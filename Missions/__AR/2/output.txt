// export function CustomInitMacro ; begin
   0: LD_INT 0
   2: PPUSH
// end ;
   3: LD_VAR 0 1
   7: RET
// export function CustomEvent ( event ) ; begin
   8: LD_INT 0
  10: PPUSH
// end ;
  11: LD_VAR 0 2
  15: RET
// export function myFun ; begin
  16: LD_INT 0
  18: PPUSH
// result := true ;
  19: LD_ADDR_VAR 0 1
  23: PUSH
  24: LD_INT 1
  26: ST_TO_ADDR
// display_strings := tick ;
  27: LD_ADDR_OWVAR 47
  31: PUSH
  32: LD_OWVAR 1
  36: ST_TO_ADDR
// wait ( 0 0$1 ) ;
  37: LD_INT 35
  39: PPUSH
  40: CALL_OW 67
// if tick > 350 then
  44: LD_OWVAR 1
  48: PUSH
  49: LD_INT 350
  51: GREATER
  52: IFFALSE 62
// result := false ;
  54: LD_ADDR_VAR 0 1
  58: PUSH
  59: LD_INT 0
  61: ST_TO_ADDR
// end ;
  62: LD_VAR 0 1
  66: RET
// starting begin ResetFog ;
  67: CALL_OW 335
// while ( myFun ) do
  71: CALL 16 0 0
  75: IFFALSE 79
// end ; end_of_file
  77: GO 71
  79: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
  80: LD_INT 0
  82: PPUSH
// ar_miner := 81 ;
  83: LD_ADDR_EXP 8
  87: PUSH
  88: LD_INT 81
  90: ST_TO_ADDR
// ar_crane := 88 ;
  91: LD_ADDR_EXP 7
  95: PUSH
  96: LD_INT 88
  98: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
  99: LD_ADDR_EXP 2
 103: PUSH
 104: LD_INT 89
 106: ST_TO_ADDR
// us_hack := 99 ;
 107: LD_ADDR_EXP 3
 111: PUSH
 112: LD_INT 99
 114: ST_TO_ADDR
// us_artillery := 97 ;
 115: LD_ADDR_EXP 4
 119: PUSH
 120: LD_INT 97
 122: ST_TO_ADDR
// ar_bio_bomb := 91 ;
 123: LD_ADDR_EXP 5
 127: PUSH
 128: LD_INT 91
 130: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
 131: LD_ADDR_EXP 6
 135: PUSH
 136: LD_INT 92
 138: ST_TO_ADDR
// ru_radar := 98 ;
 139: LD_ADDR_EXP 1
 143: PUSH
 144: LD_INT 98
 146: ST_TO_ADDR
// tech_Artillery := 80 ;
 147: LD_ADDR_EXP 9
 151: PUSH
 152: LD_INT 80
 154: ST_TO_ADDR
// tech_RadMat := 81 ;
 155: LD_ADDR_EXP 10
 159: PUSH
 160: LD_INT 81
 162: ST_TO_ADDR
// tech_BasicTools := 82 ;
 163: LD_ADDR_EXP 11
 167: PUSH
 168: LD_INT 82
 170: ST_TO_ADDR
// tech_Cargo := 83 ;
 171: LD_ADDR_EXP 12
 175: PUSH
 176: LD_INT 83
 178: ST_TO_ADDR
// tech_Track := 84 ;
 179: LD_ADDR_EXP 13
 183: PUSH
 184: LD_INT 84
 186: ST_TO_ADDR
// tech_Crane := 85 ;
 187: LD_ADDR_EXP 14
 191: PUSH
 192: LD_INT 85
 194: ST_TO_ADDR
// tech_Bulldozer := 86 ;
 195: LD_ADDR_EXP 15
 199: PUSH
 200: LD_INT 86
 202: ST_TO_ADDR
// tech_Hovercraft := 87 ;
 203: LD_ADDR_EXP 16
 207: PUSH
 208: LD_INT 87
 210: ST_TO_ADDR
// end ;
 211: LD_VAR 0 1
 215: RET
// every 1 do
 216: GO 218
 218: DISABLE
// InitGlobalVariables ; end_of_file
 219: CALL 80 0 0
 223: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
 224: LD_VAR 0 2
 228: PUSH
 229: LD_INT 100
 231: EQUAL
 232: IFFALSE 1181
// begin if not StreamModeActive then
 234: LD_EXP 17
 238: NOT
 239: IFFALSE 249
// StreamModeActive := true ;
 241: LD_ADDR_EXP 17
 245: PUSH
 246: LD_INT 1
 248: ST_TO_ADDR
// if p3 = 0 then
 249: LD_VAR 0 3
 253: PUSH
 254: LD_INT 0
 256: EQUAL
 257: IFFALSE 263
// InitStreamMode ;
 259: CALL 1339 0 0
// if p3 = 1 then
 263: LD_VAR 0 3
 267: PUSH
 268: LD_INT 1
 270: EQUAL
 271: IFFALSE 281
// sRocket := true ;
 273: LD_ADDR_EXP 22
 277: PUSH
 278: LD_INT 1
 280: ST_TO_ADDR
// if p3 = 2 then
 281: LD_VAR 0 3
 285: PUSH
 286: LD_INT 2
 288: EQUAL
 289: IFFALSE 299
// sSpeed := true ;
 291: LD_ADDR_EXP 21
 295: PUSH
 296: LD_INT 1
 298: ST_TO_ADDR
// if p3 = 3 then
 299: LD_VAR 0 3
 303: PUSH
 304: LD_INT 3
 306: EQUAL
 307: IFFALSE 317
// sEngine := true ;
 309: LD_ADDR_EXP 23
 313: PUSH
 314: LD_INT 1
 316: ST_TO_ADDR
// if p3 = 4 then
 317: LD_VAR 0 3
 321: PUSH
 322: LD_INT 4
 324: EQUAL
 325: IFFALSE 335
// sSpec := true ;
 327: LD_ADDR_EXP 20
 331: PUSH
 332: LD_INT 1
 334: ST_TO_ADDR
// if p3 = 5 then
 335: LD_VAR 0 3
 339: PUSH
 340: LD_INT 5
 342: EQUAL
 343: IFFALSE 353
// sLevel := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// if p3 = 6 then
 353: LD_VAR 0 3
 357: PUSH
 358: LD_INT 6
 360: EQUAL
 361: IFFALSE 371
// sArmoury := true ;
 363: LD_ADDR_EXP 25
 367: PUSH
 368: LD_INT 1
 370: ST_TO_ADDR
// if p3 = 7 then
 371: LD_VAR 0 3
 375: PUSH
 376: LD_INT 7
 378: EQUAL
 379: IFFALSE 389
// sRadar := true ;
 381: LD_ADDR_EXP 26
 385: PUSH
 386: LD_INT 1
 388: ST_TO_ADDR
// if p3 = 8 then
 389: LD_VAR 0 3
 393: PUSH
 394: LD_INT 8
 396: EQUAL
 397: IFFALSE 407
// sBunker := true ;
 399: LD_ADDR_EXP 27
 403: PUSH
 404: LD_INT 1
 406: ST_TO_ADDR
// if p3 = 9 then
 407: LD_VAR 0 3
 411: PUSH
 412: LD_INT 9
 414: EQUAL
 415: IFFALSE 425
// sHack := true ;
 417: LD_ADDR_EXP 28
 421: PUSH
 422: LD_INT 1
 424: ST_TO_ADDR
// if p3 = 10 then
 425: LD_VAR 0 3
 429: PUSH
 430: LD_INT 10
 432: EQUAL
 433: IFFALSE 443
// sFire := true ;
 435: LD_ADDR_EXP 29
 439: PUSH
 440: LD_INT 1
 442: ST_TO_ADDR
// if p3 = 11 then
 443: LD_VAR 0 3
 447: PUSH
 448: LD_INT 11
 450: EQUAL
 451: IFFALSE 461
// sRefresh := true ;
 453: LD_ADDR_EXP 30
 457: PUSH
 458: LD_INT 1
 460: ST_TO_ADDR
// if p3 = 12 then
 461: LD_VAR 0 3
 465: PUSH
 466: LD_INT 12
 468: EQUAL
 469: IFFALSE 479
// sExp := true ;
 471: LD_ADDR_EXP 31
 475: PUSH
 476: LD_INT 1
 478: ST_TO_ADDR
// if p3 = 13 then
 479: LD_VAR 0 3
 483: PUSH
 484: LD_INT 13
 486: EQUAL
 487: IFFALSE 497
// sDepot := true ;
 489: LD_ADDR_EXP 32
 493: PUSH
 494: LD_INT 1
 496: ST_TO_ADDR
// if p3 = 14 then
 497: LD_VAR 0 3
 501: PUSH
 502: LD_INT 14
 504: EQUAL
 505: IFFALSE 515
// sFlag := true ;
 507: LD_ADDR_EXP 33
 511: PUSH
 512: LD_INT 1
 514: ST_TO_ADDR
// if p3 = 15 then
 515: LD_VAR 0 3
 519: PUSH
 520: LD_INT 15
 522: EQUAL
 523: IFFALSE 533
// sKamikadze := true ;
 525: LD_ADDR_EXP 41
 529: PUSH
 530: LD_INT 1
 532: ST_TO_ADDR
// if p3 = 16 then
 533: LD_VAR 0 3
 537: PUSH
 538: LD_INT 16
 540: EQUAL
 541: IFFALSE 551
// sTroll := true ;
 543: LD_ADDR_EXP 42
 547: PUSH
 548: LD_INT 1
 550: ST_TO_ADDR
// if p3 = 17 then
 551: LD_VAR 0 3
 555: PUSH
 556: LD_INT 17
 558: EQUAL
 559: IFFALSE 569
// sSlow := true ;
 561: LD_ADDR_EXP 43
 565: PUSH
 566: LD_INT 1
 568: ST_TO_ADDR
// if p3 = 18 then
 569: LD_VAR 0 3
 573: PUSH
 574: LD_INT 18
 576: EQUAL
 577: IFFALSE 587
// sLack := true ;
 579: LD_ADDR_EXP 44
 583: PUSH
 584: LD_INT 1
 586: ST_TO_ADDR
// if p3 = 19 then
 587: LD_VAR 0 3
 591: PUSH
 592: LD_INT 19
 594: EQUAL
 595: IFFALSE 605
// sTank := true ;
 597: LD_ADDR_EXP 46
 601: PUSH
 602: LD_INT 1
 604: ST_TO_ADDR
// if p3 = 20 then
 605: LD_VAR 0 3
 609: PUSH
 610: LD_INT 20
 612: EQUAL
 613: IFFALSE 623
// sRemote := true ;
 615: LD_ADDR_EXP 47
 619: PUSH
 620: LD_INT 1
 622: ST_TO_ADDR
// if p3 = 21 then
 623: LD_VAR 0 3
 627: PUSH
 628: LD_INT 21
 630: EQUAL
 631: IFFALSE 641
// sPowell := true ;
 633: LD_ADDR_EXP 48
 637: PUSH
 638: LD_INT 1
 640: ST_TO_ADDR
// if p3 = 22 then
 641: LD_VAR 0 3
 645: PUSH
 646: LD_INT 22
 648: EQUAL
 649: IFFALSE 659
// sTeleport := true ;
 651: LD_ADDR_EXP 51
 655: PUSH
 656: LD_INT 1
 658: ST_TO_ADDR
// if p3 = 23 then
 659: LD_VAR 0 3
 663: PUSH
 664: LD_INT 23
 666: EQUAL
 667: IFFALSE 677
// sOilTower := true ;
 669: LD_ADDR_EXP 53
 673: PUSH
 674: LD_INT 1
 676: ST_TO_ADDR
// if p3 = 24 then
 677: LD_VAR 0 3
 681: PUSH
 682: LD_INT 24
 684: EQUAL
 685: IFFALSE 695
// sShovel := true ;
 687: LD_ADDR_EXP 54
 691: PUSH
 692: LD_INT 1
 694: ST_TO_ADDR
// if p3 = 25 then
 695: LD_VAR 0 3
 699: PUSH
 700: LD_INT 25
 702: EQUAL
 703: IFFALSE 713
// sSheik := true ;
 705: LD_ADDR_EXP 55
 709: PUSH
 710: LD_INT 1
 712: ST_TO_ADDR
// if p3 = 26 then
 713: LD_VAR 0 3
 717: PUSH
 718: LD_INT 26
 720: EQUAL
 721: IFFALSE 731
// sEarthquake := true ;
 723: LD_ADDR_EXP 57
 727: PUSH
 728: LD_INT 1
 730: ST_TO_ADDR
// if p3 = 27 then
 731: LD_VAR 0 3
 735: PUSH
 736: LD_INT 27
 738: EQUAL
 739: IFFALSE 749
// sAI := true ;
 741: LD_ADDR_EXP 58
 745: PUSH
 746: LD_INT 1
 748: ST_TO_ADDR
// if p3 = 28 then
 749: LD_VAR 0 3
 753: PUSH
 754: LD_INT 28
 756: EQUAL
 757: IFFALSE 767
// sCargo := true ;
 759: LD_ADDR_EXP 61
 763: PUSH
 764: LD_INT 1
 766: ST_TO_ADDR
// if p3 = 29 then
 767: LD_VAR 0 3
 771: PUSH
 772: LD_INT 29
 774: EQUAL
 775: IFFALSE 785
// sDLaser := true ;
 777: LD_ADDR_EXP 62
 781: PUSH
 782: LD_INT 1
 784: ST_TO_ADDR
// if p3 = 30 then
 785: LD_VAR 0 3
 789: PUSH
 790: LD_INT 30
 792: EQUAL
 793: IFFALSE 803
// sExchange := true ;
 795: LD_ADDR_EXP 63
 799: PUSH
 800: LD_INT 1
 802: ST_TO_ADDR
// if p3 = 31 then
 803: LD_VAR 0 3
 807: PUSH
 808: LD_INT 31
 810: EQUAL
 811: IFFALSE 821
// sFac := true ;
 813: LD_ADDR_EXP 64
 817: PUSH
 818: LD_INT 1
 820: ST_TO_ADDR
// if p3 = 32 then
 821: LD_VAR 0 3
 825: PUSH
 826: LD_INT 32
 828: EQUAL
 829: IFFALSE 839
// sPower := true ;
 831: LD_ADDR_EXP 65
 835: PUSH
 836: LD_INT 1
 838: ST_TO_ADDR
// if p3 = 33 then
 839: LD_VAR 0 3
 843: PUSH
 844: LD_INT 33
 846: EQUAL
 847: IFFALSE 857
// sRandom := true ;
 849: LD_ADDR_EXP 66
 853: PUSH
 854: LD_INT 1
 856: ST_TO_ADDR
// if p3 = 34 then
 857: LD_VAR 0 3
 861: PUSH
 862: LD_INT 34
 864: EQUAL
 865: IFFALSE 875
// sShield := true ;
 867: LD_ADDR_EXP 67
 871: PUSH
 872: LD_INT 1
 874: ST_TO_ADDR
// if p3 = 35 then
 875: LD_VAR 0 3
 879: PUSH
 880: LD_INT 35
 882: EQUAL
 883: IFFALSE 893
// sTime := true ;
 885: LD_ADDR_EXP 68
 889: PUSH
 890: LD_INT 1
 892: ST_TO_ADDR
// if p3 = 36 then
 893: LD_VAR 0 3
 897: PUSH
 898: LD_INT 36
 900: EQUAL
 901: IFFALSE 911
// sTools := true ;
 903: LD_ADDR_EXP 69
 907: PUSH
 908: LD_INT 1
 910: ST_TO_ADDR
// if p3 = 101 then
 911: LD_VAR 0 3
 915: PUSH
 916: LD_INT 101
 918: EQUAL
 919: IFFALSE 929
// sSold := true ;
 921: LD_ADDR_EXP 34
 925: PUSH
 926: LD_INT 1
 928: ST_TO_ADDR
// if p3 = 102 then
 929: LD_VAR 0 3
 933: PUSH
 934: LD_INT 102
 936: EQUAL
 937: IFFALSE 947
// sDiff := true ;
 939: LD_ADDR_EXP 35
 943: PUSH
 944: LD_INT 1
 946: ST_TO_ADDR
// if p3 = 103 then
 947: LD_VAR 0 3
 951: PUSH
 952: LD_INT 103
 954: EQUAL
 955: IFFALSE 965
// sFog := true ;
 957: LD_ADDR_EXP 38
 961: PUSH
 962: LD_INT 1
 964: ST_TO_ADDR
// if p3 = 104 then
 965: LD_VAR 0 3
 969: PUSH
 970: LD_INT 104
 972: EQUAL
 973: IFFALSE 983
// sReset := true ;
 975: LD_ADDR_EXP 39
 979: PUSH
 980: LD_INT 1
 982: ST_TO_ADDR
// if p3 = 105 then
 983: LD_VAR 0 3
 987: PUSH
 988: LD_INT 105
 990: EQUAL
 991: IFFALSE 1001
// sSun := true ;
 993: LD_ADDR_EXP 40
 997: PUSH
 998: LD_INT 1
1000: ST_TO_ADDR
// if p3 = 106 then
1001: LD_VAR 0 3
1005: PUSH
1006: LD_INT 106
1008: EQUAL
1009: IFFALSE 1019
// sTiger := true ;
1011: LD_ADDR_EXP 36
1015: PUSH
1016: LD_INT 1
1018: ST_TO_ADDR
// if p3 = 107 then
1019: LD_VAR 0 3
1023: PUSH
1024: LD_INT 107
1026: EQUAL
1027: IFFALSE 1037
// sBomb := true ;
1029: LD_ADDR_EXP 37
1033: PUSH
1034: LD_INT 1
1036: ST_TO_ADDR
// if p3 = 108 then
1037: LD_VAR 0 3
1041: PUSH
1042: LD_INT 108
1044: EQUAL
1045: IFFALSE 1055
// sWound := true ;
1047: LD_ADDR_EXP 45
1051: PUSH
1052: LD_INT 1
1054: ST_TO_ADDR
// if p3 = 109 then
1055: LD_VAR 0 3
1059: PUSH
1060: LD_INT 109
1062: EQUAL
1063: IFFALSE 1073
// sBetray := true ;
1065: LD_ADDR_EXP 49
1069: PUSH
1070: LD_INT 1
1072: ST_TO_ADDR
// if p3 = 110 then
1073: LD_VAR 0 3
1077: PUSH
1078: LD_INT 110
1080: EQUAL
1081: IFFALSE 1091
// sContamin := true ;
1083: LD_ADDR_EXP 50
1087: PUSH
1088: LD_INT 1
1090: ST_TO_ADDR
// if p3 = 111 then
1091: LD_VAR 0 3
1095: PUSH
1096: LD_INT 111
1098: EQUAL
1099: IFFALSE 1109
// sOil := true ;
1101: LD_ADDR_EXP 52
1105: PUSH
1106: LD_INT 1
1108: ST_TO_ADDR
// if p3 = 112 then
1109: LD_VAR 0 3
1113: PUSH
1114: LD_INT 112
1116: EQUAL
1117: IFFALSE 1127
// sStu := true ;
1119: LD_ADDR_EXP 56
1123: PUSH
1124: LD_INT 1
1126: ST_TO_ADDR
// if p3 = 113 then
1127: LD_VAR 0 3
1131: PUSH
1132: LD_INT 113
1134: EQUAL
1135: IFFALSE 1145
// sBazooka := true ;
1137: LD_ADDR_EXP 59
1141: PUSH
1142: LD_INT 1
1144: ST_TO_ADDR
// if p3 = 114 then
1145: LD_VAR 0 3
1149: PUSH
1150: LD_INT 114
1152: EQUAL
1153: IFFALSE 1163
// sMortar := true ;
1155: LD_ADDR_EXP 60
1159: PUSH
1160: LD_INT 1
1162: ST_TO_ADDR
// if p3 = 115 then
1163: LD_VAR 0 3
1167: PUSH
1168: LD_INT 115
1170: EQUAL
1171: IFFALSE 1181
// sRanger := true ;
1173: LD_ADDR_EXP 70
1177: PUSH
1178: LD_INT 1
1180: ST_TO_ADDR
// end ; if p2 = 101 then
1181: LD_VAR 0 2
1185: PUSH
1186: LD_INT 101
1188: EQUAL
1189: IFFALSE 1317
// begin case p3 of 1 :
1191: LD_VAR 0 3
1195: PUSH
1196: LD_INT 1
1198: DOUBLE
1199: EQUAL
1200: IFTRUE 1204
1202: GO 1211
1204: POP
// hHackUnlimitedResources ; 2 :
1205: CALL 12352 0 0
1209: GO 1317
1211: LD_INT 2
1213: DOUBLE
1214: EQUAL
1215: IFTRUE 1219
1217: GO 1226
1219: POP
// hHackSetLevel10 ; 3 :
1220: CALL 12485 0 0
1224: GO 1317
1226: LD_INT 3
1228: DOUBLE
1229: EQUAL
1230: IFTRUE 1234
1232: GO 1241
1234: POP
// hHackSetLevel10YourUnits ; 4 :
1235: CALL 12570 0 0
1239: GO 1317
1241: LD_INT 4
1243: DOUBLE
1244: EQUAL
1245: IFTRUE 1249
1247: GO 1256
1249: POP
// hHackInvincible ; 5 :
1250: CALL 13018 0 0
1254: GO 1317
1256: LD_INT 5
1258: DOUBLE
1259: EQUAL
1260: IFTRUE 1264
1262: GO 1271
1264: POP
// hHackInvisible ; 6 :
1265: CALL 13129 0 0
1269: GO 1317
1271: LD_INT 6
1273: DOUBLE
1274: EQUAL
1275: IFTRUE 1279
1277: GO 1286
1279: POP
// hHackChangeYourSide ; 7 :
1280: CALL 13186 0 0
1284: GO 1317
1286: LD_INT 7
1288: DOUBLE
1289: EQUAL
1290: IFTRUE 1294
1292: GO 1301
1294: POP
// hHackChangeUnitSide ; 8 :
1295: CALL 13228 0 0
1299: GO 1317
1301: LD_INT 8
1303: DOUBLE
1304: EQUAL
1305: IFTRUE 1309
1307: GO 1316
1309: POP
// hHackFog ; end ;
1310: CALL 13329 0 0
1314: GO 1317
1316: POP
// end ; end ;
1317: PPOPN 6
1319: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
1320: GO 1322
1322: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
1323: LD_STRING initStreamRollete();
1325: PPUSH
1326: CALL_OW 559
// InitStreamMode ;
1330: CALL 1339 0 0
// DefineStreamItems ( ) ;
1334: CALL 1779 0 0
// end ;
1338: END
// function InitStreamMode ; begin
1339: LD_INT 0
1341: PPUSH
// streamModeActive := false ;
1342: LD_ADDR_EXP 17
1346: PUSH
1347: LD_INT 0
1349: ST_TO_ADDR
// normalCounter := 36 ;
1350: LD_ADDR_EXP 18
1354: PUSH
1355: LD_INT 36
1357: ST_TO_ADDR
// hardcoreCounter := 16 ;
1358: LD_ADDR_EXP 19
1362: PUSH
1363: LD_INT 16
1365: ST_TO_ADDR
// sRocket := false ;
1366: LD_ADDR_EXP 22
1370: PUSH
1371: LD_INT 0
1373: ST_TO_ADDR
// sSpeed := false ;
1374: LD_ADDR_EXP 21
1378: PUSH
1379: LD_INT 0
1381: ST_TO_ADDR
// sEngine := false ;
1382: LD_ADDR_EXP 23
1386: PUSH
1387: LD_INT 0
1389: ST_TO_ADDR
// sSpec := false ;
1390: LD_ADDR_EXP 20
1394: PUSH
1395: LD_INT 0
1397: ST_TO_ADDR
// sLevel := false ;
1398: LD_ADDR_EXP 24
1402: PUSH
1403: LD_INT 0
1405: ST_TO_ADDR
// sArmoury := false ;
1406: LD_ADDR_EXP 25
1410: PUSH
1411: LD_INT 0
1413: ST_TO_ADDR
// sRadar := false ;
1414: LD_ADDR_EXP 26
1418: PUSH
1419: LD_INT 0
1421: ST_TO_ADDR
// sBunker := false ;
1422: LD_ADDR_EXP 27
1426: PUSH
1427: LD_INT 0
1429: ST_TO_ADDR
// sHack := false ;
1430: LD_ADDR_EXP 28
1434: PUSH
1435: LD_INT 0
1437: ST_TO_ADDR
// sFire := false ;
1438: LD_ADDR_EXP 29
1442: PUSH
1443: LD_INT 0
1445: ST_TO_ADDR
// sRefresh := false ;
1446: LD_ADDR_EXP 30
1450: PUSH
1451: LD_INT 0
1453: ST_TO_ADDR
// sExp := false ;
1454: LD_ADDR_EXP 31
1458: PUSH
1459: LD_INT 0
1461: ST_TO_ADDR
// sDepot := false ;
1462: LD_ADDR_EXP 32
1466: PUSH
1467: LD_INT 0
1469: ST_TO_ADDR
// sFlag := false ;
1470: LD_ADDR_EXP 33
1474: PUSH
1475: LD_INT 0
1477: ST_TO_ADDR
// sKamikadze := false ;
1478: LD_ADDR_EXP 41
1482: PUSH
1483: LD_INT 0
1485: ST_TO_ADDR
// sTroll := false ;
1486: LD_ADDR_EXP 42
1490: PUSH
1491: LD_INT 0
1493: ST_TO_ADDR
// sSlow := false ;
1494: LD_ADDR_EXP 43
1498: PUSH
1499: LD_INT 0
1501: ST_TO_ADDR
// sLack := false ;
1502: LD_ADDR_EXP 44
1506: PUSH
1507: LD_INT 0
1509: ST_TO_ADDR
// sTank := false ;
1510: LD_ADDR_EXP 46
1514: PUSH
1515: LD_INT 0
1517: ST_TO_ADDR
// sRemote := false ;
1518: LD_ADDR_EXP 47
1522: PUSH
1523: LD_INT 0
1525: ST_TO_ADDR
// sPowell := false ;
1526: LD_ADDR_EXP 48
1530: PUSH
1531: LD_INT 0
1533: ST_TO_ADDR
// sTeleport := false ;
1534: LD_ADDR_EXP 51
1538: PUSH
1539: LD_INT 0
1541: ST_TO_ADDR
// sOilTower := false ;
1542: LD_ADDR_EXP 53
1546: PUSH
1547: LD_INT 0
1549: ST_TO_ADDR
// sShovel := false ;
1550: LD_ADDR_EXP 54
1554: PUSH
1555: LD_INT 0
1557: ST_TO_ADDR
// sSheik := false ;
1558: LD_ADDR_EXP 55
1562: PUSH
1563: LD_INT 0
1565: ST_TO_ADDR
// sEarthquake := false ;
1566: LD_ADDR_EXP 57
1570: PUSH
1571: LD_INT 0
1573: ST_TO_ADDR
// sAI := false ;
1574: LD_ADDR_EXP 58
1578: PUSH
1579: LD_INT 0
1581: ST_TO_ADDR
// sCargo := false ;
1582: LD_ADDR_EXP 61
1586: PUSH
1587: LD_INT 0
1589: ST_TO_ADDR
// sDLaser := false ;
1590: LD_ADDR_EXP 62
1594: PUSH
1595: LD_INT 0
1597: ST_TO_ADDR
// sExchange := false ;
1598: LD_ADDR_EXP 63
1602: PUSH
1603: LD_INT 0
1605: ST_TO_ADDR
// sFac := false ;
1606: LD_ADDR_EXP 64
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// sPower := false ;
1614: LD_ADDR_EXP 65
1618: PUSH
1619: LD_INT 0
1621: ST_TO_ADDR
// sRandom := false ;
1622: LD_ADDR_EXP 66
1626: PUSH
1627: LD_INT 0
1629: ST_TO_ADDR
// sShield := false ;
1630: LD_ADDR_EXP 67
1634: PUSH
1635: LD_INT 0
1637: ST_TO_ADDR
// sTime := false ;
1638: LD_ADDR_EXP 68
1642: PUSH
1643: LD_INT 0
1645: ST_TO_ADDR
// sTools := false ;
1646: LD_ADDR_EXP 69
1650: PUSH
1651: LD_INT 0
1653: ST_TO_ADDR
// sSold := false ;
1654: LD_ADDR_EXP 34
1658: PUSH
1659: LD_INT 0
1661: ST_TO_ADDR
// sDiff := false ;
1662: LD_ADDR_EXP 35
1666: PUSH
1667: LD_INT 0
1669: ST_TO_ADDR
// sFog := false ;
1670: LD_ADDR_EXP 38
1674: PUSH
1675: LD_INT 0
1677: ST_TO_ADDR
// sReset := false ;
1678: LD_ADDR_EXP 39
1682: PUSH
1683: LD_INT 0
1685: ST_TO_ADDR
// sSun := false ;
1686: LD_ADDR_EXP 40
1690: PUSH
1691: LD_INT 0
1693: ST_TO_ADDR
// sTiger := false ;
1694: LD_ADDR_EXP 36
1698: PUSH
1699: LD_INT 0
1701: ST_TO_ADDR
// sBomb := false ;
1702: LD_ADDR_EXP 37
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// sWound := false ;
1710: LD_ADDR_EXP 45
1714: PUSH
1715: LD_INT 0
1717: ST_TO_ADDR
// sBetray := false ;
1718: LD_ADDR_EXP 49
1722: PUSH
1723: LD_INT 0
1725: ST_TO_ADDR
// sContamin := false ;
1726: LD_ADDR_EXP 50
1730: PUSH
1731: LD_INT 0
1733: ST_TO_ADDR
// sOil := false ;
1734: LD_ADDR_EXP 52
1738: PUSH
1739: LD_INT 0
1741: ST_TO_ADDR
// sStu := false ;
1742: LD_ADDR_EXP 56
1746: PUSH
1747: LD_INT 0
1749: ST_TO_ADDR
// sBazooka := false ;
1750: LD_ADDR_EXP 59
1754: PUSH
1755: LD_INT 0
1757: ST_TO_ADDR
// sMortar := false ;
1758: LD_ADDR_EXP 60
1762: PUSH
1763: LD_INT 0
1765: ST_TO_ADDR
// sRanger := false ;
1766: LD_ADDR_EXP 70
1770: PUSH
1771: LD_INT 0
1773: ST_TO_ADDR
// end ;
1774: LD_VAR 0 1
1778: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
1779: LD_INT 0
1781: PPUSH
1782: PPUSH
1783: PPUSH
1784: PPUSH
1785: PPUSH
// result := [ ] ;
1786: LD_ADDR_VAR 0 1
1790: PUSH
1791: EMPTY
1792: ST_TO_ADDR
// if campaign_id = 1 then
1793: LD_OWVAR 69
1797: PUSH
1798: LD_INT 1
1800: EQUAL
1801: IFFALSE 4739
// begin case mission_number of 1 :
1803: LD_OWVAR 70
1807: PUSH
1808: LD_INT 1
1810: DOUBLE
1811: EQUAL
1812: IFTRUE 1816
1814: GO 1880
1816: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
1817: LD_ADDR_VAR 0 1
1821: PUSH
1822: LD_INT 2
1824: PUSH
1825: LD_INT 4
1827: PUSH
1828: LD_INT 11
1830: PUSH
1831: LD_INT 12
1833: PUSH
1834: LD_INT 15
1836: PUSH
1837: LD_INT 16
1839: PUSH
1840: LD_INT 22
1842: PUSH
1843: LD_INT 23
1845: PUSH
1846: LD_INT 26
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: PUSH
1860: LD_INT 101
1862: PUSH
1863: LD_INT 102
1865: PUSH
1866: LD_INT 106
1868: PUSH
1869: EMPTY
1870: LIST
1871: LIST
1872: LIST
1873: PUSH
1874: EMPTY
1875: LIST
1876: LIST
1877: ST_TO_ADDR
1878: GO 4737
1880: LD_INT 2
1882: DOUBLE
1883: EQUAL
1884: IFTRUE 1888
1886: GO 1960
1888: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
1889: LD_ADDR_VAR 0 1
1893: PUSH
1894: LD_INT 2
1896: PUSH
1897: LD_INT 4
1899: PUSH
1900: LD_INT 11
1902: PUSH
1903: LD_INT 12
1905: PUSH
1906: LD_INT 15
1908: PUSH
1909: LD_INT 16
1911: PUSH
1912: LD_INT 22
1914: PUSH
1915: LD_INT 23
1917: PUSH
1918: LD_INT 26
1920: PUSH
1921: EMPTY
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: LIST
1931: PUSH
1932: LD_INT 101
1934: PUSH
1935: LD_INT 102
1937: PUSH
1938: LD_INT 105
1940: PUSH
1941: LD_INT 106
1943: PUSH
1944: LD_INT 108
1946: PUSH
1947: EMPTY
1948: LIST
1949: LIST
1950: LIST
1951: LIST
1952: LIST
1953: PUSH
1954: EMPTY
1955: LIST
1956: LIST
1957: ST_TO_ADDR
1958: GO 4737
1960: LD_INT 3
1962: DOUBLE
1963: EQUAL
1964: IFTRUE 1968
1966: GO 2044
1968: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
1969: LD_ADDR_VAR 0 1
1973: PUSH
1974: LD_INT 2
1976: PUSH
1977: LD_INT 4
1979: PUSH
1980: LD_INT 5
1982: PUSH
1983: LD_INT 11
1985: PUSH
1986: LD_INT 12
1988: PUSH
1989: LD_INT 15
1991: PUSH
1992: LD_INT 16
1994: PUSH
1995: LD_INT 22
1997: PUSH
1998: LD_INT 26
2000: PUSH
2001: LD_INT 36
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: PUSH
2016: LD_INT 101
2018: PUSH
2019: LD_INT 102
2021: PUSH
2022: LD_INT 105
2024: PUSH
2025: LD_INT 106
2027: PUSH
2028: LD_INT 108
2030: PUSH
2031: EMPTY
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: ST_TO_ADDR
2042: GO 4737
2044: LD_INT 4
2046: DOUBLE
2047: EQUAL
2048: IFTRUE 2052
2050: GO 2136
2052: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
2053: LD_ADDR_VAR 0 1
2057: PUSH
2058: LD_INT 2
2060: PUSH
2061: LD_INT 4
2063: PUSH
2064: LD_INT 5
2066: PUSH
2067: LD_INT 8
2069: PUSH
2070: LD_INT 11
2072: PUSH
2073: LD_INT 12
2075: PUSH
2076: LD_INT 15
2078: PUSH
2079: LD_INT 16
2081: PUSH
2082: LD_INT 22
2084: PUSH
2085: LD_INT 23
2087: PUSH
2088: LD_INT 26
2090: PUSH
2091: LD_INT 36
2093: PUSH
2094: EMPTY
2095: LIST
2096: LIST
2097: LIST
2098: LIST
2099: LIST
2100: LIST
2101: LIST
2102: LIST
2103: LIST
2104: LIST
2105: LIST
2106: LIST
2107: PUSH
2108: LD_INT 101
2110: PUSH
2111: LD_INT 102
2113: PUSH
2114: LD_INT 105
2116: PUSH
2117: LD_INT 106
2119: PUSH
2120: LD_INT 108
2122: PUSH
2123: EMPTY
2124: LIST
2125: LIST
2126: LIST
2127: LIST
2128: LIST
2129: PUSH
2130: EMPTY
2131: LIST
2132: LIST
2133: ST_TO_ADDR
2134: GO 4737
2136: LD_INT 5
2138: DOUBLE
2139: EQUAL
2140: IFTRUE 2144
2142: GO 2244
2144: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
2145: LD_ADDR_VAR 0 1
2149: PUSH
2150: LD_INT 2
2152: PUSH
2153: LD_INT 4
2155: PUSH
2156: LD_INT 5
2158: PUSH
2159: LD_INT 6
2161: PUSH
2162: LD_INT 8
2164: PUSH
2165: LD_INT 11
2167: PUSH
2168: LD_INT 12
2170: PUSH
2171: LD_INT 15
2173: PUSH
2174: LD_INT 16
2176: PUSH
2177: LD_INT 22
2179: PUSH
2180: LD_INT 23
2182: PUSH
2183: LD_INT 25
2185: PUSH
2186: LD_INT 26
2188: PUSH
2189: LD_INT 36
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: LIST
2202: LIST
2203: LIST
2204: LIST
2205: LIST
2206: LIST
2207: PUSH
2208: LD_INT 101
2210: PUSH
2211: LD_INT 102
2213: PUSH
2214: LD_INT 105
2216: PUSH
2217: LD_INT 106
2219: PUSH
2220: LD_INT 108
2222: PUSH
2223: LD_INT 109
2225: PUSH
2226: LD_INT 112
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: LIST
2233: LIST
2234: LIST
2235: LIST
2236: LIST
2237: PUSH
2238: EMPTY
2239: LIST
2240: LIST
2241: ST_TO_ADDR
2242: GO 4737
2244: LD_INT 6
2246: DOUBLE
2247: EQUAL
2248: IFTRUE 2252
2250: GO 2372
2252: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
2253: LD_ADDR_VAR 0 1
2257: PUSH
2258: LD_INT 2
2260: PUSH
2261: LD_INT 4
2263: PUSH
2264: LD_INT 5
2266: PUSH
2267: LD_INT 6
2269: PUSH
2270: LD_INT 8
2272: PUSH
2273: LD_INT 11
2275: PUSH
2276: LD_INT 12
2278: PUSH
2279: LD_INT 15
2281: PUSH
2282: LD_INT 16
2284: PUSH
2285: LD_INT 20
2287: PUSH
2288: LD_INT 21
2290: PUSH
2291: LD_INT 22
2293: PUSH
2294: LD_INT 23
2296: PUSH
2297: LD_INT 25
2299: PUSH
2300: LD_INT 26
2302: PUSH
2303: LD_INT 30
2305: PUSH
2306: LD_INT 31
2308: PUSH
2309: LD_INT 32
2311: PUSH
2312: LD_INT 36
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: LIST
2319: LIST
2320: LIST
2321: LIST
2322: LIST
2323: LIST
2324: LIST
2325: LIST
2326: LIST
2327: LIST
2328: LIST
2329: LIST
2330: LIST
2331: LIST
2332: LIST
2333: LIST
2334: LIST
2335: PUSH
2336: LD_INT 101
2338: PUSH
2339: LD_INT 102
2341: PUSH
2342: LD_INT 105
2344: PUSH
2345: LD_INT 106
2347: PUSH
2348: LD_INT 108
2350: PUSH
2351: LD_INT 109
2353: PUSH
2354: LD_INT 112
2356: PUSH
2357: EMPTY
2358: LIST
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: LIST
2364: LIST
2365: PUSH
2366: EMPTY
2367: LIST
2368: LIST
2369: ST_TO_ADDR
2370: GO 4737
2372: LD_INT 7
2374: DOUBLE
2375: EQUAL
2376: IFTRUE 2380
2378: GO 2480
2380: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
2381: LD_ADDR_VAR 0 1
2385: PUSH
2386: LD_INT 2
2388: PUSH
2389: LD_INT 4
2391: PUSH
2392: LD_INT 5
2394: PUSH
2395: LD_INT 7
2397: PUSH
2398: LD_INT 11
2400: PUSH
2401: LD_INT 12
2403: PUSH
2404: LD_INT 15
2406: PUSH
2407: LD_INT 16
2409: PUSH
2410: LD_INT 20
2412: PUSH
2413: LD_INT 21
2415: PUSH
2416: LD_INT 22
2418: PUSH
2419: LD_INT 23
2421: PUSH
2422: LD_INT 25
2424: PUSH
2425: LD_INT 26
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: LIST
2436: LIST
2437: LIST
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 101
2446: PUSH
2447: LD_INT 102
2449: PUSH
2450: LD_INT 103
2452: PUSH
2453: LD_INT 105
2455: PUSH
2456: LD_INT 106
2458: PUSH
2459: LD_INT 108
2461: PUSH
2462: LD_INT 112
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: LIST
2469: LIST
2470: LIST
2471: LIST
2472: LIST
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: ST_TO_ADDR
2478: GO 4737
2480: LD_INT 8
2482: DOUBLE
2483: EQUAL
2484: IFTRUE 2488
2486: GO 2616
2488: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
2489: LD_ADDR_VAR 0 1
2493: PUSH
2494: LD_INT 2
2496: PUSH
2497: LD_INT 4
2499: PUSH
2500: LD_INT 5
2502: PUSH
2503: LD_INT 6
2505: PUSH
2506: LD_INT 7
2508: PUSH
2509: LD_INT 8
2511: PUSH
2512: LD_INT 11
2514: PUSH
2515: LD_INT 12
2517: PUSH
2518: LD_INT 15
2520: PUSH
2521: LD_INT 16
2523: PUSH
2524: LD_INT 20
2526: PUSH
2527: LD_INT 21
2529: PUSH
2530: LD_INT 22
2532: PUSH
2533: LD_INT 23
2535: PUSH
2536: LD_INT 25
2538: PUSH
2539: LD_INT 26
2541: PUSH
2542: LD_INT 30
2544: PUSH
2545: LD_INT 31
2547: PUSH
2548: LD_INT 32
2550: PUSH
2551: LD_INT 36
2553: PUSH
2554: EMPTY
2555: LIST
2556: LIST
2557: LIST
2558: LIST
2559: LIST
2560: LIST
2561: LIST
2562: LIST
2563: LIST
2564: LIST
2565: LIST
2566: LIST
2567: LIST
2568: LIST
2569: LIST
2570: LIST
2571: LIST
2572: LIST
2573: LIST
2574: LIST
2575: PUSH
2576: LD_INT 101
2578: PUSH
2579: LD_INT 102
2581: PUSH
2582: LD_INT 103
2584: PUSH
2585: LD_INT 105
2587: PUSH
2588: LD_INT 106
2590: PUSH
2591: LD_INT 108
2593: PUSH
2594: LD_INT 109
2596: PUSH
2597: LD_INT 112
2599: PUSH
2600: EMPTY
2601: LIST
2602: LIST
2603: LIST
2604: LIST
2605: LIST
2606: LIST
2607: LIST
2608: LIST
2609: PUSH
2610: EMPTY
2611: LIST
2612: LIST
2613: ST_TO_ADDR
2614: GO 4737
2616: LD_INT 9
2618: DOUBLE
2619: EQUAL
2620: IFTRUE 2624
2622: GO 2760
2624: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
2625: LD_ADDR_VAR 0 1
2629: PUSH
2630: LD_INT 2
2632: PUSH
2633: LD_INT 4
2635: PUSH
2636: LD_INT 5
2638: PUSH
2639: LD_INT 6
2641: PUSH
2642: LD_INT 7
2644: PUSH
2645: LD_INT 8
2647: PUSH
2648: LD_INT 11
2650: PUSH
2651: LD_INT 12
2653: PUSH
2654: LD_INT 15
2656: PUSH
2657: LD_INT 16
2659: PUSH
2660: LD_INT 20
2662: PUSH
2663: LD_INT 21
2665: PUSH
2666: LD_INT 22
2668: PUSH
2669: LD_INT 23
2671: PUSH
2672: LD_INT 25
2674: PUSH
2675: LD_INT 26
2677: PUSH
2678: LD_INT 28
2680: PUSH
2681: LD_INT 30
2683: PUSH
2684: LD_INT 31
2686: PUSH
2687: LD_INT 32
2689: PUSH
2690: LD_INT 36
2692: PUSH
2693: EMPTY
2694: LIST
2695: LIST
2696: LIST
2697: LIST
2698: LIST
2699: LIST
2700: LIST
2701: LIST
2702: LIST
2703: LIST
2704: LIST
2705: LIST
2706: LIST
2707: LIST
2708: LIST
2709: LIST
2710: LIST
2711: LIST
2712: LIST
2713: LIST
2714: LIST
2715: PUSH
2716: LD_INT 101
2718: PUSH
2719: LD_INT 102
2721: PUSH
2722: LD_INT 103
2724: PUSH
2725: LD_INT 105
2727: PUSH
2728: LD_INT 106
2730: PUSH
2731: LD_INT 108
2733: PUSH
2734: LD_INT 109
2736: PUSH
2737: LD_INT 112
2739: PUSH
2740: LD_INT 114
2742: PUSH
2743: EMPTY
2744: LIST
2745: LIST
2746: LIST
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: LIST
2752: LIST
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: ST_TO_ADDR
2758: GO 4737
2760: LD_INT 10
2762: DOUBLE
2763: EQUAL
2764: IFTRUE 2768
2766: GO 2952
2768: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
2769: LD_ADDR_VAR 0 1
2773: PUSH
2774: LD_INT 2
2776: PUSH
2777: LD_INT 4
2779: PUSH
2780: LD_INT 5
2782: PUSH
2783: LD_INT 6
2785: PUSH
2786: LD_INT 7
2788: PUSH
2789: LD_INT 8
2791: PUSH
2792: LD_INT 9
2794: PUSH
2795: LD_INT 10
2797: PUSH
2798: LD_INT 11
2800: PUSH
2801: LD_INT 12
2803: PUSH
2804: LD_INT 13
2806: PUSH
2807: LD_INT 14
2809: PUSH
2810: LD_INT 15
2812: PUSH
2813: LD_INT 16
2815: PUSH
2816: LD_INT 17
2818: PUSH
2819: LD_INT 18
2821: PUSH
2822: LD_INT 19
2824: PUSH
2825: LD_INT 20
2827: PUSH
2828: LD_INT 21
2830: PUSH
2831: LD_INT 22
2833: PUSH
2834: LD_INT 23
2836: PUSH
2837: LD_INT 24
2839: PUSH
2840: LD_INT 25
2842: PUSH
2843: LD_INT 26
2845: PUSH
2846: LD_INT 28
2848: PUSH
2849: LD_INT 30
2851: PUSH
2852: LD_INT 31
2854: PUSH
2855: LD_INT 32
2857: PUSH
2858: LD_INT 36
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: LIST
2865: LIST
2866: LIST
2867: LIST
2868: LIST
2869: LIST
2870: LIST
2871: LIST
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: LIST
2878: LIST
2879: LIST
2880: LIST
2881: LIST
2882: LIST
2883: LIST
2884: LIST
2885: LIST
2886: LIST
2887: LIST
2888: LIST
2889: LIST
2890: LIST
2891: PUSH
2892: LD_INT 101
2894: PUSH
2895: LD_INT 102
2897: PUSH
2898: LD_INT 103
2900: PUSH
2901: LD_INT 104
2903: PUSH
2904: LD_INT 105
2906: PUSH
2907: LD_INT 106
2909: PUSH
2910: LD_INT 107
2912: PUSH
2913: LD_INT 108
2915: PUSH
2916: LD_INT 109
2918: PUSH
2919: LD_INT 110
2921: PUSH
2922: LD_INT 111
2924: PUSH
2925: LD_INT 112
2927: PUSH
2928: LD_INT 114
2930: PUSH
2931: EMPTY
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: LIST
2942: LIST
2943: LIST
2944: LIST
2945: PUSH
2946: EMPTY
2947: LIST
2948: LIST
2949: ST_TO_ADDR
2950: GO 4737
2952: LD_INT 11
2954: DOUBLE
2955: EQUAL
2956: IFTRUE 2960
2958: GO 3152
2960: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
2961: LD_ADDR_VAR 0 1
2965: PUSH
2966: LD_INT 2
2968: PUSH
2969: LD_INT 3
2971: PUSH
2972: LD_INT 4
2974: PUSH
2975: LD_INT 5
2977: PUSH
2978: LD_INT 6
2980: PUSH
2981: LD_INT 7
2983: PUSH
2984: LD_INT 8
2986: PUSH
2987: LD_INT 9
2989: PUSH
2990: LD_INT 10
2992: PUSH
2993: LD_INT 11
2995: PUSH
2996: LD_INT 12
2998: PUSH
2999: LD_INT 13
3001: PUSH
3002: LD_INT 14
3004: PUSH
3005: LD_INT 15
3007: PUSH
3008: LD_INT 16
3010: PUSH
3011: LD_INT 17
3013: PUSH
3014: LD_INT 18
3016: PUSH
3017: LD_INT 19
3019: PUSH
3020: LD_INT 20
3022: PUSH
3023: LD_INT 21
3025: PUSH
3026: LD_INT 22
3028: PUSH
3029: LD_INT 23
3031: PUSH
3032: LD_INT 24
3034: PUSH
3035: LD_INT 25
3037: PUSH
3038: LD_INT 26
3040: PUSH
3041: LD_INT 28
3043: PUSH
3044: LD_INT 30
3046: PUSH
3047: LD_INT 31
3049: PUSH
3050: LD_INT 32
3052: PUSH
3053: LD_INT 34
3055: PUSH
3056: LD_INT 36
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: LIST
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: LIST
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_INT 101
3094: PUSH
3095: LD_INT 102
3097: PUSH
3098: LD_INT 103
3100: PUSH
3101: LD_INT 104
3103: PUSH
3104: LD_INT 105
3106: PUSH
3107: LD_INT 106
3109: PUSH
3110: LD_INT 107
3112: PUSH
3113: LD_INT 108
3115: PUSH
3116: LD_INT 109
3118: PUSH
3119: LD_INT 110
3121: PUSH
3122: LD_INT 111
3124: PUSH
3125: LD_INT 112
3127: PUSH
3128: LD_INT 114
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: ST_TO_ADDR
3150: GO 4737
3152: LD_INT 12
3154: DOUBLE
3155: EQUAL
3156: IFTRUE 3160
3158: GO 3368
3160: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
3161: LD_ADDR_VAR 0 1
3165: PUSH
3166: LD_INT 1
3168: PUSH
3169: LD_INT 2
3171: PUSH
3172: LD_INT 3
3174: PUSH
3175: LD_INT 4
3177: PUSH
3178: LD_INT 5
3180: PUSH
3181: LD_INT 6
3183: PUSH
3184: LD_INT 7
3186: PUSH
3187: LD_INT 8
3189: PUSH
3190: LD_INT 9
3192: PUSH
3193: LD_INT 10
3195: PUSH
3196: LD_INT 11
3198: PUSH
3199: LD_INT 12
3201: PUSH
3202: LD_INT 13
3204: PUSH
3205: LD_INT 14
3207: PUSH
3208: LD_INT 15
3210: PUSH
3211: LD_INT 16
3213: PUSH
3214: LD_INT 17
3216: PUSH
3217: LD_INT 18
3219: PUSH
3220: LD_INT 19
3222: PUSH
3223: LD_INT 20
3225: PUSH
3226: LD_INT 21
3228: PUSH
3229: LD_INT 22
3231: PUSH
3232: LD_INT 23
3234: PUSH
3235: LD_INT 24
3237: PUSH
3238: LD_INT 25
3240: PUSH
3241: LD_INT 26
3243: PUSH
3244: LD_INT 27
3246: PUSH
3247: LD_INT 28
3249: PUSH
3250: LD_INT 30
3252: PUSH
3253: LD_INT 31
3255: PUSH
3256: LD_INT 32
3258: PUSH
3259: LD_INT 33
3261: PUSH
3262: LD_INT 34
3264: PUSH
3265: LD_INT 36
3267: PUSH
3268: EMPTY
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: LIST
3279: LIST
3280: LIST
3281: LIST
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: LIST
3291: LIST
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: PUSH
3304: LD_INT 101
3306: PUSH
3307: LD_INT 102
3309: PUSH
3310: LD_INT 103
3312: PUSH
3313: LD_INT 104
3315: PUSH
3316: LD_INT 105
3318: PUSH
3319: LD_INT 106
3321: PUSH
3322: LD_INT 107
3324: PUSH
3325: LD_INT 108
3327: PUSH
3328: LD_INT 109
3330: PUSH
3331: LD_INT 110
3333: PUSH
3334: LD_INT 111
3336: PUSH
3337: LD_INT 112
3339: PUSH
3340: LD_INT 113
3342: PUSH
3343: LD_INT 114
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: LIST
3350: LIST
3351: LIST
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: LIST
3361: PUSH
3362: EMPTY
3363: LIST
3364: LIST
3365: ST_TO_ADDR
3366: GO 4737
3368: LD_INT 13
3370: DOUBLE
3371: EQUAL
3372: IFTRUE 3376
3374: GO 3572
3376: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
3377: LD_ADDR_VAR 0 1
3381: PUSH
3382: LD_INT 1
3384: PUSH
3385: LD_INT 2
3387: PUSH
3388: LD_INT 3
3390: PUSH
3391: LD_INT 4
3393: PUSH
3394: LD_INT 5
3396: PUSH
3397: LD_INT 8
3399: PUSH
3400: LD_INT 9
3402: PUSH
3403: LD_INT 10
3405: PUSH
3406: LD_INT 11
3408: PUSH
3409: LD_INT 12
3411: PUSH
3412: LD_INT 14
3414: PUSH
3415: LD_INT 15
3417: PUSH
3418: LD_INT 16
3420: PUSH
3421: LD_INT 17
3423: PUSH
3424: LD_INT 18
3426: PUSH
3427: LD_INT 19
3429: PUSH
3430: LD_INT 20
3432: PUSH
3433: LD_INT 21
3435: PUSH
3436: LD_INT 22
3438: PUSH
3439: LD_INT 23
3441: PUSH
3442: LD_INT 24
3444: PUSH
3445: LD_INT 25
3447: PUSH
3448: LD_INT 26
3450: PUSH
3451: LD_INT 27
3453: PUSH
3454: LD_INT 28
3456: PUSH
3457: LD_INT 30
3459: PUSH
3460: LD_INT 31
3462: PUSH
3463: LD_INT 32
3465: PUSH
3466: LD_INT 33
3468: PUSH
3469: LD_INT 34
3471: PUSH
3472: LD_INT 36
3474: PUSH
3475: EMPTY
3476: LIST
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: LIST
3488: LIST
3489: LIST
3490: LIST
3491: LIST
3492: LIST
3493: LIST
3494: LIST
3495: LIST
3496: LIST
3497: LIST
3498: LIST
3499: LIST
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: LIST
3505: LIST
3506: LIST
3507: PUSH
3508: LD_INT 101
3510: PUSH
3511: LD_INT 102
3513: PUSH
3514: LD_INT 103
3516: PUSH
3517: LD_INT 104
3519: PUSH
3520: LD_INT 105
3522: PUSH
3523: LD_INT 106
3525: PUSH
3526: LD_INT 107
3528: PUSH
3529: LD_INT 108
3531: PUSH
3532: LD_INT 109
3534: PUSH
3535: LD_INT 110
3537: PUSH
3538: LD_INT 111
3540: PUSH
3541: LD_INT 112
3543: PUSH
3544: LD_INT 113
3546: PUSH
3547: LD_INT 114
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: LIST
3563: LIST
3564: LIST
3565: PUSH
3566: EMPTY
3567: LIST
3568: LIST
3569: ST_TO_ADDR
3570: GO 4737
3572: LD_INT 14
3574: DOUBLE
3575: EQUAL
3576: IFTRUE 3580
3578: GO 3792
3580: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
3581: LD_ADDR_VAR 0 1
3585: PUSH
3586: LD_INT 1
3588: PUSH
3589: LD_INT 2
3591: PUSH
3592: LD_INT 3
3594: PUSH
3595: LD_INT 4
3597: PUSH
3598: LD_INT 5
3600: PUSH
3601: LD_INT 6
3603: PUSH
3604: LD_INT 7
3606: PUSH
3607: LD_INT 8
3609: PUSH
3610: LD_INT 9
3612: PUSH
3613: LD_INT 10
3615: PUSH
3616: LD_INT 11
3618: PUSH
3619: LD_INT 12
3621: PUSH
3622: LD_INT 13
3624: PUSH
3625: LD_INT 14
3627: PUSH
3628: LD_INT 15
3630: PUSH
3631: LD_INT 16
3633: PUSH
3634: LD_INT 17
3636: PUSH
3637: LD_INT 18
3639: PUSH
3640: LD_INT 19
3642: PUSH
3643: LD_INT 20
3645: PUSH
3646: LD_INT 21
3648: PUSH
3649: LD_INT 22
3651: PUSH
3652: LD_INT 23
3654: PUSH
3655: LD_INT 24
3657: PUSH
3658: LD_INT 25
3660: PUSH
3661: LD_INT 26
3663: PUSH
3664: LD_INT 27
3666: PUSH
3667: LD_INT 28
3669: PUSH
3670: LD_INT 29
3672: PUSH
3673: LD_INT 30
3675: PUSH
3676: LD_INT 31
3678: PUSH
3679: LD_INT 32
3681: PUSH
3682: LD_INT 33
3684: PUSH
3685: LD_INT 34
3687: PUSH
3688: LD_INT 36
3690: PUSH
3691: EMPTY
3692: LIST
3693: LIST
3694: LIST
3695: LIST
3696: LIST
3697: LIST
3698: LIST
3699: LIST
3700: LIST
3701: LIST
3702: LIST
3703: LIST
3704: LIST
3705: LIST
3706: LIST
3707: LIST
3708: LIST
3709: LIST
3710: LIST
3711: LIST
3712: LIST
3713: LIST
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: LIST
3721: LIST
3722: LIST
3723: LIST
3724: LIST
3725: LIST
3726: LIST
3727: PUSH
3728: LD_INT 101
3730: PUSH
3731: LD_INT 102
3733: PUSH
3734: LD_INT 103
3736: PUSH
3737: LD_INT 104
3739: PUSH
3740: LD_INT 105
3742: PUSH
3743: LD_INT 106
3745: PUSH
3746: LD_INT 107
3748: PUSH
3749: LD_INT 108
3751: PUSH
3752: LD_INT 109
3754: PUSH
3755: LD_INT 110
3757: PUSH
3758: LD_INT 111
3760: PUSH
3761: LD_INT 112
3763: PUSH
3764: LD_INT 113
3766: PUSH
3767: LD_INT 114
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: LIST
3774: LIST
3775: LIST
3776: LIST
3777: LIST
3778: LIST
3779: LIST
3780: LIST
3781: LIST
3782: LIST
3783: LIST
3784: LIST
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: ST_TO_ADDR
3790: GO 4737
3792: LD_INT 15
3794: DOUBLE
3795: EQUAL
3796: IFTRUE 3800
3798: GO 4012
3800: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
3801: LD_ADDR_VAR 0 1
3805: PUSH
3806: LD_INT 1
3808: PUSH
3809: LD_INT 2
3811: PUSH
3812: LD_INT 3
3814: PUSH
3815: LD_INT 4
3817: PUSH
3818: LD_INT 5
3820: PUSH
3821: LD_INT 6
3823: PUSH
3824: LD_INT 7
3826: PUSH
3827: LD_INT 8
3829: PUSH
3830: LD_INT 9
3832: PUSH
3833: LD_INT 10
3835: PUSH
3836: LD_INT 11
3838: PUSH
3839: LD_INT 12
3841: PUSH
3842: LD_INT 13
3844: PUSH
3845: LD_INT 14
3847: PUSH
3848: LD_INT 15
3850: PUSH
3851: LD_INT 16
3853: PUSH
3854: LD_INT 17
3856: PUSH
3857: LD_INT 18
3859: PUSH
3860: LD_INT 19
3862: PUSH
3863: LD_INT 20
3865: PUSH
3866: LD_INT 21
3868: PUSH
3869: LD_INT 22
3871: PUSH
3872: LD_INT 23
3874: PUSH
3875: LD_INT 24
3877: PUSH
3878: LD_INT 25
3880: PUSH
3881: LD_INT 26
3883: PUSH
3884: LD_INT 27
3886: PUSH
3887: LD_INT 28
3889: PUSH
3890: LD_INT 29
3892: PUSH
3893: LD_INT 30
3895: PUSH
3896: LD_INT 31
3898: PUSH
3899: LD_INT 32
3901: PUSH
3902: LD_INT 33
3904: PUSH
3905: LD_INT 34
3907: PUSH
3908: LD_INT 36
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: LIST
3915: LIST
3916: LIST
3917: LIST
3918: LIST
3919: LIST
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: LIST
3925: LIST
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: LIST
3931: LIST
3932: LIST
3933: LIST
3934: LIST
3935: LIST
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: LIST
3942: LIST
3943: LIST
3944: LIST
3945: LIST
3946: LIST
3947: PUSH
3948: LD_INT 101
3950: PUSH
3951: LD_INT 102
3953: PUSH
3954: LD_INT 103
3956: PUSH
3957: LD_INT 104
3959: PUSH
3960: LD_INT 105
3962: PUSH
3963: LD_INT 106
3965: PUSH
3966: LD_INT 107
3968: PUSH
3969: LD_INT 108
3971: PUSH
3972: LD_INT 109
3974: PUSH
3975: LD_INT 110
3977: PUSH
3978: LD_INT 111
3980: PUSH
3981: LD_INT 112
3983: PUSH
3984: LD_INT 113
3986: PUSH
3987: LD_INT 114
3989: PUSH
3990: EMPTY
3991: LIST
3992: LIST
3993: LIST
3994: LIST
3995: LIST
3996: LIST
3997: LIST
3998: LIST
3999: LIST
4000: LIST
4001: LIST
4002: LIST
4003: LIST
4004: LIST
4005: PUSH
4006: EMPTY
4007: LIST
4008: LIST
4009: ST_TO_ADDR
4010: GO 4737
4012: LD_INT 16
4014: DOUBLE
4015: EQUAL
4016: IFTRUE 4020
4018: GO 4144
4020: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
4021: LD_ADDR_VAR 0 1
4025: PUSH
4026: LD_INT 2
4028: PUSH
4029: LD_INT 4
4031: PUSH
4032: LD_INT 5
4034: PUSH
4035: LD_INT 7
4037: PUSH
4038: LD_INT 11
4040: PUSH
4041: LD_INT 12
4043: PUSH
4044: LD_INT 15
4046: PUSH
4047: LD_INT 16
4049: PUSH
4050: LD_INT 20
4052: PUSH
4053: LD_INT 21
4055: PUSH
4056: LD_INT 22
4058: PUSH
4059: LD_INT 23
4061: PUSH
4062: LD_INT 25
4064: PUSH
4065: LD_INT 26
4067: PUSH
4068: LD_INT 30
4070: PUSH
4071: LD_INT 31
4073: PUSH
4074: LD_INT 32
4076: PUSH
4077: LD_INT 33
4079: PUSH
4080: LD_INT 34
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: LIST
4087: LIST
4088: LIST
4089: LIST
4090: LIST
4091: LIST
4092: LIST
4093: LIST
4094: LIST
4095: LIST
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: LIST
4101: LIST
4102: LIST
4103: PUSH
4104: LD_INT 101
4106: PUSH
4107: LD_INT 102
4109: PUSH
4110: LD_INT 103
4112: PUSH
4113: LD_INT 106
4115: PUSH
4116: LD_INT 108
4118: PUSH
4119: LD_INT 112
4121: PUSH
4122: LD_INT 113
4124: PUSH
4125: LD_INT 114
4127: PUSH
4128: EMPTY
4129: LIST
4130: LIST
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: LIST
4136: LIST
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: ST_TO_ADDR
4142: GO 4737
4144: LD_INT 17
4146: DOUBLE
4147: EQUAL
4148: IFTRUE 4152
4150: GO 4364
4152: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
4153: LD_ADDR_VAR 0 1
4157: PUSH
4158: LD_INT 1
4160: PUSH
4161: LD_INT 2
4163: PUSH
4164: LD_INT 3
4166: PUSH
4167: LD_INT 4
4169: PUSH
4170: LD_INT 5
4172: PUSH
4173: LD_INT 6
4175: PUSH
4176: LD_INT 7
4178: PUSH
4179: LD_INT 8
4181: PUSH
4182: LD_INT 9
4184: PUSH
4185: LD_INT 10
4187: PUSH
4188: LD_INT 11
4190: PUSH
4191: LD_INT 12
4193: PUSH
4194: LD_INT 13
4196: PUSH
4197: LD_INT 14
4199: PUSH
4200: LD_INT 15
4202: PUSH
4203: LD_INT 16
4205: PUSH
4206: LD_INT 17
4208: PUSH
4209: LD_INT 18
4211: PUSH
4212: LD_INT 19
4214: PUSH
4215: LD_INT 20
4217: PUSH
4218: LD_INT 21
4220: PUSH
4221: LD_INT 22
4223: PUSH
4224: LD_INT 23
4226: PUSH
4227: LD_INT 24
4229: PUSH
4230: LD_INT 25
4232: PUSH
4233: LD_INT 26
4235: PUSH
4236: LD_INT 27
4238: PUSH
4239: LD_INT 28
4241: PUSH
4242: LD_INT 29
4244: PUSH
4245: LD_INT 30
4247: PUSH
4248: LD_INT 31
4250: PUSH
4251: LD_INT 32
4253: PUSH
4254: LD_INT 33
4256: PUSH
4257: LD_INT 34
4259: PUSH
4260: LD_INT 36
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: LIST
4272: LIST
4273: LIST
4274: LIST
4275: LIST
4276: LIST
4277: LIST
4278: LIST
4279: LIST
4280: LIST
4281: LIST
4282: LIST
4283: LIST
4284: LIST
4285: LIST
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: LIST
4294: LIST
4295: LIST
4296: LIST
4297: LIST
4298: LIST
4299: PUSH
4300: LD_INT 101
4302: PUSH
4303: LD_INT 102
4305: PUSH
4306: LD_INT 103
4308: PUSH
4309: LD_INT 104
4311: PUSH
4312: LD_INT 105
4314: PUSH
4315: LD_INT 106
4317: PUSH
4318: LD_INT 107
4320: PUSH
4321: LD_INT 108
4323: PUSH
4324: LD_INT 109
4326: PUSH
4327: LD_INT 110
4329: PUSH
4330: LD_INT 111
4332: PUSH
4333: LD_INT 112
4335: PUSH
4336: LD_INT 113
4338: PUSH
4339: LD_INT 114
4341: PUSH
4342: EMPTY
4343: LIST
4344: LIST
4345: LIST
4346: LIST
4347: LIST
4348: LIST
4349: LIST
4350: LIST
4351: LIST
4352: LIST
4353: LIST
4354: LIST
4355: LIST
4356: LIST
4357: PUSH
4358: EMPTY
4359: LIST
4360: LIST
4361: ST_TO_ADDR
4362: GO 4737
4364: LD_INT 18
4366: DOUBLE
4367: EQUAL
4368: IFTRUE 4372
4370: GO 4508
4372: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
4373: LD_ADDR_VAR 0 1
4377: PUSH
4378: LD_INT 2
4380: PUSH
4381: LD_INT 4
4383: PUSH
4384: LD_INT 5
4386: PUSH
4387: LD_INT 7
4389: PUSH
4390: LD_INT 11
4392: PUSH
4393: LD_INT 12
4395: PUSH
4396: LD_INT 15
4398: PUSH
4399: LD_INT 16
4401: PUSH
4402: LD_INT 20
4404: PUSH
4405: LD_INT 21
4407: PUSH
4408: LD_INT 22
4410: PUSH
4411: LD_INT 23
4413: PUSH
4414: LD_INT 25
4416: PUSH
4417: LD_INT 26
4419: PUSH
4420: LD_INT 30
4422: PUSH
4423: LD_INT 31
4425: PUSH
4426: LD_INT 32
4428: PUSH
4429: LD_INT 33
4431: PUSH
4432: LD_INT 34
4434: PUSH
4435: LD_INT 35
4437: PUSH
4438: LD_INT 36
4440: PUSH
4441: EMPTY
4442: LIST
4443: LIST
4444: LIST
4445: LIST
4446: LIST
4447: LIST
4448: LIST
4449: LIST
4450: LIST
4451: LIST
4452: LIST
4453: LIST
4454: LIST
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: LIST
4460: LIST
4461: LIST
4462: LIST
4463: PUSH
4464: LD_INT 101
4466: PUSH
4467: LD_INT 102
4469: PUSH
4470: LD_INT 103
4472: PUSH
4473: LD_INT 106
4475: PUSH
4476: LD_INT 108
4478: PUSH
4479: LD_INT 112
4481: PUSH
4482: LD_INT 113
4484: PUSH
4485: LD_INT 114
4487: PUSH
4488: LD_INT 115
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: LIST
4495: LIST
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: PUSH
4502: EMPTY
4503: LIST
4504: LIST
4505: ST_TO_ADDR
4506: GO 4737
4508: LD_INT 19
4510: DOUBLE
4511: EQUAL
4512: IFTRUE 4516
4514: GO 4736
4516: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
4517: LD_ADDR_VAR 0 1
4521: PUSH
4522: LD_INT 1
4524: PUSH
4525: LD_INT 2
4527: PUSH
4528: LD_INT 3
4530: PUSH
4531: LD_INT 4
4533: PUSH
4534: LD_INT 5
4536: PUSH
4537: LD_INT 6
4539: PUSH
4540: LD_INT 7
4542: PUSH
4543: LD_INT 8
4545: PUSH
4546: LD_INT 9
4548: PUSH
4549: LD_INT 10
4551: PUSH
4552: LD_INT 11
4554: PUSH
4555: LD_INT 12
4557: PUSH
4558: LD_INT 13
4560: PUSH
4561: LD_INT 14
4563: PUSH
4564: LD_INT 15
4566: PUSH
4567: LD_INT 16
4569: PUSH
4570: LD_INT 17
4572: PUSH
4573: LD_INT 18
4575: PUSH
4576: LD_INT 19
4578: PUSH
4579: LD_INT 20
4581: PUSH
4582: LD_INT 21
4584: PUSH
4585: LD_INT 22
4587: PUSH
4588: LD_INT 23
4590: PUSH
4591: LD_INT 24
4593: PUSH
4594: LD_INT 25
4596: PUSH
4597: LD_INT 26
4599: PUSH
4600: LD_INT 27
4602: PUSH
4603: LD_INT 28
4605: PUSH
4606: LD_INT 29
4608: PUSH
4609: LD_INT 30
4611: PUSH
4612: LD_INT 31
4614: PUSH
4615: LD_INT 32
4617: PUSH
4618: LD_INT 33
4620: PUSH
4621: LD_INT 34
4623: PUSH
4624: LD_INT 35
4626: PUSH
4627: LD_INT 36
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: LIST
4634: LIST
4635: LIST
4636: LIST
4637: LIST
4638: LIST
4639: LIST
4640: LIST
4641: LIST
4642: LIST
4643: LIST
4644: LIST
4645: LIST
4646: LIST
4647: LIST
4648: LIST
4649: LIST
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: LIST
4666: LIST
4667: PUSH
4668: LD_INT 101
4670: PUSH
4671: LD_INT 102
4673: PUSH
4674: LD_INT 103
4676: PUSH
4677: LD_INT 104
4679: PUSH
4680: LD_INT 105
4682: PUSH
4683: LD_INT 106
4685: PUSH
4686: LD_INT 107
4688: PUSH
4689: LD_INT 108
4691: PUSH
4692: LD_INT 109
4694: PUSH
4695: LD_INT 110
4697: PUSH
4698: LD_INT 111
4700: PUSH
4701: LD_INT 112
4703: PUSH
4704: LD_INT 113
4706: PUSH
4707: LD_INT 114
4709: PUSH
4710: LD_INT 115
4712: PUSH
4713: EMPTY
4714: LIST
4715: LIST
4716: LIST
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: LIST
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: ST_TO_ADDR
4734: GO 4737
4736: POP
// end else
4737: GO 4956
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
4739: LD_ADDR_VAR 0 1
4743: PUSH
4744: LD_INT 1
4746: PUSH
4747: LD_INT 2
4749: PUSH
4750: LD_INT 3
4752: PUSH
4753: LD_INT 4
4755: PUSH
4756: LD_INT 5
4758: PUSH
4759: LD_INT 6
4761: PUSH
4762: LD_INT 7
4764: PUSH
4765: LD_INT 8
4767: PUSH
4768: LD_INT 9
4770: PUSH
4771: LD_INT 10
4773: PUSH
4774: LD_INT 11
4776: PUSH
4777: LD_INT 12
4779: PUSH
4780: LD_INT 13
4782: PUSH
4783: LD_INT 14
4785: PUSH
4786: LD_INT 15
4788: PUSH
4789: LD_INT 16
4791: PUSH
4792: LD_INT 17
4794: PUSH
4795: LD_INT 18
4797: PUSH
4798: LD_INT 19
4800: PUSH
4801: LD_INT 20
4803: PUSH
4804: LD_INT 21
4806: PUSH
4807: LD_INT 22
4809: PUSH
4810: LD_INT 23
4812: PUSH
4813: LD_INT 24
4815: PUSH
4816: LD_INT 25
4818: PUSH
4819: LD_INT 26
4821: PUSH
4822: LD_INT 27
4824: PUSH
4825: LD_INT 28
4827: PUSH
4828: LD_INT 29
4830: PUSH
4831: LD_INT 30
4833: PUSH
4834: LD_INT 31
4836: PUSH
4837: LD_INT 32
4839: PUSH
4840: LD_INT 33
4842: PUSH
4843: LD_INT 34
4845: PUSH
4846: LD_INT 35
4848: PUSH
4849: LD_INT 36
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: LIST
4858: LIST
4859: LIST
4860: LIST
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: LIST
4866: LIST
4867: LIST
4868: LIST
4869: LIST
4870: LIST
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: PUSH
4890: LD_INT 101
4892: PUSH
4893: LD_INT 102
4895: PUSH
4896: LD_INT 103
4898: PUSH
4899: LD_INT 104
4901: PUSH
4902: LD_INT 105
4904: PUSH
4905: LD_INT 106
4907: PUSH
4908: LD_INT 107
4910: PUSH
4911: LD_INT 108
4913: PUSH
4914: LD_INT 109
4916: PUSH
4917: LD_INT 110
4919: PUSH
4920: LD_INT 111
4922: PUSH
4923: LD_INT 112
4925: PUSH
4926: LD_INT 113
4928: PUSH
4929: LD_INT 114
4931: PUSH
4932: LD_INT 115
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: LIST
4939: LIST
4940: LIST
4941: LIST
4942: LIST
4943: LIST
4944: LIST
4945: LIST
4946: LIST
4947: LIST
4948: LIST
4949: LIST
4950: LIST
4951: PUSH
4952: EMPTY
4953: LIST
4954: LIST
4955: ST_TO_ADDR
// if result then
4956: LD_VAR 0 1
4960: IFFALSE 5249
// begin normal :=  ;
4962: LD_ADDR_VAR 0 3
4966: PUSH
4967: LD_STRING 
4969: ST_TO_ADDR
// hardcore :=  ;
4970: LD_ADDR_VAR 0 4
4974: PUSH
4975: LD_STRING 
4977: ST_TO_ADDR
// for i = 1 to normalCounter do
4978: LD_ADDR_VAR 0 5
4982: PUSH
4983: DOUBLE
4984: LD_INT 1
4986: DEC
4987: ST_TO_ADDR
4988: LD_EXP 18
4992: PUSH
4993: FOR_TO
4994: IFFALSE 5095
// begin tmp := 0 ;
4996: LD_ADDR_VAR 0 2
5000: PUSH
5001: LD_STRING 0
5003: ST_TO_ADDR
// if result [ 1 ] then
5004: LD_VAR 0 1
5008: PUSH
5009: LD_INT 1
5011: ARRAY
5012: IFFALSE 5077
// if result [ 1 ] [ 1 ] = i then
5014: LD_VAR 0 1
5018: PUSH
5019: LD_INT 1
5021: ARRAY
5022: PUSH
5023: LD_INT 1
5025: ARRAY
5026: PUSH
5027: LD_VAR 0 5
5031: EQUAL
5032: IFFALSE 5077
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
5034: LD_ADDR_VAR 0 1
5038: PUSH
5039: LD_VAR 0 1
5043: PPUSH
5044: LD_INT 1
5046: PPUSH
5047: LD_VAR 0 1
5051: PUSH
5052: LD_INT 1
5054: ARRAY
5055: PPUSH
5056: LD_INT 1
5058: PPUSH
5059: CALL_OW 3
5063: PPUSH
5064: CALL_OW 1
5068: ST_TO_ADDR
// tmp := 1 ;
5069: LD_ADDR_VAR 0 2
5073: PUSH
5074: LD_STRING 1
5076: ST_TO_ADDR
// end ; normal := normal & tmp ;
5077: LD_ADDR_VAR 0 3
5081: PUSH
5082: LD_VAR 0 3
5086: PUSH
5087: LD_VAR 0 2
5091: STR
5092: ST_TO_ADDR
// end ;
5093: GO 4993
5095: POP
5096: POP
// for i = 1 to hardcoreCounter do
5097: LD_ADDR_VAR 0 5
5101: PUSH
5102: DOUBLE
5103: LD_INT 1
5105: DEC
5106: ST_TO_ADDR
5107: LD_EXP 19
5111: PUSH
5112: FOR_TO
5113: IFFALSE 5218
// begin tmp := 0 ;
5115: LD_ADDR_VAR 0 2
5119: PUSH
5120: LD_STRING 0
5122: ST_TO_ADDR
// if result [ 2 ] then
5123: LD_VAR 0 1
5127: PUSH
5128: LD_INT 2
5130: ARRAY
5131: IFFALSE 5200
// if result [ 2 ] [ 1 ] = 100 + i then
5133: LD_VAR 0 1
5137: PUSH
5138: LD_INT 2
5140: ARRAY
5141: PUSH
5142: LD_INT 1
5144: ARRAY
5145: PUSH
5146: LD_INT 100
5148: PUSH
5149: LD_VAR 0 5
5153: PLUS
5154: EQUAL
5155: IFFALSE 5200
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
5157: LD_ADDR_VAR 0 1
5161: PUSH
5162: LD_VAR 0 1
5166: PPUSH
5167: LD_INT 2
5169: PPUSH
5170: LD_VAR 0 1
5174: PUSH
5175: LD_INT 2
5177: ARRAY
5178: PPUSH
5179: LD_INT 1
5181: PPUSH
5182: CALL_OW 3
5186: PPUSH
5187: CALL_OW 1
5191: ST_TO_ADDR
// tmp := 1 ;
5192: LD_ADDR_VAR 0 2
5196: PUSH
5197: LD_STRING 1
5199: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
5200: LD_ADDR_VAR 0 4
5204: PUSH
5205: LD_VAR 0 4
5209: PUSH
5210: LD_VAR 0 2
5214: STR
5215: ST_TO_ADDR
// end ;
5216: GO 5112
5218: POP
5219: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
5220: LD_STRING getStreamItemsFromMission("
5222: PUSH
5223: LD_VAR 0 3
5227: STR
5228: PUSH
5229: LD_STRING ","
5231: STR
5232: PUSH
5233: LD_VAR 0 4
5237: STR
5238: PUSH
5239: LD_STRING ")
5241: STR
5242: PPUSH
5243: CALL_OW 559
// end else
5247: GO 5256
// ToLua ( getStreamItemsFromMission("","") ) ;
5249: LD_STRING getStreamItemsFromMission("","")
5251: PPUSH
5252: CALL_OW 559
// end ;
5256: LD_VAR 0 1
5260: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
5261: LD_EXP 17
5265: PUSH
5266: LD_EXP 22
5270: AND
5271: IFFALSE 5395
5273: GO 5275
5275: DISABLE
5276: LD_INT 0
5278: PPUSH
5279: PPUSH
// begin enable ;
5280: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
5281: LD_ADDR_VAR 0 2
5285: PUSH
5286: LD_INT 22
5288: PUSH
5289: LD_OWVAR 2
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: PUSH
5298: LD_INT 2
5300: PUSH
5301: LD_INT 34
5303: PUSH
5304: LD_INT 7
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: PUSH
5311: LD_INT 34
5313: PUSH
5314: LD_INT 45
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PUSH
5321: LD_INT 34
5323: PUSH
5324: LD_INT 28
5326: PUSH
5327: EMPTY
5328: LIST
5329: LIST
5330: PUSH
5331: LD_INT 34
5333: PUSH
5334: LD_INT 47
5336: PUSH
5337: EMPTY
5338: LIST
5339: LIST
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: LIST
5345: LIST
5346: LIST
5347: PUSH
5348: EMPTY
5349: LIST
5350: LIST
5351: PPUSH
5352: CALL_OW 69
5356: ST_TO_ADDR
// if not tmp then
5357: LD_VAR 0 2
5361: NOT
5362: IFFALSE 5366
// exit ;
5364: GO 5395
// for i in tmp do
5366: LD_ADDR_VAR 0 1
5370: PUSH
5371: LD_VAR 0 2
5375: PUSH
5376: FOR_IN
5377: IFFALSE 5393
// begin SetLives ( i , 0 ) ;
5379: LD_VAR 0 1
5383: PPUSH
5384: LD_INT 0
5386: PPUSH
5387: CALL_OW 234
// end ;
5391: GO 5376
5393: POP
5394: POP
// end ;
5395: PPOPN 2
5397: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
5398: LD_EXP 17
5402: PUSH
5403: LD_EXP 23
5407: AND
5408: IFFALSE 5492
5410: GO 5412
5412: DISABLE
5413: LD_INT 0
5415: PPUSH
5416: PPUSH
// begin enable ;
5417: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
5418: LD_ADDR_VAR 0 2
5422: PUSH
5423: LD_INT 22
5425: PUSH
5426: LD_OWVAR 2
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PUSH
5435: LD_INT 32
5437: PUSH
5438: LD_INT 3
5440: PUSH
5441: EMPTY
5442: LIST
5443: LIST
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PPUSH
5449: CALL_OW 69
5453: ST_TO_ADDR
// if not tmp then
5454: LD_VAR 0 2
5458: NOT
5459: IFFALSE 5463
// exit ;
5461: GO 5492
// for i in tmp do
5463: LD_ADDR_VAR 0 1
5467: PUSH
5468: LD_VAR 0 2
5472: PUSH
5473: FOR_IN
5474: IFFALSE 5490
// begin SetLives ( i , 0 ) ;
5476: LD_VAR 0 1
5480: PPUSH
5481: LD_INT 0
5483: PPUSH
5484: CALL_OW 234
// end ;
5488: GO 5473
5490: POP
5491: POP
// end ;
5492: PPOPN 2
5494: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
5495: LD_EXP 17
5499: PUSH
5500: LD_EXP 20
5504: AND
5505: IFFALSE 5598
5507: GO 5509
5509: DISABLE
5510: LD_INT 0
5512: PPUSH
// begin enable ;
5513: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
5514: LD_ADDR_VAR 0 1
5518: PUSH
5519: LD_INT 22
5521: PUSH
5522: LD_OWVAR 2
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: PUSH
5531: LD_INT 2
5533: PUSH
5534: LD_INT 25
5536: PUSH
5537: LD_INT 5
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: PUSH
5544: LD_INT 25
5546: PUSH
5547: LD_INT 9
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 25
5556: PUSH
5557: LD_INT 8
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: EMPTY
5565: LIST
5566: LIST
5567: LIST
5568: LIST
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PPUSH
5574: CALL_OW 69
5578: PUSH
5579: FOR_IN
5580: IFFALSE 5596
// begin SetClass ( i , 1 ) ;
5582: LD_VAR 0 1
5586: PPUSH
5587: LD_INT 1
5589: PPUSH
5590: CALL_OW 336
// end ;
5594: GO 5579
5596: POP
5597: POP
// end ;
5598: PPOPN 1
5600: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
5601: LD_EXP 17
5605: PUSH
5606: LD_EXP 21
5610: AND
5611: PUSH
5612: LD_OWVAR 65
5616: PUSH
5617: LD_INT 7
5619: LESS
5620: AND
5621: IFFALSE 5635
5623: GO 5625
5625: DISABLE
// begin enable ;
5626: ENABLE
// game_speed := 7 ;
5627: LD_ADDR_OWVAR 65
5631: PUSH
5632: LD_INT 7
5634: ST_TO_ADDR
// end ;
5635: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
5636: LD_EXP 17
5640: PUSH
5641: LD_EXP 24
5645: AND
5646: IFFALSE 5848
5648: GO 5650
5650: DISABLE
5651: LD_INT 0
5653: PPUSH
5654: PPUSH
5655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
5656: LD_ADDR_VAR 0 3
5660: PUSH
5661: LD_INT 81
5663: PUSH
5664: LD_OWVAR 2
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: PUSH
5673: LD_INT 21
5675: PUSH
5676: LD_INT 1
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: PPUSH
5687: CALL_OW 69
5691: ST_TO_ADDR
// if not tmp then
5692: LD_VAR 0 3
5696: NOT
5697: IFFALSE 5701
// exit ;
5699: GO 5848
// if tmp > 5 then
5701: LD_VAR 0 3
5705: PUSH
5706: LD_INT 5
5708: GREATER
5709: IFFALSE 5721
// k := 5 else
5711: LD_ADDR_VAR 0 2
5715: PUSH
5716: LD_INT 5
5718: ST_TO_ADDR
5719: GO 5731
// k := tmp ;
5721: LD_ADDR_VAR 0 2
5725: PUSH
5726: LD_VAR 0 3
5730: ST_TO_ADDR
// for i := 1 to k do
5731: LD_ADDR_VAR 0 1
5735: PUSH
5736: DOUBLE
5737: LD_INT 1
5739: DEC
5740: ST_TO_ADDR
5741: LD_VAR 0 2
5745: PUSH
5746: FOR_TO
5747: IFFALSE 5846
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
5749: LD_VAR 0 3
5753: PUSH
5754: LD_VAR 0 1
5758: ARRAY
5759: PPUSH
5760: LD_VAR 0 1
5764: PUSH
5765: LD_INT 4
5767: MOD
5768: PUSH
5769: LD_INT 1
5771: PLUS
5772: PPUSH
5773: CALL_OW 259
5777: PUSH
5778: LD_INT 10
5780: LESS
5781: IFFALSE 5844
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
5783: LD_VAR 0 3
5787: PUSH
5788: LD_VAR 0 1
5792: ARRAY
5793: PPUSH
5794: LD_VAR 0 1
5798: PUSH
5799: LD_INT 4
5801: MOD
5802: PUSH
5803: LD_INT 1
5805: PLUS
5806: PPUSH
5807: LD_VAR 0 3
5811: PUSH
5812: LD_VAR 0 1
5816: ARRAY
5817: PPUSH
5818: LD_VAR 0 1
5822: PUSH
5823: LD_INT 4
5825: MOD
5826: PUSH
5827: LD_INT 1
5829: PLUS
5830: PPUSH
5831: CALL_OW 259
5835: PUSH
5836: LD_INT 1
5838: PLUS
5839: PPUSH
5840: CALL_OW 237
5844: GO 5746
5846: POP
5847: POP
// end ;
5848: PPOPN 3
5850: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
5851: LD_EXP 17
5855: PUSH
5856: LD_EXP 25
5860: AND
5861: IFFALSE 5881
5863: GO 5865
5865: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
5866: LD_INT 4
5868: PPUSH
5869: LD_OWVAR 2
5873: PPUSH
5874: LD_INT 0
5876: PPUSH
5877: CALL_OW 324
5881: END
// every 0 0$1 trigger StreamModeActive and sShovel do
5882: LD_EXP 17
5886: PUSH
5887: LD_EXP 54
5891: AND
5892: IFFALSE 5912
5894: GO 5896
5896: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
5897: LD_INT 19
5899: PPUSH
5900: LD_OWVAR 2
5904: PPUSH
5905: LD_INT 0
5907: PPUSH
5908: CALL_OW 324
5912: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
5913: LD_EXP 17
5917: PUSH
5918: LD_EXP 26
5922: AND
5923: IFFALSE 6025
5925: GO 5927
5927: DISABLE
5928: LD_INT 0
5930: PPUSH
5931: PPUSH
// begin enable ;
5932: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
5933: LD_ADDR_VAR 0 2
5937: PUSH
5938: LD_INT 22
5940: PUSH
5941: LD_OWVAR 2
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: PUSH
5950: LD_INT 2
5952: PUSH
5953: LD_INT 34
5955: PUSH
5956: LD_INT 11
5958: PUSH
5959: EMPTY
5960: LIST
5961: LIST
5962: PUSH
5963: LD_INT 34
5965: PUSH
5966: LD_INT 30
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: PUSH
5978: EMPTY
5979: LIST
5980: LIST
5981: PPUSH
5982: CALL_OW 69
5986: ST_TO_ADDR
// if not tmp then
5987: LD_VAR 0 2
5991: NOT
5992: IFFALSE 5996
// exit ;
5994: GO 6025
// for i in tmp do
5996: LD_ADDR_VAR 0 1
6000: PUSH
6001: LD_VAR 0 2
6005: PUSH
6006: FOR_IN
6007: IFFALSE 6023
// begin SetLives ( i , 0 ) ;
6009: LD_VAR 0 1
6013: PPUSH
6014: LD_INT 0
6016: PPUSH
6017: CALL_OW 234
// end ;
6021: GO 6006
6023: POP
6024: POP
// end ;
6025: PPOPN 2
6027: END
// every 0 0$1 trigger StreamModeActive and sBunker do
6028: LD_EXP 17
6032: PUSH
6033: LD_EXP 27
6037: AND
6038: IFFALSE 6058
6040: GO 6042
6042: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
6043: LD_INT 32
6045: PPUSH
6046: LD_OWVAR 2
6050: PPUSH
6051: LD_INT 0
6053: PPUSH
6054: CALL_OW 324
6058: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
6059: LD_EXP 17
6063: PUSH
6064: LD_EXP 28
6068: AND
6069: IFFALSE 6250
6071: GO 6073
6073: DISABLE
6074: LD_INT 0
6076: PPUSH
6077: PPUSH
6078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
6079: LD_ADDR_VAR 0 2
6083: PUSH
6084: LD_INT 22
6086: PUSH
6087: LD_OWVAR 2
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: LD_INT 33
6098: PUSH
6099: LD_INT 3
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 69
6114: ST_TO_ADDR
// if not tmp then
6115: LD_VAR 0 2
6119: NOT
6120: IFFALSE 6124
// exit ;
6122: GO 6250
// side := 0 ;
6124: LD_ADDR_VAR 0 3
6128: PUSH
6129: LD_INT 0
6131: ST_TO_ADDR
// for i := 1 to 8 do
6132: LD_ADDR_VAR 0 1
6136: PUSH
6137: DOUBLE
6138: LD_INT 1
6140: DEC
6141: ST_TO_ADDR
6142: LD_INT 8
6144: PUSH
6145: FOR_TO
6146: IFFALSE 6194
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
6148: LD_OWVAR 2
6152: PUSH
6153: LD_VAR 0 1
6157: NONEQUAL
6158: PUSH
6159: LD_OWVAR 2
6163: PPUSH
6164: LD_VAR 0 1
6168: PPUSH
6169: CALL_OW 81
6173: PUSH
6174: LD_INT 2
6176: EQUAL
6177: AND
6178: IFFALSE 6192
// begin side := i ;
6180: LD_ADDR_VAR 0 3
6184: PUSH
6185: LD_VAR 0 1
6189: ST_TO_ADDR
// break ;
6190: GO 6194
// end ;
6192: GO 6145
6194: POP
6195: POP
// if not side then
6196: LD_VAR 0 3
6200: NOT
6201: IFFALSE 6205
// exit ;
6203: GO 6250
// for i := 1 to tmp do
6205: LD_ADDR_VAR 0 1
6209: PUSH
6210: DOUBLE
6211: LD_INT 1
6213: DEC
6214: ST_TO_ADDR
6215: LD_VAR 0 2
6219: PUSH
6220: FOR_TO
6221: IFFALSE 6248
// if Prob ( 60 ) then
6223: LD_INT 60
6225: PPUSH
6226: CALL_OW 13
6230: IFFALSE 6246
// SetSide ( i , side ) ;
6232: LD_VAR 0 1
6236: PPUSH
6237: LD_VAR 0 3
6241: PPUSH
6242: CALL_OW 235
6246: GO 6220
6248: POP
6249: POP
// end ;
6250: PPOPN 3
6252: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
6253: LD_EXP 17
6257: PUSH
6258: LD_EXP 30
6262: AND
6263: IFFALSE 6382
6265: GO 6267
6267: DISABLE
6268: LD_INT 0
6270: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
6271: LD_ADDR_VAR 0 1
6275: PUSH
6276: LD_INT 22
6278: PUSH
6279: LD_OWVAR 2
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: PUSH
6288: LD_INT 21
6290: PUSH
6291: LD_INT 1
6293: PUSH
6294: EMPTY
6295: LIST
6296: LIST
6297: PUSH
6298: LD_INT 3
6300: PUSH
6301: LD_INT 23
6303: PUSH
6304: LD_INT 0
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: LIST
6319: PPUSH
6320: CALL_OW 69
6324: PUSH
6325: FOR_IN
6326: IFFALSE 6380
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
6328: LD_VAR 0 1
6332: PPUSH
6333: CALL_OW 257
6337: PUSH
6338: LD_INT 1
6340: PUSH
6341: LD_INT 2
6343: PUSH
6344: LD_INT 3
6346: PUSH
6347: LD_INT 4
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: LIST
6354: LIST
6355: IN
6356: IFFALSE 6378
// SetClass ( un , rand ( 1 , 4 ) ) ;
6358: LD_VAR 0 1
6362: PPUSH
6363: LD_INT 1
6365: PPUSH
6366: LD_INT 4
6368: PPUSH
6369: CALL_OW 12
6373: PPUSH
6374: CALL_OW 336
6378: GO 6325
6380: POP
6381: POP
// end ;
6382: PPOPN 1
6384: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
6385: LD_EXP 17
6389: PUSH
6390: LD_EXP 29
6394: AND
6395: IFFALSE 6474
6397: GO 6399
6399: DISABLE
6400: LD_INT 0
6402: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6403: LD_ADDR_VAR 0 1
6407: PUSH
6408: LD_INT 22
6410: PUSH
6411: LD_OWVAR 2
6415: PUSH
6416: EMPTY
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 21
6422: PUSH
6423: LD_INT 3
6425: PUSH
6426: EMPTY
6427: LIST
6428: LIST
6429: PUSH
6430: EMPTY
6431: LIST
6432: LIST
6433: PPUSH
6434: CALL_OW 69
6438: ST_TO_ADDR
// if not tmp then
6439: LD_VAR 0 1
6443: NOT
6444: IFFALSE 6448
// exit ;
6446: GO 6474
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
6448: LD_VAR 0 1
6452: PUSH
6453: LD_INT 1
6455: PPUSH
6456: LD_VAR 0 1
6460: PPUSH
6461: CALL_OW 12
6465: ARRAY
6466: PPUSH
6467: LD_INT 100
6469: PPUSH
6470: CALL_OW 234
// end ;
6474: PPOPN 1
6476: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
6477: LD_EXP 17
6481: PUSH
6482: LD_EXP 31
6486: AND
6487: IFFALSE 6585
6489: GO 6491
6491: DISABLE
6492: LD_INT 0
6494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
6495: LD_ADDR_VAR 0 1
6499: PUSH
6500: LD_INT 22
6502: PUSH
6503: LD_OWVAR 2
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 21
6514: PUSH
6515: LD_INT 1
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: EMPTY
6523: LIST
6524: LIST
6525: PPUSH
6526: CALL_OW 69
6530: ST_TO_ADDR
// if not tmp then
6531: LD_VAR 0 1
6535: NOT
6536: IFFALSE 6540
// exit ;
6538: GO 6585
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
6540: LD_VAR 0 1
6544: PUSH
6545: LD_INT 1
6547: PPUSH
6548: LD_VAR 0 1
6552: PPUSH
6553: CALL_OW 12
6557: ARRAY
6558: PPUSH
6559: LD_INT 1
6561: PPUSH
6562: LD_INT 4
6564: PPUSH
6565: CALL_OW 12
6569: PPUSH
6570: LD_INT 3000
6572: PPUSH
6573: LD_INT 9000
6575: PPUSH
6576: CALL_OW 12
6580: PPUSH
6581: CALL_OW 492
// end ;
6585: PPOPN 1
6587: END
// every 0 0$1 trigger StreamModeActive and sDepot do
6588: LD_EXP 17
6592: PUSH
6593: LD_EXP 32
6597: AND
6598: IFFALSE 6618
6600: GO 6602
6602: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
6603: LD_INT 1
6605: PPUSH
6606: LD_OWVAR 2
6610: PPUSH
6611: LD_INT 0
6613: PPUSH
6614: CALL_OW 324
6618: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
6619: LD_EXP 17
6623: PUSH
6624: LD_EXP 33
6628: AND
6629: IFFALSE 6712
6631: GO 6633
6633: DISABLE
6634: LD_INT 0
6636: PPUSH
6637: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6638: LD_ADDR_VAR 0 2
6642: PUSH
6643: LD_INT 22
6645: PUSH
6646: LD_OWVAR 2
6650: PUSH
6651: EMPTY
6652: LIST
6653: LIST
6654: PUSH
6655: LD_INT 21
6657: PUSH
6658: LD_INT 3
6660: PUSH
6661: EMPTY
6662: LIST
6663: LIST
6664: PUSH
6665: EMPTY
6666: LIST
6667: LIST
6668: PPUSH
6669: CALL_OW 69
6673: ST_TO_ADDR
// if not tmp then
6674: LD_VAR 0 2
6678: NOT
6679: IFFALSE 6683
// exit ;
6681: GO 6712
// for i in tmp do
6683: LD_ADDR_VAR 0 1
6687: PUSH
6688: LD_VAR 0 2
6692: PUSH
6693: FOR_IN
6694: IFFALSE 6710
// SetBLevel ( i , 10 ) ;
6696: LD_VAR 0 1
6700: PPUSH
6701: LD_INT 10
6703: PPUSH
6704: CALL_OW 241
6708: GO 6693
6710: POP
6711: POP
// end ;
6712: PPOPN 2
6714: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
6715: LD_EXP 17
6719: PUSH
6720: LD_EXP 34
6724: AND
6725: IFFALSE 6836
6727: GO 6729
6729: DISABLE
6730: LD_INT 0
6732: PPUSH
6733: PPUSH
6734: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
6735: LD_ADDR_VAR 0 3
6739: PUSH
6740: LD_INT 22
6742: PUSH
6743: LD_OWVAR 2
6747: PUSH
6748: EMPTY
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 25
6754: PUSH
6755: LD_INT 1
6757: PUSH
6758: EMPTY
6759: LIST
6760: LIST
6761: PUSH
6762: EMPTY
6763: LIST
6764: LIST
6765: PPUSH
6766: CALL_OW 69
6770: ST_TO_ADDR
// if not tmp then
6771: LD_VAR 0 3
6775: NOT
6776: IFFALSE 6780
// exit ;
6778: GO 6836
// un := tmp [ rand ( 1 , tmp ) ] ;
6780: LD_ADDR_VAR 0 2
6784: PUSH
6785: LD_VAR 0 3
6789: PUSH
6790: LD_INT 1
6792: PPUSH
6793: LD_VAR 0 3
6797: PPUSH
6798: CALL_OW 12
6802: ARRAY
6803: ST_TO_ADDR
// if Crawls ( un ) then
6804: LD_VAR 0 2
6808: PPUSH
6809: CALL_OW 318
6813: IFFALSE 6824
// ComWalk ( un ) ;
6815: LD_VAR 0 2
6819: PPUSH
6820: CALL_OW 138
// SetClass ( un , class_sniper ) ;
6824: LD_VAR 0 2
6828: PPUSH
6829: LD_INT 5
6831: PPUSH
6832: CALL_OW 336
// end ;
6836: PPOPN 3
6838: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
6839: LD_EXP 17
6843: PUSH
6844: LD_EXP 35
6848: AND
6849: PUSH
6850: LD_OWVAR 67
6854: PUSH
6855: LD_INT 3
6857: LESS
6858: AND
6859: IFFALSE 6878
6861: GO 6863
6863: DISABLE
// Difficulty := Difficulty + 1 ;
6864: LD_ADDR_OWVAR 67
6868: PUSH
6869: LD_OWVAR 67
6873: PUSH
6874: LD_INT 1
6876: PLUS
6877: ST_TO_ADDR
6878: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
6879: LD_EXP 17
6883: PUSH
6884: LD_EXP 36
6888: AND
6889: IFFALSE 6992
6891: GO 6893
6893: DISABLE
6894: LD_INT 0
6896: PPUSH
// begin for i := 1 to 5 do
6897: LD_ADDR_VAR 0 1
6901: PUSH
6902: DOUBLE
6903: LD_INT 1
6905: DEC
6906: ST_TO_ADDR
6907: LD_INT 5
6909: PUSH
6910: FOR_TO
6911: IFFALSE 6990
// begin uc_nation := nation_nature ;
6913: LD_ADDR_OWVAR 21
6917: PUSH
6918: LD_INT 0
6920: ST_TO_ADDR
// uc_side := 0 ;
6921: LD_ADDR_OWVAR 20
6925: PUSH
6926: LD_INT 0
6928: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
6929: LD_ADDR_OWVAR 29
6933: PUSH
6934: LD_INT 12
6936: PUSH
6937: LD_INT 12
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: ST_TO_ADDR
// hc_agressivity := 20 ;
6944: LD_ADDR_OWVAR 35
6948: PUSH
6949: LD_INT 20
6951: ST_TO_ADDR
// hc_class := class_tiger ;
6952: LD_ADDR_OWVAR 28
6956: PUSH
6957: LD_INT 14
6959: ST_TO_ADDR
// hc_gallery :=  ;
6960: LD_ADDR_OWVAR 33
6964: PUSH
6965: LD_STRING 
6967: ST_TO_ADDR
// hc_name :=  ;
6968: LD_ADDR_OWVAR 26
6972: PUSH
6973: LD_STRING 
6975: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
6976: CALL_OW 44
6980: PPUSH
6981: LD_INT 0
6983: PPUSH
6984: CALL_OW 51
// end ;
6988: GO 6910
6990: POP
6991: POP
// end ;
6992: PPOPN 1
6994: END
// every 0 0$1 trigger StreamModeActive and sBomb do
6995: LD_EXP 17
6999: PUSH
7000: LD_EXP 37
7004: AND
7005: IFFALSE 7014
7007: GO 7009
7009: DISABLE
// StreamSibBomb ;
7010: CALL 7015 0 0
7014: END
// export function StreamSibBomb ; var i , x , y ; begin
7015: LD_INT 0
7017: PPUSH
7018: PPUSH
7019: PPUSH
7020: PPUSH
// result := false ;
7021: LD_ADDR_VAR 0 1
7025: PUSH
7026: LD_INT 0
7028: ST_TO_ADDR
// for i := 1 to 16 do
7029: LD_ADDR_VAR 0 2
7033: PUSH
7034: DOUBLE
7035: LD_INT 1
7037: DEC
7038: ST_TO_ADDR
7039: LD_INT 16
7041: PUSH
7042: FOR_TO
7043: IFFALSE 7242
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
7045: LD_ADDR_VAR 0 3
7049: PUSH
7050: LD_INT 10
7052: PUSH
7053: LD_INT 20
7055: PUSH
7056: LD_INT 30
7058: PUSH
7059: LD_INT 40
7061: PUSH
7062: LD_INT 50
7064: PUSH
7065: LD_INT 60
7067: PUSH
7068: LD_INT 70
7070: PUSH
7071: LD_INT 80
7073: PUSH
7074: LD_INT 90
7076: PUSH
7077: LD_INT 100
7079: PUSH
7080: LD_INT 110
7082: PUSH
7083: LD_INT 120
7085: PUSH
7086: LD_INT 130
7088: PUSH
7089: LD_INT 140
7091: PUSH
7092: LD_INT 150
7094: PUSH
7095: EMPTY
7096: LIST
7097: LIST
7098: LIST
7099: LIST
7100: LIST
7101: LIST
7102: LIST
7103: LIST
7104: LIST
7105: LIST
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: LD_INT 1
7114: PPUSH
7115: LD_INT 15
7117: PPUSH
7118: CALL_OW 12
7122: ARRAY
7123: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
7124: LD_ADDR_VAR 0 4
7128: PUSH
7129: LD_INT 10
7131: PUSH
7132: LD_INT 20
7134: PUSH
7135: LD_INT 30
7137: PUSH
7138: LD_INT 40
7140: PUSH
7141: LD_INT 50
7143: PUSH
7144: LD_INT 60
7146: PUSH
7147: LD_INT 70
7149: PUSH
7150: LD_INT 80
7152: PUSH
7153: LD_INT 90
7155: PUSH
7156: LD_INT 100
7158: PUSH
7159: LD_INT 110
7161: PUSH
7162: LD_INT 120
7164: PUSH
7165: LD_INT 130
7167: PUSH
7168: LD_INT 140
7170: PUSH
7171: LD_INT 150
7173: PUSH
7174: EMPTY
7175: LIST
7176: LIST
7177: LIST
7178: LIST
7179: LIST
7180: LIST
7181: LIST
7182: LIST
7183: LIST
7184: LIST
7185: LIST
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: LD_INT 1
7193: PPUSH
7194: LD_INT 15
7196: PPUSH
7197: CALL_OW 12
7201: ARRAY
7202: ST_TO_ADDR
// if ValidHex ( x , y ) then
7203: LD_VAR 0 3
7207: PPUSH
7208: LD_VAR 0 4
7212: PPUSH
7213: CALL_OW 488
7217: IFFALSE 7240
// begin result := [ x , y ] ;
7219: LD_ADDR_VAR 0 1
7223: PUSH
7224: LD_VAR 0 3
7228: PUSH
7229: LD_VAR 0 4
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: ST_TO_ADDR
// break ;
7238: GO 7242
// end ; end ;
7240: GO 7042
7242: POP
7243: POP
// if result then
7244: LD_VAR 0 1
7248: IFFALSE 7308
// begin ToLua ( playSibBomb() ) ;
7250: LD_STRING playSibBomb()
7252: PPUSH
7253: CALL_OW 559
// wait ( 0 0$14 ) ;
7257: LD_INT 490
7259: PPUSH
7260: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
7264: LD_VAR 0 1
7268: PUSH
7269: LD_INT 1
7271: ARRAY
7272: PPUSH
7273: LD_VAR 0 1
7277: PUSH
7278: LD_INT 2
7280: ARRAY
7281: PPUSH
7282: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
7286: LD_VAR 0 1
7290: PUSH
7291: LD_INT 1
7293: ARRAY
7294: PPUSH
7295: LD_VAR 0 1
7299: PUSH
7300: LD_INT 2
7302: ARRAY
7303: PPUSH
7304: CALL_OW 429
// end ; end ;
7308: LD_VAR 0 1
7312: RET
// every 0 0$1 trigger StreamModeActive and sReset do
7313: LD_EXP 17
7317: PUSH
7318: LD_EXP 39
7322: AND
7323: IFFALSE 7335
7325: GO 7327
7327: DISABLE
// YouLost (  ) ;
7328: LD_STRING 
7330: PPUSH
7331: CALL_OW 104
7335: END
// every 0 0$1 trigger StreamModeActive and sFog do
7336: LD_EXP 17
7340: PUSH
7341: LD_EXP 38
7345: AND
7346: IFFALSE 7360
7348: GO 7350
7350: DISABLE
// FogOff ( your_side ) ;
7351: LD_OWVAR 2
7355: PPUSH
7356: CALL_OW 344
7360: END
// every 0 0$1 trigger StreamModeActive and sSun do
7361: LD_EXP 17
7365: PUSH
7366: LD_EXP 40
7370: AND
7371: IFFALSE 7399
7373: GO 7375
7375: DISABLE
// begin solar_recharge_percent := 0 ;
7376: LD_ADDR_OWVAR 79
7380: PUSH
7381: LD_INT 0
7383: ST_TO_ADDR
// wait ( 5 5$00 ) ;
7384: LD_INT 10500
7386: PPUSH
7387: CALL_OW 67
// solar_recharge_percent := 100 ;
7391: LD_ADDR_OWVAR 79
7395: PUSH
7396: LD_INT 100
7398: ST_TO_ADDR
// end ;
7399: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
7400: LD_EXP 17
7404: PUSH
7405: LD_EXP 41
7409: AND
7410: IFFALSE 7649
7412: GO 7414
7414: DISABLE
7415: LD_INT 0
7417: PPUSH
7418: PPUSH
7419: PPUSH
// begin tmp := [ ] ;
7420: LD_ADDR_VAR 0 3
7424: PUSH
7425: EMPTY
7426: ST_TO_ADDR
// for i := 1 to 6 do
7427: LD_ADDR_VAR 0 1
7431: PUSH
7432: DOUBLE
7433: LD_INT 1
7435: DEC
7436: ST_TO_ADDR
7437: LD_INT 6
7439: PUSH
7440: FOR_TO
7441: IFFALSE 7546
// begin uc_nation := nation_nature ;
7443: LD_ADDR_OWVAR 21
7447: PUSH
7448: LD_INT 0
7450: ST_TO_ADDR
// uc_side := 0 ;
7451: LD_ADDR_OWVAR 20
7455: PUSH
7456: LD_INT 0
7458: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7459: LD_ADDR_OWVAR 29
7463: PUSH
7464: LD_INT 12
7466: PUSH
7467: LD_INT 12
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: ST_TO_ADDR
// hc_agressivity := 20 ;
7474: LD_ADDR_OWVAR 35
7478: PUSH
7479: LD_INT 20
7481: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
7482: LD_ADDR_OWVAR 28
7486: PUSH
7487: LD_INT 17
7489: ST_TO_ADDR
// hc_gallery :=  ;
7490: LD_ADDR_OWVAR 33
7494: PUSH
7495: LD_STRING 
7497: ST_TO_ADDR
// hc_name :=  ;
7498: LD_ADDR_OWVAR 26
7502: PUSH
7503: LD_STRING 
7505: ST_TO_ADDR
// un := CreateHuman ;
7506: LD_ADDR_VAR 0 2
7510: PUSH
7511: CALL_OW 44
7515: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
7516: LD_VAR 0 2
7520: PPUSH
7521: LD_INT 1
7523: PPUSH
7524: CALL_OW 51
// tmp := tmp ^ un ;
7528: LD_ADDR_VAR 0 3
7532: PUSH
7533: LD_VAR 0 3
7537: PUSH
7538: LD_VAR 0 2
7542: ADD
7543: ST_TO_ADDR
// end ;
7544: GO 7440
7546: POP
7547: POP
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// for un in tmp do
7555: LD_ADDR_VAR 0 2
7559: PUSH
7560: LD_VAR 0 3
7564: PUSH
7565: FOR_IN
7566: IFFALSE 7640
// begin if IsDead ( un ) then
7568: LD_VAR 0 2
7572: PPUSH
7573: CALL_OW 301
7577: IFFALSE 7597
// begin tmp := tmp diff un ;
7579: LD_ADDR_VAR 0 3
7583: PUSH
7584: LD_VAR 0 3
7588: PUSH
7589: LD_VAR 0 2
7593: DIFF
7594: ST_TO_ADDR
// continue ;
7595: GO 7565
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
7597: LD_VAR 0 2
7601: PPUSH
7602: LD_INT 3
7604: PUSH
7605: LD_INT 22
7607: PUSH
7608: LD_INT 0
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PPUSH
7619: CALL_OW 69
7623: PPUSH
7624: LD_VAR 0 2
7628: PPUSH
7629: CALL_OW 74
7633: PPUSH
7634: CALL_OW 115
// end ;
7638: GO 7565
7640: POP
7641: POP
// until not tmp ;
7642: LD_VAR 0 3
7646: NOT
7647: IFFALSE 7548
// end ;
7649: PPOPN 3
7651: END
// every 0 0$1 trigger StreamModeActive and sTroll do
7652: LD_EXP 17
7656: PUSH
7657: LD_EXP 42
7661: AND
7662: IFFALSE 7716
7664: GO 7666
7666: DISABLE
// begin ToLua ( displayTroll(); ) ;
7667: LD_STRING displayTroll();
7669: PPUSH
7670: CALL_OW 559
// wait ( 3 3$00 ) ;
7674: LD_INT 6300
7676: PPUSH
7677: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7681: LD_STRING hideTroll();
7683: PPUSH
7684: CALL_OW 559
// wait ( 1 1$00 ) ;
7688: LD_INT 2100
7690: PPUSH
7691: CALL_OW 67
// ToLua ( displayTroll(); ) ;
7695: LD_STRING displayTroll();
7697: PPUSH
7698: CALL_OW 559
// wait ( 1 1$00 ) ;
7702: LD_INT 2100
7704: PPUSH
7705: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7709: LD_STRING hideTroll();
7711: PPUSH
7712: CALL_OW 559
// end ;
7716: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
7717: LD_EXP 17
7721: PUSH
7722: LD_EXP 43
7726: AND
7727: IFFALSE 7790
7729: GO 7731
7731: DISABLE
7732: LD_INT 0
7734: PPUSH
// begin p := 0 ;
7735: LD_ADDR_VAR 0 1
7739: PUSH
7740: LD_INT 0
7742: ST_TO_ADDR
// repeat game_speed := 1 ;
7743: LD_ADDR_OWVAR 65
7747: PUSH
7748: LD_INT 1
7750: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7751: LD_INT 35
7753: PPUSH
7754: CALL_OW 67
// p := p + 1 ;
7758: LD_ADDR_VAR 0 1
7762: PUSH
7763: LD_VAR 0 1
7767: PUSH
7768: LD_INT 1
7770: PLUS
7771: ST_TO_ADDR
// until p >= 60 ;
7772: LD_VAR 0 1
7776: PUSH
7777: LD_INT 60
7779: GREATEREQUAL
7780: IFFALSE 7743
// game_speed := 4 ;
7782: LD_ADDR_OWVAR 65
7786: PUSH
7787: LD_INT 4
7789: ST_TO_ADDR
// end ;
7790: PPOPN 1
7792: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
7793: LD_EXP 17
7797: PUSH
7798: LD_EXP 44
7802: AND
7803: IFFALSE 7949
7805: GO 7807
7807: DISABLE
7808: LD_INT 0
7810: PPUSH
7811: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7812: LD_ADDR_VAR 0 1
7816: PUSH
7817: LD_INT 22
7819: PUSH
7820: LD_OWVAR 2
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: LD_INT 2
7831: PUSH
7832: LD_INT 30
7834: PUSH
7835: LD_INT 0
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PUSH
7842: LD_INT 30
7844: PUSH
7845: LD_INT 1
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: LIST
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PPUSH
7861: CALL_OW 69
7865: ST_TO_ADDR
// if not depot then
7866: LD_VAR 0 1
7870: NOT
7871: IFFALSE 7875
// exit ;
7873: GO 7949
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
7875: LD_ADDR_VAR 0 2
7879: PUSH
7880: LD_VAR 0 1
7884: PUSH
7885: LD_INT 1
7887: PPUSH
7888: LD_VAR 0 1
7892: PPUSH
7893: CALL_OW 12
7897: ARRAY
7898: PPUSH
7899: CALL_OW 274
7903: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
7904: LD_VAR 0 2
7908: PPUSH
7909: LD_INT 1
7911: PPUSH
7912: LD_INT 0
7914: PPUSH
7915: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
7919: LD_VAR 0 2
7923: PPUSH
7924: LD_INT 2
7926: PPUSH
7927: LD_INT 0
7929: PPUSH
7930: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
7934: LD_VAR 0 2
7938: PPUSH
7939: LD_INT 3
7941: PPUSH
7942: LD_INT 0
7944: PPUSH
7945: CALL_OW 277
// end ;
7949: PPOPN 2
7951: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
7952: LD_EXP 17
7956: PUSH
7957: LD_EXP 45
7961: AND
7962: IFFALSE 8059
7964: GO 7966
7966: DISABLE
7967: LD_INT 0
7969: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
7970: LD_ADDR_VAR 0 1
7974: PUSH
7975: LD_INT 22
7977: PUSH
7978: LD_OWVAR 2
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: PUSH
7987: LD_INT 21
7989: PUSH
7990: LD_INT 1
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: PUSH
7997: LD_INT 3
7999: PUSH
8000: LD_INT 23
8002: PUSH
8003: LD_INT 0
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PUSH
8010: EMPTY
8011: LIST
8012: LIST
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: LIST
8018: PPUSH
8019: CALL_OW 69
8023: ST_TO_ADDR
// if not tmp then
8024: LD_VAR 0 1
8028: NOT
8029: IFFALSE 8033
// exit ;
8031: GO 8059
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
8033: LD_VAR 0 1
8037: PUSH
8038: LD_INT 1
8040: PPUSH
8041: LD_VAR 0 1
8045: PPUSH
8046: CALL_OW 12
8050: ARRAY
8051: PPUSH
8052: LD_INT 200
8054: PPUSH
8055: CALL_OW 234
// end ;
8059: PPOPN 1
8061: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
8062: LD_EXP 17
8066: PUSH
8067: LD_EXP 46
8071: AND
8072: IFFALSE 8151
8074: GO 8076
8076: DISABLE
8077: LD_INT 0
8079: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
8080: LD_ADDR_VAR 0 1
8084: PUSH
8085: LD_INT 22
8087: PUSH
8088: LD_OWVAR 2
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: PUSH
8097: LD_INT 21
8099: PUSH
8100: LD_INT 2
8102: PUSH
8103: EMPTY
8104: LIST
8105: LIST
8106: PUSH
8107: EMPTY
8108: LIST
8109: LIST
8110: PPUSH
8111: CALL_OW 69
8115: ST_TO_ADDR
// if not tmp then
8116: LD_VAR 0 1
8120: NOT
8121: IFFALSE 8125
// exit ;
8123: GO 8151
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
8125: LD_VAR 0 1
8129: PUSH
8130: LD_INT 1
8132: PPUSH
8133: LD_VAR 0 1
8137: PPUSH
8138: CALL_OW 12
8142: ARRAY
8143: PPUSH
8144: LD_INT 60
8146: PPUSH
8147: CALL_OW 234
// end ;
8151: PPOPN 1
8153: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
8154: LD_EXP 17
8158: PUSH
8159: LD_EXP 47
8163: AND
8164: IFFALSE 8263
8166: GO 8168
8168: DISABLE
8169: LD_INT 0
8171: PPUSH
8172: PPUSH
// begin enable ;
8173: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
8174: LD_ADDR_VAR 0 1
8178: PUSH
8179: LD_INT 22
8181: PUSH
8182: LD_OWVAR 2
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 61
8193: PUSH
8194: EMPTY
8195: LIST
8196: PUSH
8197: LD_INT 33
8199: PUSH
8200: LD_INT 2
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: LIST
8211: PPUSH
8212: CALL_OW 69
8216: ST_TO_ADDR
// if not tmp then
8217: LD_VAR 0 1
8221: NOT
8222: IFFALSE 8226
// exit ;
8224: GO 8263
// for i in tmp do
8226: LD_ADDR_VAR 0 2
8230: PUSH
8231: LD_VAR 0 1
8235: PUSH
8236: FOR_IN
8237: IFFALSE 8261
// if IsControledBy ( i ) then
8239: LD_VAR 0 2
8243: PPUSH
8244: CALL_OW 312
8248: IFFALSE 8259
// ComUnlink ( i ) ;
8250: LD_VAR 0 2
8254: PPUSH
8255: CALL_OW 136
8259: GO 8236
8261: POP
8262: POP
// end ;
8263: PPOPN 2
8265: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
8266: LD_EXP 17
8270: PUSH
8271: LD_EXP 48
8275: AND
8276: IFFALSE 8416
8278: GO 8280
8280: DISABLE
8281: LD_INT 0
8283: PPUSH
8284: PPUSH
// begin ToLua ( displayPowell(); ) ;
8285: LD_STRING displayPowell();
8287: PPUSH
8288: CALL_OW 559
// uc_side := 0 ;
8292: LD_ADDR_OWVAR 20
8296: PUSH
8297: LD_INT 0
8299: ST_TO_ADDR
// uc_nation := 2 ;
8300: LD_ADDR_OWVAR 21
8304: PUSH
8305: LD_INT 2
8307: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
8308: LD_ADDR_OWVAR 37
8312: PUSH
8313: LD_INT 14
8315: ST_TO_ADDR
// vc_engine := engine_siberite ;
8316: LD_ADDR_OWVAR 39
8320: PUSH
8321: LD_INT 3
8323: ST_TO_ADDR
// vc_control := control_apeman ;
8324: LD_ADDR_OWVAR 38
8328: PUSH
8329: LD_INT 5
8331: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
8332: LD_ADDR_OWVAR 40
8336: PUSH
8337: LD_INT 29
8339: ST_TO_ADDR
// un := CreateVehicle ;
8340: LD_ADDR_VAR 0 2
8344: PUSH
8345: CALL_OW 45
8349: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_INT 1
8357: PPUSH
8358: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
8362: LD_INT 35
8364: PPUSH
8365: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
8369: LD_VAR 0 2
8373: PPUSH
8374: LD_INT 22
8376: PUSH
8377: LD_OWVAR 2
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: PPUSH
8386: CALL_OW 69
8390: PPUSH
8391: LD_VAR 0 2
8395: PPUSH
8396: CALL_OW 74
8400: PPUSH
8401: CALL_OW 115
// until IsDead ( un ) ;
8405: LD_VAR 0 2
8409: PPUSH
8410: CALL_OW 301
8414: IFFALSE 8362
// end ;
8416: PPOPN 2
8418: END
// every 0 0$1 trigger StreamModeActive and sStu do
8419: LD_EXP 17
8423: PUSH
8424: LD_EXP 56
8428: AND
8429: IFFALSE 8445
8431: GO 8433
8433: DISABLE
// begin ToLua ( displayStucuk(); ) ;
8434: LD_STRING displayStucuk();
8436: PPUSH
8437: CALL_OW 559
// ResetFog ;
8441: CALL_OW 335
// end ;
8445: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
8446: LD_EXP 17
8450: PUSH
8451: LD_EXP 49
8455: AND
8456: IFFALSE 8597
8458: GO 8460
8460: DISABLE
8461: LD_INT 0
8463: PPUSH
8464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8465: LD_ADDR_VAR 0 2
8469: PUSH
8470: LD_INT 22
8472: PUSH
8473: LD_OWVAR 2
8477: PUSH
8478: EMPTY
8479: LIST
8480: LIST
8481: PUSH
8482: LD_INT 21
8484: PUSH
8485: LD_INT 1
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: PUSH
8492: EMPTY
8493: LIST
8494: LIST
8495: PPUSH
8496: CALL_OW 69
8500: ST_TO_ADDR
// if not tmp then
8501: LD_VAR 0 2
8505: NOT
8506: IFFALSE 8510
// exit ;
8508: GO 8597
// un := tmp [ rand ( 1 , tmp ) ] ;
8510: LD_ADDR_VAR 0 1
8514: PUSH
8515: LD_VAR 0 2
8519: PUSH
8520: LD_INT 1
8522: PPUSH
8523: LD_VAR 0 2
8527: PPUSH
8528: CALL_OW 12
8532: ARRAY
8533: ST_TO_ADDR
// SetSide ( un , 0 ) ;
8534: LD_VAR 0 1
8538: PPUSH
8539: LD_INT 0
8541: PPUSH
8542: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
8546: LD_VAR 0 1
8550: PPUSH
8551: LD_OWVAR 3
8555: PUSH
8556: LD_VAR 0 1
8560: DIFF
8561: PPUSH
8562: LD_VAR 0 1
8566: PPUSH
8567: CALL_OW 74
8571: PPUSH
8572: CALL_OW 115
// wait ( 0 0$20 ) ;
8576: LD_INT 700
8578: PPUSH
8579: CALL_OW 67
// SetSide ( un , your_side ) ;
8583: LD_VAR 0 1
8587: PPUSH
8588: LD_OWVAR 2
8592: PPUSH
8593: CALL_OW 235
// end ;
8597: PPOPN 2
8599: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
8600: LD_EXP 17
8604: PUSH
8605: LD_EXP 50
8609: AND
8610: IFFALSE 8716
8612: GO 8614
8614: DISABLE
8615: LD_INT 0
8617: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8618: LD_ADDR_VAR 0 1
8622: PUSH
8623: LD_INT 22
8625: PUSH
8626: LD_OWVAR 2
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: PUSH
8635: LD_INT 2
8637: PUSH
8638: LD_INT 30
8640: PUSH
8641: LD_INT 0
8643: PUSH
8644: EMPTY
8645: LIST
8646: LIST
8647: PUSH
8648: LD_INT 30
8650: PUSH
8651: LD_INT 1
8653: PUSH
8654: EMPTY
8655: LIST
8656: LIST
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: LIST
8662: PUSH
8663: EMPTY
8664: LIST
8665: LIST
8666: PPUSH
8667: CALL_OW 69
8671: ST_TO_ADDR
// if not depot then
8672: LD_VAR 0 1
8676: NOT
8677: IFFALSE 8681
// exit ;
8679: GO 8716
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
8681: LD_VAR 0 1
8685: PUSH
8686: LD_INT 1
8688: ARRAY
8689: PPUSH
8690: CALL_OW 250
8694: PPUSH
8695: LD_VAR 0 1
8699: PUSH
8700: LD_INT 1
8702: ARRAY
8703: PPUSH
8704: CALL_OW 251
8708: PPUSH
8709: LD_INT 70
8711: PPUSH
8712: CALL_OW 495
// end ;
8716: PPOPN 1
8718: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
8719: LD_EXP 17
8723: PUSH
8724: LD_EXP 51
8728: AND
8729: IFFALSE 8940
8731: GO 8733
8733: DISABLE
8734: LD_INT 0
8736: PPUSH
8737: PPUSH
8738: PPUSH
8739: PPUSH
8740: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8741: LD_ADDR_VAR 0 5
8745: PUSH
8746: LD_INT 22
8748: PUSH
8749: LD_OWVAR 2
8753: PUSH
8754: EMPTY
8755: LIST
8756: LIST
8757: PUSH
8758: LD_INT 21
8760: PUSH
8761: LD_INT 1
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PPUSH
8772: CALL_OW 69
8776: ST_TO_ADDR
// if not tmp then
8777: LD_VAR 0 5
8781: NOT
8782: IFFALSE 8786
// exit ;
8784: GO 8940
// for i in tmp do
8786: LD_ADDR_VAR 0 1
8790: PUSH
8791: LD_VAR 0 5
8795: PUSH
8796: FOR_IN
8797: IFFALSE 8938
// begin d := rand ( 0 , 5 ) ;
8799: LD_ADDR_VAR 0 4
8803: PUSH
8804: LD_INT 0
8806: PPUSH
8807: LD_INT 5
8809: PPUSH
8810: CALL_OW 12
8814: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
8815: LD_ADDR_VAR 0 2
8819: PUSH
8820: LD_VAR 0 1
8824: PPUSH
8825: CALL_OW 250
8829: PPUSH
8830: LD_VAR 0 4
8834: PPUSH
8835: LD_INT 3
8837: PPUSH
8838: LD_INT 12
8840: PPUSH
8841: CALL_OW 12
8845: PPUSH
8846: CALL_OW 272
8850: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
8851: LD_ADDR_VAR 0 3
8855: PUSH
8856: LD_VAR 0 1
8860: PPUSH
8861: CALL_OW 251
8865: PPUSH
8866: LD_VAR 0 4
8870: PPUSH
8871: LD_INT 3
8873: PPUSH
8874: LD_INT 12
8876: PPUSH
8877: CALL_OW 12
8881: PPUSH
8882: CALL_OW 273
8886: ST_TO_ADDR
// if ValidHex ( x , y ) then
8887: LD_VAR 0 2
8891: PPUSH
8892: LD_VAR 0 3
8896: PPUSH
8897: CALL_OW 488
8901: IFFALSE 8936
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
8903: LD_VAR 0 1
8907: PPUSH
8908: LD_VAR 0 2
8912: PPUSH
8913: LD_VAR 0 3
8917: PPUSH
8918: LD_INT 3
8920: PPUSH
8921: LD_INT 6
8923: PPUSH
8924: CALL_OW 12
8928: PPUSH
8929: LD_INT 1
8931: PPUSH
8932: CALL_OW 483
// end ;
8936: GO 8796
8938: POP
8939: POP
// end ;
8940: PPOPN 5
8942: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
8943: LD_EXP 17
8947: PUSH
8948: LD_EXP 52
8952: AND
8953: IFFALSE 9047
8955: GO 8957
8957: DISABLE
8958: LD_INT 0
8960: PPUSH
8961: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
8962: LD_ADDR_VAR 0 2
8966: PUSH
8967: LD_INT 22
8969: PUSH
8970: LD_OWVAR 2
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: PUSH
8979: LD_INT 32
8981: PUSH
8982: LD_INT 1
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PUSH
8989: LD_INT 21
8991: PUSH
8992: LD_INT 2
8994: PUSH
8995: EMPTY
8996: LIST
8997: LIST
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: LIST
9003: PPUSH
9004: CALL_OW 69
9008: ST_TO_ADDR
// if not tmp then
9009: LD_VAR 0 2
9013: NOT
9014: IFFALSE 9018
// exit ;
9016: GO 9047
// for i in tmp do
9018: LD_ADDR_VAR 0 1
9022: PUSH
9023: LD_VAR 0 2
9027: PUSH
9028: FOR_IN
9029: IFFALSE 9045
// SetFuel ( i , 0 ) ;
9031: LD_VAR 0 1
9035: PPUSH
9036: LD_INT 0
9038: PPUSH
9039: CALL_OW 240
9043: GO 9028
9045: POP
9046: POP
// end ;
9047: PPOPN 2
9049: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
9050: LD_EXP 17
9054: PUSH
9055: LD_EXP 53
9059: AND
9060: IFFALSE 9126
9062: GO 9064
9064: DISABLE
9065: LD_INT 0
9067: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
9068: LD_ADDR_VAR 0 1
9072: PUSH
9073: LD_INT 22
9075: PUSH
9076: LD_OWVAR 2
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: PUSH
9085: LD_INT 30
9087: PUSH
9088: LD_INT 29
9090: PUSH
9091: EMPTY
9092: LIST
9093: LIST
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: PPUSH
9099: CALL_OW 69
9103: ST_TO_ADDR
// if not tmp then
9104: LD_VAR 0 1
9108: NOT
9109: IFFALSE 9113
// exit ;
9111: GO 9126
// DestroyUnit ( tmp [ 1 ] ) ;
9113: LD_VAR 0 1
9117: PUSH
9118: LD_INT 1
9120: ARRAY
9121: PPUSH
9122: CALL_OW 65
// end ;
9126: PPOPN 1
9128: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
9129: LD_EXP 17
9133: PUSH
9134: LD_EXP 55
9138: AND
9139: IFFALSE 9268
9141: GO 9143
9143: DISABLE
9144: LD_INT 0
9146: PPUSH
// begin uc_side := 0 ;
9147: LD_ADDR_OWVAR 20
9151: PUSH
9152: LD_INT 0
9154: ST_TO_ADDR
// uc_nation := nation_arabian ;
9155: LD_ADDR_OWVAR 21
9159: PUSH
9160: LD_INT 2
9162: ST_TO_ADDR
// hc_gallery :=  ;
9163: LD_ADDR_OWVAR 33
9167: PUSH
9168: LD_STRING 
9170: ST_TO_ADDR
// hc_name :=  ;
9171: LD_ADDR_OWVAR 26
9175: PUSH
9176: LD_STRING 
9178: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
9179: LD_INT 1
9181: PPUSH
9182: LD_INT 11
9184: PPUSH
9185: LD_INT 10
9187: PPUSH
9188: CALL_OW 380
// un := CreateHuman ;
9192: LD_ADDR_VAR 0 1
9196: PUSH
9197: CALL_OW 44
9201: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
9202: LD_VAR 0 1
9206: PPUSH
9207: LD_INT 1
9209: PPUSH
9210: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
9214: LD_INT 35
9216: PPUSH
9217: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
9221: LD_VAR 0 1
9225: PPUSH
9226: LD_INT 22
9228: PUSH
9229: LD_OWVAR 2
9233: PUSH
9234: EMPTY
9235: LIST
9236: LIST
9237: PPUSH
9238: CALL_OW 69
9242: PPUSH
9243: LD_VAR 0 1
9247: PPUSH
9248: CALL_OW 74
9252: PPUSH
9253: CALL_OW 115
// until IsDead ( un ) ;
9257: LD_VAR 0 1
9261: PPUSH
9262: CALL_OW 301
9266: IFFALSE 9214
// end ;
9268: PPOPN 1
9270: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
9271: LD_EXP 17
9275: PUSH
9276: LD_EXP 57
9280: AND
9281: IFFALSE 9293
9283: GO 9285
9285: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
9286: LD_STRING earthquake(getX(game), 0, 32)
9288: PPUSH
9289: CALL_OW 559
9293: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
9294: LD_EXP 17
9298: PUSH
9299: LD_EXP 58
9303: AND
9304: IFFALSE 9395
9306: GO 9308
9308: DISABLE
9309: LD_INT 0
9311: PPUSH
// begin enable ;
9312: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
9313: LD_ADDR_VAR 0 1
9317: PUSH
9318: LD_INT 22
9320: PUSH
9321: LD_OWVAR 2
9325: PUSH
9326: EMPTY
9327: LIST
9328: LIST
9329: PUSH
9330: LD_INT 21
9332: PUSH
9333: LD_INT 2
9335: PUSH
9336: EMPTY
9337: LIST
9338: LIST
9339: PUSH
9340: LD_INT 33
9342: PUSH
9343: LD_INT 3
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: PUSH
9350: EMPTY
9351: LIST
9352: LIST
9353: LIST
9354: PPUSH
9355: CALL_OW 69
9359: ST_TO_ADDR
// if not tmp then
9360: LD_VAR 0 1
9364: NOT
9365: IFFALSE 9369
// exit ;
9367: GO 9395
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
9369: LD_VAR 0 1
9373: PUSH
9374: LD_INT 1
9376: PPUSH
9377: LD_VAR 0 1
9381: PPUSH
9382: CALL_OW 12
9386: ARRAY
9387: PPUSH
9388: LD_INT 1
9390: PPUSH
9391: CALL_OW 234
// end ;
9395: PPOPN 1
9397: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
9398: LD_EXP 17
9402: PUSH
9403: LD_EXP 59
9407: AND
9408: IFFALSE 9549
9410: GO 9412
9412: DISABLE
9413: LD_INT 0
9415: PPUSH
9416: PPUSH
9417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9418: LD_ADDR_VAR 0 3
9422: PUSH
9423: LD_INT 22
9425: PUSH
9426: LD_OWVAR 2
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: PUSH
9435: LD_INT 25
9437: PUSH
9438: LD_INT 1
9440: PUSH
9441: EMPTY
9442: LIST
9443: LIST
9444: PUSH
9445: EMPTY
9446: LIST
9447: LIST
9448: PPUSH
9449: CALL_OW 69
9453: ST_TO_ADDR
// if not tmp then
9454: LD_VAR 0 3
9458: NOT
9459: IFFALSE 9463
// exit ;
9461: GO 9549
// un := tmp [ rand ( 1 , tmp ) ] ;
9463: LD_ADDR_VAR 0 2
9467: PUSH
9468: LD_VAR 0 3
9472: PUSH
9473: LD_INT 1
9475: PPUSH
9476: LD_VAR 0 3
9480: PPUSH
9481: CALL_OW 12
9485: ARRAY
9486: ST_TO_ADDR
// if Crawls ( un ) then
9487: LD_VAR 0 2
9491: PPUSH
9492: CALL_OW 318
9496: IFFALSE 9507
// ComWalk ( un ) ;
9498: LD_VAR 0 2
9502: PPUSH
9503: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
9507: LD_VAR 0 2
9511: PPUSH
9512: LD_INT 9
9514: PPUSH
9515: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
9519: LD_INT 28
9521: PPUSH
9522: LD_OWVAR 2
9526: PPUSH
9527: LD_INT 2
9529: PPUSH
9530: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
9534: LD_INT 29
9536: PPUSH
9537: LD_OWVAR 2
9541: PPUSH
9542: LD_INT 2
9544: PPUSH
9545: CALL_OW 322
// end ;
9549: PPOPN 3
9551: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
9552: LD_EXP 17
9556: PUSH
9557: LD_EXP 60
9561: AND
9562: IFFALSE 9673
9564: GO 9566
9566: DISABLE
9567: LD_INT 0
9569: PPUSH
9570: PPUSH
9571: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9572: LD_ADDR_VAR 0 3
9576: PUSH
9577: LD_INT 22
9579: PUSH
9580: LD_OWVAR 2
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: PUSH
9589: LD_INT 25
9591: PUSH
9592: LD_INT 1
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PPUSH
9603: CALL_OW 69
9607: ST_TO_ADDR
// if not tmp then
9608: LD_VAR 0 3
9612: NOT
9613: IFFALSE 9617
// exit ;
9615: GO 9673
// un := tmp [ rand ( 1 , tmp ) ] ;
9617: LD_ADDR_VAR 0 2
9621: PUSH
9622: LD_VAR 0 3
9626: PUSH
9627: LD_INT 1
9629: PPUSH
9630: LD_VAR 0 3
9634: PPUSH
9635: CALL_OW 12
9639: ARRAY
9640: ST_TO_ADDR
// if Crawls ( un ) then
9641: LD_VAR 0 2
9645: PPUSH
9646: CALL_OW 318
9650: IFFALSE 9661
// ComWalk ( un ) ;
9652: LD_VAR 0 2
9656: PPUSH
9657: CALL_OW 138
// SetClass ( un , class_mortar ) ;
9661: LD_VAR 0 2
9665: PPUSH
9666: LD_INT 8
9668: PPUSH
9669: CALL_OW 336
// end ;
9673: PPOPN 3
9675: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
9676: LD_EXP 17
9680: PUSH
9681: LD_EXP 61
9685: AND
9686: IFFALSE 9830
9688: GO 9690
9690: DISABLE
9691: LD_INT 0
9693: PPUSH
9694: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
9695: LD_ADDR_VAR 0 2
9699: PUSH
9700: LD_INT 22
9702: PUSH
9703: LD_OWVAR 2
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: PUSH
9712: LD_INT 21
9714: PUSH
9715: LD_INT 2
9717: PUSH
9718: EMPTY
9719: LIST
9720: LIST
9721: PUSH
9722: LD_INT 2
9724: PUSH
9725: LD_INT 34
9727: PUSH
9728: LD_INT 12
9730: PUSH
9731: EMPTY
9732: LIST
9733: LIST
9734: PUSH
9735: LD_INT 34
9737: PUSH
9738: LD_INT 51
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: PUSH
9745: LD_INT 34
9747: PUSH
9748: LD_INT 32
9750: PUSH
9751: EMPTY
9752: LIST
9753: LIST
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: LIST
9759: LIST
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: LIST
9765: PPUSH
9766: CALL_OW 69
9770: ST_TO_ADDR
// if not tmp then
9771: LD_VAR 0 2
9775: NOT
9776: IFFALSE 9780
// exit ;
9778: GO 9830
// for i in tmp do
9780: LD_ADDR_VAR 0 1
9784: PUSH
9785: LD_VAR 0 2
9789: PUSH
9790: FOR_IN
9791: IFFALSE 9828
// if GetCargo ( i , mat_artifact ) = 0 then
9793: LD_VAR 0 1
9797: PPUSH
9798: LD_INT 4
9800: PPUSH
9801: CALL_OW 289
9805: PUSH
9806: LD_INT 0
9808: EQUAL
9809: IFFALSE 9826
// SetCargo ( i , mat_siberit , 100 ) ;
9811: LD_VAR 0 1
9815: PPUSH
9816: LD_INT 3
9818: PPUSH
9819: LD_INT 100
9821: PPUSH
9822: CALL_OW 290
9826: GO 9790
9828: POP
9829: POP
// end ;
9830: PPOPN 2
9832: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
9833: LD_EXP 17
9837: PUSH
9838: LD_EXP 62
9842: AND
9843: IFFALSE 10026
9845: GO 9847
9847: DISABLE
9848: LD_INT 0
9850: PPUSH
9851: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
9852: LD_ADDR_VAR 0 2
9856: PUSH
9857: LD_INT 22
9859: PUSH
9860: LD_OWVAR 2
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PPUSH
9869: CALL_OW 69
9873: ST_TO_ADDR
// if not tmp then
9874: LD_VAR 0 2
9878: NOT
9879: IFFALSE 9883
// exit ;
9881: GO 10026
// for i := 1 to 2 do
9883: LD_ADDR_VAR 0 1
9887: PUSH
9888: DOUBLE
9889: LD_INT 1
9891: DEC
9892: ST_TO_ADDR
9893: LD_INT 2
9895: PUSH
9896: FOR_TO
9897: IFFALSE 10024
// begin uc_side := your_side ;
9899: LD_ADDR_OWVAR 20
9903: PUSH
9904: LD_OWVAR 2
9908: ST_TO_ADDR
// uc_nation := nation_american ;
9909: LD_ADDR_OWVAR 21
9913: PUSH
9914: LD_INT 1
9916: ST_TO_ADDR
// vc_chassis := us_morphling ;
9917: LD_ADDR_OWVAR 37
9921: PUSH
9922: LD_INT 5
9924: ST_TO_ADDR
// vc_engine := engine_siberite ;
9925: LD_ADDR_OWVAR 39
9929: PUSH
9930: LD_INT 3
9932: ST_TO_ADDR
// vc_control := control_computer ;
9933: LD_ADDR_OWVAR 38
9937: PUSH
9938: LD_INT 3
9940: ST_TO_ADDR
// vc_weapon := us_double_laser ;
9941: LD_ADDR_OWVAR 40
9945: PUSH
9946: LD_INT 10
9948: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
9949: LD_VAR 0 2
9953: PUSH
9954: LD_INT 1
9956: ARRAY
9957: PPUSH
9958: CALL_OW 310
9962: NOT
9963: IFFALSE 10010
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
9965: CALL_OW 45
9969: PPUSH
9970: LD_VAR 0 2
9974: PUSH
9975: LD_INT 1
9977: ARRAY
9978: PPUSH
9979: CALL_OW 250
9983: PPUSH
9984: LD_VAR 0 2
9988: PUSH
9989: LD_INT 1
9991: ARRAY
9992: PPUSH
9993: CALL_OW 251
9997: PPUSH
9998: LD_INT 12
10000: PPUSH
10001: LD_INT 1
10003: PPUSH
10004: CALL_OW 50
10008: GO 10022
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
10010: CALL_OW 45
10014: PPUSH
10015: LD_INT 1
10017: PPUSH
10018: CALL_OW 51
// end ;
10022: GO 9896
10024: POP
10025: POP
// end ;
10026: PPOPN 2
10028: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
10029: LD_EXP 17
10033: PUSH
10034: LD_EXP 63
10038: AND
10039: IFFALSE 10261
10041: GO 10043
10043: DISABLE
10044: LD_INT 0
10046: PPUSH
10047: PPUSH
10048: PPUSH
10049: PPUSH
10050: PPUSH
10051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
10052: LD_ADDR_VAR 0 6
10056: PUSH
10057: LD_INT 22
10059: PUSH
10060: LD_OWVAR 2
10064: PUSH
10065: EMPTY
10066: LIST
10067: LIST
10068: PUSH
10069: LD_INT 21
10071: PUSH
10072: LD_INT 1
10074: PUSH
10075: EMPTY
10076: LIST
10077: LIST
10078: PUSH
10079: LD_INT 3
10081: PUSH
10082: LD_INT 23
10084: PUSH
10085: LD_INT 0
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: PUSH
10092: EMPTY
10093: LIST
10094: LIST
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: PPUSH
10101: CALL_OW 69
10105: ST_TO_ADDR
// if not tmp then
10106: LD_VAR 0 6
10110: NOT
10111: IFFALSE 10115
// exit ;
10113: GO 10261
// s1 := rand ( 1 , 4 ) ;
10115: LD_ADDR_VAR 0 2
10119: PUSH
10120: LD_INT 1
10122: PPUSH
10123: LD_INT 4
10125: PPUSH
10126: CALL_OW 12
10130: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
10131: LD_ADDR_VAR 0 4
10135: PUSH
10136: LD_VAR 0 6
10140: PUSH
10141: LD_INT 1
10143: ARRAY
10144: PPUSH
10145: LD_VAR 0 2
10149: PPUSH
10150: CALL_OW 259
10154: ST_TO_ADDR
// if s1 = 1 then
10155: LD_VAR 0 2
10159: PUSH
10160: LD_INT 1
10162: EQUAL
10163: IFFALSE 10183
// s2 := rand ( 2 , 4 ) else
10165: LD_ADDR_VAR 0 3
10169: PUSH
10170: LD_INT 2
10172: PPUSH
10173: LD_INT 4
10175: PPUSH
10176: CALL_OW 12
10180: ST_TO_ADDR
10181: GO 10191
// s2 := 1 ;
10183: LD_ADDR_VAR 0 3
10187: PUSH
10188: LD_INT 1
10190: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
10191: LD_ADDR_VAR 0 5
10195: PUSH
10196: LD_VAR 0 6
10200: PUSH
10201: LD_INT 1
10203: ARRAY
10204: PPUSH
10205: LD_VAR 0 3
10209: PPUSH
10210: CALL_OW 259
10214: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
10215: LD_VAR 0 6
10219: PUSH
10220: LD_INT 1
10222: ARRAY
10223: PPUSH
10224: LD_VAR 0 2
10228: PPUSH
10229: LD_VAR 0 5
10233: PPUSH
10234: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
10238: LD_VAR 0 6
10242: PUSH
10243: LD_INT 1
10245: ARRAY
10246: PPUSH
10247: LD_VAR 0 3
10251: PPUSH
10252: LD_VAR 0 4
10256: PPUSH
10257: CALL_OW 237
// end ;
10261: PPOPN 6
10263: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
10264: LD_EXP 17
10268: PUSH
10269: LD_EXP 64
10273: AND
10274: IFFALSE 10353
10276: GO 10278
10278: DISABLE
10279: LD_INT 0
10281: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
10282: LD_ADDR_VAR 0 1
10286: PUSH
10287: LD_INT 22
10289: PUSH
10290: LD_OWVAR 2
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: PUSH
10299: LD_INT 30
10301: PUSH
10302: LD_INT 3
10304: PUSH
10305: EMPTY
10306: LIST
10307: LIST
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: PPUSH
10313: CALL_OW 69
10317: ST_TO_ADDR
// if not tmp then
10318: LD_VAR 0 1
10322: NOT
10323: IFFALSE 10327
// exit ;
10325: GO 10353
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
10327: LD_VAR 0 1
10331: PUSH
10332: LD_INT 1
10334: PPUSH
10335: LD_VAR 0 1
10339: PPUSH
10340: CALL_OW 12
10344: ARRAY
10345: PPUSH
10346: LD_INT 1
10348: PPUSH
10349: CALL_OW 234
// end ;
10353: PPOPN 1
10355: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
10356: LD_EXP 17
10360: PUSH
10361: LD_EXP 65
10365: AND
10366: IFFALSE 10478
10368: GO 10370
10370: DISABLE
10371: LD_INT 0
10373: PPUSH
10374: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
10375: LD_ADDR_VAR 0 2
10379: PUSH
10380: LD_INT 22
10382: PUSH
10383: LD_OWVAR 2
10387: PUSH
10388: EMPTY
10389: LIST
10390: LIST
10391: PUSH
10392: LD_INT 2
10394: PUSH
10395: LD_INT 30
10397: PUSH
10398: LD_INT 27
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PUSH
10405: LD_INT 30
10407: PUSH
10408: LD_INT 26
10410: PUSH
10411: EMPTY
10412: LIST
10413: LIST
10414: PUSH
10415: LD_INT 30
10417: PUSH
10418: LD_INT 28
10420: PUSH
10421: EMPTY
10422: LIST
10423: LIST
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: LIST
10429: LIST
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: PPUSH
10435: CALL_OW 69
10439: ST_TO_ADDR
// if not tmp then
10440: LD_VAR 0 2
10444: NOT
10445: IFFALSE 10449
// exit ;
10447: GO 10478
// for i in tmp do
10449: LD_ADDR_VAR 0 1
10453: PUSH
10454: LD_VAR 0 2
10458: PUSH
10459: FOR_IN
10460: IFFALSE 10476
// SetLives ( i , 1 ) ;
10462: LD_VAR 0 1
10466: PPUSH
10467: LD_INT 1
10469: PPUSH
10470: CALL_OW 234
10474: GO 10459
10476: POP
10477: POP
// end ;
10478: PPOPN 2
10480: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
10481: LD_EXP 17
10485: PUSH
10486: LD_EXP 66
10490: AND
10491: IFFALSE 10765
10493: GO 10495
10495: DISABLE
10496: LD_INT 0
10498: PPUSH
10499: PPUSH
10500: PPUSH
// begin i := rand ( 1 , 7 ) ;
10501: LD_ADDR_VAR 0 1
10505: PUSH
10506: LD_INT 1
10508: PPUSH
10509: LD_INT 7
10511: PPUSH
10512: CALL_OW 12
10516: ST_TO_ADDR
// case i of 1 :
10517: LD_VAR 0 1
10521: PUSH
10522: LD_INT 1
10524: DOUBLE
10525: EQUAL
10526: IFTRUE 10530
10528: GO 10540
10530: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
10531: LD_STRING earthquake(getX(game), 0, 32)
10533: PPUSH
10534: CALL_OW 559
10538: GO 10765
10540: LD_INT 2
10542: DOUBLE
10543: EQUAL
10544: IFTRUE 10548
10546: GO 10562
10548: POP
// begin ToLua ( displayStucuk(); ) ;
10549: LD_STRING displayStucuk();
10551: PPUSH
10552: CALL_OW 559
// ResetFog ;
10556: CALL_OW 335
// end ; 3 :
10560: GO 10765
10562: LD_INT 3
10564: DOUBLE
10565: EQUAL
10566: IFTRUE 10570
10568: GO 10674
10570: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10571: LD_ADDR_VAR 0 2
10575: PUSH
10576: LD_INT 22
10578: PUSH
10579: LD_OWVAR 2
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PUSH
10588: LD_INT 25
10590: PUSH
10591: LD_INT 1
10593: PUSH
10594: EMPTY
10595: LIST
10596: LIST
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PPUSH
10602: CALL_OW 69
10606: ST_TO_ADDR
// if not tmp then
10607: LD_VAR 0 2
10611: NOT
10612: IFFALSE 10616
// exit ;
10614: GO 10765
// un := tmp [ rand ( 1 , tmp ) ] ;
10616: LD_ADDR_VAR 0 3
10620: PUSH
10621: LD_VAR 0 2
10625: PUSH
10626: LD_INT 1
10628: PPUSH
10629: LD_VAR 0 2
10633: PPUSH
10634: CALL_OW 12
10638: ARRAY
10639: ST_TO_ADDR
// if Crawls ( un ) then
10640: LD_VAR 0 3
10644: PPUSH
10645: CALL_OW 318
10649: IFFALSE 10660
// ComWalk ( un ) ;
10651: LD_VAR 0 3
10655: PPUSH
10656: CALL_OW 138
// SetClass ( un , class_mortar ) ;
10660: LD_VAR 0 3
10664: PPUSH
10665: LD_INT 8
10667: PPUSH
10668: CALL_OW 336
// end ; 4 :
10672: GO 10765
10674: LD_INT 4
10676: DOUBLE
10677: EQUAL
10678: IFTRUE 10682
10680: GO 10743
10682: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
10683: LD_ADDR_VAR 0 2
10687: PUSH
10688: LD_INT 22
10690: PUSH
10691: LD_OWVAR 2
10695: PUSH
10696: EMPTY
10697: LIST
10698: LIST
10699: PUSH
10700: LD_INT 30
10702: PUSH
10703: LD_INT 29
10705: PUSH
10706: EMPTY
10707: LIST
10708: LIST
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PPUSH
10714: CALL_OW 69
10718: ST_TO_ADDR
// if not tmp then
10719: LD_VAR 0 2
10723: NOT
10724: IFFALSE 10728
// exit ;
10726: GO 10765
// DestroyUnit ( tmp [ 1 ] ) ;
10728: LD_VAR 0 2
10732: PUSH
10733: LD_INT 1
10735: ARRAY
10736: PPUSH
10737: CALL_OW 65
// end ; 5 .. 7 :
10741: GO 10765
10743: LD_INT 5
10745: DOUBLE
10746: GREATEREQUAL
10747: IFFALSE 10755
10749: LD_INT 7
10751: DOUBLE
10752: LESSEQUAL
10753: IFTRUE 10757
10755: GO 10764
10757: POP
// StreamSibBomb ; end ;
10758: CALL 7015 0 0
10762: GO 10765
10764: POP
// end ;
10765: PPOPN 3
10767: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
10768: LD_EXP 17
10772: PUSH
10773: LD_EXP 67
10777: AND
10778: IFFALSE 10934
10780: GO 10782
10782: DISABLE
10783: LD_INT 0
10785: PPUSH
10786: PPUSH
10787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
10788: LD_ADDR_VAR 0 2
10792: PUSH
10793: LD_INT 81
10795: PUSH
10796: LD_OWVAR 2
10800: PUSH
10801: EMPTY
10802: LIST
10803: LIST
10804: PUSH
10805: LD_INT 2
10807: PUSH
10808: LD_INT 21
10810: PUSH
10811: LD_INT 1
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PUSH
10818: LD_INT 21
10820: PUSH
10821: LD_INT 2
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PUSH
10828: EMPTY
10829: LIST
10830: LIST
10831: LIST
10832: PUSH
10833: EMPTY
10834: LIST
10835: LIST
10836: PPUSH
10837: CALL_OW 69
10841: ST_TO_ADDR
// if not tmp then
10842: LD_VAR 0 2
10846: NOT
10847: IFFALSE 10851
// exit ;
10849: GO 10934
// p := 0 ;
10851: LD_ADDR_VAR 0 3
10855: PUSH
10856: LD_INT 0
10858: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10859: LD_INT 35
10861: PPUSH
10862: CALL_OW 67
// p := p + 1 ;
10866: LD_ADDR_VAR 0 3
10870: PUSH
10871: LD_VAR 0 3
10875: PUSH
10876: LD_INT 1
10878: PLUS
10879: ST_TO_ADDR
// for i in tmp do
10880: LD_ADDR_VAR 0 1
10884: PUSH
10885: LD_VAR 0 2
10889: PUSH
10890: FOR_IN
10891: IFFALSE 10922
// if GetLives ( i ) < 1000 then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 256
10902: PUSH
10903: LD_INT 1000
10905: LESS
10906: IFFALSE 10920
// SetLives ( i , 1000 ) ;
10908: LD_VAR 0 1
10912: PPUSH
10913: LD_INT 1000
10915: PPUSH
10916: CALL_OW 234
10920: GO 10890
10922: POP
10923: POP
// until p > 20 ;
10924: LD_VAR 0 3
10928: PUSH
10929: LD_INT 20
10931: GREATER
10932: IFFALSE 10859
// end ;
10934: PPOPN 3
10936: END
// every 0 0$1 trigger StreamModeActive and sTime do
10937: LD_EXP 17
10941: PUSH
10942: LD_EXP 68
10946: AND
10947: IFFALSE 10982
10949: GO 10951
10951: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
10952: LD_INT 28
10954: PPUSH
10955: LD_OWVAR 2
10959: PPUSH
10960: LD_INT 2
10962: PPUSH
10963: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
10967: LD_INT 30
10969: PPUSH
10970: LD_OWVAR 2
10974: PPUSH
10975: LD_INT 2
10977: PPUSH
10978: CALL_OW 322
// end ;
10982: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
10983: LD_EXP 17
10987: PUSH
10988: LD_EXP 69
10992: AND
10993: IFFALSE 11114
10995: GO 10997
10997: DISABLE
10998: LD_INT 0
11000: PPUSH
11001: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11002: LD_ADDR_VAR 0 2
11006: PUSH
11007: LD_INT 22
11009: PUSH
11010: LD_OWVAR 2
11014: PUSH
11015: EMPTY
11016: LIST
11017: LIST
11018: PUSH
11019: LD_INT 21
11021: PUSH
11022: LD_INT 1
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: PUSH
11029: LD_INT 3
11031: PUSH
11032: LD_INT 23
11034: PUSH
11035: LD_INT 0
11037: PUSH
11038: EMPTY
11039: LIST
11040: LIST
11041: PUSH
11042: EMPTY
11043: LIST
11044: LIST
11045: PUSH
11046: EMPTY
11047: LIST
11048: LIST
11049: LIST
11050: PPUSH
11051: CALL_OW 69
11055: ST_TO_ADDR
// if not tmp then
11056: LD_VAR 0 2
11060: NOT
11061: IFFALSE 11065
// exit ;
11063: GO 11114
// for i in tmp do
11065: LD_ADDR_VAR 0 1
11069: PUSH
11070: LD_VAR 0 2
11074: PUSH
11075: FOR_IN
11076: IFFALSE 11112
// begin if Crawls ( i ) then
11078: LD_VAR 0 1
11082: PPUSH
11083: CALL_OW 318
11087: IFFALSE 11098
// ComWalk ( i ) ;
11089: LD_VAR 0 1
11093: PPUSH
11094: CALL_OW 138
// SetClass ( i , 2 ) ;
11098: LD_VAR 0 1
11102: PPUSH
11103: LD_INT 2
11105: PPUSH
11106: CALL_OW 336
// end ;
11110: GO 11075
11112: POP
11113: POP
// end ;
11114: PPOPN 2
11116: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
11117: LD_EXP 17
11121: PUSH
11122: LD_EXP 70
11126: AND
11127: IFFALSE 11408
11129: GO 11131
11131: DISABLE
11132: LD_INT 0
11134: PPUSH
11135: PPUSH
11136: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
11137: LD_OWVAR 2
11141: PPUSH
11142: LD_INT 9
11144: PPUSH
11145: LD_INT 1
11147: PPUSH
11148: LD_INT 1
11150: PPUSH
11151: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
11155: LD_INT 9
11157: PPUSH
11158: LD_OWVAR 2
11162: PPUSH
11163: CALL_OW 343
// uc_side := 9 ;
11167: LD_ADDR_OWVAR 20
11171: PUSH
11172: LD_INT 9
11174: ST_TO_ADDR
// uc_nation := 2 ;
11175: LD_ADDR_OWVAR 21
11179: PUSH
11180: LD_INT 2
11182: ST_TO_ADDR
// hc_name := Dark Warrior ;
11183: LD_ADDR_OWVAR 26
11187: PUSH
11188: LD_STRING Dark Warrior
11190: ST_TO_ADDR
// hc_gallery :=  ;
11191: LD_ADDR_OWVAR 33
11195: PUSH
11196: LD_STRING 
11198: ST_TO_ADDR
// hc_noskilllimit := true ;
11199: LD_ADDR_OWVAR 76
11203: PUSH
11204: LD_INT 1
11206: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
11207: LD_ADDR_OWVAR 31
11211: PUSH
11212: LD_INT 30
11214: PUSH
11215: LD_INT 30
11217: PUSH
11218: LD_INT 30
11220: PUSH
11221: LD_INT 30
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: ST_TO_ADDR
// un := CreateHuman ;
11230: LD_ADDR_VAR 0 3
11234: PUSH
11235: CALL_OW 44
11239: ST_TO_ADDR
// hc_noskilllimit := false ;
11240: LD_ADDR_OWVAR 76
11244: PUSH
11245: LD_INT 0
11247: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11248: LD_VAR 0 3
11252: PPUSH
11253: LD_INT 1
11255: PPUSH
11256: CALL_OW 51
// p := 0 ;
11260: LD_ADDR_VAR 0 2
11264: PUSH
11265: LD_INT 0
11267: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11268: LD_INT 35
11270: PPUSH
11271: CALL_OW 67
// p := p + 1 ;
11275: LD_ADDR_VAR 0 2
11279: PUSH
11280: LD_VAR 0 2
11284: PUSH
11285: LD_INT 1
11287: PLUS
11288: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
11289: LD_VAR 0 3
11293: PPUSH
11294: CALL_OW 256
11298: PUSH
11299: LD_INT 1000
11301: LESS
11302: IFFALSE 11316
// SetLives ( un , 1000 ) ;
11304: LD_VAR 0 3
11308: PPUSH
11309: LD_INT 1000
11311: PPUSH
11312: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
11316: LD_VAR 0 3
11320: PPUSH
11321: LD_INT 81
11323: PUSH
11324: LD_OWVAR 2
11328: PUSH
11329: EMPTY
11330: LIST
11331: LIST
11332: PUSH
11333: LD_INT 91
11335: PUSH
11336: LD_VAR 0 3
11340: PUSH
11341: LD_INT 30
11343: PUSH
11344: EMPTY
11345: LIST
11346: LIST
11347: LIST
11348: PUSH
11349: EMPTY
11350: LIST
11351: LIST
11352: PPUSH
11353: CALL_OW 69
11357: PPUSH
11358: LD_VAR 0 3
11362: PPUSH
11363: CALL_OW 74
11367: PPUSH
11368: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
11372: LD_VAR 0 2
11376: PUSH
11377: LD_INT 60
11379: GREATER
11380: PUSH
11381: LD_VAR 0 3
11385: PPUSH
11386: CALL_OW 301
11390: OR
11391: IFFALSE 11268
// if un then
11393: LD_VAR 0 3
11397: IFFALSE 11408
// RemoveUnit ( un ) ;
11399: LD_VAR 0 3
11403: PPUSH
11404: CALL_OW 64
// end ;
11408: PPOPN 3
11410: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
11411: LD_INT 0
11413: PPUSH
// case cmd of 301 :
11414: LD_VAR 0 1
11418: PUSH
11419: LD_INT 301
11421: DOUBLE
11422: EQUAL
11423: IFTRUE 11427
11425: GO 11459
11427: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
11428: LD_VAR 0 6
11432: PPUSH
11433: LD_VAR 0 7
11437: PPUSH
11438: LD_VAR 0 8
11442: PPUSH
11443: LD_VAR 0 4
11447: PPUSH
11448: LD_VAR 0 5
11452: PPUSH
11453: CALL 12660 0 5
11457: GO 11580
11459: LD_INT 302
11461: DOUBLE
11462: EQUAL
11463: IFTRUE 11467
11465: GO 11504
11467: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
11468: LD_VAR 0 6
11472: PPUSH
11473: LD_VAR 0 7
11477: PPUSH
11478: LD_VAR 0 8
11482: PPUSH
11483: LD_VAR 0 9
11487: PPUSH
11488: LD_VAR 0 4
11492: PPUSH
11493: LD_VAR 0 5
11497: PPUSH
11498: CALL 12751 0 6
11502: GO 11580
11504: LD_INT 303
11506: DOUBLE
11507: EQUAL
11508: IFTRUE 11512
11510: GO 11549
11512: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
11513: LD_VAR 0 6
11517: PPUSH
11518: LD_VAR 0 7
11522: PPUSH
11523: LD_VAR 0 8
11527: PPUSH
11528: LD_VAR 0 9
11532: PPUSH
11533: LD_VAR 0 4
11537: PPUSH
11538: LD_VAR 0 5
11542: PPUSH
11543: CALL 11585 0 6
11547: GO 11580
11549: LD_INT 304
11551: DOUBLE
11552: EQUAL
11553: IFTRUE 11557
11555: GO 11579
11557: POP
// hHackTeleport ( unit , x , y ) ; end ;
11558: LD_VAR 0 2
11562: PPUSH
11563: LD_VAR 0 4
11567: PPUSH
11568: LD_VAR 0 5
11572: PPUSH
11573: CALL 13344 0 3
11577: GO 11580
11579: POP
// end ;
11580: LD_VAR 0 12
11584: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
11585: LD_INT 0
11587: PPUSH
11588: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
11589: LD_VAR 0 1
11593: PUSH
11594: LD_INT 1
11596: LESS
11597: PUSH
11598: LD_VAR 0 1
11602: PUSH
11603: LD_INT 3
11605: GREATER
11606: OR
11607: PUSH
11608: LD_VAR 0 5
11612: PPUSH
11613: LD_VAR 0 6
11617: PPUSH
11618: CALL_OW 428
11622: OR
11623: IFFALSE 11627
// exit ;
11625: GO 12347
// uc_side := your_side ;
11627: LD_ADDR_OWVAR 20
11631: PUSH
11632: LD_OWVAR 2
11636: ST_TO_ADDR
// uc_nation := nation ;
11637: LD_ADDR_OWVAR 21
11641: PUSH
11642: LD_VAR 0 1
11646: ST_TO_ADDR
// bc_level = 1 ;
11647: LD_ADDR_OWVAR 43
11651: PUSH
11652: LD_INT 1
11654: ST_TO_ADDR
// case btype of 1 :
11655: LD_VAR 0 2
11659: PUSH
11660: LD_INT 1
11662: DOUBLE
11663: EQUAL
11664: IFTRUE 11668
11666: GO 11679
11668: POP
// bc_type := b_depot ; 2 :
11669: LD_ADDR_OWVAR 42
11673: PUSH
11674: LD_INT 0
11676: ST_TO_ADDR
11677: GO 12291
11679: LD_INT 2
11681: DOUBLE
11682: EQUAL
11683: IFTRUE 11687
11685: GO 11698
11687: POP
// bc_type := b_warehouse ; 3 :
11688: LD_ADDR_OWVAR 42
11692: PUSH
11693: LD_INT 1
11695: ST_TO_ADDR
11696: GO 12291
11698: LD_INT 3
11700: DOUBLE
11701: EQUAL
11702: IFTRUE 11706
11704: GO 11717
11706: POP
// bc_type := b_lab ; 4 .. 9 :
11707: LD_ADDR_OWVAR 42
11711: PUSH
11712: LD_INT 6
11714: ST_TO_ADDR
11715: GO 12291
11717: LD_INT 4
11719: DOUBLE
11720: GREATEREQUAL
11721: IFFALSE 11729
11723: LD_INT 9
11725: DOUBLE
11726: LESSEQUAL
11727: IFTRUE 11731
11729: GO 11783
11731: POP
// begin bc_type := b_lab_half ;
11732: LD_ADDR_OWVAR 42
11736: PUSH
11737: LD_INT 7
11739: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
11740: LD_ADDR_OWVAR 44
11744: PUSH
11745: LD_INT 10
11747: PUSH
11748: LD_INT 11
11750: PUSH
11751: LD_INT 12
11753: PUSH
11754: LD_INT 15
11756: PUSH
11757: LD_INT 14
11759: PUSH
11760: LD_INT 13
11762: PUSH
11763: EMPTY
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: PUSH
11771: LD_VAR 0 2
11775: PUSH
11776: LD_INT 3
11778: MINUS
11779: ARRAY
11780: ST_TO_ADDR
// end ; 10 .. 13 :
11781: GO 12291
11783: LD_INT 10
11785: DOUBLE
11786: GREATEREQUAL
11787: IFFALSE 11795
11789: LD_INT 13
11791: DOUBLE
11792: LESSEQUAL
11793: IFTRUE 11797
11795: GO 11874
11797: POP
// begin bc_type := b_lab_full ;
11798: LD_ADDR_OWVAR 42
11802: PUSH
11803: LD_INT 8
11805: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
11806: LD_ADDR_OWVAR 44
11810: PUSH
11811: LD_INT 10
11813: PUSH
11814: LD_INT 12
11816: PUSH
11817: LD_INT 14
11819: PUSH
11820: LD_INT 13
11822: PUSH
11823: EMPTY
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: PUSH
11829: LD_VAR 0 2
11833: PUSH
11834: LD_INT 9
11836: MINUS
11837: ARRAY
11838: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
11839: LD_ADDR_OWVAR 45
11843: PUSH
11844: LD_INT 11
11846: PUSH
11847: LD_INT 15
11849: PUSH
11850: LD_INT 12
11852: PUSH
11853: LD_INT 15
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: PUSH
11862: LD_VAR 0 2
11866: PUSH
11867: LD_INT 9
11869: MINUS
11870: ARRAY
11871: ST_TO_ADDR
// end ; 14 :
11872: GO 12291
11874: LD_INT 14
11876: DOUBLE
11877: EQUAL
11878: IFTRUE 11882
11880: GO 11893
11882: POP
// bc_type := b_workshop ; 15 :
11883: LD_ADDR_OWVAR 42
11887: PUSH
11888: LD_INT 2
11890: ST_TO_ADDR
11891: GO 12291
11893: LD_INT 15
11895: DOUBLE
11896: EQUAL
11897: IFTRUE 11901
11899: GO 11912
11901: POP
// bc_type := b_factory ; 16 :
11902: LD_ADDR_OWVAR 42
11906: PUSH
11907: LD_INT 3
11909: ST_TO_ADDR
11910: GO 12291
11912: LD_INT 16
11914: DOUBLE
11915: EQUAL
11916: IFTRUE 11920
11918: GO 11931
11920: POP
// bc_type := b_ext_gun ; 17 :
11921: LD_ADDR_OWVAR 42
11925: PUSH
11926: LD_INT 17
11928: ST_TO_ADDR
11929: GO 12291
11931: LD_INT 17
11933: DOUBLE
11934: EQUAL
11935: IFTRUE 11939
11937: GO 11967
11939: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
11940: LD_ADDR_OWVAR 42
11944: PUSH
11945: LD_INT 19
11947: PUSH
11948: LD_INT 23
11950: PUSH
11951: LD_INT 19
11953: PUSH
11954: EMPTY
11955: LIST
11956: LIST
11957: LIST
11958: PUSH
11959: LD_VAR 0 1
11963: ARRAY
11964: ST_TO_ADDR
11965: GO 12291
11967: LD_INT 18
11969: DOUBLE
11970: EQUAL
11971: IFTRUE 11975
11973: GO 11986
11975: POP
// bc_type := b_ext_radar ; 19 :
11976: LD_ADDR_OWVAR 42
11980: PUSH
11981: LD_INT 20
11983: ST_TO_ADDR
11984: GO 12291
11986: LD_INT 19
11988: DOUBLE
11989: EQUAL
11990: IFTRUE 11994
11992: GO 12005
11994: POP
// bc_type := b_ext_radio ; 20 :
11995: LD_ADDR_OWVAR 42
11999: PUSH
12000: LD_INT 22
12002: ST_TO_ADDR
12003: GO 12291
12005: LD_INT 20
12007: DOUBLE
12008: EQUAL
12009: IFTRUE 12013
12011: GO 12024
12013: POP
// bc_type := b_ext_siberium ; 21 :
12014: LD_ADDR_OWVAR 42
12018: PUSH
12019: LD_INT 21
12021: ST_TO_ADDR
12022: GO 12291
12024: LD_INT 21
12026: DOUBLE
12027: EQUAL
12028: IFTRUE 12032
12030: GO 12043
12032: POP
// bc_type := b_ext_computer ; 22 :
12033: LD_ADDR_OWVAR 42
12037: PUSH
12038: LD_INT 24
12040: ST_TO_ADDR
12041: GO 12291
12043: LD_INT 22
12045: DOUBLE
12046: EQUAL
12047: IFTRUE 12051
12049: GO 12062
12051: POP
// bc_type := b_ext_track ; 23 :
12052: LD_ADDR_OWVAR 42
12056: PUSH
12057: LD_INT 16
12059: ST_TO_ADDR
12060: GO 12291
12062: LD_INT 23
12064: DOUBLE
12065: EQUAL
12066: IFTRUE 12070
12068: GO 12081
12070: POP
// bc_type := b_ext_laser ; 24 :
12071: LD_ADDR_OWVAR 42
12075: PUSH
12076: LD_INT 25
12078: ST_TO_ADDR
12079: GO 12291
12081: LD_INT 24
12083: DOUBLE
12084: EQUAL
12085: IFTRUE 12089
12087: GO 12100
12089: POP
// bc_type := b_control_tower ; 25 :
12090: LD_ADDR_OWVAR 42
12094: PUSH
12095: LD_INT 36
12097: ST_TO_ADDR
12098: GO 12291
12100: LD_INT 25
12102: DOUBLE
12103: EQUAL
12104: IFTRUE 12108
12106: GO 12119
12108: POP
// bc_type := b_breastwork ; 26 :
12109: LD_ADDR_OWVAR 42
12113: PUSH
12114: LD_INT 31
12116: ST_TO_ADDR
12117: GO 12291
12119: LD_INT 26
12121: DOUBLE
12122: EQUAL
12123: IFTRUE 12127
12125: GO 12138
12127: POP
// bc_type := b_bunker ; 27 :
12128: LD_ADDR_OWVAR 42
12132: PUSH
12133: LD_INT 32
12135: ST_TO_ADDR
12136: GO 12291
12138: LD_INT 27
12140: DOUBLE
12141: EQUAL
12142: IFTRUE 12146
12144: GO 12157
12146: POP
// bc_type := b_turret ; 28 :
12147: LD_ADDR_OWVAR 42
12151: PUSH
12152: LD_INT 33
12154: ST_TO_ADDR
12155: GO 12291
12157: LD_INT 28
12159: DOUBLE
12160: EQUAL
12161: IFTRUE 12165
12163: GO 12176
12165: POP
// bc_type := b_armoury ; 29 :
12166: LD_ADDR_OWVAR 42
12170: PUSH
12171: LD_INT 4
12173: ST_TO_ADDR
12174: GO 12291
12176: LD_INT 29
12178: DOUBLE
12179: EQUAL
12180: IFTRUE 12184
12182: GO 12195
12184: POP
// bc_type := b_barracks ; 30 :
12185: LD_ADDR_OWVAR 42
12189: PUSH
12190: LD_INT 5
12192: ST_TO_ADDR
12193: GO 12291
12195: LD_INT 30
12197: DOUBLE
12198: EQUAL
12199: IFTRUE 12203
12201: GO 12214
12203: POP
// bc_type := b_solar_power ; 31 :
12204: LD_ADDR_OWVAR 42
12208: PUSH
12209: LD_INT 27
12211: ST_TO_ADDR
12212: GO 12291
12214: LD_INT 31
12216: DOUBLE
12217: EQUAL
12218: IFTRUE 12222
12220: GO 12233
12222: POP
// bc_type := b_oil_power ; 32 :
12223: LD_ADDR_OWVAR 42
12227: PUSH
12228: LD_INT 26
12230: ST_TO_ADDR
12231: GO 12291
12233: LD_INT 32
12235: DOUBLE
12236: EQUAL
12237: IFTRUE 12241
12239: GO 12252
12241: POP
// bc_type := b_siberite_power ; 33 :
12242: LD_ADDR_OWVAR 42
12246: PUSH
12247: LD_INT 28
12249: ST_TO_ADDR
12250: GO 12291
12252: LD_INT 33
12254: DOUBLE
12255: EQUAL
12256: IFTRUE 12260
12258: GO 12271
12260: POP
// bc_type := b_oil_mine ; 34 :
12261: LD_ADDR_OWVAR 42
12265: PUSH
12266: LD_INT 29
12268: ST_TO_ADDR
12269: GO 12291
12271: LD_INT 34
12273: DOUBLE
12274: EQUAL
12275: IFTRUE 12279
12277: GO 12290
12279: POP
// bc_type := b_siberite_mine ; end ;
12280: LD_ADDR_OWVAR 42
12284: PUSH
12285: LD_INT 30
12287: ST_TO_ADDR
12288: GO 12291
12290: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
12291: LD_ADDR_VAR 0 8
12295: PUSH
12296: LD_VAR 0 5
12300: PPUSH
12301: LD_VAR 0 6
12305: PPUSH
12306: LD_VAR 0 3
12310: PPUSH
12311: CALL_OW 47
12315: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
12316: LD_OWVAR 42
12320: PUSH
12321: LD_INT 32
12323: PUSH
12324: LD_INT 33
12326: PUSH
12327: EMPTY
12328: LIST
12329: LIST
12330: IN
12331: IFFALSE 12347
// PlaceWeaponTurret ( b , weapon ) ;
12333: LD_VAR 0 8
12337: PPUSH
12338: LD_VAR 0 4
12342: PPUSH
12343: CALL_OW 431
// end ;
12347: LD_VAR 0 7
12351: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
12352: LD_INT 0
12354: PPUSH
12355: PPUSH
12356: PPUSH
12357: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12358: LD_ADDR_VAR 0 4
12362: PUSH
12363: LD_INT 22
12365: PUSH
12366: LD_OWVAR 2
12370: PUSH
12371: EMPTY
12372: LIST
12373: LIST
12374: PUSH
12375: LD_INT 2
12377: PUSH
12378: LD_INT 30
12380: PUSH
12381: LD_INT 0
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: PUSH
12388: LD_INT 30
12390: PUSH
12391: LD_INT 1
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: LIST
12402: PUSH
12403: EMPTY
12404: LIST
12405: LIST
12406: PPUSH
12407: CALL_OW 69
12411: ST_TO_ADDR
// if not tmp then
12412: LD_VAR 0 4
12416: NOT
12417: IFFALSE 12421
// exit ;
12419: GO 12480
// for i in tmp do
12421: LD_ADDR_VAR 0 2
12425: PUSH
12426: LD_VAR 0 4
12430: PUSH
12431: FOR_IN
12432: IFFALSE 12478
// for j = 1 to 3 do
12434: LD_ADDR_VAR 0 3
12438: PUSH
12439: DOUBLE
12440: LD_INT 1
12442: DEC
12443: ST_TO_ADDR
12444: LD_INT 3
12446: PUSH
12447: FOR_TO
12448: IFFALSE 12474
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
12450: LD_VAR 0 2
12454: PPUSH
12455: CALL_OW 274
12459: PPUSH
12460: LD_VAR 0 3
12464: PPUSH
12465: LD_INT 99999
12467: PPUSH
12468: CALL_OW 277
12472: GO 12447
12474: POP
12475: POP
12476: GO 12431
12478: POP
12479: POP
// end ;
12480: LD_VAR 0 1
12484: RET
// export function hHackSetLevel10 ; var i , j ; begin
12485: LD_INT 0
12487: PPUSH
12488: PPUSH
12489: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
12490: LD_ADDR_VAR 0 2
12494: PUSH
12495: LD_INT 21
12497: PUSH
12498: LD_INT 1
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: PPUSH
12505: CALL_OW 69
12509: PUSH
12510: FOR_IN
12511: IFFALSE 12563
// if IsSelected ( i ) then
12513: LD_VAR 0 2
12517: PPUSH
12518: CALL_OW 306
12522: IFFALSE 12561
// begin for j := 1 to 4 do
12524: LD_ADDR_VAR 0 3
12528: PUSH
12529: DOUBLE
12530: LD_INT 1
12532: DEC
12533: ST_TO_ADDR
12534: LD_INT 4
12536: PUSH
12537: FOR_TO
12538: IFFALSE 12559
// SetSkill ( i , j , 10 ) ;
12540: LD_VAR 0 2
12544: PPUSH
12545: LD_VAR 0 3
12549: PPUSH
12550: LD_INT 10
12552: PPUSH
12553: CALL_OW 237
12557: GO 12537
12559: POP
12560: POP
// end ;
12561: GO 12510
12563: POP
12564: POP
// end ;
12565: LD_VAR 0 1
12569: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
12570: LD_INT 0
12572: PPUSH
12573: PPUSH
12574: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
12575: LD_ADDR_VAR 0 2
12579: PUSH
12580: LD_INT 22
12582: PUSH
12583: LD_OWVAR 2
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 21
12594: PUSH
12595: LD_INT 1
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: PPUSH
12606: CALL_OW 69
12610: PUSH
12611: FOR_IN
12612: IFFALSE 12653
// begin for j := 1 to 4 do
12614: LD_ADDR_VAR 0 3
12618: PUSH
12619: DOUBLE
12620: LD_INT 1
12622: DEC
12623: ST_TO_ADDR
12624: LD_INT 4
12626: PUSH
12627: FOR_TO
12628: IFFALSE 12649
// SetSkill ( i , j , 10 ) ;
12630: LD_VAR 0 2
12634: PPUSH
12635: LD_VAR 0 3
12639: PPUSH
12640: LD_INT 10
12642: PPUSH
12643: CALL_OW 237
12647: GO 12627
12649: POP
12650: POP
// end ;
12651: GO 12611
12653: POP
12654: POP
// end ;
12655: LD_VAR 0 1
12659: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
12660: LD_INT 0
12662: PPUSH
// uc_side := your_side ;
12663: LD_ADDR_OWVAR 20
12667: PUSH
12668: LD_OWVAR 2
12672: ST_TO_ADDR
// uc_nation := nation ;
12673: LD_ADDR_OWVAR 21
12677: PUSH
12678: LD_VAR 0 1
12682: ST_TO_ADDR
// InitHc ;
12683: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
12687: LD_INT 0
12689: PPUSH
12690: LD_VAR 0 2
12694: PPUSH
12695: LD_VAR 0 3
12699: PPUSH
12700: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
12704: LD_VAR 0 4
12708: PPUSH
12709: LD_VAR 0 5
12713: PPUSH
12714: CALL_OW 428
12718: PUSH
12719: LD_INT 0
12721: EQUAL
12722: IFFALSE 12746
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
12724: CALL_OW 44
12728: PPUSH
12729: LD_VAR 0 4
12733: PPUSH
12734: LD_VAR 0 5
12738: PPUSH
12739: LD_INT 1
12741: PPUSH
12742: CALL_OW 48
// end ;
12746: LD_VAR 0 6
12750: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
12751: LD_INT 0
12753: PPUSH
12754: PPUSH
// uc_side := your_side ;
12755: LD_ADDR_OWVAR 20
12759: PUSH
12760: LD_OWVAR 2
12764: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
12765: LD_VAR 0 1
12769: PUSH
12770: LD_INT 1
12772: PUSH
12773: LD_INT 2
12775: PUSH
12776: LD_INT 3
12778: PUSH
12779: LD_INT 4
12781: PUSH
12782: LD_INT 5
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: LIST
12789: LIST
12790: LIST
12791: IN
12792: IFFALSE 12804
// uc_nation := nation_american else
12794: LD_ADDR_OWVAR 21
12798: PUSH
12799: LD_INT 1
12801: ST_TO_ADDR
12802: GO 12847
// if chassis in [ 11 , 12 , 13 , 14 ] then
12804: LD_VAR 0 1
12808: PUSH
12809: LD_INT 11
12811: PUSH
12812: LD_INT 12
12814: PUSH
12815: LD_INT 13
12817: PUSH
12818: LD_INT 14
12820: PUSH
12821: EMPTY
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: IN
12827: IFFALSE 12839
// uc_nation := nation_arabian else
12829: LD_ADDR_OWVAR 21
12833: PUSH
12834: LD_INT 2
12836: ST_TO_ADDR
12837: GO 12847
// uc_nation := nation_russian ;
12839: LD_ADDR_OWVAR 21
12843: PUSH
12844: LD_INT 3
12846: ST_TO_ADDR
// vc_chassis := chassis ;
12847: LD_ADDR_OWVAR 37
12851: PUSH
12852: LD_VAR 0 1
12856: ST_TO_ADDR
// vc_engine := engine ;
12857: LD_ADDR_OWVAR 39
12861: PUSH
12862: LD_VAR 0 2
12866: ST_TO_ADDR
// vc_control := control ;
12867: LD_ADDR_OWVAR 38
12871: PUSH
12872: LD_VAR 0 3
12876: ST_TO_ADDR
// vc_weapon := weapon ;
12877: LD_ADDR_OWVAR 40
12881: PUSH
12882: LD_VAR 0 4
12886: ST_TO_ADDR
// un := CreateVehicle ;
12887: LD_ADDR_VAR 0 8
12891: PUSH
12892: CALL_OW 45
12896: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
12897: LD_VAR 0 8
12901: PPUSH
12902: LD_INT 0
12904: PPUSH
12905: LD_INT 5
12907: PPUSH
12908: CALL_OW 12
12912: PPUSH
12913: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
12917: LD_VAR 0 8
12921: PPUSH
12922: LD_VAR 0 5
12926: PPUSH
12927: LD_VAR 0 6
12931: PPUSH
12932: LD_INT 1
12934: PPUSH
12935: CALL_OW 48
// end ;
12939: LD_VAR 0 7
12943: RET
// export hInvincible ; every 1 do
12944: GO 12946
12946: DISABLE
// hInvincible := [ ] ;
12947: LD_ADDR_EXP 71
12951: PUSH
12952: EMPTY
12953: ST_TO_ADDR
12954: END
// every 10 do var i ;
12955: GO 12957
12957: DISABLE
12958: LD_INT 0
12960: PPUSH
// begin enable ;
12961: ENABLE
// if not hInvincible then
12962: LD_EXP 71
12966: NOT
12967: IFFALSE 12971
// exit ;
12969: GO 13015
// for i in hInvincible do
12971: LD_ADDR_VAR 0 1
12975: PUSH
12976: LD_EXP 71
12980: PUSH
12981: FOR_IN
12982: IFFALSE 13013
// if GetLives ( i ) < 1000 then
12984: LD_VAR 0 1
12988: PPUSH
12989: CALL_OW 256
12993: PUSH
12994: LD_INT 1000
12996: LESS
12997: IFFALSE 13011
// SetLives ( i , 1000 ) ;
12999: LD_VAR 0 1
13003: PPUSH
13004: LD_INT 1000
13006: PPUSH
13007: CALL_OW 234
13011: GO 12981
13013: POP
13014: POP
// end ;
13015: PPOPN 1
13017: END
// export function hHackInvincible ; var i ; begin
13018: LD_INT 0
13020: PPUSH
13021: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
13022: LD_ADDR_VAR 0 2
13026: PUSH
13027: LD_INT 2
13029: PUSH
13030: LD_INT 21
13032: PUSH
13033: LD_INT 1
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 21
13042: PUSH
13043: LD_INT 2
13045: PUSH
13046: EMPTY
13047: LIST
13048: LIST
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: LIST
13054: PPUSH
13055: CALL_OW 69
13059: PUSH
13060: FOR_IN
13061: IFFALSE 13122
// if IsSelected ( i ) then
13063: LD_VAR 0 2
13067: PPUSH
13068: CALL_OW 306
13072: IFFALSE 13120
// begin if i in hInvincible then
13074: LD_VAR 0 2
13078: PUSH
13079: LD_EXP 71
13083: IN
13084: IFFALSE 13104
// hInvincible := hInvincible diff i else
13086: LD_ADDR_EXP 71
13090: PUSH
13091: LD_EXP 71
13095: PUSH
13096: LD_VAR 0 2
13100: DIFF
13101: ST_TO_ADDR
13102: GO 13120
// hInvincible := hInvincible union i ;
13104: LD_ADDR_EXP 71
13108: PUSH
13109: LD_EXP 71
13113: PUSH
13114: LD_VAR 0 2
13118: UNION
13119: ST_TO_ADDR
// end ;
13120: GO 13060
13122: POP
13123: POP
// end ;
13124: LD_VAR 0 1
13128: RET
// export function hHackInvisible ; var i , j ; begin
13129: LD_INT 0
13131: PPUSH
13132: PPUSH
13133: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
13134: LD_ADDR_VAR 0 2
13138: PUSH
13139: LD_INT 21
13141: PUSH
13142: LD_INT 1
13144: PUSH
13145: EMPTY
13146: LIST
13147: LIST
13148: PPUSH
13149: CALL_OW 69
13153: PUSH
13154: FOR_IN
13155: IFFALSE 13179
// if IsSelected ( i ) then
13157: LD_VAR 0 2
13161: PPUSH
13162: CALL_OW 306
13166: IFFALSE 13177
// ComForceInvisible ( i ) ;
13168: LD_VAR 0 2
13172: PPUSH
13173: CALL_OW 496
13177: GO 13154
13179: POP
13180: POP
// end ;
13181: LD_VAR 0 1
13185: RET
// export function hHackChangeYourSide ; begin
13186: LD_INT 0
13188: PPUSH
// if your_side = 8 then
13189: LD_OWVAR 2
13193: PUSH
13194: LD_INT 8
13196: EQUAL
13197: IFFALSE 13209
// your_side := 0 else
13199: LD_ADDR_OWVAR 2
13203: PUSH
13204: LD_INT 0
13206: ST_TO_ADDR
13207: GO 13223
// your_side := your_side + 1 ;
13209: LD_ADDR_OWVAR 2
13213: PUSH
13214: LD_OWVAR 2
13218: PUSH
13219: LD_INT 1
13221: PLUS
13222: ST_TO_ADDR
// end ;
13223: LD_VAR 0 1
13227: RET
// export function hHackChangeUnitSide ; var i , j ; begin
13228: LD_INT 0
13230: PPUSH
13231: PPUSH
13232: PPUSH
// for i in all_units do
13233: LD_ADDR_VAR 0 2
13237: PUSH
13238: LD_OWVAR 3
13242: PUSH
13243: FOR_IN
13244: IFFALSE 13322
// if IsSelected ( i ) then
13246: LD_VAR 0 2
13250: PPUSH
13251: CALL_OW 306
13255: IFFALSE 13320
// begin j := GetSide ( i ) ;
13257: LD_ADDR_VAR 0 3
13261: PUSH
13262: LD_VAR 0 2
13266: PPUSH
13267: CALL_OW 255
13271: ST_TO_ADDR
// if j = 8 then
13272: LD_VAR 0 3
13276: PUSH
13277: LD_INT 8
13279: EQUAL
13280: IFFALSE 13292
// j := 0 else
13282: LD_ADDR_VAR 0 3
13286: PUSH
13287: LD_INT 0
13289: ST_TO_ADDR
13290: GO 13306
// j := j + 1 ;
13292: LD_ADDR_VAR 0 3
13296: PUSH
13297: LD_VAR 0 3
13301: PUSH
13302: LD_INT 1
13304: PLUS
13305: ST_TO_ADDR
// SetSide ( i , j ) ;
13306: LD_VAR 0 2
13310: PPUSH
13311: LD_VAR 0 3
13315: PPUSH
13316: CALL_OW 235
// end ;
13320: GO 13243
13322: POP
13323: POP
// end ;
13324: LD_VAR 0 1
13328: RET
// export function hHackFog ; begin
13329: LD_INT 0
13331: PPUSH
// FogOff ( true ) ;
13332: LD_INT 1
13334: PPUSH
13335: CALL_OW 344
// end ;
13339: LD_VAR 0 1
13343: RET
// export function hHackTeleport ( unit , x , y ) ; begin
13344: LD_INT 0
13346: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
13347: LD_VAR 0 1
13351: PPUSH
13352: LD_VAR 0 2
13356: PPUSH
13357: LD_VAR 0 3
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: LD_INT 1
13367: PPUSH
13368: CALL_OW 483
// CenterOnXY ( x , y ) ;
13372: LD_VAR 0 2
13376: PPUSH
13377: LD_VAR 0 3
13381: PPUSH
13382: CALL_OW 84
// end ; end_of_file
13386: LD_VAR 0 4
13390: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
13391: LD_VAR 0 1
13395: PUSH
13396: LD_INT 200
13398: DOUBLE
13399: GREATEREQUAL
13400: IFFALSE 13408
13402: LD_INT 299
13404: DOUBLE
13405: LESSEQUAL
13406: IFTRUE 13410
13408: GO 13442
13410: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
13411: LD_VAR 0 1
13415: PPUSH
13416: LD_VAR 0 2
13420: PPUSH
13421: LD_VAR 0 3
13425: PPUSH
13426: LD_VAR 0 4
13430: PPUSH
13431: LD_VAR 0 5
13435: PPUSH
13436: CALL 13636 0 5
13440: GO 13519
13442: LD_INT 300
13444: DOUBLE
13445: GREATEREQUAL
13446: IFFALSE 13454
13448: LD_INT 399
13450: DOUBLE
13451: LESSEQUAL
13452: IFTRUE 13456
13454: GO 13518
13456: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
13457: LD_VAR 0 1
13461: PPUSH
13462: LD_VAR 0 2
13466: PPUSH
13467: LD_VAR 0 3
13471: PPUSH
13472: LD_VAR 0 4
13476: PPUSH
13477: LD_VAR 0 5
13481: PPUSH
13482: LD_VAR 0 6
13486: PPUSH
13487: LD_VAR 0 7
13491: PPUSH
13492: LD_VAR 0 8
13496: PPUSH
13497: LD_VAR 0 9
13501: PPUSH
13502: LD_VAR 0 10
13506: PPUSH
13507: LD_VAR 0 11
13511: PPUSH
13512: CALL 11411 0 11
13516: GO 13519
13518: POP
// end ; end_of_file
13519: PPOPN 11
13521: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
13522: LD_INT 0
13524: PPUSH
13525: PPUSH
13526: PPUSH
13527: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
13528: LD_VAR 0 1
13532: PPUSH
13533: CALL_OW 264
13537: PUSH
13538: LD_EXP 5
13542: EQUAL
13543: IFFALSE 13615
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
13545: LD_INT 68
13547: PPUSH
13548: LD_VAR 0 1
13552: PPUSH
13553: CALL_OW 255
13557: PPUSH
13558: CALL_OW 321
13562: PUSH
13563: LD_INT 2
13565: EQUAL
13566: IFFALSE 13578
// eff := 70 else
13568: LD_ADDR_VAR 0 4
13572: PUSH
13573: LD_INT 70
13575: ST_TO_ADDR
13576: GO 13586
// eff := 30 ;
13578: LD_ADDR_VAR 0 4
13582: PUSH
13583: LD_INT 30
13585: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
13586: LD_VAR 0 1
13590: PPUSH
13591: CALL_OW 250
13595: PPUSH
13596: LD_VAR 0 1
13600: PPUSH
13601: CALL_OW 251
13605: PPUSH
13606: LD_VAR 0 4
13610: PPUSH
13611: CALL_OW 495
// end ; end ;
13615: LD_VAR 0 2
13619: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
13620: LD_INT 0
13622: PPUSH
// end ;
13623: LD_VAR 0 4
13627: RET
// export function SOS_Command ( cmd ) ; begin
13628: LD_INT 0
13630: PPUSH
// end ;
13631: LD_VAR 0 2
13635: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
13636: LD_INT 0
13638: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
13639: LD_VAR 0 1
13643: PUSH
13644: LD_INT 250
13646: EQUAL
13647: PUSH
13648: LD_VAR 0 2
13652: PPUSH
13653: CALL_OW 264
13657: PUSH
13658: LD_EXP 8
13662: EQUAL
13663: AND
13664: IFFALSE 13685
// MinerPlaceMine ( unit , x , y ) ;
13666: LD_VAR 0 2
13670: PPUSH
13671: LD_VAR 0 4
13675: PPUSH
13676: LD_VAR 0 5
13680: PPUSH
13681: CALL 16026 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
13685: LD_VAR 0 1
13689: PUSH
13690: LD_INT 251
13692: EQUAL
13693: PUSH
13694: LD_VAR 0 2
13698: PPUSH
13699: CALL_OW 264
13703: PUSH
13704: LD_EXP 8
13708: EQUAL
13709: AND
13710: IFFALSE 13731
// MinerDetonateMine ( unit , x , y ) ;
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_VAR 0 4
13721: PPUSH
13722: LD_VAR 0 5
13726: PPUSH
13727: CALL 16303 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
13731: LD_VAR 0 1
13735: PUSH
13736: LD_INT 252
13738: EQUAL
13739: PUSH
13740: LD_VAR 0 2
13744: PPUSH
13745: CALL_OW 264
13749: PUSH
13750: LD_EXP 8
13754: EQUAL
13755: AND
13756: IFFALSE 13777
// MinerCreateMinefield ( unit , x , y ) ;
13758: LD_VAR 0 2
13762: PPUSH
13763: LD_VAR 0 4
13767: PPUSH
13768: LD_VAR 0 5
13772: PPUSH
13773: CALL 16720 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
13777: LD_VAR 0 1
13781: PUSH
13782: LD_INT 253
13784: EQUAL
13785: PUSH
13786: LD_VAR 0 2
13790: PPUSH
13791: CALL_OW 257
13795: PUSH
13796: LD_INT 5
13798: EQUAL
13799: AND
13800: IFFALSE 13821
// ComBinocular ( unit , x , y ) ;
13802: LD_VAR 0 2
13806: PPUSH
13807: LD_VAR 0 4
13811: PPUSH
13812: LD_VAR 0 5
13816: PPUSH
13817: CALL 17091 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
13821: LD_VAR 0 1
13825: PUSH
13826: LD_INT 254
13828: EQUAL
13829: PUSH
13830: LD_VAR 0 2
13834: PPUSH
13835: CALL_OW 264
13839: PUSH
13840: LD_EXP 3
13844: EQUAL
13845: AND
13846: PUSH
13847: LD_VAR 0 3
13851: PPUSH
13852: CALL_OW 263
13856: PUSH
13857: LD_INT 3
13859: EQUAL
13860: AND
13861: IFFALSE 13877
// HackDestroyVehicle ( unit , selectedUnit ) ;
13863: LD_VAR 0 2
13867: PPUSH
13868: LD_VAR 0 3
13872: PPUSH
13873: CALL 15386 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
13877: LD_VAR 0 1
13881: PUSH
13882: LD_INT 255
13884: EQUAL
13885: PUSH
13886: LD_VAR 0 2
13890: PPUSH
13891: CALL_OW 264
13895: PUSH
13896: LD_INT 14
13898: PUSH
13899: LD_INT 53
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: IN
13906: AND
13907: PUSH
13908: LD_VAR 0 4
13912: PPUSH
13913: LD_VAR 0 5
13917: PPUSH
13918: CALL_OW 488
13922: AND
13923: IFFALSE 13947
// CutTreeXYR ( unit , x , y , 12 ) ;
13925: LD_VAR 0 2
13929: PPUSH
13930: LD_VAR 0 4
13934: PPUSH
13935: LD_VAR 0 5
13939: PPUSH
13940: LD_INT 12
13942: PPUSH
13943: CALL 13952 0 4
// end ;
13947: LD_VAR 0 6
13951: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
13952: LD_INT 0
13954: PPUSH
13955: PPUSH
13956: PPUSH
13957: PPUSH
13958: PPUSH
13959: PPUSH
13960: PPUSH
13961: PPUSH
13962: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
13963: LD_VAR 0 1
13967: NOT
13968: PUSH
13969: LD_VAR 0 2
13973: PPUSH
13974: LD_VAR 0 3
13978: PPUSH
13979: CALL_OW 488
13983: NOT
13984: OR
13985: PUSH
13986: LD_VAR 0 4
13990: NOT
13991: OR
13992: IFFALSE 13996
// exit ;
13994: GO 14336
// list := [ ] ;
13996: LD_ADDR_VAR 0 13
14000: PUSH
14001: EMPTY
14002: ST_TO_ADDR
// if x - r < 0 then
14003: LD_VAR 0 2
14007: PUSH
14008: LD_VAR 0 4
14012: MINUS
14013: PUSH
14014: LD_INT 0
14016: LESS
14017: IFFALSE 14029
// min_x := 0 else
14019: LD_ADDR_VAR 0 7
14023: PUSH
14024: LD_INT 0
14026: ST_TO_ADDR
14027: GO 14045
// min_x := x - r ;
14029: LD_ADDR_VAR 0 7
14033: PUSH
14034: LD_VAR 0 2
14038: PUSH
14039: LD_VAR 0 4
14043: MINUS
14044: ST_TO_ADDR
// if y - r < 0 then
14045: LD_VAR 0 3
14049: PUSH
14050: LD_VAR 0 4
14054: MINUS
14055: PUSH
14056: LD_INT 0
14058: LESS
14059: IFFALSE 14071
// min_y := 0 else
14061: LD_ADDR_VAR 0 8
14065: PUSH
14066: LD_INT 0
14068: ST_TO_ADDR
14069: GO 14087
// min_y := y - r ;
14071: LD_ADDR_VAR 0 8
14075: PUSH
14076: LD_VAR 0 3
14080: PUSH
14081: LD_VAR 0 4
14085: MINUS
14086: ST_TO_ADDR
// max_x := x + r ;
14087: LD_ADDR_VAR 0 9
14091: PUSH
14092: LD_VAR 0 2
14096: PUSH
14097: LD_VAR 0 4
14101: PLUS
14102: ST_TO_ADDR
// max_y := y + r ;
14103: LD_ADDR_VAR 0 10
14107: PUSH
14108: LD_VAR 0 3
14112: PUSH
14113: LD_VAR 0 4
14117: PLUS
14118: ST_TO_ADDR
// for _x = min_x to max_x do
14119: LD_ADDR_VAR 0 11
14123: PUSH
14124: DOUBLE
14125: LD_VAR 0 7
14129: DEC
14130: ST_TO_ADDR
14131: LD_VAR 0 9
14135: PUSH
14136: FOR_TO
14137: IFFALSE 14254
// for _y = min_y to max_y do
14139: LD_ADDR_VAR 0 12
14143: PUSH
14144: DOUBLE
14145: LD_VAR 0 8
14149: DEC
14150: ST_TO_ADDR
14151: LD_VAR 0 10
14155: PUSH
14156: FOR_TO
14157: IFFALSE 14250
// begin if not ValidHex ( _x , _y ) then
14159: LD_VAR 0 11
14163: PPUSH
14164: LD_VAR 0 12
14168: PPUSH
14169: CALL_OW 488
14173: NOT
14174: IFFALSE 14178
// continue ;
14176: GO 14156
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
14178: LD_VAR 0 11
14182: PPUSH
14183: LD_VAR 0 12
14187: PPUSH
14188: CALL_OW 351
14192: PUSH
14193: LD_VAR 0 11
14197: PPUSH
14198: LD_VAR 0 12
14202: PPUSH
14203: CALL_OW 554
14207: AND
14208: IFFALSE 14248
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
14210: LD_ADDR_VAR 0 13
14214: PUSH
14215: LD_VAR 0 13
14219: PPUSH
14220: LD_VAR 0 13
14224: PUSH
14225: LD_INT 1
14227: PLUS
14228: PPUSH
14229: LD_VAR 0 11
14233: PUSH
14234: LD_VAR 0 12
14238: PUSH
14239: EMPTY
14240: LIST
14241: LIST
14242: PPUSH
14243: CALL_OW 2
14247: ST_TO_ADDR
// end ;
14248: GO 14156
14250: POP
14251: POP
14252: GO 14136
14254: POP
14255: POP
// if not list then
14256: LD_VAR 0 13
14260: NOT
14261: IFFALSE 14265
// exit ;
14263: GO 14336
// for i in list do
14265: LD_ADDR_VAR 0 6
14269: PUSH
14270: LD_VAR 0 13
14274: PUSH
14275: FOR_IN
14276: IFFALSE 14334
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
14278: LD_VAR 0 1
14282: PPUSH
14283: LD_STRING M
14285: PUSH
14286: LD_VAR 0 6
14290: PUSH
14291: LD_INT 1
14293: ARRAY
14294: PUSH
14295: LD_VAR 0 6
14299: PUSH
14300: LD_INT 2
14302: ARRAY
14303: PUSH
14304: LD_INT 0
14306: PUSH
14307: LD_INT 0
14309: PUSH
14310: LD_INT 0
14312: PUSH
14313: LD_INT 0
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: PUSH
14325: EMPTY
14326: LIST
14327: PPUSH
14328: CALL_OW 447
14332: GO 14275
14334: POP
14335: POP
// end ;
14336: LD_VAR 0 5
14340: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
14341: LD_EXP 72
14345: NOT
14346: IFFALSE 14396
14348: GO 14350
14350: DISABLE
// begin initHack := true ;
14351: LD_ADDR_EXP 72
14355: PUSH
14356: LD_INT 1
14358: ST_TO_ADDR
// hackTanks := [ ] ;
14359: LD_ADDR_EXP 73
14363: PUSH
14364: EMPTY
14365: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
14366: LD_ADDR_EXP 74
14370: PUSH
14371: EMPTY
14372: ST_TO_ADDR
// hackLimit := 3 ;
14373: LD_ADDR_EXP 75
14377: PUSH
14378: LD_INT 3
14380: ST_TO_ADDR
// hackDist := 12 ;
14381: LD_ADDR_EXP 76
14385: PUSH
14386: LD_INT 12
14388: ST_TO_ADDR
// hackCounter := [ ] ;
14389: LD_ADDR_EXP 77
14393: PUSH
14394: EMPTY
14395: ST_TO_ADDR
// end ;
14396: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
14397: LD_EXP 72
14401: PUSH
14402: LD_INT 34
14404: PUSH
14405: LD_EXP 3
14409: PUSH
14410: EMPTY
14411: LIST
14412: LIST
14413: PPUSH
14414: CALL_OW 69
14418: AND
14419: IFFALSE 14674
14421: GO 14423
14423: DISABLE
14424: LD_INT 0
14426: PPUSH
14427: PPUSH
// begin enable ;
14428: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
14429: LD_ADDR_VAR 0 1
14433: PUSH
14434: LD_INT 34
14436: PUSH
14437: LD_EXP 3
14441: PUSH
14442: EMPTY
14443: LIST
14444: LIST
14445: PPUSH
14446: CALL_OW 69
14450: PUSH
14451: FOR_IN
14452: IFFALSE 14672
// begin if not i in hackTanks then
14454: LD_VAR 0 1
14458: PUSH
14459: LD_EXP 73
14463: IN
14464: NOT
14465: IFFALSE 14548
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
14467: LD_ADDR_EXP 73
14471: PUSH
14472: LD_EXP 73
14476: PPUSH
14477: LD_EXP 73
14481: PUSH
14482: LD_INT 1
14484: PLUS
14485: PPUSH
14486: LD_VAR 0 1
14490: PPUSH
14491: CALL_OW 1
14495: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
14496: LD_ADDR_EXP 74
14500: PUSH
14501: LD_EXP 74
14505: PPUSH
14506: LD_EXP 74
14510: PUSH
14511: LD_INT 1
14513: PLUS
14514: PPUSH
14515: EMPTY
14516: PPUSH
14517: CALL_OW 1
14521: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
14522: LD_ADDR_EXP 77
14526: PUSH
14527: LD_EXP 77
14531: PPUSH
14532: LD_EXP 77
14536: PUSH
14537: LD_INT 1
14539: PLUS
14540: PPUSH
14541: EMPTY
14542: PPUSH
14543: CALL_OW 1
14547: ST_TO_ADDR
// end ; if not IsOk ( i ) then
14548: LD_VAR 0 1
14552: PPUSH
14553: CALL_OW 302
14557: NOT
14558: IFFALSE 14571
// begin HackUnlinkAll ( i ) ;
14560: LD_VAR 0 1
14564: PPUSH
14565: CALL 14677 0 1
// continue ;
14569: GO 14451
// end ; HackCheckCapturedStatus ( i ) ;
14571: LD_VAR 0 1
14575: PPUSH
14576: CALL 15120 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
14580: LD_ADDR_VAR 0 2
14584: PUSH
14585: LD_INT 81
14587: PUSH
14588: LD_VAR 0 1
14592: PPUSH
14593: CALL_OW 255
14597: PUSH
14598: EMPTY
14599: LIST
14600: LIST
14601: PUSH
14602: LD_INT 33
14604: PUSH
14605: LD_INT 3
14607: PUSH
14608: EMPTY
14609: LIST
14610: LIST
14611: PUSH
14612: LD_INT 91
14614: PUSH
14615: LD_VAR 0 1
14619: PUSH
14620: LD_EXP 76
14624: PUSH
14625: EMPTY
14626: LIST
14627: LIST
14628: LIST
14629: PUSH
14630: LD_INT 50
14632: PUSH
14633: EMPTY
14634: LIST
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: LIST
14640: LIST
14641: PPUSH
14642: CALL_OW 69
14646: ST_TO_ADDR
// if not tmp then
14647: LD_VAR 0 2
14651: NOT
14652: IFFALSE 14656
// continue ;
14654: GO 14451
// HackLink ( i , tmp ) ;
14656: LD_VAR 0 1
14660: PPUSH
14661: LD_VAR 0 2
14665: PPUSH
14666: CALL 14813 0 2
// end ;
14670: GO 14451
14672: POP
14673: POP
// end ;
14674: PPOPN 2
14676: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
14677: LD_INT 0
14679: PPUSH
14680: PPUSH
14681: PPUSH
// if not hack in hackTanks then
14682: LD_VAR 0 1
14686: PUSH
14687: LD_EXP 73
14691: IN
14692: NOT
14693: IFFALSE 14697
// exit ;
14695: GO 14808
// index := GetElementIndex ( hackTanks , hack ) ;
14697: LD_ADDR_VAR 0 4
14701: PUSH
14702: LD_EXP 73
14706: PPUSH
14707: LD_VAR 0 1
14711: PPUSH
14712: CALL 22242 0 2
14716: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
14717: LD_EXP 74
14721: PUSH
14722: LD_VAR 0 4
14726: ARRAY
14727: IFFALSE 14808
// begin for i in hackTanksCaptured [ index ] do
14729: LD_ADDR_VAR 0 3
14733: PUSH
14734: LD_EXP 74
14738: PUSH
14739: LD_VAR 0 4
14743: ARRAY
14744: PUSH
14745: FOR_IN
14746: IFFALSE 14772
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
14748: LD_VAR 0 3
14752: PUSH
14753: LD_INT 1
14755: ARRAY
14756: PPUSH
14757: LD_VAR 0 3
14761: PUSH
14762: LD_INT 2
14764: ARRAY
14765: PPUSH
14766: CALL_OW 235
14770: GO 14745
14772: POP
14773: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
14774: LD_ADDR_EXP 74
14778: PUSH
14779: LD_EXP 74
14783: PPUSH
14784: LD_VAR 0 4
14788: PPUSH
14789: EMPTY
14790: PPUSH
14791: CALL_OW 1
14795: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
14796: LD_VAR 0 1
14800: PPUSH
14801: LD_INT 0
14803: PPUSH
14804: CALL_OW 505
// end ; end ;
14808: LD_VAR 0 2
14812: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
14813: LD_INT 0
14815: PPUSH
14816: PPUSH
14817: PPUSH
// if not hack in hackTanks or not vehicles then
14818: LD_VAR 0 1
14822: PUSH
14823: LD_EXP 73
14827: IN
14828: NOT
14829: PUSH
14830: LD_VAR 0 2
14834: NOT
14835: OR
14836: IFFALSE 14840
// exit ;
14838: GO 15115
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
14840: LD_ADDR_VAR 0 2
14844: PUSH
14845: LD_VAR 0 1
14849: PPUSH
14850: LD_VAR 0 2
14854: PPUSH
14855: LD_INT 1
14857: PPUSH
14858: LD_INT 1
14860: PPUSH
14861: CALL 22892 0 4
14865: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
14866: LD_ADDR_VAR 0 5
14870: PUSH
14871: LD_EXP 73
14875: PPUSH
14876: LD_VAR 0 1
14880: PPUSH
14881: CALL 22242 0 2
14885: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
14886: LD_EXP 74
14890: PUSH
14891: LD_VAR 0 5
14895: ARRAY
14896: PUSH
14897: LD_EXP 75
14901: LESS
14902: IFFALSE 15091
// begin for i := 1 to vehicles do
14904: LD_ADDR_VAR 0 4
14908: PUSH
14909: DOUBLE
14910: LD_INT 1
14912: DEC
14913: ST_TO_ADDR
14914: LD_VAR 0 2
14918: PUSH
14919: FOR_TO
14920: IFFALSE 15089
// begin if hackTanksCaptured [ index ] = hackLimit then
14922: LD_EXP 74
14926: PUSH
14927: LD_VAR 0 5
14931: ARRAY
14932: PUSH
14933: LD_EXP 75
14937: EQUAL
14938: IFFALSE 14942
// break ;
14940: GO 15089
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
14942: LD_ADDR_EXP 77
14946: PUSH
14947: LD_EXP 77
14951: PPUSH
14952: LD_VAR 0 5
14956: PPUSH
14957: LD_EXP 77
14961: PUSH
14962: LD_VAR 0 5
14966: ARRAY
14967: PUSH
14968: LD_INT 1
14970: PLUS
14971: PPUSH
14972: CALL_OW 1
14976: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
14977: LD_ADDR_EXP 74
14981: PUSH
14982: LD_EXP 74
14986: PPUSH
14987: LD_VAR 0 5
14991: PUSH
14992: LD_EXP 74
14996: PUSH
14997: LD_VAR 0 5
15001: ARRAY
15002: PUSH
15003: LD_INT 1
15005: PLUS
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PPUSH
15011: LD_VAR 0 2
15015: PUSH
15016: LD_VAR 0 4
15020: ARRAY
15021: PUSH
15022: LD_VAR 0 2
15026: PUSH
15027: LD_VAR 0 4
15031: ARRAY
15032: PPUSH
15033: CALL_OW 255
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: PPUSH
15042: CALL 22457 0 3
15046: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
15047: LD_VAR 0 2
15051: PUSH
15052: LD_VAR 0 4
15056: ARRAY
15057: PPUSH
15058: LD_VAR 0 1
15062: PPUSH
15063: CALL_OW 255
15067: PPUSH
15068: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
15072: LD_VAR 0 2
15076: PUSH
15077: LD_VAR 0 4
15081: ARRAY
15082: PPUSH
15083: CALL_OW 141
// end ;
15087: GO 14919
15089: POP
15090: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
15091: LD_VAR 0 1
15095: PPUSH
15096: LD_EXP 74
15100: PUSH
15101: LD_VAR 0 5
15105: ARRAY
15106: PUSH
15107: LD_INT 0
15109: PLUS
15110: PPUSH
15111: CALL_OW 505
// end ;
15115: LD_VAR 0 3
15119: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
15120: LD_INT 0
15122: PPUSH
15123: PPUSH
15124: PPUSH
15125: PPUSH
// if not hack in hackTanks then
15126: LD_VAR 0 1
15130: PUSH
15131: LD_EXP 73
15135: IN
15136: NOT
15137: IFFALSE 15141
// exit ;
15139: GO 15381
// index := GetElementIndex ( hackTanks , hack ) ;
15141: LD_ADDR_VAR 0 4
15145: PUSH
15146: LD_EXP 73
15150: PPUSH
15151: LD_VAR 0 1
15155: PPUSH
15156: CALL 22242 0 2
15160: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
15161: LD_ADDR_VAR 0 3
15165: PUSH
15166: DOUBLE
15167: LD_EXP 74
15171: PUSH
15172: LD_VAR 0 4
15176: ARRAY
15177: INC
15178: ST_TO_ADDR
15179: LD_INT 1
15181: PUSH
15182: FOR_DOWNTO
15183: IFFALSE 15355
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
15185: LD_ADDR_VAR 0 5
15189: PUSH
15190: LD_EXP 74
15194: PUSH
15195: LD_VAR 0 4
15199: ARRAY
15200: PUSH
15201: LD_VAR 0 3
15205: ARRAY
15206: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
15207: LD_VAR 0 5
15211: PUSH
15212: LD_INT 1
15214: ARRAY
15215: PPUSH
15216: CALL_OW 302
15220: NOT
15221: PUSH
15222: LD_VAR 0 5
15226: PUSH
15227: LD_INT 1
15229: ARRAY
15230: PPUSH
15231: CALL_OW 255
15235: PUSH
15236: LD_VAR 0 1
15240: PPUSH
15241: CALL_OW 255
15245: NONEQUAL
15246: OR
15247: IFFALSE 15353
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
15249: LD_VAR 0 5
15253: PUSH
15254: LD_INT 1
15256: ARRAY
15257: PPUSH
15258: CALL_OW 305
15262: PUSH
15263: LD_VAR 0 5
15267: PUSH
15268: LD_INT 1
15270: ARRAY
15271: PPUSH
15272: CALL_OW 255
15276: PUSH
15277: LD_VAR 0 1
15281: PPUSH
15282: CALL_OW 255
15286: EQUAL
15287: AND
15288: IFFALSE 15312
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
15290: LD_VAR 0 5
15294: PUSH
15295: LD_INT 1
15297: ARRAY
15298: PPUSH
15299: LD_VAR 0 5
15303: PUSH
15304: LD_INT 2
15306: ARRAY
15307: PPUSH
15308: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
15312: LD_ADDR_EXP 74
15316: PUSH
15317: LD_EXP 74
15321: PPUSH
15322: LD_VAR 0 4
15326: PPUSH
15327: LD_EXP 74
15331: PUSH
15332: LD_VAR 0 4
15336: ARRAY
15337: PPUSH
15338: LD_VAR 0 3
15342: PPUSH
15343: CALL_OW 3
15347: PPUSH
15348: CALL_OW 1
15352: ST_TO_ADDR
// end ; end ;
15353: GO 15182
15355: POP
15356: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
15357: LD_VAR 0 1
15361: PPUSH
15362: LD_EXP 74
15366: PUSH
15367: LD_VAR 0 4
15371: ARRAY
15372: PUSH
15373: LD_INT 0
15375: PLUS
15376: PPUSH
15377: CALL_OW 505
// end ;
15381: LD_VAR 0 2
15385: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
15386: LD_INT 0
15388: PPUSH
15389: PPUSH
15390: PPUSH
15391: PPUSH
// if not hack in hackTanks then
15392: LD_VAR 0 1
15396: PUSH
15397: LD_EXP 73
15401: IN
15402: NOT
15403: IFFALSE 15407
// exit ;
15405: GO 15492
// index := GetElementIndex ( hackTanks , hack ) ;
15407: LD_ADDR_VAR 0 5
15411: PUSH
15412: LD_EXP 73
15416: PPUSH
15417: LD_VAR 0 1
15421: PPUSH
15422: CALL 22242 0 2
15426: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
15427: LD_ADDR_VAR 0 4
15431: PUSH
15432: DOUBLE
15433: LD_INT 1
15435: DEC
15436: ST_TO_ADDR
15437: LD_EXP 74
15441: PUSH
15442: LD_VAR 0 5
15446: ARRAY
15447: PUSH
15448: FOR_TO
15449: IFFALSE 15490
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
15451: LD_EXP 74
15455: PUSH
15456: LD_VAR 0 5
15460: ARRAY
15461: PUSH
15462: LD_VAR 0 4
15466: ARRAY
15467: PUSH
15468: LD_INT 1
15470: ARRAY
15471: PUSH
15472: LD_VAR 0 2
15476: EQUAL
15477: IFFALSE 15488
// KillUnit ( vehicle ) ;
15479: LD_VAR 0 2
15483: PPUSH
15484: CALL_OW 66
15488: GO 15448
15490: POP
15491: POP
// end ;
15492: LD_VAR 0 3
15496: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
15497: LD_EXP 78
15501: NOT
15502: IFFALSE 15537
15504: GO 15506
15506: DISABLE
// begin initMiner := true ;
15507: LD_ADDR_EXP 78
15511: PUSH
15512: LD_INT 1
15514: ST_TO_ADDR
// minersList := [ ] ;
15515: LD_ADDR_EXP 79
15519: PUSH
15520: EMPTY
15521: ST_TO_ADDR
// minerMinesList := [ ] ;
15522: LD_ADDR_EXP 80
15526: PUSH
15527: EMPTY
15528: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
15529: LD_ADDR_EXP 81
15533: PUSH
15534: LD_INT 5
15536: ST_TO_ADDR
// end ;
15537: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
15538: LD_EXP 78
15542: PUSH
15543: LD_INT 34
15545: PUSH
15546: LD_EXP 8
15550: PUSH
15551: EMPTY
15552: LIST
15553: LIST
15554: PPUSH
15555: CALL_OW 69
15559: AND
15560: IFFALSE 16023
15562: GO 15564
15564: DISABLE
15565: LD_INT 0
15567: PPUSH
15568: PPUSH
15569: PPUSH
15570: PPUSH
// begin enable ;
15571: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
15572: LD_ADDR_VAR 0 1
15576: PUSH
15577: LD_INT 34
15579: PUSH
15580: LD_EXP 8
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PPUSH
15589: CALL_OW 69
15593: PUSH
15594: FOR_IN
15595: IFFALSE 15667
// begin if not i in minersList then
15597: LD_VAR 0 1
15601: PUSH
15602: LD_EXP 79
15606: IN
15607: NOT
15608: IFFALSE 15665
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
15610: LD_ADDR_EXP 79
15614: PUSH
15615: LD_EXP 79
15619: PPUSH
15620: LD_EXP 79
15624: PUSH
15625: LD_INT 1
15627: PLUS
15628: PPUSH
15629: LD_VAR 0 1
15633: PPUSH
15634: CALL_OW 1
15638: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
15639: LD_ADDR_EXP 80
15643: PUSH
15644: LD_EXP 80
15648: PPUSH
15649: LD_EXP 80
15653: PUSH
15654: LD_INT 1
15656: PLUS
15657: PPUSH
15658: EMPTY
15659: PPUSH
15660: CALL_OW 1
15664: ST_TO_ADDR
// end end ;
15665: GO 15594
15667: POP
15668: POP
// for i := minerMinesList downto 1 do
15669: LD_ADDR_VAR 0 1
15673: PUSH
15674: DOUBLE
15675: LD_EXP 80
15679: INC
15680: ST_TO_ADDR
15681: LD_INT 1
15683: PUSH
15684: FOR_DOWNTO
15685: IFFALSE 16021
// begin if IsLive ( minersList [ i ] ) then
15687: LD_EXP 79
15691: PUSH
15692: LD_VAR 0 1
15696: ARRAY
15697: PPUSH
15698: CALL_OW 300
15702: IFFALSE 15730
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
15704: LD_EXP 79
15708: PUSH
15709: LD_VAR 0 1
15713: ARRAY
15714: PPUSH
15715: LD_EXP 80
15719: PUSH
15720: LD_VAR 0 1
15724: ARRAY
15725: PPUSH
15726: CALL_OW 505
// if not minerMinesList [ i ] then
15730: LD_EXP 80
15734: PUSH
15735: LD_VAR 0 1
15739: ARRAY
15740: NOT
15741: IFFALSE 15745
// continue ;
15743: GO 15684
// for j := minerMinesList [ i ] downto 1 do
15745: LD_ADDR_VAR 0 2
15749: PUSH
15750: DOUBLE
15751: LD_EXP 80
15755: PUSH
15756: LD_VAR 0 1
15760: ARRAY
15761: INC
15762: ST_TO_ADDR
15763: LD_INT 1
15765: PUSH
15766: FOR_DOWNTO
15767: IFFALSE 16017
// begin side := GetSide ( minersList [ i ] ) ;
15769: LD_ADDR_VAR 0 3
15773: PUSH
15774: LD_EXP 79
15778: PUSH
15779: LD_VAR 0 1
15783: ARRAY
15784: PPUSH
15785: CALL_OW 255
15789: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
15790: LD_ADDR_VAR 0 4
15794: PUSH
15795: LD_EXP 80
15799: PUSH
15800: LD_VAR 0 1
15804: ARRAY
15805: PUSH
15806: LD_VAR 0 2
15810: ARRAY
15811: PUSH
15812: LD_INT 1
15814: ARRAY
15815: PPUSH
15816: LD_EXP 80
15820: PUSH
15821: LD_VAR 0 1
15825: ARRAY
15826: PUSH
15827: LD_VAR 0 2
15831: ARRAY
15832: PUSH
15833: LD_INT 2
15835: ARRAY
15836: PPUSH
15837: CALL_OW 428
15841: ST_TO_ADDR
// if not tmp then
15842: LD_VAR 0 4
15846: NOT
15847: IFFALSE 15851
// continue ;
15849: GO 15766
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
15851: LD_VAR 0 4
15855: PUSH
15856: LD_INT 81
15858: PUSH
15859: LD_VAR 0 3
15863: PUSH
15864: EMPTY
15865: LIST
15866: LIST
15867: PPUSH
15868: CALL_OW 69
15872: IN
15873: PUSH
15874: LD_EXP 80
15878: PUSH
15879: LD_VAR 0 1
15883: ARRAY
15884: PUSH
15885: LD_VAR 0 2
15889: ARRAY
15890: PUSH
15891: LD_INT 1
15893: ARRAY
15894: PPUSH
15895: LD_EXP 80
15899: PUSH
15900: LD_VAR 0 1
15904: ARRAY
15905: PUSH
15906: LD_VAR 0 2
15910: ARRAY
15911: PUSH
15912: LD_INT 2
15914: ARRAY
15915: PPUSH
15916: CALL_OW 458
15920: AND
15921: IFFALSE 16015
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
15923: LD_EXP 80
15927: PUSH
15928: LD_VAR 0 1
15932: ARRAY
15933: PUSH
15934: LD_VAR 0 2
15938: ARRAY
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PPUSH
15944: LD_EXP 80
15948: PUSH
15949: LD_VAR 0 1
15953: ARRAY
15954: PUSH
15955: LD_VAR 0 2
15959: ARRAY
15960: PUSH
15961: LD_INT 2
15963: ARRAY
15964: PPUSH
15965: LD_VAR 0 3
15969: PPUSH
15970: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
15974: LD_ADDR_EXP 80
15978: PUSH
15979: LD_EXP 80
15983: PPUSH
15984: LD_VAR 0 1
15988: PPUSH
15989: LD_EXP 80
15993: PUSH
15994: LD_VAR 0 1
15998: ARRAY
15999: PPUSH
16000: LD_VAR 0 2
16004: PPUSH
16005: CALL_OW 3
16009: PPUSH
16010: CALL_OW 1
16014: ST_TO_ADDR
// end ; end ;
16015: GO 15766
16017: POP
16018: POP
// end ;
16019: GO 15684
16021: POP
16022: POP
// end ;
16023: PPOPN 4
16025: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
16026: LD_INT 0
16028: PPUSH
16029: PPUSH
// result := false ;
16030: LD_ADDR_VAR 0 4
16034: PUSH
16035: LD_INT 0
16037: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
16038: LD_VAR 0 1
16042: PPUSH
16043: CALL_OW 264
16047: PUSH
16048: LD_EXP 8
16052: EQUAL
16053: NOT
16054: IFFALSE 16058
// exit ;
16056: GO 16298
// index := GetElementIndex ( minersList , unit ) ;
16058: LD_ADDR_VAR 0 5
16062: PUSH
16063: LD_EXP 79
16067: PPUSH
16068: LD_VAR 0 1
16072: PPUSH
16073: CALL 22242 0 2
16077: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
16078: LD_EXP 80
16082: PUSH
16083: LD_VAR 0 5
16087: ARRAY
16088: PUSH
16089: LD_EXP 81
16093: GREATEREQUAL
16094: IFFALSE 16098
// exit ;
16096: GO 16298
// ComMoveXY ( unit , x , y ) ;
16098: LD_VAR 0 1
16102: PPUSH
16103: LD_VAR 0 2
16107: PPUSH
16108: LD_VAR 0 3
16112: PPUSH
16113: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
16117: LD_INT 35
16119: PPUSH
16120: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
16124: LD_VAR 0 1
16128: PPUSH
16129: LD_VAR 0 2
16133: PPUSH
16134: LD_VAR 0 3
16138: PPUSH
16139: CALL 52306 0 3
16143: NOT
16144: PUSH
16145: LD_VAR 0 1
16149: PPUSH
16150: CALL_OW 314
16154: AND
16155: IFFALSE 16159
// exit ;
16157: GO 16298
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
16159: LD_VAR 0 2
16163: PPUSH
16164: LD_VAR 0 3
16168: PPUSH
16169: CALL_OW 428
16173: PUSH
16174: LD_VAR 0 1
16178: EQUAL
16179: PUSH
16180: LD_VAR 0 1
16184: PPUSH
16185: CALL_OW 314
16189: NOT
16190: AND
16191: IFFALSE 16117
// PlaySoundXY ( x , y , PlantMine ) ;
16193: LD_VAR 0 2
16197: PPUSH
16198: LD_VAR 0 3
16202: PPUSH
16203: LD_STRING PlantMine
16205: PPUSH
16206: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
16210: LD_VAR 0 2
16214: PPUSH
16215: LD_VAR 0 3
16219: PPUSH
16220: LD_VAR 0 1
16224: PPUSH
16225: CALL_OW 255
16229: PPUSH
16230: LD_INT 0
16232: PPUSH
16233: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
16237: LD_ADDR_EXP 80
16241: PUSH
16242: LD_EXP 80
16246: PPUSH
16247: LD_VAR 0 5
16251: PUSH
16252: LD_EXP 80
16256: PUSH
16257: LD_VAR 0 5
16261: ARRAY
16262: PUSH
16263: LD_INT 1
16265: PLUS
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: PPUSH
16271: LD_VAR 0 2
16275: PUSH
16276: LD_VAR 0 3
16280: PUSH
16281: EMPTY
16282: LIST
16283: LIST
16284: PPUSH
16285: CALL 22457 0 3
16289: ST_TO_ADDR
// result := true ;
16290: LD_ADDR_VAR 0 4
16294: PUSH
16295: LD_INT 1
16297: ST_TO_ADDR
// end ;
16298: LD_VAR 0 4
16302: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
16303: LD_INT 0
16305: PPUSH
16306: PPUSH
16307: PPUSH
// if not unit in minersList then
16308: LD_VAR 0 1
16312: PUSH
16313: LD_EXP 79
16317: IN
16318: NOT
16319: IFFALSE 16323
// exit ;
16321: GO 16715
// index := GetElementIndex ( minersList , unit ) ;
16323: LD_ADDR_VAR 0 6
16327: PUSH
16328: LD_EXP 79
16332: PPUSH
16333: LD_VAR 0 1
16337: PPUSH
16338: CALL 22242 0 2
16342: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
16343: LD_ADDR_VAR 0 5
16347: PUSH
16348: DOUBLE
16349: LD_EXP 80
16353: PUSH
16354: LD_VAR 0 6
16358: ARRAY
16359: INC
16360: ST_TO_ADDR
16361: LD_INT 1
16363: PUSH
16364: FOR_DOWNTO
16365: IFFALSE 16526
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
16367: LD_EXP 80
16371: PUSH
16372: LD_VAR 0 6
16376: ARRAY
16377: PUSH
16378: LD_VAR 0 5
16382: ARRAY
16383: PUSH
16384: LD_INT 1
16386: ARRAY
16387: PUSH
16388: LD_VAR 0 2
16392: EQUAL
16393: PUSH
16394: LD_EXP 80
16398: PUSH
16399: LD_VAR 0 6
16403: ARRAY
16404: PUSH
16405: LD_VAR 0 5
16409: ARRAY
16410: PUSH
16411: LD_INT 2
16413: ARRAY
16414: PUSH
16415: LD_VAR 0 3
16419: EQUAL
16420: AND
16421: IFFALSE 16524
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
16423: LD_EXP 80
16427: PUSH
16428: LD_VAR 0 6
16432: ARRAY
16433: PUSH
16434: LD_VAR 0 5
16438: ARRAY
16439: PUSH
16440: LD_INT 1
16442: ARRAY
16443: PPUSH
16444: LD_EXP 80
16448: PUSH
16449: LD_VAR 0 6
16453: ARRAY
16454: PUSH
16455: LD_VAR 0 5
16459: ARRAY
16460: PUSH
16461: LD_INT 2
16463: ARRAY
16464: PPUSH
16465: LD_VAR 0 1
16469: PPUSH
16470: CALL_OW 255
16474: PPUSH
16475: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
16479: LD_ADDR_EXP 80
16483: PUSH
16484: LD_EXP 80
16488: PPUSH
16489: LD_VAR 0 6
16493: PPUSH
16494: LD_EXP 80
16498: PUSH
16499: LD_VAR 0 6
16503: ARRAY
16504: PPUSH
16505: LD_VAR 0 5
16509: PPUSH
16510: CALL_OW 3
16514: PPUSH
16515: CALL_OW 1
16519: ST_TO_ADDR
// exit ;
16520: POP
16521: POP
16522: GO 16715
// end ; end ;
16524: GO 16364
16526: POP
16527: POP
// for i := minerMinesList [ index ] downto 1 do
16528: LD_ADDR_VAR 0 5
16532: PUSH
16533: DOUBLE
16534: LD_EXP 80
16538: PUSH
16539: LD_VAR 0 6
16543: ARRAY
16544: INC
16545: ST_TO_ADDR
16546: LD_INT 1
16548: PUSH
16549: FOR_DOWNTO
16550: IFFALSE 16713
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
16552: LD_EXP 80
16556: PUSH
16557: LD_VAR 0 6
16561: ARRAY
16562: PUSH
16563: LD_VAR 0 5
16567: ARRAY
16568: PUSH
16569: LD_INT 1
16571: ARRAY
16572: PPUSH
16573: LD_EXP 80
16577: PUSH
16578: LD_VAR 0 6
16582: ARRAY
16583: PUSH
16584: LD_VAR 0 5
16588: ARRAY
16589: PUSH
16590: LD_INT 2
16592: ARRAY
16593: PPUSH
16594: LD_VAR 0 2
16598: PPUSH
16599: LD_VAR 0 3
16603: PPUSH
16604: CALL_OW 298
16608: PUSH
16609: LD_INT 6
16611: LESS
16612: IFFALSE 16711
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
16614: LD_EXP 80
16618: PUSH
16619: LD_VAR 0 6
16623: ARRAY
16624: PUSH
16625: LD_VAR 0 5
16629: ARRAY
16630: PUSH
16631: LD_INT 1
16633: ARRAY
16634: PPUSH
16635: LD_EXP 80
16639: PUSH
16640: LD_VAR 0 6
16644: ARRAY
16645: PUSH
16646: LD_VAR 0 5
16650: ARRAY
16651: PUSH
16652: LD_INT 2
16654: ARRAY
16655: PPUSH
16656: LD_VAR 0 1
16660: PPUSH
16661: CALL_OW 255
16665: PPUSH
16666: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
16670: LD_ADDR_EXP 80
16674: PUSH
16675: LD_EXP 80
16679: PPUSH
16680: LD_VAR 0 6
16684: PPUSH
16685: LD_EXP 80
16689: PUSH
16690: LD_VAR 0 6
16694: ARRAY
16695: PPUSH
16696: LD_VAR 0 5
16700: PPUSH
16701: CALL_OW 3
16705: PPUSH
16706: CALL_OW 1
16710: ST_TO_ADDR
// end ; end ;
16711: GO 16549
16713: POP
16714: POP
// end ;
16715: LD_VAR 0 4
16719: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
16720: LD_INT 0
16722: PPUSH
16723: PPUSH
16724: PPUSH
16725: PPUSH
16726: PPUSH
16727: PPUSH
16728: PPUSH
16729: PPUSH
16730: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
16731: LD_VAR 0 1
16735: PPUSH
16736: CALL_OW 264
16740: PUSH
16741: LD_EXP 8
16745: EQUAL
16746: NOT
16747: PUSH
16748: LD_VAR 0 1
16752: PUSH
16753: LD_EXP 79
16757: IN
16758: NOT
16759: OR
16760: IFFALSE 16764
// exit ;
16762: GO 17086
// index := GetElementIndex ( minersList , unit ) ;
16764: LD_ADDR_VAR 0 6
16768: PUSH
16769: LD_EXP 79
16773: PPUSH
16774: LD_VAR 0 1
16778: PPUSH
16779: CALL 22242 0 2
16783: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
16784: LD_ADDR_VAR 0 8
16788: PUSH
16789: LD_EXP 81
16793: PUSH
16794: LD_EXP 80
16798: PUSH
16799: LD_VAR 0 6
16803: ARRAY
16804: MINUS
16805: ST_TO_ADDR
// if not minesFreeAmount then
16806: LD_VAR 0 8
16810: NOT
16811: IFFALSE 16815
// exit ;
16813: GO 17086
// tmp := [ ] ;
16815: LD_ADDR_VAR 0 7
16819: PUSH
16820: EMPTY
16821: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
16822: LD_ADDR_VAR 0 5
16826: PUSH
16827: DOUBLE
16828: LD_INT 1
16830: DEC
16831: ST_TO_ADDR
16832: LD_VAR 0 8
16836: PUSH
16837: FOR_TO
16838: IFFALSE 17033
// begin _d := rand ( 0 , 5 ) ;
16840: LD_ADDR_VAR 0 11
16844: PUSH
16845: LD_INT 0
16847: PPUSH
16848: LD_INT 5
16850: PPUSH
16851: CALL_OW 12
16855: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
16856: LD_ADDR_VAR 0 12
16860: PUSH
16861: LD_INT 2
16863: PPUSH
16864: LD_INT 6
16866: PPUSH
16867: CALL_OW 12
16871: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
16872: LD_ADDR_VAR 0 9
16876: PUSH
16877: LD_VAR 0 2
16881: PPUSH
16882: LD_VAR 0 11
16886: PPUSH
16887: LD_VAR 0 12
16891: PPUSH
16892: CALL_OW 272
16896: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
16897: LD_ADDR_VAR 0 10
16901: PUSH
16902: LD_VAR 0 3
16906: PPUSH
16907: LD_VAR 0 11
16911: PPUSH
16912: LD_VAR 0 12
16916: PPUSH
16917: CALL_OW 273
16921: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
16922: LD_VAR 0 9
16926: PPUSH
16927: LD_VAR 0 10
16931: PPUSH
16932: CALL_OW 488
16936: PUSH
16937: LD_VAR 0 9
16941: PUSH
16942: LD_VAR 0 10
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PUSH
16951: LD_VAR 0 7
16955: IN
16956: NOT
16957: AND
16958: PUSH
16959: LD_VAR 0 9
16963: PPUSH
16964: LD_VAR 0 10
16968: PPUSH
16969: CALL_OW 458
16973: NOT
16974: AND
16975: IFFALSE 17017
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
16977: LD_ADDR_VAR 0 7
16981: PUSH
16982: LD_VAR 0 7
16986: PPUSH
16987: LD_VAR 0 7
16991: PUSH
16992: LD_INT 1
16994: PLUS
16995: PPUSH
16996: LD_VAR 0 9
17000: PUSH
17001: LD_VAR 0 10
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: PPUSH
17010: CALL_OW 1
17014: ST_TO_ADDR
17015: GO 17031
// i := i - 1 ;
17017: LD_ADDR_VAR 0 5
17021: PUSH
17022: LD_VAR 0 5
17026: PUSH
17027: LD_INT 1
17029: MINUS
17030: ST_TO_ADDR
// end ;
17031: GO 16837
17033: POP
17034: POP
// for i in tmp do
17035: LD_ADDR_VAR 0 5
17039: PUSH
17040: LD_VAR 0 7
17044: PUSH
17045: FOR_IN
17046: IFFALSE 17084
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
17048: LD_VAR 0 1
17052: PPUSH
17053: LD_VAR 0 5
17057: PUSH
17058: LD_INT 1
17060: ARRAY
17061: PPUSH
17062: LD_VAR 0 5
17066: PUSH
17067: LD_INT 2
17069: ARRAY
17070: PPUSH
17071: CALL 16026 0 3
17075: NOT
17076: IFFALSE 17082
// exit ;
17078: POP
17079: POP
17080: GO 17086
17082: GO 17045
17084: POP
17085: POP
// end ;
17086: LD_VAR 0 4
17090: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
17091: LD_INT 0
17093: PPUSH
17094: PPUSH
17095: PPUSH
17096: PPUSH
17097: PPUSH
17098: PPUSH
17099: PPUSH
// if not GetClass ( unit ) = class_sniper then
17100: LD_VAR 0 1
17104: PPUSH
17105: CALL_OW 257
17109: PUSH
17110: LD_INT 5
17112: EQUAL
17113: NOT
17114: IFFALSE 17118
// exit ;
17116: GO 17506
// dist := 8 ;
17118: LD_ADDR_VAR 0 5
17122: PUSH
17123: LD_INT 8
17125: ST_TO_ADDR
// viewRange := 12 ;
17126: LD_ADDR_VAR 0 7
17130: PUSH
17131: LD_INT 12
17133: ST_TO_ADDR
// side := GetSide ( unit ) ;
17134: LD_ADDR_VAR 0 6
17138: PUSH
17139: LD_VAR 0 1
17143: PPUSH
17144: CALL_OW 255
17148: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
17149: LD_INT 61
17151: PPUSH
17152: LD_VAR 0 6
17156: PPUSH
17157: CALL_OW 321
17161: PUSH
17162: LD_INT 2
17164: EQUAL
17165: IFFALSE 17175
// viewRange := 16 ;
17167: LD_ADDR_VAR 0 7
17171: PUSH
17172: LD_INT 16
17174: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
17175: LD_VAR 0 1
17179: PPUSH
17180: LD_VAR 0 2
17184: PPUSH
17185: LD_VAR 0 3
17189: PPUSH
17190: CALL_OW 297
17194: PUSH
17195: LD_VAR 0 5
17199: GREATER
17200: IFFALSE 17279
// begin ComMoveXY ( unit , x , y ) ;
17202: LD_VAR 0 1
17206: PPUSH
17207: LD_VAR 0 2
17211: PPUSH
17212: LD_VAR 0 3
17216: PPUSH
17217: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
17221: LD_INT 35
17223: PPUSH
17224: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
17228: LD_VAR 0 1
17232: PPUSH
17233: LD_VAR 0 2
17237: PPUSH
17238: LD_VAR 0 3
17242: PPUSH
17243: CALL 52306 0 3
17247: NOT
17248: IFFALSE 17252
// exit ;
17250: GO 17506
// until GetDistUnitXY ( unit , x , y ) < dist ;
17252: LD_VAR 0 1
17256: PPUSH
17257: LD_VAR 0 2
17261: PPUSH
17262: LD_VAR 0 3
17266: PPUSH
17267: CALL_OW 297
17271: PUSH
17272: LD_VAR 0 5
17276: LESS
17277: IFFALSE 17221
// end ; ComTurnXY ( unit , x , y ) ;
17279: LD_VAR 0 1
17283: PPUSH
17284: LD_VAR 0 2
17288: PPUSH
17289: LD_VAR 0 3
17293: PPUSH
17294: CALL_OW 118
// wait ( 5 ) ;
17298: LD_INT 5
17300: PPUSH
17301: CALL_OW 67
// _d := GetDir ( unit ) ;
17305: LD_ADDR_VAR 0 10
17309: PUSH
17310: LD_VAR 0 1
17314: PPUSH
17315: CALL_OW 254
17319: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
17320: LD_ADDR_VAR 0 8
17324: PUSH
17325: LD_VAR 0 1
17329: PPUSH
17330: CALL_OW 250
17334: PPUSH
17335: LD_VAR 0 10
17339: PPUSH
17340: LD_VAR 0 5
17344: PPUSH
17345: CALL_OW 272
17349: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
17350: LD_ADDR_VAR 0 9
17354: PUSH
17355: LD_VAR 0 1
17359: PPUSH
17360: CALL_OW 251
17364: PPUSH
17365: LD_VAR 0 10
17369: PPUSH
17370: LD_VAR 0 5
17374: PPUSH
17375: CALL_OW 273
17379: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17380: LD_VAR 0 8
17384: PPUSH
17385: LD_VAR 0 9
17389: PPUSH
17390: CALL_OW 488
17394: NOT
17395: IFFALSE 17399
// exit ;
17397: GO 17506
// ComAnimCustom ( unit , 1 ) ;
17399: LD_VAR 0 1
17403: PPUSH
17404: LD_INT 1
17406: PPUSH
17407: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
17411: LD_VAR 0 8
17415: PPUSH
17416: LD_VAR 0 9
17420: PPUSH
17421: LD_VAR 0 6
17425: PPUSH
17426: LD_VAR 0 7
17430: PPUSH
17431: CALL_OW 330
// repeat wait ( 1 ) ;
17435: LD_INT 1
17437: PPUSH
17438: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
17442: LD_VAR 0 1
17446: PPUSH
17447: CALL_OW 316
17451: PUSH
17452: LD_VAR 0 1
17456: PPUSH
17457: CALL_OW 314
17461: OR
17462: PUSH
17463: LD_VAR 0 1
17467: PPUSH
17468: CALL_OW 302
17472: NOT
17473: OR
17474: PUSH
17475: LD_VAR 0 1
17479: PPUSH
17480: CALL_OW 301
17484: OR
17485: IFFALSE 17435
// RemoveSeeing ( _x , _y , side ) ;
17487: LD_VAR 0 8
17491: PPUSH
17492: LD_VAR 0 9
17496: PPUSH
17497: LD_VAR 0 6
17501: PPUSH
17502: CALL_OW 331
// end ; end_of_file end_of_file
17506: LD_VAR 0 4
17510: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
17511: LD_INT 0
17513: PPUSH
17514: PPUSH
// if exist_mode then
17515: LD_VAR 0 2
17519: IFFALSE 17544
// unit := CreateCharacter ( prefix & ident ) else
17521: LD_ADDR_VAR 0 5
17525: PUSH
17526: LD_VAR 0 3
17530: PUSH
17531: LD_VAR 0 1
17535: STR
17536: PPUSH
17537: CALL_OW 34
17541: ST_TO_ADDR
17542: GO 17559
// unit := NewCharacter ( ident ) ;
17544: LD_ADDR_VAR 0 5
17548: PUSH
17549: LD_VAR 0 1
17553: PPUSH
17554: CALL_OW 25
17558: ST_TO_ADDR
// result := unit ;
17559: LD_ADDR_VAR 0 4
17563: PUSH
17564: LD_VAR 0 5
17568: ST_TO_ADDR
// end ;
17569: LD_VAR 0 4
17573: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
17574: LD_INT 0
17576: PPUSH
17577: PPUSH
// if not side or not nation then
17578: LD_VAR 0 1
17582: NOT
17583: PUSH
17584: LD_VAR 0 2
17588: NOT
17589: OR
17590: IFFALSE 17594
// exit ;
17592: GO 18358
// case nation of nation_american :
17594: LD_VAR 0 2
17598: PUSH
17599: LD_INT 1
17601: DOUBLE
17602: EQUAL
17603: IFTRUE 17607
17605: GO 17821
17607: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
17608: LD_ADDR_VAR 0 4
17612: PUSH
17613: LD_INT 35
17615: PUSH
17616: LD_INT 45
17618: PUSH
17619: LD_INT 46
17621: PUSH
17622: LD_INT 47
17624: PUSH
17625: LD_INT 82
17627: PUSH
17628: LD_INT 83
17630: PUSH
17631: LD_INT 84
17633: PUSH
17634: LD_INT 85
17636: PUSH
17637: LD_INT 86
17639: PUSH
17640: LD_INT 1
17642: PUSH
17643: LD_INT 2
17645: PUSH
17646: LD_INT 6
17648: PUSH
17649: LD_INT 15
17651: PUSH
17652: LD_INT 16
17654: PUSH
17655: LD_INT 7
17657: PUSH
17658: LD_INT 12
17660: PUSH
17661: LD_INT 13
17663: PUSH
17664: LD_INT 10
17666: PUSH
17667: LD_INT 14
17669: PUSH
17670: LD_INT 20
17672: PUSH
17673: LD_INT 21
17675: PUSH
17676: LD_INT 22
17678: PUSH
17679: LD_INT 25
17681: PUSH
17682: LD_INT 32
17684: PUSH
17685: LD_INT 27
17687: PUSH
17688: LD_INT 36
17690: PUSH
17691: LD_INT 69
17693: PUSH
17694: LD_INT 39
17696: PUSH
17697: LD_INT 34
17699: PUSH
17700: LD_INT 40
17702: PUSH
17703: LD_INT 48
17705: PUSH
17706: LD_INT 49
17708: PUSH
17709: LD_INT 50
17711: PUSH
17712: LD_INT 51
17714: PUSH
17715: LD_INT 52
17717: PUSH
17718: LD_INT 53
17720: PUSH
17721: LD_INT 54
17723: PUSH
17724: LD_INT 55
17726: PUSH
17727: LD_INT 56
17729: PUSH
17730: LD_INT 57
17732: PUSH
17733: LD_INT 58
17735: PUSH
17736: LD_INT 59
17738: PUSH
17739: LD_INT 60
17741: PUSH
17742: LD_INT 61
17744: PUSH
17745: LD_INT 62
17747: PUSH
17748: LD_INT 80
17750: PUSH
17751: LD_INT 82
17753: PUSH
17754: LD_INT 83
17756: PUSH
17757: LD_INT 84
17759: PUSH
17760: LD_INT 85
17762: PUSH
17763: LD_INT 86
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: LIST
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: ST_TO_ADDR
17819: GO 18282
17821: LD_INT 2
17823: DOUBLE
17824: EQUAL
17825: IFTRUE 17829
17827: GO 18051
17829: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
17830: LD_ADDR_VAR 0 4
17834: PUSH
17835: LD_INT 35
17837: PUSH
17838: LD_INT 45
17840: PUSH
17841: LD_INT 46
17843: PUSH
17844: LD_INT 47
17846: PUSH
17847: LD_INT 82
17849: PUSH
17850: LD_INT 83
17852: PUSH
17853: LD_INT 84
17855: PUSH
17856: LD_INT 85
17858: PUSH
17859: LD_INT 87
17861: PUSH
17862: LD_INT 70
17864: PUSH
17865: LD_INT 1
17867: PUSH
17868: LD_INT 11
17870: PUSH
17871: LD_INT 3
17873: PUSH
17874: LD_INT 4
17876: PUSH
17877: LD_INT 5
17879: PUSH
17880: LD_INT 6
17882: PUSH
17883: LD_INT 15
17885: PUSH
17886: LD_INT 18
17888: PUSH
17889: LD_INT 7
17891: PUSH
17892: LD_INT 17
17894: PUSH
17895: LD_INT 8
17897: PUSH
17898: LD_INT 20
17900: PUSH
17901: LD_INT 21
17903: PUSH
17904: LD_INT 22
17906: PUSH
17907: LD_INT 72
17909: PUSH
17910: LD_INT 26
17912: PUSH
17913: LD_INT 69
17915: PUSH
17916: LD_INT 39
17918: PUSH
17919: LD_INT 40
17921: PUSH
17922: LD_INT 41
17924: PUSH
17925: LD_INT 42
17927: PUSH
17928: LD_INT 43
17930: PUSH
17931: LD_INT 48
17933: PUSH
17934: LD_INT 49
17936: PUSH
17937: LD_INT 50
17939: PUSH
17940: LD_INT 51
17942: PUSH
17943: LD_INT 52
17945: PUSH
17946: LD_INT 53
17948: PUSH
17949: LD_INT 54
17951: PUSH
17952: LD_INT 55
17954: PUSH
17955: LD_INT 56
17957: PUSH
17958: LD_INT 60
17960: PUSH
17961: LD_INT 61
17963: PUSH
17964: LD_INT 62
17966: PUSH
17967: LD_INT 66
17969: PUSH
17970: LD_INT 67
17972: PUSH
17973: LD_INT 68
17975: PUSH
17976: LD_INT 81
17978: PUSH
17979: LD_INT 82
17981: PUSH
17982: LD_INT 83
17984: PUSH
17985: LD_INT 84
17987: PUSH
17988: LD_INT 85
17990: PUSH
17991: LD_INT 87
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: ST_TO_ADDR
18049: GO 18282
18051: LD_INT 3
18053: DOUBLE
18054: EQUAL
18055: IFTRUE 18059
18057: GO 18281
18059: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
18060: LD_ADDR_VAR 0 4
18064: PUSH
18065: LD_INT 46
18067: PUSH
18068: LD_INT 47
18070: PUSH
18071: LD_INT 1
18073: PUSH
18074: LD_INT 2
18076: PUSH
18077: LD_INT 82
18079: PUSH
18080: LD_INT 83
18082: PUSH
18083: LD_INT 84
18085: PUSH
18086: LD_INT 85
18088: PUSH
18089: LD_INT 86
18091: PUSH
18092: LD_INT 11
18094: PUSH
18095: LD_INT 9
18097: PUSH
18098: LD_INT 20
18100: PUSH
18101: LD_INT 19
18103: PUSH
18104: LD_INT 21
18106: PUSH
18107: LD_INT 24
18109: PUSH
18110: LD_INT 22
18112: PUSH
18113: LD_INT 25
18115: PUSH
18116: LD_INT 28
18118: PUSH
18119: LD_INT 29
18121: PUSH
18122: LD_INT 30
18124: PUSH
18125: LD_INT 31
18127: PUSH
18128: LD_INT 37
18130: PUSH
18131: LD_INT 38
18133: PUSH
18134: LD_INT 32
18136: PUSH
18137: LD_INT 27
18139: PUSH
18140: LD_INT 33
18142: PUSH
18143: LD_INT 69
18145: PUSH
18146: LD_INT 39
18148: PUSH
18149: LD_INT 34
18151: PUSH
18152: LD_INT 40
18154: PUSH
18155: LD_INT 71
18157: PUSH
18158: LD_INT 23
18160: PUSH
18161: LD_INT 44
18163: PUSH
18164: LD_INT 48
18166: PUSH
18167: LD_INT 49
18169: PUSH
18170: LD_INT 50
18172: PUSH
18173: LD_INT 51
18175: PUSH
18176: LD_INT 52
18178: PUSH
18179: LD_INT 53
18181: PUSH
18182: LD_INT 54
18184: PUSH
18185: LD_INT 55
18187: PUSH
18188: LD_INT 56
18190: PUSH
18191: LD_INT 57
18193: PUSH
18194: LD_INT 58
18196: PUSH
18197: LD_INT 59
18199: PUSH
18200: LD_INT 63
18202: PUSH
18203: LD_INT 64
18205: PUSH
18206: LD_INT 65
18208: PUSH
18209: LD_INT 82
18211: PUSH
18212: LD_INT 83
18214: PUSH
18215: LD_INT 84
18217: PUSH
18218: LD_INT 85
18220: PUSH
18221: LD_INT 86
18223: PUSH
18224: EMPTY
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: LIST
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: LIST
18255: LIST
18256: LIST
18257: LIST
18258: LIST
18259: LIST
18260: LIST
18261: LIST
18262: LIST
18263: LIST
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: LIST
18269: LIST
18270: LIST
18271: LIST
18272: LIST
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: ST_TO_ADDR
18279: GO 18282
18281: POP
// if state > - 1 and state < 3 then
18282: LD_VAR 0 3
18286: PUSH
18287: LD_INT 1
18289: NEG
18290: GREATER
18291: PUSH
18292: LD_VAR 0 3
18296: PUSH
18297: LD_INT 3
18299: LESS
18300: AND
18301: IFFALSE 18358
// for i in result do
18303: LD_ADDR_VAR 0 5
18307: PUSH
18308: LD_VAR 0 4
18312: PUSH
18313: FOR_IN
18314: IFFALSE 18356
// if GetTech ( i , side ) <> state then
18316: LD_VAR 0 5
18320: PPUSH
18321: LD_VAR 0 1
18325: PPUSH
18326: CALL_OW 321
18330: PUSH
18331: LD_VAR 0 3
18335: NONEQUAL
18336: IFFALSE 18354
// result := result diff i ;
18338: LD_ADDR_VAR 0 4
18342: PUSH
18343: LD_VAR 0 4
18347: PUSH
18348: LD_VAR 0 5
18352: DIFF
18353: ST_TO_ADDR
18354: GO 18313
18356: POP
18357: POP
// end ;
18358: LD_VAR 0 4
18362: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
18363: LD_INT 0
18365: PPUSH
18366: PPUSH
18367: PPUSH
// result := true ;
18368: LD_ADDR_VAR 0 3
18372: PUSH
18373: LD_INT 1
18375: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
18376: LD_ADDR_VAR 0 5
18380: PUSH
18381: LD_VAR 0 2
18385: PPUSH
18386: CALL_OW 480
18390: ST_TO_ADDR
// if not tmp then
18391: LD_VAR 0 5
18395: NOT
18396: IFFALSE 18400
// exit ;
18398: GO 18449
// for i in tmp do
18400: LD_ADDR_VAR 0 4
18404: PUSH
18405: LD_VAR 0 5
18409: PUSH
18410: FOR_IN
18411: IFFALSE 18447
// if GetTech ( i , side ) <> state_researched then
18413: LD_VAR 0 4
18417: PPUSH
18418: LD_VAR 0 1
18422: PPUSH
18423: CALL_OW 321
18427: PUSH
18428: LD_INT 2
18430: NONEQUAL
18431: IFFALSE 18445
// begin result := false ;
18433: LD_ADDR_VAR 0 3
18437: PUSH
18438: LD_INT 0
18440: ST_TO_ADDR
// exit ;
18441: POP
18442: POP
18443: GO 18449
// end ;
18445: GO 18410
18447: POP
18448: POP
// end ;
18449: LD_VAR 0 3
18453: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
18454: LD_INT 0
18456: PPUSH
18457: PPUSH
18458: PPUSH
18459: PPUSH
18460: PPUSH
18461: PPUSH
18462: PPUSH
18463: PPUSH
18464: PPUSH
18465: PPUSH
18466: PPUSH
18467: PPUSH
18468: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
18469: LD_VAR 0 1
18473: NOT
18474: PUSH
18475: LD_VAR 0 1
18479: PPUSH
18480: CALL_OW 257
18484: PUSH
18485: LD_INT 9
18487: NONEQUAL
18488: OR
18489: IFFALSE 18493
// exit ;
18491: GO 19066
// side := GetSide ( unit ) ;
18493: LD_ADDR_VAR 0 9
18497: PUSH
18498: LD_VAR 0 1
18502: PPUSH
18503: CALL_OW 255
18507: ST_TO_ADDR
// tech_space := tech_spacanom ;
18508: LD_ADDR_VAR 0 12
18512: PUSH
18513: LD_INT 29
18515: ST_TO_ADDR
// tech_time := tech_taurad ;
18516: LD_ADDR_VAR 0 13
18520: PUSH
18521: LD_INT 28
18523: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
18524: LD_ADDR_VAR 0 11
18528: PUSH
18529: LD_VAR 0 1
18533: PPUSH
18534: CALL_OW 310
18538: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
18539: LD_VAR 0 11
18543: PPUSH
18544: CALL_OW 247
18548: PUSH
18549: LD_INT 2
18551: EQUAL
18552: IFFALSE 18556
// exit ;
18554: GO 19066
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18556: LD_ADDR_VAR 0 8
18560: PUSH
18561: LD_INT 81
18563: PUSH
18564: LD_VAR 0 9
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PUSH
18573: LD_INT 3
18575: PUSH
18576: LD_INT 21
18578: PUSH
18579: LD_INT 3
18581: PUSH
18582: EMPTY
18583: LIST
18584: LIST
18585: PUSH
18586: EMPTY
18587: LIST
18588: LIST
18589: PUSH
18590: EMPTY
18591: LIST
18592: LIST
18593: PPUSH
18594: CALL_OW 69
18598: ST_TO_ADDR
// if not tmp then
18599: LD_VAR 0 8
18603: NOT
18604: IFFALSE 18608
// exit ;
18606: GO 19066
// if in_unit then
18608: LD_VAR 0 11
18612: IFFALSE 18636
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
18614: LD_ADDR_VAR 0 10
18618: PUSH
18619: LD_VAR 0 8
18623: PPUSH
18624: LD_VAR 0 11
18628: PPUSH
18629: CALL_OW 74
18633: ST_TO_ADDR
18634: GO 18656
// enemy := NearestUnitToUnit ( tmp , unit ) ;
18636: LD_ADDR_VAR 0 10
18640: PUSH
18641: LD_VAR 0 8
18645: PPUSH
18646: LD_VAR 0 1
18650: PPUSH
18651: CALL_OW 74
18655: ST_TO_ADDR
// if not enemy then
18656: LD_VAR 0 10
18660: NOT
18661: IFFALSE 18665
// exit ;
18663: GO 19066
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
18665: LD_VAR 0 11
18669: PUSH
18670: LD_VAR 0 11
18674: PPUSH
18675: LD_VAR 0 10
18679: PPUSH
18680: CALL_OW 296
18684: PUSH
18685: LD_INT 13
18687: GREATER
18688: AND
18689: PUSH
18690: LD_VAR 0 1
18694: PPUSH
18695: LD_VAR 0 10
18699: PPUSH
18700: CALL_OW 296
18704: PUSH
18705: LD_INT 12
18707: GREATER
18708: OR
18709: IFFALSE 18713
// exit ;
18711: GO 19066
// missile := [ 1 ] ;
18713: LD_ADDR_VAR 0 14
18717: PUSH
18718: LD_INT 1
18720: PUSH
18721: EMPTY
18722: LIST
18723: ST_TO_ADDR
// if Researched ( side , tech_space ) then
18724: LD_VAR 0 9
18728: PPUSH
18729: LD_VAR 0 12
18733: PPUSH
18734: CALL_OW 325
18738: IFFALSE 18767
// missile := Insert ( missile , missile + 1 , 2 ) ;
18740: LD_ADDR_VAR 0 14
18744: PUSH
18745: LD_VAR 0 14
18749: PPUSH
18750: LD_VAR 0 14
18754: PUSH
18755: LD_INT 1
18757: PLUS
18758: PPUSH
18759: LD_INT 2
18761: PPUSH
18762: CALL_OW 2
18766: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
18767: LD_VAR 0 9
18771: PPUSH
18772: LD_VAR 0 13
18776: PPUSH
18777: CALL_OW 325
18781: PUSH
18782: LD_VAR 0 10
18786: PPUSH
18787: CALL_OW 255
18791: PPUSH
18792: LD_VAR 0 13
18796: PPUSH
18797: CALL_OW 325
18801: NOT
18802: AND
18803: IFFALSE 18832
// missile := Insert ( missile , missile + 1 , 3 ) ;
18805: LD_ADDR_VAR 0 14
18809: PUSH
18810: LD_VAR 0 14
18814: PPUSH
18815: LD_VAR 0 14
18819: PUSH
18820: LD_INT 1
18822: PLUS
18823: PPUSH
18824: LD_INT 3
18826: PPUSH
18827: CALL_OW 2
18831: ST_TO_ADDR
// if missile < 2 then
18832: LD_VAR 0 14
18836: PUSH
18837: LD_INT 2
18839: LESS
18840: IFFALSE 18844
// exit ;
18842: GO 19066
// x := GetX ( enemy ) ;
18844: LD_ADDR_VAR 0 4
18848: PUSH
18849: LD_VAR 0 10
18853: PPUSH
18854: CALL_OW 250
18858: ST_TO_ADDR
// y := GetY ( enemy ) ;
18859: LD_ADDR_VAR 0 5
18863: PUSH
18864: LD_VAR 0 10
18868: PPUSH
18869: CALL_OW 251
18873: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
18874: LD_ADDR_VAR 0 6
18878: PUSH
18879: LD_VAR 0 4
18883: PUSH
18884: LD_INT 1
18886: NEG
18887: PPUSH
18888: LD_INT 1
18890: PPUSH
18891: CALL_OW 12
18895: PLUS
18896: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
18897: LD_ADDR_VAR 0 7
18901: PUSH
18902: LD_VAR 0 5
18906: PUSH
18907: LD_INT 1
18909: NEG
18910: PPUSH
18911: LD_INT 1
18913: PPUSH
18914: CALL_OW 12
18918: PLUS
18919: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18920: LD_VAR 0 6
18924: PPUSH
18925: LD_VAR 0 7
18929: PPUSH
18930: CALL_OW 488
18934: NOT
18935: IFFALSE 18957
// begin _x := x ;
18937: LD_ADDR_VAR 0 6
18941: PUSH
18942: LD_VAR 0 4
18946: ST_TO_ADDR
// _y := y ;
18947: LD_ADDR_VAR 0 7
18951: PUSH
18952: LD_VAR 0 5
18956: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
18957: LD_ADDR_VAR 0 3
18961: PUSH
18962: LD_INT 1
18964: PPUSH
18965: LD_VAR 0 14
18969: PPUSH
18970: CALL_OW 12
18974: ST_TO_ADDR
// case i of 1 :
18975: LD_VAR 0 3
18979: PUSH
18980: LD_INT 1
18982: DOUBLE
18983: EQUAL
18984: IFTRUE 18988
18986: GO 19005
18988: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
18989: LD_VAR 0 1
18993: PPUSH
18994: LD_VAR 0 10
18998: PPUSH
18999: CALL_OW 115
19003: GO 19066
19005: LD_INT 2
19007: DOUBLE
19008: EQUAL
19009: IFTRUE 19013
19011: GO 19035
19013: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
19014: LD_VAR 0 1
19018: PPUSH
19019: LD_VAR 0 6
19023: PPUSH
19024: LD_VAR 0 7
19028: PPUSH
19029: CALL_OW 153
19033: GO 19066
19035: LD_INT 3
19037: DOUBLE
19038: EQUAL
19039: IFTRUE 19043
19041: GO 19065
19043: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
19044: LD_VAR 0 1
19048: PPUSH
19049: LD_VAR 0 6
19053: PPUSH
19054: LD_VAR 0 7
19058: PPUSH
19059: CALL_OW 154
19063: GO 19066
19065: POP
// end ;
19066: LD_VAR 0 2
19070: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
19071: LD_INT 0
19073: PPUSH
19074: PPUSH
19075: PPUSH
19076: PPUSH
19077: PPUSH
19078: PPUSH
// if not unit or not building then
19079: LD_VAR 0 1
19083: NOT
19084: PUSH
19085: LD_VAR 0 2
19089: NOT
19090: OR
19091: IFFALSE 19095
// exit ;
19093: GO 19253
// x := GetX ( building ) ;
19095: LD_ADDR_VAR 0 5
19099: PUSH
19100: LD_VAR 0 2
19104: PPUSH
19105: CALL_OW 250
19109: ST_TO_ADDR
// y := GetY ( building ) ;
19110: LD_ADDR_VAR 0 6
19114: PUSH
19115: LD_VAR 0 2
19119: PPUSH
19120: CALL_OW 251
19124: ST_TO_ADDR
// for i = 0 to 5 do
19125: LD_ADDR_VAR 0 4
19129: PUSH
19130: DOUBLE
19131: LD_INT 0
19133: DEC
19134: ST_TO_ADDR
19135: LD_INT 5
19137: PUSH
19138: FOR_TO
19139: IFFALSE 19251
// begin _x := ShiftX ( x , i , 3 ) ;
19141: LD_ADDR_VAR 0 7
19145: PUSH
19146: LD_VAR 0 5
19150: PPUSH
19151: LD_VAR 0 4
19155: PPUSH
19156: LD_INT 3
19158: PPUSH
19159: CALL_OW 272
19163: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
19164: LD_ADDR_VAR 0 8
19168: PUSH
19169: LD_VAR 0 6
19173: PPUSH
19174: LD_VAR 0 4
19178: PPUSH
19179: LD_INT 3
19181: PPUSH
19182: CALL_OW 273
19186: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
19187: LD_VAR 0 7
19191: PPUSH
19192: LD_VAR 0 8
19196: PPUSH
19197: CALL_OW 488
19201: NOT
19202: IFFALSE 19206
// continue ;
19204: GO 19138
// if HexInfo ( _x , _y ) = 0 then
19206: LD_VAR 0 7
19210: PPUSH
19211: LD_VAR 0 8
19215: PPUSH
19216: CALL_OW 428
19220: PUSH
19221: LD_INT 0
19223: EQUAL
19224: IFFALSE 19249
// begin ComMoveXY ( unit , _x , _y ) ;
19226: LD_VAR 0 1
19230: PPUSH
19231: LD_VAR 0 7
19235: PPUSH
19236: LD_VAR 0 8
19240: PPUSH
19241: CALL_OW 111
// exit ;
19245: POP
19246: POP
19247: GO 19253
// end ; end ;
19249: GO 19138
19251: POP
19252: POP
// end ;
19253: LD_VAR 0 3
19257: RET
// export function ScanBase ( side , base_area ) ; begin
19258: LD_INT 0
19260: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
19261: LD_ADDR_VAR 0 3
19265: PUSH
19266: LD_VAR 0 2
19270: PPUSH
19271: LD_INT 81
19273: PUSH
19274: LD_VAR 0 1
19278: PUSH
19279: EMPTY
19280: LIST
19281: LIST
19282: PPUSH
19283: CALL_OW 70
19287: ST_TO_ADDR
// end ;
19288: LD_VAR 0 3
19292: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
19293: LD_INT 0
19295: PPUSH
19296: PPUSH
19297: PPUSH
19298: PPUSH
// result := false ;
19299: LD_ADDR_VAR 0 2
19303: PUSH
19304: LD_INT 0
19306: ST_TO_ADDR
// side := GetSide ( unit ) ;
19307: LD_ADDR_VAR 0 3
19311: PUSH
19312: LD_VAR 0 1
19316: PPUSH
19317: CALL_OW 255
19321: ST_TO_ADDR
// nat := GetNation ( unit ) ;
19322: LD_ADDR_VAR 0 4
19326: PUSH
19327: LD_VAR 0 1
19331: PPUSH
19332: CALL_OW 248
19336: ST_TO_ADDR
// case nat of 1 :
19337: LD_VAR 0 4
19341: PUSH
19342: LD_INT 1
19344: DOUBLE
19345: EQUAL
19346: IFTRUE 19350
19348: GO 19361
19350: POP
// tech := tech_lassight ; 2 :
19351: LD_ADDR_VAR 0 5
19355: PUSH
19356: LD_INT 12
19358: ST_TO_ADDR
19359: GO 19400
19361: LD_INT 2
19363: DOUBLE
19364: EQUAL
19365: IFTRUE 19369
19367: GO 19380
19369: POP
// tech := tech_mortar ; 3 :
19370: LD_ADDR_VAR 0 5
19374: PUSH
19375: LD_INT 41
19377: ST_TO_ADDR
19378: GO 19400
19380: LD_INT 3
19382: DOUBLE
19383: EQUAL
19384: IFTRUE 19388
19386: GO 19399
19388: POP
// tech := tech_bazooka ; end ;
19389: LD_ADDR_VAR 0 5
19393: PUSH
19394: LD_INT 44
19396: ST_TO_ADDR
19397: GO 19400
19399: POP
// if Researched ( side , tech ) then
19400: LD_VAR 0 3
19404: PPUSH
19405: LD_VAR 0 5
19409: PPUSH
19410: CALL_OW 325
19414: IFFALSE 19441
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
19416: LD_ADDR_VAR 0 2
19420: PUSH
19421: LD_INT 5
19423: PUSH
19424: LD_INT 8
19426: PUSH
19427: LD_INT 9
19429: PUSH
19430: EMPTY
19431: LIST
19432: LIST
19433: LIST
19434: PUSH
19435: LD_VAR 0 4
19439: ARRAY
19440: ST_TO_ADDR
// end ;
19441: LD_VAR 0 2
19445: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
19446: LD_INT 0
19448: PPUSH
19449: PPUSH
19450: PPUSH
// if not mines then
19451: LD_VAR 0 2
19455: NOT
19456: IFFALSE 19460
// exit ;
19458: GO 19604
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19460: LD_ADDR_VAR 0 5
19464: PUSH
19465: LD_INT 81
19467: PUSH
19468: LD_VAR 0 1
19472: PUSH
19473: EMPTY
19474: LIST
19475: LIST
19476: PUSH
19477: LD_INT 3
19479: PUSH
19480: LD_INT 21
19482: PUSH
19483: LD_INT 3
19485: PUSH
19486: EMPTY
19487: LIST
19488: LIST
19489: PUSH
19490: EMPTY
19491: LIST
19492: LIST
19493: PUSH
19494: EMPTY
19495: LIST
19496: LIST
19497: PPUSH
19498: CALL_OW 69
19502: ST_TO_ADDR
// for i in mines do
19503: LD_ADDR_VAR 0 4
19507: PUSH
19508: LD_VAR 0 2
19512: PUSH
19513: FOR_IN
19514: IFFALSE 19602
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
19516: LD_VAR 0 4
19520: PUSH
19521: LD_INT 1
19523: ARRAY
19524: PPUSH
19525: LD_VAR 0 4
19529: PUSH
19530: LD_INT 2
19532: ARRAY
19533: PPUSH
19534: CALL_OW 458
19538: NOT
19539: IFFALSE 19543
// continue ;
19541: GO 19513
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
19543: LD_VAR 0 4
19547: PUSH
19548: LD_INT 1
19550: ARRAY
19551: PPUSH
19552: LD_VAR 0 4
19556: PUSH
19557: LD_INT 2
19559: ARRAY
19560: PPUSH
19561: CALL_OW 428
19565: PUSH
19566: LD_VAR 0 5
19570: IN
19571: IFFALSE 19600
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
19573: LD_VAR 0 4
19577: PUSH
19578: LD_INT 1
19580: ARRAY
19581: PPUSH
19582: LD_VAR 0 4
19586: PUSH
19587: LD_INT 2
19589: ARRAY
19590: PPUSH
19591: LD_VAR 0 1
19595: PPUSH
19596: CALL_OW 456
// end ;
19600: GO 19513
19602: POP
19603: POP
// end ;
19604: LD_VAR 0 3
19608: RET
// export function Count ( array ) ; var i ; begin
19609: LD_INT 0
19611: PPUSH
19612: PPUSH
// result := 0 ;
19613: LD_ADDR_VAR 0 2
19617: PUSH
19618: LD_INT 0
19620: ST_TO_ADDR
// for i in array do
19621: LD_ADDR_VAR 0 3
19625: PUSH
19626: LD_VAR 0 1
19630: PUSH
19631: FOR_IN
19632: IFFALSE 19656
// if i then
19634: LD_VAR 0 3
19638: IFFALSE 19654
// result := result + 1 ;
19640: LD_ADDR_VAR 0 2
19644: PUSH
19645: LD_VAR 0 2
19649: PUSH
19650: LD_INT 1
19652: PLUS
19653: ST_TO_ADDR
19654: GO 19631
19656: POP
19657: POP
// end ;
19658: LD_VAR 0 2
19662: RET
// export function IsEmpty ( building ) ; begin
19663: LD_INT 0
19665: PPUSH
// if not building then
19666: LD_VAR 0 1
19670: NOT
19671: IFFALSE 19675
// exit ;
19673: GO 19718
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
19675: LD_ADDR_VAR 0 2
19679: PUSH
19680: LD_VAR 0 1
19684: PUSH
19685: LD_INT 22
19687: PUSH
19688: LD_VAR 0 1
19692: PPUSH
19693: CALL_OW 255
19697: PUSH
19698: EMPTY
19699: LIST
19700: LIST
19701: PUSH
19702: LD_INT 58
19704: PUSH
19705: EMPTY
19706: LIST
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: PPUSH
19712: CALL_OW 69
19716: IN
19717: ST_TO_ADDR
// end ;
19718: LD_VAR 0 2
19722: RET
// export function IsNotFull ( building ) ; begin
19723: LD_INT 0
19725: PPUSH
// if not building then
19726: LD_VAR 0 1
19730: NOT
19731: IFFALSE 19735
// exit ;
19733: GO 19754
// result := UnitsInside ( building ) < 6 ;
19735: LD_ADDR_VAR 0 2
19739: PUSH
19740: LD_VAR 0 1
19744: PPUSH
19745: CALL_OW 313
19749: PUSH
19750: LD_INT 6
19752: LESS
19753: ST_TO_ADDR
// end ;
19754: LD_VAR 0 2
19758: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
19759: LD_INT 0
19761: PPUSH
19762: PPUSH
19763: PPUSH
19764: PPUSH
// tmp := [ ] ;
19765: LD_ADDR_VAR 0 3
19769: PUSH
19770: EMPTY
19771: ST_TO_ADDR
// list := [ ] ;
19772: LD_ADDR_VAR 0 5
19776: PUSH
19777: EMPTY
19778: ST_TO_ADDR
// for i = 16 to 25 do
19779: LD_ADDR_VAR 0 4
19783: PUSH
19784: DOUBLE
19785: LD_INT 16
19787: DEC
19788: ST_TO_ADDR
19789: LD_INT 25
19791: PUSH
19792: FOR_TO
19793: IFFALSE 19866
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
19795: LD_ADDR_VAR 0 3
19799: PUSH
19800: LD_VAR 0 3
19804: PUSH
19805: LD_INT 22
19807: PUSH
19808: LD_VAR 0 1
19812: PPUSH
19813: CALL_OW 255
19817: PUSH
19818: EMPTY
19819: LIST
19820: LIST
19821: PUSH
19822: LD_INT 91
19824: PUSH
19825: LD_VAR 0 1
19829: PUSH
19830: LD_INT 6
19832: PUSH
19833: EMPTY
19834: LIST
19835: LIST
19836: LIST
19837: PUSH
19838: LD_INT 30
19840: PUSH
19841: LD_VAR 0 4
19845: PUSH
19846: EMPTY
19847: LIST
19848: LIST
19849: PUSH
19850: EMPTY
19851: LIST
19852: LIST
19853: LIST
19854: PUSH
19855: EMPTY
19856: LIST
19857: PPUSH
19858: CALL_OW 69
19862: ADD
19863: ST_TO_ADDR
19864: GO 19792
19866: POP
19867: POP
// for i = 1 to tmp do
19868: LD_ADDR_VAR 0 4
19872: PUSH
19873: DOUBLE
19874: LD_INT 1
19876: DEC
19877: ST_TO_ADDR
19878: LD_VAR 0 3
19882: PUSH
19883: FOR_TO
19884: IFFALSE 19972
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19886: LD_ADDR_VAR 0 5
19890: PUSH
19891: LD_VAR 0 5
19895: PUSH
19896: LD_VAR 0 3
19900: PUSH
19901: LD_VAR 0 4
19905: ARRAY
19906: PPUSH
19907: CALL_OW 266
19911: PUSH
19912: LD_VAR 0 3
19916: PUSH
19917: LD_VAR 0 4
19921: ARRAY
19922: PPUSH
19923: CALL_OW 250
19927: PUSH
19928: LD_VAR 0 3
19932: PUSH
19933: LD_VAR 0 4
19937: ARRAY
19938: PPUSH
19939: CALL_OW 251
19943: PUSH
19944: LD_VAR 0 3
19948: PUSH
19949: LD_VAR 0 4
19953: ARRAY
19954: PPUSH
19955: CALL_OW 254
19959: PUSH
19960: EMPTY
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: PUSH
19966: EMPTY
19967: LIST
19968: ADD
19969: ST_TO_ADDR
19970: GO 19883
19972: POP
19973: POP
// result := list ;
19974: LD_ADDR_VAR 0 2
19978: PUSH
19979: LD_VAR 0 5
19983: ST_TO_ADDR
// end ;
19984: LD_VAR 0 2
19988: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19989: LD_INT 0
19991: PPUSH
19992: PPUSH
19993: PPUSH
19994: PPUSH
19995: PPUSH
19996: PPUSH
19997: PPUSH
// if not factory then
19998: LD_VAR 0 1
20002: NOT
20003: IFFALSE 20007
// exit ;
20005: GO 20600
// if control = control_apeman then
20007: LD_VAR 0 4
20011: PUSH
20012: LD_INT 5
20014: EQUAL
20015: IFFALSE 20124
// begin tmp := UnitsInside ( factory ) ;
20017: LD_ADDR_VAR 0 8
20021: PUSH
20022: LD_VAR 0 1
20026: PPUSH
20027: CALL_OW 313
20031: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
20032: LD_VAR 0 8
20036: PPUSH
20037: LD_INT 25
20039: PUSH
20040: LD_INT 12
20042: PUSH
20043: EMPTY
20044: LIST
20045: LIST
20046: PPUSH
20047: CALL_OW 72
20051: NOT
20052: IFFALSE 20062
// control := control_manual ;
20054: LD_ADDR_VAR 0 4
20058: PUSH
20059: LD_INT 1
20061: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
20062: LD_ADDR_VAR 0 8
20066: PUSH
20067: LD_VAR 0 1
20071: PPUSH
20072: CALL 19759 0 1
20076: ST_TO_ADDR
// if tmp then
20077: LD_VAR 0 8
20081: IFFALSE 20124
// begin for i in tmp do
20083: LD_ADDR_VAR 0 7
20087: PUSH
20088: LD_VAR 0 8
20092: PUSH
20093: FOR_IN
20094: IFFALSE 20122
// if i [ 1 ] = b_ext_radio then
20096: LD_VAR 0 7
20100: PUSH
20101: LD_INT 1
20103: ARRAY
20104: PUSH
20105: LD_INT 22
20107: EQUAL
20108: IFFALSE 20120
// begin control := control_remote ;
20110: LD_ADDR_VAR 0 4
20114: PUSH
20115: LD_INT 2
20117: ST_TO_ADDR
// break ;
20118: GO 20122
// end ;
20120: GO 20093
20122: POP
20123: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20124: LD_VAR 0 1
20128: PPUSH
20129: LD_VAR 0 2
20133: PPUSH
20134: LD_VAR 0 3
20138: PPUSH
20139: LD_VAR 0 4
20143: PPUSH
20144: LD_VAR 0 5
20148: PPUSH
20149: CALL_OW 448
20153: IFFALSE 20188
// begin result := [ chassis , engine , control , weapon ] ;
20155: LD_ADDR_VAR 0 6
20159: PUSH
20160: LD_VAR 0 2
20164: PUSH
20165: LD_VAR 0 3
20169: PUSH
20170: LD_VAR 0 4
20174: PUSH
20175: LD_VAR 0 5
20179: PUSH
20180: EMPTY
20181: LIST
20182: LIST
20183: LIST
20184: LIST
20185: ST_TO_ADDR
// exit ;
20186: GO 20600
// end ; _chassis := AvailableChassisList ( factory ) ;
20188: LD_ADDR_VAR 0 9
20192: PUSH
20193: LD_VAR 0 1
20197: PPUSH
20198: CALL_OW 475
20202: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
20203: LD_ADDR_VAR 0 11
20207: PUSH
20208: LD_VAR 0 1
20212: PPUSH
20213: CALL_OW 476
20217: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
20218: LD_ADDR_VAR 0 12
20222: PUSH
20223: LD_VAR 0 1
20227: PPUSH
20228: CALL_OW 477
20232: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
20233: LD_ADDR_VAR 0 10
20237: PUSH
20238: LD_VAR 0 1
20242: PPUSH
20243: CALL_OW 478
20247: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
20248: LD_VAR 0 9
20252: NOT
20253: PUSH
20254: LD_VAR 0 11
20258: NOT
20259: OR
20260: PUSH
20261: LD_VAR 0 12
20265: NOT
20266: OR
20267: PUSH
20268: LD_VAR 0 10
20272: NOT
20273: OR
20274: IFFALSE 20309
// begin result := [ chassis , engine , control , weapon ] ;
20276: LD_ADDR_VAR 0 6
20280: PUSH
20281: LD_VAR 0 2
20285: PUSH
20286: LD_VAR 0 3
20290: PUSH
20291: LD_VAR 0 4
20295: PUSH
20296: LD_VAR 0 5
20300: PUSH
20301: EMPTY
20302: LIST
20303: LIST
20304: LIST
20305: LIST
20306: ST_TO_ADDR
// exit ;
20307: GO 20600
// end ; if not chassis in _chassis then
20309: LD_VAR 0 2
20313: PUSH
20314: LD_VAR 0 9
20318: IN
20319: NOT
20320: IFFALSE 20346
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
20322: LD_ADDR_VAR 0 2
20326: PUSH
20327: LD_VAR 0 9
20331: PUSH
20332: LD_INT 1
20334: PPUSH
20335: LD_VAR 0 9
20339: PPUSH
20340: CALL_OW 12
20344: ARRAY
20345: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
20346: LD_VAR 0 2
20350: PPUSH
20351: LD_VAR 0 3
20355: PPUSH
20356: CALL 20605 0 2
20360: NOT
20361: IFFALSE 20420
// repeat engine := _engine [ 1 ] ;
20363: LD_ADDR_VAR 0 3
20367: PUSH
20368: LD_VAR 0 11
20372: PUSH
20373: LD_INT 1
20375: ARRAY
20376: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
20377: LD_ADDR_VAR 0 11
20381: PUSH
20382: LD_VAR 0 11
20386: PPUSH
20387: LD_INT 1
20389: PPUSH
20390: CALL_OW 3
20394: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
20395: LD_VAR 0 2
20399: PPUSH
20400: LD_VAR 0 3
20404: PPUSH
20405: CALL 20605 0 2
20409: PUSH
20410: LD_VAR 0 11
20414: PUSH
20415: EMPTY
20416: EQUAL
20417: OR
20418: IFFALSE 20363
// if not control in _control then
20420: LD_VAR 0 4
20424: PUSH
20425: LD_VAR 0 12
20429: IN
20430: NOT
20431: IFFALSE 20457
// control := _control [ rand ( 1 , _control ) ] ;
20433: LD_ADDR_VAR 0 4
20437: PUSH
20438: LD_VAR 0 12
20442: PUSH
20443: LD_INT 1
20445: PPUSH
20446: LD_VAR 0 12
20450: PPUSH
20451: CALL_OW 12
20455: ARRAY
20456: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
20457: LD_VAR 0 2
20461: PPUSH
20462: LD_VAR 0 5
20466: PPUSH
20467: CALL 20825 0 2
20471: NOT
20472: IFFALSE 20531
// repeat weapon := _weapon [ 1 ] ;
20474: LD_ADDR_VAR 0 5
20478: PUSH
20479: LD_VAR 0 10
20483: PUSH
20484: LD_INT 1
20486: ARRAY
20487: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
20488: LD_ADDR_VAR 0 10
20492: PUSH
20493: LD_VAR 0 10
20497: PPUSH
20498: LD_INT 1
20500: PPUSH
20501: CALL_OW 3
20505: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
20506: LD_VAR 0 2
20510: PPUSH
20511: LD_VAR 0 5
20515: PPUSH
20516: CALL 20825 0 2
20520: PUSH
20521: LD_VAR 0 10
20525: PUSH
20526: EMPTY
20527: EQUAL
20528: OR
20529: IFFALSE 20474
// result := [ ] ;
20531: LD_ADDR_VAR 0 6
20535: PUSH
20536: EMPTY
20537: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20538: LD_VAR 0 1
20542: PPUSH
20543: LD_VAR 0 2
20547: PPUSH
20548: LD_VAR 0 3
20552: PPUSH
20553: LD_VAR 0 4
20557: PPUSH
20558: LD_VAR 0 5
20562: PPUSH
20563: CALL_OW 448
20567: IFFALSE 20600
// result := [ chassis , engine , control , weapon ] ;
20569: LD_ADDR_VAR 0 6
20573: PUSH
20574: LD_VAR 0 2
20578: PUSH
20579: LD_VAR 0 3
20583: PUSH
20584: LD_VAR 0 4
20588: PUSH
20589: LD_VAR 0 5
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: LIST
20598: LIST
20599: ST_TO_ADDR
// end ;
20600: LD_VAR 0 6
20604: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
20605: LD_INT 0
20607: PPUSH
// if not chassis or not engine then
20608: LD_VAR 0 1
20612: NOT
20613: PUSH
20614: LD_VAR 0 2
20618: NOT
20619: OR
20620: IFFALSE 20624
// exit ;
20622: GO 20820
// case engine of engine_solar :
20624: LD_VAR 0 2
20628: PUSH
20629: LD_INT 2
20631: DOUBLE
20632: EQUAL
20633: IFTRUE 20637
20635: GO 20675
20637: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
20638: LD_ADDR_VAR 0 3
20642: PUSH
20643: LD_INT 11
20645: PUSH
20646: LD_INT 12
20648: PUSH
20649: LD_INT 13
20651: PUSH
20652: LD_INT 14
20654: PUSH
20655: LD_INT 1
20657: PUSH
20658: LD_INT 2
20660: PUSH
20661: LD_INT 3
20663: PUSH
20664: EMPTY
20665: LIST
20666: LIST
20667: LIST
20668: LIST
20669: LIST
20670: LIST
20671: LIST
20672: ST_TO_ADDR
20673: GO 20804
20675: LD_INT 1
20677: DOUBLE
20678: EQUAL
20679: IFTRUE 20683
20681: GO 20745
20683: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
20684: LD_ADDR_VAR 0 3
20688: PUSH
20689: LD_INT 11
20691: PUSH
20692: LD_INT 12
20694: PUSH
20695: LD_INT 13
20697: PUSH
20698: LD_INT 14
20700: PUSH
20701: LD_INT 1
20703: PUSH
20704: LD_INT 2
20706: PUSH
20707: LD_INT 3
20709: PUSH
20710: LD_INT 4
20712: PUSH
20713: LD_INT 5
20715: PUSH
20716: LD_INT 21
20718: PUSH
20719: LD_INT 23
20721: PUSH
20722: LD_INT 22
20724: PUSH
20725: LD_INT 24
20727: PUSH
20728: EMPTY
20729: LIST
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: LIST
20735: LIST
20736: LIST
20737: LIST
20738: LIST
20739: LIST
20740: LIST
20741: LIST
20742: ST_TO_ADDR
20743: GO 20804
20745: LD_INT 3
20747: DOUBLE
20748: EQUAL
20749: IFTRUE 20753
20751: GO 20803
20753: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20754: LD_ADDR_VAR 0 3
20758: PUSH
20759: LD_INT 13
20761: PUSH
20762: LD_INT 14
20764: PUSH
20765: LD_INT 2
20767: PUSH
20768: LD_INT 3
20770: PUSH
20771: LD_INT 4
20773: PUSH
20774: LD_INT 5
20776: PUSH
20777: LD_INT 21
20779: PUSH
20780: LD_INT 22
20782: PUSH
20783: LD_INT 23
20785: PUSH
20786: LD_INT 24
20788: PUSH
20789: EMPTY
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: ST_TO_ADDR
20801: GO 20804
20803: POP
// result := ( chassis in result ) ;
20804: LD_ADDR_VAR 0 3
20808: PUSH
20809: LD_VAR 0 1
20813: PUSH
20814: LD_VAR 0 3
20818: IN
20819: ST_TO_ADDR
// end ;
20820: LD_VAR 0 3
20824: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20825: LD_INT 0
20827: PPUSH
// if not chassis or not weapon then
20828: LD_VAR 0 1
20832: NOT
20833: PUSH
20834: LD_VAR 0 2
20838: NOT
20839: OR
20840: IFFALSE 20844
// exit ;
20842: GO 21870
// case weapon of us_machine_gun :
20844: LD_VAR 0 2
20848: PUSH
20849: LD_INT 2
20851: DOUBLE
20852: EQUAL
20853: IFTRUE 20857
20855: GO 20887
20857: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20858: LD_ADDR_VAR 0 3
20862: PUSH
20863: LD_INT 1
20865: PUSH
20866: LD_INT 2
20868: PUSH
20869: LD_INT 3
20871: PUSH
20872: LD_INT 4
20874: PUSH
20875: LD_INT 5
20877: PUSH
20878: EMPTY
20879: LIST
20880: LIST
20881: LIST
20882: LIST
20883: LIST
20884: ST_TO_ADDR
20885: GO 21854
20887: LD_INT 3
20889: DOUBLE
20890: EQUAL
20891: IFTRUE 20895
20893: GO 20925
20895: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20896: LD_ADDR_VAR 0 3
20900: PUSH
20901: LD_INT 1
20903: PUSH
20904: LD_INT 2
20906: PUSH
20907: LD_INT 3
20909: PUSH
20910: LD_INT 4
20912: PUSH
20913: LD_INT 5
20915: PUSH
20916: EMPTY
20917: LIST
20918: LIST
20919: LIST
20920: LIST
20921: LIST
20922: ST_TO_ADDR
20923: GO 21854
20925: LD_INT 11
20927: DOUBLE
20928: EQUAL
20929: IFTRUE 20933
20931: GO 20963
20933: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20934: LD_ADDR_VAR 0 3
20938: PUSH
20939: LD_INT 1
20941: PUSH
20942: LD_INT 2
20944: PUSH
20945: LD_INT 3
20947: PUSH
20948: LD_INT 4
20950: PUSH
20951: LD_INT 5
20953: PUSH
20954: EMPTY
20955: LIST
20956: LIST
20957: LIST
20958: LIST
20959: LIST
20960: ST_TO_ADDR
20961: GO 21854
20963: LD_INT 4
20965: DOUBLE
20966: EQUAL
20967: IFTRUE 20971
20969: GO 20997
20971: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20972: LD_ADDR_VAR 0 3
20976: PUSH
20977: LD_INT 2
20979: PUSH
20980: LD_INT 3
20982: PUSH
20983: LD_INT 4
20985: PUSH
20986: LD_INT 5
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: LIST
20993: LIST
20994: ST_TO_ADDR
20995: GO 21854
20997: LD_INT 5
20999: DOUBLE
21000: EQUAL
21001: IFTRUE 21005
21003: GO 21031
21005: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
21006: LD_ADDR_VAR 0 3
21010: PUSH
21011: LD_INT 2
21013: PUSH
21014: LD_INT 3
21016: PUSH
21017: LD_INT 4
21019: PUSH
21020: LD_INT 5
21022: PUSH
21023: EMPTY
21024: LIST
21025: LIST
21026: LIST
21027: LIST
21028: ST_TO_ADDR
21029: GO 21854
21031: LD_INT 9
21033: DOUBLE
21034: EQUAL
21035: IFTRUE 21039
21037: GO 21065
21039: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
21040: LD_ADDR_VAR 0 3
21044: PUSH
21045: LD_INT 2
21047: PUSH
21048: LD_INT 3
21050: PUSH
21051: LD_INT 4
21053: PUSH
21054: LD_INT 5
21056: PUSH
21057: EMPTY
21058: LIST
21059: LIST
21060: LIST
21061: LIST
21062: ST_TO_ADDR
21063: GO 21854
21065: LD_INT 7
21067: DOUBLE
21068: EQUAL
21069: IFTRUE 21073
21071: GO 21099
21073: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
21074: LD_ADDR_VAR 0 3
21078: PUSH
21079: LD_INT 2
21081: PUSH
21082: LD_INT 3
21084: PUSH
21085: LD_INT 4
21087: PUSH
21088: LD_INT 5
21090: PUSH
21091: EMPTY
21092: LIST
21093: LIST
21094: LIST
21095: LIST
21096: ST_TO_ADDR
21097: GO 21854
21099: LD_INT 12
21101: DOUBLE
21102: EQUAL
21103: IFTRUE 21107
21105: GO 21133
21107: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
21108: LD_ADDR_VAR 0 3
21112: PUSH
21113: LD_INT 2
21115: PUSH
21116: LD_INT 3
21118: PUSH
21119: LD_INT 4
21121: PUSH
21122: LD_INT 5
21124: PUSH
21125: EMPTY
21126: LIST
21127: LIST
21128: LIST
21129: LIST
21130: ST_TO_ADDR
21131: GO 21854
21133: LD_INT 13
21135: DOUBLE
21136: EQUAL
21137: IFTRUE 21141
21139: GO 21167
21141: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
21142: LD_ADDR_VAR 0 3
21146: PUSH
21147: LD_INT 2
21149: PUSH
21150: LD_INT 3
21152: PUSH
21153: LD_INT 4
21155: PUSH
21156: LD_INT 5
21158: PUSH
21159: EMPTY
21160: LIST
21161: LIST
21162: LIST
21163: LIST
21164: ST_TO_ADDR
21165: GO 21854
21167: LD_INT 14
21169: DOUBLE
21170: EQUAL
21171: IFTRUE 21175
21173: GO 21193
21175: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
21176: LD_ADDR_VAR 0 3
21180: PUSH
21181: LD_INT 4
21183: PUSH
21184: LD_INT 5
21186: PUSH
21187: EMPTY
21188: LIST
21189: LIST
21190: ST_TO_ADDR
21191: GO 21854
21193: LD_INT 6
21195: DOUBLE
21196: EQUAL
21197: IFTRUE 21201
21199: GO 21219
21201: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
21202: LD_ADDR_VAR 0 3
21206: PUSH
21207: LD_INT 4
21209: PUSH
21210: LD_INT 5
21212: PUSH
21213: EMPTY
21214: LIST
21215: LIST
21216: ST_TO_ADDR
21217: GO 21854
21219: LD_INT 10
21221: DOUBLE
21222: EQUAL
21223: IFTRUE 21227
21225: GO 21245
21227: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
21228: LD_ADDR_VAR 0 3
21232: PUSH
21233: LD_INT 4
21235: PUSH
21236: LD_INT 5
21238: PUSH
21239: EMPTY
21240: LIST
21241: LIST
21242: ST_TO_ADDR
21243: GO 21854
21245: LD_INT 22
21247: DOUBLE
21248: EQUAL
21249: IFTRUE 21253
21251: GO 21279
21253: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
21254: LD_ADDR_VAR 0 3
21258: PUSH
21259: LD_INT 11
21261: PUSH
21262: LD_INT 12
21264: PUSH
21265: LD_INT 13
21267: PUSH
21268: LD_INT 14
21270: PUSH
21271: EMPTY
21272: LIST
21273: LIST
21274: LIST
21275: LIST
21276: ST_TO_ADDR
21277: GO 21854
21279: LD_INT 23
21281: DOUBLE
21282: EQUAL
21283: IFTRUE 21287
21285: GO 21313
21287: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
21288: LD_ADDR_VAR 0 3
21292: PUSH
21293: LD_INT 11
21295: PUSH
21296: LD_INT 12
21298: PUSH
21299: LD_INT 13
21301: PUSH
21302: LD_INT 14
21304: PUSH
21305: EMPTY
21306: LIST
21307: LIST
21308: LIST
21309: LIST
21310: ST_TO_ADDR
21311: GO 21854
21313: LD_INT 24
21315: DOUBLE
21316: EQUAL
21317: IFTRUE 21321
21319: GO 21347
21321: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
21322: LD_ADDR_VAR 0 3
21326: PUSH
21327: LD_INT 11
21329: PUSH
21330: LD_INT 12
21332: PUSH
21333: LD_INT 13
21335: PUSH
21336: LD_INT 14
21338: PUSH
21339: EMPTY
21340: LIST
21341: LIST
21342: LIST
21343: LIST
21344: ST_TO_ADDR
21345: GO 21854
21347: LD_INT 30
21349: DOUBLE
21350: EQUAL
21351: IFTRUE 21355
21353: GO 21381
21355: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
21356: LD_ADDR_VAR 0 3
21360: PUSH
21361: LD_INT 11
21363: PUSH
21364: LD_INT 12
21366: PUSH
21367: LD_INT 13
21369: PUSH
21370: LD_INT 14
21372: PUSH
21373: EMPTY
21374: LIST
21375: LIST
21376: LIST
21377: LIST
21378: ST_TO_ADDR
21379: GO 21854
21381: LD_INT 25
21383: DOUBLE
21384: EQUAL
21385: IFTRUE 21389
21387: GO 21407
21389: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
21390: LD_ADDR_VAR 0 3
21394: PUSH
21395: LD_INT 13
21397: PUSH
21398: LD_INT 14
21400: PUSH
21401: EMPTY
21402: LIST
21403: LIST
21404: ST_TO_ADDR
21405: GO 21854
21407: LD_INT 27
21409: DOUBLE
21410: EQUAL
21411: IFTRUE 21415
21413: GO 21433
21415: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
21416: LD_ADDR_VAR 0 3
21420: PUSH
21421: LD_INT 13
21423: PUSH
21424: LD_INT 14
21426: PUSH
21427: EMPTY
21428: LIST
21429: LIST
21430: ST_TO_ADDR
21431: GO 21854
21433: LD_INT 28
21435: DOUBLE
21436: EQUAL
21437: IFTRUE 21441
21439: GO 21459
21441: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
21442: LD_ADDR_VAR 0 3
21446: PUSH
21447: LD_INT 13
21449: PUSH
21450: LD_INT 14
21452: PUSH
21453: EMPTY
21454: LIST
21455: LIST
21456: ST_TO_ADDR
21457: GO 21854
21459: LD_INT 29
21461: DOUBLE
21462: EQUAL
21463: IFTRUE 21467
21465: GO 21485
21467: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
21468: LD_ADDR_VAR 0 3
21472: PUSH
21473: LD_INT 13
21475: PUSH
21476: LD_INT 14
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: ST_TO_ADDR
21483: GO 21854
21485: LD_INT 31
21487: DOUBLE
21488: EQUAL
21489: IFTRUE 21493
21491: GO 21511
21493: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
21494: LD_ADDR_VAR 0 3
21498: PUSH
21499: LD_INT 13
21501: PUSH
21502: LD_INT 14
21504: PUSH
21505: EMPTY
21506: LIST
21507: LIST
21508: ST_TO_ADDR
21509: GO 21854
21511: LD_INT 26
21513: DOUBLE
21514: EQUAL
21515: IFTRUE 21519
21517: GO 21537
21519: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
21520: LD_ADDR_VAR 0 3
21524: PUSH
21525: LD_INT 13
21527: PUSH
21528: LD_INT 14
21530: PUSH
21531: EMPTY
21532: LIST
21533: LIST
21534: ST_TO_ADDR
21535: GO 21854
21537: LD_INT 42
21539: DOUBLE
21540: EQUAL
21541: IFTRUE 21545
21543: GO 21571
21545: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
21546: LD_ADDR_VAR 0 3
21550: PUSH
21551: LD_INT 21
21553: PUSH
21554: LD_INT 22
21556: PUSH
21557: LD_INT 23
21559: PUSH
21560: LD_INT 24
21562: PUSH
21563: EMPTY
21564: LIST
21565: LIST
21566: LIST
21567: LIST
21568: ST_TO_ADDR
21569: GO 21854
21571: LD_INT 43
21573: DOUBLE
21574: EQUAL
21575: IFTRUE 21579
21577: GO 21605
21579: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
21580: LD_ADDR_VAR 0 3
21584: PUSH
21585: LD_INT 21
21587: PUSH
21588: LD_INT 22
21590: PUSH
21591: LD_INT 23
21593: PUSH
21594: LD_INT 24
21596: PUSH
21597: EMPTY
21598: LIST
21599: LIST
21600: LIST
21601: LIST
21602: ST_TO_ADDR
21603: GO 21854
21605: LD_INT 44
21607: DOUBLE
21608: EQUAL
21609: IFTRUE 21613
21611: GO 21639
21613: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
21614: LD_ADDR_VAR 0 3
21618: PUSH
21619: LD_INT 21
21621: PUSH
21622: LD_INT 22
21624: PUSH
21625: LD_INT 23
21627: PUSH
21628: LD_INT 24
21630: PUSH
21631: EMPTY
21632: LIST
21633: LIST
21634: LIST
21635: LIST
21636: ST_TO_ADDR
21637: GO 21854
21639: LD_INT 45
21641: DOUBLE
21642: EQUAL
21643: IFTRUE 21647
21645: GO 21673
21647: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
21648: LD_ADDR_VAR 0 3
21652: PUSH
21653: LD_INT 21
21655: PUSH
21656: LD_INT 22
21658: PUSH
21659: LD_INT 23
21661: PUSH
21662: LD_INT 24
21664: PUSH
21665: EMPTY
21666: LIST
21667: LIST
21668: LIST
21669: LIST
21670: ST_TO_ADDR
21671: GO 21854
21673: LD_INT 49
21675: DOUBLE
21676: EQUAL
21677: IFTRUE 21681
21679: GO 21707
21681: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
21682: LD_ADDR_VAR 0 3
21686: PUSH
21687: LD_INT 21
21689: PUSH
21690: LD_INT 22
21692: PUSH
21693: LD_INT 23
21695: PUSH
21696: LD_INT 24
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: LIST
21703: LIST
21704: ST_TO_ADDR
21705: GO 21854
21707: LD_INT 51
21709: DOUBLE
21710: EQUAL
21711: IFTRUE 21715
21713: GO 21741
21715: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
21716: LD_ADDR_VAR 0 3
21720: PUSH
21721: LD_INT 21
21723: PUSH
21724: LD_INT 22
21726: PUSH
21727: LD_INT 23
21729: PUSH
21730: LD_INT 24
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: LIST
21737: LIST
21738: ST_TO_ADDR
21739: GO 21854
21741: LD_INT 52
21743: DOUBLE
21744: EQUAL
21745: IFTRUE 21749
21747: GO 21775
21749: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
21750: LD_ADDR_VAR 0 3
21754: PUSH
21755: LD_INT 21
21757: PUSH
21758: LD_INT 22
21760: PUSH
21761: LD_INT 23
21763: PUSH
21764: LD_INT 24
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: ST_TO_ADDR
21773: GO 21854
21775: LD_INT 53
21777: DOUBLE
21778: EQUAL
21779: IFTRUE 21783
21781: GO 21801
21783: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
21784: LD_ADDR_VAR 0 3
21788: PUSH
21789: LD_INT 23
21791: PUSH
21792: LD_INT 24
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: ST_TO_ADDR
21799: GO 21854
21801: LD_INT 46
21803: DOUBLE
21804: EQUAL
21805: IFTRUE 21809
21807: GO 21827
21809: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21810: LD_ADDR_VAR 0 3
21814: PUSH
21815: LD_INT 23
21817: PUSH
21818: LD_INT 24
21820: PUSH
21821: EMPTY
21822: LIST
21823: LIST
21824: ST_TO_ADDR
21825: GO 21854
21827: LD_INT 47
21829: DOUBLE
21830: EQUAL
21831: IFTRUE 21835
21833: GO 21853
21835: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21836: LD_ADDR_VAR 0 3
21840: PUSH
21841: LD_INT 23
21843: PUSH
21844: LD_INT 24
21846: PUSH
21847: EMPTY
21848: LIST
21849: LIST
21850: ST_TO_ADDR
21851: GO 21854
21853: POP
// result := ( chassis in result ) ;
21854: LD_ADDR_VAR 0 3
21858: PUSH
21859: LD_VAR 0 1
21863: PUSH
21864: LD_VAR 0 3
21868: IN
21869: ST_TO_ADDR
// end ;
21870: LD_VAR 0 3
21874: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21875: LD_INT 0
21877: PPUSH
21878: PPUSH
21879: PPUSH
21880: PPUSH
21881: PPUSH
21882: PPUSH
21883: PPUSH
// result := array ;
21884: LD_ADDR_VAR 0 5
21888: PUSH
21889: LD_VAR 0 1
21893: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21894: LD_VAR 0 1
21898: NOT
21899: PUSH
21900: LD_VAR 0 2
21904: NOT
21905: OR
21906: PUSH
21907: LD_VAR 0 3
21911: NOT
21912: OR
21913: PUSH
21914: LD_VAR 0 2
21918: PUSH
21919: LD_VAR 0 1
21923: GREATER
21924: OR
21925: PUSH
21926: LD_VAR 0 3
21930: PUSH
21931: LD_VAR 0 1
21935: GREATER
21936: OR
21937: IFFALSE 21941
// exit ;
21939: GO 22237
// if direction then
21941: LD_VAR 0 4
21945: IFFALSE 22009
// begin d := 1 ;
21947: LD_ADDR_VAR 0 9
21951: PUSH
21952: LD_INT 1
21954: ST_TO_ADDR
// if i_from > i_to then
21955: LD_VAR 0 2
21959: PUSH
21960: LD_VAR 0 3
21964: GREATER
21965: IFFALSE 21991
// length := ( array - i_from ) + i_to else
21967: LD_ADDR_VAR 0 11
21971: PUSH
21972: LD_VAR 0 1
21976: PUSH
21977: LD_VAR 0 2
21981: MINUS
21982: PUSH
21983: LD_VAR 0 3
21987: PLUS
21988: ST_TO_ADDR
21989: GO 22007
// length := i_to - i_from ;
21991: LD_ADDR_VAR 0 11
21995: PUSH
21996: LD_VAR 0 3
22000: PUSH
22001: LD_VAR 0 2
22005: MINUS
22006: ST_TO_ADDR
// end else
22007: GO 22070
// begin d := - 1 ;
22009: LD_ADDR_VAR 0 9
22013: PUSH
22014: LD_INT 1
22016: NEG
22017: ST_TO_ADDR
// if i_from > i_to then
22018: LD_VAR 0 2
22022: PUSH
22023: LD_VAR 0 3
22027: GREATER
22028: IFFALSE 22048
// length := i_from - i_to else
22030: LD_ADDR_VAR 0 11
22034: PUSH
22035: LD_VAR 0 2
22039: PUSH
22040: LD_VAR 0 3
22044: MINUS
22045: ST_TO_ADDR
22046: GO 22070
// length := ( array - i_to ) + i_from ;
22048: LD_ADDR_VAR 0 11
22052: PUSH
22053: LD_VAR 0 1
22057: PUSH
22058: LD_VAR 0 3
22062: MINUS
22063: PUSH
22064: LD_VAR 0 2
22068: PLUS
22069: ST_TO_ADDR
// end ; if not length then
22070: LD_VAR 0 11
22074: NOT
22075: IFFALSE 22079
// exit ;
22077: GO 22237
// tmp := array ;
22079: LD_ADDR_VAR 0 10
22083: PUSH
22084: LD_VAR 0 1
22088: ST_TO_ADDR
// for i = 1 to length do
22089: LD_ADDR_VAR 0 6
22093: PUSH
22094: DOUBLE
22095: LD_INT 1
22097: DEC
22098: ST_TO_ADDR
22099: LD_VAR 0 11
22103: PUSH
22104: FOR_TO
22105: IFFALSE 22225
// begin for j = 1 to array do
22107: LD_ADDR_VAR 0 7
22111: PUSH
22112: DOUBLE
22113: LD_INT 1
22115: DEC
22116: ST_TO_ADDR
22117: LD_VAR 0 1
22121: PUSH
22122: FOR_TO
22123: IFFALSE 22211
// begin k := j + d ;
22125: LD_ADDR_VAR 0 8
22129: PUSH
22130: LD_VAR 0 7
22134: PUSH
22135: LD_VAR 0 9
22139: PLUS
22140: ST_TO_ADDR
// if k > array then
22141: LD_VAR 0 8
22145: PUSH
22146: LD_VAR 0 1
22150: GREATER
22151: IFFALSE 22161
// k := 1 ;
22153: LD_ADDR_VAR 0 8
22157: PUSH
22158: LD_INT 1
22160: ST_TO_ADDR
// if not k then
22161: LD_VAR 0 8
22165: NOT
22166: IFFALSE 22178
// k := array ;
22168: LD_ADDR_VAR 0 8
22172: PUSH
22173: LD_VAR 0 1
22177: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
22178: LD_ADDR_VAR 0 10
22182: PUSH
22183: LD_VAR 0 10
22187: PPUSH
22188: LD_VAR 0 8
22192: PPUSH
22193: LD_VAR 0 1
22197: PUSH
22198: LD_VAR 0 7
22202: ARRAY
22203: PPUSH
22204: CALL_OW 1
22208: ST_TO_ADDR
// end ;
22209: GO 22122
22211: POP
22212: POP
// array := tmp ;
22213: LD_ADDR_VAR 0 1
22217: PUSH
22218: LD_VAR 0 10
22222: ST_TO_ADDR
// end ;
22223: GO 22104
22225: POP
22226: POP
// result := array ;
22227: LD_ADDR_VAR 0 5
22231: PUSH
22232: LD_VAR 0 1
22236: ST_TO_ADDR
// end ;
22237: LD_VAR 0 5
22241: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
22242: LD_INT 0
22244: PPUSH
22245: PPUSH
// result := 0 ;
22246: LD_ADDR_VAR 0 3
22250: PUSH
22251: LD_INT 0
22253: ST_TO_ADDR
// if not array or not value in array then
22254: LD_VAR 0 1
22258: NOT
22259: PUSH
22260: LD_VAR 0 2
22264: PUSH
22265: LD_VAR 0 1
22269: IN
22270: NOT
22271: OR
22272: IFFALSE 22276
// exit ;
22274: GO 22330
// for i = 1 to array do
22276: LD_ADDR_VAR 0 4
22280: PUSH
22281: DOUBLE
22282: LD_INT 1
22284: DEC
22285: ST_TO_ADDR
22286: LD_VAR 0 1
22290: PUSH
22291: FOR_TO
22292: IFFALSE 22328
// if value = array [ i ] then
22294: LD_VAR 0 2
22298: PUSH
22299: LD_VAR 0 1
22303: PUSH
22304: LD_VAR 0 4
22308: ARRAY
22309: EQUAL
22310: IFFALSE 22326
// begin result := i ;
22312: LD_ADDR_VAR 0 3
22316: PUSH
22317: LD_VAR 0 4
22321: ST_TO_ADDR
// exit ;
22322: POP
22323: POP
22324: GO 22330
// end ;
22326: GO 22291
22328: POP
22329: POP
// end ;
22330: LD_VAR 0 3
22334: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
22335: LD_INT 0
22337: PPUSH
// vc_chassis := chassis ;
22338: LD_ADDR_OWVAR 37
22342: PUSH
22343: LD_VAR 0 1
22347: ST_TO_ADDR
// vc_engine := engine ;
22348: LD_ADDR_OWVAR 39
22352: PUSH
22353: LD_VAR 0 2
22357: ST_TO_ADDR
// vc_control := control ;
22358: LD_ADDR_OWVAR 38
22362: PUSH
22363: LD_VAR 0 3
22367: ST_TO_ADDR
// vc_weapon := weapon ;
22368: LD_ADDR_OWVAR 40
22372: PUSH
22373: LD_VAR 0 4
22377: ST_TO_ADDR
// vc_fuel_battery := fuel ;
22378: LD_ADDR_OWVAR 41
22382: PUSH
22383: LD_VAR 0 5
22387: ST_TO_ADDR
// end ;
22388: LD_VAR 0 6
22392: RET
// export function WantPlant ( unit ) ; var task ; begin
22393: LD_INT 0
22395: PPUSH
22396: PPUSH
// result := false ;
22397: LD_ADDR_VAR 0 2
22401: PUSH
22402: LD_INT 0
22404: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
22405: LD_ADDR_VAR 0 3
22409: PUSH
22410: LD_VAR 0 1
22414: PPUSH
22415: CALL_OW 437
22419: ST_TO_ADDR
// if task then
22420: LD_VAR 0 3
22424: IFFALSE 22452
// if task [ 1 ] [ 1 ] = p then
22426: LD_VAR 0 3
22430: PUSH
22431: LD_INT 1
22433: ARRAY
22434: PUSH
22435: LD_INT 1
22437: ARRAY
22438: PUSH
22439: LD_STRING p
22441: EQUAL
22442: IFFALSE 22452
// result := true ;
22444: LD_ADDR_VAR 0 2
22448: PUSH
22449: LD_INT 1
22451: ST_TO_ADDR
// end ;
22452: LD_VAR 0 2
22456: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
22457: LD_INT 0
22459: PPUSH
22460: PPUSH
22461: PPUSH
22462: PPUSH
// if pos < 1 then
22463: LD_VAR 0 2
22467: PUSH
22468: LD_INT 1
22470: LESS
22471: IFFALSE 22475
// exit ;
22473: GO 22778
// if pos = 1 then
22475: LD_VAR 0 2
22479: PUSH
22480: LD_INT 1
22482: EQUAL
22483: IFFALSE 22516
// result := Replace ( arr , pos [ 1 ] , value ) else
22485: LD_ADDR_VAR 0 4
22489: PUSH
22490: LD_VAR 0 1
22494: PPUSH
22495: LD_VAR 0 2
22499: PUSH
22500: LD_INT 1
22502: ARRAY
22503: PPUSH
22504: LD_VAR 0 3
22508: PPUSH
22509: CALL_OW 1
22513: ST_TO_ADDR
22514: GO 22778
// begin tmp := arr ;
22516: LD_ADDR_VAR 0 6
22520: PUSH
22521: LD_VAR 0 1
22525: ST_TO_ADDR
// s_arr := [ tmp ] ;
22526: LD_ADDR_VAR 0 7
22530: PUSH
22531: LD_VAR 0 6
22535: PUSH
22536: EMPTY
22537: LIST
22538: ST_TO_ADDR
// for i = 1 to pos - 1 do
22539: LD_ADDR_VAR 0 5
22543: PUSH
22544: DOUBLE
22545: LD_INT 1
22547: DEC
22548: ST_TO_ADDR
22549: LD_VAR 0 2
22553: PUSH
22554: LD_INT 1
22556: MINUS
22557: PUSH
22558: FOR_TO
22559: IFFALSE 22604
// begin tmp := tmp [ pos [ i ] ] ;
22561: LD_ADDR_VAR 0 6
22565: PUSH
22566: LD_VAR 0 6
22570: PUSH
22571: LD_VAR 0 2
22575: PUSH
22576: LD_VAR 0 5
22580: ARRAY
22581: ARRAY
22582: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
22583: LD_ADDR_VAR 0 7
22587: PUSH
22588: LD_VAR 0 7
22592: PUSH
22593: LD_VAR 0 6
22597: PUSH
22598: EMPTY
22599: LIST
22600: ADD
22601: ST_TO_ADDR
// end ;
22602: GO 22558
22604: POP
22605: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
22606: LD_ADDR_VAR 0 6
22610: PUSH
22611: LD_VAR 0 6
22615: PPUSH
22616: LD_VAR 0 2
22620: PUSH
22621: LD_VAR 0 2
22625: ARRAY
22626: PPUSH
22627: LD_VAR 0 3
22631: PPUSH
22632: CALL_OW 1
22636: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
22637: LD_ADDR_VAR 0 7
22641: PUSH
22642: LD_VAR 0 7
22646: PPUSH
22647: LD_VAR 0 7
22651: PPUSH
22652: LD_VAR 0 6
22656: PPUSH
22657: CALL_OW 1
22661: ST_TO_ADDR
// for i = s_arr downto 2 do
22662: LD_ADDR_VAR 0 5
22666: PUSH
22667: DOUBLE
22668: LD_VAR 0 7
22672: INC
22673: ST_TO_ADDR
22674: LD_INT 2
22676: PUSH
22677: FOR_DOWNTO
22678: IFFALSE 22762
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
22680: LD_ADDR_VAR 0 6
22684: PUSH
22685: LD_VAR 0 7
22689: PUSH
22690: LD_VAR 0 5
22694: PUSH
22695: LD_INT 1
22697: MINUS
22698: ARRAY
22699: PPUSH
22700: LD_VAR 0 2
22704: PUSH
22705: LD_VAR 0 5
22709: PUSH
22710: LD_INT 1
22712: MINUS
22713: ARRAY
22714: PPUSH
22715: LD_VAR 0 7
22719: PUSH
22720: LD_VAR 0 5
22724: ARRAY
22725: PPUSH
22726: CALL_OW 1
22730: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
22731: LD_ADDR_VAR 0 7
22735: PUSH
22736: LD_VAR 0 7
22740: PPUSH
22741: LD_VAR 0 5
22745: PUSH
22746: LD_INT 1
22748: MINUS
22749: PPUSH
22750: LD_VAR 0 6
22754: PPUSH
22755: CALL_OW 1
22759: ST_TO_ADDR
// end ;
22760: GO 22677
22762: POP
22763: POP
// result := s_arr [ 1 ] ;
22764: LD_ADDR_VAR 0 4
22768: PUSH
22769: LD_VAR 0 7
22773: PUSH
22774: LD_INT 1
22776: ARRAY
22777: ST_TO_ADDR
// end ; end ;
22778: LD_VAR 0 4
22782: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
22783: LD_INT 0
22785: PPUSH
22786: PPUSH
// if not list then
22787: LD_VAR 0 1
22791: NOT
22792: IFFALSE 22796
// exit ;
22794: GO 22887
// i := list [ pos1 ] ;
22796: LD_ADDR_VAR 0 5
22800: PUSH
22801: LD_VAR 0 1
22805: PUSH
22806: LD_VAR 0 2
22810: ARRAY
22811: ST_TO_ADDR
// if not i then
22812: LD_VAR 0 5
22816: NOT
22817: IFFALSE 22821
// exit ;
22819: GO 22887
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22821: LD_ADDR_VAR 0 1
22825: PUSH
22826: LD_VAR 0 1
22830: PPUSH
22831: LD_VAR 0 2
22835: PPUSH
22836: LD_VAR 0 1
22840: PUSH
22841: LD_VAR 0 3
22845: ARRAY
22846: PPUSH
22847: CALL_OW 1
22851: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22852: LD_ADDR_VAR 0 1
22856: PUSH
22857: LD_VAR 0 1
22861: PPUSH
22862: LD_VAR 0 3
22866: PPUSH
22867: LD_VAR 0 5
22871: PPUSH
22872: CALL_OW 1
22876: ST_TO_ADDR
// result := list ;
22877: LD_ADDR_VAR 0 4
22881: PUSH
22882: LD_VAR 0 1
22886: ST_TO_ADDR
// end ;
22887: LD_VAR 0 4
22891: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22892: LD_INT 0
22894: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22895: LD_ADDR_VAR 0 5
22899: PUSH
22900: LD_VAR 0 1
22904: PPUSH
22905: CALL_OW 250
22909: PPUSH
22910: LD_VAR 0 1
22914: PPUSH
22915: CALL_OW 251
22919: PPUSH
22920: LD_VAR 0 2
22924: PPUSH
22925: LD_VAR 0 3
22929: PPUSH
22930: LD_VAR 0 4
22934: PPUSH
22935: CALL 22945 0 5
22939: ST_TO_ADDR
// end ;
22940: LD_VAR 0 5
22944: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22945: LD_INT 0
22947: PPUSH
22948: PPUSH
22949: PPUSH
22950: PPUSH
// if not list then
22951: LD_VAR 0 3
22955: NOT
22956: IFFALSE 22960
// exit ;
22958: GO 23348
// result := [ ] ;
22960: LD_ADDR_VAR 0 6
22964: PUSH
22965: EMPTY
22966: ST_TO_ADDR
// for i in list do
22967: LD_ADDR_VAR 0 7
22971: PUSH
22972: LD_VAR 0 3
22976: PUSH
22977: FOR_IN
22978: IFFALSE 23180
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22980: LD_ADDR_VAR 0 9
22984: PUSH
22985: LD_VAR 0 7
22989: PPUSH
22990: LD_VAR 0 1
22994: PPUSH
22995: LD_VAR 0 2
22999: PPUSH
23000: CALL_OW 297
23004: ST_TO_ADDR
// if not result then
23005: LD_VAR 0 6
23009: NOT
23010: IFFALSE 23036
// result := [ [ i , tmp ] ] else
23012: LD_ADDR_VAR 0 6
23016: PUSH
23017: LD_VAR 0 7
23021: PUSH
23022: LD_VAR 0 9
23026: PUSH
23027: EMPTY
23028: LIST
23029: LIST
23030: PUSH
23031: EMPTY
23032: LIST
23033: ST_TO_ADDR
23034: GO 23178
// begin if result [ result ] [ 2 ] < tmp then
23036: LD_VAR 0 6
23040: PUSH
23041: LD_VAR 0 6
23045: ARRAY
23046: PUSH
23047: LD_INT 2
23049: ARRAY
23050: PUSH
23051: LD_VAR 0 9
23055: LESS
23056: IFFALSE 23098
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
23058: LD_ADDR_VAR 0 6
23062: PUSH
23063: LD_VAR 0 6
23067: PPUSH
23068: LD_VAR 0 6
23072: PUSH
23073: LD_INT 1
23075: PLUS
23076: PPUSH
23077: LD_VAR 0 7
23081: PUSH
23082: LD_VAR 0 9
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: PPUSH
23091: CALL_OW 2
23095: ST_TO_ADDR
23096: GO 23178
// for j = 1 to result do
23098: LD_ADDR_VAR 0 8
23102: PUSH
23103: DOUBLE
23104: LD_INT 1
23106: DEC
23107: ST_TO_ADDR
23108: LD_VAR 0 6
23112: PUSH
23113: FOR_TO
23114: IFFALSE 23176
// begin if tmp < result [ j ] [ 2 ] then
23116: LD_VAR 0 9
23120: PUSH
23121: LD_VAR 0 6
23125: PUSH
23126: LD_VAR 0 8
23130: ARRAY
23131: PUSH
23132: LD_INT 2
23134: ARRAY
23135: LESS
23136: IFFALSE 23174
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23138: LD_ADDR_VAR 0 6
23142: PUSH
23143: LD_VAR 0 6
23147: PPUSH
23148: LD_VAR 0 8
23152: PPUSH
23153: LD_VAR 0 7
23157: PUSH
23158: LD_VAR 0 9
23162: PUSH
23163: EMPTY
23164: LIST
23165: LIST
23166: PPUSH
23167: CALL_OW 2
23171: ST_TO_ADDR
// break ;
23172: GO 23176
// end ; end ;
23174: GO 23113
23176: POP
23177: POP
// end ; end ;
23178: GO 22977
23180: POP
23181: POP
// if result and not asc then
23182: LD_VAR 0 6
23186: PUSH
23187: LD_VAR 0 4
23191: NOT
23192: AND
23193: IFFALSE 23268
// begin tmp := result ;
23195: LD_ADDR_VAR 0 9
23199: PUSH
23200: LD_VAR 0 6
23204: ST_TO_ADDR
// for i = tmp downto 1 do
23205: LD_ADDR_VAR 0 7
23209: PUSH
23210: DOUBLE
23211: LD_VAR 0 9
23215: INC
23216: ST_TO_ADDR
23217: LD_INT 1
23219: PUSH
23220: FOR_DOWNTO
23221: IFFALSE 23266
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
23223: LD_ADDR_VAR 0 6
23227: PUSH
23228: LD_VAR 0 6
23232: PPUSH
23233: LD_VAR 0 9
23237: PUSH
23238: LD_VAR 0 7
23242: MINUS
23243: PUSH
23244: LD_INT 1
23246: PLUS
23247: PPUSH
23248: LD_VAR 0 9
23252: PUSH
23253: LD_VAR 0 7
23257: ARRAY
23258: PPUSH
23259: CALL_OW 1
23263: ST_TO_ADDR
23264: GO 23220
23266: POP
23267: POP
// end ; tmp := [ ] ;
23268: LD_ADDR_VAR 0 9
23272: PUSH
23273: EMPTY
23274: ST_TO_ADDR
// if mode then
23275: LD_VAR 0 5
23279: IFFALSE 23348
// begin for i = 1 to result do
23281: LD_ADDR_VAR 0 7
23285: PUSH
23286: DOUBLE
23287: LD_INT 1
23289: DEC
23290: ST_TO_ADDR
23291: LD_VAR 0 6
23295: PUSH
23296: FOR_TO
23297: IFFALSE 23336
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
23299: LD_ADDR_VAR 0 9
23303: PUSH
23304: LD_VAR 0 9
23308: PPUSH
23309: LD_VAR 0 7
23313: PPUSH
23314: LD_VAR 0 6
23318: PUSH
23319: LD_VAR 0 7
23323: ARRAY
23324: PUSH
23325: LD_INT 1
23327: ARRAY
23328: PPUSH
23329: CALL_OW 1
23333: ST_TO_ADDR
23334: GO 23296
23336: POP
23337: POP
// result := tmp ;
23338: LD_ADDR_VAR 0 6
23342: PUSH
23343: LD_VAR 0 9
23347: ST_TO_ADDR
// end ; end ;
23348: LD_VAR 0 6
23352: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
23353: LD_INT 0
23355: PPUSH
23356: PPUSH
23357: PPUSH
23358: PPUSH
23359: PPUSH
23360: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
23361: LD_ADDR_VAR 0 5
23365: PUSH
23366: LD_INT 0
23368: PUSH
23369: LD_INT 0
23371: PUSH
23372: LD_INT 0
23374: PUSH
23375: EMPTY
23376: PUSH
23377: EMPTY
23378: LIST
23379: LIST
23380: LIST
23381: LIST
23382: ST_TO_ADDR
// if not x or not y then
23383: LD_VAR 0 2
23387: NOT
23388: PUSH
23389: LD_VAR 0 3
23393: NOT
23394: OR
23395: IFFALSE 23399
// exit ;
23397: GO 25045
// if not range then
23399: LD_VAR 0 4
23403: NOT
23404: IFFALSE 23414
// range := 10 ;
23406: LD_ADDR_VAR 0 4
23410: PUSH
23411: LD_INT 10
23413: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
23414: LD_ADDR_VAR 0 8
23418: PUSH
23419: LD_INT 81
23421: PUSH
23422: LD_VAR 0 1
23426: PUSH
23427: EMPTY
23428: LIST
23429: LIST
23430: PUSH
23431: LD_INT 92
23433: PUSH
23434: LD_VAR 0 2
23438: PUSH
23439: LD_VAR 0 3
23443: PUSH
23444: LD_VAR 0 4
23448: PUSH
23449: EMPTY
23450: LIST
23451: LIST
23452: LIST
23453: LIST
23454: PUSH
23455: LD_INT 3
23457: PUSH
23458: LD_INT 21
23460: PUSH
23461: LD_INT 3
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: PUSH
23468: EMPTY
23469: LIST
23470: LIST
23471: PUSH
23472: EMPTY
23473: LIST
23474: LIST
23475: LIST
23476: PPUSH
23477: CALL_OW 69
23481: ST_TO_ADDR
// if not tmp then
23482: LD_VAR 0 8
23486: NOT
23487: IFFALSE 23491
// exit ;
23489: GO 25045
// for i in tmp do
23491: LD_ADDR_VAR 0 6
23495: PUSH
23496: LD_VAR 0 8
23500: PUSH
23501: FOR_IN
23502: IFFALSE 25020
// begin points := [ 0 , 0 , 0 ] ;
23504: LD_ADDR_VAR 0 9
23508: PUSH
23509: LD_INT 0
23511: PUSH
23512: LD_INT 0
23514: PUSH
23515: LD_INT 0
23517: PUSH
23518: EMPTY
23519: LIST
23520: LIST
23521: LIST
23522: ST_TO_ADDR
// bpoints := 1 ;
23523: LD_ADDR_VAR 0 10
23527: PUSH
23528: LD_INT 1
23530: ST_TO_ADDR
// case GetType ( i ) of unit_human :
23531: LD_VAR 0 6
23535: PPUSH
23536: CALL_OW 247
23540: PUSH
23541: LD_INT 1
23543: DOUBLE
23544: EQUAL
23545: IFTRUE 23549
23547: GO 24127
23549: POP
// begin if GetClass ( i ) = 1 then
23550: LD_VAR 0 6
23554: PPUSH
23555: CALL_OW 257
23559: PUSH
23560: LD_INT 1
23562: EQUAL
23563: IFFALSE 23584
// points := [ 10 , 5 , 3 ] ;
23565: LD_ADDR_VAR 0 9
23569: PUSH
23570: LD_INT 10
23572: PUSH
23573: LD_INT 5
23575: PUSH
23576: LD_INT 3
23578: PUSH
23579: EMPTY
23580: LIST
23581: LIST
23582: LIST
23583: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
23584: LD_VAR 0 6
23588: PPUSH
23589: CALL_OW 257
23593: PUSH
23594: LD_INT 2
23596: PUSH
23597: LD_INT 3
23599: PUSH
23600: LD_INT 4
23602: PUSH
23603: EMPTY
23604: LIST
23605: LIST
23606: LIST
23607: IN
23608: IFFALSE 23629
// points := [ 3 , 2 , 1 ] ;
23610: LD_ADDR_VAR 0 9
23614: PUSH
23615: LD_INT 3
23617: PUSH
23618: LD_INT 2
23620: PUSH
23621: LD_INT 1
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: LIST
23628: ST_TO_ADDR
// if GetClass ( i ) = 5 then
23629: LD_VAR 0 6
23633: PPUSH
23634: CALL_OW 257
23638: PUSH
23639: LD_INT 5
23641: EQUAL
23642: IFFALSE 23663
// points := [ 130 , 5 , 2 ] ;
23644: LD_ADDR_VAR 0 9
23648: PUSH
23649: LD_INT 130
23651: PUSH
23652: LD_INT 5
23654: PUSH
23655: LD_INT 2
23657: PUSH
23658: EMPTY
23659: LIST
23660: LIST
23661: LIST
23662: ST_TO_ADDR
// if GetClass ( i ) = 8 then
23663: LD_VAR 0 6
23667: PPUSH
23668: CALL_OW 257
23672: PUSH
23673: LD_INT 8
23675: EQUAL
23676: IFFALSE 23697
// points := [ 35 , 35 , 30 ] ;
23678: LD_ADDR_VAR 0 9
23682: PUSH
23683: LD_INT 35
23685: PUSH
23686: LD_INT 35
23688: PUSH
23689: LD_INT 30
23691: PUSH
23692: EMPTY
23693: LIST
23694: LIST
23695: LIST
23696: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23697: LD_VAR 0 6
23701: PPUSH
23702: CALL_OW 257
23706: PUSH
23707: LD_INT 9
23709: EQUAL
23710: IFFALSE 23731
// points := [ 20 , 55 , 40 ] ;
23712: LD_ADDR_VAR 0 9
23716: PUSH
23717: LD_INT 20
23719: PUSH
23720: LD_INT 55
23722: PUSH
23723: LD_INT 40
23725: PUSH
23726: EMPTY
23727: LIST
23728: LIST
23729: LIST
23730: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23731: LD_VAR 0 6
23735: PPUSH
23736: CALL_OW 257
23740: PUSH
23741: LD_INT 12
23743: PUSH
23744: LD_INT 16
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: IN
23751: IFFALSE 23772
// points := [ 5 , 3 , 2 ] ;
23753: LD_ADDR_VAR 0 9
23757: PUSH
23758: LD_INT 5
23760: PUSH
23761: LD_INT 3
23763: PUSH
23764: LD_INT 2
23766: PUSH
23767: EMPTY
23768: LIST
23769: LIST
23770: LIST
23771: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23772: LD_VAR 0 6
23776: PPUSH
23777: CALL_OW 257
23781: PUSH
23782: LD_INT 17
23784: EQUAL
23785: IFFALSE 23806
// points := [ 100 , 50 , 75 ] ;
23787: LD_ADDR_VAR 0 9
23791: PUSH
23792: LD_INT 100
23794: PUSH
23795: LD_INT 50
23797: PUSH
23798: LD_INT 75
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: LIST
23805: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23806: LD_VAR 0 6
23810: PPUSH
23811: CALL_OW 257
23815: PUSH
23816: LD_INT 15
23818: EQUAL
23819: IFFALSE 23840
// points := [ 10 , 5 , 3 ] ;
23821: LD_ADDR_VAR 0 9
23825: PUSH
23826: LD_INT 10
23828: PUSH
23829: LD_INT 5
23831: PUSH
23832: LD_INT 3
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: LIST
23839: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23840: LD_VAR 0 6
23844: PPUSH
23845: CALL_OW 257
23849: PUSH
23850: LD_INT 14
23852: EQUAL
23853: IFFALSE 23874
// points := [ 10 , 0 , 0 ] ;
23855: LD_ADDR_VAR 0 9
23859: PUSH
23860: LD_INT 10
23862: PUSH
23863: LD_INT 0
23865: PUSH
23866: LD_INT 0
23868: PUSH
23869: EMPTY
23870: LIST
23871: LIST
23872: LIST
23873: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23874: LD_VAR 0 6
23878: PPUSH
23879: CALL_OW 257
23883: PUSH
23884: LD_INT 11
23886: EQUAL
23887: IFFALSE 23908
// points := [ 30 , 10 , 5 ] ;
23889: LD_ADDR_VAR 0 9
23893: PUSH
23894: LD_INT 30
23896: PUSH
23897: LD_INT 10
23899: PUSH
23900: LD_INT 5
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: LIST
23907: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23908: LD_VAR 0 1
23912: PPUSH
23913: LD_INT 5
23915: PPUSH
23916: CALL_OW 321
23920: PUSH
23921: LD_INT 2
23923: EQUAL
23924: IFFALSE 23941
// bpoints := bpoints * 1.8 ;
23926: LD_ADDR_VAR 0 10
23930: PUSH
23931: LD_VAR 0 10
23935: PUSH
23936: LD_REAL  1.80000000000000E+0000
23939: MUL
23940: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23941: LD_VAR 0 6
23945: PPUSH
23946: CALL_OW 257
23950: PUSH
23951: LD_INT 1
23953: PUSH
23954: LD_INT 2
23956: PUSH
23957: LD_INT 3
23959: PUSH
23960: LD_INT 4
23962: PUSH
23963: EMPTY
23964: LIST
23965: LIST
23966: LIST
23967: LIST
23968: IN
23969: PUSH
23970: LD_VAR 0 1
23974: PPUSH
23975: LD_INT 51
23977: PPUSH
23978: CALL_OW 321
23982: PUSH
23983: LD_INT 2
23985: EQUAL
23986: AND
23987: IFFALSE 24004
// bpoints := bpoints * 1.2 ;
23989: LD_ADDR_VAR 0 10
23993: PUSH
23994: LD_VAR 0 10
23998: PUSH
23999: LD_REAL  1.20000000000000E+0000
24002: MUL
24003: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
24004: LD_VAR 0 6
24008: PPUSH
24009: CALL_OW 257
24013: PUSH
24014: LD_INT 5
24016: PUSH
24017: LD_INT 7
24019: PUSH
24020: LD_INT 9
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: LIST
24027: IN
24028: PUSH
24029: LD_VAR 0 1
24033: PPUSH
24034: LD_INT 52
24036: PPUSH
24037: CALL_OW 321
24041: PUSH
24042: LD_INT 2
24044: EQUAL
24045: AND
24046: IFFALSE 24063
// bpoints := bpoints * 1.5 ;
24048: LD_ADDR_VAR 0 10
24052: PUSH
24053: LD_VAR 0 10
24057: PUSH
24058: LD_REAL  1.50000000000000E+0000
24061: MUL
24062: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
24063: LD_VAR 0 1
24067: PPUSH
24068: LD_INT 66
24070: PPUSH
24071: CALL_OW 321
24075: PUSH
24076: LD_INT 2
24078: EQUAL
24079: IFFALSE 24096
// bpoints := bpoints * 1.1 ;
24081: LD_ADDR_VAR 0 10
24085: PUSH
24086: LD_VAR 0 10
24090: PUSH
24091: LD_REAL  1.10000000000000E+0000
24094: MUL
24095: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
24096: LD_ADDR_VAR 0 10
24100: PUSH
24101: LD_VAR 0 10
24105: PUSH
24106: LD_VAR 0 6
24110: PPUSH
24111: LD_INT 1
24113: PPUSH
24114: CALL_OW 259
24118: PUSH
24119: LD_REAL  1.15000000000000E+0000
24122: MUL
24123: MUL
24124: ST_TO_ADDR
// end ; unit_vehicle :
24125: GO 24949
24127: LD_INT 2
24129: DOUBLE
24130: EQUAL
24131: IFTRUE 24135
24133: GO 24937
24135: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
24136: LD_VAR 0 6
24140: PPUSH
24141: CALL_OW 264
24145: PUSH
24146: LD_INT 2
24148: PUSH
24149: LD_INT 42
24151: PUSH
24152: LD_INT 24
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: LIST
24159: IN
24160: IFFALSE 24181
// points := [ 25 , 5 , 3 ] ;
24162: LD_ADDR_VAR 0 9
24166: PUSH
24167: LD_INT 25
24169: PUSH
24170: LD_INT 5
24172: PUSH
24173: LD_INT 3
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: LIST
24180: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
24181: LD_VAR 0 6
24185: PPUSH
24186: CALL_OW 264
24190: PUSH
24191: LD_INT 4
24193: PUSH
24194: LD_INT 43
24196: PUSH
24197: LD_INT 25
24199: PUSH
24200: EMPTY
24201: LIST
24202: LIST
24203: LIST
24204: IN
24205: IFFALSE 24226
// points := [ 40 , 15 , 5 ] ;
24207: LD_ADDR_VAR 0 9
24211: PUSH
24212: LD_INT 40
24214: PUSH
24215: LD_INT 15
24217: PUSH
24218: LD_INT 5
24220: PUSH
24221: EMPTY
24222: LIST
24223: LIST
24224: LIST
24225: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
24226: LD_VAR 0 6
24230: PPUSH
24231: CALL_OW 264
24235: PUSH
24236: LD_INT 3
24238: PUSH
24239: LD_INT 23
24241: PUSH
24242: EMPTY
24243: LIST
24244: LIST
24245: IN
24246: IFFALSE 24267
// points := [ 7 , 25 , 8 ] ;
24248: LD_ADDR_VAR 0 9
24252: PUSH
24253: LD_INT 7
24255: PUSH
24256: LD_INT 25
24258: PUSH
24259: LD_INT 8
24261: PUSH
24262: EMPTY
24263: LIST
24264: LIST
24265: LIST
24266: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
24267: LD_VAR 0 6
24271: PPUSH
24272: CALL_OW 264
24276: PUSH
24277: LD_INT 5
24279: PUSH
24280: LD_INT 27
24282: PUSH
24283: LD_INT 44
24285: PUSH
24286: EMPTY
24287: LIST
24288: LIST
24289: LIST
24290: IN
24291: IFFALSE 24312
// points := [ 14 , 50 , 16 ] ;
24293: LD_ADDR_VAR 0 9
24297: PUSH
24298: LD_INT 14
24300: PUSH
24301: LD_INT 50
24303: PUSH
24304: LD_INT 16
24306: PUSH
24307: EMPTY
24308: LIST
24309: LIST
24310: LIST
24311: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
24312: LD_VAR 0 6
24316: PPUSH
24317: CALL_OW 264
24321: PUSH
24322: LD_INT 6
24324: PUSH
24325: LD_INT 46
24327: PUSH
24328: EMPTY
24329: LIST
24330: LIST
24331: IN
24332: IFFALSE 24353
// points := [ 32 , 120 , 70 ] ;
24334: LD_ADDR_VAR 0 9
24338: PUSH
24339: LD_INT 32
24341: PUSH
24342: LD_INT 120
24344: PUSH
24345: LD_INT 70
24347: PUSH
24348: EMPTY
24349: LIST
24350: LIST
24351: LIST
24352: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
24353: LD_VAR 0 6
24357: PPUSH
24358: CALL_OW 264
24362: PUSH
24363: LD_INT 7
24365: PUSH
24366: LD_INT 28
24368: PUSH
24369: LD_INT 45
24371: PUSH
24372: EMPTY
24373: LIST
24374: LIST
24375: LIST
24376: IN
24377: IFFALSE 24398
// points := [ 35 , 20 , 45 ] ;
24379: LD_ADDR_VAR 0 9
24383: PUSH
24384: LD_INT 35
24386: PUSH
24387: LD_INT 20
24389: PUSH
24390: LD_INT 45
24392: PUSH
24393: EMPTY
24394: LIST
24395: LIST
24396: LIST
24397: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
24398: LD_VAR 0 6
24402: PPUSH
24403: CALL_OW 264
24407: PUSH
24408: LD_INT 47
24410: PUSH
24411: EMPTY
24412: LIST
24413: IN
24414: IFFALSE 24435
// points := [ 67 , 45 , 75 ] ;
24416: LD_ADDR_VAR 0 9
24420: PUSH
24421: LD_INT 67
24423: PUSH
24424: LD_INT 45
24426: PUSH
24427: LD_INT 75
24429: PUSH
24430: EMPTY
24431: LIST
24432: LIST
24433: LIST
24434: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
24435: LD_VAR 0 6
24439: PPUSH
24440: CALL_OW 264
24444: PUSH
24445: LD_INT 26
24447: PUSH
24448: EMPTY
24449: LIST
24450: IN
24451: IFFALSE 24472
// points := [ 120 , 30 , 80 ] ;
24453: LD_ADDR_VAR 0 9
24457: PUSH
24458: LD_INT 120
24460: PUSH
24461: LD_INT 30
24463: PUSH
24464: LD_INT 80
24466: PUSH
24467: EMPTY
24468: LIST
24469: LIST
24470: LIST
24471: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
24472: LD_VAR 0 6
24476: PPUSH
24477: CALL_OW 264
24481: PUSH
24482: LD_INT 22
24484: PUSH
24485: EMPTY
24486: LIST
24487: IN
24488: IFFALSE 24509
// points := [ 40 , 1 , 1 ] ;
24490: LD_ADDR_VAR 0 9
24494: PUSH
24495: LD_INT 40
24497: PUSH
24498: LD_INT 1
24500: PUSH
24501: LD_INT 1
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: LIST
24508: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
24509: LD_VAR 0 6
24513: PPUSH
24514: CALL_OW 264
24518: PUSH
24519: LD_INT 29
24521: PUSH
24522: EMPTY
24523: LIST
24524: IN
24525: IFFALSE 24546
// points := [ 70 , 200 , 400 ] ;
24527: LD_ADDR_VAR 0 9
24531: PUSH
24532: LD_INT 70
24534: PUSH
24535: LD_INT 200
24537: PUSH
24538: LD_INT 400
24540: PUSH
24541: EMPTY
24542: LIST
24543: LIST
24544: LIST
24545: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
24546: LD_VAR 0 6
24550: PPUSH
24551: CALL_OW 264
24555: PUSH
24556: LD_INT 14
24558: PUSH
24559: LD_INT 53
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: IN
24566: IFFALSE 24587
// points := [ 40 , 10 , 20 ] ;
24568: LD_ADDR_VAR 0 9
24572: PUSH
24573: LD_INT 40
24575: PUSH
24576: LD_INT 10
24578: PUSH
24579: LD_INT 20
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: LIST
24586: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
24587: LD_VAR 0 6
24591: PPUSH
24592: CALL_OW 264
24596: PUSH
24597: LD_INT 9
24599: PUSH
24600: EMPTY
24601: LIST
24602: IN
24603: IFFALSE 24624
// points := [ 5 , 70 , 20 ] ;
24605: LD_ADDR_VAR 0 9
24609: PUSH
24610: LD_INT 5
24612: PUSH
24613: LD_INT 70
24615: PUSH
24616: LD_INT 20
24618: PUSH
24619: EMPTY
24620: LIST
24621: LIST
24622: LIST
24623: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
24624: LD_VAR 0 6
24628: PPUSH
24629: CALL_OW 264
24633: PUSH
24634: LD_INT 10
24636: PUSH
24637: EMPTY
24638: LIST
24639: IN
24640: IFFALSE 24661
// points := [ 35 , 110 , 70 ] ;
24642: LD_ADDR_VAR 0 9
24646: PUSH
24647: LD_INT 35
24649: PUSH
24650: LD_INT 110
24652: PUSH
24653: LD_INT 70
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: LIST
24660: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
24661: LD_VAR 0 6
24665: PPUSH
24666: CALL_OW 265
24670: PUSH
24671: LD_INT 25
24673: EQUAL
24674: IFFALSE 24695
// points := [ 80 , 65 , 100 ] ;
24676: LD_ADDR_VAR 0 9
24680: PUSH
24681: LD_INT 80
24683: PUSH
24684: LD_INT 65
24686: PUSH
24687: LD_INT 100
24689: PUSH
24690: EMPTY
24691: LIST
24692: LIST
24693: LIST
24694: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24695: LD_VAR 0 6
24699: PPUSH
24700: CALL_OW 263
24704: PUSH
24705: LD_INT 1
24707: EQUAL
24708: IFFALSE 24743
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24710: LD_ADDR_VAR 0 10
24714: PUSH
24715: LD_VAR 0 10
24719: PUSH
24720: LD_VAR 0 6
24724: PPUSH
24725: CALL_OW 311
24729: PPUSH
24730: LD_INT 3
24732: PPUSH
24733: CALL_OW 259
24737: PUSH
24738: LD_INT 4
24740: MUL
24741: MUL
24742: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24743: LD_VAR 0 6
24747: PPUSH
24748: CALL_OW 263
24752: PUSH
24753: LD_INT 2
24755: EQUAL
24756: IFFALSE 24807
// begin j := IsControledBy ( i ) ;
24758: LD_ADDR_VAR 0 7
24762: PUSH
24763: LD_VAR 0 6
24767: PPUSH
24768: CALL_OW 312
24772: ST_TO_ADDR
// if j then
24773: LD_VAR 0 7
24777: IFFALSE 24807
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24779: LD_ADDR_VAR 0 10
24783: PUSH
24784: LD_VAR 0 10
24788: PUSH
24789: LD_VAR 0 7
24793: PPUSH
24794: LD_INT 3
24796: PPUSH
24797: CALL_OW 259
24801: PUSH
24802: LD_INT 3
24804: MUL
24805: MUL
24806: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24807: LD_VAR 0 6
24811: PPUSH
24812: CALL_OW 264
24816: PUSH
24817: LD_INT 5
24819: PUSH
24820: LD_INT 6
24822: PUSH
24823: LD_INT 46
24825: PUSH
24826: LD_INT 44
24828: PUSH
24829: LD_INT 47
24831: PUSH
24832: LD_INT 45
24834: PUSH
24835: LD_INT 28
24837: PUSH
24838: LD_INT 7
24840: PUSH
24841: LD_INT 27
24843: PUSH
24844: LD_INT 29
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: LIST
24851: LIST
24852: LIST
24853: LIST
24854: LIST
24855: LIST
24856: LIST
24857: LIST
24858: IN
24859: PUSH
24860: LD_VAR 0 1
24864: PPUSH
24865: LD_INT 52
24867: PPUSH
24868: CALL_OW 321
24872: PUSH
24873: LD_INT 2
24875: EQUAL
24876: AND
24877: IFFALSE 24894
// bpoints := bpoints * 1.2 ;
24879: LD_ADDR_VAR 0 10
24883: PUSH
24884: LD_VAR 0 10
24888: PUSH
24889: LD_REAL  1.20000000000000E+0000
24892: MUL
24893: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24894: LD_VAR 0 6
24898: PPUSH
24899: CALL_OW 264
24903: PUSH
24904: LD_INT 6
24906: PUSH
24907: LD_INT 46
24909: PUSH
24910: LD_INT 47
24912: PUSH
24913: EMPTY
24914: LIST
24915: LIST
24916: LIST
24917: IN
24918: IFFALSE 24935
// bpoints := bpoints * 1.2 ;
24920: LD_ADDR_VAR 0 10
24924: PUSH
24925: LD_VAR 0 10
24929: PUSH
24930: LD_REAL  1.20000000000000E+0000
24933: MUL
24934: ST_TO_ADDR
// end ; unit_building :
24935: GO 24949
24937: LD_INT 3
24939: DOUBLE
24940: EQUAL
24941: IFTRUE 24945
24943: GO 24948
24945: POP
// ; end ;
24946: GO 24949
24948: POP
// for j = 1 to 3 do
24949: LD_ADDR_VAR 0 7
24953: PUSH
24954: DOUBLE
24955: LD_INT 1
24957: DEC
24958: ST_TO_ADDR
24959: LD_INT 3
24961: PUSH
24962: FOR_TO
24963: IFFALSE 25016
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24965: LD_ADDR_VAR 0 5
24969: PUSH
24970: LD_VAR 0 5
24974: PPUSH
24975: LD_VAR 0 7
24979: PPUSH
24980: LD_VAR 0 5
24984: PUSH
24985: LD_VAR 0 7
24989: ARRAY
24990: PUSH
24991: LD_VAR 0 9
24995: PUSH
24996: LD_VAR 0 7
25000: ARRAY
25001: PUSH
25002: LD_VAR 0 10
25006: MUL
25007: PLUS
25008: PPUSH
25009: CALL_OW 1
25013: ST_TO_ADDR
25014: GO 24962
25016: POP
25017: POP
// end ;
25018: GO 23501
25020: POP
25021: POP
// result := Replace ( result , 4 , tmp ) ;
25022: LD_ADDR_VAR 0 5
25026: PUSH
25027: LD_VAR 0 5
25031: PPUSH
25032: LD_INT 4
25034: PPUSH
25035: LD_VAR 0 8
25039: PPUSH
25040: CALL_OW 1
25044: ST_TO_ADDR
// end ;
25045: LD_VAR 0 5
25049: RET
// export function DangerAtRange ( unit , range ) ; begin
25050: LD_INT 0
25052: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
25053: LD_ADDR_VAR 0 3
25057: PUSH
25058: LD_VAR 0 1
25062: PPUSH
25063: CALL_OW 255
25067: PPUSH
25068: LD_VAR 0 1
25072: PPUSH
25073: CALL_OW 250
25077: PPUSH
25078: LD_VAR 0 1
25082: PPUSH
25083: CALL_OW 251
25087: PPUSH
25088: LD_VAR 0 2
25092: PPUSH
25093: CALL 23353 0 4
25097: ST_TO_ADDR
// end ;
25098: LD_VAR 0 3
25102: RET
// export function DangerInArea ( side , area ) ; begin
25103: LD_INT 0
25105: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
25106: LD_ADDR_VAR 0 3
25110: PUSH
25111: LD_VAR 0 2
25115: PPUSH
25116: LD_INT 81
25118: PUSH
25119: LD_VAR 0 1
25123: PUSH
25124: EMPTY
25125: LIST
25126: LIST
25127: PPUSH
25128: CALL_OW 70
25132: ST_TO_ADDR
// end ;
25133: LD_VAR 0 3
25137: RET
// export function IsExtension ( b ) ; begin
25138: LD_INT 0
25140: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
25141: LD_ADDR_VAR 0 2
25145: PUSH
25146: LD_VAR 0 1
25150: PUSH
25151: LD_INT 23
25153: PUSH
25154: LD_INT 20
25156: PUSH
25157: LD_INT 22
25159: PUSH
25160: LD_INT 17
25162: PUSH
25163: LD_INT 24
25165: PUSH
25166: LD_INT 21
25168: PUSH
25169: LD_INT 19
25171: PUSH
25172: LD_INT 16
25174: PUSH
25175: LD_INT 25
25177: PUSH
25178: LD_INT 18
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: LIST
25185: LIST
25186: LIST
25187: LIST
25188: LIST
25189: LIST
25190: LIST
25191: LIST
25192: IN
25193: ST_TO_ADDR
// end ;
25194: LD_VAR 0 2
25198: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
25199: LD_INT 0
25201: PPUSH
25202: PPUSH
25203: PPUSH
// result := [ ] ;
25204: LD_ADDR_VAR 0 3
25208: PUSH
25209: EMPTY
25210: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
25211: LD_ADDR_VAR 0 4
25215: PUSH
25216: LD_VAR 0 2
25220: PPUSH
25221: LD_INT 21
25223: PUSH
25224: LD_INT 3
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: PPUSH
25231: CALL_OW 70
25235: ST_TO_ADDR
// if not tmp then
25236: LD_VAR 0 4
25240: NOT
25241: IFFALSE 25245
// exit ;
25243: GO 25303
// for i in tmp do
25245: LD_ADDR_VAR 0 5
25249: PUSH
25250: LD_VAR 0 4
25254: PUSH
25255: FOR_IN
25256: IFFALSE 25291
// if GetBase ( i ) <> base then
25258: LD_VAR 0 5
25262: PPUSH
25263: CALL_OW 274
25267: PUSH
25268: LD_VAR 0 1
25272: NONEQUAL
25273: IFFALSE 25289
// ComLinkToBase ( base , i ) ;
25275: LD_VAR 0 1
25279: PPUSH
25280: LD_VAR 0 5
25284: PPUSH
25285: CALL_OW 169
25289: GO 25255
25291: POP
25292: POP
// result := tmp ;
25293: LD_ADDR_VAR 0 3
25297: PUSH
25298: LD_VAR 0 4
25302: ST_TO_ADDR
// end ;
25303: LD_VAR 0 3
25307: RET
// export function ComComplete ( unit , b ) ; var i ; begin
25308: LD_INT 0
25310: PPUSH
25311: PPUSH
// if BuildingStatus ( b ) = bs_build then
25312: LD_VAR 0 2
25316: PPUSH
25317: CALL_OW 461
25321: PUSH
25322: LD_INT 1
25324: EQUAL
25325: IFFALSE 25385
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25327: LD_VAR 0 1
25331: PPUSH
25332: LD_STRING h
25334: PUSH
25335: LD_VAR 0 2
25339: PPUSH
25340: CALL_OW 250
25344: PUSH
25345: LD_VAR 0 2
25349: PPUSH
25350: CALL_OW 251
25354: PUSH
25355: LD_VAR 0 2
25359: PUSH
25360: LD_INT 0
25362: PUSH
25363: LD_INT 0
25365: PUSH
25366: LD_INT 0
25368: PUSH
25369: EMPTY
25370: LIST
25371: LIST
25372: LIST
25373: LIST
25374: LIST
25375: LIST
25376: LIST
25377: PUSH
25378: EMPTY
25379: LIST
25380: PPUSH
25381: CALL_OW 446
// end ;
25385: LD_VAR 0 3
25389: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
25390: LD_INT 0
25392: PPUSH
25393: PPUSH
25394: PPUSH
25395: PPUSH
25396: PPUSH
25397: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
25398: LD_VAR 0 1
25402: NOT
25403: PUSH
25404: LD_VAR 0 1
25408: PPUSH
25409: CALL_OW 263
25413: PUSH
25414: LD_INT 2
25416: EQUAL
25417: NOT
25418: OR
25419: IFFALSE 25423
// exit ;
25421: GO 25739
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
25423: LD_ADDR_VAR 0 6
25427: PUSH
25428: LD_INT 22
25430: PUSH
25431: LD_VAR 0 1
25435: PPUSH
25436: CALL_OW 255
25440: PUSH
25441: EMPTY
25442: LIST
25443: LIST
25444: PUSH
25445: LD_INT 2
25447: PUSH
25448: LD_INT 30
25450: PUSH
25451: LD_INT 36
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: LD_INT 34
25460: PUSH
25461: LD_INT 31
25463: PUSH
25464: EMPTY
25465: LIST
25466: LIST
25467: PUSH
25468: EMPTY
25469: LIST
25470: LIST
25471: LIST
25472: PUSH
25473: EMPTY
25474: LIST
25475: LIST
25476: PPUSH
25477: CALL_OW 69
25481: ST_TO_ADDR
// if not tmp then
25482: LD_VAR 0 6
25486: NOT
25487: IFFALSE 25491
// exit ;
25489: GO 25739
// result := [ ] ;
25491: LD_ADDR_VAR 0 2
25495: PUSH
25496: EMPTY
25497: ST_TO_ADDR
// for i in tmp do
25498: LD_ADDR_VAR 0 3
25502: PUSH
25503: LD_VAR 0 6
25507: PUSH
25508: FOR_IN
25509: IFFALSE 25580
// begin t := UnitsInside ( i ) ;
25511: LD_ADDR_VAR 0 4
25515: PUSH
25516: LD_VAR 0 3
25520: PPUSH
25521: CALL_OW 313
25525: ST_TO_ADDR
// if t then
25526: LD_VAR 0 4
25530: IFFALSE 25578
// for j in t do
25532: LD_ADDR_VAR 0 7
25536: PUSH
25537: LD_VAR 0 4
25541: PUSH
25542: FOR_IN
25543: IFFALSE 25576
// result := Insert ( result , result + 1 , j ) ;
25545: LD_ADDR_VAR 0 2
25549: PUSH
25550: LD_VAR 0 2
25554: PPUSH
25555: LD_VAR 0 2
25559: PUSH
25560: LD_INT 1
25562: PLUS
25563: PPUSH
25564: LD_VAR 0 7
25568: PPUSH
25569: CALL_OW 2
25573: ST_TO_ADDR
25574: GO 25542
25576: POP
25577: POP
// end ;
25578: GO 25508
25580: POP
25581: POP
// if not result then
25582: LD_VAR 0 2
25586: NOT
25587: IFFALSE 25591
// exit ;
25589: GO 25739
// mech := result [ 1 ] ;
25591: LD_ADDR_VAR 0 5
25595: PUSH
25596: LD_VAR 0 2
25600: PUSH
25601: LD_INT 1
25603: ARRAY
25604: ST_TO_ADDR
// if result > 1 then
25605: LD_VAR 0 2
25609: PUSH
25610: LD_INT 1
25612: GREATER
25613: IFFALSE 25725
// for i = 2 to result do
25615: LD_ADDR_VAR 0 3
25619: PUSH
25620: DOUBLE
25621: LD_INT 2
25623: DEC
25624: ST_TO_ADDR
25625: LD_VAR 0 2
25629: PUSH
25630: FOR_TO
25631: IFFALSE 25723
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
25633: LD_ADDR_VAR 0 4
25637: PUSH
25638: LD_VAR 0 2
25642: PUSH
25643: LD_VAR 0 3
25647: ARRAY
25648: PPUSH
25649: LD_INT 3
25651: PPUSH
25652: CALL_OW 259
25656: PUSH
25657: LD_VAR 0 2
25661: PUSH
25662: LD_VAR 0 3
25666: ARRAY
25667: PPUSH
25668: CALL_OW 432
25672: MINUS
25673: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25674: LD_VAR 0 4
25678: PUSH
25679: LD_VAR 0 5
25683: PPUSH
25684: LD_INT 3
25686: PPUSH
25687: CALL_OW 259
25691: PUSH
25692: LD_VAR 0 5
25696: PPUSH
25697: CALL_OW 432
25701: MINUS
25702: GREATEREQUAL
25703: IFFALSE 25721
// mech := result [ i ] ;
25705: LD_ADDR_VAR 0 5
25709: PUSH
25710: LD_VAR 0 2
25714: PUSH
25715: LD_VAR 0 3
25719: ARRAY
25720: ST_TO_ADDR
// end ;
25721: GO 25630
25723: POP
25724: POP
// ComLinkTo ( vehicle , mech ) ;
25725: LD_VAR 0 1
25729: PPUSH
25730: LD_VAR 0 5
25734: PPUSH
25735: CALL_OW 135
// end ;
25739: LD_VAR 0 2
25743: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25744: LD_INT 0
25746: PPUSH
25747: PPUSH
25748: PPUSH
25749: PPUSH
25750: PPUSH
25751: PPUSH
25752: PPUSH
25753: PPUSH
25754: PPUSH
25755: PPUSH
25756: PPUSH
25757: PPUSH
25758: PPUSH
// result := [ ] ;
25759: LD_ADDR_VAR 0 7
25763: PUSH
25764: EMPTY
25765: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25766: LD_VAR 0 1
25770: PPUSH
25771: CALL_OW 266
25775: PUSH
25776: LD_INT 0
25778: PUSH
25779: LD_INT 1
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: IN
25786: NOT
25787: IFFALSE 25791
// exit ;
25789: GO 27422
// if name then
25791: LD_VAR 0 3
25795: IFFALSE 25811
// SetBName ( base_dep , name ) ;
25797: LD_VAR 0 1
25801: PPUSH
25802: LD_VAR 0 3
25806: PPUSH
25807: CALL_OW 500
// base := GetBase ( base_dep ) ;
25811: LD_ADDR_VAR 0 15
25815: PUSH
25816: LD_VAR 0 1
25820: PPUSH
25821: CALL_OW 274
25825: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
25826: LD_ADDR_VAR 0 16
25830: PUSH
25831: LD_VAR 0 1
25835: PPUSH
25836: CALL_OW 255
25840: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
25841: LD_ADDR_VAR 0 17
25845: PUSH
25846: LD_VAR 0 1
25850: PPUSH
25851: CALL_OW 248
25855: ST_TO_ADDR
// if sources then
25856: LD_VAR 0 5
25860: IFFALSE 25907
// for i = 1 to 3 do
25862: LD_ADDR_VAR 0 8
25866: PUSH
25867: DOUBLE
25868: LD_INT 1
25870: DEC
25871: ST_TO_ADDR
25872: LD_INT 3
25874: PUSH
25875: FOR_TO
25876: IFFALSE 25905
// AddResourceType ( base , i , sources [ i ] ) ;
25878: LD_VAR 0 15
25882: PPUSH
25883: LD_VAR 0 8
25887: PPUSH
25888: LD_VAR 0 5
25892: PUSH
25893: LD_VAR 0 8
25897: ARRAY
25898: PPUSH
25899: CALL_OW 276
25903: GO 25875
25905: POP
25906: POP
// buildings := GetBaseBuildings ( base , area ) ;
25907: LD_ADDR_VAR 0 18
25911: PUSH
25912: LD_VAR 0 15
25916: PPUSH
25917: LD_VAR 0 2
25921: PPUSH
25922: CALL 25199 0 2
25926: ST_TO_ADDR
// InitHc ;
25927: CALL_OW 19
// InitUc ;
25931: CALL_OW 18
// uc_side := side ;
25935: LD_ADDR_OWVAR 20
25939: PUSH
25940: LD_VAR 0 16
25944: ST_TO_ADDR
// uc_nation := nation ;
25945: LD_ADDR_OWVAR 21
25949: PUSH
25950: LD_VAR 0 17
25954: ST_TO_ADDR
// if buildings then
25955: LD_VAR 0 18
25959: IFFALSE 27281
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25961: LD_ADDR_VAR 0 19
25965: PUSH
25966: LD_VAR 0 18
25970: PPUSH
25971: LD_INT 2
25973: PUSH
25974: LD_INT 30
25976: PUSH
25977: LD_INT 29
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PUSH
25984: LD_INT 30
25986: PUSH
25987: LD_INT 30
25989: PUSH
25990: EMPTY
25991: LIST
25992: LIST
25993: PUSH
25994: EMPTY
25995: LIST
25996: LIST
25997: LIST
25998: PPUSH
25999: CALL_OW 72
26003: ST_TO_ADDR
// if tmp then
26004: LD_VAR 0 19
26008: IFFALSE 26056
// for i in tmp do
26010: LD_ADDR_VAR 0 8
26014: PUSH
26015: LD_VAR 0 19
26019: PUSH
26020: FOR_IN
26021: IFFALSE 26054
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
26023: LD_VAR 0 8
26027: PPUSH
26028: CALL_OW 250
26032: PPUSH
26033: LD_VAR 0 8
26037: PPUSH
26038: CALL_OW 251
26042: PPUSH
26043: LD_VAR 0 16
26047: PPUSH
26048: CALL_OW 441
26052: GO 26020
26054: POP
26055: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
26056: LD_VAR 0 18
26060: PPUSH
26061: LD_INT 2
26063: PUSH
26064: LD_INT 30
26066: PUSH
26067: LD_INT 32
26069: PUSH
26070: EMPTY
26071: LIST
26072: LIST
26073: PUSH
26074: LD_INT 30
26076: PUSH
26077: LD_INT 33
26079: PUSH
26080: EMPTY
26081: LIST
26082: LIST
26083: PUSH
26084: EMPTY
26085: LIST
26086: LIST
26087: LIST
26088: PPUSH
26089: CALL_OW 72
26093: IFFALSE 26181
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
26095: LD_ADDR_VAR 0 8
26099: PUSH
26100: LD_VAR 0 18
26104: PPUSH
26105: LD_INT 2
26107: PUSH
26108: LD_INT 30
26110: PUSH
26111: LD_INT 32
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: PUSH
26118: LD_INT 30
26120: PUSH
26121: LD_INT 33
26123: PUSH
26124: EMPTY
26125: LIST
26126: LIST
26127: PUSH
26128: EMPTY
26129: LIST
26130: LIST
26131: LIST
26132: PPUSH
26133: CALL_OW 72
26137: PUSH
26138: FOR_IN
26139: IFFALSE 26179
// begin if not GetBWeapon ( i ) then
26141: LD_VAR 0 8
26145: PPUSH
26146: CALL_OW 269
26150: NOT
26151: IFFALSE 26177
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
26153: LD_VAR 0 8
26157: PPUSH
26158: LD_VAR 0 8
26162: PPUSH
26163: LD_VAR 0 2
26167: PPUSH
26168: CALL 27427 0 2
26172: PPUSH
26173: CALL_OW 431
// end ;
26177: GO 26138
26179: POP
26180: POP
// end ; for i = 1 to personel do
26181: LD_ADDR_VAR 0 8
26185: PUSH
26186: DOUBLE
26187: LD_INT 1
26189: DEC
26190: ST_TO_ADDR
26191: LD_VAR 0 6
26195: PUSH
26196: FOR_TO
26197: IFFALSE 27261
// begin if i > 4 then
26199: LD_VAR 0 8
26203: PUSH
26204: LD_INT 4
26206: GREATER
26207: IFFALSE 26211
// break ;
26209: GO 27261
// case i of 1 :
26211: LD_VAR 0 8
26215: PUSH
26216: LD_INT 1
26218: DOUBLE
26219: EQUAL
26220: IFTRUE 26224
26222: GO 26304
26224: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
26225: LD_ADDR_VAR 0 12
26229: PUSH
26230: LD_VAR 0 18
26234: PPUSH
26235: LD_INT 22
26237: PUSH
26238: LD_VAR 0 16
26242: PUSH
26243: EMPTY
26244: LIST
26245: LIST
26246: PUSH
26247: LD_INT 58
26249: PUSH
26250: EMPTY
26251: LIST
26252: PUSH
26253: LD_INT 2
26255: PUSH
26256: LD_INT 30
26258: PUSH
26259: LD_INT 32
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: LD_INT 30
26268: PUSH
26269: LD_INT 4
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 30
26278: PUSH
26279: LD_INT 5
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: LIST
26290: LIST
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: LIST
26296: PPUSH
26297: CALL_OW 72
26301: ST_TO_ADDR
26302: GO 26526
26304: LD_INT 2
26306: DOUBLE
26307: EQUAL
26308: IFTRUE 26312
26310: GO 26374
26312: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
26313: LD_ADDR_VAR 0 12
26317: PUSH
26318: LD_VAR 0 18
26322: PPUSH
26323: LD_INT 22
26325: PUSH
26326: LD_VAR 0 16
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: PUSH
26335: LD_INT 2
26337: PUSH
26338: LD_INT 30
26340: PUSH
26341: LD_INT 0
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 30
26350: PUSH
26351: LD_INT 1
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: LIST
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PPUSH
26367: CALL_OW 72
26371: ST_TO_ADDR
26372: GO 26526
26374: LD_INT 3
26376: DOUBLE
26377: EQUAL
26378: IFTRUE 26382
26380: GO 26444
26382: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
26383: LD_ADDR_VAR 0 12
26387: PUSH
26388: LD_VAR 0 18
26392: PPUSH
26393: LD_INT 22
26395: PUSH
26396: LD_VAR 0 16
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 2
26407: PUSH
26408: LD_INT 30
26410: PUSH
26411: LD_INT 2
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: LD_INT 30
26420: PUSH
26421: LD_INT 3
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: LIST
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PPUSH
26437: CALL_OW 72
26441: ST_TO_ADDR
26442: GO 26526
26444: LD_INT 4
26446: DOUBLE
26447: EQUAL
26448: IFTRUE 26452
26450: GO 26525
26452: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
26453: LD_ADDR_VAR 0 12
26457: PUSH
26458: LD_VAR 0 18
26462: PPUSH
26463: LD_INT 22
26465: PUSH
26466: LD_VAR 0 16
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: LD_INT 2
26477: PUSH
26478: LD_INT 30
26480: PUSH
26481: LD_INT 6
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: LD_INT 30
26490: PUSH
26491: LD_INT 7
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: LD_INT 30
26500: PUSH
26501: LD_INT 8
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: LIST
26512: LIST
26513: PUSH
26514: EMPTY
26515: LIST
26516: LIST
26517: PPUSH
26518: CALL_OW 72
26522: ST_TO_ADDR
26523: GO 26526
26525: POP
// if i = 1 then
26526: LD_VAR 0 8
26530: PUSH
26531: LD_INT 1
26533: EQUAL
26534: IFFALSE 26645
// begin tmp := [ ] ;
26536: LD_ADDR_VAR 0 19
26540: PUSH
26541: EMPTY
26542: ST_TO_ADDR
// for j in f do
26543: LD_ADDR_VAR 0 9
26547: PUSH
26548: LD_VAR 0 12
26552: PUSH
26553: FOR_IN
26554: IFFALSE 26627
// if GetBType ( j ) = b_bunker then
26556: LD_VAR 0 9
26560: PPUSH
26561: CALL_OW 266
26565: PUSH
26566: LD_INT 32
26568: EQUAL
26569: IFFALSE 26596
// tmp := Insert ( tmp , 1 , j ) else
26571: LD_ADDR_VAR 0 19
26575: PUSH
26576: LD_VAR 0 19
26580: PPUSH
26581: LD_INT 1
26583: PPUSH
26584: LD_VAR 0 9
26588: PPUSH
26589: CALL_OW 2
26593: ST_TO_ADDR
26594: GO 26625
// tmp := Insert ( tmp , tmp + 1 , j ) ;
26596: LD_ADDR_VAR 0 19
26600: PUSH
26601: LD_VAR 0 19
26605: PPUSH
26606: LD_VAR 0 19
26610: PUSH
26611: LD_INT 1
26613: PLUS
26614: PPUSH
26615: LD_VAR 0 9
26619: PPUSH
26620: CALL_OW 2
26624: ST_TO_ADDR
26625: GO 26553
26627: POP
26628: POP
// if tmp then
26629: LD_VAR 0 19
26633: IFFALSE 26645
// f := tmp ;
26635: LD_ADDR_VAR 0 12
26639: PUSH
26640: LD_VAR 0 19
26644: ST_TO_ADDR
// end ; x := personel [ i ] ;
26645: LD_ADDR_VAR 0 13
26649: PUSH
26650: LD_VAR 0 6
26654: PUSH
26655: LD_VAR 0 8
26659: ARRAY
26660: ST_TO_ADDR
// if x = - 1 then
26661: LD_VAR 0 13
26665: PUSH
26666: LD_INT 1
26668: NEG
26669: EQUAL
26670: IFFALSE 26879
// begin for j in f do
26672: LD_ADDR_VAR 0 9
26676: PUSH
26677: LD_VAR 0 12
26681: PUSH
26682: FOR_IN
26683: IFFALSE 26875
// repeat InitHc ;
26685: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26689: LD_VAR 0 9
26693: PPUSH
26694: CALL_OW 266
26698: PUSH
26699: LD_INT 5
26701: EQUAL
26702: IFFALSE 26772
// begin if UnitsInside ( j ) < 3 then
26704: LD_VAR 0 9
26708: PPUSH
26709: CALL_OW 313
26713: PUSH
26714: LD_INT 3
26716: LESS
26717: IFFALSE 26753
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26719: LD_INT 0
26721: PPUSH
26722: LD_INT 5
26724: PUSH
26725: LD_INT 8
26727: PUSH
26728: LD_INT 9
26730: PUSH
26731: EMPTY
26732: LIST
26733: LIST
26734: LIST
26735: PUSH
26736: LD_VAR 0 17
26740: ARRAY
26741: PPUSH
26742: LD_VAR 0 4
26746: PPUSH
26747: CALL_OW 380
26751: GO 26770
// PrepareHuman ( false , i , skill ) ;
26753: LD_INT 0
26755: PPUSH
26756: LD_VAR 0 8
26760: PPUSH
26761: LD_VAR 0 4
26765: PPUSH
26766: CALL_OW 380
// end else
26770: GO 26789
// PrepareHuman ( false , i , skill ) ;
26772: LD_INT 0
26774: PPUSH
26775: LD_VAR 0 8
26779: PPUSH
26780: LD_VAR 0 4
26784: PPUSH
26785: CALL_OW 380
// un := CreateHuman ;
26789: LD_ADDR_VAR 0 14
26793: PUSH
26794: CALL_OW 44
26798: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26799: LD_ADDR_VAR 0 7
26803: PUSH
26804: LD_VAR 0 7
26808: PPUSH
26809: LD_INT 1
26811: PPUSH
26812: LD_VAR 0 14
26816: PPUSH
26817: CALL_OW 2
26821: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
26822: LD_VAR 0 14
26826: PPUSH
26827: LD_VAR 0 9
26831: PPUSH
26832: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
26836: LD_VAR 0 9
26840: PPUSH
26841: CALL_OW 313
26845: PUSH
26846: LD_INT 6
26848: EQUAL
26849: PUSH
26850: LD_VAR 0 9
26854: PPUSH
26855: CALL_OW 266
26859: PUSH
26860: LD_INT 32
26862: PUSH
26863: LD_INT 31
26865: PUSH
26866: EMPTY
26867: LIST
26868: LIST
26869: IN
26870: OR
26871: IFFALSE 26685
26873: GO 26682
26875: POP
26876: POP
// end else
26877: GO 27259
// for j = 1 to x do
26879: LD_ADDR_VAR 0 9
26883: PUSH
26884: DOUBLE
26885: LD_INT 1
26887: DEC
26888: ST_TO_ADDR
26889: LD_VAR 0 13
26893: PUSH
26894: FOR_TO
26895: IFFALSE 27257
// begin InitHc ;
26897: CALL_OW 19
// if not f then
26901: LD_VAR 0 12
26905: NOT
26906: IFFALSE 26995
// begin PrepareHuman ( false , i , skill ) ;
26908: LD_INT 0
26910: PPUSH
26911: LD_VAR 0 8
26915: PPUSH
26916: LD_VAR 0 4
26920: PPUSH
26921: CALL_OW 380
// un := CreateHuman ;
26925: LD_ADDR_VAR 0 14
26929: PUSH
26930: CALL_OW 44
26934: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26935: LD_ADDR_VAR 0 7
26939: PUSH
26940: LD_VAR 0 7
26944: PPUSH
26945: LD_INT 1
26947: PPUSH
26948: LD_VAR 0 14
26952: PPUSH
26953: CALL_OW 2
26957: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26958: LD_VAR 0 14
26962: PPUSH
26963: LD_VAR 0 1
26967: PPUSH
26968: CALL_OW 250
26972: PPUSH
26973: LD_VAR 0 1
26977: PPUSH
26978: CALL_OW 251
26982: PPUSH
26983: LD_INT 10
26985: PPUSH
26986: LD_INT 0
26988: PPUSH
26989: CALL_OW 50
// continue ;
26993: GO 26894
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
26995: LD_VAR 0 12
26999: PUSH
27000: LD_INT 1
27002: ARRAY
27003: PPUSH
27004: CALL_OW 313
27008: PUSH
27009: LD_VAR 0 12
27013: PUSH
27014: LD_INT 1
27016: ARRAY
27017: PPUSH
27018: CALL_OW 266
27022: PUSH
27023: LD_INT 32
27025: PUSH
27026: LD_INT 31
27028: PUSH
27029: EMPTY
27030: LIST
27031: LIST
27032: IN
27033: AND
27034: PUSH
27035: LD_VAR 0 12
27039: PUSH
27040: LD_INT 1
27042: ARRAY
27043: PPUSH
27044: CALL_OW 313
27048: PUSH
27049: LD_INT 6
27051: EQUAL
27052: OR
27053: IFFALSE 27073
// f := Delete ( f , 1 ) ;
27055: LD_ADDR_VAR 0 12
27059: PUSH
27060: LD_VAR 0 12
27064: PPUSH
27065: LD_INT 1
27067: PPUSH
27068: CALL_OW 3
27072: ST_TO_ADDR
// if not f then
27073: LD_VAR 0 12
27077: NOT
27078: IFFALSE 27096
// begin x := x + 2 ;
27080: LD_ADDR_VAR 0 13
27084: PUSH
27085: LD_VAR 0 13
27089: PUSH
27090: LD_INT 2
27092: PLUS
27093: ST_TO_ADDR
// continue ;
27094: GO 26894
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
27096: LD_VAR 0 12
27100: PUSH
27101: LD_INT 1
27103: ARRAY
27104: PPUSH
27105: CALL_OW 266
27109: PUSH
27110: LD_INT 5
27112: EQUAL
27113: IFFALSE 27187
// begin if UnitsInside ( f [ 1 ] ) < 3 then
27115: LD_VAR 0 12
27119: PUSH
27120: LD_INT 1
27122: ARRAY
27123: PPUSH
27124: CALL_OW 313
27128: PUSH
27129: LD_INT 3
27131: LESS
27132: IFFALSE 27168
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27134: LD_INT 0
27136: PPUSH
27137: LD_INT 5
27139: PUSH
27140: LD_INT 8
27142: PUSH
27143: LD_INT 9
27145: PUSH
27146: EMPTY
27147: LIST
27148: LIST
27149: LIST
27150: PUSH
27151: LD_VAR 0 17
27155: ARRAY
27156: PPUSH
27157: LD_VAR 0 4
27161: PPUSH
27162: CALL_OW 380
27166: GO 27185
// PrepareHuman ( false , i , skill ) ;
27168: LD_INT 0
27170: PPUSH
27171: LD_VAR 0 8
27175: PPUSH
27176: LD_VAR 0 4
27180: PPUSH
27181: CALL_OW 380
// end else
27185: GO 27204
// PrepareHuman ( false , i , skill ) ;
27187: LD_INT 0
27189: PPUSH
27190: LD_VAR 0 8
27194: PPUSH
27195: LD_VAR 0 4
27199: PPUSH
27200: CALL_OW 380
// un := CreateHuman ;
27204: LD_ADDR_VAR 0 14
27208: PUSH
27209: CALL_OW 44
27213: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27214: LD_ADDR_VAR 0 7
27218: PUSH
27219: LD_VAR 0 7
27223: PPUSH
27224: LD_INT 1
27226: PPUSH
27227: LD_VAR 0 14
27231: PPUSH
27232: CALL_OW 2
27236: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
27237: LD_VAR 0 14
27241: PPUSH
27242: LD_VAR 0 12
27246: PUSH
27247: LD_INT 1
27249: ARRAY
27250: PPUSH
27251: CALL_OW 52
// end ;
27255: GO 26894
27257: POP
27258: POP
// end ;
27259: GO 26196
27261: POP
27262: POP
// result := result ^ buildings ;
27263: LD_ADDR_VAR 0 7
27267: PUSH
27268: LD_VAR 0 7
27272: PUSH
27273: LD_VAR 0 18
27277: ADD
27278: ST_TO_ADDR
// end else
27279: GO 27422
// begin for i = 1 to personel do
27281: LD_ADDR_VAR 0 8
27285: PUSH
27286: DOUBLE
27287: LD_INT 1
27289: DEC
27290: ST_TO_ADDR
27291: LD_VAR 0 6
27295: PUSH
27296: FOR_TO
27297: IFFALSE 27420
// begin if i > 4 then
27299: LD_VAR 0 8
27303: PUSH
27304: LD_INT 4
27306: GREATER
27307: IFFALSE 27311
// break ;
27309: GO 27420
// x := personel [ i ] ;
27311: LD_ADDR_VAR 0 13
27315: PUSH
27316: LD_VAR 0 6
27320: PUSH
27321: LD_VAR 0 8
27325: ARRAY
27326: ST_TO_ADDR
// if x = - 1 then
27327: LD_VAR 0 13
27331: PUSH
27332: LD_INT 1
27334: NEG
27335: EQUAL
27336: IFFALSE 27340
// continue ;
27338: GO 27296
// PrepareHuman ( false , i , skill ) ;
27340: LD_INT 0
27342: PPUSH
27343: LD_VAR 0 8
27347: PPUSH
27348: LD_VAR 0 4
27352: PPUSH
27353: CALL_OW 380
// un := CreateHuman ;
27357: LD_ADDR_VAR 0 14
27361: PUSH
27362: CALL_OW 44
27366: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27367: LD_VAR 0 14
27371: PPUSH
27372: LD_VAR 0 1
27376: PPUSH
27377: CALL_OW 250
27381: PPUSH
27382: LD_VAR 0 1
27386: PPUSH
27387: CALL_OW 251
27391: PPUSH
27392: LD_INT 10
27394: PPUSH
27395: LD_INT 0
27397: PPUSH
27398: CALL_OW 50
// result := result ^ un ;
27402: LD_ADDR_VAR 0 7
27406: PUSH
27407: LD_VAR 0 7
27411: PUSH
27412: LD_VAR 0 14
27416: ADD
27417: ST_TO_ADDR
// end ;
27418: GO 27296
27420: POP
27421: POP
// end ; end ;
27422: LD_VAR 0 7
27426: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
27427: LD_INT 0
27429: PPUSH
27430: PPUSH
27431: PPUSH
27432: PPUSH
27433: PPUSH
27434: PPUSH
27435: PPUSH
27436: PPUSH
27437: PPUSH
27438: PPUSH
27439: PPUSH
27440: PPUSH
27441: PPUSH
27442: PPUSH
27443: PPUSH
27444: PPUSH
// result := false ;
27445: LD_ADDR_VAR 0 3
27449: PUSH
27450: LD_INT 0
27452: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
27453: LD_VAR 0 1
27457: NOT
27458: PUSH
27459: LD_VAR 0 1
27463: PPUSH
27464: CALL_OW 266
27468: PUSH
27469: LD_INT 32
27471: PUSH
27472: LD_INT 33
27474: PUSH
27475: EMPTY
27476: LIST
27477: LIST
27478: IN
27479: NOT
27480: OR
27481: IFFALSE 27485
// exit ;
27483: GO 28621
// nat := GetNation ( tower ) ;
27485: LD_ADDR_VAR 0 12
27489: PUSH
27490: LD_VAR 0 1
27494: PPUSH
27495: CALL_OW 248
27499: ST_TO_ADDR
// side := GetSide ( tower ) ;
27500: LD_ADDR_VAR 0 16
27504: PUSH
27505: LD_VAR 0 1
27509: PPUSH
27510: CALL_OW 255
27514: ST_TO_ADDR
// x := GetX ( tower ) ;
27515: LD_ADDR_VAR 0 10
27519: PUSH
27520: LD_VAR 0 1
27524: PPUSH
27525: CALL_OW 250
27529: ST_TO_ADDR
// y := GetY ( tower ) ;
27530: LD_ADDR_VAR 0 11
27534: PUSH
27535: LD_VAR 0 1
27539: PPUSH
27540: CALL_OW 251
27544: ST_TO_ADDR
// if not x or not y then
27545: LD_VAR 0 10
27549: NOT
27550: PUSH
27551: LD_VAR 0 11
27555: NOT
27556: OR
27557: IFFALSE 27561
// exit ;
27559: GO 28621
// weapon := 0 ;
27561: LD_ADDR_VAR 0 18
27565: PUSH
27566: LD_INT 0
27568: ST_TO_ADDR
// fac_list := [ ] ;
27569: LD_ADDR_VAR 0 17
27573: PUSH
27574: EMPTY
27575: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
27576: LD_ADDR_VAR 0 6
27580: PUSH
27581: LD_VAR 0 1
27585: PPUSH
27586: CALL_OW 274
27590: PPUSH
27591: LD_VAR 0 2
27595: PPUSH
27596: CALL 25199 0 2
27600: PPUSH
27601: LD_INT 30
27603: PUSH
27604: LD_INT 3
27606: PUSH
27607: EMPTY
27608: LIST
27609: LIST
27610: PPUSH
27611: CALL_OW 72
27615: ST_TO_ADDR
// if not factories then
27616: LD_VAR 0 6
27620: NOT
27621: IFFALSE 27625
// exit ;
27623: GO 28621
// for i in factories do
27625: LD_ADDR_VAR 0 8
27629: PUSH
27630: LD_VAR 0 6
27634: PUSH
27635: FOR_IN
27636: IFFALSE 27661
// fac_list := fac_list union AvailableWeaponList ( i ) ;
27638: LD_ADDR_VAR 0 17
27642: PUSH
27643: LD_VAR 0 17
27647: PUSH
27648: LD_VAR 0 8
27652: PPUSH
27653: CALL_OW 478
27657: UNION
27658: ST_TO_ADDR
27659: GO 27635
27661: POP
27662: POP
// if not fac_list then
27663: LD_VAR 0 17
27667: NOT
27668: IFFALSE 27672
// exit ;
27670: GO 28621
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27672: LD_ADDR_VAR 0 5
27676: PUSH
27677: LD_INT 4
27679: PUSH
27680: LD_INT 5
27682: PUSH
27683: LD_INT 9
27685: PUSH
27686: LD_INT 10
27688: PUSH
27689: LD_INT 6
27691: PUSH
27692: LD_INT 7
27694: PUSH
27695: LD_INT 11
27697: PUSH
27698: EMPTY
27699: LIST
27700: LIST
27701: LIST
27702: LIST
27703: LIST
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 27
27709: PUSH
27710: LD_INT 28
27712: PUSH
27713: LD_INT 26
27715: PUSH
27716: LD_INT 30
27718: PUSH
27719: EMPTY
27720: LIST
27721: LIST
27722: LIST
27723: LIST
27724: PUSH
27725: LD_INT 43
27727: PUSH
27728: LD_INT 44
27730: PUSH
27731: LD_INT 46
27733: PUSH
27734: LD_INT 45
27736: PUSH
27737: LD_INT 47
27739: PUSH
27740: LD_INT 49
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: LIST
27747: LIST
27748: LIST
27749: LIST
27750: PUSH
27751: EMPTY
27752: LIST
27753: LIST
27754: LIST
27755: PUSH
27756: LD_VAR 0 12
27760: ARRAY
27761: ST_TO_ADDR
// for i in list do
27762: LD_ADDR_VAR 0 8
27766: PUSH
27767: LD_VAR 0 5
27771: PUSH
27772: FOR_IN
27773: IFFALSE 27806
// if not i in fac_list then
27775: LD_VAR 0 8
27779: PUSH
27780: LD_VAR 0 17
27784: IN
27785: NOT
27786: IFFALSE 27804
// list := list diff i ;
27788: LD_ADDR_VAR 0 5
27792: PUSH
27793: LD_VAR 0 5
27797: PUSH
27798: LD_VAR 0 8
27802: DIFF
27803: ST_TO_ADDR
27804: GO 27772
27806: POP
27807: POP
// if not list then
27808: LD_VAR 0 5
27812: NOT
27813: IFFALSE 27817
// exit ;
27815: GO 28621
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27817: LD_VAR 0 12
27821: PUSH
27822: LD_INT 3
27824: EQUAL
27825: PUSH
27826: LD_INT 49
27828: PUSH
27829: LD_VAR 0 5
27833: IN
27834: AND
27835: PUSH
27836: LD_INT 31
27838: PPUSH
27839: LD_VAR 0 16
27843: PPUSH
27844: CALL_OW 321
27848: PUSH
27849: LD_INT 2
27851: EQUAL
27852: AND
27853: IFFALSE 27913
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
27855: LD_INT 22
27857: PUSH
27858: LD_VAR 0 16
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: LD_INT 35
27869: PUSH
27870: LD_INT 49
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 91
27879: PUSH
27880: LD_VAR 0 1
27884: PUSH
27885: LD_INT 10
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: LIST
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: LIST
27897: PPUSH
27898: CALL_OW 69
27902: NOT
27903: IFFALSE 27913
// weapon := ru_time_lapser ;
27905: LD_ADDR_VAR 0 18
27909: PUSH
27910: LD_INT 49
27912: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27913: LD_VAR 0 12
27917: PUSH
27918: LD_INT 1
27920: PUSH
27921: LD_INT 2
27923: PUSH
27924: EMPTY
27925: LIST
27926: LIST
27927: IN
27928: PUSH
27929: LD_INT 11
27931: PUSH
27932: LD_VAR 0 5
27936: IN
27937: PUSH
27938: LD_INT 30
27940: PUSH
27941: LD_VAR 0 5
27945: IN
27946: OR
27947: AND
27948: PUSH
27949: LD_INT 6
27951: PPUSH
27952: LD_VAR 0 16
27956: PPUSH
27957: CALL_OW 321
27961: PUSH
27962: LD_INT 2
27964: EQUAL
27965: AND
27966: IFFALSE 28131
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
27968: LD_INT 22
27970: PUSH
27971: LD_VAR 0 16
27975: PUSH
27976: EMPTY
27977: LIST
27978: LIST
27979: PUSH
27980: LD_INT 2
27982: PUSH
27983: LD_INT 35
27985: PUSH
27986: LD_INT 11
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: PUSH
27993: LD_INT 35
27995: PUSH
27996: LD_INT 30
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: LIST
28007: PUSH
28008: LD_INT 91
28010: PUSH
28011: LD_VAR 0 1
28015: PUSH
28016: LD_INT 18
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: LIST
28023: PUSH
28024: EMPTY
28025: LIST
28026: LIST
28027: LIST
28028: PPUSH
28029: CALL_OW 69
28033: NOT
28034: PUSH
28035: LD_INT 22
28037: PUSH
28038: LD_VAR 0 16
28042: PUSH
28043: EMPTY
28044: LIST
28045: LIST
28046: PUSH
28047: LD_INT 2
28049: PUSH
28050: LD_INT 30
28052: PUSH
28053: LD_INT 32
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: LD_INT 30
28062: PUSH
28063: LD_INT 33
28065: PUSH
28066: EMPTY
28067: LIST
28068: LIST
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: LIST
28074: PUSH
28075: LD_INT 91
28077: PUSH
28078: LD_VAR 0 1
28082: PUSH
28083: LD_INT 12
28085: PUSH
28086: EMPTY
28087: LIST
28088: LIST
28089: LIST
28090: PUSH
28091: EMPTY
28092: LIST
28093: LIST
28094: LIST
28095: PUSH
28096: EMPTY
28097: LIST
28098: PPUSH
28099: CALL_OW 69
28103: PUSH
28104: LD_INT 2
28106: GREATER
28107: AND
28108: IFFALSE 28131
// weapon := [ us_radar , ar_radar ] [ nat ] ;
28110: LD_ADDR_VAR 0 18
28114: PUSH
28115: LD_INT 11
28117: PUSH
28118: LD_INT 30
28120: PUSH
28121: EMPTY
28122: LIST
28123: LIST
28124: PUSH
28125: LD_VAR 0 12
28129: ARRAY
28130: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
28131: LD_VAR 0 18
28135: NOT
28136: PUSH
28137: LD_INT 40
28139: PPUSH
28140: LD_VAR 0 16
28144: PPUSH
28145: CALL_OW 321
28149: PUSH
28150: LD_INT 2
28152: EQUAL
28153: AND
28154: PUSH
28155: LD_INT 7
28157: PUSH
28158: LD_VAR 0 5
28162: IN
28163: PUSH
28164: LD_INT 28
28166: PUSH
28167: LD_VAR 0 5
28171: IN
28172: OR
28173: PUSH
28174: LD_INT 45
28176: PUSH
28177: LD_VAR 0 5
28181: IN
28182: OR
28183: AND
28184: IFFALSE 28438
// begin hex := GetHexInfo ( x , y ) ;
28186: LD_ADDR_VAR 0 4
28190: PUSH
28191: LD_VAR 0 10
28195: PPUSH
28196: LD_VAR 0 11
28200: PPUSH
28201: CALL_OW 546
28205: ST_TO_ADDR
// if hex [ 1 ] then
28206: LD_VAR 0 4
28210: PUSH
28211: LD_INT 1
28213: ARRAY
28214: IFFALSE 28218
// exit ;
28216: GO 28621
// height := hex [ 2 ] ;
28218: LD_ADDR_VAR 0 15
28222: PUSH
28223: LD_VAR 0 4
28227: PUSH
28228: LD_INT 2
28230: ARRAY
28231: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
28232: LD_ADDR_VAR 0 14
28236: PUSH
28237: LD_INT 0
28239: PUSH
28240: LD_INT 2
28242: PUSH
28243: LD_INT 3
28245: PUSH
28246: LD_INT 5
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: ST_TO_ADDR
// for i in tmp do
28255: LD_ADDR_VAR 0 8
28259: PUSH
28260: LD_VAR 0 14
28264: PUSH
28265: FOR_IN
28266: IFFALSE 28436
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
28268: LD_ADDR_VAR 0 9
28272: PUSH
28273: LD_VAR 0 10
28277: PPUSH
28278: LD_VAR 0 8
28282: PPUSH
28283: LD_INT 5
28285: PPUSH
28286: CALL_OW 272
28290: PUSH
28291: LD_VAR 0 11
28295: PPUSH
28296: LD_VAR 0 8
28300: PPUSH
28301: LD_INT 5
28303: PPUSH
28304: CALL_OW 273
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
28313: LD_VAR 0 9
28317: PUSH
28318: LD_INT 1
28320: ARRAY
28321: PPUSH
28322: LD_VAR 0 9
28326: PUSH
28327: LD_INT 2
28329: ARRAY
28330: PPUSH
28331: CALL_OW 488
28335: IFFALSE 28434
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
28337: LD_ADDR_VAR 0 4
28341: PUSH
28342: LD_VAR 0 9
28346: PUSH
28347: LD_INT 1
28349: ARRAY
28350: PPUSH
28351: LD_VAR 0 9
28355: PUSH
28356: LD_INT 2
28358: ARRAY
28359: PPUSH
28360: CALL_OW 546
28364: ST_TO_ADDR
// if hex [ 1 ] then
28365: LD_VAR 0 4
28369: PUSH
28370: LD_INT 1
28372: ARRAY
28373: IFFALSE 28377
// continue ;
28375: GO 28265
// h := hex [ 2 ] ;
28377: LD_ADDR_VAR 0 13
28381: PUSH
28382: LD_VAR 0 4
28386: PUSH
28387: LD_INT 2
28389: ARRAY
28390: ST_TO_ADDR
// if h + 7 < height then
28391: LD_VAR 0 13
28395: PUSH
28396: LD_INT 7
28398: PLUS
28399: PUSH
28400: LD_VAR 0 15
28404: LESS
28405: IFFALSE 28434
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
28407: LD_ADDR_VAR 0 18
28411: PUSH
28412: LD_INT 7
28414: PUSH
28415: LD_INT 28
28417: PUSH
28418: LD_INT 45
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: LIST
28425: PUSH
28426: LD_VAR 0 12
28430: ARRAY
28431: ST_TO_ADDR
// break ;
28432: GO 28436
// end ; end ; end ;
28434: GO 28265
28436: POP
28437: POP
// end ; if not weapon then
28438: LD_VAR 0 18
28442: NOT
28443: IFFALSE 28503
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
28445: LD_ADDR_VAR 0 5
28449: PUSH
28450: LD_VAR 0 5
28454: PUSH
28455: LD_INT 11
28457: PUSH
28458: LD_INT 30
28460: PUSH
28461: LD_INT 49
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: LIST
28468: DIFF
28469: ST_TO_ADDR
// if not list then
28470: LD_VAR 0 5
28474: NOT
28475: IFFALSE 28479
// exit ;
28477: GO 28621
// weapon := list [ rand ( 1 , list ) ] ;
28479: LD_ADDR_VAR 0 18
28483: PUSH
28484: LD_VAR 0 5
28488: PUSH
28489: LD_INT 1
28491: PPUSH
28492: LD_VAR 0 5
28496: PPUSH
28497: CALL_OW 12
28501: ARRAY
28502: ST_TO_ADDR
// end ; if weapon then
28503: LD_VAR 0 18
28507: IFFALSE 28621
// begin tmp := CostOfWeapon ( weapon ) ;
28509: LD_ADDR_VAR 0 14
28513: PUSH
28514: LD_VAR 0 18
28518: PPUSH
28519: CALL_OW 451
28523: ST_TO_ADDR
// j := GetBase ( tower ) ;
28524: LD_ADDR_VAR 0 9
28528: PUSH
28529: LD_VAR 0 1
28533: PPUSH
28534: CALL_OW 274
28538: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
28539: LD_VAR 0 9
28543: PPUSH
28544: LD_INT 1
28546: PPUSH
28547: CALL_OW 275
28551: PUSH
28552: LD_VAR 0 14
28556: PUSH
28557: LD_INT 1
28559: ARRAY
28560: GREATEREQUAL
28561: PUSH
28562: LD_VAR 0 9
28566: PPUSH
28567: LD_INT 2
28569: PPUSH
28570: CALL_OW 275
28574: PUSH
28575: LD_VAR 0 14
28579: PUSH
28580: LD_INT 2
28582: ARRAY
28583: GREATEREQUAL
28584: AND
28585: PUSH
28586: LD_VAR 0 9
28590: PPUSH
28591: LD_INT 3
28593: PPUSH
28594: CALL_OW 275
28598: PUSH
28599: LD_VAR 0 14
28603: PUSH
28604: LD_INT 3
28606: ARRAY
28607: GREATEREQUAL
28608: AND
28609: IFFALSE 28621
// result := weapon ;
28611: LD_ADDR_VAR 0 3
28615: PUSH
28616: LD_VAR 0 18
28620: ST_TO_ADDR
// end ; end ;
28621: LD_VAR 0 3
28625: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
28626: LD_INT 0
28628: PPUSH
28629: PPUSH
// result := true ;
28630: LD_ADDR_VAR 0 3
28634: PUSH
28635: LD_INT 1
28637: ST_TO_ADDR
// if array1 = array2 then
28638: LD_VAR 0 1
28642: PUSH
28643: LD_VAR 0 2
28647: EQUAL
28648: IFFALSE 28708
// begin for i = 1 to array1 do
28650: LD_ADDR_VAR 0 4
28654: PUSH
28655: DOUBLE
28656: LD_INT 1
28658: DEC
28659: ST_TO_ADDR
28660: LD_VAR 0 1
28664: PUSH
28665: FOR_TO
28666: IFFALSE 28704
// if array1 [ i ] <> array2 [ i ] then
28668: LD_VAR 0 1
28672: PUSH
28673: LD_VAR 0 4
28677: ARRAY
28678: PUSH
28679: LD_VAR 0 2
28683: PUSH
28684: LD_VAR 0 4
28688: ARRAY
28689: NONEQUAL
28690: IFFALSE 28702
// begin result := false ;
28692: LD_ADDR_VAR 0 3
28696: PUSH
28697: LD_INT 0
28699: ST_TO_ADDR
// break ;
28700: GO 28704
// end ;
28702: GO 28665
28704: POP
28705: POP
// end else
28706: GO 28716
// result := false ;
28708: LD_ADDR_VAR 0 3
28712: PUSH
28713: LD_INT 0
28715: ST_TO_ADDR
// end ;
28716: LD_VAR 0 3
28720: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
28721: LD_INT 0
28723: PPUSH
28724: PPUSH
28725: PPUSH
// pom := GetBase ( fac ) ;
28726: LD_ADDR_VAR 0 5
28730: PUSH
28731: LD_VAR 0 1
28735: PPUSH
28736: CALL_OW 274
28740: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
28741: LD_ADDR_VAR 0 4
28745: PUSH
28746: LD_VAR 0 2
28750: PUSH
28751: LD_INT 1
28753: ARRAY
28754: PPUSH
28755: LD_VAR 0 2
28759: PUSH
28760: LD_INT 2
28762: ARRAY
28763: PPUSH
28764: LD_VAR 0 2
28768: PUSH
28769: LD_INT 3
28771: ARRAY
28772: PPUSH
28773: LD_VAR 0 2
28777: PUSH
28778: LD_INT 4
28780: ARRAY
28781: PPUSH
28782: CALL_OW 449
28786: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28787: LD_ADDR_VAR 0 3
28791: PUSH
28792: LD_VAR 0 5
28796: PPUSH
28797: LD_INT 1
28799: PPUSH
28800: CALL_OW 275
28804: PUSH
28805: LD_VAR 0 4
28809: PUSH
28810: LD_INT 1
28812: ARRAY
28813: GREATEREQUAL
28814: PUSH
28815: LD_VAR 0 5
28819: PPUSH
28820: LD_INT 2
28822: PPUSH
28823: CALL_OW 275
28827: PUSH
28828: LD_VAR 0 4
28832: PUSH
28833: LD_INT 2
28835: ARRAY
28836: GREATEREQUAL
28837: AND
28838: PUSH
28839: LD_VAR 0 5
28843: PPUSH
28844: LD_INT 3
28846: PPUSH
28847: CALL_OW 275
28851: PUSH
28852: LD_VAR 0 4
28856: PUSH
28857: LD_INT 3
28859: ARRAY
28860: GREATEREQUAL
28861: AND
28862: ST_TO_ADDR
// end ;
28863: LD_VAR 0 3
28867: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28868: LD_INT 0
28870: PPUSH
28871: PPUSH
28872: PPUSH
28873: PPUSH
// pom := GetBase ( building ) ;
28874: LD_ADDR_VAR 0 3
28878: PUSH
28879: LD_VAR 0 1
28883: PPUSH
28884: CALL_OW 274
28888: ST_TO_ADDR
// if not pom then
28889: LD_VAR 0 3
28893: NOT
28894: IFFALSE 28898
// exit ;
28896: GO 29068
// btype := GetBType ( building ) ;
28898: LD_ADDR_VAR 0 5
28902: PUSH
28903: LD_VAR 0 1
28907: PPUSH
28908: CALL_OW 266
28912: ST_TO_ADDR
// if btype = b_armoury then
28913: LD_VAR 0 5
28917: PUSH
28918: LD_INT 4
28920: EQUAL
28921: IFFALSE 28931
// btype := b_barracks ;
28923: LD_ADDR_VAR 0 5
28927: PUSH
28928: LD_INT 5
28930: ST_TO_ADDR
// if btype = b_depot then
28931: LD_VAR 0 5
28935: PUSH
28936: LD_INT 0
28938: EQUAL
28939: IFFALSE 28949
// btype := b_warehouse ;
28941: LD_ADDR_VAR 0 5
28945: PUSH
28946: LD_INT 1
28948: ST_TO_ADDR
// if btype = b_workshop then
28949: LD_VAR 0 5
28953: PUSH
28954: LD_INT 2
28956: EQUAL
28957: IFFALSE 28967
// btype := b_factory ;
28959: LD_ADDR_VAR 0 5
28963: PUSH
28964: LD_INT 3
28966: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
28967: LD_ADDR_VAR 0 4
28971: PUSH
28972: LD_VAR 0 5
28976: PPUSH
28977: LD_VAR 0 1
28981: PPUSH
28982: CALL_OW 248
28986: PPUSH
28987: CALL_OW 450
28991: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28992: LD_ADDR_VAR 0 2
28996: PUSH
28997: LD_VAR 0 3
29001: PPUSH
29002: LD_INT 1
29004: PPUSH
29005: CALL_OW 275
29009: PUSH
29010: LD_VAR 0 4
29014: PUSH
29015: LD_INT 1
29017: ARRAY
29018: GREATEREQUAL
29019: PUSH
29020: LD_VAR 0 3
29024: PPUSH
29025: LD_INT 2
29027: PPUSH
29028: CALL_OW 275
29032: PUSH
29033: LD_VAR 0 4
29037: PUSH
29038: LD_INT 2
29040: ARRAY
29041: GREATEREQUAL
29042: AND
29043: PUSH
29044: LD_VAR 0 3
29048: PPUSH
29049: LD_INT 3
29051: PPUSH
29052: CALL_OW 275
29056: PUSH
29057: LD_VAR 0 4
29061: PUSH
29062: LD_INT 3
29064: ARRAY
29065: GREATEREQUAL
29066: AND
29067: ST_TO_ADDR
// end ;
29068: LD_VAR 0 2
29072: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
29073: LD_INT 0
29075: PPUSH
29076: PPUSH
29077: PPUSH
// pom := GetBase ( building ) ;
29078: LD_ADDR_VAR 0 4
29082: PUSH
29083: LD_VAR 0 1
29087: PPUSH
29088: CALL_OW 274
29092: ST_TO_ADDR
// if not pom then
29093: LD_VAR 0 4
29097: NOT
29098: IFFALSE 29102
// exit ;
29100: GO 29203
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29102: LD_ADDR_VAR 0 5
29106: PUSH
29107: LD_VAR 0 2
29111: PPUSH
29112: LD_VAR 0 1
29116: PPUSH
29117: CALL_OW 248
29121: PPUSH
29122: CALL_OW 450
29126: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29127: LD_ADDR_VAR 0 3
29131: PUSH
29132: LD_VAR 0 4
29136: PPUSH
29137: LD_INT 1
29139: PPUSH
29140: CALL_OW 275
29144: PUSH
29145: LD_VAR 0 5
29149: PUSH
29150: LD_INT 1
29152: ARRAY
29153: GREATEREQUAL
29154: PUSH
29155: LD_VAR 0 4
29159: PPUSH
29160: LD_INT 2
29162: PPUSH
29163: CALL_OW 275
29167: PUSH
29168: LD_VAR 0 5
29172: PUSH
29173: LD_INT 2
29175: ARRAY
29176: GREATEREQUAL
29177: AND
29178: PUSH
29179: LD_VAR 0 4
29183: PPUSH
29184: LD_INT 3
29186: PPUSH
29187: CALL_OW 275
29191: PUSH
29192: LD_VAR 0 5
29196: PUSH
29197: LD_INT 3
29199: ARRAY
29200: GREATEREQUAL
29201: AND
29202: ST_TO_ADDR
// end ;
29203: LD_VAR 0 3
29207: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
29208: LD_INT 0
29210: PPUSH
29211: PPUSH
29212: PPUSH
29213: PPUSH
29214: PPUSH
29215: PPUSH
29216: PPUSH
29217: PPUSH
29218: PPUSH
29219: PPUSH
// result := false ;
29220: LD_ADDR_VAR 0 6
29224: PUSH
29225: LD_INT 0
29227: ST_TO_ADDR
// if not base or not btype or not x or not y then
29228: LD_VAR 0 1
29232: NOT
29233: PUSH
29234: LD_VAR 0 2
29238: NOT
29239: OR
29240: PUSH
29241: LD_VAR 0 3
29245: NOT
29246: OR
29247: PUSH
29248: LD_VAR 0 4
29252: NOT
29253: OR
29254: IFFALSE 29258
// exit ;
29256: GO 29867
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
29258: LD_ADDR_VAR 0 12
29262: PUSH
29263: LD_VAR 0 2
29267: PPUSH
29268: LD_VAR 0 3
29272: PPUSH
29273: LD_VAR 0 4
29277: PPUSH
29278: LD_VAR 0 5
29282: PPUSH
29283: LD_VAR 0 1
29287: PUSH
29288: LD_INT 1
29290: ARRAY
29291: PPUSH
29292: CALL_OW 248
29296: PPUSH
29297: LD_INT 0
29299: PPUSH
29300: CALL 30704 0 6
29304: ST_TO_ADDR
// if not hexes then
29305: LD_VAR 0 12
29309: NOT
29310: IFFALSE 29314
// exit ;
29312: GO 29867
// for i = 1 to hexes do
29314: LD_ADDR_VAR 0 7
29318: PUSH
29319: DOUBLE
29320: LD_INT 1
29322: DEC
29323: ST_TO_ADDR
29324: LD_VAR 0 12
29328: PUSH
29329: FOR_TO
29330: IFFALSE 29865
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29332: LD_ADDR_VAR 0 11
29336: PUSH
29337: LD_VAR 0 12
29341: PUSH
29342: LD_VAR 0 7
29346: ARRAY
29347: PUSH
29348: LD_INT 1
29350: ARRAY
29351: PPUSH
29352: LD_VAR 0 12
29356: PUSH
29357: LD_VAR 0 7
29361: ARRAY
29362: PUSH
29363: LD_INT 2
29365: ARRAY
29366: PPUSH
29367: CALL_OW 428
29371: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
29372: LD_VAR 0 12
29376: PUSH
29377: LD_VAR 0 7
29381: ARRAY
29382: PUSH
29383: LD_INT 1
29385: ARRAY
29386: PPUSH
29387: LD_VAR 0 12
29391: PUSH
29392: LD_VAR 0 7
29396: ARRAY
29397: PUSH
29398: LD_INT 2
29400: ARRAY
29401: PPUSH
29402: CALL_OW 351
29406: PUSH
29407: LD_VAR 0 12
29411: PUSH
29412: LD_VAR 0 7
29416: ARRAY
29417: PUSH
29418: LD_INT 1
29420: ARRAY
29421: PPUSH
29422: LD_VAR 0 12
29426: PUSH
29427: LD_VAR 0 7
29431: ARRAY
29432: PUSH
29433: LD_INT 2
29435: ARRAY
29436: PPUSH
29437: CALL_OW 488
29441: NOT
29442: OR
29443: PUSH
29444: LD_VAR 0 11
29448: PPUSH
29449: CALL_OW 247
29453: PUSH
29454: LD_INT 3
29456: EQUAL
29457: OR
29458: IFFALSE 29464
// exit ;
29460: POP
29461: POP
29462: GO 29867
// if not tmp or not tmp in base then
29464: LD_VAR 0 11
29468: NOT
29469: PUSH
29470: LD_VAR 0 11
29474: PUSH
29475: LD_VAR 0 1
29479: IN
29480: NOT
29481: OR
29482: IFFALSE 29486
// continue ;
29484: GO 29329
// result := true ;
29486: LD_ADDR_VAR 0 6
29490: PUSH
29491: LD_INT 1
29493: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29494: LD_ADDR_VAR 0 15
29498: PUSH
29499: LD_VAR 0 1
29503: PPUSH
29504: LD_INT 22
29506: PUSH
29507: LD_VAR 0 11
29511: PPUSH
29512: CALL_OW 255
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 2
29523: PUSH
29524: LD_INT 30
29526: PUSH
29527: LD_INT 0
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: LD_INT 30
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: LIST
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PPUSH
29553: CALL_OW 72
29557: ST_TO_ADDR
// if dep then
29558: LD_VAR 0 15
29562: IFFALSE 29698
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
29564: LD_ADDR_VAR 0 14
29568: PUSH
29569: LD_VAR 0 15
29573: PUSH
29574: LD_INT 1
29576: ARRAY
29577: PPUSH
29578: CALL_OW 250
29582: PPUSH
29583: LD_VAR 0 15
29587: PUSH
29588: LD_INT 1
29590: ARRAY
29591: PPUSH
29592: CALL_OW 254
29596: PPUSH
29597: LD_INT 5
29599: PPUSH
29600: CALL_OW 272
29604: PUSH
29605: LD_VAR 0 15
29609: PUSH
29610: LD_INT 1
29612: ARRAY
29613: PPUSH
29614: CALL_OW 251
29618: PPUSH
29619: LD_VAR 0 15
29623: PUSH
29624: LD_INT 1
29626: ARRAY
29627: PPUSH
29628: CALL_OW 254
29632: PPUSH
29633: LD_INT 5
29635: PPUSH
29636: CALL_OW 273
29640: PUSH
29641: EMPTY
29642: LIST
29643: LIST
29644: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
29645: LD_VAR 0 14
29649: PUSH
29650: LD_INT 1
29652: ARRAY
29653: PPUSH
29654: LD_VAR 0 14
29658: PUSH
29659: LD_INT 2
29661: ARRAY
29662: PPUSH
29663: CALL_OW 488
29667: IFFALSE 29698
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
29669: LD_VAR 0 11
29673: PPUSH
29674: LD_VAR 0 14
29678: PUSH
29679: LD_INT 1
29681: ARRAY
29682: PPUSH
29683: LD_VAR 0 14
29687: PUSH
29688: LD_INT 2
29690: ARRAY
29691: PPUSH
29692: CALL_OW 111
// continue ;
29696: GO 29329
// end ; end ; r := GetDir ( tmp ) ;
29698: LD_ADDR_VAR 0 13
29702: PUSH
29703: LD_VAR 0 11
29707: PPUSH
29708: CALL_OW 254
29712: ST_TO_ADDR
// if r = 5 then
29713: LD_VAR 0 13
29717: PUSH
29718: LD_INT 5
29720: EQUAL
29721: IFFALSE 29731
// r := 0 ;
29723: LD_ADDR_VAR 0 13
29727: PUSH
29728: LD_INT 0
29730: ST_TO_ADDR
// for j = r to 5 do
29731: LD_ADDR_VAR 0 8
29735: PUSH
29736: DOUBLE
29737: LD_VAR 0 13
29741: DEC
29742: ST_TO_ADDR
29743: LD_INT 5
29745: PUSH
29746: FOR_TO
29747: IFFALSE 29861
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
29749: LD_ADDR_VAR 0 9
29753: PUSH
29754: LD_VAR 0 11
29758: PPUSH
29759: CALL_OW 250
29763: PPUSH
29764: LD_VAR 0 8
29768: PPUSH
29769: LD_INT 2
29771: PPUSH
29772: CALL_OW 272
29776: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
29777: LD_ADDR_VAR 0 10
29781: PUSH
29782: LD_VAR 0 11
29786: PPUSH
29787: CALL_OW 251
29791: PPUSH
29792: LD_VAR 0 8
29796: PPUSH
29797: LD_INT 2
29799: PPUSH
29800: CALL_OW 273
29804: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
29805: LD_VAR 0 9
29809: PPUSH
29810: LD_VAR 0 10
29814: PPUSH
29815: CALL_OW 488
29819: PUSH
29820: LD_VAR 0 9
29824: PPUSH
29825: LD_VAR 0 10
29829: PPUSH
29830: CALL_OW 428
29834: NOT
29835: AND
29836: IFFALSE 29859
// begin ComMoveXY ( tmp , _x , _y ) ;
29838: LD_VAR 0 11
29842: PPUSH
29843: LD_VAR 0 9
29847: PPUSH
29848: LD_VAR 0 10
29852: PPUSH
29853: CALL_OW 111
// break ;
29857: GO 29861
// end ; end ;
29859: GO 29746
29861: POP
29862: POP
// end ;
29863: GO 29329
29865: POP
29866: POP
// end ;
29867: LD_VAR 0 6
29871: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
29872: LD_INT 0
29874: PPUSH
29875: PPUSH
29876: PPUSH
29877: PPUSH
29878: PPUSH
29879: PPUSH
29880: PPUSH
29881: PPUSH
29882: PPUSH
29883: PPUSH
// result := false ;
29884: LD_ADDR_VAR 0 6
29888: PUSH
29889: LD_INT 0
29891: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
29892: LD_VAR 0 1
29896: NOT
29897: PUSH
29898: LD_VAR 0 1
29902: PPUSH
29903: CALL_OW 266
29907: PUSH
29908: LD_INT 0
29910: PUSH
29911: LD_INT 1
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: IN
29918: NOT
29919: OR
29920: PUSH
29921: LD_VAR 0 2
29925: NOT
29926: OR
29927: PUSH
29928: LD_VAR 0 5
29932: PUSH
29933: LD_INT 0
29935: PUSH
29936: LD_INT 1
29938: PUSH
29939: LD_INT 2
29941: PUSH
29942: LD_INT 3
29944: PUSH
29945: LD_INT 4
29947: PUSH
29948: LD_INT 5
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: LIST
29955: LIST
29956: LIST
29957: LIST
29958: IN
29959: NOT
29960: OR
29961: PUSH
29962: LD_VAR 0 3
29966: PPUSH
29967: LD_VAR 0 4
29971: PPUSH
29972: CALL_OW 488
29976: NOT
29977: OR
29978: IFFALSE 29982
// exit ;
29980: GO 30699
// pom := GetBase ( depot ) ;
29982: LD_ADDR_VAR 0 10
29986: PUSH
29987: LD_VAR 0 1
29991: PPUSH
29992: CALL_OW 274
29996: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
29997: LD_ADDR_VAR 0 11
30001: PUSH
30002: LD_VAR 0 2
30006: PPUSH
30007: LD_VAR 0 1
30011: PPUSH
30012: CALL_OW 248
30016: PPUSH
30017: CALL_OW 450
30021: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30022: LD_VAR 0 10
30026: PPUSH
30027: LD_INT 1
30029: PPUSH
30030: CALL_OW 275
30034: PUSH
30035: LD_VAR 0 11
30039: PUSH
30040: LD_INT 1
30042: ARRAY
30043: GREATEREQUAL
30044: PUSH
30045: LD_VAR 0 10
30049: PPUSH
30050: LD_INT 2
30052: PPUSH
30053: CALL_OW 275
30057: PUSH
30058: LD_VAR 0 11
30062: PUSH
30063: LD_INT 2
30065: ARRAY
30066: GREATEREQUAL
30067: AND
30068: PUSH
30069: LD_VAR 0 10
30073: PPUSH
30074: LD_INT 3
30076: PPUSH
30077: CALL_OW 275
30081: PUSH
30082: LD_VAR 0 11
30086: PUSH
30087: LD_INT 3
30089: ARRAY
30090: GREATEREQUAL
30091: AND
30092: NOT
30093: IFFALSE 30097
// exit ;
30095: GO 30699
// if GetBType ( depot ) = b_depot then
30097: LD_VAR 0 1
30101: PPUSH
30102: CALL_OW 266
30106: PUSH
30107: LD_INT 0
30109: EQUAL
30110: IFFALSE 30122
// dist := 28 else
30112: LD_ADDR_VAR 0 14
30116: PUSH
30117: LD_INT 28
30119: ST_TO_ADDR
30120: GO 30130
// dist := 36 ;
30122: LD_ADDR_VAR 0 14
30126: PUSH
30127: LD_INT 36
30129: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
30130: LD_VAR 0 1
30134: PPUSH
30135: LD_VAR 0 3
30139: PPUSH
30140: LD_VAR 0 4
30144: PPUSH
30145: CALL_OW 297
30149: PUSH
30150: LD_VAR 0 14
30154: GREATER
30155: IFFALSE 30159
// exit ;
30157: GO 30699
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
30159: LD_ADDR_VAR 0 12
30163: PUSH
30164: LD_VAR 0 2
30168: PPUSH
30169: LD_VAR 0 3
30173: PPUSH
30174: LD_VAR 0 4
30178: PPUSH
30179: LD_VAR 0 5
30183: PPUSH
30184: LD_VAR 0 1
30188: PPUSH
30189: CALL_OW 248
30193: PPUSH
30194: LD_INT 0
30196: PPUSH
30197: CALL 30704 0 6
30201: ST_TO_ADDR
// if not hexes then
30202: LD_VAR 0 12
30206: NOT
30207: IFFALSE 30211
// exit ;
30209: GO 30699
// hex := GetHexInfo ( x , y ) ;
30211: LD_ADDR_VAR 0 15
30215: PUSH
30216: LD_VAR 0 3
30220: PPUSH
30221: LD_VAR 0 4
30225: PPUSH
30226: CALL_OW 546
30230: ST_TO_ADDR
// if hex [ 1 ] then
30231: LD_VAR 0 15
30235: PUSH
30236: LD_INT 1
30238: ARRAY
30239: IFFALSE 30243
// exit ;
30241: GO 30699
// height := hex [ 2 ] ;
30243: LD_ADDR_VAR 0 13
30247: PUSH
30248: LD_VAR 0 15
30252: PUSH
30253: LD_INT 2
30255: ARRAY
30256: ST_TO_ADDR
// for i = 1 to hexes do
30257: LD_ADDR_VAR 0 7
30261: PUSH
30262: DOUBLE
30263: LD_INT 1
30265: DEC
30266: ST_TO_ADDR
30267: LD_VAR 0 12
30271: PUSH
30272: FOR_TO
30273: IFFALSE 30603
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
30275: LD_VAR 0 12
30279: PUSH
30280: LD_VAR 0 7
30284: ARRAY
30285: PUSH
30286: LD_INT 1
30288: ARRAY
30289: PPUSH
30290: LD_VAR 0 12
30294: PUSH
30295: LD_VAR 0 7
30299: ARRAY
30300: PUSH
30301: LD_INT 2
30303: ARRAY
30304: PPUSH
30305: CALL_OW 488
30309: NOT
30310: PUSH
30311: LD_VAR 0 12
30315: PUSH
30316: LD_VAR 0 7
30320: ARRAY
30321: PUSH
30322: LD_INT 1
30324: ARRAY
30325: PPUSH
30326: LD_VAR 0 12
30330: PUSH
30331: LD_VAR 0 7
30335: ARRAY
30336: PUSH
30337: LD_INT 2
30339: ARRAY
30340: PPUSH
30341: CALL_OW 428
30345: PUSH
30346: LD_INT 0
30348: GREATER
30349: OR
30350: PUSH
30351: LD_VAR 0 12
30355: PUSH
30356: LD_VAR 0 7
30360: ARRAY
30361: PUSH
30362: LD_INT 1
30364: ARRAY
30365: PPUSH
30366: LD_VAR 0 12
30370: PUSH
30371: LD_VAR 0 7
30375: ARRAY
30376: PUSH
30377: LD_INT 2
30379: ARRAY
30380: PPUSH
30381: CALL_OW 351
30385: OR
30386: IFFALSE 30392
// exit ;
30388: POP
30389: POP
30390: GO 30699
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30392: LD_ADDR_VAR 0 8
30396: PUSH
30397: LD_VAR 0 12
30401: PUSH
30402: LD_VAR 0 7
30406: ARRAY
30407: PUSH
30408: LD_INT 1
30410: ARRAY
30411: PPUSH
30412: LD_VAR 0 12
30416: PUSH
30417: LD_VAR 0 7
30421: ARRAY
30422: PUSH
30423: LD_INT 2
30425: ARRAY
30426: PPUSH
30427: CALL_OW 546
30431: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
30432: LD_VAR 0 8
30436: PUSH
30437: LD_INT 1
30439: ARRAY
30440: PUSH
30441: LD_VAR 0 8
30445: PUSH
30446: LD_INT 2
30448: ARRAY
30449: PUSH
30450: LD_VAR 0 13
30454: PUSH
30455: LD_INT 2
30457: PLUS
30458: GREATER
30459: OR
30460: PUSH
30461: LD_VAR 0 8
30465: PUSH
30466: LD_INT 2
30468: ARRAY
30469: PUSH
30470: LD_VAR 0 13
30474: PUSH
30475: LD_INT 2
30477: MINUS
30478: LESS
30479: OR
30480: PUSH
30481: LD_VAR 0 8
30485: PUSH
30486: LD_INT 3
30488: ARRAY
30489: PUSH
30490: LD_INT 0
30492: PUSH
30493: LD_INT 8
30495: PUSH
30496: LD_INT 9
30498: PUSH
30499: LD_INT 10
30501: PUSH
30502: LD_INT 11
30504: PUSH
30505: LD_INT 12
30507: PUSH
30508: LD_INT 13
30510: PUSH
30511: LD_INT 16
30513: PUSH
30514: LD_INT 17
30516: PUSH
30517: LD_INT 18
30519: PUSH
30520: LD_INT 19
30522: PUSH
30523: LD_INT 20
30525: PUSH
30526: LD_INT 21
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: LIST
30539: LIST
30540: LIST
30541: LIST
30542: LIST
30543: IN
30544: NOT
30545: OR
30546: PUSH
30547: LD_VAR 0 8
30551: PUSH
30552: LD_INT 5
30554: ARRAY
30555: NOT
30556: OR
30557: PUSH
30558: LD_VAR 0 8
30562: PUSH
30563: LD_INT 6
30565: ARRAY
30566: PUSH
30567: LD_INT 1
30569: PUSH
30570: LD_INT 2
30572: PUSH
30573: LD_INT 7
30575: PUSH
30576: LD_INT 9
30578: PUSH
30579: LD_INT 10
30581: PUSH
30582: LD_INT 11
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: IN
30593: NOT
30594: OR
30595: IFFALSE 30601
// exit ;
30597: POP
30598: POP
30599: GO 30699
// end ;
30601: GO 30272
30603: POP
30604: POP
// side := GetSide ( depot ) ;
30605: LD_ADDR_VAR 0 9
30609: PUSH
30610: LD_VAR 0 1
30614: PPUSH
30615: CALL_OW 255
30619: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30620: LD_VAR 0 9
30624: PPUSH
30625: LD_VAR 0 3
30629: PPUSH
30630: LD_VAR 0 4
30634: PPUSH
30635: LD_INT 20
30637: PPUSH
30638: CALL 23353 0 4
30642: PUSH
30643: LD_INT 4
30645: ARRAY
30646: IFFALSE 30650
// exit ;
30648: GO 30699
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
30650: LD_VAR 0 2
30654: PUSH
30655: LD_INT 29
30657: PUSH
30658: LD_INT 30
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: IN
30665: PUSH
30666: LD_VAR 0 3
30670: PPUSH
30671: LD_VAR 0 4
30675: PPUSH
30676: LD_VAR 0 9
30680: PPUSH
30681: CALL_OW 440
30685: NOT
30686: AND
30687: IFFALSE 30691
// exit ;
30689: GO 30699
// result := true ;
30691: LD_ADDR_VAR 0 6
30695: PUSH
30696: LD_INT 1
30698: ST_TO_ADDR
// end ;
30699: LD_VAR 0 6
30703: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
30704: LD_INT 0
30706: PPUSH
30707: PPUSH
30708: PPUSH
30709: PPUSH
30710: PPUSH
30711: PPUSH
30712: PPUSH
30713: PPUSH
30714: PPUSH
30715: PPUSH
30716: PPUSH
30717: PPUSH
30718: PPUSH
30719: PPUSH
30720: PPUSH
30721: PPUSH
30722: PPUSH
30723: PPUSH
30724: PPUSH
30725: PPUSH
30726: PPUSH
30727: PPUSH
30728: PPUSH
30729: PPUSH
30730: PPUSH
30731: PPUSH
30732: PPUSH
30733: PPUSH
30734: PPUSH
30735: PPUSH
30736: PPUSH
30737: PPUSH
30738: PPUSH
30739: PPUSH
30740: PPUSH
30741: PPUSH
30742: PPUSH
30743: PPUSH
30744: PPUSH
30745: PPUSH
30746: PPUSH
30747: PPUSH
30748: PPUSH
30749: PPUSH
30750: PPUSH
30751: PPUSH
30752: PPUSH
30753: PPUSH
30754: PPUSH
30755: PPUSH
30756: PPUSH
30757: PPUSH
30758: PPUSH
30759: PPUSH
30760: PPUSH
30761: PPUSH
30762: PPUSH
30763: PPUSH
// result = [ ] ;
30764: LD_ADDR_VAR 0 7
30768: PUSH
30769: EMPTY
30770: ST_TO_ADDR
// temp_list = [ ] ;
30771: LD_ADDR_VAR 0 9
30775: PUSH
30776: EMPTY
30777: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
30778: LD_VAR 0 4
30782: PUSH
30783: LD_INT 0
30785: PUSH
30786: LD_INT 1
30788: PUSH
30789: LD_INT 2
30791: PUSH
30792: LD_INT 3
30794: PUSH
30795: LD_INT 4
30797: PUSH
30798: LD_INT 5
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: IN
30809: NOT
30810: PUSH
30811: LD_VAR 0 1
30815: PUSH
30816: LD_INT 0
30818: PUSH
30819: LD_INT 1
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: IN
30826: PUSH
30827: LD_VAR 0 5
30831: PUSH
30832: LD_INT 1
30834: PUSH
30835: LD_INT 2
30837: PUSH
30838: LD_INT 3
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: LIST
30845: IN
30846: NOT
30847: AND
30848: OR
30849: IFFALSE 30853
// exit ;
30851: GO 49244
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
30853: LD_VAR 0 1
30857: PUSH
30858: LD_INT 6
30860: PUSH
30861: LD_INT 7
30863: PUSH
30864: LD_INT 8
30866: PUSH
30867: LD_INT 13
30869: PUSH
30870: LD_INT 12
30872: PUSH
30873: LD_INT 15
30875: PUSH
30876: LD_INT 11
30878: PUSH
30879: LD_INT 14
30881: PUSH
30882: LD_INT 10
30884: PUSH
30885: EMPTY
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: LIST
30893: LIST
30894: LIST
30895: IN
30896: IFFALSE 30906
// btype = b_lab ;
30898: LD_ADDR_VAR 0 1
30902: PUSH
30903: LD_INT 6
30905: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
30906: LD_VAR 0 6
30910: PUSH
30911: LD_INT 0
30913: PUSH
30914: LD_INT 1
30916: PUSH
30917: LD_INT 2
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: LIST
30924: IN
30925: NOT
30926: PUSH
30927: LD_VAR 0 1
30931: PUSH
30932: LD_INT 0
30934: PUSH
30935: LD_INT 1
30937: PUSH
30938: LD_INT 2
30940: PUSH
30941: LD_INT 3
30943: PUSH
30944: LD_INT 6
30946: PUSH
30947: LD_INT 36
30949: PUSH
30950: LD_INT 4
30952: PUSH
30953: LD_INT 5
30955: PUSH
30956: LD_INT 31
30958: PUSH
30959: LD_INT 32
30961: PUSH
30962: LD_INT 33
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: IN
30978: NOT
30979: PUSH
30980: LD_VAR 0 6
30984: PUSH
30985: LD_INT 1
30987: EQUAL
30988: AND
30989: OR
30990: PUSH
30991: LD_VAR 0 1
30995: PUSH
30996: LD_INT 2
30998: PUSH
30999: LD_INT 3
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: IN
31006: NOT
31007: PUSH
31008: LD_VAR 0 6
31012: PUSH
31013: LD_INT 2
31015: EQUAL
31016: AND
31017: OR
31018: IFFALSE 31028
// mode = 0 ;
31020: LD_ADDR_VAR 0 6
31024: PUSH
31025: LD_INT 0
31027: ST_TO_ADDR
// case mode of 0 :
31028: LD_VAR 0 6
31032: PUSH
31033: LD_INT 0
31035: DOUBLE
31036: EQUAL
31037: IFTRUE 31041
31039: GO 42494
31041: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31042: LD_ADDR_VAR 0 11
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: LD_INT 0
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: LD_INT 1
31062: NEG
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 1
31070: PUSH
31071: LD_INT 0
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 1
31080: PUSH
31081: LD_INT 1
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 0
31090: PUSH
31091: LD_INT 1
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: NEG
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: NEG
31112: PUSH
31113: LD_INT 1
31115: NEG
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 1
31123: NEG
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: LD_INT 2
31138: NEG
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: PUSH
31144: LD_INT 1
31146: PUSH
31147: LD_INT 1
31149: NEG
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 1
31157: PUSH
31158: LD_INT 2
31160: PUSH
31161: EMPTY
31162: LIST
31163: LIST
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: LD_INT 2
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 1
31177: NEG
31178: PUSH
31179: LD_INT 1
31181: PUSH
31182: EMPTY
31183: LIST
31184: LIST
31185: PUSH
31186: LD_INT 1
31188: PUSH
31189: LD_INT 3
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 0
31198: PUSH
31199: LD_INT 3
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 1
31208: NEG
31209: PUSH
31210: LD_INT 2
31212: PUSH
31213: EMPTY
31214: LIST
31215: LIST
31216: PUSH
31217: EMPTY
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: LIST
31223: LIST
31224: LIST
31225: LIST
31226: LIST
31227: LIST
31228: LIST
31229: LIST
31230: LIST
31231: LIST
31232: LIST
31233: LIST
31234: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31235: LD_ADDR_VAR 0 12
31239: PUSH
31240: LD_INT 0
31242: PUSH
31243: LD_INT 0
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 0
31252: PUSH
31253: LD_INT 1
31255: NEG
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 1
31263: PUSH
31264: LD_INT 0
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 1
31273: PUSH
31274: LD_INT 1
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 0
31283: PUSH
31284: LD_INT 1
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 1
31293: NEG
31294: PUSH
31295: LD_INT 0
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 1
31304: NEG
31305: PUSH
31306: LD_INT 1
31308: NEG
31309: PUSH
31310: EMPTY
31311: LIST
31312: LIST
31313: PUSH
31314: LD_INT 1
31316: PUSH
31317: LD_INT 1
31319: NEG
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: LD_INT 2
31327: PUSH
31328: LD_INT 0
31330: PUSH
31331: EMPTY
31332: LIST
31333: LIST
31334: PUSH
31335: LD_INT 2
31337: PUSH
31338: LD_INT 1
31340: PUSH
31341: EMPTY
31342: LIST
31343: LIST
31344: PUSH
31345: LD_INT 1
31347: NEG
31348: PUSH
31349: LD_INT 1
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 2
31358: NEG
31359: PUSH
31360: LD_INT 0
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: LD_INT 2
31369: NEG
31370: PUSH
31371: LD_INT 1
31373: NEG
31374: PUSH
31375: EMPTY
31376: LIST
31377: LIST
31378: PUSH
31379: LD_INT 2
31381: NEG
31382: PUSH
31383: LD_INT 1
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: PUSH
31390: LD_INT 3
31392: NEG
31393: PUSH
31394: LD_INT 0
31396: PUSH
31397: EMPTY
31398: LIST
31399: LIST
31400: PUSH
31401: LD_INT 3
31403: NEG
31404: PUSH
31405: LD_INT 1
31407: NEG
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: LIST
31417: LIST
31418: LIST
31419: LIST
31420: LIST
31421: LIST
31422: LIST
31423: LIST
31424: LIST
31425: LIST
31426: LIST
31427: LIST
31428: LIST
31429: LIST
31430: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31431: LD_ADDR_VAR 0 13
31435: PUSH
31436: LD_INT 0
31438: PUSH
31439: LD_INT 0
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 0
31448: PUSH
31449: LD_INT 1
31451: NEG
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: LD_INT 1
31459: PUSH
31460: LD_INT 0
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 1
31469: PUSH
31470: LD_INT 1
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 0
31479: PUSH
31480: LD_INT 1
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: NEG
31490: PUSH
31491: LD_INT 0
31493: PUSH
31494: EMPTY
31495: LIST
31496: LIST
31497: PUSH
31498: LD_INT 1
31500: NEG
31501: PUSH
31502: LD_INT 1
31504: NEG
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 1
31512: NEG
31513: PUSH
31514: LD_INT 2
31516: NEG
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: PUSH
31522: LD_INT 2
31524: PUSH
31525: LD_INT 1
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 2
31534: PUSH
31535: LD_INT 2
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 1
31544: PUSH
31545: LD_INT 2
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 2
31554: NEG
31555: PUSH
31556: LD_INT 1
31558: NEG
31559: PUSH
31560: EMPTY
31561: LIST
31562: LIST
31563: PUSH
31564: LD_INT 2
31566: NEG
31567: PUSH
31568: LD_INT 2
31570: NEG
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 2
31578: NEG
31579: PUSH
31580: LD_INT 3
31582: NEG
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 3
31590: NEG
31591: PUSH
31592: LD_INT 2
31594: NEG
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 3
31602: NEG
31603: PUSH
31604: LD_INT 3
31606: NEG
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: LIST
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31630: LD_ADDR_VAR 0 14
31634: PUSH
31635: LD_INT 0
31637: PUSH
31638: LD_INT 0
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: PUSH
31645: LD_INT 0
31647: PUSH
31648: LD_INT 1
31650: NEG
31651: PUSH
31652: EMPTY
31653: LIST
31654: LIST
31655: PUSH
31656: LD_INT 1
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: EMPTY
31663: LIST
31664: LIST
31665: PUSH
31666: LD_INT 1
31668: PUSH
31669: LD_INT 1
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 0
31678: PUSH
31679: LD_INT 1
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 1
31688: NEG
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 1
31699: NEG
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 1
31711: NEG
31712: PUSH
31713: LD_INT 2
31715: NEG
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: LD_INT 2
31726: NEG
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 1
31734: PUSH
31735: LD_INT 1
31737: NEG
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 1
31745: PUSH
31746: LD_INT 2
31748: PUSH
31749: EMPTY
31750: LIST
31751: LIST
31752: PUSH
31753: LD_INT 0
31755: PUSH
31756: LD_INT 2
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 1
31765: NEG
31766: PUSH
31767: LD_INT 1
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 1
31776: NEG
31777: PUSH
31778: LD_INT 3
31780: NEG
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: LD_INT 3
31791: NEG
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 1
31799: PUSH
31800: LD_INT 2
31802: NEG
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: LIST
31812: LIST
31813: LIST
31814: LIST
31815: LIST
31816: LIST
31817: LIST
31818: LIST
31819: LIST
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: LIST
31825: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31826: LD_ADDR_VAR 0 15
31830: PUSH
31831: LD_INT 0
31833: PUSH
31834: LD_INT 0
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 0
31843: PUSH
31844: LD_INT 1
31846: NEG
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 1
31854: PUSH
31855: LD_INT 0
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 1
31864: PUSH
31865: LD_INT 1
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: LD_INT 1
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: NEG
31885: PUSH
31886: LD_INT 0
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 1
31895: NEG
31896: PUSH
31897: LD_INT 1
31899: NEG
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: PUSH
31908: LD_INT 1
31910: NEG
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 2
31918: PUSH
31919: LD_INT 0
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 2
31928: PUSH
31929: LD_INT 1
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: NEG
31939: PUSH
31940: LD_INT 1
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 2
31949: NEG
31950: PUSH
31951: LD_INT 0
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 2
31960: NEG
31961: PUSH
31962: LD_INT 1
31964: NEG
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: LD_INT 1
31975: NEG
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 3
31983: PUSH
31984: LD_INT 0
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 3
31993: PUSH
31994: LD_INT 1
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: LIST
32005: LIST
32006: LIST
32007: LIST
32008: LIST
32009: LIST
32010: LIST
32011: LIST
32012: LIST
32013: LIST
32014: LIST
32015: LIST
32016: LIST
32017: LIST
32018: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32019: LD_ADDR_VAR 0 16
32023: PUSH
32024: LD_INT 0
32026: PUSH
32027: LD_INT 0
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: LD_INT 1
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 1
32047: PUSH
32048: LD_INT 0
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PUSH
32055: LD_INT 1
32057: PUSH
32058: LD_INT 1
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 0
32067: PUSH
32068: LD_INT 1
32070: PUSH
32071: EMPTY
32072: LIST
32073: LIST
32074: PUSH
32075: LD_INT 1
32077: NEG
32078: PUSH
32079: LD_INT 0
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 1
32088: NEG
32089: PUSH
32090: LD_INT 1
32092: NEG
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 1
32100: NEG
32101: PUSH
32102: LD_INT 2
32104: NEG
32105: PUSH
32106: EMPTY
32107: LIST
32108: LIST
32109: PUSH
32110: LD_INT 2
32112: PUSH
32113: LD_INT 1
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 2
32122: PUSH
32123: LD_INT 2
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: LD_INT 1
32132: PUSH
32133: LD_INT 2
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 2
32142: NEG
32143: PUSH
32144: LD_INT 1
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 2
32154: NEG
32155: PUSH
32156: LD_INT 2
32158: NEG
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 3
32166: PUSH
32167: LD_INT 2
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 3
32176: PUSH
32177: LD_INT 3
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 2
32186: PUSH
32187: LD_INT 3
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32212: LD_ADDR_VAR 0 17
32216: PUSH
32217: LD_INT 0
32219: PUSH
32220: LD_INT 0
32222: PUSH
32223: EMPTY
32224: LIST
32225: LIST
32226: PUSH
32227: LD_INT 0
32229: PUSH
32230: LD_INT 1
32232: NEG
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PUSH
32238: LD_INT 1
32240: PUSH
32241: LD_INT 0
32243: PUSH
32244: EMPTY
32245: LIST
32246: LIST
32247: PUSH
32248: LD_INT 1
32250: PUSH
32251: LD_INT 1
32253: PUSH
32254: EMPTY
32255: LIST
32256: LIST
32257: PUSH
32258: LD_INT 0
32260: PUSH
32261: LD_INT 1
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 1
32270: NEG
32271: PUSH
32272: LD_INT 0
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 1
32281: NEG
32282: PUSH
32283: LD_INT 1
32285: NEG
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 1
32293: NEG
32294: PUSH
32295: LD_INT 2
32297: NEG
32298: PUSH
32299: EMPTY
32300: LIST
32301: LIST
32302: PUSH
32303: LD_INT 0
32305: PUSH
32306: LD_INT 2
32308: NEG
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: LD_INT 1
32316: PUSH
32317: LD_INT 1
32319: NEG
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: PUSH
32325: LD_INT 2
32327: PUSH
32328: LD_INT 0
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 2
32337: PUSH
32338: LD_INT 1
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 2
32347: PUSH
32348: LD_INT 2
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 1
32357: PUSH
32358: LD_INT 2
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 0
32367: PUSH
32368: LD_INT 2
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: LD_INT 1
32377: NEG
32378: PUSH
32379: LD_INT 1
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 2
32388: NEG
32389: PUSH
32390: LD_INT 0
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 2
32399: NEG
32400: PUSH
32401: LD_INT 1
32403: NEG
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: LD_INT 2
32411: NEG
32412: PUSH
32413: LD_INT 2
32415: NEG
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: LIST
32434: LIST
32435: LIST
32436: LIST
32437: LIST
32438: LIST
32439: LIST
32440: LIST
32441: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32442: LD_ADDR_VAR 0 18
32446: PUSH
32447: LD_INT 0
32449: PUSH
32450: LD_INT 0
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 0
32459: PUSH
32460: LD_INT 1
32462: NEG
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 1
32470: PUSH
32471: LD_INT 0
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 1
32480: PUSH
32481: LD_INT 1
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 0
32490: PUSH
32491: LD_INT 1
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 1
32500: NEG
32501: PUSH
32502: LD_INT 0
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 1
32511: NEG
32512: PUSH
32513: LD_INT 1
32515: NEG
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 1
32523: NEG
32524: PUSH
32525: LD_INT 2
32527: NEG
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: LD_INT 0
32535: PUSH
32536: LD_INT 2
32538: NEG
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: PUSH
32544: LD_INT 1
32546: PUSH
32547: LD_INT 1
32549: NEG
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 2
32557: PUSH
32558: LD_INT 0
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 2
32567: PUSH
32568: LD_INT 1
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 2
32577: PUSH
32578: LD_INT 2
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 1
32587: PUSH
32588: LD_INT 2
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 0
32597: PUSH
32598: LD_INT 2
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 1
32607: NEG
32608: PUSH
32609: LD_INT 1
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 2
32618: NEG
32619: PUSH
32620: LD_INT 0
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 2
32629: NEG
32630: PUSH
32631: LD_INT 1
32633: NEG
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 2
32641: NEG
32642: PUSH
32643: LD_INT 2
32645: NEG
32646: PUSH
32647: EMPTY
32648: LIST
32649: LIST
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: LIST
32671: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32672: LD_ADDR_VAR 0 19
32676: PUSH
32677: LD_INT 0
32679: PUSH
32680: LD_INT 0
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: PUSH
32687: LD_INT 0
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 1
32700: PUSH
32701: LD_INT 0
32703: PUSH
32704: EMPTY
32705: LIST
32706: LIST
32707: PUSH
32708: LD_INT 1
32710: PUSH
32711: LD_INT 1
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 0
32720: PUSH
32721: LD_INT 1
32723: PUSH
32724: EMPTY
32725: LIST
32726: LIST
32727: PUSH
32728: LD_INT 1
32730: NEG
32731: PUSH
32732: LD_INT 0
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 1
32741: NEG
32742: PUSH
32743: LD_INT 1
32745: NEG
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: LD_INT 1
32753: NEG
32754: PUSH
32755: LD_INT 2
32757: NEG
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 0
32765: PUSH
32766: LD_INT 2
32768: NEG
32769: PUSH
32770: EMPTY
32771: LIST
32772: LIST
32773: PUSH
32774: LD_INT 1
32776: PUSH
32777: LD_INT 1
32779: NEG
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 2
32787: PUSH
32788: LD_INT 0
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 2
32797: PUSH
32798: LD_INT 1
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: PUSH
32805: LD_INT 2
32807: PUSH
32808: LD_INT 2
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: LD_INT 1
32817: PUSH
32818: LD_INT 2
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: LD_INT 0
32827: PUSH
32828: LD_INT 2
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: PUSH
32835: LD_INT 1
32837: NEG
32838: PUSH
32839: LD_INT 1
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 2
32848: NEG
32849: PUSH
32850: LD_INT 0
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 2
32859: NEG
32860: PUSH
32861: LD_INT 1
32863: NEG
32864: PUSH
32865: EMPTY
32866: LIST
32867: LIST
32868: PUSH
32869: LD_INT 2
32871: NEG
32872: PUSH
32873: LD_INT 2
32875: NEG
32876: PUSH
32877: EMPTY
32878: LIST
32879: LIST
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: LIST
32895: LIST
32896: LIST
32897: LIST
32898: LIST
32899: LIST
32900: LIST
32901: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32902: LD_ADDR_VAR 0 20
32906: PUSH
32907: LD_INT 0
32909: PUSH
32910: LD_INT 0
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 0
32919: PUSH
32920: LD_INT 1
32922: NEG
32923: PUSH
32924: EMPTY
32925: LIST
32926: LIST
32927: PUSH
32928: LD_INT 1
32930: PUSH
32931: LD_INT 0
32933: PUSH
32934: EMPTY
32935: LIST
32936: LIST
32937: PUSH
32938: LD_INT 1
32940: PUSH
32941: LD_INT 1
32943: PUSH
32944: EMPTY
32945: LIST
32946: LIST
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: LD_INT 1
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 1
32960: NEG
32961: PUSH
32962: LD_INT 0
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: PUSH
32969: LD_INT 1
32971: NEG
32972: PUSH
32973: LD_INT 1
32975: NEG
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 1
32983: NEG
32984: PUSH
32985: LD_INT 2
32987: NEG
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 0
32995: PUSH
32996: LD_INT 2
32998: NEG
32999: PUSH
33000: EMPTY
33001: LIST
33002: LIST
33003: PUSH
33004: LD_INT 1
33006: PUSH
33007: LD_INT 1
33009: NEG
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 2
33017: PUSH
33018: LD_INT 0
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 2
33027: PUSH
33028: LD_INT 1
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 2
33037: PUSH
33038: LD_INT 2
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 1
33047: PUSH
33048: LD_INT 2
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: LD_INT 0
33057: PUSH
33058: LD_INT 2
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 1
33067: NEG
33068: PUSH
33069: LD_INT 1
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 2
33078: NEG
33079: PUSH
33080: LD_INT 0
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 2
33089: NEG
33090: PUSH
33091: LD_INT 1
33093: NEG
33094: PUSH
33095: EMPTY
33096: LIST
33097: LIST
33098: PUSH
33099: LD_INT 2
33101: NEG
33102: PUSH
33103: LD_INT 2
33105: NEG
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: LIST
33115: LIST
33116: LIST
33117: LIST
33118: LIST
33119: LIST
33120: LIST
33121: LIST
33122: LIST
33123: LIST
33124: LIST
33125: LIST
33126: LIST
33127: LIST
33128: LIST
33129: LIST
33130: LIST
33131: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33132: LD_ADDR_VAR 0 21
33136: PUSH
33137: LD_INT 0
33139: PUSH
33140: LD_INT 0
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: LD_INT 0
33149: PUSH
33150: LD_INT 1
33152: NEG
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: LD_INT 0
33163: PUSH
33164: EMPTY
33165: LIST
33166: LIST
33167: PUSH
33168: LD_INT 1
33170: PUSH
33171: LD_INT 1
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 0
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 1
33190: NEG
33191: PUSH
33192: LD_INT 0
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 1
33201: NEG
33202: PUSH
33203: LD_INT 1
33205: NEG
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 1
33213: NEG
33214: PUSH
33215: LD_INT 2
33217: NEG
33218: PUSH
33219: EMPTY
33220: LIST
33221: LIST
33222: PUSH
33223: LD_INT 0
33225: PUSH
33226: LD_INT 2
33228: NEG
33229: PUSH
33230: EMPTY
33231: LIST
33232: LIST
33233: PUSH
33234: LD_INT 1
33236: PUSH
33237: LD_INT 1
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 2
33247: PUSH
33248: LD_INT 0
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 2
33257: PUSH
33258: LD_INT 1
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 2
33267: PUSH
33268: LD_INT 2
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 1
33277: PUSH
33278: LD_INT 2
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 0
33287: PUSH
33288: LD_INT 2
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: NEG
33298: PUSH
33299: LD_INT 1
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 2
33308: NEG
33309: PUSH
33310: LD_INT 0
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PUSH
33317: LD_INT 2
33319: NEG
33320: PUSH
33321: LD_INT 1
33323: NEG
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 2
33331: NEG
33332: PUSH
33333: LD_INT 2
33335: NEG
33336: PUSH
33337: EMPTY
33338: LIST
33339: LIST
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: LIST
33357: LIST
33358: LIST
33359: LIST
33360: LIST
33361: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33362: LD_ADDR_VAR 0 22
33366: PUSH
33367: LD_INT 0
33369: PUSH
33370: LD_INT 0
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: LD_INT 0
33379: PUSH
33380: LD_INT 1
33382: NEG
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 1
33390: PUSH
33391: LD_INT 0
33393: PUSH
33394: EMPTY
33395: LIST
33396: LIST
33397: PUSH
33398: LD_INT 1
33400: PUSH
33401: LD_INT 1
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: LD_INT 0
33410: PUSH
33411: LD_INT 1
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 1
33420: NEG
33421: PUSH
33422: LD_INT 0
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 1
33431: NEG
33432: PUSH
33433: LD_INT 1
33435: NEG
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 1
33443: NEG
33444: PUSH
33445: LD_INT 2
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 0
33455: PUSH
33456: LD_INT 2
33458: NEG
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: PUSH
33464: LD_INT 1
33466: PUSH
33467: LD_INT 1
33469: NEG
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: LD_INT 2
33477: PUSH
33478: LD_INT 0
33480: PUSH
33481: EMPTY
33482: LIST
33483: LIST
33484: PUSH
33485: LD_INT 2
33487: PUSH
33488: LD_INT 1
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 2
33497: PUSH
33498: LD_INT 2
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: LD_INT 1
33507: PUSH
33508: LD_INT 2
33510: PUSH
33511: EMPTY
33512: LIST
33513: LIST
33514: PUSH
33515: LD_INT 0
33517: PUSH
33518: LD_INT 2
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 1
33527: NEG
33528: PUSH
33529: LD_INT 1
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 2
33538: NEG
33539: PUSH
33540: LD_INT 0
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 2
33549: NEG
33550: PUSH
33551: LD_INT 1
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 2
33561: NEG
33562: PUSH
33563: LD_INT 2
33565: NEG
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
33592: LD_ADDR_VAR 0 23
33596: PUSH
33597: LD_INT 0
33599: PUSH
33600: LD_INT 0
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 0
33609: PUSH
33610: LD_INT 1
33612: NEG
33613: PUSH
33614: EMPTY
33615: LIST
33616: LIST
33617: PUSH
33618: LD_INT 1
33620: PUSH
33621: LD_INT 0
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 1
33630: PUSH
33631: LD_INT 1
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 0
33640: PUSH
33641: LD_INT 1
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 1
33650: NEG
33651: PUSH
33652: LD_INT 0
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: LD_INT 1
33661: NEG
33662: PUSH
33663: LD_INT 1
33665: NEG
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 1
33673: NEG
33674: PUSH
33675: LD_INT 2
33677: NEG
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 0
33685: PUSH
33686: LD_INT 2
33688: NEG
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 1
33696: PUSH
33697: LD_INT 1
33699: NEG
33700: PUSH
33701: EMPTY
33702: LIST
33703: LIST
33704: PUSH
33705: LD_INT 2
33707: PUSH
33708: LD_INT 0
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 2
33717: PUSH
33718: LD_INT 1
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 2
33727: PUSH
33728: LD_INT 2
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: LD_INT 2
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: LD_INT 0
33747: PUSH
33748: LD_INT 2
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 1
33757: NEG
33758: PUSH
33759: LD_INT 1
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 2
33768: NEG
33769: PUSH
33770: LD_INT 0
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 2
33779: NEG
33780: PUSH
33781: LD_INT 1
33783: NEG
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: LD_INT 2
33791: NEG
33792: PUSH
33793: LD_INT 2
33795: NEG
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 2
33803: NEG
33804: PUSH
33805: LD_INT 3
33807: NEG
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: LD_INT 1
33815: NEG
33816: PUSH
33817: LD_INT 3
33819: NEG
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 1
33827: PUSH
33828: LD_INT 2
33830: NEG
33831: PUSH
33832: EMPTY
33833: LIST
33834: LIST
33835: PUSH
33836: LD_INT 2
33838: PUSH
33839: LD_INT 1
33841: NEG
33842: PUSH
33843: EMPTY
33844: LIST
33845: LIST
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: LIST
33855: LIST
33856: LIST
33857: LIST
33858: LIST
33859: LIST
33860: LIST
33861: LIST
33862: LIST
33863: LIST
33864: LIST
33865: LIST
33866: LIST
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
33872: LD_ADDR_VAR 0 24
33876: PUSH
33877: LD_INT 0
33879: PUSH
33880: LD_INT 0
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 0
33889: PUSH
33890: LD_INT 1
33892: NEG
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 1
33900: PUSH
33901: LD_INT 0
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 1
33910: PUSH
33911: LD_INT 1
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 0
33920: PUSH
33921: LD_INT 1
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: NEG
33931: PUSH
33932: LD_INT 0
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 1
33941: NEG
33942: PUSH
33943: LD_INT 1
33945: NEG
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 1
33953: NEG
33954: PUSH
33955: LD_INT 2
33957: NEG
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 0
33965: PUSH
33966: LD_INT 2
33968: NEG
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 1
33976: PUSH
33977: LD_INT 1
33979: NEG
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 2
33987: PUSH
33988: LD_INT 0
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 2
33997: PUSH
33998: LD_INT 1
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 2
34007: PUSH
34008: LD_INT 2
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 1
34017: PUSH
34018: LD_INT 2
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: LD_INT 0
34027: PUSH
34028: LD_INT 2
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 1
34037: NEG
34038: PUSH
34039: LD_INT 1
34041: PUSH
34042: EMPTY
34043: LIST
34044: LIST
34045: PUSH
34046: LD_INT 2
34048: NEG
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 2
34059: NEG
34060: PUSH
34061: LD_INT 1
34063: NEG
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: PUSH
34069: LD_INT 2
34071: NEG
34072: PUSH
34073: LD_INT 2
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 2
34086: NEG
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: LD_INT 2
34094: PUSH
34095: LD_INT 1
34097: NEG
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: PUSH
34103: LD_INT 3
34105: PUSH
34106: LD_INT 1
34108: PUSH
34109: EMPTY
34110: LIST
34111: LIST
34112: PUSH
34113: LD_INT 3
34115: PUSH
34116: LD_INT 2
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: LIST
34132: LIST
34133: LIST
34134: LIST
34135: LIST
34136: LIST
34137: LIST
34138: LIST
34139: LIST
34140: LIST
34141: LIST
34142: LIST
34143: LIST
34144: LIST
34145: LIST
34146: LIST
34147: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
34148: LD_ADDR_VAR 0 25
34152: PUSH
34153: LD_INT 0
34155: PUSH
34156: LD_INT 0
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 0
34165: PUSH
34166: LD_INT 1
34168: NEG
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 1
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 1
34186: PUSH
34187: LD_INT 1
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 0
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: NEG
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 1
34217: NEG
34218: PUSH
34219: LD_INT 1
34221: NEG
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 1
34229: NEG
34230: PUSH
34231: LD_INT 2
34233: NEG
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 0
34241: PUSH
34242: LD_INT 2
34244: NEG
34245: PUSH
34246: EMPTY
34247: LIST
34248: LIST
34249: PUSH
34250: LD_INT 1
34252: PUSH
34253: LD_INT 1
34255: NEG
34256: PUSH
34257: EMPTY
34258: LIST
34259: LIST
34260: PUSH
34261: LD_INT 2
34263: PUSH
34264: LD_INT 0
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 2
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 2
34283: PUSH
34284: LD_INT 2
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 1
34293: PUSH
34294: LD_INT 2
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 0
34303: PUSH
34304: LD_INT 2
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: NEG
34314: PUSH
34315: LD_INT 1
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 2
34324: NEG
34325: PUSH
34326: LD_INT 0
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 2
34335: NEG
34336: PUSH
34337: LD_INT 1
34339: NEG
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: LD_INT 2
34347: NEG
34348: PUSH
34349: LD_INT 2
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 3
34359: PUSH
34360: LD_INT 1
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 3
34369: PUSH
34370: LD_INT 2
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 2
34379: PUSH
34380: LD_INT 3
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 3
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: LIST
34414: LIST
34415: LIST
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: LIST
34421: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
34422: LD_ADDR_VAR 0 26
34426: PUSH
34427: LD_INT 0
34429: PUSH
34430: LD_INT 0
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 0
34439: PUSH
34440: LD_INT 1
34442: NEG
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 1
34450: PUSH
34451: LD_INT 0
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: LD_INT 1
34460: PUSH
34461: LD_INT 1
34463: PUSH
34464: EMPTY
34465: LIST
34466: LIST
34467: PUSH
34468: LD_INT 0
34470: PUSH
34471: LD_INT 1
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 1
34480: NEG
34481: PUSH
34482: LD_INT 0
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 1
34491: NEG
34492: PUSH
34493: LD_INT 1
34495: NEG
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 1
34503: NEG
34504: PUSH
34505: LD_INT 2
34507: NEG
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: LD_INT 0
34515: PUSH
34516: LD_INT 2
34518: NEG
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 1
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 2
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 2
34547: PUSH
34548: LD_INT 1
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 2
34557: PUSH
34558: LD_INT 2
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 1
34567: PUSH
34568: LD_INT 2
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 0
34577: PUSH
34578: LD_INT 2
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 1
34587: NEG
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 2
34598: NEG
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 2
34609: NEG
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 2
34621: NEG
34622: PUSH
34623: LD_INT 2
34625: NEG
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 2
34633: PUSH
34634: LD_INT 3
34636: PUSH
34637: EMPTY
34638: LIST
34639: LIST
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: LD_INT 3
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 1
34653: NEG
34654: PUSH
34655: LD_INT 2
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 2
34664: NEG
34665: PUSH
34666: LD_INT 1
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34698: LD_ADDR_VAR 0 27
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: LD_INT 0
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 0
34715: PUSH
34716: LD_INT 1
34718: NEG
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 1
34726: PUSH
34727: LD_INT 0
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 1
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 0
34746: PUSH
34747: LD_INT 1
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: NEG
34757: PUSH
34758: LD_INT 0
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: NEG
34768: PUSH
34769: LD_INT 1
34771: NEG
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 1
34779: NEG
34780: PUSH
34781: LD_INT 2
34783: NEG
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: LD_INT 2
34794: NEG
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 1
34802: PUSH
34803: LD_INT 1
34805: NEG
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: LD_INT 0
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: PUSH
34821: LD_INT 2
34823: PUSH
34824: LD_INT 1
34826: PUSH
34827: EMPTY
34828: LIST
34829: LIST
34830: PUSH
34831: LD_INT 2
34833: PUSH
34834: LD_INT 2
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: LD_INT 2
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: LD_INT 2
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: NEG
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 2
34874: NEG
34875: PUSH
34876: LD_INT 0
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 2
34885: NEG
34886: PUSH
34887: LD_INT 1
34889: NEG
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 2
34897: NEG
34898: PUSH
34899: LD_INT 2
34901: NEG
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: LD_INT 2
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 2
34920: NEG
34921: PUSH
34922: LD_INT 1
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 3
34931: NEG
34932: PUSH
34933: LD_INT 1
34935: NEG
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 3
34943: NEG
34944: PUSH
34945: LD_INT 2
34947: NEG
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: LIST
34973: LIST
34974: LIST
34975: LIST
34976: LIST
34977: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
34978: LD_ADDR_VAR 0 28
34982: PUSH
34983: LD_INT 0
34985: PUSH
34986: LD_INT 0
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 0
34995: PUSH
34996: LD_INT 1
34998: NEG
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 1
35006: PUSH
35007: LD_INT 0
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 1
35016: PUSH
35017: LD_INT 1
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 0
35026: PUSH
35027: LD_INT 1
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 1
35036: NEG
35037: PUSH
35038: LD_INT 0
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 1
35047: NEG
35048: PUSH
35049: LD_INT 1
35051: NEG
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 1
35059: NEG
35060: PUSH
35061: LD_INT 2
35063: NEG
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 0
35071: PUSH
35072: LD_INT 2
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 1
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 2
35093: PUSH
35094: LD_INT 0
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 2
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 2
35113: PUSH
35114: LD_INT 2
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 1
35123: PUSH
35124: LD_INT 2
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 0
35133: PUSH
35134: LD_INT 2
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: NEG
35144: PUSH
35145: LD_INT 1
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 2
35154: NEG
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: LD_INT 2
35165: NEG
35166: PUSH
35167: LD_INT 1
35169: NEG
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 2
35177: NEG
35178: PUSH
35179: LD_INT 2
35181: NEG
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 2
35189: NEG
35190: PUSH
35191: LD_INT 3
35193: NEG
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 1
35201: NEG
35202: PUSH
35203: LD_INT 3
35205: NEG
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 3
35213: NEG
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 3
35225: NEG
35226: PUSH
35227: LD_INT 2
35229: NEG
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: LIST
35239: LIST
35240: LIST
35241: LIST
35242: LIST
35243: LIST
35244: LIST
35245: LIST
35246: LIST
35247: LIST
35248: LIST
35249: LIST
35250: LIST
35251: LIST
35252: LIST
35253: LIST
35254: LIST
35255: LIST
35256: LIST
35257: LIST
35258: LIST
35259: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35260: LD_ADDR_VAR 0 29
35264: PUSH
35265: LD_INT 0
35267: PUSH
35268: LD_INT 0
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 0
35277: PUSH
35278: LD_INT 1
35280: NEG
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 1
35288: PUSH
35289: LD_INT 0
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: PUSH
35299: LD_INT 1
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 0
35308: PUSH
35309: LD_INT 1
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 1
35329: NEG
35330: PUSH
35331: LD_INT 1
35333: NEG
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 1
35341: NEG
35342: PUSH
35343: LD_INT 2
35345: NEG
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 2
35356: NEG
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 1
35364: PUSH
35365: LD_INT 1
35367: NEG
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PUSH
35373: LD_INT 2
35375: PUSH
35376: LD_INT 0
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 2
35385: PUSH
35386: LD_INT 1
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 1
35395: PUSH
35396: LD_INT 2
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 0
35405: PUSH
35406: LD_INT 2
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: LD_INT 1
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 2
35426: NEG
35427: PUSH
35428: LD_INT 1
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 2
35438: NEG
35439: PUSH
35440: LD_INT 2
35442: NEG
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 2
35450: NEG
35451: PUSH
35452: LD_INT 3
35454: NEG
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 2
35462: PUSH
35463: LD_INT 1
35465: NEG
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 3
35473: PUSH
35474: LD_INT 1
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 1
35483: PUSH
35484: LD_INT 3
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 1
35493: NEG
35494: PUSH
35495: LD_INT 2
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PUSH
35502: LD_INT 3
35504: NEG
35505: PUSH
35506: LD_INT 2
35508: NEG
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: LIST
35518: LIST
35519: LIST
35520: LIST
35521: LIST
35522: LIST
35523: LIST
35524: LIST
35525: LIST
35526: LIST
35527: LIST
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: LIST
35533: LIST
35534: LIST
35535: LIST
35536: LIST
35537: LIST
35538: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35539: LD_ADDR_VAR 0 30
35543: PUSH
35544: LD_INT 0
35546: PUSH
35547: LD_INT 0
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 0
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: LD_INT 0
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: PUSH
35578: LD_INT 1
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 0
35587: PUSH
35588: LD_INT 1
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 1
35597: NEG
35598: PUSH
35599: LD_INT 0
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 1
35608: NEG
35609: PUSH
35610: LD_INT 1
35612: NEG
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 1
35620: NEG
35621: PUSH
35622: LD_INT 2
35624: NEG
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: LD_INT 0
35632: PUSH
35633: LD_INT 2
35635: NEG
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 1
35643: PUSH
35644: LD_INT 1
35646: NEG
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 2
35654: PUSH
35655: LD_INT 0
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 2
35664: PUSH
35665: LD_INT 1
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 2
35674: PUSH
35675: LD_INT 2
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: LD_INT 2
35687: PUSH
35688: EMPTY
35689: LIST
35690: LIST
35691: PUSH
35692: LD_INT 1
35694: NEG
35695: PUSH
35696: LD_INT 1
35698: PUSH
35699: EMPTY
35700: LIST
35701: LIST
35702: PUSH
35703: LD_INT 2
35705: NEG
35706: PUSH
35707: LD_INT 0
35709: PUSH
35710: EMPTY
35711: LIST
35712: LIST
35713: PUSH
35714: LD_INT 2
35716: NEG
35717: PUSH
35718: LD_INT 1
35720: NEG
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 1
35728: NEG
35729: PUSH
35730: LD_INT 3
35732: NEG
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 1
35740: PUSH
35741: LD_INT 2
35743: NEG
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PUSH
35749: LD_INT 3
35751: PUSH
35752: LD_INT 2
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: LD_INT 2
35761: PUSH
35762: LD_INT 3
35764: PUSH
35765: EMPTY
35766: LIST
35767: LIST
35768: PUSH
35769: LD_INT 2
35771: NEG
35772: PUSH
35773: LD_INT 1
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: LD_INT 3
35782: NEG
35783: PUSH
35784: LD_INT 1
35786: NEG
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: LIST
35796: LIST
35797: LIST
35798: LIST
35799: LIST
35800: LIST
35801: LIST
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35817: LD_ADDR_VAR 0 31
35821: PUSH
35822: LD_INT 0
35824: PUSH
35825: LD_INT 0
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: LD_INT 0
35834: PUSH
35835: LD_INT 1
35837: NEG
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 1
35845: PUSH
35846: LD_INT 0
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 1
35855: PUSH
35856: LD_INT 1
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 0
35865: PUSH
35866: LD_INT 1
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 1
35875: NEG
35876: PUSH
35877: LD_INT 0
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 1
35886: NEG
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 1
35898: NEG
35899: PUSH
35900: LD_INT 2
35902: NEG
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 1
35910: PUSH
35911: LD_INT 1
35913: NEG
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: LD_INT 0
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: LD_INT 1
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: PUSH
35939: LD_INT 2
35941: PUSH
35942: LD_INT 2
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: LD_INT 2
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 0
35961: PUSH
35962: LD_INT 2
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 1
35971: NEG
35972: PUSH
35973: LD_INT 1
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 2
35982: NEG
35983: PUSH
35984: LD_INT 1
35986: NEG
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 2
35994: NEG
35995: PUSH
35996: LD_INT 2
35998: NEG
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 2
36006: NEG
36007: PUSH
36008: LD_INT 3
36010: NEG
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PUSH
36016: LD_INT 2
36018: PUSH
36019: LD_INT 1
36021: NEG
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 3
36029: PUSH
36030: LD_INT 1
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 1
36039: PUSH
36040: LD_INT 3
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: LD_INT 2
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: PUSH
36058: LD_INT 3
36060: NEG
36061: PUSH
36062: LD_INT 2
36064: NEG
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: LIST
36074: LIST
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36095: LD_ADDR_VAR 0 32
36099: PUSH
36100: LD_INT 0
36102: PUSH
36103: LD_INT 0
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: LD_INT 0
36112: PUSH
36113: LD_INT 1
36115: NEG
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 1
36123: PUSH
36124: LD_INT 0
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: PUSH
36134: LD_INT 1
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 0
36143: PUSH
36144: LD_INT 1
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: PUSH
36151: LD_INT 1
36153: NEG
36154: PUSH
36155: LD_INT 0
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 1
36164: NEG
36165: PUSH
36166: LD_INT 1
36168: NEG
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: PUSH
36174: LD_INT 1
36176: NEG
36177: PUSH
36178: LD_INT 2
36180: NEG
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 0
36188: PUSH
36189: LD_INT 2
36191: NEG
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 1
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 2
36210: PUSH
36211: LD_INT 1
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 2
36220: PUSH
36221: LD_INT 2
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 1
36230: PUSH
36231: LD_INT 2
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: LD_INT 2
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: LD_INT 1
36250: NEG
36251: PUSH
36252: LD_INT 1
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 2
36261: NEG
36262: PUSH
36263: LD_INT 0
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 2
36272: NEG
36273: PUSH
36274: LD_INT 1
36276: NEG
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 1
36284: NEG
36285: PUSH
36286: LD_INT 3
36288: NEG
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 1
36296: PUSH
36297: LD_INT 2
36299: NEG
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 3
36307: PUSH
36308: LD_INT 2
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 2
36317: PUSH
36318: LD_INT 3
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 2
36327: NEG
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 3
36338: NEG
36339: PUSH
36340: LD_INT 1
36342: NEG
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: LIST
36358: LIST
36359: LIST
36360: LIST
36361: LIST
36362: LIST
36363: LIST
36364: LIST
36365: LIST
36366: LIST
36367: LIST
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36373: LD_ADDR_VAR 0 33
36377: PUSH
36378: LD_INT 0
36380: PUSH
36381: LD_INT 0
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 0
36390: PUSH
36391: LD_INT 1
36393: NEG
36394: PUSH
36395: EMPTY
36396: LIST
36397: LIST
36398: PUSH
36399: LD_INT 1
36401: PUSH
36402: LD_INT 0
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 1
36411: PUSH
36412: LD_INT 1
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 0
36421: PUSH
36422: LD_INT 1
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 1
36431: NEG
36432: PUSH
36433: LD_INT 0
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 1
36442: NEG
36443: PUSH
36444: LD_INT 1
36446: NEG
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: LD_INT 1
36454: NEG
36455: PUSH
36456: LD_INT 2
36458: NEG
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: PUSH
36464: LD_INT 1
36466: PUSH
36467: LD_INT 1
36469: NEG
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 2
36477: PUSH
36478: LD_INT 0
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 2
36487: PUSH
36488: LD_INT 1
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 1
36497: PUSH
36498: LD_INT 2
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 0
36507: PUSH
36508: LD_INT 2
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 1
36517: NEG
36518: PUSH
36519: LD_INT 1
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 2
36528: NEG
36529: PUSH
36530: LD_INT 0
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 2
36539: NEG
36540: PUSH
36541: LD_INT 1
36543: NEG
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 2
36551: NEG
36552: PUSH
36553: LD_INT 2
36555: NEG
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 2
36563: NEG
36564: PUSH
36565: LD_INT 3
36567: NEG
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 2
36575: PUSH
36576: LD_INT 1
36578: NEG
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: LD_INT 3
36586: PUSH
36587: LD_INT 1
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 1
36596: PUSH
36597: LD_INT 3
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 1
36606: NEG
36607: PUSH
36608: LD_INT 2
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 3
36617: NEG
36618: PUSH
36619: LD_INT 2
36621: NEG
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: LIST
36631: LIST
36632: LIST
36633: LIST
36634: LIST
36635: LIST
36636: LIST
36637: LIST
36638: LIST
36639: LIST
36640: LIST
36641: LIST
36642: LIST
36643: LIST
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36652: LD_ADDR_VAR 0 34
36656: PUSH
36657: LD_INT 0
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: LD_INT 0
36669: PUSH
36670: LD_INT 1
36672: NEG
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 1
36680: PUSH
36681: LD_INT 0
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: PUSH
36691: LD_INT 1
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: LD_INT 1
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 1
36710: NEG
36711: PUSH
36712: LD_INT 0
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: LD_INT 1
36725: NEG
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 1
36733: NEG
36734: PUSH
36735: LD_INT 2
36737: NEG
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 0
36745: PUSH
36746: LD_INT 2
36748: NEG
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 1
36756: PUSH
36757: LD_INT 1
36759: NEG
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: LD_INT 1
36770: PUSH
36771: EMPTY
36772: LIST
36773: LIST
36774: PUSH
36775: LD_INT 2
36777: PUSH
36778: LD_INT 2
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 1
36787: PUSH
36788: LD_INT 2
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 1
36797: NEG
36798: PUSH
36799: LD_INT 1
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: NEG
36809: PUSH
36810: LD_INT 0
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 2
36819: NEG
36820: PUSH
36821: LD_INT 1
36823: NEG
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 2
36831: NEG
36832: PUSH
36833: LD_INT 2
36835: NEG
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 1
36843: NEG
36844: PUSH
36845: LD_INT 3
36847: NEG
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: LD_INT 1
36855: PUSH
36856: LD_INT 2
36858: NEG
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 3
36866: PUSH
36867: LD_INT 2
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: PUSH
36874: LD_INT 2
36876: PUSH
36877: LD_INT 3
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 2
36886: NEG
36887: PUSH
36888: LD_INT 1
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 3
36897: NEG
36898: PUSH
36899: LD_INT 1
36901: NEG
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: EMPTY
36908: LIST
36909: LIST
36910: LIST
36911: LIST
36912: LIST
36913: LIST
36914: LIST
36915: LIST
36916: LIST
36917: LIST
36918: LIST
36919: LIST
36920: LIST
36921: LIST
36922: LIST
36923: LIST
36924: LIST
36925: LIST
36926: LIST
36927: LIST
36928: LIST
36929: LIST
36930: LIST
36931: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36932: LD_ADDR_VAR 0 35
36936: PUSH
36937: LD_INT 0
36939: PUSH
36940: LD_INT 0
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 0
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 1
36960: PUSH
36961: LD_INT 0
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 1
36970: PUSH
36971: LD_INT 1
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 0
36980: PUSH
36981: LD_INT 1
36983: PUSH
36984: EMPTY
36985: LIST
36986: LIST
36987: PUSH
36988: LD_INT 1
36990: NEG
36991: PUSH
36992: LD_INT 0
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: LD_INT 1
37001: NEG
37002: PUSH
37003: LD_INT 1
37005: NEG
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 2
37013: PUSH
37014: LD_INT 1
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 2
37023: NEG
37024: PUSH
37025: LD_INT 1
37027: NEG
37028: PUSH
37029: EMPTY
37030: LIST
37031: LIST
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: LIST
37037: LIST
37038: LIST
37039: LIST
37040: LIST
37041: LIST
37042: LIST
37043: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37044: LD_ADDR_VAR 0 36
37048: PUSH
37049: LD_INT 0
37051: PUSH
37052: LD_INT 0
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 0
37061: PUSH
37062: LD_INT 1
37064: NEG
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 1
37072: PUSH
37073: LD_INT 0
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 1
37082: PUSH
37083: LD_INT 1
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 0
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 1
37102: NEG
37103: PUSH
37104: LD_INT 0
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 1
37113: NEG
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: LD_INT 2
37129: NEG
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: PUSH
37135: LD_INT 1
37137: PUSH
37138: LD_INT 2
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: LIST
37149: LIST
37150: LIST
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37156: LD_ADDR_VAR 0 37
37160: PUSH
37161: LD_INT 0
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 0
37173: PUSH
37174: LD_INT 1
37176: NEG
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 1
37184: PUSH
37185: LD_INT 0
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 1
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 0
37204: PUSH
37205: LD_INT 1
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 1
37214: NEG
37215: PUSH
37216: LD_INT 0
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 1
37225: NEG
37226: PUSH
37227: LD_INT 1
37229: NEG
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 1
37237: PUSH
37238: LD_INT 1
37240: NEG
37241: PUSH
37242: EMPTY
37243: LIST
37244: LIST
37245: PUSH
37246: LD_INT 1
37248: NEG
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: LIST
37261: LIST
37262: LIST
37263: LIST
37264: LIST
37265: LIST
37266: LIST
37267: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37268: LD_ADDR_VAR 0 38
37272: PUSH
37273: LD_INT 0
37275: PUSH
37276: LD_INT 0
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 0
37285: PUSH
37286: LD_INT 1
37288: NEG
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: PUSH
37297: LD_INT 0
37299: PUSH
37300: EMPTY
37301: LIST
37302: LIST
37303: PUSH
37304: LD_INT 1
37306: PUSH
37307: LD_INT 1
37309: PUSH
37310: EMPTY
37311: LIST
37312: LIST
37313: PUSH
37314: LD_INT 0
37316: PUSH
37317: LD_INT 1
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 1
37326: NEG
37327: PUSH
37328: LD_INT 0
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 1
37337: NEG
37338: PUSH
37339: LD_INT 1
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 2
37349: PUSH
37350: LD_INT 1
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 2
37359: NEG
37360: PUSH
37361: LD_INT 1
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: LIST
37373: LIST
37374: LIST
37375: LIST
37376: LIST
37377: LIST
37378: LIST
37379: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37380: LD_ADDR_VAR 0 39
37384: PUSH
37385: LD_INT 0
37387: PUSH
37388: LD_INT 0
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 0
37397: PUSH
37398: LD_INT 1
37400: NEG
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 1
37408: PUSH
37409: LD_INT 0
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: LD_INT 1
37418: PUSH
37419: LD_INT 1
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 0
37428: PUSH
37429: LD_INT 1
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: LD_INT 0
37442: PUSH
37443: EMPTY
37444: LIST
37445: LIST
37446: PUSH
37447: LD_INT 1
37449: NEG
37450: PUSH
37451: LD_INT 1
37453: NEG
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 1
37461: NEG
37462: PUSH
37463: LD_INT 2
37465: NEG
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 1
37473: PUSH
37474: LD_INT 2
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: LIST
37485: LIST
37486: LIST
37487: LIST
37488: LIST
37489: LIST
37490: LIST
37491: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37492: LD_ADDR_VAR 0 40
37496: PUSH
37497: LD_INT 0
37499: PUSH
37500: LD_INT 0
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: LD_INT 0
37509: PUSH
37510: LD_INT 1
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 1
37520: PUSH
37521: LD_INT 0
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: PUSH
37531: LD_INT 1
37533: PUSH
37534: EMPTY
37535: LIST
37536: LIST
37537: PUSH
37538: LD_INT 0
37540: PUSH
37541: LD_INT 1
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PUSH
37548: LD_INT 1
37550: NEG
37551: PUSH
37552: LD_INT 0
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 1
37561: NEG
37562: PUSH
37563: LD_INT 1
37565: NEG
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 1
37573: PUSH
37574: LD_INT 1
37576: NEG
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 1
37584: NEG
37585: PUSH
37586: LD_INT 1
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: LIST
37597: LIST
37598: LIST
37599: LIST
37600: LIST
37601: LIST
37602: LIST
37603: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37604: LD_ADDR_VAR 0 41
37608: PUSH
37609: LD_INT 0
37611: PUSH
37612: LD_INT 0
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 0
37621: PUSH
37622: LD_INT 1
37624: NEG
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 1
37632: PUSH
37633: LD_INT 0
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 1
37642: PUSH
37643: LD_INT 1
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 0
37652: PUSH
37653: LD_INT 1
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 1
37662: NEG
37663: PUSH
37664: LD_INT 0
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 1
37673: NEG
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 1
37685: NEG
37686: PUSH
37687: LD_INT 2
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 1
37697: PUSH
37698: LD_INT 1
37700: NEG
37701: PUSH
37702: EMPTY
37703: LIST
37704: LIST
37705: PUSH
37706: LD_INT 2
37708: PUSH
37709: LD_INT 0
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: PUSH
37716: LD_INT 2
37718: PUSH
37719: LD_INT 1
37721: PUSH
37722: EMPTY
37723: LIST
37724: LIST
37725: PUSH
37726: LD_INT 2
37728: PUSH
37729: LD_INT 2
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 1
37738: PUSH
37739: LD_INT 2
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 1
37748: NEG
37749: PUSH
37750: LD_INT 1
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: LD_INT 2
37759: NEG
37760: PUSH
37761: LD_INT 0
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: PUSH
37768: LD_INT 2
37770: NEG
37771: PUSH
37772: LD_INT 1
37774: NEG
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 2
37782: NEG
37783: PUSH
37784: LD_INT 2
37786: NEG
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: LD_INT 3
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 2
37806: PUSH
37807: LD_INT 1
37809: NEG
37810: PUSH
37811: EMPTY
37812: LIST
37813: LIST
37814: PUSH
37815: LD_INT 3
37817: PUSH
37818: LD_INT 0
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 3
37827: PUSH
37828: LD_INT 1
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 3
37837: PUSH
37838: LD_INT 2
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 3
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 2
37857: PUSH
37858: LD_INT 3
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 2
37867: NEG
37868: PUSH
37869: LD_INT 1
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PUSH
37876: LD_INT 3
37878: NEG
37879: PUSH
37880: LD_INT 0
37882: PUSH
37883: EMPTY
37884: LIST
37885: LIST
37886: PUSH
37887: LD_INT 3
37889: NEG
37890: PUSH
37891: LD_INT 1
37893: NEG
37894: PUSH
37895: EMPTY
37896: LIST
37897: LIST
37898: PUSH
37899: LD_INT 3
37901: NEG
37902: PUSH
37903: LD_INT 2
37905: NEG
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 3
37913: NEG
37914: PUSH
37915: LD_INT 3
37917: NEG
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: LIST
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37954: LD_ADDR_VAR 0 42
37958: PUSH
37959: LD_INT 0
37961: PUSH
37962: LD_INT 0
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 0
37971: PUSH
37972: LD_INT 1
37974: NEG
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PUSH
37980: LD_INT 1
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 1
37992: PUSH
37993: LD_INT 1
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 0
38002: PUSH
38003: LD_INT 1
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 1
38012: NEG
38013: PUSH
38014: LD_INT 0
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 1
38023: NEG
38024: PUSH
38025: LD_INT 1
38027: NEG
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 1
38035: NEG
38036: PUSH
38037: LD_INT 2
38039: NEG
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 0
38047: PUSH
38048: LD_INT 2
38050: NEG
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: PUSH
38059: LD_INT 1
38061: NEG
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 2
38069: PUSH
38070: LD_INT 1
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 2
38079: PUSH
38080: LD_INT 2
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 1
38089: PUSH
38090: LD_INT 2
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 0
38099: PUSH
38100: LD_INT 2
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 1
38109: NEG
38110: PUSH
38111: LD_INT 1
38113: PUSH
38114: EMPTY
38115: LIST
38116: LIST
38117: PUSH
38118: LD_INT 2
38120: NEG
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 2
38132: NEG
38133: PUSH
38134: LD_INT 2
38136: NEG
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 2
38144: NEG
38145: PUSH
38146: LD_INT 3
38148: NEG
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 1
38156: NEG
38157: PUSH
38158: LD_INT 3
38160: NEG
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: LD_INT 0
38168: PUSH
38169: LD_INT 3
38171: NEG
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: LD_INT 1
38179: PUSH
38180: LD_INT 2
38182: NEG
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 3
38190: PUSH
38191: LD_INT 2
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 3
38200: PUSH
38201: LD_INT 3
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 2
38210: PUSH
38211: LD_INT 3
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: PUSH
38221: LD_INT 3
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 0
38230: PUSH
38231: LD_INT 3
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 1
38240: NEG
38241: PUSH
38242: LD_INT 2
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: PUSH
38249: LD_INT 3
38251: NEG
38252: PUSH
38253: LD_INT 2
38255: NEG
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 3
38263: NEG
38264: PUSH
38265: LD_INT 3
38267: NEG
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: LIST
38285: LIST
38286: LIST
38287: LIST
38288: LIST
38289: LIST
38290: LIST
38291: LIST
38292: LIST
38293: LIST
38294: LIST
38295: LIST
38296: LIST
38297: LIST
38298: LIST
38299: LIST
38300: LIST
38301: LIST
38302: LIST
38303: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38304: LD_ADDR_VAR 0 43
38308: PUSH
38309: LD_INT 0
38311: PUSH
38312: LD_INT 0
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 0
38321: PUSH
38322: LD_INT 1
38324: NEG
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 1
38332: PUSH
38333: LD_INT 0
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 1
38342: PUSH
38343: LD_INT 1
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 0
38352: PUSH
38353: LD_INT 1
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 1
38362: NEG
38363: PUSH
38364: LD_INT 0
38366: PUSH
38367: EMPTY
38368: LIST
38369: LIST
38370: PUSH
38371: LD_INT 1
38373: NEG
38374: PUSH
38375: LD_INT 1
38377: NEG
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 1
38385: NEG
38386: PUSH
38387: LD_INT 2
38389: NEG
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PUSH
38395: LD_INT 0
38397: PUSH
38398: LD_INT 2
38400: NEG
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 1
38408: PUSH
38409: LD_INT 1
38411: NEG
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 2
38419: PUSH
38420: LD_INT 0
38422: PUSH
38423: EMPTY
38424: LIST
38425: LIST
38426: PUSH
38427: LD_INT 2
38429: PUSH
38430: LD_INT 1
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PUSH
38437: LD_INT 1
38439: PUSH
38440: LD_INT 2
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: PUSH
38447: LD_INT 0
38449: PUSH
38450: LD_INT 2
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 1
38459: NEG
38460: PUSH
38461: LD_INT 1
38463: PUSH
38464: EMPTY
38465: LIST
38466: LIST
38467: PUSH
38468: LD_INT 2
38470: NEG
38471: PUSH
38472: LD_INT 0
38474: PUSH
38475: EMPTY
38476: LIST
38477: LIST
38478: PUSH
38479: LD_INT 2
38481: NEG
38482: PUSH
38483: LD_INT 1
38485: NEG
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 1
38493: NEG
38494: PUSH
38495: LD_INT 3
38497: NEG
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: LD_INT 3
38508: NEG
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 1
38516: PUSH
38517: LD_INT 2
38519: NEG
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 2
38527: PUSH
38528: LD_INT 1
38530: NEG
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 3
38538: PUSH
38539: LD_INT 0
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 3
38548: PUSH
38549: LD_INT 1
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 1
38558: PUSH
38559: LD_INT 3
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 0
38568: PUSH
38569: LD_INT 3
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: LD_INT 2
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 2
38589: NEG
38590: PUSH
38591: LD_INT 1
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: PUSH
38598: LD_INT 3
38600: NEG
38601: PUSH
38602: LD_INT 0
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: LD_INT 3
38611: NEG
38612: PUSH
38613: LD_INT 1
38615: NEG
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: EMPTY
38622: LIST
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: LIST
38630: LIST
38631: LIST
38632: LIST
38633: LIST
38634: LIST
38635: LIST
38636: LIST
38637: LIST
38638: LIST
38639: LIST
38640: LIST
38641: LIST
38642: LIST
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: LIST
38650: LIST
38651: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38652: LD_ADDR_VAR 0 44
38656: PUSH
38657: LD_INT 0
38659: PUSH
38660: LD_INT 0
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 0
38669: PUSH
38670: LD_INT 1
38672: NEG
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 1
38680: PUSH
38681: LD_INT 0
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: PUSH
38691: LD_INT 1
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 0
38700: PUSH
38701: LD_INT 1
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 1
38710: NEG
38711: PUSH
38712: LD_INT 0
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 1
38721: NEG
38722: PUSH
38723: LD_INT 1
38725: NEG
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 1
38733: NEG
38734: PUSH
38735: LD_INT 2
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 1
38745: PUSH
38746: LD_INT 1
38748: NEG
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 2
38756: PUSH
38757: LD_INT 0
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: PUSH
38764: LD_INT 2
38766: PUSH
38767: LD_INT 1
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 2
38776: PUSH
38777: LD_INT 2
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: LD_INT 2
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 1
38796: NEG
38797: PUSH
38798: LD_INT 1
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 2
38807: NEG
38808: PUSH
38809: LD_INT 0
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: PUSH
38816: LD_INT 2
38818: NEG
38819: PUSH
38820: LD_INT 1
38822: NEG
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: PUSH
38828: LD_INT 2
38830: NEG
38831: PUSH
38832: LD_INT 2
38834: NEG
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: LD_INT 2
38842: NEG
38843: PUSH
38844: LD_INT 3
38846: NEG
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: PUSH
38852: LD_INT 2
38854: PUSH
38855: LD_INT 1
38857: NEG
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: PUSH
38863: LD_INT 3
38865: PUSH
38866: LD_INT 0
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 3
38875: PUSH
38876: LD_INT 1
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: LD_INT 3
38885: PUSH
38886: LD_INT 2
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: PUSH
38893: LD_INT 3
38895: PUSH
38896: LD_INT 3
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 2
38905: PUSH
38906: LD_INT 3
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PUSH
38913: LD_INT 2
38915: NEG
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 3
38926: NEG
38927: PUSH
38928: LD_INT 0
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 3
38937: NEG
38938: PUSH
38939: LD_INT 1
38941: NEG
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 3
38949: NEG
38950: PUSH
38951: LD_INT 2
38953: NEG
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 3
38961: NEG
38962: PUSH
38963: LD_INT 3
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: LIST
38979: LIST
38980: LIST
38981: LIST
38982: LIST
38983: LIST
38984: LIST
38985: LIST
38986: LIST
38987: LIST
38988: LIST
38989: LIST
38990: LIST
38991: LIST
38992: LIST
38993: LIST
38994: LIST
38995: LIST
38996: LIST
38997: LIST
38998: LIST
38999: LIST
39000: LIST
39001: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39002: LD_ADDR_VAR 0 45
39006: PUSH
39007: LD_INT 0
39009: PUSH
39010: LD_INT 0
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: LD_INT 1
39022: NEG
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: LD_INT 0
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 1
39040: PUSH
39041: LD_INT 1
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: LD_INT 0
39050: PUSH
39051: LD_INT 1
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: LD_INT 0
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 1
39071: NEG
39072: PUSH
39073: LD_INT 1
39075: NEG
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 1
39083: NEG
39084: PUSH
39085: LD_INT 2
39087: NEG
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: LD_INT 0
39095: PUSH
39096: LD_INT 2
39098: NEG
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 1
39106: PUSH
39107: LD_INT 1
39109: NEG
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 2
39117: PUSH
39118: LD_INT 1
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 2
39127: PUSH
39128: LD_INT 2
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 1
39137: PUSH
39138: LD_INT 2
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 0
39147: PUSH
39148: LD_INT 2
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 1
39157: NEG
39158: PUSH
39159: LD_INT 1
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 2
39168: NEG
39169: PUSH
39170: LD_INT 1
39172: NEG
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 2
39180: NEG
39181: PUSH
39182: LD_INT 2
39184: NEG
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 2
39192: NEG
39193: PUSH
39194: LD_INT 3
39196: NEG
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 1
39204: NEG
39205: PUSH
39206: LD_INT 3
39208: NEG
39209: PUSH
39210: EMPTY
39211: LIST
39212: LIST
39213: PUSH
39214: LD_INT 0
39216: PUSH
39217: LD_INT 3
39219: NEG
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 1
39227: PUSH
39228: LD_INT 2
39230: NEG
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 3
39238: PUSH
39239: LD_INT 2
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 3
39248: PUSH
39249: LD_INT 3
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 2
39258: PUSH
39259: LD_INT 3
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 1
39268: PUSH
39269: LD_INT 3
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: LD_INT 0
39278: PUSH
39279: LD_INT 3
39281: PUSH
39282: EMPTY
39283: LIST
39284: LIST
39285: PUSH
39286: LD_INT 1
39288: NEG
39289: PUSH
39290: LD_INT 2
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PUSH
39297: LD_INT 3
39299: NEG
39300: PUSH
39301: LD_INT 2
39303: NEG
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PUSH
39309: LD_INT 3
39311: NEG
39312: PUSH
39313: LD_INT 3
39315: NEG
39316: PUSH
39317: EMPTY
39318: LIST
39319: LIST
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: LIST
39325: LIST
39326: LIST
39327: LIST
39328: LIST
39329: LIST
39330: LIST
39331: LIST
39332: LIST
39333: LIST
39334: LIST
39335: LIST
39336: LIST
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39352: LD_ADDR_VAR 0 46
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: LD_INT 0
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: PUSH
39381: LD_INT 0
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: LD_INT 1
39390: PUSH
39391: LD_INT 1
39393: PUSH
39394: EMPTY
39395: LIST
39396: LIST
39397: PUSH
39398: LD_INT 0
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 1
39410: NEG
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 1
39421: NEG
39422: PUSH
39423: LD_INT 1
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 1
39433: NEG
39434: PUSH
39435: LD_INT 2
39437: NEG
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 0
39445: PUSH
39446: LD_INT 2
39448: NEG
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 1
39456: PUSH
39457: LD_INT 1
39459: NEG
39460: PUSH
39461: EMPTY
39462: LIST
39463: LIST
39464: PUSH
39465: LD_INT 2
39467: PUSH
39468: LD_INT 0
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: LD_INT 2
39477: PUSH
39478: LD_INT 1
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: LD_INT 1
39487: PUSH
39488: LD_INT 2
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 0
39497: PUSH
39498: LD_INT 2
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 1
39507: NEG
39508: PUSH
39509: LD_INT 1
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PUSH
39516: LD_INT 2
39518: NEG
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: PUSH
39527: LD_INT 2
39529: NEG
39530: PUSH
39531: LD_INT 1
39533: NEG
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 1
39541: NEG
39542: PUSH
39543: LD_INT 3
39545: NEG
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: LD_INT 3
39556: NEG
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: LD_INT 1
39564: PUSH
39565: LD_INT 2
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 2
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 3
39586: PUSH
39587: LD_INT 0
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 3
39596: PUSH
39597: LD_INT 1
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 1
39606: PUSH
39607: LD_INT 3
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 0
39616: PUSH
39617: LD_INT 3
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: LD_INT 2
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 2
39637: NEG
39638: PUSH
39639: LD_INT 1
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 3
39648: NEG
39649: PUSH
39650: LD_INT 0
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 3
39659: NEG
39660: PUSH
39661: LD_INT 1
39663: NEG
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: LIST
39673: LIST
39674: LIST
39675: LIST
39676: LIST
39677: LIST
39678: LIST
39679: LIST
39680: LIST
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: LIST
39691: LIST
39692: LIST
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: LIST
39699: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39700: LD_ADDR_VAR 0 47
39704: PUSH
39705: LD_INT 0
39707: PUSH
39708: LD_INT 0
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 0
39717: PUSH
39718: LD_INT 1
39720: NEG
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 1
39728: PUSH
39729: LD_INT 0
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 1
39738: PUSH
39739: LD_INT 1
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 0
39748: PUSH
39749: LD_INT 1
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 1
39758: NEG
39759: PUSH
39760: LD_INT 0
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 1
39769: NEG
39770: PUSH
39771: LD_INT 1
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 1
39781: NEG
39782: PUSH
39783: LD_INT 2
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 0
39793: PUSH
39794: LD_INT 2
39796: NEG
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 1
39804: PUSH
39805: LD_INT 1
39807: NEG
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: LD_INT 2
39815: NEG
39816: PUSH
39817: LD_INT 1
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 2
39827: NEG
39828: PUSH
39829: LD_INT 2
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: LIST
39847: LIST
39848: LIST
39849: LIST
39850: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39851: LD_ADDR_VAR 0 48
39855: PUSH
39856: LD_INT 0
39858: PUSH
39859: LD_INT 0
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 0
39868: PUSH
39869: LD_INT 1
39871: NEG
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 1
39879: PUSH
39880: LD_INT 0
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 1
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 0
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 1
39909: NEG
39910: PUSH
39911: LD_INT 0
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 1
39920: NEG
39921: PUSH
39922: LD_INT 1
39924: NEG
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: LD_INT 1
39932: NEG
39933: PUSH
39934: LD_INT 2
39936: NEG
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 0
39944: PUSH
39945: LD_INT 2
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 1
39955: PUSH
39956: LD_INT 1
39958: NEG
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 2
39966: PUSH
39967: LD_INT 0
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 2
39976: PUSH
39977: LD_INT 1
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39998: LD_ADDR_VAR 0 49
40002: PUSH
40003: LD_INT 0
40005: PUSH
40006: LD_INT 0
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: LD_INT 1
40018: NEG
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 1
40026: PUSH
40027: LD_INT 0
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 1
40036: PUSH
40037: LD_INT 1
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 0
40046: PUSH
40047: LD_INT 1
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 1
40056: NEG
40057: PUSH
40058: LD_INT 0
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 1
40067: NEG
40068: PUSH
40069: LD_INT 1
40071: NEG
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: LD_INT 1
40079: PUSH
40080: LD_INT 1
40082: NEG
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 2
40090: PUSH
40091: LD_INT 0
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 2
40100: PUSH
40101: LD_INT 1
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 2
40110: PUSH
40111: LD_INT 2
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 1
40120: PUSH
40121: LD_INT 2
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: LIST
40132: LIST
40133: LIST
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40142: LD_ADDR_VAR 0 50
40146: PUSH
40147: LD_INT 0
40149: PUSH
40150: LD_INT 0
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 0
40159: PUSH
40160: LD_INT 1
40162: NEG
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 1
40170: PUSH
40171: LD_INT 0
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 1
40180: PUSH
40181: LD_INT 1
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 0
40190: PUSH
40191: LD_INT 1
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 1
40200: NEG
40201: PUSH
40202: LD_INT 0
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 1
40211: NEG
40212: PUSH
40213: LD_INT 1
40215: NEG
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 2
40223: PUSH
40224: LD_INT 1
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 2
40233: PUSH
40234: LD_INT 2
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 1
40243: PUSH
40244: LD_INT 2
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 0
40253: PUSH
40254: LD_INT 2
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 1
40263: NEG
40264: PUSH
40265: LD_INT 1
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: LIST
40276: LIST
40277: LIST
40278: LIST
40279: LIST
40280: LIST
40281: LIST
40282: LIST
40283: LIST
40284: LIST
40285: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40286: LD_ADDR_VAR 0 51
40290: PUSH
40291: LD_INT 0
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 0
40303: PUSH
40304: LD_INT 1
40306: NEG
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 1
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 1
40324: PUSH
40325: LD_INT 1
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 0
40334: PUSH
40335: LD_INT 1
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 1
40344: NEG
40345: PUSH
40346: LD_INT 0
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 1
40355: NEG
40356: PUSH
40357: LD_INT 1
40359: NEG
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 1
40367: PUSH
40368: LD_INT 2
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: LD_INT 2
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 1
40387: NEG
40388: PUSH
40389: LD_INT 1
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: PUSH
40396: LD_INT 2
40398: NEG
40399: PUSH
40400: LD_INT 0
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: LD_INT 2
40409: NEG
40410: PUSH
40411: LD_INT 1
40413: NEG
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: LIST
40428: LIST
40429: LIST
40430: LIST
40431: LIST
40432: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40433: LD_ADDR_VAR 0 52
40437: PUSH
40438: LD_INT 0
40440: PUSH
40441: LD_INT 0
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 0
40450: PUSH
40451: LD_INT 1
40453: NEG
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 1
40461: PUSH
40462: LD_INT 0
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 1
40471: PUSH
40472: LD_INT 1
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 0
40481: PUSH
40482: LD_INT 1
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: LD_INT 0
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 1
40502: NEG
40503: PUSH
40504: LD_INT 1
40506: NEG
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 1
40514: NEG
40515: PUSH
40516: LD_INT 2
40518: NEG
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: PUSH
40524: LD_INT 1
40526: NEG
40527: PUSH
40528: LD_INT 1
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 2
40537: NEG
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 2
40548: NEG
40549: PUSH
40550: LD_INT 1
40552: NEG
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 2
40560: NEG
40561: PUSH
40562: LD_INT 2
40564: NEG
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: LIST
40582: LIST
40583: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40584: LD_ADDR_VAR 0 53
40588: PUSH
40589: LD_INT 0
40591: PUSH
40592: LD_INT 0
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 0
40601: PUSH
40602: LD_INT 1
40604: NEG
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 1
40612: PUSH
40613: LD_INT 0
40615: PUSH
40616: EMPTY
40617: LIST
40618: LIST
40619: PUSH
40620: LD_INT 1
40622: PUSH
40623: LD_INT 1
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 0
40632: PUSH
40633: LD_INT 1
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 1
40642: NEG
40643: PUSH
40644: LD_INT 0
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 1
40653: NEG
40654: PUSH
40655: LD_INT 1
40657: NEG
40658: PUSH
40659: EMPTY
40660: LIST
40661: LIST
40662: PUSH
40663: LD_INT 1
40665: NEG
40666: PUSH
40667: LD_INT 2
40669: NEG
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 0
40677: PUSH
40678: LD_INT 2
40680: NEG
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: LD_INT 1
40688: PUSH
40689: LD_INT 1
40691: NEG
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: LD_INT 2
40699: PUSH
40700: LD_INT 0
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 2
40709: PUSH
40710: LD_INT 1
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 2
40719: PUSH
40720: LD_INT 2
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 1
40729: PUSH
40730: LD_INT 2
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 0
40739: PUSH
40740: LD_INT 2
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 1
40749: NEG
40750: PUSH
40751: LD_INT 1
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: PUSH
40758: LD_INT 2
40760: NEG
40761: PUSH
40762: LD_INT 0
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PUSH
40769: LD_INT 2
40771: NEG
40772: PUSH
40773: LD_INT 1
40775: NEG
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: LD_INT 2
40783: NEG
40784: PUSH
40785: LD_INT 2
40787: NEG
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: LIST
40797: LIST
40798: LIST
40799: LIST
40800: LIST
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: LIST
40806: LIST
40807: LIST
40808: LIST
40809: LIST
40810: LIST
40811: LIST
40812: LIST
40813: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40814: LD_ADDR_VAR 0 54
40818: PUSH
40819: LD_INT 0
40821: PUSH
40822: LD_INT 0
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: LD_INT 0
40831: PUSH
40832: LD_INT 1
40834: NEG
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 1
40842: PUSH
40843: LD_INT 0
40845: PUSH
40846: EMPTY
40847: LIST
40848: LIST
40849: PUSH
40850: LD_INT 1
40852: PUSH
40853: LD_INT 1
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 0
40862: PUSH
40863: LD_INT 1
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 1
40872: NEG
40873: PUSH
40874: LD_INT 0
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 1
40883: NEG
40884: PUSH
40885: LD_INT 1
40887: NEG
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 1
40895: NEG
40896: PUSH
40897: LD_INT 2
40899: NEG
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 0
40907: PUSH
40908: LD_INT 2
40910: NEG
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 1
40918: PUSH
40919: LD_INT 1
40921: NEG
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 2
40929: PUSH
40930: LD_INT 0
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 2
40939: PUSH
40940: LD_INT 1
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 2
40949: PUSH
40950: LD_INT 2
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: LD_INT 2
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 0
40969: PUSH
40970: LD_INT 2
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: NEG
40980: PUSH
40981: LD_INT 1
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: LD_INT 2
40990: NEG
40991: PUSH
40992: LD_INT 0
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PUSH
40999: LD_INT 2
41001: NEG
41002: PUSH
41003: LD_INT 1
41005: NEG
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: LD_INT 2
41013: NEG
41014: PUSH
41015: LD_INT 2
41017: NEG
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: LIST
41033: LIST
41034: LIST
41035: LIST
41036: LIST
41037: LIST
41038: LIST
41039: LIST
41040: LIST
41041: LIST
41042: LIST
41043: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41044: LD_ADDR_VAR 0 55
41048: PUSH
41049: LD_INT 0
41051: PUSH
41052: LD_INT 0
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 0
41061: PUSH
41062: LD_INT 1
41064: NEG
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 1
41072: PUSH
41073: LD_INT 0
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: LD_INT 1
41082: PUSH
41083: LD_INT 1
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 0
41092: PUSH
41093: LD_INT 1
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 1
41102: NEG
41103: PUSH
41104: LD_INT 0
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 1
41113: NEG
41114: PUSH
41115: LD_INT 1
41117: NEG
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 1
41125: NEG
41126: PUSH
41127: LD_INT 2
41129: NEG
41130: PUSH
41131: EMPTY
41132: LIST
41133: LIST
41134: PUSH
41135: LD_INT 0
41137: PUSH
41138: LD_INT 2
41140: NEG
41141: PUSH
41142: EMPTY
41143: LIST
41144: LIST
41145: PUSH
41146: LD_INT 1
41148: PUSH
41149: LD_INT 1
41151: NEG
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 2
41159: PUSH
41160: LD_INT 0
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 2
41169: PUSH
41170: LD_INT 1
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 2
41179: PUSH
41180: LD_INT 2
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 1
41189: PUSH
41190: LD_INT 2
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 0
41199: PUSH
41200: LD_INT 2
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: LD_INT 1
41209: NEG
41210: PUSH
41211: LD_INT 1
41213: PUSH
41214: EMPTY
41215: LIST
41216: LIST
41217: PUSH
41218: LD_INT 2
41220: NEG
41221: PUSH
41222: LD_INT 0
41224: PUSH
41225: EMPTY
41226: LIST
41227: LIST
41228: PUSH
41229: LD_INT 2
41231: NEG
41232: PUSH
41233: LD_INT 1
41235: NEG
41236: PUSH
41237: EMPTY
41238: LIST
41239: LIST
41240: PUSH
41241: LD_INT 2
41243: NEG
41244: PUSH
41245: LD_INT 2
41247: NEG
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: LIST
41257: LIST
41258: LIST
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: LIST
41266: LIST
41267: LIST
41268: LIST
41269: LIST
41270: LIST
41271: LIST
41272: LIST
41273: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41274: LD_ADDR_VAR 0 56
41278: PUSH
41279: LD_INT 0
41281: PUSH
41282: LD_INT 0
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: PUSH
41289: LD_INT 0
41291: PUSH
41292: LD_INT 1
41294: NEG
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: LD_INT 1
41302: PUSH
41303: LD_INT 0
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 1
41312: PUSH
41313: LD_INT 1
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: LD_INT 0
41322: PUSH
41323: LD_INT 1
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 1
41332: NEG
41333: PUSH
41334: LD_INT 0
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PUSH
41341: LD_INT 1
41343: NEG
41344: PUSH
41345: LD_INT 1
41347: NEG
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 1
41355: NEG
41356: PUSH
41357: LD_INT 2
41359: NEG
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 0
41367: PUSH
41368: LD_INT 2
41370: NEG
41371: PUSH
41372: EMPTY
41373: LIST
41374: LIST
41375: PUSH
41376: LD_INT 1
41378: PUSH
41379: LD_INT 1
41381: NEG
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 2
41389: PUSH
41390: LD_INT 0
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 2
41399: PUSH
41400: LD_INT 1
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 2
41409: PUSH
41410: LD_INT 2
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: LD_INT 1
41419: PUSH
41420: LD_INT 2
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 0
41429: PUSH
41430: LD_INT 2
41432: PUSH
41433: EMPTY
41434: LIST
41435: LIST
41436: PUSH
41437: LD_INT 1
41439: NEG
41440: PUSH
41441: LD_INT 1
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PUSH
41448: LD_INT 2
41450: NEG
41451: PUSH
41452: LD_INT 0
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 2
41461: NEG
41462: PUSH
41463: LD_INT 1
41465: NEG
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 2
41473: NEG
41474: PUSH
41475: LD_INT 2
41477: NEG
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: LIST
41487: LIST
41488: LIST
41489: LIST
41490: LIST
41491: LIST
41492: LIST
41493: LIST
41494: LIST
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: LIST
41502: LIST
41503: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41504: LD_ADDR_VAR 0 57
41508: PUSH
41509: LD_INT 0
41511: PUSH
41512: LD_INT 0
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 0
41521: PUSH
41522: LD_INT 1
41524: NEG
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 1
41532: PUSH
41533: LD_INT 0
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: LD_INT 1
41542: PUSH
41543: LD_INT 1
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 0
41552: PUSH
41553: LD_INT 1
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 1
41562: NEG
41563: PUSH
41564: LD_INT 0
41566: PUSH
41567: EMPTY
41568: LIST
41569: LIST
41570: PUSH
41571: LD_INT 1
41573: NEG
41574: PUSH
41575: LD_INT 1
41577: NEG
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: PUSH
41583: LD_INT 1
41585: NEG
41586: PUSH
41587: LD_INT 2
41589: NEG
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 0
41597: PUSH
41598: LD_INT 2
41600: NEG
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 1
41608: PUSH
41609: LD_INT 1
41611: NEG
41612: PUSH
41613: EMPTY
41614: LIST
41615: LIST
41616: PUSH
41617: LD_INT 2
41619: PUSH
41620: LD_INT 0
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 2
41629: PUSH
41630: LD_INT 1
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 2
41639: PUSH
41640: LD_INT 2
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: LD_INT 1
41649: PUSH
41650: LD_INT 2
41652: PUSH
41653: EMPTY
41654: LIST
41655: LIST
41656: PUSH
41657: LD_INT 0
41659: PUSH
41660: LD_INT 2
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: LD_INT 1
41669: NEG
41670: PUSH
41671: LD_INT 1
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: PUSH
41678: LD_INT 2
41680: NEG
41681: PUSH
41682: LD_INT 0
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 2
41691: NEG
41692: PUSH
41693: LD_INT 1
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: LD_INT 2
41703: NEG
41704: PUSH
41705: LD_INT 2
41707: NEG
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: LIST
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: LIST
41723: LIST
41724: LIST
41725: LIST
41726: LIST
41727: LIST
41728: LIST
41729: LIST
41730: LIST
41731: LIST
41732: LIST
41733: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41734: LD_ADDR_VAR 0 58
41738: PUSH
41739: LD_INT 0
41741: PUSH
41742: LD_INT 0
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 0
41751: PUSH
41752: LD_INT 1
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 1
41762: PUSH
41763: LD_INT 0
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 1
41772: PUSH
41773: LD_INT 1
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 0
41782: PUSH
41783: LD_INT 1
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: LD_INT 1
41792: NEG
41793: PUSH
41794: LD_INT 0
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 1
41803: NEG
41804: PUSH
41805: LD_INT 1
41807: NEG
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: LD_INT 1
41815: NEG
41816: PUSH
41817: LD_INT 2
41819: NEG
41820: PUSH
41821: EMPTY
41822: LIST
41823: LIST
41824: PUSH
41825: LD_INT 0
41827: PUSH
41828: LD_INT 2
41830: NEG
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: PUSH
41836: LD_INT 1
41838: PUSH
41839: LD_INT 1
41841: NEG
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 2
41849: PUSH
41850: LD_INT 0
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 2
41859: PUSH
41860: LD_INT 1
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 2
41869: PUSH
41870: LD_INT 2
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 1
41879: PUSH
41880: LD_INT 2
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 0
41889: PUSH
41890: LD_INT 2
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: PUSH
41897: LD_INT 1
41899: NEG
41900: PUSH
41901: LD_INT 1
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 2
41910: NEG
41911: PUSH
41912: LD_INT 0
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 2
41921: NEG
41922: PUSH
41923: LD_INT 1
41925: NEG
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: PUSH
41931: LD_INT 2
41933: NEG
41934: PUSH
41935: LD_INT 2
41937: NEG
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: LIST
41947: LIST
41948: LIST
41949: LIST
41950: LIST
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: LIST
41962: LIST
41963: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41964: LD_ADDR_VAR 0 59
41968: PUSH
41969: LD_INT 0
41971: PUSH
41972: LD_INT 0
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 0
41981: PUSH
41982: LD_INT 1
41984: NEG
41985: PUSH
41986: EMPTY
41987: LIST
41988: LIST
41989: PUSH
41990: LD_INT 1
41992: PUSH
41993: LD_INT 0
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 1
42002: PUSH
42003: LD_INT 1
42005: PUSH
42006: EMPTY
42007: LIST
42008: LIST
42009: PUSH
42010: LD_INT 0
42012: PUSH
42013: LD_INT 1
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: LD_INT 1
42022: NEG
42023: PUSH
42024: LD_INT 0
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: PUSH
42031: LD_INT 1
42033: NEG
42034: PUSH
42035: LD_INT 1
42037: NEG
42038: PUSH
42039: EMPTY
42040: LIST
42041: LIST
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: LIST
42047: LIST
42048: LIST
42049: LIST
42050: LIST
42051: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42052: LD_ADDR_VAR 0 60
42056: PUSH
42057: LD_INT 0
42059: PUSH
42060: LD_INT 0
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: PUSH
42067: LD_INT 0
42069: PUSH
42070: LD_INT 1
42072: NEG
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PUSH
42078: LD_INT 1
42080: PUSH
42081: LD_INT 0
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 1
42090: PUSH
42091: LD_INT 1
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 0
42100: PUSH
42101: LD_INT 1
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 1
42110: NEG
42111: PUSH
42112: LD_INT 0
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 1
42121: NEG
42122: PUSH
42123: LD_INT 1
42125: NEG
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: EMPTY
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42140: LD_ADDR_VAR 0 61
42144: PUSH
42145: LD_INT 0
42147: PUSH
42148: LD_INT 0
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 0
42157: PUSH
42158: LD_INT 1
42160: NEG
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: LD_INT 1
42168: PUSH
42169: LD_INT 0
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 1
42178: PUSH
42179: LD_INT 1
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: LD_INT 0
42188: PUSH
42189: LD_INT 1
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 1
42198: NEG
42199: PUSH
42200: LD_INT 0
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 1
42209: NEG
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: LIST
42223: LIST
42224: LIST
42225: LIST
42226: LIST
42227: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42228: LD_ADDR_VAR 0 62
42232: PUSH
42233: LD_INT 0
42235: PUSH
42236: LD_INT 0
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 0
42245: PUSH
42246: LD_INT 1
42248: NEG
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PUSH
42254: LD_INT 1
42256: PUSH
42257: LD_INT 0
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: PUSH
42264: LD_INT 1
42266: PUSH
42267: LD_INT 1
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 0
42276: PUSH
42277: LD_INT 1
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: LD_INT 1
42286: NEG
42287: PUSH
42288: LD_INT 0
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 1
42297: NEG
42298: PUSH
42299: LD_INT 1
42301: NEG
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: LIST
42314: LIST
42315: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42316: LD_ADDR_VAR 0 63
42320: PUSH
42321: LD_INT 0
42323: PUSH
42324: LD_INT 0
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: LD_INT 0
42333: PUSH
42334: LD_INT 1
42336: NEG
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: PUSH
42342: LD_INT 1
42344: PUSH
42345: LD_INT 0
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 1
42354: PUSH
42355: LD_INT 1
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 0
42364: PUSH
42365: LD_INT 1
42367: PUSH
42368: EMPTY
42369: LIST
42370: LIST
42371: PUSH
42372: LD_INT 1
42374: NEG
42375: PUSH
42376: LD_INT 0
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PUSH
42383: LD_INT 1
42385: NEG
42386: PUSH
42387: LD_INT 1
42389: NEG
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: LIST
42399: LIST
42400: LIST
42401: LIST
42402: LIST
42403: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42404: LD_ADDR_VAR 0 64
42408: PUSH
42409: LD_INT 0
42411: PUSH
42412: LD_INT 0
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 0
42421: PUSH
42422: LD_INT 1
42424: NEG
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: PUSH
42430: LD_INT 1
42432: PUSH
42433: LD_INT 0
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: LD_INT 1
42442: PUSH
42443: LD_INT 1
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 0
42452: PUSH
42453: LD_INT 1
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PUSH
42460: LD_INT 1
42462: NEG
42463: PUSH
42464: LD_INT 0
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 1
42473: NEG
42474: PUSH
42475: LD_INT 1
42477: NEG
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: LIST
42487: LIST
42488: LIST
42489: LIST
42490: LIST
42491: ST_TO_ADDR
// end ; 1 :
42492: GO 48389
42494: LD_INT 1
42496: DOUBLE
42497: EQUAL
42498: IFTRUE 42502
42500: GO 45125
42502: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42503: LD_ADDR_VAR 0 11
42507: PUSH
42508: LD_INT 1
42510: NEG
42511: PUSH
42512: LD_INT 3
42514: NEG
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: LD_INT 0
42522: PUSH
42523: LD_INT 3
42525: NEG
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: LD_INT 1
42533: PUSH
42534: LD_INT 2
42536: NEG
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: LIST
42546: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42547: LD_ADDR_VAR 0 12
42551: PUSH
42552: LD_INT 2
42554: PUSH
42555: LD_INT 1
42557: NEG
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 3
42565: PUSH
42566: LD_INT 0
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 3
42575: PUSH
42576: LD_INT 1
42578: PUSH
42579: EMPTY
42580: LIST
42581: LIST
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: LIST
42587: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42588: LD_ADDR_VAR 0 13
42592: PUSH
42593: LD_INT 3
42595: PUSH
42596: LD_INT 2
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: LD_INT 3
42605: PUSH
42606: LD_INT 3
42608: PUSH
42609: EMPTY
42610: LIST
42611: LIST
42612: PUSH
42613: LD_INT 2
42615: PUSH
42616: LD_INT 3
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: LIST
42627: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42628: LD_ADDR_VAR 0 14
42632: PUSH
42633: LD_INT 1
42635: PUSH
42636: LD_INT 3
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: LD_INT 0
42645: PUSH
42646: LD_INT 3
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 1
42655: NEG
42656: PUSH
42657: LD_INT 2
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: LIST
42668: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42669: LD_ADDR_VAR 0 15
42673: PUSH
42674: LD_INT 2
42676: NEG
42677: PUSH
42678: LD_INT 1
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: LD_INT 3
42687: NEG
42688: PUSH
42689: LD_INT 0
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: LD_INT 3
42698: NEG
42699: PUSH
42700: LD_INT 1
42702: NEG
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: LIST
42712: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42713: LD_ADDR_VAR 0 16
42717: PUSH
42718: LD_INT 2
42720: NEG
42721: PUSH
42722: LD_INT 3
42724: NEG
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 3
42732: NEG
42733: PUSH
42734: LD_INT 2
42736: NEG
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: LD_INT 3
42744: NEG
42745: PUSH
42746: LD_INT 3
42748: NEG
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: LIST
42758: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42759: LD_ADDR_VAR 0 17
42763: PUSH
42764: LD_INT 1
42766: NEG
42767: PUSH
42768: LD_INT 3
42770: NEG
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: LD_INT 0
42778: PUSH
42779: LD_INT 3
42781: NEG
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 1
42789: PUSH
42790: LD_INT 2
42792: NEG
42793: PUSH
42794: EMPTY
42795: LIST
42796: LIST
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: LIST
42802: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42803: LD_ADDR_VAR 0 18
42807: PUSH
42808: LD_INT 2
42810: PUSH
42811: LD_INT 1
42813: NEG
42814: PUSH
42815: EMPTY
42816: LIST
42817: LIST
42818: PUSH
42819: LD_INT 3
42821: PUSH
42822: LD_INT 0
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 3
42831: PUSH
42832: LD_INT 1
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: LIST
42843: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42844: LD_ADDR_VAR 0 19
42848: PUSH
42849: LD_INT 3
42851: PUSH
42852: LD_INT 2
42854: PUSH
42855: EMPTY
42856: LIST
42857: LIST
42858: PUSH
42859: LD_INT 3
42861: PUSH
42862: LD_INT 3
42864: PUSH
42865: EMPTY
42866: LIST
42867: LIST
42868: PUSH
42869: LD_INT 2
42871: PUSH
42872: LD_INT 3
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: LIST
42883: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42884: LD_ADDR_VAR 0 20
42888: PUSH
42889: LD_INT 1
42891: PUSH
42892: LD_INT 3
42894: PUSH
42895: EMPTY
42896: LIST
42897: LIST
42898: PUSH
42899: LD_INT 0
42901: PUSH
42902: LD_INT 3
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 1
42911: NEG
42912: PUSH
42913: LD_INT 2
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: EMPTY
42921: LIST
42922: LIST
42923: LIST
42924: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42925: LD_ADDR_VAR 0 21
42929: PUSH
42930: LD_INT 2
42932: NEG
42933: PUSH
42934: LD_INT 1
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 3
42943: NEG
42944: PUSH
42945: LD_INT 0
42947: PUSH
42948: EMPTY
42949: LIST
42950: LIST
42951: PUSH
42952: LD_INT 3
42954: NEG
42955: PUSH
42956: LD_INT 1
42958: NEG
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: LIST
42968: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42969: LD_ADDR_VAR 0 22
42973: PUSH
42974: LD_INT 2
42976: NEG
42977: PUSH
42978: LD_INT 3
42980: NEG
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: LD_INT 3
42988: NEG
42989: PUSH
42990: LD_INT 2
42992: NEG
42993: PUSH
42994: EMPTY
42995: LIST
42996: LIST
42997: PUSH
42998: LD_INT 3
43000: NEG
43001: PUSH
43002: LD_INT 3
43004: NEG
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: PUSH
43010: EMPTY
43011: LIST
43012: LIST
43013: LIST
43014: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43015: LD_ADDR_VAR 0 23
43019: PUSH
43020: LD_INT 0
43022: PUSH
43023: LD_INT 3
43025: NEG
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: LD_INT 1
43033: NEG
43034: PUSH
43035: LD_INT 4
43037: NEG
43038: PUSH
43039: EMPTY
43040: LIST
43041: LIST
43042: PUSH
43043: LD_INT 1
43045: PUSH
43046: LD_INT 3
43048: NEG
43049: PUSH
43050: EMPTY
43051: LIST
43052: LIST
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: LIST
43058: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43059: LD_ADDR_VAR 0 24
43063: PUSH
43064: LD_INT 3
43066: PUSH
43067: LD_INT 0
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_INT 3
43076: PUSH
43077: LD_INT 1
43079: NEG
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 4
43087: PUSH
43088: LD_INT 1
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: LIST
43099: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
43100: LD_ADDR_VAR 0 25
43104: PUSH
43105: LD_INT 3
43107: PUSH
43108: LD_INT 3
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: PUSH
43115: LD_INT 4
43117: PUSH
43118: LD_INT 3
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: PUSH
43125: LD_INT 3
43127: PUSH
43128: LD_INT 4
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: EMPTY
43136: LIST
43137: LIST
43138: LIST
43139: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
43140: LD_ADDR_VAR 0 26
43144: PUSH
43145: LD_INT 0
43147: PUSH
43148: LD_INT 3
43150: PUSH
43151: EMPTY
43152: LIST
43153: LIST
43154: PUSH
43155: LD_INT 1
43157: PUSH
43158: LD_INT 4
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 1
43167: NEG
43168: PUSH
43169: LD_INT 3
43171: PUSH
43172: EMPTY
43173: LIST
43174: LIST
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: LIST
43180: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
43181: LD_ADDR_VAR 0 27
43185: PUSH
43186: LD_INT 3
43188: NEG
43189: PUSH
43190: LD_INT 0
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: PUSH
43197: LD_INT 3
43199: NEG
43200: PUSH
43201: LD_INT 1
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: PUSH
43208: LD_INT 4
43210: NEG
43211: PUSH
43212: LD_INT 1
43214: NEG
43215: PUSH
43216: EMPTY
43217: LIST
43218: LIST
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: LIST
43224: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
43225: LD_ADDR_VAR 0 28
43229: PUSH
43230: LD_INT 3
43232: NEG
43233: PUSH
43234: LD_INT 3
43236: NEG
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 3
43244: NEG
43245: PUSH
43246: LD_INT 4
43248: NEG
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: LD_INT 4
43256: NEG
43257: PUSH
43258: LD_INT 3
43260: NEG
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: LIST
43270: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
43271: LD_ADDR_VAR 0 29
43275: PUSH
43276: LD_INT 1
43278: NEG
43279: PUSH
43280: LD_INT 3
43282: NEG
43283: PUSH
43284: EMPTY
43285: LIST
43286: LIST
43287: PUSH
43288: LD_INT 0
43290: PUSH
43291: LD_INT 3
43293: NEG
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 1
43301: PUSH
43302: LD_INT 2
43304: NEG
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 1
43312: NEG
43313: PUSH
43314: LD_INT 4
43316: NEG
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 0
43324: PUSH
43325: LD_INT 4
43327: NEG
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 1
43335: PUSH
43336: LD_INT 3
43338: NEG
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 1
43346: NEG
43347: PUSH
43348: LD_INT 5
43350: NEG
43351: PUSH
43352: EMPTY
43353: LIST
43354: LIST
43355: PUSH
43356: LD_INT 0
43358: PUSH
43359: LD_INT 5
43361: NEG
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: LD_INT 1
43369: PUSH
43370: LD_INT 4
43372: NEG
43373: PUSH
43374: EMPTY
43375: LIST
43376: LIST
43377: PUSH
43378: LD_INT 1
43380: NEG
43381: PUSH
43382: LD_INT 6
43384: NEG
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: PUSH
43390: LD_INT 0
43392: PUSH
43393: LD_INT 6
43395: NEG
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 1
43403: PUSH
43404: LD_INT 5
43406: NEG
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: EMPTY
43413: LIST
43414: LIST
43415: LIST
43416: LIST
43417: LIST
43418: LIST
43419: LIST
43420: LIST
43421: LIST
43422: LIST
43423: LIST
43424: LIST
43425: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
43426: LD_ADDR_VAR 0 30
43430: PUSH
43431: LD_INT 2
43433: PUSH
43434: LD_INT 1
43436: NEG
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 3
43444: PUSH
43445: LD_INT 0
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 3
43454: PUSH
43455: LD_INT 1
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 3
43464: PUSH
43465: LD_INT 1
43467: NEG
43468: PUSH
43469: EMPTY
43470: LIST
43471: LIST
43472: PUSH
43473: LD_INT 4
43475: PUSH
43476: LD_INT 0
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PUSH
43483: LD_INT 4
43485: PUSH
43486: LD_INT 1
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 4
43495: PUSH
43496: LD_INT 1
43498: NEG
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 5
43506: PUSH
43507: LD_INT 0
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: PUSH
43514: LD_INT 5
43516: PUSH
43517: LD_INT 1
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 5
43526: PUSH
43527: LD_INT 1
43529: NEG
43530: PUSH
43531: EMPTY
43532: LIST
43533: LIST
43534: PUSH
43535: LD_INT 6
43537: PUSH
43538: LD_INT 0
43540: PUSH
43541: EMPTY
43542: LIST
43543: LIST
43544: PUSH
43545: LD_INT 6
43547: PUSH
43548: LD_INT 1
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: LIST
43559: LIST
43560: LIST
43561: LIST
43562: LIST
43563: LIST
43564: LIST
43565: LIST
43566: LIST
43567: LIST
43568: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
43569: LD_ADDR_VAR 0 31
43573: PUSH
43574: LD_INT 3
43576: PUSH
43577: LD_INT 2
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 3
43586: PUSH
43587: LD_INT 3
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 2
43596: PUSH
43597: LD_INT 3
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: PUSH
43604: LD_INT 4
43606: PUSH
43607: LD_INT 3
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 4
43616: PUSH
43617: LD_INT 4
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 3
43626: PUSH
43627: LD_INT 4
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 5
43636: PUSH
43637: LD_INT 4
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 5
43646: PUSH
43647: LD_INT 5
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 4
43656: PUSH
43657: LD_INT 5
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 6
43666: PUSH
43667: LD_INT 5
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 6
43676: PUSH
43677: LD_INT 6
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 5
43686: PUSH
43687: LD_INT 6
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
43708: LD_ADDR_VAR 0 32
43712: PUSH
43713: LD_INT 1
43715: PUSH
43716: LD_INT 3
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: LD_INT 0
43725: PUSH
43726: LD_INT 3
43728: PUSH
43729: EMPTY
43730: LIST
43731: LIST
43732: PUSH
43733: LD_INT 1
43735: NEG
43736: PUSH
43737: LD_INT 2
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PUSH
43744: LD_INT 1
43746: PUSH
43747: LD_INT 4
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 0
43756: PUSH
43757: LD_INT 4
43759: PUSH
43760: EMPTY
43761: LIST
43762: LIST
43763: PUSH
43764: LD_INT 1
43766: NEG
43767: PUSH
43768: LD_INT 3
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 1
43777: PUSH
43778: LD_INT 5
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 0
43787: PUSH
43788: LD_INT 5
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 1
43797: NEG
43798: PUSH
43799: LD_INT 4
43801: PUSH
43802: EMPTY
43803: LIST
43804: LIST
43805: PUSH
43806: LD_INT 1
43808: PUSH
43809: LD_INT 6
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: PUSH
43816: LD_INT 0
43818: PUSH
43819: LD_INT 6
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: PUSH
43826: LD_INT 1
43828: NEG
43829: PUSH
43830: LD_INT 5
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: LIST
43850: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
43851: LD_ADDR_VAR 0 33
43855: PUSH
43856: LD_INT 2
43858: NEG
43859: PUSH
43860: LD_INT 1
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 3
43869: NEG
43870: PUSH
43871: LD_INT 0
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 3
43880: NEG
43881: PUSH
43882: LD_INT 1
43884: NEG
43885: PUSH
43886: EMPTY
43887: LIST
43888: LIST
43889: PUSH
43890: LD_INT 3
43892: NEG
43893: PUSH
43894: LD_INT 1
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 4
43903: NEG
43904: PUSH
43905: LD_INT 0
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: PUSH
43912: LD_INT 4
43914: NEG
43915: PUSH
43916: LD_INT 1
43918: NEG
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 4
43926: NEG
43927: PUSH
43928: LD_INT 1
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 5
43937: NEG
43938: PUSH
43939: LD_INT 0
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 5
43948: NEG
43949: PUSH
43950: LD_INT 1
43952: NEG
43953: PUSH
43954: EMPTY
43955: LIST
43956: LIST
43957: PUSH
43958: LD_INT 5
43960: NEG
43961: PUSH
43962: LD_INT 1
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PUSH
43969: LD_INT 6
43971: NEG
43972: PUSH
43973: LD_INT 0
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 6
43982: NEG
43983: PUSH
43984: LD_INT 1
43986: NEG
43987: PUSH
43988: EMPTY
43989: LIST
43990: LIST
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: LIST
43996: LIST
43997: LIST
43998: LIST
43999: LIST
44000: LIST
44001: LIST
44002: LIST
44003: LIST
44004: LIST
44005: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44006: LD_ADDR_VAR 0 34
44010: PUSH
44011: LD_INT 2
44013: NEG
44014: PUSH
44015: LD_INT 3
44017: NEG
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: PUSH
44023: LD_INT 3
44025: NEG
44026: PUSH
44027: LD_INT 2
44029: NEG
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 3
44037: NEG
44038: PUSH
44039: LD_INT 3
44041: NEG
44042: PUSH
44043: EMPTY
44044: LIST
44045: LIST
44046: PUSH
44047: LD_INT 3
44049: NEG
44050: PUSH
44051: LD_INT 4
44053: NEG
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 4
44061: NEG
44062: PUSH
44063: LD_INT 3
44065: NEG
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 4
44073: NEG
44074: PUSH
44075: LD_INT 4
44077: NEG
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: PUSH
44083: LD_INT 4
44085: NEG
44086: PUSH
44087: LD_INT 5
44089: NEG
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 5
44097: NEG
44098: PUSH
44099: LD_INT 4
44101: NEG
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: PUSH
44107: LD_INT 5
44109: NEG
44110: PUSH
44111: LD_INT 5
44113: NEG
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 5
44121: NEG
44122: PUSH
44123: LD_INT 6
44125: NEG
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 6
44133: NEG
44134: PUSH
44135: LD_INT 5
44137: NEG
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 6
44145: NEG
44146: PUSH
44147: LD_INT 6
44149: NEG
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: LIST
44159: LIST
44160: LIST
44161: LIST
44162: LIST
44163: LIST
44164: LIST
44165: LIST
44166: LIST
44167: LIST
44168: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
44169: LD_ADDR_VAR 0 41
44173: PUSH
44174: LD_INT 0
44176: PUSH
44177: LD_INT 2
44179: NEG
44180: PUSH
44181: EMPTY
44182: LIST
44183: LIST
44184: PUSH
44185: LD_INT 1
44187: NEG
44188: PUSH
44189: LD_INT 3
44191: NEG
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PUSH
44197: LD_INT 1
44199: PUSH
44200: LD_INT 2
44202: NEG
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: LIST
44212: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
44213: LD_ADDR_VAR 0 42
44217: PUSH
44218: LD_INT 2
44220: PUSH
44221: LD_INT 0
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: PUSH
44228: LD_INT 2
44230: PUSH
44231: LD_INT 1
44233: NEG
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: PUSH
44239: LD_INT 3
44241: PUSH
44242: LD_INT 1
44244: PUSH
44245: EMPTY
44246: LIST
44247: LIST
44248: PUSH
44249: EMPTY
44250: LIST
44251: LIST
44252: LIST
44253: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
44254: LD_ADDR_VAR 0 43
44258: PUSH
44259: LD_INT 2
44261: PUSH
44262: LD_INT 2
44264: PUSH
44265: EMPTY
44266: LIST
44267: LIST
44268: PUSH
44269: LD_INT 3
44271: PUSH
44272: LD_INT 2
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 2
44281: PUSH
44282: LD_INT 3
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: LIST
44293: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
44294: LD_ADDR_VAR 0 44
44298: PUSH
44299: LD_INT 0
44301: PUSH
44302: LD_INT 2
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PUSH
44309: LD_INT 1
44311: PUSH
44312: LD_INT 3
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: PUSH
44319: LD_INT 1
44321: NEG
44322: PUSH
44323: LD_INT 2
44325: PUSH
44326: EMPTY
44327: LIST
44328: LIST
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: LIST
44334: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
44335: LD_ADDR_VAR 0 45
44339: PUSH
44340: LD_INT 2
44342: NEG
44343: PUSH
44344: LD_INT 0
44346: PUSH
44347: EMPTY
44348: LIST
44349: LIST
44350: PUSH
44351: LD_INT 2
44353: NEG
44354: PUSH
44355: LD_INT 1
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 3
44364: NEG
44365: PUSH
44366: LD_INT 1
44368: NEG
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: LIST
44378: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
44379: LD_ADDR_VAR 0 46
44383: PUSH
44384: LD_INT 2
44386: NEG
44387: PUSH
44388: LD_INT 2
44390: NEG
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 2
44398: NEG
44399: PUSH
44400: LD_INT 3
44402: NEG
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: PUSH
44408: LD_INT 3
44410: NEG
44411: PUSH
44412: LD_INT 2
44414: NEG
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: LIST
44424: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
44425: LD_ADDR_VAR 0 47
44429: PUSH
44430: LD_INT 2
44432: NEG
44433: PUSH
44434: LD_INT 3
44436: NEG
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PUSH
44442: LD_INT 1
44444: NEG
44445: PUSH
44446: LD_INT 3
44448: NEG
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: EMPTY
44455: LIST
44456: LIST
44457: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
44458: LD_ADDR_VAR 0 48
44462: PUSH
44463: LD_INT 1
44465: PUSH
44466: LD_INT 2
44468: NEG
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 2
44476: PUSH
44477: LD_INT 1
44479: NEG
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
44489: LD_ADDR_VAR 0 49
44493: PUSH
44494: LD_INT 3
44496: PUSH
44497: LD_INT 1
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: LD_INT 3
44506: PUSH
44507: LD_INT 2
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
44518: LD_ADDR_VAR 0 50
44522: PUSH
44523: LD_INT 2
44525: PUSH
44526: LD_INT 3
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 1
44535: PUSH
44536: LD_INT 3
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: EMPTY
44544: LIST
44545: LIST
44546: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
44547: LD_ADDR_VAR 0 51
44551: PUSH
44552: LD_INT 1
44554: NEG
44555: PUSH
44556: LD_INT 2
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: LD_INT 2
44565: NEG
44566: PUSH
44567: LD_INT 1
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
44578: LD_ADDR_VAR 0 52
44582: PUSH
44583: LD_INT 3
44585: NEG
44586: PUSH
44587: LD_INT 1
44589: NEG
44590: PUSH
44591: EMPTY
44592: LIST
44593: LIST
44594: PUSH
44595: LD_INT 3
44597: NEG
44598: PUSH
44599: LD_INT 2
44601: NEG
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44611: LD_ADDR_VAR 0 53
44615: PUSH
44616: LD_INT 1
44618: NEG
44619: PUSH
44620: LD_INT 3
44622: NEG
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 0
44630: PUSH
44631: LD_INT 3
44633: NEG
44634: PUSH
44635: EMPTY
44636: LIST
44637: LIST
44638: PUSH
44639: LD_INT 1
44641: PUSH
44642: LD_INT 2
44644: NEG
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: PUSH
44650: EMPTY
44651: LIST
44652: LIST
44653: LIST
44654: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44655: LD_ADDR_VAR 0 54
44659: PUSH
44660: LD_INT 2
44662: PUSH
44663: LD_INT 1
44665: NEG
44666: PUSH
44667: EMPTY
44668: LIST
44669: LIST
44670: PUSH
44671: LD_INT 3
44673: PUSH
44674: LD_INT 0
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 3
44683: PUSH
44684: LD_INT 1
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: LIST
44695: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44696: LD_ADDR_VAR 0 55
44700: PUSH
44701: LD_INT 3
44703: PUSH
44704: LD_INT 2
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 3
44713: PUSH
44714: LD_INT 3
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 2
44723: PUSH
44724: LD_INT 3
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: LIST
44735: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44736: LD_ADDR_VAR 0 56
44740: PUSH
44741: LD_INT 1
44743: PUSH
44744: LD_INT 3
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 0
44753: PUSH
44754: LD_INT 3
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 1
44763: NEG
44764: PUSH
44765: LD_INT 2
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: LIST
44776: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44777: LD_ADDR_VAR 0 57
44781: PUSH
44782: LD_INT 2
44784: NEG
44785: PUSH
44786: LD_INT 1
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PUSH
44793: LD_INT 3
44795: NEG
44796: PUSH
44797: LD_INT 0
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: PUSH
44804: LD_INT 3
44806: NEG
44807: PUSH
44808: LD_INT 1
44810: NEG
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: PUSH
44816: EMPTY
44817: LIST
44818: LIST
44819: LIST
44820: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44821: LD_ADDR_VAR 0 58
44825: PUSH
44826: LD_INT 2
44828: NEG
44829: PUSH
44830: LD_INT 3
44832: NEG
44833: PUSH
44834: EMPTY
44835: LIST
44836: LIST
44837: PUSH
44838: LD_INT 3
44840: NEG
44841: PUSH
44842: LD_INT 2
44844: NEG
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 3
44852: NEG
44853: PUSH
44854: LD_INT 3
44856: NEG
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PUSH
44862: EMPTY
44863: LIST
44864: LIST
44865: LIST
44866: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
44867: LD_ADDR_VAR 0 59
44871: PUSH
44872: LD_INT 1
44874: NEG
44875: PUSH
44876: LD_INT 2
44878: NEG
44879: PUSH
44880: EMPTY
44881: LIST
44882: LIST
44883: PUSH
44884: LD_INT 0
44886: PUSH
44887: LD_INT 2
44889: NEG
44890: PUSH
44891: EMPTY
44892: LIST
44893: LIST
44894: PUSH
44895: LD_INT 1
44897: PUSH
44898: LD_INT 1
44900: NEG
44901: PUSH
44902: EMPTY
44903: LIST
44904: LIST
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: LIST
44910: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
44911: LD_ADDR_VAR 0 60
44915: PUSH
44916: LD_INT 1
44918: PUSH
44919: LD_INT 1
44921: NEG
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: PUSH
44927: LD_INT 2
44929: PUSH
44930: LD_INT 0
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: PUSH
44937: LD_INT 2
44939: PUSH
44940: LD_INT 1
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: LIST
44951: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
44952: LD_ADDR_VAR 0 61
44956: PUSH
44957: LD_INT 2
44959: PUSH
44960: LD_INT 1
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: PUSH
44967: LD_INT 2
44969: PUSH
44970: LD_INT 2
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: PUSH
44977: LD_INT 1
44979: PUSH
44980: LD_INT 2
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: LIST
44991: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
44992: LD_ADDR_VAR 0 62
44996: PUSH
44997: LD_INT 1
44999: PUSH
45000: LD_INT 2
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 0
45009: PUSH
45010: LD_INT 2
45012: PUSH
45013: EMPTY
45014: LIST
45015: LIST
45016: PUSH
45017: LD_INT 1
45019: NEG
45020: PUSH
45021: LD_INT 1
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: LIST
45032: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45033: LD_ADDR_VAR 0 63
45037: PUSH
45038: LD_INT 1
45040: NEG
45041: PUSH
45042: LD_INT 1
45044: PUSH
45045: EMPTY
45046: LIST
45047: LIST
45048: PUSH
45049: LD_INT 2
45051: NEG
45052: PUSH
45053: LD_INT 0
45055: PUSH
45056: EMPTY
45057: LIST
45058: LIST
45059: PUSH
45060: LD_INT 2
45062: NEG
45063: PUSH
45064: LD_INT 1
45066: NEG
45067: PUSH
45068: EMPTY
45069: LIST
45070: LIST
45071: PUSH
45072: EMPTY
45073: LIST
45074: LIST
45075: LIST
45076: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45077: LD_ADDR_VAR 0 64
45081: PUSH
45082: LD_INT 1
45084: NEG
45085: PUSH
45086: LD_INT 2
45088: NEG
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 2
45096: NEG
45097: PUSH
45098: LD_INT 1
45100: NEG
45101: PUSH
45102: EMPTY
45103: LIST
45104: LIST
45105: PUSH
45106: LD_INT 2
45108: NEG
45109: PUSH
45110: LD_INT 2
45112: NEG
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PUSH
45118: EMPTY
45119: LIST
45120: LIST
45121: LIST
45122: ST_TO_ADDR
// end ; 2 :
45123: GO 48389
45125: LD_INT 2
45127: DOUBLE
45128: EQUAL
45129: IFTRUE 45133
45131: GO 48388
45133: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
45134: LD_ADDR_VAR 0 29
45138: PUSH
45139: LD_INT 4
45141: PUSH
45142: LD_INT 0
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 4
45151: PUSH
45152: LD_INT 1
45154: NEG
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: PUSH
45160: LD_INT 5
45162: PUSH
45163: LD_INT 0
45165: PUSH
45166: EMPTY
45167: LIST
45168: LIST
45169: PUSH
45170: LD_INT 5
45172: PUSH
45173: LD_INT 1
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 4
45182: PUSH
45183: LD_INT 1
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PUSH
45190: LD_INT 3
45192: PUSH
45193: LD_INT 0
45195: PUSH
45196: EMPTY
45197: LIST
45198: LIST
45199: PUSH
45200: LD_INT 3
45202: PUSH
45203: LD_INT 1
45205: NEG
45206: PUSH
45207: EMPTY
45208: LIST
45209: LIST
45210: PUSH
45211: LD_INT 3
45213: PUSH
45214: LD_INT 2
45216: NEG
45217: PUSH
45218: EMPTY
45219: LIST
45220: LIST
45221: PUSH
45222: LD_INT 5
45224: PUSH
45225: LD_INT 2
45227: PUSH
45228: EMPTY
45229: LIST
45230: LIST
45231: PUSH
45232: LD_INT 3
45234: PUSH
45235: LD_INT 3
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: PUSH
45242: LD_INT 3
45244: PUSH
45245: LD_INT 2
45247: PUSH
45248: EMPTY
45249: LIST
45250: LIST
45251: PUSH
45252: LD_INT 4
45254: PUSH
45255: LD_INT 3
45257: PUSH
45258: EMPTY
45259: LIST
45260: LIST
45261: PUSH
45262: LD_INT 4
45264: PUSH
45265: LD_INT 4
45267: PUSH
45268: EMPTY
45269: LIST
45270: LIST
45271: PUSH
45272: LD_INT 3
45274: PUSH
45275: LD_INT 4
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 2
45284: PUSH
45285: LD_INT 3
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: LD_INT 2
45294: PUSH
45295: LD_INT 2
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: LD_INT 4
45304: PUSH
45305: LD_INT 2
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: PUSH
45312: LD_INT 2
45314: PUSH
45315: LD_INT 4
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: LD_INT 0
45324: PUSH
45325: LD_INT 4
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: LD_INT 0
45334: PUSH
45335: LD_INT 3
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: PUSH
45342: LD_INT 1
45344: PUSH
45345: LD_INT 4
45347: PUSH
45348: EMPTY
45349: LIST
45350: LIST
45351: PUSH
45352: LD_INT 1
45354: PUSH
45355: LD_INT 5
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PUSH
45362: LD_INT 0
45364: PUSH
45365: LD_INT 5
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: PUSH
45372: LD_INT 1
45374: NEG
45375: PUSH
45376: LD_INT 4
45378: PUSH
45379: EMPTY
45380: LIST
45381: LIST
45382: PUSH
45383: LD_INT 1
45385: NEG
45386: PUSH
45387: LD_INT 3
45389: PUSH
45390: EMPTY
45391: LIST
45392: LIST
45393: PUSH
45394: LD_INT 2
45396: PUSH
45397: LD_INT 5
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: LD_INT 2
45406: NEG
45407: PUSH
45408: LD_INT 3
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PUSH
45415: LD_INT 3
45417: NEG
45418: PUSH
45419: LD_INT 0
45421: PUSH
45422: EMPTY
45423: LIST
45424: LIST
45425: PUSH
45426: LD_INT 3
45428: NEG
45429: PUSH
45430: LD_INT 1
45432: NEG
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: PUSH
45438: LD_INT 2
45440: NEG
45441: PUSH
45442: LD_INT 0
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 2
45451: NEG
45452: PUSH
45453: LD_INT 1
45455: PUSH
45456: EMPTY
45457: LIST
45458: LIST
45459: PUSH
45460: LD_INT 3
45462: NEG
45463: PUSH
45464: LD_INT 1
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: LD_INT 4
45473: NEG
45474: PUSH
45475: LD_INT 0
45477: PUSH
45478: EMPTY
45479: LIST
45480: LIST
45481: PUSH
45482: LD_INT 4
45484: NEG
45485: PUSH
45486: LD_INT 1
45488: NEG
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: PUSH
45494: LD_INT 4
45496: NEG
45497: PUSH
45498: LD_INT 2
45500: NEG
45501: PUSH
45502: EMPTY
45503: LIST
45504: LIST
45505: PUSH
45506: LD_INT 2
45508: NEG
45509: PUSH
45510: LD_INT 2
45512: PUSH
45513: EMPTY
45514: LIST
45515: LIST
45516: PUSH
45517: LD_INT 4
45519: NEG
45520: PUSH
45521: LD_INT 4
45523: NEG
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: PUSH
45529: LD_INT 4
45531: NEG
45532: PUSH
45533: LD_INT 5
45535: NEG
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: PUSH
45541: LD_INT 3
45543: NEG
45544: PUSH
45545: LD_INT 4
45547: NEG
45548: PUSH
45549: EMPTY
45550: LIST
45551: LIST
45552: PUSH
45553: LD_INT 3
45555: NEG
45556: PUSH
45557: LD_INT 3
45559: NEG
45560: PUSH
45561: EMPTY
45562: LIST
45563: LIST
45564: PUSH
45565: LD_INT 4
45567: NEG
45568: PUSH
45569: LD_INT 3
45571: NEG
45572: PUSH
45573: EMPTY
45574: LIST
45575: LIST
45576: PUSH
45577: LD_INT 5
45579: NEG
45580: PUSH
45581: LD_INT 4
45583: NEG
45584: PUSH
45585: EMPTY
45586: LIST
45587: LIST
45588: PUSH
45589: LD_INT 5
45591: NEG
45592: PUSH
45593: LD_INT 5
45595: NEG
45596: PUSH
45597: EMPTY
45598: LIST
45599: LIST
45600: PUSH
45601: LD_INT 3
45603: NEG
45604: PUSH
45605: LD_INT 5
45607: NEG
45608: PUSH
45609: EMPTY
45610: LIST
45611: LIST
45612: PUSH
45613: LD_INT 5
45615: NEG
45616: PUSH
45617: LD_INT 3
45619: NEG
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: LIST
45649: LIST
45650: LIST
45651: LIST
45652: LIST
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: LIST
45659: LIST
45660: LIST
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
45672: LD_ADDR_VAR 0 30
45676: PUSH
45677: LD_INT 4
45679: PUSH
45680: LD_INT 4
45682: PUSH
45683: EMPTY
45684: LIST
45685: LIST
45686: PUSH
45687: LD_INT 4
45689: PUSH
45690: LD_INT 3
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PUSH
45697: LD_INT 5
45699: PUSH
45700: LD_INT 4
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 5
45709: PUSH
45710: LD_INT 5
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: LD_INT 4
45719: PUSH
45720: LD_INT 5
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 3
45729: PUSH
45730: LD_INT 4
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 3
45739: PUSH
45740: LD_INT 3
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: LD_INT 5
45749: PUSH
45750: LD_INT 3
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 3
45759: PUSH
45760: LD_INT 5
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 0
45769: PUSH
45770: LD_INT 3
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 0
45779: PUSH
45780: LD_INT 2
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 1
45789: PUSH
45790: LD_INT 3
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 1
45799: PUSH
45800: LD_INT 4
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 0
45809: PUSH
45810: LD_INT 4
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 1
45819: NEG
45820: PUSH
45821: LD_INT 3
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 1
45830: NEG
45831: PUSH
45832: LD_INT 2
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 2
45841: PUSH
45842: LD_INT 4
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 2
45851: NEG
45852: PUSH
45853: LD_INT 2
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PUSH
45860: LD_INT 4
45862: NEG
45863: PUSH
45864: LD_INT 0
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 4
45873: NEG
45874: PUSH
45875: LD_INT 1
45877: NEG
45878: PUSH
45879: EMPTY
45880: LIST
45881: LIST
45882: PUSH
45883: LD_INT 3
45885: NEG
45886: PUSH
45887: LD_INT 0
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 3
45896: NEG
45897: PUSH
45898: LD_INT 1
45900: PUSH
45901: EMPTY
45902: LIST
45903: LIST
45904: PUSH
45905: LD_INT 4
45907: NEG
45908: PUSH
45909: LD_INT 1
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 5
45918: NEG
45919: PUSH
45920: LD_INT 0
45922: PUSH
45923: EMPTY
45924: LIST
45925: LIST
45926: PUSH
45927: LD_INT 5
45929: NEG
45930: PUSH
45931: LD_INT 1
45933: NEG
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 5
45941: NEG
45942: PUSH
45943: LD_INT 2
45945: NEG
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 3
45953: NEG
45954: PUSH
45955: LD_INT 2
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: LD_INT 3
45964: NEG
45965: PUSH
45966: LD_INT 3
45968: NEG
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: LD_INT 3
45976: NEG
45977: PUSH
45978: LD_INT 4
45980: NEG
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 2
45988: NEG
45989: PUSH
45990: LD_INT 3
45992: NEG
45993: PUSH
45994: EMPTY
45995: LIST
45996: LIST
45997: PUSH
45998: LD_INT 2
46000: NEG
46001: PUSH
46002: LD_INT 2
46004: NEG
46005: PUSH
46006: EMPTY
46007: LIST
46008: LIST
46009: PUSH
46010: LD_INT 3
46012: NEG
46013: PUSH
46014: LD_INT 2
46016: NEG
46017: PUSH
46018: EMPTY
46019: LIST
46020: LIST
46021: PUSH
46022: LD_INT 4
46024: NEG
46025: PUSH
46026: LD_INT 3
46028: NEG
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: PUSH
46034: LD_INT 4
46036: NEG
46037: PUSH
46038: LD_INT 4
46040: NEG
46041: PUSH
46042: EMPTY
46043: LIST
46044: LIST
46045: PUSH
46046: LD_INT 2
46048: NEG
46049: PUSH
46050: LD_INT 4
46052: NEG
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: PUSH
46058: LD_INT 4
46060: NEG
46061: PUSH
46062: LD_INT 2
46064: NEG
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 0
46072: PUSH
46073: LD_INT 4
46075: NEG
46076: PUSH
46077: EMPTY
46078: LIST
46079: LIST
46080: PUSH
46081: LD_INT 0
46083: PUSH
46084: LD_INT 5
46086: NEG
46087: PUSH
46088: EMPTY
46089: LIST
46090: LIST
46091: PUSH
46092: LD_INT 1
46094: PUSH
46095: LD_INT 4
46097: NEG
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: PUSH
46103: LD_INT 1
46105: PUSH
46106: LD_INT 3
46108: NEG
46109: PUSH
46110: EMPTY
46111: LIST
46112: LIST
46113: PUSH
46114: LD_INT 0
46116: PUSH
46117: LD_INT 3
46119: NEG
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 1
46127: NEG
46128: PUSH
46129: LD_INT 4
46131: NEG
46132: PUSH
46133: EMPTY
46134: LIST
46135: LIST
46136: PUSH
46137: LD_INT 1
46139: NEG
46140: PUSH
46141: LD_INT 5
46143: NEG
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: PUSH
46149: LD_INT 2
46151: PUSH
46152: LD_INT 3
46154: NEG
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: PUSH
46160: LD_INT 2
46162: NEG
46163: PUSH
46164: LD_INT 5
46166: NEG
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: LIST
46187: LIST
46188: LIST
46189: LIST
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: LIST
46202: LIST
46203: LIST
46204: LIST
46205: LIST
46206: LIST
46207: LIST
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
46219: LD_ADDR_VAR 0 31
46223: PUSH
46224: LD_INT 0
46226: PUSH
46227: LD_INT 4
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PUSH
46234: LD_INT 0
46236: PUSH
46237: LD_INT 3
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: PUSH
46244: LD_INT 1
46246: PUSH
46247: LD_INT 4
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 1
46256: PUSH
46257: LD_INT 5
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 0
46266: PUSH
46267: LD_INT 5
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 1
46276: NEG
46277: PUSH
46278: LD_INT 4
46280: PUSH
46281: EMPTY
46282: LIST
46283: LIST
46284: PUSH
46285: LD_INT 1
46287: NEG
46288: PUSH
46289: LD_INT 3
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: PUSH
46296: LD_INT 2
46298: PUSH
46299: LD_INT 5
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: PUSH
46306: LD_INT 2
46308: NEG
46309: PUSH
46310: LD_INT 3
46312: PUSH
46313: EMPTY
46314: LIST
46315: LIST
46316: PUSH
46317: LD_INT 3
46319: NEG
46320: PUSH
46321: LD_INT 0
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 3
46330: NEG
46331: PUSH
46332: LD_INT 1
46334: NEG
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 2
46342: NEG
46343: PUSH
46344: LD_INT 0
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 2
46353: NEG
46354: PUSH
46355: LD_INT 1
46357: PUSH
46358: EMPTY
46359: LIST
46360: LIST
46361: PUSH
46362: LD_INT 3
46364: NEG
46365: PUSH
46366: LD_INT 1
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 4
46375: NEG
46376: PUSH
46377: LD_INT 0
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: LD_INT 4
46386: NEG
46387: PUSH
46388: LD_INT 1
46390: NEG
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: PUSH
46396: LD_INT 4
46398: NEG
46399: PUSH
46400: LD_INT 2
46402: NEG
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 2
46410: NEG
46411: PUSH
46412: LD_INT 2
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 4
46421: NEG
46422: PUSH
46423: LD_INT 4
46425: NEG
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 4
46433: NEG
46434: PUSH
46435: LD_INT 5
46437: NEG
46438: PUSH
46439: EMPTY
46440: LIST
46441: LIST
46442: PUSH
46443: LD_INT 3
46445: NEG
46446: PUSH
46447: LD_INT 4
46449: NEG
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: PUSH
46455: LD_INT 3
46457: NEG
46458: PUSH
46459: LD_INT 3
46461: NEG
46462: PUSH
46463: EMPTY
46464: LIST
46465: LIST
46466: PUSH
46467: LD_INT 4
46469: NEG
46470: PUSH
46471: LD_INT 3
46473: NEG
46474: PUSH
46475: EMPTY
46476: LIST
46477: LIST
46478: PUSH
46479: LD_INT 5
46481: NEG
46482: PUSH
46483: LD_INT 4
46485: NEG
46486: PUSH
46487: EMPTY
46488: LIST
46489: LIST
46490: PUSH
46491: LD_INT 5
46493: NEG
46494: PUSH
46495: LD_INT 5
46497: NEG
46498: PUSH
46499: EMPTY
46500: LIST
46501: LIST
46502: PUSH
46503: LD_INT 3
46505: NEG
46506: PUSH
46507: LD_INT 5
46509: NEG
46510: PUSH
46511: EMPTY
46512: LIST
46513: LIST
46514: PUSH
46515: LD_INT 5
46517: NEG
46518: PUSH
46519: LD_INT 3
46521: NEG
46522: PUSH
46523: EMPTY
46524: LIST
46525: LIST
46526: PUSH
46527: LD_INT 0
46529: PUSH
46530: LD_INT 3
46532: NEG
46533: PUSH
46534: EMPTY
46535: LIST
46536: LIST
46537: PUSH
46538: LD_INT 0
46540: PUSH
46541: LD_INT 4
46543: NEG
46544: PUSH
46545: EMPTY
46546: LIST
46547: LIST
46548: PUSH
46549: LD_INT 1
46551: PUSH
46552: LD_INT 3
46554: NEG
46555: PUSH
46556: EMPTY
46557: LIST
46558: LIST
46559: PUSH
46560: LD_INT 1
46562: PUSH
46563: LD_INT 2
46565: NEG
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: PUSH
46571: LD_INT 0
46573: PUSH
46574: LD_INT 2
46576: NEG
46577: PUSH
46578: EMPTY
46579: LIST
46580: LIST
46581: PUSH
46582: LD_INT 1
46584: NEG
46585: PUSH
46586: LD_INT 3
46588: NEG
46589: PUSH
46590: EMPTY
46591: LIST
46592: LIST
46593: PUSH
46594: LD_INT 1
46596: NEG
46597: PUSH
46598: LD_INT 4
46600: NEG
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: PUSH
46606: LD_INT 2
46608: PUSH
46609: LD_INT 2
46611: NEG
46612: PUSH
46613: EMPTY
46614: LIST
46615: LIST
46616: PUSH
46617: LD_INT 2
46619: NEG
46620: PUSH
46621: LD_INT 4
46623: NEG
46624: PUSH
46625: EMPTY
46626: LIST
46627: LIST
46628: PUSH
46629: LD_INT 4
46631: PUSH
46632: LD_INT 0
46634: PUSH
46635: EMPTY
46636: LIST
46637: LIST
46638: PUSH
46639: LD_INT 4
46641: PUSH
46642: LD_INT 1
46644: NEG
46645: PUSH
46646: EMPTY
46647: LIST
46648: LIST
46649: PUSH
46650: LD_INT 5
46652: PUSH
46653: LD_INT 0
46655: PUSH
46656: EMPTY
46657: LIST
46658: LIST
46659: PUSH
46660: LD_INT 5
46662: PUSH
46663: LD_INT 1
46665: PUSH
46666: EMPTY
46667: LIST
46668: LIST
46669: PUSH
46670: LD_INT 4
46672: PUSH
46673: LD_INT 1
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: PUSH
46680: LD_INT 3
46682: PUSH
46683: LD_INT 0
46685: PUSH
46686: EMPTY
46687: LIST
46688: LIST
46689: PUSH
46690: LD_INT 3
46692: PUSH
46693: LD_INT 1
46695: NEG
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: LD_INT 3
46703: PUSH
46704: LD_INT 2
46706: NEG
46707: PUSH
46708: EMPTY
46709: LIST
46710: LIST
46711: PUSH
46712: LD_INT 5
46714: PUSH
46715: LD_INT 2
46717: PUSH
46718: EMPTY
46719: LIST
46720: LIST
46721: PUSH
46722: EMPTY
46723: LIST
46724: LIST
46725: LIST
46726: LIST
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: LIST
46768: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
46769: LD_ADDR_VAR 0 32
46773: PUSH
46774: LD_INT 4
46776: NEG
46777: PUSH
46778: LD_INT 0
46780: PUSH
46781: EMPTY
46782: LIST
46783: LIST
46784: PUSH
46785: LD_INT 4
46787: NEG
46788: PUSH
46789: LD_INT 1
46791: NEG
46792: PUSH
46793: EMPTY
46794: LIST
46795: LIST
46796: PUSH
46797: LD_INT 3
46799: NEG
46800: PUSH
46801: LD_INT 0
46803: PUSH
46804: EMPTY
46805: LIST
46806: LIST
46807: PUSH
46808: LD_INT 3
46810: NEG
46811: PUSH
46812: LD_INT 1
46814: PUSH
46815: EMPTY
46816: LIST
46817: LIST
46818: PUSH
46819: LD_INT 4
46821: NEG
46822: PUSH
46823: LD_INT 1
46825: PUSH
46826: EMPTY
46827: LIST
46828: LIST
46829: PUSH
46830: LD_INT 5
46832: NEG
46833: PUSH
46834: LD_INT 0
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: PUSH
46841: LD_INT 5
46843: NEG
46844: PUSH
46845: LD_INT 1
46847: NEG
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PUSH
46853: LD_INT 5
46855: NEG
46856: PUSH
46857: LD_INT 2
46859: NEG
46860: PUSH
46861: EMPTY
46862: LIST
46863: LIST
46864: PUSH
46865: LD_INT 3
46867: NEG
46868: PUSH
46869: LD_INT 2
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: PUSH
46876: LD_INT 3
46878: NEG
46879: PUSH
46880: LD_INT 3
46882: NEG
46883: PUSH
46884: EMPTY
46885: LIST
46886: LIST
46887: PUSH
46888: LD_INT 3
46890: NEG
46891: PUSH
46892: LD_INT 4
46894: NEG
46895: PUSH
46896: EMPTY
46897: LIST
46898: LIST
46899: PUSH
46900: LD_INT 2
46902: NEG
46903: PUSH
46904: LD_INT 3
46906: NEG
46907: PUSH
46908: EMPTY
46909: LIST
46910: LIST
46911: PUSH
46912: LD_INT 2
46914: NEG
46915: PUSH
46916: LD_INT 2
46918: NEG
46919: PUSH
46920: EMPTY
46921: LIST
46922: LIST
46923: PUSH
46924: LD_INT 3
46926: NEG
46927: PUSH
46928: LD_INT 2
46930: NEG
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: PUSH
46936: LD_INT 4
46938: NEG
46939: PUSH
46940: LD_INT 3
46942: NEG
46943: PUSH
46944: EMPTY
46945: LIST
46946: LIST
46947: PUSH
46948: LD_INT 4
46950: NEG
46951: PUSH
46952: LD_INT 4
46954: NEG
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: PUSH
46960: LD_INT 2
46962: NEG
46963: PUSH
46964: LD_INT 4
46966: NEG
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: PUSH
46972: LD_INT 4
46974: NEG
46975: PUSH
46976: LD_INT 2
46978: NEG
46979: PUSH
46980: EMPTY
46981: LIST
46982: LIST
46983: PUSH
46984: LD_INT 0
46986: PUSH
46987: LD_INT 4
46989: NEG
46990: PUSH
46991: EMPTY
46992: LIST
46993: LIST
46994: PUSH
46995: LD_INT 0
46997: PUSH
46998: LD_INT 5
47000: NEG
47001: PUSH
47002: EMPTY
47003: LIST
47004: LIST
47005: PUSH
47006: LD_INT 1
47008: PUSH
47009: LD_INT 4
47011: NEG
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: PUSH
47017: LD_INT 1
47019: PUSH
47020: LD_INT 3
47022: NEG
47023: PUSH
47024: EMPTY
47025: LIST
47026: LIST
47027: PUSH
47028: LD_INT 0
47030: PUSH
47031: LD_INT 3
47033: NEG
47034: PUSH
47035: EMPTY
47036: LIST
47037: LIST
47038: PUSH
47039: LD_INT 1
47041: NEG
47042: PUSH
47043: LD_INT 4
47045: NEG
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 1
47053: NEG
47054: PUSH
47055: LD_INT 5
47057: NEG
47058: PUSH
47059: EMPTY
47060: LIST
47061: LIST
47062: PUSH
47063: LD_INT 2
47065: PUSH
47066: LD_INT 3
47068: NEG
47069: PUSH
47070: EMPTY
47071: LIST
47072: LIST
47073: PUSH
47074: LD_INT 2
47076: NEG
47077: PUSH
47078: LD_INT 5
47080: NEG
47081: PUSH
47082: EMPTY
47083: LIST
47084: LIST
47085: PUSH
47086: LD_INT 3
47088: PUSH
47089: LD_INT 0
47091: PUSH
47092: EMPTY
47093: LIST
47094: LIST
47095: PUSH
47096: LD_INT 3
47098: PUSH
47099: LD_INT 1
47101: NEG
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: PUSH
47107: LD_INT 4
47109: PUSH
47110: LD_INT 0
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: PUSH
47117: LD_INT 4
47119: PUSH
47120: LD_INT 1
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: PUSH
47127: LD_INT 3
47129: PUSH
47130: LD_INT 1
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PUSH
47137: LD_INT 2
47139: PUSH
47140: LD_INT 0
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: PUSH
47147: LD_INT 2
47149: PUSH
47150: LD_INT 1
47152: NEG
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: PUSH
47158: LD_INT 2
47160: PUSH
47161: LD_INT 2
47163: NEG
47164: PUSH
47165: EMPTY
47166: LIST
47167: LIST
47168: PUSH
47169: LD_INT 4
47171: PUSH
47172: LD_INT 2
47174: PUSH
47175: EMPTY
47176: LIST
47177: LIST
47178: PUSH
47179: LD_INT 4
47181: PUSH
47182: LD_INT 4
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: PUSH
47189: LD_INT 4
47191: PUSH
47192: LD_INT 3
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: PUSH
47199: LD_INT 5
47201: PUSH
47202: LD_INT 4
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: LD_INT 5
47211: PUSH
47212: LD_INT 5
47214: PUSH
47215: EMPTY
47216: LIST
47217: LIST
47218: PUSH
47219: LD_INT 4
47221: PUSH
47222: LD_INT 5
47224: PUSH
47225: EMPTY
47226: LIST
47227: LIST
47228: PUSH
47229: LD_INT 3
47231: PUSH
47232: LD_INT 4
47234: PUSH
47235: EMPTY
47236: LIST
47237: LIST
47238: PUSH
47239: LD_INT 3
47241: PUSH
47242: LD_INT 3
47244: PUSH
47245: EMPTY
47246: LIST
47247: LIST
47248: PUSH
47249: LD_INT 5
47251: PUSH
47252: LD_INT 3
47254: PUSH
47255: EMPTY
47256: LIST
47257: LIST
47258: PUSH
47259: LD_INT 3
47261: PUSH
47262: LD_INT 5
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PUSH
47269: EMPTY
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: LIST
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: LIST
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: LIST
47295: LIST
47296: LIST
47297: LIST
47298: LIST
47299: LIST
47300: LIST
47301: LIST
47302: LIST
47303: LIST
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: LIST
47309: LIST
47310: LIST
47311: LIST
47312: LIST
47313: LIST
47314: LIST
47315: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
47316: LD_ADDR_VAR 0 33
47320: PUSH
47321: LD_INT 4
47323: NEG
47324: PUSH
47325: LD_INT 4
47327: NEG
47328: PUSH
47329: EMPTY
47330: LIST
47331: LIST
47332: PUSH
47333: LD_INT 4
47335: NEG
47336: PUSH
47337: LD_INT 5
47339: NEG
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: PUSH
47345: LD_INT 3
47347: NEG
47348: PUSH
47349: LD_INT 4
47351: NEG
47352: PUSH
47353: EMPTY
47354: LIST
47355: LIST
47356: PUSH
47357: LD_INT 3
47359: NEG
47360: PUSH
47361: LD_INT 3
47363: NEG
47364: PUSH
47365: EMPTY
47366: LIST
47367: LIST
47368: PUSH
47369: LD_INT 4
47371: NEG
47372: PUSH
47373: LD_INT 3
47375: NEG
47376: PUSH
47377: EMPTY
47378: LIST
47379: LIST
47380: PUSH
47381: LD_INT 5
47383: NEG
47384: PUSH
47385: LD_INT 4
47387: NEG
47388: PUSH
47389: EMPTY
47390: LIST
47391: LIST
47392: PUSH
47393: LD_INT 5
47395: NEG
47396: PUSH
47397: LD_INT 5
47399: NEG
47400: PUSH
47401: EMPTY
47402: LIST
47403: LIST
47404: PUSH
47405: LD_INT 3
47407: NEG
47408: PUSH
47409: LD_INT 5
47411: NEG
47412: PUSH
47413: EMPTY
47414: LIST
47415: LIST
47416: PUSH
47417: LD_INT 5
47419: NEG
47420: PUSH
47421: LD_INT 3
47423: NEG
47424: PUSH
47425: EMPTY
47426: LIST
47427: LIST
47428: PUSH
47429: LD_INT 0
47431: PUSH
47432: LD_INT 3
47434: NEG
47435: PUSH
47436: EMPTY
47437: LIST
47438: LIST
47439: PUSH
47440: LD_INT 0
47442: PUSH
47443: LD_INT 4
47445: NEG
47446: PUSH
47447: EMPTY
47448: LIST
47449: LIST
47450: PUSH
47451: LD_INT 1
47453: PUSH
47454: LD_INT 3
47456: NEG
47457: PUSH
47458: EMPTY
47459: LIST
47460: LIST
47461: PUSH
47462: LD_INT 1
47464: PUSH
47465: LD_INT 2
47467: NEG
47468: PUSH
47469: EMPTY
47470: LIST
47471: LIST
47472: PUSH
47473: LD_INT 0
47475: PUSH
47476: LD_INT 2
47478: NEG
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: PUSH
47484: LD_INT 1
47486: NEG
47487: PUSH
47488: LD_INT 3
47490: NEG
47491: PUSH
47492: EMPTY
47493: LIST
47494: LIST
47495: PUSH
47496: LD_INT 1
47498: NEG
47499: PUSH
47500: LD_INT 4
47502: NEG
47503: PUSH
47504: EMPTY
47505: LIST
47506: LIST
47507: PUSH
47508: LD_INT 2
47510: PUSH
47511: LD_INT 2
47513: NEG
47514: PUSH
47515: EMPTY
47516: LIST
47517: LIST
47518: PUSH
47519: LD_INT 2
47521: NEG
47522: PUSH
47523: LD_INT 4
47525: NEG
47526: PUSH
47527: EMPTY
47528: LIST
47529: LIST
47530: PUSH
47531: LD_INT 4
47533: PUSH
47534: LD_INT 0
47536: PUSH
47537: EMPTY
47538: LIST
47539: LIST
47540: PUSH
47541: LD_INT 4
47543: PUSH
47544: LD_INT 1
47546: NEG
47547: PUSH
47548: EMPTY
47549: LIST
47550: LIST
47551: PUSH
47552: LD_INT 5
47554: PUSH
47555: LD_INT 0
47557: PUSH
47558: EMPTY
47559: LIST
47560: LIST
47561: PUSH
47562: LD_INT 5
47564: PUSH
47565: LD_INT 1
47567: PUSH
47568: EMPTY
47569: LIST
47570: LIST
47571: PUSH
47572: LD_INT 4
47574: PUSH
47575: LD_INT 1
47577: PUSH
47578: EMPTY
47579: LIST
47580: LIST
47581: PUSH
47582: LD_INT 3
47584: PUSH
47585: LD_INT 0
47587: PUSH
47588: EMPTY
47589: LIST
47590: LIST
47591: PUSH
47592: LD_INT 3
47594: PUSH
47595: LD_INT 1
47597: NEG
47598: PUSH
47599: EMPTY
47600: LIST
47601: LIST
47602: PUSH
47603: LD_INT 3
47605: PUSH
47606: LD_INT 2
47608: NEG
47609: PUSH
47610: EMPTY
47611: LIST
47612: LIST
47613: PUSH
47614: LD_INT 5
47616: PUSH
47617: LD_INT 2
47619: PUSH
47620: EMPTY
47621: LIST
47622: LIST
47623: PUSH
47624: LD_INT 3
47626: PUSH
47627: LD_INT 3
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PUSH
47634: LD_INT 3
47636: PUSH
47637: LD_INT 2
47639: PUSH
47640: EMPTY
47641: LIST
47642: LIST
47643: PUSH
47644: LD_INT 4
47646: PUSH
47647: LD_INT 3
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: PUSH
47654: LD_INT 4
47656: PUSH
47657: LD_INT 4
47659: PUSH
47660: EMPTY
47661: LIST
47662: LIST
47663: PUSH
47664: LD_INT 3
47666: PUSH
47667: LD_INT 4
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: PUSH
47674: LD_INT 2
47676: PUSH
47677: LD_INT 3
47679: PUSH
47680: EMPTY
47681: LIST
47682: LIST
47683: PUSH
47684: LD_INT 2
47686: PUSH
47687: LD_INT 2
47689: PUSH
47690: EMPTY
47691: LIST
47692: LIST
47693: PUSH
47694: LD_INT 4
47696: PUSH
47697: LD_INT 2
47699: PUSH
47700: EMPTY
47701: LIST
47702: LIST
47703: PUSH
47704: LD_INT 2
47706: PUSH
47707: LD_INT 4
47709: PUSH
47710: EMPTY
47711: LIST
47712: LIST
47713: PUSH
47714: LD_INT 0
47716: PUSH
47717: LD_INT 4
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: PUSH
47724: LD_INT 0
47726: PUSH
47727: LD_INT 3
47729: PUSH
47730: EMPTY
47731: LIST
47732: LIST
47733: PUSH
47734: LD_INT 1
47736: PUSH
47737: LD_INT 4
47739: PUSH
47740: EMPTY
47741: LIST
47742: LIST
47743: PUSH
47744: LD_INT 1
47746: PUSH
47747: LD_INT 5
47749: PUSH
47750: EMPTY
47751: LIST
47752: LIST
47753: PUSH
47754: LD_INT 0
47756: PUSH
47757: LD_INT 5
47759: PUSH
47760: EMPTY
47761: LIST
47762: LIST
47763: PUSH
47764: LD_INT 1
47766: NEG
47767: PUSH
47768: LD_INT 4
47770: PUSH
47771: EMPTY
47772: LIST
47773: LIST
47774: PUSH
47775: LD_INT 1
47777: NEG
47778: PUSH
47779: LD_INT 3
47781: PUSH
47782: EMPTY
47783: LIST
47784: LIST
47785: PUSH
47786: LD_INT 2
47788: PUSH
47789: LD_INT 5
47791: PUSH
47792: EMPTY
47793: LIST
47794: LIST
47795: PUSH
47796: LD_INT 2
47798: NEG
47799: PUSH
47800: LD_INT 3
47802: PUSH
47803: EMPTY
47804: LIST
47805: LIST
47806: PUSH
47807: EMPTY
47808: LIST
47809: LIST
47810: LIST
47811: LIST
47812: LIST
47813: LIST
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: LIST
47819: LIST
47820: LIST
47821: LIST
47822: LIST
47823: LIST
47824: LIST
47825: LIST
47826: LIST
47827: LIST
47828: LIST
47829: LIST
47830: LIST
47831: LIST
47832: LIST
47833: LIST
47834: LIST
47835: LIST
47836: LIST
47837: LIST
47838: LIST
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: LIST
47846: LIST
47847: LIST
47848: LIST
47849: LIST
47850: LIST
47851: LIST
47852: LIST
47853: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
47854: LD_ADDR_VAR 0 34
47858: PUSH
47859: LD_INT 0
47861: PUSH
47862: LD_INT 4
47864: NEG
47865: PUSH
47866: EMPTY
47867: LIST
47868: LIST
47869: PUSH
47870: LD_INT 0
47872: PUSH
47873: LD_INT 5
47875: NEG
47876: PUSH
47877: EMPTY
47878: LIST
47879: LIST
47880: PUSH
47881: LD_INT 1
47883: PUSH
47884: LD_INT 4
47886: NEG
47887: PUSH
47888: EMPTY
47889: LIST
47890: LIST
47891: PUSH
47892: LD_INT 1
47894: PUSH
47895: LD_INT 3
47897: NEG
47898: PUSH
47899: EMPTY
47900: LIST
47901: LIST
47902: PUSH
47903: LD_INT 0
47905: PUSH
47906: LD_INT 3
47908: NEG
47909: PUSH
47910: EMPTY
47911: LIST
47912: LIST
47913: PUSH
47914: LD_INT 1
47916: NEG
47917: PUSH
47918: LD_INT 4
47920: NEG
47921: PUSH
47922: EMPTY
47923: LIST
47924: LIST
47925: PUSH
47926: LD_INT 1
47928: NEG
47929: PUSH
47930: LD_INT 5
47932: NEG
47933: PUSH
47934: EMPTY
47935: LIST
47936: LIST
47937: PUSH
47938: LD_INT 2
47940: PUSH
47941: LD_INT 3
47943: NEG
47944: PUSH
47945: EMPTY
47946: LIST
47947: LIST
47948: PUSH
47949: LD_INT 2
47951: NEG
47952: PUSH
47953: LD_INT 5
47955: NEG
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: PUSH
47961: LD_INT 3
47963: PUSH
47964: LD_INT 0
47966: PUSH
47967: EMPTY
47968: LIST
47969: LIST
47970: PUSH
47971: LD_INT 3
47973: PUSH
47974: LD_INT 1
47976: NEG
47977: PUSH
47978: EMPTY
47979: LIST
47980: LIST
47981: PUSH
47982: LD_INT 4
47984: PUSH
47985: LD_INT 0
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: PUSH
47992: LD_INT 4
47994: PUSH
47995: LD_INT 1
47997: PUSH
47998: EMPTY
47999: LIST
48000: LIST
48001: PUSH
48002: LD_INT 3
48004: PUSH
48005: LD_INT 1
48007: PUSH
48008: EMPTY
48009: LIST
48010: LIST
48011: PUSH
48012: LD_INT 2
48014: PUSH
48015: LD_INT 0
48017: PUSH
48018: EMPTY
48019: LIST
48020: LIST
48021: PUSH
48022: LD_INT 2
48024: PUSH
48025: LD_INT 1
48027: NEG
48028: PUSH
48029: EMPTY
48030: LIST
48031: LIST
48032: PUSH
48033: LD_INT 2
48035: PUSH
48036: LD_INT 2
48038: NEG
48039: PUSH
48040: EMPTY
48041: LIST
48042: LIST
48043: PUSH
48044: LD_INT 4
48046: PUSH
48047: LD_INT 2
48049: PUSH
48050: EMPTY
48051: LIST
48052: LIST
48053: PUSH
48054: LD_INT 4
48056: PUSH
48057: LD_INT 4
48059: PUSH
48060: EMPTY
48061: LIST
48062: LIST
48063: PUSH
48064: LD_INT 4
48066: PUSH
48067: LD_INT 3
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: PUSH
48074: LD_INT 5
48076: PUSH
48077: LD_INT 4
48079: PUSH
48080: EMPTY
48081: LIST
48082: LIST
48083: PUSH
48084: LD_INT 5
48086: PUSH
48087: LD_INT 5
48089: PUSH
48090: EMPTY
48091: LIST
48092: LIST
48093: PUSH
48094: LD_INT 4
48096: PUSH
48097: LD_INT 5
48099: PUSH
48100: EMPTY
48101: LIST
48102: LIST
48103: PUSH
48104: LD_INT 3
48106: PUSH
48107: LD_INT 4
48109: PUSH
48110: EMPTY
48111: LIST
48112: LIST
48113: PUSH
48114: LD_INT 3
48116: PUSH
48117: LD_INT 3
48119: PUSH
48120: EMPTY
48121: LIST
48122: LIST
48123: PUSH
48124: LD_INT 5
48126: PUSH
48127: LD_INT 3
48129: PUSH
48130: EMPTY
48131: LIST
48132: LIST
48133: PUSH
48134: LD_INT 3
48136: PUSH
48137: LD_INT 5
48139: PUSH
48140: EMPTY
48141: LIST
48142: LIST
48143: PUSH
48144: LD_INT 0
48146: PUSH
48147: LD_INT 3
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: LD_INT 0
48156: PUSH
48157: LD_INT 2
48159: PUSH
48160: EMPTY
48161: LIST
48162: LIST
48163: PUSH
48164: LD_INT 1
48166: PUSH
48167: LD_INT 3
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: PUSH
48174: LD_INT 1
48176: PUSH
48177: LD_INT 4
48179: PUSH
48180: EMPTY
48181: LIST
48182: LIST
48183: PUSH
48184: LD_INT 0
48186: PUSH
48187: LD_INT 4
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: LD_INT 1
48196: NEG
48197: PUSH
48198: LD_INT 3
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: PUSH
48205: LD_INT 1
48207: NEG
48208: PUSH
48209: LD_INT 2
48211: PUSH
48212: EMPTY
48213: LIST
48214: LIST
48215: PUSH
48216: LD_INT 2
48218: PUSH
48219: LD_INT 4
48221: PUSH
48222: EMPTY
48223: LIST
48224: LIST
48225: PUSH
48226: LD_INT 2
48228: NEG
48229: PUSH
48230: LD_INT 2
48232: PUSH
48233: EMPTY
48234: LIST
48235: LIST
48236: PUSH
48237: LD_INT 4
48239: NEG
48240: PUSH
48241: LD_INT 0
48243: PUSH
48244: EMPTY
48245: LIST
48246: LIST
48247: PUSH
48248: LD_INT 4
48250: NEG
48251: PUSH
48252: LD_INT 1
48254: NEG
48255: PUSH
48256: EMPTY
48257: LIST
48258: LIST
48259: PUSH
48260: LD_INT 3
48262: NEG
48263: PUSH
48264: LD_INT 0
48266: PUSH
48267: EMPTY
48268: LIST
48269: LIST
48270: PUSH
48271: LD_INT 3
48273: NEG
48274: PUSH
48275: LD_INT 1
48277: PUSH
48278: EMPTY
48279: LIST
48280: LIST
48281: PUSH
48282: LD_INT 4
48284: NEG
48285: PUSH
48286: LD_INT 1
48288: PUSH
48289: EMPTY
48290: LIST
48291: LIST
48292: PUSH
48293: LD_INT 5
48295: NEG
48296: PUSH
48297: LD_INT 0
48299: PUSH
48300: EMPTY
48301: LIST
48302: LIST
48303: PUSH
48304: LD_INT 5
48306: NEG
48307: PUSH
48308: LD_INT 1
48310: NEG
48311: PUSH
48312: EMPTY
48313: LIST
48314: LIST
48315: PUSH
48316: LD_INT 5
48318: NEG
48319: PUSH
48320: LD_INT 2
48322: NEG
48323: PUSH
48324: EMPTY
48325: LIST
48326: LIST
48327: PUSH
48328: LD_INT 3
48330: NEG
48331: PUSH
48332: LD_INT 2
48334: PUSH
48335: EMPTY
48336: LIST
48337: LIST
48338: PUSH
48339: EMPTY
48340: LIST
48341: LIST
48342: LIST
48343: LIST
48344: LIST
48345: LIST
48346: LIST
48347: LIST
48348: LIST
48349: LIST
48350: LIST
48351: LIST
48352: LIST
48353: LIST
48354: LIST
48355: LIST
48356: LIST
48357: LIST
48358: LIST
48359: LIST
48360: LIST
48361: LIST
48362: LIST
48363: LIST
48364: LIST
48365: LIST
48366: LIST
48367: LIST
48368: LIST
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: LIST
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: ST_TO_ADDR
// end ; end ;
48386: GO 48389
48388: POP
// case btype of b_depot , b_warehouse :
48389: LD_VAR 0 1
48393: PUSH
48394: LD_INT 0
48396: DOUBLE
48397: EQUAL
48398: IFTRUE 48408
48400: LD_INT 1
48402: DOUBLE
48403: EQUAL
48404: IFTRUE 48408
48406: GO 48609
48408: POP
// case nation of nation_american :
48409: LD_VAR 0 5
48413: PUSH
48414: LD_INT 1
48416: DOUBLE
48417: EQUAL
48418: IFTRUE 48422
48420: GO 48478
48422: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
48423: LD_ADDR_VAR 0 9
48427: PUSH
48428: LD_VAR 0 11
48432: PUSH
48433: LD_VAR 0 12
48437: PUSH
48438: LD_VAR 0 13
48442: PUSH
48443: LD_VAR 0 14
48447: PUSH
48448: LD_VAR 0 15
48452: PUSH
48453: LD_VAR 0 16
48457: PUSH
48458: EMPTY
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: LIST
48464: LIST
48465: PUSH
48466: LD_VAR 0 4
48470: PUSH
48471: LD_INT 1
48473: PLUS
48474: ARRAY
48475: ST_TO_ADDR
48476: GO 48607
48478: LD_INT 2
48480: DOUBLE
48481: EQUAL
48482: IFTRUE 48486
48484: GO 48542
48486: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
48487: LD_ADDR_VAR 0 9
48491: PUSH
48492: LD_VAR 0 17
48496: PUSH
48497: LD_VAR 0 18
48501: PUSH
48502: LD_VAR 0 19
48506: PUSH
48507: LD_VAR 0 20
48511: PUSH
48512: LD_VAR 0 21
48516: PUSH
48517: LD_VAR 0 22
48521: PUSH
48522: EMPTY
48523: LIST
48524: LIST
48525: LIST
48526: LIST
48527: LIST
48528: LIST
48529: PUSH
48530: LD_VAR 0 4
48534: PUSH
48535: LD_INT 1
48537: PLUS
48538: ARRAY
48539: ST_TO_ADDR
48540: GO 48607
48542: LD_INT 3
48544: DOUBLE
48545: EQUAL
48546: IFTRUE 48550
48548: GO 48606
48550: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
48551: LD_ADDR_VAR 0 9
48555: PUSH
48556: LD_VAR 0 23
48560: PUSH
48561: LD_VAR 0 24
48565: PUSH
48566: LD_VAR 0 25
48570: PUSH
48571: LD_VAR 0 26
48575: PUSH
48576: LD_VAR 0 27
48580: PUSH
48581: LD_VAR 0 28
48585: PUSH
48586: EMPTY
48587: LIST
48588: LIST
48589: LIST
48590: LIST
48591: LIST
48592: LIST
48593: PUSH
48594: LD_VAR 0 4
48598: PUSH
48599: LD_INT 1
48601: PLUS
48602: ARRAY
48603: ST_TO_ADDR
48604: GO 48607
48606: POP
48607: GO 49162
48609: LD_INT 2
48611: DOUBLE
48612: EQUAL
48613: IFTRUE 48623
48615: LD_INT 3
48617: DOUBLE
48618: EQUAL
48619: IFTRUE 48623
48621: GO 48679
48623: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
48624: LD_ADDR_VAR 0 9
48628: PUSH
48629: LD_VAR 0 29
48633: PUSH
48634: LD_VAR 0 30
48638: PUSH
48639: LD_VAR 0 31
48643: PUSH
48644: LD_VAR 0 32
48648: PUSH
48649: LD_VAR 0 33
48653: PUSH
48654: LD_VAR 0 34
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: LIST
48663: LIST
48664: LIST
48665: LIST
48666: PUSH
48667: LD_VAR 0 4
48671: PUSH
48672: LD_INT 1
48674: PLUS
48675: ARRAY
48676: ST_TO_ADDR
48677: GO 49162
48679: LD_INT 16
48681: DOUBLE
48682: EQUAL
48683: IFTRUE 48741
48685: LD_INT 17
48687: DOUBLE
48688: EQUAL
48689: IFTRUE 48741
48691: LD_INT 18
48693: DOUBLE
48694: EQUAL
48695: IFTRUE 48741
48697: LD_INT 19
48699: DOUBLE
48700: EQUAL
48701: IFTRUE 48741
48703: LD_INT 22
48705: DOUBLE
48706: EQUAL
48707: IFTRUE 48741
48709: LD_INT 20
48711: DOUBLE
48712: EQUAL
48713: IFTRUE 48741
48715: LD_INT 21
48717: DOUBLE
48718: EQUAL
48719: IFTRUE 48741
48721: LD_INT 23
48723: DOUBLE
48724: EQUAL
48725: IFTRUE 48741
48727: LD_INT 24
48729: DOUBLE
48730: EQUAL
48731: IFTRUE 48741
48733: LD_INT 25
48735: DOUBLE
48736: EQUAL
48737: IFTRUE 48741
48739: GO 48797
48741: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
48742: LD_ADDR_VAR 0 9
48746: PUSH
48747: LD_VAR 0 35
48751: PUSH
48752: LD_VAR 0 36
48756: PUSH
48757: LD_VAR 0 37
48761: PUSH
48762: LD_VAR 0 38
48766: PUSH
48767: LD_VAR 0 39
48771: PUSH
48772: LD_VAR 0 40
48776: PUSH
48777: EMPTY
48778: LIST
48779: LIST
48780: LIST
48781: LIST
48782: LIST
48783: LIST
48784: PUSH
48785: LD_VAR 0 4
48789: PUSH
48790: LD_INT 1
48792: PLUS
48793: ARRAY
48794: ST_TO_ADDR
48795: GO 49162
48797: LD_INT 6
48799: DOUBLE
48800: EQUAL
48801: IFTRUE 48853
48803: LD_INT 7
48805: DOUBLE
48806: EQUAL
48807: IFTRUE 48853
48809: LD_INT 8
48811: DOUBLE
48812: EQUAL
48813: IFTRUE 48853
48815: LD_INT 13
48817: DOUBLE
48818: EQUAL
48819: IFTRUE 48853
48821: LD_INT 12
48823: DOUBLE
48824: EQUAL
48825: IFTRUE 48853
48827: LD_INT 15
48829: DOUBLE
48830: EQUAL
48831: IFTRUE 48853
48833: LD_INT 11
48835: DOUBLE
48836: EQUAL
48837: IFTRUE 48853
48839: LD_INT 14
48841: DOUBLE
48842: EQUAL
48843: IFTRUE 48853
48845: LD_INT 10
48847: DOUBLE
48848: EQUAL
48849: IFTRUE 48853
48851: GO 48909
48853: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
48854: LD_ADDR_VAR 0 9
48858: PUSH
48859: LD_VAR 0 41
48863: PUSH
48864: LD_VAR 0 42
48868: PUSH
48869: LD_VAR 0 43
48873: PUSH
48874: LD_VAR 0 44
48878: PUSH
48879: LD_VAR 0 45
48883: PUSH
48884: LD_VAR 0 46
48888: PUSH
48889: EMPTY
48890: LIST
48891: LIST
48892: LIST
48893: LIST
48894: LIST
48895: LIST
48896: PUSH
48897: LD_VAR 0 4
48901: PUSH
48902: LD_INT 1
48904: PLUS
48905: ARRAY
48906: ST_TO_ADDR
48907: GO 49162
48909: LD_INT 36
48911: DOUBLE
48912: EQUAL
48913: IFTRUE 48917
48915: GO 48973
48917: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
48918: LD_ADDR_VAR 0 9
48922: PUSH
48923: LD_VAR 0 47
48927: PUSH
48928: LD_VAR 0 48
48932: PUSH
48933: LD_VAR 0 49
48937: PUSH
48938: LD_VAR 0 50
48942: PUSH
48943: LD_VAR 0 51
48947: PUSH
48948: LD_VAR 0 52
48952: PUSH
48953: EMPTY
48954: LIST
48955: LIST
48956: LIST
48957: LIST
48958: LIST
48959: LIST
48960: PUSH
48961: LD_VAR 0 4
48965: PUSH
48966: LD_INT 1
48968: PLUS
48969: ARRAY
48970: ST_TO_ADDR
48971: GO 49162
48973: LD_INT 4
48975: DOUBLE
48976: EQUAL
48977: IFTRUE 48999
48979: LD_INT 5
48981: DOUBLE
48982: EQUAL
48983: IFTRUE 48999
48985: LD_INT 34
48987: DOUBLE
48988: EQUAL
48989: IFTRUE 48999
48991: LD_INT 37
48993: DOUBLE
48994: EQUAL
48995: IFTRUE 48999
48997: GO 49055
48999: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49000: LD_ADDR_VAR 0 9
49004: PUSH
49005: LD_VAR 0 53
49009: PUSH
49010: LD_VAR 0 54
49014: PUSH
49015: LD_VAR 0 55
49019: PUSH
49020: LD_VAR 0 56
49024: PUSH
49025: LD_VAR 0 57
49029: PUSH
49030: LD_VAR 0 58
49034: PUSH
49035: EMPTY
49036: LIST
49037: LIST
49038: LIST
49039: LIST
49040: LIST
49041: LIST
49042: PUSH
49043: LD_VAR 0 4
49047: PUSH
49048: LD_INT 1
49050: PLUS
49051: ARRAY
49052: ST_TO_ADDR
49053: GO 49162
49055: LD_INT 31
49057: DOUBLE
49058: EQUAL
49059: IFTRUE 49105
49061: LD_INT 32
49063: DOUBLE
49064: EQUAL
49065: IFTRUE 49105
49067: LD_INT 33
49069: DOUBLE
49070: EQUAL
49071: IFTRUE 49105
49073: LD_INT 27
49075: DOUBLE
49076: EQUAL
49077: IFTRUE 49105
49079: LD_INT 26
49081: DOUBLE
49082: EQUAL
49083: IFTRUE 49105
49085: LD_INT 28
49087: DOUBLE
49088: EQUAL
49089: IFTRUE 49105
49091: LD_INT 29
49093: DOUBLE
49094: EQUAL
49095: IFTRUE 49105
49097: LD_INT 30
49099: DOUBLE
49100: EQUAL
49101: IFTRUE 49105
49103: GO 49161
49105: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
49106: LD_ADDR_VAR 0 9
49110: PUSH
49111: LD_VAR 0 59
49115: PUSH
49116: LD_VAR 0 60
49120: PUSH
49121: LD_VAR 0 61
49125: PUSH
49126: LD_VAR 0 62
49130: PUSH
49131: LD_VAR 0 63
49135: PUSH
49136: LD_VAR 0 64
49140: PUSH
49141: EMPTY
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: PUSH
49149: LD_VAR 0 4
49153: PUSH
49154: LD_INT 1
49156: PLUS
49157: ARRAY
49158: ST_TO_ADDR
49159: GO 49162
49161: POP
// temp_list2 = [ ] ;
49162: LD_ADDR_VAR 0 10
49166: PUSH
49167: EMPTY
49168: ST_TO_ADDR
// for i in temp_list do
49169: LD_ADDR_VAR 0 8
49173: PUSH
49174: LD_VAR 0 9
49178: PUSH
49179: FOR_IN
49180: IFFALSE 49232
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
49182: LD_ADDR_VAR 0 10
49186: PUSH
49187: LD_VAR 0 10
49191: PUSH
49192: LD_VAR 0 8
49196: PUSH
49197: LD_INT 1
49199: ARRAY
49200: PUSH
49201: LD_VAR 0 2
49205: PLUS
49206: PUSH
49207: LD_VAR 0 8
49211: PUSH
49212: LD_INT 2
49214: ARRAY
49215: PUSH
49216: LD_VAR 0 3
49220: PLUS
49221: PUSH
49222: EMPTY
49223: LIST
49224: LIST
49225: PUSH
49226: EMPTY
49227: LIST
49228: ADD
49229: ST_TO_ADDR
49230: GO 49179
49232: POP
49233: POP
// result = temp_list2 ;
49234: LD_ADDR_VAR 0 7
49238: PUSH
49239: LD_VAR 0 10
49243: ST_TO_ADDR
// end ;
49244: LD_VAR 0 7
49248: RET
// export function EnemyInRange ( unit , dist ) ; begin
49249: LD_INT 0
49251: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
49252: LD_ADDR_VAR 0 3
49256: PUSH
49257: LD_VAR 0 1
49261: PPUSH
49262: CALL_OW 255
49266: PPUSH
49267: LD_VAR 0 1
49271: PPUSH
49272: CALL_OW 250
49276: PPUSH
49277: LD_VAR 0 1
49281: PPUSH
49282: CALL_OW 251
49286: PPUSH
49287: LD_VAR 0 2
49291: PPUSH
49292: CALL 23353 0 4
49296: PUSH
49297: LD_INT 4
49299: ARRAY
49300: ST_TO_ADDR
// end ;
49301: LD_VAR 0 3
49305: RET
// export function PlayerSeeMe ( unit ) ; begin
49306: LD_INT 0
49308: PPUSH
// result := See ( your_side , unit ) ;
49309: LD_ADDR_VAR 0 2
49313: PUSH
49314: LD_OWVAR 2
49318: PPUSH
49319: LD_VAR 0 1
49323: PPUSH
49324: CALL_OW 292
49328: ST_TO_ADDR
// end ;
49329: LD_VAR 0 2
49333: RET
// export function ReverseDir ( unit ) ; begin
49334: LD_INT 0
49336: PPUSH
// if not unit then
49337: LD_VAR 0 1
49341: NOT
49342: IFFALSE 49346
// exit ;
49344: GO 49369
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
49346: LD_ADDR_VAR 0 2
49350: PUSH
49351: LD_VAR 0 1
49355: PPUSH
49356: CALL_OW 254
49360: PUSH
49361: LD_INT 3
49363: PLUS
49364: PUSH
49365: LD_INT 6
49367: MOD
49368: ST_TO_ADDR
// end ;
49369: LD_VAR 0 2
49373: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
49374: LD_INT 0
49376: PPUSH
49377: PPUSH
49378: PPUSH
49379: PPUSH
49380: PPUSH
// if not hexes then
49381: LD_VAR 0 2
49385: NOT
49386: IFFALSE 49390
// exit ;
49388: GO 49538
// dist := 9999 ;
49390: LD_ADDR_VAR 0 5
49394: PUSH
49395: LD_INT 9999
49397: ST_TO_ADDR
// for i = 1 to hexes do
49398: LD_ADDR_VAR 0 4
49402: PUSH
49403: DOUBLE
49404: LD_INT 1
49406: DEC
49407: ST_TO_ADDR
49408: LD_VAR 0 2
49412: PUSH
49413: FOR_TO
49414: IFFALSE 49526
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
49416: LD_VAR 0 1
49420: PPUSH
49421: LD_VAR 0 2
49425: PUSH
49426: LD_VAR 0 4
49430: ARRAY
49431: PUSH
49432: LD_INT 1
49434: ARRAY
49435: PPUSH
49436: LD_VAR 0 2
49440: PUSH
49441: LD_VAR 0 4
49445: ARRAY
49446: PUSH
49447: LD_INT 2
49449: ARRAY
49450: PPUSH
49451: CALL_OW 297
49455: PUSH
49456: LD_VAR 0 5
49460: LESS
49461: IFFALSE 49524
// begin hex := hexes [ i ] ;
49463: LD_ADDR_VAR 0 7
49467: PUSH
49468: LD_VAR 0 2
49472: PUSH
49473: LD_VAR 0 4
49477: ARRAY
49478: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
49479: LD_ADDR_VAR 0 5
49483: PUSH
49484: LD_VAR 0 1
49488: PPUSH
49489: LD_VAR 0 2
49493: PUSH
49494: LD_VAR 0 4
49498: ARRAY
49499: PUSH
49500: LD_INT 1
49502: ARRAY
49503: PPUSH
49504: LD_VAR 0 2
49508: PUSH
49509: LD_VAR 0 4
49513: ARRAY
49514: PUSH
49515: LD_INT 2
49517: ARRAY
49518: PPUSH
49519: CALL_OW 297
49523: ST_TO_ADDR
// end ; end ;
49524: GO 49413
49526: POP
49527: POP
// result := hex ;
49528: LD_ADDR_VAR 0 3
49532: PUSH
49533: LD_VAR 0 7
49537: ST_TO_ADDR
// end ;
49538: LD_VAR 0 3
49542: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
49543: LD_INT 0
49545: PPUSH
49546: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
49547: LD_VAR 0 1
49551: NOT
49552: PUSH
49553: LD_VAR 0 1
49557: PUSH
49558: LD_INT 21
49560: PUSH
49561: LD_INT 2
49563: PUSH
49564: EMPTY
49565: LIST
49566: LIST
49567: PUSH
49568: LD_INT 23
49570: PUSH
49571: LD_INT 2
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: EMPTY
49579: LIST
49580: LIST
49581: PPUSH
49582: CALL_OW 69
49586: IN
49587: NOT
49588: OR
49589: IFFALSE 49593
// exit ;
49591: GO 49640
// for i = 1 to 3 do
49593: LD_ADDR_VAR 0 3
49597: PUSH
49598: DOUBLE
49599: LD_INT 1
49601: DEC
49602: ST_TO_ADDR
49603: LD_INT 3
49605: PUSH
49606: FOR_TO
49607: IFFALSE 49638
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
49609: LD_VAR 0 1
49613: PPUSH
49614: CALL_OW 250
49618: PPUSH
49619: LD_VAR 0 1
49623: PPUSH
49624: CALL_OW 251
49628: PPUSH
49629: LD_INT 1
49631: PPUSH
49632: CALL_OW 453
49636: GO 49606
49638: POP
49639: POP
// end ;
49640: LD_VAR 0 2
49644: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
49645: LD_INT 0
49647: PPUSH
49648: PPUSH
49649: PPUSH
49650: PPUSH
49651: PPUSH
49652: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
49653: LD_VAR 0 1
49657: NOT
49658: PUSH
49659: LD_VAR 0 2
49663: NOT
49664: OR
49665: PUSH
49666: LD_VAR 0 1
49670: PPUSH
49671: CALL_OW 314
49675: OR
49676: IFFALSE 49680
// exit ;
49678: GO 50121
// x := GetX ( enemy_unit ) ;
49680: LD_ADDR_VAR 0 7
49684: PUSH
49685: LD_VAR 0 2
49689: PPUSH
49690: CALL_OW 250
49694: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
49695: LD_ADDR_VAR 0 8
49699: PUSH
49700: LD_VAR 0 2
49704: PPUSH
49705: CALL_OW 251
49709: ST_TO_ADDR
// if not x or not y then
49710: LD_VAR 0 7
49714: NOT
49715: PUSH
49716: LD_VAR 0 8
49720: NOT
49721: OR
49722: IFFALSE 49726
// exit ;
49724: GO 50121
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
49726: LD_ADDR_VAR 0 6
49730: PUSH
49731: LD_VAR 0 7
49735: PPUSH
49736: LD_INT 0
49738: PPUSH
49739: LD_INT 4
49741: PPUSH
49742: CALL_OW 272
49746: PUSH
49747: LD_VAR 0 8
49751: PPUSH
49752: LD_INT 0
49754: PPUSH
49755: LD_INT 4
49757: PPUSH
49758: CALL_OW 273
49762: PUSH
49763: EMPTY
49764: LIST
49765: LIST
49766: PUSH
49767: LD_VAR 0 7
49771: PPUSH
49772: LD_INT 1
49774: PPUSH
49775: LD_INT 4
49777: PPUSH
49778: CALL_OW 272
49782: PUSH
49783: LD_VAR 0 8
49787: PPUSH
49788: LD_INT 1
49790: PPUSH
49791: LD_INT 4
49793: PPUSH
49794: CALL_OW 273
49798: PUSH
49799: EMPTY
49800: LIST
49801: LIST
49802: PUSH
49803: LD_VAR 0 7
49807: PPUSH
49808: LD_INT 2
49810: PPUSH
49811: LD_INT 4
49813: PPUSH
49814: CALL_OW 272
49818: PUSH
49819: LD_VAR 0 8
49823: PPUSH
49824: LD_INT 2
49826: PPUSH
49827: LD_INT 4
49829: PPUSH
49830: CALL_OW 273
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: PUSH
49839: LD_VAR 0 7
49843: PPUSH
49844: LD_INT 3
49846: PPUSH
49847: LD_INT 4
49849: PPUSH
49850: CALL_OW 272
49854: PUSH
49855: LD_VAR 0 8
49859: PPUSH
49860: LD_INT 3
49862: PPUSH
49863: LD_INT 4
49865: PPUSH
49866: CALL_OW 273
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: PUSH
49875: LD_VAR 0 7
49879: PPUSH
49880: LD_INT 4
49882: PPUSH
49883: LD_INT 4
49885: PPUSH
49886: CALL_OW 272
49890: PUSH
49891: LD_VAR 0 8
49895: PPUSH
49896: LD_INT 4
49898: PPUSH
49899: LD_INT 4
49901: PPUSH
49902: CALL_OW 273
49906: PUSH
49907: EMPTY
49908: LIST
49909: LIST
49910: PUSH
49911: LD_VAR 0 7
49915: PPUSH
49916: LD_INT 5
49918: PPUSH
49919: LD_INT 4
49921: PPUSH
49922: CALL_OW 272
49926: PUSH
49927: LD_VAR 0 8
49931: PPUSH
49932: LD_INT 5
49934: PPUSH
49935: LD_INT 4
49937: PPUSH
49938: CALL_OW 273
49942: PUSH
49943: EMPTY
49944: LIST
49945: LIST
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: LIST
49951: LIST
49952: LIST
49953: LIST
49954: ST_TO_ADDR
// for i = tmp downto 1 do
49955: LD_ADDR_VAR 0 4
49959: PUSH
49960: DOUBLE
49961: LD_VAR 0 6
49965: INC
49966: ST_TO_ADDR
49967: LD_INT 1
49969: PUSH
49970: FOR_DOWNTO
49971: IFFALSE 50072
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
49973: LD_VAR 0 6
49977: PUSH
49978: LD_VAR 0 4
49982: ARRAY
49983: PUSH
49984: LD_INT 1
49986: ARRAY
49987: PPUSH
49988: LD_VAR 0 6
49992: PUSH
49993: LD_VAR 0 4
49997: ARRAY
49998: PUSH
49999: LD_INT 2
50001: ARRAY
50002: PPUSH
50003: CALL_OW 488
50007: NOT
50008: PUSH
50009: LD_VAR 0 6
50013: PUSH
50014: LD_VAR 0 4
50018: ARRAY
50019: PUSH
50020: LD_INT 1
50022: ARRAY
50023: PPUSH
50024: LD_VAR 0 6
50028: PUSH
50029: LD_VAR 0 4
50033: ARRAY
50034: PUSH
50035: LD_INT 2
50037: ARRAY
50038: PPUSH
50039: CALL_OW 428
50043: PUSH
50044: LD_INT 0
50046: NONEQUAL
50047: OR
50048: IFFALSE 50070
// tmp := Delete ( tmp , i ) ;
50050: LD_ADDR_VAR 0 6
50054: PUSH
50055: LD_VAR 0 6
50059: PPUSH
50060: LD_VAR 0 4
50064: PPUSH
50065: CALL_OW 3
50069: ST_TO_ADDR
50070: GO 49970
50072: POP
50073: POP
// j := GetClosestHex ( unit , tmp ) ;
50074: LD_ADDR_VAR 0 5
50078: PUSH
50079: LD_VAR 0 1
50083: PPUSH
50084: LD_VAR 0 6
50088: PPUSH
50089: CALL 49374 0 2
50093: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
50094: LD_VAR 0 1
50098: PPUSH
50099: LD_VAR 0 5
50103: PUSH
50104: LD_INT 1
50106: ARRAY
50107: PPUSH
50108: LD_VAR 0 5
50112: PUSH
50113: LD_INT 2
50115: ARRAY
50116: PPUSH
50117: CALL_OW 111
// end ;
50121: LD_VAR 0 3
50125: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
50126: LD_INT 0
50128: PPUSH
50129: PPUSH
50130: PPUSH
// uc_side = 0 ;
50131: LD_ADDR_OWVAR 20
50135: PUSH
50136: LD_INT 0
50138: ST_TO_ADDR
// uc_nation = 0 ;
50139: LD_ADDR_OWVAR 21
50143: PUSH
50144: LD_INT 0
50146: ST_TO_ADDR
// InitHc_All ( ) ;
50147: CALL_OW 584
// InitVc ;
50151: CALL_OW 20
// if mastodonts then
50155: LD_VAR 0 6
50159: IFFALSE 50226
// for i = 1 to mastodonts do
50161: LD_ADDR_VAR 0 11
50165: PUSH
50166: DOUBLE
50167: LD_INT 1
50169: DEC
50170: ST_TO_ADDR
50171: LD_VAR 0 6
50175: PUSH
50176: FOR_TO
50177: IFFALSE 50224
// begin vc_chassis := 31 ;
50179: LD_ADDR_OWVAR 37
50183: PUSH
50184: LD_INT 31
50186: ST_TO_ADDR
// vc_control := control_rider ;
50187: LD_ADDR_OWVAR 38
50191: PUSH
50192: LD_INT 4
50194: ST_TO_ADDR
// animal := CreateVehicle ;
50195: LD_ADDR_VAR 0 12
50199: PUSH
50200: CALL_OW 45
50204: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50205: LD_VAR 0 12
50209: PPUSH
50210: LD_VAR 0 8
50214: PPUSH
50215: LD_INT 0
50217: PPUSH
50218: CALL 52414 0 3
// end ;
50222: GO 50176
50224: POP
50225: POP
// if horses then
50226: LD_VAR 0 5
50230: IFFALSE 50297
// for i = 1 to horses do
50232: LD_ADDR_VAR 0 11
50236: PUSH
50237: DOUBLE
50238: LD_INT 1
50240: DEC
50241: ST_TO_ADDR
50242: LD_VAR 0 5
50246: PUSH
50247: FOR_TO
50248: IFFALSE 50295
// begin hc_class := 21 ;
50250: LD_ADDR_OWVAR 28
50254: PUSH
50255: LD_INT 21
50257: ST_TO_ADDR
// hc_gallery :=  ;
50258: LD_ADDR_OWVAR 33
50262: PUSH
50263: LD_STRING 
50265: ST_TO_ADDR
// animal := CreateHuman ;
50266: LD_ADDR_VAR 0 12
50270: PUSH
50271: CALL_OW 44
50275: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50276: LD_VAR 0 12
50280: PPUSH
50281: LD_VAR 0 8
50285: PPUSH
50286: LD_INT 0
50288: PPUSH
50289: CALL 52414 0 3
// end ;
50293: GO 50247
50295: POP
50296: POP
// if birds then
50297: LD_VAR 0 1
50301: IFFALSE 50368
// for i = 1 to birds do
50303: LD_ADDR_VAR 0 11
50307: PUSH
50308: DOUBLE
50309: LD_INT 1
50311: DEC
50312: ST_TO_ADDR
50313: LD_VAR 0 1
50317: PUSH
50318: FOR_TO
50319: IFFALSE 50366
// begin hc_class = 18 ;
50321: LD_ADDR_OWVAR 28
50325: PUSH
50326: LD_INT 18
50328: ST_TO_ADDR
// hc_gallery =  ;
50329: LD_ADDR_OWVAR 33
50333: PUSH
50334: LD_STRING 
50336: ST_TO_ADDR
// animal := CreateHuman ;
50337: LD_ADDR_VAR 0 12
50341: PUSH
50342: CALL_OW 44
50346: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50347: LD_VAR 0 12
50351: PPUSH
50352: LD_VAR 0 8
50356: PPUSH
50357: LD_INT 0
50359: PPUSH
50360: CALL 52414 0 3
// end ;
50364: GO 50318
50366: POP
50367: POP
// if tigers then
50368: LD_VAR 0 2
50372: IFFALSE 50456
// for i = 1 to tigers do
50374: LD_ADDR_VAR 0 11
50378: PUSH
50379: DOUBLE
50380: LD_INT 1
50382: DEC
50383: ST_TO_ADDR
50384: LD_VAR 0 2
50388: PUSH
50389: FOR_TO
50390: IFFALSE 50454
// begin hc_class = class_tiger ;
50392: LD_ADDR_OWVAR 28
50396: PUSH
50397: LD_INT 14
50399: ST_TO_ADDR
// hc_gallery =  ;
50400: LD_ADDR_OWVAR 33
50404: PUSH
50405: LD_STRING 
50407: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
50408: LD_ADDR_OWVAR 35
50412: PUSH
50413: LD_INT 7
50415: NEG
50416: PPUSH
50417: LD_INT 7
50419: PPUSH
50420: CALL_OW 12
50424: ST_TO_ADDR
// animal := CreateHuman ;
50425: LD_ADDR_VAR 0 12
50429: PUSH
50430: CALL_OW 44
50434: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50435: LD_VAR 0 12
50439: PPUSH
50440: LD_VAR 0 8
50444: PPUSH
50445: LD_INT 0
50447: PPUSH
50448: CALL 52414 0 3
// end ;
50452: GO 50389
50454: POP
50455: POP
// if apemans then
50456: LD_VAR 0 3
50460: IFFALSE 50583
// for i = 1 to apemans do
50462: LD_ADDR_VAR 0 11
50466: PUSH
50467: DOUBLE
50468: LD_INT 1
50470: DEC
50471: ST_TO_ADDR
50472: LD_VAR 0 3
50476: PUSH
50477: FOR_TO
50478: IFFALSE 50581
// begin hc_class = class_apeman ;
50480: LD_ADDR_OWVAR 28
50484: PUSH
50485: LD_INT 12
50487: ST_TO_ADDR
// hc_gallery =  ;
50488: LD_ADDR_OWVAR 33
50492: PUSH
50493: LD_STRING 
50495: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
50496: LD_ADDR_OWVAR 35
50500: PUSH
50501: LD_INT 5
50503: NEG
50504: PPUSH
50505: LD_INT 5
50507: PPUSH
50508: CALL_OW 12
50512: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
50513: LD_ADDR_OWVAR 31
50517: PUSH
50518: LD_INT 1
50520: PPUSH
50521: LD_INT 3
50523: PPUSH
50524: CALL_OW 12
50528: PUSH
50529: LD_INT 1
50531: PPUSH
50532: LD_INT 3
50534: PPUSH
50535: CALL_OW 12
50539: PUSH
50540: LD_INT 0
50542: PUSH
50543: LD_INT 0
50545: PUSH
50546: EMPTY
50547: LIST
50548: LIST
50549: LIST
50550: LIST
50551: ST_TO_ADDR
// animal := CreateHuman ;
50552: LD_ADDR_VAR 0 12
50556: PUSH
50557: CALL_OW 44
50561: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50562: LD_VAR 0 12
50566: PPUSH
50567: LD_VAR 0 8
50571: PPUSH
50572: LD_INT 0
50574: PPUSH
50575: CALL 52414 0 3
// end ;
50579: GO 50477
50581: POP
50582: POP
// if enchidnas then
50583: LD_VAR 0 4
50587: IFFALSE 50654
// for i = 1 to enchidnas do
50589: LD_ADDR_VAR 0 11
50593: PUSH
50594: DOUBLE
50595: LD_INT 1
50597: DEC
50598: ST_TO_ADDR
50599: LD_VAR 0 4
50603: PUSH
50604: FOR_TO
50605: IFFALSE 50652
// begin hc_class = 13 ;
50607: LD_ADDR_OWVAR 28
50611: PUSH
50612: LD_INT 13
50614: ST_TO_ADDR
// hc_gallery =  ;
50615: LD_ADDR_OWVAR 33
50619: PUSH
50620: LD_STRING 
50622: ST_TO_ADDR
// animal := CreateHuman ;
50623: LD_ADDR_VAR 0 12
50627: PUSH
50628: CALL_OW 44
50632: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50633: LD_VAR 0 12
50637: PPUSH
50638: LD_VAR 0 8
50642: PPUSH
50643: LD_INT 0
50645: PPUSH
50646: CALL 52414 0 3
// end ;
50650: GO 50604
50652: POP
50653: POP
// if fishes then
50654: LD_VAR 0 7
50658: IFFALSE 50725
// for i = 1 to fishes do
50660: LD_ADDR_VAR 0 11
50664: PUSH
50665: DOUBLE
50666: LD_INT 1
50668: DEC
50669: ST_TO_ADDR
50670: LD_VAR 0 7
50674: PUSH
50675: FOR_TO
50676: IFFALSE 50723
// begin hc_class = 20 ;
50678: LD_ADDR_OWVAR 28
50682: PUSH
50683: LD_INT 20
50685: ST_TO_ADDR
// hc_gallery =  ;
50686: LD_ADDR_OWVAR 33
50690: PUSH
50691: LD_STRING 
50693: ST_TO_ADDR
// animal := CreateHuman ;
50694: LD_ADDR_VAR 0 12
50698: PUSH
50699: CALL_OW 44
50703: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
50704: LD_VAR 0 12
50708: PPUSH
50709: LD_VAR 0 9
50713: PPUSH
50714: LD_INT 0
50716: PPUSH
50717: CALL 52414 0 3
// end ;
50721: GO 50675
50723: POP
50724: POP
// end ;
50725: LD_VAR 0 10
50729: RET
// export function WantHeal ( sci , unit ) ; begin
50730: LD_INT 0
50732: PPUSH
// if GetTaskList ( sci ) > 0 then
50733: LD_VAR 0 1
50737: PPUSH
50738: CALL_OW 437
50742: PUSH
50743: LD_INT 0
50745: GREATER
50746: IFFALSE 50816
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
50748: LD_VAR 0 1
50752: PPUSH
50753: CALL_OW 437
50757: PUSH
50758: LD_INT 1
50760: ARRAY
50761: PUSH
50762: LD_INT 1
50764: ARRAY
50765: PUSH
50766: LD_STRING l
50768: EQUAL
50769: PUSH
50770: LD_VAR 0 1
50774: PPUSH
50775: CALL_OW 437
50779: PUSH
50780: LD_INT 1
50782: ARRAY
50783: PUSH
50784: LD_INT 4
50786: ARRAY
50787: PUSH
50788: LD_VAR 0 2
50792: EQUAL
50793: AND
50794: IFFALSE 50806
// result := true else
50796: LD_ADDR_VAR 0 3
50800: PUSH
50801: LD_INT 1
50803: ST_TO_ADDR
50804: GO 50814
// result := false ;
50806: LD_ADDR_VAR 0 3
50810: PUSH
50811: LD_INT 0
50813: ST_TO_ADDR
// end else
50814: GO 50824
// result := false ;
50816: LD_ADDR_VAR 0 3
50820: PUSH
50821: LD_INT 0
50823: ST_TO_ADDR
// end ;
50824: LD_VAR 0 3
50828: RET
// export function HealTarget ( sci ) ; begin
50829: LD_INT 0
50831: PPUSH
// if not sci then
50832: LD_VAR 0 1
50836: NOT
50837: IFFALSE 50841
// exit ;
50839: GO 50906
// result := 0 ;
50841: LD_ADDR_VAR 0 2
50845: PUSH
50846: LD_INT 0
50848: ST_TO_ADDR
// if GetTaskList ( sci ) then
50849: LD_VAR 0 1
50853: PPUSH
50854: CALL_OW 437
50858: IFFALSE 50906
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
50860: LD_VAR 0 1
50864: PPUSH
50865: CALL_OW 437
50869: PUSH
50870: LD_INT 1
50872: ARRAY
50873: PUSH
50874: LD_INT 1
50876: ARRAY
50877: PUSH
50878: LD_STRING l
50880: EQUAL
50881: IFFALSE 50906
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
50883: LD_ADDR_VAR 0 2
50887: PUSH
50888: LD_VAR 0 1
50892: PPUSH
50893: CALL_OW 437
50897: PUSH
50898: LD_INT 1
50900: ARRAY
50901: PUSH
50902: LD_INT 4
50904: ARRAY
50905: ST_TO_ADDR
// end ;
50906: LD_VAR 0 2
50910: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
50911: LD_INT 0
50913: PPUSH
50914: PPUSH
50915: PPUSH
50916: PPUSH
// if not base_units then
50917: LD_VAR 0 1
50921: NOT
50922: IFFALSE 50926
// exit ;
50924: GO 51013
// result := false ;
50926: LD_ADDR_VAR 0 2
50930: PUSH
50931: LD_INT 0
50933: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
50934: LD_ADDR_VAR 0 5
50938: PUSH
50939: LD_VAR 0 1
50943: PPUSH
50944: LD_INT 21
50946: PUSH
50947: LD_INT 3
50949: PUSH
50950: EMPTY
50951: LIST
50952: LIST
50953: PPUSH
50954: CALL_OW 72
50958: ST_TO_ADDR
// if not tmp then
50959: LD_VAR 0 5
50963: NOT
50964: IFFALSE 50968
// exit ;
50966: GO 51013
// for i in tmp do
50968: LD_ADDR_VAR 0 3
50972: PUSH
50973: LD_VAR 0 5
50977: PUSH
50978: FOR_IN
50979: IFFALSE 51011
// begin result := EnemyInRange ( i , 22 ) ;
50981: LD_ADDR_VAR 0 2
50985: PUSH
50986: LD_VAR 0 3
50990: PPUSH
50991: LD_INT 22
50993: PPUSH
50994: CALL 49249 0 2
50998: ST_TO_ADDR
// if result then
50999: LD_VAR 0 2
51003: IFFALSE 51009
// exit ;
51005: POP
51006: POP
51007: GO 51013
// end ;
51009: GO 50978
51011: POP
51012: POP
// end ;
51013: LD_VAR 0 2
51017: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
51018: LD_INT 0
51020: PPUSH
51021: PPUSH
// if not units then
51022: LD_VAR 0 1
51026: NOT
51027: IFFALSE 51031
// exit ;
51029: GO 51101
// result := [ ] ;
51031: LD_ADDR_VAR 0 3
51035: PUSH
51036: EMPTY
51037: ST_TO_ADDR
// for i in units do
51038: LD_ADDR_VAR 0 4
51042: PUSH
51043: LD_VAR 0 1
51047: PUSH
51048: FOR_IN
51049: IFFALSE 51099
// if GetTag ( i ) = tag then
51051: LD_VAR 0 4
51055: PPUSH
51056: CALL_OW 110
51060: PUSH
51061: LD_VAR 0 2
51065: EQUAL
51066: IFFALSE 51097
// result := Insert ( result , result + 1 , i ) ;
51068: LD_ADDR_VAR 0 3
51072: PUSH
51073: LD_VAR 0 3
51077: PPUSH
51078: LD_VAR 0 3
51082: PUSH
51083: LD_INT 1
51085: PLUS
51086: PPUSH
51087: LD_VAR 0 4
51091: PPUSH
51092: CALL_OW 2
51096: ST_TO_ADDR
51097: GO 51048
51099: POP
51100: POP
// end ;
51101: LD_VAR 0 3
51105: RET
// export function IsDriver ( un ) ; begin
51106: LD_INT 0
51108: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51109: LD_ADDR_VAR 0 2
51113: PUSH
51114: LD_VAR 0 1
51118: PUSH
51119: LD_INT 55
51121: PUSH
51122: EMPTY
51123: LIST
51124: PPUSH
51125: CALL_OW 69
51129: IN
51130: ST_TO_ADDR
// end ;
51131: LD_VAR 0 2
51135: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51136: LD_INT 0
51138: PPUSH
51139: PPUSH
// list := [ ] ;
51140: LD_ADDR_VAR 0 5
51144: PUSH
51145: EMPTY
51146: ST_TO_ADDR
// case d of 0 :
51147: LD_VAR 0 3
51151: PUSH
51152: LD_INT 0
51154: DOUBLE
51155: EQUAL
51156: IFTRUE 51160
51158: GO 51293
51160: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51161: LD_ADDR_VAR 0 5
51165: PUSH
51166: LD_VAR 0 1
51170: PUSH
51171: LD_INT 4
51173: MINUS
51174: PUSH
51175: LD_VAR 0 2
51179: PUSH
51180: LD_INT 4
51182: MINUS
51183: PUSH
51184: LD_INT 2
51186: PUSH
51187: EMPTY
51188: LIST
51189: LIST
51190: LIST
51191: PUSH
51192: LD_VAR 0 1
51196: PUSH
51197: LD_INT 3
51199: MINUS
51200: PUSH
51201: LD_VAR 0 2
51205: PUSH
51206: LD_INT 1
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: LIST
51213: PUSH
51214: LD_VAR 0 1
51218: PUSH
51219: LD_INT 4
51221: PLUS
51222: PUSH
51223: LD_VAR 0 2
51227: PUSH
51228: LD_INT 4
51230: PUSH
51231: EMPTY
51232: LIST
51233: LIST
51234: LIST
51235: PUSH
51236: LD_VAR 0 1
51240: PUSH
51241: LD_INT 3
51243: PLUS
51244: PUSH
51245: LD_VAR 0 2
51249: PUSH
51250: LD_INT 3
51252: PLUS
51253: PUSH
51254: LD_INT 5
51256: PUSH
51257: EMPTY
51258: LIST
51259: LIST
51260: LIST
51261: PUSH
51262: LD_VAR 0 1
51266: PUSH
51267: LD_VAR 0 2
51271: PUSH
51272: LD_INT 4
51274: PLUS
51275: PUSH
51276: LD_INT 0
51278: PUSH
51279: EMPTY
51280: LIST
51281: LIST
51282: LIST
51283: PUSH
51284: EMPTY
51285: LIST
51286: LIST
51287: LIST
51288: LIST
51289: LIST
51290: ST_TO_ADDR
// end ; 1 :
51291: GO 51991
51293: LD_INT 1
51295: DOUBLE
51296: EQUAL
51297: IFTRUE 51301
51299: GO 51434
51301: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51302: LD_ADDR_VAR 0 5
51306: PUSH
51307: LD_VAR 0 1
51311: PUSH
51312: LD_VAR 0 2
51316: PUSH
51317: LD_INT 4
51319: MINUS
51320: PUSH
51321: LD_INT 3
51323: PUSH
51324: EMPTY
51325: LIST
51326: LIST
51327: LIST
51328: PUSH
51329: LD_VAR 0 1
51333: PUSH
51334: LD_INT 3
51336: MINUS
51337: PUSH
51338: LD_VAR 0 2
51342: PUSH
51343: LD_INT 3
51345: MINUS
51346: PUSH
51347: LD_INT 2
51349: PUSH
51350: EMPTY
51351: LIST
51352: LIST
51353: LIST
51354: PUSH
51355: LD_VAR 0 1
51359: PUSH
51360: LD_INT 4
51362: MINUS
51363: PUSH
51364: LD_VAR 0 2
51368: PUSH
51369: LD_INT 1
51371: PUSH
51372: EMPTY
51373: LIST
51374: LIST
51375: LIST
51376: PUSH
51377: LD_VAR 0 1
51381: PUSH
51382: LD_VAR 0 2
51386: PUSH
51387: LD_INT 3
51389: PLUS
51390: PUSH
51391: LD_INT 0
51393: PUSH
51394: EMPTY
51395: LIST
51396: LIST
51397: LIST
51398: PUSH
51399: LD_VAR 0 1
51403: PUSH
51404: LD_INT 4
51406: PLUS
51407: PUSH
51408: LD_VAR 0 2
51412: PUSH
51413: LD_INT 4
51415: PLUS
51416: PUSH
51417: LD_INT 5
51419: PUSH
51420: EMPTY
51421: LIST
51422: LIST
51423: LIST
51424: PUSH
51425: EMPTY
51426: LIST
51427: LIST
51428: LIST
51429: LIST
51430: LIST
51431: ST_TO_ADDR
// end ; 2 :
51432: GO 51991
51434: LD_INT 2
51436: DOUBLE
51437: EQUAL
51438: IFTRUE 51442
51440: GO 51571
51442: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
51443: LD_ADDR_VAR 0 5
51447: PUSH
51448: LD_VAR 0 1
51452: PUSH
51453: LD_VAR 0 2
51457: PUSH
51458: LD_INT 3
51460: MINUS
51461: PUSH
51462: LD_INT 3
51464: PUSH
51465: EMPTY
51466: LIST
51467: LIST
51468: LIST
51469: PUSH
51470: LD_VAR 0 1
51474: PUSH
51475: LD_INT 4
51477: PLUS
51478: PUSH
51479: LD_VAR 0 2
51483: PUSH
51484: LD_INT 4
51486: PUSH
51487: EMPTY
51488: LIST
51489: LIST
51490: LIST
51491: PUSH
51492: LD_VAR 0 1
51496: PUSH
51497: LD_VAR 0 2
51501: PUSH
51502: LD_INT 4
51504: PLUS
51505: PUSH
51506: LD_INT 0
51508: PUSH
51509: EMPTY
51510: LIST
51511: LIST
51512: LIST
51513: PUSH
51514: LD_VAR 0 1
51518: PUSH
51519: LD_INT 3
51521: MINUS
51522: PUSH
51523: LD_VAR 0 2
51527: PUSH
51528: LD_INT 1
51530: PUSH
51531: EMPTY
51532: LIST
51533: LIST
51534: LIST
51535: PUSH
51536: LD_VAR 0 1
51540: PUSH
51541: LD_INT 4
51543: MINUS
51544: PUSH
51545: LD_VAR 0 2
51549: PUSH
51550: LD_INT 4
51552: MINUS
51553: PUSH
51554: LD_INT 2
51556: PUSH
51557: EMPTY
51558: LIST
51559: LIST
51560: LIST
51561: PUSH
51562: EMPTY
51563: LIST
51564: LIST
51565: LIST
51566: LIST
51567: LIST
51568: ST_TO_ADDR
// end ; 3 :
51569: GO 51991
51571: LD_INT 3
51573: DOUBLE
51574: EQUAL
51575: IFTRUE 51579
51577: GO 51712
51579: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
51580: LD_ADDR_VAR 0 5
51584: PUSH
51585: LD_VAR 0 1
51589: PUSH
51590: LD_INT 3
51592: PLUS
51593: PUSH
51594: LD_VAR 0 2
51598: PUSH
51599: LD_INT 4
51601: PUSH
51602: EMPTY
51603: LIST
51604: LIST
51605: LIST
51606: PUSH
51607: LD_VAR 0 1
51611: PUSH
51612: LD_INT 4
51614: PLUS
51615: PUSH
51616: LD_VAR 0 2
51620: PUSH
51621: LD_INT 4
51623: PLUS
51624: PUSH
51625: LD_INT 5
51627: PUSH
51628: EMPTY
51629: LIST
51630: LIST
51631: LIST
51632: PUSH
51633: LD_VAR 0 1
51637: PUSH
51638: LD_INT 4
51640: MINUS
51641: PUSH
51642: LD_VAR 0 2
51646: PUSH
51647: LD_INT 1
51649: PUSH
51650: EMPTY
51651: LIST
51652: LIST
51653: LIST
51654: PUSH
51655: LD_VAR 0 1
51659: PUSH
51660: LD_VAR 0 2
51664: PUSH
51665: LD_INT 4
51667: MINUS
51668: PUSH
51669: LD_INT 3
51671: PUSH
51672: EMPTY
51673: LIST
51674: LIST
51675: LIST
51676: PUSH
51677: LD_VAR 0 1
51681: PUSH
51682: LD_INT 3
51684: MINUS
51685: PUSH
51686: LD_VAR 0 2
51690: PUSH
51691: LD_INT 3
51693: MINUS
51694: PUSH
51695: LD_INT 2
51697: PUSH
51698: EMPTY
51699: LIST
51700: LIST
51701: LIST
51702: PUSH
51703: EMPTY
51704: LIST
51705: LIST
51706: LIST
51707: LIST
51708: LIST
51709: ST_TO_ADDR
// end ; 4 :
51710: GO 51991
51712: LD_INT 4
51714: DOUBLE
51715: EQUAL
51716: IFTRUE 51720
51718: GO 51853
51720: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
51721: LD_ADDR_VAR 0 5
51725: PUSH
51726: LD_VAR 0 1
51730: PUSH
51731: LD_VAR 0 2
51735: PUSH
51736: LD_INT 4
51738: PLUS
51739: PUSH
51740: LD_INT 0
51742: PUSH
51743: EMPTY
51744: LIST
51745: LIST
51746: LIST
51747: PUSH
51748: LD_VAR 0 1
51752: PUSH
51753: LD_INT 3
51755: PLUS
51756: PUSH
51757: LD_VAR 0 2
51761: PUSH
51762: LD_INT 3
51764: PLUS
51765: PUSH
51766: LD_INT 5
51768: PUSH
51769: EMPTY
51770: LIST
51771: LIST
51772: LIST
51773: PUSH
51774: LD_VAR 0 1
51778: PUSH
51779: LD_INT 4
51781: PLUS
51782: PUSH
51783: LD_VAR 0 2
51787: PUSH
51788: LD_INT 4
51790: PUSH
51791: EMPTY
51792: LIST
51793: LIST
51794: LIST
51795: PUSH
51796: LD_VAR 0 1
51800: PUSH
51801: LD_VAR 0 2
51805: PUSH
51806: LD_INT 3
51808: MINUS
51809: PUSH
51810: LD_INT 3
51812: PUSH
51813: EMPTY
51814: LIST
51815: LIST
51816: LIST
51817: PUSH
51818: LD_VAR 0 1
51822: PUSH
51823: LD_INT 4
51825: MINUS
51826: PUSH
51827: LD_VAR 0 2
51831: PUSH
51832: LD_INT 4
51834: MINUS
51835: PUSH
51836: LD_INT 2
51838: PUSH
51839: EMPTY
51840: LIST
51841: LIST
51842: LIST
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: LIST
51848: LIST
51849: LIST
51850: ST_TO_ADDR
// end ; 5 :
51851: GO 51991
51853: LD_INT 5
51855: DOUBLE
51856: EQUAL
51857: IFTRUE 51861
51859: GO 51990
51861: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
51862: LD_ADDR_VAR 0 5
51866: PUSH
51867: LD_VAR 0 1
51871: PUSH
51872: LD_INT 4
51874: MINUS
51875: PUSH
51876: LD_VAR 0 2
51880: PUSH
51881: LD_INT 1
51883: PUSH
51884: EMPTY
51885: LIST
51886: LIST
51887: LIST
51888: PUSH
51889: LD_VAR 0 1
51893: PUSH
51894: LD_VAR 0 2
51898: PUSH
51899: LD_INT 4
51901: MINUS
51902: PUSH
51903: LD_INT 3
51905: PUSH
51906: EMPTY
51907: LIST
51908: LIST
51909: LIST
51910: PUSH
51911: LD_VAR 0 1
51915: PUSH
51916: LD_INT 4
51918: PLUS
51919: PUSH
51920: LD_VAR 0 2
51924: PUSH
51925: LD_INT 4
51927: PLUS
51928: PUSH
51929: LD_INT 5
51931: PUSH
51932: EMPTY
51933: LIST
51934: LIST
51935: LIST
51936: PUSH
51937: LD_VAR 0 1
51941: PUSH
51942: LD_INT 3
51944: PLUS
51945: PUSH
51946: LD_VAR 0 2
51950: PUSH
51951: LD_INT 4
51953: PUSH
51954: EMPTY
51955: LIST
51956: LIST
51957: LIST
51958: PUSH
51959: LD_VAR 0 1
51963: PUSH
51964: LD_VAR 0 2
51968: PUSH
51969: LD_INT 3
51971: PLUS
51972: PUSH
51973: LD_INT 0
51975: PUSH
51976: EMPTY
51977: LIST
51978: LIST
51979: LIST
51980: PUSH
51981: EMPTY
51982: LIST
51983: LIST
51984: LIST
51985: LIST
51986: LIST
51987: ST_TO_ADDR
// end ; end ;
51988: GO 51991
51990: POP
// result := list ;
51991: LD_ADDR_VAR 0 4
51995: PUSH
51996: LD_VAR 0 5
52000: ST_TO_ADDR
// end ;
52001: LD_VAR 0 4
52005: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52006: LD_INT 0
52008: PPUSH
52009: PPUSH
52010: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52011: LD_VAR 0 1
52015: NOT
52016: PUSH
52017: LD_VAR 0 2
52021: PUSH
52022: LD_INT 1
52024: PUSH
52025: LD_INT 2
52027: PUSH
52028: LD_INT 3
52030: PUSH
52031: LD_INT 4
52033: PUSH
52034: EMPTY
52035: LIST
52036: LIST
52037: LIST
52038: LIST
52039: IN
52040: NOT
52041: OR
52042: IFFALSE 52046
// exit ;
52044: GO 52138
// tmp := [ ] ;
52046: LD_ADDR_VAR 0 5
52050: PUSH
52051: EMPTY
52052: ST_TO_ADDR
// for i in units do
52053: LD_ADDR_VAR 0 4
52057: PUSH
52058: LD_VAR 0 1
52062: PUSH
52063: FOR_IN
52064: IFFALSE 52107
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
52066: LD_ADDR_VAR 0 5
52070: PUSH
52071: LD_VAR 0 5
52075: PPUSH
52076: LD_VAR 0 5
52080: PUSH
52081: LD_INT 1
52083: PLUS
52084: PPUSH
52085: LD_VAR 0 4
52089: PPUSH
52090: LD_VAR 0 2
52094: PPUSH
52095: CALL_OW 259
52099: PPUSH
52100: CALL_OW 2
52104: ST_TO_ADDR
52105: GO 52063
52107: POP
52108: POP
// if not tmp then
52109: LD_VAR 0 5
52113: NOT
52114: IFFALSE 52118
// exit ;
52116: GO 52138
// result := SortListByListDesc ( units , tmp ) ;
52118: LD_ADDR_VAR 0 3
52122: PUSH
52123: LD_VAR 0 1
52127: PPUSH
52128: LD_VAR 0 5
52132: PPUSH
52133: CALL_OW 77
52137: ST_TO_ADDR
// end ;
52138: LD_VAR 0 3
52142: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52143: LD_INT 0
52145: PPUSH
52146: PPUSH
52147: PPUSH
// result := false ;
52148: LD_ADDR_VAR 0 3
52152: PUSH
52153: LD_INT 0
52155: ST_TO_ADDR
// x := GetX ( building ) ;
52156: LD_ADDR_VAR 0 4
52160: PUSH
52161: LD_VAR 0 2
52165: PPUSH
52166: CALL_OW 250
52170: ST_TO_ADDR
// y := GetY ( building ) ;
52171: LD_ADDR_VAR 0 5
52175: PUSH
52176: LD_VAR 0 2
52180: PPUSH
52181: CALL_OW 251
52185: ST_TO_ADDR
// if not building or not x or not y then
52186: LD_VAR 0 2
52190: NOT
52191: PUSH
52192: LD_VAR 0 4
52196: NOT
52197: OR
52198: PUSH
52199: LD_VAR 0 5
52203: NOT
52204: OR
52205: IFFALSE 52209
// exit ;
52207: GO 52301
// if GetTaskList ( unit ) then
52209: LD_VAR 0 1
52213: PPUSH
52214: CALL_OW 437
52218: IFFALSE 52301
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52220: LD_STRING e
52222: PUSH
52223: LD_VAR 0 1
52227: PPUSH
52228: CALL_OW 437
52232: PUSH
52233: LD_INT 1
52235: ARRAY
52236: PUSH
52237: LD_INT 1
52239: ARRAY
52240: EQUAL
52241: PUSH
52242: LD_VAR 0 4
52246: PUSH
52247: LD_VAR 0 1
52251: PPUSH
52252: CALL_OW 437
52256: PUSH
52257: LD_INT 1
52259: ARRAY
52260: PUSH
52261: LD_INT 2
52263: ARRAY
52264: EQUAL
52265: AND
52266: PUSH
52267: LD_VAR 0 5
52271: PUSH
52272: LD_VAR 0 1
52276: PPUSH
52277: CALL_OW 437
52281: PUSH
52282: LD_INT 1
52284: ARRAY
52285: PUSH
52286: LD_INT 3
52288: ARRAY
52289: EQUAL
52290: AND
52291: IFFALSE 52301
// result := true end ;
52293: LD_ADDR_VAR 0 3
52297: PUSH
52298: LD_INT 1
52300: ST_TO_ADDR
// end ;
52301: LD_VAR 0 3
52305: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52306: LD_INT 0
52308: PPUSH
// result := false ;
52309: LD_ADDR_VAR 0 4
52313: PUSH
52314: LD_INT 0
52316: ST_TO_ADDR
// if GetTaskList ( unit ) then
52317: LD_VAR 0 1
52321: PPUSH
52322: CALL_OW 437
52326: IFFALSE 52409
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52328: LD_STRING M
52330: PUSH
52331: LD_VAR 0 1
52335: PPUSH
52336: CALL_OW 437
52340: PUSH
52341: LD_INT 1
52343: ARRAY
52344: PUSH
52345: LD_INT 1
52347: ARRAY
52348: EQUAL
52349: PUSH
52350: LD_VAR 0 2
52354: PUSH
52355: LD_VAR 0 1
52359: PPUSH
52360: CALL_OW 437
52364: PUSH
52365: LD_INT 1
52367: ARRAY
52368: PUSH
52369: LD_INT 2
52371: ARRAY
52372: EQUAL
52373: AND
52374: PUSH
52375: LD_VAR 0 3
52379: PUSH
52380: LD_VAR 0 1
52384: PPUSH
52385: CALL_OW 437
52389: PUSH
52390: LD_INT 1
52392: ARRAY
52393: PUSH
52394: LD_INT 3
52396: ARRAY
52397: EQUAL
52398: AND
52399: IFFALSE 52409
// result := true ;
52401: LD_ADDR_VAR 0 4
52405: PUSH
52406: LD_INT 1
52408: ST_TO_ADDR
// end ; end ;
52409: LD_VAR 0 4
52413: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
52414: LD_INT 0
52416: PPUSH
52417: PPUSH
52418: PPUSH
52419: PPUSH
// if not unit or not area then
52420: LD_VAR 0 1
52424: NOT
52425: PUSH
52426: LD_VAR 0 2
52430: NOT
52431: OR
52432: IFFALSE 52436
// exit ;
52434: GO 52600
// tmp := AreaToList ( area , i ) ;
52436: LD_ADDR_VAR 0 6
52440: PUSH
52441: LD_VAR 0 2
52445: PPUSH
52446: LD_VAR 0 5
52450: PPUSH
52451: CALL_OW 517
52455: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
52456: LD_ADDR_VAR 0 5
52460: PUSH
52461: DOUBLE
52462: LD_INT 1
52464: DEC
52465: ST_TO_ADDR
52466: LD_VAR 0 6
52470: PUSH
52471: LD_INT 1
52473: ARRAY
52474: PUSH
52475: FOR_TO
52476: IFFALSE 52598
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
52478: LD_ADDR_VAR 0 7
52482: PUSH
52483: LD_VAR 0 6
52487: PUSH
52488: LD_INT 1
52490: ARRAY
52491: PUSH
52492: LD_VAR 0 5
52496: ARRAY
52497: PUSH
52498: LD_VAR 0 6
52502: PUSH
52503: LD_INT 2
52505: ARRAY
52506: PUSH
52507: LD_VAR 0 5
52511: ARRAY
52512: PUSH
52513: EMPTY
52514: LIST
52515: LIST
52516: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
52517: LD_VAR 0 7
52521: PUSH
52522: LD_INT 1
52524: ARRAY
52525: PPUSH
52526: LD_VAR 0 7
52530: PUSH
52531: LD_INT 2
52533: ARRAY
52534: PPUSH
52535: CALL_OW 428
52539: PUSH
52540: LD_INT 0
52542: EQUAL
52543: IFFALSE 52596
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
52545: LD_VAR 0 1
52549: PPUSH
52550: LD_VAR 0 7
52554: PUSH
52555: LD_INT 1
52557: ARRAY
52558: PPUSH
52559: LD_VAR 0 7
52563: PUSH
52564: LD_INT 2
52566: ARRAY
52567: PPUSH
52568: LD_VAR 0 3
52572: PPUSH
52573: CALL_OW 48
// result := IsPlaced ( unit ) ;
52577: LD_ADDR_VAR 0 4
52581: PUSH
52582: LD_VAR 0 1
52586: PPUSH
52587: CALL_OW 305
52591: ST_TO_ADDR
// exit ;
52592: POP
52593: POP
52594: GO 52600
// end ; end ;
52596: GO 52475
52598: POP
52599: POP
// end ;
52600: LD_VAR 0 4
52604: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
52605: LD_INT 0
52607: PPUSH
52608: PPUSH
52609: PPUSH
// if not side or side > 8 then
52610: LD_VAR 0 1
52614: NOT
52615: PUSH
52616: LD_VAR 0 1
52620: PUSH
52621: LD_INT 8
52623: GREATER
52624: OR
52625: IFFALSE 52629
// exit ;
52627: GO 52816
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
52629: LD_ADDR_VAR 0 4
52633: PUSH
52634: LD_INT 22
52636: PUSH
52637: LD_VAR 0 1
52641: PUSH
52642: EMPTY
52643: LIST
52644: LIST
52645: PUSH
52646: LD_INT 21
52648: PUSH
52649: LD_INT 3
52651: PUSH
52652: EMPTY
52653: LIST
52654: LIST
52655: PUSH
52656: EMPTY
52657: LIST
52658: LIST
52659: PPUSH
52660: CALL_OW 69
52664: ST_TO_ADDR
// if not tmp then
52665: LD_VAR 0 4
52669: NOT
52670: IFFALSE 52674
// exit ;
52672: GO 52816
// enable_addtolog := true ;
52674: LD_ADDR_OWVAR 81
52678: PUSH
52679: LD_INT 1
52681: ST_TO_ADDR
// AddToLog ( [ ) ;
52682: LD_STRING [
52684: PPUSH
52685: CALL_OW 561
// for i in tmp do
52689: LD_ADDR_VAR 0 3
52693: PUSH
52694: LD_VAR 0 4
52698: PUSH
52699: FOR_IN
52700: IFFALSE 52807
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
52702: LD_STRING [
52704: PUSH
52705: LD_VAR 0 3
52709: PPUSH
52710: CALL_OW 266
52714: STR
52715: PUSH
52716: LD_STRING , 
52718: STR
52719: PUSH
52720: LD_VAR 0 3
52724: PPUSH
52725: CALL_OW 250
52729: STR
52730: PUSH
52731: LD_STRING , 
52733: STR
52734: PUSH
52735: LD_VAR 0 3
52739: PPUSH
52740: CALL_OW 251
52744: STR
52745: PUSH
52746: LD_STRING , 
52748: STR
52749: PUSH
52750: LD_VAR 0 3
52754: PPUSH
52755: CALL_OW 254
52759: STR
52760: PUSH
52761: LD_STRING , 
52763: STR
52764: PUSH
52765: LD_VAR 0 3
52769: PPUSH
52770: LD_INT 1
52772: PPUSH
52773: CALL_OW 268
52777: STR
52778: PUSH
52779: LD_STRING , 
52781: STR
52782: PUSH
52783: LD_VAR 0 3
52787: PPUSH
52788: LD_INT 2
52790: PPUSH
52791: CALL_OW 268
52795: STR
52796: PUSH
52797: LD_STRING ],
52799: STR
52800: PPUSH
52801: CALL_OW 561
// end ;
52805: GO 52699
52807: POP
52808: POP
// AddToLog ( ]; ) ;
52809: LD_STRING ];
52811: PPUSH
52812: CALL_OW 561
// end ;
52816: LD_VAR 0 2
52820: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
52821: LD_INT 0
52823: PPUSH
52824: PPUSH
52825: PPUSH
52826: PPUSH
52827: PPUSH
// if not area or not rate or not max then
52828: LD_VAR 0 1
52832: NOT
52833: PUSH
52834: LD_VAR 0 2
52838: NOT
52839: OR
52840: PUSH
52841: LD_VAR 0 4
52845: NOT
52846: OR
52847: IFFALSE 52851
// exit ;
52849: GO 53043
// while 1 do
52851: LD_INT 1
52853: IFFALSE 53043
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
52855: LD_ADDR_VAR 0 9
52859: PUSH
52860: LD_VAR 0 1
52864: PPUSH
52865: LD_INT 1
52867: PPUSH
52868: CALL_OW 287
52872: PUSH
52873: LD_INT 10
52875: MUL
52876: ST_TO_ADDR
// r := rate / 10 ;
52877: LD_ADDR_VAR 0 7
52881: PUSH
52882: LD_VAR 0 2
52886: PUSH
52887: LD_INT 10
52889: DIVREAL
52890: ST_TO_ADDR
// time := 1 1$00 ;
52891: LD_ADDR_VAR 0 8
52895: PUSH
52896: LD_INT 2100
52898: ST_TO_ADDR
// if amount < min then
52899: LD_VAR 0 9
52903: PUSH
52904: LD_VAR 0 3
52908: LESS
52909: IFFALSE 52927
// r := r * 2 else
52911: LD_ADDR_VAR 0 7
52915: PUSH
52916: LD_VAR 0 7
52920: PUSH
52921: LD_INT 2
52923: MUL
52924: ST_TO_ADDR
52925: GO 52953
// if amount > max then
52927: LD_VAR 0 9
52931: PUSH
52932: LD_VAR 0 4
52936: GREATER
52937: IFFALSE 52953
// r := r / 2 ;
52939: LD_ADDR_VAR 0 7
52943: PUSH
52944: LD_VAR 0 7
52948: PUSH
52949: LD_INT 2
52951: DIVREAL
52952: ST_TO_ADDR
// time := time / r ;
52953: LD_ADDR_VAR 0 8
52957: PUSH
52958: LD_VAR 0 8
52962: PUSH
52963: LD_VAR 0 7
52967: DIVREAL
52968: ST_TO_ADDR
// if time < 0 then
52969: LD_VAR 0 8
52973: PUSH
52974: LD_INT 0
52976: LESS
52977: IFFALSE 52994
// time := time * - 1 ;
52979: LD_ADDR_VAR 0 8
52983: PUSH
52984: LD_VAR 0 8
52988: PUSH
52989: LD_INT 1
52991: NEG
52992: MUL
52993: ST_TO_ADDR
// wait ( time ) ;
52994: LD_VAR 0 8
52998: PPUSH
52999: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
53003: LD_INT 35
53005: PPUSH
53006: LD_INT 875
53008: PPUSH
53009: CALL_OW 12
53013: PPUSH
53014: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53018: LD_INT 1
53020: PPUSH
53021: LD_INT 5
53023: PPUSH
53024: CALL_OW 12
53028: PPUSH
53029: LD_VAR 0 1
53033: PPUSH
53034: LD_INT 1
53036: PPUSH
53037: CALL_OW 55
// end ;
53041: GO 52851
// end ;
53043: LD_VAR 0 5
53047: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53048: LD_INT 0
53050: PPUSH
53051: PPUSH
53052: PPUSH
53053: PPUSH
53054: PPUSH
53055: PPUSH
53056: PPUSH
53057: PPUSH
// if not turrets or not factories then
53058: LD_VAR 0 1
53062: NOT
53063: PUSH
53064: LD_VAR 0 2
53068: NOT
53069: OR
53070: IFFALSE 53074
// exit ;
53072: GO 53381
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53074: LD_ADDR_VAR 0 10
53078: PUSH
53079: LD_INT 5
53081: PUSH
53082: LD_INT 6
53084: PUSH
53085: EMPTY
53086: LIST
53087: LIST
53088: PUSH
53089: LD_INT 2
53091: PUSH
53092: LD_INT 4
53094: PUSH
53095: EMPTY
53096: LIST
53097: LIST
53098: PUSH
53099: LD_INT 3
53101: PUSH
53102: LD_INT 5
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: PUSH
53109: EMPTY
53110: LIST
53111: LIST
53112: LIST
53113: PUSH
53114: LD_INT 24
53116: PUSH
53117: LD_INT 25
53119: PUSH
53120: EMPTY
53121: LIST
53122: LIST
53123: PUSH
53124: LD_INT 23
53126: PUSH
53127: LD_INT 27
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: PUSH
53134: EMPTY
53135: LIST
53136: LIST
53137: PUSH
53138: LD_INT 42
53140: PUSH
53141: LD_INT 43
53143: PUSH
53144: EMPTY
53145: LIST
53146: LIST
53147: PUSH
53148: LD_INT 44
53150: PUSH
53151: LD_INT 46
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: PUSH
53158: LD_INT 45
53160: PUSH
53161: LD_INT 47
53163: PUSH
53164: EMPTY
53165: LIST
53166: LIST
53167: PUSH
53168: EMPTY
53169: LIST
53170: LIST
53171: LIST
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: LIST
53177: ST_TO_ADDR
// result := [ ] ;
53178: LD_ADDR_VAR 0 3
53182: PUSH
53183: EMPTY
53184: ST_TO_ADDR
// for i in turrets do
53185: LD_ADDR_VAR 0 4
53189: PUSH
53190: LD_VAR 0 1
53194: PUSH
53195: FOR_IN
53196: IFFALSE 53379
// begin nat := GetNation ( i ) ;
53198: LD_ADDR_VAR 0 7
53202: PUSH
53203: LD_VAR 0 4
53207: PPUSH
53208: CALL_OW 248
53212: ST_TO_ADDR
// weapon := 0 ;
53213: LD_ADDR_VAR 0 8
53217: PUSH
53218: LD_INT 0
53220: ST_TO_ADDR
// if not nat then
53221: LD_VAR 0 7
53225: NOT
53226: IFFALSE 53230
// continue ;
53228: GO 53195
// for j in list [ nat ] do
53230: LD_ADDR_VAR 0 5
53234: PUSH
53235: LD_VAR 0 10
53239: PUSH
53240: LD_VAR 0 7
53244: ARRAY
53245: PUSH
53246: FOR_IN
53247: IFFALSE 53288
// if GetBWeapon ( i ) = j [ 1 ] then
53249: LD_VAR 0 4
53253: PPUSH
53254: CALL_OW 269
53258: PUSH
53259: LD_VAR 0 5
53263: PUSH
53264: LD_INT 1
53266: ARRAY
53267: EQUAL
53268: IFFALSE 53286
// begin weapon := j [ 2 ] ;
53270: LD_ADDR_VAR 0 8
53274: PUSH
53275: LD_VAR 0 5
53279: PUSH
53280: LD_INT 2
53282: ARRAY
53283: ST_TO_ADDR
// break ;
53284: GO 53288
// end ;
53286: GO 53246
53288: POP
53289: POP
// if not weapon then
53290: LD_VAR 0 8
53294: NOT
53295: IFFALSE 53299
// continue ;
53297: GO 53195
// for k in factories do
53299: LD_ADDR_VAR 0 6
53303: PUSH
53304: LD_VAR 0 2
53308: PUSH
53309: FOR_IN
53310: IFFALSE 53375
// begin weapons := AvailableWeaponList ( k ) ;
53312: LD_ADDR_VAR 0 9
53316: PUSH
53317: LD_VAR 0 6
53321: PPUSH
53322: CALL_OW 478
53326: ST_TO_ADDR
// if not weapons then
53327: LD_VAR 0 9
53331: NOT
53332: IFFALSE 53336
// continue ;
53334: GO 53309
// if weapon in weapons then
53336: LD_VAR 0 8
53340: PUSH
53341: LD_VAR 0 9
53345: IN
53346: IFFALSE 53373
// begin result := [ i , weapon ] ;
53348: LD_ADDR_VAR 0 3
53352: PUSH
53353: LD_VAR 0 4
53357: PUSH
53358: LD_VAR 0 8
53362: PUSH
53363: EMPTY
53364: LIST
53365: LIST
53366: ST_TO_ADDR
// exit ;
53367: POP
53368: POP
53369: POP
53370: POP
53371: GO 53381
// end ; end ;
53373: GO 53309
53375: POP
53376: POP
// end ;
53377: GO 53195
53379: POP
53380: POP
// end ;
53381: LD_VAR 0 3
53385: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
53386: LD_INT 0
53388: PPUSH
// if not side or side > 8 then
53389: LD_VAR 0 3
53393: NOT
53394: PUSH
53395: LD_VAR 0 3
53399: PUSH
53400: LD_INT 8
53402: GREATER
53403: OR
53404: IFFALSE 53408
// exit ;
53406: GO 53467
// if not range then
53408: LD_VAR 0 4
53412: NOT
53413: IFFALSE 53424
// range := - 12 ;
53415: LD_ADDR_VAR 0 4
53419: PUSH
53420: LD_INT 12
53422: NEG
53423: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
53424: LD_VAR 0 1
53428: PPUSH
53429: LD_VAR 0 2
53433: PPUSH
53434: LD_VAR 0 3
53438: PPUSH
53439: LD_VAR 0 4
53443: PPUSH
53444: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
53448: LD_VAR 0 1
53452: PPUSH
53453: LD_VAR 0 2
53457: PPUSH
53458: LD_VAR 0 3
53462: PPUSH
53463: CALL_OW 331
// end ;
53467: LD_VAR 0 5
53471: RET
// export function Video ( mode ) ; begin
53472: LD_INT 0
53474: PPUSH
// ingame_video = mode ;
53475: LD_ADDR_OWVAR 52
53479: PUSH
53480: LD_VAR 0 1
53484: ST_TO_ADDR
// interface_hidden = mode ;
53485: LD_ADDR_OWVAR 54
53489: PUSH
53490: LD_VAR 0 1
53494: ST_TO_ADDR
// end ;
53495: LD_VAR 0 2
53499: RET
// export function Join ( array , element ) ; begin
53500: LD_INT 0
53502: PPUSH
// result := Replace ( array , array + 1 , element ) ;
53503: LD_ADDR_VAR 0 3
53507: PUSH
53508: LD_VAR 0 1
53512: PPUSH
53513: LD_VAR 0 1
53517: PUSH
53518: LD_INT 1
53520: PLUS
53521: PPUSH
53522: LD_VAR 0 2
53526: PPUSH
53527: CALL_OW 1
53531: ST_TO_ADDR
// end ;
53532: LD_VAR 0 3
53536: RET
// export function JoinUnion ( array , element ) ; begin
53537: LD_INT 0
53539: PPUSH
// result := array union element ;
53540: LD_ADDR_VAR 0 3
53544: PUSH
53545: LD_VAR 0 1
53549: PUSH
53550: LD_VAR 0 2
53554: UNION
53555: ST_TO_ADDR
// end ;
53556: LD_VAR 0 3
53560: RET
// export function GetBehemoths ( side ) ; begin
53561: LD_INT 0
53563: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
53564: LD_ADDR_VAR 0 2
53568: PUSH
53569: LD_INT 22
53571: PUSH
53572: LD_VAR 0 1
53576: PUSH
53577: EMPTY
53578: LIST
53579: LIST
53580: PUSH
53581: LD_INT 31
53583: PUSH
53584: LD_INT 25
53586: PUSH
53587: EMPTY
53588: LIST
53589: LIST
53590: PUSH
53591: EMPTY
53592: LIST
53593: LIST
53594: PPUSH
53595: CALL_OW 69
53599: ST_TO_ADDR
// end ;
53600: LD_VAR 0 2
53604: RET
// export function Shuffle ( array ) ; var i , index ; begin
53605: LD_INT 0
53607: PPUSH
53608: PPUSH
53609: PPUSH
// result := [ ] ;
53610: LD_ADDR_VAR 0 2
53614: PUSH
53615: EMPTY
53616: ST_TO_ADDR
// if not array then
53617: LD_VAR 0 1
53621: NOT
53622: IFFALSE 53626
// exit ;
53624: GO 53725
// Randomize ;
53626: CALL_OW 10
// for i = array downto 1 do
53630: LD_ADDR_VAR 0 3
53634: PUSH
53635: DOUBLE
53636: LD_VAR 0 1
53640: INC
53641: ST_TO_ADDR
53642: LD_INT 1
53644: PUSH
53645: FOR_DOWNTO
53646: IFFALSE 53723
// begin index := rand ( 1 , array ) ;
53648: LD_ADDR_VAR 0 4
53652: PUSH
53653: LD_INT 1
53655: PPUSH
53656: LD_VAR 0 1
53660: PPUSH
53661: CALL_OW 12
53665: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
53666: LD_ADDR_VAR 0 2
53670: PUSH
53671: LD_VAR 0 2
53675: PPUSH
53676: LD_VAR 0 2
53680: PUSH
53681: LD_INT 1
53683: PLUS
53684: PPUSH
53685: LD_VAR 0 1
53689: PUSH
53690: LD_VAR 0 4
53694: ARRAY
53695: PPUSH
53696: CALL_OW 2
53700: ST_TO_ADDR
// array := Delete ( array , index ) ;
53701: LD_ADDR_VAR 0 1
53705: PUSH
53706: LD_VAR 0 1
53710: PPUSH
53711: LD_VAR 0 4
53715: PPUSH
53716: CALL_OW 3
53720: ST_TO_ADDR
// end ;
53721: GO 53645
53723: POP
53724: POP
// end ;
53725: LD_VAR 0 2
53729: RET
// export function GetBaseMaterials ( base ) ; begin
53730: LD_INT 0
53732: PPUSH
// result := [ 0 , 0 , 0 ] ;
53733: LD_ADDR_VAR 0 2
53737: PUSH
53738: LD_INT 0
53740: PUSH
53741: LD_INT 0
53743: PUSH
53744: LD_INT 0
53746: PUSH
53747: EMPTY
53748: LIST
53749: LIST
53750: LIST
53751: ST_TO_ADDR
// if not base then
53752: LD_VAR 0 1
53756: NOT
53757: IFFALSE 53761
// exit ;
53759: GO 53810
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
53761: LD_ADDR_VAR 0 2
53765: PUSH
53766: LD_VAR 0 1
53770: PPUSH
53771: LD_INT 1
53773: PPUSH
53774: CALL_OW 275
53778: PUSH
53779: LD_VAR 0 1
53783: PPUSH
53784: LD_INT 2
53786: PPUSH
53787: CALL_OW 275
53791: PUSH
53792: LD_VAR 0 1
53796: PPUSH
53797: LD_INT 3
53799: PPUSH
53800: CALL_OW 275
53804: PUSH
53805: EMPTY
53806: LIST
53807: LIST
53808: LIST
53809: ST_TO_ADDR
// end ;
53810: LD_VAR 0 2
53814: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
53815: LD_INT 0
53817: PPUSH
53818: PPUSH
// result := array ;
53819: LD_ADDR_VAR 0 3
53823: PUSH
53824: LD_VAR 0 1
53828: ST_TO_ADDR
// if size > 0 then
53829: LD_VAR 0 2
53833: PUSH
53834: LD_INT 0
53836: GREATER
53837: IFFALSE 53883
// for i := array downto size do
53839: LD_ADDR_VAR 0 4
53843: PUSH
53844: DOUBLE
53845: LD_VAR 0 1
53849: INC
53850: ST_TO_ADDR
53851: LD_VAR 0 2
53855: PUSH
53856: FOR_DOWNTO
53857: IFFALSE 53881
// result := Delete ( result , result ) ;
53859: LD_ADDR_VAR 0 3
53863: PUSH
53864: LD_VAR 0 3
53868: PPUSH
53869: LD_VAR 0 3
53873: PPUSH
53874: CALL_OW 3
53878: ST_TO_ADDR
53879: GO 53856
53881: POP
53882: POP
// end ;
53883: LD_VAR 0 3
53887: RET
// export function ComExit ( unit ) ; var tmp ; begin
53888: LD_INT 0
53890: PPUSH
53891: PPUSH
// if not IsInUnit ( unit ) then
53892: LD_VAR 0 1
53896: PPUSH
53897: CALL_OW 310
53901: NOT
53902: IFFALSE 53906
// exit ;
53904: GO 53966
// tmp := IsInUnit ( unit ) ;
53906: LD_ADDR_VAR 0 3
53910: PUSH
53911: LD_VAR 0 1
53915: PPUSH
53916: CALL_OW 310
53920: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
53921: LD_VAR 0 3
53925: PPUSH
53926: CALL_OW 247
53930: PUSH
53931: LD_INT 2
53933: EQUAL
53934: IFFALSE 53947
// ComExitVehicle ( unit ) else
53936: LD_VAR 0 1
53940: PPUSH
53941: CALL_OW 121
53945: GO 53956
// ComExitBuilding ( unit ) ;
53947: LD_VAR 0 1
53951: PPUSH
53952: CALL_OW 122
// result := tmp ;
53956: LD_ADDR_VAR 0 2
53960: PUSH
53961: LD_VAR 0 3
53965: ST_TO_ADDR
// end ;
53966: LD_VAR 0 2
53970: RET
// export function ResetHc ; begin
53971: LD_INT 0
53973: PPUSH
// InitHc ;
53974: CALL_OW 19
// hc_importance := 0 ;
53978: LD_ADDR_OWVAR 32
53982: PUSH
53983: LD_INT 0
53985: ST_TO_ADDR
// end ;
53986: LD_VAR 0 1
53990: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
53991: LD_INT 0
53993: PPUSH
53994: PPUSH
53995: PPUSH
// _x := ( x1 + x2 ) div 2 ;
53996: LD_ADDR_VAR 0 6
54000: PUSH
54001: LD_VAR 0 1
54005: PUSH
54006: LD_VAR 0 3
54010: PLUS
54011: PUSH
54012: LD_INT 2
54014: DIV
54015: ST_TO_ADDR
// if _x < 0 then
54016: LD_VAR 0 6
54020: PUSH
54021: LD_INT 0
54023: LESS
54024: IFFALSE 54041
// _x := _x * - 1 ;
54026: LD_ADDR_VAR 0 6
54030: PUSH
54031: LD_VAR 0 6
54035: PUSH
54036: LD_INT 1
54038: NEG
54039: MUL
54040: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
54041: LD_ADDR_VAR 0 7
54045: PUSH
54046: LD_VAR 0 2
54050: PUSH
54051: LD_VAR 0 4
54055: PLUS
54056: PUSH
54057: LD_INT 2
54059: DIV
54060: ST_TO_ADDR
// if _y < 0 then
54061: LD_VAR 0 7
54065: PUSH
54066: LD_INT 0
54068: LESS
54069: IFFALSE 54086
// _y := _y * - 1 ;
54071: LD_ADDR_VAR 0 7
54075: PUSH
54076: LD_VAR 0 7
54080: PUSH
54081: LD_INT 1
54083: NEG
54084: MUL
54085: ST_TO_ADDR
// result := [ _x , _y ] ;
54086: LD_ADDR_VAR 0 5
54090: PUSH
54091: LD_VAR 0 6
54095: PUSH
54096: LD_VAR 0 7
54100: PUSH
54101: EMPTY
54102: LIST
54103: LIST
54104: ST_TO_ADDR
// end ;
54105: LD_VAR 0 5
54109: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
54110: LD_INT 0
54112: PPUSH
54113: PPUSH
54114: PPUSH
54115: PPUSH
// task := GetTaskList ( unit ) ;
54116: LD_ADDR_VAR 0 7
54120: PUSH
54121: LD_VAR 0 1
54125: PPUSH
54126: CALL_OW 437
54130: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
54131: LD_VAR 0 7
54135: NOT
54136: PUSH
54137: LD_VAR 0 1
54141: PPUSH
54142: LD_VAR 0 2
54146: PPUSH
54147: CALL_OW 308
54151: NOT
54152: AND
54153: IFFALSE 54157
// exit ;
54155: GO 54275
// if IsInArea ( unit , area ) then
54157: LD_VAR 0 1
54161: PPUSH
54162: LD_VAR 0 2
54166: PPUSH
54167: CALL_OW 308
54171: IFFALSE 54189
// begin ComMoveToArea ( unit , goAway ) ;
54173: LD_VAR 0 1
54177: PPUSH
54178: LD_VAR 0 3
54182: PPUSH
54183: CALL_OW 113
// exit ;
54187: GO 54275
// end ; if task [ 1 ] [ 1 ] <> M then
54189: LD_VAR 0 7
54193: PUSH
54194: LD_INT 1
54196: ARRAY
54197: PUSH
54198: LD_INT 1
54200: ARRAY
54201: PUSH
54202: LD_STRING M
54204: NONEQUAL
54205: IFFALSE 54209
// exit ;
54207: GO 54275
// x := task [ 1 ] [ 2 ] ;
54209: LD_ADDR_VAR 0 5
54213: PUSH
54214: LD_VAR 0 7
54218: PUSH
54219: LD_INT 1
54221: ARRAY
54222: PUSH
54223: LD_INT 2
54225: ARRAY
54226: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
54227: LD_ADDR_VAR 0 6
54231: PUSH
54232: LD_VAR 0 7
54236: PUSH
54237: LD_INT 1
54239: ARRAY
54240: PUSH
54241: LD_INT 3
54243: ARRAY
54244: ST_TO_ADDR
// if InArea ( x , y , area ) then
54245: LD_VAR 0 5
54249: PPUSH
54250: LD_VAR 0 6
54254: PPUSH
54255: LD_VAR 0 2
54259: PPUSH
54260: CALL_OW 309
54264: IFFALSE 54275
// ComStop ( unit ) ;
54266: LD_VAR 0 1
54270: PPUSH
54271: CALL_OW 141
// end ;
54275: LD_VAR 0 4
54279: RET
// export function Abs ( value ) ; begin
54280: LD_INT 0
54282: PPUSH
// result := value ;
54283: LD_ADDR_VAR 0 2
54287: PUSH
54288: LD_VAR 0 1
54292: ST_TO_ADDR
// if value < 0 then
54293: LD_VAR 0 1
54297: PUSH
54298: LD_INT 0
54300: LESS
54301: IFFALSE 54318
// result := value * - 1 ;
54303: LD_ADDR_VAR 0 2
54307: PUSH
54308: LD_VAR 0 1
54312: PUSH
54313: LD_INT 1
54315: NEG
54316: MUL
54317: ST_TO_ADDR
// end ;
54318: LD_VAR 0 2
54322: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
54323: LD_INT 0
54325: PPUSH
54326: PPUSH
54327: PPUSH
54328: PPUSH
54329: PPUSH
54330: PPUSH
54331: PPUSH
54332: PPUSH
// if not unit or not building then
54333: LD_VAR 0 1
54337: NOT
54338: PUSH
54339: LD_VAR 0 2
54343: NOT
54344: OR
54345: IFFALSE 54349
// exit ;
54347: GO 54575
// x := GetX ( building ) ;
54349: LD_ADDR_VAR 0 4
54353: PUSH
54354: LD_VAR 0 2
54358: PPUSH
54359: CALL_OW 250
54363: ST_TO_ADDR
// y := GetY ( building ) ;
54364: LD_ADDR_VAR 0 6
54368: PUSH
54369: LD_VAR 0 2
54373: PPUSH
54374: CALL_OW 251
54378: ST_TO_ADDR
// d := GetDir ( building ) ;
54379: LD_ADDR_VAR 0 8
54383: PUSH
54384: LD_VAR 0 2
54388: PPUSH
54389: CALL_OW 254
54393: ST_TO_ADDR
// r := 4 ;
54394: LD_ADDR_VAR 0 9
54398: PUSH
54399: LD_INT 4
54401: ST_TO_ADDR
// for i := 1 to 5 do
54402: LD_ADDR_VAR 0 10
54406: PUSH
54407: DOUBLE
54408: LD_INT 1
54410: DEC
54411: ST_TO_ADDR
54412: LD_INT 5
54414: PUSH
54415: FOR_TO
54416: IFFALSE 54573
// begin _x := ShiftX ( x , d , r + i ) ;
54418: LD_ADDR_VAR 0 5
54422: PUSH
54423: LD_VAR 0 4
54427: PPUSH
54428: LD_VAR 0 8
54432: PPUSH
54433: LD_VAR 0 9
54437: PUSH
54438: LD_VAR 0 10
54442: PLUS
54443: PPUSH
54444: CALL_OW 272
54448: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
54449: LD_ADDR_VAR 0 7
54453: PUSH
54454: LD_VAR 0 6
54458: PPUSH
54459: LD_VAR 0 8
54463: PPUSH
54464: LD_VAR 0 9
54468: PUSH
54469: LD_VAR 0 10
54473: PLUS
54474: PPUSH
54475: CALL_OW 273
54479: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
54480: LD_VAR 0 5
54484: PPUSH
54485: LD_VAR 0 7
54489: PPUSH
54490: CALL_OW 488
54494: PUSH
54495: LD_VAR 0 5
54499: PPUSH
54500: LD_VAR 0 7
54504: PPUSH
54505: CALL_OW 428
54509: PPUSH
54510: CALL_OW 247
54514: PUSH
54515: LD_INT 3
54517: PUSH
54518: LD_INT 2
54520: PUSH
54521: EMPTY
54522: LIST
54523: LIST
54524: IN
54525: NOT
54526: AND
54527: IFFALSE 54571
// begin ComMoveXY ( unit , _x , _y ) ;
54529: LD_VAR 0 1
54533: PPUSH
54534: LD_VAR 0 5
54538: PPUSH
54539: LD_VAR 0 7
54543: PPUSH
54544: CALL_OW 111
// result := [ _x , _y ] ;
54548: LD_ADDR_VAR 0 3
54552: PUSH
54553: LD_VAR 0 5
54557: PUSH
54558: LD_VAR 0 7
54562: PUSH
54563: EMPTY
54564: LIST
54565: LIST
54566: ST_TO_ADDR
// exit ;
54567: POP
54568: POP
54569: GO 54575
// end ; end ;
54571: GO 54415
54573: POP
54574: POP
// end ; end_of_file
54575: LD_VAR 0 3
54579: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
54580: LD_INT 0
54582: PPUSH
54583: PPUSH
54584: PPUSH
54585: PPUSH
54586: PPUSH
54587: PPUSH
54588: PPUSH
54589: PPUSH
54590: PPUSH
54591: PPUSH
54592: PPUSH
54593: PPUSH
54594: PPUSH
54595: PPUSH
54596: PPUSH
54597: PPUSH
54598: PPUSH
54599: PPUSH
54600: PPUSH
54601: PPUSH
54602: PPUSH
54603: PPUSH
54604: PPUSH
54605: PPUSH
54606: PPUSH
54607: PPUSH
54608: PPUSH
54609: PPUSH
54610: PPUSH
54611: PPUSH
54612: PPUSH
54613: PPUSH
54614: PPUSH
54615: PPUSH
// if not list then
54616: LD_VAR 0 1
54620: NOT
54621: IFFALSE 54625
// exit ;
54623: GO 59284
// base := list [ 1 ] ;
54625: LD_ADDR_VAR 0 3
54629: PUSH
54630: LD_VAR 0 1
54634: PUSH
54635: LD_INT 1
54637: ARRAY
54638: ST_TO_ADDR
// group := list [ 2 ] ;
54639: LD_ADDR_VAR 0 4
54643: PUSH
54644: LD_VAR 0 1
54648: PUSH
54649: LD_INT 2
54651: ARRAY
54652: ST_TO_ADDR
// path := list [ 3 ] ;
54653: LD_ADDR_VAR 0 5
54657: PUSH
54658: LD_VAR 0 1
54662: PUSH
54663: LD_INT 3
54665: ARRAY
54666: ST_TO_ADDR
// flags := list [ 4 ] ;
54667: LD_ADDR_VAR 0 6
54671: PUSH
54672: LD_VAR 0 1
54676: PUSH
54677: LD_INT 4
54679: ARRAY
54680: ST_TO_ADDR
// mined := [ ] ;
54681: LD_ADDR_VAR 0 27
54685: PUSH
54686: EMPTY
54687: ST_TO_ADDR
// bombed := [ ] ;
54688: LD_ADDR_VAR 0 28
54692: PUSH
54693: EMPTY
54694: ST_TO_ADDR
// healers := [ ] ;
54695: LD_ADDR_VAR 0 31
54699: PUSH
54700: EMPTY
54701: ST_TO_ADDR
// to_heal := [ ] ;
54702: LD_ADDR_VAR 0 30
54706: PUSH
54707: EMPTY
54708: ST_TO_ADDR
// repairs := [ ] ;
54709: LD_ADDR_VAR 0 33
54713: PUSH
54714: EMPTY
54715: ST_TO_ADDR
// to_repair := [ ] ;
54716: LD_ADDR_VAR 0 32
54720: PUSH
54721: EMPTY
54722: ST_TO_ADDR
// if not group or not path then
54723: LD_VAR 0 4
54727: NOT
54728: PUSH
54729: LD_VAR 0 5
54733: NOT
54734: OR
54735: IFFALSE 54739
// exit ;
54737: GO 59284
// side := GetSide ( group [ 1 ] ) ;
54739: LD_ADDR_VAR 0 35
54743: PUSH
54744: LD_VAR 0 4
54748: PUSH
54749: LD_INT 1
54751: ARRAY
54752: PPUSH
54753: CALL_OW 255
54757: ST_TO_ADDR
// if flags then
54758: LD_VAR 0 6
54762: IFFALSE 54906
// begin f_ignore_area := flags [ 1 ] ;
54764: LD_ADDR_VAR 0 17
54768: PUSH
54769: LD_VAR 0 6
54773: PUSH
54774: LD_INT 1
54776: ARRAY
54777: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
54778: LD_ADDR_VAR 0 18
54782: PUSH
54783: LD_VAR 0 6
54787: PUSH
54788: LD_INT 2
54790: ARRAY
54791: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
54792: LD_ADDR_VAR 0 19
54796: PUSH
54797: LD_VAR 0 6
54801: PUSH
54802: LD_INT 3
54804: ARRAY
54805: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
54806: LD_ADDR_VAR 0 20
54810: PUSH
54811: LD_VAR 0 6
54815: PUSH
54816: LD_INT 4
54818: ARRAY
54819: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
54820: LD_ADDR_VAR 0 21
54824: PUSH
54825: LD_VAR 0 6
54829: PUSH
54830: LD_INT 5
54832: ARRAY
54833: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
54834: LD_ADDR_VAR 0 22
54838: PUSH
54839: LD_VAR 0 6
54843: PUSH
54844: LD_INT 6
54846: ARRAY
54847: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
54848: LD_ADDR_VAR 0 23
54852: PUSH
54853: LD_VAR 0 6
54857: PUSH
54858: LD_INT 7
54860: ARRAY
54861: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
54862: LD_ADDR_VAR 0 24
54866: PUSH
54867: LD_VAR 0 6
54871: PUSH
54872: LD_INT 8
54874: ARRAY
54875: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
54876: LD_ADDR_VAR 0 25
54880: PUSH
54881: LD_VAR 0 6
54885: PUSH
54886: LD_INT 9
54888: ARRAY
54889: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
54890: LD_ADDR_VAR 0 26
54894: PUSH
54895: LD_VAR 0 6
54899: PUSH
54900: LD_INT 10
54902: ARRAY
54903: ST_TO_ADDR
// end else
54904: GO 54986
// begin f_ignore_area := false ;
54906: LD_ADDR_VAR 0 17
54910: PUSH
54911: LD_INT 0
54913: ST_TO_ADDR
// f_capture := false ;
54914: LD_ADDR_VAR 0 18
54918: PUSH
54919: LD_INT 0
54921: ST_TO_ADDR
// f_ignore_civ := false ;
54922: LD_ADDR_VAR 0 19
54926: PUSH
54927: LD_INT 0
54929: ST_TO_ADDR
// f_murder := false ;
54930: LD_ADDR_VAR 0 20
54934: PUSH
54935: LD_INT 0
54937: ST_TO_ADDR
// f_mines := false ;
54938: LD_ADDR_VAR 0 21
54942: PUSH
54943: LD_INT 0
54945: ST_TO_ADDR
// f_repair := false ;
54946: LD_ADDR_VAR 0 22
54950: PUSH
54951: LD_INT 0
54953: ST_TO_ADDR
// f_heal := false ;
54954: LD_ADDR_VAR 0 23
54958: PUSH
54959: LD_INT 0
54961: ST_TO_ADDR
// f_spacetime := false ;
54962: LD_ADDR_VAR 0 24
54966: PUSH
54967: LD_INT 0
54969: ST_TO_ADDR
// f_attack_depot := false ;
54970: LD_ADDR_VAR 0 25
54974: PUSH
54975: LD_INT 0
54977: ST_TO_ADDR
// f_crawl := false ;
54978: LD_ADDR_VAR 0 26
54982: PUSH
54983: LD_INT 0
54985: ST_TO_ADDR
// end ; if f_heal then
54986: LD_VAR 0 23
54990: IFFALSE 55017
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
54992: LD_ADDR_VAR 0 31
54996: PUSH
54997: LD_VAR 0 4
55001: PPUSH
55002: LD_INT 25
55004: PUSH
55005: LD_INT 4
55007: PUSH
55008: EMPTY
55009: LIST
55010: LIST
55011: PPUSH
55012: CALL_OW 72
55016: ST_TO_ADDR
// if f_repair then
55017: LD_VAR 0 22
55021: IFFALSE 55048
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
55023: LD_ADDR_VAR 0 33
55027: PUSH
55028: LD_VAR 0 4
55032: PPUSH
55033: LD_INT 25
55035: PUSH
55036: LD_INT 3
55038: PUSH
55039: EMPTY
55040: LIST
55041: LIST
55042: PPUSH
55043: CALL_OW 72
55047: ST_TO_ADDR
// units_path := [ ] ;
55048: LD_ADDR_VAR 0 16
55052: PUSH
55053: EMPTY
55054: ST_TO_ADDR
// for i = 1 to group do
55055: LD_ADDR_VAR 0 7
55059: PUSH
55060: DOUBLE
55061: LD_INT 1
55063: DEC
55064: ST_TO_ADDR
55065: LD_VAR 0 4
55069: PUSH
55070: FOR_TO
55071: IFFALSE 55100
// units_path := Replace ( units_path , i , path ) ;
55073: LD_ADDR_VAR 0 16
55077: PUSH
55078: LD_VAR 0 16
55082: PPUSH
55083: LD_VAR 0 7
55087: PPUSH
55088: LD_VAR 0 5
55092: PPUSH
55093: CALL_OW 1
55097: ST_TO_ADDR
55098: GO 55070
55100: POP
55101: POP
// repeat for i = group downto 1 do
55102: LD_ADDR_VAR 0 7
55106: PUSH
55107: DOUBLE
55108: LD_VAR 0 4
55112: INC
55113: ST_TO_ADDR
55114: LD_INT 1
55116: PUSH
55117: FOR_DOWNTO
55118: IFFALSE 59240
// begin wait ( 5 ) ;
55120: LD_INT 5
55122: PPUSH
55123: CALL_OW 67
// tmp := [ ] ;
55127: LD_ADDR_VAR 0 14
55131: PUSH
55132: EMPTY
55133: ST_TO_ADDR
// attacking := false ;
55134: LD_ADDR_VAR 0 29
55138: PUSH
55139: LD_INT 0
55141: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
55142: LD_VAR 0 4
55146: PUSH
55147: LD_VAR 0 7
55151: ARRAY
55152: PPUSH
55153: CALL_OW 301
55157: PUSH
55158: LD_VAR 0 4
55162: PUSH
55163: LD_VAR 0 7
55167: ARRAY
55168: NOT
55169: OR
55170: IFFALSE 55279
// begin if GetType ( group [ i ] ) = unit_human then
55172: LD_VAR 0 4
55176: PUSH
55177: LD_VAR 0 7
55181: ARRAY
55182: PPUSH
55183: CALL_OW 247
55187: PUSH
55188: LD_INT 1
55190: EQUAL
55191: IFFALSE 55237
// begin to_heal := to_heal diff group [ i ] ;
55193: LD_ADDR_VAR 0 30
55197: PUSH
55198: LD_VAR 0 30
55202: PUSH
55203: LD_VAR 0 4
55207: PUSH
55208: LD_VAR 0 7
55212: ARRAY
55213: DIFF
55214: ST_TO_ADDR
// healers := healers diff group [ i ] ;
55215: LD_ADDR_VAR 0 31
55219: PUSH
55220: LD_VAR 0 31
55224: PUSH
55225: LD_VAR 0 4
55229: PUSH
55230: LD_VAR 0 7
55234: ARRAY
55235: DIFF
55236: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
55237: LD_ADDR_VAR 0 4
55241: PUSH
55242: LD_VAR 0 4
55246: PPUSH
55247: LD_VAR 0 7
55251: PPUSH
55252: CALL_OW 3
55256: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
55257: LD_ADDR_VAR 0 16
55261: PUSH
55262: LD_VAR 0 16
55266: PPUSH
55267: LD_VAR 0 7
55271: PPUSH
55272: CALL_OW 3
55276: ST_TO_ADDR
// continue ;
55277: GO 55117
// end ; if f_repair then
55279: LD_VAR 0 22
55283: IFFALSE 55772
// begin if GetType ( group [ i ] ) = unit_vehicle then
55285: LD_VAR 0 4
55289: PUSH
55290: LD_VAR 0 7
55294: ARRAY
55295: PPUSH
55296: CALL_OW 247
55300: PUSH
55301: LD_INT 2
55303: EQUAL
55304: IFFALSE 55494
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
55306: LD_VAR 0 4
55310: PUSH
55311: LD_VAR 0 7
55315: ARRAY
55316: PPUSH
55317: CALL_OW 256
55321: PUSH
55322: LD_INT 700
55324: LESS
55325: PUSH
55326: LD_VAR 0 4
55330: PUSH
55331: LD_VAR 0 7
55335: ARRAY
55336: PUSH
55337: LD_VAR 0 32
55341: IN
55342: NOT
55343: AND
55344: IFFALSE 55368
// to_repair := to_repair union group [ i ] ;
55346: LD_ADDR_VAR 0 32
55350: PUSH
55351: LD_VAR 0 32
55355: PUSH
55356: LD_VAR 0 4
55360: PUSH
55361: LD_VAR 0 7
55365: ARRAY
55366: UNION
55367: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
55368: LD_VAR 0 4
55372: PUSH
55373: LD_VAR 0 7
55377: ARRAY
55378: PPUSH
55379: CALL_OW 256
55383: PUSH
55384: LD_INT 1000
55386: EQUAL
55387: PUSH
55388: LD_VAR 0 4
55392: PUSH
55393: LD_VAR 0 7
55397: ARRAY
55398: PUSH
55399: LD_VAR 0 32
55403: IN
55404: AND
55405: IFFALSE 55429
// to_repair := to_repair diff group [ i ] ;
55407: LD_ADDR_VAR 0 32
55411: PUSH
55412: LD_VAR 0 32
55416: PUSH
55417: LD_VAR 0 4
55421: PUSH
55422: LD_VAR 0 7
55426: ARRAY
55427: DIFF
55428: ST_TO_ADDR
// if group [ i ] in to_repair then
55429: LD_VAR 0 4
55433: PUSH
55434: LD_VAR 0 7
55438: ARRAY
55439: PUSH
55440: LD_VAR 0 32
55444: IN
55445: IFFALSE 55492
// begin if not IsInArea ( group [ i ] , f_repair ) then
55447: LD_VAR 0 4
55451: PUSH
55452: LD_VAR 0 7
55456: ARRAY
55457: PPUSH
55458: LD_VAR 0 22
55462: PPUSH
55463: CALL_OW 308
55467: NOT
55468: IFFALSE 55490
// ComMoveToArea ( group [ i ] , f_repair ) ;
55470: LD_VAR 0 4
55474: PUSH
55475: LD_VAR 0 7
55479: ARRAY
55480: PPUSH
55481: LD_VAR 0 22
55485: PPUSH
55486: CALL_OW 113
// continue ;
55490: GO 55117
// end ; end else
55492: GO 55772
// if group [ i ] in repairs then
55494: LD_VAR 0 4
55498: PUSH
55499: LD_VAR 0 7
55503: ARRAY
55504: PUSH
55505: LD_VAR 0 33
55509: IN
55510: IFFALSE 55772
// begin if IsInUnit ( group [ i ] ) then
55512: LD_VAR 0 4
55516: PUSH
55517: LD_VAR 0 7
55521: ARRAY
55522: PPUSH
55523: CALL_OW 310
55527: IFFALSE 55595
// begin z := IsInUnit ( group [ i ] ) ;
55529: LD_ADDR_VAR 0 13
55533: PUSH
55534: LD_VAR 0 4
55538: PUSH
55539: LD_VAR 0 7
55543: ARRAY
55544: PPUSH
55545: CALL_OW 310
55549: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
55550: LD_VAR 0 13
55554: PUSH
55555: LD_VAR 0 32
55559: IN
55560: PUSH
55561: LD_VAR 0 13
55565: PPUSH
55566: LD_VAR 0 22
55570: PPUSH
55571: CALL_OW 308
55575: AND
55576: IFFALSE 55593
// ComExitVehicle ( group [ i ] ) ;
55578: LD_VAR 0 4
55582: PUSH
55583: LD_VAR 0 7
55587: ARRAY
55588: PPUSH
55589: CALL_OW 121
// end else
55593: GO 55772
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
55595: LD_ADDR_VAR 0 13
55599: PUSH
55600: LD_VAR 0 4
55604: PPUSH
55605: LD_INT 95
55607: PUSH
55608: LD_VAR 0 22
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: PUSH
55617: LD_INT 58
55619: PUSH
55620: EMPTY
55621: LIST
55622: PUSH
55623: EMPTY
55624: LIST
55625: LIST
55626: PPUSH
55627: CALL_OW 72
55631: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
55632: LD_VAR 0 4
55636: PUSH
55637: LD_VAR 0 7
55641: ARRAY
55642: PPUSH
55643: CALL_OW 314
55647: NOT
55648: IFFALSE 55770
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
55650: LD_ADDR_VAR 0 10
55654: PUSH
55655: LD_VAR 0 13
55659: PPUSH
55660: LD_VAR 0 4
55664: PUSH
55665: LD_VAR 0 7
55669: ARRAY
55670: PPUSH
55671: CALL_OW 74
55675: ST_TO_ADDR
// if not x then
55676: LD_VAR 0 10
55680: NOT
55681: IFFALSE 55685
// continue ;
55683: GO 55117
// if GetLives ( x ) < 1000 then
55685: LD_VAR 0 10
55689: PPUSH
55690: CALL_OW 256
55694: PUSH
55695: LD_INT 1000
55697: LESS
55698: IFFALSE 55722
// ComRepairVehicle ( group [ i ] , x ) else
55700: LD_VAR 0 4
55704: PUSH
55705: LD_VAR 0 7
55709: ARRAY
55710: PPUSH
55711: LD_VAR 0 10
55715: PPUSH
55716: CALL_OW 129
55720: GO 55770
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
55722: LD_VAR 0 23
55726: PUSH
55727: LD_VAR 0 4
55731: PUSH
55732: LD_VAR 0 7
55736: ARRAY
55737: PPUSH
55738: CALL_OW 256
55742: PUSH
55743: LD_INT 1000
55745: LESS
55746: AND
55747: NOT
55748: IFFALSE 55770
// ComEnterUnit ( group [ i ] , x ) ;
55750: LD_VAR 0 4
55754: PUSH
55755: LD_VAR 0 7
55759: ARRAY
55760: PPUSH
55761: LD_VAR 0 10
55765: PPUSH
55766: CALL_OW 120
// end ; continue ;
55770: GO 55117
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
55772: LD_VAR 0 23
55776: PUSH
55777: LD_VAR 0 4
55781: PUSH
55782: LD_VAR 0 7
55786: ARRAY
55787: PPUSH
55788: CALL_OW 247
55792: PUSH
55793: LD_INT 1
55795: EQUAL
55796: AND
55797: IFFALSE 56275
// begin if group [ i ] in healers then
55799: LD_VAR 0 4
55803: PUSH
55804: LD_VAR 0 7
55808: ARRAY
55809: PUSH
55810: LD_VAR 0 31
55814: IN
55815: IFFALSE 56088
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
55817: LD_VAR 0 4
55821: PUSH
55822: LD_VAR 0 7
55826: ARRAY
55827: PPUSH
55828: LD_VAR 0 23
55832: PPUSH
55833: CALL_OW 308
55837: NOT
55838: PUSH
55839: LD_VAR 0 4
55843: PUSH
55844: LD_VAR 0 7
55848: ARRAY
55849: PPUSH
55850: CALL_OW 314
55854: NOT
55855: AND
55856: IFFALSE 55880
// ComMoveToArea ( group [ i ] , f_heal ) else
55858: LD_VAR 0 4
55862: PUSH
55863: LD_VAR 0 7
55867: ARRAY
55868: PPUSH
55869: LD_VAR 0 23
55873: PPUSH
55874: CALL_OW 113
55878: GO 56086
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
55880: LD_VAR 0 4
55884: PUSH
55885: LD_VAR 0 7
55889: ARRAY
55890: PPUSH
55891: CALL 50829 0 1
55895: PPUSH
55896: CALL_OW 256
55900: PUSH
55901: LD_INT 1000
55903: EQUAL
55904: IFFALSE 55923
// ComStop ( group [ i ] ) else
55906: LD_VAR 0 4
55910: PUSH
55911: LD_VAR 0 7
55915: ARRAY
55916: PPUSH
55917: CALL_OW 141
55921: GO 56086
// if not HasTask ( group [ i ] ) and to_heal then
55923: LD_VAR 0 4
55927: PUSH
55928: LD_VAR 0 7
55932: ARRAY
55933: PPUSH
55934: CALL_OW 314
55938: NOT
55939: PUSH
55940: LD_VAR 0 30
55944: AND
55945: IFFALSE 56086
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
55947: LD_ADDR_VAR 0 13
55951: PUSH
55952: LD_VAR 0 30
55956: PPUSH
55957: LD_INT 3
55959: PUSH
55960: LD_INT 54
55962: PUSH
55963: EMPTY
55964: LIST
55965: PUSH
55966: EMPTY
55967: LIST
55968: LIST
55969: PPUSH
55970: CALL_OW 72
55974: PPUSH
55975: LD_VAR 0 4
55979: PUSH
55980: LD_VAR 0 7
55984: ARRAY
55985: PPUSH
55986: CALL_OW 74
55990: ST_TO_ADDR
// if z then
55991: LD_VAR 0 13
55995: IFFALSE 56086
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
55997: LD_INT 91
55999: PUSH
56000: LD_VAR 0 13
56004: PUSH
56005: LD_INT 10
56007: PUSH
56008: EMPTY
56009: LIST
56010: LIST
56011: LIST
56012: PUSH
56013: LD_INT 81
56015: PUSH
56016: LD_VAR 0 13
56020: PPUSH
56021: CALL_OW 255
56025: PUSH
56026: EMPTY
56027: LIST
56028: LIST
56029: PUSH
56030: EMPTY
56031: LIST
56032: LIST
56033: PPUSH
56034: CALL_OW 69
56038: PUSH
56039: LD_INT 0
56041: EQUAL
56042: IFFALSE 56066
// ComHeal ( group [ i ] , z ) else
56044: LD_VAR 0 4
56048: PUSH
56049: LD_VAR 0 7
56053: ARRAY
56054: PPUSH
56055: LD_VAR 0 13
56059: PPUSH
56060: CALL_OW 128
56064: GO 56086
// ComMoveToArea ( group [ i ] , f_heal ) ;
56066: LD_VAR 0 4
56070: PUSH
56071: LD_VAR 0 7
56075: ARRAY
56076: PPUSH
56077: LD_VAR 0 23
56081: PPUSH
56082: CALL_OW 113
// end ; continue ;
56086: GO 55117
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
56088: LD_VAR 0 4
56092: PUSH
56093: LD_VAR 0 7
56097: ARRAY
56098: PPUSH
56099: CALL_OW 256
56103: PUSH
56104: LD_INT 700
56106: LESS
56107: PUSH
56108: LD_VAR 0 4
56112: PUSH
56113: LD_VAR 0 7
56117: ARRAY
56118: PUSH
56119: LD_VAR 0 30
56123: IN
56124: NOT
56125: AND
56126: IFFALSE 56150
// to_heal := to_heal union group [ i ] ;
56128: LD_ADDR_VAR 0 30
56132: PUSH
56133: LD_VAR 0 30
56137: PUSH
56138: LD_VAR 0 4
56142: PUSH
56143: LD_VAR 0 7
56147: ARRAY
56148: UNION
56149: ST_TO_ADDR
// if group [ i ] in to_heal then
56150: LD_VAR 0 4
56154: PUSH
56155: LD_VAR 0 7
56159: ARRAY
56160: PUSH
56161: LD_VAR 0 30
56165: IN
56166: IFFALSE 56275
// begin if GetLives ( group [ i ] ) = 1000 then
56168: LD_VAR 0 4
56172: PUSH
56173: LD_VAR 0 7
56177: ARRAY
56178: PPUSH
56179: CALL_OW 256
56183: PUSH
56184: LD_INT 1000
56186: EQUAL
56187: IFFALSE 56213
// to_heal := to_heal diff group [ i ] else
56189: LD_ADDR_VAR 0 30
56193: PUSH
56194: LD_VAR 0 30
56198: PUSH
56199: LD_VAR 0 4
56203: PUSH
56204: LD_VAR 0 7
56208: ARRAY
56209: DIFF
56210: ST_TO_ADDR
56211: GO 56275
// begin if not IsInArea ( group [ i ] , to_heal ) then
56213: LD_VAR 0 4
56217: PUSH
56218: LD_VAR 0 7
56222: ARRAY
56223: PPUSH
56224: LD_VAR 0 30
56228: PPUSH
56229: CALL_OW 308
56233: NOT
56234: IFFALSE 56258
// ComMoveToArea ( group [ i ] , f_heal ) else
56236: LD_VAR 0 4
56240: PUSH
56241: LD_VAR 0 7
56245: ARRAY
56246: PPUSH
56247: LD_VAR 0 23
56251: PPUSH
56252: CALL_OW 113
56256: GO 56273
// ComHold ( group [ i ] ) ;
56258: LD_VAR 0 4
56262: PUSH
56263: LD_VAR 0 7
56267: ARRAY
56268: PPUSH
56269: CALL_OW 140
// continue ;
56273: GO 55117
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
56275: LD_VAR 0 4
56279: PUSH
56280: LD_VAR 0 7
56284: ARRAY
56285: PPUSH
56286: LD_INT 10
56288: PPUSH
56289: CALL 49249 0 2
56293: NOT
56294: PUSH
56295: LD_VAR 0 16
56299: PUSH
56300: LD_VAR 0 7
56304: ARRAY
56305: PUSH
56306: EMPTY
56307: EQUAL
56308: NOT
56309: AND
56310: IFFALSE 56576
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
56312: LD_VAR 0 4
56316: PUSH
56317: LD_VAR 0 7
56321: ARRAY
56322: PPUSH
56323: CALL_OW 262
56327: PUSH
56328: LD_INT 1
56330: PUSH
56331: LD_INT 2
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: IN
56338: IFFALSE 56379
// if GetFuel ( group [ i ] ) < 10 then
56340: LD_VAR 0 4
56344: PUSH
56345: LD_VAR 0 7
56349: ARRAY
56350: PPUSH
56351: CALL_OW 261
56355: PUSH
56356: LD_INT 10
56358: LESS
56359: IFFALSE 56379
// SetFuel ( group [ i ] , 12 ) ;
56361: LD_VAR 0 4
56365: PUSH
56366: LD_VAR 0 7
56370: ARRAY
56371: PPUSH
56372: LD_INT 12
56374: PPUSH
56375: CALL_OW 240
// if units_path [ i ] then
56379: LD_VAR 0 16
56383: PUSH
56384: LD_VAR 0 7
56388: ARRAY
56389: IFFALSE 56574
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
56391: LD_VAR 0 4
56395: PUSH
56396: LD_VAR 0 7
56400: ARRAY
56401: PPUSH
56402: LD_VAR 0 16
56406: PUSH
56407: LD_VAR 0 7
56411: ARRAY
56412: PUSH
56413: LD_INT 1
56415: ARRAY
56416: PUSH
56417: LD_INT 1
56419: ARRAY
56420: PPUSH
56421: LD_VAR 0 16
56425: PUSH
56426: LD_VAR 0 7
56430: ARRAY
56431: PUSH
56432: LD_INT 1
56434: ARRAY
56435: PUSH
56436: LD_INT 2
56438: ARRAY
56439: PPUSH
56440: CALL_OW 297
56444: PUSH
56445: LD_INT 6
56447: GREATER
56448: IFFALSE 56523
// begin if not HasTask ( group [ i ] ) then
56450: LD_VAR 0 4
56454: PUSH
56455: LD_VAR 0 7
56459: ARRAY
56460: PPUSH
56461: CALL_OW 314
56465: NOT
56466: IFFALSE 56521
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
56468: LD_VAR 0 4
56472: PUSH
56473: LD_VAR 0 7
56477: ARRAY
56478: PPUSH
56479: LD_VAR 0 16
56483: PUSH
56484: LD_VAR 0 7
56488: ARRAY
56489: PUSH
56490: LD_INT 1
56492: ARRAY
56493: PUSH
56494: LD_INT 1
56496: ARRAY
56497: PPUSH
56498: LD_VAR 0 16
56502: PUSH
56503: LD_VAR 0 7
56507: ARRAY
56508: PUSH
56509: LD_INT 1
56511: ARRAY
56512: PUSH
56513: LD_INT 2
56515: ARRAY
56516: PPUSH
56517: CALL_OW 114
// end else
56521: GO 56574
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
56523: LD_ADDR_VAR 0 15
56527: PUSH
56528: LD_VAR 0 16
56532: PUSH
56533: LD_VAR 0 7
56537: ARRAY
56538: PPUSH
56539: LD_INT 1
56541: PPUSH
56542: CALL_OW 3
56546: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
56547: LD_ADDR_VAR 0 16
56551: PUSH
56552: LD_VAR 0 16
56556: PPUSH
56557: LD_VAR 0 7
56561: PPUSH
56562: LD_VAR 0 15
56566: PPUSH
56567: CALL_OW 1
56571: ST_TO_ADDR
// continue ;
56572: GO 55117
// end ; end ; end else
56574: GO 59238
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
56576: LD_ADDR_VAR 0 14
56580: PUSH
56581: LD_INT 81
56583: PUSH
56584: LD_VAR 0 4
56588: PUSH
56589: LD_VAR 0 7
56593: ARRAY
56594: PPUSH
56595: CALL_OW 255
56599: PUSH
56600: EMPTY
56601: LIST
56602: LIST
56603: PPUSH
56604: CALL_OW 69
56608: ST_TO_ADDR
// if not tmp then
56609: LD_VAR 0 14
56613: NOT
56614: IFFALSE 56618
// continue ;
56616: GO 55117
// if f_ignore_area then
56618: LD_VAR 0 17
56622: IFFALSE 56710
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
56624: LD_ADDR_VAR 0 15
56628: PUSH
56629: LD_VAR 0 14
56633: PPUSH
56634: LD_INT 3
56636: PUSH
56637: LD_INT 92
56639: PUSH
56640: LD_VAR 0 17
56644: PUSH
56645: LD_INT 1
56647: ARRAY
56648: PUSH
56649: LD_VAR 0 17
56653: PUSH
56654: LD_INT 2
56656: ARRAY
56657: PUSH
56658: LD_VAR 0 17
56662: PUSH
56663: LD_INT 3
56665: ARRAY
56666: PUSH
56667: EMPTY
56668: LIST
56669: LIST
56670: LIST
56671: LIST
56672: PUSH
56673: EMPTY
56674: LIST
56675: LIST
56676: PPUSH
56677: CALL_OW 72
56681: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
56682: LD_VAR 0 14
56686: PUSH
56687: LD_VAR 0 15
56691: DIFF
56692: IFFALSE 56710
// tmp := tmp diff tmp2 ;
56694: LD_ADDR_VAR 0 14
56698: PUSH
56699: LD_VAR 0 14
56703: PUSH
56704: LD_VAR 0 15
56708: DIFF
56709: ST_TO_ADDR
// end ; if not f_murder then
56710: LD_VAR 0 20
56714: NOT
56715: IFFALSE 56773
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
56717: LD_ADDR_VAR 0 15
56721: PUSH
56722: LD_VAR 0 14
56726: PPUSH
56727: LD_INT 3
56729: PUSH
56730: LD_INT 50
56732: PUSH
56733: EMPTY
56734: LIST
56735: PUSH
56736: EMPTY
56737: LIST
56738: LIST
56739: PPUSH
56740: CALL_OW 72
56744: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
56745: LD_VAR 0 14
56749: PUSH
56750: LD_VAR 0 15
56754: DIFF
56755: IFFALSE 56773
// tmp := tmp diff tmp2 ;
56757: LD_ADDR_VAR 0 14
56761: PUSH
56762: LD_VAR 0 14
56766: PUSH
56767: LD_VAR 0 15
56771: DIFF
56772: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
56773: LD_ADDR_VAR 0 14
56777: PUSH
56778: LD_VAR 0 4
56782: PUSH
56783: LD_VAR 0 7
56787: ARRAY
56788: PPUSH
56789: LD_VAR 0 14
56793: PPUSH
56794: LD_INT 1
56796: PPUSH
56797: LD_INT 1
56799: PPUSH
56800: CALL 22892 0 4
56804: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
56805: LD_VAR 0 4
56809: PUSH
56810: LD_VAR 0 7
56814: ARRAY
56815: PPUSH
56816: CALL_OW 257
56820: PUSH
56821: LD_INT 1
56823: EQUAL
56824: IFFALSE 57272
// begin if WantPlant ( group [ i ] ) then
56826: LD_VAR 0 4
56830: PUSH
56831: LD_VAR 0 7
56835: ARRAY
56836: PPUSH
56837: CALL 22393 0 1
56841: IFFALSE 56845
// continue ;
56843: GO 55117
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
56845: LD_VAR 0 18
56849: PUSH
56850: LD_VAR 0 4
56854: PUSH
56855: LD_VAR 0 7
56859: ARRAY
56860: PPUSH
56861: CALL_OW 310
56865: NOT
56866: AND
56867: PUSH
56868: LD_VAR 0 14
56872: PUSH
56873: LD_INT 1
56875: ARRAY
56876: PUSH
56877: LD_VAR 0 14
56881: PPUSH
56882: LD_INT 21
56884: PUSH
56885: LD_INT 2
56887: PUSH
56888: EMPTY
56889: LIST
56890: LIST
56891: PUSH
56892: LD_INT 58
56894: PUSH
56895: EMPTY
56896: LIST
56897: PUSH
56898: EMPTY
56899: LIST
56900: LIST
56901: PPUSH
56902: CALL_OW 72
56906: IN
56907: AND
56908: IFFALSE 56944
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
56910: LD_VAR 0 4
56914: PUSH
56915: LD_VAR 0 7
56919: ARRAY
56920: PPUSH
56921: LD_VAR 0 14
56925: PUSH
56926: LD_INT 1
56928: ARRAY
56929: PPUSH
56930: CALL_OW 120
// attacking := true ;
56934: LD_ADDR_VAR 0 29
56938: PUSH
56939: LD_INT 1
56941: ST_TO_ADDR
// continue ;
56942: GO 55117
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
56944: LD_VAR 0 26
56948: PUSH
56949: LD_VAR 0 4
56953: PUSH
56954: LD_VAR 0 7
56958: ARRAY
56959: PPUSH
56960: CALL_OW 257
56964: PUSH
56965: LD_INT 1
56967: EQUAL
56968: AND
56969: PUSH
56970: LD_VAR 0 4
56974: PUSH
56975: LD_VAR 0 7
56979: ARRAY
56980: PPUSH
56981: CALL_OW 256
56985: PUSH
56986: LD_INT 800
56988: LESS
56989: AND
56990: PUSH
56991: LD_VAR 0 4
56995: PUSH
56996: LD_VAR 0 7
57000: ARRAY
57001: PPUSH
57002: CALL_OW 318
57006: NOT
57007: AND
57008: IFFALSE 57025
// ComCrawl ( group [ i ] ) ;
57010: LD_VAR 0 4
57014: PUSH
57015: LD_VAR 0 7
57019: ARRAY
57020: PPUSH
57021: CALL_OW 137
// if f_mines then
57025: LD_VAR 0 21
57029: IFFALSE 57272
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
57031: LD_VAR 0 14
57035: PUSH
57036: LD_INT 1
57038: ARRAY
57039: PPUSH
57040: CALL_OW 247
57044: PUSH
57045: LD_INT 3
57047: EQUAL
57048: PUSH
57049: LD_VAR 0 14
57053: PUSH
57054: LD_INT 1
57056: ARRAY
57057: PUSH
57058: LD_VAR 0 27
57062: IN
57063: NOT
57064: AND
57065: IFFALSE 57272
// begin x := GetX ( tmp [ 1 ] ) ;
57067: LD_ADDR_VAR 0 10
57071: PUSH
57072: LD_VAR 0 14
57076: PUSH
57077: LD_INT 1
57079: ARRAY
57080: PPUSH
57081: CALL_OW 250
57085: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
57086: LD_ADDR_VAR 0 11
57090: PUSH
57091: LD_VAR 0 14
57095: PUSH
57096: LD_INT 1
57098: ARRAY
57099: PPUSH
57100: CALL_OW 251
57104: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
57105: LD_ADDR_VAR 0 12
57109: PUSH
57110: LD_VAR 0 4
57114: PUSH
57115: LD_VAR 0 7
57119: ARRAY
57120: PPUSH
57121: CALL 49334 0 1
57125: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
57126: LD_VAR 0 4
57130: PUSH
57131: LD_VAR 0 7
57135: ARRAY
57136: PPUSH
57137: LD_VAR 0 10
57141: PPUSH
57142: LD_VAR 0 11
57146: PPUSH
57147: LD_VAR 0 14
57151: PUSH
57152: LD_INT 1
57154: ARRAY
57155: PPUSH
57156: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
57160: LD_VAR 0 4
57164: PUSH
57165: LD_VAR 0 7
57169: ARRAY
57170: PPUSH
57171: LD_VAR 0 10
57175: PPUSH
57176: LD_VAR 0 12
57180: PPUSH
57181: LD_INT 7
57183: PPUSH
57184: CALL_OW 272
57188: PPUSH
57189: LD_VAR 0 11
57193: PPUSH
57194: LD_VAR 0 12
57198: PPUSH
57199: LD_INT 7
57201: PPUSH
57202: CALL_OW 273
57206: PPUSH
57207: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
57211: LD_VAR 0 4
57215: PUSH
57216: LD_VAR 0 7
57220: ARRAY
57221: PPUSH
57222: LD_INT 71
57224: PPUSH
57225: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
57229: LD_ADDR_VAR 0 27
57233: PUSH
57234: LD_VAR 0 27
57238: PPUSH
57239: LD_VAR 0 27
57243: PUSH
57244: LD_INT 1
57246: PLUS
57247: PPUSH
57248: LD_VAR 0 14
57252: PUSH
57253: LD_INT 1
57255: ARRAY
57256: PPUSH
57257: CALL_OW 1
57261: ST_TO_ADDR
// attacking := true ;
57262: LD_ADDR_VAR 0 29
57266: PUSH
57267: LD_INT 1
57269: ST_TO_ADDR
// continue ;
57270: GO 55117
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
57272: LD_VAR 0 4
57276: PUSH
57277: LD_VAR 0 7
57281: ARRAY
57282: PPUSH
57283: CALL_OW 257
57287: PUSH
57288: LD_INT 17
57290: EQUAL
57291: PUSH
57292: LD_VAR 0 4
57296: PUSH
57297: LD_VAR 0 7
57301: ARRAY
57302: PPUSH
57303: CALL_OW 110
57307: PUSH
57308: LD_INT 71
57310: EQUAL
57311: NOT
57312: AND
57313: IFFALSE 57459
// begin attacking := false ;
57315: LD_ADDR_VAR 0 29
57319: PUSH
57320: LD_INT 0
57322: ST_TO_ADDR
// k := 5 ;
57323: LD_ADDR_VAR 0 9
57327: PUSH
57328: LD_INT 5
57330: ST_TO_ADDR
// if tmp < k then
57331: LD_VAR 0 14
57335: PUSH
57336: LD_VAR 0 9
57340: LESS
57341: IFFALSE 57353
// k := tmp ;
57343: LD_ADDR_VAR 0 9
57347: PUSH
57348: LD_VAR 0 14
57352: ST_TO_ADDR
// for j = 1 to k do
57353: LD_ADDR_VAR 0 8
57357: PUSH
57358: DOUBLE
57359: LD_INT 1
57361: DEC
57362: ST_TO_ADDR
57363: LD_VAR 0 9
57367: PUSH
57368: FOR_TO
57369: IFFALSE 57457
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
57371: LD_VAR 0 14
57375: PUSH
57376: LD_VAR 0 8
57380: ARRAY
57381: PUSH
57382: LD_VAR 0 14
57386: PPUSH
57387: LD_INT 58
57389: PUSH
57390: EMPTY
57391: LIST
57392: PPUSH
57393: CALL_OW 72
57397: IN
57398: NOT
57399: IFFALSE 57455
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
57401: LD_VAR 0 4
57405: PUSH
57406: LD_VAR 0 7
57410: ARRAY
57411: PPUSH
57412: LD_VAR 0 14
57416: PUSH
57417: LD_VAR 0 8
57421: ARRAY
57422: PPUSH
57423: CALL_OW 115
// attacking := true ;
57427: LD_ADDR_VAR 0 29
57431: PUSH
57432: LD_INT 1
57434: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
57435: LD_VAR 0 4
57439: PUSH
57440: LD_VAR 0 7
57444: ARRAY
57445: PPUSH
57446: LD_INT 71
57448: PPUSH
57449: CALL_OW 109
// continue ;
57453: GO 57368
// end ; end ;
57455: GO 57368
57457: POP
57458: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
57459: LD_VAR 0 4
57463: PUSH
57464: LD_VAR 0 7
57468: ARRAY
57469: PPUSH
57470: CALL_OW 257
57474: PUSH
57475: LD_INT 8
57477: EQUAL
57478: PUSH
57479: LD_VAR 0 4
57483: PUSH
57484: LD_VAR 0 7
57488: ARRAY
57489: PPUSH
57490: CALL_OW 264
57494: PUSH
57495: LD_INT 28
57497: PUSH
57498: LD_INT 45
57500: PUSH
57501: LD_INT 7
57503: PUSH
57504: LD_INT 47
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: LIST
57511: LIST
57512: IN
57513: OR
57514: IFFALSE 57770
// begin attacking := false ;
57516: LD_ADDR_VAR 0 29
57520: PUSH
57521: LD_INT 0
57523: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
57524: LD_VAR 0 14
57528: PUSH
57529: LD_INT 1
57531: ARRAY
57532: PPUSH
57533: CALL_OW 266
57537: PUSH
57538: LD_INT 32
57540: PUSH
57541: LD_INT 31
57543: PUSH
57544: LD_INT 33
57546: PUSH
57547: LD_INT 4
57549: PUSH
57550: LD_INT 5
57552: PUSH
57553: EMPTY
57554: LIST
57555: LIST
57556: LIST
57557: LIST
57558: LIST
57559: IN
57560: IFFALSE 57746
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
57562: LD_ADDR_VAR 0 9
57566: PUSH
57567: LD_VAR 0 14
57571: PUSH
57572: LD_INT 1
57574: ARRAY
57575: PPUSH
57576: CALL_OW 266
57580: PPUSH
57581: LD_VAR 0 14
57585: PUSH
57586: LD_INT 1
57588: ARRAY
57589: PPUSH
57590: CALL_OW 250
57594: PPUSH
57595: LD_VAR 0 14
57599: PUSH
57600: LD_INT 1
57602: ARRAY
57603: PPUSH
57604: CALL_OW 251
57608: PPUSH
57609: LD_VAR 0 14
57613: PUSH
57614: LD_INT 1
57616: ARRAY
57617: PPUSH
57618: CALL_OW 254
57622: PPUSH
57623: LD_VAR 0 14
57627: PUSH
57628: LD_INT 1
57630: ARRAY
57631: PPUSH
57632: CALL_OW 248
57636: PPUSH
57637: LD_INT 0
57639: PPUSH
57640: CALL 30704 0 6
57644: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
57645: LD_ADDR_VAR 0 8
57649: PUSH
57650: LD_VAR 0 4
57654: PUSH
57655: LD_VAR 0 7
57659: ARRAY
57660: PPUSH
57661: LD_VAR 0 9
57665: PPUSH
57666: CALL 49374 0 2
57670: ST_TO_ADDR
// if j then
57671: LD_VAR 0 8
57675: IFFALSE 57744
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
57677: LD_VAR 0 8
57681: PUSH
57682: LD_INT 1
57684: ARRAY
57685: PPUSH
57686: LD_VAR 0 8
57690: PUSH
57691: LD_INT 2
57693: ARRAY
57694: PPUSH
57695: CALL_OW 488
57699: IFFALSE 57744
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
57701: LD_VAR 0 4
57705: PUSH
57706: LD_VAR 0 7
57710: ARRAY
57711: PPUSH
57712: LD_VAR 0 8
57716: PUSH
57717: LD_INT 1
57719: ARRAY
57720: PPUSH
57721: LD_VAR 0 8
57725: PUSH
57726: LD_INT 2
57728: ARRAY
57729: PPUSH
57730: CALL_OW 116
// attacking := true ;
57734: LD_ADDR_VAR 0 29
57738: PUSH
57739: LD_INT 1
57741: ST_TO_ADDR
// continue ;
57742: GO 55117
// end ; end else
57744: GO 57770
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
57746: LD_VAR 0 4
57750: PUSH
57751: LD_VAR 0 7
57755: ARRAY
57756: PPUSH
57757: LD_VAR 0 14
57761: PUSH
57762: LD_INT 1
57764: ARRAY
57765: PPUSH
57766: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
57770: LD_VAR 0 4
57774: PUSH
57775: LD_VAR 0 7
57779: ARRAY
57780: PPUSH
57781: CALL_OW 265
57785: PUSH
57786: LD_INT 11
57788: EQUAL
57789: IFFALSE 58067
// begin k := 10 ;
57791: LD_ADDR_VAR 0 9
57795: PUSH
57796: LD_INT 10
57798: ST_TO_ADDR
// x := 0 ;
57799: LD_ADDR_VAR 0 10
57803: PUSH
57804: LD_INT 0
57806: ST_TO_ADDR
// if tmp < k then
57807: LD_VAR 0 14
57811: PUSH
57812: LD_VAR 0 9
57816: LESS
57817: IFFALSE 57829
// k := tmp ;
57819: LD_ADDR_VAR 0 9
57823: PUSH
57824: LD_VAR 0 14
57828: ST_TO_ADDR
// for j = k downto 1 do
57829: LD_ADDR_VAR 0 8
57833: PUSH
57834: DOUBLE
57835: LD_VAR 0 9
57839: INC
57840: ST_TO_ADDR
57841: LD_INT 1
57843: PUSH
57844: FOR_DOWNTO
57845: IFFALSE 57920
// begin if GetType ( tmp [ j ] ) = unit_human then
57847: LD_VAR 0 14
57851: PUSH
57852: LD_VAR 0 8
57856: ARRAY
57857: PPUSH
57858: CALL_OW 247
57862: PUSH
57863: LD_INT 1
57865: EQUAL
57866: IFFALSE 57918
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
57868: LD_VAR 0 4
57872: PUSH
57873: LD_VAR 0 7
57877: ARRAY
57878: PPUSH
57879: LD_VAR 0 14
57883: PUSH
57884: LD_VAR 0 8
57888: ARRAY
57889: PPUSH
57890: CALL 49645 0 2
// x := tmp [ j ] ;
57894: LD_ADDR_VAR 0 10
57898: PUSH
57899: LD_VAR 0 14
57903: PUSH
57904: LD_VAR 0 8
57908: ARRAY
57909: ST_TO_ADDR
// attacking := true ;
57910: LD_ADDR_VAR 0 29
57914: PUSH
57915: LD_INT 1
57917: ST_TO_ADDR
// end ; end ;
57918: GO 57844
57920: POP
57921: POP
// if not x then
57922: LD_VAR 0 10
57926: NOT
57927: IFFALSE 58067
// begin attacking := true ;
57929: LD_ADDR_VAR 0 29
57933: PUSH
57934: LD_INT 1
57936: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
57937: LD_VAR 0 4
57941: PUSH
57942: LD_VAR 0 7
57946: ARRAY
57947: PPUSH
57948: CALL_OW 250
57952: PPUSH
57953: LD_VAR 0 4
57957: PUSH
57958: LD_VAR 0 7
57962: ARRAY
57963: PPUSH
57964: CALL_OW 251
57968: PPUSH
57969: CALL_OW 546
57973: PUSH
57974: LD_INT 2
57976: ARRAY
57977: PUSH
57978: LD_VAR 0 14
57982: PUSH
57983: LD_INT 1
57985: ARRAY
57986: PPUSH
57987: CALL_OW 250
57991: PPUSH
57992: LD_VAR 0 14
57996: PUSH
57997: LD_INT 1
57999: ARRAY
58000: PPUSH
58001: CALL_OW 251
58005: PPUSH
58006: CALL_OW 546
58010: PUSH
58011: LD_INT 2
58013: ARRAY
58014: EQUAL
58015: IFFALSE 58043
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
58017: LD_VAR 0 4
58021: PUSH
58022: LD_VAR 0 7
58026: ARRAY
58027: PPUSH
58028: LD_VAR 0 14
58032: PUSH
58033: LD_INT 1
58035: ARRAY
58036: PPUSH
58037: CALL 49645 0 2
58041: GO 58067
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
58043: LD_VAR 0 4
58047: PUSH
58048: LD_VAR 0 7
58052: ARRAY
58053: PPUSH
58054: LD_VAR 0 14
58058: PUSH
58059: LD_INT 1
58061: ARRAY
58062: PPUSH
58063: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
58067: LD_VAR 0 4
58071: PUSH
58072: LD_VAR 0 7
58076: ARRAY
58077: PPUSH
58078: CALL_OW 264
58082: PUSH
58083: LD_INT 29
58085: EQUAL
58086: IFFALSE 58452
// begin if WantsToAttack ( group [ i ] ) in bombed then
58088: LD_VAR 0 4
58092: PUSH
58093: LD_VAR 0 7
58097: ARRAY
58098: PPUSH
58099: CALL_OW 319
58103: PUSH
58104: LD_VAR 0 28
58108: IN
58109: IFFALSE 58113
// continue ;
58111: GO 55117
// k := 8 ;
58113: LD_ADDR_VAR 0 9
58117: PUSH
58118: LD_INT 8
58120: ST_TO_ADDR
// x := 0 ;
58121: LD_ADDR_VAR 0 10
58125: PUSH
58126: LD_INT 0
58128: ST_TO_ADDR
// if tmp < k then
58129: LD_VAR 0 14
58133: PUSH
58134: LD_VAR 0 9
58138: LESS
58139: IFFALSE 58151
// k := tmp ;
58141: LD_ADDR_VAR 0 9
58145: PUSH
58146: LD_VAR 0 14
58150: ST_TO_ADDR
// for j = 1 to k do
58151: LD_ADDR_VAR 0 8
58155: PUSH
58156: DOUBLE
58157: LD_INT 1
58159: DEC
58160: ST_TO_ADDR
58161: LD_VAR 0 9
58165: PUSH
58166: FOR_TO
58167: IFFALSE 58299
// begin if GetType ( tmp [ j ] ) = unit_building then
58169: LD_VAR 0 14
58173: PUSH
58174: LD_VAR 0 8
58178: ARRAY
58179: PPUSH
58180: CALL_OW 247
58184: PUSH
58185: LD_INT 3
58187: EQUAL
58188: IFFALSE 58297
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
58190: LD_VAR 0 14
58194: PUSH
58195: LD_VAR 0 8
58199: ARRAY
58200: PUSH
58201: LD_VAR 0 28
58205: IN
58206: NOT
58207: PUSH
58208: LD_VAR 0 14
58212: PUSH
58213: LD_VAR 0 8
58217: ARRAY
58218: PPUSH
58219: CALL_OW 313
58223: AND
58224: IFFALSE 58297
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
58226: LD_VAR 0 4
58230: PUSH
58231: LD_VAR 0 7
58235: ARRAY
58236: PPUSH
58237: LD_VAR 0 14
58241: PUSH
58242: LD_VAR 0 8
58246: ARRAY
58247: PPUSH
58248: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
58252: LD_ADDR_VAR 0 28
58256: PUSH
58257: LD_VAR 0 28
58261: PPUSH
58262: LD_VAR 0 28
58266: PUSH
58267: LD_INT 1
58269: PLUS
58270: PPUSH
58271: LD_VAR 0 14
58275: PUSH
58276: LD_VAR 0 8
58280: ARRAY
58281: PPUSH
58282: CALL_OW 1
58286: ST_TO_ADDR
// attacking := true ;
58287: LD_ADDR_VAR 0 29
58291: PUSH
58292: LD_INT 1
58294: ST_TO_ADDR
// break ;
58295: GO 58299
// end ; end ;
58297: GO 58166
58299: POP
58300: POP
// if not attacking and f_attack_depot then
58301: LD_VAR 0 29
58305: NOT
58306: PUSH
58307: LD_VAR 0 25
58311: AND
58312: IFFALSE 58407
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58314: LD_ADDR_VAR 0 13
58318: PUSH
58319: LD_VAR 0 14
58323: PPUSH
58324: LD_INT 2
58326: PUSH
58327: LD_INT 30
58329: PUSH
58330: LD_INT 0
58332: PUSH
58333: EMPTY
58334: LIST
58335: LIST
58336: PUSH
58337: LD_INT 30
58339: PUSH
58340: LD_INT 1
58342: PUSH
58343: EMPTY
58344: LIST
58345: LIST
58346: PUSH
58347: EMPTY
58348: LIST
58349: LIST
58350: LIST
58351: PPUSH
58352: CALL_OW 72
58356: ST_TO_ADDR
// if z then
58357: LD_VAR 0 13
58361: IFFALSE 58407
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
58363: LD_VAR 0 4
58367: PUSH
58368: LD_VAR 0 7
58372: ARRAY
58373: PPUSH
58374: LD_VAR 0 13
58378: PPUSH
58379: LD_VAR 0 4
58383: PUSH
58384: LD_VAR 0 7
58388: ARRAY
58389: PPUSH
58390: CALL_OW 74
58394: PPUSH
58395: CALL_OW 115
// attacking := true ;
58399: LD_ADDR_VAR 0 29
58403: PUSH
58404: LD_INT 1
58406: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
58407: LD_VAR 0 4
58411: PUSH
58412: LD_VAR 0 7
58416: ARRAY
58417: PPUSH
58418: CALL_OW 256
58422: PUSH
58423: LD_INT 500
58425: LESS
58426: IFFALSE 58452
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
58428: LD_VAR 0 4
58432: PUSH
58433: LD_VAR 0 7
58437: ARRAY
58438: PPUSH
58439: LD_VAR 0 14
58443: PUSH
58444: LD_INT 1
58446: ARRAY
58447: PPUSH
58448: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
58452: LD_VAR 0 4
58456: PUSH
58457: LD_VAR 0 7
58461: ARRAY
58462: PPUSH
58463: CALL_OW 264
58467: PUSH
58468: LD_INT 49
58470: EQUAL
58471: IFFALSE 58592
// begin if not HasTask ( group [ i ] ) then
58473: LD_VAR 0 4
58477: PUSH
58478: LD_VAR 0 7
58482: ARRAY
58483: PPUSH
58484: CALL_OW 314
58488: NOT
58489: IFFALSE 58592
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
58491: LD_ADDR_VAR 0 9
58495: PUSH
58496: LD_INT 81
58498: PUSH
58499: LD_VAR 0 4
58503: PUSH
58504: LD_VAR 0 7
58508: ARRAY
58509: PPUSH
58510: CALL_OW 255
58514: PUSH
58515: EMPTY
58516: LIST
58517: LIST
58518: PPUSH
58519: CALL_OW 69
58523: PPUSH
58524: LD_VAR 0 4
58528: PUSH
58529: LD_VAR 0 7
58533: ARRAY
58534: PPUSH
58535: CALL_OW 74
58539: ST_TO_ADDR
// if k then
58540: LD_VAR 0 9
58544: IFFALSE 58592
// if GetDistUnits ( group [ i ] , k ) > 10 then
58546: LD_VAR 0 4
58550: PUSH
58551: LD_VAR 0 7
58555: ARRAY
58556: PPUSH
58557: LD_VAR 0 9
58561: PPUSH
58562: CALL_OW 296
58566: PUSH
58567: LD_INT 10
58569: GREATER
58570: IFFALSE 58592
// ComMoveUnit ( group [ i ] , k ) ;
58572: LD_VAR 0 4
58576: PUSH
58577: LD_VAR 0 7
58581: ARRAY
58582: PPUSH
58583: LD_VAR 0 9
58587: PPUSH
58588: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
58592: LD_VAR 0 4
58596: PUSH
58597: LD_VAR 0 7
58601: ARRAY
58602: PPUSH
58603: CALL_OW 256
58607: PUSH
58608: LD_INT 250
58610: LESS
58611: PUSH
58612: LD_VAR 0 4
58616: PUSH
58617: LD_VAR 0 7
58621: ARRAY
58622: PUSH
58623: LD_INT 21
58625: PUSH
58626: LD_INT 2
58628: PUSH
58629: EMPTY
58630: LIST
58631: LIST
58632: PUSH
58633: LD_INT 23
58635: PUSH
58636: LD_INT 2
58638: PUSH
58639: EMPTY
58640: LIST
58641: LIST
58642: PUSH
58643: EMPTY
58644: LIST
58645: LIST
58646: PPUSH
58647: CALL_OW 69
58651: IN
58652: AND
58653: IFFALSE 58778
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
58655: LD_ADDR_VAR 0 9
58659: PUSH
58660: LD_OWVAR 3
58664: PUSH
58665: LD_VAR 0 4
58669: PUSH
58670: LD_VAR 0 7
58674: ARRAY
58675: DIFF
58676: PPUSH
58677: LD_VAR 0 4
58681: PUSH
58682: LD_VAR 0 7
58686: ARRAY
58687: PPUSH
58688: CALL_OW 74
58692: ST_TO_ADDR
// if not k then
58693: LD_VAR 0 9
58697: NOT
58698: IFFALSE 58702
// continue ;
58700: GO 55117
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
58702: LD_VAR 0 9
58706: PUSH
58707: LD_INT 81
58709: PUSH
58710: LD_VAR 0 4
58714: PUSH
58715: LD_VAR 0 7
58719: ARRAY
58720: PPUSH
58721: CALL_OW 255
58725: PUSH
58726: EMPTY
58727: LIST
58728: LIST
58729: PPUSH
58730: CALL_OW 69
58734: IN
58735: PUSH
58736: LD_VAR 0 9
58740: PPUSH
58741: LD_VAR 0 4
58745: PUSH
58746: LD_VAR 0 7
58750: ARRAY
58751: PPUSH
58752: CALL_OW 296
58756: PUSH
58757: LD_INT 5
58759: LESS
58760: AND
58761: IFFALSE 58778
// ComAutodestruct ( group [ i ] ) ;
58763: LD_VAR 0 4
58767: PUSH
58768: LD_VAR 0 7
58772: ARRAY
58773: PPUSH
58774: CALL 49543 0 1
// end ; if f_attack_depot then
58778: LD_VAR 0 25
58782: IFFALSE 58894
// begin k := 6 ;
58784: LD_ADDR_VAR 0 9
58788: PUSH
58789: LD_INT 6
58791: ST_TO_ADDR
// if tmp < k then
58792: LD_VAR 0 14
58796: PUSH
58797: LD_VAR 0 9
58801: LESS
58802: IFFALSE 58814
// k := tmp ;
58804: LD_ADDR_VAR 0 9
58808: PUSH
58809: LD_VAR 0 14
58813: ST_TO_ADDR
// for j = 1 to k do
58814: LD_ADDR_VAR 0 8
58818: PUSH
58819: DOUBLE
58820: LD_INT 1
58822: DEC
58823: ST_TO_ADDR
58824: LD_VAR 0 9
58828: PUSH
58829: FOR_TO
58830: IFFALSE 58892
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
58832: LD_VAR 0 8
58836: PPUSH
58837: CALL_OW 266
58841: PUSH
58842: LD_INT 0
58844: PUSH
58845: LD_INT 1
58847: PUSH
58848: EMPTY
58849: LIST
58850: LIST
58851: IN
58852: IFFALSE 58890
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
58854: LD_VAR 0 4
58858: PUSH
58859: LD_VAR 0 7
58863: ARRAY
58864: PPUSH
58865: LD_VAR 0 14
58869: PUSH
58870: LD_VAR 0 8
58874: ARRAY
58875: PPUSH
58876: CALL_OW 115
// attacking := true ;
58880: LD_ADDR_VAR 0 29
58884: PUSH
58885: LD_INT 1
58887: ST_TO_ADDR
// break ;
58888: GO 58892
// end ;
58890: GO 58829
58892: POP
58893: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
58894: LD_VAR 0 4
58898: PUSH
58899: LD_VAR 0 7
58903: ARRAY
58904: PPUSH
58905: CALL_OW 302
58909: PUSH
58910: LD_VAR 0 29
58914: NOT
58915: AND
58916: IFFALSE 59238
// begin if GetTag ( group [ i ] ) = 71 then
58918: LD_VAR 0 4
58922: PUSH
58923: LD_VAR 0 7
58927: ARRAY
58928: PPUSH
58929: CALL_OW 110
58933: PUSH
58934: LD_INT 71
58936: EQUAL
58937: IFFALSE 58978
// begin if HasTask ( group [ i ] ) then
58939: LD_VAR 0 4
58943: PUSH
58944: LD_VAR 0 7
58948: ARRAY
58949: PPUSH
58950: CALL_OW 314
58954: IFFALSE 58960
// continue else
58956: GO 55117
58958: GO 58978
// SetTag ( group [ i ] , 0 ) ;
58960: LD_VAR 0 4
58964: PUSH
58965: LD_VAR 0 7
58969: ARRAY
58970: PPUSH
58971: LD_INT 0
58973: PPUSH
58974: CALL_OW 109
// end ; k := 8 ;
58978: LD_ADDR_VAR 0 9
58982: PUSH
58983: LD_INT 8
58985: ST_TO_ADDR
// x := 0 ;
58986: LD_ADDR_VAR 0 10
58990: PUSH
58991: LD_INT 0
58993: ST_TO_ADDR
// if tmp < k then
58994: LD_VAR 0 14
58998: PUSH
58999: LD_VAR 0 9
59003: LESS
59004: IFFALSE 59016
// k := tmp ;
59006: LD_ADDR_VAR 0 9
59010: PUSH
59011: LD_VAR 0 14
59015: ST_TO_ADDR
// for j = 1 to k do
59016: LD_ADDR_VAR 0 8
59020: PUSH
59021: DOUBLE
59022: LD_INT 1
59024: DEC
59025: ST_TO_ADDR
59026: LD_VAR 0 9
59030: PUSH
59031: FOR_TO
59032: IFFALSE 59130
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
59034: LD_VAR 0 14
59038: PUSH
59039: LD_VAR 0 8
59043: ARRAY
59044: PPUSH
59045: CALL_OW 247
59049: PUSH
59050: LD_INT 1
59052: EQUAL
59053: PUSH
59054: LD_VAR 0 14
59058: PUSH
59059: LD_VAR 0 8
59063: ARRAY
59064: PPUSH
59065: CALL_OW 256
59069: PUSH
59070: LD_INT 250
59072: LESS
59073: PUSH
59074: LD_VAR 0 20
59078: AND
59079: PUSH
59080: LD_VAR 0 20
59084: NOT
59085: PUSH
59086: LD_VAR 0 14
59090: PUSH
59091: LD_VAR 0 8
59095: ARRAY
59096: PPUSH
59097: CALL_OW 256
59101: PUSH
59102: LD_INT 250
59104: GREATEREQUAL
59105: AND
59106: OR
59107: AND
59108: IFFALSE 59128
// begin x := tmp [ j ] ;
59110: LD_ADDR_VAR 0 10
59114: PUSH
59115: LD_VAR 0 14
59119: PUSH
59120: LD_VAR 0 8
59124: ARRAY
59125: ST_TO_ADDR
// break ;
59126: GO 59130
// end ;
59128: GO 59031
59130: POP
59131: POP
// if x then
59132: LD_VAR 0 10
59136: IFFALSE 59160
// ComAttackUnit ( group [ i ] , x ) else
59138: LD_VAR 0 4
59142: PUSH
59143: LD_VAR 0 7
59147: ARRAY
59148: PPUSH
59149: LD_VAR 0 10
59153: PPUSH
59154: CALL_OW 115
59158: GO 59184
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
59160: LD_VAR 0 4
59164: PUSH
59165: LD_VAR 0 7
59169: ARRAY
59170: PPUSH
59171: LD_VAR 0 14
59175: PUSH
59176: LD_INT 1
59178: ARRAY
59179: PPUSH
59180: CALL_OW 115
// if not HasTask ( group [ i ] ) then
59184: LD_VAR 0 4
59188: PUSH
59189: LD_VAR 0 7
59193: ARRAY
59194: PPUSH
59195: CALL_OW 314
59199: NOT
59200: IFFALSE 59238
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
59202: LD_VAR 0 4
59206: PUSH
59207: LD_VAR 0 7
59211: ARRAY
59212: PPUSH
59213: LD_VAR 0 14
59217: PPUSH
59218: LD_VAR 0 4
59222: PUSH
59223: LD_VAR 0 7
59227: ARRAY
59228: PPUSH
59229: CALL_OW 74
59233: PPUSH
59234: CALL_OW 115
// end ; end ; end ;
59238: GO 55117
59240: POP
59241: POP
// wait ( 0 0$2 ) ;
59242: LD_INT 70
59244: PPUSH
59245: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
59249: LD_VAR 0 4
59253: NOT
59254: PUSH
59255: LD_VAR 0 4
59259: PUSH
59260: EMPTY
59261: EQUAL
59262: OR
59263: PUSH
59264: LD_INT 81
59266: PUSH
59267: LD_VAR 0 35
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: PPUSH
59276: CALL_OW 69
59280: NOT
59281: OR
59282: IFFALSE 55102
// end ;
59284: LD_VAR 0 2
59288: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
59289: LD_INT 0
59291: PPUSH
59292: PPUSH
59293: PPUSH
59294: PPUSH
59295: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
59296: LD_VAR 0 1
59300: NOT
59301: PUSH
59302: LD_EXP 84
59306: PUSH
59307: LD_VAR 0 1
59311: ARRAY
59312: NOT
59313: OR
59314: PUSH
59315: LD_VAR 0 2
59319: NOT
59320: OR
59321: PUSH
59322: LD_VAR 0 3
59326: NOT
59327: OR
59328: IFFALSE 59332
// exit ;
59330: GO 59845
// side := mc_sides [ base ] ;
59332: LD_ADDR_VAR 0 6
59336: PUSH
59337: LD_EXP 110
59341: PUSH
59342: LD_VAR 0 1
59346: ARRAY
59347: ST_TO_ADDR
// if not side then
59348: LD_VAR 0 6
59352: NOT
59353: IFFALSE 59357
// exit ;
59355: GO 59845
// for i in solds do
59357: LD_ADDR_VAR 0 7
59361: PUSH
59362: LD_VAR 0 2
59366: PUSH
59367: FOR_IN
59368: IFFALSE 59429
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
59370: LD_VAR 0 7
59374: PPUSH
59375: CALL_OW 310
59379: PPUSH
59380: CALL_OW 266
59384: PUSH
59385: LD_INT 32
59387: PUSH
59388: LD_INT 31
59390: PUSH
59391: EMPTY
59392: LIST
59393: LIST
59394: IN
59395: IFFALSE 59415
// solds := solds diff i else
59397: LD_ADDR_VAR 0 2
59401: PUSH
59402: LD_VAR 0 2
59406: PUSH
59407: LD_VAR 0 7
59411: DIFF
59412: ST_TO_ADDR
59413: GO 59427
// SetTag ( i , 18 ) ;
59415: LD_VAR 0 7
59419: PPUSH
59420: LD_INT 18
59422: PPUSH
59423: CALL_OW 109
59427: GO 59367
59429: POP
59430: POP
// if not solds then
59431: LD_VAR 0 2
59435: NOT
59436: IFFALSE 59440
// exit ;
59438: GO 59845
// repeat wait ( 0 0$2 ) ;
59440: LD_INT 70
59442: PPUSH
59443: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
59447: LD_ADDR_VAR 0 5
59451: PUSH
59452: LD_VAR 0 6
59456: PPUSH
59457: LD_VAR 0 3
59461: PPUSH
59462: CALL 19258 0 2
59466: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
59467: LD_EXP 84
59471: PUSH
59472: LD_VAR 0 1
59476: ARRAY
59477: NOT
59478: PUSH
59479: LD_EXP 84
59483: PUSH
59484: LD_VAR 0 1
59488: ARRAY
59489: PUSH
59490: EMPTY
59491: EQUAL
59492: OR
59493: IFFALSE 59530
// begin for i in solds do
59495: LD_ADDR_VAR 0 7
59499: PUSH
59500: LD_VAR 0 2
59504: PUSH
59505: FOR_IN
59506: IFFALSE 59519
// ComStop ( i ) ;
59508: LD_VAR 0 7
59512: PPUSH
59513: CALL_OW 141
59517: GO 59505
59519: POP
59520: POP
// solds := [ ] ;
59521: LD_ADDR_VAR 0 2
59525: PUSH
59526: EMPTY
59527: ST_TO_ADDR
// exit ;
59528: GO 59845
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
59530: LD_VAR 0 5
59534: NOT
59535: PUSH
59536: LD_VAR 0 5
59540: PUSH
59541: LD_INT 3
59543: GREATER
59544: OR
59545: PUSH
59546: LD_EXP 106
59550: PUSH
59551: LD_VAR 0 1
59555: ARRAY
59556: OR
59557: IFFALSE 59598
// begin for i in solds do
59559: LD_ADDR_VAR 0 7
59563: PUSH
59564: LD_VAR 0 2
59568: PUSH
59569: FOR_IN
59570: IFFALSE 59594
// if HasTask ( i ) then
59572: LD_VAR 0 7
59576: PPUSH
59577: CALL_OW 314
59581: IFFALSE 59592
// ComStop ( i ) ;
59583: LD_VAR 0 7
59587: PPUSH
59588: CALL_OW 141
59592: GO 59569
59594: POP
59595: POP
// break ;
59596: GO 59833
// end ; for i in solds do
59598: LD_ADDR_VAR 0 7
59602: PUSH
59603: LD_VAR 0 2
59607: PUSH
59608: FOR_IN
59609: IFFALSE 59825
// begin if IsInUnit ( i ) then
59611: LD_VAR 0 7
59615: PPUSH
59616: CALL_OW 310
59620: IFFALSE 59631
// ComExitBuilding ( i ) ;
59622: LD_VAR 0 7
59626: PPUSH
59627: CALL_OW 122
// if GetLives ( i ) > 333 then
59631: LD_VAR 0 7
59635: PPUSH
59636: CALL_OW 256
59640: PUSH
59641: LD_INT 333
59643: GREATER
59644: IFFALSE 59672
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
59646: LD_VAR 0 7
59650: PPUSH
59651: LD_VAR 0 5
59655: PPUSH
59656: LD_VAR 0 7
59660: PPUSH
59661: CALL_OW 74
59665: PPUSH
59666: CALL_OW 115
59670: GO 59823
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
59672: LD_ADDR_VAR 0 8
59676: PUSH
59677: LD_EXP 84
59681: PUSH
59682: LD_VAR 0 1
59686: ARRAY
59687: PPUSH
59688: LD_INT 2
59690: PUSH
59691: LD_INT 30
59693: PUSH
59694: LD_INT 0
59696: PUSH
59697: EMPTY
59698: LIST
59699: LIST
59700: PUSH
59701: LD_INT 30
59703: PUSH
59704: LD_INT 1
59706: PUSH
59707: EMPTY
59708: LIST
59709: LIST
59710: PUSH
59711: LD_INT 30
59713: PUSH
59714: LD_INT 6
59716: PUSH
59717: EMPTY
59718: LIST
59719: LIST
59720: PUSH
59721: EMPTY
59722: LIST
59723: LIST
59724: LIST
59725: LIST
59726: PPUSH
59727: CALL_OW 72
59731: PPUSH
59732: LD_VAR 0 7
59736: PPUSH
59737: CALL_OW 74
59741: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
59742: LD_VAR 0 7
59746: PPUSH
59747: LD_VAR 0 8
59751: PPUSH
59752: CALL_OW 250
59756: PPUSH
59757: LD_INT 3
59759: PPUSH
59760: LD_INT 5
59762: PPUSH
59763: CALL_OW 272
59767: PPUSH
59768: LD_VAR 0 8
59772: PPUSH
59773: CALL_OW 251
59777: PPUSH
59778: LD_INT 3
59780: PPUSH
59781: LD_INT 5
59783: PPUSH
59784: CALL_OW 273
59788: PPUSH
59789: CALL_OW 111
// SetTag ( i , 0 ) ;
59793: LD_VAR 0 7
59797: PPUSH
59798: LD_INT 0
59800: PPUSH
59801: CALL_OW 109
// solds := solds diff i ;
59805: LD_ADDR_VAR 0 2
59809: PUSH
59810: LD_VAR 0 2
59814: PUSH
59815: LD_VAR 0 7
59819: DIFF
59820: ST_TO_ADDR
// continue ;
59821: GO 59608
// end ; end ;
59823: GO 59608
59825: POP
59826: POP
// until solds ;
59827: LD_VAR 0 2
59831: IFFALSE 59440
// MC_Reset ( base , 18 ) ;
59833: LD_VAR 0 1
59837: PPUSH
59838: LD_INT 18
59840: PPUSH
59841: CALL 65842 0 2
// end ;
59845: LD_VAR 0 4
59849: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
59850: LD_INT 0
59852: PPUSH
59853: PPUSH
59854: PPUSH
59855: PPUSH
59856: PPUSH
59857: PPUSH
59858: PPUSH
59859: PPUSH
59860: PPUSH
59861: PPUSH
59862: PPUSH
59863: PPUSH
59864: PPUSH
59865: PPUSH
59866: PPUSH
59867: PPUSH
59868: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59869: LD_ADDR_VAR 0 13
59873: PUSH
59874: LD_EXP 84
59878: PUSH
59879: LD_VAR 0 1
59883: ARRAY
59884: PPUSH
59885: LD_INT 25
59887: PUSH
59888: LD_INT 3
59890: PUSH
59891: EMPTY
59892: LIST
59893: LIST
59894: PPUSH
59895: CALL_OW 72
59899: ST_TO_ADDR
// if mc_remote_driver [ base ] then
59900: LD_EXP 124
59904: PUSH
59905: LD_VAR 0 1
59909: ARRAY
59910: IFFALSE 59934
// mechs := mechs diff mc_remote_driver [ base ] ;
59912: LD_ADDR_VAR 0 13
59916: PUSH
59917: LD_VAR 0 13
59921: PUSH
59922: LD_EXP 124
59926: PUSH
59927: LD_VAR 0 1
59931: ARRAY
59932: DIFF
59933: ST_TO_ADDR
// for i in mechs do
59934: LD_ADDR_VAR 0 5
59938: PUSH
59939: LD_VAR 0 13
59943: PUSH
59944: FOR_IN
59945: IFFALSE 59980
// if GetTag ( i ) > 0 then
59947: LD_VAR 0 5
59951: PPUSH
59952: CALL_OW 110
59956: PUSH
59957: LD_INT 0
59959: GREATER
59960: IFFALSE 59978
// mechs := mechs diff i ;
59962: LD_ADDR_VAR 0 13
59966: PUSH
59967: LD_VAR 0 13
59971: PUSH
59972: LD_VAR 0 5
59976: DIFF
59977: ST_TO_ADDR
59978: GO 59944
59980: POP
59981: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59982: LD_ADDR_VAR 0 9
59986: PUSH
59987: LD_EXP 84
59991: PUSH
59992: LD_VAR 0 1
59996: ARRAY
59997: PPUSH
59998: LD_INT 2
60000: PUSH
60001: LD_INT 25
60003: PUSH
60004: LD_INT 1
60006: PUSH
60007: EMPTY
60008: LIST
60009: LIST
60010: PUSH
60011: LD_INT 25
60013: PUSH
60014: LD_INT 5
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PUSH
60021: LD_INT 25
60023: PUSH
60024: LD_INT 8
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: PUSH
60031: LD_INT 25
60033: PUSH
60034: LD_INT 9
60036: PUSH
60037: EMPTY
60038: LIST
60039: LIST
60040: PUSH
60041: EMPTY
60042: LIST
60043: LIST
60044: LIST
60045: LIST
60046: LIST
60047: PPUSH
60048: CALL_OW 72
60052: ST_TO_ADDR
// if not defenders and not solds then
60053: LD_VAR 0 2
60057: NOT
60058: PUSH
60059: LD_VAR 0 9
60063: NOT
60064: AND
60065: IFFALSE 60069
// exit ;
60067: GO 61759
// depot_under_attack := false ;
60069: LD_ADDR_VAR 0 17
60073: PUSH
60074: LD_INT 0
60076: ST_TO_ADDR
// sold_defenders := [ ] ;
60077: LD_ADDR_VAR 0 18
60081: PUSH
60082: EMPTY
60083: ST_TO_ADDR
// if mechs then
60084: LD_VAR 0 13
60088: IFFALSE 60241
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
60090: LD_ADDR_VAR 0 5
60094: PUSH
60095: LD_VAR 0 2
60099: PPUSH
60100: LD_INT 21
60102: PUSH
60103: LD_INT 2
60105: PUSH
60106: EMPTY
60107: LIST
60108: LIST
60109: PPUSH
60110: CALL_OW 72
60114: PUSH
60115: FOR_IN
60116: IFFALSE 60239
// begin if GetTag ( i ) <> 20 then
60118: LD_VAR 0 5
60122: PPUSH
60123: CALL_OW 110
60127: PUSH
60128: LD_INT 20
60130: NONEQUAL
60131: IFFALSE 60145
// SetTag ( i , 20 ) ;
60133: LD_VAR 0 5
60137: PPUSH
60138: LD_INT 20
60140: PPUSH
60141: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
60145: LD_VAR 0 5
60149: PPUSH
60150: CALL_OW 263
60154: PUSH
60155: LD_INT 1
60157: EQUAL
60158: PUSH
60159: LD_VAR 0 5
60163: PPUSH
60164: CALL_OW 311
60168: NOT
60169: AND
60170: IFFALSE 60237
// begin un := mechs [ 1 ] ;
60172: LD_ADDR_VAR 0 11
60176: PUSH
60177: LD_VAR 0 13
60181: PUSH
60182: LD_INT 1
60184: ARRAY
60185: ST_TO_ADDR
// ComExit ( un ) ;
60186: LD_VAR 0 11
60190: PPUSH
60191: CALL 53888 0 1
// AddComEnterUnit ( un , i ) ;
60195: LD_VAR 0 11
60199: PPUSH
60200: LD_VAR 0 5
60204: PPUSH
60205: CALL_OW 180
// SetTag ( un , 19 ) ;
60209: LD_VAR 0 11
60213: PPUSH
60214: LD_INT 19
60216: PPUSH
60217: CALL_OW 109
// mechs := mechs diff un ;
60221: LD_ADDR_VAR 0 13
60225: PUSH
60226: LD_VAR 0 13
60230: PUSH
60231: LD_VAR 0 11
60235: DIFF
60236: ST_TO_ADDR
// end ; end ;
60237: GO 60115
60239: POP
60240: POP
// if solds then
60241: LD_VAR 0 9
60245: IFFALSE 60304
// for i in solds do
60247: LD_ADDR_VAR 0 5
60251: PUSH
60252: LD_VAR 0 9
60256: PUSH
60257: FOR_IN
60258: IFFALSE 60302
// if not GetTag ( i ) then
60260: LD_VAR 0 5
60264: PPUSH
60265: CALL_OW 110
60269: NOT
60270: IFFALSE 60300
// begin defenders := defenders union i ;
60272: LD_ADDR_VAR 0 2
60276: PUSH
60277: LD_VAR 0 2
60281: PUSH
60282: LD_VAR 0 5
60286: UNION
60287: ST_TO_ADDR
// SetTag ( i , 18 ) ;
60288: LD_VAR 0 5
60292: PPUSH
60293: LD_INT 18
60295: PPUSH
60296: CALL_OW 109
// end ;
60300: GO 60257
60302: POP
60303: POP
// repeat wait ( 0 0$2 ) ;
60304: LD_INT 70
60306: PPUSH
60307: CALL_OW 67
// enemy := mc_scan [ base ] ;
60311: LD_ADDR_VAR 0 3
60315: PUSH
60316: LD_EXP 107
60320: PUSH
60321: LD_VAR 0 1
60325: ARRAY
60326: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
60327: LD_EXP 84
60331: PUSH
60332: LD_VAR 0 1
60336: ARRAY
60337: NOT
60338: PUSH
60339: LD_EXP 84
60343: PUSH
60344: LD_VAR 0 1
60348: ARRAY
60349: PUSH
60350: EMPTY
60351: EQUAL
60352: OR
60353: IFFALSE 60390
// begin for i in defenders do
60355: LD_ADDR_VAR 0 5
60359: PUSH
60360: LD_VAR 0 2
60364: PUSH
60365: FOR_IN
60366: IFFALSE 60379
// ComStop ( i ) ;
60368: LD_VAR 0 5
60372: PPUSH
60373: CALL_OW 141
60377: GO 60365
60379: POP
60380: POP
// defenders := [ ] ;
60381: LD_ADDR_VAR 0 2
60385: PUSH
60386: EMPTY
60387: ST_TO_ADDR
// exit ;
60388: GO 61759
// end ; for i in defenders do
60390: LD_ADDR_VAR 0 5
60394: PUSH
60395: LD_VAR 0 2
60399: PUSH
60400: FOR_IN
60401: IFFALSE 61219
// begin e := NearestUnitToUnit ( enemy , i ) ;
60403: LD_ADDR_VAR 0 14
60407: PUSH
60408: LD_VAR 0 3
60412: PPUSH
60413: LD_VAR 0 5
60417: PPUSH
60418: CALL_OW 74
60422: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60423: LD_ADDR_VAR 0 8
60427: PUSH
60428: LD_EXP 84
60432: PUSH
60433: LD_VAR 0 1
60437: ARRAY
60438: PPUSH
60439: LD_INT 2
60441: PUSH
60442: LD_INT 30
60444: PUSH
60445: LD_INT 0
60447: PUSH
60448: EMPTY
60449: LIST
60450: LIST
60451: PUSH
60452: LD_INT 30
60454: PUSH
60455: LD_INT 1
60457: PUSH
60458: EMPTY
60459: LIST
60460: LIST
60461: PUSH
60462: EMPTY
60463: LIST
60464: LIST
60465: LIST
60466: PPUSH
60467: CALL_OW 72
60471: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
60472: LD_ADDR_VAR 0 17
60476: PUSH
60477: LD_VAR 0 8
60481: NOT
60482: PUSH
60483: LD_VAR 0 8
60487: PPUSH
60488: LD_INT 3
60490: PUSH
60491: LD_INT 24
60493: PUSH
60494: LD_INT 600
60496: PUSH
60497: EMPTY
60498: LIST
60499: LIST
60500: PUSH
60501: EMPTY
60502: LIST
60503: LIST
60504: PPUSH
60505: CALL_OW 72
60509: OR
60510: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
60511: LD_VAR 0 5
60515: PPUSH
60516: CALL_OW 247
60520: PUSH
60521: LD_INT 2
60523: DOUBLE
60524: EQUAL
60525: IFTRUE 60529
60527: GO 60925
60529: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
60530: LD_VAR 0 5
60534: PPUSH
60535: CALL_OW 256
60539: PUSH
60540: LD_INT 650
60542: GREATER
60543: PUSH
60544: LD_VAR 0 5
60548: PPUSH
60549: LD_VAR 0 14
60553: PPUSH
60554: CALL_OW 296
60558: PUSH
60559: LD_INT 40
60561: LESS
60562: PUSH
60563: LD_VAR 0 14
60567: PPUSH
60568: LD_EXP 109
60572: PUSH
60573: LD_VAR 0 1
60577: ARRAY
60578: PPUSH
60579: CALL_OW 308
60583: OR
60584: AND
60585: IFFALSE 60707
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
60587: LD_VAR 0 5
60591: PPUSH
60592: CALL_OW 262
60596: PUSH
60597: LD_INT 1
60599: EQUAL
60600: PUSH
60601: LD_VAR 0 5
60605: PPUSH
60606: CALL_OW 261
60610: PUSH
60611: LD_INT 30
60613: LESS
60614: AND
60615: PUSH
60616: LD_VAR 0 8
60620: AND
60621: IFFALSE 60691
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
60623: LD_VAR 0 5
60627: PPUSH
60628: LD_VAR 0 8
60632: PPUSH
60633: LD_VAR 0 5
60637: PPUSH
60638: CALL_OW 74
60642: PPUSH
60643: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
60647: LD_VAR 0 5
60651: PPUSH
60652: LD_VAR 0 8
60656: PPUSH
60657: LD_VAR 0 5
60661: PPUSH
60662: CALL_OW 74
60666: PPUSH
60667: CALL_OW 296
60671: PUSH
60672: LD_INT 6
60674: LESS
60675: IFFALSE 60689
// SetFuel ( i , 100 ) ;
60677: LD_VAR 0 5
60681: PPUSH
60682: LD_INT 100
60684: PPUSH
60685: CALL_OW 240
// end else
60689: GO 60705
// ComAttackUnit ( i , e ) ;
60691: LD_VAR 0 5
60695: PPUSH
60696: LD_VAR 0 14
60700: PPUSH
60701: CALL_OW 115
// end else
60705: GO 60808
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
60707: LD_VAR 0 14
60711: PPUSH
60712: LD_EXP 109
60716: PUSH
60717: LD_VAR 0 1
60721: ARRAY
60722: PPUSH
60723: CALL_OW 308
60727: NOT
60728: PUSH
60729: LD_VAR 0 5
60733: PPUSH
60734: LD_VAR 0 14
60738: PPUSH
60739: CALL_OW 296
60743: PUSH
60744: LD_INT 40
60746: GREATEREQUAL
60747: AND
60748: PUSH
60749: LD_VAR 0 5
60753: PPUSH
60754: CALL_OW 256
60758: PUSH
60759: LD_INT 650
60761: LESSEQUAL
60762: OR
60763: PUSH
60764: LD_VAR 0 5
60768: PPUSH
60769: LD_EXP 108
60773: PUSH
60774: LD_VAR 0 1
60778: ARRAY
60779: PPUSH
60780: CALL_OW 308
60784: NOT
60785: AND
60786: IFFALSE 60808
// ComMoveToArea ( i , mc_parking [ base ] ) ;
60788: LD_VAR 0 5
60792: PPUSH
60793: LD_EXP 108
60797: PUSH
60798: LD_VAR 0 1
60802: ARRAY
60803: PPUSH
60804: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
60808: LD_VAR 0 5
60812: PPUSH
60813: CALL_OW 256
60817: PUSH
60818: LD_INT 998
60820: LESS
60821: PUSH
60822: LD_VAR 0 5
60826: PPUSH
60827: CALL_OW 263
60831: PUSH
60832: LD_INT 1
60834: EQUAL
60835: AND
60836: PUSH
60837: LD_VAR 0 5
60841: PPUSH
60842: CALL_OW 311
60846: AND
60847: PUSH
60848: LD_VAR 0 5
60852: PPUSH
60853: LD_EXP 108
60857: PUSH
60858: LD_VAR 0 1
60862: ARRAY
60863: PPUSH
60864: CALL_OW 308
60868: AND
60869: IFFALSE 60923
// begin mech := IsDrivenBy ( i ) ;
60871: LD_ADDR_VAR 0 10
60875: PUSH
60876: LD_VAR 0 5
60880: PPUSH
60881: CALL_OW 311
60885: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
60886: LD_VAR 0 10
60890: PPUSH
60891: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
60895: LD_VAR 0 10
60899: PPUSH
60900: LD_VAR 0 5
60904: PPUSH
60905: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
60909: LD_VAR 0 10
60913: PPUSH
60914: LD_VAR 0 5
60918: PPUSH
60919: CALL_OW 180
// end ; end ; unit_human :
60923: GO 61190
60925: LD_INT 1
60927: DOUBLE
60928: EQUAL
60929: IFTRUE 60933
60931: GO 61189
60933: POP
// begin b := IsInUnit ( i ) ;
60934: LD_ADDR_VAR 0 19
60938: PUSH
60939: LD_VAR 0 5
60943: PPUSH
60944: CALL_OW 310
60948: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
60949: LD_ADDR_VAR 0 20
60953: PUSH
60954: LD_VAR 0 19
60958: NOT
60959: PUSH
60960: LD_VAR 0 19
60964: PPUSH
60965: CALL_OW 266
60969: PUSH
60970: LD_INT 32
60972: PUSH
60973: LD_INT 31
60975: PUSH
60976: EMPTY
60977: LIST
60978: LIST
60979: IN
60980: OR
60981: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
60982: LD_VAR 0 17
60986: PUSH
60987: LD_VAR 0 2
60991: PPUSH
60992: LD_INT 21
60994: PUSH
60995: LD_INT 2
60997: PUSH
60998: EMPTY
60999: LIST
61000: LIST
61001: PPUSH
61002: CALL_OW 72
61006: PUSH
61007: LD_INT 1
61009: LESSEQUAL
61010: OR
61011: PUSH
61012: LD_VAR 0 20
61016: AND
61017: PUSH
61018: LD_VAR 0 5
61022: PUSH
61023: LD_VAR 0 18
61027: IN
61028: NOT
61029: AND
61030: IFFALSE 61123
// begin if b then
61032: LD_VAR 0 19
61036: IFFALSE 61085
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
61038: LD_VAR 0 19
61042: PPUSH
61043: LD_VAR 0 3
61047: PPUSH
61048: LD_VAR 0 19
61052: PPUSH
61053: CALL_OW 74
61057: PPUSH
61058: CALL_OW 296
61062: PUSH
61063: LD_INT 10
61065: LESS
61066: PUSH
61067: LD_VAR 0 19
61071: PPUSH
61072: CALL_OW 461
61076: PUSH
61077: LD_INT 7
61079: NONEQUAL
61080: AND
61081: IFFALSE 61085
// continue ;
61083: GO 60400
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
61085: LD_ADDR_VAR 0 18
61089: PUSH
61090: LD_VAR 0 18
61094: PPUSH
61095: LD_VAR 0 18
61099: PUSH
61100: LD_INT 1
61102: PLUS
61103: PPUSH
61104: LD_VAR 0 5
61108: PPUSH
61109: CALL_OW 1
61113: ST_TO_ADDR
// ComExitBuilding ( i ) ;
61114: LD_VAR 0 5
61118: PPUSH
61119: CALL_OW 122
// end ; if sold_defenders then
61123: LD_VAR 0 18
61127: IFFALSE 61187
// if i in sold_defenders then
61129: LD_VAR 0 5
61133: PUSH
61134: LD_VAR 0 18
61138: IN
61139: IFFALSE 61187
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
61141: LD_VAR 0 5
61145: PPUSH
61146: CALL_OW 314
61150: NOT
61151: PUSH
61152: LD_VAR 0 5
61156: PPUSH
61157: LD_VAR 0 14
61161: PPUSH
61162: CALL_OW 296
61166: PUSH
61167: LD_INT 30
61169: LESS
61170: AND
61171: IFFALSE 61187
// ComAttackUnit ( i , e ) ;
61173: LD_VAR 0 5
61177: PPUSH
61178: LD_VAR 0 14
61182: PPUSH
61183: CALL_OW 115
// end ; end ; end ;
61187: GO 61190
61189: POP
// if IsDead ( i ) then
61190: LD_VAR 0 5
61194: PPUSH
61195: CALL_OW 301
61199: IFFALSE 61217
// defenders := defenders diff i ;
61201: LD_ADDR_VAR 0 2
61205: PUSH
61206: LD_VAR 0 2
61210: PUSH
61211: LD_VAR 0 5
61215: DIFF
61216: ST_TO_ADDR
// end ;
61217: GO 60400
61219: POP
61220: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
61221: LD_VAR 0 3
61225: NOT
61226: PUSH
61227: LD_VAR 0 2
61231: NOT
61232: OR
61233: PUSH
61234: LD_EXP 84
61238: PUSH
61239: LD_VAR 0 1
61243: ARRAY
61244: NOT
61245: OR
61246: IFFALSE 60304
// MC_Reset ( base , 18 ) ;
61248: LD_VAR 0 1
61252: PPUSH
61253: LD_INT 18
61255: PPUSH
61256: CALL 65842 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61260: LD_ADDR_VAR 0 2
61264: PUSH
61265: LD_VAR 0 2
61269: PUSH
61270: LD_VAR 0 2
61274: PPUSH
61275: LD_INT 2
61277: PUSH
61278: LD_INT 25
61280: PUSH
61281: LD_INT 1
61283: PUSH
61284: EMPTY
61285: LIST
61286: LIST
61287: PUSH
61288: LD_INT 25
61290: PUSH
61291: LD_INT 5
61293: PUSH
61294: EMPTY
61295: LIST
61296: LIST
61297: PUSH
61298: LD_INT 25
61300: PUSH
61301: LD_INT 8
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: PUSH
61308: LD_INT 25
61310: PUSH
61311: LD_INT 9
61313: PUSH
61314: EMPTY
61315: LIST
61316: LIST
61317: PUSH
61318: EMPTY
61319: LIST
61320: LIST
61321: LIST
61322: LIST
61323: LIST
61324: PPUSH
61325: CALL_OW 72
61329: DIFF
61330: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
61331: LD_VAR 0 3
61335: NOT
61336: PUSH
61337: LD_VAR 0 2
61341: PPUSH
61342: LD_INT 21
61344: PUSH
61345: LD_INT 2
61347: PUSH
61348: EMPTY
61349: LIST
61350: LIST
61351: PPUSH
61352: CALL_OW 72
61356: AND
61357: IFFALSE 61695
// begin tmp := FilterByTag ( defenders , 19 ) ;
61359: LD_ADDR_VAR 0 12
61363: PUSH
61364: LD_VAR 0 2
61368: PPUSH
61369: LD_INT 19
61371: PPUSH
61372: CALL 51018 0 2
61376: ST_TO_ADDR
// if tmp then
61377: LD_VAR 0 12
61381: IFFALSE 61451
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
61383: LD_ADDR_VAR 0 12
61387: PUSH
61388: LD_VAR 0 12
61392: PPUSH
61393: LD_INT 25
61395: PUSH
61396: LD_INT 3
61398: PUSH
61399: EMPTY
61400: LIST
61401: LIST
61402: PPUSH
61403: CALL_OW 72
61407: ST_TO_ADDR
// if tmp then
61408: LD_VAR 0 12
61412: IFFALSE 61451
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
61414: LD_ADDR_EXP 96
61418: PUSH
61419: LD_EXP 96
61423: PPUSH
61424: LD_VAR 0 1
61428: PPUSH
61429: LD_EXP 96
61433: PUSH
61434: LD_VAR 0 1
61438: ARRAY
61439: PUSH
61440: LD_VAR 0 12
61444: UNION
61445: PPUSH
61446: CALL_OW 1
61450: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
61451: LD_VAR 0 1
61455: PPUSH
61456: LD_INT 19
61458: PPUSH
61459: CALL 65842 0 2
// repeat wait ( 0 0$1 ) ;
61463: LD_INT 35
61465: PPUSH
61466: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
61470: LD_EXP 84
61474: PUSH
61475: LD_VAR 0 1
61479: ARRAY
61480: NOT
61481: PUSH
61482: LD_EXP 84
61486: PUSH
61487: LD_VAR 0 1
61491: ARRAY
61492: PUSH
61493: EMPTY
61494: EQUAL
61495: OR
61496: IFFALSE 61533
// begin for i in defenders do
61498: LD_ADDR_VAR 0 5
61502: PUSH
61503: LD_VAR 0 2
61507: PUSH
61508: FOR_IN
61509: IFFALSE 61522
// ComStop ( i ) ;
61511: LD_VAR 0 5
61515: PPUSH
61516: CALL_OW 141
61520: GO 61508
61522: POP
61523: POP
// defenders := [ ] ;
61524: LD_ADDR_VAR 0 2
61528: PUSH
61529: EMPTY
61530: ST_TO_ADDR
// exit ;
61531: GO 61759
// end ; for i in defenders do
61533: LD_ADDR_VAR 0 5
61537: PUSH
61538: LD_VAR 0 2
61542: PUSH
61543: FOR_IN
61544: IFFALSE 61633
// begin if not IsInArea ( i , mc_parking [ base ] ) then
61546: LD_VAR 0 5
61550: PPUSH
61551: LD_EXP 108
61555: PUSH
61556: LD_VAR 0 1
61560: ARRAY
61561: PPUSH
61562: CALL_OW 308
61566: NOT
61567: IFFALSE 61591
// ComMoveToArea ( i , mc_parking [ base ] ) else
61569: LD_VAR 0 5
61573: PPUSH
61574: LD_EXP 108
61578: PUSH
61579: LD_VAR 0 1
61583: ARRAY
61584: PPUSH
61585: CALL_OW 113
61589: GO 61631
// if GetControl ( i ) = control_manual then
61591: LD_VAR 0 5
61595: PPUSH
61596: CALL_OW 263
61600: PUSH
61601: LD_INT 1
61603: EQUAL
61604: IFFALSE 61631
// if IsDrivenBy ( i ) then
61606: LD_VAR 0 5
61610: PPUSH
61611: CALL_OW 311
61615: IFFALSE 61631
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
61617: LD_VAR 0 5
61621: PPUSH
61622: CALL_OW 311
61626: PPUSH
61627: CALL_OW 121
// end ;
61631: GO 61543
61633: POP
61634: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
61635: LD_VAR 0 2
61639: PPUSH
61640: LD_INT 95
61642: PUSH
61643: LD_EXP 108
61647: PUSH
61648: LD_VAR 0 1
61652: ARRAY
61653: PUSH
61654: EMPTY
61655: LIST
61656: LIST
61657: PPUSH
61658: CALL_OW 72
61662: PUSH
61663: LD_VAR 0 2
61667: EQUAL
61668: PUSH
61669: LD_EXP 107
61673: PUSH
61674: LD_VAR 0 1
61678: ARRAY
61679: OR
61680: PUSH
61681: LD_EXP 84
61685: PUSH
61686: LD_VAR 0 1
61690: ARRAY
61691: NOT
61692: OR
61693: IFFALSE 61463
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
61695: LD_ADDR_EXP 106
61699: PUSH
61700: LD_EXP 106
61704: PPUSH
61705: LD_VAR 0 1
61709: PPUSH
61710: LD_VAR 0 2
61714: PPUSH
61715: LD_INT 21
61717: PUSH
61718: LD_INT 2
61720: PUSH
61721: EMPTY
61722: LIST
61723: LIST
61724: PPUSH
61725: CALL_OW 72
61729: PPUSH
61730: CALL_OW 1
61734: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
61735: LD_VAR 0 1
61739: PPUSH
61740: LD_INT 19
61742: PPUSH
61743: CALL 65842 0 2
// MC_Reset ( base , 20 ) ;
61747: LD_VAR 0 1
61751: PPUSH
61752: LD_INT 20
61754: PPUSH
61755: CALL 65842 0 2
// end ; end_of_file
61759: LD_VAR 0 4
61763: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
61764: LD_INT 0
61766: PPUSH
61767: PPUSH
// skirmish := false ;
61768: LD_ADDR_EXP 82
61772: PUSH
61773: LD_INT 0
61775: ST_TO_ADDR
// debug_mc := false ;
61776: LD_ADDR_EXP 83
61780: PUSH
61781: LD_INT 0
61783: ST_TO_ADDR
// mc_bases := [ ] ;
61784: LD_ADDR_EXP 84
61788: PUSH
61789: EMPTY
61790: ST_TO_ADDR
// mc_sides := [ ] ;
61791: LD_ADDR_EXP 110
61795: PUSH
61796: EMPTY
61797: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61798: LD_ADDR_EXP 85
61802: PUSH
61803: EMPTY
61804: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61805: LD_ADDR_EXP 86
61809: PUSH
61810: EMPTY
61811: ST_TO_ADDR
// mc_need_heal := [ ] ;
61812: LD_ADDR_EXP 87
61816: PUSH
61817: EMPTY
61818: ST_TO_ADDR
// mc_healers := [ ] ;
61819: LD_ADDR_EXP 88
61823: PUSH
61824: EMPTY
61825: ST_TO_ADDR
// mc_build_list := [ ] ;
61826: LD_ADDR_EXP 89
61830: PUSH
61831: EMPTY
61832: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61833: LD_ADDR_EXP 116
61837: PUSH
61838: EMPTY
61839: ST_TO_ADDR
// mc_builders := [ ] ;
61840: LD_ADDR_EXP 90
61844: PUSH
61845: EMPTY
61846: ST_TO_ADDR
// mc_construct_list := [ ] ;
61847: LD_ADDR_EXP 91
61851: PUSH
61852: EMPTY
61853: ST_TO_ADDR
// mc_turret_list := [ ] ;
61854: LD_ADDR_EXP 92
61858: PUSH
61859: EMPTY
61860: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61861: LD_ADDR_EXP 93
61865: PUSH
61866: EMPTY
61867: ST_TO_ADDR
// mc_miners := [ ] ;
61868: LD_ADDR_EXP 98
61872: PUSH
61873: EMPTY
61874: ST_TO_ADDR
// mc_mines := [ ] ;
61875: LD_ADDR_EXP 97
61879: PUSH
61880: EMPTY
61881: ST_TO_ADDR
// mc_minefields := [ ] ;
61882: LD_ADDR_EXP 99
61886: PUSH
61887: EMPTY
61888: ST_TO_ADDR
// mc_crates := [ ] ;
61889: LD_ADDR_EXP 100
61893: PUSH
61894: EMPTY
61895: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61896: LD_ADDR_EXP 101
61900: PUSH
61901: EMPTY
61902: ST_TO_ADDR
// mc_crates_area := [ ] ;
61903: LD_ADDR_EXP 102
61907: PUSH
61908: EMPTY
61909: ST_TO_ADDR
// mc_vehicles := [ ] ;
61910: LD_ADDR_EXP 103
61914: PUSH
61915: EMPTY
61916: ST_TO_ADDR
// mc_attack := [ ] ;
61917: LD_ADDR_EXP 104
61921: PUSH
61922: EMPTY
61923: ST_TO_ADDR
// mc_produce := [ ] ;
61924: LD_ADDR_EXP 105
61928: PUSH
61929: EMPTY
61930: ST_TO_ADDR
// mc_defender := [ ] ;
61931: LD_ADDR_EXP 106
61935: PUSH
61936: EMPTY
61937: ST_TO_ADDR
// mc_parking := [ ] ;
61938: LD_ADDR_EXP 108
61942: PUSH
61943: EMPTY
61944: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61945: LD_ADDR_EXP 94
61949: PUSH
61950: EMPTY
61951: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61952: LD_ADDR_EXP 96
61956: PUSH
61957: EMPTY
61958: ST_TO_ADDR
// mc_scan := [ ] ;
61959: LD_ADDR_EXP 107
61963: PUSH
61964: EMPTY
61965: ST_TO_ADDR
// mc_scan_area := [ ] ;
61966: LD_ADDR_EXP 109
61970: PUSH
61971: EMPTY
61972: ST_TO_ADDR
// mc_tech := [ ] ;
61973: LD_ADDR_EXP 111
61977: PUSH
61978: EMPTY
61979: ST_TO_ADDR
// mc_class := [ ] ;
61980: LD_ADDR_EXP 125
61984: PUSH
61985: EMPTY
61986: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61987: LD_ADDR_EXP 126
61991: PUSH
61992: EMPTY
61993: ST_TO_ADDR
// end ;
61994: LD_VAR 0 1
61998: RET
// export function MC_Kill ( base ) ; begin
61999: LD_INT 0
62001: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
62002: LD_ADDR_EXP 84
62006: PUSH
62007: LD_EXP 84
62011: PPUSH
62012: LD_VAR 0 1
62016: PPUSH
62017: EMPTY
62018: PPUSH
62019: CALL_OW 1
62023: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62024: LD_ADDR_EXP 85
62028: PUSH
62029: LD_EXP 85
62033: PPUSH
62034: LD_VAR 0 1
62038: PPUSH
62039: EMPTY
62040: PPUSH
62041: CALL_OW 1
62045: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62046: LD_ADDR_EXP 86
62050: PUSH
62051: LD_EXP 86
62055: PPUSH
62056: LD_VAR 0 1
62060: PPUSH
62061: EMPTY
62062: PPUSH
62063: CALL_OW 1
62067: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62068: LD_ADDR_EXP 87
62072: PUSH
62073: LD_EXP 87
62077: PPUSH
62078: LD_VAR 0 1
62082: PPUSH
62083: EMPTY
62084: PPUSH
62085: CALL_OW 1
62089: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62090: LD_ADDR_EXP 88
62094: PUSH
62095: LD_EXP 88
62099: PPUSH
62100: LD_VAR 0 1
62104: PPUSH
62105: EMPTY
62106: PPUSH
62107: CALL_OW 1
62111: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62112: LD_ADDR_EXP 89
62116: PUSH
62117: LD_EXP 89
62121: PPUSH
62122: LD_VAR 0 1
62126: PPUSH
62127: EMPTY
62128: PPUSH
62129: CALL_OW 1
62133: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62134: LD_ADDR_EXP 90
62138: PUSH
62139: LD_EXP 90
62143: PPUSH
62144: LD_VAR 0 1
62148: PPUSH
62149: EMPTY
62150: PPUSH
62151: CALL_OW 1
62155: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62156: LD_ADDR_EXP 91
62160: PUSH
62161: LD_EXP 91
62165: PPUSH
62166: LD_VAR 0 1
62170: PPUSH
62171: EMPTY
62172: PPUSH
62173: CALL_OW 1
62177: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62178: LD_ADDR_EXP 92
62182: PUSH
62183: LD_EXP 92
62187: PPUSH
62188: LD_VAR 0 1
62192: PPUSH
62193: EMPTY
62194: PPUSH
62195: CALL_OW 1
62199: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62200: LD_ADDR_EXP 93
62204: PUSH
62205: LD_EXP 93
62209: PPUSH
62210: LD_VAR 0 1
62214: PPUSH
62215: EMPTY
62216: PPUSH
62217: CALL_OW 1
62221: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62222: LD_ADDR_EXP 94
62226: PUSH
62227: LD_EXP 94
62231: PPUSH
62232: LD_VAR 0 1
62236: PPUSH
62237: EMPTY
62238: PPUSH
62239: CALL_OW 1
62243: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62244: LD_ADDR_EXP 95
62248: PUSH
62249: LD_EXP 95
62253: PPUSH
62254: LD_VAR 0 1
62258: PPUSH
62259: LD_INT 0
62261: PPUSH
62262: CALL_OW 1
62266: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62267: LD_ADDR_EXP 96
62271: PUSH
62272: LD_EXP 96
62276: PPUSH
62277: LD_VAR 0 1
62281: PPUSH
62282: EMPTY
62283: PPUSH
62284: CALL_OW 1
62288: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62289: LD_ADDR_EXP 97
62293: PUSH
62294: LD_EXP 97
62298: PPUSH
62299: LD_VAR 0 1
62303: PPUSH
62304: EMPTY
62305: PPUSH
62306: CALL_OW 1
62310: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62311: LD_ADDR_EXP 98
62315: PUSH
62316: LD_EXP 98
62320: PPUSH
62321: LD_VAR 0 1
62325: PPUSH
62326: EMPTY
62327: PPUSH
62328: CALL_OW 1
62332: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62333: LD_ADDR_EXP 99
62337: PUSH
62338: LD_EXP 99
62342: PPUSH
62343: LD_VAR 0 1
62347: PPUSH
62348: EMPTY
62349: PPUSH
62350: CALL_OW 1
62354: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62355: LD_ADDR_EXP 100
62359: PUSH
62360: LD_EXP 100
62364: PPUSH
62365: LD_VAR 0 1
62369: PPUSH
62370: EMPTY
62371: PPUSH
62372: CALL_OW 1
62376: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62377: LD_ADDR_EXP 101
62381: PUSH
62382: LD_EXP 101
62386: PPUSH
62387: LD_VAR 0 1
62391: PPUSH
62392: EMPTY
62393: PPUSH
62394: CALL_OW 1
62398: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62399: LD_ADDR_EXP 102
62403: PUSH
62404: LD_EXP 102
62408: PPUSH
62409: LD_VAR 0 1
62413: PPUSH
62414: EMPTY
62415: PPUSH
62416: CALL_OW 1
62420: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62421: LD_ADDR_EXP 103
62425: PUSH
62426: LD_EXP 103
62430: PPUSH
62431: LD_VAR 0 1
62435: PPUSH
62436: EMPTY
62437: PPUSH
62438: CALL_OW 1
62442: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62443: LD_ADDR_EXP 104
62447: PUSH
62448: LD_EXP 104
62452: PPUSH
62453: LD_VAR 0 1
62457: PPUSH
62458: EMPTY
62459: PPUSH
62460: CALL_OW 1
62464: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62465: LD_ADDR_EXP 105
62469: PUSH
62470: LD_EXP 105
62474: PPUSH
62475: LD_VAR 0 1
62479: PPUSH
62480: EMPTY
62481: PPUSH
62482: CALL_OW 1
62486: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62487: LD_ADDR_EXP 106
62491: PUSH
62492: LD_EXP 106
62496: PPUSH
62497: LD_VAR 0 1
62501: PPUSH
62502: EMPTY
62503: PPUSH
62504: CALL_OW 1
62508: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62509: LD_ADDR_EXP 107
62513: PUSH
62514: LD_EXP 107
62518: PPUSH
62519: LD_VAR 0 1
62523: PPUSH
62524: EMPTY
62525: PPUSH
62526: CALL_OW 1
62530: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62531: LD_ADDR_EXP 108
62535: PUSH
62536: LD_EXP 108
62540: PPUSH
62541: LD_VAR 0 1
62545: PPUSH
62546: EMPTY
62547: PPUSH
62548: CALL_OW 1
62552: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62553: LD_ADDR_EXP 109
62557: PUSH
62558: LD_EXP 109
62562: PPUSH
62563: LD_VAR 0 1
62567: PPUSH
62568: EMPTY
62569: PPUSH
62570: CALL_OW 1
62574: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62575: LD_ADDR_EXP 111
62579: PUSH
62580: LD_EXP 111
62584: PPUSH
62585: LD_VAR 0 1
62589: PPUSH
62590: EMPTY
62591: PPUSH
62592: CALL_OW 1
62596: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62597: LD_ADDR_EXP 113
62601: PUSH
62602: LD_EXP 113
62606: PPUSH
62607: LD_VAR 0 1
62611: PPUSH
62612: EMPTY
62613: PPUSH
62614: CALL_OW 1
62618: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62619: LD_ADDR_EXP 114
62623: PUSH
62624: LD_EXP 114
62628: PPUSH
62629: LD_VAR 0 1
62633: PPUSH
62634: EMPTY
62635: PPUSH
62636: CALL_OW 1
62640: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62641: LD_ADDR_EXP 115
62645: PUSH
62646: LD_EXP 115
62650: PPUSH
62651: LD_VAR 0 1
62655: PPUSH
62656: EMPTY
62657: PPUSH
62658: CALL_OW 1
62662: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62663: LD_ADDR_EXP 116
62667: PUSH
62668: LD_EXP 116
62672: PPUSH
62673: LD_VAR 0 1
62677: PPUSH
62678: EMPTY
62679: PPUSH
62680: CALL_OW 1
62684: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62685: LD_ADDR_EXP 117
62689: PUSH
62690: LD_EXP 117
62694: PPUSH
62695: LD_VAR 0 1
62699: PPUSH
62700: EMPTY
62701: PPUSH
62702: CALL_OW 1
62706: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62707: LD_ADDR_EXP 118
62711: PUSH
62712: LD_EXP 118
62716: PPUSH
62717: LD_VAR 0 1
62721: PPUSH
62722: EMPTY
62723: PPUSH
62724: CALL_OW 1
62728: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62729: LD_ADDR_EXP 119
62733: PUSH
62734: LD_EXP 119
62738: PPUSH
62739: LD_VAR 0 1
62743: PPUSH
62744: EMPTY
62745: PPUSH
62746: CALL_OW 1
62750: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62751: LD_ADDR_EXP 120
62755: PUSH
62756: LD_EXP 120
62760: PPUSH
62761: LD_VAR 0 1
62765: PPUSH
62766: EMPTY
62767: PPUSH
62768: CALL_OW 1
62772: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62773: LD_ADDR_EXP 121
62777: PUSH
62778: LD_EXP 121
62782: PPUSH
62783: LD_VAR 0 1
62787: PPUSH
62788: EMPTY
62789: PPUSH
62790: CALL_OW 1
62794: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62795: LD_ADDR_EXP 122
62799: PUSH
62800: LD_EXP 122
62804: PPUSH
62805: LD_VAR 0 1
62809: PPUSH
62810: EMPTY
62811: PPUSH
62812: CALL_OW 1
62816: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62817: LD_ADDR_EXP 123
62821: PUSH
62822: LD_EXP 123
62826: PPUSH
62827: LD_VAR 0 1
62831: PPUSH
62832: EMPTY
62833: PPUSH
62834: CALL_OW 1
62838: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62839: LD_ADDR_EXP 124
62843: PUSH
62844: LD_EXP 124
62848: PPUSH
62849: LD_VAR 0 1
62853: PPUSH
62854: EMPTY
62855: PPUSH
62856: CALL_OW 1
62860: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62861: LD_ADDR_EXP 125
62865: PUSH
62866: LD_EXP 125
62870: PPUSH
62871: LD_VAR 0 1
62875: PPUSH
62876: EMPTY
62877: PPUSH
62878: CALL_OW 1
62882: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62883: LD_ADDR_EXP 126
62887: PUSH
62888: LD_EXP 126
62892: PPUSH
62893: LD_VAR 0 1
62897: PPUSH
62898: LD_INT 0
62900: PPUSH
62901: CALL_OW 1
62905: ST_TO_ADDR
// end ;
62906: LD_VAR 0 2
62910: RET
// export function MC_Add ( side , units ) ; var base ; begin
62911: LD_INT 0
62913: PPUSH
62914: PPUSH
// base := mc_bases + 1 ;
62915: LD_ADDR_VAR 0 4
62919: PUSH
62920: LD_EXP 84
62924: PUSH
62925: LD_INT 1
62927: PLUS
62928: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62929: LD_ADDR_EXP 110
62933: PUSH
62934: LD_EXP 110
62938: PPUSH
62939: LD_VAR 0 4
62943: PPUSH
62944: LD_VAR 0 1
62948: PPUSH
62949: CALL_OW 1
62953: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62954: LD_ADDR_EXP 84
62958: PUSH
62959: LD_EXP 84
62963: PPUSH
62964: LD_VAR 0 4
62968: PPUSH
62969: LD_VAR 0 2
62973: PPUSH
62974: CALL_OW 1
62978: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62979: LD_ADDR_EXP 85
62983: PUSH
62984: LD_EXP 85
62988: PPUSH
62989: LD_VAR 0 4
62993: PPUSH
62994: EMPTY
62995: PPUSH
62996: CALL_OW 1
63000: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
63001: LD_ADDR_EXP 86
63005: PUSH
63006: LD_EXP 86
63010: PPUSH
63011: LD_VAR 0 4
63015: PPUSH
63016: EMPTY
63017: PPUSH
63018: CALL_OW 1
63022: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
63023: LD_ADDR_EXP 87
63027: PUSH
63028: LD_EXP 87
63032: PPUSH
63033: LD_VAR 0 4
63037: PPUSH
63038: EMPTY
63039: PPUSH
63040: CALL_OW 1
63044: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
63045: LD_ADDR_EXP 88
63049: PUSH
63050: LD_EXP 88
63054: PPUSH
63055: LD_VAR 0 4
63059: PPUSH
63060: EMPTY
63061: PPUSH
63062: CALL_OW 1
63066: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
63067: LD_ADDR_EXP 89
63071: PUSH
63072: LD_EXP 89
63076: PPUSH
63077: LD_VAR 0 4
63081: PPUSH
63082: EMPTY
63083: PPUSH
63084: CALL_OW 1
63088: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
63089: LD_ADDR_EXP 90
63093: PUSH
63094: LD_EXP 90
63098: PPUSH
63099: LD_VAR 0 4
63103: PPUSH
63104: EMPTY
63105: PPUSH
63106: CALL_OW 1
63110: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
63111: LD_ADDR_EXP 91
63115: PUSH
63116: LD_EXP 91
63120: PPUSH
63121: LD_VAR 0 4
63125: PPUSH
63126: EMPTY
63127: PPUSH
63128: CALL_OW 1
63132: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
63133: LD_ADDR_EXP 92
63137: PUSH
63138: LD_EXP 92
63142: PPUSH
63143: LD_VAR 0 4
63147: PPUSH
63148: EMPTY
63149: PPUSH
63150: CALL_OW 1
63154: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
63155: LD_ADDR_EXP 93
63159: PUSH
63160: LD_EXP 93
63164: PPUSH
63165: LD_VAR 0 4
63169: PPUSH
63170: EMPTY
63171: PPUSH
63172: CALL_OW 1
63176: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
63177: LD_ADDR_EXP 94
63181: PUSH
63182: LD_EXP 94
63186: PPUSH
63187: LD_VAR 0 4
63191: PPUSH
63192: EMPTY
63193: PPUSH
63194: CALL_OW 1
63198: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
63199: LD_ADDR_EXP 95
63203: PUSH
63204: LD_EXP 95
63208: PPUSH
63209: LD_VAR 0 4
63213: PPUSH
63214: LD_INT 0
63216: PPUSH
63217: CALL_OW 1
63221: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
63222: LD_ADDR_EXP 96
63226: PUSH
63227: LD_EXP 96
63231: PPUSH
63232: LD_VAR 0 4
63236: PPUSH
63237: EMPTY
63238: PPUSH
63239: CALL_OW 1
63243: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
63244: LD_ADDR_EXP 97
63248: PUSH
63249: LD_EXP 97
63253: PPUSH
63254: LD_VAR 0 4
63258: PPUSH
63259: EMPTY
63260: PPUSH
63261: CALL_OW 1
63265: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
63266: LD_ADDR_EXP 98
63270: PUSH
63271: LD_EXP 98
63275: PPUSH
63276: LD_VAR 0 4
63280: PPUSH
63281: EMPTY
63282: PPUSH
63283: CALL_OW 1
63287: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
63288: LD_ADDR_EXP 99
63292: PUSH
63293: LD_EXP 99
63297: PPUSH
63298: LD_VAR 0 4
63302: PPUSH
63303: EMPTY
63304: PPUSH
63305: CALL_OW 1
63309: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
63310: LD_ADDR_EXP 100
63314: PUSH
63315: LD_EXP 100
63319: PPUSH
63320: LD_VAR 0 4
63324: PPUSH
63325: EMPTY
63326: PPUSH
63327: CALL_OW 1
63331: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
63332: LD_ADDR_EXP 101
63336: PUSH
63337: LD_EXP 101
63341: PPUSH
63342: LD_VAR 0 4
63346: PPUSH
63347: EMPTY
63348: PPUSH
63349: CALL_OW 1
63353: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
63354: LD_ADDR_EXP 102
63358: PUSH
63359: LD_EXP 102
63363: PPUSH
63364: LD_VAR 0 4
63368: PPUSH
63369: EMPTY
63370: PPUSH
63371: CALL_OW 1
63375: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
63376: LD_ADDR_EXP 103
63380: PUSH
63381: LD_EXP 103
63385: PPUSH
63386: LD_VAR 0 4
63390: PPUSH
63391: EMPTY
63392: PPUSH
63393: CALL_OW 1
63397: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
63398: LD_ADDR_EXP 104
63402: PUSH
63403: LD_EXP 104
63407: PPUSH
63408: LD_VAR 0 4
63412: PPUSH
63413: EMPTY
63414: PPUSH
63415: CALL_OW 1
63419: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
63420: LD_ADDR_EXP 105
63424: PUSH
63425: LD_EXP 105
63429: PPUSH
63430: LD_VAR 0 4
63434: PPUSH
63435: EMPTY
63436: PPUSH
63437: CALL_OW 1
63441: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
63442: LD_ADDR_EXP 106
63446: PUSH
63447: LD_EXP 106
63451: PPUSH
63452: LD_VAR 0 4
63456: PPUSH
63457: EMPTY
63458: PPUSH
63459: CALL_OW 1
63463: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
63464: LD_ADDR_EXP 107
63468: PUSH
63469: LD_EXP 107
63473: PPUSH
63474: LD_VAR 0 4
63478: PPUSH
63479: EMPTY
63480: PPUSH
63481: CALL_OW 1
63485: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63486: LD_ADDR_EXP 108
63490: PUSH
63491: LD_EXP 108
63495: PPUSH
63496: LD_VAR 0 4
63500: PPUSH
63501: EMPTY
63502: PPUSH
63503: CALL_OW 1
63507: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63508: LD_ADDR_EXP 109
63512: PUSH
63513: LD_EXP 109
63517: PPUSH
63518: LD_VAR 0 4
63522: PPUSH
63523: EMPTY
63524: PPUSH
63525: CALL_OW 1
63529: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63530: LD_ADDR_EXP 111
63534: PUSH
63535: LD_EXP 111
63539: PPUSH
63540: LD_VAR 0 4
63544: PPUSH
63545: EMPTY
63546: PPUSH
63547: CALL_OW 1
63551: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63552: LD_ADDR_EXP 113
63556: PUSH
63557: LD_EXP 113
63561: PPUSH
63562: LD_VAR 0 4
63566: PPUSH
63567: EMPTY
63568: PPUSH
63569: CALL_OW 1
63573: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63574: LD_ADDR_EXP 114
63578: PUSH
63579: LD_EXP 114
63583: PPUSH
63584: LD_VAR 0 4
63588: PPUSH
63589: EMPTY
63590: PPUSH
63591: CALL_OW 1
63595: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63596: LD_ADDR_EXP 115
63600: PUSH
63601: LD_EXP 115
63605: PPUSH
63606: LD_VAR 0 4
63610: PPUSH
63611: EMPTY
63612: PPUSH
63613: CALL_OW 1
63617: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63618: LD_ADDR_EXP 116
63622: PUSH
63623: LD_EXP 116
63627: PPUSH
63628: LD_VAR 0 4
63632: PPUSH
63633: EMPTY
63634: PPUSH
63635: CALL_OW 1
63639: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63640: LD_ADDR_EXP 117
63644: PUSH
63645: LD_EXP 117
63649: PPUSH
63650: LD_VAR 0 4
63654: PPUSH
63655: EMPTY
63656: PPUSH
63657: CALL_OW 1
63661: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63662: LD_ADDR_EXP 118
63666: PUSH
63667: LD_EXP 118
63671: PPUSH
63672: LD_VAR 0 4
63676: PPUSH
63677: EMPTY
63678: PPUSH
63679: CALL_OW 1
63683: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63684: LD_ADDR_EXP 119
63688: PUSH
63689: LD_EXP 119
63693: PPUSH
63694: LD_VAR 0 4
63698: PPUSH
63699: EMPTY
63700: PPUSH
63701: CALL_OW 1
63705: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63706: LD_ADDR_EXP 120
63710: PUSH
63711: LD_EXP 120
63715: PPUSH
63716: LD_VAR 0 4
63720: PPUSH
63721: EMPTY
63722: PPUSH
63723: CALL_OW 1
63727: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63728: LD_ADDR_EXP 121
63732: PUSH
63733: LD_EXP 121
63737: PPUSH
63738: LD_VAR 0 4
63742: PPUSH
63743: EMPTY
63744: PPUSH
63745: CALL_OW 1
63749: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63750: LD_ADDR_EXP 122
63754: PUSH
63755: LD_EXP 122
63759: PPUSH
63760: LD_VAR 0 4
63764: PPUSH
63765: EMPTY
63766: PPUSH
63767: CALL_OW 1
63771: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63772: LD_ADDR_EXP 123
63776: PUSH
63777: LD_EXP 123
63781: PPUSH
63782: LD_VAR 0 4
63786: PPUSH
63787: EMPTY
63788: PPUSH
63789: CALL_OW 1
63793: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63794: LD_ADDR_EXP 124
63798: PUSH
63799: LD_EXP 124
63803: PPUSH
63804: LD_VAR 0 4
63808: PPUSH
63809: EMPTY
63810: PPUSH
63811: CALL_OW 1
63815: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63816: LD_ADDR_EXP 125
63820: PUSH
63821: LD_EXP 125
63825: PPUSH
63826: LD_VAR 0 4
63830: PPUSH
63831: EMPTY
63832: PPUSH
63833: CALL_OW 1
63837: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63838: LD_ADDR_EXP 126
63842: PUSH
63843: LD_EXP 126
63847: PPUSH
63848: LD_VAR 0 4
63852: PPUSH
63853: LD_INT 0
63855: PPUSH
63856: CALL_OW 1
63860: ST_TO_ADDR
// result := base ;
63861: LD_ADDR_VAR 0 3
63865: PUSH
63866: LD_VAR 0 4
63870: ST_TO_ADDR
// end ;
63871: LD_VAR 0 3
63875: RET
// export function MC_Start ( ) ; var i ; begin
63876: LD_INT 0
63878: PPUSH
63879: PPUSH
// for i = 1 to mc_bases do
63880: LD_ADDR_VAR 0 2
63884: PUSH
63885: DOUBLE
63886: LD_INT 1
63888: DEC
63889: ST_TO_ADDR
63890: LD_EXP 84
63894: PUSH
63895: FOR_TO
63896: IFFALSE 64973
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63898: LD_ADDR_EXP 84
63902: PUSH
63903: LD_EXP 84
63907: PPUSH
63908: LD_VAR 0 2
63912: PPUSH
63913: LD_EXP 84
63917: PUSH
63918: LD_VAR 0 2
63922: ARRAY
63923: PUSH
63924: LD_INT 0
63926: DIFF
63927: PPUSH
63928: CALL_OW 1
63932: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63933: LD_ADDR_EXP 85
63937: PUSH
63938: LD_EXP 85
63942: PPUSH
63943: LD_VAR 0 2
63947: PPUSH
63948: EMPTY
63949: PPUSH
63950: CALL_OW 1
63954: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63955: LD_ADDR_EXP 86
63959: PUSH
63960: LD_EXP 86
63964: PPUSH
63965: LD_VAR 0 2
63969: PPUSH
63970: EMPTY
63971: PPUSH
63972: CALL_OW 1
63976: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63977: LD_ADDR_EXP 87
63981: PUSH
63982: LD_EXP 87
63986: PPUSH
63987: LD_VAR 0 2
63991: PPUSH
63992: EMPTY
63993: PPUSH
63994: CALL_OW 1
63998: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63999: LD_ADDR_EXP 88
64003: PUSH
64004: LD_EXP 88
64008: PPUSH
64009: LD_VAR 0 2
64013: PPUSH
64014: EMPTY
64015: PUSH
64016: EMPTY
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: PPUSH
64022: CALL_OW 1
64026: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
64027: LD_ADDR_EXP 89
64031: PUSH
64032: LD_EXP 89
64036: PPUSH
64037: LD_VAR 0 2
64041: PPUSH
64042: EMPTY
64043: PPUSH
64044: CALL_OW 1
64048: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
64049: LD_ADDR_EXP 116
64053: PUSH
64054: LD_EXP 116
64058: PPUSH
64059: LD_VAR 0 2
64063: PPUSH
64064: EMPTY
64065: PPUSH
64066: CALL_OW 1
64070: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
64071: LD_ADDR_EXP 90
64075: PUSH
64076: LD_EXP 90
64080: PPUSH
64081: LD_VAR 0 2
64085: PPUSH
64086: EMPTY
64087: PPUSH
64088: CALL_OW 1
64092: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
64093: LD_ADDR_EXP 91
64097: PUSH
64098: LD_EXP 91
64102: PPUSH
64103: LD_VAR 0 2
64107: PPUSH
64108: EMPTY
64109: PPUSH
64110: CALL_OW 1
64114: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
64115: LD_ADDR_EXP 92
64119: PUSH
64120: LD_EXP 92
64124: PPUSH
64125: LD_VAR 0 2
64129: PPUSH
64130: LD_EXP 84
64134: PUSH
64135: LD_VAR 0 2
64139: ARRAY
64140: PPUSH
64141: LD_INT 2
64143: PUSH
64144: LD_INT 30
64146: PUSH
64147: LD_INT 32
64149: PUSH
64150: EMPTY
64151: LIST
64152: LIST
64153: PUSH
64154: LD_INT 30
64156: PUSH
64157: LD_INT 33
64159: PUSH
64160: EMPTY
64161: LIST
64162: LIST
64163: PUSH
64164: EMPTY
64165: LIST
64166: LIST
64167: LIST
64168: PPUSH
64169: CALL_OW 72
64173: PPUSH
64174: CALL_OW 1
64178: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
64179: LD_ADDR_EXP 93
64183: PUSH
64184: LD_EXP 93
64188: PPUSH
64189: LD_VAR 0 2
64193: PPUSH
64194: LD_EXP 84
64198: PUSH
64199: LD_VAR 0 2
64203: ARRAY
64204: PPUSH
64205: LD_INT 2
64207: PUSH
64208: LD_INT 30
64210: PUSH
64211: LD_INT 32
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PUSH
64218: LD_INT 30
64220: PUSH
64221: LD_INT 31
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: LIST
64232: PUSH
64233: LD_INT 58
64235: PUSH
64236: EMPTY
64237: LIST
64238: PUSH
64239: EMPTY
64240: LIST
64241: LIST
64242: PPUSH
64243: CALL_OW 72
64247: PPUSH
64248: CALL_OW 1
64252: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
64253: LD_ADDR_EXP 94
64257: PUSH
64258: LD_EXP 94
64262: PPUSH
64263: LD_VAR 0 2
64267: PPUSH
64268: EMPTY
64269: PPUSH
64270: CALL_OW 1
64274: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
64275: LD_ADDR_EXP 98
64279: PUSH
64280: LD_EXP 98
64284: PPUSH
64285: LD_VAR 0 2
64289: PPUSH
64290: EMPTY
64291: PPUSH
64292: CALL_OW 1
64296: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
64297: LD_ADDR_EXP 97
64301: PUSH
64302: LD_EXP 97
64306: PPUSH
64307: LD_VAR 0 2
64311: PPUSH
64312: EMPTY
64313: PPUSH
64314: CALL_OW 1
64318: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
64319: LD_ADDR_EXP 99
64323: PUSH
64324: LD_EXP 99
64328: PPUSH
64329: LD_VAR 0 2
64333: PPUSH
64334: EMPTY
64335: PPUSH
64336: CALL_OW 1
64340: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
64341: LD_ADDR_EXP 100
64345: PUSH
64346: LD_EXP 100
64350: PPUSH
64351: LD_VAR 0 2
64355: PPUSH
64356: EMPTY
64357: PPUSH
64358: CALL_OW 1
64362: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64363: LD_ADDR_EXP 101
64367: PUSH
64368: LD_EXP 101
64372: PPUSH
64373: LD_VAR 0 2
64377: PPUSH
64378: EMPTY
64379: PPUSH
64380: CALL_OW 1
64384: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
64385: LD_ADDR_EXP 102
64389: PUSH
64390: LD_EXP 102
64394: PPUSH
64395: LD_VAR 0 2
64399: PPUSH
64400: EMPTY
64401: PPUSH
64402: CALL_OW 1
64406: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
64407: LD_ADDR_EXP 103
64411: PUSH
64412: LD_EXP 103
64416: PPUSH
64417: LD_VAR 0 2
64421: PPUSH
64422: EMPTY
64423: PPUSH
64424: CALL_OW 1
64428: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
64429: LD_ADDR_EXP 104
64433: PUSH
64434: LD_EXP 104
64438: PPUSH
64439: LD_VAR 0 2
64443: PPUSH
64444: EMPTY
64445: PPUSH
64446: CALL_OW 1
64450: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
64451: LD_ADDR_EXP 105
64455: PUSH
64456: LD_EXP 105
64460: PPUSH
64461: LD_VAR 0 2
64465: PPUSH
64466: EMPTY
64467: PPUSH
64468: CALL_OW 1
64472: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64473: LD_ADDR_EXP 106
64477: PUSH
64478: LD_EXP 106
64482: PPUSH
64483: LD_VAR 0 2
64487: PPUSH
64488: EMPTY
64489: PPUSH
64490: CALL_OW 1
64494: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
64495: LD_ADDR_EXP 95
64499: PUSH
64500: LD_EXP 95
64504: PPUSH
64505: LD_VAR 0 2
64509: PPUSH
64510: LD_INT 0
64512: PPUSH
64513: CALL_OW 1
64517: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
64518: LD_ADDR_EXP 108
64522: PUSH
64523: LD_EXP 108
64527: PPUSH
64528: LD_VAR 0 2
64532: PPUSH
64533: LD_INT 0
64535: PPUSH
64536: CALL_OW 1
64540: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
64541: LD_ADDR_EXP 96
64545: PUSH
64546: LD_EXP 96
64550: PPUSH
64551: LD_VAR 0 2
64555: PPUSH
64556: EMPTY
64557: PPUSH
64558: CALL_OW 1
64562: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
64563: LD_ADDR_EXP 107
64567: PUSH
64568: LD_EXP 107
64572: PPUSH
64573: LD_VAR 0 2
64577: PPUSH
64578: LD_INT 0
64580: PPUSH
64581: CALL_OW 1
64585: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
64586: LD_ADDR_EXP 109
64590: PUSH
64591: LD_EXP 109
64595: PPUSH
64596: LD_VAR 0 2
64600: PPUSH
64601: EMPTY
64602: PPUSH
64603: CALL_OW 1
64607: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
64608: LD_ADDR_EXP 112
64612: PUSH
64613: LD_EXP 112
64617: PPUSH
64618: LD_VAR 0 2
64622: PPUSH
64623: LD_INT 0
64625: PPUSH
64626: CALL_OW 1
64630: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
64631: LD_ADDR_EXP 113
64635: PUSH
64636: LD_EXP 113
64640: PPUSH
64641: LD_VAR 0 2
64645: PPUSH
64646: EMPTY
64647: PPUSH
64648: CALL_OW 1
64652: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
64653: LD_ADDR_EXP 114
64657: PUSH
64658: LD_EXP 114
64662: PPUSH
64663: LD_VAR 0 2
64667: PPUSH
64668: EMPTY
64669: PPUSH
64670: CALL_OW 1
64674: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64675: LD_ADDR_EXP 115
64679: PUSH
64680: LD_EXP 115
64684: PPUSH
64685: LD_VAR 0 2
64689: PPUSH
64690: EMPTY
64691: PPUSH
64692: CALL_OW 1
64696: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
64697: LD_ADDR_EXP 117
64701: PUSH
64702: LD_EXP 117
64706: PPUSH
64707: LD_VAR 0 2
64711: PPUSH
64712: LD_EXP 84
64716: PUSH
64717: LD_VAR 0 2
64721: ARRAY
64722: PPUSH
64723: LD_INT 2
64725: PUSH
64726: LD_INT 30
64728: PUSH
64729: LD_INT 6
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: PUSH
64736: LD_INT 30
64738: PUSH
64739: LD_INT 7
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: PUSH
64746: LD_INT 30
64748: PUSH
64749: LD_INT 8
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: LIST
64760: LIST
64761: PPUSH
64762: CALL_OW 72
64766: PPUSH
64767: CALL_OW 1
64771: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64772: LD_ADDR_EXP 118
64776: PUSH
64777: LD_EXP 118
64781: PPUSH
64782: LD_VAR 0 2
64786: PPUSH
64787: EMPTY
64788: PPUSH
64789: CALL_OW 1
64793: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64794: LD_ADDR_EXP 119
64798: PUSH
64799: LD_EXP 119
64803: PPUSH
64804: LD_VAR 0 2
64808: PPUSH
64809: EMPTY
64810: PPUSH
64811: CALL_OW 1
64815: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64816: LD_ADDR_EXP 120
64820: PUSH
64821: LD_EXP 120
64825: PPUSH
64826: LD_VAR 0 2
64830: PPUSH
64831: EMPTY
64832: PPUSH
64833: CALL_OW 1
64837: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64838: LD_ADDR_EXP 121
64842: PUSH
64843: LD_EXP 121
64847: PPUSH
64848: LD_VAR 0 2
64852: PPUSH
64853: EMPTY
64854: PPUSH
64855: CALL_OW 1
64859: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64860: LD_ADDR_EXP 122
64864: PUSH
64865: LD_EXP 122
64869: PPUSH
64870: LD_VAR 0 2
64874: PPUSH
64875: EMPTY
64876: PPUSH
64877: CALL_OW 1
64881: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64882: LD_ADDR_EXP 123
64886: PUSH
64887: LD_EXP 123
64891: PPUSH
64892: LD_VAR 0 2
64896: PPUSH
64897: EMPTY
64898: PPUSH
64899: CALL_OW 1
64903: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64904: LD_ADDR_EXP 124
64908: PUSH
64909: LD_EXP 124
64913: PPUSH
64914: LD_VAR 0 2
64918: PPUSH
64919: EMPTY
64920: PPUSH
64921: CALL_OW 1
64925: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64926: LD_ADDR_EXP 125
64930: PUSH
64931: LD_EXP 125
64935: PPUSH
64936: LD_VAR 0 2
64940: PPUSH
64941: EMPTY
64942: PPUSH
64943: CALL_OW 1
64947: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64948: LD_ADDR_EXP 126
64952: PUSH
64953: LD_EXP 126
64957: PPUSH
64958: LD_VAR 0 2
64962: PPUSH
64963: LD_INT 0
64965: PPUSH
64966: CALL_OW 1
64970: ST_TO_ADDR
// end ;
64971: GO 63895
64973: POP
64974: POP
// MC_InitSides ( ) ;
64975: CALL 65261 0 0
// MC_InitResearch ( ) ;
64979: CALL 65000 0 0
// CustomInitMacro ( ) ;
64983: CALL 0 0 0
// skirmish := true ;
64987: LD_ADDR_EXP 82
64991: PUSH
64992: LD_INT 1
64994: ST_TO_ADDR
// end ;
64995: LD_VAR 0 1
64999: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
65000: LD_INT 0
65002: PPUSH
65003: PPUSH
65004: PPUSH
65005: PPUSH
65006: PPUSH
65007: PPUSH
// if not mc_bases then
65008: LD_EXP 84
65012: NOT
65013: IFFALSE 65017
// exit ;
65015: GO 65256
// for i = 1 to 8 do
65017: LD_ADDR_VAR 0 2
65021: PUSH
65022: DOUBLE
65023: LD_INT 1
65025: DEC
65026: ST_TO_ADDR
65027: LD_INT 8
65029: PUSH
65030: FOR_TO
65031: IFFALSE 65057
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
65033: LD_ADDR_EXP 111
65037: PUSH
65038: LD_EXP 111
65042: PPUSH
65043: LD_VAR 0 2
65047: PPUSH
65048: EMPTY
65049: PPUSH
65050: CALL_OW 1
65054: ST_TO_ADDR
65055: GO 65030
65057: POP
65058: POP
// tmp := [ ] ;
65059: LD_ADDR_VAR 0 5
65063: PUSH
65064: EMPTY
65065: ST_TO_ADDR
// for i = 1 to mc_sides do
65066: LD_ADDR_VAR 0 2
65070: PUSH
65071: DOUBLE
65072: LD_INT 1
65074: DEC
65075: ST_TO_ADDR
65076: LD_EXP 110
65080: PUSH
65081: FOR_TO
65082: IFFALSE 65140
// if not mc_sides [ i ] in tmp then
65084: LD_EXP 110
65088: PUSH
65089: LD_VAR 0 2
65093: ARRAY
65094: PUSH
65095: LD_VAR 0 5
65099: IN
65100: NOT
65101: IFFALSE 65138
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
65103: LD_ADDR_VAR 0 5
65107: PUSH
65108: LD_VAR 0 5
65112: PPUSH
65113: LD_VAR 0 5
65117: PUSH
65118: LD_INT 1
65120: PLUS
65121: PPUSH
65122: LD_EXP 110
65126: PUSH
65127: LD_VAR 0 2
65131: ARRAY
65132: PPUSH
65133: CALL_OW 2
65137: ST_TO_ADDR
65138: GO 65081
65140: POP
65141: POP
// if not tmp then
65142: LD_VAR 0 5
65146: NOT
65147: IFFALSE 65151
// exit ;
65149: GO 65256
// for j in tmp do
65151: LD_ADDR_VAR 0 3
65155: PUSH
65156: LD_VAR 0 5
65160: PUSH
65161: FOR_IN
65162: IFFALSE 65254
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
65164: LD_ADDR_VAR 0 6
65168: PUSH
65169: LD_INT 22
65171: PUSH
65172: LD_VAR 0 3
65176: PUSH
65177: EMPTY
65178: LIST
65179: LIST
65180: PPUSH
65181: CALL_OW 69
65185: ST_TO_ADDR
// if not un then
65186: LD_VAR 0 6
65190: NOT
65191: IFFALSE 65195
// continue ;
65193: GO 65161
// nation := GetNation ( un [ 1 ] ) ;
65195: LD_ADDR_VAR 0 4
65199: PUSH
65200: LD_VAR 0 6
65204: PUSH
65205: LD_INT 1
65207: ARRAY
65208: PPUSH
65209: CALL_OW 248
65213: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
65214: LD_ADDR_EXP 111
65218: PUSH
65219: LD_EXP 111
65223: PPUSH
65224: LD_VAR 0 3
65228: PPUSH
65229: LD_VAR 0 3
65233: PPUSH
65234: LD_VAR 0 4
65238: PPUSH
65239: LD_INT 1
65241: PPUSH
65242: CALL 17574 0 3
65246: PPUSH
65247: CALL_OW 1
65251: ST_TO_ADDR
// end ;
65252: GO 65161
65254: POP
65255: POP
// end ;
65256: LD_VAR 0 1
65260: RET
// export function MC_InitSides ( ) ; var i ; begin
65261: LD_INT 0
65263: PPUSH
65264: PPUSH
// if not mc_bases then
65265: LD_EXP 84
65269: NOT
65270: IFFALSE 65274
// exit ;
65272: GO 65348
// for i = 1 to mc_bases do
65274: LD_ADDR_VAR 0 2
65278: PUSH
65279: DOUBLE
65280: LD_INT 1
65282: DEC
65283: ST_TO_ADDR
65284: LD_EXP 84
65288: PUSH
65289: FOR_TO
65290: IFFALSE 65346
// if mc_bases [ i ] then
65292: LD_EXP 84
65296: PUSH
65297: LD_VAR 0 2
65301: ARRAY
65302: IFFALSE 65344
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
65304: LD_ADDR_EXP 110
65308: PUSH
65309: LD_EXP 110
65313: PPUSH
65314: LD_VAR 0 2
65318: PPUSH
65319: LD_EXP 84
65323: PUSH
65324: LD_VAR 0 2
65328: ARRAY
65329: PUSH
65330: LD_INT 1
65332: ARRAY
65333: PPUSH
65334: CALL_OW 255
65338: PPUSH
65339: CALL_OW 1
65343: ST_TO_ADDR
65344: GO 65289
65346: POP
65347: POP
// end ;
65348: LD_VAR 0 1
65352: RET
// every 0 0$01 trigger skirmish do
65353: LD_EXP 82
65357: IFFALSE 65511
65359: GO 65361
65361: DISABLE
// begin enable ;
65362: ENABLE
// MC_CheckBuildings ( ) ;
65363: CALL 70009 0 0
// MC_CheckPeopleLife ( ) ;
65367: CALL 70134 0 0
// RaiseSailEvent ( 100 ) ;
65371: LD_INT 100
65373: PPUSH
65374: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
65378: LD_INT 103
65380: PPUSH
65381: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
65385: LD_INT 104
65387: PPUSH
65388: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
65392: LD_INT 105
65394: PPUSH
65395: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
65399: LD_INT 106
65401: PPUSH
65402: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
65406: LD_INT 107
65408: PPUSH
65409: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
65413: LD_INT 108
65415: PPUSH
65416: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
65420: LD_INT 109
65422: PPUSH
65423: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
65427: LD_INT 110
65429: PPUSH
65430: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
65434: LD_INT 111
65436: PPUSH
65437: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
65441: LD_INT 112
65443: PPUSH
65444: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
65448: LD_INT 113
65450: PPUSH
65451: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
65455: LD_INT 120
65457: PPUSH
65458: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
65462: LD_INT 121
65464: PPUSH
65465: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
65469: LD_INT 122
65471: PPUSH
65472: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
65476: LD_INT 123
65478: PPUSH
65479: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
65483: LD_INT 124
65485: PPUSH
65486: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
65490: LD_INT 125
65492: PPUSH
65493: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
65497: LD_INT 126
65499: PPUSH
65500: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
65504: LD_INT 200
65506: PPUSH
65507: CALL_OW 427
// end ;
65511: END
// on SailEvent ( event ) do begin if event < 100 then
65512: LD_VAR 0 1
65516: PUSH
65517: LD_INT 100
65519: LESS
65520: IFFALSE 65531
// CustomEvent ( event ) ;
65522: LD_VAR 0 1
65526: PPUSH
65527: CALL 8 0 1
// if event = 100 then
65531: LD_VAR 0 1
65535: PUSH
65536: LD_INT 100
65538: EQUAL
65539: IFFALSE 65545
// MC_ClassManager ( ) ;
65541: CALL 65937 0 0
// if event = 101 then
65545: LD_VAR 0 1
65549: PUSH
65550: LD_INT 101
65552: EQUAL
65553: IFFALSE 65559
// MC_RepairBuildings ( ) ;
65555: CALL 70719 0 0
// if event = 102 then
65559: LD_VAR 0 1
65563: PUSH
65564: LD_INT 102
65566: EQUAL
65567: IFFALSE 65573
// MC_Heal ( ) ;
65569: CALL 71604 0 0
// if event = 103 then
65573: LD_VAR 0 1
65577: PUSH
65578: LD_INT 103
65580: EQUAL
65581: IFFALSE 65587
// MC_Build ( ) ;
65583: CALL 72026 0 0
// if event = 104 then
65587: LD_VAR 0 1
65591: PUSH
65592: LD_INT 104
65594: EQUAL
65595: IFFALSE 65601
// MC_TurretWeapon ( ) ;
65597: CALL 73639 0 0
// if event = 105 then
65601: LD_VAR 0 1
65605: PUSH
65606: LD_INT 105
65608: EQUAL
65609: IFFALSE 65615
// MC_BuildUpgrade ( ) ;
65611: CALL 73190 0 0
// if event = 106 then
65615: LD_VAR 0 1
65619: PUSH
65620: LD_INT 106
65622: EQUAL
65623: IFFALSE 65629
// MC_PlantMines ( ) ;
65625: CALL 74069 0 0
// if event = 107 then
65629: LD_VAR 0 1
65633: PUSH
65634: LD_INT 107
65636: EQUAL
65637: IFFALSE 65643
// MC_CollectCrates ( ) ;
65639: CALL 74867 0 0
// if event = 108 then
65643: LD_VAR 0 1
65647: PUSH
65648: LD_INT 108
65650: EQUAL
65651: IFFALSE 65657
// MC_LinkRemoteControl ( ) ;
65653: CALL 76643 0 0
// if event = 109 then
65657: LD_VAR 0 1
65661: PUSH
65662: LD_INT 109
65664: EQUAL
65665: IFFALSE 65671
// MC_ProduceVehicle ( ) ;
65667: CALL 76824 0 0
// if event = 110 then
65671: LD_VAR 0 1
65675: PUSH
65676: LD_INT 110
65678: EQUAL
65679: IFFALSE 65685
// MC_SendAttack ( ) ;
65681: CALL 77290 0 0
// if event = 111 then
65685: LD_VAR 0 1
65689: PUSH
65690: LD_INT 111
65692: EQUAL
65693: IFFALSE 65699
// MC_Defend ( ) ;
65695: CALL 77398 0 0
// if event = 112 then
65699: LD_VAR 0 1
65703: PUSH
65704: LD_INT 112
65706: EQUAL
65707: IFFALSE 65713
// MC_Research ( ) ;
65709: CALL 78025 0 0
// if event = 113 then
65713: LD_VAR 0 1
65717: PUSH
65718: LD_INT 113
65720: EQUAL
65721: IFFALSE 65727
// MC_MinesTrigger ( ) ;
65723: CALL 79139 0 0
// if event = 120 then
65727: LD_VAR 0 1
65731: PUSH
65732: LD_INT 120
65734: EQUAL
65735: IFFALSE 65741
// MC_RepairVehicle ( ) ;
65737: CALL 79238 0 0
// if event = 121 then
65741: LD_VAR 0 1
65745: PUSH
65746: LD_INT 121
65748: EQUAL
65749: IFFALSE 65755
// MC_TameApe ( ) ;
65751: CALL 79968 0 0
// if event = 122 then
65755: LD_VAR 0 1
65759: PUSH
65760: LD_INT 122
65762: EQUAL
65763: IFFALSE 65769
// MC_ChangeApeClass ( ) ;
65765: CALL 80797 0 0
// if event = 123 then
65769: LD_VAR 0 1
65773: PUSH
65774: LD_INT 123
65776: EQUAL
65777: IFFALSE 65783
// MC_Bazooka ( ) ;
65779: CALL 81447 0 0
// if event = 124 then
65783: LD_VAR 0 1
65787: PUSH
65788: LD_INT 124
65790: EQUAL
65791: IFFALSE 65797
// MC_TeleportExit ( ) ;
65793: CALL 81645 0 0
// if event = 125 then
65797: LD_VAR 0 1
65801: PUSH
65802: LD_INT 125
65804: EQUAL
65805: IFFALSE 65811
// MC_Deposits ( ) ;
65807: CALL 82292 0 0
// if event = 126 then
65811: LD_VAR 0 1
65815: PUSH
65816: LD_INT 126
65818: EQUAL
65819: IFFALSE 65825
// MC_RemoteDriver ( ) ;
65821: CALL 82917 0 0
// if event = 200 then
65825: LD_VAR 0 1
65829: PUSH
65830: LD_INT 200
65832: EQUAL
65833: IFFALSE 65839
// MC_Idle ( ) ;
65835: CALL 84866 0 0
// end ;
65839: PPOPN 1
65841: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65842: LD_INT 0
65844: PPUSH
65845: PPUSH
// if not mc_bases [ base ] or not tag then
65846: LD_EXP 84
65850: PUSH
65851: LD_VAR 0 1
65855: ARRAY
65856: NOT
65857: PUSH
65858: LD_VAR 0 2
65862: NOT
65863: OR
65864: IFFALSE 65868
// exit ;
65866: GO 65932
// for i in mc_bases [ base ] union mc_ape [ base ] do
65868: LD_ADDR_VAR 0 4
65872: PUSH
65873: LD_EXP 84
65877: PUSH
65878: LD_VAR 0 1
65882: ARRAY
65883: PUSH
65884: LD_EXP 113
65888: PUSH
65889: LD_VAR 0 1
65893: ARRAY
65894: UNION
65895: PUSH
65896: FOR_IN
65897: IFFALSE 65930
// if GetTag ( i ) = tag then
65899: LD_VAR 0 4
65903: PPUSH
65904: CALL_OW 110
65908: PUSH
65909: LD_VAR 0 2
65913: EQUAL
65914: IFFALSE 65928
// SetTag ( i , 0 ) ;
65916: LD_VAR 0 4
65920: PPUSH
65921: LD_INT 0
65923: PPUSH
65924: CALL_OW 109
65928: GO 65896
65930: POP
65931: POP
// end ;
65932: LD_VAR 0 3
65936: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65937: LD_INT 0
65939: PPUSH
65940: PPUSH
65941: PPUSH
65942: PPUSH
65943: PPUSH
65944: PPUSH
65945: PPUSH
65946: PPUSH
// if not mc_bases then
65947: LD_EXP 84
65951: NOT
65952: IFFALSE 65956
// exit ;
65954: GO 66414
// for i = 1 to mc_bases do
65956: LD_ADDR_VAR 0 2
65960: PUSH
65961: DOUBLE
65962: LD_INT 1
65964: DEC
65965: ST_TO_ADDR
65966: LD_EXP 84
65970: PUSH
65971: FOR_TO
65972: IFFALSE 66412
// begin tmp := MC_ClassCheckReq ( i ) ;
65974: LD_ADDR_VAR 0 4
65978: PUSH
65979: LD_VAR 0 2
65983: PPUSH
65984: CALL 66419 0 1
65988: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65989: LD_ADDR_EXP 125
65993: PUSH
65994: LD_EXP 125
65998: PPUSH
65999: LD_VAR 0 2
66003: PPUSH
66004: LD_VAR 0 4
66008: PPUSH
66009: CALL_OW 1
66013: ST_TO_ADDR
// if not tmp then
66014: LD_VAR 0 4
66018: NOT
66019: IFFALSE 66023
// continue ;
66021: GO 65971
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
66023: LD_ADDR_VAR 0 6
66027: PUSH
66028: LD_EXP 84
66032: PUSH
66033: LD_VAR 0 2
66037: ARRAY
66038: PPUSH
66039: LD_INT 2
66041: PUSH
66042: LD_INT 30
66044: PUSH
66045: LD_INT 4
66047: PUSH
66048: EMPTY
66049: LIST
66050: LIST
66051: PUSH
66052: LD_INT 30
66054: PUSH
66055: LD_INT 5
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: LIST
66066: PPUSH
66067: CALL_OW 72
66071: PUSH
66072: LD_EXP 84
66076: PUSH
66077: LD_VAR 0 2
66081: ARRAY
66082: PPUSH
66083: LD_INT 2
66085: PUSH
66086: LD_INT 30
66088: PUSH
66089: LD_INT 0
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 30
66098: PUSH
66099: LD_INT 1
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: EMPTY
66107: LIST
66108: LIST
66109: LIST
66110: PPUSH
66111: CALL_OW 72
66115: PUSH
66116: LD_EXP 84
66120: PUSH
66121: LD_VAR 0 2
66125: ARRAY
66126: PPUSH
66127: LD_INT 30
66129: PUSH
66130: LD_INT 3
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PPUSH
66137: CALL_OW 72
66141: PUSH
66142: LD_EXP 84
66146: PUSH
66147: LD_VAR 0 2
66151: ARRAY
66152: PPUSH
66153: LD_INT 2
66155: PUSH
66156: LD_INT 30
66158: PUSH
66159: LD_INT 6
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 30
66168: PUSH
66169: LD_INT 7
66171: PUSH
66172: EMPTY
66173: LIST
66174: LIST
66175: PUSH
66176: LD_INT 30
66178: PUSH
66179: LD_INT 8
66181: PUSH
66182: EMPTY
66183: LIST
66184: LIST
66185: PUSH
66186: EMPTY
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: PPUSH
66192: CALL_OW 72
66196: PUSH
66197: EMPTY
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: ST_TO_ADDR
// for j = 1 to 4 do
66203: LD_ADDR_VAR 0 3
66207: PUSH
66208: DOUBLE
66209: LD_INT 1
66211: DEC
66212: ST_TO_ADDR
66213: LD_INT 4
66215: PUSH
66216: FOR_TO
66217: IFFALSE 66408
// begin if not tmp [ j ] then
66219: LD_VAR 0 4
66223: PUSH
66224: LD_VAR 0 3
66228: ARRAY
66229: NOT
66230: IFFALSE 66234
// continue ;
66232: GO 66216
// for p in tmp [ j ] do
66234: LD_ADDR_VAR 0 5
66238: PUSH
66239: LD_VAR 0 4
66243: PUSH
66244: LD_VAR 0 3
66248: ARRAY
66249: PUSH
66250: FOR_IN
66251: IFFALSE 66404
// begin if not b [ j ] then
66253: LD_VAR 0 6
66257: PUSH
66258: LD_VAR 0 3
66262: ARRAY
66263: NOT
66264: IFFALSE 66268
// break ;
66266: GO 66404
// e := 0 ;
66268: LD_ADDR_VAR 0 7
66272: PUSH
66273: LD_INT 0
66275: ST_TO_ADDR
// for k in b [ j ] do
66276: LD_ADDR_VAR 0 8
66280: PUSH
66281: LD_VAR 0 6
66285: PUSH
66286: LD_VAR 0 3
66290: ARRAY
66291: PUSH
66292: FOR_IN
66293: IFFALSE 66320
// if IsNotFull ( k ) then
66295: LD_VAR 0 8
66299: PPUSH
66300: CALL 19723 0 1
66304: IFFALSE 66318
// begin e := k ;
66306: LD_ADDR_VAR 0 7
66310: PUSH
66311: LD_VAR 0 8
66315: ST_TO_ADDR
// break ;
66316: GO 66320
// end ;
66318: GO 66292
66320: POP
66321: POP
// if e and not UnitGoingToBuilding ( p , e ) then
66322: LD_VAR 0 7
66326: PUSH
66327: LD_VAR 0 5
66331: PPUSH
66332: LD_VAR 0 7
66336: PPUSH
66337: CALL 52143 0 2
66341: NOT
66342: AND
66343: IFFALSE 66402
// begin if IsInUnit ( p ) then
66345: LD_VAR 0 5
66349: PPUSH
66350: CALL_OW 310
66354: IFFALSE 66365
// ComExitBuilding ( p ) ;
66356: LD_VAR 0 5
66360: PPUSH
66361: CALL_OW 122
// ComEnterUnit ( p , e ) ;
66365: LD_VAR 0 5
66369: PPUSH
66370: LD_VAR 0 7
66374: PPUSH
66375: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
66379: LD_VAR 0 5
66383: PPUSH
66384: LD_VAR 0 3
66388: PPUSH
66389: CALL_OW 183
// AddComExitBuilding ( p ) ;
66393: LD_VAR 0 5
66397: PPUSH
66398: CALL_OW 182
// end ; end ;
66402: GO 66250
66404: POP
66405: POP
// end ;
66406: GO 66216
66408: POP
66409: POP
// end ;
66410: GO 65971
66412: POP
66413: POP
// end ;
66414: LD_VAR 0 1
66418: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
66419: LD_INT 0
66421: PPUSH
66422: PPUSH
66423: PPUSH
66424: PPUSH
66425: PPUSH
66426: PPUSH
66427: PPUSH
66428: PPUSH
66429: PPUSH
66430: PPUSH
66431: PPUSH
66432: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66433: LD_VAR 0 1
66437: NOT
66438: PUSH
66439: LD_EXP 84
66443: PUSH
66444: LD_VAR 0 1
66448: ARRAY
66449: NOT
66450: OR
66451: PUSH
66452: LD_EXP 84
66456: PUSH
66457: LD_VAR 0 1
66461: ARRAY
66462: PPUSH
66463: LD_INT 2
66465: PUSH
66466: LD_INT 30
66468: PUSH
66469: LD_INT 0
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 30
66478: PUSH
66479: LD_INT 1
66481: PUSH
66482: EMPTY
66483: LIST
66484: LIST
66485: PUSH
66486: EMPTY
66487: LIST
66488: LIST
66489: LIST
66490: PPUSH
66491: CALL_OW 72
66495: NOT
66496: OR
66497: IFFALSE 66501
// exit ;
66499: GO 70004
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66501: LD_ADDR_VAR 0 4
66505: PUSH
66506: LD_EXP 84
66510: PUSH
66511: LD_VAR 0 1
66515: ARRAY
66516: PPUSH
66517: LD_INT 2
66519: PUSH
66520: LD_INT 25
66522: PUSH
66523: LD_INT 1
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: PUSH
66530: LD_INT 25
66532: PUSH
66533: LD_INT 2
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 25
66542: PUSH
66543: LD_INT 3
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 25
66552: PUSH
66553: LD_INT 4
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 25
66562: PUSH
66563: LD_INT 5
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 25
66572: PUSH
66573: LD_INT 8
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 25
66582: PUSH
66583: LD_INT 9
66585: PUSH
66586: EMPTY
66587: LIST
66588: LIST
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: LIST
66594: LIST
66595: LIST
66596: LIST
66597: LIST
66598: LIST
66599: PPUSH
66600: CALL_OW 72
66604: ST_TO_ADDR
// if not tmp then
66605: LD_VAR 0 4
66609: NOT
66610: IFFALSE 66614
// exit ;
66612: GO 70004
// for i in tmp do
66614: LD_ADDR_VAR 0 3
66618: PUSH
66619: LD_VAR 0 4
66623: PUSH
66624: FOR_IN
66625: IFFALSE 66656
// if GetTag ( i ) then
66627: LD_VAR 0 3
66631: PPUSH
66632: CALL_OW 110
66636: IFFALSE 66654
// tmp := tmp diff i ;
66638: LD_ADDR_VAR 0 4
66642: PUSH
66643: LD_VAR 0 4
66647: PUSH
66648: LD_VAR 0 3
66652: DIFF
66653: ST_TO_ADDR
66654: GO 66624
66656: POP
66657: POP
// if not tmp then
66658: LD_VAR 0 4
66662: NOT
66663: IFFALSE 66667
// exit ;
66665: GO 70004
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66667: LD_ADDR_VAR 0 5
66671: PUSH
66672: LD_EXP 84
66676: PUSH
66677: LD_VAR 0 1
66681: ARRAY
66682: PPUSH
66683: LD_INT 2
66685: PUSH
66686: LD_INT 25
66688: PUSH
66689: LD_INT 1
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: LD_INT 25
66698: PUSH
66699: LD_INT 5
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PUSH
66706: LD_INT 25
66708: PUSH
66709: LD_INT 8
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 25
66718: PUSH
66719: LD_INT 9
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: LIST
66732: PPUSH
66733: CALL_OW 72
66737: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66738: LD_ADDR_VAR 0 6
66742: PUSH
66743: LD_EXP 84
66747: PUSH
66748: LD_VAR 0 1
66752: ARRAY
66753: PPUSH
66754: LD_INT 25
66756: PUSH
66757: LD_INT 2
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PPUSH
66764: CALL_OW 72
66768: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66769: LD_ADDR_VAR 0 7
66773: PUSH
66774: LD_EXP 84
66778: PUSH
66779: LD_VAR 0 1
66783: ARRAY
66784: PPUSH
66785: LD_INT 25
66787: PUSH
66788: LD_INT 3
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PPUSH
66795: CALL_OW 72
66799: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66800: LD_ADDR_VAR 0 8
66804: PUSH
66805: LD_EXP 84
66809: PUSH
66810: LD_VAR 0 1
66814: ARRAY
66815: PPUSH
66816: LD_INT 25
66818: PUSH
66819: LD_INT 4
66821: PUSH
66822: EMPTY
66823: LIST
66824: LIST
66825: PUSH
66826: LD_INT 24
66828: PUSH
66829: LD_INT 251
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PPUSH
66840: CALL_OW 72
66844: ST_TO_ADDR
// if mc_scan [ base ] then
66845: LD_EXP 107
66849: PUSH
66850: LD_VAR 0 1
66854: ARRAY
66855: IFFALSE 67316
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66857: LD_ADDR_EXP 126
66861: PUSH
66862: LD_EXP 126
66866: PPUSH
66867: LD_VAR 0 1
66871: PPUSH
66872: LD_INT 4
66874: PPUSH
66875: CALL_OW 1
66879: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66880: LD_ADDR_VAR 0 12
66884: PUSH
66885: LD_EXP 84
66889: PUSH
66890: LD_VAR 0 1
66894: ARRAY
66895: PPUSH
66896: LD_INT 2
66898: PUSH
66899: LD_INT 30
66901: PUSH
66902: LD_INT 4
66904: PUSH
66905: EMPTY
66906: LIST
66907: LIST
66908: PUSH
66909: LD_INT 30
66911: PUSH
66912: LD_INT 5
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: LIST
66923: PPUSH
66924: CALL_OW 72
66928: ST_TO_ADDR
// if not b then
66929: LD_VAR 0 12
66933: NOT
66934: IFFALSE 66938
// exit ;
66936: GO 70004
// p := [ ] ;
66938: LD_ADDR_VAR 0 11
66942: PUSH
66943: EMPTY
66944: ST_TO_ADDR
// if sci >= 2 then
66945: LD_VAR 0 8
66949: PUSH
66950: LD_INT 2
66952: GREATEREQUAL
66953: IFFALSE 66984
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66955: LD_ADDR_VAR 0 8
66959: PUSH
66960: LD_VAR 0 8
66964: PUSH
66965: LD_INT 1
66967: ARRAY
66968: PUSH
66969: LD_VAR 0 8
66973: PUSH
66974: LD_INT 2
66976: ARRAY
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: ST_TO_ADDR
66982: GO 67045
// if sci = 1 then
66984: LD_VAR 0 8
66988: PUSH
66989: LD_INT 1
66991: EQUAL
66992: IFFALSE 67013
// sci := [ sci [ 1 ] ] else
66994: LD_ADDR_VAR 0 8
66998: PUSH
66999: LD_VAR 0 8
67003: PUSH
67004: LD_INT 1
67006: ARRAY
67007: PUSH
67008: EMPTY
67009: LIST
67010: ST_TO_ADDR
67011: GO 67045
// if sci = 0 then
67013: LD_VAR 0 8
67017: PUSH
67018: LD_INT 0
67020: EQUAL
67021: IFFALSE 67045
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
67023: LD_ADDR_VAR 0 11
67027: PUSH
67028: LD_VAR 0 4
67032: PPUSH
67033: LD_INT 4
67035: PPUSH
67036: CALL 52006 0 2
67040: PUSH
67041: LD_INT 1
67043: ARRAY
67044: ST_TO_ADDR
// if eng > 4 then
67045: LD_VAR 0 6
67049: PUSH
67050: LD_INT 4
67052: GREATER
67053: IFFALSE 67099
// for i = eng downto 4 do
67055: LD_ADDR_VAR 0 3
67059: PUSH
67060: DOUBLE
67061: LD_VAR 0 6
67065: INC
67066: ST_TO_ADDR
67067: LD_INT 4
67069: PUSH
67070: FOR_DOWNTO
67071: IFFALSE 67097
// eng := eng diff eng [ i ] ;
67073: LD_ADDR_VAR 0 6
67077: PUSH
67078: LD_VAR 0 6
67082: PUSH
67083: LD_VAR 0 6
67087: PUSH
67088: LD_VAR 0 3
67092: ARRAY
67093: DIFF
67094: ST_TO_ADDR
67095: GO 67070
67097: POP
67098: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
67099: LD_ADDR_VAR 0 4
67103: PUSH
67104: LD_VAR 0 4
67108: PUSH
67109: LD_VAR 0 5
67113: PUSH
67114: LD_VAR 0 6
67118: UNION
67119: PUSH
67120: LD_VAR 0 7
67124: UNION
67125: PUSH
67126: LD_VAR 0 8
67130: UNION
67131: DIFF
67132: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
67133: LD_ADDR_VAR 0 13
67137: PUSH
67138: LD_EXP 84
67142: PUSH
67143: LD_VAR 0 1
67147: ARRAY
67148: PPUSH
67149: LD_INT 2
67151: PUSH
67152: LD_INT 30
67154: PUSH
67155: LD_INT 32
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: LD_INT 30
67164: PUSH
67165: LD_INT 31
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: LIST
67176: PPUSH
67177: CALL_OW 72
67181: PUSH
67182: LD_EXP 84
67186: PUSH
67187: LD_VAR 0 1
67191: ARRAY
67192: PPUSH
67193: LD_INT 2
67195: PUSH
67196: LD_INT 30
67198: PUSH
67199: LD_INT 4
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: LD_INT 30
67208: PUSH
67209: LD_INT 5
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: LIST
67220: PPUSH
67221: CALL_OW 72
67225: PUSH
67226: LD_INT 6
67228: MUL
67229: PLUS
67230: ST_TO_ADDR
// if bcount < tmp then
67231: LD_VAR 0 13
67235: PUSH
67236: LD_VAR 0 4
67240: LESS
67241: IFFALSE 67287
// for i = tmp downto bcount do
67243: LD_ADDR_VAR 0 3
67247: PUSH
67248: DOUBLE
67249: LD_VAR 0 4
67253: INC
67254: ST_TO_ADDR
67255: LD_VAR 0 13
67259: PUSH
67260: FOR_DOWNTO
67261: IFFALSE 67285
// tmp := Delete ( tmp , tmp ) ;
67263: LD_ADDR_VAR 0 4
67267: PUSH
67268: LD_VAR 0 4
67272: PPUSH
67273: LD_VAR 0 4
67277: PPUSH
67278: CALL_OW 3
67282: ST_TO_ADDR
67283: GO 67260
67285: POP
67286: POP
// result := [ tmp , 0 , 0 , p ] ;
67287: LD_ADDR_VAR 0 2
67291: PUSH
67292: LD_VAR 0 4
67296: PUSH
67297: LD_INT 0
67299: PUSH
67300: LD_INT 0
67302: PUSH
67303: LD_VAR 0 11
67307: PUSH
67308: EMPTY
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: ST_TO_ADDR
// exit ;
67314: GO 70004
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67316: LD_EXP 84
67320: PUSH
67321: LD_VAR 0 1
67325: ARRAY
67326: PPUSH
67327: LD_INT 2
67329: PUSH
67330: LD_INT 30
67332: PUSH
67333: LD_INT 6
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 30
67342: PUSH
67343: LD_INT 7
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 30
67352: PUSH
67353: LD_INT 8
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: PPUSH
67366: CALL_OW 72
67370: NOT
67371: PUSH
67372: LD_EXP 84
67376: PUSH
67377: LD_VAR 0 1
67381: ARRAY
67382: PPUSH
67383: LD_INT 30
67385: PUSH
67386: LD_INT 3
67388: PUSH
67389: EMPTY
67390: LIST
67391: LIST
67392: PPUSH
67393: CALL_OW 72
67397: NOT
67398: AND
67399: IFFALSE 67471
// begin if eng = tmp then
67401: LD_VAR 0 6
67405: PUSH
67406: LD_VAR 0 4
67410: EQUAL
67411: IFFALSE 67415
// exit ;
67413: GO 70004
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
67415: LD_ADDR_EXP 126
67419: PUSH
67420: LD_EXP 126
67424: PPUSH
67425: LD_VAR 0 1
67429: PPUSH
67430: LD_INT 1
67432: PPUSH
67433: CALL_OW 1
67437: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
67438: LD_ADDR_VAR 0 2
67442: PUSH
67443: LD_INT 0
67445: PUSH
67446: LD_VAR 0 4
67450: PUSH
67451: LD_VAR 0 6
67455: DIFF
67456: PUSH
67457: LD_INT 0
67459: PUSH
67460: LD_INT 0
67462: PUSH
67463: EMPTY
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: ST_TO_ADDR
// exit ;
67469: GO 70004
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67471: LD_EXP 111
67475: PUSH
67476: LD_EXP 110
67480: PUSH
67481: LD_VAR 0 1
67485: ARRAY
67486: ARRAY
67487: PUSH
67488: LD_EXP 84
67492: PUSH
67493: LD_VAR 0 1
67497: ARRAY
67498: PPUSH
67499: LD_INT 2
67501: PUSH
67502: LD_INT 30
67504: PUSH
67505: LD_INT 6
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: PUSH
67512: LD_INT 30
67514: PUSH
67515: LD_INT 7
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: LD_INT 30
67524: PUSH
67525: LD_INT 8
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: PPUSH
67538: CALL_OW 72
67542: AND
67543: PUSH
67544: LD_EXP 84
67548: PUSH
67549: LD_VAR 0 1
67553: ARRAY
67554: PPUSH
67555: LD_INT 30
67557: PUSH
67558: LD_INT 3
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PPUSH
67565: CALL_OW 72
67569: NOT
67570: AND
67571: IFFALSE 67785
// begin if sci >= 6 then
67573: LD_VAR 0 8
67577: PUSH
67578: LD_INT 6
67580: GREATEREQUAL
67581: IFFALSE 67585
// exit ;
67583: GO 70004
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
67585: LD_ADDR_EXP 126
67589: PUSH
67590: LD_EXP 126
67594: PPUSH
67595: LD_VAR 0 1
67599: PPUSH
67600: LD_INT 2
67602: PPUSH
67603: CALL_OW 1
67607: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
67608: LD_ADDR_VAR 0 9
67612: PUSH
67613: LD_VAR 0 4
67617: PUSH
67618: LD_VAR 0 8
67622: DIFF
67623: PPUSH
67624: LD_INT 4
67626: PPUSH
67627: CALL 52006 0 2
67631: ST_TO_ADDR
// p := [ ] ;
67632: LD_ADDR_VAR 0 11
67636: PUSH
67637: EMPTY
67638: ST_TO_ADDR
// if sci < 6 and sort > 6 then
67639: LD_VAR 0 8
67643: PUSH
67644: LD_INT 6
67646: LESS
67647: PUSH
67648: LD_VAR 0 9
67652: PUSH
67653: LD_INT 6
67655: GREATER
67656: AND
67657: IFFALSE 67738
// begin for i = 1 to 6 - sci do
67659: LD_ADDR_VAR 0 3
67663: PUSH
67664: DOUBLE
67665: LD_INT 1
67667: DEC
67668: ST_TO_ADDR
67669: LD_INT 6
67671: PUSH
67672: LD_VAR 0 8
67676: MINUS
67677: PUSH
67678: FOR_TO
67679: IFFALSE 67734
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67681: LD_ADDR_VAR 0 11
67685: PUSH
67686: LD_VAR 0 11
67690: PPUSH
67691: LD_VAR 0 11
67695: PUSH
67696: LD_INT 1
67698: PLUS
67699: PPUSH
67700: LD_VAR 0 9
67704: PUSH
67705: LD_INT 1
67707: ARRAY
67708: PPUSH
67709: CALL_OW 2
67713: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67714: LD_ADDR_VAR 0 9
67718: PUSH
67719: LD_VAR 0 9
67723: PPUSH
67724: LD_INT 1
67726: PPUSH
67727: CALL_OW 3
67731: ST_TO_ADDR
// end ;
67732: GO 67678
67734: POP
67735: POP
// end else
67736: GO 67758
// if sort then
67738: LD_VAR 0 9
67742: IFFALSE 67758
// p := sort [ 1 ] ;
67744: LD_ADDR_VAR 0 11
67748: PUSH
67749: LD_VAR 0 9
67753: PUSH
67754: LD_INT 1
67756: ARRAY
67757: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67758: LD_ADDR_VAR 0 2
67762: PUSH
67763: LD_INT 0
67765: PUSH
67766: LD_INT 0
67768: PUSH
67769: LD_INT 0
67771: PUSH
67772: LD_VAR 0 11
67776: PUSH
67777: EMPTY
67778: LIST
67779: LIST
67780: LIST
67781: LIST
67782: ST_TO_ADDR
// exit ;
67783: GO 70004
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67785: LD_EXP 111
67789: PUSH
67790: LD_EXP 110
67794: PUSH
67795: LD_VAR 0 1
67799: ARRAY
67800: ARRAY
67801: PUSH
67802: LD_EXP 84
67806: PUSH
67807: LD_VAR 0 1
67811: ARRAY
67812: PPUSH
67813: LD_INT 2
67815: PUSH
67816: LD_INT 30
67818: PUSH
67819: LD_INT 6
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: LD_INT 30
67828: PUSH
67829: LD_INT 7
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: LD_INT 30
67838: PUSH
67839: LD_INT 8
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: PPUSH
67852: CALL_OW 72
67856: AND
67857: PUSH
67858: LD_EXP 84
67862: PUSH
67863: LD_VAR 0 1
67867: ARRAY
67868: PPUSH
67869: LD_INT 30
67871: PUSH
67872: LD_INT 3
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PPUSH
67879: CALL_OW 72
67883: AND
67884: IFFALSE 68618
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67886: LD_ADDR_EXP 126
67890: PUSH
67891: LD_EXP 126
67895: PPUSH
67896: LD_VAR 0 1
67900: PPUSH
67901: LD_INT 3
67903: PPUSH
67904: CALL_OW 1
67908: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67909: LD_ADDR_VAR 0 2
67913: PUSH
67914: LD_INT 0
67916: PUSH
67917: LD_INT 0
67919: PUSH
67920: LD_INT 0
67922: PUSH
67923: LD_INT 0
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: ST_TO_ADDR
// if not eng then
67932: LD_VAR 0 6
67936: NOT
67937: IFFALSE 68000
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67939: LD_ADDR_VAR 0 11
67943: PUSH
67944: LD_VAR 0 4
67948: PPUSH
67949: LD_INT 2
67951: PPUSH
67952: CALL 52006 0 2
67956: PUSH
67957: LD_INT 1
67959: ARRAY
67960: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67961: LD_ADDR_VAR 0 2
67965: PUSH
67966: LD_VAR 0 2
67970: PPUSH
67971: LD_INT 2
67973: PPUSH
67974: LD_VAR 0 11
67978: PPUSH
67979: CALL_OW 1
67983: ST_TO_ADDR
// tmp := tmp diff p ;
67984: LD_ADDR_VAR 0 4
67988: PUSH
67989: LD_VAR 0 4
67993: PUSH
67994: LD_VAR 0 11
67998: DIFF
67999: ST_TO_ADDR
// end ; if tmp and sci < 6 then
68000: LD_VAR 0 4
68004: PUSH
68005: LD_VAR 0 8
68009: PUSH
68010: LD_INT 6
68012: LESS
68013: AND
68014: IFFALSE 68202
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
68016: LD_ADDR_VAR 0 9
68020: PUSH
68021: LD_VAR 0 4
68025: PUSH
68026: LD_VAR 0 8
68030: PUSH
68031: LD_VAR 0 7
68035: UNION
68036: DIFF
68037: PPUSH
68038: LD_INT 4
68040: PPUSH
68041: CALL 52006 0 2
68045: ST_TO_ADDR
// p := [ ] ;
68046: LD_ADDR_VAR 0 11
68050: PUSH
68051: EMPTY
68052: ST_TO_ADDR
// if sort then
68053: LD_VAR 0 9
68057: IFFALSE 68173
// for i = 1 to 6 - sci do
68059: LD_ADDR_VAR 0 3
68063: PUSH
68064: DOUBLE
68065: LD_INT 1
68067: DEC
68068: ST_TO_ADDR
68069: LD_INT 6
68071: PUSH
68072: LD_VAR 0 8
68076: MINUS
68077: PUSH
68078: FOR_TO
68079: IFFALSE 68171
// begin if i = sort then
68081: LD_VAR 0 3
68085: PUSH
68086: LD_VAR 0 9
68090: EQUAL
68091: IFFALSE 68095
// break ;
68093: GO 68171
// if GetClass ( i ) = 4 then
68095: LD_VAR 0 3
68099: PPUSH
68100: CALL_OW 257
68104: PUSH
68105: LD_INT 4
68107: EQUAL
68108: IFFALSE 68112
// continue ;
68110: GO 68078
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68112: LD_ADDR_VAR 0 11
68116: PUSH
68117: LD_VAR 0 11
68121: PPUSH
68122: LD_VAR 0 11
68126: PUSH
68127: LD_INT 1
68129: PLUS
68130: PPUSH
68131: LD_VAR 0 9
68135: PUSH
68136: LD_VAR 0 3
68140: ARRAY
68141: PPUSH
68142: CALL_OW 2
68146: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68147: LD_ADDR_VAR 0 4
68151: PUSH
68152: LD_VAR 0 4
68156: PUSH
68157: LD_VAR 0 9
68161: PUSH
68162: LD_VAR 0 3
68166: ARRAY
68167: DIFF
68168: ST_TO_ADDR
// end ;
68169: GO 68078
68171: POP
68172: POP
// if p then
68173: LD_VAR 0 11
68177: IFFALSE 68202
// result := Replace ( result , 4 , p ) ;
68179: LD_ADDR_VAR 0 2
68183: PUSH
68184: LD_VAR 0 2
68188: PPUSH
68189: LD_INT 4
68191: PPUSH
68192: LD_VAR 0 11
68196: PPUSH
68197: CALL_OW 1
68201: ST_TO_ADDR
// end ; if tmp and mech < 6 then
68202: LD_VAR 0 4
68206: PUSH
68207: LD_VAR 0 7
68211: PUSH
68212: LD_INT 6
68214: LESS
68215: AND
68216: IFFALSE 68404
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68218: LD_ADDR_VAR 0 9
68222: PUSH
68223: LD_VAR 0 4
68227: PUSH
68228: LD_VAR 0 8
68232: PUSH
68233: LD_VAR 0 7
68237: UNION
68238: DIFF
68239: PPUSH
68240: LD_INT 3
68242: PPUSH
68243: CALL 52006 0 2
68247: ST_TO_ADDR
// p := [ ] ;
68248: LD_ADDR_VAR 0 11
68252: PUSH
68253: EMPTY
68254: ST_TO_ADDR
// if sort then
68255: LD_VAR 0 9
68259: IFFALSE 68375
// for i = 1 to 6 - mech do
68261: LD_ADDR_VAR 0 3
68265: PUSH
68266: DOUBLE
68267: LD_INT 1
68269: DEC
68270: ST_TO_ADDR
68271: LD_INT 6
68273: PUSH
68274: LD_VAR 0 7
68278: MINUS
68279: PUSH
68280: FOR_TO
68281: IFFALSE 68373
// begin if i = sort then
68283: LD_VAR 0 3
68287: PUSH
68288: LD_VAR 0 9
68292: EQUAL
68293: IFFALSE 68297
// break ;
68295: GO 68373
// if GetClass ( i ) = 3 then
68297: LD_VAR 0 3
68301: PPUSH
68302: CALL_OW 257
68306: PUSH
68307: LD_INT 3
68309: EQUAL
68310: IFFALSE 68314
// continue ;
68312: GO 68280
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68314: LD_ADDR_VAR 0 11
68318: PUSH
68319: LD_VAR 0 11
68323: PPUSH
68324: LD_VAR 0 11
68328: PUSH
68329: LD_INT 1
68331: PLUS
68332: PPUSH
68333: LD_VAR 0 9
68337: PUSH
68338: LD_VAR 0 3
68342: ARRAY
68343: PPUSH
68344: CALL_OW 2
68348: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68349: LD_ADDR_VAR 0 4
68353: PUSH
68354: LD_VAR 0 4
68358: PUSH
68359: LD_VAR 0 9
68363: PUSH
68364: LD_VAR 0 3
68368: ARRAY
68369: DIFF
68370: ST_TO_ADDR
// end ;
68371: GO 68280
68373: POP
68374: POP
// if p then
68375: LD_VAR 0 11
68379: IFFALSE 68404
// result := Replace ( result , 3 , p ) ;
68381: LD_ADDR_VAR 0 2
68385: PUSH
68386: LD_VAR 0 2
68390: PPUSH
68391: LD_INT 3
68393: PPUSH
68394: LD_VAR 0 11
68398: PPUSH
68399: CALL_OW 1
68403: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
68404: LD_VAR 0 4
68408: PUSH
68409: LD_INT 6
68411: GREATER
68412: PUSH
68413: LD_VAR 0 6
68417: PUSH
68418: LD_INT 6
68420: LESS
68421: AND
68422: IFFALSE 68616
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68424: LD_ADDR_VAR 0 9
68428: PUSH
68429: LD_VAR 0 4
68433: PUSH
68434: LD_VAR 0 8
68438: PUSH
68439: LD_VAR 0 7
68443: UNION
68444: PUSH
68445: LD_VAR 0 6
68449: UNION
68450: DIFF
68451: PPUSH
68452: LD_INT 2
68454: PPUSH
68455: CALL 52006 0 2
68459: ST_TO_ADDR
// p := [ ] ;
68460: LD_ADDR_VAR 0 11
68464: PUSH
68465: EMPTY
68466: ST_TO_ADDR
// if sort then
68467: LD_VAR 0 9
68471: IFFALSE 68587
// for i = 1 to 6 - eng do
68473: LD_ADDR_VAR 0 3
68477: PUSH
68478: DOUBLE
68479: LD_INT 1
68481: DEC
68482: ST_TO_ADDR
68483: LD_INT 6
68485: PUSH
68486: LD_VAR 0 6
68490: MINUS
68491: PUSH
68492: FOR_TO
68493: IFFALSE 68585
// begin if i = sort then
68495: LD_VAR 0 3
68499: PUSH
68500: LD_VAR 0 9
68504: EQUAL
68505: IFFALSE 68509
// break ;
68507: GO 68585
// if GetClass ( i ) = 2 then
68509: LD_VAR 0 3
68513: PPUSH
68514: CALL_OW 257
68518: PUSH
68519: LD_INT 2
68521: EQUAL
68522: IFFALSE 68526
// continue ;
68524: GO 68492
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68526: LD_ADDR_VAR 0 11
68530: PUSH
68531: LD_VAR 0 11
68535: PPUSH
68536: LD_VAR 0 11
68540: PUSH
68541: LD_INT 1
68543: PLUS
68544: PPUSH
68545: LD_VAR 0 9
68549: PUSH
68550: LD_VAR 0 3
68554: ARRAY
68555: PPUSH
68556: CALL_OW 2
68560: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68561: LD_ADDR_VAR 0 4
68565: PUSH
68566: LD_VAR 0 4
68570: PUSH
68571: LD_VAR 0 9
68575: PUSH
68576: LD_VAR 0 3
68580: ARRAY
68581: DIFF
68582: ST_TO_ADDR
// end ;
68583: GO 68492
68585: POP
68586: POP
// if p then
68587: LD_VAR 0 11
68591: IFFALSE 68616
// result := Replace ( result , 2 , p ) ;
68593: LD_ADDR_VAR 0 2
68597: PUSH
68598: LD_VAR 0 2
68602: PPUSH
68603: LD_INT 2
68605: PPUSH
68606: LD_VAR 0 11
68610: PPUSH
68611: CALL_OW 1
68615: ST_TO_ADDR
// end ; exit ;
68616: GO 70004
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
68618: LD_EXP 111
68622: PUSH
68623: LD_EXP 110
68627: PUSH
68628: LD_VAR 0 1
68632: ARRAY
68633: ARRAY
68634: NOT
68635: PUSH
68636: LD_EXP 84
68640: PUSH
68641: LD_VAR 0 1
68645: ARRAY
68646: PPUSH
68647: LD_INT 30
68649: PUSH
68650: LD_INT 3
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PPUSH
68657: CALL_OW 72
68661: AND
68662: PUSH
68663: LD_EXP 89
68667: PUSH
68668: LD_VAR 0 1
68672: ARRAY
68673: AND
68674: IFFALSE 69282
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68676: LD_ADDR_EXP 126
68680: PUSH
68681: LD_EXP 126
68685: PPUSH
68686: LD_VAR 0 1
68690: PPUSH
68691: LD_INT 5
68693: PPUSH
68694: CALL_OW 1
68698: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68699: LD_ADDR_VAR 0 2
68703: PUSH
68704: LD_INT 0
68706: PUSH
68707: LD_INT 0
68709: PUSH
68710: LD_INT 0
68712: PUSH
68713: LD_INT 0
68715: PUSH
68716: EMPTY
68717: LIST
68718: LIST
68719: LIST
68720: LIST
68721: ST_TO_ADDR
// if sci > 1 then
68722: LD_VAR 0 8
68726: PUSH
68727: LD_INT 1
68729: GREATER
68730: IFFALSE 68758
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68732: LD_ADDR_VAR 0 4
68736: PUSH
68737: LD_VAR 0 4
68741: PUSH
68742: LD_VAR 0 8
68746: PUSH
68747: LD_VAR 0 8
68751: PUSH
68752: LD_INT 1
68754: ARRAY
68755: DIFF
68756: DIFF
68757: ST_TO_ADDR
// if tmp and not sci then
68758: LD_VAR 0 4
68762: PUSH
68763: LD_VAR 0 8
68767: NOT
68768: AND
68769: IFFALSE 68838
// begin sort := SortBySkill ( tmp , 4 ) ;
68771: LD_ADDR_VAR 0 9
68775: PUSH
68776: LD_VAR 0 4
68780: PPUSH
68781: LD_INT 4
68783: PPUSH
68784: CALL 52006 0 2
68788: ST_TO_ADDR
// if sort then
68789: LD_VAR 0 9
68793: IFFALSE 68809
// p := sort [ 1 ] ;
68795: LD_ADDR_VAR 0 11
68799: PUSH
68800: LD_VAR 0 9
68804: PUSH
68805: LD_INT 1
68807: ARRAY
68808: ST_TO_ADDR
// if p then
68809: LD_VAR 0 11
68813: IFFALSE 68838
// result := Replace ( result , 4 , p ) ;
68815: LD_ADDR_VAR 0 2
68819: PUSH
68820: LD_VAR 0 2
68824: PPUSH
68825: LD_INT 4
68827: PPUSH
68828: LD_VAR 0 11
68832: PPUSH
68833: CALL_OW 1
68837: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68838: LD_ADDR_VAR 0 4
68842: PUSH
68843: LD_VAR 0 4
68847: PUSH
68848: LD_VAR 0 7
68852: DIFF
68853: ST_TO_ADDR
// if tmp and mech < 6 then
68854: LD_VAR 0 4
68858: PUSH
68859: LD_VAR 0 7
68863: PUSH
68864: LD_INT 6
68866: LESS
68867: AND
68868: IFFALSE 69056
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68870: LD_ADDR_VAR 0 9
68874: PUSH
68875: LD_VAR 0 4
68879: PUSH
68880: LD_VAR 0 8
68884: PUSH
68885: LD_VAR 0 7
68889: UNION
68890: DIFF
68891: PPUSH
68892: LD_INT 3
68894: PPUSH
68895: CALL 52006 0 2
68899: ST_TO_ADDR
// p := [ ] ;
68900: LD_ADDR_VAR 0 11
68904: PUSH
68905: EMPTY
68906: ST_TO_ADDR
// if sort then
68907: LD_VAR 0 9
68911: IFFALSE 69027
// for i = 1 to 6 - mech do
68913: LD_ADDR_VAR 0 3
68917: PUSH
68918: DOUBLE
68919: LD_INT 1
68921: DEC
68922: ST_TO_ADDR
68923: LD_INT 6
68925: PUSH
68926: LD_VAR 0 7
68930: MINUS
68931: PUSH
68932: FOR_TO
68933: IFFALSE 69025
// begin if i = sort then
68935: LD_VAR 0 3
68939: PUSH
68940: LD_VAR 0 9
68944: EQUAL
68945: IFFALSE 68949
// break ;
68947: GO 69025
// if GetClass ( i ) = 3 then
68949: LD_VAR 0 3
68953: PPUSH
68954: CALL_OW 257
68958: PUSH
68959: LD_INT 3
68961: EQUAL
68962: IFFALSE 68966
// continue ;
68964: GO 68932
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68966: LD_ADDR_VAR 0 11
68970: PUSH
68971: LD_VAR 0 11
68975: PPUSH
68976: LD_VAR 0 11
68980: PUSH
68981: LD_INT 1
68983: PLUS
68984: PPUSH
68985: LD_VAR 0 9
68989: PUSH
68990: LD_VAR 0 3
68994: ARRAY
68995: PPUSH
68996: CALL_OW 2
69000: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69001: LD_ADDR_VAR 0 4
69005: PUSH
69006: LD_VAR 0 4
69010: PUSH
69011: LD_VAR 0 9
69015: PUSH
69016: LD_VAR 0 3
69020: ARRAY
69021: DIFF
69022: ST_TO_ADDR
// end ;
69023: GO 68932
69025: POP
69026: POP
// if p then
69027: LD_VAR 0 11
69031: IFFALSE 69056
// result := Replace ( result , 3 , p ) ;
69033: LD_ADDR_VAR 0 2
69037: PUSH
69038: LD_VAR 0 2
69042: PPUSH
69043: LD_INT 3
69045: PPUSH
69046: LD_VAR 0 11
69050: PPUSH
69051: CALL_OW 1
69055: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69056: LD_ADDR_VAR 0 4
69060: PUSH
69061: LD_VAR 0 4
69065: PUSH
69066: LD_VAR 0 6
69070: DIFF
69071: ST_TO_ADDR
// if tmp and eng < 6 then
69072: LD_VAR 0 4
69076: PUSH
69077: LD_VAR 0 6
69081: PUSH
69082: LD_INT 6
69084: LESS
69085: AND
69086: IFFALSE 69280
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
69088: LD_ADDR_VAR 0 9
69092: PUSH
69093: LD_VAR 0 4
69097: PUSH
69098: LD_VAR 0 8
69102: PUSH
69103: LD_VAR 0 7
69107: UNION
69108: PUSH
69109: LD_VAR 0 6
69113: UNION
69114: DIFF
69115: PPUSH
69116: LD_INT 2
69118: PPUSH
69119: CALL 52006 0 2
69123: ST_TO_ADDR
// p := [ ] ;
69124: LD_ADDR_VAR 0 11
69128: PUSH
69129: EMPTY
69130: ST_TO_ADDR
// if sort then
69131: LD_VAR 0 9
69135: IFFALSE 69251
// for i = 1 to 6 - eng do
69137: LD_ADDR_VAR 0 3
69141: PUSH
69142: DOUBLE
69143: LD_INT 1
69145: DEC
69146: ST_TO_ADDR
69147: LD_INT 6
69149: PUSH
69150: LD_VAR 0 6
69154: MINUS
69155: PUSH
69156: FOR_TO
69157: IFFALSE 69249
// begin if i = sort then
69159: LD_VAR 0 3
69163: PUSH
69164: LD_VAR 0 9
69168: EQUAL
69169: IFFALSE 69173
// break ;
69171: GO 69249
// if GetClass ( i ) = 2 then
69173: LD_VAR 0 3
69177: PPUSH
69178: CALL_OW 257
69182: PUSH
69183: LD_INT 2
69185: EQUAL
69186: IFFALSE 69190
// continue ;
69188: GO 69156
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69190: LD_ADDR_VAR 0 11
69194: PUSH
69195: LD_VAR 0 11
69199: PPUSH
69200: LD_VAR 0 11
69204: PUSH
69205: LD_INT 1
69207: PLUS
69208: PPUSH
69209: LD_VAR 0 9
69213: PUSH
69214: LD_VAR 0 3
69218: ARRAY
69219: PPUSH
69220: CALL_OW 2
69224: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69225: LD_ADDR_VAR 0 4
69229: PUSH
69230: LD_VAR 0 4
69234: PUSH
69235: LD_VAR 0 9
69239: PUSH
69240: LD_VAR 0 3
69244: ARRAY
69245: DIFF
69246: ST_TO_ADDR
// end ;
69247: GO 69156
69249: POP
69250: POP
// if p then
69251: LD_VAR 0 11
69255: IFFALSE 69280
// result := Replace ( result , 2 , p ) ;
69257: LD_ADDR_VAR 0 2
69261: PUSH
69262: LD_VAR 0 2
69266: PPUSH
69267: LD_INT 2
69269: PPUSH
69270: LD_VAR 0 11
69274: PPUSH
69275: CALL_OW 1
69279: ST_TO_ADDR
// end ; exit ;
69280: GO 70004
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
69282: LD_EXP 111
69286: PUSH
69287: LD_EXP 110
69291: PUSH
69292: LD_VAR 0 1
69296: ARRAY
69297: ARRAY
69298: NOT
69299: PUSH
69300: LD_EXP 84
69304: PUSH
69305: LD_VAR 0 1
69309: ARRAY
69310: PPUSH
69311: LD_INT 30
69313: PUSH
69314: LD_INT 3
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PPUSH
69321: CALL_OW 72
69325: AND
69326: PUSH
69327: LD_EXP 89
69331: PUSH
69332: LD_VAR 0 1
69336: ARRAY
69337: NOT
69338: AND
69339: IFFALSE 70004
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
69341: LD_ADDR_EXP 126
69345: PUSH
69346: LD_EXP 126
69350: PPUSH
69351: LD_VAR 0 1
69355: PPUSH
69356: LD_INT 6
69358: PPUSH
69359: CALL_OW 1
69363: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
69364: LD_ADDR_VAR 0 2
69368: PUSH
69369: LD_INT 0
69371: PUSH
69372: LD_INT 0
69374: PUSH
69375: LD_INT 0
69377: PUSH
69378: LD_INT 0
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: LIST
69385: LIST
69386: ST_TO_ADDR
// if sci >= 1 then
69387: LD_VAR 0 8
69391: PUSH
69392: LD_INT 1
69394: GREATEREQUAL
69395: IFFALSE 69417
// tmp := tmp diff sci [ 1 ] ;
69397: LD_ADDR_VAR 0 4
69401: PUSH
69402: LD_VAR 0 4
69406: PUSH
69407: LD_VAR 0 8
69411: PUSH
69412: LD_INT 1
69414: ARRAY
69415: DIFF
69416: ST_TO_ADDR
// if tmp and not sci then
69417: LD_VAR 0 4
69421: PUSH
69422: LD_VAR 0 8
69426: NOT
69427: AND
69428: IFFALSE 69497
// begin sort := SortBySkill ( tmp , 4 ) ;
69430: LD_ADDR_VAR 0 9
69434: PUSH
69435: LD_VAR 0 4
69439: PPUSH
69440: LD_INT 4
69442: PPUSH
69443: CALL 52006 0 2
69447: ST_TO_ADDR
// if sort then
69448: LD_VAR 0 9
69452: IFFALSE 69468
// p := sort [ 1 ] ;
69454: LD_ADDR_VAR 0 11
69458: PUSH
69459: LD_VAR 0 9
69463: PUSH
69464: LD_INT 1
69466: ARRAY
69467: ST_TO_ADDR
// if p then
69468: LD_VAR 0 11
69472: IFFALSE 69497
// result := Replace ( result , 4 , p ) ;
69474: LD_ADDR_VAR 0 2
69478: PUSH
69479: LD_VAR 0 2
69483: PPUSH
69484: LD_INT 4
69486: PPUSH
69487: LD_VAR 0 11
69491: PPUSH
69492: CALL_OW 1
69496: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69497: LD_ADDR_VAR 0 4
69501: PUSH
69502: LD_VAR 0 4
69506: PUSH
69507: LD_VAR 0 7
69511: DIFF
69512: ST_TO_ADDR
// if tmp and mech < 6 then
69513: LD_VAR 0 4
69517: PUSH
69518: LD_VAR 0 7
69522: PUSH
69523: LD_INT 6
69525: LESS
69526: AND
69527: IFFALSE 69709
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
69529: LD_ADDR_VAR 0 9
69533: PUSH
69534: LD_VAR 0 4
69538: PUSH
69539: LD_VAR 0 7
69543: DIFF
69544: PPUSH
69545: LD_INT 3
69547: PPUSH
69548: CALL 52006 0 2
69552: ST_TO_ADDR
// p := [ ] ;
69553: LD_ADDR_VAR 0 11
69557: PUSH
69558: EMPTY
69559: ST_TO_ADDR
// if sort then
69560: LD_VAR 0 9
69564: IFFALSE 69680
// for i = 1 to 6 - mech do
69566: LD_ADDR_VAR 0 3
69570: PUSH
69571: DOUBLE
69572: LD_INT 1
69574: DEC
69575: ST_TO_ADDR
69576: LD_INT 6
69578: PUSH
69579: LD_VAR 0 7
69583: MINUS
69584: PUSH
69585: FOR_TO
69586: IFFALSE 69678
// begin if i = sort then
69588: LD_VAR 0 3
69592: PUSH
69593: LD_VAR 0 9
69597: EQUAL
69598: IFFALSE 69602
// break ;
69600: GO 69678
// if GetClass ( i ) = 3 then
69602: LD_VAR 0 3
69606: PPUSH
69607: CALL_OW 257
69611: PUSH
69612: LD_INT 3
69614: EQUAL
69615: IFFALSE 69619
// continue ;
69617: GO 69585
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69619: LD_ADDR_VAR 0 11
69623: PUSH
69624: LD_VAR 0 11
69628: PPUSH
69629: LD_VAR 0 11
69633: PUSH
69634: LD_INT 1
69636: PLUS
69637: PPUSH
69638: LD_VAR 0 9
69642: PUSH
69643: LD_VAR 0 3
69647: ARRAY
69648: PPUSH
69649: CALL_OW 2
69653: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69654: LD_ADDR_VAR 0 4
69658: PUSH
69659: LD_VAR 0 4
69663: PUSH
69664: LD_VAR 0 9
69668: PUSH
69669: LD_VAR 0 3
69673: ARRAY
69674: DIFF
69675: ST_TO_ADDR
// end ;
69676: GO 69585
69678: POP
69679: POP
// if p then
69680: LD_VAR 0 11
69684: IFFALSE 69709
// result := Replace ( result , 3 , p ) ;
69686: LD_ADDR_VAR 0 2
69690: PUSH
69691: LD_VAR 0 2
69695: PPUSH
69696: LD_INT 3
69698: PPUSH
69699: LD_VAR 0 11
69703: PPUSH
69704: CALL_OW 1
69708: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69709: LD_ADDR_VAR 0 4
69713: PUSH
69714: LD_VAR 0 4
69718: PUSH
69719: LD_VAR 0 6
69723: DIFF
69724: ST_TO_ADDR
// if tmp and eng < 4 then
69725: LD_VAR 0 4
69729: PUSH
69730: LD_VAR 0 6
69734: PUSH
69735: LD_INT 4
69737: LESS
69738: AND
69739: IFFALSE 69929
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69741: LD_ADDR_VAR 0 9
69745: PUSH
69746: LD_VAR 0 4
69750: PUSH
69751: LD_VAR 0 7
69755: PUSH
69756: LD_VAR 0 6
69760: UNION
69761: DIFF
69762: PPUSH
69763: LD_INT 2
69765: PPUSH
69766: CALL 52006 0 2
69770: ST_TO_ADDR
// p := [ ] ;
69771: LD_ADDR_VAR 0 11
69775: PUSH
69776: EMPTY
69777: ST_TO_ADDR
// if sort then
69778: LD_VAR 0 9
69782: IFFALSE 69898
// for i = 1 to 4 - eng do
69784: LD_ADDR_VAR 0 3
69788: PUSH
69789: DOUBLE
69790: LD_INT 1
69792: DEC
69793: ST_TO_ADDR
69794: LD_INT 4
69796: PUSH
69797: LD_VAR 0 6
69801: MINUS
69802: PUSH
69803: FOR_TO
69804: IFFALSE 69896
// begin if i = sort then
69806: LD_VAR 0 3
69810: PUSH
69811: LD_VAR 0 9
69815: EQUAL
69816: IFFALSE 69820
// break ;
69818: GO 69896
// if GetClass ( i ) = 2 then
69820: LD_VAR 0 3
69824: PPUSH
69825: CALL_OW 257
69829: PUSH
69830: LD_INT 2
69832: EQUAL
69833: IFFALSE 69837
// continue ;
69835: GO 69803
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69837: LD_ADDR_VAR 0 11
69841: PUSH
69842: LD_VAR 0 11
69846: PPUSH
69847: LD_VAR 0 11
69851: PUSH
69852: LD_INT 1
69854: PLUS
69855: PPUSH
69856: LD_VAR 0 9
69860: PUSH
69861: LD_VAR 0 3
69865: ARRAY
69866: PPUSH
69867: CALL_OW 2
69871: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69872: LD_ADDR_VAR 0 4
69876: PUSH
69877: LD_VAR 0 4
69881: PUSH
69882: LD_VAR 0 9
69886: PUSH
69887: LD_VAR 0 3
69891: ARRAY
69892: DIFF
69893: ST_TO_ADDR
// end ;
69894: GO 69803
69896: POP
69897: POP
// if p then
69898: LD_VAR 0 11
69902: IFFALSE 69927
// result := Replace ( result , 2 , p ) ;
69904: LD_ADDR_VAR 0 2
69908: PUSH
69909: LD_VAR 0 2
69913: PPUSH
69914: LD_INT 2
69916: PPUSH
69917: LD_VAR 0 11
69921: PPUSH
69922: CALL_OW 1
69926: ST_TO_ADDR
// end else
69927: GO 69973
// for i = eng downto 5 do
69929: LD_ADDR_VAR 0 3
69933: PUSH
69934: DOUBLE
69935: LD_VAR 0 6
69939: INC
69940: ST_TO_ADDR
69941: LD_INT 5
69943: PUSH
69944: FOR_DOWNTO
69945: IFFALSE 69971
// tmp := tmp union eng [ i ] ;
69947: LD_ADDR_VAR 0 4
69951: PUSH
69952: LD_VAR 0 4
69956: PUSH
69957: LD_VAR 0 6
69961: PUSH
69962: LD_VAR 0 3
69966: ARRAY
69967: UNION
69968: ST_TO_ADDR
69969: GO 69944
69971: POP
69972: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69973: LD_ADDR_VAR 0 2
69977: PUSH
69978: LD_VAR 0 2
69982: PPUSH
69983: LD_INT 1
69985: PPUSH
69986: LD_VAR 0 4
69990: PUSH
69991: LD_VAR 0 5
69995: DIFF
69996: PPUSH
69997: CALL_OW 1
70001: ST_TO_ADDR
// exit ;
70002: GO 70004
// end ; end ;
70004: LD_VAR 0 2
70008: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
70009: LD_INT 0
70011: PPUSH
70012: PPUSH
70013: PPUSH
// if not mc_bases then
70014: LD_EXP 84
70018: NOT
70019: IFFALSE 70023
// exit ;
70021: GO 70129
// for i = 1 to mc_bases do
70023: LD_ADDR_VAR 0 2
70027: PUSH
70028: DOUBLE
70029: LD_INT 1
70031: DEC
70032: ST_TO_ADDR
70033: LD_EXP 84
70037: PUSH
70038: FOR_TO
70039: IFFALSE 70120
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70041: LD_ADDR_VAR 0 3
70045: PUSH
70046: LD_EXP 84
70050: PUSH
70051: LD_VAR 0 2
70055: ARRAY
70056: PPUSH
70057: LD_INT 21
70059: PUSH
70060: LD_INT 3
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 3
70069: PUSH
70070: LD_INT 24
70072: PUSH
70073: LD_INT 1000
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: EMPTY
70081: LIST
70082: LIST
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PPUSH
70088: CALL_OW 72
70092: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
70093: LD_ADDR_EXP 85
70097: PUSH
70098: LD_EXP 85
70102: PPUSH
70103: LD_VAR 0 2
70107: PPUSH
70108: LD_VAR 0 3
70112: PPUSH
70113: CALL_OW 1
70117: ST_TO_ADDR
// end ;
70118: GO 70038
70120: POP
70121: POP
// RaiseSailEvent ( 101 ) ;
70122: LD_INT 101
70124: PPUSH
70125: CALL_OW 427
// end ;
70129: LD_VAR 0 1
70133: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
70134: LD_INT 0
70136: PPUSH
70137: PPUSH
70138: PPUSH
70139: PPUSH
70140: PPUSH
70141: PPUSH
70142: PPUSH
// if not mc_bases then
70143: LD_EXP 84
70147: NOT
70148: IFFALSE 70152
// exit ;
70150: GO 70714
// for i = 1 to mc_bases do
70152: LD_ADDR_VAR 0 2
70156: PUSH
70157: DOUBLE
70158: LD_INT 1
70160: DEC
70161: ST_TO_ADDR
70162: LD_EXP 84
70166: PUSH
70167: FOR_TO
70168: IFFALSE 70705
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
70170: LD_ADDR_VAR 0 5
70174: PUSH
70175: LD_EXP 84
70179: PUSH
70180: LD_VAR 0 2
70184: ARRAY
70185: PUSH
70186: LD_EXP 113
70190: PUSH
70191: LD_VAR 0 2
70195: ARRAY
70196: UNION
70197: PPUSH
70198: LD_INT 21
70200: PUSH
70201: LD_INT 1
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PUSH
70208: LD_INT 1
70210: PUSH
70211: LD_INT 3
70213: PUSH
70214: LD_INT 54
70216: PUSH
70217: EMPTY
70218: LIST
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: PUSH
70224: LD_INT 3
70226: PUSH
70227: LD_INT 24
70229: PUSH
70230: LD_INT 800
70232: PUSH
70233: EMPTY
70234: LIST
70235: LIST
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PUSH
70241: EMPTY
70242: LIST
70243: LIST
70244: LIST
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PPUSH
70250: CALL_OW 72
70254: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
70255: LD_ADDR_VAR 0 6
70259: PUSH
70260: LD_EXP 84
70264: PUSH
70265: LD_VAR 0 2
70269: ARRAY
70270: PPUSH
70271: LD_INT 21
70273: PUSH
70274: LD_INT 1
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: PUSH
70281: LD_INT 1
70283: PUSH
70284: LD_INT 3
70286: PUSH
70287: LD_INT 54
70289: PUSH
70290: EMPTY
70291: LIST
70292: PUSH
70293: EMPTY
70294: LIST
70295: LIST
70296: PUSH
70297: LD_INT 3
70299: PUSH
70300: LD_INT 24
70302: PUSH
70303: LD_INT 250
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: EMPTY
70311: LIST
70312: LIST
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: LIST
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PPUSH
70323: CALL_OW 72
70327: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
70328: LD_ADDR_VAR 0 7
70332: PUSH
70333: LD_VAR 0 5
70337: PUSH
70338: LD_VAR 0 6
70342: DIFF
70343: ST_TO_ADDR
// if not need_heal_1 then
70344: LD_VAR 0 6
70348: NOT
70349: IFFALSE 70382
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
70351: LD_ADDR_EXP 87
70355: PUSH
70356: LD_EXP 87
70360: PPUSH
70361: LD_VAR 0 2
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PPUSH
70373: EMPTY
70374: PPUSH
70375: CALL 22457 0 3
70379: ST_TO_ADDR
70380: GO 70452
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
70382: LD_ADDR_EXP 87
70386: PUSH
70387: LD_EXP 87
70391: PPUSH
70392: LD_VAR 0 2
70396: PUSH
70397: LD_INT 1
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PPUSH
70404: LD_EXP 87
70408: PUSH
70409: LD_VAR 0 2
70413: ARRAY
70414: PUSH
70415: LD_INT 1
70417: ARRAY
70418: PPUSH
70419: LD_INT 3
70421: PUSH
70422: LD_INT 24
70424: PUSH
70425: LD_INT 1000
70427: PUSH
70428: EMPTY
70429: LIST
70430: LIST
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PPUSH
70436: CALL_OW 72
70440: PUSH
70441: LD_VAR 0 6
70445: UNION
70446: PPUSH
70447: CALL 22457 0 3
70451: ST_TO_ADDR
// if not need_heal_2 then
70452: LD_VAR 0 7
70456: NOT
70457: IFFALSE 70490
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
70459: LD_ADDR_EXP 87
70463: PUSH
70464: LD_EXP 87
70468: PPUSH
70469: LD_VAR 0 2
70473: PUSH
70474: LD_INT 2
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PPUSH
70481: EMPTY
70482: PPUSH
70483: CALL 22457 0 3
70487: ST_TO_ADDR
70488: GO 70522
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
70490: LD_ADDR_EXP 87
70494: PUSH
70495: LD_EXP 87
70499: PPUSH
70500: LD_VAR 0 2
70504: PUSH
70505: LD_INT 2
70507: PUSH
70508: EMPTY
70509: LIST
70510: LIST
70511: PPUSH
70512: LD_VAR 0 7
70516: PPUSH
70517: CALL 22457 0 3
70521: ST_TO_ADDR
// if need_heal_2 then
70522: LD_VAR 0 7
70526: IFFALSE 70687
// for j in need_heal_2 do
70528: LD_ADDR_VAR 0 3
70532: PUSH
70533: LD_VAR 0 7
70537: PUSH
70538: FOR_IN
70539: IFFALSE 70685
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70541: LD_ADDR_VAR 0 5
70545: PUSH
70546: LD_EXP 84
70550: PUSH
70551: LD_VAR 0 2
70555: ARRAY
70556: PPUSH
70557: LD_INT 2
70559: PUSH
70560: LD_INT 30
70562: PUSH
70563: LD_INT 6
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: PUSH
70570: LD_INT 30
70572: PUSH
70573: LD_INT 7
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 30
70582: PUSH
70583: LD_INT 8
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 30
70592: PUSH
70593: LD_INT 0
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 30
70602: PUSH
70603: LD_INT 1
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: LIST
70614: LIST
70615: LIST
70616: LIST
70617: PPUSH
70618: CALL_OW 72
70622: ST_TO_ADDR
// if tmp then
70623: LD_VAR 0 5
70627: IFFALSE 70683
// begin k := NearestUnitToUnit ( tmp , j ) ;
70629: LD_ADDR_VAR 0 4
70633: PUSH
70634: LD_VAR 0 5
70638: PPUSH
70639: LD_VAR 0 3
70643: PPUSH
70644: CALL_OW 74
70648: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70649: LD_VAR 0 3
70653: PPUSH
70654: LD_VAR 0 4
70658: PPUSH
70659: CALL_OW 296
70663: PUSH
70664: LD_INT 5
70666: GREATER
70667: IFFALSE 70683
// ComMoveToNearbyEntrance ( j , k ) ;
70669: LD_VAR 0 3
70673: PPUSH
70674: LD_VAR 0 4
70678: PPUSH
70679: CALL 54323 0 2
// end ; end ;
70683: GO 70538
70685: POP
70686: POP
// if not need_heal_1 and not need_heal_2 then
70687: LD_VAR 0 6
70691: NOT
70692: PUSH
70693: LD_VAR 0 7
70697: NOT
70698: AND
70699: IFFALSE 70703
// continue ;
70701: GO 70167
// end ;
70703: GO 70167
70705: POP
70706: POP
// RaiseSailEvent ( 102 ) ;
70707: LD_INT 102
70709: PPUSH
70710: CALL_OW 427
// end ;
70714: LD_VAR 0 1
70718: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70719: LD_INT 0
70721: PPUSH
70722: PPUSH
70723: PPUSH
70724: PPUSH
70725: PPUSH
70726: PPUSH
70727: PPUSH
70728: PPUSH
// if not mc_bases then
70729: LD_EXP 84
70733: NOT
70734: IFFALSE 70738
// exit ;
70736: GO 71599
// for i = 1 to mc_bases do
70738: LD_ADDR_VAR 0 2
70742: PUSH
70743: DOUBLE
70744: LD_INT 1
70746: DEC
70747: ST_TO_ADDR
70748: LD_EXP 84
70752: PUSH
70753: FOR_TO
70754: IFFALSE 71597
// begin if not mc_building_need_repair [ i ] then
70756: LD_EXP 85
70760: PUSH
70761: LD_VAR 0 2
70765: ARRAY
70766: NOT
70767: IFFALSE 70954
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70769: LD_ADDR_VAR 0 6
70773: PUSH
70774: LD_EXP 103
70778: PUSH
70779: LD_VAR 0 2
70783: ARRAY
70784: PPUSH
70785: LD_INT 3
70787: PUSH
70788: LD_INT 24
70790: PUSH
70791: LD_INT 1000
70793: PUSH
70794: EMPTY
70795: LIST
70796: LIST
70797: PUSH
70798: EMPTY
70799: LIST
70800: LIST
70801: PUSH
70802: LD_INT 2
70804: PUSH
70805: LD_INT 34
70807: PUSH
70808: LD_INT 13
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PUSH
70815: LD_INT 34
70817: PUSH
70818: LD_INT 52
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: PUSH
70825: LD_INT 34
70827: PUSH
70828: LD_EXP 7
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: LIST
70841: LIST
70842: PUSH
70843: EMPTY
70844: LIST
70845: LIST
70846: PPUSH
70847: CALL_OW 72
70851: ST_TO_ADDR
// if cranes then
70852: LD_VAR 0 6
70856: IFFALSE 70918
// for j in cranes do
70858: LD_ADDR_VAR 0 3
70862: PUSH
70863: LD_VAR 0 6
70867: PUSH
70868: FOR_IN
70869: IFFALSE 70916
// if not IsInArea ( j , mc_parking [ i ] ) then
70871: LD_VAR 0 3
70875: PPUSH
70876: LD_EXP 108
70880: PUSH
70881: LD_VAR 0 2
70885: ARRAY
70886: PPUSH
70887: CALL_OW 308
70891: NOT
70892: IFFALSE 70914
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70894: LD_VAR 0 3
70898: PPUSH
70899: LD_EXP 108
70903: PUSH
70904: LD_VAR 0 2
70908: ARRAY
70909: PPUSH
70910: CALL_OW 113
70914: GO 70868
70916: POP
70917: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70918: LD_ADDR_EXP 86
70922: PUSH
70923: LD_EXP 86
70927: PPUSH
70928: LD_VAR 0 2
70932: PPUSH
70933: EMPTY
70934: PPUSH
70935: CALL_OW 1
70939: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70940: LD_VAR 0 2
70944: PPUSH
70945: LD_INT 101
70947: PPUSH
70948: CALL 65842 0 2
// continue ;
70952: GO 70753
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70954: LD_ADDR_EXP 90
70958: PUSH
70959: LD_EXP 90
70963: PPUSH
70964: LD_VAR 0 2
70968: PPUSH
70969: EMPTY
70970: PPUSH
70971: CALL_OW 1
70975: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70976: LD_VAR 0 2
70980: PPUSH
70981: LD_INT 103
70983: PPUSH
70984: CALL 65842 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70988: LD_ADDR_VAR 0 5
70992: PUSH
70993: LD_EXP 84
70997: PUSH
70998: LD_VAR 0 2
71002: ARRAY
71003: PUSH
71004: LD_EXP 113
71008: PUSH
71009: LD_VAR 0 2
71013: ARRAY
71014: UNION
71015: PPUSH
71016: LD_INT 2
71018: PUSH
71019: LD_INT 25
71021: PUSH
71022: LD_INT 2
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 25
71031: PUSH
71032: LD_INT 16
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: LIST
71043: PUSH
71044: EMPTY
71045: LIST
71046: PPUSH
71047: CALL_OW 72
71051: PUSH
71052: LD_EXP 87
71056: PUSH
71057: LD_VAR 0 2
71061: ARRAY
71062: PUSH
71063: LD_INT 1
71065: ARRAY
71066: PUSH
71067: LD_EXP 87
71071: PUSH
71072: LD_VAR 0 2
71076: ARRAY
71077: PUSH
71078: LD_INT 2
71080: ARRAY
71081: UNION
71082: DIFF
71083: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
71084: LD_ADDR_VAR 0 6
71088: PUSH
71089: LD_EXP 103
71093: PUSH
71094: LD_VAR 0 2
71098: ARRAY
71099: PPUSH
71100: LD_INT 2
71102: PUSH
71103: LD_INT 34
71105: PUSH
71106: LD_INT 13
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 34
71115: PUSH
71116: LD_INT 52
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 34
71125: PUSH
71126: LD_EXP 7
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: PPUSH
71141: CALL_OW 72
71145: ST_TO_ADDR
// if cranes then
71146: LD_VAR 0 6
71150: IFFALSE 71286
// begin for j in cranes do
71152: LD_ADDR_VAR 0 3
71156: PUSH
71157: LD_VAR 0 6
71161: PUSH
71162: FOR_IN
71163: IFFALSE 71284
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
71165: LD_VAR 0 3
71169: PPUSH
71170: CALL_OW 256
71174: PUSH
71175: LD_INT 1000
71177: EQUAL
71178: PUSH
71179: LD_VAR 0 3
71183: PPUSH
71184: CALL_OW 314
71188: NOT
71189: AND
71190: IFFALSE 71224
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
71192: LD_VAR 0 3
71196: PPUSH
71197: LD_EXP 85
71201: PUSH
71202: LD_VAR 0 2
71206: ARRAY
71207: PPUSH
71208: LD_VAR 0 3
71212: PPUSH
71213: CALL_OW 74
71217: PPUSH
71218: CALL_OW 130
71222: GO 71282
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
71224: LD_VAR 0 3
71228: PPUSH
71229: CALL_OW 256
71233: PUSH
71234: LD_INT 500
71236: LESS
71237: PUSH
71238: LD_VAR 0 3
71242: PPUSH
71243: LD_EXP 108
71247: PUSH
71248: LD_VAR 0 2
71252: ARRAY
71253: PPUSH
71254: CALL_OW 308
71258: NOT
71259: AND
71260: IFFALSE 71282
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71262: LD_VAR 0 3
71266: PPUSH
71267: LD_EXP 108
71271: PUSH
71272: LD_VAR 0 2
71276: ARRAY
71277: PPUSH
71278: CALL_OW 113
// end ;
71282: GO 71162
71284: POP
71285: POP
// end ; if tmp > 3 then
71286: LD_VAR 0 5
71290: PUSH
71291: LD_INT 3
71293: GREATER
71294: IFFALSE 71314
// tmp := ShrinkArray ( tmp , 4 ) ;
71296: LD_ADDR_VAR 0 5
71300: PUSH
71301: LD_VAR 0 5
71305: PPUSH
71306: LD_INT 4
71308: PPUSH
71309: CALL 53815 0 2
71313: ST_TO_ADDR
// if not tmp then
71314: LD_VAR 0 5
71318: NOT
71319: IFFALSE 71323
// continue ;
71321: GO 70753
// for j in tmp do
71323: LD_ADDR_VAR 0 3
71327: PUSH
71328: LD_VAR 0 5
71332: PUSH
71333: FOR_IN
71334: IFFALSE 71593
// begin if IsInUnit ( j ) then
71336: LD_VAR 0 3
71340: PPUSH
71341: CALL_OW 310
71345: IFFALSE 71356
// ComExitBuilding ( j ) ;
71347: LD_VAR 0 3
71351: PPUSH
71352: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
71356: LD_VAR 0 3
71360: PUSH
71361: LD_EXP 86
71365: PUSH
71366: LD_VAR 0 2
71370: ARRAY
71371: IN
71372: NOT
71373: IFFALSE 71431
// begin SetTag ( j , 101 ) ;
71375: LD_VAR 0 3
71379: PPUSH
71380: LD_INT 101
71382: PPUSH
71383: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
71387: LD_ADDR_EXP 86
71391: PUSH
71392: LD_EXP 86
71396: PPUSH
71397: LD_VAR 0 2
71401: PUSH
71402: LD_EXP 86
71406: PUSH
71407: LD_VAR 0 2
71411: ARRAY
71412: PUSH
71413: LD_INT 1
71415: PLUS
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PPUSH
71421: LD_VAR 0 3
71425: PPUSH
71426: CALL 22457 0 3
71430: ST_TO_ADDR
// end ; wait ( 1 ) ;
71431: LD_INT 1
71433: PPUSH
71434: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
71438: LD_ADDR_VAR 0 7
71442: PUSH
71443: LD_EXP 85
71447: PUSH
71448: LD_VAR 0 2
71452: ARRAY
71453: ST_TO_ADDR
// if mc_scan [ i ] then
71454: LD_EXP 107
71458: PUSH
71459: LD_VAR 0 2
71463: ARRAY
71464: IFFALSE 71526
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
71466: LD_ADDR_VAR 0 7
71470: PUSH
71471: LD_EXP 85
71475: PUSH
71476: LD_VAR 0 2
71480: ARRAY
71481: PPUSH
71482: LD_INT 3
71484: PUSH
71485: LD_INT 30
71487: PUSH
71488: LD_INT 32
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 30
71497: PUSH
71498: LD_INT 33
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PUSH
71505: LD_INT 30
71507: PUSH
71508: LD_INT 31
71510: PUSH
71511: EMPTY
71512: LIST
71513: LIST
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: LIST
71519: LIST
71520: PPUSH
71521: CALL_OW 72
71525: ST_TO_ADDR
// if not to_repair_tmp then
71526: LD_VAR 0 7
71530: NOT
71531: IFFALSE 71535
// continue ;
71533: GO 71333
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
71535: LD_ADDR_VAR 0 8
71539: PUSH
71540: LD_VAR 0 7
71544: PPUSH
71545: LD_VAR 0 3
71549: PPUSH
71550: CALL_OW 74
71554: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
71555: LD_VAR 0 8
71559: PPUSH
71560: LD_INT 16
71562: PPUSH
71563: CALL 25050 0 2
71567: PUSH
71568: LD_INT 4
71570: ARRAY
71571: PUSH
71572: LD_INT 10
71574: LESS
71575: IFFALSE 71591
// ComRepairBuilding ( j , to_repair ) ;
71577: LD_VAR 0 3
71581: PPUSH
71582: LD_VAR 0 8
71586: PPUSH
71587: CALL_OW 130
// end ;
71591: GO 71333
71593: POP
71594: POP
// end ;
71595: GO 70753
71597: POP
71598: POP
// end ;
71599: LD_VAR 0 1
71603: RET
// export function MC_Heal ; var i , j , tmp ; begin
71604: LD_INT 0
71606: PPUSH
71607: PPUSH
71608: PPUSH
71609: PPUSH
// if not mc_bases then
71610: LD_EXP 84
71614: NOT
71615: IFFALSE 71619
// exit ;
71617: GO 72021
// for i = 1 to mc_bases do
71619: LD_ADDR_VAR 0 2
71623: PUSH
71624: DOUBLE
71625: LD_INT 1
71627: DEC
71628: ST_TO_ADDR
71629: LD_EXP 84
71633: PUSH
71634: FOR_TO
71635: IFFALSE 72019
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71637: LD_EXP 87
71641: PUSH
71642: LD_VAR 0 2
71646: ARRAY
71647: PUSH
71648: LD_INT 1
71650: ARRAY
71651: NOT
71652: PUSH
71653: LD_EXP 87
71657: PUSH
71658: LD_VAR 0 2
71662: ARRAY
71663: PUSH
71664: LD_INT 2
71666: ARRAY
71667: NOT
71668: AND
71669: IFFALSE 71707
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71671: LD_ADDR_EXP 88
71675: PUSH
71676: LD_EXP 88
71680: PPUSH
71681: LD_VAR 0 2
71685: PPUSH
71686: EMPTY
71687: PPUSH
71688: CALL_OW 1
71692: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71693: LD_VAR 0 2
71697: PPUSH
71698: LD_INT 102
71700: PPUSH
71701: CALL 65842 0 2
// continue ;
71705: GO 71634
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71707: LD_ADDR_VAR 0 4
71711: PUSH
71712: LD_EXP 84
71716: PUSH
71717: LD_VAR 0 2
71721: ARRAY
71722: PPUSH
71723: LD_INT 25
71725: PUSH
71726: LD_INT 4
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PPUSH
71733: CALL_OW 72
71737: ST_TO_ADDR
// if not tmp then
71738: LD_VAR 0 4
71742: NOT
71743: IFFALSE 71747
// continue ;
71745: GO 71634
// if mc_taming [ i ] then
71747: LD_EXP 115
71751: PUSH
71752: LD_VAR 0 2
71756: ARRAY
71757: IFFALSE 71781
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71759: LD_ADDR_EXP 115
71763: PUSH
71764: LD_EXP 115
71768: PPUSH
71769: LD_VAR 0 2
71773: PPUSH
71774: EMPTY
71775: PPUSH
71776: CALL_OW 1
71780: ST_TO_ADDR
// for j in tmp do
71781: LD_ADDR_VAR 0 3
71785: PUSH
71786: LD_VAR 0 4
71790: PUSH
71791: FOR_IN
71792: IFFALSE 72015
// begin if IsInUnit ( j ) then
71794: LD_VAR 0 3
71798: PPUSH
71799: CALL_OW 310
71803: IFFALSE 71814
// ComExitBuilding ( j ) ;
71805: LD_VAR 0 3
71809: PPUSH
71810: CALL_OW 122
// if not j in mc_healers [ i ] then
71814: LD_VAR 0 3
71818: PUSH
71819: LD_EXP 88
71823: PUSH
71824: LD_VAR 0 2
71828: ARRAY
71829: IN
71830: NOT
71831: IFFALSE 71877
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71833: LD_ADDR_EXP 88
71837: PUSH
71838: LD_EXP 88
71842: PPUSH
71843: LD_VAR 0 2
71847: PUSH
71848: LD_EXP 88
71852: PUSH
71853: LD_VAR 0 2
71857: ARRAY
71858: PUSH
71859: LD_INT 1
71861: PLUS
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PPUSH
71867: LD_VAR 0 3
71871: PPUSH
71872: CALL 22457 0 3
71876: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71877: LD_VAR 0 3
71881: PPUSH
71882: CALL_OW 110
71886: PUSH
71887: LD_INT 102
71889: NONEQUAL
71890: IFFALSE 71904
// SetTag ( j , 102 ) ;
71892: LD_VAR 0 3
71896: PPUSH
71897: LD_INT 102
71899: PPUSH
71900: CALL_OW 109
// Wait ( 3 ) ;
71904: LD_INT 3
71906: PPUSH
71907: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71911: LD_EXP 87
71915: PUSH
71916: LD_VAR 0 2
71920: ARRAY
71921: PUSH
71922: LD_INT 1
71924: ARRAY
71925: IFFALSE 71957
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71927: LD_VAR 0 3
71931: PPUSH
71932: LD_EXP 87
71936: PUSH
71937: LD_VAR 0 2
71941: ARRAY
71942: PUSH
71943: LD_INT 1
71945: ARRAY
71946: PUSH
71947: LD_INT 1
71949: ARRAY
71950: PPUSH
71951: CALL_OW 128
71955: GO 72013
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71957: LD_VAR 0 3
71961: PPUSH
71962: CALL_OW 314
71966: NOT
71967: PUSH
71968: LD_EXP 87
71972: PUSH
71973: LD_VAR 0 2
71977: ARRAY
71978: PUSH
71979: LD_INT 2
71981: ARRAY
71982: AND
71983: IFFALSE 72013
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71985: LD_VAR 0 3
71989: PPUSH
71990: LD_EXP 87
71994: PUSH
71995: LD_VAR 0 2
71999: ARRAY
72000: PUSH
72001: LD_INT 2
72003: ARRAY
72004: PUSH
72005: LD_INT 1
72007: ARRAY
72008: PPUSH
72009: CALL_OW 128
// end ;
72013: GO 71791
72015: POP
72016: POP
// end ;
72017: GO 71634
72019: POP
72020: POP
// end ;
72021: LD_VAR 0 1
72025: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
72026: LD_INT 0
72028: PPUSH
72029: PPUSH
72030: PPUSH
72031: PPUSH
72032: PPUSH
// if not mc_bases then
72033: LD_EXP 84
72037: NOT
72038: IFFALSE 72042
// exit ;
72040: GO 73185
// for i = 1 to mc_bases do
72042: LD_ADDR_VAR 0 2
72046: PUSH
72047: DOUBLE
72048: LD_INT 1
72050: DEC
72051: ST_TO_ADDR
72052: LD_EXP 84
72056: PUSH
72057: FOR_TO
72058: IFFALSE 73183
// begin if mc_scan [ i ] then
72060: LD_EXP 107
72064: PUSH
72065: LD_VAR 0 2
72069: ARRAY
72070: IFFALSE 72074
// continue ;
72072: GO 72057
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
72074: LD_EXP 89
72078: PUSH
72079: LD_VAR 0 2
72083: ARRAY
72084: NOT
72085: PUSH
72086: LD_EXP 91
72090: PUSH
72091: LD_VAR 0 2
72095: ARRAY
72096: NOT
72097: AND
72098: PUSH
72099: LD_EXP 90
72103: PUSH
72104: LD_VAR 0 2
72108: ARRAY
72109: AND
72110: IFFALSE 72148
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
72112: LD_ADDR_EXP 90
72116: PUSH
72117: LD_EXP 90
72121: PPUSH
72122: LD_VAR 0 2
72126: PPUSH
72127: EMPTY
72128: PPUSH
72129: CALL_OW 1
72133: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
72134: LD_VAR 0 2
72138: PPUSH
72139: LD_INT 103
72141: PPUSH
72142: CALL 65842 0 2
// continue ;
72146: GO 72057
// end ; if mc_construct_list [ i ] then
72148: LD_EXP 91
72152: PUSH
72153: LD_VAR 0 2
72157: ARRAY
72158: IFFALSE 72378
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72160: LD_ADDR_VAR 0 4
72164: PUSH
72165: LD_EXP 84
72169: PUSH
72170: LD_VAR 0 2
72174: ARRAY
72175: PPUSH
72176: LD_INT 25
72178: PUSH
72179: LD_INT 2
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PPUSH
72186: CALL_OW 72
72190: PUSH
72191: LD_EXP 86
72195: PUSH
72196: LD_VAR 0 2
72200: ARRAY
72201: DIFF
72202: ST_TO_ADDR
// if not tmp then
72203: LD_VAR 0 4
72207: NOT
72208: IFFALSE 72212
// continue ;
72210: GO 72057
// for j in tmp do
72212: LD_ADDR_VAR 0 3
72216: PUSH
72217: LD_VAR 0 4
72221: PUSH
72222: FOR_IN
72223: IFFALSE 72374
// begin if not mc_builders [ i ] then
72225: LD_EXP 90
72229: PUSH
72230: LD_VAR 0 2
72234: ARRAY
72235: NOT
72236: IFFALSE 72294
// begin SetTag ( j , 103 ) ;
72238: LD_VAR 0 3
72242: PPUSH
72243: LD_INT 103
72245: PPUSH
72246: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72250: LD_ADDR_EXP 90
72254: PUSH
72255: LD_EXP 90
72259: PPUSH
72260: LD_VAR 0 2
72264: PUSH
72265: LD_EXP 90
72269: PUSH
72270: LD_VAR 0 2
72274: ARRAY
72275: PUSH
72276: LD_INT 1
72278: PLUS
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PPUSH
72284: LD_VAR 0 3
72288: PPUSH
72289: CALL 22457 0 3
72293: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72294: LD_VAR 0 3
72298: PPUSH
72299: CALL_OW 310
72303: IFFALSE 72314
// ComExitBuilding ( j ) ;
72305: LD_VAR 0 3
72309: PPUSH
72310: CALL_OW 122
// wait ( 3 ) ;
72314: LD_INT 3
72316: PPUSH
72317: CALL_OW 67
// if not mc_construct_list [ i ] then
72321: LD_EXP 91
72325: PUSH
72326: LD_VAR 0 2
72330: ARRAY
72331: NOT
72332: IFFALSE 72336
// break ;
72334: GO 72374
// if not HasTask ( j ) then
72336: LD_VAR 0 3
72340: PPUSH
72341: CALL_OW 314
72345: NOT
72346: IFFALSE 72372
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
72348: LD_VAR 0 3
72352: PPUSH
72353: LD_EXP 91
72357: PUSH
72358: LD_VAR 0 2
72362: ARRAY
72363: PUSH
72364: LD_INT 1
72366: ARRAY
72367: PPUSH
72368: CALL 25308 0 2
// end ;
72372: GO 72222
72374: POP
72375: POP
// end else
72376: GO 73181
// if mc_build_list [ i ] then
72378: LD_EXP 89
72382: PUSH
72383: LD_VAR 0 2
72387: ARRAY
72388: IFFALSE 73181
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72390: LD_ADDR_VAR 0 5
72394: PUSH
72395: LD_EXP 84
72399: PUSH
72400: LD_VAR 0 2
72404: ARRAY
72405: PPUSH
72406: LD_INT 2
72408: PUSH
72409: LD_INT 30
72411: PUSH
72412: LD_INT 0
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: PUSH
72419: LD_INT 30
72421: PUSH
72422: LD_INT 1
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: LIST
72433: PPUSH
72434: CALL_OW 72
72438: ST_TO_ADDR
// if depot then
72439: LD_VAR 0 5
72443: IFFALSE 72461
// depot := depot [ 1 ] else
72445: LD_ADDR_VAR 0 5
72449: PUSH
72450: LD_VAR 0 5
72454: PUSH
72455: LD_INT 1
72457: ARRAY
72458: ST_TO_ADDR
72459: GO 72469
// depot := 0 ;
72461: LD_ADDR_VAR 0 5
72465: PUSH
72466: LD_INT 0
72468: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
72469: LD_EXP 89
72473: PUSH
72474: LD_VAR 0 2
72478: ARRAY
72479: PUSH
72480: LD_INT 1
72482: ARRAY
72483: PUSH
72484: LD_INT 1
72486: ARRAY
72487: PPUSH
72488: CALL 25138 0 1
72492: PUSH
72493: LD_EXP 84
72497: PUSH
72498: LD_VAR 0 2
72502: ARRAY
72503: PPUSH
72504: LD_INT 2
72506: PUSH
72507: LD_INT 30
72509: PUSH
72510: LD_INT 2
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 30
72519: PUSH
72520: LD_INT 3
72522: PUSH
72523: EMPTY
72524: LIST
72525: LIST
72526: PUSH
72527: EMPTY
72528: LIST
72529: LIST
72530: LIST
72531: PPUSH
72532: CALL_OW 72
72536: NOT
72537: AND
72538: IFFALSE 72643
// begin for j = 1 to mc_build_list [ i ] do
72540: LD_ADDR_VAR 0 3
72544: PUSH
72545: DOUBLE
72546: LD_INT 1
72548: DEC
72549: ST_TO_ADDR
72550: LD_EXP 89
72554: PUSH
72555: LD_VAR 0 2
72559: ARRAY
72560: PUSH
72561: FOR_TO
72562: IFFALSE 72641
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
72564: LD_EXP 89
72568: PUSH
72569: LD_VAR 0 2
72573: ARRAY
72574: PUSH
72575: LD_VAR 0 3
72579: ARRAY
72580: PUSH
72581: LD_INT 1
72583: ARRAY
72584: PUSH
72585: LD_INT 2
72587: EQUAL
72588: IFFALSE 72639
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
72590: LD_ADDR_EXP 89
72594: PUSH
72595: LD_EXP 89
72599: PPUSH
72600: LD_VAR 0 2
72604: PPUSH
72605: LD_EXP 89
72609: PUSH
72610: LD_VAR 0 2
72614: ARRAY
72615: PPUSH
72616: LD_VAR 0 3
72620: PPUSH
72621: LD_INT 1
72623: PPUSH
72624: LD_INT 0
72626: PPUSH
72627: CALL 21875 0 4
72631: PPUSH
72632: CALL_OW 1
72636: ST_TO_ADDR
// break ;
72637: GO 72641
// end ;
72639: GO 72561
72641: POP
72642: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
72643: LD_EXP 89
72647: PUSH
72648: LD_VAR 0 2
72652: ARRAY
72653: PUSH
72654: LD_INT 1
72656: ARRAY
72657: PUSH
72658: LD_INT 1
72660: ARRAY
72661: PUSH
72662: LD_INT 0
72664: EQUAL
72665: PUSH
72666: LD_VAR 0 5
72670: PUSH
72671: LD_VAR 0 5
72675: PPUSH
72676: LD_EXP 89
72680: PUSH
72681: LD_VAR 0 2
72685: ARRAY
72686: PUSH
72687: LD_INT 1
72689: ARRAY
72690: PUSH
72691: LD_INT 1
72693: ARRAY
72694: PPUSH
72695: LD_EXP 89
72699: PUSH
72700: LD_VAR 0 2
72704: ARRAY
72705: PUSH
72706: LD_INT 1
72708: ARRAY
72709: PUSH
72710: LD_INT 2
72712: ARRAY
72713: PPUSH
72714: LD_EXP 89
72718: PUSH
72719: LD_VAR 0 2
72723: ARRAY
72724: PUSH
72725: LD_INT 1
72727: ARRAY
72728: PUSH
72729: LD_INT 3
72731: ARRAY
72732: PPUSH
72733: LD_EXP 89
72737: PUSH
72738: LD_VAR 0 2
72742: ARRAY
72743: PUSH
72744: LD_INT 1
72746: ARRAY
72747: PUSH
72748: LD_INT 4
72750: ARRAY
72751: PPUSH
72752: CALL 29872 0 5
72756: AND
72757: OR
72758: IFFALSE 73039
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72760: LD_ADDR_VAR 0 4
72764: PUSH
72765: LD_EXP 84
72769: PUSH
72770: LD_VAR 0 2
72774: ARRAY
72775: PPUSH
72776: LD_INT 25
72778: PUSH
72779: LD_INT 2
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PPUSH
72786: CALL_OW 72
72790: PUSH
72791: LD_EXP 86
72795: PUSH
72796: LD_VAR 0 2
72800: ARRAY
72801: DIFF
72802: ST_TO_ADDR
// if not tmp then
72803: LD_VAR 0 4
72807: NOT
72808: IFFALSE 72812
// continue ;
72810: GO 72057
// for j in tmp do
72812: LD_ADDR_VAR 0 3
72816: PUSH
72817: LD_VAR 0 4
72821: PUSH
72822: FOR_IN
72823: IFFALSE 73035
// begin if not mc_builders [ i ] then
72825: LD_EXP 90
72829: PUSH
72830: LD_VAR 0 2
72834: ARRAY
72835: NOT
72836: IFFALSE 72894
// begin SetTag ( j , 103 ) ;
72838: LD_VAR 0 3
72842: PPUSH
72843: LD_INT 103
72845: PPUSH
72846: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72850: LD_ADDR_EXP 90
72854: PUSH
72855: LD_EXP 90
72859: PPUSH
72860: LD_VAR 0 2
72864: PUSH
72865: LD_EXP 90
72869: PUSH
72870: LD_VAR 0 2
72874: ARRAY
72875: PUSH
72876: LD_INT 1
72878: PLUS
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PPUSH
72884: LD_VAR 0 3
72888: PPUSH
72889: CALL 22457 0 3
72893: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72894: LD_VAR 0 3
72898: PPUSH
72899: CALL_OW 310
72903: IFFALSE 72914
// ComExitBuilding ( j ) ;
72905: LD_VAR 0 3
72909: PPUSH
72910: CALL_OW 122
// wait ( 3 ) ;
72914: LD_INT 3
72916: PPUSH
72917: CALL_OW 67
// if not mc_build_list [ i ] then
72921: LD_EXP 89
72925: PUSH
72926: LD_VAR 0 2
72930: ARRAY
72931: NOT
72932: IFFALSE 72936
// break ;
72934: GO 73035
// if not HasTask ( j ) then
72936: LD_VAR 0 3
72940: PPUSH
72941: CALL_OW 314
72945: NOT
72946: IFFALSE 73033
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72948: LD_VAR 0 3
72952: PPUSH
72953: LD_EXP 89
72957: PUSH
72958: LD_VAR 0 2
72962: ARRAY
72963: PUSH
72964: LD_INT 1
72966: ARRAY
72967: PUSH
72968: LD_INT 1
72970: ARRAY
72971: PPUSH
72972: LD_EXP 89
72976: PUSH
72977: LD_VAR 0 2
72981: ARRAY
72982: PUSH
72983: LD_INT 1
72985: ARRAY
72986: PUSH
72987: LD_INT 2
72989: ARRAY
72990: PPUSH
72991: LD_EXP 89
72995: PUSH
72996: LD_VAR 0 2
73000: ARRAY
73001: PUSH
73002: LD_INT 1
73004: ARRAY
73005: PUSH
73006: LD_INT 3
73008: ARRAY
73009: PPUSH
73010: LD_EXP 89
73014: PUSH
73015: LD_VAR 0 2
73019: ARRAY
73020: PUSH
73021: LD_INT 1
73023: ARRAY
73024: PUSH
73025: LD_INT 4
73027: ARRAY
73028: PPUSH
73029: CALL_OW 145
// end ;
73033: GO 72822
73035: POP
73036: POP
// end else
73037: GO 73181
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
73039: LD_EXP 84
73043: PUSH
73044: LD_VAR 0 2
73048: ARRAY
73049: PPUSH
73050: LD_EXP 89
73054: PUSH
73055: LD_VAR 0 2
73059: ARRAY
73060: PUSH
73061: LD_INT 1
73063: ARRAY
73064: PUSH
73065: LD_INT 1
73067: ARRAY
73068: PPUSH
73069: LD_EXP 89
73073: PUSH
73074: LD_VAR 0 2
73078: ARRAY
73079: PUSH
73080: LD_INT 1
73082: ARRAY
73083: PUSH
73084: LD_INT 2
73086: ARRAY
73087: PPUSH
73088: LD_EXP 89
73092: PUSH
73093: LD_VAR 0 2
73097: ARRAY
73098: PUSH
73099: LD_INT 1
73101: ARRAY
73102: PUSH
73103: LD_INT 3
73105: ARRAY
73106: PPUSH
73107: LD_EXP 89
73111: PUSH
73112: LD_VAR 0 2
73116: ARRAY
73117: PUSH
73118: LD_INT 1
73120: ARRAY
73121: PUSH
73122: LD_INT 4
73124: ARRAY
73125: PPUSH
73126: CALL 29208 0 5
73130: NOT
73131: IFFALSE 73181
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
73133: LD_ADDR_EXP 89
73137: PUSH
73138: LD_EXP 89
73142: PPUSH
73143: LD_VAR 0 2
73147: PPUSH
73148: LD_EXP 89
73152: PUSH
73153: LD_VAR 0 2
73157: ARRAY
73158: PPUSH
73159: LD_INT 1
73161: PPUSH
73162: LD_INT 1
73164: NEG
73165: PPUSH
73166: LD_INT 0
73168: PPUSH
73169: CALL 21875 0 4
73173: PPUSH
73174: CALL_OW 1
73178: ST_TO_ADDR
// continue ;
73179: GO 72057
// end ; end ; end ;
73181: GO 72057
73183: POP
73184: POP
// end ;
73185: LD_VAR 0 1
73189: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
73190: LD_INT 0
73192: PPUSH
73193: PPUSH
73194: PPUSH
73195: PPUSH
73196: PPUSH
73197: PPUSH
// if not mc_bases then
73198: LD_EXP 84
73202: NOT
73203: IFFALSE 73207
// exit ;
73205: GO 73634
// for i = 1 to mc_bases do
73207: LD_ADDR_VAR 0 2
73211: PUSH
73212: DOUBLE
73213: LD_INT 1
73215: DEC
73216: ST_TO_ADDR
73217: LD_EXP 84
73221: PUSH
73222: FOR_TO
73223: IFFALSE 73632
// begin tmp := mc_build_upgrade [ i ] ;
73225: LD_ADDR_VAR 0 4
73229: PUSH
73230: LD_EXP 116
73234: PUSH
73235: LD_VAR 0 2
73239: ARRAY
73240: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
73241: LD_ADDR_VAR 0 6
73245: PUSH
73246: LD_EXP 117
73250: PUSH
73251: LD_VAR 0 2
73255: ARRAY
73256: PPUSH
73257: LD_INT 2
73259: PUSH
73260: LD_INT 30
73262: PUSH
73263: LD_INT 6
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: LD_INT 30
73272: PUSH
73273: LD_INT 7
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: LIST
73284: PPUSH
73285: CALL_OW 72
73289: ST_TO_ADDR
// if not tmp and not lab then
73290: LD_VAR 0 4
73294: NOT
73295: PUSH
73296: LD_VAR 0 6
73300: NOT
73301: AND
73302: IFFALSE 73306
// continue ;
73304: GO 73222
// if tmp then
73306: LD_VAR 0 4
73310: IFFALSE 73430
// for j in tmp do
73312: LD_ADDR_VAR 0 3
73316: PUSH
73317: LD_VAR 0 4
73321: PUSH
73322: FOR_IN
73323: IFFALSE 73428
// begin if UpgradeCost ( j ) then
73325: LD_VAR 0 3
73329: PPUSH
73330: CALL 28868 0 1
73334: IFFALSE 73426
// begin ComUpgrade ( j ) ;
73336: LD_VAR 0 3
73340: PPUSH
73341: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
73345: LD_ADDR_EXP 116
73349: PUSH
73350: LD_EXP 116
73354: PPUSH
73355: LD_VAR 0 2
73359: PPUSH
73360: LD_EXP 116
73364: PUSH
73365: LD_VAR 0 2
73369: ARRAY
73370: PUSH
73371: LD_VAR 0 3
73375: DIFF
73376: PPUSH
73377: CALL_OW 1
73381: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73382: LD_ADDR_EXP 91
73386: PUSH
73387: LD_EXP 91
73391: PPUSH
73392: LD_VAR 0 2
73396: PUSH
73397: LD_EXP 91
73401: PUSH
73402: LD_VAR 0 2
73406: ARRAY
73407: PUSH
73408: LD_INT 1
73410: PLUS
73411: PUSH
73412: EMPTY
73413: LIST
73414: LIST
73415: PPUSH
73416: LD_VAR 0 3
73420: PPUSH
73421: CALL 22457 0 3
73425: ST_TO_ADDR
// end ; end ;
73426: GO 73322
73428: POP
73429: POP
// if not lab or not mc_lab_upgrade [ i ] then
73430: LD_VAR 0 6
73434: NOT
73435: PUSH
73436: LD_EXP 118
73440: PUSH
73441: LD_VAR 0 2
73445: ARRAY
73446: NOT
73447: OR
73448: IFFALSE 73452
// continue ;
73450: GO 73222
// for j in lab do
73452: LD_ADDR_VAR 0 3
73456: PUSH
73457: LD_VAR 0 6
73461: PUSH
73462: FOR_IN
73463: IFFALSE 73628
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
73465: LD_VAR 0 3
73469: PPUSH
73470: CALL_OW 266
73474: PUSH
73475: LD_INT 6
73477: PUSH
73478: LD_INT 7
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: IN
73485: PUSH
73486: LD_VAR 0 3
73490: PPUSH
73491: CALL_OW 461
73495: PUSH
73496: LD_INT 1
73498: NONEQUAL
73499: AND
73500: IFFALSE 73626
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
73502: LD_VAR 0 3
73506: PPUSH
73507: LD_EXP 118
73511: PUSH
73512: LD_VAR 0 2
73516: ARRAY
73517: PUSH
73518: LD_INT 1
73520: ARRAY
73521: PPUSH
73522: CALL 29073 0 2
73526: IFFALSE 73626
// begin ComCancel ( j ) ;
73528: LD_VAR 0 3
73532: PPUSH
73533: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73537: LD_VAR 0 3
73541: PPUSH
73542: LD_EXP 118
73546: PUSH
73547: LD_VAR 0 2
73551: ARRAY
73552: PUSH
73553: LD_INT 1
73555: ARRAY
73556: PPUSH
73557: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73561: LD_VAR 0 3
73565: PUSH
73566: LD_EXP 91
73570: PUSH
73571: LD_VAR 0 2
73575: ARRAY
73576: IN
73577: NOT
73578: IFFALSE 73624
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73580: LD_ADDR_EXP 91
73584: PUSH
73585: LD_EXP 91
73589: PPUSH
73590: LD_VAR 0 2
73594: PUSH
73595: LD_EXP 91
73599: PUSH
73600: LD_VAR 0 2
73604: ARRAY
73605: PUSH
73606: LD_INT 1
73608: PLUS
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PPUSH
73614: LD_VAR 0 3
73618: PPUSH
73619: CALL 22457 0 3
73623: ST_TO_ADDR
// break ;
73624: GO 73628
// end ; end ; end ;
73626: GO 73462
73628: POP
73629: POP
// end ;
73630: GO 73222
73632: POP
73633: POP
// end ;
73634: LD_VAR 0 1
73638: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73639: LD_INT 0
73641: PPUSH
73642: PPUSH
73643: PPUSH
73644: PPUSH
73645: PPUSH
73646: PPUSH
73647: PPUSH
73648: PPUSH
73649: PPUSH
// if not mc_bases then
73650: LD_EXP 84
73654: NOT
73655: IFFALSE 73659
// exit ;
73657: GO 74064
// for i = 1 to mc_bases do
73659: LD_ADDR_VAR 0 2
73663: PUSH
73664: DOUBLE
73665: LD_INT 1
73667: DEC
73668: ST_TO_ADDR
73669: LD_EXP 84
73673: PUSH
73674: FOR_TO
73675: IFFALSE 74062
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73677: LD_EXP 92
73681: PUSH
73682: LD_VAR 0 2
73686: ARRAY
73687: NOT
73688: PUSH
73689: LD_EXP 84
73693: PUSH
73694: LD_VAR 0 2
73698: ARRAY
73699: PPUSH
73700: LD_INT 30
73702: PUSH
73703: LD_INT 3
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PPUSH
73710: CALL_OW 72
73714: NOT
73715: OR
73716: IFFALSE 73720
// continue ;
73718: GO 73674
// busy := false ;
73720: LD_ADDR_VAR 0 8
73724: PUSH
73725: LD_INT 0
73727: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73728: LD_ADDR_VAR 0 4
73732: PUSH
73733: LD_EXP 84
73737: PUSH
73738: LD_VAR 0 2
73742: ARRAY
73743: PPUSH
73744: LD_INT 30
73746: PUSH
73747: LD_INT 3
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PPUSH
73754: CALL_OW 72
73758: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73759: LD_ADDR_VAR 0 6
73763: PUSH
73764: LD_EXP 92
73768: PUSH
73769: LD_VAR 0 2
73773: ARRAY
73774: PPUSH
73775: LD_INT 2
73777: PUSH
73778: LD_INT 30
73780: PUSH
73781: LD_INT 32
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 30
73790: PUSH
73791: LD_INT 33
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: LIST
73802: PPUSH
73803: CALL_OW 72
73807: ST_TO_ADDR
// if not t then
73808: LD_VAR 0 6
73812: NOT
73813: IFFALSE 73817
// continue ;
73815: GO 73674
// for j in tmp do
73817: LD_ADDR_VAR 0 3
73821: PUSH
73822: LD_VAR 0 4
73826: PUSH
73827: FOR_IN
73828: IFFALSE 73858
// if not BuildingStatus ( j ) = bs_idle then
73830: LD_VAR 0 3
73834: PPUSH
73835: CALL_OW 461
73839: PUSH
73840: LD_INT 2
73842: EQUAL
73843: NOT
73844: IFFALSE 73856
// begin busy := true ;
73846: LD_ADDR_VAR 0 8
73850: PUSH
73851: LD_INT 1
73853: ST_TO_ADDR
// break ;
73854: GO 73858
// end ;
73856: GO 73827
73858: POP
73859: POP
// if busy then
73860: LD_VAR 0 8
73864: IFFALSE 73868
// continue ;
73866: GO 73674
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73868: LD_ADDR_VAR 0 7
73872: PUSH
73873: LD_VAR 0 6
73877: PPUSH
73878: LD_INT 35
73880: PUSH
73881: LD_INT 0
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PPUSH
73888: CALL_OW 72
73892: ST_TO_ADDR
// if tw then
73893: LD_VAR 0 7
73897: IFFALSE 73974
// begin tw := tw [ 1 ] ;
73899: LD_ADDR_VAR 0 7
73903: PUSH
73904: LD_VAR 0 7
73908: PUSH
73909: LD_INT 1
73911: ARRAY
73912: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73913: LD_ADDR_VAR 0 9
73917: PUSH
73918: LD_VAR 0 7
73922: PPUSH
73923: LD_EXP 109
73927: PUSH
73928: LD_VAR 0 2
73932: ARRAY
73933: PPUSH
73934: CALL 27427 0 2
73938: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73939: LD_EXP 123
73943: PUSH
73944: LD_VAR 0 2
73948: ARRAY
73949: IFFALSE 73972
// if not weapon in mc_allowed_tower_weapons [ i ] then
73951: LD_VAR 0 9
73955: PUSH
73956: LD_EXP 123
73960: PUSH
73961: LD_VAR 0 2
73965: ARRAY
73966: IN
73967: NOT
73968: IFFALSE 73972
// continue ;
73970: GO 73674
// end else
73972: GO 74037
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73974: LD_ADDR_VAR 0 5
73978: PUSH
73979: LD_EXP 92
73983: PUSH
73984: LD_VAR 0 2
73988: ARRAY
73989: PPUSH
73990: LD_VAR 0 4
73994: PPUSH
73995: CALL 53048 0 2
73999: ST_TO_ADDR
// if not tmp2 then
74000: LD_VAR 0 5
74004: NOT
74005: IFFALSE 74009
// continue ;
74007: GO 73674
// tw := tmp2 [ 1 ] ;
74009: LD_ADDR_VAR 0 7
74013: PUSH
74014: LD_VAR 0 5
74018: PUSH
74019: LD_INT 1
74021: ARRAY
74022: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
74023: LD_ADDR_VAR 0 9
74027: PUSH
74028: LD_VAR 0 5
74032: PUSH
74033: LD_INT 2
74035: ARRAY
74036: ST_TO_ADDR
// end ; if not weapon then
74037: LD_VAR 0 9
74041: NOT
74042: IFFALSE 74046
// continue ;
74044: GO 73674
// ComPlaceWeapon ( tw , weapon ) ;
74046: LD_VAR 0 7
74050: PPUSH
74051: LD_VAR 0 9
74055: PPUSH
74056: CALL_OW 148
// end ;
74060: GO 73674
74062: POP
74063: POP
// end ;
74064: LD_VAR 0 1
74068: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
74069: LD_INT 0
74071: PPUSH
74072: PPUSH
74073: PPUSH
74074: PPUSH
74075: PPUSH
74076: PPUSH
// if not mc_bases then
74077: LD_EXP 84
74081: NOT
74082: IFFALSE 74086
// exit ;
74084: GO 74862
// for i = 1 to mc_bases do
74086: LD_ADDR_VAR 0 2
74090: PUSH
74091: DOUBLE
74092: LD_INT 1
74094: DEC
74095: ST_TO_ADDR
74096: LD_EXP 84
74100: PUSH
74101: FOR_TO
74102: IFFALSE 74860
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
74104: LD_EXP 97
74108: PUSH
74109: LD_VAR 0 2
74113: ARRAY
74114: NOT
74115: PUSH
74116: LD_EXP 97
74120: PUSH
74121: LD_VAR 0 2
74125: ARRAY
74126: PUSH
74127: LD_EXP 98
74131: PUSH
74132: LD_VAR 0 2
74136: ARRAY
74137: EQUAL
74138: OR
74139: PUSH
74140: LD_EXP 107
74144: PUSH
74145: LD_VAR 0 2
74149: ARRAY
74150: OR
74151: IFFALSE 74155
// continue ;
74153: GO 74101
// if mc_miners [ i ] then
74155: LD_EXP 98
74159: PUSH
74160: LD_VAR 0 2
74164: ARRAY
74165: IFFALSE 74547
// begin for j = mc_miners [ i ] downto 1 do
74167: LD_ADDR_VAR 0 3
74171: PUSH
74172: DOUBLE
74173: LD_EXP 98
74177: PUSH
74178: LD_VAR 0 2
74182: ARRAY
74183: INC
74184: ST_TO_ADDR
74185: LD_INT 1
74187: PUSH
74188: FOR_DOWNTO
74189: IFFALSE 74545
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
74191: LD_EXP 98
74195: PUSH
74196: LD_VAR 0 2
74200: ARRAY
74201: PUSH
74202: LD_VAR 0 3
74206: ARRAY
74207: PPUSH
74208: CALL_OW 301
74212: PUSH
74213: LD_EXP 98
74217: PUSH
74218: LD_VAR 0 2
74222: ARRAY
74223: PUSH
74224: LD_VAR 0 3
74228: ARRAY
74229: PPUSH
74230: CALL_OW 257
74234: PUSH
74235: LD_INT 1
74237: NONEQUAL
74238: OR
74239: IFFALSE 74302
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
74241: LD_ADDR_VAR 0 5
74245: PUSH
74246: LD_EXP 98
74250: PUSH
74251: LD_VAR 0 2
74255: ARRAY
74256: PUSH
74257: LD_EXP 98
74261: PUSH
74262: LD_VAR 0 2
74266: ARRAY
74267: PUSH
74268: LD_VAR 0 3
74272: ARRAY
74273: DIFF
74274: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
74275: LD_ADDR_EXP 98
74279: PUSH
74280: LD_EXP 98
74284: PPUSH
74285: LD_VAR 0 2
74289: PPUSH
74290: LD_VAR 0 5
74294: PPUSH
74295: CALL_OW 1
74299: ST_TO_ADDR
// continue ;
74300: GO 74188
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
74302: LD_EXP 98
74306: PUSH
74307: LD_VAR 0 2
74311: ARRAY
74312: PUSH
74313: LD_VAR 0 3
74317: ARRAY
74318: PPUSH
74319: CALL_OW 257
74323: PUSH
74324: LD_INT 1
74326: EQUAL
74327: PUSH
74328: LD_EXP 98
74332: PUSH
74333: LD_VAR 0 2
74337: ARRAY
74338: PUSH
74339: LD_VAR 0 3
74343: ARRAY
74344: PPUSH
74345: CALL_OW 459
74349: NOT
74350: AND
74351: PUSH
74352: LD_EXP 98
74356: PUSH
74357: LD_VAR 0 2
74361: ARRAY
74362: PUSH
74363: LD_VAR 0 3
74367: ARRAY
74368: PPUSH
74369: CALL_OW 314
74373: NOT
74374: AND
74375: IFFALSE 74543
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
74377: LD_EXP 98
74381: PUSH
74382: LD_VAR 0 2
74386: ARRAY
74387: PUSH
74388: LD_VAR 0 3
74392: ARRAY
74393: PPUSH
74394: CALL_OW 310
74398: IFFALSE 74421
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
74400: LD_EXP 98
74404: PUSH
74405: LD_VAR 0 2
74409: ARRAY
74410: PUSH
74411: LD_VAR 0 3
74415: ARRAY
74416: PPUSH
74417: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
74421: LD_EXP 98
74425: PUSH
74426: LD_VAR 0 2
74430: ARRAY
74431: PUSH
74432: LD_VAR 0 3
74436: ARRAY
74437: PPUSH
74438: CALL_OW 314
74442: NOT
74443: IFFALSE 74543
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
74445: LD_EXP 98
74449: PUSH
74450: LD_VAR 0 2
74454: ARRAY
74455: PUSH
74456: LD_VAR 0 3
74460: ARRAY
74461: PPUSH
74462: LD_EXP 97
74466: PUSH
74467: LD_VAR 0 2
74471: ARRAY
74472: PUSH
74473: LD_VAR 0 3
74477: PUSH
74478: LD_EXP 97
74482: PUSH
74483: LD_VAR 0 2
74487: ARRAY
74488: MOD
74489: PUSH
74490: LD_INT 1
74492: PLUS
74493: ARRAY
74494: PUSH
74495: LD_INT 1
74497: ARRAY
74498: PPUSH
74499: LD_EXP 97
74503: PUSH
74504: LD_VAR 0 2
74508: ARRAY
74509: PUSH
74510: LD_VAR 0 3
74514: PUSH
74515: LD_EXP 97
74519: PUSH
74520: LD_VAR 0 2
74524: ARRAY
74525: MOD
74526: PUSH
74527: LD_INT 1
74529: PLUS
74530: ARRAY
74531: PUSH
74532: LD_INT 2
74534: ARRAY
74535: PPUSH
74536: LD_INT 0
74538: PPUSH
74539: CALL_OW 193
// end ; end ;
74543: GO 74188
74545: POP
74546: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74547: LD_ADDR_VAR 0 5
74551: PUSH
74552: LD_EXP 84
74556: PUSH
74557: LD_VAR 0 2
74561: ARRAY
74562: PPUSH
74563: LD_INT 2
74565: PUSH
74566: LD_INT 30
74568: PUSH
74569: LD_INT 4
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: LD_INT 30
74578: PUSH
74579: LD_INT 5
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: PUSH
74586: LD_INT 30
74588: PUSH
74589: LD_INT 32
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: LIST
74600: LIST
74601: PPUSH
74602: CALL_OW 72
74606: ST_TO_ADDR
// if not tmp then
74607: LD_VAR 0 5
74611: NOT
74612: IFFALSE 74616
// continue ;
74614: GO 74101
// list := [ ] ;
74616: LD_ADDR_VAR 0 6
74620: PUSH
74621: EMPTY
74622: ST_TO_ADDR
// for j in tmp do
74623: LD_ADDR_VAR 0 3
74627: PUSH
74628: LD_VAR 0 5
74632: PUSH
74633: FOR_IN
74634: IFFALSE 74703
// begin for k in UnitsInside ( j ) do
74636: LD_ADDR_VAR 0 4
74640: PUSH
74641: LD_VAR 0 3
74645: PPUSH
74646: CALL_OW 313
74650: PUSH
74651: FOR_IN
74652: IFFALSE 74699
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74654: LD_VAR 0 4
74658: PPUSH
74659: CALL_OW 257
74663: PUSH
74664: LD_INT 1
74666: EQUAL
74667: PUSH
74668: LD_VAR 0 4
74672: PPUSH
74673: CALL_OW 459
74677: NOT
74678: AND
74679: IFFALSE 74697
// list := list ^ k ;
74681: LD_ADDR_VAR 0 6
74685: PUSH
74686: LD_VAR 0 6
74690: PUSH
74691: LD_VAR 0 4
74695: ADD
74696: ST_TO_ADDR
74697: GO 74651
74699: POP
74700: POP
// end ;
74701: GO 74633
74703: POP
74704: POP
// list := list diff mc_miners [ i ] ;
74705: LD_ADDR_VAR 0 6
74709: PUSH
74710: LD_VAR 0 6
74714: PUSH
74715: LD_EXP 98
74719: PUSH
74720: LD_VAR 0 2
74724: ARRAY
74725: DIFF
74726: ST_TO_ADDR
// if not list then
74727: LD_VAR 0 6
74731: NOT
74732: IFFALSE 74736
// continue ;
74734: GO 74101
// k := mc_mines [ i ] - mc_miners [ i ] ;
74736: LD_ADDR_VAR 0 4
74740: PUSH
74741: LD_EXP 97
74745: PUSH
74746: LD_VAR 0 2
74750: ARRAY
74751: PUSH
74752: LD_EXP 98
74756: PUSH
74757: LD_VAR 0 2
74761: ARRAY
74762: MINUS
74763: ST_TO_ADDR
// if k > list then
74764: LD_VAR 0 4
74768: PUSH
74769: LD_VAR 0 6
74773: GREATER
74774: IFFALSE 74786
// k := list ;
74776: LD_ADDR_VAR 0 4
74780: PUSH
74781: LD_VAR 0 6
74785: ST_TO_ADDR
// for j = 1 to k do
74786: LD_ADDR_VAR 0 3
74790: PUSH
74791: DOUBLE
74792: LD_INT 1
74794: DEC
74795: ST_TO_ADDR
74796: LD_VAR 0 4
74800: PUSH
74801: FOR_TO
74802: IFFALSE 74856
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74804: LD_ADDR_EXP 98
74808: PUSH
74809: LD_EXP 98
74813: PPUSH
74814: LD_VAR 0 2
74818: PUSH
74819: LD_EXP 98
74823: PUSH
74824: LD_VAR 0 2
74828: ARRAY
74829: PUSH
74830: LD_INT 1
74832: PLUS
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PPUSH
74838: LD_VAR 0 6
74842: PUSH
74843: LD_VAR 0 3
74847: ARRAY
74848: PPUSH
74849: CALL 22457 0 3
74853: ST_TO_ADDR
74854: GO 74801
74856: POP
74857: POP
// end ;
74858: GO 74101
74860: POP
74861: POP
// end ;
74862: LD_VAR 0 1
74866: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
74867: LD_INT 0
74869: PPUSH
74870: PPUSH
74871: PPUSH
74872: PPUSH
74873: PPUSH
74874: PPUSH
74875: PPUSH
74876: PPUSH
74877: PPUSH
74878: PPUSH
// if not mc_bases then
74879: LD_EXP 84
74883: NOT
74884: IFFALSE 74888
// exit ;
74886: GO 76638
// for i = 1 to mc_bases do
74888: LD_ADDR_VAR 0 2
74892: PUSH
74893: DOUBLE
74894: LD_INT 1
74896: DEC
74897: ST_TO_ADDR
74898: LD_EXP 84
74902: PUSH
74903: FOR_TO
74904: IFFALSE 76636
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74906: LD_EXP 84
74910: PUSH
74911: LD_VAR 0 2
74915: ARRAY
74916: NOT
74917: PUSH
74918: LD_EXP 91
74922: PUSH
74923: LD_VAR 0 2
74927: ARRAY
74928: OR
74929: IFFALSE 74933
// continue ;
74931: GO 74903
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74933: LD_EXP 100
74937: PUSH
74938: LD_VAR 0 2
74942: ARRAY
74943: NOT
74944: PUSH
74945: LD_EXP 101
74949: PUSH
74950: LD_VAR 0 2
74954: ARRAY
74955: AND
74956: IFFALSE 74994
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74958: LD_ADDR_EXP 101
74962: PUSH
74963: LD_EXP 101
74967: PPUSH
74968: LD_VAR 0 2
74972: PPUSH
74973: EMPTY
74974: PPUSH
74975: CALL_OW 1
74979: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74980: LD_VAR 0 2
74984: PPUSH
74985: LD_INT 107
74987: PPUSH
74988: CALL 65842 0 2
// continue ;
74992: GO 74903
// end ; target := [ ] ;
74994: LD_ADDR_VAR 0 6
74998: PUSH
74999: EMPTY
75000: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
75001: LD_ADDR_VAR 0 3
75005: PUSH
75006: DOUBLE
75007: LD_EXP 100
75011: PUSH
75012: LD_VAR 0 2
75016: ARRAY
75017: INC
75018: ST_TO_ADDR
75019: LD_INT 1
75021: PUSH
75022: FOR_DOWNTO
75023: IFFALSE 75283
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
75025: LD_EXP 100
75029: PUSH
75030: LD_VAR 0 2
75034: ARRAY
75035: PUSH
75036: LD_VAR 0 3
75040: ARRAY
75041: PUSH
75042: LD_INT 2
75044: ARRAY
75045: PPUSH
75046: LD_EXP 100
75050: PUSH
75051: LD_VAR 0 2
75055: ARRAY
75056: PUSH
75057: LD_VAR 0 3
75061: ARRAY
75062: PUSH
75063: LD_INT 3
75065: ARRAY
75066: PPUSH
75067: CALL_OW 488
75071: PUSH
75072: LD_EXP 100
75076: PUSH
75077: LD_VAR 0 2
75081: ARRAY
75082: PUSH
75083: LD_VAR 0 3
75087: ARRAY
75088: PUSH
75089: LD_INT 2
75091: ARRAY
75092: PPUSH
75093: LD_EXP 100
75097: PUSH
75098: LD_VAR 0 2
75102: ARRAY
75103: PUSH
75104: LD_VAR 0 3
75108: ARRAY
75109: PUSH
75110: LD_INT 3
75112: ARRAY
75113: PPUSH
75114: CALL_OW 284
75118: PUSH
75119: LD_INT 0
75121: EQUAL
75122: AND
75123: IFFALSE 75178
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
75125: LD_ADDR_VAR 0 5
75129: PUSH
75130: LD_EXP 100
75134: PUSH
75135: LD_VAR 0 2
75139: ARRAY
75140: PPUSH
75141: LD_VAR 0 3
75145: PPUSH
75146: CALL_OW 3
75150: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
75151: LD_ADDR_EXP 100
75155: PUSH
75156: LD_EXP 100
75160: PPUSH
75161: LD_VAR 0 2
75165: PPUSH
75166: LD_VAR 0 5
75170: PPUSH
75171: CALL_OW 1
75175: ST_TO_ADDR
// continue ;
75176: GO 75022
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
75178: LD_EXP 84
75182: PUSH
75183: LD_VAR 0 2
75187: ARRAY
75188: PUSH
75189: LD_INT 1
75191: ARRAY
75192: PPUSH
75193: CALL_OW 255
75197: PPUSH
75198: LD_EXP 100
75202: PUSH
75203: LD_VAR 0 2
75207: ARRAY
75208: PUSH
75209: LD_VAR 0 3
75213: ARRAY
75214: PUSH
75215: LD_INT 2
75217: ARRAY
75218: PPUSH
75219: LD_EXP 100
75223: PUSH
75224: LD_VAR 0 2
75228: ARRAY
75229: PUSH
75230: LD_VAR 0 3
75234: ARRAY
75235: PUSH
75236: LD_INT 3
75238: ARRAY
75239: PPUSH
75240: LD_INT 30
75242: PPUSH
75243: CALL 23353 0 4
75247: PUSH
75248: LD_INT 4
75250: ARRAY
75251: PUSH
75252: LD_INT 0
75254: EQUAL
75255: IFFALSE 75281
// begin target := mc_crates [ i ] [ j ] ;
75257: LD_ADDR_VAR 0 6
75261: PUSH
75262: LD_EXP 100
75266: PUSH
75267: LD_VAR 0 2
75271: ARRAY
75272: PUSH
75273: LD_VAR 0 3
75277: ARRAY
75278: ST_TO_ADDR
// break ;
75279: GO 75283
// end ; end ;
75281: GO 75022
75283: POP
75284: POP
// if not target then
75285: LD_VAR 0 6
75289: NOT
75290: IFFALSE 75294
// continue ;
75292: GO 74903
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75294: LD_ADDR_VAR 0 7
75298: PUSH
75299: LD_EXP 103
75303: PUSH
75304: LD_VAR 0 2
75308: ARRAY
75309: PPUSH
75310: LD_INT 2
75312: PUSH
75313: LD_INT 3
75315: PUSH
75316: LD_INT 58
75318: PUSH
75319: EMPTY
75320: LIST
75321: PUSH
75322: EMPTY
75323: LIST
75324: LIST
75325: PUSH
75326: LD_INT 61
75328: PUSH
75329: EMPTY
75330: LIST
75331: PUSH
75332: LD_INT 33
75334: PUSH
75335: LD_INT 5
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PUSH
75342: LD_INT 33
75344: PUSH
75345: LD_INT 3
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: LIST
75356: LIST
75357: LIST
75358: PUSH
75359: LD_INT 2
75361: PUSH
75362: LD_INT 34
75364: PUSH
75365: LD_INT 32
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 34
75374: PUSH
75375: LD_INT 51
75377: PUSH
75378: EMPTY
75379: LIST
75380: LIST
75381: PUSH
75382: LD_INT 34
75384: PUSH
75385: LD_INT 12
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: LIST
75396: LIST
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PPUSH
75402: CALL_OW 72
75406: ST_TO_ADDR
// if not cargo then
75407: LD_VAR 0 7
75411: NOT
75412: IFFALSE 76055
// begin if mc_crates_collector [ i ] < 5 then
75414: LD_EXP 101
75418: PUSH
75419: LD_VAR 0 2
75423: ARRAY
75424: PUSH
75425: LD_INT 5
75427: LESS
75428: IFFALSE 75794
// begin if mc_ape [ i ] then
75430: LD_EXP 113
75434: PUSH
75435: LD_VAR 0 2
75439: ARRAY
75440: IFFALSE 75487
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75442: LD_ADDR_VAR 0 5
75446: PUSH
75447: LD_EXP 113
75451: PUSH
75452: LD_VAR 0 2
75456: ARRAY
75457: PPUSH
75458: LD_INT 25
75460: PUSH
75461: LD_INT 16
75463: PUSH
75464: EMPTY
75465: LIST
75466: LIST
75467: PUSH
75468: LD_INT 24
75470: PUSH
75471: LD_INT 750
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: PPUSH
75482: CALL_OW 72
75486: ST_TO_ADDR
// if not tmp then
75487: LD_VAR 0 5
75491: NOT
75492: IFFALSE 75539
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75494: LD_ADDR_VAR 0 5
75498: PUSH
75499: LD_EXP 84
75503: PUSH
75504: LD_VAR 0 2
75508: ARRAY
75509: PPUSH
75510: LD_INT 25
75512: PUSH
75513: LD_INT 2
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: LD_INT 24
75522: PUSH
75523: LD_INT 750
75525: PUSH
75526: EMPTY
75527: LIST
75528: LIST
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PPUSH
75534: CALL_OW 72
75538: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75539: LD_EXP 113
75543: PUSH
75544: LD_VAR 0 2
75548: ARRAY
75549: PUSH
75550: LD_EXP 84
75554: PUSH
75555: LD_VAR 0 2
75559: ARRAY
75560: PPUSH
75561: LD_INT 25
75563: PUSH
75564: LD_INT 2
75566: PUSH
75567: EMPTY
75568: LIST
75569: LIST
75570: PUSH
75571: LD_INT 24
75573: PUSH
75574: LD_INT 750
75576: PUSH
75577: EMPTY
75578: LIST
75579: LIST
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PPUSH
75585: CALL_OW 72
75589: AND
75590: PUSH
75591: LD_VAR 0 5
75595: PUSH
75596: LD_INT 5
75598: LESS
75599: AND
75600: IFFALSE 75682
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75602: LD_ADDR_VAR 0 3
75606: PUSH
75607: LD_EXP 84
75611: PUSH
75612: LD_VAR 0 2
75616: ARRAY
75617: PPUSH
75618: LD_INT 25
75620: PUSH
75621: LD_INT 2
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 24
75630: PUSH
75631: LD_INT 750
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PPUSH
75642: CALL_OW 72
75646: PUSH
75647: FOR_IN
75648: IFFALSE 75680
// begin tmp := tmp union j ;
75650: LD_ADDR_VAR 0 5
75654: PUSH
75655: LD_VAR 0 5
75659: PUSH
75660: LD_VAR 0 3
75664: UNION
75665: ST_TO_ADDR
// if tmp >= 5 then
75666: LD_VAR 0 5
75670: PUSH
75671: LD_INT 5
75673: GREATEREQUAL
75674: IFFALSE 75678
// break ;
75676: GO 75680
// end ;
75678: GO 75647
75680: POP
75681: POP
// end ; if not tmp then
75682: LD_VAR 0 5
75686: NOT
75687: IFFALSE 75691
// continue ;
75689: GO 74903
// for j in tmp do
75691: LD_ADDR_VAR 0 3
75695: PUSH
75696: LD_VAR 0 5
75700: PUSH
75701: FOR_IN
75702: IFFALSE 75792
// if not GetTag ( j ) then
75704: LD_VAR 0 3
75708: PPUSH
75709: CALL_OW 110
75713: NOT
75714: IFFALSE 75790
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75716: LD_ADDR_EXP 101
75720: PUSH
75721: LD_EXP 101
75725: PPUSH
75726: LD_VAR 0 2
75730: PUSH
75731: LD_EXP 101
75735: PUSH
75736: LD_VAR 0 2
75740: ARRAY
75741: PUSH
75742: LD_INT 1
75744: PLUS
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PPUSH
75750: LD_VAR 0 3
75754: PPUSH
75755: CALL 22457 0 3
75759: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75760: LD_VAR 0 3
75764: PPUSH
75765: LD_INT 107
75767: PPUSH
75768: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75772: LD_EXP 101
75776: PUSH
75777: LD_VAR 0 2
75781: ARRAY
75782: PUSH
75783: LD_INT 5
75785: GREATEREQUAL
75786: IFFALSE 75790
// break ;
75788: GO 75792
// end ;
75790: GO 75701
75792: POP
75793: POP
// end ; if mc_crates_collector [ i ] and target then
75794: LD_EXP 101
75798: PUSH
75799: LD_VAR 0 2
75803: ARRAY
75804: PUSH
75805: LD_VAR 0 6
75809: AND
75810: IFFALSE 76053
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75812: LD_EXP 101
75816: PUSH
75817: LD_VAR 0 2
75821: ARRAY
75822: PUSH
75823: LD_VAR 0 6
75827: PUSH
75828: LD_INT 1
75830: ARRAY
75831: LESS
75832: IFFALSE 75852
// tmp := mc_crates_collector [ i ] else
75834: LD_ADDR_VAR 0 5
75838: PUSH
75839: LD_EXP 101
75843: PUSH
75844: LD_VAR 0 2
75848: ARRAY
75849: ST_TO_ADDR
75850: GO 75866
// tmp := target [ 1 ] ;
75852: LD_ADDR_VAR 0 5
75856: PUSH
75857: LD_VAR 0 6
75861: PUSH
75862: LD_INT 1
75864: ARRAY
75865: ST_TO_ADDR
// k := 0 ;
75866: LD_ADDR_VAR 0 4
75870: PUSH
75871: LD_INT 0
75873: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75874: LD_ADDR_VAR 0 3
75878: PUSH
75879: LD_EXP 101
75883: PUSH
75884: LD_VAR 0 2
75888: ARRAY
75889: PUSH
75890: FOR_IN
75891: IFFALSE 76051
// begin k := k + 1 ;
75893: LD_ADDR_VAR 0 4
75897: PUSH
75898: LD_VAR 0 4
75902: PUSH
75903: LD_INT 1
75905: PLUS
75906: ST_TO_ADDR
// if k > tmp then
75907: LD_VAR 0 4
75911: PUSH
75912: LD_VAR 0 5
75916: GREATER
75917: IFFALSE 75921
// break ;
75919: GO 76051
// if not GetClass ( j ) in [ 2 , 16 ] then
75921: LD_VAR 0 3
75925: PPUSH
75926: CALL_OW 257
75930: PUSH
75931: LD_INT 2
75933: PUSH
75934: LD_INT 16
75936: PUSH
75937: EMPTY
75938: LIST
75939: LIST
75940: IN
75941: NOT
75942: IFFALSE 75995
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75944: LD_ADDR_EXP 101
75948: PUSH
75949: LD_EXP 101
75953: PPUSH
75954: LD_VAR 0 2
75958: PPUSH
75959: LD_EXP 101
75963: PUSH
75964: LD_VAR 0 2
75968: ARRAY
75969: PUSH
75970: LD_VAR 0 3
75974: DIFF
75975: PPUSH
75976: CALL_OW 1
75980: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75981: LD_VAR 0 3
75985: PPUSH
75986: LD_INT 0
75988: PPUSH
75989: CALL_OW 109
// continue ;
75993: GO 75890
// end ; if IsInUnit ( j ) then
75995: LD_VAR 0 3
75999: PPUSH
76000: CALL_OW 310
76004: IFFALSE 76015
// ComExitBuilding ( j ) ;
76006: LD_VAR 0 3
76010: PPUSH
76011: CALL_OW 122
// wait ( 3 ) ;
76015: LD_INT 3
76017: PPUSH
76018: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76022: LD_VAR 0 3
76026: PPUSH
76027: LD_VAR 0 6
76031: PUSH
76032: LD_INT 2
76034: ARRAY
76035: PPUSH
76036: LD_VAR 0 6
76040: PUSH
76041: LD_INT 3
76043: ARRAY
76044: PPUSH
76045: CALL_OW 117
// end ;
76049: GO 75890
76051: POP
76052: POP
// end ; end else
76053: GO 76634
// begin for j in cargo do
76055: LD_ADDR_VAR 0 3
76059: PUSH
76060: LD_VAR 0 7
76064: PUSH
76065: FOR_IN
76066: IFFALSE 76632
// begin if GetTag ( j ) <> 0 then
76068: LD_VAR 0 3
76072: PPUSH
76073: CALL_OW 110
76077: PUSH
76078: LD_INT 0
76080: NONEQUAL
76081: IFFALSE 76085
// continue ;
76083: GO 76065
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
76085: LD_VAR 0 3
76089: PPUSH
76090: CALL_OW 256
76094: PUSH
76095: LD_INT 1000
76097: LESS
76098: PUSH
76099: LD_VAR 0 3
76103: PPUSH
76104: LD_EXP 108
76108: PUSH
76109: LD_VAR 0 2
76113: ARRAY
76114: PPUSH
76115: CALL_OW 308
76119: NOT
76120: AND
76121: IFFALSE 76143
// ComMoveToArea ( j , mc_parking [ i ] ) ;
76123: LD_VAR 0 3
76127: PPUSH
76128: LD_EXP 108
76132: PUSH
76133: LD_VAR 0 2
76137: ARRAY
76138: PPUSH
76139: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
76143: LD_VAR 0 3
76147: PPUSH
76148: CALL_OW 256
76152: PUSH
76153: LD_INT 1000
76155: LESS
76156: PUSH
76157: LD_VAR 0 3
76161: PPUSH
76162: LD_EXP 108
76166: PUSH
76167: LD_VAR 0 2
76171: ARRAY
76172: PPUSH
76173: CALL_OW 308
76177: AND
76178: IFFALSE 76182
// continue ;
76180: GO 76065
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
76182: LD_VAR 0 3
76186: PPUSH
76187: CALL_OW 262
76191: PUSH
76192: LD_INT 2
76194: EQUAL
76195: PUSH
76196: LD_VAR 0 3
76200: PPUSH
76201: CALL_OW 261
76205: PUSH
76206: LD_INT 15
76208: LESS
76209: AND
76210: IFFALSE 76214
// continue ;
76212: GO 76065
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
76214: LD_VAR 0 3
76218: PPUSH
76219: CALL_OW 262
76223: PUSH
76224: LD_INT 1
76226: EQUAL
76227: PUSH
76228: LD_VAR 0 3
76232: PPUSH
76233: CALL_OW 261
76237: PUSH
76238: LD_INT 10
76240: LESS
76241: AND
76242: IFFALSE 76571
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76244: LD_ADDR_VAR 0 8
76248: PUSH
76249: LD_EXP 84
76253: PUSH
76254: LD_VAR 0 2
76258: ARRAY
76259: PPUSH
76260: LD_INT 2
76262: PUSH
76263: LD_INT 30
76265: PUSH
76266: LD_INT 0
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 30
76275: PUSH
76276: LD_INT 1
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: LIST
76287: PPUSH
76288: CALL_OW 72
76292: ST_TO_ADDR
// if not depot then
76293: LD_VAR 0 8
76297: NOT
76298: IFFALSE 76302
// continue ;
76300: GO 76065
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76302: LD_VAR 0 3
76306: PPUSH
76307: LD_VAR 0 8
76311: PPUSH
76312: LD_VAR 0 3
76316: PPUSH
76317: CALL_OW 74
76321: PPUSH
76322: CALL_OW 296
76326: PUSH
76327: LD_INT 6
76329: LESS
76330: IFFALSE 76346
// SetFuel ( j , 100 ) else
76332: LD_VAR 0 3
76336: PPUSH
76337: LD_INT 100
76339: PPUSH
76340: CALL_OW 240
76344: GO 76571
// if GetFuel ( j ) = 0 then
76346: LD_VAR 0 3
76350: PPUSH
76351: CALL_OW 261
76355: PUSH
76356: LD_INT 0
76358: EQUAL
76359: IFFALSE 76571
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
76361: LD_ADDR_EXP 103
76365: PUSH
76366: LD_EXP 103
76370: PPUSH
76371: LD_VAR 0 2
76375: PPUSH
76376: LD_EXP 103
76380: PUSH
76381: LD_VAR 0 2
76385: ARRAY
76386: PUSH
76387: LD_VAR 0 3
76391: DIFF
76392: PPUSH
76393: CALL_OW 1
76397: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
76398: LD_VAR 0 3
76402: PPUSH
76403: CALL_OW 263
76407: PUSH
76408: LD_INT 1
76410: EQUAL
76411: IFFALSE 76427
// ComExitVehicle ( IsInUnit ( j ) ) ;
76413: LD_VAR 0 3
76417: PPUSH
76418: CALL_OW 310
76422: PPUSH
76423: CALL_OW 121
// if GetControl ( j ) = control_remote then
76427: LD_VAR 0 3
76431: PPUSH
76432: CALL_OW 263
76436: PUSH
76437: LD_INT 2
76439: EQUAL
76440: IFFALSE 76451
// ComUnlink ( j ) ;
76442: LD_VAR 0 3
76446: PPUSH
76447: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76451: LD_ADDR_VAR 0 9
76455: PUSH
76456: LD_VAR 0 2
76460: PPUSH
76461: LD_INT 3
76463: PPUSH
76464: CALL 85946 0 2
76468: ST_TO_ADDR
// if fac then
76469: LD_VAR 0 9
76473: IFFALSE 76569
// begin for k in fac do
76475: LD_ADDR_VAR 0 4
76479: PUSH
76480: LD_VAR 0 9
76484: PUSH
76485: FOR_IN
76486: IFFALSE 76567
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76488: LD_ADDR_VAR 0 10
76492: PUSH
76493: LD_VAR 0 9
76497: PPUSH
76498: LD_VAR 0 3
76502: PPUSH
76503: CALL_OW 265
76507: PPUSH
76508: LD_VAR 0 3
76512: PPUSH
76513: CALL_OW 262
76517: PPUSH
76518: LD_VAR 0 3
76522: PPUSH
76523: CALL_OW 263
76527: PPUSH
76528: LD_VAR 0 3
76532: PPUSH
76533: CALL_OW 264
76537: PPUSH
76538: CALL 19989 0 5
76542: ST_TO_ADDR
// if components then
76543: LD_VAR 0 10
76547: IFFALSE 76565
// begin MC_InsertProduceList ( i , components ) ;
76549: LD_VAR 0 2
76553: PPUSH
76554: LD_VAR 0 10
76558: PPUSH
76559: CALL 85491 0 2
// break ;
76563: GO 76567
// end ; end ;
76565: GO 76485
76567: POP
76568: POP
// end ; continue ;
76569: GO 76065
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76571: LD_VAR 0 3
76575: PPUSH
76576: LD_INT 1
76578: PPUSH
76579: CALL_OW 289
76583: PUSH
76584: LD_INT 100
76586: LESS
76587: PUSH
76588: LD_VAR 0 3
76592: PPUSH
76593: CALL_OW 314
76597: NOT
76598: AND
76599: IFFALSE 76628
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76601: LD_VAR 0 3
76605: PPUSH
76606: LD_VAR 0 6
76610: PUSH
76611: LD_INT 2
76613: ARRAY
76614: PPUSH
76615: LD_VAR 0 6
76619: PUSH
76620: LD_INT 3
76622: ARRAY
76623: PPUSH
76624: CALL_OW 117
// break ;
76628: GO 76632
// end ;
76630: GO 76065
76632: POP
76633: POP
// end ; end ;
76634: GO 74903
76636: POP
76637: POP
// end ;
76638: LD_VAR 0 1
76642: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76643: LD_INT 0
76645: PPUSH
76646: PPUSH
76647: PPUSH
76648: PPUSH
// if not mc_bases then
76649: LD_EXP 84
76653: NOT
76654: IFFALSE 76658
// exit ;
76656: GO 76819
// for i = 1 to mc_bases do
76658: LD_ADDR_VAR 0 2
76662: PUSH
76663: DOUBLE
76664: LD_INT 1
76666: DEC
76667: ST_TO_ADDR
76668: LD_EXP 84
76672: PUSH
76673: FOR_TO
76674: IFFALSE 76817
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76676: LD_ADDR_VAR 0 4
76680: PUSH
76681: LD_EXP 103
76685: PUSH
76686: LD_VAR 0 2
76690: ARRAY
76691: PUSH
76692: LD_EXP 106
76696: PUSH
76697: LD_VAR 0 2
76701: ARRAY
76702: UNION
76703: PPUSH
76704: LD_INT 33
76706: PUSH
76707: LD_INT 2
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PPUSH
76714: CALL_OW 72
76718: ST_TO_ADDR
// if tmp then
76719: LD_VAR 0 4
76723: IFFALSE 76815
// for j in tmp do
76725: LD_ADDR_VAR 0 3
76729: PUSH
76730: LD_VAR 0 4
76734: PUSH
76735: FOR_IN
76736: IFFALSE 76813
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76738: LD_VAR 0 3
76742: PPUSH
76743: CALL_OW 312
76747: NOT
76748: PUSH
76749: LD_VAR 0 3
76753: PPUSH
76754: CALL_OW 256
76758: PUSH
76759: LD_INT 250
76761: GREATEREQUAL
76762: AND
76763: IFFALSE 76776
// Connect ( j ) else
76765: LD_VAR 0 3
76769: PPUSH
76770: CALL 25390 0 1
76774: GO 76811
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76776: LD_VAR 0 3
76780: PPUSH
76781: CALL_OW 256
76785: PUSH
76786: LD_INT 250
76788: LESS
76789: PUSH
76790: LD_VAR 0 3
76794: PPUSH
76795: CALL_OW 312
76799: AND
76800: IFFALSE 76811
// ComUnlink ( j ) ;
76802: LD_VAR 0 3
76806: PPUSH
76807: CALL_OW 136
76811: GO 76735
76813: POP
76814: POP
// end ;
76815: GO 76673
76817: POP
76818: POP
// end ;
76819: LD_VAR 0 1
76823: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76824: LD_INT 0
76826: PPUSH
76827: PPUSH
76828: PPUSH
76829: PPUSH
76830: PPUSH
// if not mc_bases then
76831: LD_EXP 84
76835: NOT
76836: IFFALSE 76840
// exit ;
76838: GO 77285
// for i = 1 to mc_bases do
76840: LD_ADDR_VAR 0 2
76844: PUSH
76845: DOUBLE
76846: LD_INT 1
76848: DEC
76849: ST_TO_ADDR
76850: LD_EXP 84
76854: PUSH
76855: FOR_TO
76856: IFFALSE 77283
// begin if not mc_produce [ i ] then
76858: LD_EXP 105
76862: PUSH
76863: LD_VAR 0 2
76867: ARRAY
76868: NOT
76869: IFFALSE 76873
// continue ;
76871: GO 76855
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76873: LD_ADDR_VAR 0 5
76877: PUSH
76878: LD_EXP 84
76882: PUSH
76883: LD_VAR 0 2
76887: ARRAY
76888: PPUSH
76889: LD_INT 30
76891: PUSH
76892: LD_INT 3
76894: PUSH
76895: EMPTY
76896: LIST
76897: LIST
76898: PPUSH
76899: CALL_OW 72
76903: ST_TO_ADDR
// if not fac then
76904: LD_VAR 0 5
76908: NOT
76909: IFFALSE 76913
// continue ;
76911: GO 76855
// for j in fac do
76913: LD_ADDR_VAR 0 3
76917: PUSH
76918: LD_VAR 0 5
76922: PUSH
76923: FOR_IN
76924: IFFALSE 77279
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76926: LD_VAR 0 3
76930: PPUSH
76931: CALL_OW 461
76935: PUSH
76936: LD_INT 2
76938: NONEQUAL
76939: PUSH
76940: LD_VAR 0 3
76944: PPUSH
76945: LD_INT 15
76947: PPUSH
76948: CALL 25050 0 2
76952: PUSH
76953: LD_INT 4
76955: ARRAY
76956: OR
76957: IFFALSE 76961
// continue ;
76959: GO 76923
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76961: LD_VAR 0 3
76965: PPUSH
76966: LD_EXP 105
76970: PUSH
76971: LD_VAR 0 2
76975: ARRAY
76976: PUSH
76977: LD_INT 1
76979: ARRAY
76980: PUSH
76981: LD_INT 1
76983: ARRAY
76984: PPUSH
76985: LD_EXP 105
76989: PUSH
76990: LD_VAR 0 2
76994: ARRAY
76995: PUSH
76996: LD_INT 1
76998: ARRAY
76999: PUSH
77000: LD_INT 2
77002: ARRAY
77003: PPUSH
77004: LD_EXP 105
77008: PUSH
77009: LD_VAR 0 2
77013: ARRAY
77014: PUSH
77015: LD_INT 1
77017: ARRAY
77018: PUSH
77019: LD_INT 3
77021: ARRAY
77022: PPUSH
77023: LD_EXP 105
77027: PUSH
77028: LD_VAR 0 2
77032: ARRAY
77033: PUSH
77034: LD_INT 1
77036: ARRAY
77037: PUSH
77038: LD_INT 4
77040: ARRAY
77041: PPUSH
77042: CALL_OW 448
77046: PUSH
77047: LD_VAR 0 3
77051: PPUSH
77052: LD_EXP 105
77056: PUSH
77057: LD_VAR 0 2
77061: ARRAY
77062: PUSH
77063: LD_INT 1
77065: ARRAY
77066: PUSH
77067: LD_INT 1
77069: ARRAY
77070: PUSH
77071: LD_EXP 105
77075: PUSH
77076: LD_VAR 0 2
77080: ARRAY
77081: PUSH
77082: LD_INT 1
77084: ARRAY
77085: PUSH
77086: LD_INT 2
77088: ARRAY
77089: PUSH
77090: LD_EXP 105
77094: PUSH
77095: LD_VAR 0 2
77099: ARRAY
77100: PUSH
77101: LD_INT 1
77103: ARRAY
77104: PUSH
77105: LD_INT 3
77107: ARRAY
77108: PUSH
77109: LD_EXP 105
77113: PUSH
77114: LD_VAR 0 2
77118: ARRAY
77119: PUSH
77120: LD_INT 1
77122: ARRAY
77123: PUSH
77124: LD_INT 4
77126: ARRAY
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: LIST
77132: LIST
77133: PPUSH
77134: CALL 28721 0 2
77138: AND
77139: IFFALSE 77277
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
77141: LD_VAR 0 3
77145: PPUSH
77146: LD_EXP 105
77150: PUSH
77151: LD_VAR 0 2
77155: ARRAY
77156: PUSH
77157: LD_INT 1
77159: ARRAY
77160: PUSH
77161: LD_INT 1
77163: ARRAY
77164: PPUSH
77165: LD_EXP 105
77169: PUSH
77170: LD_VAR 0 2
77174: ARRAY
77175: PUSH
77176: LD_INT 1
77178: ARRAY
77179: PUSH
77180: LD_INT 2
77182: ARRAY
77183: PPUSH
77184: LD_EXP 105
77188: PUSH
77189: LD_VAR 0 2
77193: ARRAY
77194: PUSH
77195: LD_INT 1
77197: ARRAY
77198: PUSH
77199: LD_INT 3
77201: ARRAY
77202: PPUSH
77203: LD_EXP 105
77207: PUSH
77208: LD_VAR 0 2
77212: ARRAY
77213: PUSH
77214: LD_INT 1
77216: ARRAY
77217: PUSH
77218: LD_INT 4
77220: ARRAY
77221: PPUSH
77222: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
77226: LD_ADDR_VAR 0 4
77230: PUSH
77231: LD_EXP 105
77235: PUSH
77236: LD_VAR 0 2
77240: ARRAY
77241: PPUSH
77242: LD_INT 1
77244: PPUSH
77245: CALL_OW 3
77249: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77250: LD_ADDR_EXP 105
77254: PUSH
77255: LD_EXP 105
77259: PPUSH
77260: LD_VAR 0 2
77264: PPUSH
77265: LD_VAR 0 4
77269: PPUSH
77270: CALL_OW 1
77274: ST_TO_ADDR
// break ;
77275: GO 77279
// end ; end ;
77277: GO 76923
77279: POP
77280: POP
// end ;
77281: GO 76855
77283: POP
77284: POP
// end ;
77285: LD_VAR 0 1
77289: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77290: LD_INT 0
77292: PPUSH
77293: PPUSH
77294: PPUSH
// if not mc_bases then
77295: LD_EXP 84
77299: NOT
77300: IFFALSE 77304
// exit ;
77302: GO 77393
// for i = 1 to mc_bases do
77304: LD_ADDR_VAR 0 2
77308: PUSH
77309: DOUBLE
77310: LD_INT 1
77312: DEC
77313: ST_TO_ADDR
77314: LD_EXP 84
77318: PUSH
77319: FOR_TO
77320: IFFALSE 77391
// begin if mc_attack [ i ] then
77322: LD_EXP 104
77326: PUSH
77327: LD_VAR 0 2
77331: ARRAY
77332: IFFALSE 77389
// begin tmp := mc_attack [ i ] [ 1 ] ;
77334: LD_ADDR_VAR 0 3
77338: PUSH
77339: LD_EXP 104
77343: PUSH
77344: LD_VAR 0 2
77348: ARRAY
77349: PUSH
77350: LD_INT 1
77352: ARRAY
77353: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
77354: LD_ADDR_EXP 104
77358: PUSH
77359: LD_EXP 104
77363: PPUSH
77364: LD_VAR 0 2
77368: PPUSH
77369: EMPTY
77370: PPUSH
77371: CALL_OW 1
77375: ST_TO_ADDR
// Attack ( tmp ) ;
77376: LD_VAR 0 3
77380: PPUSH
77381: CALL 54580 0 1
// exit ;
77385: POP
77386: POP
77387: GO 77393
// end ; end ;
77389: GO 77319
77391: POP
77392: POP
// end ;
77393: LD_VAR 0 1
77397: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77398: LD_INT 0
77400: PPUSH
77401: PPUSH
77402: PPUSH
77403: PPUSH
77404: PPUSH
77405: PPUSH
77406: PPUSH
// if not mc_bases then
77407: LD_EXP 84
77411: NOT
77412: IFFALSE 77416
// exit ;
77414: GO 78020
// for i = 1 to mc_bases do
77416: LD_ADDR_VAR 0 2
77420: PUSH
77421: DOUBLE
77422: LD_INT 1
77424: DEC
77425: ST_TO_ADDR
77426: LD_EXP 84
77430: PUSH
77431: FOR_TO
77432: IFFALSE 78018
// begin if not mc_bases [ i ] then
77434: LD_EXP 84
77438: PUSH
77439: LD_VAR 0 2
77443: ARRAY
77444: NOT
77445: IFFALSE 77449
// continue ;
77447: GO 77431
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77449: LD_ADDR_VAR 0 7
77453: PUSH
77454: LD_EXP 84
77458: PUSH
77459: LD_VAR 0 2
77463: ARRAY
77464: PUSH
77465: LD_INT 1
77467: ARRAY
77468: PPUSH
77469: CALL 19293 0 1
77473: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77474: LD_ADDR_EXP 107
77478: PUSH
77479: LD_EXP 107
77483: PPUSH
77484: LD_VAR 0 2
77488: PPUSH
77489: LD_EXP 84
77493: PUSH
77494: LD_VAR 0 2
77498: ARRAY
77499: PUSH
77500: LD_INT 1
77502: ARRAY
77503: PPUSH
77504: CALL_OW 255
77508: PPUSH
77509: LD_EXP 109
77513: PUSH
77514: LD_VAR 0 2
77518: ARRAY
77519: PPUSH
77520: CALL 19258 0 2
77524: PPUSH
77525: CALL_OW 1
77529: ST_TO_ADDR
// if not mc_scan [ i ] then
77530: LD_EXP 107
77534: PUSH
77535: LD_VAR 0 2
77539: ARRAY
77540: NOT
77541: IFFALSE 77696
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77543: LD_ADDR_VAR 0 4
77547: PUSH
77548: LD_EXP 84
77552: PUSH
77553: LD_VAR 0 2
77557: ARRAY
77558: PPUSH
77559: LD_INT 2
77561: PUSH
77562: LD_INT 25
77564: PUSH
77565: LD_INT 5
77567: PUSH
77568: EMPTY
77569: LIST
77570: LIST
77571: PUSH
77572: LD_INT 25
77574: PUSH
77575: LD_INT 8
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 25
77584: PUSH
77585: LD_INT 9
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: EMPTY
77593: LIST
77594: LIST
77595: LIST
77596: LIST
77597: PPUSH
77598: CALL_OW 72
77602: ST_TO_ADDR
// if not tmp then
77603: LD_VAR 0 4
77607: NOT
77608: IFFALSE 77612
// continue ;
77610: GO 77431
// for j in tmp do
77612: LD_ADDR_VAR 0 3
77616: PUSH
77617: LD_VAR 0 4
77621: PUSH
77622: FOR_IN
77623: IFFALSE 77694
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77625: LD_VAR 0 3
77629: PPUSH
77630: CALL_OW 310
77634: PPUSH
77635: CALL_OW 266
77639: PUSH
77640: LD_INT 5
77642: EQUAL
77643: PUSH
77644: LD_VAR 0 3
77648: PPUSH
77649: CALL_OW 257
77653: PUSH
77654: LD_INT 1
77656: EQUAL
77657: AND
77658: PUSH
77659: LD_VAR 0 3
77663: PPUSH
77664: CALL_OW 459
77668: NOT
77669: AND
77670: PUSH
77671: LD_VAR 0 7
77675: AND
77676: IFFALSE 77692
// ComChangeProfession ( j , class ) ;
77678: LD_VAR 0 3
77682: PPUSH
77683: LD_VAR 0 7
77687: PPUSH
77688: CALL_OW 123
77692: GO 77622
77694: POP
77695: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77696: LD_EXP 107
77700: PUSH
77701: LD_VAR 0 2
77705: ARRAY
77706: PUSH
77707: LD_EXP 106
77711: PUSH
77712: LD_VAR 0 2
77716: ARRAY
77717: NOT
77718: AND
77719: PUSH
77720: LD_EXP 84
77724: PUSH
77725: LD_VAR 0 2
77729: ARRAY
77730: PPUSH
77731: LD_INT 30
77733: PUSH
77734: LD_INT 32
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: PPUSH
77741: CALL_OW 72
77745: NOT
77746: AND
77747: PUSH
77748: LD_EXP 84
77752: PUSH
77753: LD_VAR 0 2
77757: ARRAY
77758: PPUSH
77759: LD_INT 2
77761: PUSH
77762: LD_INT 30
77764: PUSH
77765: LD_INT 4
77767: PUSH
77768: EMPTY
77769: LIST
77770: LIST
77771: PUSH
77772: LD_INT 30
77774: PUSH
77775: LD_INT 5
77777: PUSH
77778: EMPTY
77779: LIST
77780: LIST
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: LIST
77786: PPUSH
77787: CALL_OW 72
77791: NOT
77792: AND
77793: IFFALSE 77925
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77795: LD_ADDR_VAR 0 4
77799: PUSH
77800: LD_EXP 84
77804: PUSH
77805: LD_VAR 0 2
77809: ARRAY
77810: PPUSH
77811: LD_INT 2
77813: PUSH
77814: LD_INT 25
77816: PUSH
77817: LD_INT 1
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: PUSH
77824: LD_INT 25
77826: PUSH
77827: LD_INT 5
77829: PUSH
77830: EMPTY
77831: LIST
77832: LIST
77833: PUSH
77834: LD_INT 25
77836: PUSH
77837: LD_INT 8
77839: PUSH
77840: EMPTY
77841: LIST
77842: LIST
77843: PUSH
77844: LD_INT 25
77846: PUSH
77847: LD_INT 9
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: LIST
77858: LIST
77859: LIST
77860: PPUSH
77861: CALL_OW 72
77865: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77866: LD_ADDR_VAR 0 4
77870: PUSH
77871: LD_VAR 0 4
77875: PUSH
77876: LD_VAR 0 4
77880: PPUSH
77881: LD_INT 18
77883: PPUSH
77884: CALL 51018 0 2
77888: DIFF
77889: ST_TO_ADDR
// if tmp then
77890: LD_VAR 0 4
77894: IFFALSE 77925
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
77896: LD_VAR 0 2
77900: PPUSH
77901: LD_VAR 0 4
77905: PPUSH
77906: LD_EXP 109
77910: PUSH
77911: LD_VAR 0 2
77915: ARRAY
77916: PPUSH
77917: CALL 59289 0 3
// exit ;
77921: POP
77922: POP
77923: GO 78020
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
77925: LD_EXP 107
77929: PUSH
77930: LD_VAR 0 2
77934: ARRAY
77935: PUSH
77936: LD_EXP 106
77940: PUSH
77941: LD_VAR 0 2
77945: ARRAY
77946: AND
77947: IFFALSE 78016
// begin tmp := mc_defender [ i ] ;
77949: LD_ADDR_VAR 0 4
77953: PUSH
77954: LD_EXP 106
77958: PUSH
77959: LD_VAR 0 2
77963: ARRAY
77964: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
77965: LD_ADDR_EXP 106
77969: PUSH
77970: LD_EXP 106
77974: PPUSH
77975: LD_VAR 0 2
77979: PPUSH
77980: EMPTY
77981: PPUSH
77982: CALL_OW 1
77986: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
77987: LD_VAR 0 2
77991: PPUSH
77992: LD_VAR 0 4
77996: PPUSH
77997: LD_EXP 107
78001: PUSH
78002: LD_VAR 0 2
78006: ARRAY
78007: PPUSH
78008: CALL 59850 0 3
// exit ;
78012: POP
78013: POP
78014: GO 78020
// end ; end ;
78016: GO 77431
78018: POP
78019: POP
// end ;
78020: LD_VAR 0 1
78024: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78025: LD_INT 0
78027: PPUSH
78028: PPUSH
78029: PPUSH
78030: PPUSH
78031: PPUSH
78032: PPUSH
78033: PPUSH
78034: PPUSH
78035: PPUSH
78036: PPUSH
78037: PPUSH
// if not mc_bases then
78038: LD_EXP 84
78042: NOT
78043: IFFALSE 78047
// exit ;
78045: GO 79134
// for i = 1 to mc_bases do
78047: LD_ADDR_VAR 0 2
78051: PUSH
78052: DOUBLE
78053: LD_INT 1
78055: DEC
78056: ST_TO_ADDR
78057: LD_EXP 84
78061: PUSH
78062: FOR_TO
78063: IFFALSE 79132
// begin tmp := mc_lab [ i ] ;
78065: LD_ADDR_VAR 0 6
78069: PUSH
78070: LD_EXP 117
78074: PUSH
78075: LD_VAR 0 2
78079: ARRAY
78080: ST_TO_ADDR
// if not tmp then
78081: LD_VAR 0 6
78085: NOT
78086: IFFALSE 78090
// continue ;
78088: GO 78062
// idle_lab := 0 ;
78090: LD_ADDR_VAR 0 11
78094: PUSH
78095: LD_INT 0
78097: ST_TO_ADDR
// for j in tmp do
78098: LD_ADDR_VAR 0 3
78102: PUSH
78103: LD_VAR 0 6
78107: PUSH
78108: FOR_IN
78109: IFFALSE 79128
// begin researching := false ;
78111: LD_ADDR_VAR 0 10
78115: PUSH
78116: LD_INT 0
78118: ST_TO_ADDR
// side := GetSide ( j ) ;
78119: LD_ADDR_VAR 0 4
78123: PUSH
78124: LD_VAR 0 3
78128: PPUSH
78129: CALL_OW 255
78133: ST_TO_ADDR
// if not mc_tech [ side ] then
78134: LD_EXP 111
78138: PUSH
78139: LD_VAR 0 4
78143: ARRAY
78144: NOT
78145: IFFALSE 78149
// continue ;
78147: GO 78108
// if BuildingStatus ( j ) = bs_idle then
78149: LD_VAR 0 3
78153: PPUSH
78154: CALL_OW 461
78158: PUSH
78159: LD_INT 2
78161: EQUAL
78162: IFFALSE 78350
// begin if idle_lab and UnitsInside ( j ) < 6 then
78164: LD_VAR 0 11
78168: PUSH
78169: LD_VAR 0 3
78173: PPUSH
78174: CALL_OW 313
78178: PUSH
78179: LD_INT 6
78181: LESS
78182: AND
78183: IFFALSE 78254
// begin tmp2 := UnitsInside ( idle_lab ) ;
78185: LD_ADDR_VAR 0 9
78189: PUSH
78190: LD_VAR 0 11
78194: PPUSH
78195: CALL_OW 313
78199: ST_TO_ADDR
// if tmp2 then
78200: LD_VAR 0 9
78204: IFFALSE 78246
// for x in tmp2 do
78206: LD_ADDR_VAR 0 7
78210: PUSH
78211: LD_VAR 0 9
78215: PUSH
78216: FOR_IN
78217: IFFALSE 78244
// begin ComExitBuilding ( x ) ;
78219: LD_VAR 0 7
78223: PPUSH
78224: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78228: LD_VAR 0 7
78232: PPUSH
78233: LD_VAR 0 3
78237: PPUSH
78238: CALL_OW 180
// end ;
78242: GO 78216
78244: POP
78245: POP
// idle_lab := 0 ;
78246: LD_ADDR_VAR 0 11
78250: PUSH
78251: LD_INT 0
78253: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78254: LD_ADDR_VAR 0 5
78258: PUSH
78259: LD_EXP 111
78263: PUSH
78264: LD_VAR 0 4
78268: ARRAY
78269: PUSH
78270: FOR_IN
78271: IFFALSE 78331
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78273: LD_VAR 0 3
78277: PPUSH
78278: LD_VAR 0 5
78282: PPUSH
78283: CALL_OW 430
78287: PUSH
78288: LD_VAR 0 4
78292: PPUSH
78293: LD_VAR 0 5
78297: PPUSH
78298: CALL 18363 0 2
78302: AND
78303: IFFALSE 78329
// begin researching := true ;
78305: LD_ADDR_VAR 0 10
78309: PUSH
78310: LD_INT 1
78312: ST_TO_ADDR
// ComResearch ( j , t ) ;
78313: LD_VAR 0 3
78317: PPUSH
78318: LD_VAR 0 5
78322: PPUSH
78323: CALL_OW 124
// break ;
78327: GO 78331
// end ;
78329: GO 78270
78331: POP
78332: POP
// if not researching then
78333: LD_VAR 0 10
78337: NOT
78338: IFFALSE 78350
// idle_lab := j ;
78340: LD_ADDR_VAR 0 11
78344: PUSH
78345: LD_VAR 0 3
78349: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78350: LD_VAR 0 3
78354: PPUSH
78355: CALL_OW 461
78359: PUSH
78360: LD_INT 10
78362: EQUAL
78363: IFFALSE 78951
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78365: LD_EXP 113
78369: PUSH
78370: LD_VAR 0 2
78374: ARRAY
78375: NOT
78376: PUSH
78377: LD_EXP 114
78381: PUSH
78382: LD_VAR 0 2
78386: ARRAY
78387: NOT
78388: AND
78389: PUSH
78390: LD_EXP 111
78394: PUSH
78395: LD_VAR 0 4
78399: ARRAY
78400: PUSH
78401: LD_INT 1
78403: GREATER
78404: AND
78405: IFFALSE 78536
// begin ComCancel ( j ) ;
78407: LD_VAR 0 3
78411: PPUSH
78412: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78416: LD_ADDR_EXP 111
78420: PUSH
78421: LD_EXP 111
78425: PPUSH
78426: LD_VAR 0 4
78430: PPUSH
78431: LD_EXP 111
78435: PUSH
78436: LD_VAR 0 4
78440: ARRAY
78441: PPUSH
78442: LD_EXP 111
78446: PUSH
78447: LD_VAR 0 4
78451: ARRAY
78452: PUSH
78453: LD_INT 1
78455: MINUS
78456: PPUSH
78457: LD_EXP 111
78461: PUSH
78462: LD_VAR 0 4
78466: ARRAY
78467: PPUSH
78468: LD_INT 0
78470: PPUSH
78471: CALL 21875 0 4
78475: PPUSH
78476: CALL_OW 1
78480: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78481: LD_ADDR_EXP 111
78485: PUSH
78486: LD_EXP 111
78490: PPUSH
78491: LD_VAR 0 4
78495: PPUSH
78496: LD_EXP 111
78500: PUSH
78501: LD_VAR 0 4
78505: ARRAY
78506: PPUSH
78507: LD_EXP 111
78511: PUSH
78512: LD_VAR 0 4
78516: ARRAY
78517: PPUSH
78518: LD_INT 1
78520: PPUSH
78521: LD_INT 0
78523: PPUSH
78524: CALL 21875 0 4
78528: PPUSH
78529: CALL_OW 1
78533: ST_TO_ADDR
// continue ;
78534: GO 78108
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78536: LD_EXP 113
78540: PUSH
78541: LD_VAR 0 2
78545: ARRAY
78546: PUSH
78547: LD_EXP 114
78551: PUSH
78552: LD_VAR 0 2
78556: ARRAY
78557: NOT
78558: AND
78559: IFFALSE 78686
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78561: LD_ADDR_EXP 114
78565: PUSH
78566: LD_EXP 114
78570: PPUSH
78571: LD_VAR 0 2
78575: PUSH
78576: LD_EXP 114
78580: PUSH
78581: LD_VAR 0 2
78585: ARRAY
78586: PUSH
78587: LD_INT 1
78589: PLUS
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PPUSH
78595: LD_EXP 113
78599: PUSH
78600: LD_VAR 0 2
78604: ARRAY
78605: PUSH
78606: LD_INT 1
78608: ARRAY
78609: PPUSH
78610: CALL 22457 0 3
78614: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78615: LD_EXP 113
78619: PUSH
78620: LD_VAR 0 2
78624: ARRAY
78625: PUSH
78626: LD_INT 1
78628: ARRAY
78629: PPUSH
78630: LD_INT 112
78632: PPUSH
78633: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78637: LD_ADDR_VAR 0 9
78641: PUSH
78642: LD_EXP 113
78646: PUSH
78647: LD_VAR 0 2
78651: ARRAY
78652: PPUSH
78653: LD_INT 1
78655: PPUSH
78656: CALL_OW 3
78660: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78661: LD_ADDR_EXP 113
78665: PUSH
78666: LD_EXP 113
78670: PPUSH
78671: LD_VAR 0 2
78675: PPUSH
78676: LD_VAR 0 9
78680: PPUSH
78681: CALL_OW 1
78685: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78686: LD_EXP 113
78690: PUSH
78691: LD_VAR 0 2
78695: ARRAY
78696: PUSH
78697: LD_EXP 114
78701: PUSH
78702: LD_VAR 0 2
78706: ARRAY
78707: AND
78708: PUSH
78709: LD_EXP 114
78713: PUSH
78714: LD_VAR 0 2
78718: ARRAY
78719: PUSH
78720: LD_INT 1
78722: ARRAY
78723: PPUSH
78724: CALL_OW 310
78728: NOT
78729: AND
78730: PUSH
78731: LD_VAR 0 3
78735: PPUSH
78736: CALL_OW 313
78740: PUSH
78741: LD_INT 6
78743: EQUAL
78744: AND
78745: IFFALSE 78801
// begin tmp2 := UnitsInside ( j ) ;
78747: LD_ADDR_VAR 0 9
78751: PUSH
78752: LD_VAR 0 3
78756: PPUSH
78757: CALL_OW 313
78761: ST_TO_ADDR
// if tmp2 = 6 then
78762: LD_VAR 0 9
78766: PUSH
78767: LD_INT 6
78769: EQUAL
78770: IFFALSE 78801
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78772: LD_VAR 0 9
78776: PUSH
78777: LD_INT 1
78779: ARRAY
78780: PPUSH
78781: LD_INT 112
78783: PPUSH
78784: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78788: LD_VAR 0 9
78792: PUSH
78793: LD_INT 1
78795: ARRAY
78796: PPUSH
78797: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78801: LD_EXP 114
78805: PUSH
78806: LD_VAR 0 2
78810: ARRAY
78811: PUSH
78812: LD_EXP 114
78816: PUSH
78817: LD_VAR 0 2
78821: ARRAY
78822: PUSH
78823: LD_INT 1
78825: ARRAY
78826: PPUSH
78827: CALL_OW 314
78831: NOT
78832: AND
78833: PUSH
78834: LD_EXP 114
78838: PUSH
78839: LD_VAR 0 2
78843: ARRAY
78844: PUSH
78845: LD_INT 1
78847: ARRAY
78848: PPUSH
78849: CALL_OW 310
78853: NOT
78854: AND
78855: IFFALSE 78881
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78857: LD_EXP 114
78861: PUSH
78862: LD_VAR 0 2
78866: ARRAY
78867: PUSH
78868: LD_INT 1
78870: ARRAY
78871: PPUSH
78872: LD_VAR 0 3
78876: PPUSH
78877: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78881: LD_EXP 114
78885: PUSH
78886: LD_VAR 0 2
78890: ARRAY
78891: PUSH
78892: LD_INT 1
78894: ARRAY
78895: PPUSH
78896: CALL_OW 310
78900: PUSH
78901: LD_EXP 114
78905: PUSH
78906: LD_VAR 0 2
78910: ARRAY
78911: PUSH
78912: LD_INT 1
78914: ARRAY
78915: PPUSH
78916: CALL_OW 310
78920: PPUSH
78921: CALL_OW 461
78925: PUSH
78926: LD_INT 3
78928: NONEQUAL
78929: AND
78930: IFFALSE 78951
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78932: LD_EXP 114
78936: PUSH
78937: LD_VAR 0 2
78941: ARRAY
78942: PUSH
78943: LD_INT 1
78945: ARRAY
78946: PPUSH
78947: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
78951: LD_VAR 0 3
78955: PPUSH
78956: CALL_OW 461
78960: PUSH
78961: LD_INT 6
78963: EQUAL
78964: PUSH
78965: LD_VAR 0 6
78969: PUSH
78970: LD_INT 1
78972: GREATER
78973: AND
78974: IFFALSE 79126
// begin sci := [ ] ;
78976: LD_ADDR_VAR 0 8
78980: PUSH
78981: EMPTY
78982: ST_TO_ADDR
// for x in ( tmp diff j ) do
78983: LD_ADDR_VAR 0 7
78987: PUSH
78988: LD_VAR 0 6
78992: PUSH
78993: LD_VAR 0 3
78997: DIFF
78998: PUSH
78999: FOR_IN
79000: IFFALSE 79052
// begin if sci = 6 then
79002: LD_VAR 0 8
79006: PUSH
79007: LD_INT 6
79009: EQUAL
79010: IFFALSE 79014
// break ;
79012: GO 79052
// if BuildingStatus ( x ) = bs_idle then
79014: LD_VAR 0 7
79018: PPUSH
79019: CALL_OW 461
79023: PUSH
79024: LD_INT 2
79026: EQUAL
79027: IFFALSE 79050
// sci := sci ^ UnitsInside ( x ) ;
79029: LD_ADDR_VAR 0 8
79033: PUSH
79034: LD_VAR 0 8
79038: PUSH
79039: LD_VAR 0 7
79043: PPUSH
79044: CALL_OW 313
79048: ADD
79049: ST_TO_ADDR
// end ;
79050: GO 78999
79052: POP
79053: POP
// if not sci then
79054: LD_VAR 0 8
79058: NOT
79059: IFFALSE 79063
// continue ;
79061: GO 78108
// for x in sci do
79063: LD_ADDR_VAR 0 7
79067: PUSH
79068: LD_VAR 0 8
79072: PUSH
79073: FOR_IN
79074: IFFALSE 79124
// if IsInUnit ( x ) and not HasTask ( x ) then
79076: LD_VAR 0 7
79080: PPUSH
79081: CALL_OW 310
79085: PUSH
79086: LD_VAR 0 7
79090: PPUSH
79091: CALL_OW 314
79095: NOT
79096: AND
79097: IFFALSE 79122
// begin ComExitBuilding ( x ) ;
79099: LD_VAR 0 7
79103: PPUSH
79104: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79108: LD_VAR 0 7
79112: PPUSH
79113: LD_VAR 0 3
79117: PPUSH
79118: CALL_OW 180
// end ;
79122: GO 79073
79124: POP
79125: POP
// end ; end ;
79126: GO 78108
79128: POP
79129: POP
// end ;
79130: GO 78062
79132: POP
79133: POP
// end ;
79134: LD_VAR 0 1
79138: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79139: LD_INT 0
79141: PPUSH
79142: PPUSH
// if not mc_bases then
79143: LD_EXP 84
79147: NOT
79148: IFFALSE 79152
// exit ;
79150: GO 79233
// for i = 1 to mc_bases do
79152: LD_ADDR_VAR 0 2
79156: PUSH
79157: DOUBLE
79158: LD_INT 1
79160: DEC
79161: ST_TO_ADDR
79162: LD_EXP 84
79166: PUSH
79167: FOR_TO
79168: IFFALSE 79231
// if mc_mines [ i ] and mc_miners [ i ] then
79170: LD_EXP 97
79174: PUSH
79175: LD_VAR 0 2
79179: ARRAY
79180: PUSH
79181: LD_EXP 98
79185: PUSH
79186: LD_VAR 0 2
79190: ARRAY
79191: AND
79192: IFFALSE 79229
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79194: LD_EXP 98
79198: PUSH
79199: LD_VAR 0 2
79203: ARRAY
79204: PUSH
79205: LD_INT 1
79207: ARRAY
79208: PPUSH
79209: CALL_OW 255
79213: PPUSH
79214: LD_EXP 97
79218: PUSH
79219: LD_VAR 0 2
79223: ARRAY
79224: PPUSH
79225: CALL 19446 0 2
79229: GO 79167
79231: POP
79232: POP
// end ;
79233: LD_VAR 0 1
79237: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79238: LD_INT 0
79240: PPUSH
79241: PPUSH
79242: PPUSH
79243: PPUSH
79244: PPUSH
79245: PPUSH
79246: PPUSH
79247: PPUSH
// if not mc_bases or not mc_parking then
79248: LD_EXP 84
79252: NOT
79253: PUSH
79254: LD_EXP 108
79258: NOT
79259: OR
79260: IFFALSE 79264
// exit ;
79262: GO 79963
// for i = 1 to mc_bases do
79264: LD_ADDR_VAR 0 2
79268: PUSH
79269: DOUBLE
79270: LD_INT 1
79272: DEC
79273: ST_TO_ADDR
79274: LD_EXP 84
79278: PUSH
79279: FOR_TO
79280: IFFALSE 79961
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79282: LD_EXP 84
79286: PUSH
79287: LD_VAR 0 2
79291: ARRAY
79292: NOT
79293: PUSH
79294: LD_EXP 108
79298: PUSH
79299: LD_VAR 0 2
79303: ARRAY
79304: NOT
79305: OR
79306: IFFALSE 79310
// continue ;
79308: GO 79279
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79310: LD_ADDR_VAR 0 5
79314: PUSH
79315: LD_EXP 84
79319: PUSH
79320: LD_VAR 0 2
79324: ARRAY
79325: PUSH
79326: LD_INT 1
79328: ARRAY
79329: PPUSH
79330: CALL_OW 255
79334: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79335: LD_ADDR_VAR 0 6
79339: PUSH
79340: LD_EXP 84
79344: PUSH
79345: LD_VAR 0 2
79349: ARRAY
79350: PPUSH
79351: LD_INT 30
79353: PUSH
79354: LD_INT 3
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PPUSH
79361: CALL_OW 72
79365: ST_TO_ADDR
// if not fac then
79366: LD_VAR 0 6
79370: NOT
79371: IFFALSE 79422
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79373: LD_ADDR_VAR 0 6
79377: PUSH
79378: LD_EXP 84
79382: PUSH
79383: LD_VAR 0 2
79387: ARRAY
79388: PPUSH
79389: LD_INT 2
79391: PUSH
79392: LD_INT 30
79394: PUSH
79395: LD_INT 0
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: LD_INT 30
79404: PUSH
79405: LD_INT 1
79407: PUSH
79408: EMPTY
79409: LIST
79410: LIST
79411: PUSH
79412: EMPTY
79413: LIST
79414: LIST
79415: LIST
79416: PPUSH
79417: CALL_OW 72
79421: ST_TO_ADDR
// if not fac then
79422: LD_VAR 0 6
79426: NOT
79427: IFFALSE 79431
// continue ;
79429: GO 79279
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79431: LD_ADDR_VAR 0 7
79435: PUSH
79436: LD_EXP 108
79440: PUSH
79441: LD_VAR 0 2
79445: ARRAY
79446: PPUSH
79447: LD_INT 22
79449: PUSH
79450: LD_VAR 0 5
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 21
79461: PUSH
79462: LD_INT 2
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 3
79471: PUSH
79472: LD_INT 24
79474: PUSH
79475: LD_INT 1000
79477: PUSH
79478: EMPTY
79479: LIST
79480: LIST
79481: PUSH
79482: EMPTY
79483: LIST
79484: LIST
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: LIST
79490: PPUSH
79491: CALL_OW 70
79495: ST_TO_ADDR
// for j in fac do
79496: LD_ADDR_VAR 0 3
79500: PUSH
79501: LD_VAR 0 6
79505: PUSH
79506: FOR_IN
79507: IFFALSE 79588
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79509: LD_ADDR_VAR 0 7
79513: PUSH
79514: LD_VAR 0 7
79518: PUSH
79519: LD_INT 22
79521: PUSH
79522: LD_VAR 0 5
79526: PUSH
79527: EMPTY
79528: LIST
79529: LIST
79530: PUSH
79531: LD_INT 91
79533: PUSH
79534: LD_VAR 0 3
79538: PUSH
79539: LD_INT 15
79541: PUSH
79542: EMPTY
79543: LIST
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 21
79549: PUSH
79550: LD_INT 2
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 3
79559: PUSH
79560: LD_INT 24
79562: PUSH
79563: LD_INT 1000
79565: PUSH
79566: EMPTY
79567: LIST
79568: LIST
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: LIST
79578: LIST
79579: PPUSH
79580: CALL_OW 69
79584: UNION
79585: ST_TO_ADDR
79586: GO 79506
79588: POP
79589: POP
// if not vehs then
79590: LD_VAR 0 7
79594: NOT
79595: IFFALSE 79621
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79597: LD_ADDR_EXP 96
79601: PUSH
79602: LD_EXP 96
79606: PPUSH
79607: LD_VAR 0 2
79611: PPUSH
79612: EMPTY
79613: PPUSH
79614: CALL_OW 1
79618: ST_TO_ADDR
// continue ;
79619: GO 79279
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79621: LD_ADDR_VAR 0 8
79625: PUSH
79626: LD_EXP 84
79630: PUSH
79631: LD_VAR 0 2
79635: ARRAY
79636: PPUSH
79637: LD_INT 30
79639: PUSH
79640: LD_INT 3
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PPUSH
79647: CALL_OW 72
79651: ST_TO_ADDR
// if tmp then
79652: LD_VAR 0 8
79656: IFFALSE 79759
// begin for j in tmp do
79658: LD_ADDR_VAR 0 3
79662: PUSH
79663: LD_VAR 0 8
79667: PUSH
79668: FOR_IN
79669: IFFALSE 79757
// for k in UnitsInside ( j ) do
79671: LD_ADDR_VAR 0 4
79675: PUSH
79676: LD_VAR 0 3
79680: PPUSH
79681: CALL_OW 313
79685: PUSH
79686: FOR_IN
79687: IFFALSE 79753
// if k then
79689: LD_VAR 0 4
79693: IFFALSE 79751
// if not k in mc_repair_vehicle [ i ] then
79695: LD_VAR 0 4
79699: PUSH
79700: LD_EXP 96
79704: PUSH
79705: LD_VAR 0 2
79709: ARRAY
79710: IN
79711: NOT
79712: IFFALSE 79751
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79714: LD_ADDR_EXP 96
79718: PUSH
79719: LD_EXP 96
79723: PPUSH
79724: LD_VAR 0 2
79728: PPUSH
79729: LD_EXP 96
79733: PUSH
79734: LD_VAR 0 2
79738: ARRAY
79739: PUSH
79740: LD_VAR 0 4
79744: UNION
79745: PPUSH
79746: CALL_OW 1
79750: ST_TO_ADDR
79751: GO 79686
79753: POP
79754: POP
79755: GO 79668
79757: POP
79758: POP
// end ; if not mc_repair_vehicle [ i ] then
79759: LD_EXP 96
79763: PUSH
79764: LD_VAR 0 2
79768: ARRAY
79769: NOT
79770: IFFALSE 79774
// continue ;
79772: GO 79279
// for j in mc_repair_vehicle [ i ] do
79774: LD_ADDR_VAR 0 3
79778: PUSH
79779: LD_EXP 96
79783: PUSH
79784: LD_VAR 0 2
79788: ARRAY
79789: PUSH
79790: FOR_IN
79791: IFFALSE 79957
// begin if GetClass ( j ) <> 3 then
79793: LD_VAR 0 3
79797: PPUSH
79798: CALL_OW 257
79802: PUSH
79803: LD_INT 3
79805: NONEQUAL
79806: IFFALSE 79847
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79808: LD_ADDR_EXP 96
79812: PUSH
79813: LD_EXP 96
79817: PPUSH
79818: LD_VAR 0 2
79822: PPUSH
79823: LD_EXP 96
79827: PUSH
79828: LD_VAR 0 2
79832: ARRAY
79833: PUSH
79834: LD_VAR 0 3
79838: DIFF
79839: PPUSH
79840: CALL_OW 1
79844: ST_TO_ADDR
// continue ;
79845: GO 79790
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79847: LD_VAR 0 3
79851: PPUSH
79852: CALL_OW 311
79856: NOT
79857: PUSH
79858: LD_VAR 0 3
79862: PUSH
79863: LD_EXP 87
79867: PUSH
79868: LD_VAR 0 2
79872: ARRAY
79873: PUSH
79874: LD_INT 1
79876: ARRAY
79877: IN
79878: NOT
79879: AND
79880: PUSH
79881: LD_VAR 0 3
79885: PUSH
79886: LD_EXP 87
79890: PUSH
79891: LD_VAR 0 2
79895: ARRAY
79896: PUSH
79897: LD_INT 2
79899: ARRAY
79900: IN
79901: NOT
79902: AND
79903: IFFALSE 79955
// begin if IsInUnit ( j ) then
79905: LD_VAR 0 3
79909: PPUSH
79910: CALL_OW 310
79914: IFFALSE 79925
// ComExitBuilding ( j ) ;
79916: LD_VAR 0 3
79920: PPUSH
79921: CALL_OW 122
// if not HasTask ( j ) then
79925: LD_VAR 0 3
79929: PPUSH
79930: CALL_OW 314
79934: NOT
79935: IFFALSE 79955
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
79937: LD_VAR 0 3
79941: PPUSH
79942: LD_VAR 0 7
79946: PUSH
79947: LD_INT 1
79949: ARRAY
79950: PPUSH
79951: CALL_OW 189
// end ; end ;
79955: GO 79790
79957: POP
79958: POP
// end ;
79959: GO 79279
79961: POP
79962: POP
// end ;
79963: LD_VAR 0 1
79967: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
79968: LD_INT 0
79970: PPUSH
79971: PPUSH
79972: PPUSH
79973: PPUSH
79974: PPUSH
79975: PPUSH
79976: PPUSH
79977: PPUSH
79978: PPUSH
79979: PPUSH
79980: PPUSH
// if not mc_bases then
79981: LD_EXP 84
79985: NOT
79986: IFFALSE 79990
// exit ;
79988: GO 80792
// for i = 1 to mc_bases do
79990: LD_ADDR_VAR 0 2
79994: PUSH
79995: DOUBLE
79996: LD_INT 1
79998: DEC
79999: ST_TO_ADDR
80000: LD_EXP 84
80004: PUSH
80005: FOR_TO
80006: IFFALSE 80790
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
80008: LD_EXP 112
80012: PUSH
80013: LD_VAR 0 2
80017: ARRAY
80018: NOT
80019: PUSH
80020: LD_EXP 87
80024: PUSH
80025: LD_VAR 0 2
80029: ARRAY
80030: PUSH
80031: LD_INT 1
80033: ARRAY
80034: OR
80035: PUSH
80036: LD_EXP 87
80040: PUSH
80041: LD_VAR 0 2
80045: ARRAY
80046: PUSH
80047: LD_INT 2
80049: ARRAY
80050: OR
80051: PUSH
80052: LD_EXP 110
80056: PUSH
80057: LD_VAR 0 2
80061: ARRAY
80062: PPUSH
80063: LD_INT 1
80065: PPUSH
80066: CALL_OW 325
80070: NOT
80071: OR
80072: PUSH
80073: LD_EXP 107
80077: PUSH
80078: LD_VAR 0 2
80082: ARRAY
80083: OR
80084: IFFALSE 80088
// continue ;
80086: GO 80005
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80088: LD_ADDR_VAR 0 8
80092: PUSH
80093: LD_EXP 84
80097: PUSH
80098: LD_VAR 0 2
80102: ARRAY
80103: PPUSH
80104: LD_INT 25
80106: PUSH
80107: LD_INT 4
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 50
80116: PUSH
80117: EMPTY
80118: LIST
80119: PUSH
80120: LD_INT 3
80122: PUSH
80123: LD_INT 60
80125: PUSH
80126: EMPTY
80127: LIST
80128: PUSH
80129: EMPTY
80130: LIST
80131: LIST
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: LIST
80137: PPUSH
80138: CALL_OW 72
80142: PUSH
80143: LD_EXP 88
80147: PUSH
80148: LD_VAR 0 2
80152: ARRAY
80153: DIFF
80154: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80155: LD_ADDR_VAR 0 9
80159: PUSH
80160: LD_EXP 84
80164: PUSH
80165: LD_VAR 0 2
80169: ARRAY
80170: PPUSH
80171: LD_INT 2
80173: PUSH
80174: LD_INT 30
80176: PUSH
80177: LD_INT 0
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 30
80186: PUSH
80187: LD_INT 1
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: LIST
80198: PPUSH
80199: CALL_OW 72
80203: ST_TO_ADDR
// if not tmp or not dep then
80204: LD_VAR 0 8
80208: NOT
80209: PUSH
80210: LD_VAR 0 9
80214: NOT
80215: OR
80216: IFFALSE 80220
// continue ;
80218: GO 80005
// side := GetSide ( tmp [ 1 ] ) ;
80220: LD_ADDR_VAR 0 11
80224: PUSH
80225: LD_VAR 0 8
80229: PUSH
80230: LD_INT 1
80232: ARRAY
80233: PPUSH
80234: CALL_OW 255
80238: ST_TO_ADDR
// dep := dep [ 1 ] ;
80239: LD_ADDR_VAR 0 9
80243: PUSH
80244: LD_VAR 0 9
80248: PUSH
80249: LD_INT 1
80251: ARRAY
80252: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80253: LD_ADDR_VAR 0 7
80257: PUSH
80258: LD_EXP 112
80262: PUSH
80263: LD_VAR 0 2
80267: ARRAY
80268: PPUSH
80269: LD_INT 22
80271: PUSH
80272: LD_INT 0
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 25
80281: PUSH
80282: LD_INT 12
80284: PUSH
80285: EMPTY
80286: LIST
80287: LIST
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PPUSH
80293: CALL_OW 70
80297: PUSH
80298: LD_INT 22
80300: PUSH
80301: LD_INT 0
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 25
80310: PUSH
80311: LD_INT 12
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 91
80320: PUSH
80321: LD_VAR 0 9
80325: PUSH
80326: LD_INT 20
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: LIST
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: LIST
80338: PPUSH
80339: CALL_OW 69
80343: UNION
80344: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80345: LD_ADDR_VAR 0 10
80349: PUSH
80350: LD_EXP 112
80354: PUSH
80355: LD_VAR 0 2
80359: ARRAY
80360: PPUSH
80361: LD_INT 81
80363: PUSH
80364: LD_VAR 0 11
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PPUSH
80373: CALL_OW 70
80377: ST_TO_ADDR
// if not apes or danger_at_area then
80378: LD_VAR 0 7
80382: NOT
80383: PUSH
80384: LD_VAR 0 10
80388: OR
80389: IFFALSE 80439
// begin if mc_taming [ i ] then
80391: LD_EXP 115
80395: PUSH
80396: LD_VAR 0 2
80400: ARRAY
80401: IFFALSE 80437
// begin MC_Reset ( i , 121 ) ;
80403: LD_VAR 0 2
80407: PPUSH
80408: LD_INT 121
80410: PPUSH
80411: CALL 65842 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80415: LD_ADDR_EXP 115
80419: PUSH
80420: LD_EXP 115
80424: PPUSH
80425: LD_VAR 0 2
80429: PPUSH
80430: EMPTY
80431: PPUSH
80432: CALL_OW 1
80436: ST_TO_ADDR
// end ; continue ;
80437: GO 80005
// end ; for j in tmp do
80439: LD_ADDR_VAR 0 3
80443: PUSH
80444: LD_VAR 0 8
80448: PUSH
80449: FOR_IN
80450: IFFALSE 80786
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80452: LD_VAR 0 3
80456: PUSH
80457: LD_EXP 115
80461: PUSH
80462: LD_VAR 0 2
80466: ARRAY
80467: IN
80468: NOT
80469: PUSH
80470: LD_EXP 115
80474: PUSH
80475: LD_VAR 0 2
80479: ARRAY
80480: PUSH
80481: LD_INT 3
80483: LESS
80484: AND
80485: IFFALSE 80543
// begin SetTag ( j , 121 ) ;
80487: LD_VAR 0 3
80491: PPUSH
80492: LD_INT 121
80494: PPUSH
80495: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80499: LD_ADDR_EXP 115
80503: PUSH
80504: LD_EXP 115
80508: PPUSH
80509: LD_VAR 0 2
80513: PUSH
80514: LD_EXP 115
80518: PUSH
80519: LD_VAR 0 2
80523: ARRAY
80524: PUSH
80525: LD_INT 1
80527: PLUS
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: PPUSH
80533: LD_VAR 0 3
80537: PPUSH
80538: CALL 22457 0 3
80542: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80543: LD_VAR 0 3
80547: PUSH
80548: LD_EXP 115
80552: PUSH
80553: LD_VAR 0 2
80557: ARRAY
80558: IN
80559: IFFALSE 80784
// begin if GetClass ( j ) <> 4 then
80561: LD_VAR 0 3
80565: PPUSH
80566: CALL_OW 257
80570: PUSH
80571: LD_INT 4
80573: NONEQUAL
80574: IFFALSE 80627
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80576: LD_ADDR_EXP 115
80580: PUSH
80581: LD_EXP 115
80585: PPUSH
80586: LD_VAR 0 2
80590: PPUSH
80591: LD_EXP 115
80595: PUSH
80596: LD_VAR 0 2
80600: ARRAY
80601: PUSH
80602: LD_VAR 0 3
80606: DIFF
80607: PPUSH
80608: CALL_OW 1
80612: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80613: LD_VAR 0 3
80617: PPUSH
80618: LD_INT 0
80620: PPUSH
80621: CALL_OW 109
// continue ;
80625: GO 80449
// end ; if IsInUnit ( j ) then
80627: LD_VAR 0 3
80631: PPUSH
80632: CALL_OW 310
80636: IFFALSE 80647
// ComExitBuilding ( j ) ;
80638: LD_VAR 0 3
80642: PPUSH
80643: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80647: LD_ADDR_VAR 0 6
80651: PUSH
80652: LD_VAR 0 7
80656: PPUSH
80657: LD_VAR 0 3
80661: PPUSH
80662: CALL_OW 74
80666: ST_TO_ADDR
// if not ape then
80667: LD_VAR 0 6
80671: NOT
80672: IFFALSE 80676
// break ;
80674: GO 80786
// x := GetX ( ape ) ;
80676: LD_ADDR_VAR 0 4
80680: PUSH
80681: LD_VAR 0 6
80685: PPUSH
80686: CALL_OW 250
80690: ST_TO_ADDR
// y := GetY ( ape ) ;
80691: LD_ADDR_VAR 0 5
80695: PUSH
80696: LD_VAR 0 6
80700: PPUSH
80701: CALL_OW 251
80705: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80706: LD_VAR 0 4
80710: PPUSH
80711: LD_VAR 0 5
80715: PPUSH
80716: CALL_OW 488
80720: NOT
80721: PUSH
80722: LD_VAR 0 11
80726: PPUSH
80727: LD_VAR 0 4
80731: PPUSH
80732: LD_VAR 0 5
80736: PPUSH
80737: LD_INT 20
80739: PPUSH
80740: CALL 23353 0 4
80744: PUSH
80745: LD_INT 4
80747: ARRAY
80748: OR
80749: IFFALSE 80753
// break ;
80751: GO 80786
// if not HasTask ( j ) then
80753: LD_VAR 0 3
80757: PPUSH
80758: CALL_OW 314
80762: NOT
80763: IFFALSE 80784
// ComTameXY ( j , x , y ) ;
80765: LD_VAR 0 3
80769: PPUSH
80770: LD_VAR 0 4
80774: PPUSH
80775: LD_VAR 0 5
80779: PPUSH
80780: CALL_OW 131
// end ; end ;
80784: GO 80449
80786: POP
80787: POP
// end ;
80788: GO 80005
80790: POP
80791: POP
// end ;
80792: LD_VAR 0 1
80796: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80797: LD_INT 0
80799: PPUSH
80800: PPUSH
80801: PPUSH
80802: PPUSH
80803: PPUSH
80804: PPUSH
80805: PPUSH
80806: PPUSH
// if not mc_bases then
80807: LD_EXP 84
80811: NOT
80812: IFFALSE 80816
// exit ;
80814: GO 81442
// for i = 1 to mc_bases do
80816: LD_ADDR_VAR 0 2
80820: PUSH
80821: DOUBLE
80822: LD_INT 1
80824: DEC
80825: ST_TO_ADDR
80826: LD_EXP 84
80830: PUSH
80831: FOR_TO
80832: IFFALSE 81440
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80834: LD_EXP 113
80838: PUSH
80839: LD_VAR 0 2
80843: ARRAY
80844: NOT
80845: PUSH
80846: LD_EXP 113
80850: PUSH
80851: LD_VAR 0 2
80855: ARRAY
80856: PPUSH
80857: LD_INT 25
80859: PUSH
80860: LD_INT 12
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PPUSH
80867: CALL_OW 72
80871: NOT
80872: OR
80873: IFFALSE 80877
// continue ;
80875: GO 80831
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80877: LD_ADDR_VAR 0 5
80881: PUSH
80882: LD_EXP 113
80886: PUSH
80887: LD_VAR 0 2
80891: ARRAY
80892: PUSH
80893: LD_INT 1
80895: ARRAY
80896: PPUSH
80897: CALL_OW 255
80901: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80902: LD_VAR 0 5
80906: PPUSH
80907: LD_INT 2
80909: PPUSH
80910: CALL_OW 325
80914: IFFALSE 81167
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80916: LD_ADDR_VAR 0 4
80920: PUSH
80921: LD_EXP 113
80925: PUSH
80926: LD_VAR 0 2
80930: ARRAY
80931: PPUSH
80932: LD_INT 25
80934: PUSH
80935: LD_INT 16
80937: PUSH
80938: EMPTY
80939: LIST
80940: LIST
80941: PPUSH
80942: CALL_OW 72
80946: ST_TO_ADDR
// if tmp < 6 then
80947: LD_VAR 0 4
80951: PUSH
80952: LD_INT 6
80954: LESS
80955: IFFALSE 81167
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80957: LD_ADDR_VAR 0 6
80961: PUSH
80962: LD_EXP 84
80966: PUSH
80967: LD_VAR 0 2
80971: ARRAY
80972: PPUSH
80973: LD_INT 2
80975: PUSH
80976: LD_INT 30
80978: PUSH
80979: LD_INT 0
80981: PUSH
80982: EMPTY
80983: LIST
80984: LIST
80985: PUSH
80986: LD_INT 30
80988: PUSH
80989: LD_INT 1
80991: PUSH
80992: EMPTY
80993: LIST
80994: LIST
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: LIST
81000: PPUSH
81001: CALL_OW 72
81005: ST_TO_ADDR
// if depot then
81006: LD_VAR 0 6
81010: IFFALSE 81167
// begin selected := 0 ;
81012: LD_ADDR_VAR 0 7
81016: PUSH
81017: LD_INT 0
81019: ST_TO_ADDR
// for j in depot do
81020: LD_ADDR_VAR 0 3
81024: PUSH
81025: LD_VAR 0 6
81029: PUSH
81030: FOR_IN
81031: IFFALSE 81062
// begin if UnitsInside ( j ) < 6 then
81033: LD_VAR 0 3
81037: PPUSH
81038: CALL_OW 313
81042: PUSH
81043: LD_INT 6
81045: LESS
81046: IFFALSE 81060
// begin selected := j ;
81048: LD_ADDR_VAR 0 7
81052: PUSH
81053: LD_VAR 0 3
81057: ST_TO_ADDR
// break ;
81058: GO 81062
// end ; end ;
81060: GO 81030
81062: POP
81063: POP
// if selected then
81064: LD_VAR 0 7
81068: IFFALSE 81167
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81070: LD_ADDR_VAR 0 3
81074: PUSH
81075: LD_EXP 113
81079: PUSH
81080: LD_VAR 0 2
81084: ARRAY
81085: PPUSH
81086: LD_INT 25
81088: PUSH
81089: LD_INT 12
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PPUSH
81096: CALL_OW 72
81100: PUSH
81101: FOR_IN
81102: IFFALSE 81165
// if not HasTask ( j ) then
81104: LD_VAR 0 3
81108: PPUSH
81109: CALL_OW 314
81113: NOT
81114: IFFALSE 81163
// begin if not IsInUnit ( j ) then
81116: LD_VAR 0 3
81120: PPUSH
81121: CALL_OW 310
81125: NOT
81126: IFFALSE 81142
// ComEnterUnit ( j , selected ) ;
81128: LD_VAR 0 3
81132: PPUSH
81133: LD_VAR 0 7
81137: PPUSH
81138: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81142: LD_VAR 0 3
81146: PPUSH
81147: LD_INT 16
81149: PPUSH
81150: CALL_OW 183
// AddComExitBuilding ( j ) ;
81154: LD_VAR 0 3
81158: PPUSH
81159: CALL_OW 182
// end ;
81163: GO 81101
81165: POP
81166: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81167: LD_VAR 0 5
81171: PPUSH
81172: LD_INT 11
81174: PPUSH
81175: CALL_OW 325
81179: IFFALSE 81438
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81181: LD_ADDR_VAR 0 4
81185: PUSH
81186: LD_EXP 113
81190: PUSH
81191: LD_VAR 0 2
81195: ARRAY
81196: PPUSH
81197: LD_INT 25
81199: PUSH
81200: LD_INT 16
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PPUSH
81207: CALL_OW 72
81211: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81212: LD_VAR 0 4
81216: PUSH
81217: LD_INT 6
81219: GREATEREQUAL
81220: PUSH
81221: LD_VAR 0 5
81225: PPUSH
81226: LD_INT 2
81228: PPUSH
81229: CALL_OW 325
81233: NOT
81234: OR
81235: IFFALSE 81438
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81237: LD_ADDR_VAR 0 8
81241: PUSH
81242: LD_EXP 84
81246: PUSH
81247: LD_VAR 0 2
81251: ARRAY
81252: PPUSH
81253: LD_INT 2
81255: PUSH
81256: LD_INT 30
81258: PUSH
81259: LD_INT 4
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 30
81268: PUSH
81269: LD_INT 5
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: LIST
81280: PPUSH
81281: CALL_OW 72
81285: ST_TO_ADDR
// if barracks then
81286: LD_VAR 0 8
81290: IFFALSE 81438
// begin selected := 0 ;
81292: LD_ADDR_VAR 0 7
81296: PUSH
81297: LD_INT 0
81299: ST_TO_ADDR
// for j in barracks do
81300: LD_ADDR_VAR 0 3
81304: PUSH
81305: LD_VAR 0 8
81309: PUSH
81310: FOR_IN
81311: IFFALSE 81342
// begin if UnitsInside ( j ) < 6 then
81313: LD_VAR 0 3
81317: PPUSH
81318: CALL_OW 313
81322: PUSH
81323: LD_INT 6
81325: LESS
81326: IFFALSE 81340
// begin selected := j ;
81328: LD_ADDR_VAR 0 7
81332: PUSH
81333: LD_VAR 0 3
81337: ST_TO_ADDR
// break ;
81338: GO 81342
// end ; end ;
81340: GO 81310
81342: POP
81343: POP
// if selected then
81344: LD_VAR 0 7
81348: IFFALSE 81438
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81350: LD_ADDR_VAR 0 3
81354: PUSH
81355: LD_EXP 113
81359: PUSH
81360: LD_VAR 0 2
81364: ARRAY
81365: PPUSH
81366: LD_INT 25
81368: PUSH
81369: LD_INT 12
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PPUSH
81376: CALL_OW 72
81380: PUSH
81381: FOR_IN
81382: IFFALSE 81436
// if not IsInUnit ( j ) and not HasTask ( j ) then
81384: LD_VAR 0 3
81388: PPUSH
81389: CALL_OW 310
81393: NOT
81394: PUSH
81395: LD_VAR 0 3
81399: PPUSH
81400: CALL_OW 314
81404: NOT
81405: AND
81406: IFFALSE 81434
// begin ComEnterUnit ( j , selected ) ;
81408: LD_VAR 0 3
81412: PPUSH
81413: LD_VAR 0 7
81417: PPUSH
81418: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81422: LD_VAR 0 3
81426: PPUSH
81427: LD_INT 15
81429: PPUSH
81430: CALL_OW 183
// end ;
81434: GO 81381
81436: POP
81437: POP
// end ; end ; end ; end ; end ;
81438: GO 80831
81440: POP
81441: POP
// end ;
81442: LD_VAR 0 1
81446: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81447: LD_INT 0
81449: PPUSH
81450: PPUSH
81451: PPUSH
81452: PPUSH
// if not mc_bases then
81453: LD_EXP 84
81457: NOT
81458: IFFALSE 81462
// exit ;
81460: GO 81640
// for i = 1 to mc_bases do
81462: LD_ADDR_VAR 0 2
81466: PUSH
81467: DOUBLE
81468: LD_INT 1
81470: DEC
81471: ST_TO_ADDR
81472: LD_EXP 84
81476: PUSH
81477: FOR_TO
81478: IFFALSE 81638
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81480: LD_ADDR_VAR 0 4
81484: PUSH
81485: LD_EXP 84
81489: PUSH
81490: LD_VAR 0 2
81494: ARRAY
81495: PPUSH
81496: LD_INT 25
81498: PUSH
81499: LD_INT 9
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PPUSH
81506: CALL_OW 72
81510: ST_TO_ADDR
// if not tmp then
81511: LD_VAR 0 4
81515: NOT
81516: IFFALSE 81520
// continue ;
81518: GO 81477
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81520: LD_EXP 110
81524: PUSH
81525: LD_VAR 0 2
81529: ARRAY
81530: PPUSH
81531: LD_INT 29
81533: PPUSH
81534: CALL_OW 325
81538: NOT
81539: PUSH
81540: LD_EXP 110
81544: PUSH
81545: LD_VAR 0 2
81549: ARRAY
81550: PPUSH
81551: LD_INT 28
81553: PPUSH
81554: CALL_OW 325
81558: NOT
81559: AND
81560: IFFALSE 81564
// continue ;
81562: GO 81477
// for j in tmp do
81564: LD_ADDR_VAR 0 3
81568: PUSH
81569: LD_VAR 0 4
81573: PUSH
81574: FOR_IN
81575: IFFALSE 81634
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81577: LD_VAR 0 3
81581: PUSH
81582: LD_EXP 87
81586: PUSH
81587: LD_VAR 0 2
81591: ARRAY
81592: PUSH
81593: LD_INT 1
81595: ARRAY
81596: IN
81597: NOT
81598: PUSH
81599: LD_VAR 0 3
81603: PUSH
81604: LD_EXP 87
81608: PUSH
81609: LD_VAR 0 2
81613: ARRAY
81614: PUSH
81615: LD_INT 2
81617: ARRAY
81618: IN
81619: NOT
81620: AND
81621: IFFALSE 81632
// ComSpaceTimeShoot ( j ) ;
81623: LD_VAR 0 3
81627: PPUSH
81628: CALL 18454 0 1
81632: GO 81574
81634: POP
81635: POP
// end ;
81636: GO 81477
81638: POP
81639: POP
// end ;
81640: LD_VAR 0 1
81644: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81645: LD_INT 0
81647: PPUSH
81648: PPUSH
81649: PPUSH
81650: PPUSH
81651: PPUSH
81652: PPUSH
81653: PPUSH
81654: PPUSH
81655: PPUSH
// if not mc_bases then
81656: LD_EXP 84
81660: NOT
81661: IFFALSE 81665
// exit ;
81663: GO 82287
// for i = 1 to mc_bases do
81665: LD_ADDR_VAR 0 2
81669: PUSH
81670: DOUBLE
81671: LD_INT 1
81673: DEC
81674: ST_TO_ADDR
81675: LD_EXP 84
81679: PUSH
81680: FOR_TO
81681: IFFALSE 82285
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81683: LD_EXP 119
81687: PUSH
81688: LD_VAR 0 2
81692: ARRAY
81693: NOT
81694: PUSH
81695: LD_INT 38
81697: PPUSH
81698: LD_EXP 110
81702: PUSH
81703: LD_VAR 0 2
81707: ARRAY
81708: PPUSH
81709: CALL_OW 321
81713: PUSH
81714: LD_INT 2
81716: NONEQUAL
81717: OR
81718: IFFALSE 81722
// continue ;
81720: GO 81680
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81722: LD_ADDR_VAR 0 8
81726: PUSH
81727: LD_EXP 84
81731: PUSH
81732: LD_VAR 0 2
81736: ARRAY
81737: PPUSH
81738: LD_INT 30
81740: PUSH
81741: LD_INT 34
81743: PUSH
81744: EMPTY
81745: LIST
81746: LIST
81747: PPUSH
81748: CALL_OW 72
81752: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81753: LD_ADDR_VAR 0 9
81757: PUSH
81758: LD_EXP 84
81762: PUSH
81763: LD_VAR 0 2
81767: ARRAY
81768: PPUSH
81769: LD_INT 25
81771: PUSH
81772: LD_INT 4
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PPUSH
81779: CALL_OW 72
81783: PPUSH
81784: LD_INT 0
81786: PPUSH
81787: CALL 51018 0 2
81791: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81792: LD_VAR 0 9
81796: NOT
81797: PUSH
81798: LD_VAR 0 8
81802: NOT
81803: OR
81804: PUSH
81805: LD_EXP 84
81809: PUSH
81810: LD_VAR 0 2
81814: ARRAY
81815: PPUSH
81816: LD_INT 124
81818: PPUSH
81819: CALL 51018 0 2
81823: OR
81824: IFFALSE 81828
// continue ;
81826: GO 81680
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81828: LD_EXP 120
81832: PUSH
81833: LD_VAR 0 2
81837: ARRAY
81838: PUSH
81839: LD_EXP 119
81843: PUSH
81844: LD_VAR 0 2
81848: ARRAY
81849: LESS
81850: PUSH
81851: LD_EXP 120
81855: PUSH
81856: LD_VAR 0 2
81860: ARRAY
81861: PUSH
81862: LD_VAR 0 8
81866: LESS
81867: AND
81868: IFFALSE 82283
// begin tmp := sci [ 1 ] ;
81870: LD_ADDR_VAR 0 7
81874: PUSH
81875: LD_VAR 0 9
81879: PUSH
81880: LD_INT 1
81882: ARRAY
81883: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81884: LD_VAR 0 7
81888: PPUSH
81889: LD_INT 124
81891: PPUSH
81892: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81896: LD_ADDR_VAR 0 3
81900: PUSH
81901: DOUBLE
81902: LD_EXP 119
81906: PUSH
81907: LD_VAR 0 2
81911: ARRAY
81912: INC
81913: ST_TO_ADDR
81914: LD_EXP 119
81918: PUSH
81919: LD_VAR 0 2
81923: ARRAY
81924: PUSH
81925: FOR_DOWNTO
81926: IFFALSE 82269
// begin if IsInUnit ( tmp ) then
81928: LD_VAR 0 7
81932: PPUSH
81933: CALL_OW 310
81937: IFFALSE 81948
// ComExitBuilding ( tmp ) ;
81939: LD_VAR 0 7
81943: PPUSH
81944: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
81948: LD_INT 35
81950: PPUSH
81951: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
81955: LD_VAR 0 7
81959: PPUSH
81960: CALL_OW 310
81964: NOT
81965: PUSH
81966: LD_VAR 0 7
81970: PPUSH
81971: CALL_OW 314
81975: NOT
81976: AND
81977: IFFALSE 81948
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
81979: LD_ADDR_VAR 0 6
81983: PUSH
81984: LD_VAR 0 7
81988: PPUSH
81989: CALL_OW 250
81993: PUSH
81994: LD_VAR 0 7
81998: PPUSH
81999: CALL_OW 251
82003: PUSH
82004: EMPTY
82005: LIST
82006: LIST
82007: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
82008: LD_INT 35
82010: PPUSH
82011: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82015: LD_ADDR_VAR 0 4
82019: PUSH
82020: LD_EXP 119
82024: PUSH
82025: LD_VAR 0 2
82029: ARRAY
82030: PUSH
82031: LD_VAR 0 3
82035: ARRAY
82036: PUSH
82037: LD_INT 1
82039: ARRAY
82040: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82041: LD_ADDR_VAR 0 5
82045: PUSH
82046: LD_EXP 119
82050: PUSH
82051: LD_VAR 0 2
82055: ARRAY
82056: PUSH
82057: LD_VAR 0 3
82061: ARRAY
82062: PUSH
82063: LD_INT 2
82065: ARRAY
82066: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82067: LD_VAR 0 7
82071: PPUSH
82072: LD_INT 10
82074: PPUSH
82075: CALL 25050 0 2
82079: PUSH
82080: LD_INT 4
82082: ARRAY
82083: IFFALSE 82121
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82085: LD_VAR 0 7
82089: PPUSH
82090: LD_VAR 0 6
82094: PUSH
82095: LD_INT 1
82097: ARRAY
82098: PPUSH
82099: LD_VAR 0 6
82103: PUSH
82104: LD_INT 2
82106: ARRAY
82107: PPUSH
82108: CALL_OW 111
// wait ( 0 0$10 ) ;
82112: LD_INT 350
82114: PPUSH
82115: CALL_OW 67
// end else
82119: GO 82147
// begin ComMoveXY ( tmp , x , y ) ;
82121: LD_VAR 0 7
82125: PPUSH
82126: LD_VAR 0 4
82130: PPUSH
82131: LD_VAR 0 5
82135: PPUSH
82136: CALL_OW 111
// wait ( 0 0$3 ) ;
82140: LD_INT 105
82142: PPUSH
82143: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82147: LD_VAR 0 7
82151: PPUSH
82152: LD_VAR 0 4
82156: PPUSH
82157: LD_VAR 0 5
82161: PPUSH
82162: CALL_OW 307
82166: IFFALSE 82008
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82168: LD_VAR 0 7
82172: PPUSH
82173: LD_VAR 0 4
82177: PPUSH
82178: LD_VAR 0 5
82182: PPUSH
82183: LD_VAR 0 8
82187: PUSH
82188: LD_VAR 0 3
82192: ARRAY
82193: PPUSH
82194: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82198: LD_INT 35
82200: PPUSH
82201: CALL_OW 67
// until not HasTask ( tmp ) ;
82205: LD_VAR 0 7
82209: PPUSH
82210: CALL_OW 314
82214: NOT
82215: IFFALSE 82198
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82217: LD_ADDR_EXP 120
82221: PUSH
82222: LD_EXP 120
82226: PPUSH
82227: LD_VAR 0 2
82231: PUSH
82232: LD_EXP 120
82236: PUSH
82237: LD_VAR 0 2
82241: ARRAY
82242: PUSH
82243: LD_INT 1
82245: PLUS
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: PPUSH
82251: LD_VAR 0 8
82255: PUSH
82256: LD_VAR 0 3
82260: ARRAY
82261: PPUSH
82262: CALL 22457 0 3
82266: ST_TO_ADDR
// end ;
82267: GO 81925
82269: POP
82270: POP
// MC_Reset ( i , 124 ) ;
82271: LD_VAR 0 2
82275: PPUSH
82276: LD_INT 124
82278: PPUSH
82279: CALL 65842 0 2
// end ; end ;
82283: GO 81680
82285: POP
82286: POP
// end ;
82287: LD_VAR 0 1
82291: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82292: LD_INT 0
82294: PPUSH
82295: PPUSH
82296: PPUSH
// if not mc_bases then
82297: LD_EXP 84
82301: NOT
82302: IFFALSE 82306
// exit ;
82304: GO 82912
// for i = 1 to mc_bases do
82306: LD_ADDR_VAR 0 2
82310: PUSH
82311: DOUBLE
82312: LD_INT 1
82314: DEC
82315: ST_TO_ADDR
82316: LD_EXP 84
82320: PUSH
82321: FOR_TO
82322: IFFALSE 82910
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82324: LD_ADDR_VAR 0 3
82328: PUSH
82329: LD_EXP 84
82333: PUSH
82334: LD_VAR 0 2
82338: ARRAY
82339: PPUSH
82340: LD_INT 25
82342: PUSH
82343: LD_INT 4
82345: PUSH
82346: EMPTY
82347: LIST
82348: LIST
82349: PPUSH
82350: CALL_OW 72
82354: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82355: LD_VAR 0 3
82359: NOT
82360: PUSH
82361: LD_EXP 121
82365: PUSH
82366: LD_VAR 0 2
82370: ARRAY
82371: NOT
82372: OR
82373: PUSH
82374: LD_EXP 84
82378: PUSH
82379: LD_VAR 0 2
82383: ARRAY
82384: PPUSH
82385: LD_INT 2
82387: PUSH
82388: LD_INT 30
82390: PUSH
82391: LD_INT 0
82393: PUSH
82394: EMPTY
82395: LIST
82396: LIST
82397: PUSH
82398: LD_INT 30
82400: PUSH
82401: LD_INT 1
82403: PUSH
82404: EMPTY
82405: LIST
82406: LIST
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: LIST
82412: PPUSH
82413: CALL_OW 72
82417: NOT
82418: OR
82419: IFFALSE 82469
// begin if mc_deposits_finder [ i ] then
82421: LD_EXP 122
82425: PUSH
82426: LD_VAR 0 2
82430: ARRAY
82431: IFFALSE 82467
// begin MC_Reset ( i , 125 ) ;
82433: LD_VAR 0 2
82437: PPUSH
82438: LD_INT 125
82440: PPUSH
82441: CALL 65842 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82445: LD_ADDR_EXP 122
82449: PUSH
82450: LD_EXP 122
82454: PPUSH
82455: LD_VAR 0 2
82459: PPUSH
82460: EMPTY
82461: PPUSH
82462: CALL_OW 1
82466: ST_TO_ADDR
// end ; continue ;
82467: GO 82321
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82469: LD_EXP 121
82473: PUSH
82474: LD_VAR 0 2
82478: ARRAY
82479: PUSH
82480: LD_INT 1
82482: ARRAY
82483: PUSH
82484: LD_INT 3
82486: ARRAY
82487: PUSH
82488: LD_INT 1
82490: EQUAL
82491: PUSH
82492: LD_INT 20
82494: PPUSH
82495: LD_EXP 110
82499: PUSH
82500: LD_VAR 0 2
82504: ARRAY
82505: PPUSH
82506: CALL_OW 321
82510: PUSH
82511: LD_INT 2
82513: NONEQUAL
82514: AND
82515: IFFALSE 82565
// begin if mc_deposits_finder [ i ] then
82517: LD_EXP 122
82521: PUSH
82522: LD_VAR 0 2
82526: ARRAY
82527: IFFALSE 82563
// begin MC_Reset ( i , 125 ) ;
82529: LD_VAR 0 2
82533: PPUSH
82534: LD_INT 125
82536: PPUSH
82537: CALL 65842 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82541: LD_ADDR_EXP 122
82545: PUSH
82546: LD_EXP 122
82550: PPUSH
82551: LD_VAR 0 2
82555: PPUSH
82556: EMPTY
82557: PPUSH
82558: CALL_OW 1
82562: ST_TO_ADDR
// end ; continue ;
82563: GO 82321
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82565: LD_EXP 121
82569: PUSH
82570: LD_VAR 0 2
82574: ARRAY
82575: PUSH
82576: LD_INT 1
82578: ARRAY
82579: PUSH
82580: LD_INT 1
82582: ARRAY
82583: PPUSH
82584: LD_EXP 121
82588: PUSH
82589: LD_VAR 0 2
82593: ARRAY
82594: PUSH
82595: LD_INT 1
82597: ARRAY
82598: PUSH
82599: LD_INT 2
82601: ARRAY
82602: PPUSH
82603: LD_EXP 110
82607: PUSH
82608: LD_VAR 0 2
82612: ARRAY
82613: PPUSH
82614: CALL_OW 440
82618: IFFALSE 82661
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82620: LD_ADDR_EXP 121
82624: PUSH
82625: LD_EXP 121
82629: PPUSH
82630: LD_VAR 0 2
82634: PPUSH
82635: LD_EXP 121
82639: PUSH
82640: LD_VAR 0 2
82644: ARRAY
82645: PPUSH
82646: LD_INT 1
82648: PPUSH
82649: CALL_OW 3
82653: PPUSH
82654: CALL_OW 1
82658: ST_TO_ADDR
82659: GO 82908
// begin if not mc_deposits_finder [ i ] then
82661: LD_EXP 122
82665: PUSH
82666: LD_VAR 0 2
82670: ARRAY
82671: NOT
82672: IFFALSE 82724
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82674: LD_ADDR_EXP 122
82678: PUSH
82679: LD_EXP 122
82683: PPUSH
82684: LD_VAR 0 2
82688: PPUSH
82689: LD_VAR 0 3
82693: PUSH
82694: LD_INT 1
82696: ARRAY
82697: PUSH
82698: EMPTY
82699: LIST
82700: PPUSH
82701: CALL_OW 1
82705: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82706: LD_VAR 0 3
82710: PUSH
82711: LD_INT 1
82713: ARRAY
82714: PPUSH
82715: LD_INT 125
82717: PPUSH
82718: CALL_OW 109
// end else
82722: GO 82908
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82724: LD_EXP 122
82728: PUSH
82729: LD_VAR 0 2
82733: ARRAY
82734: PUSH
82735: LD_INT 1
82737: ARRAY
82738: PPUSH
82739: CALL_OW 310
82743: IFFALSE 82766
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82745: LD_EXP 122
82749: PUSH
82750: LD_VAR 0 2
82754: ARRAY
82755: PUSH
82756: LD_INT 1
82758: ARRAY
82759: PPUSH
82760: CALL_OW 122
82764: GO 82908
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82766: LD_EXP 122
82770: PUSH
82771: LD_VAR 0 2
82775: ARRAY
82776: PUSH
82777: LD_INT 1
82779: ARRAY
82780: PPUSH
82781: CALL_OW 314
82785: NOT
82786: PUSH
82787: LD_EXP 122
82791: PUSH
82792: LD_VAR 0 2
82796: ARRAY
82797: PUSH
82798: LD_INT 1
82800: ARRAY
82801: PPUSH
82802: LD_EXP 121
82806: PUSH
82807: LD_VAR 0 2
82811: ARRAY
82812: PUSH
82813: LD_INT 1
82815: ARRAY
82816: PUSH
82817: LD_INT 1
82819: ARRAY
82820: PPUSH
82821: LD_EXP 121
82825: PUSH
82826: LD_VAR 0 2
82830: ARRAY
82831: PUSH
82832: LD_INT 1
82834: ARRAY
82835: PUSH
82836: LD_INT 2
82838: ARRAY
82839: PPUSH
82840: CALL_OW 297
82844: PUSH
82845: LD_INT 6
82847: GREATER
82848: AND
82849: IFFALSE 82908
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82851: LD_EXP 122
82855: PUSH
82856: LD_VAR 0 2
82860: ARRAY
82861: PUSH
82862: LD_INT 1
82864: ARRAY
82865: PPUSH
82866: LD_EXP 121
82870: PUSH
82871: LD_VAR 0 2
82875: ARRAY
82876: PUSH
82877: LD_INT 1
82879: ARRAY
82880: PUSH
82881: LD_INT 1
82883: ARRAY
82884: PPUSH
82885: LD_EXP 121
82889: PUSH
82890: LD_VAR 0 2
82894: ARRAY
82895: PUSH
82896: LD_INT 1
82898: ARRAY
82899: PUSH
82900: LD_INT 2
82902: ARRAY
82903: PPUSH
82904: CALL_OW 111
// end ; end ; end ;
82908: GO 82321
82910: POP
82911: POP
// end ;
82912: LD_VAR 0 1
82916: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
82917: LD_INT 0
82919: PPUSH
82920: PPUSH
82921: PPUSH
82922: PPUSH
82923: PPUSH
82924: PPUSH
82925: PPUSH
82926: PPUSH
82927: PPUSH
82928: PPUSH
82929: PPUSH
// if not mc_bases then
82930: LD_EXP 84
82934: NOT
82935: IFFALSE 82939
// exit ;
82937: GO 83879
// for i = 1 to mc_bases do
82939: LD_ADDR_VAR 0 2
82943: PUSH
82944: DOUBLE
82945: LD_INT 1
82947: DEC
82948: ST_TO_ADDR
82949: LD_EXP 84
82953: PUSH
82954: FOR_TO
82955: IFFALSE 83877
// begin if not mc_bases [ i ] or mc_scan [ i ] then
82957: LD_EXP 84
82961: PUSH
82962: LD_VAR 0 2
82966: ARRAY
82967: NOT
82968: PUSH
82969: LD_EXP 107
82973: PUSH
82974: LD_VAR 0 2
82978: ARRAY
82979: OR
82980: IFFALSE 82984
// continue ;
82982: GO 82954
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
82984: LD_ADDR_VAR 0 7
82988: PUSH
82989: LD_EXP 84
82993: PUSH
82994: LD_VAR 0 2
82998: ARRAY
82999: PUSH
83000: LD_INT 1
83002: ARRAY
83003: PPUSH
83004: CALL_OW 248
83008: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83009: LD_VAR 0 7
83013: PUSH
83014: LD_INT 3
83016: EQUAL
83017: PUSH
83018: LD_EXP 103
83022: PUSH
83023: LD_VAR 0 2
83027: ARRAY
83028: PUSH
83029: LD_EXP 106
83033: PUSH
83034: LD_VAR 0 2
83038: ARRAY
83039: UNION
83040: PPUSH
83041: LD_INT 33
83043: PUSH
83044: LD_INT 2
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PPUSH
83051: CALL_OW 72
83055: NOT
83056: OR
83057: IFFALSE 83061
// continue ;
83059: GO 82954
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83061: LD_ADDR_VAR 0 9
83065: PUSH
83066: LD_EXP 84
83070: PUSH
83071: LD_VAR 0 2
83075: ARRAY
83076: PPUSH
83077: LD_INT 30
83079: PUSH
83080: LD_INT 36
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PPUSH
83087: CALL_OW 72
83091: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83092: LD_ADDR_VAR 0 10
83096: PUSH
83097: LD_EXP 103
83101: PUSH
83102: LD_VAR 0 2
83106: ARRAY
83107: PPUSH
83108: LD_INT 34
83110: PUSH
83111: LD_INT 31
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: PPUSH
83118: CALL_OW 72
83122: ST_TO_ADDR
// if not cts and not mcts then
83123: LD_VAR 0 9
83127: NOT
83128: PUSH
83129: LD_VAR 0 10
83133: NOT
83134: AND
83135: IFFALSE 83139
// continue ;
83137: GO 82954
// x := cts ;
83139: LD_ADDR_VAR 0 11
83143: PUSH
83144: LD_VAR 0 9
83148: ST_TO_ADDR
// if not x then
83149: LD_VAR 0 11
83153: NOT
83154: IFFALSE 83166
// x := mcts ;
83156: LD_ADDR_VAR 0 11
83160: PUSH
83161: LD_VAR 0 10
83165: ST_TO_ADDR
// if not x then
83166: LD_VAR 0 11
83170: NOT
83171: IFFALSE 83175
// continue ;
83173: GO 82954
// if mc_remote_driver [ i ] then
83175: LD_EXP 124
83179: PUSH
83180: LD_VAR 0 2
83184: ARRAY
83185: IFFALSE 83572
// for j in mc_remote_driver [ i ] do
83187: LD_ADDR_VAR 0 3
83191: PUSH
83192: LD_EXP 124
83196: PUSH
83197: LD_VAR 0 2
83201: ARRAY
83202: PUSH
83203: FOR_IN
83204: IFFALSE 83570
// begin if GetClass ( j ) <> 3 then
83206: LD_VAR 0 3
83210: PPUSH
83211: CALL_OW 257
83215: PUSH
83216: LD_INT 3
83218: NONEQUAL
83219: IFFALSE 83272
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83221: LD_ADDR_EXP 124
83225: PUSH
83226: LD_EXP 124
83230: PPUSH
83231: LD_VAR 0 2
83235: PPUSH
83236: LD_EXP 124
83240: PUSH
83241: LD_VAR 0 2
83245: ARRAY
83246: PUSH
83247: LD_VAR 0 3
83251: DIFF
83252: PPUSH
83253: CALL_OW 1
83257: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83258: LD_VAR 0 3
83262: PPUSH
83263: LD_INT 0
83265: PPUSH
83266: CALL_OW 109
// continue ;
83270: GO 83203
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83272: LD_EXP 103
83276: PUSH
83277: LD_VAR 0 2
83281: ARRAY
83282: PPUSH
83283: LD_INT 34
83285: PUSH
83286: LD_INT 31
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 58
83295: PUSH
83296: EMPTY
83297: LIST
83298: PUSH
83299: EMPTY
83300: LIST
83301: LIST
83302: PPUSH
83303: CALL_OW 72
83307: PUSH
83308: LD_VAR 0 3
83312: PPUSH
83313: CALL 51106 0 1
83317: NOT
83318: AND
83319: IFFALSE 83390
// begin if IsInUnit ( j ) then
83321: LD_VAR 0 3
83325: PPUSH
83326: CALL_OW 310
83330: IFFALSE 83341
// ComExitBuilding ( j ) ;
83332: LD_VAR 0 3
83336: PPUSH
83337: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83341: LD_VAR 0 3
83345: PPUSH
83346: LD_EXP 103
83350: PUSH
83351: LD_VAR 0 2
83355: ARRAY
83356: PPUSH
83357: LD_INT 34
83359: PUSH
83360: LD_INT 31
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 58
83369: PUSH
83370: EMPTY
83371: LIST
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PPUSH
83377: CALL_OW 72
83381: PUSH
83382: LD_INT 1
83384: ARRAY
83385: PPUSH
83386: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83390: LD_VAR 0 3
83394: PPUSH
83395: CALL_OW 310
83399: NOT
83400: PUSH
83401: LD_VAR 0 3
83405: PPUSH
83406: CALL_OW 310
83410: PPUSH
83411: CALL_OW 266
83415: PUSH
83416: LD_INT 36
83418: NONEQUAL
83419: PUSH
83420: LD_VAR 0 3
83424: PPUSH
83425: CALL 51106 0 1
83429: NOT
83430: AND
83431: OR
83432: IFFALSE 83568
// begin if IsInUnit ( j ) then
83434: LD_VAR 0 3
83438: PPUSH
83439: CALL_OW 310
83443: IFFALSE 83454
// ComExitBuilding ( j ) ;
83445: LD_VAR 0 3
83449: PPUSH
83450: CALL_OW 122
// ct := 0 ;
83454: LD_ADDR_VAR 0 8
83458: PUSH
83459: LD_INT 0
83461: ST_TO_ADDR
// for k in x do
83462: LD_ADDR_VAR 0 4
83466: PUSH
83467: LD_VAR 0 11
83471: PUSH
83472: FOR_IN
83473: IFFALSE 83546
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83475: LD_VAR 0 4
83479: PPUSH
83480: CALL_OW 264
83484: PUSH
83485: LD_INT 31
83487: EQUAL
83488: PUSH
83489: LD_VAR 0 4
83493: PPUSH
83494: CALL_OW 311
83498: NOT
83499: AND
83500: PUSH
83501: LD_VAR 0 4
83505: PPUSH
83506: CALL_OW 266
83510: PUSH
83511: LD_INT 36
83513: EQUAL
83514: PUSH
83515: LD_VAR 0 4
83519: PPUSH
83520: CALL_OW 313
83524: PUSH
83525: LD_INT 3
83527: LESS
83528: AND
83529: OR
83530: IFFALSE 83544
// begin ct := k ;
83532: LD_ADDR_VAR 0 8
83536: PUSH
83537: LD_VAR 0 4
83541: ST_TO_ADDR
// break ;
83542: GO 83546
// end ;
83544: GO 83472
83546: POP
83547: POP
// if ct then
83548: LD_VAR 0 8
83552: IFFALSE 83568
// ComEnterUnit ( j , ct ) ;
83554: LD_VAR 0 3
83558: PPUSH
83559: LD_VAR 0 8
83563: PPUSH
83564: CALL_OW 120
// end ; end ;
83568: GO 83203
83570: POP
83571: POP
// places := 0 ;
83572: LD_ADDR_VAR 0 5
83576: PUSH
83577: LD_INT 0
83579: ST_TO_ADDR
// for j = 1 to x do
83580: LD_ADDR_VAR 0 3
83584: PUSH
83585: DOUBLE
83586: LD_INT 1
83588: DEC
83589: ST_TO_ADDR
83590: LD_VAR 0 11
83594: PUSH
83595: FOR_TO
83596: IFFALSE 83672
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83598: LD_VAR 0 11
83602: PUSH
83603: LD_VAR 0 3
83607: ARRAY
83608: PPUSH
83609: CALL_OW 264
83613: PUSH
83614: LD_INT 31
83616: EQUAL
83617: IFFALSE 83635
// places := places + 1 else
83619: LD_ADDR_VAR 0 5
83623: PUSH
83624: LD_VAR 0 5
83628: PUSH
83629: LD_INT 1
83631: PLUS
83632: ST_TO_ADDR
83633: GO 83670
// if GetBType ( x [ j ] ) = b_control_tower then
83635: LD_VAR 0 11
83639: PUSH
83640: LD_VAR 0 3
83644: ARRAY
83645: PPUSH
83646: CALL_OW 266
83650: PUSH
83651: LD_INT 36
83653: EQUAL
83654: IFFALSE 83670
// places := places + 3 ;
83656: LD_ADDR_VAR 0 5
83660: PUSH
83661: LD_VAR 0 5
83665: PUSH
83666: LD_INT 3
83668: PLUS
83669: ST_TO_ADDR
83670: GO 83595
83672: POP
83673: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83674: LD_VAR 0 5
83678: PUSH
83679: LD_INT 0
83681: EQUAL
83682: PUSH
83683: LD_VAR 0 5
83687: PUSH
83688: LD_EXP 124
83692: PUSH
83693: LD_VAR 0 2
83697: ARRAY
83698: LESSEQUAL
83699: OR
83700: IFFALSE 83704
// continue ;
83702: GO 82954
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83704: LD_ADDR_VAR 0 6
83708: PUSH
83709: LD_EXP 84
83713: PUSH
83714: LD_VAR 0 2
83718: ARRAY
83719: PPUSH
83720: LD_INT 25
83722: PUSH
83723: LD_INT 3
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: PPUSH
83730: CALL_OW 72
83734: PUSH
83735: LD_EXP 124
83739: PUSH
83740: LD_VAR 0 2
83744: ARRAY
83745: DIFF
83746: PPUSH
83747: LD_INT 3
83749: PPUSH
83750: CALL 52006 0 2
83754: ST_TO_ADDR
// for j in tmp do
83755: LD_ADDR_VAR 0 3
83759: PUSH
83760: LD_VAR 0 6
83764: PUSH
83765: FOR_IN
83766: IFFALSE 83801
// if GetTag ( j ) > 0 then
83768: LD_VAR 0 3
83772: PPUSH
83773: CALL_OW 110
83777: PUSH
83778: LD_INT 0
83780: GREATER
83781: IFFALSE 83799
// tmp := tmp diff j ;
83783: LD_ADDR_VAR 0 6
83787: PUSH
83788: LD_VAR 0 6
83792: PUSH
83793: LD_VAR 0 3
83797: DIFF
83798: ST_TO_ADDR
83799: GO 83765
83801: POP
83802: POP
// if not tmp then
83803: LD_VAR 0 6
83807: NOT
83808: IFFALSE 83812
// continue ;
83810: GO 82954
// if places then
83812: LD_VAR 0 5
83816: IFFALSE 83875
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83818: LD_ADDR_EXP 124
83822: PUSH
83823: LD_EXP 124
83827: PPUSH
83828: LD_VAR 0 2
83832: PPUSH
83833: LD_EXP 124
83837: PUSH
83838: LD_VAR 0 2
83842: ARRAY
83843: PUSH
83844: LD_VAR 0 6
83848: PUSH
83849: LD_INT 1
83851: ARRAY
83852: UNION
83853: PPUSH
83854: CALL_OW 1
83858: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83859: LD_VAR 0 6
83863: PUSH
83864: LD_INT 1
83866: ARRAY
83867: PPUSH
83868: LD_INT 126
83870: PPUSH
83871: CALL_OW 109
// end ; end ;
83875: GO 82954
83877: POP
83878: POP
// end ;
83879: LD_VAR 0 1
83883: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83884: LD_INT 0
83886: PPUSH
83887: PPUSH
83888: PPUSH
83889: PPUSH
83890: PPUSH
83891: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83892: LD_VAR 0 1
83896: NOT
83897: PUSH
83898: LD_VAR 0 2
83902: NOT
83903: OR
83904: PUSH
83905: LD_VAR 0 3
83909: NOT
83910: OR
83911: PUSH
83912: LD_VAR 0 4
83916: PUSH
83917: LD_INT 1
83919: PUSH
83920: LD_INT 2
83922: PUSH
83923: LD_INT 3
83925: PUSH
83926: LD_INT 4
83928: PUSH
83929: LD_INT 5
83931: PUSH
83932: LD_INT 8
83934: PUSH
83935: LD_INT 9
83937: PUSH
83938: LD_INT 15
83940: PUSH
83941: LD_INT 16
83943: PUSH
83944: EMPTY
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: IN
83955: NOT
83956: OR
83957: IFFALSE 83961
// exit ;
83959: GO 84861
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
83961: LD_ADDR_VAR 0 2
83965: PUSH
83966: LD_VAR 0 2
83970: PPUSH
83971: LD_INT 21
83973: PUSH
83974: LD_INT 3
83976: PUSH
83977: EMPTY
83978: LIST
83979: LIST
83980: PUSH
83981: LD_INT 24
83983: PUSH
83984: LD_INT 250
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PPUSH
83995: CALL_OW 72
83999: ST_TO_ADDR
// case class of 1 , 15 :
84000: LD_VAR 0 4
84004: PUSH
84005: LD_INT 1
84007: DOUBLE
84008: EQUAL
84009: IFTRUE 84019
84011: LD_INT 15
84013: DOUBLE
84014: EQUAL
84015: IFTRUE 84019
84017: GO 84104
84019: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84020: LD_ADDR_VAR 0 8
84024: PUSH
84025: LD_VAR 0 2
84029: PPUSH
84030: LD_INT 2
84032: PUSH
84033: LD_INT 30
84035: PUSH
84036: LD_INT 32
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 30
84045: PUSH
84046: LD_INT 31
84048: PUSH
84049: EMPTY
84050: LIST
84051: LIST
84052: PUSH
84053: EMPTY
84054: LIST
84055: LIST
84056: LIST
84057: PPUSH
84058: CALL_OW 72
84062: PUSH
84063: LD_VAR 0 2
84067: PPUSH
84068: LD_INT 2
84070: PUSH
84071: LD_INT 30
84073: PUSH
84074: LD_INT 4
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 30
84083: PUSH
84084: LD_INT 5
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: LIST
84095: PPUSH
84096: CALL_OW 72
84100: ADD
84101: ST_TO_ADDR
84102: GO 84350
84104: LD_INT 2
84106: DOUBLE
84107: EQUAL
84108: IFTRUE 84118
84110: LD_INT 16
84112: DOUBLE
84113: EQUAL
84114: IFTRUE 84118
84116: GO 84164
84118: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84119: LD_ADDR_VAR 0 8
84123: PUSH
84124: LD_VAR 0 2
84128: PPUSH
84129: LD_INT 2
84131: PUSH
84132: LD_INT 30
84134: PUSH
84135: LD_INT 0
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: PUSH
84142: LD_INT 30
84144: PUSH
84145: LD_INT 1
84147: PUSH
84148: EMPTY
84149: LIST
84150: LIST
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: LIST
84156: PPUSH
84157: CALL_OW 72
84161: ST_TO_ADDR
84162: GO 84350
84164: LD_INT 3
84166: DOUBLE
84167: EQUAL
84168: IFTRUE 84172
84170: GO 84218
84172: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84173: LD_ADDR_VAR 0 8
84177: PUSH
84178: LD_VAR 0 2
84182: PPUSH
84183: LD_INT 2
84185: PUSH
84186: LD_INT 30
84188: PUSH
84189: LD_INT 2
84191: PUSH
84192: EMPTY
84193: LIST
84194: LIST
84195: PUSH
84196: LD_INT 30
84198: PUSH
84199: LD_INT 3
84201: PUSH
84202: EMPTY
84203: LIST
84204: LIST
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: LIST
84210: PPUSH
84211: CALL_OW 72
84215: ST_TO_ADDR
84216: GO 84350
84218: LD_INT 4
84220: DOUBLE
84221: EQUAL
84222: IFTRUE 84226
84224: GO 84283
84226: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84227: LD_ADDR_VAR 0 8
84231: PUSH
84232: LD_VAR 0 2
84236: PPUSH
84237: LD_INT 2
84239: PUSH
84240: LD_INT 30
84242: PUSH
84243: LD_INT 6
84245: PUSH
84246: EMPTY
84247: LIST
84248: LIST
84249: PUSH
84250: LD_INT 30
84252: PUSH
84253: LD_INT 7
84255: PUSH
84256: EMPTY
84257: LIST
84258: LIST
84259: PUSH
84260: LD_INT 30
84262: PUSH
84263: LD_INT 8
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: PPUSH
84276: CALL_OW 72
84280: ST_TO_ADDR
84281: GO 84350
84283: LD_INT 5
84285: DOUBLE
84286: EQUAL
84287: IFTRUE 84303
84289: LD_INT 8
84291: DOUBLE
84292: EQUAL
84293: IFTRUE 84303
84295: LD_INT 9
84297: DOUBLE
84298: EQUAL
84299: IFTRUE 84303
84301: GO 84349
84303: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84304: LD_ADDR_VAR 0 8
84308: PUSH
84309: LD_VAR 0 2
84313: PPUSH
84314: LD_INT 2
84316: PUSH
84317: LD_INT 30
84319: PUSH
84320: LD_INT 4
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 30
84329: PUSH
84330: LD_INT 5
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: LIST
84341: PPUSH
84342: CALL_OW 72
84346: ST_TO_ADDR
84347: GO 84350
84349: POP
// if not tmp then
84350: LD_VAR 0 8
84354: NOT
84355: IFFALSE 84359
// exit ;
84357: GO 84861
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84359: LD_VAR 0 4
84363: PUSH
84364: LD_INT 1
84366: PUSH
84367: LD_INT 15
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: IN
84374: PUSH
84375: LD_EXP 93
84379: PUSH
84380: LD_VAR 0 1
84384: ARRAY
84385: AND
84386: IFFALSE 84542
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84388: LD_ADDR_VAR 0 9
84392: PUSH
84393: LD_EXP 93
84397: PUSH
84398: LD_VAR 0 1
84402: ARRAY
84403: PUSH
84404: LD_INT 1
84406: ARRAY
84407: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84408: LD_VAR 0 9
84412: PUSH
84413: LD_EXP 94
84417: PUSH
84418: LD_VAR 0 1
84422: ARRAY
84423: IN
84424: NOT
84425: IFFALSE 84540
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84427: LD_ADDR_EXP 94
84431: PUSH
84432: LD_EXP 94
84436: PPUSH
84437: LD_VAR 0 1
84441: PUSH
84442: LD_EXP 94
84446: PUSH
84447: LD_VAR 0 1
84451: ARRAY
84452: PUSH
84453: LD_INT 1
84455: PLUS
84456: PUSH
84457: EMPTY
84458: LIST
84459: LIST
84460: PPUSH
84461: LD_VAR 0 9
84465: PPUSH
84466: CALL 22457 0 3
84470: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84471: LD_ADDR_EXP 93
84475: PUSH
84476: LD_EXP 93
84480: PPUSH
84481: LD_VAR 0 1
84485: PPUSH
84486: LD_EXP 93
84490: PUSH
84491: LD_VAR 0 1
84495: ARRAY
84496: PUSH
84497: LD_VAR 0 9
84501: DIFF
84502: PPUSH
84503: CALL_OW 1
84507: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84508: LD_VAR 0 3
84512: PPUSH
84513: LD_EXP 94
84517: PUSH
84518: LD_VAR 0 1
84522: ARRAY
84523: PUSH
84524: LD_EXP 94
84528: PUSH
84529: LD_VAR 0 1
84533: ARRAY
84534: ARRAY
84535: PPUSH
84536: CALL_OW 120
// end ; exit ;
84540: GO 84861
// end ; if tmp > 1 then
84542: LD_VAR 0 8
84546: PUSH
84547: LD_INT 1
84549: GREATER
84550: IFFALSE 84654
// for i = 2 to tmp do
84552: LD_ADDR_VAR 0 6
84556: PUSH
84557: DOUBLE
84558: LD_INT 2
84560: DEC
84561: ST_TO_ADDR
84562: LD_VAR 0 8
84566: PUSH
84567: FOR_TO
84568: IFFALSE 84652
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84570: LD_VAR 0 8
84574: PUSH
84575: LD_VAR 0 6
84579: ARRAY
84580: PPUSH
84581: CALL_OW 461
84585: PUSH
84586: LD_INT 6
84588: EQUAL
84589: IFFALSE 84650
// begin x := tmp [ i ] ;
84591: LD_ADDR_VAR 0 9
84595: PUSH
84596: LD_VAR 0 8
84600: PUSH
84601: LD_VAR 0 6
84605: ARRAY
84606: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84607: LD_ADDR_VAR 0 8
84611: PUSH
84612: LD_VAR 0 8
84616: PPUSH
84617: LD_VAR 0 6
84621: PPUSH
84622: CALL_OW 3
84626: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84627: LD_ADDR_VAR 0 8
84631: PUSH
84632: LD_VAR 0 8
84636: PPUSH
84637: LD_INT 1
84639: PPUSH
84640: LD_VAR 0 9
84644: PPUSH
84645: CALL_OW 2
84649: ST_TO_ADDR
// end ;
84650: GO 84567
84652: POP
84653: POP
// for i in tmp do
84654: LD_ADDR_VAR 0 6
84658: PUSH
84659: LD_VAR 0 8
84663: PUSH
84664: FOR_IN
84665: IFFALSE 84734
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
84667: LD_VAR 0 6
84671: PPUSH
84672: CALL_OW 313
84676: PUSH
84677: LD_INT 6
84679: LESS
84680: PUSH
84681: LD_VAR 0 6
84685: PPUSH
84686: CALL_OW 266
84690: PUSH
84691: LD_INT 31
84693: PUSH
84694: LD_INT 32
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: IN
84701: NOT
84702: AND
84703: PUSH
84704: LD_VAR 0 6
84708: PPUSH
84709: CALL_OW 313
84713: PUSH
84714: LD_INT 0
84716: EQUAL
84717: OR
84718: IFFALSE 84732
// begin j := i ;
84720: LD_ADDR_VAR 0 7
84724: PUSH
84725: LD_VAR 0 6
84729: ST_TO_ADDR
// break ;
84730: GO 84734
// end ; end ;
84732: GO 84664
84734: POP
84735: POP
// if j then
84736: LD_VAR 0 7
84740: IFFALSE 84758
// ComEnterUnit ( unit , j ) else
84742: LD_VAR 0 3
84746: PPUSH
84747: LD_VAR 0 7
84751: PPUSH
84752: CALL_OW 120
84756: GO 84861
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84758: LD_ADDR_VAR 0 10
84762: PUSH
84763: LD_VAR 0 2
84767: PPUSH
84768: LD_INT 2
84770: PUSH
84771: LD_INT 30
84773: PUSH
84774: LD_INT 0
84776: PUSH
84777: EMPTY
84778: LIST
84779: LIST
84780: PUSH
84781: LD_INT 30
84783: PUSH
84784: LD_INT 1
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: LIST
84795: PPUSH
84796: CALL_OW 72
84800: ST_TO_ADDR
// if depot then
84801: LD_VAR 0 10
84805: IFFALSE 84861
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84807: LD_ADDR_VAR 0 10
84811: PUSH
84812: LD_VAR 0 10
84816: PPUSH
84817: LD_VAR 0 3
84821: PPUSH
84822: CALL_OW 74
84826: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84827: LD_VAR 0 3
84831: PPUSH
84832: LD_VAR 0 10
84836: PPUSH
84837: CALL_OW 296
84841: PUSH
84842: LD_INT 10
84844: GREATER
84845: IFFALSE 84861
// ComStandNearbyBuilding ( unit , depot ) ;
84847: LD_VAR 0 3
84851: PPUSH
84852: LD_VAR 0 10
84856: PPUSH
84857: CALL 19071 0 2
// end ; end ; end ;
84861: LD_VAR 0 5
84865: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84866: LD_INT 0
84868: PPUSH
84869: PPUSH
84870: PPUSH
84871: PPUSH
// if not mc_bases then
84872: LD_EXP 84
84876: NOT
84877: IFFALSE 84881
// exit ;
84879: GO 85120
// for i = 1 to mc_bases do
84881: LD_ADDR_VAR 0 2
84885: PUSH
84886: DOUBLE
84887: LD_INT 1
84889: DEC
84890: ST_TO_ADDR
84891: LD_EXP 84
84895: PUSH
84896: FOR_TO
84897: IFFALSE 85118
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84899: LD_ADDR_VAR 0 4
84903: PUSH
84904: LD_EXP 84
84908: PUSH
84909: LD_VAR 0 2
84913: ARRAY
84914: PPUSH
84915: LD_INT 21
84917: PUSH
84918: LD_INT 1
84920: PUSH
84921: EMPTY
84922: LIST
84923: LIST
84924: PPUSH
84925: CALL_OW 72
84929: PUSH
84930: LD_EXP 113
84934: PUSH
84935: LD_VAR 0 2
84939: ARRAY
84940: UNION
84941: ST_TO_ADDR
// if not tmp then
84942: LD_VAR 0 4
84946: NOT
84947: IFFALSE 84951
// continue ;
84949: GO 84896
// for j in tmp do
84951: LD_ADDR_VAR 0 3
84955: PUSH
84956: LD_VAR 0 4
84960: PUSH
84961: FOR_IN
84962: IFFALSE 85114
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
84964: LD_VAR 0 3
84968: PPUSH
84969: CALL_OW 110
84973: NOT
84974: PUSH
84975: LD_VAR 0 3
84979: PPUSH
84980: CALL_OW 314
84984: NOT
84985: AND
84986: PUSH
84987: LD_VAR 0 3
84991: PPUSH
84992: CALL_OW 311
84996: NOT
84997: AND
84998: PUSH
84999: LD_VAR 0 3
85003: PPUSH
85004: CALL_OW 310
85008: NOT
85009: AND
85010: PUSH
85011: LD_VAR 0 3
85015: PUSH
85016: LD_EXP 87
85020: PUSH
85021: LD_VAR 0 2
85025: ARRAY
85026: PUSH
85027: LD_INT 1
85029: ARRAY
85030: IN
85031: NOT
85032: AND
85033: PUSH
85034: LD_VAR 0 3
85038: PUSH
85039: LD_EXP 87
85043: PUSH
85044: LD_VAR 0 2
85048: ARRAY
85049: PUSH
85050: LD_INT 2
85052: ARRAY
85053: IN
85054: NOT
85055: AND
85056: PUSH
85057: LD_VAR 0 3
85061: PUSH
85062: LD_EXP 96
85066: PUSH
85067: LD_VAR 0 2
85071: ARRAY
85072: IN
85073: NOT
85074: AND
85075: IFFALSE 85112
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85077: LD_VAR 0 2
85081: PPUSH
85082: LD_EXP 84
85086: PUSH
85087: LD_VAR 0 2
85091: ARRAY
85092: PPUSH
85093: LD_VAR 0 3
85097: PPUSH
85098: LD_VAR 0 3
85102: PPUSH
85103: CALL_OW 257
85107: PPUSH
85108: CALL 83884 0 4
// end ;
85112: GO 84961
85114: POP
85115: POP
// end ;
85116: GO 84896
85118: POP
85119: POP
// end ;
85120: LD_VAR 0 1
85124: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
85125: LD_INT 0
85127: PPUSH
85128: PPUSH
85129: PPUSH
85130: PPUSH
85131: PPUSH
85132: PPUSH
// if not mc_bases [ base ] then
85133: LD_EXP 84
85137: PUSH
85138: LD_VAR 0 1
85142: ARRAY
85143: NOT
85144: IFFALSE 85148
// exit ;
85146: GO 85330
// tmp := [ ] ;
85148: LD_ADDR_VAR 0 6
85152: PUSH
85153: EMPTY
85154: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85155: LD_ADDR_VAR 0 7
85159: PUSH
85160: LD_VAR 0 3
85164: PPUSH
85165: LD_INT 0
85167: PPUSH
85168: CALL_OW 517
85172: ST_TO_ADDR
// if not list then
85173: LD_VAR 0 7
85177: NOT
85178: IFFALSE 85182
// exit ;
85180: GO 85330
// for i = 1 to amount do
85182: LD_ADDR_VAR 0 5
85186: PUSH
85187: DOUBLE
85188: LD_INT 1
85190: DEC
85191: ST_TO_ADDR
85192: LD_VAR 0 2
85196: PUSH
85197: FOR_TO
85198: IFFALSE 85278
// begin x := rand ( 1 , list [ 1 ] ) ;
85200: LD_ADDR_VAR 0 8
85204: PUSH
85205: LD_INT 1
85207: PPUSH
85208: LD_VAR 0 7
85212: PUSH
85213: LD_INT 1
85215: ARRAY
85216: PPUSH
85217: CALL_OW 12
85221: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
85222: LD_ADDR_VAR 0 6
85226: PUSH
85227: LD_VAR 0 6
85231: PPUSH
85232: LD_VAR 0 5
85236: PPUSH
85237: LD_VAR 0 7
85241: PUSH
85242: LD_INT 1
85244: ARRAY
85245: PUSH
85246: LD_VAR 0 8
85250: ARRAY
85251: PUSH
85252: LD_VAR 0 7
85256: PUSH
85257: LD_INT 2
85259: ARRAY
85260: PUSH
85261: LD_VAR 0 8
85265: ARRAY
85266: PUSH
85267: EMPTY
85268: LIST
85269: LIST
85270: PPUSH
85271: CALL_OW 1
85275: ST_TO_ADDR
// end ;
85276: GO 85197
85278: POP
85279: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85280: LD_ADDR_EXP 97
85284: PUSH
85285: LD_EXP 97
85289: PPUSH
85290: LD_VAR 0 1
85294: PPUSH
85295: LD_VAR 0 6
85299: PPUSH
85300: CALL_OW 1
85304: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85305: LD_ADDR_EXP 99
85309: PUSH
85310: LD_EXP 99
85314: PPUSH
85315: LD_VAR 0 1
85319: PPUSH
85320: LD_VAR 0 3
85324: PPUSH
85325: CALL_OW 1
85329: ST_TO_ADDR
// end ;
85330: LD_VAR 0 4
85334: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85335: LD_INT 0
85337: PPUSH
// if not mc_bases [ base ] then
85338: LD_EXP 84
85342: PUSH
85343: LD_VAR 0 1
85347: ARRAY
85348: NOT
85349: IFFALSE 85353
// exit ;
85351: GO 85378
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85353: LD_ADDR_EXP 89
85357: PUSH
85358: LD_EXP 89
85362: PPUSH
85363: LD_VAR 0 1
85367: PPUSH
85368: LD_VAR 0 2
85372: PPUSH
85373: CALL_OW 1
85377: ST_TO_ADDR
// end ;
85378: LD_VAR 0 3
85382: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85383: LD_INT 0
85385: PPUSH
// if not mc_bases [ base ] then
85386: LD_EXP 84
85390: PUSH
85391: LD_VAR 0 1
85395: ARRAY
85396: NOT
85397: IFFALSE 85401
// exit ;
85399: GO 85438
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85401: LD_ADDR_EXP 89
85405: PUSH
85406: LD_EXP 89
85410: PPUSH
85411: LD_VAR 0 1
85415: PPUSH
85416: LD_EXP 89
85420: PUSH
85421: LD_VAR 0 1
85425: ARRAY
85426: PUSH
85427: LD_VAR 0 2
85431: UNION
85432: PPUSH
85433: CALL_OW 1
85437: ST_TO_ADDR
// end ;
85438: LD_VAR 0 3
85442: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85443: LD_INT 0
85445: PPUSH
// if not mc_bases [ base ] then
85446: LD_EXP 84
85450: PUSH
85451: LD_VAR 0 1
85455: ARRAY
85456: NOT
85457: IFFALSE 85461
// exit ;
85459: GO 85486
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85461: LD_ADDR_EXP 105
85465: PUSH
85466: LD_EXP 105
85470: PPUSH
85471: LD_VAR 0 1
85475: PPUSH
85476: LD_VAR 0 2
85480: PPUSH
85481: CALL_OW 1
85485: ST_TO_ADDR
// end ;
85486: LD_VAR 0 3
85490: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85491: LD_INT 0
85493: PPUSH
// if not mc_bases [ base ] then
85494: LD_EXP 84
85498: PUSH
85499: LD_VAR 0 1
85503: ARRAY
85504: NOT
85505: IFFALSE 85509
// exit ;
85507: GO 85546
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85509: LD_ADDR_EXP 105
85513: PUSH
85514: LD_EXP 105
85518: PPUSH
85519: LD_VAR 0 1
85523: PPUSH
85524: LD_EXP 105
85528: PUSH
85529: LD_VAR 0 1
85533: ARRAY
85534: PUSH
85535: LD_VAR 0 2
85539: ADD
85540: PPUSH
85541: CALL_OW 1
85545: ST_TO_ADDR
// end ;
85546: LD_VAR 0 3
85550: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85551: LD_INT 0
85553: PPUSH
// if not mc_bases [ base ] then
85554: LD_EXP 84
85558: PUSH
85559: LD_VAR 0 1
85563: ARRAY
85564: NOT
85565: IFFALSE 85569
// exit ;
85567: GO 85623
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85569: LD_ADDR_EXP 106
85573: PUSH
85574: LD_EXP 106
85578: PPUSH
85579: LD_VAR 0 1
85583: PPUSH
85584: LD_VAR 0 2
85588: PPUSH
85589: CALL_OW 1
85593: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85594: LD_ADDR_EXP 95
85598: PUSH
85599: LD_EXP 95
85603: PPUSH
85604: LD_VAR 0 1
85608: PPUSH
85609: LD_VAR 0 2
85613: PUSH
85614: LD_INT 0
85616: PLUS
85617: PPUSH
85618: CALL_OW 1
85622: ST_TO_ADDR
// end ;
85623: LD_VAR 0 3
85627: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85628: LD_INT 0
85630: PPUSH
// if not mc_bases [ base ] then
85631: LD_EXP 84
85635: PUSH
85636: LD_VAR 0 1
85640: ARRAY
85641: NOT
85642: IFFALSE 85646
// exit ;
85644: GO 85671
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85646: LD_ADDR_EXP 95
85650: PUSH
85651: LD_EXP 95
85655: PPUSH
85656: LD_VAR 0 1
85660: PPUSH
85661: LD_VAR 0 2
85665: PPUSH
85666: CALL_OW 1
85670: ST_TO_ADDR
// end ;
85671: LD_VAR 0 3
85675: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85676: LD_INT 0
85678: PPUSH
85679: PPUSH
85680: PPUSH
85681: PPUSH
// if not mc_bases [ base ] then
85682: LD_EXP 84
85686: PUSH
85687: LD_VAR 0 1
85691: ARRAY
85692: NOT
85693: IFFALSE 85697
// exit ;
85695: GO 85762
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85697: LD_ADDR_EXP 104
85701: PUSH
85702: LD_EXP 104
85706: PPUSH
85707: LD_VAR 0 1
85711: PUSH
85712: LD_EXP 104
85716: PUSH
85717: LD_VAR 0 1
85721: ARRAY
85722: PUSH
85723: LD_INT 1
85725: PLUS
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PPUSH
85731: LD_VAR 0 1
85735: PUSH
85736: LD_VAR 0 2
85740: PUSH
85741: LD_VAR 0 3
85745: PUSH
85746: LD_VAR 0 4
85750: PUSH
85751: EMPTY
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: PPUSH
85757: CALL 22457 0 3
85761: ST_TO_ADDR
// end ;
85762: LD_VAR 0 5
85766: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85767: LD_INT 0
85769: PPUSH
// if not mc_bases [ base ] then
85770: LD_EXP 84
85774: PUSH
85775: LD_VAR 0 1
85779: ARRAY
85780: NOT
85781: IFFALSE 85785
// exit ;
85783: GO 85810
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85785: LD_ADDR_EXP 121
85789: PUSH
85790: LD_EXP 121
85794: PPUSH
85795: LD_VAR 0 1
85799: PPUSH
85800: LD_VAR 0 2
85804: PPUSH
85805: CALL_OW 1
85809: ST_TO_ADDR
// end ;
85810: LD_VAR 0 3
85814: RET
// export function MC_GetMinesField ( base ) ; begin
85815: LD_INT 0
85817: PPUSH
// result := mc_mines [ base ] ;
85818: LD_ADDR_VAR 0 2
85822: PUSH
85823: LD_EXP 97
85827: PUSH
85828: LD_VAR 0 1
85832: ARRAY
85833: ST_TO_ADDR
// end ;
85834: LD_VAR 0 2
85838: RET
// export function MC_GetProduceList ( base ) ; begin
85839: LD_INT 0
85841: PPUSH
// result := mc_produce [ base ] ;
85842: LD_ADDR_VAR 0 2
85846: PUSH
85847: LD_EXP 105
85851: PUSH
85852: LD_VAR 0 1
85856: ARRAY
85857: ST_TO_ADDR
// end ;
85858: LD_VAR 0 2
85862: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85863: LD_INT 0
85865: PPUSH
85866: PPUSH
// if not mc_bases then
85867: LD_EXP 84
85871: NOT
85872: IFFALSE 85876
// exit ;
85874: GO 85941
// if mc_bases [ base ] then
85876: LD_EXP 84
85880: PUSH
85881: LD_VAR 0 1
85885: ARRAY
85886: IFFALSE 85941
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85888: LD_ADDR_VAR 0 3
85892: PUSH
85893: LD_EXP 84
85897: PUSH
85898: LD_VAR 0 1
85902: ARRAY
85903: PPUSH
85904: LD_INT 30
85906: PUSH
85907: LD_VAR 0 2
85911: PUSH
85912: EMPTY
85913: LIST
85914: LIST
85915: PPUSH
85916: CALL_OW 72
85920: ST_TO_ADDR
// if result then
85921: LD_VAR 0 3
85925: IFFALSE 85941
// result := result [ 1 ] ;
85927: LD_ADDR_VAR 0 3
85931: PUSH
85932: LD_VAR 0 3
85936: PUSH
85937: LD_INT 1
85939: ARRAY
85940: ST_TO_ADDR
// end ; end ;
85941: LD_VAR 0 3
85945: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
85946: LD_INT 0
85948: PPUSH
85949: PPUSH
// if not mc_bases then
85950: LD_EXP 84
85954: NOT
85955: IFFALSE 85959
// exit ;
85957: GO 86004
// if mc_bases [ base ] then
85959: LD_EXP 84
85963: PUSH
85964: LD_VAR 0 1
85968: ARRAY
85969: IFFALSE 86004
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85971: LD_ADDR_VAR 0 3
85975: PUSH
85976: LD_EXP 84
85980: PUSH
85981: LD_VAR 0 1
85985: ARRAY
85986: PPUSH
85987: LD_INT 30
85989: PUSH
85990: LD_VAR 0 2
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: PPUSH
85999: CALL_OW 72
86003: ST_TO_ADDR
// end ;
86004: LD_VAR 0 3
86008: RET
// export function MC_SetTame ( base , area ) ; begin
86009: LD_INT 0
86011: PPUSH
// if not mc_bases or not base then
86012: LD_EXP 84
86016: NOT
86017: PUSH
86018: LD_VAR 0 1
86022: NOT
86023: OR
86024: IFFALSE 86028
// exit ;
86026: GO 86053
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86028: LD_ADDR_EXP 112
86032: PUSH
86033: LD_EXP 112
86037: PPUSH
86038: LD_VAR 0 1
86042: PPUSH
86043: LD_VAR 0 2
86047: PPUSH
86048: CALL_OW 1
86052: ST_TO_ADDR
// end ;
86053: LD_VAR 0 3
86057: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86058: LD_INT 0
86060: PPUSH
86061: PPUSH
// if not mc_bases or not base then
86062: LD_EXP 84
86066: NOT
86067: PUSH
86068: LD_VAR 0 1
86072: NOT
86073: OR
86074: IFFALSE 86078
// exit ;
86076: GO 86180
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86078: LD_ADDR_VAR 0 4
86082: PUSH
86083: LD_EXP 84
86087: PUSH
86088: LD_VAR 0 1
86092: ARRAY
86093: PPUSH
86094: LD_INT 30
86096: PUSH
86097: LD_VAR 0 2
86101: PUSH
86102: EMPTY
86103: LIST
86104: LIST
86105: PPUSH
86106: CALL_OW 72
86110: ST_TO_ADDR
// if not tmp then
86111: LD_VAR 0 4
86115: NOT
86116: IFFALSE 86120
// exit ;
86118: GO 86180
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86120: LD_ADDR_EXP 116
86124: PUSH
86125: LD_EXP 116
86129: PPUSH
86130: LD_VAR 0 1
86134: PPUSH
86135: LD_EXP 116
86139: PUSH
86140: LD_VAR 0 1
86144: ARRAY
86145: PPUSH
86146: LD_EXP 116
86150: PUSH
86151: LD_VAR 0 1
86155: ARRAY
86156: PUSH
86157: LD_INT 1
86159: PLUS
86160: PPUSH
86161: LD_VAR 0 4
86165: PUSH
86166: LD_INT 1
86168: ARRAY
86169: PPUSH
86170: CALL_OW 2
86174: PPUSH
86175: CALL_OW 1
86179: ST_TO_ADDR
// end ;
86180: LD_VAR 0 3
86184: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86185: LD_INT 0
86187: PPUSH
86188: PPUSH
// if not mc_bases or not base or not kinds then
86189: LD_EXP 84
86193: NOT
86194: PUSH
86195: LD_VAR 0 1
86199: NOT
86200: OR
86201: PUSH
86202: LD_VAR 0 2
86206: NOT
86207: OR
86208: IFFALSE 86212
// exit ;
86210: GO 86273
// for i in kinds do
86212: LD_ADDR_VAR 0 4
86216: PUSH
86217: LD_VAR 0 2
86221: PUSH
86222: FOR_IN
86223: IFFALSE 86271
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86225: LD_ADDR_EXP 118
86229: PUSH
86230: LD_EXP 118
86234: PPUSH
86235: LD_VAR 0 1
86239: PUSH
86240: LD_EXP 118
86244: PUSH
86245: LD_VAR 0 1
86249: ARRAY
86250: PUSH
86251: LD_INT 1
86253: PLUS
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: PPUSH
86259: LD_VAR 0 4
86263: PPUSH
86264: CALL 22457 0 3
86268: ST_TO_ADDR
86269: GO 86222
86271: POP
86272: POP
// end ;
86273: LD_VAR 0 3
86277: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86278: LD_INT 0
86280: PPUSH
// if not mc_bases or not base or not areas then
86281: LD_EXP 84
86285: NOT
86286: PUSH
86287: LD_VAR 0 1
86291: NOT
86292: OR
86293: PUSH
86294: LD_VAR 0 2
86298: NOT
86299: OR
86300: IFFALSE 86304
// exit ;
86302: GO 86329
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86304: LD_ADDR_EXP 102
86308: PUSH
86309: LD_EXP 102
86313: PPUSH
86314: LD_VAR 0 1
86318: PPUSH
86319: LD_VAR 0 2
86323: PPUSH
86324: CALL_OW 1
86328: ST_TO_ADDR
// end ;
86329: LD_VAR 0 3
86333: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86334: LD_INT 0
86336: PPUSH
// if not mc_bases or not base or not teleports_exit then
86337: LD_EXP 84
86341: NOT
86342: PUSH
86343: LD_VAR 0 1
86347: NOT
86348: OR
86349: PUSH
86350: LD_VAR 0 2
86354: NOT
86355: OR
86356: IFFALSE 86360
// exit ;
86358: GO 86385
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86360: LD_ADDR_EXP 119
86364: PUSH
86365: LD_EXP 119
86369: PPUSH
86370: LD_VAR 0 1
86374: PPUSH
86375: LD_VAR 0 2
86379: PPUSH
86380: CALL_OW 1
86384: ST_TO_ADDR
// end ;
86385: LD_VAR 0 3
86389: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86390: LD_INT 0
86392: PPUSH
86393: PPUSH
86394: PPUSH
// if not mc_bases or not base or not ext_list then
86395: LD_EXP 84
86399: NOT
86400: PUSH
86401: LD_VAR 0 1
86405: NOT
86406: OR
86407: PUSH
86408: LD_VAR 0 5
86412: NOT
86413: OR
86414: IFFALSE 86418
// exit ;
86416: GO 86591
// tmp := GetFacExtXYD ( x , y , d ) ;
86418: LD_ADDR_VAR 0 8
86422: PUSH
86423: LD_VAR 0 2
86427: PPUSH
86428: LD_VAR 0 3
86432: PPUSH
86433: LD_VAR 0 4
86437: PPUSH
86438: CALL 51136 0 3
86442: ST_TO_ADDR
// if not tmp then
86443: LD_VAR 0 8
86447: NOT
86448: IFFALSE 86452
// exit ;
86450: GO 86591
// for i in tmp do
86452: LD_ADDR_VAR 0 7
86456: PUSH
86457: LD_VAR 0 8
86461: PUSH
86462: FOR_IN
86463: IFFALSE 86589
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86465: LD_ADDR_EXP 89
86469: PUSH
86470: LD_EXP 89
86474: PPUSH
86475: LD_VAR 0 1
86479: PPUSH
86480: LD_EXP 89
86484: PUSH
86485: LD_VAR 0 1
86489: ARRAY
86490: PPUSH
86491: LD_EXP 89
86495: PUSH
86496: LD_VAR 0 1
86500: ARRAY
86501: PUSH
86502: LD_INT 1
86504: PLUS
86505: PPUSH
86506: LD_VAR 0 5
86510: PUSH
86511: LD_INT 1
86513: ARRAY
86514: PUSH
86515: LD_VAR 0 7
86519: PUSH
86520: LD_INT 1
86522: ARRAY
86523: PUSH
86524: LD_VAR 0 7
86528: PUSH
86529: LD_INT 2
86531: ARRAY
86532: PUSH
86533: LD_VAR 0 7
86537: PUSH
86538: LD_INT 3
86540: ARRAY
86541: PUSH
86542: EMPTY
86543: LIST
86544: LIST
86545: LIST
86546: LIST
86547: PPUSH
86548: CALL_OW 2
86552: PPUSH
86553: CALL_OW 1
86557: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86558: LD_ADDR_VAR 0 5
86562: PUSH
86563: LD_VAR 0 5
86567: PPUSH
86568: LD_INT 1
86570: PPUSH
86571: CALL_OW 3
86575: ST_TO_ADDR
// if not ext_list then
86576: LD_VAR 0 5
86580: NOT
86581: IFFALSE 86587
// exit ;
86583: POP
86584: POP
86585: GO 86591
// end ;
86587: GO 86462
86589: POP
86590: POP
// end ;
86591: LD_VAR 0 6
86595: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86596: LD_INT 0
86598: PPUSH
// if not mc_bases or not base or not weapon_list then
86599: LD_EXP 84
86603: NOT
86604: PUSH
86605: LD_VAR 0 1
86609: NOT
86610: OR
86611: PUSH
86612: LD_VAR 0 2
86616: NOT
86617: OR
86618: IFFALSE 86622
// exit ;
86620: GO 86647
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86622: LD_ADDR_EXP 123
86626: PUSH
86627: LD_EXP 123
86631: PPUSH
86632: LD_VAR 0 1
86636: PPUSH
86637: LD_VAR 0 2
86641: PPUSH
86642: CALL_OW 1
86646: ST_TO_ADDR
// end ;
86647: LD_VAR 0 3
86651: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86652: LD_INT 0
86654: PPUSH
// if not mc_bases or not base or not tech_list then
86655: LD_EXP 84
86659: NOT
86660: PUSH
86661: LD_VAR 0 1
86665: NOT
86666: OR
86667: PUSH
86668: LD_VAR 0 2
86672: NOT
86673: OR
86674: IFFALSE 86678
// exit ;
86676: GO 86703
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86678: LD_ADDR_EXP 111
86682: PUSH
86683: LD_EXP 111
86687: PPUSH
86688: LD_VAR 0 1
86692: PPUSH
86693: LD_VAR 0 2
86697: PPUSH
86698: CALL_OW 1
86702: ST_TO_ADDR
// end ;
86703: LD_VAR 0 3
86707: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86708: LD_INT 0
86710: PPUSH
// if not mc_bases or not parking_area or not base then
86711: LD_EXP 84
86715: NOT
86716: PUSH
86717: LD_VAR 0 2
86721: NOT
86722: OR
86723: PUSH
86724: LD_VAR 0 1
86728: NOT
86729: OR
86730: IFFALSE 86734
// exit ;
86732: GO 86759
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86734: LD_ADDR_EXP 108
86738: PUSH
86739: LD_EXP 108
86743: PPUSH
86744: LD_VAR 0 1
86748: PPUSH
86749: LD_VAR 0 2
86753: PPUSH
86754: CALL_OW 1
86758: ST_TO_ADDR
// end ;
86759: LD_VAR 0 3
86763: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86764: LD_INT 0
86766: PPUSH
// if not mc_bases or not base or not scan_area then
86767: LD_EXP 84
86771: NOT
86772: PUSH
86773: LD_VAR 0 1
86777: NOT
86778: OR
86779: PUSH
86780: LD_VAR 0 2
86784: NOT
86785: OR
86786: IFFALSE 86790
// exit ;
86788: GO 86815
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86790: LD_ADDR_EXP 109
86794: PUSH
86795: LD_EXP 109
86799: PPUSH
86800: LD_VAR 0 1
86804: PPUSH
86805: LD_VAR 0 2
86809: PPUSH
86810: CALL_OW 1
86814: ST_TO_ADDR
// end ;
86815: LD_VAR 0 3
86819: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86820: LD_INT 0
86822: PPUSH
86823: PPUSH
// if not mc_bases or not base then
86824: LD_EXP 84
86828: NOT
86829: PUSH
86830: LD_VAR 0 1
86834: NOT
86835: OR
86836: IFFALSE 86840
// exit ;
86838: GO 86904
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86840: LD_ADDR_VAR 0 3
86844: PUSH
86845: LD_INT 1
86847: PUSH
86848: LD_INT 2
86850: PUSH
86851: LD_INT 3
86853: PUSH
86854: LD_INT 4
86856: PUSH
86857: LD_INT 11
86859: PUSH
86860: EMPTY
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86867: LD_ADDR_EXP 111
86871: PUSH
86872: LD_EXP 111
86876: PPUSH
86877: LD_VAR 0 1
86881: PPUSH
86882: LD_EXP 111
86886: PUSH
86887: LD_VAR 0 1
86891: ARRAY
86892: PUSH
86893: LD_VAR 0 3
86897: DIFF
86898: PPUSH
86899: CALL_OW 1
86903: ST_TO_ADDR
// end ;
86904: LD_VAR 0 2
86908: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86909: LD_INT 0
86911: PPUSH
// result := mc_vehicles [ base ] ;
86912: LD_ADDR_VAR 0 3
86916: PUSH
86917: LD_EXP 103
86921: PUSH
86922: LD_VAR 0 1
86926: ARRAY
86927: ST_TO_ADDR
// if onlyCombat then
86928: LD_VAR 0 2
86932: IFFALSE 87110
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
86934: LD_ADDR_VAR 0 3
86938: PUSH
86939: LD_VAR 0 3
86943: PUSH
86944: LD_VAR 0 3
86948: PPUSH
86949: LD_INT 2
86951: PUSH
86952: LD_INT 34
86954: PUSH
86955: LD_INT 12
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: PUSH
86962: LD_INT 34
86964: PUSH
86965: LD_INT 51
86967: PUSH
86968: EMPTY
86969: LIST
86970: LIST
86971: PUSH
86972: LD_INT 34
86974: PUSH
86975: LD_EXP 2
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 34
86986: PUSH
86987: LD_INT 32
86989: PUSH
86990: EMPTY
86991: LIST
86992: LIST
86993: PUSH
86994: LD_INT 34
86996: PUSH
86997: LD_INT 13
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PUSH
87004: LD_INT 34
87006: PUSH
87007: LD_INT 52
87009: PUSH
87010: EMPTY
87011: LIST
87012: LIST
87013: PUSH
87014: LD_INT 34
87016: PUSH
87017: LD_EXP 7
87021: PUSH
87022: EMPTY
87023: LIST
87024: LIST
87025: PUSH
87026: LD_INT 34
87028: PUSH
87029: LD_INT 14
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: PUSH
87036: LD_INT 34
87038: PUSH
87039: LD_INT 53
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 34
87048: PUSH
87049: LD_EXP 1
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: LD_INT 34
87060: PUSH
87061: LD_INT 31
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: PUSH
87068: LD_INT 34
87070: PUSH
87071: LD_INT 48
87073: PUSH
87074: EMPTY
87075: LIST
87076: LIST
87077: PUSH
87078: LD_INT 34
87080: PUSH
87081: LD_INT 8
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: LIST
87095: LIST
87096: LIST
87097: LIST
87098: LIST
87099: LIST
87100: LIST
87101: LIST
87102: LIST
87103: PPUSH
87104: CALL_OW 72
87108: DIFF
87109: ST_TO_ADDR
// end ; end_of_file
87110: LD_VAR 0 3
87114: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87115: LD_INT 0
87117: PPUSH
87118: PPUSH
87119: PPUSH
// if not mc_bases or not skirmish then
87120: LD_EXP 84
87124: NOT
87125: PUSH
87126: LD_EXP 82
87130: NOT
87131: OR
87132: IFFALSE 87136
// exit ;
87134: GO 87301
// for i = 1 to mc_bases do
87136: LD_ADDR_VAR 0 4
87140: PUSH
87141: DOUBLE
87142: LD_INT 1
87144: DEC
87145: ST_TO_ADDR
87146: LD_EXP 84
87150: PUSH
87151: FOR_TO
87152: IFFALSE 87299
// begin if sci in mc_bases [ i ] then
87154: LD_VAR 0 2
87158: PUSH
87159: LD_EXP 84
87163: PUSH
87164: LD_VAR 0 4
87168: ARRAY
87169: IN
87170: IFFALSE 87297
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87172: LD_ADDR_EXP 113
87176: PUSH
87177: LD_EXP 113
87181: PPUSH
87182: LD_VAR 0 4
87186: PUSH
87187: LD_EXP 113
87191: PUSH
87192: LD_VAR 0 4
87196: ARRAY
87197: PUSH
87198: LD_INT 1
87200: PLUS
87201: PUSH
87202: EMPTY
87203: LIST
87204: LIST
87205: PPUSH
87206: LD_VAR 0 1
87210: PPUSH
87211: CALL 22457 0 3
87215: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87216: LD_ADDR_VAR 0 5
87220: PUSH
87221: LD_EXP 84
87225: PUSH
87226: LD_VAR 0 4
87230: ARRAY
87231: PPUSH
87232: LD_INT 2
87234: PUSH
87235: LD_INT 30
87237: PUSH
87238: LD_INT 0
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 30
87247: PUSH
87248: LD_INT 1
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: EMPTY
87256: LIST
87257: LIST
87258: LIST
87259: PPUSH
87260: CALL_OW 72
87264: PPUSH
87265: LD_VAR 0 1
87269: PPUSH
87270: CALL_OW 74
87274: ST_TO_ADDR
// if tmp then
87275: LD_VAR 0 5
87279: IFFALSE 87295
// ComStandNearbyBuilding ( ape , tmp ) ;
87281: LD_VAR 0 1
87285: PPUSH
87286: LD_VAR 0 5
87290: PPUSH
87291: CALL 19071 0 2
// break ;
87295: GO 87299
// end ; end ;
87297: GO 87151
87299: POP
87300: POP
// end ;
87301: LD_VAR 0 3
87305: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87306: LD_INT 0
87308: PPUSH
87309: PPUSH
87310: PPUSH
// if not mc_bases or not skirmish then
87311: LD_EXP 84
87315: NOT
87316: PUSH
87317: LD_EXP 82
87321: NOT
87322: OR
87323: IFFALSE 87327
// exit ;
87325: GO 87416
// for i = 1 to mc_bases do
87327: LD_ADDR_VAR 0 4
87331: PUSH
87332: DOUBLE
87333: LD_INT 1
87335: DEC
87336: ST_TO_ADDR
87337: LD_EXP 84
87341: PUSH
87342: FOR_TO
87343: IFFALSE 87414
// begin if building in mc_busy_turret_list [ i ] then
87345: LD_VAR 0 1
87349: PUSH
87350: LD_EXP 94
87354: PUSH
87355: LD_VAR 0 4
87359: ARRAY
87360: IN
87361: IFFALSE 87412
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87363: LD_ADDR_VAR 0 5
87367: PUSH
87368: LD_EXP 94
87372: PUSH
87373: LD_VAR 0 4
87377: ARRAY
87378: PUSH
87379: LD_VAR 0 1
87383: DIFF
87384: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87385: LD_ADDR_EXP 94
87389: PUSH
87390: LD_EXP 94
87394: PPUSH
87395: LD_VAR 0 4
87399: PPUSH
87400: LD_VAR 0 5
87404: PPUSH
87405: CALL_OW 1
87409: ST_TO_ADDR
// break ;
87410: GO 87414
// end ; end ;
87412: GO 87342
87414: POP
87415: POP
// end ;
87416: LD_VAR 0 3
87420: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87421: LD_INT 0
87423: PPUSH
87424: PPUSH
87425: PPUSH
// if not mc_bases or not skirmish then
87426: LD_EXP 84
87430: NOT
87431: PUSH
87432: LD_EXP 82
87436: NOT
87437: OR
87438: IFFALSE 87442
// exit ;
87440: GO 87641
// for i = 1 to mc_bases do
87442: LD_ADDR_VAR 0 5
87446: PUSH
87447: DOUBLE
87448: LD_INT 1
87450: DEC
87451: ST_TO_ADDR
87452: LD_EXP 84
87456: PUSH
87457: FOR_TO
87458: IFFALSE 87639
// if building in mc_bases [ i ] then
87460: LD_VAR 0 1
87464: PUSH
87465: LD_EXP 84
87469: PUSH
87470: LD_VAR 0 5
87474: ARRAY
87475: IN
87476: IFFALSE 87637
// begin tmp := mc_bases [ i ] diff building ;
87478: LD_ADDR_VAR 0 6
87482: PUSH
87483: LD_EXP 84
87487: PUSH
87488: LD_VAR 0 5
87492: ARRAY
87493: PUSH
87494: LD_VAR 0 1
87498: DIFF
87499: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87500: LD_ADDR_EXP 84
87504: PUSH
87505: LD_EXP 84
87509: PPUSH
87510: LD_VAR 0 5
87514: PPUSH
87515: LD_VAR 0 6
87519: PPUSH
87520: CALL_OW 1
87524: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87525: LD_VAR 0 1
87529: PUSH
87530: LD_EXP 92
87534: PUSH
87535: LD_VAR 0 5
87539: ARRAY
87540: IN
87541: IFFALSE 87580
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87543: LD_ADDR_EXP 92
87547: PUSH
87548: LD_EXP 92
87552: PPUSH
87553: LD_VAR 0 5
87557: PPUSH
87558: LD_EXP 92
87562: PUSH
87563: LD_VAR 0 5
87567: ARRAY
87568: PUSH
87569: LD_VAR 0 1
87573: DIFF
87574: PPUSH
87575: CALL_OW 1
87579: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87580: LD_VAR 0 1
87584: PUSH
87585: LD_EXP 93
87589: PUSH
87590: LD_VAR 0 5
87594: ARRAY
87595: IN
87596: IFFALSE 87635
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87598: LD_ADDR_EXP 93
87602: PUSH
87603: LD_EXP 93
87607: PPUSH
87608: LD_VAR 0 5
87612: PPUSH
87613: LD_EXP 93
87617: PUSH
87618: LD_VAR 0 5
87622: ARRAY
87623: PUSH
87624: LD_VAR 0 1
87628: DIFF
87629: PPUSH
87630: CALL_OW 1
87634: ST_TO_ADDR
// break ;
87635: GO 87639
// end ;
87637: GO 87457
87639: POP
87640: POP
// end ;
87641: LD_VAR 0 4
87645: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87646: LD_INT 0
87648: PPUSH
87649: PPUSH
87650: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87651: LD_EXP 84
87655: NOT
87656: PUSH
87657: LD_EXP 82
87661: NOT
87662: OR
87663: PUSH
87664: LD_VAR 0 3
87668: PUSH
87669: LD_EXP 110
87673: IN
87674: NOT
87675: OR
87676: IFFALSE 87680
// exit ;
87678: GO 87803
// for i = 1 to mc_vehicles do
87680: LD_ADDR_VAR 0 6
87684: PUSH
87685: DOUBLE
87686: LD_INT 1
87688: DEC
87689: ST_TO_ADDR
87690: LD_EXP 103
87694: PUSH
87695: FOR_TO
87696: IFFALSE 87801
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87698: LD_VAR 0 2
87702: PUSH
87703: LD_EXP 103
87707: PUSH
87708: LD_VAR 0 6
87712: ARRAY
87713: IN
87714: PUSH
87715: LD_VAR 0 1
87719: PUSH
87720: LD_EXP 103
87724: PUSH
87725: LD_VAR 0 6
87729: ARRAY
87730: IN
87731: OR
87732: IFFALSE 87799
// begin tmp := mc_vehicles [ i ] diff old ;
87734: LD_ADDR_VAR 0 7
87738: PUSH
87739: LD_EXP 103
87743: PUSH
87744: LD_VAR 0 6
87748: ARRAY
87749: PUSH
87750: LD_VAR 0 2
87754: DIFF
87755: ST_TO_ADDR
// tmp := tmp diff new ;
87756: LD_ADDR_VAR 0 7
87760: PUSH
87761: LD_VAR 0 7
87765: PUSH
87766: LD_VAR 0 1
87770: DIFF
87771: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87772: LD_ADDR_EXP 103
87776: PUSH
87777: LD_EXP 103
87781: PPUSH
87782: LD_VAR 0 6
87786: PPUSH
87787: LD_VAR 0 7
87791: PPUSH
87792: CALL_OW 1
87796: ST_TO_ADDR
// break ;
87797: GO 87801
// end ;
87799: GO 87695
87801: POP
87802: POP
// end ;
87803: LD_VAR 0 5
87807: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87808: LD_INT 0
87810: PPUSH
87811: PPUSH
87812: PPUSH
87813: PPUSH
// if not mc_bases or not skirmish then
87814: LD_EXP 84
87818: NOT
87819: PUSH
87820: LD_EXP 82
87824: NOT
87825: OR
87826: IFFALSE 87830
// exit ;
87828: GO 88213
// side := GetSide ( vehicle ) ;
87830: LD_ADDR_VAR 0 5
87834: PUSH
87835: LD_VAR 0 1
87839: PPUSH
87840: CALL_OW 255
87844: ST_TO_ADDR
// for i = 1 to mc_bases do
87845: LD_ADDR_VAR 0 4
87849: PUSH
87850: DOUBLE
87851: LD_INT 1
87853: DEC
87854: ST_TO_ADDR
87855: LD_EXP 84
87859: PUSH
87860: FOR_TO
87861: IFFALSE 88211
// begin if factory in mc_bases [ i ] then
87863: LD_VAR 0 2
87867: PUSH
87868: LD_EXP 84
87872: PUSH
87873: LD_VAR 0 4
87877: ARRAY
87878: IN
87879: IFFALSE 88209
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87881: LD_EXP 106
87885: PUSH
87886: LD_VAR 0 4
87890: ARRAY
87891: PUSH
87892: LD_EXP 95
87896: PUSH
87897: LD_VAR 0 4
87901: ARRAY
87902: LESS
87903: PUSH
87904: LD_VAR 0 1
87908: PPUSH
87909: CALL_OW 264
87913: PUSH
87914: LD_INT 31
87916: PUSH
87917: LD_INT 32
87919: PUSH
87920: LD_INT 51
87922: PUSH
87923: LD_EXP 2
87927: PUSH
87928: LD_INT 12
87930: PUSH
87931: LD_INT 30
87933: PUSH
87934: LD_EXP 1
87938: PUSH
87939: LD_INT 11
87941: PUSH
87942: LD_INT 53
87944: PUSH
87945: LD_INT 14
87947: PUSH
87948: LD_EXP 5
87952: PUSH
87953: LD_INT 29
87955: PUSH
87956: LD_EXP 3
87960: PUSH
87961: LD_INT 13
87963: PUSH
87964: LD_INT 52
87966: PUSH
87967: LD_EXP 7
87971: PUSH
87972: LD_INT 48
87974: PUSH
87975: LD_INT 8
87977: PUSH
87978: EMPTY
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: IN
87998: NOT
87999: AND
88000: IFFALSE 88048
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88002: LD_ADDR_EXP 106
88006: PUSH
88007: LD_EXP 106
88011: PPUSH
88012: LD_VAR 0 4
88016: PUSH
88017: LD_EXP 106
88021: PUSH
88022: LD_VAR 0 4
88026: ARRAY
88027: PUSH
88028: LD_INT 1
88030: PLUS
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: PPUSH
88036: LD_VAR 0 1
88040: PPUSH
88041: CALL 22457 0 3
88045: ST_TO_ADDR
88046: GO 88092
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88048: LD_ADDR_EXP 103
88052: PUSH
88053: LD_EXP 103
88057: PPUSH
88058: LD_VAR 0 4
88062: PUSH
88063: LD_EXP 103
88067: PUSH
88068: LD_VAR 0 4
88072: ARRAY
88073: PUSH
88074: LD_INT 1
88076: PLUS
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: PPUSH
88082: LD_VAR 0 1
88086: PPUSH
88087: CALL 22457 0 3
88091: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88092: LD_VAR 0 1
88096: PPUSH
88097: CALL_OW 263
88101: PUSH
88102: LD_INT 2
88104: EQUAL
88105: IFFALSE 88125
// begin repeat wait ( 0 0$1 ) ;
88107: LD_INT 35
88109: PPUSH
88110: CALL_OW 67
// until IsControledBy ( vehicle ) ;
88114: LD_VAR 0 1
88118: PPUSH
88119: CALL_OW 312
88123: IFFALSE 88107
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88125: LD_VAR 0 1
88129: PPUSH
88130: LD_EXP 108
88134: PUSH
88135: LD_VAR 0 4
88139: ARRAY
88140: PPUSH
88141: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88145: LD_VAR 0 1
88149: PPUSH
88150: CALL_OW 263
88154: PUSH
88155: LD_INT 1
88157: NONEQUAL
88158: IFFALSE 88162
// break ;
88160: GO 88211
// repeat wait ( 0 0$1 ) ;
88162: LD_INT 35
88164: PPUSH
88165: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88169: LD_VAR 0 1
88173: PPUSH
88174: LD_EXP 108
88178: PUSH
88179: LD_VAR 0 4
88183: ARRAY
88184: PPUSH
88185: CALL_OW 308
88189: IFFALSE 88162
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88191: LD_VAR 0 1
88195: PPUSH
88196: CALL_OW 311
88200: PPUSH
88201: CALL_OW 121
// exit ;
88205: POP
88206: POP
88207: GO 88213
// end ; end ;
88209: GO 87860
88211: POP
88212: POP
// end ;
88213: LD_VAR 0 3
88217: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88218: LD_INT 0
88220: PPUSH
88221: PPUSH
88222: PPUSH
88223: PPUSH
// if not mc_bases or not skirmish then
88224: LD_EXP 84
88228: NOT
88229: PUSH
88230: LD_EXP 82
88234: NOT
88235: OR
88236: IFFALSE 88240
// exit ;
88238: GO 88593
// repeat wait ( 0 0$1 ) ;
88240: LD_INT 35
88242: PPUSH
88243: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88247: LD_VAR 0 2
88251: PPUSH
88252: LD_VAR 0 3
88256: PPUSH
88257: CALL_OW 284
88261: IFFALSE 88240
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88263: LD_VAR 0 2
88267: PPUSH
88268: LD_VAR 0 3
88272: PPUSH
88273: CALL_OW 283
88277: PUSH
88278: LD_INT 4
88280: EQUAL
88281: IFFALSE 88285
// exit ;
88283: GO 88593
// for i = 1 to mc_bases do
88285: LD_ADDR_VAR 0 7
88289: PUSH
88290: DOUBLE
88291: LD_INT 1
88293: DEC
88294: ST_TO_ADDR
88295: LD_EXP 84
88299: PUSH
88300: FOR_TO
88301: IFFALSE 88591
// begin if mc_crates_area [ i ] then
88303: LD_EXP 102
88307: PUSH
88308: LD_VAR 0 7
88312: ARRAY
88313: IFFALSE 88424
// for j in mc_crates_area [ i ] do
88315: LD_ADDR_VAR 0 8
88319: PUSH
88320: LD_EXP 102
88324: PUSH
88325: LD_VAR 0 7
88329: ARRAY
88330: PUSH
88331: FOR_IN
88332: IFFALSE 88422
// if InArea ( x , y , j ) then
88334: LD_VAR 0 2
88338: PPUSH
88339: LD_VAR 0 3
88343: PPUSH
88344: LD_VAR 0 8
88348: PPUSH
88349: CALL_OW 309
88353: IFFALSE 88420
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88355: LD_ADDR_EXP 100
88359: PUSH
88360: LD_EXP 100
88364: PPUSH
88365: LD_VAR 0 7
88369: PUSH
88370: LD_EXP 100
88374: PUSH
88375: LD_VAR 0 7
88379: ARRAY
88380: PUSH
88381: LD_INT 1
88383: PLUS
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PPUSH
88389: LD_VAR 0 4
88393: PUSH
88394: LD_VAR 0 2
88398: PUSH
88399: LD_VAR 0 3
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: LIST
88408: PPUSH
88409: CALL 22457 0 3
88413: ST_TO_ADDR
// exit ;
88414: POP
88415: POP
88416: POP
88417: POP
88418: GO 88593
// end ;
88420: GO 88331
88422: POP
88423: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88424: LD_ADDR_VAR 0 9
88428: PUSH
88429: LD_EXP 84
88433: PUSH
88434: LD_VAR 0 7
88438: ARRAY
88439: PPUSH
88440: LD_INT 2
88442: PUSH
88443: LD_INT 30
88445: PUSH
88446: LD_INT 0
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 30
88455: PUSH
88456: LD_INT 1
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: LIST
88467: PPUSH
88468: CALL_OW 72
88472: ST_TO_ADDR
// if not depot then
88473: LD_VAR 0 9
88477: NOT
88478: IFFALSE 88482
// continue ;
88480: GO 88300
// for j in depot do
88482: LD_ADDR_VAR 0 8
88486: PUSH
88487: LD_VAR 0 9
88491: PUSH
88492: FOR_IN
88493: IFFALSE 88587
// if GetDistUnitXY ( j , x , y ) < 30 then
88495: LD_VAR 0 8
88499: PPUSH
88500: LD_VAR 0 2
88504: PPUSH
88505: LD_VAR 0 3
88509: PPUSH
88510: CALL_OW 297
88514: PUSH
88515: LD_INT 30
88517: LESS
88518: IFFALSE 88585
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88520: LD_ADDR_EXP 100
88524: PUSH
88525: LD_EXP 100
88529: PPUSH
88530: LD_VAR 0 7
88534: PUSH
88535: LD_EXP 100
88539: PUSH
88540: LD_VAR 0 7
88544: ARRAY
88545: PUSH
88546: LD_INT 1
88548: PLUS
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PPUSH
88554: LD_VAR 0 4
88558: PUSH
88559: LD_VAR 0 2
88563: PUSH
88564: LD_VAR 0 3
88568: PUSH
88569: EMPTY
88570: LIST
88571: LIST
88572: LIST
88573: PPUSH
88574: CALL 22457 0 3
88578: ST_TO_ADDR
// exit ;
88579: POP
88580: POP
88581: POP
88582: POP
88583: GO 88593
// end ;
88585: GO 88492
88587: POP
88588: POP
// end ;
88589: GO 88300
88591: POP
88592: POP
// end ;
88593: LD_VAR 0 6
88597: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88598: LD_INT 0
88600: PPUSH
88601: PPUSH
88602: PPUSH
88603: PPUSH
// if not mc_bases or not skirmish then
88604: LD_EXP 84
88608: NOT
88609: PUSH
88610: LD_EXP 82
88614: NOT
88615: OR
88616: IFFALSE 88620
// exit ;
88618: GO 88897
// side := GetSide ( lab ) ;
88620: LD_ADDR_VAR 0 4
88624: PUSH
88625: LD_VAR 0 2
88629: PPUSH
88630: CALL_OW 255
88634: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88635: LD_VAR 0 4
88639: PUSH
88640: LD_EXP 110
88644: IN
88645: NOT
88646: PUSH
88647: LD_EXP 111
88651: NOT
88652: OR
88653: PUSH
88654: LD_EXP 84
88658: NOT
88659: OR
88660: IFFALSE 88664
// exit ;
88662: GO 88897
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88664: LD_ADDR_EXP 111
88668: PUSH
88669: LD_EXP 111
88673: PPUSH
88674: LD_VAR 0 4
88678: PPUSH
88679: LD_EXP 111
88683: PUSH
88684: LD_VAR 0 4
88688: ARRAY
88689: PUSH
88690: LD_VAR 0 1
88694: DIFF
88695: PPUSH
88696: CALL_OW 1
88700: ST_TO_ADDR
// for i = 1 to mc_bases do
88701: LD_ADDR_VAR 0 5
88705: PUSH
88706: DOUBLE
88707: LD_INT 1
88709: DEC
88710: ST_TO_ADDR
88711: LD_EXP 84
88715: PUSH
88716: FOR_TO
88717: IFFALSE 88895
// begin if lab in mc_bases [ i ] then
88719: LD_VAR 0 2
88723: PUSH
88724: LD_EXP 84
88728: PUSH
88729: LD_VAR 0 5
88733: ARRAY
88734: IN
88735: IFFALSE 88893
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88737: LD_VAR 0 1
88741: PUSH
88742: LD_INT 11
88744: PUSH
88745: LD_INT 4
88747: PUSH
88748: LD_INT 3
88750: PUSH
88751: LD_INT 2
88753: PUSH
88754: EMPTY
88755: LIST
88756: LIST
88757: LIST
88758: LIST
88759: IN
88760: PUSH
88761: LD_EXP 114
88765: PUSH
88766: LD_VAR 0 5
88770: ARRAY
88771: AND
88772: IFFALSE 88893
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88774: LD_ADDR_VAR 0 6
88778: PUSH
88779: LD_EXP 114
88783: PUSH
88784: LD_VAR 0 5
88788: ARRAY
88789: PUSH
88790: LD_INT 1
88792: ARRAY
88793: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88794: LD_ADDR_EXP 114
88798: PUSH
88799: LD_EXP 114
88803: PPUSH
88804: LD_VAR 0 5
88808: PPUSH
88809: EMPTY
88810: PPUSH
88811: CALL_OW 1
88815: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88816: LD_VAR 0 6
88820: PPUSH
88821: LD_INT 0
88823: PPUSH
88824: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88828: LD_VAR 0 6
88832: PPUSH
88833: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88837: LD_ADDR_EXP 113
88841: PUSH
88842: LD_EXP 113
88846: PPUSH
88847: LD_VAR 0 5
88851: PPUSH
88852: LD_EXP 113
88856: PUSH
88857: LD_VAR 0 5
88861: ARRAY
88862: PPUSH
88863: LD_INT 1
88865: PPUSH
88866: LD_VAR 0 6
88870: PPUSH
88871: CALL_OW 2
88875: PPUSH
88876: CALL_OW 1
88880: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88881: LD_VAR 0 5
88885: PPUSH
88886: LD_INT 112
88888: PPUSH
88889: CALL 65842 0 2
// end ; end ; end ;
88893: GO 88716
88895: POP
88896: POP
// end ;
88897: LD_VAR 0 3
88901: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
88902: LD_INT 0
88904: PPUSH
88905: PPUSH
88906: PPUSH
88907: PPUSH
88908: PPUSH
88909: PPUSH
88910: PPUSH
88911: PPUSH
// if not mc_bases or not skirmish then
88912: LD_EXP 84
88916: NOT
88917: PUSH
88918: LD_EXP 82
88922: NOT
88923: OR
88924: IFFALSE 88928
// exit ;
88926: GO 90299
// for i = 1 to mc_bases do
88928: LD_ADDR_VAR 0 3
88932: PUSH
88933: DOUBLE
88934: LD_INT 1
88936: DEC
88937: ST_TO_ADDR
88938: LD_EXP 84
88942: PUSH
88943: FOR_TO
88944: IFFALSE 90297
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
88946: LD_VAR 0 1
88950: PUSH
88951: LD_EXP 84
88955: PUSH
88956: LD_VAR 0 3
88960: ARRAY
88961: IN
88962: PUSH
88963: LD_VAR 0 1
88967: PUSH
88968: LD_EXP 91
88972: PUSH
88973: LD_VAR 0 3
88977: ARRAY
88978: IN
88979: OR
88980: PUSH
88981: LD_VAR 0 1
88985: PUSH
88986: LD_EXP 106
88990: PUSH
88991: LD_VAR 0 3
88995: ARRAY
88996: IN
88997: OR
88998: PUSH
88999: LD_VAR 0 1
89003: PUSH
89004: LD_EXP 103
89008: PUSH
89009: LD_VAR 0 3
89013: ARRAY
89014: IN
89015: OR
89016: PUSH
89017: LD_VAR 0 1
89021: PUSH
89022: LD_EXP 113
89026: PUSH
89027: LD_VAR 0 3
89031: ARRAY
89032: IN
89033: OR
89034: PUSH
89035: LD_VAR 0 1
89039: PUSH
89040: LD_EXP 114
89044: PUSH
89045: LD_VAR 0 3
89049: ARRAY
89050: IN
89051: OR
89052: IFFALSE 90295
// begin if un in mc_ape [ i ] then
89054: LD_VAR 0 1
89058: PUSH
89059: LD_EXP 113
89063: PUSH
89064: LD_VAR 0 3
89068: ARRAY
89069: IN
89070: IFFALSE 89109
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89072: LD_ADDR_EXP 113
89076: PUSH
89077: LD_EXP 113
89081: PPUSH
89082: LD_VAR 0 3
89086: PPUSH
89087: LD_EXP 113
89091: PUSH
89092: LD_VAR 0 3
89096: ARRAY
89097: PUSH
89098: LD_VAR 0 1
89102: DIFF
89103: PPUSH
89104: CALL_OW 1
89108: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89109: LD_VAR 0 1
89113: PUSH
89114: LD_EXP 114
89118: PUSH
89119: LD_VAR 0 3
89123: ARRAY
89124: IN
89125: IFFALSE 89149
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89127: LD_ADDR_EXP 114
89131: PUSH
89132: LD_EXP 114
89136: PPUSH
89137: LD_VAR 0 3
89141: PPUSH
89142: EMPTY
89143: PPUSH
89144: CALL_OW 1
89148: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89149: LD_VAR 0 1
89153: PPUSH
89154: CALL_OW 247
89158: PUSH
89159: LD_INT 2
89161: EQUAL
89162: PUSH
89163: LD_VAR 0 1
89167: PPUSH
89168: CALL_OW 110
89172: PUSH
89173: LD_INT 20
89175: EQUAL
89176: PUSH
89177: LD_VAR 0 1
89181: PUSH
89182: LD_EXP 106
89186: PUSH
89187: LD_VAR 0 3
89191: ARRAY
89192: IN
89193: OR
89194: PUSH
89195: LD_VAR 0 1
89199: PPUSH
89200: CALL_OW 264
89204: PUSH
89205: LD_INT 12
89207: PUSH
89208: LD_INT 51
89210: PUSH
89211: LD_EXP 2
89215: PUSH
89216: LD_INT 32
89218: PUSH
89219: LD_INT 13
89221: PUSH
89222: LD_INT 52
89224: PUSH
89225: LD_INT 31
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: IN
89237: OR
89238: AND
89239: IFFALSE 89547
// begin if un in mc_defender [ i ] then
89241: LD_VAR 0 1
89245: PUSH
89246: LD_EXP 106
89250: PUSH
89251: LD_VAR 0 3
89255: ARRAY
89256: IN
89257: IFFALSE 89296
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89259: LD_ADDR_EXP 106
89263: PUSH
89264: LD_EXP 106
89268: PPUSH
89269: LD_VAR 0 3
89273: PPUSH
89274: LD_EXP 106
89278: PUSH
89279: LD_VAR 0 3
89283: ARRAY
89284: PUSH
89285: LD_VAR 0 1
89289: DIFF
89290: PPUSH
89291: CALL_OW 1
89295: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89296: LD_ADDR_VAR 0 8
89300: PUSH
89301: LD_VAR 0 3
89305: PPUSH
89306: LD_INT 3
89308: PPUSH
89309: CALL 85946 0 2
89313: ST_TO_ADDR
// if fac then
89314: LD_VAR 0 8
89318: IFFALSE 89547
// begin for j in fac do
89320: LD_ADDR_VAR 0 4
89324: PUSH
89325: LD_VAR 0 8
89329: PUSH
89330: FOR_IN
89331: IFFALSE 89545
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89333: LD_ADDR_VAR 0 9
89337: PUSH
89338: LD_VAR 0 8
89342: PPUSH
89343: LD_VAR 0 1
89347: PPUSH
89348: CALL_OW 265
89352: PPUSH
89353: LD_VAR 0 1
89357: PPUSH
89358: CALL_OW 262
89362: PPUSH
89363: LD_VAR 0 1
89367: PPUSH
89368: CALL_OW 263
89372: PPUSH
89373: LD_VAR 0 1
89377: PPUSH
89378: CALL_OW 264
89382: PPUSH
89383: CALL 19989 0 5
89387: ST_TO_ADDR
// if components then
89388: LD_VAR 0 9
89392: IFFALSE 89543
// begin if GetWeapon ( un ) = ar_control_tower then
89394: LD_VAR 0 1
89398: PPUSH
89399: CALL_OW 264
89403: PUSH
89404: LD_INT 31
89406: EQUAL
89407: IFFALSE 89524
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89409: LD_VAR 0 1
89413: PPUSH
89414: CALL_OW 311
89418: PPUSH
89419: LD_INT 0
89421: PPUSH
89422: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89426: LD_ADDR_EXP 124
89430: PUSH
89431: LD_EXP 124
89435: PPUSH
89436: LD_VAR 0 3
89440: PPUSH
89441: LD_EXP 124
89445: PUSH
89446: LD_VAR 0 3
89450: ARRAY
89451: PUSH
89452: LD_VAR 0 1
89456: PPUSH
89457: CALL_OW 311
89461: DIFF
89462: PPUSH
89463: CALL_OW 1
89467: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89468: LD_ADDR_VAR 0 7
89472: PUSH
89473: LD_EXP 105
89477: PUSH
89478: LD_VAR 0 3
89482: ARRAY
89483: PPUSH
89484: LD_INT 1
89486: PPUSH
89487: LD_VAR 0 9
89491: PPUSH
89492: CALL_OW 2
89496: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89497: LD_ADDR_EXP 105
89501: PUSH
89502: LD_EXP 105
89506: PPUSH
89507: LD_VAR 0 3
89511: PPUSH
89512: LD_VAR 0 7
89516: PPUSH
89517: CALL_OW 1
89521: ST_TO_ADDR
// end else
89522: GO 89541
// MC_InsertProduceList ( i , [ components ] ) ;
89524: LD_VAR 0 3
89528: PPUSH
89529: LD_VAR 0 9
89533: PUSH
89534: EMPTY
89535: LIST
89536: PPUSH
89537: CALL 85491 0 2
// break ;
89541: GO 89545
// end ; end ;
89543: GO 89330
89545: POP
89546: POP
// end ; end ; if GetType ( un ) = unit_building then
89547: LD_VAR 0 1
89551: PPUSH
89552: CALL_OW 247
89556: PUSH
89557: LD_INT 3
89559: EQUAL
89560: IFFALSE 89963
// begin btype := GetBType ( un ) ;
89562: LD_ADDR_VAR 0 5
89566: PUSH
89567: LD_VAR 0 1
89571: PPUSH
89572: CALL_OW 266
89576: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89577: LD_VAR 0 5
89581: PUSH
89582: LD_INT 29
89584: PUSH
89585: LD_INT 30
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: IN
89592: IFFALSE 89665
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89594: LD_VAR 0 1
89598: PPUSH
89599: CALL_OW 250
89603: PPUSH
89604: LD_VAR 0 1
89608: PPUSH
89609: CALL_OW 251
89613: PPUSH
89614: LD_VAR 0 1
89618: PPUSH
89619: CALL_OW 255
89623: PPUSH
89624: CALL_OW 440
89628: NOT
89629: IFFALSE 89665
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89631: LD_VAR 0 1
89635: PPUSH
89636: CALL_OW 250
89640: PPUSH
89641: LD_VAR 0 1
89645: PPUSH
89646: CALL_OW 251
89650: PPUSH
89651: LD_VAR 0 1
89655: PPUSH
89656: CALL_OW 255
89660: PPUSH
89661: CALL_OW 441
// end ; if btype = b_warehouse then
89665: LD_VAR 0 5
89669: PUSH
89670: LD_INT 1
89672: EQUAL
89673: IFFALSE 89691
// begin btype := b_depot ;
89675: LD_ADDR_VAR 0 5
89679: PUSH
89680: LD_INT 0
89682: ST_TO_ADDR
// pos := 1 ;
89683: LD_ADDR_VAR 0 6
89687: PUSH
89688: LD_INT 1
89690: ST_TO_ADDR
// end ; if btype = b_factory then
89691: LD_VAR 0 5
89695: PUSH
89696: LD_INT 3
89698: EQUAL
89699: IFFALSE 89717
// begin btype := b_workshop ;
89701: LD_ADDR_VAR 0 5
89705: PUSH
89706: LD_INT 2
89708: ST_TO_ADDR
// pos := 1 ;
89709: LD_ADDR_VAR 0 6
89713: PUSH
89714: LD_INT 1
89716: ST_TO_ADDR
// end ; if btype = b_barracks then
89717: LD_VAR 0 5
89721: PUSH
89722: LD_INT 5
89724: EQUAL
89725: IFFALSE 89735
// btype := b_armoury ;
89727: LD_ADDR_VAR 0 5
89731: PUSH
89732: LD_INT 4
89734: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89735: LD_VAR 0 5
89739: PUSH
89740: LD_INT 7
89742: PUSH
89743: LD_INT 8
89745: PUSH
89746: EMPTY
89747: LIST
89748: LIST
89749: IN
89750: IFFALSE 89760
// btype := b_lab ;
89752: LD_ADDR_VAR 0 5
89756: PUSH
89757: LD_INT 6
89759: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89760: LD_ADDR_EXP 89
89764: PUSH
89765: LD_EXP 89
89769: PPUSH
89770: LD_VAR 0 3
89774: PUSH
89775: LD_EXP 89
89779: PUSH
89780: LD_VAR 0 3
89784: ARRAY
89785: PUSH
89786: LD_INT 1
89788: PLUS
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: PPUSH
89794: LD_VAR 0 5
89798: PUSH
89799: LD_VAR 0 1
89803: PPUSH
89804: CALL_OW 250
89808: PUSH
89809: LD_VAR 0 1
89813: PPUSH
89814: CALL_OW 251
89818: PUSH
89819: LD_VAR 0 1
89823: PPUSH
89824: CALL_OW 254
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: PPUSH
89835: CALL 22457 0 3
89839: ST_TO_ADDR
// if pos = 1 then
89840: LD_VAR 0 6
89844: PUSH
89845: LD_INT 1
89847: EQUAL
89848: IFFALSE 89963
// begin tmp := mc_build_list [ i ] ;
89850: LD_ADDR_VAR 0 7
89854: PUSH
89855: LD_EXP 89
89859: PUSH
89860: LD_VAR 0 3
89864: ARRAY
89865: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89866: LD_VAR 0 7
89870: PPUSH
89871: LD_INT 2
89873: PUSH
89874: LD_INT 30
89876: PUSH
89877: LD_INT 0
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: PUSH
89884: LD_INT 30
89886: PUSH
89887: LD_INT 1
89889: PUSH
89890: EMPTY
89891: LIST
89892: LIST
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: LIST
89898: PPUSH
89899: CALL_OW 72
89903: IFFALSE 89913
// pos := 2 ;
89905: LD_ADDR_VAR 0 6
89909: PUSH
89910: LD_INT 2
89912: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
89913: LD_ADDR_VAR 0 7
89917: PUSH
89918: LD_VAR 0 7
89922: PPUSH
89923: LD_VAR 0 6
89927: PPUSH
89928: LD_VAR 0 7
89932: PPUSH
89933: CALL 22783 0 3
89937: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
89938: LD_ADDR_EXP 89
89942: PUSH
89943: LD_EXP 89
89947: PPUSH
89948: LD_VAR 0 3
89952: PPUSH
89953: LD_VAR 0 7
89957: PPUSH
89958: CALL_OW 1
89962: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
89963: LD_VAR 0 1
89967: PUSH
89968: LD_EXP 84
89972: PUSH
89973: LD_VAR 0 3
89977: ARRAY
89978: IN
89979: IFFALSE 90018
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
89981: LD_ADDR_EXP 84
89985: PUSH
89986: LD_EXP 84
89990: PPUSH
89991: LD_VAR 0 3
89995: PPUSH
89996: LD_EXP 84
90000: PUSH
90001: LD_VAR 0 3
90005: ARRAY
90006: PUSH
90007: LD_VAR 0 1
90011: DIFF
90012: PPUSH
90013: CALL_OW 1
90017: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90018: LD_VAR 0 1
90022: PUSH
90023: LD_EXP 91
90027: PUSH
90028: LD_VAR 0 3
90032: ARRAY
90033: IN
90034: IFFALSE 90073
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90036: LD_ADDR_EXP 91
90040: PUSH
90041: LD_EXP 91
90045: PPUSH
90046: LD_VAR 0 3
90050: PPUSH
90051: LD_EXP 91
90055: PUSH
90056: LD_VAR 0 3
90060: ARRAY
90061: PUSH
90062: LD_VAR 0 1
90066: DIFF
90067: PPUSH
90068: CALL_OW 1
90072: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90073: LD_VAR 0 1
90077: PUSH
90078: LD_EXP 103
90082: PUSH
90083: LD_VAR 0 3
90087: ARRAY
90088: IN
90089: IFFALSE 90128
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90091: LD_ADDR_EXP 103
90095: PUSH
90096: LD_EXP 103
90100: PPUSH
90101: LD_VAR 0 3
90105: PPUSH
90106: LD_EXP 103
90110: PUSH
90111: LD_VAR 0 3
90115: ARRAY
90116: PUSH
90117: LD_VAR 0 1
90121: DIFF
90122: PPUSH
90123: CALL_OW 1
90127: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90128: LD_VAR 0 1
90132: PUSH
90133: LD_EXP 106
90137: PUSH
90138: LD_VAR 0 3
90142: ARRAY
90143: IN
90144: IFFALSE 90183
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90146: LD_ADDR_EXP 106
90150: PUSH
90151: LD_EXP 106
90155: PPUSH
90156: LD_VAR 0 3
90160: PPUSH
90161: LD_EXP 106
90165: PUSH
90166: LD_VAR 0 3
90170: ARRAY
90171: PUSH
90172: LD_VAR 0 1
90176: DIFF
90177: PPUSH
90178: CALL_OW 1
90182: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90183: LD_VAR 0 1
90187: PUSH
90188: LD_EXP 93
90192: PUSH
90193: LD_VAR 0 3
90197: ARRAY
90198: IN
90199: IFFALSE 90238
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90201: LD_ADDR_EXP 93
90205: PUSH
90206: LD_EXP 93
90210: PPUSH
90211: LD_VAR 0 3
90215: PPUSH
90216: LD_EXP 93
90220: PUSH
90221: LD_VAR 0 3
90225: ARRAY
90226: PUSH
90227: LD_VAR 0 1
90231: DIFF
90232: PPUSH
90233: CALL_OW 1
90237: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90238: LD_VAR 0 1
90242: PUSH
90243: LD_EXP 92
90247: PUSH
90248: LD_VAR 0 3
90252: ARRAY
90253: IN
90254: IFFALSE 90293
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90256: LD_ADDR_EXP 92
90260: PUSH
90261: LD_EXP 92
90265: PPUSH
90266: LD_VAR 0 3
90270: PPUSH
90271: LD_EXP 92
90275: PUSH
90276: LD_VAR 0 3
90280: ARRAY
90281: PUSH
90282: LD_VAR 0 1
90286: DIFF
90287: PPUSH
90288: CALL_OW 1
90292: ST_TO_ADDR
// end ; break ;
90293: GO 90297
// end ;
90295: GO 88943
90297: POP
90298: POP
// end ;
90299: LD_VAR 0 2
90303: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90304: LD_INT 0
90306: PPUSH
90307: PPUSH
90308: PPUSH
// if not mc_bases or not skirmish then
90309: LD_EXP 84
90313: NOT
90314: PUSH
90315: LD_EXP 82
90319: NOT
90320: OR
90321: IFFALSE 90325
// exit ;
90323: GO 90540
// for i = 1 to mc_bases do
90325: LD_ADDR_VAR 0 3
90329: PUSH
90330: DOUBLE
90331: LD_INT 1
90333: DEC
90334: ST_TO_ADDR
90335: LD_EXP 84
90339: PUSH
90340: FOR_TO
90341: IFFALSE 90538
// begin if building in mc_construct_list [ i ] then
90343: LD_VAR 0 1
90347: PUSH
90348: LD_EXP 91
90352: PUSH
90353: LD_VAR 0 3
90357: ARRAY
90358: IN
90359: IFFALSE 90536
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90361: LD_ADDR_EXP 91
90365: PUSH
90366: LD_EXP 91
90370: PPUSH
90371: LD_VAR 0 3
90375: PPUSH
90376: LD_EXP 91
90380: PUSH
90381: LD_VAR 0 3
90385: ARRAY
90386: PUSH
90387: LD_VAR 0 1
90391: DIFF
90392: PPUSH
90393: CALL_OW 1
90397: ST_TO_ADDR
// if building in mc_lab [ i ] then
90398: LD_VAR 0 1
90402: PUSH
90403: LD_EXP 117
90407: PUSH
90408: LD_VAR 0 3
90412: ARRAY
90413: IN
90414: IFFALSE 90469
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90416: LD_ADDR_EXP 118
90420: PUSH
90421: LD_EXP 118
90425: PPUSH
90426: LD_VAR 0 3
90430: PPUSH
90431: LD_EXP 118
90435: PUSH
90436: LD_VAR 0 3
90440: ARRAY
90441: PPUSH
90442: LD_INT 1
90444: PPUSH
90445: LD_EXP 118
90449: PUSH
90450: LD_VAR 0 3
90454: ARRAY
90455: PPUSH
90456: LD_INT 0
90458: PPUSH
90459: CALL 21875 0 4
90463: PPUSH
90464: CALL_OW 1
90468: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90469: LD_VAR 0 1
90473: PUSH
90474: LD_EXP 84
90478: PUSH
90479: LD_VAR 0 3
90483: ARRAY
90484: IN
90485: NOT
90486: IFFALSE 90532
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90488: LD_ADDR_EXP 84
90492: PUSH
90493: LD_EXP 84
90497: PPUSH
90498: LD_VAR 0 3
90502: PUSH
90503: LD_EXP 84
90507: PUSH
90508: LD_VAR 0 3
90512: ARRAY
90513: PUSH
90514: LD_INT 1
90516: PLUS
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PPUSH
90522: LD_VAR 0 1
90526: PPUSH
90527: CALL 22457 0 3
90531: ST_TO_ADDR
// exit ;
90532: POP
90533: POP
90534: GO 90540
// end ; end ;
90536: GO 90340
90538: POP
90539: POP
// end ;
90540: LD_VAR 0 2
90544: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90545: LD_INT 0
90547: PPUSH
90548: PPUSH
90549: PPUSH
90550: PPUSH
90551: PPUSH
90552: PPUSH
90553: PPUSH
// if not mc_bases or not skirmish then
90554: LD_EXP 84
90558: NOT
90559: PUSH
90560: LD_EXP 82
90564: NOT
90565: OR
90566: IFFALSE 90570
// exit ;
90568: GO 91231
// for i = 1 to mc_bases do
90570: LD_ADDR_VAR 0 3
90574: PUSH
90575: DOUBLE
90576: LD_INT 1
90578: DEC
90579: ST_TO_ADDR
90580: LD_EXP 84
90584: PUSH
90585: FOR_TO
90586: IFFALSE 91229
// begin if building in mc_construct_list [ i ] then
90588: LD_VAR 0 1
90592: PUSH
90593: LD_EXP 91
90597: PUSH
90598: LD_VAR 0 3
90602: ARRAY
90603: IN
90604: IFFALSE 91227
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90606: LD_ADDR_EXP 91
90610: PUSH
90611: LD_EXP 91
90615: PPUSH
90616: LD_VAR 0 3
90620: PPUSH
90621: LD_EXP 91
90625: PUSH
90626: LD_VAR 0 3
90630: ARRAY
90631: PUSH
90632: LD_VAR 0 1
90636: DIFF
90637: PPUSH
90638: CALL_OW 1
90642: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90643: LD_ADDR_EXP 84
90647: PUSH
90648: LD_EXP 84
90652: PPUSH
90653: LD_VAR 0 3
90657: PUSH
90658: LD_EXP 84
90662: PUSH
90663: LD_VAR 0 3
90667: ARRAY
90668: PUSH
90669: LD_INT 1
90671: PLUS
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: PPUSH
90677: LD_VAR 0 1
90681: PPUSH
90682: CALL 22457 0 3
90686: ST_TO_ADDR
// btype := GetBType ( building ) ;
90687: LD_ADDR_VAR 0 5
90691: PUSH
90692: LD_VAR 0 1
90696: PPUSH
90697: CALL_OW 266
90701: ST_TO_ADDR
// side := GetSide ( building ) ;
90702: LD_ADDR_VAR 0 8
90706: PUSH
90707: LD_VAR 0 1
90711: PPUSH
90712: CALL_OW 255
90716: ST_TO_ADDR
// if btype = b_lab then
90717: LD_VAR 0 5
90721: PUSH
90722: LD_INT 6
90724: EQUAL
90725: IFFALSE 90775
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90727: LD_ADDR_EXP 117
90731: PUSH
90732: LD_EXP 117
90736: PPUSH
90737: LD_VAR 0 3
90741: PUSH
90742: LD_EXP 117
90746: PUSH
90747: LD_VAR 0 3
90751: ARRAY
90752: PUSH
90753: LD_INT 1
90755: PLUS
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: PPUSH
90761: LD_VAR 0 1
90765: PPUSH
90766: CALL 22457 0 3
90770: ST_TO_ADDR
// exit ;
90771: POP
90772: POP
90773: GO 91231
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90775: LD_VAR 0 5
90779: PUSH
90780: LD_INT 0
90782: PUSH
90783: LD_INT 2
90785: PUSH
90786: LD_INT 4
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: LIST
90793: IN
90794: IFFALSE 90918
// begin if btype = b_armoury then
90796: LD_VAR 0 5
90800: PUSH
90801: LD_INT 4
90803: EQUAL
90804: IFFALSE 90814
// btype := b_barracks ;
90806: LD_ADDR_VAR 0 5
90810: PUSH
90811: LD_INT 5
90813: ST_TO_ADDR
// if btype = b_depot then
90814: LD_VAR 0 5
90818: PUSH
90819: LD_INT 0
90821: EQUAL
90822: IFFALSE 90832
// btype := b_warehouse ;
90824: LD_ADDR_VAR 0 5
90828: PUSH
90829: LD_INT 1
90831: ST_TO_ADDR
// if btype = b_workshop then
90832: LD_VAR 0 5
90836: PUSH
90837: LD_INT 2
90839: EQUAL
90840: IFFALSE 90850
// btype := b_factory ;
90842: LD_ADDR_VAR 0 5
90846: PUSH
90847: LD_INT 3
90849: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90850: LD_VAR 0 5
90854: PPUSH
90855: LD_VAR 0 8
90859: PPUSH
90860: CALL_OW 323
90864: PUSH
90865: LD_INT 1
90867: EQUAL
90868: IFFALSE 90914
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90870: LD_ADDR_EXP 116
90874: PUSH
90875: LD_EXP 116
90879: PPUSH
90880: LD_VAR 0 3
90884: PUSH
90885: LD_EXP 116
90889: PUSH
90890: LD_VAR 0 3
90894: ARRAY
90895: PUSH
90896: LD_INT 1
90898: PLUS
90899: PUSH
90900: EMPTY
90901: LIST
90902: LIST
90903: PPUSH
90904: LD_VAR 0 1
90908: PPUSH
90909: CALL 22457 0 3
90913: ST_TO_ADDR
// exit ;
90914: POP
90915: POP
90916: GO 91231
// end ; if btype in [ b_bunker , b_turret ] then
90918: LD_VAR 0 5
90922: PUSH
90923: LD_INT 32
90925: PUSH
90926: LD_INT 33
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: IN
90933: IFFALSE 91223
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
90935: LD_ADDR_EXP 92
90939: PUSH
90940: LD_EXP 92
90944: PPUSH
90945: LD_VAR 0 3
90949: PUSH
90950: LD_EXP 92
90954: PUSH
90955: LD_VAR 0 3
90959: ARRAY
90960: PUSH
90961: LD_INT 1
90963: PLUS
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PPUSH
90969: LD_VAR 0 1
90973: PPUSH
90974: CALL 22457 0 3
90978: ST_TO_ADDR
// if btype = b_bunker then
90979: LD_VAR 0 5
90983: PUSH
90984: LD_INT 32
90986: EQUAL
90987: IFFALSE 91223
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
90989: LD_ADDR_EXP 93
90993: PUSH
90994: LD_EXP 93
90998: PPUSH
90999: LD_VAR 0 3
91003: PUSH
91004: LD_EXP 93
91008: PUSH
91009: LD_VAR 0 3
91013: ARRAY
91014: PUSH
91015: LD_INT 1
91017: PLUS
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PPUSH
91023: LD_VAR 0 1
91027: PPUSH
91028: CALL 22457 0 3
91032: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91033: LD_ADDR_VAR 0 6
91037: PUSH
91038: LD_EXP 84
91042: PUSH
91043: LD_VAR 0 3
91047: ARRAY
91048: PPUSH
91049: LD_INT 25
91051: PUSH
91052: LD_INT 1
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 3
91061: PUSH
91062: LD_INT 54
91064: PUSH
91065: EMPTY
91066: LIST
91067: PUSH
91068: EMPTY
91069: LIST
91070: LIST
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PPUSH
91076: CALL_OW 72
91080: ST_TO_ADDR
// if tmp then
91081: LD_VAR 0 6
91085: IFFALSE 91091
// exit ;
91087: POP
91088: POP
91089: GO 91231
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91091: LD_ADDR_VAR 0 6
91095: PUSH
91096: LD_EXP 84
91100: PUSH
91101: LD_VAR 0 3
91105: ARRAY
91106: PPUSH
91107: LD_INT 2
91109: PUSH
91110: LD_INT 30
91112: PUSH
91113: LD_INT 4
91115: PUSH
91116: EMPTY
91117: LIST
91118: LIST
91119: PUSH
91120: LD_INT 30
91122: PUSH
91123: LD_INT 5
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: LIST
91134: PPUSH
91135: CALL_OW 72
91139: ST_TO_ADDR
// if not tmp then
91140: LD_VAR 0 6
91144: NOT
91145: IFFALSE 91151
// exit ;
91147: POP
91148: POP
91149: GO 91231
// for j in tmp do
91151: LD_ADDR_VAR 0 4
91155: PUSH
91156: LD_VAR 0 6
91160: PUSH
91161: FOR_IN
91162: IFFALSE 91221
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91164: LD_ADDR_VAR 0 7
91168: PUSH
91169: LD_VAR 0 4
91173: PPUSH
91174: CALL_OW 313
91178: PPUSH
91179: LD_INT 25
91181: PUSH
91182: LD_INT 1
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PPUSH
91189: CALL_OW 72
91193: ST_TO_ADDR
// if units then
91194: LD_VAR 0 7
91198: IFFALSE 91219
// begin ComExitBuilding ( units [ 1 ] ) ;
91200: LD_VAR 0 7
91204: PUSH
91205: LD_INT 1
91207: ARRAY
91208: PPUSH
91209: CALL_OW 122
// exit ;
91213: POP
91214: POP
91215: POP
91216: POP
91217: GO 91231
// end ; end ;
91219: GO 91161
91221: POP
91222: POP
// end ; end ; exit ;
91223: POP
91224: POP
91225: GO 91231
// end ; end ;
91227: GO 90585
91229: POP
91230: POP
// end ;
91231: LD_VAR 0 2
91235: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91236: LD_INT 0
91238: PPUSH
91239: PPUSH
91240: PPUSH
91241: PPUSH
91242: PPUSH
91243: PPUSH
91244: PPUSH
// if not mc_bases or not skirmish then
91245: LD_EXP 84
91249: NOT
91250: PUSH
91251: LD_EXP 82
91255: NOT
91256: OR
91257: IFFALSE 91261
// exit ;
91259: GO 91492
// btype := GetBType ( building ) ;
91261: LD_ADDR_VAR 0 6
91265: PUSH
91266: LD_VAR 0 1
91270: PPUSH
91271: CALL_OW 266
91275: ST_TO_ADDR
// x := GetX ( building ) ;
91276: LD_ADDR_VAR 0 7
91280: PUSH
91281: LD_VAR 0 1
91285: PPUSH
91286: CALL_OW 250
91290: ST_TO_ADDR
// y := GetY ( building ) ;
91291: LD_ADDR_VAR 0 8
91295: PUSH
91296: LD_VAR 0 1
91300: PPUSH
91301: CALL_OW 251
91305: ST_TO_ADDR
// d := GetDir ( building ) ;
91306: LD_ADDR_VAR 0 9
91310: PUSH
91311: LD_VAR 0 1
91315: PPUSH
91316: CALL_OW 254
91320: ST_TO_ADDR
// for i = 1 to mc_bases do
91321: LD_ADDR_VAR 0 4
91325: PUSH
91326: DOUBLE
91327: LD_INT 1
91329: DEC
91330: ST_TO_ADDR
91331: LD_EXP 84
91335: PUSH
91336: FOR_TO
91337: IFFALSE 91490
// begin if not mc_build_list [ i ] then
91339: LD_EXP 89
91343: PUSH
91344: LD_VAR 0 4
91348: ARRAY
91349: NOT
91350: IFFALSE 91354
// continue ;
91352: GO 91336
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
91354: LD_VAR 0 6
91358: PUSH
91359: LD_VAR 0 7
91363: PUSH
91364: LD_VAR 0 8
91368: PUSH
91369: LD_VAR 0 9
91373: PUSH
91374: EMPTY
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: PPUSH
91380: LD_EXP 89
91384: PUSH
91385: LD_VAR 0 4
91389: ARRAY
91390: PUSH
91391: LD_INT 1
91393: ARRAY
91394: PPUSH
91395: CALL 28626 0 2
91399: IFFALSE 91488
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
91401: LD_ADDR_EXP 89
91405: PUSH
91406: LD_EXP 89
91410: PPUSH
91411: LD_VAR 0 4
91415: PPUSH
91416: LD_EXP 89
91420: PUSH
91421: LD_VAR 0 4
91425: ARRAY
91426: PPUSH
91427: LD_INT 1
91429: PPUSH
91430: CALL_OW 3
91434: PPUSH
91435: CALL_OW 1
91439: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91440: LD_ADDR_EXP 91
91444: PUSH
91445: LD_EXP 91
91449: PPUSH
91450: LD_VAR 0 4
91454: PUSH
91455: LD_EXP 91
91459: PUSH
91460: LD_VAR 0 4
91464: ARRAY
91465: PUSH
91466: LD_INT 1
91468: PLUS
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: PPUSH
91474: LD_VAR 0 1
91478: PPUSH
91479: CALL 22457 0 3
91483: ST_TO_ADDR
// exit ;
91484: POP
91485: POP
91486: GO 91492
// end ; end ;
91488: GO 91336
91490: POP
91491: POP
// end ;
91492: LD_VAR 0 3
91496: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91497: LD_INT 0
91499: PPUSH
91500: PPUSH
91501: PPUSH
// if not mc_bases or not skirmish then
91502: LD_EXP 84
91506: NOT
91507: PUSH
91508: LD_EXP 82
91512: NOT
91513: OR
91514: IFFALSE 91518
// exit ;
91516: GO 91708
// for i = 1 to mc_bases do
91518: LD_ADDR_VAR 0 4
91522: PUSH
91523: DOUBLE
91524: LD_INT 1
91526: DEC
91527: ST_TO_ADDR
91528: LD_EXP 84
91532: PUSH
91533: FOR_TO
91534: IFFALSE 91621
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91536: LD_VAR 0 1
91540: PUSH
91541: LD_EXP 92
91545: PUSH
91546: LD_VAR 0 4
91550: ARRAY
91551: IN
91552: PUSH
91553: LD_VAR 0 1
91557: PUSH
91558: LD_EXP 93
91562: PUSH
91563: LD_VAR 0 4
91567: ARRAY
91568: IN
91569: NOT
91570: AND
91571: IFFALSE 91619
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91573: LD_ADDR_EXP 93
91577: PUSH
91578: LD_EXP 93
91582: PPUSH
91583: LD_VAR 0 4
91587: PUSH
91588: LD_EXP 93
91592: PUSH
91593: LD_VAR 0 4
91597: ARRAY
91598: PUSH
91599: LD_INT 1
91601: PLUS
91602: PUSH
91603: EMPTY
91604: LIST
91605: LIST
91606: PPUSH
91607: LD_VAR 0 1
91611: PPUSH
91612: CALL 22457 0 3
91616: ST_TO_ADDR
// break ;
91617: GO 91621
// end ; end ;
91619: GO 91533
91621: POP
91622: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91623: LD_VAR 0 1
91627: PPUSH
91628: CALL_OW 257
91632: PUSH
91633: LD_EXP 110
91637: IN
91638: PUSH
91639: LD_VAR 0 1
91643: PPUSH
91644: CALL_OW 266
91648: PUSH
91649: LD_INT 5
91651: EQUAL
91652: AND
91653: PUSH
91654: LD_VAR 0 2
91658: PPUSH
91659: CALL_OW 110
91663: PUSH
91664: LD_INT 18
91666: NONEQUAL
91667: AND
91668: IFFALSE 91708
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91670: LD_VAR 0 2
91674: PPUSH
91675: CALL_OW 257
91679: PUSH
91680: LD_INT 5
91682: PUSH
91683: LD_INT 8
91685: PUSH
91686: LD_INT 9
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: LIST
91693: IN
91694: IFFALSE 91708
// SetClass ( unit , 1 ) ;
91696: LD_VAR 0 2
91700: PPUSH
91701: LD_INT 1
91703: PPUSH
91704: CALL_OW 336
// end ;
91708: LD_VAR 0 3
91712: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91713: LD_INT 0
91715: PPUSH
91716: PPUSH
// if not mc_bases or not skirmish then
91717: LD_EXP 84
91721: NOT
91722: PUSH
91723: LD_EXP 82
91727: NOT
91728: OR
91729: IFFALSE 91733
// exit ;
91731: GO 91849
// if GetLives ( abandoned_vehicle ) > 250 then
91733: LD_VAR 0 2
91737: PPUSH
91738: CALL_OW 256
91742: PUSH
91743: LD_INT 250
91745: GREATER
91746: IFFALSE 91750
// exit ;
91748: GO 91849
// for i = 1 to mc_bases do
91750: LD_ADDR_VAR 0 6
91754: PUSH
91755: DOUBLE
91756: LD_INT 1
91758: DEC
91759: ST_TO_ADDR
91760: LD_EXP 84
91764: PUSH
91765: FOR_TO
91766: IFFALSE 91847
// begin if driver in mc_bases [ i ] then
91768: LD_VAR 0 1
91772: PUSH
91773: LD_EXP 84
91777: PUSH
91778: LD_VAR 0 6
91782: ARRAY
91783: IN
91784: IFFALSE 91845
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91786: LD_VAR 0 1
91790: PPUSH
91791: LD_EXP 84
91795: PUSH
91796: LD_VAR 0 6
91800: ARRAY
91801: PPUSH
91802: LD_INT 2
91804: PUSH
91805: LD_INT 30
91807: PUSH
91808: LD_INT 0
91810: PUSH
91811: EMPTY
91812: LIST
91813: LIST
91814: PUSH
91815: LD_INT 30
91817: PUSH
91818: LD_INT 1
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: PUSH
91825: EMPTY
91826: LIST
91827: LIST
91828: LIST
91829: PPUSH
91830: CALL_OW 72
91834: PUSH
91835: LD_INT 1
91837: ARRAY
91838: PPUSH
91839: CALL 54323 0 2
// break ;
91843: GO 91847
// end ; end ;
91845: GO 91765
91847: POP
91848: POP
// end ;
91849: LD_VAR 0 5
91853: RET
