// export function CustomInitMacro ; begin
   0: LD_INT 0
   2: PPUSH
// end ;
   3: LD_VAR 0 1
   7: RET
// export function CustomEvent ( event ) ; begin
   8: LD_INT 0
  10: PPUSH
// end ; end_of_file
  11: LD_VAR 0 2
  15: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
  16: LD_INT 0
  18: PPUSH
// ar_miner := 81 ;
  19: LD_ADDR_EXP 8
  23: PUSH
  24: LD_INT 81
  26: ST_TO_ADDR
// ar_crane := 88 ;
  27: LD_ADDR_EXP 7
  31: PUSH
  32: LD_INT 88
  34: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
  35: LD_ADDR_EXP 2
  39: PUSH
  40: LD_INT 89
  42: ST_TO_ADDR
// us_hack := 99 ;
  43: LD_ADDR_EXP 3
  47: PUSH
  48: LD_INT 99
  50: ST_TO_ADDR
// us_artillery := 97 ;
  51: LD_ADDR_EXP 4
  55: PUSH
  56: LD_INT 97
  58: ST_TO_ADDR
// ar_bio_bomb := 91 ;
  59: LD_ADDR_EXP 5
  63: PUSH
  64: LD_INT 91
  66: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
  67: LD_ADDR_EXP 6
  71: PUSH
  72: LD_INT 92
  74: ST_TO_ADDR
// ru_radar := 98 ;
  75: LD_ADDR_EXP 1
  79: PUSH
  80: LD_INT 98
  82: ST_TO_ADDR
// tech_Artillery := 80 ;
  83: LD_ADDR_EXP 9
  87: PUSH
  88: LD_INT 80
  90: ST_TO_ADDR
// tech_RadMat := 81 ;
  91: LD_ADDR_EXP 10
  95: PUSH
  96: LD_INT 81
  98: ST_TO_ADDR
// tech_BasicTools := 82 ;
  99: LD_ADDR_EXP 11
 103: PUSH
 104: LD_INT 82
 106: ST_TO_ADDR
// tech_Cargo := 83 ;
 107: LD_ADDR_EXP 12
 111: PUSH
 112: LD_INT 83
 114: ST_TO_ADDR
// tech_Track := 84 ;
 115: LD_ADDR_EXP 13
 119: PUSH
 120: LD_INT 84
 122: ST_TO_ADDR
// tech_Crane := 85 ;
 123: LD_ADDR_EXP 14
 127: PUSH
 128: LD_INT 85
 130: ST_TO_ADDR
// tech_Bulldozer := 86 ;
 131: LD_ADDR_EXP 15
 135: PUSH
 136: LD_INT 86
 138: ST_TO_ADDR
// tech_Hovercraft := 87 ;
 139: LD_ADDR_EXP 16
 143: PUSH
 144: LD_INT 87
 146: ST_TO_ADDR
// end ;
 147: LD_VAR 0 1
 151: RET
// every 1 do
 152: GO 154
 154: DISABLE
// InitGlobalVariables ; end_of_file
 155: CALL 16 0 0
 159: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
 160: LD_VAR 0 2
 164: PUSH
 165: LD_INT 100
 167: EQUAL
 168: IFFALSE 1117
// begin if not StreamModeActive then
 170: LD_EXP 17
 174: NOT
 175: IFFALSE 185
// StreamModeActive := true ;
 177: LD_ADDR_EXP 17
 181: PUSH
 182: LD_INT 1
 184: ST_TO_ADDR
// if p3 = 0 then
 185: LD_VAR 0 3
 189: PUSH
 190: LD_INT 0
 192: EQUAL
 193: IFFALSE 199
// InitStreamMode ;
 195: CALL 1275 0 0
// if p3 = 1 then
 199: LD_VAR 0 3
 203: PUSH
 204: LD_INT 1
 206: EQUAL
 207: IFFALSE 217
// sRocket := true ;
 209: LD_ADDR_EXP 22
 213: PUSH
 214: LD_INT 1
 216: ST_TO_ADDR
// if p3 = 2 then
 217: LD_VAR 0 3
 221: PUSH
 222: LD_INT 2
 224: EQUAL
 225: IFFALSE 235
// sSpeed := true ;
 227: LD_ADDR_EXP 21
 231: PUSH
 232: LD_INT 1
 234: ST_TO_ADDR
// if p3 = 3 then
 235: LD_VAR 0 3
 239: PUSH
 240: LD_INT 3
 242: EQUAL
 243: IFFALSE 253
// sEngine := true ;
 245: LD_ADDR_EXP 23
 249: PUSH
 250: LD_INT 1
 252: ST_TO_ADDR
// if p3 = 4 then
 253: LD_VAR 0 3
 257: PUSH
 258: LD_INT 4
 260: EQUAL
 261: IFFALSE 271
// sSpec := true ;
 263: LD_ADDR_EXP 20
 267: PUSH
 268: LD_INT 1
 270: ST_TO_ADDR
// if p3 = 5 then
 271: LD_VAR 0 3
 275: PUSH
 276: LD_INT 5
 278: EQUAL
 279: IFFALSE 289
// sLevel := true ;
 281: LD_ADDR_EXP 24
 285: PUSH
 286: LD_INT 1
 288: ST_TO_ADDR
// if p3 = 6 then
 289: LD_VAR 0 3
 293: PUSH
 294: LD_INT 6
 296: EQUAL
 297: IFFALSE 307
// sArmoury := true ;
 299: LD_ADDR_EXP 25
 303: PUSH
 304: LD_INT 1
 306: ST_TO_ADDR
// if p3 = 7 then
 307: LD_VAR 0 3
 311: PUSH
 312: LD_INT 7
 314: EQUAL
 315: IFFALSE 325
// sRadar := true ;
 317: LD_ADDR_EXP 26
 321: PUSH
 322: LD_INT 1
 324: ST_TO_ADDR
// if p3 = 8 then
 325: LD_VAR 0 3
 329: PUSH
 330: LD_INT 8
 332: EQUAL
 333: IFFALSE 343
// sBunker := true ;
 335: LD_ADDR_EXP 27
 339: PUSH
 340: LD_INT 1
 342: ST_TO_ADDR
// if p3 = 9 then
 343: LD_VAR 0 3
 347: PUSH
 348: LD_INT 9
 350: EQUAL
 351: IFFALSE 361
// sHack := true ;
 353: LD_ADDR_EXP 28
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// if p3 = 10 then
 361: LD_VAR 0 3
 365: PUSH
 366: LD_INT 10
 368: EQUAL
 369: IFFALSE 379
// sFire := true ;
 371: LD_ADDR_EXP 29
 375: PUSH
 376: LD_INT 1
 378: ST_TO_ADDR
// if p3 = 11 then
 379: LD_VAR 0 3
 383: PUSH
 384: LD_INT 11
 386: EQUAL
 387: IFFALSE 397
// sRefresh := true ;
 389: LD_ADDR_EXP 30
 393: PUSH
 394: LD_INT 1
 396: ST_TO_ADDR
// if p3 = 12 then
 397: LD_VAR 0 3
 401: PUSH
 402: LD_INT 12
 404: EQUAL
 405: IFFALSE 415
// sExp := true ;
 407: LD_ADDR_EXP 31
 411: PUSH
 412: LD_INT 1
 414: ST_TO_ADDR
// if p3 = 13 then
 415: LD_VAR 0 3
 419: PUSH
 420: LD_INT 13
 422: EQUAL
 423: IFFALSE 433
// sDepot := true ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 1
 432: ST_TO_ADDR
// if p3 = 14 then
 433: LD_VAR 0 3
 437: PUSH
 438: LD_INT 14
 440: EQUAL
 441: IFFALSE 451
// sFlag := true ;
 443: LD_ADDR_EXP 33
 447: PUSH
 448: LD_INT 1
 450: ST_TO_ADDR
// if p3 = 15 then
 451: LD_VAR 0 3
 455: PUSH
 456: LD_INT 15
 458: EQUAL
 459: IFFALSE 469
// sKamikadze := true ;
 461: LD_ADDR_EXP 41
 465: PUSH
 466: LD_INT 1
 468: ST_TO_ADDR
// if p3 = 16 then
 469: LD_VAR 0 3
 473: PUSH
 474: LD_INT 16
 476: EQUAL
 477: IFFALSE 487
// sTroll := true ;
 479: LD_ADDR_EXP 42
 483: PUSH
 484: LD_INT 1
 486: ST_TO_ADDR
// if p3 = 17 then
 487: LD_VAR 0 3
 491: PUSH
 492: LD_INT 17
 494: EQUAL
 495: IFFALSE 505
// sSlow := true ;
 497: LD_ADDR_EXP 43
 501: PUSH
 502: LD_INT 1
 504: ST_TO_ADDR
// if p3 = 18 then
 505: LD_VAR 0 3
 509: PUSH
 510: LD_INT 18
 512: EQUAL
 513: IFFALSE 523
// sLack := true ;
 515: LD_ADDR_EXP 44
 519: PUSH
 520: LD_INT 1
 522: ST_TO_ADDR
// if p3 = 19 then
 523: LD_VAR 0 3
 527: PUSH
 528: LD_INT 19
 530: EQUAL
 531: IFFALSE 541
// sTank := true ;
 533: LD_ADDR_EXP 46
 537: PUSH
 538: LD_INT 1
 540: ST_TO_ADDR
// if p3 = 20 then
 541: LD_VAR 0 3
 545: PUSH
 546: LD_INT 20
 548: EQUAL
 549: IFFALSE 559
// sRemote := true ;
 551: LD_ADDR_EXP 47
 555: PUSH
 556: LD_INT 1
 558: ST_TO_ADDR
// if p3 = 21 then
 559: LD_VAR 0 3
 563: PUSH
 564: LD_INT 21
 566: EQUAL
 567: IFFALSE 577
// sPowell := true ;
 569: LD_ADDR_EXP 48
 573: PUSH
 574: LD_INT 1
 576: ST_TO_ADDR
// if p3 = 22 then
 577: LD_VAR 0 3
 581: PUSH
 582: LD_INT 22
 584: EQUAL
 585: IFFALSE 595
// sTeleport := true ;
 587: LD_ADDR_EXP 51
 591: PUSH
 592: LD_INT 1
 594: ST_TO_ADDR
// if p3 = 23 then
 595: LD_VAR 0 3
 599: PUSH
 600: LD_INT 23
 602: EQUAL
 603: IFFALSE 613
// sOilTower := true ;
 605: LD_ADDR_EXP 53
 609: PUSH
 610: LD_INT 1
 612: ST_TO_ADDR
// if p3 = 24 then
 613: LD_VAR 0 3
 617: PUSH
 618: LD_INT 24
 620: EQUAL
 621: IFFALSE 631
// sShovel := true ;
 623: LD_ADDR_EXP 54
 627: PUSH
 628: LD_INT 1
 630: ST_TO_ADDR
// if p3 = 25 then
 631: LD_VAR 0 3
 635: PUSH
 636: LD_INT 25
 638: EQUAL
 639: IFFALSE 649
// sSheik := true ;
 641: LD_ADDR_EXP 55
 645: PUSH
 646: LD_INT 1
 648: ST_TO_ADDR
// if p3 = 26 then
 649: LD_VAR 0 3
 653: PUSH
 654: LD_INT 26
 656: EQUAL
 657: IFFALSE 667
// sEarthquake := true ;
 659: LD_ADDR_EXP 57
 663: PUSH
 664: LD_INT 1
 666: ST_TO_ADDR
// if p3 = 27 then
 667: LD_VAR 0 3
 671: PUSH
 672: LD_INT 27
 674: EQUAL
 675: IFFALSE 685
// sAI := true ;
 677: LD_ADDR_EXP 58
 681: PUSH
 682: LD_INT 1
 684: ST_TO_ADDR
// if p3 = 28 then
 685: LD_VAR 0 3
 689: PUSH
 690: LD_INT 28
 692: EQUAL
 693: IFFALSE 703
// sCargo := true ;
 695: LD_ADDR_EXP 61
 699: PUSH
 700: LD_INT 1
 702: ST_TO_ADDR
// if p3 = 29 then
 703: LD_VAR 0 3
 707: PUSH
 708: LD_INT 29
 710: EQUAL
 711: IFFALSE 721
// sDLaser := true ;
 713: LD_ADDR_EXP 62
 717: PUSH
 718: LD_INT 1
 720: ST_TO_ADDR
// if p3 = 30 then
 721: LD_VAR 0 3
 725: PUSH
 726: LD_INT 30
 728: EQUAL
 729: IFFALSE 739
// sExchange := true ;
 731: LD_ADDR_EXP 63
 735: PUSH
 736: LD_INT 1
 738: ST_TO_ADDR
// if p3 = 31 then
 739: LD_VAR 0 3
 743: PUSH
 744: LD_INT 31
 746: EQUAL
 747: IFFALSE 757
// sFac := true ;
 749: LD_ADDR_EXP 64
 753: PUSH
 754: LD_INT 1
 756: ST_TO_ADDR
// if p3 = 32 then
 757: LD_VAR 0 3
 761: PUSH
 762: LD_INT 32
 764: EQUAL
 765: IFFALSE 775
// sPower := true ;
 767: LD_ADDR_EXP 65
 771: PUSH
 772: LD_INT 1
 774: ST_TO_ADDR
// if p3 = 33 then
 775: LD_VAR 0 3
 779: PUSH
 780: LD_INT 33
 782: EQUAL
 783: IFFALSE 793
// sRandom := true ;
 785: LD_ADDR_EXP 66
 789: PUSH
 790: LD_INT 1
 792: ST_TO_ADDR
// if p3 = 34 then
 793: LD_VAR 0 3
 797: PUSH
 798: LD_INT 34
 800: EQUAL
 801: IFFALSE 811
// sShield := true ;
 803: LD_ADDR_EXP 67
 807: PUSH
 808: LD_INT 1
 810: ST_TO_ADDR
// if p3 = 35 then
 811: LD_VAR 0 3
 815: PUSH
 816: LD_INT 35
 818: EQUAL
 819: IFFALSE 829
// sTime := true ;
 821: LD_ADDR_EXP 68
 825: PUSH
 826: LD_INT 1
 828: ST_TO_ADDR
// if p3 = 36 then
 829: LD_VAR 0 3
 833: PUSH
 834: LD_INT 36
 836: EQUAL
 837: IFFALSE 847
// sTools := true ;
 839: LD_ADDR_EXP 69
 843: PUSH
 844: LD_INT 1
 846: ST_TO_ADDR
// if p3 = 101 then
 847: LD_VAR 0 3
 851: PUSH
 852: LD_INT 101
 854: EQUAL
 855: IFFALSE 865
// sSold := true ;
 857: LD_ADDR_EXP 34
 861: PUSH
 862: LD_INT 1
 864: ST_TO_ADDR
// if p3 = 102 then
 865: LD_VAR 0 3
 869: PUSH
 870: LD_INT 102
 872: EQUAL
 873: IFFALSE 883
// sDiff := true ;
 875: LD_ADDR_EXP 35
 879: PUSH
 880: LD_INT 1
 882: ST_TO_ADDR
// if p3 = 103 then
 883: LD_VAR 0 3
 887: PUSH
 888: LD_INT 103
 890: EQUAL
 891: IFFALSE 901
// sFog := true ;
 893: LD_ADDR_EXP 38
 897: PUSH
 898: LD_INT 1
 900: ST_TO_ADDR
// if p3 = 104 then
 901: LD_VAR 0 3
 905: PUSH
 906: LD_INT 104
 908: EQUAL
 909: IFFALSE 919
// sReset := true ;
 911: LD_ADDR_EXP 39
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
// if p3 = 105 then
 919: LD_VAR 0 3
 923: PUSH
 924: LD_INT 105
 926: EQUAL
 927: IFFALSE 937
// sSun := true ;
 929: LD_ADDR_EXP 40
 933: PUSH
 934: LD_INT 1
 936: ST_TO_ADDR
// if p3 = 106 then
 937: LD_VAR 0 3
 941: PUSH
 942: LD_INT 106
 944: EQUAL
 945: IFFALSE 955
// sTiger := true ;
 947: LD_ADDR_EXP 36
 951: PUSH
 952: LD_INT 1
 954: ST_TO_ADDR
// if p3 = 107 then
 955: LD_VAR 0 3
 959: PUSH
 960: LD_INT 107
 962: EQUAL
 963: IFFALSE 973
// sBomb := true ;
 965: LD_ADDR_EXP 37
 969: PUSH
 970: LD_INT 1
 972: ST_TO_ADDR
// if p3 = 108 then
 973: LD_VAR 0 3
 977: PUSH
 978: LD_INT 108
 980: EQUAL
 981: IFFALSE 991
// sWound := true ;
 983: LD_ADDR_EXP 45
 987: PUSH
 988: LD_INT 1
 990: ST_TO_ADDR
// if p3 = 109 then
 991: LD_VAR 0 3
 995: PUSH
 996: LD_INT 109
 998: EQUAL
 999: IFFALSE 1009
// sBetray := true ;
1001: LD_ADDR_EXP 49
1005: PUSH
1006: LD_INT 1
1008: ST_TO_ADDR
// if p3 = 110 then
1009: LD_VAR 0 3
1013: PUSH
1014: LD_INT 110
1016: EQUAL
1017: IFFALSE 1027
// sContamin := true ;
1019: LD_ADDR_EXP 50
1023: PUSH
1024: LD_INT 1
1026: ST_TO_ADDR
// if p3 = 111 then
1027: LD_VAR 0 3
1031: PUSH
1032: LD_INT 111
1034: EQUAL
1035: IFFALSE 1045
// sOil := true ;
1037: LD_ADDR_EXP 52
1041: PUSH
1042: LD_INT 1
1044: ST_TO_ADDR
// if p3 = 112 then
1045: LD_VAR 0 3
1049: PUSH
1050: LD_INT 112
1052: EQUAL
1053: IFFALSE 1063
// sStu := true ;
1055: LD_ADDR_EXP 56
1059: PUSH
1060: LD_INT 1
1062: ST_TO_ADDR
// if p3 = 113 then
1063: LD_VAR 0 3
1067: PUSH
1068: LD_INT 113
1070: EQUAL
1071: IFFALSE 1081
// sBazooka := true ;
1073: LD_ADDR_EXP 59
1077: PUSH
1078: LD_INT 1
1080: ST_TO_ADDR
// if p3 = 114 then
1081: LD_VAR 0 3
1085: PUSH
1086: LD_INT 114
1088: EQUAL
1089: IFFALSE 1099
// sMortar := true ;
1091: LD_ADDR_EXP 60
1095: PUSH
1096: LD_INT 1
1098: ST_TO_ADDR
// if p3 = 115 then
1099: LD_VAR 0 3
1103: PUSH
1104: LD_INT 115
1106: EQUAL
1107: IFFALSE 1117
// sRanger := true ;
1109: LD_ADDR_EXP 70
1113: PUSH
1114: LD_INT 1
1116: ST_TO_ADDR
// end ; if p2 = 101 then
1117: LD_VAR 0 2
1121: PUSH
1122: LD_INT 101
1124: EQUAL
1125: IFFALSE 1253
// begin case p3 of 1 :
1127: LD_VAR 0 3
1131: PUSH
1132: LD_INT 1
1134: DOUBLE
1135: EQUAL
1136: IFTRUE 1140
1138: GO 1147
1140: POP
// hHackUnlimitedResources ; 2 :
1141: CALL 12288 0 0
1145: GO 1253
1147: LD_INT 2
1149: DOUBLE
1150: EQUAL
1151: IFTRUE 1155
1153: GO 1162
1155: POP
// hHackSetLevel10 ; 3 :
1156: CALL 12421 0 0
1160: GO 1253
1162: LD_INT 3
1164: DOUBLE
1165: EQUAL
1166: IFTRUE 1170
1168: GO 1177
1170: POP
// hHackSetLevel10YourUnits ; 4 :
1171: CALL 12506 0 0
1175: GO 1253
1177: LD_INT 4
1179: DOUBLE
1180: EQUAL
1181: IFTRUE 1185
1183: GO 1192
1185: POP
// hHackInvincible ; 5 :
1186: CALL 12954 0 0
1190: GO 1253
1192: LD_INT 5
1194: DOUBLE
1195: EQUAL
1196: IFTRUE 1200
1198: GO 1207
1200: POP
// hHackInvisible ; 6 :
1201: CALL 13065 0 0
1205: GO 1253
1207: LD_INT 6
1209: DOUBLE
1210: EQUAL
1211: IFTRUE 1215
1213: GO 1222
1215: POP
// hHackChangeYourSide ; 7 :
1216: CALL 13122 0 0
1220: GO 1253
1222: LD_INT 7
1224: DOUBLE
1225: EQUAL
1226: IFTRUE 1230
1228: GO 1237
1230: POP
// hHackChangeUnitSide ; 8 :
1231: CALL 13164 0 0
1235: GO 1253
1237: LD_INT 8
1239: DOUBLE
1240: EQUAL
1241: IFTRUE 1245
1243: GO 1252
1245: POP
// hHackFog ; end ;
1246: CALL 13265 0 0
1250: GO 1253
1252: POP
// end ; end ;
1253: PPOPN 6
1255: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
1256: GO 1258
1258: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
1259: LD_STRING initStreamRollete();
1261: PPUSH
1262: CALL_OW 559
// InitStreamMode ;
1266: CALL 1275 0 0
// DefineStreamItems ( ) ;
1270: CALL 1715 0 0
// end ;
1274: END
// function InitStreamMode ; begin
1275: LD_INT 0
1277: PPUSH
// streamModeActive := false ;
1278: LD_ADDR_EXP 17
1282: PUSH
1283: LD_INT 0
1285: ST_TO_ADDR
// normalCounter := 36 ;
1286: LD_ADDR_EXP 18
1290: PUSH
1291: LD_INT 36
1293: ST_TO_ADDR
// hardcoreCounter := 16 ;
1294: LD_ADDR_EXP 19
1298: PUSH
1299: LD_INT 16
1301: ST_TO_ADDR
// sRocket := false ;
1302: LD_ADDR_EXP 22
1306: PUSH
1307: LD_INT 0
1309: ST_TO_ADDR
// sSpeed := false ;
1310: LD_ADDR_EXP 21
1314: PUSH
1315: LD_INT 0
1317: ST_TO_ADDR
// sEngine := false ;
1318: LD_ADDR_EXP 23
1322: PUSH
1323: LD_INT 0
1325: ST_TO_ADDR
// sSpec := false ;
1326: LD_ADDR_EXP 20
1330: PUSH
1331: LD_INT 0
1333: ST_TO_ADDR
// sLevel := false ;
1334: LD_ADDR_EXP 24
1338: PUSH
1339: LD_INT 0
1341: ST_TO_ADDR
// sArmoury := false ;
1342: LD_ADDR_EXP 25
1346: PUSH
1347: LD_INT 0
1349: ST_TO_ADDR
// sRadar := false ;
1350: LD_ADDR_EXP 26
1354: PUSH
1355: LD_INT 0
1357: ST_TO_ADDR
// sBunker := false ;
1358: LD_ADDR_EXP 27
1362: PUSH
1363: LD_INT 0
1365: ST_TO_ADDR
// sHack := false ;
1366: LD_ADDR_EXP 28
1370: PUSH
1371: LD_INT 0
1373: ST_TO_ADDR
// sFire := false ;
1374: LD_ADDR_EXP 29
1378: PUSH
1379: LD_INT 0
1381: ST_TO_ADDR
// sRefresh := false ;
1382: LD_ADDR_EXP 30
1386: PUSH
1387: LD_INT 0
1389: ST_TO_ADDR
// sExp := false ;
1390: LD_ADDR_EXP 31
1394: PUSH
1395: LD_INT 0
1397: ST_TO_ADDR
// sDepot := false ;
1398: LD_ADDR_EXP 32
1402: PUSH
1403: LD_INT 0
1405: ST_TO_ADDR
// sFlag := false ;
1406: LD_ADDR_EXP 33
1410: PUSH
1411: LD_INT 0
1413: ST_TO_ADDR
// sKamikadze := false ;
1414: LD_ADDR_EXP 41
1418: PUSH
1419: LD_INT 0
1421: ST_TO_ADDR
// sTroll := false ;
1422: LD_ADDR_EXP 42
1426: PUSH
1427: LD_INT 0
1429: ST_TO_ADDR
// sSlow := false ;
1430: LD_ADDR_EXP 43
1434: PUSH
1435: LD_INT 0
1437: ST_TO_ADDR
// sLack := false ;
1438: LD_ADDR_EXP 44
1442: PUSH
1443: LD_INT 0
1445: ST_TO_ADDR
// sTank := false ;
1446: LD_ADDR_EXP 46
1450: PUSH
1451: LD_INT 0
1453: ST_TO_ADDR
// sRemote := false ;
1454: LD_ADDR_EXP 47
1458: PUSH
1459: LD_INT 0
1461: ST_TO_ADDR
// sPowell := false ;
1462: LD_ADDR_EXP 48
1466: PUSH
1467: LD_INT 0
1469: ST_TO_ADDR
// sTeleport := false ;
1470: LD_ADDR_EXP 51
1474: PUSH
1475: LD_INT 0
1477: ST_TO_ADDR
// sOilTower := false ;
1478: LD_ADDR_EXP 53
1482: PUSH
1483: LD_INT 0
1485: ST_TO_ADDR
// sShovel := false ;
1486: LD_ADDR_EXP 54
1490: PUSH
1491: LD_INT 0
1493: ST_TO_ADDR
// sSheik := false ;
1494: LD_ADDR_EXP 55
1498: PUSH
1499: LD_INT 0
1501: ST_TO_ADDR
// sEarthquake := false ;
1502: LD_ADDR_EXP 57
1506: PUSH
1507: LD_INT 0
1509: ST_TO_ADDR
// sAI := false ;
1510: LD_ADDR_EXP 58
1514: PUSH
1515: LD_INT 0
1517: ST_TO_ADDR
// sCargo := false ;
1518: LD_ADDR_EXP 61
1522: PUSH
1523: LD_INT 0
1525: ST_TO_ADDR
// sDLaser := false ;
1526: LD_ADDR_EXP 62
1530: PUSH
1531: LD_INT 0
1533: ST_TO_ADDR
// sExchange := false ;
1534: LD_ADDR_EXP 63
1538: PUSH
1539: LD_INT 0
1541: ST_TO_ADDR
// sFac := false ;
1542: LD_ADDR_EXP 64
1546: PUSH
1547: LD_INT 0
1549: ST_TO_ADDR
// sPower := false ;
1550: LD_ADDR_EXP 65
1554: PUSH
1555: LD_INT 0
1557: ST_TO_ADDR
// sRandom := false ;
1558: LD_ADDR_EXP 66
1562: PUSH
1563: LD_INT 0
1565: ST_TO_ADDR
// sShield := false ;
1566: LD_ADDR_EXP 67
1570: PUSH
1571: LD_INT 0
1573: ST_TO_ADDR
// sTime := false ;
1574: LD_ADDR_EXP 68
1578: PUSH
1579: LD_INT 0
1581: ST_TO_ADDR
// sTools := false ;
1582: LD_ADDR_EXP 69
1586: PUSH
1587: LD_INT 0
1589: ST_TO_ADDR
// sSold := false ;
1590: LD_ADDR_EXP 34
1594: PUSH
1595: LD_INT 0
1597: ST_TO_ADDR
// sDiff := false ;
1598: LD_ADDR_EXP 35
1602: PUSH
1603: LD_INT 0
1605: ST_TO_ADDR
// sFog := false ;
1606: LD_ADDR_EXP 38
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// sReset := false ;
1614: LD_ADDR_EXP 39
1618: PUSH
1619: LD_INT 0
1621: ST_TO_ADDR
// sSun := false ;
1622: LD_ADDR_EXP 40
1626: PUSH
1627: LD_INT 0
1629: ST_TO_ADDR
// sTiger := false ;
1630: LD_ADDR_EXP 36
1634: PUSH
1635: LD_INT 0
1637: ST_TO_ADDR
// sBomb := false ;
1638: LD_ADDR_EXP 37
1642: PUSH
1643: LD_INT 0
1645: ST_TO_ADDR
// sWound := false ;
1646: LD_ADDR_EXP 45
1650: PUSH
1651: LD_INT 0
1653: ST_TO_ADDR
// sBetray := false ;
1654: LD_ADDR_EXP 49
1658: PUSH
1659: LD_INT 0
1661: ST_TO_ADDR
// sContamin := false ;
1662: LD_ADDR_EXP 50
1666: PUSH
1667: LD_INT 0
1669: ST_TO_ADDR
// sOil := false ;
1670: LD_ADDR_EXP 52
1674: PUSH
1675: LD_INT 0
1677: ST_TO_ADDR
// sStu := false ;
1678: LD_ADDR_EXP 56
1682: PUSH
1683: LD_INT 0
1685: ST_TO_ADDR
// sBazooka := false ;
1686: LD_ADDR_EXP 59
1690: PUSH
1691: LD_INT 0
1693: ST_TO_ADDR
// sMortar := false ;
1694: LD_ADDR_EXP 60
1698: PUSH
1699: LD_INT 0
1701: ST_TO_ADDR
// sRanger := false ;
1702: LD_ADDR_EXP 70
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// end ;
1710: LD_VAR 0 1
1714: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
1715: LD_INT 0
1717: PPUSH
1718: PPUSH
1719: PPUSH
1720: PPUSH
1721: PPUSH
// result := [ ] ;
1722: LD_ADDR_VAR 0 1
1726: PUSH
1727: EMPTY
1728: ST_TO_ADDR
// if campaign_id = 1 then
1729: LD_OWVAR 69
1733: PUSH
1734: LD_INT 1
1736: EQUAL
1737: IFFALSE 4675
// begin case mission_number of 1 :
1739: LD_OWVAR 70
1743: PUSH
1744: LD_INT 1
1746: DOUBLE
1747: EQUAL
1748: IFTRUE 1752
1750: GO 1816
1752: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
1753: LD_ADDR_VAR 0 1
1757: PUSH
1758: LD_INT 2
1760: PUSH
1761: LD_INT 4
1763: PUSH
1764: LD_INT 11
1766: PUSH
1767: LD_INT 12
1769: PUSH
1770: LD_INT 15
1772: PUSH
1773: LD_INT 16
1775: PUSH
1776: LD_INT 22
1778: PUSH
1779: LD_INT 23
1781: PUSH
1782: LD_INT 26
1784: PUSH
1785: EMPTY
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: PUSH
1796: LD_INT 101
1798: PUSH
1799: LD_INT 102
1801: PUSH
1802: LD_INT 106
1804: PUSH
1805: EMPTY
1806: LIST
1807: LIST
1808: LIST
1809: PUSH
1810: EMPTY
1811: LIST
1812: LIST
1813: ST_TO_ADDR
1814: GO 4673
1816: LD_INT 2
1818: DOUBLE
1819: EQUAL
1820: IFTRUE 1824
1822: GO 1896
1824: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
1825: LD_ADDR_VAR 0 1
1829: PUSH
1830: LD_INT 2
1832: PUSH
1833: LD_INT 4
1835: PUSH
1836: LD_INT 11
1838: PUSH
1839: LD_INT 12
1841: PUSH
1842: LD_INT 15
1844: PUSH
1845: LD_INT 16
1847: PUSH
1848: LD_INT 22
1850: PUSH
1851: LD_INT 23
1853: PUSH
1854: LD_INT 26
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: PUSH
1868: LD_INT 101
1870: PUSH
1871: LD_INT 102
1873: PUSH
1874: LD_INT 105
1876: PUSH
1877: LD_INT 106
1879: PUSH
1880: LD_INT 108
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: PUSH
1890: EMPTY
1891: LIST
1892: LIST
1893: ST_TO_ADDR
1894: GO 4673
1896: LD_INT 3
1898: DOUBLE
1899: EQUAL
1900: IFTRUE 1904
1902: GO 1980
1904: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
1905: LD_ADDR_VAR 0 1
1909: PUSH
1910: LD_INT 2
1912: PUSH
1913: LD_INT 4
1915: PUSH
1916: LD_INT 5
1918: PUSH
1919: LD_INT 11
1921: PUSH
1922: LD_INT 12
1924: PUSH
1925: LD_INT 15
1927: PUSH
1928: LD_INT 16
1930: PUSH
1931: LD_INT 22
1933: PUSH
1934: LD_INT 26
1936: PUSH
1937: LD_INT 36
1939: PUSH
1940: EMPTY
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: LIST
1950: LIST
1951: PUSH
1952: LD_INT 101
1954: PUSH
1955: LD_INT 102
1957: PUSH
1958: LD_INT 105
1960: PUSH
1961: LD_INT 106
1963: PUSH
1964: LD_INT 108
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: LIST
1973: PUSH
1974: EMPTY
1975: LIST
1976: LIST
1977: ST_TO_ADDR
1978: GO 4673
1980: LD_INT 4
1982: DOUBLE
1983: EQUAL
1984: IFTRUE 1988
1986: GO 2072
1988: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
1989: LD_ADDR_VAR 0 1
1993: PUSH
1994: LD_INT 2
1996: PUSH
1997: LD_INT 4
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: LD_INT 8
2005: PUSH
2006: LD_INT 11
2008: PUSH
2009: LD_INT 12
2011: PUSH
2012: LD_INT 15
2014: PUSH
2015: LD_INT 16
2017: PUSH
2018: LD_INT 22
2020: PUSH
2021: LD_INT 23
2023: PUSH
2024: LD_INT 26
2026: PUSH
2027: LD_INT 36
2029: PUSH
2030: EMPTY
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: LIST
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: PUSH
2044: LD_INT 101
2046: PUSH
2047: LD_INT 102
2049: PUSH
2050: LD_INT 105
2052: PUSH
2053: LD_INT 106
2055: PUSH
2056: LD_INT 108
2058: PUSH
2059: EMPTY
2060: LIST
2061: LIST
2062: LIST
2063: LIST
2064: LIST
2065: PUSH
2066: EMPTY
2067: LIST
2068: LIST
2069: ST_TO_ADDR
2070: GO 4673
2072: LD_INT 5
2074: DOUBLE
2075: EQUAL
2076: IFTRUE 2080
2078: GO 2180
2080: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
2081: LD_ADDR_VAR 0 1
2085: PUSH
2086: LD_INT 2
2088: PUSH
2089: LD_INT 4
2091: PUSH
2092: LD_INT 5
2094: PUSH
2095: LD_INT 6
2097: PUSH
2098: LD_INT 8
2100: PUSH
2101: LD_INT 11
2103: PUSH
2104: LD_INT 12
2106: PUSH
2107: LD_INT 15
2109: PUSH
2110: LD_INT 16
2112: PUSH
2113: LD_INT 22
2115: PUSH
2116: LD_INT 23
2118: PUSH
2119: LD_INT 25
2121: PUSH
2122: LD_INT 26
2124: PUSH
2125: LD_INT 36
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: LIST
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: LIST
2143: PUSH
2144: LD_INT 101
2146: PUSH
2147: LD_INT 102
2149: PUSH
2150: LD_INT 105
2152: PUSH
2153: LD_INT 106
2155: PUSH
2156: LD_INT 108
2158: PUSH
2159: LD_INT 109
2161: PUSH
2162: LD_INT 112
2164: PUSH
2165: EMPTY
2166: LIST
2167: LIST
2168: LIST
2169: LIST
2170: LIST
2171: LIST
2172: LIST
2173: PUSH
2174: EMPTY
2175: LIST
2176: LIST
2177: ST_TO_ADDR
2178: GO 4673
2180: LD_INT 6
2182: DOUBLE
2183: EQUAL
2184: IFTRUE 2188
2186: GO 2308
2188: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
2189: LD_ADDR_VAR 0 1
2193: PUSH
2194: LD_INT 2
2196: PUSH
2197: LD_INT 4
2199: PUSH
2200: LD_INT 5
2202: PUSH
2203: LD_INT 6
2205: PUSH
2206: LD_INT 8
2208: PUSH
2209: LD_INT 11
2211: PUSH
2212: LD_INT 12
2214: PUSH
2215: LD_INT 15
2217: PUSH
2218: LD_INT 16
2220: PUSH
2221: LD_INT 20
2223: PUSH
2224: LD_INT 21
2226: PUSH
2227: LD_INT 22
2229: PUSH
2230: LD_INT 23
2232: PUSH
2233: LD_INT 25
2235: PUSH
2236: LD_INT 26
2238: PUSH
2239: LD_INT 30
2241: PUSH
2242: LD_INT 31
2244: PUSH
2245: LD_INT 32
2247: PUSH
2248: LD_INT 36
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: LIST
2256: LIST
2257: LIST
2258: LIST
2259: LIST
2260: LIST
2261: LIST
2262: LIST
2263: LIST
2264: LIST
2265: LIST
2266: LIST
2267: LIST
2268: LIST
2269: LIST
2270: LIST
2271: PUSH
2272: LD_INT 101
2274: PUSH
2275: LD_INT 102
2277: PUSH
2278: LD_INT 105
2280: PUSH
2281: LD_INT 106
2283: PUSH
2284: LD_INT 108
2286: PUSH
2287: LD_INT 109
2289: PUSH
2290: LD_INT 112
2292: PUSH
2293: EMPTY
2294: LIST
2295: LIST
2296: LIST
2297: LIST
2298: LIST
2299: LIST
2300: LIST
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: ST_TO_ADDR
2306: GO 4673
2308: LD_INT 7
2310: DOUBLE
2311: EQUAL
2312: IFTRUE 2316
2314: GO 2416
2316: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
2317: LD_ADDR_VAR 0 1
2321: PUSH
2322: LD_INT 2
2324: PUSH
2325: LD_INT 4
2327: PUSH
2328: LD_INT 5
2330: PUSH
2331: LD_INT 7
2333: PUSH
2334: LD_INT 11
2336: PUSH
2337: LD_INT 12
2339: PUSH
2340: LD_INT 15
2342: PUSH
2343: LD_INT 16
2345: PUSH
2346: LD_INT 20
2348: PUSH
2349: LD_INT 21
2351: PUSH
2352: LD_INT 22
2354: PUSH
2355: LD_INT 23
2357: PUSH
2358: LD_INT 25
2360: PUSH
2361: LD_INT 26
2363: PUSH
2364: EMPTY
2365: LIST
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: LIST
2371: LIST
2372: LIST
2373: LIST
2374: LIST
2375: LIST
2376: LIST
2377: LIST
2378: LIST
2379: PUSH
2380: LD_INT 101
2382: PUSH
2383: LD_INT 102
2385: PUSH
2386: LD_INT 103
2388: PUSH
2389: LD_INT 105
2391: PUSH
2392: LD_INT 106
2394: PUSH
2395: LD_INT 108
2397: PUSH
2398: LD_INT 112
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: LIST
2408: LIST
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: ST_TO_ADDR
2414: GO 4673
2416: LD_INT 8
2418: DOUBLE
2419: EQUAL
2420: IFTRUE 2424
2422: GO 2552
2424: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
2425: LD_ADDR_VAR 0 1
2429: PUSH
2430: LD_INT 2
2432: PUSH
2433: LD_INT 4
2435: PUSH
2436: LD_INT 5
2438: PUSH
2439: LD_INT 6
2441: PUSH
2442: LD_INT 7
2444: PUSH
2445: LD_INT 8
2447: PUSH
2448: LD_INT 11
2450: PUSH
2451: LD_INT 12
2453: PUSH
2454: LD_INT 15
2456: PUSH
2457: LD_INT 16
2459: PUSH
2460: LD_INT 20
2462: PUSH
2463: LD_INT 21
2465: PUSH
2466: LD_INT 22
2468: PUSH
2469: LD_INT 23
2471: PUSH
2472: LD_INT 25
2474: PUSH
2475: LD_INT 26
2477: PUSH
2478: LD_INT 30
2480: PUSH
2481: LD_INT 31
2483: PUSH
2484: LD_INT 32
2486: PUSH
2487: LD_INT 36
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: LIST
2494: LIST
2495: LIST
2496: LIST
2497: LIST
2498: LIST
2499: LIST
2500: LIST
2501: LIST
2502: LIST
2503: LIST
2504: LIST
2505: LIST
2506: LIST
2507: LIST
2508: LIST
2509: LIST
2510: LIST
2511: PUSH
2512: LD_INT 101
2514: PUSH
2515: LD_INT 102
2517: PUSH
2518: LD_INT 103
2520: PUSH
2521: LD_INT 105
2523: PUSH
2524: LD_INT 106
2526: PUSH
2527: LD_INT 108
2529: PUSH
2530: LD_INT 109
2532: PUSH
2533: LD_INT 112
2535: PUSH
2536: EMPTY
2537: LIST
2538: LIST
2539: LIST
2540: LIST
2541: LIST
2542: LIST
2543: LIST
2544: LIST
2545: PUSH
2546: EMPTY
2547: LIST
2548: LIST
2549: ST_TO_ADDR
2550: GO 4673
2552: LD_INT 9
2554: DOUBLE
2555: EQUAL
2556: IFTRUE 2560
2558: GO 2696
2560: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
2561: LD_ADDR_VAR 0 1
2565: PUSH
2566: LD_INT 2
2568: PUSH
2569: LD_INT 4
2571: PUSH
2572: LD_INT 5
2574: PUSH
2575: LD_INT 6
2577: PUSH
2578: LD_INT 7
2580: PUSH
2581: LD_INT 8
2583: PUSH
2584: LD_INT 11
2586: PUSH
2587: LD_INT 12
2589: PUSH
2590: LD_INT 15
2592: PUSH
2593: LD_INT 16
2595: PUSH
2596: LD_INT 20
2598: PUSH
2599: LD_INT 21
2601: PUSH
2602: LD_INT 22
2604: PUSH
2605: LD_INT 23
2607: PUSH
2608: LD_INT 25
2610: PUSH
2611: LD_INT 26
2613: PUSH
2614: LD_INT 28
2616: PUSH
2617: LD_INT 30
2619: PUSH
2620: LD_INT 31
2622: PUSH
2623: LD_INT 32
2625: PUSH
2626: LD_INT 36
2628: PUSH
2629: EMPTY
2630: LIST
2631: LIST
2632: LIST
2633: LIST
2634: LIST
2635: LIST
2636: LIST
2637: LIST
2638: LIST
2639: LIST
2640: LIST
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: LIST
2646: LIST
2647: LIST
2648: LIST
2649: LIST
2650: LIST
2651: PUSH
2652: LD_INT 101
2654: PUSH
2655: LD_INT 102
2657: PUSH
2658: LD_INT 103
2660: PUSH
2661: LD_INT 105
2663: PUSH
2664: LD_INT 106
2666: PUSH
2667: LD_INT 108
2669: PUSH
2670: LD_INT 109
2672: PUSH
2673: LD_INT 112
2675: PUSH
2676: LD_INT 114
2678: PUSH
2679: EMPTY
2680: LIST
2681: LIST
2682: LIST
2683: LIST
2684: LIST
2685: LIST
2686: LIST
2687: LIST
2688: LIST
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: ST_TO_ADDR
2694: GO 4673
2696: LD_INT 10
2698: DOUBLE
2699: EQUAL
2700: IFTRUE 2704
2702: GO 2888
2704: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
2705: LD_ADDR_VAR 0 1
2709: PUSH
2710: LD_INT 2
2712: PUSH
2713: LD_INT 4
2715: PUSH
2716: LD_INT 5
2718: PUSH
2719: LD_INT 6
2721: PUSH
2722: LD_INT 7
2724: PUSH
2725: LD_INT 8
2727: PUSH
2728: LD_INT 9
2730: PUSH
2731: LD_INT 10
2733: PUSH
2734: LD_INT 11
2736: PUSH
2737: LD_INT 12
2739: PUSH
2740: LD_INT 13
2742: PUSH
2743: LD_INT 14
2745: PUSH
2746: LD_INT 15
2748: PUSH
2749: LD_INT 16
2751: PUSH
2752: LD_INT 17
2754: PUSH
2755: LD_INT 18
2757: PUSH
2758: LD_INT 19
2760: PUSH
2761: LD_INT 20
2763: PUSH
2764: LD_INT 21
2766: PUSH
2767: LD_INT 22
2769: PUSH
2770: LD_INT 23
2772: PUSH
2773: LD_INT 24
2775: PUSH
2776: LD_INT 25
2778: PUSH
2779: LD_INT 26
2781: PUSH
2782: LD_INT 28
2784: PUSH
2785: LD_INT 30
2787: PUSH
2788: LD_INT 31
2790: PUSH
2791: LD_INT 32
2793: PUSH
2794: LD_INT 36
2796: PUSH
2797: EMPTY
2798: LIST
2799: LIST
2800: LIST
2801: LIST
2802: LIST
2803: LIST
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: LIST
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: LIST
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: LIST
2825: LIST
2826: LIST
2827: PUSH
2828: LD_INT 101
2830: PUSH
2831: LD_INT 102
2833: PUSH
2834: LD_INT 103
2836: PUSH
2837: LD_INT 104
2839: PUSH
2840: LD_INT 105
2842: PUSH
2843: LD_INT 106
2845: PUSH
2846: LD_INT 107
2848: PUSH
2849: LD_INT 108
2851: PUSH
2852: LD_INT 109
2854: PUSH
2855: LD_INT 110
2857: PUSH
2858: LD_INT 111
2860: PUSH
2861: LD_INT 112
2863: PUSH
2864: LD_INT 114
2866: PUSH
2867: EMPTY
2868: LIST
2869: LIST
2870: LIST
2871: LIST
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: LIST
2878: LIST
2879: LIST
2880: LIST
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: ST_TO_ADDR
2886: GO 4673
2888: LD_INT 11
2890: DOUBLE
2891: EQUAL
2892: IFTRUE 2896
2894: GO 3088
2896: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
2897: LD_ADDR_VAR 0 1
2901: PUSH
2902: LD_INT 2
2904: PUSH
2905: LD_INT 3
2907: PUSH
2908: LD_INT 4
2910: PUSH
2911: LD_INT 5
2913: PUSH
2914: LD_INT 6
2916: PUSH
2917: LD_INT 7
2919: PUSH
2920: LD_INT 8
2922: PUSH
2923: LD_INT 9
2925: PUSH
2926: LD_INT 10
2928: PUSH
2929: LD_INT 11
2931: PUSH
2932: LD_INT 12
2934: PUSH
2935: LD_INT 13
2937: PUSH
2938: LD_INT 14
2940: PUSH
2941: LD_INT 15
2943: PUSH
2944: LD_INT 16
2946: PUSH
2947: LD_INT 17
2949: PUSH
2950: LD_INT 18
2952: PUSH
2953: LD_INT 19
2955: PUSH
2956: LD_INT 20
2958: PUSH
2959: LD_INT 21
2961: PUSH
2962: LD_INT 22
2964: PUSH
2965: LD_INT 23
2967: PUSH
2968: LD_INT 24
2970: PUSH
2971: LD_INT 25
2973: PUSH
2974: LD_INT 26
2976: PUSH
2977: LD_INT 28
2979: PUSH
2980: LD_INT 30
2982: PUSH
2983: LD_INT 31
2985: PUSH
2986: LD_INT 32
2988: PUSH
2989: LD_INT 34
2991: PUSH
2992: LD_INT 36
2994: PUSH
2995: EMPTY
2996: LIST
2997: LIST
2998: LIST
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: LIST
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: LIST
3009: LIST
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: LIST
3019: LIST
3020: LIST
3021: LIST
3022: LIST
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_INT 101
3030: PUSH
3031: LD_INT 102
3033: PUSH
3034: LD_INT 103
3036: PUSH
3037: LD_INT 104
3039: PUSH
3040: LD_INT 105
3042: PUSH
3043: LD_INT 106
3045: PUSH
3046: LD_INT 107
3048: PUSH
3049: LD_INT 108
3051: PUSH
3052: LD_INT 109
3054: PUSH
3055: LD_INT 110
3057: PUSH
3058: LD_INT 111
3060: PUSH
3061: LD_INT 112
3063: PUSH
3064: LD_INT 114
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: ST_TO_ADDR
3086: GO 4673
3088: LD_INT 12
3090: DOUBLE
3091: EQUAL
3092: IFTRUE 3096
3094: GO 3304
3096: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
3097: LD_ADDR_VAR 0 1
3101: PUSH
3102: LD_INT 1
3104: PUSH
3105: LD_INT 2
3107: PUSH
3108: LD_INT 3
3110: PUSH
3111: LD_INT 4
3113: PUSH
3114: LD_INT 5
3116: PUSH
3117: LD_INT 6
3119: PUSH
3120: LD_INT 7
3122: PUSH
3123: LD_INT 8
3125: PUSH
3126: LD_INT 9
3128: PUSH
3129: LD_INT 10
3131: PUSH
3132: LD_INT 11
3134: PUSH
3135: LD_INT 12
3137: PUSH
3138: LD_INT 13
3140: PUSH
3141: LD_INT 14
3143: PUSH
3144: LD_INT 15
3146: PUSH
3147: LD_INT 16
3149: PUSH
3150: LD_INT 17
3152: PUSH
3153: LD_INT 18
3155: PUSH
3156: LD_INT 19
3158: PUSH
3159: LD_INT 20
3161: PUSH
3162: LD_INT 21
3164: PUSH
3165: LD_INT 22
3167: PUSH
3168: LD_INT 23
3170: PUSH
3171: LD_INT 24
3173: PUSH
3174: LD_INT 25
3176: PUSH
3177: LD_INT 26
3179: PUSH
3180: LD_INT 27
3182: PUSH
3183: LD_INT 28
3185: PUSH
3186: LD_INT 30
3188: PUSH
3189: LD_INT 31
3191: PUSH
3192: LD_INT 32
3194: PUSH
3195: LD_INT 33
3197: PUSH
3198: LD_INT 34
3200: PUSH
3201: LD_INT 36
3203: PUSH
3204: EMPTY
3205: LIST
3206: LIST
3207: LIST
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: LIST
3238: LIST
3239: PUSH
3240: LD_INT 101
3242: PUSH
3243: LD_INT 102
3245: PUSH
3246: LD_INT 103
3248: PUSH
3249: LD_INT 104
3251: PUSH
3252: LD_INT 105
3254: PUSH
3255: LD_INT 106
3257: PUSH
3258: LD_INT 107
3260: PUSH
3261: LD_INT 108
3263: PUSH
3264: LD_INT 109
3266: PUSH
3267: LD_INT 110
3269: PUSH
3270: LD_INT 111
3272: PUSH
3273: LD_INT 112
3275: PUSH
3276: LD_INT 113
3278: PUSH
3279: LD_INT 114
3281: PUSH
3282: EMPTY
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: LIST
3291: LIST
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PUSH
3298: EMPTY
3299: LIST
3300: LIST
3301: ST_TO_ADDR
3302: GO 4673
3304: LD_INT 13
3306: DOUBLE
3307: EQUAL
3308: IFTRUE 3312
3310: GO 3508
3312: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
3313: LD_ADDR_VAR 0 1
3317: PUSH
3318: LD_INT 1
3320: PUSH
3321: LD_INT 2
3323: PUSH
3324: LD_INT 3
3326: PUSH
3327: LD_INT 4
3329: PUSH
3330: LD_INT 5
3332: PUSH
3333: LD_INT 8
3335: PUSH
3336: LD_INT 9
3338: PUSH
3339: LD_INT 10
3341: PUSH
3342: LD_INT 11
3344: PUSH
3345: LD_INT 12
3347: PUSH
3348: LD_INT 14
3350: PUSH
3351: LD_INT 15
3353: PUSH
3354: LD_INT 16
3356: PUSH
3357: LD_INT 17
3359: PUSH
3360: LD_INT 18
3362: PUSH
3363: LD_INT 19
3365: PUSH
3366: LD_INT 20
3368: PUSH
3369: LD_INT 21
3371: PUSH
3372: LD_INT 22
3374: PUSH
3375: LD_INT 23
3377: PUSH
3378: LD_INT 24
3380: PUSH
3381: LD_INT 25
3383: PUSH
3384: LD_INT 26
3386: PUSH
3387: LD_INT 27
3389: PUSH
3390: LD_INT 28
3392: PUSH
3393: LD_INT 30
3395: PUSH
3396: LD_INT 31
3398: PUSH
3399: LD_INT 32
3401: PUSH
3402: LD_INT 33
3404: PUSH
3405: LD_INT 34
3407: PUSH
3408: LD_INT 36
3410: PUSH
3411: EMPTY
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: LIST
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: LIST
3440: LIST
3441: LIST
3442: LIST
3443: PUSH
3444: LD_INT 101
3446: PUSH
3447: LD_INT 102
3449: PUSH
3450: LD_INT 103
3452: PUSH
3453: LD_INT 104
3455: PUSH
3456: LD_INT 105
3458: PUSH
3459: LD_INT 106
3461: PUSH
3462: LD_INT 107
3464: PUSH
3465: LD_INT 108
3467: PUSH
3468: LD_INT 109
3470: PUSH
3471: LD_INT 110
3473: PUSH
3474: LD_INT 111
3476: PUSH
3477: LD_INT 112
3479: PUSH
3480: LD_INT 113
3482: PUSH
3483: LD_INT 114
3485: PUSH
3486: EMPTY
3487: LIST
3488: LIST
3489: LIST
3490: LIST
3491: LIST
3492: LIST
3493: LIST
3494: LIST
3495: LIST
3496: LIST
3497: LIST
3498: LIST
3499: LIST
3500: LIST
3501: PUSH
3502: EMPTY
3503: LIST
3504: LIST
3505: ST_TO_ADDR
3506: GO 4673
3508: LD_INT 14
3510: DOUBLE
3511: EQUAL
3512: IFTRUE 3516
3514: GO 3728
3516: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
3517: LD_ADDR_VAR 0 1
3521: PUSH
3522: LD_INT 1
3524: PUSH
3525: LD_INT 2
3527: PUSH
3528: LD_INT 3
3530: PUSH
3531: LD_INT 4
3533: PUSH
3534: LD_INT 5
3536: PUSH
3537: LD_INT 6
3539: PUSH
3540: LD_INT 7
3542: PUSH
3543: LD_INT 8
3545: PUSH
3546: LD_INT 9
3548: PUSH
3549: LD_INT 10
3551: PUSH
3552: LD_INT 11
3554: PUSH
3555: LD_INT 12
3557: PUSH
3558: LD_INT 13
3560: PUSH
3561: LD_INT 14
3563: PUSH
3564: LD_INT 15
3566: PUSH
3567: LD_INT 16
3569: PUSH
3570: LD_INT 17
3572: PUSH
3573: LD_INT 18
3575: PUSH
3576: LD_INT 19
3578: PUSH
3579: LD_INT 20
3581: PUSH
3582: LD_INT 21
3584: PUSH
3585: LD_INT 22
3587: PUSH
3588: LD_INT 23
3590: PUSH
3591: LD_INT 24
3593: PUSH
3594: LD_INT 25
3596: PUSH
3597: LD_INT 26
3599: PUSH
3600: LD_INT 27
3602: PUSH
3603: LD_INT 28
3605: PUSH
3606: LD_INT 29
3608: PUSH
3609: LD_INT 30
3611: PUSH
3612: LD_INT 31
3614: PUSH
3615: LD_INT 32
3617: PUSH
3618: LD_INT 33
3620: PUSH
3621: LD_INT 34
3623: PUSH
3624: LD_INT 36
3626: PUSH
3627: EMPTY
3628: LIST
3629: LIST
3630: LIST
3631: LIST
3632: LIST
3633: LIST
3634: LIST
3635: LIST
3636: LIST
3637: LIST
3638: LIST
3639: LIST
3640: LIST
3641: LIST
3642: LIST
3643: LIST
3644: LIST
3645: LIST
3646: LIST
3647: LIST
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: LIST
3653: LIST
3654: LIST
3655: LIST
3656: LIST
3657: LIST
3658: LIST
3659: LIST
3660: LIST
3661: LIST
3662: LIST
3663: PUSH
3664: LD_INT 101
3666: PUSH
3667: LD_INT 102
3669: PUSH
3670: LD_INT 103
3672: PUSH
3673: LD_INT 104
3675: PUSH
3676: LD_INT 105
3678: PUSH
3679: LD_INT 106
3681: PUSH
3682: LD_INT 107
3684: PUSH
3685: LD_INT 108
3687: PUSH
3688: LD_INT 109
3690: PUSH
3691: LD_INT 110
3693: PUSH
3694: LD_INT 111
3696: PUSH
3697: LD_INT 112
3699: PUSH
3700: LD_INT 113
3702: PUSH
3703: LD_INT 114
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: LIST
3710: LIST
3711: LIST
3712: LIST
3713: LIST
3714: LIST
3715: LIST
3716: LIST
3717: LIST
3718: LIST
3719: LIST
3720: LIST
3721: PUSH
3722: EMPTY
3723: LIST
3724: LIST
3725: ST_TO_ADDR
3726: GO 4673
3728: LD_INT 15
3730: DOUBLE
3731: EQUAL
3732: IFTRUE 3736
3734: GO 3948
3736: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
3737: LD_ADDR_VAR 0 1
3741: PUSH
3742: LD_INT 1
3744: PUSH
3745: LD_INT 2
3747: PUSH
3748: LD_INT 3
3750: PUSH
3751: LD_INT 4
3753: PUSH
3754: LD_INT 5
3756: PUSH
3757: LD_INT 6
3759: PUSH
3760: LD_INT 7
3762: PUSH
3763: LD_INT 8
3765: PUSH
3766: LD_INT 9
3768: PUSH
3769: LD_INT 10
3771: PUSH
3772: LD_INT 11
3774: PUSH
3775: LD_INT 12
3777: PUSH
3778: LD_INT 13
3780: PUSH
3781: LD_INT 14
3783: PUSH
3784: LD_INT 15
3786: PUSH
3787: LD_INT 16
3789: PUSH
3790: LD_INT 17
3792: PUSH
3793: LD_INT 18
3795: PUSH
3796: LD_INT 19
3798: PUSH
3799: LD_INT 20
3801: PUSH
3802: LD_INT 21
3804: PUSH
3805: LD_INT 22
3807: PUSH
3808: LD_INT 23
3810: PUSH
3811: LD_INT 24
3813: PUSH
3814: LD_INT 25
3816: PUSH
3817: LD_INT 26
3819: PUSH
3820: LD_INT 27
3822: PUSH
3823: LD_INT 28
3825: PUSH
3826: LD_INT 29
3828: PUSH
3829: LD_INT 30
3831: PUSH
3832: LD_INT 31
3834: PUSH
3835: LD_INT 32
3837: PUSH
3838: LD_INT 33
3840: PUSH
3841: LD_INT 34
3843: PUSH
3844: LD_INT 36
3846: PUSH
3847: EMPTY
3848: LIST
3849: LIST
3850: LIST
3851: LIST
3852: LIST
3853: LIST
3854: LIST
3855: LIST
3856: LIST
3857: LIST
3858: LIST
3859: LIST
3860: LIST
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: LIST
3866: LIST
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: LIST
3879: LIST
3880: LIST
3881: LIST
3882: LIST
3883: PUSH
3884: LD_INT 101
3886: PUSH
3887: LD_INT 102
3889: PUSH
3890: LD_INT 103
3892: PUSH
3893: LD_INT 104
3895: PUSH
3896: LD_INT 105
3898: PUSH
3899: LD_INT 106
3901: PUSH
3902: LD_INT 107
3904: PUSH
3905: LD_INT 108
3907: PUSH
3908: LD_INT 109
3910: PUSH
3911: LD_INT 110
3913: PUSH
3914: LD_INT 111
3916: PUSH
3917: LD_INT 112
3919: PUSH
3920: LD_INT 113
3922: PUSH
3923: LD_INT 114
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: LIST
3930: LIST
3931: LIST
3932: LIST
3933: LIST
3934: LIST
3935: LIST
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: ST_TO_ADDR
3946: GO 4673
3948: LD_INT 16
3950: DOUBLE
3951: EQUAL
3952: IFTRUE 3956
3954: GO 4080
3956: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
3957: LD_ADDR_VAR 0 1
3961: PUSH
3962: LD_INT 2
3964: PUSH
3965: LD_INT 4
3967: PUSH
3968: LD_INT 5
3970: PUSH
3971: LD_INT 7
3973: PUSH
3974: LD_INT 11
3976: PUSH
3977: LD_INT 12
3979: PUSH
3980: LD_INT 15
3982: PUSH
3983: LD_INT 16
3985: PUSH
3986: LD_INT 20
3988: PUSH
3989: LD_INT 21
3991: PUSH
3992: LD_INT 22
3994: PUSH
3995: LD_INT 23
3997: PUSH
3998: LD_INT 25
4000: PUSH
4001: LD_INT 26
4003: PUSH
4004: LD_INT 30
4006: PUSH
4007: LD_INT 31
4009: PUSH
4010: LD_INT 32
4012: PUSH
4013: LD_INT 33
4015: PUSH
4016: LD_INT 34
4018: PUSH
4019: EMPTY
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: LIST
4035: LIST
4036: LIST
4037: LIST
4038: LIST
4039: PUSH
4040: LD_INT 101
4042: PUSH
4043: LD_INT 102
4045: PUSH
4046: LD_INT 103
4048: PUSH
4049: LD_INT 106
4051: PUSH
4052: LD_INT 108
4054: PUSH
4055: LD_INT 112
4057: PUSH
4058: LD_INT 113
4060: PUSH
4061: LD_INT 114
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: LIST
4069: LIST
4070: LIST
4071: LIST
4072: LIST
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: ST_TO_ADDR
4078: GO 4673
4080: LD_INT 17
4082: DOUBLE
4083: EQUAL
4084: IFTRUE 4088
4086: GO 4300
4088: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
4089: LD_ADDR_VAR 0 1
4093: PUSH
4094: LD_INT 1
4096: PUSH
4097: LD_INT 2
4099: PUSH
4100: LD_INT 3
4102: PUSH
4103: LD_INT 4
4105: PUSH
4106: LD_INT 5
4108: PUSH
4109: LD_INT 6
4111: PUSH
4112: LD_INT 7
4114: PUSH
4115: LD_INT 8
4117: PUSH
4118: LD_INT 9
4120: PUSH
4121: LD_INT 10
4123: PUSH
4124: LD_INT 11
4126: PUSH
4127: LD_INT 12
4129: PUSH
4130: LD_INT 13
4132: PUSH
4133: LD_INT 14
4135: PUSH
4136: LD_INT 15
4138: PUSH
4139: LD_INT 16
4141: PUSH
4142: LD_INT 17
4144: PUSH
4145: LD_INT 18
4147: PUSH
4148: LD_INT 19
4150: PUSH
4151: LD_INT 20
4153: PUSH
4154: LD_INT 21
4156: PUSH
4157: LD_INT 22
4159: PUSH
4160: LD_INT 23
4162: PUSH
4163: LD_INT 24
4165: PUSH
4166: LD_INT 25
4168: PUSH
4169: LD_INT 26
4171: PUSH
4172: LD_INT 27
4174: PUSH
4175: LD_INT 28
4177: PUSH
4178: LD_INT 29
4180: PUSH
4181: LD_INT 30
4183: PUSH
4184: LD_INT 31
4186: PUSH
4187: LD_INT 32
4189: PUSH
4190: LD_INT 33
4192: PUSH
4193: LD_INT 34
4195: PUSH
4196: LD_INT 36
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: LIST
4204: LIST
4205: LIST
4206: LIST
4207: LIST
4208: LIST
4209: LIST
4210: LIST
4211: LIST
4212: LIST
4213: LIST
4214: LIST
4215: LIST
4216: LIST
4217: LIST
4218: LIST
4219: LIST
4220: LIST
4221: LIST
4222: LIST
4223: LIST
4224: LIST
4225: LIST
4226: LIST
4227: LIST
4228: LIST
4229: LIST
4230: LIST
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_INT 101
4238: PUSH
4239: LD_INT 102
4241: PUSH
4242: LD_INT 103
4244: PUSH
4245: LD_INT 104
4247: PUSH
4248: LD_INT 105
4250: PUSH
4251: LD_INT 106
4253: PUSH
4254: LD_INT 107
4256: PUSH
4257: LD_INT 108
4259: PUSH
4260: LD_INT 109
4262: PUSH
4263: LD_INT 110
4265: PUSH
4266: LD_INT 111
4268: PUSH
4269: LD_INT 112
4271: PUSH
4272: LD_INT 113
4274: PUSH
4275: LD_INT 114
4277: PUSH
4278: EMPTY
4279: LIST
4280: LIST
4281: LIST
4282: LIST
4283: LIST
4284: LIST
4285: LIST
4286: LIST
4287: LIST
4288: LIST
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: PUSH
4294: EMPTY
4295: LIST
4296: LIST
4297: ST_TO_ADDR
4298: GO 4673
4300: LD_INT 18
4302: DOUBLE
4303: EQUAL
4304: IFTRUE 4308
4306: GO 4444
4308: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
4309: LD_ADDR_VAR 0 1
4313: PUSH
4314: LD_INT 2
4316: PUSH
4317: LD_INT 4
4319: PUSH
4320: LD_INT 5
4322: PUSH
4323: LD_INT 7
4325: PUSH
4326: LD_INT 11
4328: PUSH
4329: LD_INT 12
4331: PUSH
4332: LD_INT 15
4334: PUSH
4335: LD_INT 16
4337: PUSH
4338: LD_INT 20
4340: PUSH
4341: LD_INT 21
4343: PUSH
4344: LD_INT 22
4346: PUSH
4347: LD_INT 23
4349: PUSH
4350: LD_INT 25
4352: PUSH
4353: LD_INT 26
4355: PUSH
4356: LD_INT 30
4358: PUSH
4359: LD_INT 31
4361: PUSH
4362: LD_INT 32
4364: PUSH
4365: LD_INT 33
4367: PUSH
4368: LD_INT 34
4370: PUSH
4371: LD_INT 35
4373: PUSH
4374: LD_INT 36
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: LIST
4381: LIST
4382: LIST
4383: LIST
4384: LIST
4385: LIST
4386: LIST
4387: LIST
4388: LIST
4389: LIST
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_INT 101
4402: PUSH
4403: LD_INT 102
4405: PUSH
4406: LD_INT 103
4408: PUSH
4409: LD_INT 106
4411: PUSH
4412: LD_INT 108
4414: PUSH
4415: LD_INT 112
4417: PUSH
4418: LD_INT 113
4420: PUSH
4421: LD_INT 114
4423: PUSH
4424: LD_INT 115
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: LIST
4431: LIST
4432: LIST
4433: LIST
4434: LIST
4435: LIST
4436: LIST
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: ST_TO_ADDR
4442: GO 4673
4444: LD_INT 19
4446: DOUBLE
4447: EQUAL
4448: IFTRUE 4452
4450: GO 4672
4452: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
4453: LD_ADDR_VAR 0 1
4457: PUSH
4458: LD_INT 1
4460: PUSH
4461: LD_INT 2
4463: PUSH
4464: LD_INT 3
4466: PUSH
4467: LD_INT 4
4469: PUSH
4470: LD_INT 5
4472: PUSH
4473: LD_INT 6
4475: PUSH
4476: LD_INT 7
4478: PUSH
4479: LD_INT 8
4481: PUSH
4482: LD_INT 9
4484: PUSH
4485: LD_INT 10
4487: PUSH
4488: LD_INT 11
4490: PUSH
4491: LD_INT 12
4493: PUSH
4494: LD_INT 13
4496: PUSH
4497: LD_INT 14
4499: PUSH
4500: LD_INT 15
4502: PUSH
4503: LD_INT 16
4505: PUSH
4506: LD_INT 17
4508: PUSH
4509: LD_INT 18
4511: PUSH
4512: LD_INT 19
4514: PUSH
4515: LD_INT 20
4517: PUSH
4518: LD_INT 21
4520: PUSH
4521: LD_INT 22
4523: PUSH
4524: LD_INT 23
4526: PUSH
4527: LD_INT 24
4529: PUSH
4530: LD_INT 25
4532: PUSH
4533: LD_INT 26
4535: PUSH
4536: LD_INT 27
4538: PUSH
4539: LD_INT 28
4541: PUSH
4542: LD_INT 29
4544: PUSH
4545: LD_INT 30
4547: PUSH
4548: LD_INT 31
4550: PUSH
4551: LD_INT 32
4553: PUSH
4554: LD_INT 33
4556: PUSH
4557: LD_INT 34
4559: PUSH
4560: LD_INT 35
4562: PUSH
4563: LD_INT 36
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: LIST
4570: LIST
4571: LIST
4572: LIST
4573: LIST
4574: LIST
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: LIST
4584: LIST
4585: LIST
4586: LIST
4587: LIST
4588: LIST
4589: LIST
4590: LIST
4591: LIST
4592: LIST
4593: LIST
4594: LIST
4595: LIST
4596: LIST
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: LD_INT 101
4606: PUSH
4607: LD_INT 102
4609: PUSH
4610: LD_INT 103
4612: PUSH
4613: LD_INT 104
4615: PUSH
4616: LD_INT 105
4618: PUSH
4619: LD_INT 106
4621: PUSH
4622: LD_INT 107
4624: PUSH
4625: LD_INT 108
4627: PUSH
4628: LD_INT 109
4630: PUSH
4631: LD_INT 110
4633: PUSH
4634: LD_INT 111
4636: PUSH
4637: LD_INT 112
4639: PUSH
4640: LD_INT 113
4642: PUSH
4643: LD_INT 114
4645: PUSH
4646: LD_INT 115
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: LIST
4663: LIST
4664: LIST
4665: PUSH
4666: EMPTY
4667: LIST
4668: LIST
4669: ST_TO_ADDR
4670: GO 4673
4672: POP
// end else
4673: GO 4892
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
4675: LD_ADDR_VAR 0 1
4679: PUSH
4680: LD_INT 1
4682: PUSH
4683: LD_INT 2
4685: PUSH
4686: LD_INT 3
4688: PUSH
4689: LD_INT 4
4691: PUSH
4692: LD_INT 5
4694: PUSH
4695: LD_INT 6
4697: PUSH
4698: LD_INT 7
4700: PUSH
4701: LD_INT 8
4703: PUSH
4704: LD_INT 9
4706: PUSH
4707: LD_INT 10
4709: PUSH
4710: LD_INT 11
4712: PUSH
4713: LD_INT 12
4715: PUSH
4716: LD_INT 13
4718: PUSH
4719: LD_INT 14
4721: PUSH
4722: LD_INT 15
4724: PUSH
4725: LD_INT 16
4727: PUSH
4728: LD_INT 17
4730: PUSH
4731: LD_INT 18
4733: PUSH
4734: LD_INT 19
4736: PUSH
4737: LD_INT 20
4739: PUSH
4740: LD_INT 21
4742: PUSH
4743: LD_INT 22
4745: PUSH
4746: LD_INT 23
4748: PUSH
4749: LD_INT 24
4751: PUSH
4752: LD_INT 25
4754: PUSH
4755: LD_INT 26
4757: PUSH
4758: LD_INT 27
4760: PUSH
4761: LD_INT 28
4763: PUSH
4764: LD_INT 29
4766: PUSH
4767: LD_INT 30
4769: PUSH
4770: LD_INT 31
4772: PUSH
4773: LD_INT 32
4775: PUSH
4776: LD_INT 33
4778: PUSH
4779: LD_INT 34
4781: PUSH
4782: LD_INT 35
4784: PUSH
4785: LD_INT 36
4787: PUSH
4788: EMPTY
4789: LIST
4790: LIST
4791: LIST
4792: LIST
4793: LIST
4794: LIST
4795: LIST
4796: LIST
4797: LIST
4798: LIST
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: LIST
4804: LIST
4805: LIST
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: PUSH
4826: LD_INT 101
4828: PUSH
4829: LD_INT 102
4831: PUSH
4832: LD_INT 103
4834: PUSH
4835: LD_INT 104
4837: PUSH
4838: LD_INT 105
4840: PUSH
4841: LD_INT 106
4843: PUSH
4844: LD_INT 107
4846: PUSH
4847: LD_INT 108
4849: PUSH
4850: LD_INT 109
4852: PUSH
4853: LD_INT 110
4855: PUSH
4856: LD_INT 111
4858: PUSH
4859: LD_INT 112
4861: PUSH
4862: LD_INT 113
4864: PUSH
4865: LD_INT 114
4867: PUSH
4868: LD_INT 115
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: ST_TO_ADDR
// if result then
4892: LD_VAR 0 1
4896: IFFALSE 5185
// begin normal :=  ;
4898: LD_ADDR_VAR 0 3
4902: PUSH
4903: LD_STRING 
4905: ST_TO_ADDR
// hardcore :=  ;
4906: LD_ADDR_VAR 0 4
4910: PUSH
4911: LD_STRING 
4913: ST_TO_ADDR
// for i = 1 to normalCounter do
4914: LD_ADDR_VAR 0 5
4918: PUSH
4919: DOUBLE
4920: LD_INT 1
4922: DEC
4923: ST_TO_ADDR
4924: LD_EXP 18
4928: PUSH
4929: FOR_TO
4930: IFFALSE 5031
// begin tmp := 0 ;
4932: LD_ADDR_VAR 0 2
4936: PUSH
4937: LD_STRING 0
4939: ST_TO_ADDR
// if result [ 1 ] then
4940: LD_VAR 0 1
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: IFFALSE 5013
// if result [ 1 ] [ 1 ] = i then
4950: LD_VAR 0 1
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PUSH
4959: LD_INT 1
4961: ARRAY
4962: PUSH
4963: LD_VAR 0 5
4967: EQUAL
4968: IFFALSE 5013
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
4970: LD_ADDR_VAR 0 1
4974: PUSH
4975: LD_VAR 0 1
4979: PPUSH
4980: LD_INT 1
4982: PPUSH
4983: LD_VAR 0 1
4987: PUSH
4988: LD_INT 1
4990: ARRAY
4991: PPUSH
4992: LD_INT 1
4994: PPUSH
4995: CALL_OW 3
4999: PPUSH
5000: CALL_OW 1
5004: ST_TO_ADDR
// tmp := 1 ;
5005: LD_ADDR_VAR 0 2
5009: PUSH
5010: LD_STRING 1
5012: ST_TO_ADDR
// end ; normal := normal & tmp ;
5013: LD_ADDR_VAR 0 3
5017: PUSH
5018: LD_VAR 0 3
5022: PUSH
5023: LD_VAR 0 2
5027: STR
5028: ST_TO_ADDR
// end ;
5029: GO 4929
5031: POP
5032: POP
// for i = 1 to hardcoreCounter do
5033: LD_ADDR_VAR 0 5
5037: PUSH
5038: DOUBLE
5039: LD_INT 1
5041: DEC
5042: ST_TO_ADDR
5043: LD_EXP 19
5047: PUSH
5048: FOR_TO
5049: IFFALSE 5154
// begin tmp := 0 ;
5051: LD_ADDR_VAR 0 2
5055: PUSH
5056: LD_STRING 0
5058: ST_TO_ADDR
// if result [ 2 ] then
5059: LD_VAR 0 1
5063: PUSH
5064: LD_INT 2
5066: ARRAY
5067: IFFALSE 5136
// if result [ 2 ] [ 1 ] = 100 + i then
5069: LD_VAR 0 1
5073: PUSH
5074: LD_INT 2
5076: ARRAY
5077: PUSH
5078: LD_INT 1
5080: ARRAY
5081: PUSH
5082: LD_INT 100
5084: PUSH
5085: LD_VAR 0 5
5089: PLUS
5090: EQUAL
5091: IFFALSE 5136
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
5093: LD_ADDR_VAR 0 1
5097: PUSH
5098: LD_VAR 0 1
5102: PPUSH
5103: LD_INT 2
5105: PPUSH
5106: LD_VAR 0 1
5110: PUSH
5111: LD_INT 2
5113: ARRAY
5114: PPUSH
5115: LD_INT 1
5117: PPUSH
5118: CALL_OW 3
5122: PPUSH
5123: CALL_OW 1
5127: ST_TO_ADDR
// tmp := 1 ;
5128: LD_ADDR_VAR 0 2
5132: PUSH
5133: LD_STRING 1
5135: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
5136: LD_ADDR_VAR 0 4
5140: PUSH
5141: LD_VAR 0 4
5145: PUSH
5146: LD_VAR 0 2
5150: STR
5151: ST_TO_ADDR
// end ;
5152: GO 5048
5154: POP
5155: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
5156: LD_STRING getStreamItemsFromMission("
5158: PUSH
5159: LD_VAR 0 3
5163: STR
5164: PUSH
5165: LD_STRING ","
5167: STR
5168: PUSH
5169: LD_VAR 0 4
5173: STR
5174: PUSH
5175: LD_STRING ")
5177: STR
5178: PPUSH
5179: CALL_OW 559
// end else
5183: GO 5192
// ToLua ( getStreamItemsFromMission("","") ) ;
5185: LD_STRING getStreamItemsFromMission("","")
5187: PPUSH
5188: CALL_OW 559
// end ;
5192: LD_VAR 0 1
5196: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
5197: LD_EXP 17
5201: PUSH
5202: LD_EXP 22
5206: AND
5207: IFFALSE 5331
5209: GO 5211
5211: DISABLE
5212: LD_INT 0
5214: PPUSH
5215: PPUSH
// begin enable ;
5216: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
5217: LD_ADDR_VAR 0 2
5221: PUSH
5222: LD_INT 22
5224: PUSH
5225: LD_OWVAR 2
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: PUSH
5234: LD_INT 2
5236: PUSH
5237: LD_INT 34
5239: PUSH
5240: LD_INT 7
5242: PUSH
5243: EMPTY
5244: LIST
5245: LIST
5246: PUSH
5247: LD_INT 34
5249: PUSH
5250: LD_INT 45
5252: PUSH
5253: EMPTY
5254: LIST
5255: LIST
5256: PUSH
5257: LD_INT 34
5259: PUSH
5260: LD_INT 28
5262: PUSH
5263: EMPTY
5264: LIST
5265: LIST
5266: PUSH
5267: LD_INT 34
5269: PUSH
5270: LD_INT 47
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: LIST
5281: LIST
5282: LIST
5283: PUSH
5284: EMPTY
5285: LIST
5286: LIST
5287: PPUSH
5288: CALL_OW 69
5292: ST_TO_ADDR
// if not tmp then
5293: LD_VAR 0 2
5297: NOT
5298: IFFALSE 5302
// exit ;
5300: GO 5331
// for i in tmp do
5302: LD_ADDR_VAR 0 1
5306: PUSH
5307: LD_VAR 0 2
5311: PUSH
5312: FOR_IN
5313: IFFALSE 5329
// begin SetLives ( i , 0 ) ;
5315: LD_VAR 0 1
5319: PPUSH
5320: LD_INT 0
5322: PPUSH
5323: CALL_OW 234
// end ;
5327: GO 5312
5329: POP
5330: POP
// end ;
5331: PPOPN 2
5333: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
5334: LD_EXP 17
5338: PUSH
5339: LD_EXP 23
5343: AND
5344: IFFALSE 5428
5346: GO 5348
5348: DISABLE
5349: LD_INT 0
5351: PPUSH
5352: PPUSH
// begin enable ;
5353: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
5354: LD_ADDR_VAR 0 2
5358: PUSH
5359: LD_INT 22
5361: PUSH
5362: LD_OWVAR 2
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: PUSH
5371: LD_INT 32
5373: PUSH
5374: LD_INT 3
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 69
5389: ST_TO_ADDR
// if not tmp then
5390: LD_VAR 0 2
5394: NOT
5395: IFFALSE 5399
// exit ;
5397: GO 5428
// for i in tmp do
5399: LD_ADDR_VAR 0 1
5403: PUSH
5404: LD_VAR 0 2
5408: PUSH
5409: FOR_IN
5410: IFFALSE 5426
// begin SetLives ( i , 0 ) ;
5412: LD_VAR 0 1
5416: PPUSH
5417: LD_INT 0
5419: PPUSH
5420: CALL_OW 234
// end ;
5424: GO 5409
5426: POP
5427: POP
// end ;
5428: PPOPN 2
5430: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
5431: LD_EXP 17
5435: PUSH
5436: LD_EXP 20
5440: AND
5441: IFFALSE 5534
5443: GO 5445
5445: DISABLE
5446: LD_INT 0
5448: PPUSH
// begin enable ;
5449: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
5450: LD_ADDR_VAR 0 1
5454: PUSH
5455: LD_INT 22
5457: PUSH
5458: LD_OWVAR 2
5462: PUSH
5463: EMPTY
5464: LIST
5465: LIST
5466: PUSH
5467: LD_INT 2
5469: PUSH
5470: LD_INT 25
5472: PUSH
5473: LD_INT 5
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 25
5482: PUSH
5483: LD_INT 9
5485: PUSH
5486: EMPTY
5487: LIST
5488: LIST
5489: PUSH
5490: LD_INT 25
5492: PUSH
5493: LD_INT 8
5495: PUSH
5496: EMPTY
5497: LIST
5498: LIST
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: LIST
5504: LIST
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PPUSH
5510: CALL_OW 69
5514: PUSH
5515: FOR_IN
5516: IFFALSE 5532
// begin SetClass ( i , 1 ) ;
5518: LD_VAR 0 1
5522: PPUSH
5523: LD_INT 1
5525: PPUSH
5526: CALL_OW 336
// end ;
5530: GO 5515
5532: POP
5533: POP
// end ;
5534: PPOPN 1
5536: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
5537: LD_EXP 17
5541: PUSH
5542: LD_EXP 21
5546: AND
5547: PUSH
5548: LD_OWVAR 65
5552: PUSH
5553: LD_INT 7
5555: LESS
5556: AND
5557: IFFALSE 5571
5559: GO 5561
5561: DISABLE
// begin enable ;
5562: ENABLE
// game_speed := 7 ;
5563: LD_ADDR_OWVAR 65
5567: PUSH
5568: LD_INT 7
5570: ST_TO_ADDR
// end ;
5571: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
5572: LD_EXP 17
5576: PUSH
5577: LD_EXP 24
5581: AND
5582: IFFALSE 5784
5584: GO 5586
5586: DISABLE
5587: LD_INT 0
5589: PPUSH
5590: PPUSH
5591: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
5592: LD_ADDR_VAR 0 3
5596: PUSH
5597: LD_INT 81
5599: PUSH
5600: LD_OWVAR 2
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: LD_INT 21
5611: PUSH
5612: LD_INT 1
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: PPUSH
5623: CALL_OW 69
5627: ST_TO_ADDR
// if not tmp then
5628: LD_VAR 0 3
5632: NOT
5633: IFFALSE 5637
// exit ;
5635: GO 5784
// if tmp > 5 then
5637: LD_VAR 0 3
5641: PUSH
5642: LD_INT 5
5644: GREATER
5645: IFFALSE 5657
// k := 5 else
5647: LD_ADDR_VAR 0 2
5651: PUSH
5652: LD_INT 5
5654: ST_TO_ADDR
5655: GO 5667
// k := tmp ;
5657: LD_ADDR_VAR 0 2
5661: PUSH
5662: LD_VAR 0 3
5666: ST_TO_ADDR
// for i := 1 to k do
5667: LD_ADDR_VAR 0 1
5671: PUSH
5672: DOUBLE
5673: LD_INT 1
5675: DEC
5676: ST_TO_ADDR
5677: LD_VAR 0 2
5681: PUSH
5682: FOR_TO
5683: IFFALSE 5782
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
5685: LD_VAR 0 3
5689: PUSH
5690: LD_VAR 0 1
5694: ARRAY
5695: PPUSH
5696: LD_VAR 0 1
5700: PUSH
5701: LD_INT 4
5703: MOD
5704: PUSH
5705: LD_INT 1
5707: PLUS
5708: PPUSH
5709: CALL_OW 259
5713: PUSH
5714: LD_INT 10
5716: LESS
5717: IFFALSE 5780
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
5719: LD_VAR 0 3
5723: PUSH
5724: LD_VAR 0 1
5728: ARRAY
5729: PPUSH
5730: LD_VAR 0 1
5734: PUSH
5735: LD_INT 4
5737: MOD
5738: PUSH
5739: LD_INT 1
5741: PLUS
5742: PPUSH
5743: LD_VAR 0 3
5747: PUSH
5748: LD_VAR 0 1
5752: ARRAY
5753: PPUSH
5754: LD_VAR 0 1
5758: PUSH
5759: LD_INT 4
5761: MOD
5762: PUSH
5763: LD_INT 1
5765: PLUS
5766: PPUSH
5767: CALL_OW 259
5771: PUSH
5772: LD_INT 1
5774: PLUS
5775: PPUSH
5776: CALL_OW 237
5780: GO 5682
5782: POP
5783: POP
// end ;
5784: PPOPN 3
5786: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
5787: LD_EXP 17
5791: PUSH
5792: LD_EXP 25
5796: AND
5797: IFFALSE 5817
5799: GO 5801
5801: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
5802: LD_INT 4
5804: PPUSH
5805: LD_OWVAR 2
5809: PPUSH
5810: LD_INT 0
5812: PPUSH
5813: CALL_OW 324
5817: END
// every 0 0$1 trigger StreamModeActive and sShovel do
5818: LD_EXP 17
5822: PUSH
5823: LD_EXP 54
5827: AND
5828: IFFALSE 5848
5830: GO 5832
5832: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
5833: LD_INT 19
5835: PPUSH
5836: LD_OWVAR 2
5840: PPUSH
5841: LD_INT 0
5843: PPUSH
5844: CALL_OW 324
5848: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
5849: LD_EXP 17
5853: PUSH
5854: LD_EXP 26
5858: AND
5859: IFFALSE 5961
5861: GO 5863
5863: DISABLE
5864: LD_INT 0
5866: PPUSH
5867: PPUSH
// begin enable ;
5868: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
5869: LD_ADDR_VAR 0 2
5873: PUSH
5874: LD_INT 22
5876: PUSH
5877: LD_OWVAR 2
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: PUSH
5886: LD_INT 2
5888: PUSH
5889: LD_INT 34
5891: PUSH
5892: LD_INT 11
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 34
5901: PUSH
5902: LD_INT 30
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PUSH
5909: EMPTY
5910: LIST
5911: LIST
5912: LIST
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PPUSH
5918: CALL_OW 69
5922: ST_TO_ADDR
// if not tmp then
5923: LD_VAR 0 2
5927: NOT
5928: IFFALSE 5932
// exit ;
5930: GO 5961
// for i in tmp do
5932: LD_ADDR_VAR 0 1
5936: PUSH
5937: LD_VAR 0 2
5941: PUSH
5942: FOR_IN
5943: IFFALSE 5959
// begin SetLives ( i , 0 ) ;
5945: LD_VAR 0 1
5949: PPUSH
5950: LD_INT 0
5952: PPUSH
5953: CALL_OW 234
// end ;
5957: GO 5942
5959: POP
5960: POP
// end ;
5961: PPOPN 2
5963: END
// every 0 0$1 trigger StreamModeActive and sBunker do
5964: LD_EXP 17
5968: PUSH
5969: LD_EXP 27
5973: AND
5974: IFFALSE 5994
5976: GO 5978
5978: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
5979: LD_INT 32
5981: PPUSH
5982: LD_OWVAR 2
5986: PPUSH
5987: LD_INT 0
5989: PPUSH
5990: CALL_OW 324
5994: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
5995: LD_EXP 17
5999: PUSH
6000: LD_EXP 28
6004: AND
6005: IFFALSE 6186
6007: GO 6009
6009: DISABLE
6010: LD_INT 0
6012: PPUSH
6013: PPUSH
6014: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
6015: LD_ADDR_VAR 0 2
6019: PUSH
6020: LD_INT 22
6022: PUSH
6023: LD_OWVAR 2
6027: PUSH
6028: EMPTY
6029: LIST
6030: LIST
6031: PUSH
6032: LD_INT 33
6034: PUSH
6035: LD_INT 3
6037: PUSH
6038: EMPTY
6039: LIST
6040: LIST
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: PPUSH
6046: CALL_OW 69
6050: ST_TO_ADDR
// if not tmp then
6051: LD_VAR 0 2
6055: NOT
6056: IFFALSE 6060
// exit ;
6058: GO 6186
// side := 0 ;
6060: LD_ADDR_VAR 0 3
6064: PUSH
6065: LD_INT 0
6067: ST_TO_ADDR
// for i := 1 to 8 do
6068: LD_ADDR_VAR 0 1
6072: PUSH
6073: DOUBLE
6074: LD_INT 1
6076: DEC
6077: ST_TO_ADDR
6078: LD_INT 8
6080: PUSH
6081: FOR_TO
6082: IFFALSE 6130
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
6084: LD_OWVAR 2
6088: PUSH
6089: LD_VAR 0 1
6093: NONEQUAL
6094: PUSH
6095: LD_OWVAR 2
6099: PPUSH
6100: LD_VAR 0 1
6104: PPUSH
6105: CALL_OW 81
6109: PUSH
6110: LD_INT 2
6112: EQUAL
6113: AND
6114: IFFALSE 6128
// begin side := i ;
6116: LD_ADDR_VAR 0 3
6120: PUSH
6121: LD_VAR 0 1
6125: ST_TO_ADDR
// break ;
6126: GO 6130
// end ;
6128: GO 6081
6130: POP
6131: POP
// if not side then
6132: LD_VAR 0 3
6136: NOT
6137: IFFALSE 6141
// exit ;
6139: GO 6186
// for i := 1 to tmp do
6141: LD_ADDR_VAR 0 1
6145: PUSH
6146: DOUBLE
6147: LD_INT 1
6149: DEC
6150: ST_TO_ADDR
6151: LD_VAR 0 2
6155: PUSH
6156: FOR_TO
6157: IFFALSE 6184
// if Prob ( 60 ) then
6159: LD_INT 60
6161: PPUSH
6162: CALL_OW 13
6166: IFFALSE 6182
// SetSide ( i , side ) ;
6168: LD_VAR 0 1
6172: PPUSH
6173: LD_VAR 0 3
6177: PPUSH
6178: CALL_OW 235
6182: GO 6156
6184: POP
6185: POP
// end ;
6186: PPOPN 3
6188: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
6189: LD_EXP 17
6193: PUSH
6194: LD_EXP 30
6198: AND
6199: IFFALSE 6318
6201: GO 6203
6203: DISABLE
6204: LD_INT 0
6206: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
6207: LD_ADDR_VAR 0 1
6211: PUSH
6212: LD_INT 22
6214: PUSH
6215: LD_OWVAR 2
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: PUSH
6224: LD_INT 21
6226: PUSH
6227: LD_INT 1
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 3
6236: PUSH
6237: LD_INT 23
6239: PUSH
6240: LD_INT 0
6242: PUSH
6243: EMPTY
6244: LIST
6245: LIST
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: LIST
6255: PPUSH
6256: CALL_OW 69
6260: PUSH
6261: FOR_IN
6262: IFFALSE 6316
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
6264: LD_VAR 0 1
6268: PPUSH
6269: CALL_OW 257
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: LD_INT 2
6279: PUSH
6280: LD_INT 3
6282: PUSH
6283: LD_INT 4
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: LIST
6290: LIST
6291: IN
6292: IFFALSE 6314
// SetClass ( un , rand ( 1 , 4 ) ) ;
6294: LD_VAR 0 1
6298: PPUSH
6299: LD_INT 1
6301: PPUSH
6302: LD_INT 4
6304: PPUSH
6305: CALL_OW 12
6309: PPUSH
6310: CALL_OW 336
6314: GO 6261
6316: POP
6317: POP
// end ;
6318: PPOPN 1
6320: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
6321: LD_EXP 17
6325: PUSH
6326: LD_EXP 29
6330: AND
6331: IFFALSE 6410
6333: GO 6335
6335: DISABLE
6336: LD_INT 0
6338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6339: LD_ADDR_VAR 0 1
6343: PUSH
6344: LD_INT 22
6346: PUSH
6347: LD_OWVAR 2
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: PUSH
6356: LD_INT 21
6358: PUSH
6359: LD_INT 3
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: PPUSH
6370: CALL_OW 69
6374: ST_TO_ADDR
// if not tmp then
6375: LD_VAR 0 1
6379: NOT
6380: IFFALSE 6384
// exit ;
6382: GO 6410
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
6384: LD_VAR 0 1
6388: PUSH
6389: LD_INT 1
6391: PPUSH
6392: LD_VAR 0 1
6396: PPUSH
6397: CALL_OW 12
6401: ARRAY
6402: PPUSH
6403: LD_INT 100
6405: PPUSH
6406: CALL_OW 234
// end ;
6410: PPOPN 1
6412: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
6413: LD_EXP 17
6417: PUSH
6418: LD_EXP 31
6422: AND
6423: IFFALSE 6521
6425: GO 6427
6427: DISABLE
6428: LD_INT 0
6430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
6431: LD_ADDR_VAR 0 1
6435: PUSH
6436: LD_INT 22
6438: PUSH
6439: LD_OWVAR 2
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: PUSH
6448: LD_INT 21
6450: PUSH
6451: LD_INT 1
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: PPUSH
6462: CALL_OW 69
6466: ST_TO_ADDR
// if not tmp then
6467: LD_VAR 0 1
6471: NOT
6472: IFFALSE 6476
// exit ;
6474: GO 6521
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
6476: LD_VAR 0 1
6480: PUSH
6481: LD_INT 1
6483: PPUSH
6484: LD_VAR 0 1
6488: PPUSH
6489: CALL_OW 12
6493: ARRAY
6494: PPUSH
6495: LD_INT 1
6497: PPUSH
6498: LD_INT 4
6500: PPUSH
6501: CALL_OW 12
6505: PPUSH
6506: LD_INT 3000
6508: PPUSH
6509: LD_INT 9000
6511: PPUSH
6512: CALL_OW 12
6516: PPUSH
6517: CALL_OW 492
// end ;
6521: PPOPN 1
6523: END
// every 0 0$1 trigger StreamModeActive and sDepot do
6524: LD_EXP 17
6528: PUSH
6529: LD_EXP 32
6533: AND
6534: IFFALSE 6554
6536: GO 6538
6538: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
6539: LD_INT 1
6541: PPUSH
6542: LD_OWVAR 2
6546: PPUSH
6547: LD_INT 0
6549: PPUSH
6550: CALL_OW 324
6554: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
6555: LD_EXP 17
6559: PUSH
6560: LD_EXP 33
6564: AND
6565: IFFALSE 6648
6567: GO 6569
6569: DISABLE
6570: LD_INT 0
6572: PPUSH
6573: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6574: LD_ADDR_VAR 0 2
6578: PUSH
6579: LD_INT 22
6581: PUSH
6582: LD_OWVAR 2
6586: PUSH
6587: EMPTY
6588: LIST
6589: LIST
6590: PUSH
6591: LD_INT 21
6593: PUSH
6594: LD_INT 3
6596: PUSH
6597: EMPTY
6598: LIST
6599: LIST
6600: PUSH
6601: EMPTY
6602: LIST
6603: LIST
6604: PPUSH
6605: CALL_OW 69
6609: ST_TO_ADDR
// if not tmp then
6610: LD_VAR 0 2
6614: NOT
6615: IFFALSE 6619
// exit ;
6617: GO 6648
// for i in tmp do
6619: LD_ADDR_VAR 0 1
6623: PUSH
6624: LD_VAR 0 2
6628: PUSH
6629: FOR_IN
6630: IFFALSE 6646
// SetBLevel ( i , 10 ) ;
6632: LD_VAR 0 1
6636: PPUSH
6637: LD_INT 10
6639: PPUSH
6640: CALL_OW 241
6644: GO 6629
6646: POP
6647: POP
// end ;
6648: PPOPN 2
6650: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
6651: LD_EXP 17
6655: PUSH
6656: LD_EXP 34
6660: AND
6661: IFFALSE 6772
6663: GO 6665
6665: DISABLE
6666: LD_INT 0
6668: PPUSH
6669: PPUSH
6670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
6671: LD_ADDR_VAR 0 3
6675: PUSH
6676: LD_INT 22
6678: PUSH
6679: LD_OWVAR 2
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: PUSH
6688: LD_INT 25
6690: PUSH
6691: LD_INT 1
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 69
6706: ST_TO_ADDR
// if not tmp then
6707: LD_VAR 0 3
6711: NOT
6712: IFFALSE 6716
// exit ;
6714: GO 6772
// un := tmp [ rand ( 1 , tmp ) ] ;
6716: LD_ADDR_VAR 0 2
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 1
6728: PPUSH
6729: LD_VAR 0 3
6733: PPUSH
6734: CALL_OW 12
6738: ARRAY
6739: ST_TO_ADDR
// if Crawls ( un ) then
6740: LD_VAR 0 2
6744: PPUSH
6745: CALL_OW 318
6749: IFFALSE 6760
// ComWalk ( un ) ;
6751: LD_VAR 0 2
6755: PPUSH
6756: CALL_OW 138
// SetClass ( un , class_sniper ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 5
6767: PPUSH
6768: CALL_OW 336
// end ;
6772: PPOPN 3
6774: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
6775: LD_EXP 17
6779: PUSH
6780: LD_EXP 35
6784: AND
6785: PUSH
6786: LD_OWVAR 67
6790: PUSH
6791: LD_INT 3
6793: LESS
6794: AND
6795: IFFALSE 6814
6797: GO 6799
6799: DISABLE
// Difficulty := Difficulty + 1 ;
6800: LD_ADDR_OWVAR 67
6804: PUSH
6805: LD_OWVAR 67
6809: PUSH
6810: LD_INT 1
6812: PLUS
6813: ST_TO_ADDR
6814: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
6815: LD_EXP 17
6819: PUSH
6820: LD_EXP 36
6824: AND
6825: IFFALSE 6928
6827: GO 6829
6829: DISABLE
6830: LD_INT 0
6832: PPUSH
// begin for i := 1 to 5 do
6833: LD_ADDR_VAR 0 1
6837: PUSH
6838: DOUBLE
6839: LD_INT 1
6841: DEC
6842: ST_TO_ADDR
6843: LD_INT 5
6845: PUSH
6846: FOR_TO
6847: IFFALSE 6926
// begin uc_nation := nation_nature ;
6849: LD_ADDR_OWVAR 21
6853: PUSH
6854: LD_INT 0
6856: ST_TO_ADDR
// uc_side := 0 ;
6857: LD_ADDR_OWVAR 20
6861: PUSH
6862: LD_INT 0
6864: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
6865: LD_ADDR_OWVAR 29
6869: PUSH
6870: LD_INT 12
6872: PUSH
6873: LD_INT 12
6875: PUSH
6876: EMPTY
6877: LIST
6878: LIST
6879: ST_TO_ADDR
// hc_agressivity := 20 ;
6880: LD_ADDR_OWVAR 35
6884: PUSH
6885: LD_INT 20
6887: ST_TO_ADDR
// hc_class := class_tiger ;
6888: LD_ADDR_OWVAR 28
6892: PUSH
6893: LD_INT 14
6895: ST_TO_ADDR
// hc_gallery :=  ;
6896: LD_ADDR_OWVAR 33
6900: PUSH
6901: LD_STRING 
6903: ST_TO_ADDR
// hc_name :=  ;
6904: LD_ADDR_OWVAR 26
6908: PUSH
6909: LD_STRING 
6911: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
6912: CALL_OW 44
6916: PPUSH
6917: LD_INT 0
6919: PPUSH
6920: CALL_OW 51
// end ;
6924: GO 6846
6926: POP
6927: POP
// end ;
6928: PPOPN 1
6930: END
// every 0 0$1 trigger StreamModeActive and sBomb do
6931: LD_EXP 17
6935: PUSH
6936: LD_EXP 37
6940: AND
6941: IFFALSE 6950
6943: GO 6945
6945: DISABLE
// StreamSibBomb ;
6946: CALL 6951 0 0
6950: END
// export function StreamSibBomb ; var i , x , y ; begin
6951: LD_INT 0
6953: PPUSH
6954: PPUSH
6955: PPUSH
6956: PPUSH
// result := false ;
6957: LD_ADDR_VAR 0 1
6961: PUSH
6962: LD_INT 0
6964: ST_TO_ADDR
// for i := 1 to 16 do
6965: LD_ADDR_VAR 0 2
6969: PUSH
6970: DOUBLE
6971: LD_INT 1
6973: DEC
6974: ST_TO_ADDR
6975: LD_INT 16
6977: PUSH
6978: FOR_TO
6979: IFFALSE 7178
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
6981: LD_ADDR_VAR 0 3
6985: PUSH
6986: LD_INT 10
6988: PUSH
6989: LD_INT 20
6991: PUSH
6992: LD_INT 30
6994: PUSH
6995: LD_INT 40
6997: PUSH
6998: LD_INT 50
7000: PUSH
7001: LD_INT 60
7003: PUSH
7004: LD_INT 70
7006: PUSH
7007: LD_INT 80
7009: PUSH
7010: LD_INT 90
7012: PUSH
7013: LD_INT 100
7015: PUSH
7016: LD_INT 110
7018: PUSH
7019: LD_INT 120
7021: PUSH
7022: LD_INT 130
7024: PUSH
7025: LD_INT 140
7027: PUSH
7028: LD_INT 150
7030: PUSH
7031: EMPTY
7032: LIST
7033: LIST
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: LIST
7040: LIST
7041: LIST
7042: LIST
7043: LIST
7044: LIST
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 1
7050: PPUSH
7051: LD_INT 15
7053: PPUSH
7054: CALL_OW 12
7058: ARRAY
7059: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
7060: LD_ADDR_VAR 0 4
7064: PUSH
7065: LD_INT 10
7067: PUSH
7068: LD_INT 20
7070: PUSH
7071: LD_INT 30
7073: PUSH
7074: LD_INT 40
7076: PUSH
7077: LD_INT 50
7079: PUSH
7080: LD_INT 60
7082: PUSH
7083: LD_INT 70
7085: PUSH
7086: LD_INT 80
7088: PUSH
7089: LD_INT 90
7091: PUSH
7092: LD_INT 100
7094: PUSH
7095: LD_INT 110
7097: PUSH
7098: LD_INT 120
7100: PUSH
7101: LD_INT 130
7103: PUSH
7104: LD_INT 140
7106: PUSH
7107: LD_INT 150
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: LIST
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: LIST
7125: LIST
7126: PUSH
7127: LD_INT 1
7129: PPUSH
7130: LD_INT 15
7132: PPUSH
7133: CALL_OW 12
7137: ARRAY
7138: ST_TO_ADDR
// if ValidHex ( x , y ) then
7139: LD_VAR 0 3
7143: PPUSH
7144: LD_VAR 0 4
7148: PPUSH
7149: CALL_OW 488
7153: IFFALSE 7176
// begin result := [ x , y ] ;
7155: LD_ADDR_VAR 0 1
7159: PUSH
7160: LD_VAR 0 3
7164: PUSH
7165: LD_VAR 0 4
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: ST_TO_ADDR
// break ;
7174: GO 7178
// end ; end ;
7176: GO 6978
7178: POP
7179: POP
// if result then
7180: LD_VAR 0 1
7184: IFFALSE 7244
// begin ToLua ( playSibBomb() ) ;
7186: LD_STRING playSibBomb()
7188: PPUSH
7189: CALL_OW 559
// wait ( 0 0$14 ) ;
7193: LD_INT 490
7195: PPUSH
7196: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
7200: LD_VAR 0 1
7204: PUSH
7205: LD_INT 1
7207: ARRAY
7208: PPUSH
7209: LD_VAR 0 1
7213: PUSH
7214: LD_INT 2
7216: ARRAY
7217: PPUSH
7218: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
7222: LD_VAR 0 1
7226: PUSH
7227: LD_INT 1
7229: ARRAY
7230: PPUSH
7231: LD_VAR 0 1
7235: PUSH
7236: LD_INT 2
7238: ARRAY
7239: PPUSH
7240: CALL_OW 429
// end ; end ;
7244: LD_VAR 0 1
7248: RET
// every 0 0$1 trigger StreamModeActive and sReset do
7249: LD_EXP 17
7253: PUSH
7254: LD_EXP 39
7258: AND
7259: IFFALSE 7271
7261: GO 7263
7263: DISABLE
// YouLost (  ) ;
7264: LD_STRING 
7266: PPUSH
7267: CALL_OW 104
7271: END
// every 0 0$1 trigger StreamModeActive and sFog do
7272: LD_EXP 17
7276: PUSH
7277: LD_EXP 38
7281: AND
7282: IFFALSE 7296
7284: GO 7286
7286: DISABLE
// FogOff ( your_side ) ;
7287: LD_OWVAR 2
7291: PPUSH
7292: CALL_OW 344
7296: END
// every 0 0$1 trigger StreamModeActive and sSun do
7297: LD_EXP 17
7301: PUSH
7302: LD_EXP 40
7306: AND
7307: IFFALSE 7335
7309: GO 7311
7311: DISABLE
// begin solar_recharge_percent := 0 ;
7312: LD_ADDR_OWVAR 79
7316: PUSH
7317: LD_INT 0
7319: ST_TO_ADDR
// wait ( 5 5$00 ) ;
7320: LD_INT 10500
7322: PPUSH
7323: CALL_OW 67
// solar_recharge_percent := 100 ;
7327: LD_ADDR_OWVAR 79
7331: PUSH
7332: LD_INT 100
7334: ST_TO_ADDR
// end ;
7335: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
7336: LD_EXP 17
7340: PUSH
7341: LD_EXP 41
7345: AND
7346: IFFALSE 7585
7348: GO 7350
7350: DISABLE
7351: LD_INT 0
7353: PPUSH
7354: PPUSH
7355: PPUSH
// begin tmp := [ ] ;
7356: LD_ADDR_VAR 0 3
7360: PUSH
7361: EMPTY
7362: ST_TO_ADDR
// for i := 1 to 6 do
7363: LD_ADDR_VAR 0 1
7367: PUSH
7368: DOUBLE
7369: LD_INT 1
7371: DEC
7372: ST_TO_ADDR
7373: LD_INT 6
7375: PUSH
7376: FOR_TO
7377: IFFALSE 7482
// begin uc_nation := nation_nature ;
7379: LD_ADDR_OWVAR 21
7383: PUSH
7384: LD_INT 0
7386: ST_TO_ADDR
// uc_side := 0 ;
7387: LD_ADDR_OWVAR 20
7391: PUSH
7392: LD_INT 0
7394: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7395: LD_ADDR_OWVAR 29
7399: PUSH
7400: LD_INT 12
7402: PUSH
7403: LD_INT 12
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: ST_TO_ADDR
// hc_agressivity := 20 ;
7410: LD_ADDR_OWVAR 35
7414: PUSH
7415: LD_INT 20
7417: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
7418: LD_ADDR_OWVAR 28
7422: PUSH
7423: LD_INT 17
7425: ST_TO_ADDR
// hc_gallery :=  ;
7426: LD_ADDR_OWVAR 33
7430: PUSH
7431: LD_STRING 
7433: ST_TO_ADDR
// hc_name :=  ;
7434: LD_ADDR_OWVAR 26
7438: PUSH
7439: LD_STRING 
7441: ST_TO_ADDR
// un := CreateHuman ;
7442: LD_ADDR_VAR 0 2
7446: PUSH
7447: CALL_OW 44
7451: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
7452: LD_VAR 0 2
7456: PPUSH
7457: LD_INT 1
7459: PPUSH
7460: CALL_OW 51
// tmp := tmp ^ un ;
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: LD_VAR 0 3
7473: PUSH
7474: LD_VAR 0 2
7478: ADD
7479: ST_TO_ADDR
// end ;
7480: GO 7376
7482: POP
7483: POP
// repeat wait ( 0 0$1 ) ;
7484: LD_INT 35
7486: PPUSH
7487: CALL_OW 67
// for un in tmp do
7491: LD_ADDR_VAR 0 2
7495: PUSH
7496: LD_VAR 0 3
7500: PUSH
7501: FOR_IN
7502: IFFALSE 7576
// begin if IsDead ( un ) then
7504: LD_VAR 0 2
7508: PPUSH
7509: CALL_OW 301
7513: IFFALSE 7533
// begin tmp := tmp diff un ;
7515: LD_ADDR_VAR 0 3
7519: PUSH
7520: LD_VAR 0 3
7524: PUSH
7525: LD_VAR 0 2
7529: DIFF
7530: ST_TO_ADDR
// continue ;
7531: GO 7501
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
7533: LD_VAR 0 2
7537: PPUSH
7538: LD_INT 3
7540: PUSH
7541: LD_INT 22
7543: PUSH
7544: LD_INT 0
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PPUSH
7555: CALL_OW 69
7559: PPUSH
7560: LD_VAR 0 2
7564: PPUSH
7565: CALL_OW 74
7569: PPUSH
7570: CALL_OW 115
// end ;
7574: GO 7501
7576: POP
7577: POP
// until not tmp ;
7578: LD_VAR 0 3
7582: NOT
7583: IFFALSE 7484
// end ;
7585: PPOPN 3
7587: END
// every 0 0$1 trigger StreamModeActive and sTroll do
7588: LD_EXP 17
7592: PUSH
7593: LD_EXP 42
7597: AND
7598: IFFALSE 7652
7600: GO 7602
7602: DISABLE
// begin ToLua ( displayTroll(); ) ;
7603: LD_STRING displayTroll();
7605: PPUSH
7606: CALL_OW 559
// wait ( 3 3$00 ) ;
7610: LD_INT 6300
7612: PPUSH
7613: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7617: LD_STRING hideTroll();
7619: PPUSH
7620: CALL_OW 559
// wait ( 1 1$00 ) ;
7624: LD_INT 2100
7626: PPUSH
7627: CALL_OW 67
// ToLua ( displayTroll(); ) ;
7631: LD_STRING displayTroll();
7633: PPUSH
7634: CALL_OW 559
// wait ( 1 1$00 ) ;
7638: LD_INT 2100
7640: PPUSH
7641: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7645: LD_STRING hideTroll();
7647: PPUSH
7648: CALL_OW 559
// end ;
7652: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
7653: LD_EXP 17
7657: PUSH
7658: LD_EXP 43
7662: AND
7663: IFFALSE 7726
7665: GO 7667
7667: DISABLE
7668: LD_INT 0
7670: PPUSH
// begin p := 0 ;
7671: LD_ADDR_VAR 0 1
7675: PUSH
7676: LD_INT 0
7678: ST_TO_ADDR
// repeat game_speed := 1 ;
7679: LD_ADDR_OWVAR 65
7683: PUSH
7684: LD_INT 1
7686: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7687: LD_INT 35
7689: PPUSH
7690: CALL_OW 67
// p := p + 1 ;
7694: LD_ADDR_VAR 0 1
7698: PUSH
7699: LD_VAR 0 1
7703: PUSH
7704: LD_INT 1
7706: PLUS
7707: ST_TO_ADDR
// until p >= 60 ;
7708: LD_VAR 0 1
7712: PUSH
7713: LD_INT 60
7715: GREATEREQUAL
7716: IFFALSE 7679
// game_speed := 4 ;
7718: LD_ADDR_OWVAR 65
7722: PUSH
7723: LD_INT 4
7725: ST_TO_ADDR
// end ;
7726: PPOPN 1
7728: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
7729: LD_EXP 17
7733: PUSH
7734: LD_EXP 44
7738: AND
7739: IFFALSE 7885
7741: GO 7743
7743: DISABLE
7744: LD_INT 0
7746: PPUSH
7747: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7748: LD_ADDR_VAR 0 1
7752: PUSH
7753: LD_INT 22
7755: PUSH
7756: LD_OWVAR 2
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PUSH
7765: LD_INT 2
7767: PUSH
7768: LD_INT 30
7770: PUSH
7771: LD_INT 0
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: PUSH
7778: LD_INT 30
7780: PUSH
7781: LD_INT 1
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: LIST
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: PPUSH
7797: CALL_OW 69
7801: ST_TO_ADDR
// if not depot then
7802: LD_VAR 0 1
7806: NOT
7807: IFFALSE 7811
// exit ;
7809: GO 7885
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
7811: LD_ADDR_VAR 0 2
7815: PUSH
7816: LD_VAR 0 1
7820: PUSH
7821: LD_INT 1
7823: PPUSH
7824: LD_VAR 0 1
7828: PPUSH
7829: CALL_OW 12
7833: ARRAY
7834: PPUSH
7835: CALL_OW 274
7839: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
7840: LD_VAR 0 2
7844: PPUSH
7845: LD_INT 1
7847: PPUSH
7848: LD_INT 0
7850: PPUSH
7851: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
7855: LD_VAR 0 2
7859: PPUSH
7860: LD_INT 2
7862: PPUSH
7863: LD_INT 0
7865: PPUSH
7866: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
7870: LD_VAR 0 2
7874: PPUSH
7875: LD_INT 3
7877: PPUSH
7878: LD_INT 0
7880: PPUSH
7881: CALL_OW 277
// end ;
7885: PPOPN 2
7887: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
7888: LD_EXP 17
7892: PUSH
7893: LD_EXP 45
7897: AND
7898: IFFALSE 7995
7900: GO 7902
7902: DISABLE
7903: LD_INT 0
7905: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
7906: LD_ADDR_VAR 0 1
7910: PUSH
7911: LD_INT 22
7913: PUSH
7914: LD_OWVAR 2
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: PUSH
7923: LD_INT 21
7925: PUSH
7926: LD_INT 1
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PUSH
7933: LD_INT 3
7935: PUSH
7936: LD_INT 23
7938: PUSH
7939: LD_INT 0
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PUSH
7946: EMPTY
7947: LIST
7948: LIST
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: LIST
7954: PPUSH
7955: CALL_OW 69
7959: ST_TO_ADDR
// if not tmp then
7960: LD_VAR 0 1
7964: NOT
7965: IFFALSE 7969
// exit ;
7967: GO 7995
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
7969: LD_VAR 0 1
7973: PUSH
7974: LD_INT 1
7976: PPUSH
7977: LD_VAR 0 1
7981: PPUSH
7982: CALL_OW 12
7986: ARRAY
7987: PPUSH
7988: LD_INT 200
7990: PPUSH
7991: CALL_OW 234
// end ;
7995: PPOPN 1
7997: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
7998: LD_EXP 17
8002: PUSH
8003: LD_EXP 46
8007: AND
8008: IFFALSE 8087
8010: GO 8012
8012: DISABLE
8013: LD_INT 0
8015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
8016: LD_ADDR_VAR 0 1
8020: PUSH
8021: LD_INT 22
8023: PUSH
8024: LD_OWVAR 2
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 21
8035: PUSH
8036: LD_INT 2
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: PPUSH
8047: CALL_OW 69
8051: ST_TO_ADDR
// if not tmp then
8052: LD_VAR 0 1
8056: NOT
8057: IFFALSE 8061
// exit ;
8059: GO 8087
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
8061: LD_VAR 0 1
8065: PUSH
8066: LD_INT 1
8068: PPUSH
8069: LD_VAR 0 1
8073: PPUSH
8074: CALL_OW 12
8078: ARRAY
8079: PPUSH
8080: LD_INT 60
8082: PPUSH
8083: CALL_OW 234
// end ;
8087: PPOPN 1
8089: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
8090: LD_EXP 17
8094: PUSH
8095: LD_EXP 47
8099: AND
8100: IFFALSE 8199
8102: GO 8104
8104: DISABLE
8105: LD_INT 0
8107: PPUSH
8108: PPUSH
// begin enable ;
8109: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
8110: LD_ADDR_VAR 0 1
8114: PUSH
8115: LD_INT 22
8117: PUSH
8118: LD_OWVAR 2
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: PUSH
8127: LD_INT 61
8129: PUSH
8130: EMPTY
8131: LIST
8132: PUSH
8133: LD_INT 33
8135: PUSH
8136: LD_INT 2
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PUSH
8143: EMPTY
8144: LIST
8145: LIST
8146: LIST
8147: PPUSH
8148: CALL_OW 69
8152: ST_TO_ADDR
// if not tmp then
8153: LD_VAR 0 1
8157: NOT
8158: IFFALSE 8162
// exit ;
8160: GO 8199
// for i in tmp do
8162: LD_ADDR_VAR 0 2
8166: PUSH
8167: LD_VAR 0 1
8171: PUSH
8172: FOR_IN
8173: IFFALSE 8197
// if IsControledBy ( i ) then
8175: LD_VAR 0 2
8179: PPUSH
8180: CALL_OW 312
8184: IFFALSE 8195
// ComUnlink ( i ) ;
8186: LD_VAR 0 2
8190: PPUSH
8191: CALL_OW 136
8195: GO 8172
8197: POP
8198: POP
// end ;
8199: PPOPN 2
8201: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
8202: LD_EXP 17
8206: PUSH
8207: LD_EXP 48
8211: AND
8212: IFFALSE 8352
8214: GO 8216
8216: DISABLE
8217: LD_INT 0
8219: PPUSH
8220: PPUSH
// begin ToLua ( displayPowell(); ) ;
8221: LD_STRING displayPowell();
8223: PPUSH
8224: CALL_OW 559
// uc_side := 0 ;
8228: LD_ADDR_OWVAR 20
8232: PUSH
8233: LD_INT 0
8235: ST_TO_ADDR
// uc_nation := 2 ;
8236: LD_ADDR_OWVAR 21
8240: PUSH
8241: LD_INT 2
8243: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
8244: LD_ADDR_OWVAR 37
8248: PUSH
8249: LD_INT 14
8251: ST_TO_ADDR
// vc_engine := engine_siberite ;
8252: LD_ADDR_OWVAR 39
8256: PUSH
8257: LD_INT 3
8259: ST_TO_ADDR
// vc_control := control_apeman ;
8260: LD_ADDR_OWVAR 38
8264: PUSH
8265: LD_INT 5
8267: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
8268: LD_ADDR_OWVAR 40
8272: PUSH
8273: LD_INT 29
8275: ST_TO_ADDR
// un := CreateVehicle ;
8276: LD_ADDR_VAR 0 2
8280: PUSH
8281: CALL_OW 45
8285: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
8286: LD_VAR 0 2
8290: PPUSH
8291: LD_INT 1
8293: PPUSH
8294: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
8298: LD_INT 35
8300: PPUSH
8301: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
8305: LD_VAR 0 2
8309: PPUSH
8310: LD_INT 22
8312: PUSH
8313: LD_OWVAR 2
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PPUSH
8322: CALL_OW 69
8326: PPUSH
8327: LD_VAR 0 2
8331: PPUSH
8332: CALL_OW 74
8336: PPUSH
8337: CALL_OW 115
// until IsDead ( un ) ;
8341: LD_VAR 0 2
8345: PPUSH
8346: CALL_OW 301
8350: IFFALSE 8298
// end ;
8352: PPOPN 2
8354: END
// every 0 0$1 trigger StreamModeActive and sStu do
8355: LD_EXP 17
8359: PUSH
8360: LD_EXP 56
8364: AND
8365: IFFALSE 8381
8367: GO 8369
8369: DISABLE
// begin ToLua ( displayStucuk(); ) ;
8370: LD_STRING displayStucuk();
8372: PPUSH
8373: CALL_OW 559
// ResetFog ;
8377: CALL_OW 335
// end ;
8381: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
8382: LD_EXP 17
8386: PUSH
8387: LD_EXP 49
8391: AND
8392: IFFALSE 8533
8394: GO 8396
8396: DISABLE
8397: LD_INT 0
8399: PPUSH
8400: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8401: LD_ADDR_VAR 0 2
8405: PUSH
8406: LD_INT 22
8408: PUSH
8409: LD_OWVAR 2
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: LD_INT 21
8420: PUSH
8421: LD_INT 1
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: PPUSH
8432: CALL_OW 69
8436: ST_TO_ADDR
// if not tmp then
8437: LD_VAR 0 2
8441: NOT
8442: IFFALSE 8446
// exit ;
8444: GO 8533
// un := tmp [ rand ( 1 , tmp ) ] ;
8446: LD_ADDR_VAR 0 1
8450: PUSH
8451: LD_VAR 0 2
8455: PUSH
8456: LD_INT 1
8458: PPUSH
8459: LD_VAR 0 2
8463: PPUSH
8464: CALL_OW 12
8468: ARRAY
8469: ST_TO_ADDR
// SetSide ( un , 0 ) ;
8470: LD_VAR 0 1
8474: PPUSH
8475: LD_INT 0
8477: PPUSH
8478: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
8482: LD_VAR 0 1
8486: PPUSH
8487: LD_OWVAR 3
8491: PUSH
8492: LD_VAR 0 1
8496: DIFF
8497: PPUSH
8498: LD_VAR 0 1
8502: PPUSH
8503: CALL_OW 74
8507: PPUSH
8508: CALL_OW 115
// wait ( 0 0$20 ) ;
8512: LD_INT 700
8514: PPUSH
8515: CALL_OW 67
// SetSide ( un , your_side ) ;
8519: LD_VAR 0 1
8523: PPUSH
8524: LD_OWVAR 2
8528: PPUSH
8529: CALL_OW 235
// end ;
8533: PPOPN 2
8535: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
8536: LD_EXP 17
8540: PUSH
8541: LD_EXP 50
8545: AND
8546: IFFALSE 8652
8548: GO 8550
8550: DISABLE
8551: LD_INT 0
8553: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8554: LD_ADDR_VAR 0 1
8558: PUSH
8559: LD_INT 22
8561: PUSH
8562: LD_OWVAR 2
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: PUSH
8571: LD_INT 2
8573: PUSH
8574: LD_INT 30
8576: PUSH
8577: LD_INT 0
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PUSH
8584: LD_INT 30
8586: PUSH
8587: LD_INT 1
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: PUSH
8599: EMPTY
8600: LIST
8601: LIST
8602: PPUSH
8603: CALL_OW 69
8607: ST_TO_ADDR
// if not depot then
8608: LD_VAR 0 1
8612: NOT
8613: IFFALSE 8617
// exit ;
8615: GO 8652
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
8617: LD_VAR 0 1
8621: PUSH
8622: LD_INT 1
8624: ARRAY
8625: PPUSH
8626: CALL_OW 250
8630: PPUSH
8631: LD_VAR 0 1
8635: PUSH
8636: LD_INT 1
8638: ARRAY
8639: PPUSH
8640: CALL_OW 251
8644: PPUSH
8645: LD_INT 70
8647: PPUSH
8648: CALL_OW 495
// end ;
8652: PPOPN 1
8654: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
8655: LD_EXP 17
8659: PUSH
8660: LD_EXP 51
8664: AND
8665: IFFALSE 8876
8667: GO 8669
8669: DISABLE
8670: LD_INT 0
8672: PPUSH
8673: PPUSH
8674: PPUSH
8675: PPUSH
8676: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8677: LD_ADDR_VAR 0 5
8681: PUSH
8682: LD_INT 22
8684: PUSH
8685: LD_OWVAR 2
8689: PUSH
8690: EMPTY
8691: LIST
8692: LIST
8693: PUSH
8694: LD_INT 21
8696: PUSH
8697: LD_INT 1
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PPUSH
8708: CALL_OW 69
8712: ST_TO_ADDR
// if not tmp then
8713: LD_VAR 0 5
8717: NOT
8718: IFFALSE 8722
// exit ;
8720: GO 8876
// for i in tmp do
8722: LD_ADDR_VAR 0 1
8726: PUSH
8727: LD_VAR 0 5
8731: PUSH
8732: FOR_IN
8733: IFFALSE 8874
// begin d := rand ( 0 , 5 ) ;
8735: LD_ADDR_VAR 0 4
8739: PUSH
8740: LD_INT 0
8742: PPUSH
8743: LD_INT 5
8745: PPUSH
8746: CALL_OW 12
8750: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
8751: LD_ADDR_VAR 0 2
8755: PUSH
8756: LD_VAR 0 1
8760: PPUSH
8761: CALL_OW 250
8765: PPUSH
8766: LD_VAR 0 4
8770: PPUSH
8771: LD_INT 3
8773: PPUSH
8774: LD_INT 12
8776: PPUSH
8777: CALL_OW 12
8781: PPUSH
8782: CALL_OW 272
8786: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
8787: LD_ADDR_VAR 0 3
8791: PUSH
8792: LD_VAR 0 1
8796: PPUSH
8797: CALL_OW 251
8801: PPUSH
8802: LD_VAR 0 4
8806: PPUSH
8807: LD_INT 3
8809: PPUSH
8810: LD_INT 12
8812: PPUSH
8813: CALL_OW 12
8817: PPUSH
8818: CALL_OW 273
8822: ST_TO_ADDR
// if ValidHex ( x , y ) then
8823: LD_VAR 0 2
8827: PPUSH
8828: LD_VAR 0 3
8832: PPUSH
8833: CALL_OW 488
8837: IFFALSE 8872
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
8839: LD_VAR 0 1
8843: PPUSH
8844: LD_VAR 0 2
8848: PPUSH
8849: LD_VAR 0 3
8853: PPUSH
8854: LD_INT 3
8856: PPUSH
8857: LD_INT 6
8859: PPUSH
8860: CALL_OW 12
8864: PPUSH
8865: LD_INT 1
8867: PPUSH
8868: CALL_OW 483
// end ;
8872: GO 8732
8874: POP
8875: POP
// end ;
8876: PPOPN 5
8878: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
8879: LD_EXP 17
8883: PUSH
8884: LD_EXP 52
8888: AND
8889: IFFALSE 8983
8891: GO 8893
8893: DISABLE
8894: LD_INT 0
8896: PPUSH
8897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
8898: LD_ADDR_VAR 0 2
8902: PUSH
8903: LD_INT 22
8905: PUSH
8906: LD_OWVAR 2
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 32
8917: PUSH
8918: LD_INT 1
8920: PUSH
8921: EMPTY
8922: LIST
8923: LIST
8924: PUSH
8925: LD_INT 21
8927: PUSH
8928: LD_INT 2
8930: PUSH
8931: EMPTY
8932: LIST
8933: LIST
8934: PUSH
8935: EMPTY
8936: LIST
8937: LIST
8938: LIST
8939: PPUSH
8940: CALL_OW 69
8944: ST_TO_ADDR
// if not tmp then
8945: LD_VAR 0 2
8949: NOT
8950: IFFALSE 8954
// exit ;
8952: GO 8983
// for i in tmp do
8954: LD_ADDR_VAR 0 1
8958: PUSH
8959: LD_VAR 0 2
8963: PUSH
8964: FOR_IN
8965: IFFALSE 8981
// SetFuel ( i , 0 ) ;
8967: LD_VAR 0 1
8971: PPUSH
8972: LD_INT 0
8974: PPUSH
8975: CALL_OW 240
8979: GO 8964
8981: POP
8982: POP
// end ;
8983: PPOPN 2
8985: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
8986: LD_EXP 17
8990: PUSH
8991: LD_EXP 53
8995: AND
8996: IFFALSE 9062
8998: GO 9000
9000: DISABLE
9001: LD_INT 0
9003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
9004: LD_ADDR_VAR 0 1
9008: PUSH
9009: LD_INT 22
9011: PUSH
9012: LD_OWVAR 2
9016: PUSH
9017: EMPTY
9018: LIST
9019: LIST
9020: PUSH
9021: LD_INT 30
9023: PUSH
9024: LD_INT 29
9026: PUSH
9027: EMPTY
9028: LIST
9029: LIST
9030: PUSH
9031: EMPTY
9032: LIST
9033: LIST
9034: PPUSH
9035: CALL_OW 69
9039: ST_TO_ADDR
// if not tmp then
9040: LD_VAR 0 1
9044: NOT
9045: IFFALSE 9049
// exit ;
9047: GO 9062
// DestroyUnit ( tmp [ 1 ] ) ;
9049: LD_VAR 0 1
9053: PUSH
9054: LD_INT 1
9056: ARRAY
9057: PPUSH
9058: CALL_OW 65
// end ;
9062: PPOPN 1
9064: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
9065: LD_EXP 17
9069: PUSH
9070: LD_EXP 55
9074: AND
9075: IFFALSE 9204
9077: GO 9079
9079: DISABLE
9080: LD_INT 0
9082: PPUSH
// begin uc_side := 0 ;
9083: LD_ADDR_OWVAR 20
9087: PUSH
9088: LD_INT 0
9090: ST_TO_ADDR
// uc_nation := nation_arabian ;
9091: LD_ADDR_OWVAR 21
9095: PUSH
9096: LD_INT 2
9098: ST_TO_ADDR
// hc_gallery :=  ;
9099: LD_ADDR_OWVAR 33
9103: PUSH
9104: LD_STRING 
9106: ST_TO_ADDR
// hc_name :=  ;
9107: LD_ADDR_OWVAR 26
9111: PUSH
9112: LD_STRING 
9114: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
9115: LD_INT 1
9117: PPUSH
9118: LD_INT 11
9120: PPUSH
9121: LD_INT 10
9123: PPUSH
9124: CALL_OW 380
// un := CreateHuman ;
9128: LD_ADDR_VAR 0 1
9132: PUSH
9133: CALL_OW 44
9137: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
9138: LD_VAR 0 1
9142: PPUSH
9143: LD_INT 1
9145: PPUSH
9146: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
9150: LD_INT 35
9152: PPUSH
9153: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
9157: LD_VAR 0 1
9161: PPUSH
9162: LD_INT 22
9164: PUSH
9165: LD_OWVAR 2
9169: PUSH
9170: EMPTY
9171: LIST
9172: LIST
9173: PPUSH
9174: CALL_OW 69
9178: PPUSH
9179: LD_VAR 0 1
9183: PPUSH
9184: CALL_OW 74
9188: PPUSH
9189: CALL_OW 115
// until IsDead ( un ) ;
9193: LD_VAR 0 1
9197: PPUSH
9198: CALL_OW 301
9202: IFFALSE 9150
// end ;
9204: PPOPN 1
9206: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
9207: LD_EXP 17
9211: PUSH
9212: LD_EXP 57
9216: AND
9217: IFFALSE 9229
9219: GO 9221
9221: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
9222: LD_STRING earthquake(getX(game), 0, 32)
9224: PPUSH
9225: CALL_OW 559
9229: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
9230: LD_EXP 17
9234: PUSH
9235: LD_EXP 58
9239: AND
9240: IFFALSE 9331
9242: GO 9244
9244: DISABLE
9245: LD_INT 0
9247: PPUSH
// begin enable ;
9248: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
9249: LD_ADDR_VAR 0 1
9253: PUSH
9254: LD_INT 22
9256: PUSH
9257: LD_OWVAR 2
9261: PUSH
9262: EMPTY
9263: LIST
9264: LIST
9265: PUSH
9266: LD_INT 21
9268: PUSH
9269: LD_INT 2
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: PUSH
9276: LD_INT 33
9278: PUSH
9279: LD_INT 3
9281: PUSH
9282: EMPTY
9283: LIST
9284: LIST
9285: PUSH
9286: EMPTY
9287: LIST
9288: LIST
9289: LIST
9290: PPUSH
9291: CALL_OW 69
9295: ST_TO_ADDR
// if not tmp then
9296: LD_VAR 0 1
9300: NOT
9301: IFFALSE 9305
// exit ;
9303: GO 9331
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
9305: LD_VAR 0 1
9309: PUSH
9310: LD_INT 1
9312: PPUSH
9313: LD_VAR 0 1
9317: PPUSH
9318: CALL_OW 12
9322: ARRAY
9323: PPUSH
9324: LD_INT 1
9326: PPUSH
9327: CALL_OW 234
// end ;
9331: PPOPN 1
9333: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
9334: LD_EXP 17
9338: PUSH
9339: LD_EXP 59
9343: AND
9344: IFFALSE 9485
9346: GO 9348
9348: DISABLE
9349: LD_INT 0
9351: PPUSH
9352: PPUSH
9353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9354: LD_ADDR_VAR 0 3
9358: PUSH
9359: LD_INT 22
9361: PUSH
9362: LD_OWVAR 2
9366: PUSH
9367: EMPTY
9368: LIST
9369: LIST
9370: PUSH
9371: LD_INT 25
9373: PUSH
9374: LD_INT 1
9376: PUSH
9377: EMPTY
9378: LIST
9379: LIST
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: PPUSH
9385: CALL_OW 69
9389: ST_TO_ADDR
// if not tmp then
9390: LD_VAR 0 3
9394: NOT
9395: IFFALSE 9399
// exit ;
9397: GO 9485
// un := tmp [ rand ( 1 , tmp ) ] ;
9399: LD_ADDR_VAR 0 2
9403: PUSH
9404: LD_VAR 0 3
9408: PUSH
9409: LD_INT 1
9411: PPUSH
9412: LD_VAR 0 3
9416: PPUSH
9417: CALL_OW 12
9421: ARRAY
9422: ST_TO_ADDR
// if Crawls ( un ) then
9423: LD_VAR 0 2
9427: PPUSH
9428: CALL_OW 318
9432: IFFALSE 9443
// ComWalk ( un ) ;
9434: LD_VAR 0 2
9438: PPUSH
9439: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
9443: LD_VAR 0 2
9447: PPUSH
9448: LD_INT 9
9450: PPUSH
9451: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
9455: LD_INT 28
9457: PPUSH
9458: LD_OWVAR 2
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
9470: LD_INT 29
9472: PPUSH
9473: LD_OWVAR 2
9477: PPUSH
9478: LD_INT 2
9480: PPUSH
9481: CALL_OW 322
// end ;
9485: PPOPN 3
9487: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
9488: LD_EXP 17
9492: PUSH
9493: LD_EXP 60
9497: AND
9498: IFFALSE 9609
9500: GO 9502
9502: DISABLE
9503: LD_INT 0
9505: PPUSH
9506: PPUSH
9507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9508: LD_ADDR_VAR 0 3
9512: PUSH
9513: LD_INT 22
9515: PUSH
9516: LD_OWVAR 2
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PUSH
9525: LD_INT 25
9527: PUSH
9528: LD_INT 1
9530: PUSH
9531: EMPTY
9532: LIST
9533: LIST
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: PPUSH
9539: CALL_OW 69
9543: ST_TO_ADDR
// if not tmp then
9544: LD_VAR 0 3
9548: NOT
9549: IFFALSE 9553
// exit ;
9551: GO 9609
// un := tmp [ rand ( 1 , tmp ) ] ;
9553: LD_ADDR_VAR 0 2
9557: PUSH
9558: LD_VAR 0 3
9562: PUSH
9563: LD_INT 1
9565: PPUSH
9566: LD_VAR 0 3
9570: PPUSH
9571: CALL_OW 12
9575: ARRAY
9576: ST_TO_ADDR
// if Crawls ( un ) then
9577: LD_VAR 0 2
9581: PPUSH
9582: CALL_OW 318
9586: IFFALSE 9597
// ComWalk ( un ) ;
9588: LD_VAR 0 2
9592: PPUSH
9593: CALL_OW 138
// SetClass ( un , class_mortar ) ;
9597: LD_VAR 0 2
9601: PPUSH
9602: LD_INT 8
9604: PPUSH
9605: CALL_OW 336
// end ;
9609: PPOPN 3
9611: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
9612: LD_EXP 17
9616: PUSH
9617: LD_EXP 61
9621: AND
9622: IFFALSE 9766
9624: GO 9626
9626: DISABLE
9627: LD_INT 0
9629: PPUSH
9630: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
9631: LD_ADDR_VAR 0 2
9635: PUSH
9636: LD_INT 22
9638: PUSH
9639: LD_OWVAR 2
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: PUSH
9648: LD_INT 21
9650: PUSH
9651: LD_INT 2
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PUSH
9658: LD_INT 2
9660: PUSH
9661: LD_INT 34
9663: PUSH
9664: LD_INT 12
9666: PUSH
9667: EMPTY
9668: LIST
9669: LIST
9670: PUSH
9671: LD_INT 34
9673: PUSH
9674: LD_INT 51
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: PUSH
9681: LD_INT 34
9683: PUSH
9684: LD_INT 32
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PUSH
9691: EMPTY
9692: LIST
9693: LIST
9694: LIST
9695: LIST
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: LIST
9701: PPUSH
9702: CALL_OW 69
9706: ST_TO_ADDR
// if not tmp then
9707: LD_VAR 0 2
9711: NOT
9712: IFFALSE 9716
// exit ;
9714: GO 9766
// for i in tmp do
9716: LD_ADDR_VAR 0 1
9720: PUSH
9721: LD_VAR 0 2
9725: PUSH
9726: FOR_IN
9727: IFFALSE 9764
// if GetCargo ( i , mat_artifact ) = 0 then
9729: LD_VAR 0 1
9733: PPUSH
9734: LD_INT 4
9736: PPUSH
9737: CALL_OW 289
9741: PUSH
9742: LD_INT 0
9744: EQUAL
9745: IFFALSE 9762
// SetCargo ( i , mat_siberit , 100 ) ;
9747: LD_VAR 0 1
9751: PPUSH
9752: LD_INT 3
9754: PPUSH
9755: LD_INT 100
9757: PPUSH
9758: CALL_OW 290
9762: GO 9726
9764: POP
9765: POP
// end ;
9766: PPOPN 2
9768: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
9769: LD_EXP 17
9773: PUSH
9774: LD_EXP 62
9778: AND
9779: IFFALSE 9962
9781: GO 9783
9783: DISABLE
9784: LD_INT 0
9786: PPUSH
9787: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
9788: LD_ADDR_VAR 0 2
9792: PUSH
9793: LD_INT 22
9795: PUSH
9796: LD_OWVAR 2
9800: PUSH
9801: EMPTY
9802: LIST
9803: LIST
9804: PPUSH
9805: CALL_OW 69
9809: ST_TO_ADDR
// if not tmp then
9810: LD_VAR 0 2
9814: NOT
9815: IFFALSE 9819
// exit ;
9817: GO 9962
// for i := 1 to 2 do
9819: LD_ADDR_VAR 0 1
9823: PUSH
9824: DOUBLE
9825: LD_INT 1
9827: DEC
9828: ST_TO_ADDR
9829: LD_INT 2
9831: PUSH
9832: FOR_TO
9833: IFFALSE 9960
// begin uc_side := your_side ;
9835: LD_ADDR_OWVAR 20
9839: PUSH
9840: LD_OWVAR 2
9844: ST_TO_ADDR
// uc_nation := nation_american ;
9845: LD_ADDR_OWVAR 21
9849: PUSH
9850: LD_INT 1
9852: ST_TO_ADDR
// vc_chassis := us_morphling ;
9853: LD_ADDR_OWVAR 37
9857: PUSH
9858: LD_INT 5
9860: ST_TO_ADDR
// vc_engine := engine_siberite ;
9861: LD_ADDR_OWVAR 39
9865: PUSH
9866: LD_INT 3
9868: ST_TO_ADDR
// vc_control := control_computer ;
9869: LD_ADDR_OWVAR 38
9873: PUSH
9874: LD_INT 3
9876: ST_TO_ADDR
// vc_weapon := us_double_laser ;
9877: LD_ADDR_OWVAR 40
9881: PUSH
9882: LD_INT 10
9884: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
9885: LD_VAR 0 2
9889: PUSH
9890: LD_INT 1
9892: ARRAY
9893: PPUSH
9894: CALL_OW 310
9898: NOT
9899: IFFALSE 9946
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
9901: CALL_OW 45
9905: PPUSH
9906: LD_VAR 0 2
9910: PUSH
9911: LD_INT 1
9913: ARRAY
9914: PPUSH
9915: CALL_OW 250
9919: PPUSH
9920: LD_VAR 0 2
9924: PUSH
9925: LD_INT 1
9927: ARRAY
9928: PPUSH
9929: CALL_OW 251
9933: PPUSH
9934: LD_INT 12
9936: PPUSH
9937: LD_INT 1
9939: PPUSH
9940: CALL_OW 50
9944: GO 9958
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
9946: CALL_OW 45
9950: PPUSH
9951: LD_INT 1
9953: PPUSH
9954: CALL_OW 51
// end ;
9958: GO 9832
9960: POP
9961: POP
// end ;
9962: PPOPN 2
9964: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
9965: LD_EXP 17
9969: PUSH
9970: LD_EXP 63
9974: AND
9975: IFFALSE 10197
9977: GO 9979
9979: DISABLE
9980: LD_INT 0
9982: PPUSH
9983: PPUSH
9984: PPUSH
9985: PPUSH
9986: PPUSH
9987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
9988: LD_ADDR_VAR 0 6
9992: PUSH
9993: LD_INT 22
9995: PUSH
9996: LD_OWVAR 2
10000: PUSH
10001: EMPTY
10002: LIST
10003: LIST
10004: PUSH
10005: LD_INT 21
10007: PUSH
10008: LD_INT 1
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: PUSH
10015: LD_INT 3
10017: PUSH
10018: LD_INT 23
10020: PUSH
10021: LD_INT 0
10023: PUSH
10024: EMPTY
10025: LIST
10026: LIST
10027: PUSH
10028: EMPTY
10029: LIST
10030: LIST
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: PPUSH
10037: CALL_OW 69
10041: ST_TO_ADDR
// if not tmp then
10042: LD_VAR 0 6
10046: NOT
10047: IFFALSE 10051
// exit ;
10049: GO 10197
// s1 := rand ( 1 , 4 ) ;
10051: LD_ADDR_VAR 0 2
10055: PUSH
10056: LD_INT 1
10058: PPUSH
10059: LD_INT 4
10061: PPUSH
10062: CALL_OW 12
10066: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
10067: LD_ADDR_VAR 0 4
10071: PUSH
10072: LD_VAR 0 6
10076: PUSH
10077: LD_INT 1
10079: ARRAY
10080: PPUSH
10081: LD_VAR 0 2
10085: PPUSH
10086: CALL_OW 259
10090: ST_TO_ADDR
// if s1 = 1 then
10091: LD_VAR 0 2
10095: PUSH
10096: LD_INT 1
10098: EQUAL
10099: IFFALSE 10119
// s2 := rand ( 2 , 4 ) else
10101: LD_ADDR_VAR 0 3
10105: PUSH
10106: LD_INT 2
10108: PPUSH
10109: LD_INT 4
10111: PPUSH
10112: CALL_OW 12
10116: ST_TO_ADDR
10117: GO 10127
// s2 := 1 ;
10119: LD_ADDR_VAR 0 3
10123: PUSH
10124: LD_INT 1
10126: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
10127: LD_ADDR_VAR 0 5
10131: PUSH
10132: LD_VAR 0 6
10136: PUSH
10137: LD_INT 1
10139: ARRAY
10140: PPUSH
10141: LD_VAR 0 3
10145: PPUSH
10146: CALL_OW 259
10150: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
10151: LD_VAR 0 6
10155: PUSH
10156: LD_INT 1
10158: ARRAY
10159: PPUSH
10160: LD_VAR 0 2
10164: PPUSH
10165: LD_VAR 0 5
10169: PPUSH
10170: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
10174: LD_VAR 0 6
10178: PUSH
10179: LD_INT 1
10181: ARRAY
10182: PPUSH
10183: LD_VAR 0 3
10187: PPUSH
10188: LD_VAR 0 4
10192: PPUSH
10193: CALL_OW 237
// end ;
10197: PPOPN 6
10199: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
10200: LD_EXP 17
10204: PUSH
10205: LD_EXP 64
10209: AND
10210: IFFALSE 10289
10212: GO 10214
10214: DISABLE
10215: LD_INT 0
10217: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
10218: LD_ADDR_VAR 0 1
10222: PUSH
10223: LD_INT 22
10225: PUSH
10226: LD_OWVAR 2
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: PUSH
10235: LD_INT 30
10237: PUSH
10238: LD_INT 3
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: PUSH
10245: EMPTY
10246: LIST
10247: LIST
10248: PPUSH
10249: CALL_OW 69
10253: ST_TO_ADDR
// if not tmp then
10254: LD_VAR 0 1
10258: NOT
10259: IFFALSE 10263
// exit ;
10261: GO 10289
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
10263: LD_VAR 0 1
10267: PUSH
10268: LD_INT 1
10270: PPUSH
10271: LD_VAR 0 1
10275: PPUSH
10276: CALL_OW 12
10280: ARRAY
10281: PPUSH
10282: LD_INT 1
10284: PPUSH
10285: CALL_OW 234
// end ;
10289: PPOPN 1
10291: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
10292: LD_EXP 17
10296: PUSH
10297: LD_EXP 65
10301: AND
10302: IFFALSE 10414
10304: GO 10306
10306: DISABLE
10307: LD_INT 0
10309: PPUSH
10310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
10311: LD_ADDR_VAR 0 2
10315: PUSH
10316: LD_INT 22
10318: PUSH
10319: LD_OWVAR 2
10323: PUSH
10324: EMPTY
10325: LIST
10326: LIST
10327: PUSH
10328: LD_INT 2
10330: PUSH
10331: LD_INT 30
10333: PUSH
10334: LD_INT 27
10336: PUSH
10337: EMPTY
10338: LIST
10339: LIST
10340: PUSH
10341: LD_INT 30
10343: PUSH
10344: LD_INT 26
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: PUSH
10351: LD_INT 30
10353: PUSH
10354: LD_INT 28
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: PUSH
10361: EMPTY
10362: LIST
10363: LIST
10364: LIST
10365: LIST
10366: PUSH
10367: EMPTY
10368: LIST
10369: LIST
10370: PPUSH
10371: CALL_OW 69
10375: ST_TO_ADDR
// if not tmp then
10376: LD_VAR 0 2
10380: NOT
10381: IFFALSE 10385
// exit ;
10383: GO 10414
// for i in tmp do
10385: LD_ADDR_VAR 0 1
10389: PUSH
10390: LD_VAR 0 2
10394: PUSH
10395: FOR_IN
10396: IFFALSE 10412
// SetLives ( i , 1 ) ;
10398: LD_VAR 0 1
10402: PPUSH
10403: LD_INT 1
10405: PPUSH
10406: CALL_OW 234
10410: GO 10395
10412: POP
10413: POP
// end ;
10414: PPOPN 2
10416: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
10417: LD_EXP 17
10421: PUSH
10422: LD_EXP 66
10426: AND
10427: IFFALSE 10701
10429: GO 10431
10431: DISABLE
10432: LD_INT 0
10434: PPUSH
10435: PPUSH
10436: PPUSH
// begin i := rand ( 1 , 7 ) ;
10437: LD_ADDR_VAR 0 1
10441: PUSH
10442: LD_INT 1
10444: PPUSH
10445: LD_INT 7
10447: PPUSH
10448: CALL_OW 12
10452: ST_TO_ADDR
// case i of 1 :
10453: LD_VAR 0 1
10457: PUSH
10458: LD_INT 1
10460: DOUBLE
10461: EQUAL
10462: IFTRUE 10466
10464: GO 10476
10466: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
10467: LD_STRING earthquake(getX(game), 0, 32)
10469: PPUSH
10470: CALL_OW 559
10474: GO 10701
10476: LD_INT 2
10478: DOUBLE
10479: EQUAL
10480: IFTRUE 10484
10482: GO 10498
10484: POP
// begin ToLua ( displayStucuk(); ) ;
10485: LD_STRING displayStucuk();
10487: PPUSH
10488: CALL_OW 559
// ResetFog ;
10492: CALL_OW 335
// end ; 3 :
10496: GO 10701
10498: LD_INT 3
10500: DOUBLE
10501: EQUAL
10502: IFTRUE 10506
10504: GO 10610
10506: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10507: LD_ADDR_VAR 0 2
10511: PUSH
10512: LD_INT 22
10514: PUSH
10515: LD_OWVAR 2
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PUSH
10524: LD_INT 25
10526: PUSH
10527: LD_INT 1
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: PPUSH
10538: CALL_OW 69
10542: ST_TO_ADDR
// if not tmp then
10543: LD_VAR 0 2
10547: NOT
10548: IFFALSE 10552
// exit ;
10550: GO 10701
// un := tmp [ rand ( 1 , tmp ) ] ;
10552: LD_ADDR_VAR 0 3
10556: PUSH
10557: LD_VAR 0 2
10561: PUSH
10562: LD_INT 1
10564: PPUSH
10565: LD_VAR 0 2
10569: PPUSH
10570: CALL_OW 12
10574: ARRAY
10575: ST_TO_ADDR
// if Crawls ( un ) then
10576: LD_VAR 0 3
10580: PPUSH
10581: CALL_OW 318
10585: IFFALSE 10596
// ComWalk ( un ) ;
10587: LD_VAR 0 3
10591: PPUSH
10592: CALL_OW 138
// SetClass ( un , class_mortar ) ;
10596: LD_VAR 0 3
10600: PPUSH
10601: LD_INT 8
10603: PPUSH
10604: CALL_OW 336
// end ; 4 :
10608: GO 10701
10610: LD_INT 4
10612: DOUBLE
10613: EQUAL
10614: IFTRUE 10618
10616: GO 10679
10618: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
10619: LD_ADDR_VAR 0 2
10623: PUSH
10624: LD_INT 22
10626: PUSH
10627: LD_OWVAR 2
10631: PUSH
10632: EMPTY
10633: LIST
10634: LIST
10635: PUSH
10636: LD_INT 30
10638: PUSH
10639: LD_INT 29
10641: PUSH
10642: EMPTY
10643: LIST
10644: LIST
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PPUSH
10650: CALL_OW 69
10654: ST_TO_ADDR
// if not tmp then
10655: LD_VAR 0 2
10659: NOT
10660: IFFALSE 10664
// exit ;
10662: GO 10701
// DestroyUnit ( tmp [ 1 ] ) ;
10664: LD_VAR 0 2
10668: PUSH
10669: LD_INT 1
10671: ARRAY
10672: PPUSH
10673: CALL_OW 65
// end ; 5 .. 7 :
10677: GO 10701
10679: LD_INT 5
10681: DOUBLE
10682: GREATEREQUAL
10683: IFFALSE 10691
10685: LD_INT 7
10687: DOUBLE
10688: LESSEQUAL
10689: IFTRUE 10693
10691: GO 10700
10693: POP
// StreamSibBomb ; end ;
10694: CALL 6951 0 0
10698: GO 10701
10700: POP
// end ;
10701: PPOPN 3
10703: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
10704: LD_EXP 17
10708: PUSH
10709: LD_EXP 67
10713: AND
10714: IFFALSE 10870
10716: GO 10718
10718: DISABLE
10719: LD_INT 0
10721: PPUSH
10722: PPUSH
10723: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
10724: LD_ADDR_VAR 0 2
10728: PUSH
10729: LD_INT 81
10731: PUSH
10732: LD_OWVAR 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 2
10743: PUSH
10744: LD_INT 21
10746: PUSH
10747: LD_INT 1
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PUSH
10754: LD_INT 21
10756: PUSH
10757: LD_INT 2
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: LIST
10768: PUSH
10769: EMPTY
10770: LIST
10771: LIST
10772: PPUSH
10773: CALL_OW 69
10777: ST_TO_ADDR
// if not tmp then
10778: LD_VAR 0 2
10782: NOT
10783: IFFALSE 10787
// exit ;
10785: GO 10870
// p := 0 ;
10787: LD_ADDR_VAR 0 3
10791: PUSH
10792: LD_INT 0
10794: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10795: LD_INT 35
10797: PPUSH
10798: CALL_OW 67
// p := p + 1 ;
10802: LD_ADDR_VAR 0 3
10806: PUSH
10807: LD_VAR 0 3
10811: PUSH
10812: LD_INT 1
10814: PLUS
10815: ST_TO_ADDR
// for i in tmp do
10816: LD_ADDR_VAR 0 1
10820: PUSH
10821: LD_VAR 0 2
10825: PUSH
10826: FOR_IN
10827: IFFALSE 10858
// if GetLives ( i ) < 1000 then
10829: LD_VAR 0 1
10833: PPUSH
10834: CALL_OW 256
10838: PUSH
10839: LD_INT 1000
10841: LESS
10842: IFFALSE 10856
// SetLives ( i , 1000 ) ;
10844: LD_VAR 0 1
10848: PPUSH
10849: LD_INT 1000
10851: PPUSH
10852: CALL_OW 234
10856: GO 10826
10858: POP
10859: POP
// until p > 20 ;
10860: LD_VAR 0 3
10864: PUSH
10865: LD_INT 20
10867: GREATER
10868: IFFALSE 10795
// end ;
10870: PPOPN 3
10872: END
// every 0 0$1 trigger StreamModeActive and sTime do
10873: LD_EXP 17
10877: PUSH
10878: LD_EXP 68
10882: AND
10883: IFFALSE 10918
10885: GO 10887
10887: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
10888: LD_INT 28
10890: PPUSH
10891: LD_OWVAR 2
10895: PPUSH
10896: LD_INT 2
10898: PPUSH
10899: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
10903: LD_INT 30
10905: PPUSH
10906: LD_OWVAR 2
10910: PPUSH
10911: LD_INT 2
10913: PPUSH
10914: CALL_OW 322
// end ;
10918: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
10919: LD_EXP 17
10923: PUSH
10924: LD_EXP 69
10928: AND
10929: IFFALSE 11050
10931: GO 10933
10933: DISABLE
10934: LD_INT 0
10936: PPUSH
10937: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
10938: LD_ADDR_VAR 0 2
10942: PUSH
10943: LD_INT 22
10945: PUSH
10946: LD_OWVAR 2
10950: PUSH
10951: EMPTY
10952: LIST
10953: LIST
10954: PUSH
10955: LD_INT 21
10957: PUSH
10958: LD_INT 1
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 3
10967: PUSH
10968: LD_INT 23
10970: PUSH
10971: LD_INT 0
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: PUSH
10978: EMPTY
10979: LIST
10980: LIST
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: LIST
10986: PPUSH
10987: CALL_OW 69
10991: ST_TO_ADDR
// if not tmp then
10992: LD_VAR 0 2
10996: NOT
10997: IFFALSE 11001
// exit ;
10999: GO 11050
// for i in tmp do
11001: LD_ADDR_VAR 0 1
11005: PUSH
11006: LD_VAR 0 2
11010: PUSH
11011: FOR_IN
11012: IFFALSE 11048
// begin if Crawls ( i ) then
11014: LD_VAR 0 1
11018: PPUSH
11019: CALL_OW 318
11023: IFFALSE 11034
// ComWalk ( i ) ;
11025: LD_VAR 0 1
11029: PPUSH
11030: CALL_OW 138
// SetClass ( i , 2 ) ;
11034: LD_VAR 0 1
11038: PPUSH
11039: LD_INT 2
11041: PPUSH
11042: CALL_OW 336
// end ;
11046: GO 11011
11048: POP
11049: POP
// end ;
11050: PPOPN 2
11052: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
11053: LD_EXP 17
11057: PUSH
11058: LD_EXP 70
11062: AND
11063: IFFALSE 11344
11065: GO 11067
11067: DISABLE
11068: LD_INT 0
11070: PPUSH
11071: PPUSH
11072: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
11073: LD_OWVAR 2
11077: PPUSH
11078: LD_INT 9
11080: PPUSH
11081: LD_INT 1
11083: PPUSH
11084: LD_INT 1
11086: PPUSH
11087: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
11091: LD_INT 9
11093: PPUSH
11094: LD_OWVAR 2
11098: PPUSH
11099: CALL_OW 343
// uc_side := 9 ;
11103: LD_ADDR_OWVAR 20
11107: PUSH
11108: LD_INT 9
11110: ST_TO_ADDR
// uc_nation := 2 ;
11111: LD_ADDR_OWVAR 21
11115: PUSH
11116: LD_INT 2
11118: ST_TO_ADDR
// hc_name := Dark Warrior ;
11119: LD_ADDR_OWVAR 26
11123: PUSH
11124: LD_STRING Dark Warrior
11126: ST_TO_ADDR
// hc_gallery :=  ;
11127: LD_ADDR_OWVAR 33
11131: PUSH
11132: LD_STRING 
11134: ST_TO_ADDR
// hc_noskilllimit := true ;
11135: LD_ADDR_OWVAR 76
11139: PUSH
11140: LD_INT 1
11142: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
11143: LD_ADDR_OWVAR 31
11147: PUSH
11148: LD_INT 30
11150: PUSH
11151: LD_INT 30
11153: PUSH
11154: LD_INT 30
11156: PUSH
11157: LD_INT 30
11159: PUSH
11160: EMPTY
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: ST_TO_ADDR
// un := CreateHuman ;
11166: LD_ADDR_VAR 0 3
11170: PUSH
11171: CALL_OW 44
11175: ST_TO_ADDR
// hc_noskilllimit := false ;
11176: LD_ADDR_OWVAR 76
11180: PUSH
11181: LD_INT 0
11183: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11184: LD_VAR 0 3
11188: PPUSH
11189: LD_INT 1
11191: PPUSH
11192: CALL_OW 51
// p := 0 ;
11196: LD_ADDR_VAR 0 2
11200: PUSH
11201: LD_INT 0
11203: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11204: LD_INT 35
11206: PPUSH
11207: CALL_OW 67
// p := p + 1 ;
11211: LD_ADDR_VAR 0 2
11215: PUSH
11216: LD_VAR 0 2
11220: PUSH
11221: LD_INT 1
11223: PLUS
11224: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
11225: LD_VAR 0 3
11229: PPUSH
11230: CALL_OW 256
11234: PUSH
11235: LD_INT 1000
11237: LESS
11238: IFFALSE 11252
// SetLives ( un , 1000 ) ;
11240: LD_VAR 0 3
11244: PPUSH
11245: LD_INT 1000
11247: PPUSH
11248: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
11252: LD_VAR 0 3
11256: PPUSH
11257: LD_INT 81
11259: PUSH
11260: LD_OWVAR 2
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: PUSH
11269: LD_INT 91
11271: PUSH
11272: LD_VAR 0 3
11276: PUSH
11277: LD_INT 30
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: LIST
11284: PUSH
11285: EMPTY
11286: LIST
11287: LIST
11288: PPUSH
11289: CALL_OW 69
11293: PPUSH
11294: LD_VAR 0 3
11298: PPUSH
11299: CALL_OW 74
11303: PPUSH
11304: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
11308: LD_VAR 0 2
11312: PUSH
11313: LD_INT 60
11315: GREATER
11316: PUSH
11317: LD_VAR 0 3
11321: PPUSH
11322: CALL_OW 301
11326: OR
11327: IFFALSE 11204
// if un then
11329: LD_VAR 0 3
11333: IFFALSE 11344
// RemoveUnit ( un ) ;
11335: LD_VAR 0 3
11339: PPUSH
11340: CALL_OW 64
// end ;
11344: PPOPN 3
11346: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
11347: LD_INT 0
11349: PPUSH
// case cmd of 301 :
11350: LD_VAR 0 1
11354: PUSH
11355: LD_INT 301
11357: DOUBLE
11358: EQUAL
11359: IFTRUE 11363
11361: GO 11395
11363: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
11364: LD_VAR 0 6
11368: PPUSH
11369: LD_VAR 0 7
11373: PPUSH
11374: LD_VAR 0 8
11378: PPUSH
11379: LD_VAR 0 4
11383: PPUSH
11384: LD_VAR 0 5
11388: PPUSH
11389: CALL 12596 0 5
11393: GO 11516
11395: LD_INT 302
11397: DOUBLE
11398: EQUAL
11399: IFTRUE 11403
11401: GO 11440
11403: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
11404: LD_VAR 0 6
11408: PPUSH
11409: LD_VAR 0 7
11413: PPUSH
11414: LD_VAR 0 8
11418: PPUSH
11419: LD_VAR 0 9
11423: PPUSH
11424: LD_VAR 0 4
11428: PPUSH
11429: LD_VAR 0 5
11433: PPUSH
11434: CALL 12687 0 6
11438: GO 11516
11440: LD_INT 303
11442: DOUBLE
11443: EQUAL
11444: IFTRUE 11448
11446: GO 11485
11448: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
11449: LD_VAR 0 6
11453: PPUSH
11454: LD_VAR 0 7
11458: PPUSH
11459: LD_VAR 0 8
11463: PPUSH
11464: LD_VAR 0 9
11468: PPUSH
11469: LD_VAR 0 4
11473: PPUSH
11474: LD_VAR 0 5
11478: PPUSH
11479: CALL 11521 0 6
11483: GO 11516
11485: LD_INT 304
11487: DOUBLE
11488: EQUAL
11489: IFTRUE 11493
11491: GO 11515
11493: POP
// hHackTeleport ( unit , x , y ) ; end ;
11494: LD_VAR 0 2
11498: PPUSH
11499: LD_VAR 0 4
11503: PPUSH
11504: LD_VAR 0 5
11508: PPUSH
11509: CALL 13280 0 3
11513: GO 11516
11515: POP
// end ;
11516: LD_VAR 0 12
11520: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
11521: LD_INT 0
11523: PPUSH
11524: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
11525: LD_VAR 0 1
11529: PUSH
11530: LD_INT 1
11532: LESS
11533: PUSH
11534: LD_VAR 0 1
11538: PUSH
11539: LD_INT 3
11541: GREATER
11542: OR
11543: PUSH
11544: LD_VAR 0 5
11548: PPUSH
11549: LD_VAR 0 6
11553: PPUSH
11554: CALL_OW 428
11558: OR
11559: IFFALSE 11563
// exit ;
11561: GO 12283
// uc_side := your_side ;
11563: LD_ADDR_OWVAR 20
11567: PUSH
11568: LD_OWVAR 2
11572: ST_TO_ADDR
// uc_nation := nation ;
11573: LD_ADDR_OWVAR 21
11577: PUSH
11578: LD_VAR 0 1
11582: ST_TO_ADDR
// bc_level = 1 ;
11583: LD_ADDR_OWVAR 43
11587: PUSH
11588: LD_INT 1
11590: ST_TO_ADDR
// case btype of 1 :
11591: LD_VAR 0 2
11595: PUSH
11596: LD_INT 1
11598: DOUBLE
11599: EQUAL
11600: IFTRUE 11604
11602: GO 11615
11604: POP
// bc_type := b_depot ; 2 :
11605: LD_ADDR_OWVAR 42
11609: PUSH
11610: LD_INT 0
11612: ST_TO_ADDR
11613: GO 12227
11615: LD_INT 2
11617: DOUBLE
11618: EQUAL
11619: IFTRUE 11623
11621: GO 11634
11623: POP
// bc_type := b_warehouse ; 3 :
11624: LD_ADDR_OWVAR 42
11628: PUSH
11629: LD_INT 1
11631: ST_TO_ADDR
11632: GO 12227
11634: LD_INT 3
11636: DOUBLE
11637: EQUAL
11638: IFTRUE 11642
11640: GO 11653
11642: POP
// bc_type := b_lab ; 4 .. 9 :
11643: LD_ADDR_OWVAR 42
11647: PUSH
11648: LD_INT 6
11650: ST_TO_ADDR
11651: GO 12227
11653: LD_INT 4
11655: DOUBLE
11656: GREATEREQUAL
11657: IFFALSE 11665
11659: LD_INT 9
11661: DOUBLE
11662: LESSEQUAL
11663: IFTRUE 11667
11665: GO 11719
11667: POP
// begin bc_type := b_lab_half ;
11668: LD_ADDR_OWVAR 42
11672: PUSH
11673: LD_INT 7
11675: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
11676: LD_ADDR_OWVAR 44
11680: PUSH
11681: LD_INT 10
11683: PUSH
11684: LD_INT 11
11686: PUSH
11687: LD_INT 12
11689: PUSH
11690: LD_INT 15
11692: PUSH
11693: LD_INT 14
11695: PUSH
11696: LD_INT 13
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: PUSH
11707: LD_VAR 0 2
11711: PUSH
11712: LD_INT 3
11714: MINUS
11715: ARRAY
11716: ST_TO_ADDR
// end ; 10 .. 13 :
11717: GO 12227
11719: LD_INT 10
11721: DOUBLE
11722: GREATEREQUAL
11723: IFFALSE 11731
11725: LD_INT 13
11727: DOUBLE
11728: LESSEQUAL
11729: IFTRUE 11733
11731: GO 11810
11733: POP
// begin bc_type := b_lab_full ;
11734: LD_ADDR_OWVAR 42
11738: PUSH
11739: LD_INT 8
11741: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
11742: LD_ADDR_OWVAR 44
11746: PUSH
11747: LD_INT 10
11749: PUSH
11750: LD_INT 12
11752: PUSH
11753: LD_INT 14
11755: PUSH
11756: LD_INT 13
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: PUSH
11765: LD_VAR 0 2
11769: PUSH
11770: LD_INT 9
11772: MINUS
11773: ARRAY
11774: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
11775: LD_ADDR_OWVAR 45
11779: PUSH
11780: LD_INT 11
11782: PUSH
11783: LD_INT 15
11785: PUSH
11786: LD_INT 12
11788: PUSH
11789: LD_INT 15
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: PUSH
11798: LD_VAR 0 2
11802: PUSH
11803: LD_INT 9
11805: MINUS
11806: ARRAY
11807: ST_TO_ADDR
// end ; 14 :
11808: GO 12227
11810: LD_INT 14
11812: DOUBLE
11813: EQUAL
11814: IFTRUE 11818
11816: GO 11829
11818: POP
// bc_type := b_workshop ; 15 :
11819: LD_ADDR_OWVAR 42
11823: PUSH
11824: LD_INT 2
11826: ST_TO_ADDR
11827: GO 12227
11829: LD_INT 15
11831: DOUBLE
11832: EQUAL
11833: IFTRUE 11837
11835: GO 11848
11837: POP
// bc_type := b_factory ; 16 :
11838: LD_ADDR_OWVAR 42
11842: PUSH
11843: LD_INT 3
11845: ST_TO_ADDR
11846: GO 12227
11848: LD_INT 16
11850: DOUBLE
11851: EQUAL
11852: IFTRUE 11856
11854: GO 11867
11856: POP
// bc_type := b_ext_gun ; 17 :
11857: LD_ADDR_OWVAR 42
11861: PUSH
11862: LD_INT 17
11864: ST_TO_ADDR
11865: GO 12227
11867: LD_INT 17
11869: DOUBLE
11870: EQUAL
11871: IFTRUE 11875
11873: GO 11903
11875: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
11876: LD_ADDR_OWVAR 42
11880: PUSH
11881: LD_INT 19
11883: PUSH
11884: LD_INT 23
11886: PUSH
11887: LD_INT 19
11889: PUSH
11890: EMPTY
11891: LIST
11892: LIST
11893: LIST
11894: PUSH
11895: LD_VAR 0 1
11899: ARRAY
11900: ST_TO_ADDR
11901: GO 12227
11903: LD_INT 18
11905: DOUBLE
11906: EQUAL
11907: IFTRUE 11911
11909: GO 11922
11911: POP
// bc_type := b_ext_radar ; 19 :
11912: LD_ADDR_OWVAR 42
11916: PUSH
11917: LD_INT 20
11919: ST_TO_ADDR
11920: GO 12227
11922: LD_INT 19
11924: DOUBLE
11925: EQUAL
11926: IFTRUE 11930
11928: GO 11941
11930: POP
// bc_type := b_ext_radio ; 20 :
11931: LD_ADDR_OWVAR 42
11935: PUSH
11936: LD_INT 22
11938: ST_TO_ADDR
11939: GO 12227
11941: LD_INT 20
11943: DOUBLE
11944: EQUAL
11945: IFTRUE 11949
11947: GO 11960
11949: POP
// bc_type := b_ext_siberium ; 21 :
11950: LD_ADDR_OWVAR 42
11954: PUSH
11955: LD_INT 21
11957: ST_TO_ADDR
11958: GO 12227
11960: LD_INT 21
11962: DOUBLE
11963: EQUAL
11964: IFTRUE 11968
11966: GO 11979
11968: POP
// bc_type := b_ext_computer ; 22 :
11969: LD_ADDR_OWVAR 42
11973: PUSH
11974: LD_INT 24
11976: ST_TO_ADDR
11977: GO 12227
11979: LD_INT 22
11981: DOUBLE
11982: EQUAL
11983: IFTRUE 11987
11985: GO 11998
11987: POP
// bc_type := b_ext_track ; 23 :
11988: LD_ADDR_OWVAR 42
11992: PUSH
11993: LD_INT 16
11995: ST_TO_ADDR
11996: GO 12227
11998: LD_INT 23
12000: DOUBLE
12001: EQUAL
12002: IFTRUE 12006
12004: GO 12017
12006: POP
// bc_type := b_ext_laser ; 24 :
12007: LD_ADDR_OWVAR 42
12011: PUSH
12012: LD_INT 25
12014: ST_TO_ADDR
12015: GO 12227
12017: LD_INT 24
12019: DOUBLE
12020: EQUAL
12021: IFTRUE 12025
12023: GO 12036
12025: POP
// bc_type := b_control_tower ; 25 :
12026: LD_ADDR_OWVAR 42
12030: PUSH
12031: LD_INT 36
12033: ST_TO_ADDR
12034: GO 12227
12036: LD_INT 25
12038: DOUBLE
12039: EQUAL
12040: IFTRUE 12044
12042: GO 12055
12044: POP
// bc_type := b_breastwork ; 26 :
12045: LD_ADDR_OWVAR 42
12049: PUSH
12050: LD_INT 31
12052: ST_TO_ADDR
12053: GO 12227
12055: LD_INT 26
12057: DOUBLE
12058: EQUAL
12059: IFTRUE 12063
12061: GO 12074
12063: POP
// bc_type := b_bunker ; 27 :
12064: LD_ADDR_OWVAR 42
12068: PUSH
12069: LD_INT 32
12071: ST_TO_ADDR
12072: GO 12227
12074: LD_INT 27
12076: DOUBLE
12077: EQUAL
12078: IFTRUE 12082
12080: GO 12093
12082: POP
// bc_type := b_turret ; 28 :
12083: LD_ADDR_OWVAR 42
12087: PUSH
12088: LD_INT 33
12090: ST_TO_ADDR
12091: GO 12227
12093: LD_INT 28
12095: DOUBLE
12096: EQUAL
12097: IFTRUE 12101
12099: GO 12112
12101: POP
// bc_type := b_armoury ; 29 :
12102: LD_ADDR_OWVAR 42
12106: PUSH
12107: LD_INT 4
12109: ST_TO_ADDR
12110: GO 12227
12112: LD_INT 29
12114: DOUBLE
12115: EQUAL
12116: IFTRUE 12120
12118: GO 12131
12120: POP
// bc_type := b_barracks ; 30 :
12121: LD_ADDR_OWVAR 42
12125: PUSH
12126: LD_INT 5
12128: ST_TO_ADDR
12129: GO 12227
12131: LD_INT 30
12133: DOUBLE
12134: EQUAL
12135: IFTRUE 12139
12137: GO 12150
12139: POP
// bc_type := b_solar_power ; 31 :
12140: LD_ADDR_OWVAR 42
12144: PUSH
12145: LD_INT 27
12147: ST_TO_ADDR
12148: GO 12227
12150: LD_INT 31
12152: DOUBLE
12153: EQUAL
12154: IFTRUE 12158
12156: GO 12169
12158: POP
// bc_type := b_oil_power ; 32 :
12159: LD_ADDR_OWVAR 42
12163: PUSH
12164: LD_INT 26
12166: ST_TO_ADDR
12167: GO 12227
12169: LD_INT 32
12171: DOUBLE
12172: EQUAL
12173: IFTRUE 12177
12175: GO 12188
12177: POP
// bc_type := b_siberite_power ; 33 :
12178: LD_ADDR_OWVAR 42
12182: PUSH
12183: LD_INT 28
12185: ST_TO_ADDR
12186: GO 12227
12188: LD_INT 33
12190: DOUBLE
12191: EQUAL
12192: IFTRUE 12196
12194: GO 12207
12196: POP
// bc_type := b_oil_mine ; 34 :
12197: LD_ADDR_OWVAR 42
12201: PUSH
12202: LD_INT 29
12204: ST_TO_ADDR
12205: GO 12227
12207: LD_INT 34
12209: DOUBLE
12210: EQUAL
12211: IFTRUE 12215
12213: GO 12226
12215: POP
// bc_type := b_siberite_mine ; end ;
12216: LD_ADDR_OWVAR 42
12220: PUSH
12221: LD_INT 30
12223: ST_TO_ADDR
12224: GO 12227
12226: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
12227: LD_ADDR_VAR 0 8
12231: PUSH
12232: LD_VAR 0 5
12236: PPUSH
12237: LD_VAR 0 6
12241: PPUSH
12242: LD_VAR 0 3
12246: PPUSH
12247: CALL_OW 47
12251: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
12252: LD_OWVAR 42
12256: PUSH
12257: LD_INT 32
12259: PUSH
12260: LD_INT 33
12262: PUSH
12263: EMPTY
12264: LIST
12265: LIST
12266: IN
12267: IFFALSE 12283
// PlaceWeaponTurret ( b , weapon ) ;
12269: LD_VAR 0 8
12273: PPUSH
12274: LD_VAR 0 4
12278: PPUSH
12279: CALL_OW 431
// end ;
12283: LD_VAR 0 7
12287: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
12288: LD_INT 0
12290: PPUSH
12291: PPUSH
12292: PPUSH
12293: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
12294: LD_ADDR_VAR 0 4
12298: PUSH
12299: LD_INT 22
12301: PUSH
12302: LD_OWVAR 2
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: PUSH
12311: LD_INT 2
12313: PUSH
12314: LD_INT 30
12316: PUSH
12317: LD_INT 0
12319: PUSH
12320: EMPTY
12321: LIST
12322: LIST
12323: PUSH
12324: LD_INT 30
12326: PUSH
12327: LD_INT 1
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: LIST
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: PPUSH
12343: CALL_OW 69
12347: ST_TO_ADDR
// if not tmp then
12348: LD_VAR 0 4
12352: NOT
12353: IFFALSE 12357
// exit ;
12355: GO 12416
// for i in tmp do
12357: LD_ADDR_VAR 0 2
12361: PUSH
12362: LD_VAR 0 4
12366: PUSH
12367: FOR_IN
12368: IFFALSE 12414
// for j = 1 to 3 do
12370: LD_ADDR_VAR 0 3
12374: PUSH
12375: DOUBLE
12376: LD_INT 1
12378: DEC
12379: ST_TO_ADDR
12380: LD_INT 3
12382: PUSH
12383: FOR_TO
12384: IFFALSE 12410
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
12386: LD_VAR 0 2
12390: PPUSH
12391: CALL_OW 274
12395: PPUSH
12396: LD_VAR 0 3
12400: PPUSH
12401: LD_INT 99999
12403: PPUSH
12404: CALL_OW 277
12408: GO 12383
12410: POP
12411: POP
12412: GO 12367
12414: POP
12415: POP
// end ;
12416: LD_VAR 0 1
12420: RET
// export function hHackSetLevel10 ; var i , j ; begin
12421: LD_INT 0
12423: PPUSH
12424: PPUSH
12425: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
12426: LD_ADDR_VAR 0 2
12430: PUSH
12431: LD_INT 21
12433: PUSH
12434: LD_INT 1
12436: PUSH
12437: EMPTY
12438: LIST
12439: LIST
12440: PPUSH
12441: CALL_OW 69
12445: PUSH
12446: FOR_IN
12447: IFFALSE 12499
// if IsSelected ( i ) then
12449: LD_VAR 0 2
12453: PPUSH
12454: CALL_OW 306
12458: IFFALSE 12497
// begin for j := 1 to 4 do
12460: LD_ADDR_VAR 0 3
12464: PUSH
12465: DOUBLE
12466: LD_INT 1
12468: DEC
12469: ST_TO_ADDR
12470: LD_INT 4
12472: PUSH
12473: FOR_TO
12474: IFFALSE 12495
// SetSkill ( i , j , 10 ) ;
12476: LD_VAR 0 2
12480: PPUSH
12481: LD_VAR 0 3
12485: PPUSH
12486: LD_INT 10
12488: PPUSH
12489: CALL_OW 237
12493: GO 12473
12495: POP
12496: POP
// end ;
12497: GO 12446
12499: POP
12500: POP
// end ;
12501: LD_VAR 0 1
12505: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
12506: LD_INT 0
12508: PPUSH
12509: PPUSH
12510: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
12511: LD_ADDR_VAR 0 2
12515: PUSH
12516: LD_INT 22
12518: PUSH
12519: LD_OWVAR 2
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: PUSH
12528: LD_INT 21
12530: PUSH
12531: LD_INT 1
12533: PUSH
12534: EMPTY
12535: LIST
12536: LIST
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PPUSH
12542: CALL_OW 69
12546: PUSH
12547: FOR_IN
12548: IFFALSE 12589
// begin for j := 1 to 4 do
12550: LD_ADDR_VAR 0 3
12554: PUSH
12555: DOUBLE
12556: LD_INT 1
12558: DEC
12559: ST_TO_ADDR
12560: LD_INT 4
12562: PUSH
12563: FOR_TO
12564: IFFALSE 12585
// SetSkill ( i , j , 10 ) ;
12566: LD_VAR 0 2
12570: PPUSH
12571: LD_VAR 0 3
12575: PPUSH
12576: LD_INT 10
12578: PPUSH
12579: CALL_OW 237
12583: GO 12563
12585: POP
12586: POP
// end ;
12587: GO 12547
12589: POP
12590: POP
// end ;
12591: LD_VAR 0 1
12595: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
12596: LD_INT 0
12598: PPUSH
// uc_side := your_side ;
12599: LD_ADDR_OWVAR 20
12603: PUSH
12604: LD_OWVAR 2
12608: ST_TO_ADDR
// uc_nation := nation ;
12609: LD_ADDR_OWVAR 21
12613: PUSH
12614: LD_VAR 0 1
12618: ST_TO_ADDR
// InitHc ;
12619: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
12623: LD_INT 0
12625: PPUSH
12626: LD_VAR 0 2
12630: PPUSH
12631: LD_VAR 0 3
12635: PPUSH
12636: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
12640: LD_VAR 0 4
12644: PPUSH
12645: LD_VAR 0 5
12649: PPUSH
12650: CALL_OW 428
12654: PUSH
12655: LD_INT 0
12657: EQUAL
12658: IFFALSE 12682
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
12660: CALL_OW 44
12664: PPUSH
12665: LD_VAR 0 4
12669: PPUSH
12670: LD_VAR 0 5
12674: PPUSH
12675: LD_INT 1
12677: PPUSH
12678: CALL_OW 48
// end ;
12682: LD_VAR 0 6
12686: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
12687: LD_INT 0
12689: PPUSH
12690: PPUSH
// uc_side := your_side ;
12691: LD_ADDR_OWVAR 20
12695: PUSH
12696: LD_OWVAR 2
12700: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
12701: LD_VAR 0 1
12705: PUSH
12706: LD_INT 1
12708: PUSH
12709: LD_INT 2
12711: PUSH
12712: LD_INT 3
12714: PUSH
12715: LD_INT 4
12717: PUSH
12718: LD_INT 5
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: IN
12728: IFFALSE 12740
// uc_nation := nation_american else
12730: LD_ADDR_OWVAR 21
12734: PUSH
12735: LD_INT 1
12737: ST_TO_ADDR
12738: GO 12783
// if chassis in [ 11 , 12 , 13 , 14 ] then
12740: LD_VAR 0 1
12744: PUSH
12745: LD_INT 11
12747: PUSH
12748: LD_INT 12
12750: PUSH
12751: LD_INT 13
12753: PUSH
12754: LD_INT 14
12756: PUSH
12757: EMPTY
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: IN
12763: IFFALSE 12775
// uc_nation := nation_arabian else
12765: LD_ADDR_OWVAR 21
12769: PUSH
12770: LD_INT 2
12772: ST_TO_ADDR
12773: GO 12783
// uc_nation := nation_russian ;
12775: LD_ADDR_OWVAR 21
12779: PUSH
12780: LD_INT 3
12782: ST_TO_ADDR
// vc_chassis := chassis ;
12783: LD_ADDR_OWVAR 37
12787: PUSH
12788: LD_VAR 0 1
12792: ST_TO_ADDR
// vc_engine := engine ;
12793: LD_ADDR_OWVAR 39
12797: PUSH
12798: LD_VAR 0 2
12802: ST_TO_ADDR
// vc_control := control ;
12803: LD_ADDR_OWVAR 38
12807: PUSH
12808: LD_VAR 0 3
12812: ST_TO_ADDR
// vc_weapon := weapon ;
12813: LD_ADDR_OWVAR 40
12817: PUSH
12818: LD_VAR 0 4
12822: ST_TO_ADDR
// un := CreateVehicle ;
12823: LD_ADDR_VAR 0 8
12827: PUSH
12828: CALL_OW 45
12832: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
12833: LD_VAR 0 8
12837: PPUSH
12838: LD_INT 0
12840: PPUSH
12841: LD_INT 5
12843: PPUSH
12844: CALL_OW 12
12848: PPUSH
12849: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
12853: LD_VAR 0 8
12857: PPUSH
12858: LD_VAR 0 5
12862: PPUSH
12863: LD_VAR 0 6
12867: PPUSH
12868: LD_INT 1
12870: PPUSH
12871: CALL_OW 48
// end ;
12875: LD_VAR 0 7
12879: RET
// export hInvincible ; every 1 do
12880: GO 12882
12882: DISABLE
// hInvincible := [ ] ;
12883: LD_ADDR_EXP 71
12887: PUSH
12888: EMPTY
12889: ST_TO_ADDR
12890: END
// every 10 do var i ;
12891: GO 12893
12893: DISABLE
12894: LD_INT 0
12896: PPUSH
// begin enable ;
12897: ENABLE
// if not hInvincible then
12898: LD_EXP 71
12902: NOT
12903: IFFALSE 12907
// exit ;
12905: GO 12951
// for i in hInvincible do
12907: LD_ADDR_VAR 0 1
12911: PUSH
12912: LD_EXP 71
12916: PUSH
12917: FOR_IN
12918: IFFALSE 12949
// if GetLives ( i ) < 1000 then
12920: LD_VAR 0 1
12924: PPUSH
12925: CALL_OW 256
12929: PUSH
12930: LD_INT 1000
12932: LESS
12933: IFFALSE 12947
// SetLives ( i , 1000 ) ;
12935: LD_VAR 0 1
12939: PPUSH
12940: LD_INT 1000
12942: PPUSH
12943: CALL_OW 234
12947: GO 12917
12949: POP
12950: POP
// end ;
12951: PPOPN 1
12953: END
// export function hHackInvincible ; var i ; begin
12954: LD_INT 0
12956: PPUSH
12957: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
12958: LD_ADDR_VAR 0 2
12962: PUSH
12963: LD_INT 2
12965: PUSH
12966: LD_INT 21
12968: PUSH
12969: LD_INT 1
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: LD_INT 21
12978: PUSH
12979: LD_INT 2
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: LIST
12990: PPUSH
12991: CALL_OW 69
12995: PUSH
12996: FOR_IN
12997: IFFALSE 13058
// if IsSelected ( i ) then
12999: LD_VAR 0 2
13003: PPUSH
13004: CALL_OW 306
13008: IFFALSE 13056
// begin if i in hInvincible then
13010: LD_VAR 0 2
13014: PUSH
13015: LD_EXP 71
13019: IN
13020: IFFALSE 13040
// hInvincible := hInvincible diff i else
13022: LD_ADDR_EXP 71
13026: PUSH
13027: LD_EXP 71
13031: PUSH
13032: LD_VAR 0 2
13036: DIFF
13037: ST_TO_ADDR
13038: GO 13056
// hInvincible := hInvincible union i ;
13040: LD_ADDR_EXP 71
13044: PUSH
13045: LD_EXP 71
13049: PUSH
13050: LD_VAR 0 2
13054: UNION
13055: ST_TO_ADDR
// end ;
13056: GO 12996
13058: POP
13059: POP
// end ;
13060: LD_VAR 0 1
13064: RET
// export function hHackInvisible ; var i , j ; begin
13065: LD_INT 0
13067: PPUSH
13068: PPUSH
13069: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
13070: LD_ADDR_VAR 0 2
13074: PUSH
13075: LD_INT 21
13077: PUSH
13078: LD_INT 1
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PPUSH
13085: CALL_OW 69
13089: PUSH
13090: FOR_IN
13091: IFFALSE 13115
// if IsSelected ( i ) then
13093: LD_VAR 0 2
13097: PPUSH
13098: CALL_OW 306
13102: IFFALSE 13113
// ComForceInvisible ( i ) ;
13104: LD_VAR 0 2
13108: PPUSH
13109: CALL_OW 496
13113: GO 13090
13115: POP
13116: POP
// end ;
13117: LD_VAR 0 1
13121: RET
// export function hHackChangeYourSide ; begin
13122: LD_INT 0
13124: PPUSH
// if your_side = 8 then
13125: LD_OWVAR 2
13129: PUSH
13130: LD_INT 8
13132: EQUAL
13133: IFFALSE 13145
// your_side := 0 else
13135: LD_ADDR_OWVAR 2
13139: PUSH
13140: LD_INT 0
13142: ST_TO_ADDR
13143: GO 13159
// your_side := your_side + 1 ;
13145: LD_ADDR_OWVAR 2
13149: PUSH
13150: LD_OWVAR 2
13154: PUSH
13155: LD_INT 1
13157: PLUS
13158: ST_TO_ADDR
// end ;
13159: LD_VAR 0 1
13163: RET
// export function hHackChangeUnitSide ; var i , j ; begin
13164: LD_INT 0
13166: PPUSH
13167: PPUSH
13168: PPUSH
// for i in all_units do
13169: LD_ADDR_VAR 0 2
13173: PUSH
13174: LD_OWVAR 3
13178: PUSH
13179: FOR_IN
13180: IFFALSE 13258
// if IsSelected ( i ) then
13182: LD_VAR 0 2
13186: PPUSH
13187: CALL_OW 306
13191: IFFALSE 13256
// begin j := GetSide ( i ) ;
13193: LD_ADDR_VAR 0 3
13197: PUSH
13198: LD_VAR 0 2
13202: PPUSH
13203: CALL_OW 255
13207: ST_TO_ADDR
// if j = 8 then
13208: LD_VAR 0 3
13212: PUSH
13213: LD_INT 8
13215: EQUAL
13216: IFFALSE 13228
// j := 0 else
13218: LD_ADDR_VAR 0 3
13222: PUSH
13223: LD_INT 0
13225: ST_TO_ADDR
13226: GO 13242
// j := j + 1 ;
13228: LD_ADDR_VAR 0 3
13232: PUSH
13233: LD_VAR 0 3
13237: PUSH
13238: LD_INT 1
13240: PLUS
13241: ST_TO_ADDR
// SetSide ( i , j ) ;
13242: LD_VAR 0 2
13246: PPUSH
13247: LD_VAR 0 3
13251: PPUSH
13252: CALL_OW 235
// end ;
13256: GO 13179
13258: POP
13259: POP
// end ;
13260: LD_VAR 0 1
13264: RET
// export function hHackFog ; begin
13265: LD_INT 0
13267: PPUSH
// FogOff ( true ) ;
13268: LD_INT 1
13270: PPUSH
13271: CALL_OW 344
// end ;
13275: LD_VAR 0 1
13279: RET
// export function hHackTeleport ( unit , x , y ) ; begin
13280: LD_INT 0
13282: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
13283: LD_VAR 0 1
13287: PPUSH
13288: LD_VAR 0 2
13292: PPUSH
13293: LD_VAR 0 3
13297: PPUSH
13298: LD_INT 1
13300: PPUSH
13301: LD_INT 1
13303: PPUSH
13304: CALL_OW 483
// CenterOnXY ( x , y ) ;
13308: LD_VAR 0 2
13312: PPUSH
13313: LD_VAR 0 3
13317: PPUSH
13318: CALL_OW 84
// end ; end_of_file
13322: LD_VAR 0 4
13326: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
13327: LD_VAR 0 1
13331: PUSH
13332: LD_INT 200
13334: DOUBLE
13335: GREATEREQUAL
13336: IFFALSE 13344
13338: LD_INT 299
13340: DOUBLE
13341: LESSEQUAL
13342: IFTRUE 13346
13344: GO 13378
13346: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
13347: LD_VAR 0 1
13351: PPUSH
13352: LD_VAR 0 2
13356: PPUSH
13357: LD_VAR 0 3
13361: PPUSH
13362: LD_VAR 0 4
13366: PPUSH
13367: LD_VAR 0 5
13371: PPUSH
13372: CALL 13622 0 5
13376: GO 13455
13378: LD_INT 300
13380: DOUBLE
13381: GREATEREQUAL
13382: IFFALSE 13390
13384: LD_INT 399
13386: DOUBLE
13387: LESSEQUAL
13388: IFTRUE 13392
13390: GO 13454
13392: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
13393: LD_VAR 0 1
13397: PPUSH
13398: LD_VAR 0 2
13402: PPUSH
13403: LD_VAR 0 3
13407: PPUSH
13408: LD_VAR 0 4
13412: PPUSH
13413: LD_VAR 0 5
13417: PPUSH
13418: LD_VAR 0 6
13422: PPUSH
13423: LD_VAR 0 7
13427: PPUSH
13428: LD_VAR 0 8
13432: PPUSH
13433: LD_VAR 0 9
13437: PPUSH
13438: LD_VAR 0 10
13442: PPUSH
13443: LD_VAR 0 11
13447: PPUSH
13448: CALL 11347 0 11
13452: GO 13455
13454: POP
// end ;
13455: PPOPN 11
13457: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
13458: LD_VAR 0 1
13462: PPUSH
13463: LD_VAR 0 2
13467: PPUSH
13468: LD_VAR 0 3
13472: PPUSH
13473: LD_VAR 0 4
13477: PPUSH
13478: LD_VAR 0 5
13482: PPUSH
13483: CALL 13604 0 5
// end ; end_of_file
13487: PPOPN 5
13489: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
13490: LD_INT 0
13492: PPUSH
13493: PPUSH
13494: PPUSH
13495: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL_OW 264
13505: PUSH
13506: LD_EXP 5
13510: EQUAL
13511: IFFALSE 13583
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
13513: LD_INT 68
13515: PPUSH
13516: LD_VAR 0 1
13520: PPUSH
13521: CALL_OW 255
13525: PPUSH
13526: CALL_OW 321
13530: PUSH
13531: LD_INT 2
13533: EQUAL
13534: IFFALSE 13546
// eff := 70 else
13536: LD_ADDR_VAR 0 4
13540: PUSH
13541: LD_INT 70
13543: ST_TO_ADDR
13544: GO 13554
// eff := 30 ;
13546: LD_ADDR_VAR 0 4
13550: PUSH
13551: LD_INT 30
13553: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
13554: LD_VAR 0 1
13558: PPUSH
13559: CALL_OW 250
13563: PPUSH
13564: LD_VAR 0 1
13568: PPUSH
13569: CALL_OW 251
13573: PPUSH
13574: LD_VAR 0 4
13578: PPUSH
13579: CALL_OW 495
// end ; end ;
13583: LD_VAR 0 2
13587: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
13588: LD_INT 0
13590: PPUSH
// end ;
13591: LD_VAR 0 4
13595: RET
// export function SOS_Command ( cmd ) ; begin
13596: LD_INT 0
13598: PPUSH
// end ;
13599: LD_VAR 0 2
13603: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
13604: LD_INT 0
13606: PPUSH
// if cmd = 121 then
13607: LD_VAR 0 1
13611: PUSH
13612: LD_INT 121
13614: EQUAL
13615: IFFALSE 13617
// end ;
13617: LD_VAR 0 6
13621: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
13622: LD_INT 0
13624: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
13625: LD_VAR 0 1
13629: PUSH
13630: LD_INT 250
13632: EQUAL
13633: PUSH
13634: LD_VAR 0 2
13638: PPUSH
13639: CALL_OW 264
13643: PUSH
13644: LD_EXP 8
13648: EQUAL
13649: AND
13650: IFFALSE 13671
// MinerPlaceMine ( unit , x , y ) ;
13652: LD_VAR 0 2
13656: PPUSH
13657: LD_VAR 0 4
13661: PPUSH
13662: LD_VAR 0 5
13666: PPUSH
13667: CALL 16020 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
13671: LD_VAR 0 1
13675: PUSH
13676: LD_INT 251
13678: EQUAL
13679: PUSH
13680: LD_VAR 0 2
13684: PPUSH
13685: CALL_OW 264
13689: PUSH
13690: LD_EXP 8
13694: EQUAL
13695: AND
13696: IFFALSE 13717
// MinerDetonateMine ( unit , x , y ) ;
13698: LD_VAR 0 2
13702: PPUSH
13703: LD_VAR 0 4
13707: PPUSH
13708: LD_VAR 0 5
13712: PPUSH
13713: CALL 16297 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
13717: LD_VAR 0 1
13721: PUSH
13722: LD_INT 252
13724: EQUAL
13725: PUSH
13726: LD_VAR 0 2
13730: PPUSH
13731: CALL_OW 264
13735: PUSH
13736: LD_EXP 8
13740: EQUAL
13741: AND
13742: IFFALSE 13763
// MinerCreateMinefield ( unit , x , y ) ;
13744: LD_VAR 0 2
13748: PPUSH
13749: LD_VAR 0 4
13753: PPUSH
13754: LD_VAR 0 5
13758: PPUSH
13759: CALL 16714 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
13763: LD_VAR 0 1
13767: PUSH
13768: LD_INT 253
13770: EQUAL
13771: PUSH
13772: LD_VAR 0 2
13776: PPUSH
13777: CALL_OW 257
13781: PUSH
13782: LD_INT 5
13784: EQUAL
13785: AND
13786: IFFALSE 13807
// ComBinocular ( unit , x , y ) ;
13788: LD_VAR 0 2
13792: PPUSH
13793: LD_VAR 0 4
13797: PPUSH
13798: LD_VAR 0 5
13802: PPUSH
13803: CALL 17085 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
13807: LD_VAR 0 1
13811: PUSH
13812: LD_INT 254
13814: EQUAL
13815: PUSH
13816: LD_VAR 0 2
13820: PPUSH
13821: CALL_OW 264
13825: PUSH
13826: LD_EXP 3
13830: EQUAL
13831: AND
13832: PUSH
13833: LD_VAR 0 3
13837: PPUSH
13838: CALL_OW 263
13842: PUSH
13843: LD_INT 3
13845: EQUAL
13846: AND
13847: IFFALSE 13863
// HackDestroyVehicle ( unit , selectedUnit ) ;
13849: LD_VAR 0 2
13853: PPUSH
13854: LD_VAR 0 3
13858: PPUSH
13859: CALL 15380 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
13863: LD_VAR 0 1
13867: PUSH
13868: LD_INT 255
13870: EQUAL
13871: PUSH
13872: LD_VAR 0 2
13876: PPUSH
13877: CALL_OW 264
13881: PUSH
13882: LD_INT 14
13884: PUSH
13885: LD_INT 53
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: IN
13892: AND
13893: PUSH
13894: LD_VAR 0 4
13898: PPUSH
13899: LD_VAR 0 5
13903: PPUSH
13904: CALL_OW 488
13908: AND
13909: IFFALSE 13933
// CutTreeXYR ( unit , x , y , 12 ) ;
13911: LD_VAR 0 2
13915: PPUSH
13916: LD_VAR 0 4
13920: PPUSH
13921: LD_VAR 0 5
13925: PPUSH
13926: LD_INT 12
13928: PPUSH
13929: CALL 13946 0 4
// end ;
13933: LD_VAR 0 6
13937: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
13938: LD_INT 0
13940: PPUSH
// end ;
13941: LD_VAR 0 4
13945: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
13946: LD_INT 0
13948: PPUSH
13949: PPUSH
13950: PPUSH
13951: PPUSH
13952: PPUSH
13953: PPUSH
13954: PPUSH
13955: PPUSH
13956: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
13957: LD_VAR 0 1
13961: NOT
13962: PUSH
13963: LD_VAR 0 2
13967: PPUSH
13968: LD_VAR 0 3
13972: PPUSH
13973: CALL_OW 488
13977: NOT
13978: OR
13979: PUSH
13980: LD_VAR 0 4
13984: NOT
13985: OR
13986: IFFALSE 13990
// exit ;
13988: GO 14330
// list := [ ] ;
13990: LD_ADDR_VAR 0 13
13994: PUSH
13995: EMPTY
13996: ST_TO_ADDR
// if x - r < 0 then
13997: LD_VAR 0 2
14001: PUSH
14002: LD_VAR 0 4
14006: MINUS
14007: PUSH
14008: LD_INT 0
14010: LESS
14011: IFFALSE 14023
// min_x := 0 else
14013: LD_ADDR_VAR 0 7
14017: PUSH
14018: LD_INT 0
14020: ST_TO_ADDR
14021: GO 14039
// min_x := x - r ;
14023: LD_ADDR_VAR 0 7
14027: PUSH
14028: LD_VAR 0 2
14032: PUSH
14033: LD_VAR 0 4
14037: MINUS
14038: ST_TO_ADDR
// if y - r < 0 then
14039: LD_VAR 0 3
14043: PUSH
14044: LD_VAR 0 4
14048: MINUS
14049: PUSH
14050: LD_INT 0
14052: LESS
14053: IFFALSE 14065
// min_y := 0 else
14055: LD_ADDR_VAR 0 8
14059: PUSH
14060: LD_INT 0
14062: ST_TO_ADDR
14063: GO 14081
// min_y := y - r ;
14065: LD_ADDR_VAR 0 8
14069: PUSH
14070: LD_VAR 0 3
14074: PUSH
14075: LD_VAR 0 4
14079: MINUS
14080: ST_TO_ADDR
// max_x := x + r ;
14081: LD_ADDR_VAR 0 9
14085: PUSH
14086: LD_VAR 0 2
14090: PUSH
14091: LD_VAR 0 4
14095: PLUS
14096: ST_TO_ADDR
// max_y := y + r ;
14097: LD_ADDR_VAR 0 10
14101: PUSH
14102: LD_VAR 0 3
14106: PUSH
14107: LD_VAR 0 4
14111: PLUS
14112: ST_TO_ADDR
// for _x = min_x to max_x do
14113: LD_ADDR_VAR 0 11
14117: PUSH
14118: DOUBLE
14119: LD_VAR 0 7
14123: DEC
14124: ST_TO_ADDR
14125: LD_VAR 0 9
14129: PUSH
14130: FOR_TO
14131: IFFALSE 14248
// for _y = min_y to max_y do
14133: LD_ADDR_VAR 0 12
14137: PUSH
14138: DOUBLE
14139: LD_VAR 0 8
14143: DEC
14144: ST_TO_ADDR
14145: LD_VAR 0 10
14149: PUSH
14150: FOR_TO
14151: IFFALSE 14244
// begin if not ValidHex ( _x , _y ) then
14153: LD_VAR 0 11
14157: PPUSH
14158: LD_VAR 0 12
14162: PPUSH
14163: CALL_OW 488
14167: NOT
14168: IFFALSE 14172
// continue ;
14170: GO 14150
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
14172: LD_VAR 0 11
14176: PPUSH
14177: LD_VAR 0 12
14181: PPUSH
14182: CALL_OW 351
14186: PUSH
14187: LD_VAR 0 11
14191: PPUSH
14192: LD_VAR 0 12
14196: PPUSH
14197: CALL_OW 554
14201: AND
14202: IFFALSE 14242
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
14204: LD_ADDR_VAR 0 13
14208: PUSH
14209: LD_VAR 0 13
14213: PPUSH
14214: LD_VAR 0 13
14218: PUSH
14219: LD_INT 1
14221: PLUS
14222: PPUSH
14223: LD_VAR 0 11
14227: PUSH
14228: LD_VAR 0 12
14232: PUSH
14233: EMPTY
14234: LIST
14235: LIST
14236: PPUSH
14237: CALL_OW 2
14241: ST_TO_ADDR
// end ;
14242: GO 14150
14244: POP
14245: POP
14246: GO 14130
14248: POP
14249: POP
// if not list then
14250: LD_VAR 0 13
14254: NOT
14255: IFFALSE 14259
// exit ;
14257: GO 14330
// for i in list do
14259: LD_ADDR_VAR 0 6
14263: PUSH
14264: LD_VAR 0 13
14268: PUSH
14269: FOR_IN
14270: IFFALSE 14328
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
14272: LD_VAR 0 1
14276: PPUSH
14277: LD_STRING M
14279: PUSH
14280: LD_VAR 0 6
14284: PUSH
14285: LD_INT 1
14287: ARRAY
14288: PUSH
14289: LD_VAR 0 6
14293: PUSH
14294: LD_INT 2
14296: ARRAY
14297: PUSH
14298: LD_INT 0
14300: PUSH
14301: LD_INT 0
14303: PUSH
14304: LD_INT 0
14306: PUSH
14307: LD_INT 0
14309: PUSH
14310: EMPTY
14311: LIST
14312: LIST
14313: LIST
14314: LIST
14315: LIST
14316: LIST
14317: LIST
14318: PUSH
14319: EMPTY
14320: LIST
14321: PPUSH
14322: CALL_OW 447
14326: GO 14269
14328: POP
14329: POP
// end ;
14330: LD_VAR 0 5
14334: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
14335: LD_EXP 74
14339: NOT
14340: IFFALSE 14390
14342: GO 14344
14344: DISABLE
// begin initHack := true ;
14345: LD_ADDR_EXP 74
14349: PUSH
14350: LD_INT 1
14352: ST_TO_ADDR
// hackTanks := [ ] ;
14353: LD_ADDR_EXP 75
14357: PUSH
14358: EMPTY
14359: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
14360: LD_ADDR_EXP 76
14364: PUSH
14365: EMPTY
14366: ST_TO_ADDR
// hackLimit := 3 ;
14367: LD_ADDR_EXP 77
14371: PUSH
14372: LD_INT 3
14374: ST_TO_ADDR
// hackDist := 12 ;
14375: LD_ADDR_EXP 78
14379: PUSH
14380: LD_INT 12
14382: ST_TO_ADDR
// hackCounter := [ ] ;
14383: LD_ADDR_EXP 79
14387: PUSH
14388: EMPTY
14389: ST_TO_ADDR
// end ;
14390: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
14391: LD_EXP 74
14395: PUSH
14396: LD_INT 34
14398: PUSH
14399: LD_EXP 3
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: PPUSH
14408: CALL_OW 69
14412: AND
14413: IFFALSE 14668
14415: GO 14417
14417: DISABLE
14418: LD_INT 0
14420: PPUSH
14421: PPUSH
// begin enable ;
14422: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
14423: LD_ADDR_VAR 0 1
14427: PUSH
14428: LD_INT 34
14430: PUSH
14431: LD_EXP 3
14435: PUSH
14436: EMPTY
14437: LIST
14438: LIST
14439: PPUSH
14440: CALL_OW 69
14444: PUSH
14445: FOR_IN
14446: IFFALSE 14666
// begin if not i in hackTanks then
14448: LD_VAR 0 1
14452: PUSH
14453: LD_EXP 75
14457: IN
14458: NOT
14459: IFFALSE 14542
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
14461: LD_ADDR_EXP 75
14465: PUSH
14466: LD_EXP 75
14470: PPUSH
14471: LD_EXP 75
14475: PUSH
14476: LD_INT 1
14478: PLUS
14479: PPUSH
14480: LD_VAR 0 1
14484: PPUSH
14485: CALL_OW 1
14489: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
14490: LD_ADDR_EXP 76
14494: PUSH
14495: LD_EXP 76
14499: PPUSH
14500: LD_EXP 76
14504: PUSH
14505: LD_INT 1
14507: PLUS
14508: PPUSH
14509: EMPTY
14510: PPUSH
14511: CALL_OW 1
14515: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
14516: LD_ADDR_EXP 79
14520: PUSH
14521: LD_EXP 79
14525: PPUSH
14526: LD_EXP 79
14530: PUSH
14531: LD_INT 1
14533: PLUS
14534: PPUSH
14535: EMPTY
14536: PPUSH
14537: CALL_OW 1
14541: ST_TO_ADDR
// end ; if not IsOk ( i ) then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 302
14551: NOT
14552: IFFALSE 14565
// begin HackUnlinkAll ( i ) ;
14554: LD_VAR 0 1
14558: PPUSH
14559: CALL 14671 0 1
// continue ;
14563: GO 14445
// end ; HackCheckCapturedStatus ( i ) ;
14565: LD_VAR 0 1
14569: PPUSH
14570: CALL 15114 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
14574: LD_ADDR_VAR 0 2
14578: PUSH
14579: LD_INT 81
14581: PUSH
14582: LD_VAR 0 1
14586: PPUSH
14587: CALL_OW 255
14591: PUSH
14592: EMPTY
14593: LIST
14594: LIST
14595: PUSH
14596: LD_INT 33
14598: PUSH
14599: LD_INT 3
14601: PUSH
14602: EMPTY
14603: LIST
14604: LIST
14605: PUSH
14606: LD_INT 91
14608: PUSH
14609: LD_VAR 0 1
14613: PUSH
14614: LD_EXP 78
14618: PUSH
14619: EMPTY
14620: LIST
14621: LIST
14622: LIST
14623: PUSH
14624: LD_INT 50
14626: PUSH
14627: EMPTY
14628: LIST
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: PPUSH
14636: CALL_OW 69
14640: ST_TO_ADDR
// if not tmp then
14641: LD_VAR 0 2
14645: NOT
14646: IFFALSE 14650
// continue ;
14648: GO 14445
// HackLink ( i , tmp ) ;
14650: LD_VAR 0 1
14654: PPUSH
14655: LD_VAR 0 2
14659: PPUSH
14660: CALL 14807 0 2
// end ;
14664: GO 14445
14666: POP
14667: POP
// end ;
14668: PPOPN 2
14670: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
14671: LD_INT 0
14673: PPUSH
14674: PPUSH
14675: PPUSH
// if not hack in hackTanks then
14676: LD_VAR 0 1
14680: PUSH
14681: LD_EXP 75
14685: IN
14686: NOT
14687: IFFALSE 14691
// exit ;
14689: GO 14802
// index := GetElementIndex ( hackTanks , hack ) ;
14691: LD_ADDR_VAR 0 4
14695: PUSH
14696: LD_EXP 75
14700: PPUSH
14701: LD_VAR 0 1
14705: PPUSH
14706: CALL 22236 0 2
14710: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
14711: LD_EXP 76
14715: PUSH
14716: LD_VAR 0 4
14720: ARRAY
14721: IFFALSE 14802
// begin for i in hackTanksCaptured [ index ] do
14723: LD_ADDR_VAR 0 3
14727: PUSH
14728: LD_EXP 76
14732: PUSH
14733: LD_VAR 0 4
14737: ARRAY
14738: PUSH
14739: FOR_IN
14740: IFFALSE 14766
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
14742: LD_VAR 0 3
14746: PUSH
14747: LD_INT 1
14749: ARRAY
14750: PPUSH
14751: LD_VAR 0 3
14755: PUSH
14756: LD_INT 2
14758: ARRAY
14759: PPUSH
14760: CALL_OW 235
14764: GO 14739
14766: POP
14767: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
14768: LD_ADDR_EXP 76
14772: PUSH
14773: LD_EXP 76
14777: PPUSH
14778: LD_VAR 0 4
14782: PPUSH
14783: EMPTY
14784: PPUSH
14785: CALL_OW 1
14789: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
14790: LD_VAR 0 1
14794: PPUSH
14795: LD_INT 0
14797: PPUSH
14798: CALL_OW 505
// end ; end ;
14802: LD_VAR 0 2
14806: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
14807: LD_INT 0
14809: PPUSH
14810: PPUSH
14811: PPUSH
// if not hack in hackTanks or not vehicles then
14812: LD_VAR 0 1
14816: PUSH
14817: LD_EXP 75
14821: IN
14822: NOT
14823: PUSH
14824: LD_VAR 0 2
14828: NOT
14829: OR
14830: IFFALSE 14834
// exit ;
14832: GO 15109
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
14834: LD_ADDR_VAR 0 2
14838: PUSH
14839: LD_VAR 0 1
14843: PPUSH
14844: LD_VAR 0 2
14848: PPUSH
14849: LD_INT 1
14851: PPUSH
14852: LD_INT 1
14854: PPUSH
14855: CALL 22886 0 4
14859: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
14860: LD_ADDR_VAR 0 5
14864: PUSH
14865: LD_EXP 75
14869: PPUSH
14870: LD_VAR 0 1
14874: PPUSH
14875: CALL 22236 0 2
14879: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
14880: LD_EXP 76
14884: PUSH
14885: LD_VAR 0 5
14889: ARRAY
14890: PUSH
14891: LD_EXP 77
14895: LESS
14896: IFFALSE 15085
// begin for i := 1 to vehicles do
14898: LD_ADDR_VAR 0 4
14902: PUSH
14903: DOUBLE
14904: LD_INT 1
14906: DEC
14907: ST_TO_ADDR
14908: LD_VAR 0 2
14912: PUSH
14913: FOR_TO
14914: IFFALSE 15083
// begin if hackTanksCaptured [ index ] = hackLimit then
14916: LD_EXP 76
14920: PUSH
14921: LD_VAR 0 5
14925: ARRAY
14926: PUSH
14927: LD_EXP 77
14931: EQUAL
14932: IFFALSE 14936
// break ;
14934: GO 15083
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
14936: LD_ADDR_EXP 79
14940: PUSH
14941: LD_EXP 79
14945: PPUSH
14946: LD_VAR 0 5
14950: PPUSH
14951: LD_EXP 79
14955: PUSH
14956: LD_VAR 0 5
14960: ARRAY
14961: PUSH
14962: LD_INT 1
14964: PLUS
14965: PPUSH
14966: CALL_OW 1
14970: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
14971: LD_ADDR_EXP 76
14975: PUSH
14976: LD_EXP 76
14980: PPUSH
14981: LD_VAR 0 5
14985: PUSH
14986: LD_EXP 76
14990: PUSH
14991: LD_VAR 0 5
14995: ARRAY
14996: PUSH
14997: LD_INT 1
14999: PLUS
15000: PUSH
15001: EMPTY
15002: LIST
15003: LIST
15004: PPUSH
15005: LD_VAR 0 2
15009: PUSH
15010: LD_VAR 0 4
15014: ARRAY
15015: PUSH
15016: LD_VAR 0 2
15020: PUSH
15021: LD_VAR 0 4
15025: ARRAY
15026: PPUSH
15027: CALL_OW 255
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: PPUSH
15036: CALL 22451 0 3
15040: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
15041: LD_VAR 0 2
15045: PUSH
15046: LD_VAR 0 4
15050: ARRAY
15051: PPUSH
15052: LD_VAR 0 1
15056: PPUSH
15057: CALL_OW 255
15061: PPUSH
15062: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
15066: LD_VAR 0 2
15070: PUSH
15071: LD_VAR 0 4
15075: ARRAY
15076: PPUSH
15077: CALL_OW 141
// end ;
15081: GO 14913
15083: POP
15084: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
15085: LD_VAR 0 1
15089: PPUSH
15090: LD_EXP 76
15094: PUSH
15095: LD_VAR 0 5
15099: ARRAY
15100: PUSH
15101: LD_INT 0
15103: PLUS
15104: PPUSH
15105: CALL_OW 505
// end ;
15109: LD_VAR 0 3
15113: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
15114: LD_INT 0
15116: PPUSH
15117: PPUSH
15118: PPUSH
15119: PPUSH
// if not hack in hackTanks then
15120: LD_VAR 0 1
15124: PUSH
15125: LD_EXP 75
15129: IN
15130: NOT
15131: IFFALSE 15135
// exit ;
15133: GO 15375
// index := GetElementIndex ( hackTanks , hack ) ;
15135: LD_ADDR_VAR 0 4
15139: PUSH
15140: LD_EXP 75
15144: PPUSH
15145: LD_VAR 0 1
15149: PPUSH
15150: CALL 22236 0 2
15154: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
15155: LD_ADDR_VAR 0 3
15159: PUSH
15160: DOUBLE
15161: LD_EXP 76
15165: PUSH
15166: LD_VAR 0 4
15170: ARRAY
15171: INC
15172: ST_TO_ADDR
15173: LD_INT 1
15175: PUSH
15176: FOR_DOWNTO
15177: IFFALSE 15349
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
15179: LD_ADDR_VAR 0 5
15183: PUSH
15184: LD_EXP 76
15188: PUSH
15189: LD_VAR 0 4
15193: ARRAY
15194: PUSH
15195: LD_VAR 0 3
15199: ARRAY
15200: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
15201: LD_VAR 0 5
15205: PUSH
15206: LD_INT 1
15208: ARRAY
15209: PPUSH
15210: CALL_OW 302
15214: NOT
15215: PUSH
15216: LD_VAR 0 5
15220: PUSH
15221: LD_INT 1
15223: ARRAY
15224: PPUSH
15225: CALL_OW 255
15229: PUSH
15230: LD_VAR 0 1
15234: PPUSH
15235: CALL_OW 255
15239: NONEQUAL
15240: OR
15241: IFFALSE 15347
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
15243: LD_VAR 0 5
15247: PUSH
15248: LD_INT 1
15250: ARRAY
15251: PPUSH
15252: CALL_OW 305
15256: PUSH
15257: LD_VAR 0 5
15261: PUSH
15262: LD_INT 1
15264: ARRAY
15265: PPUSH
15266: CALL_OW 255
15270: PUSH
15271: LD_VAR 0 1
15275: PPUSH
15276: CALL_OW 255
15280: EQUAL
15281: AND
15282: IFFALSE 15306
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
15284: LD_VAR 0 5
15288: PUSH
15289: LD_INT 1
15291: ARRAY
15292: PPUSH
15293: LD_VAR 0 5
15297: PUSH
15298: LD_INT 2
15300: ARRAY
15301: PPUSH
15302: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
15306: LD_ADDR_EXP 76
15310: PUSH
15311: LD_EXP 76
15315: PPUSH
15316: LD_VAR 0 4
15320: PPUSH
15321: LD_EXP 76
15325: PUSH
15326: LD_VAR 0 4
15330: ARRAY
15331: PPUSH
15332: LD_VAR 0 3
15336: PPUSH
15337: CALL_OW 3
15341: PPUSH
15342: CALL_OW 1
15346: ST_TO_ADDR
// end ; end ;
15347: GO 15176
15349: POP
15350: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
15351: LD_VAR 0 1
15355: PPUSH
15356: LD_EXP 76
15360: PUSH
15361: LD_VAR 0 4
15365: ARRAY
15366: PUSH
15367: LD_INT 0
15369: PLUS
15370: PPUSH
15371: CALL_OW 505
// end ;
15375: LD_VAR 0 2
15379: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
15380: LD_INT 0
15382: PPUSH
15383: PPUSH
15384: PPUSH
15385: PPUSH
// if not hack in hackTanks then
15386: LD_VAR 0 1
15390: PUSH
15391: LD_EXP 75
15395: IN
15396: NOT
15397: IFFALSE 15401
// exit ;
15399: GO 15486
// index := GetElementIndex ( hackTanks , hack ) ;
15401: LD_ADDR_VAR 0 5
15405: PUSH
15406: LD_EXP 75
15410: PPUSH
15411: LD_VAR 0 1
15415: PPUSH
15416: CALL 22236 0 2
15420: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
15421: LD_ADDR_VAR 0 4
15425: PUSH
15426: DOUBLE
15427: LD_INT 1
15429: DEC
15430: ST_TO_ADDR
15431: LD_EXP 76
15435: PUSH
15436: LD_VAR 0 5
15440: ARRAY
15441: PUSH
15442: FOR_TO
15443: IFFALSE 15484
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
15445: LD_EXP 76
15449: PUSH
15450: LD_VAR 0 5
15454: ARRAY
15455: PUSH
15456: LD_VAR 0 4
15460: ARRAY
15461: PUSH
15462: LD_INT 1
15464: ARRAY
15465: PUSH
15466: LD_VAR 0 2
15470: EQUAL
15471: IFFALSE 15482
// KillUnit ( vehicle ) ;
15473: LD_VAR 0 2
15477: PPUSH
15478: CALL_OW 66
15482: GO 15442
15484: POP
15485: POP
// end ;
15486: LD_VAR 0 3
15490: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
15491: LD_EXP 80
15495: NOT
15496: IFFALSE 15531
15498: GO 15500
15500: DISABLE
// begin initMiner := true ;
15501: LD_ADDR_EXP 80
15505: PUSH
15506: LD_INT 1
15508: ST_TO_ADDR
// minersList := [ ] ;
15509: LD_ADDR_EXP 81
15513: PUSH
15514: EMPTY
15515: ST_TO_ADDR
// minerMinesList := [ ] ;
15516: LD_ADDR_EXP 82
15520: PUSH
15521: EMPTY
15522: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
15523: LD_ADDR_EXP 83
15527: PUSH
15528: LD_INT 5
15530: ST_TO_ADDR
// end ;
15531: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
15532: LD_EXP 80
15536: PUSH
15537: LD_INT 34
15539: PUSH
15540: LD_EXP 8
15544: PUSH
15545: EMPTY
15546: LIST
15547: LIST
15548: PPUSH
15549: CALL_OW 69
15553: AND
15554: IFFALSE 16017
15556: GO 15558
15558: DISABLE
15559: LD_INT 0
15561: PPUSH
15562: PPUSH
15563: PPUSH
15564: PPUSH
// begin enable ;
15565: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
15566: LD_ADDR_VAR 0 1
15570: PUSH
15571: LD_INT 34
15573: PUSH
15574: LD_EXP 8
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: PPUSH
15583: CALL_OW 69
15587: PUSH
15588: FOR_IN
15589: IFFALSE 15661
// begin if not i in minersList then
15591: LD_VAR 0 1
15595: PUSH
15596: LD_EXP 81
15600: IN
15601: NOT
15602: IFFALSE 15659
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
15604: LD_ADDR_EXP 81
15608: PUSH
15609: LD_EXP 81
15613: PPUSH
15614: LD_EXP 81
15618: PUSH
15619: LD_INT 1
15621: PLUS
15622: PPUSH
15623: LD_VAR 0 1
15627: PPUSH
15628: CALL_OW 1
15632: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
15633: LD_ADDR_EXP 82
15637: PUSH
15638: LD_EXP 82
15642: PPUSH
15643: LD_EXP 82
15647: PUSH
15648: LD_INT 1
15650: PLUS
15651: PPUSH
15652: EMPTY
15653: PPUSH
15654: CALL_OW 1
15658: ST_TO_ADDR
// end end ;
15659: GO 15588
15661: POP
15662: POP
// for i := minerMinesList downto 1 do
15663: LD_ADDR_VAR 0 1
15667: PUSH
15668: DOUBLE
15669: LD_EXP 82
15673: INC
15674: ST_TO_ADDR
15675: LD_INT 1
15677: PUSH
15678: FOR_DOWNTO
15679: IFFALSE 16015
// begin if IsLive ( minersList [ i ] ) then
15681: LD_EXP 81
15685: PUSH
15686: LD_VAR 0 1
15690: ARRAY
15691: PPUSH
15692: CALL_OW 300
15696: IFFALSE 15724
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
15698: LD_EXP 81
15702: PUSH
15703: LD_VAR 0 1
15707: ARRAY
15708: PPUSH
15709: LD_EXP 82
15713: PUSH
15714: LD_VAR 0 1
15718: ARRAY
15719: PPUSH
15720: CALL_OW 505
// if not minerMinesList [ i ] then
15724: LD_EXP 82
15728: PUSH
15729: LD_VAR 0 1
15733: ARRAY
15734: NOT
15735: IFFALSE 15739
// continue ;
15737: GO 15678
// for j := minerMinesList [ i ] downto 1 do
15739: LD_ADDR_VAR 0 2
15743: PUSH
15744: DOUBLE
15745: LD_EXP 82
15749: PUSH
15750: LD_VAR 0 1
15754: ARRAY
15755: INC
15756: ST_TO_ADDR
15757: LD_INT 1
15759: PUSH
15760: FOR_DOWNTO
15761: IFFALSE 16011
// begin side := GetSide ( minersList [ i ] ) ;
15763: LD_ADDR_VAR 0 3
15767: PUSH
15768: LD_EXP 81
15772: PUSH
15773: LD_VAR 0 1
15777: ARRAY
15778: PPUSH
15779: CALL_OW 255
15783: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
15784: LD_ADDR_VAR 0 4
15788: PUSH
15789: LD_EXP 82
15793: PUSH
15794: LD_VAR 0 1
15798: ARRAY
15799: PUSH
15800: LD_VAR 0 2
15804: ARRAY
15805: PUSH
15806: LD_INT 1
15808: ARRAY
15809: PPUSH
15810: LD_EXP 82
15814: PUSH
15815: LD_VAR 0 1
15819: ARRAY
15820: PUSH
15821: LD_VAR 0 2
15825: ARRAY
15826: PUSH
15827: LD_INT 2
15829: ARRAY
15830: PPUSH
15831: CALL_OW 428
15835: ST_TO_ADDR
// if not tmp then
15836: LD_VAR 0 4
15840: NOT
15841: IFFALSE 15845
// continue ;
15843: GO 15760
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
15845: LD_VAR 0 4
15849: PUSH
15850: LD_INT 81
15852: PUSH
15853: LD_VAR 0 3
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PPUSH
15862: CALL_OW 69
15866: IN
15867: PUSH
15868: LD_EXP 82
15872: PUSH
15873: LD_VAR 0 1
15877: ARRAY
15878: PUSH
15879: LD_VAR 0 2
15883: ARRAY
15884: PUSH
15885: LD_INT 1
15887: ARRAY
15888: PPUSH
15889: LD_EXP 82
15893: PUSH
15894: LD_VAR 0 1
15898: ARRAY
15899: PUSH
15900: LD_VAR 0 2
15904: ARRAY
15905: PUSH
15906: LD_INT 2
15908: ARRAY
15909: PPUSH
15910: CALL_OW 458
15914: AND
15915: IFFALSE 16009
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
15917: LD_EXP 82
15921: PUSH
15922: LD_VAR 0 1
15926: ARRAY
15927: PUSH
15928: LD_VAR 0 2
15932: ARRAY
15933: PUSH
15934: LD_INT 1
15936: ARRAY
15937: PPUSH
15938: LD_EXP 82
15942: PUSH
15943: LD_VAR 0 1
15947: ARRAY
15948: PUSH
15949: LD_VAR 0 2
15953: ARRAY
15954: PUSH
15955: LD_INT 2
15957: ARRAY
15958: PPUSH
15959: LD_VAR 0 3
15963: PPUSH
15964: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
15968: LD_ADDR_EXP 82
15972: PUSH
15973: LD_EXP 82
15977: PPUSH
15978: LD_VAR 0 1
15982: PPUSH
15983: LD_EXP 82
15987: PUSH
15988: LD_VAR 0 1
15992: ARRAY
15993: PPUSH
15994: LD_VAR 0 2
15998: PPUSH
15999: CALL_OW 3
16003: PPUSH
16004: CALL_OW 1
16008: ST_TO_ADDR
// end ; end ;
16009: GO 15760
16011: POP
16012: POP
// end ;
16013: GO 15678
16015: POP
16016: POP
// end ;
16017: PPOPN 4
16019: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
16020: LD_INT 0
16022: PPUSH
16023: PPUSH
// result := false ;
16024: LD_ADDR_VAR 0 4
16028: PUSH
16029: LD_INT 0
16031: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
16032: LD_VAR 0 1
16036: PPUSH
16037: CALL_OW 264
16041: PUSH
16042: LD_EXP 8
16046: EQUAL
16047: NOT
16048: IFFALSE 16052
// exit ;
16050: GO 16292
// index := GetElementIndex ( minersList , unit ) ;
16052: LD_ADDR_VAR 0 5
16056: PUSH
16057: LD_EXP 81
16061: PPUSH
16062: LD_VAR 0 1
16066: PPUSH
16067: CALL 22236 0 2
16071: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
16072: LD_EXP 82
16076: PUSH
16077: LD_VAR 0 5
16081: ARRAY
16082: PUSH
16083: LD_EXP 83
16087: GREATEREQUAL
16088: IFFALSE 16092
// exit ;
16090: GO 16292
// ComMoveXY ( unit , x , y ) ;
16092: LD_VAR 0 1
16096: PPUSH
16097: LD_VAR 0 2
16101: PPUSH
16102: LD_VAR 0 3
16106: PPUSH
16107: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
16111: LD_INT 35
16113: PPUSH
16114: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
16118: LD_VAR 0 1
16122: PPUSH
16123: LD_VAR 0 2
16127: PPUSH
16128: LD_VAR 0 3
16132: PPUSH
16133: CALL 52633 0 3
16137: NOT
16138: PUSH
16139: LD_VAR 0 1
16143: PPUSH
16144: CALL_OW 314
16148: AND
16149: IFFALSE 16153
// exit ;
16151: GO 16292
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
16153: LD_VAR 0 2
16157: PPUSH
16158: LD_VAR 0 3
16162: PPUSH
16163: CALL_OW 428
16167: PUSH
16168: LD_VAR 0 1
16172: EQUAL
16173: PUSH
16174: LD_VAR 0 1
16178: PPUSH
16179: CALL_OW 314
16183: NOT
16184: AND
16185: IFFALSE 16111
// PlaySoundXY ( x , y , PlantMine ) ;
16187: LD_VAR 0 2
16191: PPUSH
16192: LD_VAR 0 3
16196: PPUSH
16197: LD_STRING PlantMine
16199: PPUSH
16200: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
16204: LD_VAR 0 2
16208: PPUSH
16209: LD_VAR 0 3
16213: PPUSH
16214: LD_VAR 0 1
16218: PPUSH
16219: CALL_OW 255
16223: PPUSH
16224: LD_INT 0
16226: PPUSH
16227: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
16231: LD_ADDR_EXP 82
16235: PUSH
16236: LD_EXP 82
16240: PPUSH
16241: LD_VAR 0 5
16245: PUSH
16246: LD_EXP 82
16250: PUSH
16251: LD_VAR 0 5
16255: ARRAY
16256: PUSH
16257: LD_INT 1
16259: PLUS
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PPUSH
16265: LD_VAR 0 2
16269: PUSH
16270: LD_VAR 0 3
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PPUSH
16279: CALL 22451 0 3
16283: ST_TO_ADDR
// result := true ;
16284: LD_ADDR_VAR 0 4
16288: PUSH
16289: LD_INT 1
16291: ST_TO_ADDR
// end ;
16292: LD_VAR 0 4
16296: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
16297: LD_INT 0
16299: PPUSH
16300: PPUSH
16301: PPUSH
// if not unit in minersList then
16302: LD_VAR 0 1
16306: PUSH
16307: LD_EXP 81
16311: IN
16312: NOT
16313: IFFALSE 16317
// exit ;
16315: GO 16709
// index := GetElementIndex ( minersList , unit ) ;
16317: LD_ADDR_VAR 0 6
16321: PUSH
16322: LD_EXP 81
16326: PPUSH
16327: LD_VAR 0 1
16331: PPUSH
16332: CALL 22236 0 2
16336: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
16337: LD_ADDR_VAR 0 5
16341: PUSH
16342: DOUBLE
16343: LD_EXP 82
16347: PUSH
16348: LD_VAR 0 6
16352: ARRAY
16353: INC
16354: ST_TO_ADDR
16355: LD_INT 1
16357: PUSH
16358: FOR_DOWNTO
16359: IFFALSE 16520
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
16361: LD_EXP 82
16365: PUSH
16366: LD_VAR 0 6
16370: ARRAY
16371: PUSH
16372: LD_VAR 0 5
16376: ARRAY
16377: PUSH
16378: LD_INT 1
16380: ARRAY
16381: PUSH
16382: LD_VAR 0 2
16386: EQUAL
16387: PUSH
16388: LD_EXP 82
16392: PUSH
16393: LD_VAR 0 6
16397: ARRAY
16398: PUSH
16399: LD_VAR 0 5
16403: ARRAY
16404: PUSH
16405: LD_INT 2
16407: ARRAY
16408: PUSH
16409: LD_VAR 0 3
16413: EQUAL
16414: AND
16415: IFFALSE 16518
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
16417: LD_EXP 82
16421: PUSH
16422: LD_VAR 0 6
16426: ARRAY
16427: PUSH
16428: LD_VAR 0 5
16432: ARRAY
16433: PUSH
16434: LD_INT 1
16436: ARRAY
16437: PPUSH
16438: LD_EXP 82
16442: PUSH
16443: LD_VAR 0 6
16447: ARRAY
16448: PUSH
16449: LD_VAR 0 5
16453: ARRAY
16454: PUSH
16455: LD_INT 2
16457: ARRAY
16458: PPUSH
16459: LD_VAR 0 1
16463: PPUSH
16464: CALL_OW 255
16468: PPUSH
16469: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
16473: LD_ADDR_EXP 82
16477: PUSH
16478: LD_EXP 82
16482: PPUSH
16483: LD_VAR 0 6
16487: PPUSH
16488: LD_EXP 82
16492: PUSH
16493: LD_VAR 0 6
16497: ARRAY
16498: PPUSH
16499: LD_VAR 0 5
16503: PPUSH
16504: CALL_OW 3
16508: PPUSH
16509: CALL_OW 1
16513: ST_TO_ADDR
// exit ;
16514: POP
16515: POP
16516: GO 16709
// end ; end ;
16518: GO 16358
16520: POP
16521: POP
// for i := minerMinesList [ index ] downto 1 do
16522: LD_ADDR_VAR 0 5
16526: PUSH
16527: DOUBLE
16528: LD_EXP 82
16532: PUSH
16533: LD_VAR 0 6
16537: ARRAY
16538: INC
16539: ST_TO_ADDR
16540: LD_INT 1
16542: PUSH
16543: FOR_DOWNTO
16544: IFFALSE 16707
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
16546: LD_EXP 82
16550: PUSH
16551: LD_VAR 0 6
16555: ARRAY
16556: PUSH
16557: LD_VAR 0 5
16561: ARRAY
16562: PUSH
16563: LD_INT 1
16565: ARRAY
16566: PPUSH
16567: LD_EXP 82
16571: PUSH
16572: LD_VAR 0 6
16576: ARRAY
16577: PUSH
16578: LD_VAR 0 5
16582: ARRAY
16583: PUSH
16584: LD_INT 2
16586: ARRAY
16587: PPUSH
16588: LD_VAR 0 2
16592: PPUSH
16593: LD_VAR 0 3
16597: PPUSH
16598: CALL_OW 298
16602: PUSH
16603: LD_INT 6
16605: LESS
16606: IFFALSE 16705
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
16608: LD_EXP 82
16612: PUSH
16613: LD_VAR 0 6
16617: ARRAY
16618: PUSH
16619: LD_VAR 0 5
16623: ARRAY
16624: PUSH
16625: LD_INT 1
16627: ARRAY
16628: PPUSH
16629: LD_EXP 82
16633: PUSH
16634: LD_VAR 0 6
16638: ARRAY
16639: PUSH
16640: LD_VAR 0 5
16644: ARRAY
16645: PUSH
16646: LD_INT 2
16648: ARRAY
16649: PPUSH
16650: LD_VAR 0 1
16654: PPUSH
16655: CALL_OW 255
16659: PPUSH
16660: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
16664: LD_ADDR_EXP 82
16668: PUSH
16669: LD_EXP 82
16673: PPUSH
16674: LD_VAR 0 6
16678: PPUSH
16679: LD_EXP 82
16683: PUSH
16684: LD_VAR 0 6
16688: ARRAY
16689: PPUSH
16690: LD_VAR 0 5
16694: PPUSH
16695: CALL_OW 3
16699: PPUSH
16700: CALL_OW 1
16704: ST_TO_ADDR
// end ; end ;
16705: GO 16543
16707: POP
16708: POP
// end ;
16709: LD_VAR 0 4
16713: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
16714: LD_INT 0
16716: PPUSH
16717: PPUSH
16718: PPUSH
16719: PPUSH
16720: PPUSH
16721: PPUSH
16722: PPUSH
16723: PPUSH
16724: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
16725: LD_VAR 0 1
16729: PPUSH
16730: CALL_OW 264
16734: PUSH
16735: LD_EXP 8
16739: EQUAL
16740: NOT
16741: PUSH
16742: LD_VAR 0 1
16746: PUSH
16747: LD_EXP 81
16751: IN
16752: NOT
16753: OR
16754: IFFALSE 16758
// exit ;
16756: GO 17080
// index := GetElementIndex ( minersList , unit ) ;
16758: LD_ADDR_VAR 0 6
16762: PUSH
16763: LD_EXP 81
16767: PPUSH
16768: LD_VAR 0 1
16772: PPUSH
16773: CALL 22236 0 2
16777: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
16778: LD_ADDR_VAR 0 8
16782: PUSH
16783: LD_EXP 83
16787: PUSH
16788: LD_EXP 82
16792: PUSH
16793: LD_VAR 0 6
16797: ARRAY
16798: MINUS
16799: ST_TO_ADDR
// if not minesFreeAmount then
16800: LD_VAR 0 8
16804: NOT
16805: IFFALSE 16809
// exit ;
16807: GO 17080
// tmp := [ ] ;
16809: LD_ADDR_VAR 0 7
16813: PUSH
16814: EMPTY
16815: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
16816: LD_ADDR_VAR 0 5
16820: PUSH
16821: DOUBLE
16822: LD_INT 1
16824: DEC
16825: ST_TO_ADDR
16826: LD_VAR 0 8
16830: PUSH
16831: FOR_TO
16832: IFFALSE 17027
// begin _d := rand ( 0 , 5 ) ;
16834: LD_ADDR_VAR 0 11
16838: PUSH
16839: LD_INT 0
16841: PPUSH
16842: LD_INT 5
16844: PPUSH
16845: CALL_OW 12
16849: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
16850: LD_ADDR_VAR 0 12
16854: PUSH
16855: LD_INT 2
16857: PPUSH
16858: LD_INT 6
16860: PPUSH
16861: CALL_OW 12
16865: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
16866: LD_ADDR_VAR 0 9
16870: PUSH
16871: LD_VAR 0 2
16875: PPUSH
16876: LD_VAR 0 11
16880: PPUSH
16881: LD_VAR 0 12
16885: PPUSH
16886: CALL_OW 272
16890: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
16891: LD_ADDR_VAR 0 10
16895: PUSH
16896: LD_VAR 0 3
16900: PPUSH
16901: LD_VAR 0 11
16905: PPUSH
16906: LD_VAR 0 12
16910: PPUSH
16911: CALL_OW 273
16915: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
16916: LD_VAR 0 9
16920: PPUSH
16921: LD_VAR 0 10
16925: PPUSH
16926: CALL_OW 488
16930: PUSH
16931: LD_VAR 0 9
16935: PUSH
16936: LD_VAR 0 10
16940: PUSH
16941: EMPTY
16942: LIST
16943: LIST
16944: PUSH
16945: LD_VAR 0 7
16949: IN
16950: NOT
16951: AND
16952: PUSH
16953: LD_VAR 0 9
16957: PPUSH
16958: LD_VAR 0 10
16962: PPUSH
16963: CALL_OW 458
16967: NOT
16968: AND
16969: IFFALSE 17011
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
16971: LD_ADDR_VAR 0 7
16975: PUSH
16976: LD_VAR 0 7
16980: PPUSH
16981: LD_VAR 0 7
16985: PUSH
16986: LD_INT 1
16988: PLUS
16989: PPUSH
16990: LD_VAR 0 9
16994: PUSH
16995: LD_VAR 0 10
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: PPUSH
17004: CALL_OW 1
17008: ST_TO_ADDR
17009: GO 17025
// i := i - 1 ;
17011: LD_ADDR_VAR 0 5
17015: PUSH
17016: LD_VAR 0 5
17020: PUSH
17021: LD_INT 1
17023: MINUS
17024: ST_TO_ADDR
// end ;
17025: GO 16831
17027: POP
17028: POP
// for i in tmp do
17029: LD_ADDR_VAR 0 5
17033: PUSH
17034: LD_VAR 0 7
17038: PUSH
17039: FOR_IN
17040: IFFALSE 17078
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
17042: LD_VAR 0 1
17046: PPUSH
17047: LD_VAR 0 5
17051: PUSH
17052: LD_INT 1
17054: ARRAY
17055: PPUSH
17056: LD_VAR 0 5
17060: PUSH
17061: LD_INT 2
17063: ARRAY
17064: PPUSH
17065: CALL 16020 0 3
17069: NOT
17070: IFFALSE 17076
// exit ;
17072: POP
17073: POP
17074: GO 17080
17076: GO 17039
17078: POP
17079: POP
// end ;
17080: LD_VAR 0 4
17084: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
17085: LD_INT 0
17087: PPUSH
17088: PPUSH
17089: PPUSH
17090: PPUSH
17091: PPUSH
17092: PPUSH
17093: PPUSH
// if not GetClass ( unit ) = class_sniper then
17094: LD_VAR 0 1
17098: PPUSH
17099: CALL_OW 257
17103: PUSH
17104: LD_INT 5
17106: EQUAL
17107: NOT
17108: IFFALSE 17112
// exit ;
17110: GO 17500
// dist := 8 ;
17112: LD_ADDR_VAR 0 5
17116: PUSH
17117: LD_INT 8
17119: ST_TO_ADDR
// viewRange := 12 ;
17120: LD_ADDR_VAR 0 7
17124: PUSH
17125: LD_INT 12
17127: ST_TO_ADDR
// side := GetSide ( unit ) ;
17128: LD_ADDR_VAR 0 6
17132: PUSH
17133: LD_VAR 0 1
17137: PPUSH
17138: CALL_OW 255
17142: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
17143: LD_INT 61
17145: PPUSH
17146: LD_VAR 0 6
17150: PPUSH
17151: CALL_OW 321
17155: PUSH
17156: LD_INT 2
17158: EQUAL
17159: IFFALSE 17169
// viewRange := 16 ;
17161: LD_ADDR_VAR 0 7
17165: PUSH
17166: LD_INT 16
17168: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
17169: LD_VAR 0 1
17173: PPUSH
17174: LD_VAR 0 2
17178: PPUSH
17179: LD_VAR 0 3
17183: PPUSH
17184: CALL_OW 297
17188: PUSH
17189: LD_VAR 0 5
17193: GREATER
17194: IFFALSE 17273
// begin ComMoveXY ( unit , x , y ) ;
17196: LD_VAR 0 1
17200: PPUSH
17201: LD_VAR 0 2
17205: PPUSH
17206: LD_VAR 0 3
17210: PPUSH
17211: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
17215: LD_INT 35
17217: PPUSH
17218: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
17222: LD_VAR 0 1
17226: PPUSH
17227: LD_VAR 0 2
17231: PPUSH
17232: LD_VAR 0 3
17236: PPUSH
17237: CALL 52633 0 3
17241: NOT
17242: IFFALSE 17246
// exit ;
17244: GO 17500
// until GetDistUnitXY ( unit , x , y ) < dist ;
17246: LD_VAR 0 1
17250: PPUSH
17251: LD_VAR 0 2
17255: PPUSH
17256: LD_VAR 0 3
17260: PPUSH
17261: CALL_OW 297
17265: PUSH
17266: LD_VAR 0 5
17270: LESS
17271: IFFALSE 17215
// end ; ComTurnXY ( unit , x , y ) ;
17273: LD_VAR 0 1
17277: PPUSH
17278: LD_VAR 0 2
17282: PPUSH
17283: LD_VAR 0 3
17287: PPUSH
17288: CALL_OW 118
// wait ( 5 ) ;
17292: LD_INT 5
17294: PPUSH
17295: CALL_OW 67
// _d := GetDir ( unit ) ;
17299: LD_ADDR_VAR 0 10
17303: PUSH
17304: LD_VAR 0 1
17308: PPUSH
17309: CALL_OW 254
17313: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
17314: LD_ADDR_VAR 0 8
17318: PUSH
17319: LD_VAR 0 1
17323: PPUSH
17324: CALL_OW 250
17328: PPUSH
17329: LD_VAR 0 10
17333: PPUSH
17334: LD_VAR 0 5
17338: PPUSH
17339: CALL_OW 272
17343: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
17344: LD_ADDR_VAR 0 9
17348: PUSH
17349: LD_VAR 0 1
17353: PPUSH
17354: CALL_OW 251
17358: PPUSH
17359: LD_VAR 0 10
17363: PPUSH
17364: LD_VAR 0 5
17368: PPUSH
17369: CALL_OW 273
17373: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17374: LD_VAR 0 8
17378: PPUSH
17379: LD_VAR 0 9
17383: PPUSH
17384: CALL_OW 488
17388: NOT
17389: IFFALSE 17393
// exit ;
17391: GO 17500
// ComAnimCustom ( unit , 1 ) ;
17393: LD_VAR 0 1
17397: PPUSH
17398: LD_INT 1
17400: PPUSH
17401: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
17405: LD_VAR 0 8
17409: PPUSH
17410: LD_VAR 0 9
17414: PPUSH
17415: LD_VAR 0 6
17419: PPUSH
17420: LD_VAR 0 7
17424: PPUSH
17425: CALL_OW 330
// repeat wait ( 1 ) ;
17429: LD_INT 1
17431: PPUSH
17432: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
17436: LD_VAR 0 1
17440: PPUSH
17441: CALL_OW 316
17445: PUSH
17446: LD_VAR 0 1
17450: PPUSH
17451: CALL_OW 314
17455: OR
17456: PUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 302
17466: NOT
17467: OR
17468: PUSH
17469: LD_VAR 0 1
17473: PPUSH
17474: CALL_OW 301
17478: OR
17479: IFFALSE 17429
// RemoveSeeing ( _x , _y , side ) ;
17481: LD_VAR 0 8
17485: PPUSH
17486: LD_VAR 0 9
17490: PPUSH
17491: LD_VAR 0 6
17495: PPUSH
17496: CALL_OW 331
// end ; end_of_file end_of_file
17500: LD_VAR 0 4
17504: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
17505: LD_INT 0
17507: PPUSH
17508: PPUSH
// if exist_mode then
17509: LD_VAR 0 2
17513: IFFALSE 17538
// unit := CreateCharacter ( prefix & ident ) else
17515: LD_ADDR_VAR 0 5
17519: PUSH
17520: LD_VAR 0 3
17524: PUSH
17525: LD_VAR 0 1
17529: STR
17530: PPUSH
17531: CALL_OW 34
17535: ST_TO_ADDR
17536: GO 17553
// unit := NewCharacter ( ident ) ;
17538: LD_ADDR_VAR 0 5
17542: PUSH
17543: LD_VAR 0 1
17547: PPUSH
17548: CALL_OW 25
17552: ST_TO_ADDR
// result := unit ;
17553: LD_ADDR_VAR 0 4
17557: PUSH
17558: LD_VAR 0 5
17562: ST_TO_ADDR
// end ;
17563: LD_VAR 0 4
17567: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
17568: LD_INT 0
17570: PPUSH
17571: PPUSH
// if not side or not nation then
17572: LD_VAR 0 1
17576: NOT
17577: PUSH
17578: LD_VAR 0 2
17582: NOT
17583: OR
17584: IFFALSE 17588
// exit ;
17586: GO 18352
// case nation of nation_american :
17588: LD_VAR 0 2
17592: PUSH
17593: LD_INT 1
17595: DOUBLE
17596: EQUAL
17597: IFTRUE 17601
17599: GO 17815
17601: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
17602: LD_ADDR_VAR 0 4
17606: PUSH
17607: LD_INT 35
17609: PUSH
17610: LD_INT 45
17612: PUSH
17613: LD_INT 46
17615: PUSH
17616: LD_INT 47
17618: PUSH
17619: LD_INT 82
17621: PUSH
17622: LD_INT 83
17624: PUSH
17625: LD_INT 84
17627: PUSH
17628: LD_INT 85
17630: PUSH
17631: LD_INT 86
17633: PUSH
17634: LD_INT 1
17636: PUSH
17637: LD_INT 2
17639: PUSH
17640: LD_INT 6
17642: PUSH
17643: LD_INT 15
17645: PUSH
17646: LD_INT 16
17648: PUSH
17649: LD_INT 7
17651: PUSH
17652: LD_INT 12
17654: PUSH
17655: LD_INT 13
17657: PUSH
17658: LD_INT 10
17660: PUSH
17661: LD_INT 14
17663: PUSH
17664: LD_INT 20
17666: PUSH
17667: LD_INT 21
17669: PUSH
17670: LD_INT 22
17672: PUSH
17673: LD_INT 25
17675: PUSH
17676: LD_INT 32
17678: PUSH
17679: LD_INT 27
17681: PUSH
17682: LD_INT 36
17684: PUSH
17685: LD_INT 69
17687: PUSH
17688: LD_INT 39
17690: PUSH
17691: LD_INT 34
17693: PUSH
17694: LD_INT 40
17696: PUSH
17697: LD_INT 48
17699: PUSH
17700: LD_INT 49
17702: PUSH
17703: LD_INT 50
17705: PUSH
17706: LD_INT 51
17708: PUSH
17709: LD_INT 52
17711: PUSH
17712: LD_INT 53
17714: PUSH
17715: LD_INT 54
17717: PUSH
17718: LD_INT 55
17720: PUSH
17721: LD_INT 56
17723: PUSH
17724: LD_INT 57
17726: PUSH
17727: LD_INT 58
17729: PUSH
17730: LD_INT 59
17732: PUSH
17733: LD_INT 60
17735: PUSH
17736: LD_INT 61
17738: PUSH
17739: LD_INT 62
17741: PUSH
17742: LD_INT 80
17744: PUSH
17745: LD_INT 82
17747: PUSH
17748: LD_INT 83
17750: PUSH
17751: LD_INT 84
17753: PUSH
17754: LD_INT 85
17756: PUSH
17757: LD_INT 86
17759: PUSH
17760: EMPTY
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: LIST
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: ST_TO_ADDR
17813: GO 18276
17815: LD_INT 2
17817: DOUBLE
17818: EQUAL
17819: IFTRUE 17823
17821: GO 18045
17823: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
17824: LD_ADDR_VAR 0 4
17828: PUSH
17829: LD_INT 35
17831: PUSH
17832: LD_INT 45
17834: PUSH
17835: LD_INT 46
17837: PUSH
17838: LD_INT 47
17840: PUSH
17841: LD_INT 82
17843: PUSH
17844: LD_INT 83
17846: PUSH
17847: LD_INT 84
17849: PUSH
17850: LD_INT 85
17852: PUSH
17853: LD_INT 87
17855: PUSH
17856: LD_INT 70
17858: PUSH
17859: LD_INT 1
17861: PUSH
17862: LD_INT 11
17864: PUSH
17865: LD_INT 3
17867: PUSH
17868: LD_INT 4
17870: PUSH
17871: LD_INT 5
17873: PUSH
17874: LD_INT 6
17876: PUSH
17877: LD_INT 15
17879: PUSH
17880: LD_INT 18
17882: PUSH
17883: LD_INT 7
17885: PUSH
17886: LD_INT 17
17888: PUSH
17889: LD_INT 8
17891: PUSH
17892: LD_INT 20
17894: PUSH
17895: LD_INT 21
17897: PUSH
17898: LD_INT 22
17900: PUSH
17901: LD_INT 72
17903: PUSH
17904: LD_INT 26
17906: PUSH
17907: LD_INT 69
17909: PUSH
17910: LD_INT 39
17912: PUSH
17913: LD_INT 40
17915: PUSH
17916: LD_INT 41
17918: PUSH
17919: LD_INT 42
17921: PUSH
17922: LD_INT 43
17924: PUSH
17925: LD_INT 48
17927: PUSH
17928: LD_INT 49
17930: PUSH
17931: LD_INT 50
17933: PUSH
17934: LD_INT 51
17936: PUSH
17937: LD_INT 52
17939: PUSH
17940: LD_INT 53
17942: PUSH
17943: LD_INT 54
17945: PUSH
17946: LD_INT 55
17948: PUSH
17949: LD_INT 56
17951: PUSH
17952: LD_INT 60
17954: PUSH
17955: LD_INT 61
17957: PUSH
17958: LD_INT 62
17960: PUSH
17961: LD_INT 66
17963: PUSH
17964: LD_INT 67
17966: PUSH
17967: LD_INT 68
17969: PUSH
17970: LD_INT 81
17972: PUSH
17973: LD_INT 82
17975: PUSH
17976: LD_INT 83
17978: PUSH
17979: LD_INT 84
17981: PUSH
17982: LD_INT 85
17984: PUSH
17985: LD_INT 87
17987: PUSH
17988: EMPTY
17989: LIST
17990: LIST
17991: LIST
17992: LIST
17993: LIST
17994: LIST
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: ST_TO_ADDR
18043: GO 18276
18045: LD_INT 3
18047: DOUBLE
18048: EQUAL
18049: IFTRUE 18053
18051: GO 18275
18053: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
18054: LD_ADDR_VAR 0 4
18058: PUSH
18059: LD_INT 46
18061: PUSH
18062: LD_INT 47
18064: PUSH
18065: LD_INT 1
18067: PUSH
18068: LD_INT 2
18070: PUSH
18071: LD_INT 82
18073: PUSH
18074: LD_INT 83
18076: PUSH
18077: LD_INT 84
18079: PUSH
18080: LD_INT 85
18082: PUSH
18083: LD_INT 86
18085: PUSH
18086: LD_INT 11
18088: PUSH
18089: LD_INT 9
18091: PUSH
18092: LD_INT 20
18094: PUSH
18095: LD_INT 19
18097: PUSH
18098: LD_INT 21
18100: PUSH
18101: LD_INT 24
18103: PUSH
18104: LD_INT 22
18106: PUSH
18107: LD_INT 25
18109: PUSH
18110: LD_INT 28
18112: PUSH
18113: LD_INT 29
18115: PUSH
18116: LD_INT 30
18118: PUSH
18119: LD_INT 31
18121: PUSH
18122: LD_INT 37
18124: PUSH
18125: LD_INT 38
18127: PUSH
18128: LD_INT 32
18130: PUSH
18131: LD_INT 27
18133: PUSH
18134: LD_INT 33
18136: PUSH
18137: LD_INT 69
18139: PUSH
18140: LD_INT 39
18142: PUSH
18143: LD_INT 34
18145: PUSH
18146: LD_INT 40
18148: PUSH
18149: LD_INT 71
18151: PUSH
18152: LD_INT 23
18154: PUSH
18155: LD_INT 44
18157: PUSH
18158: LD_INT 48
18160: PUSH
18161: LD_INT 49
18163: PUSH
18164: LD_INT 50
18166: PUSH
18167: LD_INT 51
18169: PUSH
18170: LD_INT 52
18172: PUSH
18173: LD_INT 53
18175: PUSH
18176: LD_INT 54
18178: PUSH
18179: LD_INT 55
18181: PUSH
18182: LD_INT 56
18184: PUSH
18185: LD_INT 57
18187: PUSH
18188: LD_INT 58
18190: PUSH
18191: LD_INT 59
18193: PUSH
18194: LD_INT 63
18196: PUSH
18197: LD_INT 64
18199: PUSH
18200: LD_INT 65
18202: PUSH
18203: LD_INT 82
18205: PUSH
18206: LD_INT 83
18208: PUSH
18209: LD_INT 84
18211: PUSH
18212: LD_INT 85
18214: PUSH
18215: LD_INT 86
18217: PUSH
18218: EMPTY
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: LIST
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: LIST
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: LIST
18255: LIST
18256: LIST
18257: LIST
18258: LIST
18259: LIST
18260: LIST
18261: LIST
18262: LIST
18263: LIST
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: LIST
18269: LIST
18270: LIST
18271: LIST
18272: ST_TO_ADDR
18273: GO 18276
18275: POP
// if state > - 1 and state < 3 then
18276: LD_VAR 0 3
18280: PUSH
18281: LD_INT 1
18283: NEG
18284: GREATER
18285: PUSH
18286: LD_VAR 0 3
18290: PUSH
18291: LD_INT 3
18293: LESS
18294: AND
18295: IFFALSE 18352
// for i in result do
18297: LD_ADDR_VAR 0 5
18301: PUSH
18302: LD_VAR 0 4
18306: PUSH
18307: FOR_IN
18308: IFFALSE 18350
// if GetTech ( i , side ) <> state then
18310: LD_VAR 0 5
18314: PPUSH
18315: LD_VAR 0 1
18319: PPUSH
18320: CALL_OW 321
18324: PUSH
18325: LD_VAR 0 3
18329: NONEQUAL
18330: IFFALSE 18348
// result := result diff i ;
18332: LD_ADDR_VAR 0 4
18336: PUSH
18337: LD_VAR 0 4
18341: PUSH
18342: LD_VAR 0 5
18346: DIFF
18347: ST_TO_ADDR
18348: GO 18307
18350: POP
18351: POP
// end ;
18352: LD_VAR 0 4
18356: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
18357: LD_INT 0
18359: PPUSH
18360: PPUSH
18361: PPUSH
// result := true ;
18362: LD_ADDR_VAR 0 3
18366: PUSH
18367: LD_INT 1
18369: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
18370: LD_ADDR_VAR 0 5
18374: PUSH
18375: LD_VAR 0 2
18379: PPUSH
18380: CALL_OW 480
18384: ST_TO_ADDR
// if not tmp then
18385: LD_VAR 0 5
18389: NOT
18390: IFFALSE 18394
// exit ;
18392: GO 18443
// for i in tmp do
18394: LD_ADDR_VAR 0 4
18398: PUSH
18399: LD_VAR 0 5
18403: PUSH
18404: FOR_IN
18405: IFFALSE 18441
// if GetTech ( i , side ) <> state_researched then
18407: LD_VAR 0 4
18411: PPUSH
18412: LD_VAR 0 1
18416: PPUSH
18417: CALL_OW 321
18421: PUSH
18422: LD_INT 2
18424: NONEQUAL
18425: IFFALSE 18439
// begin result := false ;
18427: LD_ADDR_VAR 0 3
18431: PUSH
18432: LD_INT 0
18434: ST_TO_ADDR
// exit ;
18435: POP
18436: POP
18437: GO 18443
// end ;
18439: GO 18404
18441: POP
18442: POP
// end ;
18443: LD_VAR 0 3
18447: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
18448: LD_INT 0
18450: PPUSH
18451: PPUSH
18452: PPUSH
18453: PPUSH
18454: PPUSH
18455: PPUSH
18456: PPUSH
18457: PPUSH
18458: PPUSH
18459: PPUSH
18460: PPUSH
18461: PPUSH
18462: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
18463: LD_VAR 0 1
18467: NOT
18468: PUSH
18469: LD_VAR 0 1
18473: PPUSH
18474: CALL_OW 257
18478: PUSH
18479: LD_INT 9
18481: NONEQUAL
18482: OR
18483: IFFALSE 18487
// exit ;
18485: GO 19060
// side := GetSide ( unit ) ;
18487: LD_ADDR_VAR 0 9
18491: PUSH
18492: LD_VAR 0 1
18496: PPUSH
18497: CALL_OW 255
18501: ST_TO_ADDR
// tech_space := tech_spacanom ;
18502: LD_ADDR_VAR 0 12
18506: PUSH
18507: LD_INT 29
18509: ST_TO_ADDR
// tech_time := tech_taurad ;
18510: LD_ADDR_VAR 0 13
18514: PUSH
18515: LD_INT 28
18517: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
18518: LD_ADDR_VAR 0 11
18522: PUSH
18523: LD_VAR 0 1
18527: PPUSH
18528: CALL_OW 310
18532: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
18533: LD_VAR 0 11
18537: PPUSH
18538: CALL_OW 247
18542: PUSH
18543: LD_INT 2
18545: EQUAL
18546: IFFALSE 18550
// exit ;
18548: GO 19060
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18550: LD_ADDR_VAR 0 8
18554: PUSH
18555: LD_INT 81
18557: PUSH
18558: LD_VAR 0 9
18562: PUSH
18563: EMPTY
18564: LIST
18565: LIST
18566: PUSH
18567: LD_INT 3
18569: PUSH
18570: LD_INT 21
18572: PUSH
18573: LD_INT 3
18575: PUSH
18576: EMPTY
18577: LIST
18578: LIST
18579: PUSH
18580: EMPTY
18581: LIST
18582: LIST
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PPUSH
18588: CALL_OW 69
18592: ST_TO_ADDR
// if not tmp then
18593: LD_VAR 0 8
18597: NOT
18598: IFFALSE 18602
// exit ;
18600: GO 19060
// if in_unit then
18602: LD_VAR 0 11
18606: IFFALSE 18630
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
18608: LD_ADDR_VAR 0 10
18612: PUSH
18613: LD_VAR 0 8
18617: PPUSH
18618: LD_VAR 0 11
18622: PPUSH
18623: CALL_OW 74
18627: ST_TO_ADDR
18628: GO 18650
// enemy := NearestUnitToUnit ( tmp , unit ) ;
18630: LD_ADDR_VAR 0 10
18634: PUSH
18635: LD_VAR 0 8
18639: PPUSH
18640: LD_VAR 0 1
18644: PPUSH
18645: CALL_OW 74
18649: ST_TO_ADDR
// if not enemy then
18650: LD_VAR 0 10
18654: NOT
18655: IFFALSE 18659
// exit ;
18657: GO 19060
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
18659: LD_VAR 0 11
18663: PUSH
18664: LD_VAR 0 11
18668: PPUSH
18669: LD_VAR 0 10
18673: PPUSH
18674: CALL_OW 296
18678: PUSH
18679: LD_INT 13
18681: GREATER
18682: AND
18683: PUSH
18684: LD_VAR 0 1
18688: PPUSH
18689: LD_VAR 0 10
18693: PPUSH
18694: CALL_OW 296
18698: PUSH
18699: LD_INT 12
18701: GREATER
18702: OR
18703: IFFALSE 18707
// exit ;
18705: GO 19060
// missile := [ 1 ] ;
18707: LD_ADDR_VAR 0 14
18711: PUSH
18712: LD_INT 1
18714: PUSH
18715: EMPTY
18716: LIST
18717: ST_TO_ADDR
// if Researched ( side , tech_space ) then
18718: LD_VAR 0 9
18722: PPUSH
18723: LD_VAR 0 12
18727: PPUSH
18728: CALL_OW 325
18732: IFFALSE 18761
// missile := Insert ( missile , missile + 1 , 2 ) ;
18734: LD_ADDR_VAR 0 14
18738: PUSH
18739: LD_VAR 0 14
18743: PPUSH
18744: LD_VAR 0 14
18748: PUSH
18749: LD_INT 1
18751: PLUS
18752: PPUSH
18753: LD_INT 2
18755: PPUSH
18756: CALL_OW 2
18760: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
18761: LD_VAR 0 9
18765: PPUSH
18766: LD_VAR 0 13
18770: PPUSH
18771: CALL_OW 325
18775: PUSH
18776: LD_VAR 0 10
18780: PPUSH
18781: CALL_OW 255
18785: PPUSH
18786: LD_VAR 0 13
18790: PPUSH
18791: CALL_OW 325
18795: NOT
18796: AND
18797: IFFALSE 18826
// missile := Insert ( missile , missile + 1 , 3 ) ;
18799: LD_ADDR_VAR 0 14
18803: PUSH
18804: LD_VAR 0 14
18808: PPUSH
18809: LD_VAR 0 14
18813: PUSH
18814: LD_INT 1
18816: PLUS
18817: PPUSH
18818: LD_INT 3
18820: PPUSH
18821: CALL_OW 2
18825: ST_TO_ADDR
// if missile < 2 then
18826: LD_VAR 0 14
18830: PUSH
18831: LD_INT 2
18833: LESS
18834: IFFALSE 18838
// exit ;
18836: GO 19060
// x := GetX ( enemy ) ;
18838: LD_ADDR_VAR 0 4
18842: PUSH
18843: LD_VAR 0 10
18847: PPUSH
18848: CALL_OW 250
18852: ST_TO_ADDR
// y := GetY ( enemy ) ;
18853: LD_ADDR_VAR 0 5
18857: PUSH
18858: LD_VAR 0 10
18862: PPUSH
18863: CALL_OW 251
18867: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
18868: LD_ADDR_VAR 0 6
18872: PUSH
18873: LD_VAR 0 4
18877: PUSH
18878: LD_INT 1
18880: NEG
18881: PPUSH
18882: LD_INT 1
18884: PPUSH
18885: CALL_OW 12
18889: PLUS
18890: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
18891: LD_ADDR_VAR 0 7
18895: PUSH
18896: LD_VAR 0 5
18900: PUSH
18901: LD_INT 1
18903: NEG
18904: PPUSH
18905: LD_INT 1
18907: PPUSH
18908: CALL_OW 12
18912: PLUS
18913: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18914: LD_VAR 0 6
18918: PPUSH
18919: LD_VAR 0 7
18923: PPUSH
18924: CALL_OW 488
18928: NOT
18929: IFFALSE 18951
// begin _x := x ;
18931: LD_ADDR_VAR 0 6
18935: PUSH
18936: LD_VAR 0 4
18940: ST_TO_ADDR
// _y := y ;
18941: LD_ADDR_VAR 0 7
18945: PUSH
18946: LD_VAR 0 5
18950: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
18951: LD_ADDR_VAR 0 3
18955: PUSH
18956: LD_INT 1
18958: PPUSH
18959: LD_VAR 0 14
18963: PPUSH
18964: CALL_OW 12
18968: ST_TO_ADDR
// case i of 1 :
18969: LD_VAR 0 3
18973: PUSH
18974: LD_INT 1
18976: DOUBLE
18977: EQUAL
18978: IFTRUE 18982
18980: GO 18999
18982: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
18983: LD_VAR 0 1
18987: PPUSH
18988: LD_VAR 0 10
18992: PPUSH
18993: CALL_OW 115
18997: GO 19060
18999: LD_INT 2
19001: DOUBLE
19002: EQUAL
19003: IFTRUE 19007
19005: GO 19029
19007: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
19008: LD_VAR 0 1
19012: PPUSH
19013: LD_VAR 0 6
19017: PPUSH
19018: LD_VAR 0 7
19022: PPUSH
19023: CALL_OW 153
19027: GO 19060
19029: LD_INT 3
19031: DOUBLE
19032: EQUAL
19033: IFTRUE 19037
19035: GO 19059
19037: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
19038: LD_VAR 0 1
19042: PPUSH
19043: LD_VAR 0 6
19047: PPUSH
19048: LD_VAR 0 7
19052: PPUSH
19053: CALL_OW 154
19057: GO 19060
19059: POP
// end ;
19060: LD_VAR 0 2
19064: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
19065: LD_INT 0
19067: PPUSH
19068: PPUSH
19069: PPUSH
19070: PPUSH
19071: PPUSH
19072: PPUSH
// if not unit or not building then
19073: LD_VAR 0 1
19077: NOT
19078: PUSH
19079: LD_VAR 0 2
19083: NOT
19084: OR
19085: IFFALSE 19089
// exit ;
19087: GO 19247
// x := GetX ( building ) ;
19089: LD_ADDR_VAR 0 5
19093: PUSH
19094: LD_VAR 0 2
19098: PPUSH
19099: CALL_OW 250
19103: ST_TO_ADDR
// y := GetY ( building ) ;
19104: LD_ADDR_VAR 0 6
19108: PUSH
19109: LD_VAR 0 2
19113: PPUSH
19114: CALL_OW 251
19118: ST_TO_ADDR
// for i = 0 to 5 do
19119: LD_ADDR_VAR 0 4
19123: PUSH
19124: DOUBLE
19125: LD_INT 0
19127: DEC
19128: ST_TO_ADDR
19129: LD_INT 5
19131: PUSH
19132: FOR_TO
19133: IFFALSE 19245
// begin _x := ShiftX ( x , i , 3 ) ;
19135: LD_ADDR_VAR 0 7
19139: PUSH
19140: LD_VAR 0 5
19144: PPUSH
19145: LD_VAR 0 4
19149: PPUSH
19150: LD_INT 3
19152: PPUSH
19153: CALL_OW 272
19157: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
19158: LD_ADDR_VAR 0 8
19162: PUSH
19163: LD_VAR 0 6
19167: PPUSH
19168: LD_VAR 0 4
19172: PPUSH
19173: LD_INT 3
19175: PPUSH
19176: CALL_OW 273
19180: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
19181: LD_VAR 0 7
19185: PPUSH
19186: LD_VAR 0 8
19190: PPUSH
19191: CALL_OW 488
19195: NOT
19196: IFFALSE 19200
// continue ;
19198: GO 19132
// if HexInfo ( _x , _y ) = 0 then
19200: LD_VAR 0 7
19204: PPUSH
19205: LD_VAR 0 8
19209: PPUSH
19210: CALL_OW 428
19214: PUSH
19215: LD_INT 0
19217: EQUAL
19218: IFFALSE 19243
// begin ComMoveXY ( unit , _x , _y ) ;
19220: LD_VAR 0 1
19224: PPUSH
19225: LD_VAR 0 7
19229: PPUSH
19230: LD_VAR 0 8
19234: PPUSH
19235: CALL_OW 111
// exit ;
19239: POP
19240: POP
19241: GO 19247
// end ; end ;
19243: GO 19132
19245: POP
19246: POP
// end ;
19247: LD_VAR 0 3
19251: RET
// export function ScanBase ( side , base_area ) ; begin
19252: LD_INT 0
19254: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
19255: LD_ADDR_VAR 0 3
19259: PUSH
19260: LD_VAR 0 2
19264: PPUSH
19265: LD_INT 81
19267: PUSH
19268: LD_VAR 0 1
19272: PUSH
19273: EMPTY
19274: LIST
19275: LIST
19276: PPUSH
19277: CALL_OW 70
19281: ST_TO_ADDR
// end ;
19282: LD_VAR 0 3
19286: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
19287: LD_INT 0
19289: PPUSH
19290: PPUSH
19291: PPUSH
19292: PPUSH
// result := false ;
19293: LD_ADDR_VAR 0 2
19297: PUSH
19298: LD_INT 0
19300: ST_TO_ADDR
// side := GetSide ( unit ) ;
19301: LD_ADDR_VAR 0 3
19305: PUSH
19306: LD_VAR 0 1
19310: PPUSH
19311: CALL_OW 255
19315: ST_TO_ADDR
// nat := GetNation ( unit ) ;
19316: LD_ADDR_VAR 0 4
19320: PUSH
19321: LD_VAR 0 1
19325: PPUSH
19326: CALL_OW 248
19330: ST_TO_ADDR
// case nat of 1 :
19331: LD_VAR 0 4
19335: PUSH
19336: LD_INT 1
19338: DOUBLE
19339: EQUAL
19340: IFTRUE 19344
19342: GO 19355
19344: POP
// tech := tech_lassight ; 2 :
19345: LD_ADDR_VAR 0 5
19349: PUSH
19350: LD_INT 12
19352: ST_TO_ADDR
19353: GO 19394
19355: LD_INT 2
19357: DOUBLE
19358: EQUAL
19359: IFTRUE 19363
19361: GO 19374
19363: POP
// tech := tech_mortar ; 3 :
19364: LD_ADDR_VAR 0 5
19368: PUSH
19369: LD_INT 41
19371: ST_TO_ADDR
19372: GO 19394
19374: LD_INT 3
19376: DOUBLE
19377: EQUAL
19378: IFTRUE 19382
19380: GO 19393
19382: POP
// tech := tech_bazooka ; end ;
19383: LD_ADDR_VAR 0 5
19387: PUSH
19388: LD_INT 44
19390: ST_TO_ADDR
19391: GO 19394
19393: POP
// if Researched ( side , tech ) then
19394: LD_VAR 0 3
19398: PPUSH
19399: LD_VAR 0 5
19403: PPUSH
19404: CALL_OW 325
19408: IFFALSE 19435
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
19410: LD_ADDR_VAR 0 2
19414: PUSH
19415: LD_INT 5
19417: PUSH
19418: LD_INT 8
19420: PUSH
19421: LD_INT 9
19423: PUSH
19424: EMPTY
19425: LIST
19426: LIST
19427: LIST
19428: PUSH
19429: LD_VAR 0 4
19433: ARRAY
19434: ST_TO_ADDR
// end ;
19435: LD_VAR 0 2
19439: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
19440: LD_INT 0
19442: PPUSH
19443: PPUSH
19444: PPUSH
// if not mines then
19445: LD_VAR 0 2
19449: NOT
19450: IFFALSE 19454
// exit ;
19452: GO 19598
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19454: LD_ADDR_VAR 0 5
19458: PUSH
19459: LD_INT 81
19461: PUSH
19462: LD_VAR 0 1
19466: PUSH
19467: EMPTY
19468: LIST
19469: LIST
19470: PUSH
19471: LD_INT 3
19473: PUSH
19474: LD_INT 21
19476: PUSH
19477: LD_INT 3
19479: PUSH
19480: EMPTY
19481: LIST
19482: LIST
19483: PUSH
19484: EMPTY
19485: LIST
19486: LIST
19487: PUSH
19488: EMPTY
19489: LIST
19490: LIST
19491: PPUSH
19492: CALL_OW 69
19496: ST_TO_ADDR
// for i in mines do
19497: LD_ADDR_VAR 0 4
19501: PUSH
19502: LD_VAR 0 2
19506: PUSH
19507: FOR_IN
19508: IFFALSE 19596
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
19510: LD_VAR 0 4
19514: PUSH
19515: LD_INT 1
19517: ARRAY
19518: PPUSH
19519: LD_VAR 0 4
19523: PUSH
19524: LD_INT 2
19526: ARRAY
19527: PPUSH
19528: CALL_OW 458
19532: NOT
19533: IFFALSE 19537
// continue ;
19535: GO 19507
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
19537: LD_VAR 0 4
19541: PUSH
19542: LD_INT 1
19544: ARRAY
19545: PPUSH
19546: LD_VAR 0 4
19550: PUSH
19551: LD_INT 2
19553: ARRAY
19554: PPUSH
19555: CALL_OW 428
19559: PUSH
19560: LD_VAR 0 5
19564: IN
19565: IFFALSE 19594
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
19567: LD_VAR 0 4
19571: PUSH
19572: LD_INT 1
19574: ARRAY
19575: PPUSH
19576: LD_VAR 0 4
19580: PUSH
19581: LD_INT 2
19583: ARRAY
19584: PPUSH
19585: LD_VAR 0 1
19589: PPUSH
19590: CALL_OW 456
// end ;
19594: GO 19507
19596: POP
19597: POP
// end ;
19598: LD_VAR 0 3
19602: RET
// export function Count ( array ) ; var i ; begin
19603: LD_INT 0
19605: PPUSH
19606: PPUSH
// result := 0 ;
19607: LD_ADDR_VAR 0 2
19611: PUSH
19612: LD_INT 0
19614: ST_TO_ADDR
// for i in array do
19615: LD_ADDR_VAR 0 3
19619: PUSH
19620: LD_VAR 0 1
19624: PUSH
19625: FOR_IN
19626: IFFALSE 19650
// if i then
19628: LD_VAR 0 3
19632: IFFALSE 19648
// result := result + 1 ;
19634: LD_ADDR_VAR 0 2
19638: PUSH
19639: LD_VAR 0 2
19643: PUSH
19644: LD_INT 1
19646: PLUS
19647: ST_TO_ADDR
19648: GO 19625
19650: POP
19651: POP
// end ;
19652: LD_VAR 0 2
19656: RET
// export function IsEmpty ( building ) ; begin
19657: LD_INT 0
19659: PPUSH
// if not building then
19660: LD_VAR 0 1
19664: NOT
19665: IFFALSE 19669
// exit ;
19667: GO 19712
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
19669: LD_ADDR_VAR 0 2
19673: PUSH
19674: LD_VAR 0 1
19678: PUSH
19679: LD_INT 22
19681: PUSH
19682: LD_VAR 0 1
19686: PPUSH
19687: CALL_OW 255
19691: PUSH
19692: EMPTY
19693: LIST
19694: LIST
19695: PUSH
19696: LD_INT 58
19698: PUSH
19699: EMPTY
19700: LIST
19701: PUSH
19702: EMPTY
19703: LIST
19704: LIST
19705: PPUSH
19706: CALL_OW 69
19710: IN
19711: ST_TO_ADDR
// end ;
19712: LD_VAR 0 2
19716: RET
// export function IsNotFull ( building ) ; begin
19717: LD_INT 0
19719: PPUSH
// if not building then
19720: LD_VAR 0 1
19724: NOT
19725: IFFALSE 19729
// exit ;
19727: GO 19748
// result := UnitsInside ( building ) < 6 ;
19729: LD_ADDR_VAR 0 2
19733: PUSH
19734: LD_VAR 0 1
19738: PPUSH
19739: CALL_OW 313
19743: PUSH
19744: LD_INT 6
19746: LESS
19747: ST_TO_ADDR
// end ;
19748: LD_VAR 0 2
19752: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
19753: LD_INT 0
19755: PPUSH
19756: PPUSH
19757: PPUSH
19758: PPUSH
// tmp := [ ] ;
19759: LD_ADDR_VAR 0 3
19763: PUSH
19764: EMPTY
19765: ST_TO_ADDR
// list := [ ] ;
19766: LD_ADDR_VAR 0 5
19770: PUSH
19771: EMPTY
19772: ST_TO_ADDR
// for i = 16 to 25 do
19773: LD_ADDR_VAR 0 4
19777: PUSH
19778: DOUBLE
19779: LD_INT 16
19781: DEC
19782: ST_TO_ADDR
19783: LD_INT 25
19785: PUSH
19786: FOR_TO
19787: IFFALSE 19860
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
19789: LD_ADDR_VAR 0 3
19793: PUSH
19794: LD_VAR 0 3
19798: PUSH
19799: LD_INT 22
19801: PUSH
19802: LD_VAR 0 1
19806: PPUSH
19807: CALL_OW 255
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: PUSH
19816: LD_INT 91
19818: PUSH
19819: LD_VAR 0 1
19823: PUSH
19824: LD_INT 6
19826: PUSH
19827: EMPTY
19828: LIST
19829: LIST
19830: LIST
19831: PUSH
19832: LD_INT 30
19834: PUSH
19835: LD_VAR 0 4
19839: PUSH
19840: EMPTY
19841: LIST
19842: LIST
19843: PUSH
19844: EMPTY
19845: LIST
19846: LIST
19847: LIST
19848: PUSH
19849: EMPTY
19850: LIST
19851: PPUSH
19852: CALL_OW 69
19856: ADD
19857: ST_TO_ADDR
19858: GO 19786
19860: POP
19861: POP
// for i = 1 to tmp do
19862: LD_ADDR_VAR 0 4
19866: PUSH
19867: DOUBLE
19868: LD_INT 1
19870: DEC
19871: ST_TO_ADDR
19872: LD_VAR 0 3
19876: PUSH
19877: FOR_TO
19878: IFFALSE 19966
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19880: LD_ADDR_VAR 0 5
19884: PUSH
19885: LD_VAR 0 5
19889: PUSH
19890: LD_VAR 0 3
19894: PUSH
19895: LD_VAR 0 4
19899: ARRAY
19900: PPUSH
19901: CALL_OW 266
19905: PUSH
19906: LD_VAR 0 3
19910: PUSH
19911: LD_VAR 0 4
19915: ARRAY
19916: PPUSH
19917: CALL_OW 250
19921: PUSH
19922: LD_VAR 0 3
19926: PUSH
19927: LD_VAR 0 4
19931: ARRAY
19932: PPUSH
19933: CALL_OW 251
19937: PUSH
19938: LD_VAR 0 3
19942: PUSH
19943: LD_VAR 0 4
19947: ARRAY
19948: PPUSH
19949: CALL_OW 254
19953: PUSH
19954: EMPTY
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: PUSH
19960: EMPTY
19961: LIST
19962: ADD
19963: ST_TO_ADDR
19964: GO 19877
19966: POP
19967: POP
// result := list ;
19968: LD_ADDR_VAR 0 2
19972: PUSH
19973: LD_VAR 0 5
19977: ST_TO_ADDR
// end ;
19978: LD_VAR 0 2
19982: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19983: LD_INT 0
19985: PPUSH
19986: PPUSH
19987: PPUSH
19988: PPUSH
19989: PPUSH
19990: PPUSH
19991: PPUSH
// if not factory then
19992: LD_VAR 0 1
19996: NOT
19997: IFFALSE 20001
// exit ;
19999: GO 20594
// if control = control_apeman then
20001: LD_VAR 0 4
20005: PUSH
20006: LD_INT 5
20008: EQUAL
20009: IFFALSE 20118
// begin tmp := UnitsInside ( factory ) ;
20011: LD_ADDR_VAR 0 8
20015: PUSH
20016: LD_VAR 0 1
20020: PPUSH
20021: CALL_OW 313
20025: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
20026: LD_VAR 0 8
20030: PPUSH
20031: LD_INT 25
20033: PUSH
20034: LD_INT 12
20036: PUSH
20037: EMPTY
20038: LIST
20039: LIST
20040: PPUSH
20041: CALL_OW 72
20045: NOT
20046: IFFALSE 20056
// control := control_manual ;
20048: LD_ADDR_VAR 0 4
20052: PUSH
20053: LD_INT 1
20055: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
20056: LD_ADDR_VAR 0 8
20060: PUSH
20061: LD_VAR 0 1
20065: PPUSH
20066: CALL 19753 0 1
20070: ST_TO_ADDR
// if tmp then
20071: LD_VAR 0 8
20075: IFFALSE 20118
// begin for i in tmp do
20077: LD_ADDR_VAR 0 7
20081: PUSH
20082: LD_VAR 0 8
20086: PUSH
20087: FOR_IN
20088: IFFALSE 20116
// if i [ 1 ] = b_ext_radio then
20090: LD_VAR 0 7
20094: PUSH
20095: LD_INT 1
20097: ARRAY
20098: PUSH
20099: LD_INT 22
20101: EQUAL
20102: IFFALSE 20114
// begin control := control_remote ;
20104: LD_ADDR_VAR 0 4
20108: PUSH
20109: LD_INT 2
20111: ST_TO_ADDR
// break ;
20112: GO 20116
// end ;
20114: GO 20087
20116: POP
20117: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20118: LD_VAR 0 1
20122: PPUSH
20123: LD_VAR 0 2
20127: PPUSH
20128: LD_VAR 0 3
20132: PPUSH
20133: LD_VAR 0 4
20137: PPUSH
20138: LD_VAR 0 5
20142: PPUSH
20143: CALL_OW 448
20147: IFFALSE 20182
// begin result := [ chassis , engine , control , weapon ] ;
20149: LD_ADDR_VAR 0 6
20153: PUSH
20154: LD_VAR 0 2
20158: PUSH
20159: LD_VAR 0 3
20163: PUSH
20164: LD_VAR 0 4
20168: PUSH
20169: LD_VAR 0 5
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: LIST
20178: LIST
20179: ST_TO_ADDR
// exit ;
20180: GO 20594
// end ; _chassis := AvailableChassisList ( factory ) ;
20182: LD_ADDR_VAR 0 9
20186: PUSH
20187: LD_VAR 0 1
20191: PPUSH
20192: CALL_OW 475
20196: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
20197: LD_ADDR_VAR 0 11
20201: PUSH
20202: LD_VAR 0 1
20206: PPUSH
20207: CALL_OW 476
20211: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
20212: LD_ADDR_VAR 0 12
20216: PUSH
20217: LD_VAR 0 1
20221: PPUSH
20222: CALL_OW 477
20226: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
20227: LD_ADDR_VAR 0 10
20231: PUSH
20232: LD_VAR 0 1
20236: PPUSH
20237: CALL_OW 478
20241: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
20242: LD_VAR 0 9
20246: NOT
20247: PUSH
20248: LD_VAR 0 11
20252: NOT
20253: OR
20254: PUSH
20255: LD_VAR 0 12
20259: NOT
20260: OR
20261: PUSH
20262: LD_VAR 0 10
20266: NOT
20267: OR
20268: IFFALSE 20303
// begin result := [ chassis , engine , control , weapon ] ;
20270: LD_ADDR_VAR 0 6
20274: PUSH
20275: LD_VAR 0 2
20279: PUSH
20280: LD_VAR 0 3
20284: PUSH
20285: LD_VAR 0 4
20289: PUSH
20290: LD_VAR 0 5
20294: PUSH
20295: EMPTY
20296: LIST
20297: LIST
20298: LIST
20299: LIST
20300: ST_TO_ADDR
// exit ;
20301: GO 20594
// end ; if not chassis in _chassis then
20303: LD_VAR 0 2
20307: PUSH
20308: LD_VAR 0 9
20312: IN
20313: NOT
20314: IFFALSE 20340
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
20316: LD_ADDR_VAR 0 2
20320: PUSH
20321: LD_VAR 0 9
20325: PUSH
20326: LD_INT 1
20328: PPUSH
20329: LD_VAR 0 9
20333: PPUSH
20334: CALL_OW 12
20338: ARRAY
20339: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
20340: LD_VAR 0 2
20344: PPUSH
20345: LD_VAR 0 3
20349: PPUSH
20350: CALL 20599 0 2
20354: NOT
20355: IFFALSE 20414
// repeat engine := _engine [ 1 ] ;
20357: LD_ADDR_VAR 0 3
20361: PUSH
20362: LD_VAR 0 11
20366: PUSH
20367: LD_INT 1
20369: ARRAY
20370: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
20371: LD_ADDR_VAR 0 11
20375: PUSH
20376: LD_VAR 0 11
20380: PPUSH
20381: LD_INT 1
20383: PPUSH
20384: CALL_OW 3
20388: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
20389: LD_VAR 0 2
20393: PPUSH
20394: LD_VAR 0 3
20398: PPUSH
20399: CALL 20599 0 2
20403: PUSH
20404: LD_VAR 0 11
20408: PUSH
20409: EMPTY
20410: EQUAL
20411: OR
20412: IFFALSE 20357
// if not control in _control then
20414: LD_VAR 0 4
20418: PUSH
20419: LD_VAR 0 12
20423: IN
20424: NOT
20425: IFFALSE 20451
// control := _control [ rand ( 1 , _control ) ] ;
20427: LD_ADDR_VAR 0 4
20431: PUSH
20432: LD_VAR 0 12
20436: PUSH
20437: LD_INT 1
20439: PPUSH
20440: LD_VAR 0 12
20444: PPUSH
20445: CALL_OW 12
20449: ARRAY
20450: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
20451: LD_VAR 0 2
20455: PPUSH
20456: LD_VAR 0 5
20460: PPUSH
20461: CALL 20819 0 2
20465: NOT
20466: IFFALSE 20525
// repeat weapon := _weapon [ 1 ] ;
20468: LD_ADDR_VAR 0 5
20472: PUSH
20473: LD_VAR 0 10
20477: PUSH
20478: LD_INT 1
20480: ARRAY
20481: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
20482: LD_ADDR_VAR 0 10
20486: PUSH
20487: LD_VAR 0 10
20491: PPUSH
20492: LD_INT 1
20494: PPUSH
20495: CALL_OW 3
20499: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
20500: LD_VAR 0 2
20504: PPUSH
20505: LD_VAR 0 5
20509: PPUSH
20510: CALL 20819 0 2
20514: PUSH
20515: LD_VAR 0 10
20519: PUSH
20520: EMPTY
20521: EQUAL
20522: OR
20523: IFFALSE 20468
// result := [ ] ;
20525: LD_ADDR_VAR 0 6
20529: PUSH
20530: EMPTY
20531: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20532: LD_VAR 0 1
20536: PPUSH
20537: LD_VAR 0 2
20541: PPUSH
20542: LD_VAR 0 3
20546: PPUSH
20547: LD_VAR 0 4
20551: PPUSH
20552: LD_VAR 0 5
20556: PPUSH
20557: CALL_OW 448
20561: IFFALSE 20594
// result := [ chassis , engine , control , weapon ] ;
20563: LD_ADDR_VAR 0 6
20567: PUSH
20568: LD_VAR 0 2
20572: PUSH
20573: LD_VAR 0 3
20577: PUSH
20578: LD_VAR 0 4
20582: PUSH
20583: LD_VAR 0 5
20587: PUSH
20588: EMPTY
20589: LIST
20590: LIST
20591: LIST
20592: LIST
20593: ST_TO_ADDR
// end ;
20594: LD_VAR 0 6
20598: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
20599: LD_INT 0
20601: PPUSH
// if not chassis or not engine then
20602: LD_VAR 0 1
20606: NOT
20607: PUSH
20608: LD_VAR 0 2
20612: NOT
20613: OR
20614: IFFALSE 20618
// exit ;
20616: GO 20814
// case engine of engine_solar :
20618: LD_VAR 0 2
20622: PUSH
20623: LD_INT 2
20625: DOUBLE
20626: EQUAL
20627: IFTRUE 20631
20629: GO 20669
20631: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
20632: LD_ADDR_VAR 0 3
20636: PUSH
20637: LD_INT 11
20639: PUSH
20640: LD_INT 12
20642: PUSH
20643: LD_INT 13
20645: PUSH
20646: LD_INT 14
20648: PUSH
20649: LD_INT 1
20651: PUSH
20652: LD_INT 2
20654: PUSH
20655: LD_INT 3
20657: PUSH
20658: EMPTY
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: LIST
20665: LIST
20666: ST_TO_ADDR
20667: GO 20798
20669: LD_INT 1
20671: DOUBLE
20672: EQUAL
20673: IFTRUE 20677
20675: GO 20739
20677: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
20678: LD_ADDR_VAR 0 3
20682: PUSH
20683: LD_INT 11
20685: PUSH
20686: LD_INT 12
20688: PUSH
20689: LD_INT 13
20691: PUSH
20692: LD_INT 14
20694: PUSH
20695: LD_INT 1
20697: PUSH
20698: LD_INT 2
20700: PUSH
20701: LD_INT 3
20703: PUSH
20704: LD_INT 4
20706: PUSH
20707: LD_INT 5
20709: PUSH
20710: LD_INT 21
20712: PUSH
20713: LD_INT 23
20715: PUSH
20716: LD_INT 22
20718: PUSH
20719: LD_INT 24
20721: PUSH
20722: EMPTY
20723: LIST
20724: LIST
20725: LIST
20726: LIST
20727: LIST
20728: LIST
20729: LIST
20730: LIST
20731: LIST
20732: LIST
20733: LIST
20734: LIST
20735: LIST
20736: ST_TO_ADDR
20737: GO 20798
20739: LD_INT 3
20741: DOUBLE
20742: EQUAL
20743: IFTRUE 20747
20745: GO 20797
20747: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20748: LD_ADDR_VAR 0 3
20752: PUSH
20753: LD_INT 13
20755: PUSH
20756: LD_INT 14
20758: PUSH
20759: LD_INT 2
20761: PUSH
20762: LD_INT 3
20764: PUSH
20765: LD_INT 4
20767: PUSH
20768: LD_INT 5
20770: PUSH
20771: LD_INT 21
20773: PUSH
20774: LD_INT 22
20776: PUSH
20777: LD_INT 23
20779: PUSH
20780: LD_INT 24
20782: PUSH
20783: EMPTY
20784: LIST
20785: LIST
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: LIST
20792: LIST
20793: LIST
20794: ST_TO_ADDR
20795: GO 20798
20797: POP
// result := ( chassis in result ) ;
20798: LD_ADDR_VAR 0 3
20802: PUSH
20803: LD_VAR 0 1
20807: PUSH
20808: LD_VAR 0 3
20812: IN
20813: ST_TO_ADDR
// end ;
20814: LD_VAR 0 3
20818: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20819: LD_INT 0
20821: PPUSH
// if not chassis or not weapon then
20822: LD_VAR 0 1
20826: NOT
20827: PUSH
20828: LD_VAR 0 2
20832: NOT
20833: OR
20834: IFFALSE 20838
// exit ;
20836: GO 21864
// case weapon of us_machine_gun :
20838: LD_VAR 0 2
20842: PUSH
20843: LD_INT 2
20845: DOUBLE
20846: EQUAL
20847: IFTRUE 20851
20849: GO 20881
20851: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20852: LD_ADDR_VAR 0 3
20856: PUSH
20857: LD_INT 1
20859: PUSH
20860: LD_INT 2
20862: PUSH
20863: LD_INT 3
20865: PUSH
20866: LD_INT 4
20868: PUSH
20869: LD_INT 5
20871: PUSH
20872: EMPTY
20873: LIST
20874: LIST
20875: LIST
20876: LIST
20877: LIST
20878: ST_TO_ADDR
20879: GO 21848
20881: LD_INT 3
20883: DOUBLE
20884: EQUAL
20885: IFTRUE 20889
20887: GO 20919
20889: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20890: LD_ADDR_VAR 0 3
20894: PUSH
20895: LD_INT 1
20897: PUSH
20898: LD_INT 2
20900: PUSH
20901: LD_INT 3
20903: PUSH
20904: LD_INT 4
20906: PUSH
20907: LD_INT 5
20909: PUSH
20910: EMPTY
20911: LIST
20912: LIST
20913: LIST
20914: LIST
20915: LIST
20916: ST_TO_ADDR
20917: GO 21848
20919: LD_INT 11
20921: DOUBLE
20922: EQUAL
20923: IFTRUE 20927
20925: GO 20957
20927: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20928: LD_ADDR_VAR 0 3
20932: PUSH
20933: LD_INT 1
20935: PUSH
20936: LD_INT 2
20938: PUSH
20939: LD_INT 3
20941: PUSH
20942: LD_INT 4
20944: PUSH
20945: LD_INT 5
20947: PUSH
20948: EMPTY
20949: LIST
20950: LIST
20951: LIST
20952: LIST
20953: LIST
20954: ST_TO_ADDR
20955: GO 21848
20957: LD_INT 4
20959: DOUBLE
20960: EQUAL
20961: IFTRUE 20965
20963: GO 20991
20965: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20966: LD_ADDR_VAR 0 3
20970: PUSH
20971: LD_INT 2
20973: PUSH
20974: LD_INT 3
20976: PUSH
20977: LD_INT 4
20979: PUSH
20980: LD_INT 5
20982: PUSH
20983: EMPTY
20984: LIST
20985: LIST
20986: LIST
20987: LIST
20988: ST_TO_ADDR
20989: GO 21848
20991: LD_INT 5
20993: DOUBLE
20994: EQUAL
20995: IFTRUE 20999
20997: GO 21025
20999: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
21000: LD_ADDR_VAR 0 3
21004: PUSH
21005: LD_INT 2
21007: PUSH
21008: LD_INT 3
21010: PUSH
21011: LD_INT 4
21013: PUSH
21014: LD_INT 5
21016: PUSH
21017: EMPTY
21018: LIST
21019: LIST
21020: LIST
21021: LIST
21022: ST_TO_ADDR
21023: GO 21848
21025: LD_INT 9
21027: DOUBLE
21028: EQUAL
21029: IFTRUE 21033
21031: GO 21059
21033: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
21034: LD_ADDR_VAR 0 3
21038: PUSH
21039: LD_INT 2
21041: PUSH
21042: LD_INT 3
21044: PUSH
21045: LD_INT 4
21047: PUSH
21048: LD_INT 5
21050: PUSH
21051: EMPTY
21052: LIST
21053: LIST
21054: LIST
21055: LIST
21056: ST_TO_ADDR
21057: GO 21848
21059: LD_INT 7
21061: DOUBLE
21062: EQUAL
21063: IFTRUE 21067
21065: GO 21093
21067: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
21068: LD_ADDR_VAR 0 3
21072: PUSH
21073: LD_INT 2
21075: PUSH
21076: LD_INT 3
21078: PUSH
21079: LD_INT 4
21081: PUSH
21082: LD_INT 5
21084: PUSH
21085: EMPTY
21086: LIST
21087: LIST
21088: LIST
21089: LIST
21090: ST_TO_ADDR
21091: GO 21848
21093: LD_INT 12
21095: DOUBLE
21096: EQUAL
21097: IFTRUE 21101
21099: GO 21127
21101: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
21102: LD_ADDR_VAR 0 3
21106: PUSH
21107: LD_INT 2
21109: PUSH
21110: LD_INT 3
21112: PUSH
21113: LD_INT 4
21115: PUSH
21116: LD_INT 5
21118: PUSH
21119: EMPTY
21120: LIST
21121: LIST
21122: LIST
21123: LIST
21124: ST_TO_ADDR
21125: GO 21848
21127: LD_INT 13
21129: DOUBLE
21130: EQUAL
21131: IFTRUE 21135
21133: GO 21161
21135: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
21136: LD_ADDR_VAR 0 3
21140: PUSH
21141: LD_INT 2
21143: PUSH
21144: LD_INT 3
21146: PUSH
21147: LD_INT 4
21149: PUSH
21150: LD_INT 5
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: ST_TO_ADDR
21159: GO 21848
21161: LD_INT 14
21163: DOUBLE
21164: EQUAL
21165: IFTRUE 21169
21167: GO 21187
21169: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
21170: LD_ADDR_VAR 0 3
21174: PUSH
21175: LD_INT 4
21177: PUSH
21178: LD_INT 5
21180: PUSH
21181: EMPTY
21182: LIST
21183: LIST
21184: ST_TO_ADDR
21185: GO 21848
21187: LD_INT 6
21189: DOUBLE
21190: EQUAL
21191: IFTRUE 21195
21193: GO 21213
21195: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
21196: LD_ADDR_VAR 0 3
21200: PUSH
21201: LD_INT 4
21203: PUSH
21204: LD_INT 5
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: ST_TO_ADDR
21211: GO 21848
21213: LD_INT 10
21215: DOUBLE
21216: EQUAL
21217: IFTRUE 21221
21219: GO 21239
21221: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
21222: LD_ADDR_VAR 0 3
21226: PUSH
21227: LD_INT 4
21229: PUSH
21230: LD_INT 5
21232: PUSH
21233: EMPTY
21234: LIST
21235: LIST
21236: ST_TO_ADDR
21237: GO 21848
21239: LD_INT 22
21241: DOUBLE
21242: EQUAL
21243: IFTRUE 21247
21245: GO 21273
21247: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
21248: LD_ADDR_VAR 0 3
21252: PUSH
21253: LD_INT 11
21255: PUSH
21256: LD_INT 12
21258: PUSH
21259: LD_INT 13
21261: PUSH
21262: LD_INT 14
21264: PUSH
21265: EMPTY
21266: LIST
21267: LIST
21268: LIST
21269: LIST
21270: ST_TO_ADDR
21271: GO 21848
21273: LD_INT 23
21275: DOUBLE
21276: EQUAL
21277: IFTRUE 21281
21279: GO 21307
21281: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
21282: LD_ADDR_VAR 0 3
21286: PUSH
21287: LD_INT 11
21289: PUSH
21290: LD_INT 12
21292: PUSH
21293: LD_INT 13
21295: PUSH
21296: LD_INT 14
21298: PUSH
21299: EMPTY
21300: LIST
21301: LIST
21302: LIST
21303: LIST
21304: ST_TO_ADDR
21305: GO 21848
21307: LD_INT 24
21309: DOUBLE
21310: EQUAL
21311: IFTRUE 21315
21313: GO 21341
21315: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
21316: LD_ADDR_VAR 0 3
21320: PUSH
21321: LD_INT 11
21323: PUSH
21324: LD_INT 12
21326: PUSH
21327: LD_INT 13
21329: PUSH
21330: LD_INT 14
21332: PUSH
21333: EMPTY
21334: LIST
21335: LIST
21336: LIST
21337: LIST
21338: ST_TO_ADDR
21339: GO 21848
21341: LD_INT 30
21343: DOUBLE
21344: EQUAL
21345: IFTRUE 21349
21347: GO 21375
21349: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
21350: LD_ADDR_VAR 0 3
21354: PUSH
21355: LD_INT 11
21357: PUSH
21358: LD_INT 12
21360: PUSH
21361: LD_INT 13
21363: PUSH
21364: LD_INT 14
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: LIST
21371: LIST
21372: ST_TO_ADDR
21373: GO 21848
21375: LD_INT 25
21377: DOUBLE
21378: EQUAL
21379: IFTRUE 21383
21381: GO 21401
21383: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
21384: LD_ADDR_VAR 0 3
21388: PUSH
21389: LD_INT 13
21391: PUSH
21392: LD_INT 14
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: ST_TO_ADDR
21399: GO 21848
21401: LD_INT 27
21403: DOUBLE
21404: EQUAL
21405: IFTRUE 21409
21407: GO 21427
21409: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
21410: LD_ADDR_VAR 0 3
21414: PUSH
21415: LD_INT 13
21417: PUSH
21418: LD_INT 14
21420: PUSH
21421: EMPTY
21422: LIST
21423: LIST
21424: ST_TO_ADDR
21425: GO 21848
21427: LD_INT 28
21429: DOUBLE
21430: EQUAL
21431: IFTRUE 21435
21433: GO 21453
21435: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
21436: LD_ADDR_VAR 0 3
21440: PUSH
21441: LD_INT 13
21443: PUSH
21444: LD_INT 14
21446: PUSH
21447: EMPTY
21448: LIST
21449: LIST
21450: ST_TO_ADDR
21451: GO 21848
21453: LD_INT 29
21455: DOUBLE
21456: EQUAL
21457: IFTRUE 21461
21459: GO 21479
21461: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
21462: LD_ADDR_VAR 0 3
21466: PUSH
21467: LD_INT 13
21469: PUSH
21470: LD_INT 14
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: ST_TO_ADDR
21477: GO 21848
21479: LD_INT 31
21481: DOUBLE
21482: EQUAL
21483: IFTRUE 21487
21485: GO 21505
21487: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
21488: LD_ADDR_VAR 0 3
21492: PUSH
21493: LD_INT 13
21495: PUSH
21496: LD_INT 14
21498: PUSH
21499: EMPTY
21500: LIST
21501: LIST
21502: ST_TO_ADDR
21503: GO 21848
21505: LD_INT 26
21507: DOUBLE
21508: EQUAL
21509: IFTRUE 21513
21511: GO 21531
21513: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
21514: LD_ADDR_VAR 0 3
21518: PUSH
21519: LD_INT 13
21521: PUSH
21522: LD_INT 14
21524: PUSH
21525: EMPTY
21526: LIST
21527: LIST
21528: ST_TO_ADDR
21529: GO 21848
21531: LD_INT 42
21533: DOUBLE
21534: EQUAL
21535: IFTRUE 21539
21537: GO 21565
21539: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
21540: LD_ADDR_VAR 0 3
21544: PUSH
21545: LD_INT 21
21547: PUSH
21548: LD_INT 22
21550: PUSH
21551: LD_INT 23
21553: PUSH
21554: LD_INT 24
21556: PUSH
21557: EMPTY
21558: LIST
21559: LIST
21560: LIST
21561: LIST
21562: ST_TO_ADDR
21563: GO 21848
21565: LD_INT 43
21567: DOUBLE
21568: EQUAL
21569: IFTRUE 21573
21571: GO 21599
21573: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
21574: LD_ADDR_VAR 0 3
21578: PUSH
21579: LD_INT 21
21581: PUSH
21582: LD_INT 22
21584: PUSH
21585: LD_INT 23
21587: PUSH
21588: LD_INT 24
21590: PUSH
21591: EMPTY
21592: LIST
21593: LIST
21594: LIST
21595: LIST
21596: ST_TO_ADDR
21597: GO 21848
21599: LD_INT 44
21601: DOUBLE
21602: EQUAL
21603: IFTRUE 21607
21605: GO 21633
21607: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
21608: LD_ADDR_VAR 0 3
21612: PUSH
21613: LD_INT 21
21615: PUSH
21616: LD_INT 22
21618: PUSH
21619: LD_INT 23
21621: PUSH
21622: LD_INT 24
21624: PUSH
21625: EMPTY
21626: LIST
21627: LIST
21628: LIST
21629: LIST
21630: ST_TO_ADDR
21631: GO 21848
21633: LD_INT 45
21635: DOUBLE
21636: EQUAL
21637: IFTRUE 21641
21639: GO 21667
21641: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
21642: LD_ADDR_VAR 0 3
21646: PUSH
21647: LD_INT 21
21649: PUSH
21650: LD_INT 22
21652: PUSH
21653: LD_INT 23
21655: PUSH
21656: LD_INT 24
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: ST_TO_ADDR
21665: GO 21848
21667: LD_INT 49
21669: DOUBLE
21670: EQUAL
21671: IFTRUE 21675
21673: GO 21701
21675: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
21676: LD_ADDR_VAR 0 3
21680: PUSH
21681: LD_INT 21
21683: PUSH
21684: LD_INT 22
21686: PUSH
21687: LD_INT 23
21689: PUSH
21690: LD_INT 24
21692: PUSH
21693: EMPTY
21694: LIST
21695: LIST
21696: LIST
21697: LIST
21698: ST_TO_ADDR
21699: GO 21848
21701: LD_INT 51
21703: DOUBLE
21704: EQUAL
21705: IFTRUE 21709
21707: GO 21735
21709: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
21710: LD_ADDR_VAR 0 3
21714: PUSH
21715: LD_INT 21
21717: PUSH
21718: LD_INT 22
21720: PUSH
21721: LD_INT 23
21723: PUSH
21724: LD_INT 24
21726: PUSH
21727: EMPTY
21728: LIST
21729: LIST
21730: LIST
21731: LIST
21732: ST_TO_ADDR
21733: GO 21848
21735: LD_INT 52
21737: DOUBLE
21738: EQUAL
21739: IFTRUE 21743
21741: GO 21769
21743: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
21744: LD_ADDR_VAR 0 3
21748: PUSH
21749: LD_INT 21
21751: PUSH
21752: LD_INT 22
21754: PUSH
21755: LD_INT 23
21757: PUSH
21758: LD_INT 24
21760: PUSH
21761: EMPTY
21762: LIST
21763: LIST
21764: LIST
21765: LIST
21766: ST_TO_ADDR
21767: GO 21848
21769: LD_INT 53
21771: DOUBLE
21772: EQUAL
21773: IFTRUE 21777
21775: GO 21795
21777: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
21778: LD_ADDR_VAR 0 3
21782: PUSH
21783: LD_INT 23
21785: PUSH
21786: LD_INT 24
21788: PUSH
21789: EMPTY
21790: LIST
21791: LIST
21792: ST_TO_ADDR
21793: GO 21848
21795: LD_INT 46
21797: DOUBLE
21798: EQUAL
21799: IFTRUE 21803
21801: GO 21821
21803: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21804: LD_ADDR_VAR 0 3
21808: PUSH
21809: LD_INT 23
21811: PUSH
21812: LD_INT 24
21814: PUSH
21815: EMPTY
21816: LIST
21817: LIST
21818: ST_TO_ADDR
21819: GO 21848
21821: LD_INT 47
21823: DOUBLE
21824: EQUAL
21825: IFTRUE 21829
21827: GO 21847
21829: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21830: LD_ADDR_VAR 0 3
21834: PUSH
21835: LD_INT 23
21837: PUSH
21838: LD_INT 24
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: ST_TO_ADDR
21845: GO 21848
21847: POP
// result := ( chassis in result ) ;
21848: LD_ADDR_VAR 0 3
21852: PUSH
21853: LD_VAR 0 1
21857: PUSH
21858: LD_VAR 0 3
21862: IN
21863: ST_TO_ADDR
// end ;
21864: LD_VAR 0 3
21868: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21869: LD_INT 0
21871: PPUSH
21872: PPUSH
21873: PPUSH
21874: PPUSH
21875: PPUSH
21876: PPUSH
21877: PPUSH
// result := array ;
21878: LD_ADDR_VAR 0 5
21882: PUSH
21883: LD_VAR 0 1
21887: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21888: LD_VAR 0 1
21892: NOT
21893: PUSH
21894: LD_VAR 0 2
21898: NOT
21899: OR
21900: PUSH
21901: LD_VAR 0 3
21905: NOT
21906: OR
21907: PUSH
21908: LD_VAR 0 2
21912: PUSH
21913: LD_VAR 0 1
21917: GREATER
21918: OR
21919: PUSH
21920: LD_VAR 0 3
21924: PUSH
21925: LD_VAR 0 1
21929: GREATER
21930: OR
21931: IFFALSE 21935
// exit ;
21933: GO 22231
// if direction then
21935: LD_VAR 0 4
21939: IFFALSE 22003
// begin d := 1 ;
21941: LD_ADDR_VAR 0 9
21945: PUSH
21946: LD_INT 1
21948: ST_TO_ADDR
// if i_from > i_to then
21949: LD_VAR 0 2
21953: PUSH
21954: LD_VAR 0 3
21958: GREATER
21959: IFFALSE 21985
// length := ( array - i_from ) + i_to else
21961: LD_ADDR_VAR 0 11
21965: PUSH
21966: LD_VAR 0 1
21970: PUSH
21971: LD_VAR 0 2
21975: MINUS
21976: PUSH
21977: LD_VAR 0 3
21981: PLUS
21982: ST_TO_ADDR
21983: GO 22001
// length := i_to - i_from ;
21985: LD_ADDR_VAR 0 11
21989: PUSH
21990: LD_VAR 0 3
21994: PUSH
21995: LD_VAR 0 2
21999: MINUS
22000: ST_TO_ADDR
// end else
22001: GO 22064
// begin d := - 1 ;
22003: LD_ADDR_VAR 0 9
22007: PUSH
22008: LD_INT 1
22010: NEG
22011: ST_TO_ADDR
// if i_from > i_to then
22012: LD_VAR 0 2
22016: PUSH
22017: LD_VAR 0 3
22021: GREATER
22022: IFFALSE 22042
// length := i_from - i_to else
22024: LD_ADDR_VAR 0 11
22028: PUSH
22029: LD_VAR 0 2
22033: PUSH
22034: LD_VAR 0 3
22038: MINUS
22039: ST_TO_ADDR
22040: GO 22064
// length := ( array - i_to ) + i_from ;
22042: LD_ADDR_VAR 0 11
22046: PUSH
22047: LD_VAR 0 1
22051: PUSH
22052: LD_VAR 0 3
22056: MINUS
22057: PUSH
22058: LD_VAR 0 2
22062: PLUS
22063: ST_TO_ADDR
// end ; if not length then
22064: LD_VAR 0 11
22068: NOT
22069: IFFALSE 22073
// exit ;
22071: GO 22231
// tmp := array ;
22073: LD_ADDR_VAR 0 10
22077: PUSH
22078: LD_VAR 0 1
22082: ST_TO_ADDR
// for i = 1 to length do
22083: LD_ADDR_VAR 0 6
22087: PUSH
22088: DOUBLE
22089: LD_INT 1
22091: DEC
22092: ST_TO_ADDR
22093: LD_VAR 0 11
22097: PUSH
22098: FOR_TO
22099: IFFALSE 22219
// begin for j = 1 to array do
22101: LD_ADDR_VAR 0 7
22105: PUSH
22106: DOUBLE
22107: LD_INT 1
22109: DEC
22110: ST_TO_ADDR
22111: LD_VAR 0 1
22115: PUSH
22116: FOR_TO
22117: IFFALSE 22205
// begin k := j + d ;
22119: LD_ADDR_VAR 0 8
22123: PUSH
22124: LD_VAR 0 7
22128: PUSH
22129: LD_VAR 0 9
22133: PLUS
22134: ST_TO_ADDR
// if k > array then
22135: LD_VAR 0 8
22139: PUSH
22140: LD_VAR 0 1
22144: GREATER
22145: IFFALSE 22155
// k := 1 ;
22147: LD_ADDR_VAR 0 8
22151: PUSH
22152: LD_INT 1
22154: ST_TO_ADDR
// if not k then
22155: LD_VAR 0 8
22159: NOT
22160: IFFALSE 22172
// k := array ;
22162: LD_ADDR_VAR 0 8
22166: PUSH
22167: LD_VAR 0 1
22171: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
22172: LD_ADDR_VAR 0 10
22176: PUSH
22177: LD_VAR 0 10
22181: PPUSH
22182: LD_VAR 0 8
22186: PPUSH
22187: LD_VAR 0 1
22191: PUSH
22192: LD_VAR 0 7
22196: ARRAY
22197: PPUSH
22198: CALL_OW 1
22202: ST_TO_ADDR
// end ;
22203: GO 22116
22205: POP
22206: POP
// array := tmp ;
22207: LD_ADDR_VAR 0 1
22211: PUSH
22212: LD_VAR 0 10
22216: ST_TO_ADDR
// end ;
22217: GO 22098
22219: POP
22220: POP
// result := array ;
22221: LD_ADDR_VAR 0 5
22225: PUSH
22226: LD_VAR 0 1
22230: ST_TO_ADDR
// end ;
22231: LD_VAR 0 5
22235: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
22236: LD_INT 0
22238: PPUSH
22239: PPUSH
// result := 0 ;
22240: LD_ADDR_VAR 0 3
22244: PUSH
22245: LD_INT 0
22247: ST_TO_ADDR
// if not array or not value in array then
22248: LD_VAR 0 1
22252: NOT
22253: PUSH
22254: LD_VAR 0 2
22258: PUSH
22259: LD_VAR 0 1
22263: IN
22264: NOT
22265: OR
22266: IFFALSE 22270
// exit ;
22268: GO 22324
// for i = 1 to array do
22270: LD_ADDR_VAR 0 4
22274: PUSH
22275: DOUBLE
22276: LD_INT 1
22278: DEC
22279: ST_TO_ADDR
22280: LD_VAR 0 1
22284: PUSH
22285: FOR_TO
22286: IFFALSE 22322
// if value = array [ i ] then
22288: LD_VAR 0 2
22292: PUSH
22293: LD_VAR 0 1
22297: PUSH
22298: LD_VAR 0 4
22302: ARRAY
22303: EQUAL
22304: IFFALSE 22320
// begin result := i ;
22306: LD_ADDR_VAR 0 3
22310: PUSH
22311: LD_VAR 0 4
22315: ST_TO_ADDR
// exit ;
22316: POP
22317: POP
22318: GO 22324
// end ;
22320: GO 22285
22322: POP
22323: POP
// end ;
22324: LD_VAR 0 3
22328: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
22329: LD_INT 0
22331: PPUSH
// vc_chassis := chassis ;
22332: LD_ADDR_OWVAR 37
22336: PUSH
22337: LD_VAR 0 1
22341: ST_TO_ADDR
// vc_engine := engine ;
22342: LD_ADDR_OWVAR 39
22346: PUSH
22347: LD_VAR 0 2
22351: ST_TO_ADDR
// vc_control := control ;
22352: LD_ADDR_OWVAR 38
22356: PUSH
22357: LD_VAR 0 3
22361: ST_TO_ADDR
// vc_weapon := weapon ;
22362: LD_ADDR_OWVAR 40
22366: PUSH
22367: LD_VAR 0 4
22371: ST_TO_ADDR
// vc_fuel_battery := fuel ;
22372: LD_ADDR_OWVAR 41
22376: PUSH
22377: LD_VAR 0 5
22381: ST_TO_ADDR
// end ;
22382: LD_VAR 0 6
22386: RET
// export function WantPlant ( unit ) ; var task ; begin
22387: LD_INT 0
22389: PPUSH
22390: PPUSH
// result := false ;
22391: LD_ADDR_VAR 0 2
22395: PUSH
22396: LD_INT 0
22398: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
22399: LD_ADDR_VAR 0 3
22403: PUSH
22404: LD_VAR 0 1
22408: PPUSH
22409: CALL_OW 437
22413: ST_TO_ADDR
// if task then
22414: LD_VAR 0 3
22418: IFFALSE 22446
// if task [ 1 ] [ 1 ] = p then
22420: LD_VAR 0 3
22424: PUSH
22425: LD_INT 1
22427: ARRAY
22428: PUSH
22429: LD_INT 1
22431: ARRAY
22432: PUSH
22433: LD_STRING p
22435: EQUAL
22436: IFFALSE 22446
// result := true ;
22438: LD_ADDR_VAR 0 2
22442: PUSH
22443: LD_INT 1
22445: ST_TO_ADDR
// end ;
22446: LD_VAR 0 2
22450: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
22451: LD_INT 0
22453: PPUSH
22454: PPUSH
22455: PPUSH
22456: PPUSH
// if pos < 1 then
22457: LD_VAR 0 2
22461: PUSH
22462: LD_INT 1
22464: LESS
22465: IFFALSE 22469
// exit ;
22467: GO 22772
// if pos = 1 then
22469: LD_VAR 0 2
22473: PUSH
22474: LD_INT 1
22476: EQUAL
22477: IFFALSE 22510
// result := Replace ( arr , pos [ 1 ] , value ) else
22479: LD_ADDR_VAR 0 4
22483: PUSH
22484: LD_VAR 0 1
22488: PPUSH
22489: LD_VAR 0 2
22493: PUSH
22494: LD_INT 1
22496: ARRAY
22497: PPUSH
22498: LD_VAR 0 3
22502: PPUSH
22503: CALL_OW 1
22507: ST_TO_ADDR
22508: GO 22772
// begin tmp := arr ;
22510: LD_ADDR_VAR 0 6
22514: PUSH
22515: LD_VAR 0 1
22519: ST_TO_ADDR
// s_arr := [ tmp ] ;
22520: LD_ADDR_VAR 0 7
22524: PUSH
22525: LD_VAR 0 6
22529: PUSH
22530: EMPTY
22531: LIST
22532: ST_TO_ADDR
// for i = 1 to pos - 1 do
22533: LD_ADDR_VAR 0 5
22537: PUSH
22538: DOUBLE
22539: LD_INT 1
22541: DEC
22542: ST_TO_ADDR
22543: LD_VAR 0 2
22547: PUSH
22548: LD_INT 1
22550: MINUS
22551: PUSH
22552: FOR_TO
22553: IFFALSE 22598
// begin tmp := tmp [ pos [ i ] ] ;
22555: LD_ADDR_VAR 0 6
22559: PUSH
22560: LD_VAR 0 6
22564: PUSH
22565: LD_VAR 0 2
22569: PUSH
22570: LD_VAR 0 5
22574: ARRAY
22575: ARRAY
22576: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
22577: LD_ADDR_VAR 0 7
22581: PUSH
22582: LD_VAR 0 7
22586: PUSH
22587: LD_VAR 0 6
22591: PUSH
22592: EMPTY
22593: LIST
22594: ADD
22595: ST_TO_ADDR
// end ;
22596: GO 22552
22598: POP
22599: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
22600: LD_ADDR_VAR 0 6
22604: PUSH
22605: LD_VAR 0 6
22609: PPUSH
22610: LD_VAR 0 2
22614: PUSH
22615: LD_VAR 0 2
22619: ARRAY
22620: PPUSH
22621: LD_VAR 0 3
22625: PPUSH
22626: CALL_OW 1
22630: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
22631: LD_ADDR_VAR 0 7
22635: PUSH
22636: LD_VAR 0 7
22640: PPUSH
22641: LD_VAR 0 7
22645: PPUSH
22646: LD_VAR 0 6
22650: PPUSH
22651: CALL_OW 1
22655: ST_TO_ADDR
// for i = s_arr downto 2 do
22656: LD_ADDR_VAR 0 5
22660: PUSH
22661: DOUBLE
22662: LD_VAR 0 7
22666: INC
22667: ST_TO_ADDR
22668: LD_INT 2
22670: PUSH
22671: FOR_DOWNTO
22672: IFFALSE 22756
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
22674: LD_ADDR_VAR 0 6
22678: PUSH
22679: LD_VAR 0 7
22683: PUSH
22684: LD_VAR 0 5
22688: PUSH
22689: LD_INT 1
22691: MINUS
22692: ARRAY
22693: PPUSH
22694: LD_VAR 0 2
22698: PUSH
22699: LD_VAR 0 5
22703: PUSH
22704: LD_INT 1
22706: MINUS
22707: ARRAY
22708: PPUSH
22709: LD_VAR 0 7
22713: PUSH
22714: LD_VAR 0 5
22718: ARRAY
22719: PPUSH
22720: CALL_OW 1
22724: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
22725: LD_ADDR_VAR 0 7
22729: PUSH
22730: LD_VAR 0 7
22734: PPUSH
22735: LD_VAR 0 5
22739: PUSH
22740: LD_INT 1
22742: MINUS
22743: PPUSH
22744: LD_VAR 0 6
22748: PPUSH
22749: CALL_OW 1
22753: ST_TO_ADDR
// end ;
22754: GO 22671
22756: POP
22757: POP
// result := s_arr [ 1 ] ;
22758: LD_ADDR_VAR 0 4
22762: PUSH
22763: LD_VAR 0 7
22767: PUSH
22768: LD_INT 1
22770: ARRAY
22771: ST_TO_ADDR
// end ; end ;
22772: LD_VAR 0 4
22776: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
22777: LD_INT 0
22779: PPUSH
22780: PPUSH
// if not list then
22781: LD_VAR 0 1
22785: NOT
22786: IFFALSE 22790
// exit ;
22788: GO 22881
// i := list [ pos1 ] ;
22790: LD_ADDR_VAR 0 5
22794: PUSH
22795: LD_VAR 0 1
22799: PUSH
22800: LD_VAR 0 2
22804: ARRAY
22805: ST_TO_ADDR
// if not i then
22806: LD_VAR 0 5
22810: NOT
22811: IFFALSE 22815
// exit ;
22813: GO 22881
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22815: LD_ADDR_VAR 0 1
22819: PUSH
22820: LD_VAR 0 1
22824: PPUSH
22825: LD_VAR 0 2
22829: PPUSH
22830: LD_VAR 0 1
22834: PUSH
22835: LD_VAR 0 3
22839: ARRAY
22840: PPUSH
22841: CALL_OW 1
22845: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22846: LD_ADDR_VAR 0 1
22850: PUSH
22851: LD_VAR 0 1
22855: PPUSH
22856: LD_VAR 0 3
22860: PPUSH
22861: LD_VAR 0 5
22865: PPUSH
22866: CALL_OW 1
22870: ST_TO_ADDR
// result := list ;
22871: LD_ADDR_VAR 0 4
22875: PUSH
22876: LD_VAR 0 1
22880: ST_TO_ADDR
// end ;
22881: LD_VAR 0 4
22885: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22886: LD_INT 0
22888: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22889: LD_ADDR_VAR 0 5
22893: PUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 250
22903: PPUSH
22904: LD_VAR 0 1
22908: PPUSH
22909: CALL_OW 251
22913: PPUSH
22914: LD_VAR 0 2
22918: PPUSH
22919: LD_VAR 0 3
22923: PPUSH
22924: LD_VAR 0 4
22928: PPUSH
22929: CALL 22939 0 5
22933: ST_TO_ADDR
// end ;
22934: LD_VAR 0 5
22938: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
22939: LD_INT 0
22941: PPUSH
22942: PPUSH
22943: PPUSH
22944: PPUSH
// if not list then
22945: LD_VAR 0 3
22949: NOT
22950: IFFALSE 22954
// exit ;
22952: GO 23342
// result := [ ] ;
22954: LD_ADDR_VAR 0 6
22958: PUSH
22959: EMPTY
22960: ST_TO_ADDR
// for i in list do
22961: LD_ADDR_VAR 0 7
22965: PUSH
22966: LD_VAR 0 3
22970: PUSH
22971: FOR_IN
22972: IFFALSE 23174
// begin tmp := GetDistUnitXY ( i , x , y ) ;
22974: LD_ADDR_VAR 0 9
22978: PUSH
22979: LD_VAR 0 7
22983: PPUSH
22984: LD_VAR 0 1
22988: PPUSH
22989: LD_VAR 0 2
22993: PPUSH
22994: CALL_OW 297
22998: ST_TO_ADDR
// if not result then
22999: LD_VAR 0 6
23003: NOT
23004: IFFALSE 23030
// result := [ [ i , tmp ] ] else
23006: LD_ADDR_VAR 0 6
23010: PUSH
23011: LD_VAR 0 7
23015: PUSH
23016: LD_VAR 0 9
23020: PUSH
23021: EMPTY
23022: LIST
23023: LIST
23024: PUSH
23025: EMPTY
23026: LIST
23027: ST_TO_ADDR
23028: GO 23172
// begin if result [ result ] [ 2 ] < tmp then
23030: LD_VAR 0 6
23034: PUSH
23035: LD_VAR 0 6
23039: ARRAY
23040: PUSH
23041: LD_INT 2
23043: ARRAY
23044: PUSH
23045: LD_VAR 0 9
23049: LESS
23050: IFFALSE 23092
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
23052: LD_ADDR_VAR 0 6
23056: PUSH
23057: LD_VAR 0 6
23061: PPUSH
23062: LD_VAR 0 6
23066: PUSH
23067: LD_INT 1
23069: PLUS
23070: PPUSH
23071: LD_VAR 0 7
23075: PUSH
23076: LD_VAR 0 9
23080: PUSH
23081: EMPTY
23082: LIST
23083: LIST
23084: PPUSH
23085: CALL_OW 2
23089: ST_TO_ADDR
23090: GO 23172
// for j = 1 to result do
23092: LD_ADDR_VAR 0 8
23096: PUSH
23097: DOUBLE
23098: LD_INT 1
23100: DEC
23101: ST_TO_ADDR
23102: LD_VAR 0 6
23106: PUSH
23107: FOR_TO
23108: IFFALSE 23170
// begin if tmp < result [ j ] [ 2 ] then
23110: LD_VAR 0 9
23114: PUSH
23115: LD_VAR 0 6
23119: PUSH
23120: LD_VAR 0 8
23124: ARRAY
23125: PUSH
23126: LD_INT 2
23128: ARRAY
23129: LESS
23130: IFFALSE 23168
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23132: LD_ADDR_VAR 0 6
23136: PUSH
23137: LD_VAR 0 6
23141: PPUSH
23142: LD_VAR 0 8
23146: PPUSH
23147: LD_VAR 0 7
23151: PUSH
23152: LD_VAR 0 9
23156: PUSH
23157: EMPTY
23158: LIST
23159: LIST
23160: PPUSH
23161: CALL_OW 2
23165: ST_TO_ADDR
// break ;
23166: GO 23170
// end ; end ;
23168: GO 23107
23170: POP
23171: POP
// end ; end ;
23172: GO 22971
23174: POP
23175: POP
// if result and not asc then
23176: LD_VAR 0 6
23180: PUSH
23181: LD_VAR 0 4
23185: NOT
23186: AND
23187: IFFALSE 23262
// begin tmp := result ;
23189: LD_ADDR_VAR 0 9
23193: PUSH
23194: LD_VAR 0 6
23198: ST_TO_ADDR
// for i = tmp downto 1 do
23199: LD_ADDR_VAR 0 7
23203: PUSH
23204: DOUBLE
23205: LD_VAR 0 9
23209: INC
23210: ST_TO_ADDR
23211: LD_INT 1
23213: PUSH
23214: FOR_DOWNTO
23215: IFFALSE 23260
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
23217: LD_ADDR_VAR 0 6
23221: PUSH
23222: LD_VAR 0 6
23226: PPUSH
23227: LD_VAR 0 9
23231: PUSH
23232: LD_VAR 0 7
23236: MINUS
23237: PUSH
23238: LD_INT 1
23240: PLUS
23241: PPUSH
23242: LD_VAR 0 9
23246: PUSH
23247: LD_VAR 0 7
23251: ARRAY
23252: PPUSH
23253: CALL_OW 1
23257: ST_TO_ADDR
23258: GO 23214
23260: POP
23261: POP
// end ; tmp := [ ] ;
23262: LD_ADDR_VAR 0 9
23266: PUSH
23267: EMPTY
23268: ST_TO_ADDR
// if mode then
23269: LD_VAR 0 5
23273: IFFALSE 23342
// begin for i = 1 to result do
23275: LD_ADDR_VAR 0 7
23279: PUSH
23280: DOUBLE
23281: LD_INT 1
23283: DEC
23284: ST_TO_ADDR
23285: LD_VAR 0 6
23289: PUSH
23290: FOR_TO
23291: IFFALSE 23330
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
23293: LD_ADDR_VAR 0 9
23297: PUSH
23298: LD_VAR 0 9
23302: PPUSH
23303: LD_VAR 0 7
23307: PPUSH
23308: LD_VAR 0 6
23312: PUSH
23313: LD_VAR 0 7
23317: ARRAY
23318: PUSH
23319: LD_INT 1
23321: ARRAY
23322: PPUSH
23323: CALL_OW 1
23327: ST_TO_ADDR
23328: GO 23290
23330: POP
23331: POP
// result := tmp ;
23332: LD_ADDR_VAR 0 6
23336: PUSH
23337: LD_VAR 0 9
23341: ST_TO_ADDR
// end ; end ;
23342: LD_VAR 0 6
23346: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
23347: LD_INT 0
23349: PPUSH
23350: PPUSH
23351: PPUSH
23352: PPUSH
23353: PPUSH
23354: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
23355: LD_ADDR_VAR 0 5
23359: PUSH
23360: LD_INT 0
23362: PUSH
23363: LD_INT 0
23365: PUSH
23366: LD_INT 0
23368: PUSH
23369: EMPTY
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: LIST
23375: LIST
23376: ST_TO_ADDR
// if not x or not y then
23377: LD_VAR 0 2
23381: NOT
23382: PUSH
23383: LD_VAR 0 3
23387: NOT
23388: OR
23389: IFFALSE 23393
// exit ;
23391: GO 25039
// if not range then
23393: LD_VAR 0 4
23397: NOT
23398: IFFALSE 23408
// range := 10 ;
23400: LD_ADDR_VAR 0 4
23404: PUSH
23405: LD_INT 10
23407: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
23408: LD_ADDR_VAR 0 8
23412: PUSH
23413: LD_INT 81
23415: PUSH
23416: LD_VAR 0 1
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: PUSH
23425: LD_INT 92
23427: PUSH
23428: LD_VAR 0 2
23432: PUSH
23433: LD_VAR 0 3
23437: PUSH
23438: LD_VAR 0 4
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: LIST
23447: LIST
23448: PUSH
23449: LD_INT 3
23451: PUSH
23452: LD_INT 21
23454: PUSH
23455: LD_INT 3
23457: PUSH
23458: EMPTY
23459: LIST
23460: LIST
23461: PUSH
23462: EMPTY
23463: LIST
23464: LIST
23465: PUSH
23466: EMPTY
23467: LIST
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 69
23475: ST_TO_ADDR
// if not tmp then
23476: LD_VAR 0 8
23480: NOT
23481: IFFALSE 23485
// exit ;
23483: GO 25039
// for i in tmp do
23485: LD_ADDR_VAR 0 6
23489: PUSH
23490: LD_VAR 0 8
23494: PUSH
23495: FOR_IN
23496: IFFALSE 25014
// begin points := [ 0 , 0 , 0 ] ;
23498: LD_ADDR_VAR 0 9
23502: PUSH
23503: LD_INT 0
23505: PUSH
23506: LD_INT 0
23508: PUSH
23509: LD_INT 0
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: LIST
23516: ST_TO_ADDR
// bpoints := 1 ;
23517: LD_ADDR_VAR 0 10
23521: PUSH
23522: LD_INT 1
23524: ST_TO_ADDR
// case GetType ( i ) of unit_human :
23525: LD_VAR 0 6
23529: PPUSH
23530: CALL_OW 247
23534: PUSH
23535: LD_INT 1
23537: DOUBLE
23538: EQUAL
23539: IFTRUE 23543
23541: GO 24121
23543: POP
// begin if GetClass ( i ) = 1 then
23544: LD_VAR 0 6
23548: PPUSH
23549: CALL_OW 257
23553: PUSH
23554: LD_INT 1
23556: EQUAL
23557: IFFALSE 23578
// points := [ 10 , 5 , 3 ] ;
23559: LD_ADDR_VAR 0 9
23563: PUSH
23564: LD_INT 10
23566: PUSH
23567: LD_INT 5
23569: PUSH
23570: LD_INT 3
23572: PUSH
23573: EMPTY
23574: LIST
23575: LIST
23576: LIST
23577: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
23578: LD_VAR 0 6
23582: PPUSH
23583: CALL_OW 257
23587: PUSH
23588: LD_INT 2
23590: PUSH
23591: LD_INT 3
23593: PUSH
23594: LD_INT 4
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: LIST
23601: IN
23602: IFFALSE 23623
// points := [ 3 , 2 , 1 ] ;
23604: LD_ADDR_VAR 0 9
23608: PUSH
23609: LD_INT 3
23611: PUSH
23612: LD_INT 2
23614: PUSH
23615: LD_INT 1
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: LIST
23622: ST_TO_ADDR
// if GetClass ( i ) = 5 then
23623: LD_VAR 0 6
23627: PPUSH
23628: CALL_OW 257
23632: PUSH
23633: LD_INT 5
23635: EQUAL
23636: IFFALSE 23657
// points := [ 130 , 5 , 2 ] ;
23638: LD_ADDR_VAR 0 9
23642: PUSH
23643: LD_INT 130
23645: PUSH
23646: LD_INT 5
23648: PUSH
23649: LD_INT 2
23651: PUSH
23652: EMPTY
23653: LIST
23654: LIST
23655: LIST
23656: ST_TO_ADDR
// if GetClass ( i ) = 8 then
23657: LD_VAR 0 6
23661: PPUSH
23662: CALL_OW 257
23666: PUSH
23667: LD_INT 8
23669: EQUAL
23670: IFFALSE 23691
// points := [ 35 , 35 , 30 ] ;
23672: LD_ADDR_VAR 0 9
23676: PUSH
23677: LD_INT 35
23679: PUSH
23680: LD_INT 35
23682: PUSH
23683: LD_INT 30
23685: PUSH
23686: EMPTY
23687: LIST
23688: LIST
23689: LIST
23690: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23691: LD_VAR 0 6
23695: PPUSH
23696: CALL_OW 257
23700: PUSH
23701: LD_INT 9
23703: EQUAL
23704: IFFALSE 23725
// points := [ 20 , 55 , 40 ] ;
23706: LD_ADDR_VAR 0 9
23710: PUSH
23711: LD_INT 20
23713: PUSH
23714: LD_INT 55
23716: PUSH
23717: LD_INT 40
23719: PUSH
23720: EMPTY
23721: LIST
23722: LIST
23723: LIST
23724: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23725: LD_VAR 0 6
23729: PPUSH
23730: CALL_OW 257
23734: PUSH
23735: LD_INT 12
23737: PUSH
23738: LD_INT 16
23740: PUSH
23741: EMPTY
23742: LIST
23743: LIST
23744: IN
23745: IFFALSE 23766
// points := [ 5 , 3 , 2 ] ;
23747: LD_ADDR_VAR 0 9
23751: PUSH
23752: LD_INT 5
23754: PUSH
23755: LD_INT 3
23757: PUSH
23758: LD_INT 2
23760: PUSH
23761: EMPTY
23762: LIST
23763: LIST
23764: LIST
23765: ST_TO_ADDR
// if GetClass ( i ) = 17 then
23766: LD_VAR 0 6
23770: PPUSH
23771: CALL_OW 257
23775: PUSH
23776: LD_INT 17
23778: EQUAL
23779: IFFALSE 23800
// points := [ 100 , 50 , 75 ] ;
23781: LD_ADDR_VAR 0 9
23785: PUSH
23786: LD_INT 100
23788: PUSH
23789: LD_INT 50
23791: PUSH
23792: LD_INT 75
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: LIST
23799: ST_TO_ADDR
// if GetClass ( i ) = 15 then
23800: LD_VAR 0 6
23804: PPUSH
23805: CALL_OW 257
23809: PUSH
23810: LD_INT 15
23812: EQUAL
23813: IFFALSE 23834
// points := [ 10 , 5 , 3 ] ;
23815: LD_ADDR_VAR 0 9
23819: PUSH
23820: LD_INT 10
23822: PUSH
23823: LD_INT 5
23825: PUSH
23826: LD_INT 3
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: LIST
23833: ST_TO_ADDR
// if GetClass ( i ) = 14 then
23834: LD_VAR 0 6
23838: PPUSH
23839: CALL_OW 257
23843: PUSH
23844: LD_INT 14
23846: EQUAL
23847: IFFALSE 23868
// points := [ 10 , 0 , 0 ] ;
23849: LD_ADDR_VAR 0 9
23853: PUSH
23854: LD_INT 10
23856: PUSH
23857: LD_INT 0
23859: PUSH
23860: LD_INT 0
23862: PUSH
23863: EMPTY
23864: LIST
23865: LIST
23866: LIST
23867: ST_TO_ADDR
// if GetClass ( i ) = 11 then
23868: LD_VAR 0 6
23872: PPUSH
23873: CALL_OW 257
23877: PUSH
23878: LD_INT 11
23880: EQUAL
23881: IFFALSE 23902
// points := [ 30 , 10 , 5 ] ;
23883: LD_ADDR_VAR 0 9
23887: PUSH
23888: LD_INT 30
23890: PUSH
23891: LD_INT 10
23893: PUSH
23894: LD_INT 5
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: LIST
23901: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
23902: LD_VAR 0 1
23906: PPUSH
23907: LD_INT 5
23909: PPUSH
23910: CALL_OW 321
23914: PUSH
23915: LD_INT 2
23917: EQUAL
23918: IFFALSE 23935
// bpoints := bpoints * 1.8 ;
23920: LD_ADDR_VAR 0 10
23924: PUSH
23925: LD_VAR 0 10
23929: PUSH
23930: LD_REAL  1.80000000000000E+0000
23933: MUL
23934: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
23935: LD_VAR 0 6
23939: PPUSH
23940: CALL_OW 257
23944: PUSH
23945: LD_INT 1
23947: PUSH
23948: LD_INT 2
23950: PUSH
23951: LD_INT 3
23953: PUSH
23954: LD_INT 4
23956: PUSH
23957: EMPTY
23958: LIST
23959: LIST
23960: LIST
23961: LIST
23962: IN
23963: PUSH
23964: LD_VAR 0 1
23968: PPUSH
23969: LD_INT 51
23971: PPUSH
23972: CALL_OW 321
23976: PUSH
23977: LD_INT 2
23979: EQUAL
23980: AND
23981: IFFALSE 23998
// bpoints := bpoints * 1.2 ;
23983: LD_ADDR_VAR 0 10
23987: PUSH
23988: LD_VAR 0 10
23992: PUSH
23993: LD_REAL  1.20000000000000E+0000
23996: MUL
23997: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
23998: LD_VAR 0 6
24002: PPUSH
24003: CALL_OW 257
24007: PUSH
24008: LD_INT 5
24010: PUSH
24011: LD_INT 7
24013: PUSH
24014: LD_INT 9
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: LIST
24021: IN
24022: PUSH
24023: LD_VAR 0 1
24027: PPUSH
24028: LD_INT 52
24030: PPUSH
24031: CALL_OW 321
24035: PUSH
24036: LD_INT 2
24038: EQUAL
24039: AND
24040: IFFALSE 24057
// bpoints := bpoints * 1.5 ;
24042: LD_ADDR_VAR 0 10
24046: PUSH
24047: LD_VAR 0 10
24051: PUSH
24052: LD_REAL  1.50000000000000E+0000
24055: MUL
24056: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
24057: LD_VAR 0 1
24061: PPUSH
24062: LD_INT 66
24064: PPUSH
24065: CALL_OW 321
24069: PUSH
24070: LD_INT 2
24072: EQUAL
24073: IFFALSE 24090
// bpoints := bpoints * 1.1 ;
24075: LD_ADDR_VAR 0 10
24079: PUSH
24080: LD_VAR 0 10
24084: PUSH
24085: LD_REAL  1.10000000000000E+0000
24088: MUL
24089: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
24090: LD_ADDR_VAR 0 10
24094: PUSH
24095: LD_VAR 0 10
24099: PUSH
24100: LD_VAR 0 6
24104: PPUSH
24105: LD_INT 1
24107: PPUSH
24108: CALL_OW 259
24112: PUSH
24113: LD_REAL  1.15000000000000E+0000
24116: MUL
24117: MUL
24118: ST_TO_ADDR
// end ; unit_vehicle :
24119: GO 24943
24121: LD_INT 2
24123: DOUBLE
24124: EQUAL
24125: IFTRUE 24129
24127: GO 24931
24129: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
24130: LD_VAR 0 6
24134: PPUSH
24135: CALL_OW 264
24139: PUSH
24140: LD_INT 2
24142: PUSH
24143: LD_INT 42
24145: PUSH
24146: LD_INT 24
24148: PUSH
24149: EMPTY
24150: LIST
24151: LIST
24152: LIST
24153: IN
24154: IFFALSE 24175
// points := [ 25 , 5 , 3 ] ;
24156: LD_ADDR_VAR 0 9
24160: PUSH
24161: LD_INT 25
24163: PUSH
24164: LD_INT 5
24166: PUSH
24167: LD_INT 3
24169: PUSH
24170: EMPTY
24171: LIST
24172: LIST
24173: LIST
24174: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
24175: LD_VAR 0 6
24179: PPUSH
24180: CALL_OW 264
24184: PUSH
24185: LD_INT 4
24187: PUSH
24188: LD_INT 43
24190: PUSH
24191: LD_INT 25
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: LIST
24198: IN
24199: IFFALSE 24220
// points := [ 40 , 15 , 5 ] ;
24201: LD_ADDR_VAR 0 9
24205: PUSH
24206: LD_INT 40
24208: PUSH
24209: LD_INT 15
24211: PUSH
24212: LD_INT 5
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: LIST
24219: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
24220: LD_VAR 0 6
24224: PPUSH
24225: CALL_OW 264
24229: PUSH
24230: LD_INT 3
24232: PUSH
24233: LD_INT 23
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: IN
24240: IFFALSE 24261
// points := [ 7 , 25 , 8 ] ;
24242: LD_ADDR_VAR 0 9
24246: PUSH
24247: LD_INT 7
24249: PUSH
24250: LD_INT 25
24252: PUSH
24253: LD_INT 8
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: LIST
24260: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
24261: LD_VAR 0 6
24265: PPUSH
24266: CALL_OW 264
24270: PUSH
24271: LD_INT 5
24273: PUSH
24274: LD_INT 27
24276: PUSH
24277: LD_INT 44
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: LIST
24284: IN
24285: IFFALSE 24306
// points := [ 14 , 50 , 16 ] ;
24287: LD_ADDR_VAR 0 9
24291: PUSH
24292: LD_INT 14
24294: PUSH
24295: LD_INT 50
24297: PUSH
24298: LD_INT 16
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: LIST
24305: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
24306: LD_VAR 0 6
24310: PPUSH
24311: CALL_OW 264
24315: PUSH
24316: LD_INT 6
24318: PUSH
24319: LD_INT 46
24321: PUSH
24322: EMPTY
24323: LIST
24324: LIST
24325: IN
24326: IFFALSE 24347
// points := [ 32 , 120 , 70 ] ;
24328: LD_ADDR_VAR 0 9
24332: PUSH
24333: LD_INT 32
24335: PUSH
24336: LD_INT 120
24338: PUSH
24339: LD_INT 70
24341: PUSH
24342: EMPTY
24343: LIST
24344: LIST
24345: LIST
24346: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
24347: LD_VAR 0 6
24351: PPUSH
24352: CALL_OW 264
24356: PUSH
24357: LD_INT 7
24359: PUSH
24360: LD_INT 28
24362: PUSH
24363: LD_INT 45
24365: PUSH
24366: EMPTY
24367: LIST
24368: LIST
24369: LIST
24370: IN
24371: IFFALSE 24392
// points := [ 35 , 20 , 45 ] ;
24373: LD_ADDR_VAR 0 9
24377: PUSH
24378: LD_INT 35
24380: PUSH
24381: LD_INT 20
24383: PUSH
24384: LD_INT 45
24386: PUSH
24387: EMPTY
24388: LIST
24389: LIST
24390: LIST
24391: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
24392: LD_VAR 0 6
24396: PPUSH
24397: CALL_OW 264
24401: PUSH
24402: LD_INT 47
24404: PUSH
24405: EMPTY
24406: LIST
24407: IN
24408: IFFALSE 24429
// points := [ 67 , 45 , 75 ] ;
24410: LD_ADDR_VAR 0 9
24414: PUSH
24415: LD_INT 67
24417: PUSH
24418: LD_INT 45
24420: PUSH
24421: LD_INT 75
24423: PUSH
24424: EMPTY
24425: LIST
24426: LIST
24427: LIST
24428: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
24429: LD_VAR 0 6
24433: PPUSH
24434: CALL_OW 264
24438: PUSH
24439: LD_INT 26
24441: PUSH
24442: EMPTY
24443: LIST
24444: IN
24445: IFFALSE 24466
// points := [ 120 , 30 , 80 ] ;
24447: LD_ADDR_VAR 0 9
24451: PUSH
24452: LD_INT 120
24454: PUSH
24455: LD_INT 30
24457: PUSH
24458: LD_INT 80
24460: PUSH
24461: EMPTY
24462: LIST
24463: LIST
24464: LIST
24465: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
24466: LD_VAR 0 6
24470: PPUSH
24471: CALL_OW 264
24475: PUSH
24476: LD_INT 22
24478: PUSH
24479: EMPTY
24480: LIST
24481: IN
24482: IFFALSE 24503
// points := [ 40 , 1 , 1 ] ;
24484: LD_ADDR_VAR 0 9
24488: PUSH
24489: LD_INT 40
24491: PUSH
24492: LD_INT 1
24494: PUSH
24495: LD_INT 1
24497: PUSH
24498: EMPTY
24499: LIST
24500: LIST
24501: LIST
24502: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
24503: LD_VAR 0 6
24507: PPUSH
24508: CALL_OW 264
24512: PUSH
24513: LD_INT 29
24515: PUSH
24516: EMPTY
24517: LIST
24518: IN
24519: IFFALSE 24540
// points := [ 70 , 200 , 400 ] ;
24521: LD_ADDR_VAR 0 9
24525: PUSH
24526: LD_INT 70
24528: PUSH
24529: LD_INT 200
24531: PUSH
24532: LD_INT 400
24534: PUSH
24535: EMPTY
24536: LIST
24537: LIST
24538: LIST
24539: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
24540: LD_VAR 0 6
24544: PPUSH
24545: CALL_OW 264
24549: PUSH
24550: LD_INT 14
24552: PUSH
24553: LD_INT 53
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: IN
24560: IFFALSE 24581
// points := [ 40 , 10 , 20 ] ;
24562: LD_ADDR_VAR 0 9
24566: PUSH
24567: LD_INT 40
24569: PUSH
24570: LD_INT 10
24572: PUSH
24573: LD_INT 20
24575: PUSH
24576: EMPTY
24577: LIST
24578: LIST
24579: LIST
24580: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
24581: LD_VAR 0 6
24585: PPUSH
24586: CALL_OW 264
24590: PUSH
24591: LD_INT 9
24593: PUSH
24594: EMPTY
24595: LIST
24596: IN
24597: IFFALSE 24618
// points := [ 5 , 70 , 20 ] ;
24599: LD_ADDR_VAR 0 9
24603: PUSH
24604: LD_INT 5
24606: PUSH
24607: LD_INT 70
24609: PUSH
24610: LD_INT 20
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: LIST
24617: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
24618: LD_VAR 0 6
24622: PPUSH
24623: CALL_OW 264
24627: PUSH
24628: LD_INT 10
24630: PUSH
24631: EMPTY
24632: LIST
24633: IN
24634: IFFALSE 24655
// points := [ 35 , 110 , 70 ] ;
24636: LD_ADDR_VAR 0 9
24640: PUSH
24641: LD_INT 35
24643: PUSH
24644: LD_INT 110
24646: PUSH
24647: LD_INT 70
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: LIST
24654: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
24655: LD_VAR 0 6
24659: PPUSH
24660: CALL_OW 265
24664: PUSH
24665: LD_INT 25
24667: EQUAL
24668: IFFALSE 24689
// points := [ 80 , 65 , 100 ] ;
24670: LD_ADDR_VAR 0 9
24674: PUSH
24675: LD_INT 80
24677: PUSH
24678: LD_INT 65
24680: PUSH
24681: LD_INT 100
24683: PUSH
24684: EMPTY
24685: LIST
24686: LIST
24687: LIST
24688: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24689: LD_VAR 0 6
24693: PPUSH
24694: CALL_OW 263
24698: PUSH
24699: LD_INT 1
24701: EQUAL
24702: IFFALSE 24737
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24704: LD_ADDR_VAR 0 10
24708: PUSH
24709: LD_VAR 0 10
24713: PUSH
24714: LD_VAR 0 6
24718: PPUSH
24719: CALL_OW 311
24723: PPUSH
24724: LD_INT 3
24726: PPUSH
24727: CALL_OW 259
24731: PUSH
24732: LD_INT 4
24734: MUL
24735: MUL
24736: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24737: LD_VAR 0 6
24741: PPUSH
24742: CALL_OW 263
24746: PUSH
24747: LD_INT 2
24749: EQUAL
24750: IFFALSE 24801
// begin j := IsControledBy ( i ) ;
24752: LD_ADDR_VAR 0 7
24756: PUSH
24757: LD_VAR 0 6
24761: PPUSH
24762: CALL_OW 312
24766: ST_TO_ADDR
// if j then
24767: LD_VAR 0 7
24771: IFFALSE 24801
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
24773: LD_ADDR_VAR 0 10
24777: PUSH
24778: LD_VAR 0 10
24782: PUSH
24783: LD_VAR 0 7
24787: PPUSH
24788: LD_INT 3
24790: PPUSH
24791: CALL_OW 259
24795: PUSH
24796: LD_INT 3
24798: MUL
24799: MUL
24800: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
24801: LD_VAR 0 6
24805: PPUSH
24806: CALL_OW 264
24810: PUSH
24811: LD_INT 5
24813: PUSH
24814: LD_INT 6
24816: PUSH
24817: LD_INT 46
24819: PUSH
24820: LD_INT 44
24822: PUSH
24823: LD_INT 47
24825: PUSH
24826: LD_INT 45
24828: PUSH
24829: LD_INT 28
24831: PUSH
24832: LD_INT 7
24834: PUSH
24835: LD_INT 27
24837: PUSH
24838: LD_INT 29
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: LIST
24845: LIST
24846: LIST
24847: LIST
24848: LIST
24849: LIST
24850: LIST
24851: LIST
24852: IN
24853: PUSH
24854: LD_VAR 0 1
24858: PPUSH
24859: LD_INT 52
24861: PPUSH
24862: CALL_OW 321
24866: PUSH
24867: LD_INT 2
24869: EQUAL
24870: AND
24871: IFFALSE 24888
// bpoints := bpoints * 1.2 ;
24873: LD_ADDR_VAR 0 10
24877: PUSH
24878: LD_VAR 0 10
24882: PUSH
24883: LD_REAL  1.20000000000000E+0000
24886: MUL
24887: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
24888: LD_VAR 0 6
24892: PPUSH
24893: CALL_OW 264
24897: PUSH
24898: LD_INT 6
24900: PUSH
24901: LD_INT 46
24903: PUSH
24904: LD_INT 47
24906: PUSH
24907: EMPTY
24908: LIST
24909: LIST
24910: LIST
24911: IN
24912: IFFALSE 24929
// bpoints := bpoints * 1.2 ;
24914: LD_ADDR_VAR 0 10
24918: PUSH
24919: LD_VAR 0 10
24923: PUSH
24924: LD_REAL  1.20000000000000E+0000
24927: MUL
24928: ST_TO_ADDR
// end ; unit_building :
24929: GO 24943
24931: LD_INT 3
24933: DOUBLE
24934: EQUAL
24935: IFTRUE 24939
24937: GO 24942
24939: POP
// ; end ;
24940: GO 24943
24942: POP
// for j = 1 to 3 do
24943: LD_ADDR_VAR 0 7
24947: PUSH
24948: DOUBLE
24949: LD_INT 1
24951: DEC
24952: ST_TO_ADDR
24953: LD_INT 3
24955: PUSH
24956: FOR_TO
24957: IFFALSE 25010
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
24959: LD_ADDR_VAR 0 5
24963: PUSH
24964: LD_VAR 0 5
24968: PPUSH
24969: LD_VAR 0 7
24973: PPUSH
24974: LD_VAR 0 5
24978: PUSH
24979: LD_VAR 0 7
24983: ARRAY
24984: PUSH
24985: LD_VAR 0 9
24989: PUSH
24990: LD_VAR 0 7
24994: ARRAY
24995: PUSH
24996: LD_VAR 0 10
25000: MUL
25001: PLUS
25002: PPUSH
25003: CALL_OW 1
25007: ST_TO_ADDR
25008: GO 24956
25010: POP
25011: POP
// end ;
25012: GO 23495
25014: POP
25015: POP
// result := Replace ( result , 4 , tmp ) ;
25016: LD_ADDR_VAR 0 5
25020: PUSH
25021: LD_VAR 0 5
25025: PPUSH
25026: LD_INT 4
25028: PPUSH
25029: LD_VAR 0 8
25033: PPUSH
25034: CALL_OW 1
25038: ST_TO_ADDR
// end ;
25039: LD_VAR 0 5
25043: RET
// export function DangerAtRange ( unit , range ) ; begin
25044: LD_INT 0
25046: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
25047: LD_ADDR_VAR 0 3
25051: PUSH
25052: LD_VAR 0 1
25056: PPUSH
25057: CALL_OW 255
25061: PPUSH
25062: LD_VAR 0 1
25066: PPUSH
25067: CALL_OW 250
25071: PPUSH
25072: LD_VAR 0 1
25076: PPUSH
25077: CALL_OW 251
25081: PPUSH
25082: LD_VAR 0 2
25086: PPUSH
25087: CALL 23347 0 4
25091: ST_TO_ADDR
// end ;
25092: LD_VAR 0 3
25096: RET
// export function DangerInArea ( side , area ) ; begin
25097: LD_INT 0
25099: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
25100: LD_ADDR_VAR 0 3
25104: PUSH
25105: LD_VAR 0 2
25109: PPUSH
25110: LD_INT 81
25112: PUSH
25113: LD_VAR 0 1
25117: PUSH
25118: EMPTY
25119: LIST
25120: LIST
25121: PPUSH
25122: CALL_OW 70
25126: ST_TO_ADDR
// end ;
25127: LD_VAR 0 3
25131: RET
// export function IsExtension ( b ) ; begin
25132: LD_INT 0
25134: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
25135: LD_ADDR_VAR 0 2
25139: PUSH
25140: LD_VAR 0 1
25144: PUSH
25145: LD_INT 23
25147: PUSH
25148: LD_INT 20
25150: PUSH
25151: LD_INT 22
25153: PUSH
25154: LD_INT 17
25156: PUSH
25157: LD_INT 24
25159: PUSH
25160: LD_INT 21
25162: PUSH
25163: LD_INT 19
25165: PUSH
25166: LD_INT 16
25168: PUSH
25169: LD_INT 25
25171: PUSH
25172: LD_INT 18
25174: PUSH
25175: EMPTY
25176: LIST
25177: LIST
25178: LIST
25179: LIST
25180: LIST
25181: LIST
25182: LIST
25183: LIST
25184: LIST
25185: LIST
25186: IN
25187: ST_TO_ADDR
// end ;
25188: LD_VAR 0 2
25192: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
25193: LD_INT 0
25195: PPUSH
25196: PPUSH
25197: PPUSH
// result := [ ] ;
25198: LD_ADDR_VAR 0 4
25202: PUSH
25203: EMPTY
25204: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
25205: LD_ADDR_VAR 0 5
25209: PUSH
25210: LD_VAR 0 2
25214: PPUSH
25215: LD_INT 21
25217: PUSH
25218: LD_INT 3
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PPUSH
25225: CALL_OW 70
25229: ST_TO_ADDR
// if not tmp then
25230: LD_VAR 0 5
25234: NOT
25235: IFFALSE 25239
// exit ;
25237: GO 25303
// if checkLink then
25239: LD_VAR 0 3
25243: IFFALSE 25293
// begin for i in tmp do
25245: LD_ADDR_VAR 0 6
25249: PUSH
25250: LD_VAR 0 5
25254: PUSH
25255: FOR_IN
25256: IFFALSE 25291
// if GetBase ( i ) <> base then
25258: LD_VAR 0 6
25262: PPUSH
25263: CALL_OW 274
25267: PUSH
25268: LD_VAR 0 1
25272: NONEQUAL
25273: IFFALSE 25289
// ComLinkToBase ( base , i ) ;
25275: LD_VAR 0 1
25279: PPUSH
25280: LD_VAR 0 6
25284: PPUSH
25285: CALL_OW 169
25289: GO 25255
25291: POP
25292: POP
// end ; result := tmp ;
25293: LD_ADDR_VAR 0 4
25297: PUSH
25298: LD_VAR 0 5
25302: ST_TO_ADDR
// end ;
25303: LD_VAR 0 4
25307: RET
// export function ComComplete ( units , b ) ; var i ; begin
25308: LD_INT 0
25310: PPUSH
25311: PPUSH
// if not units then
25312: LD_VAR 0 1
25316: NOT
25317: IFFALSE 25321
// exit ;
25319: GO 25411
// for i in units do
25321: LD_ADDR_VAR 0 4
25325: PUSH
25326: LD_VAR 0 1
25330: PUSH
25331: FOR_IN
25332: IFFALSE 25409
// if BuildingStatus ( b ) = bs_build then
25334: LD_VAR 0 2
25338: PPUSH
25339: CALL_OW 461
25343: PUSH
25344: LD_INT 1
25346: EQUAL
25347: IFFALSE 25407
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25349: LD_VAR 0 4
25353: PPUSH
25354: LD_STRING h
25356: PUSH
25357: LD_VAR 0 2
25361: PPUSH
25362: CALL_OW 250
25366: PUSH
25367: LD_VAR 0 2
25371: PPUSH
25372: CALL_OW 251
25376: PUSH
25377: LD_VAR 0 2
25381: PUSH
25382: LD_INT 0
25384: PUSH
25385: LD_INT 0
25387: PUSH
25388: LD_INT 0
25390: PUSH
25391: EMPTY
25392: LIST
25393: LIST
25394: LIST
25395: LIST
25396: LIST
25397: LIST
25398: LIST
25399: PUSH
25400: EMPTY
25401: LIST
25402: PPUSH
25403: CALL_OW 446
25407: GO 25331
25409: POP
25410: POP
// end ;
25411: LD_VAR 0 3
25415: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
25416: LD_INT 0
25418: PPUSH
25419: PPUSH
25420: PPUSH
25421: PPUSH
25422: PPUSH
25423: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
25424: LD_VAR 0 1
25428: NOT
25429: PUSH
25430: LD_VAR 0 1
25434: PPUSH
25435: CALL_OW 263
25439: PUSH
25440: LD_INT 2
25442: EQUAL
25443: NOT
25444: OR
25445: IFFALSE 25449
// exit ;
25447: GO 25765
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
25449: LD_ADDR_VAR 0 6
25453: PUSH
25454: LD_INT 22
25456: PUSH
25457: LD_VAR 0 1
25461: PPUSH
25462: CALL_OW 255
25466: PUSH
25467: EMPTY
25468: LIST
25469: LIST
25470: PUSH
25471: LD_INT 2
25473: PUSH
25474: LD_INT 30
25476: PUSH
25477: LD_INT 36
25479: PUSH
25480: EMPTY
25481: LIST
25482: LIST
25483: PUSH
25484: LD_INT 34
25486: PUSH
25487: LD_INT 31
25489: PUSH
25490: EMPTY
25491: LIST
25492: LIST
25493: PUSH
25494: EMPTY
25495: LIST
25496: LIST
25497: LIST
25498: PUSH
25499: EMPTY
25500: LIST
25501: LIST
25502: PPUSH
25503: CALL_OW 69
25507: ST_TO_ADDR
// if not tmp then
25508: LD_VAR 0 6
25512: NOT
25513: IFFALSE 25517
// exit ;
25515: GO 25765
// result := [ ] ;
25517: LD_ADDR_VAR 0 2
25521: PUSH
25522: EMPTY
25523: ST_TO_ADDR
// for i in tmp do
25524: LD_ADDR_VAR 0 3
25528: PUSH
25529: LD_VAR 0 6
25533: PUSH
25534: FOR_IN
25535: IFFALSE 25606
// begin t := UnitsInside ( i ) ;
25537: LD_ADDR_VAR 0 4
25541: PUSH
25542: LD_VAR 0 3
25546: PPUSH
25547: CALL_OW 313
25551: ST_TO_ADDR
// if t then
25552: LD_VAR 0 4
25556: IFFALSE 25604
// for j in t do
25558: LD_ADDR_VAR 0 7
25562: PUSH
25563: LD_VAR 0 4
25567: PUSH
25568: FOR_IN
25569: IFFALSE 25602
// result := Insert ( result , result + 1 , j ) ;
25571: LD_ADDR_VAR 0 2
25575: PUSH
25576: LD_VAR 0 2
25580: PPUSH
25581: LD_VAR 0 2
25585: PUSH
25586: LD_INT 1
25588: PLUS
25589: PPUSH
25590: LD_VAR 0 7
25594: PPUSH
25595: CALL_OW 2
25599: ST_TO_ADDR
25600: GO 25568
25602: POP
25603: POP
// end ;
25604: GO 25534
25606: POP
25607: POP
// if not result then
25608: LD_VAR 0 2
25612: NOT
25613: IFFALSE 25617
// exit ;
25615: GO 25765
// mech := result [ 1 ] ;
25617: LD_ADDR_VAR 0 5
25621: PUSH
25622: LD_VAR 0 2
25626: PUSH
25627: LD_INT 1
25629: ARRAY
25630: ST_TO_ADDR
// if result > 1 then
25631: LD_VAR 0 2
25635: PUSH
25636: LD_INT 1
25638: GREATER
25639: IFFALSE 25751
// for i = 2 to result do
25641: LD_ADDR_VAR 0 3
25645: PUSH
25646: DOUBLE
25647: LD_INT 2
25649: DEC
25650: ST_TO_ADDR
25651: LD_VAR 0 2
25655: PUSH
25656: FOR_TO
25657: IFFALSE 25749
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
25659: LD_ADDR_VAR 0 4
25663: PUSH
25664: LD_VAR 0 2
25668: PUSH
25669: LD_VAR 0 3
25673: ARRAY
25674: PPUSH
25675: LD_INT 3
25677: PPUSH
25678: CALL_OW 259
25682: PUSH
25683: LD_VAR 0 2
25687: PUSH
25688: LD_VAR 0 3
25692: ARRAY
25693: PPUSH
25694: CALL_OW 432
25698: MINUS
25699: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25700: LD_VAR 0 4
25704: PUSH
25705: LD_VAR 0 5
25709: PPUSH
25710: LD_INT 3
25712: PPUSH
25713: CALL_OW 259
25717: PUSH
25718: LD_VAR 0 5
25722: PPUSH
25723: CALL_OW 432
25727: MINUS
25728: GREATEREQUAL
25729: IFFALSE 25747
// mech := result [ i ] ;
25731: LD_ADDR_VAR 0 5
25735: PUSH
25736: LD_VAR 0 2
25740: PUSH
25741: LD_VAR 0 3
25745: ARRAY
25746: ST_TO_ADDR
// end ;
25747: GO 25656
25749: POP
25750: POP
// ComLinkTo ( vehicle , mech ) ;
25751: LD_VAR 0 1
25755: PPUSH
25756: LD_VAR 0 5
25760: PPUSH
25761: CALL_OW 135
// end ;
25765: LD_VAR 0 2
25769: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
25770: LD_INT 0
25772: PPUSH
25773: PPUSH
25774: PPUSH
25775: PPUSH
25776: PPUSH
25777: PPUSH
25778: PPUSH
25779: PPUSH
25780: PPUSH
25781: PPUSH
25782: PPUSH
25783: PPUSH
25784: PPUSH
// result := [ ] ;
25785: LD_ADDR_VAR 0 7
25789: PUSH
25790: EMPTY
25791: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
25792: LD_VAR 0 1
25796: PPUSH
25797: CALL_OW 266
25801: PUSH
25802: LD_INT 0
25804: PUSH
25805: LD_INT 1
25807: PUSH
25808: EMPTY
25809: LIST
25810: LIST
25811: IN
25812: NOT
25813: IFFALSE 25817
// exit ;
25815: GO 27451
// if name then
25817: LD_VAR 0 3
25821: IFFALSE 25837
// SetBName ( base_dep , name ) ;
25823: LD_VAR 0 1
25827: PPUSH
25828: LD_VAR 0 3
25832: PPUSH
25833: CALL_OW 500
// base := GetBase ( base_dep ) ;
25837: LD_ADDR_VAR 0 15
25841: PUSH
25842: LD_VAR 0 1
25846: PPUSH
25847: CALL_OW 274
25851: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
25852: LD_ADDR_VAR 0 16
25856: PUSH
25857: LD_VAR 0 1
25861: PPUSH
25862: CALL_OW 255
25866: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
25867: LD_ADDR_VAR 0 17
25871: PUSH
25872: LD_VAR 0 1
25876: PPUSH
25877: CALL_OW 248
25881: ST_TO_ADDR
// if sources then
25882: LD_VAR 0 5
25886: IFFALSE 25933
// for i = 1 to 3 do
25888: LD_ADDR_VAR 0 8
25892: PUSH
25893: DOUBLE
25894: LD_INT 1
25896: DEC
25897: ST_TO_ADDR
25898: LD_INT 3
25900: PUSH
25901: FOR_TO
25902: IFFALSE 25931
// AddResourceType ( base , i , sources [ i ] ) ;
25904: LD_VAR 0 15
25908: PPUSH
25909: LD_VAR 0 8
25913: PPUSH
25914: LD_VAR 0 5
25918: PUSH
25919: LD_VAR 0 8
25923: ARRAY
25924: PPUSH
25925: CALL_OW 276
25929: GO 25901
25931: POP
25932: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
25933: LD_ADDR_VAR 0 18
25937: PUSH
25938: LD_VAR 0 15
25942: PPUSH
25943: LD_VAR 0 2
25947: PPUSH
25948: LD_INT 1
25950: PPUSH
25951: CALL 25193 0 3
25955: ST_TO_ADDR
// InitHc ;
25956: CALL_OW 19
// InitUc ;
25960: CALL_OW 18
// uc_side := side ;
25964: LD_ADDR_OWVAR 20
25968: PUSH
25969: LD_VAR 0 16
25973: ST_TO_ADDR
// uc_nation := nation ;
25974: LD_ADDR_OWVAR 21
25978: PUSH
25979: LD_VAR 0 17
25983: ST_TO_ADDR
// if buildings then
25984: LD_VAR 0 18
25988: IFFALSE 27310
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
25990: LD_ADDR_VAR 0 19
25994: PUSH
25995: LD_VAR 0 18
25999: PPUSH
26000: LD_INT 2
26002: PUSH
26003: LD_INT 30
26005: PUSH
26006: LD_INT 29
26008: PUSH
26009: EMPTY
26010: LIST
26011: LIST
26012: PUSH
26013: LD_INT 30
26015: PUSH
26016: LD_INT 30
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: LIST
26027: PPUSH
26028: CALL_OW 72
26032: ST_TO_ADDR
// if tmp then
26033: LD_VAR 0 19
26037: IFFALSE 26085
// for i in tmp do
26039: LD_ADDR_VAR 0 8
26043: PUSH
26044: LD_VAR 0 19
26048: PUSH
26049: FOR_IN
26050: IFFALSE 26083
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
26052: LD_VAR 0 8
26056: PPUSH
26057: CALL_OW 250
26061: PPUSH
26062: LD_VAR 0 8
26066: PPUSH
26067: CALL_OW 251
26071: PPUSH
26072: LD_VAR 0 16
26076: PPUSH
26077: CALL_OW 441
26081: GO 26049
26083: POP
26084: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
26085: LD_VAR 0 18
26089: PPUSH
26090: LD_INT 2
26092: PUSH
26093: LD_INT 30
26095: PUSH
26096: LD_INT 32
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 30
26105: PUSH
26106: LD_INT 33
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: EMPTY
26114: LIST
26115: LIST
26116: LIST
26117: PPUSH
26118: CALL_OW 72
26122: IFFALSE 26210
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
26124: LD_ADDR_VAR 0 8
26128: PUSH
26129: LD_VAR 0 18
26133: PPUSH
26134: LD_INT 2
26136: PUSH
26137: LD_INT 30
26139: PUSH
26140: LD_INT 32
26142: PUSH
26143: EMPTY
26144: LIST
26145: LIST
26146: PUSH
26147: LD_INT 30
26149: PUSH
26150: LD_INT 33
26152: PUSH
26153: EMPTY
26154: LIST
26155: LIST
26156: PUSH
26157: EMPTY
26158: LIST
26159: LIST
26160: LIST
26161: PPUSH
26162: CALL_OW 72
26166: PUSH
26167: FOR_IN
26168: IFFALSE 26208
// begin if not GetBWeapon ( i ) then
26170: LD_VAR 0 8
26174: PPUSH
26175: CALL_OW 269
26179: NOT
26180: IFFALSE 26206
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
26182: LD_VAR 0 8
26186: PPUSH
26187: LD_VAR 0 8
26191: PPUSH
26192: LD_VAR 0 2
26196: PPUSH
26197: CALL 27456 0 2
26201: PPUSH
26202: CALL_OW 431
// end ;
26206: GO 26167
26208: POP
26209: POP
// end ; for i = 1 to personel do
26210: LD_ADDR_VAR 0 8
26214: PUSH
26215: DOUBLE
26216: LD_INT 1
26218: DEC
26219: ST_TO_ADDR
26220: LD_VAR 0 6
26224: PUSH
26225: FOR_TO
26226: IFFALSE 27290
// begin if i > 4 then
26228: LD_VAR 0 8
26232: PUSH
26233: LD_INT 4
26235: GREATER
26236: IFFALSE 26240
// break ;
26238: GO 27290
// case i of 1 :
26240: LD_VAR 0 8
26244: PUSH
26245: LD_INT 1
26247: DOUBLE
26248: EQUAL
26249: IFTRUE 26253
26251: GO 26333
26253: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
26254: LD_ADDR_VAR 0 12
26258: PUSH
26259: LD_VAR 0 18
26263: PPUSH
26264: LD_INT 22
26266: PUSH
26267: LD_VAR 0 16
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: LD_INT 58
26278: PUSH
26279: EMPTY
26280: LIST
26281: PUSH
26282: LD_INT 2
26284: PUSH
26285: LD_INT 30
26287: PUSH
26288: LD_INT 32
26290: PUSH
26291: EMPTY
26292: LIST
26293: LIST
26294: PUSH
26295: LD_INT 30
26297: PUSH
26298: LD_INT 4
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: PUSH
26305: LD_INT 30
26307: PUSH
26308: LD_INT 5
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: LIST
26319: LIST
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: LIST
26325: PPUSH
26326: CALL_OW 72
26330: ST_TO_ADDR
26331: GO 26555
26333: LD_INT 2
26335: DOUBLE
26336: EQUAL
26337: IFTRUE 26341
26339: GO 26403
26341: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
26342: LD_ADDR_VAR 0 12
26346: PUSH
26347: LD_VAR 0 18
26351: PPUSH
26352: LD_INT 22
26354: PUSH
26355: LD_VAR 0 16
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 2
26366: PUSH
26367: LD_INT 30
26369: PUSH
26370: LD_INT 0
26372: PUSH
26373: EMPTY
26374: LIST
26375: LIST
26376: PUSH
26377: LD_INT 30
26379: PUSH
26380: LD_INT 1
26382: PUSH
26383: EMPTY
26384: LIST
26385: LIST
26386: PUSH
26387: EMPTY
26388: LIST
26389: LIST
26390: LIST
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PPUSH
26396: CALL_OW 72
26400: ST_TO_ADDR
26401: GO 26555
26403: LD_INT 3
26405: DOUBLE
26406: EQUAL
26407: IFTRUE 26411
26409: GO 26473
26411: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
26412: LD_ADDR_VAR 0 12
26416: PUSH
26417: LD_VAR 0 18
26421: PPUSH
26422: LD_INT 22
26424: PUSH
26425: LD_VAR 0 16
26429: PUSH
26430: EMPTY
26431: LIST
26432: LIST
26433: PUSH
26434: LD_INT 2
26436: PUSH
26437: LD_INT 30
26439: PUSH
26440: LD_INT 2
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: LD_INT 30
26449: PUSH
26450: LD_INT 3
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: PUSH
26462: EMPTY
26463: LIST
26464: LIST
26465: PPUSH
26466: CALL_OW 72
26470: ST_TO_ADDR
26471: GO 26555
26473: LD_INT 4
26475: DOUBLE
26476: EQUAL
26477: IFTRUE 26481
26479: GO 26554
26481: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
26482: LD_ADDR_VAR 0 12
26486: PUSH
26487: LD_VAR 0 18
26491: PPUSH
26492: LD_INT 22
26494: PUSH
26495: LD_VAR 0 16
26499: PUSH
26500: EMPTY
26501: LIST
26502: LIST
26503: PUSH
26504: LD_INT 2
26506: PUSH
26507: LD_INT 30
26509: PUSH
26510: LD_INT 6
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 30
26519: PUSH
26520: LD_INT 7
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: LD_INT 30
26529: PUSH
26530: LD_INT 8
26532: PUSH
26533: EMPTY
26534: LIST
26535: LIST
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: LIST
26541: LIST
26542: PUSH
26543: EMPTY
26544: LIST
26545: LIST
26546: PPUSH
26547: CALL_OW 72
26551: ST_TO_ADDR
26552: GO 26555
26554: POP
// if i = 1 then
26555: LD_VAR 0 8
26559: PUSH
26560: LD_INT 1
26562: EQUAL
26563: IFFALSE 26674
// begin tmp := [ ] ;
26565: LD_ADDR_VAR 0 19
26569: PUSH
26570: EMPTY
26571: ST_TO_ADDR
// for j in f do
26572: LD_ADDR_VAR 0 9
26576: PUSH
26577: LD_VAR 0 12
26581: PUSH
26582: FOR_IN
26583: IFFALSE 26656
// if GetBType ( j ) = b_bunker then
26585: LD_VAR 0 9
26589: PPUSH
26590: CALL_OW 266
26594: PUSH
26595: LD_INT 32
26597: EQUAL
26598: IFFALSE 26625
// tmp := Insert ( tmp , 1 , j ) else
26600: LD_ADDR_VAR 0 19
26604: PUSH
26605: LD_VAR 0 19
26609: PPUSH
26610: LD_INT 1
26612: PPUSH
26613: LD_VAR 0 9
26617: PPUSH
26618: CALL_OW 2
26622: ST_TO_ADDR
26623: GO 26654
// tmp := Insert ( tmp , tmp + 1 , j ) ;
26625: LD_ADDR_VAR 0 19
26629: PUSH
26630: LD_VAR 0 19
26634: PPUSH
26635: LD_VAR 0 19
26639: PUSH
26640: LD_INT 1
26642: PLUS
26643: PPUSH
26644: LD_VAR 0 9
26648: PPUSH
26649: CALL_OW 2
26653: ST_TO_ADDR
26654: GO 26582
26656: POP
26657: POP
// if tmp then
26658: LD_VAR 0 19
26662: IFFALSE 26674
// f := tmp ;
26664: LD_ADDR_VAR 0 12
26668: PUSH
26669: LD_VAR 0 19
26673: ST_TO_ADDR
// end ; x := personel [ i ] ;
26674: LD_ADDR_VAR 0 13
26678: PUSH
26679: LD_VAR 0 6
26683: PUSH
26684: LD_VAR 0 8
26688: ARRAY
26689: ST_TO_ADDR
// if x = - 1 then
26690: LD_VAR 0 13
26694: PUSH
26695: LD_INT 1
26697: NEG
26698: EQUAL
26699: IFFALSE 26908
// begin for j in f do
26701: LD_ADDR_VAR 0 9
26705: PUSH
26706: LD_VAR 0 12
26710: PUSH
26711: FOR_IN
26712: IFFALSE 26904
// repeat InitHc ;
26714: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26718: LD_VAR 0 9
26722: PPUSH
26723: CALL_OW 266
26727: PUSH
26728: LD_INT 5
26730: EQUAL
26731: IFFALSE 26801
// begin if UnitsInside ( j ) < 3 then
26733: LD_VAR 0 9
26737: PPUSH
26738: CALL_OW 313
26742: PUSH
26743: LD_INT 3
26745: LESS
26746: IFFALSE 26782
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26748: LD_INT 0
26750: PPUSH
26751: LD_INT 5
26753: PUSH
26754: LD_INT 8
26756: PUSH
26757: LD_INT 9
26759: PUSH
26760: EMPTY
26761: LIST
26762: LIST
26763: LIST
26764: PUSH
26765: LD_VAR 0 17
26769: ARRAY
26770: PPUSH
26771: LD_VAR 0 4
26775: PPUSH
26776: CALL_OW 380
26780: GO 26799
// PrepareHuman ( false , i , skill ) ;
26782: LD_INT 0
26784: PPUSH
26785: LD_VAR 0 8
26789: PPUSH
26790: LD_VAR 0 4
26794: PPUSH
26795: CALL_OW 380
// end else
26799: GO 26818
// PrepareHuman ( false , i , skill ) ;
26801: LD_INT 0
26803: PPUSH
26804: LD_VAR 0 8
26808: PPUSH
26809: LD_VAR 0 4
26813: PPUSH
26814: CALL_OW 380
// un := CreateHuman ;
26818: LD_ADDR_VAR 0 14
26822: PUSH
26823: CALL_OW 44
26827: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26828: LD_ADDR_VAR 0 7
26832: PUSH
26833: LD_VAR 0 7
26837: PPUSH
26838: LD_INT 1
26840: PPUSH
26841: LD_VAR 0 14
26845: PPUSH
26846: CALL_OW 2
26850: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
26851: LD_VAR 0 14
26855: PPUSH
26856: LD_VAR 0 9
26860: PPUSH
26861: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
26865: LD_VAR 0 9
26869: PPUSH
26870: CALL_OW 313
26874: PUSH
26875: LD_INT 6
26877: EQUAL
26878: PUSH
26879: LD_VAR 0 9
26883: PPUSH
26884: CALL_OW 266
26888: PUSH
26889: LD_INT 32
26891: PUSH
26892: LD_INT 31
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: IN
26899: OR
26900: IFFALSE 26714
26902: GO 26711
26904: POP
26905: POP
// end else
26906: GO 27288
// for j = 1 to x do
26908: LD_ADDR_VAR 0 9
26912: PUSH
26913: DOUBLE
26914: LD_INT 1
26916: DEC
26917: ST_TO_ADDR
26918: LD_VAR 0 13
26922: PUSH
26923: FOR_TO
26924: IFFALSE 27286
// begin InitHc ;
26926: CALL_OW 19
// if not f then
26930: LD_VAR 0 12
26934: NOT
26935: IFFALSE 27024
// begin PrepareHuman ( false , i , skill ) ;
26937: LD_INT 0
26939: PPUSH
26940: LD_VAR 0 8
26944: PPUSH
26945: LD_VAR 0 4
26949: PPUSH
26950: CALL_OW 380
// un := CreateHuman ;
26954: LD_ADDR_VAR 0 14
26958: PUSH
26959: CALL_OW 44
26963: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26964: LD_ADDR_VAR 0 7
26968: PUSH
26969: LD_VAR 0 7
26973: PPUSH
26974: LD_INT 1
26976: PPUSH
26977: LD_VAR 0 14
26981: PPUSH
26982: CALL_OW 2
26986: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26987: LD_VAR 0 14
26991: PPUSH
26992: LD_VAR 0 1
26996: PPUSH
26997: CALL_OW 250
27001: PPUSH
27002: LD_VAR 0 1
27006: PPUSH
27007: CALL_OW 251
27011: PPUSH
27012: LD_INT 10
27014: PPUSH
27015: LD_INT 0
27017: PPUSH
27018: CALL_OW 50
// continue ;
27022: GO 26923
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
27024: LD_VAR 0 12
27028: PUSH
27029: LD_INT 1
27031: ARRAY
27032: PPUSH
27033: CALL_OW 313
27037: PUSH
27038: LD_VAR 0 12
27042: PUSH
27043: LD_INT 1
27045: ARRAY
27046: PPUSH
27047: CALL_OW 266
27051: PUSH
27052: LD_INT 32
27054: PUSH
27055: LD_INT 31
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: IN
27062: AND
27063: PUSH
27064: LD_VAR 0 12
27068: PUSH
27069: LD_INT 1
27071: ARRAY
27072: PPUSH
27073: CALL_OW 313
27077: PUSH
27078: LD_INT 6
27080: EQUAL
27081: OR
27082: IFFALSE 27102
// f := Delete ( f , 1 ) ;
27084: LD_ADDR_VAR 0 12
27088: PUSH
27089: LD_VAR 0 12
27093: PPUSH
27094: LD_INT 1
27096: PPUSH
27097: CALL_OW 3
27101: ST_TO_ADDR
// if not f then
27102: LD_VAR 0 12
27106: NOT
27107: IFFALSE 27125
// begin x := x + 2 ;
27109: LD_ADDR_VAR 0 13
27113: PUSH
27114: LD_VAR 0 13
27118: PUSH
27119: LD_INT 2
27121: PLUS
27122: ST_TO_ADDR
// continue ;
27123: GO 26923
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
27125: LD_VAR 0 12
27129: PUSH
27130: LD_INT 1
27132: ARRAY
27133: PPUSH
27134: CALL_OW 266
27138: PUSH
27139: LD_INT 5
27141: EQUAL
27142: IFFALSE 27216
// begin if UnitsInside ( f [ 1 ] ) < 3 then
27144: LD_VAR 0 12
27148: PUSH
27149: LD_INT 1
27151: ARRAY
27152: PPUSH
27153: CALL_OW 313
27157: PUSH
27158: LD_INT 3
27160: LESS
27161: IFFALSE 27197
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27163: LD_INT 0
27165: PPUSH
27166: LD_INT 5
27168: PUSH
27169: LD_INT 8
27171: PUSH
27172: LD_INT 9
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: LIST
27179: PUSH
27180: LD_VAR 0 17
27184: ARRAY
27185: PPUSH
27186: LD_VAR 0 4
27190: PPUSH
27191: CALL_OW 380
27195: GO 27214
// PrepareHuman ( false , i , skill ) ;
27197: LD_INT 0
27199: PPUSH
27200: LD_VAR 0 8
27204: PPUSH
27205: LD_VAR 0 4
27209: PPUSH
27210: CALL_OW 380
// end else
27214: GO 27233
// PrepareHuman ( false , i , skill ) ;
27216: LD_INT 0
27218: PPUSH
27219: LD_VAR 0 8
27223: PPUSH
27224: LD_VAR 0 4
27228: PPUSH
27229: CALL_OW 380
// un := CreateHuman ;
27233: LD_ADDR_VAR 0 14
27237: PUSH
27238: CALL_OW 44
27242: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27243: LD_ADDR_VAR 0 7
27247: PUSH
27248: LD_VAR 0 7
27252: PPUSH
27253: LD_INT 1
27255: PPUSH
27256: LD_VAR 0 14
27260: PPUSH
27261: CALL_OW 2
27265: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
27266: LD_VAR 0 14
27270: PPUSH
27271: LD_VAR 0 12
27275: PUSH
27276: LD_INT 1
27278: ARRAY
27279: PPUSH
27280: CALL_OW 52
// end ;
27284: GO 26923
27286: POP
27287: POP
// end ;
27288: GO 26225
27290: POP
27291: POP
// result := result ^ buildings ;
27292: LD_ADDR_VAR 0 7
27296: PUSH
27297: LD_VAR 0 7
27301: PUSH
27302: LD_VAR 0 18
27306: ADD
27307: ST_TO_ADDR
// end else
27308: GO 27451
// begin for i = 1 to personel do
27310: LD_ADDR_VAR 0 8
27314: PUSH
27315: DOUBLE
27316: LD_INT 1
27318: DEC
27319: ST_TO_ADDR
27320: LD_VAR 0 6
27324: PUSH
27325: FOR_TO
27326: IFFALSE 27449
// begin if i > 4 then
27328: LD_VAR 0 8
27332: PUSH
27333: LD_INT 4
27335: GREATER
27336: IFFALSE 27340
// break ;
27338: GO 27449
// x := personel [ i ] ;
27340: LD_ADDR_VAR 0 13
27344: PUSH
27345: LD_VAR 0 6
27349: PUSH
27350: LD_VAR 0 8
27354: ARRAY
27355: ST_TO_ADDR
// if x = - 1 then
27356: LD_VAR 0 13
27360: PUSH
27361: LD_INT 1
27363: NEG
27364: EQUAL
27365: IFFALSE 27369
// continue ;
27367: GO 27325
// PrepareHuman ( false , i , skill ) ;
27369: LD_INT 0
27371: PPUSH
27372: LD_VAR 0 8
27376: PPUSH
27377: LD_VAR 0 4
27381: PPUSH
27382: CALL_OW 380
// un := CreateHuman ;
27386: LD_ADDR_VAR 0 14
27390: PUSH
27391: CALL_OW 44
27395: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27396: LD_VAR 0 14
27400: PPUSH
27401: LD_VAR 0 1
27405: PPUSH
27406: CALL_OW 250
27410: PPUSH
27411: LD_VAR 0 1
27415: PPUSH
27416: CALL_OW 251
27420: PPUSH
27421: LD_INT 10
27423: PPUSH
27424: LD_INT 0
27426: PPUSH
27427: CALL_OW 50
// result := result ^ un ;
27431: LD_ADDR_VAR 0 7
27435: PUSH
27436: LD_VAR 0 7
27440: PUSH
27441: LD_VAR 0 14
27445: ADD
27446: ST_TO_ADDR
// end ;
27447: GO 27325
27449: POP
27450: POP
// end ; end ;
27451: LD_VAR 0 7
27455: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
27456: LD_INT 0
27458: PPUSH
27459: PPUSH
27460: PPUSH
27461: PPUSH
27462: PPUSH
27463: PPUSH
27464: PPUSH
27465: PPUSH
27466: PPUSH
27467: PPUSH
27468: PPUSH
27469: PPUSH
27470: PPUSH
27471: PPUSH
27472: PPUSH
27473: PPUSH
// result := false ;
27474: LD_ADDR_VAR 0 3
27478: PUSH
27479: LD_INT 0
27481: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
27482: LD_VAR 0 1
27486: NOT
27487: PUSH
27488: LD_VAR 0 1
27492: PPUSH
27493: CALL_OW 266
27497: PUSH
27498: LD_INT 32
27500: PUSH
27501: LD_INT 33
27503: PUSH
27504: EMPTY
27505: LIST
27506: LIST
27507: IN
27508: NOT
27509: OR
27510: IFFALSE 27514
// exit ;
27512: GO 28653
// nat := GetNation ( tower ) ;
27514: LD_ADDR_VAR 0 12
27518: PUSH
27519: LD_VAR 0 1
27523: PPUSH
27524: CALL_OW 248
27528: ST_TO_ADDR
// side := GetSide ( tower ) ;
27529: LD_ADDR_VAR 0 16
27533: PUSH
27534: LD_VAR 0 1
27538: PPUSH
27539: CALL_OW 255
27543: ST_TO_ADDR
// x := GetX ( tower ) ;
27544: LD_ADDR_VAR 0 10
27548: PUSH
27549: LD_VAR 0 1
27553: PPUSH
27554: CALL_OW 250
27558: ST_TO_ADDR
// y := GetY ( tower ) ;
27559: LD_ADDR_VAR 0 11
27563: PUSH
27564: LD_VAR 0 1
27568: PPUSH
27569: CALL_OW 251
27573: ST_TO_ADDR
// if not x or not y then
27574: LD_VAR 0 10
27578: NOT
27579: PUSH
27580: LD_VAR 0 11
27584: NOT
27585: OR
27586: IFFALSE 27590
// exit ;
27588: GO 28653
// weapon := 0 ;
27590: LD_ADDR_VAR 0 18
27594: PUSH
27595: LD_INT 0
27597: ST_TO_ADDR
// fac_list := [ ] ;
27598: LD_ADDR_VAR 0 17
27602: PUSH
27603: EMPTY
27604: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
27605: LD_ADDR_VAR 0 6
27609: PUSH
27610: LD_VAR 0 1
27614: PPUSH
27615: CALL_OW 274
27619: PPUSH
27620: LD_VAR 0 2
27624: PPUSH
27625: LD_INT 0
27627: PPUSH
27628: CALL 25193 0 3
27632: PPUSH
27633: LD_INT 30
27635: PUSH
27636: LD_INT 3
27638: PUSH
27639: EMPTY
27640: LIST
27641: LIST
27642: PPUSH
27643: CALL_OW 72
27647: ST_TO_ADDR
// if not factories then
27648: LD_VAR 0 6
27652: NOT
27653: IFFALSE 27657
// exit ;
27655: GO 28653
// for i in factories do
27657: LD_ADDR_VAR 0 8
27661: PUSH
27662: LD_VAR 0 6
27666: PUSH
27667: FOR_IN
27668: IFFALSE 27693
// fac_list := fac_list union AvailableWeaponList ( i ) ;
27670: LD_ADDR_VAR 0 17
27674: PUSH
27675: LD_VAR 0 17
27679: PUSH
27680: LD_VAR 0 8
27684: PPUSH
27685: CALL_OW 478
27689: UNION
27690: ST_TO_ADDR
27691: GO 27667
27693: POP
27694: POP
// if not fac_list then
27695: LD_VAR 0 17
27699: NOT
27700: IFFALSE 27704
// exit ;
27702: GO 28653
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27704: LD_ADDR_VAR 0 5
27708: PUSH
27709: LD_INT 4
27711: PUSH
27712: LD_INT 5
27714: PUSH
27715: LD_INT 9
27717: PUSH
27718: LD_INT 10
27720: PUSH
27721: LD_INT 6
27723: PUSH
27724: LD_INT 7
27726: PUSH
27727: LD_INT 11
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: LIST
27734: LIST
27735: LIST
27736: LIST
27737: LIST
27738: PUSH
27739: LD_INT 27
27741: PUSH
27742: LD_INT 28
27744: PUSH
27745: LD_INT 26
27747: PUSH
27748: LD_INT 30
27750: PUSH
27751: EMPTY
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: PUSH
27757: LD_INT 43
27759: PUSH
27760: LD_INT 44
27762: PUSH
27763: LD_INT 46
27765: PUSH
27766: LD_INT 45
27768: PUSH
27769: LD_INT 47
27771: PUSH
27772: LD_INT 49
27774: PUSH
27775: EMPTY
27776: LIST
27777: LIST
27778: LIST
27779: LIST
27780: LIST
27781: LIST
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: LIST
27787: PUSH
27788: LD_VAR 0 12
27792: ARRAY
27793: ST_TO_ADDR
// for i in list do
27794: LD_ADDR_VAR 0 8
27798: PUSH
27799: LD_VAR 0 5
27803: PUSH
27804: FOR_IN
27805: IFFALSE 27838
// if not i in fac_list then
27807: LD_VAR 0 8
27811: PUSH
27812: LD_VAR 0 17
27816: IN
27817: NOT
27818: IFFALSE 27836
// list := list diff i ;
27820: LD_ADDR_VAR 0 5
27824: PUSH
27825: LD_VAR 0 5
27829: PUSH
27830: LD_VAR 0 8
27834: DIFF
27835: ST_TO_ADDR
27836: GO 27804
27838: POP
27839: POP
// if not list then
27840: LD_VAR 0 5
27844: NOT
27845: IFFALSE 27849
// exit ;
27847: GO 28653
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
27849: LD_VAR 0 12
27853: PUSH
27854: LD_INT 3
27856: EQUAL
27857: PUSH
27858: LD_INT 49
27860: PUSH
27861: LD_VAR 0 5
27865: IN
27866: AND
27867: PUSH
27868: LD_INT 31
27870: PPUSH
27871: LD_VAR 0 16
27875: PPUSH
27876: CALL_OW 321
27880: PUSH
27881: LD_INT 2
27883: EQUAL
27884: AND
27885: IFFALSE 27945
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
27887: LD_INT 22
27889: PUSH
27890: LD_VAR 0 16
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 35
27901: PUSH
27902: LD_INT 49
27904: PUSH
27905: EMPTY
27906: LIST
27907: LIST
27908: PUSH
27909: LD_INT 91
27911: PUSH
27912: LD_VAR 0 1
27916: PUSH
27917: LD_INT 10
27919: PUSH
27920: EMPTY
27921: LIST
27922: LIST
27923: LIST
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: LIST
27929: PPUSH
27930: CALL_OW 69
27934: NOT
27935: IFFALSE 27945
// weapon := ru_time_lapser ;
27937: LD_ADDR_VAR 0 18
27941: PUSH
27942: LD_INT 49
27944: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
27945: LD_VAR 0 12
27949: PUSH
27950: LD_INT 1
27952: PUSH
27953: LD_INT 2
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: IN
27960: PUSH
27961: LD_INT 11
27963: PUSH
27964: LD_VAR 0 5
27968: IN
27969: PUSH
27970: LD_INT 30
27972: PUSH
27973: LD_VAR 0 5
27977: IN
27978: OR
27979: AND
27980: PUSH
27981: LD_INT 6
27983: PPUSH
27984: LD_VAR 0 16
27988: PPUSH
27989: CALL_OW 321
27993: PUSH
27994: LD_INT 2
27996: EQUAL
27997: AND
27998: IFFALSE 28163
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
28000: LD_INT 22
28002: PUSH
28003: LD_VAR 0 16
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 2
28014: PUSH
28015: LD_INT 35
28017: PUSH
28018: LD_INT 11
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: PUSH
28025: LD_INT 35
28027: PUSH
28028: LD_INT 30
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: EMPTY
28036: LIST
28037: LIST
28038: LIST
28039: PUSH
28040: LD_INT 91
28042: PUSH
28043: LD_VAR 0 1
28047: PUSH
28048: LD_INT 18
28050: PUSH
28051: EMPTY
28052: LIST
28053: LIST
28054: LIST
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: LIST
28060: PPUSH
28061: CALL_OW 69
28065: NOT
28066: PUSH
28067: LD_INT 22
28069: PUSH
28070: LD_VAR 0 16
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: LD_INT 2
28081: PUSH
28082: LD_INT 30
28084: PUSH
28085: LD_INT 32
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 30
28094: PUSH
28095: LD_INT 33
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: LIST
28106: PUSH
28107: LD_INT 91
28109: PUSH
28110: LD_VAR 0 1
28114: PUSH
28115: LD_INT 12
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: LIST
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: LIST
28127: PUSH
28128: EMPTY
28129: LIST
28130: PPUSH
28131: CALL_OW 69
28135: PUSH
28136: LD_INT 2
28138: GREATER
28139: AND
28140: IFFALSE 28163
// weapon := [ us_radar , ar_radar ] [ nat ] ;
28142: LD_ADDR_VAR 0 18
28146: PUSH
28147: LD_INT 11
28149: PUSH
28150: LD_INT 30
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: PUSH
28157: LD_VAR 0 12
28161: ARRAY
28162: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
28163: LD_VAR 0 18
28167: NOT
28168: PUSH
28169: LD_INT 40
28171: PPUSH
28172: LD_VAR 0 16
28176: PPUSH
28177: CALL_OW 321
28181: PUSH
28182: LD_INT 2
28184: EQUAL
28185: AND
28186: PUSH
28187: LD_INT 7
28189: PUSH
28190: LD_VAR 0 5
28194: IN
28195: PUSH
28196: LD_INT 28
28198: PUSH
28199: LD_VAR 0 5
28203: IN
28204: OR
28205: PUSH
28206: LD_INT 45
28208: PUSH
28209: LD_VAR 0 5
28213: IN
28214: OR
28215: AND
28216: IFFALSE 28470
// begin hex := GetHexInfo ( x , y ) ;
28218: LD_ADDR_VAR 0 4
28222: PUSH
28223: LD_VAR 0 10
28227: PPUSH
28228: LD_VAR 0 11
28232: PPUSH
28233: CALL_OW 546
28237: ST_TO_ADDR
// if hex [ 1 ] then
28238: LD_VAR 0 4
28242: PUSH
28243: LD_INT 1
28245: ARRAY
28246: IFFALSE 28250
// exit ;
28248: GO 28653
// height := hex [ 2 ] ;
28250: LD_ADDR_VAR 0 15
28254: PUSH
28255: LD_VAR 0 4
28259: PUSH
28260: LD_INT 2
28262: ARRAY
28263: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
28264: LD_ADDR_VAR 0 14
28268: PUSH
28269: LD_INT 0
28271: PUSH
28272: LD_INT 2
28274: PUSH
28275: LD_INT 3
28277: PUSH
28278: LD_INT 5
28280: PUSH
28281: EMPTY
28282: LIST
28283: LIST
28284: LIST
28285: LIST
28286: ST_TO_ADDR
// for i in tmp do
28287: LD_ADDR_VAR 0 8
28291: PUSH
28292: LD_VAR 0 14
28296: PUSH
28297: FOR_IN
28298: IFFALSE 28468
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
28300: LD_ADDR_VAR 0 9
28304: PUSH
28305: LD_VAR 0 10
28309: PPUSH
28310: LD_VAR 0 8
28314: PPUSH
28315: LD_INT 5
28317: PPUSH
28318: CALL_OW 272
28322: PUSH
28323: LD_VAR 0 11
28327: PPUSH
28328: LD_VAR 0 8
28332: PPUSH
28333: LD_INT 5
28335: PPUSH
28336: CALL_OW 273
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
28345: LD_VAR 0 9
28349: PUSH
28350: LD_INT 1
28352: ARRAY
28353: PPUSH
28354: LD_VAR 0 9
28358: PUSH
28359: LD_INT 2
28361: ARRAY
28362: PPUSH
28363: CALL_OW 488
28367: IFFALSE 28466
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
28369: LD_ADDR_VAR 0 4
28373: PUSH
28374: LD_VAR 0 9
28378: PUSH
28379: LD_INT 1
28381: ARRAY
28382: PPUSH
28383: LD_VAR 0 9
28387: PUSH
28388: LD_INT 2
28390: ARRAY
28391: PPUSH
28392: CALL_OW 546
28396: ST_TO_ADDR
// if hex [ 1 ] then
28397: LD_VAR 0 4
28401: PUSH
28402: LD_INT 1
28404: ARRAY
28405: IFFALSE 28409
// continue ;
28407: GO 28297
// h := hex [ 2 ] ;
28409: LD_ADDR_VAR 0 13
28413: PUSH
28414: LD_VAR 0 4
28418: PUSH
28419: LD_INT 2
28421: ARRAY
28422: ST_TO_ADDR
// if h + 7 < height then
28423: LD_VAR 0 13
28427: PUSH
28428: LD_INT 7
28430: PLUS
28431: PUSH
28432: LD_VAR 0 15
28436: LESS
28437: IFFALSE 28466
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
28439: LD_ADDR_VAR 0 18
28443: PUSH
28444: LD_INT 7
28446: PUSH
28447: LD_INT 28
28449: PUSH
28450: LD_INT 45
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: LIST
28457: PUSH
28458: LD_VAR 0 12
28462: ARRAY
28463: ST_TO_ADDR
// break ;
28464: GO 28468
// end ; end ; end ;
28466: GO 28297
28468: POP
28469: POP
// end ; if not weapon then
28470: LD_VAR 0 18
28474: NOT
28475: IFFALSE 28535
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
28477: LD_ADDR_VAR 0 5
28481: PUSH
28482: LD_VAR 0 5
28486: PUSH
28487: LD_INT 11
28489: PUSH
28490: LD_INT 30
28492: PUSH
28493: LD_INT 49
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: LIST
28500: DIFF
28501: ST_TO_ADDR
// if not list then
28502: LD_VAR 0 5
28506: NOT
28507: IFFALSE 28511
// exit ;
28509: GO 28653
// weapon := list [ rand ( 1 , list ) ] ;
28511: LD_ADDR_VAR 0 18
28515: PUSH
28516: LD_VAR 0 5
28520: PUSH
28521: LD_INT 1
28523: PPUSH
28524: LD_VAR 0 5
28528: PPUSH
28529: CALL_OW 12
28533: ARRAY
28534: ST_TO_ADDR
// end ; if weapon then
28535: LD_VAR 0 18
28539: IFFALSE 28653
// begin tmp := CostOfWeapon ( weapon ) ;
28541: LD_ADDR_VAR 0 14
28545: PUSH
28546: LD_VAR 0 18
28550: PPUSH
28551: CALL_OW 451
28555: ST_TO_ADDR
// j := GetBase ( tower ) ;
28556: LD_ADDR_VAR 0 9
28560: PUSH
28561: LD_VAR 0 1
28565: PPUSH
28566: CALL_OW 274
28570: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
28571: LD_VAR 0 9
28575: PPUSH
28576: LD_INT 1
28578: PPUSH
28579: CALL_OW 275
28583: PUSH
28584: LD_VAR 0 14
28588: PUSH
28589: LD_INT 1
28591: ARRAY
28592: GREATEREQUAL
28593: PUSH
28594: LD_VAR 0 9
28598: PPUSH
28599: LD_INT 2
28601: PPUSH
28602: CALL_OW 275
28606: PUSH
28607: LD_VAR 0 14
28611: PUSH
28612: LD_INT 2
28614: ARRAY
28615: GREATEREQUAL
28616: AND
28617: PUSH
28618: LD_VAR 0 9
28622: PPUSH
28623: LD_INT 3
28625: PPUSH
28626: CALL_OW 275
28630: PUSH
28631: LD_VAR 0 14
28635: PUSH
28636: LD_INT 3
28638: ARRAY
28639: GREATEREQUAL
28640: AND
28641: IFFALSE 28653
// result := weapon ;
28643: LD_ADDR_VAR 0 3
28647: PUSH
28648: LD_VAR 0 18
28652: ST_TO_ADDR
// end ; end ;
28653: LD_VAR 0 3
28657: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
28658: LD_INT 0
28660: PPUSH
28661: PPUSH
// result := true ;
28662: LD_ADDR_VAR 0 3
28666: PUSH
28667: LD_INT 1
28669: ST_TO_ADDR
// if array1 = array2 then
28670: LD_VAR 0 1
28674: PUSH
28675: LD_VAR 0 2
28679: EQUAL
28680: IFFALSE 28740
// begin for i = 1 to array1 do
28682: LD_ADDR_VAR 0 4
28686: PUSH
28687: DOUBLE
28688: LD_INT 1
28690: DEC
28691: ST_TO_ADDR
28692: LD_VAR 0 1
28696: PUSH
28697: FOR_TO
28698: IFFALSE 28736
// if array1 [ i ] <> array2 [ i ] then
28700: LD_VAR 0 1
28704: PUSH
28705: LD_VAR 0 4
28709: ARRAY
28710: PUSH
28711: LD_VAR 0 2
28715: PUSH
28716: LD_VAR 0 4
28720: ARRAY
28721: NONEQUAL
28722: IFFALSE 28734
// begin result := false ;
28724: LD_ADDR_VAR 0 3
28728: PUSH
28729: LD_INT 0
28731: ST_TO_ADDR
// break ;
28732: GO 28736
// end ;
28734: GO 28697
28736: POP
28737: POP
// end else
28738: GO 28748
// result := false ;
28740: LD_ADDR_VAR 0 3
28744: PUSH
28745: LD_INT 0
28747: ST_TO_ADDR
// end ;
28748: LD_VAR 0 3
28752: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
28753: LD_INT 0
28755: PPUSH
28756: PPUSH
// if not array1 or not array2 then
28757: LD_VAR 0 1
28761: NOT
28762: PUSH
28763: LD_VAR 0 2
28767: NOT
28768: OR
28769: IFFALSE 28773
// exit ;
28771: GO 28837
// result := true ;
28773: LD_ADDR_VAR 0 3
28777: PUSH
28778: LD_INT 1
28780: ST_TO_ADDR
// for i = 1 to array1 do
28781: LD_ADDR_VAR 0 4
28785: PUSH
28786: DOUBLE
28787: LD_INT 1
28789: DEC
28790: ST_TO_ADDR
28791: LD_VAR 0 1
28795: PUSH
28796: FOR_TO
28797: IFFALSE 28835
// if array1 [ i ] <> array2 [ i ] then
28799: LD_VAR 0 1
28803: PUSH
28804: LD_VAR 0 4
28808: ARRAY
28809: PUSH
28810: LD_VAR 0 2
28814: PUSH
28815: LD_VAR 0 4
28819: ARRAY
28820: NONEQUAL
28821: IFFALSE 28833
// begin result := false ;
28823: LD_ADDR_VAR 0 3
28827: PUSH
28828: LD_INT 0
28830: ST_TO_ADDR
// break ;
28831: GO 28835
// end ;
28833: GO 28796
28835: POP
28836: POP
// end ;
28837: LD_VAR 0 3
28841: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
28842: LD_INT 0
28844: PPUSH
28845: PPUSH
28846: PPUSH
// pom := GetBase ( fac ) ;
28847: LD_ADDR_VAR 0 5
28851: PUSH
28852: LD_VAR 0 1
28856: PPUSH
28857: CALL_OW 274
28861: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
28862: LD_ADDR_VAR 0 4
28866: PUSH
28867: LD_VAR 0 2
28871: PUSH
28872: LD_INT 1
28874: ARRAY
28875: PPUSH
28876: LD_VAR 0 2
28880: PUSH
28881: LD_INT 2
28883: ARRAY
28884: PPUSH
28885: LD_VAR 0 2
28889: PUSH
28890: LD_INT 3
28892: ARRAY
28893: PPUSH
28894: LD_VAR 0 2
28898: PUSH
28899: LD_INT 4
28901: ARRAY
28902: PPUSH
28903: CALL_OW 449
28907: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
28908: LD_ADDR_VAR 0 3
28912: PUSH
28913: LD_VAR 0 5
28917: PPUSH
28918: LD_INT 1
28920: PPUSH
28921: CALL_OW 275
28925: PUSH
28926: LD_VAR 0 4
28930: PUSH
28931: LD_INT 1
28933: ARRAY
28934: GREATEREQUAL
28935: PUSH
28936: LD_VAR 0 5
28940: PPUSH
28941: LD_INT 2
28943: PPUSH
28944: CALL_OW 275
28948: PUSH
28949: LD_VAR 0 4
28953: PUSH
28954: LD_INT 2
28956: ARRAY
28957: GREATEREQUAL
28958: AND
28959: PUSH
28960: LD_VAR 0 5
28964: PPUSH
28965: LD_INT 3
28967: PPUSH
28968: CALL_OW 275
28972: PUSH
28973: LD_VAR 0 4
28977: PUSH
28978: LD_INT 3
28980: ARRAY
28981: GREATEREQUAL
28982: AND
28983: ST_TO_ADDR
// end ;
28984: LD_VAR 0 3
28988: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
28989: LD_INT 0
28991: PPUSH
28992: PPUSH
28993: PPUSH
28994: PPUSH
// pom := GetBase ( building ) ;
28995: LD_ADDR_VAR 0 3
28999: PUSH
29000: LD_VAR 0 1
29004: PPUSH
29005: CALL_OW 274
29009: ST_TO_ADDR
// if not pom then
29010: LD_VAR 0 3
29014: NOT
29015: IFFALSE 29019
// exit ;
29017: GO 29189
// btype := GetBType ( building ) ;
29019: LD_ADDR_VAR 0 5
29023: PUSH
29024: LD_VAR 0 1
29028: PPUSH
29029: CALL_OW 266
29033: ST_TO_ADDR
// if btype = b_armoury then
29034: LD_VAR 0 5
29038: PUSH
29039: LD_INT 4
29041: EQUAL
29042: IFFALSE 29052
// btype := b_barracks ;
29044: LD_ADDR_VAR 0 5
29048: PUSH
29049: LD_INT 5
29051: ST_TO_ADDR
// if btype = b_depot then
29052: LD_VAR 0 5
29056: PUSH
29057: LD_INT 0
29059: EQUAL
29060: IFFALSE 29070
// btype := b_warehouse ;
29062: LD_ADDR_VAR 0 5
29066: PUSH
29067: LD_INT 1
29069: ST_TO_ADDR
// if btype = b_workshop then
29070: LD_VAR 0 5
29074: PUSH
29075: LD_INT 2
29077: EQUAL
29078: IFFALSE 29088
// btype := b_factory ;
29080: LD_ADDR_VAR 0 5
29084: PUSH
29085: LD_INT 3
29087: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29088: LD_ADDR_VAR 0 4
29092: PUSH
29093: LD_VAR 0 5
29097: PPUSH
29098: LD_VAR 0 1
29102: PPUSH
29103: CALL_OW 248
29107: PPUSH
29108: CALL_OW 450
29112: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29113: LD_ADDR_VAR 0 2
29117: PUSH
29118: LD_VAR 0 3
29122: PPUSH
29123: LD_INT 1
29125: PPUSH
29126: CALL_OW 275
29130: PUSH
29131: LD_VAR 0 4
29135: PUSH
29136: LD_INT 1
29138: ARRAY
29139: GREATEREQUAL
29140: PUSH
29141: LD_VAR 0 3
29145: PPUSH
29146: LD_INT 2
29148: PPUSH
29149: CALL_OW 275
29153: PUSH
29154: LD_VAR 0 4
29158: PUSH
29159: LD_INT 2
29161: ARRAY
29162: GREATEREQUAL
29163: AND
29164: PUSH
29165: LD_VAR 0 3
29169: PPUSH
29170: LD_INT 3
29172: PPUSH
29173: CALL_OW 275
29177: PUSH
29178: LD_VAR 0 4
29182: PUSH
29183: LD_INT 3
29185: ARRAY
29186: GREATEREQUAL
29187: AND
29188: ST_TO_ADDR
// end ;
29189: LD_VAR 0 2
29193: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
29194: LD_INT 0
29196: PPUSH
29197: PPUSH
29198: PPUSH
// pom := GetBase ( building ) ;
29199: LD_ADDR_VAR 0 4
29203: PUSH
29204: LD_VAR 0 1
29208: PPUSH
29209: CALL_OW 274
29213: ST_TO_ADDR
// if not pom then
29214: LD_VAR 0 4
29218: NOT
29219: IFFALSE 29223
// exit ;
29221: GO 29324
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29223: LD_ADDR_VAR 0 5
29227: PUSH
29228: LD_VAR 0 2
29232: PPUSH
29233: LD_VAR 0 1
29237: PPUSH
29238: CALL_OW 248
29242: PPUSH
29243: CALL_OW 450
29247: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29248: LD_ADDR_VAR 0 3
29252: PUSH
29253: LD_VAR 0 4
29257: PPUSH
29258: LD_INT 1
29260: PPUSH
29261: CALL_OW 275
29265: PUSH
29266: LD_VAR 0 5
29270: PUSH
29271: LD_INT 1
29273: ARRAY
29274: GREATEREQUAL
29275: PUSH
29276: LD_VAR 0 4
29280: PPUSH
29281: LD_INT 2
29283: PPUSH
29284: CALL_OW 275
29288: PUSH
29289: LD_VAR 0 5
29293: PUSH
29294: LD_INT 2
29296: ARRAY
29297: GREATEREQUAL
29298: AND
29299: PUSH
29300: LD_VAR 0 4
29304: PPUSH
29305: LD_INT 3
29307: PPUSH
29308: CALL_OW 275
29312: PUSH
29313: LD_VAR 0 5
29317: PUSH
29318: LD_INT 3
29320: ARRAY
29321: GREATEREQUAL
29322: AND
29323: ST_TO_ADDR
// end ;
29324: LD_VAR 0 3
29328: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
29329: LD_INT 0
29331: PPUSH
29332: PPUSH
29333: PPUSH
29334: PPUSH
29335: PPUSH
29336: PPUSH
29337: PPUSH
29338: PPUSH
29339: PPUSH
29340: PPUSH
29341: PPUSH
// result := false ;
29342: LD_ADDR_VAR 0 8
29346: PUSH
29347: LD_INT 0
29349: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
29350: LD_VAR 0 5
29354: NOT
29355: PUSH
29356: LD_VAR 0 1
29360: NOT
29361: OR
29362: PUSH
29363: LD_VAR 0 2
29367: NOT
29368: OR
29369: PUSH
29370: LD_VAR 0 3
29374: NOT
29375: OR
29376: IFFALSE 29380
// exit ;
29378: GO 30194
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
29380: LD_ADDR_VAR 0 14
29384: PUSH
29385: LD_VAR 0 1
29389: PPUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: LD_VAR 0 3
29399: PPUSH
29400: LD_VAR 0 4
29404: PPUSH
29405: LD_VAR 0 5
29409: PUSH
29410: LD_INT 1
29412: ARRAY
29413: PPUSH
29414: CALL_OW 248
29418: PPUSH
29419: LD_INT 0
29421: PPUSH
29422: CALL 31031 0 6
29426: ST_TO_ADDR
// if not hexes then
29427: LD_VAR 0 14
29431: NOT
29432: IFFALSE 29436
// exit ;
29434: GO 30194
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29436: LD_ADDR_VAR 0 17
29440: PUSH
29441: LD_VAR 0 5
29445: PPUSH
29446: LD_INT 22
29448: PUSH
29449: LD_VAR 0 13
29453: PPUSH
29454: CALL_OW 255
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 2
29465: PUSH
29466: LD_INT 30
29468: PUSH
29469: LD_INT 0
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 30
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: LIST
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: PPUSH
29495: CALL_OW 72
29499: ST_TO_ADDR
// for i = 1 to hexes do
29500: LD_ADDR_VAR 0 9
29504: PUSH
29505: DOUBLE
29506: LD_INT 1
29508: DEC
29509: ST_TO_ADDR
29510: LD_VAR 0 14
29514: PUSH
29515: FOR_TO
29516: IFFALSE 30192
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29518: LD_ADDR_VAR 0 13
29522: PUSH
29523: LD_VAR 0 14
29527: PUSH
29528: LD_VAR 0 9
29532: ARRAY
29533: PUSH
29534: LD_INT 1
29536: ARRAY
29537: PPUSH
29538: LD_VAR 0 14
29542: PUSH
29543: LD_VAR 0 9
29547: ARRAY
29548: PUSH
29549: LD_INT 2
29551: ARRAY
29552: PPUSH
29553: CALL_OW 428
29557: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
29558: LD_VAR 0 14
29562: PUSH
29563: LD_VAR 0 9
29567: ARRAY
29568: PUSH
29569: LD_INT 1
29571: ARRAY
29572: PPUSH
29573: LD_VAR 0 14
29577: PUSH
29578: LD_VAR 0 9
29582: ARRAY
29583: PUSH
29584: LD_INT 2
29586: ARRAY
29587: PPUSH
29588: CALL_OW 351
29592: PUSH
29593: LD_VAR 0 14
29597: PUSH
29598: LD_VAR 0 9
29602: ARRAY
29603: PUSH
29604: LD_INT 1
29606: ARRAY
29607: PPUSH
29608: LD_VAR 0 14
29612: PUSH
29613: LD_VAR 0 9
29617: ARRAY
29618: PUSH
29619: LD_INT 2
29621: ARRAY
29622: PPUSH
29623: CALL_OW 488
29627: NOT
29628: OR
29629: PUSH
29630: LD_VAR 0 13
29634: PPUSH
29635: CALL_OW 247
29639: PUSH
29640: LD_INT 3
29642: EQUAL
29643: OR
29644: IFFALSE 29650
// exit ;
29646: POP
29647: POP
29648: GO 30194
// if not tmp then
29650: LD_VAR 0 13
29654: NOT
29655: IFFALSE 29659
// continue ;
29657: GO 29515
// result := true ;
29659: LD_ADDR_VAR 0 8
29663: PUSH
29664: LD_INT 1
29666: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
29667: LD_VAR 0 6
29671: PUSH
29672: LD_VAR 0 13
29676: PPUSH
29677: CALL_OW 247
29681: PUSH
29682: LD_INT 2
29684: EQUAL
29685: AND
29686: PUSH
29687: LD_VAR 0 13
29691: PPUSH
29692: CALL_OW 263
29696: PUSH
29697: LD_INT 1
29699: EQUAL
29700: AND
29701: IFFALSE 29865
// begin if IsDrivenBy ( tmp ) then
29703: LD_VAR 0 13
29707: PPUSH
29708: CALL_OW 311
29712: IFFALSE 29716
// continue ;
29714: GO 29515
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
29716: LD_VAR 0 6
29720: PPUSH
29721: LD_INT 3
29723: PUSH
29724: LD_INT 60
29726: PUSH
29727: EMPTY
29728: LIST
29729: PUSH
29730: EMPTY
29731: LIST
29732: LIST
29733: PUSH
29734: LD_INT 3
29736: PUSH
29737: LD_INT 55
29739: PUSH
29740: EMPTY
29741: LIST
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PPUSH
29751: CALL_OW 72
29755: IFFALSE 29863
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
29757: LD_ADDR_VAR 0 18
29761: PUSH
29762: LD_VAR 0 6
29766: PPUSH
29767: LD_INT 3
29769: PUSH
29770: LD_INT 60
29772: PUSH
29773: EMPTY
29774: LIST
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: LD_INT 3
29782: PUSH
29783: LD_INT 55
29785: PUSH
29786: EMPTY
29787: LIST
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PPUSH
29797: CALL_OW 72
29801: PUSH
29802: LD_INT 1
29804: ARRAY
29805: ST_TO_ADDR
// if IsInUnit ( driver ) then
29806: LD_VAR 0 18
29810: PPUSH
29811: CALL_OW 310
29815: IFFALSE 29826
// ComExit ( driver ) ;
29817: LD_VAR 0 18
29821: PPUSH
29822: CALL 54215 0 1
// AddComEnterUnit ( driver , tmp ) ;
29826: LD_VAR 0 18
29830: PPUSH
29831: LD_VAR 0 13
29835: PPUSH
29836: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
29840: LD_VAR 0 18
29844: PPUSH
29845: LD_VAR 0 7
29849: PPUSH
29850: CALL_OW 173
// AddComExitVehicle ( driver ) ;
29854: LD_VAR 0 18
29858: PPUSH
29859: CALL_OW 181
// end ; continue ;
29863: GO 29515
// end ; if not cleaners or not tmp in cleaners then
29865: LD_VAR 0 6
29869: NOT
29870: PUSH
29871: LD_VAR 0 13
29875: PUSH
29876: LD_VAR 0 6
29880: IN
29881: NOT
29882: OR
29883: IFFALSE 30190
// begin if dep then
29885: LD_VAR 0 17
29889: IFFALSE 30025
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
29891: LD_ADDR_VAR 0 16
29895: PUSH
29896: LD_VAR 0 17
29900: PUSH
29901: LD_INT 1
29903: ARRAY
29904: PPUSH
29905: CALL_OW 250
29909: PPUSH
29910: LD_VAR 0 17
29914: PUSH
29915: LD_INT 1
29917: ARRAY
29918: PPUSH
29919: CALL_OW 254
29923: PPUSH
29924: LD_INT 5
29926: PPUSH
29927: CALL_OW 272
29931: PUSH
29932: LD_VAR 0 17
29936: PUSH
29937: LD_INT 1
29939: ARRAY
29940: PPUSH
29941: CALL_OW 251
29945: PPUSH
29946: LD_VAR 0 17
29950: PUSH
29951: LD_INT 1
29953: ARRAY
29954: PPUSH
29955: CALL_OW 254
29959: PPUSH
29960: LD_INT 5
29962: PPUSH
29963: CALL_OW 273
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
29972: LD_VAR 0 16
29976: PUSH
29977: LD_INT 1
29979: ARRAY
29980: PPUSH
29981: LD_VAR 0 16
29985: PUSH
29986: LD_INT 2
29988: ARRAY
29989: PPUSH
29990: CALL_OW 488
29994: IFFALSE 30025
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
29996: LD_VAR 0 13
30000: PPUSH
30001: LD_VAR 0 16
30005: PUSH
30006: LD_INT 1
30008: ARRAY
30009: PPUSH
30010: LD_VAR 0 16
30014: PUSH
30015: LD_INT 2
30017: ARRAY
30018: PPUSH
30019: CALL_OW 111
// continue ;
30023: GO 29515
// end ; end ; r := GetDir ( tmp ) ;
30025: LD_ADDR_VAR 0 15
30029: PUSH
30030: LD_VAR 0 13
30034: PPUSH
30035: CALL_OW 254
30039: ST_TO_ADDR
// if r = 5 then
30040: LD_VAR 0 15
30044: PUSH
30045: LD_INT 5
30047: EQUAL
30048: IFFALSE 30058
// r := 0 ;
30050: LD_ADDR_VAR 0 15
30054: PUSH
30055: LD_INT 0
30057: ST_TO_ADDR
// for j = r to 5 do
30058: LD_ADDR_VAR 0 10
30062: PUSH
30063: DOUBLE
30064: LD_VAR 0 15
30068: DEC
30069: ST_TO_ADDR
30070: LD_INT 5
30072: PUSH
30073: FOR_TO
30074: IFFALSE 30188
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
30076: LD_ADDR_VAR 0 11
30080: PUSH
30081: LD_VAR 0 13
30085: PPUSH
30086: CALL_OW 250
30090: PPUSH
30091: LD_VAR 0 10
30095: PPUSH
30096: LD_INT 2
30098: PPUSH
30099: CALL_OW 272
30103: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
30104: LD_ADDR_VAR 0 12
30108: PUSH
30109: LD_VAR 0 13
30113: PPUSH
30114: CALL_OW 251
30118: PPUSH
30119: LD_VAR 0 10
30123: PPUSH
30124: LD_INT 2
30126: PPUSH
30127: CALL_OW 273
30131: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
30132: LD_VAR 0 11
30136: PPUSH
30137: LD_VAR 0 12
30141: PPUSH
30142: CALL_OW 488
30146: PUSH
30147: LD_VAR 0 11
30151: PPUSH
30152: LD_VAR 0 12
30156: PPUSH
30157: CALL_OW 428
30161: NOT
30162: AND
30163: IFFALSE 30186
// begin ComMoveXY ( tmp , _x , _y ) ;
30165: LD_VAR 0 13
30169: PPUSH
30170: LD_VAR 0 11
30174: PPUSH
30175: LD_VAR 0 12
30179: PPUSH
30180: CALL_OW 111
// break ;
30184: GO 30188
// end ; end ;
30186: GO 30073
30188: POP
30189: POP
// end ; end ;
30190: GO 29515
30192: POP
30193: POP
// end ;
30194: LD_VAR 0 8
30198: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
30199: LD_INT 0
30201: PPUSH
30202: PPUSH
30203: PPUSH
30204: PPUSH
30205: PPUSH
30206: PPUSH
30207: PPUSH
30208: PPUSH
30209: PPUSH
30210: PPUSH
// result := false ;
30211: LD_ADDR_VAR 0 6
30215: PUSH
30216: LD_INT 0
30218: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
30219: LD_VAR 0 1
30223: NOT
30224: PUSH
30225: LD_VAR 0 1
30229: PPUSH
30230: CALL_OW 266
30234: PUSH
30235: LD_INT 0
30237: PUSH
30238: LD_INT 1
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: IN
30245: NOT
30246: OR
30247: PUSH
30248: LD_VAR 0 2
30252: NOT
30253: OR
30254: PUSH
30255: LD_VAR 0 5
30259: PUSH
30260: LD_INT 0
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: LD_INT 2
30268: PUSH
30269: LD_INT 3
30271: PUSH
30272: LD_INT 4
30274: PUSH
30275: LD_INT 5
30277: PUSH
30278: EMPTY
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: LIST
30285: IN
30286: NOT
30287: OR
30288: PUSH
30289: LD_VAR 0 3
30293: PPUSH
30294: LD_VAR 0 4
30298: PPUSH
30299: CALL_OW 488
30303: NOT
30304: OR
30305: IFFALSE 30309
// exit ;
30307: GO 31026
// pom := GetBase ( depot ) ;
30309: LD_ADDR_VAR 0 10
30313: PUSH
30314: LD_VAR 0 1
30318: PPUSH
30319: CALL_OW 274
30323: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30324: LD_ADDR_VAR 0 11
30328: PUSH
30329: LD_VAR 0 2
30333: PPUSH
30334: LD_VAR 0 1
30338: PPUSH
30339: CALL_OW 248
30343: PPUSH
30344: CALL_OW 450
30348: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
30349: LD_VAR 0 10
30353: PPUSH
30354: LD_INT 1
30356: PPUSH
30357: CALL_OW 275
30361: PUSH
30362: LD_VAR 0 11
30366: PUSH
30367: LD_INT 1
30369: ARRAY
30370: GREATEREQUAL
30371: PUSH
30372: LD_VAR 0 10
30376: PPUSH
30377: LD_INT 2
30379: PPUSH
30380: CALL_OW 275
30384: PUSH
30385: LD_VAR 0 11
30389: PUSH
30390: LD_INT 2
30392: ARRAY
30393: GREATEREQUAL
30394: AND
30395: PUSH
30396: LD_VAR 0 10
30400: PPUSH
30401: LD_INT 3
30403: PPUSH
30404: CALL_OW 275
30408: PUSH
30409: LD_VAR 0 11
30413: PUSH
30414: LD_INT 3
30416: ARRAY
30417: GREATEREQUAL
30418: AND
30419: NOT
30420: IFFALSE 30424
// exit ;
30422: GO 31026
// if GetBType ( depot ) = b_depot then
30424: LD_VAR 0 1
30428: PPUSH
30429: CALL_OW 266
30433: PUSH
30434: LD_INT 0
30436: EQUAL
30437: IFFALSE 30449
// dist := 28 else
30439: LD_ADDR_VAR 0 14
30443: PUSH
30444: LD_INT 28
30446: ST_TO_ADDR
30447: GO 30457
// dist := 36 ;
30449: LD_ADDR_VAR 0 14
30453: PUSH
30454: LD_INT 36
30456: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
30457: LD_VAR 0 1
30461: PPUSH
30462: LD_VAR 0 3
30466: PPUSH
30467: LD_VAR 0 4
30471: PPUSH
30472: CALL_OW 297
30476: PUSH
30477: LD_VAR 0 14
30481: GREATER
30482: IFFALSE 30486
// exit ;
30484: GO 31026
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
30486: LD_ADDR_VAR 0 12
30490: PUSH
30491: LD_VAR 0 2
30495: PPUSH
30496: LD_VAR 0 3
30500: PPUSH
30501: LD_VAR 0 4
30505: PPUSH
30506: LD_VAR 0 5
30510: PPUSH
30511: LD_VAR 0 1
30515: PPUSH
30516: CALL_OW 248
30520: PPUSH
30521: LD_INT 0
30523: PPUSH
30524: CALL 31031 0 6
30528: ST_TO_ADDR
// if not hexes then
30529: LD_VAR 0 12
30533: NOT
30534: IFFALSE 30538
// exit ;
30536: GO 31026
// hex := GetHexInfo ( x , y ) ;
30538: LD_ADDR_VAR 0 15
30542: PUSH
30543: LD_VAR 0 3
30547: PPUSH
30548: LD_VAR 0 4
30552: PPUSH
30553: CALL_OW 546
30557: ST_TO_ADDR
// if hex [ 1 ] then
30558: LD_VAR 0 15
30562: PUSH
30563: LD_INT 1
30565: ARRAY
30566: IFFALSE 30570
// exit ;
30568: GO 31026
// height := hex [ 2 ] ;
30570: LD_ADDR_VAR 0 13
30574: PUSH
30575: LD_VAR 0 15
30579: PUSH
30580: LD_INT 2
30582: ARRAY
30583: ST_TO_ADDR
// for i = 1 to hexes do
30584: LD_ADDR_VAR 0 7
30588: PUSH
30589: DOUBLE
30590: LD_INT 1
30592: DEC
30593: ST_TO_ADDR
30594: LD_VAR 0 12
30598: PUSH
30599: FOR_TO
30600: IFFALSE 30930
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
30602: LD_VAR 0 12
30606: PUSH
30607: LD_VAR 0 7
30611: ARRAY
30612: PUSH
30613: LD_INT 1
30615: ARRAY
30616: PPUSH
30617: LD_VAR 0 12
30621: PUSH
30622: LD_VAR 0 7
30626: ARRAY
30627: PUSH
30628: LD_INT 2
30630: ARRAY
30631: PPUSH
30632: CALL_OW 488
30636: NOT
30637: PUSH
30638: LD_VAR 0 12
30642: PUSH
30643: LD_VAR 0 7
30647: ARRAY
30648: PUSH
30649: LD_INT 1
30651: ARRAY
30652: PPUSH
30653: LD_VAR 0 12
30657: PUSH
30658: LD_VAR 0 7
30662: ARRAY
30663: PUSH
30664: LD_INT 2
30666: ARRAY
30667: PPUSH
30668: CALL_OW 428
30672: PUSH
30673: LD_INT 0
30675: GREATER
30676: OR
30677: PUSH
30678: LD_VAR 0 12
30682: PUSH
30683: LD_VAR 0 7
30687: ARRAY
30688: PUSH
30689: LD_INT 1
30691: ARRAY
30692: PPUSH
30693: LD_VAR 0 12
30697: PUSH
30698: LD_VAR 0 7
30702: ARRAY
30703: PUSH
30704: LD_INT 2
30706: ARRAY
30707: PPUSH
30708: CALL_OW 351
30712: OR
30713: IFFALSE 30719
// exit ;
30715: POP
30716: POP
30717: GO 31026
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30719: LD_ADDR_VAR 0 8
30723: PUSH
30724: LD_VAR 0 12
30728: PUSH
30729: LD_VAR 0 7
30733: ARRAY
30734: PUSH
30735: LD_INT 1
30737: ARRAY
30738: PPUSH
30739: LD_VAR 0 12
30743: PUSH
30744: LD_VAR 0 7
30748: ARRAY
30749: PUSH
30750: LD_INT 2
30752: ARRAY
30753: PPUSH
30754: CALL_OW 546
30758: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
30759: LD_VAR 0 8
30763: PUSH
30764: LD_INT 1
30766: ARRAY
30767: PUSH
30768: LD_VAR 0 8
30772: PUSH
30773: LD_INT 2
30775: ARRAY
30776: PUSH
30777: LD_VAR 0 13
30781: PUSH
30782: LD_INT 2
30784: PLUS
30785: GREATER
30786: OR
30787: PUSH
30788: LD_VAR 0 8
30792: PUSH
30793: LD_INT 2
30795: ARRAY
30796: PUSH
30797: LD_VAR 0 13
30801: PUSH
30802: LD_INT 2
30804: MINUS
30805: LESS
30806: OR
30807: PUSH
30808: LD_VAR 0 8
30812: PUSH
30813: LD_INT 3
30815: ARRAY
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: LD_INT 8
30822: PUSH
30823: LD_INT 9
30825: PUSH
30826: LD_INT 10
30828: PUSH
30829: LD_INT 11
30831: PUSH
30832: LD_INT 12
30834: PUSH
30835: LD_INT 13
30837: PUSH
30838: LD_INT 16
30840: PUSH
30841: LD_INT 17
30843: PUSH
30844: LD_INT 18
30846: PUSH
30847: LD_INT 19
30849: PUSH
30850: LD_INT 20
30852: PUSH
30853: LD_INT 21
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: IN
30871: NOT
30872: OR
30873: PUSH
30874: LD_VAR 0 8
30878: PUSH
30879: LD_INT 5
30881: ARRAY
30882: NOT
30883: OR
30884: PUSH
30885: LD_VAR 0 8
30889: PUSH
30890: LD_INT 6
30892: ARRAY
30893: PUSH
30894: LD_INT 1
30896: PUSH
30897: LD_INT 2
30899: PUSH
30900: LD_INT 7
30902: PUSH
30903: LD_INT 9
30905: PUSH
30906: LD_INT 10
30908: PUSH
30909: LD_INT 11
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: IN
30920: NOT
30921: OR
30922: IFFALSE 30928
// exit ;
30924: POP
30925: POP
30926: GO 31026
// end ;
30928: GO 30599
30930: POP
30931: POP
// side := GetSide ( depot ) ;
30932: LD_ADDR_VAR 0 9
30936: PUSH
30937: LD_VAR 0 1
30941: PPUSH
30942: CALL_OW 255
30946: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
30947: LD_VAR 0 9
30951: PPUSH
30952: LD_VAR 0 3
30956: PPUSH
30957: LD_VAR 0 4
30961: PPUSH
30962: LD_INT 20
30964: PPUSH
30965: CALL 23347 0 4
30969: PUSH
30970: LD_INT 4
30972: ARRAY
30973: IFFALSE 30977
// exit ;
30975: GO 31026
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
30977: LD_VAR 0 2
30981: PUSH
30982: LD_INT 29
30984: PUSH
30985: LD_INT 30
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: IN
30992: PUSH
30993: LD_VAR 0 3
30997: PPUSH
30998: LD_VAR 0 4
31002: PPUSH
31003: LD_VAR 0 9
31007: PPUSH
31008: CALL_OW 440
31012: NOT
31013: AND
31014: IFFALSE 31018
// exit ;
31016: GO 31026
// result := true ;
31018: LD_ADDR_VAR 0 6
31022: PUSH
31023: LD_INT 1
31025: ST_TO_ADDR
// end ;
31026: LD_VAR 0 6
31030: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
31031: LD_INT 0
31033: PPUSH
31034: PPUSH
31035: PPUSH
31036: PPUSH
31037: PPUSH
31038: PPUSH
31039: PPUSH
31040: PPUSH
31041: PPUSH
31042: PPUSH
31043: PPUSH
31044: PPUSH
31045: PPUSH
31046: PPUSH
31047: PPUSH
31048: PPUSH
31049: PPUSH
31050: PPUSH
31051: PPUSH
31052: PPUSH
31053: PPUSH
31054: PPUSH
31055: PPUSH
31056: PPUSH
31057: PPUSH
31058: PPUSH
31059: PPUSH
31060: PPUSH
31061: PPUSH
31062: PPUSH
31063: PPUSH
31064: PPUSH
31065: PPUSH
31066: PPUSH
31067: PPUSH
31068: PPUSH
31069: PPUSH
31070: PPUSH
31071: PPUSH
31072: PPUSH
31073: PPUSH
31074: PPUSH
31075: PPUSH
31076: PPUSH
31077: PPUSH
31078: PPUSH
31079: PPUSH
31080: PPUSH
31081: PPUSH
31082: PPUSH
31083: PPUSH
31084: PPUSH
31085: PPUSH
31086: PPUSH
31087: PPUSH
31088: PPUSH
31089: PPUSH
31090: PPUSH
// result = [ ] ;
31091: LD_ADDR_VAR 0 7
31095: PUSH
31096: EMPTY
31097: ST_TO_ADDR
// temp_list = [ ] ;
31098: LD_ADDR_VAR 0 9
31102: PUSH
31103: EMPTY
31104: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
31105: LD_VAR 0 4
31109: PUSH
31110: LD_INT 0
31112: PUSH
31113: LD_INT 1
31115: PUSH
31116: LD_INT 2
31118: PUSH
31119: LD_INT 3
31121: PUSH
31122: LD_INT 4
31124: PUSH
31125: LD_INT 5
31127: PUSH
31128: EMPTY
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: IN
31136: NOT
31137: PUSH
31138: LD_VAR 0 1
31142: PUSH
31143: LD_INT 0
31145: PUSH
31146: LD_INT 1
31148: PUSH
31149: EMPTY
31150: LIST
31151: LIST
31152: IN
31153: PUSH
31154: LD_VAR 0 5
31158: PUSH
31159: LD_INT 1
31161: PUSH
31162: LD_INT 2
31164: PUSH
31165: LD_INT 3
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: LIST
31172: IN
31173: NOT
31174: AND
31175: OR
31176: IFFALSE 31180
// exit ;
31178: GO 49571
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
31180: LD_VAR 0 1
31184: PUSH
31185: LD_INT 6
31187: PUSH
31188: LD_INT 7
31190: PUSH
31191: LD_INT 8
31193: PUSH
31194: LD_INT 13
31196: PUSH
31197: LD_INT 12
31199: PUSH
31200: LD_INT 15
31202: PUSH
31203: LD_INT 11
31205: PUSH
31206: LD_INT 14
31208: PUSH
31209: LD_INT 10
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: LIST
31216: LIST
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: IN
31223: IFFALSE 31233
// btype = b_lab ;
31225: LD_ADDR_VAR 0 1
31229: PUSH
31230: LD_INT 6
31232: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
31233: LD_VAR 0 6
31237: PUSH
31238: LD_INT 0
31240: PUSH
31241: LD_INT 1
31243: PUSH
31244: LD_INT 2
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: LIST
31251: IN
31252: NOT
31253: PUSH
31254: LD_VAR 0 1
31258: PUSH
31259: LD_INT 0
31261: PUSH
31262: LD_INT 1
31264: PUSH
31265: LD_INT 2
31267: PUSH
31268: LD_INT 3
31270: PUSH
31271: LD_INT 6
31273: PUSH
31274: LD_INT 36
31276: PUSH
31277: LD_INT 4
31279: PUSH
31280: LD_INT 5
31282: PUSH
31283: LD_INT 31
31285: PUSH
31286: LD_INT 32
31288: PUSH
31289: LD_INT 33
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: LIST
31296: LIST
31297: LIST
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: IN
31305: NOT
31306: PUSH
31307: LD_VAR 0 6
31311: PUSH
31312: LD_INT 1
31314: EQUAL
31315: AND
31316: OR
31317: PUSH
31318: LD_VAR 0 1
31322: PUSH
31323: LD_INT 2
31325: PUSH
31326: LD_INT 3
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: IN
31333: NOT
31334: PUSH
31335: LD_VAR 0 6
31339: PUSH
31340: LD_INT 2
31342: EQUAL
31343: AND
31344: OR
31345: IFFALSE 31355
// mode = 0 ;
31347: LD_ADDR_VAR 0 6
31351: PUSH
31352: LD_INT 0
31354: ST_TO_ADDR
// case mode of 0 :
31355: LD_VAR 0 6
31359: PUSH
31360: LD_INT 0
31362: DOUBLE
31363: EQUAL
31364: IFTRUE 31368
31366: GO 42821
31368: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31369: LD_ADDR_VAR 0 11
31373: PUSH
31374: LD_INT 0
31376: PUSH
31377: LD_INT 0
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 0
31386: PUSH
31387: LD_INT 1
31389: NEG
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 1
31397: PUSH
31398: LD_INT 0
31400: PUSH
31401: EMPTY
31402: LIST
31403: LIST
31404: PUSH
31405: LD_INT 1
31407: PUSH
31408: LD_INT 1
31410: PUSH
31411: EMPTY
31412: LIST
31413: LIST
31414: PUSH
31415: LD_INT 0
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 1
31427: NEG
31428: PUSH
31429: LD_INT 0
31431: PUSH
31432: EMPTY
31433: LIST
31434: LIST
31435: PUSH
31436: LD_INT 1
31438: NEG
31439: PUSH
31440: LD_INT 1
31442: NEG
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 1
31450: NEG
31451: PUSH
31452: LD_INT 2
31454: NEG
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 0
31462: PUSH
31463: LD_INT 2
31465: NEG
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: PUSH
31474: LD_INT 1
31476: NEG
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 1
31484: PUSH
31485: LD_INT 2
31487: PUSH
31488: EMPTY
31489: LIST
31490: LIST
31491: PUSH
31492: LD_INT 0
31494: PUSH
31495: LD_INT 2
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 1
31504: NEG
31505: PUSH
31506: LD_INT 1
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: LD_INT 1
31515: PUSH
31516: LD_INT 3
31518: PUSH
31519: EMPTY
31520: LIST
31521: LIST
31522: PUSH
31523: LD_INT 0
31525: PUSH
31526: LD_INT 3
31528: PUSH
31529: EMPTY
31530: LIST
31531: LIST
31532: PUSH
31533: LD_INT 1
31535: NEG
31536: PUSH
31537: LD_INT 2
31539: PUSH
31540: EMPTY
31541: LIST
31542: LIST
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: LIST
31559: LIST
31560: LIST
31561: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31562: LD_ADDR_VAR 0 12
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: LD_INT 0
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 0
31579: PUSH
31580: LD_INT 1
31582: NEG
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 1
31590: PUSH
31591: LD_INT 0
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 1
31600: PUSH
31601: LD_INT 1
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 0
31610: PUSH
31611: LD_INT 1
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 1
31620: NEG
31621: PUSH
31622: LD_INT 0
31624: PUSH
31625: EMPTY
31626: LIST
31627: LIST
31628: PUSH
31629: LD_INT 1
31631: NEG
31632: PUSH
31633: LD_INT 1
31635: NEG
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: LD_INT 1
31643: PUSH
31644: LD_INT 1
31646: NEG
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 2
31654: PUSH
31655: LD_INT 0
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 2
31664: PUSH
31665: LD_INT 1
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 1
31674: NEG
31675: PUSH
31676: LD_INT 1
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 2
31685: NEG
31686: PUSH
31687: LD_INT 0
31689: PUSH
31690: EMPTY
31691: LIST
31692: LIST
31693: PUSH
31694: LD_INT 2
31696: NEG
31697: PUSH
31698: LD_INT 1
31700: NEG
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 2
31708: NEG
31709: PUSH
31710: LD_INT 1
31712: PUSH
31713: EMPTY
31714: LIST
31715: LIST
31716: PUSH
31717: LD_INT 3
31719: NEG
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: EMPTY
31725: LIST
31726: LIST
31727: PUSH
31728: LD_INT 3
31730: NEG
31731: PUSH
31732: LD_INT 1
31734: NEG
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: LIST
31744: LIST
31745: LIST
31746: LIST
31747: LIST
31748: LIST
31749: LIST
31750: LIST
31751: LIST
31752: LIST
31753: LIST
31754: LIST
31755: LIST
31756: LIST
31757: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31758: LD_ADDR_VAR 0 13
31762: PUSH
31763: LD_INT 0
31765: PUSH
31766: LD_INT 0
31768: PUSH
31769: EMPTY
31770: LIST
31771: LIST
31772: PUSH
31773: LD_INT 0
31775: PUSH
31776: LD_INT 1
31778: NEG
31779: PUSH
31780: EMPTY
31781: LIST
31782: LIST
31783: PUSH
31784: LD_INT 1
31786: PUSH
31787: LD_INT 0
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: PUSH
31794: LD_INT 1
31796: PUSH
31797: LD_INT 1
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: PUSH
31804: LD_INT 0
31806: PUSH
31807: LD_INT 1
31809: PUSH
31810: EMPTY
31811: LIST
31812: LIST
31813: PUSH
31814: LD_INT 1
31816: NEG
31817: PUSH
31818: LD_INT 0
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 1
31827: NEG
31828: PUSH
31829: LD_INT 1
31831: NEG
31832: PUSH
31833: EMPTY
31834: LIST
31835: LIST
31836: PUSH
31837: LD_INT 1
31839: NEG
31840: PUSH
31841: LD_INT 2
31843: NEG
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 2
31851: PUSH
31852: LD_INT 1
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PUSH
31859: LD_INT 2
31861: PUSH
31862: LD_INT 2
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: PUSH
31869: LD_INT 1
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 2
31881: NEG
31882: PUSH
31883: LD_INT 1
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 2
31893: NEG
31894: PUSH
31895: LD_INT 2
31897: NEG
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 2
31905: NEG
31906: PUSH
31907: LD_INT 3
31909: NEG
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 3
31917: NEG
31918: PUSH
31919: LD_INT 2
31921: NEG
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: PUSH
31927: LD_INT 3
31929: NEG
31930: PUSH
31931: LD_INT 3
31933: NEG
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: EMPTY
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31957: LD_ADDR_VAR 0 14
31961: PUSH
31962: LD_INT 0
31964: PUSH
31965: LD_INT 0
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 0
31974: PUSH
31975: LD_INT 1
31977: NEG
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 1
31985: PUSH
31986: LD_INT 0
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 1
31995: PUSH
31996: LD_INT 1
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: LD_INT 1
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: LD_INT 1
32015: NEG
32016: PUSH
32017: LD_INT 0
32019: PUSH
32020: EMPTY
32021: LIST
32022: LIST
32023: PUSH
32024: LD_INT 1
32026: NEG
32027: PUSH
32028: LD_INT 1
32030: NEG
32031: PUSH
32032: EMPTY
32033: LIST
32034: LIST
32035: PUSH
32036: LD_INT 1
32038: NEG
32039: PUSH
32040: LD_INT 2
32042: NEG
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PUSH
32048: LD_INT 0
32050: PUSH
32051: LD_INT 2
32053: NEG
32054: PUSH
32055: EMPTY
32056: LIST
32057: LIST
32058: PUSH
32059: LD_INT 1
32061: PUSH
32062: LD_INT 1
32064: NEG
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 1
32072: PUSH
32073: LD_INT 2
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 0
32082: PUSH
32083: LD_INT 2
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: LD_INT 1
32092: NEG
32093: PUSH
32094: LD_INT 1
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: LD_INT 1
32103: NEG
32104: PUSH
32105: LD_INT 3
32107: NEG
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PUSH
32113: LD_INT 0
32115: PUSH
32116: LD_INT 3
32118: NEG
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 1
32126: PUSH
32127: LD_INT 2
32129: NEG
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: EMPTY
32136: LIST
32137: LIST
32138: LIST
32139: LIST
32140: LIST
32141: LIST
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
32153: LD_ADDR_VAR 0 15
32157: PUSH
32158: LD_INT 0
32160: PUSH
32161: LD_INT 0
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 0
32170: PUSH
32171: LD_INT 1
32173: NEG
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 1
32181: PUSH
32182: LD_INT 0
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 1
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 0
32201: PUSH
32202: LD_INT 1
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: LD_INT 1
32211: NEG
32212: PUSH
32213: LD_INT 0
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: PUSH
32220: LD_INT 1
32222: NEG
32223: PUSH
32224: LD_INT 1
32226: NEG
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 1
32234: PUSH
32235: LD_INT 1
32237: NEG
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 2
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 2
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 1
32265: NEG
32266: PUSH
32267: LD_INT 1
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: LD_INT 2
32276: NEG
32277: PUSH
32278: LD_INT 0
32280: PUSH
32281: EMPTY
32282: LIST
32283: LIST
32284: PUSH
32285: LD_INT 2
32287: NEG
32288: PUSH
32289: LD_INT 1
32291: NEG
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 2
32299: PUSH
32300: LD_INT 1
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 3
32310: PUSH
32311: LD_INT 0
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: LD_INT 3
32320: PUSH
32321: LD_INT 1
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: LIST
32345: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32346: LD_ADDR_VAR 0 16
32350: PUSH
32351: LD_INT 0
32353: PUSH
32354: LD_INT 0
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 0
32363: PUSH
32364: LD_INT 1
32366: NEG
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 1
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 1
32384: PUSH
32385: LD_INT 1
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: LD_INT 0
32394: PUSH
32395: LD_INT 1
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 1
32404: NEG
32405: PUSH
32406: LD_INT 0
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: LD_INT 1
32415: NEG
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 1
32427: NEG
32428: PUSH
32429: LD_INT 2
32431: NEG
32432: PUSH
32433: EMPTY
32434: LIST
32435: LIST
32436: PUSH
32437: LD_INT 2
32439: PUSH
32440: LD_INT 1
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 2
32449: PUSH
32450: LD_INT 2
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 1
32459: PUSH
32460: LD_INT 2
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PUSH
32467: LD_INT 2
32469: NEG
32470: PUSH
32471: LD_INT 1
32473: NEG
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 2
32481: NEG
32482: PUSH
32483: LD_INT 2
32485: NEG
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 3
32493: PUSH
32494: LD_INT 2
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 3
32503: PUSH
32504: LD_INT 3
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 2
32513: PUSH
32514: LD_INT 3
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32539: LD_ADDR_VAR 0 17
32543: PUSH
32544: LD_INT 0
32546: PUSH
32547: LD_INT 0
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: LD_INT 1
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 1
32567: PUSH
32568: LD_INT 0
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 1
32577: PUSH
32578: LD_INT 1
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 0
32587: PUSH
32588: LD_INT 1
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 1
32597: NEG
32598: PUSH
32599: LD_INT 0
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 1
32608: NEG
32609: PUSH
32610: LD_INT 1
32612: NEG
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: PUSH
32618: LD_INT 1
32620: NEG
32621: PUSH
32622: LD_INT 2
32624: NEG
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: LD_INT 0
32632: PUSH
32633: LD_INT 2
32635: NEG
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 1
32643: PUSH
32644: LD_INT 1
32646: NEG
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 2
32654: PUSH
32655: LD_INT 0
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 2
32664: PUSH
32665: LD_INT 1
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 2
32674: PUSH
32675: LD_INT 2
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: LD_INT 2
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 0
32694: PUSH
32695: LD_INT 2
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: NEG
32705: PUSH
32706: LD_INT 1
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 2
32715: NEG
32716: PUSH
32717: LD_INT 0
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 2
32726: NEG
32727: PUSH
32728: LD_INT 1
32730: NEG
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 2
32738: NEG
32739: PUSH
32740: LD_INT 2
32742: NEG
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: LIST
32752: LIST
32753: LIST
32754: LIST
32755: LIST
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32769: LD_ADDR_VAR 0 18
32773: PUSH
32774: LD_INT 0
32776: PUSH
32777: LD_INT 0
32779: PUSH
32780: EMPTY
32781: LIST
32782: LIST
32783: PUSH
32784: LD_INT 0
32786: PUSH
32787: LD_INT 1
32789: NEG
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 1
32797: PUSH
32798: LD_INT 0
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: PUSH
32805: LD_INT 1
32807: PUSH
32808: LD_INT 1
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: LD_INT 0
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: LD_INT 1
32827: NEG
32828: PUSH
32829: LD_INT 0
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PUSH
32836: LD_INT 1
32838: NEG
32839: PUSH
32840: LD_INT 1
32842: NEG
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 1
32850: NEG
32851: PUSH
32852: LD_INT 2
32854: NEG
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 0
32862: PUSH
32863: LD_INT 2
32865: NEG
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 1
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 2
32884: PUSH
32885: LD_INT 0
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: LD_INT 2
32894: PUSH
32895: LD_INT 1
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: LD_INT 2
32904: PUSH
32905: LD_INT 2
32907: PUSH
32908: EMPTY
32909: LIST
32910: LIST
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: LD_INT 2
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: LD_INT 2
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 1
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 2
32945: NEG
32946: PUSH
32947: LD_INT 0
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: PUSH
32954: LD_INT 2
32956: NEG
32957: PUSH
32958: LD_INT 1
32960: NEG
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 2
32968: NEG
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32999: LD_ADDR_VAR 0 19
33003: PUSH
33004: LD_INT 0
33006: PUSH
33007: LD_INT 0
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: PUSH
33014: LD_INT 0
33016: PUSH
33017: LD_INT 1
33019: NEG
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 1
33027: PUSH
33028: LD_INT 0
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 0
33047: PUSH
33048: LD_INT 1
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: LD_INT 1
33057: NEG
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: PUSH
33066: LD_INT 1
33068: NEG
33069: PUSH
33070: LD_INT 1
33072: NEG
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: LD_INT 1
33080: NEG
33081: PUSH
33082: LD_INT 2
33084: NEG
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 0
33092: PUSH
33093: LD_INT 2
33095: NEG
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 1
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 2
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 2
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 2
33134: PUSH
33135: LD_INT 2
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 1
33144: PUSH
33145: LD_INT 2
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 0
33154: PUSH
33155: LD_INT 2
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 1
33164: NEG
33165: PUSH
33166: LD_INT 1
33168: PUSH
33169: EMPTY
33170: LIST
33171: LIST
33172: PUSH
33173: LD_INT 2
33175: NEG
33176: PUSH
33177: LD_INT 0
33179: PUSH
33180: EMPTY
33181: LIST
33182: LIST
33183: PUSH
33184: LD_INT 2
33186: NEG
33187: PUSH
33188: LD_INT 1
33190: NEG
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 2
33198: NEG
33199: PUSH
33200: LD_INT 2
33202: NEG
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33229: LD_ADDR_VAR 0 20
33233: PUSH
33234: LD_INT 0
33236: PUSH
33237: LD_INT 0
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 0
33246: PUSH
33247: LD_INT 1
33249: NEG
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 1
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 1
33267: PUSH
33268: LD_INT 1
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 0
33277: PUSH
33278: LD_INT 1
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 1
33287: NEG
33288: PUSH
33289: LD_INT 0
33291: PUSH
33292: EMPTY
33293: LIST
33294: LIST
33295: PUSH
33296: LD_INT 1
33298: NEG
33299: PUSH
33300: LD_INT 1
33302: NEG
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 1
33310: NEG
33311: PUSH
33312: LD_INT 2
33314: NEG
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: PUSH
33320: LD_INT 0
33322: PUSH
33323: LD_INT 2
33325: NEG
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: LD_INT 1
33333: PUSH
33334: LD_INT 1
33336: NEG
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 2
33344: PUSH
33345: LD_INT 0
33347: PUSH
33348: EMPTY
33349: LIST
33350: LIST
33351: PUSH
33352: LD_INT 2
33354: PUSH
33355: LD_INT 1
33357: PUSH
33358: EMPTY
33359: LIST
33360: LIST
33361: PUSH
33362: LD_INT 2
33364: PUSH
33365: LD_INT 2
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 1
33374: PUSH
33375: LD_INT 2
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: LD_INT 2
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 1
33394: NEG
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 2
33405: NEG
33406: PUSH
33407: LD_INT 0
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 2
33416: NEG
33417: PUSH
33418: LD_INT 1
33420: NEG
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 2
33428: NEG
33429: PUSH
33430: LD_INT 2
33432: NEG
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: LIST
33453: LIST
33454: LIST
33455: LIST
33456: LIST
33457: LIST
33458: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33459: LD_ADDR_VAR 0 21
33463: PUSH
33464: LD_INT 0
33466: PUSH
33467: LD_INT 0
33469: PUSH
33470: EMPTY
33471: LIST
33472: LIST
33473: PUSH
33474: LD_INT 0
33476: PUSH
33477: LD_INT 1
33479: NEG
33480: PUSH
33481: EMPTY
33482: LIST
33483: LIST
33484: PUSH
33485: LD_INT 1
33487: PUSH
33488: LD_INT 0
33490: PUSH
33491: EMPTY
33492: LIST
33493: LIST
33494: PUSH
33495: LD_INT 1
33497: PUSH
33498: LD_INT 1
33500: PUSH
33501: EMPTY
33502: LIST
33503: LIST
33504: PUSH
33505: LD_INT 0
33507: PUSH
33508: LD_INT 1
33510: PUSH
33511: EMPTY
33512: LIST
33513: LIST
33514: PUSH
33515: LD_INT 1
33517: NEG
33518: PUSH
33519: LD_INT 0
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 1
33528: NEG
33529: PUSH
33530: LD_INT 1
33532: NEG
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: LD_INT 2
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 0
33552: PUSH
33553: LD_INT 2
33555: NEG
33556: PUSH
33557: EMPTY
33558: LIST
33559: LIST
33560: PUSH
33561: LD_INT 1
33563: PUSH
33564: LD_INT 1
33566: NEG
33567: PUSH
33568: EMPTY
33569: LIST
33570: LIST
33571: PUSH
33572: LD_INT 2
33574: PUSH
33575: LD_INT 0
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 2
33584: PUSH
33585: LD_INT 1
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PUSH
33592: LD_INT 2
33594: PUSH
33595: LD_INT 2
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 1
33604: PUSH
33605: LD_INT 2
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 0
33614: PUSH
33615: LD_INT 2
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 1
33624: NEG
33625: PUSH
33626: LD_INT 1
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 2
33635: NEG
33636: PUSH
33637: LD_INT 0
33639: PUSH
33640: EMPTY
33641: LIST
33642: LIST
33643: PUSH
33644: LD_INT 2
33646: NEG
33647: PUSH
33648: LD_INT 1
33650: NEG
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 2
33658: NEG
33659: PUSH
33660: LD_INT 2
33662: NEG
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: LIST
33672: LIST
33673: LIST
33674: LIST
33675: LIST
33676: LIST
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33689: LD_ADDR_VAR 0 22
33693: PUSH
33694: LD_INT 0
33696: PUSH
33697: LD_INT 0
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 0
33706: PUSH
33707: LD_INT 1
33709: NEG
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 1
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 1
33727: PUSH
33728: LD_INT 1
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 0
33737: PUSH
33738: LD_INT 1
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: LD_INT 1
33747: NEG
33748: PUSH
33749: LD_INT 0
33751: PUSH
33752: EMPTY
33753: LIST
33754: LIST
33755: PUSH
33756: LD_INT 1
33758: NEG
33759: PUSH
33760: LD_INT 1
33762: NEG
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 1
33770: NEG
33771: PUSH
33772: LD_INT 2
33774: NEG
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 0
33782: PUSH
33783: LD_INT 2
33785: NEG
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 1
33793: PUSH
33794: LD_INT 1
33796: NEG
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 2
33804: PUSH
33805: LD_INT 0
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: LD_INT 2
33814: PUSH
33815: LD_INT 1
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: PUSH
33822: LD_INT 2
33824: PUSH
33825: LD_INT 2
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 1
33834: PUSH
33835: LD_INT 2
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 0
33844: PUSH
33845: LD_INT 2
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 1
33854: NEG
33855: PUSH
33856: LD_INT 1
33858: PUSH
33859: EMPTY
33860: LIST
33861: LIST
33862: PUSH
33863: LD_INT 2
33865: NEG
33866: PUSH
33867: LD_INT 0
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: LD_INT 2
33876: NEG
33877: PUSH
33878: LD_INT 1
33880: NEG
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 2
33888: NEG
33889: PUSH
33890: LD_INT 2
33892: NEG
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: LIST
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
33919: LD_ADDR_VAR 0 23
33923: PUSH
33924: LD_INT 0
33926: PUSH
33927: LD_INT 0
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: PUSH
33934: LD_INT 0
33936: PUSH
33937: LD_INT 1
33939: NEG
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: PUSH
33945: LD_INT 1
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: PUSH
33955: LD_INT 1
33957: PUSH
33958: LD_INT 1
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 0
33967: PUSH
33968: LD_INT 1
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: LD_INT 1
33977: NEG
33978: PUSH
33979: LD_INT 0
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PUSH
33986: LD_INT 1
33988: NEG
33989: PUSH
33990: LD_INT 1
33992: NEG
33993: PUSH
33994: EMPTY
33995: LIST
33996: LIST
33997: PUSH
33998: LD_INT 1
34000: NEG
34001: PUSH
34002: LD_INT 2
34004: NEG
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 0
34012: PUSH
34013: LD_INT 2
34015: NEG
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: PUSH
34024: LD_INT 1
34026: NEG
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 2
34034: PUSH
34035: LD_INT 0
34037: PUSH
34038: EMPTY
34039: LIST
34040: LIST
34041: PUSH
34042: LD_INT 2
34044: PUSH
34045: LD_INT 1
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 2
34054: PUSH
34055: LD_INT 2
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 1
34064: PUSH
34065: LD_INT 2
34067: PUSH
34068: EMPTY
34069: LIST
34070: LIST
34071: PUSH
34072: LD_INT 0
34074: PUSH
34075: LD_INT 2
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: PUSH
34082: LD_INT 1
34084: NEG
34085: PUSH
34086: LD_INT 1
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 2
34095: NEG
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: EMPTY
34101: LIST
34102: LIST
34103: PUSH
34104: LD_INT 2
34106: NEG
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 2
34118: NEG
34119: PUSH
34120: LD_INT 2
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 2
34130: NEG
34131: PUSH
34132: LD_INT 3
34134: NEG
34135: PUSH
34136: EMPTY
34137: LIST
34138: LIST
34139: PUSH
34140: LD_INT 1
34142: NEG
34143: PUSH
34144: LD_INT 3
34146: NEG
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 1
34154: PUSH
34155: LD_INT 2
34157: NEG
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 2
34165: PUSH
34166: LD_INT 1
34168: NEG
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: LIST
34186: LIST
34187: LIST
34188: LIST
34189: LIST
34190: LIST
34191: LIST
34192: LIST
34193: LIST
34194: LIST
34195: LIST
34196: LIST
34197: LIST
34198: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
34199: LD_ADDR_VAR 0 24
34203: PUSH
34204: LD_INT 0
34206: PUSH
34207: LD_INT 0
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 1
34219: NEG
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: LD_INT 1
34227: PUSH
34228: LD_INT 0
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: PUSH
34238: LD_INT 1
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 0
34247: PUSH
34248: LD_INT 1
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 1
34257: NEG
34258: PUSH
34259: LD_INT 0
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 1
34268: NEG
34269: PUSH
34270: LD_INT 1
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 1
34280: NEG
34281: PUSH
34282: LD_INT 2
34284: NEG
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 2
34295: NEG
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 1
34303: PUSH
34304: LD_INT 1
34306: NEG
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 2
34314: PUSH
34315: LD_INT 0
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 2
34324: PUSH
34325: LD_INT 1
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PUSH
34332: LD_INT 2
34334: PUSH
34335: LD_INT 2
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 1
34344: PUSH
34345: LD_INT 2
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 0
34354: PUSH
34355: LD_INT 2
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 1
34364: NEG
34365: PUSH
34366: LD_INT 1
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: PUSH
34373: LD_INT 2
34375: NEG
34376: PUSH
34377: LD_INT 0
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 2
34386: NEG
34387: PUSH
34388: LD_INT 1
34390: NEG
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: PUSH
34396: LD_INT 2
34398: NEG
34399: PUSH
34400: LD_INT 2
34402: NEG
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 1
34410: PUSH
34411: LD_INT 2
34413: NEG
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 2
34421: PUSH
34422: LD_INT 1
34424: NEG
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 3
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 3
34442: PUSH
34443: LD_INT 2
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: EMPTY
34451: LIST
34452: LIST
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: LIST
34461: LIST
34462: LIST
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: LIST
34470: LIST
34471: LIST
34472: LIST
34473: LIST
34474: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
34475: LD_ADDR_VAR 0 25
34479: PUSH
34480: LD_INT 0
34482: PUSH
34483: LD_INT 0
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: LD_INT 1
34495: NEG
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 1
34503: PUSH
34504: LD_INT 0
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 1
34513: PUSH
34514: LD_INT 1
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 0
34523: PUSH
34524: LD_INT 1
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 1
34533: NEG
34534: PUSH
34535: LD_INT 0
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 1
34544: NEG
34545: PUSH
34546: LD_INT 1
34548: NEG
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 1
34556: NEG
34557: PUSH
34558: LD_INT 2
34560: NEG
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 0
34568: PUSH
34569: LD_INT 2
34571: NEG
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: PUSH
34577: LD_INT 1
34579: PUSH
34580: LD_INT 1
34582: NEG
34583: PUSH
34584: EMPTY
34585: LIST
34586: LIST
34587: PUSH
34588: LD_INT 2
34590: PUSH
34591: LD_INT 0
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: PUSH
34598: LD_INT 2
34600: PUSH
34601: LD_INT 1
34603: PUSH
34604: EMPTY
34605: LIST
34606: LIST
34607: PUSH
34608: LD_INT 2
34610: PUSH
34611: LD_INT 2
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 1
34620: PUSH
34621: LD_INT 2
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 0
34630: PUSH
34631: LD_INT 2
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 1
34640: NEG
34641: PUSH
34642: LD_INT 1
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 2
34651: NEG
34652: PUSH
34653: LD_INT 0
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: LD_INT 2
34662: NEG
34663: PUSH
34664: LD_INT 1
34666: NEG
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 2
34674: NEG
34675: PUSH
34676: LD_INT 2
34678: NEG
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 3
34686: PUSH
34687: LD_INT 1
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 3
34696: PUSH
34697: LD_INT 2
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 2
34706: PUSH
34707: LD_INT 3
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 1
34716: PUSH
34717: LD_INT 3
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
34749: LD_ADDR_VAR 0 26
34753: PUSH
34754: LD_INT 0
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: LD_INT 1
34769: NEG
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: LD_INT 0
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 1
34787: PUSH
34788: LD_INT 1
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 0
34797: PUSH
34798: LD_INT 1
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 1
34807: NEG
34808: PUSH
34809: LD_INT 0
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 1
34830: NEG
34831: PUSH
34832: LD_INT 2
34834: NEG
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: LD_INT 2
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: LD_INT 1
34856: NEG
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 2
34864: PUSH
34865: LD_INT 0
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 2
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: LD_INT 2
34884: PUSH
34885: LD_INT 2
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 1
34894: PUSH
34895: LD_INT 2
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 0
34904: PUSH
34905: LD_INT 2
34907: PUSH
34908: EMPTY
34909: LIST
34910: LIST
34911: PUSH
34912: LD_INT 1
34914: NEG
34915: PUSH
34916: LD_INT 1
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: LD_INT 2
34925: NEG
34926: PUSH
34927: LD_INT 0
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 2
34936: NEG
34937: PUSH
34938: LD_INT 1
34940: NEG
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 2
34948: NEG
34949: PUSH
34950: LD_INT 2
34952: NEG
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: LD_INT 3
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: PUSH
34971: LD_INT 3
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 1
34980: NEG
34981: PUSH
34982: LD_INT 2
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 2
34991: NEG
34992: PUSH
34993: LD_INT 1
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: LIST
35017: LIST
35018: LIST
35019: LIST
35020: LIST
35021: LIST
35022: LIST
35023: LIST
35024: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35025: LD_ADDR_VAR 0 27
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: LD_INT 0
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 0
35042: PUSH
35043: LD_INT 1
35045: NEG
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 1
35053: PUSH
35054: LD_INT 0
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 1
35063: PUSH
35064: LD_INT 1
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 0
35073: PUSH
35074: LD_INT 1
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 1
35083: NEG
35084: PUSH
35085: LD_INT 0
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 1
35094: NEG
35095: PUSH
35096: LD_INT 1
35098: NEG
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 1
35106: NEG
35107: PUSH
35108: LD_INT 2
35110: NEG
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: PUSH
35116: LD_INT 0
35118: PUSH
35119: LD_INT 2
35121: NEG
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 1
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 2
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 2
35150: PUSH
35151: LD_INT 1
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 2
35160: PUSH
35161: LD_INT 2
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: LD_INT 2
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 0
35180: PUSH
35181: LD_INT 2
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 1
35190: NEG
35191: PUSH
35192: LD_INT 1
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 2
35201: NEG
35202: PUSH
35203: LD_INT 0
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 2
35212: NEG
35213: PUSH
35214: LD_INT 1
35216: NEG
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 2
35224: NEG
35225: PUSH
35226: LD_INT 2
35228: NEG
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 1
35236: NEG
35237: PUSH
35238: LD_INT 2
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 2
35247: NEG
35248: PUSH
35249: LD_INT 1
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 3
35258: NEG
35259: PUSH
35260: LD_INT 1
35262: NEG
35263: PUSH
35264: EMPTY
35265: LIST
35266: LIST
35267: PUSH
35268: LD_INT 3
35270: NEG
35271: PUSH
35272: LD_INT 2
35274: NEG
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35305: LD_ADDR_VAR 0 28
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: LD_INT 0
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: LD_INT 1
35325: NEG
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 1
35333: PUSH
35334: LD_INT 0
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: LD_INT 1
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 1
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 1
35363: NEG
35364: PUSH
35365: LD_INT 0
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: NEG
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 1
35386: NEG
35387: PUSH
35388: LD_INT 2
35390: NEG
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 0
35398: PUSH
35399: LD_INT 2
35401: NEG
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: LD_INT 1
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: PUSH
35421: LD_INT 0
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 2
35430: PUSH
35431: LD_INT 1
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 2
35440: PUSH
35441: LD_INT 2
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: LD_INT 2
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 0
35460: PUSH
35461: LD_INT 2
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: LD_INT 1
35470: NEG
35471: PUSH
35472: LD_INT 1
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 2
35481: NEG
35482: PUSH
35483: LD_INT 0
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: PUSH
35490: LD_INT 2
35492: NEG
35493: PUSH
35494: LD_INT 1
35496: NEG
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PUSH
35502: LD_INT 2
35504: NEG
35505: PUSH
35506: LD_INT 2
35508: NEG
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 2
35516: NEG
35517: PUSH
35518: LD_INT 3
35520: NEG
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: LD_INT 3
35532: NEG
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: PUSH
35538: LD_INT 3
35540: NEG
35541: PUSH
35542: LD_INT 1
35544: NEG
35545: PUSH
35546: EMPTY
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 3
35552: NEG
35553: PUSH
35554: LD_INT 2
35556: NEG
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: LIST
35583: LIST
35584: LIST
35585: LIST
35586: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35587: LD_ADDR_VAR 0 29
35591: PUSH
35592: LD_INT 0
35594: PUSH
35595: LD_INT 0
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 0
35604: PUSH
35605: LD_INT 1
35607: NEG
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 1
35615: PUSH
35616: LD_INT 0
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 0
35635: PUSH
35636: LD_INT 1
35638: PUSH
35639: EMPTY
35640: LIST
35641: LIST
35642: PUSH
35643: LD_INT 1
35645: NEG
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 1
35656: NEG
35657: PUSH
35658: LD_INT 1
35660: NEG
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 1
35668: NEG
35669: PUSH
35670: LD_INT 2
35672: NEG
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: LD_INT 0
35680: PUSH
35681: LD_INT 2
35683: NEG
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 1
35691: PUSH
35692: LD_INT 1
35694: NEG
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 2
35702: PUSH
35703: LD_INT 0
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: LD_INT 2
35712: PUSH
35713: LD_INT 1
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 1
35722: PUSH
35723: LD_INT 2
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 0
35732: PUSH
35733: LD_INT 2
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: LD_INT 1
35742: NEG
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: PUSH
35751: LD_INT 2
35753: NEG
35754: PUSH
35755: LD_INT 1
35757: NEG
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: PUSH
35763: LD_INT 2
35765: NEG
35766: PUSH
35767: LD_INT 2
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 2
35777: NEG
35778: PUSH
35779: LD_INT 3
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 2
35789: PUSH
35790: LD_INT 1
35792: NEG
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 3
35800: PUSH
35801: LD_INT 1
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 1
35810: PUSH
35811: LD_INT 3
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 1
35820: NEG
35821: PUSH
35822: LD_INT 2
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 3
35831: NEG
35832: PUSH
35833: LD_INT 2
35835: NEG
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: LIST
35857: LIST
35858: LIST
35859: LIST
35860: LIST
35861: LIST
35862: LIST
35863: LIST
35864: LIST
35865: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35866: LD_ADDR_VAR 0 30
35870: PUSH
35871: LD_INT 0
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 0
35883: PUSH
35884: LD_INT 1
35886: NEG
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: PUSH
35895: LD_INT 0
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: PUSH
35905: LD_INT 1
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 0
35914: PUSH
35915: LD_INT 1
35917: PUSH
35918: EMPTY
35919: LIST
35920: LIST
35921: PUSH
35922: LD_INT 1
35924: NEG
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: EMPTY
35930: LIST
35931: LIST
35932: PUSH
35933: LD_INT 1
35935: NEG
35936: PUSH
35937: LD_INT 1
35939: NEG
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: LD_INT 1
35947: NEG
35948: PUSH
35949: LD_INT 2
35951: NEG
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 0
35959: PUSH
35960: LD_INT 2
35962: NEG
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 1
35970: PUSH
35971: LD_INT 1
35973: NEG
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: PUSH
35979: LD_INT 2
35981: PUSH
35982: LD_INT 0
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 2
35991: PUSH
35992: LD_INT 1
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: PUSH
35999: LD_INT 2
36001: PUSH
36002: LD_INT 2
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 1
36011: PUSH
36012: LD_INT 2
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 1
36021: NEG
36022: PUSH
36023: LD_INT 1
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: LD_INT 2
36032: NEG
36033: PUSH
36034: LD_INT 0
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 2
36043: NEG
36044: PUSH
36045: LD_INT 1
36047: NEG
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 1
36055: NEG
36056: PUSH
36057: LD_INT 3
36059: NEG
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: LD_INT 2
36070: NEG
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 3
36078: PUSH
36079: LD_INT 2
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 2
36088: PUSH
36089: LD_INT 3
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 2
36098: NEG
36099: PUSH
36100: LD_INT 1
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 3
36109: NEG
36110: PUSH
36111: LD_INT 1
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36144: LD_ADDR_VAR 0 31
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 0
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: LD_INT 1
36164: NEG
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 1
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: LD_INT 1
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: EMPTY
36208: LIST
36209: LIST
36210: PUSH
36211: LD_INT 1
36213: NEG
36214: PUSH
36215: LD_INT 1
36217: NEG
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: LD_INT 1
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 2
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 2
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 2
36268: PUSH
36269: LD_INT 2
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 1
36278: PUSH
36279: LD_INT 2
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 0
36288: PUSH
36289: LD_INT 2
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 1
36298: NEG
36299: PUSH
36300: LD_INT 1
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 2
36309: NEG
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 2
36321: NEG
36322: PUSH
36323: LD_INT 2
36325: NEG
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 2
36333: NEG
36334: PUSH
36335: LD_INT 3
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 2
36345: PUSH
36346: LD_INT 1
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 3
36356: PUSH
36357: LD_INT 1
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 1
36366: PUSH
36367: LD_INT 3
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 1
36376: NEG
36377: PUSH
36378: LD_INT 2
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 3
36387: NEG
36388: PUSH
36389: LD_INT 2
36391: NEG
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: LIST
36407: LIST
36408: LIST
36409: LIST
36410: LIST
36411: LIST
36412: LIST
36413: LIST
36414: LIST
36415: LIST
36416: LIST
36417: LIST
36418: LIST
36419: LIST
36420: LIST
36421: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36422: LD_ADDR_VAR 0 32
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 0
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 0
36439: PUSH
36440: LD_INT 1
36442: NEG
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: PUSH
36451: LD_INT 0
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 1
36460: PUSH
36461: LD_INT 1
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: LD_INT 1
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 1
36480: NEG
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: NEG
36492: PUSH
36493: LD_INT 1
36495: NEG
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 1
36503: NEG
36504: PUSH
36505: LD_INT 2
36507: NEG
36508: PUSH
36509: EMPTY
36510: LIST
36511: LIST
36512: PUSH
36513: LD_INT 0
36515: PUSH
36516: LD_INT 2
36518: NEG
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 1
36526: PUSH
36527: LD_INT 1
36529: NEG
36530: PUSH
36531: EMPTY
36532: LIST
36533: LIST
36534: PUSH
36535: LD_INT 2
36537: PUSH
36538: LD_INT 1
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: LD_INT 2
36547: PUSH
36548: LD_INT 2
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: LD_INT 2
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: PUSH
36565: LD_INT 0
36567: PUSH
36568: LD_INT 2
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 1
36577: NEG
36578: PUSH
36579: LD_INT 1
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 2
36588: NEG
36589: PUSH
36590: LD_INT 0
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 2
36599: NEG
36600: PUSH
36601: LD_INT 1
36603: NEG
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 1
36611: NEG
36612: PUSH
36613: LD_INT 3
36615: NEG
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 1
36623: PUSH
36624: LD_INT 2
36626: NEG
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: PUSH
36632: LD_INT 3
36634: PUSH
36635: LD_INT 2
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 2
36644: PUSH
36645: LD_INT 3
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 2
36654: NEG
36655: PUSH
36656: LD_INT 1
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 3
36665: NEG
36666: PUSH
36667: LD_INT 1
36669: NEG
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: EMPTY
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36700: LD_ADDR_VAR 0 33
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: LD_INT 0
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: PUSH
36715: LD_INT 0
36717: PUSH
36718: LD_INT 1
36720: NEG
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 1
36728: PUSH
36729: LD_INT 0
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 1
36738: PUSH
36739: LD_INT 1
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 0
36748: PUSH
36749: LD_INT 1
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 1
36758: NEG
36759: PUSH
36760: LD_INT 0
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PUSH
36767: LD_INT 1
36769: NEG
36770: PUSH
36771: LD_INT 1
36773: NEG
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: PUSH
36779: LD_INT 1
36781: NEG
36782: PUSH
36783: LD_INT 2
36785: NEG
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 1
36793: PUSH
36794: LD_INT 1
36796: NEG
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 2
36804: PUSH
36805: LD_INT 0
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 2
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: PUSH
36822: LD_INT 1
36824: PUSH
36825: LD_INT 2
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 0
36834: PUSH
36835: LD_INT 2
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 1
36844: NEG
36845: PUSH
36846: LD_INT 1
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: LD_INT 2
36855: NEG
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 2
36866: NEG
36867: PUSH
36868: LD_INT 1
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 2
36878: NEG
36879: PUSH
36880: LD_INT 2
36882: NEG
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 2
36890: NEG
36891: PUSH
36892: LD_INT 3
36894: NEG
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 2
36902: PUSH
36903: LD_INT 1
36905: NEG
36906: PUSH
36907: EMPTY
36908: LIST
36909: LIST
36910: PUSH
36911: LD_INT 3
36913: PUSH
36914: LD_INT 1
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 1
36923: PUSH
36924: LD_INT 3
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: PUSH
36931: LD_INT 1
36933: NEG
36934: PUSH
36935: LD_INT 2
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 3
36944: NEG
36945: PUSH
36946: LD_INT 2
36948: NEG
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36979: LD_ADDR_VAR 0 34
36983: PUSH
36984: LD_INT 0
36986: PUSH
36987: LD_INT 0
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: LD_INT 0
36996: PUSH
36997: LD_INT 1
36999: NEG
37000: PUSH
37001: EMPTY
37002: LIST
37003: LIST
37004: PUSH
37005: LD_INT 1
37007: PUSH
37008: LD_INT 0
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 1
37017: PUSH
37018: LD_INT 1
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 0
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: EMPTY
37032: LIST
37033: LIST
37034: PUSH
37035: LD_INT 1
37037: NEG
37038: PUSH
37039: LD_INT 0
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 1
37052: NEG
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 1
37060: NEG
37061: PUSH
37062: LD_INT 2
37064: NEG
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 0
37072: PUSH
37073: LD_INT 2
37075: NEG
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 1
37083: PUSH
37084: LD_INT 1
37086: NEG
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: LD_INT 1
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 2
37104: PUSH
37105: LD_INT 2
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 1
37114: PUSH
37115: LD_INT 2
37117: PUSH
37118: EMPTY
37119: LIST
37120: LIST
37121: PUSH
37122: LD_INT 1
37124: NEG
37125: PUSH
37126: LD_INT 1
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 2
37135: NEG
37136: PUSH
37137: LD_INT 0
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 2
37146: NEG
37147: PUSH
37148: LD_INT 1
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 2
37158: NEG
37159: PUSH
37160: LD_INT 2
37162: NEG
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: LD_INT 1
37170: NEG
37171: PUSH
37172: LD_INT 3
37174: NEG
37175: PUSH
37176: EMPTY
37177: LIST
37178: LIST
37179: PUSH
37180: LD_INT 1
37182: PUSH
37183: LD_INT 2
37185: NEG
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 3
37193: PUSH
37194: LD_INT 2
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: LD_INT 2
37203: PUSH
37204: LD_INT 3
37206: PUSH
37207: EMPTY
37208: LIST
37209: LIST
37210: PUSH
37211: LD_INT 2
37213: NEG
37214: PUSH
37215: LD_INT 1
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 3
37224: NEG
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: LIST
37238: LIST
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: LIST
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: LIST
37257: LIST
37258: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37259: LD_ADDR_VAR 0 35
37263: PUSH
37264: LD_INT 0
37266: PUSH
37267: LD_INT 0
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 0
37276: PUSH
37277: LD_INT 1
37279: NEG
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: LD_INT 0
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 1
37297: PUSH
37298: LD_INT 1
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 0
37307: PUSH
37308: LD_INT 1
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 1
37317: NEG
37318: PUSH
37319: LD_INT 0
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 1
37328: NEG
37329: PUSH
37330: LD_INT 1
37332: NEG
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 2
37340: PUSH
37341: LD_INT 1
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: PUSH
37348: LD_INT 2
37350: NEG
37351: PUSH
37352: LD_INT 1
37354: NEG
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37371: LD_ADDR_VAR 0 36
37375: PUSH
37376: LD_INT 0
37378: PUSH
37379: LD_INT 0
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 0
37388: PUSH
37389: LD_INT 1
37391: NEG
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 1
37399: PUSH
37400: LD_INT 0
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: LD_INT 1
37409: PUSH
37410: LD_INT 1
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: LD_INT 0
37419: PUSH
37420: LD_INT 1
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: LD_INT 1
37429: NEG
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 1
37440: NEG
37441: PUSH
37442: LD_INT 1
37444: NEG
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 1
37452: NEG
37453: PUSH
37454: LD_INT 2
37456: NEG
37457: PUSH
37458: EMPTY
37459: LIST
37460: LIST
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: LD_INT 2
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: LIST
37476: LIST
37477: LIST
37478: LIST
37479: LIST
37480: LIST
37481: LIST
37482: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37483: LD_ADDR_VAR 0 37
37487: PUSH
37488: LD_INT 0
37490: PUSH
37491: LD_INT 0
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 0
37500: PUSH
37501: LD_INT 1
37503: NEG
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 1
37511: PUSH
37512: LD_INT 0
37514: PUSH
37515: EMPTY
37516: LIST
37517: LIST
37518: PUSH
37519: LD_INT 1
37521: PUSH
37522: LD_INT 1
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: LD_INT 1
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 1
37541: NEG
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 1
37552: NEG
37553: PUSH
37554: LD_INT 1
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 1
37564: PUSH
37565: LD_INT 1
37567: NEG
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: LD_INT 1
37575: NEG
37576: PUSH
37577: LD_INT 1
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37595: LD_ADDR_VAR 0 38
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 0
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 1
37668: NEG
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 2
37676: PUSH
37677: LD_INT 1
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 2
37686: NEG
37687: PUSH
37688: LD_INT 1
37690: NEG
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: EMPTY
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
37707: LD_ADDR_VAR 0 39
37711: PUSH
37712: LD_INT 0
37714: PUSH
37715: LD_INT 0
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 0
37724: PUSH
37725: LD_INT 1
37727: NEG
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 1
37735: PUSH
37736: LD_INT 0
37738: PUSH
37739: EMPTY
37740: LIST
37741: LIST
37742: PUSH
37743: LD_INT 1
37745: PUSH
37746: LD_INT 1
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 0
37755: PUSH
37756: LD_INT 1
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 1
37765: NEG
37766: PUSH
37767: LD_INT 0
37769: PUSH
37770: EMPTY
37771: LIST
37772: LIST
37773: PUSH
37774: LD_INT 1
37776: NEG
37777: PUSH
37778: LD_INT 1
37780: NEG
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 1
37788: NEG
37789: PUSH
37790: LD_INT 2
37792: NEG
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 1
37800: PUSH
37801: LD_INT 2
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: PUSH
37808: EMPTY
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
37819: LD_ADDR_VAR 0 40
37823: PUSH
37824: LD_INT 0
37826: PUSH
37827: LD_INT 0
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 0
37836: PUSH
37837: LD_INT 1
37839: NEG
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 1
37847: PUSH
37848: LD_INT 0
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 1
37857: PUSH
37858: LD_INT 1
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 0
37867: PUSH
37868: LD_INT 1
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 1
37877: NEG
37878: PUSH
37879: LD_INT 0
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 1
37888: NEG
37889: PUSH
37890: LD_INT 1
37892: NEG
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 1
37900: PUSH
37901: LD_INT 1
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 1
37911: NEG
37912: PUSH
37913: LD_INT 1
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37931: LD_ADDR_VAR 0 41
37935: PUSH
37936: LD_INT 0
37938: PUSH
37939: LD_INT 0
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 0
37948: PUSH
37949: LD_INT 1
37951: NEG
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 1
37959: PUSH
37960: LD_INT 0
37962: PUSH
37963: EMPTY
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 1
37969: PUSH
37970: LD_INT 1
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: LD_INT 0
37979: PUSH
37980: LD_INT 1
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: PUSH
37987: LD_INT 1
37989: NEG
37990: PUSH
37991: LD_INT 0
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: PUSH
37998: LD_INT 1
38000: NEG
38001: PUSH
38002: LD_INT 1
38004: NEG
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 1
38012: NEG
38013: PUSH
38014: LD_INT 2
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 1
38024: PUSH
38025: LD_INT 1
38027: NEG
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 2
38035: PUSH
38036: LD_INT 0
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 2
38045: PUSH
38046: LD_INT 1
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: LD_INT 2
38055: PUSH
38056: LD_INT 2
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 1
38065: PUSH
38066: LD_INT 2
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: LD_INT 1
38075: NEG
38076: PUSH
38077: LD_INT 1
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 2
38086: NEG
38087: PUSH
38088: LD_INT 0
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 2
38097: NEG
38098: PUSH
38099: LD_INT 1
38101: NEG
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 2
38109: NEG
38110: PUSH
38111: LD_INT 2
38113: NEG
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 2
38121: NEG
38122: PUSH
38123: LD_INT 3
38125: NEG
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 2
38133: PUSH
38134: LD_INT 1
38136: NEG
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 3
38144: PUSH
38145: LD_INT 0
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PUSH
38152: LD_INT 3
38154: PUSH
38155: LD_INT 1
38157: PUSH
38158: EMPTY
38159: LIST
38160: LIST
38161: PUSH
38162: LD_INT 3
38164: PUSH
38165: LD_INT 2
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 3
38174: PUSH
38175: LD_INT 3
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 2
38184: PUSH
38185: LD_INT 3
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 2
38194: NEG
38195: PUSH
38196: LD_INT 1
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 3
38205: NEG
38206: PUSH
38207: LD_INT 0
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 3
38216: NEG
38217: PUSH
38218: LD_INT 1
38220: NEG
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: PUSH
38226: LD_INT 3
38228: NEG
38229: PUSH
38230: LD_INT 2
38232: NEG
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 3
38240: NEG
38241: PUSH
38242: LD_INT 3
38244: NEG
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: LIST
38254: LIST
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38281: LD_ADDR_VAR 0 42
38285: PUSH
38286: LD_INT 0
38288: PUSH
38289: LD_INT 0
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 0
38298: PUSH
38299: LD_INT 1
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 1
38309: PUSH
38310: LD_INT 0
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: LD_INT 1
38322: PUSH
38323: EMPTY
38324: LIST
38325: LIST
38326: PUSH
38327: LD_INT 0
38329: PUSH
38330: LD_INT 1
38332: PUSH
38333: EMPTY
38334: LIST
38335: LIST
38336: PUSH
38337: LD_INT 1
38339: NEG
38340: PUSH
38341: LD_INT 0
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 1
38350: NEG
38351: PUSH
38352: LD_INT 1
38354: NEG
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 1
38362: NEG
38363: PUSH
38364: LD_INT 2
38366: NEG
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 0
38374: PUSH
38375: LD_INT 2
38377: NEG
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 1
38385: PUSH
38386: LD_INT 1
38388: NEG
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 2
38396: PUSH
38397: LD_INT 1
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PUSH
38404: LD_INT 2
38406: PUSH
38407: LD_INT 2
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 1
38416: PUSH
38417: LD_INT 2
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 0
38426: PUSH
38427: LD_INT 2
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 1
38436: NEG
38437: PUSH
38438: LD_INT 1
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: LD_INT 1
38451: NEG
38452: PUSH
38453: EMPTY
38454: LIST
38455: LIST
38456: PUSH
38457: LD_INT 2
38459: NEG
38460: PUSH
38461: LD_INT 2
38463: NEG
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 2
38471: NEG
38472: PUSH
38473: LD_INT 3
38475: NEG
38476: PUSH
38477: EMPTY
38478: LIST
38479: LIST
38480: PUSH
38481: LD_INT 1
38483: NEG
38484: PUSH
38485: LD_INT 3
38487: NEG
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 0
38495: PUSH
38496: LD_INT 3
38498: NEG
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 1
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 3
38517: PUSH
38518: LD_INT 2
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 3
38527: PUSH
38528: LD_INT 3
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 2
38537: PUSH
38538: LD_INT 3
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 1
38547: PUSH
38548: LD_INT 3
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: LD_INT 3
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 1
38567: NEG
38568: PUSH
38569: LD_INT 2
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 3
38578: NEG
38579: PUSH
38580: LD_INT 2
38582: NEG
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 3
38590: NEG
38591: PUSH
38592: LD_INT 3
38594: NEG
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: LIST
38606: LIST
38607: LIST
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: LIST
38630: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38631: LD_ADDR_VAR 0 43
38635: PUSH
38636: LD_INT 0
38638: PUSH
38639: LD_INT 0
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: LD_INT 0
38648: PUSH
38649: LD_INT 1
38651: NEG
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PUSH
38657: LD_INT 1
38659: PUSH
38660: LD_INT 0
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 1
38669: PUSH
38670: LD_INT 1
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 0
38679: PUSH
38680: LD_INT 1
38682: PUSH
38683: EMPTY
38684: LIST
38685: LIST
38686: PUSH
38687: LD_INT 1
38689: NEG
38690: PUSH
38691: LD_INT 0
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 1
38700: NEG
38701: PUSH
38702: LD_INT 1
38704: NEG
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: PUSH
38710: LD_INT 1
38712: NEG
38713: PUSH
38714: LD_INT 2
38716: NEG
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 0
38724: PUSH
38725: LD_INT 2
38727: NEG
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 1
38735: PUSH
38736: LD_INT 1
38738: NEG
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 2
38746: PUSH
38747: LD_INT 0
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 2
38756: PUSH
38757: LD_INT 1
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: PUSH
38764: LD_INT 1
38766: PUSH
38767: LD_INT 2
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 0
38776: PUSH
38777: LD_INT 2
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 1
38786: NEG
38787: PUSH
38788: LD_INT 1
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 2
38797: NEG
38798: PUSH
38799: LD_INT 0
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 2
38808: NEG
38809: PUSH
38810: LD_INT 1
38812: NEG
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 1
38820: NEG
38821: PUSH
38822: LD_INT 3
38824: NEG
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 0
38832: PUSH
38833: LD_INT 3
38835: NEG
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 2
38846: NEG
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: PUSH
38852: LD_INT 2
38854: PUSH
38855: LD_INT 1
38857: NEG
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: PUSH
38863: LD_INT 3
38865: PUSH
38866: LD_INT 0
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 3
38875: PUSH
38876: LD_INT 1
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: LD_INT 1
38885: PUSH
38886: LD_INT 3
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: PUSH
38893: LD_INT 0
38895: PUSH
38896: LD_INT 3
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 1
38905: NEG
38906: PUSH
38907: LD_INT 2
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 2
38916: NEG
38917: PUSH
38918: LD_INT 1
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 3
38927: NEG
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 3
38938: NEG
38939: PUSH
38940: LD_INT 1
38942: NEG
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: LIST
38952: LIST
38953: LIST
38954: LIST
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: LIST
38965: LIST
38966: LIST
38967: LIST
38968: LIST
38969: LIST
38970: LIST
38971: LIST
38972: LIST
38973: LIST
38974: LIST
38975: LIST
38976: LIST
38977: LIST
38978: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38979: LD_ADDR_VAR 0 44
38983: PUSH
38984: LD_INT 0
38986: PUSH
38987: LD_INT 0
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 0
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: NEG
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: LD_INT 1
39048: NEG
39049: PUSH
39050: LD_INT 1
39052: NEG
39053: PUSH
39054: EMPTY
39055: LIST
39056: LIST
39057: PUSH
39058: LD_INT 1
39060: NEG
39061: PUSH
39062: LD_INT 2
39064: NEG
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 1
39072: PUSH
39073: LD_INT 1
39075: NEG
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 2
39083: PUSH
39084: LD_INT 0
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 2
39093: PUSH
39094: LD_INT 1
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 2
39103: PUSH
39104: LD_INT 2
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 1
39113: PUSH
39114: LD_INT 2
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 1
39123: NEG
39124: PUSH
39125: LD_INT 1
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 2
39134: NEG
39135: PUSH
39136: LD_INT 0
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 2
39145: NEG
39146: PUSH
39147: LD_INT 1
39149: NEG
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 2
39157: NEG
39158: PUSH
39159: LD_INT 2
39161: NEG
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 2
39169: NEG
39170: PUSH
39171: LD_INT 3
39173: NEG
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 2
39181: PUSH
39182: LD_INT 1
39184: NEG
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 3
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 3
39202: PUSH
39203: LD_INT 1
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 3
39212: PUSH
39213: LD_INT 2
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 3
39222: PUSH
39223: LD_INT 3
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: LD_INT 2
39232: PUSH
39233: LD_INT 3
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 2
39242: NEG
39243: PUSH
39244: LD_INT 1
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 3
39253: NEG
39254: PUSH
39255: LD_INT 0
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: LD_INT 3
39264: NEG
39265: PUSH
39266: LD_INT 1
39268: NEG
39269: PUSH
39270: EMPTY
39271: LIST
39272: LIST
39273: PUSH
39274: LD_INT 3
39276: NEG
39277: PUSH
39278: LD_INT 2
39280: NEG
39281: PUSH
39282: EMPTY
39283: LIST
39284: LIST
39285: PUSH
39286: LD_INT 3
39288: NEG
39289: PUSH
39290: LD_INT 3
39292: NEG
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: LIST
39302: LIST
39303: LIST
39304: LIST
39305: LIST
39306: LIST
39307: LIST
39308: LIST
39309: LIST
39310: LIST
39311: LIST
39312: LIST
39313: LIST
39314: LIST
39315: LIST
39316: LIST
39317: LIST
39318: LIST
39319: LIST
39320: LIST
39321: LIST
39322: LIST
39323: LIST
39324: LIST
39325: LIST
39326: LIST
39327: LIST
39328: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39329: LD_ADDR_VAR 0 45
39333: PUSH
39334: LD_INT 0
39336: PUSH
39337: LD_INT 0
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 0
39346: PUSH
39347: LD_INT 1
39349: NEG
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 1
39357: PUSH
39358: LD_INT 0
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 1
39367: PUSH
39368: LD_INT 1
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 0
39377: PUSH
39378: LD_INT 1
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 1
39387: NEG
39388: PUSH
39389: LD_INT 0
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: LD_INT 1
39398: NEG
39399: PUSH
39400: LD_INT 1
39402: NEG
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 1
39410: NEG
39411: PUSH
39412: LD_INT 2
39414: NEG
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: PUSH
39420: LD_INT 0
39422: PUSH
39423: LD_INT 2
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 1
39433: PUSH
39434: LD_INT 1
39436: NEG
39437: PUSH
39438: EMPTY
39439: LIST
39440: LIST
39441: PUSH
39442: LD_INT 2
39444: PUSH
39445: LD_INT 1
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 2
39454: PUSH
39455: LD_INT 2
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 1
39464: PUSH
39465: LD_INT 2
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 0
39474: PUSH
39475: LD_INT 2
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 1
39484: NEG
39485: PUSH
39486: LD_INT 1
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 2
39495: NEG
39496: PUSH
39497: LD_INT 1
39499: NEG
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 2
39507: NEG
39508: PUSH
39509: LD_INT 2
39511: NEG
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: LD_INT 2
39519: NEG
39520: PUSH
39521: LD_INT 3
39523: NEG
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: PUSH
39529: LD_INT 1
39531: NEG
39532: PUSH
39533: LD_INT 3
39535: NEG
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 0
39543: PUSH
39544: LD_INT 3
39546: NEG
39547: PUSH
39548: EMPTY
39549: LIST
39550: LIST
39551: PUSH
39552: LD_INT 1
39554: PUSH
39555: LD_INT 2
39557: NEG
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 3
39565: PUSH
39566: LD_INT 2
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 3
39575: PUSH
39576: LD_INT 3
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 2
39585: PUSH
39586: LD_INT 3
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: LD_INT 3
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: LD_INT 3
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 1
39615: NEG
39616: PUSH
39617: LD_INT 2
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 3
39626: NEG
39627: PUSH
39628: LD_INT 2
39630: NEG
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 3
39638: NEG
39639: PUSH
39640: LD_INT 3
39642: NEG
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: LIST
39656: LIST
39657: LIST
39658: LIST
39659: LIST
39660: LIST
39661: LIST
39662: LIST
39663: LIST
39664: LIST
39665: LIST
39666: LIST
39667: LIST
39668: LIST
39669: LIST
39670: LIST
39671: LIST
39672: LIST
39673: LIST
39674: LIST
39675: LIST
39676: LIST
39677: LIST
39678: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39679: LD_ADDR_VAR 0 46
39683: PUSH
39684: LD_INT 0
39686: PUSH
39687: LD_INT 0
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 0
39696: PUSH
39697: LD_INT 1
39699: NEG
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: LD_INT 0
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: LD_INT 1
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 0
39727: PUSH
39728: LD_INT 1
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 1
39737: NEG
39738: PUSH
39739: LD_INT 0
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 1
39748: NEG
39749: PUSH
39750: LD_INT 1
39752: NEG
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 1
39760: NEG
39761: PUSH
39762: LD_INT 2
39764: NEG
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 0
39772: PUSH
39773: LD_INT 2
39775: NEG
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 1
39783: PUSH
39784: LD_INT 1
39786: NEG
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 2
39794: PUSH
39795: LD_INT 0
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 2
39804: PUSH
39805: LD_INT 1
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: PUSH
39815: LD_INT 2
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 0
39824: PUSH
39825: LD_INT 2
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 1
39834: NEG
39835: PUSH
39836: LD_INT 1
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: LD_INT 2
39845: NEG
39846: PUSH
39847: LD_INT 0
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 2
39856: NEG
39857: PUSH
39858: LD_INT 1
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 1
39868: NEG
39869: PUSH
39870: LD_INT 3
39872: NEG
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: PUSH
39878: LD_INT 0
39880: PUSH
39881: LD_INT 3
39883: NEG
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 1
39891: PUSH
39892: LD_INT 2
39894: NEG
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 2
39902: PUSH
39903: LD_INT 1
39905: NEG
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: PUSH
39911: LD_INT 3
39913: PUSH
39914: LD_INT 0
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 3
39923: PUSH
39924: LD_INT 1
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 1
39933: PUSH
39934: LD_INT 3
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 0
39943: PUSH
39944: LD_INT 3
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: PUSH
39951: LD_INT 1
39953: NEG
39954: PUSH
39955: LD_INT 2
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 2
39964: NEG
39965: PUSH
39966: LD_INT 1
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 3
39975: NEG
39976: PUSH
39977: LD_INT 0
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 3
39986: NEG
39987: PUSH
39988: LD_INT 1
39990: NEG
39991: PUSH
39992: EMPTY
39993: LIST
39994: LIST
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: LIST
40011: LIST
40012: LIST
40013: LIST
40014: LIST
40015: LIST
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: LIST
40023: LIST
40024: LIST
40025: LIST
40026: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40027: LD_ADDR_VAR 0 47
40031: PUSH
40032: LD_INT 0
40034: PUSH
40035: LD_INT 0
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 0
40044: PUSH
40045: LD_INT 1
40047: NEG
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PUSH
40053: LD_INT 1
40055: PUSH
40056: LD_INT 0
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 1
40065: PUSH
40066: LD_INT 1
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 0
40075: PUSH
40076: LD_INT 1
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 1
40085: NEG
40086: PUSH
40087: LD_INT 0
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 1
40096: NEG
40097: PUSH
40098: LD_INT 1
40100: NEG
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: PUSH
40106: LD_INT 1
40108: NEG
40109: PUSH
40110: LD_INT 2
40112: NEG
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 0
40120: PUSH
40121: LD_INT 2
40123: NEG
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 1
40131: PUSH
40132: LD_INT 1
40134: NEG
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 2
40142: NEG
40143: PUSH
40144: LD_INT 1
40146: NEG
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 2
40154: NEG
40155: PUSH
40156: LD_INT 2
40158: NEG
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
40178: LD_ADDR_VAR 0 48
40182: PUSH
40183: LD_INT 0
40185: PUSH
40186: LD_INT 0
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: LD_INT 0
40195: PUSH
40196: LD_INT 1
40198: NEG
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 1
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 1
40216: PUSH
40217: LD_INT 1
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 0
40226: PUSH
40227: LD_INT 1
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 1
40236: NEG
40237: PUSH
40238: LD_INT 0
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 1
40247: NEG
40248: PUSH
40249: LD_INT 1
40251: NEG
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 1
40259: NEG
40260: PUSH
40261: LD_INT 2
40263: NEG
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 0
40271: PUSH
40272: LD_INT 2
40274: NEG
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 1
40282: PUSH
40283: LD_INT 1
40285: NEG
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 2
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 2
40303: PUSH
40304: LD_INT 1
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: LIST
40317: LIST
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40325: LD_ADDR_VAR 0 49
40329: PUSH
40330: LD_INT 0
40332: PUSH
40333: LD_INT 0
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 1
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 0
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 1
40383: NEG
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 1
40394: NEG
40395: PUSH
40396: LD_INT 1
40398: NEG
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: PUSH
40407: LD_INT 1
40409: NEG
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 2
40417: PUSH
40418: LD_INT 0
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 2
40427: PUSH
40428: LD_INT 1
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 2
40437: PUSH
40438: LD_INT 2
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 1
40447: PUSH
40448: LD_INT 2
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40469: LD_ADDR_VAR 0 50
40473: PUSH
40474: LD_INT 0
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: LD_INT 1
40489: NEG
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 1
40497: PUSH
40498: LD_INT 0
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 0
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 1
40527: NEG
40528: PUSH
40529: LD_INT 0
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 1
40538: NEG
40539: PUSH
40540: LD_INT 1
40542: NEG
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 2
40550: PUSH
40551: LD_INT 1
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 2
40560: PUSH
40561: LD_INT 2
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: PUSH
40571: LD_INT 2
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: LD_INT 2
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PUSH
40588: LD_INT 1
40590: NEG
40591: PUSH
40592: LD_INT 1
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40613: LD_ADDR_VAR 0 51
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: LD_INT 0
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: LD_INT 1
40633: NEG
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: LD_INT 1
40641: PUSH
40642: LD_INT 0
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 1
40651: PUSH
40652: LD_INT 1
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 0
40661: PUSH
40662: LD_INT 1
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: LD_INT 1
40671: NEG
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: LD_INT 1
40682: NEG
40683: PUSH
40684: LD_INT 1
40686: NEG
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: PUSH
40692: LD_INT 1
40694: PUSH
40695: LD_INT 2
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 0
40704: PUSH
40705: LD_INT 2
40707: PUSH
40708: EMPTY
40709: LIST
40710: LIST
40711: PUSH
40712: LD_INT 1
40714: NEG
40715: PUSH
40716: LD_INT 1
40718: PUSH
40719: EMPTY
40720: LIST
40721: LIST
40722: PUSH
40723: LD_INT 2
40725: NEG
40726: PUSH
40727: LD_INT 0
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 2
40736: NEG
40737: PUSH
40738: LD_INT 1
40740: NEG
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: LIST
40752: LIST
40753: LIST
40754: LIST
40755: LIST
40756: LIST
40757: LIST
40758: LIST
40759: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40760: LD_ADDR_VAR 0 52
40764: PUSH
40765: LD_INT 0
40767: PUSH
40768: LD_INT 0
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: LD_INT 0
40777: PUSH
40778: LD_INT 1
40780: NEG
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 1
40788: PUSH
40789: LD_INT 0
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: LD_INT 1
40798: PUSH
40799: LD_INT 1
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: LD_INT 0
40808: PUSH
40809: LD_INT 1
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 1
40818: NEG
40819: PUSH
40820: LD_INT 0
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 1
40829: NEG
40830: PUSH
40831: LD_INT 1
40833: NEG
40834: PUSH
40835: EMPTY
40836: LIST
40837: LIST
40838: PUSH
40839: LD_INT 1
40841: NEG
40842: PUSH
40843: LD_INT 2
40845: NEG
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PUSH
40851: LD_INT 1
40853: NEG
40854: PUSH
40855: LD_INT 1
40857: PUSH
40858: EMPTY
40859: LIST
40860: LIST
40861: PUSH
40862: LD_INT 2
40864: NEG
40865: PUSH
40866: LD_INT 0
40868: PUSH
40869: EMPTY
40870: LIST
40871: LIST
40872: PUSH
40873: LD_INT 2
40875: NEG
40876: PUSH
40877: LD_INT 1
40879: NEG
40880: PUSH
40881: EMPTY
40882: LIST
40883: LIST
40884: PUSH
40885: LD_INT 2
40887: NEG
40888: PUSH
40889: LD_INT 2
40891: NEG
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40911: LD_ADDR_VAR 0 53
40915: PUSH
40916: LD_INT 0
40918: PUSH
40919: LD_INT 0
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 0
40928: PUSH
40929: LD_INT 1
40931: NEG
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 1
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 1
40949: PUSH
40950: LD_INT 1
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 0
40959: PUSH
40960: LD_INT 1
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: PUSH
40967: LD_INT 1
40969: NEG
40970: PUSH
40971: LD_INT 0
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 1
40980: NEG
40981: PUSH
40982: LD_INT 1
40984: NEG
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: LD_INT 1
40992: NEG
40993: PUSH
40994: LD_INT 2
40996: NEG
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: PUSH
41002: LD_INT 0
41004: PUSH
41005: LD_INT 2
41007: NEG
41008: PUSH
41009: EMPTY
41010: LIST
41011: LIST
41012: PUSH
41013: LD_INT 1
41015: PUSH
41016: LD_INT 1
41018: NEG
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: LD_INT 2
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: LD_INT 2
41036: PUSH
41037: LD_INT 1
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: PUSH
41044: LD_INT 2
41046: PUSH
41047: LD_INT 2
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: PUSH
41054: LD_INT 1
41056: PUSH
41057: LD_INT 2
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: LD_INT 0
41066: PUSH
41067: LD_INT 2
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: LD_INT 1
41076: NEG
41077: PUSH
41078: LD_INT 1
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 2
41087: NEG
41088: PUSH
41089: LD_INT 0
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 2
41098: NEG
41099: PUSH
41100: LD_INT 1
41102: NEG
41103: PUSH
41104: EMPTY
41105: LIST
41106: LIST
41107: PUSH
41108: LD_INT 2
41110: NEG
41111: PUSH
41112: LD_INT 2
41114: NEG
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: LIST
41124: LIST
41125: LIST
41126: LIST
41127: LIST
41128: LIST
41129: LIST
41130: LIST
41131: LIST
41132: LIST
41133: LIST
41134: LIST
41135: LIST
41136: LIST
41137: LIST
41138: LIST
41139: LIST
41140: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41141: LD_ADDR_VAR 0 54
41145: PUSH
41146: LD_INT 0
41148: PUSH
41149: LD_INT 0
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 0
41158: PUSH
41159: LD_INT 1
41161: NEG
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 1
41169: PUSH
41170: LD_INT 0
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 1
41179: PUSH
41180: LD_INT 1
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 0
41189: PUSH
41190: LD_INT 1
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 1
41199: NEG
41200: PUSH
41201: LD_INT 0
41203: PUSH
41204: EMPTY
41205: LIST
41206: LIST
41207: PUSH
41208: LD_INT 1
41210: NEG
41211: PUSH
41212: LD_INT 1
41214: NEG
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PUSH
41220: LD_INT 1
41222: NEG
41223: PUSH
41224: LD_INT 2
41226: NEG
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: PUSH
41232: LD_INT 0
41234: PUSH
41235: LD_INT 2
41237: NEG
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 1
41245: PUSH
41246: LD_INT 1
41248: NEG
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 2
41256: PUSH
41257: LD_INT 0
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 2
41266: PUSH
41267: LD_INT 1
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PUSH
41274: LD_INT 2
41276: PUSH
41277: LD_INT 2
41279: PUSH
41280: EMPTY
41281: LIST
41282: LIST
41283: PUSH
41284: LD_INT 1
41286: PUSH
41287: LD_INT 2
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: LD_INT 0
41296: PUSH
41297: LD_INT 2
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 1
41306: NEG
41307: PUSH
41308: LD_INT 1
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 2
41317: NEG
41318: PUSH
41319: LD_INT 0
41321: PUSH
41322: EMPTY
41323: LIST
41324: LIST
41325: PUSH
41326: LD_INT 2
41328: NEG
41329: PUSH
41330: LD_INT 1
41332: NEG
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 2
41340: NEG
41341: PUSH
41342: LD_INT 2
41344: NEG
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: LIST
41358: LIST
41359: LIST
41360: LIST
41361: LIST
41362: LIST
41363: LIST
41364: LIST
41365: LIST
41366: LIST
41367: LIST
41368: LIST
41369: LIST
41370: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41371: LD_ADDR_VAR 0 55
41375: PUSH
41376: LD_INT 0
41378: PUSH
41379: LD_INT 0
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: PUSH
41386: LD_INT 0
41388: PUSH
41389: LD_INT 1
41391: NEG
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 1
41399: PUSH
41400: LD_INT 0
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 1
41409: PUSH
41410: LD_INT 1
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: LD_INT 0
41419: PUSH
41420: LD_INT 1
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 1
41429: NEG
41430: PUSH
41431: LD_INT 0
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 1
41440: NEG
41441: PUSH
41442: LD_INT 1
41444: NEG
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 1
41452: NEG
41453: PUSH
41454: LD_INT 2
41456: NEG
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 0
41464: PUSH
41465: LD_INT 2
41467: NEG
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 1
41475: PUSH
41476: LD_INT 1
41478: NEG
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 2
41486: PUSH
41487: LD_INT 0
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 2
41496: PUSH
41497: LD_INT 1
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 2
41506: PUSH
41507: LD_INT 2
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 1
41516: PUSH
41517: LD_INT 2
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 0
41526: PUSH
41527: LD_INT 2
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 1
41536: NEG
41537: PUSH
41538: LD_INT 1
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 2
41547: NEG
41548: PUSH
41549: LD_INT 0
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 2
41558: NEG
41559: PUSH
41560: LD_INT 1
41562: NEG
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 2
41570: NEG
41571: PUSH
41572: LD_INT 2
41574: NEG
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41601: LD_ADDR_VAR 0 56
41605: PUSH
41606: LD_INT 0
41608: PUSH
41609: LD_INT 0
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: LD_INT 1
41621: NEG
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 1
41629: PUSH
41630: LD_INT 0
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 1
41639: PUSH
41640: LD_INT 1
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: LD_INT 0
41649: PUSH
41650: LD_INT 1
41652: PUSH
41653: EMPTY
41654: LIST
41655: LIST
41656: PUSH
41657: LD_INT 1
41659: NEG
41660: PUSH
41661: LD_INT 0
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: PUSH
41668: LD_INT 1
41670: NEG
41671: PUSH
41672: LD_INT 1
41674: NEG
41675: PUSH
41676: EMPTY
41677: LIST
41678: LIST
41679: PUSH
41680: LD_INT 1
41682: NEG
41683: PUSH
41684: LD_INT 2
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 0
41694: PUSH
41695: LD_INT 2
41697: NEG
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: PUSH
41706: LD_INT 1
41708: NEG
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 2
41716: PUSH
41717: LD_INT 0
41719: PUSH
41720: EMPTY
41721: LIST
41722: LIST
41723: PUSH
41724: LD_INT 2
41726: PUSH
41727: LD_INT 1
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PUSH
41734: LD_INT 2
41736: PUSH
41737: LD_INT 2
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: PUSH
41744: LD_INT 1
41746: PUSH
41747: LD_INT 2
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 0
41756: PUSH
41757: LD_INT 2
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: LD_INT 1
41766: NEG
41767: PUSH
41768: LD_INT 1
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: LD_INT 2
41777: NEG
41778: PUSH
41779: LD_INT 0
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: LD_INT 2
41788: NEG
41789: PUSH
41790: LD_INT 1
41792: NEG
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 2
41800: NEG
41801: PUSH
41802: LD_INT 2
41804: NEG
41805: PUSH
41806: EMPTY
41807: LIST
41808: LIST
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: LIST
41814: LIST
41815: LIST
41816: LIST
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: LIST
41822: LIST
41823: LIST
41824: LIST
41825: LIST
41826: LIST
41827: LIST
41828: LIST
41829: LIST
41830: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41831: LD_ADDR_VAR 0 57
41835: PUSH
41836: LD_INT 0
41838: PUSH
41839: LD_INT 0
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: PUSH
41846: LD_INT 0
41848: PUSH
41849: LD_INT 1
41851: NEG
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 1
41859: PUSH
41860: LD_INT 0
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 1
41869: PUSH
41870: LD_INT 1
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 0
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 1
41889: NEG
41890: PUSH
41891: LD_INT 0
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: PUSH
41898: LD_INT 1
41900: NEG
41901: PUSH
41902: LD_INT 1
41904: NEG
41905: PUSH
41906: EMPTY
41907: LIST
41908: LIST
41909: PUSH
41910: LD_INT 1
41912: NEG
41913: PUSH
41914: LD_INT 2
41916: NEG
41917: PUSH
41918: EMPTY
41919: LIST
41920: LIST
41921: PUSH
41922: LD_INT 0
41924: PUSH
41925: LD_INT 2
41927: NEG
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 1
41935: PUSH
41936: LD_INT 1
41938: NEG
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 2
41946: PUSH
41947: LD_INT 0
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 2
41956: PUSH
41957: LD_INT 1
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 2
41966: PUSH
41967: LD_INT 2
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PUSH
41974: LD_INT 1
41976: PUSH
41977: LD_INT 2
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: LD_INT 0
41986: PUSH
41987: LD_INT 2
41989: PUSH
41990: EMPTY
41991: LIST
41992: LIST
41993: PUSH
41994: LD_INT 1
41996: NEG
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 2
42007: NEG
42008: PUSH
42009: LD_INT 0
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 2
42018: NEG
42019: PUSH
42020: LD_INT 1
42022: NEG
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 2
42030: NEG
42031: PUSH
42032: LD_INT 2
42034: NEG
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: LIST
42044: LIST
42045: LIST
42046: LIST
42047: LIST
42048: LIST
42049: LIST
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: LIST
42059: LIST
42060: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42061: LD_ADDR_VAR 0 58
42065: PUSH
42066: LD_INT 0
42068: PUSH
42069: LD_INT 0
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 0
42078: PUSH
42079: LD_INT 1
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 1
42089: PUSH
42090: LD_INT 0
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: PUSH
42097: LD_INT 1
42099: PUSH
42100: LD_INT 1
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 0
42109: PUSH
42110: LD_INT 1
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PUSH
42117: LD_INT 1
42119: NEG
42120: PUSH
42121: LD_INT 0
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: PUSH
42128: LD_INT 1
42130: NEG
42131: PUSH
42132: LD_INT 1
42134: NEG
42135: PUSH
42136: EMPTY
42137: LIST
42138: LIST
42139: PUSH
42140: LD_INT 1
42142: NEG
42143: PUSH
42144: LD_INT 2
42146: NEG
42147: PUSH
42148: EMPTY
42149: LIST
42150: LIST
42151: PUSH
42152: LD_INT 0
42154: PUSH
42155: LD_INT 2
42157: NEG
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 1
42165: PUSH
42166: LD_INT 1
42168: NEG
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: PUSH
42174: LD_INT 2
42176: PUSH
42177: LD_INT 0
42179: PUSH
42180: EMPTY
42181: LIST
42182: LIST
42183: PUSH
42184: LD_INT 2
42186: PUSH
42187: LD_INT 1
42189: PUSH
42190: EMPTY
42191: LIST
42192: LIST
42193: PUSH
42194: LD_INT 2
42196: PUSH
42197: LD_INT 2
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: PUSH
42204: LD_INT 1
42206: PUSH
42207: LD_INT 2
42209: PUSH
42210: EMPTY
42211: LIST
42212: LIST
42213: PUSH
42214: LD_INT 0
42216: PUSH
42217: LD_INT 2
42219: PUSH
42220: EMPTY
42221: LIST
42222: LIST
42223: PUSH
42224: LD_INT 1
42226: NEG
42227: PUSH
42228: LD_INT 1
42230: PUSH
42231: EMPTY
42232: LIST
42233: LIST
42234: PUSH
42235: LD_INT 2
42237: NEG
42238: PUSH
42239: LD_INT 0
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: LD_INT 2
42248: NEG
42249: PUSH
42250: LD_INT 1
42252: NEG
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: LD_INT 2
42260: NEG
42261: PUSH
42262: LD_INT 2
42264: NEG
42265: PUSH
42266: EMPTY
42267: LIST
42268: LIST
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: LIST
42274: LIST
42275: LIST
42276: LIST
42277: LIST
42278: LIST
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: LIST
42284: LIST
42285: LIST
42286: LIST
42287: LIST
42288: LIST
42289: LIST
42290: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42291: LD_ADDR_VAR 0 59
42295: PUSH
42296: LD_INT 0
42298: PUSH
42299: LD_INT 0
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PUSH
42306: LD_INT 0
42308: PUSH
42309: LD_INT 1
42311: NEG
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PUSH
42317: LD_INT 1
42319: PUSH
42320: LD_INT 0
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: LD_INT 1
42329: PUSH
42330: LD_INT 1
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 0
42339: PUSH
42340: LD_INT 1
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 1
42349: NEG
42350: PUSH
42351: LD_INT 0
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 1
42360: NEG
42361: PUSH
42362: LD_INT 1
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: LIST
42374: LIST
42375: LIST
42376: LIST
42377: LIST
42378: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42379: LD_ADDR_VAR 0 60
42383: PUSH
42384: LD_INT 0
42386: PUSH
42387: LD_INT 0
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 0
42396: PUSH
42397: LD_INT 1
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 1
42407: PUSH
42408: LD_INT 0
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 1
42417: PUSH
42418: LD_INT 1
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 0
42427: PUSH
42428: LD_INT 1
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 1
42437: NEG
42438: PUSH
42439: LD_INT 0
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 1
42448: NEG
42449: PUSH
42450: LD_INT 1
42452: NEG
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: LIST
42465: LIST
42466: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42467: LD_ADDR_VAR 0 61
42471: PUSH
42472: LD_INT 0
42474: PUSH
42475: LD_INT 0
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: LD_INT 1
42487: NEG
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 1
42495: PUSH
42496: LD_INT 0
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: LD_INT 1
42505: PUSH
42506: LD_INT 1
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PUSH
42513: LD_INT 0
42515: PUSH
42516: LD_INT 1
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 1
42525: NEG
42526: PUSH
42527: LD_INT 0
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 1
42536: NEG
42537: PUSH
42538: LD_INT 1
42540: NEG
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: EMPTY
42547: LIST
42548: LIST
42549: LIST
42550: LIST
42551: LIST
42552: LIST
42553: LIST
42554: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42555: LD_ADDR_VAR 0 62
42559: PUSH
42560: LD_INT 0
42562: PUSH
42563: LD_INT 0
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 0
42572: PUSH
42573: LD_INT 1
42575: NEG
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 1
42583: PUSH
42584: LD_INT 0
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: LD_INT 1
42593: PUSH
42594: LD_INT 1
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: PUSH
42601: LD_INT 0
42603: PUSH
42604: LD_INT 1
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 1
42613: NEG
42614: PUSH
42615: LD_INT 0
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 1
42624: NEG
42625: PUSH
42626: LD_INT 1
42628: NEG
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: LIST
42638: LIST
42639: LIST
42640: LIST
42641: LIST
42642: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42643: LD_ADDR_VAR 0 63
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: LD_INT 0
42653: PUSH
42654: EMPTY
42655: LIST
42656: LIST
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: LD_INT 1
42663: NEG
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: PUSH
42669: LD_INT 1
42671: PUSH
42672: LD_INT 0
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 1
42681: PUSH
42682: LD_INT 1
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 0
42691: PUSH
42692: LD_INT 1
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 1
42701: NEG
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 1
42712: NEG
42713: PUSH
42714: LD_INT 1
42716: NEG
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: EMPTY
42723: LIST
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: LIST
42729: LIST
42730: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42731: LD_ADDR_VAR 0 64
42735: PUSH
42736: LD_INT 0
42738: PUSH
42739: LD_INT 0
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: PUSH
42746: LD_INT 0
42748: PUSH
42749: LD_INT 1
42751: NEG
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 1
42759: PUSH
42760: LD_INT 0
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: PUSH
42767: LD_INT 1
42769: PUSH
42770: LD_INT 1
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PUSH
42777: LD_INT 0
42779: PUSH
42780: LD_INT 1
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 1
42789: NEG
42790: PUSH
42791: LD_INT 0
42793: PUSH
42794: EMPTY
42795: LIST
42796: LIST
42797: PUSH
42798: LD_INT 1
42800: NEG
42801: PUSH
42802: LD_INT 1
42804: NEG
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: PUSH
42810: EMPTY
42811: LIST
42812: LIST
42813: LIST
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: ST_TO_ADDR
// end ; 1 :
42819: GO 48716
42821: LD_INT 1
42823: DOUBLE
42824: EQUAL
42825: IFTRUE 42829
42827: GO 45452
42829: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42830: LD_ADDR_VAR 0 11
42834: PUSH
42835: LD_INT 1
42837: NEG
42838: PUSH
42839: LD_INT 3
42841: NEG
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: LD_INT 0
42849: PUSH
42850: LD_INT 3
42852: NEG
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: LD_INT 1
42860: PUSH
42861: LD_INT 2
42863: NEG
42864: PUSH
42865: EMPTY
42866: LIST
42867: LIST
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: LIST
42873: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42874: LD_ADDR_VAR 0 12
42878: PUSH
42879: LD_INT 2
42881: PUSH
42882: LD_INT 1
42884: NEG
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 3
42892: PUSH
42893: LD_INT 0
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: PUSH
42900: LD_INT 3
42902: PUSH
42903: LD_INT 1
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: PUSH
42910: EMPTY
42911: LIST
42912: LIST
42913: LIST
42914: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42915: LD_ADDR_VAR 0 13
42919: PUSH
42920: LD_INT 3
42922: PUSH
42923: LD_INT 2
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 3
42932: PUSH
42933: LD_INT 3
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: LD_INT 2
42942: PUSH
42943: LD_INT 3
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: LIST
42954: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42955: LD_ADDR_VAR 0 14
42959: PUSH
42960: LD_INT 1
42962: PUSH
42963: LD_INT 3
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PUSH
42970: LD_INT 0
42972: PUSH
42973: LD_INT 3
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: LD_INT 1
42982: NEG
42983: PUSH
42984: LD_INT 2
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: LIST
42995: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42996: LD_ADDR_VAR 0 15
43000: PUSH
43001: LD_INT 2
43003: NEG
43004: PUSH
43005: LD_INT 1
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: PUSH
43012: LD_INT 3
43014: NEG
43015: PUSH
43016: LD_INT 0
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: LD_INT 3
43025: NEG
43026: PUSH
43027: LD_INT 1
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: LIST
43039: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43040: LD_ADDR_VAR 0 16
43044: PUSH
43045: LD_INT 2
43047: NEG
43048: PUSH
43049: LD_INT 3
43051: NEG
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 3
43059: NEG
43060: PUSH
43061: LD_INT 2
43063: NEG
43064: PUSH
43065: EMPTY
43066: LIST
43067: LIST
43068: PUSH
43069: LD_INT 3
43071: NEG
43072: PUSH
43073: LD_INT 3
43075: NEG
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: LIST
43085: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43086: LD_ADDR_VAR 0 17
43090: PUSH
43091: LD_INT 1
43093: NEG
43094: PUSH
43095: LD_INT 3
43097: NEG
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 0
43105: PUSH
43106: LD_INT 3
43108: NEG
43109: PUSH
43110: EMPTY
43111: LIST
43112: LIST
43113: PUSH
43114: LD_INT 1
43116: PUSH
43117: LD_INT 2
43119: NEG
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: PUSH
43125: EMPTY
43126: LIST
43127: LIST
43128: LIST
43129: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43130: LD_ADDR_VAR 0 18
43134: PUSH
43135: LD_INT 2
43137: PUSH
43138: LD_INT 1
43140: NEG
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: LD_INT 3
43148: PUSH
43149: LD_INT 0
43151: PUSH
43152: EMPTY
43153: LIST
43154: LIST
43155: PUSH
43156: LD_INT 3
43158: PUSH
43159: LD_INT 1
43161: PUSH
43162: EMPTY
43163: LIST
43164: LIST
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: LIST
43170: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43171: LD_ADDR_VAR 0 19
43175: PUSH
43176: LD_INT 3
43178: PUSH
43179: LD_INT 2
43181: PUSH
43182: EMPTY
43183: LIST
43184: LIST
43185: PUSH
43186: LD_INT 3
43188: PUSH
43189: LD_INT 3
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: LD_INT 2
43198: PUSH
43199: LD_INT 3
43201: PUSH
43202: EMPTY
43203: LIST
43204: LIST
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: LIST
43210: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43211: LD_ADDR_VAR 0 20
43215: PUSH
43216: LD_INT 1
43218: PUSH
43219: LD_INT 3
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: PUSH
43226: LD_INT 0
43228: PUSH
43229: LD_INT 3
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 1
43238: NEG
43239: PUSH
43240: LD_INT 2
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: LIST
43251: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43252: LD_ADDR_VAR 0 21
43256: PUSH
43257: LD_INT 2
43259: NEG
43260: PUSH
43261: LD_INT 1
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: PUSH
43268: LD_INT 3
43270: NEG
43271: PUSH
43272: LD_INT 0
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 3
43281: NEG
43282: PUSH
43283: LD_INT 1
43285: NEG
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: EMPTY
43292: LIST
43293: LIST
43294: LIST
43295: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43296: LD_ADDR_VAR 0 22
43300: PUSH
43301: LD_INT 2
43303: NEG
43304: PUSH
43305: LD_INT 3
43307: NEG
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: LD_INT 3
43315: NEG
43316: PUSH
43317: LD_INT 2
43319: NEG
43320: PUSH
43321: EMPTY
43322: LIST
43323: LIST
43324: PUSH
43325: LD_INT 3
43327: NEG
43328: PUSH
43329: LD_INT 3
43331: NEG
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: LIST
43341: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43342: LD_ADDR_VAR 0 23
43346: PUSH
43347: LD_INT 0
43349: PUSH
43350: LD_INT 3
43352: NEG
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: PUSH
43358: LD_INT 1
43360: NEG
43361: PUSH
43362: LD_INT 4
43364: NEG
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: LD_INT 1
43372: PUSH
43373: LD_INT 3
43375: NEG
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: LIST
43385: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
43386: LD_ADDR_VAR 0 24
43390: PUSH
43391: LD_INT 3
43393: PUSH
43394: LD_INT 0
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 3
43403: PUSH
43404: LD_INT 1
43406: NEG
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 4
43414: PUSH
43415: LD_INT 1
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: LIST
43426: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
43427: LD_ADDR_VAR 0 25
43431: PUSH
43432: LD_INT 3
43434: PUSH
43435: LD_INT 3
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 4
43444: PUSH
43445: LD_INT 3
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 3
43454: PUSH
43455: LD_INT 4
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: LIST
43466: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
43467: LD_ADDR_VAR 0 26
43471: PUSH
43472: LD_INT 0
43474: PUSH
43475: LD_INT 3
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 1
43484: PUSH
43485: LD_INT 4
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 1
43494: NEG
43495: PUSH
43496: LD_INT 3
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: LIST
43507: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
43508: LD_ADDR_VAR 0 27
43512: PUSH
43513: LD_INT 3
43515: NEG
43516: PUSH
43517: LD_INT 0
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 3
43526: NEG
43527: PUSH
43528: LD_INT 1
43530: PUSH
43531: EMPTY
43532: LIST
43533: LIST
43534: PUSH
43535: LD_INT 4
43537: NEG
43538: PUSH
43539: LD_INT 1
43541: NEG
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: LIST
43551: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
43552: LD_ADDR_VAR 0 28
43556: PUSH
43557: LD_INT 3
43559: NEG
43560: PUSH
43561: LD_INT 3
43563: NEG
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: LD_INT 3
43571: NEG
43572: PUSH
43573: LD_INT 4
43575: NEG
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 4
43583: NEG
43584: PUSH
43585: LD_INT 3
43587: NEG
43588: PUSH
43589: EMPTY
43590: LIST
43591: LIST
43592: PUSH
43593: EMPTY
43594: LIST
43595: LIST
43596: LIST
43597: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
43598: LD_ADDR_VAR 0 29
43602: PUSH
43603: LD_INT 1
43605: NEG
43606: PUSH
43607: LD_INT 3
43609: NEG
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: PUSH
43615: LD_INT 0
43617: PUSH
43618: LD_INT 3
43620: NEG
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: PUSH
43626: LD_INT 1
43628: PUSH
43629: LD_INT 2
43631: NEG
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: LD_INT 1
43639: NEG
43640: PUSH
43641: LD_INT 4
43643: NEG
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: PUSH
43649: LD_INT 0
43651: PUSH
43652: LD_INT 4
43654: NEG
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: PUSH
43660: LD_INT 1
43662: PUSH
43663: LD_INT 3
43665: NEG
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: LD_INT 1
43673: NEG
43674: PUSH
43675: LD_INT 5
43677: NEG
43678: PUSH
43679: EMPTY
43680: LIST
43681: LIST
43682: PUSH
43683: LD_INT 0
43685: PUSH
43686: LD_INT 5
43688: NEG
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 1
43696: PUSH
43697: LD_INT 4
43699: NEG
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: LD_INT 1
43707: NEG
43708: PUSH
43709: LD_INT 6
43711: NEG
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 0
43719: PUSH
43720: LD_INT 6
43722: NEG
43723: PUSH
43724: EMPTY
43725: LIST
43726: LIST
43727: PUSH
43728: LD_INT 1
43730: PUSH
43731: LD_INT 5
43733: NEG
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: LIST
43747: LIST
43748: LIST
43749: LIST
43750: LIST
43751: LIST
43752: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
43753: LD_ADDR_VAR 0 30
43757: PUSH
43758: LD_INT 2
43760: PUSH
43761: LD_INT 1
43763: NEG
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 3
43771: PUSH
43772: LD_INT 0
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 3
43781: PUSH
43782: LD_INT 1
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 3
43791: PUSH
43792: LD_INT 1
43794: NEG
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: PUSH
43800: LD_INT 4
43802: PUSH
43803: LD_INT 0
43805: PUSH
43806: EMPTY
43807: LIST
43808: LIST
43809: PUSH
43810: LD_INT 4
43812: PUSH
43813: LD_INT 1
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 4
43822: PUSH
43823: LD_INT 1
43825: NEG
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 5
43833: PUSH
43834: LD_INT 0
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 5
43843: PUSH
43844: LD_INT 1
43846: PUSH
43847: EMPTY
43848: LIST
43849: LIST
43850: PUSH
43851: LD_INT 5
43853: PUSH
43854: LD_INT 1
43856: NEG
43857: PUSH
43858: EMPTY
43859: LIST
43860: LIST
43861: PUSH
43862: LD_INT 6
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: EMPTY
43869: LIST
43870: LIST
43871: PUSH
43872: LD_INT 6
43874: PUSH
43875: LD_INT 1
43877: PUSH
43878: EMPTY
43879: LIST
43880: LIST
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: LIST
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
43896: LD_ADDR_VAR 0 31
43900: PUSH
43901: LD_INT 3
43903: PUSH
43904: LD_INT 2
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: LD_INT 3
43913: PUSH
43914: LD_INT 3
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: LD_INT 2
43923: PUSH
43924: LD_INT 3
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: PUSH
43931: LD_INT 4
43933: PUSH
43934: LD_INT 3
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 4
43943: PUSH
43944: LD_INT 4
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 3
43953: PUSH
43954: LD_INT 4
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 5
43963: PUSH
43964: LD_INT 4
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: LD_INT 5
43973: PUSH
43974: LD_INT 5
43976: PUSH
43977: EMPTY
43978: LIST
43979: LIST
43980: PUSH
43981: LD_INT 4
43983: PUSH
43984: LD_INT 5
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 6
43993: PUSH
43994: LD_INT 5
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 6
44003: PUSH
44004: LD_INT 6
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 5
44013: PUSH
44014: LD_INT 6
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: LIST
44025: LIST
44026: LIST
44027: LIST
44028: LIST
44029: LIST
44030: LIST
44031: LIST
44032: LIST
44033: LIST
44034: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
44035: LD_ADDR_VAR 0 32
44039: PUSH
44040: LD_INT 1
44042: PUSH
44043: LD_INT 3
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 0
44052: PUSH
44053: LD_INT 3
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PUSH
44060: LD_INT 1
44062: NEG
44063: PUSH
44064: LD_INT 2
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 1
44073: PUSH
44074: LD_INT 4
44076: PUSH
44077: EMPTY
44078: LIST
44079: LIST
44080: PUSH
44081: LD_INT 0
44083: PUSH
44084: LD_INT 4
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 1
44093: NEG
44094: PUSH
44095: LD_INT 3
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 1
44104: PUSH
44105: LD_INT 5
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 0
44114: PUSH
44115: LD_INT 5
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 1
44124: NEG
44125: PUSH
44126: LD_INT 4
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: LD_INT 1
44135: PUSH
44136: LD_INT 6
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 0
44145: PUSH
44146: LD_INT 6
44148: PUSH
44149: EMPTY
44150: LIST
44151: LIST
44152: PUSH
44153: LD_INT 1
44155: NEG
44156: PUSH
44157: LD_INT 5
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: LIST
44168: LIST
44169: LIST
44170: LIST
44171: LIST
44172: LIST
44173: LIST
44174: LIST
44175: LIST
44176: LIST
44177: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
44178: LD_ADDR_VAR 0 33
44182: PUSH
44183: LD_INT 2
44185: NEG
44186: PUSH
44187: LD_INT 1
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: PUSH
44194: LD_INT 3
44196: NEG
44197: PUSH
44198: LD_INT 0
44200: PUSH
44201: EMPTY
44202: LIST
44203: LIST
44204: PUSH
44205: LD_INT 3
44207: NEG
44208: PUSH
44209: LD_INT 1
44211: NEG
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: PUSH
44217: LD_INT 3
44219: NEG
44220: PUSH
44221: LD_INT 1
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: PUSH
44228: LD_INT 4
44230: NEG
44231: PUSH
44232: LD_INT 0
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: PUSH
44239: LD_INT 4
44241: NEG
44242: PUSH
44243: LD_INT 1
44245: NEG
44246: PUSH
44247: EMPTY
44248: LIST
44249: LIST
44250: PUSH
44251: LD_INT 4
44253: NEG
44254: PUSH
44255: LD_INT 1
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 5
44264: NEG
44265: PUSH
44266: LD_INT 0
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: PUSH
44273: LD_INT 5
44275: NEG
44276: PUSH
44277: LD_INT 1
44279: NEG
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: PUSH
44285: LD_INT 5
44287: NEG
44288: PUSH
44289: LD_INT 1
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 6
44298: NEG
44299: PUSH
44300: LD_INT 0
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 6
44309: NEG
44310: PUSH
44311: LD_INT 1
44313: NEG
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: LIST
44327: LIST
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44333: LD_ADDR_VAR 0 34
44337: PUSH
44338: LD_INT 2
44340: NEG
44341: PUSH
44342: LD_INT 3
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 3
44352: NEG
44353: PUSH
44354: LD_INT 2
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 3
44364: NEG
44365: PUSH
44366: LD_INT 3
44368: NEG
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 3
44376: NEG
44377: PUSH
44378: LD_INT 4
44380: NEG
44381: PUSH
44382: EMPTY
44383: LIST
44384: LIST
44385: PUSH
44386: LD_INT 4
44388: NEG
44389: PUSH
44390: LD_INT 3
44392: NEG
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: PUSH
44398: LD_INT 4
44400: NEG
44401: PUSH
44402: LD_INT 4
44404: NEG
44405: PUSH
44406: EMPTY
44407: LIST
44408: LIST
44409: PUSH
44410: LD_INT 4
44412: NEG
44413: PUSH
44414: LD_INT 5
44416: NEG
44417: PUSH
44418: EMPTY
44419: LIST
44420: LIST
44421: PUSH
44422: LD_INT 5
44424: NEG
44425: PUSH
44426: LD_INT 4
44428: NEG
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 5
44436: NEG
44437: PUSH
44438: LD_INT 5
44440: NEG
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: PUSH
44446: LD_INT 5
44448: NEG
44449: PUSH
44450: LD_INT 6
44452: NEG
44453: PUSH
44454: EMPTY
44455: LIST
44456: LIST
44457: PUSH
44458: LD_INT 6
44460: NEG
44461: PUSH
44462: LD_INT 5
44464: NEG
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: LD_INT 6
44472: NEG
44473: PUSH
44474: LD_INT 6
44476: NEG
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: LIST
44486: LIST
44487: LIST
44488: LIST
44489: LIST
44490: LIST
44491: LIST
44492: LIST
44493: LIST
44494: LIST
44495: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
44496: LD_ADDR_VAR 0 41
44500: PUSH
44501: LD_INT 0
44503: PUSH
44504: LD_INT 2
44506: NEG
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PUSH
44512: LD_INT 1
44514: NEG
44515: PUSH
44516: LD_INT 3
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 1
44526: PUSH
44527: LD_INT 2
44529: NEG
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: LIST
44539: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
44540: LD_ADDR_VAR 0 42
44544: PUSH
44545: LD_INT 2
44547: PUSH
44548: LD_INT 0
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: LD_INT 2
44557: PUSH
44558: LD_INT 1
44560: NEG
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 3
44568: PUSH
44569: LD_INT 1
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: LIST
44580: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
44581: LD_ADDR_VAR 0 43
44585: PUSH
44586: LD_INT 2
44588: PUSH
44589: LD_INT 2
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: PUSH
44596: LD_INT 3
44598: PUSH
44599: LD_INT 2
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 2
44608: PUSH
44609: LD_INT 3
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: EMPTY
44617: LIST
44618: LIST
44619: LIST
44620: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
44621: LD_ADDR_VAR 0 44
44625: PUSH
44626: LD_INT 0
44628: PUSH
44629: LD_INT 2
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 1
44638: PUSH
44639: LD_INT 3
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: LD_INT 1
44648: NEG
44649: PUSH
44650: LD_INT 2
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: LIST
44661: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
44662: LD_ADDR_VAR 0 45
44666: PUSH
44667: LD_INT 2
44669: NEG
44670: PUSH
44671: LD_INT 0
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: LD_INT 2
44680: NEG
44681: PUSH
44682: LD_INT 1
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: LD_INT 3
44691: NEG
44692: PUSH
44693: LD_INT 1
44695: NEG
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: PUSH
44701: EMPTY
44702: LIST
44703: LIST
44704: LIST
44705: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
44706: LD_ADDR_VAR 0 46
44710: PUSH
44711: LD_INT 2
44713: NEG
44714: PUSH
44715: LD_INT 2
44717: NEG
44718: PUSH
44719: EMPTY
44720: LIST
44721: LIST
44722: PUSH
44723: LD_INT 2
44725: NEG
44726: PUSH
44727: LD_INT 3
44729: NEG
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 3
44737: NEG
44738: PUSH
44739: LD_INT 2
44741: NEG
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: LIST
44751: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
44752: LD_ADDR_VAR 0 47
44756: PUSH
44757: LD_INT 2
44759: NEG
44760: PUSH
44761: LD_INT 3
44763: NEG
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 1
44771: NEG
44772: PUSH
44773: LD_INT 3
44775: NEG
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: EMPTY
44782: LIST
44783: LIST
44784: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
44785: LD_ADDR_VAR 0 48
44789: PUSH
44790: LD_INT 1
44792: PUSH
44793: LD_INT 2
44795: NEG
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 2
44803: PUSH
44804: LD_INT 1
44806: NEG
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
44816: LD_ADDR_VAR 0 49
44820: PUSH
44821: LD_INT 3
44823: PUSH
44824: LD_INT 1
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 3
44833: PUSH
44834: LD_INT 2
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
44845: LD_ADDR_VAR 0 50
44849: PUSH
44850: LD_INT 2
44852: PUSH
44853: LD_INT 3
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 1
44862: PUSH
44863: LD_INT 3
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: EMPTY
44871: LIST
44872: LIST
44873: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
44874: LD_ADDR_VAR 0 51
44878: PUSH
44879: LD_INT 1
44881: NEG
44882: PUSH
44883: LD_INT 2
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 2
44892: NEG
44893: PUSH
44894: LD_INT 1
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
44905: LD_ADDR_VAR 0 52
44909: PUSH
44910: LD_INT 3
44912: NEG
44913: PUSH
44914: LD_INT 1
44916: NEG
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 3
44924: NEG
44925: PUSH
44926: LD_INT 2
44928: NEG
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: EMPTY
44935: LIST
44936: LIST
44937: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44938: LD_ADDR_VAR 0 53
44942: PUSH
44943: LD_INT 1
44945: NEG
44946: PUSH
44947: LD_INT 3
44949: NEG
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 0
44957: PUSH
44958: LD_INT 3
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 1
44968: PUSH
44969: LD_INT 2
44971: NEG
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: LIST
44981: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44982: LD_ADDR_VAR 0 54
44986: PUSH
44987: LD_INT 2
44989: PUSH
44990: LD_INT 1
44992: NEG
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: PUSH
44998: LD_INT 3
45000: PUSH
45001: LD_INT 0
45003: PUSH
45004: EMPTY
45005: LIST
45006: LIST
45007: PUSH
45008: LD_INT 3
45010: PUSH
45011: LD_INT 1
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: LIST
45022: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45023: LD_ADDR_VAR 0 55
45027: PUSH
45028: LD_INT 3
45030: PUSH
45031: LD_INT 2
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 3
45040: PUSH
45041: LD_INT 3
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: PUSH
45048: LD_INT 2
45050: PUSH
45051: LD_INT 3
45053: PUSH
45054: EMPTY
45055: LIST
45056: LIST
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: LIST
45062: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45063: LD_ADDR_VAR 0 56
45067: PUSH
45068: LD_INT 1
45070: PUSH
45071: LD_INT 3
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: PUSH
45078: LD_INT 0
45080: PUSH
45081: LD_INT 3
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: LD_INT 1
45090: NEG
45091: PUSH
45092: LD_INT 2
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: LIST
45103: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45104: LD_ADDR_VAR 0 57
45108: PUSH
45109: LD_INT 2
45111: NEG
45112: PUSH
45113: LD_INT 1
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: LD_INT 3
45122: NEG
45123: PUSH
45124: LD_INT 0
45126: PUSH
45127: EMPTY
45128: LIST
45129: LIST
45130: PUSH
45131: LD_INT 3
45133: NEG
45134: PUSH
45135: LD_INT 1
45137: NEG
45138: PUSH
45139: EMPTY
45140: LIST
45141: LIST
45142: PUSH
45143: EMPTY
45144: LIST
45145: LIST
45146: LIST
45147: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45148: LD_ADDR_VAR 0 58
45152: PUSH
45153: LD_INT 2
45155: NEG
45156: PUSH
45157: LD_INT 3
45159: NEG
45160: PUSH
45161: EMPTY
45162: LIST
45163: LIST
45164: PUSH
45165: LD_INT 3
45167: NEG
45168: PUSH
45169: LD_INT 2
45171: NEG
45172: PUSH
45173: EMPTY
45174: LIST
45175: LIST
45176: PUSH
45177: LD_INT 3
45179: NEG
45180: PUSH
45181: LD_INT 3
45183: NEG
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: EMPTY
45190: LIST
45191: LIST
45192: LIST
45193: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
45194: LD_ADDR_VAR 0 59
45198: PUSH
45199: LD_INT 1
45201: NEG
45202: PUSH
45203: LD_INT 2
45205: NEG
45206: PUSH
45207: EMPTY
45208: LIST
45209: LIST
45210: PUSH
45211: LD_INT 0
45213: PUSH
45214: LD_INT 2
45216: NEG
45217: PUSH
45218: EMPTY
45219: LIST
45220: LIST
45221: PUSH
45222: LD_INT 1
45224: PUSH
45225: LD_INT 1
45227: NEG
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: LIST
45237: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
45238: LD_ADDR_VAR 0 60
45242: PUSH
45243: LD_INT 1
45245: PUSH
45246: LD_INT 1
45248: NEG
45249: PUSH
45250: EMPTY
45251: LIST
45252: LIST
45253: PUSH
45254: LD_INT 2
45256: PUSH
45257: LD_INT 0
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 2
45266: PUSH
45267: LD_INT 1
45269: PUSH
45270: EMPTY
45271: LIST
45272: LIST
45273: PUSH
45274: EMPTY
45275: LIST
45276: LIST
45277: LIST
45278: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
45279: LD_ADDR_VAR 0 61
45283: PUSH
45284: LD_INT 2
45286: PUSH
45287: LD_INT 1
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: LD_INT 2
45296: PUSH
45297: LD_INT 2
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PUSH
45304: LD_INT 1
45306: PUSH
45307: LD_INT 2
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: EMPTY
45315: LIST
45316: LIST
45317: LIST
45318: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45319: LD_ADDR_VAR 0 62
45323: PUSH
45324: LD_INT 1
45326: PUSH
45327: LD_INT 2
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: PUSH
45334: LD_INT 0
45336: PUSH
45337: LD_INT 2
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 1
45346: NEG
45347: PUSH
45348: LD_INT 1
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: LIST
45359: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45360: LD_ADDR_VAR 0 63
45364: PUSH
45365: LD_INT 1
45367: NEG
45368: PUSH
45369: LD_INT 1
45371: PUSH
45372: EMPTY
45373: LIST
45374: LIST
45375: PUSH
45376: LD_INT 2
45378: NEG
45379: PUSH
45380: LD_INT 0
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 2
45389: NEG
45390: PUSH
45391: LD_INT 1
45393: NEG
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PUSH
45399: EMPTY
45400: LIST
45401: LIST
45402: LIST
45403: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45404: LD_ADDR_VAR 0 64
45408: PUSH
45409: LD_INT 1
45411: NEG
45412: PUSH
45413: LD_INT 2
45415: NEG
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 2
45423: NEG
45424: PUSH
45425: LD_INT 1
45427: NEG
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 2
45435: NEG
45436: PUSH
45437: LD_INT 2
45439: NEG
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: LIST
45449: ST_TO_ADDR
// end ; 2 :
45450: GO 48716
45452: LD_INT 2
45454: DOUBLE
45455: EQUAL
45456: IFTRUE 45460
45458: GO 48715
45460: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
45461: LD_ADDR_VAR 0 29
45465: PUSH
45466: LD_INT 4
45468: PUSH
45469: LD_INT 0
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: LD_INT 4
45478: PUSH
45479: LD_INT 1
45481: NEG
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: PUSH
45487: LD_INT 5
45489: PUSH
45490: LD_INT 0
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: PUSH
45497: LD_INT 5
45499: PUSH
45500: LD_INT 1
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PUSH
45507: LD_INT 4
45509: PUSH
45510: LD_INT 1
45512: PUSH
45513: EMPTY
45514: LIST
45515: LIST
45516: PUSH
45517: LD_INT 3
45519: PUSH
45520: LD_INT 0
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: PUSH
45527: LD_INT 3
45529: PUSH
45530: LD_INT 1
45532: NEG
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: PUSH
45538: LD_INT 3
45540: PUSH
45541: LD_INT 2
45543: NEG
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 5
45551: PUSH
45552: LD_INT 2
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 3
45561: PUSH
45562: LD_INT 3
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: PUSH
45569: LD_INT 3
45571: PUSH
45572: LD_INT 2
45574: PUSH
45575: EMPTY
45576: LIST
45577: LIST
45578: PUSH
45579: LD_INT 4
45581: PUSH
45582: LD_INT 3
45584: PUSH
45585: EMPTY
45586: LIST
45587: LIST
45588: PUSH
45589: LD_INT 4
45591: PUSH
45592: LD_INT 4
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 3
45601: PUSH
45602: LD_INT 4
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: PUSH
45609: LD_INT 2
45611: PUSH
45612: LD_INT 3
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 2
45621: PUSH
45622: LD_INT 2
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: PUSH
45629: LD_INT 4
45631: PUSH
45632: LD_INT 2
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: PUSH
45639: LD_INT 2
45641: PUSH
45642: LD_INT 4
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 0
45651: PUSH
45652: LD_INT 4
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 0
45661: PUSH
45662: LD_INT 3
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 1
45671: PUSH
45672: LD_INT 4
45674: PUSH
45675: EMPTY
45676: LIST
45677: LIST
45678: PUSH
45679: LD_INT 1
45681: PUSH
45682: LD_INT 5
45684: PUSH
45685: EMPTY
45686: LIST
45687: LIST
45688: PUSH
45689: LD_INT 0
45691: PUSH
45692: LD_INT 5
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: PUSH
45699: LD_INT 1
45701: NEG
45702: PUSH
45703: LD_INT 4
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: PUSH
45710: LD_INT 1
45712: NEG
45713: PUSH
45714: LD_INT 3
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 2
45723: PUSH
45724: LD_INT 5
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 2
45733: NEG
45734: PUSH
45735: LD_INT 3
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 3
45744: NEG
45745: PUSH
45746: LD_INT 0
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: PUSH
45753: LD_INT 3
45755: NEG
45756: PUSH
45757: LD_INT 1
45759: NEG
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PUSH
45765: LD_INT 2
45767: NEG
45768: PUSH
45769: LD_INT 0
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 2
45778: NEG
45779: PUSH
45780: LD_INT 1
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 3
45789: NEG
45790: PUSH
45791: LD_INT 1
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: PUSH
45798: LD_INT 4
45800: NEG
45801: PUSH
45802: LD_INT 0
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: PUSH
45809: LD_INT 4
45811: NEG
45812: PUSH
45813: LD_INT 1
45815: NEG
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 4
45823: NEG
45824: PUSH
45825: LD_INT 2
45827: NEG
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: PUSH
45833: LD_INT 2
45835: NEG
45836: PUSH
45837: LD_INT 2
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 4
45846: NEG
45847: PUSH
45848: LD_INT 4
45850: NEG
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 4
45858: NEG
45859: PUSH
45860: LD_INT 5
45862: NEG
45863: PUSH
45864: EMPTY
45865: LIST
45866: LIST
45867: PUSH
45868: LD_INT 3
45870: NEG
45871: PUSH
45872: LD_INT 4
45874: NEG
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: PUSH
45880: LD_INT 3
45882: NEG
45883: PUSH
45884: LD_INT 3
45886: NEG
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: PUSH
45892: LD_INT 4
45894: NEG
45895: PUSH
45896: LD_INT 3
45898: NEG
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 5
45906: NEG
45907: PUSH
45908: LD_INT 4
45910: NEG
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 5
45918: NEG
45919: PUSH
45920: LD_INT 5
45922: NEG
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: LD_INT 3
45930: NEG
45931: PUSH
45932: LD_INT 5
45934: NEG
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: PUSH
45940: LD_INT 5
45942: NEG
45943: PUSH
45944: LD_INT 3
45946: NEG
45947: PUSH
45948: EMPTY
45949: LIST
45950: LIST
45951: PUSH
45952: EMPTY
45953: LIST
45954: LIST
45955: LIST
45956: LIST
45957: LIST
45958: LIST
45959: LIST
45960: LIST
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
45999: LD_ADDR_VAR 0 30
46003: PUSH
46004: LD_INT 4
46006: PUSH
46007: LD_INT 4
46009: PUSH
46010: EMPTY
46011: LIST
46012: LIST
46013: PUSH
46014: LD_INT 4
46016: PUSH
46017: LD_INT 3
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: PUSH
46024: LD_INT 5
46026: PUSH
46027: LD_INT 4
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: PUSH
46034: LD_INT 5
46036: PUSH
46037: LD_INT 5
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: PUSH
46044: LD_INT 4
46046: PUSH
46047: LD_INT 5
46049: PUSH
46050: EMPTY
46051: LIST
46052: LIST
46053: PUSH
46054: LD_INT 3
46056: PUSH
46057: LD_INT 4
46059: PUSH
46060: EMPTY
46061: LIST
46062: LIST
46063: PUSH
46064: LD_INT 3
46066: PUSH
46067: LD_INT 3
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: LD_INT 5
46076: PUSH
46077: LD_INT 3
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: PUSH
46084: LD_INT 3
46086: PUSH
46087: LD_INT 5
46089: PUSH
46090: EMPTY
46091: LIST
46092: LIST
46093: PUSH
46094: LD_INT 0
46096: PUSH
46097: LD_INT 3
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: LD_INT 0
46106: PUSH
46107: LD_INT 2
46109: PUSH
46110: EMPTY
46111: LIST
46112: LIST
46113: PUSH
46114: LD_INT 1
46116: PUSH
46117: LD_INT 3
46119: PUSH
46120: EMPTY
46121: LIST
46122: LIST
46123: PUSH
46124: LD_INT 1
46126: PUSH
46127: LD_INT 4
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: LD_INT 0
46136: PUSH
46137: LD_INT 4
46139: PUSH
46140: EMPTY
46141: LIST
46142: LIST
46143: PUSH
46144: LD_INT 1
46146: NEG
46147: PUSH
46148: LD_INT 3
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: PUSH
46155: LD_INT 1
46157: NEG
46158: PUSH
46159: LD_INT 2
46161: PUSH
46162: EMPTY
46163: LIST
46164: LIST
46165: PUSH
46166: LD_INT 2
46168: PUSH
46169: LD_INT 4
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: LD_INT 2
46178: NEG
46179: PUSH
46180: LD_INT 2
46182: PUSH
46183: EMPTY
46184: LIST
46185: LIST
46186: PUSH
46187: LD_INT 4
46189: NEG
46190: PUSH
46191: LD_INT 0
46193: PUSH
46194: EMPTY
46195: LIST
46196: LIST
46197: PUSH
46198: LD_INT 4
46200: NEG
46201: PUSH
46202: LD_INT 1
46204: NEG
46205: PUSH
46206: EMPTY
46207: LIST
46208: LIST
46209: PUSH
46210: LD_INT 3
46212: NEG
46213: PUSH
46214: LD_INT 0
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: PUSH
46221: LD_INT 3
46223: NEG
46224: PUSH
46225: LD_INT 1
46227: PUSH
46228: EMPTY
46229: LIST
46230: LIST
46231: PUSH
46232: LD_INT 4
46234: NEG
46235: PUSH
46236: LD_INT 1
46238: PUSH
46239: EMPTY
46240: LIST
46241: LIST
46242: PUSH
46243: LD_INT 5
46245: NEG
46246: PUSH
46247: LD_INT 0
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 5
46256: NEG
46257: PUSH
46258: LD_INT 1
46260: NEG
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 5
46268: NEG
46269: PUSH
46270: LD_INT 2
46272: NEG
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 3
46280: NEG
46281: PUSH
46282: LD_INT 2
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: LD_INT 3
46291: NEG
46292: PUSH
46293: LD_INT 3
46295: NEG
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 3
46303: NEG
46304: PUSH
46305: LD_INT 4
46307: NEG
46308: PUSH
46309: EMPTY
46310: LIST
46311: LIST
46312: PUSH
46313: LD_INT 2
46315: NEG
46316: PUSH
46317: LD_INT 3
46319: NEG
46320: PUSH
46321: EMPTY
46322: LIST
46323: LIST
46324: PUSH
46325: LD_INT 2
46327: NEG
46328: PUSH
46329: LD_INT 2
46331: NEG
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: PUSH
46337: LD_INT 3
46339: NEG
46340: PUSH
46341: LD_INT 2
46343: NEG
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: PUSH
46349: LD_INT 4
46351: NEG
46352: PUSH
46353: LD_INT 3
46355: NEG
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 4
46363: NEG
46364: PUSH
46365: LD_INT 4
46367: NEG
46368: PUSH
46369: EMPTY
46370: LIST
46371: LIST
46372: PUSH
46373: LD_INT 2
46375: NEG
46376: PUSH
46377: LD_INT 4
46379: NEG
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: PUSH
46385: LD_INT 4
46387: NEG
46388: PUSH
46389: LD_INT 2
46391: NEG
46392: PUSH
46393: EMPTY
46394: LIST
46395: LIST
46396: PUSH
46397: LD_INT 0
46399: PUSH
46400: LD_INT 4
46402: NEG
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 0
46410: PUSH
46411: LD_INT 5
46413: NEG
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 1
46421: PUSH
46422: LD_INT 4
46424: NEG
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 1
46432: PUSH
46433: LD_INT 3
46435: NEG
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 0
46443: PUSH
46444: LD_INT 3
46446: NEG
46447: PUSH
46448: EMPTY
46449: LIST
46450: LIST
46451: PUSH
46452: LD_INT 1
46454: NEG
46455: PUSH
46456: LD_INT 4
46458: NEG
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: PUSH
46464: LD_INT 1
46466: NEG
46467: PUSH
46468: LD_INT 5
46470: NEG
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: PUSH
46476: LD_INT 2
46478: PUSH
46479: LD_INT 3
46481: NEG
46482: PUSH
46483: EMPTY
46484: LIST
46485: LIST
46486: PUSH
46487: LD_INT 2
46489: NEG
46490: PUSH
46491: LD_INT 5
46493: NEG
46494: PUSH
46495: EMPTY
46496: LIST
46497: LIST
46498: PUSH
46499: EMPTY
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: LIST
46507: LIST
46508: LIST
46509: LIST
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: LIST
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
46546: LD_ADDR_VAR 0 31
46550: PUSH
46551: LD_INT 0
46553: PUSH
46554: LD_INT 4
46556: PUSH
46557: EMPTY
46558: LIST
46559: LIST
46560: PUSH
46561: LD_INT 0
46563: PUSH
46564: LD_INT 3
46566: PUSH
46567: EMPTY
46568: LIST
46569: LIST
46570: PUSH
46571: LD_INT 1
46573: PUSH
46574: LD_INT 4
46576: PUSH
46577: EMPTY
46578: LIST
46579: LIST
46580: PUSH
46581: LD_INT 1
46583: PUSH
46584: LD_INT 5
46586: PUSH
46587: EMPTY
46588: LIST
46589: LIST
46590: PUSH
46591: LD_INT 0
46593: PUSH
46594: LD_INT 5
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: PUSH
46601: LD_INT 1
46603: NEG
46604: PUSH
46605: LD_INT 4
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: PUSH
46612: LD_INT 1
46614: NEG
46615: PUSH
46616: LD_INT 3
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: PUSH
46623: LD_INT 2
46625: PUSH
46626: LD_INT 5
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 2
46635: NEG
46636: PUSH
46637: LD_INT 3
46639: PUSH
46640: EMPTY
46641: LIST
46642: LIST
46643: PUSH
46644: LD_INT 3
46646: NEG
46647: PUSH
46648: LD_INT 0
46650: PUSH
46651: EMPTY
46652: LIST
46653: LIST
46654: PUSH
46655: LD_INT 3
46657: NEG
46658: PUSH
46659: LD_INT 1
46661: NEG
46662: PUSH
46663: EMPTY
46664: LIST
46665: LIST
46666: PUSH
46667: LD_INT 2
46669: NEG
46670: PUSH
46671: LD_INT 0
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 2
46680: NEG
46681: PUSH
46682: LD_INT 1
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 3
46691: NEG
46692: PUSH
46693: LD_INT 1
46695: PUSH
46696: EMPTY
46697: LIST
46698: LIST
46699: PUSH
46700: LD_INT 4
46702: NEG
46703: PUSH
46704: LD_INT 0
46706: PUSH
46707: EMPTY
46708: LIST
46709: LIST
46710: PUSH
46711: LD_INT 4
46713: NEG
46714: PUSH
46715: LD_INT 1
46717: NEG
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: PUSH
46723: LD_INT 4
46725: NEG
46726: PUSH
46727: LD_INT 2
46729: NEG
46730: PUSH
46731: EMPTY
46732: LIST
46733: LIST
46734: PUSH
46735: LD_INT 2
46737: NEG
46738: PUSH
46739: LD_INT 2
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: PUSH
46746: LD_INT 4
46748: NEG
46749: PUSH
46750: LD_INT 4
46752: NEG
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: PUSH
46758: LD_INT 4
46760: NEG
46761: PUSH
46762: LD_INT 5
46764: NEG
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 3
46772: NEG
46773: PUSH
46774: LD_INT 4
46776: NEG
46777: PUSH
46778: EMPTY
46779: LIST
46780: LIST
46781: PUSH
46782: LD_INT 3
46784: NEG
46785: PUSH
46786: LD_INT 3
46788: NEG
46789: PUSH
46790: EMPTY
46791: LIST
46792: LIST
46793: PUSH
46794: LD_INT 4
46796: NEG
46797: PUSH
46798: LD_INT 3
46800: NEG
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: PUSH
46806: LD_INT 5
46808: NEG
46809: PUSH
46810: LD_INT 4
46812: NEG
46813: PUSH
46814: EMPTY
46815: LIST
46816: LIST
46817: PUSH
46818: LD_INT 5
46820: NEG
46821: PUSH
46822: LD_INT 5
46824: NEG
46825: PUSH
46826: EMPTY
46827: LIST
46828: LIST
46829: PUSH
46830: LD_INT 3
46832: NEG
46833: PUSH
46834: LD_INT 5
46836: NEG
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: PUSH
46842: LD_INT 5
46844: NEG
46845: PUSH
46846: LD_INT 3
46848: NEG
46849: PUSH
46850: EMPTY
46851: LIST
46852: LIST
46853: PUSH
46854: LD_INT 0
46856: PUSH
46857: LD_INT 3
46859: NEG
46860: PUSH
46861: EMPTY
46862: LIST
46863: LIST
46864: PUSH
46865: LD_INT 0
46867: PUSH
46868: LD_INT 4
46870: NEG
46871: PUSH
46872: EMPTY
46873: LIST
46874: LIST
46875: PUSH
46876: LD_INT 1
46878: PUSH
46879: LD_INT 3
46881: NEG
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: PUSH
46887: LD_INT 1
46889: PUSH
46890: LD_INT 2
46892: NEG
46893: PUSH
46894: EMPTY
46895: LIST
46896: LIST
46897: PUSH
46898: LD_INT 0
46900: PUSH
46901: LD_INT 2
46903: NEG
46904: PUSH
46905: EMPTY
46906: LIST
46907: LIST
46908: PUSH
46909: LD_INT 1
46911: NEG
46912: PUSH
46913: LD_INT 3
46915: NEG
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: PUSH
46921: LD_INT 1
46923: NEG
46924: PUSH
46925: LD_INT 4
46927: NEG
46928: PUSH
46929: EMPTY
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 2
46935: PUSH
46936: LD_INT 2
46938: NEG
46939: PUSH
46940: EMPTY
46941: LIST
46942: LIST
46943: PUSH
46944: LD_INT 2
46946: NEG
46947: PUSH
46948: LD_INT 4
46950: NEG
46951: PUSH
46952: EMPTY
46953: LIST
46954: LIST
46955: PUSH
46956: LD_INT 4
46958: PUSH
46959: LD_INT 0
46961: PUSH
46962: EMPTY
46963: LIST
46964: LIST
46965: PUSH
46966: LD_INT 4
46968: PUSH
46969: LD_INT 1
46971: NEG
46972: PUSH
46973: EMPTY
46974: LIST
46975: LIST
46976: PUSH
46977: LD_INT 5
46979: PUSH
46980: LD_INT 0
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: LD_INT 5
46989: PUSH
46990: LD_INT 1
46992: PUSH
46993: EMPTY
46994: LIST
46995: LIST
46996: PUSH
46997: LD_INT 4
46999: PUSH
47000: LD_INT 1
47002: PUSH
47003: EMPTY
47004: LIST
47005: LIST
47006: PUSH
47007: LD_INT 3
47009: PUSH
47010: LD_INT 0
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: PUSH
47017: LD_INT 3
47019: PUSH
47020: LD_INT 1
47022: NEG
47023: PUSH
47024: EMPTY
47025: LIST
47026: LIST
47027: PUSH
47028: LD_INT 3
47030: PUSH
47031: LD_INT 2
47033: NEG
47034: PUSH
47035: EMPTY
47036: LIST
47037: LIST
47038: PUSH
47039: LD_INT 5
47041: PUSH
47042: LD_INT 2
47044: PUSH
47045: EMPTY
47046: LIST
47047: LIST
47048: PUSH
47049: EMPTY
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: LIST
47082: LIST
47083: LIST
47084: LIST
47085: LIST
47086: LIST
47087: LIST
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: LIST
47095: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
47096: LD_ADDR_VAR 0 32
47100: PUSH
47101: LD_INT 4
47103: NEG
47104: PUSH
47105: LD_INT 0
47107: PUSH
47108: EMPTY
47109: LIST
47110: LIST
47111: PUSH
47112: LD_INT 4
47114: NEG
47115: PUSH
47116: LD_INT 1
47118: NEG
47119: PUSH
47120: EMPTY
47121: LIST
47122: LIST
47123: PUSH
47124: LD_INT 3
47126: NEG
47127: PUSH
47128: LD_INT 0
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 3
47137: NEG
47138: PUSH
47139: LD_INT 1
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: LD_INT 4
47148: NEG
47149: PUSH
47150: LD_INT 1
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: PUSH
47157: LD_INT 5
47159: NEG
47160: PUSH
47161: LD_INT 0
47163: PUSH
47164: EMPTY
47165: LIST
47166: LIST
47167: PUSH
47168: LD_INT 5
47170: NEG
47171: PUSH
47172: LD_INT 1
47174: NEG
47175: PUSH
47176: EMPTY
47177: LIST
47178: LIST
47179: PUSH
47180: LD_INT 5
47182: NEG
47183: PUSH
47184: LD_INT 2
47186: NEG
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: LD_INT 3
47194: NEG
47195: PUSH
47196: LD_INT 2
47198: PUSH
47199: EMPTY
47200: LIST
47201: LIST
47202: PUSH
47203: LD_INT 3
47205: NEG
47206: PUSH
47207: LD_INT 3
47209: NEG
47210: PUSH
47211: EMPTY
47212: LIST
47213: LIST
47214: PUSH
47215: LD_INT 3
47217: NEG
47218: PUSH
47219: LD_INT 4
47221: NEG
47222: PUSH
47223: EMPTY
47224: LIST
47225: LIST
47226: PUSH
47227: LD_INT 2
47229: NEG
47230: PUSH
47231: LD_INT 3
47233: NEG
47234: PUSH
47235: EMPTY
47236: LIST
47237: LIST
47238: PUSH
47239: LD_INT 2
47241: NEG
47242: PUSH
47243: LD_INT 2
47245: NEG
47246: PUSH
47247: EMPTY
47248: LIST
47249: LIST
47250: PUSH
47251: LD_INT 3
47253: NEG
47254: PUSH
47255: LD_INT 2
47257: NEG
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: PUSH
47263: LD_INT 4
47265: NEG
47266: PUSH
47267: LD_INT 3
47269: NEG
47270: PUSH
47271: EMPTY
47272: LIST
47273: LIST
47274: PUSH
47275: LD_INT 4
47277: NEG
47278: PUSH
47279: LD_INT 4
47281: NEG
47282: PUSH
47283: EMPTY
47284: LIST
47285: LIST
47286: PUSH
47287: LD_INT 2
47289: NEG
47290: PUSH
47291: LD_INT 4
47293: NEG
47294: PUSH
47295: EMPTY
47296: LIST
47297: LIST
47298: PUSH
47299: LD_INT 4
47301: NEG
47302: PUSH
47303: LD_INT 2
47305: NEG
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: PUSH
47311: LD_INT 0
47313: PUSH
47314: LD_INT 4
47316: NEG
47317: PUSH
47318: EMPTY
47319: LIST
47320: LIST
47321: PUSH
47322: LD_INT 0
47324: PUSH
47325: LD_INT 5
47327: NEG
47328: PUSH
47329: EMPTY
47330: LIST
47331: LIST
47332: PUSH
47333: LD_INT 1
47335: PUSH
47336: LD_INT 4
47338: NEG
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: PUSH
47344: LD_INT 1
47346: PUSH
47347: LD_INT 3
47349: NEG
47350: PUSH
47351: EMPTY
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 0
47357: PUSH
47358: LD_INT 3
47360: NEG
47361: PUSH
47362: EMPTY
47363: LIST
47364: LIST
47365: PUSH
47366: LD_INT 1
47368: NEG
47369: PUSH
47370: LD_INT 4
47372: NEG
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: PUSH
47378: LD_INT 1
47380: NEG
47381: PUSH
47382: LD_INT 5
47384: NEG
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: PUSH
47390: LD_INT 2
47392: PUSH
47393: LD_INT 3
47395: NEG
47396: PUSH
47397: EMPTY
47398: LIST
47399: LIST
47400: PUSH
47401: LD_INT 2
47403: NEG
47404: PUSH
47405: LD_INT 5
47407: NEG
47408: PUSH
47409: EMPTY
47410: LIST
47411: LIST
47412: PUSH
47413: LD_INT 3
47415: PUSH
47416: LD_INT 0
47418: PUSH
47419: EMPTY
47420: LIST
47421: LIST
47422: PUSH
47423: LD_INT 3
47425: PUSH
47426: LD_INT 1
47428: NEG
47429: PUSH
47430: EMPTY
47431: LIST
47432: LIST
47433: PUSH
47434: LD_INT 4
47436: PUSH
47437: LD_INT 0
47439: PUSH
47440: EMPTY
47441: LIST
47442: LIST
47443: PUSH
47444: LD_INT 4
47446: PUSH
47447: LD_INT 1
47449: PUSH
47450: EMPTY
47451: LIST
47452: LIST
47453: PUSH
47454: LD_INT 3
47456: PUSH
47457: LD_INT 1
47459: PUSH
47460: EMPTY
47461: LIST
47462: LIST
47463: PUSH
47464: LD_INT 2
47466: PUSH
47467: LD_INT 0
47469: PUSH
47470: EMPTY
47471: LIST
47472: LIST
47473: PUSH
47474: LD_INT 2
47476: PUSH
47477: LD_INT 1
47479: NEG
47480: PUSH
47481: EMPTY
47482: LIST
47483: LIST
47484: PUSH
47485: LD_INT 2
47487: PUSH
47488: LD_INT 2
47490: NEG
47491: PUSH
47492: EMPTY
47493: LIST
47494: LIST
47495: PUSH
47496: LD_INT 4
47498: PUSH
47499: LD_INT 2
47501: PUSH
47502: EMPTY
47503: LIST
47504: LIST
47505: PUSH
47506: LD_INT 4
47508: PUSH
47509: LD_INT 4
47511: PUSH
47512: EMPTY
47513: LIST
47514: LIST
47515: PUSH
47516: LD_INT 4
47518: PUSH
47519: LD_INT 3
47521: PUSH
47522: EMPTY
47523: LIST
47524: LIST
47525: PUSH
47526: LD_INT 5
47528: PUSH
47529: LD_INT 4
47531: PUSH
47532: EMPTY
47533: LIST
47534: LIST
47535: PUSH
47536: LD_INT 5
47538: PUSH
47539: LD_INT 5
47541: PUSH
47542: EMPTY
47543: LIST
47544: LIST
47545: PUSH
47546: LD_INT 4
47548: PUSH
47549: LD_INT 5
47551: PUSH
47552: EMPTY
47553: LIST
47554: LIST
47555: PUSH
47556: LD_INT 3
47558: PUSH
47559: LD_INT 4
47561: PUSH
47562: EMPTY
47563: LIST
47564: LIST
47565: PUSH
47566: LD_INT 3
47568: PUSH
47569: LD_INT 3
47571: PUSH
47572: EMPTY
47573: LIST
47574: LIST
47575: PUSH
47576: LD_INT 5
47578: PUSH
47579: LD_INT 3
47581: PUSH
47582: EMPTY
47583: LIST
47584: LIST
47585: PUSH
47586: LD_INT 3
47588: PUSH
47589: LD_INT 5
47591: PUSH
47592: EMPTY
47593: LIST
47594: LIST
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: LIST
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: LIST
47612: LIST
47613: LIST
47614: LIST
47615: LIST
47616: LIST
47617: LIST
47618: LIST
47619: LIST
47620: LIST
47621: LIST
47622: LIST
47623: LIST
47624: LIST
47625: LIST
47626: LIST
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: LIST
47638: LIST
47639: LIST
47640: LIST
47641: LIST
47642: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
47643: LD_ADDR_VAR 0 33
47647: PUSH
47648: LD_INT 4
47650: NEG
47651: PUSH
47652: LD_INT 4
47654: NEG
47655: PUSH
47656: EMPTY
47657: LIST
47658: LIST
47659: PUSH
47660: LD_INT 4
47662: NEG
47663: PUSH
47664: LD_INT 5
47666: NEG
47667: PUSH
47668: EMPTY
47669: LIST
47670: LIST
47671: PUSH
47672: LD_INT 3
47674: NEG
47675: PUSH
47676: LD_INT 4
47678: NEG
47679: PUSH
47680: EMPTY
47681: LIST
47682: LIST
47683: PUSH
47684: LD_INT 3
47686: NEG
47687: PUSH
47688: LD_INT 3
47690: NEG
47691: PUSH
47692: EMPTY
47693: LIST
47694: LIST
47695: PUSH
47696: LD_INT 4
47698: NEG
47699: PUSH
47700: LD_INT 3
47702: NEG
47703: PUSH
47704: EMPTY
47705: LIST
47706: LIST
47707: PUSH
47708: LD_INT 5
47710: NEG
47711: PUSH
47712: LD_INT 4
47714: NEG
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: LD_INT 5
47722: NEG
47723: PUSH
47724: LD_INT 5
47726: NEG
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: PUSH
47732: LD_INT 3
47734: NEG
47735: PUSH
47736: LD_INT 5
47738: NEG
47739: PUSH
47740: EMPTY
47741: LIST
47742: LIST
47743: PUSH
47744: LD_INT 5
47746: NEG
47747: PUSH
47748: LD_INT 3
47750: NEG
47751: PUSH
47752: EMPTY
47753: LIST
47754: LIST
47755: PUSH
47756: LD_INT 0
47758: PUSH
47759: LD_INT 3
47761: NEG
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: PUSH
47767: LD_INT 0
47769: PUSH
47770: LD_INT 4
47772: NEG
47773: PUSH
47774: EMPTY
47775: LIST
47776: LIST
47777: PUSH
47778: LD_INT 1
47780: PUSH
47781: LD_INT 3
47783: NEG
47784: PUSH
47785: EMPTY
47786: LIST
47787: LIST
47788: PUSH
47789: LD_INT 1
47791: PUSH
47792: LD_INT 2
47794: NEG
47795: PUSH
47796: EMPTY
47797: LIST
47798: LIST
47799: PUSH
47800: LD_INT 0
47802: PUSH
47803: LD_INT 2
47805: NEG
47806: PUSH
47807: EMPTY
47808: LIST
47809: LIST
47810: PUSH
47811: LD_INT 1
47813: NEG
47814: PUSH
47815: LD_INT 3
47817: NEG
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PUSH
47823: LD_INT 1
47825: NEG
47826: PUSH
47827: LD_INT 4
47829: NEG
47830: PUSH
47831: EMPTY
47832: LIST
47833: LIST
47834: PUSH
47835: LD_INT 2
47837: PUSH
47838: LD_INT 2
47840: NEG
47841: PUSH
47842: EMPTY
47843: LIST
47844: LIST
47845: PUSH
47846: LD_INT 2
47848: NEG
47849: PUSH
47850: LD_INT 4
47852: NEG
47853: PUSH
47854: EMPTY
47855: LIST
47856: LIST
47857: PUSH
47858: LD_INT 4
47860: PUSH
47861: LD_INT 0
47863: PUSH
47864: EMPTY
47865: LIST
47866: LIST
47867: PUSH
47868: LD_INT 4
47870: PUSH
47871: LD_INT 1
47873: NEG
47874: PUSH
47875: EMPTY
47876: LIST
47877: LIST
47878: PUSH
47879: LD_INT 5
47881: PUSH
47882: LD_INT 0
47884: PUSH
47885: EMPTY
47886: LIST
47887: LIST
47888: PUSH
47889: LD_INT 5
47891: PUSH
47892: LD_INT 1
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: PUSH
47899: LD_INT 4
47901: PUSH
47902: LD_INT 1
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: PUSH
47909: LD_INT 3
47911: PUSH
47912: LD_INT 0
47914: PUSH
47915: EMPTY
47916: LIST
47917: LIST
47918: PUSH
47919: LD_INT 3
47921: PUSH
47922: LD_INT 1
47924: NEG
47925: PUSH
47926: EMPTY
47927: LIST
47928: LIST
47929: PUSH
47930: LD_INT 3
47932: PUSH
47933: LD_INT 2
47935: NEG
47936: PUSH
47937: EMPTY
47938: LIST
47939: LIST
47940: PUSH
47941: LD_INT 5
47943: PUSH
47944: LD_INT 2
47946: PUSH
47947: EMPTY
47948: LIST
47949: LIST
47950: PUSH
47951: LD_INT 3
47953: PUSH
47954: LD_INT 3
47956: PUSH
47957: EMPTY
47958: LIST
47959: LIST
47960: PUSH
47961: LD_INT 3
47963: PUSH
47964: LD_INT 2
47966: PUSH
47967: EMPTY
47968: LIST
47969: LIST
47970: PUSH
47971: LD_INT 4
47973: PUSH
47974: LD_INT 3
47976: PUSH
47977: EMPTY
47978: LIST
47979: LIST
47980: PUSH
47981: LD_INT 4
47983: PUSH
47984: LD_INT 4
47986: PUSH
47987: EMPTY
47988: LIST
47989: LIST
47990: PUSH
47991: LD_INT 3
47993: PUSH
47994: LD_INT 4
47996: PUSH
47997: EMPTY
47998: LIST
47999: LIST
48000: PUSH
48001: LD_INT 2
48003: PUSH
48004: LD_INT 3
48006: PUSH
48007: EMPTY
48008: LIST
48009: LIST
48010: PUSH
48011: LD_INT 2
48013: PUSH
48014: LD_INT 2
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: PUSH
48021: LD_INT 4
48023: PUSH
48024: LD_INT 2
48026: PUSH
48027: EMPTY
48028: LIST
48029: LIST
48030: PUSH
48031: LD_INT 2
48033: PUSH
48034: LD_INT 4
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: PUSH
48041: LD_INT 0
48043: PUSH
48044: LD_INT 4
48046: PUSH
48047: EMPTY
48048: LIST
48049: LIST
48050: PUSH
48051: LD_INT 0
48053: PUSH
48054: LD_INT 3
48056: PUSH
48057: EMPTY
48058: LIST
48059: LIST
48060: PUSH
48061: LD_INT 1
48063: PUSH
48064: LD_INT 4
48066: PUSH
48067: EMPTY
48068: LIST
48069: LIST
48070: PUSH
48071: LD_INT 1
48073: PUSH
48074: LD_INT 5
48076: PUSH
48077: EMPTY
48078: LIST
48079: LIST
48080: PUSH
48081: LD_INT 0
48083: PUSH
48084: LD_INT 5
48086: PUSH
48087: EMPTY
48088: LIST
48089: LIST
48090: PUSH
48091: LD_INT 1
48093: NEG
48094: PUSH
48095: LD_INT 4
48097: PUSH
48098: EMPTY
48099: LIST
48100: LIST
48101: PUSH
48102: LD_INT 1
48104: NEG
48105: PUSH
48106: LD_INT 3
48108: PUSH
48109: EMPTY
48110: LIST
48111: LIST
48112: PUSH
48113: LD_INT 2
48115: PUSH
48116: LD_INT 5
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: PUSH
48123: LD_INT 2
48125: NEG
48126: PUSH
48127: LD_INT 3
48129: PUSH
48130: EMPTY
48131: LIST
48132: LIST
48133: PUSH
48134: EMPTY
48135: LIST
48136: LIST
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: LIST
48168: LIST
48169: LIST
48170: LIST
48171: LIST
48172: LIST
48173: LIST
48174: LIST
48175: LIST
48176: LIST
48177: LIST
48178: LIST
48179: LIST
48180: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
48181: LD_ADDR_VAR 0 34
48185: PUSH
48186: LD_INT 0
48188: PUSH
48189: LD_INT 4
48191: NEG
48192: PUSH
48193: EMPTY
48194: LIST
48195: LIST
48196: PUSH
48197: LD_INT 0
48199: PUSH
48200: LD_INT 5
48202: NEG
48203: PUSH
48204: EMPTY
48205: LIST
48206: LIST
48207: PUSH
48208: LD_INT 1
48210: PUSH
48211: LD_INT 4
48213: NEG
48214: PUSH
48215: EMPTY
48216: LIST
48217: LIST
48218: PUSH
48219: LD_INT 1
48221: PUSH
48222: LD_INT 3
48224: NEG
48225: PUSH
48226: EMPTY
48227: LIST
48228: LIST
48229: PUSH
48230: LD_INT 0
48232: PUSH
48233: LD_INT 3
48235: NEG
48236: PUSH
48237: EMPTY
48238: LIST
48239: LIST
48240: PUSH
48241: LD_INT 1
48243: NEG
48244: PUSH
48245: LD_INT 4
48247: NEG
48248: PUSH
48249: EMPTY
48250: LIST
48251: LIST
48252: PUSH
48253: LD_INT 1
48255: NEG
48256: PUSH
48257: LD_INT 5
48259: NEG
48260: PUSH
48261: EMPTY
48262: LIST
48263: LIST
48264: PUSH
48265: LD_INT 2
48267: PUSH
48268: LD_INT 3
48270: NEG
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 2
48278: NEG
48279: PUSH
48280: LD_INT 5
48282: NEG
48283: PUSH
48284: EMPTY
48285: LIST
48286: LIST
48287: PUSH
48288: LD_INT 3
48290: PUSH
48291: LD_INT 0
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: PUSH
48298: LD_INT 3
48300: PUSH
48301: LD_INT 1
48303: NEG
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 4
48311: PUSH
48312: LD_INT 0
48314: PUSH
48315: EMPTY
48316: LIST
48317: LIST
48318: PUSH
48319: LD_INT 4
48321: PUSH
48322: LD_INT 1
48324: PUSH
48325: EMPTY
48326: LIST
48327: LIST
48328: PUSH
48329: LD_INT 3
48331: PUSH
48332: LD_INT 1
48334: PUSH
48335: EMPTY
48336: LIST
48337: LIST
48338: PUSH
48339: LD_INT 2
48341: PUSH
48342: LD_INT 0
48344: PUSH
48345: EMPTY
48346: LIST
48347: LIST
48348: PUSH
48349: LD_INT 2
48351: PUSH
48352: LD_INT 1
48354: NEG
48355: PUSH
48356: EMPTY
48357: LIST
48358: LIST
48359: PUSH
48360: LD_INT 2
48362: PUSH
48363: LD_INT 2
48365: NEG
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: PUSH
48371: LD_INT 4
48373: PUSH
48374: LD_INT 2
48376: PUSH
48377: EMPTY
48378: LIST
48379: LIST
48380: PUSH
48381: LD_INT 4
48383: PUSH
48384: LD_INT 4
48386: PUSH
48387: EMPTY
48388: LIST
48389: LIST
48390: PUSH
48391: LD_INT 4
48393: PUSH
48394: LD_INT 3
48396: PUSH
48397: EMPTY
48398: LIST
48399: LIST
48400: PUSH
48401: LD_INT 5
48403: PUSH
48404: LD_INT 4
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PUSH
48411: LD_INT 5
48413: PUSH
48414: LD_INT 5
48416: PUSH
48417: EMPTY
48418: LIST
48419: LIST
48420: PUSH
48421: LD_INT 4
48423: PUSH
48424: LD_INT 5
48426: PUSH
48427: EMPTY
48428: LIST
48429: LIST
48430: PUSH
48431: LD_INT 3
48433: PUSH
48434: LD_INT 4
48436: PUSH
48437: EMPTY
48438: LIST
48439: LIST
48440: PUSH
48441: LD_INT 3
48443: PUSH
48444: LD_INT 3
48446: PUSH
48447: EMPTY
48448: LIST
48449: LIST
48450: PUSH
48451: LD_INT 5
48453: PUSH
48454: LD_INT 3
48456: PUSH
48457: EMPTY
48458: LIST
48459: LIST
48460: PUSH
48461: LD_INT 3
48463: PUSH
48464: LD_INT 5
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: PUSH
48471: LD_INT 0
48473: PUSH
48474: LD_INT 3
48476: PUSH
48477: EMPTY
48478: LIST
48479: LIST
48480: PUSH
48481: LD_INT 0
48483: PUSH
48484: LD_INT 2
48486: PUSH
48487: EMPTY
48488: LIST
48489: LIST
48490: PUSH
48491: LD_INT 1
48493: PUSH
48494: LD_INT 3
48496: PUSH
48497: EMPTY
48498: LIST
48499: LIST
48500: PUSH
48501: LD_INT 1
48503: PUSH
48504: LD_INT 4
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PUSH
48511: LD_INT 0
48513: PUSH
48514: LD_INT 4
48516: PUSH
48517: EMPTY
48518: LIST
48519: LIST
48520: PUSH
48521: LD_INT 1
48523: NEG
48524: PUSH
48525: LD_INT 3
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: PUSH
48532: LD_INT 1
48534: NEG
48535: PUSH
48536: LD_INT 2
48538: PUSH
48539: EMPTY
48540: LIST
48541: LIST
48542: PUSH
48543: LD_INT 2
48545: PUSH
48546: LD_INT 4
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 2
48555: NEG
48556: PUSH
48557: LD_INT 2
48559: PUSH
48560: EMPTY
48561: LIST
48562: LIST
48563: PUSH
48564: LD_INT 4
48566: NEG
48567: PUSH
48568: LD_INT 0
48570: PUSH
48571: EMPTY
48572: LIST
48573: LIST
48574: PUSH
48575: LD_INT 4
48577: NEG
48578: PUSH
48579: LD_INT 1
48581: NEG
48582: PUSH
48583: EMPTY
48584: LIST
48585: LIST
48586: PUSH
48587: LD_INT 3
48589: NEG
48590: PUSH
48591: LD_INT 0
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 3
48600: NEG
48601: PUSH
48602: LD_INT 1
48604: PUSH
48605: EMPTY
48606: LIST
48607: LIST
48608: PUSH
48609: LD_INT 4
48611: NEG
48612: PUSH
48613: LD_INT 1
48615: PUSH
48616: EMPTY
48617: LIST
48618: LIST
48619: PUSH
48620: LD_INT 5
48622: NEG
48623: PUSH
48624: LD_INT 0
48626: PUSH
48627: EMPTY
48628: LIST
48629: LIST
48630: PUSH
48631: LD_INT 5
48633: NEG
48634: PUSH
48635: LD_INT 1
48637: NEG
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: PUSH
48643: LD_INT 5
48645: NEG
48646: PUSH
48647: LD_INT 2
48649: NEG
48650: PUSH
48651: EMPTY
48652: LIST
48653: LIST
48654: PUSH
48655: LD_INT 3
48657: NEG
48658: PUSH
48659: LD_INT 2
48661: PUSH
48662: EMPTY
48663: LIST
48664: LIST
48665: PUSH
48666: EMPTY
48667: LIST
48668: LIST
48669: LIST
48670: LIST
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: LIST
48676: LIST
48677: LIST
48678: LIST
48679: LIST
48680: LIST
48681: LIST
48682: LIST
48683: LIST
48684: LIST
48685: LIST
48686: LIST
48687: LIST
48688: LIST
48689: LIST
48690: LIST
48691: LIST
48692: LIST
48693: LIST
48694: LIST
48695: LIST
48696: LIST
48697: LIST
48698: LIST
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: LIST
48706: LIST
48707: LIST
48708: LIST
48709: LIST
48710: LIST
48711: LIST
48712: ST_TO_ADDR
// end ; end ;
48713: GO 48716
48715: POP
// case btype of b_depot , b_warehouse :
48716: LD_VAR 0 1
48720: PUSH
48721: LD_INT 0
48723: DOUBLE
48724: EQUAL
48725: IFTRUE 48735
48727: LD_INT 1
48729: DOUBLE
48730: EQUAL
48731: IFTRUE 48735
48733: GO 48936
48735: POP
// case nation of nation_american :
48736: LD_VAR 0 5
48740: PUSH
48741: LD_INT 1
48743: DOUBLE
48744: EQUAL
48745: IFTRUE 48749
48747: GO 48805
48749: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
48750: LD_ADDR_VAR 0 9
48754: PUSH
48755: LD_VAR 0 11
48759: PUSH
48760: LD_VAR 0 12
48764: PUSH
48765: LD_VAR 0 13
48769: PUSH
48770: LD_VAR 0 14
48774: PUSH
48775: LD_VAR 0 15
48779: PUSH
48780: LD_VAR 0 16
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: LIST
48789: LIST
48790: LIST
48791: LIST
48792: PUSH
48793: LD_VAR 0 4
48797: PUSH
48798: LD_INT 1
48800: PLUS
48801: ARRAY
48802: ST_TO_ADDR
48803: GO 48934
48805: LD_INT 2
48807: DOUBLE
48808: EQUAL
48809: IFTRUE 48813
48811: GO 48869
48813: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
48814: LD_ADDR_VAR 0 9
48818: PUSH
48819: LD_VAR 0 17
48823: PUSH
48824: LD_VAR 0 18
48828: PUSH
48829: LD_VAR 0 19
48833: PUSH
48834: LD_VAR 0 20
48838: PUSH
48839: LD_VAR 0 21
48843: PUSH
48844: LD_VAR 0 22
48848: PUSH
48849: EMPTY
48850: LIST
48851: LIST
48852: LIST
48853: LIST
48854: LIST
48855: LIST
48856: PUSH
48857: LD_VAR 0 4
48861: PUSH
48862: LD_INT 1
48864: PLUS
48865: ARRAY
48866: ST_TO_ADDR
48867: GO 48934
48869: LD_INT 3
48871: DOUBLE
48872: EQUAL
48873: IFTRUE 48877
48875: GO 48933
48877: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
48878: LD_ADDR_VAR 0 9
48882: PUSH
48883: LD_VAR 0 23
48887: PUSH
48888: LD_VAR 0 24
48892: PUSH
48893: LD_VAR 0 25
48897: PUSH
48898: LD_VAR 0 26
48902: PUSH
48903: LD_VAR 0 27
48907: PUSH
48908: LD_VAR 0 28
48912: PUSH
48913: EMPTY
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: PUSH
48921: LD_VAR 0 4
48925: PUSH
48926: LD_INT 1
48928: PLUS
48929: ARRAY
48930: ST_TO_ADDR
48931: GO 48934
48933: POP
48934: GO 49489
48936: LD_INT 2
48938: DOUBLE
48939: EQUAL
48940: IFTRUE 48950
48942: LD_INT 3
48944: DOUBLE
48945: EQUAL
48946: IFTRUE 48950
48948: GO 49006
48950: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
48951: LD_ADDR_VAR 0 9
48955: PUSH
48956: LD_VAR 0 29
48960: PUSH
48961: LD_VAR 0 30
48965: PUSH
48966: LD_VAR 0 31
48970: PUSH
48971: LD_VAR 0 32
48975: PUSH
48976: LD_VAR 0 33
48980: PUSH
48981: LD_VAR 0 34
48985: PUSH
48986: EMPTY
48987: LIST
48988: LIST
48989: LIST
48990: LIST
48991: LIST
48992: LIST
48993: PUSH
48994: LD_VAR 0 4
48998: PUSH
48999: LD_INT 1
49001: PLUS
49002: ARRAY
49003: ST_TO_ADDR
49004: GO 49489
49006: LD_INT 16
49008: DOUBLE
49009: EQUAL
49010: IFTRUE 49068
49012: LD_INT 17
49014: DOUBLE
49015: EQUAL
49016: IFTRUE 49068
49018: LD_INT 18
49020: DOUBLE
49021: EQUAL
49022: IFTRUE 49068
49024: LD_INT 19
49026: DOUBLE
49027: EQUAL
49028: IFTRUE 49068
49030: LD_INT 22
49032: DOUBLE
49033: EQUAL
49034: IFTRUE 49068
49036: LD_INT 20
49038: DOUBLE
49039: EQUAL
49040: IFTRUE 49068
49042: LD_INT 21
49044: DOUBLE
49045: EQUAL
49046: IFTRUE 49068
49048: LD_INT 23
49050: DOUBLE
49051: EQUAL
49052: IFTRUE 49068
49054: LD_INT 24
49056: DOUBLE
49057: EQUAL
49058: IFTRUE 49068
49060: LD_INT 25
49062: DOUBLE
49063: EQUAL
49064: IFTRUE 49068
49066: GO 49124
49068: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
49069: LD_ADDR_VAR 0 9
49073: PUSH
49074: LD_VAR 0 35
49078: PUSH
49079: LD_VAR 0 36
49083: PUSH
49084: LD_VAR 0 37
49088: PUSH
49089: LD_VAR 0 38
49093: PUSH
49094: LD_VAR 0 39
49098: PUSH
49099: LD_VAR 0 40
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: PUSH
49112: LD_VAR 0 4
49116: PUSH
49117: LD_INT 1
49119: PLUS
49120: ARRAY
49121: ST_TO_ADDR
49122: GO 49489
49124: LD_INT 6
49126: DOUBLE
49127: EQUAL
49128: IFTRUE 49180
49130: LD_INT 7
49132: DOUBLE
49133: EQUAL
49134: IFTRUE 49180
49136: LD_INT 8
49138: DOUBLE
49139: EQUAL
49140: IFTRUE 49180
49142: LD_INT 13
49144: DOUBLE
49145: EQUAL
49146: IFTRUE 49180
49148: LD_INT 12
49150: DOUBLE
49151: EQUAL
49152: IFTRUE 49180
49154: LD_INT 15
49156: DOUBLE
49157: EQUAL
49158: IFTRUE 49180
49160: LD_INT 11
49162: DOUBLE
49163: EQUAL
49164: IFTRUE 49180
49166: LD_INT 14
49168: DOUBLE
49169: EQUAL
49170: IFTRUE 49180
49172: LD_INT 10
49174: DOUBLE
49175: EQUAL
49176: IFTRUE 49180
49178: GO 49236
49180: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
49181: LD_ADDR_VAR 0 9
49185: PUSH
49186: LD_VAR 0 41
49190: PUSH
49191: LD_VAR 0 42
49195: PUSH
49196: LD_VAR 0 43
49200: PUSH
49201: LD_VAR 0 44
49205: PUSH
49206: LD_VAR 0 45
49210: PUSH
49211: LD_VAR 0 46
49215: PUSH
49216: EMPTY
49217: LIST
49218: LIST
49219: LIST
49220: LIST
49221: LIST
49222: LIST
49223: PUSH
49224: LD_VAR 0 4
49228: PUSH
49229: LD_INT 1
49231: PLUS
49232: ARRAY
49233: ST_TO_ADDR
49234: GO 49489
49236: LD_INT 36
49238: DOUBLE
49239: EQUAL
49240: IFTRUE 49244
49242: GO 49300
49244: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
49245: LD_ADDR_VAR 0 9
49249: PUSH
49250: LD_VAR 0 47
49254: PUSH
49255: LD_VAR 0 48
49259: PUSH
49260: LD_VAR 0 49
49264: PUSH
49265: LD_VAR 0 50
49269: PUSH
49270: LD_VAR 0 51
49274: PUSH
49275: LD_VAR 0 52
49279: PUSH
49280: EMPTY
49281: LIST
49282: LIST
49283: LIST
49284: LIST
49285: LIST
49286: LIST
49287: PUSH
49288: LD_VAR 0 4
49292: PUSH
49293: LD_INT 1
49295: PLUS
49296: ARRAY
49297: ST_TO_ADDR
49298: GO 49489
49300: LD_INT 4
49302: DOUBLE
49303: EQUAL
49304: IFTRUE 49326
49306: LD_INT 5
49308: DOUBLE
49309: EQUAL
49310: IFTRUE 49326
49312: LD_INT 34
49314: DOUBLE
49315: EQUAL
49316: IFTRUE 49326
49318: LD_INT 37
49320: DOUBLE
49321: EQUAL
49322: IFTRUE 49326
49324: GO 49382
49326: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49327: LD_ADDR_VAR 0 9
49331: PUSH
49332: LD_VAR 0 53
49336: PUSH
49337: LD_VAR 0 54
49341: PUSH
49342: LD_VAR 0 55
49346: PUSH
49347: LD_VAR 0 56
49351: PUSH
49352: LD_VAR 0 57
49356: PUSH
49357: LD_VAR 0 58
49361: PUSH
49362: EMPTY
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: PUSH
49370: LD_VAR 0 4
49374: PUSH
49375: LD_INT 1
49377: PLUS
49378: ARRAY
49379: ST_TO_ADDR
49380: GO 49489
49382: LD_INT 31
49384: DOUBLE
49385: EQUAL
49386: IFTRUE 49432
49388: LD_INT 32
49390: DOUBLE
49391: EQUAL
49392: IFTRUE 49432
49394: LD_INT 33
49396: DOUBLE
49397: EQUAL
49398: IFTRUE 49432
49400: LD_INT 27
49402: DOUBLE
49403: EQUAL
49404: IFTRUE 49432
49406: LD_INT 26
49408: DOUBLE
49409: EQUAL
49410: IFTRUE 49432
49412: LD_INT 28
49414: DOUBLE
49415: EQUAL
49416: IFTRUE 49432
49418: LD_INT 29
49420: DOUBLE
49421: EQUAL
49422: IFTRUE 49432
49424: LD_INT 30
49426: DOUBLE
49427: EQUAL
49428: IFTRUE 49432
49430: GO 49488
49432: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
49433: LD_ADDR_VAR 0 9
49437: PUSH
49438: LD_VAR 0 59
49442: PUSH
49443: LD_VAR 0 60
49447: PUSH
49448: LD_VAR 0 61
49452: PUSH
49453: LD_VAR 0 62
49457: PUSH
49458: LD_VAR 0 63
49462: PUSH
49463: LD_VAR 0 64
49467: PUSH
49468: EMPTY
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: PUSH
49476: LD_VAR 0 4
49480: PUSH
49481: LD_INT 1
49483: PLUS
49484: ARRAY
49485: ST_TO_ADDR
49486: GO 49489
49488: POP
// temp_list2 = [ ] ;
49489: LD_ADDR_VAR 0 10
49493: PUSH
49494: EMPTY
49495: ST_TO_ADDR
// for i in temp_list do
49496: LD_ADDR_VAR 0 8
49500: PUSH
49501: LD_VAR 0 9
49505: PUSH
49506: FOR_IN
49507: IFFALSE 49559
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
49509: LD_ADDR_VAR 0 10
49513: PUSH
49514: LD_VAR 0 10
49518: PUSH
49519: LD_VAR 0 8
49523: PUSH
49524: LD_INT 1
49526: ARRAY
49527: PUSH
49528: LD_VAR 0 2
49532: PLUS
49533: PUSH
49534: LD_VAR 0 8
49538: PUSH
49539: LD_INT 2
49541: ARRAY
49542: PUSH
49543: LD_VAR 0 3
49547: PLUS
49548: PUSH
49549: EMPTY
49550: LIST
49551: LIST
49552: PUSH
49553: EMPTY
49554: LIST
49555: ADD
49556: ST_TO_ADDR
49557: GO 49506
49559: POP
49560: POP
// result = temp_list2 ;
49561: LD_ADDR_VAR 0 7
49565: PUSH
49566: LD_VAR 0 10
49570: ST_TO_ADDR
// end ;
49571: LD_VAR 0 7
49575: RET
// export function EnemyInRange ( unit , dist ) ; begin
49576: LD_INT 0
49578: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
49579: LD_ADDR_VAR 0 3
49583: PUSH
49584: LD_VAR 0 1
49588: PPUSH
49589: CALL_OW 255
49593: PPUSH
49594: LD_VAR 0 1
49598: PPUSH
49599: CALL_OW 250
49603: PPUSH
49604: LD_VAR 0 1
49608: PPUSH
49609: CALL_OW 251
49613: PPUSH
49614: LD_VAR 0 2
49618: PPUSH
49619: CALL 23347 0 4
49623: PUSH
49624: LD_INT 4
49626: ARRAY
49627: ST_TO_ADDR
// end ;
49628: LD_VAR 0 3
49632: RET
// export function PlayerSeeMe ( unit ) ; begin
49633: LD_INT 0
49635: PPUSH
// result := See ( your_side , unit ) ;
49636: LD_ADDR_VAR 0 2
49640: PUSH
49641: LD_OWVAR 2
49645: PPUSH
49646: LD_VAR 0 1
49650: PPUSH
49651: CALL_OW 292
49655: ST_TO_ADDR
// end ;
49656: LD_VAR 0 2
49660: RET
// export function ReverseDir ( unit ) ; begin
49661: LD_INT 0
49663: PPUSH
// if not unit then
49664: LD_VAR 0 1
49668: NOT
49669: IFFALSE 49673
// exit ;
49671: GO 49696
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
49673: LD_ADDR_VAR 0 2
49677: PUSH
49678: LD_VAR 0 1
49682: PPUSH
49683: CALL_OW 254
49687: PUSH
49688: LD_INT 3
49690: PLUS
49691: PUSH
49692: LD_INT 6
49694: MOD
49695: ST_TO_ADDR
// end ;
49696: LD_VAR 0 2
49700: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
49701: LD_INT 0
49703: PPUSH
49704: PPUSH
49705: PPUSH
49706: PPUSH
49707: PPUSH
// if not hexes then
49708: LD_VAR 0 2
49712: NOT
49713: IFFALSE 49717
// exit ;
49715: GO 49865
// dist := 9999 ;
49717: LD_ADDR_VAR 0 5
49721: PUSH
49722: LD_INT 9999
49724: ST_TO_ADDR
// for i = 1 to hexes do
49725: LD_ADDR_VAR 0 4
49729: PUSH
49730: DOUBLE
49731: LD_INT 1
49733: DEC
49734: ST_TO_ADDR
49735: LD_VAR 0 2
49739: PUSH
49740: FOR_TO
49741: IFFALSE 49853
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
49743: LD_VAR 0 1
49747: PPUSH
49748: LD_VAR 0 2
49752: PUSH
49753: LD_VAR 0 4
49757: ARRAY
49758: PUSH
49759: LD_INT 1
49761: ARRAY
49762: PPUSH
49763: LD_VAR 0 2
49767: PUSH
49768: LD_VAR 0 4
49772: ARRAY
49773: PUSH
49774: LD_INT 2
49776: ARRAY
49777: PPUSH
49778: CALL_OW 297
49782: PUSH
49783: LD_VAR 0 5
49787: LESS
49788: IFFALSE 49851
// begin hex := hexes [ i ] ;
49790: LD_ADDR_VAR 0 7
49794: PUSH
49795: LD_VAR 0 2
49799: PUSH
49800: LD_VAR 0 4
49804: ARRAY
49805: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
49806: LD_ADDR_VAR 0 5
49810: PUSH
49811: LD_VAR 0 1
49815: PPUSH
49816: LD_VAR 0 2
49820: PUSH
49821: LD_VAR 0 4
49825: ARRAY
49826: PUSH
49827: LD_INT 1
49829: ARRAY
49830: PPUSH
49831: LD_VAR 0 2
49835: PUSH
49836: LD_VAR 0 4
49840: ARRAY
49841: PUSH
49842: LD_INT 2
49844: ARRAY
49845: PPUSH
49846: CALL_OW 297
49850: ST_TO_ADDR
// end ; end ;
49851: GO 49740
49853: POP
49854: POP
// result := hex ;
49855: LD_ADDR_VAR 0 3
49859: PUSH
49860: LD_VAR 0 7
49864: ST_TO_ADDR
// end ;
49865: LD_VAR 0 3
49869: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
49870: LD_INT 0
49872: PPUSH
49873: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
49874: LD_VAR 0 1
49878: NOT
49879: PUSH
49880: LD_VAR 0 1
49884: PUSH
49885: LD_INT 21
49887: PUSH
49888: LD_INT 2
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 23
49897: PUSH
49898: LD_INT 2
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: EMPTY
49906: LIST
49907: LIST
49908: PPUSH
49909: CALL_OW 69
49913: IN
49914: NOT
49915: OR
49916: IFFALSE 49920
// exit ;
49918: GO 49967
// for i = 1 to 3 do
49920: LD_ADDR_VAR 0 3
49924: PUSH
49925: DOUBLE
49926: LD_INT 1
49928: DEC
49929: ST_TO_ADDR
49930: LD_INT 3
49932: PUSH
49933: FOR_TO
49934: IFFALSE 49965
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
49936: LD_VAR 0 1
49940: PPUSH
49941: CALL_OW 250
49945: PPUSH
49946: LD_VAR 0 1
49950: PPUSH
49951: CALL_OW 251
49955: PPUSH
49956: LD_INT 1
49958: PPUSH
49959: CALL_OW 453
49963: GO 49933
49965: POP
49966: POP
// end ;
49967: LD_VAR 0 2
49971: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
49972: LD_INT 0
49974: PPUSH
49975: PPUSH
49976: PPUSH
49977: PPUSH
49978: PPUSH
49979: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
49980: LD_VAR 0 1
49984: NOT
49985: PUSH
49986: LD_VAR 0 2
49990: NOT
49991: OR
49992: PUSH
49993: LD_VAR 0 1
49997: PPUSH
49998: CALL_OW 314
50002: OR
50003: IFFALSE 50007
// exit ;
50005: GO 50448
// x := GetX ( enemy_unit ) ;
50007: LD_ADDR_VAR 0 7
50011: PUSH
50012: LD_VAR 0 2
50016: PPUSH
50017: CALL_OW 250
50021: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
50022: LD_ADDR_VAR 0 8
50026: PUSH
50027: LD_VAR 0 2
50031: PPUSH
50032: CALL_OW 251
50036: ST_TO_ADDR
// if not x or not y then
50037: LD_VAR 0 7
50041: NOT
50042: PUSH
50043: LD_VAR 0 8
50047: NOT
50048: OR
50049: IFFALSE 50053
// exit ;
50051: GO 50448
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
50053: LD_ADDR_VAR 0 6
50057: PUSH
50058: LD_VAR 0 7
50062: PPUSH
50063: LD_INT 0
50065: PPUSH
50066: LD_INT 4
50068: PPUSH
50069: CALL_OW 272
50073: PUSH
50074: LD_VAR 0 8
50078: PPUSH
50079: LD_INT 0
50081: PPUSH
50082: LD_INT 4
50084: PPUSH
50085: CALL_OW 273
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: PUSH
50094: LD_VAR 0 7
50098: PPUSH
50099: LD_INT 1
50101: PPUSH
50102: LD_INT 4
50104: PPUSH
50105: CALL_OW 272
50109: PUSH
50110: LD_VAR 0 8
50114: PPUSH
50115: LD_INT 1
50117: PPUSH
50118: LD_INT 4
50120: PPUSH
50121: CALL_OW 273
50125: PUSH
50126: EMPTY
50127: LIST
50128: LIST
50129: PUSH
50130: LD_VAR 0 7
50134: PPUSH
50135: LD_INT 2
50137: PPUSH
50138: LD_INT 4
50140: PPUSH
50141: CALL_OW 272
50145: PUSH
50146: LD_VAR 0 8
50150: PPUSH
50151: LD_INT 2
50153: PPUSH
50154: LD_INT 4
50156: PPUSH
50157: CALL_OW 273
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PUSH
50166: LD_VAR 0 7
50170: PPUSH
50171: LD_INT 3
50173: PPUSH
50174: LD_INT 4
50176: PPUSH
50177: CALL_OW 272
50181: PUSH
50182: LD_VAR 0 8
50186: PPUSH
50187: LD_INT 3
50189: PPUSH
50190: LD_INT 4
50192: PPUSH
50193: CALL_OW 273
50197: PUSH
50198: EMPTY
50199: LIST
50200: LIST
50201: PUSH
50202: LD_VAR 0 7
50206: PPUSH
50207: LD_INT 4
50209: PPUSH
50210: LD_INT 4
50212: PPUSH
50213: CALL_OW 272
50217: PUSH
50218: LD_VAR 0 8
50222: PPUSH
50223: LD_INT 4
50225: PPUSH
50226: LD_INT 4
50228: PPUSH
50229: CALL_OW 273
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: PUSH
50238: LD_VAR 0 7
50242: PPUSH
50243: LD_INT 5
50245: PPUSH
50246: LD_INT 4
50248: PPUSH
50249: CALL_OW 272
50253: PUSH
50254: LD_VAR 0 8
50258: PPUSH
50259: LD_INT 5
50261: PPUSH
50262: LD_INT 4
50264: PPUSH
50265: CALL_OW 273
50269: PUSH
50270: EMPTY
50271: LIST
50272: LIST
50273: PUSH
50274: EMPTY
50275: LIST
50276: LIST
50277: LIST
50278: LIST
50279: LIST
50280: LIST
50281: ST_TO_ADDR
// for i = tmp downto 1 do
50282: LD_ADDR_VAR 0 4
50286: PUSH
50287: DOUBLE
50288: LD_VAR 0 6
50292: INC
50293: ST_TO_ADDR
50294: LD_INT 1
50296: PUSH
50297: FOR_DOWNTO
50298: IFFALSE 50399
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
50300: LD_VAR 0 6
50304: PUSH
50305: LD_VAR 0 4
50309: ARRAY
50310: PUSH
50311: LD_INT 1
50313: ARRAY
50314: PPUSH
50315: LD_VAR 0 6
50319: PUSH
50320: LD_VAR 0 4
50324: ARRAY
50325: PUSH
50326: LD_INT 2
50328: ARRAY
50329: PPUSH
50330: CALL_OW 488
50334: NOT
50335: PUSH
50336: LD_VAR 0 6
50340: PUSH
50341: LD_VAR 0 4
50345: ARRAY
50346: PUSH
50347: LD_INT 1
50349: ARRAY
50350: PPUSH
50351: LD_VAR 0 6
50355: PUSH
50356: LD_VAR 0 4
50360: ARRAY
50361: PUSH
50362: LD_INT 2
50364: ARRAY
50365: PPUSH
50366: CALL_OW 428
50370: PUSH
50371: LD_INT 0
50373: NONEQUAL
50374: OR
50375: IFFALSE 50397
// tmp := Delete ( tmp , i ) ;
50377: LD_ADDR_VAR 0 6
50381: PUSH
50382: LD_VAR 0 6
50386: PPUSH
50387: LD_VAR 0 4
50391: PPUSH
50392: CALL_OW 3
50396: ST_TO_ADDR
50397: GO 50297
50399: POP
50400: POP
// j := GetClosestHex ( unit , tmp ) ;
50401: LD_ADDR_VAR 0 5
50405: PUSH
50406: LD_VAR 0 1
50410: PPUSH
50411: LD_VAR 0 6
50415: PPUSH
50416: CALL 49701 0 2
50420: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
50421: LD_VAR 0 1
50425: PPUSH
50426: LD_VAR 0 5
50430: PUSH
50431: LD_INT 1
50433: ARRAY
50434: PPUSH
50435: LD_VAR 0 5
50439: PUSH
50440: LD_INT 2
50442: ARRAY
50443: PPUSH
50444: CALL_OW 111
// end ;
50448: LD_VAR 0 3
50452: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
50453: LD_INT 0
50455: PPUSH
50456: PPUSH
50457: PPUSH
// uc_side = 0 ;
50458: LD_ADDR_OWVAR 20
50462: PUSH
50463: LD_INT 0
50465: ST_TO_ADDR
// uc_nation = 0 ;
50466: LD_ADDR_OWVAR 21
50470: PUSH
50471: LD_INT 0
50473: ST_TO_ADDR
// InitHc_All ( ) ;
50474: CALL_OW 584
// InitVc ;
50478: CALL_OW 20
// if mastodonts then
50482: LD_VAR 0 6
50486: IFFALSE 50553
// for i = 1 to mastodonts do
50488: LD_ADDR_VAR 0 11
50492: PUSH
50493: DOUBLE
50494: LD_INT 1
50496: DEC
50497: ST_TO_ADDR
50498: LD_VAR 0 6
50502: PUSH
50503: FOR_TO
50504: IFFALSE 50551
// begin vc_chassis := 31 ;
50506: LD_ADDR_OWVAR 37
50510: PUSH
50511: LD_INT 31
50513: ST_TO_ADDR
// vc_control := control_rider ;
50514: LD_ADDR_OWVAR 38
50518: PUSH
50519: LD_INT 4
50521: ST_TO_ADDR
// animal := CreateVehicle ;
50522: LD_ADDR_VAR 0 12
50526: PUSH
50527: CALL_OW 45
50531: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50532: LD_VAR 0 12
50536: PPUSH
50537: LD_VAR 0 8
50541: PPUSH
50542: LD_INT 0
50544: PPUSH
50545: CALL 52741 0 3
// end ;
50549: GO 50503
50551: POP
50552: POP
// if horses then
50553: LD_VAR 0 5
50557: IFFALSE 50624
// for i = 1 to horses do
50559: LD_ADDR_VAR 0 11
50563: PUSH
50564: DOUBLE
50565: LD_INT 1
50567: DEC
50568: ST_TO_ADDR
50569: LD_VAR 0 5
50573: PUSH
50574: FOR_TO
50575: IFFALSE 50622
// begin hc_class := 21 ;
50577: LD_ADDR_OWVAR 28
50581: PUSH
50582: LD_INT 21
50584: ST_TO_ADDR
// hc_gallery :=  ;
50585: LD_ADDR_OWVAR 33
50589: PUSH
50590: LD_STRING 
50592: ST_TO_ADDR
// animal := CreateHuman ;
50593: LD_ADDR_VAR 0 12
50597: PUSH
50598: CALL_OW 44
50602: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50603: LD_VAR 0 12
50607: PPUSH
50608: LD_VAR 0 8
50612: PPUSH
50613: LD_INT 0
50615: PPUSH
50616: CALL 52741 0 3
// end ;
50620: GO 50574
50622: POP
50623: POP
// if birds then
50624: LD_VAR 0 1
50628: IFFALSE 50695
// for i = 1 to birds do
50630: LD_ADDR_VAR 0 11
50634: PUSH
50635: DOUBLE
50636: LD_INT 1
50638: DEC
50639: ST_TO_ADDR
50640: LD_VAR 0 1
50644: PUSH
50645: FOR_TO
50646: IFFALSE 50693
// begin hc_class = 18 ;
50648: LD_ADDR_OWVAR 28
50652: PUSH
50653: LD_INT 18
50655: ST_TO_ADDR
// hc_gallery =  ;
50656: LD_ADDR_OWVAR 33
50660: PUSH
50661: LD_STRING 
50663: ST_TO_ADDR
// animal := CreateHuman ;
50664: LD_ADDR_VAR 0 12
50668: PUSH
50669: CALL_OW 44
50673: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50674: LD_VAR 0 12
50678: PPUSH
50679: LD_VAR 0 8
50683: PPUSH
50684: LD_INT 0
50686: PPUSH
50687: CALL 52741 0 3
// end ;
50691: GO 50645
50693: POP
50694: POP
// if tigers then
50695: LD_VAR 0 2
50699: IFFALSE 50783
// for i = 1 to tigers do
50701: LD_ADDR_VAR 0 11
50705: PUSH
50706: DOUBLE
50707: LD_INT 1
50709: DEC
50710: ST_TO_ADDR
50711: LD_VAR 0 2
50715: PUSH
50716: FOR_TO
50717: IFFALSE 50781
// begin hc_class = class_tiger ;
50719: LD_ADDR_OWVAR 28
50723: PUSH
50724: LD_INT 14
50726: ST_TO_ADDR
// hc_gallery =  ;
50727: LD_ADDR_OWVAR 33
50731: PUSH
50732: LD_STRING 
50734: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
50735: LD_ADDR_OWVAR 35
50739: PUSH
50740: LD_INT 7
50742: NEG
50743: PPUSH
50744: LD_INT 7
50746: PPUSH
50747: CALL_OW 12
50751: ST_TO_ADDR
// animal := CreateHuman ;
50752: LD_ADDR_VAR 0 12
50756: PUSH
50757: CALL_OW 44
50761: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50762: LD_VAR 0 12
50766: PPUSH
50767: LD_VAR 0 8
50771: PPUSH
50772: LD_INT 0
50774: PPUSH
50775: CALL 52741 0 3
// end ;
50779: GO 50716
50781: POP
50782: POP
// if apemans then
50783: LD_VAR 0 3
50787: IFFALSE 50910
// for i = 1 to apemans do
50789: LD_ADDR_VAR 0 11
50793: PUSH
50794: DOUBLE
50795: LD_INT 1
50797: DEC
50798: ST_TO_ADDR
50799: LD_VAR 0 3
50803: PUSH
50804: FOR_TO
50805: IFFALSE 50908
// begin hc_class = class_apeman ;
50807: LD_ADDR_OWVAR 28
50811: PUSH
50812: LD_INT 12
50814: ST_TO_ADDR
// hc_gallery =  ;
50815: LD_ADDR_OWVAR 33
50819: PUSH
50820: LD_STRING 
50822: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
50823: LD_ADDR_OWVAR 35
50827: PUSH
50828: LD_INT 5
50830: NEG
50831: PPUSH
50832: LD_INT 5
50834: PPUSH
50835: CALL_OW 12
50839: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
50840: LD_ADDR_OWVAR 31
50844: PUSH
50845: LD_INT 1
50847: PPUSH
50848: LD_INT 3
50850: PPUSH
50851: CALL_OW 12
50855: PUSH
50856: LD_INT 1
50858: PPUSH
50859: LD_INT 3
50861: PPUSH
50862: CALL_OW 12
50866: PUSH
50867: LD_INT 0
50869: PUSH
50870: LD_INT 0
50872: PUSH
50873: EMPTY
50874: LIST
50875: LIST
50876: LIST
50877: LIST
50878: ST_TO_ADDR
// animal := CreateHuman ;
50879: LD_ADDR_VAR 0 12
50883: PUSH
50884: CALL_OW 44
50888: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50889: LD_VAR 0 12
50893: PPUSH
50894: LD_VAR 0 8
50898: PPUSH
50899: LD_INT 0
50901: PPUSH
50902: CALL 52741 0 3
// end ;
50906: GO 50804
50908: POP
50909: POP
// if enchidnas then
50910: LD_VAR 0 4
50914: IFFALSE 50981
// for i = 1 to enchidnas do
50916: LD_ADDR_VAR 0 11
50920: PUSH
50921: DOUBLE
50922: LD_INT 1
50924: DEC
50925: ST_TO_ADDR
50926: LD_VAR 0 4
50930: PUSH
50931: FOR_TO
50932: IFFALSE 50979
// begin hc_class = 13 ;
50934: LD_ADDR_OWVAR 28
50938: PUSH
50939: LD_INT 13
50941: ST_TO_ADDR
// hc_gallery =  ;
50942: LD_ADDR_OWVAR 33
50946: PUSH
50947: LD_STRING 
50949: ST_TO_ADDR
// animal := CreateHuman ;
50950: LD_ADDR_VAR 0 12
50954: PUSH
50955: CALL_OW 44
50959: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50960: LD_VAR 0 12
50964: PPUSH
50965: LD_VAR 0 8
50969: PPUSH
50970: LD_INT 0
50972: PPUSH
50973: CALL 52741 0 3
// end ;
50977: GO 50931
50979: POP
50980: POP
// if fishes then
50981: LD_VAR 0 7
50985: IFFALSE 51052
// for i = 1 to fishes do
50987: LD_ADDR_VAR 0 11
50991: PUSH
50992: DOUBLE
50993: LD_INT 1
50995: DEC
50996: ST_TO_ADDR
50997: LD_VAR 0 7
51001: PUSH
51002: FOR_TO
51003: IFFALSE 51050
// begin hc_class = 20 ;
51005: LD_ADDR_OWVAR 28
51009: PUSH
51010: LD_INT 20
51012: ST_TO_ADDR
// hc_gallery =  ;
51013: LD_ADDR_OWVAR 33
51017: PUSH
51018: LD_STRING 
51020: ST_TO_ADDR
// animal := CreateHuman ;
51021: LD_ADDR_VAR 0 12
51025: PUSH
51026: CALL_OW 44
51030: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
51031: LD_VAR 0 12
51035: PPUSH
51036: LD_VAR 0 9
51040: PPUSH
51041: LD_INT 0
51043: PPUSH
51044: CALL 52741 0 3
// end ;
51048: GO 51002
51050: POP
51051: POP
// end ;
51052: LD_VAR 0 10
51056: RET
// export function WantHeal ( sci , unit ) ; begin
51057: LD_INT 0
51059: PPUSH
// if GetTaskList ( sci ) > 0 then
51060: LD_VAR 0 1
51064: PPUSH
51065: CALL_OW 437
51069: PUSH
51070: LD_INT 0
51072: GREATER
51073: IFFALSE 51143
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
51075: LD_VAR 0 1
51079: PPUSH
51080: CALL_OW 437
51084: PUSH
51085: LD_INT 1
51087: ARRAY
51088: PUSH
51089: LD_INT 1
51091: ARRAY
51092: PUSH
51093: LD_STRING l
51095: EQUAL
51096: PUSH
51097: LD_VAR 0 1
51101: PPUSH
51102: CALL_OW 437
51106: PUSH
51107: LD_INT 1
51109: ARRAY
51110: PUSH
51111: LD_INT 4
51113: ARRAY
51114: PUSH
51115: LD_VAR 0 2
51119: EQUAL
51120: AND
51121: IFFALSE 51133
// result := true else
51123: LD_ADDR_VAR 0 3
51127: PUSH
51128: LD_INT 1
51130: ST_TO_ADDR
51131: GO 51141
// result := false ;
51133: LD_ADDR_VAR 0 3
51137: PUSH
51138: LD_INT 0
51140: ST_TO_ADDR
// end else
51141: GO 51151
// result := false ;
51143: LD_ADDR_VAR 0 3
51147: PUSH
51148: LD_INT 0
51150: ST_TO_ADDR
// end ;
51151: LD_VAR 0 3
51155: RET
// export function HealTarget ( sci ) ; begin
51156: LD_INT 0
51158: PPUSH
// if not sci then
51159: LD_VAR 0 1
51163: NOT
51164: IFFALSE 51168
// exit ;
51166: GO 51233
// result := 0 ;
51168: LD_ADDR_VAR 0 2
51172: PUSH
51173: LD_INT 0
51175: ST_TO_ADDR
// if GetTaskList ( sci ) then
51176: LD_VAR 0 1
51180: PPUSH
51181: CALL_OW 437
51185: IFFALSE 51233
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
51187: LD_VAR 0 1
51191: PPUSH
51192: CALL_OW 437
51196: PUSH
51197: LD_INT 1
51199: ARRAY
51200: PUSH
51201: LD_INT 1
51203: ARRAY
51204: PUSH
51205: LD_STRING l
51207: EQUAL
51208: IFFALSE 51233
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
51210: LD_ADDR_VAR 0 2
51214: PUSH
51215: LD_VAR 0 1
51219: PPUSH
51220: CALL_OW 437
51224: PUSH
51225: LD_INT 1
51227: ARRAY
51228: PUSH
51229: LD_INT 4
51231: ARRAY
51232: ST_TO_ADDR
// end ;
51233: LD_VAR 0 2
51237: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
51238: LD_INT 0
51240: PPUSH
51241: PPUSH
51242: PPUSH
51243: PPUSH
// if not base_units then
51244: LD_VAR 0 1
51248: NOT
51249: IFFALSE 51253
// exit ;
51251: GO 51340
// result := false ;
51253: LD_ADDR_VAR 0 2
51257: PUSH
51258: LD_INT 0
51260: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
51261: LD_ADDR_VAR 0 5
51265: PUSH
51266: LD_VAR 0 1
51270: PPUSH
51271: LD_INT 21
51273: PUSH
51274: LD_INT 3
51276: PUSH
51277: EMPTY
51278: LIST
51279: LIST
51280: PPUSH
51281: CALL_OW 72
51285: ST_TO_ADDR
// if not tmp then
51286: LD_VAR 0 5
51290: NOT
51291: IFFALSE 51295
// exit ;
51293: GO 51340
// for i in tmp do
51295: LD_ADDR_VAR 0 3
51299: PUSH
51300: LD_VAR 0 5
51304: PUSH
51305: FOR_IN
51306: IFFALSE 51338
// begin result := EnemyInRange ( i , 22 ) ;
51308: LD_ADDR_VAR 0 2
51312: PUSH
51313: LD_VAR 0 3
51317: PPUSH
51318: LD_INT 22
51320: PPUSH
51321: CALL 49576 0 2
51325: ST_TO_ADDR
// if result then
51326: LD_VAR 0 2
51330: IFFALSE 51336
// exit ;
51332: POP
51333: POP
51334: GO 51340
// end ;
51336: GO 51305
51338: POP
51339: POP
// end ;
51340: LD_VAR 0 2
51344: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
51345: LD_INT 0
51347: PPUSH
51348: PPUSH
// if not units then
51349: LD_VAR 0 1
51353: NOT
51354: IFFALSE 51358
// exit ;
51356: GO 51428
// result := [ ] ;
51358: LD_ADDR_VAR 0 3
51362: PUSH
51363: EMPTY
51364: ST_TO_ADDR
// for i in units do
51365: LD_ADDR_VAR 0 4
51369: PUSH
51370: LD_VAR 0 1
51374: PUSH
51375: FOR_IN
51376: IFFALSE 51426
// if GetTag ( i ) = tag then
51378: LD_VAR 0 4
51382: PPUSH
51383: CALL_OW 110
51387: PUSH
51388: LD_VAR 0 2
51392: EQUAL
51393: IFFALSE 51424
// result := Insert ( result , result + 1 , i ) ;
51395: LD_ADDR_VAR 0 3
51399: PUSH
51400: LD_VAR 0 3
51404: PPUSH
51405: LD_VAR 0 3
51409: PUSH
51410: LD_INT 1
51412: PLUS
51413: PPUSH
51414: LD_VAR 0 4
51418: PPUSH
51419: CALL_OW 2
51423: ST_TO_ADDR
51424: GO 51375
51426: POP
51427: POP
// end ;
51428: LD_VAR 0 3
51432: RET
// export function IsDriver ( un ) ; begin
51433: LD_INT 0
51435: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
51436: LD_ADDR_VAR 0 2
51440: PUSH
51441: LD_VAR 0 1
51445: PUSH
51446: LD_INT 55
51448: PUSH
51449: EMPTY
51450: LIST
51451: PPUSH
51452: CALL_OW 69
51456: IN
51457: ST_TO_ADDR
// end ;
51458: LD_VAR 0 2
51462: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
51463: LD_INT 0
51465: PPUSH
51466: PPUSH
// list := [ ] ;
51467: LD_ADDR_VAR 0 5
51471: PUSH
51472: EMPTY
51473: ST_TO_ADDR
// case d of 0 :
51474: LD_VAR 0 3
51478: PUSH
51479: LD_INT 0
51481: DOUBLE
51482: EQUAL
51483: IFTRUE 51487
51485: GO 51620
51487: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
51488: LD_ADDR_VAR 0 5
51492: PUSH
51493: LD_VAR 0 1
51497: PUSH
51498: LD_INT 4
51500: MINUS
51501: PUSH
51502: LD_VAR 0 2
51506: PUSH
51507: LD_INT 4
51509: MINUS
51510: PUSH
51511: LD_INT 2
51513: PUSH
51514: EMPTY
51515: LIST
51516: LIST
51517: LIST
51518: PUSH
51519: LD_VAR 0 1
51523: PUSH
51524: LD_INT 3
51526: MINUS
51527: PUSH
51528: LD_VAR 0 2
51532: PUSH
51533: LD_INT 1
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: PUSH
51541: LD_VAR 0 1
51545: PUSH
51546: LD_INT 4
51548: PLUS
51549: PUSH
51550: LD_VAR 0 2
51554: PUSH
51555: LD_INT 4
51557: PUSH
51558: EMPTY
51559: LIST
51560: LIST
51561: LIST
51562: PUSH
51563: LD_VAR 0 1
51567: PUSH
51568: LD_INT 3
51570: PLUS
51571: PUSH
51572: LD_VAR 0 2
51576: PUSH
51577: LD_INT 3
51579: PLUS
51580: PUSH
51581: LD_INT 5
51583: PUSH
51584: EMPTY
51585: LIST
51586: LIST
51587: LIST
51588: PUSH
51589: LD_VAR 0 1
51593: PUSH
51594: LD_VAR 0 2
51598: PUSH
51599: LD_INT 4
51601: PLUS
51602: PUSH
51603: LD_INT 0
51605: PUSH
51606: EMPTY
51607: LIST
51608: LIST
51609: LIST
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: ST_TO_ADDR
// end ; 1 :
51618: GO 52318
51620: LD_INT 1
51622: DOUBLE
51623: EQUAL
51624: IFTRUE 51628
51626: GO 51761
51628: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
51629: LD_ADDR_VAR 0 5
51633: PUSH
51634: LD_VAR 0 1
51638: PUSH
51639: LD_VAR 0 2
51643: PUSH
51644: LD_INT 4
51646: MINUS
51647: PUSH
51648: LD_INT 3
51650: PUSH
51651: EMPTY
51652: LIST
51653: LIST
51654: LIST
51655: PUSH
51656: LD_VAR 0 1
51660: PUSH
51661: LD_INT 3
51663: MINUS
51664: PUSH
51665: LD_VAR 0 2
51669: PUSH
51670: LD_INT 3
51672: MINUS
51673: PUSH
51674: LD_INT 2
51676: PUSH
51677: EMPTY
51678: LIST
51679: LIST
51680: LIST
51681: PUSH
51682: LD_VAR 0 1
51686: PUSH
51687: LD_INT 4
51689: MINUS
51690: PUSH
51691: LD_VAR 0 2
51695: PUSH
51696: LD_INT 1
51698: PUSH
51699: EMPTY
51700: LIST
51701: LIST
51702: LIST
51703: PUSH
51704: LD_VAR 0 1
51708: PUSH
51709: LD_VAR 0 2
51713: PUSH
51714: LD_INT 3
51716: PLUS
51717: PUSH
51718: LD_INT 0
51720: PUSH
51721: EMPTY
51722: LIST
51723: LIST
51724: LIST
51725: PUSH
51726: LD_VAR 0 1
51730: PUSH
51731: LD_INT 4
51733: PLUS
51734: PUSH
51735: LD_VAR 0 2
51739: PUSH
51740: LD_INT 4
51742: PLUS
51743: PUSH
51744: LD_INT 5
51746: PUSH
51747: EMPTY
51748: LIST
51749: LIST
51750: LIST
51751: PUSH
51752: EMPTY
51753: LIST
51754: LIST
51755: LIST
51756: LIST
51757: LIST
51758: ST_TO_ADDR
// end ; 2 :
51759: GO 52318
51761: LD_INT 2
51763: DOUBLE
51764: EQUAL
51765: IFTRUE 51769
51767: GO 51898
51769: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
51770: LD_ADDR_VAR 0 5
51774: PUSH
51775: LD_VAR 0 1
51779: PUSH
51780: LD_VAR 0 2
51784: PUSH
51785: LD_INT 3
51787: MINUS
51788: PUSH
51789: LD_INT 3
51791: PUSH
51792: EMPTY
51793: LIST
51794: LIST
51795: LIST
51796: PUSH
51797: LD_VAR 0 1
51801: PUSH
51802: LD_INT 4
51804: PLUS
51805: PUSH
51806: LD_VAR 0 2
51810: PUSH
51811: LD_INT 4
51813: PUSH
51814: EMPTY
51815: LIST
51816: LIST
51817: LIST
51818: PUSH
51819: LD_VAR 0 1
51823: PUSH
51824: LD_VAR 0 2
51828: PUSH
51829: LD_INT 4
51831: PLUS
51832: PUSH
51833: LD_INT 0
51835: PUSH
51836: EMPTY
51837: LIST
51838: LIST
51839: LIST
51840: PUSH
51841: LD_VAR 0 1
51845: PUSH
51846: LD_INT 3
51848: MINUS
51849: PUSH
51850: LD_VAR 0 2
51854: PUSH
51855: LD_INT 1
51857: PUSH
51858: EMPTY
51859: LIST
51860: LIST
51861: LIST
51862: PUSH
51863: LD_VAR 0 1
51867: PUSH
51868: LD_INT 4
51870: MINUS
51871: PUSH
51872: LD_VAR 0 2
51876: PUSH
51877: LD_INT 4
51879: MINUS
51880: PUSH
51881: LD_INT 2
51883: PUSH
51884: EMPTY
51885: LIST
51886: LIST
51887: LIST
51888: PUSH
51889: EMPTY
51890: LIST
51891: LIST
51892: LIST
51893: LIST
51894: LIST
51895: ST_TO_ADDR
// end ; 3 :
51896: GO 52318
51898: LD_INT 3
51900: DOUBLE
51901: EQUAL
51902: IFTRUE 51906
51904: GO 52039
51906: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
51907: LD_ADDR_VAR 0 5
51911: PUSH
51912: LD_VAR 0 1
51916: PUSH
51917: LD_INT 3
51919: PLUS
51920: PUSH
51921: LD_VAR 0 2
51925: PUSH
51926: LD_INT 4
51928: PUSH
51929: EMPTY
51930: LIST
51931: LIST
51932: LIST
51933: PUSH
51934: LD_VAR 0 1
51938: PUSH
51939: LD_INT 4
51941: PLUS
51942: PUSH
51943: LD_VAR 0 2
51947: PUSH
51948: LD_INT 4
51950: PLUS
51951: PUSH
51952: LD_INT 5
51954: PUSH
51955: EMPTY
51956: LIST
51957: LIST
51958: LIST
51959: PUSH
51960: LD_VAR 0 1
51964: PUSH
51965: LD_INT 4
51967: MINUS
51968: PUSH
51969: LD_VAR 0 2
51973: PUSH
51974: LD_INT 1
51976: PUSH
51977: EMPTY
51978: LIST
51979: LIST
51980: LIST
51981: PUSH
51982: LD_VAR 0 1
51986: PUSH
51987: LD_VAR 0 2
51991: PUSH
51992: LD_INT 4
51994: MINUS
51995: PUSH
51996: LD_INT 3
51998: PUSH
51999: EMPTY
52000: LIST
52001: LIST
52002: LIST
52003: PUSH
52004: LD_VAR 0 1
52008: PUSH
52009: LD_INT 3
52011: MINUS
52012: PUSH
52013: LD_VAR 0 2
52017: PUSH
52018: LD_INT 3
52020: MINUS
52021: PUSH
52022: LD_INT 2
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: LIST
52029: PUSH
52030: EMPTY
52031: LIST
52032: LIST
52033: LIST
52034: LIST
52035: LIST
52036: ST_TO_ADDR
// end ; 4 :
52037: GO 52318
52039: LD_INT 4
52041: DOUBLE
52042: EQUAL
52043: IFTRUE 52047
52045: GO 52180
52047: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
52048: LD_ADDR_VAR 0 5
52052: PUSH
52053: LD_VAR 0 1
52057: PUSH
52058: LD_VAR 0 2
52062: PUSH
52063: LD_INT 4
52065: PLUS
52066: PUSH
52067: LD_INT 0
52069: PUSH
52070: EMPTY
52071: LIST
52072: LIST
52073: LIST
52074: PUSH
52075: LD_VAR 0 1
52079: PUSH
52080: LD_INT 3
52082: PLUS
52083: PUSH
52084: LD_VAR 0 2
52088: PUSH
52089: LD_INT 3
52091: PLUS
52092: PUSH
52093: LD_INT 5
52095: PUSH
52096: EMPTY
52097: LIST
52098: LIST
52099: LIST
52100: PUSH
52101: LD_VAR 0 1
52105: PUSH
52106: LD_INT 4
52108: PLUS
52109: PUSH
52110: LD_VAR 0 2
52114: PUSH
52115: LD_INT 4
52117: PUSH
52118: EMPTY
52119: LIST
52120: LIST
52121: LIST
52122: PUSH
52123: LD_VAR 0 1
52127: PUSH
52128: LD_VAR 0 2
52132: PUSH
52133: LD_INT 3
52135: MINUS
52136: PUSH
52137: LD_INT 3
52139: PUSH
52140: EMPTY
52141: LIST
52142: LIST
52143: LIST
52144: PUSH
52145: LD_VAR 0 1
52149: PUSH
52150: LD_INT 4
52152: MINUS
52153: PUSH
52154: LD_VAR 0 2
52158: PUSH
52159: LD_INT 4
52161: MINUS
52162: PUSH
52163: LD_INT 2
52165: PUSH
52166: EMPTY
52167: LIST
52168: LIST
52169: LIST
52170: PUSH
52171: EMPTY
52172: LIST
52173: LIST
52174: LIST
52175: LIST
52176: LIST
52177: ST_TO_ADDR
// end ; 5 :
52178: GO 52318
52180: LD_INT 5
52182: DOUBLE
52183: EQUAL
52184: IFTRUE 52188
52186: GO 52317
52188: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
52189: LD_ADDR_VAR 0 5
52193: PUSH
52194: LD_VAR 0 1
52198: PUSH
52199: LD_INT 4
52201: MINUS
52202: PUSH
52203: LD_VAR 0 2
52207: PUSH
52208: LD_INT 1
52210: PUSH
52211: EMPTY
52212: LIST
52213: LIST
52214: LIST
52215: PUSH
52216: LD_VAR 0 1
52220: PUSH
52221: LD_VAR 0 2
52225: PUSH
52226: LD_INT 4
52228: MINUS
52229: PUSH
52230: LD_INT 3
52232: PUSH
52233: EMPTY
52234: LIST
52235: LIST
52236: LIST
52237: PUSH
52238: LD_VAR 0 1
52242: PUSH
52243: LD_INT 4
52245: PLUS
52246: PUSH
52247: LD_VAR 0 2
52251: PUSH
52252: LD_INT 4
52254: PLUS
52255: PUSH
52256: LD_INT 5
52258: PUSH
52259: EMPTY
52260: LIST
52261: LIST
52262: LIST
52263: PUSH
52264: LD_VAR 0 1
52268: PUSH
52269: LD_INT 3
52271: PLUS
52272: PUSH
52273: LD_VAR 0 2
52277: PUSH
52278: LD_INT 4
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: LIST
52285: PUSH
52286: LD_VAR 0 1
52290: PUSH
52291: LD_VAR 0 2
52295: PUSH
52296: LD_INT 3
52298: PLUS
52299: PUSH
52300: LD_INT 0
52302: PUSH
52303: EMPTY
52304: LIST
52305: LIST
52306: LIST
52307: PUSH
52308: EMPTY
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: ST_TO_ADDR
// end ; end ;
52315: GO 52318
52317: POP
// result := list ;
52318: LD_ADDR_VAR 0 4
52322: PUSH
52323: LD_VAR 0 5
52327: ST_TO_ADDR
// end ;
52328: LD_VAR 0 4
52332: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
52333: LD_INT 0
52335: PPUSH
52336: PPUSH
52337: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
52338: LD_VAR 0 1
52342: NOT
52343: PUSH
52344: LD_VAR 0 2
52348: PUSH
52349: LD_INT 1
52351: PUSH
52352: LD_INT 2
52354: PUSH
52355: LD_INT 3
52357: PUSH
52358: LD_INT 4
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: LIST
52365: LIST
52366: IN
52367: NOT
52368: OR
52369: IFFALSE 52373
// exit ;
52371: GO 52465
// tmp := [ ] ;
52373: LD_ADDR_VAR 0 5
52377: PUSH
52378: EMPTY
52379: ST_TO_ADDR
// for i in units do
52380: LD_ADDR_VAR 0 4
52384: PUSH
52385: LD_VAR 0 1
52389: PUSH
52390: FOR_IN
52391: IFFALSE 52434
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
52393: LD_ADDR_VAR 0 5
52397: PUSH
52398: LD_VAR 0 5
52402: PPUSH
52403: LD_VAR 0 5
52407: PUSH
52408: LD_INT 1
52410: PLUS
52411: PPUSH
52412: LD_VAR 0 4
52416: PPUSH
52417: LD_VAR 0 2
52421: PPUSH
52422: CALL_OW 259
52426: PPUSH
52427: CALL_OW 2
52431: ST_TO_ADDR
52432: GO 52390
52434: POP
52435: POP
// if not tmp then
52436: LD_VAR 0 5
52440: NOT
52441: IFFALSE 52445
// exit ;
52443: GO 52465
// result := SortListByListDesc ( units , tmp ) ;
52445: LD_ADDR_VAR 0 3
52449: PUSH
52450: LD_VAR 0 1
52454: PPUSH
52455: LD_VAR 0 5
52459: PPUSH
52460: CALL_OW 77
52464: ST_TO_ADDR
// end ;
52465: LD_VAR 0 3
52469: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
52470: LD_INT 0
52472: PPUSH
52473: PPUSH
52474: PPUSH
// result := false ;
52475: LD_ADDR_VAR 0 3
52479: PUSH
52480: LD_INT 0
52482: ST_TO_ADDR
// x := GetX ( building ) ;
52483: LD_ADDR_VAR 0 4
52487: PUSH
52488: LD_VAR 0 2
52492: PPUSH
52493: CALL_OW 250
52497: ST_TO_ADDR
// y := GetY ( building ) ;
52498: LD_ADDR_VAR 0 5
52502: PUSH
52503: LD_VAR 0 2
52507: PPUSH
52508: CALL_OW 251
52512: ST_TO_ADDR
// if not building or not x or not y then
52513: LD_VAR 0 2
52517: NOT
52518: PUSH
52519: LD_VAR 0 4
52523: NOT
52524: OR
52525: PUSH
52526: LD_VAR 0 5
52530: NOT
52531: OR
52532: IFFALSE 52536
// exit ;
52534: GO 52628
// if GetTaskList ( unit ) then
52536: LD_VAR 0 1
52540: PPUSH
52541: CALL_OW 437
52545: IFFALSE 52628
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52547: LD_STRING e
52549: PUSH
52550: LD_VAR 0 1
52554: PPUSH
52555: CALL_OW 437
52559: PUSH
52560: LD_INT 1
52562: ARRAY
52563: PUSH
52564: LD_INT 1
52566: ARRAY
52567: EQUAL
52568: PUSH
52569: LD_VAR 0 4
52573: PUSH
52574: LD_VAR 0 1
52578: PPUSH
52579: CALL_OW 437
52583: PUSH
52584: LD_INT 1
52586: ARRAY
52587: PUSH
52588: LD_INT 2
52590: ARRAY
52591: EQUAL
52592: AND
52593: PUSH
52594: LD_VAR 0 5
52598: PUSH
52599: LD_VAR 0 1
52603: PPUSH
52604: CALL_OW 437
52608: PUSH
52609: LD_INT 1
52611: ARRAY
52612: PUSH
52613: LD_INT 3
52615: ARRAY
52616: EQUAL
52617: AND
52618: IFFALSE 52628
// result := true end ;
52620: LD_ADDR_VAR 0 3
52624: PUSH
52625: LD_INT 1
52627: ST_TO_ADDR
// end ;
52628: LD_VAR 0 3
52632: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
52633: LD_INT 0
52635: PPUSH
// result := false ;
52636: LD_ADDR_VAR 0 4
52640: PUSH
52641: LD_INT 0
52643: ST_TO_ADDR
// if GetTaskList ( unit ) then
52644: LD_VAR 0 1
52648: PPUSH
52649: CALL_OW 437
52653: IFFALSE 52736
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
52655: LD_STRING M
52657: PUSH
52658: LD_VAR 0 1
52662: PPUSH
52663: CALL_OW 437
52667: PUSH
52668: LD_INT 1
52670: ARRAY
52671: PUSH
52672: LD_INT 1
52674: ARRAY
52675: EQUAL
52676: PUSH
52677: LD_VAR 0 2
52681: PUSH
52682: LD_VAR 0 1
52686: PPUSH
52687: CALL_OW 437
52691: PUSH
52692: LD_INT 1
52694: ARRAY
52695: PUSH
52696: LD_INT 2
52698: ARRAY
52699: EQUAL
52700: AND
52701: PUSH
52702: LD_VAR 0 3
52706: PUSH
52707: LD_VAR 0 1
52711: PPUSH
52712: CALL_OW 437
52716: PUSH
52717: LD_INT 1
52719: ARRAY
52720: PUSH
52721: LD_INT 3
52723: ARRAY
52724: EQUAL
52725: AND
52726: IFFALSE 52736
// result := true ;
52728: LD_ADDR_VAR 0 4
52732: PUSH
52733: LD_INT 1
52735: ST_TO_ADDR
// end ; end ;
52736: LD_VAR 0 4
52740: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
52741: LD_INT 0
52743: PPUSH
52744: PPUSH
52745: PPUSH
52746: PPUSH
// if not unit or not area then
52747: LD_VAR 0 1
52751: NOT
52752: PUSH
52753: LD_VAR 0 2
52757: NOT
52758: OR
52759: IFFALSE 52763
// exit ;
52761: GO 52927
// tmp := AreaToList ( area , i ) ;
52763: LD_ADDR_VAR 0 6
52767: PUSH
52768: LD_VAR 0 2
52772: PPUSH
52773: LD_VAR 0 5
52777: PPUSH
52778: CALL_OW 517
52782: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
52783: LD_ADDR_VAR 0 5
52787: PUSH
52788: DOUBLE
52789: LD_INT 1
52791: DEC
52792: ST_TO_ADDR
52793: LD_VAR 0 6
52797: PUSH
52798: LD_INT 1
52800: ARRAY
52801: PUSH
52802: FOR_TO
52803: IFFALSE 52925
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
52805: LD_ADDR_VAR 0 7
52809: PUSH
52810: LD_VAR 0 6
52814: PUSH
52815: LD_INT 1
52817: ARRAY
52818: PUSH
52819: LD_VAR 0 5
52823: ARRAY
52824: PUSH
52825: LD_VAR 0 6
52829: PUSH
52830: LD_INT 2
52832: ARRAY
52833: PUSH
52834: LD_VAR 0 5
52838: ARRAY
52839: PUSH
52840: EMPTY
52841: LIST
52842: LIST
52843: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
52844: LD_VAR 0 7
52848: PUSH
52849: LD_INT 1
52851: ARRAY
52852: PPUSH
52853: LD_VAR 0 7
52857: PUSH
52858: LD_INT 2
52860: ARRAY
52861: PPUSH
52862: CALL_OW 428
52866: PUSH
52867: LD_INT 0
52869: EQUAL
52870: IFFALSE 52923
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
52872: LD_VAR 0 1
52876: PPUSH
52877: LD_VAR 0 7
52881: PUSH
52882: LD_INT 1
52884: ARRAY
52885: PPUSH
52886: LD_VAR 0 7
52890: PUSH
52891: LD_INT 2
52893: ARRAY
52894: PPUSH
52895: LD_VAR 0 3
52899: PPUSH
52900: CALL_OW 48
// result := IsPlaced ( unit ) ;
52904: LD_ADDR_VAR 0 4
52908: PUSH
52909: LD_VAR 0 1
52913: PPUSH
52914: CALL_OW 305
52918: ST_TO_ADDR
// exit ;
52919: POP
52920: POP
52921: GO 52927
// end ; end ;
52923: GO 52802
52925: POP
52926: POP
// end ;
52927: LD_VAR 0 4
52931: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
52932: LD_INT 0
52934: PPUSH
52935: PPUSH
52936: PPUSH
// if not side or side > 8 then
52937: LD_VAR 0 1
52941: NOT
52942: PUSH
52943: LD_VAR 0 1
52947: PUSH
52948: LD_INT 8
52950: GREATER
52951: OR
52952: IFFALSE 52956
// exit ;
52954: GO 53143
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
52956: LD_ADDR_VAR 0 4
52960: PUSH
52961: LD_INT 22
52963: PUSH
52964: LD_VAR 0 1
52968: PUSH
52969: EMPTY
52970: LIST
52971: LIST
52972: PUSH
52973: LD_INT 21
52975: PUSH
52976: LD_INT 3
52978: PUSH
52979: EMPTY
52980: LIST
52981: LIST
52982: PUSH
52983: EMPTY
52984: LIST
52985: LIST
52986: PPUSH
52987: CALL_OW 69
52991: ST_TO_ADDR
// if not tmp then
52992: LD_VAR 0 4
52996: NOT
52997: IFFALSE 53001
// exit ;
52999: GO 53143
// enable_addtolog := true ;
53001: LD_ADDR_OWVAR 81
53005: PUSH
53006: LD_INT 1
53008: ST_TO_ADDR
// AddToLog ( [ ) ;
53009: LD_STRING [
53011: PPUSH
53012: CALL_OW 561
// for i in tmp do
53016: LD_ADDR_VAR 0 3
53020: PUSH
53021: LD_VAR 0 4
53025: PUSH
53026: FOR_IN
53027: IFFALSE 53134
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
53029: LD_STRING [
53031: PUSH
53032: LD_VAR 0 3
53036: PPUSH
53037: CALL_OW 266
53041: STR
53042: PUSH
53043: LD_STRING , 
53045: STR
53046: PUSH
53047: LD_VAR 0 3
53051: PPUSH
53052: CALL_OW 250
53056: STR
53057: PUSH
53058: LD_STRING , 
53060: STR
53061: PUSH
53062: LD_VAR 0 3
53066: PPUSH
53067: CALL_OW 251
53071: STR
53072: PUSH
53073: LD_STRING , 
53075: STR
53076: PUSH
53077: LD_VAR 0 3
53081: PPUSH
53082: CALL_OW 254
53086: STR
53087: PUSH
53088: LD_STRING , 
53090: STR
53091: PUSH
53092: LD_VAR 0 3
53096: PPUSH
53097: LD_INT 1
53099: PPUSH
53100: CALL_OW 268
53104: STR
53105: PUSH
53106: LD_STRING , 
53108: STR
53109: PUSH
53110: LD_VAR 0 3
53114: PPUSH
53115: LD_INT 2
53117: PPUSH
53118: CALL_OW 268
53122: STR
53123: PUSH
53124: LD_STRING ],
53126: STR
53127: PPUSH
53128: CALL_OW 561
// end ;
53132: GO 53026
53134: POP
53135: POP
// AddToLog ( ]; ) ;
53136: LD_STRING ];
53138: PPUSH
53139: CALL_OW 561
// end ;
53143: LD_VAR 0 2
53147: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
53148: LD_INT 0
53150: PPUSH
53151: PPUSH
53152: PPUSH
53153: PPUSH
53154: PPUSH
// if not area or not rate or not max then
53155: LD_VAR 0 1
53159: NOT
53160: PUSH
53161: LD_VAR 0 2
53165: NOT
53166: OR
53167: PUSH
53168: LD_VAR 0 4
53172: NOT
53173: OR
53174: IFFALSE 53178
// exit ;
53176: GO 53370
// while 1 do
53178: LD_INT 1
53180: IFFALSE 53370
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
53182: LD_ADDR_VAR 0 9
53186: PUSH
53187: LD_VAR 0 1
53191: PPUSH
53192: LD_INT 1
53194: PPUSH
53195: CALL_OW 287
53199: PUSH
53200: LD_INT 10
53202: MUL
53203: ST_TO_ADDR
// r := rate / 10 ;
53204: LD_ADDR_VAR 0 7
53208: PUSH
53209: LD_VAR 0 2
53213: PUSH
53214: LD_INT 10
53216: DIVREAL
53217: ST_TO_ADDR
// time := 1 1$00 ;
53218: LD_ADDR_VAR 0 8
53222: PUSH
53223: LD_INT 2100
53225: ST_TO_ADDR
// if amount < min then
53226: LD_VAR 0 9
53230: PUSH
53231: LD_VAR 0 3
53235: LESS
53236: IFFALSE 53254
// r := r * 2 else
53238: LD_ADDR_VAR 0 7
53242: PUSH
53243: LD_VAR 0 7
53247: PUSH
53248: LD_INT 2
53250: MUL
53251: ST_TO_ADDR
53252: GO 53280
// if amount > max then
53254: LD_VAR 0 9
53258: PUSH
53259: LD_VAR 0 4
53263: GREATER
53264: IFFALSE 53280
// r := r / 2 ;
53266: LD_ADDR_VAR 0 7
53270: PUSH
53271: LD_VAR 0 7
53275: PUSH
53276: LD_INT 2
53278: DIVREAL
53279: ST_TO_ADDR
// time := time / r ;
53280: LD_ADDR_VAR 0 8
53284: PUSH
53285: LD_VAR 0 8
53289: PUSH
53290: LD_VAR 0 7
53294: DIVREAL
53295: ST_TO_ADDR
// if time < 0 then
53296: LD_VAR 0 8
53300: PUSH
53301: LD_INT 0
53303: LESS
53304: IFFALSE 53321
// time := time * - 1 ;
53306: LD_ADDR_VAR 0 8
53310: PUSH
53311: LD_VAR 0 8
53315: PUSH
53316: LD_INT 1
53318: NEG
53319: MUL
53320: ST_TO_ADDR
// wait ( time ) ;
53321: LD_VAR 0 8
53325: PPUSH
53326: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
53330: LD_INT 35
53332: PPUSH
53333: LD_INT 875
53335: PPUSH
53336: CALL_OW 12
53340: PPUSH
53341: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
53345: LD_INT 1
53347: PPUSH
53348: LD_INT 5
53350: PPUSH
53351: CALL_OW 12
53355: PPUSH
53356: LD_VAR 0 1
53360: PPUSH
53361: LD_INT 1
53363: PPUSH
53364: CALL_OW 55
// end ;
53368: GO 53178
// end ;
53370: LD_VAR 0 5
53374: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
53375: LD_INT 0
53377: PPUSH
53378: PPUSH
53379: PPUSH
53380: PPUSH
53381: PPUSH
53382: PPUSH
53383: PPUSH
53384: PPUSH
// if not turrets or not factories then
53385: LD_VAR 0 1
53389: NOT
53390: PUSH
53391: LD_VAR 0 2
53395: NOT
53396: OR
53397: IFFALSE 53401
// exit ;
53399: GO 53708
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
53401: LD_ADDR_VAR 0 10
53405: PUSH
53406: LD_INT 5
53408: PUSH
53409: LD_INT 6
53411: PUSH
53412: EMPTY
53413: LIST
53414: LIST
53415: PUSH
53416: LD_INT 2
53418: PUSH
53419: LD_INT 4
53421: PUSH
53422: EMPTY
53423: LIST
53424: LIST
53425: PUSH
53426: LD_INT 3
53428: PUSH
53429: LD_INT 5
53431: PUSH
53432: EMPTY
53433: LIST
53434: LIST
53435: PUSH
53436: EMPTY
53437: LIST
53438: LIST
53439: LIST
53440: PUSH
53441: LD_INT 24
53443: PUSH
53444: LD_INT 25
53446: PUSH
53447: EMPTY
53448: LIST
53449: LIST
53450: PUSH
53451: LD_INT 23
53453: PUSH
53454: LD_INT 27
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: PUSH
53461: EMPTY
53462: LIST
53463: LIST
53464: PUSH
53465: LD_INT 42
53467: PUSH
53468: LD_INT 43
53470: PUSH
53471: EMPTY
53472: LIST
53473: LIST
53474: PUSH
53475: LD_INT 44
53477: PUSH
53478: LD_INT 46
53480: PUSH
53481: EMPTY
53482: LIST
53483: LIST
53484: PUSH
53485: LD_INT 45
53487: PUSH
53488: LD_INT 47
53490: PUSH
53491: EMPTY
53492: LIST
53493: LIST
53494: PUSH
53495: EMPTY
53496: LIST
53497: LIST
53498: LIST
53499: PUSH
53500: EMPTY
53501: LIST
53502: LIST
53503: LIST
53504: ST_TO_ADDR
// result := [ ] ;
53505: LD_ADDR_VAR 0 3
53509: PUSH
53510: EMPTY
53511: ST_TO_ADDR
// for i in turrets do
53512: LD_ADDR_VAR 0 4
53516: PUSH
53517: LD_VAR 0 1
53521: PUSH
53522: FOR_IN
53523: IFFALSE 53706
// begin nat := GetNation ( i ) ;
53525: LD_ADDR_VAR 0 7
53529: PUSH
53530: LD_VAR 0 4
53534: PPUSH
53535: CALL_OW 248
53539: ST_TO_ADDR
// weapon := 0 ;
53540: LD_ADDR_VAR 0 8
53544: PUSH
53545: LD_INT 0
53547: ST_TO_ADDR
// if not nat then
53548: LD_VAR 0 7
53552: NOT
53553: IFFALSE 53557
// continue ;
53555: GO 53522
// for j in list [ nat ] do
53557: LD_ADDR_VAR 0 5
53561: PUSH
53562: LD_VAR 0 10
53566: PUSH
53567: LD_VAR 0 7
53571: ARRAY
53572: PUSH
53573: FOR_IN
53574: IFFALSE 53615
// if GetBWeapon ( i ) = j [ 1 ] then
53576: LD_VAR 0 4
53580: PPUSH
53581: CALL_OW 269
53585: PUSH
53586: LD_VAR 0 5
53590: PUSH
53591: LD_INT 1
53593: ARRAY
53594: EQUAL
53595: IFFALSE 53613
// begin weapon := j [ 2 ] ;
53597: LD_ADDR_VAR 0 8
53601: PUSH
53602: LD_VAR 0 5
53606: PUSH
53607: LD_INT 2
53609: ARRAY
53610: ST_TO_ADDR
// break ;
53611: GO 53615
// end ;
53613: GO 53573
53615: POP
53616: POP
// if not weapon then
53617: LD_VAR 0 8
53621: NOT
53622: IFFALSE 53626
// continue ;
53624: GO 53522
// for k in factories do
53626: LD_ADDR_VAR 0 6
53630: PUSH
53631: LD_VAR 0 2
53635: PUSH
53636: FOR_IN
53637: IFFALSE 53702
// begin weapons := AvailableWeaponList ( k ) ;
53639: LD_ADDR_VAR 0 9
53643: PUSH
53644: LD_VAR 0 6
53648: PPUSH
53649: CALL_OW 478
53653: ST_TO_ADDR
// if not weapons then
53654: LD_VAR 0 9
53658: NOT
53659: IFFALSE 53663
// continue ;
53661: GO 53636
// if weapon in weapons then
53663: LD_VAR 0 8
53667: PUSH
53668: LD_VAR 0 9
53672: IN
53673: IFFALSE 53700
// begin result := [ i , weapon ] ;
53675: LD_ADDR_VAR 0 3
53679: PUSH
53680: LD_VAR 0 4
53684: PUSH
53685: LD_VAR 0 8
53689: PUSH
53690: EMPTY
53691: LIST
53692: LIST
53693: ST_TO_ADDR
// exit ;
53694: POP
53695: POP
53696: POP
53697: POP
53698: GO 53708
// end ; end ;
53700: GO 53636
53702: POP
53703: POP
// end ;
53704: GO 53522
53706: POP
53707: POP
// end ;
53708: LD_VAR 0 3
53712: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
53713: LD_INT 0
53715: PPUSH
// if not side or side > 8 then
53716: LD_VAR 0 3
53720: NOT
53721: PUSH
53722: LD_VAR 0 3
53726: PUSH
53727: LD_INT 8
53729: GREATER
53730: OR
53731: IFFALSE 53735
// exit ;
53733: GO 53794
// if not range then
53735: LD_VAR 0 4
53739: NOT
53740: IFFALSE 53751
// range := - 12 ;
53742: LD_ADDR_VAR 0 4
53746: PUSH
53747: LD_INT 12
53749: NEG
53750: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
53751: LD_VAR 0 1
53755: PPUSH
53756: LD_VAR 0 2
53760: PPUSH
53761: LD_VAR 0 3
53765: PPUSH
53766: LD_VAR 0 4
53770: PPUSH
53771: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
53775: LD_VAR 0 1
53779: PPUSH
53780: LD_VAR 0 2
53784: PPUSH
53785: LD_VAR 0 3
53789: PPUSH
53790: CALL_OW 331
// end ;
53794: LD_VAR 0 5
53798: RET
// export function Video ( mode ) ; begin
53799: LD_INT 0
53801: PPUSH
// ingame_video = mode ;
53802: LD_ADDR_OWVAR 52
53806: PUSH
53807: LD_VAR 0 1
53811: ST_TO_ADDR
// interface_hidden = mode ;
53812: LD_ADDR_OWVAR 54
53816: PUSH
53817: LD_VAR 0 1
53821: ST_TO_ADDR
// end ;
53822: LD_VAR 0 2
53826: RET
// export function Join ( array , element ) ; begin
53827: LD_INT 0
53829: PPUSH
// result := Replace ( array , array + 1 , element ) ;
53830: LD_ADDR_VAR 0 3
53834: PUSH
53835: LD_VAR 0 1
53839: PPUSH
53840: LD_VAR 0 1
53844: PUSH
53845: LD_INT 1
53847: PLUS
53848: PPUSH
53849: LD_VAR 0 2
53853: PPUSH
53854: CALL_OW 1
53858: ST_TO_ADDR
// end ;
53859: LD_VAR 0 3
53863: RET
// export function JoinUnion ( array , element ) ; begin
53864: LD_INT 0
53866: PPUSH
// result := array union element ;
53867: LD_ADDR_VAR 0 3
53871: PUSH
53872: LD_VAR 0 1
53876: PUSH
53877: LD_VAR 0 2
53881: UNION
53882: ST_TO_ADDR
// end ;
53883: LD_VAR 0 3
53887: RET
// export function GetBehemoths ( side ) ; begin
53888: LD_INT 0
53890: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
53891: LD_ADDR_VAR 0 2
53895: PUSH
53896: LD_INT 22
53898: PUSH
53899: LD_VAR 0 1
53903: PUSH
53904: EMPTY
53905: LIST
53906: LIST
53907: PUSH
53908: LD_INT 31
53910: PUSH
53911: LD_INT 25
53913: PUSH
53914: EMPTY
53915: LIST
53916: LIST
53917: PUSH
53918: EMPTY
53919: LIST
53920: LIST
53921: PPUSH
53922: CALL_OW 69
53926: ST_TO_ADDR
// end ;
53927: LD_VAR 0 2
53931: RET
// export function Shuffle ( array ) ; var i , index ; begin
53932: LD_INT 0
53934: PPUSH
53935: PPUSH
53936: PPUSH
// result := [ ] ;
53937: LD_ADDR_VAR 0 2
53941: PUSH
53942: EMPTY
53943: ST_TO_ADDR
// if not array then
53944: LD_VAR 0 1
53948: NOT
53949: IFFALSE 53953
// exit ;
53951: GO 54052
// Randomize ;
53953: CALL_OW 10
// for i = array downto 1 do
53957: LD_ADDR_VAR 0 3
53961: PUSH
53962: DOUBLE
53963: LD_VAR 0 1
53967: INC
53968: ST_TO_ADDR
53969: LD_INT 1
53971: PUSH
53972: FOR_DOWNTO
53973: IFFALSE 54050
// begin index := rand ( 1 , array ) ;
53975: LD_ADDR_VAR 0 4
53979: PUSH
53980: LD_INT 1
53982: PPUSH
53983: LD_VAR 0 1
53987: PPUSH
53988: CALL_OW 12
53992: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
53993: LD_ADDR_VAR 0 2
53997: PUSH
53998: LD_VAR 0 2
54002: PPUSH
54003: LD_VAR 0 2
54007: PUSH
54008: LD_INT 1
54010: PLUS
54011: PPUSH
54012: LD_VAR 0 1
54016: PUSH
54017: LD_VAR 0 4
54021: ARRAY
54022: PPUSH
54023: CALL_OW 2
54027: ST_TO_ADDR
// array := Delete ( array , index ) ;
54028: LD_ADDR_VAR 0 1
54032: PUSH
54033: LD_VAR 0 1
54037: PPUSH
54038: LD_VAR 0 4
54042: PPUSH
54043: CALL_OW 3
54047: ST_TO_ADDR
// end ;
54048: GO 53972
54050: POP
54051: POP
// end ;
54052: LD_VAR 0 2
54056: RET
// export function GetBaseMaterials ( base ) ; begin
54057: LD_INT 0
54059: PPUSH
// result := [ 0 , 0 , 0 ] ;
54060: LD_ADDR_VAR 0 2
54064: PUSH
54065: LD_INT 0
54067: PUSH
54068: LD_INT 0
54070: PUSH
54071: LD_INT 0
54073: PUSH
54074: EMPTY
54075: LIST
54076: LIST
54077: LIST
54078: ST_TO_ADDR
// if not base then
54079: LD_VAR 0 1
54083: NOT
54084: IFFALSE 54088
// exit ;
54086: GO 54137
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
54088: LD_ADDR_VAR 0 2
54092: PUSH
54093: LD_VAR 0 1
54097: PPUSH
54098: LD_INT 1
54100: PPUSH
54101: CALL_OW 275
54105: PUSH
54106: LD_VAR 0 1
54110: PPUSH
54111: LD_INT 2
54113: PPUSH
54114: CALL_OW 275
54118: PUSH
54119: LD_VAR 0 1
54123: PPUSH
54124: LD_INT 3
54126: PPUSH
54127: CALL_OW 275
54131: PUSH
54132: EMPTY
54133: LIST
54134: LIST
54135: LIST
54136: ST_TO_ADDR
// end ;
54137: LD_VAR 0 2
54141: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
54142: LD_INT 0
54144: PPUSH
54145: PPUSH
// result := array ;
54146: LD_ADDR_VAR 0 3
54150: PUSH
54151: LD_VAR 0 1
54155: ST_TO_ADDR
// if size > 0 then
54156: LD_VAR 0 2
54160: PUSH
54161: LD_INT 0
54163: GREATER
54164: IFFALSE 54210
// for i := array downto size do
54166: LD_ADDR_VAR 0 4
54170: PUSH
54171: DOUBLE
54172: LD_VAR 0 1
54176: INC
54177: ST_TO_ADDR
54178: LD_VAR 0 2
54182: PUSH
54183: FOR_DOWNTO
54184: IFFALSE 54208
// result := Delete ( result , result ) ;
54186: LD_ADDR_VAR 0 3
54190: PUSH
54191: LD_VAR 0 3
54195: PPUSH
54196: LD_VAR 0 3
54200: PPUSH
54201: CALL_OW 3
54205: ST_TO_ADDR
54206: GO 54183
54208: POP
54209: POP
// end ;
54210: LD_VAR 0 3
54214: RET
// export function ComExit ( unit ) ; var tmp ; begin
54215: LD_INT 0
54217: PPUSH
54218: PPUSH
// if not IsInUnit ( unit ) then
54219: LD_VAR 0 1
54223: PPUSH
54224: CALL_OW 310
54228: NOT
54229: IFFALSE 54233
// exit ;
54231: GO 54293
// tmp := IsInUnit ( unit ) ;
54233: LD_ADDR_VAR 0 3
54237: PUSH
54238: LD_VAR 0 1
54242: PPUSH
54243: CALL_OW 310
54247: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
54248: LD_VAR 0 3
54252: PPUSH
54253: CALL_OW 247
54257: PUSH
54258: LD_INT 2
54260: EQUAL
54261: IFFALSE 54274
// ComExitVehicle ( unit ) else
54263: LD_VAR 0 1
54267: PPUSH
54268: CALL_OW 121
54272: GO 54283
// ComExitBuilding ( unit ) ;
54274: LD_VAR 0 1
54278: PPUSH
54279: CALL_OW 122
// result := tmp ;
54283: LD_ADDR_VAR 0 2
54287: PUSH
54288: LD_VAR 0 3
54292: ST_TO_ADDR
// end ;
54293: LD_VAR 0 2
54297: RET
// export function ComExitAll ( units ) ; var i ; begin
54298: LD_INT 0
54300: PPUSH
54301: PPUSH
// if not units then
54302: LD_VAR 0 1
54306: NOT
54307: IFFALSE 54311
// exit ;
54309: GO 54337
// for i in units do
54311: LD_ADDR_VAR 0 3
54315: PUSH
54316: LD_VAR 0 1
54320: PUSH
54321: FOR_IN
54322: IFFALSE 54335
// ComExit ( i ) ;
54324: LD_VAR 0 3
54328: PPUSH
54329: CALL 54215 0 1
54333: GO 54321
54335: POP
54336: POP
// end ;
54337: LD_VAR 0 2
54341: RET
// export function ResetHc ; begin
54342: LD_INT 0
54344: PPUSH
// InitHc ;
54345: CALL_OW 19
// hc_importance := 0 ;
54349: LD_ADDR_OWVAR 32
54353: PUSH
54354: LD_INT 0
54356: ST_TO_ADDR
// end ;
54357: LD_VAR 0 1
54361: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
54362: LD_INT 0
54364: PPUSH
54365: PPUSH
54366: PPUSH
// _x := ( x1 + x2 ) div 2 ;
54367: LD_ADDR_VAR 0 6
54371: PUSH
54372: LD_VAR 0 1
54376: PUSH
54377: LD_VAR 0 3
54381: PLUS
54382: PUSH
54383: LD_INT 2
54385: DIV
54386: ST_TO_ADDR
// if _x < 0 then
54387: LD_VAR 0 6
54391: PUSH
54392: LD_INT 0
54394: LESS
54395: IFFALSE 54412
// _x := _x * - 1 ;
54397: LD_ADDR_VAR 0 6
54401: PUSH
54402: LD_VAR 0 6
54406: PUSH
54407: LD_INT 1
54409: NEG
54410: MUL
54411: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
54412: LD_ADDR_VAR 0 7
54416: PUSH
54417: LD_VAR 0 2
54421: PUSH
54422: LD_VAR 0 4
54426: PLUS
54427: PUSH
54428: LD_INT 2
54430: DIV
54431: ST_TO_ADDR
// if _y < 0 then
54432: LD_VAR 0 7
54436: PUSH
54437: LD_INT 0
54439: LESS
54440: IFFALSE 54457
// _y := _y * - 1 ;
54442: LD_ADDR_VAR 0 7
54446: PUSH
54447: LD_VAR 0 7
54451: PUSH
54452: LD_INT 1
54454: NEG
54455: MUL
54456: ST_TO_ADDR
// result := [ _x , _y ] ;
54457: LD_ADDR_VAR 0 5
54461: PUSH
54462: LD_VAR 0 6
54466: PUSH
54467: LD_VAR 0 7
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: ST_TO_ADDR
// end ;
54476: LD_VAR 0 5
54480: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
54481: LD_INT 0
54483: PPUSH
54484: PPUSH
54485: PPUSH
54486: PPUSH
// task := GetTaskList ( unit ) ;
54487: LD_ADDR_VAR 0 7
54491: PUSH
54492: LD_VAR 0 1
54496: PPUSH
54497: CALL_OW 437
54501: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
54502: LD_VAR 0 7
54506: NOT
54507: PUSH
54508: LD_VAR 0 1
54512: PPUSH
54513: LD_VAR 0 2
54517: PPUSH
54518: CALL_OW 308
54522: NOT
54523: AND
54524: IFFALSE 54528
// exit ;
54526: GO 54646
// if IsInArea ( unit , area ) then
54528: LD_VAR 0 1
54532: PPUSH
54533: LD_VAR 0 2
54537: PPUSH
54538: CALL_OW 308
54542: IFFALSE 54560
// begin ComMoveToArea ( unit , goAway ) ;
54544: LD_VAR 0 1
54548: PPUSH
54549: LD_VAR 0 3
54553: PPUSH
54554: CALL_OW 113
// exit ;
54558: GO 54646
// end ; if task [ 1 ] [ 1 ] <> M then
54560: LD_VAR 0 7
54564: PUSH
54565: LD_INT 1
54567: ARRAY
54568: PUSH
54569: LD_INT 1
54571: ARRAY
54572: PUSH
54573: LD_STRING M
54575: NONEQUAL
54576: IFFALSE 54580
// exit ;
54578: GO 54646
// x := task [ 1 ] [ 2 ] ;
54580: LD_ADDR_VAR 0 5
54584: PUSH
54585: LD_VAR 0 7
54589: PUSH
54590: LD_INT 1
54592: ARRAY
54593: PUSH
54594: LD_INT 2
54596: ARRAY
54597: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
54598: LD_ADDR_VAR 0 6
54602: PUSH
54603: LD_VAR 0 7
54607: PUSH
54608: LD_INT 1
54610: ARRAY
54611: PUSH
54612: LD_INT 3
54614: ARRAY
54615: ST_TO_ADDR
// if InArea ( x , y , area ) then
54616: LD_VAR 0 5
54620: PPUSH
54621: LD_VAR 0 6
54625: PPUSH
54626: LD_VAR 0 2
54630: PPUSH
54631: CALL_OW 309
54635: IFFALSE 54646
// ComStop ( unit ) ;
54637: LD_VAR 0 1
54641: PPUSH
54642: CALL_OW 141
// end ;
54646: LD_VAR 0 4
54650: RET
// export function Abs ( value ) ; begin
54651: LD_INT 0
54653: PPUSH
// result := value ;
54654: LD_ADDR_VAR 0 2
54658: PUSH
54659: LD_VAR 0 1
54663: ST_TO_ADDR
// if value < 0 then
54664: LD_VAR 0 1
54668: PUSH
54669: LD_INT 0
54671: LESS
54672: IFFALSE 54689
// result := value * - 1 ;
54674: LD_ADDR_VAR 0 2
54678: PUSH
54679: LD_VAR 0 1
54683: PUSH
54684: LD_INT 1
54686: NEG
54687: MUL
54688: ST_TO_ADDR
// end ;
54689: LD_VAR 0 2
54693: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
54694: LD_INT 0
54696: PPUSH
54697: PPUSH
54698: PPUSH
54699: PPUSH
54700: PPUSH
54701: PPUSH
54702: PPUSH
54703: PPUSH
// if not unit or not building then
54704: LD_VAR 0 1
54708: NOT
54709: PUSH
54710: LD_VAR 0 2
54714: NOT
54715: OR
54716: IFFALSE 54720
// exit ;
54718: GO 54946
// x := GetX ( building ) ;
54720: LD_ADDR_VAR 0 4
54724: PUSH
54725: LD_VAR 0 2
54729: PPUSH
54730: CALL_OW 250
54734: ST_TO_ADDR
// y := GetY ( building ) ;
54735: LD_ADDR_VAR 0 6
54739: PUSH
54740: LD_VAR 0 2
54744: PPUSH
54745: CALL_OW 251
54749: ST_TO_ADDR
// d := GetDir ( building ) ;
54750: LD_ADDR_VAR 0 8
54754: PUSH
54755: LD_VAR 0 2
54759: PPUSH
54760: CALL_OW 254
54764: ST_TO_ADDR
// r := 4 ;
54765: LD_ADDR_VAR 0 9
54769: PUSH
54770: LD_INT 4
54772: ST_TO_ADDR
// for i := 1 to 5 do
54773: LD_ADDR_VAR 0 10
54777: PUSH
54778: DOUBLE
54779: LD_INT 1
54781: DEC
54782: ST_TO_ADDR
54783: LD_INT 5
54785: PUSH
54786: FOR_TO
54787: IFFALSE 54944
// begin _x := ShiftX ( x , d , r + i ) ;
54789: LD_ADDR_VAR 0 5
54793: PUSH
54794: LD_VAR 0 4
54798: PPUSH
54799: LD_VAR 0 8
54803: PPUSH
54804: LD_VAR 0 9
54808: PUSH
54809: LD_VAR 0 10
54813: PLUS
54814: PPUSH
54815: CALL_OW 272
54819: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
54820: LD_ADDR_VAR 0 7
54824: PUSH
54825: LD_VAR 0 6
54829: PPUSH
54830: LD_VAR 0 8
54834: PPUSH
54835: LD_VAR 0 9
54839: PUSH
54840: LD_VAR 0 10
54844: PLUS
54845: PPUSH
54846: CALL_OW 273
54850: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
54851: LD_VAR 0 5
54855: PPUSH
54856: LD_VAR 0 7
54860: PPUSH
54861: CALL_OW 488
54865: PUSH
54866: LD_VAR 0 5
54870: PPUSH
54871: LD_VAR 0 7
54875: PPUSH
54876: CALL_OW 428
54880: PPUSH
54881: CALL_OW 247
54885: PUSH
54886: LD_INT 3
54888: PUSH
54889: LD_INT 2
54891: PUSH
54892: EMPTY
54893: LIST
54894: LIST
54895: IN
54896: NOT
54897: AND
54898: IFFALSE 54942
// begin ComMoveXY ( unit , _x , _y ) ;
54900: LD_VAR 0 1
54904: PPUSH
54905: LD_VAR 0 5
54909: PPUSH
54910: LD_VAR 0 7
54914: PPUSH
54915: CALL_OW 111
// result := [ _x , _y ] ;
54919: LD_ADDR_VAR 0 3
54923: PUSH
54924: LD_VAR 0 5
54928: PUSH
54929: LD_VAR 0 7
54933: PUSH
54934: EMPTY
54935: LIST
54936: LIST
54937: ST_TO_ADDR
// exit ;
54938: POP
54939: POP
54940: GO 54946
// end ; end ;
54942: GO 54786
54944: POP
54945: POP
// end ;
54946: LD_VAR 0 3
54950: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
54951: LD_INT 0
54953: PPUSH
54954: PPUSH
54955: PPUSH
// result := 0 ;
54956: LD_ADDR_VAR 0 3
54960: PUSH
54961: LD_INT 0
54963: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
54964: LD_VAR 0 1
54968: PUSH
54969: LD_INT 0
54971: LESS
54972: PUSH
54973: LD_VAR 0 1
54977: PUSH
54978: LD_INT 8
54980: GREATER
54981: OR
54982: PUSH
54983: LD_VAR 0 2
54987: PUSH
54988: LD_INT 0
54990: LESS
54991: OR
54992: PUSH
54993: LD_VAR 0 2
54997: PUSH
54998: LD_INT 8
55000: GREATER
55001: OR
55002: IFFALSE 55006
// exit ;
55004: GO 55081
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
55006: LD_ADDR_VAR 0 4
55010: PUSH
55011: LD_INT 22
55013: PUSH
55014: LD_VAR 0 2
55018: PUSH
55019: EMPTY
55020: LIST
55021: LIST
55022: PPUSH
55023: CALL_OW 69
55027: PUSH
55028: FOR_IN
55029: IFFALSE 55079
// begin un := UnitShoot ( i ) ;
55031: LD_ADDR_VAR 0 5
55035: PUSH
55036: LD_VAR 0 4
55040: PPUSH
55041: CALL_OW 504
55045: ST_TO_ADDR
// if GetSide ( un ) = side1 then
55046: LD_VAR 0 5
55050: PPUSH
55051: CALL_OW 255
55055: PUSH
55056: LD_VAR 0 1
55060: EQUAL
55061: IFFALSE 55077
// begin result := un ;
55063: LD_ADDR_VAR 0 3
55067: PUSH
55068: LD_VAR 0 5
55072: ST_TO_ADDR
// exit ;
55073: POP
55074: POP
55075: GO 55081
// end ; end ;
55077: GO 55028
55079: POP
55080: POP
// end ;
55081: LD_VAR 0 3
55085: RET
// export function GetCargoBay ( units ) ; begin
55086: LD_INT 0
55088: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
55089: LD_ADDR_VAR 0 2
55093: PUSH
55094: LD_VAR 0 1
55098: PPUSH
55099: LD_INT 2
55101: PUSH
55102: LD_INT 34
55104: PUSH
55105: LD_INT 12
55107: PUSH
55108: EMPTY
55109: LIST
55110: LIST
55111: PUSH
55112: LD_INT 34
55114: PUSH
55115: LD_INT 51
55117: PUSH
55118: EMPTY
55119: LIST
55120: LIST
55121: PUSH
55122: LD_INT 34
55124: PUSH
55125: LD_INT 32
55127: PUSH
55128: EMPTY
55129: LIST
55130: LIST
55131: PUSH
55132: LD_INT 34
55134: PUSH
55135: LD_EXP 2
55139: PUSH
55140: EMPTY
55141: LIST
55142: LIST
55143: PUSH
55144: EMPTY
55145: LIST
55146: LIST
55147: LIST
55148: LIST
55149: LIST
55150: PPUSH
55151: CALL_OW 72
55155: ST_TO_ADDR
// end ; end_of_file
55156: LD_VAR 0 2
55160: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
55161: LD_INT 0
55163: PPUSH
55164: PPUSH
55165: PPUSH
55166: PPUSH
55167: PPUSH
55168: PPUSH
55169: PPUSH
55170: PPUSH
55171: PPUSH
55172: PPUSH
55173: PPUSH
55174: PPUSH
55175: PPUSH
55176: PPUSH
55177: PPUSH
55178: PPUSH
55179: PPUSH
55180: PPUSH
55181: PPUSH
55182: PPUSH
55183: PPUSH
55184: PPUSH
55185: PPUSH
55186: PPUSH
55187: PPUSH
55188: PPUSH
55189: PPUSH
55190: PPUSH
55191: PPUSH
55192: PPUSH
55193: PPUSH
55194: PPUSH
55195: PPUSH
55196: PPUSH
// if not list then
55197: LD_VAR 0 1
55201: NOT
55202: IFFALSE 55206
// exit ;
55204: GO 59865
// base := list [ 1 ] ;
55206: LD_ADDR_VAR 0 3
55210: PUSH
55211: LD_VAR 0 1
55215: PUSH
55216: LD_INT 1
55218: ARRAY
55219: ST_TO_ADDR
// group := list [ 2 ] ;
55220: LD_ADDR_VAR 0 4
55224: PUSH
55225: LD_VAR 0 1
55229: PUSH
55230: LD_INT 2
55232: ARRAY
55233: ST_TO_ADDR
// path := list [ 3 ] ;
55234: LD_ADDR_VAR 0 5
55238: PUSH
55239: LD_VAR 0 1
55243: PUSH
55244: LD_INT 3
55246: ARRAY
55247: ST_TO_ADDR
// flags := list [ 4 ] ;
55248: LD_ADDR_VAR 0 6
55252: PUSH
55253: LD_VAR 0 1
55257: PUSH
55258: LD_INT 4
55260: ARRAY
55261: ST_TO_ADDR
// mined := [ ] ;
55262: LD_ADDR_VAR 0 27
55266: PUSH
55267: EMPTY
55268: ST_TO_ADDR
// bombed := [ ] ;
55269: LD_ADDR_VAR 0 28
55273: PUSH
55274: EMPTY
55275: ST_TO_ADDR
// healers := [ ] ;
55276: LD_ADDR_VAR 0 31
55280: PUSH
55281: EMPTY
55282: ST_TO_ADDR
// to_heal := [ ] ;
55283: LD_ADDR_VAR 0 30
55287: PUSH
55288: EMPTY
55289: ST_TO_ADDR
// repairs := [ ] ;
55290: LD_ADDR_VAR 0 33
55294: PUSH
55295: EMPTY
55296: ST_TO_ADDR
// to_repair := [ ] ;
55297: LD_ADDR_VAR 0 32
55301: PUSH
55302: EMPTY
55303: ST_TO_ADDR
// if not group or not path then
55304: LD_VAR 0 4
55308: NOT
55309: PUSH
55310: LD_VAR 0 5
55314: NOT
55315: OR
55316: IFFALSE 55320
// exit ;
55318: GO 59865
// side := GetSide ( group [ 1 ] ) ;
55320: LD_ADDR_VAR 0 35
55324: PUSH
55325: LD_VAR 0 4
55329: PUSH
55330: LD_INT 1
55332: ARRAY
55333: PPUSH
55334: CALL_OW 255
55338: ST_TO_ADDR
// if flags then
55339: LD_VAR 0 6
55343: IFFALSE 55487
// begin f_ignore_area := flags [ 1 ] ;
55345: LD_ADDR_VAR 0 17
55349: PUSH
55350: LD_VAR 0 6
55354: PUSH
55355: LD_INT 1
55357: ARRAY
55358: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
55359: LD_ADDR_VAR 0 18
55363: PUSH
55364: LD_VAR 0 6
55368: PUSH
55369: LD_INT 2
55371: ARRAY
55372: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
55373: LD_ADDR_VAR 0 19
55377: PUSH
55378: LD_VAR 0 6
55382: PUSH
55383: LD_INT 3
55385: ARRAY
55386: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
55387: LD_ADDR_VAR 0 20
55391: PUSH
55392: LD_VAR 0 6
55396: PUSH
55397: LD_INT 4
55399: ARRAY
55400: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
55401: LD_ADDR_VAR 0 21
55405: PUSH
55406: LD_VAR 0 6
55410: PUSH
55411: LD_INT 5
55413: ARRAY
55414: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
55415: LD_ADDR_VAR 0 22
55419: PUSH
55420: LD_VAR 0 6
55424: PUSH
55425: LD_INT 6
55427: ARRAY
55428: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
55429: LD_ADDR_VAR 0 23
55433: PUSH
55434: LD_VAR 0 6
55438: PUSH
55439: LD_INT 7
55441: ARRAY
55442: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
55443: LD_ADDR_VAR 0 24
55447: PUSH
55448: LD_VAR 0 6
55452: PUSH
55453: LD_INT 8
55455: ARRAY
55456: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
55457: LD_ADDR_VAR 0 25
55461: PUSH
55462: LD_VAR 0 6
55466: PUSH
55467: LD_INT 9
55469: ARRAY
55470: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
55471: LD_ADDR_VAR 0 26
55475: PUSH
55476: LD_VAR 0 6
55480: PUSH
55481: LD_INT 10
55483: ARRAY
55484: ST_TO_ADDR
// end else
55485: GO 55567
// begin f_ignore_area := false ;
55487: LD_ADDR_VAR 0 17
55491: PUSH
55492: LD_INT 0
55494: ST_TO_ADDR
// f_capture := false ;
55495: LD_ADDR_VAR 0 18
55499: PUSH
55500: LD_INT 0
55502: ST_TO_ADDR
// f_ignore_civ := false ;
55503: LD_ADDR_VAR 0 19
55507: PUSH
55508: LD_INT 0
55510: ST_TO_ADDR
// f_murder := false ;
55511: LD_ADDR_VAR 0 20
55515: PUSH
55516: LD_INT 0
55518: ST_TO_ADDR
// f_mines := false ;
55519: LD_ADDR_VAR 0 21
55523: PUSH
55524: LD_INT 0
55526: ST_TO_ADDR
// f_repair := false ;
55527: LD_ADDR_VAR 0 22
55531: PUSH
55532: LD_INT 0
55534: ST_TO_ADDR
// f_heal := false ;
55535: LD_ADDR_VAR 0 23
55539: PUSH
55540: LD_INT 0
55542: ST_TO_ADDR
// f_spacetime := false ;
55543: LD_ADDR_VAR 0 24
55547: PUSH
55548: LD_INT 0
55550: ST_TO_ADDR
// f_attack_depot := false ;
55551: LD_ADDR_VAR 0 25
55555: PUSH
55556: LD_INT 0
55558: ST_TO_ADDR
// f_crawl := false ;
55559: LD_ADDR_VAR 0 26
55563: PUSH
55564: LD_INT 0
55566: ST_TO_ADDR
// end ; if f_heal then
55567: LD_VAR 0 23
55571: IFFALSE 55598
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
55573: LD_ADDR_VAR 0 31
55577: PUSH
55578: LD_VAR 0 4
55582: PPUSH
55583: LD_INT 25
55585: PUSH
55586: LD_INT 4
55588: PUSH
55589: EMPTY
55590: LIST
55591: LIST
55592: PPUSH
55593: CALL_OW 72
55597: ST_TO_ADDR
// if f_repair then
55598: LD_VAR 0 22
55602: IFFALSE 55629
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
55604: LD_ADDR_VAR 0 33
55608: PUSH
55609: LD_VAR 0 4
55613: PPUSH
55614: LD_INT 25
55616: PUSH
55617: LD_INT 3
55619: PUSH
55620: EMPTY
55621: LIST
55622: LIST
55623: PPUSH
55624: CALL_OW 72
55628: ST_TO_ADDR
// units_path := [ ] ;
55629: LD_ADDR_VAR 0 16
55633: PUSH
55634: EMPTY
55635: ST_TO_ADDR
// for i = 1 to group do
55636: LD_ADDR_VAR 0 7
55640: PUSH
55641: DOUBLE
55642: LD_INT 1
55644: DEC
55645: ST_TO_ADDR
55646: LD_VAR 0 4
55650: PUSH
55651: FOR_TO
55652: IFFALSE 55681
// units_path := Replace ( units_path , i , path ) ;
55654: LD_ADDR_VAR 0 16
55658: PUSH
55659: LD_VAR 0 16
55663: PPUSH
55664: LD_VAR 0 7
55668: PPUSH
55669: LD_VAR 0 5
55673: PPUSH
55674: CALL_OW 1
55678: ST_TO_ADDR
55679: GO 55651
55681: POP
55682: POP
// repeat for i = group downto 1 do
55683: LD_ADDR_VAR 0 7
55687: PUSH
55688: DOUBLE
55689: LD_VAR 0 4
55693: INC
55694: ST_TO_ADDR
55695: LD_INT 1
55697: PUSH
55698: FOR_DOWNTO
55699: IFFALSE 59821
// begin wait ( 5 ) ;
55701: LD_INT 5
55703: PPUSH
55704: CALL_OW 67
// tmp := [ ] ;
55708: LD_ADDR_VAR 0 14
55712: PUSH
55713: EMPTY
55714: ST_TO_ADDR
// attacking := false ;
55715: LD_ADDR_VAR 0 29
55719: PUSH
55720: LD_INT 0
55722: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
55723: LD_VAR 0 4
55727: PUSH
55728: LD_VAR 0 7
55732: ARRAY
55733: PPUSH
55734: CALL_OW 301
55738: PUSH
55739: LD_VAR 0 4
55743: PUSH
55744: LD_VAR 0 7
55748: ARRAY
55749: NOT
55750: OR
55751: IFFALSE 55860
// begin if GetType ( group [ i ] ) = unit_human then
55753: LD_VAR 0 4
55757: PUSH
55758: LD_VAR 0 7
55762: ARRAY
55763: PPUSH
55764: CALL_OW 247
55768: PUSH
55769: LD_INT 1
55771: EQUAL
55772: IFFALSE 55818
// begin to_heal := to_heal diff group [ i ] ;
55774: LD_ADDR_VAR 0 30
55778: PUSH
55779: LD_VAR 0 30
55783: PUSH
55784: LD_VAR 0 4
55788: PUSH
55789: LD_VAR 0 7
55793: ARRAY
55794: DIFF
55795: ST_TO_ADDR
// healers := healers diff group [ i ] ;
55796: LD_ADDR_VAR 0 31
55800: PUSH
55801: LD_VAR 0 31
55805: PUSH
55806: LD_VAR 0 4
55810: PUSH
55811: LD_VAR 0 7
55815: ARRAY
55816: DIFF
55817: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
55818: LD_ADDR_VAR 0 4
55822: PUSH
55823: LD_VAR 0 4
55827: PPUSH
55828: LD_VAR 0 7
55832: PPUSH
55833: CALL_OW 3
55837: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
55838: LD_ADDR_VAR 0 16
55842: PUSH
55843: LD_VAR 0 16
55847: PPUSH
55848: LD_VAR 0 7
55852: PPUSH
55853: CALL_OW 3
55857: ST_TO_ADDR
// continue ;
55858: GO 55698
// end ; if f_repair then
55860: LD_VAR 0 22
55864: IFFALSE 56353
// begin if GetType ( group [ i ] ) = unit_vehicle then
55866: LD_VAR 0 4
55870: PUSH
55871: LD_VAR 0 7
55875: ARRAY
55876: PPUSH
55877: CALL_OW 247
55881: PUSH
55882: LD_INT 2
55884: EQUAL
55885: IFFALSE 56075
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
55887: LD_VAR 0 4
55891: PUSH
55892: LD_VAR 0 7
55896: ARRAY
55897: PPUSH
55898: CALL_OW 256
55902: PUSH
55903: LD_INT 700
55905: LESS
55906: PUSH
55907: LD_VAR 0 4
55911: PUSH
55912: LD_VAR 0 7
55916: ARRAY
55917: PUSH
55918: LD_VAR 0 32
55922: IN
55923: NOT
55924: AND
55925: IFFALSE 55949
// to_repair := to_repair union group [ i ] ;
55927: LD_ADDR_VAR 0 32
55931: PUSH
55932: LD_VAR 0 32
55936: PUSH
55937: LD_VAR 0 4
55941: PUSH
55942: LD_VAR 0 7
55946: ARRAY
55947: UNION
55948: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
55949: LD_VAR 0 4
55953: PUSH
55954: LD_VAR 0 7
55958: ARRAY
55959: PPUSH
55960: CALL_OW 256
55964: PUSH
55965: LD_INT 1000
55967: EQUAL
55968: PUSH
55969: LD_VAR 0 4
55973: PUSH
55974: LD_VAR 0 7
55978: ARRAY
55979: PUSH
55980: LD_VAR 0 32
55984: IN
55985: AND
55986: IFFALSE 56010
// to_repair := to_repair diff group [ i ] ;
55988: LD_ADDR_VAR 0 32
55992: PUSH
55993: LD_VAR 0 32
55997: PUSH
55998: LD_VAR 0 4
56002: PUSH
56003: LD_VAR 0 7
56007: ARRAY
56008: DIFF
56009: ST_TO_ADDR
// if group [ i ] in to_repair then
56010: LD_VAR 0 4
56014: PUSH
56015: LD_VAR 0 7
56019: ARRAY
56020: PUSH
56021: LD_VAR 0 32
56025: IN
56026: IFFALSE 56073
// begin if not IsInArea ( group [ i ] , f_repair ) then
56028: LD_VAR 0 4
56032: PUSH
56033: LD_VAR 0 7
56037: ARRAY
56038: PPUSH
56039: LD_VAR 0 22
56043: PPUSH
56044: CALL_OW 308
56048: NOT
56049: IFFALSE 56071
// ComMoveToArea ( group [ i ] , f_repair ) ;
56051: LD_VAR 0 4
56055: PUSH
56056: LD_VAR 0 7
56060: ARRAY
56061: PPUSH
56062: LD_VAR 0 22
56066: PPUSH
56067: CALL_OW 113
// continue ;
56071: GO 55698
// end ; end else
56073: GO 56353
// if group [ i ] in repairs then
56075: LD_VAR 0 4
56079: PUSH
56080: LD_VAR 0 7
56084: ARRAY
56085: PUSH
56086: LD_VAR 0 33
56090: IN
56091: IFFALSE 56353
// begin if IsInUnit ( group [ i ] ) then
56093: LD_VAR 0 4
56097: PUSH
56098: LD_VAR 0 7
56102: ARRAY
56103: PPUSH
56104: CALL_OW 310
56108: IFFALSE 56176
// begin z := IsInUnit ( group [ i ] ) ;
56110: LD_ADDR_VAR 0 13
56114: PUSH
56115: LD_VAR 0 4
56119: PUSH
56120: LD_VAR 0 7
56124: ARRAY
56125: PPUSH
56126: CALL_OW 310
56130: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
56131: LD_VAR 0 13
56135: PUSH
56136: LD_VAR 0 32
56140: IN
56141: PUSH
56142: LD_VAR 0 13
56146: PPUSH
56147: LD_VAR 0 22
56151: PPUSH
56152: CALL_OW 308
56156: AND
56157: IFFALSE 56174
// ComExitVehicle ( group [ i ] ) ;
56159: LD_VAR 0 4
56163: PUSH
56164: LD_VAR 0 7
56168: ARRAY
56169: PPUSH
56170: CALL_OW 121
// end else
56174: GO 56353
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
56176: LD_ADDR_VAR 0 13
56180: PUSH
56181: LD_VAR 0 4
56185: PPUSH
56186: LD_INT 95
56188: PUSH
56189: LD_VAR 0 22
56193: PUSH
56194: EMPTY
56195: LIST
56196: LIST
56197: PUSH
56198: LD_INT 58
56200: PUSH
56201: EMPTY
56202: LIST
56203: PUSH
56204: EMPTY
56205: LIST
56206: LIST
56207: PPUSH
56208: CALL_OW 72
56212: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
56213: LD_VAR 0 4
56217: PUSH
56218: LD_VAR 0 7
56222: ARRAY
56223: PPUSH
56224: CALL_OW 314
56228: NOT
56229: IFFALSE 56351
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
56231: LD_ADDR_VAR 0 10
56235: PUSH
56236: LD_VAR 0 13
56240: PPUSH
56241: LD_VAR 0 4
56245: PUSH
56246: LD_VAR 0 7
56250: ARRAY
56251: PPUSH
56252: CALL_OW 74
56256: ST_TO_ADDR
// if not x then
56257: LD_VAR 0 10
56261: NOT
56262: IFFALSE 56266
// continue ;
56264: GO 55698
// if GetLives ( x ) < 1000 then
56266: LD_VAR 0 10
56270: PPUSH
56271: CALL_OW 256
56275: PUSH
56276: LD_INT 1000
56278: LESS
56279: IFFALSE 56303
// ComRepairVehicle ( group [ i ] , x ) else
56281: LD_VAR 0 4
56285: PUSH
56286: LD_VAR 0 7
56290: ARRAY
56291: PPUSH
56292: LD_VAR 0 10
56296: PPUSH
56297: CALL_OW 129
56301: GO 56351
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
56303: LD_VAR 0 23
56307: PUSH
56308: LD_VAR 0 4
56312: PUSH
56313: LD_VAR 0 7
56317: ARRAY
56318: PPUSH
56319: CALL_OW 256
56323: PUSH
56324: LD_INT 1000
56326: LESS
56327: AND
56328: NOT
56329: IFFALSE 56351
// ComEnterUnit ( group [ i ] , x ) ;
56331: LD_VAR 0 4
56335: PUSH
56336: LD_VAR 0 7
56340: ARRAY
56341: PPUSH
56342: LD_VAR 0 10
56346: PPUSH
56347: CALL_OW 120
// end ; continue ;
56351: GO 55698
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
56353: LD_VAR 0 23
56357: PUSH
56358: LD_VAR 0 4
56362: PUSH
56363: LD_VAR 0 7
56367: ARRAY
56368: PPUSH
56369: CALL_OW 247
56373: PUSH
56374: LD_INT 1
56376: EQUAL
56377: AND
56378: IFFALSE 56856
// begin if group [ i ] in healers then
56380: LD_VAR 0 4
56384: PUSH
56385: LD_VAR 0 7
56389: ARRAY
56390: PUSH
56391: LD_VAR 0 31
56395: IN
56396: IFFALSE 56669
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
56398: LD_VAR 0 4
56402: PUSH
56403: LD_VAR 0 7
56407: ARRAY
56408: PPUSH
56409: LD_VAR 0 23
56413: PPUSH
56414: CALL_OW 308
56418: NOT
56419: PUSH
56420: LD_VAR 0 4
56424: PUSH
56425: LD_VAR 0 7
56429: ARRAY
56430: PPUSH
56431: CALL_OW 314
56435: NOT
56436: AND
56437: IFFALSE 56461
// ComMoveToArea ( group [ i ] , f_heal ) else
56439: LD_VAR 0 4
56443: PUSH
56444: LD_VAR 0 7
56448: ARRAY
56449: PPUSH
56450: LD_VAR 0 23
56454: PPUSH
56455: CALL_OW 113
56459: GO 56667
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
56461: LD_VAR 0 4
56465: PUSH
56466: LD_VAR 0 7
56470: ARRAY
56471: PPUSH
56472: CALL 51156 0 1
56476: PPUSH
56477: CALL_OW 256
56481: PUSH
56482: LD_INT 1000
56484: EQUAL
56485: IFFALSE 56504
// ComStop ( group [ i ] ) else
56487: LD_VAR 0 4
56491: PUSH
56492: LD_VAR 0 7
56496: ARRAY
56497: PPUSH
56498: CALL_OW 141
56502: GO 56667
// if not HasTask ( group [ i ] ) and to_heal then
56504: LD_VAR 0 4
56508: PUSH
56509: LD_VAR 0 7
56513: ARRAY
56514: PPUSH
56515: CALL_OW 314
56519: NOT
56520: PUSH
56521: LD_VAR 0 30
56525: AND
56526: IFFALSE 56667
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
56528: LD_ADDR_VAR 0 13
56532: PUSH
56533: LD_VAR 0 30
56537: PPUSH
56538: LD_INT 3
56540: PUSH
56541: LD_INT 54
56543: PUSH
56544: EMPTY
56545: LIST
56546: PUSH
56547: EMPTY
56548: LIST
56549: LIST
56550: PPUSH
56551: CALL_OW 72
56555: PPUSH
56556: LD_VAR 0 4
56560: PUSH
56561: LD_VAR 0 7
56565: ARRAY
56566: PPUSH
56567: CALL_OW 74
56571: ST_TO_ADDR
// if z then
56572: LD_VAR 0 13
56576: IFFALSE 56667
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
56578: LD_INT 91
56580: PUSH
56581: LD_VAR 0 13
56585: PUSH
56586: LD_INT 10
56588: PUSH
56589: EMPTY
56590: LIST
56591: LIST
56592: LIST
56593: PUSH
56594: LD_INT 81
56596: PUSH
56597: LD_VAR 0 13
56601: PPUSH
56602: CALL_OW 255
56606: PUSH
56607: EMPTY
56608: LIST
56609: LIST
56610: PUSH
56611: EMPTY
56612: LIST
56613: LIST
56614: PPUSH
56615: CALL_OW 69
56619: PUSH
56620: LD_INT 0
56622: EQUAL
56623: IFFALSE 56647
// ComHeal ( group [ i ] , z ) else
56625: LD_VAR 0 4
56629: PUSH
56630: LD_VAR 0 7
56634: ARRAY
56635: PPUSH
56636: LD_VAR 0 13
56640: PPUSH
56641: CALL_OW 128
56645: GO 56667
// ComMoveToArea ( group [ i ] , f_heal ) ;
56647: LD_VAR 0 4
56651: PUSH
56652: LD_VAR 0 7
56656: ARRAY
56657: PPUSH
56658: LD_VAR 0 23
56662: PPUSH
56663: CALL_OW 113
// end ; continue ;
56667: GO 55698
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
56669: LD_VAR 0 4
56673: PUSH
56674: LD_VAR 0 7
56678: ARRAY
56679: PPUSH
56680: CALL_OW 256
56684: PUSH
56685: LD_INT 700
56687: LESS
56688: PUSH
56689: LD_VAR 0 4
56693: PUSH
56694: LD_VAR 0 7
56698: ARRAY
56699: PUSH
56700: LD_VAR 0 30
56704: IN
56705: NOT
56706: AND
56707: IFFALSE 56731
// to_heal := to_heal union group [ i ] ;
56709: LD_ADDR_VAR 0 30
56713: PUSH
56714: LD_VAR 0 30
56718: PUSH
56719: LD_VAR 0 4
56723: PUSH
56724: LD_VAR 0 7
56728: ARRAY
56729: UNION
56730: ST_TO_ADDR
// if group [ i ] in to_heal then
56731: LD_VAR 0 4
56735: PUSH
56736: LD_VAR 0 7
56740: ARRAY
56741: PUSH
56742: LD_VAR 0 30
56746: IN
56747: IFFALSE 56856
// begin if GetLives ( group [ i ] ) = 1000 then
56749: LD_VAR 0 4
56753: PUSH
56754: LD_VAR 0 7
56758: ARRAY
56759: PPUSH
56760: CALL_OW 256
56764: PUSH
56765: LD_INT 1000
56767: EQUAL
56768: IFFALSE 56794
// to_heal := to_heal diff group [ i ] else
56770: LD_ADDR_VAR 0 30
56774: PUSH
56775: LD_VAR 0 30
56779: PUSH
56780: LD_VAR 0 4
56784: PUSH
56785: LD_VAR 0 7
56789: ARRAY
56790: DIFF
56791: ST_TO_ADDR
56792: GO 56856
// begin if not IsInArea ( group [ i ] , to_heal ) then
56794: LD_VAR 0 4
56798: PUSH
56799: LD_VAR 0 7
56803: ARRAY
56804: PPUSH
56805: LD_VAR 0 30
56809: PPUSH
56810: CALL_OW 308
56814: NOT
56815: IFFALSE 56839
// ComMoveToArea ( group [ i ] , f_heal ) else
56817: LD_VAR 0 4
56821: PUSH
56822: LD_VAR 0 7
56826: ARRAY
56827: PPUSH
56828: LD_VAR 0 23
56832: PPUSH
56833: CALL_OW 113
56837: GO 56854
// ComHold ( group [ i ] ) ;
56839: LD_VAR 0 4
56843: PUSH
56844: LD_VAR 0 7
56848: ARRAY
56849: PPUSH
56850: CALL_OW 140
// continue ;
56854: GO 55698
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
56856: LD_VAR 0 4
56860: PUSH
56861: LD_VAR 0 7
56865: ARRAY
56866: PPUSH
56867: LD_INT 10
56869: PPUSH
56870: CALL 49576 0 2
56874: NOT
56875: PUSH
56876: LD_VAR 0 16
56880: PUSH
56881: LD_VAR 0 7
56885: ARRAY
56886: PUSH
56887: EMPTY
56888: EQUAL
56889: NOT
56890: AND
56891: IFFALSE 57157
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
56893: LD_VAR 0 4
56897: PUSH
56898: LD_VAR 0 7
56902: ARRAY
56903: PPUSH
56904: CALL_OW 262
56908: PUSH
56909: LD_INT 1
56911: PUSH
56912: LD_INT 2
56914: PUSH
56915: EMPTY
56916: LIST
56917: LIST
56918: IN
56919: IFFALSE 56960
// if GetFuel ( group [ i ] ) < 10 then
56921: LD_VAR 0 4
56925: PUSH
56926: LD_VAR 0 7
56930: ARRAY
56931: PPUSH
56932: CALL_OW 261
56936: PUSH
56937: LD_INT 10
56939: LESS
56940: IFFALSE 56960
// SetFuel ( group [ i ] , 12 ) ;
56942: LD_VAR 0 4
56946: PUSH
56947: LD_VAR 0 7
56951: ARRAY
56952: PPUSH
56953: LD_INT 12
56955: PPUSH
56956: CALL_OW 240
// if units_path [ i ] then
56960: LD_VAR 0 16
56964: PUSH
56965: LD_VAR 0 7
56969: ARRAY
56970: IFFALSE 57155
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
56972: LD_VAR 0 4
56976: PUSH
56977: LD_VAR 0 7
56981: ARRAY
56982: PPUSH
56983: LD_VAR 0 16
56987: PUSH
56988: LD_VAR 0 7
56992: ARRAY
56993: PUSH
56994: LD_INT 1
56996: ARRAY
56997: PUSH
56998: LD_INT 1
57000: ARRAY
57001: PPUSH
57002: LD_VAR 0 16
57006: PUSH
57007: LD_VAR 0 7
57011: ARRAY
57012: PUSH
57013: LD_INT 1
57015: ARRAY
57016: PUSH
57017: LD_INT 2
57019: ARRAY
57020: PPUSH
57021: CALL_OW 297
57025: PUSH
57026: LD_INT 6
57028: GREATER
57029: IFFALSE 57104
// begin if not HasTask ( group [ i ] ) then
57031: LD_VAR 0 4
57035: PUSH
57036: LD_VAR 0 7
57040: ARRAY
57041: PPUSH
57042: CALL_OW 314
57046: NOT
57047: IFFALSE 57102
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
57049: LD_VAR 0 4
57053: PUSH
57054: LD_VAR 0 7
57058: ARRAY
57059: PPUSH
57060: LD_VAR 0 16
57064: PUSH
57065: LD_VAR 0 7
57069: ARRAY
57070: PUSH
57071: LD_INT 1
57073: ARRAY
57074: PUSH
57075: LD_INT 1
57077: ARRAY
57078: PPUSH
57079: LD_VAR 0 16
57083: PUSH
57084: LD_VAR 0 7
57088: ARRAY
57089: PUSH
57090: LD_INT 1
57092: ARRAY
57093: PUSH
57094: LD_INT 2
57096: ARRAY
57097: PPUSH
57098: CALL_OW 114
// end else
57102: GO 57155
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
57104: LD_ADDR_VAR 0 15
57108: PUSH
57109: LD_VAR 0 16
57113: PUSH
57114: LD_VAR 0 7
57118: ARRAY
57119: PPUSH
57120: LD_INT 1
57122: PPUSH
57123: CALL_OW 3
57127: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
57128: LD_ADDR_VAR 0 16
57132: PUSH
57133: LD_VAR 0 16
57137: PPUSH
57138: LD_VAR 0 7
57142: PPUSH
57143: LD_VAR 0 15
57147: PPUSH
57148: CALL_OW 1
57152: ST_TO_ADDR
// continue ;
57153: GO 55698
// end ; end ; end else
57155: GO 59819
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
57157: LD_ADDR_VAR 0 14
57161: PUSH
57162: LD_INT 81
57164: PUSH
57165: LD_VAR 0 4
57169: PUSH
57170: LD_VAR 0 7
57174: ARRAY
57175: PPUSH
57176: CALL_OW 255
57180: PUSH
57181: EMPTY
57182: LIST
57183: LIST
57184: PPUSH
57185: CALL_OW 69
57189: ST_TO_ADDR
// if not tmp then
57190: LD_VAR 0 14
57194: NOT
57195: IFFALSE 57199
// continue ;
57197: GO 55698
// if f_ignore_area then
57199: LD_VAR 0 17
57203: IFFALSE 57291
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
57205: LD_ADDR_VAR 0 15
57209: PUSH
57210: LD_VAR 0 14
57214: PPUSH
57215: LD_INT 3
57217: PUSH
57218: LD_INT 92
57220: PUSH
57221: LD_VAR 0 17
57225: PUSH
57226: LD_INT 1
57228: ARRAY
57229: PUSH
57230: LD_VAR 0 17
57234: PUSH
57235: LD_INT 2
57237: ARRAY
57238: PUSH
57239: LD_VAR 0 17
57243: PUSH
57244: LD_INT 3
57246: ARRAY
57247: PUSH
57248: EMPTY
57249: LIST
57250: LIST
57251: LIST
57252: LIST
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: PPUSH
57258: CALL_OW 72
57262: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
57263: LD_VAR 0 14
57267: PUSH
57268: LD_VAR 0 15
57272: DIFF
57273: IFFALSE 57291
// tmp := tmp diff tmp2 ;
57275: LD_ADDR_VAR 0 14
57279: PUSH
57280: LD_VAR 0 14
57284: PUSH
57285: LD_VAR 0 15
57289: DIFF
57290: ST_TO_ADDR
// end ; if not f_murder then
57291: LD_VAR 0 20
57295: NOT
57296: IFFALSE 57354
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
57298: LD_ADDR_VAR 0 15
57302: PUSH
57303: LD_VAR 0 14
57307: PPUSH
57308: LD_INT 3
57310: PUSH
57311: LD_INT 50
57313: PUSH
57314: EMPTY
57315: LIST
57316: PUSH
57317: EMPTY
57318: LIST
57319: LIST
57320: PPUSH
57321: CALL_OW 72
57325: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
57326: LD_VAR 0 14
57330: PUSH
57331: LD_VAR 0 15
57335: DIFF
57336: IFFALSE 57354
// tmp := tmp diff tmp2 ;
57338: LD_ADDR_VAR 0 14
57342: PUSH
57343: LD_VAR 0 14
57347: PUSH
57348: LD_VAR 0 15
57352: DIFF
57353: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
57354: LD_ADDR_VAR 0 14
57358: PUSH
57359: LD_VAR 0 4
57363: PUSH
57364: LD_VAR 0 7
57368: ARRAY
57369: PPUSH
57370: LD_VAR 0 14
57374: PPUSH
57375: LD_INT 1
57377: PPUSH
57378: LD_INT 1
57380: PPUSH
57381: CALL 22886 0 4
57385: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
57386: LD_VAR 0 4
57390: PUSH
57391: LD_VAR 0 7
57395: ARRAY
57396: PPUSH
57397: CALL_OW 257
57401: PUSH
57402: LD_INT 1
57404: EQUAL
57405: IFFALSE 57853
// begin if WantPlant ( group [ i ] ) then
57407: LD_VAR 0 4
57411: PUSH
57412: LD_VAR 0 7
57416: ARRAY
57417: PPUSH
57418: CALL 22387 0 1
57422: IFFALSE 57426
// continue ;
57424: GO 55698
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
57426: LD_VAR 0 18
57430: PUSH
57431: LD_VAR 0 4
57435: PUSH
57436: LD_VAR 0 7
57440: ARRAY
57441: PPUSH
57442: CALL_OW 310
57446: NOT
57447: AND
57448: PUSH
57449: LD_VAR 0 14
57453: PUSH
57454: LD_INT 1
57456: ARRAY
57457: PUSH
57458: LD_VAR 0 14
57462: PPUSH
57463: LD_INT 21
57465: PUSH
57466: LD_INT 2
57468: PUSH
57469: EMPTY
57470: LIST
57471: LIST
57472: PUSH
57473: LD_INT 58
57475: PUSH
57476: EMPTY
57477: LIST
57478: PUSH
57479: EMPTY
57480: LIST
57481: LIST
57482: PPUSH
57483: CALL_OW 72
57487: IN
57488: AND
57489: IFFALSE 57525
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
57491: LD_VAR 0 4
57495: PUSH
57496: LD_VAR 0 7
57500: ARRAY
57501: PPUSH
57502: LD_VAR 0 14
57506: PUSH
57507: LD_INT 1
57509: ARRAY
57510: PPUSH
57511: CALL_OW 120
// attacking := true ;
57515: LD_ADDR_VAR 0 29
57519: PUSH
57520: LD_INT 1
57522: ST_TO_ADDR
// continue ;
57523: GO 55698
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
57525: LD_VAR 0 26
57529: PUSH
57530: LD_VAR 0 4
57534: PUSH
57535: LD_VAR 0 7
57539: ARRAY
57540: PPUSH
57541: CALL_OW 257
57545: PUSH
57546: LD_INT 1
57548: EQUAL
57549: AND
57550: PUSH
57551: LD_VAR 0 4
57555: PUSH
57556: LD_VAR 0 7
57560: ARRAY
57561: PPUSH
57562: CALL_OW 256
57566: PUSH
57567: LD_INT 800
57569: LESS
57570: AND
57571: PUSH
57572: LD_VAR 0 4
57576: PUSH
57577: LD_VAR 0 7
57581: ARRAY
57582: PPUSH
57583: CALL_OW 318
57587: NOT
57588: AND
57589: IFFALSE 57606
// ComCrawl ( group [ i ] ) ;
57591: LD_VAR 0 4
57595: PUSH
57596: LD_VAR 0 7
57600: ARRAY
57601: PPUSH
57602: CALL_OW 137
// if f_mines then
57606: LD_VAR 0 21
57610: IFFALSE 57853
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
57612: LD_VAR 0 14
57616: PUSH
57617: LD_INT 1
57619: ARRAY
57620: PPUSH
57621: CALL_OW 247
57625: PUSH
57626: LD_INT 3
57628: EQUAL
57629: PUSH
57630: LD_VAR 0 14
57634: PUSH
57635: LD_INT 1
57637: ARRAY
57638: PUSH
57639: LD_VAR 0 27
57643: IN
57644: NOT
57645: AND
57646: IFFALSE 57853
// begin x := GetX ( tmp [ 1 ] ) ;
57648: LD_ADDR_VAR 0 10
57652: PUSH
57653: LD_VAR 0 14
57657: PUSH
57658: LD_INT 1
57660: ARRAY
57661: PPUSH
57662: CALL_OW 250
57666: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
57667: LD_ADDR_VAR 0 11
57671: PUSH
57672: LD_VAR 0 14
57676: PUSH
57677: LD_INT 1
57679: ARRAY
57680: PPUSH
57681: CALL_OW 251
57685: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
57686: LD_ADDR_VAR 0 12
57690: PUSH
57691: LD_VAR 0 4
57695: PUSH
57696: LD_VAR 0 7
57700: ARRAY
57701: PPUSH
57702: CALL 49661 0 1
57706: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
57707: LD_VAR 0 4
57711: PUSH
57712: LD_VAR 0 7
57716: ARRAY
57717: PPUSH
57718: LD_VAR 0 10
57722: PPUSH
57723: LD_VAR 0 11
57727: PPUSH
57728: LD_VAR 0 14
57732: PUSH
57733: LD_INT 1
57735: ARRAY
57736: PPUSH
57737: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
57741: LD_VAR 0 4
57745: PUSH
57746: LD_VAR 0 7
57750: ARRAY
57751: PPUSH
57752: LD_VAR 0 10
57756: PPUSH
57757: LD_VAR 0 12
57761: PPUSH
57762: LD_INT 7
57764: PPUSH
57765: CALL_OW 272
57769: PPUSH
57770: LD_VAR 0 11
57774: PPUSH
57775: LD_VAR 0 12
57779: PPUSH
57780: LD_INT 7
57782: PPUSH
57783: CALL_OW 273
57787: PPUSH
57788: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
57792: LD_VAR 0 4
57796: PUSH
57797: LD_VAR 0 7
57801: ARRAY
57802: PPUSH
57803: LD_INT 71
57805: PPUSH
57806: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
57810: LD_ADDR_VAR 0 27
57814: PUSH
57815: LD_VAR 0 27
57819: PPUSH
57820: LD_VAR 0 27
57824: PUSH
57825: LD_INT 1
57827: PLUS
57828: PPUSH
57829: LD_VAR 0 14
57833: PUSH
57834: LD_INT 1
57836: ARRAY
57837: PPUSH
57838: CALL_OW 1
57842: ST_TO_ADDR
// attacking := true ;
57843: LD_ADDR_VAR 0 29
57847: PUSH
57848: LD_INT 1
57850: ST_TO_ADDR
// continue ;
57851: GO 55698
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
57853: LD_VAR 0 4
57857: PUSH
57858: LD_VAR 0 7
57862: ARRAY
57863: PPUSH
57864: CALL_OW 257
57868: PUSH
57869: LD_INT 17
57871: EQUAL
57872: PUSH
57873: LD_VAR 0 4
57877: PUSH
57878: LD_VAR 0 7
57882: ARRAY
57883: PPUSH
57884: CALL_OW 110
57888: PUSH
57889: LD_INT 71
57891: EQUAL
57892: NOT
57893: AND
57894: IFFALSE 58040
// begin attacking := false ;
57896: LD_ADDR_VAR 0 29
57900: PUSH
57901: LD_INT 0
57903: ST_TO_ADDR
// k := 5 ;
57904: LD_ADDR_VAR 0 9
57908: PUSH
57909: LD_INT 5
57911: ST_TO_ADDR
// if tmp < k then
57912: LD_VAR 0 14
57916: PUSH
57917: LD_VAR 0 9
57921: LESS
57922: IFFALSE 57934
// k := tmp ;
57924: LD_ADDR_VAR 0 9
57928: PUSH
57929: LD_VAR 0 14
57933: ST_TO_ADDR
// for j = 1 to k do
57934: LD_ADDR_VAR 0 8
57938: PUSH
57939: DOUBLE
57940: LD_INT 1
57942: DEC
57943: ST_TO_ADDR
57944: LD_VAR 0 9
57948: PUSH
57949: FOR_TO
57950: IFFALSE 58038
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
57952: LD_VAR 0 14
57956: PUSH
57957: LD_VAR 0 8
57961: ARRAY
57962: PUSH
57963: LD_VAR 0 14
57967: PPUSH
57968: LD_INT 58
57970: PUSH
57971: EMPTY
57972: LIST
57973: PPUSH
57974: CALL_OW 72
57978: IN
57979: NOT
57980: IFFALSE 58036
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
57982: LD_VAR 0 4
57986: PUSH
57987: LD_VAR 0 7
57991: ARRAY
57992: PPUSH
57993: LD_VAR 0 14
57997: PUSH
57998: LD_VAR 0 8
58002: ARRAY
58003: PPUSH
58004: CALL_OW 115
// attacking := true ;
58008: LD_ADDR_VAR 0 29
58012: PUSH
58013: LD_INT 1
58015: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
58016: LD_VAR 0 4
58020: PUSH
58021: LD_VAR 0 7
58025: ARRAY
58026: PPUSH
58027: LD_INT 71
58029: PPUSH
58030: CALL_OW 109
// continue ;
58034: GO 57949
// end ; end ;
58036: GO 57949
58038: POP
58039: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
58040: LD_VAR 0 4
58044: PUSH
58045: LD_VAR 0 7
58049: ARRAY
58050: PPUSH
58051: CALL_OW 257
58055: PUSH
58056: LD_INT 8
58058: EQUAL
58059: PUSH
58060: LD_VAR 0 4
58064: PUSH
58065: LD_VAR 0 7
58069: ARRAY
58070: PPUSH
58071: CALL_OW 264
58075: PUSH
58076: LD_INT 28
58078: PUSH
58079: LD_INT 45
58081: PUSH
58082: LD_INT 7
58084: PUSH
58085: LD_INT 47
58087: PUSH
58088: EMPTY
58089: LIST
58090: LIST
58091: LIST
58092: LIST
58093: IN
58094: OR
58095: IFFALSE 58351
// begin attacking := false ;
58097: LD_ADDR_VAR 0 29
58101: PUSH
58102: LD_INT 0
58104: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
58105: LD_VAR 0 14
58109: PUSH
58110: LD_INT 1
58112: ARRAY
58113: PPUSH
58114: CALL_OW 266
58118: PUSH
58119: LD_INT 32
58121: PUSH
58122: LD_INT 31
58124: PUSH
58125: LD_INT 33
58127: PUSH
58128: LD_INT 4
58130: PUSH
58131: LD_INT 5
58133: PUSH
58134: EMPTY
58135: LIST
58136: LIST
58137: LIST
58138: LIST
58139: LIST
58140: IN
58141: IFFALSE 58327
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
58143: LD_ADDR_VAR 0 9
58147: PUSH
58148: LD_VAR 0 14
58152: PUSH
58153: LD_INT 1
58155: ARRAY
58156: PPUSH
58157: CALL_OW 266
58161: PPUSH
58162: LD_VAR 0 14
58166: PUSH
58167: LD_INT 1
58169: ARRAY
58170: PPUSH
58171: CALL_OW 250
58175: PPUSH
58176: LD_VAR 0 14
58180: PUSH
58181: LD_INT 1
58183: ARRAY
58184: PPUSH
58185: CALL_OW 251
58189: PPUSH
58190: LD_VAR 0 14
58194: PUSH
58195: LD_INT 1
58197: ARRAY
58198: PPUSH
58199: CALL_OW 254
58203: PPUSH
58204: LD_VAR 0 14
58208: PUSH
58209: LD_INT 1
58211: ARRAY
58212: PPUSH
58213: CALL_OW 248
58217: PPUSH
58218: LD_INT 0
58220: PPUSH
58221: CALL 31031 0 6
58225: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
58226: LD_ADDR_VAR 0 8
58230: PUSH
58231: LD_VAR 0 4
58235: PUSH
58236: LD_VAR 0 7
58240: ARRAY
58241: PPUSH
58242: LD_VAR 0 9
58246: PPUSH
58247: CALL 49701 0 2
58251: ST_TO_ADDR
// if j then
58252: LD_VAR 0 8
58256: IFFALSE 58325
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
58258: LD_VAR 0 8
58262: PUSH
58263: LD_INT 1
58265: ARRAY
58266: PPUSH
58267: LD_VAR 0 8
58271: PUSH
58272: LD_INT 2
58274: ARRAY
58275: PPUSH
58276: CALL_OW 488
58280: IFFALSE 58325
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
58282: LD_VAR 0 4
58286: PUSH
58287: LD_VAR 0 7
58291: ARRAY
58292: PPUSH
58293: LD_VAR 0 8
58297: PUSH
58298: LD_INT 1
58300: ARRAY
58301: PPUSH
58302: LD_VAR 0 8
58306: PUSH
58307: LD_INT 2
58309: ARRAY
58310: PPUSH
58311: CALL_OW 116
// attacking := true ;
58315: LD_ADDR_VAR 0 29
58319: PUSH
58320: LD_INT 1
58322: ST_TO_ADDR
// continue ;
58323: GO 55698
// end ; end else
58325: GO 58351
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
58327: LD_VAR 0 4
58331: PUSH
58332: LD_VAR 0 7
58336: ARRAY
58337: PPUSH
58338: LD_VAR 0 14
58342: PUSH
58343: LD_INT 1
58345: ARRAY
58346: PPUSH
58347: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
58351: LD_VAR 0 4
58355: PUSH
58356: LD_VAR 0 7
58360: ARRAY
58361: PPUSH
58362: CALL_OW 265
58366: PUSH
58367: LD_INT 11
58369: EQUAL
58370: IFFALSE 58648
// begin k := 10 ;
58372: LD_ADDR_VAR 0 9
58376: PUSH
58377: LD_INT 10
58379: ST_TO_ADDR
// x := 0 ;
58380: LD_ADDR_VAR 0 10
58384: PUSH
58385: LD_INT 0
58387: ST_TO_ADDR
// if tmp < k then
58388: LD_VAR 0 14
58392: PUSH
58393: LD_VAR 0 9
58397: LESS
58398: IFFALSE 58410
// k := tmp ;
58400: LD_ADDR_VAR 0 9
58404: PUSH
58405: LD_VAR 0 14
58409: ST_TO_ADDR
// for j = k downto 1 do
58410: LD_ADDR_VAR 0 8
58414: PUSH
58415: DOUBLE
58416: LD_VAR 0 9
58420: INC
58421: ST_TO_ADDR
58422: LD_INT 1
58424: PUSH
58425: FOR_DOWNTO
58426: IFFALSE 58501
// begin if GetType ( tmp [ j ] ) = unit_human then
58428: LD_VAR 0 14
58432: PUSH
58433: LD_VAR 0 8
58437: ARRAY
58438: PPUSH
58439: CALL_OW 247
58443: PUSH
58444: LD_INT 1
58446: EQUAL
58447: IFFALSE 58499
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
58449: LD_VAR 0 4
58453: PUSH
58454: LD_VAR 0 7
58458: ARRAY
58459: PPUSH
58460: LD_VAR 0 14
58464: PUSH
58465: LD_VAR 0 8
58469: ARRAY
58470: PPUSH
58471: CALL 49972 0 2
// x := tmp [ j ] ;
58475: LD_ADDR_VAR 0 10
58479: PUSH
58480: LD_VAR 0 14
58484: PUSH
58485: LD_VAR 0 8
58489: ARRAY
58490: ST_TO_ADDR
// attacking := true ;
58491: LD_ADDR_VAR 0 29
58495: PUSH
58496: LD_INT 1
58498: ST_TO_ADDR
// end ; end ;
58499: GO 58425
58501: POP
58502: POP
// if not x then
58503: LD_VAR 0 10
58507: NOT
58508: IFFALSE 58648
// begin attacking := true ;
58510: LD_ADDR_VAR 0 29
58514: PUSH
58515: LD_INT 1
58517: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
58518: LD_VAR 0 4
58522: PUSH
58523: LD_VAR 0 7
58527: ARRAY
58528: PPUSH
58529: CALL_OW 250
58533: PPUSH
58534: LD_VAR 0 4
58538: PUSH
58539: LD_VAR 0 7
58543: ARRAY
58544: PPUSH
58545: CALL_OW 251
58549: PPUSH
58550: CALL_OW 546
58554: PUSH
58555: LD_INT 2
58557: ARRAY
58558: PUSH
58559: LD_VAR 0 14
58563: PUSH
58564: LD_INT 1
58566: ARRAY
58567: PPUSH
58568: CALL_OW 250
58572: PPUSH
58573: LD_VAR 0 14
58577: PUSH
58578: LD_INT 1
58580: ARRAY
58581: PPUSH
58582: CALL_OW 251
58586: PPUSH
58587: CALL_OW 546
58591: PUSH
58592: LD_INT 2
58594: ARRAY
58595: EQUAL
58596: IFFALSE 58624
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
58598: LD_VAR 0 4
58602: PUSH
58603: LD_VAR 0 7
58607: ARRAY
58608: PPUSH
58609: LD_VAR 0 14
58613: PUSH
58614: LD_INT 1
58616: ARRAY
58617: PPUSH
58618: CALL 49972 0 2
58622: GO 58648
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
58624: LD_VAR 0 4
58628: PUSH
58629: LD_VAR 0 7
58633: ARRAY
58634: PPUSH
58635: LD_VAR 0 14
58639: PUSH
58640: LD_INT 1
58642: ARRAY
58643: PPUSH
58644: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
58648: LD_VAR 0 4
58652: PUSH
58653: LD_VAR 0 7
58657: ARRAY
58658: PPUSH
58659: CALL_OW 264
58663: PUSH
58664: LD_INT 29
58666: EQUAL
58667: IFFALSE 59033
// begin if WantsToAttack ( group [ i ] ) in bombed then
58669: LD_VAR 0 4
58673: PUSH
58674: LD_VAR 0 7
58678: ARRAY
58679: PPUSH
58680: CALL_OW 319
58684: PUSH
58685: LD_VAR 0 28
58689: IN
58690: IFFALSE 58694
// continue ;
58692: GO 55698
// k := 8 ;
58694: LD_ADDR_VAR 0 9
58698: PUSH
58699: LD_INT 8
58701: ST_TO_ADDR
// x := 0 ;
58702: LD_ADDR_VAR 0 10
58706: PUSH
58707: LD_INT 0
58709: ST_TO_ADDR
// if tmp < k then
58710: LD_VAR 0 14
58714: PUSH
58715: LD_VAR 0 9
58719: LESS
58720: IFFALSE 58732
// k := tmp ;
58722: LD_ADDR_VAR 0 9
58726: PUSH
58727: LD_VAR 0 14
58731: ST_TO_ADDR
// for j = 1 to k do
58732: LD_ADDR_VAR 0 8
58736: PUSH
58737: DOUBLE
58738: LD_INT 1
58740: DEC
58741: ST_TO_ADDR
58742: LD_VAR 0 9
58746: PUSH
58747: FOR_TO
58748: IFFALSE 58880
// begin if GetType ( tmp [ j ] ) = unit_building then
58750: LD_VAR 0 14
58754: PUSH
58755: LD_VAR 0 8
58759: ARRAY
58760: PPUSH
58761: CALL_OW 247
58765: PUSH
58766: LD_INT 3
58768: EQUAL
58769: IFFALSE 58878
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
58771: LD_VAR 0 14
58775: PUSH
58776: LD_VAR 0 8
58780: ARRAY
58781: PUSH
58782: LD_VAR 0 28
58786: IN
58787: NOT
58788: PUSH
58789: LD_VAR 0 14
58793: PUSH
58794: LD_VAR 0 8
58798: ARRAY
58799: PPUSH
58800: CALL_OW 313
58804: AND
58805: IFFALSE 58878
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
58807: LD_VAR 0 4
58811: PUSH
58812: LD_VAR 0 7
58816: ARRAY
58817: PPUSH
58818: LD_VAR 0 14
58822: PUSH
58823: LD_VAR 0 8
58827: ARRAY
58828: PPUSH
58829: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
58833: LD_ADDR_VAR 0 28
58837: PUSH
58838: LD_VAR 0 28
58842: PPUSH
58843: LD_VAR 0 28
58847: PUSH
58848: LD_INT 1
58850: PLUS
58851: PPUSH
58852: LD_VAR 0 14
58856: PUSH
58857: LD_VAR 0 8
58861: ARRAY
58862: PPUSH
58863: CALL_OW 1
58867: ST_TO_ADDR
// attacking := true ;
58868: LD_ADDR_VAR 0 29
58872: PUSH
58873: LD_INT 1
58875: ST_TO_ADDR
// break ;
58876: GO 58880
// end ; end ;
58878: GO 58747
58880: POP
58881: POP
// if not attacking and f_attack_depot then
58882: LD_VAR 0 29
58886: NOT
58887: PUSH
58888: LD_VAR 0 25
58892: AND
58893: IFFALSE 58988
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58895: LD_ADDR_VAR 0 13
58899: PUSH
58900: LD_VAR 0 14
58904: PPUSH
58905: LD_INT 2
58907: PUSH
58908: LD_INT 30
58910: PUSH
58911: LD_INT 0
58913: PUSH
58914: EMPTY
58915: LIST
58916: LIST
58917: PUSH
58918: LD_INT 30
58920: PUSH
58921: LD_INT 1
58923: PUSH
58924: EMPTY
58925: LIST
58926: LIST
58927: PUSH
58928: EMPTY
58929: LIST
58930: LIST
58931: LIST
58932: PPUSH
58933: CALL_OW 72
58937: ST_TO_ADDR
// if z then
58938: LD_VAR 0 13
58942: IFFALSE 58988
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
58944: LD_VAR 0 4
58948: PUSH
58949: LD_VAR 0 7
58953: ARRAY
58954: PPUSH
58955: LD_VAR 0 13
58959: PPUSH
58960: LD_VAR 0 4
58964: PUSH
58965: LD_VAR 0 7
58969: ARRAY
58970: PPUSH
58971: CALL_OW 74
58975: PPUSH
58976: CALL_OW 115
// attacking := true ;
58980: LD_ADDR_VAR 0 29
58984: PUSH
58985: LD_INT 1
58987: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
58988: LD_VAR 0 4
58992: PUSH
58993: LD_VAR 0 7
58997: ARRAY
58998: PPUSH
58999: CALL_OW 256
59003: PUSH
59004: LD_INT 500
59006: LESS
59007: IFFALSE 59033
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
59009: LD_VAR 0 4
59013: PUSH
59014: LD_VAR 0 7
59018: ARRAY
59019: PPUSH
59020: LD_VAR 0 14
59024: PUSH
59025: LD_INT 1
59027: ARRAY
59028: PPUSH
59029: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
59033: LD_VAR 0 4
59037: PUSH
59038: LD_VAR 0 7
59042: ARRAY
59043: PPUSH
59044: CALL_OW 264
59048: PUSH
59049: LD_INT 49
59051: EQUAL
59052: IFFALSE 59173
// begin if not HasTask ( group [ i ] ) then
59054: LD_VAR 0 4
59058: PUSH
59059: LD_VAR 0 7
59063: ARRAY
59064: PPUSH
59065: CALL_OW 314
59069: NOT
59070: IFFALSE 59173
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
59072: LD_ADDR_VAR 0 9
59076: PUSH
59077: LD_INT 81
59079: PUSH
59080: LD_VAR 0 4
59084: PUSH
59085: LD_VAR 0 7
59089: ARRAY
59090: PPUSH
59091: CALL_OW 255
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: PPUSH
59100: CALL_OW 69
59104: PPUSH
59105: LD_VAR 0 4
59109: PUSH
59110: LD_VAR 0 7
59114: ARRAY
59115: PPUSH
59116: CALL_OW 74
59120: ST_TO_ADDR
// if k then
59121: LD_VAR 0 9
59125: IFFALSE 59173
// if GetDistUnits ( group [ i ] , k ) > 10 then
59127: LD_VAR 0 4
59131: PUSH
59132: LD_VAR 0 7
59136: ARRAY
59137: PPUSH
59138: LD_VAR 0 9
59142: PPUSH
59143: CALL_OW 296
59147: PUSH
59148: LD_INT 10
59150: GREATER
59151: IFFALSE 59173
// ComMoveUnit ( group [ i ] , k ) ;
59153: LD_VAR 0 4
59157: PUSH
59158: LD_VAR 0 7
59162: ARRAY
59163: PPUSH
59164: LD_VAR 0 9
59168: PPUSH
59169: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
59173: LD_VAR 0 4
59177: PUSH
59178: LD_VAR 0 7
59182: ARRAY
59183: PPUSH
59184: CALL_OW 256
59188: PUSH
59189: LD_INT 250
59191: LESS
59192: PUSH
59193: LD_VAR 0 4
59197: PUSH
59198: LD_VAR 0 7
59202: ARRAY
59203: PUSH
59204: LD_INT 21
59206: PUSH
59207: LD_INT 2
59209: PUSH
59210: EMPTY
59211: LIST
59212: LIST
59213: PUSH
59214: LD_INT 23
59216: PUSH
59217: LD_INT 2
59219: PUSH
59220: EMPTY
59221: LIST
59222: LIST
59223: PUSH
59224: EMPTY
59225: LIST
59226: LIST
59227: PPUSH
59228: CALL_OW 69
59232: IN
59233: AND
59234: IFFALSE 59359
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
59236: LD_ADDR_VAR 0 9
59240: PUSH
59241: LD_OWVAR 3
59245: PUSH
59246: LD_VAR 0 4
59250: PUSH
59251: LD_VAR 0 7
59255: ARRAY
59256: DIFF
59257: PPUSH
59258: LD_VAR 0 4
59262: PUSH
59263: LD_VAR 0 7
59267: ARRAY
59268: PPUSH
59269: CALL_OW 74
59273: ST_TO_ADDR
// if not k then
59274: LD_VAR 0 9
59278: NOT
59279: IFFALSE 59283
// continue ;
59281: GO 55698
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
59283: LD_VAR 0 9
59287: PUSH
59288: LD_INT 81
59290: PUSH
59291: LD_VAR 0 4
59295: PUSH
59296: LD_VAR 0 7
59300: ARRAY
59301: PPUSH
59302: CALL_OW 255
59306: PUSH
59307: EMPTY
59308: LIST
59309: LIST
59310: PPUSH
59311: CALL_OW 69
59315: IN
59316: PUSH
59317: LD_VAR 0 9
59321: PPUSH
59322: LD_VAR 0 4
59326: PUSH
59327: LD_VAR 0 7
59331: ARRAY
59332: PPUSH
59333: CALL_OW 296
59337: PUSH
59338: LD_INT 5
59340: LESS
59341: AND
59342: IFFALSE 59359
// ComAutodestruct ( group [ i ] ) ;
59344: LD_VAR 0 4
59348: PUSH
59349: LD_VAR 0 7
59353: ARRAY
59354: PPUSH
59355: CALL 49870 0 1
// end ; if f_attack_depot then
59359: LD_VAR 0 25
59363: IFFALSE 59475
// begin k := 6 ;
59365: LD_ADDR_VAR 0 9
59369: PUSH
59370: LD_INT 6
59372: ST_TO_ADDR
// if tmp < k then
59373: LD_VAR 0 14
59377: PUSH
59378: LD_VAR 0 9
59382: LESS
59383: IFFALSE 59395
// k := tmp ;
59385: LD_ADDR_VAR 0 9
59389: PUSH
59390: LD_VAR 0 14
59394: ST_TO_ADDR
// for j = 1 to k do
59395: LD_ADDR_VAR 0 8
59399: PUSH
59400: DOUBLE
59401: LD_INT 1
59403: DEC
59404: ST_TO_ADDR
59405: LD_VAR 0 9
59409: PUSH
59410: FOR_TO
59411: IFFALSE 59473
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
59413: LD_VAR 0 8
59417: PPUSH
59418: CALL_OW 266
59422: PUSH
59423: LD_INT 0
59425: PUSH
59426: LD_INT 1
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: IN
59433: IFFALSE 59471
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
59435: LD_VAR 0 4
59439: PUSH
59440: LD_VAR 0 7
59444: ARRAY
59445: PPUSH
59446: LD_VAR 0 14
59450: PUSH
59451: LD_VAR 0 8
59455: ARRAY
59456: PPUSH
59457: CALL_OW 115
// attacking := true ;
59461: LD_ADDR_VAR 0 29
59465: PUSH
59466: LD_INT 1
59468: ST_TO_ADDR
// break ;
59469: GO 59473
// end ;
59471: GO 59410
59473: POP
59474: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
59475: LD_VAR 0 4
59479: PUSH
59480: LD_VAR 0 7
59484: ARRAY
59485: PPUSH
59486: CALL_OW 302
59490: PUSH
59491: LD_VAR 0 29
59495: NOT
59496: AND
59497: IFFALSE 59819
// begin if GetTag ( group [ i ] ) = 71 then
59499: LD_VAR 0 4
59503: PUSH
59504: LD_VAR 0 7
59508: ARRAY
59509: PPUSH
59510: CALL_OW 110
59514: PUSH
59515: LD_INT 71
59517: EQUAL
59518: IFFALSE 59559
// begin if HasTask ( group [ i ] ) then
59520: LD_VAR 0 4
59524: PUSH
59525: LD_VAR 0 7
59529: ARRAY
59530: PPUSH
59531: CALL_OW 314
59535: IFFALSE 59541
// continue else
59537: GO 55698
59539: GO 59559
// SetTag ( group [ i ] , 0 ) ;
59541: LD_VAR 0 4
59545: PUSH
59546: LD_VAR 0 7
59550: ARRAY
59551: PPUSH
59552: LD_INT 0
59554: PPUSH
59555: CALL_OW 109
// end ; k := 8 ;
59559: LD_ADDR_VAR 0 9
59563: PUSH
59564: LD_INT 8
59566: ST_TO_ADDR
// x := 0 ;
59567: LD_ADDR_VAR 0 10
59571: PUSH
59572: LD_INT 0
59574: ST_TO_ADDR
// if tmp < k then
59575: LD_VAR 0 14
59579: PUSH
59580: LD_VAR 0 9
59584: LESS
59585: IFFALSE 59597
// k := tmp ;
59587: LD_ADDR_VAR 0 9
59591: PUSH
59592: LD_VAR 0 14
59596: ST_TO_ADDR
// for j = 1 to k do
59597: LD_ADDR_VAR 0 8
59601: PUSH
59602: DOUBLE
59603: LD_INT 1
59605: DEC
59606: ST_TO_ADDR
59607: LD_VAR 0 9
59611: PUSH
59612: FOR_TO
59613: IFFALSE 59711
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
59615: LD_VAR 0 14
59619: PUSH
59620: LD_VAR 0 8
59624: ARRAY
59625: PPUSH
59626: CALL_OW 247
59630: PUSH
59631: LD_INT 1
59633: EQUAL
59634: PUSH
59635: LD_VAR 0 14
59639: PUSH
59640: LD_VAR 0 8
59644: ARRAY
59645: PPUSH
59646: CALL_OW 256
59650: PUSH
59651: LD_INT 250
59653: LESS
59654: PUSH
59655: LD_VAR 0 20
59659: AND
59660: PUSH
59661: LD_VAR 0 20
59665: NOT
59666: PUSH
59667: LD_VAR 0 14
59671: PUSH
59672: LD_VAR 0 8
59676: ARRAY
59677: PPUSH
59678: CALL_OW 256
59682: PUSH
59683: LD_INT 250
59685: GREATEREQUAL
59686: AND
59687: OR
59688: AND
59689: IFFALSE 59709
// begin x := tmp [ j ] ;
59691: LD_ADDR_VAR 0 10
59695: PUSH
59696: LD_VAR 0 14
59700: PUSH
59701: LD_VAR 0 8
59705: ARRAY
59706: ST_TO_ADDR
// break ;
59707: GO 59711
// end ;
59709: GO 59612
59711: POP
59712: POP
// if x then
59713: LD_VAR 0 10
59717: IFFALSE 59741
// ComAttackUnit ( group [ i ] , x ) else
59719: LD_VAR 0 4
59723: PUSH
59724: LD_VAR 0 7
59728: ARRAY
59729: PPUSH
59730: LD_VAR 0 10
59734: PPUSH
59735: CALL_OW 115
59739: GO 59765
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
59741: LD_VAR 0 4
59745: PUSH
59746: LD_VAR 0 7
59750: ARRAY
59751: PPUSH
59752: LD_VAR 0 14
59756: PUSH
59757: LD_INT 1
59759: ARRAY
59760: PPUSH
59761: CALL_OW 115
// if not HasTask ( group [ i ] ) then
59765: LD_VAR 0 4
59769: PUSH
59770: LD_VAR 0 7
59774: ARRAY
59775: PPUSH
59776: CALL_OW 314
59780: NOT
59781: IFFALSE 59819
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
59783: LD_VAR 0 4
59787: PUSH
59788: LD_VAR 0 7
59792: ARRAY
59793: PPUSH
59794: LD_VAR 0 14
59798: PPUSH
59799: LD_VAR 0 4
59803: PUSH
59804: LD_VAR 0 7
59808: ARRAY
59809: PPUSH
59810: CALL_OW 74
59814: PPUSH
59815: CALL_OW 115
// end ; end ; end ;
59819: GO 55698
59821: POP
59822: POP
// wait ( 0 0$2 ) ;
59823: LD_INT 70
59825: PPUSH
59826: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
59830: LD_VAR 0 4
59834: NOT
59835: PUSH
59836: LD_VAR 0 4
59840: PUSH
59841: EMPTY
59842: EQUAL
59843: OR
59844: PUSH
59845: LD_INT 81
59847: PUSH
59848: LD_VAR 0 35
59852: PUSH
59853: EMPTY
59854: LIST
59855: LIST
59856: PPUSH
59857: CALL_OW 69
59861: NOT
59862: OR
59863: IFFALSE 55683
// end ;
59865: LD_VAR 0 2
59869: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
59870: LD_INT 0
59872: PPUSH
59873: PPUSH
59874: PPUSH
59875: PPUSH
59876: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
59877: LD_VAR 0 1
59881: NOT
59882: PUSH
59883: LD_EXP 86
59887: PUSH
59888: LD_VAR 0 1
59892: ARRAY
59893: NOT
59894: OR
59895: PUSH
59896: LD_VAR 0 2
59900: NOT
59901: OR
59902: PUSH
59903: LD_VAR 0 3
59907: NOT
59908: OR
59909: IFFALSE 59913
// exit ;
59911: GO 60426
// side := mc_sides [ base ] ;
59913: LD_ADDR_VAR 0 6
59917: PUSH
59918: LD_EXP 112
59922: PUSH
59923: LD_VAR 0 1
59927: ARRAY
59928: ST_TO_ADDR
// if not side then
59929: LD_VAR 0 6
59933: NOT
59934: IFFALSE 59938
// exit ;
59936: GO 60426
// for i in solds do
59938: LD_ADDR_VAR 0 7
59942: PUSH
59943: LD_VAR 0 2
59947: PUSH
59948: FOR_IN
59949: IFFALSE 60010
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
59951: LD_VAR 0 7
59955: PPUSH
59956: CALL_OW 310
59960: PPUSH
59961: CALL_OW 266
59965: PUSH
59966: LD_INT 32
59968: PUSH
59969: LD_INT 31
59971: PUSH
59972: EMPTY
59973: LIST
59974: LIST
59975: IN
59976: IFFALSE 59996
// solds := solds diff i else
59978: LD_ADDR_VAR 0 2
59982: PUSH
59983: LD_VAR 0 2
59987: PUSH
59988: LD_VAR 0 7
59992: DIFF
59993: ST_TO_ADDR
59994: GO 60008
// SetTag ( i , 18 ) ;
59996: LD_VAR 0 7
60000: PPUSH
60001: LD_INT 18
60003: PPUSH
60004: CALL_OW 109
60008: GO 59948
60010: POP
60011: POP
// if not solds then
60012: LD_VAR 0 2
60016: NOT
60017: IFFALSE 60021
// exit ;
60019: GO 60426
// repeat wait ( 0 0$2 ) ;
60021: LD_INT 70
60023: PPUSH
60024: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
60028: LD_ADDR_VAR 0 5
60032: PUSH
60033: LD_VAR 0 6
60037: PPUSH
60038: LD_VAR 0 3
60042: PPUSH
60043: CALL 19252 0 2
60047: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
60048: LD_EXP 86
60052: PUSH
60053: LD_VAR 0 1
60057: ARRAY
60058: NOT
60059: PUSH
60060: LD_EXP 86
60064: PUSH
60065: LD_VAR 0 1
60069: ARRAY
60070: PUSH
60071: EMPTY
60072: EQUAL
60073: OR
60074: IFFALSE 60111
// begin for i in solds do
60076: LD_ADDR_VAR 0 7
60080: PUSH
60081: LD_VAR 0 2
60085: PUSH
60086: FOR_IN
60087: IFFALSE 60100
// ComStop ( i ) ;
60089: LD_VAR 0 7
60093: PPUSH
60094: CALL_OW 141
60098: GO 60086
60100: POP
60101: POP
// solds := [ ] ;
60102: LD_ADDR_VAR 0 2
60106: PUSH
60107: EMPTY
60108: ST_TO_ADDR
// exit ;
60109: GO 60426
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
60111: LD_VAR 0 5
60115: NOT
60116: PUSH
60117: LD_VAR 0 5
60121: PUSH
60122: LD_INT 3
60124: GREATER
60125: OR
60126: PUSH
60127: LD_EXP 108
60131: PUSH
60132: LD_VAR 0 1
60136: ARRAY
60137: OR
60138: IFFALSE 60179
// begin for i in solds do
60140: LD_ADDR_VAR 0 7
60144: PUSH
60145: LD_VAR 0 2
60149: PUSH
60150: FOR_IN
60151: IFFALSE 60175
// if HasTask ( i ) then
60153: LD_VAR 0 7
60157: PPUSH
60158: CALL_OW 314
60162: IFFALSE 60173
// ComStop ( i ) ;
60164: LD_VAR 0 7
60168: PPUSH
60169: CALL_OW 141
60173: GO 60150
60175: POP
60176: POP
// break ;
60177: GO 60414
// end ; for i in solds do
60179: LD_ADDR_VAR 0 7
60183: PUSH
60184: LD_VAR 0 2
60188: PUSH
60189: FOR_IN
60190: IFFALSE 60406
// begin if IsInUnit ( i ) then
60192: LD_VAR 0 7
60196: PPUSH
60197: CALL_OW 310
60201: IFFALSE 60212
// ComExitBuilding ( i ) ;
60203: LD_VAR 0 7
60207: PPUSH
60208: CALL_OW 122
// if GetLives ( i ) > 333 then
60212: LD_VAR 0 7
60216: PPUSH
60217: CALL_OW 256
60221: PUSH
60222: LD_INT 333
60224: GREATER
60225: IFFALSE 60253
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
60227: LD_VAR 0 7
60231: PPUSH
60232: LD_VAR 0 5
60236: PPUSH
60237: LD_VAR 0 7
60241: PPUSH
60242: CALL_OW 74
60246: PPUSH
60247: CALL_OW 115
60251: GO 60404
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
60253: LD_ADDR_VAR 0 8
60257: PUSH
60258: LD_EXP 86
60262: PUSH
60263: LD_VAR 0 1
60267: ARRAY
60268: PPUSH
60269: LD_INT 2
60271: PUSH
60272: LD_INT 30
60274: PUSH
60275: LD_INT 0
60277: PUSH
60278: EMPTY
60279: LIST
60280: LIST
60281: PUSH
60282: LD_INT 30
60284: PUSH
60285: LD_INT 1
60287: PUSH
60288: EMPTY
60289: LIST
60290: LIST
60291: PUSH
60292: LD_INT 30
60294: PUSH
60295: LD_INT 6
60297: PUSH
60298: EMPTY
60299: LIST
60300: LIST
60301: PUSH
60302: EMPTY
60303: LIST
60304: LIST
60305: LIST
60306: LIST
60307: PPUSH
60308: CALL_OW 72
60312: PPUSH
60313: LD_VAR 0 7
60317: PPUSH
60318: CALL_OW 74
60322: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
60323: LD_VAR 0 7
60327: PPUSH
60328: LD_VAR 0 8
60332: PPUSH
60333: CALL_OW 250
60337: PPUSH
60338: LD_INT 3
60340: PPUSH
60341: LD_INT 5
60343: PPUSH
60344: CALL_OW 272
60348: PPUSH
60349: LD_VAR 0 8
60353: PPUSH
60354: CALL_OW 251
60358: PPUSH
60359: LD_INT 3
60361: PPUSH
60362: LD_INT 5
60364: PPUSH
60365: CALL_OW 273
60369: PPUSH
60370: CALL_OW 111
// SetTag ( i , 0 ) ;
60374: LD_VAR 0 7
60378: PPUSH
60379: LD_INT 0
60381: PPUSH
60382: CALL_OW 109
// solds := solds diff i ;
60386: LD_ADDR_VAR 0 2
60390: PUSH
60391: LD_VAR 0 2
60395: PUSH
60396: LD_VAR 0 7
60400: DIFF
60401: ST_TO_ADDR
// continue ;
60402: GO 60189
// end ; end ;
60404: GO 60189
60406: POP
60407: POP
// until solds ;
60408: LD_VAR 0 2
60412: IFFALSE 60021
// MC_Reset ( base , 18 ) ;
60414: LD_VAR 0 1
60418: PPUSH
60419: LD_INT 18
60421: PPUSH
60422: CALL 66476 0 2
// end ;
60426: LD_VAR 0 4
60430: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
60431: LD_INT 0
60433: PPUSH
60434: PPUSH
60435: PPUSH
60436: PPUSH
60437: PPUSH
60438: PPUSH
60439: PPUSH
60440: PPUSH
60441: PPUSH
60442: PPUSH
60443: PPUSH
60444: PPUSH
60445: PPUSH
60446: PPUSH
60447: PPUSH
60448: PPUSH
60449: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60450: LD_ADDR_VAR 0 13
60454: PUSH
60455: LD_EXP 86
60459: PUSH
60460: LD_VAR 0 1
60464: ARRAY
60465: PPUSH
60466: LD_INT 25
60468: PUSH
60469: LD_INT 3
60471: PUSH
60472: EMPTY
60473: LIST
60474: LIST
60475: PPUSH
60476: CALL_OW 72
60480: ST_TO_ADDR
// if mc_remote_driver [ base ] then
60481: LD_EXP 126
60485: PUSH
60486: LD_VAR 0 1
60490: ARRAY
60491: IFFALSE 60515
// mechs := mechs diff mc_remote_driver [ base ] ;
60493: LD_ADDR_VAR 0 13
60497: PUSH
60498: LD_VAR 0 13
60502: PUSH
60503: LD_EXP 126
60507: PUSH
60508: LD_VAR 0 1
60512: ARRAY
60513: DIFF
60514: ST_TO_ADDR
// for i in mechs do
60515: LD_ADDR_VAR 0 5
60519: PUSH
60520: LD_VAR 0 13
60524: PUSH
60525: FOR_IN
60526: IFFALSE 60561
// if GetTag ( i ) > 0 then
60528: LD_VAR 0 5
60532: PPUSH
60533: CALL_OW 110
60537: PUSH
60538: LD_INT 0
60540: GREATER
60541: IFFALSE 60559
// mechs := mechs diff i ;
60543: LD_ADDR_VAR 0 13
60547: PUSH
60548: LD_VAR 0 13
60552: PUSH
60553: LD_VAR 0 5
60557: DIFF
60558: ST_TO_ADDR
60559: GO 60525
60561: POP
60562: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60563: LD_ADDR_VAR 0 9
60567: PUSH
60568: LD_EXP 86
60572: PUSH
60573: LD_VAR 0 1
60577: ARRAY
60578: PPUSH
60579: LD_INT 2
60581: PUSH
60582: LD_INT 25
60584: PUSH
60585: LD_INT 1
60587: PUSH
60588: EMPTY
60589: LIST
60590: LIST
60591: PUSH
60592: LD_INT 25
60594: PUSH
60595: LD_INT 5
60597: PUSH
60598: EMPTY
60599: LIST
60600: LIST
60601: PUSH
60602: LD_INT 25
60604: PUSH
60605: LD_INT 8
60607: PUSH
60608: EMPTY
60609: LIST
60610: LIST
60611: PUSH
60612: LD_INT 25
60614: PUSH
60615: LD_INT 9
60617: PUSH
60618: EMPTY
60619: LIST
60620: LIST
60621: PUSH
60622: EMPTY
60623: LIST
60624: LIST
60625: LIST
60626: LIST
60627: LIST
60628: PPUSH
60629: CALL_OW 72
60633: ST_TO_ADDR
// if not defenders and not solds then
60634: LD_VAR 0 2
60638: NOT
60639: PUSH
60640: LD_VAR 0 9
60644: NOT
60645: AND
60646: IFFALSE 60650
// exit ;
60648: GO 62340
// depot_under_attack := false ;
60650: LD_ADDR_VAR 0 17
60654: PUSH
60655: LD_INT 0
60657: ST_TO_ADDR
// sold_defenders := [ ] ;
60658: LD_ADDR_VAR 0 18
60662: PUSH
60663: EMPTY
60664: ST_TO_ADDR
// if mechs then
60665: LD_VAR 0 13
60669: IFFALSE 60822
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
60671: LD_ADDR_VAR 0 5
60675: PUSH
60676: LD_VAR 0 2
60680: PPUSH
60681: LD_INT 21
60683: PUSH
60684: LD_INT 2
60686: PUSH
60687: EMPTY
60688: LIST
60689: LIST
60690: PPUSH
60691: CALL_OW 72
60695: PUSH
60696: FOR_IN
60697: IFFALSE 60820
// begin if GetTag ( i ) <> 20 then
60699: LD_VAR 0 5
60703: PPUSH
60704: CALL_OW 110
60708: PUSH
60709: LD_INT 20
60711: NONEQUAL
60712: IFFALSE 60726
// SetTag ( i , 20 ) ;
60714: LD_VAR 0 5
60718: PPUSH
60719: LD_INT 20
60721: PPUSH
60722: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
60726: LD_VAR 0 5
60730: PPUSH
60731: CALL_OW 263
60735: PUSH
60736: LD_INT 1
60738: EQUAL
60739: PUSH
60740: LD_VAR 0 5
60744: PPUSH
60745: CALL_OW 311
60749: NOT
60750: AND
60751: IFFALSE 60818
// begin un := mechs [ 1 ] ;
60753: LD_ADDR_VAR 0 11
60757: PUSH
60758: LD_VAR 0 13
60762: PUSH
60763: LD_INT 1
60765: ARRAY
60766: ST_TO_ADDR
// ComExit ( un ) ;
60767: LD_VAR 0 11
60771: PPUSH
60772: CALL 54215 0 1
// AddComEnterUnit ( un , i ) ;
60776: LD_VAR 0 11
60780: PPUSH
60781: LD_VAR 0 5
60785: PPUSH
60786: CALL_OW 180
// SetTag ( un , 19 ) ;
60790: LD_VAR 0 11
60794: PPUSH
60795: LD_INT 19
60797: PPUSH
60798: CALL_OW 109
// mechs := mechs diff un ;
60802: LD_ADDR_VAR 0 13
60806: PUSH
60807: LD_VAR 0 13
60811: PUSH
60812: LD_VAR 0 11
60816: DIFF
60817: ST_TO_ADDR
// end ; end ;
60818: GO 60696
60820: POP
60821: POP
// if solds then
60822: LD_VAR 0 9
60826: IFFALSE 60885
// for i in solds do
60828: LD_ADDR_VAR 0 5
60832: PUSH
60833: LD_VAR 0 9
60837: PUSH
60838: FOR_IN
60839: IFFALSE 60883
// if not GetTag ( i ) then
60841: LD_VAR 0 5
60845: PPUSH
60846: CALL_OW 110
60850: NOT
60851: IFFALSE 60881
// begin defenders := defenders union i ;
60853: LD_ADDR_VAR 0 2
60857: PUSH
60858: LD_VAR 0 2
60862: PUSH
60863: LD_VAR 0 5
60867: UNION
60868: ST_TO_ADDR
// SetTag ( i , 18 ) ;
60869: LD_VAR 0 5
60873: PPUSH
60874: LD_INT 18
60876: PPUSH
60877: CALL_OW 109
// end ;
60881: GO 60838
60883: POP
60884: POP
// repeat wait ( 0 0$2 ) ;
60885: LD_INT 70
60887: PPUSH
60888: CALL_OW 67
// enemy := mc_scan [ base ] ;
60892: LD_ADDR_VAR 0 3
60896: PUSH
60897: LD_EXP 109
60901: PUSH
60902: LD_VAR 0 1
60906: ARRAY
60907: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
60908: LD_EXP 86
60912: PUSH
60913: LD_VAR 0 1
60917: ARRAY
60918: NOT
60919: PUSH
60920: LD_EXP 86
60924: PUSH
60925: LD_VAR 0 1
60929: ARRAY
60930: PUSH
60931: EMPTY
60932: EQUAL
60933: OR
60934: IFFALSE 60971
// begin for i in defenders do
60936: LD_ADDR_VAR 0 5
60940: PUSH
60941: LD_VAR 0 2
60945: PUSH
60946: FOR_IN
60947: IFFALSE 60960
// ComStop ( i ) ;
60949: LD_VAR 0 5
60953: PPUSH
60954: CALL_OW 141
60958: GO 60946
60960: POP
60961: POP
// defenders := [ ] ;
60962: LD_ADDR_VAR 0 2
60966: PUSH
60967: EMPTY
60968: ST_TO_ADDR
// exit ;
60969: GO 62340
// end ; for i in defenders do
60971: LD_ADDR_VAR 0 5
60975: PUSH
60976: LD_VAR 0 2
60980: PUSH
60981: FOR_IN
60982: IFFALSE 61800
// begin e := NearestUnitToUnit ( enemy , i ) ;
60984: LD_ADDR_VAR 0 14
60988: PUSH
60989: LD_VAR 0 3
60993: PPUSH
60994: LD_VAR 0 5
60998: PPUSH
60999: CALL_OW 74
61003: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61004: LD_ADDR_VAR 0 8
61008: PUSH
61009: LD_EXP 86
61013: PUSH
61014: LD_VAR 0 1
61018: ARRAY
61019: PPUSH
61020: LD_INT 2
61022: PUSH
61023: LD_INT 30
61025: PUSH
61026: LD_INT 0
61028: PUSH
61029: EMPTY
61030: LIST
61031: LIST
61032: PUSH
61033: LD_INT 30
61035: PUSH
61036: LD_INT 1
61038: PUSH
61039: EMPTY
61040: LIST
61041: LIST
61042: PUSH
61043: EMPTY
61044: LIST
61045: LIST
61046: LIST
61047: PPUSH
61048: CALL_OW 72
61052: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
61053: LD_ADDR_VAR 0 17
61057: PUSH
61058: LD_VAR 0 8
61062: NOT
61063: PUSH
61064: LD_VAR 0 8
61068: PPUSH
61069: LD_INT 3
61071: PUSH
61072: LD_INT 24
61074: PUSH
61075: LD_INT 600
61077: PUSH
61078: EMPTY
61079: LIST
61080: LIST
61081: PUSH
61082: EMPTY
61083: LIST
61084: LIST
61085: PPUSH
61086: CALL_OW 72
61090: OR
61091: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
61092: LD_VAR 0 5
61096: PPUSH
61097: CALL_OW 247
61101: PUSH
61102: LD_INT 2
61104: DOUBLE
61105: EQUAL
61106: IFTRUE 61110
61108: GO 61506
61110: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
61111: LD_VAR 0 5
61115: PPUSH
61116: CALL_OW 256
61120: PUSH
61121: LD_INT 1000
61123: EQUAL
61124: PUSH
61125: LD_VAR 0 5
61129: PPUSH
61130: LD_VAR 0 14
61134: PPUSH
61135: CALL_OW 296
61139: PUSH
61140: LD_INT 40
61142: LESS
61143: PUSH
61144: LD_VAR 0 14
61148: PPUSH
61149: LD_EXP 111
61153: PUSH
61154: LD_VAR 0 1
61158: ARRAY
61159: PPUSH
61160: CALL_OW 308
61164: OR
61165: AND
61166: IFFALSE 61288
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
61168: LD_VAR 0 5
61172: PPUSH
61173: CALL_OW 262
61177: PUSH
61178: LD_INT 1
61180: EQUAL
61181: PUSH
61182: LD_VAR 0 5
61186: PPUSH
61187: CALL_OW 261
61191: PUSH
61192: LD_INT 30
61194: LESS
61195: AND
61196: PUSH
61197: LD_VAR 0 8
61201: AND
61202: IFFALSE 61272
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
61204: LD_VAR 0 5
61208: PPUSH
61209: LD_VAR 0 8
61213: PPUSH
61214: LD_VAR 0 5
61218: PPUSH
61219: CALL_OW 74
61223: PPUSH
61224: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
61228: LD_VAR 0 5
61232: PPUSH
61233: LD_VAR 0 8
61237: PPUSH
61238: LD_VAR 0 5
61242: PPUSH
61243: CALL_OW 74
61247: PPUSH
61248: CALL_OW 296
61252: PUSH
61253: LD_INT 6
61255: LESS
61256: IFFALSE 61270
// SetFuel ( i , 100 ) ;
61258: LD_VAR 0 5
61262: PPUSH
61263: LD_INT 100
61265: PPUSH
61266: CALL_OW 240
// end else
61270: GO 61286
// ComAttackUnit ( i , e ) ;
61272: LD_VAR 0 5
61276: PPUSH
61277: LD_VAR 0 14
61281: PPUSH
61282: CALL_OW 115
// end else
61286: GO 61389
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
61288: LD_VAR 0 14
61292: PPUSH
61293: LD_EXP 111
61297: PUSH
61298: LD_VAR 0 1
61302: ARRAY
61303: PPUSH
61304: CALL_OW 308
61308: NOT
61309: PUSH
61310: LD_VAR 0 5
61314: PPUSH
61315: LD_VAR 0 14
61319: PPUSH
61320: CALL_OW 296
61324: PUSH
61325: LD_INT 40
61327: GREATEREQUAL
61328: AND
61329: PUSH
61330: LD_VAR 0 5
61334: PPUSH
61335: CALL_OW 256
61339: PUSH
61340: LD_INT 650
61342: LESSEQUAL
61343: OR
61344: PUSH
61345: LD_VAR 0 5
61349: PPUSH
61350: LD_EXP 110
61354: PUSH
61355: LD_VAR 0 1
61359: ARRAY
61360: PPUSH
61361: CALL_OW 308
61365: NOT
61366: AND
61367: IFFALSE 61389
// ComMoveToArea ( i , mc_parking [ base ] ) ;
61369: LD_VAR 0 5
61373: PPUSH
61374: LD_EXP 110
61378: PUSH
61379: LD_VAR 0 1
61383: ARRAY
61384: PPUSH
61385: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
61389: LD_VAR 0 5
61393: PPUSH
61394: CALL_OW 256
61398: PUSH
61399: LD_INT 1000
61401: LESS
61402: PUSH
61403: LD_VAR 0 5
61407: PPUSH
61408: CALL_OW 263
61412: PUSH
61413: LD_INT 1
61415: EQUAL
61416: AND
61417: PUSH
61418: LD_VAR 0 5
61422: PPUSH
61423: CALL_OW 311
61427: AND
61428: PUSH
61429: LD_VAR 0 5
61433: PPUSH
61434: LD_EXP 110
61438: PUSH
61439: LD_VAR 0 1
61443: ARRAY
61444: PPUSH
61445: CALL_OW 308
61449: AND
61450: IFFALSE 61504
// begin mech := IsDrivenBy ( i ) ;
61452: LD_ADDR_VAR 0 10
61456: PUSH
61457: LD_VAR 0 5
61461: PPUSH
61462: CALL_OW 311
61466: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
61467: LD_VAR 0 10
61471: PPUSH
61472: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
61476: LD_VAR 0 10
61480: PPUSH
61481: LD_VAR 0 5
61485: PPUSH
61486: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
61490: LD_VAR 0 10
61494: PPUSH
61495: LD_VAR 0 5
61499: PPUSH
61500: CALL_OW 180
// end ; end ; unit_human :
61504: GO 61771
61506: LD_INT 1
61508: DOUBLE
61509: EQUAL
61510: IFTRUE 61514
61512: GO 61770
61514: POP
// begin b := IsInUnit ( i ) ;
61515: LD_ADDR_VAR 0 19
61519: PUSH
61520: LD_VAR 0 5
61524: PPUSH
61525: CALL_OW 310
61529: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
61530: LD_ADDR_VAR 0 20
61534: PUSH
61535: LD_VAR 0 19
61539: NOT
61540: PUSH
61541: LD_VAR 0 19
61545: PPUSH
61546: CALL_OW 266
61550: PUSH
61551: LD_INT 32
61553: PUSH
61554: LD_INT 31
61556: PUSH
61557: EMPTY
61558: LIST
61559: LIST
61560: IN
61561: OR
61562: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
61563: LD_VAR 0 17
61567: PUSH
61568: LD_VAR 0 2
61572: PPUSH
61573: LD_INT 21
61575: PUSH
61576: LD_INT 2
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PPUSH
61583: CALL_OW 72
61587: PUSH
61588: LD_INT 1
61590: LESSEQUAL
61591: OR
61592: PUSH
61593: LD_VAR 0 20
61597: AND
61598: PUSH
61599: LD_VAR 0 5
61603: PUSH
61604: LD_VAR 0 18
61608: IN
61609: NOT
61610: AND
61611: IFFALSE 61704
// begin if b then
61613: LD_VAR 0 19
61617: IFFALSE 61666
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
61619: LD_VAR 0 19
61623: PPUSH
61624: LD_VAR 0 3
61628: PPUSH
61629: LD_VAR 0 19
61633: PPUSH
61634: CALL_OW 74
61638: PPUSH
61639: CALL_OW 296
61643: PUSH
61644: LD_INT 10
61646: LESS
61647: PUSH
61648: LD_VAR 0 19
61652: PPUSH
61653: CALL_OW 461
61657: PUSH
61658: LD_INT 7
61660: NONEQUAL
61661: AND
61662: IFFALSE 61666
// continue ;
61664: GO 60981
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
61666: LD_ADDR_VAR 0 18
61670: PUSH
61671: LD_VAR 0 18
61675: PPUSH
61676: LD_VAR 0 18
61680: PUSH
61681: LD_INT 1
61683: PLUS
61684: PPUSH
61685: LD_VAR 0 5
61689: PPUSH
61690: CALL_OW 1
61694: ST_TO_ADDR
// ComExitBuilding ( i ) ;
61695: LD_VAR 0 5
61699: PPUSH
61700: CALL_OW 122
// end ; if sold_defenders then
61704: LD_VAR 0 18
61708: IFFALSE 61768
// if i in sold_defenders then
61710: LD_VAR 0 5
61714: PUSH
61715: LD_VAR 0 18
61719: IN
61720: IFFALSE 61768
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
61722: LD_VAR 0 5
61726: PPUSH
61727: CALL_OW 314
61731: NOT
61732: PUSH
61733: LD_VAR 0 5
61737: PPUSH
61738: LD_VAR 0 14
61742: PPUSH
61743: CALL_OW 296
61747: PUSH
61748: LD_INT 30
61750: LESS
61751: AND
61752: IFFALSE 61768
// ComAttackUnit ( i , e ) ;
61754: LD_VAR 0 5
61758: PPUSH
61759: LD_VAR 0 14
61763: PPUSH
61764: CALL_OW 115
// end ; end ; end ;
61768: GO 61771
61770: POP
// if IsDead ( i ) then
61771: LD_VAR 0 5
61775: PPUSH
61776: CALL_OW 301
61780: IFFALSE 61798
// defenders := defenders diff i ;
61782: LD_ADDR_VAR 0 2
61786: PUSH
61787: LD_VAR 0 2
61791: PUSH
61792: LD_VAR 0 5
61796: DIFF
61797: ST_TO_ADDR
// end ;
61798: GO 60981
61800: POP
61801: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
61802: LD_VAR 0 3
61806: NOT
61807: PUSH
61808: LD_VAR 0 2
61812: NOT
61813: OR
61814: PUSH
61815: LD_EXP 86
61819: PUSH
61820: LD_VAR 0 1
61824: ARRAY
61825: NOT
61826: OR
61827: IFFALSE 60885
// MC_Reset ( base , 18 ) ;
61829: LD_VAR 0 1
61833: PPUSH
61834: LD_INT 18
61836: PPUSH
61837: CALL 66476 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61841: LD_ADDR_VAR 0 2
61845: PUSH
61846: LD_VAR 0 2
61850: PUSH
61851: LD_VAR 0 2
61855: PPUSH
61856: LD_INT 2
61858: PUSH
61859: LD_INT 25
61861: PUSH
61862: LD_INT 1
61864: PUSH
61865: EMPTY
61866: LIST
61867: LIST
61868: PUSH
61869: LD_INT 25
61871: PUSH
61872: LD_INT 5
61874: PUSH
61875: EMPTY
61876: LIST
61877: LIST
61878: PUSH
61879: LD_INT 25
61881: PUSH
61882: LD_INT 8
61884: PUSH
61885: EMPTY
61886: LIST
61887: LIST
61888: PUSH
61889: LD_INT 25
61891: PUSH
61892: LD_INT 9
61894: PUSH
61895: EMPTY
61896: LIST
61897: LIST
61898: PUSH
61899: EMPTY
61900: LIST
61901: LIST
61902: LIST
61903: LIST
61904: LIST
61905: PPUSH
61906: CALL_OW 72
61910: DIFF
61911: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
61912: LD_VAR 0 3
61916: NOT
61917: PUSH
61918: LD_VAR 0 2
61922: PPUSH
61923: LD_INT 21
61925: PUSH
61926: LD_INT 2
61928: PUSH
61929: EMPTY
61930: LIST
61931: LIST
61932: PPUSH
61933: CALL_OW 72
61937: AND
61938: IFFALSE 62276
// begin tmp := FilterByTag ( defenders , 19 ) ;
61940: LD_ADDR_VAR 0 12
61944: PUSH
61945: LD_VAR 0 2
61949: PPUSH
61950: LD_INT 19
61952: PPUSH
61953: CALL 51345 0 2
61957: ST_TO_ADDR
// if tmp then
61958: LD_VAR 0 12
61962: IFFALSE 62032
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
61964: LD_ADDR_VAR 0 12
61968: PUSH
61969: LD_VAR 0 12
61973: PPUSH
61974: LD_INT 25
61976: PUSH
61977: LD_INT 3
61979: PUSH
61980: EMPTY
61981: LIST
61982: LIST
61983: PPUSH
61984: CALL_OW 72
61988: ST_TO_ADDR
// if tmp then
61989: LD_VAR 0 12
61993: IFFALSE 62032
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
61995: LD_ADDR_EXP 98
61999: PUSH
62000: LD_EXP 98
62004: PPUSH
62005: LD_VAR 0 1
62009: PPUSH
62010: LD_EXP 98
62014: PUSH
62015: LD_VAR 0 1
62019: ARRAY
62020: PUSH
62021: LD_VAR 0 12
62025: UNION
62026: PPUSH
62027: CALL_OW 1
62031: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
62032: LD_VAR 0 1
62036: PPUSH
62037: LD_INT 19
62039: PPUSH
62040: CALL 66476 0 2
// repeat wait ( 0 0$1 ) ;
62044: LD_INT 35
62046: PPUSH
62047: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
62051: LD_EXP 86
62055: PUSH
62056: LD_VAR 0 1
62060: ARRAY
62061: NOT
62062: PUSH
62063: LD_EXP 86
62067: PUSH
62068: LD_VAR 0 1
62072: ARRAY
62073: PUSH
62074: EMPTY
62075: EQUAL
62076: OR
62077: IFFALSE 62114
// begin for i in defenders do
62079: LD_ADDR_VAR 0 5
62083: PUSH
62084: LD_VAR 0 2
62088: PUSH
62089: FOR_IN
62090: IFFALSE 62103
// ComStop ( i ) ;
62092: LD_VAR 0 5
62096: PPUSH
62097: CALL_OW 141
62101: GO 62089
62103: POP
62104: POP
// defenders := [ ] ;
62105: LD_ADDR_VAR 0 2
62109: PUSH
62110: EMPTY
62111: ST_TO_ADDR
// exit ;
62112: GO 62340
// end ; for i in defenders do
62114: LD_ADDR_VAR 0 5
62118: PUSH
62119: LD_VAR 0 2
62123: PUSH
62124: FOR_IN
62125: IFFALSE 62214
// begin if not IsInArea ( i , mc_parking [ base ] ) then
62127: LD_VAR 0 5
62131: PPUSH
62132: LD_EXP 110
62136: PUSH
62137: LD_VAR 0 1
62141: ARRAY
62142: PPUSH
62143: CALL_OW 308
62147: NOT
62148: IFFALSE 62172
// ComMoveToArea ( i , mc_parking [ base ] ) else
62150: LD_VAR 0 5
62154: PPUSH
62155: LD_EXP 110
62159: PUSH
62160: LD_VAR 0 1
62164: ARRAY
62165: PPUSH
62166: CALL_OW 113
62170: GO 62212
// if GetControl ( i ) = control_manual then
62172: LD_VAR 0 5
62176: PPUSH
62177: CALL_OW 263
62181: PUSH
62182: LD_INT 1
62184: EQUAL
62185: IFFALSE 62212
// if IsDrivenBy ( i ) then
62187: LD_VAR 0 5
62191: PPUSH
62192: CALL_OW 311
62196: IFFALSE 62212
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
62198: LD_VAR 0 5
62202: PPUSH
62203: CALL_OW 311
62207: PPUSH
62208: CALL_OW 121
// end ;
62212: GO 62124
62214: POP
62215: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
62216: LD_VAR 0 2
62220: PPUSH
62221: LD_INT 95
62223: PUSH
62224: LD_EXP 110
62228: PUSH
62229: LD_VAR 0 1
62233: ARRAY
62234: PUSH
62235: EMPTY
62236: LIST
62237: LIST
62238: PPUSH
62239: CALL_OW 72
62243: PUSH
62244: LD_VAR 0 2
62248: EQUAL
62249: PUSH
62250: LD_EXP 109
62254: PUSH
62255: LD_VAR 0 1
62259: ARRAY
62260: OR
62261: PUSH
62262: LD_EXP 86
62266: PUSH
62267: LD_VAR 0 1
62271: ARRAY
62272: NOT
62273: OR
62274: IFFALSE 62044
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
62276: LD_ADDR_EXP 108
62280: PUSH
62281: LD_EXP 108
62285: PPUSH
62286: LD_VAR 0 1
62290: PPUSH
62291: LD_VAR 0 2
62295: PPUSH
62296: LD_INT 21
62298: PUSH
62299: LD_INT 2
62301: PUSH
62302: EMPTY
62303: LIST
62304: LIST
62305: PPUSH
62306: CALL_OW 72
62310: PPUSH
62311: CALL_OW 1
62315: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
62316: LD_VAR 0 1
62320: PPUSH
62321: LD_INT 19
62323: PPUSH
62324: CALL 66476 0 2
// MC_Reset ( base , 20 ) ;
62328: LD_VAR 0 1
62332: PPUSH
62333: LD_INT 20
62335: PPUSH
62336: CALL 66476 0 2
// end ; end_of_file
62340: LD_VAR 0 4
62344: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
62345: LD_INT 0
62347: PPUSH
62348: PPUSH
// skirmish := false ;
62349: LD_ADDR_EXP 84
62353: PUSH
62354: LD_INT 0
62356: ST_TO_ADDR
// debug_mc := false ;
62357: LD_ADDR_EXP 85
62361: PUSH
62362: LD_INT 0
62364: ST_TO_ADDR
// mc_bases := [ ] ;
62365: LD_ADDR_EXP 86
62369: PUSH
62370: EMPTY
62371: ST_TO_ADDR
// mc_sides := [ ] ;
62372: LD_ADDR_EXP 112
62376: PUSH
62377: EMPTY
62378: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
62379: LD_ADDR_EXP 87
62383: PUSH
62384: EMPTY
62385: ST_TO_ADDR
// mc_building_repairs := [ ] ;
62386: LD_ADDR_EXP 88
62390: PUSH
62391: EMPTY
62392: ST_TO_ADDR
// mc_need_heal := [ ] ;
62393: LD_ADDR_EXP 89
62397: PUSH
62398: EMPTY
62399: ST_TO_ADDR
// mc_healers := [ ] ;
62400: LD_ADDR_EXP 90
62404: PUSH
62405: EMPTY
62406: ST_TO_ADDR
// mc_build_list := [ ] ;
62407: LD_ADDR_EXP 91
62411: PUSH
62412: EMPTY
62413: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
62414: LD_ADDR_EXP 118
62418: PUSH
62419: EMPTY
62420: ST_TO_ADDR
// mc_builders := [ ] ;
62421: LD_ADDR_EXP 92
62425: PUSH
62426: EMPTY
62427: ST_TO_ADDR
// mc_construct_list := [ ] ;
62428: LD_ADDR_EXP 93
62432: PUSH
62433: EMPTY
62434: ST_TO_ADDR
// mc_turret_list := [ ] ;
62435: LD_ADDR_EXP 94
62439: PUSH
62440: EMPTY
62441: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
62442: LD_ADDR_EXP 95
62446: PUSH
62447: EMPTY
62448: ST_TO_ADDR
// mc_miners := [ ] ;
62449: LD_ADDR_EXP 100
62453: PUSH
62454: EMPTY
62455: ST_TO_ADDR
// mc_mines := [ ] ;
62456: LD_ADDR_EXP 99
62460: PUSH
62461: EMPTY
62462: ST_TO_ADDR
// mc_minefields := [ ] ;
62463: LD_ADDR_EXP 101
62467: PUSH
62468: EMPTY
62469: ST_TO_ADDR
// mc_crates := [ ] ;
62470: LD_ADDR_EXP 102
62474: PUSH
62475: EMPTY
62476: ST_TO_ADDR
// mc_crates_collector := [ ] ;
62477: LD_ADDR_EXP 103
62481: PUSH
62482: EMPTY
62483: ST_TO_ADDR
// mc_crates_area := [ ] ;
62484: LD_ADDR_EXP 104
62488: PUSH
62489: EMPTY
62490: ST_TO_ADDR
// mc_vehicles := [ ] ;
62491: LD_ADDR_EXP 105
62495: PUSH
62496: EMPTY
62497: ST_TO_ADDR
// mc_attack := [ ] ;
62498: LD_ADDR_EXP 106
62502: PUSH
62503: EMPTY
62504: ST_TO_ADDR
// mc_produce := [ ] ;
62505: LD_ADDR_EXP 107
62509: PUSH
62510: EMPTY
62511: ST_TO_ADDR
// mc_defender := [ ] ;
62512: LD_ADDR_EXP 108
62516: PUSH
62517: EMPTY
62518: ST_TO_ADDR
// mc_parking := [ ] ;
62519: LD_ADDR_EXP 110
62523: PUSH
62524: EMPTY
62525: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
62526: LD_ADDR_EXP 96
62530: PUSH
62531: EMPTY
62532: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
62533: LD_ADDR_EXP 98
62537: PUSH
62538: EMPTY
62539: ST_TO_ADDR
// mc_scan := [ ] ;
62540: LD_ADDR_EXP 109
62544: PUSH
62545: EMPTY
62546: ST_TO_ADDR
// mc_scan_area := [ ] ;
62547: LD_ADDR_EXP 111
62551: PUSH
62552: EMPTY
62553: ST_TO_ADDR
// mc_tech := [ ] ;
62554: LD_ADDR_EXP 113
62558: PUSH
62559: EMPTY
62560: ST_TO_ADDR
// mc_class := [ ] ;
62561: LD_ADDR_EXP 127
62565: PUSH
62566: EMPTY
62567: ST_TO_ADDR
// mc_class_case_use := [ ] ;
62568: LD_ADDR_EXP 128
62572: PUSH
62573: EMPTY
62574: ST_TO_ADDR
// mc_is_defending := [ ] ;
62575: LD_ADDR_EXP 129
62579: PUSH
62580: EMPTY
62581: ST_TO_ADDR
// end ;
62582: LD_VAR 0 1
62586: RET
// export function MC_Kill ( base ) ; begin
62587: LD_INT 0
62589: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
62590: LD_ADDR_EXP 86
62594: PUSH
62595: LD_EXP 86
62599: PPUSH
62600: LD_VAR 0 1
62604: PPUSH
62605: EMPTY
62606: PPUSH
62607: CALL_OW 1
62611: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62612: LD_ADDR_EXP 87
62616: PUSH
62617: LD_EXP 87
62621: PPUSH
62622: LD_VAR 0 1
62626: PPUSH
62627: EMPTY
62628: PPUSH
62629: CALL_OW 1
62633: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62634: LD_ADDR_EXP 88
62638: PUSH
62639: LD_EXP 88
62643: PPUSH
62644: LD_VAR 0 1
62648: PPUSH
62649: EMPTY
62650: PPUSH
62651: CALL_OW 1
62655: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62656: LD_ADDR_EXP 89
62660: PUSH
62661: LD_EXP 89
62665: PPUSH
62666: LD_VAR 0 1
62670: PPUSH
62671: EMPTY
62672: PPUSH
62673: CALL_OW 1
62677: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62678: LD_ADDR_EXP 90
62682: PUSH
62683: LD_EXP 90
62687: PPUSH
62688: LD_VAR 0 1
62692: PPUSH
62693: EMPTY
62694: PPUSH
62695: CALL_OW 1
62699: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62700: LD_ADDR_EXP 91
62704: PUSH
62705: LD_EXP 91
62709: PPUSH
62710: LD_VAR 0 1
62714: PPUSH
62715: EMPTY
62716: PPUSH
62717: CALL_OW 1
62721: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62722: LD_ADDR_EXP 92
62726: PUSH
62727: LD_EXP 92
62731: PPUSH
62732: LD_VAR 0 1
62736: PPUSH
62737: EMPTY
62738: PPUSH
62739: CALL_OW 1
62743: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62744: LD_ADDR_EXP 93
62748: PUSH
62749: LD_EXP 93
62753: PPUSH
62754: LD_VAR 0 1
62758: PPUSH
62759: EMPTY
62760: PPUSH
62761: CALL_OW 1
62765: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62766: LD_ADDR_EXP 94
62770: PUSH
62771: LD_EXP 94
62775: PPUSH
62776: LD_VAR 0 1
62780: PPUSH
62781: EMPTY
62782: PPUSH
62783: CALL_OW 1
62787: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62788: LD_ADDR_EXP 95
62792: PUSH
62793: LD_EXP 95
62797: PPUSH
62798: LD_VAR 0 1
62802: PPUSH
62803: EMPTY
62804: PPUSH
62805: CALL_OW 1
62809: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62810: LD_ADDR_EXP 96
62814: PUSH
62815: LD_EXP 96
62819: PPUSH
62820: LD_VAR 0 1
62824: PPUSH
62825: EMPTY
62826: PPUSH
62827: CALL_OW 1
62831: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62832: LD_ADDR_EXP 97
62836: PUSH
62837: LD_EXP 97
62841: PPUSH
62842: LD_VAR 0 1
62846: PPUSH
62847: LD_INT 0
62849: PPUSH
62850: CALL_OW 1
62854: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62855: LD_ADDR_EXP 98
62859: PUSH
62860: LD_EXP 98
62864: PPUSH
62865: LD_VAR 0 1
62869: PPUSH
62870: EMPTY
62871: PPUSH
62872: CALL_OW 1
62876: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62877: LD_ADDR_EXP 99
62881: PUSH
62882: LD_EXP 99
62886: PPUSH
62887: LD_VAR 0 1
62891: PPUSH
62892: EMPTY
62893: PPUSH
62894: CALL_OW 1
62898: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62899: LD_ADDR_EXP 100
62903: PUSH
62904: LD_EXP 100
62908: PPUSH
62909: LD_VAR 0 1
62913: PPUSH
62914: EMPTY
62915: PPUSH
62916: CALL_OW 1
62920: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62921: LD_ADDR_EXP 101
62925: PUSH
62926: LD_EXP 101
62930: PPUSH
62931: LD_VAR 0 1
62935: PPUSH
62936: EMPTY
62937: PPUSH
62938: CALL_OW 1
62942: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62943: LD_ADDR_EXP 102
62947: PUSH
62948: LD_EXP 102
62952: PPUSH
62953: LD_VAR 0 1
62957: PPUSH
62958: EMPTY
62959: PPUSH
62960: CALL_OW 1
62964: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62965: LD_ADDR_EXP 103
62969: PUSH
62970: LD_EXP 103
62974: PPUSH
62975: LD_VAR 0 1
62979: PPUSH
62980: EMPTY
62981: PPUSH
62982: CALL_OW 1
62986: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62987: LD_ADDR_EXP 104
62991: PUSH
62992: LD_EXP 104
62996: PPUSH
62997: LD_VAR 0 1
63001: PPUSH
63002: EMPTY
63003: PPUSH
63004: CALL_OW 1
63008: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
63009: LD_ADDR_EXP 105
63013: PUSH
63014: LD_EXP 105
63018: PPUSH
63019: LD_VAR 0 1
63023: PPUSH
63024: EMPTY
63025: PPUSH
63026: CALL_OW 1
63030: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
63031: LD_ADDR_EXP 106
63035: PUSH
63036: LD_EXP 106
63040: PPUSH
63041: LD_VAR 0 1
63045: PPUSH
63046: EMPTY
63047: PPUSH
63048: CALL_OW 1
63052: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
63053: LD_ADDR_EXP 107
63057: PUSH
63058: LD_EXP 107
63062: PPUSH
63063: LD_VAR 0 1
63067: PPUSH
63068: EMPTY
63069: PPUSH
63070: CALL_OW 1
63074: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
63075: LD_ADDR_EXP 108
63079: PUSH
63080: LD_EXP 108
63084: PPUSH
63085: LD_VAR 0 1
63089: PPUSH
63090: EMPTY
63091: PPUSH
63092: CALL_OW 1
63096: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
63097: LD_ADDR_EXP 109
63101: PUSH
63102: LD_EXP 109
63106: PPUSH
63107: LD_VAR 0 1
63111: PPUSH
63112: EMPTY
63113: PPUSH
63114: CALL_OW 1
63118: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
63119: LD_ADDR_EXP 110
63123: PUSH
63124: LD_EXP 110
63128: PPUSH
63129: LD_VAR 0 1
63133: PPUSH
63134: EMPTY
63135: PPUSH
63136: CALL_OW 1
63140: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
63141: LD_ADDR_EXP 111
63145: PUSH
63146: LD_EXP 111
63150: PPUSH
63151: LD_VAR 0 1
63155: PPUSH
63156: EMPTY
63157: PPUSH
63158: CALL_OW 1
63162: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
63163: LD_ADDR_EXP 113
63167: PUSH
63168: LD_EXP 113
63172: PPUSH
63173: LD_VAR 0 1
63177: PPUSH
63178: EMPTY
63179: PPUSH
63180: CALL_OW 1
63184: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
63185: LD_ADDR_EXP 115
63189: PUSH
63190: LD_EXP 115
63194: PPUSH
63195: LD_VAR 0 1
63199: PPUSH
63200: EMPTY
63201: PPUSH
63202: CALL_OW 1
63206: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
63207: LD_ADDR_EXP 116
63211: PUSH
63212: LD_EXP 116
63216: PPUSH
63217: LD_VAR 0 1
63221: PPUSH
63222: EMPTY
63223: PPUSH
63224: CALL_OW 1
63228: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
63229: LD_ADDR_EXP 117
63233: PUSH
63234: LD_EXP 117
63238: PPUSH
63239: LD_VAR 0 1
63243: PPUSH
63244: EMPTY
63245: PPUSH
63246: CALL_OW 1
63250: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
63251: LD_ADDR_EXP 118
63255: PUSH
63256: LD_EXP 118
63260: PPUSH
63261: LD_VAR 0 1
63265: PPUSH
63266: EMPTY
63267: PPUSH
63268: CALL_OW 1
63272: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
63273: LD_ADDR_EXP 119
63277: PUSH
63278: LD_EXP 119
63282: PPUSH
63283: LD_VAR 0 1
63287: PPUSH
63288: EMPTY
63289: PPUSH
63290: CALL_OW 1
63294: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
63295: LD_ADDR_EXP 120
63299: PUSH
63300: LD_EXP 120
63304: PPUSH
63305: LD_VAR 0 1
63309: PPUSH
63310: EMPTY
63311: PPUSH
63312: CALL_OW 1
63316: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
63317: LD_ADDR_EXP 121
63321: PUSH
63322: LD_EXP 121
63326: PPUSH
63327: LD_VAR 0 1
63331: PPUSH
63332: EMPTY
63333: PPUSH
63334: CALL_OW 1
63338: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
63339: LD_ADDR_EXP 122
63343: PUSH
63344: LD_EXP 122
63348: PPUSH
63349: LD_VAR 0 1
63353: PPUSH
63354: EMPTY
63355: PPUSH
63356: CALL_OW 1
63360: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
63361: LD_ADDR_EXP 123
63365: PUSH
63366: LD_EXP 123
63370: PPUSH
63371: LD_VAR 0 1
63375: PPUSH
63376: EMPTY
63377: PPUSH
63378: CALL_OW 1
63382: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
63383: LD_ADDR_EXP 124
63387: PUSH
63388: LD_EXP 124
63392: PPUSH
63393: LD_VAR 0 1
63397: PPUSH
63398: EMPTY
63399: PPUSH
63400: CALL_OW 1
63404: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63405: LD_ADDR_EXP 125
63409: PUSH
63410: LD_EXP 125
63414: PPUSH
63415: LD_VAR 0 1
63419: PPUSH
63420: EMPTY
63421: PPUSH
63422: CALL_OW 1
63426: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63427: LD_ADDR_EXP 126
63431: PUSH
63432: LD_EXP 126
63436: PPUSH
63437: LD_VAR 0 1
63441: PPUSH
63442: EMPTY
63443: PPUSH
63444: CALL_OW 1
63448: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63449: LD_ADDR_EXP 127
63453: PUSH
63454: LD_EXP 127
63458: PPUSH
63459: LD_VAR 0 1
63463: PPUSH
63464: EMPTY
63465: PPUSH
63466: CALL_OW 1
63470: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63471: LD_ADDR_EXP 128
63475: PUSH
63476: LD_EXP 128
63480: PPUSH
63481: LD_VAR 0 1
63485: PPUSH
63486: LD_INT 0
63488: PPUSH
63489: CALL_OW 1
63493: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63494: LD_ADDR_EXP 129
63498: PUSH
63499: LD_EXP 129
63503: PPUSH
63504: LD_VAR 0 1
63508: PPUSH
63509: LD_INT 0
63511: PPUSH
63512: CALL_OW 1
63516: ST_TO_ADDR
// end ;
63517: LD_VAR 0 2
63521: RET
// export function MC_Add ( side , units ) ; var base ; begin
63522: LD_INT 0
63524: PPUSH
63525: PPUSH
// base := mc_bases + 1 ;
63526: LD_ADDR_VAR 0 4
63530: PUSH
63531: LD_EXP 86
63535: PUSH
63536: LD_INT 1
63538: PLUS
63539: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
63540: LD_ADDR_EXP 112
63544: PUSH
63545: LD_EXP 112
63549: PPUSH
63550: LD_VAR 0 4
63554: PPUSH
63555: LD_VAR 0 1
63559: PPUSH
63560: CALL_OW 1
63564: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
63565: LD_ADDR_EXP 86
63569: PUSH
63570: LD_EXP 86
63574: PPUSH
63575: LD_VAR 0 4
63579: PPUSH
63580: LD_VAR 0 2
63584: PPUSH
63585: CALL_OW 1
63589: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
63590: LD_ADDR_EXP 87
63594: PUSH
63595: LD_EXP 87
63599: PPUSH
63600: LD_VAR 0 4
63604: PPUSH
63605: EMPTY
63606: PPUSH
63607: CALL_OW 1
63611: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
63612: LD_ADDR_EXP 88
63616: PUSH
63617: LD_EXP 88
63621: PPUSH
63622: LD_VAR 0 4
63626: PPUSH
63627: EMPTY
63628: PPUSH
63629: CALL_OW 1
63633: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
63634: LD_ADDR_EXP 89
63638: PUSH
63639: LD_EXP 89
63643: PPUSH
63644: LD_VAR 0 4
63648: PPUSH
63649: EMPTY
63650: PPUSH
63651: CALL_OW 1
63655: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
63656: LD_ADDR_EXP 90
63660: PUSH
63661: LD_EXP 90
63665: PPUSH
63666: LD_VAR 0 4
63670: PPUSH
63671: EMPTY
63672: PPUSH
63673: CALL_OW 1
63677: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
63678: LD_ADDR_EXP 91
63682: PUSH
63683: LD_EXP 91
63687: PPUSH
63688: LD_VAR 0 4
63692: PPUSH
63693: EMPTY
63694: PPUSH
63695: CALL_OW 1
63699: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
63700: LD_ADDR_EXP 92
63704: PUSH
63705: LD_EXP 92
63709: PPUSH
63710: LD_VAR 0 4
63714: PPUSH
63715: EMPTY
63716: PPUSH
63717: CALL_OW 1
63721: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
63722: LD_ADDR_EXP 93
63726: PUSH
63727: LD_EXP 93
63731: PPUSH
63732: LD_VAR 0 4
63736: PPUSH
63737: EMPTY
63738: PPUSH
63739: CALL_OW 1
63743: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
63744: LD_ADDR_EXP 94
63748: PUSH
63749: LD_EXP 94
63753: PPUSH
63754: LD_VAR 0 4
63758: PPUSH
63759: EMPTY
63760: PPUSH
63761: CALL_OW 1
63765: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
63766: LD_ADDR_EXP 95
63770: PUSH
63771: LD_EXP 95
63775: PPUSH
63776: LD_VAR 0 4
63780: PPUSH
63781: EMPTY
63782: PPUSH
63783: CALL_OW 1
63787: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
63788: LD_ADDR_EXP 96
63792: PUSH
63793: LD_EXP 96
63797: PPUSH
63798: LD_VAR 0 4
63802: PPUSH
63803: EMPTY
63804: PPUSH
63805: CALL_OW 1
63809: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
63810: LD_ADDR_EXP 97
63814: PUSH
63815: LD_EXP 97
63819: PPUSH
63820: LD_VAR 0 4
63824: PPUSH
63825: LD_INT 0
63827: PPUSH
63828: CALL_OW 1
63832: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
63833: LD_ADDR_EXP 98
63837: PUSH
63838: LD_EXP 98
63842: PPUSH
63843: LD_VAR 0 4
63847: PPUSH
63848: EMPTY
63849: PPUSH
63850: CALL_OW 1
63854: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
63855: LD_ADDR_EXP 99
63859: PUSH
63860: LD_EXP 99
63864: PPUSH
63865: LD_VAR 0 4
63869: PPUSH
63870: EMPTY
63871: PPUSH
63872: CALL_OW 1
63876: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
63877: LD_ADDR_EXP 100
63881: PUSH
63882: LD_EXP 100
63886: PPUSH
63887: LD_VAR 0 4
63891: PPUSH
63892: EMPTY
63893: PPUSH
63894: CALL_OW 1
63898: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
63899: LD_ADDR_EXP 101
63903: PUSH
63904: LD_EXP 101
63908: PPUSH
63909: LD_VAR 0 4
63913: PPUSH
63914: EMPTY
63915: PPUSH
63916: CALL_OW 1
63920: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
63921: LD_ADDR_EXP 102
63925: PUSH
63926: LD_EXP 102
63930: PPUSH
63931: LD_VAR 0 4
63935: PPUSH
63936: EMPTY
63937: PPUSH
63938: CALL_OW 1
63942: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
63943: LD_ADDR_EXP 103
63947: PUSH
63948: LD_EXP 103
63952: PPUSH
63953: LD_VAR 0 4
63957: PPUSH
63958: EMPTY
63959: PPUSH
63960: CALL_OW 1
63964: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
63965: LD_ADDR_EXP 104
63969: PUSH
63970: LD_EXP 104
63974: PPUSH
63975: LD_VAR 0 4
63979: PPUSH
63980: EMPTY
63981: PPUSH
63982: CALL_OW 1
63986: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
63987: LD_ADDR_EXP 105
63991: PUSH
63992: LD_EXP 105
63996: PPUSH
63997: LD_VAR 0 4
64001: PPUSH
64002: EMPTY
64003: PPUSH
64004: CALL_OW 1
64008: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
64009: LD_ADDR_EXP 106
64013: PUSH
64014: LD_EXP 106
64018: PPUSH
64019: LD_VAR 0 4
64023: PPUSH
64024: EMPTY
64025: PPUSH
64026: CALL_OW 1
64030: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
64031: LD_ADDR_EXP 107
64035: PUSH
64036: LD_EXP 107
64040: PPUSH
64041: LD_VAR 0 4
64045: PPUSH
64046: EMPTY
64047: PPUSH
64048: CALL_OW 1
64052: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
64053: LD_ADDR_EXP 108
64057: PUSH
64058: LD_EXP 108
64062: PPUSH
64063: LD_VAR 0 4
64067: PPUSH
64068: EMPTY
64069: PPUSH
64070: CALL_OW 1
64074: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
64075: LD_ADDR_EXP 109
64079: PUSH
64080: LD_EXP 109
64084: PPUSH
64085: LD_VAR 0 4
64089: PPUSH
64090: EMPTY
64091: PPUSH
64092: CALL_OW 1
64096: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
64097: LD_ADDR_EXP 110
64101: PUSH
64102: LD_EXP 110
64106: PPUSH
64107: LD_VAR 0 4
64111: PPUSH
64112: EMPTY
64113: PPUSH
64114: CALL_OW 1
64118: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
64119: LD_ADDR_EXP 111
64123: PUSH
64124: LD_EXP 111
64128: PPUSH
64129: LD_VAR 0 4
64133: PPUSH
64134: EMPTY
64135: PPUSH
64136: CALL_OW 1
64140: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
64141: LD_ADDR_EXP 113
64145: PUSH
64146: LD_EXP 113
64150: PPUSH
64151: LD_VAR 0 4
64155: PPUSH
64156: EMPTY
64157: PPUSH
64158: CALL_OW 1
64162: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
64163: LD_ADDR_EXP 115
64167: PUSH
64168: LD_EXP 115
64172: PPUSH
64173: LD_VAR 0 4
64177: PPUSH
64178: EMPTY
64179: PPUSH
64180: CALL_OW 1
64184: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
64185: LD_ADDR_EXP 116
64189: PUSH
64190: LD_EXP 116
64194: PPUSH
64195: LD_VAR 0 4
64199: PPUSH
64200: EMPTY
64201: PPUSH
64202: CALL_OW 1
64206: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
64207: LD_ADDR_EXP 117
64211: PUSH
64212: LD_EXP 117
64216: PPUSH
64217: LD_VAR 0 4
64221: PPUSH
64222: EMPTY
64223: PPUSH
64224: CALL_OW 1
64228: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
64229: LD_ADDR_EXP 118
64233: PUSH
64234: LD_EXP 118
64238: PPUSH
64239: LD_VAR 0 4
64243: PPUSH
64244: EMPTY
64245: PPUSH
64246: CALL_OW 1
64250: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
64251: LD_ADDR_EXP 119
64255: PUSH
64256: LD_EXP 119
64260: PPUSH
64261: LD_VAR 0 4
64265: PPUSH
64266: EMPTY
64267: PPUSH
64268: CALL_OW 1
64272: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
64273: LD_ADDR_EXP 120
64277: PUSH
64278: LD_EXP 120
64282: PPUSH
64283: LD_VAR 0 4
64287: PPUSH
64288: EMPTY
64289: PPUSH
64290: CALL_OW 1
64294: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
64295: LD_ADDR_EXP 121
64299: PUSH
64300: LD_EXP 121
64304: PPUSH
64305: LD_VAR 0 4
64309: PPUSH
64310: EMPTY
64311: PPUSH
64312: CALL_OW 1
64316: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
64317: LD_ADDR_EXP 122
64321: PUSH
64322: LD_EXP 122
64326: PPUSH
64327: LD_VAR 0 4
64331: PPUSH
64332: EMPTY
64333: PPUSH
64334: CALL_OW 1
64338: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
64339: LD_ADDR_EXP 123
64343: PUSH
64344: LD_EXP 123
64348: PPUSH
64349: LD_VAR 0 4
64353: PPUSH
64354: EMPTY
64355: PPUSH
64356: CALL_OW 1
64360: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
64361: LD_ADDR_EXP 124
64365: PUSH
64366: LD_EXP 124
64370: PPUSH
64371: LD_VAR 0 4
64375: PPUSH
64376: EMPTY
64377: PPUSH
64378: CALL_OW 1
64382: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
64383: LD_ADDR_EXP 125
64387: PUSH
64388: LD_EXP 125
64392: PPUSH
64393: LD_VAR 0 4
64397: PPUSH
64398: EMPTY
64399: PPUSH
64400: CALL_OW 1
64404: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
64405: LD_ADDR_EXP 126
64409: PUSH
64410: LD_EXP 126
64414: PPUSH
64415: LD_VAR 0 4
64419: PPUSH
64420: EMPTY
64421: PPUSH
64422: CALL_OW 1
64426: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
64427: LD_ADDR_EXP 127
64431: PUSH
64432: LD_EXP 127
64436: PPUSH
64437: LD_VAR 0 4
64441: PPUSH
64442: EMPTY
64443: PPUSH
64444: CALL_OW 1
64448: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
64449: LD_ADDR_EXP 128
64453: PUSH
64454: LD_EXP 128
64458: PPUSH
64459: LD_VAR 0 4
64463: PPUSH
64464: LD_INT 0
64466: PPUSH
64467: CALL_OW 1
64471: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
64472: LD_ADDR_EXP 129
64476: PUSH
64477: LD_EXP 129
64481: PPUSH
64482: LD_VAR 0 4
64486: PPUSH
64487: LD_INT 0
64489: PPUSH
64490: CALL_OW 1
64494: ST_TO_ADDR
// result := base ;
64495: LD_ADDR_VAR 0 3
64499: PUSH
64500: LD_VAR 0 4
64504: ST_TO_ADDR
// end ;
64505: LD_VAR 0 3
64509: RET
// export function MC_Start ( ) ; var i ; begin
64510: LD_INT 0
64512: PPUSH
64513: PPUSH
// for i = 1 to mc_bases do
64514: LD_ADDR_VAR 0 2
64518: PUSH
64519: DOUBLE
64520: LD_INT 1
64522: DEC
64523: ST_TO_ADDR
64524: LD_EXP 86
64528: PUSH
64529: FOR_TO
64530: IFFALSE 65607
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
64532: LD_ADDR_EXP 86
64536: PUSH
64537: LD_EXP 86
64541: PPUSH
64542: LD_VAR 0 2
64546: PPUSH
64547: LD_EXP 86
64551: PUSH
64552: LD_VAR 0 2
64556: ARRAY
64557: PUSH
64558: LD_INT 0
64560: DIFF
64561: PPUSH
64562: CALL_OW 1
64566: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
64567: LD_ADDR_EXP 87
64571: PUSH
64572: LD_EXP 87
64576: PPUSH
64577: LD_VAR 0 2
64581: PPUSH
64582: EMPTY
64583: PPUSH
64584: CALL_OW 1
64588: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64589: LD_ADDR_EXP 88
64593: PUSH
64594: LD_EXP 88
64598: PPUSH
64599: LD_VAR 0 2
64603: PPUSH
64604: EMPTY
64605: PPUSH
64606: CALL_OW 1
64610: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
64611: LD_ADDR_EXP 89
64615: PUSH
64616: LD_EXP 89
64620: PPUSH
64621: LD_VAR 0 2
64625: PPUSH
64626: EMPTY
64627: PPUSH
64628: CALL_OW 1
64632: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
64633: LD_ADDR_EXP 90
64637: PUSH
64638: LD_EXP 90
64642: PPUSH
64643: LD_VAR 0 2
64647: PPUSH
64648: EMPTY
64649: PUSH
64650: EMPTY
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PPUSH
64656: CALL_OW 1
64660: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
64661: LD_ADDR_EXP 91
64665: PUSH
64666: LD_EXP 91
64670: PPUSH
64671: LD_VAR 0 2
64675: PPUSH
64676: EMPTY
64677: PPUSH
64678: CALL_OW 1
64682: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
64683: LD_ADDR_EXP 118
64687: PUSH
64688: LD_EXP 118
64692: PPUSH
64693: LD_VAR 0 2
64697: PPUSH
64698: EMPTY
64699: PPUSH
64700: CALL_OW 1
64704: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
64705: LD_ADDR_EXP 92
64709: PUSH
64710: LD_EXP 92
64714: PPUSH
64715: LD_VAR 0 2
64719: PPUSH
64720: EMPTY
64721: PPUSH
64722: CALL_OW 1
64726: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
64727: LD_ADDR_EXP 93
64731: PUSH
64732: LD_EXP 93
64736: PPUSH
64737: LD_VAR 0 2
64741: PPUSH
64742: EMPTY
64743: PPUSH
64744: CALL_OW 1
64748: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
64749: LD_ADDR_EXP 94
64753: PUSH
64754: LD_EXP 94
64758: PPUSH
64759: LD_VAR 0 2
64763: PPUSH
64764: LD_EXP 86
64768: PUSH
64769: LD_VAR 0 2
64773: ARRAY
64774: PPUSH
64775: LD_INT 2
64777: PUSH
64778: LD_INT 30
64780: PUSH
64781: LD_INT 32
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: LD_INT 30
64790: PUSH
64791: LD_INT 33
64793: PUSH
64794: EMPTY
64795: LIST
64796: LIST
64797: PUSH
64798: EMPTY
64799: LIST
64800: LIST
64801: LIST
64802: PPUSH
64803: CALL_OW 72
64807: PPUSH
64808: CALL_OW 1
64812: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
64813: LD_ADDR_EXP 95
64817: PUSH
64818: LD_EXP 95
64822: PPUSH
64823: LD_VAR 0 2
64827: PPUSH
64828: LD_EXP 86
64832: PUSH
64833: LD_VAR 0 2
64837: ARRAY
64838: PPUSH
64839: LD_INT 2
64841: PUSH
64842: LD_INT 30
64844: PUSH
64845: LD_INT 32
64847: PUSH
64848: EMPTY
64849: LIST
64850: LIST
64851: PUSH
64852: LD_INT 30
64854: PUSH
64855: LD_INT 31
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: PUSH
64862: EMPTY
64863: LIST
64864: LIST
64865: LIST
64866: PUSH
64867: LD_INT 58
64869: PUSH
64870: EMPTY
64871: LIST
64872: PUSH
64873: EMPTY
64874: LIST
64875: LIST
64876: PPUSH
64877: CALL_OW 72
64881: PPUSH
64882: CALL_OW 1
64886: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
64887: LD_ADDR_EXP 96
64891: PUSH
64892: LD_EXP 96
64896: PPUSH
64897: LD_VAR 0 2
64901: PPUSH
64902: EMPTY
64903: PPUSH
64904: CALL_OW 1
64908: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
64909: LD_ADDR_EXP 100
64913: PUSH
64914: LD_EXP 100
64918: PPUSH
64919: LD_VAR 0 2
64923: PPUSH
64924: EMPTY
64925: PPUSH
64926: CALL_OW 1
64930: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
64931: LD_ADDR_EXP 99
64935: PUSH
64936: LD_EXP 99
64940: PPUSH
64941: LD_VAR 0 2
64945: PPUSH
64946: EMPTY
64947: PPUSH
64948: CALL_OW 1
64952: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
64953: LD_ADDR_EXP 101
64957: PUSH
64958: LD_EXP 101
64962: PPUSH
64963: LD_VAR 0 2
64967: PPUSH
64968: EMPTY
64969: PPUSH
64970: CALL_OW 1
64974: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
64975: LD_ADDR_EXP 102
64979: PUSH
64980: LD_EXP 102
64984: PPUSH
64985: LD_VAR 0 2
64989: PPUSH
64990: EMPTY
64991: PPUSH
64992: CALL_OW 1
64996: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64997: LD_ADDR_EXP 103
65001: PUSH
65002: LD_EXP 103
65006: PPUSH
65007: LD_VAR 0 2
65011: PPUSH
65012: EMPTY
65013: PPUSH
65014: CALL_OW 1
65018: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
65019: LD_ADDR_EXP 104
65023: PUSH
65024: LD_EXP 104
65028: PPUSH
65029: LD_VAR 0 2
65033: PPUSH
65034: EMPTY
65035: PPUSH
65036: CALL_OW 1
65040: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
65041: LD_ADDR_EXP 105
65045: PUSH
65046: LD_EXP 105
65050: PPUSH
65051: LD_VAR 0 2
65055: PPUSH
65056: EMPTY
65057: PPUSH
65058: CALL_OW 1
65062: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
65063: LD_ADDR_EXP 106
65067: PUSH
65068: LD_EXP 106
65072: PPUSH
65073: LD_VAR 0 2
65077: PPUSH
65078: EMPTY
65079: PPUSH
65080: CALL_OW 1
65084: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
65085: LD_ADDR_EXP 107
65089: PUSH
65090: LD_EXP 107
65094: PPUSH
65095: LD_VAR 0 2
65099: PPUSH
65100: EMPTY
65101: PPUSH
65102: CALL_OW 1
65106: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
65107: LD_ADDR_EXP 108
65111: PUSH
65112: LD_EXP 108
65116: PPUSH
65117: LD_VAR 0 2
65121: PPUSH
65122: EMPTY
65123: PPUSH
65124: CALL_OW 1
65128: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
65129: LD_ADDR_EXP 97
65133: PUSH
65134: LD_EXP 97
65138: PPUSH
65139: LD_VAR 0 2
65143: PPUSH
65144: LD_INT 0
65146: PPUSH
65147: CALL_OW 1
65151: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
65152: LD_ADDR_EXP 110
65156: PUSH
65157: LD_EXP 110
65161: PPUSH
65162: LD_VAR 0 2
65166: PPUSH
65167: LD_INT 0
65169: PPUSH
65170: CALL_OW 1
65174: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
65175: LD_ADDR_EXP 98
65179: PUSH
65180: LD_EXP 98
65184: PPUSH
65185: LD_VAR 0 2
65189: PPUSH
65190: EMPTY
65191: PPUSH
65192: CALL_OW 1
65196: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
65197: LD_ADDR_EXP 109
65201: PUSH
65202: LD_EXP 109
65206: PPUSH
65207: LD_VAR 0 2
65211: PPUSH
65212: LD_INT 0
65214: PPUSH
65215: CALL_OW 1
65219: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
65220: LD_ADDR_EXP 111
65224: PUSH
65225: LD_EXP 111
65229: PPUSH
65230: LD_VAR 0 2
65234: PPUSH
65235: EMPTY
65236: PPUSH
65237: CALL_OW 1
65241: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
65242: LD_ADDR_EXP 114
65246: PUSH
65247: LD_EXP 114
65251: PPUSH
65252: LD_VAR 0 2
65256: PPUSH
65257: LD_INT 0
65259: PPUSH
65260: CALL_OW 1
65264: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
65265: LD_ADDR_EXP 115
65269: PUSH
65270: LD_EXP 115
65274: PPUSH
65275: LD_VAR 0 2
65279: PPUSH
65280: EMPTY
65281: PPUSH
65282: CALL_OW 1
65286: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
65287: LD_ADDR_EXP 116
65291: PUSH
65292: LD_EXP 116
65296: PPUSH
65297: LD_VAR 0 2
65301: PPUSH
65302: EMPTY
65303: PPUSH
65304: CALL_OW 1
65308: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65309: LD_ADDR_EXP 117
65313: PUSH
65314: LD_EXP 117
65318: PPUSH
65319: LD_VAR 0 2
65323: PPUSH
65324: EMPTY
65325: PPUSH
65326: CALL_OW 1
65330: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
65331: LD_ADDR_EXP 119
65335: PUSH
65336: LD_EXP 119
65340: PPUSH
65341: LD_VAR 0 2
65345: PPUSH
65346: LD_EXP 86
65350: PUSH
65351: LD_VAR 0 2
65355: ARRAY
65356: PPUSH
65357: LD_INT 2
65359: PUSH
65360: LD_INT 30
65362: PUSH
65363: LD_INT 6
65365: PUSH
65366: EMPTY
65367: LIST
65368: LIST
65369: PUSH
65370: LD_INT 30
65372: PUSH
65373: LD_INT 7
65375: PUSH
65376: EMPTY
65377: LIST
65378: LIST
65379: PUSH
65380: LD_INT 30
65382: PUSH
65383: LD_INT 8
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: PPUSH
65396: CALL_OW 72
65400: PPUSH
65401: CALL_OW 1
65405: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
65406: LD_ADDR_EXP 120
65410: PUSH
65411: LD_EXP 120
65415: PPUSH
65416: LD_VAR 0 2
65420: PPUSH
65421: EMPTY
65422: PPUSH
65423: CALL_OW 1
65427: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
65428: LD_ADDR_EXP 121
65432: PUSH
65433: LD_EXP 121
65437: PPUSH
65438: LD_VAR 0 2
65442: PPUSH
65443: EMPTY
65444: PPUSH
65445: CALL_OW 1
65449: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
65450: LD_ADDR_EXP 122
65454: PUSH
65455: LD_EXP 122
65459: PPUSH
65460: LD_VAR 0 2
65464: PPUSH
65465: EMPTY
65466: PPUSH
65467: CALL_OW 1
65471: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
65472: LD_ADDR_EXP 123
65476: PUSH
65477: LD_EXP 123
65481: PPUSH
65482: LD_VAR 0 2
65486: PPUSH
65487: EMPTY
65488: PPUSH
65489: CALL_OW 1
65493: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
65494: LD_ADDR_EXP 124
65498: PUSH
65499: LD_EXP 124
65503: PPUSH
65504: LD_VAR 0 2
65508: PPUSH
65509: EMPTY
65510: PPUSH
65511: CALL_OW 1
65515: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
65516: LD_ADDR_EXP 125
65520: PUSH
65521: LD_EXP 125
65525: PPUSH
65526: LD_VAR 0 2
65530: PPUSH
65531: EMPTY
65532: PPUSH
65533: CALL_OW 1
65537: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
65538: LD_ADDR_EXP 126
65542: PUSH
65543: LD_EXP 126
65547: PPUSH
65548: LD_VAR 0 2
65552: PPUSH
65553: EMPTY
65554: PPUSH
65555: CALL_OW 1
65559: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
65560: LD_ADDR_EXP 127
65564: PUSH
65565: LD_EXP 127
65569: PPUSH
65570: LD_VAR 0 2
65574: PPUSH
65575: EMPTY
65576: PPUSH
65577: CALL_OW 1
65581: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
65582: LD_ADDR_EXP 128
65586: PUSH
65587: LD_EXP 128
65591: PPUSH
65592: LD_VAR 0 2
65596: PPUSH
65597: LD_INT 0
65599: PPUSH
65600: CALL_OW 1
65604: ST_TO_ADDR
// end ;
65605: GO 64529
65607: POP
65608: POP
// MC_InitSides ( ) ;
65609: CALL 65895 0 0
// MC_InitResearch ( ) ;
65613: CALL 65634 0 0
// CustomInitMacro ( ) ;
65617: CALL 0 0 0
// skirmish := true ;
65621: LD_ADDR_EXP 84
65625: PUSH
65626: LD_INT 1
65628: ST_TO_ADDR
// end ;
65629: LD_VAR 0 1
65633: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
65634: LD_INT 0
65636: PPUSH
65637: PPUSH
65638: PPUSH
65639: PPUSH
65640: PPUSH
65641: PPUSH
// if not mc_bases then
65642: LD_EXP 86
65646: NOT
65647: IFFALSE 65651
// exit ;
65649: GO 65890
// for i = 1 to 8 do
65651: LD_ADDR_VAR 0 2
65655: PUSH
65656: DOUBLE
65657: LD_INT 1
65659: DEC
65660: ST_TO_ADDR
65661: LD_INT 8
65663: PUSH
65664: FOR_TO
65665: IFFALSE 65691
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
65667: LD_ADDR_EXP 113
65671: PUSH
65672: LD_EXP 113
65676: PPUSH
65677: LD_VAR 0 2
65681: PPUSH
65682: EMPTY
65683: PPUSH
65684: CALL_OW 1
65688: ST_TO_ADDR
65689: GO 65664
65691: POP
65692: POP
// tmp := [ ] ;
65693: LD_ADDR_VAR 0 5
65697: PUSH
65698: EMPTY
65699: ST_TO_ADDR
// for i = 1 to mc_sides do
65700: LD_ADDR_VAR 0 2
65704: PUSH
65705: DOUBLE
65706: LD_INT 1
65708: DEC
65709: ST_TO_ADDR
65710: LD_EXP 112
65714: PUSH
65715: FOR_TO
65716: IFFALSE 65774
// if not mc_sides [ i ] in tmp then
65718: LD_EXP 112
65722: PUSH
65723: LD_VAR 0 2
65727: ARRAY
65728: PUSH
65729: LD_VAR 0 5
65733: IN
65734: NOT
65735: IFFALSE 65772
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
65737: LD_ADDR_VAR 0 5
65741: PUSH
65742: LD_VAR 0 5
65746: PPUSH
65747: LD_VAR 0 5
65751: PUSH
65752: LD_INT 1
65754: PLUS
65755: PPUSH
65756: LD_EXP 112
65760: PUSH
65761: LD_VAR 0 2
65765: ARRAY
65766: PPUSH
65767: CALL_OW 2
65771: ST_TO_ADDR
65772: GO 65715
65774: POP
65775: POP
// if not tmp then
65776: LD_VAR 0 5
65780: NOT
65781: IFFALSE 65785
// exit ;
65783: GO 65890
// for j in tmp do
65785: LD_ADDR_VAR 0 3
65789: PUSH
65790: LD_VAR 0 5
65794: PUSH
65795: FOR_IN
65796: IFFALSE 65888
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
65798: LD_ADDR_VAR 0 6
65802: PUSH
65803: LD_INT 22
65805: PUSH
65806: LD_VAR 0 3
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PPUSH
65815: CALL_OW 69
65819: ST_TO_ADDR
// if not un then
65820: LD_VAR 0 6
65824: NOT
65825: IFFALSE 65829
// continue ;
65827: GO 65795
// nation := GetNation ( un [ 1 ] ) ;
65829: LD_ADDR_VAR 0 4
65833: PUSH
65834: LD_VAR 0 6
65838: PUSH
65839: LD_INT 1
65841: ARRAY
65842: PPUSH
65843: CALL_OW 248
65847: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
65848: LD_ADDR_EXP 113
65852: PUSH
65853: LD_EXP 113
65857: PPUSH
65858: LD_VAR 0 3
65862: PPUSH
65863: LD_VAR 0 3
65867: PPUSH
65868: LD_VAR 0 4
65872: PPUSH
65873: LD_INT 1
65875: PPUSH
65876: CALL 17568 0 3
65880: PPUSH
65881: CALL_OW 1
65885: ST_TO_ADDR
// end ;
65886: GO 65795
65888: POP
65889: POP
// end ;
65890: LD_VAR 0 1
65894: RET
// export function MC_InitSides ( ) ; var i ; begin
65895: LD_INT 0
65897: PPUSH
65898: PPUSH
// if not mc_bases then
65899: LD_EXP 86
65903: NOT
65904: IFFALSE 65908
// exit ;
65906: GO 65982
// for i = 1 to mc_bases do
65908: LD_ADDR_VAR 0 2
65912: PUSH
65913: DOUBLE
65914: LD_INT 1
65916: DEC
65917: ST_TO_ADDR
65918: LD_EXP 86
65922: PUSH
65923: FOR_TO
65924: IFFALSE 65980
// if mc_bases [ i ] then
65926: LD_EXP 86
65930: PUSH
65931: LD_VAR 0 2
65935: ARRAY
65936: IFFALSE 65978
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
65938: LD_ADDR_EXP 112
65942: PUSH
65943: LD_EXP 112
65947: PPUSH
65948: LD_VAR 0 2
65952: PPUSH
65953: LD_EXP 86
65957: PUSH
65958: LD_VAR 0 2
65962: ARRAY
65963: PUSH
65964: LD_INT 1
65966: ARRAY
65967: PPUSH
65968: CALL_OW 255
65972: PPUSH
65973: CALL_OW 1
65977: ST_TO_ADDR
65978: GO 65923
65980: POP
65981: POP
// end ;
65982: LD_VAR 0 1
65986: RET
// every 0 0$03 trigger skirmish do
65987: LD_EXP 84
65991: IFFALSE 66145
65993: GO 65995
65995: DISABLE
// begin enable ;
65996: ENABLE
// MC_CheckBuildings ( ) ;
65997: CALL 70643 0 0
// MC_CheckPeopleLife ( ) ;
66001: CALL 70768 0 0
// RaiseSailEvent ( 100 ) ;
66005: LD_INT 100
66007: PPUSH
66008: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
66012: LD_INT 103
66014: PPUSH
66015: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
66019: LD_INT 104
66021: PPUSH
66022: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
66026: LD_INT 105
66028: PPUSH
66029: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
66033: LD_INT 106
66035: PPUSH
66036: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
66040: LD_INT 107
66042: PPUSH
66043: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
66047: LD_INT 108
66049: PPUSH
66050: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
66054: LD_INT 109
66056: PPUSH
66057: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
66061: LD_INT 110
66063: PPUSH
66064: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
66068: LD_INT 111
66070: PPUSH
66071: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
66075: LD_INT 112
66077: PPUSH
66078: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
66082: LD_INT 113
66084: PPUSH
66085: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
66089: LD_INT 120
66091: PPUSH
66092: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
66096: LD_INT 121
66098: PPUSH
66099: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
66103: LD_INT 122
66105: PPUSH
66106: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
66110: LD_INT 123
66112: PPUSH
66113: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
66117: LD_INT 124
66119: PPUSH
66120: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
66124: LD_INT 125
66126: PPUSH
66127: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
66131: LD_INT 126
66133: PPUSH
66134: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
66138: LD_INT 200
66140: PPUSH
66141: CALL_OW 427
// end ;
66145: END
// on SailEvent ( event ) do begin if event < 100 then
66146: LD_VAR 0 1
66150: PUSH
66151: LD_INT 100
66153: LESS
66154: IFFALSE 66165
// CustomEvent ( event ) ;
66156: LD_VAR 0 1
66160: PPUSH
66161: CALL 8 0 1
// if event = 100 then
66165: LD_VAR 0 1
66169: PUSH
66170: LD_INT 100
66172: EQUAL
66173: IFFALSE 66179
// MC_ClassManager ( ) ;
66175: CALL 66571 0 0
// if event = 101 then
66179: LD_VAR 0 1
66183: PUSH
66184: LD_INT 101
66186: EQUAL
66187: IFFALSE 66193
// MC_RepairBuildings ( ) ;
66189: CALL 71353 0 0
// if event = 102 then
66193: LD_VAR 0 1
66197: PUSH
66198: LD_INT 102
66200: EQUAL
66201: IFFALSE 66207
// MC_Heal ( ) ;
66203: CALL 72238 0 0
// if event = 103 then
66207: LD_VAR 0 1
66211: PUSH
66212: LD_INT 103
66214: EQUAL
66215: IFFALSE 66221
// MC_Build ( ) ;
66217: CALL 72660 0 0
// if event = 104 then
66221: LD_VAR 0 1
66225: PUSH
66226: LD_INT 104
66228: EQUAL
66229: IFFALSE 66235
// MC_TurretWeapon ( ) ;
66231: CALL 74301 0 0
// if event = 105 then
66235: LD_VAR 0 1
66239: PUSH
66240: LD_INT 105
66242: EQUAL
66243: IFFALSE 66249
// MC_BuildUpgrade ( ) ;
66245: CALL 73852 0 0
// if event = 106 then
66249: LD_VAR 0 1
66253: PUSH
66254: LD_INT 106
66256: EQUAL
66257: IFFALSE 66263
// MC_PlantMines ( ) ;
66259: CALL 74731 0 0
// if event = 107 then
66263: LD_VAR 0 1
66267: PUSH
66268: LD_INT 107
66270: EQUAL
66271: IFFALSE 66277
// MC_CollectCrates ( ) ;
66273: CALL 75522 0 0
// if event = 108 then
66277: LD_VAR 0 1
66281: PUSH
66282: LD_INT 108
66284: EQUAL
66285: IFFALSE 66291
// MC_LinkRemoteControl ( ) ;
66287: CALL 77298 0 0
// if event = 109 then
66291: LD_VAR 0 1
66295: PUSH
66296: LD_INT 109
66298: EQUAL
66299: IFFALSE 66305
// MC_ProduceVehicle ( ) ;
66301: CALL 77479 0 0
// if event = 110 then
66305: LD_VAR 0 1
66309: PUSH
66310: LD_INT 110
66312: EQUAL
66313: IFFALSE 66319
// MC_SendAttack ( ) ;
66315: CALL 77945 0 0
// if event = 111 then
66319: LD_VAR 0 1
66323: PUSH
66324: LD_INT 111
66326: EQUAL
66327: IFFALSE 66333
// MC_Defend ( ) ;
66329: CALL 78053 0 0
// if event = 112 then
66333: LD_VAR 0 1
66337: PUSH
66338: LD_INT 112
66340: EQUAL
66341: IFFALSE 66347
// MC_Research ( ) ;
66343: CALL 78775 0 0
// if event = 113 then
66347: LD_VAR 0 1
66351: PUSH
66352: LD_INT 113
66354: EQUAL
66355: IFFALSE 66361
// MC_MinesTrigger ( ) ;
66357: CALL 79889 0 0
// if event = 120 then
66361: LD_VAR 0 1
66365: PUSH
66366: LD_INT 120
66368: EQUAL
66369: IFFALSE 66375
// MC_RepairVehicle ( ) ;
66371: CALL 79988 0 0
// if event = 121 then
66375: LD_VAR 0 1
66379: PUSH
66380: LD_INT 121
66382: EQUAL
66383: IFFALSE 66389
// MC_TameApe ( ) ;
66385: CALL 80718 0 0
// if event = 122 then
66389: LD_VAR 0 1
66393: PUSH
66394: LD_INT 122
66396: EQUAL
66397: IFFALSE 66403
// MC_ChangeApeClass ( ) ;
66399: CALL 81547 0 0
// if event = 123 then
66403: LD_VAR 0 1
66407: PUSH
66408: LD_INT 123
66410: EQUAL
66411: IFFALSE 66417
// MC_Bazooka ( ) ;
66413: CALL 82197 0 0
// if event = 124 then
66417: LD_VAR 0 1
66421: PUSH
66422: LD_INT 124
66424: EQUAL
66425: IFFALSE 66431
// MC_TeleportExit ( ) ;
66427: CALL 82395 0 0
// if event = 125 then
66431: LD_VAR 0 1
66435: PUSH
66436: LD_INT 125
66438: EQUAL
66439: IFFALSE 66445
// MC_Deposits ( ) ;
66441: CALL 83042 0 0
// if event = 126 then
66445: LD_VAR 0 1
66449: PUSH
66450: LD_INT 126
66452: EQUAL
66453: IFFALSE 66459
// MC_RemoteDriver ( ) ;
66455: CALL 83667 0 0
// if event = 200 then
66459: LD_VAR 0 1
66463: PUSH
66464: LD_INT 200
66466: EQUAL
66467: IFFALSE 66473
// MC_Idle ( ) ;
66469: CALL 85616 0 0
// end ;
66473: PPOPN 1
66475: END
// export function MC_Reset ( base , tag ) ; var i ; begin
66476: LD_INT 0
66478: PPUSH
66479: PPUSH
// if not mc_bases [ base ] or not tag then
66480: LD_EXP 86
66484: PUSH
66485: LD_VAR 0 1
66489: ARRAY
66490: NOT
66491: PUSH
66492: LD_VAR 0 2
66496: NOT
66497: OR
66498: IFFALSE 66502
// exit ;
66500: GO 66566
// for i in mc_bases [ base ] union mc_ape [ base ] do
66502: LD_ADDR_VAR 0 4
66506: PUSH
66507: LD_EXP 86
66511: PUSH
66512: LD_VAR 0 1
66516: ARRAY
66517: PUSH
66518: LD_EXP 115
66522: PUSH
66523: LD_VAR 0 1
66527: ARRAY
66528: UNION
66529: PUSH
66530: FOR_IN
66531: IFFALSE 66564
// if GetTag ( i ) = tag then
66533: LD_VAR 0 4
66537: PPUSH
66538: CALL_OW 110
66542: PUSH
66543: LD_VAR 0 2
66547: EQUAL
66548: IFFALSE 66562
// SetTag ( i , 0 ) ;
66550: LD_VAR 0 4
66554: PPUSH
66555: LD_INT 0
66557: PPUSH
66558: CALL_OW 109
66562: GO 66530
66564: POP
66565: POP
// end ;
66566: LD_VAR 0 3
66570: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
66571: LD_INT 0
66573: PPUSH
66574: PPUSH
66575: PPUSH
66576: PPUSH
66577: PPUSH
66578: PPUSH
66579: PPUSH
66580: PPUSH
// if not mc_bases then
66581: LD_EXP 86
66585: NOT
66586: IFFALSE 66590
// exit ;
66588: GO 67048
// for i = 1 to mc_bases do
66590: LD_ADDR_VAR 0 2
66594: PUSH
66595: DOUBLE
66596: LD_INT 1
66598: DEC
66599: ST_TO_ADDR
66600: LD_EXP 86
66604: PUSH
66605: FOR_TO
66606: IFFALSE 67046
// begin tmp := MC_ClassCheckReq ( i ) ;
66608: LD_ADDR_VAR 0 4
66612: PUSH
66613: LD_VAR 0 2
66617: PPUSH
66618: CALL 67053 0 1
66622: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
66623: LD_ADDR_EXP 127
66627: PUSH
66628: LD_EXP 127
66632: PPUSH
66633: LD_VAR 0 2
66637: PPUSH
66638: LD_VAR 0 4
66642: PPUSH
66643: CALL_OW 1
66647: ST_TO_ADDR
// if not tmp then
66648: LD_VAR 0 4
66652: NOT
66653: IFFALSE 66657
// continue ;
66655: GO 66605
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
66657: LD_ADDR_VAR 0 6
66661: PUSH
66662: LD_EXP 86
66666: PUSH
66667: LD_VAR 0 2
66671: ARRAY
66672: PPUSH
66673: LD_INT 2
66675: PUSH
66676: LD_INT 30
66678: PUSH
66679: LD_INT 4
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 30
66688: PUSH
66689: LD_INT 5
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: LIST
66700: PPUSH
66701: CALL_OW 72
66705: PUSH
66706: LD_EXP 86
66710: PUSH
66711: LD_VAR 0 2
66715: ARRAY
66716: PPUSH
66717: LD_INT 2
66719: PUSH
66720: LD_INT 30
66722: PUSH
66723: LD_INT 0
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 30
66732: PUSH
66733: LD_INT 1
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: LIST
66744: PPUSH
66745: CALL_OW 72
66749: PUSH
66750: LD_EXP 86
66754: PUSH
66755: LD_VAR 0 2
66759: ARRAY
66760: PPUSH
66761: LD_INT 30
66763: PUSH
66764: LD_INT 3
66766: PUSH
66767: EMPTY
66768: LIST
66769: LIST
66770: PPUSH
66771: CALL_OW 72
66775: PUSH
66776: LD_EXP 86
66780: PUSH
66781: LD_VAR 0 2
66785: ARRAY
66786: PPUSH
66787: LD_INT 2
66789: PUSH
66790: LD_INT 30
66792: PUSH
66793: LD_INT 6
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 30
66802: PUSH
66803: LD_INT 7
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 30
66812: PUSH
66813: LD_INT 8
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: LIST
66824: LIST
66825: PPUSH
66826: CALL_OW 72
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: LIST
66835: LIST
66836: ST_TO_ADDR
// for j = 1 to 4 do
66837: LD_ADDR_VAR 0 3
66841: PUSH
66842: DOUBLE
66843: LD_INT 1
66845: DEC
66846: ST_TO_ADDR
66847: LD_INT 4
66849: PUSH
66850: FOR_TO
66851: IFFALSE 67042
// begin if not tmp [ j ] then
66853: LD_VAR 0 4
66857: PUSH
66858: LD_VAR 0 3
66862: ARRAY
66863: NOT
66864: IFFALSE 66868
// continue ;
66866: GO 66850
// for p in tmp [ j ] do
66868: LD_ADDR_VAR 0 5
66872: PUSH
66873: LD_VAR 0 4
66877: PUSH
66878: LD_VAR 0 3
66882: ARRAY
66883: PUSH
66884: FOR_IN
66885: IFFALSE 67038
// begin if not b [ j ] then
66887: LD_VAR 0 6
66891: PUSH
66892: LD_VAR 0 3
66896: ARRAY
66897: NOT
66898: IFFALSE 66902
// break ;
66900: GO 67038
// e := 0 ;
66902: LD_ADDR_VAR 0 7
66906: PUSH
66907: LD_INT 0
66909: ST_TO_ADDR
// for k in b [ j ] do
66910: LD_ADDR_VAR 0 8
66914: PUSH
66915: LD_VAR 0 6
66919: PUSH
66920: LD_VAR 0 3
66924: ARRAY
66925: PUSH
66926: FOR_IN
66927: IFFALSE 66954
// if IsNotFull ( k ) then
66929: LD_VAR 0 8
66933: PPUSH
66934: CALL 19717 0 1
66938: IFFALSE 66952
// begin e := k ;
66940: LD_ADDR_VAR 0 7
66944: PUSH
66945: LD_VAR 0 8
66949: ST_TO_ADDR
// break ;
66950: GO 66954
// end ;
66952: GO 66926
66954: POP
66955: POP
// if e and not UnitGoingToBuilding ( p , e ) then
66956: LD_VAR 0 7
66960: PUSH
66961: LD_VAR 0 5
66965: PPUSH
66966: LD_VAR 0 7
66970: PPUSH
66971: CALL 52470 0 2
66975: NOT
66976: AND
66977: IFFALSE 67036
// begin if IsInUnit ( p ) then
66979: LD_VAR 0 5
66983: PPUSH
66984: CALL_OW 310
66988: IFFALSE 66999
// ComExitBuilding ( p ) ;
66990: LD_VAR 0 5
66994: PPUSH
66995: CALL_OW 122
// ComEnterUnit ( p , e ) ;
66999: LD_VAR 0 5
67003: PPUSH
67004: LD_VAR 0 7
67008: PPUSH
67009: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
67013: LD_VAR 0 5
67017: PPUSH
67018: LD_VAR 0 3
67022: PPUSH
67023: CALL_OW 183
// AddComExitBuilding ( p ) ;
67027: LD_VAR 0 5
67031: PPUSH
67032: CALL_OW 182
// end ; end ;
67036: GO 66884
67038: POP
67039: POP
// end ;
67040: GO 66850
67042: POP
67043: POP
// end ;
67044: GO 66605
67046: POP
67047: POP
// end ;
67048: LD_VAR 0 1
67052: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
67053: LD_INT 0
67055: PPUSH
67056: PPUSH
67057: PPUSH
67058: PPUSH
67059: PPUSH
67060: PPUSH
67061: PPUSH
67062: PPUSH
67063: PPUSH
67064: PPUSH
67065: PPUSH
67066: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67067: LD_VAR 0 1
67071: NOT
67072: PUSH
67073: LD_EXP 86
67077: PUSH
67078: LD_VAR 0 1
67082: ARRAY
67083: NOT
67084: OR
67085: PUSH
67086: LD_EXP 86
67090: PUSH
67091: LD_VAR 0 1
67095: ARRAY
67096: PPUSH
67097: LD_INT 2
67099: PUSH
67100: LD_INT 30
67102: PUSH
67103: LD_INT 0
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 30
67112: PUSH
67113: LD_INT 1
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: EMPTY
67121: LIST
67122: LIST
67123: LIST
67124: PPUSH
67125: CALL_OW 72
67129: NOT
67130: OR
67131: IFFALSE 67135
// exit ;
67133: GO 70638
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67135: LD_ADDR_VAR 0 4
67139: PUSH
67140: LD_EXP 86
67144: PUSH
67145: LD_VAR 0 1
67149: ARRAY
67150: PPUSH
67151: LD_INT 2
67153: PUSH
67154: LD_INT 25
67156: PUSH
67157: LD_INT 1
67159: PUSH
67160: EMPTY
67161: LIST
67162: LIST
67163: PUSH
67164: LD_INT 25
67166: PUSH
67167: LD_INT 2
67169: PUSH
67170: EMPTY
67171: LIST
67172: LIST
67173: PUSH
67174: LD_INT 25
67176: PUSH
67177: LD_INT 3
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: LD_INT 25
67186: PUSH
67187: LD_INT 4
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 25
67196: PUSH
67197: LD_INT 5
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: LD_INT 25
67206: PUSH
67207: LD_INT 8
67209: PUSH
67210: EMPTY
67211: LIST
67212: LIST
67213: PUSH
67214: LD_INT 25
67216: PUSH
67217: LD_INT 9
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: EMPTY
67225: LIST
67226: LIST
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: LIST
67232: LIST
67233: PPUSH
67234: CALL_OW 72
67238: ST_TO_ADDR
// if not tmp then
67239: LD_VAR 0 4
67243: NOT
67244: IFFALSE 67248
// exit ;
67246: GO 70638
// for i in tmp do
67248: LD_ADDR_VAR 0 3
67252: PUSH
67253: LD_VAR 0 4
67257: PUSH
67258: FOR_IN
67259: IFFALSE 67290
// if GetTag ( i ) then
67261: LD_VAR 0 3
67265: PPUSH
67266: CALL_OW 110
67270: IFFALSE 67288
// tmp := tmp diff i ;
67272: LD_ADDR_VAR 0 4
67276: PUSH
67277: LD_VAR 0 4
67281: PUSH
67282: LD_VAR 0 3
67286: DIFF
67287: ST_TO_ADDR
67288: GO 67258
67290: POP
67291: POP
// if not tmp then
67292: LD_VAR 0 4
67296: NOT
67297: IFFALSE 67301
// exit ;
67299: GO 70638
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67301: LD_ADDR_VAR 0 5
67305: PUSH
67306: LD_EXP 86
67310: PUSH
67311: LD_VAR 0 1
67315: ARRAY
67316: PPUSH
67317: LD_INT 2
67319: PUSH
67320: LD_INT 25
67322: PUSH
67323: LD_INT 1
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: LD_INT 25
67332: PUSH
67333: LD_INT 5
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 25
67342: PUSH
67343: LD_INT 8
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 25
67352: PUSH
67353: LD_INT 9
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: LIST
67366: PPUSH
67367: CALL_OW 72
67371: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
67372: LD_ADDR_VAR 0 6
67376: PUSH
67377: LD_EXP 86
67381: PUSH
67382: LD_VAR 0 1
67386: ARRAY
67387: PPUSH
67388: LD_INT 25
67390: PUSH
67391: LD_INT 2
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PPUSH
67398: CALL_OW 72
67402: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
67403: LD_ADDR_VAR 0 7
67407: PUSH
67408: LD_EXP 86
67412: PUSH
67413: LD_VAR 0 1
67417: ARRAY
67418: PPUSH
67419: LD_INT 25
67421: PUSH
67422: LD_INT 3
67424: PUSH
67425: EMPTY
67426: LIST
67427: LIST
67428: PPUSH
67429: CALL_OW 72
67433: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
67434: LD_ADDR_VAR 0 8
67438: PUSH
67439: LD_EXP 86
67443: PUSH
67444: LD_VAR 0 1
67448: ARRAY
67449: PPUSH
67450: LD_INT 25
67452: PUSH
67453: LD_INT 4
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: LD_INT 24
67462: PUSH
67463: LD_INT 251
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PPUSH
67474: CALL_OW 72
67478: ST_TO_ADDR
// if mc_scan [ base ] then
67479: LD_EXP 109
67483: PUSH
67484: LD_VAR 0 1
67488: ARRAY
67489: IFFALSE 67950
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
67491: LD_ADDR_EXP 128
67495: PUSH
67496: LD_EXP 128
67500: PPUSH
67501: LD_VAR 0 1
67505: PPUSH
67506: LD_INT 4
67508: PPUSH
67509: CALL_OW 1
67513: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
67514: LD_ADDR_VAR 0 12
67518: PUSH
67519: LD_EXP 86
67523: PUSH
67524: LD_VAR 0 1
67528: ARRAY
67529: PPUSH
67530: LD_INT 2
67532: PUSH
67533: LD_INT 30
67535: PUSH
67536: LD_INT 4
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PUSH
67543: LD_INT 30
67545: PUSH
67546: LD_INT 5
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: LIST
67557: PPUSH
67558: CALL_OW 72
67562: ST_TO_ADDR
// if not b then
67563: LD_VAR 0 12
67567: NOT
67568: IFFALSE 67572
// exit ;
67570: GO 70638
// p := [ ] ;
67572: LD_ADDR_VAR 0 11
67576: PUSH
67577: EMPTY
67578: ST_TO_ADDR
// if sci >= 2 then
67579: LD_VAR 0 8
67583: PUSH
67584: LD_INT 2
67586: GREATEREQUAL
67587: IFFALSE 67618
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
67589: LD_ADDR_VAR 0 8
67593: PUSH
67594: LD_VAR 0 8
67598: PUSH
67599: LD_INT 1
67601: ARRAY
67602: PUSH
67603: LD_VAR 0 8
67607: PUSH
67608: LD_INT 2
67610: ARRAY
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: ST_TO_ADDR
67616: GO 67679
// if sci = 1 then
67618: LD_VAR 0 8
67622: PUSH
67623: LD_INT 1
67625: EQUAL
67626: IFFALSE 67647
// sci := [ sci [ 1 ] ] else
67628: LD_ADDR_VAR 0 8
67632: PUSH
67633: LD_VAR 0 8
67637: PUSH
67638: LD_INT 1
67640: ARRAY
67641: PUSH
67642: EMPTY
67643: LIST
67644: ST_TO_ADDR
67645: GO 67679
// if sci = 0 then
67647: LD_VAR 0 8
67651: PUSH
67652: LD_INT 0
67654: EQUAL
67655: IFFALSE 67679
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
67657: LD_ADDR_VAR 0 11
67661: PUSH
67662: LD_VAR 0 4
67666: PPUSH
67667: LD_INT 4
67669: PPUSH
67670: CALL 52333 0 2
67674: PUSH
67675: LD_INT 1
67677: ARRAY
67678: ST_TO_ADDR
// if eng > 4 then
67679: LD_VAR 0 6
67683: PUSH
67684: LD_INT 4
67686: GREATER
67687: IFFALSE 67733
// for i = eng downto 4 do
67689: LD_ADDR_VAR 0 3
67693: PUSH
67694: DOUBLE
67695: LD_VAR 0 6
67699: INC
67700: ST_TO_ADDR
67701: LD_INT 4
67703: PUSH
67704: FOR_DOWNTO
67705: IFFALSE 67731
// eng := eng diff eng [ i ] ;
67707: LD_ADDR_VAR 0 6
67711: PUSH
67712: LD_VAR 0 6
67716: PUSH
67717: LD_VAR 0 6
67721: PUSH
67722: LD_VAR 0 3
67726: ARRAY
67727: DIFF
67728: ST_TO_ADDR
67729: GO 67704
67731: POP
67732: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
67733: LD_ADDR_VAR 0 4
67737: PUSH
67738: LD_VAR 0 4
67742: PUSH
67743: LD_VAR 0 5
67747: PUSH
67748: LD_VAR 0 6
67752: UNION
67753: PUSH
67754: LD_VAR 0 7
67758: UNION
67759: PUSH
67760: LD_VAR 0 8
67764: UNION
67765: DIFF
67766: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
67767: LD_ADDR_VAR 0 13
67771: PUSH
67772: LD_EXP 86
67776: PUSH
67777: LD_VAR 0 1
67781: ARRAY
67782: PPUSH
67783: LD_INT 2
67785: PUSH
67786: LD_INT 30
67788: PUSH
67789: LD_INT 32
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 30
67798: PUSH
67799: LD_INT 31
67801: PUSH
67802: EMPTY
67803: LIST
67804: LIST
67805: PUSH
67806: EMPTY
67807: LIST
67808: LIST
67809: LIST
67810: PPUSH
67811: CALL_OW 72
67815: PUSH
67816: LD_EXP 86
67820: PUSH
67821: LD_VAR 0 1
67825: ARRAY
67826: PPUSH
67827: LD_INT 2
67829: PUSH
67830: LD_INT 30
67832: PUSH
67833: LD_INT 4
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: PUSH
67840: LD_INT 30
67842: PUSH
67843: LD_INT 5
67845: PUSH
67846: EMPTY
67847: LIST
67848: LIST
67849: PUSH
67850: EMPTY
67851: LIST
67852: LIST
67853: LIST
67854: PPUSH
67855: CALL_OW 72
67859: PUSH
67860: LD_INT 6
67862: MUL
67863: PLUS
67864: ST_TO_ADDR
// if bcount < tmp then
67865: LD_VAR 0 13
67869: PUSH
67870: LD_VAR 0 4
67874: LESS
67875: IFFALSE 67921
// for i = tmp downto bcount do
67877: LD_ADDR_VAR 0 3
67881: PUSH
67882: DOUBLE
67883: LD_VAR 0 4
67887: INC
67888: ST_TO_ADDR
67889: LD_VAR 0 13
67893: PUSH
67894: FOR_DOWNTO
67895: IFFALSE 67919
// tmp := Delete ( tmp , tmp ) ;
67897: LD_ADDR_VAR 0 4
67901: PUSH
67902: LD_VAR 0 4
67906: PPUSH
67907: LD_VAR 0 4
67911: PPUSH
67912: CALL_OW 3
67916: ST_TO_ADDR
67917: GO 67894
67919: POP
67920: POP
// result := [ tmp , 0 , 0 , p ] ;
67921: LD_ADDR_VAR 0 2
67925: PUSH
67926: LD_VAR 0 4
67930: PUSH
67931: LD_INT 0
67933: PUSH
67934: LD_INT 0
67936: PUSH
67937: LD_VAR 0 11
67941: PUSH
67942: EMPTY
67943: LIST
67944: LIST
67945: LIST
67946: LIST
67947: ST_TO_ADDR
// exit ;
67948: GO 70638
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67950: LD_EXP 86
67954: PUSH
67955: LD_VAR 0 1
67959: ARRAY
67960: PPUSH
67961: LD_INT 2
67963: PUSH
67964: LD_INT 30
67966: PUSH
67967: LD_INT 6
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 30
67976: PUSH
67977: LD_INT 7
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 30
67986: PUSH
67987: LD_INT 8
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: EMPTY
67995: LIST
67996: LIST
67997: LIST
67998: LIST
67999: PPUSH
68000: CALL_OW 72
68004: NOT
68005: PUSH
68006: LD_EXP 86
68010: PUSH
68011: LD_VAR 0 1
68015: ARRAY
68016: PPUSH
68017: LD_INT 30
68019: PUSH
68020: LD_INT 3
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: PPUSH
68027: CALL_OW 72
68031: NOT
68032: AND
68033: IFFALSE 68105
// begin if eng = tmp then
68035: LD_VAR 0 6
68039: PUSH
68040: LD_VAR 0 4
68044: EQUAL
68045: IFFALSE 68049
// exit ;
68047: GO 70638
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
68049: LD_ADDR_EXP 128
68053: PUSH
68054: LD_EXP 128
68058: PPUSH
68059: LD_VAR 0 1
68063: PPUSH
68064: LD_INT 1
68066: PPUSH
68067: CALL_OW 1
68071: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
68072: LD_ADDR_VAR 0 2
68076: PUSH
68077: LD_INT 0
68079: PUSH
68080: LD_VAR 0 4
68084: PUSH
68085: LD_VAR 0 6
68089: DIFF
68090: PUSH
68091: LD_INT 0
68093: PUSH
68094: LD_INT 0
68096: PUSH
68097: EMPTY
68098: LIST
68099: LIST
68100: LIST
68101: LIST
68102: ST_TO_ADDR
// exit ;
68103: GO 70638
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
68105: LD_EXP 113
68109: PUSH
68110: LD_EXP 112
68114: PUSH
68115: LD_VAR 0 1
68119: ARRAY
68120: ARRAY
68121: PUSH
68122: LD_EXP 86
68126: PUSH
68127: LD_VAR 0 1
68131: ARRAY
68132: PPUSH
68133: LD_INT 2
68135: PUSH
68136: LD_INT 30
68138: PUSH
68139: LD_INT 6
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 30
68148: PUSH
68149: LD_INT 7
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 30
68158: PUSH
68159: LD_INT 8
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: PUSH
68166: EMPTY
68167: LIST
68168: LIST
68169: LIST
68170: LIST
68171: PPUSH
68172: CALL_OW 72
68176: AND
68177: PUSH
68178: LD_EXP 86
68182: PUSH
68183: LD_VAR 0 1
68187: ARRAY
68188: PPUSH
68189: LD_INT 30
68191: PUSH
68192: LD_INT 3
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PPUSH
68199: CALL_OW 72
68203: NOT
68204: AND
68205: IFFALSE 68419
// begin if sci >= 6 then
68207: LD_VAR 0 8
68211: PUSH
68212: LD_INT 6
68214: GREATEREQUAL
68215: IFFALSE 68219
// exit ;
68217: GO 70638
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
68219: LD_ADDR_EXP 128
68223: PUSH
68224: LD_EXP 128
68228: PPUSH
68229: LD_VAR 0 1
68233: PPUSH
68234: LD_INT 2
68236: PPUSH
68237: CALL_OW 1
68241: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
68242: LD_ADDR_VAR 0 9
68246: PUSH
68247: LD_VAR 0 4
68251: PUSH
68252: LD_VAR 0 8
68256: DIFF
68257: PPUSH
68258: LD_INT 4
68260: PPUSH
68261: CALL 52333 0 2
68265: ST_TO_ADDR
// p := [ ] ;
68266: LD_ADDR_VAR 0 11
68270: PUSH
68271: EMPTY
68272: ST_TO_ADDR
// if sci < 6 and sort > 6 then
68273: LD_VAR 0 8
68277: PUSH
68278: LD_INT 6
68280: LESS
68281: PUSH
68282: LD_VAR 0 9
68286: PUSH
68287: LD_INT 6
68289: GREATER
68290: AND
68291: IFFALSE 68372
// begin for i = 1 to 6 - sci do
68293: LD_ADDR_VAR 0 3
68297: PUSH
68298: DOUBLE
68299: LD_INT 1
68301: DEC
68302: ST_TO_ADDR
68303: LD_INT 6
68305: PUSH
68306: LD_VAR 0 8
68310: MINUS
68311: PUSH
68312: FOR_TO
68313: IFFALSE 68368
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
68315: LD_ADDR_VAR 0 11
68319: PUSH
68320: LD_VAR 0 11
68324: PPUSH
68325: LD_VAR 0 11
68329: PUSH
68330: LD_INT 1
68332: PLUS
68333: PPUSH
68334: LD_VAR 0 9
68338: PUSH
68339: LD_INT 1
68341: ARRAY
68342: PPUSH
68343: CALL_OW 2
68347: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
68348: LD_ADDR_VAR 0 9
68352: PUSH
68353: LD_VAR 0 9
68357: PPUSH
68358: LD_INT 1
68360: PPUSH
68361: CALL_OW 3
68365: ST_TO_ADDR
// end ;
68366: GO 68312
68368: POP
68369: POP
// end else
68370: GO 68392
// if sort then
68372: LD_VAR 0 9
68376: IFFALSE 68392
// p := sort [ 1 ] ;
68378: LD_ADDR_VAR 0 11
68382: PUSH
68383: LD_VAR 0 9
68387: PUSH
68388: LD_INT 1
68390: ARRAY
68391: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
68392: LD_ADDR_VAR 0 2
68396: PUSH
68397: LD_INT 0
68399: PUSH
68400: LD_INT 0
68402: PUSH
68403: LD_INT 0
68405: PUSH
68406: LD_VAR 0 11
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: ST_TO_ADDR
// exit ;
68417: GO 70638
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
68419: LD_EXP 113
68423: PUSH
68424: LD_EXP 112
68428: PUSH
68429: LD_VAR 0 1
68433: ARRAY
68434: ARRAY
68435: PUSH
68436: LD_EXP 86
68440: PUSH
68441: LD_VAR 0 1
68445: ARRAY
68446: PPUSH
68447: LD_INT 2
68449: PUSH
68450: LD_INT 30
68452: PUSH
68453: LD_INT 6
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 30
68462: PUSH
68463: LD_INT 7
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 30
68472: PUSH
68473: LD_INT 8
68475: PUSH
68476: EMPTY
68477: LIST
68478: LIST
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: PPUSH
68486: CALL_OW 72
68490: AND
68491: PUSH
68492: LD_EXP 86
68496: PUSH
68497: LD_VAR 0 1
68501: ARRAY
68502: PPUSH
68503: LD_INT 30
68505: PUSH
68506: LD_INT 3
68508: PUSH
68509: EMPTY
68510: LIST
68511: LIST
68512: PPUSH
68513: CALL_OW 72
68517: AND
68518: IFFALSE 69252
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
68520: LD_ADDR_EXP 128
68524: PUSH
68525: LD_EXP 128
68529: PPUSH
68530: LD_VAR 0 1
68534: PPUSH
68535: LD_INT 3
68537: PPUSH
68538: CALL_OW 1
68542: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68543: LD_ADDR_VAR 0 2
68547: PUSH
68548: LD_INT 0
68550: PUSH
68551: LD_INT 0
68553: PUSH
68554: LD_INT 0
68556: PUSH
68557: LD_INT 0
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: LIST
68564: LIST
68565: ST_TO_ADDR
// if not eng then
68566: LD_VAR 0 6
68570: NOT
68571: IFFALSE 68634
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
68573: LD_ADDR_VAR 0 11
68577: PUSH
68578: LD_VAR 0 4
68582: PPUSH
68583: LD_INT 2
68585: PPUSH
68586: CALL 52333 0 2
68590: PUSH
68591: LD_INT 1
68593: ARRAY
68594: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
68595: LD_ADDR_VAR 0 2
68599: PUSH
68600: LD_VAR 0 2
68604: PPUSH
68605: LD_INT 2
68607: PPUSH
68608: LD_VAR 0 11
68612: PPUSH
68613: CALL_OW 1
68617: ST_TO_ADDR
// tmp := tmp diff p ;
68618: LD_ADDR_VAR 0 4
68622: PUSH
68623: LD_VAR 0 4
68627: PUSH
68628: LD_VAR 0 11
68632: DIFF
68633: ST_TO_ADDR
// end ; if tmp and sci < 6 then
68634: LD_VAR 0 4
68638: PUSH
68639: LD_VAR 0 8
68643: PUSH
68644: LD_INT 6
68646: LESS
68647: AND
68648: IFFALSE 68836
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
68650: LD_ADDR_VAR 0 9
68654: PUSH
68655: LD_VAR 0 4
68659: PUSH
68660: LD_VAR 0 8
68664: PUSH
68665: LD_VAR 0 7
68669: UNION
68670: DIFF
68671: PPUSH
68672: LD_INT 4
68674: PPUSH
68675: CALL 52333 0 2
68679: ST_TO_ADDR
// p := [ ] ;
68680: LD_ADDR_VAR 0 11
68684: PUSH
68685: EMPTY
68686: ST_TO_ADDR
// if sort then
68687: LD_VAR 0 9
68691: IFFALSE 68807
// for i = 1 to 6 - sci do
68693: LD_ADDR_VAR 0 3
68697: PUSH
68698: DOUBLE
68699: LD_INT 1
68701: DEC
68702: ST_TO_ADDR
68703: LD_INT 6
68705: PUSH
68706: LD_VAR 0 8
68710: MINUS
68711: PUSH
68712: FOR_TO
68713: IFFALSE 68805
// begin if i = sort then
68715: LD_VAR 0 3
68719: PUSH
68720: LD_VAR 0 9
68724: EQUAL
68725: IFFALSE 68729
// break ;
68727: GO 68805
// if GetClass ( i ) = 4 then
68729: LD_VAR 0 3
68733: PPUSH
68734: CALL_OW 257
68738: PUSH
68739: LD_INT 4
68741: EQUAL
68742: IFFALSE 68746
// continue ;
68744: GO 68712
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68746: LD_ADDR_VAR 0 11
68750: PUSH
68751: LD_VAR 0 11
68755: PPUSH
68756: LD_VAR 0 11
68760: PUSH
68761: LD_INT 1
68763: PLUS
68764: PPUSH
68765: LD_VAR 0 9
68769: PUSH
68770: LD_VAR 0 3
68774: ARRAY
68775: PPUSH
68776: CALL_OW 2
68780: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68781: LD_ADDR_VAR 0 4
68785: PUSH
68786: LD_VAR 0 4
68790: PUSH
68791: LD_VAR 0 9
68795: PUSH
68796: LD_VAR 0 3
68800: ARRAY
68801: DIFF
68802: ST_TO_ADDR
// end ;
68803: GO 68712
68805: POP
68806: POP
// if p then
68807: LD_VAR 0 11
68811: IFFALSE 68836
// result := Replace ( result , 4 , p ) ;
68813: LD_ADDR_VAR 0 2
68817: PUSH
68818: LD_VAR 0 2
68822: PPUSH
68823: LD_INT 4
68825: PPUSH
68826: LD_VAR 0 11
68830: PPUSH
68831: CALL_OW 1
68835: ST_TO_ADDR
// end ; if tmp and mech < 6 then
68836: LD_VAR 0 4
68840: PUSH
68841: LD_VAR 0 7
68845: PUSH
68846: LD_INT 6
68848: LESS
68849: AND
68850: IFFALSE 69038
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68852: LD_ADDR_VAR 0 9
68856: PUSH
68857: LD_VAR 0 4
68861: PUSH
68862: LD_VAR 0 8
68866: PUSH
68867: LD_VAR 0 7
68871: UNION
68872: DIFF
68873: PPUSH
68874: LD_INT 3
68876: PPUSH
68877: CALL 52333 0 2
68881: ST_TO_ADDR
// p := [ ] ;
68882: LD_ADDR_VAR 0 11
68886: PUSH
68887: EMPTY
68888: ST_TO_ADDR
// if sort then
68889: LD_VAR 0 9
68893: IFFALSE 69009
// for i = 1 to 6 - mech do
68895: LD_ADDR_VAR 0 3
68899: PUSH
68900: DOUBLE
68901: LD_INT 1
68903: DEC
68904: ST_TO_ADDR
68905: LD_INT 6
68907: PUSH
68908: LD_VAR 0 7
68912: MINUS
68913: PUSH
68914: FOR_TO
68915: IFFALSE 69007
// begin if i = sort then
68917: LD_VAR 0 3
68921: PUSH
68922: LD_VAR 0 9
68926: EQUAL
68927: IFFALSE 68931
// break ;
68929: GO 69007
// if GetClass ( i ) = 3 then
68931: LD_VAR 0 3
68935: PPUSH
68936: CALL_OW 257
68940: PUSH
68941: LD_INT 3
68943: EQUAL
68944: IFFALSE 68948
// continue ;
68946: GO 68914
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68948: LD_ADDR_VAR 0 11
68952: PUSH
68953: LD_VAR 0 11
68957: PPUSH
68958: LD_VAR 0 11
68962: PUSH
68963: LD_INT 1
68965: PLUS
68966: PPUSH
68967: LD_VAR 0 9
68971: PUSH
68972: LD_VAR 0 3
68976: ARRAY
68977: PPUSH
68978: CALL_OW 2
68982: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68983: LD_ADDR_VAR 0 4
68987: PUSH
68988: LD_VAR 0 4
68992: PUSH
68993: LD_VAR 0 9
68997: PUSH
68998: LD_VAR 0 3
69002: ARRAY
69003: DIFF
69004: ST_TO_ADDR
// end ;
69005: GO 68914
69007: POP
69008: POP
// if p then
69009: LD_VAR 0 11
69013: IFFALSE 69038
// result := Replace ( result , 3 , p ) ;
69015: LD_ADDR_VAR 0 2
69019: PUSH
69020: LD_VAR 0 2
69024: PPUSH
69025: LD_INT 3
69027: PPUSH
69028: LD_VAR 0 11
69032: PPUSH
69033: CALL_OW 1
69037: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
69038: LD_VAR 0 4
69042: PUSH
69043: LD_INT 6
69045: GREATER
69046: PUSH
69047: LD_VAR 0 6
69051: PUSH
69052: LD_INT 6
69054: LESS
69055: AND
69056: IFFALSE 69250
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
69058: LD_ADDR_VAR 0 9
69062: PUSH
69063: LD_VAR 0 4
69067: PUSH
69068: LD_VAR 0 8
69072: PUSH
69073: LD_VAR 0 7
69077: UNION
69078: PUSH
69079: LD_VAR 0 6
69083: UNION
69084: DIFF
69085: PPUSH
69086: LD_INT 2
69088: PPUSH
69089: CALL 52333 0 2
69093: ST_TO_ADDR
// p := [ ] ;
69094: LD_ADDR_VAR 0 11
69098: PUSH
69099: EMPTY
69100: ST_TO_ADDR
// if sort then
69101: LD_VAR 0 9
69105: IFFALSE 69221
// for i = 1 to 6 - eng do
69107: LD_ADDR_VAR 0 3
69111: PUSH
69112: DOUBLE
69113: LD_INT 1
69115: DEC
69116: ST_TO_ADDR
69117: LD_INT 6
69119: PUSH
69120: LD_VAR 0 6
69124: MINUS
69125: PUSH
69126: FOR_TO
69127: IFFALSE 69219
// begin if i = sort then
69129: LD_VAR 0 3
69133: PUSH
69134: LD_VAR 0 9
69138: EQUAL
69139: IFFALSE 69143
// break ;
69141: GO 69219
// if GetClass ( i ) = 2 then
69143: LD_VAR 0 3
69147: PPUSH
69148: CALL_OW 257
69152: PUSH
69153: LD_INT 2
69155: EQUAL
69156: IFFALSE 69160
// continue ;
69158: GO 69126
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69160: LD_ADDR_VAR 0 11
69164: PUSH
69165: LD_VAR 0 11
69169: PPUSH
69170: LD_VAR 0 11
69174: PUSH
69175: LD_INT 1
69177: PLUS
69178: PPUSH
69179: LD_VAR 0 9
69183: PUSH
69184: LD_VAR 0 3
69188: ARRAY
69189: PPUSH
69190: CALL_OW 2
69194: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69195: LD_ADDR_VAR 0 4
69199: PUSH
69200: LD_VAR 0 4
69204: PUSH
69205: LD_VAR 0 9
69209: PUSH
69210: LD_VAR 0 3
69214: ARRAY
69215: DIFF
69216: ST_TO_ADDR
// end ;
69217: GO 69126
69219: POP
69220: POP
// if p then
69221: LD_VAR 0 11
69225: IFFALSE 69250
// result := Replace ( result , 2 , p ) ;
69227: LD_ADDR_VAR 0 2
69231: PUSH
69232: LD_VAR 0 2
69236: PPUSH
69237: LD_INT 2
69239: PPUSH
69240: LD_VAR 0 11
69244: PPUSH
69245: CALL_OW 1
69249: ST_TO_ADDR
// end ; exit ;
69250: GO 70638
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
69252: LD_EXP 113
69256: PUSH
69257: LD_EXP 112
69261: PUSH
69262: LD_VAR 0 1
69266: ARRAY
69267: ARRAY
69268: NOT
69269: PUSH
69270: LD_EXP 86
69274: PUSH
69275: LD_VAR 0 1
69279: ARRAY
69280: PPUSH
69281: LD_INT 30
69283: PUSH
69284: LD_INT 3
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PPUSH
69291: CALL_OW 72
69295: AND
69296: PUSH
69297: LD_EXP 91
69301: PUSH
69302: LD_VAR 0 1
69306: ARRAY
69307: AND
69308: IFFALSE 69916
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
69310: LD_ADDR_EXP 128
69314: PUSH
69315: LD_EXP 128
69319: PPUSH
69320: LD_VAR 0 1
69324: PPUSH
69325: LD_INT 5
69327: PPUSH
69328: CALL_OW 1
69332: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
69333: LD_ADDR_VAR 0 2
69337: PUSH
69338: LD_INT 0
69340: PUSH
69341: LD_INT 0
69343: PUSH
69344: LD_INT 0
69346: PUSH
69347: LD_INT 0
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: ST_TO_ADDR
// if sci > 1 then
69356: LD_VAR 0 8
69360: PUSH
69361: LD_INT 1
69363: GREATER
69364: IFFALSE 69392
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
69366: LD_ADDR_VAR 0 4
69370: PUSH
69371: LD_VAR 0 4
69375: PUSH
69376: LD_VAR 0 8
69380: PUSH
69381: LD_VAR 0 8
69385: PUSH
69386: LD_INT 1
69388: ARRAY
69389: DIFF
69390: DIFF
69391: ST_TO_ADDR
// if tmp and not sci then
69392: LD_VAR 0 4
69396: PUSH
69397: LD_VAR 0 8
69401: NOT
69402: AND
69403: IFFALSE 69472
// begin sort := SortBySkill ( tmp , 4 ) ;
69405: LD_ADDR_VAR 0 9
69409: PUSH
69410: LD_VAR 0 4
69414: PPUSH
69415: LD_INT 4
69417: PPUSH
69418: CALL 52333 0 2
69422: ST_TO_ADDR
// if sort then
69423: LD_VAR 0 9
69427: IFFALSE 69443
// p := sort [ 1 ] ;
69429: LD_ADDR_VAR 0 11
69433: PUSH
69434: LD_VAR 0 9
69438: PUSH
69439: LD_INT 1
69441: ARRAY
69442: ST_TO_ADDR
// if p then
69443: LD_VAR 0 11
69447: IFFALSE 69472
// result := Replace ( result , 4 , p ) ;
69449: LD_ADDR_VAR 0 2
69453: PUSH
69454: LD_VAR 0 2
69458: PPUSH
69459: LD_INT 4
69461: PPUSH
69462: LD_VAR 0 11
69466: PPUSH
69467: CALL_OW 1
69471: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
69472: LD_ADDR_VAR 0 4
69476: PUSH
69477: LD_VAR 0 4
69481: PUSH
69482: LD_VAR 0 7
69486: DIFF
69487: ST_TO_ADDR
// if tmp and mech < 6 then
69488: LD_VAR 0 4
69492: PUSH
69493: LD_VAR 0 7
69497: PUSH
69498: LD_INT 6
69500: LESS
69501: AND
69502: IFFALSE 69690
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
69504: LD_ADDR_VAR 0 9
69508: PUSH
69509: LD_VAR 0 4
69513: PUSH
69514: LD_VAR 0 8
69518: PUSH
69519: LD_VAR 0 7
69523: UNION
69524: DIFF
69525: PPUSH
69526: LD_INT 3
69528: PPUSH
69529: CALL 52333 0 2
69533: ST_TO_ADDR
// p := [ ] ;
69534: LD_ADDR_VAR 0 11
69538: PUSH
69539: EMPTY
69540: ST_TO_ADDR
// if sort then
69541: LD_VAR 0 9
69545: IFFALSE 69661
// for i = 1 to 6 - mech do
69547: LD_ADDR_VAR 0 3
69551: PUSH
69552: DOUBLE
69553: LD_INT 1
69555: DEC
69556: ST_TO_ADDR
69557: LD_INT 6
69559: PUSH
69560: LD_VAR 0 7
69564: MINUS
69565: PUSH
69566: FOR_TO
69567: IFFALSE 69659
// begin if i = sort then
69569: LD_VAR 0 3
69573: PUSH
69574: LD_VAR 0 9
69578: EQUAL
69579: IFFALSE 69583
// break ;
69581: GO 69659
// if GetClass ( i ) = 3 then
69583: LD_VAR 0 3
69587: PPUSH
69588: CALL_OW 257
69592: PUSH
69593: LD_INT 3
69595: EQUAL
69596: IFFALSE 69600
// continue ;
69598: GO 69566
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69600: LD_ADDR_VAR 0 11
69604: PUSH
69605: LD_VAR 0 11
69609: PPUSH
69610: LD_VAR 0 11
69614: PUSH
69615: LD_INT 1
69617: PLUS
69618: PPUSH
69619: LD_VAR 0 9
69623: PUSH
69624: LD_VAR 0 3
69628: ARRAY
69629: PPUSH
69630: CALL_OW 2
69634: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69635: LD_ADDR_VAR 0 4
69639: PUSH
69640: LD_VAR 0 4
69644: PUSH
69645: LD_VAR 0 9
69649: PUSH
69650: LD_VAR 0 3
69654: ARRAY
69655: DIFF
69656: ST_TO_ADDR
// end ;
69657: GO 69566
69659: POP
69660: POP
// if p then
69661: LD_VAR 0 11
69665: IFFALSE 69690
// result := Replace ( result , 3 , p ) ;
69667: LD_ADDR_VAR 0 2
69671: PUSH
69672: LD_VAR 0 2
69676: PPUSH
69677: LD_INT 3
69679: PPUSH
69680: LD_VAR 0 11
69684: PPUSH
69685: CALL_OW 1
69689: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69690: LD_ADDR_VAR 0 4
69694: PUSH
69695: LD_VAR 0 4
69699: PUSH
69700: LD_VAR 0 6
69704: DIFF
69705: ST_TO_ADDR
// if tmp and eng < 6 then
69706: LD_VAR 0 4
69710: PUSH
69711: LD_VAR 0 6
69715: PUSH
69716: LD_INT 6
69718: LESS
69719: AND
69720: IFFALSE 69914
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
69722: LD_ADDR_VAR 0 9
69726: PUSH
69727: LD_VAR 0 4
69731: PUSH
69732: LD_VAR 0 8
69736: PUSH
69737: LD_VAR 0 7
69741: UNION
69742: PUSH
69743: LD_VAR 0 6
69747: UNION
69748: DIFF
69749: PPUSH
69750: LD_INT 2
69752: PPUSH
69753: CALL 52333 0 2
69757: ST_TO_ADDR
// p := [ ] ;
69758: LD_ADDR_VAR 0 11
69762: PUSH
69763: EMPTY
69764: ST_TO_ADDR
// if sort then
69765: LD_VAR 0 9
69769: IFFALSE 69885
// for i = 1 to 6 - eng do
69771: LD_ADDR_VAR 0 3
69775: PUSH
69776: DOUBLE
69777: LD_INT 1
69779: DEC
69780: ST_TO_ADDR
69781: LD_INT 6
69783: PUSH
69784: LD_VAR 0 6
69788: MINUS
69789: PUSH
69790: FOR_TO
69791: IFFALSE 69883
// begin if i = sort then
69793: LD_VAR 0 3
69797: PUSH
69798: LD_VAR 0 9
69802: EQUAL
69803: IFFALSE 69807
// break ;
69805: GO 69883
// if GetClass ( i ) = 2 then
69807: LD_VAR 0 3
69811: PPUSH
69812: CALL_OW 257
69816: PUSH
69817: LD_INT 2
69819: EQUAL
69820: IFFALSE 69824
// continue ;
69822: GO 69790
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69824: LD_ADDR_VAR 0 11
69828: PUSH
69829: LD_VAR 0 11
69833: PPUSH
69834: LD_VAR 0 11
69838: PUSH
69839: LD_INT 1
69841: PLUS
69842: PPUSH
69843: LD_VAR 0 9
69847: PUSH
69848: LD_VAR 0 3
69852: ARRAY
69853: PPUSH
69854: CALL_OW 2
69858: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69859: LD_ADDR_VAR 0 4
69863: PUSH
69864: LD_VAR 0 4
69868: PUSH
69869: LD_VAR 0 9
69873: PUSH
69874: LD_VAR 0 3
69878: ARRAY
69879: DIFF
69880: ST_TO_ADDR
// end ;
69881: GO 69790
69883: POP
69884: POP
// if p then
69885: LD_VAR 0 11
69889: IFFALSE 69914
// result := Replace ( result , 2 , p ) ;
69891: LD_ADDR_VAR 0 2
69895: PUSH
69896: LD_VAR 0 2
69900: PPUSH
69901: LD_INT 2
69903: PPUSH
69904: LD_VAR 0 11
69908: PPUSH
69909: CALL_OW 1
69913: ST_TO_ADDR
// end ; exit ;
69914: GO 70638
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
69916: LD_EXP 113
69920: PUSH
69921: LD_EXP 112
69925: PUSH
69926: LD_VAR 0 1
69930: ARRAY
69931: ARRAY
69932: NOT
69933: PUSH
69934: LD_EXP 86
69938: PUSH
69939: LD_VAR 0 1
69943: ARRAY
69944: PPUSH
69945: LD_INT 30
69947: PUSH
69948: LD_INT 3
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PPUSH
69955: CALL_OW 72
69959: AND
69960: PUSH
69961: LD_EXP 91
69965: PUSH
69966: LD_VAR 0 1
69970: ARRAY
69971: NOT
69972: AND
69973: IFFALSE 70638
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
69975: LD_ADDR_EXP 128
69979: PUSH
69980: LD_EXP 128
69984: PPUSH
69985: LD_VAR 0 1
69989: PPUSH
69990: LD_INT 6
69992: PPUSH
69993: CALL_OW 1
69997: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
69998: LD_ADDR_VAR 0 2
70002: PUSH
70003: LD_INT 0
70005: PUSH
70006: LD_INT 0
70008: PUSH
70009: LD_INT 0
70011: PUSH
70012: LD_INT 0
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: ST_TO_ADDR
// if sci >= 1 then
70021: LD_VAR 0 8
70025: PUSH
70026: LD_INT 1
70028: GREATEREQUAL
70029: IFFALSE 70051
// tmp := tmp diff sci [ 1 ] ;
70031: LD_ADDR_VAR 0 4
70035: PUSH
70036: LD_VAR 0 4
70040: PUSH
70041: LD_VAR 0 8
70045: PUSH
70046: LD_INT 1
70048: ARRAY
70049: DIFF
70050: ST_TO_ADDR
// if tmp and not sci then
70051: LD_VAR 0 4
70055: PUSH
70056: LD_VAR 0 8
70060: NOT
70061: AND
70062: IFFALSE 70131
// begin sort := SortBySkill ( tmp , 4 ) ;
70064: LD_ADDR_VAR 0 9
70068: PUSH
70069: LD_VAR 0 4
70073: PPUSH
70074: LD_INT 4
70076: PPUSH
70077: CALL 52333 0 2
70081: ST_TO_ADDR
// if sort then
70082: LD_VAR 0 9
70086: IFFALSE 70102
// p := sort [ 1 ] ;
70088: LD_ADDR_VAR 0 11
70092: PUSH
70093: LD_VAR 0 9
70097: PUSH
70098: LD_INT 1
70100: ARRAY
70101: ST_TO_ADDR
// if p then
70102: LD_VAR 0 11
70106: IFFALSE 70131
// result := Replace ( result , 4 , p ) ;
70108: LD_ADDR_VAR 0 2
70112: PUSH
70113: LD_VAR 0 2
70117: PPUSH
70118: LD_INT 4
70120: PPUSH
70121: LD_VAR 0 11
70125: PPUSH
70126: CALL_OW 1
70130: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
70131: LD_ADDR_VAR 0 4
70135: PUSH
70136: LD_VAR 0 4
70140: PUSH
70141: LD_VAR 0 7
70145: DIFF
70146: ST_TO_ADDR
// if tmp and mech < 6 then
70147: LD_VAR 0 4
70151: PUSH
70152: LD_VAR 0 7
70156: PUSH
70157: LD_INT 6
70159: LESS
70160: AND
70161: IFFALSE 70343
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
70163: LD_ADDR_VAR 0 9
70167: PUSH
70168: LD_VAR 0 4
70172: PUSH
70173: LD_VAR 0 7
70177: DIFF
70178: PPUSH
70179: LD_INT 3
70181: PPUSH
70182: CALL 52333 0 2
70186: ST_TO_ADDR
// p := [ ] ;
70187: LD_ADDR_VAR 0 11
70191: PUSH
70192: EMPTY
70193: ST_TO_ADDR
// if sort then
70194: LD_VAR 0 9
70198: IFFALSE 70314
// for i = 1 to 6 - mech do
70200: LD_ADDR_VAR 0 3
70204: PUSH
70205: DOUBLE
70206: LD_INT 1
70208: DEC
70209: ST_TO_ADDR
70210: LD_INT 6
70212: PUSH
70213: LD_VAR 0 7
70217: MINUS
70218: PUSH
70219: FOR_TO
70220: IFFALSE 70312
// begin if i = sort then
70222: LD_VAR 0 3
70226: PUSH
70227: LD_VAR 0 9
70231: EQUAL
70232: IFFALSE 70236
// break ;
70234: GO 70312
// if GetClass ( i ) = 3 then
70236: LD_VAR 0 3
70240: PPUSH
70241: CALL_OW 257
70245: PUSH
70246: LD_INT 3
70248: EQUAL
70249: IFFALSE 70253
// continue ;
70251: GO 70219
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70253: LD_ADDR_VAR 0 11
70257: PUSH
70258: LD_VAR 0 11
70262: PPUSH
70263: LD_VAR 0 11
70267: PUSH
70268: LD_INT 1
70270: PLUS
70271: PPUSH
70272: LD_VAR 0 9
70276: PUSH
70277: LD_VAR 0 3
70281: ARRAY
70282: PPUSH
70283: CALL_OW 2
70287: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70288: LD_ADDR_VAR 0 4
70292: PUSH
70293: LD_VAR 0 4
70297: PUSH
70298: LD_VAR 0 9
70302: PUSH
70303: LD_VAR 0 3
70307: ARRAY
70308: DIFF
70309: ST_TO_ADDR
// end ;
70310: GO 70219
70312: POP
70313: POP
// if p then
70314: LD_VAR 0 11
70318: IFFALSE 70343
// result := Replace ( result , 3 , p ) ;
70320: LD_ADDR_VAR 0 2
70324: PUSH
70325: LD_VAR 0 2
70329: PPUSH
70330: LD_INT 3
70332: PPUSH
70333: LD_VAR 0 11
70337: PPUSH
70338: CALL_OW 1
70342: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
70343: LD_ADDR_VAR 0 4
70347: PUSH
70348: LD_VAR 0 4
70352: PUSH
70353: LD_VAR 0 6
70357: DIFF
70358: ST_TO_ADDR
// if tmp and eng < 4 then
70359: LD_VAR 0 4
70363: PUSH
70364: LD_VAR 0 6
70368: PUSH
70369: LD_INT 4
70371: LESS
70372: AND
70373: IFFALSE 70563
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
70375: LD_ADDR_VAR 0 9
70379: PUSH
70380: LD_VAR 0 4
70384: PUSH
70385: LD_VAR 0 7
70389: PUSH
70390: LD_VAR 0 6
70394: UNION
70395: DIFF
70396: PPUSH
70397: LD_INT 2
70399: PPUSH
70400: CALL 52333 0 2
70404: ST_TO_ADDR
// p := [ ] ;
70405: LD_ADDR_VAR 0 11
70409: PUSH
70410: EMPTY
70411: ST_TO_ADDR
// if sort then
70412: LD_VAR 0 9
70416: IFFALSE 70532
// for i = 1 to 4 - eng do
70418: LD_ADDR_VAR 0 3
70422: PUSH
70423: DOUBLE
70424: LD_INT 1
70426: DEC
70427: ST_TO_ADDR
70428: LD_INT 4
70430: PUSH
70431: LD_VAR 0 6
70435: MINUS
70436: PUSH
70437: FOR_TO
70438: IFFALSE 70530
// begin if i = sort then
70440: LD_VAR 0 3
70444: PUSH
70445: LD_VAR 0 9
70449: EQUAL
70450: IFFALSE 70454
// break ;
70452: GO 70530
// if GetClass ( i ) = 2 then
70454: LD_VAR 0 3
70458: PPUSH
70459: CALL_OW 257
70463: PUSH
70464: LD_INT 2
70466: EQUAL
70467: IFFALSE 70471
// continue ;
70469: GO 70437
// p := Insert ( p , p + 1 , sort [ i ] ) ;
70471: LD_ADDR_VAR 0 11
70475: PUSH
70476: LD_VAR 0 11
70480: PPUSH
70481: LD_VAR 0 11
70485: PUSH
70486: LD_INT 1
70488: PLUS
70489: PPUSH
70490: LD_VAR 0 9
70494: PUSH
70495: LD_VAR 0 3
70499: ARRAY
70500: PPUSH
70501: CALL_OW 2
70505: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
70506: LD_ADDR_VAR 0 4
70510: PUSH
70511: LD_VAR 0 4
70515: PUSH
70516: LD_VAR 0 9
70520: PUSH
70521: LD_VAR 0 3
70525: ARRAY
70526: DIFF
70527: ST_TO_ADDR
// end ;
70528: GO 70437
70530: POP
70531: POP
// if p then
70532: LD_VAR 0 11
70536: IFFALSE 70561
// result := Replace ( result , 2 , p ) ;
70538: LD_ADDR_VAR 0 2
70542: PUSH
70543: LD_VAR 0 2
70547: PPUSH
70548: LD_INT 2
70550: PPUSH
70551: LD_VAR 0 11
70555: PPUSH
70556: CALL_OW 1
70560: ST_TO_ADDR
// end else
70561: GO 70607
// for i = eng downto 5 do
70563: LD_ADDR_VAR 0 3
70567: PUSH
70568: DOUBLE
70569: LD_VAR 0 6
70573: INC
70574: ST_TO_ADDR
70575: LD_INT 5
70577: PUSH
70578: FOR_DOWNTO
70579: IFFALSE 70605
// tmp := tmp union eng [ i ] ;
70581: LD_ADDR_VAR 0 4
70585: PUSH
70586: LD_VAR 0 4
70590: PUSH
70591: LD_VAR 0 6
70595: PUSH
70596: LD_VAR 0 3
70600: ARRAY
70601: UNION
70602: ST_TO_ADDR
70603: GO 70578
70605: POP
70606: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
70607: LD_ADDR_VAR 0 2
70611: PUSH
70612: LD_VAR 0 2
70616: PPUSH
70617: LD_INT 1
70619: PPUSH
70620: LD_VAR 0 4
70624: PUSH
70625: LD_VAR 0 5
70629: DIFF
70630: PPUSH
70631: CALL_OW 1
70635: ST_TO_ADDR
// exit ;
70636: GO 70638
// end ; end ;
70638: LD_VAR 0 2
70642: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
70643: LD_INT 0
70645: PPUSH
70646: PPUSH
70647: PPUSH
// if not mc_bases then
70648: LD_EXP 86
70652: NOT
70653: IFFALSE 70657
// exit ;
70655: GO 70763
// for i = 1 to mc_bases do
70657: LD_ADDR_VAR 0 2
70661: PUSH
70662: DOUBLE
70663: LD_INT 1
70665: DEC
70666: ST_TO_ADDR
70667: LD_EXP 86
70671: PUSH
70672: FOR_TO
70673: IFFALSE 70754
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70675: LD_ADDR_VAR 0 3
70679: PUSH
70680: LD_EXP 86
70684: PUSH
70685: LD_VAR 0 2
70689: ARRAY
70690: PPUSH
70691: LD_INT 21
70693: PUSH
70694: LD_INT 3
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 3
70703: PUSH
70704: LD_INT 24
70706: PUSH
70707: LD_INT 1000
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: EMPTY
70715: LIST
70716: LIST
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PPUSH
70722: CALL_OW 72
70726: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
70727: LD_ADDR_EXP 87
70731: PUSH
70732: LD_EXP 87
70736: PPUSH
70737: LD_VAR 0 2
70741: PPUSH
70742: LD_VAR 0 3
70746: PPUSH
70747: CALL_OW 1
70751: ST_TO_ADDR
// end ;
70752: GO 70672
70754: POP
70755: POP
// RaiseSailEvent ( 101 ) ;
70756: LD_INT 101
70758: PPUSH
70759: CALL_OW 427
// end ;
70763: LD_VAR 0 1
70767: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
70768: LD_INT 0
70770: PPUSH
70771: PPUSH
70772: PPUSH
70773: PPUSH
70774: PPUSH
70775: PPUSH
70776: PPUSH
// if not mc_bases then
70777: LD_EXP 86
70781: NOT
70782: IFFALSE 70786
// exit ;
70784: GO 71348
// for i = 1 to mc_bases do
70786: LD_ADDR_VAR 0 2
70790: PUSH
70791: DOUBLE
70792: LD_INT 1
70794: DEC
70795: ST_TO_ADDR
70796: LD_EXP 86
70800: PUSH
70801: FOR_TO
70802: IFFALSE 71339
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
70804: LD_ADDR_VAR 0 5
70808: PUSH
70809: LD_EXP 86
70813: PUSH
70814: LD_VAR 0 2
70818: ARRAY
70819: PUSH
70820: LD_EXP 115
70824: PUSH
70825: LD_VAR 0 2
70829: ARRAY
70830: UNION
70831: PPUSH
70832: LD_INT 21
70834: PUSH
70835: LD_INT 1
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: PUSH
70842: LD_INT 1
70844: PUSH
70845: LD_INT 3
70847: PUSH
70848: LD_INT 54
70850: PUSH
70851: EMPTY
70852: LIST
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 3
70860: PUSH
70861: LD_INT 24
70863: PUSH
70864: LD_INT 1000
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: EMPTY
70876: LIST
70877: LIST
70878: LIST
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PPUSH
70884: CALL_OW 72
70888: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
70889: LD_ADDR_VAR 0 6
70893: PUSH
70894: LD_EXP 86
70898: PUSH
70899: LD_VAR 0 2
70903: ARRAY
70904: PPUSH
70905: LD_INT 21
70907: PUSH
70908: LD_INT 1
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 1
70917: PUSH
70918: LD_INT 3
70920: PUSH
70921: LD_INT 54
70923: PUSH
70924: EMPTY
70925: LIST
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 3
70933: PUSH
70934: LD_INT 24
70936: PUSH
70937: LD_INT 250
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: EMPTY
70949: LIST
70950: LIST
70951: LIST
70952: PUSH
70953: EMPTY
70954: LIST
70955: LIST
70956: PPUSH
70957: CALL_OW 72
70961: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
70962: LD_ADDR_VAR 0 7
70966: PUSH
70967: LD_VAR 0 5
70971: PUSH
70972: LD_VAR 0 6
70976: DIFF
70977: ST_TO_ADDR
// if not need_heal_1 then
70978: LD_VAR 0 6
70982: NOT
70983: IFFALSE 71016
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
70985: LD_ADDR_EXP 89
70989: PUSH
70990: LD_EXP 89
70994: PPUSH
70995: LD_VAR 0 2
70999: PUSH
71000: LD_INT 1
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PPUSH
71007: EMPTY
71008: PPUSH
71009: CALL 22451 0 3
71013: ST_TO_ADDR
71014: GO 71086
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
71016: LD_ADDR_EXP 89
71020: PUSH
71021: LD_EXP 89
71025: PPUSH
71026: LD_VAR 0 2
71030: PUSH
71031: LD_INT 1
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PPUSH
71038: LD_EXP 89
71042: PUSH
71043: LD_VAR 0 2
71047: ARRAY
71048: PUSH
71049: LD_INT 1
71051: ARRAY
71052: PPUSH
71053: LD_INT 3
71055: PUSH
71056: LD_INT 24
71058: PUSH
71059: LD_INT 1000
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PPUSH
71070: CALL_OW 72
71074: PUSH
71075: LD_VAR 0 6
71079: UNION
71080: PPUSH
71081: CALL 22451 0 3
71085: ST_TO_ADDR
// if not need_heal_2 then
71086: LD_VAR 0 7
71090: NOT
71091: IFFALSE 71124
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
71093: LD_ADDR_EXP 89
71097: PUSH
71098: LD_EXP 89
71102: PPUSH
71103: LD_VAR 0 2
71107: PUSH
71108: LD_INT 2
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PPUSH
71115: EMPTY
71116: PPUSH
71117: CALL 22451 0 3
71121: ST_TO_ADDR
71122: GO 71156
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
71124: LD_ADDR_EXP 89
71128: PUSH
71129: LD_EXP 89
71133: PPUSH
71134: LD_VAR 0 2
71138: PUSH
71139: LD_INT 2
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PPUSH
71146: LD_VAR 0 7
71150: PPUSH
71151: CALL 22451 0 3
71155: ST_TO_ADDR
// if need_heal_2 then
71156: LD_VAR 0 7
71160: IFFALSE 71321
// for j in need_heal_2 do
71162: LD_ADDR_VAR 0 3
71166: PUSH
71167: LD_VAR 0 7
71171: PUSH
71172: FOR_IN
71173: IFFALSE 71319
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71175: LD_ADDR_VAR 0 5
71179: PUSH
71180: LD_EXP 86
71184: PUSH
71185: LD_VAR 0 2
71189: ARRAY
71190: PPUSH
71191: LD_INT 2
71193: PUSH
71194: LD_INT 30
71196: PUSH
71197: LD_INT 6
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 30
71206: PUSH
71207: LD_INT 7
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 30
71216: PUSH
71217: LD_INT 8
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 30
71226: PUSH
71227: LD_INT 0
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 30
71236: PUSH
71237: LD_INT 1
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: LIST
71248: LIST
71249: LIST
71250: LIST
71251: PPUSH
71252: CALL_OW 72
71256: ST_TO_ADDR
// if tmp then
71257: LD_VAR 0 5
71261: IFFALSE 71317
// begin k := NearestUnitToUnit ( tmp , j ) ;
71263: LD_ADDR_VAR 0 4
71267: PUSH
71268: LD_VAR 0 5
71272: PPUSH
71273: LD_VAR 0 3
71277: PPUSH
71278: CALL_OW 74
71282: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
71283: LD_VAR 0 3
71287: PPUSH
71288: LD_VAR 0 4
71292: PPUSH
71293: CALL_OW 296
71297: PUSH
71298: LD_INT 5
71300: GREATER
71301: IFFALSE 71317
// ComMoveToNearbyEntrance ( j , k ) ;
71303: LD_VAR 0 3
71307: PPUSH
71308: LD_VAR 0 4
71312: PPUSH
71313: CALL 54694 0 2
// end ; end ;
71317: GO 71172
71319: POP
71320: POP
// if not need_heal_1 and not need_heal_2 then
71321: LD_VAR 0 6
71325: NOT
71326: PUSH
71327: LD_VAR 0 7
71331: NOT
71332: AND
71333: IFFALSE 71337
// continue ;
71335: GO 70801
// end ;
71337: GO 70801
71339: POP
71340: POP
// RaiseSailEvent ( 102 ) ;
71341: LD_INT 102
71343: PPUSH
71344: CALL_OW 427
// end ;
71348: LD_VAR 0 1
71352: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
71353: LD_INT 0
71355: PPUSH
71356: PPUSH
71357: PPUSH
71358: PPUSH
71359: PPUSH
71360: PPUSH
71361: PPUSH
71362: PPUSH
// if not mc_bases then
71363: LD_EXP 86
71367: NOT
71368: IFFALSE 71372
// exit ;
71370: GO 72233
// for i = 1 to mc_bases do
71372: LD_ADDR_VAR 0 2
71376: PUSH
71377: DOUBLE
71378: LD_INT 1
71380: DEC
71381: ST_TO_ADDR
71382: LD_EXP 86
71386: PUSH
71387: FOR_TO
71388: IFFALSE 72231
// begin if not mc_building_need_repair [ i ] then
71390: LD_EXP 87
71394: PUSH
71395: LD_VAR 0 2
71399: ARRAY
71400: NOT
71401: IFFALSE 71588
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
71403: LD_ADDR_VAR 0 6
71407: PUSH
71408: LD_EXP 105
71412: PUSH
71413: LD_VAR 0 2
71417: ARRAY
71418: PPUSH
71419: LD_INT 3
71421: PUSH
71422: LD_INT 24
71424: PUSH
71425: LD_INT 1000
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: PUSH
71436: LD_INT 2
71438: PUSH
71439: LD_INT 34
71441: PUSH
71442: LD_INT 13
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 34
71451: PUSH
71452: LD_INT 52
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: LD_INT 34
71461: PUSH
71462: LD_EXP 7
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: EMPTY
71472: LIST
71473: LIST
71474: LIST
71475: LIST
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PPUSH
71481: CALL_OW 72
71485: ST_TO_ADDR
// if cranes then
71486: LD_VAR 0 6
71490: IFFALSE 71552
// for j in cranes do
71492: LD_ADDR_VAR 0 3
71496: PUSH
71497: LD_VAR 0 6
71501: PUSH
71502: FOR_IN
71503: IFFALSE 71550
// if not IsInArea ( j , mc_parking [ i ] ) then
71505: LD_VAR 0 3
71509: PPUSH
71510: LD_EXP 110
71514: PUSH
71515: LD_VAR 0 2
71519: ARRAY
71520: PPUSH
71521: CALL_OW 308
71525: NOT
71526: IFFALSE 71548
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71528: LD_VAR 0 3
71532: PPUSH
71533: LD_EXP 110
71537: PUSH
71538: LD_VAR 0 2
71542: ARRAY
71543: PPUSH
71544: CALL_OW 113
71548: GO 71502
71550: POP
71551: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
71552: LD_ADDR_EXP 88
71556: PUSH
71557: LD_EXP 88
71561: PPUSH
71562: LD_VAR 0 2
71566: PPUSH
71567: EMPTY
71568: PPUSH
71569: CALL_OW 1
71573: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
71574: LD_VAR 0 2
71578: PPUSH
71579: LD_INT 101
71581: PPUSH
71582: CALL 66476 0 2
// continue ;
71586: GO 71387
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
71588: LD_ADDR_EXP 92
71592: PUSH
71593: LD_EXP 92
71597: PPUSH
71598: LD_VAR 0 2
71602: PPUSH
71603: EMPTY
71604: PPUSH
71605: CALL_OW 1
71609: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71610: LD_VAR 0 2
71614: PPUSH
71615: LD_INT 103
71617: PPUSH
71618: CALL 66476 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
71622: LD_ADDR_VAR 0 5
71626: PUSH
71627: LD_EXP 86
71631: PUSH
71632: LD_VAR 0 2
71636: ARRAY
71637: PUSH
71638: LD_EXP 115
71642: PUSH
71643: LD_VAR 0 2
71647: ARRAY
71648: UNION
71649: PPUSH
71650: LD_INT 2
71652: PUSH
71653: LD_INT 25
71655: PUSH
71656: LD_INT 2
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: PUSH
71663: LD_INT 25
71665: PUSH
71666: LD_INT 16
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: LIST
71677: PUSH
71678: EMPTY
71679: LIST
71680: PPUSH
71681: CALL_OW 72
71685: PUSH
71686: LD_EXP 89
71690: PUSH
71691: LD_VAR 0 2
71695: ARRAY
71696: PUSH
71697: LD_INT 1
71699: ARRAY
71700: PUSH
71701: LD_EXP 89
71705: PUSH
71706: LD_VAR 0 2
71710: ARRAY
71711: PUSH
71712: LD_INT 2
71714: ARRAY
71715: UNION
71716: DIFF
71717: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
71718: LD_ADDR_VAR 0 6
71722: PUSH
71723: LD_EXP 105
71727: PUSH
71728: LD_VAR 0 2
71732: ARRAY
71733: PPUSH
71734: LD_INT 2
71736: PUSH
71737: LD_INT 34
71739: PUSH
71740: LD_INT 13
71742: PUSH
71743: EMPTY
71744: LIST
71745: LIST
71746: PUSH
71747: LD_INT 34
71749: PUSH
71750: LD_INT 52
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: PUSH
71757: LD_INT 34
71759: PUSH
71760: LD_EXP 7
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: PPUSH
71775: CALL_OW 72
71779: ST_TO_ADDR
// if cranes then
71780: LD_VAR 0 6
71784: IFFALSE 71920
// begin for j in cranes do
71786: LD_ADDR_VAR 0 3
71790: PUSH
71791: LD_VAR 0 6
71795: PUSH
71796: FOR_IN
71797: IFFALSE 71918
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
71799: LD_VAR 0 3
71803: PPUSH
71804: CALL_OW 256
71808: PUSH
71809: LD_INT 1000
71811: EQUAL
71812: PUSH
71813: LD_VAR 0 3
71817: PPUSH
71818: CALL_OW 314
71822: NOT
71823: AND
71824: IFFALSE 71858
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
71826: LD_VAR 0 3
71830: PPUSH
71831: LD_EXP 87
71835: PUSH
71836: LD_VAR 0 2
71840: ARRAY
71841: PPUSH
71842: LD_VAR 0 3
71846: PPUSH
71847: CALL_OW 74
71851: PPUSH
71852: CALL_OW 130
71856: GO 71916
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
71858: LD_VAR 0 3
71862: PPUSH
71863: CALL_OW 256
71867: PUSH
71868: LD_INT 500
71870: LESS
71871: PUSH
71872: LD_VAR 0 3
71876: PPUSH
71877: LD_EXP 110
71881: PUSH
71882: LD_VAR 0 2
71886: ARRAY
71887: PPUSH
71888: CALL_OW 308
71892: NOT
71893: AND
71894: IFFALSE 71916
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71896: LD_VAR 0 3
71900: PPUSH
71901: LD_EXP 110
71905: PUSH
71906: LD_VAR 0 2
71910: ARRAY
71911: PPUSH
71912: CALL_OW 113
// end ;
71916: GO 71796
71918: POP
71919: POP
// end ; if tmp > 3 then
71920: LD_VAR 0 5
71924: PUSH
71925: LD_INT 3
71927: GREATER
71928: IFFALSE 71948
// tmp := ShrinkArray ( tmp , 4 ) ;
71930: LD_ADDR_VAR 0 5
71934: PUSH
71935: LD_VAR 0 5
71939: PPUSH
71940: LD_INT 4
71942: PPUSH
71943: CALL 54142 0 2
71947: ST_TO_ADDR
// if not tmp then
71948: LD_VAR 0 5
71952: NOT
71953: IFFALSE 71957
// continue ;
71955: GO 71387
// for j in tmp do
71957: LD_ADDR_VAR 0 3
71961: PUSH
71962: LD_VAR 0 5
71966: PUSH
71967: FOR_IN
71968: IFFALSE 72227
// begin if IsInUnit ( j ) then
71970: LD_VAR 0 3
71974: PPUSH
71975: CALL_OW 310
71979: IFFALSE 71990
// ComExitBuilding ( j ) ;
71981: LD_VAR 0 3
71985: PPUSH
71986: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
71990: LD_VAR 0 3
71994: PUSH
71995: LD_EXP 88
71999: PUSH
72000: LD_VAR 0 2
72004: ARRAY
72005: IN
72006: NOT
72007: IFFALSE 72065
// begin SetTag ( j , 101 ) ;
72009: LD_VAR 0 3
72013: PPUSH
72014: LD_INT 101
72016: PPUSH
72017: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
72021: LD_ADDR_EXP 88
72025: PUSH
72026: LD_EXP 88
72030: PPUSH
72031: LD_VAR 0 2
72035: PUSH
72036: LD_EXP 88
72040: PUSH
72041: LD_VAR 0 2
72045: ARRAY
72046: PUSH
72047: LD_INT 1
72049: PLUS
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PPUSH
72055: LD_VAR 0 3
72059: PPUSH
72060: CALL 22451 0 3
72064: ST_TO_ADDR
// end ; wait ( 1 ) ;
72065: LD_INT 1
72067: PPUSH
72068: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
72072: LD_ADDR_VAR 0 7
72076: PUSH
72077: LD_EXP 87
72081: PUSH
72082: LD_VAR 0 2
72086: ARRAY
72087: ST_TO_ADDR
// if mc_scan [ i ] then
72088: LD_EXP 109
72092: PUSH
72093: LD_VAR 0 2
72097: ARRAY
72098: IFFALSE 72160
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
72100: LD_ADDR_VAR 0 7
72104: PUSH
72105: LD_EXP 87
72109: PUSH
72110: LD_VAR 0 2
72114: ARRAY
72115: PPUSH
72116: LD_INT 3
72118: PUSH
72119: LD_INT 30
72121: PUSH
72122: LD_INT 32
72124: PUSH
72125: EMPTY
72126: LIST
72127: LIST
72128: PUSH
72129: LD_INT 30
72131: PUSH
72132: LD_INT 33
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: LD_INT 30
72141: PUSH
72142: LD_INT 31
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: PUSH
72149: EMPTY
72150: LIST
72151: LIST
72152: LIST
72153: LIST
72154: PPUSH
72155: CALL_OW 72
72159: ST_TO_ADDR
// if not to_repair_tmp then
72160: LD_VAR 0 7
72164: NOT
72165: IFFALSE 72169
// continue ;
72167: GO 71967
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
72169: LD_ADDR_VAR 0 8
72173: PUSH
72174: LD_VAR 0 7
72178: PPUSH
72179: LD_VAR 0 3
72183: PPUSH
72184: CALL_OW 74
72188: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
72189: LD_VAR 0 8
72193: PPUSH
72194: LD_INT 16
72196: PPUSH
72197: CALL 25044 0 2
72201: PUSH
72202: LD_INT 4
72204: ARRAY
72205: PUSH
72206: LD_INT 10
72208: LESS
72209: IFFALSE 72225
// ComRepairBuilding ( j , to_repair ) ;
72211: LD_VAR 0 3
72215: PPUSH
72216: LD_VAR 0 8
72220: PPUSH
72221: CALL_OW 130
// end ;
72225: GO 71967
72227: POP
72228: POP
// end ;
72229: GO 71387
72231: POP
72232: POP
// end ;
72233: LD_VAR 0 1
72237: RET
// export function MC_Heal ; var i , j , tmp ; begin
72238: LD_INT 0
72240: PPUSH
72241: PPUSH
72242: PPUSH
72243: PPUSH
// if not mc_bases then
72244: LD_EXP 86
72248: NOT
72249: IFFALSE 72253
// exit ;
72251: GO 72655
// for i = 1 to mc_bases do
72253: LD_ADDR_VAR 0 2
72257: PUSH
72258: DOUBLE
72259: LD_INT 1
72261: DEC
72262: ST_TO_ADDR
72263: LD_EXP 86
72267: PUSH
72268: FOR_TO
72269: IFFALSE 72653
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
72271: LD_EXP 89
72275: PUSH
72276: LD_VAR 0 2
72280: ARRAY
72281: PUSH
72282: LD_INT 1
72284: ARRAY
72285: NOT
72286: PUSH
72287: LD_EXP 89
72291: PUSH
72292: LD_VAR 0 2
72296: ARRAY
72297: PUSH
72298: LD_INT 2
72300: ARRAY
72301: NOT
72302: AND
72303: IFFALSE 72341
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
72305: LD_ADDR_EXP 90
72309: PUSH
72310: LD_EXP 90
72314: PPUSH
72315: LD_VAR 0 2
72319: PPUSH
72320: EMPTY
72321: PPUSH
72322: CALL_OW 1
72326: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
72327: LD_VAR 0 2
72331: PPUSH
72332: LD_INT 102
72334: PPUSH
72335: CALL 66476 0 2
// continue ;
72339: GO 72268
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72341: LD_ADDR_VAR 0 4
72345: PUSH
72346: LD_EXP 86
72350: PUSH
72351: LD_VAR 0 2
72355: ARRAY
72356: PPUSH
72357: LD_INT 25
72359: PUSH
72360: LD_INT 4
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: PPUSH
72367: CALL_OW 72
72371: ST_TO_ADDR
// if not tmp then
72372: LD_VAR 0 4
72376: NOT
72377: IFFALSE 72381
// continue ;
72379: GO 72268
// if mc_taming [ i ] then
72381: LD_EXP 117
72385: PUSH
72386: LD_VAR 0 2
72390: ARRAY
72391: IFFALSE 72415
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72393: LD_ADDR_EXP 117
72397: PUSH
72398: LD_EXP 117
72402: PPUSH
72403: LD_VAR 0 2
72407: PPUSH
72408: EMPTY
72409: PPUSH
72410: CALL_OW 1
72414: ST_TO_ADDR
// for j in tmp do
72415: LD_ADDR_VAR 0 3
72419: PUSH
72420: LD_VAR 0 4
72424: PUSH
72425: FOR_IN
72426: IFFALSE 72649
// begin if IsInUnit ( j ) then
72428: LD_VAR 0 3
72432: PPUSH
72433: CALL_OW 310
72437: IFFALSE 72448
// ComExitBuilding ( j ) ;
72439: LD_VAR 0 3
72443: PPUSH
72444: CALL_OW 122
// if not j in mc_healers [ i ] then
72448: LD_VAR 0 3
72452: PUSH
72453: LD_EXP 90
72457: PUSH
72458: LD_VAR 0 2
72462: ARRAY
72463: IN
72464: NOT
72465: IFFALSE 72511
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
72467: LD_ADDR_EXP 90
72471: PUSH
72472: LD_EXP 90
72476: PPUSH
72477: LD_VAR 0 2
72481: PUSH
72482: LD_EXP 90
72486: PUSH
72487: LD_VAR 0 2
72491: ARRAY
72492: PUSH
72493: LD_INT 1
72495: PLUS
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PPUSH
72501: LD_VAR 0 3
72505: PPUSH
72506: CALL 22451 0 3
72510: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
72511: LD_VAR 0 3
72515: PPUSH
72516: CALL_OW 110
72520: PUSH
72521: LD_INT 102
72523: NONEQUAL
72524: IFFALSE 72538
// SetTag ( j , 102 ) ;
72526: LD_VAR 0 3
72530: PPUSH
72531: LD_INT 102
72533: PPUSH
72534: CALL_OW 109
// Wait ( 3 ) ;
72538: LD_INT 3
72540: PPUSH
72541: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
72545: LD_EXP 89
72549: PUSH
72550: LD_VAR 0 2
72554: ARRAY
72555: PUSH
72556: LD_INT 1
72558: ARRAY
72559: IFFALSE 72591
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
72561: LD_VAR 0 3
72565: PPUSH
72566: LD_EXP 89
72570: PUSH
72571: LD_VAR 0 2
72575: ARRAY
72576: PUSH
72577: LD_INT 1
72579: ARRAY
72580: PUSH
72581: LD_INT 1
72583: ARRAY
72584: PPUSH
72585: CALL_OW 128
72589: GO 72647
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
72591: LD_VAR 0 3
72595: PPUSH
72596: CALL_OW 314
72600: NOT
72601: PUSH
72602: LD_EXP 89
72606: PUSH
72607: LD_VAR 0 2
72611: ARRAY
72612: PUSH
72613: LD_INT 2
72615: ARRAY
72616: AND
72617: IFFALSE 72647
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
72619: LD_VAR 0 3
72623: PPUSH
72624: LD_EXP 89
72628: PUSH
72629: LD_VAR 0 2
72633: ARRAY
72634: PUSH
72635: LD_INT 2
72637: ARRAY
72638: PUSH
72639: LD_INT 1
72641: ARRAY
72642: PPUSH
72643: CALL_OW 128
// end ;
72647: GO 72425
72649: POP
72650: POP
// end ;
72651: GO 72268
72653: POP
72654: POP
// end ;
72655: LD_VAR 0 1
72659: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
72660: LD_INT 0
72662: PPUSH
72663: PPUSH
72664: PPUSH
72665: PPUSH
72666: PPUSH
// if not mc_bases then
72667: LD_EXP 86
72671: NOT
72672: IFFALSE 72676
// exit ;
72674: GO 73847
// for i = 1 to mc_bases do
72676: LD_ADDR_VAR 0 2
72680: PUSH
72681: DOUBLE
72682: LD_INT 1
72684: DEC
72685: ST_TO_ADDR
72686: LD_EXP 86
72690: PUSH
72691: FOR_TO
72692: IFFALSE 73845
// begin if mc_scan [ i ] then
72694: LD_EXP 109
72698: PUSH
72699: LD_VAR 0 2
72703: ARRAY
72704: IFFALSE 72708
// continue ;
72706: GO 72691
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
72708: LD_EXP 91
72712: PUSH
72713: LD_VAR 0 2
72717: ARRAY
72718: NOT
72719: PUSH
72720: LD_EXP 93
72724: PUSH
72725: LD_VAR 0 2
72729: ARRAY
72730: NOT
72731: AND
72732: PUSH
72733: LD_EXP 92
72737: PUSH
72738: LD_VAR 0 2
72742: ARRAY
72743: AND
72744: IFFALSE 72782
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
72746: LD_ADDR_EXP 92
72750: PUSH
72751: LD_EXP 92
72755: PPUSH
72756: LD_VAR 0 2
72760: PPUSH
72761: EMPTY
72762: PPUSH
72763: CALL_OW 1
72767: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
72768: LD_VAR 0 2
72772: PPUSH
72773: LD_INT 103
72775: PPUSH
72776: CALL 66476 0 2
// continue ;
72780: GO 72691
// end ; if mc_construct_list [ i ] then
72782: LD_EXP 93
72786: PUSH
72787: LD_VAR 0 2
72791: ARRAY
72792: IFFALSE 73012
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72794: LD_ADDR_VAR 0 4
72798: PUSH
72799: LD_EXP 86
72803: PUSH
72804: LD_VAR 0 2
72808: ARRAY
72809: PPUSH
72810: LD_INT 25
72812: PUSH
72813: LD_INT 2
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PPUSH
72820: CALL_OW 72
72824: PUSH
72825: LD_EXP 88
72829: PUSH
72830: LD_VAR 0 2
72834: ARRAY
72835: DIFF
72836: ST_TO_ADDR
// if not tmp then
72837: LD_VAR 0 4
72841: NOT
72842: IFFALSE 72846
// continue ;
72844: GO 72691
// for j in tmp do
72846: LD_ADDR_VAR 0 3
72850: PUSH
72851: LD_VAR 0 4
72855: PUSH
72856: FOR_IN
72857: IFFALSE 73008
// begin if not mc_builders [ i ] then
72859: LD_EXP 92
72863: PUSH
72864: LD_VAR 0 2
72868: ARRAY
72869: NOT
72870: IFFALSE 72928
// begin SetTag ( j , 103 ) ;
72872: LD_VAR 0 3
72876: PPUSH
72877: LD_INT 103
72879: PPUSH
72880: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72884: LD_ADDR_EXP 92
72888: PUSH
72889: LD_EXP 92
72893: PPUSH
72894: LD_VAR 0 2
72898: PUSH
72899: LD_EXP 92
72903: PUSH
72904: LD_VAR 0 2
72908: ARRAY
72909: PUSH
72910: LD_INT 1
72912: PLUS
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PPUSH
72918: LD_VAR 0 3
72922: PPUSH
72923: CALL 22451 0 3
72927: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72928: LD_VAR 0 3
72932: PPUSH
72933: CALL_OW 310
72937: IFFALSE 72948
// ComExitBuilding ( j ) ;
72939: LD_VAR 0 3
72943: PPUSH
72944: CALL_OW 122
// wait ( 3 ) ;
72948: LD_INT 3
72950: PPUSH
72951: CALL_OW 67
// if not mc_construct_list [ i ] then
72955: LD_EXP 93
72959: PUSH
72960: LD_VAR 0 2
72964: ARRAY
72965: NOT
72966: IFFALSE 72970
// break ;
72968: GO 73008
// if not HasTask ( j ) then
72970: LD_VAR 0 3
72974: PPUSH
72975: CALL_OW 314
72979: NOT
72980: IFFALSE 73006
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
72982: LD_VAR 0 3
72986: PPUSH
72987: LD_EXP 93
72991: PUSH
72992: LD_VAR 0 2
72996: ARRAY
72997: PUSH
72998: LD_INT 1
73000: ARRAY
73001: PPUSH
73002: CALL 25308 0 2
// end ;
73006: GO 72856
73008: POP
73009: POP
// end else
73010: GO 73843
// if mc_build_list [ i ] then
73012: LD_EXP 91
73016: PUSH
73017: LD_VAR 0 2
73021: ARRAY
73022: IFFALSE 73843
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73024: LD_ADDR_VAR 0 5
73028: PUSH
73029: LD_EXP 86
73033: PUSH
73034: LD_VAR 0 2
73038: ARRAY
73039: PPUSH
73040: LD_INT 2
73042: PUSH
73043: LD_INT 30
73045: PUSH
73046: LD_INT 0
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: PUSH
73053: LD_INT 30
73055: PUSH
73056: LD_INT 1
73058: PUSH
73059: EMPTY
73060: LIST
73061: LIST
73062: PUSH
73063: EMPTY
73064: LIST
73065: LIST
73066: LIST
73067: PPUSH
73068: CALL_OW 72
73072: ST_TO_ADDR
// if depot then
73073: LD_VAR 0 5
73077: IFFALSE 73095
// depot := depot [ 1 ] else
73079: LD_ADDR_VAR 0 5
73083: PUSH
73084: LD_VAR 0 5
73088: PUSH
73089: LD_INT 1
73091: ARRAY
73092: ST_TO_ADDR
73093: GO 73103
// depot := 0 ;
73095: LD_ADDR_VAR 0 5
73099: PUSH
73100: LD_INT 0
73102: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
73103: LD_EXP 91
73107: PUSH
73108: LD_VAR 0 2
73112: ARRAY
73113: PUSH
73114: LD_INT 1
73116: ARRAY
73117: PUSH
73118: LD_INT 1
73120: ARRAY
73121: PPUSH
73122: CALL 25132 0 1
73126: PUSH
73127: LD_EXP 86
73131: PUSH
73132: LD_VAR 0 2
73136: ARRAY
73137: PPUSH
73138: LD_INT 2
73140: PUSH
73141: LD_INT 30
73143: PUSH
73144: LD_INT 2
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PUSH
73151: LD_INT 30
73153: PUSH
73154: LD_INT 3
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: LIST
73165: PPUSH
73166: CALL_OW 72
73170: NOT
73171: AND
73172: IFFALSE 73277
// begin for j = 1 to mc_build_list [ i ] do
73174: LD_ADDR_VAR 0 3
73178: PUSH
73179: DOUBLE
73180: LD_INT 1
73182: DEC
73183: ST_TO_ADDR
73184: LD_EXP 91
73188: PUSH
73189: LD_VAR 0 2
73193: ARRAY
73194: PUSH
73195: FOR_TO
73196: IFFALSE 73275
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
73198: LD_EXP 91
73202: PUSH
73203: LD_VAR 0 2
73207: ARRAY
73208: PUSH
73209: LD_VAR 0 3
73213: ARRAY
73214: PUSH
73215: LD_INT 1
73217: ARRAY
73218: PUSH
73219: LD_INT 2
73221: EQUAL
73222: IFFALSE 73273
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
73224: LD_ADDR_EXP 91
73228: PUSH
73229: LD_EXP 91
73233: PPUSH
73234: LD_VAR 0 2
73238: PPUSH
73239: LD_EXP 91
73243: PUSH
73244: LD_VAR 0 2
73248: ARRAY
73249: PPUSH
73250: LD_VAR 0 3
73254: PPUSH
73255: LD_INT 1
73257: PPUSH
73258: LD_INT 0
73260: PPUSH
73261: CALL 21869 0 4
73265: PPUSH
73266: CALL_OW 1
73270: ST_TO_ADDR
// break ;
73271: GO 73275
// end ;
73273: GO 73195
73275: POP
73276: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
73277: LD_EXP 91
73281: PUSH
73282: LD_VAR 0 2
73286: ARRAY
73287: PUSH
73288: LD_INT 1
73290: ARRAY
73291: PUSH
73292: LD_INT 1
73294: ARRAY
73295: PUSH
73296: LD_INT 0
73298: EQUAL
73299: PUSH
73300: LD_VAR 0 5
73304: PUSH
73305: LD_VAR 0 5
73309: PPUSH
73310: LD_EXP 91
73314: PUSH
73315: LD_VAR 0 2
73319: ARRAY
73320: PUSH
73321: LD_INT 1
73323: ARRAY
73324: PUSH
73325: LD_INT 1
73327: ARRAY
73328: PPUSH
73329: LD_EXP 91
73333: PUSH
73334: LD_VAR 0 2
73338: ARRAY
73339: PUSH
73340: LD_INT 1
73342: ARRAY
73343: PUSH
73344: LD_INT 2
73346: ARRAY
73347: PPUSH
73348: LD_EXP 91
73352: PUSH
73353: LD_VAR 0 2
73357: ARRAY
73358: PUSH
73359: LD_INT 1
73361: ARRAY
73362: PUSH
73363: LD_INT 3
73365: ARRAY
73366: PPUSH
73367: LD_EXP 91
73371: PUSH
73372: LD_VAR 0 2
73376: ARRAY
73377: PUSH
73378: LD_INT 1
73380: ARRAY
73381: PUSH
73382: LD_INT 4
73384: ARRAY
73385: PPUSH
73386: CALL 30199 0 5
73390: AND
73391: OR
73392: IFFALSE 73673
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
73394: LD_ADDR_VAR 0 4
73398: PUSH
73399: LD_EXP 86
73403: PUSH
73404: LD_VAR 0 2
73408: ARRAY
73409: PPUSH
73410: LD_INT 25
73412: PUSH
73413: LD_INT 2
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PPUSH
73420: CALL_OW 72
73424: PUSH
73425: LD_EXP 88
73429: PUSH
73430: LD_VAR 0 2
73434: ARRAY
73435: DIFF
73436: ST_TO_ADDR
// if not tmp then
73437: LD_VAR 0 4
73441: NOT
73442: IFFALSE 73446
// continue ;
73444: GO 72691
// for j in tmp do
73446: LD_ADDR_VAR 0 3
73450: PUSH
73451: LD_VAR 0 4
73455: PUSH
73456: FOR_IN
73457: IFFALSE 73669
// begin if not mc_builders [ i ] then
73459: LD_EXP 92
73463: PUSH
73464: LD_VAR 0 2
73468: ARRAY
73469: NOT
73470: IFFALSE 73528
// begin SetTag ( j , 103 ) ;
73472: LD_VAR 0 3
73476: PPUSH
73477: LD_INT 103
73479: PPUSH
73480: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
73484: LD_ADDR_EXP 92
73488: PUSH
73489: LD_EXP 92
73493: PPUSH
73494: LD_VAR 0 2
73498: PUSH
73499: LD_EXP 92
73503: PUSH
73504: LD_VAR 0 2
73508: ARRAY
73509: PUSH
73510: LD_INT 1
73512: PLUS
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PPUSH
73518: LD_VAR 0 3
73522: PPUSH
73523: CALL 22451 0 3
73527: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
73528: LD_VAR 0 3
73532: PPUSH
73533: CALL_OW 310
73537: IFFALSE 73548
// ComExitBuilding ( j ) ;
73539: LD_VAR 0 3
73543: PPUSH
73544: CALL_OW 122
// wait ( 3 ) ;
73548: LD_INT 3
73550: PPUSH
73551: CALL_OW 67
// if not mc_build_list [ i ] then
73555: LD_EXP 91
73559: PUSH
73560: LD_VAR 0 2
73564: ARRAY
73565: NOT
73566: IFFALSE 73570
// break ;
73568: GO 73669
// if not HasTask ( j ) then
73570: LD_VAR 0 3
73574: PPUSH
73575: CALL_OW 314
73579: NOT
73580: IFFALSE 73667
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
73582: LD_VAR 0 3
73586: PPUSH
73587: LD_EXP 91
73591: PUSH
73592: LD_VAR 0 2
73596: ARRAY
73597: PUSH
73598: LD_INT 1
73600: ARRAY
73601: PUSH
73602: LD_INT 1
73604: ARRAY
73605: PPUSH
73606: LD_EXP 91
73610: PUSH
73611: LD_VAR 0 2
73615: ARRAY
73616: PUSH
73617: LD_INT 1
73619: ARRAY
73620: PUSH
73621: LD_INT 2
73623: ARRAY
73624: PPUSH
73625: LD_EXP 91
73629: PUSH
73630: LD_VAR 0 2
73634: ARRAY
73635: PUSH
73636: LD_INT 1
73638: ARRAY
73639: PUSH
73640: LD_INT 3
73642: ARRAY
73643: PPUSH
73644: LD_EXP 91
73648: PUSH
73649: LD_VAR 0 2
73653: ARRAY
73654: PUSH
73655: LD_INT 1
73657: ARRAY
73658: PUSH
73659: LD_INT 4
73661: ARRAY
73662: PPUSH
73663: CALL_OW 145
// end ;
73667: GO 73456
73669: POP
73670: POP
// end else
73671: GO 73843
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
73673: LD_EXP 86
73677: PUSH
73678: LD_VAR 0 2
73682: ARRAY
73683: PPUSH
73684: LD_EXP 91
73688: PUSH
73689: LD_VAR 0 2
73693: ARRAY
73694: PUSH
73695: LD_INT 1
73697: ARRAY
73698: PUSH
73699: LD_INT 1
73701: ARRAY
73702: PPUSH
73703: LD_EXP 91
73707: PUSH
73708: LD_VAR 0 2
73712: ARRAY
73713: PUSH
73714: LD_INT 1
73716: ARRAY
73717: PUSH
73718: LD_INT 2
73720: ARRAY
73721: PPUSH
73722: LD_EXP 91
73726: PUSH
73727: LD_VAR 0 2
73731: ARRAY
73732: PUSH
73733: LD_INT 1
73735: ARRAY
73736: PUSH
73737: LD_INT 3
73739: ARRAY
73740: PPUSH
73741: LD_EXP 91
73745: PUSH
73746: LD_VAR 0 2
73750: ARRAY
73751: PUSH
73752: LD_INT 1
73754: ARRAY
73755: PUSH
73756: LD_INT 4
73758: ARRAY
73759: PPUSH
73760: LD_EXP 86
73764: PUSH
73765: LD_VAR 0 2
73769: ARRAY
73770: PPUSH
73771: LD_INT 21
73773: PUSH
73774: LD_INT 3
73776: PUSH
73777: EMPTY
73778: LIST
73779: LIST
73780: PPUSH
73781: CALL_OW 72
73785: PPUSH
73786: EMPTY
73787: PPUSH
73788: CALL 29329 0 7
73792: NOT
73793: IFFALSE 73843
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
73795: LD_ADDR_EXP 91
73799: PUSH
73800: LD_EXP 91
73804: PPUSH
73805: LD_VAR 0 2
73809: PPUSH
73810: LD_EXP 91
73814: PUSH
73815: LD_VAR 0 2
73819: ARRAY
73820: PPUSH
73821: LD_INT 1
73823: PPUSH
73824: LD_INT 1
73826: NEG
73827: PPUSH
73828: LD_INT 0
73830: PPUSH
73831: CALL 21869 0 4
73835: PPUSH
73836: CALL_OW 1
73840: ST_TO_ADDR
// continue ;
73841: GO 72691
// end ; end ; end ;
73843: GO 72691
73845: POP
73846: POP
// end ;
73847: LD_VAR 0 1
73851: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
73852: LD_INT 0
73854: PPUSH
73855: PPUSH
73856: PPUSH
73857: PPUSH
73858: PPUSH
73859: PPUSH
// if not mc_bases then
73860: LD_EXP 86
73864: NOT
73865: IFFALSE 73869
// exit ;
73867: GO 74296
// for i = 1 to mc_bases do
73869: LD_ADDR_VAR 0 2
73873: PUSH
73874: DOUBLE
73875: LD_INT 1
73877: DEC
73878: ST_TO_ADDR
73879: LD_EXP 86
73883: PUSH
73884: FOR_TO
73885: IFFALSE 74294
// begin tmp := mc_build_upgrade [ i ] ;
73887: LD_ADDR_VAR 0 4
73891: PUSH
73892: LD_EXP 118
73896: PUSH
73897: LD_VAR 0 2
73901: ARRAY
73902: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
73903: LD_ADDR_VAR 0 6
73907: PUSH
73908: LD_EXP 119
73912: PUSH
73913: LD_VAR 0 2
73917: ARRAY
73918: PPUSH
73919: LD_INT 2
73921: PUSH
73922: LD_INT 30
73924: PUSH
73925: LD_INT 6
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: PUSH
73932: LD_INT 30
73934: PUSH
73935: LD_INT 7
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: LIST
73946: PPUSH
73947: CALL_OW 72
73951: ST_TO_ADDR
// if not tmp and not lab then
73952: LD_VAR 0 4
73956: NOT
73957: PUSH
73958: LD_VAR 0 6
73962: NOT
73963: AND
73964: IFFALSE 73968
// continue ;
73966: GO 73884
// if tmp then
73968: LD_VAR 0 4
73972: IFFALSE 74092
// for j in tmp do
73974: LD_ADDR_VAR 0 3
73978: PUSH
73979: LD_VAR 0 4
73983: PUSH
73984: FOR_IN
73985: IFFALSE 74090
// begin if UpgradeCost ( j ) then
73987: LD_VAR 0 3
73991: PPUSH
73992: CALL 28989 0 1
73996: IFFALSE 74088
// begin ComUpgrade ( j ) ;
73998: LD_VAR 0 3
74002: PPUSH
74003: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
74007: LD_ADDR_EXP 118
74011: PUSH
74012: LD_EXP 118
74016: PPUSH
74017: LD_VAR 0 2
74021: PPUSH
74022: LD_EXP 118
74026: PUSH
74027: LD_VAR 0 2
74031: ARRAY
74032: PUSH
74033: LD_VAR 0 3
74037: DIFF
74038: PPUSH
74039: CALL_OW 1
74043: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
74044: LD_ADDR_EXP 93
74048: PUSH
74049: LD_EXP 93
74053: PPUSH
74054: LD_VAR 0 2
74058: PUSH
74059: LD_EXP 93
74063: PUSH
74064: LD_VAR 0 2
74068: ARRAY
74069: PUSH
74070: LD_INT 1
74072: PLUS
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PPUSH
74078: LD_VAR 0 3
74082: PPUSH
74083: CALL 22451 0 3
74087: ST_TO_ADDR
// end ; end ;
74088: GO 73984
74090: POP
74091: POP
// if not lab or not mc_lab_upgrade [ i ] then
74092: LD_VAR 0 6
74096: NOT
74097: PUSH
74098: LD_EXP 120
74102: PUSH
74103: LD_VAR 0 2
74107: ARRAY
74108: NOT
74109: OR
74110: IFFALSE 74114
// continue ;
74112: GO 73884
// for j in lab do
74114: LD_ADDR_VAR 0 3
74118: PUSH
74119: LD_VAR 0 6
74123: PUSH
74124: FOR_IN
74125: IFFALSE 74290
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
74127: LD_VAR 0 3
74131: PPUSH
74132: CALL_OW 266
74136: PUSH
74137: LD_INT 6
74139: PUSH
74140: LD_INT 7
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: IN
74147: PUSH
74148: LD_VAR 0 3
74152: PPUSH
74153: CALL_OW 461
74157: PUSH
74158: LD_INT 1
74160: NONEQUAL
74161: AND
74162: IFFALSE 74288
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
74164: LD_VAR 0 3
74168: PPUSH
74169: LD_EXP 120
74173: PUSH
74174: LD_VAR 0 2
74178: ARRAY
74179: PUSH
74180: LD_INT 1
74182: ARRAY
74183: PPUSH
74184: CALL 29194 0 2
74188: IFFALSE 74288
// begin ComCancel ( j ) ;
74190: LD_VAR 0 3
74194: PPUSH
74195: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
74199: LD_VAR 0 3
74203: PPUSH
74204: LD_EXP 120
74208: PUSH
74209: LD_VAR 0 2
74213: ARRAY
74214: PUSH
74215: LD_INT 1
74217: ARRAY
74218: PPUSH
74219: CALL_OW 207
// if not j in mc_construct_list [ i ] then
74223: LD_VAR 0 3
74227: PUSH
74228: LD_EXP 93
74232: PUSH
74233: LD_VAR 0 2
74237: ARRAY
74238: IN
74239: NOT
74240: IFFALSE 74286
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
74242: LD_ADDR_EXP 93
74246: PUSH
74247: LD_EXP 93
74251: PPUSH
74252: LD_VAR 0 2
74256: PUSH
74257: LD_EXP 93
74261: PUSH
74262: LD_VAR 0 2
74266: ARRAY
74267: PUSH
74268: LD_INT 1
74270: PLUS
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: PPUSH
74276: LD_VAR 0 3
74280: PPUSH
74281: CALL 22451 0 3
74285: ST_TO_ADDR
// break ;
74286: GO 74290
// end ; end ; end ;
74288: GO 74124
74290: POP
74291: POP
// end ;
74292: GO 73884
74294: POP
74295: POP
// end ;
74296: LD_VAR 0 1
74300: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
74301: LD_INT 0
74303: PPUSH
74304: PPUSH
74305: PPUSH
74306: PPUSH
74307: PPUSH
74308: PPUSH
74309: PPUSH
74310: PPUSH
74311: PPUSH
// if not mc_bases then
74312: LD_EXP 86
74316: NOT
74317: IFFALSE 74321
// exit ;
74319: GO 74726
// for i = 1 to mc_bases do
74321: LD_ADDR_VAR 0 2
74325: PUSH
74326: DOUBLE
74327: LD_INT 1
74329: DEC
74330: ST_TO_ADDR
74331: LD_EXP 86
74335: PUSH
74336: FOR_TO
74337: IFFALSE 74724
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
74339: LD_EXP 94
74343: PUSH
74344: LD_VAR 0 2
74348: ARRAY
74349: NOT
74350: PUSH
74351: LD_EXP 86
74355: PUSH
74356: LD_VAR 0 2
74360: ARRAY
74361: PPUSH
74362: LD_INT 30
74364: PUSH
74365: LD_INT 3
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PPUSH
74372: CALL_OW 72
74376: NOT
74377: OR
74378: IFFALSE 74382
// continue ;
74380: GO 74336
// busy := false ;
74382: LD_ADDR_VAR 0 8
74386: PUSH
74387: LD_INT 0
74389: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74390: LD_ADDR_VAR 0 4
74394: PUSH
74395: LD_EXP 86
74399: PUSH
74400: LD_VAR 0 2
74404: ARRAY
74405: PPUSH
74406: LD_INT 30
74408: PUSH
74409: LD_INT 3
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PPUSH
74416: CALL_OW 72
74420: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
74421: LD_ADDR_VAR 0 6
74425: PUSH
74426: LD_EXP 94
74430: PUSH
74431: LD_VAR 0 2
74435: ARRAY
74436: PPUSH
74437: LD_INT 2
74439: PUSH
74440: LD_INT 30
74442: PUSH
74443: LD_INT 32
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: LD_INT 30
74452: PUSH
74453: LD_INT 33
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: LIST
74464: PPUSH
74465: CALL_OW 72
74469: ST_TO_ADDR
// if not t then
74470: LD_VAR 0 6
74474: NOT
74475: IFFALSE 74479
// continue ;
74477: GO 74336
// for j in tmp do
74479: LD_ADDR_VAR 0 3
74483: PUSH
74484: LD_VAR 0 4
74488: PUSH
74489: FOR_IN
74490: IFFALSE 74520
// if not BuildingStatus ( j ) = bs_idle then
74492: LD_VAR 0 3
74496: PPUSH
74497: CALL_OW 461
74501: PUSH
74502: LD_INT 2
74504: EQUAL
74505: NOT
74506: IFFALSE 74518
// begin busy := true ;
74508: LD_ADDR_VAR 0 8
74512: PUSH
74513: LD_INT 1
74515: ST_TO_ADDR
// break ;
74516: GO 74520
// end ;
74518: GO 74489
74520: POP
74521: POP
// if busy then
74522: LD_VAR 0 8
74526: IFFALSE 74530
// continue ;
74528: GO 74336
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
74530: LD_ADDR_VAR 0 7
74534: PUSH
74535: LD_VAR 0 6
74539: PPUSH
74540: LD_INT 35
74542: PUSH
74543: LD_INT 0
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PPUSH
74550: CALL_OW 72
74554: ST_TO_ADDR
// if tw then
74555: LD_VAR 0 7
74559: IFFALSE 74636
// begin tw := tw [ 1 ] ;
74561: LD_ADDR_VAR 0 7
74565: PUSH
74566: LD_VAR 0 7
74570: PUSH
74571: LD_INT 1
74573: ARRAY
74574: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
74575: LD_ADDR_VAR 0 9
74579: PUSH
74580: LD_VAR 0 7
74584: PPUSH
74585: LD_EXP 111
74589: PUSH
74590: LD_VAR 0 2
74594: ARRAY
74595: PPUSH
74596: CALL 27456 0 2
74600: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
74601: LD_EXP 125
74605: PUSH
74606: LD_VAR 0 2
74610: ARRAY
74611: IFFALSE 74634
// if not weapon in mc_allowed_tower_weapons [ i ] then
74613: LD_VAR 0 9
74617: PUSH
74618: LD_EXP 125
74622: PUSH
74623: LD_VAR 0 2
74627: ARRAY
74628: IN
74629: NOT
74630: IFFALSE 74634
// continue ;
74632: GO 74336
// end else
74634: GO 74699
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
74636: LD_ADDR_VAR 0 5
74640: PUSH
74641: LD_EXP 94
74645: PUSH
74646: LD_VAR 0 2
74650: ARRAY
74651: PPUSH
74652: LD_VAR 0 4
74656: PPUSH
74657: CALL 53375 0 2
74661: ST_TO_ADDR
// if not tmp2 then
74662: LD_VAR 0 5
74666: NOT
74667: IFFALSE 74671
// continue ;
74669: GO 74336
// tw := tmp2 [ 1 ] ;
74671: LD_ADDR_VAR 0 7
74675: PUSH
74676: LD_VAR 0 5
74680: PUSH
74681: LD_INT 1
74683: ARRAY
74684: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
74685: LD_ADDR_VAR 0 9
74689: PUSH
74690: LD_VAR 0 5
74694: PUSH
74695: LD_INT 2
74697: ARRAY
74698: ST_TO_ADDR
// end ; if not weapon then
74699: LD_VAR 0 9
74703: NOT
74704: IFFALSE 74708
// continue ;
74706: GO 74336
// ComPlaceWeapon ( tw , weapon ) ;
74708: LD_VAR 0 7
74712: PPUSH
74713: LD_VAR 0 9
74717: PPUSH
74718: CALL_OW 148
// end ;
74722: GO 74336
74724: POP
74725: POP
// end ;
74726: LD_VAR 0 1
74730: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
74731: LD_INT 0
74733: PPUSH
74734: PPUSH
74735: PPUSH
74736: PPUSH
74737: PPUSH
74738: PPUSH
74739: PPUSH
// if not mc_bases then
74740: LD_EXP 86
74744: NOT
74745: IFFALSE 74749
// exit ;
74747: GO 75517
// for i = 1 to mc_bases do
74749: LD_ADDR_VAR 0 2
74753: PUSH
74754: DOUBLE
74755: LD_INT 1
74757: DEC
74758: ST_TO_ADDR
74759: LD_EXP 86
74763: PUSH
74764: FOR_TO
74765: IFFALSE 75515
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
74767: LD_EXP 99
74771: PUSH
74772: LD_VAR 0 2
74776: ARRAY
74777: NOT
74778: PUSH
74779: LD_EXP 99
74783: PUSH
74784: LD_VAR 0 2
74788: ARRAY
74789: PUSH
74790: LD_EXP 100
74794: PUSH
74795: LD_VAR 0 2
74799: ARRAY
74800: EQUAL
74801: OR
74802: PUSH
74803: LD_EXP 109
74807: PUSH
74808: LD_VAR 0 2
74812: ARRAY
74813: OR
74814: IFFALSE 74818
// continue ;
74816: GO 74764
// if mc_miners [ i ] then
74818: LD_EXP 100
74822: PUSH
74823: LD_VAR 0 2
74827: ARRAY
74828: IFFALSE 75202
// begin for j = mc_miners [ i ] downto 1 do
74830: LD_ADDR_VAR 0 3
74834: PUSH
74835: DOUBLE
74836: LD_EXP 100
74840: PUSH
74841: LD_VAR 0 2
74845: ARRAY
74846: INC
74847: ST_TO_ADDR
74848: LD_INT 1
74850: PUSH
74851: FOR_DOWNTO
74852: IFFALSE 75200
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
74854: LD_EXP 100
74858: PUSH
74859: LD_VAR 0 2
74863: ARRAY
74864: PUSH
74865: LD_VAR 0 3
74869: ARRAY
74870: PPUSH
74871: CALL_OW 301
74875: PUSH
74876: LD_EXP 100
74880: PUSH
74881: LD_VAR 0 2
74885: ARRAY
74886: PUSH
74887: LD_VAR 0 3
74891: ARRAY
74892: PPUSH
74893: CALL_OW 257
74897: PUSH
74898: LD_INT 1
74900: NONEQUAL
74901: OR
74902: IFFALSE 74965
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
74904: LD_ADDR_VAR 0 5
74908: PUSH
74909: LD_EXP 100
74913: PUSH
74914: LD_VAR 0 2
74918: ARRAY
74919: PUSH
74920: LD_EXP 100
74924: PUSH
74925: LD_VAR 0 2
74929: ARRAY
74930: PUSH
74931: LD_VAR 0 3
74935: ARRAY
74936: DIFF
74937: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
74938: LD_ADDR_EXP 100
74942: PUSH
74943: LD_EXP 100
74947: PPUSH
74948: LD_VAR 0 2
74952: PPUSH
74953: LD_VAR 0 5
74957: PPUSH
74958: CALL_OW 1
74962: ST_TO_ADDR
// continue ;
74963: GO 74851
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
74965: LD_EXP 100
74969: PUSH
74970: LD_VAR 0 2
74974: ARRAY
74975: PUSH
74976: LD_VAR 0 3
74980: ARRAY
74981: PPUSH
74982: CALL_OW 257
74986: PUSH
74987: LD_INT 1
74989: EQUAL
74990: PUSH
74991: LD_EXP 100
74995: PUSH
74996: LD_VAR 0 2
75000: ARRAY
75001: PUSH
75002: LD_VAR 0 3
75006: ARRAY
75007: PPUSH
75008: CALL_OW 459
75012: NOT
75013: AND
75014: PUSH
75015: LD_EXP 100
75019: PUSH
75020: LD_VAR 0 2
75024: ARRAY
75025: PUSH
75026: LD_VAR 0 3
75030: ARRAY
75031: PPUSH
75032: CALL_OW 314
75036: NOT
75037: AND
75038: IFFALSE 75198
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
75040: LD_EXP 100
75044: PUSH
75045: LD_VAR 0 2
75049: ARRAY
75050: PUSH
75051: LD_VAR 0 3
75055: ARRAY
75056: PPUSH
75057: CALL_OW 310
75061: IFFALSE 75084
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
75063: LD_EXP 100
75067: PUSH
75068: LD_VAR 0 2
75072: ARRAY
75073: PUSH
75074: LD_VAR 0 3
75078: ARRAY
75079: PPUSH
75080: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
75084: LD_EXP 100
75088: PUSH
75089: LD_VAR 0 2
75093: ARRAY
75094: PUSH
75095: LD_VAR 0 3
75099: ARRAY
75100: PPUSH
75101: CALL_OW 314
75105: NOT
75106: IFFALSE 75198
// begin r := rand ( 1 , mc_mines [ i ] ) ;
75108: LD_ADDR_VAR 0 7
75112: PUSH
75113: LD_INT 1
75115: PPUSH
75116: LD_EXP 99
75120: PUSH
75121: LD_VAR 0 2
75125: ARRAY
75126: PPUSH
75127: CALL_OW 12
75131: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
75132: LD_EXP 100
75136: PUSH
75137: LD_VAR 0 2
75141: ARRAY
75142: PUSH
75143: LD_VAR 0 3
75147: ARRAY
75148: PPUSH
75149: LD_EXP 99
75153: PUSH
75154: LD_VAR 0 2
75158: ARRAY
75159: PUSH
75160: LD_VAR 0 7
75164: ARRAY
75165: PUSH
75166: LD_INT 1
75168: ARRAY
75169: PPUSH
75170: LD_EXP 99
75174: PUSH
75175: LD_VAR 0 2
75179: ARRAY
75180: PUSH
75181: LD_VAR 0 7
75185: ARRAY
75186: PUSH
75187: LD_INT 2
75189: ARRAY
75190: PPUSH
75191: LD_INT 0
75193: PPUSH
75194: CALL_OW 193
// end ; end ; end ;
75198: GO 74851
75200: POP
75201: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
75202: LD_ADDR_VAR 0 5
75206: PUSH
75207: LD_EXP 86
75211: PUSH
75212: LD_VAR 0 2
75216: ARRAY
75217: PPUSH
75218: LD_INT 2
75220: PUSH
75221: LD_INT 30
75223: PUSH
75224: LD_INT 4
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 30
75233: PUSH
75234: LD_INT 5
75236: PUSH
75237: EMPTY
75238: LIST
75239: LIST
75240: PUSH
75241: LD_INT 30
75243: PUSH
75244: LD_INT 32
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: EMPTY
75252: LIST
75253: LIST
75254: LIST
75255: LIST
75256: PPUSH
75257: CALL_OW 72
75261: ST_TO_ADDR
// if not tmp then
75262: LD_VAR 0 5
75266: NOT
75267: IFFALSE 75271
// continue ;
75269: GO 74764
// list := [ ] ;
75271: LD_ADDR_VAR 0 6
75275: PUSH
75276: EMPTY
75277: ST_TO_ADDR
// for j in tmp do
75278: LD_ADDR_VAR 0 3
75282: PUSH
75283: LD_VAR 0 5
75287: PUSH
75288: FOR_IN
75289: IFFALSE 75358
// begin for k in UnitsInside ( j ) do
75291: LD_ADDR_VAR 0 4
75295: PUSH
75296: LD_VAR 0 3
75300: PPUSH
75301: CALL_OW 313
75305: PUSH
75306: FOR_IN
75307: IFFALSE 75354
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
75309: LD_VAR 0 4
75313: PPUSH
75314: CALL_OW 257
75318: PUSH
75319: LD_INT 1
75321: EQUAL
75322: PUSH
75323: LD_VAR 0 4
75327: PPUSH
75328: CALL_OW 459
75332: NOT
75333: AND
75334: IFFALSE 75352
// list := list ^ k ;
75336: LD_ADDR_VAR 0 6
75340: PUSH
75341: LD_VAR 0 6
75345: PUSH
75346: LD_VAR 0 4
75350: ADD
75351: ST_TO_ADDR
75352: GO 75306
75354: POP
75355: POP
// end ;
75356: GO 75288
75358: POP
75359: POP
// list := list diff mc_miners [ i ] ;
75360: LD_ADDR_VAR 0 6
75364: PUSH
75365: LD_VAR 0 6
75369: PUSH
75370: LD_EXP 100
75374: PUSH
75375: LD_VAR 0 2
75379: ARRAY
75380: DIFF
75381: ST_TO_ADDR
// if not list then
75382: LD_VAR 0 6
75386: NOT
75387: IFFALSE 75391
// continue ;
75389: GO 74764
// k := mc_mines [ i ] - mc_miners [ i ] ;
75391: LD_ADDR_VAR 0 4
75395: PUSH
75396: LD_EXP 99
75400: PUSH
75401: LD_VAR 0 2
75405: ARRAY
75406: PUSH
75407: LD_EXP 100
75411: PUSH
75412: LD_VAR 0 2
75416: ARRAY
75417: MINUS
75418: ST_TO_ADDR
// if k > list then
75419: LD_VAR 0 4
75423: PUSH
75424: LD_VAR 0 6
75428: GREATER
75429: IFFALSE 75441
// k := list ;
75431: LD_ADDR_VAR 0 4
75435: PUSH
75436: LD_VAR 0 6
75440: ST_TO_ADDR
// for j = 1 to k do
75441: LD_ADDR_VAR 0 3
75445: PUSH
75446: DOUBLE
75447: LD_INT 1
75449: DEC
75450: ST_TO_ADDR
75451: LD_VAR 0 4
75455: PUSH
75456: FOR_TO
75457: IFFALSE 75511
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
75459: LD_ADDR_EXP 100
75463: PUSH
75464: LD_EXP 100
75468: PPUSH
75469: LD_VAR 0 2
75473: PUSH
75474: LD_EXP 100
75478: PUSH
75479: LD_VAR 0 2
75483: ARRAY
75484: PUSH
75485: LD_INT 1
75487: PLUS
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PPUSH
75493: LD_VAR 0 6
75497: PUSH
75498: LD_VAR 0 3
75502: ARRAY
75503: PPUSH
75504: CALL 22451 0 3
75508: ST_TO_ADDR
75509: GO 75456
75511: POP
75512: POP
// end ;
75513: GO 74764
75515: POP
75516: POP
// end ;
75517: LD_VAR 0 1
75521: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
75522: LD_INT 0
75524: PPUSH
75525: PPUSH
75526: PPUSH
75527: PPUSH
75528: PPUSH
75529: PPUSH
75530: PPUSH
75531: PPUSH
75532: PPUSH
75533: PPUSH
// if not mc_bases then
75534: LD_EXP 86
75538: NOT
75539: IFFALSE 75543
// exit ;
75541: GO 77293
// for i = 1 to mc_bases do
75543: LD_ADDR_VAR 0 2
75547: PUSH
75548: DOUBLE
75549: LD_INT 1
75551: DEC
75552: ST_TO_ADDR
75553: LD_EXP 86
75557: PUSH
75558: FOR_TO
75559: IFFALSE 77291
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
75561: LD_EXP 86
75565: PUSH
75566: LD_VAR 0 2
75570: ARRAY
75571: NOT
75572: PUSH
75573: LD_EXP 93
75577: PUSH
75578: LD_VAR 0 2
75582: ARRAY
75583: OR
75584: IFFALSE 75588
// continue ;
75586: GO 75558
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
75588: LD_EXP 102
75592: PUSH
75593: LD_VAR 0 2
75597: ARRAY
75598: NOT
75599: PUSH
75600: LD_EXP 103
75604: PUSH
75605: LD_VAR 0 2
75609: ARRAY
75610: AND
75611: IFFALSE 75649
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
75613: LD_ADDR_EXP 103
75617: PUSH
75618: LD_EXP 103
75622: PPUSH
75623: LD_VAR 0 2
75627: PPUSH
75628: EMPTY
75629: PPUSH
75630: CALL_OW 1
75634: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
75635: LD_VAR 0 2
75639: PPUSH
75640: LD_INT 107
75642: PPUSH
75643: CALL 66476 0 2
// continue ;
75647: GO 75558
// end ; target := [ ] ;
75649: LD_ADDR_VAR 0 6
75653: PUSH
75654: EMPTY
75655: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
75656: LD_ADDR_VAR 0 3
75660: PUSH
75661: DOUBLE
75662: LD_EXP 102
75666: PUSH
75667: LD_VAR 0 2
75671: ARRAY
75672: INC
75673: ST_TO_ADDR
75674: LD_INT 1
75676: PUSH
75677: FOR_DOWNTO
75678: IFFALSE 75938
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
75680: LD_EXP 102
75684: PUSH
75685: LD_VAR 0 2
75689: ARRAY
75690: PUSH
75691: LD_VAR 0 3
75695: ARRAY
75696: PUSH
75697: LD_INT 2
75699: ARRAY
75700: PPUSH
75701: LD_EXP 102
75705: PUSH
75706: LD_VAR 0 2
75710: ARRAY
75711: PUSH
75712: LD_VAR 0 3
75716: ARRAY
75717: PUSH
75718: LD_INT 3
75720: ARRAY
75721: PPUSH
75722: CALL_OW 488
75726: PUSH
75727: LD_EXP 102
75731: PUSH
75732: LD_VAR 0 2
75736: ARRAY
75737: PUSH
75738: LD_VAR 0 3
75742: ARRAY
75743: PUSH
75744: LD_INT 2
75746: ARRAY
75747: PPUSH
75748: LD_EXP 102
75752: PUSH
75753: LD_VAR 0 2
75757: ARRAY
75758: PUSH
75759: LD_VAR 0 3
75763: ARRAY
75764: PUSH
75765: LD_INT 3
75767: ARRAY
75768: PPUSH
75769: CALL_OW 284
75773: PUSH
75774: LD_INT 0
75776: EQUAL
75777: AND
75778: IFFALSE 75833
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
75780: LD_ADDR_VAR 0 5
75784: PUSH
75785: LD_EXP 102
75789: PUSH
75790: LD_VAR 0 2
75794: ARRAY
75795: PPUSH
75796: LD_VAR 0 3
75800: PPUSH
75801: CALL_OW 3
75805: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
75806: LD_ADDR_EXP 102
75810: PUSH
75811: LD_EXP 102
75815: PPUSH
75816: LD_VAR 0 2
75820: PPUSH
75821: LD_VAR 0 5
75825: PPUSH
75826: CALL_OW 1
75830: ST_TO_ADDR
// continue ;
75831: GO 75677
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
75833: LD_EXP 86
75837: PUSH
75838: LD_VAR 0 2
75842: ARRAY
75843: PUSH
75844: LD_INT 1
75846: ARRAY
75847: PPUSH
75848: CALL_OW 255
75852: PPUSH
75853: LD_EXP 102
75857: PUSH
75858: LD_VAR 0 2
75862: ARRAY
75863: PUSH
75864: LD_VAR 0 3
75868: ARRAY
75869: PUSH
75870: LD_INT 2
75872: ARRAY
75873: PPUSH
75874: LD_EXP 102
75878: PUSH
75879: LD_VAR 0 2
75883: ARRAY
75884: PUSH
75885: LD_VAR 0 3
75889: ARRAY
75890: PUSH
75891: LD_INT 3
75893: ARRAY
75894: PPUSH
75895: LD_INT 30
75897: PPUSH
75898: CALL 23347 0 4
75902: PUSH
75903: LD_INT 4
75905: ARRAY
75906: PUSH
75907: LD_INT 0
75909: EQUAL
75910: IFFALSE 75936
// begin target := mc_crates [ i ] [ j ] ;
75912: LD_ADDR_VAR 0 6
75916: PUSH
75917: LD_EXP 102
75921: PUSH
75922: LD_VAR 0 2
75926: ARRAY
75927: PUSH
75928: LD_VAR 0 3
75932: ARRAY
75933: ST_TO_ADDR
// break ;
75934: GO 75938
// end ; end ;
75936: GO 75677
75938: POP
75939: POP
// if not target then
75940: LD_VAR 0 6
75944: NOT
75945: IFFALSE 75949
// continue ;
75947: GO 75558
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
75949: LD_ADDR_VAR 0 7
75953: PUSH
75954: LD_EXP 105
75958: PUSH
75959: LD_VAR 0 2
75963: ARRAY
75964: PPUSH
75965: LD_INT 2
75967: PUSH
75968: LD_INT 3
75970: PUSH
75971: LD_INT 58
75973: PUSH
75974: EMPTY
75975: LIST
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PUSH
75981: LD_INT 61
75983: PUSH
75984: EMPTY
75985: LIST
75986: PUSH
75987: LD_INT 33
75989: PUSH
75990: LD_INT 5
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 33
75999: PUSH
76000: LD_INT 3
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: EMPTY
76008: LIST
76009: LIST
76010: LIST
76011: LIST
76012: LIST
76013: PUSH
76014: LD_INT 2
76016: PUSH
76017: LD_INT 34
76019: PUSH
76020: LD_INT 32
76022: PUSH
76023: EMPTY
76024: LIST
76025: LIST
76026: PUSH
76027: LD_INT 34
76029: PUSH
76030: LD_INT 51
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 34
76039: PUSH
76040: LD_INT 12
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: EMPTY
76048: LIST
76049: LIST
76050: LIST
76051: LIST
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PPUSH
76057: CALL_OW 72
76061: ST_TO_ADDR
// if not cargo then
76062: LD_VAR 0 7
76066: NOT
76067: IFFALSE 76710
// begin if mc_crates_collector [ i ] < 5 then
76069: LD_EXP 103
76073: PUSH
76074: LD_VAR 0 2
76078: ARRAY
76079: PUSH
76080: LD_INT 5
76082: LESS
76083: IFFALSE 76449
// begin if mc_ape [ i ] then
76085: LD_EXP 115
76089: PUSH
76090: LD_VAR 0 2
76094: ARRAY
76095: IFFALSE 76142
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
76097: LD_ADDR_VAR 0 5
76101: PUSH
76102: LD_EXP 115
76106: PUSH
76107: LD_VAR 0 2
76111: ARRAY
76112: PPUSH
76113: LD_INT 25
76115: PUSH
76116: LD_INT 16
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 24
76125: PUSH
76126: LD_INT 750
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: PPUSH
76137: CALL_OW 72
76141: ST_TO_ADDR
// if not tmp then
76142: LD_VAR 0 5
76146: NOT
76147: IFFALSE 76194
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
76149: LD_ADDR_VAR 0 5
76153: PUSH
76154: LD_EXP 86
76158: PUSH
76159: LD_VAR 0 2
76163: ARRAY
76164: PPUSH
76165: LD_INT 25
76167: PUSH
76168: LD_INT 2
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 24
76177: PUSH
76178: LD_INT 750
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: PPUSH
76189: CALL_OW 72
76193: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
76194: LD_EXP 115
76198: PUSH
76199: LD_VAR 0 2
76203: ARRAY
76204: PUSH
76205: LD_EXP 86
76209: PUSH
76210: LD_VAR 0 2
76214: ARRAY
76215: PPUSH
76216: LD_INT 25
76218: PUSH
76219: LD_INT 2
76221: PUSH
76222: EMPTY
76223: LIST
76224: LIST
76225: PUSH
76226: LD_INT 24
76228: PUSH
76229: LD_INT 750
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PPUSH
76240: CALL_OW 72
76244: AND
76245: PUSH
76246: LD_VAR 0 5
76250: PUSH
76251: LD_INT 5
76253: LESS
76254: AND
76255: IFFALSE 76337
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
76257: LD_ADDR_VAR 0 3
76261: PUSH
76262: LD_EXP 86
76266: PUSH
76267: LD_VAR 0 2
76271: ARRAY
76272: PPUSH
76273: LD_INT 25
76275: PUSH
76276: LD_INT 2
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: LD_INT 24
76285: PUSH
76286: LD_INT 750
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PPUSH
76297: CALL_OW 72
76301: PUSH
76302: FOR_IN
76303: IFFALSE 76335
// begin tmp := tmp union j ;
76305: LD_ADDR_VAR 0 5
76309: PUSH
76310: LD_VAR 0 5
76314: PUSH
76315: LD_VAR 0 3
76319: UNION
76320: ST_TO_ADDR
// if tmp >= 5 then
76321: LD_VAR 0 5
76325: PUSH
76326: LD_INT 5
76328: GREATEREQUAL
76329: IFFALSE 76333
// break ;
76331: GO 76335
// end ;
76333: GO 76302
76335: POP
76336: POP
// end ; if not tmp then
76337: LD_VAR 0 5
76341: NOT
76342: IFFALSE 76346
// continue ;
76344: GO 75558
// for j in tmp do
76346: LD_ADDR_VAR 0 3
76350: PUSH
76351: LD_VAR 0 5
76355: PUSH
76356: FOR_IN
76357: IFFALSE 76447
// if not GetTag ( j ) then
76359: LD_VAR 0 3
76363: PPUSH
76364: CALL_OW 110
76368: NOT
76369: IFFALSE 76445
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
76371: LD_ADDR_EXP 103
76375: PUSH
76376: LD_EXP 103
76380: PPUSH
76381: LD_VAR 0 2
76385: PUSH
76386: LD_EXP 103
76390: PUSH
76391: LD_VAR 0 2
76395: ARRAY
76396: PUSH
76397: LD_INT 1
76399: PLUS
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PPUSH
76405: LD_VAR 0 3
76409: PPUSH
76410: CALL 22451 0 3
76414: ST_TO_ADDR
// SetTag ( j , 107 ) ;
76415: LD_VAR 0 3
76419: PPUSH
76420: LD_INT 107
76422: PPUSH
76423: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
76427: LD_EXP 103
76431: PUSH
76432: LD_VAR 0 2
76436: ARRAY
76437: PUSH
76438: LD_INT 5
76440: GREATEREQUAL
76441: IFFALSE 76445
// break ;
76443: GO 76447
// end ;
76445: GO 76356
76447: POP
76448: POP
// end ; if mc_crates_collector [ i ] and target then
76449: LD_EXP 103
76453: PUSH
76454: LD_VAR 0 2
76458: ARRAY
76459: PUSH
76460: LD_VAR 0 6
76464: AND
76465: IFFALSE 76708
// begin if mc_crates_collector [ i ] < target [ 1 ] then
76467: LD_EXP 103
76471: PUSH
76472: LD_VAR 0 2
76476: ARRAY
76477: PUSH
76478: LD_VAR 0 6
76482: PUSH
76483: LD_INT 1
76485: ARRAY
76486: LESS
76487: IFFALSE 76507
// tmp := mc_crates_collector [ i ] else
76489: LD_ADDR_VAR 0 5
76493: PUSH
76494: LD_EXP 103
76498: PUSH
76499: LD_VAR 0 2
76503: ARRAY
76504: ST_TO_ADDR
76505: GO 76521
// tmp := target [ 1 ] ;
76507: LD_ADDR_VAR 0 5
76511: PUSH
76512: LD_VAR 0 6
76516: PUSH
76517: LD_INT 1
76519: ARRAY
76520: ST_TO_ADDR
// k := 0 ;
76521: LD_ADDR_VAR 0 4
76525: PUSH
76526: LD_INT 0
76528: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
76529: LD_ADDR_VAR 0 3
76533: PUSH
76534: LD_EXP 103
76538: PUSH
76539: LD_VAR 0 2
76543: ARRAY
76544: PUSH
76545: FOR_IN
76546: IFFALSE 76706
// begin k := k + 1 ;
76548: LD_ADDR_VAR 0 4
76552: PUSH
76553: LD_VAR 0 4
76557: PUSH
76558: LD_INT 1
76560: PLUS
76561: ST_TO_ADDR
// if k > tmp then
76562: LD_VAR 0 4
76566: PUSH
76567: LD_VAR 0 5
76571: GREATER
76572: IFFALSE 76576
// break ;
76574: GO 76706
// if not GetClass ( j ) in [ 2 , 16 ] then
76576: LD_VAR 0 3
76580: PPUSH
76581: CALL_OW 257
76585: PUSH
76586: LD_INT 2
76588: PUSH
76589: LD_INT 16
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: IN
76596: NOT
76597: IFFALSE 76650
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
76599: LD_ADDR_EXP 103
76603: PUSH
76604: LD_EXP 103
76608: PPUSH
76609: LD_VAR 0 2
76613: PPUSH
76614: LD_EXP 103
76618: PUSH
76619: LD_VAR 0 2
76623: ARRAY
76624: PUSH
76625: LD_VAR 0 3
76629: DIFF
76630: PPUSH
76631: CALL_OW 1
76635: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76636: LD_VAR 0 3
76640: PPUSH
76641: LD_INT 0
76643: PPUSH
76644: CALL_OW 109
// continue ;
76648: GO 76545
// end ; if IsInUnit ( j ) then
76650: LD_VAR 0 3
76654: PPUSH
76655: CALL_OW 310
76659: IFFALSE 76670
// ComExitBuilding ( j ) ;
76661: LD_VAR 0 3
76665: PPUSH
76666: CALL_OW 122
// wait ( 3 ) ;
76670: LD_INT 3
76672: PPUSH
76673: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76677: LD_VAR 0 3
76681: PPUSH
76682: LD_VAR 0 6
76686: PUSH
76687: LD_INT 2
76689: ARRAY
76690: PPUSH
76691: LD_VAR 0 6
76695: PUSH
76696: LD_INT 3
76698: ARRAY
76699: PPUSH
76700: CALL_OW 117
// end ;
76704: GO 76545
76706: POP
76707: POP
// end ; end else
76708: GO 77289
// begin for j in cargo do
76710: LD_ADDR_VAR 0 3
76714: PUSH
76715: LD_VAR 0 7
76719: PUSH
76720: FOR_IN
76721: IFFALSE 77287
// begin if GetTag ( j ) <> 0 then
76723: LD_VAR 0 3
76727: PPUSH
76728: CALL_OW 110
76732: PUSH
76733: LD_INT 0
76735: NONEQUAL
76736: IFFALSE 76740
// continue ;
76738: GO 76720
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
76740: LD_VAR 0 3
76744: PPUSH
76745: CALL_OW 256
76749: PUSH
76750: LD_INT 1000
76752: LESS
76753: PUSH
76754: LD_VAR 0 3
76758: PPUSH
76759: LD_EXP 110
76763: PUSH
76764: LD_VAR 0 2
76768: ARRAY
76769: PPUSH
76770: CALL_OW 308
76774: NOT
76775: AND
76776: IFFALSE 76798
// ComMoveToArea ( j , mc_parking [ i ] ) ;
76778: LD_VAR 0 3
76782: PPUSH
76783: LD_EXP 110
76787: PUSH
76788: LD_VAR 0 2
76792: ARRAY
76793: PPUSH
76794: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
76798: LD_VAR 0 3
76802: PPUSH
76803: CALL_OW 256
76807: PUSH
76808: LD_INT 1000
76810: LESS
76811: PUSH
76812: LD_VAR 0 3
76816: PPUSH
76817: LD_EXP 110
76821: PUSH
76822: LD_VAR 0 2
76826: ARRAY
76827: PPUSH
76828: CALL_OW 308
76832: AND
76833: IFFALSE 76837
// continue ;
76835: GO 76720
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
76837: LD_VAR 0 3
76841: PPUSH
76842: CALL_OW 262
76846: PUSH
76847: LD_INT 2
76849: EQUAL
76850: PUSH
76851: LD_VAR 0 3
76855: PPUSH
76856: CALL_OW 261
76860: PUSH
76861: LD_INT 15
76863: LESS
76864: AND
76865: IFFALSE 76869
// continue ;
76867: GO 76720
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
76869: LD_VAR 0 3
76873: PPUSH
76874: CALL_OW 262
76878: PUSH
76879: LD_INT 1
76881: EQUAL
76882: PUSH
76883: LD_VAR 0 3
76887: PPUSH
76888: CALL_OW 261
76892: PUSH
76893: LD_INT 10
76895: LESS
76896: AND
76897: IFFALSE 77226
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76899: LD_ADDR_VAR 0 8
76903: PUSH
76904: LD_EXP 86
76908: PUSH
76909: LD_VAR 0 2
76913: ARRAY
76914: PPUSH
76915: LD_INT 2
76917: PUSH
76918: LD_INT 30
76920: PUSH
76921: LD_INT 0
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 30
76930: PUSH
76931: LD_INT 1
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PUSH
76938: EMPTY
76939: LIST
76940: LIST
76941: LIST
76942: PPUSH
76943: CALL_OW 72
76947: ST_TO_ADDR
// if not depot then
76948: LD_VAR 0 8
76952: NOT
76953: IFFALSE 76957
// continue ;
76955: GO 76720
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
76957: LD_VAR 0 3
76961: PPUSH
76962: LD_VAR 0 8
76966: PPUSH
76967: LD_VAR 0 3
76971: PPUSH
76972: CALL_OW 74
76976: PPUSH
76977: CALL_OW 296
76981: PUSH
76982: LD_INT 6
76984: LESS
76985: IFFALSE 77001
// SetFuel ( j , 100 ) else
76987: LD_VAR 0 3
76991: PPUSH
76992: LD_INT 100
76994: PPUSH
76995: CALL_OW 240
76999: GO 77226
// if GetFuel ( j ) = 0 then
77001: LD_VAR 0 3
77005: PPUSH
77006: CALL_OW 261
77010: PUSH
77011: LD_INT 0
77013: EQUAL
77014: IFFALSE 77226
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
77016: LD_ADDR_EXP 105
77020: PUSH
77021: LD_EXP 105
77025: PPUSH
77026: LD_VAR 0 2
77030: PPUSH
77031: LD_EXP 105
77035: PUSH
77036: LD_VAR 0 2
77040: ARRAY
77041: PUSH
77042: LD_VAR 0 3
77046: DIFF
77047: PPUSH
77048: CALL_OW 1
77052: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
77053: LD_VAR 0 3
77057: PPUSH
77058: CALL_OW 263
77062: PUSH
77063: LD_INT 1
77065: EQUAL
77066: IFFALSE 77082
// ComExitVehicle ( IsInUnit ( j ) ) ;
77068: LD_VAR 0 3
77072: PPUSH
77073: CALL_OW 310
77077: PPUSH
77078: CALL_OW 121
// if GetControl ( j ) = control_remote then
77082: LD_VAR 0 3
77086: PPUSH
77087: CALL_OW 263
77091: PUSH
77092: LD_INT 2
77094: EQUAL
77095: IFFALSE 77106
// ComUnlink ( j ) ;
77097: LD_VAR 0 3
77101: PPUSH
77102: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
77106: LD_ADDR_VAR 0 9
77110: PUSH
77111: LD_VAR 0 2
77115: PPUSH
77116: LD_INT 3
77118: PPUSH
77119: CALL 86696 0 2
77123: ST_TO_ADDR
// if fac then
77124: LD_VAR 0 9
77128: IFFALSE 77224
// begin for k in fac do
77130: LD_ADDR_VAR 0 4
77134: PUSH
77135: LD_VAR 0 9
77139: PUSH
77140: FOR_IN
77141: IFFALSE 77222
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
77143: LD_ADDR_VAR 0 10
77147: PUSH
77148: LD_VAR 0 9
77152: PPUSH
77153: LD_VAR 0 3
77157: PPUSH
77158: CALL_OW 265
77162: PPUSH
77163: LD_VAR 0 3
77167: PPUSH
77168: CALL_OW 262
77172: PPUSH
77173: LD_VAR 0 3
77177: PPUSH
77178: CALL_OW 263
77182: PPUSH
77183: LD_VAR 0 3
77187: PPUSH
77188: CALL_OW 264
77192: PPUSH
77193: CALL 19983 0 5
77197: ST_TO_ADDR
// if components then
77198: LD_VAR 0 10
77202: IFFALSE 77220
// begin MC_InsertProduceList ( i , components ) ;
77204: LD_VAR 0 2
77208: PPUSH
77209: LD_VAR 0 10
77213: PPUSH
77214: CALL 86241 0 2
// break ;
77218: GO 77222
// end ; end ;
77220: GO 77140
77222: POP
77223: POP
// end ; continue ;
77224: GO 76720
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
77226: LD_VAR 0 3
77230: PPUSH
77231: LD_INT 1
77233: PPUSH
77234: CALL_OW 289
77238: PUSH
77239: LD_INT 100
77241: LESS
77242: PUSH
77243: LD_VAR 0 3
77247: PPUSH
77248: CALL_OW 314
77252: NOT
77253: AND
77254: IFFALSE 77283
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
77256: LD_VAR 0 3
77260: PPUSH
77261: LD_VAR 0 6
77265: PUSH
77266: LD_INT 2
77268: ARRAY
77269: PPUSH
77270: LD_VAR 0 6
77274: PUSH
77275: LD_INT 3
77277: ARRAY
77278: PPUSH
77279: CALL_OW 117
// break ;
77283: GO 77287
// end ;
77285: GO 76720
77287: POP
77288: POP
// end ; end ;
77289: GO 75558
77291: POP
77292: POP
// end ;
77293: LD_VAR 0 1
77297: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
77298: LD_INT 0
77300: PPUSH
77301: PPUSH
77302: PPUSH
77303: PPUSH
// if not mc_bases then
77304: LD_EXP 86
77308: NOT
77309: IFFALSE 77313
// exit ;
77311: GO 77474
// for i = 1 to mc_bases do
77313: LD_ADDR_VAR 0 2
77317: PUSH
77318: DOUBLE
77319: LD_INT 1
77321: DEC
77322: ST_TO_ADDR
77323: LD_EXP 86
77327: PUSH
77328: FOR_TO
77329: IFFALSE 77472
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
77331: LD_ADDR_VAR 0 4
77335: PUSH
77336: LD_EXP 105
77340: PUSH
77341: LD_VAR 0 2
77345: ARRAY
77346: PUSH
77347: LD_EXP 108
77351: PUSH
77352: LD_VAR 0 2
77356: ARRAY
77357: UNION
77358: PPUSH
77359: LD_INT 33
77361: PUSH
77362: LD_INT 2
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PPUSH
77369: CALL_OW 72
77373: ST_TO_ADDR
// if tmp then
77374: LD_VAR 0 4
77378: IFFALSE 77470
// for j in tmp do
77380: LD_ADDR_VAR 0 3
77384: PUSH
77385: LD_VAR 0 4
77389: PUSH
77390: FOR_IN
77391: IFFALSE 77468
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
77393: LD_VAR 0 3
77397: PPUSH
77398: CALL_OW 312
77402: NOT
77403: PUSH
77404: LD_VAR 0 3
77408: PPUSH
77409: CALL_OW 256
77413: PUSH
77414: LD_INT 250
77416: GREATEREQUAL
77417: AND
77418: IFFALSE 77431
// Connect ( j ) else
77420: LD_VAR 0 3
77424: PPUSH
77425: CALL 25416 0 1
77429: GO 77466
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
77431: LD_VAR 0 3
77435: PPUSH
77436: CALL_OW 256
77440: PUSH
77441: LD_INT 250
77443: LESS
77444: PUSH
77445: LD_VAR 0 3
77449: PPUSH
77450: CALL_OW 312
77454: AND
77455: IFFALSE 77466
// ComUnlink ( j ) ;
77457: LD_VAR 0 3
77461: PPUSH
77462: CALL_OW 136
77466: GO 77390
77468: POP
77469: POP
// end ;
77470: GO 77328
77472: POP
77473: POP
// end ;
77474: LD_VAR 0 1
77478: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
77479: LD_INT 0
77481: PPUSH
77482: PPUSH
77483: PPUSH
77484: PPUSH
77485: PPUSH
// if not mc_bases then
77486: LD_EXP 86
77490: NOT
77491: IFFALSE 77495
// exit ;
77493: GO 77940
// for i = 1 to mc_bases do
77495: LD_ADDR_VAR 0 2
77499: PUSH
77500: DOUBLE
77501: LD_INT 1
77503: DEC
77504: ST_TO_ADDR
77505: LD_EXP 86
77509: PUSH
77510: FOR_TO
77511: IFFALSE 77938
// begin if not mc_produce [ i ] then
77513: LD_EXP 107
77517: PUSH
77518: LD_VAR 0 2
77522: ARRAY
77523: NOT
77524: IFFALSE 77528
// continue ;
77526: GO 77510
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
77528: LD_ADDR_VAR 0 5
77532: PUSH
77533: LD_EXP 86
77537: PUSH
77538: LD_VAR 0 2
77542: ARRAY
77543: PPUSH
77544: LD_INT 30
77546: PUSH
77547: LD_INT 3
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: PPUSH
77554: CALL_OW 72
77558: ST_TO_ADDR
// if not fac then
77559: LD_VAR 0 5
77563: NOT
77564: IFFALSE 77568
// continue ;
77566: GO 77510
// for j in fac do
77568: LD_ADDR_VAR 0 3
77572: PUSH
77573: LD_VAR 0 5
77577: PUSH
77578: FOR_IN
77579: IFFALSE 77934
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
77581: LD_VAR 0 3
77585: PPUSH
77586: CALL_OW 461
77590: PUSH
77591: LD_INT 2
77593: NONEQUAL
77594: PUSH
77595: LD_VAR 0 3
77599: PPUSH
77600: LD_INT 15
77602: PPUSH
77603: CALL 25044 0 2
77607: PUSH
77608: LD_INT 4
77610: ARRAY
77611: OR
77612: IFFALSE 77616
// continue ;
77614: GO 77578
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
77616: LD_VAR 0 3
77620: PPUSH
77621: LD_EXP 107
77625: PUSH
77626: LD_VAR 0 2
77630: ARRAY
77631: PUSH
77632: LD_INT 1
77634: ARRAY
77635: PUSH
77636: LD_INT 1
77638: ARRAY
77639: PPUSH
77640: LD_EXP 107
77644: PUSH
77645: LD_VAR 0 2
77649: ARRAY
77650: PUSH
77651: LD_INT 1
77653: ARRAY
77654: PUSH
77655: LD_INT 2
77657: ARRAY
77658: PPUSH
77659: LD_EXP 107
77663: PUSH
77664: LD_VAR 0 2
77668: ARRAY
77669: PUSH
77670: LD_INT 1
77672: ARRAY
77673: PUSH
77674: LD_INT 3
77676: ARRAY
77677: PPUSH
77678: LD_EXP 107
77682: PUSH
77683: LD_VAR 0 2
77687: ARRAY
77688: PUSH
77689: LD_INT 1
77691: ARRAY
77692: PUSH
77693: LD_INT 4
77695: ARRAY
77696: PPUSH
77697: CALL_OW 448
77701: PUSH
77702: LD_VAR 0 3
77706: PPUSH
77707: LD_EXP 107
77711: PUSH
77712: LD_VAR 0 2
77716: ARRAY
77717: PUSH
77718: LD_INT 1
77720: ARRAY
77721: PUSH
77722: LD_INT 1
77724: ARRAY
77725: PUSH
77726: LD_EXP 107
77730: PUSH
77731: LD_VAR 0 2
77735: ARRAY
77736: PUSH
77737: LD_INT 1
77739: ARRAY
77740: PUSH
77741: LD_INT 2
77743: ARRAY
77744: PUSH
77745: LD_EXP 107
77749: PUSH
77750: LD_VAR 0 2
77754: ARRAY
77755: PUSH
77756: LD_INT 1
77758: ARRAY
77759: PUSH
77760: LD_INT 3
77762: ARRAY
77763: PUSH
77764: LD_EXP 107
77768: PUSH
77769: LD_VAR 0 2
77773: ARRAY
77774: PUSH
77775: LD_INT 1
77777: ARRAY
77778: PUSH
77779: LD_INT 4
77781: ARRAY
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: LIST
77787: LIST
77788: PPUSH
77789: CALL 28842 0 2
77793: AND
77794: IFFALSE 77932
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
77796: LD_VAR 0 3
77800: PPUSH
77801: LD_EXP 107
77805: PUSH
77806: LD_VAR 0 2
77810: ARRAY
77811: PUSH
77812: LD_INT 1
77814: ARRAY
77815: PUSH
77816: LD_INT 1
77818: ARRAY
77819: PPUSH
77820: LD_EXP 107
77824: PUSH
77825: LD_VAR 0 2
77829: ARRAY
77830: PUSH
77831: LD_INT 1
77833: ARRAY
77834: PUSH
77835: LD_INT 2
77837: ARRAY
77838: PPUSH
77839: LD_EXP 107
77843: PUSH
77844: LD_VAR 0 2
77848: ARRAY
77849: PUSH
77850: LD_INT 1
77852: ARRAY
77853: PUSH
77854: LD_INT 3
77856: ARRAY
77857: PPUSH
77858: LD_EXP 107
77862: PUSH
77863: LD_VAR 0 2
77867: ARRAY
77868: PUSH
77869: LD_INT 1
77871: ARRAY
77872: PUSH
77873: LD_INT 4
77875: ARRAY
77876: PPUSH
77877: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
77881: LD_ADDR_VAR 0 4
77885: PUSH
77886: LD_EXP 107
77890: PUSH
77891: LD_VAR 0 2
77895: ARRAY
77896: PPUSH
77897: LD_INT 1
77899: PPUSH
77900: CALL_OW 3
77904: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77905: LD_ADDR_EXP 107
77909: PUSH
77910: LD_EXP 107
77914: PPUSH
77915: LD_VAR 0 2
77919: PPUSH
77920: LD_VAR 0 4
77924: PPUSH
77925: CALL_OW 1
77929: ST_TO_ADDR
// break ;
77930: GO 77934
// end ; end ;
77932: GO 77578
77934: POP
77935: POP
// end ;
77936: GO 77510
77938: POP
77939: POP
// end ;
77940: LD_VAR 0 1
77944: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
77945: LD_INT 0
77947: PPUSH
77948: PPUSH
77949: PPUSH
// if not mc_bases then
77950: LD_EXP 86
77954: NOT
77955: IFFALSE 77959
// exit ;
77957: GO 78048
// for i = 1 to mc_bases do
77959: LD_ADDR_VAR 0 2
77963: PUSH
77964: DOUBLE
77965: LD_INT 1
77967: DEC
77968: ST_TO_ADDR
77969: LD_EXP 86
77973: PUSH
77974: FOR_TO
77975: IFFALSE 78046
// begin if mc_attack [ i ] then
77977: LD_EXP 106
77981: PUSH
77982: LD_VAR 0 2
77986: ARRAY
77987: IFFALSE 78044
// begin tmp := mc_attack [ i ] [ 1 ] ;
77989: LD_ADDR_VAR 0 3
77993: PUSH
77994: LD_EXP 106
77998: PUSH
77999: LD_VAR 0 2
78003: ARRAY
78004: PUSH
78005: LD_INT 1
78007: ARRAY
78008: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
78009: LD_ADDR_EXP 106
78013: PUSH
78014: LD_EXP 106
78018: PPUSH
78019: LD_VAR 0 2
78023: PPUSH
78024: EMPTY
78025: PPUSH
78026: CALL_OW 1
78030: ST_TO_ADDR
// Attack ( tmp ) ;
78031: LD_VAR 0 3
78035: PPUSH
78036: CALL 55161 0 1
// exit ;
78040: POP
78041: POP
78042: GO 78048
// end ; end ;
78044: GO 77974
78046: POP
78047: POP
// end ;
78048: LD_VAR 0 1
78052: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
78053: LD_INT 0
78055: PPUSH
78056: PPUSH
78057: PPUSH
78058: PPUSH
78059: PPUSH
78060: PPUSH
78061: PPUSH
// if not mc_bases then
78062: LD_EXP 86
78066: NOT
78067: IFFALSE 78071
// exit ;
78069: GO 78770
// for i = 1 to mc_bases do
78071: LD_ADDR_VAR 0 2
78075: PUSH
78076: DOUBLE
78077: LD_INT 1
78079: DEC
78080: ST_TO_ADDR
78081: LD_EXP 86
78085: PUSH
78086: FOR_TO
78087: IFFALSE 78768
// begin if not mc_bases [ i ] then
78089: LD_EXP 86
78093: PUSH
78094: LD_VAR 0 2
78098: ARRAY
78099: NOT
78100: IFFALSE 78104
// continue ;
78102: GO 78086
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
78104: LD_ADDR_VAR 0 7
78108: PUSH
78109: LD_EXP 86
78113: PUSH
78114: LD_VAR 0 2
78118: ARRAY
78119: PUSH
78120: LD_INT 1
78122: ARRAY
78123: PPUSH
78124: CALL 19287 0 1
78128: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
78129: LD_ADDR_EXP 109
78133: PUSH
78134: LD_EXP 109
78138: PPUSH
78139: LD_VAR 0 2
78143: PPUSH
78144: LD_EXP 86
78148: PUSH
78149: LD_VAR 0 2
78153: ARRAY
78154: PUSH
78155: LD_INT 1
78157: ARRAY
78158: PPUSH
78159: CALL_OW 255
78163: PPUSH
78164: LD_EXP 111
78168: PUSH
78169: LD_VAR 0 2
78173: ARRAY
78174: PPUSH
78175: CALL 19252 0 2
78179: PPUSH
78180: CALL_OW 1
78184: ST_TO_ADDR
// if not mc_scan [ i ] then
78185: LD_EXP 109
78189: PUSH
78190: LD_VAR 0 2
78194: ARRAY
78195: NOT
78196: IFFALSE 78374
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
78198: LD_ADDR_VAR 0 4
78202: PUSH
78203: LD_EXP 86
78207: PUSH
78208: LD_VAR 0 2
78212: ARRAY
78213: PPUSH
78214: LD_INT 2
78216: PUSH
78217: LD_INT 25
78219: PUSH
78220: LD_INT 5
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 25
78229: PUSH
78230: LD_INT 8
78232: PUSH
78233: EMPTY
78234: LIST
78235: LIST
78236: PUSH
78237: LD_INT 25
78239: PUSH
78240: LD_INT 9
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: LIST
78251: LIST
78252: PPUSH
78253: CALL_OW 72
78257: ST_TO_ADDR
// if not tmp then
78258: LD_VAR 0 4
78262: NOT
78263: IFFALSE 78267
// continue ;
78265: GO 78086
// for j in tmp do
78267: LD_ADDR_VAR 0 3
78271: PUSH
78272: LD_VAR 0 4
78276: PUSH
78277: FOR_IN
78278: IFFALSE 78349
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
78280: LD_VAR 0 3
78284: PPUSH
78285: CALL_OW 310
78289: PPUSH
78290: CALL_OW 266
78294: PUSH
78295: LD_INT 5
78297: EQUAL
78298: PUSH
78299: LD_VAR 0 3
78303: PPUSH
78304: CALL_OW 257
78308: PUSH
78309: LD_INT 1
78311: EQUAL
78312: AND
78313: PUSH
78314: LD_VAR 0 3
78318: PPUSH
78319: CALL_OW 459
78323: NOT
78324: AND
78325: PUSH
78326: LD_VAR 0 7
78330: AND
78331: IFFALSE 78347
// ComChangeProfession ( j , class ) ;
78333: LD_VAR 0 3
78337: PPUSH
78338: LD_VAR 0 7
78342: PPUSH
78343: CALL_OW 123
78347: GO 78277
78349: POP
78350: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
78351: LD_ADDR_EXP 129
78355: PUSH
78356: LD_EXP 129
78360: PPUSH
78361: LD_VAR 0 2
78365: PPUSH
78366: LD_INT 0
78368: PPUSH
78369: CALL_OW 1
78373: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
78374: LD_EXP 109
78378: PUSH
78379: LD_VAR 0 2
78383: ARRAY
78384: PUSH
78385: LD_EXP 129
78389: PUSH
78390: LD_VAR 0 2
78394: ARRAY
78395: NOT
78396: AND
78397: PUSH
78398: LD_EXP 108
78402: PUSH
78403: LD_VAR 0 2
78407: ARRAY
78408: NOT
78409: AND
78410: PUSH
78411: LD_EXP 86
78415: PUSH
78416: LD_VAR 0 2
78420: ARRAY
78421: PPUSH
78422: LD_INT 30
78424: PUSH
78425: LD_INT 32
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: PPUSH
78432: CALL_OW 72
78436: NOT
78437: AND
78438: PUSH
78439: LD_EXP 86
78443: PUSH
78444: LD_VAR 0 2
78448: ARRAY
78449: PPUSH
78450: LD_INT 2
78452: PUSH
78453: LD_INT 30
78455: PUSH
78456: LD_INT 4
78458: PUSH
78459: EMPTY
78460: LIST
78461: LIST
78462: PUSH
78463: LD_INT 30
78465: PUSH
78466: LD_INT 5
78468: PUSH
78469: EMPTY
78470: LIST
78471: LIST
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: LIST
78477: PPUSH
78478: CALL_OW 72
78482: NOT
78483: AND
78484: IFFALSE 78639
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
78486: LD_ADDR_VAR 0 4
78490: PUSH
78491: LD_EXP 86
78495: PUSH
78496: LD_VAR 0 2
78500: ARRAY
78501: PPUSH
78502: LD_INT 2
78504: PUSH
78505: LD_INT 25
78507: PUSH
78508: LD_INT 1
78510: PUSH
78511: EMPTY
78512: LIST
78513: LIST
78514: PUSH
78515: LD_INT 25
78517: PUSH
78518: LD_INT 5
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 25
78527: PUSH
78528: LD_INT 8
78530: PUSH
78531: EMPTY
78532: LIST
78533: LIST
78534: PUSH
78535: LD_INT 25
78537: PUSH
78538: LD_INT 9
78540: PUSH
78541: EMPTY
78542: LIST
78543: LIST
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: PPUSH
78552: CALL_OW 72
78556: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
78557: LD_ADDR_VAR 0 4
78561: PUSH
78562: LD_VAR 0 4
78566: PUSH
78567: LD_VAR 0 4
78571: PPUSH
78572: LD_INT 18
78574: PPUSH
78575: CALL 51345 0 2
78579: DIFF
78580: ST_TO_ADDR
// if tmp then
78581: LD_VAR 0 4
78585: IFFALSE 78639
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
78587: LD_ADDR_EXP 129
78591: PUSH
78592: LD_EXP 129
78596: PPUSH
78597: LD_VAR 0 2
78601: PPUSH
78602: LD_INT 1
78604: PPUSH
78605: CALL_OW 1
78609: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
78610: LD_VAR 0 2
78614: PPUSH
78615: LD_VAR 0 4
78619: PPUSH
78620: LD_EXP 111
78624: PUSH
78625: LD_VAR 0 2
78629: ARRAY
78630: PPUSH
78631: CALL 59870 0 3
// exit ;
78635: POP
78636: POP
78637: GO 78770
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
78639: LD_EXP 109
78643: PUSH
78644: LD_VAR 0 2
78648: ARRAY
78649: PUSH
78650: LD_EXP 129
78654: PUSH
78655: LD_VAR 0 2
78659: ARRAY
78660: NOT
78661: AND
78662: PUSH
78663: LD_EXP 108
78667: PUSH
78668: LD_VAR 0 2
78672: ARRAY
78673: AND
78674: IFFALSE 78766
// begin tmp := mc_defender [ i ] ;
78676: LD_ADDR_VAR 0 4
78680: PUSH
78681: LD_EXP 108
78685: PUSH
78686: LD_VAR 0 2
78690: ARRAY
78691: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
78692: LD_ADDR_EXP 108
78696: PUSH
78697: LD_EXP 108
78701: PPUSH
78702: LD_VAR 0 2
78706: PPUSH
78707: EMPTY
78708: PPUSH
78709: CALL_OW 1
78713: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
78714: LD_ADDR_EXP 129
78718: PUSH
78719: LD_EXP 129
78723: PPUSH
78724: LD_VAR 0 2
78728: PPUSH
78729: LD_INT 1
78731: PPUSH
78732: CALL_OW 1
78736: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
78737: LD_VAR 0 2
78741: PPUSH
78742: LD_VAR 0 4
78746: PPUSH
78747: LD_EXP 109
78751: PUSH
78752: LD_VAR 0 2
78756: ARRAY
78757: PPUSH
78758: CALL 60431 0 3
// exit ;
78762: POP
78763: POP
78764: GO 78770
// end ; end ;
78766: GO 78086
78768: POP
78769: POP
// end ;
78770: LD_VAR 0 1
78774: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
78775: LD_INT 0
78777: PPUSH
78778: PPUSH
78779: PPUSH
78780: PPUSH
78781: PPUSH
78782: PPUSH
78783: PPUSH
78784: PPUSH
78785: PPUSH
78786: PPUSH
78787: PPUSH
// if not mc_bases then
78788: LD_EXP 86
78792: NOT
78793: IFFALSE 78797
// exit ;
78795: GO 79884
// for i = 1 to mc_bases do
78797: LD_ADDR_VAR 0 2
78801: PUSH
78802: DOUBLE
78803: LD_INT 1
78805: DEC
78806: ST_TO_ADDR
78807: LD_EXP 86
78811: PUSH
78812: FOR_TO
78813: IFFALSE 79882
// begin tmp := mc_lab [ i ] ;
78815: LD_ADDR_VAR 0 6
78819: PUSH
78820: LD_EXP 119
78824: PUSH
78825: LD_VAR 0 2
78829: ARRAY
78830: ST_TO_ADDR
// if not tmp then
78831: LD_VAR 0 6
78835: NOT
78836: IFFALSE 78840
// continue ;
78838: GO 78812
// idle_lab := 0 ;
78840: LD_ADDR_VAR 0 11
78844: PUSH
78845: LD_INT 0
78847: ST_TO_ADDR
// for j in tmp do
78848: LD_ADDR_VAR 0 3
78852: PUSH
78853: LD_VAR 0 6
78857: PUSH
78858: FOR_IN
78859: IFFALSE 79878
// begin researching := false ;
78861: LD_ADDR_VAR 0 10
78865: PUSH
78866: LD_INT 0
78868: ST_TO_ADDR
// side := GetSide ( j ) ;
78869: LD_ADDR_VAR 0 4
78873: PUSH
78874: LD_VAR 0 3
78878: PPUSH
78879: CALL_OW 255
78883: ST_TO_ADDR
// if not mc_tech [ side ] then
78884: LD_EXP 113
78888: PUSH
78889: LD_VAR 0 4
78893: ARRAY
78894: NOT
78895: IFFALSE 78899
// continue ;
78897: GO 78858
// if BuildingStatus ( j ) = bs_idle then
78899: LD_VAR 0 3
78903: PPUSH
78904: CALL_OW 461
78908: PUSH
78909: LD_INT 2
78911: EQUAL
78912: IFFALSE 79100
// begin if idle_lab and UnitsInside ( j ) < 6 then
78914: LD_VAR 0 11
78918: PUSH
78919: LD_VAR 0 3
78923: PPUSH
78924: CALL_OW 313
78928: PUSH
78929: LD_INT 6
78931: LESS
78932: AND
78933: IFFALSE 79004
// begin tmp2 := UnitsInside ( idle_lab ) ;
78935: LD_ADDR_VAR 0 9
78939: PUSH
78940: LD_VAR 0 11
78944: PPUSH
78945: CALL_OW 313
78949: ST_TO_ADDR
// if tmp2 then
78950: LD_VAR 0 9
78954: IFFALSE 78996
// for x in tmp2 do
78956: LD_ADDR_VAR 0 7
78960: PUSH
78961: LD_VAR 0 9
78965: PUSH
78966: FOR_IN
78967: IFFALSE 78994
// begin ComExitBuilding ( x ) ;
78969: LD_VAR 0 7
78973: PPUSH
78974: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78978: LD_VAR 0 7
78982: PPUSH
78983: LD_VAR 0 3
78987: PPUSH
78988: CALL_OW 180
// end ;
78992: GO 78966
78994: POP
78995: POP
// idle_lab := 0 ;
78996: LD_ADDR_VAR 0 11
79000: PUSH
79001: LD_INT 0
79003: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
79004: LD_ADDR_VAR 0 5
79008: PUSH
79009: LD_EXP 113
79013: PUSH
79014: LD_VAR 0 4
79018: ARRAY
79019: PUSH
79020: FOR_IN
79021: IFFALSE 79081
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
79023: LD_VAR 0 3
79027: PPUSH
79028: LD_VAR 0 5
79032: PPUSH
79033: CALL_OW 430
79037: PUSH
79038: LD_VAR 0 4
79042: PPUSH
79043: LD_VAR 0 5
79047: PPUSH
79048: CALL 18357 0 2
79052: AND
79053: IFFALSE 79079
// begin researching := true ;
79055: LD_ADDR_VAR 0 10
79059: PUSH
79060: LD_INT 1
79062: ST_TO_ADDR
// ComResearch ( j , t ) ;
79063: LD_VAR 0 3
79067: PPUSH
79068: LD_VAR 0 5
79072: PPUSH
79073: CALL_OW 124
// break ;
79077: GO 79081
// end ;
79079: GO 79020
79081: POP
79082: POP
// if not researching then
79083: LD_VAR 0 10
79087: NOT
79088: IFFALSE 79100
// idle_lab := j ;
79090: LD_ADDR_VAR 0 11
79094: PUSH
79095: LD_VAR 0 3
79099: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
79100: LD_VAR 0 3
79104: PPUSH
79105: CALL_OW 461
79109: PUSH
79110: LD_INT 10
79112: EQUAL
79113: IFFALSE 79701
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
79115: LD_EXP 115
79119: PUSH
79120: LD_VAR 0 2
79124: ARRAY
79125: NOT
79126: PUSH
79127: LD_EXP 116
79131: PUSH
79132: LD_VAR 0 2
79136: ARRAY
79137: NOT
79138: AND
79139: PUSH
79140: LD_EXP 113
79144: PUSH
79145: LD_VAR 0 4
79149: ARRAY
79150: PUSH
79151: LD_INT 1
79153: GREATER
79154: AND
79155: IFFALSE 79286
// begin ComCancel ( j ) ;
79157: LD_VAR 0 3
79161: PPUSH
79162: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
79166: LD_ADDR_EXP 113
79170: PUSH
79171: LD_EXP 113
79175: PPUSH
79176: LD_VAR 0 4
79180: PPUSH
79181: LD_EXP 113
79185: PUSH
79186: LD_VAR 0 4
79190: ARRAY
79191: PPUSH
79192: LD_EXP 113
79196: PUSH
79197: LD_VAR 0 4
79201: ARRAY
79202: PUSH
79203: LD_INT 1
79205: MINUS
79206: PPUSH
79207: LD_EXP 113
79211: PUSH
79212: LD_VAR 0 4
79216: ARRAY
79217: PPUSH
79218: LD_INT 0
79220: PPUSH
79221: CALL 21869 0 4
79225: PPUSH
79226: CALL_OW 1
79230: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
79231: LD_ADDR_EXP 113
79235: PUSH
79236: LD_EXP 113
79240: PPUSH
79241: LD_VAR 0 4
79245: PPUSH
79246: LD_EXP 113
79250: PUSH
79251: LD_VAR 0 4
79255: ARRAY
79256: PPUSH
79257: LD_EXP 113
79261: PUSH
79262: LD_VAR 0 4
79266: ARRAY
79267: PPUSH
79268: LD_INT 1
79270: PPUSH
79271: LD_INT 0
79273: PPUSH
79274: CALL 21869 0 4
79278: PPUSH
79279: CALL_OW 1
79283: ST_TO_ADDR
// continue ;
79284: GO 78858
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
79286: LD_EXP 115
79290: PUSH
79291: LD_VAR 0 2
79295: ARRAY
79296: PUSH
79297: LD_EXP 116
79301: PUSH
79302: LD_VAR 0 2
79306: ARRAY
79307: NOT
79308: AND
79309: IFFALSE 79436
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
79311: LD_ADDR_EXP 116
79315: PUSH
79316: LD_EXP 116
79320: PPUSH
79321: LD_VAR 0 2
79325: PUSH
79326: LD_EXP 116
79330: PUSH
79331: LD_VAR 0 2
79335: ARRAY
79336: PUSH
79337: LD_INT 1
79339: PLUS
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PPUSH
79345: LD_EXP 115
79349: PUSH
79350: LD_VAR 0 2
79354: ARRAY
79355: PUSH
79356: LD_INT 1
79358: ARRAY
79359: PPUSH
79360: CALL 22451 0 3
79364: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
79365: LD_EXP 115
79369: PUSH
79370: LD_VAR 0 2
79374: ARRAY
79375: PUSH
79376: LD_INT 1
79378: ARRAY
79379: PPUSH
79380: LD_INT 112
79382: PPUSH
79383: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
79387: LD_ADDR_VAR 0 9
79391: PUSH
79392: LD_EXP 115
79396: PUSH
79397: LD_VAR 0 2
79401: ARRAY
79402: PPUSH
79403: LD_INT 1
79405: PPUSH
79406: CALL_OW 3
79410: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
79411: LD_ADDR_EXP 115
79415: PUSH
79416: LD_EXP 115
79420: PPUSH
79421: LD_VAR 0 2
79425: PPUSH
79426: LD_VAR 0 9
79430: PPUSH
79431: CALL_OW 1
79435: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
79436: LD_EXP 115
79440: PUSH
79441: LD_VAR 0 2
79445: ARRAY
79446: PUSH
79447: LD_EXP 116
79451: PUSH
79452: LD_VAR 0 2
79456: ARRAY
79457: AND
79458: PUSH
79459: LD_EXP 116
79463: PUSH
79464: LD_VAR 0 2
79468: ARRAY
79469: PUSH
79470: LD_INT 1
79472: ARRAY
79473: PPUSH
79474: CALL_OW 310
79478: NOT
79479: AND
79480: PUSH
79481: LD_VAR 0 3
79485: PPUSH
79486: CALL_OW 313
79490: PUSH
79491: LD_INT 6
79493: EQUAL
79494: AND
79495: IFFALSE 79551
// begin tmp2 := UnitsInside ( j ) ;
79497: LD_ADDR_VAR 0 9
79501: PUSH
79502: LD_VAR 0 3
79506: PPUSH
79507: CALL_OW 313
79511: ST_TO_ADDR
// if tmp2 = 6 then
79512: LD_VAR 0 9
79516: PUSH
79517: LD_INT 6
79519: EQUAL
79520: IFFALSE 79551
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
79522: LD_VAR 0 9
79526: PUSH
79527: LD_INT 1
79529: ARRAY
79530: PPUSH
79531: LD_INT 112
79533: PPUSH
79534: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
79538: LD_VAR 0 9
79542: PUSH
79543: LD_INT 1
79545: ARRAY
79546: PPUSH
79547: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
79551: LD_EXP 116
79555: PUSH
79556: LD_VAR 0 2
79560: ARRAY
79561: PUSH
79562: LD_EXP 116
79566: PUSH
79567: LD_VAR 0 2
79571: ARRAY
79572: PUSH
79573: LD_INT 1
79575: ARRAY
79576: PPUSH
79577: CALL_OW 314
79581: NOT
79582: AND
79583: PUSH
79584: LD_EXP 116
79588: PUSH
79589: LD_VAR 0 2
79593: ARRAY
79594: PUSH
79595: LD_INT 1
79597: ARRAY
79598: PPUSH
79599: CALL_OW 310
79603: NOT
79604: AND
79605: IFFALSE 79631
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
79607: LD_EXP 116
79611: PUSH
79612: LD_VAR 0 2
79616: ARRAY
79617: PUSH
79618: LD_INT 1
79620: ARRAY
79621: PPUSH
79622: LD_VAR 0 3
79626: PPUSH
79627: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
79631: LD_EXP 116
79635: PUSH
79636: LD_VAR 0 2
79640: ARRAY
79641: PUSH
79642: LD_INT 1
79644: ARRAY
79645: PPUSH
79646: CALL_OW 310
79650: PUSH
79651: LD_EXP 116
79655: PUSH
79656: LD_VAR 0 2
79660: ARRAY
79661: PUSH
79662: LD_INT 1
79664: ARRAY
79665: PPUSH
79666: CALL_OW 310
79670: PPUSH
79671: CALL_OW 461
79675: PUSH
79676: LD_INT 3
79678: NONEQUAL
79679: AND
79680: IFFALSE 79701
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
79682: LD_EXP 116
79686: PUSH
79687: LD_VAR 0 2
79691: ARRAY
79692: PUSH
79693: LD_INT 1
79695: ARRAY
79696: PPUSH
79697: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
79701: LD_VAR 0 3
79705: PPUSH
79706: CALL_OW 461
79710: PUSH
79711: LD_INT 6
79713: EQUAL
79714: PUSH
79715: LD_VAR 0 6
79719: PUSH
79720: LD_INT 1
79722: GREATER
79723: AND
79724: IFFALSE 79876
// begin sci := [ ] ;
79726: LD_ADDR_VAR 0 8
79730: PUSH
79731: EMPTY
79732: ST_TO_ADDR
// for x in ( tmp diff j ) do
79733: LD_ADDR_VAR 0 7
79737: PUSH
79738: LD_VAR 0 6
79742: PUSH
79743: LD_VAR 0 3
79747: DIFF
79748: PUSH
79749: FOR_IN
79750: IFFALSE 79802
// begin if sci = 6 then
79752: LD_VAR 0 8
79756: PUSH
79757: LD_INT 6
79759: EQUAL
79760: IFFALSE 79764
// break ;
79762: GO 79802
// if BuildingStatus ( x ) = bs_idle then
79764: LD_VAR 0 7
79768: PPUSH
79769: CALL_OW 461
79773: PUSH
79774: LD_INT 2
79776: EQUAL
79777: IFFALSE 79800
// sci := sci ^ UnitsInside ( x ) ;
79779: LD_ADDR_VAR 0 8
79783: PUSH
79784: LD_VAR 0 8
79788: PUSH
79789: LD_VAR 0 7
79793: PPUSH
79794: CALL_OW 313
79798: ADD
79799: ST_TO_ADDR
// end ;
79800: GO 79749
79802: POP
79803: POP
// if not sci then
79804: LD_VAR 0 8
79808: NOT
79809: IFFALSE 79813
// continue ;
79811: GO 78858
// for x in sci do
79813: LD_ADDR_VAR 0 7
79817: PUSH
79818: LD_VAR 0 8
79822: PUSH
79823: FOR_IN
79824: IFFALSE 79874
// if IsInUnit ( x ) and not HasTask ( x ) then
79826: LD_VAR 0 7
79830: PPUSH
79831: CALL_OW 310
79835: PUSH
79836: LD_VAR 0 7
79840: PPUSH
79841: CALL_OW 314
79845: NOT
79846: AND
79847: IFFALSE 79872
// begin ComExitBuilding ( x ) ;
79849: LD_VAR 0 7
79853: PPUSH
79854: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79858: LD_VAR 0 7
79862: PPUSH
79863: LD_VAR 0 3
79867: PPUSH
79868: CALL_OW 180
// end ;
79872: GO 79823
79874: POP
79875: POP
// end ; end ;
79876: GO 78858
79878: POP
79879: POP
// end ;
79880: GO 78812
79882: POP
79883: POP
// end ;
79884: LD_VAR 0 1
79888: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79889: LD_INT 0
79891: PPUSH
79892: PPUSH
// if not mc_bases then
79893: LD_EXP 86
79897: NOT
79898: IFFALSE 79902
// exit ;
79900: GO 79983
// for i = 1 to mc_bases do
79902: LD_ADDR_VAR 0 2
79906: PUSH
79907: DOUBLE
79908: LD_INT 1
79910: DEC
79911: ST_TO_ADDR
79912: LD_EXP 86
79916: PUSH
79917: FOR_TO
79918: IFFALSE 79981
// if mc_mines [ i ] and mc_miners [ i ] then
79920: LD_EXP 99
79924: PUSH
79925: LD_VAR 0 2
79929: ARRAY
79930: PUSH
79931: LD_EXP 100
79935: PUSH
79936: LD_VAR 0 2
79940: ARRAY
79941: AND
79942: IFFALSE 79979
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79944: LD_EXP 100
79948: PUSH
79949: LD_VAR 0 2
79953: ARRAY
79954: PUSH
79955: LD_INT 1
79957: ARRAY
79958: PPUSH
79959: CALL_OW 255
79963: PPUSH
79964: LD_EXP 99
79968: PUSH
79969: LD_VAR 0 2
79973: ARRAY
79974: PPUSH
79975: CALL 19440 0 2
79979: GO 79917
79981: POP
79982: POP
// end ;
79983: LD_VAR 0 1
79987: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79988: LD_INT 0
79990: PPUSH
79991: PPUSH
79992: PPUSH
79993: PPUSH
79994: PPUSH
79995: PPUSH
79996: PPUSH
79997: PPUSH
// if not mc_bases or not mc_parking then
79998: LD_EXP 86
80002: NOT
80003: PUSH
80004: LD_EXP 110
80008: NOT
80009: OR
80010: IFFALSE 80014
// exit ;
80012: GO 80713
// for i = 1 to mc_bases do
80014: LD_ADDR_VAR 0 2
80018: PUSH
80019: DOUBLE
80020: LD_INT 1
80022: DEC
80023: ST_TO_ADDR
80024: LD_EXP 86
80028: PUSH
80029: FOR_TO
80030: IFFALSE 80711
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
80032: LD_EXP 86
80036: PUSH
80037: LD_VAR 0 2
80041: ARRAY
80042: NOT
80043: PUSH
80044: LD_EXP 110
80048: PUSH
80049: LD_VAR 0 2
80053: ARRAY
80054: NOT
80055: OR
80056: IFFALSE 80060
// continue ;
80058: GO 80029
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
80060: LD_ADDR_VAR 0 5
80064: PUSH
80065: LD_EXP 86
80069: PUSH
80070: LD_VAR 0 2
80074: ARRAY
80075: PUSH
80076: LD_INT 1
80078: ARRAY
80079: PPUSH
80080: CALL_OW 255
80084: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
80085: LD_ADDR_VAR 0 6
80089: PUSH
80090: LD_EXP 86
80094: PUSH
80095: LD_VAR 0 2
80099: ARRAY
80100: PPUSH
80101: LD_INT 30
80103: PUSH
80104: LD_INT 3
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PPUSH
80111: CALL_OW 72
80115: ST_TO_ADDR
// if not fac then
80116: LD_VAR 0 6
80120: NOT
80121: IFFALSE 80172
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80123: LD_ADDR_VAR 0 6
80127: PUSH
80128: LD_EXP 86
80132: PUSH
80133: LD_VAR 0 2
80137: ARRAY
80138: PPUSH
80139: LD_INT 2
80141: PUSH
80142: LD_INT 30
80144: PUSH
80145: LD_INT 0
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 30
80154: PUSH
80155: LD_INT 1
80157: PUSH
80158: EMPTY
80159: LIST
80160: LIST
80161: PUSH
80162: EMPTY
80163: LIST
80164: LIST
80165: LIST
80166: PPUSH
80167: CALL_OW 72
80171: ST_TO_ADDR
// if not fac then
80172: LD_VAR 0 6
80176: NOT
80177: IFFALSE 80181
// continue ;
80179: GO 80029
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
80181: LD_ADDR_VAR 0 7
80185: PUSH
80186: LD_EXP 110
80190: PUSH
80191: LD_VAR 0 2
80195: ARRAY
80196: PPUSH
80197: LD_INT 22
80199: PUSH
80200: LD_VAR 0 5
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 21
80211: PUSH
80212: LD_INT 2
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 3
80221: PUSH
80222: LD_INT 24
80224: PUSH
80225: LD_INT 1000
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: LIST
80240: PPUSH
80241: CALL_OW 70
80245: ST_TO_ADDR
// for j in fac do
80246: LD_ADDR_VAR 0 3
80250: PUSH
80251: LD_VAR 0 6
80255: PUSH
80256: FOR_IN
80257: IFFALSE 80338
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
80259: LD_ADDR_VAR 0 7
80263: PUSH
80264: LD_VAR 0 7
80268: PUSH
80269: LD_INT 22
80271: PUSH
80272: LD_VAR 0 5
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 91
80283: PUSH
80284: LD_VAR 0 3
80288: PUSH
80289: LD_INT 15
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 21
80299: PUSH
80300: LD_INT 2
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: PUSH
80307: LD_INT 3
80309: PUSH
80310: LD_INT 24
80312: PUSH
80313: LD_INT 1000
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: LIST
80328: LIST
80329: PPUSH
80330: CALL_OW 69
80334: UNION
80335: ST_TO_ADDR
80336: GO 80256
80338: POP
80339: POP
// if not vehs then
80340: LD_VAR 0 7
80344: NOT
80345: IFFALSE 80371
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
80347: LD_ADDR_EXP 98
80351: PUSH
80352: LD_EXP 98
80356: PPUSH
80357: LD_VAR 0 2
80361: PPUSH
80362: EMPTY
80363: PPUSH
80364: CALL_OW 1
80368: ST_TO_ADDR
// continue ;
80369: GO 80029
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
80371: LD_ADDR_VAR 0 8
80375: PUSH
80376: LD_EXP 86
80380: PUSH
80381: LD_VAR 0 2
80385: ARRAY
80386: PPUSH
80387: LD_INT 30
80389: PUSH
80390: LD_INT 3
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PPUSH
80397: CALL_OW 72
80401: ST_TO_ADDR
// if tmp then
80402: LD_VAR 0 8
80406: IFFALSE 80509
// begin for j in tmp do
80408: LD_ADDR_VAR 0 3
80412: PUSH
80413: LD_VAR 0 8
80417: PUSH
80418: FOR_IN
80419: IFFALSE 80507
// for k in UnitsInside ( j ) do
80421: LD_ADDR_VAR 0 4
80425: PUSH
80426: LD_VAR 0 3
80430: PPUSH
80431: CALL_OW 313
80435: PUSH
80436: FOR_IN
80437: IFFALSE 80503
// if k then
80439: LD_VAR 0 4
80443: IFFALSE 80501
// if not k in mc_repair_vehicle [ i ] then
80445: LD_VAR 0 4
80449: PUSH
80450: LD_EXP 98
80454: PUSH
80455: LD_VAR 0 2
80459: ARRAY
80460: IN
80461: NOT
80462: IFFALSE 80501
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
80464: LD_ADDR_EXP 98
80468: PUSH
80469: LD_EXP 98
80473: PPUSH
80474: LD_VAR 0 2
80478: PPUSH
80479: LD_EXP 98
80483: PUSH
80484: LD_VAR 0 2
80488: ARRAY
80489: PUSH
80490: LD_VAR 0 4
80494: UNION
80495: PPUSH
80496: CALL_OW 1
80500: ST_TO_ADDR
80501: GO 80436
80503: POP
80504: POP
80505: GO 80418
80507: POP
80508: POP
// end ; if not mc_repair_vehicle [ i ] then
80509: LD_EXP 98
80513: PUSH
80514: LD_VAR 0 2
80518: ARRAY
80519: NOT
80520: IFFALSE 80524
// continue ;
80522: GO 80029
// for j in mc_repair_vehicle [ i ] do
80524: LD_ADDR_VAR 0 3
80528: PUSH
80529: LD_EXP 98
80533: PUSH
80534: LD_VAR 0 2
80538: ARRAY
80539: PUSH
80540: FOR_IN
80541: IFFALSE 80707
// begin if GetClass ( j ) <> 3 then
80543: LD_VAR 0 3
80547: PPUSH
80548: CALL_OW 257
80552: PUSH
80553: LD_INT 3
80555: NONEQUAL
80556: IFFALSE 80597
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
80558: LD_ADDR_EXP 98
80562: PUSH
80563: LD_EXP 98
80567: PPUSH
80568: LD_VAR 0 2
80572: PPUSH
80573: LD_EXP 98
80577: PUSH
80578: LD_VAR 0 2
80582: ARRAY
80583: PUSH
80584: LD_VAR 0 3
80588: DIFF
80589: PPUSH
80590: CALL_OW 1
80594: ST_TO_ADDR
// continue ;
80595: GO 80540
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
80597: LD_VAR 0 3
80601: PPUSH
80602: CALL_OW 311
80606: NOT
80607: PUSH
80608: LD_VAR 0 3
80612: PUSH
80613: LD_EXP 89
80617: PUSH
80618: LD_VAR 0 2
80622: ARRAY
80623: PUSH
80624: LD_INT 1
80626: ARRAY
80627: IN
80628: NOT
80629: AND
80630: PUSH
80631: LD_VAR 0 3
80635: PUSH
80636: LD_EXP 89
80640: PUSH
80641: LD_VAR 0 2
80645: ARRAY
80646: PUSH
80647: LD_INT 2
80649: ARRAY
80650: IN
80651: NOT
80652: AND
80653: IFFALSE 80705
// begin if IsInUnit ( j ) then
80655: LD_VAR 0 3
80659: PPUSH
80660: CALL_OW 310
80664: IFFALSE 80675
// ComExitBuilding ( j ) ;
80666: LD_VAR 0 3
80670: PPUSH
80671: CALL_OW 122
// if not HasTask ( j ) then
80675: LD_VAR 0 3
80679: PPUSH
80680: CALL_OW 314
80684: NOT
80685: IFFALSE 80705
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
80687: LD_VAR 0 3
80691: PPUSH
80692: LD_VAR 0 7
80696: PUSH
80697: LD_INT 1
80699: ARRAY
80700: PPUSH
80701: CALL_OW 189
// end ; end ;
80705: GO 80540
80707: POP
80708: POP
// end ;
80709: GO 80029
80711: POP
80712: POP
// end ;
80713: LD_VAR 0 1
80717: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
80718: LD_INT 0
80720: PPUSH
80721: PPUSH
80722: PPUSH
80723: PPUSH
80724: PPUSH
80725: PPUSH
80726: PPUSH
80727: PPUSH
80728: PPUSH
80729: PPUSH
80730: PPUSH
// if not mc_bases then
80731: LD_EXP 86
80735: NOT
80736: IFFALSE 80740
// exit ;
80738: GO 81542
// for i = 1 to mc_bases do
80740: LD_ADDR_VAR 0 2
80744: PUSH
80745: DOUBLE
80746: LD_INT 1
80748: DEC
80749: ST_TO_ADDR
80750: LD_EXP 86
80754: PUSH
80755: FOR_TO
80756: IFFALSE 81540
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
80758: LD_EXP 114
80762: PUSH
80763: LD_VAR 0 2
80767: ARRAY
80768: NOT
80769: PUSH
80770: LD_EXP 89
80774: PUSH
80775: LD_VAR 0 2
80779: ARRAY
80780: PUSH
80781: LD_INT 1
80783: ARRAY
80784: OR
80785: PUSH
80786: LD_EXP 89
80790: PUSH
80791: LD_VAR 0 2
80795: ARRAY
80796: PUSH
80797: LD_INT 2
80799: ARRAY
80800: OR
80801: PUSH
80802: LD_EXP 112
80806: PUSH
80807: LD_VAR 0 2
80811: ARRAY
80812: PPUSH
80813: LD_INT 1
80815: PPUSH
80816: CALL_OW 325
80820: NOT
80821: OR
80822: PUSH
80823: LD_EXP 109
80827: PUSH
80828: LD_VAR 0 2
80832: ARRAY
80833: OR
80834: IFFALSE 80838
// continue ;
80836: GO 80755
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80838: LD_ADDR_VAR 0 8
80842: PUSH
80843: LD_EXP 86
80847: PUSH
80848: LD_VAR 0 2
80852: ARRAY
80853: PPUSH
80854: LD_INT 25
80856: PUSH
80857: LD_INT 4
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PUSH
80864: LD_INT 50
80866: PUSH
80867: EMPTY
80868: LIST
80869: PUSH
80870: LD_INT 3
80872: PUSH
80873: LD_INT 60
80875: PUSH
80876: EMPTY
80877: LIST
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: LIST
80887: PPUSH
80888: CALL_OW 72
80892: PUSH
80893: LD_EXP 90
80897: PUSH
80898: LD_VAR 0 2
80902: ARRAY
80903: DIFF
80904: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80905: LD_ADDR_VAR 0 9
80909: PUSH
80910: LD_EXP 86
80914: PUSH
80915: LD_VAR 0 2
80919: ARRAY
80920: PPUSH
80921: LD_INT 2
80923: PUSH
80924: LD_INT 30
80926: PUSH
80927: LD_INT 0
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 30
80936: PUSH
80937: LD_INT 1
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: LIST
80948: PPUSH
80949: CALL_OW 72
80953: ST_TO_ADDR
// if not tmp or not dep then
80954: LD_VAR 0 8
80958: NOT
80959: PUSH
80960: LD_VAR 0 9
80964: NOT
80965: OR
80966: IFFALSE 80970
// continue ;
80968: GO 80755
// side := GetSide ( tmp [ 1 ] ) ;
80970: LD_ADDR_VAR 0 11
80974: PUSH
80975: LD_VAR 0 8
80979: PUSH
80980: LD_INT 1
80982: ARRAY
80983: PPUSH
80984: CALL_OW 255
80988: ST_TO_ADDR
// dep := dep [ 1 ] ;
80989: LD_ADDR_VAR 0 9
80993: PUSH
80994: LD_VAR 0 9
80998: PUSH
80999: LD_INT 1
81001: ARRAY
81002: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
81003: LD_ADDR_VAR 0 7
81007: PUSH
81008: LD_EXP 114
81012: PUSH
81013: LD_VAR 0 2
81017: ARRAY
81018: PPUSH
81019: LD_INT 22
81021: PUSH
81022: LD_INT 0
81024: PUSH
81025: EMPTY
81026: LIST
81027: LIST
81028: PUSH
81029: LD_INT 25
81031: PUSH
81032: LD_INT 12
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PPUSH
81043: CALL_OW 70
81047: PUSH
81048: LD_INT 22
81050: PUSH
81051: LD_INT 0
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 25
81060: PUSH
81061: LD_INT 12
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PUSH
81068: LD_INT 91
81070: PUSH
81071: LD_VAR 0 9
81075: PUSH
81076: LD_INT 20
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: LIST
81083: PUSH
81084: EMPTY
81085: LIST
81086: LIST
81087: LIST
81088: PPUSH
81089: CALL_OW 69
81093: UNION
81094: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
81095: LD_ADDR_VAR 0 10
81099: PUSH
81100: LD_EXP 114
81104: PUSH
81105: LD_VAR 0 2
81109: ARRAY
81110: PPUSH
81111: LD_INT 81
81113: PUSH
81114: LD_VAR 0 11
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PPUSH
81123: CALL_OW 70
81127: ST_TO_ADDR
// if not apes or danger_at_area then
81128: LD_VAR 0 7
81132: NOT
81133: PUSH
81134: LD_VAR 0 10
81138: OR
81139: IFFALSE 81189
// begin if mc_taming [ i ] then
81141: LD_EXP 117
81145: PUSH
81146: LD_VAR 0 2
81150: ARRAY
81151: IFFALSE 81187
// begin MC_Reset ( i , 121 ) ;
81153: LD_VAR 0 2
81157: PPUSH
81158: LD_INT 121
81160: PPUSH
81161: CALL 66476 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
81165: LD_ADDR_EXP 117
81169: PUSH
81170: LD_EXP 117
81174: PPUSH
81175: LD_VAR 0 2
81179: PPUSH
81180: EMPTY
81181: PPUSH
81182: CALL_OW 1
81186: ST_TO_ADDR
// end ; continue ;
81187: GO 80755
// end ; for j in tmp do
81189: LD_ADDR_VAR 0 3
81193: PUSH
81194: LD_VAR 0 8
81198: PUSH
81199: FOR_IN
81200: IFFALSE 81536
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
81202: LD_VAR 0 3
81206: PUSH
81207: LD_EXP 117
81211: PUSH
81212: LD_VAR 0 2
81216: ARRAY
81217: IN
81218: NOT
81219: PUSH
81220: LD_EXP 117
81224: PUSH
81225: LD_VAR 0 2
81229: ARRAY
81230: PUSH
81231: LD_INT 3
81233: LESS
81234: AND
81235: IFFALSE 81293
// begin SetTag ( j , 121 ) ;
81237: LD_VAR 0 3
81241: PPUSH
81242: LD_INT 121
81244: PPUSH
81245: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
81249: LD_ADDR_EXP 117
81253: PUSH
81254: LD_EXP 117
81258: PPUSH
81259: LD_VAR 0 2
81263: PUSH
81264: LD_EXP 117
81268: PUSH
81269: LD_VAR 0 2
81273: ARRAY
81274: PUSH
81275: LD_INT 1
81277: PLUS
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PPUSH
81283: LD_VAR 0 3
81287: PPUSH
81288: CALL 22451 0 3
81292: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
81293: LD_VAR 0 3
81297: PUSH
81298: LD_EXP 117
81302: PUSH
81303: LD_VAR 0 2
81307: ARRAY
81308: IN
81309: IFFALSE 81534
// begin if GetClass ( j ) <> 4 then
81311: LD_VAR 0 3
81315: PPUSH
81316: CALL_OW 257
81320: PUSH
81321: LD_INT 4
81323: NONEQUAL
81324: IFFALSE 81377
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
81326: LD_ADDR_EXP 117
81330: PUSH
81331: LD_EXP 117
81335: PPUSH
81336: LD_VAR 0 2
81340: PPUSH
81341: LD_EXP 117
81345: PUSH
81346: LD_VAR 0 2
81350: ARRAY
81351: PUSH
81352: LD_VAR 0 3
81356: DIFF
81357: PPUSH
81358: CALL_OW 1
81362: ST_TO_ADDR
// SetTag ( j , 0 ) ;
81363: LD_VAR 0 3
81367: PPUSH
81368: LD_INT 0
81370: PPUSH
81371: CALL_OW 109
// continue ;
81375: GO 81199
// end ; if IsInUnit ( j ) then
81377: LD_VAR 0 3
81381: PPUSH
81382: CALL_OW 310
81386: IFFALSE 81397
// ComExitBuilding ( j ) ;
81388: LD_VAR 0 3
81392: PPUSH
81393: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
81397: LD_ADDR_VAR 0 6
81401: PUSH
81402: LD_VAR 0 7
81406: PPUSH
81407: LD_VAR 0 3
81411: PPUSH
81412: CALL_OW 74
81416: ST_TO_ADDR
// if not ape then
81417: LD_VAR 0 6
81421: NOT
81422: IFFALSE 81426
// break ;
81424: GO 81536
// x := GetX ( ape ) ;
81426: LD_ADDR_VAR 0 4
81430: PUSH
81431: LD_VAR 0 6
81435: PPUSH
81436: CALL_OW 250
81440: ST_TO_ADDR
// y := GetY ( ape ) ;
81441: LD_ADDR_VAR 0 5
81445: PUSH
81446: LD_VAR 0 6
81450: PPUSH
81451: CALL_OW 251
81455: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
81456: LD_VAR 0 4
81460: PPUSH
81461: LD_VAR 0 5
81465: PPUSH
81466: CALL_OW 488
81470: NOT
81471: PUSH
81472: LD_VAR 0 11
81476: PPUSH
81477: LD_VAR 0 4
81481: PPUSH
81482: LD_VAR 0 5
81486: PPUSH
81487: LD_INT 20
81489: PPUSH
81490: CALL 23347 0 4
81494: PUSH
81495: LD_INT 4
81497: ARRAY
81498: OR
81499: IFFALSE 81503
// break ;
81501: GO 81536
// if not HasTask ( j ) then
81503: LD_VAR 0 3
81507: PPUSH
81508: CALL_OW 314
81512: NOT
81513: IFFALSE 81534
// ComTameXY ( j , x , y ) ;
81515: LD_VAR 0 3
81519: PPUSH
81520: LD_VAR 0 4
81524: PPUSH
81525: LD_VAR 0 5
81529: PPUSH
81530: CALL_OW 131
// end ; end ;
81534: GO 81199
81536: POP
81537: POP
// end ;
81538: GO 80755
81540: POP
81541: POP
// end ;
81542: LD_VAR 0 1
81546: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
81547: LD_INT 0
81549: PPUSH
81550: PPUSH
81551: PPUSH
81552: PPUSH
81553: PPUSH
81554: PPUSH
81555: PPUSH
81556: PPUSH
// if not mc_bases then
81557: LD_EXP 86
81561: NOT
81562: IFFALSE 81566
// exit ;
81564: GO 82192
// for i = 1 to mc_bases do
81566: LD_ADDR_VAR 0 2
81570: PUSH
81571: DOUBLE
81572: LD_INT 1
81574: DEC
81575: ST_TO_ADDR
81576: LD_EXP 86
81580: PUSH
81581: FOR_TO
81582: IFFALSE 82190
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
81584: LD_EXP 115
81588: PUSH
81589: LD_VAR 0 2
81593: ARRAY
81594: NOT
81595: PUSH
81596: LD_EXP 115
81600: PUSH
81601: LD_VAR 0 2
81605: ARRAY
81606: PPUSH
81607: LD_INT 25
81609: PUSH
81610: LD_INT 12
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PPUSH
81617: CALL_OW 72
81621: NOT
81622: OR
81623: IFFALSE 81627
// continue ;
81625: GO 81581
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
81627: LD_ADDR_VAR 0 5
81631: PUSH
81632: LD_EXP 115
81636: PUSH
81637: LD_VAR 0 2
81641: ARRAY
81642: PUSH
81643: LD_INT 1
81645: ARRAY
81646: PPUSH
81647: CALL_OW 255
81651: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
81652: LD_VAR 0 5
81656: PPUSH
81657: LD_INT 2
81659: PPUSH
81660: CALL_OW 325
81664: IFFALSE 81917
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81666: LD_ADDR_VAR 0 4
81670: PUSH
81671: LD_EXP 115
81675: PUSH
81676: LD_VAR 0 2
81680: ARRAY
81681: PPUSH
81682: LD_INT 25
81684: PUSH
81685: LD_INT 16
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PPUSH
81692: CALL_OW 72
81696: ST_TO_ADDR
// if tmp < 6 then
81697: LD_VAR 0 4
81701: PUSH
81702: LD_INT 6
81704: LESS
81705: IFFALSE 81917
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81707: LD_ADDR_VAR 0 6
81711: PUSH
81712: LD_EXP 86
81716: PUSH
81717: LD_VAR 0 2
81721: ARRAY
81722: PPUSH
81723: LD_INT 2
81725: PUSH
81726: LD_INT 30
81728: PUSH
81729: LD_INT 0
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 30
81738: PUSH
81739: LD_INT 1
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: LIST
81750: PPUSH
81751: CALL_OW 72
81755: ST_TO_ADDR
// if depot then
81756: LD_VAR 0 6
81760: IFFALSE 81917
// begin selected := 0 ;
81762: LD_ADDR_VAR 0 7
81766: PUSH
81767: LD_INT 0
81769: ST_TO_ADDR
// for j in depot do
81770: LD_ADDR_VAR 0 3
81774: PUSH
81775: LD_VAR 0 6
81779: PUSH
81780: FOR_IN
81781: IFFALSE 81812
// begin if UnitsInside ( j ) < 6 then
81783: LD_VAR 0 3
81787: PPUSH
81788: CALL_OW 313
81792: PUSH
81793: LD_INT 6
81795: LESS
81796: IFFALSE 81810
// begin selected := j ;
81798: LD_ADDR_VAR 0 7
81802: PUSH
81803: LD_VAR 0 3
81807: ST_TO_ADDR
// break ;
81808: GO 81812
// end ; end ;
81810: GO 81780
81812: POP
81813: POP
// if selected then
81814: LD_VAR 0 7
81818: IFFALSE 81917
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81820: LD_ADDR_VAR 0 3
81824: PUSH
81825: LD_EXP 115
81829: PUSH
81830: LD_VAR 0 2
81834: ARRAY
81835: PPUSH
81836: LD_INT 25
81838: PUSH
81839: LD_INT 12
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PPUSH
81846: CALL_OW 72
81850: PUSH
81851: FOR_IN
81852: IFFALSE 81915
// if not HasTask ( j ) then
81854: LD_VAR 0 3
81858: PPUSH
81859: CALL_OW 314
81863: NOT
81864: IFFALSE 81913
// begin if not IsInUnit ( j ) then
81866: LD_VAR 0 3
81870: PPUSH
81871: CALL_OW 310
81875: NOT
81876: IFFALSE 81892
// ComEnterUnit ( j , selected ) ;
81878: LD_VAR 0 3
81882: PPUSH
81883: LD_VAR 0 7
81887: PPUSH
81888: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81892: LD_VAR 0 3
81896: PPUSH
81897: LD_INT 16
81899: PPUSH
81900: CALL_OW 183
// AddComExitBuilding ( j ) ;
81904: LD_VAR 0 3
81908: PPUSH
81909: CALL_OW 182
// end ;
81913: GO 81851
81915: POP
81916: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81917: LD_VAR 0 5
81921: PPUSH
81922: LD_INT 11
81924: PPUSH
81925: CALL_OW 325
81929: IFFALSE 82188
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81931: LD_ADDR_VAR 0 4
81935: PUSH
81936: LD_EXP 115
81940: PUSH
81941: LD_VAR 0 2
81945: ARRAY
81946: PPUSH
81947: LD_INT 25
81949: PUSH
81950: LD_INT 16
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PPUSH
81957: CALL_OW 72
81961: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81962: LD_VAR 0 4
81966: PUSH
81967: LD_INT 6
81969: GREATEREQUAL
81970: PUSH
81971: LD_VAR 0 5
81975: PPUSH
81976: LD_INT 2
81978: PPUSH
81979: CALL_OW 325
81983: NOT
81984: OR
81985: IFFALSE 82188
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81987: LD_ADDR_VAR 0 8
81991: PUSH
81992: LD_EXP 86
81996: PUSH
81997: LD_VAR 0 2
82001: ARRAY
82002: PPUSH
82003: LD_INT 2
82005: PUSH
82006: LD_INT 30
82008: PUSH
82009: LD_INT 4
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 30
82018: PUSH
82019: LD_INT 5
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: EMPTY
82027: LIST
82028: LIST
82029: LIST
82030: PPUSH
82031: CALL_OW 72
82035: ST_TO_ADDR
// if barracks then
82036: LD_VAR 0 8
82040: IFFALSE 82188
// begin selected := 0 ;
82042: LD_ADDR_VAR 0 7
82046: PUSH
82047: LD_INT 0
82049: ST_TO_ADDR
// for j in barracks do
82050: LD_ADDR_VAR 0 3
82054: PUSH
82055: LD_VAR 0 8
82059: PUSH
82060: FOR_IN
82061: IFFALSE 82092
// begin if UnitsInside ( j ) < 6 then
82063: LD_VAR 0 3
82067: PPUSH
82068: CALL_OW 313
82072: PUSH
82073: LD_INT 6
82075: LESS
82076: IFFALSE 82090
// begin selected := j ;
82078: LD_ADDR_VAR 0 7
82082: PUSH
82083: LD_VAR 0 3
82087: ST_TO_ADDR
// break ;
82088: GO 82092
// end ; end ;
82090: GO 82060
82092: POP
82093: POP
// if selected then
82094: LD_VAR 0 7
82098: IFFALSE 82188
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
82100: LD_ADDR_VAR 0 3
82104: PUSH
82105: LD_EXP 115
82109: PUSH
82110: LD_VAR 0 2
82114: ARRAY
82115: PPUSH
82116: LD_INT 25
82118: PUSH
82119: LD_INT 12
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PPUSH
82126: CALL_OW 72
82130: PUSH
82131: FOR_IN
82132: IFFALSE 82186
// if not IsInUnit ( j ) and not HasTask ( j ) then
82134: LD_VAR 0 3
82138: PPUSH
82139: CALL_OW 310
82143: NOT
82144: PUSH
82145: LD_VAR 0 3
82149: PPUSH
82150: CALL_OW 314
82154: NOT
82155: AND
82156: IFFALSE 82184
// begin ComEnterUnit ( j , selected ) ;
82158: LD_VAR 0 3
82162: PPUSH
82163: LD_VAR 0 7
82167: PPUSH
82168: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
82172: LD_VAR 0 3
82176: PPUSH
82177: LD_INT 15
82179: PPUSH
82180: CALL_OW 183
// end ;
82184: GO 82131
82186: POP
82187: POP
// end ; end ; end ; end ; end ;
82188: GO 81581
82190: POP
82191: POP
// end ;
82192: LD_VAR 0 1
82196: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
82197: LD_INT 0
82199: PPUSH
82200: PPUSH
82201: PPUSH
82202: PPUSH
// if not mc_bases then
82203: LD_EXP 86
82207: NOT
82208: IFFALSE 82212
// exit ;
82210: GO 82390
// for i = 1 to mc_bases do
82212: LD_ADDR_VAR 0 2
82216: PUSH
82217: DOUBLE
82218: LD_INT 1
82220: DEC
82221: ST_TO_ADDR
82222: LD_EXP 86
82226: PUSH
82227: FOR_TO
82228: IFFALSE 82388
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
82230: LD_ADDR_VAR 0 4
82234: PUSH
82235: LD_EXP 86
82239: PUSH
82240: LD_VAR 0 2
82244: ARRAY
82245: PPUSH
82246: LD_INT 25
82248: PUSH
82249: LD_INT 9
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: PPUSH
82256: CALL_OW 72
82260: ST_TO_ADDR
// if not tmp then
82261: LD_VAR 0 4
82265: NOT
82266: IFFALSE 82270
// continue ;
82268: GO 82227
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
82270: LD_EXP 112
82274: PUSH
82275: LD_VAR 0 2
82279: ARRAY
82280: PPUSH
82281: LD_INT 29
82283: PPUSH
82284: CALL_OW 325
82288: NOT
82289: PUSH
82290: LD_EXP 112
82294: PUSH
82295: LD_VAR 0 2
82299: ARRAY
82300: PPUSH
82301: LD_INT 28
82303: PPUSH
82304: CALL_OW 325
82308: NOT
82309: AND
82310: IFFALSE 82314
// continue ;
82312: GO 82227
// for j in tmp do
82314: LD_ADDR_VAR 0 3
82318: PUSH
82319: LD_VAR 0 4
82323: PUSH
82324: FOR_IN
82325: IFFALSE 82384
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
82327: LD_VAR 0 3
82331: PUSH
82332: LD_EXP 89
82336: PUSH
82337: LD_VAR 0 2
82341: ARRAY
82342: PUSH
82343: LD_INT 1
82345: ARRAY
82346: IN
82347: NOT
82348: PUSH
82349: LD_VAR 0 3
82353: PUSH
82354: LD_EXP 89
82358: PUSH
82359: LD_VAR 0 2
82363: ARRAY
82364: PUSH
82365: LD_INT 2
82367: ARRAY
82368: IN
82369: NOT
82370: AND
82371: IFFALSE 82382
// ComSpaceTimeShoot ( j ) ;
82373: LD_VAR 0 3
82377: PPUSH
82378: CALL 18448 0 1
82382: GO 82324
82384: POP
82385: POP
// end ;
82386: GO 82227
82388: POP
82389: POP
// end ;
82390: LD_VAR 0 1
82394: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
82395: LD_INT 0
82397: PPUSH
82398: PPUSH
82399: PPUSH
82400: PPUSH
82401: PPUSH
82402: PPUSH
82403: PPUSH
82404: PPUSH
82405: PPUSH
// if not mc_bases then
82406: LD_EXP 86
82410: NOT
82411: IFFALSE 82415
// exit ;
82413: GO 83037
// for i = 1 to mc_bases do
82415: LD_ADDR_VAR 0 2
82419: PUSH
82420: DOUBLE
82421: LD_INT 1
82423: DEC
82424: ST_TO_ADDR
82425: LD_EXP 86
82429: PUSH
82430: FOR_TO
82431: IFFALSE 83035
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
82433: LD_EXP 121
82437: PUSH
82438: LD_VAR 0 2
82442: ARRAY
82443: NOT
82444: PUSH
82445: LD_INT 38
82447: PPUSH
82448: LD_EXP 112
82452: PUSH
82453: LD_VAR 0 2
82457: ARRAY
82458: PPUSH
82459: CALL_OW 321
82463: PUSH
82464: LD_INT 2
82466: NONEQUAL
82467: OR
82468: IFFALSE 82472
// continue ;
82470: GO 82430
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
82472: LD_ADDR_VAR 0 8
82476: PUSH
82477: LD_EXP 86
82481: PUSH
82482: LD_VAR 0 2
82486: ARRAY
82487: PPUSH
82488: LD_INT 30
82490: PUSH
82491: LD_INT 34
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PPUSH
82498: CALL_OW 72
82502: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
82503: LD_ADDR_VAR 0 9
82507: PUSH
82508: LD_EXP 86
82512: PUSH
82513: LD_VAR 0 2
82517: ARRAY
82518: PPUSH
82519: LD_INT 25
82521: PUSH
82522: LD_INT 4
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PPUSH
82529: CALL_OW 72
82533: PPUSH
82534: LD_INT 0
82536: PPUSH
82537: CALL 51345 0 2
82541: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
82542: LD_VAR 0 9
82546: NOT
82547: PUSH
82548: LD_VAR 0 8
82552: NOT
82553: OR
82554: PUSH
82555: LD_EXP 86
82559: PUSH
82560: LD_VAR 0 2
82564: ARRAY
82565: PPUSH
82566: LD_INT 124
82568: PPUSH
82569: CALL 51345 0 2
82573: OR
82574: IFFALSE 82578
// continue ;
82576: GO 82430
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
82578: LD_EXP 122
82582: PUSH
82583: LD_VAR 0 2
82587: ARRAY
82588: PUSH
82589: LD_EXP 121
82593: PUSH
82594: LD_VAR 0 2
82598: ARRAY
82599: LESS
82600: PUSH
82601: LD_EXP 122
82605: PUSH
82606: LD_VAR 0 2
82610: ARRAY
82611: PUSH
82612: LD_VAR 0 8
82616: LESS
82617: AND
82618: IFFALSE 83033
// begin tmp := sci [ 1 ] ;
82620: LD_ADDR_VAR 0 7
82624: PUSH
82625: LD_VAR 0 9
82629: PUSH
82630: LD_INT 1
82632: ARRAY
82633: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
82634: LD_VAR 0 7
82638: PPUSH
82639: LD_INT 124
82641: PPUSH
82642: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
82646: LD_ADDR_VAR 0 3
82650: PUSH
82651: DOUBLE
82652: LD_EXP 121
82656: PUSH
82657: LD_VAR 0 2
82661: ARRAY
82662: INC
82663: ST_TO_ADDR
82664: LD_EXP 121
82668: PUSH
82669: LD_VAR 0 2
82673: ARRAY
82674: PUSH
82675: FOR_DOWNTO
82676: IFFALSE 83019
// begin if IsInUnit ( tmp ) then
82678: LD_VAR 0 7
82682: PPUSH
82683: CALL_OW 310
82687: IFFALSE 82698
// ComExitBuilding ( tmp ) ;
82689: LD_VAR 0 7
82693: PPUSH
82694: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
82698: LD_INT 35
82700: PPUSH
82701: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
82705: LD_VAR 0 7
82709: PPUSH
82710: CALL_OW 310
82714: NOT
82715: PUSH
82716: LD_VAR 0 7
82720: PPUSH
82721: CALL_OW 314
82725: NOT
82726: AND
82727: IFFALSE 82698
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
82729: LD_ADDR_VAR 0 6
82733: PUSH
82734: LD_VAR 0 7
82738: PPUSH
82739: CALL_OW 250
82743: PUSH
82744: LD_VAR 0 7
82748: PPUSH
82749: CALL_OW 251
82753: PUSH
82754: EMPTY
82755: LIST
82756: LIST
82757: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
82758: LD_INT 35
82760: PPUSH
82761: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82765: LD_ADDR_VAR 0 4
82769: PUSH
82770: LD_EXP 121
82774: PUSH
82775: LD_VAR 0 2
82779: ARRAY
82780: PUSH
82781: LD_VAR 0 3
82785: ARRAY
82786: PUSH
82787: LD_INT 1
82789: ARRAY
82790: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82791: LD_ADDR_VAR 0 5
82795: PUSH
82796: LD_EXP 121
82800: PUSH
82801: LD_VAR 0 2
82805: ARRAY
82806: PUSH
82807: LD_VAR 0 3
82811: ARRAY
82812: PUSH
82813: LD_INT 2
82815: ARRAY
82816: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82817: LD_VAR 0 7
82821: PPUSH
82822: LD_INT 10
82824: PPUSH
82825: CALL 25044 0 2
82829: PUSH
82830: LD_INT 4
82832: ARRAY
82833: IFFALSE 82871
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82835: LD_VAR 0 7
82839: PPUSH
82840: LD_VAR 0 6
82844: PUSH
82845: LD_INT 1
82847: ARRAY
82848: PPUSH
82849: LD_VAR 0 6
82853: PUSH
82854: LD_INT 2
82856: ARRAY
82857: PPUSH
82858: CALL_OW 111
// wait ( 0 0$10 ) ;
82862: LD_INT 350
82864: PPUSH
82865: CALL_OW 67
// end else
82869: GO 82897
// begin ComMoveXY ( tmp , x , y ) ;
82871: LD_VAR 0 7
82875: PPUSH
82876: LD_VAR 0 4
82880: PPUSH
82881: LD_VAR 0 5
82885: PPUSH
82886: CALL_OW 111
// wait ( 0 0$3 ) ;
82890: LD_INT 105
82892: PPUSH
82893: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82897: LD_VAR 0 7
82901: PPUSH
82902: LD_VAR 0 4
82906: PPUSH
82907: LD_VAR 0 5
82911: PPUSH
82912: CALL_OW 307
82916: IFFALSE 82758
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82918: LD_VAR 0 7
82922: PPUSH
82923: LD_VAR 0 4
82927: PPUSH
82928: LD_VAR 0 5
82932: PPUSH
82933: LD_VAR 0 8
82937: PUSH
82938: LD_VAR 0 3
82942: ARRAY
82943: PPUSH
82944: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82948: LD_INT 35
82950: PPUSH
82951: CALL_OW 67
// until not HasTask ( tmp ) ;
82955: LD_VAR 0 7
82959: PPUSH
82960: CALL_OW 314
82964: NOT
82965: IFFALSE 82948
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82967: LD_ADDR_EXP 122
82971: PUSH
82972: LD_EXP 122
82976: PPUSH
82977: LD_VAR 0 2
82981: PUSH
82982: LD_EXP 122
82986: PUSH
82987: LD_VAR 0 2
82991: ARRAY
82992: PUSH
82993: LD_INT 1
82995: PLUS
82996: PUSH
82997: EMPTY
82998: LIST
82999: LIST
83000: PPUSH
83001: LD_VAR 0 8
83005: PUSH
83006: LD_VAR 0 3
83010: ARRAY
83011: PPUSH
83012: CALL 22451 0 3
83016: ST_TO_ADDR
// end ;
83017: GO 82675
83019: POP
83020: POP
// MC_Reset ( i , 124 ) ;
83021: LD_VAR 0 2
83025: PPUSH
83026: LD_INT 124
83028: PPUSH
83029: CALL 66476 0 2
// end ; end ;
83033: GO 82430
83035: POP
83036: POP
// end ;
83037: LD_VAR 0 1
83041: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
83042: LD_INT 0
83044: PPUSH
83045: PPUSH
83046: PPUSH
// if not mc_bases then
83047: LD_EXP 86
83051: NOT
83052: IFFALSE 83056
// exit ;
83054: GO 83662
// for i = 1 to mc_bases do
83056: LD_ADDR_VAR 0 2
83060: PUSH
83061: DOUBLE
83062: LD_INT 1
83064: DEC
83065: ST_TO_ADDR
83066: LD_EXP 86
83070: PUSH
83071: FOR_TO
83072: IFFALSE 83660
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
83074: LD_ADDR_VAR 0 3
83078: PUSH
83079: LD_EXP 86
83083: PUSH
83084: LD_VAR 0 2
83088: ARRAY
83089: PPUSH
83090: LD_INT 25
83092: PUSH
83093: LD_INT 4
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PPUSH
83100: CALL_OW 72
83104: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83105: LD_VAR 0 3
83109: NOT
83110: PUSH
83111: LD_EXP 123
83115: PUSH
83116: LD_VAR 0 2
83120: ARRAY
83121: NOT
83122: OR
83123: PUSH
83124: LD_EXP 86
83128: PUSH
83129: LD_VAR 0 2
83133: ARRAY
83134: PPUSH
83135: LD_INT 2
83137: PUSH
83138: LD_INT 30
83140: PUSH
83141: LD_INT 0
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 30
83150: PUSH
83151: LD_INT 1
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: LIST
83162: PPUSH
83163: CALL_OW 72
83167: NOT
83168: OR
83169: IFFALSE 83219
// begin if mc_deposits_finder [ i ] then
83171: LD_EXP 124
83175: PUSH
83176: LD_VAR 0 2
83180: ARRAY
83181: IFFALSE 83217
// begin MC_Reset ( i , 125 ) ;
83183: LD_VAR 0 2
83187: PPUSH
83188: LD_INT 125
83190: PPUSH
83191: CALL 66476 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
83195: LD_ADDR_EXP 124
83199: PUSH
83200: LD_EXP 124
83204: PPUSH
83205: LD_VAR 0 2
83209: PPUSH
83210: EMPTY
83211: PPUSH
83212: CALL_OW 1
83216: ST_TO_ADDR
// end ; continue ;
83217: GO 83071
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
83219: LD_EXP 123
83223: PUSH
83224: LD_VAR 0 2
83228: ARRAY
83229: PUSH
83230: LD_INT 1
83232: ARRAY
83233: PUSH
83234: LD_INT 3
83236: ARRAY
83237: PUSH
83238: LD_INT 1
83240: EQUAL
83241: PUSH
83242: LD_INT 20
83244: PPUSH
83245: LD_EXP 112
83249: PUSH
83250: LD_VAR 0 2
83254: ARRAY
83255: PPUSH
83256: CALL_OW 321
83260: PUSH
83261: LD_INT 2
83263: NONEQUAL
83264: AND
83265: IFFALSE 83315
// begin if mc_deposits_finder [ i ] then
83267: LD_EXP 124
83271: PUSH
83272: LD_VAR 0 2
83276: ARRAY
83277: IFFALSE 83313
// begin MC_Reset ( i , 125 ) ;
83279: LD_VAR 0 2
83283: PPUSH
83284: LD_INT 125
83286: PPUSH
83287: CALL 66476 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
83291: LD_ADDR_EXP 124
83295: PUSH
83296: LD_EXP 124
83300: PPUSH
83301: LD_VAR 0 2
83305: PPUSH
83306: EMPTY
83307: PPUSH
83308: CALL_OW 1
83312: ST_TO_ADDR
// end ; continue ;
83313: GO 83071
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
83315: LD_EXP 123
83319: PUSH
83320: LD_VAR 0 2
83324: ARRAY
83325: PUSH
83326: LD_INT 1
83328: ARRAY
83329: PUSH
83330: LD_INT 1
83332: ARRAY
83333: PPUSH
83334: LD_EXP 123
83338: PUSH
83339: LD_VAR 0 2
83343: ARRAY
83344: PUSH
83345: LD_INT 1
83347: ARRAY
83348: PUSH
83349: LD_INT 2
83351: ARRAY
83352: PPUSH
83353: LD_EXP 112
83357: PUSH
83358: LD_VAR 0 2
83362: ARRAY
83363: PPUSH
83364: CALL_OW 440
83368: IFFALSE 83411
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
83370: LD_ADDR_EXP 123
83374: PUSH
83375: LD_EXP 123
83379: PPUSH
83380: LD_VAR 0 2
83384: PPUSH
83385: LD_EXP 123
83389: PUSH
83390: LD_VAR 0 2
83394: ARRAY
83395: PPUSH
83396: LD_INT 1
83398: PPUSH
83399: CALL_OW 3
83403: PPUSH
83404: CALL_OW 1
83408: ST_TO_ADDR
83409: GO 83658
// begin if not mc_deposits_finder [ i ] then
83411: LD_EXP 124
83415: PUSH
83416: LD_VAR 0 2
83420: ARRAY
83421: NOT
83422: IFFALSE 83474
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
83424: LD_ADDR_EXP 124
83428: PUSH
83429: LD_EXP 124
83433: PPUSH
83434: LD_VAR 0 2
83438: PPUSH
83439: LD_VAR 0 3
83443: PUSH
83444: LD_INT 1
83446: ARRAY
83447: PUSH
83448: EMPTY
83449: LIST
83450: PPUSH
83451: CALL_OW 1
83455: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
83456: LD_VAR 0 3
83460: PUSH
83461: LD_INT 1
83463: ARRAY
83464: PPUSH
83465: LD_INT 125
83467: PPUSH
83468: CALL_OW 109
// end else
83472: GO 83658
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
83474: LD_EXP 124
83478: PUSH
83479: LD_VAR 0 2
83483: ARRAY
83484: PUSH
83485: LD_INT 1
83487: ARRAY
83488: PPUSH
83489: CALL_OW 310
83493: IFFALSE 83516
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
83495: LD_EXP 124
83499: PUSH
83500: LD_VAR 0 2
83504: ARRAY
83505: PUSH
83506: LD_INT 1
83508: ARRAY
83509: PPUSH
83510: CALL_OW 122
83514: GO 83658
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
83516: LD_EXP 124
83520: PUSH
83521: LD_VAR 0 2
83525: ARRAY
83526: PUSH
83527: LD_INT 1
83529: ARRAY
83530: PPUSH
83531: CALL_OW 314
83535: NOT
83536: PUSH
83537: LD_EXP 124
83541: PUSH
83542: LD_VAR 0 2
83546: ARRAY
83547: PUSH
83548: LD_INT 1
83550: ARRAY
83551: PPUSH
83552: LD_EXP 123
83556: PUSH
83557: LD_VAR 0 2
83561: ARRAY
83562: PUSH
83563: LD_INT 1
83565: ARRAY
83566: PUSH
83567: LD_INT 1
83569: ARRAY
83570: PPUSH
83571: LD_EXP 123
83575: PUSH
83576: LD_VAR 0 2
83580: ARRAY
83581: PUSH
83582: LD_INT 1
83584: ARRAY
83585: PUSH
83586: LD_INT 2
83588: ARRAY
83589: PPUSH
83590: CALL_OW 297
83594: PUSH
83595: LD_INT 6
83597: GREATER
83598: AND
83599: IFFALSE 83658
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
83601: LD_EXP 124
83605: PUSH
83606: LD_VAR 0 2
83610: ARRAY
83611: PUSH
83612: LD_INT 1
83614: ARRAY
83615: PPUSH
83616: LD_EXP 123
83620: PUSH
83621: LD_VAR 0 2
83625: ARRAY
83626: PUSH
83627: LD_INT 1
83629: ARRAY
83630: PUSH
83631: LD_INT 1
83633: ARRAY
83634: PPUSH
83635: LD_EXP 123
83639: PUSH
83640: LD_VAR 0 2
83644: ARRAY
83645: PUSH
83646: LD_INT 1
83648: ARRAY
83649: PUSH
83650: LD_INT 2
83652: ARRAY
83653: PPUSH
83654: CALL_OW 111
// end ; end ; end ;
83658: GO 83071
83660: POP
83661: POP
// end ;
83662: LD_VAR 0 1
83666: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
83667: LD_INT 0
83669: PPUSH
83670: PPUSH
83671: PPUSH
83672: PPUSH
83673: PPUSH
83674: PPUSH
83675: PPUSH
83676: PPUSH
83677: PPUSH
83678: PPUSH
83679: PPUSH
// if not mc_bases then
83680: LD_EXP 86
83684: NOT
83685: IFFALSE 83689
// exit ;
83687: GO 84629
// for i = 1 to mc_bases do
83689: LD_ADDR_VAR 0 2
83693: PUSH
83694: DOUBLE
83695: LD_INT 1
83697: DEC
83698: ST_TO_ADDR
83699: LD_EXP 86
83703: PUSH
83704: FOR_TO
83705: IFFALSE 84627
// begin if not mc_bases [ i ] or mc_scan [ i ] then
83707: LD_EXP 86
83711: PUSH
83712: LD_VAR 0 2
83716: ARRAY
83717: NOT
83718: PUSH
83719: LD_EXP 109
83723: PUSH
83724: LD_VAR 0 2
83728: ARRAY
83729: OR
83730: IFFALSE 83734
// continue ;
83732: GO 83704
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
83734: LD_ADDR_VAR 0 7
83738: PUSH
83739: LD_EXP 86
83743: PUSH
83744: LD_VAR 0 2
83748: ARRAY
83749: PUSH
83750: LD_INT 1
83752: ARRAY
83753: PPUSH
83754: CALL_OW 248
83758: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83759: LD_VAR 0 7
83763: PUSH
83764: LD_INT 3
83766: EQUAL
83767: PUSH
83768: LD_EXP 105
83772: PUSH
83773: LD_VAR 0 2
83777: ARRAY
83778: PUSH
83779: LD_EXP 108
83783: PUSH
83784: LD_VAR 0 2
83788: ARRAY
83789: UNION
83790: PPUSH
83791: LD_INT 33
83793: PUSH
83794: LD_INT 2
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: PPUSH
83801: CALL_OW 72
83805: NOT
83806: OR
83807: IFFALSE 83811
// continue ;
83809: GO 83704
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83811: LD_ADDR_VAR 0 9
83815: PUSH
83816: LD_EXP 86
83820: PUSH
83821: LD_VAR 0 2
83825: ARRAY
83826: PPUSH
83827: LD_INT 30
83829: PUSH
83830: LD_INT 36
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: PPUSH
83837: CALL_OW 72
83841: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83842: LD_ADDR_VAR 0 10
83846: PUSH
83847: LD_EXP 105
83851: PUSH
83852: LD_VAR 0 2
83856: ARRAY
83857: PPUSH
83858: LD_INT 34
83860: PUSH
83861: LD_INT 31
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PPUSH
83868: CALL_OW 72
83872: ST_TO_ADDR
// if not cts and not mcts then
83873: LD_VAR 0 9
83877: NOT
83878: PUSH
83879: LD_VAR 0 10
83883: NOT
83884: AND
83885: IFFALSE 83889
// continue ;
83887: GO 83704
// x := cts ;
83889: LD_ADDR_VAR 0 11
83893: PUSH
83894: LD_VAR 0 9
83898: ST_TO_ADDR
// if not x then
83899: LD_VAR 0 11
83903: NOT
83904: IFFALSE 83916
// x := mcts ;
83906: LD_ADDR_VAR 0 11
83910: PUSH
83911: LD_VAR 0 10
83915: ST_TO_ADDR
// if not x then
83916: LD_VAR 0 11
83920: NOT
83921: IFFALSE 83925
// continue ;
83923: GO 83704
// if mc_remote_driver [ i ] then
83925: LD_EXP 126
83929: PUSH
83930: LD_VAR 0 2
83934: ARRAY
83935: IFFALSE 84322
// for j in mc_remote_driver [ i ] do
83937: LD_ADDR_VAR 0 3
83941: PUSH
83942: LD_EXP 126
83946: PUSH
83947: LD_VAR 0 2
83951: ARRAY
83952: PUSH
83953: FOR_IN
83954: IFFALSE 84320
// begin if GetClass ( j ) <> 3 then
83956: LD_VAR 0 3
83960: PPUSH
83961: CALL_OW 257
83965: PUSH
83966: LD_INT 3
83968: NONEQUAL
83969: IFFALSE 84022
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83971: LD_ADDR_EXP 126
83975: PUSH
83976: LD_EXP 126
83980: PPUSH
83981: LD_VAR 0 2
83985: PPUSH
83986: LD_EXP 126
83990: PUSH
83991: LD_VAR 0 2
83995: ARRAY
83996: PUSH
83997: LD_VAR 0 3
84001: DIFF
84002: PPUSH
84003: CALL_OW 1
84007: ST_TO_ADDR
// SetTag ( j , 0 ) ;
84008: LD_VAR 0 3
84012: PPUSH
84013: LD_INT 0
84015: PPUSH
84016: CALL_OW 109
// continue ;
84020: GO 83953
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
84022: LD_EXP 105
84026: PUSH
84027: LD_VAR 0 2
84031: ARRAY
84032: PPUSH
84033: LD_INT 34
84035: PUSH
84036: LD_INT 31
84038: PUSH
84039: EMPTY
84040: LIST
84041: LIST
84042: PUSH
84043: LD_INT 58
84045: PUSH
84046: EMPTY
84047: LIST
84048: PUSH
84049: EMPTY
84050: LIST
84051: LIST
84052: PPUSH
84053: CALL_OW 72
84057: PUSH
84058: LD_VAR 0 3
84062: PPUSH
84063: CALL 51433 0 1
84067: NOT
84068: AND
84069: IFFALSE 84140
// begin if IsInUnit ( j ) then
84071: LD_VAR 0 3
84075: PPUSH
84076: CALL_OW 310
84080: IFFALSE 84091
// ComExitBuilding ( j ) ;
84082: LD_VAR 0 3
84086: PPUSH
84087: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
84091: LD_VAR 0 3
84095: PPUSH
84096: LD_EXP 105
84100: PUSH
84101: LD_VAR 0 2
84105: ARRAY
84106: PPUSH
84107: LD_INT 34
84109: PUSH
84110: LD_INT 31
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: PUSH
84117: LD_INT 58
84119: PUSH
84120: EMPTY
84121: LIST
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PPUSH
84127: CALL_OW 72
84131: PUSH
84132: LD_INT 1
84134: ARRAY
84135: PPUSH
84136: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
84140: LD_VAR 0 3
84144: PPUSH
84145: CALL_OW 310
84149: NOT
84150: PUSH
84151: LD_VAR 0 3
84155: PPUSH
84156: CALL_OW 310
84160: PPUSH
84161: CALL_OW 266
84165: PUSH
84166: LD_INT 36
84168: NONEQUAL
84169: PUSH
84170: LD_VAR 0 3
84174: PPUSH
84175: CALL 51433 0 1
84179: NOT
84180: AND
84181: OR
84182: IFFALSE 84318
// begin if IsInUnit ( j ) then
84184: LD_VAR 0 3
84188: PPUSH
84189: CALL_OW 310
84193: IFFALSE 84204
// ComExitBuilding ( j ) ;
84195: LD_VAR 0 3
84199: PPUSH
84200: CALL_OW 122
// ct := 0 ;
84204: LD_ADDR_VAR 0 8
84208: PUSH
84209: LD_INT 0
84211: ST_TO_ADDR
// for k in x do
84212: LD_ADDR_VAR 0 4
84216: PUSH
84217: LD_VAR 0 11
84221: PUSH
84222: FOR_IN
84223: IFFALSE 84296
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
84225: LD_VAR 0 4
84229: PPUSH
84230: CALL_OW 264
84234: PUSH
84235: LD_INT 31
84237: EQUAL
84238: PUSH
84239: LD_VAR 0 4
84243: PPUSH
84244: CALL_OW 311
84248: NOT
84249: AND
84250: PUSH
84251: LD_VAR 0 4
84255: PPUSH
84256: CALL_OW 266
84260: PUSH
84261: LD_INT 36
84263: EQUAL
84264: PUSH
84265: LD_VAR 0 4
84269: PPUSH
84270: CALL_OW 313
84274: PUSH
84275: LD_INT 3
84277: LESS
84278: AND
84279: OR
84280: IFFALSE 84294
// begin ct := k ;
84282: LD_ADDR_VAR 0 8
84286: PUSH
84287: LD_VAR 0 4
84291: ST_TO_ADDR
// break ;
84292: GO 84296
// end ;
84294: GO 84222
84296: POP
84297: POP
// if ct then
84298: LD_VAR 0 8
84302: IFFALSE 84318
// ComEnterUnit ( j , ct ) ;
84304: LD_VAR 0 3
84308: PPUSH
84309: LD_VAR 0 8
84313: PPUSH
84314: CALL_OW 120
// end ; end ;
84318: GO 83953
84320: POP
84321: POP
// places := 0 ;
84322: LD_ADDR_VAR 0 5
84326: PUSH
84327: LD_INT 0
84329: ST_TO_ADDR
// for j = 1 to x do
84330: LD_ADDR_VAR 0 3
84334: PUSH
84335: DOUBLE
84336: LD_INT 1
84338: DEC
84339: ST_TO_ADDR
84340: LD_VAR 0 11
84344: PUSH
84345: FOR_TO
84346: IFFALSE 84422
// if GetWeapon ( x [ j ] ) = ar_control_tower then
84348: LD_VAR 0 11
84352: PUSH
84353: LD_VAR 0 3
84357: ARRAY
84358: PPUSH
84359: CALL_OW 264
84363: PUSH
84364: LD_INT 31
84366: EQUAL
84367: IFFALSE 84385
// places := places + 1 else
84369: LD_ADDR_VAR 0 5
84373: PUSH
84374: LD_VAR 0 5
84378: PUSH
84379: LD_INT 1
84381: PLUS
84382: ST_TO_ADDR
84383: GO 84420
// if GetBType ( x [ j ] ) = b_control_tower then
84385: LD_VAR 0 11
84389: PUSH
84390: LD_VAR 0 3
84394: ARRAY
84395: PPUSH
84396: CALL_OW 266
84400: PUSH
84401: LD_INT 36
84403: EQUAL
84404: IFFALSE 84420
// places := places + 3 ;
84406: LD_ADDR_VAR 0 5
84410: PUSH
84411: LD_VAR 0 5
84415: PUSH
84416: LD_INT 3
84418: PLUS
84419: ST_TO_ADDR
84420: GO 84345
84422: POP
84423: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
84424: LD_VAR 0 5
84428: PUSH
84429: LD_INT 0
84431: EQUAL
84432: PUSH
84433: LD_VAR 0 5
84437: PUSH
84438: LD_EXP 126
84442: PUSH
84443: LD_VAR 0 2
84447: ARRAY
84448: LESSEQUAL
84449: OR
84450: IFFALSE 84454
// continue ;
84452: GO 83704
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
84454: LD_ADDR_VAR 0 6
84458: PUSH
84459: LD_EXP 86
84463: PUSH
84464: LD_VAR 0 2
84468: ARRAY
84469: PPUSH
84470: LD_INT 25
84472: PUSH
84473: LD_INT 3
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PPUSH
84480: CALL_OW 72
84484: PUSH
84485: LD_EXP 126
84489: PUSH
84490: LD_VAR 0 2
84494: ARRAY
84495: DIFF
84496: PPUSH
84497: LD_INT 3
84499: PPUSH
84500: CALL 52333 0 2
84504: ST_TO_ADDR
// for j in tmp do
84505: LD_ADDR_VAR 0 3
84509: PUSH
84510: LD_VAR 0 6
84514: PUSH
84515: FOR_IN
84516: IFFALSE 84551
// if GetTag ( j ) > 0 then
84518: LD_VAR 0 3
84522: PPUSH
84523: CALL_OW 110
84527: PUSH
84528: LD_INT 0
84530: GREATER
84531: IFFALSE 84549
// tmp := tmp diff j ;
84533: LD_ADDR_VAR 0 6
84537: PUSH
84538: LD_VAR 0 6
84542: PUSH
84543: LD_VAR 0 3
84547: DIFF
84548: ST_TO_ADDR
84549: GO 84515
84551: POP
84552: POP
// if not tmp then
84553: LD_VAR 0 6
84557: NOT
84558: IFFALSE 84562
// continue ;
84560: GO 83704
// if places then
84562: LD_VAR 0 5
84566: IFFALSE 84625
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
84568: LD_ADDR_EXP 126
84572: PUSH
84573: LD_EXP 126
84577: PPUSH
84578: LD_VAR 0 2
84582: PPUSH
84583: LD_EXP 126
84587: PUSH
84588: LD_VAR 0 2
84592: ARRAY
84593: PUSH
84594: LD_VAR 0 6
84598: PUSH
84599: LD_INT 1
84601: ARRAY
84602: UNION
84603: PPUSH
84604: CALL_OW 1
84608: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
84609: LD_VAR 0 6
84613: PUSH
84614: LD_INT 1
84616: ARRAY
84617: PPUSH
84618: LD_INT 126
84620: PPUSH
84621: CALL_OW 109
// end ; end ;
84625: GO 83704
84627: POP
84628: POP
// end ;
84629: LD_VAR 0 1
84633: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
84634: LD_INT 0
84636: PPUSH
84637: PPUSH
84638: PPUSH
84639: PPUSH
84640: PPUSH
84641: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
84642: LD_VAR 0 1
84646: NOT
84647: PUSH
84648: LD_VAR 0 2
84652: NOT
84653: OR
84654: PUSH
84655: LD_VAR 0 3
84659: NOT
84660: OR
84661: PUSH
84662: LD_VAR 0 4
84666: PUSH
84667: LD_INT 1
84669: PUSH
84670: LD_INT 2
84672: PUSH
84673: LD_INT 3
84675: PUSH
84676: LD_INT 4
84678: PUSH
84679: LD_INT 5
84681: PUSH
84682: LD_INT 8
84684: PUSH
84685: LD_INT 9
84687: PUSH
84688: LD_INT 15
84690: PUSH
84691: LD_INT 16
84693: PUSH
84694: EMPTY
84695: LIST
84696: LIST
84697: LIST
84698: LIST
84699: LIST
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: IN
84705: NOT
84706: OR
84707: IFFALSE 84711
// exit ;
84709: GO 85611
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
84711: LD_ADDR_VAR 0 2
84715: PUSH
84716: LD_VAR 0 2
84720: PPUSH
84721: LD_INT 21
84723: PUSH
84724: LD_INT 3
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 24
84733: PUSH
84734: LD_INT 250
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: EMPTY
84742: LIST
84743: LIST
84744: PPUSH
84745: CALL_OW 72
84749: ST_TO_ADDR
// case class of 1 , 15 :
84750: LD_VAR 0 4
84754: PUSH
84755: LD_INT 1
84757: DOUBLE
84758: EQUAL
84759: IFTRUE 84769
84761: LD_INT 15
84763: DOUBLE
84764: EQUAL
84765: IFTRUE 84769
84767: GO 84854
84769: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84770: LD_ADDR_VAR 0 8
84774: PUSH
84775: LD_VAR 0 2
84779: PPUSH
84780: LD_INT 2
84782: PUSH
84783: LD_INT 30
84785: PUSH
84786: LD_INT 32
84788: PUSH
84789: EMPTY
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 30
84795: PUSH
84796: LD_INT 31
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: EMPTY
84804: LIST
84805: LIST
84806: LIST
84807: PPUSH
84808: CALL_OW 72
84812: PUSH
84813: LD_VAR 0 2
84817: PPUSH
84818: LD_INT 2
84820: PUSH
84821: LD_INT 30
84823: PUSH
84824: LD_INT 4
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: PUSH
84831: LD_INT 30
84833: PUSH
84834: LD_INT 5
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: LIST
84845: PPUSH
84846: CALL_OW 72
84850: ADD
84851: ST_TO_ADDR
84852: GO 85100
84854: LD_INT 2
84856: DOUBLE
84857: EQUAL
84858: IFTRUE 84868
84860: LD_INT 16
84862: DOUBLE
84863: EQUAL
84864: IFTRUE 84868
84866: GO 84914
84868: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84869: LD_ADDR_VAR 0 8
84873: PUSH
84874: LD_VAR 0 2
84878: PPUSH
84879: LD_INT 2
84881: PUSH
84882: LD_INT 30
84884: PUSH
84885: LD_INT 0
84887: PUSH
84888: EMPTY
84889: LIST
84890: LIST
84891: PUSH
84892: LD_INT 30
84894: PUSH
84895: LD_INT 1
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: LIST
84906: PPUSH
84907: CALL_OW 72
84911: ST_TO_ADDR
84912: GO 85100
84914: LD_INT 3
84916: DOUBLE
84917: EQUAL
84918: IFTRUE 84922
84920: GO 84968
84922: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84923: LD_ADDR_VAR 0 8
84927: PUSH
84928: LD_VAR 0 2
84932: PPUSH
84933: LD_INT 2
84935: PUSH
84936: LD_INT 30
84938: PUSH
84939: LD_INT 2
84941: PUSH
84942: EMPTY
84943: LIST
84944: LIST
84945: PUSH
84946: LD_INT 30
84948: PUSH
84949: LD_INT 3
84951: PUSH
84952: EMPTY
84953: LIST
84954: LIST
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: LIST
84960: PPUSH
84961: CALL_OW 72
84965: ST_TO_ADDR
84966: GO 85100
84968: LD_INT 4
84970: DOUBLE
84971: EQUAL
84972: IFTRUE 84976
84974: GO 85033
84976: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84977: LD_ADDR_VAR 0 8
84981: PUSH
84982: LD_VAR 0 2
84986: PPUSH
84987: LD_INT 2
84989: PUSH
84990: LD_INT 30
84992: PUSH
84993: LD_INT 6
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: PUSH
85000: LD_INT 30
85002: PUSH
85003: LD_INT 7
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 30
85012: PUSH
85013: LD_INT 8
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: PPUSH
85026: CALL_OW 72
85030: ST_TO_ADDR
85031: GO 85100
85033: LD_INT 5
85035: DOUBLE
85036: EQUAL
85037: IFTRUE 85053
85039: LD_INT 8
85041: DOUBLE
85042: EQUAL
85043: IFTRUE 85053
85045: LD_INT 9
85047: DOUBLE
85048: EQUAL
85049: IFTRUE 85053
85051: GO 85099
85053: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
85054: LD_ADDR_VAR 0 8
85058: PUSH
85059: LD_VAR 0 2
85063: PPUSH
85064: LD_INT 2
85066: PUSH
85067: LD_INT 30
85069: PUSH
85070: LD_INT 4
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 30
85079: PUSH
85080: LD_INT 5
85082: PUSH
85083: EMPTY
85084: LIST
85085: LIST
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: LIST
85091: PPUSH
85092: CALL_OW 72
85096: ST_TO_ADDR
85097: GO 85100
85099: POP
// if not tmp then
85100: LD_VAR 0 8
85104: NOT
85105: IFFALSE 85109
// exit ;
85107: GO 85611
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
85109: LD_VAR 0 4
85113: PUSH
85114: LD_INT 1
85116: PUSH
85117: LD_INT 15
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: IN
85124: PUSH
85125: LD_EXP 95
85129: PUSH
85130: LD_VAR 0 1
85134: ARRAY
85135: AND
85136: IFFALSE 85292
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
85138: LD_ADDR_VAR 0 9
85142: PUSH
85143: LD_EXP 95
85147: PUSH
85148: LD_VAR 0 1
85152: ARRAY
85153: PUSH
85154: LD_INT 1
85156: ARRAY
85157: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
85158: LD_VAR 0 9
85162: PUSH
85163: LD_EXP 96
85167: PUSH
85168: LD_VAR 0 1
85172: ARRAY
85173: IN
85174: NOT
85175: IFFALSE 85290
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
85177: LD_ADDR_EXP 96
85181: PUSH
85182: LD_EXP 96
85186: PPUSH
85187: LD_VAR 0 1
85191: PUSH
85192: LD_EXP 96
85196: PUSH
85197: LD_VAR 0 1
85201: ARRAY
85202: PUSH
85203: LD_INT 1
85205: PLUS
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PPUSH
85211: LD_VAR 0 9
85215: PPUSH
85216: CALL 22451 0 3
85220: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
85221: LD_ADDR_EXP 95
85225: PUSH
85226: LD_EXP 95
85230: PPUSH
85231: LD_VAR 0 1
85235: PPUSH
85236: LD_EXP 95
85240: PUSH
85241: LD_VAR 0 1
85245: ARRAY
85246: PUSH
85247: LD_VAR 0 9
85251: DIFF
85252: PPUSH
85253: CALL_OW 1
85257: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
85258: LD_VAR 0 3
85262: PPUSH
85263: LD_EXP 96
85267: PUSH
85268: LD_VAR 0 1
85272: ARRAY
85273: PUSH
85274: LD_EXP 96
85278: PUSH
85279: LD_VAR 0 1
85283: ARRAY
85284: ARRAY
85285: PPUSH
85286: CALL_OW 120
// end ; exit ;
85290: GO 85611
// end ; if tmp > 1 then
85292: LD_VAR 0 8
85296: PUSH
85297: LD_INT 1
85299: GREATER
85300: IFFALSE 85404
// for i = 2 to tmp do
85302: LD_ADDR_VAR 0 6
85306: PUSH
85307: DOUBLE
85308: LD_INT 2
85310: DEC
85311: ST_TO_ADDR
85312: LD_VAR 0 8
85316: PUSH
85317: FOR_TO
85318: IFFALSE 85402
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
85320: LD_VAR 0 8
85324: PUSH
85325: LD_VAR 0 6
85329: ARRAY
85330: PPUSH
85331: CALL_OW 461
85335: PUSH
85336: LD_INT 6
85338: EQUAL
85339: IFFALSE 85400
// begin x := tmp [ i ] ;
85341: LD_ADDR_VAR 0 9
85345: PUSH
85346: LD_VAR 0 8
85350: PUSH
85351: LD_VAR 0 6
85355: ARRAY
85356: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
85357: LD_ADDR_VAR 0 8
85361: PUSH
85362: LD_VAR 0 8
85366: PPUSH
85367: LD_VAR 0 6
85371: PPUSH
85372: CALL_OW 3
85376: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
85377: LD_ADDR_VAR 0 8
85381: PUSH
85382: LD_VAR 0 8
85386: PPUSH
85387: LD_INT 1
85389: PPUSH
85390: LD_VAR 0 9
85394: PPUSH
85395: CALL_OW 2
85399: ST_TO_ADDR
// end ;
85400: GO 85317
85402: POP
85403: POP
// for i in tmp do
85404: LD_ADDR_VAR 0 6
85408: PUSH
85409: LD_VAR 0 8
85413: PUSH
85414: FOR_IN
85415: IFFALSE 85484
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
85417: LD_VAR 0 6
85421: PPUSH
85422: CALL_OW 313
85426: PUSH
85427: LD_INT 6
85429: LESS
85430: PUSH
85431: LD_VAR 0 6
85435: PPUSH
85436: CALL_OW 266
85440: PUSH
85441: LD_INT 31
85443: PUSH
85444: LD_INT 32
85446: PUSH
85447: EMPTY
85448: LIST
85449: LIST
85450: IN
85451: NOT
85452: AND
85453: PUSH
85454: LD_VAR 0 6
85458: PPUSH
85459: CALL_OW 313
85463: PUSH
85464: LD_INT 0
85466: EQUAL
85467: OR
85468: IFFALSE 85482
// begin j := i ;
85470: LD_ADDR_VAR 0 7
85474: PUSH
85475: LD_VAR 0 6
85479: ST_TO_ADDR
// break ;
85480: GO 85484
// end ; end ;
85482: GO 85414
85484: POP
85485: POP
// if j then
85486: LD_VAR 0 7
85490: IFFALSE 85508
// ComEnterUnit ( unit , j ) else
85492: LD_VAR 0 3
85496: PPUSH
85497: LD_VAR 0 7
85501: PPUSH
85502: CALL_OW 120
85506: GO 85611
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85508: LD_ADDR_VAR 0 10
85512: PUSH
85513: LD_VAR 0 2
85517: PPUSH
85518: LD_INT 2
85520: PUSH
85521: LD_INT 30
85523: PUSH
85524: LD_INT 0
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 30
85533: PUSH
85534: LD_INT 1
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: EMPTY
85542: LIST
85543: LIST
85544: LIST
85545: PPUSH
85546: CALL_OW 72
85550: ST_TO_ADDR
// if depot then
85551: LD_VAR 0 10
85555: IFFALSE 85611
// begin depot := NearestUnitToUnit ( depot , unit ) ;
85557: LD_ADDR_VAR 0 10
85561: PUSH
85562: LD_VAR 0 10
85566: PPUSH
85567: LD_VAR 0 3
85571: PPUSH
85572: CALL_OW 74
85576: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
85577: LD_VAR 0 3
85581: PPUSH
85582: LD_VAR 0 10
85586: PPUSH
85587: CALL_OW 296
85591: PUSH
85592: LD_INT 10
85594: GREATER
85595: IFFALSE 85611
// ComStandNearbyBuilding ( unit , depot ) ;
85597: LD_VAR 0 3
85601: PPUSH
85602: LD_VAR 0 10
85606: PPUSH
85607: CALL 19065 0 2
// end ; end ; end ;
85611: LD_VAR 0 5
85615: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
85616: LD_INT 0
85618: PPUSH
85619: PPUSH
85620: PPUSH
85621: PPUSH
// if not mc_bases then
85622: LD_EXP 86
85626: NOT
85627: IFFALSE 85631
// exit ;
85629: GO 85870
// for i = 1 to mc_bases do
85631: LD_ADDR_VAR 0 2
85635: PUSH
85636: DOUBLE
85637: LD_INT 1
85639: DEC
85640: ST_TO_ADDR
85641: LD_EXP 86
85645: PUSH
85646: FOR_TO
85647: IFFALSE 85868
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
85649: LD_ADDR_VAR 0 4
85653: PUSH
85654: LD_EXP 86
85658: PUSH
85659: LD_VAR 0 2
85663: ARRAY
85664: PPUSH
85665: LD_INT 21
85667: PUSH
85668: LD_INT 1
85670: PUSH
85671: EMPTY
85672: LIST
85673: LIST
85674: PPUSH
85675: CALL_OW 72
85679: PUSH
85680: LD_EXP 115
85684: PUSH
85685: LD_VAR 0 2
85689: ARRAY
85690: UNION
85691: ST_TO_ADDR
// if not tmp then
85692: LD_VAR 0 4
85696: NOT
85697: IFFALSE 85701
// continue ;
85699: GO 85646
// for j in tmp do
85701: LD_ADDR_VAR 0 3
85705: PUSH
85706: LD_VAR 0 4
85710: PUSH
85711: FOR_IN
85712: IFFALSE 85864
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
85714: LD_VAR 0 3
85718: PPUSH
85719: CALL_OW 110
85723: NOT
85724: PUSH
85725: LD_VAR 0 3
85729: PPUSH
85730: CALL_OW 314
85734: NOT
85735: AND
85736: PUSH
85737: LD_VAR 0 3
85741: PPUSH
85742: CALL_OW 311
85746: NOT
85747: AND
85748: PUSH
85749: LD_VAR 0 3
85753: PPUSH
85754: CALL_OW 310
85758: NOT
85759: AND
85760: PUSH
85761: LD_VAR 0 3
85765: PUSH
85766: LD_EXP 89
85770: PUSH
85771: LD_VAR 0 2
85775: ARRAY
85776: PUSH
85777: LD_INT 1
85779: ARRAY
85780: IN
85781: NOT
85782: AND
85783: PUSH
85784: LD_VAR 0 3
85788: PUSH
85789: LD_EXP 89
85793: PUSH
85794: LD_VAR 0 2
85798: ARRAY
85799: PUSH
85800: LD_INT 2
85802: ARRAY
85803: IN
85804: NOT
85805: AND
85806: PUSH
85807: LD_VAR 0 3
85811: PUSH
85812: LD_EXP 98
85816: PUSH
85817: LD_VAR 0 2
85821: ARRAY
85822: IN
85823: NOT
85824: AND
85825: IFFALSE 85862
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85827: LD_VAR 0 2
85831: PPUSH
85832: LD_EXP 86
85836: PUSH
85837: LD_VAR 0 2
85841: ARRAY
85842: PPUSH
85843: LD_VAR 0 3
85847: PPUSH
85848: LD_VAR 0 3
85852: PPUSH
85853: CALL_OW 257
85857: PPUSH
85858: CALL 84634 0 4
// end ;
85862: GO 85711
85864: POP
85865: POP
// end ;
85866: GO 85646
85868: POP
85869: POP
// end ;
85870: LD_VAR 0 1
85874: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
85875: LD_INT 0
85877: PPUSH
85878: PPUSH
85879: PPUSH
85880: PPUSH
85881: PPUSH
85882: PPUSH
// if not mc_bases [ base ] then
85883: LD_EXP 86
85887: PUSH
85888: LD_VAR 0 1
85892: ARRAY
85893: NOT
85894: IFFALSE 85898
// exit ;
85896: GO 86080
// tmp := [ ] ;
85898: LD_ADDR_VAR 0 6
85902: PUSH
85903: EMPTY
85904: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85905: LD_ADDR_VAR 0 7
85909: PUSH
85910: LD_VAR 0 3
85914: PPUSH
85915: LD_INT 0
85917: PPUSH
85918: CALL_OW 517
85922: ST_TO_ADDR
// if not list then
85923: LD_VAR 0 7
85927: NOT
85928: IFFALSE 85932
// exit ;
85930: GO 86080
// for i = 1 to amount do
85932: LD_ADDR_VAR 0 5
85936: PUSH
85937: DOUBLE
85938: LD_INT 1
85940: DEC
85941: ST_TO_ADDR
85942: LD_VAR 0 2
85946: PUSH
85947: FOR_TO
85948: IFFALSE 86028
// begin x := rand ( 1 , list [ 1 ] ) ;
85950: LD_ADDR_VAR 0 8
85954: PUSH
85955: LD_INT 1
85957: PPUSH
85958: LD_VAR 0 7
85962: PUSH
85963: LD_INT 1
85965: ARRAY
85966: PPUSH
85967: CALL_OW 12
85971: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
85972: LD_ADDR_VAR 0 6
85976: PUSH
85977: LD_VAR 0 6
85981: PPUSH
85982: LD_VAR 0 5
85986: PPUSH
85987: LD_VAR 0 7
85991: PUSH
85992: LD_INT 1
85994: ARRAY
85995: PUSH
85996: LD_VAR 0 8
86000: ARRAY
86001: PUSH
86002: LD_VAR 0 7
86006: PUSH
86007: LD_INT 2
86009: ARRAY
86010: PUSH
86011: LD_VAR 0 8
86015: ARRAY
86016: PUSH
86017: EMPTY
86018: LIST
86019: LIST
86020: PPUSH
86021: CALL_OW 1
86025: ST_TO_ADDR
// end ;
86026: GO 85947
86028: POP
86029: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
86030: LD_ADDR_EXP 99
86034: PUSH
86035: LD_EXP 99
86039: PPUSH
86040: LD_VAR 0 1
86044: PPUSH
86045: LD_VAR 0 6
86049: PPUSH
86050: CALL_OW 1
86054: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
86055: LD_ADDR_EXP 101
86059: PUSH
86060: LD_EXP 101
86064: PPUSH
86065: LD_VAR 0 1
86069: PPUSH
86070: LD_VAR 0 3
86074: PPUSH
86075: CALL_OW 1
86079: ST_TO_ADDR
// end ;
86080: LD_VAR 0 4
86084: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
86085: LD_INT 0
86087: PPUSH
// if not mc_bases [ base ] then
86088: LD_EXP 86
86092: PUSH
86093: LD_VAR 0 1
86097: ARRAY
86098: NOT
86099: IFFALSE 86103
// exit ;
86101: GO 86128
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
86103: LD_ADDR_EXP 91
86107: PUSH
86108: LD_EXP 91
86112: PPUSH
86113: LD_VAR 0 1
86117: PPUSH
86118: LD_VAR 0 2
86122: PPUSH
86123: CALL_OW 1
86127: ST_TO_ADDR
// end ;
86128: LD_VAR 0 3
86132: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
86133: LD_INT 0
86135: PPUSH
// if not mc_bases [ base ] then
86136: LD_EXP 86
86140: PUSH
86141: LD_VAR 0 1
86145: ARRAY
86146: NOT
86147: IFFALSE 86151
// exit ;
86149: GO 86188
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
86151: LD_ADDR_EXP 91
86155: PUSH
86156: LD_EXP 91
86160: PPUSH
86161: LD_VAR 0 1
86165: PPUSH
86166: LD_EXP 91
86170: PUSH
86171: LD_VAR 0 1
86175: ARRAY
86176: PUSH
86177: LD_VAR 0 2
86181: UNION
86182: PPUSH
86183: CALL_OW 1
86187: ST_TO_ADDR
// end ;
86188: LD_VAR 0 3
86192: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
86193: LD_INT 0
86195: PPUSH
// if not mc_bases [ base ] then
86196: LD_EXP 86
86200: PUSH
86201: LD_VAR 0 1
86205: ARRAY
86206: NOT
86207: IFFALSE 86211
// exit ;
86209: GO 86236
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
86211: LD_ADDR_EXP 107
86215: PUSH
86216: LD_EXP 107
86220: PPUSH
86221: LD_VAR 0 1
86225: PPUSH
86226: LD_VAR 0 2
86230: PPUSH
86231: CALL_OW 1
86235: ST_TO_ADDR
// end ;
86236: LD_VAR 0 3
86240: RET
// export function MC_InsertProduceList ( base , components ) ; begin
86241: LD_INT 0
86243: PPUSH
// if not mc_bases [ base ] then
86244: LD_EXP 86
86248: PUSH
86249: LD_VAR 0 1
86253: ARRAY
86254: NOT
86255: IFFALSE 86259
// exit ;
86257: GO 86296
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
86259: LD_ADDR_EXP 107
86263: PUSH
86264: LD_EXP 107
86268: PPUSH
86269: LD_VAR 0 1
86273: PPUSH
86274: LD_EXP 107
86278: PUSH
86279: LD_VAR 0 1
86283: ARRAY
86284: PUSH
86285: LD_VAR 0 2
86289: ADD
86290: PPUSH
86291: CALL_OW 1
86295: ST_TO_ADDR
// end ;
86296: LD_VAR 0 3
86300: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
86301: LD_INT 0
86303: PPUSH
// if not mc_bases [ base ] then
86304: LD_EXP 86
86308: PUSH
86309: LD_VAR 0 1
86313: ARRAY
86314: NOT
86315: IFFALSE 86319
// exit ;
86317: GO 86373
// mc_defender := Replace ( mc_defender , base , deflist ) ;
86319: LD_ADDR_EXP 108
86323: PUSH
86324: LD_EXP 108
86328: PPUSH
86329: LD_VAR 0 1
86333: PPUSH
86334: LD_VAR 0 2
86338: PPUSH
86339: CALL_OW 1
86343: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
86344: LD_ADDR_EXP 97
86348: PUSH
86349: LD_EXP 97
86353: PPUSH
86354: LD_VAR 0 1
86358: PPUSH
86359: LD_VAR 0 2
86363: PUSH
86364: LD_INT 0
86366: PLUS
86367: PPUSH
86368: CALL_OW 1
86372: ST_TO_ADDR
// end ;
86373: LD_VAR 0 3
86377: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
86378: LD_INT 0
86380: PPUSH
// if not mc_bases [ base ] then
86381: LD_EXP 86
86385: PUSH
86386: LD_VAR 0 1
86390: ARRAY
86391: NOT
86392: IFFALSE 86396
// exit ;
86394: GO 86421
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
86396: LD_ADDR_EXP 97
86400: PUSH
86401: LD_EXP 97
86405: PPUSH
86406: LD_VAR 0 1
86410: PPUSH
86411: LD_VAR 0 2
86415: PPUSH
86416: CALL_OW 1
86420: ST_TO_ADDR
// end ;
86421: LD_VAR 0 3
86425: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
86426: LD_INT 0
86428: PPUSH
86429: PPUSH
86430: PPUSH
86431: PPUSH
// if not mc_bases [ base ] then
86432: LD_EXP 86
86436: PUSH
86437: LD_VAR 0 1
86441: ARRAY
86442: NOT
86443: IFFALSE 86447
// exit ;
86445: GO 86512
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
86447: LD_ADDR_EXP 106
86451: PUSH
86452: LD_EXP 106
86456: PPUSH
86457: LD_VAR 0 1
86461: PUSH
86462: LD_EXP 106
86466: PUSH
86467: LD_VAR 0 1
86471: ARRAY
86472: PUSH
86473: LD_INT 1
86475: PLUS
86476: PUSH
86477: EMPTY
86478: LIST
86479: LIST
86480: PPUSH
86481: LD_VAR 0 1
86485: PUSH
86486: LD_VAR 0 2
86490: PUSH
86491: LD_VAR 0 3
86495: PUSH
86496: LD_VAR 0 4
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: LIST
86505: LIST
86506: PPUSH
86507: CALL 22451 0 3
86511: ST_TO_ADDR
// end ;
86512: LD_VAR 0 5
86516: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
86517: LD_INT 0
86519: PPUSH
// if not mc_bases [ base ] then
86520: LD_EXP 86
86524: PUSH
86525: LD_VAR 0 1
86529: ARRAY
86530: NOT
86531: IFFALSE 86535
// exit ;
86533: GO 86560
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
86535: LD_ADDR_EXP 123
86539: PUSH
86540: LD_EXP 123
86544: PPUSH
86545: LD_VAR 0 1
86549: PPUSH
86550: LD_VAR 0 2
86554: PPUSH
86555: CALL_OW 1
86559: ST_TO_ADDR
// end ;
86560: LD_VAR 0 3
86564: RET
// export function MC_GetMinesField ( base ) ; begin
86565: LD_INT 0
86567: PPUSH
// result := mc_mines [ base ] ;
86568: LD_ADDR_VAR 0 2
86572: PUSH
86573: LD_EXP 99
86577: PUSH
86578: LD_VAR 0 1
86582: ARRAY
86583: ST_TO_ADDR
// end ;
86584: LD_VAR 0 2
86588: RET
// export function MC_GetProduceList ( base ) ; begin
86589: LD_INT 0
86591: PPUSH
// result := mc_produce [ base ] ;
86592: LD_ADDR_VAR 0 2
86596: PUSH
86597: LD_EXP 107
86601: PUSH
86602: LD_VAR 0 1
86606: ARRAY
86607: ST_TO_ADDR
// end ;
86608: LD_VAR 0 2
86612: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
86613: LD_INT 0
86615: PPUSH
86616: PPUSH
// if not mc_bases then
86617: LD_EXP 86
86621: NOT
86622: IFFALSE 86626
// exit ;
86624: GO 86691
// if mc_bases [ base ] then
86626: LD_EXP 86
86630: PUSH
86631: LD_VAR 0 1
86635: ARRAY
86636: IFFALSE 86691
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86638: LD_ADDR_VAR 0 3
86642: PUSH
86643: LD_EXP 86
86647: PUSH
86648: LD_VAR 0 1
86652: ARRAY
86653: PPUSH
86654: LD_INT 30
86656: PUSH
86657: LD_VAR 0 2
86661: PUSH
86662: EMPTY
86663: LIST
86664: LIST
86665: PPUSH
86666: CALL_OW 72
86670: ST_TO_ADDR
// if result then
86671: LD_VAR 0 3
86675: IFFALSE 86691
// result := result [ 1 ] ;
86677: LD_ADDR_VAR 0 3
86681: PUSH
86682: LD_VAR 0 3
86686: PUSH
86687: LD_INT 1
86689: ARRAY
86690: ST_TO_ADDR
// end ; end ;
86691: LD_VAR 0 3
86695: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
86696: LD_INT 0
86698: PPUSH
86699: PPUSH
// if not mc_bases then
86700: LD_EXP 86
86704: NOT
86705: IFFALSE 86709
// exit ;
86707: GO 86754
// if mc_bases [ base ] then
86709: LD_EXP 86
86713: PUSH
86714: LD_VAR 0 1
86718: ARRAY
86719: IFFALSE 86754
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86721: LD_ADDR_VAR 0 3
86725: PUSH
86726: LD_EXP 86
86730: PUSH
86731: LD_VAR 0 1
86735: ARRAY
86736: PPUSH
86737: LD_INT 30
86739: PUSH
86740: LD_VAR 0 2
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: PPUSH
86749: CALL_OW 72
86753: ST_TO_ADDR
// end ;
86754: LD_VAR 0 3
86758: RET
// export function MC_SetTame ( base , area ) ; begin
86759: LD_INT 0
86761: PPUSH
// if not mc_bases or not base then
86762: LD_EXP 86
86766: NOT
86767: PUSH
86768: LD_VAR 0 1
86772: NOT
86773: OR
86774: IFFALSE 86778
// exit ;
86776: GO 86803
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86778: LD_ADDR_EXP 114
86782: PUSH
86783: LD_EXP 114
86787: PPUSH
86788: LD_VAR 0 1
86792: PPUSH
86793: LD_VAR 0 2
86797: PPUSH
86798: CALL_OW 1
86802: ST_TO_ADDR
// end ;
86803: LD_VAR 0 3
86807: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86808: LD_INT 0
86810: PPUSH
86811: PPUSH
// if not mc_bases or not base then
86812: LD_EXP 86
86816: NOT
86817: PUSH
86818: LD_VAR 0 1
86822: NOT
86823: OR
86824: IFFALSE 86828
// exit ;
86826: GO 86930
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86828: LD_ADDR_VAR 0 4
86832: PUSH
86833: LD_EXP 86
86837: PUSH
86838: LD_VAR 0 1
86842: ARRAY
86843: PPUSH
86844: LD_INT 30
86846: PUSH
86847: LD_VAR 0 2
86851: PUSH
86852: EMPTY
86853: LIST
86854: LIST
86855: PPUSH
86856: CALL_OW 72
86860: ST_TO_ADDR
// if not tmp then
86861: LD_VAR 0 4
86865: NOT
86866: IFFALSE 86870
// exit ;
86868: GO 86930
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86870: LD_ADDR_EXP 118
86874: PUSH
86875: LD_EXP 118
86879: PPUSH
86880: LD_VAR 0 1
86884: PPUSH
86885: LD_EXP 118
86889: PUSH
86890: LD_VAR 0 1
86894: ARRAY
86895: PPUSH
86896: LD_EXP 118
86900: PUSH
86901: LD_VAR 0 1
86905: ARRAY
86906: PUSH
86907: LD_INT 1
86909: PLUS
86910: PPUSH
86911: LD_VAR 0 4
86915: PUSH
86916: LD_INT 1
86918: ARRAY
86919: PPUSH
86920: CALL_OW 2
86924: PPUSH
86925: CALL_OW 1
86929: ST_TO_ADDR
// end ;
86930: LD_VAR 0 3
86934: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86935: LD_INT 0
86937: PPUSH
86938: PPUSH
// if not mc_bases or not base or not kinds then
86939: LD_EXP 86
86943: NOT
86944: PUSH
86945: LD_VAR 0 1
86949: NOT
86950: OR
86951: PUSH
86952: LD_VAR 0 2
86956: NOT
86957: OR
86958: IFFALSE 86962
// exit ;
86960: GO 87023
// for i in kinds do
86962: LD_ADDR_VAR 0 4
86966: PUSH
86967: LD_VAR 0 2
86971: PUSH
86972: FOR_IN
86973: IFFALSE 87021
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86975: LD_ADDR_EXP 120
86979: PUSH
86980: LD_EXP 120
86984: PPUSH
86985: LD_VAR 0 1
86989: PUSH
86990: LD_EXP 120
86994: PUSH
86995: LD_VAR 0 1
86999: ARRAY
87000: PUSH
87001: LD_INT 1
87003: PLUS
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PPUSH
87009: LD_VAR 0 4
87013: PPUSH
87014: CALL 22451 0 3
87018: ST_TO_ADDR
87019: GO 86972
87021: POP
87022: POP
// end ;
87023: LD_VAR 0 3
87027: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
87028: LD_INT 0
87030: PPUSH
// if not mc_bases or not base or not areas then
87031: LD_EXP 86
87035: NOT
87036: PUSH
87037: LD_VAR 0 1
87041: NOT
87042: OR
87043: PUSH
87044: LD_VAR 0 2
87048: NOT
87049: OR
87050: IFFALSE 87054
// exit ;
87052: GO 87079
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
87054: LD_ADDR_EXP 104
87058: PUSH
87059: LD_EXP 104
87063: PPUSH
87064: LD_VAR 0 1
87068: PPUSH
87069: LD_VAR 0 2
87073: PPUSH
87074: CALL_OW 1
87078: ST_TO_ADDR
// end ;
87079: LD_VAR 0 3
87083: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
87084: LD_INT 0
87086: PPUSH
// if not mc_bases or not base or not teleports_exit then
87087: LD_EXP 86
87091: NOT
87092: PUSH
87093: LD_VAR 0 1
87097: NOT
87098: OR
87099: PUSH
87100: LD_VAR 0 2
87104: NOT
87105: OR
87106: IFFALSE 87110
// exit ;
87108: GO 87135
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
87110: LD_ADDR_EXP 121
87114: PUSH
87115: LD_EXP 121
87119: PPUSH
87120: LD_VAR 0 1
87124: PPUSH
87125: LD_VAR 0 2
87129: PPUSH
87130: CALL_OW 1
87134: ST_TO_ADDR
// end ;
87135: LD_VAR 0 3
87139: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
87140: LD_INT 0
87142: PPUSH
87143: PPUSH
87144: PPUSH
// if not mc_bases or not base or not ext_list then
87145: LD_EXP 86
87149: NOT
87150: PUSH
87151: LD_VAR 0 1
87155: NOT
87156: OR
87157: PUSH
87158: LD_VAR 0 5
87162: NOT
87163: OR
87164: IFFALSE 87168
// exit ;
87166: GO 87341
// tmp := GetFacExtXYD ( x , y , d ) ;
87168: LD_ADDR_VAR 0 8
87172: PUSH
87173: LD_VAR 0 2
87177: PPUSH
87178: LD_VAR 0 3
87182: PPUSH
87183: LD_VAR 0 4
87187: PPUSH
87188: CALL 51463 0 3
87192: ST_TO_ADDR
// if not tmp then
87193: LD_VAR 0 8
87197: NOT
87198: IFFALSE 87202
// exit ;
87200: GO 87341
// for i in tmp do
87202: LD_ADDR_VAR 0 7
87206: PUSH
87207: LD_VAR 0 8
87211: PUSH
87212: FOR_IN
87213: IFFALSE 87339
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
87215: LD_ADDR_EXP 91
87219: PUSH
87220: LD_EXP 91
87224: PPUSH
87225: LD_VAR 0 1
87229: PPUSH
87230: LD_EXP 91
87234: PUSH
87235: LD_VAR 0 1
87239: ARRAY
87240: PPUSH
87241: LD_EXP 91
87245: PUSH
87246: LD_VAR 0 1
87250: ARRAY
87251: PUSH
87252: LD_INT 1
87254: PLUS
87255: PPUSH
87256: LD_VAR 0 5
87260: PUSH
87261: LD_INT 1
87263: ARRAY
87264: PUSH
87265: LD_VAR 0 7
87269: PUSH
87270: LD_INT 1
87272: ARRAY
87273: PUSH
87274: LD_VAR 0 7
87278: PUSH
87279: LD_INT 2
87281: ARRAY
87282: PUSH
87283: LD_VAR 0 7
87287: PUSH
87288: LD_INT 3
87290: ARRAY
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: LIST
87296: LIST
87297: PPUSH
87298: CALL_OW 2
87302: PPUSH
87303: CALL_OW 1
87307: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
87308: LD_ADDR_VAR 0 5
87312: PUSH
87313: LD_VAR 0 5
87317: PPUSH
87318: LD_INT 1
87320: PPUSH
87321: CALL_OW 3
87325: ST_TO_ADDR
// if not ext_list then
87326: LD_VAR 0 5
87330: NOT
87331: IFFALSE 87337
// exit ;
87333: POP
87334: POP
87335: GO 87341
// end ;
87337: GO 87212
87339: POP
87340: POP
// end ;
87341: LD_VAR 0 6
87345: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
87346: LD_INT 0
87348: PPUSH
// if not mc_bases or not base or not weapon_list then
87349: LD_EXP 86
87353: NOT
87354: PUSH
87355: LD_VAR 0 1
87359: NOT
87360: OR
87361: PUSH
87362: LD_VAR 0 2
87366: NOT
87367: OR
87368: IFFALSE 87372
// exit ;
87370: GO 87397
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
87372: LD_ADDR_EXP 125
87376: PUSH
87377: LD_EXP 125
87381: PPUSH
87382: LD_VAR 0 1
87386: PPUSH
87387: LD_VAR 0 2
87391: PPUSH
87392: CALL_OW 1
87396: ST_TO_ADDR
// end ;
87397: LD_VAR 0 3
87401: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
87402: LD_INT 0
87404: PPUSH
// if not mc_bases or not base or not tech_list then
87405: LD_EXP 86
87409: NOT
87410: PUSH
87411: LD_VAR 0 1
87415: NOT
87416: OR
87417: PUSH
87418: LD_VAR 0 2
87422: NOT
87423: OR
87424: IFFALSE 87428
// exit ;
87426: GO 87453
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
87428: LD_ADDR_EXP 113
87432: PUSH
87433: LD_EXP 113
87437: PPUSH
87438: LD_VAR 0 1
87442: PPUSH
87443: LD_VAR 0 2
87447: PPUSH
87448: CALL_OW 1
87452: ST_TO_ADDR
// end ;
87453: LD_VAR 0 3
87457: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
87458: LD_INT 0
87460: PPUSH
// if not mc_bases or not parking_area or not base then
87461: LD_EXP 86
87465: NOT
87466: PUSH
87467: LD_VAR 0 2
87471: NOT
87472: OR
87473: PUSH
87474: LD_VAR 0 1
87478: NOT
87479: OR
87480: IFFALSE 87484
// exit ;
87482: GO 87509
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
87484: LD_ADDR_EXP 110
87488: PUSH
87489: LD_EXP 110
87493: PPUSH
87494: LD_VAR 0 1
87498: PPUSH
87499: LD_VAR 0 2
87503: PPUSH
87504: CALL_OW 1
87508: ST_TO_ADDR
// end ;
87509: LD_VAR 0 3
87513: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
87514: LD_INT 0
87516: PPUSH
// if not mc_bases or not base or not scan_area then
87517: LD_EXP 86
87521: NOT
87522: PUSH
87523: LD_VAR 0 1
87527: NOT
87528: OR
87529: PUSH
87530: LD_VAR 0 2
87534: NOT
87535: OR
87536: IFFALSE 87540
// exit ;
87538: GO 87565
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
87540: LD_ADDR_EXP 111
87544: PUSH
87545: LD_EXP 111
87549: PPUSH
87550: LD_VAR 0 1
87554: PPUSH
87555: LD_VAR 0 2
87559: PPUSH
87560: CALL_OW 1
87564: ST_TO_ADDR
// end ;
87565: LD_VAR 0 3
87569: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
87570: LD_INT 0
87572: PPUSH
87573: PPUSH
// if not mc_bases or not base then
87574: LD_EXP 86
87578: NOT
87579: PUSH
87580: LD_VAR 0 1
87584: NOT
87585: OR
87586: IFFALSE 87590
// exit ;
87588: GO 87654
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
87590: LD_ADDR_VAR 0 3
87594: PUSH
87595: LD_INT 1
87597: PUSH
87598: LD_INT 2
87600: PUSH
87601: LD_INT 3
87603: PUSH
87604: LD_INT 4
87606: PUSH
87607: LD_INT 11
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
87617: LD_ADDR_EXP 113
87621: PUSH
87622: LD_EXP 113
87626: PPUSH
87627: LD_VAR 0 1
87631: PPUSH
87632: LD_EXP 113
87636: PUSH
87637: LD_VAR 0 1
87641: ARRAY
87642: PUSH
87643: LD_VAR 0 3
87647: DIFF
87648: PPUSH
87649: CALL_OW 1
87653: ST_TO_ADDR
// end ;
87654: LD_VAR 0 2
87658: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
87659: LD_INT 0
87661: PPUSH
// result := mc_vehicles [ base ] ;
87662: LD_ADDR_VAR 0 3
87666: PUSH
87667: LD_EXP 105
87671: PUSH
87672: LD_VAR 0 1
87676: ARRAY
87677: ST_TO_ADDR
// if onlyCombat then
87678: LD_VAR 0 2
87682: IFFALSE 87860
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
87684: LD_ADDR_VAR 0 3
87688: PUSH
87689: LD_VAR 0 3
87693: PUSH
87694: LD_VAR 0 3
87698: PPUSH
87699: LD_INT 2
87701: PUSH
87702: LD_INT 34
87704: PUSH
87705: LD_INT 12
87707: PUSH
87708: EMPTY
87709: LIST
87710: LIST
87711: PUSH
87712: LD_INT 34
87714: PUSH
87715: LD_INT 51
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: PUSH
87722: LD_INT 34
87724: PUSH
87725: LD_EXP 2
87729: PUSH
87730: EMPTY
87731: LIST
87732: LIST
87733: PUSH
87734: LD_INT 34
87736: PUSH
87737: LD_INT 32
87739: PUSH
87740: EMPTY
87741: LIST
87742: LIST
87743: PUSH
87744: LD_INT 34
87746: PUSH
87747: LD_INT 13
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: PUSH
87754: LD_INT 34
87756: PUSH
87757: LD_INT 52
87759: PUSH
87760: EMPTY
87761: LIST
87762: LIST
87763: PUSH
87764: LD_INT 34
87766: PUSH
87767: LD_EXP 7
87771: PUSH
87772: EMPTY
87773: LIST
87774: LIST
87775: PUSH
87776: LD_INT 34
87778: PUSH
87779: LD_INT 14
87781: PUSH
87782: EMPTY
87783: LIST
87784: LIST
87785: PUSH
87786: LD_INT 34
87788: PUSH
87789: LD_INT 53
87791: PUSH
87792: EMPTY
87793: LIST
87794: LIST
87795: PUSH
87796: LD_INT 34
87798: PUSH
87799: LD_EXP 1
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PUSH
87808: LD_INT 34
87810: PUSH
87811: LD_INT 31
87813: PUSH
87814: EMPTY
87815: LIST
87816: LIST
87817: PUSH
87818: LD_INT 34
87820: PUSH
87821: LD_INT 48
87823: PUSH
87824: EMPTY
87825: LIST
87826: LIST
87827: PUSH
87828: LD_INT 34
87830: PUSH
87831: LD_INT 8
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: PUSH
87838: EMPTY
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: PPUSH
87854: CALL_OW 72
87858: DIFF
87859: ST_TO_ADDR
// end ; end_of_file
87860: LD_VAR 0 3
87864: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87865: LD_INT 0
87867: PPUSH
87868: PPUSH
87869: PPUSH
// if not mc_bases or not skirmish then
87870: LD_EXP 86
87874: NOT
87875: PUSH
87876: LD_EXP 84
87880: NOT
87881: OR
87882: IFFALSE 87886
// exit ;
87884: GO 88051
// for i = 1 to mc_bases do
87886: LD_ADDR_VAR 0 4
87890: PUSH
87891: DOUBLE
87892: LD_INT 1
87894: DEC
87895: ST_TO_ADDR
87896: LD_EXP 86
87900: PUSH
87901: FOR_TO
87902: IFFALSE 88049
// begin if sci in mc_bases [ i ] then
87904: LD_VAR 0 2
87908: PUSH
87909: LD_EXP 86
87913: PUSH
87914: LD_VAR 0 4
87918: ARRAY
87919: IN
87920: IFFALSE 88047
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87922: LD_ADDR_EXP 115
87926: PUSH
87927: LD_EXP 115
87931: PPUSH
87932: LD_VAR 0 4
87936: PUSH
87937: LD_EXP 115
87941: PUSH
87942: LD_VAR 0 4
87946: ARRAY
87947: PUSH
87948: LD_INT 1
87950: PLUS
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PPUSH
87956: LD_VAR 0 1
87960: PPUSH
87961: CALL 22451 0 3
87965: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87966: LD_ADDR_VAR 0 5
87970: PUSH
87971: LD_EXP 86
87975: PUSH
87976: LD_VAR 0 4
87980: ARRAY
87981: PPUSH
87982: LD_INT 2
87984: PUSH
87985: LD_INT 30
87987: PUSH
87988: LD_INT 0
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: PUSH
87995: LD_INT 30
87997: PUSH
87998: LD_INT 1
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: EMPTY
88006: LIST
88007: LIST
88008: LIST
88009: PPUSH
88010: CALL_OW 72
88014: PPUSH
88015: LD_VAR 0 1
88019: PPUSH
88020: CALL_OW 74
88024: ST_TO_ADDR
// if tmp then
88025: LD_VAR 0 5
88029: IFFALSE 88045
// ComStandNearbyBuilding ( ape , tmp ) ;
88031: LD_VAR 0 1
88035: PPUSH
88036: LD_VAR 0 5
88040: PPUSH
88041: CALL 19065 0 2
// break ;
88045: GO 88049
// end ; end ;
88047: GO 87901
88049: POP
88050: POP
// end ;
88051: LD_VAR 0 3
88055: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
88056: LD_INT 0
88058: PPUSH
88059: PPUSH
88060: PPUSH
// if not mc_bases or not skirmish then
88061: LD_EXP 86
88065: NOT
88066: PUSH
88067: LD_EXP 84
88071: NOT
88072: OR
88073: IFFALSE 88077
// exit ;
88075: GO 88166
// for i = 1 to mc_bases do
88077: LD_ADDR_VAR 0 4
88081: PUSH
88082: DOUBLE
88083: LD_INT 1
88085: DEC
88086: ST_TO_ADDR
88087: LD_EXP 86
88091: PUSH
88092: FOR_TO
88093: IFFALSE 88164
// begin if building in mc_busy_turret_list [ i ] then
88095: LD_VAR 0 1
88099: PUSH
88100: LD_EXP 96
88104: PUSH
88105: LD_VAR 0 4
88109: ARRAY
88110: IN
88111: IFFALSE 88162
// begin tmp := mc_busy_turret_list [ i ] diff building ;
88113: LD_ADDR_VAR 0 5
88117: PUSH
88118: LD_EXP 96
88122: PUSH
88123: LD_VAR 0 4
88127: ARRAY
88128: PUSH
88129: LD_VAR 0 1
88133: DIFF
88134: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
88135: LD_ADDR_EXP 96
88139: PUSH
88140: LD_EXP 96
88144: PPUSH
88145: LD_VAR 0 4
88149: PPUSH
88150: LD_VAR 0 5
88154: PPUSH
88155: CALL_OW 1
88159: ST_TO_ADDR
// break ;
88160: GO 88164
// end ; end ;
88162: GO 88092
88164: POP
88165: POP
// end ;
88166: LD_VAR 0 3
88170: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
88171: LD_INT 0
88173: PPUSH
88174: PPUSH
88175: PPUSH
// if not mc_bases or not skirmish then
88176: LD_EXP 86
88180: NOT
88181: PUSH
88182: LD_EXP 84
88186: NOT
88187: OR
88188: IFFALSE 88192
// exit ;
88190: GO 88391
// for i = 1 to mc_bases do
88192: LD_ADDR_VAR 0 5
88196: PUSH
88197: DOUBLE
88198: LD_INT 1
88200: DEC
88201: ST_TO_ADDR
88202: LD_EXP 86
88206: PUSH
88207: FOR_TO
88208: IFFALSE 88389
// if building in mc_bases [ i ] then
88210: LD_VAR 0 1
88214: PUSH
88215: LD_EXP 86
88219: PUSH
88220: LD_VAR 0 5
88224: ARRAY
88225: IN
88226: IFFALSE 88387
// begin tmp := mc_bases [ i ] diff building ;
88228: LD_ADDR_VAR 0 6
88232: PUSH
88233: LD_EXP 86
88237: PUSH
88238: LD_VAR 0 5
88242: ARRAY
88243: PUSH
88244: LD_VAR 0 1
88248: DIFF
88249: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
88250: LD_ADDR_EXP 86
88254: PUSH
88255: LD_EXP 86
88259: PPUSH
88260: LD_VAR 0 5
88264: PPUSH
88265: LD_VAR 0 6
88269: PPUSH
88270: CALL_OW 1
88274: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
88275: LD_VAR 0 1
88279: PUSH
88280: LD_EXP 94
88284: PUSH
88285: LD_VAR 0 5
88289: ARRAY
88290: IN
88291: IFFALSE 88330
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
88293: LD_ADDR_EXP 94
88297: PUSH
88298: LD_EXP 94
88302: PPUSH
88303: LD_VAR 0 5
88307: PPUSH
88308: LD_EXP 94
88312: PUSH
88313: LD_VAR 0 5
88317: ARRAY
88318: PUSH
88319: LD_VAR 0 1
88323: DIFF
88324: PPUSH
88325: CALL_OW 1
88329: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
88330: LD_VAR 0 1
88334: PUSH
88335: LD_EXP 95
88339: PUSH
88340: LD_VAR 0 5
88344: ARRAY
88345: IN
88346: IFFALSE 88385
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
88348: LD_ADDR_EXP 95
88352: PUSH
88353: LD_EXP 95
88357: PPUSH
88358: LD_VAR 0 5
88362: PPUSH
88363: LD_EXP 95
88367: PUSH
88368: LD_VAR 0 5
88372: ARRAY
88373: PUSH
88374: LD_VAR 0 1
88378: DIFF
88379: PPUSH
88380: CALL_OW 1
88384: ST_TO_ADDR
// break ;
88385: GO 88389
// end ;
88387: GO 88207
88389: POP
88390: POP
// end ;
88391: LD_VAR 0 4
88395: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
88396: LD_INT 0
88398: PPUSH
88399: PPUSH
88400: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
88401: LD_EXP 86
88405: NOT
88406: PUSH
88407: LD_EXP 84
88411: NOT
88412: OR
88413: PUSH
88414: LD_VAR 0 3
88418: PUSH
88419: LD_EXP 112
88423: IN
88424: NOT
88425: OR
88426: IFFALSE 88430
// exit ;
88428: GO 88553
// for i = 1 to mc_vehicles do
88430: LD_ADDR_VAR 0 6
88434: PUSH
88435: DOUBLE
88436: LD_INT 1
88438: DEC
88439: ST_TO_ADDR
88440: LD_EXP 105
88444: PUSH
88445: FOR_TO
88446: IFFALSE 88551
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
88448: LD_VAR 0 2
88452: PUSH
88453: LD_EXP 105
88457: PUSH
88458: LD_VAR 0 6
88462: ARRAY
88463: IN
88464: PUSH
88465: LD_VAR 0 1
88469: PUSH
88470: LD_EXP 105
88474: PUSH
88475: LD_VAR 0 6
88479: ARRAY
88480: IN
88481: OR
88482: IFFALSE 88549
// begin tmp := mc_vehicles [ i ] diff old ;
88484: LD_ADDR_VAR 0 7
88488: PUSH
88489: LD_EXP 105
88493: PUSH
88494: LD_VAR 0 6
88498: ARRAY
88499: PUSH
88500: LD_VAR 0 2
88504: DIFF
88505: ST_TO_ADDR
// tmp := tmp diff new ;
88506: LD_ADDR_VAR 0 7
88510: PUSH
88511: LD_VAR 0 7
88515: PUSH
88516: LD_VAR 0 1
88520: DIFF
88521: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
88522: LD_ADDR_EXP 105
88526: PUSH
88527: LD_EXP 105
88531: PPUSH
88532: LD_VAR 0 6
88536: PPUSH
88537: LD_VAR 0 7
88541: PPUSH
88542: CALL_OW 1
88546: ST_TO_ADDR
// break ;
88547: GO 88551
// end ;
88549: GO 88445
88551: POP
88552: POP
// end ;
88553: LD_VAR 0 5
88557: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
88558: LD_INT 0
88560: PPUSH
88561: PPUSH
88562: PPUSH
88563: PPUSH
// if not mc_bases or not skirmish then
88564: LD_EXP 86
88568: NOT
88569: PUSH
88570: LD_EXP 84
88574: NOT
88575: OR
88576: IFFALSE 88580
// exit ;
88578: GO 88963
// side := GetSide ( vehicle ) ;
88580: LD_ADDR_VAR 0 5
88584: PUSH
88585: LD_VAR 0 1
88589: PPUSH
88590: CALL_OW 255
88594: ST_TO_ADDR
// for i = 1 to mc_bases do
88595: LD_ADDR_VAR 0 4
88599: PUSH
88600: DOUBLE
88601: LD_INT 1
88603: DEC
88604: ST_TO_ADDR
88605: LD_EXP 86
88609: PUSH
88610: FOR_TO
88611: IFFALSE 88961
// begin if factory in mc_bases [ i ] then
88613: LD_VAR 0 2
88617: PUSH
88618: LD_EXP 86
88622: PUSH
88623: LD_VAR 0 4
88627: ARRAY
88628: IN
88629: IFFALSE 88959
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
88631: LD_EXP 108
88635: PUSH
88636: LD_VAR 0 4
88640: ARRAY
88641: PUSH
88642: LD_EXP 97
88646: PUSH
88647: LD_VAR 0 4
88651: ARRAY
88652: LESS
88653: PUSH
88654: LD_VAR 0 1
88658: PPUSH
88659: CALL_OW 264
88663: PUSH
88664: LD_INT 31
88666: PUSH
88667: LD_INT 32
88669: PUSH
88670: LD_INT 51
88672: PUSH
88673: LD_EXP 2
88677: PUSH
88678: LD_INT 12
88680: PUSH
88681: LD_INT 30
88683: PUSH
88684: LD_EXP 1
88688: PUSH
88689: LD_INT 11
88691: PUSH
88692: LD_INT 53
88694: PUSH
88695: LD_INT 14
88697: PUSH
88698: LD_EXP 5
88702: PUSH
88703: LD_INT 29
88705: PUSH
88706: LD_EXP 3
88710: PUSH
88711: LD_INT 13
88713: PUSH
88714: LD_INT 52
88716: PUSH
88717: LD_EXP 7
88721: PUSH
88722: LD_INT 48
88724: PUSH
88725: LD_INT 8
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: IN
88748: NOT
88749: AND
88750: IFFALSE 88798
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88752: LD_ADDR_EXP 108
88756: PUSH
88757: LD_EXP 108
88761: PPUSH
88762: LD_VAR 0 4
88766: PUSH
88767: LD_EXP 108
88771: PUSH
88772: LD_VAR 0 4
88776: ARRAY
88777: PUSH
88778: LD_INT 1
88780: PLUS
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PPUSH
88786: LD_VAR 0 1
88790: PPUSH
88791: CALL 22451 0 3
88795: ST_TO_ADDR
88796: GO 88842
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88798: LD_ADDR_EXP 105
88802: PUSH
88803: LD_EXP 105
88807: PPUSH
88808: LD_VAR 0 4
88812: PUSH
88813: LD_EXP 105
88817: PUSH
88818: LD_VAR 0 4
88822: ARRAY
88823: PUSH
88824: LD_INT 1
88826: PLUS
88827: PUSH
88828: EMPTY
88829: LIST
88830: LIST
88831: PPUSH
88832: LD_VAR 0 1
88836: PPUSH
88837: CALL 22451 0 3
88841: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88842: LD_VAR 0 1
88846: PPUSH
88847: CALL_OW 263
88851: PUSH
88852: LD_INT 2
88854: EQUAL
88855: IFFALSE 88875
// begin repeat wait ( 0 0$1 ) ;
88857: LD_INT 35
88859: PPUSH
88860: CALL_OW 67
// until IsControledBy ( vehicle ) ;
88864: LD_VAR 0 1
88868: PPUSH
88869: CALL_OW 312
88873: IFFALSE 88857
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88875: LD_VAR 0 1
88879: PPUSH
88880: LD_EXP 110
88884: PUSH
88885: LD_VAR 0 4
88889: ARRAY
88890: PPUSH
88891: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88895: LD_VAR 0 1
88899: PPUSH
88900: CALL_OW 263
88904: PUSH
88905: LD_INT 1
88907: NONEQUAL
88908: IFFALSE 88912
// break ;
88910: GO 88961
// repeat wait ( 0 0$1 ) ;
88912: LD_INT 35
88914: PPUSH
88915: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88919: LD_VAR 0 1
88923: PPUSH
88924: LD_EXP 110
88928: PUSH
88929: LD_VAR 0 4
88933: ARRAY
88934: PPUSH
88935: CALL_OW 308
88939: IFFALSE 88912
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88941: LD_VAR 0 1
88945: PPUSH
88946: CALL_OW 311
88950: PPUSH
88951: CALL_OW 121
// exit ;
88955: POP
88956: POP
88957: GO 88963
// end ; end ;
88959: GO 88610
88961: POP
88962: POP
// end ;
88963: LD_VAR 0 3
88967: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88968: LD_INT 0
88970: PPUSH
88971: PPUSH
88972: PPUSH
88973: PPUSH
// if not mc_bases or not skirmish then
88974: LD_EXP 86
88978: NOT
88979: PUSH
88980: LD_EXP 84
88984: NOT
88985: OR
88986: IFFALSE 88990
// exit ;
88988: GO 89343
// repeat wait ( 0 0$1 ) ;
88990: LD_INT 35
88992: PPUSH
88993: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88997: LD_VAR 0 2
89001: PPUSH
89002: LD_VAR 0 3
89006: PPUSH
89007: CALL_OW 284
89011: IFFALSE 88990
// if GetResourceTypeXY ( x , y ) = mat_artefact then
89013: LD_VAR 0 2
89017: PPUSH
89018: LD_VAR 0 3
89022: PPUSH
89023: CALL_OW 283
89027: PUSH
89028: LD_INT 4
89030: EQUAL
89031: IFFALSE 89035
// exit ;
89033: GO 89343
// for i = 1 to mc_bases do
89035: LD_ADDR_VAR 0 7
89039: PUSH
89040: DOUBLE
89041: LD_INT 1
89043: DEC
89044: ST_TO_ADDR
89045: LD_EXP 86
89049: PUSH
89050: FOR_TO
89051: IFFALSE 89341
// begin if mc_crates_area [ i ] then
89053: LD_EXP 104
89057: PUSH
89058: LD_VAR 0 7
89062: ARRAY
89063: IFFALSE 89174
// for j in mc_crates_area [ i ] do
89065: LD_ADDR_VAR 0 8
89069: PUSH
89070: LD_EXP 104
89074: PUSH
89075: LD_VAR 0 7
89079: ARRAY
89080: PUSH
89081: FOR_IN
89082: IFFALSE 89172
// if InArea ( x , y , j ) then
89084: LD_VAR 0 2
89088: PPUSH
89089: LD_VAR 0 3
89093: PPUSH
89094: LD_VAR 0 8
89098: PPUSH
89099: CALL_OW 309
89103: IFFALSE 89170
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
89105: LD_ADDR_EXP 102
89109: PUSH
89110: LD_EXP 102
89114: PPUSH
89115: LD_VAR 0 7
89119: PUSH
89120: LD_EXP 102
89124: PUSH
89125: LD_VAR 0 7
89129: ARRAY
89130: PUSH
89131: LD_INT 1
89133: PLUS
89134: PUSH
89135: EMPTY
89136: LIST
89137: LIST
89138: PPUSH
89139: LD_VAR 0 4
89143: PUSH
89144: LD_VAR 0 2
89148: PUSH
89149: LD_VAR 0 3
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: LIST
89158: PPUSH
89159: CALL 22451 0 3
89163: ST_TO_ADDR
// exit ;
89164: POP
89165: POP
89166: POP
89167: POP
89168: GO 89343
// end ;
89170: GO 89081
89172: POP
89173: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89174: LD_ADDR_VAR 0 9
89178: PUSH
89179: LD_EXP 86
89183: PUSH
89184: LD_VAR 0 7
89188: ARRAY
89189: PPUSH
89190: LD_INT 2
89192: PUSH
89193: LD_INT 30
89195: PUSH
89196: LD_INT 0
89198: PUSH
89199: EMPTY
89200: LIST
89201: LIST
89202: PUSH
89203: LD_INT 30
89205: PUSH
89206: LD_INT 1
89208: PUSH
89209: EMPTY
89210: LIST
89211: LIST
89212: PUSH
89213: EMPTY
89214: LIST
89215: LIST
89216: LIST
89217: PPUSH
89218: CALL_OW 72
89222: ST_TO_ADDR
// if not depot then
89223: LD_VAR 0 9
89227: NOT
89228: IFFALSE 89232
// continue ;
89230: GO 89050
// for j in depot do
89232: LD_ADDR_VAR 0 8
89236: PUSH
89237: LD_VAR 0 9
89241: PUSH
89242: FOR_IN
89243: IFFALSE 89337
// if GetDistUnitXY ( j , x , y ) < 30 then
89245: LD_VAR 0 8
89249: PPUSH
89250: LD_VAR 0 2
89254: PPUSH
89255: LD_VAR 0 3
89259: PPUSH
89260: CALL_OW 297
89264: PUSH
89265: LD_INT 30
89267: LESS
89268: IFFALSE 89335
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
89270: LD_ADDR_EXP 102
89274: PUSH
89275: LD_EXP 102
89279: PPUSH
89280: LD_VAR 0 7
89284: PUSH
89285: LD_EXP 102
89289: PUSH
89290: LD_VAR 0 7
89294: ARRAY
89295: PUSH
89296: LD_INT 1
89298: PLUS
89299: PUSH
89300: EMPTY
89301: LIST
89302: LIST
89303: PPUSH
89304: LD_VAR 0 4
89308: PUSH
89309: LD_VAR 0 2
89313: PUSH
89314: LD_VAR 0 3
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: LIST
89323: PPUSH
89324: CALL 22451 0 3
89328: ST_TO_ADDR
// exit ;
89329: POP
89330: POP
89331: POP
89332: POP
89333: GO 89343
// end ;
89335: GO 89242
89337: POP
89338: POP
// end ;
89339: GO 89050
89341: POP
89342: POP
// end ;
89343: LD_VAR 0 6
89347: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
89348: LD_INT 0
89350: PPUSH
89351: PPUSH
89352: PPUSH
89353: PPUSH
// if not mc_bases or not skirmish then
89354: LD_EXP 86
89358: NOT
89359: PUSH
89360: LD_EXP 84
89364: NOT
89365: OR
89366: IFFALSE 89370
// exit ;
89368: GO 89647
// side := GetSide ( lab ) ;
89370: LD_ADDR_VAR 0 4
89374: PUSH
89375: LD_VAR 0 2
89379: PPUSH
89380: CALL_OW 255
89384: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
89385: LD_VAR 0 4
89389: PUSH
89390: LD_EXP 112
89394: IN
89395: NOT
89396: PUSH
89397: LD_EXP 113
89401: NOT
89402: OR
89403: PUSH
89404: LD_EXP 86
89408: NOT
89409: OR
89410: IFFALSE 89414
// exit ;
89412: GO 89647
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
89414: LD_ADDR_EXP 113
89418: PUSH
89419: LD_EXP 113
89423: PPUSH
89424: LD_VAR 0 4
89428: PPUSH
89429: LD_EXP 113
89433: PUSH
89434: LD_VAR 0 4
89438: ARRAY
89439: PUSH
89440: LD_VAR 0 1
89444: DIFF
89445: PPUSH
89446: CALL_OW 1
89450: ST_TO_ADDR
// for i = 1 to mc_bases do
89451: LD_ADDR_VAR 0 5
89455: PUSH
89456: DOUBLE
89457: LD_INT 1
89459: DEC
89460: ST_TO_ADDR
89461: LD_EXP 86
89465: PUSH
89466: FOR_TO
89467: IFFALSE 89645
// begin if lab in mc_bases [ i ] then
89469: LD_VAR 0 2
89473: PUSH
89474: LD_EXP 86
89478: PUSH
89479: LD_VAR 0 5
89483: ARRAY
89484: IN
89485: IFFALSE 89643
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
89487: LD_VAR 0 1
89491: PUSH
89492: LD_INT 11
89494: PUSH
89495: LD_INT 4
89497: PUSH
89498: LD_INT 3
89500: PUSH
89501: LD_INT 2
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: IN
89510: PUSH
89511: LD_EXP 116
89515: PUSH
89516: LD_VAR 0 5
89520: ARRAY
89521: AND
89522: IFFALSE 89643
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
89524: LD_ADDR_VAR 0 6
89528: PUSH
89529: LD_EXP 116
89533: PUSH
89534: LD_VAR 0 5
89538: ARRAY
89539: PUSH
89540: LD_INT 1
89542: ARRAY
89543: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89544: LD_ADDR_EXP 116
89548: PUSH
89549: LD_EXP 116
89553: PPUSH
89554: LD_VAR 0 5
89558: PPUSH
89559: EMPTY
89560: PPUSH
89561: CALL_OW 1
89565: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
89566: LD_VAR 0 6
89570: PPUSH
89571: LD_INT 0
89573: PPUSH
89574: CALL_OW 109
// ComExitBuilding ( tmp ) ;
89578: LD_VAR 0 6
89582: PPUSH
89583: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
89587: LD_ADDR_EXP 115
89591: PUSH
89592: LD_EXP 115
89596: PPUSH
89597: LD_VAR 0 5
89601: PPUSH
89602: LD_EXP 115
89606: PUSH
89607: LD_VAR 0 5
89611: ARRAY
89612: PPUSH
89613: LD_INT 1
89615: PPUSH
89616: LD_VAR 0 6
89620: PPUSH
89621: CALL_OW 2
89625: PPUSH
89626: CALL_OW 1
89630: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
89631: LD_VAR 0 5
89635: PPUSH
89636: LD_INT 112
89638: PPUSH
89639: CALL 66476 0 2
// end ; end ; end ;
89643: GO 89466
89645: POP
89646: POP
// end ;
89647: LD_VAR 0 3
89651: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
89652: LD_INT 0
89654: PPUSH
89655: PPUSH
89656: PPUSH
89657: PPUSH
89658: PPUSH
89659: PPUSH
89660: PPUSH
89661: PPUSH
// if not mc_bases or not skirmish then
89662: LD_EXP 86
89666: NOT
89667: PUSH
89668: LD_EXP 84
89672: NOT
89673: OR
89674: IFFALSE 89678
// exit ;
89676: GO 91049
// for i = 1 to mc_bases do
89678: LD_ADDR_VAR 0 3
89682: PUSH
89683: DOUBLE
89684: LD_INT 1
89686: DEC
89687: ST_TO_ADDR
89688: LD_EXP 86
89692: PUSH
89693: FOR_TO
89694: IFFALSE 91047
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
89696: LD_VAR 0 1
89700: PUSH
89701: LD_EXP 86
89705: PUSH
89706: LD_VAR 0 3
89710: ARRAY
89711: IN
89712: PUSH
89713: LD_VAR 0 1
89717: PUSH
89718: LD_EXP 93
89722: PUSH
89723: LD_VAR 0 3
89727: ARRAY
89728: IN
89729: OR
89730: PUSH
89731: LD_VAR 0 1
89735: PUSH
89736: LD_EXP 108
89740: PUSH
89741: LD_VAR 0 3
89745: ARRAY
89746: IN
89747: OR
89748: PUSH
89749: LD_VAR 0 1
89753: PUSH
89754: LD_EXP 105
89758: PUSH
89759: LD_VAR 0 3
89763: ARRAY
89764: IN
89765: OR
89766: PUSH
89767: LD_VAR 0 1
89771: PUSH
89772: LD_EXP 115
89776: PUSH
89777: LD_VAR 0 3
89781: ARRAY
89782: IN
89783: OR
89784: PUSH
89785: LD_VAR 0 1
89789: PUSH
89790: LD_EXP 116
89794: PUSH
89795: LD_VAR 0 3
89799: ARRAY
89800: IN
89801: OR
89802: IFFALSE 91045
// begin if un in mc_ape [ i ] then
89804: LD_VAR 0 1
89808: PUSH
89809: LD_EXP 115
89813: PUSH
89814: LD_VAR 0 3
89818: ARRAY
89819: IN
89820: IFFALSE 89859
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89822: LD_ADDR_EXP 115
89826: PUSH
89827: LD_EXP 115
89831: PPUSH
89832: LD_VAR 0 3
89836: PPUSH
89837: LD_EXP 115
89841: PUSH
89842: LD_VAR 0 3
89846: ARRAY
89847: PUSH
89848: LD_VAR 0 1
89852: DIFF
89853: PPUSH
89854: CALL_OW 1
89858: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89859: LD_VAR 0 1
89863: PUSH
89864: LD_EXP 116
89868: PUSH
89869: LD_VAR 0 3
89873: ARRAY
89874: IN
89875: IFFALSE 89899
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89877: LD_ADDR_EXP 116
89881: PUSH
89882: LD_EXP 116
89886: PPUSH
89887: LD_VAR 0 3
89891: PPUSH
89892: EMPTY
89893: PPUSH
89894: CALL_OW 1
89898: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89899: LD_VAR 0 1
89903: PPUSH
89904: CALL_OW 247
89908: PUSH
89909: LD_INT 2
89911: EQUAL
89912: PUSH
89913: LD_VAR 0 1
89917: PPUSH
89918: CALL_OW 110
89922: PUSH
89923: LD_INT 20
89925: EQUAL
89926: PUSH
89927: LD_VAR 0 1
89931: PUSH
89932: LD_EXP 108
89936: PUSH
89937: LD_VAR 0 3
89941: ARRAY
89942: IN
89943: OR
89944: PUSH
89945: LD_VAR 0 1
89949: PPUSH
89950: CALL_OW 264
89954: PUSH
89955: LD_INT 12
89957: PUSH
89958: LD_INT 51
89960: PUSH
89961: LD_EXP 2
89965: PUSH
89966: LD_INT 32
89968: PUSH
89969: LD_INT 13
89971: PUSH
89972: LD_INT 52
89974: PUSH
89975: LD_INT 31
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: IN
89987: OR
89988: AND
89989: IFFALSE 90297
// begin if un in mc_defender [ i ] then
89991: LD_VAR 0 1
89995: PUSH
89996: LD_EXP 108
90000: PUSH
90001: LD_VAR 0 3
90005: ARRAY
90006: IN
90007: IFFALSE 90046
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90009: LD_ADDR_EXP 108
90013: PUSH
90014: LD_EXP 108
90018: PPUSH
90019: LD_VAR 0 3
90023: PPUSH
90024: LD_EXP 108
90028: PUSH
90029: LD_VAR 0 3
90033: ARRAY
90034: PUSH
90035: LD_VAR 0 1
90039: DIFF
90040: PPUSH
90041: CALL_OW 1
90045: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
90046: LD_ADDR_VAR 0 8
90050: PUSH
90051: LD_VAR 0 3
90055: PPUSH
90056: LD_INT 3
90058: PPUSH
90059: CALL 86696 0 2
90063: ST_TO_ADDR
// if fac then
90064: LD_VAR 0 8
90068: IFFALSE 90297
// begin for j in fac do
90070: LD_ADDR_VAR 0 4
90074: PUSH
90075: LD_VAR 0 8
90079: PUSH
90080: FOR_IN
90081: IFFALSE 90295
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
90083: LD_ADDR_VAR 0 9
90087: PUSH
90088: LD_VAR 0 8
90092: PPUSH
90093: LD_VAR 0 1
90097: PPUSH
90098: CALL_OW 265
90102: PPUSH
90103: LD_VAR 0 1
90107: PPUSH
90108: CALL_OW 262
90112: PPUSH
90113: LD_VAR 0 1
90117: PPUSH
90118: CALL_OW 263
90122: PPUSH
90123: LD_VAR 0 1
90127: PPUSH
90128: CALL_OW 264
90132: PPUSH
90133: CALL 19983 0 5
90137: ST_TO_ADDR
// if components then
90138: LD_VAR 0 9
90142: IFFALSE 90293
// begin if GetWeapon ( un ) = ar_control_tower then
90144: LD_VAR 0 1
90148: PPUSH
90149: CALL_OW 264
90153: PUSH
90154: LD_INT 31
90156: EQUAL
90157: IFFALSE 90274
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
90159: LD_VAR 0 1
90163: PPUSH
90164: CALL_OW 311
90168: PPUSH
90169: LD_INT 0
90171: PPUSH
90172: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
90176: LD_ADDR_EXP 126
90180: PUSH
90181: LD_EXP 126
90185: PPUSH
90186: LD_VAR 0 3
90190: PPUSH
90191: LD_EXP 126
90195: PUSH
90196: LD_VAR 0 3
90200: ARRAY
90201: PUSH
90202: LD_VAR 0 1
90206: PPUSH
90207: CALL_OW 311
90211: DIFF
90212: PPUSH
90213: CALL_OW 1
90217: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
90218: LD_ADDR_VAR 0 7
90222: PUSH
90223: LD_EXP 107
90227: PUSH
90228: LD_VAR 0 3
90232: ARRAY
90233: PPUSH
90234: LD_INT 1
90236: PPUSH
90237: LD_VAR 0 9
90241: PPUSH
90242: CALL_OW 2
90246: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
90247: LD_ADDR_EXP 107
90251: PUSH
90252: LD_EXP 107
90256: PPUSH
90257: LD_VAR 0 3
90261: PPUSH
90262: LD_VAR 0 7
90266: PPUSH
90267: CALL_OW 1
90271: ST_TO_ADDR
// end else
90272: GO 90291
// MC_InsertProduceList ( i , [ components ] ) ;
90274: LD_VAR 0 3
90278: PPUSH
90279: LD_VAR 0 9
90283: PUSH
90284: EMPTY
90285: LIST
90286: PPUSH
90287: CALL 86241 0 2
// break ;
90291: GO 90295
// end ; end ;
90293: GO 90080
90295: POP
90296: POP
// end ; end ; if GetType ( un ) = unit_building then
90297: LD_VAR 0 1
90301: PPUSH
90302: CALL_OW 247
90306: PUSH
90307: LD_INT 3
90309: EQUAL
90310: IFFALSE 90713
// begin btype := GetBType ( un ) ;
90312: LD_ADDR_VAR 0 5
90316: PUSH
90317: LD_VAR 0 1
90321: PPUSH
90322: CALL_OW 266
90326: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
90327: LD_VAR 0 5
90331: PUSH
90332: LD_INT 29
90334: PUSH
90335: LD_INT 30
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: IN
90342: IFFALSE 90415
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
90344: LD_VAR 0 1
90348: PPUSH
90349: CALL_OW 250
90353: PPUSH
90354: LD_VAR 0 1
90358: PPUSH
90359: CALL_OW 251
90363: PPUSH
90364: LD_VAR 0 1
90368: PPUSH
90369: CALL_OW 255
90373: PPUSH
90374: CALL_OW 440
90378: NOT
90379: IFFALSE 90415
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
90381: LD_VAR 0 1
90385: PPUSH
90386: CALL_OW 250
90390: PPUSH
90391: LD_VAR 0 1
90395: PPUSH
90396: CALL_OW 251
90400: PPUSH
90401: LD_VAR 0 1
90405: PPUSH
90406: CALL_OW 255
90410: PPUSH
90411: CALL_OW 441
// end ; if btype = b_warehouse then
90415: LD_VAR 0 5
90419: PUSH
90420: LD_INT 1
90422: EQUAL
90423: IFFALSE 90441
// begin btype := b_depot ;
90425: LD_ADDR_VAR 0 5
90429: PUSH
90430: LD_INT 0
90432: ST_TO_ADDR
// pos := 1 ;
90433: LD_ADDR_VAR 0 6
90437: PUSH
90438: LD_INT 1
90440: ST_TO_ADDR
// end ; if btype = b_factory then
90441: LD_VAR 0 5
90445: PUSH
90446: LD_INT 3
90448: EQUAL
90449: IFFALSE 90467
// begin btype := b_workshop ;
90451: LD_ADDR_VAR 0 5
90455: PUSH
90456: LD_INT 2
90458: ST_TO_ADDR
// pos := 1 ;
90459: LD_ADDR_VAR 0 6
90463: PUSH
90464: LD_INT 1
90466: ST_TO_ADDR
// end ; if btype = b_barracks then
90467: LD_VAR 0 5
90471: PUSH
90472: LD_INT 5
90474: EQUAL
90475: IFFALSE 90485
// btype := b_armoury ;
90477: LD_ADDR_VAR 0 5
90481: PUSH
90482: LD_INT 4
90484: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
90485: LD_VAR 0 5
90489: PUSH
90490: LD_INT 7
90492: PUSH
90493: LD_INT 8
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: IN
90500: IFFALSE 90510
// btype := b_lab ;
90502: LD_ADDR_VAR 0 5
90506: PUSH
90507: LD_INT 6
90509: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
90510: LD_ADDR_EXP 91
90514: PUSH
90515: LD_EXP 91
90519: PPUSH
90520: LD_VAR 0 3
90524: PUSH
90525: LD_EXP 91
90529: PUSH
90530: LD_VAR 0 3
90534: ARRAY
90535: PUSH
90536: LD_INT 1
90538: PLUS
90539: PUSH
90540: EMPTY
90541: LIST
90542: LIST
90543: PPUSH
90544: LD_VAR 0 5
90548: PUSH
90549: LD_VAR 0 1
90553: PPUSH
90554: CALL_OW 250
90558: PUSH
90559: LD_VAR 0 1
90563: PPUSH
90564: CALL_OW 251
90568: PUSH
90569: LD_VAR 0 1
90573: PPUSH
90574: CALL_OW 254
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: PPUSH
90585: CALL 22451 0 3
90589: ST_TO_ADDR
// if pos = 1 then
90590: LD_VAR 0 6
90594: PUSH
90595: LD_INT 1
90597: EQUAL
90598: IFFALSE 90713
// begin tmp := mc_build_list [ i ] ;
90600: LD_ADDR_VAR 0 7
90604: PUSH
90605: LD_EXP 91
90609: PUSH
90610: LD_VAR 0 3
90614: ARRAY
90615: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
90616: LD_VAR 0 7
90620: PPUSH
90621: LD_INT 2
90623: PUSH
90624: LD_INT 30
90626: PUSH
90627: LD_INT 0
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PUSH
90634: LD_INT 30
90636: PUSH
90637: LD_INT 1
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: LIST
90648: PPUSH
90649: CALL_OW 72
90653: IFFALSE 90663
// pos := 2 ;
90655: LD_ADDR_VAR 0 6
90659: PUSH
90660: LD_INT 2
90662: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
90663: LD_ADDR_VAR 0 7
90667: PUSH
90668: LD_VAR 0 7
90672: PPUSH
90673: LD_VAR 0 6
90677: PPUSH
90678: LD_VAR 0 7
90682: PPUSH
90683: CALL 22777 0 3
90687: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
90688: LD_ADDR_EXP 91
90692: PUSH
90693: LD_EXP 91
90697: PPUSH
90698: LD_VAR 0 3
90702: PPUSH
90703: LD_VAR 0 7
90707: PPUSH
90708: CALL_OW 1
90712: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
90713: LD_VAR 0 1
90717: PUSH
90718: LD_EXP 86
90722: PUSH
90723: LD_VAR 0 3
90727: ARRAY
90728: IN
90729: IFFALSE 90768
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90731: LD_ADDR_EXP 86
90735: PUSH
90736: LD_EXP 86
90740: PPUSH
90741: LD_VAR 0 3
90745: PPUSH
90746: LD_EXP 86
90750: PUSH
90751: LD_VAR 0 3
90755: ARRAY
90756: PUSH
90757: LD_VAR 0 1
90761: DIFF
90762: PPUSH
90763: CALL_OW 1
90767: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90768: LD_VAR 0 1
90772: PUSH
90773: LD_EXP 93
90777: PUSH
90778: LD_VAR 0 3
90782: ARRAY
90783: IN
90784: IFFALSE 90823
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90786: LD_ADDR_EXP 93
90790: PUSH
90791: LD_EXP 93
90795: PPUSH
90796: LD_VAR 0 3
90800: PPUSH
90801: LD_EXP 93
90805: PUSH
90806: LD_VAR 0 3
90810: ARRAY
90811: PUSH
90812: LD_VAR 0 1
90816: DIFF
90817: PPUSH
90818: CALL_OW 1
90822: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90823: LD_VAR 0 1
90827: PUSH
90828: LD_EXP 105
90832: PUSH
90833: LD_VAR 0 3
90837: ARRAY
90838: IN
90839: IFFALSE 90878
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90841: LD_ADDR_EXP 105
90845: PUSH
90846: LD_EXP 105
90850: PPUSH
90851: LD_VAR 0 3
90855: PPUSH
90856: LD_EXP 105
90860: PUSH
90861: LD_VAR 0 3
90865: ARRAY
90866: PUSH
90867: LD_VAR 0 1
90871: DIFF
90872: PPUSH
90873: CALL_OW 1
90877: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90878: LD_VAR 0 1
90882: PUSH
90883: LD_EXP 108
90887: PUSH
90888: LD_VAR 0 3
90892: ARRAY
90893: IN
90894: IFFALSE 90933
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90896: LD_ADDR_EXP 108
90900: PUSH
90901: LD_EXP 108
90905: PPUSH
90906: LD_VAR 0 3
90910: PPUSH
90911: LD_EXP 108
90915: PUSH
90916: LD_VAR 0 3
90920: ARRAY
90921: PUSH
90922: LD_VAR 0 1
90926: DIFF
90927: PPUSH
90928: CALL_OW 1
90932: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90933: LD_VAR 0 1
90937: PUSH
90938: LD_EXP 95
90942: PUSH
90943: LD_VAR 0 3
90947: ARRAY
90948: IN
90949: IFFALSE 90988
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90951: LD_ADDR_EXP 95
90955: PUSH
90956: LD_EXP 95
90960: PPUSH
90961: LD_VAR 0 3
90965: PPUSH
90966: LD_EXP 95
90970: PUSH
90971: LD_VAR 0 3
90975: ARRAY
90976: PUSH
90977: LD_VAR 0 1
90981: DIFF
90982: PPUSH
90983: CALL_OW 1
90987: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90988: LD_VAR 0 1
90992: PUSH
90993: LD_EXP 94
90997: PUSH
90998: LD_VAR 0 3
91002: ARRAY
91003: IN
91004: IFFALSE 91043
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
91006: LD_ADDR_EXP 94
91010: PUSH
91011: LD_EXP 94
91015: PPUSH
91016: LD_VAR 0 3
91020: PPUSH
91021: LD_EXP 94
91025: PUSH
91026: LD_VAR 0 3
91030: ARRAY
91031: PUSH
91032: LD_VAR 0 1
91036: DIFF
91037: PPUSH
91038: CALL_OW 1
91042: ST_TO_ADDR
// end ; break ;
91043: GO 91047
// end ;
91045: GO 89693
91047: POP
91048: POP
// end ;
91049: LD_VAR 0 2
91053: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
91054: LD_INT 0
91056: PPUSH
91057: PPUSH
91058: PPUSH
// if not mc_bases or not skirmish then
91059: LD_EXP 86
91063: NOT
91064: PUSH
91065: LD_EXP 84
91069: NOT
91070: OR
91071: IFFALSE 91075
// exit ;
91073: GO 91290
// for i = 1 to mc_bases do
91075: LD_ADDR_VAR 0 3
91079: PUSH
91080: DOUBLE
91081: LD_INT 1
91083: DEC
91084: ST_TO_ADDR
91085: LD_EXP 86
91089: PUSH
91090: FOR_TO
91091: IFFALSE 91288
// begin if building in mc_construct_list [ i ] then
91093: LD_VAR 0 1
91097: PUSH
91098: LD_EXP 93
91102: PUSH
91103: LD_VAR 0 3
91107: ARRAY
91108: IN
91109: IFFALSE 91286
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
91111: LD_ADDR_EXP 93
91115: PUSH
91116: LD_EXP 93
91120: PPUSH
91121: LD_VAR 0 3
91125: PPUSH
91126: LD_EXP 93
91130: PUSH
91131: LD_VAR 0 3
91135: ARRAY
91136: PUSH
91137: LD_VAR 0 1
91141: DIFF
91142: PPUSH
91143: CALL_OW 1
91147: ST_TO_ADDR
// if building in mc_lab [ i ] then
91148: LD_VAR 0 1
91152: PUSH
91153: LD_EXP 119
91157: PUSH
91158: LD_VAR 0 3
91162: ARRAY
91163: IN
91164: IFFALSE 91219
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
91166: LD_ADDR_EXP 120
91170: PUSH
91171: LD_EXP 120
91175: PPUSH
91176: LD_VAR 0 3
91180: PPUSH
91181: LD_EXP 120
91185: PUSH
91186: LD_VAR 0 3
91190: ARRAY
91191: PPUSH
91192: LD_INT 1
91194: PPUSH
91195: LD_EXP 120
91199: PUSH
91200: LD_VAR 0 3
91204: ARRAY
91205: PPUSH
91206: LD_INT 0
91208: PPUSH
91209: CALL 21869 0 4
91213: PPUSH
91214: CALL_OW 1
91218: ST_TO_ADDR
// if not building in mc_bases [ i ] then
91219: LD_VAR 0 1
91223: PUSH
91224: LD_EXP 86
91228: PUSH
91229: LD_VAR 0 3
91233: ARRAY
91234: IN
91235: NOT
91236: IFFALSE 91282
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
91238: LD_ADDR_EXP 86
91242: PUSH
91243: LD_EXP 86
91247: PPUSH
91248: LD_VAR 0 3
91252: PUSH
91253: LD_EXP 86
91257: PUSH
91258: LD_VAR 0 3
91262: ARRAY
91263: PUSH
91264: LD_INT 1
91266: PLUS
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PPUSH
91272: LD_VAR 0 1
91276: PPUSH
91277: CALL 22451 0 3
91281: ST_TO_ADDR
// exit ;
91282: POP
91283: POP
91284: GO 91290
// end ; end ;
91286: GO 91090
91288: POP
91289: POP
// end ;
91290: LD_VAR 0 2
91294: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
91295: LD_INT 0
91297: PPUSH
91298: PPUSH
91299: PPUSH
91300: PPUSH
91301: PPUSH
91302: PPUSH
91303: PPUSH
// if not mc_bases or not skirmish then
91304: LD_EXP 86
91308: NOT
91309: PUSH
91310: LD_EXP 84
91314: NOT
91315: OR
91316: IFFALSE 91320
// exit ;
91318: GO 91981
// for i = 1 to mc_bases do
91320: LD_ADDR_VAR 0 3
91324: PUSH
91325: DOUBLE
91326: LD_INT 1
91328: DEC
91329: ST_TO_ADDR
91330: LD_EXP 86
91334: PUSH
91335: FOR_TO
91336: IFFALSE 91979
// begin if building in mc_construct_list [ i ] then
91338: LD_VAR 0 1
91342: PUSH
91343: LD_EXP 93
91347: PUSH
91348: LD_VAR 0 3
91352: ARRAY
91353: IN
91354: IFFALSE 91977
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
91356: LD_ADDR_EXP 93
91360: PUSH
91361: LD_EXP 93
91365: PPUSH
91366: LD_VAR 0 3
91370: PPUSH
91371: LD_EXP 93
91375: PUSH
91376: LD_VAR 0 3
91380: ARRAY
91381: PUSH
91382: LD_VAR 0 1
91386: DIFF
91387: PPUSH
91388: CALL_OW 1
91392: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
91393: LD_ADDR_EXP 86
91397: PUSH
91398: LD_EXP 86
91402: PPUSH
91403: LD_VAR 0 3
91407: PUSH
91408: LD_EXP 86
91412: PUSH
91413: LD_VAR 0 3
91417: ARRAY
91418: PUSH
91419: LD_INT 1
91421: PLUS
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PPUSH
91427: LD_VAR 0 1
91431: PPUSH
91432: CALL 22451 0 3
91436: ST_TO_ADDR
// btype := GetBType ( building ) ;
91437: LD_ADDR_VAR 0 5
91441: PUSH
91442: LD_VAR 0 1
91446: PPUSH
91447: CALL_OW 266
91451: ST_TO_ADDR
// side := GetSide ( building ) ;
91452: LD_ADDR_VAR 0 8
91456: PUSH
91457: LD_VAR 0 1
91461: PPUSH
91462: CALL_OW 255
91466: ST_TO_ADDR
// if btype = b_lab then
91467: LD_VAR 0 5
91471: PUSH
91472: LD_INT 6
91474: EQUAL
91475: IFFALSE 91525
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
91477: LD_ADDR_EXP 119
91481: PUSH
91482: LD_EXP 119
91486: PPUSH
91487: LD_VAR 0 3
91491: PUSH
91492: LD_EXP 119
91496: PUSH
91497: LD_VAR 0 3
91501: ARRAY
91502: PUSH
91503: LD_INT 1
91505: PLUS
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PPUSH
91511: LD_VAR 0 1
91515: PPUSH
91516: CALL 22451 0 3
91520: ST_TO_ADDR
// exit ;
91521: POP
91522: POP
91523: GO 91981
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
91525: LD_VAR 0 5
91529: PUSH
91530: LD_INT 0
91532: PUSH
91533: LD_INT 2
91535: PUSH
91536: LD_INT 4
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: LIST
91543: IN
91544: IFFALSE 91668
// begin if btype = b_armoury then
91546: LD_VAR 0 5
91550: PUSH
91551: LD_INT 4
91553: EQUAL
91554: IFFALSE 91564
// btype := b_barracks ;
91556: LD_ADDR_VAR 0 5
91560: PUSH
91561: LD_INT 5
91563: ST_TO_ADDR
// if btype = b_depot then
91564: LD_VAR 0 5
91568: PUSH
91569: LD_INT 0
91571: EQUAL
91572: IFFALSE 91582
// btype := b_warehouse ;
91574: LD_ADDR_VAR 0 5
91578: PUSH
91579: LD_INT 1
91581: ST_TO_ADDR
// if btype = b_workshop then
91582: LD_VAR 0 5
91586: PUSH
91587: LD_INT 2
91589: EQUAL
91590: IFFALSE 91600
// btype := b_factory ;
91592: LD_ADDR_VAR 0 5
91596: PUSH
91597: LD_INT 3
91599: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
91600: LD_VAR 0 5
91604: PPUSH
91605: LD_VAR 0 8
91609: PPUSH
91610: CALL_OW 323
91614: PUSH
91615: LD_INT 1
91617: EQUAL
91618: IFFALSE 91664
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
91620: LD_ADDR_EXP 118
91624: PUSH
91625: LD_EXP 118
91629: PPUSH
91630: LD_VAR 0 3
91634: PUSH
91635: LD_EXP 118
91639: PUSH
91640: LD_VAR 0 3
91644: ARRAY
91645: PUSH
91646: LD_INT 1
91648: PLUS
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PPUSH
91654: LD_VAR 0 1
91658: PPUSH
91659: CALL 22451 0 3
91663: ST_TO_ADDR
// exit ;
91664: POP
91665: POP
91666: GO 91981
// end ; if btype in [ b_bunker , b_turret ] then
91668: LD_VAR 0 5
91672: PUSH
91673: LD_INT 32
91675: PUSH
91676: LD_INT 33
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: IN
91683: IFFALSE 91973
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
91685: LD_ADDR_EXP 94
91689: PUSH
91690: LD_EXP 94
91694: PPUSH
91695: LD_VAR 0 3
91699: PUSH
91700: LD_EXP 94
91704: PUSH
91705: LD_VAR 0 3
91709: ARRAY
91710: PUSH
91711: LD_INT 1
91713: PLUS
91714: PUSH
91715: EMPTY
91716: LIST
91717: LIST
91718: PPUSH
91719: LD_VAR 0 1
91723: PPUSH
91724: CALL 22451 0 3
91728: ST_TO_ADDR
// if btype = b_bunker then
91729: LD_VAR 0 5
91733: PUSH
91734: LD_INT 32
91736: EQUAL
91737: IFFALSE 91973
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91739: LD_ADDR_EXP 95
91743: PUSH
91744: LD_EXP 95
91748: PPUSH
91749: LD_VAR 0 3
91753: PUSH
91754: LD_EXP 95
91758: PUSH
91759: LD_VAR 0 3
91763: ARRAY
91764: PUSH
91765: LD_INT 1
91767: PLUS
91768: PUSH
91769: EMPTY
91770: LIST
91771: LIST
91772: PPUSH
91773: LD_VAR 0 1
91777: PPUSH
91778: CALL 22451 0 3
91782: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91783: LD_ADDR_VAR 0 6
91787: PUSH
91788: LD_EXP 86
91792: PUSH
91793: LD_VAR 0 3
91797: ARRAY
91798: PPUSH
91799: LD_INT 25
91801: PUSH
91802: LD_INT 1
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PUSH
91809: LD_INT 3
91811: PUSH
91812: LD_INT 54
91814: PUSH
91815: EMPTY
91816: LIST
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: PPUSH
91826: CALL_OW 72
91830: ST_TO_ADDR
// if tmp then
91831: LD_VAR 0 6
91835: IFFALSE 91841
// exit ;
91837: POP
91838: POP
91839: GO 91981
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91841: LD_ADDR_VAR 0 6
91845: PUSH
91846: LD_EXP 86
91850: PUSH
91851: LD_VAR 0 3
91855: ARRAY
91856: PPUSH
91857: LD_INT 2
91859: PUSH
91860: LD_INT 30
91862: PUSH
91863: LD_INT 4
91865: PUSH
91866: EMPTY
91867: LIST
91868: LIST
91869: PUSH
91870: LD_INT 30
91872: PUSH
91873: LD_INT 5
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: LIST
91884: PPUSH
91885: CALL_OW 72
91889: ST_TO_ADDR
// if not tmp then
91890: LD_VAR 0 6
91894: NOT
91895: IFFALSE 91901
// exit ;
91897: POP
91898: POP
91899: GO 91981
// for j in tmp do
91901: LD_ADDR_VAR 0 4
91905: PUSH
91906: LD_VAR 0 6
91910: PUSH
91911: FOR_IN
91912: IFFALSE 91971
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91914: LD_ADDR_VAR 0 7
91918: PUSH
91919: LD_VAR 0 4
91923: PPUSH
91924: CALL_OW 313
91928: PPUSH
91929: LD_INT 25
91931: PUSH
91932: LD_INT 1
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PPUSH
91939: CALL_OW 72
91943: ST_TO_ADDR
// if units then
91944: LD_VAR 0 7
91948: IFFALSE 91969
// begin ComExitBuilding ( units [ 1 ] ) ;
91950: LD_VAR 0 7
91954: PUSH
91955: LD_INT 1
91957: ARRAY
91958: PPUSH
91959: CALL_OW 122
// exit ;
91963: POP
91964: POP
91965: POP
91966: POP
91967: GO 91981
// end ; end ;
91969: GO 91911
91971: POP
91972: POP
// end ; end ; exit ;
91973: POP
91974: POP
91975: GO 91981
// end ; end ;
91977: GO 91335
91979: POP
91980: POP
// end ;
91981: LD_VAR 0 2
91985: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91986: LD_INT 0
91988: PPUSH
91989: PPUSH
91990: PPUSH
91991: PPUSH
91992: PPUSH
91993: PPUSH
91994: PPUSH
// if not mc_bases or not skirmish then
91995: LD_EXP 86
91999: NOT
92000: PUSH
92001: LD_EXP 84
92005: NOT
92006: OR
92007: IFFALSE 92011
// exit ;
92009: GO 92242
// btype := GetBType ( building ) ;
92011: LD_ADDR_VAR 0 6
92015: PUSH
92016: LD_VAR 0 1
92020: PPUSH
92021: CALL_OW 266
92025: ST_TO_ADDR
// x := GetX ( building ) ;
92026: LD_ADDR_VAR 0 7
92030: PUSH
92031: LD_VAR 0 1
92035: PPUSH
92036: CALL_OW 250
92040: ST_TO_ADDR
// y := GetY ( building ) ;
92041: LD_ADDR_VAR 0 8
92045: PUSH
92046: LD_VAR 0 1
92050: PPUSH
92051: CALL_OW 251
92055: ST_TO_ADDR
// d := GetDir ( building ) ;
92056: LD_ADDR_VAR 0 9
92060: PUSH
92061: LD_VAR 0 1
92065: PPUSH
92066: CALL_OW 254
92070: ST_TO_ADDR
// for i = 1 to mc_bases do
92071: LD_ADDR_VAR 0 4
92075: PUSH
92076: DOUBLE
92077: LD_INT 1
92079: DEC
92080: ST_TO_ADDR
92081: LD_EXP 86
92085: PUSH
92086: FOR_TO
92087: IFFALSE 92240
// begin if not mc_build_list [ i ] then
92089: LD_EXP 91
92093: PUSH
92094: LD_VAR 0 4
92098: ARRAY
92099: NOT
92100: IFFALSE 92104
// continue ;
92102: GO 92086
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
92104: LD_VAR 0 6
92108: PUSH
92109: LD_VAR 0 7
92113: PUSH
92114: LD_VAR 0 8
92118: PUSH
92119: LD_VAR 0 9
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: PPUSH
92130: LD_EXP 91
92134: PUSH
92135: LD_VAR 0 4
92139: ARRAY
92140: PUSH
92141: LD_INT 1
92143: ARRAY
92144: PPUSH
92145: CALL 28658 0 2
92149: IFFALSE 92238
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
92151: LD_ADDR_EXP 91
92155: PUSH
92156: LD_EXP 91
92160: PPUSH
92161: LD_VAR 0 4
92165: PPUSH
92166: LD_EXP 91
92170: PUSH
92171: LD_VAR 0 4
92175: ARRAY
92176: PPUSH
92177: LD_INT 1
92179: PPUSH
92180: CALL_OW 3
92184: PPUSH
92185: CALL_OW 1
92189: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
92190: LD_ADDR_EXP 93
92194: PUSH
92195: LD_EXP 93
92199: PPUSH
92200: LD_VAR 0 4
92204: PUSH
92205: LD_EXP 93
92209: PUSH
92210: LD_VAR 0 4
92214: ARRAY
92215: PUSH
92216: LD_INT 1
92218: PLUS
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PPUSH
92224: LD_VAR 0 1
92228: PPUSH
92229: CALL 22451 0 3
92233: ST_TO_ADDR
// exit ;
92234: POP
92235: POP
92236: GO 92242
// end ; end ;
92238: GO 92086
92240: POP
92241: POP
// end ;
92242: LD_VAR 0 3
92246: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
92247: LD_INT 0
92249: PPUSH
92250: PPUSH
92251: PPUSH
// if not mc_bases or not skirmish then
92252: LD_EXP 86
92256: NOT
92257: PUSH
92258: LD_EXP 84
92262: NOT
92263: OR
92264: IFFALSE 92268
// exit ;
92266: GO 92458
// for i = 1 to mc_bases do
92268: LD_ADDR_VAR 0 4
92272: PUSH
92273: DOUBLE
92274: LD_INT 1
92276: DEC
92277: ST_TO_ADDR
92278: LD_EXP 86
92282: PUSH
92283: FOR_TO
92284: IFFALSE 92371
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
92286: LD_VAR 0 1
92290: PUSH
92291: LD_EXP 94
92295: PUSH
92296: LD_VAR 0 4
92300: ARRAY
92301: IN
92302: PUSH
92303: LD_VAR 0 1
92307: PUSH
92308: LD_EXP 95
92312: PUSH
92313: LD_VAR 0 4
92317: ARRAY
92318: IN
92319: NOT
92320: AND
92321: IFFALSE 92369
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
92323: LD_ADDR_EXP 95
92327: PUSH
92328: LD_EXP 95
92332: PPUSH
92333: LD_VAR 0 4
92337: PUSH
92338: LD_EXP 95
92342: PUSH
92343: LD_VAR 0 4
92347: ARRAY
92348: PUSH
92349: LD_INT 1
92351: PLUS
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PPUSH
92357: LD_VAR 0 1
92361: PPUSH
92362: CALL 22451 0 3
92366: ST_TO_ADDR
// break ;
92367: GO 92371
// end ; end ;
92369: GO 92283
92371: POP
92372: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
92373: LD_VAR 0 1
92377: PPUSH
92378: CALL_OW 257
92382: PUSH
92383: LD_EXP 112
92387: IN
92388: PUSH
92389: LD_VAR 0 1
92393: PPUSH
92394: CALL_OW 266
92398: PUSH
92399: LD_INT 5
92401: EQUAL
92402: AND
92403: PUSH
92404: LD_VAR 0 2
92408: PPUSH
92409: CALL_OW 110
92413: PUSH
92414: LD_INT 18
92416: NONEQUAL
92417: AND
92418: IFFALSE 92458
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
92420: LD_VAR 0 2
92424: PPUSH
92425: CALL_OW 257
92429: PUSH
92430: LD_INT 5
92432: PUSH
92433: LD_INT 8
92435: PUSH
92436: LD_INT 9
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: LIST
92443: IN
92444: IFFALSE 92458
// SetClass ( unit , 1 ) ;
92446: LD_VAR 0 2
92450: PPUSH
92451: LD_INT 1
92453: PPUSH
92454: CALL_OW 336
// end ;
92458: LD_VAR 0 3
92462: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
92463: LD_INT 0
92465: PPUSH
92466: PPUSH
// if not mc_bases or not skirmish then
92467: LD_EXP 86
92471: NOT
92472: PUSH
92473: LD_EXP 84
92477: NOT
92478: OR
92479: IFFALSE 92483
// exit ;
92481: GO 92599
// if GetLives ( abandoned_vehicle ) > 250 then
92483: LD_VAR 0 2
92487: PPUSH
92488: CALL_OW 256
92492: PUSH
92493: LD_INT 250
92495: GREATER
92496: IFFALSE 92500
// exit ;
92498: GO 92599
// for i = 1 to mc_bases do
92500: LD_ADDR_VAR 0 6
92504: PUSH
92505: DOUBLE
92506: LD_INT 1
92508: DEC
92509: ST_TO_ADDR
92510: LD_EXP 86
92514: PUSH
92515: FOR_TO
92516: IFFALSE 92597
// begin if driver in mc_bases [ i ] then
92518: LD_VAR 0 1
92522: PUSH
92523: LD_EXP 86
92527: PUSH
92528: LD_VAR 0 6
92532: ARRAY
92533: IN
92534: IFFALSE 92595
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
92536: LD_VAR 0 1
92540: PPUSH
92541: LD_EXP 86
92545: PUSH
92546: LD_VAR 0 6
92550: ARRAY
92551: PPUSH
92552: LD_INT 2
92554: PUSH
92555: LD_INT 30
92557: PUSH
92558: LD_INT 0
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: PUSH
92565: LD_INT 30
92567: PUSH
92568: LD_INT 1
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: EMPTY
92576: LIST
92577: LIST
92578: LIST
92579: PPUSH
92580: CALL_OW 72
92584: PUSH
92585: LD_INT 1
92587: ARRAY
92588: PPUSH
92589: CALL 54694 0 2
// break ;
92593: GO 92597
// end ; end ;
92595: GO 92515
92597: POP
92598: POP
// end ;
92599: LD_VAR 0 5
92603: RET
