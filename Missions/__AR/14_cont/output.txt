// export side_Neutral , side_Ru , side_Ar , side_Le , side_Upr ; export Burlak ; export Belkov , Gnyevko , Kirilenkova ; export Kovalyuk , Scholtze ; export Kuzmov ; export Karamazov , Petrovova , Gleb , Petrosyan ; export Lipshchin , Titov , Dolgov , Xavier ; export Oblukov , Kozlov , Kapitsova ; export Ostatni ; export Masha ; export Gladkov , GladkovFake ; export Heike , Farmer , Bergkamp ; export Abdul , Omar ; export MercPaid , MercAccepted , MercHandedOver , BehemothSeen ; export HeikeKilled , OmarKilled ; export Rusove , Rusove2 ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: LD_VAR 0 1
   7: PPUSH
   8: CALL_OW 28
  12: IFFALSE 31
// Result = CreateCharacter ( Ident ) else
  14: LD_ADDR_VAR 0 2
  18: PUSH
  19: LD_VAR 0 1
  23: PPUSH
  24: CALL_OW 34
  28: ST_TO_ADDR
  29: GO 46
// Result = NewCharacter ( Ident ) ;
  31: LD_ADDR_VAR 0 2
  35: PUSH
  36: LD_VAR 0 1
  40: PPUSH
  41: CALL_OW 25
  45: ST_TO_ADDR
// end ;
  46: LD_VAR 0 2
  50: RET
// function load_set ( Ident ) ; begin
  51: LD_INT 0
  53: PPUSH
// if TestCharacters ( Ident ) then
  54: LD_VAR 0 1
  58: PPUSH
  59: CALL_OW 28
  63: IFFALSE 82
// Result = CreateCharacterSet ( Ident ) else
  65: LD_ADDR_VAR 0 2
  69: PUSH
  70: LD_VAR 0 1
  74: PPUSH
  75: CALL_OW 31
  79: ST_TO_ADDR
  80: GO 89
// Result = [ ] ;
  82: LD_ADDR_VAR 0 2
  86: PUSH
  87: EMPTY
  88: ST_TO_ADDR
// end ;
  89: LD_VAR 0 2
  93: RET
// function vytvor_gladkova ; begin
  94: LD_INT 0
  96: PPUSH
// UC_Nation = NATION_RUSSIAN ;
  97: LD_ADDR_OWVAR 21
 101: PUSH
 102: LD_INT 3
 104: ST_TO_ADDR
// UC_side = side_Ru ;
 105: LD_ADDR_OWVAR 20
 109: PUSH
 110: LD_EXP 2
 114: ST_TO_ADDR
// HC_name =  ;
 115: LD_ADDR_OWVAR 26
 119: PUSH
 120: LD_STRING 
 122: ST_TO_ADDR
// HC_sex = SEX_MALE ;
 123: LD_ADDR_OWVAR 27
 127: PUSH
 128: LD_INT 1
 130: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 131: LD_ADDR_OWVAR 28
 135: PUSH
 136: LD_INT 1
 138: ST_TO_ADDR
// PrepareSoldierSkills ( 7 ) ;
 139: LD_INT 7
 141: PPUSH
 142: CALL_OW 375
// Result = CreateHuman ;
 146: LD_ADDR_VAR 0 1
 150: PUSH
 151: CALL_OW 44
 155: ST_TO_ADDR
// end ;
 156: LD_VAR 0 1
 160: RET
// function load ; var MashaSpec ; begin
 161: LD_INT 0
 163: PPUSH
 164: PPUSH
// AutoEnemy = false ;
 165: LD_ADDR_OWVAR 74
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// MercPaid = LoadVariable ( MercPaid , false ) ;
 173: LD_ADDR_EXP 33
 177: PUSH
 178: LD_STRING MercPaid
 180: PPUSH
 181: LD_INT 0
 183: PPUSH
 184: CALL_OW 30
 188: ST_TO_ADDR
// MercAccepted = LoadVariable ( MercAccepted , false ) ;
 189: LD_ADDR_EXP 34
 193: PUSH
 194: LD_STRING MercAccepted
 196: PPUSH
 197: LD_INT 0
 199: PPUSH
 200: CALL_OW 30
 204: ST_TO_ADDR
// MercHandedOver = LoadVariable ( MercHandedOver , false ) ;
 205: LD_ADDR_EXP 35
 209: PUSH
 210: LD_STRING MercHandedOver
 212: PPUSH
 213: LD_INT 0
 215: PPUSH
 216: CALL_OW 30
 220: ST_TO_ADDR
// BehemothSeen = LoadVariable ( BehemothSeen , false ) ;
 221: LD_ADDR_EXP 36
 225: PUSH
 226: LD_STRING BehemothSeen
 228: PPUSH
 229: LD_INT 0
 231: PPUSH
 232: CALL_OW 30
 236: ST_TO_ADDR
// HeikeKilled = LoadVariable ( HeikeKilled , false ) ;
 237: LD_ADDR_EXP 37
 241: PUSH
 242: LD_STRING HeikeKilled
 244: PPUSH
 245: LD_INT 0
 247: PPUSH
 248: CALL_OW 30
 252: ST_TO_ADDR
// OmarKilled = LoadVariable ( OmarKilled , false ) ;
 253: LD_ADDR_EXP 38
 257: PUSH
 258: LD_STRING OmarKilled
 260: PPUSH
 261: LD_INT 0
 263: PPUSH
 264: CALL_OW 30
 268: ST_TO_ADDR
// UC_Side = side_Le ;
 269: LD_ADDR_OWVAR 20
 273: PUSH
 274: LD_EXP 4
 278: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
 279: LD_ADDR_OWVAR 21
 283: PUSH
 284: LD_INT 2
 286: ST_TO_ADDR
// Heike = load_char ( Heike ) ;
 287: LD_ADDR_EXP 28
 291: PUSH
 292: LD_STRING Heike
 294: PPUSH
 295: CALL 0 0 1
 299: ST_TO_ADDR
// Farmer = load_char ( Farmer ) ;
 300: LD_ADDR_EXP 29
 304: PUSH
 305: LD_STRING Farmer
 307: PPUSH
 308: CALL 0 0 1
 312: ST_TO_ADDR
// Bergkamp = load_char ( Bergkamp ) ;
 313: LD_ADDR_EXP 30
 317: PUSH
 318: LD_STRING Bergkamp
 320: PPUSH
 321: CALL 0 0 1
 325: ST_TO_ADDR
// UC_Side = side_Ar ;
 326: LD_ADDR_OWVAR 20
 330: PUSH
 331: LD_EXP 3
 335: ST_TO_ADDR
// Abdul = load_char ( Abdul ) ;
 336: LD_ADDR_EXP 31
 340: PUSH
 341: LD_STRING Abdul
 343: PPUSH
 344: CALL 0 0 1
 348: ST_TO_ADDR
// if not OmarKilled then
 349: LD_EXP 38
 353: NOT
 354: IFFALSE 369
// Omar = load_char ( Omar ) ;
 356: LD_ADDR_EXP 32
 360: PUSH
 361: LD_STRING Omar
 363: PPUSH
 364: CALL 0 0 1
 368: ST_TO_ADDR
// UC_Side = side_Ru ;
 369: LD_ADDR_OWVAR 20
 373: PUSH
 374: LD_EXP 2
 378: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
 379: LD_ADDR_OWVAR 21
 383: PUSH
 384: LD_INT 3
 386: ST_TO_ADDR
// Gladkov = load_char ( Gladkov ) ;
 387: LD_ADDR_EXP 26
 391: PUSH
 392: LD_STRING Gladkov
 394: PPUSH
 395: CALL 0 0 1
 399: ST_TO_ADDR
// if not Gladkov then
 400: LD_EXP 26
 404: NOT
 405: IFFALSE 417
// GladkovFake = vytvor_gladkova ;
 407: LD_ADDR_EXP 27
 411: PUSH
 412: CALL 94 0 0
 416: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
 417: LD_ADDR_EXP 6
 421: PUSH
 422: LD_STRING Burlak
 424: PPUSH
 425: CALL 0 0 1
 429: ST_TO_ADDR
// if LoadVariable ( GlebLoc , 0 ) = 14 then
 430: LD_STRING GlebLoc
 432: PPUSH
 433: LD_INT 0
 435: PPUSH
 436: CALL_OW 30
 440: PUSH
 441: LD_INT 14
 443: EQUAL
 444: IFFALSE 459
// Gleb = load_char ( Gleb ) ;
 446: LD_ADDR_EXP 15
 450: PUSH
 451: LD_STRING Gleb
 453: PPUSH
 454: CALL 0 0 1
 458: ST_TO_ADDR
// if LoadVariable ( BelkovLoc , 0 ) = 14 then
 459: LD_STRING BelkovLoc
 461: PPUSH
 462: LD_INT 0
 464: PPUSH
 465: CALL_OW 30
 469: PUSH
 470: LD_INT 14
 472: EQUAL
 473: IFFALSE 488
// Belkov = load_char ( Belkov ) ;
 475: LD_ADDR_EXP 7
 479: PUSH
 480: LD_STRING Belkov
 482: PPUSH
 483: CALL 0 0 1
 487: ST_TO_ADDR
// if LoadVariable ( GnyevkoLoc , 0 ) = 14 then
 488: LD_STRING GnyevkoLoc
 490: PPUSH
 491: LD_INT 0
 493: PPUSH
 494: CALL_OW 30
 498: PUSH
 499: LD_INT 14
 501: EQUAL
 502: IFFALSE 517
// Gnyevko = load_char ( Gnyevko ) ;
 504: LD_ADDR_EXP 8
 508: PUSH
 509: LD_STRING Gnyevko
 511: PPUSH
 512: CALL 0 0 1
 516: ST_TO_ADDR
// if LoadVariable ( KirilenkovaLoc , 0 ) = 14 then
 517: LD_STRING KirilenkovaLoc
 519: PPUSH
 520: LD_INT 0
 522: PPUSH
 523: CALL_OW 30
 527: PUSH
 528: LD_INT 14
 530: EQUAL
 531: IFFALSE 546
// Kirilenkova = load_char ( Kirilenkova ) ;
 533: LD_ADDR_EXP 9
 537: PUSH
 538: LD_STRING Kirilenkova
 540: PPUSH
 541: CALL 0 0 1
 545: ST_TO_ADDR
// if LoadVariable ( KovalyukLoc , 0 ) = 14 then
 546: LD_STRING KovalyukLoc
 548: PPUSH
 549: LD_INT 0
 551: PPUSH
 552: CALL_OW 30
 556: PUSH
 557: LD_INT 14
 559: EQUAL
 560: IFFALSE 575
// Kovalyuk = load_char ( Kovalyuk ) ;
 562: LD_ADDR_EXP 10
 566: PUSH
 567: LD_STRING Kovalyuk
 569: PPUSH
 570: CALL 0 0 1
 574: ST_TO_ADDR
// if LoadVariable ( ScholtzeLoc , 0 ) = 14 then
 575: LD_STRING ScholtzeLoc
 577: PPUSH
 578: LD_INT 0
 580: PPUSH
 581: CALL_OW 30
 585: PUSH
 586: LD_INT 14
 588: EQUAL
 589: IFFALSE 604
// Scholtze = load_char ( Scholtze ) ;
 591: LD_ADDR_EXP 11
 595: PUSH
 596: LD_STRING Scholtze
 598: PPUSH
 599: CALL 0 0 1
 603: ST_TO_ADDR
// if LoadVariable ( KuzmovLoc , 0 ) = 14 then
 604: LD_STRING KuzmovLoc
 606: PPUSH
 607: LD_INT 0
 609: PPUSH
 610: CALL_OW 30
 614: PUSH
 615: LD_INT 14
 617: EQUAL
 618: IFFALSE 633
// Kuzmov = load_char ( Kuzmov ) ;
 620: LD_ADDR_EXP 12
 624: PUSH
 625: LD_STRING Kuzmov
 627: PPUSH
 628: CALL 0 0 1
 632: ST_TO_ADDR
// if LoadVariable ( KaramazovLoc , 0 ) = 14 then
 633: LD_STRING KaramazovLoc
 635: PPUSH
 636: LD_INT 0
 638: PPUSH
 639: CALL_OW 30
 643: PUSH
 644: LD_INT 14
 646: EQUAL
 647: IFFALSE 662
// Karamazov = load_char ( Karamazov ) ;
 649: LD_ADDR_EXP 13
 653: PUSH
 654: LD_STRING Karamazov
 656: PPUSH
 657: CALL 0 0 1
 661: ST_TO_ADDR
// if LoadVariable ( PetrovovaLoc , 0 ) = 14 then
 662: LD_STRING PetrovovaLoc
 664: PPUSH
 665: LD_INT 0
 667: PPUSH
 668: CALL_OW 30
 672: PUSH
 673: LD_INT 14
 675: EQUAL
 676: IFFALSE 691
// Petrovova = load_char ( Petrovova ) ;
 678: LD_ADDR_EXP 14
 682: PUSH
 683: LD_STRING Petrovova
 685: PPUSH
 686: CALL 0 0 1
 690: ST_TO_ADDR
// if LoadVariable ( GlebLoc , 0 ) = 14 then
 691: LD_STRING GlebLoc
 693: PPUSH
 694: LD_INT 0
 696: PPUSH
 697: CALL_OW 30
 701: PUSH
 702: LD_INT 14
 704: EQUAL
 705: IFFALSE 720
// Gleb = load_char ( Gleb ) ;
 707: LD_ADDR_EXP 15
 711: PUSH
 712: LD_STRING Gleb
 714: PPUSH
 715: CALL 0 0 1
 719: ST_TO_ADDR
// if LoadVariable ( PetrosyanLoc , 0 ) = 14 then
 720: LD_STRING PetrosyanLoc
 722: PPUSH
 723: LD_INT 0
 725: PPUSH
 726: CALL_OW 30
 730: PUSH
 731: LD_INT 14
 733: EQUAL
 734: IFFALSE 749
// Petrosyan = load_char ( Petrosyan ) ;
 736: LD_ADDR_EXP 16
 740: PUSH
 741: LD_STRING Petrosyan
 743: PPUSH
 744: CALL 0 0 1
 748: ST_TO_ADDR
// if LoadVariable ( LipshchinLoc , 0 ) = 14 then
 749: LD_STRING LipshchinLoc
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL_OW 30
 759: PUSH
 760: LD_INT 14
 762: EQUAL
 763: IFFALSE 778
// Lipshchin = load_char ( Lipshchin ) ;
 765: LD_ADDR_EXP 17
 769: PUSH
 770: LD_STRING Lipshchin
 772: PPUSH
 773: CALL 0 0 1
 777: ST_TO_ADDR
// if LoadVariable ( TitovLoc , 0 ) = 14 then
 778: LD_STRING TitovLoc
 780: PPUSH
 781: LD_INT 0
 783: PPUSH
 784: CALL_OW 30
 788: PUSH
 789: LD_INT 14
 791: EQUAL
 792: IFFALSE 807
// Titov = load_char ( Titov ) ;
 794: LD_ADDR_EXP 18
 798: PUSH
 799: LD_STRING Titov
 801: PPUSH
 802: CALL 0 0 1
 806: ST_TO_ADDR
// if LoadVariable ( DolgovLoc , 0 ) = 14 then
 807: LD_STRING DolgovLoc
 809: PPUSH
 810: LD_INT 0
 812: PPUSH
 813: CALL_OW 30
 817: PUSH
 818: LD_INT 14
 820: EQUAL
 821: IFFALSE 836
// Dolgov = load_char ( Dolgov ) ;
 823: LD_ADDR_EXP 19
 827: PUSH
 828: LD_STRING Dolgov
 830: PPUSH
 831: CALL 0 0 1
 835: ST_TO_ADDR
// if LoadVariable ( XavierLoc , 0 ) = 14 then
 836: LD_STRING XavierLoc
 838: PPUSH
 839: LD_INT 0
 841: PPUSH
 842: CALL_OW 30
 846: PUSH
 847: LD_INT 14
 849: EQUAL
 850: IFFALSE 865
// Xavier = load_char ( Xavier ) ;
 852: LD_ADDR_EXP 20
 856: PUSH
 857: LD_STRING Xavier
 859: PPUSH
 860: CALL 0 0 1
 864: ST_TO_ADDR
// if LoadVariable ( OblukovLoc , 0 ) = 14 then
 865: LD_STRING OblukovLoc
 867: PPUSH
 868: LD_INT 0
 870: PPUSH
 871: CALL_OW 30
 875: PUSH
 876: LD_INT 14
 878: EQUAL
 879: IFFALSE 894
// Oblukov = load_char ( Oblukov ) ;
 881: LD_ADDR_EXP 21
 885: PUSH
 886: LD_STRING Oblukov
 888: PPUSH
 889: CALL 0 0 1
 893: ST_TO_ADDR
// if LoadVariable ( KozlovLoc , 0 ) = 14 then
 894: LD_STRING KozlovLoc
 896: PPUSH
 897: LD_INT 0
 899: PPUSH
 900: CALL_OW 30
 904: PUSH
 905: LD_INT 14
 907: EQUAL
 908: IFFALSE 923
// Kozlov = load_char ( Kozlov ) ;
 910: LD_ADDR_EXP 22
 914: PUSH
 915: LD_STRING Kozlov
 917: PPUSH
 918: CALL 0 0 1
 922: ST_TO_ADDR
// if LoadVariable ( KapitsovaLoc , 0 ) = 14 then
 923: LD_STRING KapitsovaLoc
 925: PPUSH
 926: LD_INT 0
 928: PPUSH
 929: CALL_OW 30
 933: PUSH
 934: LD_INT 14
 936: EQUAL
 937: IFFALSE 952
// Kapitsova = load_char ( Kapitsova ) ;
 939: LD_ADDR_EXP 23
 943: PUSH
 944: LD_STRING Kapitsova
 946: PPUSH
 947: CALL 0 0 1
 951: ST_TO_ADDR
// Ostatni = load_set ( Others_Ru14 ) ;
 952: LD_ADDR_EXP 24
 956: PUSH
 957: LD_STRING Others_Ru14
 959: PPUSH
 960: CALL 51 0 1
 964: ST_TO_ADDR
// DeleteCharacters ( Others_Ru14 ) ;
 965: LD_STRING Others_Ru14
 967: PPUSH
 968: CALL_OW 40
// MashaSpec = LoadVariable ( Masha , [ ] ) ;
 972: LD_ADDR_VAR 0 2
 976: PUSH
 977: LD_STRING Masha
 979: PPUSH
 980: EMPTY
 981: PPUSH
 982: CALL_OW 30
 986: ST_TO_ADDR
// if MashaSpec = 0 then
 987: LD_VAR 0 2
 991: PUSH
 992: LD_INT 0
 994: EQUAL
 995: IFFALSE 1007
// Masha = 0 else
 997: LD_ADDR_EXP 25
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
1005: GO 1153
// begin UC_Nation = NATION_RUSSIAN ;
1007: LD_ADDR_OWVAR 21
1011: PUSH
1012: LD_INT 3
1014: ST_TO_ADDR
// UC_Side = side_Ru ;
1015: LD_ADDR_OWVAR 20
1019: PUSH
1020: LD_EXP 2
1024: ST_TO_ADDR
// VC_Chassis = MashaSpec [ 1 ] ;
1025: LD_ADDR_OWVAR 37
1029: PUSH
1030: LD_VAR 0 2
1034: PUSH
1035: LD_INT 1
1037: ARRAY
1038: ST_TO_ADDR
// VC_Engine = MashaSpec [ 2 ] ;
1039: LD_ADDR_OWVAR 39
1043: PUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_INT 2
1051: ARRAY
1052: ST_TO_ADDR
// VC_Control = MashaSpec [ 3 ] ;
1053: LD_ADDR_OWVAR 38
1057: PUSH
1058: LD_VAR 0 2
1062: PUSH
1063: LD_INT 3
1065: ARRAY
1066: ST_TO_ADDR
// VC_Weapon = MashaSpec [ 4 ] ;
1067: LD_ADDR_OWVAR 40
1071: PUSH
1072: LD_VAR 0 2
1076: PUSH
1077: LD_INT 4
1079: ARRAY
1080: ST_TO_ADDR
// if ( VC_Weapon = 0 ) or ( VC_Control = 0 ) or ( VC_Engine = 0 ) or ( VC_Chassis = 0 ) then
1081: LD_OWVAR 40
1085: PUSH
1086: LD_INT 0
1088: EQUAL
1089: PUSH
1090: LD_OWVAR 38
1094: PUSH
1095: LD_INT 0
1097: EQUAL
1098: OR
1099: PUSH
1100: LD_OWVAR 39
1104: PUSH
1105: LD_INT 0
1107: EQUAL
1108: OR
1109: PUSH
1110: LD_OWVAR 37
1114: PUSH
1115: LD_INT 0
1117: EQUAL
1118: OR
1119: IFFALSE 1131
// Masha = 0 else
1121: LD_ADDR_EXP 25
1125: PUSH
1126: LD_INT 0
1128: ST_TO_ADDR
1129: GO 1153
// begin Masha = CreateVehicle ;
1131: LD_ADDR_EXP 25
1135: PUSH
1136: CALL_OW 45
1140: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
1141: LD_EXP 25
1145: PPUSH
1146: LD_INT 1
1148: PPUSH
1149: CALL_OW 242
// end ; end ; Rusove = ( [ Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] union Ostatni ) diff [ 0 ] ;
1153: LD_ADDR_EXP 39
1157: PUSH
1158: LD_EXP 15
1162: PUSH
1163: LD_EXP 7
1167: PUSH
1168: LD_EXP 8
1172: PUSH
1173: LD_EXP 9
1177: PUSH
1178: LD_EXP 10
1182: PUSH
1183: LD_EXP 11
1187: PUSH
1188: LD_EXP 12
1192: PUSH
1193: LD_EXP 13
1197: PUSH
1198: LD_EXP 14
1202: PUSH
1203: LD_EXP 15
1207: PUSH
1208: LD_EXP 16
1212: PUSH
1213: LD_EXP 17
1217: PUSH
1218: LD_EXP 18
1222: PUSH
1223: LD_EXP 19
1227: PUSH
1228: LD_EXP 20
1232: PUSH
1233: LD_EXP 21
1237: PUSH
1238: LD_EXP 22
1242: PUSH
1243: LD_EXP 23
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: LIST
1266: LIST
1267: PUSH
1268: LD_EXP 24
1272: UNION
1273: PUSH
1274: LD_INT 0
1276: PUSH
1277: EMPTY
1278: LIST
1279: DIFF
1280: ST_TO_ADDR
// Rusove2 = [ ] ;
1281: LD_ADDR_EXP 40
1285: PUSH
1286: EMPTY
1287: ST_TO_ADDR
// SetSide ( [ Burlak ] , side_Ru ) ;
1288: LD_EXP 6
1292: PUSH
1293: EMPTY
1294: LIST
1295: PPUSH
1296: LD_EXP 2
1300: PPUSH
1301: CALL_OW 235
// SetSide ( Rusove , side_Ru ) ;
1305: LD_EXP 39
1309: PPUSH
1310: LD_EXP 2
1314: PPUSH
1315: CALL_OW 235
// end ;
1319: LD_VAR 0 1
1323: RET
// function save_char ( Handle , Ident ) ; begin
1324: LD_INT 0
1326: PPUSH
// if Handle then
1327: LD_VAR 0 1
1331: IFFALSE 1350
// SaveCharacters ( [ Handle ] , Ident ) ;
1333: LD_VAR 0 1
1337: PUSH
1338: EMPTY
1339: LIST
1340: PPUSH
1341: LD_VAR 0 2
1345: PPUSH
1346: CALL_OW 38
// end ;
1350: LD_VAR 0 3
1354: RET
// function save ; var MashaSpec , Survivors4 , O , Opice ; begin
1355: LD_INT 0
1357: PPUSH
1358: PPUSH
1359: PPUSH
1360: PPUSH
1361: PPUSH
// SaveVariable ( LegieZnicena , LegionDestroyed ) ;
1362: LD_EXP 67
1366: PPUSH
1367: LD_STRING LegionDestroyed
1369: PPUSH
1370: CALL_OW 39
// if Masha and IsOk ( Masha ) and ( GetSide ( Masha ) = side_Ru ) then
1374: LD_EXP 25
1378: PUSH
1379: LD_EXP 25
1383: PPUSH
1384: CALL_OW 302
1388: AND
1389: PUSH
1390: LD_EXP 25
1394: PPUSH
1395: CALL_OW 255
1399: PUSH
1400: LD_EXP 2
1404: EQUAL
1405: AND
1406: IFFALSE 1410
// begin end else
1408: GO 1417
// DeleteVariable ( Masha ) ;
1410: LD_STRING Masha
1412: PPUSH
1413: CALL_OW 41
// save_char ( Burlak , Burlak ) ;
1417: LD_EXP 6
1421: PPUSH
1422: LD_STRING Burlak
1424: PPUSH
1425: CALL 1324 0 2
// save_char ( Gleb , Gleb ) ;
1429: LD_EXP 15
1433: PPUSH
1434: LD_STRING Gleb
1436: PPUSH
1437: CALL 1324 0 2
// save_char ( Belkov , Belkov ) ;
1441: LD_EXP 7
1445: PPUSH
1446: LD_STRING Belkov
1448: PPUSH
1449: CALL 1324 0 2
// save_char ( Gnyevko , Gnyevko ) ;
1453: LD_EXP 8
1457: PPUSH
1458: LD_STRING Gnyevko
1460: PPUSH
1461: CALL 1324 0 2
// save_char ( Kirilenkova , Kirilenkova ) ;
1465: LD_EXP 9
1469: PPUSH
1470: LD_STRING Kirilenkova
1472: PPUSH
1473: CALL 1324 0 2
// save_char ( Kovalyuk , Kovalyuk ) ;
1477: LD_EXP 10
1481: PPUSH
1482: LD_STRING Kovalyuk
1484: PPUSH
1485: CALL 1324 0 2
// save_char ( Scholtze , Scholtze ) ;
1489: LD_EXP 11
1493: PPUSH
1494: LD_STRING Scholtze
1496: PPUSH
1497: CALL 1324 0 2
// save_char ( Kuzmov , Kuzmov ) ;
1501: LD_EXP 12
1505: PPUSH
1506: LD_STRING Kuzmov
1508: PPUSH
1509: CALL 1324 0 2
// save_char ( Karamazov , Karamazov ) ;
1513: LD_EXP 13
1517: PPUSH
1518: LD_STRING Karamazov
1520: PPUSH
1521: CALL 1324 0 2
// save_char ( Petrovova , Petrovova ) ;
1525: LD_EXP 14
1529: PPUSH
1530: LD_STRING Petrovova
1532: PPUSH
1533: CALL 1324 0 2
// save_char ( Gleb , Gleb ) ;
1537: LD_EXP 15
1541: PPUSH
1542: LD_STRING Gleb
1544: PPUSH
1545: CALL 1324 0 2
// save_char ( Petrosyan , Petrosyan ) ;
1549: LD_EXP 16
1553: PPUSH
1554: LD_STRING Petrosyan
1556: PPUSH
1557: CALL 1324 0 2
// save_char ( Lipshchin , Lipshchin ) ;
1561: LD_EXP 17
1565: PPUSH
1566: LD_STRING Lipshchin
1568: PPUSH
1569: CALL 1324 0 2
// save_char ( Titov , Titov ) ;
1573: LD_EXP 18
1577: PPUSH
1578: LD_STRING Titov
1580: PPUSH
1581: CALL 1324 0 2
// save_char ( Dolgov , Dolgov ) ;
1585: LD_EXP 19
1589: PPUSH
1590: LD_STRING Dolgov
1592: PPUSH
1593: CALL 1324 0 2
// save_char ( Xavier , Xavier ) ;
1597: LD_EXP 20
1601: PPUSH
1602: LD_STRING Xavier
1604: PPUSH
1605: CALL 1324 0 2
// save_char ( Oblukov , Oblukov ) ;
1609: LD_EXP 21
1613: PPUSH
1614: LD_STRING Oblukov
1616: PPUSH
1617: CALL 1324 0 2
// save_char ( Kozlov , Kozlov ) ;
1621: LD_EXP 22
1625: PPUSH
1626: LD_STRING Kozlov
1628: PPUSH
1629: CALL 1324 0 2
// save_char ( Kapitsova , Kapitsova ) ;
1633: LD_EXP 23
1637: PPUSH
1638: LD_STRING Kapitsova
1640: PPUSH
1641: CALL 1324 0 2
// save_char ( Abdul , Abdul ) ;
1645: LD_EXP 31
1649: PPUSH
1650: LD_STRING Abdul
1652: PPUSH
1653: CALL 1324 0 2
// save_char ( Farmer , Farmer ) ;
1657: LD_EXP 29
1661: PPUSH
1662: LD_STRING Farmer
1664: PPUSH
1665: CALL 1324 0 2
// save_char ( Heike , Heike ) ;
1669: LD_EXP 28
1673: PPUSH
1674: LD_STRING Heike
1676: PPUSH
1677: CALL 1324 0 2
// Survivors4 = load_set ( Survivors4 ) ;
1681: LD_ADDR_VAR 0 3
1685: PUSH
1686: LD_STRING Survivors4
1688: PPUSH
1689: CALL 51 0 1
1693: ST_TO_ADDR
// O = Rusove diff [ 0 , Burlak , Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] ;
1694: LD_ADDR_VAR 0 4
1698: PUSH
1699: LD_EXP 39
1703: PUSH
1704: LD_INT 0
1706: PUSH
1707: LD_EXP 6
1711: PUSH
1712: LD_EXP 15
1716: PUSH
1717: LD_EXP 7
1721: PUSH
1722: LD_EXP 8
1726: PUSH
1727: LD_EXP 9
1731: PUSH
1732: LD_EXP 10
1736: PUSH
1737: LD_EXP 11
1741: PUSH
1742: LD_EXP 12
1746: PUSH
1747: LD_EXP 13
1751: PUSH
1752: LD_EXP 14
1756: PUSH
1757: LD_EXP 15
1761: PUSH
1762: LD_EXP 16
1766: PUSH
1767: LD_EXP 17
1771: PUSH
1772: LD_EXP 18
1776: PUSH
1777: LD_EXP 19
1781: PUSH
1782: LD_EXP 20
1786: PUSH
1787: LD_EXP 21
1791: PUSH
1792: LD_EXP 22
1796: PUSH
1797: LD_EXP 23
1801: PUSH
1802: EMPTY
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: LIST
1808: LIST
1809: LIST
1810: LIST
1811: LIST
1812: LIST
1813: LIST
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: DIFF
1824: ST_TO_ADDR
// Opice = UnitFilter ( Rusove , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
1825: LD_ADDR_VAR 0 5
1829: PUSH
1830: LD_EXP 39
1834: PPUSH
1835: LD_INT 2
1837: PUSH
1838: LD_INT 25
1840: PUSH
1841: LD_INT 12
1843: PUSH
1844: EMPTY
1845: LIST
1846: LIST
1847: PUSH
1848: LD_INT 25
1850: PUSH
1851: LD_INT 15
1853: PUSH
1854: EMPTY
1855: LIST
1856: LIST
1857: PUSH
1858: LD_INT 25
1860: PUSH
1861: LD_INT 16
1863: PUSH
1864: EMPTY
1865: LIST
1866: LIST
1867: PUSH
1868: LD_INT 25
1870: PUSH
1871: LD_INT 17
1873: PUSH
1874: EMPTY
1875: LIST
1876: LIST
1877: PUSH
1878: EMPTY
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: PUSH
1885: EMPTY
1886: LIST
1887: PPUSH
1888: CALL_OW 72
1892: ST_TO_ADDR
// O = O diff Opice ;
1893: LD_ADDR_VAR 0 4
1897: PUSH
1898: LD_VAR 0 4
1902: PUSH
1903: LD_VAR 0 5
1907: DIFF
1908: ST_TO_ADDR
// SaveCharacters ( Survivors4 union O , Survivors4 ) ;
1909: LD_VAR 0 3
1913: PUSH
1914: LD_VAR 0 4
1918: UNION
1919: PPUSH
1920: LD_STRING Survivors4
1922: PPUSH
1923: CALL_OW 38
// end ;
1927: LD_VAR 0 1
1931: RET
// function dej_medaile ; begin
1932: LD_INT 0
1934: PPUSH
// if not RusMaOtraveno then
1935: LD_EXP 64
1939: NOT
1940: IFFALSE 1954
// AddMedal ( Siberite , 1 ) else
1942: LD_STRING Siberite
1944: PPUSH
1945: LD_INT 1
1947: PPUSH
1948: CALL_OW 101
1952: GO 1984
// if RusMaSiberit then
1954: LD_EXP 63
1958: IFFALSE 1973
// AddMedal ( Siberite , - 1 ) else
1960: LD_STRING Siberite
1962: PPUSH
1963: LD_INT 1
1965: NEG
1966: PPUSH
1967: CALL_OW 101
1971: GO 1984
// AddMedal ( Siberite , - 2 ) ;
1973: LD_STRING Siberite
1975: PPUSH
1976: LD_INT 2
1978: NEG
1979: PPUSH
1980: CALL_OW 101
// if BehemothBuilt then
1984: LD_EXP 68
1988: IFFALSE 2002
// AddMedal ( Behemoth , 1 ) else
1990: LD_STRING Behemoth
1992: PPUSH
1993: LD_INT 1
1995: PPUSH
1996: CALL_OW 101
2000: GO 2013
// AddMedal ( Behemoth , - 1 ) ;
2002: LD_STRING Behemoth
2004: PPUSH
2005: LD_INT 1
2007: NEG
2008: PPUSH
2009: CALL_OW 101
// if MenLost <= 2 then
2013: LD_EXP 69
2017: PUSH
2018: LD_INT 2
2020: LESSEQUAL
2021: IFFALSE 2035
// AddMedal ( LittleLosses , 1 ) else
2023: LD_STRING LittleLosses
2025: PPUSH
2026: LD_INT 1
2028: PPUSH
2029: CALL_OW 101
2033: GO 2046
// AddMedal ( LittleLosses , - 1 ) ;
2035: LD_STRING LittleLosses
2037: PPUSH
2038: LD_INT 1
2040: NEG
2041: PPUSH
2042: CALL_OW 101
// end ;
2046: LD_VAR 0 1
2050: RET
// export function vyhral ; var Lidi , Opice ; begin
2051: LD_INT 0
2053: PPUSH
2054: PPUSH
2055: PPUSH
// dej_medaile ;
2056: CALL 1932 0 0
// GiveMedals ( Main ) ;
2060: LD_STRING Main
2062: PPUSH
2063: CALL_OW 102
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_ALIVE ] ] ) ;
2067: LD_ADDR_VAR 0 2
2071: PUSH
2072: LD_INT 22
2074: PUSH
2075: LD_EXP 2
2079: PUSH
2080: EMPTY
2081: LIST
2082: LIST
2083: PUSH
2084: LD_INT 21
2086: PUSH
2087: LD_INT 1
2089: PUSH
2090: EMPTY
2091: LIST
2092: LIST
2093: PUSH
2094: LD_INT 51
2096: PUSH
2097: EMPTY
2098: LIST
2099: PUSH
2100: EMPTY
2101: LIST
2102: LIST
2103: LIST
2104: PPUSH
2105: CALL_OW 69
2109: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
2110: LD_ADDR_VAR 0 3
2114: PUSH
2115: LD_VAR 0 2
2119: PPUSH
2120: LD_INT 2
2122: PUSH
2123: LD_INT 25
2125: PUSH
2126: LD_INT 12
2128: PUSH
2129: EMPTY
2130: LIST
2131: LIST
2132: PUSH
2133: LD_INT 25
2135: PUSH
2136: LD_INT 15
2138: PUSH
2139: EMPTY
2140: LIST
2141: LIST
2142: PUSH
2143: LD_INT 25
2145: PUSH
2146: LD_INT 16
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: LD_INT 25
2155: PUSH
2156: LD_INT 17
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: EMPTY
2164: LIST
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: EMPTY
2171: LIST
2172: PPUSH
2173: CALL_OW 72
2177: ST_TO_ADDR
// RewardPeople ( Lidi diff Opice ) ;
2178: LD_VAR 0 2
2182: PUSH
2183: LD_VAR 0 3
2187: DIFF
2188: PPUSH
2189: CALL_OW 43
// save ;
2193: CALL 1355 0 0
// YouWin ;
2197: CALL_OW 103
// end ;
2201: LD_VAR 0 1
2205: RET
// function set_attitudes ; begin
2206: LD_INT 0
2208: PPUSH
// SetAttitude ( side_Ru , side_Upr , ATT_NEUTRAL , true ) ;
2209: LD_EXP 2
2213: PPUSH
2214: LD_EXP 5
2218: PPUSH
2219: LD_INT 0
2221: PPUSH
2222: LD_INT 1
2224: PPUSH
2225: CALL_OW 80
// SetAttitude ( side_Le , side_Upr , ATT_FRIEND , true ) ;
2229: LD_EXP 4
2233: PPUSH
2234: LD_EXP 5
2238: PPUSH
2239: LD_INT 1
2241: PPUSH
2242: LD_INT 1
2244: PPUSH
2245: CALL_OW 80
// SetAttitude ( side_Ar , side_Upr , ATT_FRIEND , true ) ;
2249: LD_EXP 3
2253: PPUSH
2254: LD_EXP 5
2258: PPUSH
2259: LD_INT 1
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: CALL_OW 80
// SetAttitude ( side_Le , side_Ar , ATT_FRIEND , true ) ;
2269: LD_EXP 4
2273: PPUSH
2274: LD_EXP 3
2278: PPUSH
2279: LD_INT 1
2281: PPUSH
2282: LD_INT 1
2284: PPUSH
2285: CALL_OW 80
// end ;
2289: LD_VAR 0 1
2293: RET
// starting begin RandomizeAll ;
2294: CALL_OW 11
// InitUC ;
2298: CALL_OW 18
// InitBC ;
2302: CALL_OW 21
// InitVC ;
2306: CALL_OW 20
// InitHC ;
2310: CALL_OW 19
// side_Neutral = 0 ;
2314: LD_ADDR_EXP 1
2318: PUSH
2319: LD_INT 0
2321: ST_TO_ADDR
// side_Ru = 3 ;
2322: LD_ADDR_EXP 2
2326: PUSH
2327: LD_INT 3
2329: ST_TO_ADDR
// side_Ar = 2 ;
2330: LD_ADDR_EXP 3
2334: PUSH
2335: LD_INT 2
2337: ST_TO_ADDR
// side_Upr = 7 ;
2338: LD_ADDR_EXP 5
2342: PUSH
2343: LD_INT 7
2345: ST_TO_ADDR
// side_Le = 8 ;
2346: LD_ADDR_EXP 4
2350: PUSH
2351: LD_INT 8
2353: ST_TO_ADDR
// set_attitudes ;
2354: CALL 2206 0 0
// load ;
2358: CALL 161 0 0
// init_difficulty ;
2362: CALL 2391 0 0
// init_nature ;
2366: CALL 2998 0 0
// init_suroviny ;
2370: CALL 3075 0 0
// init_legion ;
2374: CALL 6079 0 0
// init_arabi ;
2378: CALL 11519 0 0
// init_rusove ;
2382: CALL 18890 0 0
// uvod ;
2386: CALL 18957 0 0
// end ; end_of_file
2390: END
// export dif_CekaniBednyRus , dif_PoctyBednyRus ; export dif_PoctyBednyStart , dif_PoctyBednyExtra ; export dif_LegionRidici , dif_AraboveRidici ; export dif_UtokSkupina , dif_CasovacUtoku , dif_PrvniUtok ; export dif_PstZbrane ; export dif_MaxOpice , dif_ZpozdeniOpice , dif_PstOpiceRus ; export dif_OpiceLimit , dif_OpiceNajednouPocet ; export dif_ArabiLidiVzdajSe ; export dif_LegionTimeout ; export function init_difficulty ; begin
2391: LD_INT 0
2393: PPUSH
// dif_CekaniBednyRus = [ [ 0 0$1 , 0 0$25 ] , [ 0 0$30 , 1 1$05 ] , [ 0 0$50 , 1 1$15 ] ] ;
2394: LD_ADDR_EXP 41
2398: PUSH
2399: LD_INT 35
2401: PUSH
2402: LD_INT 875
2404: PUSH
2405: EMPTY
2406: LIST
2407: LIST
2408: PUSH
2409: LD_INT 1050
2411: PUSH
2412: LD_INT 2275
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: PUSH
2419: LD_INT 1750
2421: PUSH
2422: LD_INT 2625
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PUSH
2429: EMPTY
2430: LIST
2431: LIST
2432: LIST
2433: ST_TO_ADDR
// dif_PoctyBednyRus = [ [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 5 ] ] ;
2434: LD_ADDR_EXP 42
2438: PUSH
2439: LD_INT 5
2441: PUSH
2442: LD_INT 5
2444: PUSH
2445: EMPTY
2446: LIST
2447: LIST
2448: PUSH
2449: LD_INT 4
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: PUSH
2459: LD_INT 3
2461: PUSH
2462: LD_INT 5
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: PUSH
2469: EMPTY
2470: LIST
2471: LIST
2472: LIST
2473: ST_TO_ADDR
// dif_PoctyBednyStart = [ 5 , 3 , 1 ] ;
2474: LD_ADDR_EXP 43
2478: PUSH
2479: LD_INT 5
2481: PUSH
2482: LD_INT 3
2484: PUSH
2485: LD_INT 1
2487: PUSH
2488: EMPTY
2489: LIST
2490: LIST
2491: LIST
2492: ST_TO_ADDR
// dif_PoctyBednyExtra = [ 10 , 5 , 0 ] ;
2493: LD_ADDR_EXP 44
2497: PUSH
2498: LD_INT 10
2500: PUSH
2501: LD_INT 5
2503: PUSH
2504: LD_INT 0
2506: PUSH
2507: EMPTY
2508: LIST
2509: LIST
2510: LIST
2511: ST_TO_ADDR
// dif_LegionRidici = [ 2 , 3 , 4 ] ;
2512: LD_ADDR_EXP 45
2516: PUSH
2517: LD_INT 2
2519: PUSH
2520: LD_INT 3
2522: PUSH
2523: LD_INT 4
2525: PUSH
2526: EMPTY
2527: LIST
2528: LIST
2529: LIST
2530: ST_TO_ADDR
// dif_AraboveRidici = [ 3 , 5 , 7 ] ;
2531: LD_ADDR_EXP 46
2535: PUSH
2536: LD_INT 3
2538: PUSH
2539: LD_INT 5
2541: PUSH
2542: LD_INT 7
2544: PUSH
2545: EMPTY
2546: LIST
2547: LIST
2548: LIST
2549: ST_TO_ADDR
// dif_PrvniUtok = [ [ 6 , 10 ] , [ 4 , 6 ] , [ 4 , 6 ] ] ;
2550: LD_ADDR_EXP 49
2554: PUSH
2555: LD_INT 6
2557: PUSH
2558: LD_INT 10
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PUSH
2565: LD_INT 4
2567: PUSH
2568: LD_INT 6
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: PUSH
2575: LD_INT 4
2577: PUSH
2578: LD_INT 6
2580: PUSH
2581: EMPTY
2582: LIST
2583: LIST
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: LIST
2589: ST_TO_ADDR
// dif_CasovacUtoku = [ [ 2 , 5 , 6 ] , [ 2 , 4 ] , [ 2 , 3 ] ] ;
2590: LD_ADDR_EXP 48
2594: PUSH
2595: LD_INT 2
2597: PUSH
2598: LD_INT 5
2600: PUSH
2601: LD_INT 6
2603: PUSH
2604: EMPTY
2605: LIST
2606: LIST
2607: LIST
2608: PUSH
2609: LD_INT 2
2611: PUSH
2612: LD_INT 4
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: PUSH
2619: LD_INT 2
2621: PUSH
2622: LD_INT 3
2624: PUSH
2625: EMPTY
2626: LIST
2627: LIST
2628: PUSH
2629: EMPTY
2630: LIST
2631: LIST
2632: LIST
2633: ST_TO_ADDR
// dif_UtokSkupina = [ 4 , 6 , 8 ] ;
2634: LD_ADDR_EXP 47
2638: PUSH
2639: LD_INT 4
2641: PUSH
2642: LD_INT 6
2644: PUSH
2645: LD_INT 8
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: LIST
2652: ST_TO_ADDR
// dif_PstZbrane = [ [ 20 , 40 , 80 , 100 ] , [ 25 , 50 , 75 , 100 ] , [ 30 , 60 , 55 , 100 ] ] ;
2653: LD_ADDR_EXP 50
2657: PUSH
2658: LD_INT 20
2660: PUSH
2661: LD_INT 40
2663: PUSH
2664: LD_INT 80
2666: PUSH
2667: LD_INT 100
2669: PUSH
2670: EMPTY
2671: LIST
2672: LIST
2673: LIST
2674: LIST
2675: PUSH
2676: LD_INT 25
2678: PUSH
2679: LD_INT 50
2681: PUSH
2682: LD_INT 75
2684: PUSH
2685: LD_INT 100
2687: PUSH
2688: EMPTY
2689: LIST
2690: LIST
2691: LIST
2692: LIST
2693: PUSH
2694: LD_INT 30
2696: PUSH
2697: LD_INT 60
2699: PUSH
2700: LD_INT 55
2702: PUSH
2703: LD_INT 100
2705: PUSH
2706: EMPTY
2707: LIST
2708: LIST
2709: LIST
2710: LIST
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: LIST
2716: ST_TO_ADDR
// dif_MaxOpice = [ 5 , 8 , 11 ] ;
2717: LD_ADDR_EXP 51
2721: PUSH
2722: LD_INT 5
2724: PUSH
2725: LD_INT 8
2727: PUSH
2728: LD_INT 11
2730: PUSH
2731: EMPTY
2732: LIST
2733: LIST
2734: LIST
2735: ST_TO_ADDR
// dif_ZpozdeniOpice = [ [ 2 2$0 , 3 3$4 ] , [ 1 1$0 , 2 2$0 ] , [ 0 , 1 1$0 ] ] ;
2736: LD_ADDR_EXP 52
2740: PUSH
2741: LD_INT 4200
2743: PUSH
2744: LD_INT 6440
2746: PUSH
2747: EMPTY
2748: LIST
2749: LIST
2750: PUSH
2751: LD_INT 2100
2753: PUSH
2754: LD_INT 4200
2756: PUSH
2757: EMPTY
2758: LIST
2759: LIST
2760: PUSH
2761: LD_INT 0
2763: PUSH
2764: LD_INT 2100
2766: PUSH
2767: EMPTY
2768: LIST
2769: LIST
2770: PUSH
2771: EMPTY
2772: LIST
2773: LIST
2774: LIST
2775: ST_TO_ADDR
// dif_PstOpiceRus = [ 60 , 40 , 15 ] ;
2776: LD_ADDR_EXP 53
2780: PUSH
2781: LD_INT 60
2783: PUSH
2784: LD_INT 40
2786: PUSH
2787: LD_INT 15
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: LIST
2794: ST_TO_ADDR
// dif_OpiceLimit = [ 10 , 25 , - 1 ] ;
2795: LD_ADDR_EXP 54
2799: PUSH
2800: LD_INT 10
2802: PUSH
2803: LD_INT 25
2805: PUSH
2806: LD_INT 1
2808: NEG
2809: PUSH
2810: EMPTY
2811: LIST
2812: LIST
2813: LIST
2814: ST_TO_ADDR
// dif_OpiceNajednouPocet = [ 1 , 2 , 4 ] ;
2815: LD_ADDR_EXP 55
2819: PUSH
2820: LD_INT 1
2822: PUSH
2823: LD_INT 2
2825: PUSH
2826: LD_INT 4
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: LIST
2833: ST_TO_ADDR
// dif_ArabiLidiVzdajSe = [ 6 , 4 , 2 ] ;
2834: LD_ADDR_EXP 56
2838: PUSH
2839: LD_INT 6
2841: PUSH
2842: LD_INT 4
2844: PUSH
2845: LD_INT 2
2847: PUSH
2848: EMPTY
2849: LIST
2850: LIST
2851: LIST
2852: ST_TO_ADDR
// dif_LegionTimeout = [ 30 30$0 , 25 25$0 , 15 15$0 ] ;
2853: LD_ADDR_EXP 57
2857: PUSH
2858: LD_INT 63000
2860: PUSH
2861: LD_INT 52500
2863: PUSH
2864: LD_INT 31500
2866: PUSH
2867: EMPTY
2868: LIST
2869: LIST
2870: LIST
2871: ST_TO_ADDR
// end ; end_of_file
2872: LD_VAR 0 1
2876: RET
// export function create_nature ( Cls , Cnt , Area ) ; var i , h ; begin
2877: LD_INT 0
2879: PPUSH
2880: PPUSH
2881: PPUSH
// Result = [ ] ;
2882: LD_ADDR_VAR 0 4
2886: PUSH
2887: EMPTY
2888: ST_TO_ADDR
// UC_nation = NATION_NATURE ;
2889: LD_ADDR_OWVAR 21
2893: PUSH
2894: LD_INT 0
2896: ST_TO_ADDR
// UC_side = side_neutral ;
2897: LD_ADDR_OWVAR 20
2901: PUSH
2902: LD_EXP 1
2906: ST_TO_ADDR
// HC_Class = Cls ;
2907: LD_ADDR_OWVAR 28
2911: PUSH
2912: LD_VAR 0 1
2916: ST_TO_ADDR
// HC_Name =  ;
2917: LD_ADDR_OWVAR 26
2921: PUSH
2922: LD_STRING 
2924: ST_TO_ADDR
// for i = 1 to Cnt do
2925: LD_ADDR_VAR 0 5
2929: PUSH
2930: DOUBLE
2931: LD_INT 1
2933: DEC
2934: ST_TO_ADDR
2935: LD_VAR 0 2
2939: PUSH
2940: FOR_TO
2941: IFFALSE 2991
// begin h = CreateHuman ;
2943: LD_ADDR_VAR 0 6
2947: PUSH
2948: CALL_OW 44
2952: ST_TO_ADDR
// Result = Result union [ h ] ;
2953: LD_ADDR_VAR 0 4
2957: PUSH
2958: LD_VAR 0 4
2962: PUSH
2963: LD_VAR 0 6
2967: PUSH
2968: EMPTY
2969: LIST
2970: UNION
2971: ST_TO_ADDR
// PlaceUnitArea ( h , Area , false ) ;
2972: LD_VAR 0 6
2976: PPUSH
2977: LD_VAR 0 3
2981: PPUSH
2982: LD_INT 0
2984: PPUSH
2985: CALL_OW 49
// end ;
2989: GO 2940
2991: POP
2992: POP
// end ;
2993: LD_VAR 0 4
2997: RET
// export function init_nature ; begin
2998: LD_INT 0
3000: PPUSH
// create_nature ( CLASS_TIGER , Rand ( 3 , 5 ) , Les ) ;
3001: LD_INT 14
3003: PPUSH
3004: LD_INT 3
3006: PPUSH
3007: LD_INT 5
3009: PPUSH
3010: CALL_OW 12
3014: PPUSH
3015: LD_INT 1
3017: PPUSH
3018: CALL 2877 0 3
// create_nature ( CLASS_APEMAN , Rand ( 5 , 7 ) - Difficulty , Les ) ;
3022: LD_INT 12
3024: PPUSH
3025: LD_INT 5
3027: PPUSH
3028: LD_INT 7
3030: PPUSH
3031: CALL_OW 12
3035: PUSH
3036: LD_OWVAR 67
3040: MINUS
3041: PPUSH
3042: LD_INT 1
3044: PPUSH
3045: CALL 2877 0 3
// create_nature ( CLASS_BAGGIE , Rand ( 2 , 5 ) , Louka ) ;
3049: LD_INT 13
3051: PPUSH
3052: LD_INT 2
3054: PPUSH
3055: LD_INT 5
3057: PPUSH
3058: CALL_OW 12
3062: PPUSH
3063: LD_INT 2
3065: PPUSH
3066: CALL 2877 0 3
// end ; end_of_file
3070: LD_VAR 0 1
3074: RET
// var CekaniRus , PoctyRus , PoctyExtra , PoctyStart ; export function init_suroviny ; var I ; begin
3075: LD_INT 0
3077: PPUSH
3078: PPUSH
// CekaniRus = dif_CekaniBednyRus [ Difficulty ] ;
3079: LD_ADDR_LOC 1
3083: PUSH
3084: LD_EXP 41
3088: PUSH
3089: LD_OWVAR 67
3093: ARRAY
3094: ST_TO_ADDR
// PoctyRus = dif_PoctyBednyRus [ Difficulty ] ;
3095: LD_ADDR_LOC 2
3099: PUSH
3100: LD_EXP 42
3104: PUSH
3105: LD_OWVAR 67
3109: ARRAY
3110: ST_TO_ADDR
// PoctyExtra = dif_PoctyBednyExtra [ Difficulty ] ;
3111: LD_ADDR_LOC 3
3115: PUSH
3116: LD_EXP 44
3120: PUSH
3121: LD_OWVAR 67
3125: ARRAY
3126: ST_TO_ADDR
// PoctyStart = dif_PoctyBednyStart [ Difficulty ] ;
3127: LD_ADDR_LOC 4
3131: PUSH
3132: LD_EXP 43
3136: PUSH
3137: LD_OWVAR 67
3141: ARRAY
3142: ST_TO_ADDR
// end ;
3143: LD_VAR 0 1
3147: RET
// every 3 3$0 do
3148: GO 3150
3150: DISABLE
// begin Wait ( Rand ( CekaniRus [ 1 ] , CekaniRus [ 2 ] ) ) ;
3151: LD_LOC 1
3155: PUSH
3156: LD_INT 1
3158: ARRAY
3159: PPUSH
3160: LD_LOC 1
3164: PUSH
3165: LD_INT 2
3167: ARRAY
3168: PPUSH
3169: CALL_OW 12
3173: PPUSH
3174: CALL_OW 67
// CreateCratesArea ( Rand ( PoctyRus [ 1 ] , PoctyRus [ 2 ] ) , BednyRusove , true ) ;
3178: LD_LOC 2
3182: PUSH
3183: LD_INT 1
3185: ARRAY
3186: PPUSH
3187: LD_LOC 2
3191: PUSH
3192: LD_INT 2
3194: ARRAY
3195: PPUSH
3196: CALL_OW 12
3200: PPUSH
3201: LD_INT 6
3203: PPUSH
3204: LD_INT 1
3206: PPUSH
3207: CALL_OW 55
// enable ;
3211: ENABLE
// end ;
3212: END
// every 2 2$10 do
3213: GO 3215
3215: DISABLE
// begin if PoctyStart <= 0 then
3216: LD_LOC 4
3220: PUSH
3221: LD_INT 0
3223: LESSEQUAL
3224: IFFALSE 3228
// exit ;
3226: GO 3301
// Wait ( Rand ( CekaniRus [ 1 ] , CekaniRus [ 2 ] ) ) ;
3228: LD_LOC 1
3232: PUSH
3233: LD_INT 1
3235: ARRAY
3236: PPUSH
3237: LD_LOC 1
3241: PUSH
3242: LD_INT 2
3244: ARRAY
3245: PPUSH
3246: CALL_OW 12
3250: PPUSH
3251: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 3 ) , BednyStart , false ) ;
3255: LD_INT 1
3257: PPUSH
3258: LD_INT 3
3260: PPUSH
3261: CALL_OW 12
3265: PPUSH
3266: LD_INT 8
3268: PPUSH
3269: LD_INT 0
3271: PPUSH
3272: CALL_OW 55
// PoctyStart = PoctyStart - 1 ;
3276: LD_ADDR_LOC 4
3280: PUSH
3281: LD_LOC 4
3285: PUSH
3286: LD_INT 1
3288: MINUS
3289: ST_TO_ADDR
// if PoctyStart > 0 then
3290: LD_LOC 4
3294: PUSH
3295: LD_INT 0
3297: GREATER
3298: IFFALSE 3301
// enable ;
3300: ENABLE
// end ;
3301: END
// every 3 3$12 + 1 1$49 do
3302: GO 3304
3304: DISABLE
// begin if PoctyExtra <= 0 then
3305: LD_LOC 3
3309: PUSH
3310: LD_INT 0
3312: LESSEQUAL
3313: IFFALSE 3317
// exit ;
3315: GO 3402
// if Prob ( 40 ) then
3317: LD_INT 40
3319: PPUSH
3320: CALL_OW 13
3324: IFFALSE 3329
// begin enable ;
3326: ENABLE
// exit ;
3327: GO 3402
// end ; Wait ( Rand ( CekaniRus [ 1 ] , CekaniRus [ 2 ] ) ) ;
3329: LD_LOC 1
3333: PUSH
3334: LD_INT 1
3336: ARRAY
3337: PPUSH
3338: LD_LOC 1
3342: PUSH
3343: LD_INT 2
3345: ARRAY
3346: PPUSH
3347: CALL_OW 12
3351: PPUSH
3352: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , BednyExtra , true ) ;
3356: LD_INT 3
3358: PPUSH
3359: LD_INT 5
3361: PPUSH
3362: CALL_OW 12
3366: PPUSH
3367: LD_INT 9
3369: PPUSH
3370: LD_INT 1
3372: PPUSH
3373: CALL_OW 55
// PoctyExtra = PoctyExtra - 1 ;
3377: LD_ADDR_LOC 3
3381: PUSH
3382: LD_LOC 3
3386: PUSH
3387: LD_INT 1
3389: MINUS
3390: ST_TO_ADDR
// if PoctyExtra > 0 then
3391: LD_LOC 3
3395: PUSH
3396: LD_INT 0
3398: GREATER
3399: IFFALSE 3402
// enable ;
3401: ENABLE
// end ;
3402: END
// every 3 3$13.7 + 2 2$9 do var Pocet ;
3403: GO 3405
3405: DISABLE
3406: LD_INT 0
3408: PPUSH
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
3409: LD_INT 35
3411: PPUSH
3412: LD_INT 2100
3414: PPUSH
3415: CALL_OW 12
3419: PPUSH
3420: CALL_OW 67
// Pocet = Rand ( 0 , 5 ) ;
3424: LD_ADDR_VAR 0 1
3428: PUSH
3429: LD_INT 0
3431: PPUSH
3432: LD_INT 5
3434: PPUSH
3435: CALL_OW 12
3439: ST_TO_ADDR
// if Pocet > 0 then
3440: LD_VAR 0 1
3444: PUSH
3445: LD_INT 0
3447: GREATER
3448: IFFALSE 3462
// CreateCratesAnywhere ( Pocet , true ) ;
3450: LD_VAR 0 1
3454: PPUSH
3455: LD_INT 1
3457: PPUSH
3458: CALL_OW 57
// enable ;
3462: ENABLE
// end ;
3463: PPOPN 1
3465: END
// every 0 0$57 do var Area , Pocet ;
3466: GO 3468
3468: DISABLE
3469: LD_INT 0
3471: PPUSH
3472: PPUSH
// begin if ArabiZniceni then
3473: LD_EXP 65
3477: IFFALSE 3496
// Wait ( Rand ( 2 2$0 , 3 3$30 ) ) else
3479: LD_INT 4200
3481: PPUSH
3482: LD_INT 7350
3484: PPUSH
3485: CALL_OW 12
3489: PPUSH
3490: CALL_OW 67
3494: GO 3517
// Wait ( Rand ( 0 0$1 , Difficulty * 1 1$0 ) ) ;
3496: LD_INT 35
3498: PPUSH
3499: LD_OWVAR 67
3503: PUSH
3504: LD_INT 2100
3506: MUL
3507: PPUSH
3508: CALL_OW 12
3512: PPUSH
3513: CALL_OW 67
// if ArabiZniceni then
3517: LD_EXP 65
3521: IFFALSE 3548
// begin Area = Arabove ;
3523: LD_ADDR_VAR 0 1
3527: PUSH
3528: LD_INT 5
3530: ST_TO_ADDR
// Pocet = [ 0 , 5 ] ;
3531: LD_ADDR_VAR 0 2
3535: PUSH
3536: LD_INT 0
3538: PUSH
3539: LD_INT 5
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: ST_TO_ADDR
// end else
3546: GO 3571
// begin Area = BednyArabove ;
3548: LD_ADDR_VAR 0 1
3552: PUSH
3553: LD_INT 7
3555: ST_TO_ADDR
// Pocet = [ 3 , 5 ] ;
3556: LD_ADDR_VAR 0 2
3560: PUSH
3561: LD_INT 3
3563: PUSH
3564: LD_INT 5
3566: PUSH
3567: EMPTY
3568: LIST
3569: LIST
3570: ST_TO_ADDR
// end ; Pocet = Rand ( Pocet [ 1 ] , Pocet [ 2 ] ) ;
3571: LD_ADDR_VAR 0 2
3575: PUSH
3576: LD_VAR 0 2
3580: PUSH
3581: LD_INT 1
3583: ARRAY
3584: PPUSH
3585: LD_VAR 0 2
3589: PUSH
3590: LD_INT 2
3592: ARRAY
3593: PPUSH
3594: CALL_OW 12
3598: ST_TO_ADDR
// if Pocet > 0 then
3599: LD_VAR 0 2
3603: PUSH
3604: LD_INT 0
3606: GREATER
3607: IFFALSE 3626
// CreateCratesArea ( Pocet , Area , true ) ;
3609: LD_VAR 0 2
3613: PPUSH
3614: LD_VAR 0 1
3618: PPUSH
3619: LD_INT 1
3621: PPUSH
3622: CALL_OW 55
// enable ;
3626: ENABLE
// end ; end_of_file
3627: PPOPN 2
3629: END
// function najdi_nekoho ; var Lidi ; begin
3630: LD_INT 0
3632: PPUSH
3633: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
3634: LD_ADDR_VAR 0 2
3638: PUSH
3639: LD_INT 22
3641: PUSH
3642: LD_EXP 2
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: PUSH
3651: LD_INT 50
3653: PUSH
3654: EMPTY
3655: LIST
3656: PUSH
3657: LD_INT 52
3659: PUSH
3660: EMPTY
3661: LIST
3662: PUSH
3663: LD_INT 21
3665: PUSH
3666: LD_INT 1
3668: PUSH
3669: EMPTY
3670: LIST
3671: LIST
3672: PUSH
3673: LD_INT 23
3675: PUSH
3676: LD_INT 3
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: PUSH
3683: LD_INT 26
3685: PUSH
3686: LD_INT 1
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: LIST
3697: LIST
3698: LIST
3699: LIST
3700: PPUSH
3701: CALL_OW 69
3705: PUSH
3706: LD_EXP 6
3710: PUSH
3711: EMPTY
3712: LIST
3713: DIFF
3714: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
3715: LD_ADDR_VAR 0 2
3719: PUSH
3720: LD_VAR 0 2
3724: PPUSH
3725: CALL 22324 0 1
3729: ST_TO_ADDR
// if Lidi then
3730: LD_VAR 0 2
3734: IFFALSE 3752
// Result = Lidi [ 1 ] else
3736: LD_ADDR_VAR 0 1
3740: PUSH
3741: LD_VAR 0 2
3745: PUSH
3746: LD_INT 1
3748: ARRAY
3749: ST_TO_ADDR
3750: GO 3762
// Result = Burlak ;
3752: LD_ADDR_VAR 0 1
3756: PUSH
3757: LD_EXP 6
3761: ST_TO_ADDR
// end ;
3762: LD_VAR 0 1
3766: RET
// function najdi_nekohoMF ; var Lidi ; begin
3767: LD_INT 0
3769: PPUSH
3770: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] ] ) diff [ Burlak ] ;
3771: LD_ADDR_VAR 0 2
3775: PUSH
3776: LD_INT 22
3778: PUSH
3779: LD_EXP 2
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 50
3790: PUSH
3791: EMPTY
3792: LIST
3793: PUSH
3794: LD_INT 52
3796: PUSH
3797: EMPTY
3798: LIST
3799: PUSH
3800: LD_INT 21
3802: PUSH
3803: LD_INT 1
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PUSH
3810: LD_INT 23
3812: PUSH
3813: LD_INT 3
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: PPUSH
3827: CALL_OW 69
3831: PUSH
3832: LD_EXP 6
3836: PUSH
3837: EMPTY
3838: LIST
3839: DIFF
3840: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
3841: LD_ADDR_VAR 0 2
3845: PUSH
3846: LD_VAR 0 2
3850: PPUSH
3851: CALL 22324 0 1
3855: ST_TO_ADDR
// if Lidi then
3856: LD_VAR 0 2
3860: IFFALSE 3878
// Result = Lidi [ 1 ] else
3862: LD_ADDR_VAR 0 1
3866: PUSH
3867: LD_VAR 0 2
3871: PUSH
3872: LD_INT 1
3874: ARRAY
3875: ST_TO_ADDR
3876: GO 3888
// Result = Burlak ;
3878: LD_ADDR_VAR 0 1
3882: PUSH
3883: LD_EXP 6
3887: ST_TO_ADDR
// end ;
3888: LD_VAR 0 1
3892: RET
// function najdi_vojaka ; var Vojaci ; begin
3893: LD_INT 0
3895: PPUSH
3896: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_CLASS , CLASS_SOLDIER ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
3897: LD_ADDR_VAR 0 2
3901: PUSH
3902: LD_INT 22
3904: PUSH
3905: LD_EXP 2
3909: PUSH
3910: EMPTY
3911: LIST
3912: LIST
3913: PUSH
3914: LD_INT 50
3916: PUSH
3917: EMPTY
3918: LIST
3919: PUSH
3920: LD_INT 52
3922: PUSH
3923: EMPTY
3924: LIST
3925: PUSH
3926: LD_INT 21
3928: PUSH
3929: LD_INT 1
3931: PUSH
3932: EMPTY
3933: LIST
3934: LIST
3935: PUSH
3936: LD_INT 23
3938: PUSH
3939: LD_INT 3
3941: PUSH
3942: EMPTY
3943: LIST
3944: LIST
3945: PUSH
3946: LD_INT 25
3948: PUSH
3949: LD_INT 1
3951: PUSH
3952: EMPTY
3953: LIST
3954: LIST
3955: PUSH
3956: LD_INT 26
3958: PUSH
3959: LD_INT 1
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PUSH
3966: EMPTY
3967: LIST
3968: LIST
3969: LIST
3970: LIST
3971: LIST
3972: LIST
3973: LIST
3974: PPUSH
3975: CALL_OW 69
3979: PUSH
3980: LD_EXP 6
3984: PUSH
3985: EMPTY
3986: LIST
3987: DIFF
3988: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
3989: LD_ADDR_VAR 0 2
3993: PUSH
3994: LD_VAR 0 2
3998: PPUSH
3999: CALL 22324 0 1
4003: ST_TO_ADDR
// if Vojaci then
4004: LD_VAR 0 2
4008: IFFALSE 4026
// Result = Vojaci [ 1 ] else
4010: LD_ADDR_VAR 0 1
4014: PUSH
4015: LD_VAR 0 2
4019: PUSH
4020: LD_INT 1
4022: ARRAY
4023: ST_TO_ADDR
4024: GO 4036
// Result = najdi_nekoho ;
4026: LD_ADDR_VAR 0 1
4030: PUSH
4031: CALL 3630 0 0
4035: ST_TO_ADDR
// end ;
4036: LD_VAR 0 1
4040: RET
// function najdi_vedce ; var Vojaci ; begin
4041: LD_INT 0
4043: PPUSH
4044: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
4045: LD_ADDR_VAR 0 2
4049: PUSH
4050: LD_INT 22
4052: PUSH
4053: LD_EXP 2
4057: PUSH
4058: EMPTY
4059: LIST
4060: LIST
4061: PUSH
4062: LD_INT 50
4064: PUSH
4065: EMPTY
4066: LIST
4067: PUSH
4068: LD_INT 52
4070: PUSH
4071: EMPTY
4072: LIST
4073: PUSH
4074: LD_INT 21
4076: PUSH
4077: LD_INT 1
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PUSH
4084: LD_INT 23
4086: PUSH
4087: LD_INT 3
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: PUSH
4094: LD_INT 25
4096: PUSH
4097: LD_INT 4
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: PUSH
4104: LD_INT 26
4106: PUSH
4107: LD_INT 1
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: LIST
4120: LIST
4121: LIST
4122: PPUSH
4123: CALL_OW 69
4127: PUSH
4128: LD_EXP 6
4132: PUSH
4133: EMPTY
4134: LIST
4135: DIFF
4136: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
4137: LD_ADDR_VAR 0 2
4141: PUSH
4142: LD_VAR 0 2
4146: PPUSH
4147: CALL 22324 0 1
4151: ST_TO_ADDR
// if Vojaci then
4152: LD_VAR 0 2
4156: IFFALSE 4174
// Result = Vojaci [ 1 ] else
4158: LD_ADDR_VAR 0 1
4162: PUSH
4163: LD_VAR 0 2
4167: PUSH
4168: LD_INT 1
4170: ARRAY
4171: ST_TO_ADDR
4172: GO 4182
// Result = 0 ;
4174: LD_ADDR_VAR 0 1
4178: PUSH
4179: LD_INT 0
4181: ST_TO_ADDR
// end ;
4182: LD_VAR 0 1
4186: RET
// function najdi_vedceMF ; var Vojaci ; begin
4187: LD_INT 0
4189: PPUSH
4190: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_NATION , NATION_RUSSIAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] ] ) diff [ Burlak ] ;
4191: LD_ADDR_VAR 0 2
4195: PUSH
4196: LD_INT 22
4198: PUSH
4199: LD_EXP 2
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: PUSH
4208: LD_INT 50
4210: PUSH
4211: EMPTY
4212: LIST
4213: PUSH
4214: LD_INT 52
4216: PUSH
4217: EMPTY
4218: LIST
4219: PUSH
4220: LD_INT 21
4222: PUSH
4223: LD_INT 1
4225: PUSH
4226: EMPTY
4227: LIST
4228: LIST
4229: PUSH
4230: LD_INT 23
4232: PUSH
4233: LD_INT 3
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: LD_INT 25
4242: PUSH
4243: LD_INT 4
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: LIST
4254: LIST
4255: LIST
4256: LIST
4257: PPUSH
4258: CALL_OW 69
4262: PUSH
4263: LD_EXP 6
4267: PUSH
4268: EMPTY
4269: LIST
4270: DIFF
4271: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
4272: LD_ADDR_VAR 0 2
4276: PUSH
4277: LD_VAR 0 2
4281: PPUSH
4282: CALL 22324 0 1
4286: ST_TO_ADDR
// if Vojaci then
4287: LD_VAR 0 2
4291: IFFALSE 4309
// Result = Vojaci [ 1 ] else
4293: LD_ADDR_VAR 0 1
4297: PUSH
4298: LD_VAR 0 2
4302: PUSH
4303: LD_INT 1
4305: ARRAY
4306: ST_TO_ADDR
4307: GO 4317
// Result = 0 ;
4309: LD_ADDR_VAR 0 1
4313: PUSH
4314: LD_INT 0
4316: ST_TO_ADDR
// end ;
4317: LD_VAR 0 1
4321: RET
// function najdi_sejka ; var Lidi , Sejkove ; begin
4322: LD_INT 0
4324: PPUSH
4325: PPUSH
4326: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) ;
4327: LD_ADDR_VAR 0 2
4331: PUSH
4332: LD_INT 22
4334: PUSH
4335: LD_EXP 3
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PUSH
4344: LD_INT 50
4346: PUSH
4347: EMPTY
4348: LIST
4349: PUSH
4350: LD_INT 52
4352: PUSH
4353: EMPTY
4354: LIST
4355: PUSH
4356: LD_INT 21
4358: PUSH
4359: LD_INT 1
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: PUSH
4366: LD_INT 26
4368: PUSH
4369: LD_INT 1
4371: PUSH
4372: EMPTY
4373: LIST
4374: LIST
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: LIST
4380: LIST
4381: LIST
4382: PPUSH
4383: CALL_OW 69
4387: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
4388: LD_ADDR_VAR 0 2
4392: PUSH
4393: LD_VAR 0 2
4397: PPUSH
4398: CALL 22324 0 1
4402: ST_TO_ADDR
// Sejkove = UnitFilter ( Lidi , [ [ F_CLASS , CLASS_DESERT_WARIOR ] ] ) ;
4403: LD_ADDR_VAR 0 3
4407: PUSH
4408: LD_VAR 0 2
4412: PPUSH
4413: LD_INT 25
4415: PUSH
4416: LD_INT 11
4418: PUSH
4419: EMPTY
4420: LIST
4421: LIST
4422: PUSH
4423: EMPTY
4424: LIST
4425: PPUSH
4426: CALL_OW 72
4430: ST_TO_ADDR
// if Sejkove then
4431: LD_VAR 0 3
4435: IFFALSE 4453
// Result = Sejkove [ 1 ] else
4437: LD_ADDR_VAR 0 1
4441: PUSH
4442: LD_VAR 0 3
4446: PUSH
4447: LD_INT 1
4449: ARRAY
4450: ST_TO_ADDR
4451: GO 4483
// if Lidi then
4453: LD_VAR 0 2
4457: IFFALSE 4475
// Result = Lidi [ 1 ] else
4459: LD_ADDR_VAR 0 1
4463: PUSH
4464: LD_VAR 0 2
4468: PUSH
4469: LD_INT 1
4471: ARRAY
4472: ST_TO_ADDR
4473: GO 4483
// Result = 0 ;
4475: LD_ADDR_VAR 0 1
4479: PUSH
4480: LD_INT 0
4482: ST_TO_ADDR
// end ;
4483: LD_VAR 0 1
4487: RET
// function najdi_araba ; var Lidi ; begin
4488: LD_INT 0
4490: PPUSH
4491: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) ;
4492: LD_ADDR_VAR 0 2
4496: PUSH
4497: LD_INT 22
4499: PUSH
4500: LD_EXP 3
4504: PUSH
4505: EMPTY
4506: LIST
4507: LIST
4508: PUSH
4509: LD_INT 50
4511: PUSH
4512: EMPTY
4513: LIST
4514: PUSH
4515: LD_INT 52
4517: PUSH
4518: EMPTY
4519: LIST
4520: PUSH
4521: LD_INT 21
4523: PUSH
4524: LD_INT 1
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: LD_INT 26
4533: PUSH
4534: LD_INT 1
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: PPUSH
4548: CALL_OW 69
4552: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
4553: LD_ADDR_VAR 0 2
4557: PUSH
4558: LD_VAR 0 2
4562: PPUSH
4563: CALL 22324 0 1
4567: ST_TO_ADDR
// if Lidi then
4568: LD_VAR 0 2
4572: IFFALSE 4590
// Result = Lidi [ 1 ] else
4574: LD_ADDR_VAR 0 1
4578: PUSH
4579: LD_VAR 0 2
4583: PUSH
4584: LD_INT 1
4586: ARRAY
4587: ST_TO_ADDR
4588: GO 4598
// Result = 0 ;
4590: LD_ADDR_VAR 0 1
4594: PUSH
4595: LD_INT 0
4597: ST_TO_ADDR
// end ;
4598: LD_VAR 0 1
4602: RET
// export function dialog_Start ; var V ; begin
4603: LD_INT 0
4605: PPUSH
4606: PPUSH
// V = najdi_vojaka ;
4607: LD_ADDR_VAR 0 2
4611: PUSH
4612: CALL 3893 0 0
4616: ST_TO_ADDR
// if not V then
4617: LD_VAR 0 2
4621: NOT
4622: IFFALSE 4634
// V = najdi_nekoho ;
4624: LD_ADDR_VAR 0 2
4628: PUSH
4629: CALL 3630 0 0
4633: ST_TO_ADDR
// if V then
4634: LD_VAR 0 2
4638: IFFALSE 4652
// Say ( V , DStart-RSol1-1 ) ;
4640: LD_VAR 0 2
4644: PPUSH
4645: LD_STRING DStart-RSol1-1
4647: PPUSH
4648: CALL_OW 88
// Say ( Burlak , DStart-Bur-1 ) ;
4652: LD_EXP 6
4656: PPUSH
4657: LD_STRING DStart-Bur-1
4659: PPUSH
4660: CALL_OW 88
// end ;
4664: LD_VAR 0 1
4668: RET
// export function dialog_AmAttack ; var G ; begin
4669: LD_INT 0
4671: PPUSH
4672: PPUSH
// if Gladkov then
4673: LD_EXP 26
4677: IFFALSE 4691
// G = Gladkov else
4679: LD_ADDR_VAR 0 2
4683: PUSH
4684: LD_EXP 26
4688: ST_TO_ADDR
4689: GO 4701
// G = GladkovFake ;
4691: LD_ADDR_VAR 0 2
4695: PUSH
4696: LD_EXP 27
4700: ST_TO_ADDR
// SayRadio ( G , DAmAttack-Gla-1 ) ;
4701: LD_VAR 0 2
4705: PPUSH
4706: LD_STRING DAmAttack-Gla-1
4708: PPUSH
4709: CALL_OW 94
// SayRadio ( Burlak , DAmAttack-Bur-1 ) ;
4713: LD_EXP 6
4717: PPUSH
4718: LD_STRING DAmAttack-Bur-1
4720: PPUSH
4721: CALL_OW 94
// SayRadio ( G , DAmAttack-Gla-2 ) ;
4725: LD_VAR 0 2
4729: PPUSH
4730: LD_STRING DAmAttack-Gla-2
4732: PPUSH
4733: CALL_OW 94
// SayRadio ( Burlak , DAmAttack-Bur-2 ) ;
4737: LD_EXP 6
4741: PPUSH
4742: LD_STRING DAmAttack-Bur-2
4744: PPUSH
4745: CALL_OW 94
// Say ( Burlak , DAmAttack-Bur-2a ) ;
4749: LD_EXP 6
4753: PPUSH
4754: LD_STRING DAmAttack-Bur-2a
4756: PPUSH
4757: CALL_OW 88
// end ;
4761: LD_VAR 0 1
4765: RET
// export function dialog_LegionOfferHeike1 ; begin
4766: LD_INT 0
4768: PPUSH
// SayRadio ( Heike , DLegionOfferHeike1-Hke-1 ) ;
4769: LD_EXP 28
4773: PPUSH
4774: LD_STRING DLegionOfferHeike1-Hke-1
4776: PPUSH
4777: CALL_OW 94
// SayRadio ( Burlak , DLegionOfferHeike1-Bur-1 ) ;
4781: LD_EXP 6
4785: PPUSH
4786: LD_STRING DLegionOfferHeike1-Bur-1
4788: PPUSH
4789: CALL_OW 94
// SayRadio ( Heike , DLegionOfferHeike1-Hke-2 ) ;
4793: LD_EXP 28
4797: PPUSH
4798: LD_STRING DLegionOfferHeike1-Hke-2
4800: PPUSH
4801: CALL_OW 94
// end ;
4805: LD_VAR 0 1
4809: RET
// export function dialog_LegionOfferHeike2 ; begin
4810: LD_INT 0
4812: PPUSH
// SayRadio ( Heike , DLegionOfferHeike1-Hke-2a ) ;
4813: LD_EXP 28
4817: PPUSH
4818: LD_STRING DLegionOfferHeike1-Hke-2a
4820: PPUSH
4821: CALL_OW 94
// SayRadio ( Burlak , DLegionOfferHeike1-Bur-2 ) ;
4825: LD_EXP 6
4829: PPUSH
4830: LD_STRING DLegionOfferHeike1-Bur-2
4832: PPUSH
4833: CALL_OW 94
// SayRadio ( Heike , DLegionOfferHeike1-Hke-3 ) ;
4837: LD_EXP 28
4841: PPUSH
4842: LD_STRING DLegionOfferHeike1-Hke-3
4844: PPUSH
4845: CALL_OW 94
// end ;
4849: LD_VAR 0 1
4853: RET
// export function dialog_LegionOfferHeikeCont ; begin
4854: LD_INT 0
4856: PPUSH
// SayRadio ( Heike , DLegionOfferHeikeCont-Hke-1 ) ;
4857: LD_EXP 28
4861: PPUSH
4862: LD_STRING DLegionOfferHeikeCont-Hke-1
4864: PPUSH
4865: CALL_OW 94
// end ;
4869: LD_VAR 0 1
4873: RET
// export function query_LegionHeike ; begin
4874: LD_INT 0
4876: PPUSH
// Result = Query ( QLegionHeike ) ;
4877: LD_ADDR_VAR 0 1
4881: PUSH
4882: LD_STRING QLegionHeike
4884: PPUSH
4885: CALL_OW 97
4889: ST_TO_ADDR
// end ;
4890: LD_VAR 0 1
4894: RET
// export function dialog_QrLegionHeike13 ; begin
4895: LD_INT 0
4897: PPUSH
// SayRadio ( Burlak , DQrLegionHeike#1-2-Bur-1 ) ;
4898: LD_EXP 6
4902: PPUSH
4903: LD_STRING DQrLegionHeike#1-2-Bur-1
4905: PPUSH
4906: CALL_OW 94
// end ;
4910: LD_VAR 0 1
4914: RET
// export function dialog_QrLegionHeike4 ; begin
4915: LD_INT 0
4917: PPUSH
// SayRadio ( Burlak , DQrLegionHeike#3-Bur-1 ) ;
4918: LD_EXP 6
4922: PPUSH
4923: LD_STRING DQrLegionHeike#3-Bur-1
4925: PPUSH
4926: CALL_OW 94
// end ;
4930: LD_VAR 0 1
4934: RET
// export function dialog_LegionOfferFarmer ; begin
4935: LD_INT 0
4937: PPUSH
// SayRadio ( Farmer , DLegionOfferFarmer-Frm-1 ) ;
4938: LD_EXP 29
4942: PPUSH
4943: LD_STRING DLegionOfferFarmer-Frm-1
4945: PPUSH
4946: CALL_OW 94
// SayRadio ( Burlak , DLegionOfferFarmer-Bur-1 ) ;
4950: LD_EXP 6
4954: PPUSH
4955: LD_STRING DLegionOfferFarmer-Bur-1
4957: PPUSH
4958: CALL_OW 94
// SayRadio ( Farmer , DLegionOfferFarmer-Frm-2 ) ;
4962: LD_EXP 29
4966: PPUSH
4967: LD_STRING DLegionOfferFarmer-Frm-2
4969: PPUSH
4970: CALL_OW 94
// end ;
4974: LD_VAR 0 1
4978: RET
// export function query_LegionFarmer ; begin
4979: LD_INT 0
4981: PPUSH
// Result = Query ( QLegionFarmer ) ;
4982: LD_ADDR_VAR 0 1
4986: PUSH
4987: LD_STRING QLegionFarmer
4989: PPUSH
4990: CALL_OW 97
4994: ST_TO_ADDR
// end ;
4995: LD_VAR 0 1
4999: RET
// export function dialog_QrLegionFarmer13 ; begin
5000: LD_INT 0
5002: PPUSH
// SayRadio ( Burlak , DQrLegionFarmer#1-3-Bur-1 ) ;
5003: LD_EXP 6
5007: PPUSH
5008: LD_STRING DQrLegionFarmer#1-3-Bur-1
5010: PPUSH
5011: CALL_OW 94
// end ;
5015: LD_VAR 0 1
5019: RET
// export function dialog_QrLegionFarmer4 ; begin
5020: LD_INT 0
5022: PPUSH
// SayRadio ( Burlak , DQrLegionFarmer#4-Bur-1 ) ;
5023: LD_EXP 6
5027: PPUSH
5028: LD_STRING DQrLegionFarmer#4-Bur-1
5030: PPUSH
5031: CALL_OW 94
// end ;
5035: LD_VAR 0 1
5039: RET
// export function dialog_LegionFugit ; begin
5040: LD_INT 0
5042: PPUSH
// Say ( Bergkamp , DLegionFugit-Brg-1 ) ;
5043: LD_EXP 30
5047: PPUSH
5048: LD_STRING DLegionFugit-Brg-1
5050: PPUSH
5051: CALL_OW 88
// Say ( Burlak , DLegionFugit-Bur-1 ) ;
5055: LD_EXP 6
5059: PPUSH
5060: LD_STRING DLegionFugit-Bur-1
5062: PPUSH
5063: CALL_OW 88
// Say ( Bergkamp , DLegionFugit-Brg-2 ) ;
5067: LD_EXP 30
5071: PPUSH
5072: LD_STRING DLegionFugit-Brg-2
5074: PPUSH
5075: CALL_OW 88
// end ;
5079: LD_VAR 0 1
5083: RET
// export function query_LegionBergkamp ; begin
5084: LD_INT 0
5086: PPUSH
// Result = Query ( QLegionBergkamp ) ;
5087: LD_ADDR_VAR 0 1
5091: PUSH
5092: LD_STRING QLegionBergkamp
5094: PPUSH
5095: CALL_OW 97
5099: ST_TO_ADDR
// end ;
5100: LD_VAR 0 1
5104: RET
// export function dialog_QrLegionBergkamp1 ; begin
5105: LD_INT 0
5107: PPUSH
// Say ( Burlak , DQrLegionBergkamp#1-Bur-1 ) ;
5108: LD_EXP 6
5112: PPUSH
5113: LD_STRING DQrLegionBergkamp#1-Bur-1
5115: PPUSH
5116: CALL_OW 88
// Say ( Bergkamp , DQrLegionBergkamp#1-Brg-1 ) ;
5120: LD_EXP 30
5124: PPUSH
5125: LD_STRING DQrLegionBergkamp#1-Brg-1
5127: PPUSH
5128: CALL_OW 88
// end ;
5132: LD_VAR 0 1
5136: RET
// export function dialog_QrLegionBergkamp2 ; begin
5137: LD_INT 0
5139: PPUSH
// Say ( Burlak , DQrLegionBergkamp#2-Bur-1 ) ;
5140: LD_EXP 6
5144: PPUSH
5145: LD_STRING DQrLegionBergkamp#2-Bur-1
5147: PPUSH
5148: CALL_OW 88
// end ;
5152: LD_VAR 0 1
5156: RET
// export function dialog_LegionLeave ; begin
5157: LD_INT 0
5159: PPUSH
// if not IsOk ( Bergkamp ) then
5160: LD_EXP 30
5164: PPUSH
5165: CALL_OW 302
5169: NOT
5170: IFFALSE 5174
// exit ;
5172: GO 5230
// if LegionOffer_Accepted then
5174: LD_EXP 59
5178: IFFALSE 5194
// Say ( Bergkamp , DLegionLeave-Brg-1 ) else
5180: LD_EXP 30
5184: PPUSH
5185: LD_STRING DLegionLeave-Brg-1
5187: PPUSH
5188: CALL_OW 88
5192: GO 5230
// begin Say ( Bergkamp , DLegionLeave-Brg-1a ) ;
5194: LD_EXP 30
5198: PPUSH
5199: LD_STRING DLegionLeave-Brg-1a
5201: PPUSH
5202: CALL_OW 88
// Say ( Burlak , DLegionLeave-Bur-1 ) ;
5206: LD_EXP 6
5210: PPUSH
5211: LD_STRING DLegionLeave-Bur-1
5213: PPUSH
5214: CALL_OW 88
// Say ( Bergkamp , DLegionLeave-Brg-2 ) ;
5218: LD_EXP 30
5222: PPUSH
5223: LD_STRING DLegionLeave-Brg-2
5225: PPUSH
5226: CALL_OW 88
// end ; end ;
5230: LD_VAR 0 1
5234: RET
// export function dialog_LegionSpy ; var V ; begin
5235: LD_INT 0
5237: PPUSH
5238: PPUSH
// V = najdi_vedce ;
5239: LD_ADDR_VAR 0 2
5243: PUSH
5244: CALL 4041 0 0
5248: ST_TO_ADDR
// if not V then
5249: LD_VAR 0 2
5253: NOT
5254: IFFALSE 5266
// V = najdi_nekoho ;
5256: LD_ADDR_VAR 0 2
5260: PUSH
5261: CALL 3630 0 0
5265: ST_TO_ADDR
// if V then
5266: LD_VAR 0 2
5270: IFFALSE 5284
// Say ( V , DLegionSpy-Sci1-1 ) ;
5272: LD_VAR 0 2
5276: PPUSH
5277: LD_STRING DLegionSpy-Sci1-1
5279: PPUSH
5280: CALL_OW 88
// Say ( Burlak , DLegionSpy-Bur-1 ) ;
5284: LD_EXP 6
5288: PPUSH
5289: LD_STRING DLegionSpy-Bur-1
5291: PPUSH
5292: CALL_OW 88
// end ;
5296: LD_VAR 0 1
5300: RET
// export function dialog_LegionChallengeHeike ; begin
5301: LD_INT 0
5303: PPUSH
// SayRadio ( Burlak , DLegionChallengeHeike-Bur-1 ) ;
5304: LD_EXP 6
5308: PPUSH
5309: LD_STRING DLegionChallengeHeike-Bur-1
5311: PPUSH
5312: CALL_OW 94
// SayRadio ( Heike , DLegionChallengeHeike-Hke-1 ) ;
5316: LD_EXP 28
5320: PPUSH
5321: LD_STRING DLegionChallengeHeike-Hke-1
5323: PPUSH
5324: CALL_OW 94
// SayRadio ( Burlak , DLegionChallengeHeike-Bur-2 ) ;
5328: LD_EXP 6
5332: PPUSH
5333: LD_STRING DLegionChallengeHeike-Bur-2
5335: PPUSH
5336: CALL_OW 94
// if OmarKilled then
5340: LD_EXP 38
5344: IFFALSE 5358
// SayRadio ( Heike , DLegionChallengeHeike-Hke-2 ) ;
5346: LD_EXP 28
5350: PPUSH
5351: LD_STRING DLegionChallengeHeike-Hke-2
5353: PPUSH
5354: CALL_OW 94
// end ;
5358: LD_VAR 0 1
5362: RET
// export function dialog_LegionChallengeFarmer ; begin
5363: LD_INT 0
5365: PPUSH
// SayRadio ( Burlak , DLegionChallengeFarmer-Bur-1 ) ;
5366: LD_EXP 6
5370: PPUSH
5371: LD_STRING DLegionChallengeFarmer-Bur-1
5373: PPUSH
5374: CALL_OW 94
// SayRadio ( Farmer , DLegionChallengeFarmer-Frm-1 ) ;
5378: LD_EXP 29
5382: PPUSH
5383: LD_STRING DLegionChallengeFarmer-Frm-1
5385: PPUSH
5386: CALL_OW 94
// SayRadio ( Burlak , DLegionChallengeFarmer-Bur-2 ) ;
5390: LD_EXP 6
5394: PPUSH
5395: LD_STRING DLegionChallengeFarmer-Bur-2
5397: PPUSH
5398: CALL_OW 94
// SayRadio ( Farmer , DLegionChallengeFarmer-Frm-2 ) ;
5402: LD_EXP 29
5406: PPUSH
5407: LD_STRING DLegionChallengeFarmer-Frm-2
5409: PPUSH
5410: CALL_OW 94
// SayRadio ( Burlak , DLegionChallengeFarmer-Bur-3 ) ;
5414: LD_EXP 6
5418: PPUSH
5419: LD_STRING DLegionChallengeFarmer-Bur-3
5421: PPUSH
5422: CALL_OW 94
// end ;
5426: LD_VAR 0 1
5430: RET
// export function dialog_Contam ; var V ; begin
5431: LD_INT 0
5433: PPUSH
5434: PPUSH
// V = najdi_vedce ;
5435: LD_ADDR_VAR 0 2
5439: PUSH
5440: CALL 4041 0 0
5444: ST_TO_ADDR
// if not V then
5445: LD_VAR 0 2
5449: NOT
5450: IFFALSE 5462
// V = najdi_nekoho ;
5452: LD_ADDR_VAR 0 2
5456: PUSH
5457: CALL 3630 0 0
5461: ST_TO_ADDR
// if V and ( V <> Burlak ) then
5462: LD_VAR 0 2
5466: PUSH
5467: LD_VAR 0 2
5471: PUSH
5472: LD_EXP 6
5476: NONEQUAL
5477: AND
5478: IFFALSE 5528
// begin Say ( V , DContam-Sci1-1 ) ;
5480: LD_VAR 0 2
5484: PPUSH
5485: LD_STRING DContam-Sci1-1
5487: PPUSH
5488: CALL_OW 88
// Say ( Burlak , DContam-Bur-1 ) ;
5492: LD_EXP 6
5496: PPUSH
5497: LD_STRING DContam-Bur-1
5499: PPUSH
5500: CALL_OW 88
// Say ( V , DContam-Sci1-2 ) ;
5504: LD_VAR 0 2
5508: PPUSH
5509: LD_STRING DContam-Sci1-2
5511: PPUSH
5512: CALL_OW 88
// Say ( Burlak , DContam-Bur-2 ) ;
5516: LD_EXP 6
5520: PPUSH
5521: LD_STRING DContam-Bur-2
5523: PPUSH
5524: CALL_OW 88
// end ; end ;
5528: LD_VAR 0 1
5532: RET
// export function dialog_SurrenderArabians ; var V ; begin
5533: LD_INT 0
5535: PPUSH
5536: PPUSH
// if IsOK ( Abdul ) then
5537: LD_EXP 31
5541: PPUSH
5542: CALL_OW 302
5546: IFFALSE 5562
// Say ( Abdul , DSurrenderArabians-Abd-1 ) else
5548: LD_EXP 31
5552: PPUSH
5553: LD_STRING DSurrenderArabians-Abd-1
5555: PPUSH
5556: CALL_OW 88
5560: GO 5636
// begin if Omar and IsOk ( Omar ) then
5562: LD_EXP 32
5566: PUSH
5567: LD_EXP 32
5571: PPUSH
5572: CALL_OW 302
5576: AND
5577: IFFALSE 5591
// V = Omar else
5579: LD_ADDR_VAR 0 2
5583: PUSH
5584: LD_EXP 32
5588: ST_TO_ADDR
5589: GO 5601
// V = najdi_sejka ;
5591: LD_ADDR_VAR 0 2
5595: PUSH
5596: CALL 4322 0 0
5600: ST_TO_ADDR
// if not V then
5601: LD_VAR 0 2
5605: NOT
5606: IFFALSE 5618
// V = najdi_araba ;
5608: LD_ADDR_VAR 0 2
5612: PUSH
5613: CALL 4488 0 0
5617: ST_TO_ADDR
// if V then
5618: LD_VAR 0 2
5622: IFFALSE 5636
// Say ( V , DSurrenderArabians-ArSol1-1 ) ;
5624: LD_VAR 0 2
5628: PPUSH
5629: LD_STRING DSurrenderArabians-ArSol1-1
5631: PPUSH
5632: CALL_OW 88
// end ; end ;
5636: LD_VAR 0 1
5640: RET
// export function dialog_BehemothTechno1 ; var V ; begin
5641: LD_INT 0
5643: PPUSH
5644: PPUSH
// Say ( Burlak , DBehemothTechno-Bur-1 ) ;
5645: LD_EXP 6
5649: PPUSH
5650: LD_STRING DBehemothTechno-Bur-1
5652: PPUSH
5653: CALL_OW 88
// if Petrosyan and IsOk ( Petrosyan ) then
5657: LD_EXP 16
5661: PUSH
5662: LD_EXP 16
5666: PPUSH
5667: CALL_OW 302
5671: AND
5672: IFFALSE 5688
// Say ( Petrosyan , DBehemothTechno-Pty-1 ) else
5674: LD_EXP 16
5678: PPUSH
5679: LD_STRING DBehemothTechno-Pty-1
5681: PPUSH
5682: CALL_OW 88
5686: GO 5771
// begin V = najdi_vedceMF ;
5688: LD_ADDR_VAR 0 2
5692: PUSH
5693: CALL 4187 0 0
5697: ST_TO_ADDR
// if not V then
5698: LD_VAR 0 2
5702: NOT
5703: IFFALSE 5715
// V = najdi_nekoho ;
5705: LD_ADDR_VAR 0 2
5709: PUSH
5710: CALL 3630 0 0
5714: ST_TO_ADDR
// if GetSex ( V ) = SEX_MALE then
5715: LD_VAR 0 2
5719: PPUSH
5720: CALL_OW 258
5724: PUSH
5725: LD_INT 1
5727: EQUAL
5728: IFFALSE 5744
// Say ( V , DBehemothTechno-Sci-1 ) else
5730: LD_VAR 0 2
5734: PPUSH
5735: LD_STRING DBehemothTechno-Sci-1
5737: PPUSH
5738: CALL_OW 88
5742: GO 5771
// if GetSex ( V ) = SEX_FEMALE then
5744: LD_VAR 0 2
5748: PPUSH
5749: CALL_OW 258
5753: PUSH
5754: LD_INT 2
5756: EQUAL
5757: IFFALSE 5771
// Say ( V , DBehemothTechno-FSci1-1 ) ;
5759: LD_VAR 0 2
5763: PPUSH
5764: LD_STRING DBehemothTechno-FSci1-1
5766: PPUSH
5767: CALL_OW 88
// end ; end ;
5771: LD_VAR 0 1
5775: RET
// export function dialog_BehemothTechno2 ; var V ; begin
5776: LD_INT 0
5778: PPUSH
5779: PPUSH
// Say ( Burlak , DBehemothTechno-Bur-2 ) ;
5780: LD_EXP 6
5784: PPUSH
5785: LD_STRING DBehemothTechno-Bur-2
5787: PPUSH
5788: CALL_OW 88
// V = najdi_vedceMF ;
5792: LD_ADDR_VAR 0 2
5796: PUSH
5797: CALL 4187 0 0
5801: ST_TO_ADDR
// if not V then
5802: LD_VAR 0 2
5806: NOT
5807: IFFALSE 5819
// V = najdi_nekoho ;
5809: LD_ADDR_VAR 0 2
5813: PUSH
5814: CALL 3630 0 0
5818: ST_TO_ADDR
// if GetSex ( V ) = SEX_MALE then
5819: LD_VAR 0 2
5823: PPUSH
5824: CALL_OW 258
5828: PUSH
5829: LD_INT 1
5831: EQUAL
5832: IFFALSE 5848
// Say ( V , DBehemothTechno-Sci-2 ) else
5834: LD_VAR 0 2
5838: PPUSH
5839: LD_STRING DBehemothTechno-Sci-2
5841: PPUSH
5842: CALL_OW 88
5846: GO 5875
// if GetSex ( V ) = SEX_FEMALE then
5848: LD_VAR 0 2
5852: PPUSH
5853: CALL_OW 258
5857: PUSH
5858: LD_INT 2
5860: EQUAL
5861: IFFALSE 5875
// Say ( V , DBehemothTechno-FSci1-2 ) ;
5863: LD_VAR 0 2
5867: PPUSH
5868: LD_STRING DBehemothTechno-FSci1-2
5870: PPUSH
5871: CALL_OW 88
// end ;
5875: LD_VAR 0 1
5879: RET
// export function dialog_BehemothComplete ; var Vsichni , Seznam , Vedci , Kdo ; begin
5880: LD_INT 0
5882: PPUSH
5883: PPUSH
5884: PPUSH
5885: PPUSH
5886: PPUSH
// Seznam = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
5887: LD_ADDR_VAR 0 3
5891: PUSH
5892: LD_INT 22
5894: PUSH
5895: LD_EXP 2
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: PUSH
5904: LD_INT 50
5906: PUSH
5907: EMPTY
5908: LIST
5909: PUSH
5910: LD_INT 52
5912: PUSH
5913: EMPTY
5914: LIST
5915: PUSH
5916: LD_INT 21
5918: PUSH
5919: LD_INT 1
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: PUSH
5926: LD_INT 26
5928: PUSH
5929: LD_INT 1
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: PUSH
5936: EMPTY
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PPUSH
5943: CALL_OW 69
5947: PUSH
5948: LD_EXP 6
5952: PUSH
5953: EMPTY
5954: LIST
5955: DIFF
5956: ST_TO_ADDR
// Vedci = UnitFilter ( Vsichni , [ [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
5957: LD_ADDR_VAR 0 4
5961: PUSH
5962: LD_VAR 0 2
5966: PPUSH
5967: LD_INT 25
5969: PUSH
5970: LD_INT 4
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PUSH
5977: EMPTY
5978: LIST
5979: PPUSH
5980: CALL_OW 72
5984: ST_TO_ADDR
// Vsichni = Vedci ^ ( Seznam diff Vedci ) ;
5985: LD_ADDR_VAR 0 2
5989: PUSH
5990: LD_VAR 0 4
5994: PUSH
5995: LD_VAR 0 3
5999: PUSH
6000: LD_VAR 0 4
6004: DIFF
6005: ADD
6006: ST_TO_ADDR
// if Vsichni >= 1 then
6007: LD_VAR 0 2
6011: PUSH
6012: LD_INT 1
6014: GREATEREQUAL
6015: IFFALSE 6067
// begin Kdo = Vsichni [ 1 ] ;
6017: LD_ADDR_VAR 0 5
6021: PUSH
6022: LD_VAR 0 2
6026: PUSH
6027: LD_INT 1
6029: ARRAY
6030: ST_TO_ADDR
// Say ( Kdo , DBehemothComplete-Sci-1 ) ;
6031: LD_VAR 0 5
6035: PPUSH
6036: LD_STRING DBehemothComplete-Sci-1
6038: PPUSH
6039: CALL_OW 88
// Say ( Kdo , DBehemothComplete-Sci-1a ) ;
6043: LD_VAR 0 5
6047: PPUSH
6048: LD_STRING DBehemothComplete-Sci-1a
6050: PPUSH
6051: CALL_OW 88
// Say ( Kdo , DBehemothComplete-Sci-1b ) ;
6055: LD_VAR 0 5
6059: PPUSH
6060: LD_STRING DBehemothComplete-Sci-1b
6062: PPUSH
6063: CALL_OW 88
// end ; Hint ( Behemoth ) ;
6067: LD_STRING Behemoth
6069: PPUSH
6070: CALL_OW 339
// end ; end_of_file
6074: LD_VAR 0 1
6078: RET
// export LegionOffer_Heike , LegionOffer_Accepted , LegionFugit_Accepted ; var LeSci1 , LeSci2 , LeMech1 , LeMech2 , LeEng ; var Obranci , Mechanici ; var Ridici ; export Uprchlici ; var Uprchlici_JsouTam ; var Uprchlici_X , Uprchlici_Y ; var KonvojPopojizdi ; var Nabidka_Nakladaky , Nabidka_Ridici , Nabidka_Cena , Nabidka_Lidi ; var Nabidka_Nalozeno , Nabidka_Vylozeno ; var Makro ; var KdoLeci , KdoOpravuje ; var ProbihaPredavaniSurovin ; var MamPrebarvit ; export function init_legion ; var Base , Reg ; begin
6079: LD_INT 0
6081: PPUSH
6082: PPUSH
6083: PPUSH
// disable ( 11 ) ;
6084: LD_INT 11
6086: DISABLE_MARKED
// disable ( 12 ) ;
6087: LD_INT 12
6089: DISABLE_MARKED
// disable ( 13 ) ;
6090: LD_INT 13
6092: DISABLE_MARKED
// disable ( 14 ) ;
6093: LD_INT 14
6095: DISABLE_MARKED
// disable ( 15 ) ;
6096: LD_INT 15
6098: DISABLE_MARKED
// disable ( 16 ) ;
6099: LD_INT 16
6101: DISABLE_MARKED
// if Difficulty = 1 then
6102: LD_OWVAR 67
6106: PUSH
6107: LD_INT 1
6109: EQUAL
6110: IFFALSE 6165
// begin DestroyUnit ( LeBunk2 ) ;
6112: LD_INT 28
6114: PPUSH
6115: CALL_OW 65
// DestroyUnit ( LeBunk4 ) ;
6119: LD_INT 40
6121: PPUSH
6122: CALL_OW 65
// DestroyUnit ( LeBunk6 ) ;
6126: LD_INT 31
6128: PPUSH
6129: CALL_OW 65
// PlaceWeaponTurret ( LeBunk1 , AR_FLAME_THROWER ) ;
6133: LD_INT 27
6135: PPUSH
6136: LD_INT 26
6138: PPUSH
6139: CALL_OW 431
// PlaceWeaponTurret ( LeBunk5 , AR_FLAME_THROWER ) ;
6143: LD_INT 30
6145: PPUSH
6146: LD_INT 26
6148: PPUSH
6149: CALL_OW 431
// PlaceWeaponTurret ( LeBunk7 , AR_GUN ) ;
6153: LD_INT 22
6155: PPUSH
6156: LD_INT 27
6158: PPUSH
6159: CALL_OW 431
// end else
6163: GO 6182
// if Difficulty = 2 then
6165: LD_OWVAR 67
6169: PUSH
6170: LD_INT 2
6172: EQUAL
6173: IFFALSE 6182
// begin DestroyUnit ( LeBunk2 ) ;
6175: LD_INT 28
6177: PPUSH
6178: CALL_OW 65
// end ; LegionOffer_Heike = false ;
6182: LD_ADDR_EXP 58
6186: PUSH
6187: LD_INT 0
6189: ST_TO_ADDR
// LegionOffer_Accepted = false ;
6190: LD_ADDR_EXP 59
6194: PUSH
6195: LD_INT 0
6197: ST_TO_ADDR
// LegionFugit_Accepted = false ;
6198: LD_ADDR_EXP 60
6202: PUSH
6203: LD_INT 0
6205: ST_TO_ADDR
// Uprchlici = [ ] ;
6206: LD_ADDR_EXP 61
6210: PUSH
6211: EMPTY
6212: ST_TO_ADDR
// Uprchlici_JsouTam = false ;
6213: LD_ADDR_LOC 13
6217: PUSH
6218: LD_INT 0
6220: ST_TO_ADDR
// Uprchlici_X = Uprchlici_Y = 0 ;
6221: LD_ADDR_LOC 14
6225: PUSH
6226: LD_LOC 15
6230: PUSH
6231: LD_INT 0
6233: EQUAL
6234: ST_TO_ADDR
// KonvojPopojizdi = false ;
6235: LD_ADDR_LOC 16
6239: PUSH
6240: LD_INT 0
6242: ST_TO_ADDR
// Nabidka_Nakladaky = [ ] ;
6243: LD_ADDR_LOC 17
6247: PUSH
6248: EMPTY
6249: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
6250: LD_ADDR_LOC 18
6254: PUSH
6255: EMPTY
6256: ST_TO_ADDR
// Nabidka_Cena = [ 0 , 0 ] ;
6257: LD_ADDR_LOC 19
6261: PUSH
6262: LD_INT 0
6264: PUSH
6265: LD_INT 0
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: ST_TO_ADDR
// Nabidka_Lidi = 0 ;
6272: LD_ADDR_LOC 20
6276: PUSH
6277: LD_INT 0
6279: ST_TO_ADDR
// Nabidka_Nalozeno = false ;
6280: LD_ADDR_LOC 21
6284: PUSH
6285: LD_INT 0
6287: ST_TO_ADDR
// Nabidka_Vylozeno = false ;
6288: LD_ADDR_LOC 22
6292: PUSH
6293: LD_INT 0
6295: ST_TO_ADDR
// KdoLeci = [ ] ;
6296: LD_ADDR_LOC 24
6300: PUSH
6301: EMPTY
6302: ST_TO_ADDR
// KdoOpravuje = [ ] ;
6303: LD_ADDR_LOC 25
6307: PUSH
6308: EMPTY
6309: ST_TO_ADDR
// ProbihaPredavaniSurovin = false ;
6310: LD_ADDR_LOC 26
6314: PUSH
6315: LD_INT 0
6317: ST_TO_ADDR
// vytvor_postavy ;
6318: CALL 6516 0 0
// Base = GetBase ( LeDepot ) ;
6322: LD_ADDR_VAR 0 2
6326: PUSH
6327: LD_INT 20
6329: PPUSH
6330: CALL_OW 274
6334: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , Rand ( 600 , 700 ) ) ;
6335: LD_VAR 0 2
6339: PPUSH
6340: LD_INT 1
6342: PPUSH
6343: LD_INT 600
6345: PPUSH
6346: LD_INT 700
6348: PPUSH
6349: CALL_OW 12
6353: PPUSH
6354: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , Rand ( 800 , 1200 ) ) ;
6358: LD_VAR 0 2
6362: PPUSH
6363: LD_INT 2
6365: PPUSH
6366: LD_INT 800
6368: PPUSH
6369: LD_INT 1200
6371: PPUSH
6372: CALL_OW 12
6376: PPUSH
6377: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , Rand ( 200 , 300 ) ) ;
6381: LD_VAR 0 2
6385: PPUSH
6386: LD_INT 3
6388: PPUSH
6389: LD_INT 200
6391: PPUSH
6392: LD_INT 300
6394: PPUSH
6395: CALL_OW 12
6399: PPUSH
6400: CALL_OW 277
// Reg = McRegistry ( side_Le , [ [ MC_REG_AREA_TO_PROTECT , LegionObrana ] ] ) ;
6404: LD_ADDR_VAR 0 3
6408: PUSH
6409: LD_EXP 4
6413: PPUSH
6414: LD_INT 3
6416: PUSH
6417: LD_INT 16
6419: PUSH
6420: EMPTY
6421: LIST
6422: LIST
6423: PUSH
6424: EMPTY
6425: LIST
6426: PPUSH
6427: CALL_OW 399
6431: ST_TO_ADDR
// Makro = McDefend ( 0 , Reg , Obranci union Mechanici union Ridici union [ LeBunk1 , LeBunk2 , LeBunk3 , LeBunk4 , Lebunk5 , LeBunk6 , LeBunk7 ] , [ [ MC_AREA_DONT_LEAVE , Legion ] ] ) ;
6432: LD_ADDR_LOC 23
6436: PUSH
6437: LD_INT 0
6439: PPUSH
6440: LD_VAR 0 3
6444: PPUSH
6445: LD_LOC 10
6449: PUSH
6450: LD_LOC 11
6454: UNION
6455: PUSH
6456: LD_LOC 12
6460: UNION
6461: PUSH
6462: LD_INT 27
6464: PUSH
6465: LD_INT 28
6467: PUSH
6468: LD_INT 29
6470: PUSH
6471: LD_INT 40
6473: PUSH
6474: LD_INT 30
6476: PUSH
6477: LD_INT 31
6479: PUSH
6480: LD_INT 22
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: LIST
6491: UNION
6492: PPUSH
6493: LD_INT 2
6495: PUSH
6496: LD_INT 4
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: PUSH
6503: EMPTY
6504: LIST
6505: PPUSH
6506: CALL_OW 401
6510: ST_TO_ADDR
// end ;
6511: LD_VAR 0 1
6515: RET
// function vytvor_postavy ; var Bunkry , B ; begin
6516: LD_INT 0
6518: PPUSH
6519: PPUSH
6520: PPUSH
// LeSci1 = vytvor_postavu_B ( LeLab , CLASS_SCIENTISTIC ) ;
6521: LD_ADDR_LOC 5
6525: PUSH
6526: LD_INT 25
6528: PPUSH
6529: LD_INT 4
6531: PPUSH
6532: CALL 6839 0 2
6536: ST_TO_ADDR
// LeSci2 = vytvor_postavu_B ( LeLab , CLASS_SCIENTISTIC ) ;
6537: LD_ADDR_LOC 6
6541: PUSH
6542: LD_INT 25
6544: PPUSH
6545: LD_INT 4
6547: PPUSH
6548: CALL 6839 0 2
6552: ST_TO_ADDR
// LeMech1 = vytvor_postavu_B ( LeFact , CLASS_MECHANIC ) ;
6553: LD_ADDR_LOC 7
6557: PUSH
6558: LD_INT 26
6560: PPUSH
6561: LD_INT 3
6563: PPUSH
6564: CALL 6839 0 2
6568: ST_TO_ADDR
// LeMech2 = vytvor_postavu_B ( LeFact , CLASS_MECHANIC ) ;
6569: LD_ADDR_LOC 8
6573: PUSH
6574: LD_INT 26
6576: PPUSH
6577: LD_INT 3
6579: PPUSH
6580: CALL 6839 0 2
6584: ST_TO_ADDR
// vytvor_postavu_B ( LeDepot , CLASS_ENGINEER ) ;
6585: LD_INT 20
6587: PPUSH
6588: LD_INT 2
6590: PPUSH
6591: CALL 6839 0 2
// LeEng = vytvor_postavu_A ( Legion , CLASS_ENGINEER ) ;
6595: LD_ADDR_LOC 9
6599: PUSH
6600: LD_INT 4
6602: PPUSH
6603: LD_INT 2
6605: PPUSH
6606: CALL 6876 0 2
6610: ST_TO_ADDR
// Obranci = vytvor_postavy_A ( 3 , Legion , CLASS_SOLDIER ) ;
6611: LD_ADDR_LOC 10
6615: PUSH
6616: LD_INT 3
6618: PPUSH
6619: LD_INT 4
6621: PPUSH
6622: LD_INT 1
6624: PPUSH
6625: CALL 6916 0 3
6629: ST_TO_ADDR
// Mechanici = vytvor_postavy_A ( 2 , Legion , CLASS_MECHANIC ) ;
6630: LD_ADDR_LOC 11
6634: PUSH
6635: LD_INT 2
6637: PPUSH
6638: LD_INT 4
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: CALL 6916 0 3
6648: ST_TO_ADDR
// Ridici = Mechanici union vytvor_postavy_A ( dif_LegionRidici [ Difficulty ] , Legion , CLASS_SOLDIER ) ;
6649: LD_ADDR_LOC 12
6653: PUSH
6654: LD_LOC 11
6658: PUSH
6659: LD_EXP 45
6663: PUSH
6664: LD_OWVAR 67
6668: ARRAY
6669: PPUSH
6670: LD_INT 4
6672: PPUSH
6673: LD_INT 1
6675: PPUSH
6676: CALL 6916 0 3
6680: UNION
6681: ST_TO_ADDR
// Bunkry = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_BUNKER ] ] ) ;
6682: LD_ADDR_VAR 0 2
6686: PUSH
6687: LD_INT 22
6689: PUSH
6690: LD_EXP 4
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: PUSH
6699: LD_INT 21
6701: PUSH
6702: LD_INT 3
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: PUSH
6709: LD_INT 30
6711: PUSH
6712: LD_INT 32
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: LIST
6723: PPUSH
6724: CALL_OW 69
6728: ST_TO_ADDR
// for B in Bunkry do
6729: LD_ADDR_VAR 0 3
6733: PUSH
6734: LD_VAR 0 2
6738: PUSH
6739: FOR_IN
6740: IFFALSE 6756
// vytvor_postavu_B ( B , CLASS_SOLDIER ) ;
6742: LD_VAR 0 3
6746: PPUSH
6747: LD_INT 1
6749: PPUSH
6750: CALL 6839 0 2
6754: GO 6739
6756: POP
6757: POP
// end ;
6758: LD_VAR 0 1
6762: RET
// function vytvor_postavu ( Cls ) ; var X , Y ; begin
6763: LD_INT 0
6765: PPUSH
6766: PPUSH
6767: PPUSH
// UC_Side = side_Le ;
6768: LD_ADDR_OWVAR 20
6772: PUSH
6773: LD_EXP 4
6777: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
6778: LD_ADDR_OWVAR 21
6782: PUSH
6783: LD_INT 2
6785: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
6786: LD_ADDR_OWVAR 27
6790: PUSH
6791: LD_INT 1
6793: PPUSH
6794: LD_INT 2
6796: PPUSH
6797: CALL_OW 12
6801: ST_TO_ADDR
// HC_Class = Cls ;
6802: LD_ADDR_OWVAR 28
6806: PUSH
6807: LD_VAR 0 1
6811: ST_TO_ADDR
// PrepareClassSkills ( Cls , 7 ) ;
6812: LD_VAR 0 1
6816: PPUSH
6817: LD_INT 7
6819: PPUSH
6820: CALL_OW 374
// Result = CreateHuman ;
6824: LD_ADDR_VAR 0 2
6828: PUSH
6829: CALL_OW 44
6833: ST_TO_ADDR
// end ;
6834: LD_VAR 0 2
6838: RET
// function vytvor_postavu_B ( Budova , Cls ) ; begin
6839: LD_INT 0
6841: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6842: LD_ADDR_VAR 0 3
6846: PUSH
6847: LD_VAR 0 2
6851: PPUSH
6852: CALL 6763 0 1
6856: ST_TO_ADDR
// PlaceHumanInUnit ( Result , Budova ) ;
6857: LD_VAR 0 3
6861: PPUSH
6862: LD_VAR 0 1
6866: PPUSH
6867: CALL_OW 52
// end ;
6871: LD_VAR 0 3
6875: RET
// function vytvor_postavu_A ( Area , Cls ) ; begin
6876: LD_INT 0
6878: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6879: LD_ADDR_VAR 0 3
6883: PUSH
6884: LD_VAR 0 2
6888: PPUSH
6889: CALL 6763 0 1
6893: ST_TO_ADDR
// PlaceUnitArea ( Result , Area , false ) ;
6894: LD_VAR 0 3
6898: PPUSH
6899: LD_VAR 0 1
6903: PPUSH
6904: LD_INT 0
6906: PPUSH
6907: CALL_OW 49
// end ;
6911: LD_VAR 0 3
6915: RET
// function vytvor_postavy_A ( Pocet , Area , Cls ) ; var I ; begin
6916: LD_INT 0
6918: PPUSH
6919: PPUSH
// Result = [ ] ;
6920: LD_ADDR_VAR 0 4
6924: PUSH
6925: EMPTY
6926: ST_TO_ADDR
// for I = 1 to Pocet do
6927: LD_ADDR_VAR 0 5
6931: PUSH
6932: DOUBLE
6933: LD_INT 1
6935: DEC
6936: ST_TO_ADDR
6937: LD_VAR 0 1
6941: PUSH
6942: FOR_TO
6943: IFFALSE 6976
// Result = Result union [ vytvor_postavu_A ( Area , Cls ) ] ;
6945: LD_ADDR_VAR 0 4
6949: PUSH
6950: LD_VAR 0 4
6954: PUSH
6955: LD_VAR 0 2
6959: PPUSH
6960: LD_VAR 0 3
6964: PPUSH
6965: CALL 6876 0 2
6969: PUSH
6970: EMPTY
6971: LIST
6972: UNION
6973: ST_TO_ADDR
6974: GO 6942
6976: POP
6977: POP
// end ;
6978: LD_VAR 0 4
6982: RET
// function zacni_vynalezat ; begin
6983: LD_INT 0
6985: PPUSH
// AddComResearch ( LeLab , TECH_ROCKET ) ;
6986: LD_INT 25
6988: PPUSH
6989: LD_INT 40
6991: PPUSH
6992: CALL_OW 184
// AddComResearch ( LeLab , TECH_FLAME ) ;
6996: LD_INT 25
6998: PPUSH
6999: LD_INT 70
7001: PPUSH
7002: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIBCONTAM ) ;
7006: LD_INT 25
7008: PPUSH
7009: LD_INT 26
7011: PPUSH
7012: CALL_OW 184
// AddComResearch ( LeLab , TECH_MORTAR ) ;
7016: LD_INT 25
7018: PPUSH
7019: LD_INT 41
7021: PPUSH
7022: CALL_OW 184
// AddComResearch ( LeLab , TECH_EXPLOS ) ;
7026: LD_INT 25
7028: PPUSH
7029: LD_INT 42
7031: PPUSH
7032: CALL_OW 184
// AddComResearch ( LeLab , TECH_SELFDEST ) ;
7036: LD_INT 25
7038: PPUSH
7039: LD_INT 43
7041: PPUSH
7042: CALL_OW 184
// AddComResearch ( LeLab , TECH_TECH1 ) ;
7046: LD_INT 25
7048: PPUSH
7049: LD_INT 48
7051: PPUSH
7052: CALL_OW 184
// AddComResearch ( LeLab , TECH_WEAP1 ) ;
7056: LD_INT 25
7058: PPUSH
7059: LD_INT 51
7061: PPUSH
7062: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIB1 ) ;
7066: LD_INT 25
7068: PPUSH
7069: LD_INT 54
7071: PPUSH
7072: CALL_OW 184
// AddComResearch ( LeLab , TECH_TECH2 ) ;
7076: LD_INT 25
7078: PPUSH
7079: LD_INT 49
7081: PPUSH
7082: CALL_OW 184
// AddComResearch ( LeLab , TECH_WEAP2 ) ;
7086: LD_INT 25
7088: PPUSH
7089: LD_INT 52
7091: PPUSH
7092: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIB2 ) ;
7096: LD_INT 25
7098: PPUSH
7099: LD_INT 55
7101: PPUSH
7102: CALL_OW 184
// AddComResearch ( LeLab , TECH_TECH3 ) ;
7106: LD_INT 25
7108: PPUSH
7109: LD_INT 50
7111: PPUSH
7112: CALL_OW 184
// AddComResearch ( LeLab , TECH_WEAP3 ) ;
7116: LD_INT 25
7118: PPUSH
7119: LD_INT 53
7121: PPUSH
7122: CALL_OW 184
// AddComResearch ( LeLab , TECH_SIB3 ) ;
7126: LD_INT 25
7128: PPUSH
7129: LD_INT 56
7131: PPUSH
7132: CALL_OW 184
// end ;
7136: LD_VAR 0 1
7140: RET
// every 0 0$2.3 do
7141: GO 7143
7143: DISABLE
// begin zacni_vynalezat ;
7144: CALL 6983 0 0
// end ;
7148: END
// every 1 1$28 do var Inz ;
7149: GO 7151
7151: DISABLE
7152: LD_INT 0
7154: PPUSH
// begin Inz = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] ] ) ;
7155: LD_ADDR_VAR 0 1
7159: PUSH
7160: LD_INT 22
7162: PUSH
7163: LD_EXP 4
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: PUSH
7172: LD_INT 21
7174: PUSH
7175: LD_INT 1
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: PUSH
7182: LD_INT 25
7184: PUSH
7185: LD_INT 2
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: PUSH
7192: EMPTY
7193: LIST
7194: LIST
7195: LIST
7196: PPUSH
7197: CALL_OW 69
7201: ST_TO_ADDR
// sbirej_bedny ( Inz , Legion ) ;
7202: LD_VAR 0 1
7206: PPUSH
7207: LD_INT 4
7209: PPUSH
7210: CALL 20986 0 2
// opravuj_budovy ( Inz , Legion , side_Le ) ;
7214: LD_VAR 0 1
7218: PPUSH
7219: LD_INT 4
7221: PPUSH
7222: LD_EXP 4
7226: PPUSH
7227: CALL 21216 0 3
// enable ;
7231: ENABLE
// end ;
7232: PPOPN 1
7234: END
// function opravuj ; begin
7235: LD_INT 0
7237: PPUSH
// if KdoOpravuje then
7238: LD_LOC 25
7242: IFFALSE 7246
// exit ;
7244: GO 7283
// KdoOpravuje = opravuj_auta ( [ LeMech1 , LeMech2 ] , 113 , Legion , side_Le , [ ] ) ;
7246: LD_ADDR_LOC 25
7250: PUSH
7251: LD_LOC 7
7255: PUSH
7256: LD_LOC 8
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: PPUSH
7265: LD_INT 113
7267: PPUSH
7268: LD_INT 4
7270: PPUSH
7271: LD_EXP 4
7275: PPUSH
7276: EMPTY
7277: PPUSH
7278: CALL 21734 0 5
7282: ST_TO_ADDR
// end ;
7283: LD_VAR 0 1
7287: RET
// function kuryruj ; begin
7288: LD_INT 0
7290: PPUSH
// if KdoLeci then
7291: LD_LOC 24
7295: IFFALSE 7299
// exit ;
7297: GO 7334
// KdoLeci = kuryruj_lidi ( [ LeSci1 , LeSci2 ] , 114 , Legion , side_Le ) ;
7299: LD_ADDR_LOC 24
7303: PUSH
7304: LD_LOC 5
7308: PUSH
7309: LD_LOC 6
7313: PUSH
7314: EMPTY
7315: LIST
7316: LIST
7317: PPUSH
7318: LD_INT 114
7320: PPUSH
7321: LD_INT 4
7323: PPUSH
7324: LD_EXP 4
7328: PPUSH
7329: CALL 22036 0 4
7333: ST_TO_ADDR
// end ;
7334: LD_VAR 0 1
7338: RET
// export function event_LegionOprava ( Event ) ; begin
7339: LD_INT 0
7341: PPUSH
// case Event of 113 :
7342: LD_VAR 0 1
7346: PUSH
7347: LD_INT 113
7349: DOUBLE
7350: EQUAL
7351: IFTRUE 7355
7353: GO 7377
7355: POP
// begin ComEnterUnit ( KdoOpravuje , LeFact ) ;
7356: LD_LOC 25
7360: PPUSH
7361: LD_INT 26
7363: PPUSH
7364: CALL_OW 120
// KdoOpravuje = [ ] ;
7368: LD_ADDR_LOC 25
7372: PUSH
7373: EMPTY
7374: ST_TO_ADDR
// end ; 114 :
7375: GO 7408
7377: LD_INT 114
7379: DOUBLE
7380: EQUAL
7381: IFTRUE 7385
7383: GO 7407
7385: POP
// begin ComEnterUnit ( KdoLeci , LeLab ) ;
7386: LD_LOC 24
7390: PPUSH
7391: LD_INT 25
7393: PPUSH
7394: CALL_OW 120
// KdoLeci = [ ] ;
7398: LD_ADDR_LOC 24
7402: PUSH
7403: EMPTY
7404: ST_TO_ADDR
// end ; end ;
7405: GO 7408
7407: POP
// end ;
7408: LD_VAR 0 2
7412: RET
// every 2 2$7 do
7413: GO 7415
7415: DISABLE
// begin opravuj ;
7416: CALL 7235 0 0
// kuryruj ;
7420: CALL 7288 0 0
// enable ;
7424: ENABLE
// end ;
7425: END
// function vyrob_autak ; var Chassis , Weapon , P ; begin
7426: LD_INT 0
7428: PPUSH
7429: PPUSH
7430: PPUSH
7431: PPUSH
// P = Rand ( 1 , 100 ) ;
7432: LD_ADDR_VAR 0 4
7436: PUSH
7437: LD_INT 1
7439: PPUSH
7440: LD_INT 100
7442: PPUSH
7443: CALL_OW 12
7447: ST_TO_ADDR
// if ( Difficulty = 1 ) and ( P >= 75 ) then
7448: LD_OWVAR 67
7452: PUSH
7453: LD_INT 1
7455: EQUAL
7456: PUSH
7457: LD_VAR 0 4
7461: PUSH
7462: LD_INT 75
7464: GREATEREQUAL
7465: AND
7466: IFFALSE 7476
// P = 74 ;
7468: LD_ADDR_VAR 0 4
7472: PUSH
7473: LD_INT 74
7475: ST_TO_ADDR
// if P < 18 then
7476: LD_VAR 0 4
7480: PUSH
7481: LD_INT 18
7483: LESS
7484: IFFALSE 7504
// begin Weapon = AR_MULTIMISSILE_BALLISTA ;
7486: LD_ADDR_VAR 0 3
7490: PUSH
7491: LD_INT 22
7493: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
7494: LD_ADDR_VAR 0 2
7498: PUSH
7499: LD_INT 11
7501: ST_TO_ADDR
// end else
7502: GO 7604
// if P < 25 then
7504: LD_VAR 0 4
7508: PUSH
7509: LD_INT 25
7511: LESS
7512: IFFALSE 7532
// begin Weapon = AR_DOUBLE_MACHINE_GUN ;
7514: LD_ADDR_VAR 0 3
7518: PUSH
7519: LD_INT 24
7521: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_INT 11
7529: ST_TO_ADDR
// end else
7530: GO 7604
// if P < 50 then
7532: LD_VAR 0 4
7536: PUSH
7537: LD_INT 50
7539: LESS
7540: IFFALSE 7560
// begin Weapon = AR_FLAME_THROWER ;
7542: LD_ADDR_VAR 0 3
7546: PUSH
7547: LD_INT 26
7549: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
7550: LD_ADDR_VAR 0 2
7554: PUSH
7555: LD_INT 13
7557: ST_TO_ADDR
// end else
7558: GO 7604
// if P < 75 then
7560: LD_VAR 0 4
7564: PUSH
7565: LD_INT 75
7567: LESS
7568: IFFALSE 7588
// begin Weapon = AR_GUN ;
7570: LD_ADDR_VAR 0 3
7574: PUSH
7575: LD_INT 27
7577: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
7578: LD_ADDR_VAR 0 2
7582: PUSH
7583: LD_INT 13
7585: ST_TO_ADDR
// end else
7586: GO 7604
// begin Weapon = AR_ROCKET_LAUNCHER ;
7588: LD_ADDR_VAR 0 3
7592: PUSH
7593: LD_INT 28
7595: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
7596: LD_ADDR_VAR 0 2
7600: PUSH
7601: LD_INT 13
7603: ST_TO_ADDR
// end ; Chassis = Rand ( Chassis , AR_HALF_TRACKED ) ;
7604: LD_ADDR_VAR 0 2
7608: PUSH
7609: LD_VAR 0 2
7613: PPUSH
7614: LD_INT 14
7616: PPUSH
7617: CALL_OW 12
7621: ST_TO_ADDR
// AddComConstruct ( LeFact , Chassis , ENGINE_SIBERITE , CONTROL_MANUAL , Weapon ) ;
7622: LD_INT 26
7624: PPUSH
7625: LD_VAR 0 2
7629: PPUSH
7630: LD_INT 3
7632: PPUSH
7633: LD_INT 1
7635: PPUSH
7636: LD_VAR 0 3
7640: PPUSH
7641: CALL_OW 185
// end ;
7645: LD_VAR 0 1
7649: RET
// function vyrob_autaky ; var I ; begin
7650: LD_INT 0
7652: PPUSH
7653: PPUSH
// for I in Ridici do
7654: LD_ADDR_VAR 0 2
7658: PUSH
7659: LD_LOC 12
7663: PUSH
7664: FOR_IN
7665: IFFALSE 7673
// vyrob_autak ;
7667: CALL 7426 0 0
7671: GO 7664
7673: POP
7674: POP
// end ;
7675: LD_VAR 0 1
7679: RET
// every 0 0$25 do
7680: GO 7682
7682: DISABLE
// begin vyrob_autaky ;
7683: CALL 7650 0 0
// end ;
7687: END
// export function legion_VehicleConstructed ( Veh , Fact ) ; var Ridic ; begin
7688: LD_INT 0
7690: PPUSH
7691: PPUSH
// if GetSide ( Veh ) = side_Le then
7692: LD_VAR 0 1
7696: PPUSH
7697: CALL_OW 255
7701: PUSH
7702: LD_EXP 4
7706: EQUAL
7707: IFFALSE 7811
// begin Wait ( 0 0$2.5 ) ;
7709: LD_INT 88
7711: PPUSH
7712: CALL_OW 67
// Ridic = IsDrivenBy ( Veh ) ;
7716: LD_ADDR_VAR 0 4
7720: PUSH
7721: LD_VAR 0 1
7725: PPUSH
7726: CALL_OW 311
7730: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
7731: LD_INT 105
7733: PPUSH
7734: CALL_OW 67
// ComExitVehicle ( Ridic ) ;
7738: LD_VAR 0 4
7742: PPUSH
7743: CALL_OW 121
// Wait ( 0 0$1 ) ;
7747: LD_INT 35
7749: PPUSH
7750: CALL_OW 67
// while IsDrivenBy ( Veh ) = Ridic do
7754: LD_VAR 0 1
7758: PPUSH
7759: CALL_OW 311
7763: PUSH
7764: LD_VAR 0 4
7768: EQUAL
7769: IFFALSE 7780
// Wait ( 0 0$1 ) ;
7771: LD_INT 35
7773: PPUSH
7774: CALL_OW 67
7778: GO 7754
// AddComEnterUnit ( Ridic , Fact ) ;
7780: LD_VAR 0 4
7784: PPUSH
7785: LD_VAR 0 2
7789: PPUSH
7790: CALL_OW 180
// AddMcUnits ( Makro , [ Veh ] ) ;
7794: LD_LOC 23
7798: PPUSH
7799: LD_VAR 0 1
7803: PUSH
7804: EMPTY
7805: LIST
7806: PPUSH
7807: CALL_OW 390
// end ; end ;
7811: LD_VAR 0 3
7815: RET
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
7816: LD_INT 0
7818: PPUSH
7819: PPUSH
7820: PPUSH
// Lidi = UnitFilter ( Ridici , [ [ F_OUTSIDE ] ] ) ;
7821: LD_ADDR_VAR 0 3
7825: PUSH
7826: LD_LOC 12
7830: PPUSH
7831: LD_INT 56
7833: PUSH
7834: EMPTY
7835: LIST
7836: PUSH
7837: EMPTY
7838: LIST
7839: PPUSH
7840: CALL_OW 72
7844: ST_TO_ADDR
// for I in Lidi do
7845: LD_ADDR_VAR 0 4
7849: PUSH
7850: LD_VAR 0 3
7854: PUSH
7855: FOR_IN
7856: IFFALSE 7890
// if not HasTask ( I ) then
7858: LD_VAR 0 4
7862: PPUSH
7863: CALL_OW 314
7867: NOT
7868: IFFALSE 7888
// begin ComEnterUnit ( I , Veh ) ;
7870: LD_VAR 0 4
7874: PPUSH
7875: LD_VAR 0 1
7879: PPUSH
7880: CALL_OW 120
// exit ;
7884: POP
7885: POP
7886: GO 7892
// end ;
7888: GO 7855
7890: POP
7891: POP
// end ;
7892: LD_VAR 0 2
7896: RET
// function nastupuj_auta ; var Auta , I ; begin
7897: LD_INT 0
7899: PPUSH
7900: PPUSH
7901: PPUSH
// Auta = FilterUnitsInArea ( LegionObrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
7902: LD_ADDR_VAR 0 2
7906: PUSH
7907: LD_INT 16
7909: PPUSH
7910: LD_INT 21
7912: PUSH
7913: LD_INT 2
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 33
7922: PUSH
7923: LD_INT 1
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PUSH
7930: LD_INT 58
7932: PUSH
7933: EMPTY
7934: LIST
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: PPUSH
7941: CALL_OW 70
7945: ST_TO_ADDR
// if not Auta then
7946: LD_VAR 0 2
7950: NOT
7951: IFFALSE 7955
// exit ;
7953: GO 7981
// for I in Auta do
7955: LD_ADDR_VAR 0 3
7959: PUSH
7960: LD_VAR 0 2
7964: PUSH
7965: FOR_IN
7966: IFFALSE 7979
// zarid_ridice ( I ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: CALL 7816 0 1
7977: GO 7965
7979: POP
7980: POP
// end ;
7981: LD_VAR 0 1
7985: RET
// every 0 0$18 do
7986: GO 7988
7988: DISABLE
// begin nastupuj_auta ;
7989: CALL 7897 0 0
// enable ;
7993: ENABLE
// end ;
7994: END
// function zavolej ; var V , R ; begin
7995: LD_INT 0
7997: PPUSH
7998: PPUSH
7999: PPUSH
// DialogueOn ;
8000: CALL_OW 6
// Nabidka_Cena = [ 0 , 0 ] ;
8004: LD_ADDR_LOC 19
8008: PUSH
8009: LD_INT 0
8011: PUSH
8012: LD_INT 0
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: ST_TO_ADDR
// Nabidka_Lidi = 0 ;
8019: LD_ADDR_LOC 20
8023: PUSH
8024: LD_INT 0
8026: ST_TO_ADDR
// if HeikeKilled or not MercAccepted then
8027: LD_EXP 37
8031: PUSH
8032: LD_EXP 34
8036: NOT
8037: OR
8038: IFFALSE 8171
// begin LegionOffer_Heike = false ;
8040: LD_ADDR_EXP 58
8044: PUSH
8045: LD_INT 0
8047: ST_TO_ADDR
// dialog_LegionOfferFarmer ;
8048: CALL 4935 0 0
// V = query_LegionFarmer ;
8052: LD_ADDR_VAR 0 2
8056: PUSH
8057: CALL 4979 0 0
8061: ST_TO_ADDR
// if V < 4 then
8062: LD_VAR 0 2
8066: PUSH
8067: LD_INT 4
8069: LESS
8070: IFFALSE 8157
// begin LegionOffer_Accepted = true ;
8072: LD_ADDR_EXP 59
8076: PUSH
8077: LD_INT 1
8079: ST_TO_ADDR
// dialog_QrLegionFarmer13 ;
8080: CALL 5000 0 0
// Nabidka_Cena = [ [ 60 , 15 ] , [ 90 , 25 ] , [ 120 , 30 ] ] [ V ] ;
8084: LD_ADDR_LOC 19
8088: PUSH
8089: LD_INT 60
8091: PUSH
8092: LD_INT 15
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 90
8101: PUSH
8102: LD_INT 25
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 120
8111: PUSH
8112: LD_INT 30
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: LIST
8123: PUSH
8124: LD_VAR 0 2
8128: ARRAY
8129: ST_TO_ADDR
// Nabidka_Lidi = [ 3 , 5 , 7 ] [ V ] ;
8130: LD_ADDR_LOC 20
8134: PUSH
8135: LD_INT 3
8137: PUSH
8138: LD_INT 5
8140: PUSH
8141: LD_INT 7
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_VAR 0 2
8153: ARRAY
8154: ST_TO_ADDR
// end else
8155: GO 8169
// begin LegionOffer_Accepted = false ;
8157: LD_ADDR_EXP 59
8161: PUSH
8162: LD_INT 0
8164: ST_TO_ADDR
// dialog_QrLegionFarmer4 ;
8165: CALL 5020 0 0
// end ; end else
8169: GO 8322
// begin LegionOffer_Heike = true ;
8171: LD_ADDR_EXP 58
8175: PUSH
8176: LD_INT 1
8178: ST_TO_ADDR
// if MercPaid and OmarKilled then
8179: LD_EXP 33
8183: PUSH
8184: LD_EXP 38
8188: AND
8189: IFFALSE 8197
// dialog_LegionOfferHeike1 else
8191: CALL 4766 0 0
8195: GO 8201
// dialog_LegionOfferHeike2 ;
8197: CALL 4810 0 0
// dialog_LegionOfferHeikeCont ;
8201: CALL 4854 0 0
// V = query_LegionHeike ;
8205: LD_ADDR_VAR 0 2
8209: PUSH
8210: CALL 4874 0 0
8214: ST_TO_ADDR
// if V < 4 then
8215: LD_VAR 0 2
8219: PUSH
8220: LD_INT 4
8222: LESS
8223: IFFALSE 8310
// begin LegionOffer_Accepted = true ;
8225: LD_ADDR_EXP 59
8229: PUSH
8230: LD_INT 1
8232: ST_TO_ADDR
// dialog_QrLegionHeike13 ;
8233: CALL 4895 0 0
// Nabidka_Cena = [ [ 50 , 10 ] , [ 75 , 15 ] , [ 100 , 20 ] ] [ V ] ;
8237: LD_ADDR_LOC 19
8241: PUSH
8242: LD_INT 50
8244: PUSH
8245: LD_INT 10
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: PUSH
8252: LD_INT 75
8254: PUSH
8255: LD_INT 15
8257: PUSH
8258: EMPTY
8259: LIST
8260: LIST
8261: PUSH
8262: LD_INT 100
8264: PUSH
8265: LD_INT 20
8267: PUSH
8268: EMPTY
8269: LIST
8270: LIST
8271: PUSH
8272: EMPTY
8273: LIST
8274: LIST
8275: LIST
8276: PUSH
8277: LD_VAR 0 2
8281: ARRAY
8282: ST_TO_ADDR
// Nabidka_Lidi = [ 3 , 5 , 7 ] [ V ] ;
8283: LD_ADDR_LOC 20
8287: PUSH
8288: LD_INT 3
8290: PUSH
8291: LD_INT 5
8293: PUSH
8294: LD_INT 7
8296: PUSH
8297: EMPTY
8298: LIST
8299: LIST
8300: LIST
8301: PUSH
8302: LD_VAR 0 2
8306: ARRAY
8307: ST_TO_ADDR
// end else
8308: GO 8322
// begin LegionOffer_Accepted = false ;
8310: LD_ADDR_EXP 59
8314: PUSH
8315: LD_INT 0
8317: ST_TO_ADDR
// dialog_QrLegionHeike4 ;
8318: CALL 4915 0 0
// end ; end ; if LegionOffer_Accepted then
8322: LD_EXP 59
8326: IFFALSE 8433
// begin Nabidka_Nakladaky = [ vytvor_nakladak , vytvor_nakladak ] ;
8328: LD_ADDR_LOC 17
8332: PUSH
8333: CALL 9989 0 0
8337: PUSH
8338: CALL 9989 0 0
8342: PUSH
8343: EMPTY
8344: LIST
8345: LIST
8346: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
8347: LD_ADDR_LOC 18
8351: PUSH
8352: EMPTY
8353: ST_TO_ADDR
// for V in Nabidka_Nakladaky do
8354: LD_ADDR_VAR 0 2
8358: PUSH
8359: LD_LOC 17
8363: PUSH
8364: FOR_IN
8365: IFFALSE 8408
// begin PlaceUnitArea ( V , LegionVstup , false ) ;
8367: LD_VAR 0 2
8371: PPUSH
8372: LD_INT 10
8374: PPUSH
8375: LD_INT 0
8377: PPUSH
8378: CALL_OW 49
// Nabidka_Ridici = Nabidka_Ridici union [ IsDrivenBy ( V ) ] ;
8382: LD_ADDR_LOC 18
8386: PUSH
8387: LD_LOC 18
8391: PUSH
8392: LD_VAR 0 2
8396: PPUSH
8397: CALL_OW 311
8401: PUSH
8402: EMPTY
8403: LIST
8404: UNION
8405: ST_TO_ADDR
// end ;
8406: GO 8364
8408: POP
8409: POP
// Hint ( LegionHelp ) ;
8410: LD_STRING LegionHelp
8412: PPUSH
8413: CALL_OW 339
// enable ( 12 ) ;
8417: LD_INT 12
8419: ENABLE_MARKED
// enable ( 15 ) ;
8420: LD_INT 15
8422: ENABLE_MARKED
// ProbihaPredavaniSurovin = true ;
8423: LD_ADDR_LOC 26
8427: PUSH
8428: LD_INT 1
8430: ST_TO_ADDR
// end else
8431: GO 8436
// begin enable ( 11 ) ;
8433: LD_INT 11
8435: ENABLE_MARKED
// end ; DialogueOff ;
8436: CALL_OW 7
// end ;
8440: LD_VAR 0 1
8444: RET
// function ma_dost_materialu ( Bud ) ; var Base , Cans , Sib ; begin
8445: LD_INT 0
8447: PPUSH
8448: PPUSH
8449: PPUSH
8450: PPUSH
// Base = GetBase ( Bud ) ;
8451: LD_ADDR_VAR 0 3
8455: PUSH
8456: LD_VAR 0 1
8460: PPUSH
8461: CALL_OW 274
8465: ST_TO_ADDR
// Cans = Nabidka_Cena [ 1 ] ;
8466: LD_ADDR_VAR 0 4
8470: PUSH
8471: LD_LOC 19
8475: PUSH
8476: LD_INT 1
8478: ARRAY
8479: ST_TO_ADDR
// Sib = Nabidka_Cena [ 2 ] ;
8480: LD_ADDR_VAR 0 5
8484: PUSH
8485: LD_LOC 19
8489: PUSH
8490: LD_INT 2
8492: ARRAY
8493: ST_TO_ADDR
// Result = ( GetResourceType ( Base , MAT_CANS ) >= Cans ) and ( GetResourceType ( Base , MAT_SIBERIT ) >= Sib ) ;
8494: LD_ADDR_VAR 0 2
8498: PUSH
8499: LD_VAR 0 3
8503: PPUSH
8504: LD_INT 1
8506: PPUSH
8507: CALL_OW 275
8511: PUSH
8512: LD_VAR 0 4
8516: GREATEREQUAL
8517: PUSH
8518: LD_VAR 0 3
8522: PPUSH
8523: LD_INT 3
8525: PPUSH
8526: CALL_OW 275
8530: PUSH
8531: LD_VAR 0 5
8535: GREATEREQUAL
8536: AND
8537: ST_TO_ADDR
// end ;
8538: LD_VAR 0 2
8542: RET
// function naloz ( Veh , Bud , Mat , Amount ) ; var Base , Res ; begin
8543: LD_INT 0
8545: PPUSH
8546: PPUSH
8547: PPUSH
// Base = GetBase ( Bud ) ;
8548: LD_ADDR_VAR 0 6
8552: PUSH
8553: LD_VAR 0 2
8557: PPUSH
8558: CALL_OW 274
8562: ST_TO_ADDR
// Result = CanCarryHowMuch ( Veh ) ;
8563: LD_ADDR_VAR 0 5
8567: PUSH
8568: LD_VAR 0 1
8572: PPUSH
8573: CALL_OW 466
8577: ST_TO_ADDR
// if Result > Amount then
8578: LD_VAR 0 5
8582: PUSH
8583: LD_VAR 0 4
8587: GREATER
8588: IFFALSE 8600
// Result = Amount ;
8590: LD_ADDR_VAR 0 5
8594: PUSH
8595: LD_VAR 0 4
8599: ST_TO_ADDR
// Res = GetResourceType ( Base , Mat ) ;
8600: LD_ADDR_VAR 0 7
8604: PUSH
8605: LD_VAR 0 6
8609: PPUSH
8610: LD_VAR 0 3
8614: PPUSH
8615: CALL_OW 275
8619: ST_TO_ADDR
// if Result > Res then
8620: LD_VAR 0 5
8624: PUSH
8625: LD_VAR 0 7
8629: GREATER
8630: IFFALSE 8642
// Result = Res ;
8632: LD_ADDR_VAR 0 5
8636: PUSH
8637: LD_VAR 0 7
8641: ST_TO_ADDR
// SetResourceType ( Base , Mat , Res - Amount ) ;
8642: LD_VAR 0 6
8646: PPUSH
8647: LD_VAR 0 3
8651: PPUSH
8652: LD_VAR 0 7
8656: PUSH
8657: LD_VAR 0 4
8661: MINUS
8662: PPUSH
8663: CALL_OW 277
// AddCargo ( Veh , Mat , Result ) ;
8667: LD_VAR 0 1
8671: PPUSH
8672: LD_VAR 0 3
8676: PPUSH
8677: LD_VAR 0 5
8681: PPUSH
8682: CALL_OW 291
// end ;
8686: LD_VAR 0 5
8690: RET
// every 0 0$11 trigger KonvojPopojizdi and Nabidka_Nakladaky marked 16 do
8691: LD_LOC 16
8695: PUSH
8696: LD_LOC 17
8700: AND
8701: IFFALSE 8711
8703: GO 8705
8705: DISABLE
// begin popojizdej_konvoj ;
8706: CALL 8712 0 0
// enable ;
8710: ENABLE
// end ;
8711: END
// function popojizdej_konvoj ; var I , Hex ; begin
8712: LD_INT 0
8714: PPUSH
8715: PPUSH
8716: PPUSH
// for I in Nabidka_Nakladaky do
8717: LD_ADDR_VAR 0 2
8721: PUSH
8722: LD_LOC 17
8726: PUSH
8727: FOR_IN
8728: IFFALSE 8821
// begin if HasTask ( I ) then
8730: LD_VAR 0 2
8734: PPUSH
8735: CALL_OW 314
8739: IFFALSE 8743
// continue ;
8741: GO 8727
// if not IsDrivenBy ( I ) then
8743: LD_VAR 0 2
8747: PPUSH
8748: CALL_OW 311
8752: NOT
8753: IFFALSE 8757
// continue ;
8755: GO 8727
// Hex = RandHexXYR ( Uprchlici_X , Uprchlici_Y , 8 , false ) ;
8757: LD_ADDR_VAR 0 3
8761: PUSH
8762: LD_LOC 14
8766: PPUSH
8767: LD_LOC 15
8771: PPUSH
8772: LD_INT 8
8774: PPUSH
8775: LD_INT 0
8777: PPUSH
8778: CALL_OW 17
8782: ST_TO_ADDR
// ComMoveXY ( I , Hex [ 1 ] , Hex [ 2 ] ) ;
8783: LD_VAR 0 2
8787: PPUSH
8788: LD_VAR 0 3
8792: PUSH
8793: LD_INT 1
8795: ARRAY
8796: PPUSH
8797: LD_VAR 0 3
8801: PUSH
8802: LD_INT 2
8804: ARRAY
8805: PPUSH
8806: CALL_OW 111
// AddComHold ( I ) ;
8810: LD_VAR 0 2
8814: PPUSH
8815: CALL_OW 200
// end ;
8819: GO 8727
8821: POP
8822: POP
// end ;
8823: LD_VAR 0 1
8827: RET
// function zacni_popojizdet ; begin
8828: LD_INT 0
8830: PPUSH
// if not KonvojPopojizdi then
8831: LD_LOC 16
8835: NOT
8836: IFFALSE 8849
// begin enable ( 16 ) ;
8838: LD_INT 16
8840: ENABLE_MARKED
// KonvojPopojizdi = true ;
8841: LD_ADDR_LOC 16
8845: PUSH
8846: LD_INT 1
8848: ST_TO_ADDR
// end ; end ;
8849: LD_VAR 0 1
8853: RET
// function prestan_popojizdet ; begin
8854: LD_INT 0
8856: PPUSH
// if KonvojPopojizdi then
8857: LD_LOC 16
8861: IFFALSE 8874
// begin disable ( 16 ) ;
8863: LD_INT 16
8865: DISABLE_MARKED
// KonvojPopojizdi = false ;
8866: LD_ADDR_LOC 16
8870: PUSH
8871: LD_INT 0
8873: ST_TO_ADDR
// end ; end ;
8874: LD_VAR 0 1
8878: RET
// function ovladani_nakladaku ; var RuDepot , Bud , J , I , Cans , Sib , N1 , N2 , Ok , Ridic , Nakladak ; begin
8879: LD_INT 0
8881: PPUSH
8882: PPUSH
8883: PPUSH
8884: PPUSH
8885: PPUSH
8886: PPUSH
8887: PPUSH
8888: PPUSH
8889: PPUSH
8890: PPUSH
8891: PPUSH
8892: PPUSH
// if not Nabidka_Nalozeno then
8893: LD_LOC 21
8897: NOT
8898: IFFALSE 9489
// begin Ok = true ;
8900: LD_ADDR_VAR 0 10
8904: PUSH
8905: LD_INT 1
8907: ST_TO_ADDR
// for I = 1 to Nabidka_Nakladaky do
8908: LD_ADDR_VAR 0 5
8912: PUSH
8913: DOUBLE
8914: LD_INT 1
8916: DEC
8917: ST_TO_ADDR
8918: LD_LOC 17
8922: PUSH
8923: FOR_TO
8924: IFFALSE 9038
// begin Nakladak = Nabidka_Nakladaky [ I ] ;
8926: LD_ADDR_VAR 0 12
8930: PUSH
8931: LD_LOC 17
8935: PUSH
8936: LD_VAR 0 5
8940: ARRAY
8941: ST_TO_ADDR
// Ridic = Nabidka_Ridici [ I ] ;
8942: LD_ADDR_VAR 0 11
8946: PUSH
8947: LD_LOC 18
8951: PUSH
8952: LD_VAR 0 5
8956: ARRAY
8957: ST_TO_ADDR
// if GetLives ( Nakladak ) < HRANICE_ZDRAVI then
8958: LD_VAR 0 12
8962: PPUSH
8963: CALL_OW 256
8967: PUSH
8968: LD_INT 1000
8970: LESS
8971: IFFALSE 8997
// begin ComRepairVehicle ( Ridic , Nakladak ) ;
8973: LD_VAR 0 11
8977: PPUSH
8978: LD_VAR 0 12
8982: PPUSH
8983: CALL_OW 129
// Ok = false ;
8987: LD_ADDR_VAR 0 10
8991: PUSH
8992: LD_INT 0
8994: ST_TO_ADDR
// end else
8995: GO 9036
// begin if IsInUnit ( Ridic ) <> Nakladak then
8997: LD_VAR 0 11
9001: PPUSH
9002: CALL_OW 310
9006: PUSH
9007: LD_VAR 0 12
9011: NONEQUAL
9012: IFFALSE 9036
// begin ComEnterUnit ( Ridic , Nakladak ) ;
9014: LD_VAR 0 11
9018: PPUSH
9019: LD_VAR 0 12
9023: PPUSH
9024: CALL_OW 120
// Ok = false ;
9028: LD_ADDR_VAR 0 10
9032: PUSH
9033: LD_INT 0
9035: ST_TO_ADDR
// end ; end ; end ;
9036: GO 8923
9038: POP
9039: POP
// if not Ok then
9040: LD_VAR 0 10
9044: NOT
9045: IFFALSE 9049
// exit ;
9047: GO 9835
// Bud = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_DEPOT ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_WAREHOUSE ] ] ) ;
9049: LD_ADDR_VAR 0 3
9053: PUSH
9054: LD_INT 22
9056: PUSH
9057: LD_EXP 2
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: PUSH
9066: LD_INT 52
9068: PUSH
9069: EMPTY
9070: LIST
9071: PUSH
9072: LD_INT 21
9074: PUSH
9075: LD_INT 3
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PUSH
9082: LD_INT 30
9084: PUSH
9085: LD_INT 0
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: EMPTY
9093: LIST
9094: LIST
9095: LIST
9096: LIST
9097: PPUSH
9098: CALL_OW 69
9102: PUSH
9103: LD_INT 22
9105: PUSH
9106: LD_EXP 2
9110: PUSH
9111: EMPTY
9112: LIST
9113: LIST
9114: PUSH
9115: LD_INT 52
9117: PUSH
9118: EMPTY
9119: LIST
9120: PUSH
9121: LD_INT 21
9123: PUSH
9124: LD_INT 3
9126: PUSH
9127: EMPTY
9128: LIST
9129: LIST
9130: PUSH
9131: LD_INT 30
9133: PUSH
9134: LD_INT 1
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: PUSH
9141: EMPTY
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: PPUSH
9147: CALL_OW 69
9151: UNION
9152: ST_TO_ADDR
// RuDepot = 0 ;
9153: LD_ADDR_VAR 0 2
9157: PUSH
9158: LD_INT 0
9160: ST_TO_ADDR
// for I in Bud do
9161: LD_ADDR_VAR 0 5
9165: PUSH
9166: LD_VAR 0 3
9170: PUSH
9171: FOR_IN
9172: IFFALSE 9199
// if ma_dost_materialu ( I ) then
9174: LD_VAR 0 5
9178: PPUSH
9179: CALL 8445 0 1
9183: IFFALSE 9197
// begin RuDepot = I ;
9185: LD_ADDR_VAR 0 2
9189: PUSH
9190: LD_VAR 0 5
9194: ST_TO_ADDR
// break ;
9195: GO 9199
// end ;
9197: GO 9171
9199: POP
9200: POP
// if not RuDepot then
9201: LD_VAR 0 2
9205: NOT
9206: IFFALSE 9232
// if Bud then
9208: LD_VAR 0 3
9212: IFFALSE 9230
// RuDepot = Bud [ 1 ] else
9214: LD_ADDR_VAR 0 2
9218: PUSH
9219: LD_VAR 0 3
9223: PUSH
9224: LD_INT 1
9226: ARRAY
9227: ST_TO_ADDR
9228: GO 9232
// exit ;
9230: GO 9835
// Uprchlici_X = GetX ( RuDepot ) ;
9232: LD_ADDR_LOC 14
9236: PUSH
9237: LD_VAR 0 2
9241: PPUSH
9242: CALL_OW 250
9246: ST_TO_ADDR
// Uprchlici_Y = GetY ( RuDepot ) ;
9247: LD_ADDR_LOC 15
9251: PUSH
9252: LD_VAR 0 2
9256: PPUSH
9257: CALL_OW 251
9261: ST_TO_ADDR
// zacni_popojizdet ;
9262: CALL 8828 0 0
// for I in Nabidka_Nakladaky do
9266: LD_ADDR_VAR 0 5
9270: PUSH
9271: LD_LOC 17
9275: PUSH
9276: FOR_IN
9277: IFFALSE 9305
// if GetDistUnits ( I , RuDepot ) > 8 then
9279: LD_VAR 0 5
9283: PPUSH
9284: LD_VAR 0 2
9288: PPUSH
9289: CALL_OW 296
9293: PUSH
9294: LD_INT 8
9296: GREATER
9297: IFFALSE 9303
// exit ;
9299: POP
9300: POP
9301: GO 9835
9303: GO 9276
9305: POP
9306: POP
// if not ma_dost_materialu ( RuDepot ) then
9307: LD_VAR 0 2
9311: PPUSH
9312: CALL 8445 0 1
9316: NOT
9317: IFFALSE 9321
// exit ;
9319: GO 9835
// prestan_popojizdet ;
9321: CALL 8854 0 0
// Cans = Nabidka_Cena [ 1 ] ;
9325: LD_ADDR_VAR 0 6
9329: PUSH
9330: LD_LOC 19
9334: PUSH
9335: LD_INT 1
9337: ARRAY
9338: ST_TO_ADDR
// Sib = Nabidka_Cena [ 2 ] ;
9339: LD_ADDR_VAR 0 7
9343: PUSH
9344: LD_LOC 19
9348: PUSH
9349: LD_INT 2
9351: ARRAY
9352: ST_TO_ADDR
// N1 = Nabidka_Nakladaky [ 1 ] ;
9353: LD_ADDR_VAR 0 8
9357: PUSH
9358: LD_LOC 17
9362: PUSH
9363: LD_INT 1
9365: ARRAY
9366: ST_TO_ADDR
// N2 = Nabidka_Nakladaky [ 2 ] ;
9367: LD_ADDR_VAR 0 9
9371: PUSH
9372: LD_LOC 17
9376: PUSH
9377: LD_INT 2
9379: ARRAY
9380: ST_TO_ADDR
// naloz ( N1 , RuDepot , MAT_SIBERIT , Sib ) ;
9381: LD_VAR 0 8
9385: PPUSH
9386: LD_VAR 0 2
9390: PPUSH
9391: LD_INT 3
9393: PPUSH
9394: LD_VAR 0 7
9398: PPUSH
9399: CALL 8543 0 4
// I = naloz ( N1 , RuDepot , MAT_CANS , min ( Cans , CanCarryHowMuch ( N1 ) ) ) ;
9403: LD_ADDR_VAR 0 5
9407: PUSH
9408: LD_VAR 0 8
9412: PPUSH
9413: LD_VAR 0 2
9417: PPUSH
9418: LD_INT 1
9420: PPUSH
9421: LD_VAR 0 6
9425: PPUSH
9426: LD_VAR 0 8
9430: PPUSH
9431: CALL_OW 466
9435: PPUSH
9436: CALL 21358 0 2
9440: PPUSH
9441: CALL 8543 0 4
9445: ST_TO_ADDR
// naloz ( N2 , RuDepot , MAT_CANS , Cans - I ) ;
9446: LD_VAR 0 9
9450: PPUSH
9451: LD_VAR 0 2
9455: PPUSH
9456: LD_INT 1
9458: PPUSH
9459: LD_VAR 0 6
9463: PUSH
9464: LD_VAR 0 5
9468: MINUS
9469: PPUSH
9470: CALL 8543 0 4
// Nabidka_Nalozeno = true ;
9474: LD_ADDR_LOC 21
9478: PUSH
9479: LD_INT 1
9481: ST_TO_ADDR
// Wait ( 0 0$0.2 ) ;
9482: LD_INT 7
9484: PPUSH
9485: CALL_OW 67
// end ; prestan_popojizdet ;
9489: CALL 8854 0 0
// if not Nabidka_Vylozeno then
9493: LD_LOC 22
9497: NOT
9498: IFFALSE 9696
// begin MamPrebarvit = [ ] ;
9500: LD_ADDR_LOC 27
9504: PUSH
9505: EMPTY
9506: ST_TO_ADDR
// for I in Nabidka_Nakladaky do
9507: LD_ADDR_VAR 0 5
9511: PUSH
9512: LD_LOC 17
9516: PUSH
9517: FOR_IN
9518: IFFALSE 9581
// begin MamPrebarvit = MamPrebarvit union [ I ] ;
9520: LD_ADDR_LOC 27
9524: PUSH
9525: LD_LOC 27
9529: PUSH
9530: LD_VAR 0 5
9534: PUSH
9535: EMPTY
9536: LIST
9537: UNION
9538: ST_TO_ADDR
// J = IsDrivenBy ( I ) ;
9539: LD_ADDR_VAR 0 4
9543: PUSH
9544: LD_VAR 0 5
9548: PPUSH
9549: CALL_OW 311
9553: ST_TO_ADDR
// if J then
9554: LD_VAR 0 4
9558: IFFALSE 9579
// MamPrebarvit = MamPrebarvit union [ J ] ;
9560: LD_ADDR_LOC 27
9564: PUSH
9565: LD_LOC 27
9569: PUSH
9570: LD_VAR 0 4
9574: PUSH
9575: EMPTY
9576: LIST
9577: UNION
9578: ST_TO_ADDR
// end ;
9579: GO 9517
9581: POP
9582: POP
// Ok = true ;
9583: LD_ADDR_VAR 0 10
9587: PUSH
9588: LD_INT 1
9590: ST_TO_ADDR
// for I in Nabidka_Nakladaky do
9591: LD_ADDR_VAR 0 5
9595: PUSH
9596: LD_LOC 17
9600: PUSH
9601: FOR_IN
9602: IFFALSE 9677
// begin if not IsInArea ( I , Legion ) then
9604: LD_VAR 0 5
9608: PPUSH
9609: LD_INT 4
9611: PPUSH
9612: CALL_OW 308
9616: NOT
9617: IFFALSE 9675
// begin if not HasTask ( I ) then
9619: LD_VAR 0 5
9623: PPUSH
9624: CALL_OW 314
9628: NOT
9629: IFFALSE 9667
// begin ComMoveUnit ( I , LeDepot ) ;
9631: LD_VAR 0 5
9635: PPUSH
9636: LD_INT 20
9638: PPUSH
9639: CALL_OW 112
// AddComSailEvent ( I , 115 ) ;
9643: LD_VAR 0 5
9647: PPUSH
9648: LD_INT 115
9650: PPUSH
9651: CALL_OW 224
// AddComGive ( I , LeDepot ) ;
9655: LD_VAR 0 5
9659: PPUSH
9660: LD_INT 20
9662: PPUSH
9663: CALL_OW 221
// end ; Ok = false ;
9667: LD_ADDR_VAR 0 10
9671: PUSH
9672: LD_INT 0
9674: ST_TO_ADDR
// end ; end ;
9675: GO 9601
9677: POP
9678: POP
// if not Ok then
9679: LD_VAR 0 10
9683: NOT
9684: IFFALSE 9688
// exit ;
9686: GO 9835
// Nabidka_Vylozeno = true ;
9688: LD_ADDR_LOC 22
9692: PUSH
9693: LD_INT 1
9695: ST_TO_ADDR
// end ; Uprchlici = [ ] ;
9696: LD_ADDR_EXP 61
9700: PUSH
9701: EMPTY
9702: ST_TO_ADDR
// for I = 1 to Nabidka_Lidi do
9703: LD_ADDR_VAR 0 5
9707: PUSH
9708: DOUBLE
9709: LD_INT 1
9711: DEC
9712: ST_TO_ADDR
9713: LD_LOC 20
9717: PUSH
9718: FOR_TO
9719: IFFALSE 9742
// Uprchlici = Uprchlici union [ vytvor_uprchlika ] ;
9721: LD_ADDR_EXP 61
9725: PUSH
9726: LD_EXP 61
9730: PUSH
9731: CALL 9922 0 0
9735: PUSH
9736: EMPTY
9737: LIST
9738: UNION
9739: ST_TO_ADDR
9740: GO 9718
9742: POP
9743: POP
// for I in Uprchlici do
9744: LD_ADDR_VAR 0 5
9748: PUSH
9749: LD_EXP 61
9753: PUSH
9754: FOR_IN
9755: IFFALSE 9774
// PlaceUnitArea ( I , LegionVstup , false ) ;
9757: LD_VAR 0 5
9761: PPUSH
9762: LD_INT 10
9764: PPUSH
9765: LD_INT 0
9767: PPUSH
9768: CALL_OW 49
9772: GO 9754
9774: POP
9775: POP
// ComMoveXY ( Uprchlici , Uprchlici_X , Uprchlici_Y ) ;
9776: LD_EXP 61
9780: PPUSH
9781: LD_LOC 14
9785: PPUSH
9786: LD_LOC 15
9790: PPUSH
9791: CALL_OW 111
// AddComSailEvent ( Uprchlici , 111 ) ;
9795: LD_EXP 61
9799: PPUSH
9800: LD_INT 111
9802: PPUSH
9803: CALL_OW 224
// Nabidka_Nakladaky = [ ] ;
9807: LD_ADDR_LOC 17
9811: PUSH
9812: EMPTY
9813: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
9814: LD_ADDR_LOC 18
9818: PUSH
9819: EMPTY
9820: ST_TO_ADDR
// disable ( 12 ) ;
9821: LD_INT 12
9823: DISABLE_MARKED
// disable ( 15 ) ;
9824: LD_INT 15
9826: DISABLE_MARKED
// ProbihaPredavaniSurovin = false ;
9827: LD_ADDR_LOC 26
9831: PUSH
9832: LD_INT 0
9834: ST_TO_ADDR
// end ;
9835: LD_VAR 0 1
9839: RET
// export function event_KoupeniPrisli ; begin
9840: LD_INT 0
9842: PPUSH
// if not Uprchlici_JsouTam then
9843: LD_LOC 13
9847: NOT
9848: IFFALSE 9917
// begin DialogueOn ;
9850: CALL_OW 6
// CenterOnUnits ( Uprchlici ) ;
9854: LD_EXP 61
9858: PPUSH
9859: CALL_OW 85
// Uprchlici_JsouTam = true ;
9863: LD_ADDR_LOC 13
9867: PUSH
9868: LD_INT 1
9870: ST_TO_ADDR
// SetSide ( Uprchlici , side_Ru ) ;
9871: LD_EXP 61
9875: PPUSH
9876: LD_EXP 2
9880: PPUSH
9881: CALL_OW 235
// Rusove2 = Uprchlici ;
9885: LD_ADDR_EXP 40
9889: PUSH
9890: LD_EXP 61
9894: ST_TO_ADDR
// uprchlik_jdi_k_labu ;
9895: CALL 10245 0 0
// Wait ( 0 0$5 ) ;
9899: LD_INT 175
9901: PPUSH
9902: CALL_OW 67
// Hint ( Legion ) ;
9906: LD_STRING Legion
9908: PPUSH
9909: CALL_OW 339
// DialogueOff ;
9913: CALL_OW 7
// end ; end ;
9917: LD_VAR 0 1
9921: RET
// function vytvor_uprchlika ; begin
9922: LD_INT 0
9924: PPUSH
// UC_Side = side_Upr ;
9925: LD_ADDR_OWVAR 20
9929: PUSH
9930: LD_EXP 5
9934: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
9935: LD_ADDR_OWVAR 21
9939: PUSH
9940: LD_INT 2
9942: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
9943: LD_ADDR_OWVAR 27
9947: PUSH
9948: LD_INT 1
9950: PPUSH
9951: LD_INT 2
9953: PPUSH
9954: CALL_OW 12
9958: ST_TO_ADDR
// HC_Class = CLASS_SOLDIER ;
9959: LD_ADDR_OWVAR 28
9963: PUSH
9964: LD_INT 1
9966: ST_TO_ADDR
// PrepareSoldierSkills ( 6 ) ;
9967: LD_INT 6
9969: PPUSH
9970: CALL_OW 375
// Result = CreateHuman ;
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: CALL_OW 44
9983: ST_TO_ADDR
// end ;
9984: LD_VAR 0 1
9988: RET
// function vytvor_nakladak ; var Ridic ; begin
9989: LD_INT 0
9991: PPUSH
9992: PPUSH
// UC_Side = side_Upr ;
9993: LD_ADDR_OWVAR 20
9997: PUSH
9998: LD_EXP 5
10002: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
10003: LD_ADDR_OWVAR 21
10007: PUSH
10008: LD_INT 2
10010: ST_TO_ADDR
// VC_Chassis = AR_HALF_TRACKED ;
10011: LD_ADDR_OWVAR 37
10015: PUSH
10016: LD_INT 14
10018: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
10019: LD_ADDR_OWVAR 38
10023: PUSH
10024: LD_INT 1
10026: ST_TO_ADDR
// VC_Weapon = AR_CARGO_BAY ;
10027: LD_ADDR_OWVAR 40
10031: PUSH
10032: LD_INT 32
10034: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
10035: LD_ADDR_OWVAR 39
10039: PUSH
10040: LD_INT 3
10042: ST_TO_ADDR
// Result = CreateVehicle ;
10043: LD_ADDR_VAR 0 1
10047: PUSH
10048: CALL_OW 45
10052: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
10053: LD_ADDR_OWVAR 27
10057: PUSH
10058: LD_INT 1
10060: PPUSH
10061: LD_INT 2
10063: PPUSH
10064: CALL_OW 12
10068: ST_TO_ADDR
// HC_Class = CLASS_MECHANIC ;
10069: LD_ADDR_OWVAR 28
10073: PUSH
10074: LD_INT 3
10076: ST_TO_ADDR
// PrepareMechanicSkills ( 4 ) ;
10077: LD_INT 4
10079: PPUSH
10080: CALL_OW 377
// Ridic = CreateHuman ;
10084: LD_ADDR_VAR 0 2
10088: PUSH
10089: CALL_OW 44
10093: ST_TO_ADDR
// PlaceHumanInUnit ( Ridic , Result ) ;
10094: LD_VAR 0 2
10098: PPUSH
10099: LD_VAR 0 1
10103: PPUSH
10104: CALL_OW 52
// end ;
10108: LD_VAR 0 1
10112: RET
// function prchajici ; var I ; begin
10113: LD_INT 0
10115: PPUSH
10116: PPUSH
// Uprchlici = [ Bergkamp ] ;
10117: LD_ADDR_EXP 61
10121: PUSH
10122: LD_EXP 30
10126: PUSH
10127: EMPTY
10128: LIST
10129: ST_TO_ADDR
// for I = Difficulty to Rand ( 5 , 6 ) do
10130: LD_ADDR_VAR 0 2
10134: PUSH
10135: DOUBLE
10136: LD_OWVAR 67
10140: DEC
10141: ST_TO_ADDR
10142: LD_INT 5
10144: PPUSH
10145: LD_INT 6
10147: PPUSH
10148: CALL_OW 12
10152: PUSH
10153: FOR_TO
10154: IFFALSE 10177
// Uprchlici = Uprchlici union [ vytvor_uprchlika ] ;
10156: LD_ADDR_EXP 61
10160: PUSH
10161: LD_EXP 61
10165: PUSH
10166: CALL 9922 0 0
10170: PUSH
10171: EMPTY
10172: LIST
10173: UNION
10174: ST_TO_ADDR
10175: GO 10153
10177: POP
10178: POP
// for I in Uprchlici do
10179: LD_ADDR_VAR 0 2
10183: PUSH
10184: LD_EXP 61
10188: PUSH
10189: FOR_IN
10190: IFFALSE 10209
// PlaceUnitArea ( I , Legion , false ) ;
10192: LD_VAR 0 2
10196: PPUSH
10197: LD_INT 4
10199: PPUSH
10200: LD_INT 0
10202: PPUSH
10203: CALL_OW 49
10207: GO 10189
10209: POP
10210: POP
// ComMoveUnit ( Uprchlici , Burlak ) ;
10211: LD_EXP 61
10215: PPUSH
10216: LD_EXP 6
10220: PPUSH
10221: CALL_OW 112
// AddComSailEvent ( Uprchlici , 112 ) ;
10225: LD_EXP 61
10229: PPUSH
10230: LD_INT 112
10232: PPUSH
10233: CALL_OW 224
// enable ( 14 ) ;
10237: LD_INT 14
10239: ENABLE_MARKED
// end ;
10240: LD_VAR 0 1
10244: RET
// function uprchlik_jdi_k_labu ; var Laby , X , Y ; begin
10245: LD_INT 0
10247: PPUSH
10248: PPUSH
10249: PPUSH
10250: PPUSH
// Laby = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_LAB ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_LAB_HALF ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_LAB_FULL ] ] ) ;
10251: LD_ADDR_VAR 0 2
10255: PUSH
10256: LD_INT 22
10258: PUSH
10259: LD_EXP 2
10263: PUSH
10264: EMPTY
10265: LIST
10266: LIST
10267: PUSH
10268: LD_INT 52
10270: PUSH
10271: EMPTY
10272: LIST
10273: PUSH
10274: LD_INT 21
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: EMPTY
10281: LIST
10282: LIST
10283: PUSH
10284: LD_INT 30
10286: PUSH
10287: LD_INT 6
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: PUSH
10294: EMPTY
10295: LIST
10296: LIST
10297: LIST
10298: LIST
10299: PPUSH
10300: CALL_OW 69
10304: PUSH
10305: LD_INT 22
10307: PUSH
10308: LD_EXP 2
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: PUSH
10317: LD_INT 52
10319: PUSH
10320: EMPTY
10321: LIST
10322: PUSH
10323: LD_INT 21
10325: PUSH
10326: LD_INT 3
10328: PUSH
10329: EMPTY
10330: LIST
10331: LIST
10332: PUSH
10333: LD_INT 30
10335: PUSH
10336: LD_INT 7
10338: PUSH
10339: EMPTY
10340: LIST
10341: LIST
10342: PUSH
10343: EMPTY
10344: LIST
10345: LIST
10346: LIST
10347: LIST
10348: PPUSH
10349: CALL_OW 69
10353: UNION
10354: PUSH
10355: LD_INT 22
10357: PUSH
10358: LD_EXP 2
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: PUSH
10367: LD_INT 52
10369: PUSH
10370: EMPTY
10371: LIST
10372: PUSH
10373: LD_INT 21
10375: PUSH
10376: LD_INT 3
10378: PUSH
10379: EMPTY
10380: LIST
10381: LIST
10382: PUSH
10383: LD_INT 30
10385: PUSH
10386: LD_INT 8
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: LIST
10397: LIST
10398: PPUSH
10399: CALL_OW 69
10403: UNION
10404: ST_TO_ADDR
// if Laby then
10405: LD_VAR 0 2
10409: IFFALSE 10512
// begin Laby = nahoda_seznam ( Laby ) ;
10411: LD_ADDR_VAR 0 2
10415: PUSH
10416: LD_VAR 0 2
10420: PPUSH
10421: CALL 21499 0 1
10425: ST_TO_ADDR
// X = GetX ( Laby ) ;
10426: LD_ADDR_VAR 0 3
10430: PUSH
10431: LD_VAR 0 2
10435: PPUSH
10436: CALL_OW 250
10440: ST_TO_ADDR
// Y = GetY ( Laby ) ;
10441: LD_ADDR_VAR 0 4
10445: PUSH
10446: LD_VAR 0 2
10450: PPUSH
10451: CALL_OW 251
10455: ST_TO_ADDR
// if Bergkamp in Uprchlici then
10456: LD_EXP 30
10460: PUSH
10461: LD_EXP 61
10465: IN
10466: IFFALSE 10489
// AddComMoveXY ( Bergkamp , X , Y ) else
10468: LD_EXP 30
10472: PPUSH
10473: LD_VAR 0 3
10477: PPUSH
10478: LD_VAR 0 4
10482: PPUSH
10483: CALL_OW 171
10487: GO 10512
// AddComMoveXY ( Uprchlici [ 1 ] , X , Y ) ;
10489: LD_EXP 61
10493: PUSH
10494: LD_INT 1
10496: ARRAY
10497: PPUSH
10498: LD_VAR 0 3
10502: PPUSH
10503: LD_VAR 0 4
10507: PPUSH
10508: CALL_OW 171
// end ; end ;
10512: LD_VAR 0 1
10516: RET
// function uprchlici_dotaz ; var Q ; begin
10517: LD_INT 0
10519: PPUSH
10520: PPUSH
// if Uprchlici_JsouTam then
10521: LD_LOC 13
10525: IFFALSE 10529
// exit ;
10527: GO 10653
// disable ( 14 ) ;
10529: LD_INT 14
10531: DISABLE_MARKED
// Uprchlici_JsouTam = true ;
10532: LD_ADDR_LOC 13
10536: PUSH
10537: LD_INT 1
10539: ST_TO_ADDR
// DialogueOn ;
10540: CALL_OW 6
// CenterOnUnits ( Uprchlici ) ;
10544: LD_EXP 61
10548: PPUSH
10549: CALL_OW 85
// Wait ( 0 0$3 ) ;
10553: LD_INT 105
10555: PPUSH
10556: CALL_OW 67
// dialog_LegionFugit ;
10560: CALL 5040 0 0
// Q = query_LegionBergkamp ;
10564: LD_ADDR_VAR 0 2
10568: PUSH
10569: CALL 5084 0 0
10573: ST_TO_ADDR
// if Q = 1 then
10574: LD_VAR 0 2
10578: PUSH
10579: LD_INT 1
10581: EQUAL
10582: IFFALSE 10633
// begin LegionFugit_Accepted = true ;
10584: LD_ADDR_EXP 60
10588: PUSH
10589: LD_INT 1
10591: ST_TO_ADDR
// dialog_QrLegionBergkamp1 ;
10592: CALL 5105 0 0
// SetSide ( Uprchlici , side_Ru ) ;
10596: LD_EXP 61
10600: PPUSH
10601: LD_EXP 2
10605: PPUSH
10606: CALL_OW 235
// Rusove2 = Uprchlici ;
10610: LD_ADDR_EXP 40
10614: PUSH
10615: LD_EXP 61
10619: ST_TO_ADDR
// Hint ( Legion ) ;
10620: LD_STRING Legion
10622: PPUSH
10623: CALL_OW 339
// uprchlik_jdi_k_labu ;
10627: CALL 10245 0 0
// end else
10631: GO 10649
// begin LegionFugit_Accepted = false ;
10633: LD_ADDR_EXP 60
10637: PUSH
10638: LD_INT 0
10640: ST_TO_ADDR
// dialog_QrLegionBergkamp2 ;
10641: CALL 5137 0 0
// uprchlici_zacnete_odchazet ;
10645: CALL 10658 0 0
// end ; DialogueOff ;
10649: CALL_OW 7
// end ;
10653: LD_VAR 0 1
10657: RET
// export function uprchlici_zacnete_odchazet ; begin
10658: LD_INT 0
10660: PPUSH
// ComMoveToArea ( Uprchlici , Legion ) ;
10661: LD_EXP 61
10665: PPUSH
10666: LD_INT 4
10668: PPUSH
10669: CALL_OW 113
// enable ( 13 ) ;
10673: LD_INT 13
10675: ENABLE_MARKED
// end ;
10676: LD_VAR 0 1
10680: RET
// export function event_LegionPrebarvi ; begin
10681: LD_INT 0
10683: PPUSH
// SetSide ( MamPrebarvit , side_Le ) ;
10684: LD_LOC 27
10688: PPUSH
10689: LD_EXP 4
10693: PPUSH
10694: CALL_OW 235
// MamPrebarvit = [ ] ;
10698: LD_ADDR_LOC 27
10702: PUSH
10703: EMPTY
10704: ST_TO_ADDR
// end ;
10705: LD_VAR 0 1
10709: RET
// export function event_UprchliciPrisli ; begin
10710: LD_INT 0
10712: PPUSH
// uprchlici_dotaz ;
10713: CALL 10517 0 0
// end ;
10717: LD_VAR 0 1
10721: RET
// every 0 0$3.9 marked 13 do var Tam , Kdo ;
10722: GO 10724
10724: DISABLE
10725: LD_INT 0
10727: PPUSH
10728: PPUSH
// begin if not Uprchlici then
10729: LD_EXP 61
10733: NOT
10734: IFFALSE 10738
// exit ;
10736: GO 10837
// Tam = Uprchlici isect FilterUnitsInArea ( Legion , [ [ F_SIDE , side_Upr ] ] ) ;
10738: LD_ADDR_VAR 0 1
10742: PUSH
10743: LD_EXP 61
10747: PUSH
10748: LD_INT 4
10750: PPUSH
10751: LD_INT 22
10753: PUSH
10754: LD_EXP 5
10758: PUSH
10759: EMPTY
10760: LIST
10761: LIST
10762: PUSH
10763: EMPTY
10764: LIST
10765: PPUSH
10766: CALL_OW 70
10770: ISECT
10771: ST_TO_ADDR
// SetSide ( Tam , side_Le ) ;
10772: LD_VAR 0 1
10776: PPUSH
10777: LD_EXP 4
10781: PPUSH
10782: CALL_OW 235
// Uprchlici = Uprchlici diff Tam ;
10786: LD_ADDR_EXP 61
10790: PUSH
10791: LD_EXP 61
10795: PUSH
10796: LD_VAR 0 1
10800: DIFF
10801: ST_TO_ADDR
// Rusove2 = Rusove2 diff Tam ;
10802: LD_ADDR_EXP 40
10806: PUSH
10807: LD_EXP 40
10811: PUSH
10812: LD_VAR 0 1
10816: DIFF
10817: ST_TO_ADDR
// if Uprchlici then
10818: LD_EXP 61
10822: IFFALSE 10837
// begin ComMoveToArea ( Uprchlici , Legion ) ;
10824: LD_EXP 61
10828: PPUSH
10829: LD_INT 4
10831: PPUSH
10832: CALL_OW 113
// enable ;
10836: ENABLE
// end ; end ;
10837: PPOPN 2
10839: END
// every 0 0$1.2 trigger vidi_strana_cloveka ( side_Upr , side_Ru ) marked 14 do
10840: LD_EXP 5
10844: PPUSH
10845: LD_EXP 2
10849: PPUSH
10850: CALL 21400 0 2
10854: IFFALSE 10881
10856: GO 10858
10858: DISABLE
// begin ComCancel ( Uprchlici ) ;
10859: LD_EXP 61
10863: PPUSH
10864: CALL_OW 127
// ComHold ( Uprchlici ) ;
10868: LD_EXP 61
10872: PPUSH
10873: CALL_OW 140
// uprchlici_dotaz ;
10877: CALL 10517 0 0
// end ;
10881: END
// every 13 13$0 do
10882: GO 10884
10884: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
10885: LD_INT 35
10887: PPUSH
10888: LD_INT 4200
10890: PPUSH
10891: CALL_OW 12
10895: PPUSH
10896: CALL_OW 67
// while ProbihaUtok do
10900: LD_EXP 62
10904: IFFALSE 10915
// Wait ( 0 0$30 ) ;
10906: LD_INT 1050
10908: PPUSH
10909: CALL_OW 67
10913: GO 10900
// zavolej ;
10915: CALL 7995 0 0
// end ;
10919: END
// every 3 3$0 marked 11 do
10920: GO 10922
10922: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
10923: LD_INT 35
10925: PPUSH
10926: LD_INT 4200
10928: PPUSH
10929: CALL_OW 12
10933: PPUSH
10934: CALL_OW 67
// prchajici ;
10938: CALL 10113 0 0
// end ;
10942: END
// every 0 0$4.9 marked 12 do
10943: GO 10945
10945: DISABLE
// begin enable ;
10946: ENABLE
// ovladani_nakladaku ;
10947: CALL 8879 0 0
// end ;
10951: END
// every 0 0$1 marked 15 do
10952: GO 10954
10954: DISABLE
// begin Wait ( dif_LegionTimeout [ Difficulty ] ) ;
10955: LD_EXP 57
10959: PUSH
10960: LD_OWVAR 67
10964: ARRAY
10965: PPUSH
10966: CALL_OW 67
// if not ProbihaPredavaniSurovin then
10970: LD_LOC 26
10974: NOT
10975: IFFALSE 10979
// exit ;
10977: GO 10983
// ukonci_nabidku ;
10979: CALL 10984 0 0
// end ;
10983: END
// function ukonci_nabidku ; var I ; begin
10984: LD_INT 0
10986: PPUSH
10987: PPUSH
// if Nabidka_Nalozeno then
10988: LD_LOC 21
10992: IFFALSE 10996
// exit ;
10994: GO 11129
// if Nabidka_Vylozeno then
10996: LD_LOC 22
11000: IFFALSE 11004
// exit ;
11002: GO 11129
// if not ProbihaPredavaniSurovin then
11004: LD_LOC 26
11008: NOT
11009: IFFALSE 11013
// exit ;
11011: GO 11129
// ProbihaPredavaniSurovin = false ;
11013: LD_ADDR_LOC 26
11017: PUSH
11018: LD_INT 0
11020: ST_TO_ADDR
// prestan_popojizdet ;
11021: CALL 8854 0 0
// disable ( 12 ) ;
11025: LD_INT 12
11027: DISABLE_MARKED
// disable ( 15 ) ;
11028: LD_INT 15
11030: DISABLE_MARKED
// for I in Nabidka_Nakladaky do
11031: LD_ADDR_VAR 0 2
11035: PUSH
11036: LD_LOC 17
11040: PUSH
11041: FOR_IN
11042: IFFALSE 11098
// begin if ( GetSide ( I ) = side_Ru ) then
11044: LD_VAR 0 2
11048: PPUSH
11049: CALL_OW 255
11053: PUSH
11054: LD_EXP 2
11058: EQUAL
11059: IFFALSE 11063
// continue ;
11061: GO 11041
// SetSide ( I , side_Le ) ;
11063: LD_VAR 0 2
11067: PPUSH
11068: LD_EXP 4
11072: PPUSH
11073: CALL_OW 235
// SetSide ( IsDrivenBy ( I ) , side_Le ) ;
11077: LD_VAR 0 2
11081: PPUSH
11082: CALL_OW 311
11086: PPUSH
11087: LD_EXP 4
11091: PPUSH
11092: CALL_OW 235
// end ;
11096: GO 11041
11098: POP
11099: POP
// ComMoveToArea ( Nabidka_Nakladaky , LeDepot ) ;
11100: LD_LOC 17
11104: PPUSH
11105: LD_INT 20
11107: PPUSH
11108: CALL_OW 113
// Nabidka_Nakladaky = [ ] ;
11112: LD_ADDR_LOC 17
11116: PUSH
11117: EMPTY
11118: ST_TO_ADDR
// Nabidka_Ridici = [ ] ;
11119: LD_ADDR_LOC 18
11123: PUSH
11124: EMPTY
11125: ST_TO_ADDR
// enable ( 11 ) ;
11126: LD_INT 11
11128: ENABLE_MARKED
// end ;
11129: LD_VAR 0 1
11133: RET
// function testuj_konec_nabidky ( Un ) ; begin
11134: LD_INT 0
11136: PPUSH
// if ( Un in Nabidka_Nakladaky ) or ( Un in Nabidka_Ridici ) then
11137: LD_VAR 0 1
11141: PUSH
11142: LD_LOC 17
11146: IN
11147: PUSH
11148: LD_VAR 0 1
11152: PUSH
11153: LD_LOC 18
11157: IN
11158: OR
11159: IFFALSE 11165
// ukonci_nabidku ;
11161: CALL 10984 0 0
// end ;
11165: LD_VAR 0 2
11169: RET
// export function legion_Contact ( Side1 , Side2 ) ; begin
11170: LD_INT 0
11172: PPUSH
// if ( ( Side1 = side_Ru ) and ( Side2 = side_Le ) ) or ( ( Side1 = side_Le ) and ( Side1 = side_Ru ) ) then
11173: LD_VAR 0 1
11177: PUSH
11178: LD_EXP 2
11182: EQUAL
11183: PUSH
11184: LD_VAR 0 2
11188: PUSH
11189: LD_EXP 4
11193: EQUAL
11194: AND
11195: PUSH
11196: LD_VAR 0 1
11200: PUSH
11201: LD_EXP 4
11205: EQUAL
11206: PUSH
11207: LD_VAR 0 1
11211: PUSH
11212: LD_EXP 2
11216: EQUAL
11217: AND
11218: OR
11219: IFFALSE 11231
// if ProbihaPredavaniSurovin then
11221: LD_LOC 26
11225: IFFALSE 11231
// ukonci_nabidku ;
11227: CALL 10984 0 0
// end ;
11231: LD_VAR 0 3
11235: RET
// export function legion_VehicleCaptured ( VewNew , VehOld , OrigSide , Hum ) ; begin
11236: LD_INT 0
11238: PPUSH
// testuj_konec_nabidky ( VehOld ) ;
11239: LD_VAR 0 2
11243: PPUSH
11244: CALL 11134 0 1
// end ;
11248: LD_VAR 0 5
11252: RET
// export function legion_UnitDestroyed ( Un ) ; var Cancel ; begin
11253: LD_INT 0
11255: PPUSH
11256: PPUSH
// if Un in Obranci then
11257: LD_VAR 0 1
11261: PUSH
11262: LD_LOC 10
11266: IN
11267: IFFALSE 11288
// Obranci = Obranci diff [ Un ] ;
11269: LD_ADDR_LOC 10
11273: PUSH
11274: LD_LOC 10
11278: PUSH
11279: LD_VAR 0 1
11283: PUSH
11284: EMPTY
11285: LIST
11286: DIFF
11287: ST_TO_ADDR
// if Un in Mechanici then
11288: LD_VAR 0 1
11292: PUSH
11293: LD_LOC 11
11297: IN
11298: IFFALSE 11319
// Mechanici = Mechanici diff [ Un ] ;
11300: LD_ADDR_LOC 11
11304: PUSH
11305: LD_LOC 11
11309: PUSH
11310: LD_VAR 0 1
11314: PUSH
11315: EMPTY
11316: LIST
11317: DIFF
11318: ST_TO_ADDR
// if Un in Ridici then
11319: LD_VAR 0 1
11323: PUSH
11324: LD_LOC 12
11328: IN
11329: IFFALSE 11350
// Ridici = Ridici diff [ Un ] ;
11331: LD_ADDR_LOC 12
11335: PUSH
11336: LD_LOC 12
11340: PUSH
11341: LD_VAR 0 1
11345: PUSH
11346: EMPTY
11347: LIST
11348: DIFF
11349: ST_TO_ADDR
// if Un in Uprchlici then
11350: LD_VAR 0 1
11354: PUSH
11355: LD_EXP 61
11359: IN
11360: IFFALSE 11381
// Uprchlici = Uprchlici diff [ Un ] ;
11362: LD_ADDR_EXP 61
11366: PUSH
11367: LD_EXP 61
11371: PUSH
11372: LD_VAR 0 1
11376: PUSH
11377: EMPTY
11378: LIST
11379: DIFF
11380: ST_TO_ADDR
// if Un in KdoLeci then
11381: LD_VAR 0 1
11385: PUSH
11386: LD_LOC 24
11390: IN
11391: IFFALSE 11412
// KdoLeci = KdoLeci diff [ Un ] ;
11393: LD_ADDR_LOC 24
11397: PUSH
11398: LD_LOC 24
11402: PUSH
11403: LD_VAR 0 1
11407: PUSH
11408: EMPTY
11409: LIST
11410: DIFF
11411: ST_TO_ADDR
// if Un in KdoOpravuje then
11412: LD_VAR 0 1
11416: PUSH
11417: LD_LOC 25
11421: IN
11422: IFFALSE 11443
// KdoOpravuje = KdoOpravuje diff [ Un ] ;
11424: LD_ADDR_LOC 25
11428: PUSH
11429: LD_LOC 25
11433: PUSH
11434: LD_VAR 0 1
11438: PUSH
11439: EMPTY
11440: LIST
11441: DIFF
11442: ST_TO_ADDR
// testuj_konec_nabidky ( Un ) ;
11443: LD_VAR 0 1
11447: PPUSH
11448: CALL 11134 0 1
// if Un in Nabidka_Nakladaky then
11452: LD_VAR 0 1
11456: PUSH
11457: LD_LOC 17
11461: IN
11462: IFFALSE 11483
// Nabidka_Nakladaky = Nabidka_Nakladaky diff [ Un ] ;
11464: LD_ADDR_LOC 17
11468: PUSH
11469: LD_LOC 17
11473: PUSH
11474: LD_VAR 0 1
11478: PUSH
11479: EMPTY
11480: LIST
11481: DIFF
11482: ST_TO_ADDR
// if Un in Nabidka_Ridici then
11483: LD_VAR 0 1
11487: PUSH
11488: LD_LOC 18
11492: IN
11493: IFFALSE 11514
// Nabidka_Ridici = Nabidka_Ridici diff [ Un ] ;
11495: LD_ADDR_LOC 18
11499: PUSH
11500: LD_LOC 18
11504: PUSH
11505: LD_VAR 0 1
11509: PUSH
11510: EMPTY
11511: LIST
11512: DIFF
11513: ST_TO_ADDR
// end ; end_of_file
11514: LD_VAR 0 2
11518: RET
// var ArSci1 , ArSci2 , ArSci3 , ArSci4 , ArMech1 , ArMech2 , ArEng1 , ArEng2 ; var ArMechDalkar ; var Obranci , Sejkove , VolnyLidi ; var Auta , Utok_Auta ; var KdoOtravuje ; var MakroObrana ; var Miny ; var ObranaBehemota ; var MakroKamikaze ; var RegUtok ; var VolnyRidiciOpicaci ; var ArDalkar ; var KolikDalkovych ; var DelamDalkare ; var MakroUtok ; export ProbihaUtok ; var CisloUtoku ; var PrvniUtok ; var Utok_ZbyvaMinut ; var CasyUtoku ; var PstZbrane ; var VidelRusa ; var MakroPresunZakladna ; var BeziStahovani ; var MaxOpice ; var ZpozdeniOpice ; var PstOpiceRus ; var OpiceLimit ; var OpiceNajednouPocet ; var KdoLeci ; var KdoOpravuje ; var KdoLakaOpice ; export function init_arabi ; var Reg , Base ; begin
11519: LD_INT 0
11521: PPUSH
11522: PPUSH
11523: PPUSH
// disable ( 31 ) ;
11524: LD_INT 31
11526: DISABLE_MARKED
// disable ( 32 ) ;
11527: LD_INT 32
11529: DISABLE_MARKED
// disable ( 33 ) ;
11530: LD_INT 33
11532: DISABLE_MARKED
// SetBName ( ArDepot , newsamark ) ;
11533: LD_INT 1
11535: PPUSH
11536: LD_STRING newsamark
11538: PPUSH
11539: CALL_OW 500
// KdoOtravuje = [ ] ;
11543: LD_ADDR_LOC 42
11547: PUSH
11548: EMPTY
11549: ST_TO_ADDR
// Auta = [ ] ;
11550: LD_ADDR_LOC 40
11554: PUSH
11555: EMPTY
11556: ST_TO_ADDR
// Utok_Auta = [ ] ;
11557: LD_ADDR_LOC 41
11561: PUSH
11562: EMPTY
11563: ST_TO_ADDR
// ObranaBehemota = [ ArProp1 , ArProp2 , ArProp3 ] ;
11564: LD_ADDR_LOC 45
11568: PUSH
11569: LD_INT 44
11571: PUSH
11572: LD_INT 45
11574: PUSH
11575: LD_INT 46
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: LIST
11582: ST_TO_ADDR
// VolnyRidiciOpicaci = 0 ;
11583: LD_ADDR_LOC 48
11587: PUSH
11588: LD_INT 0
11590: ST_TO_ADDR
// ArDalkar = 0 ;
11591: LD_ADDR_LOC 49
11595: PUSH
11596: LD_INT 0
11598: ST_TO_ADDR
// KolikDalkovych = 0 ;
11599: LD_ADDR_LOC 50
11603: PUSH
11604: LD_INT 0
11606: ST_TO_ADDR
// DelamDalkare = false ;
11607: LD_ADDR_LOC 51
11611: PUSH
11612: LD_INT 0
11614: ST_TO_ADDR
// ProbihaUtok = false ;
11615: LD_ADDR_EXP 62
11619: PUSH
11620: LD_INT 0
11622: ST_TO_ADDR
// Utok_ZbyvaMinut = - 1 ;
11623: LD_ADDR_LOC 55
11627: PUSH
11628: LD_INT 1
11630: NEG
11631: ST_TO_ADDR
// CisloUtoku = 1 ;
11632: LD_ADDR_LOC 53
11636: PUSH
11637: LD_INT 1
11639: ST_TO_ADDR
// VidelRusa = false ;
11640: LD_ADDR_LOC 58
11644: PUSH
11645: LD_INT 0
11647: ST_TO_ADDR
// KdoLeci = [ ] ;
11648: LD_ADDR_LOC 66
11652: PUSH
11653: EMPTY
11654: ST_TO_ADDR
// KdoOpravuje = [ ] ;
11655: LD_ADDR_LOC 67
11659: PUSH
11660: EMPTY
11661: ST_TO_ADDR
// KdoLakaOpice = [ ] ;
11662: LD_ADDR_LOC 68
11666: PUSH
11667: EMPTY
11668: ST_TO_ADDR
// if Difficulty = 1 then
11669: LD_OWVAR 67
11673: PUSH
11674: LD_INT 1
11676: EQUAL
11677: IFFALSE 11693
// begin DestroyUnit ( ArBunk2 ) ;
11679: LD_INT 34
11681: PPUSH
11682: CALL_OW 65
// DestroyUnit ( ArBunk5 ) ;
11686: LD_INT 42
11688: PPUSH
11689: CALL_OW 65
// end ; PrvniUtok = dif_PrvniUtok [ Difficulty ] ;
11693: LD_ADDR_LOC 54
11697: PUSH
11698: LD_EXP 49
11702: PUSH
11703: LD_OWVAR 67
11707: ARRAY
11708: ST_TO_ADDR
// CasyUtoku = dif_CasovacUtoku [ Difficulty ] ;
11709: LD_ADDR_LOC 56
11713: PUSH
11714: LD_EXP 48
11718: PUSH
11719: LD_OWVAR 67
11723: ARRAY
11724: ST_TO_ADDR
// PstZbrane = dif_PstZbrane [ Difficulty ] ;
11725: LD_ADDR_LOC 57
11729: PUSH
11730: LD_EXP 50
11734: PUSH
11735: LD_OWVAR 67
11739: ARRAY
11740: ST_TO_ADDR
// MaxOpice = dif_MaxOpice [ Difficulty ] ;
11741: LD_ADDR_LOC 61
11745: PUSH
11746: LD_EXP 51
11750: PUSH
11751: LD_OWVAR 67
11755: ARRAY
11756: ST_TO_ADDR
// ZpozdeniOpice = dif_ZpozdeniOpice [ Difficulty ] ;
11757: LD_ADDR_LOC 62
11761: PUSH
11762: LD_EXP 52
11766: PUSH
11767: LD_OWVAR 67
11771: ARRAY
11772: ST_TO_ADDR
// PstOpiceRus = dif_PstOpiceRus [ Difficulty ] ;
11773: LD_ADDR_LOC 63
11777: PUSH
11778: LD_EXP 53
11782: PUSH
11783: LD_OWVAR 67
11787: ARRAY
11788: ST_TO_ADDR
// OpiceLimit = dif_OpiceLimit [ Difficulty ] ;
11789: LD_ADDR_LOC 64
11793: PUSH
11794: LD_EXP 54
11798: PUSH
11799: LD_OWVAR 67
11803: ARRAY
11804: ST_TO_ADDR
// OpiceNajednouPocet = dif_OpiceNajednouPocet [ Difficulty ] ;
11805: LD_ADDR_LOC 65
11809: PUSH
11810: LD_EXP 55
11814: PUSH
11815: LD_OWVAR 67
11819: ARRAY
11820: ST_TO_ADDR
// vytvor_postavy ;
11821: CALL 12455 0 0
// Base = GetBase ( ArDepot ) ;
11825: LD_ADDR_VAR 0 3
11829: PUSH
11830: LD_INT 1
11832: PPUSH
11833: CALL_OW 274
11837: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , Rand ( 300 , 400 ) ) ;
11838: LD_VAR 0 3
11842: PPUSH
11843: LD_INT 1
11845: PPUSH
11846: LD_INT 300
11848: PPUSH
11849: LD_INT 400
11851: PPUSH
11852: CALL_OW 12
11856: PPUSH
11857: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , Rand ( 100 , 300 ) ) ;
11861: LD_VAR 0 3
11865: PPUSH
11866: LD_INT 2
11868: PPUSH
11869: LD_INT 100
11871: PPUSH
11872: LD_INT 300
11874: PPUSH
11875: CALL_OW 12
11879: PPUSH
11880: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , Rand ( 40 , 80 ) ) ;
11884: LD_VAR 0 3
11888: PPUSH
11889: LD_INT 3
11891: PPUSH
11892: LD_INT 40
11894: PPUSH
11895: LD_INT 80
11897: PPUSH
11898: CALL_OW 12
11902: PPUSH
11903: CALL_OW 277
// Reg = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_PROTECT , AraboveObrana ] ] ) ;
11907: LD_ADDR_VAR 0 2
11911: PUSH
11912: LD_EXP 3
11916: PPUSH
11917: LD_INT 3
11919: PUSH
11920: LD_INT 12
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: PUSH
11927: EMPTY
11928: LIST
11929: PPUSH
11930: CALL_OW 399
11934: ST_TO_ADDR
// MakroObrana = McDefend ( 0 , Reg , Sejkove union Obranci union VolnyLidi union [ ArBarracks , ArBunk1 , ArBunk2 , ArBunk3 , ArBunk4 , ArBunk5 , ArBunk6 ] , [ [ MC_AREA_DONT_LEAVE , Arabove ] ] ) ;
11935: LD_ADDR_LOC 43
11939: PUSH
11940: LD_INT 0
11942: PPUSH
11943: LD_VAR 0 2
11947: PPUSH
11948: LD_LOC 38
11952: PUSH
11953: LD_LOC 37
11957: UNION
11958: PUSH
11959: LD_LOC 39
11963: UNION
11964: PUSH
11965: LD_INT 32
11967: PUSH
11968: LD_INT 33
11970: PUSH
11971: LD_INT 34
11973: PUSH
11974: LD_INT 19
11976: PUSH
11977: LD_INT 41
11979: PUSH
11980: LD_INT 42
11982: PUSH
11983: LD_INT 18
11985: PUSH
11986: EMPTY
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: LIST
11992: LIST
11993: LIST
11994: UNION
11995: PPUSH
11996: LD_INT 2
11998: PUSH
11999: LD_INT 5
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: PUSH
12006: EMPTY
12007: LIST
12008: PPUSH
12009: CALL_OW 401
12013: ST_TO_ADDR
// MakroPresunZakladna = McCustom ( 1 , Sejkove union Obranci union VolnyLidi ) ;
12014: LD_ADDR_LOC 59
12018: PUSH
12019: LD_INT 1
12021: PPUSH
12022: LD_LOC 38
12026: PUSH
12027: LD_LOC 37
12031: UNION
12032: PUSH
12033: LD_LOC 39
12037: UNION
12038: PPUSH
12039: CALL_OW 416
12043: ST_TO_ADDR
// RegUtok = McRegistry ( side_Ar , [ [ MC_REG_AREA_TO_GUARD , RusoveUtok ] , MC_REG_IGNORE_FOG ] ) ;
12044: LD_ADDR_LOC 47
12048: PUSH
12049: LD_EXP 3
12053: PPUSH
12054: LD_INT 2
12056: PUSH
12057: LD_INT 11
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: LD_INT 7
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: PPUSH
12071: CALL_OW 399
12075: ST_TO_ADDR
// MakroKamikaze = McAttack ( 20 , RegUtok , [ ] , [ MC_NO_STOP ] ) ;
12076: LD_ADDR_LOC 46
12080: PUSH
12081: LD_INT 20
12083: PPUSH
12084: LD_LOC 47
12088: PPUSH
12089: EMPTY
12090: PPUSH
12091: LD_INT 10
12093: PUSH
12094: EMPTY
12095: LIST
12096: PPUSH
12097: CALL_OW 402
12101: ST_TO_ADDR
// MakroUtok = 0 ;
12102: LD_ADDR_LOC 52
12106: PUSH
12107: LD_INT 0
12109: ST_TO_ADDR
// init_miny ;
12110: CALL 12119 0 0
// end ;
12114: LD_VAR 0 1
12118: RET
// function init_miny ; var M ; begin
12119: LD_INT 0
12121: PPUSH
12122: PPUSH
// if Difficulty = 1 then
12123: LD_OWVAR 67
12127: PUSH
12128: LD_INT 1
12130: EQUAL
12131: IFFALSE 12142
// Miny = [ ] else
12133: LD_ADDR_LOC 44
12137: PUSH
12138: EMPTY
12139: ST_TO_ADDR
12140: GO 12450
// begin Miny = [ [ 168 , 77 ] , [ 169 , 76 ] , [ 170 , 75 ] , [ 179 , 90 ] , [ 178 , 87 ] , [ 179 , 86 ] ] ;
12142: LD_ADDR_LOC 44
12146: PUSH
12147: LD_INT 168
12149: PUSH
12150: LD_INT 77
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: LD_INT 169
12159: PUSH
12160: LD_INT 76
12162: PUSH
12163: EMPTY
12164: LIST
12165: LIST
12166: PUSH
12167: LD_INT 170
12169: PUSH
12170: LD_INT 75
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: PUSH
12177: LD_INT 179
12179: PUSH
12180: LD_INT 90
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: PUSH
12187: LD_INT 178
12189: PUSH
12190: LD_INT 87
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 179
12199: PUSH
12200: LD_INT 86
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: EMPTY
12208: LIST
12209: LIST
12210: LIST
12211: LIST
12212: LIST
12213: LIST
12214: ST_TO_ADDR
// if Difficulty = 3 then
12215: LD_OWVAR 67
12219: PUSH
12220: LD_INT 3
12222: EQUAL
12223: IFFALSE 12403
// Miny = Miny ^ [ [ 170 , 79 ] , [ 171 , 78 ] , [ 172 , 77 ] , [ 87 , 5 ] , [ 89 , 13 ] , [ 97 , 24 ] , [ 97 , 23 ] , [ 103 , 33 ] , [ 111 , 41 ] , [ 120 , 52 ] , [ 128 , 57 ] , [ 140 , 62 ] , [ 148 , 76 ] , [ 154 , 86 ] , [ 161 , 87 ] ] ;
12225: LD_ADDR_LOC 44
12229: PUSH
12230: LD_LOC 44
12234: PUSH
12235: LD_INT 170
12237: PUSH
12238: LD_INT 79
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 171
12247: PUSH
12248: LD_INT 78
12250: PUSH
12251: EMPTY
12252: LIST
12253: LIST
12254: PUSH
12255: LD_INT 172
12257: PUSH
12258: LD_INT 77
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PUSH
12265: LD_INT 87
12267: PUSH
12268: LD_INT 5
12270: PUSH
12271: EMPTY
12272: LIST
12273: LIST
12274: PUSH
12275: LD_INT 89
12277: PUSH
12278: LD_INT 13
12280: PUSH
12281: EMPTY
12282: LIST
12283: LIST
12284: PUSH
12285: LD_INT 97
12287: PUSH
12288: LD_INT 24
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: PUSH
12295: LD_INT 97
12297: PUSH
12298: LD_INT 23
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PUSH
12305: LD_INT 103
12307: PUSH
12308: LD_INT 33
12310: PUSH
12311: EMPTY
12312: LIST
12313: LIST
12314: PUSH
12315: LD_INT 111
12317: PUSH
12318: LD_INT 41
12320: PUSH
12321: EMPTY
12322: LIST
12323: LIST
12324: PUSH
12325: LD_INT 120
12327: PUSH
12328: LD_INT 52
12330: PUSH
12331: EMPTY
12332: LIST
12333: LIST
12334: PUSH
12335: LD_INT 128
12337: PUSH
12338: LD_INT 57
12340: PUSH
12341: EMPTY
12342: LIST
12343: LIST
12344: PUSH
12345: LD_INT 140
12347: PUSH
12348: LD_INT 62
12350: PUSH
12351: EMPTY
12352: LIST
12353: LIST
12354: PUSH
12355: LD_INT 148
12357: PUSH
12358: LD_INT 76
12360: PUSH
12361: EMPTY
12362: LIST
12363: LIST
12364: PUSH
12365: LD_INT 154
12367: PUSH
12368: LD_INT 86
12370: PUSH
12371: EMPTY
12372: LIST
12373: LIST
12374: PUSH
12375: LD_INT 161
12377: PUSH
12378: LD_INT 87
12380: PUSH
12381: EMPTY
12382: LIST
12383: LIST
12384: PUSH
12385: EMPTY
12386: LIST
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: ADD
12402: ST_TO_ADDR
// for M in Miny do
12403: LD_ADDR_VAR 0 2
12407: PUSH
12408: LD_LOC 44
12412: PUSH
12413: FOR_IN
12414: IFFALSE 12448
// PlaceMine ( M [ 1 ] , M [ 2 ] , side_Ar , 0 ) ;
12416: LD_VAR 0 2
12420: PUSH
12421: LD_INT 1
12423: ARRAY
12424: PPUSH
12425: LD_VAR 0 2
12429: PUSH
12430: LD_INT 2
12432: ARRAY
12433: PPUSH
12434: LD_EXP 3
12438: PPUSH
12439: LD_INT 0
12441: PPUSH
12442: CALL_OW 454
12446: GO 12413
12448: POP
12449: POP
// end ; end ;
12450: LD_VAR 0 1
12454: RET
// function vytvor_postavy ; var Bunkry , B ; begin
12455: LD_INT 0
12457: PPUSH
12458: PPUSH
12459: PPUSH
// ArSci1 = vytvor_postavu_B ( ArLabWS , CLASS_SCIENTISTIC ) ;
12460: LD_ADDR_LOC 28
12464: PUSH
12465: LD_INT 11
12467: PPUSH
12468: LD_INT 4
12470: PPUSH
12471: CALL 12963 0 2
12475: ST_TO_ADDR
// ArSci2 = vytvor_postavu_B ( ArLabWS , CLASS_SCIENTISTIC ) ;
12476: LD_ADDR_LOC 29
12480: PUSH
12481: LD_INT 11
12483: PPUSH
12484: LD_INT 4
12486: PPUSH
12487: CALL 12963 0 2
12491: ST_TO_ADDR
// ArSci3 = vytvor_postavu_B ( ArLabBO , CLASS_SCIENTISTIC ) ;
12492: LD_ADDR_LOC 30
12496: PUSH
12497: LD_INT 12
12499: PPUSH
12500: LD_INT 4
12502: PPUSH
12503: CALL 12963 0 2
12507: ST_TO_ADDR
// ArSci4 = vytvor_postavu_B ( ArLabBO , CLASS_SCIENTISTIC ) ;
12508: LD_ADDR_LOC 31
12512: PUSH
12513: LD_INT 12
12515: PPUSH
12516: LD_INT 4
12518: PPUSH
12519: CALL 12963 0 2
12523: ST_TO_ADDR
// ArMech1 = vytvor_postavu_B ( ArFact , CLASS_MECHANIC ) ;
12524: LD_ADDR_LOC 32
12528: PUSH
12529: LD_INT 5
12531: PPUSH
12532: LD_INT 3
12534: PPUSH
12535: CALL 12963 0 2
12539: ST_TO_ADDR
// ArMech2 = vytvor_postavu_B ( ArFact , CLASS_MECHANIC ) ;
12540: LD_ADDR_LOC 33
12544: PUSH
12545: LD_INT 5
12547: PPUSH
12548: LD_INT 3
12550: PPUSH
12551: CALL 12963 0 2
12555: ST_TO_ADDR
// vytvor_postavu_B ( ArDepot , CLASS_ENGINEER ) ;
12556: LD_INT 1
12558: PPUSH
12559: LD_INT 2
12561: PPUSH
12562: CALL 12963 0 2
// ArEng1 = vytvor_postavu_A ( Arabove , CLASS_ENGINEER ) ;
12566: LD_ADDR_LOC 34
12570: PUSH
12571: LD_INT 5
12573: PPUSH
12574: LD_INT 2
12576: PPUSH
12577: CALL 13000 0 2
12581: ST_TO_ADDR
// ArEng2 = vytvor_postavu_A ( Arabove , CLASS_ENGINEER ) ;
12582: LD_ADDR_LOC 35
12586: PUSH
12587: LD_INT 5
12589: PPUSH
12590: LD_INT 2
12592: PPUSH
12593: CALL 13000 0 2
12597: ST_TO_ADDR
// Obranci = vytvor_postavy_A ( 2 + 2 * Difficulty , Arabove , CLASS_SOLDIER ) ;
12598: LD_ADDR_LOC 37
12602: PUSH
12603: LD_INT 2
12605: PUSH
12606: LD_INT 2
12608: PUSH
12609: LD_OWVAR 67
12613: MUL
12614: PLUS
12615: PPUSH
12616: LD_INT 5
12618: PPUSH
12619: LD_INT 1
12621: PPUSH
12622: CALL 13040 0 3
12626: ST_TO_ADDR
// VolnyLidi = vytvor_postavy_A ( 2 + dif_AraboveRidici [ Difficulty ] , Arabove , CLASS_SOLDIER ) ;
12627: LD_ADDR_LOC 39
12631: PUSH
12632: LD_INT 2
12634: PUSH
12635: LD_EXP 46
12639: PUSH
12640: LD_OWVAR 67
12644: ARRAY
12645: PLUS
12646: PPUSH
12647: LD_INT 5
12649: PPUSH
12650: LD_INT 1
12652: PPUSH
12653: CALL 13040 0 3
12657: ST_TO_ADDR
// ArMechDalkar = vytvor_postavu_A ( Arabove , CLASS_MECHANIC ) ;
12658: LD_ADDR_LOC 36
12662: PUSH
12663: LD_INT 5
12665: PPUSH
12666: LD_INT 3
12668: PPUSH
12669: CALL 13000 0 2
12673: ST_TO_ADDR
// Bunkry = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_BUNKER ] ] ) ;
12674: LD_ADDR_VAR 0 2
12678: PUSH
12679: LD_INT 22
12681: PUSH
12682: LD_EXP 3
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PUSH
12691: LD_INT 21
12693: PUSH
12694: LD_INT 3
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: PUSH
12701: LD_INT 30
12703: PUSH
12704: LD_INT 32
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: LIST
12715: PPUSH
12716: CALL_OW 69
12720: ST_TO_ADDR
// for B in Bunkry do
12721: LD_ADDR_VAR 0 3
12725: PUSH
12726: LD_VAR 0 2
12730: PUSH
12731: FOR_IN
12732: IFFALSE 12763
// Obranci = Obranci union [ vytvor_postavu_B ( B , CLASS_SOLDIER ) ] ;
12734: LD_ADDR_LOC 37
12738: PUSH
12739: LD_LOC 37
12743: PUSH
12744: LD_VAR 0 3
12748: PPUSH
12749: LD_INT 1
12751: PPUSH
12752: CALL 12963 0 2
12756: PUSH
12757: EMPTY
12758: LIST
12759: UNION
12760: ST_TO_ADDR
12761: GO 12731
12763: POP
12764: POP
// if Abdul then
12765: LD_EXP 31
12769: IFFALSE 12786
// PlaceUnitArea ( Abdul , Arabove , false ) ;
12771: LD_EXP 31
12775: PPUSH
12776: LD_INT 5
12778: PPUSH
12779: LD_INT 0
12781: PPUSH
12782: CALL_OW 49
// if Omar then
12786: LD_EXP 32
12790: IFFALSE 12807
// PlaceUnitArea ( Omar , Arabove , false ) ;
12792: LD_EXP 32
12796: PPUSH
12797: LD_INT 5
12799: PPUSH
12800: LD_INT 0
12802: PPUSH
12803: CALL_OW 49
// Sejkove = vytvor_postavy_A ( 1 + Difficulty , Arabove , CLASS_DESERT_WARIOR ) ;
12807: LD_ADDR_LOC 38
12811: PUSH
12812: LD_INT 1
12814: PUSH
12815: LD_OWVAR 67
12819: PLUS
12820: PPUSH
12821: LD_INT 5
12823: PPUSH
12824: LD_INT 11
12826: PPUSH
12827: CALL 13040 0 3
12831: ST_TO_ADDR
// if Abdul then
12832: LD_EXP 31
12836: IFFALSE 12857
// Sejkove = Sejkove union [ Abdul ] ;
12838: LD_ADDR_LOC 38
12842: PUSH
12843: LD_LOC 38
12847: PUSH
12848: LD_EXP 31
12852: PUSH
12853: EMPTY
12854: LIST
12855: UNION
12856: ST_TO_ADDR
// if Omar then
12857: LD_EXP 32
12861: IFFALSE 12882
// Sejkove = Sejkove union [ Omar ] ;
12863: LD_ADDR_LOC 38
12867: PUSH
12868: LD_LOC 38
12872: PUSH
12873: LD_EXP 32
12877: PUSH
12878: EMPTY
12879: LIST
12880: UNION
12881: ST_TO_ADDR
// end ;
12882: LD_VAR 0 1
12886: RET
// function vytvor_postavu ( Cls ) ; var X , Y ; begin
12887: LD_INT 0
12889: PPUSH
12890: PPUSH
12891: PPUSH
// UC_Side = side_Ar ;
12892: LD_ADDR_OWVAR 20
12896: PUSH
12897: LD_EXP 3
12901: ST_TO_ADDR
// UC_Nation = NATION_ARABIAN ;
12902: LD_ADDR_OWVAR 21
12906: PUSH
12907: LD_INT 2
12909: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
12910: LD_ADDR_OWVAR 27
12914: PUSH
12915: LD_INT 1
12917: PPUSH
12918: LD_INT 2
12920: PPUSH
12921: CALL_OW 12
12925: ST_TO_ADDR
// HC_Class = Cls ;
12926: LD_ADDR_OWVAR 28
12930: PUSH
12931: LD_VAR 0 1
12935: ST_TO_ADDR
// PrepareClassSkills ( Cls , 7 ) ;
12936: LD_VAR 0 1
12940: PPUSH
12941: LD_INT 7
12943: PPUSH
12944: CALL_OW 374
// Result = CreateHuman ;
12948: LD_ADDR_VAR 0 2
12952: PUSH
12953: CALL_OW 44
12957: ST_TO_ADDR
// end ;
12958: LD_VAR 0 2
12962: RET
// function vytvor_postavu_B ( Budova , Cls ) ; begin
12963: LD_INT 0
12965: PPUSH
// Result = vytvor_postavu ( Cls ) ;
12966: LD_ADDR_VAR 0 3
12970: PUSH
12971: LD_VAR 0 2
12975: PPUSH
12976: CALL 12887 0 1
12980: ST_TO_ADDR
// PlaceHumanInUnit ( Result , Budova ) ;
12981: LD_VAR 0 3
12985: PPUSH
12986: LD_VAR 0 1
12990: PPUSH
12991: CALL_OW 52
// end ;
12995: LD_VAR 0 3
12999: RET
// function vytvor_postavu_A ( Area , Cls ) ; begin
13000: LD_INT 0
13002: PPUSH
// Result = vytvor_postavu ( Cls ) ;
13003: LD_ADDR_VAR 0 3
13007: PUSH
13008: LD_VAR 0 2
13012: PPUSH
13013: CALL 12887 0 1
13017: ST_TO_ADDR
// PlaceUnitArea ( Result , Area , false ) ;
13018: LD_VAR 0 3
13022: PPUSH
13023: LD_VAR 0 1
13027: PPUSH
13028: LD_INT 0
13030: PPUSH
13031: CALL_OW 49
// end ;
13035: LD_VAR 0 3
13039: RET
// function vytvor_postavy_A ( Pocet , Area , Cls ) ; var I ; begin
13040: LD_INT 0
13042: PPUSH
13043: PPUSH
// Result = [ ] ;
13044: LD_ADDR_VAR 0 4
13048: PUSH
13049: EMPTY
13050: ST_TO_ADDR
// for I = 1 to Pocet do
13051: LD_ADDR_VAR 0 5
13055: PUSH
13056: DOUBLE
13057: LD_INT 1
13059: DEC
13060: ST_TO_ADDR
13061: LD_VAR 0 1
13065: PUSH
13066: FOR_TO
13067: IFFALSE 13100
// Result = Result union [ vytvor_postavu_A ( Area , Cls ) ] ;
13069: LD_ADDR_VAR 0 4
13073: PUSH
13074: LD_VAR 0 4
13078: PUSH
13079: LD_VAR 0 2
13083: PPUSH
13084: LD_VAR 0 3
13088: PPUSH
13089: CALL 13000 0 2
13093: PUSH
13094: EMPTY
13095: LIST
13096: UNION
13097: ST_TO_ADDR
13098: GO 13066
13100: POP
13101: POP
// end ;
13102: LD_VAR 0 4
13106: RET
// function zpet_do_labu ( Kdo ) ; begin
13107: LD_INT 0
13109: PPUSH
// if Kdo = ArSci1 then
13110: LD_VAR 0 1
13114: PUSH
13115: LD_LOC 28
13119: EQUAL
13120: IFFALSE 13136
// AddComEnterUnit ( Kdo , ArLabWS ) else
13122: LD_VAR 0 1
13126: PPUSH
13127: LD_INT 11
13129: PPUSH
13130: CALL_OW 180
13134: GO 13212
// if Kdo = ArSci2 then
13136: LD_VAR 0 1
13140: PUSH
13141: LD_LOC 29
13145: EQUAL
13146: IFFALSE 13162
// AddComEnterUnit ( Kdo , ArLabWS ) else
13148: LD_VAR 0 1
13152: PPUSH
13153: LD_INT 11
13155: PPUSH
13156: CALL_OW 180
13160: GO 13212
// if Kdo = ArSci3 then
13162: LD_VAR 0 1
13166: PUSH
13167: LD_LOC 30
13171: EQUAL
13172: IFFALSE 13188
// AddComEnterUnit ( Kdo , ArLabBO ) else
13174: LD_VAR 0 1
13178: PPUSH
13179: LD_INT 12
13181: PPUSH
13182: CALL_OW 180
13186: GO 13212
// if Kdo = ArSci4 then
13188: LD_VAR 0 1
13192: PUSH
13193: LD_LOC 31
13197: EQUAL
13198: IFFALSE 13212
// AddComEnterUnit ( Kdo , ArLabBO ) ;
13200: LD_VAR 0 1
13204: PPUSH
13205: LD_INT 12
13207: PPUSH
13208: CALL_OW 180
// end ;
13212: LD_VAR 0 2
13216: RET
// function zacni_vynalezat ; begin
13217: LD_INT 0
13219: PPUSH
// AddComResearch ( ArLabWS , TECH_ROCKET ) ;
13220: LD_INT 11
13222: PPUSH
13223: LD_INT 40
13225: PPUSH
13226: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_FLAME ) ;
13230: LD_INT 11
13232: PPUSH
13233: LD_INT 70
13235: PPUSH
13236: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_MORTAR ) ;
13240: LD_INT 11
13242: PPUSH
13243: LD_INT 41
13245: PPUSH
13246: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_EXPLOS ) ;
13250: LD_INT 11
13252: PPUSH
13253: LD_INT 42
13255: PPUSH
13256: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SELFDEST ) ;
13260: LD_INT 11
13262: PPUSH
13263: LD_INT 43
13265: PPUSH
13266: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_WEAP1 ) ;
13270: LD_INT 11
13272: PPUSH
13273: LD_INT 51
13275: PPUSH
13276: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SIB1 ) ;
13280: LD_INT 11
13282: PPUSH
13283: LD_INT 54
13285: PPUSH
13286: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_WEAP2 ) ;
13290: LD_INT 11
13292: PPUSH
13293: LD_INT 52
13295: PPUSH
13296: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SIB2 ) ;
13300: LD_INT 11
13302: PPUSH
13303: LD_INT 55
13305: PPUSH
13306: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_WEAP3 ) ;
13310: LD_INT 11
13312: PPUSH
13313: LD_INT 53
13315: PPUSH
13316: CALL_OW 184
// AddComResearch ( ArLabWS , TECH_SIB3 ) ;
13320: LD_INT 11
13322: PPUSH
13323: LD_INT 56
13325: PPUSH
13326: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_RADAR ) ;
13330: LD_INT 12
13332: PPUSH
13333: LD_INT 6
13335: PPUSH
13336: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_REMCONT ) ;
13340: LD_INT 12
13342: PPUSH
13343: LD_INT 15
13345: PPUSH
13346: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_STIMDRUGS ) ;
13350: LD_INT 12
13352: PPUSH
13353: LD_INT 5
13355: PPUSH
13356: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIODET ) ;
13360: LD_INT 12
13362: PPUSH
13363: LD_INT 8
13365: PPUSH
13366: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_MATDET ) ;
13370: LD_INT 12
13372: PPUSH
13373: LD_INT 7
13375: PPUSH
13376: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_HIDCAM ) ;
13380: LD_INT 12
13382: PPUSH
13383: LD_INT 17
13385: PPUSH
13386: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_TECH1 ) ;
13390: LD_INT 12
13392: PPUSH
13393: LD_INT 48
13395: PPUSH
13396: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIO1 ) ;
13400: LD_INT 12
13402: PPUSH
13403: LD_INT 66
13405: PPUSH
13406: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_OPTO1 ) ;
13410: LD_INT 12
13412: PPUSH
13413: LD_INT 60
13415: PPUSH
13416: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_TECH2 ) ;
13420: LD_INT 12
13422: PPUSH
13423: LD_INT 49
13425: PPUSH
13426: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIO2 ) ;
13430: LD_INT 12
13432: PPUSH
13433: LD_INT 67
13435: PPUSH
13436: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_OPTO2 ) ;
13440: LD_INT 12
13442: PPUSH
13443: LD_INT 61
13445: PPUSH
13446: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_TECH3 ) ;
13450: LD_INT 12
13452: PPUSH
13453: LD_INT 50
13455: PPUSH
13456: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_BIO3 ) ;
13460: LD_INT 12
13462: PPUSH
13463: LD_INT 68
13465: PPUSH
13466: CALL_OW 184
// AddComResearch ( ArLabBO , TECH_OPTO3 ) ;
13470: LD_INT 12
13472: PPUSH
13473: LD_INT 62
13475: PPUSH
13476: CALL_OW 184
// end ;
13480: LD_VAR 0 1
13484: RET
// every 0 0$2.3 do
13485: GO 13487
13487: DISABLE
// begin zacni_vynalezat ;
13488: CALL 13217 0 0
// end ;
13492: END
// function otravuj ; var Vedci , Doly , I , Dul , X , Y ; begin
13493: LD_INT 0
13495: PPUSH
13496: PPUSH
13497: PPUSH
13498: PPUSH
13499: PPUSH
13500: PPUSH
13501: PPUSH
// Result = false ;
13502: LD_ADDR_VAR 0 1
13506: PUSH
13507: LD_INT 0
13509: ST_TO_ADDR
// if ( RusMaOtraveno >= 2 ) then
13510: LD_EXP 64
13514: PUSH
13515: LD_INT 2
13517: GREATEREQUAL
13518: IFFALSE 13522
// exit ;
13520: GO 14024
// if KdoOtravuje then
13522: LD_LOC 42
13526: IFFALSE 13530
// exit ;
13528: GO 14024
// Vedci = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] ] ) ;
13530: LD_ADDR_VAR 0 2
13534: PUSH
13535: LD_INT 22
13537: PUSH
13538: LD_EXP 3
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: PUSH
13547: LD_INT 21
13549: PUSH
13550: LD_INT 1
13552: PUSH
13553: EMPTY
13554: LIST
13555: LIST
13556: PUSH
13557: LD_INT 25
13559: PUSH
13560: LD_INT 4
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: EMPTY
13568: LIST
13569: LIST
13570: LIST
13571: PPUSH
13572: CALL_OW 69
13576: ST_TO_ADDR
// if not Vedci then
13577: LD_VAR 0 2
13581: NOT
13582: IFFALSE 13586
// exit ;
13584: GO 14024
// Doly = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , B_SIBERITE_MINE ] ] ) ;
13586: LD_ADDR_VAR 0 3
13590: PUSH
13591: LD_INT 22
13593: PUSH
13594: LD_EXP 2
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: PUSH
13603: LD_INT 21
13605: PUSH
13606: LD_INT 3
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PUSH
13613: LD_INT 30
13615: PUSH
13616: LD_INT 30
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: LIST
13627: PPUSH
13628: CALL_OW 69
13632: ST_TO_ADDR
// if ( not Doly ) and ( Tick < 30 30$0 ) then
13633: LD_VAR 0 3
13637: NOT
13638: PUSH
13639: LD_OWVAR 1
13643: PUSH
13644: LD_INT 63000
13646: LESS
13647: AND
13648: IFFALSE 13652
// exit ;
13650: GO 14024
// if Doly then
13652: LD_VAR 0 3
13656: IFFALSE 13767
// begin X = - 1 ;
13658: LD_ADDR_VAR 0 6
13662: PUSH
13663: LD_INT 1
13665: NEG
13666: ST_TO_ADDR
// Y = - 1 ;
13667: LD_ADDR_VAR 0 7
13671: PUSH
13672: LD_INT 1
13674: NEG
13675: ST_TO_ADDR
// Dul = 0 ;
13676: LD_ADDR_VAR 0 5
13680: PUSH
13681: LD_INT 0
13683: ST_TO_ADDR
// for I in Doly do
13684: LD_ADDR_VAR 0 4
13688: PUSH
13689: LD_VAR 0 3
13693: PUSH
13694: FOR_IN
13695: IFFALSE 13763
// begin if not Dul or GetX ( Dul ) > X then
13697: LD_VAR 0 5
13701: NOT
13702: PUSH
13703: LD_VAR 0 5
13707: PPUSH
13708: CALL_OW 250
13712: PUSH
13713: LD_VAR 0 6
13717: GREATER
13718: OR
13719: IFFALSE 13761
// begin Dul = I ;
13721: LD_ADDR_VAR 0 5
13725: PUSH
13726: LD_VAR 0 4
13730: ST_TO_ADDR
// X = GetX ( Dul ) ;
13731: LD_ADDR_VAR 0 6
13735: PUSH
13736: LD_VAR 0 5
13740: PPUSH
13741: CALL_OW 250
13745: ST_TO_ADDR
// Y = GetY ( Dul ) ;
13746: LD_ADDR_VAR 0 7
13750: PUSH
13751: LD_VAR 0 5
13755: PPUSH
13756: CALL_OW 251
13760: ST_TO_ADDR
// end end end else
13761: GO 13694
13763: POP
13764: POP
13765: GO 13922
// begin Doly = GetResourceArea ( RusoveUtok , MAT_SIBERIT ) ;
13767: LD_ADDR_VAR 0 3
13771: PUSH
13772: LD_INT 11
13774: PPUSH
13775: LD_INT 3
13777: PPUSH
13778: CALL_OW 287
13782: ST_TO_ADDR
// Doly = [ [ 74 , 6 ] , [ 23 , 9 ] , [ 144 , 97 ] ] ;
13783: LD_ADDR_VAR 0 3
13787: PUSH
13788: LD_INT 74
13790: PUSH
13791: LD_INT 6
13793: PUSH
13794: EMPTY
13795: LIST
13796: LIST
13797: PUSH
13798: LD_INT 23
13800: PUSH
13801: LD_INT 9
13803: PUSH
13804: EMPTY
13805: LIST
13806: LIST
13807: PUSH
13808: LD_INT 144
13810: PUSH
13811: LD_INT 97
13813: PUSH
13814: EMPTY
13815: LIST
13816: LIST
13817: PUSH
13818: EMPTY
13819: LIST
13820: LIST
13821: LIST
13822: ST_TO_ADDR
// if not Doly then
13823: LD_VAR 0 3
13827: NOT
13828: IFFALSE 13832
// exit ;
13830: GO 14024
// X = - 1 ;
13832: LD_ADDR_VAR 0 6
13836: PUSH
13837: LD_INT 1
13839: NEG
13840: ST_TO_ADDR
// Y = - 1 ;
13841: LD_ADDR_VAR 0 7
13845: PUSH
13846: LD_INT 1
13848: NEG
13849: ST_TO_ADDR
// for I in Doly do
13850: LD_ADDR_VAR 0 4
13854: PUSH
13855: LD_VAR 0 3
13859: PUSH
13860: FOR_IN
13861: IFFALSE 13920
// begin if ( X = - 1 ) or ( I [ 1 ] > X ) then
13863: LD_VAR 0 6
13867: PUSH
13868: LD_INT 1
13870: NEG
13871: EQUAL
13872: PUSH
13873: LD_VAR 0 4
13877: PUSH
13878: LD_INT 1
13880: ARRAY
13881: PUSH
13882: LD_VAR 0 6
13886: GREATER
13887: OR
13888: IFFALSE 13918
// begin X = I [ 1 ] ;
13890: LD_ADDR_VAR 0 6
13894: PUSH
13895: LD_VAR 0 4
13899: PUSH
13900: LD_INT 1
13902: ARRAY
13903: ST_TO_ADDR
// Y = I [ 2 ] ;
13904: LD_ADDR_VAR 0 7
13908: PUSH
13909: LD_VAR 0 4
13913: PUSH
13914: LD_INT 2
13916: ARRAY
13917: ST_TO_ADDR
// end ; end ;
13918: GO 13860
13920: POP
13921: POP
// end ; KdoOtravuje = [ nahoda_seznam ( Vedci ) ] ;
13922: LD_ADDR_LOC 42
13926: PUSH
13927: LD_VAR 0 2
13931: PPUSH
13932: CALL 21499 0 1
13936: PUSH
13937: EMPTY
13938: LIST
13939: ST_TO_ADDR
// ComExitBuilding ( KdoOtravuje ) ;
13940: LD_LOC 42
13944: PPUSH
13945: CALL_OW 122
// Wait ( 0 0$1 ) ;
13949: LD_INT 35
13951: PPUSH
13952: CALL_OW 67
// if ( Y <= 20 ) then
13956: LD_VAR 0 7
13960: PUSH
13961: LD_INT 20
13963: LESSEQUAL
13964: IFFALSE 13981
// AddComMoveXY ( KdoOtravuje , 95 , 5 ) ;
13966: LD_LOC 42
13970: PPUSH
13971: LD_INT 95
13973: PPUSH
13974: LD_INT 5
13976: PPUSH
13977: CALL_OW 171
// AddComContaminate ( KdoOtravuje , X , Y ) ;
13981: LD_LOC 42
13985: PPUSH
13986: LD_VAR 0 6
13990: PPUSH
13991: LD_VAR 0 7
13995: PPUSH
13996: CALL_OW 218
// AddComMoveToArea ( KdoOtravuje , Arabove ) ;
14000: LD_LOC 42
14004: PPUSH
14005: LD_INT 5
14007: PPUSH
14008: CALL_OW 173
// AddComSailEvent ( KdoOtravuje , 101 ) ;
14012: LD_LOC 42
14016: PPUSH
14017: LD_INT 101
14019: PPUSH
14020: CALL_OW 224
// end ;
14024: LD_VAR 0 1
14028: RET
// export function event_Kontaminovano ; var Kdo ; begin
14029: LD_INT 0
14031: PPUSH
14032: PPUSH
// for Kdo in KdoOtravuje do
14033: LD_ADDR_VAR 0 2
14037: PUSH
14038: LD_LOC 42
14042: PUSH
14043: FOR_IN
14044: IFFALSE 14057
// zpet_do_labu ( Kdo ) ;
14046: LD_VAR 0 2
14050: PPUSH
14051: CALL 13107 0 1
14055: GO 14043
14057: POP
14058: POP
// KdoOtravuje = [ ] ;
14059: LD_ADDR_LOC 42
14063: PUSH
14064: EMPTY
14065: ST_TO_ADDR
// end ;
14066: LD_VAR 0 1
14070: RET
// export function arabi_UnitDestroyed ( Un ) ; begin
14071: LD_INT 0
14073: PPUSH
// if Un in KdoOtravuje then
14074: LD_VAR 0 1
14078: PUSH
14079: LD_LOC 42
14083: IN
14084: IFFALSE 14119
// begin KdoOtravuje = KdoOtravuje diff [ Un ] ;
14086: LD_ADDR_LOC 42
14090: PUSH
14091: LD_LOC 42
14095: PUSH
14096: LD_VAR 0 1
14100: PUSH
14101: EMPTY
14102: LIST
14103: DIFF
14104: ST_TO_ADDR
// if not KdoOtravuje then
14105: LD_LOC 42
14109: NOT
14110: IFFALSE 14119
// RaiseSailEvent ( 101 ) ;
14112: LD_INT 101
14114: PPUSH
14115: CALL_OW 427
// end ; if Un in Obranci then
14119: LD_VAR 0 1
14123: PUSH
14124: LD_LOC 37
14128: IN
14129: IFFALSE 14150
// Obranci = Obranci diff [ Un ] ;
14131: LD_ADDR_LOC 37
14135: PUSH
14136: LD_LOC 37
14140: PUSH
14141: LD_VAR 0 1
14145: PUSH
14146: EMPTY
14147: LIST
14148: DIFF
14149: ST_TO_ADDR
// if Un in VolnyLidi then
14150: LD_VAR 0 1
14154: PUSH
14155: LD_LOC 39
14159: IN
14160: IFFALSE 14181
// VolnyLidi = VolnyLidi diff [ Un ] ;
14162: LD_ADDR_LOC 39
14166: PUSH
14167: LD_LOC 39
14171: PUSH
14172: LD_VAR 0 1
14176: PUSH
14177: EMPTY
14178: LIST
14179: DIFF
14180: ST_TO_ADDR
// if Un in Auta then
14181: LD_VAR 0 1
14185: PUSH
14186: LD_LOC 40
14190: IN
14191: IFFALSE 14212
// Auta = Auta diff [ Un ] ;
14193: LD_ADDR_LOC 40
14197: PUSH
14198: LD_LOC 40
14202: PUSH
14203: LD_VAR 0 1
14207: PUSH
14208: EMPTY
14209: LIST
14210: DIFF
14211: ST_TO_ADDR
// if Un in Utok_Auta then
14212: LD_VAR 0 1
14216: PUSH
14217: LD_LOC 41
14221: IN
14222: IFFALSE 14243
// Utok_Auta = Utok_Auta diff [ Un ] ;
14224: LD_ADDR_LOC 41
14228: PUSH
14229: LD_LOC 41
14233: PUSH
14234: LD_VAR 0 1
14238: PUSH
14239: EMPTY
14240: LIST
14241: DIFF
14242: ST_TO_ADDR
// if Un in Sejkove then
14243: LD_VAR 0 1
14247: PUSH
14248: LD_LOC 38
14252: IN
14253: IFFALSE 14274
// Sejkove = Sejkove diff [ Un ] ;
14255: LD_ADDR_LOC 38
14259: PUSH
14260: LD_LOC 38
14264: PUSH
14265: LD_VAR 0 1
14269: PUSH
14270: EMPTY
14271: LIST
14272: DIFF
14273: ST_TO_ADDR
// if Un in ObranaBehemota then
14274: LD_VAR 0 1
14278: PUSH
14279: LD_LOC 45
14283: IN
14284: IFFALSE 14305
// ObranaBehemota = ObranaBehemota diff [ Un ] ;
14286: LD_ADDR_LOC 45
14290: PUSH
14291: LD_LOC 45
14295: PUSH
14296: LD_VAR 0 1
14300: PUSH
14301: EMPTY
14302: LIST
14303: DIFF
14304: ST_TO_ADDR
// if Un in KdoLakaOpice then
14305: LD_VAR 0 1
14309: PUSH
14310: LD_LOC 68
14314: IN
14315: IFFALSE 14336
// KdoLakaOpice = KdoLakaOpice diff [ Un ] ;
14317: LD_ADDR_LOC 68
14321: PUSH
14322: LD_LOC 68
14326: PUSH
14327: LD_VAR 0 1
14331: PUSH
14332: EMPTY
14333: LIST
14334: DIFF
14335: ST_TO_ADDR
// if Un in KdoLeci then
14336: LD_VAR 0 1
14340: PUSH
14341: LD_LOC 66
14345: IN
14346: IFFALSE 14367
// KdoLeci = KdoLeci diff [ Un ] ;
14348: LD_ADDR_LOC 66
14352: PUSH
14353: LD_LOC 66
14357: PUSH
14358: LD_VAR 0 1
14362: PUSH
14363: EMPTY
14364: LIST
14365: DIFF
14366: ST_TO_ADDR
// if Un in KdoOpravuje then
14367: LD_VAR 0 1
14371: PUSH
14372: LD_LOC 67
14376: IN
14377: IFFALSE 14398
// KdoOpravuje = KdoOpravuje diff [ Un ] ;
14379: LD_ADDR_LOC 67
14383: PUSH
14384: LD_LOC 67
14388: PUSH
14389: LD_VAR 0 1
14393: PUSH
14394: EMPTY
14395: LIST
14396: DIFF
14397: ST_TO_ADDR
// end ;
14398: LD_VAR 0 2
14402: RET
// export function arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
14403: LD_INT 0
14405: PPUSH
// if VehOld in Auta then
14406: LD_VAR 0 2
14410: PUSH
14411: LD_LOC 40
14415: IN
14416: IFFALSE 14437
// Auta = Auta diff [ VehOld ] ;
14418: LD_ADDR_LOC 40
14422: PUSH
14423: LD_LOC 40
14427: PUSH
14428: LD_VAR 0 2
14432: PUSH
14433: EMPTY
14434: LIST
14435: DIFF
14436: ST_TO_ADDR
// if GetSide ( VehNew ) = side_Ar then
14437: LD_VAR 0 1
14441: PPUSH
14442: CALL_OW 255
14446: PUSH
14447: LD_EXP 3
14451: EQUAL
14452: IFFALSE 14473
// Auta = Auta union [ VehNew ] ;
14454: LD_ADDR_LOC 40
14458: PUSH
14459: LD_LOC 40
14463: PUSH
14464: LD_VAR 0 1
14468: PUSH
14469: EMPTY
14470: LIST
14471: UNION
14472: ST_TO_ADDR
// if VehOld in Utok_Auta then
14473: LD_VAR 0 2
14477: PUSH
14478: LD_LOC 41
14482: IN
14483: IFFALSE 14504
// Utok_Auta = Utok_Auta diff [ VehOld ] ;
14485: LD_ADDR_LOC 41
14489: PUSH
14490: LD_LOC 41
14494: PUSH
14495: LD_VAR 0 2
14499: PUSH
14500: EMPTY
14501: LIST
14502: DIFF
14503: ST_TO_ADDR
// end ;
14504: LD_VAR 0 5
14508: RET
// function vyrob_autak ; var Chassis , Weapon , P ; begin
14509: LD_INT 0
14511: PPUSH
14512: PPUSH
14513: PPUSH
14514: PPUSH
// P = Rand ( 1 , 100 ) ;
14515: LD_ADDR_VAR 0 4
14519: PUSH
14520: LD_INT 1
14522: PPUSH
14523: LD_INT 100
14525: PPUSH
14526: CALL_OW 12
14530: ST_TO_ADDR
// if ( Difficulty = 1 ) and ( P >= 65 ) then
14531: LD_OWVAR 67
14535: PUSH
14536: LD_INT 1
14538: EQUAL
14539: PUSH
14540: LD_VAR 0 4
14544: PUSH
14545: LD_INT 65
14547: GREATEREQUAL
14548: AND
14549: IFFALSE 14559
// P = 64 ;
14551: LD_ADDR_VAR 0 4
14555: PUSH
14556: LD_INT 64
14558: ST_TO_ADDR
// if P < 8 then
14559: LD_VAR 0 4
14563: PUSH
14564: LD_INT 8
14566: LESS
14567: IFFALSE 14587
// begin Weapon = AR_MULTIMISSILE_BALLISTA ;
14569: LD_ADDR_VAR 0 3
14573: PUSH
14574: LD_INT 22
14576: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
14577: LD_ADDR_VAR 0 2
14581: PUSH
14582: LD_INT 11
14584: ST_TO_ADDR
// end else
14585: GO 14687
// if P < 15 then
14587: LD_VAR 0 4
14591: PUSH
14592: LD_INT 15
14594: LESS
14595: IFFALSE 14615
// begin Weapon = AR_DOUBLE_MACHINE_GUN ;
14597: LD_ADDR_VAR 0 3
14601: PUSH
14602: LD_INT 24
14604: ST_TO_ADDR
// Chassis = AR_HOVERCRAFT ;
14605: LD_ADDR_VAR 0 2
14609: PUSH
14610: LD_INT 11
14612: ST_TO_ADDR
// end else
14613: GO 14687
// if P < 35 then
14615: LD_VAR 0 4
14619: PUSH
14620: LD_INT 35
14622: LESS
14623: IFFALSE 14643
// begin Weapon = AR_GATLING_GUN ;
14625: LD_ADDR_VAR 0 3
14629: PUSH
14630: LD_INT 25
14632: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
14633: LD_ADDR_VAR 0 2
14637: PUSH
14638: LD_INT 13
14640: ST_TO_ADDR
// end else
14641: GO 14687
// if P < 65 then
14643: LD_VAR 0 4
14647: PUSH
14648: LD_INT 65
14650: LESS
14651: IFFALSE 14671
// begin Weapon = AR_GUN ;
14653: LD_ADDR_VAR 0 3
14657: PUSH
14658: LD_INT 27
14660: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
14661: LD_ADDR_VAR 0 2
14665: PUSH
14666: LD_INT 13
14668: ST_TO_ADDR
// end else
14669: GO 14687
// begin Weapon = AR_ROCKET_LAUNCHER ;
14671: LD_ADDR_VAR 0 3
14675: PUSH
14676: LD_INT 28
14678: ST_TO_ADDR
// Chassis = AR_MEDIUM_TRIKE ;
14679: LD_ADDR_VAR 0 2
14683: PUSH
14684: LD_INT 13
14686: ST_TO_ADDR
// end ; Chassis = Rand ( Chassis , AR_HALF_TRACKED ) ;
14687: LD_ADDR_VAR 0 2
14691: PUSH
14692: LD_VAR 0 2
14696: PPUSH
14697: LD_INT 14
14699: PPUSH
14700: CALL_OW 12
14704: ST_TO_ADDR
// AddComConstruct ( ArFact , Chassis , ENGINE_SIBERITE , CONTROL_MANUAL , Weapon ) ;
14705: LD_INT 5
14707: PPUSH
14708: LD_VAR 0 2
14712: PPUSH
14713: LD_INT 3
14715: PPUSH
14716: LD_INT 1
14718: PPUSH
14719: LD_VAR 0 3
14723: PPUSH
14724: CALL_OW 185
// end ;
14728: LD_VAR 0 1
14732: RET
// function vyrob_auto_opice ; begin
14733: LD_INT 0
14735: PPUSH
// AddComConstruct ( ArFact , AR_MEDIUM_TRIKE , ENGINE_SIBERITE , CONTROL_APEMAN , AR_SELFPROPELLED_BOMB ) ;
14736: LD_INT 5
14738: PPUSH
14739: LD_INT 13
14741: PPUSH
14742: LD_INT 3
14744: PPUSH
14745: LD_INT 5
14747: PPUSH
14748: LD_INT 29
14750: PPUSH
14751: CALL_OW 185
// end ;
14755: LD_VAR 0 1
14759: RET
// export function arabi_EnterBuilding ( Building , Un ) ; begin
14760: LD_INT 0
14762: PPUSH
// if ( Building = ArFact ) and ( GetSide ( Un ) = side_Ar ) and ( GetClass ( Un ) = CLASS_APEMAN ) then
14763: LD_VAR 0 1
14767: PUSH
14768: LD_INT 5
14770: EQUAL
14771: PUSH
14772: LD_VAR 0 2
14776: PPUSH
14777: CALL_OW 255
14781: PUSH
14782: LD_EXP 3
14786: EQUAL
14787: AND
14788: PUSH
14789: LD_VAR 0 2
14793: PPUSH
14794: CALL_OW 257
14798: PUSH
14799: LD_INT 12
14801: EQUAL
14802: AND
14803: IFFALSE 14823
// begin VolnyRidiciOpicaci = VolnyRidiciOpicaci + 1 ;
14805: LD_ADDR_LOC 48
14809: PUSH
14810: LD_LOC 48
14814: PUSH
14815: LD_INT 1
14817: PLUS
14818: ST_TO_ADDR
// vyrob_auto_opice ;
14819: CALL 14733 0 0
// end ; end ;
14823: LD_VAR 0 3
14827: RET
// export function arabi_VehicleConstructed ( Veh , Fact ) ; var Ridic , Volni , Control , Weapon , NovyRidic ; begin
14828: LD_INT 0
14830: PPUSH
14831: PPUSH
14832: PPUSH
14833: PPUSH
14834: PPUSH
14835: PPUSH
// if GetSide ( Veh ) = side_Ar then
14836: LD_VAR 0 1
14840: PPUSH
14841: CALL_OW 255
14845: PUSH
14846: LD_EXP 3
14850: EQUAL
14851: IFFALSE 15234
// begin Auta = Auta union [ Veh ] ;
14853: LD_ADDR_LOC 40
14857: PUSH
14858: LD_LOC 40
14862: PUSH
14863: LD_VAR 0 1
14867: PUSH
14868: EMPTY
14869: LIST
14870: UNION
14871: ST_TO_ADDR
// Control = GetControl ( Veh ) ;
14872: LD_ADDR_VAR 0 6
14876: PUSH
14877: LD_VAR 0 1
14881: PPUSH
14882: CALL_OW 263
14886: ST_TO_ADDR
// Weapon = GetWeapon ( Veh ) ;
14887: LD_ADDR_VAR 0 7
14891: PUSH
14892: LD_VAR 0 1
14896: PPUSH
14897: CALL_OW 264
14901: ST_TO_ADDR
// if ( Weapon = AR_CONTROL_TOWER ) then
14902: LD_VAR 0 7
14906: PUSH
14907: LD_INT 31
14909: EQUAL
14910: IFFALSE 14940
// begin ArDalkar = Veh ;
14912: LD_ADDR_LOC 49
14916: PUSH
14917: LD_VAR 0 1
14921: ST_TO_ADDR
// NovyRidic = ArMechDalkar ;
14922: LD_ADDR_VAR 0 8
14926: PUSH
14927: LD_LOC 36
14931: ST_TO_ADDR
// DelamDalkare = false ;
14932: LD_ADDR_LOC 51
14936: PUSH
14937: LD_INT 0
14939: ST_TO_ADDR
// end ; if ( Control = CONTROL_MANUAL ) then
14940: LD_VAR 0 6
14944: PUSH
14945: LD_INT 1
14947: EQUAL
14948: IFFALSE 15089
// begin Wait ( 0 0$2.5 ) ;
14950: LD_INT 88
14952: PPUSH
14953: CALL_OW 67
// Ridic = IsDrivenBy ( Veh ) ;
14957: LD_ADDR_VAR 0 4
14961: PUSH
14962: LD_VAR 0 1
14966: PPUSH
14967: CALL_OW 311
14971: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
14972: LD_INT 105
14974: PPUSH
14975: CALL_OW 67
// ComExitVehicle ( Ridic ) ;
14979: LD_VAR 0 4
14983: PPUSH
14984: CALL_OW 121
// Wait ( 0 0$1 ) ;
14988: LD_INT 35
14990: PPUSH
14991: CALL_OW 67
// while IsDrivenBy ( Veh ) = Ridic do
14995: LD_VAR 0 1
14999: PPUSH
15000: CALL_OW 311
15004: PUSH
15005: LD_VAR 0 4
15009: EQUAL
15010: IFFALSE 15021
// Wait ( 0 0$1 ) ;
15012: LD_INT 35
15014: PPUSH
15015: CALL_OW 67
15019: GO 14995
// AddComEnterUnit ( Ridic , Fact ) ;
15021: LD_VAR 0 4
15025: PPUSH
15026: LD_VAR 0 2
15030: PPUSH
15031: CALL_OW 180
// if NovyRidic then
15035: LD_VAR 0 8
15039: IFFALSE 15055
// ComEnterUnit ( NovyRidic , Veh ) ;
15041: LD_VAR 0 8
15045: PPUSH
15046: LD_VAR 0 1
15050: PPUSH
15051: CALL_OW 120
// AddMcUnits ( MakroObrana , [ Veh ] ) ;
15055: LD_LOC 43
15059: PPUSH
15060: LD_VAR 0 1
15064: PUSH
15065: EMPTY
15066: LIST
15067: PPUSH
15068: CALL_OW 390
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
15072: LD_LOC 59
15076: PPUSH
15077: LD_VAR 0 1
15081: PUSH
15082: EMPTY
15083: LIST
15084: PPUSH
15085: CALL_OW 390
// end ; if ( Control = CONTROL_APEMAN ) and ( VolnyRidiciOpicaci > 0 ) then
15089: LD_VAR 0 6
15093: PUSH
15094: LD_INT 5
15096: EQUAL
15097: PUSH
15098: LD_LOC 48
15102: PUSH
15103: LD_INT 0
15105: GREATER
15106: AND
15107: IFFALSE 15123
// begin VolnyRidiciOpicaci = VolnyRidiciOpicaci - 1 ;
15109: LD_ADDR_LOC 48
15113: PUSH
15114: LD_LOC 48
15118: PUSH
15119: LD_INT 1
15121: MINUS
15122: ST_TO_ADDR
// end ; if ( Control = CONTROL_APEMAN ) and ( Weapon = AR_SELFPROPELLED_BOMB ) then
15123: LD_VAR 0 6
15127: PUSH
15128: LD_INT 5
15130: EQUAL
15131: PUSH
15132: LD_VAR 0 7
15136: PUSH
15137: LD_INT 29
15139: EQUAL
15140: AND
15141: IFFALSE 15167
// begin Wait ( 0 0$3.6 ) ;
15143: LD_INT 126
15145: PPUSH
15146: CALL_OW 67
// AddMcUnits ( MakroKamikaze , [ Veh ] ) ;
15150: LD_LOC 46
15154: PPUSH
15155: LD_VAR 0 1
15159: PUSH
15160: EMPTY
15161: LIST
15162: PPUSH
15163: CALL_OW 390
// end ; if ( GetControl ( Veh ) = CONTROL_REMOTE ) then
15167: LD_VAR 0 1
15171: PPUSH
15172: CALL_OW 263
15176: PUSH
15177: LD_INT 2
15179: EQUAL
15180: IFFALSE 15234
// begin LinkVehicleToHuman ( Veh , ArMechDalkar ) ;
15182: LD_VAR 0 1
15186: PPUSH
15187: LD_LOC 36
15191: PPUSH
15192: CALL_OW 53
// KolikDalkovych = KolikDalkovych + 1 ;
15196: LD_ADDR_LOC 50
15200: PUSH
15201: LD_LOC 50
15205: PUSH
15206: LD_INT 1
15208: PLUS
15209: ST_TO_ADDR
// Wait ( 0 0$3 ) ;
15210: LD_INT 105
15212: PPUSH
15213: CALL_OW 67
// AddMcUnits ( MakroPresunZakladna , [ Veh ] ) ;
15217: LD_LOC 59
15221: PPUSH
15222: LD_VAR 0 1
15226: PUSH
15227: EMPTY
15228: LIST
15229: PPUSH
15230: CALL_OW 390
// end ; end ; end ;
15234: LD_VAR 0 3
15238: RET
// function vyber_zbran ; var P ; begin
15239: LD_INT 0
15241: PPUSH
15242: PPUSH
// P = Rand ( 1 , 100 ) ;
15243: LD_ADDR_VAR 0 2
15247: PUSH
15248: LD_INT 1
15250: PPUSH
15251: LD_INT 100
15253: PPUSH
15254: CALL_OW 12
15258: ST_TO_ADDR
// if P < PstZbrane [ 1 ] then
15259: LD_VAR 0 2
15263: PUSH
15264: LD_LOC 57
15268: PUSH
15269: LD_INT 1
15271: ARRAY
15272: LESS
15273: IFFALSE 15285
// Result = AR_FLAME_THROWER else
15275: LD_ADDR_VAR 0 1
15279: PUSH
15280: LD_INT 26
15282: ST_TO_ADDR
15283: GO 15345
// if P < PstZbrane [ 2 ] then
15285: LD_VAR 0 2
15289: PUSH
15290: LD_LOC 57
15294: PUSH
15295: LD_INT 2
15297: ARRAY
15298: LESS
15299: IFFALSE 15311
// Result = AR_GUN else
15301: LD_ADDR_VAR 0 1
15305: PUSH
15306: LD_INT 27
15308: ST_TO_ADDR
15309: GO 15345
// if P < PstZbrane [ 3 ] then
15311: LD_VAR 0 2
15315: PUSH
15316: LD_LOC 57
15320: PUSH
15321: LD_INT 3
15323: ARRAY
15324: LESS
15325: IFFALSE 15337
// Result = AR_GATLING_GUN else
15327: LD_ADDR_VAR 0 1
15331: PUSH
15332: LD_INT 25
15334: ST_TO_ADDR
15335: GO 15345
// Result = AR_ROCKET_LAUNCHER ;
15337: LD_ADDR_VAR 0 1
15341: PUSH
15342: LD_INT 28
15344: ST_TO_ADDR
// end ;
15345: LD_VAR 0 1
15349: RET
// function vyber_ovladani ; begin
15350: LD_INT 0
15352: PPUSH
// Result = CONTROL_MANUAL ;
15353: LD_ADDR_VAR 0 1
15357: PUSH
15358: LD_INT 1
15360: ST_TO_ADDR
// if not ArDalkar or not IsOk ( ArDalkar ) then
15361: LD_LOC 49
15365: NOT
15366: PUSH
15367: LD_LOC 49
15371: PPUSH
15372: CALL_OW 302
15376: NOT
15377: OR
15378: IFFALSE 15382
// exit ;
15380: GO 15438
// if not ArMechDalkar or not IsOk ( ArMechDalkar ) then
15382: LD_LOC 36
15386: NOT
15387: PUSH
15388: LD_LOC 36
15392: PPUSH
15393: CALL_OW 302
15397: NOT
15398: OR
15399: IFFALSE 15403
// exit ;
15401: GO 15438
// if UnitsLinked ( ArMechDalkar ) >= GetSkill ( ArMechDalkar , SKILL_MECHANICAL ) then
15403: LD_LOC 36
15407: PPUSH
15408: CALL_OW 432
15412: PUSH
15413: LD_LOC 36
15417: PPUSH
15418: LD_INT 3
15420: PPUSH
15421: CALL_OW 259
15425: GREATEREQUAL
15426: IFFALSE 15430
// exit ;
15428: GO 15438
// Result = CONTROL_REMOTE ;
15430: LD_ADDR_VAR 0 1
15434: PUSH
15435: LD_INT 2
15437: ST_TO_ADDR
// end ;
15438: LD_VAR 0 1
15442: RET
// function kontrola_vyroby ; var Base , Chassis , Weapon , Control ; begin
15443: LD_INT 0
15445: PPUSH
15446: PPUSH
15447: PPUSH
15448: PPUSH
15449: PPUSH
// if not IsOK ( ArFact ) or HasTask ( ArFact ) then
15450: LD_INT 5
15452: PPUSH
15453: CALL_OW 302
15457: NOT
15458: PUSH
15459: LD_INT 5
15461: PPUSH
15462: CALL_OW 314
15466: OR
15467: IFFALSE 15471
// exit ;
15469: GO 15783
// if GetSide ( ArFact ) <> side_Ar then
15471: LD_INT 5
15473: PPUSH
15474: CALL_OW 255
15478: PUSH
15479: LD_EXP 3
15483: NONEQUAL
15484: IFFALSE 15488
// exit ;
15486: GO 15783
// if not UnitsInside ( ArFact ) then
15488: LD_INT 5
15490: PPUSH
15491: CALL_OW 313
15495: NOT
15496: IFFALSE 15500
// exit ;
15498: GO 15783
// if ( GetTech ( TECH_REMCONT , side_Ar ) = STATE_RESEARCHED ) and not ArDalkar and not DelamDalkare and Prob ( 75 ) then
15500: LD_INT 15
15502: PPUSH
15503: LD_EXP 3
15507: PPUSH
15508: CALL_OW 321
15512: PUSH
15513: LD_INT 2
15515: EQUAL
15516: PUSH
15517: LD_LOC 49
15521: NOT
15522: AND
15523: PUSH
15524: LD_LOC 51
15528: NOT
15529: AND
15530: PUSH
15531: LD_INT 75
15533: PPUSH
15534: CALL_OW 13
15538: AND
15539: IFFALSE 15567
// begin Chassis = AR_MEDIUM_TRIKE ;
15541: LD_ADDR_VAR 0 3
15545: PUSH
15546: LD_INT 13
15548: ST_TO_ADDR
// Weapon = AR_CONTROL_TOWER ;
15549: LD_ADDR_VAR 0 4
15553: PUSH
15554: LD_INT 31
15556: ST_TO_ADDR
// Control = CONTROL_MANUAL ;
15557: LD_ADDR_VAR 0 5
15561: PUSH
15562: LD_INT 1
15564: ST_TO_ADDR
// end else
15565: GO 15614
// begin if Prob ( 50 ) then
15567: LD_INT 50
15569: PPUSH
15570: CALL_OW 13
15574: IFFALSE 15586
// Chassis = AR_MEDIUM_TRIKE else
15576: LD_ADDR_VAR 0 3
15580: PUSH
15581: LD_INT 13
15583: ST_TO_ADDR
15584: GO 15594
// Chassis = AR_HALF_TRACKED ;
15586: LD_ADDR_VAR 0 3
15590: PUSH
15591: LD_INT 14
15593: ST_TO_ADDR
// Weapon = vyber_zbran ;
15594: LD_ADDR_VAR 0 4
15598: PUSH
15599: CALL 15239 0 0
15603: ST_TO_ADDR
// Control = vyber_ovladani ;
15604: LD_ADDR_VAR 0 5
15608: PUSH
15609: CALL 15350 0 0
15613: ST_TO_ADDR
// end ; if not CanBeConstructed ( ArFact , Chassis , ENGINE_SIBERITE , Control , Weapon ) then
15614: LD_INT 5
15616: PPUSH
15617: LD_VAR 0 3
15621: PPUSH
15622: LD_INT 3
15624: PPUSH
15625: LD_VAR 0 5
15629: PPUSH
15630: LD_VAR 0 4
15634: PPUSH
15635: CALL_OW 448
15639: NOT
15640: IFFALSE 15684
// begin if not CanBeConstructed ( ArFact , AR_LIGHT_TRIKE , ENGINE_SIBERITE , Control , AR_LIGHT_GUN ) then
15642: LD_INT 5
15644: PPUSH
15645: LD_INT 12
15647: PPUSH
15648: LD_INT 3
15650: PPUSH
15651: LD_VAR 0 5
15655: PPUSH
15656: LD_INT 23
15658: PPUSH
15659: CALL_OW 448
15663: NOT
15664: IFFALSE 15668
// exit ;
15666: GO 15783
// Chassis = AR_LIGHT_TRIKE ;
15668: LD_ADDR_VAR 0 3
15672: PUSH
15673: LD_INT 12
15675: ST_TO_ADDR
// Weapon = AR_LIGHT_GUN ;
15676: LD_ADDR_VAR 0 4
15680: PUSH
15681: LD_INT 23
15683: ST_TO_ADDR
// end ; Base = GetBase ( ArFact ) ;
15684: LD_ADDR_VAR 0 2
15688: PUSH
15689: LD_INT 5
15691: PPUSH
15692: CALL_OW 274
15696: ST_TO_ADDR
// if GetResourceType ( Base , MAT_CANS ) < 120 then
15697: LD_VAR 0 2
15701: PPUSH
15702: LD_INT 1
15704: PPUSH
15705: CALL_OW 275
15709: PUSH
15710: LD_INT 120
15712: LESS
15713: IFFALSE 15717
// exit ;
15715: GO 15783
// if GetResourceType ( Base , MAT_SIBERIT ) < 30 then
15717: LD_VAR 0 2
15721: PPUSH
15722: LD_INT 3
15724: PPUSH
15725: CALL_OW 275
15729: PUSH
15730: LD_INT 30
15732: LESS
15733: IFFALSE 15737
// exit ;
15735: GO 15783
// AddComConstruct ( ArFact , Chassis , ENGINE_SIBERITE , Control , Weapon ) ;
15737: LD_INT 5
15739: PPUSH
15740: LD_VAR 0 3
15744: PPUSH
15745: LD_INT 3
15747: PPUSH
15748: LD_VAR 0 5
15752: PPUSH
15753: LD_VAR 0 4
15757: PPUSH
15758: CALL_OW 185
// if Weapon = AR_CONTROL_TOWER then
15762: LD_VAR 0 4
15766: PUSH
15767: LD_INT 31
15769: EQUAL
15770: IFFALSE 15783
// begin DelamDalkare = true ;
15772: LD_ADDR_LOC 51
15776: PUSH
15777: LD_INT 1
15779: ST_TO_ADDR
// enable ( 33 ) ;
15780: LD_INT 33
15782: ENABLE_MARKED
// end ; end ;
15783: LD_VAR 0 1
15787: RET
// every 5 5$1 marked 33 do
15788: GO 15790
15790: DISABLE
// begin if not ArDalkar then
15791: LD_LOC 49
15795: NOT
15796: IFFALSE 15806
// DelamDalkare = false ;
15798: LD_ADDR_LOC 51
15802: PUSH
15803: LD_INT 0
15805: ST_TO_ADDR
// end ;
15806: END
// every 0 0$19 do
15807: GO 15809
15809: DISABLE
// begin kontrola_vyroby ;
15810: CALL 15443 0 0
// enable ;
15814: ENABLE
// end ;
15815: END
// function zjisti_auta_na_utok ; var KolikChci , I , Riditelne ; begin
15816: LD_INT 0
15818: PPUSH
15819: PPUSH
15820: PPUSH
15821: PPUSH
// KolikChci = dif_UtokSkupina [ Difficulty ] ;
15822: LD_ADDR_VAR 0 2
15826: PUSH
15827: LD_EXP 47
15831: PUSH
15832: LD_OWVAR 67
15836: ARRAY
15837: ST_TO_ADDR
// I = Rand ( 1 , 100 ) ;
15838: LD_ADDR_VAR 0 3
15842: PUSH
15843: LD_INT 1
15845: PPUSH
15846: LD_INT 100
15848: PPUSH
15849: CALL_OW 12
15853: ST_TO_ADDR
// if ( I < 25 ) then
15854: LD_VAR 0 3
15858: PUSH
15859: LD_INT 25
15861: LESS
15862: IFFALSE 15880
// KolikChci = KolikChci - 1 else
15864: LD_ADDR_VAR 0 2
15868: PUSH
15869: LD_VAR 0 2
15873: PUSH
15874: LD_INT 1
15876: MINUS
15877: ST_TO_ADDR
15878: GO 15914
// if ( I > 75 ) and ( CisloUtoku > 1 ) then
15880: LD_VAR 0 3
15884: PUSH
15885: LD_INT 75
15887: GREATER
15888: PUSH
15889: LD_LOC 53
15893: PUSH
15894: LD_INT 1
15896: GREATER
15897: AND
15898: IFFALSE 15914
// KolikChci = KolikChci + 1 ;
15900: LD_ADDR_VAR 0 2
15904: PUSH
15905: LD_VAR 0 2
15909: PUSH
15910: LD_INT 1
15912: PLUS
15913: ST_TO_ADDR
// Riditelne = [ ] ;
15914: LD_ADDR_VAR 0 4
15918: PUSH
15919: EMPTY
15920: ST_TO_ADDR
// for I in Auta do
15921: LD_ADDR_VAR 0 3
15925: PUSH
15926: LD_LOC 40
15930: PUSH
15931: FOR_IN
15932: IFFALSE 16018
// begin if ( GetControl ( I ) = CONTROL_MANUAL ) and not IsDrivenBy ( I ) then
15934: LD_VAR 0 3
15938: PPUSH
15939: CALL_OW 263
15943: PUSH
15944: LD_INT 1
15946: EQUAL
15947: PUSH
15948: LD_VAR 0 3
15952: PPUSH
15953: CALL_OW 311
15957: NOT
15958: AND
15959: IFFALSE 15963
// continue ;
15961: GO 15931
// if ( GetWeapon ( I ) = AR_CONTROL_TOWER ) then
15963: LD_VAR 0 3
15967: PPUSH
15968: CALL_OW 264
15972: PUSH
15973: LD_INT 31
15975: EQUAL
15976: IFFALSE 15980
// continue ;
15978: GO 15931
// if ( GetLives ( I ) < HRANICE_ZDRAVI ) then
15980: LD_VAR 0 3
15984: PPUSH
15985: CALL_OW 256
15989: PUSH
15990: LD_INT 1000
15992: LESS
15993: IFFALSE 15997
// continue ;
15995: GO 15931
// Riditelne = Riditelne union [ I ] ;
15997: LD_ADDR_VAR 0 4
16001: PUSH
16002: LD_VAR 0 4
16006: PUSH
16007: LD_VAR 0 3
16011: PUSH
16012: EMPTY
16013: LIST
16014: UNION
16015: ST_TO_ADDR
// end ;
16016: GO 15931
16018: POP
16019: POP
// if Riditelne >= KolikChci then
16020: LD_VAR 0 4
16024: PUSH
16025: LD_VAR 0 2
16029: GREATEREQUAL
16030: IFFALSE 16170
// begin if ( Tick > 45 45$0 ) then
16032: LD_OWVAR 1
16036: PUSH
16037: LD_INT 94500
16039: GREATER
16040: IFFALSE 16054
// Result = Riditelne else
16042: LD_ADDR_VAR 0 1
16046: PUSH
16047: LD_VAR 0 4
16051: ST_TO_ADDR
16052: GO 16105
// begin Result = [ ] ;
16054: LD_ADDR_VAR 0 1
16058: PUSH
16059: EMPTY
16060: ST_TO_ADDR
// for I = 1 to KolikChci do
16061: LD_ADDR_VAR 0 3
16065: PUSH
16066: DOUBLE
16067: LD_INT 1
16069: DEC
16070: ST_TO_ADDR
16071: LD_VAR 0 2
16075: PUSH
16076: FOR_TO
16077: IFFALSE 16103
// Result = Result union Riditelne [ I ] ;
16079: LD_ADDR_VAR 0 1
16083: PUSH
16084: LD_VAR 0 1
16088: PUSH
16089: LD_VAR 0 4
16093: PUSH
16094: LD_VAR 0 3
16098: ARRAY
16099: UNION
16100: ST_TO_ADDR
16101: GO 16076
16103: POP
16104: POP
// end ; if Obranci > 4 then
16105: LD_LOC 37
16109: PUSH
16110: LD_INT 4
16112: GREATER
16113: IFFALSE 16168
// for I = 1 to Rand ( 1 , 2 ) do
16115: LD_ADDR_VAR 0 3
16119: PUSH
16120: DOUBLE
16121: LD_INT 1
16123: DEC
16124: ST_TO_ADDR
16125: LD_INT 1
16127: PPUSH
16128: LD_INT 2
16130: PPUSH
16131: CALL_OW 12
16135: PUSH
16136: FOR_TO
16137: IFFALSE 16166
// Result = Result union [ Obranci [ I ] ] ;
16139: LD_ADDR_VAR 0 1
16143: PUSH
16144: LD_VAR 0 1
16148: PUSH
16149: LD_LOC 37
16153: PUSH
16154: LD_VAR 0 3
16158: ARRAY
16159: PUSH
16160: EMPTY
16161: LIST
16162: UNION
16163: ST_TO_ADDR
16164: GO 16136
16166: POP
16167: POP
// end else
16168: GO 16177
// Result = [ ] ;
16170: LD_ADDR_VAR 0 1
16174: PUSH
16175: EMPTY
16176: ST_TO_ADDR
// end ;
16177: LD_VAR 0 1
16181: RET
// function zacni_utok ; begin
16182: LD_INT 0
16184: PPUSH
// ProbihaUtok = true ;
16185: LD_ADDR_EXP 62
16189: PUSH
16190: LD_INT 1
16192: ST_TO_ADDR
// if ( RusMaOtraveno < 2 ) and not KdoOtravuje and RusMaSiberit then
16193: LD_EXP 64
16197: PUSH
16198: LD_INT 2
16200: LESS
16201: PUSH
16202: LD_LOC 42
16206: NOT
16207: AND
16208: PUSH
16209: LD_EXP 63
16213: AND
16214: IFFALSE 16235
// begin otravuj ;
16216: CALL 13493 0 0
// Wait ( Rand ( 0 0$10 , 0 0$15 ) ) ;
16220: LD_INT 350
16222: PPUSH
16223: LD_INT 525
16225: PPUSH
16226: CALL_OW 12
16230: PPUSH
16231: CALL_OW 67
// end ; MakroUtok = McAttack ( 10 , RegUtok , Utok_Auta , [ [ MC_RETREAT_AREA_PEOPLE , AraboveParkoviste ] , [ MC_RETREAT_AREA_VEHICLES , AraboveParkoviste ] , [ MC_RETREAT_LIVES_PEOPLE , 10 ] , [ MC_RETREAT_LIVES_VEHICLES , 10 ] ] ) ;
16235: LD_ADDR_LOC 52
16239: PUSH
16240: LD_INT 10
16242: PPUSH
16243: LD_LOC 47
16247: PPUSH
16248: LD_LOC 41
16252: PPUSH
16253: LD_INT 7
16255: PUSH
16256: LD_INT 15
16258: PUSH
16259: EMPTY
16260: LIST
16261: LIST
16262: PUSH
16263: LD_INT 8
16265: PUSH
16266: LD_INT 15
16268: PUSH
16269: EMPTY
16270: LIST
16271: LIST
16272: PUSH
16273: LD_INT 5
16275: PUSH
16276: LD_INT 10
16278: PUSH
16279: EMPTY
16280: LIST
16281: LIST
16282: PUSH
16283: LD_INT 6
16285: PUSH
16286: LD_INT 10
16288: PUSH
16289: EMPTY
16290: LIST
16291: LIST
16292: PUSH
16293: EMPTY
16294: LIST
16295: LIST
16296: LIST
16297: LIST
16298: PPUSH
16299: CALL_OW 402
16303: ST_TO_ADDR
// end ;
16304: LD_VAR 0 1
16308: RET
// function vrat_utok ; var I ; begin
16309: LD_INT 0
16311: PPUSH
16312: PPUSH
// ProbihaUtok = false ;
16313: LD_ADDR_EXP 62
16317: PUSH
16318: LD_INT 0
16320: ST_TO_ADDR
// CisloUtoku = CisloUtoku + 1 ;
16321: LD_ADDR_LOC 53
16325: PUSH
16326: LD_LOC 53
16330: PUSH
16331: LD_INT 1
16333: PLUS
16334: ST_TO_ADDR
// MakroUtok = 0 ;
16335: LD_ADDR_LOC 52
16339: PUSH
16340: LD_INT 0
16342: ST_TO_ADDR
// AddComMoveToArea ( Utok_Auta , Arabove ) ;
16343: LD_LOC 41
16347: PPUSH
16348: LD_INT 5
16350: PPUSH
16351: CALL_OW 173
// end ;
16355: LD_VAR 0 1
16359: RET
// export function arabi_McAttackDone ( McId , Un ) ; begin
16360: LD_INT 0
16362: PPUSH
// vrat_utok ;
16363: CALL 16309 0 0
// end ;
16367: LD_VAR 0 3
16371: RET
// function zjisti_cas_utoku ; begin
16372: LD_INT 0
16374: PPUSH
// if CasyUtoku then
16375: LD_LOC 56
16379: IFFALSE 16425
// begin Result = CasyUtoku [ 1 ] ;
16381: LD_ADDR_VAR 0 1
16385: PUSH
16386: LD_LOC 56
16390: PUSH
16391: LD_INT 1
16393: ARRAY
16394: ST_TO_ADDR
// if CasyUtoku > 1 then
16395: LD_LOC 56
16399: PUSH
16400: LD_INT 1
16402: GREATER
16403: IFFALSE 16423
// CasyUtoku = Delete ( CasyUtoku , 1 ) ;
16405: LD_ADDR_LOC 56
16409: PUSH
16410: LD_LOC 56
16414: PPUSH
16415: LD_INT 1
16417: PPUSH
16418: CALL_OW 3
16422: ST_TO_ADDR
// end else
16423: GO 16433
// Result = 5 ;
16425: LD_ADDR_VAR 0 1
16429: PUSH
16430: LD_INT 5
16432: ST_TO_ADDR
// end ;
16433: LD_VAR 0 1
16437: RET
// function utoceni_splneny_predpoklady ; begin
16438: LD_INT 0
16440: PPUSH
// Result = VidelRusa or ( Tick > 12 12$0 ) ;
16441: LD_ADDR_VAR 0 1
16445: PUSH
16446: LD_LOC 58
16450: PUSH
16451: LD_OWVAR 1
16455: PUSH
16456: LD_INT 25200
16458: GREATER
16459: OR
16460: ST_TO_ADDR
// if Prob ( 25 ) then
16461: LD_INT 25
16463: PPUSH
16464: CALL_OW 13
16468: IFFALSE 16478
// Result = false ;
16470: LD_ADDR_VAR 0 1
16474: PUSH
16475: LD_INT 0
16477: ST_TO_ADDR
// end ;
16478: LD_VAR 0 1
16482: RET
// function casovac_utok ; begin
16483: LD_INT 0
16485: PPUSH
// if ProbihaUtok then
16486: LD_EXP 62
16490: IFFALSE 16494
// exit ;
16492: GO 16601
// if ArabiZniceni then
16494: LD_EXP 65
16498: IFFALSE 16502
// exit ;
16500: GO 16601
// if Utok_ZbyvaMinut = - 1 then
16502: LD_LOC 55
16506: PUSH
16507: LD_INT 1
16509: NEG
16510: EQUAL
16511: IFFALSE 16523
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
16513: LD_ADDR_LOC 55
16517: PUSH
16518: CALL 16372 0 0
16522: ST_TO_ADDR
// if Utok_ZbyvaMinut > 0 then
16523: LD_LOC 55
16527: PUSH
16528: LD_INT 0
16530: GREATER
16531: IFFALSE 16547
// Utok_ZbyvaMinut = Utok_ZbyvaMinut - 1 ;
16533: LD_ADDR_LOC 55
16537: PUSH
16538: LD_LOC 55
16542: PUSH
16543: LD_INT 1
16545: MINUS
16546: ST_TO_ADDR
// if not utoceni_splneny_predpoklady then
16547: CALL 16438 0 0
16551: NOT
16552: IFFALSE 16556
// exit ;
16554: GO 16601
// if Utok_ZbyvaMinut > 0 then
16556: LD_LOC 55
16560: PUSH
16561: LD_INT 0
16563: GREATER
16564: IFFALSE 16568
// exit ;
16566: GO 16601
// Utok_Auta = zjisti_auta_na_utok ;
16568: LD_ADDR_LOC 41
16572: PUSH
16573: CALL 15816 0 0
16577: ST_TO_ADDR
// if not Utok_Auta then
16578: LD_LOC 41
16582: NOT
16583: IFFALSE 16587
// exit ;
16585: GO 16601
// zacni_utok ;
16587: CALL 16182 0 0
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
16591: LD_ADDR_LOC 55
16595: PUSH
16596: CALL 16372 0 0
16600: ST_TO_ADDR
// end ;
16601: LD_VAR 0 1
16605: RET
// every 0 0$45 marked 31 do
16606: GO 16608
16608: DISABLE
// begin Wait ( Rand ( 0 0$0 , 0 0$30 ) ) ;
16609: LD_INT 0
16611: PPUSH
16612: LD_INT 1050
16614: PPUSH
16615: CALL_OW 12
16619: PPUSH
16620: CALL_OW 67
// casovac_utok ;
16624: CALL 16483 0 0
// enable ;
16628: ENABLE
// end ;
16629: END
// every 0 0$30 do
16630: GO 16632
16632: DISABLE
// begin Wait ( 1 1$0 * Rand ( PrvniUtok [ 1 ] , PrvniUtok [ 2 ] ) ) ;
16633: LD_INT 2100
16635: PUSH
16636: LD_LOC 54
16640: PUSH
16641: LD_INT 1
16643: ARRAY
16644: PPUSH
16645: LD_LOC 54
16649: PUSH
16650: LD_INT 2
16652: ARRAY
16653: PPUSH
16654: CALL_OW 12
16658: MUL
16659: PPUSH
16660: CALL_OW 67
// enable ( 31 ) ;
16664: LD_INT 31
16666: ENABLE_MARKED
// end ;
16667: END
// function testuj_minu ( X , Y ) ; var Jednotky ; begin
16668: LD_INT 0
16670: PPUSH
16671: PPUSH
// Jednotky = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_DISTXY , X , Y , 2 ] ] ) ;
16672: LD_ADDR_VAR 0 4
16676: PUSH
16677: LD_INT 22
16679: PUSH
16680: LD_EXP 2
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: PUSH
16689: LD_INT 92
16691: PUSH
16692: LD_VAR 0 1
16696: PUSH
16697: LD_VAR 0 2
16701: PUSH
16702: LD_INT 2
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: PUSH
16711: EMPTY
16712: LIST
16713: LIST
16714: PPUSH
16715: CALL_OW 69
16719: ST_TO_ADDR
// if Jednotky then
16720: LD_VAR 0 4
16724: IFFALSE 16755
// begin LaunchMineAtPos ( X , Y , side_Ar ) ;
16726: LD_VAR 0 1
16730: PPUSH
16731: LD_VAR 0 2
16735: PPUSH
16736: LD_EXP 3
16740: PPUSH
16741: CALL_OW 456
// Result = true ;
16745: LD_ADDR_VAR 0 3
16749: PUSH
16750: LD_INT 1
16752: ST_TO_ADDR
// end else
16753: GO 16763
// Result = false ;
16755: LD_ADDR_VAR 0 3
16759: PUSH
16760: LD_INT 0
16762: ST_TO_ADDR
// end ;
16763: LD_VAR 0 3
16767: RET
// every 0 0$1.1 + 0 0$0.7 do var M , Bouchlo ;
16768: GO 16770
16770: DISABLE
16771: LD_INT 0
16773: PPUSH
16774: PPUSH
// begin if not Miny then
16775: LD_LOC 44
16779: NOT
16780: IFFALSE 16784
// exit ;
16782: GO 16880
// Bouchlo = [ ] ;
16784: LD_ADDR_VAR 0 2
16788: PUSH
16789: EMPTY
16790: ST_TO_ADDR
// for M in Miny do
16791: LD_ADDR_VAR 0 1
16795: PUSH
16796: LD_LOC 44
16800: PUSH
16801: FOR_IN
16802: IFFALSE 16849
// if testuj_minu ( M [ 1 ] , M [ 2 ] ) then
16804: LD_VAR 0 1
16808: PUSH
16809: LD_INT 1
16811: ARRAY
16812: PPUSH
16813: LD_VAR 0 1
16817: PUSH
16818: LD_INT 2
16820: ARRAY
16821: PPUSH
16822: CALL 16668 0 2
16826: IFFALSE 16847
// Bouchlo = Bouchlo ^ [ M ] ;
16828: LD_ADDR_VAR 0 2
16832: PUSH
16833: LD_VAR 0 2
16837: PUSH
16838: LD_VAR 0 1
16842: PUSH
16843: EMPTY
16844: LIST
16845: ADD
16846: ST_TO_ADDR
16847: GO 16801
16849: POP
16850: POP
// if Bouchlo then
16851: LD_VAR 0 2
16855: IFFALSE 16873
// Miny = Miny diff Bouchlo ;
16857: LD_ADDR_LOC 44
16861: PUSH
16862: LD_LOC 44
16866: PUSH
16867: LD_VAR 0 2
16871: DIFF
16872: ST_TO_ADDR
// if Miny then
16873: LD_LOC 44
16877: IFFALSE 16880
// enable ;
16879: ENABLE
// end ;
16880: PPOPN 2
16882: END
// function testuj_behemota ( Un ) ; begin
16883: LD_INT 0
16885: PPUSH
// if not IsInArea ( Un , AraboveObrana ) then
16886: LD_VAR 0 1
16890: PPUSH
16891: LD_INT 12
16893: PPUSH
16894: CALL_OW 308
16898: NOT
16899: IFFALSE 16903
// exit ;
16901: GO 16936
// if not See ( side_Ar , Un ) then
16903: LD_EXP 3
16907: PPUSH
16908: LD_VAR 0 1
16912: PPUSH
16913: CALL_OW 292
16917: NOT
16918: IFFALSE 16922
// exit ;
16920: GO 16936
// AddComAttackUnit ( ObranaBehemota , Un ) ;
16922: LD_LOC 45
16926: PPUSH
16927: LD_VAR 0 1
16931: PPUSH
16932: CALL_OW 175
// end ;
16936: LD_VAR 0 2
16940: RET
// every 0 0$5.1 do var Kdo , I ;
16941: GO 16943
16943: DISABLE
16944: LD_INT 0
16946: PPUSH
16947: PPUSH
// begin Kdo = FilterUnitsInArea ( AraboveObrana , [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_VEHICLE ] , [ F_CHASSIS , 25 ] ] ) ;
16948: LD_ADDR_VAR 0 1
16952: PUSH
16953: LD_INT 12
16955: PPUSH
16956: LD_INT 22
16958: PUSH
16959: LD_EXP 2
16963: PUSH
16964: EMPTY
16965: LIST
16966: LIST
16967: PUSH
16968: LD_INT 21
16970: PUSH
16971: LD_INT 2
16973: PUSH
16974: EMPTY
16975: LIST
16976: LIST
16977: PUSH
16978: LD_INT 31
16980: PUSH
16981: LD_INT 25
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: PUSH
16988: EMPTY
16989: LIST
16990: LIST
16991: LIST
16992: PPUSH
16993: CALL_OW 70
16997: ST_TO_ADDR
// for I in Kdo do
16998: LD_ADDR_VAR 0 2
17002: PUSH
17003: LD_VAR 0 1
17007: PUSH
17008: FOR_IN
17009: IFFALSE 17022
// testuj_behemota ( I ) ;
17011: LD_VAR 0 2
17015: PPUSH
17016: CALL 16883 0 1
17020: GO 17008
17022: POP
17023: POP
// if ObranaBehemota then
17024: LD_LOC 45
17028: IFFALSE 17031
// enable ;
17030: ENABLE
// end ;
17031: PPOPN 2
17033: END
// export function arabi_ApemanTamed ( Ape , Sci ) ; var tmp , tmp1 , tmp2 ; begin
17034: LD_INT 0
17036: PPUSH
17037: PPUSH
17038: PPUSH
17039: PPUSH
// if GetSide ( Sci ) <> side_Ar then
17040: LD_VAR 0 2
17044: PPUSH
17045: CALL_OW 255
17049: PUSH
17050: LD_EXP 3
17054: NONEQUAL
17055: IFFALSE 17059
// exit ;
17057: GO 17071
// ComMoveToArea ( Ape , Arabove ) ;
17059: LD_VAR 0 1
17063: PPUSH
17064: LD_INT 5
17066: PPUSH
17067: CALL_OW 113
// end ;
17071: LD_VAR 0 3
17075: RET
// function kamikazuj_opicaky ; var O ; begin
17076: LD_INT 0
17078: PPUSH
17079: PPUSH
// O = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ) ;
17080: LD_ADDR_VAR 0 2
17084: PUSH
17085: LD_INT 22
17087: PUSH
17088: LD_EXP 3
17092: PUSH
17093: EMPTY
17094: LIST
17095: LIST
17096: PUSH
17097: LD_INT 21
17099: PUSH
17100: LD_INT 1
17102: PUSH
17103: EMPTY
17104: LIST
17105: LIST
17106: PUSH
17107: LD_INT 25
17109: PUSH
17110: LD_INT 17
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: LIST
17121: PPUSH
17122: CALL_OW 69
17126: ST_TO_ADDR
// AddMcUnits ( MakroKamikaze , O ) ;
17127: LD_LOC 46
17131: PPUSH
17132: LD_VAR 0 2
17136: PPUSH
17137: CALL_OW 390
// end ;
17141: LD_VAR 0 1
17145: RET
// function zmen_na_kamikaze ( Ape ) ; begin
17146: LD_INT 0
17148: PPUSH
// AddComEnterUnit ( Ape , ArLabWS ) ;
17149: LD_VAR 0 1
17153: PPUSH
17154: LD_INT 11
17156: PPUSH
17157: CALL_OW 180
// AddComChangeProfession ( Ape , CLASS_APEMAN_KAMIKAZE ) ;
17161: LD_VAR 0 1
17165: PPUSH
17166: LD_INT 17
17168: PPUSH
17169: CALL_OW 183
// AddComExitBuilding ( Ape ) ;
17173: LD_VAR 0 1
17177: PPUSH
17178: CALL_OW 182
// end ;
17182: LD_VAR 0 2
17186: RET
// function chci_ridice_opicaka ; begin
17187: LD_INT 0
17189: PPUSH
// Result = false ;
17190: LD_ADDR_VAR 0 1
17194: PUSH
17195: LD_INT 0
17197: ST_TO_ADDR
// if VolnyRidiciOpicaci >= 2 then
17198: LD_LOC 48
17202: PUSH
17203: LD_INT 2
17205: GREATEREQUAL
17206: IFFALSE 17210
// exit ;
17208: GO 17244
// if UnitsInside ( ArFact ) > 4 then
17210: LD_INT 5
17212: PPUSH
17213: CALL_OW 313
17217: PUSH
17218: LD_INT 4
17220: GREATER
17221: IFFALSE 17225
// exit ;
17223: GO 17244
// if Prob ( 50 ) then
17225: LD_INT 50
17227: PPUSH
17228: CALL_OW 13
17232: IFFALSE 17236
// exit ;
17234: GO 17244
// Result = true ;
17236: LD_ADDR_VAR 0 1
17240: PUSH
17241: LD_INT 1
17243: ST_TO_ADDR
// end ;
17244: LD_VAR 0 1
17248: RET
// function men_na_kamikaze ; var O , I ; begin
17249: LD_INT 0
17251: PPUSH
17252: PPUSH
17253: PPUSH
// O = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_APEMAN ] , [ F_OUTSIDE ] ] ) ;
17254: LD_ADDR_VAR 0 2
17258: PUSH
17259: LD_INT 22
17261: PUSH
17262: LD_EXP 3
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: PUSH
17271: LD_INT 21
17273: PUSH
17274: LD_INT 1
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: PUSH
17281: LD_INT 25
17283: PUSH
17284: LD_INT 12
17286: PUSH
17287: EMPTY
17288: LIST
17289: LIST
17290: PUSH
17291: LD_INT 56
17293: PUSH
17294: EMPTY
17295: LIST
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: LIST
17301: LIST
17302: PPUSH
17303: CALL_OW 69
17307: ST_TO_ADDR
// for I in O do
17308: LD_ADDR_VAR 0 3
17312: PUSH
17313: LD_VAR 0 2
17317: PUSH
17318: FOR_IN
17319: IFFALSE 17391
// begin if IsBusy ( I ) then
17321: LD_VAR 0 3
17325: PPUSH
17326: CALL_OW 315
17330: IFFALSE 17334
// continue ;
17332: GO 17318
// if HasTask ( I ) then
17334: LD_VAR 0 3
17338: PPUSH
17339: CALL_OW 314
17343: IFFALSE 17347
// continue ;
17345: GO 17318
// if IsInUnit ( I ) then
17347: LD_VAR 0 3
17351: PPUSH
17352: CALL_OW 310
17356: IFFALSE 17360
// continue ;
17358: GO 17318
// if chci_ridice_opicaka then
17360: CALL 17187 0 0
17364: IFFALSE 17380
// begin ComEnterUnit ( I , ArFact ) ;
17366: LD_VAR 0 3
17370: PPUSH
17371: LD_INT 5
17373: PPUSH
17374: CALL_OW 120
// end else
17378: GO 17389
// zmen_na_kamikaze ( I ) ;
17380: LD_VAR 0 3
17384: PPUSH
17385: CALL 17146 0 1
// end ;
17389: GO 17318
17391: POP
17392: POP
// end ;
17393: LD_VAR 0 1
17397: RET
// function vedec_volny ( List ) ; var I , OK ; begin
17398: LD_INT 0
17400: PPUSH
17401: PPUSH
17402: PPUSH
// OK = [ ] ;
17403: LD_ADDR_VAR 0 4
17407: PUSH
17408: EMPTY
17409: ST_TO_ADDR
// for I in List do
17410: LD_ADDR_VAR 0 3
17414: PUSH
17415: LD_VAR 0 1
17419: PUSH
17420: FOR_IN
17421: IFFALSE 17467
// if IsInUnit ( I ) or not HasTask ( I ) then
17423: LD_VAR 0 3
17427: PPUSH
17428: CALL_OW 310
17432: PUSH
17433: LD_VAR 0 3
17437: PPUSH
17438: CALL_OW 314
17442: NOT
17443: OR
17444: IFFALSE 17465
// OK = OK union [ I ] ;
17446: LD_ADDR_VAR 0 4
17450: PUSH
17451: LD_VAR 0 4
17455: PUSH
17456: LD_VAR 0 3
17460: PUSH
17461: EMPTY
17462: LIST
17463: UNION
17464: ST_TO_ADDR
17465: GO 17420
17467: POP
17468: POP
// Result = nahoda_seznam ( OK ) ;
17469: LD_ADDR_VAR 0 2
17473: PUSH
17474: LD_VAR 0 4
17478: PPUSH
17479: CALL 21499 0 1
17483: ST_TO_ADDR
// end ;
17484: LD_VAR 0 2
17488: RET
// function lakej_opice ; var Opice , Kdo , I ; begin
17489: LD_INT 0
17491: PPUSH
17492: PPUSH
17493: PPUSH
17494: PPUSH
// if KdoLakaOpice then
17495: LD_LOC 68
17499: IFFALSE 17503
// exit ;
17501: GO 17695
// Kdo = vedec_volny ( [ ArSci1 , ArSci2 , ArSci3 , ArSci4 ] diff KdoLeci ) ;
17503: LD_ADDR_VAR 0 3
17507: PUSH
17508: LD_LOC 28
17512: PUSH
17513: LD_LOC 29
17517: PUSH
17518: LD_LOC 30
17522: PUSH
17523: LD_LOC 31
17527: PUSH
17528: EMPTY
17529: LIST
17530: LIST
17531: LIST
17532: LIST
17533: PUSH
17534: LD_LOC 66
17538: DIFF
17539: PPUSH
17540: CALL 17398 0 1
17544: ST_TO_ADDR
// if not Kdo then
17545: LD_VAR 0 3
17549: NOT
17550: IFFALSE 17554
// exit ;
17552: GO 17695
// if HasTask ( Kdo ) then
17554: LD_VAR 0 3
17558: PPUSH
17559: CALL_OW 314
17563: IFFALSE 17567
// exit ;
17565: GO 17695
// Opice = FilterUnitsInArea ( AraboveOpice , [ [ F_SIDE , side_Neutral ] , [ F_CLASS , CLASS_APEMAN ] ] ) ;
17567: LD_ADDR_VAR 0 2
17571: PUSH
17572: LD_INT 13
17574: PPUSH
17575: LD_INT 22
17577: PUSH
17578: LD_EXP 1
17582: PUSH
17583: EMPTY
17584: LIST
17585: LIST
17586: PUSH
17587: LD_INT 25
17589: PUSH
17590: LD_INT 12
17592: PUSH
17593: EMPTY
17594: LIST
17595: LIST
17596: PUSH
17597: EMPTY
17598: LIST
17599: LIST
17600: PPUSH
17601: CALL_OW 70
17605: ST_TO_ADDR
// if not Opice then
17606: LD_VAR 0 2
17610: NOT
17611: IFFALSE 17615
// exit ;
17613: GO 17695
// KdoLakaOpice = [ Kdo ] ;
17615: LD_ADDR_LOC 68
17619: PUSH
17620: LD_VAR 0 3
17624: PUSH
17625: EMPTY
17626: LIST
17627: ST_TO_ADDR
// ComExitBuilding ( KdoLakaOpice ) ;
17628: LD_LOC 68
17632: PPUSH
17633: CALL_OW 122
// for I in Opice do
17637: LD_ADDR_VAR 0 4
17641: PUSH
17642: LD_VAR 0 2
17646: PUSH
17647: FOR_IN
17648: IFFALSE 17681
// AddComTameXY ( KdoLakaOpice , GetX ( I ) , GetY ( I ) ) ;
17650: LD_LOC 68
17654: PPUSH
17655: LD_VAR 0 4
17659: PPUSH
17660: CALL_OW 250
17664: PPUSH
17665: LD_VAR 0 4
17669: PPUSH
17670: CALL_OW 251
17674: PPUSH
17675: CALL_OW 191
17679: GO 17647
17681: POP
17682: POP
// AddComSailEvent ( KdoLakaOpice , 103 ) ;
17683: LD_LOC 68
17687: PPUSH
17688: LD_INT 103
17690: PPUSH
17691: CALL_OW 224
// end ;
17695: LD_VAR 0 1
17699: RET
// export function event_DolakanaOpice ; var Kdo ; begin
17700: LD_INT 0
17702: PPUSH
17703: PPUSH
// for Kdo in KdoLakaOpice do
17704: LD_ADDR_VAR 0 2
17708: PUSH
17709: LD_LOC 68
17713: PUSH
17714: FOR_IN
17715: IFFALSE 17728
// zpet_do_labu ( Kdo ) ;
17717: LD_VAR 0 2
17721: PPUSH
17722: CALL 13107 0 1
17726: GO 17714
17728: POP
17729: POP
// KdoLakaOpice = [ ] ;
17730: LD_ADDR_LOC 68
17734: PUSH
17735: EMPTY
17736: ST_TO_ADDR
// end ;
17737: LD_VAR 0 1
17741: RET
// function vytvor_nove_opice ; var Opice , I , Hex , Pocet ; begin
17742: LD_INT 0
17744: PPUSH
17745: PPUSH
17746: PPUSH
17747: PPUSH
17748: PPUSH
// Result = true ;
17749: LD_ADDR_VAR 0 1
17753: PUSH
17754: LD_INT 1
17756: ST_TO_ADDR
// Opice = FilterAllUnits ( [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
17757: LD_ADDR_VAR 0 2
17761: PUSH
17762: LD_INT 2
17764: PUSH
17765: LD_INT 25
17767: PUSH
17768: LD_INT 12
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: PUSH
17775: LD_INT 25
17777: PUSH
17778: LD_INT 15
17780: PUSH
17781: EMPTY
17782: LIST
17783: LIST
17784: PUSH
17785: LD_INT 25
17787: PUSH
17788: LD_INT 16
17790: PUSH
17791: EMPTY
17792: LIST
17793: LIST
17794: PUSH
17795: LD_INT 25
17797: PUSH
17798: LD_INT 17
17800: PUSH
17801: EMPTY
17802: LIST
17803: LIST
17804: PUSH
17805: EMPTY
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: PUSH
17812: EMPTY
17813: LIST
17814: PPUSH
17815: CALL_OW 69
17819: ST_TO_ADDR
// if Opice > MaxOpice then
17820: LD_VAR 0 2
17824: PUSH
17825: LD_LOC 61
17829: GREATER
17830: IFFALSE 17834
// exit ;
17832: GO 18028
// Pocet = Rand ( 1 , OpiceNajednouPocet ) ;
17834: LD_ADDR_VAR 0 5
17838: PUSH
17839: LD_INT 1
17841: PPUSH
17842: LD_LOC 65
17846: PPUSH
17847: CALL_OW 12
17851: ST_TO_ADDR
// if ( OpiceLimit <> - 1 ) and ( Pocet > OpiceLimit ) then
17852: LD_LOC 64
17856: PUSH
17857: LD_INT 1
17859: NEG
17860: NONEQUAL
17861: PUSH
17862: LD_VAR 0 5
17866: PUSH
17867: LD_LOC 64
17871: GREATER
17872: AND
17873: IFFALSE 17885
// Pocet = OpiceLimit ;
17875: LD_ADDR_VAR 0 5
17879: PUSH
17880: LD_LOC 64
17884: ST_TO_ADDR
// Opice = create_nature ( CLASS_APEMAN , Pocet , CreateOpice ) ;
17885: LD_ADDR_VAR 0 2
17889: PUSH
17890: LD_INT 12
17892: PPUSH
17893: LD_VAR 0 5
17897: PPUSH
17898: LD_INT 14
17900: PPUSH
17901: CALL 2877 0 3
17905: ST_TO_ADDR
// for I in Opice do
17906: LD_ADDR_VAR 0 3
17910: PUSH
17911: LD_VAR 0 2
17915: PUSH
17916: FOR_IN
17917: IFFALSE 17981
// if Prob ( PstOpiceRus ) then
17919: LD_LOC 63
17923: PPUSH
17924: CALL_OW 13
17928: IFFALSE 17979
// begin Hex = RandHexArea ( Les , true ) ;
17930: LD_ADDR_VAR 0 4
17934: PUSH
17935: LD_INT 1
17937: PPUSH
17938: LD_INT 1
17940: PPUSH
17941: CALL_OW 16
17945: ST_TO_ADDR
// if Hex then
17946: LD_VAR 0 4
17950: IFFALSE 17979
// ComMoveXY ( I , Hex [ 1 ] , Hex [ 2 ] ) ;
17952: LD_VAR 0 3
17956: PPUSH
17957: LD_VAR 0 4
17961: PUSH
17962: LD_INT 1
17964: ARRAY
17965: PPUSH
17966: LD_VAR 0 4
17970: PUSH
17971: LD_INT 2
17973: ARRAY
17974: PPUSH
17975: CALL_OW 111
// end ;
17979: GO 17916
17981: POP
17982: POP
// if OpiceLimit <> - 1 then
17983: LD_LOC 64
17987: PUSH
17988: LD_INT 1
17990: NEG
17991: NONEQUAL
17992: IFFALSE 18028
// begin OpiceLimit = OpiceLimit - Pocet ;
17994: LD_ADDR_LOC 64
17998: PUSH
17999: LD_LOC 64
18003: PUSH
18004: LD_VAR 0 5
18008: MINUS
18009: ST_TO_ADDR
// if OpiceLimit = 0 then
18010: LD_LOC 64
18014: PUSH
18015: LD_INT 0
18017: EQUAL
18018: IFFALSE 18028
// Result = false ;
18020: LD_ADDR_VAR 0 1
18024: PUSH
18025: LD_INT 0
18027: ST_TO_ADDR
// end ; end ;
18028: LD_VAR 0 1
18032: RET
// every 0 0$15.3 do
18033: GO 18035
18035: DISABLE
// begin men_na_kamikaze ;
18036: CALL 17249 0 0
// enable ;
18040: ENABLE
// end ;
18041: END
// every 0 0$7.1 do
18042: GO 18044
18044: DISABLE
// begin kamikazuj_opicaky ;
18045: CALL 17076 0 0
// enable ;
18049: ENABLE
// end ;
18050: END
// every 1 1$13 do
18051: GO 18053
18053: DISABLE
// begin lakej_opice ;
18054: CALL 17489 0 0
// enable ;
18058: ENABLE
// end ;
18059: END
// every 2 2$25 do
18060: GO 18062
18062: DISABLE
// begin Wait ( Rand ( ZpozdeniOpice [ 1 ] , ZpozdeniOpice [ 2 ] ) ) ;
18063: LD_LOC 62
18067: PUSH
18068: LD_INT 1
18070: ARRAY
18071: PPUSH
18072: LD_LOC 62
18076: PUSH
18077: LD_INT 2
18079: ARRAY
18080: PPUSH
18081: CALL_OW 12
18085: PPUSH
18086: CALL_OW 67
// if vytvor_nove_opice then
18090: CALL 17742 0 0
18094: IFFALSE 18097
// enable ;
18096: ENABLE
// end ;
18097: END
// every 0 0$1.1 trigger vidi_strana_stranu ( side_Ar , side_Ru ) do
18098: LD_EXP 3
18102: PPUSH
18103: LD_EXP 2
18107: PPUSH
18108: CALL 21547 0 2
18112: IFFALSE 18125
18114: GO 18116
18116: DISABLE
// begin VidelRusa = true ;
18117: LD_ADDR_LOC 58
18121: PUSH
18122: LD_INT 1
18124: ST_TO_ADDR
// end ;
18125: END
// function zarid_ridice ( Veh ) ; var Lidi , I ; begin
18126: LD_INT 0
18128: PPUSH
18129: PPUSH
18130: PPUSH
// if Veh = ArDalkar then
18131: LD_VAR 0 1
18135: PUSH
18136: LD_LOC 49
18140: EQUAL
18141: IFFALSE 18182
// begin if IsOk ( ArMechDalkar ) and not IsInUnit ( ArMechDalkar ) then
18143: LD_LOC 36
18147: PPUSH
18148: CALL_OW 302
18152: PUSH
18153: LD_LOC 36
18157: PPUSH
18158: CALL_OW 310
18162: NOT
18163: AND
18164: IFFALSE 18182
// begin ComEnterUnit ( ArMechDalkar , Veh ) ;
18166: LD_LOC 36
18170: PPUSH
18171: LD_VAR 0 1
18175: PPUSH
18176: CALL_OW 120
// exit ;
18180: GO 18253
// end ; end ; Lidi = UnitFilter ( VolnyLidi , [ [ F_OUTSIDE ] ] ) ;
18182: LD_ADDR_VAR 0 3
18186: PUSH
18187: LD_LOC 39
18191: PPUSH
18192: LD_INT 56
18194: PUSH
18195: EMPTY
18196: LIST
18197: PUSH
18198: EMPTY
18199: LIST
18200: PPUSH
18201: CALL_OW 72
18205: ST_TO_ADDR
// for I in Lidi do
18206: LD_ADDR_VAR 0 4
18210: PUSH
18211: LD_VAR 0 3
18215: PUSH
18216: FOR_IN
18217: IFFALSE 18251
// if not HasTask ( I ) then
18219: LD_VAR 0 4
18223: PPUSH
18224: CALL_OW 314
18228: NOT
18229: IFFALSE 18249
// begin ComEnterUnit ( I , Veh ) ;
18231: LD_VAR 0 4
18235: PPUSH
18236: LD_VAR 0 1
18240: PPUSH
18241: CALL_OW 120
// exit ;
18245: POP
18246: POP
18247: GO 18253
// end ;
18249: GO 18216
18251: POP
18252: POP
// end ;
18253: LD_VAR 0 2
18257: RET
// function nastupuj_auta ; var Auta , I ; begin
18258: LD_INT 0
18260: PPUSH
18261: PPUSH
18262: PPUSH
// Auta = FilterUnitsInArea ( AraboveObrana , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_CONTROL , CONTROL_MANUAL ] , [ F_EMPTY ] ] ) ;
18263: LD_ADDR_VAR 0 2
18267: PUSH
18268: LD_INT 12
18270: PPUSH
18271: LD_INT 21
18273: PUSH
18274: LD_INT 2
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: PUSH
18281: LD_INT 33
18283: PUSH
18284: LD_INT 1
18286: PUSH
18287: EMPTY
18288: LIST
18289: LIST
18290: PUSH
18291: LD_INT 58
18293: PUSH
18294: EMPTY
18295: LIST
18296: PUSH
18297: EMPTY
18298: LIST
18299: LIST
18300: LIST
18301: PPUSH
18302: CALL_OW 70
18306: ST_TO_ADDR
// if not Auta then
18307: LD_VAR 0 2
18311: NOT
18312: IFFALSE 18316
// exit ;
18314: GO 18342
// for I in Auta do
18316: LD_ADDR_VAR 0 3
18320: PUSH
18321: LD_VAR 0 2
18325: PUSH
18326: FOR_IN
18327: IFFALSE 18340
// zarid_ridice ( I ) ;
18329: LD_VAR 0 3
18333: PPUSH
18334: CALL 18126 0 1
18338: GO 18326
18340: POP
18341: POP
// end ;
18342: LD_VAR 0 1
18346: RET
// every 0 0$17 do
18347: GO 18349
18349: DISABLE
// begin nastupuj_auta ;
18350: CALL 18258 0 0
// enable ;
18354: ENABLE
// end ;
18355: END
// every 0 0$5.1 do var I , Stahnout ;
18356: GO 18358
18358: DISABLE
18359: LD_INT 0
18361: PPUSH
18362: PPUSH
// begin Stahnout = true ;
18363: LD_ADDR_VAR 0 2
18367: PUSH
18368: LD_INT 1
18370: ST_TO_ADDR
// for I in GetMcUnits ( MakroObrana ) do
18371: LD_ADDR_VAR 0 1
18375: PUSH
18376: LD_LOC 43
18380: PPUSH
18381: CALL_OW 389
18385: PUSH
18386: FOR_IN
18387: IFFALSE 18418
// if ( GetUnitMc ( I ) = MakroObrana ) then
18389: LD_VAR 0 1
18393: PPUSH
18394: CALL_OW 388
18398: PUSH
18399: LD_LOC 43
18403: EQUAL
18404: IFFALSE 18416
// begin Stahnout = false ;
18406: LD_ADDR_VAR 0 2
18410: PUSH
18411: LD_INT 0
18413: ST_TO_ADDR
// break ;
18414: GO 18418
// end ;
18416: GO 18386
18418: POP
18419: POP
// enable ;
18420: ENABLE
// if Stahnout <> BeziStahovani then
18421: LD_VAR 0 2
18425: PUSH
18426: LD_LOC 60
18430: NONEQUAL
18431: IFFALSE 18457
// begin if Stahnout then
18433: LD_VAR 0 2
18437: IFFALSE 18444
// enable ( 46 ) else
18439: LD_INT 46
18441: ENABLE_MARKED
18442: GO 18447
// disable ( 46 ) ;
18444: LD_INT 46
18446: DISABLE_MARKED
// BeziStahovani = Stahnout ;
18447: LD_ADDR_LOC 60
18451: PUSH
18452: LD_VAR 0 2
18456: ST_TO_ADDR
// end ; end ;
18457: PPOPN 2
18459: END
// every 0 0$30 marked 32 do var I ;
18460: GO 18462
18462: DISABLE
18463: LD_INT 0
18465: PPUSH
// begin for I in GetMcUnits ( MakroPresunZakladna ) do
18466: LD_ADDR_VAR 0 1
18470: PUSH
18471: LD_LOC 59
18475: PPUSH
18476: CALL_OW 389
18480: PUSH
18481: FOR_IN
18482: IFFALSE 18557
// if ( GetUnitMc ( I ) = MakroPresunZakladna ) and ( GetDistUnitArea ( I , Arabove ) > 0 ) and not IsInUnit ( I ) and not HasTask ( I ) then
18484: LD_VAR 0 1
18488: PPUSH
18489: CALL_OW 388
18493: PUSH
18494: LD_LOC 59
18498: EQUAL
18499: PUSH
18500: LD_VAR 0 1
18504: PPUSH
18505: LD_INT 5
18507: PPUSH
18508: CALL_OW 299
18512: PUSH
18513: LD_INT 0
18515: GREATER
18516: AND
18517: PUSH
18518: LD_VAR 0 1
18522: PPUSH
18523: CALL_OW 310
18527: NOT
18528: AND
18529: PUSH
18530: LD_VAR 0 1
18534: PPUSH
18535: CALL_OW 314
18539: NOT
18540: AND
18541: IFFALSE 18555
// ComMoveToArea ( I , Arabove ) ;
18543: LD_VAR 0 1
18547: PPUSH
18548: LD_INT 5
18550: PPUSH
18551: CALL_OW 113
18555: GO 18481
18557: POP
18558: POP
// BeziStahovani = false ;
18559: LD_ADDR_LOC 60
18563: PUSH
18564: LD_INT 0
18566: ST_TO_ADDR
// end ;
18567: PPOPN 1
18569: END
// every 1 1$16 do var Inz ;
18570: GO 18572
18572: DISABLE
18573: LD_INT 0
18575: PPUSH
// begin Inz = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] , [ F_OK ] ] ) ;
18576: LD_ADDR_VAR 0 1
18580: PUSH
18581: LD_INT 22
18583: PUSH
18584: LD_EXP 3
18588: PUSH
18589: EMPTY
18590: LIST
18591: LIST
18592: PUSH
18593: LD_INT 21
18595: PUSH
18596: LD_INT 1
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: LD_INT 25
18605: PUSH
18606: LD_INT 2
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PUSH
18613: LD_INT 50
18615: PUSH
18616: EMPTY
18617: LIST
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: LIST
18623: LIST
18624: PPUSH
18625: CALL_OW 69
18629: ST_TO_ADDR
// sbirej_bedny ( Inz , Arabove ) ;
18630: LD_VAR 0 1
18634: PPUSH
18635: LD_INT 5
18637: PPUSH
18638: CALL 20986 0 2
// opravuj_budovy ( Inz , Arabove , side_Ar ) ;
18642: LD_VAR 0 1
18646: PPUSH
18647: LD_INT 5
18649: PPUSH
18650: LD_EXP 3
18654: PPUSH
18655: CALL 21216 0 3
// enable ;
18659: ENABLE
// end ;
18660: PPOPN 1
18662: END
// function opravuj ; begin
18663: LD_INT 0
18665: PPUSH
// if KdoOpravuje then
18666: LD_LOC 67
18670: IFFALSE 18674
// exit ;
18672: GO 18714
// KdoOpravuje = opravuj_auta ( [ ArMech1 , ArMech2 ] , 104 , Arabove , side_Ar , Utok_Auta ) ;
18674: LD_ADDR_LOC 67
18678: PUSH
18679: LD_LOC 32
18683: PUSH
18684: LD_LOC 33
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PPUSH
18693: LD_INT 104
18695: PPUSH
18696: LD_INT 5
18698: PPUSH
18699: LD_EXP 3
18703: PPUSH
18704: LD_LOC 41
18708: PPUSH
18709: CALL 21734 0 5
18713: ST_TO_ADDR
// end ;
18714: LD_VAR 0 1
18718: RET
// function kuryruj ; begin
18719: LD_INT 0
18721: PPUSH
// if KdoLeci then
18722: LD_LOC 66
18726: IFFALSE 18730
// exit ;
18728: GO 18783
// KdoLeci = kuryruj_lidi ( [ ArSci1 , ArSci2 , ArSci3 , ArSci4 ] diff KdoLakaOpice , 105 , Arabove , side_Ar ) ;
18730: LD_ADDR_LOC 66
18734: PUSH
18735: LD_LOC 28
18739: PUSH
18740: LD_LOC 29
18744: PUSH
18745: LD_LOC 30
18749: PUSH
18750: LD_LOC 31
18754: PUSH
18755: EMPTY
18756: LIST
18757: LIST
18758: LIST
18759: LIST
18760: PUSH
18761: LD_LOC 68
18765: DIFF
18766: PPUSH
18767: LD_INT 105
18769: PPUSH
18770: LD_INT 5
18772: PPUSH
18773: LD_EXP 3
18777: PPUSH
18778: CALL 22036 0 4
18782: ST_TO_ADDR
// end ;
18783: LD_VAR 0 1
18787: RET
// export function event_ArabiOprava ( Event ) ; var Kdo ; begin
18788: LD_INT 0
18790: PPUSH
18791: PPUSH
// case Event of 104 :
18792: LD_VAR 0 1
18796: PUSH
18797: LD_INT 104
18799: DOUBLE
18800: EQUAL
18801: IFTRUE 18805
18803: GO 18827
18805: POP
// begin ComEnterUnit ( KdoOpravuje , ArFact ) ;
18806: LD_LOC 67
18810: PPUSH
18811: LD_INT 5
18813: PPUSH
18814: CALL_OW 120
// KdoOpravuje = [ ] ;
18818: LD_ADDR_LOC 67
18822: PUSH
18823: EMPTY
18824: ST_TO_ADDR
// end ; 105 :
18825: GO 18872
18827: LD_INT 105
18829: DOUBLE
18830: EQUAL
18831: IFTRUE 18835
18833: GO 18871
18835: POP
// begin for Kdo in KdoLeci do
18836: LD_ADDR_VAR 0 3
18840: PUSH
18841: LD_LOC 66
18845: PUSH
18846: FOR_IN
18847: IFFALSE 18860
// zpet_do_labu ( Kdo ) ;
18849: LD_VAR 0 3
18853: PPUSH
18854: CALL 13107 0 1
18858: GO 18846
18860: POP
18861: POP
// KdoLeci = [ ] ;
18862: LD_ADDR_LOC 66
18866: PUSH
18867: EMPTY
18868: ST_TO_ADDR
// end ; end ;
18869: GO 18872
18871: POP
// end ;
18872: LD_VAR 0 2
18876: RET
// every 0 0$57 do
18877: GO 18879
18879: DISABLE
// begin opravuj ;
18880: CALL 18663 0 0
// kuryruj ;
18884: CALL 18719 0 0
// enable ;
18888: ENABLE
// end ; end_of_file
18889: END
// export RusMaSiberit , RusMaOtraveno ; export ArabiZniceni , LegieMamZnicit , LegieZnicena ; export BehemothBuilt , MenLost ; export function init_rusove ; begin
18890: LD_INT 0
18892: PPUSH
// disable ( 21 ) ;
18893: LD_INT 21
18895: DISABLE_MARKED
// RusMaSiberit = false ;
18896: LD_ADDR_EXP 63
18900: PUSH
18901: LD_INT 0
18903: ST_TO_ADDR
// RusMaOtraveno = 0 ;
18904: LD_ADDR_EXP 64
18908: PUSH
18909: LD_INT 0
18911: ST_TO_ADDR
// ArabiZniceni = false ;
18912: LD_ADDR_EXP 65
18916: PUSH
18917: LD_INT 0
18919: ST_TO_ADDR
// LegieMamZnicit = false ;
18920: LD_ADDR_EXP 66
18924: PUSH
18925: LD_INT 0
18927: ST_TO_ADDR
// LegieZnicena = false ;
18928: LD_ADDR_EXP 67
18932: PUSH
18933: LD_INT 0
18935: ST_TO_ADDR
// BehemothBuilt = false ;
18936: LD_ADDR_EXP 68
18940: PUSH
18941: LD_INT 0
18943: ST_TO_ADDR
// MenLost = 0 ;
18944: LD_ADDR_EXP 69
18948: PUSH
18949: LD_INT 0
18951: ST_TO_ADDR
// end ;
18952: LD_VAR 0 1
18956: RET
// export function uvod ; var I , Auto ; begin
18957: LD_INT 0
18959: PPUSH
18960: PPUSH
18961: PPUSH
// InGameOn ;
18962: CALL_OW 8
// if Masha then
18966: LD_EXP 25
18970: IFFALSE 19003
// begin PlaceHumanInUnit ( Burlak , Masha ) ;
18972: LD_EXP 6
18976: PPUSH
18977: LD_EXP 25
18981: PPUSH
18982: CALL_OW 52
// PlaceUnitArea ( Masha , Start , false ) ;
18986: LD_EXP 25
18990: PPUSH
18991: LD_INT 3
18993: PPUSH
18994: LD_INT 0
18996: PPUSH
18997: CALL_OW 49
// end else
19001: GO 19045
// begin Auto = vytvor_tank ( RU_GUN ) ;
19003: LD_ADDR_VAR 0 3
19007: PUSH
19008: LD_INT 44
19010: PPUSH
19011: CALL 19366 0 1
19015: ST_TO_ADDR
// PlaceHumanInUnit ( Burlak , Auto ) ;
19016: LD_EXP 6
19020: PPUSH
19021: LD_VAR 0 3
19025: PPUSH
19026: CALL_OW 52
// PlaceUnitArea ( Auto , Start , false ) ;
19030: LD_VAR 0 3
19034: PPUSH
19035: LD_INT 3
19037: PPUSH
19038: LD_INT 0
19040: PPUSH
19041: CALL_OW 49
// end ; PlaceUnitArea ( vytvor_nakladak ( MAT_OIL , 100 ) , Start , false ) ;
19045: LD_INT 2
19047: PPUSH
19048: LD_INT 100
19050: PPUSH
19051: CALL 19269 0 2
19055: PPUSH
19056: LD_INT 3
19058: PPUSH
19059: LD_INT 0
19061: PPUSH
19062: CALL_OW 49
// PlaceUnitArea ( vytvor_nakladak ( MAT_CANS , 100 ) , Start , false ) ;
19066: LD_INT 1
19068: PPUSH
19069: LD_INT 100
19071: PPUSH
19072: CALL 19269 0 2
19076: PPUSH
19077: LD_INT 3
19079: PPUSH
19080: LD_INT 0
19082: PPUSH
19083: CALL_OW 49
// PlaceUnitArea ( vytvor_nakladak ( MAT_CANS , 100 ) , Start , false ) ;
19087: LD_INT 1
19089: PPUSH
19090: LD_INT 100
19092: PPUSH
19093: CALL 19269 0 2
19097: PPUSH
19098: LD_INT 3
19100: PPUSH
19101: LD_INT 0
19103: PPUSH
19104: CALL_OW 49
// if Rusove then
19108: LD_EXP 39
19112: IFFALSE 19204
// begin Auto = 0 ;
19114: LD_ADDR_VAR 0 3
19118: PUSH
19119: LD_INT 0
19121: ST_TO_ADDR
// for I in Rusove do
19122: LD_ADDR_VAR 0 2
19126: PUSH
19127: LD_EXP 39
19131: PUSH
19132: FOR_IN
19133: IFFALSE 19202
// begin if Auto then
19135: LD_VAR 0 3
19139: IFFALSE 19158
// PlaceUnitArea ( I , Start , false ) else
19141: LD_VAR 0 2
19145: PPUSH
19146: LD_INT 3
19148: PPUSH
19149: LD_INT 0
19151: PPUSH
19152: CALL_OW 49
19156: GO 19200
// begin Auto = vytvor_tank ( RU_GATLING_GUN ) ;
19158: LD_ADDR_VAR 0 3
19162: PUSH
19163: LD_INT 43
19165: PPUSH
19166: CALL 19366 0 1
19170: ST_TO_ADDR
// PlaceHumanInUnit ( I , Auto ) ;
19171: LD_VAR 0 2
19175: PPUSH
19176: LD_VAR 0 3
19180: PPUSH
19181: CALL_OW 52
// PlaceUnitArea ( Auto , Start , false ) ;
19185: LD_VAR 0 3
19189: PPUSH
19190: LD_INT 3
19192: PPUSH
19193: LD_INT 0
19195: PPUSH
19196: CALL_OW 49
// end ; end ;
19200: GO 19132
19202: POP
19203: POP
// end ; I = IsInUnit ( Burlak ) ;
19204: LD_ADDR_VAR 0 2
19208: PUSH
19209: LD_EXP 6
19213: PPUSH
19214: CALL_OW 310
19218: ST_TO_ADDR
// if I then
19219: LD_VAR 0 2
19223: IFFALSE 19236
// CenterNowOnUnits ( I ) else
19225: LD_VAR 0 2
19229: PPUSH
19230: CALL_OW 87
19234: GO 19245
// CenterNowOnUnits ( Burlak ) ;
19236: LD_EXP 6
19240: PPUSH
19241: CALL_OW 87
// dialog_Start ;
19245: CALL 4603 0 0
// ChangeMissionObjectives ( MStart ) ;
19249: LD_STRING MStart
19251: PPUSH
19252: CALL_OW 337
// SaveForQuickRestart ;
19256: CALL_OW 22
// InGameOff ;
19260: CALL_OW 9
// end ;
19264: LD_VAR 0 1
19268: RET
// function vytvor_nakladak ( Material , Amount ) ; begin
19269: LD_INT 0
19271: PPUSH
// UC_Side = side_Ru ;
19272: LD_ADDR_OWVAR 20
19276: PUSH
19277: LD_EXP 2
19281: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
19282: LD_ADDR_OWVAR 21
19286: PUSH
19287: LD_INT 3
19289: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
19290: LD_ADDR_OWVAR 37
19294: PUSH
19295: LD_INT 21
19297: ST_TO_ADDR
// VC_Control = CONTROL_COMPUTER ;
19298: LD_ADDR_OWVAR 38
19302: PUSH
19303: LD_INT 3
19305: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
19306: LD_ADDR_OWVAR 39
19310: PUSH
19311: LD_INT 3
19313: ST_TO_ADDR
// VC_Weapon = RU_CARGO_BAY ;
19314: LD_ADDR_OWVAR 40
19318: PUSH
19319: LD_INT 51
19321: ST_TO_ADDR
// Result = CreateVehicle ;
19322: LD_ADDR_VAR 0 3
19326: PUSH
19327: CALL_OW 45
19331: ST_TO_ADDR
// if Amount > 0 then
19332: LD_VAR 0 2
19336: PUSH
19337: LD_INT 0
19339: GREATER
19340: IFFALSE 19361
// SetCargo ( Result , Material , Amount ) ;
19342: LD_VAR 0 3
19346: PPUSH
19347: LD_VAR 0 1
19351: PPUSH
19352: LD_VAR 0 2
19356: PPUSH
19357: CALL_OW 290
// end ;
19361: LD_VAR 0 3
19365: RET
// function vytvor_tank ( Zbran ) ; begin
19366: LD_INT 0
19368: PPUSH
// UC_Side = side_Ru ;
19369: LD_ADDR_OWVAR 20
19373: PUSH
19374: LD_EXP 2
19378: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
19379: LD_ADDR_OWVAR 21
19383: PUSH
19384: LD_INT 3
19386: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
19387: LD_ADDR_OWVAR 37
19391: PUSH
19392: LD_INT 21
19394: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
19395: LD_ADDR_OWVAR 38
19399: PUSH
19400: LD_INT 1
19402: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
19403: LD_ADDR_OWVAR 39
19407: PUSH
19408: LD_INT 1
19410: ST_TO_ADDR
// VC_Weapon = Zbran ;
19411: LD_ADDR_OWVAR 40
19415: PUSH
19416: LD_VAR 0 1
19420: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 70 , 90 ) ;
19421: LD_ADDR_OWVAR 41
19425: PUSH
19426: LD_INT 70
19428: PPUSH
19429: LD_INT 90
19431: PPUSH
19432: CALL_OW 12
19436: ST_TO_ADDR
// Result = CreateVehicle ;
19437: LD_ADDR_VAR 0 2
19441: PUSH
19442: CALL_OW 45
19446: ST_TO_ADDR
// end ;
19447: LD_VAR 0 2
19451: RET
// function arabska_zakladna_kaput ; begin
19452: LD_INT 0
19454: PPUSH
// Wait ( 0 0$3.5 ) ;
19455: LD_INT 122
19457: PPUSH
19458: CALL_OW 67
// SetAttitude ( side_Ru , side_Ar , ATT_NEUTRAL , true ) ;
19462: LD_EXP 2
19466: PPUSH
19467: LD_EXP 3
19471: PPUSH
19472: LD_INT 0
19474: PPUSH
19475: LD_INT 1
19477: PPUSH
19478: CALL_OW 80
// disable ( 31 ) ;
19482: LD_INT 31
19484: DISABLE_MARKED
// DialogueOn ;
19485: CALL_OW 6
// dialog_SurrenderArabians ;
19489: CALL 5533 0 0
// DialogueOff ;
19493: CALL_OW 7
// ChangeMissionObjectives ( MAttOut ) ;
19497: LD_STRING MAttOut
19499: PPUSH
19500: CALL_OW 337
// if LegionOffer_Accepted or LegionFugit_Accepted then
19504: LD_EXP 59
19508: PUSH
19509: LD_EXP 60
19513: OR
19514: IFFALSE 19591
// begin if LegieZnicena then
19516: LD_EXP 67
19520: IFFALSE 19528
// begin vyhral ;
19522: CALL 2051 0 0
// exit ;
19526: GO 19595
// end ; LegieMamZnicit = true ;
19528: LD_ADDR_EXP 66
19532: PUSH
19533: LD_INT 1
19535: ST_TO_ADDR
// if UnitFilter ( Uprchlici , [ [ F_ALIVE ] ] ) then
19536: LD_EXP 61
19540: PPUSH
19541: LD_INT 51
19543: PUSH
19544: EMPTY
19545: LIST
19546: PUSH
19547: EMPTY
19548: LIST
19549: PPUSH
19550: CALL_OW 72
19554: IFFALSE 19586
// begin DialogueOn ;
19556: CALL_OW 6
// dialog_LegionLeave ;
19560: CALL 5157 0 0
// DialogueOff ;
19564: CALL_OW 7
// SetSide ( Uprchlici , side_Upr ) ;
19568: LD_EXP 61
19572: PPUSH
19573: LD_EXP 5
19577: PPUSH
19578: CALL_OW 235
// uprchlici_zacnete_odchazet ;
19582: CALL 10658 0 0
// end ; enable ( 21 ) ;
19586: LD_INT 21
19588: ENABLE_MARKED
// end else
19589: GO 19595
// begin vyhral ;
19591: CALL 2051 0 0
// end ; end ;
19595: LD_VAR 0 1
19599: RET
// function legie_zakladna_kaput ; begin
19600: LD_INT 0
19602: PPUSH
// SetAttitude ( side_Le , side_Ru , ATT_NEUTRAL , true ) ;
19603: LD_EXP 4
19607: PPUSH
19608: LD_EXP 2
19612: PPUSH
19613: LD_INT 0
19615: PPUSH
19616: LD_INT 1
19618: PPUSH
19619: CALL_OW 80
// SetAttitude ( side_Upr , side_Ru , ATT_NEUTRAL , true ) ;
19623: LD_EXP 5
19627: PPUSH
19628: LD_EXP 2
19632: PPUSH
19633: LD_INT 0
19635: PPUSH
19636: LD_INT 1
19638: PPUSH
19639: CALL_OW 80
// ChangeMissionObjectives ( MLegOut ) ;
19643: LD_STRING MLegOut
19645: PPUSH
19646: CALL_OW 337
// if ArabiZniceni then
19650: LD_EXP 65
19654: IFFALSE 19660
// vyhral ;
19656: CALL 2051 0 0
// end ;
19660: LD_VAR 0 1
19664: RET
// function kontrola_arabska_zakladna ; var Domy , Lidi ; begin
19665: LD_INT 0
19667: PPUSH
19668: PPUSH
19669: PPUSH
// if ArabiZniceni then
19670: LD_EXP 65
19674: IFFALSE 19678
// exit ;
19676: GO 19820
// Domy = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
19678: LD_ADDR_VAR 0 2
19682: PUSH
19683: LD_INT 22
19685: PUSH
19686: LD_EXP 3
19690: PUSH
19691: EMPTY
19692: LIST
19693: LIST
19694: PUSH
19695: LD_INT 52
19697: PUSH
19698: EMPTY
19699: LIST
19700: PUSH
19701: LD_INT 50
19703: PUSH
19704: EMPTY
19705: LIST
19706: PUSH
19707: LD_INT 21
19709: PUSH
19710: LD_INT 3
19712: PUSH
19713: EMPTY
19714: LIST
19715: LIST
19716: PUSH
19717: EMPTY
19718: LIST
19719: LIST
19720: LIST
19721: LIST
19722: PPUSH
19723: CALL_OW 69
19727: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ar ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
19728: LD_ADDR_VAR 0 3
19732: PUSH
19733: LD_INT 22
19735: PUSH
19736: LD_EXP 3
19740: PUSH
19741: EMPTY
19742: LIST
19743: LIST
19744: PUSH
19745: LD_INT 52
19747: PUSH
19748: EMPTY
19749: LIST
19750: PUSH
19751: LD_INT 50
19753: PUSH
19754: EMPTY
19755: LIST
19756: PUSH
19757: LD_INT 21
19759: PUSH
19760: LD_INT 1
19762: PUSH
19763: EMPTY
19764: LIST
19765: LIST
19766: PUSH
19767: EMPTY
19768: LIST
19769: LIST
19770: LIST
19771: LIST
19772: PPUSH
19773: CALL_OW 69
19777: ST_TO_ADDR
// if not obsahuje_dulezitou_budovu ( Domy ) and ( Lidi < dif_ArabiLidiVzdajSe [ Difficulty ] ) then
19778: LD_VAR 0 2
19782: PPUSH
19783: CALL 21635 0 1
19787: NOT
19788: PUSH
19789: LD_VAR 0 3
19793: PUSH
19794: LD_EXP 56
19798: PUSH
19799: LD_OWVAR 67
19803: ARRAY
19804: LESS
19805: AND
19806: IFFALSE 19820
// begin ArabiZniceni = true ;
19808: LD_ADDR_EXP 65
19812: PUSH
19813: LD_INT 1
19815: ST_TO_ADDR
// arabska_zakladna_kaput ;
19816: CALL 19452 0 0
// end ; end ;
19820: LD_VAR 0 1
19824: RET
// function kontrola_legie_zakladna ; var Domy , Lidi ; begin
19825: LD_INT 0
19827: PPUSH
19828: PPUSH
19829: PPUSH
// if LegieZnicena then
19830: LD_EXP 67
19834: IFFALSE 19838
// exit ;
19836: GO 20061
// Domy = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Upr ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_BUILDING ] ] ) ;
19838: LD_ADDR_VAR 0 2
19842: PUSH
19843: LD_INT 22
19845: PUSH
19846: LD_EXP 4
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: PUSH
19855: LD_INT 50
19857: PUSH
19858: EMPTY
19859: LIST
19860: PUSH
19861: LD_INT 52
19863: PUSH
19864: EMPTY
19865: LIST
19866: PUSH
19867: LD_INT 21
19869: PUSH
19870: LD_INT 3
19872: PUSH
19873: EMPTY
19874: LIST
19875: LIST
19876: PUSH
19877: EMPTY
19878: LIST
19879: LIST
19880: LIST
19881: LIST
19882: PPUSH
19883: CALL_OW 69
19887: PUSH
19888: LD_INT 22
19890: PUSH
19891: LD_EXP 5
19895: PUSH
19896: EMPTY
19897: LIST
19898: LIST
19899: PUSH
19900: LD_INT 50
19902: PUSH
19903: EMPTY
19904: LIST
19905: PUSH
19906: LD_INT 52
19908: PUSH
19909: EMPTY
19910: LIST
19911: PUSH
19912: LD_INT 21
19914: PUSH
19915: LD_INT 3
19917: PUSH
19918: EMPTY
19919: LIST
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: LIST
19926: LIST
19927: PPUSH
19928: CALL_OW 69
19932: UNION
19933: ST_TO_ADDR
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Le ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] ] ) union FilterAllUnits ( [ [ F_SIDE , side_Upr ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
19934: LD_ADDR_VAR 0 3
19938: PUSH
19939: LD_INT 22
19941: PUSH
19942: LD_EXP 4
19946: PUSH
19947: EMPTY
19948: LIST
19949: LIST
19950: PUSH
19951: LD_INT 50
19953: PUSH
19954: EMPTY
19955: LIST
19956: PUSH
19957: LD_INT 52
19959: PUSH
19960: EMPTY
19961: LIST
19962: PUSH
19963: LD_INT 21
19965: PUSH
19966: LD_INT 1
19968: PUSH
19969: EMPTY
19970: LIST
19971: LIST
19972: PUSH
19973: EMPTY
19974: LIST
19975: LIST
19976: LIST
19977: LIST
19978: PPUSH
19979: CALL_OW 69
19983: PUSH
19984: LD_INT 22
19986: PUSH
19987: LD_EXP 5
19991: PUSH
19992: EMPTY
19993: LIST
19994: LIST
19995: PUSH
19996: LD_INT 50
19998: PUSH
19999: EMPTY
20000: LIST
20001: PUSH
20002: LD_INT 52
20004: PUSH
20005: EMPTY
20006: LIST
20007: PUSH
20008: LD_INT 21
20010: PUSH
20011: LD_INT 1
20013: PUSH
20014: EMPTY
20015: LIST
20016: LIST
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: LIST
20022: LIST
20023: PPUSH
20024: CALL_OW 69
20028: UNION
20029: ST_TO_ADDR
// if not obsahuje_dulezitou_budovu ( Domy ) and not Lidi then
20030: LD_VAR 0 2
20034: PPUSH
20035: CALL 21635 0 1
20039: NOT
20040: PUSH
20041: LD_VAR 0 3
20045: NOT
20046: AND
20047: IFFALSE 20061
// begin LegieZnicena = true ;
20049: LD_ADDR_EXP 67
20053: PUSH
20054: LD_INT 1
20056: ST_TO_ADDR
// legie_zakladna_kaput ;
20057: CALL 19600 0 0
// end ; end ;
20061: LD_VAR 0 1
20065: RET
// export function rusove_UnitDestroyed ( Un ) ; begin
20066: LD_INT 0
20068: PPUSH
// if Un = Burlak then
20069: LD_VAR 0 1
20073: PUSH
20074: LD_EXP 6
20078: EQUAL
20079: IFFALSE 20090
// begin YouLost ( Burlak ) ;
20081: LD_STRING Burlak
20083: PPUSH
20084: CALL_OW 104
// exit ;
20088: GO 20124
// end ; if Un in Rusove then
20090: LD_VAR 0 1
20094: PUSH
20095: LD_EXP 39
20099: IN
20100: IFFALSE 20116
// MenLost = MenLost + 1 ;
20102: LD_ADDR_EXP 69
20106: PUSH
20107: LD_EXP 69
20111: PUSH
20112: LD_INT 1
20114: PLUS
20115: ST_TO_ADDR
// kontrola_arabska_zakladna ;
20116: CALL 19665 0 0
// kontrola_legie_zakladna ;
20120: CALL 19825 0 0
// end ;
20124: LD_VAR 0 2
20128: RET
// export function rusove_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
20129: LD_INT 0
20131: PPUSH
// if OrigSide = side_Ar then
20132: LD_VAR 0 2
20136: PUSH
20137: LD_EXP 3
20141: EQUAL
20142: IFFALSE 20148
// kontrola_arabska_zakladna ;
20144: CALL 19665 0 0
// if OrigSide = side_Le then
20148: LD_VAR 0 2
20152: PUSH
20153: LD_EXP 4
20157: EQUAL
20158: IFFALSE 20164
// kontrola_legie_zakladna ;
20160: CALL 19825 0 0
// end ;
20164: LD_VAR 0 4
20168: RET
// export function rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
20169: LD_INT 0
20171: PPUSH
// if OrigSide = side_Ru then
20172: LD_VAR 0 3
20176: PUSH
20177: LD_EXP 2
20181: EQUAL
20182: IFFALSE 20188
// kontrola_arabska_zakladna ;
20184: CALL 19665 0 0
// if Masha = VehOld then
20188: LD_EXP 25
20192: PUSH
20193: LD_VAR 0 2
20197: EQUAL
20198: IFFALSE 20210
// Masha = VehNew ;
20200: LD_ADDR_EXP 25
20204: PUSH
20205: LD_VAR 0 1
20209: ST_TO_ADDR
// end ;
20210: LD_VAR 0 5
20214: RET
// every 0 0$10 marked 21 do
20215: GO 20217
20217: DISABLE
// begin Wait ( Rand ( 0 0$15 , 0 0$35 ) ) ;
20218: LD_INT 525
20220: PPUSH
20221: LD_INT 1225
20223: PPUSH
20224: CALL_OW 12
20228: PPUSH
20229: CALL_OW 67
// DialogueOn ;
20233: CALL_OW 6
// dialog_LegionSpy ;
20237: CALL 5235 0 0
// if LegionOffer_Heike then
20241: LD_EXP 58
20245: IFFALSE 20253
// dialog_LegionChallengeHeike else
20247: CALL 5301 0 0
20251: GO 20257
// dialog_LegionChallengeFarmer ;
20253: CALL 5363 0 0
// ChangeMissionObjectives ( MLeg ) ;
20257: LD_STRING MLeg
20259: PPUSH
20260: CALL_OW 337
// SetAttitude ( side_Ru , side_Le , ATT_ENEMY , true ) ;
20264: LD_EXP 2
20268: PPUSH
20269: LD_EXP 4
20273: PPUSH
20274: LD_INT 2
20276: PPUSH
20277: LD_INT 1
20279: PPUSH
20280: CALL_OW 80
// SetAttitude ( side_Ru , side_Upr , ATT_ENEMY , true ) ;
20284: LD_EXP 2
20288: PPUSH
20289: LD_EXP 5
20293: PPUSH
20294: LD_INT 2
20296: PPUSH
20297: LD_INT 1
20299: PPUSH
20300: CALL_OW 80
// DialogueOff ;
20304: CALL_OW 7
// end ;
20308: END
// every 4 4$30 do
20309: GO 20311
20311: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
20312: LD_INT 35
20314: PPUSH
20315: LD_INT 4200
20317: PPUSH
20318: CALL_OW 12
20322: PPUSH
20323: CALL_OW 67
// DialogueOn ;
20327: CALL_OW 6
// dialog_AmAttack ;
20331: CALL 4669 0 0
// ChangeMissionObjectives ( MAttack ) ;
20335: LD_STRING MAttack
20337: PPUSH
20338: CALL_OW 337
// DialogueOff ;
20342: CALL_OW 7
// end ;
20346: END
// every 9 9$0 do
20347: GO 20349
20349: DISABLE
// begin Wait ( Rand ( 0 0$1 , 4 4$0 ) ) ;
20350: LD_INT 35
20352: PPUSH
20353: LD_INT 8400
20355: PPUSH
20356: CALL_OW 12
20360: PPUSH
20361: CALL_OW 67
// if not BehemothBuilt then
20365: LD_EXP 68
20369: NOT
20370: IFFALSE 20403
// begin DialogueOn ;
20372: CALL_OW 6
// if BehemothSeen then
20376: LD_EXP 36
20380: IFFALSE 20388
// dialog_BehemothTechno1 else
20382: CALL 5641 0 0
20386: GO 20392
// dialog_BehemothTechno2 ;
20388: CALL 5776 0 0
// ChangeMissionObjectives ( MBeh ) ;
20392: LD_STRING MBeh
20394: PPUSH
20395: CALL_OW 337
// DialogueOff ;
20399: CALL_OW 7
// end ; end ;
20403: END
// export function rusove_BuildingComplete ( Build ) ; begin
20404: LD_INT 0
20406: PPUSH
// if GetSide ( Build ) = side_Ru then
20407: LD_VAR 0 1
20411: PPUSH
20412: CALL_OW 255
20416: PUSH
20417: LD_EXP 2
20421: EQUAL
20422: IFFALSE 20447
// begin if GetBType ( Build ) = B_SIBERITE_MINE then
20424: LD_VAR 0 1
20428: PPUSH
20429: CALL_OW 266
20433: PUSH
20434: LD_INT 30
20436: EQUAL
20437: IFFALSE 20447
// RusMaSiberit = true ;
20439: LD_ADDR_EXP 63
20443: PUSH
20444: LD_INT 1
20446: ST_TO_ADDR
// end ; end ;
20447: LD_VAR 0 2
20451: RET
// export function rusove_BehemothConstructed ( Un ) ; begin
20452: LD_INT 0
20454: PPUSH
// if ( GetSide ( Un ) = side_Ru ) and not BehemothBuilt then
20455: LD_VAR 0 1
20459: PPUSH
20460: CALL_OW 255
20464: PUSH
20465: LD_EXP 2
20469: EQUAL
20470: PUSH
20471: LD_EXP 68
20475: NOT
20476: AND
20477: IFFALSE 20506
// begin BehemothBuilt = true ;
20479: LD_ADDR_EXP 68
20483: PUSH
20484: LD_INT 1
20486: ST_TO_ADDR
// DialogueOn ;
20487: CALL_OW 6
// dialog_BehemothComplete ;
20491: CALL 5880 0 0
// ChangeMissionObjectives ( MBehOut ) ;
20495: LD_STRING MBehOut
20497: PPUSH
20498: CALL_OW 337
// DialogueOff ;
20502: CALL_OW 7
// end ; end ;
20506: LD_VAR 0 2
20510: RET
// export function rusove_SibDepositContaminated ( Un , X , Y ) ; begin
20511: LD_INT 0
20513: PPUSH
// RusMaOtraveno = RusMaOtraveno + 1 ;
20514: LD_ADDR_EXP 64
20518: PUSH
20519: LD_EXP 64
20523: PUSH
20524: LD_INT 1
20526: PLUS
20527: ST_TO_ADDR
// if RusMaOtraveno = 1 then
20528: LD_EXP 64
20532: PUSH
20533: LD_INT 1
20535: EQUAL
20536: IFFALSE 20565
// begin Wait ( Rand ( 0 0$1 , 0 0$10 ) ) ;
20538: LD_INT 35
20540: PPUSH
20541: LD_INT 350
20543: PPUSH
20544: CALL_OW 12
20548: PPUSH
20549: CALL_OW 67
// DialogueOn ;
20553: CALL_OW 6
// dialog_Contam ;
20557: CALL 5431 0 0
// DialogueOff ;
20561: CALL_OW 7
// end ; end ; end_of_file
20565: LD_VAR 0 4
20569: RET
// on Contact ( Side1 , Side2 ) do begin legion_Contact ( Side1 , Side2 ) ;
20570: LD_VAR 0 1
20574: PPUSH
20575: LD_VAR 0 2
20579: PPUSH
20580: CALL 11170 0 2
// end ;
20584: PPOPN 2
20586: END
// on UnitDestroyed ( Un ) do begin rusove_UnitDestroyed ( Un ) ;
20587: LD_VAR 0 1
20591: PPUSH
20592: CALL 20066 0 1
// arabi_UnitDestroyed ( Un ) ;
20596: LD_VAR 0 1
20600: PPUSH
20601: CALL 14071 0 1
// legion_UnitDestroyed ( Un ) ;
20605: LD_VAR 0 1
20609: PPUSH
20610: CALL 11253 0 1
// end ;
20614: PPOPN 1
20616: END
// on VehicleConstructed ( Veh , Fact ) do begin arabi_VehicleConstructed ( Veh , Fact ) ;
20617: LD_VAR 0 1
20621: PPUSH
20622: LD_VAR 0 2
20626: PPUSH
20627: CALL 14828 0 2
// legion_VehicleConstructed ( Veh , Fact ) ;
20631: LD_VAR 0 1
20635: PPUSH
20636: LD_VAR 0 2
20640: PPUSH
20641: CALL 7688 0 2
// end ;
20645: PPOPN 2
20647: END
// on BuildingComplete ( Build ) do begin rusove_BuildingComplete ( Build ) ;
20648: LD_VAR 0 1
20652: PPUSH
20653: CALL 20404 0 1
// end ;
20657: PPOPN 1
20659: END
// on SibDepositContaminated ( Un , X , Y ) do begin rusove_SibDepositContaminated ( Un , X , Y ) ;
20660: LD_VAR 0 1
20664: PPUSH
20665: LD_VAR 0 2
20669: PPUSH
20670: LD_VAR 0 3
20674: PPUSH
20675: CALL 20511 0 3
// end ;
20679: PPOPN 3
20681: END
// on SailEvent ( Event ) do begin case Event of 101 :
20682: LD_VAR 0 1
20686: PUSH
20687: LD_INT 101
20689: DOUBLE
20690: EQUAL
20691: IFTRUE 20695
20693: GO 20702
20695: POP
// event_Kontaminovano ; 103 :
20696: CALL 14029 0 0
20700: GO 20815
20702: LD_INT 103
20704: DOUBLE
20705: EQUAL
20706: IFTRUE 20710
20708: GO 20717
20710: POP
// event_DolakanaOpice ; 104 , 105 :
20711: CALL 17700 0 0
20715: GO 20815
20717: LD_INT 104
20719: DOUBLE
20720: EQUAL
20721: IFTRUE 20731
20723: LD_INT 105
20725: DOUBLE
20726: EQUAL
20727: IFTRUE 20731
20729: GO 20743
20731: POP
// event_ArabiOprava ( Event ) ; 111 :
20732: LD_VAR 0 1
20736: PPUSH
20737: CALL 18788 0 1
20741: GO 20815
20743: LD_INT 111
20745: DOUBLE
20746: EQUAL
20747: IFTRUE 20751
20749: GO 20758
20751: POP
// event_KoupeniPrisli ; 112 :
20752: CALL 9840 0 0
20756: GO 20815
20758: LD_INT 112
20760: DOUBLE
20761: EQUAL
20762: IFTRUE 20766
20764: GO 20773
20766: POP
// event_UprchliciPrisli ; 113 , 114 :
20767: CALL 10710 0 0
20771: GO 20815
20773: LD_INT 113
20775: DOUBLE
20776: EQUAL
20777: IFTRUE 20787
20779: LD_INT 114
20781: DOUBLE
20782: EQUAL
20783: IFTRUE 20787
20785: GO 20799
20787: POP
// event_LegionOprava ( Event ) ; 115 :
20788: LD_VAR 0 1
20792: PPUSH
20793: CALL 7339 0 1
20797: GO 20815
20799: LD_INT 115
20801: DOUBLE
20802: EQUAL
20803: IFTRUE 20807
20805: GO 20814
20807: POP
// event_LegionPrebarvi ; end ;
20808: CALL 10681 0 0
20812: GO 20815
20814: POP
// end ;
20815: PPOPN 1
20817: END
// on BuildingCaptured ( Build , OrigSide , Eng ) do begin rusove_BuildingCaptured ( Build , OrigSide , Eng ) ;
20818: LD_VAR 0 1
20822: PPUSH
20823: LD_VAR 0 2
20827: PPUSH
20828: LD_VAR 0 3
20832: PPUSH
20833: CALL 20129 0 3
// end ;
20837: PPOPN 3
20839: END
// on VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) do begin rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
20840: LD_VAR 0 1
20844: PPUSH
20845: LD_VAR 0 2
20849: PPUSH
20850: LD_VAR 0 3
20854: PPUSH
20855: LD_VAR 0 4
20859: PPUSH
20860: CALL 20169 0 4
// arabi_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
20864: LD_VAR 0 1
20868: PPUSH
20869: LD_VAR 0 2
20873: PPUSH
20874: LD_VAR 0 3
20878: PPUSH
20879: LD_VAR 0 4
20883: PPUSH
20884: CALL 14403 0 4
// legion_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
20888: LD_VAR 0 1
20892: PPUSH
20893: LD_VAR 0 2
20897: PPUSH
20898: LD_VAR 0 3
20902: PPUSH
20903: LD_VAR 0 4
20907: PPUSH
20908: CALL 11236 0 4
// end ;
20912: PPOPN 4
20914: END
// on BehemothConstructed ( Un ) do begin rusove_BehemothConstructed ( Un ) ;
20915: LD_VAR 0 1
20919: PPUSH
20920: CALL 20452 0 1
// end ;
20924: PPOPN 1
20926: END
// on ApemanTamed ( Ape , Sci ) do begin arabi_ApemanTamed ( Ape , Sci ) ;
20927: LD_VAR 0 1
20931: PPUSH
20932: LD_VAR 0 2
20936: PPUSH
20937: CALL 17034 0 2
// end ;
20941: PPOPN 2
20943: END
// on EnterBuilding ( Building , Un ) do begin arabi_EnterBuilding ( Building , Un ) ;
20944: LD_VAR 0 1
20948: PPUSH
20949: LD_VAR 0 2
20953: PPUSH
20954: CALL 14760 0 2
// end ;
20958: PPOPN 2
20960: END
// on McAttackDone ( McId , Un ) do begin arabi_McAttackDone ( McId , Un ) ;
20961: LD_VAR 0 1
20965: PPUSH
20966: LD_VAR 0 2
20970: PPUSH
20971: CALL 16360 0 2
// end ;
20975: PPOPN 2
20977: END
// every 1 1$59 do
20978: GO 20980
20980: DISABLE
// begin RandomizeAll ;
20981: CALL_OW 11
// end ; end_of_file
20985: END
// export function sbirej_bedny ( Jednotky , Area ) ; var I , Ok , Kdo , Bedny , Delka , X , Y ; begin
20986: LD_INT 0
20988: PPUSH
20989: PPUSH
20990: PPUSH
20991: PPUSH
20992: PPUSH
20993: PPUSH
20994: PPUSH
20995: PPUSH
// Ok = false ;
20996: LD_ADDR_VAR 0 5
21000: PUSH
21001: LD_INT 0
21003: ST_TO_ADDR
// for Kdo in Jednotky do
21004: LD_ADDR_VAR 0 6
21008: PUSH
21009: LD_VAR 0 1
21013: PUSH
21014: FOR_IN
21015: IFFALSE 21040
// if IsOk ( Kdo ) then
21017: LD_VAR 0 6
21021: PPUSH
21022: CALL_OW 302
21026: IFFALSE 21038
// begin Ok = true ;
21028: LD_ADDR_VAR 0 5
21032: PUSH
21033: LD_INT 1
21035: ST_TO_ADDR
// break ;
21036: GO 21040
// end ;
21038: GO 21014
21040: POP
21041: POP
// if not Ok then
21042: LD_VAR 0 5
21046: NOT
21047: IFFALSE 21051
// exit ;
21049: GO 21211
// Bedny = GetListOfCratesInArea ( Area ) ;
21051: LD_ADDR_VAR 0 7
21055: PUSH
21056: LD_VAR 0 2
21060: PPUSH
21061: CALL_OW 435
21065: ST_TO_ADDR
// if not Bedny then
21066: LD_VAR 0 7
21070: NOT
21071: IFFALSE 21075
// exit ;
21073: GO 21211
// Delka = Bedny div 2 ;
21075: LD_ADDR_VAR 0 8
21079: PUSH
21080: LD_VAR 0 7
21084: PUSH
21085: LD_INT 2
21087: DIV
21088: ST_TO_ADDR
// for I = 1 to Delka do
21089: LD_ADDR_VAR 0 4
21093: PUSH
21094: DOUBLE
21095: LD_INT 1
21097: DEC
21098: ST_TO_ADDR
21099: LD_VAR 0 8
21103: PUSH
21104: FOR_TO
21105: IFFALSE 21209
// begin X = Bedny [ 2 * I - 1 ] ;
21107: LD_ADDR_VAR 0 9
21111: PUSH
21112: LD_VAR 0 7
21116: PUSH
21117: LD_INT 2
21119: PUSH
21120: LD_VAR 0 4
21124: MUL
21125: PUSH
21126: LD_INT 1
21128: MINUS
21129: ARRAY
21130: ST_TO_ADDR
// Y = Bedny [ 2 * I ] ;
21131: LD_ADDR_VAR 0 10
21135: PUSH
21136: LD_VAR 0 7
21140: PUSH
21141: LD_INT 2
21143: PUSH
21144: LD_VAR 0 4
21148: MUL
21149: ARRAY
21150: ST_TO_ADDR
// for Kdo in Jednotky do
21151: LD_ADDR_VAR 0 6
21155: PUSH
21156: LD_VAR 0 1
21160: PUSH
21161: FOR_IN
21162: IFFALSE 21205
// if IsOk ( Kdo ) and Prob ( 50 ) then
21164: LD_VAR 0 6
21168: PPUSH
21169: CALL_OW 302
21173: PUSH
21174: LD_INT 50
21176: PPUSH
21177: CALL_OW 13
21181: AND
21182: IFFALSE 21203
// AddComCollect ( Kdo , X , Y ) ;
21184: LD_VAR 0 6
21188: PPUSH
21189: LD_VAR 0 9
21193: PPUSH
21194: LD_VAR 0 10
21198: PPUSH
21199: CALL_OW 177
21203: GO 21161
21205: POP
21206: POP
// end ;
21207: GO 21104
21209: POP
21210: POP
// end ;
21211: LD_VAR 0 3
21215: RET
// export function opravuj_budovy ( Jednotky , Area , Side ) ; var Budovy , Opravit , I , Kde ; begin
21216: LD_INT 0
21218: PPUSH
21219: PPUSH
21220: PPUSH
21221: PPUSH
21222: PPUSH
// Budovy = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_BUILDING ] , [ F_SIDE , Side ] ] ) ;
21223: LD_ADDR_VAR 0 5
21227: PUSH
21228: LD_VAR 0 2
21232: PPUSH
21233: LD_INT 21
21235: PUSH
21236: LD_INT 3
21238: PUSH
21239: EMPTY
21240: LIST
21241: LIST
21242: PUSH
21243: LD_INT 22
21245: PUSH
21246: LD_VAR 0 3
21250: PUSH
21251: EMPTY
21252: LIST
21253: LIST
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: PPUSH
21259: CALL_OW 70
21263: ST_TO_ADDR
// Opravit = [ ] ;
21264: LD_ADDR_VAR 0 6
21268: PUSH
21269: EMPTY
21270: ST_TO_ADDR
// for I in Budovy do
21271: LD_ADDR_VAR 0 7
21275: PUSH
21276: LD_VAR 0 5
21280: PUSH
21281: FOR_IN
21282: IFFALSE 21320
// if GetLives ( I ) < HRANICE_ZDRAVI then
21284: LD_VAR 0 7
21288: PPUSH
21289: CALL_OW 256
21293: PUSH
21294: LD_INT 1000
21296: LESS
21297: IFFALSE 21318
// Opravit = Opravit union [ I ] ;
21299: LD_ADDR_VAR 0 6
21303: PUSH
21304: LD_VAR 0 6
21308: PUSH
21309: LD_VAR 0 7
21313: PUSH
21314: EMPTY
21315: LIST
21316: UNION
21317: ST_TO_ADDR
21318: GO 21281
21320: POP
21321: POP
// for I in Opravit do
21322: LD_ADDR_VAR 0 7
21326: PUSH
21327: LD_VAR 0 6
21331: PUSH
21332: FOR_IN
21333: IFFALSE 21351
// AddComRepairBuilding ( Jednotky , I ) ;
21335: LD_VAR 0 1
21339: PPUSH
21340: LD_VAR 0 7
21344: PPUSH
21345: CALL_OW 190
21349: GO 21332
21351: POP
21352: POP
// end ;
21353: LD_VAR 0 4
21357: RET
// export function min ( A , B ) ; begin
21358: LD_INT 0
21360: PPUSH
// if A < B then
21361: LD_VAR 0 1
21365: PUSH
21366: LD_VAR 0 2
21370: LESS
21371: IFFALSE 21385
// Result = A else
21373: LD_ADDR_VAR 0 3
21377: PUSH
21378: LD_VAR 0 1
21382: ST_TO_ADDR
21383: GO 21395
// Result = B ;
21385: LD_ADDR_VAR 0 3
21389: PUSH
21390: LD_VAR 0 2
21394: ST_TO_ADDR
// end ;
21395: LD_VAR 0 3
21399: RET
// export function vidi_strana_cloveka ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
21400: LD_INT 0
21402: PPUSH
21403: PPUSH
21404: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
21405: LD_ADDR_VAR 0 4
21409: PUSH
21410: LD_INT 22
21412: PUSH
21413: LD_VAR 0 2
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: PUSH
21422: LD_INT 21
21424: PUSH
21425: LD_INT 1
21427: PUSH
21428: EMPTY
21429: LIST
21430: LIST
21431: PUSH
21432: EMPTY
21433: LIST
21434: LIST
21435: PPUSH
21436: CALL_OW 69
21440: ST_TO_ADDR
// for Jednotka in KohoJednotky do
21441: LD_ADDR_VAR 0 5
21445: PUSH
21446: LD_VAR 0 4
21450: PUSH
21451: FOR_IN
21452: IFFALSE 21484
// if See ( Kdo , Jednotka ) then
21454: LD_VAR 0 1
21458: PPUSH
21459: LD_VAR 0 5
21463: PPUSH
21464: CALL_OW 292
21468: IFFALSE 21482
// begin Result = true ;
21470: LD_ADDR_VAR 0 3
21474: PUSH
21475: LD_INT 1
21477: ST_TO_ADDR
// exit ;
21478: POP
21479: POP
21480: GO 21494
// end ;
21482: GO 21451
21484: POP
21485: POP
// Result = false ;
21486: LD_ADDR_VAR 0 3
21490: PUSH
21491: LD_INT 0
21493: ST_TO_ADDR
// end ;
21494: LD_VAR 0 3
21498: RET
// export function nahoda_seznam ( Seznam ) ; begin
21499: LD_INT 0
21501: PPUSH
// if Seznam then
21502: LD_VAR 0 1
21506: IFFALSE 21534
// Result = Seznam [ Rand ( 1 , Seznam ) ] else
21508: LD_ADDR_VAR 0 2
21512: PUSH
21513: LD_VAR 0 1
21517: PUSH
21518: LD_INT 1
21520: PPUSH
21521: LD_VAR 0 1
21525: PPUSH
21526: CALL_OW 12
21530: ARRAY
21531: ST_TO_ADDR
21532: GO 21542
// Result = 0 ;
21534: LD_ADDR_VAR 0 2
21538: PUSH
21539: LD_INT 0
21541: ST_TO_ADDR
// end ;
21542: LD_VAR 0 2
21546: RET
// export function vidi_strana_stranu ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
21547: LD_INT 0
21549: PPUSH
21550: PPUSH
21551: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
21552: LD_ADDR_VAR 0 4
21556: PUSH
21557: LD_INT 22
21559: PUSH
21560: LD_VAR 0 2
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: PUSH
21569: EMPTY
21570: LIST
21571: PPUSH
21572: CALL_OW 69
21576: ST_TO_ADDR
// for Jednotka in KohoJednotky do
21577: LD_ADDR_VAR 0 5
21581: PUSH
21582: LD_VAR 0 4
21586: PUSH
21587: FOR_IN
21588: IFFALSE 21620
// if See ( Kdo , Jednotka ) then
21590: LD_VAR 0 1
21594: PPUSH
21595: LD_VAR 0 5
21599: PPUSH
21600: CALL_OW 292
21604: IFFALSE 21618
// begin Result = true ;
21606: LD_ADDR_VAR 0 3
21610: PUSH
21611: LD_INT 1
21613: ST_TO_ADDR
// exit ;
21614: POP
21615: POP
21616: GO 21630
// end ;
21618: GO 21587
21620: POP
21621: POP
// Result = false ;
21622: LD_ADDR_VAR 0 3
21626: PUSH
21627: LD_INT 0
21629: ST_TO_ADDR
// end ;
21630: LD_VAR 0 3
21634: RET
// export function obsahuje_dulezitou_budovu ( List ) ; var Dulezite , I ; begin
21635: LD_INT 0
21637: PPUSH
21638: PPUSH
21639: PPUSH
// Dulezite = [ B_DEPOT , B_WAREHOUSE ] ;
21640: LD_ADDR_VAR 0 3
21644: PUSH
21645: LD_INT 0
21647: PUSH
21648: LD_INT 1
21650: PUSH
21651: EMPTY
21652: LIST
21653: LIST
21654: ST_TO_ADDR
// Result = true ;
21655: LD_ADDR_VAR 0 2
21659: PUSH
21660: LD_INT 1
21662: ST_TO_ADDR
// for I in Dulezite do
21663: LD_ADDR_VAR 0 4
21667: PUSH
21668: LD_VAR 0 3
21672: PUSH
21673: FOR_IN
21674: IFFALSE 21719
// if UnitFilter ( List , [ [ F_TYPE , UNIT_BUILDING ] , [ F_BTYPE , I ] ] ) then
21676: LD_VAR 0 1
21680: PPUSH
21681: LD_INT 21
21683: PUSH
21684: LD_INT 3
21686: PUSH
21687: EMPTY
21688: LIST
21689: LIST
21690: PUSH
21691: LD_INT 30
21693: PUSH
21694: LD_VAR 0 4
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: PUSH
21703: EMPTY
21704: LIST
21705: LIST
21706: PPUSH
21707: CALL_OW 72
21711: IFFALSE 21717
// exit ;
21713: POP
21714: POP
21715: GO 21729
21717: GO 21673
21719: POP
21720: POP
// Result = false ;
21721: LD_ADDR_VAR 0 2
21725: PUSH
21726: LD_INT 0
21728: ST_TO_ADDR
// end ;
21729: LD_VAR 0 2
21733: RET
// export function opravuj_auta ( List , Event , Area , Side , Ignore ) ; var Auta , Opravit , I , Kde , Mech ; begin
21734: LD_INT 0
21736: PPUSH
21737: PPUSH
21738: PPUSH
21739: PPUSH
21740: PPUSH
21741: PPUSH
// Result = [ ] ;
21742: LD_ADDR_VAR 0 6
21746: PUSH
21747: EMPTY
21748: ST_TO_ADDR
// Mech = 0 ;
21749: LD_ADDR_VAR 0 11
21753: PUSH
21754: LD_INT 0
21756: ST_TO_ADDR
// for I in List do
21757: LD_ADDR_VAR 0 9
21761: PUSH
21762: LD_VAR 0 1
21766: PUSH
21767: FOR_IN
21768: IFFALSE 21795
// if IsOk ( I ) then
21770: LD_VAR 0 9
21774: PPUSH
21775: CALL_OW 302
21779: IFFALSE 21793
// begin Mech = I ;
21781: LD_ADDR_VAR 0 11
21785: PUSH
21786: LD_VAR 0 9
21790: ST_TO_ADDR
// break ;
21791: GO 21795
// end ;
21793: GO 21767
21795: POP
21796: POP
// if not Mech then
21797: LD_VAR 0 11
21801: NOT
21802: IFFALSE 21806
// exit ;
21804: GO 22031
// Auta = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_SIDE , Side ] ] ) diff Ignore ;
21806: LD_ADDR_VAR 0 7
21810: PUSH
21811: LD_VAR 0 3
21815: PPUSH
21816: LD_INT 21
21818: PUSH
21819: LD_INT 2
21821: PUSH
21822: EMPTY
21823: LIST
21824: LIST
21825: PUSH
21826: LD_INT 22
21828: PUSH
21829: LD_VAR 0 4
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PUSH
21838: EMPTY
21839: LIST
21840: LIST
21841: PPUSH
21842: CALL_OW 70
21846: PUSH
21847: LD_VAR 0 5
21851: DIFF
21852: ST_TO_ADDR
// Opravit = [ ] ;
21853: LD_ADDR_VAR 0 8
21857: PUSH
21858: EMPTY
21859: ST_TO_ADDR
// for I in Auta do
21860: LD_ADDR_VAR 0 9
21864: PUSH
21865: LD_VAR 0 7
21869: PUSH
21870: FOR_IN
21871: IFFALSE 21909
// if GetLives ( I ) < HRANICE_ZDRAVI then
21873: LD_VAR 0 9
21877: PPUSH
21878: CALL_OW 256
21882: PUSH
21883: LD_INT 1000
21885: LESS
21886: IFFALSE 21907
// Opravit = Opravit union [ I ] ;
21888: LD_ADDR_VAR 0 8
21892: PUSH
21893: LD_VAR 0 8
21897: PUSH
21898: LD_VAR 0 9
21902: PUSH
21903: EMPTY
21904: LIST
21905: UNION
21906: ST_TO_ADDR
21907: GO 21870
21909: POP
21910: POP
// if Opravit then
21911: LD_VAR 0 8
21915: IFFALSE 22031
// begin Kde = IsInUnit ( Mech ) ;
21917: LD_ADDR_VAR 0 10
21921: PUSH
21922: LD_VAR 0 11
21926: PPUSH
21927: CALL_OW 310
21931: ST_TO_ADDR
// if Kde then
21932: LD_VAR 0 10
21936: IFFALSE 21973
// if GetType ( Kde ) = UNIT_BUILDING then
21938: LD_VAR 0 10
21942: PPUSH
21943: CALL_OW 247
21947: PUSH
21948: LD_INT 3
21950: EQUAL
21951: IFFALSE 21964
// ComExitBuilding ( Mech ) else
21953: LD_VAR 0 11
21957: PPUSH
21958: CALL_OW 122
21962: GO 21973
// ComExitVehicle ( Mech ) ;
21964: LD_VAR 0 11
21968: PPUSH
21969: CALL_OW 121
// for I in Opravit do
21973: LD_ADDR_VAR 0 9
21977: PUSH
21978: LD_VAR 0 8
21982: PUSH
21983: FOR_IN
21984: IFFALSE 22002
// AddComRepairVehicle ( Mech , I ) ;
21986: LD_VAR 0 11
21990: PPUSH
21991: LD_VAR 0 9
21995: PPUSH
21996: CALL_OW 189
22000: GO 21983
22002: POP
22003: POP
// AddComSailEvent ( Mech , Event ) ;
22004: LD_VAR 0 11
22008: PPUSH
22009: LD_VAR 0 2
22013: PPUSH
22014: CALL_OW 224
// Result = [ Mech ] ;
22018: LD_ADDR_VAR 0 6
22022: PUSH
22023: LD_VAR 0 11
22027: PUSH
22028: EMPTY
22029: LIST
22030: ST_TO_ADDR
// end ; end ;
22031: LD_VAR 0 6
22035: RET
// export function kuryruj_lidi ( List , Event , Area , Side ) ; var Lidi , Opravit , I , Kde , Felcar , Budova ; begin
22036: LD_INT 0
22038: PPUSH
22039: PPUSH
22040: PPUSH
22041: PPUSH
22042: PPUSH
22043: PPUSH
22044: PPUSH
// Result = [ ] ;
22045: LD_ADDR_VAR 0 5
22049: PUSH
22050: EMPTY
22051: ST_TO_ADDR
// Felcar = 0 ;
22052: LD_ADDR_VAR 0 10
22056: PUSH
22057: LD_INT 0
22059: ST_TO_ADDR
// for I in List do
22060: LD_ADDR_VAR 0 8
22064: PUSH
22065: LD_VAR 0 1
22069: PUSH
22070: FOR_IN
22071: IFFALSE 22098
// if IsOk ( I ) then
22073: LD_VAR 0 8
22077: PPUSH
22078: CALL_OW 302
22082: IFFALSE 22096
// begin Felcar = I ;
22084: LD_ADDR_VAR 0 10
22088: PUSH
22089: LD_VAR 0 8
22093: ST_TO_ADDR
// break ;
22094: GO 22098
// end ;
22096: GO 22070
22098: POP
22099: POP
// Lidi = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_HUMAN ] , [ F_SIDE , Side ] ] ) ;
22100: LD_ADDR_VAR 0 6
22104: PUSH
22105: LD_VAR 0 3
22109: PPUSH
22110: LD_INT 21
22112: PUSH
22113: LD_INT 1
22115: PUSH
22116: EMPTY
22117: LIST
22118: LIST
22119: PUSH
22120: LD_INT 22
22122: PUSH
22123: LD_VAR 0 4
22127: PUSH
22128: EMPTY
22129: LIST
22130: LIST
22131: PUSH
22132: EMPTY
22133: LIST
22134: LIST
22135: PPUSH
22136: CALL_OW 70
22140: ST_TO_ADDR
// Opravit = [ ] ;
22141: LD_ADDR_VAR 0 7
22145: PUSH
22146: EMPTY
22147: ST_TO_ADDR
// for I in Lidi do
22148: LD_ADDR_VAR 0 8
22152: PUSH
22153: LD_VAR 0 6
22157: PUSH
22158: FOR_IN
22159: IFFALSE 22197
// if GetLives ( I ) < HRANICE_ZDRAVI then
22161: LD_VAR 0 8
22165: PPUSH
22166: CALL_OW 256
22170: PUSH
22171: LD_INT 1000
22173: LESS
22174: IFFALSE 22195
// Opravit = Opravit union [ I ] ;
22176: LD_ADDR_VAR 0 7
22180: PUSH
22181: LD_VAR 0 7
22185: PUSH
22186: LD_VAR 0 8
22190: PUSH
22191: EMPTY
22192: LIST
22193: UNION
22194: ST_TO_ADDR
22195: GO 22158
22197: POP
22198: POP
// if Opravit then
22199: LD_VAR 0 7
22203: IFFALSE 22319
// begin Kde = IsInUnit ( Felcar ) ;
22205: LD_ADDR_VAR 0 9
22209: PUSH
22210: LD_VAR 0 10
22214: PPUSH
22215: CALL_OW 310
22219: ST_TO_ADDR
// if Kde then
22220: LD_VAR 0 9
22224: IFFALSE 22261
// if GetType ( Kde ) = UNIT_BUILDING then
22226: LD_VAR 0 9
22230: PPUSH
22231: CALL_OW 247
22235: PUSH
22236: LD_INT 3
22238: EQUAL
22239: IFFALSE 22252
// ComExitBuilding ( Felcar ) else
22241: LD_VAR 0 10
22245: PPUSH
22246: CALL_OW 122
22250: GO 22261
// ComExitVehicle ( Felcar ) ;
22252: LD_VAR 0 10
22256: PPUSH
22257: CALL_OW 121
// for I in Opravit do
22261: LD_ADDR_VAR 0 8
22265: PUSH
22266: LD_VAR 0 7
22270: PUSH
22271: FOR_IN
22272: IFFALSE 22290
// AddComHeal ( Felcar , I ) ;
22274: LD_VAR 0 10
22278: PPUSH
22279: LD_VAR 0 8
22283: PPUSH
22284: CALL_OW 188
22288: GO 22271
22290: POP
22291: POP
// AddComSailEvent ( Felcar , Event ) ;
22292: LD_VAR 0 10
22296: PPUSH
22297: LD_VAR 0 2
22301: PPUSH
22302: CALL_OW 224
// Result = [ Felcar ] ;
22306: LD_ADDR_VAR 0 5
22310: PUSH
22311: LD_VAR 0 10
22315: PUSH
22316: EMPTY
22317: LIST
22318: ST_TO_ADDR
// end ; end ;
22319: LD_VAR 0 5
22323: RET
// export function bez_opic ( List ) ; var Opice ; begin
22324: LD_INT 0
22326: PPUSH
22327: PPUSH
// Opice = UnitFilter ( List , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
22328: LD_ADDR_VAR 0 3
22332: PUSH
22333: LD_VAR 0 1
22337: PPUSH
22338: LD_INT 2
22340: PUSH
22341: LD_INT 25
22343: PUSH
22344: LD_INT 12
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: PUSH
22351: LD_INT 25
22353: PUSH
22354: LD_INT 15
22356: PUSH
22357: EMPTY
22358: LIST
22359: LIST
22360: PUSH
22361: LD_INT 25
22363: PUSH
22364: LD_INT 16
22366: PUSH
22367: EMPTY
22368: LIST
22369: LIST
22370: PUSH
22371: LD_INT 25
22373: PUSH
22374: LD_INT 17
22376: PUSH
22377: EMPTY
22378: LIST
22379: LIST
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: LIST
22386: LIST
22387: PUSH
22388: EMPTY
22389: LIST
22390: PPUSH
22391: CALL_OW 72
22395: ST_TO_ADDR
// Result = List diff Opice ;
22396: LD_ADDR_VAR 0 2
22400: PUSH
22401: LD_VAR 0 1
22405: PUSH
22406: LD_VAR 0 3
22410: DIFF
22411: ST_TO_ADDR
// end ;
22412: LD_VAR 0 2
22416: RET
