// starting begin ResetFog ;
   0: CALL_OW 335
// PrepareNature ( [ 7 , 6 , 5 ] [ Difficulty ] , 3 , 3 ) ;
   4: LD_INT 7
   6: PUSH
   7: LD_INT 6
   9: PUSH
  10: LD_INT 5
  12: PUSH
  13: EMPTY
  14: LIST
  15: LIST
  16: LIST
  17: PUSH
  18: LD_OWVAR 67
  22: ARRAY
  23: PPUSH
  24: LD_INT 3
  26: PPUSH
  27: LD_INT 3
  29: PPUSH
  30: CALL 1011 0 3
// Triggers ;
  34: CALL 6971 0 0
// ScriptArabian ;
  38: CALL 2713 0 0
// LoadUnits ;
  42: CALL 1404 0 0
// LoadVehicles ;
  46: CALL 2310 0 0
// Action ;
  50: CALL 9116 0 0
// end ; end_of_file
  54: END
// export function CreateHumanWithClass ( clas , lvl ) ; var skill_com , skill_eng , skill_mech , skill_sci , bonus ; begin
  55: LD_INT 0
  57: PPUSH
  58: PPUSH
  59: PPUSH
  60: PPUSH
  61: PPUSH
  62: PPUSH
// hc_class := clas ;
  63: LD_ADDR_OWVAR 28
  67: PUSH
  68: LD_VAR 0 1
  72: ST_TO_ADDR
// skill_com := ( lvl + Rand ( - 1 , 1 ) ) ;
  73: LD_ADDR_VAR 0 4
  77: PUSH
  78: LD_VAR 0 2
  82: PUSH
  83: LD_INT 1
  85: NEG
  86: PPUSH
  87: LD_INT 1
  89: PPUSH
  90: CALL_OW 12
  94: PLUS
  95: ST_TO_ADDR
// skill_eng := ( lvl + Rand ( - 1 , 1 ) ) ;
  96: LD_ADDR_VAR 0 5
 100: PUSH
 101: LD_VAR 0 2
 105: PUSH
 106: LD_INT 1
 108: NEG
 109: PPUSH
 110: LD_INT 1
 112: PPUSH
 113: CALL_OW 12
 117: PLUS
 118: ST_TO_ADDR
// skill_mech := ( lvl + Rand ( - 1 , 1 ) ) ;
 119: LD_ADDR_VAR 0 6
 123: PUSH
 124: LD_VAR 0 2
 128: PUSH
 129: LD_INT 1
 131: NEG
 132: PPUSH
 133: LD_INT 1
 135: PPUSH
 136: CALL_OW 12
 140: PLUS
 141: ST_TO_ADDR
// skill_sci := ( lvl + Rand ( - 1 , 1 ) ) ;
 142: LD_ADDR_VAR 0 7
 146: PUSH
 147: LD_VAR 0 2
 151: PUSH
 152: LD_INT 1
 154: NEG
 155: PPUSH
 156: LD_INT 1
 158: PPUSH
 159: CALL_OW 12
 163: PLUS
 164: ST_TO_ADDR
// if clas = 1 or clas = 9 then
 165: LD_VAR 0 1
 169: PUSH
 170: LD_INT 1
 172: EQUAL
 173: PUSH
 174: LD_VAR 0 1
 178: PUSH
 179: LD_INT 9
 181: EQUAL
 182: OR
 183: IFFALSE 208
// bonus := [ 2 , 0 , 0 , 0 ] ;
 185: LD_ADDR_VAR 0 8
 189: PUSH
 190: LD_INT 2
 192: PUSH
 193: LD_INT 0
 195: PUSH
 196: LD_INT 0
 198: PUSH
 199: LD_INT 0
 201: PUSH
 202: EMPTY
 203: LIST
 204: LIST
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// if clas = 2 then
 208: LD_VAR 0 1
 212: PUSH
 213: LD_INT 2
 215: EQUAL
 216: IFFALSE 241
// bonus := [ 0 , 2 , 0 , 0 ] ;
 218: LD_ADDR_VAR 0 8
 222: PUSH
 223: LD_INT 0
 225: PUSH
 226: LD_INT 2
 228: PUSH
 229: LD_INT 0
 231: PUSH
 232: LD_INT 0
 234: PUSH
 235: EMPTY
 236: LIST
 237: LIST
 238: LIST
 239: LIST
 240: ST_TO_ADDR
// if clas = 3 then
 241: LD_VAR 0 1
 245: PUSH
 246: LD_INT 3
 248: EQUAL
 249: IFFALSE 274
// bonus := [ 0 , 0 , 2 , 0 ] ;
 251: LD_ADDR_VAR 0 8
 255: PUSH
 256: LD_INT 0
 258: PUSH
 259: LD_INT 0
 261: PUSH
 262: LD_INT 2
 264: PUSH
 265: LD_INT 0
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: ST_TO_ADDR
// if clas = 4 then
 274: LD_VAR 0 1
 278: PUSH
 279: LD_INT 4
 281: EQUAL
 282: IFFALSE 307
// bonus := [ 0 , 0 , 0 , 2 ] ;
 284: LD_ADDR_VAR 0 8
 288: PUSH
 289: LD_INT 0
 291: PUSH
 292: LD_INT 0
 294: PUSH
 295: LD_INT 0
 297: PUSH
 298: LD_INT 2
 300: PUSH
 301: EMPTY
 302: LIST
 303: LIST
 304: LIST
 305: LIST
 306: ST_TO_ADDR
// if clas > 4 and not clas = 9 then
 307: LD_VAR 0 1
 311: PUSH
 312: LD_INT 4
 314: GREATER
 315: PUSH
 316: LD_VAR 0 1
 320: PUSH
 321: LD_INT 9
 323: EQUAL
 324: NOT
 325: AND
 326: IFFALSE 351
// bonus := [ 0 , 0 , 0 , 0 ] ;
 328: LD_ADDR_VAR 0 8
 332: PUSH
 333: LD_INT 0
 335: PUSH
 336: LD_INT 0
 338: PUSH
 339: LD_INT 0
 341: PUSH
 342: LD_INT 0
 344: PUSH
 345: EMPTY
 346: LIST
 347: LIST
 348: LIST
 349: LIST
 350: ST_TO_ADDR
// hc_skills := [ skill_com + bonus [ 1 ] , skill_eng + bonus [ 2 ] , skill_mech + bonus [ 3 ] , skill_sci + bonus [ 4 ] ] ;
 351: LD_ADDR_OWVAR 31
 355: PUSH
 356: LD_VAR 0 4
 360: PUSH
 361: LD_VAR 0 8
 365: PUSH
 366: LD_INT 1
 368: ARRAY
 369: PLUS
 370: PUSH
 371: LD_VAR 0 5
 375: PUSH
 376: LD_VAR 0 8
 380: PUSH
 381: LD_INT 2
 383: ARRAY
 384: PLUS
 385: PUSH
 386: LD_VAR 0 6
 390: PUSH
 391: LD_VAR 0 8
 395: PUSH
 396: LD_INT 3
 398: ARRAY
 399: PLUS
 400: PUSH
 401: LD_VAR 0 7
 405: PUSH
 406: LD_VAR 0 8
 410: PUSH
 411: LD_INT 4
 413: ARRAY
 414: PLUS
 415: PUSH
 416: EMPTY
 417: LIST
 418: LIST
 419: LIST
 420: LIST
 421: ST_TO_ADDR
// hc_sex := Rand ( sex_male , sex_female ) ;
 422: LD_ADDR_OWVAR 27
 426: PUSH
 427: LD_INT 1
 429: PPUSH
 430: LD_INT 2
 432: PPUSH
 433: CALL_OW 12
 437: ST_TO_ADDR
// hc_gallery :=  ;
 438: LD_ADDR_OWVAR 33
 442: PUSH
 443: LD_STRING 
 445: ST_TO_ADDR
// hc_attr := [ Rand ( 8 , 12 ) , Rand ( 9 , 11 ) ] ;
 446: LD_ADDR_OWVAR 29
 450: PUSH
 451: LD_INT 8
 453: PPUSH
 454: LD_INT 12
 456: PPUSH
 457: CALL_OW 12
 461: PUSH
 462: LD_INT 9
 464: PPUSH
 465: LD_INT 11
 467: PPUSH
 468: CALL_OW 12
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: ST_TO_ADDR
// hc_name :=  ;
 477: LD_ADDR_OWVAR 26
 481: PUSH
 482: LD_STRING 
 484: ST_TO_ADDR
// result := CreateHuman ;
 485: LD_ADDR_VAR 0 3
 489: PUSH
 490: CALL_OW 44
 494: ST_TO_ADDR
// end ;
 495: LD_VAR 0 3
 499: RET
// export function RussianAttack ( side , num , typ , area ) ; var i , un , filter , veh , chassis , weapon ; begin
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
 504: PPUSH
 505: PPUSH
 506: PPUSH
 507: PPUSH
 508: PPUSH
// uc_side := side ;
 509: LD_ADDR_OWVAR 20
 513: PUSH
 514: LD_VAR 0 1
 518: ST_TO_ADDR
// uc_nation := nation_russian ;
 519: LD_ADDR_OWVAR 21
 523: PUSH
 524: LD_INT 3
 526: ST_TO_ADDR
// chassis := [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_wheeled ] ;
 527: LD_ADDR_VAR 0 10
 531: PUSH
 532: LD_INT 22
 534: PUSH
 535: LD_INT 24
 537: PUSH
 538: LD_INT 23
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: ST_TO_ADDR
// weapon := [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher ] ;
 546: LD_ADDR_VAR 0 11
 550: PUSH
 551: LD_INT 43
 553: PUSH
 554: LD_INT 44
 556: PUSH
 557: LD_INT 46
 559: PUSH
 560: LD_INT 45
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: ST_TO_ADDR
// case typ of 1 :
 569: LD_VAR 0 3
 573: PUSH
 574: LD_INT 1
 576: DOUBLE
 577: EQUAL
 578: IFTRUE 582
 580: GO 817
 582: POP
// begin for i = 1 to num do
 583: LD_ADDR_VAR 0 6
 587: PUSH
 588: DOUBLE
 589: LD_INT 1
 591: DEC
 592: ST_TO_ADDR
 593: LD_VAR 0 2
 597: PUSH
 598: FOR_TO
 599: IFFALSE 758
// begin vc_chassis := chassis [ Rand ( 2 , 3 ) ] ;
 601: LD_ADDR_OWVAR 37
 605: PUSH
 606: LD_VAR 0 10
 610: PUSH
 611: LD_INT 2
 613: PPUSH
 614: LD_INT 3
 616: PPUSH
 617: CALL_OW 12
 621: ARRAY
 622: ST_TO_ADDR
// vc_engine := engine_combustion ;
 623: LD_ADDR_OWVAR 39
 627: PUSH
 628: LD_INT 1
 630: ST_TO_ADDR
// vc_control := control_manual ;
 631: LD_ADDR_OWVAR 38
 635: PUSH
 636: LD_INT 1
 638: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 3 , 4 ) ] ;
 639: LD_ADDR_OWVAR 40
 643: PUSH
 644: LD_VAR 0 11
 648: PUSH
 649: LD_INT 3
 651: PPUSH
 652: LD_INT 4
 654: PPUSH
 655: CALL_OW 12
 659: ARRAY
 660: ST_TO_ADDR
// veh := CreateVehicle ;
 661: LD_ADDR_VAR 0 9
 665: PUSH
 666: CALL_OW 45
 670: ST_TO_ADDR
// if area = ru_north_spawn then
 671: LD_VAR 0 4
 675: PUSH
 676: LD_INT 3
 678: EQUAL
 679: IFFALSE 695
// SetDir ( veh , 3 ) else
 681: LD_VAR 0 9
 685: PPUSH
 686: LD_INT 3
 688: PPUSH
 689: CALL_OW 233
 693: GO 707
// SetDir ( veh , 1 ) ;
 695: LD_VAR 0 9
 699: PPUSH
 700: LD_INT 1
 702: PPUSH
 703: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
 707: LD_VAR 0 9
 711: PPUSH
 712: LD_VAR 0 4
 716: PPUSH
 717: LD_INT 0
 719: PPUSH
 720: CALL_OW 49
// un := CreateHumanWithClass ( 1 , rus_skill ) ;
 724: LD_ADDR_VAR 0 7
 728: PUSH
 729: LD_INT 1
 731: PPUSH
 732: LD_EXP 36
 736: PPUSH
 737: CALL 55 0 2
 741: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
 742: LD_VAR 0 7
 746: PPUSH
 747: LD_VAR 0 9
 751: PPUSH
 752: CALL_OW 52
// end ;
 756: GO 598
 758: POP
 759: POP
// for i = 1 to 2 do
 760: LD_ADDR_VAR 0 6
 764: PUSH
 765: DOUBLE
 766: LD_INT 1
 768: DEC
 769: ST_TO_ADDR
 770: LD_INT 2
 772: PUSH
 773: FOR_TO
 774: IFFALSE 813
// begin un := CreateHumanWithClass ( class_bazooker , rus_skill ) ;
 776: LD_ADDR_VAR 0 7
 780: PUSH
 781: LD_INT 9
 783: PPUSH
 784: LD_EXP 36
 788: PPUSH
 789: CALL 55 0 2
 793: ST_TO_ADDR
// PlaceUnitArea ( un , area , false ) ;
 794: LD_VAR 0 7
 798: PPUSH
 799: LD_VAR 0 4
 803: PPUSH
 804: LD_INT 0
 806: PPUSH
 807: CALL_OW 49
// end ;
 811: GO 773
 813: POP
 814: POP
// end ; 2 :
 815: GO 1006
 817: LD_INT 2
 819: DOUBLE
 820: EQUAL
 821: IFTRUE 825
 823: GO 1005
 825: POP
// begin for i = 1 to num do
 826: LD_ADDR_VAR 0 6
 830: PUSH
 831: DOUBLE
 832: LD_INT 1
 834: DEC
 835: ST_TO_ADDR
 836: LD_VAR 0 2
 840: PUSH
 841: FOR_TO
 842: IFFALSE 1001
// begin vc_chassis := chassis [ Rand ( 1 , 3 ) ] ;
 844: LD_ADDR_OWVAR 37
 848: PUSH
 849: LD_VAR 0 10
 853: PUSH
 854: LD_INT 1
 856: PPUSH
 857: LD_INT 3
 859: PPUSH
 860: CALL_OW 12
 864: ARRAY
 865: ST_TO_ADDR
// vc_engine := engine_combustion ;
 866: LD_ADDR_OWVAR 39
 870: PUSH
 871: LD_INT 1
 873: ST_TO_ADDR
// vc_control := control_manual ;
 874: LD_ADDR_OWVAR 38
 878: PUSH
 879: LD_INT 1
 881: ST_TO_ADDR
// vc_weapon := weapon [ Rand ( 1 , 2 ) ] ;
 882: LD_ADDR_OWVAR 40
 886: PUSH
 887: LD_VAR 0 11
 891: PUSH
 892: LD_INT 1
 894: PPUSH
 895: LD_INT 2
 897: PPUSH
 898: CALL_OW 12
 902: ARRAY
 903: ST_TO_ADDR
// veh := CreateVehicle ;
 904: LD_ADDR_VAR 0 9
 908: PUSH
 909: CALL_OW 45
 913: ST_TO_ADDR
// if area = ru_north_spawn then
 914: LD_VAR 0 4
 918: PUSH
 919: LD_INT 3
 921: EQUAL
 922: IFFALSE 938
// SetDir ( veh , 3 ) else
 924: LD_VAR 0 9
 928: PPUSH
 929: LD_INT 3
 931: PPUSH
 932: CALL_OW 233
 936: GO 950
// SetDir ( veh , 1 ) ;
 938: LD_VAR 0 9
 942: PPUSH
 943: LD_INT 1
 945: PPUSH
 946: CALL_OW 233
// PlaceUnitArea ( veh , area , false ) ;
 950: LD_VAR 0 9
 954: PPUSH
 955: LD_VAR 0 4
 959: PPUSH
 960: LD_INT 0
 962: PPUSH
 963: CALL_OW 49
// un := CreateHumanWithClass ( 1 , rus_skill ) ;
 967: LD_ADDR_VAR 0 7
 971: PUSH
 972: LD_INT 1
 974: PPUSH
 975: LD_EXP 36
 979: PPUSH
 980: CALL 55 0 2
 984: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
 985: LD_VAR 0 7
 989: PPUSH
 990: LD_VAR 0 9
 994: PPUSH
 995: CALL_OW 52
// end ;
 999: GO 841
1001: POP
1002: POP
// end ; end ;
1003: GO 1006
1005: POP
// end ;
1006: LD_VAR 0 5
1010: RET
// export function PrepareNature ( num1 , num2 , num3 ) ; var l , apeman , tiger , bird ; begin
1011: LD_INT 0
1013: PPUSH
1014: PPUSH
1015: PPUSH
1016: PPUSH
1017: PPUSH
// uc_nation = nation_nature ;
1018: LD_ADDR_OWVAR 21
1022: PUSH
1023: LD_INT 0
1025: ST_TO_ADDR
// uc_side = 0 ;
1026: LD_ADDR_OWVAR 20
1030: PUSH
1031: LD_INT 0
1033: ST_TO_ADDR
// l = 0 ;
1034: LD_ADDR_VAR 0 5
1038: PUSH
1039: LD_INT 0
1041: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
1042: LD_ADDR_OWVAR 24
1046: PUSH
1047: LD_INT 0
1049: PPUSH
1050: LD_INT 5
1052: PPUSH
1053: CALL_OW 12
1057: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 0 ) ;
1058: LD_ADDR_OWVAR 35
1062: PUSH
1063: LD_INT 5
1065: NEG
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 12
1074: ST_TO_ADDR
// hc_gallery =  ;
1075: LD_ADDR_OWVAR 33
1079: PUSH
1080: LD_STRING 
1082: ST_TO_ADDR
// hc_class = class_apeman ;
1083: LD_ADDR_OWVAR 28
1087: PUSH
1088: LD_INT 12
1090: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
1091: LD_ADDR_OWVAR 29
1095: PUSH
1096: LD_INT 11
1098: PPUSH
1099: LD_INT 13
1101: PPUSH
1102: CALL_OW 12
1106: PUSH
1107: LD_INT 10
1109: PPUSH
1110: LD_INT 11
1112: PPUSH
1113: CALL_OW 12
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: ST_TO_ADDR
// hc_sex = sex_male ;
1122: LD_ADDR_OWVAR 27
1126: PUSH
1127: LD_INT 1
1129: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
1130: LD_ADDR_OWVAR 31
1134: PUSH
1135: LD_INT 0
1137: PPUSH
1138: LD_INT 2
1140: PPUSH
1141: CALL_OW 12
1145: PUSH
1146: LD_INT 0
1148: PUSH
1149: LD_INT 0
1151: PUSH
1152: LD_INT 0
1154: PUSH
1155: EMPTY
1156: LIST
1157: LIST
1158: LIST
1159: LIST
1160: ST_TO_ADDR
// apeman = CreateHuman ;
1161: LD_ADDR_VAR 0 6
1165: PUSH
1166: CALL_OW 44
1170: ST_TO_ADDR
// PlaceUnitArea ( apeman , forest , false ) ;
1171: LD_VAR 0 6
1175: PPUSH
1176: LD_INT 12
1178: PPUSH
1179: LD_INT 0
1181: PPUSH
1182: CALL_OW 49
// l = l + 1 ;
1186: LD_ADDR_VAR 0 5
1190: PUSH
1191: LD_VAR 0 5
1195: PUSH
1196: LD_INT 1
1198: PLUS
1199: ST_TO_ADDR
// end until l = num1 ;
1200: LD_VAR 0 5
1204: PUSH
1205: LD_VAR 0 1
1209: EQUAL
1210: IFFALSE 1042
// l = 0 ;
1212: LD_ADDR_VAR 0 5
1216: PUSH
1217: LD_INT 0
1219: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
1220: LD_ADDR_OWVAR 35
1224: PUSH
1225: LD_INT 0
1227: PPUSH
1228: LD_INT 25
1230: PPUSH
1231: CALL_OW 12
1235: ST_TO_ADDR
// hc_class = class_tiger ;
1236: LD_ADDR_OWVAR 28
1240: PUSH
1241: LD_INT 14
1243: ST_TO_ADDR
// hc_sex = sex_male ;
1244: LD_ADDR_OWVAR 27
1248: PUSH
1249: LD_INT 1
1251: ST_TO_ADDR
// hc_gallery = sandnature ;
1252: LD_ADDR_OWVAR 33
1256: PUSH
1257: LD_STRING sandnature
1259: ST_TO_ADDR
// hc_face_number = 3 ;
1260: LD_ADDR_OWVAR 34
1264: PUSH
1265: LD_INT 3
1267: ST_TO_ADDR
// tiger = CreateHuman ;
1268: LD_ADDR_VAR 0 7
1272: PUSH
1273: CALL_OW 44
1277: ST_TO_ADDR
// PlaceUnitArea ( tiger , forest , false ) ;
1278: LD_VAR 0 7
1282: PPUSH
1283: LD_INT 12
1285: PPUSH
1286: LD_INT 0
1288: PPUSH
1289: CALL_OW 49
// l = l + 1 ;
1293: LD_ADDR_VAR 0 5
1297: PUSH
1298: LD_VAR 0 5
1302: PUSH
1303: LD_INT 1
1305: PLUS
1306: ST_TO_ADDR
// end until l = num2 ;
1307: LD_VAR 0 5
1311: PUSH
1312: LD_VAR 0 2
1316: EQUAL
1317: IFFALSE 1220
// l = 0 ;
1319: LD_ADDR_VAR 0 5
1323: PUSH
1324: LD_INT 0
1326: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
1327: LD_ADDR_OWVAR 28
1331: PUSH
1332: LD_INT 18
1334: ST_TO_ADDR
// hc_gallery = sandnature ;
1335: LD_ADDR_OWVAR 33
1339: PUSH
1340: LD_STRING sandnature
1342: ST_TO_ADDR
// hc_face_number = 1 ;
1343: LD_ADDR_OWVAR 34
1347: PUSH
1348: LD_INT 1
1350: ST_TO_ADDR
// bird = CreateHuman ;
1351: LD_ADDR_VAR 0 8
1355: PUSH
1356: CALL_OW 44
1360: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
1361: LD_VAR 0 8
1365: PPUSH
1366: LD_INT 0
1368: PPUSH
1369: CALL_OW 51
// l = l + 1 ;
1373: LD_ADDR_VAR 0 5
1377: PUSH
1378: LD_VAR 0 5
1382: PUSH
1383: LD_INT 1
1385: PLUS
1386: ST_TO_ADDR
// end until l = num3 ;
1387: LD_VAR 0 5
1391: PUSH
1392: LD_VAR 0 3
1396: EQUAL
1397: IFFALSE 1327
// end ; end_of_file
1399: LD_VAR 0 4
1403: RET
// export Louis , Martin , Karla , Dwein , Joachim , Olaf , Mmark , Herczeg , Mia , Kantor , Ronn , Gunther , ot1 , ot2 , ot3 , ot4 , ot5 , ot6 , ot7 ; export AllPeo ; export function LoadUnits ; begin
1404: LD_INT 0
1406: PPUSH
// AllPeo := [ ] ;
1407: LD_ADDR_EXP 20
1411: PUSH
1412: EMPTY
1413: ST_TO_ADDR
// uc_side := 2 ;
1414: LD_ADDR_OWVAR 20
1418: PUSH
1419: LD_INT 2
1421: ST_TO_ADDR
// Louis := CreateCharacter ( Louis ) ;
1422: LD_ADDR_EXP 1
1426: PUSH
1427: LD_STRING Louis
1429: PPUSH
1430: CALL_OW 34
1434: ST_TO_ADDR
// AllPeo = AllPeo ^ Louis ;
1435: LD_ADDR_EXP 20
1439: PUSH
1440: LD_EXP 20
1444: PUSH
1445: LD_EXP 1
1449: ADD
1450: ST_TO_ADDR
// if TestCharacters ( Martin_05 ) then
1451: LD_STRING Martin_05
1453: PPUSH
1454: CALL_OW 28
1458: IFFALSE 1491
// begin Martin := CreateCharacter ( Martin_05 ) ;
1460: LD_ADDR_EXP 2
1464: PUSH
1465: LD_STRING Martin_05
1467: PPUSH
1468: CALL_OW 34
1472: ST_TO_ADDR
// AllPeo = AllPeo ^ Martin ;
1473: LD_ADDR_EXP 20
1477: PUSH
1478: LD_EXP 20
1482: PUSH
1483: LD_EXP 2
1487: ADD
1488: ST_TO_ADDR
// end else
1489: GO 1499
// begin Martin = false ;
1491: LD_ADDR_EXP 2
1495: PUSH
1496: LD_INT 0
1498: ST_TO_ADDR
// end ; if TestCharacters ( Karla_05 ) then
1499: LD_STRING Karla_05
1501: PPUSH
1502: CALL_OW 28
1506: IFFALSE 1539
// begin Karla := CreateCharacter ( Karla_05 ) ;
1508: LD_ADDR_EXP 3
1512: PUSH
1513: LD_STRING Karla_05
1515: PPUSH
1516: CALL_OW 34
1520: ST_TO_ADDR
// AllPeo = AllPeo ^ Karla ;
1521: LD_ADDR_EXP 20
1525: PUSH
1526: LD_EXP 20
1530: PUSH
1531: LD_EXP 3
1535: ADD
1536: ST_TO_ADDR
// end else
1537: GO 1547
// begin Karla = false ;
1539: LD_ADDR_EXP 3
1543: PUSH
1544: LD_INT 0
1546: ST_TO_ADDR
// end ; if TestCharacters ( Mmark_05 ) then
1547: LD_STRING Mmark_05
1549: PPUSH
1550: CALL_OW 28
1554: IFFALSE 1587
// begin Mmark := CreateCharacter ( Mmark_05 ) ;
1556: LD_ADDR_EXP 7
1560: PUSH
1561: LD_STRING Mmark_05
1563: PPUSH
1564: CALL_OW 34
1568: ST_TO_ADDR
// AllPeo = AllPeo ^ Mmark ;
1569: LD_ADDR_EXP 20
1573: PUSH
1574: LD_EXP 20
1578: PUSH
1579: LD_EXP 7
1583: ADD
1584: ST_TO_ADDR
// end else
1585: GO 1595
// begin Mmark = false ;
1587: LD_ADDR_EXP 7
1591: PUSH
1592: LD_INT 0
1594: ST_TO_ADDR
// end ; if TestCharacters ( Joachim_05 ) then
1595: LD_STRING Joachim_05
1597: PPUSH
1598: CALL_OW 28
1602: IFFALSE 1635
// begin Joachim := CreateCharacter ( Joachim_05 ) ;
1604: LD_ADDR_EXP 5
1608: PUSH
1609: LD_STRING Joachim_05
1611: PPUSH
1612: CALL_OW 34
1616: ST_TO_ADDR
// AllPeo = AllPeo ^ Joachim ;
1617: LD_ADDR_EXP 20
1621: PUSH
1622: LD_EXP 20
1626: PUSH
1627: LD_EXP 5
1631: ADD
1632: ST_TO_ADDR
// end else
1633: GO 1643
// begin Joachim = false ;
1635: LD_ADDR_EXP 5
1639: PUSH
1640: LD_INT 0
1642: ST_TO_ADDR
// end ; if TestCharacters ( Olaf_05 ) then
1643: LD_STRING Olaf_05
1645: PPUSH
1646: CALL_OW 28
1650: IFFALSE 1683
// begin Olaf := CreateCharacter ( Olaf_05 ) ;
1652: LD_ADDR_EXP 6
1656: PUSH
1657: LD_STRING Olaf_05
1659: PPUSH
1660: CALL_OW 34
1664: ST_TO_ADDR
// AllPeo = AllPeo ^ Olaf ;
1665: LD_ADDR_EXP 20
1669: PUSH
1670: LD_EXP 20
1674: PUSH
1675: LD_EXP 6
1679: ADD
1680: ST_TO_ADDR
// end else
1681: GO 1691
// begin Olaf = false ;
1683: LD_ADDR_EXP 6
1687: PUSH
1688: LD_INT 0
1690: ST_TO_ADDR
// end ; if TestCharacters ( Dwein_05 ) then
1691: LD_STRING Dwein_05
1693: PPUSH
1694: CALL_OW 28
1698: IFFALSE 1731
// begin Dwein := CreateCharacter ( Dwein_05 ) ;
1700: LD_ADDR_EXP 4
1704: PUSH
1705: LD_STRING Dwein_05
1707: PPUSH
1708: CALL_OW 34
1712: ST_TO_ADDR
// AllPeo = AllPeo ^ Dwein ;
1713: LD_ADDR_EXP 20
1717: PUSH
1718: LD_EXP 20
1722: PUSH
1723: LD_EXP 4
1727: ADD
1728: ST_TO_ADDR
// end else
1729: GO 1739
// begin Dwein = false ;
1731: LD_ADDR_EXP 4
1735: PUSH
1736: LD_INT 0
1738: ST_TO_ADDR
// end ; if TestCharacters ( Herczeg_05 ) then
1739: LD_STRING Herczeg_05
1741: PPUSH
1742: CALL_OW 28
1746: IFFALSE 1779
// begin Herczeg := CreateCharacter ( Herczeg_05 ) ;
1748: LD_ADDR_EXP 8
1752: PUSH
1753: LD_STRING Herczeg_05
1755: PPUSH
1756: CALL_OW 34
1760: ST_TO_ADDR
// AllPeo = AllPeo ^ Herczeg ;
1761: LD_ADDR_EXP 20
1765: PUSH
1766: LD_EXP 20
1770: PUSH
1771: LD_EXP 8
1775: ADD
1776: ST_TO_ADDR
// end else
1777: GO 1787
// begin Herczeg = false ;
1779: LD_ADDR_EXP 8
1783: PUSH
1784: LD_INT 0
1786: ST_TO_ADDR
// end ; if TestCharacters ( Mia_05 ) then
1787: LD_STRING Mia_05
1789: PPUSH
1790: CALL_OW 28
1794: IFFALSE 1827
// begin Mia := CreateCharacter ( Mia_05 ) ;
1796: LD_ADDR_EXP 9
1800: PUSH
1801: LD_STRING Mia_05
1803: PPUSH
1804: CALL_OW 34
1808: ST_TO_ADDR
// AllPeo = AllPeo ^ Mia ;
1809: LD_ADDR_EXP 20
1813: PUSH
1814: LD_EXP 20
1818: PUSH
1819: LD_EXP 9
1823: ADD
1824: ST_TO_ADDR
// end else
1825: GO 1835
// begin Mia = false ;
1827: LD_ADDR_EXP 9
1831: PUSH
1832: LD_INT 0
1834: ST_TO_ADDR
// end ; if TestCharacters ( Kantor_05 ) then
1835: LD_STRING Kantor_05
1837: PPUSH
1838: CALL_OW 28
1842: IFFALSE 1875
// begin Kantor := CreateCharacter ( Kantor_05 ) ;
1844: LD_ADDR_EXP 10
1848: PUSH
1849: LD_STRING Kantor_05
1851: PPUSH
1852: CALL_OW 34
1856: ST_TO_ADDR
// AllPeo = AllPeo ^ Kantor ;
1857: LD_ADDR_EXP 20
1861: PUSH
1862: LD_EXP 20
1866: PUSH
1867: LD_EXP 10
1871: ADD
1872: ST_TO_ADDR
// end else
1873: GO 1883
// begin Kantor = false ;
1875: LD_ADDR_EXP 10
1879: PUSH
1880: LD_INT 0
1882: ST_TO_ADDR
// end ; if TestCharacters ( Gunther_05 ) then
1883: LD_STRING Gunther_05
1885: PPUSH
1886: CALL_OW 28
1890: IFFALSE 1923
// begin Gunther := CreateCharacter ( Gunther_05 ) ;
1892: LD_ADDR_EXP 12
1896: PUSH
1897: LD_STRING Gunther_05
1899: PPUSH
1900: CALL_OW 34
1904: ST_TO_ADDR
// AllPeo = AllPeo ^ Gunther ;
1905: LD_ADDR_EXP 20
1909: PUSH
1910: LD_EXP 20
1914: PUSH
1915: LD_EXP 12
1919: ADD
1920: ST_TO_ADDR
// end else
1921: GO 1931
// begin Gunther = false ;
1923: LD_ADDR_EXP 12
1927: PUSH
1928: LD_INT 0
1930: ST_TO_ADDR
// end ; if TestCharacters ( Ronn_05 ) then
1931: LD_STRING Ronn_05
1933: PPUSH
1934: CALL_OW 28
1938: IFFALSE 1969
// begin Ronn := CreateCharacter ( Ronn_05 ) ;
1940: LD_ADDR_EXP 11
1944: PUSH
1945: LD_STRING Ronn_05
1947: PPUSH
1948: CALL_OW 34
1952: ST_TO_ADDR
// AllPeo = AllPeo ^ Ronn ;
1953: LD_ADDR_EXP 20
1957: PUSH
1958: LD_EXP 20
1962: PUSH
1963: LD_EXP 11
1967: ADD
1968: ST_TO_ADDR
// end ; if TestCharacters ( ot1_05 ) then
1969: LD_STRING ot1_05
1971: PPUSH
1972: CALL_OW 28
1976: IFFALSE 2009
// begin ot1 := CreateCharacter ( ot1_05 ) ;
1978: LD_ADDR_EXP 13
1982: PUSH
1983: LD_STRING ot1_05
1985: PPUSH
1986: CALL_OW 34
1990: ST_TO_ADDR
// AllPeo = AllPeo ^ ot1 ;
1991: LD_ADDR_EXP 20
1995: PUSH
1996: LD_EXP 20
2000: PUSH
2001: LD_EXP 13
2005: ADD
2006: ST_TO_ADDR
// end else
2007: GO 2017
// begin ot1 = false ;
2009: LD_ADDR_EXP 13
2013: PUSH
2014: LD_INT 0
2016: ST_TO_ADDR
// end ; if TestCharacters ( ot2_05 ) then
2017: LD_STRING ot2_05
2019: PPUSH
2020: CALL_OW 28
2024: IFFALSE 2057
// begin ot2 := CreateCharacter ( ot2_05 ) ;
2026: LD_ADDR_EXP 14
2030: PUSH
2031: LD_STRING ot2_05
2033: PPUSH
2034: CALL_OW 34
2038: ST_TO_ADDR
// AllPeo = AllPeo ^ ot2 ;
2039: LD_ADDR_EXP 20
2043: PUSH
2044: LD_EXP 20
2048: PUSH
2049: LD_EXP 14
2053: ADD
2054: ST_TO_ADDR
// end else
2055: GO 2065
// begin ot2 = false ;
2057: LD_ADDR_EXP 14
2061: PUSH
2062: LD_INT 0
2064: ST_TO_ADDR
// end ; if TestCharacters ( ot3_04 ) then
2065: LD_STRING ot3_04
2067: PPUSH
2068: CALL_OW 28
2072: IFFALSE 2105
// begin ot3 := CreateCharacter ( ot3_04 ) ;
2074: LD_ADDR_EXP 15
2078: PUSH
2079: LD_STRING ot3_04
2081: PPUSH
2082: CALL_OW 34
2086: ST_TO_ADDR
// AllPeo = AllPeo ^ ot3 ;
2087: LD_ADDR_EXP 20
2091: PUSH
2092: LD_EXP 20
2096: PUSH
2097: LD_EXP 15
2101: ADD
2102: ST_TO_ADDR
// end else
2103: GO 2113
// begin ot3 = false ;
2105: LD_ADDR_EXP 15
2109: PUSH
2110: LD_INT 0
2112: ST_TO_ADDR
// end ; if TestCharacters ( ot4_05 ) then
2113: LD_STRING ot4_05
2115: PPUSH
2116: CALL_OW 28
2120: IFFALSE 2153
// begin ot4 := CreateCharacter ( ot4_05 ) ;
2122: LD_ADDR_EXP 16
2126: PUSH
2127: LD_STRING ot4_05
2129: PPUSH
2130: CALL_OW 34
2134: ST_TO_ADDR
// AllPeo = AllPeo ^ ot4 ;
2135: LD_ADDR_EXP 20
2139: PUSH
2140: LD_EXP 20
2144: PUSH
2145: LD_EXP 16
2149: ADD
2150: ST_TO_ADDR
// end else
2151: GO 2161
// begin ot4 = false ;
2153: LD_ADDR_EXP 16
2157: PUSH
2158: LD_INT 0
2160: ST_TO_ADDR
// end ; if TestCharacters ( ot5_05 ) then
2161: LD_STRING ot5_05
2163: PPUSH
2164: CALL_OW 28
2168: IFFALSE 2201
// begin ot5 := CreateCharacter ( ot5_05 ) ;
2170: LD_ADDR_EXP 17
2174: PUSH
2175: LD_STRING ot5_05
2177: PPUSH
2178: CALL_OW 34
2182: ST_TO_ADDR
// AllPeo = AllPeo ^ ot5 ;
2183: LD_ADDR_EXP 20
2187: PUSH
2188: LD_EXP 20
2192: PUSH
2193: LD_EXP 17
2197: ADD
2198: ST_TO_ADDR
// end else
2199: GO 2209
// begin ot5 = false ;
2201: LD_ADDR_EXP 17
2205: PUSH
2206: LD_INT 0
2208: ST_TO_ADDR
// end ; if TestCharacters ( ot6_05 ) then
2209: LD_STRING ot6_05
2211: PPUSH
2212: CALL_OW 28
2216: IFFALSE 2249
// begin ot6 := CreateCharacter ( ot6_05 ) ;
2218: LD_ADDR_EXP 18
2222: PUSH
2223: LD_STRING ot6_05
2225: PPUSH
2226: CALL_OW 34
2230: ST_TO_ADDR
// AllPeo = AllPeo ^ ot6 ;
2231: LD_ADDR_EXP 20
2235: PUSH
2236: LD_EXP 20
2240: PUSH
2241: LD_EXP 18
2245: ADD
2246: ST_TO_ADDR
// end else
2247: GO 2257
// begin ot6 = false ;
2249: LD_ADDR_EXP 18
2253: PUSH
2254: LD_INT 0
2256: ST_TO_ADDR
// end ; if TestCharacters ( ot7_05 ) then
2257: LD_STRING ot7_05
2259: PPUSH
2260: CALL_OW 28
2264: IFFALSE 2297
// begin ot7 := CreateCharacter ( ot7_05 ) ;
2266: LD_ADDR_EXP 19
2270: PUSH
2271: LD_STRING ot7_05
2273: PPUSH
2274: CALL_OW 34
2278: ST_TO_ADDR
// AllPeo = AllPeo ^ ot7 ;
2279: LD_ADDR_EXP 20
2283: PUSH
2284: LD_EXP 20
2288: PUSH
2289: LD_EXP 19
2293: ADD
2294: ST_TO_ADDR
// end else
2295: GO 2305
// begin ot7 = false ;
2297: LD_ADDR_EXP 19
2301: PUSH
2302: LD_INT 0
2304: ST_TO_ADDR
// end ; end ;
2305: LD_VAR 0 1
2309: RET
// export ar_vehicles ; export function LoadVehicles ; var tab , i , p , veh , filter ; begin
2310: LD_INT 0
2312: PPUSH
2313: PPUSH
2314: PPUSH
2315: PPUSH
2316: PPUSH
2317: PPUSH
// uc_side := 2 ;
2318: LD_ADDR_OWVAR 20
2322: PUSH
2323: LD_INT 2
2325: ST_TO_ADDR
// tab := LoadVariable ( unit_vehs , [ ] ) ;
2326: LD_ADDR_VAR 0 2
2330: PUSH
2331: LD_STRING unit_vehs
2333: PPUSH
2334: EMPTY
2335: PPUSH
2336: CALL_OW 30
2340: ST_TO_ADDR
// i := 1 ;
2341: LD_ADDR_VAR 0 3
2345: PUSH
2346: LD_INT 1
2348: ST_TO_ADDR
// p := 1 ;
2349: LD_ADDR_VAR 0 4
2353: PUSH
2354: LD_INT 1
2356: ST_TO_ADDR
// if tab > 0 then
2357: LD_VAR 0 2
2361: PUSH
2362: LD_INT 0
2364: GREATER
2365: IFFALSE 2627
// while ( i <= tab ) do
2367: LD_VAR 0 3
2371: PUSH
2372: LD_VAR 0 2
2376: LESSEQUAL
2377: IFFALSE 2627
// begin if tab [ i ] in [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] then
2379: LD_VAR 0 2
2383: PUSH
2384: LD_VAR 0 3
2388: ARRAY
2389: PUSH
2390: LD_INT 21
2392: PUSH
2393: LD_INT 22
2395: PUSH
2396: LD_INT 23
2398: PUSH
2399: LD_INT 24
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: IN
2408: IFFALSE 2420
// uc_nation := nation_russian else
2410: LD_ADDR_OWVAR 21
2414: PUSH
2415: LD_INT 3
2417: ST_TO_ADDR
2418: GO 2428
// uc_nation := nation_arabian ;
2420: LD_ADDR_OWVAR 21
2424: PUSH
2425: LD_INT 2
2427: ST_TO_ADDR
// vc_chassis := tab [ i ] ;
2428: LD_ADDR_OWVAR 37
2432: PUSH
2433: LD_VAR 0 2
2437: PUSH
2438: LD_VAR 0 3
2442: ARRAY
2443: ST_TO_ADDR
// vc_engine := tab [ i + 1 ] ;
2444: LD_ADDR_OWVAR 39
2448: PUSH
2449: LD_VAR 0 2
2453: PUSH
2454: LD_VAR 0 3
2458: PUSH
2459: LD_INT 1
2461: PLUS
2462: ARRAY
2463: ST_TO_ADDR
// vc_control := tab [ i + 2 ] ;
2464: LD_ADDR_OWVAR 38
2468: PUSH
2469: LD_VAR 0 2
2473: PUSH
2474: LD_VAR 0 3
2478: PUSH
2479: LD_INT 2
2481: PLUS
2482: ARRAY
2483: ST_TO_ADDR
// vc_weapon := tab [ i + 3 ] ;
2484: LD_ADDR_OWVAR 40
2488: PUSH
2489: LD_VAR 0 2
2493: PUSH
2494: LD_VAR 0 3
2498: PUSH
2499: LD_INT 3
2501: PLUS
2502: ARRAY
2503: ST_TO_ADDR
// veh := CreateVehicle ;
2504: LD_ADDR_VAR 0 5
2508: PUSH
2509: CALL_OW 45
2513: ST_TO_ADDR
// ar_vehicles := ar_vehicles ^ veh ;
2514: LD_ADDR_EXP 21
2518: PUSH
2519: LD_EXP 21
2523: PUSH
2524: LD_VAR 0 5
2528: ADD
2529: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2530: LD_VAR 0 5
2534: PPUSH
2535: LD_INT 3
2537: PPUSH
2538: CALL_OW 233
// PlaceUnitArea ( veh , ar2_spawn , false ) ;
2542: LD_VAR 0 5
2546: PPUSH
2547: LD_INT 2
2549: PPUSH
2550: LD_INT 0
2552: PPUSH
2553: CALL_OW 49
// SetFuel ( veh , Rand ( 35 , 50 ) ) ;
2557: LD_VAR 0 5
2561: PPUSH
2562: LD_INT 35
2564: PPUSH
2565: LD_INT 50
2567: PPUSH
2568: CALL_OW 12
2572: PPUSH
2573: CALL_OW 240
// PlaceHumanInUnit ( AllPeo [ p ] , veh ) ;
2577: LD_EXP 20
2581: PUSH
2582: LD_VAR 0 4
2586: ARRAY
2587: PPUSH
2588: LD_VAR 0 5
2592: PPUSH
2593: CALL_OW 52
// p := p + 1 ;
2597: LD_ADDR_VAR 0 4
2601: PUSH
2602: LD_VAR 0 4
2606: PUSH
2607: LD_INT 1
2609: PLUS
2610: ST_TO_ADDR
// i := i + 4 ;
2611: LD_ADDR_VAR 0 3
2615: PUSH
2616: LD_VAR 0 3
2620: PUSH
2621: LD_INT 4
2623: PLUS
2624: ST_TO_ADDR
// end ;
2625: GO 2367
// filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ] ) ;
2627: LD_ADDR_VAR 0 6
2631: PUSH
2632: LD_INT 22
2634: PUSH
2635: LD_INT 2
2637: PUSH
2638: EMPTY
2639: LIST
2640: LIST
2641: PUSH
2642: LD_INT 21
2644: PUSH
2645: LD_INT 2
2647: PUSH
2648: EMPTY
2649: LIST
2650: LIST
2651: PUSH
2652: LD_INT 58
2654: PUSH
2655: EMPTY
2656: LIST
2657: PUSH
2658: EMPTY
2659: LIST
2660: LIST
2661: LIST
2662: PUSH
2663: EMPTY
2664: LIST
2665: PPUSH
2666: CALL_OW 69
2670: ST_TO_ADDR
// for i = 1 to filter do
2671: LD_ADDR_VAR 0 3
2675: PUSH
2676: DOUBLE
2677: LD_INT 1
2679: DEC
2680: ST_TO_ADDR
2681: LD_VAR 0 6
2685: PUSH
2686: FOR_TO
2687: IFFALSE 2706
// RemoveUnit ( filter [ i ] ) ;
2689: LD_VAR 0 6
2693: PUSH
2694: LD_VAR 0 3
2698: ARRAY
2699: PPUSH
2700: CALL_OW 64
2704: GO 2686
2706: POP
2707: POP
// end ; end_of_file
2708: LD_VAR 0 1
2712: RET
// export ar_miners , mine_x , mine_y , ar_build_list , ar_tech_list , ar_produce_list ; export ar_engs , ar_mechs , ar_lab ; export Erwin ; export skill_level ; export function ScriptArabian ; var i , filter , un , barracks , bunkers ; begin
2713: LD_INT 0
2715: PPUSH
2716: PPUSH
2717: PPUSH
2718: PPUSH
2719: PPUSH
2720: PPUSH
// uc_side := 8 ;
2721: LD_ADDR_OWVAR 20
2725: PUSH
2726: LD_INT 8
2728: ST_TO_ADDR
// uc_nation := nation_arabian ;
2729: LD_ADDR_OWVAR 21
2733: PUSH
2734: LD_INT 2
2736: ST_TO_ADDR
// ar_build_list := [ b_lab , 117 , 125 , 5 , b_armoury , 117 , 112 , 3 , b_workshop , 100 , 113 , 2 , b_solar_power , 93 , 126 , 3 , b_solar_power , 91 , 123 , 5 , b_solar_power , 91 , 103 , 2 ] ;
2737: LD_ADDR_EXP 25
2741: PUSH
2742: LD_INT 6
2744: PUSH
2745: LD_INT 117
2747: PUSH
2748: LD_INT 125
2750: PUSH
2751: LD_INT 5
2753: PUSH
2754: LD_INT 4
2756: PUSH
2757: LD_INT 117
2759: PUSH
2760: LD_INT 112
2762: PUSH
2763: LD_INT 3
2765: PUSH
2766: LD_INT 2
2768: PUSH
2769: LD_INT 100
2771: PUSH
2772: LD_INT 113
2774: PUSH
2775: LD_INT 2
2777: PUSH
2778: LD_INT 27
2780: PUSH
2781: LD_INT 93
2783: PUSH
2784: LD_INT 126
2786: PUSH
2787: LD_INT 3
2789: PUSH
2790: LD_INT 27
2792: PUSH
2793: LD_INT 91
2795: PUSH
2796: LD_INT 123
2798: PUSH
2799: LD_INT 5
2801: PUSH
2802: LD_INT 27
2804: PUSH
2805: LD_INT 91
2807: PUSH
2808: LD_INT 103
2810: PUSH
2811: LD_INT 2
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: LIST
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: LIST
2825: LIST
2826: LIST
2827: LIST
2828: LIST
2829: LIST
2830: LIST
2831: LIST
2832: LIST
2833: LIST
2834: LIST
2835: LIST
2836: LIST
2837: LIST
2838: LIST
2839: ST_TO_ADDR
// ar_tech_list := [ tech_oilpow , tech_oileng , tech_tech1 , tech_tech2 , tech_tech3 , tech_weap1 , tech_opto1 , tech_weap2 , tech_gatling , tech_gun , tech_flame , tech_explos , tech_radar , tech_remcont ] ;
2840: LD_ADDR_EXP 26
2844: PUSH
2845: LD_INT 46
2847: PUSH
2848: LD_INT 47
2850: PUSH
2851: LD_INT 48
2853: PUSH
2854: LD_INT 49
2856: PUSH
2857: LD_INT 50
2859: PUSH
2860: LD_INT 51
2862: PUSH
2863: LD_INT 60
2865: PUSH
2866: LD_INT 52
2868: PUSH
2869: LD_INT 69
2871: PUSH
2872: LD_INT 39
2874: PUSH
2875: LD_INT 70
2877: PUSH
2878: LD_INT 42
2880: PUSH
2881: LD_INT 6
2883: PUSH
2884: LD_INT 15
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: LIST
2891: LIST
2892: LIST
2893: LIST
2894: LIST
2895: LIST
2896: LIST
2897: LIST
2898: LIST
2899: LIST
2900: LIST
2901: LIST
2902: ST_TO_ADDR
// ar_produce_list := [ ar_cargo_bay , ar_gun , ar_flame_thrower ] ;
2903: LD_ADDR_EXP 27
2907: PUSH
2908: LD_INT 32
2910: PUSH
2911: LD_INT 27
2913: PUSH
2914: LD_INT 26
2916: PUSH
2917: EMPTY
2918: LIST
2919: LIST
2920: LIST
2921: ST_TO_ADDR
// skill_level := [ 7 , 6 , 6 ] [ Difficulty ] ;
2922: LD_ADDR_EXP 32
2926: PUSH
2927: LD_INT 7
2929: PUSH
2930: LD_INT 6
2932: PUSH
2933: LD_INT 6
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: PUSH
2941: LD_OWVAR 67
2945: ARRAY
2946: ST_TO_ADDR
// mine_x := [ 102 , 98 , 104 , 108 ] ;
2947: LD_ADDR_EXP 23
2951: PUSH
2952: LD_INT 102
2954: PUSH
2955: LD_INT 98
2957: PUSH
2958: LD_INT 104
2960: PUSH
2961: LD_INT 108
2963: PUSH
2964: EMPTY
2965: LIST
2966: LIST
2967: LIST
2968: LIST
2969: ST_TO_ADDR
// mine_y := [ 65 , 60 , 60 , 66 ] ;
2970: LD_ADDR_EXP 24
2974: PUSH
2975: LD_INT 65
2977: PUSH
2978: LD_INT 60
2980: PUSH
2981: LD_INT 60
2983: PUSH
2984: LD_INT 66
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: ST_TO_ADDR
// ar_miners := [ ] ;
2993: LD_ADDR_EXP 22
2997: PUSH
2998: EMPTY
2999: ST_TO_ADDR
// barracks := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_armoury ] ] ) ;
3000: LD_ADDR_VAR 0 5
3004: PUSH
3005: LD_INT 22
3007: PUSH
3008: LD_INT 8
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: PUSH
3015: LD_INT 30
3017: PUSH
3018: LD_INT 4
3020: PUSH
3021: EMPTY
3022: LIST
3023: LIST
3024: PUSH
3025: EMPTY
3026: LIST
3027: LIST
3028: PPUSH
3029: CALL_OW 69
3033: ST_TO_ADDR
// bunkers := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_breastwork ] ] ) ;
3034: LD_ADDR_VAR 0 6
3038: PUSH
3039: LD_INT 22
3041: PUSH
3042: LD_INT 8
3044: PUSH
3045: EMPTY
3046: LIST
3047: LIST
3048: PUSH
3049: LD_INT 30
3051: PUSH
3052: LD_INT 31
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: PPUSH
3063: CALL_OW 69
3067: ST_TO_ADDR
// for i = 1 to 4 do
3068: LD_ADDR_VAR 0 2
3072: PUSH
3073: DOUBLE
3074: LD_INT 1
3076: DEC
3077: ST_TO_ADDR
3078: LD_INT 4
3080: PUSH
3081: FOR_TO
3082: IFFALSE 3138
// begin un := CreateHumanWithClass ( 1 , skill_level ) ;
3084: LD_ADDR_VAR 0 4
3088: PUSH
3089: LD_INT 1
3091: PPUSH
3092: LD_EXP 32
3096: PPUSH
3097: CALL 55 0 2
3101: ST_TO_ADDR
// PlaceHumanInUnit ( un , barracks [ 1 ] ) ;
3102: LD_VAR 0 4
3106: PPUSH
3107: LD_VAR 0 5
3111: PUSH
3112: LD_INT 1
3114: ARRAY
3115: PPUSH
3116: CALL_OW 52
// ar_miners := ar_miners ^ un ;
3120: LD_ADDR_EXP 22
3124: PUSH
3125: LD_EXP 22
3129: PUSH
3130: LD_VAR 0 4
3134: ADD
3135: ST_TO_ADDR
// end ;
3136: GO 3081
3138: POP
3139: POP
// for i = 1 to 2 do
3140: LD_ADDR_VAR 0 2
3144: PUSH
3145: DOUBLE
3146: LD_INT 1
3148: DEC
3149: ST_TO_ADDR
3150: LD_INT 2
3152: PUSH
3153: FOR_TO
3154: IFFALSE 3194
// begin un := CreateHumanWithClass ( class_mortar , skill_level ) ;
3156: LD_ADDR_VAR 0 4
3160: PUSH
3161: LD_INT 8
3163: PPUSH
3164: LD_EXP 32
3168: PPUSH
3169: CALL 55 0 2
3173: ST_TO_ADDR
// PlaceHumanInUnit ( un , barracks [ 1 ] ) ;
3174: LD_VAR 0 4
3178: PPUSH
3179: LD_VAR 0 5
3183: PUSH
3184: LD_INT 1
3186: ARRAY
3187: PPUSH
3188: CALL_OW 52
// end ;
3192: GO 3153
3194: POP
3195: POP
// for i = 1 to 4 do
3196: LD_ADDR_VAR 0 2
3200: PUSH
3201: DOUBLE
3202: LD_INT 1
3204: DEC
3205: ST_TO_ADDR
3206: LD_INT 4
3208: PUSH
3209: FOR_TO
3210: IFFALSE 3244
// begin un := CreateHumanWithClass ( class_mortar , skill_level ) ;
3212: LD_ADDR_VAR 0 4
3216: PUSH
3217: LD_INT 8
3219: PPUSH
3220: LD_EXP 32
3224: PPUSH
3225: CALL 55 0 2
3229: ST_TO_ADDR
// PlaceHumanInUnit ( un , add_arm ) ;
3230: LD_VAR 0 4
3234: PPUSH
3235: LD_INT 25
3237: PPUSH
3238: CALL_OW 52
// end ;
3242: GO 3209
3244: POP
3245: POP
// for i = 1 to 2 do
3246: LD_ADDR_VAR 0 2
3250: PUSH
3251: DOUBLE
3252: LD_INT 1
3254: DEC
3255: ST_TO_ADDR
3256: LD_INT 2
3258: PUSH
3259: FOR_TO
3260: IFFALSE 3321
// begin un := CreateHumanWithClass ( 1 , skill_level ) ;
3262: LD_ADDR_VAR 0 4
3266: PUSH
3267: LD_INT 1
3269: PPUSH
3270: LD_EXP 32
3274: PPUSH
3275: CALL 55 0 2
3279: ST_TO_ADDR
// PlaceUnitArea ( un , ar_bunker_spawn , false ) ;
3280: LD_VAR 0 4
3284: PPUSH
3285: LD_INT 6
3287: PPUSH
3288: LD_INT 0
3290: PPUSH
3291: CALL_OW 49
// ComEnterUnit ( un , NearestUnitToUnit ( bunkers , un ) ) ;
3295: LD_VAR 0 4
3299: PPUSH
3300: LD_VAR 0 6
3304: PPUSH
3305: LD_VAR 0 4
3309: PPUSH
3310: CALL_OW 74
3314: PPUSH
3315: CALL_OW 120
// end ;
3319: GO 3259
3321: POP
3322: POP
// hc_name := Erwin van der Veen ;
3323: LD_ADDR_OWVAR 26
3327: PUSH
3328: LD_STRING Erwin van der Veen
3330: ST_TO_ADDR
// hc_gallery := sandar ;
3331: LD_ADDR_OWVAR 33
3335: PUSH
3336: LD_STRING sandar
3338: ST_TO_ADDR
// hc_face_number := 35 ;
3339: LD_ADDR_OWVAR 34
3343: PUSH
3344: LD_INT 35
3346: ST_TO_ADDR
// hc_basic_skills := [ 3 , 0 , 0 , 0 ] ;
3347: LD_ADDR_OWVAR 30
3351: PUSH
3352: LD_INT 3
3354: PUSH
3355: LD_INT 0
3357: PUSH
3358: LD_INT 0
3360: PUSH
3361: LD_INT 0
3363: PUSH
3364: EMPTY
3365: LIST
3366: LIST
3367: LIST
3368: LIST
3369: ST_TO_ADDR
// hc_skills := [ 7 , 2 , 4 , 1 ] ;
3370: LD_ADDR_OWVAR 31
3374: PUSH
3375: LD_INT 7
3377: PUSH
3378: LD_INT 2
3380: PUSH
3381: LD_INT 4
3383: PUSH
3384: LD_INT 1
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: ST_TO_ADDR
// hc_importance := 50 ;
3393: LD_ADDR_OWVAR 32
3397: PUSH
3398: LD_INT 50
3400: ST_TO_ADDR
// hc_sex := sex_male ;
3401: LD_ADDR_OWVAR 27
3405: PUSH
3406: LD_INT 1
3408: ST_TO_ADDR
// Erwin := CreateHuman ;
3409: LD_ADDR_EXP 31
3413: PUSH
3414: CALL_OW 44
3418: ST_TO_ADDR
// PlaceUnitXY ( Erwin , 102 , 120 , false ) ;
3419: LD_EXP 31
3423: PPUSH
3424: LD_INT 102
3426: PPUSH
3427: LD_INT 120
3429: PPUSH
3430: LD_INT 0
3432: PPUSH
3433: CALL_OW 48
// hc_importance := 15 ;
3437: LD_ADDR_OWVAR 32
3441: PUSH
3442: LD_INT 15
3444: ST_TO_ADDR
// for i = 1 to 7 do
3445: LD_ADDR_VAR 0 2
3449: PUSH
3450: DOUBLE
3451: LD_INT 1
3453: DEC
3454: ST_TO_ADDR
3455: LD_INT 7
3457: PUSH
3458: FOR_TO
3459: IFFALSE 3512
// begin un := CreateHumanWithClass ( 2 , skill_level ) ;
3461: LD_ADDR_VAR 0 4
3465: PUSH
3466: LD_INT 2
3468: PPUSH
3469: LD_EXP 32
3473: PPUSH
3474: CALL 55 0 2
3478: ST_TO_ADDR
// PlaceUnitArea ( un , ar_south_spawn , false ) ;
3479: LD_VAR 0 4
3483: PPUSH
3484: LD_INT 8
3486: PPUSH
3487: LD_INT 0
3489: PPUSH
3490: CALL_OW 49
// ar_engs := ar_engs ^ un ;
3494: LD_ADDR_EXP 28
3498: PUSH
3499: LD_EXP 28
3503: PUSH
3504: LD_VAR 0 4
3508: ADD
3509: ST_TO_ADDR
// end ;
3510: GO 3458
3512: POP
3513: POP
// for i = 1 to 2 do
3514: LD_ADDR_VAR 0 2
3518: PUSH
3519: DOUBLE
3520: LD_INT 1
3522: DEC
3523: ST_TO_ADDR
3524: LD_INT 2
3526: PUSH
3527: FOR_TO
3528: IFFALSE 3570
// PlaceHumanInUnit ( CreateHumanWithClass ( 3 , skill_level ) , FilterAllUnits ( [ f_weapon , ar_rocket_launcher ] ) [ i ] ) ;
3530: LD_INT 3
3532: PPUSH
3533: LD_EXP 32
3537: PPUSH
3538: CALL 55 0 2
3542: PPUSH
3543: LD_INT 34
3545: PUSH
3546: LD_INT 28
3548: PUSH
3549: EMPTY
3550: LIST
3551: LIST
3552: PPUSH
3553: CALL_OW 69
3557: PUSH
3558: LD_VAR 0 2
3562: ARRAY
3563: PPUSH
3564: CALL_OW 52
3568: GO 3527
3570: POP
3571: POP
// for i = 1 to 3 do
3572: LD_ADDR_VAR 0 2
3576: PUSH
3577: DOUBLE
3578: LD_INT 1
3580: DEC
3581: ST_TO_ADDR
3582: LD_INT 3
3584: PUSH
3585: FOR_TO
3586: IFFALSE 3639
// begin un := CreateHumanWithClass ( 3 , skill_level ) ;
3588: LD_ADDR_VAR 0 4
3592: PUSH
3593: LD_INT 3
3595: PPUSH
3596: LD_EXP 32
3600: PPUSH
3601: CALL 55 0 2
3605: ST_TO_ADDR
// PlaceUnitArea ( un , ar_south_spawn , false ) ;
3606: LD_VAR 0 4
3610: PPUSH
3611: LD_INT 8
3613: PPUSH
3614: LD_INT 0
3616: PPUSH
3617: CALL_OW 49
// ar_mechs := ar_mechs ^ un ;
3621: LD_ADDR_EXP 29
3625: PUSH
3626: LD_EXP 29
3630: PUSH
3631: LD_VAR 0 4
3635: ADD
3636: ST_TO_ADDR
// end ;
3637: GO 3585
3639: POP
3640: POP
// end ;
3641: LD_VAR 0 1
3645: RET
// every 0 0$01 trigger game_started do var i , filter ;
3646: LD_EXP 33
3650: IFFALSE 3843
3652: GO 3654
3654: DISABLE
3655: LD_INT 0
3657: PPUSH
3658: PPUSH
// begin enable ;
3659: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) ;
3660: LD_ADDR_VAR 0 2
3664: PUSH
3665: LD_INT 22
3667: PUSH
3668: LD_INT 8
3670: PUSH
3671: EMPTY
3672: LIST
3673: LIST
3674: PUSH
3675: LD_INT 25
3677: PUSH
3678: LD_INT 2
3680: PUSH
3681: EMPTY
3682: LIST
3683: LIST
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PPUSH
3689: CALL_OW 69
3693: ST_TO_ADDR
// if ar_build_list > 0 then
3694: LD_EXP 25
3698: PUSH
3699: LD_INT 0
3701: GREATER
3702: IFFALSE 3843
// if filter > 0 then
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 0
3711: GREATER
3712: IFFALSE 3843
// for i = 1 to filter do
3714: LD_ADDR_VAR 0 1
3718: PUSH
3719: DOUBLE
3720: LD_INT 1
3722: DEC
3723: ST_TO_ADDR
3724: LD_VAR 0 2
3728: PUSH
3729: FOR_TO
3730: IFFALSE 3841
// begin if not HasTask ( filter [ i ] ) and FilterAllUnits ( [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) = 0 then
3732: LD_VAR 0 2
3736: PUSH
3737: LD_VAR 0 1
3741: ARRAY
3742: PPUSH
3743: CALL_OW 314
3747: NOT
3748: PUSH
3749: LD_INT 2
3751: PUSH
3752: LD_INT 22
3754: PUSH
3755: LD_INT 3
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 6
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 0
3784: EQUAL
3785: AND
3786: IFFALSE 3839
// AddComBuild ( filter [ i ] , ar_build_list [ 1 ] , ar_build_list [ 2 ] , ar_build_list [ 3 ] , ar_build_list [ 4 ] ) ;
3788: LD_VAR 0 2
3792: PUSH
3793: LD_VAR 0 1
3797: ARRAY
3798: PPUSH
3799: LD_EXP 25
3803: PUSH
3804: LD_INT 1
3806: ARRAY
3807: PPUSH
3808: LD_EXP 25
3812: PUSH
3813: LD_INT 2
3815: ARRAY
3816: PPUSH
3817: LD_EXP 25
3821: PUSH
3822: LD_INT 3
3824: ARRAY
3825: PPUSH
3826: LD_EXP 25
3830: PUSH
3831: LD_INT 4
3833: ARRAY
3834: PPUSH
3835: CALL_OW 205
// end ;
3839: GO 3729
3841: POP
3842: POP
// end ;
3843: PPOPN 2
3845: END
// every 0 0$05 trigger ar_res do
3846: LD_EXP 34
3850: IFFALSE 3884
3852: GO 3854
3854: DISABLE
// begin enable ;
3855: ENABLE
// if ar_tech_list > 0 then
3856: LD_EXP 26
3860: PUSH
3861: LD_INT 0
3863: GREATER
3864: IFFALSE 3884
// ComResearch ( ar_lab , ar_tech_list [ 1 ] ) ;
3866: LD_EXP 30
3870: PPUSH
3871: LD_EXP 26
3875: PUSH
3876: LD_INT 1
3878: ARRAY
3879: PPUSH
3880: CALL_OW 124
// end ;
3884: END
// every 0 0$03 trigger ar_produce do var fac ;
3885: LD_EXP 35
3889: IFFALSE 4024
3891: GO 3893
3893: DISABLE
3894: LD_INT 0
3896: PPUSH
// begin enable ;
3897: ENABLE
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) ;
3898: LD_ADDR_VAR 0 1
3902: PUSH
3903: LD_INT 22
3905: PUSH
3906: LD_INT 8
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: PUSH
3913: LD_INT 30
3915: PUSH
3916: LD_INT 3
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PUSH
3923: EMPTY
3924: LIST
3925: LIST
3926: PPUSH
3927: CALL_OW 69
3931: ST_TO_ADDR
// if ar_produce_list > 0 then
3932: LD_EXP 27
3936: PUSH
3937: LD_INT 0
3939: GREATER
3940: IFFALSE 4024
// if CanBeConstructed ( fac [ 1 ] , ar_half_tracked , engine_combustion , control_manual , ar_produce_list [ 1 ] ) then
3942: LD_VAR 0 1
3946: PUSH
3947: LD_INT 1
3949: ARRAY
3950: PPUSH
3951: LD_INT 14
3953: PPUSH
3954: LD_INT 1
3956: PPUSH
3957: LD_INT 1
3959: PPUSH
3960: LD_EXP 27
3964: PUSH
3965: LD_INT 1
3967: ARRAY
3968: PPUSH
3969: CALL_OW 448
3973: IFFALSE 4024
// begin ComConstruct ( fac [ 1 ] , ar_half_tracked , engine_combustion , control_manual , ar_produce_list [ 1 ] ) ;
3975: LD_VAR 0 1
3979: PUSH
3980: LD_INT 1
3982: ARRAY
3983: PPUSH
3984: LD_INT 14
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 1
3992: PPUSH
3993: LD_EXP 27
3997: PUSH
3998: LD_INT 1
4000: ARRAY
4001: PPUSH
4002: CALL_OW 125
// ar_produce_list := Delete ( ar_produce_list , 1 ) ;
4006: LD_ADDR_EXP 27
4010: PUSH
4011: LD_EXP 27
4015: PPUSH
4016: LD_INT 1
4018: PPUSH
4019: CALL_OW 3
4023: ST_TO_ADDR
// end ; end ;
4024: PPOPN 1
4026: END
// every 0 0$10 trigger GetResourceType ( GetBase ( north_dep ) , mat_cans ) >= 200 and game_started do var sor ;
4027: LD_INT 2
4029: PPUSH
4030: CALL_OW 274
4034: PPUSH
4035: LD_INT 1
4037: PPUSH
4038: CALL_OW 275
4042: PUSH
4043: LD_INT 200
4045: GREATEREQUAL
4046: PUSH
4047: LD_EXP 33
4051: AND
4052: IFFALSE 4124
4054: GO 4056
4056: DISABLE
4057: LD_INT 0
4059: PPUSH
// begin enable ;
4060: ENABLE
// sor := GetResourceType ( GetBase ( south_dep ) , mat_cans ) ;
4061: LD_ADDR_VAR 0 1
4065: PUSH
4066: LD_INT 6
4068: PPUSH
4069: CALL_OW 274
4073: PPUSH
4074: LD_INT 1
4076: PPUSH
4077: CALL_OW 275
4081: ST_TO_ADDR
// SetResourceType ( GetBase ( south_dep ) , mat_cans , sor + 100 ) ;
4082: LD_INT 6
4084: PPUSH
4085: CALL_OW 274
4089: PPUSH
4090: LD_INT 1
4092: PPUSH
4093: LD_VAR 0 1
4097: PUSH
4098: LD_INT 100
4100: PLUS
4101: PPUSH
4102: CALL_OW 277
// SetResourceType ( GetBase ( north_dep ) , mat_cans , 100 ) ;
4106: LD_INT 2
4108: PPUSH
4109: CALL_OW 274
4113: PPUSH
4114: LD_INT 1
4116: PPUSH
4117: LD_INT 100
4119: PPUSH
4120: CALL_OW 277
// end ;
4124: PPOPN 1
4126: END
// every 0 0$03 trigger game_started do var i , c , p , skr , filter , cargo , dep ;
4127: LD_EXP 33
4131: IFFALSE 4666
4133: GO 4135
4135: DISABLE
4136: LD_INT 0
4138: PPUSH
4139: PPUSH
4140: PPUSH
4141: PPUSH
4142: PPUSH
4143: PPUSH
4144: PPUSH
// begin enable ;
4145: ENABLE
// filter := FilterAllUnits ( [ [ f_ok ] , [ f_side , 8 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
4146: LD_ADDR_VAR 0 5
4150: PUSH
4151: LD_INT 50
4153: PUSH
4154: EMPTY
4155: LIST
4156: PUSH
4157: LD_INT 22
4159: PUSH
4160: LD_INT 8
4162: PUSH
4163: EMPTY
4164: LIST
4165: LIST
4166: PUSH
4167: LD_INT 2
4169: PUSH
4170: LD_INT 25
4172: PUSH
4173: LD_INT 2
4175: PUSH
4176: EMPTY
4177: LIST
4178: LIST
4179: PUSH
4180: LD_INT 25
4182: PUSH
4183: LD_INT 16
4185: PUSH
4186: EMPTY
4187: LIST
4188: LIST
4189: PUSH
4190: EMPTY
4191: LIST
4192: LIST
4193: LIST
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: LIST
4199: PPUSH
4200: CALL_OW 69
4204: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4205: LD_ADDR_VAR 0 6
4209: PUSH
4210: LD_INT 22
4212: PUSH
4213: LD_INT 8
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: LD_INT 34
4222: PUSH
4223: LD_INT 32
4225: PUSH
4226: EMPTY
4227: LIST
4228: LIST
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PPUSH
4234: CALL_OW 69
4238: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
4239: LD_ADDR_VAR 0 7
4243: PUSH
4244: LD_INT 22
4246: PUSH
4247: LD_INT 8
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PUSH
4254: LD_INT 2
4256: PUSH
4257: LD_INT 30
4259: PUSH
4260: LD_INT 0
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: PUSH
4267: LD_INT 30
4269: PUSH
4270: LD_INT 1
4272: PUSH
4273: EMPTY
4274: LIST
4275: LIST
4276: PUSH
4277: EMPTY
4278: LIST
4279: LIST
4280: LIST
4281: PUSH
4282: EMPTY
4283: LIST
4284: LIST
4285: PPUSH
4286: CALL_OW 69
4290: ST_TO_ADDR
// skr = GetListOfCratesInArea ( crates_spawn ) ;
4291: LD_ADDR_VAR 0 4
4295: PUSH
4296: LD_INT 5
4298: PPUSH
4299: CALL_OW 435
4303: ST_TO_ADDR
// c = 1 ;
4304: LD_ADDR_VAR 0 2
4308: PUSH
4309: LD_INT 1
4311: ST_TO_ADDR
// while c < skr do
4312: LD_VAR 0 2
4316: PUSH
4317: LD_VAR 0 4
4321: LESS
4322: IFFALSE 4666
// begin if FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) = 0 then
4324: LD_INT 22
4326: PUSH
4327: LD_INT 8
4329: PUSH
4330: EMPTY
4331: LIST
4332: LIST
4333: PUSH
4334: LD_INT 34
4336: PUSH
4337: LD_INT 32
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PPUSH
4348: CALL_OW 69
4352: PUSH
4353: LD_INT 0
4355: EQUAL
4356: IFFALSE 4498
// begin for p = 1 to 2 do
4358: LD_ADDR_VAR 0 3
4362: PUSH
4363: DOUBLE
4364: LD_INT 1
4366: DEC
4367: ST_TO_ADDR
4368: LD_INT 2
4370: PUSH
4371: FOR_TO
4372: IFFALSE 4482
// if not HasTask ( filter [ p ] ) and GetDistUnitXY ( filter [ p ] , skr [ c ] , skr [ c + 1 ] ) <= 40 then
4374: LD_VAR 0 5
4378: PUSH
4379: LD_VAR 0 3
4383: ARRAY
4384: PPUSH
4385: CALL_OW 314
4389: NOT
4390: PUSH
4391: LD_VAR 0 5
4395: PUSH
4396: LD_VAR 0 3
4400: ARRAY
4401: PPUSH
4402: LD_VAR 0 4
4406: PUSH
4407: LD_VAR 0 2
4411: ARRAY
4412: PPUSH
4413: LD_VAR 0 4
4417: PUSH
4418: LD_VAR 0 2
4422: PUSH
4423: LD_INT 1
4425: PLUS
4426: ARRAY
4427: PPUSH
4428: CALL_OW 297
4432: PUSH
4433: LD_INT 40
4435: LESSEQUAL
4436: AND
4437: IFFALSE 4480
// ComCollect ( filter [ p ] , skr [ c ] , skr [ c + 1 ] ) ;
4439: LD_VAR 0 5
4443: PUSH
4444: LD_VAR 0 3
4448: ARRAY
4449: PPUSH
4450: LD_VAR 0 4
4454: PUSH
4455: LD_VAR 0 2
4459: ARRAY
4460: PPUSH
4461: LD_VAR 0 4
4465: PUSH
4466: LD_VAR 0 2
4470: PUSH
4471: LD_INT 1
4473: PLUS
4474: ARRAY
4475: PPUSH
4476: CALL_OW 117
4480: GO 4371
4482: POP
4483: POP
// c = c + 2 ;
4484: LD_ADDR_VAR 0 2
4488: PUSH
4489: LD_VAR 0 2
4493: PUSH
4494: LD_INT 2
4496: PLUS
4497: ST_TO_ADDR
// end ; if cargo > 0 then
4498: LD_VAR 0 6
4502: PUSH
4503: LD_INT 0
4505: GREATER
4506: IFFALSE 4664
// begin if GetFuel ( cargo [ 1 ] ) > 80 then
4508: LD_VAR 0 6
4512: PUSH
4513: LD_INT 1
4515: ARRAY
4516: PPUSH
4517: CALL_OW 261
4521: PUSH
4522: LD_INT 80
4524: GREATER
4525: IFFALSE 4568
// ComCollect ( cargo [ 1 ] , skr [ c ] , skr [ c + 1 ] ) else
4527: LD_VAR 0 6
4531: PUSH
4532: LD_INT 1
4534: ARRAY
4535: PPUSH
4536: LD_VAR 0 4
4540: PUSH
4541: LD_VAR 0 2
4545: ARRAY
4546: PPUSH
4547: LD_VAR 0 4
4551: PUSH
4552: LD_VAR 0 2
4556: PUSH
4557: LD_INT 1
4559: PLUS
4560: ARRAY
4561: PPUSH
4562: CALL_OW 117
4566: GO 4650
// begin repeat begin ComMoveXY ( cargo [ 1 ] , GetX ( south_dep [ 1 ] ) , GetY ( south_dep [ 1 ] ) ) ;
4568: LD_VAR 0 6
4572: PUSH
4573: LD_INT 1
4575: ARRAY
4576: PPUSH
4577: LD_INT 6
4579: PUSH
4580: LD_INT 1
4582: ARRAY
4583: PPUSH
4584: CALL_OW 250
4588: PPUSH
4589: LD_INT 6
4591: PUSH
4592: LD_INT 1
4594: ARRAY
4595: PPUSH
4596: CALL_OW 251
4600: PPUSH
4601: CALL_OW 111
// Wait ( 0 0$01 ) ;
4605: LD_INT 35
4607: PPUSH
4608: CALL_OW 67
// end until GetDistUnits ( cargo [ 1 ] , south_dep ) < 7 ;
4612: LD_VAR 0 6
4616: PUSH
4617: LD_INT 1
4619: ARRAY
4620: PPUSH
4621: LD_INT 6
4623: PPUSH
4624: CALL_OW 296
4628: PUSH
4629: LD_INT 7
4631: LESS
4632: IFFALSE 4568
// SetFuel ( cargo [ 1 ] , 100 ) ;
4634: LD_VAR 0 6
4638: PUSH
4639: LD_INT 1
4641: ARRAY
4642: PPUSH
4643: LD_INT 100
4645: PPUSH
4646: CALL_OW 240
// end ; c = c + 2 ;
4650: LD_ADDR_VAR 0 2
4654: PUSH
4655: LD_VAR 0 2
4659: PUSH
4660: LD_INT 2
4662: PLUS
4663: ST_TO_ADDR
// end ; end ;
4664: GO 4312
// end ;
4666: PPOPN 7
4668: END
// every 0 0$01 trigger game_started do var i , barracks ;
4669: LD_EXP 33
4673: IFFALSE 4980
4675: GO 4677
4677: DISABLE
4678: LD_INT 0
4680: PPUSH
4681: PPUSH
// begin enable ;
4682: ENABLE
// barracks := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4683: LD_ADDR_VAR 0 2
4687: PUSH
4688: LD_INT 22
4690: PUSH
4691: LD_INT 8
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: LD_INT 2
4700: PUSH
4701: LD_INT 30
4703: PUSH
4704: LD_INT 4
4706: PUSH
4707: EMPTY
4708: LIST
4709: LIST
4710: PUSH
4711: LD_INT 30
4713: PUSH
4714: LD_INT 5
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: PUSH
4721: EMPTY
4722: LIST
4723: LIST
4724: LIST
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PPUSH
4730: CALL_OW 69
4734: ST_TO_ADDR
// if ar_miners > 0 then
4735: LD_EXP 22
4739: PUSH
4740: LD_INT 0
4742: GREATER
4743: IFFALSE 4980
// for i = 1 to ar_miners do
4745: LD_ADDR_VAR 0 1
4749: PUSH
4750: DOUBLE
4751: LD_INT 1
4753: DEC
4754: ST_TO_ADDR
4755: LD_EXP 22
4759: PUSH
4760: FOR_TO
4761: IFFALSE 4978
// begin if MineAtPos ( mine_x [ i ] , mine_y [ i ] ) = false then
4763: LD_EXP 23
4767: PUSH
4768: LD_VAR 0 1
4772: ARRAY
4773: PPUSH
4774: LD_EXP 24
4778: PUSH
4779: LD_VAR 0 1
4783: ARRAY
4784: PPUSH
4785: CALL_OW 458
4789: PUSH
4790: LD_INT 0
4792: EQUAL
4793: IFFALSE 4976
// begin if not HasTask ( ar_miners [ i ] ) and FilterAllUnits ( [ f_side , 3 ] ) = 0 then
4795: LD_EXP 22
4799: PUSH
4800: LD_VAR 0 1
4804: ARRAY
4805: PPUSH
4806: CALL_OW 314
4810: NOT
4811: PUSH
4812: LD_INT 22
4814: PUSH
4815: LD_INT 3
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PPUSH
4822: CALL_OW 69
4826: PUSH
4827: LD_INT 0
4829: EQUAL
4830: AND
4831: IFFALSE 4976
// begin if IsInUnit ( ar_miners [ i ] ) then
4833: LD_EXP 22
4837: PUSH
4838: LD_VAR 0 1
4842: ARRAY
4843: PPUSH
4844: CALL_OW 310
4848: IFFALSE 4865
// ComExitBuilding ( ar_miners [ i ] ) ;
4850: LD_EXP 22
4854: PUSH
4855: LD_VAR 0 1
4859: ARRAY
4860: PPUSH
4861: CALL_OW 122
// AddComPlaceRemoteCharge ( ar_miners [ i ] , mine_x [ i ] , mine_y [ i ] , 0 ) ;
4865: LD_EXP 22
4869: PUSH
4870: LD_VAR 0 1
4874: ARRAY
4875: PPUSH
4876: LD_EXP 23
4880: PUSH
4881: LD_VAR 0 1
4885: ARRAY
4886: PPUSH
4887: LD_EXP 24
4891: PUSH
4892: LD_VAR 0 1
4896: ARRAY
4897: PPUSH
4898: LD_INT 0
4900: PPUSH
4901: CALL_OW 193
// repeat Wait ( 0 0$01 ) ;
4905: LD_INT 35
4907: PPUSH
4908: CALL_OW 67
// until MineAtPos ( mine_x [ i ] , mine_y [ i ] ) ;
4912: LD_EXP 23
4916: PUSH
4917: LD_VAR 0 1
4921: ARRAY
4922: PPUSH
4923: LD_EXP 24
4927: PUSH
4928: LD_VAR 0 1
4932: ARRAY
4933: PPUSH
4934: CALL_OW 458
4938: IFFALSE 4905
// ComEnterUnit ( ar_miners [ i ] , NearestUnitToUnit ( barracks , ar_miners [ i ] ) ) ;
4940: LD_EXP 22
4944: PUSH
4945: LD_VAR 0 1
4949: ARRAY
4950: PPUSH
4951: LD_VAR 0 2
4955: PPUSH
4956: LD_EXP 22
4960: PUSH
4961: LD_VAR 0 1
4965: ARRAY
4966: PPUSH
4967: CALL_OW 74
4971: PPUSH
4972: CALL_OW 120
// end ; end ; end ;
4976: GO 4760
4978: POP
4979: POP
// end ;
4980: PPOPN 2
4982: END
// every 0 0$0.7 trigger game_started do var i , h , filter ;
4983: LD_EXP 33
4987: IFFALSE 5162
4989: GO 4991
4991: DISABLE
4992: LD_INT 0
4994: PPUSH
4995: PPUSH
4996: PPUSH
// begin enable ;
4997: ENABLE
// filter := FilterAllUnits ( [ f_side , 3 ] ) ;
4998: LD_ADDR_VAR 0 3
5002: PUSH
5003: LD_INT 22
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 69
5017: ST_TO_ADDR
// for i = 1 to filter do
5018: LD_ADDR_VAR 0 1
5022: PUSH
5023: DOUBLE
5024: LD_INT 1
5026: DEC
5027: ST_TO_ADDR
5028: LD_VAR 0 3
5032: PUSH
5033: FOR_TO
5034: IFFALSE 5160
// begin for h = 1 to mine_x do
5036: LD_ADDR_VAR 0 2
5040: PUSH
5041: DOUBLE
5042: LD_INT 1
5044: DEC
5045: ST_TO_ADDR
5046: LD_EXP 23
5050: PUSH
5051: FOR_TO
5052: IFFALSE 5156
// begin if MineAtPos ( mine_x [ h ] , mine_y [ h ] ) then
5054: LD_EXP 23
5058: PUSH
5059: LD_VAR 0 2
5063: ARRAY
5064: PPUSH
5065: LD_EXP 24
5069: PUSH
5070: LD_VAR 0 2
5074: ARRAY
5075: PPUSH
5076: CALL_OW 458
5080: IFFALSE 5154
// if GetDistUnitXY ( filter [ i ] , mine_x [ h ] , mine_y [ h ] ) <= 2 then
5082: LD_VAR 0 3
5086: PUSH
5087: LD_VAR 0 1
5091: ARRAY
5092: PPUSH
5093: LD_EXP 23
5097: PUSH
5098: LD_VAR 0 2
5102: ARRAY
5103: PPUSH
5104: LD_EXP 24
5108: PUSH
5109: LD_VAR 0 2
5113: ARRAY
5114: PPUSH
5115: CALL_OW 297
5119: PUSH
5120: LD_INT 2
5122: LESSEQUAL
5123: IFFALSE 5154
// LaunchMineAtPos ( mine_x [ h ] , mine_y [ h ] , 8 ) ;
5125: LD_EXP 23
5129: PUSH
5130: LD_VAR 0 2
5134: ARRAY
5135: PPUSH
5136: LD_EXP 24
5140: PUSH
5141: LD_VAR 0 2
5145: ARRAY
5146: PPUSH
5147: LD_INT 8
5149: PPUSH
5150: CALL_OW 456
// end ;
5154: GO 5051
5156: POP
5157: POP
// end ;
5158: GO 5033
5160: POP
5161: POP
// end ;
5162: PPOPN 3
5164: END
// every 0 0$01 trigger game_started do var i , un , filter , fac ;
5165: LD_EXP 33
5169: IFFALSE 5821
5171: GO 5173
5173: DISABLE
5174: LD_INT 0
5176: PPUSH
5177: PPUSH
5178: PPUSH
5179: PPUSH
// begin enable ;
5180: ENABLE
// filter := FilterAllUnits ( [ [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , ar_gun ] , [ f_weapon , ar_gatling_gun ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ar_flame_thrower ] ] ] ] ) ;
5181: LD_ADDR_VAR 0 3
5185: PUSH
5186: LD_INT 22
5188: PUSH
5189: LD_INT 8
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 21
5198: PUSH
5199: LD_INT 2
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: LD_INT 34
5211: PUSH
5212: LD_INT 27
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: PUSH
5219: LD_INT 34
5221: PUSH
5222: LD_INT 25
5224: PUSH
5225: EMPTY
5226: LIST
5227: LIST
5228: PUSH
5229: LD_INT 34
5231: PUSH
5232: LD_INT 28
5234: PUSH
5235: EMPTY
5236: LIST
5237: LIST
5238: PUSH
5239: LD_INT 34
5241: PUSH
5242: LD_INT 26
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: LIST
5253: LIST
5254: LIST
5255: PUSH
5256: EMPTY
5257: LIST
5258: LIST
5259: LIST
5260: PUSH
5261: EMPTY
5262: LIST
5263: PPUSH
5264: CALL_OW 69
5268: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) ;
5269: LD_ADDR_VAR 0 4
5273: PUSH
5274: LD_INT 22
5276: PUSH
5277: LD_INT 8
5279: PUSH
5280: EMPTY
5281: LIST
5282: LIST
5283: PUSH
5284: LD_INT 30
5286: PUSH
5287: LD_INT 3
5289: PUSH
5290: EMPTY
5291: LIST
5292: LIST
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: PPUSH
5298: CALL_OW 69
5302: ST_TO_ADDR
// if ar_mechs = [ ] then
5303: LD_EXP 29
5307: PUSH
5308: EMPTY
5309: EQUAL
5310: IFFALSE 5384
// begin for i = 1 to 3 do
5312: LD_ADDR_VAR 0 1
5316: PUSH
5317: DOUBLE
5318: LD_INT 1
5320: DEC
5321: ST_TO_ADDR
5322: LD_INT 3
5324: PUSH
5325: FOR_TO
5326: IFFALSE 5382
// begin un := CreateHumanWithClass ( 3 , skill_level ) ;
5328: LD_ADDR_VAR 0 2
5332: PUSH
5333: LD_INT 3
5335: PPUSH
5336: LD_EXP 32
5340: PPUSH
5341: CALL 55 0 2
5345: ST_TO_ADDR
// ar_mechs := ar_mechs ^ un ;
5346: LD_ADDR_EXP 29
5350: PUSH
5351: LD_EXP 29
5355: PUSH
5356: LD_VAR 0 2
5360: ADD
5361: ST_TO_ADDR
// ComEnterUnit ( un , fac [ 1 ] ) ;
5362: LD_VAR 0 2
5366: PPUSH
5367: LD_VAR 0 4
5371: PUSH
5372: LD_INT 1
5374: ARRAY
5375: PPUSH
5376: CALL_OW 120
// end ;
5380: GO 5325
5382: POP
5383: POP
// end ; if filter > 0 and FilterAllUnits ( [ f_enemy , 8 ] ) = 0 then
5384: LD_VAR 0 3
5388: PUSH
5389: LD_INT 0
5391: GREATER
5392: PUSH
5393: LD_INT 81
5395: PUSH
5396: LD_INT 8
5398: PUSH
5399: EMPTY
5400: LIST
5401: LIST
5402: PPUSH
5403: CALL_OW 69
5407: PUSH
5408: LD_INT 0
5410: EQUAL
5411: AND
5412: IFFALSE 5527
// begin for i = 1 to filter do
5414: LD_ADDR_VAR 0 1
5418: PUSH
5419: DOUBLE
5420: LD_INT 1
5422: DEC
5423: ST_TO_ADDR
5424: LD_VAR 0 3
5428: PUSH
5429: FOR_TO
5430: IFFALSE 5525
// if GetFuel ( filter [ i ] ) < 30 then
5432: LD_VAR 0 3
5436: PUSH
5437: LD_VAR 0 1
5441: ARRAY
5442: PPUSH
5443: CALL_OW 261
5447: PUSH
5448: LD_INT 30
5450: LESS
5451: IFFALSE 5523
// begin ComMoveXY ( filter [ i ] , 110 , 123 ) ;
5453: LD_VAR 0 3
5457: PUSH
5458: LD_VAR 0 1
5462: ARRAY
5463: PPUSH
5464: LD_INT 110
5466: PPUSH
5467: LD_INT 123
5469: PPUSH
5470: CALL_OW 111
// repeat Wait ( 0 0$01 ) ;
5474: LD_INT 35
5476: PPUSH
5477: CALL_OW 67
// until GetDistUnits ( filter [ i ] , south_dep ) < 4 ;
5481: LD_VAR 0 3
5485: PUSH
5486: LD_VAR 0 1
5490: ARRAY
5491: PPUSH
5492: LD_INT 6
5494: PPUSH
5495: CALL_OW 296
5499: PUSH
5500: LD_INT 4
5502: LESS
5503: IFFALSE 5474
// SetFuel ( filter [ i ] , 100 ) ;
5505: LD_VAR 0 3
5509: PUSH
5510: LD_VAR 0 1
5514: ARRAY
5515: PPUSH
5516: LD_INT 100
5518: PPUSH
5519: CALL_OW 240
// end ;
5523: GO 5429
5525: POP
5526: POP
// end ; if filter > 0 then
5527: LD_VAR 0 3
5531: PUSH
5532: LD_INT 0
5534: GREATER
5535: IFFALSE 5640
// begin for i = 1 to filter do
5537: LD_ADDR_VAR 0 1
5541: PUSH
5542: DOUBLE
5543: LD_INT 1
5545: DEC
5546: ST_TO_ADDR
5547: LD_VAR 0 3
5551: PUSH
5552: FOR_TO
5553: IFFALSE 5638
// if GetFuel ( filter [ i ] ) > 90 and GetLives ( filter [ i ] ) = 1000 and not IsInArea ( filter [ i ] , ar_mobile_def ) then
5555: LD_VAR 0 3
5559: PUSH
5560: LD_VAR 0 1
5564: ARRAY
5565: PPUSH
5566: CALL_OW 261
5570: PUSH
5571: LD_INT 90
5573: GREATER
5574: PUSH
5575: LD_VAR 0 3
5579: PUSH
5580: LD_VAR 0 1
5584: ARRAY
5585: PPUSH
5586: CALL_OW 256
5590: PUSH
5591: LD_INT 1000
5593: EQUAL
5594: AND
5595: PUSH
5596: LD_VAR 0 3
5600: PUSH
5601: LD_VAR 0 1
5605: ARRAY
5606: PPUSH
5607: LD_INT 9
5609: PPUSH
5610: CALL_OW 308
5614: NOT
5615: AND
5616: IFFALSE 5636
// ComMoveToArea ( filter [ i ] , ar_mobile_def ) ;
5618: LD_VAR 0 3
5622: PUSH
5623: LD_VAR 0 1
5627: ARRAY
5628: PPUSH
5629: LD_INT 9
5631: PPUSH
5632: CALL_OW 113
5636: GO 5552
5638: POP
5639: POP
// end ; if filter > 0 then
5640: LD_VAR 0 3
5644: PUSH
5645: LD_INT 0
5647: GREATER
5648: IFFALSE 5821
// begin for i = 1 to filter do
5650: LD_ADDR_VAR 0 1
5654: PUSH
5655: DOUBLE
5656: LD_INT 1
5658: DEC
5659: ST_TO_ADDR
5660: LD_VAR 0 3
5664: PUSH
5665: FOR_TO
5666: IFFALSE 5819
// if GetLives ( filter [ i ] ) <= 650 then
5668: LD_VAR 0 3
5672: PUSH
5673: LD_VAR 0 1
5677: ARRAY
5678: PPUSH
5679: CALL_OW 256
5683: PUSH
5684: LD_INT 650
5686: LESSEQUAL
5687: IFFALSE 5817
// begin un := IsDrivenBy ( filter [ i ] ) ;
5689: LD_ADDR_VAR 0 2
5693: PUSH
5694: LD_VAR 0 3
5698: PUSH
5699: LD_VAR 0 1
5703: ARRAY
5704: PPUSH
5705: CALL_OW 311
5709: ST_TO_ADDR
// ComMoveToArea ( filter [ i ] , ar_repair_zone ) ;
5710: LD_VAR 0 3
5714: PUSH
5715: LD_VAR 0 1
5719: ARRAY
5720: PPUSH
5721: LD_INT 10
5723: PPUSH
5724: CALL_OW 113
// AddComExitVehicle ( un ) ;
5728: LD_VAR 0 2
5732: PPUSH
5733: CALL_OW 181
// AddComRepairVehicle ( un , filter [ i ] ) ;
5737: LD_VAR 0 2
5741: PPUSH
5742: LD_VAR 0 3
5746: PUSH
5747: LD_VAR 0 1
5751: ARRAY
5752: PPUSH
5753: CALL_OW 189
// repeat Wait ( 0 0$01 ) ;
5757: LD_INT 35
5759: PPUSH
5760: CALL_OW 67
// until GetLives ( filter [ i ] ) = 1000 ;
5764: LD_VAR 0 3
5768: PUSH
5769: LD_VAR 0 1
5773: ARRAY
5774: PPUSH
5775: CALL_OW 256
5779: PUSH
5780: LD_INT 1000
5782: EQUAL
5783: IFFALSE 5757
// AddComEnterUnit ( un , filter [ i ] ) ;
5785: LD_VAR 0 2
5789: PPUSH
5790: LD_VAR 0 3
5794: PUSH
5795: LD_VAR 0 1
5799: ARRAY
5800: PPUSH
5801: CALL_OW 180
// AddComMoveToArea ( un , ar_mobile_def ) ;
5805: LD_VAR 0 2
5809: PPUSH
5810: LD_INT 9
5812: PPUSH
5813: CALL_OW 173
// end ;
5817: GO 5665
5819: POP
5820: POP
// end ; end ;
5821: PPOPN 4
5823: END
// every 0 0$01 trigger game_started do var filter , heal , sci , buildings , un , i ;
5824: LD_EXP 33
5828: IFFALSE 6166
5830: GO 5832
5832: DISABLE
5833: LD_INT 0
5835: PPUSH
5836: PPUSH
5837: PPUSH
5838: PPUSH
5839: PPUSH
5840: PPUSH
// begin enable ;
5841: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] , [ f_ok ] ] ) ;
5842: LD_ADDR_VAR 0 1
5846: PUSH
5847: LD_INT 22
5849: PUSH
5850: LD_INT 8
5852: PUSH
5853: EMPTY
5854: LIST
5855: LIST
5856: PUSH
5857: LD_INT 25
5859: PUSH
5860: LD_INT 2
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: PUSH
5867: LD_INT 50
5869: PUSH
5870: EMPTY
5871: LIST
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: PPUSH
5878: CALL_OW 69
5882: ST_TO_ADDR
// heal := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] , [ f_not , [ f_lives , 725 ] ] ] ) ;
5883: LD_ADDR_VAR 0 2
5887: PUSH
5888: LD_INT 22
5890: PUSH
5891: LD_INT 8
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: PUSH
5898: LD_INT 25
5900: PUSH
5901: LD_INT 2
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 3
5910: PUSH
5911: LD_INT 24
5913: PUSH
5914: LD_INT 725
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: PUSH
5925: EMPTY
5926: LIST
5927: LIST
5928: LIST
5929: PPUSH
5930: CALL_OW 69
5934: ST_TO_ADDR
// buildings := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5935: LD_ADDR_VAR 0 4
5939: PUSH
5940: LD_INT 22
5942: PUSH
5943: LD_INT 8
5945: PUSH
5946: EMPTY
5947: LIST
5948: LIST
5949: PUSH
5950: LD_INT 21
5952: PUSH
5953: LD_INT 3
5955: PUSH
5956: EMPTY
5957: LIST
5958: LIST
5959: PUSH
5960: LD_INT 3
5962: PUSH
5963: LD_INT 24
5965: PUSH
5966: LD_INT 1000
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: PUSH
5977: EMPTY
5978: LIST
5979: LIST
5980: LIST
5981: PPUSH
5982: CALL_OW 69
5986: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
5987: LD_ADDR_VAR 0 3
5991: PUSH
5992: LD_INT 22
5994: PUSH
5995: LD_INT 8
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PUSH
6002: LD_INT 25
6004: PUSH
6005: LD_INT 4
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: PPUSH
6016: CALL_OW 69
6020: ST_TO_ADDR
// for i = 1 to filter do
6021: LD_ADDR_VAR 0 6
6025: PUSH
6026: DOUBLE
6027: LD_INT 1
6029: DEC
6030: ST_TO_ADDR
6031: LD_VAR 0 1
6035: PUSH
6036: FOR_TO
6037: IFFALSE 6107
// begin if IsInUnit ( filter [ i ] ) then
6039: LD_VAR 0 1
6043: PUSH
6044: LD_VAR 0 6
6048: ARRAY
6049: PPUSH
6050: CALL_OW 310
6054: IFFALSE 6071
// ComExitBuilding ( filter [ i ] ) ;
6056: LD_VAR 0 1
6060: PUSH
6061: LD_VAR 0 6
6065: ARRAY
6066: PPUSH
6067: CALL_OW 122
// if buildings > 0 then
6071: LD_VAR 0 4
6075: PUSH
6076: LD_INT 0
6078: GREATER
6079: IFFALSE 6105
// ComRepairBuilding ( filter [ i ] , buildings [ 1 ] ) end ;
6081: LD_VAR 0 1
6085: PUSH
6086: LD_VAR 0 6
6090: ARRAY
6091: PPUSH
6092: LD_VAR 0 4
6096: PUSH
6097: LD_INT 1
6099: ARRAY
6100: PPUSH
6101: CALL_OW 130
6105: GO 6036
6107: POP
6108: POP
// for i = 1 to heal do
6109: LD_ADDR_VAR 0 6
6113: PUSH
6114: DOUBLE
6115: LD_INT 1
6117: DEC
6118: ST_TO_ADDR
6119: LD_VAR 0 2
6123: PUSH
6124: FOR_TO
6125: IFFALSE 6164
// begin ComEnterUnit ( heal [ i ] , ar_lab ) ;
6127: LD_VAR 0 2
6131: PUSH
6132: LD_VAR 0 6
6136: ARRAY
6137: PPUSH
6138: LD_EXP 30
6142: PPUSH
6143: CALL_OW 120
// AddComExitBuilding ( heal [ i ] ) ;
6147: LD_VAR 0 2
6151: PUSH
6152: LD_VAR 0 6
6156: ARRAY
6157: PPUSH
6158: CALL_OW 182
// end ;
6162: GO 6124
6164: POP
6165: POP
// end ;
6166: PPOPN 6
6168: END
// every 0 0$01 trigger game_started do var factory , filter , vehicles , i ;
6169: LD_EXP 33
6173: IFFALSE 6503
6175: GO 6177
6177: DISABLE
6178: LD_INT 0
6180: PPUSH
6181: PPUSH
6182: PPUSH
6183: PPUSH
// begin enable ;
6184: ENABLE
// factory := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) ;
6185: LD_ADDR_VAR 0 1
6189: PUSH
6190: LD_INT 22
6192: PUSH
6193: LD_INT 8
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: PUSH
6200: LD_INT 30
6202: PUSH
6203: LD_INT 3
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: PPUSH
6214: CALL_OW 69
6218: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ [ f_side , 8 ] , [ f_class , 3 ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_driving ] ] ] ] ) ;
6219: LD_ADDR_VAR 0 2
6223: PUSH
6224: LD_INT 22
6226: PUSH
6227: LD_INT 8
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: PUSH
6234: LD_INT 25
6236: PUSH
6237: LD_INT 3
6239: PUSH
6240: EMPTY
6241: LIST
6242: LIST
6243: PUSH
6244: LD_INT 3
6246: PUSH
6247: LD_INT 54
6249: PUSH
6250: EMPTY
6251: LIST
6252: PUSH
6253: EMPTY
6254: LIST
6255: LIST
6256: PUSH
6257: LD_INT 3
6259: PUSH
6260: LD_INT 55
6262: PUSH
6263: EMPTY
6264: LIST
6265: PUSH
6266: EMPTY
6267: LIST
6268: LIST
6269: PUSH
6270: EMPTY
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: PUSH
6276: EMPTY
6277: LIST
6278: PPUSH
6279: CALL_OW 69
6283: ST_TO_ADDR
// vehicles := FilterAllUnits ( [ [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ] ) ;
6284: LD_ADDR_VAR 0 3
6288: PUSH
6289: LD_INT 22
6291: PUSH
6292: LD_INT 8
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: PUSH
6299: LD_INT 21
6301: PUSH
6302: LD_INT 2
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: PUSH
6309: LD_INT 58
6311: PUSH
6312: EMPTY
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: LIST
6319: PUSH
6320: EMPTY
6321: LIST
6322: PPUSH
6323: CALL_OW 69
6327: ST_TO_ADDR
// if factory > 0 and filter > 0 and vehicles = 0 then
6328: LD_VAR 0 1
6332: PUSH
6333: LD_INT 0
6335: GREATER
6336: PUSH
6337: LD_VAR 0 2
6341: PUSH
6342: LD_INT 0
6344: GREATER
6345: AND
6346: PUSH
6347: LD_VAR 0 3
6351: PUSH
6352: LD_INT 0
6354: EQUAL
6355: AND
6356: IFFALSE 6404
// for i = 1 to filter do
6358: LD_ADDR_VAR 0 4
6362: PUSH
6363: DOUBLE
6364: LD_INT 1
6366: DEC
6367: ST_TO_ADDR
6368: LD_VAR 0 2
6372: PUSH
6373: FOR_TO
6374: IFFALSE 6402
// ComEnterUnit ( filter [ i ] , factory [ 1 ] ) ;
6376: LD_VAR 0 2
6380: PUSH
6381: LD_VAR 0 4
6385: ARRAY
6386: PPUSH
6387: LD_VAR 0 1
6391: PUSH
6392: LD_INT 1
6394: ARRAY
6395: PPUSH
6396: CALL_OW 120
6400: GO 6373
6402: POP
6403: POP
// if filter > 0 and vehicles = 0 then
6404: LD_VAR 0 2
6408: PUSH
6409: LD_INT 0
6411: GREATER
6412: PUSH
6413: LD_VAR 0 3
6417: PUSH
6418: LD_INT 0
6420: EQUAL
6421: AND
6422: IFFALSE 6503
// for i = 1 to filter do
6424: LD_ADDR_VAR 0 4
6428: PUSH
6429: DOUBLE
6430: LD_INT 1
6432: DEC
6433: ST_TO_ADDR
6434: LD_VAR 0 2
6438: PUSH
6439: FOR_TO
6440: IFFALSE 6501
// if not GetLives ( filter [ i ] ) = 1000 then
6442: LD_VAR 0 2
6446: PUSH
6447: LD_VAR 0 4
6451: ARRAY
6452: PPUSH
6453: CALL_OW 256
6457: PUSH
6458: LD_INT 1000
6460: EQUAL
6461: NOT
6462: IFFALSE 6499
// begin ComEnterUnit ( filter [ i ] , ar_lab ) ;
6464: LD_VAR 0 2
6468: PUSH
6469: LD_VAR 0 4
6473: ARRAY
6474: PPUSH
6475: LD_EXP 30
6479: PPUSH
6480: CALL_OW 120
// AddComExitBuilding ( filter [ i ] ) ;
6484: LD_VAR 0 2
6488: PUSH
6489: LD_VAR 0 4
6493: ARRAY
6494: PPUSH
6495: CALL_OW 182
// end ;
6499: GO 6439
6501: POP
6502: POP
// end ;
6503: PPOPN 4
6505: END
// every 0 0$01 trigger game_started do var i , filter ;
6506: LD_EXP 33
6510: IFFALSE 6620
6512: GO 6514
6514: DISABLE
6515: LD_INT 0
6517: PPUSH
6518: PPUSH
// begin enable ;
6519: ENABLE
// filter := FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 4 ] ] ) ;
6520: LD_ADDR_VAR 0 2
6524: PUSH
6525: LD_INT 22
6527: PUSH
6528: LD_INT 8
6530: PUSH
6531: EMPTY
6532: LIST
6533: LIST
6534: PUSH
6535: LD_INT 25
6537: PUSH
6538: LD_INT 4
6540: PUSH
6541: EMPTY
6542: LIST
6543: LIST
6544: PUSH
6545: EMPTY
6546: LIST
6547: LIST
6548: PPUSH
6549: CALL_OW 69
6553: ST_TO_ADDR
// if ar_lab then
6554: LD_EXP 30
6558: IFFALSE 6620
// for i = 1 to filter do
6560: LD_ADDR_VAR 0 1
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_VAR 0 2
6574: PUSH
6575: FOR_TO
6576: IFFALSE 6618
// if not HasTask ( filter [ i ] ) then
6578: LD_VAR 0 2
6582: PUSH
6583: LD_VAR 0 1
6587: ARRAY
6588: PPUSH
6589: CALL_OW 314
6593: NOT
6594: IFFALSE 6616
// ComEnterUnit ( filter [ i ] , ar_lab ) ;
6596: LD_VAR 0 2
6600: PUSH
6601: LD_VAR 0 1
6605: ARRAY
6606: PPUSH
6607: LD_EXP 30
6611: PPUSH
6612: CALL_OW 120
6616: GO 6575
6618: POP
6619: POP
// end ; end_of_file
6620: PPOPN 2
6622: END
// every 0 0$20 + 0 0$15 trigger game_started do var i , barracks ;
6623: LD_EXP 33
6627: IFFALSE 6927
6629: GO 6631
6631: DISABLE
6632: LD_INT 0
6634: PPUSH
6635: PPUSH
// begin enable ;
6636: ENABLE
// barracks := FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
6637: LD_ADDR_VAR 0 2
6641: PUSH
6642: LD_INT 22
6644: PUSH
6645: LD_INT 8
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 2
6654: PUSH
6655: LD_INT 30
6657: PUSH
6658: LD_INT 4
6660: PUSH
6661: EMPTY
6662: LIST
6663: LIST
6664: PUSH
6665: LD_INT 30
6667: PUSH
6668: LD_INT 5
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PPUSH
6684: CALL_OW 69
6688: ST_TO_ADDR
// if FilterAllUnits ( [ f_side , 3 ] ) > 0 or FilterAllUnits ( [ f_side , 6 ] ) > 0 then
6689: LD_INT 22
6691: PUSH
6692: LD_INT 3
6694: PUSH
6695: EMPTY
6696: LIST
6697: LIST
6698: PPUSH
6699: CALL_OW 69
6703: PUSH
6704: LD_INT 0
6706: GREATER
6707: PUSH
6708: LD_INT 22
6710: PUSH
6711: LD_INT 6
6713: PUSH
6714: EMPTY
6715: LIST
6716: LIST
6717: PPUSH
6718: CALL_OW 69
6722: PUSH
6723: LD_INT 0
6725: GREATER
6726: OR
6727: IFFALSE 6743
// begin ComEnterUnit ( Erwin , south_dep ) ;
6729: LD_EXP 31
6733: PPUSH
6734: LD_INT 6
6736: PPUSH
6737: CALL_OW 120
// end else
6741: GO 6927
// begin if IsInUnit ( Erwin ) then
6743: LD_EXP 31
6747: PPUSH
6748: CALL_OW 310
6752: IFFALSE 6763
// ComExitBuilding ( Erwin ) ;
6754: LD_EXP 31
6758: PPUSH
6759: CALL_OW 122
// i := Rand ( 1 , 5 ) ;
6763: LD_ADDR_VAR 0 1
6767: PUSH
6768: LD_INT 1
6770: PPUSH
6771: LD_INT 5
6773: PPUSH
6774: CALL_OW 12
6778: ST_TO_ADDR
// if not HasTask ( Erwin ) then
6779: LD_EXP 31
6783: PPUSH
6784: CALL_OW 314
6788: NOT
6789: IFFALSE 6927
// case i of 1 :
6791: LD_VAR 0 1
6795: PUSH
6796: LD_INT 1
6798: DOUBLE
6799: EQUAL
6800: IFTRUE 6804
6802: GO 6822
6804: POP
// ComMoveXY ( Erwin , 69 , 68 ) ; 2 :
6805: LD_EXP 31
6809: PPUSH
6810: LD_INT 69
6812: PPUSH
6813: LD_INT 68
6815: PPUSH
6816: CALL_OW 111
6820: GO 6927
6822: LD_INT 2
6824: DOUBLE
6825: EQUAL
6826: IFTRUE 6830
6828: GO 6848
6830: POP
// ComMoveXY ( Erwin , 59 , 2 ) ; 3 :
6831: LD_EXP 31
6835: PPUSH
6836: LD_INT 59
6838: PPUSH
6839: LD_INT 2
6841: PPUSH
6842: CALL_OW 111
6846: GO 6927
6848: LD_INT 3
6850: DOUBLE
6851: EQUAL
6852: IFTRUE 6856
6854: GO 6874
6856: POP
// ComMoveXY ( Erwin , 154 , 122 ) ; 4 :
6857: LD_EXP 31
6861: PPUSH
6862: LD_INT 154
6864: PPUSH
6865: LD_INT 122
6867: PPUSH
6868: CALL_OW 111
6872: GO 6927
6874: LD_INT 4
6876: DOUBLE
6877: EQUAL
6878: IFTRUE 6882
6880: GO 6900
6882: POP
// ComMoveXY ( Erwin , 59 , 23 ) ; 5 :
6883: LD_EXP 31
6887: PPUSH
6888: LD_INT 59
6890: PPUSH
6891: LD_INT 23
6893: PPUSH
6894: CALL_OW 111
6898: GO 6927
6900: LD_INT 5
6902: DOUBLE
6903: EQUAL
6904: IFTRUE 6908
6906: GO 6926
6908: POP
// ComMoveXY ( Erwin , 108 , 121 ) ; end ;
6909: LD_EXP 31
6913: PPUSH
6914: LD_INT 108
6916: PPUSH
6917: LD_INT 121
6919: PPUSH
6920: CALL_OW 111
6924: GO 6927
6926: POP
// end ; end ;
6927: PPOPN 2
6929: END
// every 0 0$01 trigger GetLives ( Erwin ) < 500 and Difficulty = 1 do
6930: LD_EXP 31
6934: PPUSH
6935: CALL_OW 256
6939: PUSH
6940: LD_INT 500
6942: LESS
6943: PUSH
6944: LD_OWVAR 67
6948: PUSH
6949: LD_INT 1
6951: EQUAL
6952: AND
6953: IFFALSE 6970
6955: GO 6957
6957: DISABLE
// SetLives ( Erwin , 1000 ) ; end_of_file
6958: LD_EXP 31
6962: PPUSH
6963: LD_INT 1000
6965: PPUSH
6966: CALL_OW 234
6970: END
// export game_started , ar_res , ar_produce , rus_skill , rus_red , rus_pink , act_baz , pl_lab , pl_fac , pl_el , pl_opto , dip_points , counter_start , erwin_safe , dip_count ; export function Triggers ; begin
6971: LD_INT 0
6973: PPUSH
// game_started := false ;
6974: LD_ADDR_EXP 33
6978: PUSH
6979: LD_INT 0
6981: ST_TO_ADDR
// counter_start := false ;
6982: LD_ADDR_EXP 45
6986: PUSH
6987: LD_INT 0
6989: ST_TO_ADDR
// ar_res := false ;
6990: LD_ADDR_EXP 34
6994: PUSH
6995: LD_INT 0
6997: ST_TO_ADDR
// ar_produce := false ;
6998: LD_ADDR_EXP 35
7002: PUSH
7003: LD_INT 0
7005: ST_TO_ADDR
// rus_skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
7006: LD_ADDR_EXP 36
7010: PUSH
7011: LD_INT 4
7013: PUSH
7014: LD_INT 5
7016: PUSH
7017: LD_INT 6
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: LIST
7024: PUSH
7025: LD_OWVAR 67
7029: ARRAY
7030: ST_TO_ADDR
// rus_red := false ;
7031: LD_ADDR_EXP 37
7035: PUSH
7036: LD_INT 0
7038: ST_TO_ADDR
// rus_pink := false ;
7039: LD_ADDR_EXP 38
7043: PUSH
7044: LD_INT 0
7046: ST_TO_ADDR
// pl_lab := false ;
7047: LD_ADDR_EXP 40
7051: PUSH
7052: LD_INT 0
7054: ST_TO_ADDR
// pl_opto := false ;
7055: LD_ADDR_EXP 43
7059: PUSH
7060: LD_INT 0
7062: ST_TO_ADDR
// pl_fac := false ;
7063: LD_ADDR_EXP 41
7067: PUSH
7068: LD_INT 0
7070: ST_TO_ADDR
// pl_el := 0 ;
7071: LD_ADDR_EXP 42
7075: PUSH
7076: LD_INT 0
7078: ST_TO_ADDR
// act_baz := false ;
7079: LD_ADDR_EXP 39
7083: PUSH
7084: LD_INT 0
7086: ST_TO_ADDR
// dip_points := 5 ;
7087: LD_ADDR_EXP 44
7091: PUSH
7092: LD_INT 5
7094: ST_TO_ADDR
// erwin_safe := true ;
7095: LD_ADDR_EXP 46
7099: PUSH
7100: LD_INT 1
7102: ST_TO_ADDR
// dip_count := 0 ;
7103: LD_ADDR_EXP 47
7107: PUSH
7108: LD_INT 0
7110: ST_TO_ADDR
// end ; end_of_file
7111: LD_VAR 0 1
7115: RET
// on BuildingComplete ( b ) do var i , side , un ;
7116: LD_INT 0
7118: PPUSH
7119: PPUSH
7120: PPUSH
// begin if GetSide ( b ) = 2 then
7121: LD_VAR 0 1
7125: PPUSH
7126: CALL_OW 255
7130: PUSH
7131: LD_INT 2
7133: EQUAL
7134: IFFALSE 7203
// begin if GetBType ( b ) = b_lab then
7136: LD_VAR 0 1
7140: PPUSH
7141: CALL_OW 266
7145: PUSH
7146: LD_INT 6
7148: EQUAL
7149: IFFALSE 7167
// begin pl_lab := true ;
7151: LD_ADDR_EXP 40
7155: PUSH
7156: LD_INT 1
7158: ST_TO_ADDR
// pl_opto := true ;
7159: LD_ADDR_EXP 43
7163: PUSH
7164: LD_INT 1
7166: ST_TO_ADDR
// end ; if GetBType ( b ) in [ b_solar_power , b_oil_power ] then
7167: LD_VAR 0 1
7171: PPUSH
7172: CALL_OW 266
7176: PUSH
7177: LD_INT 27
7179: PUSH
7180: LD_INT 26
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: IN
7187: IFFALSE 7203
// pl_el := pl_el + 1 ;
7189: LD_ADDR_EXP 42
7193: PUSH
7194: LD_EXP 42
7198: PUSH
7199: LD_INT 1
7201: PLUS
7202: ST_TO_ADDR
// end ; if GetSide ( b ) = 8 then
7203: LD_VAR 0 1
7207: PPUSH
7208: CALL_OW 255
7212: PUSH
7213: LD_INT 8
7215: EQUAL
7216: IFFALSE 7319
// begin for i = 1 to 4 do
7218: LD_ADDR_VAR 0 2
7222: PUSH
7223: DOUBLE
7224: LD_INT 1
7226: DEC
7227: ST_TO_ADDR
7228: LD_INT 4
7230: PUSH
7231: FOR_TO
7232: IFFALSE 7254
// ar_build_list := Delete ( ar_build_list , 1 ) ;
7234: LD_ADDR_EXP 25
7238: PUSH
7239: LD_EXP 25
7243: PPUSH
7244: LD_INT 1
7246: PPUSH
7247: CALL_OW 3
7251: ST_TO_ADDR
7252: GO 7231
7254: POP
7255: POP
// if GetBType ( b ) = b_lab then
7256: LD_VAR 0 1
7260: PPUSH
7261: CALL_OW 266
7265: PUSH
7266: LD_INT 6
7268: EQUAL
7269: IFFALSE 7295
// begin ComUpgradeLab ( b , b_lab_weapon ) ;
7271: LD_VAR 0 1
7275: PPUSH
7276: LD_INT 10
7278: PPUSH
7279: CALL_OW 147
// AddComUpgradeLab ( b , b_lab_opto ) ;
7283: LD_VAR 0 1
7287: PPUSH
7288: LD_INT 15
7290: PPUSH
7291: CALL_OW 207
// end ; if GetBType ( b ) = b_workshop then
7295: LD_VAR 0 1
7299: PPUSH
7300: CALL_OW 266
7304: PUSH
7305: LD_INT 2
7307: EQUAL
7308: IFFALSE 7319
// ComUpgrade ( b ) ;
7310: LD_VAR 0 1
7314: PPUSH
7315: CALL_OW 146
// end ; end ;
7319: PPOPN 4
7321: END
// on UpgradeComplete ( b ) do var i , un ;
7322: LD_INT 0
7324: PPUSH
7325: PPUSH
// begin if GetSide ( b ) = 2 then
7326: LD_VAR 0 1
7330: PPUSH
7331: CALL_OW 255
7335: PUSH
7336: LD_INT 2
7338: EQUAL
7339: IFFALSE 7398
// begin if GetBType ( b ) = b_factory then
7341: LD_VAR 0 1
7345: PPUSH
7346: CALL_OW 266
7350: PUSH
7351: LD_INT 3
7353: EQUAL
7354: IFFALSE 7364
// pl_fac := true ;
7356: LD_ADDR_EXP 41
7360: PUSH
7361: LD_INT 1
7363: ST_TO_ADDR
// if GetBType ( b ) in [ b_lab , b_lab_full , b_lab_opto ] then
7364: LD_VAR 0 1
7368: PPUSH
7369: CALL_OW 266
7373: PUSH
7374: LD_INT 6
7376: PUSH
7377: LD_INT 8
7379: PUSH
7380: LD_INT 15
7382: PUSH
7383: EMPTY
7384: LIST
7385: LIST
7386: LIST
7387: IN
7388: IFFALSE 7398
// pl_opto := true ;
7390: LD_ADDR_EXP 43
7394: PUSH
7395: LD_INT 1
7397: ST_TO_ADDR
// end ; if GetSide ( b ) = 8 then
7398: LD_VAR 0 1
7402: PPUSH
7403: CALL_OW 255
7407: PUSH
7408: LD_INT 8
7410: EQUAL
7411: IFFALSE 7685
// begin if GetBType ( b ) = b_factory then
7413: LD_VAR 0 1
7417: PPUSH
7418: CALL_OW 266
7422: PUSH
7423: LD_INT 3
7425: EQUAL
7426: IFFALSE 7554
// begin for i = 1 to ar_mechs do
7428: LD_ADDR_VAR 0 2
7432: PUSH
7433: DOUBLE
7434: LD_INT 1
7436: DEC
7437: ST_TO_ADDR
7438: LD_EXP 29
7442: PUSH
7443: FOR_TO
7444: IFFALSE 7468
// ComEnterUnit ( ar_mechs [ i ] , b ) ;
7446: LD_EXP 29
7450: PUSH
7451: LD_VAR 0 2
7455: ARRAY
7456: PPUSH
7457: LD_VAR 0 1
7461: PPUSH
7462: CALL_OW 120
7466: GO 7443
7468: POP
7469: POP
// ar_build_list := ar_build_list ^ [ b_ext_stitch ] ^ [ 100 ] ^ [ 117 ] ^ [ 0 ] ;
7470: LD_ADDR_EXP 25
7474: PUSH
7475: LD_EXP 25
7479: PUSH
7480: LD_INT 23
7482: PUSH
7483: EMPTY
7484: LIST
7485: ADD
7486: PUSH
7487: LD_INT 100
7489: PUSH
7490: EMPTY
7491: LIST
7492: ADD
7493: PUSH
7494: LD_INT 117
7496: PUSH
7497: EMPTY
7498: LIST
7499: ADD
7500: PUSH
7501: LD_INT 0
7503: PUSH
7504: EMPTY
7505: LIST
7506: ADD
7507: ST_TO_ADDR
// ar_build_list := ar_build_list ^ [ b_ext_track ] ^ [ 104 ] ^ [ 113 ] ^ [ 4 ] ;
7508: LD_ADDR_EXP 25
7512: PUSH
7513: LD_EXP 25
7517: PUSH
7518: LD_INT 16
7520: PUSH
7521: EMPTY
7522: LIST
7523: ADD
7524: PUSH
7525: LD_INT 104
7527: PUSH
7528: EMPTY
7529: LIST
7530: ADD
7531: PUSH
7532: LD_INT 113
7534: PUSH
7535: EMPTY
7536: LIST
7537: ADD
7538: PUSH
7539: LD_INT 4
7541: PUSH
7542: EMPTY
7543: LIST
7544: ADD
7545: ST_TO_ADDR
// ar_produce := true ;
7546: LD_ADDR_EXP 35
7550: PUSH
7551: LD_INT 1
7553: ST_TO_ADDR
// end ; if GetBType ( b ) in [ b_lab , b_lab_full , b_lab_weapon , b_lab_opto ] then
7554: LD_VAR 0 1
7558: PPUSH
7559: CALL_OW 266
7563: PUSH
7564: LD_INT 6
7566: PUSH
7567: LD_INT 8
7569: PUSH
7570: LD_INT 10
7572: PUSH
7573: LD_INT 15
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: LIST
7580: LIST
7581: IN
7582: IFFALSE 7685
// begin ar_lab := b ;
7584: LD_ADDR_EXP 30
7588: PUSH
7589: LD_VAR 0 1
7593: ST_TO_ADDR
// for i = 1 to 3 do
7594: LD_ADDR_VAR 0 2
7598: PUSH
7599: DOUBLE
7600: LD_INT 1
7602: DEC
7603: ST_TO_ADDR
7604: LD_INT 3
7606: PUSH
7607: FOR_TO
7608: IFFALSE 7675
// begin uc_nation := 2 ;
7610: LD_ADDR_OWVAR 21
7614: PUSH
7615: LD_INT 2
7617: ST_TO_ADDR
// uc_side := 8 ;
7618: LD_ADDR_OWVAR 20
7622: PUSH
7623: LD_INT 8
7625: ST_TO_ADDR
// un := CreateHumanWithClass ( 4 , skill_level ) ;
7626: LD_ADDR_VAR 0 3
7630: PUSH
7631: LD_INT 4
7633: PPUSH
7634: LD_EXP 32
7638: PPUSH
7639: CALL 55 0 2
7643: ST_TO_ADDR
// PlaceUnitArea ( un , ar8_spawn , false ) ;
7644: LD_VAR 0 3
7648: PPUSH
7649: LD_INT 1
7651: PPUSH
7652: LD_INT 0
7654: PPUSH
7655: CALL_OW 49
// ComEnterUnit ( un , b ) ;
7659: LD_VAR 0 3
7663: PPUSH
7664: LD_VAR 0 1
7668: PPUSH
7669: CALL_OW 120
// end ;
7673: GO 7607
7675: POP
7676: POP
// ar_res := true ;
7677: LD_ADDR_EXP 34
7681: PUSH
7682: LD_INT 1
7684: ST_TO_ADDR
// end ; end ; end ;
7685: PPOPN 3
7687: END
// on ResearchComplete ( tech , lab ) do var i , filter , un ;
7688: LD_INT 0
7690: PPUSH
7691: PPUSH
7692: PPUSH
// begin if tech in ar_tech_list then
7693: LD_VAR 0 1
7697: PUSH
7698: LD_EXP 26
7702: IN
7703: IFFALSE 7723
// ar_tech_list := Delete ( ar_tech_list , 1 ) ;
7705: LD_ADDR_EXP 26
7709: PUSH
7710: LD_EXP 26
7714: PPUSH
7715: LD_INT 1
7717: PPUSH
7718: CALL_OW 3
7722: ST_TO_ADDR
// if GetSide ( lab ) = 8 and tech = tech_gun then
7723: LD_VAR 0 2
7727: PPUSH
7728: CALL_OW 255
7732: PUSH
7733: LD_INT 8
7735: EQUAL
7736: PUSH
7737: LD_VAR 0 1
7741: PUSH
7742: LD_INT 39
7744: EQUAL
7745: AND
7746: IFFALSE 7786
// ar_build_list := ar_build_list ^ [ b_ext_gun ] ^ [ 100 ] ^ [ 110 ] ^ [ 3 ] ;
7748: LD_ADDR_EXP 25
7752: PUSH
7753: LD_EXP 25
7757: PUSH
7758: LD_INT 17
7760: PUSH
7761: EMPTY
7762: LIST
7763: ADD
7764: PUSH
7765: LD_INT 100
7767: PUSH
7768: EMPTY
7769: LIST
7770: ADD
7771: PUSH
7772: LD_INT 110
7774: PUSH
7775: EMPTY
7776: LIST
7777: ADD
7778: PUSH
7779: LD_INT 3
7781: PUSH
7782: EMPTY
7783: LIST
7784: ADD
7785: ST_TO_ADDR
// if GetSide ( lab ) = 8 and tech = tech_radar then
7786: LD_VAR 0 2
7790: PPUSH
7791: CALL_OW 255
7795: PUSH
7796: LD_INT 8
7798: EQUAL
7799: PUSH
7800: LD_VAR 0 1
7804: PUSH
7805: LD_INT 6
7807: EQUAL
7808: AND
7809: IFFALSE 7849
// ar_build_list := ar_build_list ^ [ b_ext_radar ] ^ [ 97 ] ^ [ 113 ] ^ [ 1 ] ;
7811: LD_ADDR_EXP 25
7815: PUSH
7816: LD_EXP 25
7820: PUSH
7821: LD_INT 20
7823: PUSH
7824: EMPTY
7825: LIST
7826: ADD
7827: PUSH
7828: LD_INT 97
7830: PUSH
7831: EMPTY
7832: LIST
7833: ADD
7834: PUSH
7835: LD_INT 113
7837: PUSH
7838: EMPTY
7839: LIST
7840: ADD
7841: PUSH
7842: LD_INT 1
7844: PUSH
7845: EMPTY
7846: LIST
7847: ADD
7848: ST_TO_ADDR
// if GetSide ( lab ) = 8 and tech = tech_tech2 then
7849: LD_VAR 0 2
7853: PPUSH
7854: CALL_OW 255
7858: PUSH
7859: LD_INT 8
7861: EQUAL
7862: PUSH
7863: LD_VAR 0 1
7867: PUSH
7868: LD_INT 49
7870: EQUAL
7871: AND
7872: IFFALSE 7945
// begin filter := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_armoury ] ] ) ;
7874: LD_ADDR_VAR 0 4
7878: PUSH
7879: LD_INT 22
7881: PUSH
7882: LD_INT 8
7884: PUSH
7885: EMPTY
7886: LIST
7887: LIST
7888: PUSH
7889: LD_INT 30
7891: PUSH
7892: LD_INT 4
7894: PUSH
7895: EMPTY
7896: LIST
7897: LIST
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PPUSH
7903: CALL_OW 69
7907: ST_TO_ADDR
// for i = 1 to filter do
7908: LD_ADDR_VAR 0 3
7912: PUSH
7913: DOUBLE
7914: LD_INT 1
7916: DEC
7917: ST_TO_ADDR
7918: LD_VAR 0 4
7922: PUSH
7923: FOR_TO
7924: IFFALSE 7943
// ComUpgrade ( filter [ i ] ) ;
7926: LD_VAR 0 4
7930: PUSH
7931: LD_VAR 0 3
7935: ARRAY
7936: PPUSH
7937: CALL_OW 146
7941: GO 7923
7943: POP
7944: POP
// end ; if GetSide ( lab ) = 2 and tech = tech_remcont then
7945: LD_VAR 0 2
7949: PPUSH
7950: CALL_OW 255
7954: PUSH
7955: LD_INT 2
7957: EQUAL
7958: PUSH
7959: LD_VAR 0 1
7963: PUSH
7964: LD_INT 15
7966: EQUAL
7967: AND
7968: IFFALSE 8133
// begin if IsLive ( Martin ) then
7970: LD_EXP 2
7974: PPUSH
7975: CALL_OW 300
7979: IFFALSE 8043
// begin Say ( Martin , DM-ct1 ) ;
7981: LD_EXP 2
7985: PPUSH
7986: LD_STRING DM-ct1
7988: PPUSH
7989: CALL_OW 88
// Say ( Louis , DLM-ct1 ) ;
7993: LD_EXP 1
7997: PPUSH
7998: LD_STRING DLM-ct1
8000: PPUSH
8001: CALL_OW 88
// Say ( Martin , DM-ct2 ) ;
8005: LD_EXP 2
8009: PPUSH
8010: LD_STRING DM-ct2
8012: PPUSH
8013: CALL_OW 88
// Say ( Martin , DM-ct3 ) ;
8017: LD_EXP 2
8021: PPUSH
8022: LD_STRING DM-ct3
8024: PPUSH
8025: CALL_OW 88
// Say ( Louis , DLM-ct2 ) ;
8029: LD_EXP 1
8033: PPUSH
8034: LD_STRING DLM-ct2
8036: PPUSH
8037: CALL_OW 88
// end else
8041: GO 8133
// begin un := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) ;
8043: LD_ADDR_VAR 0 5
8047: PUSH
8048: LD_INT 22
8050: PUSH
8051: LD_INT 2
8053: PUSH
8054: EMPTY
8055: LIST
8056: LIST
8057: PUSH
8058: LD_INT 25
8060: PUSH
8061: LD_INT 4
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: PPUSH
8072: CALL_OW 69
8076: ST_TO_ADDR
// Say ( un [ 1 ] , DA-ct1 ) ;
8077: LD_VAR 0 5
8081: PUSH
8082: LD_INT 1
8084: ARRAY
8085: PPUSH
8086: LD_STRING DA-ct1
8088: PPUSH
8089: CALL_OW 88
// Say ( Louis , DLA-ct1 ) ;
8093: LD_EXP 1
8097: PPUSH
8098: LD_STRING DLA-ct1
8100: PPUSH
8101: CALL_OW 88
// Say ( un [ 1 ] , DA-ct2 ) ;
8105: LD_VAR 0 5
8109: PUSH
8110: LD_INT 1
8112: ARRAY
8113: PPUSH
8114: LD_STRING DA-ct2
8116: PPUSH
8117: CALL_OW 88
// Say ( Louis , DLA-ct2 ) ;
8121: LD_EXP 1
8125: PPUSH
8126: LD_STRING DLA-ct2
8128: PPUSH
8129: CALL_OW 88
// end ; end ; end ;
8133: PPOPN 5
8135: END
// on UnitDestroyed ( un ) do var filter ;
8136: LD_INT 0
8138: PPUSH
// begin if GetSide ( un ) = 6 then
8139: LD_VAR 0 1
8143: PPUSH
8144: CALL_OW 255
8148: PUSH
8149: LD_INT 6
8151: EQUAL
8152: IFFALSE 8223
// begin if un in FilterAllUnits ( [ [ f_type , unit_vehicle ] ] ) then
8154: LD_VAR 0 1
8158: PUSH
8159: LD_INT 21
8161: PUSH
8162: LD_INT 2
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: PPUSH
8172: CALL_OW 69
8176: IN
8177: IFFALSE 8193
// begin dip_count := dip_count + 2 ;
8179: LD_ADDR_EXP 47
8183: PUSH
8184: LD_EXP 47
8188: PUSH
8189: LD_INT 2
8191: PLUS
8192: ST_TO_ADDR
// end ; if un in FilterAllUnits ( [ f_class , class_bazooker ] ) then
8193: LD_VAR 0 1
8197: PUSH
8198: LD_INT 25
8200: PUSH
8201: LD_INT 9
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PPUSH
8208: CALL_OW 69
8212: IN
8213: IFFALSE 8223
// act_baz := true ;
8215: LD_ADDR_EXP 39
8219: PUSH
8220: LD_INT 1
8222: ST_TO_ADDR
// end ; if GetSide ( un ) = 8 and un in FilterAllUnits ( [ f_type , unit_building ] ) then
8223: LD_VAR 0 1
8227: PPUSH
8228: CALL_OW 255
8232: PUSH
8233: LD_INT 8
8235: EQUAL
8236: PUSH
8237: LD_VAR 0 1
8241: PUSH
8242: LD_INT 21
8244: PUSH
8245: LD_INT 3
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: PPUSH
8252: CALL_OW 69
8256: IN
8257: AND
8258: IFFALSE 8344
// begin ar_build_list := ar_build_list ^ GetBType ( un ) ;
8260: LD_ADDR_EXP 25
8264: PUSH
8265: LD_EXP 25
8269: PUSH
8270: LD_VAR 0 1
8274: PPUSH
8275: CALL_OW 266
8279: ADD
8280: ST_TO_ADDR
// ar_build_list := ar_build_list ^ GetX ( un ) ;
8281: LD_ADDR_EXP 25
8285: PUSH
8286: LD_EXP 25
8290: PUSH
8291: LD_VAR 0 1
8295: PPUSH
8296: CALL_OW 250
8300: ADD
8301: ST_TO_ADDR
// ar_build_list := ar_build_list ^ GetY ( un ) ;
8302: LD_ADDR_EXP 25
8306: PUSH
8307: LD_EXP 25
8311: PUSH
8312: LD_VAR 0 1
8316: PPUSH
8317: CALL_OW 251
8321: ADD
8322: ST_TO_ADDR
// ar_build_list := ar_build_list ^ GetDir ( un ) ;
8323: LD_ADDR_EXP 25
8327: PUSH
8328: LD_EXP 25
8332: PUSH
8333: LD_VAR 0 1
8337: PPUSH
8338: CALL_OW 254
8342: ADD
8343: ST_TO_ADDR
// end ; if un in ar_mechs then
8344: LD_VAR 0 1
8348: PUSH
8349: LD_EXP 29
8353: IN
8354: IFFALSE 8376
// ar_mechs := Delete ( ar_mechs , un ) ;
8356: LD_ADDR_EXP 29
8360: PUSH
8361: LD_EXP 29
8365: PPUSH
8366: LD_VAR 0 1
8370: PPUSH
8371: CALL_OW 3
8375: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) then
8376: LD_VAR 0 1
8380: PUSH
8381: LD_INT 22
8383: PUSH
8384: LD_INT 8
8386: PUSH
8387: EMPTY
8388: LIST
8389: LIST
8390: PUSH
8391: LD_INT 21
8393: PUSH
8394: LD_INT 2
8396: PUSH
8397: EMPTY
8398: LIST
8399: LIST
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PPUSH
8405: CALL_OW 69
8409: IN
8410: IFFALSE 8568
// begin if GetWeapon ( un ) <> ar_rocket_launcher then
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 264
8421: PUSH
8422: LD_INT 28
8424: NONEQUAL
8425: IFFALSE 8453
// ar_produce_list := ar_produce_list ^ [ GetWeapon ( un ) ] else
8427: LD_ADDR_EXP 27
8431: PUSH
8432: LD_EXP 27
8436: PUSH
8437: LD_VAR 0 1
8441: PPUSH
8442: CALL_OW 264
8446: PUSH
8447: EMPTY
8448: LIST
8449: ADD
8450: ST_TO_ADDR
8451: GO 8470
// ar_produce_list := ar_produce_list ^ [ ar_gun ] ;
8453: LD_ADDR_EXP 27
8457: PUSH
8458: LD_EXP 27
8462: PUSH
8463: LD_INT 27
8465: PUSH
8466: EMPTY
8467: LIST
8468: ADD
8469: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ [ f_side , 8 ] , [ f_class , 3 ] , [ f_not , [ f_inside ] ] , [ f_not , [ f_driving ] ] ] ] ) ;
8470: LD_ADDR_VAR 0 2
8474: PUSH
8475: LD_INT 22
8477: PUSH
8478: LD_INT 8
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: PUSH
8485: LD_INT 25
8487: PUSH
8488: LD_INT 3
8490: PUSH
8491: EMPTY
8492: LIST
8493: LIST
8494: PUSH
8495: LD_INT 3
8497: PUSH
8498: LD_INT 54
8500: PUSH
8501: EMPTY
8502: LIST
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: PUSH
8508: LD_INT 3
8510: PUSH
8511: LD_INT 55
8513: PUSH
8514: EMPTY
8515: LIST
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: LIST
8526: PUSH
8527: EMPTY
8528: LIST
8529: PPUSH
8530: CALL_OW 69
8534: ST_TO_ADDR
// if filter = 0 then
8535: LD_VAR 0 2
8539: PUSH
8540: LD_INT 0
8542: EQUAL
8543: IFFALSE 8568
// PlaceUnitArea ( CreateHumanWithClass ( 3 , skill_level ) , ar8_spawn , false ) ;
8545: LD_INT 3
8547: PPUSH
8548: LD_EXP 32
8552: PPUSH
8553: CALL 55 0 2
8557: PPUSH
8558: LD_INT 1
8560: PPUSH
8561: LD_INT 0
8563: PPUSH
8564: CALL_OW 49
// end ; end ;
8568: PPOPN 2
8570: END
// on EnterBuilding ( b , un ) do var deps ;
8571: LD_INT 0
8573: PPUSH
// begin if un in FilterAllUnits ( [ f_side , 8 ] ) and b = ar_lab and GetLives ( un ) < 1000 then
8574: LD_VAR 0 2
8578: PUSH
8579: LD_INT 22
8581: PUSH
8582: LD_INT 8
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: PPUSH
8589: CALL_OW 69
8593: IN
8594: PUSH
8595: LD_VAR 0 1
8599: PUSH
8600: LD_EXP 30
8604: EQUAL
8605: AND
8606: PUSH
8607: LD_VAR 0 2
8611: PPUSH
8612: CALL_OW 256
8616: PUSH
8617: LD_INT 1000
8619: LESS
8620: AND
8621: IFFALSE 8635
// SetLives ( un , 1000 ) ;
8623: LD_VAR 0 2
8627: PPUSH
8628: LD_INT 1000
8630: PPUSH
8631: CALL_OW 234
// deps := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8635: LD_ADDR_VAR 0 3
8639: PUSH
8640: LD_INT 22
8642: PUSH
8643: LD_INT 2
8645: PUSH
8646: EMPTY
8647: LIST
8648: LIST
8649: PUSH
8650: LD_INT 2
8652: PUSH
8653: LD_INT 30
8655: PUSH
8656: LD_INT 0
8658: PUSH
8659: EMPTY
8660: LIST
8661: LIST
8662: PUSH
8663: LD_INT 30
8665: PUSH
8666: LD_INT 1
8668: PUSH
8669: EMPTY
8670: LIST
8671: LIST
8672: PUSH
8673: EMPTY
8674: LIST
8675: LIST
8676: LIST
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: PPUSH
8682: CALL_OW 69
8686: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman ] ] ) or un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) then
8687: LD_VAR 0 2
8691: PUSH
8692: LD_INT 22
8694: PUSH
8695: LD_INT 2
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: PUSH
8702: LD_INT 25
8704: PUSH
8705: LD_INT 12
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: PPUSH
8716: CALL_OW 69
8720: IN
8721: PUSH
8722: LD_VAR 0 2
8726: PUSH
8727: LD_INT 22
8729: PUSH
8730: LD_INT 2
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: PUSH
8737: LD_INT 25
8739: PUSH
8740: LD_INT 15
8742: PUSH
8743: EMPTY
8744: LIST
8745: LIST
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: PPUSH
8751: CALL_OW 69
8755: IN
8756: OR
8757: IFFALSE 8790
// if b in deps then
8759: LD_VAR 0 1
8763: PUSH
8764: LD_VAR 0 3
8768: IN
8769: IFFALSE 8790
// begin Wait ( 0 0$0.3 ) ;
8771: LD_INT 10
8773: PPUSH
8774: CALL_OW 67
// SetClass ( un , 16 ) ;
8778: LD_VAR 0 2
8782: PPUSH
8783: LD_INT 16
8785: PPUSH
8786: CALL_OW 336
// end ; end ; end_of_file
8790: PPOPN 3
8792: END
// every 1 1$47 + 0 0$11 do
8793: GO 8795
8795: DISABLE
// begin enable ;
8796: ENABLE
// case Difficulty of 1 :
8797: LD_OWVAR 67
8801: PUSH
8802: LD_INT 1
8804: DOUBLE
8805: EQUAL
8806: IFTRUE 8810
8808: GO 8906
8810: POP
// begin CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
8811: LD_INT 1
8813: PPUSH
8814: LD_INT 5
8816: PPUSH
8817: CALL_OW 12
8821: PPUSH
8822: LD_INT 5
8824: PPUSH
8825: LD_INT 1
8827: PPUSH
8828: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$20 ) ) ;
8832: LD_INT 350
8834: PPUSH
8835: LD_INT 700
8837: PPUSH
8838: CALL_OW 12
8842: PPUSH
8843: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
8847: LD_INT 1
8849: PPUSH
8850: LD_INT 5
8852: PPUSH
8853: CALL_OW 12
8857: PPUSH
8858: LD_INT 5
8860: PPUSH
8861: LD_INT 1
8863: PPUSH
8864: CALL_OW 55
// Wait ( Rand ( 0 0$10 , 0 0$20 ) ) ;
8868: LD_INT 350
8870: PPUSH
8871: LD_INT 700
8873: PPUSH
8874: CALL_OW 12
8878: PPUSH
8879: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
8883: LD_INT 1
8885: PPUSH
8886: LD_INT 5
8888: PPUSH
8889: CALL_OW 12
8893: PPUSH
8894: LD_INT 5
8896: PPUSH
8897: LD_INT 1
8899: PPUSH
8900: CALL_OW 55
// end ; 2 :
8904: GO 9115
8906: LD_INT 2
8908: DOUBLE
8909: EQUAL
8910: IFTRUE 8914
8912: GO 9010
8914: POP
// begin CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
8915: LD_INT 1
8917: PPUSH
8918: LD_INT 5
8920: PPUSH
8921: CALL_OW 12
8925: PPUSH
8926: LD_INT 5
8928: PPUSH
8929: LD_INT 1
8931: PPUSH
8932: CALL_OW 55
// Wait ( Rand ( 0 0$25 , 0 0$55 ) ) ;
8936: LD_INT 875
8938: PPUSH
8939: LD_INT 1925
8941: PPUSH
8942: CALL_OW 12
8946: PPUSH
8947: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 3 ) , crates_spawn , true ) ;
8951: LD_INT 1
8953: PPUSH
8954: LD_INT 3
8956: PPUSH
8957: CALL_OW 12
8961: PPUSH
8962: LD_INT 5
8964: PPUSH
8965: LD_INT 1
8967: PPUSH
8968: CALL_OW 55
// Wait ( Rand ( 0 0$35 , 0 0$45 ) ) ;
8972: LD_INT 1225
8974: PPUSH
8975: LD_INT 1575
8977: PPUSH
8978: CALL_OW 12
8982: PPUSH
8983: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
8987: LD_INT 1
8989: PPUSH
8990: LD_INT 5
8992: PPUSH
8993: CALL_OW 12
8997: PPUSH
8998: LD_INT 5
9000: PPUSH
9001: LD_INT 1
9003: PPUSH
9004: CALL_OW 55
// end ; 3 :
9008: GO 9115
9010: LD_INT 3
9012: DOUBLE
9013: EQUAL
9014: IFTRUE 9018
9016: GO 9114
9018: POP
// begin CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9019: LD_INT 1
9021: PPUSH
9022: LD_INT 5
9024: PPUSH
9025: CALL_OW 12
9029: PPUSH
9030: LD_INT 5
9032: PPUSH
9033: LD_INT 1
9035: PPUSH
9036: CALL_OW 55
// Wait ( Rand ( 0 0$30 , 0 0$55 ) ) ;
9040: LD_INT 1050
9042: PPUSH
9043: LD_INT 1925
9045: PPUSH
9046: CALL_OW 12
9050: PPUSH
9051: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 2 ) , crates_spawn , true ) ;
9055: LD_INT 1
9057: PPUSH
9058: LD_INT 2
9060: PPUSH
9061: CALL_OW 12
9065: PPUSH
9066: LD_INT 5
9068: PPUSH
9069: LD_INT 1
9071: PPUSH
9072: CALL_OW 55
// Wait ( Rand ( 0 0$35 , 0 0$55 ) ) ;
9076: LD_INT 1225
9078: PPUSH
9079: LD_INT 1925
9081: PPUSH
9082: CALL_OW 12
9086: PPUSH
9087: CALL_OW 67
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
9091: LD_INT 1
9093: PPUSH
9094: LD_INT 5
9096: PPUSH
9097: CALL_OW 12
9101: PPUSH
9102: LD_INT 5
9104: PPUSH
9105: LD_INT 1
9107: PPUSH
9108: CALL_OW 55
// end ; end ;
9112: GO 9115
9114: POP
// end ; end_of_file end_of_file
9115: END
// export function Action ; begin
9116: LD_INT 0
9118: PPUSH
// InGameOn ;
9119: CALL_OW 8
// CenterNowOnXY ( 90 , 30 ) ;
9123: LD_INT 90
9125: PPUSH
9126: LD_INT 30
9128: PPUSH
9129: CALL_OW 86
// Wait ( 0 0$02 ) ;
9133: LD_INT 70
9135: PPUSH
9136: CALL_OW 67
// Say ( Louis , DL-f ) ;
9140: LD_EXP 1
9144: PPUSH
9145: LD_STRING DL-f
9147: PPUSH
9148: CALL_OW 88
// Say ( AllPeo [ 2 ] , DP-1p ) ;
9152: LD_EXP 20
9156: PUSH
9157: LD_INT 2
9159: ARRAY
9160: PPUSH
9161: LD_STRING DP-1p
9163: PPUSH
9164: CALL_OW 88
// Say ( AllPeo [ 3 ] , DP-2p ) ;
9168: LD_EXP 20
9172: PUSH
9173: LD_INT 3
9175: ARRAY
9176: PPUSH
9177: LD_STRING DP-2p
9179: PPUSH
9180: CALL_OW 88
// Say ( AllPeo [ 4 ] , DP-3p ) ;
9184: LD_EXP 20
9188: PUSH
9189: LD_INT 4
9191: ARRAY
9192: PPUSH
9193: LD_STRING DP-3p
9195: PPUSH
9196: CALL_OW 88
// Say ( AllPeo [ 5 ] , DP-4p ) ;
9200: LD_EXP 20
9204: PUSH
9205: LD_INT 5
9207: ARRAY
9208: PPUSH
9209: LD_STRING DP-4p
9211: PPUSH
9212: CALL_OW 88
// InGameOff ;
9216: CALL_OW 9
// ChangeMissionObjectives ( Target1 ) ;
9220: LD_STRING Target1
9222: PPUSH
9223: CALL_OW 337
// SetAreaMapShow ( act_base , 1 ) ;
9227: LD_INT 11
9229: PPUSH
9230: LD_INT 1
9232: PPUSH
9233: CALL_OW 424
// PlaceSeeing ( 67 , 65 , 2 , 15 ) ;
9237: LD_INT 67
9239: PPUSH
9240: LD_INT 65
9242: PPUSH
9243: LD_INT 2
9245: PPUSH
9246: LD_INT 15
9248: PPUSH
9249: CALL_OW 330
// end ;
9253: LD_VAR 0 1
9257: RET
// every 0 0$01 trigger GetDistUnits ( Louis , player_base ) <= 10 do
9258: LD_EXP 1
9262: PPUSH
9263: LD_INT 21
9265: PPUSH
9266: CALL_OW 296
9270: PUSH
9271: LD_INT 10
9273: LESSEQUAL
9274: IFFALSE 9800
9276: GO 9278
9278: DISABLE
// begin SetAreaMapShow ( act_base , 0 ) ;
9279: LD_INT 11
9281: PPUSH
9282: LD_INT 0
9284: PPUSH
9285: CALL_OW 424
// RemoveSeeing ( 71 , 63 , 2 ) ;
9289: LD_INT 71
9291: PPUSH
9292: LD_INT 63
9294: PPUSH
9295: LD_INT 2
9297: PPUSH
9298: CALL_OW 331
// InGameOn ;
9302: CALL_OW 8
// CenterNowOnXY ( 63 , 65 ) ;
9306: LD_INT 63
9308: PPUSH
9309: LD_INT 65
9311: PPUSH
9312: CALL_OW 86
// ComMoveXY ( Erwin , GetX ( Louis ) , GetY ( Louis ) ) ;
9316: LD_EXP 31
9320: PPUSH
9321: LD_EXP 1
9325: PPUSH
9326: CALL_OW 250
9330: PPUSH
9331: LD_EXP 1
9335: PPUSH
9336: CALL_OW 251
9340: PPUSH
9341: CALL_OW 111
// if IsInUnit ( Louis ) then
9345: LD_EXP 1
9349: PPUSH
9350: CALL_OW 310
9354: IFFALSE 9365
// ComExitVehicle ( Louis ) ;
9356: LD_EXP 1
9360: PPUSH
9361: CALL_OW 121
// Wait ( 0 0$03 ) ;
9365: LD_INT 105
9367: PPUSH
9368: CALL_OW 67
// ComHold ( Louis ) ;
9372: LD_EXP 1
9376: PPUSH
9377: CALL_OW 140
// Say ( Louis , DL-1 ) ;
9381: LD_EXP 1
9385: PPUSH
9386: LD_STRING DL-1
9388: PPUSH
9389: CALL_OW 88
// SetSide ( player_base , 2 ) ;
9393: LD_INT 21
9395: PPUSH
9396: LD_INT 2
9398: PPUSH
9399: CALL_OW 235
// InGameOff ;
9403: CALL_OW 9
// repeat Wait ( 0 0$01 ) ;
9407: LD_INT 35
9409: PPUSH
9410: CALL_OW 67
// until GetDistUnits ( Erwin , Louis ) <= 6 or GetDistUnits ( Erwin , FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ) ;
9414: LD_EXP 31
9418: PPUSH
9419: LD_EXP 1
9423: PPUSH
9424: CALL_OW 296
9428: PUSH
9429: LD_INT 6
9431: LESSEQUAL
9432: PUSH
9433: LD_EXP 31
9437: PPUSH
9438: LD_INT 22
9440: PUSH
9441: LD_INT 2
9443: PUSH
9444: EMPTY
9445: LIST
9446: LIST
9447: PUSH
9448: LD_INT 30
9450: PUSH
9451: LD_INT 0
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: PUSH
9458: EMPTY
9459: LIST
9460: LIST
9461: PPUSH
9462: CALL_OW 69
9466: PUSH
9467: LD_INT 1
9469: ARRAY
9470: PPUSH
9471: CALL_OW 296
9475: OR
9476: IFFALSE 9407
// InGameOn ;
9478: CALL_OW 8
// ChangeSideFog ( 2 , 8 ) ;
9482: LD_INT 2
9484: PPUSH
9485: LD_INT 8
9487: PPUSH
9488: CALL_OW 343
// ComTurnUnit ( Erwin , Louis ) ;
9492: LD_EXP 31
9496: PPUSH
9497: LD_EXP 1
9501: PPUSH
9502: CALL_OW 119
// CenterOnUnits ( Erwin ) ;
9506: LD_EXP 31
9510: PPUSH
9511: CALL_OW 85
// Say ( Erwin , DE-1 ) ;
9515: LD_EXP 31
9519: PPUSH
9520: LD_STRING DE-1
9522: PPUSH
9523: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
9527: LD_INT 10
9529: PPUSH
9530: CALL_OW 67
// ComTurnUnit ( Louis , Erwin ) ;
9534: LD_EXP 1
9538: PPUSH
9539: LD_EXP 31
9543: PPUSH
9544: CALL_OW 119
// Say ( Louis , DL-2 ) ;
9548: LD_EXP 1
9552: PPUSH
9553: LD_STRING DL-2
9555: PPUSH
9556: CALL_OW 88
// Say ( Erwin , DE-2 ) ;
9560: LD_EXP 31
9564: PPUSH
9565: LD_STRING DE-2
9567: PPUSH
9568: CALL_OW 88
// Say ( Louis , DL-3 ) ;
9572: LD_EXP 1
9576: PPUSH
9577: LD_STRING DL-3
9579: PPUSH
9580: CALL_OW 88
// Say ( Erwin , DE-3 ) ;
9584: LD_EXP 31
9588: PPUSH
9589: LD_STRING DE-3
9591: PPUSH
9592: CALL_OW 88
// Say ( Erwin , DE-4 ) ;
9596: LD_EXP 31
9600: PPUSH
9601: LD_STRING DE-4
9603: PPUSH
9604: CALL_OW 88
// Say ( Erwin , DE-5 ) ;
9608: LD_EXP 31
9612: PPUSH
9613: LD_STRING DE-5
9615: PPUSH
9616: CALL_OW 88
// Say ( Erwin , DE-6 ) ;
9620: LD_EXP 31
9624: PPUSH
9625: LD_STRING DE-6
9627: PPUSH
9628: CALL_OW 88
// Say ( Erwin , DE-7 ) ;
9632: LD_EXP 31
9636: PPUSH
9637: LD_STRING DE-7
9639: PPUSH
9640: CALL_OW 88
// Say ( Louis , DL-4 ) ;
9644: LD_EXP 1
9648: PPUSH
9649: LD_STRING DL-4
9651: PPUSH
9652: CALL_OW 88
// Wait ( 0 0$0.3 ) ;
9656: LD_INT 10
9658: PPUSH
9659: CALL_OW 67
// Say ( Erwin , DE-8 ) ;
9663: LD_EXP 31
9667: PPUSH
9668: LD_STRING DE-8
9670: PPUSH
9671: CALL_OW 88
// Say ( AllPeo [ Rand ( 2 , 5 ) ] , Deng-1 ) ;
9675: LD_EXP 20
9679: PUSH
9680: LD_INT 2
9682: PPUSH
9683: LD_INT 5
9685: PPUSH
9686: CALL_OW 12
9690: ARRAY
9691: PPUSH
9692: LD_STRING Deng-1
9694: PPUSH
9695: CALL_OW 88
// Say ( Erwin , DE-9 ) ;
9699: LD_EXP 31
9703: PPUSH
9704: LD_STRING DE-9
9706: PPUSH
9707: CALL_OW 88
// InGameOff ;
9711: CALL_OW 9
// ChangeMissionObjectives ( Target2 ) ;
9715: LD_STRING Target2
9717: PPUSH
9718: CALL_OW 337
// PlaceSeeing ( 103 , 62 , 2 , 13 ) ;
9722: LD_INT 103
9724: PPUSH
9725: LD_INT 62
9727: PPUSH
9728: LD_INT 2
9730: PPUSH
9731: LD_INT 13
9733: PPUSH
9734: CALL_OW 330
// game_started := true ;
9738: LD_ADDR_EXP 33
9742: PUSH
9743: LD_INT 1
9745: ST_TO_ADDR
// ComMoveXY ( Erwin , 104 , 123 ) ;
9746: LD_EXP 31
9750: PPUSH
9751: LD_INT 104
9753: PPUSH
9754: LD_INT 123
9756: PPUSH
9757: CALL_OW 111
// Wait ( 0 0$05 ) ;
9761: LD_INT 175
9763: PPUSH
9764: CALL_OW 67
// Say ( AllPeo [ 4 ] , Deng-2 ) ;
9768: LD_EXP 20
9772: PUSH
9773: LD_INT 4
9775: ARRAY
9776: PPUSH
9777: LD_STRING Deng-2
9779: PPUSH
9780: CALL_OW 88
// Say ( AllPeo [ 8 ] , Deng-3 ) ;
9784: LD_EXP 20
9788: PUSH
9789: LD_INT 8
9791: ARRAY
9792: PPUSH
9793: LD_STRING Deng-3
9795: PPUSH
9796: CALL_OW 88
// end ;
9800: END
// every 0 0$01 trigger pl_lab and pl_fac and pl_el >= 3 do
9801: LD_EXP 40
9805: PUSH
9806: LD_EXP 41
9810: AND
9811: PUSH
9812: LD_EXP 42
9816: PUSH
9817: LD_INT 3
9819: GREATEREQUAL
9820: AND
9821: IFFALSE 9833
9823: GO 9825
9825: DISABLE
// ChangeMissionObjectives ( OutTarget2 ) ;
9826: LD_STRING OutTarget2
9828: PPUSH
9829: CALL_OW 337
9833: END
// every 0 0$01 trigger pl_opto do var un ;
9834: LD_EXP 43
9838: IFFALSE 9984
9840: GO 9842
9842: DISABLE
9843: LD_INT 0
9845: PPUSH
// begin if not IsLive ( Martin ) then
9846: LD_EXP 2
9850: PPUSH
9851: CALL_OW 300
9855: NOT
9856: IFFALSE 9903
// un := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff [ Louis ] else
9858: LD_ADDR_VAR 0 1
9862: PUSH
9863: LD_INT 22
9865: PUSH
9866: LD_INT 2
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PUSH
9873: LD_INT 25
9875: PUSH
9876: LD_INT 4
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: PUSH
9883: EMPTY
9884: LIST
9885: LIST
9886: PPUSH
9887: CALL_OW 69
9891: PUSH
9892: LD_EXP 1
9896: PUSH
9897: EMPTY
9898: LIST
9899: DIFF
9900: ST_TO_ADDR
9901: GO 9913
// un := Martin ;
9903: LD_ADDR_VAR 0 1
9907: PUSH
9908: LD_EXP 2
9912: ST_TO_ADDR
// DialogueOn ;
9913: CALL_OW 6
// Say ( Louis , Dct-1 ) ;
9917: LD_EXP 1
9921: PPUSH
9922: LD_STRING Dct-1
9924: PPUSH
9925: CALL_OW 88
// Say ( un [ 1 ] , Dct-2 ) ;
9929: LD_VAR 0 1
9933: PUSH
9934: LD_INT 1
9936: ARRAY
9937: PPUSH
9938: LD_STRING Dct-2
9940: PPUSH
9941: CALL_OW 88
// Say ( Louis , Dct-3 ) ;
9945: LD_EXP 1
9949: PPUSH
9950: LD_STRING Dct-3
9952: PPUSH
9953: CALL_OW 88
// Say ( un [ 1 ] , Dct-4 ) ;
9957: LD_VAR 0 1
9961: PUSH
9962: LD_INT 1
9964: ARRAY
9965: PPUSH
9966: LD_STRING Dct-4
9968: PPUSH
9969: CALL_OW 88
// DialogueOff ;
9973: CALL_OW 7
// ChangeMissionObjectives ( Target3 ) ;
9977: LD_STRING Target3
9979: PPUSH
9980: CALL_OW 337
// end ;
9984: PPOPN 1
9986: END
// every 0 0$01 trigger FilterUnitsInArea ( crates_spawn , [ [ f_side , 8 ] , [ f_weapon , ar_cargo_bay ] ] ) > 0 do
9987: LD_INT 5
9989: PPUSH
9990: LD_INT 22
9992: PUSH
9993: LD_INT 8
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: LD_INT 34
10002: PUSH
10003: LD_INT 32
10005: PUSH
10006: EMPTY
10007: LIST
10008: LIST
10009: PUSH
10010: EMPTY
10011: LIST
10012: LIST
10013: PPUSH
10014: CALL_OW 70
10018: PUSH
10019: LD_INT 0
10021: GREATER
10022: IFFALSE 10058
10024: GO 10026
10026: DISABLE
// begin Wait ( 0 0$0.3 ) ;
10027: LD_INT 10
10029: PPUSH
10030: CALL_OW 67
// Say ( AllPeo [ Rand ( 3 , 5 ) ] , Dcargo ) ;
10034: LD_EXP 20
10038: PUSH
10039: LD_INT 3
10041: PPUSH
10042: LD_INT 5
10044: PPUSH
10045: CALL_OW 12
10049: ARRAY
10050: PPUSH
10051: LD_STRING Dcargo
10053: PPUSH
10054: CALL_OW 88
// end ;
10058: END
// every 0 0$04 trigger act_baz do
10059: LD_EXP 39
10063: IFFALSE 10130
10065: GO 10067
10067: DISABLE
// begin if IsLive ( Karla ) then
10068: LD_EXP 3
10072: PPUSH
10073: CALL_OW 300
10077: IFFALSE 10093
// Say ( Karla , Dbaz ) else
10079: LD_EXP 3
10083: PPUSH
10084: LD_STRING Dbaz
10086: PPUSH
10087: CALL_OW 88
10091: GO 10130
// Say ( UnitFilter ( AllPeo , [ f_class , 1 ] diff Louis ) [ 1 ] , Dbaz ) ;
10093: LD_EXP 20
10097: PPUSH
10098: LD_INT 25
10100: PUSH
10101: LD_INT 1
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: PUSH
10108: LD_EXP 1
10112: DIFF
10113: PPUSH
10114: CALL_OW 72
10118: PUSH
10119: LD_INT 1
10121: ARRAY
10122: PPUSH
10123: LD_STRING Dbaz
10125: PPUSH
10126: CALL_OW 88
// end ;
10130: END
// every 33 33$00 trigger game_started do
10131: LD_EXP 33
10135: IFFALSE 10156
10137: GO 10139
10139: DISABLE
// Say ( AllPeo [ 5 ] , DHard ) ;
10140: LD_EXP 20
10144: PUSH
10145: LD_INT 5
10147: ARRAY
10148: PPUSH
10149: LD_STRING DHard
10151: PPUSH
10152: CALL_OW 88
10156: END
// every 0 0$01 trigger timer >= Rand ( 45 45$00 , 50 50$00 ) do
10157: LD_EXP 48
10161: PUSH
10162: LD_INT 94500
10164: PPUSH
10165: LD_INT 105000
10167: PPUSH
10168: CALL_OW 12
10172: GREATEREQUAL
10173: IFFALSE 10522
10175: GO 10177
10177: DISABLE
// begin if erwin_safe then
10178: LD_EXP 46
10182: IFFALSE 10198
// dip_points := dip_points + 5 ;
10184: LD_ADDR_EXP 44
10188: PUSH
10189: LD_EXP 44
10193: PUSH
10194: LD_INT 5
10196: PLUS
10197: ST_TO_ADDR
// Wait ( 0 0$30 ) ;
10198: LD_INT 1050
10200: PPUSH
10201: CALL_OW 67
// InGameOn ;
10205: CALL_OW 8
// DialogueOn ;
10209: CALL_OW 6
// Say ( Erwin , DE-end ) ;
10213: LD_EXP 31
10217: PPUSH
10218: LD_STRING DE-end
10220: PPUSH
10221: CALL_OW 88
// if dip_points <= 5 then
10225: LD_EXP 44
10229: PUSH
10230: LD_INT 5
10232: LESSEQUAL
10233: IFFALSE 10247
// Say ( Erwin , DE-end-bad ) ;
10235: LD_EXP 31
10239: PPUSH
10240: LD_STRING DE-end-bad
10242: PPUSH
10243: CALL_OW 88
// if dip_points > 5 and dip_points <= 10 then
10247: LD_EXP 44
10251: PUSH
10252: LD_INT 5
10254: GREATER
10255: PUSH
10256: LD_EXP 44
10260: PUSH
10261: LD_INT 10
10263: LESSEQUAL
10264: AND
10265: IFFALSE 10279
// Say ( Erwin , DE-end-ok ) ;
10267: LD_EXP 31
10271: PPUSH
10272: LD_STRING DE-end-ok
10274: PPUSH
10275: CALL_OW 88
// if dip_points > 10 then
10279: LD_EXP 44
10283: PUSH
10284: LD_INT 10
10286: GREATER
10287: IFFALSE 10301
// Say ( Erwin , DE-end-good ) ;
10289: LD_EXP 31
10293: PPUSH
10294: LD_STRING DE-end-good
10296: PPUSH
10297: CALL_OW 88
// if dip_points >= 13 then
10301: LD_EXP 44
10305: PUSH
10306: LD_INT 13
10308: GREATEREQUAL
10309: IFFALSE 10323
// AddMedal ( med1 , 1 ) else
10311: LD_STRING med1
10313: PPUSH
10314: LD_INT 1
10316: PPUSH
10317: CALL_OW 101
10321: GO 10334
// AddMedal ( med1 , - 1 ) ;
10323: LD_STRING med1
10325: PPUSH
10326: LD_INT 1
10328: NEG
10329: PPUSH
10330: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) > 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) > 0 then
10334: LD_INT 22
10336: PUSH
10337: LD_INT 2
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: PUSH
10344: LD_INT 34
10346: PUSH
10347: LD_INT 31
10349: PUSH
10350: EMPTY
10351: LIST
10352: LIST
10353: PUSH
10354: EMPTY
10355: LIST
10356: LIST
10357: PPUSH
10358: CALL_OW 69
10362: PUSH
10363: LD_INT 0
10365: GREATER
10366: PUSH
10367: LD_INT 22
10369: PUSH
10370: LD_INT 2
10372: PUSH
10373: EMPTY
10374: LIST
10375: LIST
10376: PUSH
10377: LD_INT 33
10379: PUSH
10380: LD_INT 2
10382: PUSH
10383: EMPTY
10384: LIST
10385: LIST
10386: PUSH
10387: EMPTY
10388: LIST
10389: LIST
10390: PPUSH
10391: CALL_OW 69
10395: PUSH
10396: LD_INT 0
10398: GREATER
10399: AND
10400: IFFALSE 10424
// begin AddMedal ( med2 , 1 ) ;
10402: LD_STRING med2
10404: PPUSH
10405: LD_INT 1
10407: PPUSH
10408: CALL_OW 101
// SaveVariable ( 1 , control_tower ) ;
10412: LD_INT 1
10414: PPUSH
10415: LD_STRING control_tower
10417: PPUSH
10418: CALL_OW 39
// end else
10422: GO 10445
// begin AddMedal ( med2 , - 1 ) ;
10424: LD_STRING med2
10426: PPUSH
10427: LD_INT 1
10429: NEG
10430: PPUSH
10431: CALL_OW 101
// SaveVariable ( 0 , control_tower ) ;
10435: LD_INT 0
10437: PPUSH
10438: LD_STRING control_tower
10440: PPUSH
10441: CALL_OW 39
// end ; if GetTech ( tech_mortar , 2 ) = state_researched then
10445: LD_INT 41
10447: PPUSH
10448: LD_INT 2
10450: PPUSH
10451: CALL_OW 321
10455: PUSH
10456: LD_INT 2
10458: EQUAL
10459: IFFALSE 10483
// begin AddMedal ( med3 , 1 ) ;
10461: LD_STRING med3
10463: PPUSH
10464: LD_INT 1
10466: PPUSH
10467: CALL_OW 101
// SaveVariable ( 1 , mortar ) ;
10471: LD_INT 1
10473: PPUSH
10474: LD_STRING mortar
10476: PPUSH
10477: CALL_OW 39
// end else
10481: GO 10504
// begin AddMedal ( med3 , - 1 ) ;
10483: LD_STRING med3
10485: PPUSH
10486: LD_INT 1
10488: NEG
10489: PPUSH
10490: CALL_OW 101
// SaveVariable ( 0 , mortar ) ;
10494: LD_INT 0
10496: PPUSH
10497: LD_STRING mortar
10499: PPUSH
10500: CALL_OW 39
// end ; GiveMedals ( MAIN ) ;
10504: LD_STRING MAIN
10506: PPUSH
10507: CALL_OW 102
// SaveFunction ;
10511: CALL 12327 0 0
// SetNextMission ( 1 ) ;
10515: LD_INT 1
10517: PPUSH
10518: CALL_OW 536
// end ; end_of_file
10522: END
// on Contact ( s1 , s2 ) do var i ;
10523: LD_INT 0
10525: PPUSH
// begin if s1 = your_side and s2 = 8 or s1 = 8 and s2 = your_side then
10526: LD_VAR 0 1
10530: PUSH
10531: LD_OWVAR 2
10535: EQUAL
10536: PUSH
10537: LD_VAR 0 2
10541: PUSH
10542: LD_INT 8
10544: EQUAL
10545: AND
10546: PUSH
10547: LD_VAR 0 1
10551: PUSH
10552: LD_INT 8
10554: EQUAL
10555: PUSH
10556: LD_VAR 0 2
10560: PUSH
10561: LD_OWVAR 2
10565: EQUAL
10566: AND
10567: OR
10568: IFFALSE 10577
// YouLost ( TeamAttack ) ;
10570: LD_STRING TeamAttack
10572: PPUSH
10573: CALL_OW 104
// if s1 = 6 and s2 = 8 then
10577: LD_VAR 0 1
10581: PUSH
10582: LD_INT 6
10584: EQUAL
10585: PUSH
10586: LD_VAR 0 2
10590: PUSH
10591: LD_INT 8
10593: EQUAL
10594: AND
10595: IFFALSE 10710
// begin i := Rand ( 1 , 3 ) ;
10597: LD_ADDR_VAR 0 3
10601: PUSH
10602: LD_INT 1
10604: PPUSH
10605: LD_INT 3
10607: PPUSH
10608: CALL_OW 12
10612: ST_TO_ADDR
// case i of 1 :
10613: LD_VAR 0 3
10617: PUSH
10618: LD_INT 1
10620: DOUBLE
10621: EQUAL
10622: IFTRUE 10626
10624: GO 10641
10626: POP
// Say ( Erwin , DE-at1 ) ; 2 :
10627: LD_EXP 31
10631: PPUSH
10632: LD_STRING DE-at1
10634: PPUSH
10635: CALL_OW 88
10639: GO 10688
10641: LD_INT 2
10643: DOUBLE
10644: EQUAL
10645: IFTRUE 10649
10647: GO 10664
10649: POP
// Say ( Erwin , DE-at2 ) ; 3 :
10650: LD_EXP 31
10654: PPUSH
10655: LD_STRING DE-at2
10657: PPUSH
10658: CALL_OW 88
10662: GO 10688
10664: LD_INT 3
10666: DOUBLE
10667: EQUAL
10668: IFTRUE 10672
10670: GO 10687
10672: POP
// Say ( Erwin , DE-at3 ) ; end ;
10673: LD_EXP 31
10677: PPUSH
10678: LD_STRING DE-at3
10680: PPUSH
10681: CALL_OW 88
10685: GO 10688
10687: POP
// dip_points := dip_points - 2 ;
10688: LD_ADDR_EXP 44
10692: PUSH
10693: LD_EXP 44
10697: PUSH
10698: LD_INT 2
10700: MINUS
10701: ST_TO_ADDR
// erwin_safe := false ;
10702: LD_ADDR_EXP 46
10706: PUSH
10707: LD_INT 0
10709: ST_TO_ADDR
// end ; end ;
10710: PPOPN 3
10712: END
// every 0 0$01 trigger IsDead ( Louis ) do
10713: LD_EXP 1
10717: PPUSH
10718: CALL_OW 301
10722: IFFALSE 10734
10724: GO 10726
10726: DISABLE
// YouLost ( LouisDead ) ;
10727: LD_STRING LouisDead
10729: PPUSH
10730: CALL_OW 104
10734: END
// every 0 0$01 trigger IsDead ( Erwin ) do
10735: LD_EXP 31
10739: PPUSH
10740: CALL_OW 301
10744: IFFALSE 10756
10746: GO 10748
10748: DISABLE
// YouLost ( ErwinDead ) ; end_of_file
10749: LD_STRING ErwinDead
10751: PPUSH
10752: CALL_OW 104
10756: END
// every 0 0$01 do var filter , enemy , i ;
10757: GO 10759
10759: DISABLE
10760: LD_INT 0
10762: PPUSH
10763: PPUSH
10764: PPUSH
// begin enable ;
10765: ENABLE
// filter := FilterAllUnits ( [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) ;
10766: LD_ADDR_VAR 0 1
10770: PUSH
10771: LD_INT 2
10773: PUSH
10774: LD_INT 22
10776: PUSH
10777: LD_INT 3
10779: PUSH
10780: EMPTY
10781: LIST
10782: LIST
10783: PUSH
10784: LD_INT 22
10786: PUSH
10787: LD_INT 6
10789: PUSH
10790: EMPTY
10791: LIST
10792: LIST
10793: PUSH
10794: EMPTY
10795: LIST
10796: LIST
10797: LIST
10798: PPUSH
10799: CALL_OW 69
10803: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_or , [ f_side , 2 ] , [ f_side , 8 ] ] ) ;
10804: LD_ADDR_VAR 0 2
10808: PUSH
10809: LD_INT 2
10811: PUSH
10812: LD_INT 22
10814: PUSH
10815: LD_INT 2
10817: PUSH
10818: EMPTY
10819: LIST
10820: LIST
10821: PUSH
10822: LD_INT 22
10824: PUSH
10825: LD_INT 8
10827: PUSH
10828: EMPTY
10829: LIST
10830: LIST
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: LIST
10836: PPUSH
10837: CALL_OW 69
10841: ST_TO_ADDR
// if filter > 0 then
10842: LD_VAR 0 1
10846: PUSH
10847: LD_INT 0
10849: GREATER
10850: IFFALSE 10910
// for i = 1 to filter do
10852: LD_ADDR_VAR 0 3
10856: PUSH
10857: DOUBLE
10858: LD_INT 1
10860: DEC
10861: ST_TO_ADDR
10862: LD_VAR 0 1
10866: PUSH
10867: FOR_TO
10868: IFFALSE 10908
// ComAttackUnit ( filter [ i ] , NearestUnitToUnit ( enemy , filter [ i ] ) ) ;
10870: LD_VAR 0 1
10874: PUSH
10875: LD_VAR 0 3
10879: ARRAY
10880: PPUSH
10881: LD_VAR 0 2
10885: PPUSH
10886: LD_VAR 0 1
10890: PUSH
10891: LD_VAR 0 3
10895: ARRAY
10896: PPUSH
10897: CALL_OW 74
10901: PPUSH
10902: CALL_OW 115
10906: GO 10867
10908: POP
10909: POP
// end ;
10910: PPOPN 3
10912: END
// every 0 0$01 trigger game_started do var time , rus_time ;
10913: LD_EXP 33
10917: IFFALSE 11030
10919: GO 10921
10921: DISABLE
10922: LD_INT 0
10924: PPUSH
10925: PPUSH
// begin time := [ 1 1$50 , 1 1$20 , 1 1$10 ] [ Difficulty ] ;
10926: LD_ADDR_VAR 0 1
10930: PUSH
10931: LD_INT 3850
10933: PUSH
10934: LD_INT 2800
10936: PUSH
10937: LD_INT 2450
10939: PUSH
10940: EMPTY
10941: LIST
10942: LIST
10943: LIST
10944: PUSH
10945: LD_OWVAR 67
10949: ARRAY
10950: ST_TO_ADDR
// rus_time := LoadVariable ( rus_time , 0 ) ;
10951: LD_ADDR_VAR 0 2
10955: PUSH
10956: LD_STRING rus_time
10958: PPUSH
10959: LD_INT 0
10961: PPUSH
10962: CALL_OW 30
10966: ST_TO_ADDR
// Wait ( time + rus_time ) ;
10967: LD_VAR 0 1
10971: PUSH
10972: LD_VAR 0 2
10976: PLUS
10977: PPUSH
10978: CALL_OW 67
// RussianAttack ( 3 , 2 + [ Difficulty ] , 2 , ru_north_spawn ) ;
10982: LD_INT 3
10984: PPUSH
10985: LD_INT 2
10987: PUSH
10988: LD_OWVAR 67
10992: PUSH
10993: EMPTY
10994: LIST
10995: PLUS
10996: PPUSH
10997: LD_INT 2
10999: PPUSH
11000: LD_INT 3
11002: PPUSH
11003: CALL 500 0 4
// Wait ( 1 1$30 ) ;
11007: LD_INT 3150
11009: PPUSH
11010: CALL_OW 67
// rus_red := true ;
11014: LD_ADDR_EXP 37
11018: PUSH
11019: LD_INT 1
11021: ST_TO_ADDR
// rus_pink := true ;
11022: LD_ADDR_EXP 38
11026: PUSH
11027: LD_INT 1
11029: ST_TO_ADDR
// end ;
11030: PPOPN 2
11032: END
// every 4 4$50 + 0 0$35 trigger rus_red do var i ;
11033: LD_EXP 37
11037: IFFALSE 11143
11039: GO 11041
11041: DISABLE
11042: LD_INT 0
11044: PPUSH
// begin enable ;
11045: ENABLE
// Wait ( Rand ( 0 0$33 , 0 0$57 ) ) ;
11046: LD_INT 1155
11048: PPUSH
11049: LD_INT 1995
11051: PPUSH
11052: CALL_OW 12
11056: PPUSH
11057: CALL_OW 67
// i := Rand ( 1 , 2 ) ;
11061: LD_ADDR_VAR 0 1
11065: PUSH
11066: LD_INT 1
11068: PPUSH
11069: LD_INT 2
11071: PPUSH
11072: CALL_OW 12
11076: ST_TO_ADDR
// if timer <= 25 25$00 then
11077: LD_EXP 48
11081: PUSH
11082: LD_INT 52500
11084: LESSEQUAL
11085: IFFALSE 11116
// RussianAttack ( 3 , 2 + [ Difficulty ] , i , ru_north_spawn ) else
11087: LD_INT 3
11089: PPUSH
11090: LD_INT 2
11092: PUSH
11093: LD_OWVAR 67
11097: PUSH
11098: EMPTY
11099: LIST
11100: PLUS
11101: PPUSH
11102: LD_VAR 0 1
11106: PPUSH
11107: LD_INT 3
11109: PPUSH
11110: CALL 500 0 4
11114: GO 11143
// RussianAttack ( 3 , 3 + [ Difficulty ] , i , ru_north_spawn ) ;
11116: LD_INT 3
11118: PPUSH
11119: LD_INT 3
11121: PUSH
11122: LD_OWVAR 67
11126: PUSH
11127: EMPTY
11128: LIST
11129: PLUS
11130: PPUSH
11131: LD_VAR 0 1
11135: PPUSH
11136: LD_INT 3
11138: PPUSH
11139: CALL 500 0 4
// end ;
11143: PPOPN 1
11145: END
// every 5 5$20 trigger rus_pink do var i ;
11146: LD_EXP 38
11150: IFFALSE 11311
11152: GO 11154
11154: DISABLE
11155: LD_INT 0
11157: PPUSH
// begin enable ;
11158: ENABLE
// Wait ( Rand ( 0 0$53 , 1 1$27 ) ) ;
11159: LD_INT 1855
11161: PPUSH
11162: LD_INT 3045
11164: PPUSH
11165: CALL_OW 12
11169: PPUSH
11170: CALL_OW 67
// i := Rand ( 1 , 2 ) ;
11174: LD_ADDR_VAR 0 1
11178: PUSH
11179: LD_INT 1
11181: PPUSH
11182: LD_INT 2
11184: PPUSH
11185: CALL_OW 12
11189: ST_TO_ADDR
// if timer <= 20 20$00 then
11190: LD_EXP 48
11194: PUSH
11195: LD_INT 42000
11197: LESSEQUAL
11198: IFFALSE 11227
// RussianAttack ( 6 , 1 + [ Difficulty ] , i , ru_south_spawn ) ;
11200: LD_INT 6
11202: PPUSH
11203: LD_INT 1
11205: PUSH
11206: LD_OWVAR 67
11210: PUSH
11211: EMPTY
11212: LIST
11213: PLUS
11214: PPUSH
11215: LD_VAR 0 1
11219: PPUSH
11220: LD_INT 4
11222: PPUSH
11223: CALL 500 0 4
// if timer > 20 20$00 and timer <= 37 37$00 then
11227: LD_EXP 48
11231: PUSH
11232: LD_INT 42000
11234: GREATER
11235: PUSH
11236: LD_EXP 48
11240: PUSH
11241: LD_INT 77700
11243: LESSEQUAL
11244: AND
11245: IFFALSE 11274
// RussianAttack ( 6 , 2 + [ Difficulty ] , i , ru_south_spawn ) ;
11247: LD_INT 6
11249: PPUSH
11250: LD_INT 2
11252: PUSH
11253: LD_OWVAR 67
11257: PUSH
11258: EMPTY
11259: LIST
11260: PLUS
11261: PPUSH
11262: LD_VAR 0 1
11266: PPUSH
11267: LD_INT 4
11269: PPUSH
11270: CALL 500 0 4
// if timer > 37 37$00 then
11274: LD_EXP 48
11278: PUSH
11279: LD_INT 77700
11281: GREATER
11282: IFFALSE 11311
// RussianAttack ( 6 , 4 + [ Difficulty ] , i , ru_south_spawn ) ;
11284: LD_INT 6
11286: PPUSH
11287: LD_INT 4
11289: PUSH
11290: LD_OWVAR 67
11294: PUSH
11295: EMPTY
11296: LIST
11297: PLUS
11298: PPUSH
11299: LD_VAR 0 1
11303: PPUSH
11304: LD_INT 4
11306: PPUSH
11307: CALL 500 0 4
// end ;
11311: PPOPN 1
11313: END
// every 1 1$20 trigger timer > Rand ( 30 30$00 , 40 40$00 ) do var i , un ;
11314: LD_EXP 48
11318: PUSH
11319: LD_INT 63000
11321: PPUSH
11322: LD_INT 84000
11324: PPUSH
11325: CALL_OW 12
11329: GREATER
11330: IFFALSE 11492
11332: GO 11334
11334: DISABLE
11335: LD_INT 0
11337: PPUSH
11338: PPUSH
// begin for i = 1 to 2 + [ Difficulty ] do
11339: LD_ADDR_VAR 0 1
11343: PUSH
11344: DOUBLE
11345: LD_INT 1
11347: DEC
11348: ST_TO_ADDR
11349: LD_INT 2
11351: PUSH
11352: LD_OWVAR 67
11356: PUSH
11357: EMPTY
11358: LIST
11359: PLUS
11360: PUSH
11361: FOR_TO
11362: IFFALSE 11415
// begin uc_side := 6 ;
11364: LD_ADDR_OWVAR 20
11368: PUSH
11369: LD_INT 6
11371: ST_TO_ADDR
// uc_nation := 3 ;
11372: LD_ADDR_OWVAR 21
11376: PUSH
11377: LD_INT 3
11379: ST_TO_ADDR
// un := CreateHumanWithClass ( class_soldier , rus_skill ) ;
11380: LD_ADDR_VAR 0 2
11384: PUSH
11385: LD_INT 1
11387: PPUSH
11388: LD_EXP 36
11392: PPUSH
11393: CALL 55 0 2
11397: ST_TO_ADDR
// PlaceUnitArea ( un , ru_add , false ) ;
11398: LD_VAR 0 2
11402: PPUSH
11403: LD_INT 16
11405: PPUSH
11406: LD_INT 0
11408: PPUSH
11409: CALL_OW 49
// end ;
11413: GO 11361
11415: POP
11416: POP
// Wait ( 0 0$02 ) ;
11417: LD_INT 70
11419: PPUSH
11420: CALL_OW 67
// DialogueOn ;
11424: CALL_OW 6
// PlaceSeeing ( 8 , 11 , 2 , 10 ) ;
11428: LD_INT 8
11430: PPUSH
11431: LD_INT 11
11433: PPUSH
11434: LD_INT 2
11436: PPUSH
11437: LD_INT 10
11439: PPUSH
11440: CALL_OW 330
// Say ( AllPeo [ Rand ( 2 , 8 ) ] , Dsup ) ;
11444: LD_EXP 20
11448: PUSH
11449: LD_INT 2
11451: PPUSH
11452: LD_INT 8
11454: PPUSH
11455: CALL_OW 12
11459: ARRAY
11460: PPUSH
11461: LD_STRING Dsup
11463: PPUSH
11464: CALL_OW 88
// DialogueOff ;
11468: CALL_OW 7
// Wait ( 0 0$05 ) ;
11472: LD_INT 175
11474: PPUSH
11475: CALL_OW 67
// RemoveSeeing ( 8 , 11 , 2 ) ;
11479: LD_INT 8
11481: PPUSH
11482: LD_INT 11
11484: PPUSH
11485: LD_INT 2
11487: PPUSH
11488: CALL_OW 331
// end ; end_of_file
11492: PPOPN 2
11494: END
// every 0 0$01 trigger dip_points > 15 do
11495: LD_EXP 44
11499: PUSH
11500: LD_INT 15
11502: GREATER
11503: IFFALSE 11517
11505: GO 11507
11507: DISABLE
// begin enable ;
11508: ENABLE
// dip_points := 15 ;
11509: LD_ADDR_EXP 44
11513: PUSH
11514: LD_INT 15
11516: ST_TO_ADDR
// end ;
11517: END
// every 0 0$01 trigger dip_points < 0 do
11518: LD_EXP 44
11522: PUSH
11523: LD_INT 0
11525: LESS
11526: IFFALSE 11540
11528: GO 11530
11530: DISABLE
// begin enable ;
11531: ENABLE
// dip_points := 0 ;
11532: LD_ADDR_EXP 44
11536: PUSH
11537: LD_INT 0
11539: ST_TO_ADDR
// end ;
11540: END
// every 0 0$01 trigger FilterAllUnits ( [ f_class , class_apeman_soldier ] ) > 0 and game_started do var i ;
11541: LD_INT 25
11543: PUSH
11544: LD_INT 15
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: PPUSH
11551: CALL_OW 69
11555: PUSH
11556: LD_INT 0
11558: GREATER
11559: PUSH
11560: LD_EXP 33
11564: AND
11565: IFFALSE 11678
11567: GO 11569
11569: DISABLE
11570: LD_INT 0
11572: PPUSH
// begin i := Rand ( 1 , 3 ) ;
11573: LD_ADDR_VAR 0 1
11577: PUSH
11578: LD_INT 1
11580: PPUSH
11581: LD_INT 3
11583: PPUSH
11584: CALL_OW 12
11588: ST_TO_ADDR
// case i of 1 :
11589: LD_VAR 0 1
11593: PUSH
11594: LD_INT 1
11596: DOUBLE
11597: EQUAL
11598: IFTRUE 11602
11600: GO 11617
11602: POP
// Say ( Erwin , DE-ape1 ) ; 2 :
11603: LD_EXP 31
11607: PPUSH
11608: LD_STRING DE-ape1
11610: PPUSH
11611: CALL_OW 88
11615: GO 11664
11617: LD_INT 2
11619: DOUBLE
11620: EQUAL
11621: IFTRUE 11625
11623: GO 11640
11625: POP
// Say ( Erwin , DE-ape2 ) ; 3 :
11626: LD_EXP 31
11630: PPUSH
11631: LD_STRING DE-ape2
11633: PPUSH
11634: CALL_OW 88
11638: GO 11664
11640: LD_INT 3
11642: DOUBLE
11643: EQUAL
11644: IFTRUE 11648
11646: GO 11663
11648: POP
// Say ( Erwin , DE-ape3 ) ; end ;
11649: LD_EXP 31
11653: PPUSH
11654: LD_STRING DE-ape3
11656: PPUSH
11657: CALL_OW 88
11661: GO 11664
11663: POP
// dip_points := dip_points - 2 ;
11664: LD_ADDR_EXP 44
11668: PUSH
11669: LD_EXP 44
11673: PUSH
11674: LD_INT 2
11676: MINUS
11677: ST_TO_ADDR
// end ;
11678: PPOPN 1
11680: END
// every 0 0$01 trigger FilterAllUnits ( [ f_control , control_remote ] ) > 0 and game_started do
11681: LD_INT 33
11683: PUSH
11684: LD_INT 2
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PPUSH
11691: CALL_OW 69
11695: PUSH
11696: LD_INT 0
11698: GREATER
11699: PUSH
11700: LD_EXP 33
11704: AND
11705: IFFALSE 11736
11707: GO 11709
11709: DISABLE
// begin Say ( Erwin , DE-ct ) ;
11710: LD_EXP 31
11714: PPUSH
11715: LD_STRING DE-ct
11717: PPUSH
11718: CALL_OW 88
// dip_points := dip_points + 3 ;
11722: LD_ADDR_EXP 44
11726: PUSH
11727: LD_EXP 44
11731: PUSH
11732: LD_INT 3
11734: PLUS
11735: ST_TO_ADDR
// end ;
11736: END
// every 0 0$03 trigger game_started do var filter , i , p , deps ;
11737: LD_EXP 33
11741: IFFALSE 11970
11743: GO 11745
11745: DISABLE
11746: LD_INT 0
11748: PPUSH
11749: PPUSH
11750: PPUSH
11751: PPUSH
// begin enable ;
11752: ENABLE
// deps := [ north_dep , south_dep ] ;
11753: LD_ADDR_VAR 0 4
11757: PUSH
11758: LD_INT 2
11760: PUSH
11761: LD_INT 6
11763: PUSH
11764: EMPTY
11765: LIST
11766: LIST
11767: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ [ f_side , 2 ] , [ f_or , [ f_class , 2 ] , [ f_weapon , ar_cargo_bay ] ] ] ] ) ;
11768: LD_ADDR_VAR 0 1
11772: PUSH
11773: LD_INT 22
11775: PUSH
11776: LD_INT 2
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 2
11785: PUSH
11786: LD_INT 25
11788: PUSH
11789: LD_INT 2
11791: PUSH
11792: EMPTY
11793: LIST
11794: LIST
11795: PUSH
11796: LD_INT 34
11798: PUSH
11799: LD_INT 32
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: EMPTY
11807: LIST
11808: LIST
11809: LIST
11810: PUSH
11811: EMPTY
11812: LIST
11813: LIST
11814: PUSH
11815: EMPTY
11816: LIST
11817: PPUSH
11818: CALL_OW 69
11822: ST_TO_ADDR
// p := Rand ( 1 , 3 ) ;
11823: LD_ADDR_VAR 0 3
11827: PUSH
11828: LD_INT 1
11830: PPUSH
11831: LD_INT 3
11833: PPUSH
11834: CALL_OW 12
11838: ST_TO_ADDR
// for i = 1 to filter do
11839: LD_ADDR_VAR 0 2
11843: PUSH
11844: DOUBLE
11845: LD_INT 1
11847: DEC
11848: ST_TO_ADDR
11849: LD_VAR 0 1
11853: PUSH
11854: FOR_TO
11855: IFFALSE 11968
// if IsInArea ( filter [ i ] , ar_robb ) then
11857: LD_VAR 0 1
11861: PUSH
11862: LD_VAR 0 2
11866: ARRAY
11867: PPUSH
11868: LD_INT 14
11870: PPUSH
11871: CALL_OW 308
11875: IFFALSE 11966
// begin case p of 1 :
11877: LD_VAR 0 3
11881: PUSH
11882: LD_INT 1
11884: DOUBLE
11885: EQUAL
11886: IFTRUE 11890
11888: GO 11905
11890: POP
// Say ( Erwin , DE-robb1 ) ; 2 :
11891: LD_EXP 31
11895: PPUSH
11896: LD_STRING DE-robb1
11898: PPUSH
11899: CALL_OW 88
11903: GO 11952
11905: LD_INT 2
11907: DOUBLE
11908: EQUAL
11909: IFTRUE 11913
11911: GO 11928
11913: POP
// Say ( Erwin , DE-robb2 ) ; 3 :
11914: LD_EXP 31
11918: PPUSH
11919: LD_STRING DE-robb2
11921: PPUSH
11922: CALL_OW 88
11926: GO 11952
11928: LD_INT 3
11930: DOUBLE
11931: EQUAL
11932: IFTRUE 11936
11934: GO 11951
11936: POP
// Say ( Erwin , DE-robb3 ) ; end ;
11937: LD_EXP 31
11941: PPUSH
11942: LD_STRING DE-robb3
11944: PPUSH
11945: CALL_OW 88
11949: GO 11952
11951: POP
// dip_points := dip_points - 1 ;
11952: LD_ADDR_EXP 44
11956: PUSH
11957: LD_EXP 44
11961: PUSH
11962: LD_INT 1
11964: MINUS
11965: ST_TO_ADDR
// end ;
11966: GO 11854
11968: POP
11969: POP
// end ;
11970: PPOPN 4
11972: END
// every 0 0$01 trigger game_started and FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) = 0 do
11973: LD_EXP 33
11977: PUSH
11978: LD_INT 22
11980: PUSH
11981: LD_INT 8
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 25
11990: PUSH
11991: LD_INT 2
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PPUSH
12002: CALL_OW 69
12006: PUSH
12007: LD_INT 0
12009: EQUAL
12010: AND
12011: IFFALSE 12028
12013: GO 12015
12015: DISABLE
// Say ( Erwin , DE-help ) ;
12016: LD_EXP 31
12020: PPUSH
12021: LD_STRING DE-help
12023: PPUSH
12024: CALL_OW 88
12028: END
// every 0 0$01 trigger dip_points >= 10 do
12029: LD_EXP 44
12033: PUSH
12034: LD_INT 10
12036: GREATEREQUAL
12037: IFFALSE 12067
12039: GO 12041
12041: DISABLE
// begin Say ( Erwin , DE-mortar ) ;
12042: LD_EXP 31
12046: PPUSH
12047: LD_STRING DE-mortar
12049: PPUSH
12050: CALL_OW 88
// SetTech ( tech_mortar , 2 , state_researched ) ;
12054: LD_INT 41
12056: PPUSH
12057: LD_INT 2
12059: PPUSH
12060: LD_INT 2
12062: PPUSH
12063: CALL_OW 322
// end ;
12067: END
// every 0 0$01 trigger dip_points >= 13 do
12068: LD_EXP 44
12072: PUSH
12073: LD_INT 13
12075: GREATEREQUAL
12076: IFFALSE 12106
12078: GO 12080
12080: DISABLE
// begin Say ( Erwin , DE-mines ) ;
12081: LD_EXP 31
12085: PPUSH
12086: LD_STRING DE-mines
12088: PPUSH
12089: CALL_OW 88
// SetTech ( tech_remcharge , 2 , state_researched ) ;
12093: LD_INT 18
12095: PPUSH
12096: LD_INT 2
12098: PPUSH
12099: LD_INT 2
12101: PPUSH
12102: CALL_OW 322
// end ;
12106: END
// every 0 0$01 trigger dip_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
12107: LD_EXP 47
12111: PUSH
12112: LD_INT 3
12114: PUSH
12115: LD_INT 4
12117: PUSH
12118: LD_INT 5
12120: PUSH
12121: EMPTY
12122: LIST
12123: LIST
12124: LIST
12125: PUSH
12126: LD_OWVAR 67
12130: ARRAY
12131: GREATEREQUAL
12132: IFFALSE 12172
12134: GO 12136
12136: DISABLE
// begin enable ;
12137: ENABLE
// Say ( Erwin , DE-ruscount ) ;
12138: LD_EXP 31
12142: PPUSH
12143: LD_STRING DE-ruscount
12145: PPUSH
12146: CALL_OW 88
// dip_points := dip_points + 1 ;
12150: LD_ADDR_EXP 44
12154: PUSH
12155: LD_EXP 44
12159: PUSH
12160: LD_INT 1
12162: PLUS
12163: ST_TO_ADDR
// dip_count := 0 ;
12164: LD_ADDR_EXP 47
12168: PUSH
12169: LD_INT 0
12171: ST_TO_ADDR
// end ;
12172: END
// on BuildingStarted ( build , builder ) do begin if IsInArea ( build , al_area ) and GetSide ( build ) = 2 then
12173: LD_VAR 0 1
12177: PPUSH
12178: LD_INT 15
12180: PPUSH
12181: CALL_OW 308
12185: PUSH
12186: LD_VAR 0 1
12190: PPUSH
12191: CALL_OW 255
12195: PUSH
12196: LD_INT 2
12198: EQUAL
12199: AND
12200: IFFALSE 12246
// begin CenterNowOnUnits ( build ) ;
12202: LD_VAR 0 1
12206: PPUSH
12207: CALL_OW 87
// Say ( Erwin , DE-burem ) ;
12211: LD_EXP 31
12215: PPUSH
12216: LD_STRING DE-burem
12218: PPUSH
12219: CALL_OW 88
// dip_points := dip_points - 1 ;
12223: LD_ADDR_EXP 44
12227: PUSH
12228: LD_EXP 44
12232: PUSH
12233: LD_INT 1
12235: MINUS
12236: ST_TO_ADDR
// RemoveUnit ( build ) ;
12237: LD_VAR 0 1
12241: PPUSH
12242: CALL_OW 64
// end ; end ; end_of_file
12246: PPOPN 2
12248: END
// export timer ; every 1 trigger game_started do
12249: LD_EXP 33
12253: IFFALSE 12274
12255: GO 12257
12257: DISABLE
// begin counter_start := true ;
12258: LD_ADDR_EXP 45
12262: PUSH
12263: LD_INT 1
12265: ST_TO_ADDR
// timer := 0 0$00 ;
12266: LD_ADDR_EXP 48
12270: PUSH
12271: LD_INT 0
12273: ST_TO_ADDR
// end ;
12274: END
// every 0 0$01 trigger counter_start do
12275: LD_EXP 45
12279: IFFALSE 12326
12281: GO 12283
12283: DISABLE
// begin enable ;
12284: ENABLE
// Display_Strings := [ #Ar06-1 , timer , #Ar06-2 , dip_points ] ;
12285: LD_ADDR_OWVAR 47
12289: PUSH
12290: LD_STRING #Ar06-1
12292: PUSH
12293: LD_EXP 48
12297: PUSH
12298: LD_STRING #Ar06-2
12300: PUSH
12301: LD_EXP 44
12305: PUSH
12306: EMPTY
12307: LIST
12308: LIST
12309: LIST
12310: LIST
12311: ST_TO_ADDR
// timer := timer + 0 0$01 ;
12312: LD_ADDR_EXP 48
12316: PUSH
12317: LD_EXP 48
12321: PUSH
12322: LD_INT 35
12324: PLUS
12325: ST_TO_ADDR
// end ; end_of_file
12326: END
// export function SaveFunction ; begin
12327: LD_INT 0
12329: PPUSH
// RewardPeople ( AllPeo ) ;
12330: LD_EXP 20
12334: PPUSH
12335: CALL_OW 43
// SaveCharacters ( Louis , Louis ) ;
12339: LD_EXP 1
12343: PPUSH
12344: LD_STRING Louis
12346: PPUSH
12347: CALL_OW 38
// if IsLive ( Martin ) then
12351: LD_EXP 2
12355: PPUSH
12356: CALL_OW 300
12360: IFFALSE 12374
// begin SaveCharacters ( Martin , Martin_06 ) ;
12362: LD_EXP 2
12366: PPUSH
12367: LD_STRING Martin_06
12369: PPUSH
12370: CALL_OW 38
// end ; if IsLive ( Karla ) then
12374: LD_EXP 3
12378: PPUSH
12379: CALL_OW 300
12383: IFFALSE 12397
// begin SaveCharacters ( Karla , Karla_06 ) ;
12385: LD_EXP 3
12389: PPUSH
12390: LD_STRING Karla_06
12392: PPUSH
12393: CALL_OW 38
// end ; if IsLive ( Dwein ) then
12397: LD_EXP 4
12401: PPUSH
12402: CALL_OW 300
12406: IFFALSE 12420
// begin SaveCharacters ( Dwein , Dwein_06 ) ;
12408: LD_EXP 4
12412: PPUSH
12413: LD_STRING Dwein_06
12415: PPUSH
12416: CALL_OW 38
// end ; if IsLive ( Joachim ) then
12420: LD_EXP 5
12424: PPUSH
12425: CALL_OW 300
12429: IFFALSE 12443
// begin SaveCharacters ( Joachim , Joachim_06 ) ;
12431: LD_EXP 5
12435: PPUSH
12436: LD_STRING Joachim_06
12438: PPUSH
12439: CALL_OW 38
// end ; if IsLive ( Olaf ) then
12443: LD_EXP 6
12447: PPUSH
12448: CALL_OW 300
12452: IFFALSE 12466
// begin SaveCharacters ( Olaf , Olaf_06 ) ;
12454: LD_EXP 6
12458: PPUSH
12459: LD_STRING Olaf_06
12461: PPUSH
12462: CALL_OW 38
// end ; if IsLive ( Mmark ) then
12466: LD_EXP 7
12470: PPUSH
12471: CALL_OW 300
12475: IFFALSE 12489
// begin SaveCharacters ( Mmark , Mmark_06 ) ;
12477: LD_EXP 7
12481: PPUSH
12482: LD_STRING Mmark_06
12484: PPUSH
12485: CALL_OW 38
// end ; if IsLive ( Herczeg ) then
12489: LD_EXP 8
12493: PPUSH
12494: CALL_OW 300
12498: IFFALSE 12512
// begin SaveCharacters ( Herczeg , Herczeg_06 ) ;
12500: LD_EXP 8
12504: PPUSH
12505: LD_STRING Herczeg_06
12507: PPUSH
12508: CALL_OW 38
// end ; if IsLive ( Kantor ) then
12512: LD_EXP 10
12516: PPUSH
12517: CALL_OW 300
12521: IFFALSE 12535
// begin SaveCharacters ( Kantor , Kantor_06 ) ;
12523: LD_EXP 10
12527: PPUSH
12528: LD_STRING Kantor_06
12530: PPUSH
12531: CALL_OW 38
// end ; if IsLive ( Ronn ) then
12535: LD_EXP 11
12539: PPUSH
12540: CALL_OW 300
12544: IFFALSE 12558
// begin SaveCharacters ( Ronn , Ronn_06 ) ;
12546: LD_EXP 11
12550: PPUSH
12551: LD_STRING Ronn_06
12553: PPUSH
12554: CALL_OW 38
// end ; if IsLive ( Mia ) then
12558: LD_EXP 9
12562: PPUSH
12563: CALL_OW 300
12567: IFFALSE 12581
// begin SaveCharacters ( Mia , Mia_06 ) ;
12569: LD_EXP 9
12573: PPUSH
12574: LD_STRING Mia_06
12576: PPUSH
12577: CALL_OW 38
// end ; if IsLive ( Gunther ) then
12581: LD_EXP 12
12585: PPUSH
12586: CALL_OW 300
12590: IFFALSE 12604
// begin SaveCharacters ( Gunther , Gunther_06 ) ;
12592: LD_EXP 12
12596: PPUSH
12597: LD_STRING Gunther_06
12599: PPUSH
12600: CALL_OW 38
// end ; if IsLive ( ot1 ) then
12604: LD_EXP 13
12608: PPUSH
12609: CALL_OW 300
12613: IFFALSE 12627
// begin SaveCharacters ( ot1 , ot1_06 ) ;
12615: LD_EXP 13
12619: PPUSH
12620: LD_STRING ot1_06
12622: PPUSH
12623: CALL_OW 38
// end ; if IsLive ( ot2 ) then
12627: LD_EXP 14
12631: PPUSH
12632: CALL_OW 300
12636: IFFALSE 12650
// begin SaveCharacters ( ot2 , ot2_06 ) ;
12638: LD_EXP 14
12642: PPUSH
12643: LD_STRING ot2_06
12645: PPUSH
12646: CALL_OW 38
// end ; if IsLive ( ot3 ) then
12650: LD_EXP 15
12654: PPUSH
12655: CALL_OW 300
12659: IFFALSE 12673
// begin SaveCharacters ( ot3 , ot3_06 ) ;
12661: LD_EXP 15
12665: PPUSH
12666: LD_STRING ot3_06
12668: PPUSH
12669: CALL_OW 38
// end ; if IsLive ( ot4 ) then
12673: LD_EXP 16
12677: PPUSH
12678: CALL_OW 300
12682: IFFALSE 12696
// begin SaveCharacters ( ot4 , ot4_06 ) ;
12684: LD_EXP 16
12688: PPUSH
12689: LD_STRING ot4_06
12691: PPUSH
12692: CALL_OW 38
// end ; if IsLive ( ot5 ) then
12696: LD_EXP 17
12700: PPUSH
12701: CALL_OW 300
12705: IFFALSE 12719
// begin SaveCharacters ( ot5 , ot5_06 ) ;
12707: LD_EXP 17
12711: PPUSH
12712: LD_STRING ot5_06
12714: PPUSH
12715: CALL_OW 38
// end ; if IsLive ( ot6 ) then
12719: LD_EXP 18
12723: PPUSH
12724: CALL_OW 300
12728: IFFALSE 12742
// begin SaveCharacters ( ot6 , ot6_06 ) ;
12730: LD_EXP 18
12734: PPUSH
12735: LD_STRING ot6_06
12737: PPUSH
12738: CALL_OW 38
// end ; if IsLive ( ot7 ) then
12742: LD_EXP 19
12746: PPUSH
12747: CALL_OW 300
12751: IFFALSE 12765
// begin SaveCharacters ( ot7 , ot7_06 ) ;
12753: LD_EXP 19
12757: PPUSH
12758: LD_STRING ot7_06
12760: PPUSH
12761: CALL_OW 38
// end ; end ;
12765: LD_VAR 0 1
12769: RET
