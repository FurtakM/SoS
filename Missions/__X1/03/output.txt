// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 38 0 0
// PrepareNature ;
   8: CALL 681 0 0
// PrepareArabian ;
  12: CALL 1996 0 0
// PrepareAmerican ;
  16: CALL 5021 0 0
// if debug then
  20: LD_EXP 1
  24: IFFALSE 33
// FogOff ( 2 ) ;
  26: LD_INT 2
  28: PPUSH
  29: CALL_OW 344
// Action ;
  33: CALL 9680 0 0
// end ;
  37: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , allowCargoEvacuation , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , capturedCargoCounter , americanStartRun , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , farmerHumanLoseCounter , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := false ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 0
  48: ST_TO_ADDR
// prefix := 02_ ;
  49: LD_ADDR_EXP 2
  53: PUSH
  54: LD_STRING 02_
  56: ST_TO_ADDR
// eventAttack := 1 ;
  57: LD_ADDR_EXP 24
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// deadCounter := 0 ;
  65: LD_ADDR_EXP 9
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// gameStarted := false ;
  73: LD_ADDR_EXP 3
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// farmerBaseReady := false ;
  81: LD_ADDR_EXP 4
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// americanBaseSpoted := false ;
  89: LD_ADDR_EXP 5
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// americanBaseCaptured := false ;
  97: LD_ADDR_EXP 6
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// americanHasEscaped := false ;
 105: LD_ADDR_EXP 8
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// workshopBuilded := false ;
 113: LD_ADDR_EXP 10
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// retreatAllowed := false ;
 121: LD_ADDR_EXP 11
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// allowConvoys := false ;
 129: LD_ADDR_EXP 12
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// farmerCrates := 0 ;
 137: LD_ADDR_EXP 15
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 145: LD_ADDR_EXP 16
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 153: LD_ADDR_EXP 17
 157: PUSH
 158: LD_INT 63000
 160: PUSH
 161: LD_INT 52500
 163: PUSH
 164: LD_INT 46200
 166: PUSH
 167: EMPTY
 168: LIST
 169: LIST
 170: LIST
 171: PUSH
 172: LD_OWVAR 67
 176: ARRAY
 177: ST_TO_ADDR
// farmerHumanLoseCounter := 0 ;
 178: LD_ADDR_EXP 20
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 186: LD_ADDR_EXP 18
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// attackWave := 1 ;
 194: LD_ADDR_EXP 19
 198: PUSH
 199: LD_INT 1
 201: ST_TO_ADDR
// omarCargoCounter := [ 6 , 8 , 10 ] [ Difficulty ] ;
 202: LD_ADDR_EXP 21
 206: PUSH
 207: LD_INT 6
 209: PUSH
 210: LD_INT 8
 212: PUSH
 213: LD_INT 10
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: PUSH
 221: LD_OWVAR 67
 225: ARRAY
 226: ST_TO_ADDR
// vehCounter := 0 ;
 227: LD_ADDR_EXP 22
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// convoyCounter := 0 ;
 235: LD_ADDR_EXP 23
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// ibrahimInDepot := false ;
 243: LD_ADDR_EXP 25
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// ibrahimIsFree := false ;
 251: LD_ADDR_EXP 26
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// maxConvoys := [ 16 , 16 , 15 ] [ Difficulty ] ;
 259: LD_ADDR_EXP 27
 263: PUSH
 264: LD_INT 16
 266: PUSH
 267: LD_INT 16
 269: PUSH
 270: LD_INT 15
 272: PUSH
 273: EMPTY
 274: LIST
 275: LIST
 276: LIST
 277: PUSH
 278: LD_OWVAR 67
 282: ARRAY
 283: ST_TO_ADDR
// capturedCargoCounter := 0 ;
 284: LD_ADDR_EXP 13
 288: PUSH
 289: LD_INT 0
 291: ST_TO_ADDR
// allowCargoEvacuation := false ;
 292: LD_ADDR_EXP 7
 296: PUSH
 297: LD_INT 0
 299: ST_TO_ADDR
// americanStartRun := false ;
 300: LD_ADDR_EXP 14
 304: PUSH
 305: LD_INT 0
 307: ST_TO_ADDR
// end ; end_of_file
 308: LD_VAR 0 1
 312: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 313: LD_INT 0
 315: PPUSH
 316: PPUSH
// if exist_mode then
 317: LD_VAR 0 2
 321: IFFALSE 346
// unit := CreateCharacter ( prefix & ident ) else
 323: LD_ADDR_VAR 0 5
 327: PUSH
 328: LD_VAR 0 3
 332: PUSH
 333: LD_VAR 0 1
 337: STR
 338: PPUSH
 339: CALL_OW 34
 343: ST_TO_ADDR
 344: GO 361
// unit := NewCharacter ( ident ) ;
 346: LD_ADDR_VAR 0 5
 350: PUSH
 351: LD_VAR 0 1
 355: PPUSH
 356: CALL_OW 25
 360: ST_TO_ADDR
// result := unit ;
 361: LD_ADDR_VAR 0 4
 365: PUSH
 366: LD_VAR 0 5
 370: ST_TO_ADDR
// end ;
 371: LD_VAR 0 4
 375: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 376: LD_INT 0
 378: PPUSH
// uc_side := side ;
 379: LD_ADDR_OWVAR 20
 383: PUSH
 384: LD_VAR 0 1
 388: ST_TO_ADDR
// uc_nation := nation ;
 389: LD_ADDR_OWVAR 21
 393: PUSH
 394: LD_VAR 0 2
 398: ST_TO_ADDR
// vc_chassis := chassis ;
 399: LD_ADDR_OWVAR 37
 403: PUSH
 404: LD_VAR 0 3
 408: ST_TO_ADDR
// vc_engine := engine ;
 409: LD_ADDR_OWVAR 39
 413: PUSH
 414: LD_VAR 0 4
 418: ST_TO_ADDR
// vc_control := control ;
 419: LD_ADDR_OWVAR 38
 423: PUSH
 424: LD_VAR 0 5
 428: ST_TO_ADDR
// vc_weapon := weapon ;
 429: LD_ADDR_OWVAR 40
 433: PUSH
 434: LD_VAR 0 6
 438: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 439: LD_ADDR_OWVAR 41
 443: PUSH
 444: LD_VAR 0 7
 448: ST_TO_ADDR
// result := CreateVehicle ;
 449: LD_ADDR_VAR 0 8
 453: PUSH
 454: CALL_OW 45
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 8
 463: RET
// export function SayX ( units , ident ) ; var i ; begin
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// result := false ;
 468: LD_ADDR_VAR 0 3
 472: PUSH
 473: LD_INT 0
 475: ST_TO_ADDR
// if not units then
 476: LD_VAR 0 1
 480: NOT
 481: IFFALSE 485
// exit ;
 483: GO 539
// for i in units do
 485: LD_ADDR_VAR 0 4
 489: PUSH
 490: LD_VAR 0 1
 494: PUSH
 495: FOR_IN
 496: IFFALSE 537
// if IsOk ( i ) then
 498: LD_VAR 0 4
 502: PPUSH
 503: CALL_OW 302
 507: IFFALSE 535
// begin Say ( i , ident ) ;
 509: LD_VAR 0 4
 513: PPUSH
 514: LD_VAR 0 2
 518: PPUSH
 519: CALL_OW 88
// result := i ;
 523: LD_ADDR_VAR 0 3
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// break ;
 533: GO 537
// end ;
 535: GO 495
 537: POP
 538: POP
// end ;
 539: LD_VAR 0 3
 543: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 544: LD_INT 0
 546: PPUSH
 547: PPUSH
// InitUc ;
 548: CALL_OW 18
// InitHc ;
 552: CALL_OW 19
// uc_side := 0 ;
 556: LD_ADDR_OWVAR 20
 560: PUSH
 561: LD_INT 0
 563: ST_TO_ADDR
// uc_nation := 0 ;
 564: LD_ADDR_OWVAR 21
 568: PUSH
 569: LD_INT 0
 571: ST_TO_ADDR
// for i = 1 to amount do
 572: LD_ADDR_VAR 0 4
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 2
 586: PUSH
 587: FOR_TO
 588: IFFALSE 670
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 590: LD_ADDR_OWVAR 29
 594: PUSH
 595: LD_INT 9
 597: PPUSH
 598: LD_INT 12
 600: PPUSH
 601: CALL_OW 12
 605: PUSH
 606: LD_INT 9
 608: PPUSH
 609: LD_INT 12
 611: PPUSH
 612: CALL_OW 12
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 621: LD_ADDR_OWVAR 35
 625: PUSH
 626: LD_INT 1
 628: NEG
 629: PPUSH
 630: LD_INT 1
 632: PPUSH
 633: CALL_OW 12
 637: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 638: LD_INT 0
 640: PPUSH
 641: LD_INT 12
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 651: CALL_OW 44
 655: PPUSH
 656: LD_VAR 0 1
 660: PPUSH
 661: LD_INT 0
 663: PPUSH
 664: CALL_OW 49
// end ;
 668: GO 587
 670: POP
 671: POP
// InitHc ;
 672: CALL_OW 19
// end ;
 676: LD_VAR 0 3
 680: RET
// export function PrepareNature ; var i ; begin
 681: LD_INT 0
 683: PPUSH
 684: PPUSH
// SpawnApeman ( forest , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
 685: LD_INT 2
 687: PPUSH
 688: LD_INT 5
 690: PUSH
 691: LD_INT 4
 693: PUSH
 694: LD_INT 4
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_OWVAR 67
 706: ARRAY
 707: PPUSH
 708: CALL 544 0 2
// for i := 1 to 2 do
 712: LD_ADDR_VAR 0 2
 716: PUSH
 717: DOUBLE
 718: LD_INT 1
 720: DEC
 721: ST_TO_ADDR
 722: LD_INT 2
 724: PUSH
 725: FOR_TO
 726: IFFALSE 761
// begin hc_class := 21 ;
 728: LD_ADDR_OWVAR 28
 732: PUSH
 733: LD_INT 21
 735: ST_TO_ADDR
// hc_gallery :=  ;
 736: LD_ADDR_OWVAR 33
 740: PUSH
 741: LD_STRING 
 743: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 744: CALL_OW 44
 748: PPUSH
 749: LD_INT 2
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL_OW 49
// end ;
 759: GO 725
 761: POP
 762: POP
// for i := 1 to 2 do
 763: LD_ADDR_VAR 0 2
 767: PUSH
 768: DOUBLE
 769: LD_INT 1
 771: DEC
 772: ST_TO_ADDR
 773: LD_INT 2
 775: PUSH
 776: FOR_TO
 777: IFFALSE 812
// begin hc_class := 18 ;
 779: LD_ADDR_OWVAR 28
 783: PUSH
 784: LD_INT 18
 786: ST_TO_ADDR
// hc_gallery :=  ;
 787: LD_ADDR_OWVAR 33
 791: PUSH
 792: LD_STRING 
 794: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 795: CALL_OW 44
 799: PPUSH
 800: LD_INT 2
 802: PPUSH
 803: LD_INT 0
 805: PPUSH
 806: CALL_OW 49
// end ;
 810: GO 776
 812: POP
 813: POP
// for i := 1 to 2 do
 814: LD_ADDR_VAR 0 2
 818: PUSH
 819: DOUBLE
 820: LD_INT 1
 822: DEC
 823: ST_TO_ADDR
 824: LD_INT 2
 826: PUSH
 827: FOR_TO
 828: IFFALSE 863
// begin hc_class := 13 ;
 830: LD_ADDR_OWVAR 28
 834: PUSH
 835: LD_INT 13
 837: ST_TO_ADDR
// hc_gallery :=  ;
 838: LD_ADDR_OWVAR 33
 842: PUSH
 843: LD_STRING 
 845: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 846: CALL_OW 44
 850: PPUSH
 851: LD_INT 2
 853: PPUSH
 854: LD_INT 0
 856: PPUSH
 857: CALL_OW 49
// end ;
 861: GO 827
 863: POP
 864: POP
// end ;
 865: LD_VAR 0 1
 869: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 870: LD_INT 0
 872: PPUSH
 873: PPUSH
 874: PPUSH
// if not observer or not unit then
 875: LD_VAR 0 1
 879: NOT
 880: PUSH
 881: LD_VAR 0 2
 885: NOT
 886: OR
 887: IFFALSE 891
// exit ;
 889: GO 939
// if not See ( GetSide ( observer ) , unit ) then
 891: LD_VAR 0 1
 895: PPUSH
 896: CALL_OW 255
 900: PPUSH
 901: LD_VAR 0 2
 905: PPUSH
 906: CALL_OW 292
 910: NOT
 911: IFFALSE 915
// exit ;
 913: GO 939
// result := GetDistUnits ( observer , unit ) < 12 ;
 915: LD_ADDR_VAR 0 3
 919: PUSH
 920: LD_VAR 0 1
 924: PPUSH
 925: LD_VAR 0 2
 929: PPUSH
 930: CALL_OW 296
 934: PUSH
 935: LD_INT 12
 937: LESS
 938: ST_TO_ADDR
// end ;
 939: LD_VAR 0 3
 943: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 944: LD_INT 0
 946: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 947: LD_VAR 0 2
 951: PUSH
 952: LD_INT 1
 954: ARRAY
 955: PPUSH
 956: LD_VAR 0 2
 960: PUSH
 961: LD_INT 2
 963: ARRAY
 964: PPUSH
 965: CALL_OW 488
 969: PUSH
 970: LD_VAR 0 2
 974: PUSH
 975: LD_INT 1
 977: ARRAY
 978: PPUSH
 979: LD_VAR 0 2
 983: PUSH
 984: LD_INT 2
 986: ARRAY
 987: PPUSH
 988: CALL_OW 428
 992: PUSH
 993: LD_INT 0
 995: EQUAL
 996: AND
 997: IFFALSE 1031
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 999: LD_VAR 0 1
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_INT 1
1011: ARRAY
1012: PPUSH
1013: LD_VAR 0 2
1017: PUSH
1018: LD_INT 2
1020: ARRAY
1021: PPUSH
1022: LD_VAR 0 3
1026: PPUSH
1027: CALL_OW 48
// end ;
1031: LD_VAR 0 4
1035: RET
// export function Video ( mode ) ; begin
1036: LD_INT 0
1038: PPUSH
// ingame_video = mode ;
1039: LD_ADDR_OWVAR 52
1043: PUSH
1044: LD_VAR 0 1
1048: ST_TO_ADDR
// interface_hidden = mode ;
1049: LD_ADDR_OWVAR 54
1053: PUSH
1054: LD_VAR 0 1
1058: ST_TO_ADDR
// end ;
1059: LD_VAR 0 2
1063: RET
// export function ReverseArray ( array ) ; var i ; begin
1064: LD_INT 0
1066: PPUSH
1067: PPUSH
// if not array then
1068: LD_VAR 0 1
1072: NOT
1073: IFFALSE 1077
// exit ;
1075: GO 1135
// result := [ ] ;
1077: LD_ADDR_VAR 0 2
1081: PUSH
1082: EMPTY
1083: ST_TO_ADDR
// for i := 1 to array do
1084: LD_ADDR_VAR 0 3
1088: PUSH
1089: DOUBLE
1090: LD_INT 1
1092: DEC
1093: ST_TO_ADDR
1094: LD_VAR 0 1
1098: PUSH
1099: FOR_TO
1100: IFFALSE 1133
// result := Insert ( result , 1 , array [ i ] ) ;
1102: LD_ADDR_VAR 0 2
1106: PUSH
1107: LD_VAR 0 2
1111: PPUSH
1112: LD_INT 1
1114: PPUSH
1115: LD_VAR 0 1
1119: PUSH
1120: LD_VAR 0 3
1124: ARRAY
1125: PPUSH
1126: CALL_OW 2
1130: ST_TO_ADDR
1131: GO 1099
1133: POP
1134: POP
// end ;
1135: LD_VAR 0 2
1139: RET
// export function ComExit ( unit ) ; begin
1140: LD_INT 0
1142: PPUSH
// result := IsInUnit ( unit ) ;
1143: LD_ADDR_VAR 0 2
1147: PUSH
1148: LD_VAR 0 1
1152: PPUSH
1153: CALL_OW 310
1157: ST_TO_ADDR
// if not result then
1158: LD_VAR 0 2
1162: NOT
1163: IFFALSE 1167
// exit ;
1165: GO 1202
// if GetType ( result ) = unit_vehicle then
1167: LD_VAR 0 2
1171: PPUSH
1172: CALL_OW 247
1176: PUSH
1177: LD_INT 2
1179: EQUAL
1180: IFFALSE 1193
// ComExitVehicle ( unit ) else
1182: LD_VAR 0 1
1186: PPUSH
1187: CALL_OW 121
1191: GO 1202
// ComExitBuilding ( unit ) ;
1193: LD_VAR 0 1
1197: PPUSH
1198: CALL_OW 122
// end ;
1202: LD_VAR 0 2
1206: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1207: LD_INT 0
1209: PPUSH
1210: PPUSH
// if not side or not nation then
1211: LD_VAR 0 1
1215: NOT
1216: PUSH
1217: LD_VAR 0 2
1221: NOT
1222: OR
1223: IFFALSE 1227
// exit ;
1225: GO 1991
// case nation of nation_american :
1227: LD_VAR 0 2
1231: PUSH
1232: LD_INT 1
1234: DOUBLE
1235: EQUAL
1236: IFTRUE 1240
1238: GO 1454
1240: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1241: LD_ADDR_VAR 0 4
1245: PUSH
1246: LD_INT 35
1248: PUSH
1249: LD_INT 45
1251: PUSH
1252: LD_INT 46
1254: PUSH
1255: LD_INT 47
1257: PUSH
1258: LD_INT 82
1260: PUSH
1261: LD_INT 83
1263: PUSH
1264: LD_INT 84
1266: PUSH
1267: LD_INT 85
1269: PUSH
1270: LD_INT 86
1272: PUSH
1273: LD_INT 1
1275: PUSH
1276: LD_INT 2
1278: PUSH
1279: LD_INT 6
1281: PUSH
1282: LD_INT 15
1284: PUSH
1285: LD_INT 16
1287: PUSH
1288: LD_INT 7
1290: PUSH
1291: LD_INT 12
1293: PUSH
1294: LD_INT 13
1296: PUSH
1297: LD_INT 10
1299: PUSH
1300: LD_INT 14
1302: PUSH
1303: LD_INT 20
1305: PUSH
1306: LD_INT 21
1308: PUSH
1309: LD_INT 22
1311: PUSH
1312: LD_INT 25
1314: PUSH
1315: LD_INT 32
1317: PUSH
1318: LD_INT 27
1320: PUSH
1321: LD_INT 36
1323: PUSH
1324: LD_INT 69
1326: PUSH
1327: LD_INT 39
1329: PUSH
1330: LD_INT 34
1332: PUSH
1333: LD_INT 40
1335: PUSH
1336: LD_INT 48
1338: PUSH
1339: LD_INT 49
1341: PUSH
1342: LD_INT 50
1344: PUSH
1345: LD_INT 51
1347: PUSH
1348: LD_INT 52
1350: PUSH
1351: LD_INT 53
1353: PUSH
1354: LD_INT 54
1356: PUSH
1357: LD_INT 55
1359: PUSH
1360: LD_INT 56
1362: PUSH
1363: LD_INT 57
1365: PUSH
1366: LD_INT 58
1368: PUSH
1369: LD_INT 59
1371: PUSH
1372: LD_INT 60
1374: PUSH
1375: LD_INT 61
1377: PUSH
1378: LD_INT 62
1380: PUSH
1381: LD_INT 80
1383: PUSH
1384: LD_INT 82
1386: PUSH
1387: LD_INT 83
1389: PUSH
1390: LD_INT 84
1392: PUSH
1393: LD_INT 85
1395: PUSH
1396: LD_INT 86
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: ST_TO_ADDR
1452: GO 1915
1454: LD_INT 2
1456: DOUBLE
1457: EQUAL
1458: IFTRUE 1462
1460: GO 1684
1462: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1463: LD_ADDR_VAR 0 4
1467: PUSH
1468: LD_INT 35
1470: PUSH
1471: LD_INT 45
1473: PUSH
1474: LD_INT 46
1476: PUSH
1477: LD_INT 47
1479: PUSH
1480: LD_INT 82
1482: PUSH
1483: LD_INT 83
1485: PUSH
1486: LD_INT 84
1488: PUSH
1489: LD_INT 85
1491: PUSH
1492: LD_INT 87
1494: PUSH
1495: LD_INT 70
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 11
1503: PUSH
1504: LD_INT 3
1506: PUSH
1507: LD_INT 4
1509: PUSH
1510: LD_INT 5
1512: PUSH
1513: LD_INT 6
1515: PUSH
1516: LD_INT 15
1518: PUSH
1519: LD_INT 18
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: LD_INT 17
1527: PUSH
1528: LD_INT 8
1530: PUSH
1531: LD_INT 20
1533: PUSH
1534: LD_INT 21
1536: PUSH
1537: LD_INT 22
1539: PUSH
1540: LD_INT 72
1542: PUSH
1543: LD_INT 26
1545: PUSH
1546: LD_INT 69
1548: PUSH
1549: LD_INT 39
1551: PUSH
1552: LD_INT 40
1554: PUSH
1555: LD_INT 41
1557: PUSH
1558: LD_INT 42
1560: PUSH
1561: LD_INT 43
1563: PUSH
1564: LD_INT 48
1566: PUSH
1567: LD_INT 49
1569: PUSH
1570: LD_INT 50
1572: PUSH
1573: LD_INT 51
1575: PUSH
1576: LD_INT 52
1578: PUSH
1579: LD_INT 53
1581: PUSH
1582: LD_INT 54
1584: PUSH
1585: LD_INT 55
1587: PUSH
1588: LD_INT 56
1590: PUSH
1591: LD_INT 60
1593: PUSH
1594: LD_INT 61
1596: PUSH
1597: LD_INT 62
1599: PUSH
1600: LD_INT 66
1602: PUSH
1603: LD_INT 67
1605: PUSH
1606: LD_INT 68
1608: PUSH
1609: LD_INT 81
1611: PUSH
1612: LD_INT 82
1614: PUSH
1615: LD_INT 83
1617: PUSH
1618: LD_INT 84
1620: PUSH
1621: LD_INT 85
1623: PUSH
1624: LD_INT 87
1626: PUSH
1627: EMPTY
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: ST_TO_ADDR
1682: GO 1915
1684: LD_INT 3
1686: DOUBLE
1687: EQUAL
1688: IFTRUE 1692
1690: GO 1914
1692: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1693: LD_ADDR_VAR 0 4
1697: PUSH
1698: LD_INT 46
1700: PUSH
1701: LD_INT 47
1703: PUSH
1704: LD_INT 1
1706: PUSH
1707: LD_INT 2
1709: PUSH
1710: LD_INT 82
1712: PUSH
1713: LD_INT 83
1715: PUSH
1716: LD_INT 84
1718: PUSH
1719: LD_INT 85
1721: PUSH
1722: LD_INT 86
1724: PUSH
1725: LD_INT 11
1727: PUSH
1728: LD_INT 9
1730: PUSH
1731: LD_INT 20
1733: PUSH
1734: LD_INT 19
1736: PUSH
1737: LD_INT 21
1739: PUSH
1740: LD_INT 24
1742: PUSH
1743: LD_INT 22
1745: PUSH
1746: LD_INT 25
1748: PUSH
1749: LD_INT 28
1751: PUSH
1752: LD_INT 29
1754: PUSH
1755: LD_INT 30
1757: PUSH
1758: LD_INT 31
1760: PUSH
1761: LD_INT 37
1763: PUSH
1764: LD_INT 38
1766: PUSH
1767: LD_INT 32
1769: PUSH
1770: LD_INT 27
1772: PUSH
1773: LD_INT 33
1775: PUSH
1776: LD_INT 69
1778: PUSH
1779: LD_INT 39
1781: PUSH
1782: LD_INT 34
1784: PUSH
1785: LD_INT 40
1787: PUSH
1788: LD_INT 71
1790: PUSH
1791: LD_INT 23
1793: PUSH
1794: LD_INT 44
1796: PUSH
1797: LD_INT 48
1799: PUSH
1800: LD_INT 49
1802: PUSH
1803: LD_INT 50
1805: PUSH
1806: LD_INT 51
1808: PUSH
1809: LD_INT 52
1811: PUSH
1812: LD_INT 53
1814: PUSH
1815: LD_INT 54
1817: PUSH
1818: LD_INT 55
1820: PUSH
1821: LD_INT 56
1823: PUSH
1824: LD_INT 57
1826: PUSH
1827: LD_INT 58
1829: PUSH
1830: LD_INT 59
1832: PUSH
1833: LD_INT 63
1835: PUSH
1836: LD_INT 64
1838: PUSH
1839: LD_INT 65
1841: PUSH
1842: LD_INT 82
1844: PUSH
1845: LD_INT 83
1847: PUSH
1848: LD_INT 84
1850: PUSH
1851: LD_INT 85
1853: PUSH
1854: LD_INT 86
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: ST_TO_ADDR
1912: GO 1915
1914: POP
// if state > - 1 and state < 3 then
1915: LD_VAR 0 3
1919: PUSH
1920: LD_INT 1
1922: NEG
1923: GREATER
1924: PUSH
1925: LD_VAR 0 3
1929: PUSH
1930: LD_INT 3
1932: LESS
1933: AND
1934: IFFALSE 1991
// for i in result do
1936: LD_ADDR_VAR 0 5
1940: PUSH
1941: LD_VAR 0 4
1945: PUSH
1946: FOR_IN
1947: IFFALSE 1989
// if GetTech ( i , side ) <> state then
1949: LD_VAR 0 5
1953: PPUSH
1954: LD_VAR 0 1
1958: PPUSH
1959: CALL_OW 321
1963: PUSH
1964: LD_VAR 0 3
1968: NONEQUAL
1969: IFFALSE 1987
// result := result diff i ;
1971: LD_ADDR_VAR 0 4
1975: PUSH
1976: LD_VAR 0 4
1980: PUSH
1981: LD_VAR 0 5
1985: DIFF
1986: ST_TO_ADDR
1987: GO 1946
1989: POP
1990: POP
// end ; end_of_file
1991: LD_VAR 0 4
1995: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1996: LD_INT 0
1998: PPUSH
1999: PPUSH
2000: PPUSH
2001: PPUSH
// uc_side := 5 ;
2002: LD_ADDR_OWVAR 20
2006: PUSH
2007: LD_INT 5
2009: ST_TO_ADDR
// uc_nation := 2 ;
2010: LD_ADDR_OWVAR 21
2014: PUSH
2015: LD_INT 2
2017: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
2018: LD_INT 5
2020: PPUSH
2021: CALL_OW 274
2025: PPUSH
2026: LD_INT 1
2028: PPUSH
2029: LD_INT 45
2031: PPUSH
2032: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
2036: LD_ADDR_EXP 36
2040: PUSH
2041: LD_STRING Farmer
2043: PPUSH
2044: LD_INT 0
2046: PPUSH
2047: LD_STRING 
2049: PPUSH
2050: CALL 313 0 3
2054: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2055: LD_ADDR_EXP 37
2059: PUSH
2060: LD_STRING Omar
2062: PPUSH
2063: LD_INT 0
2065: PPUSH
2066: LD_STRING 
2068: PPUSH
2069: CALL 313 0 3
2073: ST_TO_ADDR
// omarSquad := [ ] ;
2074: LD_ADDR_EXP 40
2078: PUSH
2079: EMPTY
2080: ST_TO_ADDR
// heikeSquad := [ ] ;
2081: LD_ADDR_EXP 41
2085: PUSH
2086: EMPTY
2087: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2088: LD_ADDR_EXP 42
2092: PUSH
2093: EMPTY
2094: ST_TO_ADDR
// omarCargo := [ ] ;
2095: LD_ADDR_EXP 43
2099: PUSH
2100: EMPTY
2101: ST_TO_ADDR
// for i := 1 to 5 do
2102: LD_ADDR_VAR 0 2
2106: PUSH
2107: DOUBLE
2108: LD_INT 1
2110: DEC
2111: ST_TO_ADDR
2112: LD_INT 5
2114: PUSH
2115: FOR_TO
2116: IFFALSE 2274
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2118: LD_INT 0
2120: PPUSH
2121: LD_INT 1
2123: PUSH
2124: LD_INT 1
2126: PUSH
2127: LD_INT 2
2129: PUSH
2130: LD_INT 1
2132: PUSH
2133: LD_INT 1
2135: PUSH
2136: EMPTY
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: PUSH
2143: LD_VAR 0 2
2147: ARRAY
2148: PPUSH
2149: LD_INT 3
2151: PPUSH
2152: CALL_OW 380
// un := CreateHuman ;
2156: LD_ADDR_VAR 0 3
2160: PUSH
2161: CALL_OW 44
2165: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2166: LD_ADDR_EXP 40
2170: PUSH
2171: LD_EXP 40
2175: PUSH
2176: LD_VAR 0 3
2180: UNION
2181: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2182: LD_VAR 0 3
2186: PPUSH
2187: LD_INT 87
2189: PUSH
2190: LD_INT 30
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 91
2199: PUSH
2200: LD_INT 32
2202: PUSH
2203: EMPTY
2204: LIST
2205: LIST
2206: PUSH
2207: LD_INT 82
2209: PUSH
2210: LD_INT 15
2212: PUSH
2213: EMPTY
2214: LIST
2215: LIST
2216: PUSH
2217: LD_INT 79
2219: PUSH
2220: LD_INT 14
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: PUSH
2227: LD_INT 82
2229: PUSH
2230: LD_INT 13
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: LIST
2241: LIST
2242: LIST
2243: PUSH
2244: LD_VAR 0 2
2248: ARRAY
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL 944 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2257: LD_VAR 0 3
2261: PPUSH
2262: LD_INT 93
2264: PPUSH
2265: LD_INT 21
2267: PPUSH
2268: CALL_OW 118
// end ;
2272: GO 2115
2274: POP
2275: POP
// uc_side := 2 ;
2276: LD_ADDR_OWVAR 20
2280: PUSH
2281: LD_INT 2
2283: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2284: LD_ADDR_EXP 28
2288: PUSH
2289: LD_STRING Heike
2291: PPUSH
2292: LD_EXP 1
2296: NOT
2297: PPUSH
2298: LD_EXP 2
2302: PPUSH
2303: CALL 313 0 3
2307: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2308: LD_ADDR_EXP 32
2312: PUSH
2313: LD_STRING Aviradze
2315: PPUSH
2316: LD_EXP 1
2320: NOT
2321: PPUSH
2322: LD_EXP 2
2326: PPUSH
2327: CALL 313 0 3
2331: ST_TO_ADDR
// tmp := [ ] ;
2332: LD_ADDR_VAR 0 4
2336: PUSH
2337: EMPTY
2338: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2339: LD_ADDR_EXP 29
2343: PUSH
2344: LD_STRING Givi
2346: PPUSH
2347: LD_EXP 1
2351: NOT
2352: PPUSH
2353: LD_EXP 2
2357: PPUSH
2358: CALL 313 0 3
2362: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2363: LD_ADDR_EXP 30
2367: PUSH
2368: LD_STRING Mike
2370: PPUSH
2371: LD_EXP 1
2375: NOT
2376: PPUSH
2377: LD_EXP 2
2381: PPUSH
2382: CALL 313 0 3
2386: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2387: LD_ADDR_EXP 31
2391: PUSH
2392: LD_STRING Kamil
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_EXP 2
2405: PPUSH
2406: CALL 313 0 3
2410: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2411: LD_ADDR_EXP 33
2415: PUSH
2416: LD_STRING Kaia
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_EXP 2
2429: PPUSH
2430: CALL 313 0 3
2434: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2435: LD_ADDR_EXP 34
2439: PUSH
2440: LD_STRING Sophia
2442: PPUSH
2443: LD_EXP 1
2447: NOT
2448: PPUSH
2449: LD_EXP 2
2453: PPUSH
2454: CALL 313 0 3
2458: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2459: LD_ADDR_EXP 35
2463: PUSH
2464: LD_STRING Markov
2466: PPUSH
2467: LD_EXP 1
2471: NOT
2472: PPUSH
2473: LD_EXP 2
2477: PPUSH
2478: CALL 313 0 3
2482: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2483: LD_ADDR_EXP 42
2487: PUSH
2488: LD_STRING 02_others
2490: PPUSH
2491: CALL_OW 31
2495: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2496: LD_ADDR_VAR 0 4
2500: PUSH
2501: LD_EXP 30
2505: PUSH
2506: LD_EXP 31
2510: PUSH
2511: LD_EXP 33
2515: PUSH
2516: LD_EXP 34
2520: PUSH
2521: LD_EXP 35
2525: PUSH
2526: LD_EXP 29
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: LIST
2535: LIST
2536: LIST
2537: LIST
2538: PUSH
2539: LD_EXP 42
2543: ADD
2544: PUSH
2545: LD_INT 0
2547: DIFF
2548: ST_TO_ADDR
// heikeSquad := tmp ;
2549: LD_ADDR_EXP 41
2553: PUSH
2554: LD_VAR 0 4
2558: ST_TO_ADDR
// if UnitFilter ( heikeSquad , [ f_class , 1 ] ) < 3 then
2559: LD_EXP 41
2563: PPUSH
2564: LD_INT 25
2566: PUSH
2567: LD_INT 1
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PPUSH
2574: CALL_OW 72
2578: PUSH
2579: LD_INT 3
2581: LESS
2582: IFFALSE 2632
// begin SetClass ( Kaia , 1 ) ;
2584: LD_EXP 33
2588: PPUSH
2589: LD_INT 1
2591: PPUSH
2592: CALL_OW 336
// SetClass ( Mike , 1 ) ;
2596: LD_EXP 30
2600: PPUSH
2601: LD_INT 1
2603: PPUSH
2604: CALL_OW 336
// SetClass ( Givi , 1 ) ;
2608: LD_EXP 29
2612: PPUSH
2613: LD_INT 1
2615: PPUSH
2616: CALL_OW 336
// SetClass ( Heike , 1 ) ;
2620: LD_EXP 28
2624: PPUSH
2625: LD_INT 1
2627: PPUSH
2628: CALL_OW 336
// end ; tmp := tmp union CreateCharacterSet ( 02_ape ) ;
2632: LD_ADDR_VAR 0 4
2636: PUSH
2637: LD_VAR 0 4
2641: PUSH
2642: LD_STRING 02_ape
2644: PPUSH
2645: CALL_OW 31
2649: UNION
2650: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2651: LD_EXP 28
2655: PPUSH
2656: LD_INT 92
2658: PPUSH
2659: LD_INT 17
2661: PPUSH
2662: LD_INT 0
2664: PPUSH
2665: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2669: LD_EXP 36
2673: PPUSH
2674: LD_INT 95
2676: PPUSH
2677: LD_INT 19
2679: PPUSH
2680: LD_INT 0
2682: PPUSH
2683: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2687: LD_EXP 37
2691: PPUSH
2692: LD_INT 89
2694: PPUSH
2695: LD_INT 25
2697: PPUSH
2698: LD_INT 0
2700: PPUSH
2701: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2705: LD_EXP 32
2709: PPUSH
2710: LD_INT 92
2712: PPUSH
2713: LD_INT 27
2715: PPUSH
2716: LD_INT 0
2718: PPUSH
2719: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2723: LD_EXP 37
2727: PPUSH
2728: LD_EXP 32
2732: PPUSH
2733: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2737: LD_EXP 32
2741: PPUSH
2742: LD_EXP 37
2746: PPUSH
2747: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2751: LD_EXP 28
2755: PUSH
2756: LD_EXP 36
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PPUSH
2765: LD_EXP 37
2769: PPUSH
2770: CALL_OW 119
// if tmp then
2774: LD_VAR 0 4
2778: IFFALSE 2832
// for i in tmp do
2780: LD_ADDR_VAR 0 2
2784: PUSH
2785: LD_VAR 0 4
2789: PUSH
2790: FOR_IN
2791: IFFALSE 2830
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2793: LD_VAR 0 2
2797: PPUSH
2798: LD_INT 94
2800: PPUSH
2801: LD_INT 14
2803: PPUSH
2804: LD_INT 4
2806: PPUSH
2807: LD_INT 0
2809: PPUSH
2810: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2814: LD_VAR 0 2
2818: PPUSH
2819: LD_EXP 28
2823: PPUSH
2824: CALL_OW 119
// end ;
2828: GO 2790
2830: POP
2831: POP
// farmerSquad := [ ] ;
2832: LD_ADDR_EXP 39
2836: PUSH
2837: EMPTY
2838: ST_TO_ADDR
// uc_side := 5 ;
2839: LD_ADDR_OWVAR 20
2843: PUSH
2844: LD_INT 5
2846: ST_TO_ADDR
// uc_nation := 2 ;
2847: LD_ADDR_OWVAR 21
2851: PUSH
2852: LD_INT 2
2854: ST_TO_ADDR
// for i := 1 to 4 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 4
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2947
// begin PrepareHuman ( false , 1 , 2 ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 1
2876: PPUSH
2877: LD_INT 2
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 3
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2894: LD_VAR 0 3
2898: PPUSH
2899: LD_INT 102
2901: PPUSH
2902: LD_INT 27
2904: PPUSH
2905: LD_INT 4
2907: PPUSH
2908: LD_INT 0
2910: PPUSH
2911: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2915: LD_ADDR_EXP 39
2919: PUSH
2920: LD_EXP 39
2924: PUSH
2925: LD_VAR 0 3
2929: UNION
2930: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2931: LD_VAR 0 3
2935: PPUSH
2936: LD_EXP 37
2940: PPUSH
2941: CALL_OW 119
// end ;
2945: GO 2868
2947: POP
2948: POP
// for i := 1 to 2 do
2949: LD_ADDR_VAR 0 2
2953: PUSH
2954: DOUBLE
2955: LD_INT 1
2957: DEC
2958: ST_TO_ADDR
2959: LD_INT 2
2961: PUSH
2962: FOR_TO
2963: IFFALSE 3041
// begin PrepareHuman ( false , 2 , 2 ) ;
2965: LD_INT 0
2967: PPUSH
2968: LD_INT 2
2970: PPUSH
2971: LD_INT 2
2973: PPUSH
2974: CALL_OW 380
// un := CreateHuman ;
2978: LD_ADDR_VAR 0 3
2982: PUSH
2983: CALL_OW 44
2987: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2988: LD_VAR 0 3
2992: PPUSH
2993: LD_INT 108
2995: PPUSH
2996: LD_INT 62
2998: PPUSH
2999: LD_INT 2
3001: PPUSH
3002: LD_INT 0
3004: PPUSH
3005: CALL_OW 50
// farmerSquad := farmerSquad union un ;
3009: LD_ADDR_EXP 39
3013: PUSH
3014: LD_EXP 39
3018: PUSH
3019: LD_VAR 0 3
3023: UNION
3024: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
3025: LD_VAR 0 3
3029: PPUSH
3030: LD_EXP 37
3034: PPUSH
3035: CALL_OW 119
// end ;
3039: GO 2962
3041: POP
3042: POP
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
3043: LD_INT 109
3045: PPUSH
3046: LD_INT 63
3048: PPUSH
3049: LD_INT 2
3051: PPUSH
3052: LD_INT 15
3054: NEG
3055: PPUSH
3056: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
3060: LD_INT 109
3062: PPUSH
3063: LD_INT 63
3065: PPUSH
3066: LD_INT 2
3068: PPUSH
3069: CALL_OW 331
// end ;
3073: LD_VAR 0 1
3077: RET
// export function PrepareIbrahim ( x , y ) ; begin
3078: LD_INT 0
3080: PPUSH
// uc_side := 6 ;
3081: LD_ADDR_OWVAR 20
3085: PUSH
3086: LD_INT 6
3088: ST_TO_ADDR
// uc_nation := 3 ;
3089: LD_ADDR_OWVAR 21
3093: PUSH
3094: LD_INT 3
3096: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3097: LD_ADDR_EXP 38
3101: PUSH
3102: LD_STRING IbrahimRu
3104: PPUSH
3105: LD_INT 0
3107: PPUSH
3108: LD_STRING 
3110: PPUSH
3111: CALL 313 0 3
3115: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3116: LD_EXP 38
3120: PPUSH
3121: LD_VAR 0 1
3125: PPUSH
3126: LD_VAR 0 2
3130: PPUSH
3131: LD_INT 8
3133: PPUSH
3134: LD_INT 1
3136: PPUSH
3137: CALL_OW 50
// end ;
3141: LD_VAR 0 3
3145: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3146: LD_EXP 37
3150: PUSH
3151: LD_EXP 40
3155: ADD
3156: PPUSH
3157: LD_INT 95
3159: PUSH
3160: LD_INT 3
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL_OW 72
3171: IFFALSE 3227
3173: GO 3175
3175: DISABLE
3176: LD_INT 0
3178: PPUSH
// begin enable ;
3179: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3180: LD_ADDR_VAR 0 1
3184: PUSH
3185: LD_EXP 37
3189: PUSH
3190: LD_EXP 40
3194: ADD
3195: PPUSH
3196: LD_INT 95
3198: PUSH
3199: LD_INT 3
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PPUSH
3206: CALL_OW 72
3210: PUSH
3211: FOR_IN
3212: IFFALSE 3225
// RemoveUnit ( i ) ;
3214: LD_VAR 0 1
3218: PPUSH
3219: CALL_OW 64
3223: GO 3211
3225: POP
3226: POP
// end ;
3227: PPOPN 1
3229: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3230: LD_EXP 3
3234: PUSH
3235: LD_EXP 36
3239: PPUSH
3240: LD_INT 4
3242: PPUSH
3243: CALL_OW 308
3247: AND
3248: IFFALSE 4031
3250: GO 3252
3252: DISABLE
3253: LD_INT 0
3255: PPUSH
3256: PPUSH
3257: PPUSH
3258: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3259: LD_EXP 36
3263: PPUSH
3264: LD_INT 110
3266: PPUSH
3267: LD_INT 60
3269: PPUSH
3270: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3274: LD_EXP 36
3278: PPUSH
3279: LD_INT 110
3281: PPUSH
3282: LD_INT 61
3284: PPUSH
3285: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3289: LD_ADDR_VAR 0 2
3293: PUSH
3294: LD_EXP 39
3298: PPUSH
3299: LD_INT 25
3301: PUSH
3302: LD_INT 1
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PPUSH
3309: CALL_OW 72
3313: ST_TO_ADDR
// if tmp then
3314: LD_VAR 0 2
3318: IFFALSE 3412
// begin for i := 1 to 2 do
3320: LD_ADDR_VAR 0 1
3324: PUSH
3325: DOUBLE
3326: LD_INT 1
3328: DEC
3329: ST_TO_ADDR
3330: LD_INT 2
3332: PUSH
3333: FOR_TO
3334: IFFALSE 3410
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3336: LD_VAR 0 2
3340: PUSH
3341: LD_VAR 0 1
3345: ARRAY
3346: PPUSH
3347: LD_INT 5
3349: PPUSH
3350: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3354: LD_VAR 0 2
3358: PUSH
3359: LD_VAR 0 1
3363: ARRAY
3364: PPUSH
3365: LD_INT 2
3367: PPUSH
3368: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3372: LD_VAR 0 2
3376: PUSH
3377: LD_VAR 0 1
3381: ARRAY
3382: PPUSH
3383: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3387: LD_VAR 0 2
3391: PUSH
3392: LD_VAR 0 1
3396: ARRAY
3397: PPUSH
3398: LD_INT 107
3400: PPUSH
3401: LD_INT 66
3403: PPUSH
3404: CALL_OW 171
// end ;
3408: GO 3333
3410: POP
3411: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3412: LD_ADDR_VAR 0 2
3416: PUSH
3417: LD_EXP 39
3421: PPUSH
3422: LD_INT 25
3424: PUSH
3425: LD_INT 2
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PPUSH
3432: CALL_OW 72
3436: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3437: LD_INT 35
3439: PPUSH
3440: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3444: LD_ADDR_VAR 0 2
3448: PUSH
3449: LD_EXP 39
3453: PPUSH
3454: LD_INT 25
3456: PUSH
3457: LD_INT 2
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: PPUSH
3464: CALL_OW 72
3468: ST_TO_ADDR
// until tmp ;
3469: LD_VAR 0 2
3473: IFFALSE 3437
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3475: LD_VAR 0 2
3479: PPUSH
3480: LD_INT 31
3482: PPUSH
3483: LD_INT 102
3485: PPUSH
3486: LD_INT 69
3488: PPUSH
3489: LD_INT 2
3491: PPUSH
3492: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3496: LD_INT 35
3498: PPUSH
3499: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3503: LD_EXP 39
3507: PPUSH
3508: LD_INT 3
3510: PUSH
3511: LD_INT 60
3513: PUSH
3514: EMPTY
3515: LIST
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: PUSH
3521: LD_INT 25
3523: PUSH
3524: LD_INT 2
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: PPUSH
3535: CALL_OW 72
3539: IFFALSE 3496
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: LD_EXP 39
3550: PPUSH
3551: LD_INT 25
3553: PUSH
3554: LD_INT 2
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: PPUSH
3561: CALL_OW 72
3565: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3566: LD_VAR 0 2
3570: PPUSH
3571: LD_INT 4
3573: PPUSH
3574: LD_INT 116
3576: PPUSH
3577: LD_INT 70
3579: PPUSH
3580: LD_INT 5
3582: PPUSH
3583: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3587: LD_VAR 0 2
3591: PPUSH
3592: LD_INT 31
3594: PPUSH
3595: LD_INT 108
3597: PPUSH
3598: LD_INT 50
3600: PPUSH
3601: LD_INT 2
3603: PPUSH
3604: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3608: LD_INT 35
3610: PPUSH
3611: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3615: LD_INT 22
3617: PUSH
3618: LD_INT 5
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: PUSH
3625: LD_INT 30
3627: PUSH
3628: LD_INT 4
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 3
3637: PUSH
3638: LD_INT 57
3640: PUSH
3641: EMPTY
3642: LIST
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: LIST
3652: PPUSH
3653: CALL_OW 69
3657: IFFALSE 3608
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3659: LD_ADDR_VAR 0 3
3663: PUSH
3664: LD_INT 22
3666: PUSH
3667: LD_INT 5
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: PUSH
3674: LD_INT 30
3676: PUSH
3677: LD_INT 4
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: PUSH
3684: LD_INT 3
3686: PUSH
3687: LD_INT 57
3689: PUSH
3690: EMPTY
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: LIST
3701: PPUSH
3702: CALL_OW 69
3706: PUSH
3707: LD_INT 1
3709: ARRAY
3710: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3711: LD_ADDR_VAR 0 2
3715: PUSH
3716: LD_EXP 39
3720: PPUSH
3721: LD_INT 25
3723: PUSH
3724: LD_INT 1
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PPUSH
3731: CALL_OW 72
3735: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3736: LD_VAR 0 2
3740: PPUSH
3741: LD_VAR 0 3
3745: PPUSH
3746: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3750: LD_INT 35
3752: PPUSH
3753: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3757: LD_INT 22
3759: PUSH
3760: LD_INT 5
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: LD_INT 30
3769: PUSH
3770: LD_INT 31
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 3
3779: PUSH
3780: LD_INT 57
3782: PUSH
3783: EMPTY
3784: LIST
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: LIST
3794: PPUSH
3795: CALL_OW 69
3799: PUSH
3800: LD_INT 2
3802: GREATEREQUAL
3803: IFFALSE 3750
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3805: LD_ADDR_VAR 0 2
3809: PUSH
3810: LD_EXP 39
3814: PPUSH
3815: LD_INT 25
3817: PUSH
3818: LD_INT 2
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PPUSH
3825: CALL_OW 72
3829: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3830: LD_VAR 0 2
3834: PUSH
3835: LD_INT 1
3837: ARRAY
3838: PPUSH
3839: LD_INT 5
3841: PPUSH
3842: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3846: LD_VAR 0 2
3850: PUSH
3851: LD_INT 2
3853: ARRAY
3854: PUSH
3855: LD_VAR 0 2
3859: PUSH
3860: LD_INT 3
3862: ARRAY
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: LD_VAR 0 3
3872: PPUSH
3873: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3877: LD_VAR 0 2
3881: PUSH
3882: LD_INT 2
3884: ARRAY
3885: PUSH
3886: LD_VAR 0 2
3890: PUSH
3891: LD_INT 3
3893: ARRAY
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PPUSH
3899: LD_INT 1
3901: PPUSH
3902: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3906: LD_VAR 0 2
3910: PUSH
3911: LD_INT 2
3913: ARRAY
3914: PUSH
3915: LD_VAR 0 2
3919: PUSH
3920: LD_INT 3
3922: ARRAY
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PPUSH
3928: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3932: LD_ADDR_VAR 0 4
3936: PUSH
3937: LD_INT 22
3939: PUSH
3940: LD_INT 5
3942: PUSH
3943: EMPTY
3944: LIST
3945: LIST
3946: PUSH
3947: LD_INT 30
3949: PUSH
3950: LD_INT 31
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: PUSH
3957: EMPTY
3958: LIST
3959: LIST
3960: PPUSH
3961: CALL_OW 69
3965: ST_TO_ADDR
// for i := 1 to 2 do
3966: LD_ADDR_VAR 0 1
3970: PUSH
3971: DOUBLE
3972: LD_INT 1
3974: DEC
3975: ST_TO_ADDR
3976: LD_INT 2
3978: PUSH
3979: FOR_TO
3980: IFFALSE 4014
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3982: LD_VAR 0 2
3986: PUSH
3987: LD_VAR 0 1
3991: PUSH
3992: LD_INT 1
3994: PLUS
3995: ARRAY
3996: PPUSH
3997: LD_VAR 0 4
4001: PUSH
4002: LD_VAR 0 1
4006: ARRAY
4007: PPUSH
4008: CALL_OW 180
4012: GO 3979
4014: POP
4015: POP
// wait ( 1 1$00 ) ;
4016: LD_INT 2100
4018: PPUSH
4019: CALL_OW 67
// farmerBaseReady := true ;
4023: LD_ADDR_EXP 4
4027: PUSH
4028: LD_INT 1
4030: ST_TO_ADDR
// end ;
4031: PPOPN 4
4033: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
4034: LD_EXP 4
4038: PUSH
4039: LD_EXP 11
4043: NOT
4044: AND
4045: IFFALSE 4567
4047: GO 4049
4049: DISABLE
4050: LD_INT 0
4052: PPUSH
4053: PPUSH
4054: PPUSH
4055: PPUSH
4056: PPUSH
// begin enable ;
4057: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
4058: LD_ADDR_VAR 0 3
4062: PUSH
4063: LD_EXP 39
4067: PPUSH
4068: LD_INT 25
4070: PUSH
4071: LD_INT 1
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: PPUSH
4078: CALL_OW 72
4082: PUSH
4083: LD_EXP 36
4087: ADD
4088: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4089: LD_ADDR_VAR 0 2
4093: PUSH
4094: LD_EXP 39
4098: PPUSH
4099: LD_INT 25
4101: PUSH
4102: LD_INT 2
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PPUSH
4109: CALL_OW 72
4113: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4114: LD_ADDR_VAR 0 5
4118: PUSH
4119: LD_INT 22
4121: PUSH
4122: LD_INT 5
4124: PUSH
4125: EMPTY
4126: LIST
4127: LIST
4128: PUSH
4129: LD_INT 21
4131: PUSH
4132: LD_INT 3
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PUSH
4139: LD_INT 3
4141: PUSH
4142: LD_INT 24
4144: PUSH
4145: LD_INT 1000
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: PUSH
4152: EMPTY
4153: LIST
4154: LIST
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: LIST
4160: PPUSH
4161: CALL_OW 69
4165: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4166: LD_ADDR_VAR 0 4
4170: PUSH
4171: LD_INT 22
4173: PUSH
4174: LD_INT 5
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: LD_INT 30
4183: PUSH
4184: LD_INT 4
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: PPUSH
4195: CALL_OW 69
4199: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4200: LD_VAR 0 4
4204: PUSH
4205: LD_INT 1
4207: ARRAY
4208: PPUSH
4209: CALL_OW 302
4213: IFFALSE 4277
// for i in sol do
4215: LD_ADDR_VAR 0 1
4219: PUSH
4220: LD_VAR 0 3
4224: PUSH
4225: FOR_IN
4226: IFFALSE 4275
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4228: LD_VAR 0 1
4232: PPUSH
4233: CALL_OW 256
4237: PUSH
4238: LD_INT 999
4240: LESS
4241: PUSH
4242: LD_VAR 0 1
4246: PPUSH
4247: CALL_OW 310
4251: NOT
4252: AND
4253: IFFALSE 4273
// ComEnterUnit ( i , arm [ 1 ] ) ;
4255: LD_VAR 0 1
4259: PPUSH
4260: LD_VAR 0 4
4264: PUSH
4265: LD_INT 1
4267: ARRAY
4268: PPUSH
4269: CALL_OW 120
4273: GO 4225
4275: POP
4276: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4277: LD_VAR 0 2
4281: NOT
4282: PUSH
4283: LD_INT 22
4285: PUSH
4286: LD_INT 1
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 21
4295: PUSH
4296: LD_INT 1
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PPUSH
4307: CALL_OW 69
4311: NOT
4312: AND
4313: IFFALSE 4405
// begin uc_side := 5 ;
4315: LD_ADDR_OWVAR 20
4319: PUSH
4320: LD_INT 5
4322: ST_TO_ADDR
// uc_nation := 2 ;
4323: LD_ADDR_OWVAR 21
4327: PUSH
4328: LD_INT 2
4330: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4331: LD_INT 0
4333: PPUSH
4334: LD_INT 2
4336: PPUSH
4337: LD_INT 2
4339: PPUSH
4340: CALL_OW 380
// eng := CreateHuman ;
4344: LD_ADDR_VAR 0 2
4348: PUSH
4349: CALL_OW 44
4353: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4354: LD_VAR 0 2
4358: PPUSH
4359: LD_INT 102
4361: PPUSH
4362: LD_INT 8
4364: PPUSH
4365: LD_INT 0
4367: PPUSH
4368: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4372: LD_VAR 0 2
4376: PPUSH
4377: LD_INT 110
4379: PPUSH
4380: LD_INT 60
4382: PPUSH
4383: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4387: LD_ADDR_EXP 39
4391: PUSH
4392: LD_EXP 39
4396: PUSH
4397: LD_VAR 0 2
4401: UNION
4402: ST_TO_ADDR
// end else
4403: GO 4567
// begin for i in eng do
4405: LD_ADDR_VAR 0 1
4409: PUSH
4410: LD_VAR 0 2
4414: PUSH
4415: FOR_IN
4416: IFFALSE 4565
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4418: LD_INT 10
4420: PPUSH
4421: LD_INT 1
4423: PPUSH
4424: CALL_OW 287
4428: IFFALSE 4479
// begin if IsInUnit ( i ) then
4430: LD_VAR 0 1
4434: PPUSH
4435: CALL_OW 310
4439: IFFALSE 4450
// ComExitBuilding ( i ) ;
4441: LD_VAR 0 1
4445: PPUSH
4446: CALL_OW 122
// if not IsInArea ( i , collectFarmerArea ) then
4450: LD_VAR 0 1
4454: PPUSH
4455: LD_INT 10
4457: PPUSH
4458: CALL_OW 308
4462: NOT
4463: IFFALSE 4477
// AddComMoveToArea ( i , collectFarmerArea ) ;
4465: LD_VAR 0 1
4469: PPUSH
4470: LD_INT 10
4472: PPUSH
4473: CALL_OW 173
// end else
4477: GO 4563
// begin if damagedBuilding then
4479: LD_VAR 0 5
4483: IFFALSE 4527
// begin if IsInUnit ( i ) then
4485: LD_VAR 0 1
4489: PPUSH
4490: CALL_OW 310
4494: IFFALSE 4507
// ComExitBuilding ( i ) else
4496: LD_VAR 0 1
4500: PPUSH
4501: CALL_OW 122
4505: GO 4525
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4507: LD_VAR 0 1
4511: PPUSH
4512: LD_VAR 0 5
4516: PUSH
4517: LD_INT 1
4519: ARRAY
4520: PPUSH
4521: CALL_OW 130
// end else
4525: GO 4563
// if not IsInUnit ( i ) and not HasTask ( i ) then
4527: LD_VAR 0 1
4531: PPUSH
4532: CALL_OW 310
4536: NOT
4537: PUSH
4538: LD_VAR 0 1
4542: PPUSH
4543: CALL_OW 314
4547: NOT
4548: AND
4549: IFFALSE 4563
// ComEnterUnit ( i , arDepot ) ;
4551: LD_VAR 0 1
4555: PPUSH
4556: LD_INT 5
4558: PPUSH
4559: CALL_OW 120
// end ; end ;
4563: GO 4415
4565: POP
4566: POP
// end ; end ;
4567: PPOPN 5
4569: END
// export function StartCargoEvacuation ; begin
4570: LD_INT 0
4572: PPUSH
// while omarCargoCounter > 0 do
4573: LD_EXP 21
4577: PUSH
4578: LD_INT 0
4580: GREATER
4581: IFFALSE 4898
// begin wait ( 0 0$40 ) ;
4583: LD_INT 1400
4585: PPUSH
4586: CALL_OW 67
// omarCargo := PrepareCargo ;
4590: LD_ADDR_EXP 43
4594: PUSH
4595: CALL 4903 0 0
4599: ST_TO_ADDR
// SetTag ( omarCargo , 0 ) ;
4600: LD_EXP 43
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 109
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4612: LD_EXP 43
4616: PPUSH
4617: LD_INT 107
4619: PPUSH
4620: LD_INT 59
4622: PPUSH
4623: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4627: LD_INT 35
4629: PPUSH
4630: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4634: LD_EXP 43
4638: PPUSH
4639: LD_INT 107
4641: PPUSH
4642: LD_INT 59
4644: PPUSH
4645: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4649: LD_EXP 43
4653: PPUSH
4654: CALL_OW 302
4658: NOT
4659: PUSH
4660: LD_EXP 43
4664: PPUSH
4665: CALL_OW 301
4669: OR
4670: IFFALSE 4674
// continue ;
4672: GO 4627
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4674: LD_EXP 43
4678: PPUSH
4679: LD_INT 107
4681: PPUSH
4682: LD_INT 59
4684: PPUSH
4685: CALL_OW 307
4689: PUSH
4690: LD_EXP 43
4694: PPUSH
4695: LD_INT 5
4697: PPUSH
4698: CALL_OW 296
4702: PUSH
4703: LD_INT 6
4705: LESS
4706: OR
4707: IFFALSE 4627
// SetTag ( omarCargo , 1 ) ;
4709: LD_EXP 43
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 109
// wait ( 0 0$05 ) ;
4721: LD_INT 175
4723: PPUSH
4724: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4728: LD_EXP 43
4732: PPUSH
4733: LD_INT 5
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4743: LD_EXP 43
4747: PPUSH
4748: LD_INT 103
4750: PPUSH
4751: LD_INT 9
4753: PPUSH
4754: CALL_OW 171
// wait ( 0 0$1 ) ;
4758: LD_INT 35
4760: PPUSH
4761: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
4765: LD_EXP 43
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 100
4775: PPUSH
4776: CALL_OW 290
// repeat wait ( 0 0$1 ) ;
4780: LD_INT 35
4782: PPUSH
4783: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4787: LD_EXP 43
4791: PPUSH
4792: LD_INT 103
4794: PPUSH
4795: LD_INT 9
4797: PPUSH
4798: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4802: LD_EXP 43
4806: PPUSH
4807: CALL_OW 302
4811: NOT
4812: PUSH
4813: LD_EXP 43
4817: PPUSH
4818: CALL_OW 301
4822: OR
4823: IFFALSE 4827
// continue ;
4825: GO 4780
// until ( IsAt ( omarCargo , 103 , 9 ) or IsInArea ( omarCargo , northRoad ) ) and GetTag ( omarCargo ) > 0 ;
4827: LD_EXP 43
4831: PPUSH
4832: LD_INT 103
4834: PPUSH
4835: LD_INT 9
4837: PPUSH
4838: CALL_OW 307
4842: PUSH
4843: LD_EXP 43
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 308
4855: OR
4856: PUSH
4857: LD_EXP 43
4861: PPUSH
4862: CALL_OW 110
4866: PUSH
4867: LD_INT 0
4869: GREATER
4870: AND
4871: IFFALSE 4780
// RemoveUnit ( omarCargo ) ;
4873: LD_EXP 43
4877: PPUSH
4878: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4882: LD_ADDR_EXP 21
4886: PUSH
4887: LD_EXP 21
4891: PUSH
4892: LD_INT 1
4894: MINUS
4895: ST_TO_ADDR
// end ;
4896: GO 4573
// end ;
4898: LD_VAR 0 1
4902: RET
// export function PrepareCargo ; var un , veh ; begin
4903: LD_INT 0
4905: PPUSH
4906: PPUSH
4907: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4908: LD_ADDR_VAR 0 3
4912: PUSH
4913: LD_INT 5
4915: PPUSH
4916: LD_INT 2
4918: PPUSH
4919: LD_INT 13
4921: PPUSH
4922: LD_INT 1
4924: PPUSH
4925: LD_INT 1
4927: PPUSH
4928: LD_INT 32
4930: PPUSH
4931: LD_INT 80
4933: PPUSH
4934: CALL 376 0 7
4938: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4939: LD_VAR 0 3
4943: PPUSH
4944: LD_INT 4
4946: PPUSH
4947: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4951: LD_VAR 0 3
4955: PPUSH
4956: LD_INT 101
4958: PPUSH
4959: LD_INT 8
4961: PPUSH
4962: LD_INT 0
4964: PPUSH
4965: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4969: LD_INT 0
4971: PPUSH
4972: LD_INT 3
4974: PPUSH
4975: LD_INT 2
4977: PPUSH
4978: CALL_OW 380
// un := CreateHuman ;
4982: LD_ADDR_VAR 0 2
4986: PUSH
4987: CALL_OW 44
4991: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4992: LD_VAR 0 2
4996: PPUSH
4997: LD_VAR 0 3
5001: PPUSH
5002: CALL_OW 52
// result := veh ;
5006: LD_ADDR_VAR 0 1
5010: PUSH
5011: LD_VAR 0 3
5015: ST_TO_ADDR
// end ; end_of_file
5016: LD_VAR 0 1
5020: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
5021: LD_INT 0
5023: PPUSH
5024: PPUSH
5025: PPUSH
// usForces := [ ] ;
5026: LD_ADDR_EXP 44
5030: PUSH
5031: EMPTY
5032: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
5033: LD_ADDR_EXP 46
5037: PUSH
5038: LD_INT 6
5040: PUSH
5041: LD_INT 32
5043: PUSH
5044: LD_INT 27
5046: PUSH
5047: LD_INT 1
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 4
5058: PUSH
5059: LD_INT 43
5061: PUSH
5062: LD_INT 24
5064: PUSH
5065: LD_INT 5
5067: PUSH
5068: EMPTY
5069: LIST
5070: LIST
5071: LIST
5072: LIST
5073: PUSH
5074: LD_INT 27
5076: PUSH
5077: LD_INT 29
5079: PUSH
5080: LD_INT 21
5082: PUSH
5083: LD_INT 0
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: LIST
5090: LIST
5091: PUSH
5092: EMPTY
5093: LIST
5094: LIST
5095: LIST
5096: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
5097: LD_INT 11
5099: PPUSH
5100: CALL_OW 274
5104: PPUSH
5105: LD_INT 1
5107: PPUSH
5108: LD_INT 150
5110: PUSH
5111: LD_INT 120
5113: PUSH
5114: LD_INT 100
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: PUSH
5122: LD_OWVAR 67
5126: ARRAY
5127: PPUSH
5128: CALL_OW 277
// if Difficulty = 1 then
5132: LD_OWVAR 67
5136: PUSH
5137: LD_INT 1
5139: EQUAL
5140: IFFALSE 5149
// RemoveUnit ( hillBun ) ;
5142: LD_INT 14
5144: PPUSH
5145: CALL_OW 64
// uc_side := 1 ;
5149: LD_ADDR_OWVAR 20
5153: PUSH
5154: LD_INT 1
5156: ST_TO_ADDR
// uc_nation := 1 ;
5157: LD_ADDR_OWVAR 21
5161: PUSH
5162: LD_INT 1
5164: ST_TO_ADDR
// hc_gallery :=  ;
5165: LD_ADDR_OWVAR 33
5169: PUSH
5170: LD_STRING 
5172: ST_TO_ADDR
// hc_name :=  ;
5173: LD_ADDR_OWVAR 26
5177: PUSH
5178: LD_STRING 
5180: ST_TO_ADDR
// hc_importance := 0 ;
5181: LD_ADDR_OWVAR 32
5185: PUSH
5186: LD_INT 0
5188: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5189: LD_INT 1
5191: PPUSH
5192: LD_INT 1
5194: PPUSH
5195: LD_INT 3
5197: PPUSH
5198: CALL_OW 380
// usCommander := CreateHuman ;
5202: LD_ADDR_EXP 45
5206: PUSH
5207: CALL_OW 44
5211: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5212: LD_EXP 45
5216: PPUSH
5217: LD_INT 11
5219: PPUSH
5220: CALL_OW 52
// if Difficulty > 1 then
5224: LD_OWVAR 67
5228: PUSH
5229: LD_INT 1
5231: GREATER
5232: IFFALSE 5314
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5234: LD_INT 0
5236: PPUSH
5237: LD_INT 1
5239: PPUSH
5240: LD_INT 1
5242: PUSH
5243: LD_INT 2
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: LIST
5253: PUSH
5254: LD_OWVAR 67
5258: ARRAY
5259: PPUSH
5260: CALL_OW 380
// un := CreateHuman ;
5264: LD_ADDR_VAR 0 3
5268: PUSH
5269: CALL_OW 44
5273: ST_TO_ADDR
// usForces := usForces union un ;
5274: LD_ADDR_EXP 44
5278: PUSH
5279: LD_EXP 44
5283: PUSH
5284: LD_VAR 0 3
5288: UNION
5289: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5290: LD_VAR 0 3
5294: PPUSH
5295: LD_INT 1
5297: PPUSH
5298: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5302: LD_VAR 0 3
5306: PPUSH
5307: LD_INT 14
5309: PPUSH
5310: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5314: LD_ADDR_VAR 0 2
5318: PUSH
5319: DOUBLE
5320: LD_INT 1
5322: DEC
5323: ST_TO_ADDR
5324: LD_INT 2
5326: PUSH
5327: LD_INT 3
5329: PUSH
5330: LD_INT 4
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PUSH
5344: FOR_TO
5345: IFFALSE 5487
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5347: LD_INT 0
5349: PPUSH
5350: LD_INT 1
5352: PPUSH
5353: LD_INT 1
5355: PUSH
5356: LD_INT 2
5358: PUSH
5359: LD_INT 3
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: LIST
5366: PUSH
5367: LD_OWVAR 67
5371: ARRAY
5372: PPUSH
5373: CALL_OW 380
// un := CreateHuman ;
5377: LD_ADDR_VAR 0 3
5381: PUSH
5382: CALL_OW 44
5386: ST_TO_ADDR
// usForces := usForces union un ;
5387: LD_ADDR_EXP 44
5391: PUSH
5392: LD_EXP 44
5396: PUSH
5397: LD_VAR 0 3
5401: UNION
5402: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5403: LD_VAR 0 3
5407: PPUSH
5408: LD_INT 39
5410: PPUSH
5411: LD_INT 24
5413: PPUSH
5414: LD_INT 4
5416: PPUSH
5417: LD_INT 0
5419: PPUSH
5420: CALL_OW 50
// if i < 3 then
5424: LD_VAR 0 2
5428: PUSH
5429: LD_INT 3
5431: LESS
5432: IFFALSE 5485
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5434: LD_VAR 0 3
5438: PPUSH
5439: LD_INT 22
5441: PUSH
5442: LD_INT 1
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 58
5451: PUSH
5452: EMPTY
5453: LIST
5454: PUSH
5455: LD_INT 30
5457: PUSH
5458: LD_INT 31
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: PPUSH
5470: CALL_OW 69
5474: PUSH
5475: LD_VAR 0 2
5479: ARRAY
5480: PPUSH
5481: CALL_OW 120
// end ;
5485: GO 5344
5487: POP
5488: POP
// for i := 1 to 2 do
5489: LD_ADDR_VAR 0 2
5493: PUSH
5494: DOUBLE
5495: LD_INT 1
5497: DEC
5498: ST_TO_ADDR
5499: LD_INT 2
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5567
// begin PrepareHuman ( false , 2 , 2 ) ;
5505: LD_INT 0
5507: PPUSH
5508: LD_INT 2
5510: PPUSH
5511: LD_INT 2
5513: PPUSH
5514: CALL_OW 380
// un := CreateHuman ;
5518: LD_ADDR_VAR 0 3
5522: PUSH
5523: CALL_OW 44
5527: ST_TO_ADDR
// usForces := usForces union un ;
5528: LD_ADDR_EXP 44
5532: PUSH
5533: LD_EXP 44
5537: PUSH
5538: LD_VAR 0 3
5542: UNION
5543: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5544: LD_VAR 0 3
5548: PPUSH
5549: LD_INT 39
5551: PPUSH
5552: LD_INT 24
5554: PPUSH
5555: LD_INT 4
5557: PPUSH
5558: LD_INT 0
5560: PPUSH
5561: CALL_OW 50
// end ;
5565: GO 5502
5567: POP
5568: POP
// PrepareHuman ( false , 4 , 1 ) ;
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 4
5574: PPUSH
5575: LD_INT 1
5577: PPUSH
5578: CALL_OW 380
// un := CreateHuman ;
5582: LD_ADDR_VAR 0 3
5586: PUSH
5587: CALL_OW 44
5591: ST_TO_ADDR
// usForces := usForces union un ;
5592: LD_ADDR_EXP 44
5596: PUSH
5597: LD_EXP 44
5601: PUSH
5602: LD_VAR 0 3
5606: UNION
5607: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5608: LD_VAR 0 3
5612: PPUSH
5613: LD_INT 39
5615: PPUSH
5616: LD_INT 24
5618: PPUSH
5619: LD_INT 4
5621: PPUSH
5622: LD_INT 0
5624: PPUSH
5625: CALL_OW 50
// end ;
5629: LD_VAR 0 1
5633: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured and not americanStartRun do var i , b , eng , sol , sci ;
5634: LD_EXP 44
5638: PUSH
5639: LD_EXP 6
5643: NOT
5644: AND
5645: PUSH
5646: LD_EXP 14
5650: NOT
5651: AND
5652: IFFALSE 6083
5654: GO 5656
5656: DISABLE
5657: LD_INT 0
5659: PPUSH
5660: PPUSH
5661: PPUSH
5662: PPUSH
5663: PPUSH
// begin enable ;
5664: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5665: LD_ADDR_VAR 0 3
5669: PUSH
5670: LD_EXP 44
5674: PPUSH
5675: LD_INT 25
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PPUSH
5685: CALL_OW 72
5689: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5690: LD_ADDR_VAR 0 4
5694: PUSH
5695: LD_EXP 44
5699: PPUSH
5700: LD_INT 25
5702: PUSH
5703: LD_INT 1
5705: PUSH
5706: EMPTY
5707: LIST
5708: LIST
5709: PPUSH
5710: CALL_OW 72
5714: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5715: LD_ADDR_VAR 0 5
5719: PUSH
5720: LD_EXP 44
5724: PPUSH
5725: LD_INT 25
5727: PUSH
5728: LD_INT 4
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PPUSH
5735: CALL_OW 72
5739: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5740: LD_INT 7
5742: PPUSH
5743: LD_INT 22
5745: PUSH
5746: LD_INT 2
5748: PUSH
5749: EMPTY
5750: LIST
5751: LIST
5752: PPUSH
5753: CALL_OW 70
5757: PUSH
5758: LD_INT 1
5760: EQUAL
5761: IFFALSE 5837
// for i in sol do
5763: LD_ADDR_VAR 0 1
5767: PUSH
5768: LD_VAR 0 4
5772: PUSH
5773: FOR_IN
5774: IFFALSE 5835
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5776: LD_VAR 0 1
5780: PPUSH
5781: CALL_OW 310
5785: NOT
5786: PUSH
5787: LD_VAR 0 1
5791: PPUSH
5792: CALL_OW 310
5796: PPUSH
5797: CALL_OW 266
5801: PUSH
5802: LD_INT 4
5804: EQUAL
5805: NOT
5806: OR
5807: IFFALSE 5833
// begin ComExitBuilding ( i ) ;
5809: LD_VAR 0 1
5813: PPUSH
5814: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5818: LD_VAR 0 1
5822: PPUSH
5823: LD_INT 37
5825: PPUSH
5826: LD_INT 23
5828: PPUSH
5829: CALL_OW 174
// end ;
5833: GO 5773
5835: POP
5836: POP
// if eng then
5837: LD_VAR 0 3
5841: IFFALSE 6083
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 22
5850: PUSH
5851: LD_INT 1
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 95
5860: PUSH
5861: LD_INT 7
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 21
5870: PUSH
5871: LD_INT 3
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 3
5880: PUSH
5881: LD_INT 24
5883: PUSH
5884: LD_INT 1000
5886: PUSH
5887: EMPTY
5888: LIST
5889: LIST
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: PPUSH
5901: CALL_OW 69
5905: ST_TO_ADDR
// if b then
5906: LD_VAR 0 2
5910: IFFALSE 5941
// begin ComExitBuilding ( eng ) ;
5912: LD_VAR 0 3
5916: PPUSH
5917: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5921: LD_VAR 0 3
5925: PPUSH
5926: LD_VAR 0 2
5930: PUSH
5931: LD_INT 1
5933: ARRAY
5934: PPUSH
5935: CALL_OW 190
// end else
5939: GO 6083
// begin for i in eng do
5941: LD_ADDR_VAR 0 1
5945: PUSH
5946: LD_VAR 0 3
5950: PUSH
5951: FOR_IN
5952: IFFALSE 6081
// if not HasTask ( i ) then
5954: LD_VAR 0 1
5958: PPUSH
5959: CALL_OW 314
5963: NOT
5964: IFFALSE 6079
// begin if americanBuildList then
5966: LD_EXP 46
5970: IFFALSE 6055
// begin if IsInUnit ( i ) then
5972: LD_VAR 0 1
5976: PPUSH
5977: CALL_OW 310
5981: IFFALSE 5992
// ComExitBuilding ( i ) ;
5983: LD_VAR 0 1
5987: PPUSH
5988: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5992: LD_VAR 0 1
5996: PPUSH
5997: LD_EXP 46
6001: PUSH
6002: LD_INT 1
6004: ARRAY
6005: PUSH
6006: LD_INT 1
6008: ARRAY
6009: PPUSH
6010: LD_EXP 46
6014: PUSH
6015: LD_INT 1
6017: ARRAY
6018: PUSH
6019: LD_INT 2
6021: ARRAY
6022: PPUSH
6023: LD_EXP 46
6027: PUSH
6028: LD_INT 1
6030: ARRAY
6031: PUSH
6032: LD_INT 3
6034: ARRAY
6035: PPUSH
6036: LD_EXP 46
6040: PUSH
6041: LD_INT 1
6043: ARRAY
6044: PUSH
6045: LD_INT 4
6047: ARRAY
6048: PPUSH
6049: CALL_OW 205
// end else
6053: GO 6079
// if not IsInUnit ( i ) then
6055: LD_VAR 0 1
6059: PPUSH
6060: CALL_OW 310
6064: NOT
6065: IFFALSE 6079
// ComEnterUnit ( i , usDepot ) ;
6067: LD_VAR 0 1
6071: PPUSH
6072: LD_INT 11
6074: PPUSH
6075: CALL_OW 120
// end ;
6079: GO 5951
6081: POP
6082: POP
// end ; end ; end ;
6083: PPOPN 5
6085: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
6086: LD_INT 0
6088: PPUSH
6089: PPUSH
6090: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
6091: LD_ADDR_VAR 0 3
6095: PUSH
6096: LD_INT 35
6098: PUSH
6099: LD_INT 45
6101: PUSH
6102: LD_INT 48
6104: PUSH
6105: LD_EXP 57
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: LIST
6115: ST_TO_ADDR
// for i in tech do
6116: LD_ADDR_VAR 0 4
6120: PUSH
6121: LD_VAR 0 3
6125: PUSH
6126: FOR_IN
6127: IFFALSE 6145
// AddComResearch ( lab , i ) ;
6129: LD_VAR 0 1
6133: PPUSH
6134: LD_VAR 0 4
6138: PPUSH
6139: CALL_OW 184
6143: GO 6126
6145: POP
6146: POP
// end ;
6147: LD_VAR 0 2
6151: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
6152: LD_EXP 12
6156: PUSH
6157: LD_EXP 23
6161: PUSH
6162: LD_EXP 27
6166: LESSEQUAL
6167: AND
6168: IFFALSE 6193
6170: GO 6172
6172: DISABLE
// begin enable ;
6173: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6174: LD_INT 35
6176: PPUSH
6177: LD_INT 2065
6179: PPUSH
6180: CALL_OW 12
6184: PPUSH
6185: CALL_OW 67
// SendConvoy ;
6189: CALL 6291 0 0
// end ;
6193: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6194: LD_EXP 6
6198: PUSH
6199: LD_EXP 18
6203: AND
6204: IFFALSE 6290
6206: GO 6208
6208: DISABLE
// begin if americanHasEscaped then
6209: LD_EXP 8
6213: IFFALSE 6224
// wait ( 3 3$20 ) else
6215: LD_INT 7000
6217: PPUSH
6218: CALL_OW 67
6222: GO 6231
// wait ( 6 6$40 ) ;
6224: LD_INT 14000
6226: PPUSH
6227: CALL_OW 67
// SendAttack ;
6231: CALL 7034 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6235: LD_INT 14000
6237: PUSH
6238: LD_INT 11900
6240: PUSH
6241: LD_INT 9800
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: LIST
6248: PUSH
6249: LD_OWVAR 67
6253: ARRAY
6254: PPUSH
6255: CALL_OW 67
// SendAttack ;
6259: CALL 7034 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6263: LD_EXP 19
6267: PUSH
6268: LD_INT 6
6270: PUSH
6271: LD_INT 7
6273: PUSH
6274: LD_INT 8
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_OWVAR 67
6286: ARRAY
6287: LESS
6288: IFFALSE 6235
// end ;
6290: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6291: LD_INT 0
6293: PPUSH
6294: PPUSH
6295: PPUSH
6296: PPUSH
6297: PPUSH
6298: PPUSH
6299: PPUSH
6300: PPUSH
// road := rand ( 1 , 2 ) ;
6301: LD_ADDR_VAR 0 4
6305: PUSH
6306: LD_INT 1
6308: PPUSH
6309: LD_INT 2
6311: PPUSH
6312: CALL_OW 12
6316: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6317: LD_ADDR_VAR 0 8
6321: PUSH
6322: LD_INT 3
6324: PUSH
6325: LD_INT 8
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: PUSH
6332: LD_VAR 0 4
6336: ARRAY
6337: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6338: LD_ADDR_VAR 0 5
6342: PUSH
6343: LD_INT 35
6345: PUSH
6346: LD_INT 66
6348: PUSH
6349: LD_INT 1
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: LIST
6356: PUSH
6357: LD_INT 101
6359: PUSH
6360: LD_INT 8
6362: PUSH
6363: LD_INT 4
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: LIST
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6375: LD_ADDR_VAR 0 6
6379: PUSH
6380: LD_INT 34
6382: PUSH
6383: LD_INT 67
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: PUSH
6390: LD_INT 38
6392: PUSH
6393: LD_INT 62
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: PUSH
6400: LD_INT 43
6402: PUSH
6403: LD_INT 54
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 57
6412: PUSH
6413: LD_INT 57
6415: PUSH
6416: EMPTY
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 77
6422: PUSH
6423: LD_INT 71
6425: PUSH
6426: EMPTY
6427: LIST
6428: LIST
6429: PUSH
6430: LD_INT 86
6432: PUSH
6433: LD_INT 60
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: LD_INT 89
6442: PUSH
6443: LD_INT 35
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: PUSH
6450: LD_INT 93
6452: PUSH
6453: LD_INT 17
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 97
6462: PUSH
6463: LD_INT 10
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 103
6472: PUSH
6473: LD_INT 9
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: LIST
6491: ST_TO_ADDR
// if road = 2 then
6492: LD_VAR 0 4
6496: PUSH
6497: LD_INT 2
6499: EQUAL
6500: IFFALSE 6517
// points := ReverseArray ( points ) ;
6502: LD_ADDR_VAR 0 6
6506: PUSH
6507: LD_VAR 0 6
6511: PPUSH
6512: CALL 1064 0 1
6516: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6517: LD_INT 4
6519: PPUSH
6520: LD_INT 1
6522: PPUSH
6523: LD_INT 2
6525: PPUSH
6526: LD_INT 1
6528: PPUSH
6529: LD_INT 1
6531: PPUSH
6532: LD_INT 12
6534: PPUSH
6535: LD_INT 80
6537: PPUSH
6538: CALL 376 0 7
// veh := CreateVehicle ;
6542: LD_ADDR_VAR 0 3
6546: PUSH
6547: CALL_OW 45
6551: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6552: LD_VAR 0 3
6556: PPUSH
6557: LD_VAR 0 5
6561: PUSH
6562: LD_VAR 0 4
6566: ARRAY
6567: PUSH
6568: LD_INT 3
6570: ARRAY
6571: PPUSH
6572: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6576: LD_VAR 0 3
6580: PPUSH
6581: LD_VAR 0 5
6585: PUSH
6586: LD_VAR 0 4
6590: ARRAY
6591: PUSH
6592: LD_INT 1
6594: ARRAY
6595: PPUSH
6596: LD_VAR 0 5
6600: PUSH
6601: LD_VAR 0 4
6605: ARRAY
6606: PUSH
6607: LD_INT 2
6609: ARRAY
6610: PPUSH
6611: LD_INT 0
6613: PPUSH
6614: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6618: LD_INT 0
6620: PPUSH
6621: LD_INT 1
6623: PPUSH
6624: LD_OWVAR 67
6628: PPUSH
6629: CALL_OW 380
// un := CreateHuman ;
6633: LD_ADDR_VAR 0 2
6637: PUSH
6638: CALL_OW 44
6642: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6643: LD_VAR 0 2
6647: PPUSH
6648: LD_VAR 0 3
6652: PPUSH
6653: CALL_OW 52
// if ( Prob ( [ 60 , 56 , 52 ] [ Difficulty ] ) + tick mod 30 ) or convoyCounter < 4 then
6657: LD_INT 60
6659: PUSH
6660: LD_INT 56
6662: PUSH
6663: LD_INT 52
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: LIST
6670: PUSH
6671: LD_OWVAR 67
6675: ARRAY
6676: PPUSH
6677: CALL_OW 13
6681: PUSH
6682: LD_OWVAR 1
6686: PUSH
6687: LD_INT 30
6689: MOD
6690: PLUS
6691: PUSH
6692: LD_EXP 23
6696: PUSH
6697: LD_INT 4
6699: LESS
6700: OR
6701: IFFALSE 6718
// SetCargo ( veh , mat_cans , 100 ) ;
6703: LD_VAR 0 3
6707: PPUSH
6708: LD_INT 1
6710: PPUSH
6711: LD_INT 100
6713: PPUSH
6714: CALL_OW 290
// for i := 2 to points do
6718: LD_ADDR_VAR 0 7
6722: PUSH
6723: DOUBLE
6724: LD_INT 2
6726: DEC
6727: ST_TO_ADDR
6728: LD_VAR 0 6
6732: PUSH
6733: FOR_TO
6734: IFFALSE 6777
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6736: LD_VAR 0 3
6740: PPUSH
6741: LD_VAR 0 6
6745: PUSH
6746: LD_VAR 0 7
6750: ARRAY
6751: PUSH
6752: LD_INT 1
6754: ARRAY
6755: PPUSH
6756: LD_VAR 0 6
6760: PUSH
6761: LD_VAR 0 7
6765: ARRAY
6766: PUSH
6767: LD_INT 2
6769: ARRAY
6770: PPUSH
6771: CALL_OW 171
6775: GO 6733
6777: POP
6778: POP
// convoyCounter := convoyCounter + 1 ;
6779: LD_ADDR_EXP 23
6783: PUSH
6784: LD_EXP 23
6788: PUSH
6789: LD_INT 1
6791: PLUS
6792: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6793: LD_INT 35
6795: PPUSH
6796: CALL_OW 67
// if not HasTask ( veh ) and IsOk ( veh ) then
6800: LD_VAR 0 3
6804: PPUSH
6805: CALL_OW 314
6809: NOT
6810: PUSH
6811: LD_VAR 0 3
6815: PPUSH
6816: CALL_OW 302
6820: AND
6821: IFFALSE 6862
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6823: LD_VAR 0 3
6827: PPUSH
6828: LD_VAR 0 6
6832: PUSH
6833: LD_VAR 0 6
6837: ARRAY
6838: PUSH
6839: LD_INT 1
6841: ARRAY
6842: PPUSH
6843: LD_VAR 0 6
6847: PUSH
6848: LD_VAR 0 6
6852: ARRAY
6853: PUSH
6854: LD_INT 2
6856: ARRAY
6857: PPUSH
6858: CALL_OW 111
// if not IsInUnit ( un ) then
6862: LD_VAR 0 2
6866: PPUSH
6867: CALL_OW 310
6871: NOT
6872: IFFALSE 6913
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6874: LD_VAR 0 2
6878: PPUSH
6879: LD_VAR 0 6
6883: PUSH
6884: LD_VAR 0 6
6888: ARRAY
6889: PUSH
6890: LD_INT 1
6892: ARRAY
6893: PPUSH
6894: LD_VAR 0 6
6898: PUSH
6899: LD_VAR 0 6
6903: ARRAY
6904: PUSH
6905: LD_INT 2
6907: ARRAY
6908: PPUSH
6909: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6913: LD_VAR 0 3
6917: PPUSH
6918: LD_VAR 0 8
6922: PPUSH
6923: CALL_OW 308
6927: PUSH
6928: LD_VAR 0 2
6932: PPUSH
6933: LD_VAR 0 8
6937: PPUSH
6938: CALL_OW 308
6942: OR
6943: IFFALSE 6793
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6945: LD_VAR 0 2
6949: PPUSH
6950: CALL_OW 302
6954: PUSH
6955: LD_VAR 0 3
6959: PPUSH
6960: CALL_OW 302
6964: NOT
6965: AND
6966: PUSH
6967: LD_VAR 0 2
6971: PPUSH
6972: LD_VAR 0 8
6976: PPUSH
6977: CALL_OW 308
6981: AND
6982: IFFALSE 6993
// RemoveUnit ( un ) ;
6984: LD_VAR 0 2
6988: PPUSH
6989: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6993: LD_VAR 0 3
6997: PPUSH
6998: LD_VAR 0 8
7002: PPUSH
7003: CALL_OW 308
7007: PUSH
7008: LD_VAR 0 3
7012: PPUSH
7013: CALL_OW 302
7017: AND
7018: IFFALSE 7029
// RemoveUnit ( veh ) ;
7020: LD_VAR 0 3
7024: PPUSH
7025: CALL_OW 64
// end ;
7029: LD_VAR 0 1
7033: RET
// export function SendAttack ; var un , veh , i ; begin
7034: LD_INT 0
7036: PPUSH
7037: PPUSH
7038: PPUSH
7039: PPUSH
// IncomingAttack ;
7040: CALL 15565 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
7044: LD_INT 2100
7046: PPUSH
7047: LD_INT 3500
7049: PPUSH
7050: CALL_OW 12
7054: PPUSH
7055: CALL_OW 67
// for i := 1 to [ 3 , 4 , 4 ] [ Difficulty ] + attackWave div 3 do
7059: LD_ADDR_VAR 0 4
7063: PUSH
7064: DOUBLE
7065: LD_INT 1
7067: DEC
7068: ST_TO_ADDR
7069: LD_INT 3
7071: PUSH
7072: LD_INT 4
7074: PUSH
7075: LD_INT 4
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: LIST
7082: PUSH
7083: LD_OWVAR 67
7087: ARRAY
7088: PUSH
7089: LD_EXP 19
7093: PUSH
7094: LD_INT 3
7096: DIV
7097: PLUS
7098: PUSH
7099: FOR_TO
7100: IFFALSE 7212
// begin uc_side := 1 ;
7102: LD_ADDR_OWVAR 20
7106: PUSH
7107: LD_INT 1
7109: ST_TO_ADDR
// uc_nation := 1 ;
7110: LD_ADDR_OWVAR 21
7114: PUSH
7115: LD_INT 1
7117: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
7118: LD_INT 0
7120: PPUSH
7121: LD_INT 1
7123: PPUSH
7124: LD_INT 2
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: ARRAY
7143: PPUSH
7144: CALL_OW 380
// un := CreateHuman ;
7148: LD_ADDR_VAR 0 2
7152: PUSH
7153: CALL_OW 44
7157: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7158: LD_VAR 0 2
7162: PPUSH
7163: LD_INT 37
7165: PPUSH
7166: LD_INT 70
7168: PPUSH
7169: LD_INT 3
7171: PPUSH
7172: LD_INT 0
7174: PPUSH
7175: CALL_OW 50
// usAttackers := usAttackers union un ;
7179: LD_ADDR_EXP 47
7183: PUSH
7184: LD_EXP 47
7188: PUSH
7189: LD_VAR 0 2
7193: UNION
7194: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7195: LD_VAR 0 2
7199: PPUSH
7200: LD_INT 40
7202: PPUSH
7203: LD_INT 65
7205: PPUSH
7206: CALL_OW 111
// end ;
7210: GO 7099
7212: POP
7213: POP
// uc_side := 1 ;
7214: LD_ADDR_OWVAR 20
7218: PUSH
7219: LD_INT 1
7221: ST_TO_ADDR
// uc_nation := 1 ;
7222: LD_ADDR_OWVAR 21
7226: PUSH
7227: LD_INT 1
7229: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7230: LD_INT 0
7232: PPUSH
7233: LD_INT 4
7235: PPUSH
7236: LD_INT 2
7238: PPUSH
7239: CALL_OW 380
// un := CreateHuman ;
7243: LD_ADDR_VAR 0 2
7247: PUSH
7248: CALL_OW 44
7252: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7253: LD_VAR 0 2
7257: PPUSH
7258: LD_INT 37
7260: PPUSH
7261: LD_INT 70
7263: PPUSH
7264: LD_INT 3
7266: PPUSH
7267: LD_INT 0
7269: PPUSH
7270: CALL_OW 50
// usAttackers := usAttackers union un ;
7274: LD_ADDR_EXP 47
7278: PUSH
7279: LD_EXP 47
7283: PUSH
7284: LD_VAR 0 2
7288: UNION
7289: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7290: LD_VAR 0 2
7294: PPUSH
7295: LD_INT 40
7297: PPUSH
7298: LD_INT 65
7300: PPUSH
7301: CALL_OW 111
// for i := 1 to Difficulty + attackWave div 4 do
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: DOUBLE
7311: LD_INT 1
7313: DEC
7314: ST_TO_ADDR
7315: LD_OWVAR 67
7319: PUSH
7320: LD_EXP 19
7324: PUSH
7325: LD_INT 4
7327: DIV
7328: PLUS
7329: PUSH
7330: FOR_TO
7331: IFFALSE 7504
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7333: LD_ADDR_VAR 0 3
7337: PUSH
7338: LD_INT 1
7340: PPUSH
7341: LD_INT 1
7343: PPUSH
7344: LD_INT 2
7346: PPUSH
7347: LD_INT 1
7349: PPUSH
7350: LD_INT 1
7352: PPUSH
7353: LD_INT 4
7355: PUSH
7356: LD_INT 3
7358: PUSH
7359: LD_INT 2
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: PUSH
7367: LD_INT 1
7369: PPUSH
7370: LD_INT 3
7372: PPUSH
7373: CALL_OW 12
7377: ARRAY
7378: PPUSH
7379: LD_INT 90
7381: PPUSH
7382: CALL 376 0 7
7386: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7387: LD_VAR 0 3
7391: PPUSH
7392: LD_INT 35
7394: PPUSH
7395: LD_INT 65
7397: PPUSH
7398: LD_INT 0
7400: PPUSH
7401: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7405: LD_INT 0
7407: PPUSH
7408: LD_INT 3
7410: PPUSH
7411: LD_OWVAR 67
7415: PUSH
7416: LD_INT 1
7418: PLUS
7419: PPUSH
7420: CALL_OW 380
// un := CreateHuman ;
7424: LD_ADDR_VAR 0 2
7428: PUSH
7429: CALL_OW 44
7433: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7434: LD_VAR 0 2
7438: PPUSH
7439: LD_VAR 0 3
7443: PPUSH
7444: CALL_OW 52
// usAttackers := usAttackers union un ;
7448: LD_ADDR_EXP 47
7452: PUSH
7453: LD_EXP 47
7457: PUSH
7458: LD_VAR 0 2
7462: UNION
7463: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7464: LD_VAR 0 3
7468: PPUSH
7469: LD_INT 39
7471: PPUSH
7472: LD_INT 60
7474: PPUSH
7475: CALL_OW 111
// wait ( 0 0$3 ) ;
7479: LD_INT 105
7481: PPUSH
7482: CALL_OW 67
// usAttackers := usAttackers union veh ;
7486: LD_ADDR_EXP 47
7490: PUSH
7491: LD_EXP 47
7495: PUSH
7496: LD_VAR 0 3
7500: UNION
7501: ST_TO_ADDR
// end ;
7502: GO 7330
7504: POP
7505: POP
// attackWave := attackWave + 1 ;
7506: LD_ADDR_EXP 19
7510: PUSH
7511: LD_EXP 19
7515: PUSH
7516: LD_INT 1
7518: PLUS
7519: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7520: LD_EXP 24
7524: PPUSH
7525: CALL_OW 427
// end ;
7529: LD_VAR 0 1
7533: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7534: LD_INT 0
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
7543: PPUSH
7544: PPUSH
7545: PPUSH
7546: PPUSH
// if retreatAllowed then
7547: LD_EXP 11
7551: IFFALSE 7563
// strategy := 2 else
7553: LD_ADDR_VAR 0 5
7557: PUSH
7558: LD_INT 2
7560: ST_TO_ADDR
7561: GO 7579
// strategy := rand ( 0 , 2 ) ;
7563: LD_ADDR_VAR 0 5
7567: PUSH
7568: LD_INT 0
7570: PPUSH
7571: LD_INT 2
7573: PPUSH
7574: CALL_OW 12
7578: ST_TO_ADDR
// attackFormula := [ ] ;
7579: LD_ADDR_VAR 0 6
7583: PUSH
7584: EMPTY
7585: ST_TO_ADDR
// case strategy of 0 :
7586: LD_VAR 0 5
7590: PUSH
7591: LD_INT 0
7593: DOUBLE
7594: EQUAL
7595: IFTRUE 7599
7597: GO 7929
7599: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7600: LD_INT 11
7602: PPUSH
7603: LD_INT 22
7605: PUSH
7606: LD_INT 2
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 30
7615: PUSH
7616: LD_INT 4
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: PPUSH
7627: CALL_OW 70
7631: NOT
7632: IFFALSE 7704
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7634: LD_ADDR_VAR 0 6
7638: PUSH
7639: LD_INT 41
7641: PUSH
7642: LD_INT 34
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: PUSH
7649: EMPTY
7650: LIST
7651: PUSH
7652: LD_INT 53
7654: PUSH
7655: LD_INT 62
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 37
7664: PUSH
7665: LD_INT 63
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: LD_INT 44
7674: PUSH
7675: LD_INT 45
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: LD_INT 37
7684: PUSH
7685: LD_INT 28
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: ST_TO_ADDR
7702: GO 7927
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7704: LD_INT 12
7706: PPUSH
7707: LD_INT 22
7709: PUSH
7710: LD_INT 2
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PUSH
7717: LD_INT 2
7719: PUSH
7720: LD_INT 30
7722: PUSH
7723: LD_INT 4
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PUSH
7730: LD_INT 30
7732: PUSH
7733: LD_INT 31
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 30
7742: PUSH
7743: LD_INT 32
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PPUSH
7760: CALL_OW 70
7764: NOT
7765: IFFALSE 7848
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7767: LD_ADDR_VAR 0 6
7771: PUSH
7772: LD_INT 27
7774: PUSH
7775: LD_INT 42
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 27
7784: PUSH
7785: LD_INT 32
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: LD_INT 53
7798: PUSH
7799: LD_INT 62
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: LD_INT 37
7808: PUSH
7809: LD_INT 63
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 44
7818: PUSH
7819: LD_INT 45
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 37
7828: PUSH
7829: LD_INT 28
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: EMPTY
7837: LIST
7838: LIST
7839: PUSH
7840: EMPTY
7841: LIST
7842: LIST
7843: LIST
7844: LIST
7845: ST_TO_ADDR
7846: GO 7927
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7848: LD_ADDR_VAR 0 6
7852: PUSH
7853: LD_INT 71
7855: PUSH
7856: LD_INT 67
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 54
7865: PUSH
7866: LD_INT 35
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: PUSH
7877: LD_INT 63
7879: PUSH
7880: LD_INT 40
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PUSH
7887: LD_INT 37
7889: PUSH
7890: LD_INT 63
7892: PUSH
7893: EMPTY
7894: LIST
7895: LIST
7896: PUSH
7897: LD_INT 44
7899: PUSH
7900: LD_INT 45
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 37
7909: PUSH
7910: LD_INT 28
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: EMPTY
7918: LIST
7919: LIST
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: LIST
7926: ST_TO_ADDR
// end ; 1 :
7927: GO 8132
7929: LD_INT 1
7931: DOUBLE
7932: EQUAL
7933: IFTRUE 7937
7935: GO 8041
7937: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7938: LD_ADDR_VAR 0 6
7942: PUSH
7943: LD_INT 71
7945: PUSH
7946: LD_INT 67
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PUSH
7953: LD_INT 82
7955: PUSH
7956: LD_INT 23
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: PUSH
7963: LD_INT 53
7965: PUSH
7966: LD_INT 7
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PUSH
7973: LD_INT 43
7975: PUSH
7976: LD_INT 10
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 53
7991: PUSH
7992: LD_INT 62
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: PUSH
7999: LD_INT 37
8001: PUSH
8002: LD_INT 63
8004: PUSH
8005: EMPTY
8006: LIST
8007: LIST
8008: PUSH
8009: LD_INT 44
8011: PUSH
8012: LD_INT 45
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 37
8021: PUSH
8022: LD_INT 28
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: EMPTY
8034: LIST
8035: LIST
8036: LIST
8037: LIST
8038: ST_TO_ADDR
8039: GO 8132
8041: LD_INT 2
8043: DOUBLE
8044: EQUAL
8045: IFTRUE 8049
8047: GO 8131
8049: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
8050: LD_ADDR_VAR 0 6
8054: PUSH
8055: LD_INT 90
8057: PUSH
8058: LD_INT 59
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: PUSH
8065: LD_INT 108
8067: PUSH
8068: LD_INT 64
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: PUSH
8079: LD_INT 82
8081: PUSH
8082: LD_INT 75
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PUSH
8089: LD_INT 73
8091: PUSH
8092: LD_INT 67
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 101
8101: PUSH
8102: LD_INT 65
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 108
8111: PUSH
8112: LD_INT 62
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: LIST
8127: LIST
8128: ST_TO_ADDR
8129: GO 8132
8131: POP
// if not attackFormula then
8132: LD_VAR 0 6
8136: NOT
8137: IFFALSE 8141
// exit ;
8139: GO 9567
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8141: LD_ADDR_VAR 0 7
8145: PUSH
8146: LD_EXP 47
8150: PPUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 1
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PPUSH
8161: CALL_OW 72
8165: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8166: LD_ADDR_VAR 0 8
8170: PUSH
8171: LD_EXP 47
8175: PPUSH
8176: LD_INT 25
8178: PUSH
8179: LD_INT 4
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: PPUSH
8186: CALL_OW 72
8190: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8191: LD_ADDR_VAR 0 9
8195: PUSH
8196: LD_EXP 47
8200: PPUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 72
8215: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8216: LD_ADDR_VAR 0 10
8220: PUSH
8221: LD_EXP 47
8225: PPUSH
8226: LD_INT 21
8228: PUSH
8229: LD_INT 2
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PPUSH
8236: CALL_OW 72
8240: ST_TO_ADDR
// if sci then
8241: LD_VAR 0 8
8245: IFFALSE 8282
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8247: LD_VAR 0 8
8251: PPUSH
8252: LD_VAR 0 6
8256: PUSH
8257: LD_INT 2
8259: ARRAY
8260: PUSH
8261: LD_INT 1
8263: ARRAY
8264: PPUSH
8265: LD_VAR 0 6
8269: PUSH
8270: LD_INT 2
8272: ARRAY
8273: PUSH
8274: LD_INT 2
8276: ARRAY
8277: PPUSH
8278: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8282: LD_INT 35
8284: PPUSH
8285: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8289: LD_ADDR_VAR 0 7
8293: PUSH
8294: LD_EXP 47
8298: PPUSH
8299: LD_INT 25
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: EMPTY
8306: LIST
8307: LIST
8308: PPUSH
8309: CALL_OW 72
8313: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8314: LD_ADDR_VAR 0 8
8318: PUSH
8319: LD_EXP 47
8323: PPUSH
8324: LD_INT 25
8326: PUSH
8327: LD_INT 4
8329: PUSH
8330: EMPTY
8331: LIST
8332: LIST
8333: PPUSH
8334: CALL_OW 72
8338: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8339: LD_ADDR_VAR 0 9
8343: PUSH
8344: LD_EXP 47
8348: PPUSH
8349: LD_INT 25
8351: PUSH
8352: LD_INT 3
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: PPUSH
8359: CALL_OW 72
8363: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8364: LD_ADDR_VAR 0 10
8368: PUSH
8369: LD_EXP 47
8373: PPUSH
8374: LD_INT 21
8376: PUSH
8377: LD_INT 2
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 72
8388: ST_TO_ADDR
// if sol then
8389: LD_VAR 0 7
8393: IFFALSE 8788
// begin for i in sol do
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 7
8404: PUSH
8405: FOR_IN
8406: IFFALSE 8786
// begin tag := GetTag ( i ) ;
8408: LD_ADDR_VAR 0 4
8412: PUSH
8413: LD_VAR 0 2
8417: PPUSH
8418: CALL_OW 110
8422: ST_TO_ADDR
// if not tag then
8423: LD_VAR 0 4
8427: NOT
8428: IFFALSE 8546
// begin if GetLives ( i ) = 1000 then
8430: LD_VAR 0 2
8434: PPUSH
8435: CALL_OW 256
8439: PUSH
8440: LD_INT 1000
8442: EQUAL
8443: IFFALSE 8459
// SetTag ( i , 1 ) else
8445: LD_VAR 0 2
8449: PPUSH
8450: LD_INT 1
8452: PPUSH
8453: CALL_OW 109
8457: GO 8544
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8459: LD_VAR 0 2
8463: PPUSH
8464: LD_VAR 0 6
8468: PUSH
8469: LD_INT 2
8471: ARRAY
8472: PUSH
8473: LD_INT 1
8475: ARRAY
8476: PPUSH
8477: LD_VAR 0 6
8481: PUSH
8482: LD_INT 2
8484: ARRAY
8485: PUSH
8486: LD_INT 2
8488: ARRAY
8489: PPUSH
8490: CALL_OW 297
8494: PUSH
8495: LD_INT 6
8497: GREATER
8498: IFFALSE 8544
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8500: LD_VAR 0 2
8504: PPUSH
8505: LD_VAR 0 6
8509: PUSH
8510: LD_INT 2
8512: ARRAY
8513: PUSH
8514: LD_INT 1
8516: ARRAY
8517: PPUSH
8518: LD_VAR 0 6
8522: PUSH
8523: LD_INT 2
8525: ARRAY
8526: PUSH
8527: LD_INT 2
8529: ARRAY
8530: PPUSH
8531: CALL_OW 111
// AddComHold ( i ) ;
8535: LD_VAR 0 2
8539: PPUSH
8540: CALL_OW 200
// end ; end else
8544: GO 8784
// begin if GetLives ( i ) < 720 then
8546: LD_VAR 0 2
8550: PPUSH
8551: CALL_OW 256
8555: PUSH
8556: LD_INT 720
8558: LESS
8559: IFFALSE 8575
// SetTag ( i , 0 ) else
8561: LD_VAR 0 2
8565: PPUSH
8566: LD_INT 0
8568: PPUSH
8569: CALL_OW 109
8573: GO 8784
// if tag <= attackFormula [ 1 ] then
8575: LD_VAR 0 4
8579: PUSH
8580: LD_VAR 0 6
8584: PUSH
8585: LD_INT 1
8587: ARRAY
8588: LESSEQUAL
8589: IFFALSE 8750
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8591: LD_VAR 0 2
8595: PPUSH
8596: LD_VAR 0 6
8600: PUSH
8601: LD_INT 1
8603: ARRAY
8604: PUSH
8605: LD_VAR 0 4
8609: ARRAY
8610: PUSH
8611: LD_INT 1
8613: ARRAY
8614: PPUSH
8615: LD_VAR 0 6
8619: PUSH
8620: LD_INT 1
8622: ARRAY
8623: PUSH
8624: LD_VAR 0 4
8628: ARRAY
8629: PUSH
8630: LD_INT 2
8632: ARRAY
8633: PPUSH
8634: CALL_OW 297
8638: PUSH
8639: LD_INT 6
8641: GREATER
8642: IFFALSE 8693
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8644: LD_VAR 0 2
8648: PPUSH
8649: LD_VAR 0 6
8653: PUSH
8654: LD_INT 1
8656: ARRAY
8657: PUSH
8658: LD_VAR 0 4
8662: ARRAY
8663: PUSH
8664: LD_INT 1
8666: ARRAY
8667: PPUSH
8668: LD_VAR 0 6
8672: PUSH
8673: LD_INT 1
8675: ARRAY
8676: PUSH
8677: LD_VAR 0 4
8681: ARRAY
8682: PUSH
8683: LD_INT 2
8685: ARRAY
8686: PPUSH
8687: CALL_OW 114
8691: GO 8748
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8693: LD_INT 81
8695: PUSH
8696: LD_INT 1
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PUSH
8703: LD_INT 91
8705: PUSH
8706: LD_VAR 0 2
8710: PUSH
8711: LD_INT 10
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: EMPTY
8720: LIST
8721: LIST
8722: PPUSH
8723: CALL_OW 69
8727: NOT
8728: IFFALSE 8748
// SetTag ( i , tag + 1 ) ;
8730: LD_VAR 0 2
8734: PPUSH
8735: LD_VAR 0 4
8739: PUSH
8740: LD_INT 1
8742: PLUS
8743: PPUSH
8744: CALL_OW 109
// end else
8748: GO 8784
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8750: LD_VAR 0 2
8754: PPUSH
8755: LD_INT 81
8757: PUSH
8758: LD_INT 1
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: PPUSH
8765: CALL_OW 69
8769: PPUSH
8770: LD_VAR 0 2
8774: PPUSH
8775: CALL_OW 74
8779: PPUSH
8780: CALL_OW 115
// end ; end ;
8784: GO 8405
8786: POP
8787: POP
// end ; if sci then
8788: LD_VAR 0 8
8792: IFFALSE 8951
// begin if not sol and not mech then
8794: LD_VAR 0 7
8798: NOT
8799: PUSH
8800: LD_VAR 0 9
8804: NOT
8805: AND
8806: IFFALSE 8858
// begin for i in sci do
8808: LD_ADDR_VAR 0 2
8812: PUSH
8813: LD_VAR 0 8
8817: PUSH
8818: FOR_IN
8819: IFFALSE 8854
// begin usForces := usForces union i ;
8821: LD_ADDR_EXP 44
8825: PUSH
8826: LD_EXP 44
8830: PUSH
8831: LD_VAR 0 2
8835: UNION
8836: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8837: LD_VAR 0 2
8841: PPUSH
8842: LD_INT 34
8844: PPUSH
8845: LD_INT 68
8847: PPUSH
8848: CALL_OW 111
// end ;
8852: GO 8818
8854: POP
8855: POP
// end else
8856: GO 8951
// for i in sci do
8858: LD_ADDR_VAR 0 2
8862: PUSH
8863: LD_VAR 0 8
8867: PUSH
8868: FOR_IN
8869: IFFALSE 8949
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8871: LD_VAR 0 2
8875: PPUSH
8876: LD_VAR 0 6
8880: PUSH
8881: LD_INT 2
8883: ARRAY
8884: PUSH
8885: LD_INT 1
8887: ARRAY
8888: PPUSH
8889: LD_VAR 0 6
8893: PUSH
8894: LD_INT 2
8896: ARRAY
8897: PUSH
8898: LD_INT 2
8900: ARRAY
8901: PPUSH
8902: CALL_OW 297
8906: PUSH
8907: LD_INT 8
8909: GREATER
8910: IFFALSE 8947
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8912: LD_VAR 0 2
8916: PPUSH
8917: LD_VAR 0 6
8921: PUSH
8922: LD_INT 2
8924: ARRAY
8925: PUSH
8926: LD_INT 1
8928: ARRAY
8929: PPUSH
8930: LD_VAR 0 6
8934: PUSH
8935: LD_INT 2
8937: ARRAY
8938: PUSH
8939: LD_INT 2
8941: ARRAY
8942: PPUSH
8943: CALL_OW 111
8947: GO 8868
8949: POP
8950: POP
// end ; if mech then
8951: LD_VAR 0 9
8955: IFFALSE 9560
// begin for i in mech do
8957: LD_ADDR_VAR 0 2
8961: PUSH
8962: LD_VAR 0 9
8966: PUSH
8967: FOR_IN
8968: IFFALSE 9558
// begin tag := GetTag ( i ) ;
8970: LD_ADDR_VAR 0 4
8974: PUSH
8975: LD_VAR 0 2
8979: PPUSH
8980: CALL_OW 110
8984: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8985: LD_ADDR_VAR 0 11
8989: PUSH
8990: LD_VAR 0 2
8994: PPUSH
8995: CALL_OW 310
8999: ST_TO_ADDR
// if not tag then
9000: LD_VAR 0 4
9004: NOT
9005: IFFALSE 9318
// begin if veh then
9007: LD_VAR 0 11
9011: IFFALSE 9160
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
9013: LD_VAR 0 11
9017: PPUSH
9018: CALL_OW 256
9022: PUSH
9023: LD_INT 1000
9025: EQUAL
9026: PUSH
9027: LD_VAR 0 11
9031: PPUSH
9032: CALL_OW 261
9036: PUSH
9037: LD_INT 60
9039: GREATER
9040: AND
9041: IFFALSE 9057
// SetTag ( i , 1 ) else
9043: LD_VAR 0 2
9047: PPUSH
9048: LD_INT 1
9050: PPUSH
9051: CALL_OW 109
9055: GO 9158
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
9057: LD_VAR 0 2
9061: PPUSH
9062: LD_VAR 0 6
9066: PUSH
9067: LD_INT 3
9069: ARRAY
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PPUSH
9075: LD_VAR 0 6
9079: PUSH
9080: LD_INT 3
9082: ARRAY
9083: PUSH
9084: LD_INT 2
9086: ARRAY
9087: PPUSH
9088: CALL_OW 297
9092: PUSH
9093: LD_INT 7
9095: GREATER
9096: IFFALSE 9135
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
9098: LD_VAR 0 2
9102: PPUSH
9103: LD_VAR 0 6
9107: PUSH
9108: LD_INT 3
9110: ARRAY
9111: PUSH
9112: LD_INT 1
9114: ARRAY
9115: PPUSH
9116: LD_VAR 0 6
9120: PUSH
9121: LD_INT 3
9123: ARRAY
9124: PUSH
9125: LD_INT 2
9127: ARRAY
9128: PPUSH
9129: CALL_OW 111
9133: GO 9158
// begin ComExitVehicle ( i ) ;
9135: LD_VAR 0 2
9139: PPUSH
9140: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
9144: LD_VAR 0 2
9148: PPUSH
9149: LD_VAR 0 11
9153: PPUSH
9154: CALL_OW 189
// end ; end else
9158: GO 9316
// if GetLives ( i ) < 700 then
9160: LD_VAR 0 2
9164: PPUSH
9165: CALL_OW 256
9169: PUSH
9170: LD_INT 700
9172: LESS
9173: IFFALSE 9224
// begin usAttackers := usAttackers diff i ;
9175: LD_ADDR_EXP 47
9179: PUSH
9180: LD_EXP 47
9184: PUSH
9185: LD_VAR 0 2
9189: DIFF
9190: ST_TO_ADDR
// usForces := usForces union i ;
9191: LD_ADDR_EXP 44
9195: PUSH
9196: LD_EXP 44
9200: PUSH
9201: LD_VAR 0 2
9205: UNION
9206: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9207: LD_VAR 0 2
9211: PPUSH
9212: LD_INT 34
9214: PPUSH
9215: LD_INT 68
9217: PPUSH
9218: CALL_OW 111
// end else
9222: GO 9316
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9224: LD_VAR 0 10
9228: PPUSH
9229: LD_INT 58
9231: PUSH
9232: EMPTY
9233: LIST
9234: PUSH
9235: LD_INT 24
9237: PUSH
9238: LD_INT 1000
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: PPUSH
9249: CALL_OW 72
9253: PUSH
9254: LD_VAR 0 2
9258: PPUSH
9259: CALL_OW 314
9263: NOT
9264: AND
9265: IFFALSE 9316
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9267: LD_VAR 0 2
9271: PPUSH
9272: LD_VAR 0 10
9276: PPUSH
9277: LD_INT 58
9279: PUSH
9280: EMPTY
9281: LIST
9282: PUSH
9283: LD_INT 24
9285: PUSH
9286: LD_INT 1000
9288: PUSH
9289: EMPTY
9290: LIST
9291: LIST
9292: PUSH
9293: EMPTY
9294: LIST
9295: LIST
9296: PPUSH
9297: CALL_OW 72
9301: PPUSH
9302: LD_VAR 0 2
9306: PPUSH
9307: CALL_OW 74
9311: PPUSH
9312: CALL_OW 120
// end else
9316: GO 9556
// begin if GetLives ( veh ) < 720 then
9318: LD_VAR 0 11
9322: PPUSH
9323: CALL_OW 256
9327: PUSH
9328: LD_INT 720
9330: LESS
9331: IFFALSE 9347
// SetTag ( i , 0 ) else
9333: LD_VAR 0 2
9337: PPUSH
9338: LD_INT 0
9340: PPUSH
9341: CALL_OW 109
9345: GO 9556
// if tag <= attackFormula [ 4 ] then
9347: LD_VAR 0 4
9351: PUSH
9352: LD_VAR 0 6
9356: PUSH
9357: LD_INT 4
9359: ARRAY
9360: LESSEQUAL
9361: IFFALSE 9522
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9363: LD_VAR 0 2
9367: PPUSH
9368: LD_VAR 0 6
9372: PUSH
9373: LD_INT 4
9375: ARRAY
9376: PUSH
9377: LD_VAR 0 4
9381: ARRAY
9382: PUSH
9383: LD_INT 1
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 6
9391: PUSH
9392: LD_INT 4
9394: ARRAY
9395: PUSH
9396: LD_VAR 0 4
9400: ARRAY
9401: PUSH
9402: LD_INT 2
9404: ARRAY
9405: PPUSH
9406: CALL_OW 297
9410: PUSH
9411: LD_INT 6
9413: GREATER
9414: IFFALSE 9465
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9416: LD_VAR 0 2
9420: PPUSH
9421: LD_VAR 0 6
9425: PUSH
9426: LD_INT 4
9428: ARRAY
9429: PUSH
9430: LD_VAR 0 4
9434: ARRAY
9435: PUSH
9436: LD_INT 1
9438: ARRAY
9439: PPUSH
9440: LD_VAR 0 6
9444: PUSH
9445: LD_INT 4
9447: ARRAY
9448: PUSH
9449: LD_VAR 0 4
9453: ARRAY
9454: PUSH
9455: LD_INT 2
9457: ARRAY
9458: PPUSH
9459: CALL_OW 114
9463: GO 9520
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9465: LD_INT 81
9467: PUSH
9468: LD_INT 1
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: PUSH
9475: LD_INT 91
9477: PUSH
9478: LD_VAR 0 2
9482: PUSH
9483: LD_INT 10
9485: PUSH
9486: EMPTY
9487: LIST
9488: LIST
9489: LIST
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: PPUSH
9495: CALL_OW 69
9499: NOT
9500: IFFALSE 9520
// SetTag ( i , tag + 1 ) ;
9502: LD_VAR 0 2
9506: PPUSH
9507: LD_VAR 0 4
9511: PUSH
9512: LD_INT 1
9514: PLUS
9515: PPUSH
9516: CALL_OW 109
// end else
9520: GO 9556
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9522: LD_VAR 0 2
9526: PPUSH
9527: LD_INT 81
9529: PUSH
9530: LD_INT 1
9532: PUSH
9533: EMPTY
9534: LIST
9535: LIST
9536: PPUSH
9537: CALL_OW 69
9541: PPUSH
9542: LD_VAR 0 2
9546: PPUSH
9547: CALL_OW 74
9551: PPUSH
9552: CALL_OW 115
// end ; end ;
9556: GO 8967
9558: POP
9559: POP
// end ; until not usAttackers ;
9560: LD_EXP 47
9564: NOT
9565: IFFALSE 8282
// end ;
9567: LD_VAR 0 1
9571: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do var i ;
9572: LD_INT 22
9574: PUSH
9575: LD_INT 1
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: PUSH
9582: LD_INT 32
9584: PUSH
9585: LD_INT 1
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PPUSH
9596: CALL_OW 69
9600: IFFALSE 9677
9602: GO 9604
9604: DISABLE
9605: LD_INT 0
9607: PPUSH
// begin enable ;
9608: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do
9609: LD_ADDR_VAR 0 1
9613: PUSH
9614: LD_INT 22
9616: PUSH
9617: LD_INT 1
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: LD_INT 32
9626: PUSH
9627: LD_INT 1
9629: PUSH
9630: EMPTY
9631: LIST
9632: LIST
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PPUSH
9638: CALL_OW 69
9642: PUSH
9643: FOR_IN
9644: IFFALSE 9675
// if GetFuel ( i ) < 10 then
9646: LD_VAR 0 1
9650: PPUSH
9651: CALL_OW 261
9655: PUSH
9656: LD_INT 10
9658: LESS
9659: IFFALSE 9673
// SetFuel ( i , 10 ) ;
9661: LD_VAR 0 1
9665: PPUSH
9666: LD_INT 10
9668: PPUSH
9669: CALL_OW 240
9673: GO 9643
9675: POP
9676: POP
// end ; end_of_file
9677: PPOPN 1
9679: END
// export function Action ; var hasAll , i , tmp ; begin
9680: LD_INT 0
9682: PPUSH
9683: PPUSH
9684: PPUSH
9685: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9686: LD_ADDR_VAR 0 2
9690: PUSH
9691: LD_INT 22
9693: PUSH
9694: LD_INT 2
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: PUSH
9701: LD_INT 21
9703: PUSH
9704: LD_INT 1
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 23
9713: PUSH
9714: LD_INT 2
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: LIST
9725: PPUSH
9726: CALL_OW 69
9730: PUSH
9731: LD_INT 7
9733: GREATEREQUAL
9734: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9735: LD_VAR 0 2
9739: PPUSH
9740: LD_STRING 03_HasAll
9742: PPUSH
9743: CALL_OW 39
// Video ( true ) ;
9747: LD_INT 1
9749: PPUSH
9750: CALL 1036 0 1
// CenterNowOnUnits ( Heike ) ;
9754: LD_EXP 28
9758: PPUSH
9759: CALL_OW 87
// wait ( 0 0$2 ) ;
9763: LD_INT 70
9765: PPUSH
9766: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9770: LD_EXP 36
9774: PPUSH
9775: LD_STRING DF-1-start
9777: PPUSH
9778: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9782: LD_EXP 28
9786: PPUSH
9787: LD_EXP 36
9791: PPUSH
9792: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9796: LD_EXP 28
9800: PPUSH
9801: LD_STRING DH-1-start
9803: PPUSH
9804: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9808: LD_EXP 37
9812: PPUSH
9813: LD_INT 92
9815: PPUSH
9816: LD_INT 21
9818: PPUSH
9819: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9823: LD_EXP 32
9827: PPUSH
9828: LD_INT 94
9830: PPUSH
9831: LD_INT 23
9833: PPUSH
9834: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9838: LD_EXP 40
9842: PUSH
9843: LD_INT 1
9845: ARRAY
9846: PPUSH
9847: LD_INT 90
9849: PPUSH
9850: LD_INT 23
9852: PPUSH
9853: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9857: LD_EXP 40
9861: PUSH
9862: LD_INT 2
9864: ARRAY
9865: PPUSH
9866: LD_INT 93
9868: PPUSH
9869: LD_INT 25
9871: PPUSH
9872: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9876: LD_EXP 40
9880: PPUSH
9881: LD_EXP 37
9885: PPUSH
9886: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9890: LD_EXP 37
9894: PUSH
9895: LD_EXP 32
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PPUSH
9904: LD_EXP 28
9908: PPUSH
9909: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9913: LD_EXP 28
9917: PPUSH
9918: LD_EXP 37
9922: PPUSH
9923: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9927: LD_INT 35
9929: PPUSH
9930: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9934: LD_EXP 37
9938: PPUSH
9939: LD_INT 92
9941: PPUSH
9942: LD_INT 21
9944: PPUSH
9945: CALL_OW 307
9949: IFFALSE 9927
// Say ( Omar , DO-1-start ) ;
9951: LD_EXP 37
9955: PPUSH
9956: LD_STRING DO-1-start
9958: PPUSH
9959: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9963: LD_EXP 28
9967: PPUSH
9968: LD_STRING DH-2-start
9970: PPUSH
9971: CALL_OW 88
// if hasAll then
9975: LD_VAR 0 2
9979: IFFALSE 10107
// begin Say ( Omar , DO-2-start ) ;
9981: LD_EXP 37
9985: PPUSH
9986: LD_STRING DO-2-start
9988: PPUSH
9989: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9993: LD_EXP 37
9997: PPUSH
9998: LD_STRING DO-3-start
10000: PPUSH
10001: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
10005: LD_EXP 28
10009: PPUSH
10010: LD_STRING DH-3-start
10012: PPUSH
10013: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
10017: LD_EXP 36
10021: PPUSH
10022: LD_STRING DF-2-start
10024: PPUSH
10025: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10029: LD_EXP 37
10033: PPUSH
10034: LD_EXP 36
10038: PPUSH
10039: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
10043: LD_EXP 37
10047: PPUSH
10048: LD_STRING DO-4-start
10050: PPUSH
10051: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
10055: LD_EXP 36
10059: PPUSH
10060: LD_STRING DF-3-start
10062: PPUSH
10063: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
10067: LD_EXP 37
10071: PPUSH
10072: LD_STRING DO-5-start
10074: PPUSH
10075: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
10079: LD_EXP 36
10083: PPUSH
10084: LD_STRING DF-4-start
10086: PPUSH
10087: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10091: LD_EXP 37
10095: PPUSH
10096: LD_EXP 28
10100: PPUSH
10101: CALL_OW 119
// end else
10105: GO 10207
// begin Say ( Omar , DO-2-start-a ) ;
10107: LD_EXP 37
10111: PPUSH
10112: LD_STRING DO-2-start-a
10114: PPUSH
10115: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
10119: LD_EXP 37
10123: PPUSH
10124: LD_STRING DO-3-start-a
10126: PPUSH
10127: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
10131: LD_EXP 28
10135: PPUSH
10136: LD_STRING DH-3-start-a
10138: PPUSH
10139: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
10143: LD_EXP 36
10147: PPUSH
10148: LD_STRING DF-2-start-a
10150: PPUSH
10151: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10155: LD_EXP 37
10159: PPUSH
10160: LD_EXP 36
10164: PPUSH
10165: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
10169: LD_EXP 37
10173: PPUSH
10174: LD_STRING DO-4-start-a
10176: PPUSH
10177: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
10181: LD_EXP 36
10185: PPUSH
10186: LD_STRING DF-3-start-a
10188: PPUSH
10189: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10193: LD_EXP 37
10197: PPUSH
10198: LD_EXP 28
10202: PPUSH
10203: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
10207: LD_INT 10
10209: PPUSH
10210: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
10214: LD_EXP 37
10218: PPUSH
10219: LD_STRING DO-1-mission
10221: PPUSH
10222: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
10226: LD_EXP 37
10230: PPUSH
10231: LD_STRING DO-2-mission
10233: PPUSH
10234: CALL_OW 88
// if not hasAll then
10238: LD_VAR 0 2
10242: NOT
10243: IFFALSE 10257
// Say ( Omar , DO-3-mission ) ;
10245: LD_EXP 37
10249: PPUSH
10250: LD_STRING DO-3-mission
10252: PPUSH
10253: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
10257: LD_EXP 37
10261: PPUSH
10262: LD_STRING DO-4-mission
10264: PPUSH
10265: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
10269: LD_EXP 28
10273: PPUSH
10274: LD_STRING DH-1-mission
10276: PPUSH
10277: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10281: LD_EXP 36
10285: PPUSH
10286: LD_STRING DF-1-mission
10288: PPUSH
10289: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10293: LD_EXP 37
10297: PPUSH
10298: LD_STRING DO-5-mission
10300: PPUSH
10301: CALL_OW 88
// if not hasAll then
10305: LD_VAR 0 2
10309: NOT
10310: IFFALSE 10445
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10312: LD_ADDR_VAR 0 4
10316: PUSH
10317: LD_INT 22
10319: PUSH
10320: LD_INT 2
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PUSH
10327: LD_INT 21
10329: PUSH
10330: LD_INT 1
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PUSH
10337: LD_INT 23
10339: PUSH
10340: LD_INT 2
10342: PUSH
10343: EMPTY
10344: LIST
10345: LIST
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: LIST
10351: PPUSH
10352: CALL_OW 69
10356: ST_TO_ADDR
// for i := 7 downto tmp do
10357: LD_ADDR_VAR 0 3
10361: PUSH
10362: DOUBLE
10363: LD_INT 7
10365: INC
10366: ST_TO_ADDR
10367: LD_VAR 0 4
10371: PUSH
10372: FOR_DOWNTO
10373: IFFALSE 10443
// begin if omarSquad < 3 then
10375: LD_EXP 40
10379: PUSH
10380: LD_INT 3
10382: LESS
10383: IFFALSE 10387
// break ;
10385: GO 10443
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10387: LD_EXP 40
10391: PUSH
10392: LD_INT 3
10394: ARRAY
10395: PPUSH
10396: LD_INT 2
10398: PPUSH
10399: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10403: LD_ADDR_EXP 42
10407: PUSH
10408: LD_EXP 42
10412: PUSH
10413: LD_EXP 40
10417: PUSH
10418: LD_INT 3
10420: ARRAY
10421: UNION
10422: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10423: LD_ADDR_EXP 40
10427: PUSH
10428: LD_EXP 40
10432: PPUSH
10433: LD_INT 3
10435: PPUSH
10436: CALL_OW 3
10440: ST_TO_ADDR
// end ;
10441: GO 10372
10443: POP
10444: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10445: LD_EXP 37
10449: PUSH
10450: LD_EXP 40
10454: ADD
10455: PPUSH
10456: LD_INT 103
10458: PPUSH
10459: LD_INT 9
10461: PPUSH
10462: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10466: LD_VAR 0 2
10470: PUSH
10471: LD_EXP 33
10475: PPUSH
10476: CALL_OW 302
10480: AND
10481: IFFALSE 10542
// begin wait ( 0 0$3 ) ;
10483: LD_INT 105
10485: PPUSH
10486: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10490: LD_EXP 33
10494: PPUSH
10495: LD_EXP 36
10499: PPUSH
10500: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10504: LD_EXP 33
10508: PPUSH
10509: LD_STRING DK-1-side
10511: PPUSH
10512: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10516: LD_EXP 36
10520: PPUSH
10521: LD_EXP 33
10525: PPUSH
10526: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10530: LD_EXP 36
10534: PPUSH
10535: LD_STRING DF-1-side
10537: PPUSH
10538: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10542: LD_INT 22
10544: PUSH
10545: LD_INT 2
10547: PUSH
10548: EMPTY
10549: LIST
10550: LIST
10551: PPUSH
10552: CALL_OW 69
10556: PPUSH
10557: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10561: LD_EXP 36
10565: PUSH
10566: LD_EXP 39
10570: ADD
10571: PPUSH
10572: LD_INT 108
10574: PPUSH
10575: LD_INT 62
10577: PPUSH
10578: CALL_OW 111
// gameStarted := true ;
10582: LD_ADDR_EXP 3
10586: PUSH
10587: LD_INT 1
10589: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10590: LD_INT 105
10592: PPUSH
10593: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10597: LD_EXP 28
10601: PPUSH
10602: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10606: LD_EXP 28
10610: PPUSH
10611: LD_EXP 32
10615: PPUSH
10616: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10620: LD_INT 22
10622: PUSH
10623: LD_INT 2
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: PPUSH
10630: CALL_OW 69
10634: PUSH
10635: LD_EXP 28
10639: DIFF
10640: PPUSH
10641: LD_EXP 28
10645: PPUSH
10646: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10650: LD_EXP 28
10654: PPUSH
10655: LD_STRING DH-1-explore
10657: PPUSH
10658: CALL_OW 88
// if Givi then
10662: LD_EXP 29
10666: IFFALSE 10682
// Say ( Givi , DG-1-explore ) else
10668: LD_EXP 29
10672: PPUSH
10673: LD_STRING DG-1-explore
10675: PPUSH
10676: CALL_OW 88
10680: GO 10719
// if heikeSecondSquad then
10682: LD_EXP 42
10686: IFFALSE 10719
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10688: LD_EXP 42
10692: PPUSH
10693: LD_INT 26
10695: PUSH
10696: LD_INT 1
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PPUSH
10703: CALL_OW 72
10707: PUSH
10708: LD_INT 1
10710: ARRAY
10711: PPUSH
10712: LD_STRING DArm-1-explore
10714: PPUSH
10715: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10719: LD_EXP 32
10723: PPUSH
10724: LD_STRING DA-1-explore
10726: PPUSH
10727: CALL_OW 88
// if Sophia then
10731: LD_EXP 34
10735: IFFALSE 10813
// begin Say ( Sophia , DS-2-explore ) ;
10737: LD_EXP 34
10741: PPUSH
10742: LD_STRING DS-2-explore
10744: PPUSH
10745: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10749: LD_EXP 32
10753: PPUSH
10754: LD_STRING DA-2-explore
10756: PPUSH
10757: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10761: LD_EXP 34
10765: PPUSH
10766: LD_EXP 32
10770: PPUSH
10771: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10775: LD_EXP 32
10779: PPUSH
10780: LD_EXP 34
10784: PPUSH
10785: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10789: LD_EXP 34
10793: PPUSH
10794: LD_STRING DS-3-explore
10796: PPUSH
10797: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10801: LD_EXP 32
10805: PPUSH
10806: LD_STRING DA-3-explore
10808: PPUSH
10809: CALL_OW 88
// end ; if Mike then
10813: LD_EXP 30
10817: IFFALSE 10873
// begin Say ( Mike , DM-1-explore ) ;
10819: LD_EXP 30
10823: PPUSH
10824: LD_STRING DM-1-explore
10826: PPUSH
10827: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10831: LD_EXP 28
10835: PPUSH
10836: LD_STRING DH-2-explore
10838: PPUSH
10839: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10843: LD_EXP 30
10847: PPUSH
10848: LD_STRING DM-2-explore
10850: PPUSH
10851: CALL_OW 88
// if Kaia then
10855: LD_EXP 33
10859: IFFALSE 10873
// Say ( Kaia , DK-1-explore ) ;
10861: LD_EXP 33
10865: PPUSH
10866: LD_STRING DK-1-explore
10868: PPUSH
10869: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10873: LD_INT 22
10875: PUSH
10876: LD_INT 2
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: PPUSH
10883: CALL_OW 69
10887: PPUSH
10888: CALL_OW 139
// Video ( false ) ;
10892: LD_INT 0
10894: PPUSH
10895: CALL 1036 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10899: LD_STRING BuildBase
10901: PPUSH
10902: CALL_OW 337
// SaveForQuickRestart ;
10906: CALL_OW 22
// end ;
10910: LD_VAR 0 1
10914: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10915: LD_EXP 5
10919: NOT
10920: PUSH
10921: LD_EXP 6
10925: NOT
10926: AND
10927: PUSH
10928: LD_INT 5
10930: PPUSH
10931: LD_INT 22
10933: PUSH
10934: LD_INT 2
10936: PUSH
10937: EMPTY
10938: LIST
10939: LIST
10940: PPUSH
10941: CALL_OW 70
10945: AND
10946: PUSH
10947: LD_EXP 6
10951: NOT
10952: AND
10953: IFFALSE 11038
10955: GO 10957
10957: DISABLE
// begin if Mike then
10958: LD_EXP 30
10962: IFFALSE 10978
// Say ( Mike , DM-1-scout ) else
10964: LD_EXP 30
10968: PPUSH
10969: LD_STRING DM-1-scout
10971: PPUSH
10972: CALL_OW 88
10976: GO 11009
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10978: LD_EXP 42
10982: PPUSH
10983: LD_INT 26
10985: PUSH
10986: LD_INT 1
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: PPUSH
10993: CALL_OW 72
10997: PUSH
10998: LD_INT 1
11000: ARRAY
11001: PPUSH
11002: LD_STRING DArm-1-explore
11004: PPUSH
11005: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
11009: LD_INT 54
11011: PPUSH
11012: LD_INT 35
11014: PPUSH
11015: LD_INT 2
11017: PPUSH
11018: LD_INT 1
11020: PPUSH
11021: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
11025: LD_INT 54
11027: PPUSH
11028: LD_INT 35
11030: PPUSH
11031: LD_INT 2
11033: PPUSH
11034: CALL_OW 331
// end ;
11038: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
11039: LD_INT 6
11041: PPUSH
11042: LD_INT 22
11044: PUSH
11045: LD_INT 2
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: PPUSH
11052: CALL_OW 70
11056: PUSH
11057: LD_EXP 6
11061: NOT
11062: AND
11063: IFFALSE 11317
11065: GO 11067
11067: DISABLE
11068: LD_INT 0
11070: PPUSH
11071: PPUSH
11072: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11073: LD_ADDR_VAR 0 1
11077: PUSH
11078: LD_EXP 42
11082: PPUSH
11083: LD_INT 26
11085: PUSH
11086: LD_INT 1
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: PPUSH
11093: CALL_OW 72
11097: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
11098: LD_ADDR_VAR 0 2
11102: PUSH
11103: LD_EXP 42
11107: PPUSH
11108: LD_INT 26
11110: PUSH
11111: LD_INT 2
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PPUSH
11118: CALL_OW 72
11122: ST_TO_ADDR
// DialogueOn ;
11123: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
11127: LD_INT 36
11129: PPUSH
11130: LD_INT 22
11132: PPUSH
11133: LD_INT 2
11135: PPUSH
11136: LD_INT 8
11138: PPUSH
11139: CALL_OW 330
// dwait ( 0 0$1 ) ;
11143: LD_INT 35
11145: PPUSH
11146: CALL_OW 68
// speakerOk := false ;
11150: LD_ADDR_VAR 0 3
11154: PUSH
11155: LD_INT 0
11157: ST_TO_ADDR
// if Mike then
11158: LD_EXP 30
11162: IFFALSE 11184
// speakerOk := Say ( Mike , DM-1-spot ) else
11164: LD_ADDR_VAR 0 3
11168: PUSH
11169: LD_EXP 30
11173: PPUSH
11174: LD_STRING DM-1-spot
11176: PPUSH
11177: CALL_OW 88
11181: ST_TO_ADDR
11182: GO 11212
// if randomMen then
11184: LD_VAR 0 1
11188: IFFALSE 11212
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11190: LD_ADDR_VAR 0 3
11194: PUSH
11195: LD_VAR 0 1
11199: PUSH
11200: LD_INT 1
11202: ARRAY
11203: PPUSH
11204: LD_STRING DArm-1-spot-a
11206: PPUSH
11207: CALL_OW 88
11211: ST_TO_ADDR
// if speakerOk then
11212: LD_VAR 0 3
11216: IFFALSE 11260
// begin if Givi then
11218: LD_EXP 29
11222: IFFALSE 11238
// Say ( Givi , DG-1-spot ) else
11224: LD_EXP 29
11228: PPUSH
11229: LD_STRING DG-1-spot
11231: PPUSH
11232: CALL_OW 88
11236: GO 11260
// if randomWomen then
11238: LD_VAR 0 2
11242: IFFALSE 11260
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
11244: LD_VAR 0 2
11248: PUSH
11249: LD_INT 1
11251: ARRAY
11252: PPUSH
11253: LD_STRING DArf-1-spot-a
11255: PPUSH
11256: CALL_OW 88
// end ; if Mike then
11260: LD_EXP 30
11264: IFFALSE 11280
// Say ( Heike , DH-1-spot ) else
11266: LD_EXP 28
11270: PPUSH
11271: LD_STRING DH-1-spot
11273: PPUSH
11274: CALL_OW 88
11278: GO 11292
// Say ( Heike , DH-1-spot-a ) ;
11280: LD_EXP 28
11284: PPUSH
11285: LD_STRING DH-1-spot-a
11287: PPUSH
11288: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11292: LD_INT 36
11294: PPUSH
11295: LD_INT 22
11297: PPUSH
11298: LD_INT 2
11300: PPUSH
11301: CALL_OW 331
// DialogueOff ;
11305: CALL_OW 7
// americanBaseSpoted := true ;
11309: LD_ADDR_EXP 5
11313: PUSH
11314: LD_INT 1
11316: ST_TO_ADDR
// end ;
11317: PPOPN 3
11319: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11320: LD_EXP 5
11324: NOT
11325: PUSH
11326: LD_INT 22
11328: PUSH
11329: LD_INT 2
11331: PUSH
11332: EMPTY
11333: LIST
11334: LIST
11335: PUSH
11336: LD_INT 101
11338: PUSH
11339: LD_INT 1
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PPUSH
11350: CALL_OW 69
11354: AND
11355: PUSH
11356: LD_EXP 6
11360: NOT
11361: AND
11362: IFFALSE 11448
11364: GO 11366
11366: DISABLE
11367: LD_INT 0
11369: PPUSH
// begin americanBaseSpoted := true ;
11370: LD_ADDR_EXP 5
11374: PUSH
11375: LD_INT 1
11377: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11378: LD_ADDR_VAR 0 1
11382: PUSH
11383: LD_EXP 42
11387: PPUSH
11388: LD_INT 26
11390: PUSH
11391: LD_INT 1
11393: PUSH
11394: EMPTY
11395: LIST
11396: LIST
11397: PPUSH
11398: CALL_OW 72
11402: ST_TO_ADDR
// if not randomMen then
11403: LD_VAR 0 1
11407: NOT
11408: IFFALSE 11412
// exit ;
11410: GO 11448
// DialogueOn ;
11412: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11416: LD_VAR 0 1
11420: PUSH
11421: LD_INT 1
11423: ARRAY
11424: PPUSH
11425: LD_STRING DArm-1-spot-a
11427: PPUSH
11428: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11432: LD_EXP 28
11436: PPUSH
11437: LD_STRING DH-1-spot-a
11439: PPUSH
11440: CALL_OW 88
// DialogueOff ;
11444: CALL_OW 7
// end ;
11448: PPOPN 1
11450: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or usForces <= 4 do var i , p ;
11451: LD_INT 11
11453: PPUSH
11454: CALL_OW 255
11458: PUSH
11459: LD_INT 2
11461: EQUAL
11462: PUSH
11463: LD_INT 7
11465: PPUSH
11466: LD_INT 22
11468: PUSH
11469: LD_INT 1
11471: PUSH
11472: EMPTY
11473: LIST
11474: LIST
11475: PUSH
11476: LD_INT 3
11478: PUSH
11479: LD_INT 50
11481: PUSH
11482: EMPTY
11483: LIST
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: PUSH
11489: LD_INT 30
11491: PUSH
11492: LD_INT 31
11494: PUSH
11495: EMPTY
11496: LIST
11497: LIST
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: LIST
11503: PPUSH
11504: CALL_OW 70
11508: OR
11509: PUSH
11510: LD_INT 7
11512: PPUSH
11513: LD_INT 22
11515: PUSH
11516: LD_INT 2
11518: PUSH
11519: EMPTY
11520: LIST
11521: LIST
11522: PPUSH
11523: CALL_OW 70
11527: PUSH
11528: LD_INT 1
11530: GREATER
11531: OR
11532: PUSH
11533: LD_EXP 44
11537: PUSH
11538: LD_INT 4
11540: LESSEQUAL
11541: OR
11542: IFFALSE 12068
11544: GO 11546
11546: DISABLE
11547: LD_INT 0
11549: PPUSH
11550: PPUSH
// begin wait ( 0 0$3 ) ;
11551: LD_INT 105
11553: PPUSH
11554: CALL_OW 67
// americanStartRun := true ;
11558: LD_ADDR_EXP 14
11562: PUSH
11563: LD_INT 1
11565: ST_TO_ADDR
// if IsOk ( usCommander ) then
11566: LD_EXP 45
11570: PPUSH
11571: CALL_OW 302
11575: IFFALSE 11605
// begin usForces := usForces union usCommander ;
11577: LD_ADDR_EXP 44
11581: PUSH
11582: LD_EXP 44
11586: PUSH
11587: LD_EXP 45
11591: UNION
11592: ST_TO_ADDR
// Say ( usCommander , DUsm-1-assault ) ;
11593: LD_EXP 45
11597: PPUSH
11598: LD_STRING DUsm-1-assault
11600: PPUSH
11601: CALL_OW 88
// end ; for i in usForces do
11605: LD_ADDR_VAR 0 1
11609: PUSH
11610: LD_EXP 44
11614: PUSH
11615: FOR_IN
11616: IFFALSE 11662
// begin if IsInUnit ( i ) then
11618: LD_VAR 0 1
11622: PPUSH
11623: CALL_OW 310
11627: IFFALSE 11638
// ComExitBuilding ( i ) ;
11629: LD_VAR 0 1
11633: PPUSH
11634: CALL_OW 122
// wait ( 3 ) ;
11638: LD_INT 3
11640: PPUSH
11641: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11645: LD_VAR 0 1
11649: PPUSH
11650: LD_INT 34
11652: PPUSH
11653: LD_INT 67
11655: PPUSH
11656: CALL_OW 111
// end ;
11660: GO 11615
11662: POP
11663: POP
// Say ( Heike , DH-1-assault ) ;
11664: LD_EXP 28
11668: PPUSH
11669: LD_STRING DH-1-assault
11671: PPUSH
11672: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11676: LD_INT 35
11678: PPUSH
11679: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11683: LD_VAR 0 1
11687: PPUSH
11688: LD_INT 34
11690: PPUSH
11691: LD_INT 67
11693: PPUSH
11694: CALL_OW 111
// until not usForces ;
11698: LD_EXP 44
11702: NOT
11703: IFFALSE 11676
// music_nat := 2 ;
11705: LD_ADDR_OWVAR 71
11709: PUSH
11710: LD_INT 2
11712: ST_TO_ADDR
// music_class := music_victory ;
11713: LD_ADDR_OWVAR 72
11717: PUSH
11718: LD_INT 4
11720: ST_TO_ADDR
// if not americanHasEscaped then
11721: LD_EXP 8
11725: NOT
11726: IFFALSE 11747
// begin Say ( Heike , DH-2-assault ) ;
11728: LD_EXP 28
11732: PPUSH
11733: LD_STRING DH-2-assault
11735: PPUSH
11736: CALL_OW 88
// SetAchievement ( ACH_CLEAN ) ;
11740: LD_STRING ACH_CLEAN
11742: PPUSH
11743: CALL_OW 543
// end ; wait ( 0 0$2 ) ;
11747: LD_INT 70
11749: PPUSH
11750: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11754: LD_INT 35
11756: PPUSH
11757: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11761: LD_INT 22
11763: PUSH
11764: LD_INT 2
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: PUSH
11771: LD_INT 21
11773: PUSH
11774: LD_INT 1
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: PUSH
11781: LD_INT 3
11783: PUSH
11784: LD_INT 50
11786: PUSH
11787: EMPTY
11788: LIST
11789: PUSH
11790: EMPTY
11791: LIST
11792: LIST
11793: PUSH
11794: EMPTY
11795: LIST
11796: LIST
11797: LIST
11798: PPUSH
11799: CALL_OW 69
11803: NOT
11804: IFFALSE 11754
// InGameOn ;
11806: CALL_OW 8
// if not GetSide ( usDepot ) = 2 then
11810: LD_INT 11
11812: PPUSH
11813: CALL_OW 255
11817: PUSH
11818: LD_INT 2
11820: EQUAL
11821: NOT
11822: IFFALSE 11834
// SetSide ( usDepot , 2 ) ;
11824: LD_INT 11
11826: PPUSH
11827: LD_INT 2
11829: PPUSH
11830: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11834: LD_INT 35
11836: PPUSH
11837: LD_INT 22
11839: PPUSH
11840: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11844: LD_EXP 28
11848: PPUSH
11849: LD_INT 35
11851: PPUSH
11852: LD_INT 22
11854: PPUSH
11855: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11859: LD_EXP 28
11863: PPUSH
11864: LD_INT 38
11866: PPUSH
11867: LD_INT 25
11869: PPUSH
11870: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11874: LD_EXP 41
11878: PUSH
11879: LD_EXP 42
11883: UNION
11884: PPUSH
11885: LD_INT 39
11887: PPUSH
11888: LD_INT 26
11890: PPUSH
11891: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11895: LD_EXP 41
11899: PUSH
11900: LD_EXP 42
11904: UNION
11905: PPUSH
11906: LD_EXP 28
11910: PPUSH
11911: CALL_OW 179
// p := 0 ;
11915: LD_ADDR_VAR 0 2
11919: PUSH
11920: LD_INT 0
11922: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11923: LD_INT 35
11925: PPUSH
11926: CALL_OW 67
// p := p + 1 ;
11930: LD_ADDR_VAR 0 2
11934: PUSH
11935: LD_VAR 0 2
11939: PUSH
11940: LD_INT 1
11942: PLUS
11943: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11944: LD_EXP 28
11948: PPUSH
11949: CALL_OW 314
11953: NOT
11954: PUSH
11955: LD_VAR 0 2
11959: PUSH
11960: LD_INT 10
11962: GREATER
11963: OR
11964: IFFALSE 11923
// Say ( Heike , DH-1-capture ) ;
11966: LD_EXP 28
11970: PPUSH
11971: LD_STRING DH-1-capture
11973: PPUSH
11974: CALL_OW 88
// if Markov then
11978: LD_EXP 35
11982: IFFALSE 11996
// Say ( Markov , DMar-1-capture ) ;
11984: LD_EXP 35
11988: PPUSH
11989: LD_STRING DMar-1-capture
11991: PPUSH
11992: CALL_OW 88
// if Sophia then
11996: LD_EXP 34
12000: IFFALSE 12026
// begin Say ( Heike , DH-2-capture ) ;
12002: LD_EXP 28
12006: PPUSH
12007: LD_STRING DH-2-capture
12009: PPUSH
12010: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
12014: LD_EXP 34
12018: PPUSH
12019: LD_STRING DS-1-capture
12021: PPUSH
12022: CALL_OW 88
// end ; InGameOff ;
12026: CALL_OW 9
// music_nat := music_auto ;
12030: LD_ADDR_OWVAR 71
12034: PUSH
12035: LD_INT 0
12037: ST_TO_ADDR
// music_class := music_auto ;
12038: LD_ADDR_OWVAR 72
12042: PUSH
12043: LD_INT 0
12045: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
12046: LD_STRING ConstructBase
12048: PPUSH
12049: CALL_OW 337
// wait ( 0 0$3 ) ;
12053: LD_INT 105
12055: PPUSH
12056: CALL_OW 67
// americanBaseCaptured := true ;
12060: LD_ADDR_EXP 6
12064: PUSH
12065: LD_INT 1
12067: ST_TO_ADDR
// end ;
12068: PPOPN 2
12070: END
// every 0 0$1 trigger capturedCargoCounter >= 3 do
12071: LD_EXP 13
12075: PUSH
12076: LD_INT 3
12078: GREATEREQUAL
12079: IFFALSE 12091
12081: GO 12083
12083: DISABLE
// SetAchievement ( ACH_ENG ) ;
12084: LD_STRING ACH_ENG
12086: PPUSH
12087: CALL_OW 543
12091: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) >= 4 do
12092: LD_INT 22
12094: PUSH
12095: LD_INT 2
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PUSH
12102: LD_INT 25
12104: PUSH
12105: LD_INT 15
12107: PUSH
12108: EMPTY
12109: LIST
12110: LIST
12111: PUSH
12112: EMPTY
12113: LIST
12114: LIST
12115: PPUSH
12116: CALL_OW 69
12120: PUSH
12121: LD_INT 4
12123: GREATEREQUAL
12124: IFFALSE 12136
12126: GO 12128
12128: DISABLE
// SetAchievement ( ACH_APEGEN ) ;
12129: LD_STRING ACH_APEGEN
12131: PPUSH
12132: CALL_OW 543
12136: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
12137: LD_INT 22
12139: PUSH
12140: LD_INT 2
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 30
12149: PUSH
12150: LD_INT 2
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: LD_INT 3
12159: PUSH
12160: LD_INT 57
12162: PUSH
12163: EMPTY
12164: LIST
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: LIST
12174: PPUSH
12175: CALL_OW 69
12179: IFFALSE 12422
12181: GO 12183
12183: DISABLE
// begin workshopBuilded := true ;
12184: LD_ADDR_EXP 10
12188: PUSH
12189: LD_INT 1
12191: ST_TO_ADDR
// if IsOk ( Markov ) then
12192: LD_EXP 35
12196: PPUSH
12197: CALL_OW 302
12201: IFFALSE 12260
// begin Say ( Heike , DH-1-shop-a ) ;
12203: LD_EXP 28
12207: PPUSH
12208: LD_STRING DH-1-shop-a
12210: PPUSH
12211: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
12215: LD_INT 47
12217: PPUSH
12218: LD_INT 2
12220: PPUSH
12221: CALL_OW 321
12225: PUSH
12226: LD_INT 2
12228: EQUAL
12229: PUSH
12230: LD_INT 45
12232: PPUSH
12233: LD_INT 2
12235: PPUSH
12236: CALL_OW 321
12240: PUSH
12241: LD_INT 2
12243: EQUAL
12244: AND
12245: NOT
12246: IFFALSE 12260
// Say ( Markov , DMar-1-shop-a ) ;
12248: LD_EXP 35
12252: PPUSH
12253: LD_STRING DMar-1-shop-a
12255: PPUSH
12256: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
12260: LD_INT 35
12262: PPUSH
12263: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched or GetTech ( tech_SolEng , 2 ) = state_researched ;
12267: LD_INT 47
12269: PPUSH
12270: LD_INT 2
12272: PPUSH
12273: CALL_OW 321
12277: PUSH
12278: LD_INT 2
12280: EQUAL
12281: PUSH
12282: LD_INT 45
12284: PPUSH
12285: LD_INT 2
12287: PPUSH
12288: CALL_OW 321
12292: PUSH
12293: LD_INT 2
12295: EQUAL
12296: OR
12297: IFFALSE 12260
// DialogueOn ;
12299: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
12303: LD_EXP 35
12307: PPUSH
12308: LD_STRING DMar-1-shop
12310: PPUSH
12311: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
12315: LD_EXP 28
12319: PPUSH
12320: LD_STRING DH-1-shop
12322: PPUSH
12323: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12327: LD_EXP 35
12331: PPUSH
12332: LD_STRING DMar-2-shop
12334: PPUSH
12335: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12339: LD_EXP 35
12343: PPUSH
12344: LD_STRING DMar-3-shop
12346: PPUSH
12347: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12351: LD_EXP 28
12355: PPUSH
12356: LD_STRING DH-2-shop
12358: PPUSH
12359: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12363: LD_EXP 35
12367: PPUSH
12368: LD_STRING DMar-4-shop
12370: PPUSH
12371: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12375: LD_EXP 28
12379: PPUSH
12380: LD_STRING DH-3-shop
12382: PPUSH
12383: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12387: LD_EXP 35
12391: PPUSH
12392: LD_STRING DMar-5-shop
12394: PPUSH
12395: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12399: LD_EXP 28
12403: PPUSH
12404: LD_STRING DH-4-shop
12406: PPUSH
12407: CALL_OW 88
// DialogueOff ;
12411: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12415: LD_STRING ConstructVeh
12417: PPUSH
12418: CALL_OW 337
// end ;
12422: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12423: LD_INT 2
12425: PPUSH
12426: LD_INT 2
12428: PPUSH
12429: LD_INT 1
12431: PPUSH
12432: CALL 1207 0 3
12436: PUSH
12437: LD_INT 0
12439: EQUAL
12440: IFFALSE 12452
12442: GO 12444
12444: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12445: LD_STRING Techs
12447: PPUSH
12448: CALL_OW 337
12452: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12453: LD_EXP 35
12457: PPUSH
12458: CALL_OW 302
12462: PUSH
12463: LD_INT 22
12465: PUSH
12466: LD_INT 2
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: PUSH
12473: LD_INT 2
12475: PUSH
12476: LD_INT 34
12478: PUSH
12479: LD_INT 22
12481: PUSH
12482: EMPTY
12483: LIST
12484: LIST
12485: PUSH
12486: LD_INT 35
12488: PUSH
12489: LD_INT 22
12491: PUSH
12492: EMPTY
12493: LIST
12494: LIST
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: LIST
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: PPUSH
12505: CALL_OW 69
12509: AND
12510: IFFALSE 12617
12512: GO 12514
12514: DISABLE
// begin DialogueOn ;
12515: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12519: LD_INT 22
12521: PUSH
12522: LD_INT 2
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: PUSH
12529: LD_INT 2
12531: PUSH
12532: LD_INT 34
12534: PUSH
12535: LD_INT 22
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PUSH
12542: LD_INT 35
12544: PUSH
12545: LD_INT 22
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: LIST
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PPUSH
12561: CALL_OW 69
12565: PPUSH
12566: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12570: LD_INT 10
12572: PPUSH
12573: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12577: LD_EXP 28
12581: PPUSH
12582: LD_STRING DH-1-bal
12584: PPUSH
12585: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12589: LD_EXP 35
12593: PPUSH
12594: LD_STRING DMar-1-bal
12596: PPUSH
12597: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12601: LD_EXP 28
12605: PPUSH
12606: LD_STRING DH-2-bal
12608: PPUSH
12609: CALL_OW 88
// DialogueOff ;
12613: CALL_OW 7
// end ;
12617: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12618: LD_EXP 32
12622: PPUSH
12623: CALL_OW 302
12627: PUSH
12628: LD_INT 22
12630: PUSH
12631: LD_INT 2
12633: PUSH
12634: EMPTY
12635: LIST
12636: LIST
12637: PUSH
12638: LD_INT 30
12640: PUSH
12641: LD_INT 6
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PPUSH
12652: CALL_OW 69
12656: AND
12657: IFFALSE 12718
12659: GO 12661
12661: DISABLE
// begin DialogueOn ;
12662: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12666: LD_EXP 32
12670: PPUSH
12671: LD_STRING DA-1-lab
12673: PPUSH
12674: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12678: LD_EXP 28
12682: PPUSH
12683: LD_STRING DH-1-lab
12685: PPUSH
12686: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12690: LD_EXP 32
12694: PPUSH
12695: LD_STRING DA-2-lab
12697: PPUSH
12698: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12702: LD_EXP 28
12706: PPUSH
12707: LD_STRING DH-2-lab
12709: PPUSH
12710: CALL_OW 88
// DialogueOff ;
12714: CALL_OW 7
// end ;
12718: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12719: LD_EXP 33
12723: PPUSH
12724: CALL_OW 302
12728: PUSH
12729: LD_INT 22
12731: PUSH
12732: LD_INT 2
12734: PUSH
12735: EMPTY
12736: LIST
12737: LIST
12738: PUSH
12739: LD_INT 25
12741: PUSH
12742: LD_INT 15
12744: PUSH
12745: EMPTY
12746: LIST
12747: LIST
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PPUSH
12753: CALL_OW 69
12757: AND
12758: PUSH
12759: LD_INT 81
12761: PUSH
12762: LD_INT 2
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 69
12773: NOT
12774: AND
12775: IFFALSE 12957
12777: GO 12779
12779: DISABLE
12780: LD_INT 0
12782: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12783: LD_ADDR_VAR 0 1
12787: PUSH
12788: LD_INT 22
12790: PUSH
12791: LD_INT 2
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: PUSH
12798: LD_INT 25
12800: PUSH
12801: LD_INT 15
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: EMPTY
12809: LIST
12810: LIST
12811: PPUSH
12812: CALL_OW 69
12816: ST_TO_ADDR
// InGameOn ;
12817: CALL_OW 8
// CenterNowOnUnits ( ape [ 1 ] ) ;
12821: LD_VAR 0 1
12825: PUSH
12826: LD_INT 1
12828: ARRAY
12829: PPUSH
12830: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12834: LD_VAR 0 1
12838: PUSH
12839: LD_INT 1
12841: ARRAY
12842: PPUSH
12843: CALL_OW 122
// Say ( Kaia , DK-1-apesol ) ;
12847: LD_EXP 33
12851: PPUSH
12852: LD_STRING DK-1-apesol
12854: PPUSH
12855: CALL_OW 88
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12859: LD_VAR 0 1
12863: PUSH
12864: LD_INT 1
12866: ARRAY
12867: PPUSH
12868: LD_INT 35
12870: PPUSH
12871: LD_INT 28
12873: PPUSH
12874: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12878: LD_VAR 0 1
12882: PUSH
12883: LD_INT 1
12885: ARRAY
12886: PPUSH
12887: LD_INT 36
12889: PPUSH
12890: LD_INT 17
12892: PPUSH
12893: CALL_OW 171
// DialogueOn ;
12897: CALL_OW 6
// Say ( Aviradze , DA-1-apesol ) ;
12901: LD_EXP 32
12905: PPUSH
12906: LD_STRING DA-1-apesol
12908: PPUSH
12909: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12913: LD_EXP 33
12917: PPUSH
12918: LD_STRING DK-2-apesol
12920: PPUSH
12921: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12925: LD_EXP 32
12929: PPUSH
12930: LD_STRING DA-2-apesol
12932: PPUSH
12933: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12937: LD_EXP 33
12941: PPUSH
12942: LD_STRING DK-3-apesol
12944: PPUSH
12945: CALL_OW 88
// DialogueOff ;
12949: CALL_OW 7
// InGameOff ;
12953: CALL_OW 9
// end ;
12957: PPOPN 1
12959: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12960: LD_EXP 34
12964: PPUSH
12965: CALL_OW 302
12969: PUSH
12970: LD_INT 22
12972: PUSH
12973: LD_INT 2
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PUSH
12980: LD_INT 25
12982: PUSH
12983: LD_INT 16
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PPUSH
12994: CALL_OW 69
12998: AND
12999: PUSH
13000: LD_INT 81
13002: PUSH
13003: LD_INT 2
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: PPUSH
13010: CALL_OW 69
13014: NOT
13015: AND
13016: IFFALSE 13279
13018: GO 13020
13020: DISABLE
13021: LD_INT 0
13023: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
13024: LD_ADDR_VAR 0 1
13028: PUSH
13029: LD_INT 22
13031: PUSH
13032: LD_INT 2
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PUSH
13039: LD_INT 25
13041: PUSH
13042: LD_INT 16
13044: PUSH
13045: EMPTY
13046: LIST
13047: LIST
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PPUSH
13053: CALL_OW 69
13057: ST_TO_ADDR
// InGameOn ;
13058: CALL_OW 8
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
13062: LD_INT 5
13064: PPUSH
13065: LD_INT 35
13067: PPUSH
13068: LD_INT 22
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
13078: LD_EXP 34
13082: PPUSH
13083: LD_VAR 0 1
13087: PUSH
13088: LD_INT 1
13090: ARRAY
13091: PPUSH
13092: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
13096: LD_VAR 0 1
13100: PUSH
13101: LD_INT 1
13103: ARRAY
13104: PPUSH
13105: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
13109: LD_VAR 0 1
13113: PUSH
13114: LD_INT 1
13116: ARRAY
13117: PPUSH
13118: CALL_OW 122
// wait ( 0 0$2 ) ;
13122: LD_INT 70
13124: PPUSH
13125: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
13129: LD_EXP 34
13133: PPUSH
13134: LD_STRING DS-1-apeeng
13136: PPUSH
13137: CALL_OW 88
// if IsOk ( Kamil ) then
13141: LD_EXP 31
13145: PPUSH
13146: CALL_OW 302
13150: IFFALSE 13275
// begin Say ( Kamil , DKam-1-apeeng ) ;
13152: LD_EXP 31
13156: PPUSH
13157: LD_STRING DKam-1-apeeng
13159: PPUSH
13160: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
13164: LD_EXP 34
13168: PPUSH
13169: LD_STRING DS-2-apeeng
13171: PPUSH
13172: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
13176: LD_EXP 31
13180: PPUSH
13181: LD_STRING DKam-2-apeeng
13183: PPUSH
13184: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
13188: LD_EXP 34
13192: PPUSH
13193: LD_STRING DS-3-apeeng
13195: PPUSH
13196: CALL_OW 88
// if not IsOK ( Kaia ) then
13200: LD_EXP 33
13204: PPUSH
13205: CALL_OW 302
13209: NOT
13210: IFFALSE 13218
// begin InGameOff ;
13212: CALL_OW 9
// exit ;
13216: GO 13279
// end ; Say ( Kaia , DK-1-apeeng ) ;
13218: LD_EXP 33
13222: PPUSH
13223: LD_STRING DK-1-apeeng
13225: PPUSH
13226: CALL_OW 88
// if not IsOk ( Givi ) then
13230: LD_EXP 29
13234: PPUSH
13235: CALL_OW 302
13239: NOT
13240: IFFALSE 13251
// begin Video ( false ) ;
13242: LD_INT 0
13244: PPUSH
13245: CALL 1036 0 1
// exit ;
13249: GO 13279
// end ; Say ( Givi , DG-1-apeeng ) ;
13251: LD_EXP 29
13255: PPUSH
13256: LD_STRING DG-1-apeeng
13258: PPUSH
13259: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
13263: LD_EXP 33
13267: PPUSH
13268: LD_STRING DK-2-apeeng
13270: PPUSH
13271: CALL_OW 88
// end ; InGameOff ;
13275: CALL_OW 9
// end ;
13279: PPOPN 1
13281: END
// every 0 0$10 trigger farmerBaseReady and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) do
13282: LD_EXP 4
13286: PUSH
13287: LD_INT 22
13289: PUSH
13290: LD_INT 2
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 30
13299: PUSH
13300: LD_INT 0
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: PUSH
13307: EMPTY
13308: LIST
13309: LIST
13310: PPUSH
13311: CALL_OW 69
13315: AND
13316: IFFALSE 13481
13318: GO 13320
13320: DISABLE
// begin wait ( 0 0$10 ) ;
13321: LD_INT 350
13323: PPUSH
13324: CALL_OW 67
// DialogueOn ;
13328: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
13332: LD_EXP 36
13336: PPUSH
13337: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
13341: LD_EXP 36
13345: PPUSH
13346: LD_STRING DF-1-distribution
13348: PPUSH
13349: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
13353: LD_EXP 28
13357: PPUSH
13358: LD_STRING DH-2-distribution
13360: PPUSH
13361: CALL_OW 88
// if IsOk ( Kaia ) then
13365: LD_EXP 33
13369: PPUSH
13370: CALL_OW 302
13374: IFFALSE 13435
// begin Say ( Kaia , DK-1-distribution ) ;
13376: LD_EXP 33
13380: PPUSH
13381: LD_STRING DK-1-distribution
13383: PPUSH
13384: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13388: LD_EXP 28
13392: PPUSH
13393: LD_STRING DH-1-distribution
13395: PPUSH
13396: CALL_OW 88
// if IsOk ( Givi ) then
13400: LD_EXP 29
13404: PPUSH
13405: CALL_OW 302
13409: IFFALSE 13435
// begin Say ( Givi , DG-1-distribution ) ;
13411: LD_EXP 29
13415: PPUSH
13416: LD_STRING DG-1-distribution
13418: PPUSH
13419: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13423: LD_EXP 28
13427: PPUSH
13428: LD_STRING DH-3-distribution
13430: PPUSH
13431: CALL_OW 88
// end ; end ; DialogueOff ;
13435: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13439: LD_STRING Crates1
13441: PPUSH
13442: CALL_OW 337
// farmerRequestedCrates := 300 ;
13446: LD_ADDR_EXP 16
13450: PUSH
13451: LD_INT 300
13453: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13454: LD_STRING FarmerCrates
13456: PPUSH
13457: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13461: LD_INT 10
13463: PPUSH
13464: LD_INT 1
13466: PPUSH
13467: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13471: LD_INT 108
13473: PPUSH
13474: LD_INT 61
13476: PPUSH
13477: CALL_OW 86
// end ;
13481: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13482: LD_EXP 6
13486: PUSH
13487: LD_INT 22
13489: PUSH
13490: LD_INT 2
13492: PUSH
13493: EMPTY
13494: LIST
13495: LIST
13496: PUSH
13497: LD_INT 3
13499: PUSH
13500: LD_INT 57
13502: PUSH
13503: EMPTY
13504: LIST
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: PUSH
13510: LD_INT 2
13512: PUSH
13513: LD_INT 30
13515: PUSH
13516: LD_INT 6
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PUSH
13523: LD_INT 30
13525: PUSH
13526: LD_INT 7
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: PUSH
13533: EMPTY
13534: LIST
13535: LIST
13536: LIST
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: LIST
13542: PPUSH
13543: CALL_OW 69
13547: AND
13548: PUSH
13549: LD_INT 22
13551: PUSH
13552: LD_INT 2
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: LD_INT 3
13561: PUSH
13562: LD_INT 57
13564: PUSH
13565: EMPTY
13566: LIST
13567: PUSH
13568: EMPTY
13569: LIST
13570: LIST
13571: PUSH
13572: LD_INT 30
13574: PUSH
13575: LD_INT 4
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: LIST
13586: PPUSH
13587: CALL_OW 69
13591: AND
13592: IFFALSE 13756
13594: GO 13596
13596: DISABLE
13597: LD_INT 0
13599: PPUSH
// begin wait ( 0 0$10 ) ;
13600: LD_INT 350
13602: PPUSH
13603: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13607: LD_ADDR_VAR 0 1
13611: PUSH
13612: LD_EXP 42
13616: PPUSH
13617: LD_INT 26
13619: PUSH
13620: LD_INT 1
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PUSH
13627: LD_INT 25
13629: PUSH
13630: LD_INT 2
13632: PUSH
13633: EMPTY
13634: LIST
13635: LIST
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PPUSH
13641: CALL_OW 72
13645: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13646: LD_EXP 28
13650: PPUSH
13651: LD_STRING DH-1-task
13653: PPUSH
13654: CALL_OW 88
// if IsOk ( Sophia ) then
13658: LD_EXP 34
13662: PPUSH
13663: CALL_OW 302
13667: IFFALSE 13707
// begin Say ( Sophia , DS-1-task ) ;
13669: LD_EXP 34
13673: PPUSH
13674: LD_STRING DS-1-task
13676: PPUSH
13677: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13681: LD_EXP 34
13685: PPUSH
13686: LD_STRING DS-2-task
13688: PPUSH
13689: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13693: LD_EXP 28
13697: PPUSH
13698: LD_STRING DH-2-task
13700: PPUSH
13701: CALL_OW 88
// end else
13705: GO 13741
// if eng then
13707: LD_VAR 0 1
13711: IFFALSE 13741
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13713: LD_VAR 0 1
13717: PUSH
13718: LD_INT 1
13720: ARRAY
13721: PPUSH
13722: LD_STRING DArm-1-task
13724: PPUSH
13725: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13729: LD_EXP 28
13733: PPUSH
13734: LD_STRING DH-2-task
13736: PPUSH
13737: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13741: LD_STRING BaseConstructed
13743: PPUSH
13744: CALL_OW 337
// allowConvoys := true ;
13748: LD_ADDR_EXP 12
13752: PUSH
13753: LD_INT 1
13755: ST_TO_ADDR
// end ;
13756: PPOPN 1
13758: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13759: LD_INT 22
13761: PUSH
13762: LD_INT 4
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: PUSH
13769: LD_INT 34
13771: PUSH
13772: LD_INT 12
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: PPUSH
13783: CALL_OW 69
13787: IFFALSE 13955
13789: GO 13791
13791: DISABLE
13792: LD_INT 0
13794: PPUSH
13795: PPUSH
13796: PPUSH
// begin wait ( 0 0$2 ) ;
13797: LD_INT 70
13799: PPUSH
13800: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13804: LD_ADDR_VAR 0 1
13808: PUSH
13809: LD_INT 22
13811: PUSH
13812: LD_INT 4
13814: PUSH
13815: EMPTY
13816: LIST
13817: LIST
13818: PUSH
13819: LD_INT 34
13821: PUSH
13822: LD_INT 12
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: PPUSH
13833: CALL_OW 69
13837: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13838: LD_ADDR_VAR 0 2
13842: PUSH
13843: LD_VAR 0 1
13847: PUSH
13848: LD_INT 1
13850: ARRAY
13851: PPUSH
13852: CALL_OW 250
13856: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13857: LD_ADDR_VAR 0 3
13861: PUSH
13862: LD_VAR 0 1
13866: PUSH
13867: LD_INT 1
13869: ARRAY
13870: PPUSH
13871: CALL_OW 251
13875: ST_TO_ADDR
// DialogueOn ;
13876: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13880: LD_VAR 0 2
13884: PPUSH
13885: LD_VAR 0 3
13889: PPUSH
13890: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13894: LD_VAR 0 2
13898: PPUSH
13899: LD_VAR 0 3
13903: PPUSH
13904: LD_INT 2
13906: PPUSH
13907: LD_INT 6
13909: NEG
13910: PPUSH
13911: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13915: LD_INT 10
13917: PPUSH
13918: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13922: LD_EXP 28
13926: PPUSH
13927: LD_STRING DH-1-seecargo
13929: PPUSH
13930: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13934: LD_VAR 0 2
13938: PPUSH
13939: LD_VAR 0 3
13943: PPUSH
13944: LD_INT 2
13946: PPUSH
13947: CALL_OW 331
// DialogueOff ;
13951: CALL_OW 7
// end ;
13955: PPOPN 3
13957: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13958: LD_EXP 4
13962: PUSH
13963: LD_EXP 15
13967: PUSH
13968: LD_INT 300
13970: GREATEREQUAL
13971: AND
13972: IFFALSE 14044
13974: GO 13976
13976: DISABLE
// begin DialogueOn ;
13977: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13981: LD_EXP 36
13985: PPUSH
13986: LD_STRING DF-1-delivery-2
13988: PPUSH
13989: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13993: LD_EXP 28
13997: PPUSH
13998: LD_STRING DH-1-delivery-2
14000: PPUSH
14001: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
14005: LD_EXP 36
14009: PPUSH
14010: LD_STRING DF-2-delivery-2
14012: PPUSH
14013: CALL_OW 94
// DialogueOff ;
14017: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
14021: LD_STRING Crates2
14023: PPUSH
14024: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14028: LD_ADDR_EXP 17
14032: PUSH
14033: LD_INT 63000
14035: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
14036: LD_ADDR_EXP 16
14040: PUSH
14041: LD_INT 600
14043: ST_TO_ADDR
// end ;
14044: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 and Difficulty > 1 do
14045: LD_EXP 4
14049: PUSH
14050: LD_EXP 15
14054: PUSH
14055: LD_INT 600
14057: GREATEREQUAL
14058: AND
14059: PUSH
14060: LD_OWVAR 67
14064: PUSH
14065: LD_INT 1
14067: GREATER
14068: AND
14069: IFFALSE 14235
14071: GO 14073
14073: DISABLE
// begin DialogueOn ;
14074: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
14078: LD_EXP 36
14082: PPUSH
14083: LD_STRING DF-1-delivery-3
14085: PPUSH
14086: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
14090: LD_EXP 28
14094: PPUSH
14095: LD_STRING DH-1-delivery-3
14097: PPUSH
14098: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
14102: LD_EXP 36
14106: PPUSH
14107: LD_STRING DF-2-delivery-3
14109: PPUSH
14110: CALL_OW 94
// if IsOk ( Kaia ) then
14114: LD_EXP 33
14118: PPUSH
14119: CALL_OW 302
14123: IFFALSE 14173
// begin Say ( Kaia , DK-1-delivery-3 ) ;
14125: LD_EXP 33
14129: PPUSH
14130: LD_STRING DK-1-delivery-3
14132: PPUSH
14133: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
14137: LD_EXP 28
14141: PPUSH
14142: LD_STRING DH-2-delivery-3
14144: PPUSH
14145: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
14149: LD_EXP 29
14153: PPUSH
14154: LD_STRING DG-1-delivery-3
14156: PPUSH
14157: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
14161: LD_EXP 30
14165: PPUSH
14166: LD_STRING DM-1-delivery-3
14168: PPUSH
14169: CALL_OW 88
// end ; DialogueOff ;
14173: CALL_OW 7
// if Difficulty = 2 then
14177: LD_OWVAR 67
14181: PUSH
14182: LD_INT 2
14184: EQUAL
14185: IFFALSE 14212
// begin ChangeMissionObjectives ( Crates3 ) ;
14187: LD_STRING Crates3
14189: PPUSH
14190: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14194: LD_ADDR_EXP 17
14198: PUSH
14199: LD_INT 63000
14201: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
14202: LD_ADDR_EXP 16
14206: PUSH
14207: LD_INT 900
14209: ST_TO_ADDR
// end else
14210: GO 14235
// begin ChangeMissionObjectives ( Crates4 ) ;
14212: LD_STRING Crates4
14214: PPUSH
14215: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14219: LD_ADDR_EXP 17
14223: PUSH
14224: LD_INT 63000
14226: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
14227: LD_ADDR_EXP 16
14231: PUSH
14232: LD_INT 1200
14234: ST_TO_ADDR
// end ; end ;
14235: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
14236: LD_EXP 4
14240: PUSH
14241: LD_EXP 15
14245: PUSH
14246: LD_INT 600
14248: PUSH
14249: LD_INT 900
14251: PUSH
14252: LD_INT 1200
14254: PUSH
14255: EMPTY
14256: LIST
14257: LIST
14258: LIST
14259: PUSH
14260: LD_OWVAR 67
14264: ARRAY
14265: GREATEREQUAL
14266: AND
14267: PUSH
14268: LD_EXP 16
14272: PUSH
14273: LD_EXP 17
14277: LESSEQUAL
14278: AND
14279: IFFALSE 14346
14281: GO 14283
14283: DISABLE
// begin retreatAllowed := true ;
14284: LD_ADDR_EXP 11
14288: PUSH
14289: LD_INT 1
14291: ST_TO_ADDR
// display_strings := [ ] ;
14292: LD_ADDR_OWVAR 47
14296: PUSH
14297: EMPTY
14298: ST_TO_ADDR
// DialogueOn ;
14299: CALL_OW 6
// InGameOn ;
14303: CALL_OW 8
// SayRadio ( Omar , DO-radio-end ) ;
14307: LD_EXP 37
14311: PPUSH
14312: LD_STRING DO-radio-end
14314: PPUSH
14315: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
14319: LD_EXP 28
14323: PPUSH
14324: LD_STRING DH-1-radio-end
14326: PPUSH
14327: CALL_OW 88
// InGameOff ;
14331: CALL_OW 9
// DialogueOff ;
14335: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
14339: LD_STRING Retreat
14341: PPUSH
14342: CALL_OW 337
// end ;
14346: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
14347: LD_EXP 11
14351: IFFALSE 14482
14353: GO 14355
14355: DISABLE
14356: LD_INT 0
14358: PPUSH
14359: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
14360: LD_INT 10
14362: PPUSH
14363: LD_INT 0
14365: PPUSH
14366: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
14370: LD_ADDR_VAR 0 1
14374: PUSH
14375: LD_EXP 39
14379: PPUSH
14380: LD_INT 25
14382: PUSH
14383: LD_INT 2
14385: PUSH
14386: EMPTY
14387: LIST
14388: LIST
14389: PPUSH
14390: CALL_OW 72
14394: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14395: LD_VAR 0 1
14399: PUSH
14400: LD_INT 102
14402: PPUSH
14403: LD_INT 69
14405: PPUSH
14406: CALL_OW 428
14410: PUSH
14411: LD_INT 0
14413: EQUAL
14414: AND
14415: IFFALSE 14482
// begin for i in tmp do
14417: LD_ADDR_VAR 0 2
14421: PUSH
14422: LD_VAR 0 1
14426: PUSH
14427: FOR_IN
14428: IFFALSE 14452
// if IsInUnit ( i ) then
14430: LD_VAR 0 2
14434: PPUSH
14435: CALL_OW 310
14439: IFFALSE 14450
// ComExitBuilding ( i ) ;
14441: LD_VAR 0 2
14445: PPUSH
14446: CALL_OW 122
14450: GO 14427
14452: POP
14453: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14454: LD_VAR 0 1
14458: PPUSH
14459: LD_INT 31
14461: PPUSH
14462: LD_INT 102
14464: PPUSH
14465: LD_INT 69
14467: PPUSH
14468: LD_INT 2
14470: PPUSH
14471: CALL_OW 205
// wait ( 0 0$3 ) ;
14475: LD_INT 105
14477: PPUSH
14478: CALL_OW 67
// end ; end ;
14482: PPOPN 2
14484: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14485: LD_EXP 11
14489: NOT
14490: PUSH
14491: LD_INT 5
14493: PPUSH
14494: CALL_OW 301
14498: AND
14499: IFFALSE 14531
14501: GO 14503
14503: DISABLE
// begin DialogueOn ;
14504: CALL_OW 6
// SayRadio ( Farmer , DF-1-failure ) ;
14508: LD_EXP 36
14512: PPUSH
14513: LD_STRING DF-1-failure
14515: PPUSH
14516: CALL_OW 94
// DialogueOff ;
14520: CALL_OW 7
// YouLost ( FarmerDepot ) ;
14524: LD_STRING FarmerDepot
14526: PPUSH
14527: CALL_OW 104
// end ;
14531: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 and not FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_type , unit_human ] ] ) do var i , max , tmp ;
14532: LD_EXP 11
14536: PUSH
14537: LD_EXP 28
14541: PPUSH
14542: LD_EXP 36
14546: PPUSH
14547: CALL_OW 296
14551: PUSH
14552: LD_INT 6
14554: LESS
14555: AND
14556: PUSH
14557: LD_INT 81
14559: PUSH
14560: LD_INT 2
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: LD_INT 21
14569: PUSH
14570: LD_INT 1
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: PPUSH
14581: CALL_OW 69
14585: NOT
14586: AND
14587: IFFALSE 15208
14589: GO 14591
14591: DISABLE
14592: LD_INT 0
14594: PPUSH
14595: PPUSH
14596: PPUSH
// begin allowConvoys := false ;
14597: LD_ADDR_EXP 12
14601: PUSH
14602: LD_INT 0
14604: ST_TO_ADDR
// InGameOn ;
14605: CALL_OW 8
// ComTurnUnit ( Heike , Farmer ) ;
14609: LD_EXP 28
14613: PPUSH
14614: LD_EXP 36
14618: PPUSH
14619: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14623: LD_EXP 36
14627: PPUSH
14628: LD_EXP 28
14632: PPUSH
14633: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14637: LD_EXP 36
14641: PPUSH
14642: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14646: LD_EXP 28
14650: PPUSH
14651: LD_STRING DH-1-end
14653: PPUSH
14654: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14658: LD_EXP 36
14662: PPUSH
14663: LD_STRING DF-1-end
14665: PPUSH
14666: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14670: LD_EXP 36
14674: PPUSH
14675: LD_STRING DF-2-end
14677: PPUSH
14678: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14682: LD_EXP 28
14686: PPUSH
14687: LD_STRING DH-2-end
14689: PPUSH
14690: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14694: LD_EXP 36
14698: PPUSH
14699: LD_STRING DF-3-end
14701: PPUSH
14702: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14706: LD_EXP 28
14710: PPUSH
14711: LD_STRING DH-3-end
14713: PPUSH
14714: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14718: LD_EXP 29
14722: PPUSH
14723: LD_STRING DG-1-end
14725: PPUSH
14726: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14730: LD_EXP 28
14734: PPUSH
14735: LD_STRING DH-4-end
14737: PPUSH
14738: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14742: LD_EXP 36
14746: PPUSH
14747: LD_STRING DF-4-end
14749: PPUSH
14750: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14754: LD_EXP 28
14758: PPUSH
14759: LD_STRING DH-5-end
14761: PPUSH
14762: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14766: LD_EXP 36
14770: PPUSH
14771: LD_STRING DF-5-end
14773: PPUSH
14774: CALL_OW 88
// InGameOff ;
14778: CALL_OW 9
// allowCargoEvacuation := true ;
14782: LD_ADDR_EXP 7
14786: PUSH
14787: LD_INT 1
14789: ST_TO_ADDR
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14790: LD_ADDR_VAR 0 2
14794: PUSH
14795: LD_INT 4
14797: PUSH
14798: LD_INT 3
14800: PUSH
14801: LD_INT 2
14803: PUSH
14804: EMPTY
14805: LIST
14806: LIST
14807: LIST
14808: PUSH
14809: LD_OWVAR 67
14813: ARRAY
14814: ST_TO_ADDR
// if farmerSquad < max then
14815: LD_EXP 39
14819: PUSH
14820: LD_VAR 0 2
14824: LESS
14825: IFFALSE 14837
// max := farmerSquad ;
14827: LD_ADDR_VAR 0 2
14831: PUSH
14832: LD_EXP 39
14836: ST_TO_ADDR
// for i := 1 to max do
14837: LD_ADDR_VAR 0 1
14841: PUSH
14842: DOUBLE
14843: LD_INT 1
14845: DEC
14846: ST_TO_ADDR
14847: LD_VAR 0 2
14851: PUSH
14852: FOR_TO
14853: IFFALSE 14891
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14855: LD_EXP 39
14859: PUSH
14860: LD_INT 1
14862: ARRAY
14863: PPUSH
14864: LD_INT 2
14866: PPUSH
14867: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14871: LD_ADDR_EXP 39
14875: PUSH
14876: LD_EXP 39
14880: PPUSH
14881: LD_INT 1
14883: PPUSH
14884: CALL_OW 3
14888: ST_TO_ADDR
// end ;
14889: GO 14852
14891: POP
14892: POP
// for i in Farmer ^ farmerSquad do
14893: LD_ADDR_VAR 0 1
14897: PUSH
14898: LD_EXP 36
14902: PUSH
14903: LD_EXP 39
14907: ADD
14908: PUSH
14909: FOR_IN
14910: IFFALSE 14949
// begin if IsInUnit ( i ) then
14912: LD_VAR 0 1
14916: PPUSH
14917: CALL_OW 310
14921: IFFALSE 14932
// ComExitBuilding ( i ) ;
14923: LD_VAR 0 1
14927: PPUSH
14928: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14932: LD_VAR 0 1
14936: PPUSH
14937: LD_INT 102
14939: PPUSH
14940: LD_INT 7
14942: PPUSH
14943: CALL_OW 171
// end ;
14947: GO 14909
14949: POP
14950: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14951: LD_ADDR_VAR 0 1
14955: PUSH
14956: LD_INT 22
14958: PUSH
14959: LD_INT 5
14961: PUSH
14962: EMPTY
14963: LIST
14964: LIST
14965: PUSH
14966: LD_INT 21
14968: PUSH
14969: LD_INT 3
14971: PUSH
14972: EMPTY
14973: LIST
14974: LIST
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: PPUSH
14980: CALL_OW 69
14984: PUSH
14985: LD_INT 5
14987: DIFF
14988: PUSH
14989: FOR_IN
14990: IFFALSE 15006
// SetSide ( i , 2 ) ;
14992: LD_VAR 0 1
14996: PPUSH
14997: LD_INT 2
14999: PPUSH
15000: CALL_OW 235
15004: GO 14989
15006: POP
15007: POP
// repeat wait ( 0 0$1 ) ;
15008: LD_INT 35
15010: PPUSH
15011: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
15015: LD_ADDR_VAR 0 3
15019: PUSH
15020: LD_EXP 36
15024: PUSH
15025: LD_EXP 39
15029: ADD
15030: PPUSH
15031: LD_INT 95
15033: PUSH
15034: LD_INT 3
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PPUSH
15041: CALL_OW 72
15045: ST_TO_ADDR
// if tmp then
15046: LD_VAR 0 3
15050: IFFALSE 15094
// for i in tmp do
15052: LD_ADDR_VAR 0 1
15056: PUSH
15057: LD_VAR 0 3
15061: PUSH
15062: FOR_IN
15063: IFFALSE 15092
// begin farmerSquad := farmerSquad diff i ;
15065: LD_ADDR_EXP 39
15069: PUSH
15070: LD_EXP 39
15074: PUSH
15075: LD_VAR 0 1
15079: DIFF
15080: ST_TO_ADDR
// RemoveUnit ( i ) ;
15081: LD_VAR 0 1
15085: PPUSH
15086: CALL_OW 64
// end ;
15090: GO 15062
15092: POP
15093: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
15094: LD_EXP 39
15098: PUSH
15099: EMPTY
15100: EQUAL
15101: PUSH
15102: LD_EXP 36
15106: PPUSH
15107: CALL_OW 305
15111: NOT
15112: AND
15113: IFFALSE 15008
// if farmerHumanLoseCounter = 0 then
15115: LD_EXP 20
15119: PUSH
15120: LD_INT 0
15122: EQUAL
15123: IFFALSE 15132
// SetAchievement ( ACH_BABY ) ;
15125: LD_STRING ACH_BABY
15127: PPUSH
15128: CALL_OW 543
// wait ( 1 1$00 ) ;
15132: LD_INT 2100
15134: PPUSH
15135: CALL_OW 67
// SendAttack ;
15139: CALL 7034 0 0
// for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15143: LD_ADDR_VAR 0 1
15147: PUSH
15148: DOUBLE
15149: LD_INT 1
15151: DEC
15152: ST_TO_ADDR
15153: LD_INT 2
15155: PUSH
15156: LD_INT 3
15158: PUSH
15159: LD_INT 4
15161: PUSH
15162: EMPTY
15163: LIST
15164: LIST
15165: LIST
15166: PUSH
15167: LD_OWVAR 67
15171: ARRAY
15172: PUSH
15173: FOR_TO
15174: IFFALSE 15206
// begin wait ( [ 2 2$00 , 1 1$40 , 1 1$30 ] [ Difficulty ] ) ;
15176: LD_INT 4200
15178: PUSH
15179: LD_INT 3500
15181: PUSH
15182: LD_INT 3150
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: LIST
15189: PUSH
15190: LD_OWVAR 67
15194: ARRAY
15195: PPUSH
15196: CALL_OW 67
// SendAttack ;
15200: CALL 7034 0 0
// end ;
15204: GO 15173
15206: POP
15207: POP
// end ;
15208: PPOPN 3
15210: END
// every 0 0$1 trigger allowCargoEvacuation do
15211: LD_EXP 7
15215: IFFALSE 15224
15217: GO 15219
15219: DISABLE
// StartCargoEvacuation ;
15220: CALL 4570 0 0
15224: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
15225: LD_EXP 17
15229: PUSH
15230: LD_INT 18900
15232: LESSEQUAL
15233: IFFALSE 15282
15235: GO 15237
15237: DISABLE
// begin DialogueOn ;
15238: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
15242: LD_EXP 36
15246: PPUSH
15247: LD_STRING DF-1-distribution-a
15249: PPUSH
15250: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
15254: LD_EXP 28
15258: PPUSH
15259: LD_STRING DH-1-distribution-a
15261: PPUSH
15262: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
15266: LD_EXP 36
15270: PPUSH
15271: LD_STRING DF-2-distribution-a
15273: PPUSH
15274: CALL_OW 94
// DialogueOff ;
15278: CALL_OW 7
// end ;
15282: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
15283: LD_EXP 17
15287: PUSH
15288: LD_INT 0
15290: LESSEQUAL
15291: IFFALSE 15323
15293: GO 15295
15295: DISABLE
// begin DialogueOn ;
15296: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
15300: LD_EXP 36
15304: PPUSH
15305: LD_STRING DF-3-distribution-a
15307: PPUSH
15308: CALL_OW 94
// YouLost ( Distribution ) ;
15312: LD_STRING Distribution
15314: PPUSH
15315: CALL_OW 104
// DialogueOff ;
15319: CALL_OW 7
// end ;
15323: END
// every 0 0$1 trigger vehCounter >= 2 do
15324: LD_EXP 22
15328: PUSH
15329: LD_INT 2
15331: GREATEREQUAL
15332: IFFALSE 15344
15334: GO 15336
15336: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
15337: LD_STRING VehConstructed
15339: PPUSH
15340: CALL_OW 337
15344: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
15345: LD_INT 22
15347: PUSH
15348: LD_INT 2
15350: PUSH
15351: EMPTY
15352: LIST
15353: LIST
15354: PUSH
15355: LD_INT 34
15357: PUSH
15358: LD_INT 12
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PUSH
15365: EMPTY
15366: LIST
15367: LIST
15368: PPUSH
15369: CALL_OW 69
15373: IFFALSE 15433
15375: GO 15377
15377: DISABLE
// begin DialogueOn ;
15378: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
15382: LD_EXP 28
15386: PPUSH
15387: LD_STRING DH-1-truck
15389: PPUSH
15390: CALL_OW 88
// if IsOk ( Markov ) then
15394: LD_EXP 35
15398: PPUSH
15399: CALL_OW 302
15403: IFFALSE 15429
// begin Say ( Markov , DMar-1-truck ) ;
15405: LD_EXP 35
15409: PPUSH
15410: LD_STRING DMar-1-truck
15412: PPUSH
15413: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
15417: LD_EXP 28
15421: PPUSH
15422: LD_STRING DH-2-truck
15424: PPUSH
15425: CALL_OW 88
// end ; DialogueOff ;
15429: CALL_OW 7
// end ;
15433: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
15434: LD_INT 0
15436: PPUSH
15437: PPUSH
15438: PPUSH
// if IsOk ( Givi ) then
15439: LD_EXP 29
15443: PPUSH
15444: CALL_OW 302
15448: IFFALSE 15464
// begin Say ( Givi , DG-1-nocargo ) ;
15450: LD_EXP 29
15454: PPUSH
15455: LD_STRING DG-1-nocargo
15457: PPUSH
15458: CALL_OW 88
// exit ;
15462: GO 15560
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15464: LD_ADDR_VAR 0 2
15468: PUSH
15469: LD_EXP 42
15473: PPUSH
15474: LD_INT 26
15476: PUSH
15477: LD_INT 1
15479: PUSH
15480: EMPTY
15481: LIST
15482: LIST
15483: PPUSH
15484: CALL_OW 72
15488: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15489: LD_ADDR_VAR 0 3
15493: PUSH
15494: LD_EXP 42
15498: PPUSH
15499: LD_INT 26
15501: PUSH
15502: LD_INT 2
15504: PUSH
15505: EMPTY
15506: LIST
15507: LIST
15508: PPUSH
15509: CALL_OW 72
15513: ST_TO_ADDR
// if randomMen then
15514: LD_VAR 0 2
15518: IFFALSE 15538
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15520: LD_VAR 0 2
15524: PUSH
15525: LD_INT 1
15527: ARRAY
15528: PPUSH
15529: LD_STRING DArm-1-nocargo
15531: PPUSH
15532: CALL_OW 88
15536: GO 15560
// if randomWomen then
15538: LD_VAR 0 3
15542: IFFALSE 15560
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15544: LD_VAR 0 3
15548: PUSH
15549: LD_INT 1
15551: ARRAY
15552: PPUSH
15553: LD_STRING DArf-1-nocargo
15555: PPUSH
15556: CALL_OW 88
// end ;
15560: LD_VAR 0 1
15564: RET
// export function IncomingAttack ; begin
15565: LD_INT 0
15567: PPUSH
// if attackWave = 1 then
15568: LD_EXP 19
15572: PUSH
15573: LD_INT 1
15575: EQUAL
15576: IFFALSE 15647
// begin DialogueOn ;
15578: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15582: LD_EXP 37
15586: PPUSH
15587: LD_STRING DO-1-radio-1
15589: PPUSH
15590: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15594: LD_EXP 28
15598: PPUSH
15599: LD_STRING DH-1-radio-1-
15601: PPUSH
15602: CALL_OW 88
// if IsOk ( Markov ) then
15606: LD_EXP 35
15610: PPUSH
15611: CALL_OW 302
15615: IFFALSE 15641
// begin Say ( Markov , DMar-1-radio-1 ) ;
15617: LD_EXP 35
15621: PPUSH
15622: LD_STRING DMar-1-radio-1
15624: PPUSH
15625: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15629: LD_EXP 28
15633: PPUSH
15634: LD_STRING DH-2-radio-1
15636: PPUSH
15637: CALL_OW 88
// end ; DialogueOff ;
15641: CALL_OW 7
// end else
15645: GO 15671
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15647: LD_EXP 37
15651: PPUSH
15652: LD_STRING DO-1-radio-u
15654: PPUSH
15655: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15659: LD_EXP 28
15663: PPUSH
15664: LD_STRING DH-1-radio-u
15666: PPUSH
15667: CALL_OW 88
// end ; end ;
15671: LD_VAR 0 1
15675: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15676: LD_EXP 44
15680: PPUSH
15681: LD_INT 95
15683: PUSH
15684: LD_INT 8
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: PPUSH
15691: CALL_OW 72
15695: IFFALSE 15798
15697: GO 15699
15699: DISABLE
15700: LD_INT 0
15702: PPUSH
// begin enable ;
15703: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15704: LD_ADDR_VAR 0 1
15708: PUSH
15709: LD_EXP 44
15713: PPUSH
15714: LD_INT 95
15716: PUSH
15717: LD_INT 8
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PPUSH
15724: CALL_OW 72
15728: PUSH
15729: FOR_IN
15730: IFFALSE 15759
// begin usForces := usForces diff i ;
15732: LD_ADDR_EXP 44
15736: PUSH
15737: LD_EXP 44
15741: PUSH
15742: LD_VAR 0 1
15746: DIFF
15747: ST_TO_ADDR
// RemoveUnit ( i ) ;
15748: LD_VAR 0 1
15752: PPUSH
15753: CALL_OW 64
// end ;
15757: GO 15729
15759: POP
15760: POP
// if not americanHasEscaped and attackWave = 1 then
15761: LD_EXP 8
15765: NOT
15766: PUSH
15767: LD_EXP 19
15771: PUSH
15772: LD_INT 1
15774: EQUAL
15775: AND
15776: IFFALSE 15798
// begin americanHasEscaped := true ;
15778: LD_ADDR_EXP 8
15782: PUSH
15783: LD_INT 1
15785: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15786: LD_EXP 28
15790: PPUSH
15791: LD_STRING DH-2-assault-a
15793: PPUSH
15794: CALL_OW 88
// end ; end ;
15798: PPOPN 1
15800: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) and not retreatAllowed do
15801: LD_INT 4
15803: PPUSH
15804: LD_INT 22
15806: PUSH
15807: LD_INT 1
15809: PUSH
15810: EMPTY
15811: LIST
15812: LIST
15813: PPUSH
15814: CALL_OW 70
15818: PUSH
15819: LD_EXP 11
15823: NOT
15824: AND
15825: IFFALSE 15842
15827: GO 15829
15829: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15830: LD_EXP 36
15834: PPUSH
15835: LD_STRING DF-1-attack
15837: PPUSH
15838: CALL_OW 94
15842: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15843: LD_INT 5
15845: PPUSH
15846: CALL_OW 255
15850: PUSH
15851: LD_INT 2
15853: EQUAL
15854: IFFALSE 15866
15856: GO 15858
15858: DISABLE
// YouLost ( Attack ) ;
15859: LD_STRING Attack
15861: PPUSH
15862: CALL_OW 104
15866: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 90 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot ;
15867: LD_INT 22
15869: PUSH
15870: LD_INT 1
15872: PUSH
15873: EMPTY
15874: LIST
15875: LIST
15876: PUSH
15877: LD_INT 21
15879: PUSH
15880: LD_INT 1
15882: PUSH
15883: EMPTY
15884: LIST
15885: LIST
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PPUSH
15891: CALL_OW 69
15895: NOT
15896: PUSH
15897: LD_INT 22
15899: PUSH
15900: LD_INT 4
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PPUSH
15907: CALL_OW 69
15911: NOT
15912: AND
15913: PUSH
15914: LD_EXP 11
15918: NOT
15919: AND
15920: PUSH
15921: LD_EXP 15
15925: PUSH
15926: LD_INT 90
15928: GREATER
15929: AND
15930: PUSH
15931: LD_INT 7
15933: PPUSH
15934: LD_INT 22
15936: PUSH
15937: LD_INT 2
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: PUSH
15944: LD_INT 21
15946: PUSH
15947: LD_INT 1
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: PUSH
15954: EMPTY
15955: LIST
15956: LIST
15957: PPUSH
15958: CALL_OW 70
15962: AND
15963: PUSH
15964: LD_INT 22
15966: PUSH
15967: LD_INT 2
15969: PUSH
15970: EMPTY
15971: LIST
15972: LIST
15973: PUSH
15974: LD_INT 50
15976: PUSH
15977: EMPTY
15978: LIST
15979: PUSH
15980: LD_INT 30
15982: PUSH
15983: LD_INT 0
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: LIST
15994: PPUSH
15995: CALL_OW 69
15999: AND
16000: IFFALSE 16701
16002: GO 16004
16004: DISABLE
16005: LD_INT 0
16007: PPUSH
16008: PPUSH
16009: PPUSH
16010: PPUSH
16011: PPUSH
// begin depot := usDepot ;
16012: LD_ADDR_VAR 0 5
16016: PUSH
16017: LD_INT 11
16019: ST_TO_ADDR
// if not depot then
16020: LD_VAR 0 5
16024: NOT
16025: IFFALSE 16065
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
16027: LD_ADDR_VAR 0 5
16031: PUSH
16032: LD_INT 22
16034: PUSH
16035: LD_INT 2
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: PUSH
16042: LD_INT 30
16044: PUSH
16045: LD_INT 0
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PPUSH
16056: CALL_OW 69
16060: PUSH
16061: LD_INT 1
16063: ARRAY
16064: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
16065: LD_ADDR_VAR 0 1
16069: PUSH
16070: LD_EXP 42
16074: PPUSH
16075: LD_INT 26
16077: PUSH
16078: LD_INT 1
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PPUSH
16085: CALL_OW 72
16089: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
16090: LD_ADDR_VAR 0 2
16094: PUSH
16095: LD_EXP 42
16099: PPUSH
16100: LD_INT 26
16102: PUSH
16103: LD_INT 2
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: PPUSH
16110: CALL_OW 72
16114: ST_TO_ADDR
// if IsOk ( Kaia ) then
16115: LD_EXP 33
16119: PPUSH
16120: CALL_OW 302
16124: IFFALSE 16145
// speaker := [ Kaia , DK ] else
16126: LD_ADDR_VAR 0 3
16130: PUSH
16131: LD_EXP 33
16135: PUSH
16136: LD_STRING DK
16138: PUSH
16139: EMPTY
16140: LIST
16141: LIST
16142: ST_TO_ADDR
16143: GO 16225
// if randomMen then
16145: LD_VAR 0 1
16149: IFFALSE 16184
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
16151: LD_ADDR_VAR 0 3
16155: PUSH
16156: LD_VAR 0 1
16160: PUSH
16161: LD_INT 1
16163: PPUSH
16164: LD_VAR 0 1
16168: PPUSH
16169: CALL_OW 12
16173: ARRAY
16174: PUSH
16175: LD_STRING DArm
16177: PUSH
16178: EMPTY
16179: LIST
16180: LIST
16181: ST_TO_ADDR
16182: GO 16225
// if randomWomen then
16184: LD_VAR 0 2
16188: IFFALSE 16223
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
16190: LD_ADDR_VAR 0 3
16194: PUSH
16195: LD_VAR 0 2
16199: PUSH
16200: LD_INT 1
16202: PPUSH
16203: LD_VAR 0 2
16207: PPUSH
16208: CALL_OW 12
16212: ARRAY
16213: PUSH
16214: LD_STRING DArf
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: ST_TO_ADDR
16221: GO 16225
// exit ;
16223: GO 16701
// if IsInUnit ( speaker [ 1 ] ) then
16225: LD_VAR 0 3
16229: PUSH
16230: LD_INT 1
16232: ARRAY
16233: PPUSH
16234: CALL_OW 310
16238: IFFALSE 16261
// place := IsInUnit ( speaker [ 1 ] ) else
16240: LD_ADDR_VAR 0 4
16244: PUSH
16245: LD_VAR 0 3
16249: PUSH
16250: LD_INT 1
16252: ARRAY
16253: PPUSH
16254: CALL_OW 310
16258: ST_TO_ADDR
16259: GO 16275
// place := speaker [ 1 ] ;
16261: LD_ADDR_VAR 0 4
16265: PUSH
16266: LD_VAR 0 3
16270: PUSH
16271: LD_INT 1
16273: ARRAY
16274: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
16275: LD_VAR 0 4
16279: PPUSH
16280: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
16284: LD_VAR 0 4
16288: PPUSH
16289: CALL_OW 250
16293: PPUSH
16294: LD_VAR 0 4
16298: PPUSH
16299: CALL_OW 251
16303: PPUSH
16304: CALL 3078 0 2
// wait ( 0 0$2 ) ;
16308: LD_INT 70
16310: PPUSH
16311: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
16315: LD_EXP 38
16319: PPUSH
16320: CALL_OW 305
16324: NOT
16325: IFFALSE 16329
// exit ;
16327: GO 16701
// allowConvoys := false ;
16329: LD_ADDR_EXP 12
16333: PUSH
16334: LD_INT 0
16336: ST_TO_ADDR
// InGameOn ;
16337: CALL_OW 8
// wait ( 0 0$1 ) ;
16341: LD_INT 35
16343: PPUSH
16344: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
16348: LD_EXP 38
16352: PPUSH
16353: LD_STRING DI-1-land
16355: PPUSH
16356: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
16360: LD_VAR 0 3
16364: PUSH
16365: LD_INT 1
16367: ARRAY
16368: PPUSH
16369: CALL_OW 310
16373: IFFALSE 16388
// ComExit ( speaker [ 1 ] ) ;
16375: LD_VAR 0 3
16379: PUSH
16380: LD_INT 1
16382: ARRAY
16383: PPUSH
16384: CALL 1140 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
16388: LD_VAR 0 3
16392: PUSH
16393: LD_INT 1
16395: ARRAY
16396: PPUSH
16397: LD_EXP 38
16401: PPUSH
16402: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
16406: LD_VAR 0 3
16410: PUSH
16411: LD_INT 1
16413: ARRAY
16414: PPUSH
16415: LD_EXP 38
16419: PPUSH
16420: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
16424: LD_EXP 38
16428: PPUSH
16429: LD_VAR 0 3
16433: PUSH
16434: LD_INT 1
16436: ARRAY
16437: PPUSH
16438: CALL_OW 119
// wait ( 0 0$1 ) ;
16442: LD_INT 35
16444: PPUSH
16445: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
16449: LD_VAR 0 3
16453: PUSH
16454: LD_INT 1
16456: ARRAY
16457: PPUSH
16458: LD_VAR 0 3
16462: PUSH
16463: LD_INT 2
16465: ARRAY
16466: PUSH
16467: LD_STRING -1-land
16469: STR
16470: PPUSH
16471: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16475: LD_EXP 38
16479: PPUSH
16480: LD_STRING DI-2-land
16482: PPUSH
16483: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16487: LD_VAR 0 3
16491: PUSH
16492: LD_INT 1
16494: ARRAY
16495: PPUSH
16496: LD_VAR 0 3
16500: PUSH
16501: LD_INT 2
16503: ARRAY
16504: PUSH
16505: LD_STRING -2-land
16507: STR
16508: PPUSH
16509: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16513: LD_VAR 0 3
16517: PUSH
16518: LD_INT 1
16520: ARRAY
16521: PPUSH
16522: LD_VAR 0 3
16526: PUSH
16527: LD_INT 2
16529: ARRAY
16530: PUSH
16531: LD_STRING -3-land
16533: STR
16534: PPUSH
16535: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16539: LD_EXP 28
16543: PPUSH
16544: LD_STRING DH-1-land
16546: PPUSH
16547: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16551: LD_VAR 0 5
16555: PPUSH
16556: CALL_OW 313
16560: PUSH
16561: LD_INT 6
16563: EQUAL
16564: IFFALSE 16584
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16566: LD_VAR 0 5
16570: PPUSH
16571: CALL_OW 313
16575: PUSH
16576: LD_INT 1
16578: ARRAY
16579: PPUSH
16580: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16584: LD_EXP 38
16588: PPUSH
16589: LD_INT 2
16591: PPUSH
16592: CALL_OW 235
// CenterOnUnits ( depot ) ;
16596: LD_VAR 0 5
16600: PPUSH
16601: CALL_OW 85
// ComEnterUnit ( Ibrahim , depot ) ;
16605: LD_EXP 38
16609: PPUSH
16610: LD_VAR 0 5
16614: PPUSH
16615: CALL_OW 120
// ComEnterUnit ( speaker [ 1 ] , depot ) ;
16619: LD_VAR 0 3
16623: PUSH
16624: LD_INT 1
16626: ARRAY
16627: PPUSH
16628: LD_VAR 0 5
16632: PPUSH
16633: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
16637: LD_INT 35
16639: PPUSH
16640: CALL_OW 67
// until IsInUnit ( Ibrahim ) or not IsOk ( Ibrahim ) ;
16644: LD_EXP 38
16648: PPUSH
16649: CALL_OW 310
16653: PUSH
16654: LD_EXP 38
16658: PPUSH
16659: CALL_OW 302
16663: NOT
16664: OR
16665: IFFALSE 16637
// InGameOff ;
16667: CALL_OW 9
// if not IsOk ( Ibrahim ) then
16671: LD_EXP 38
16675: PPUSH
16676: CALL_OW 302
16680: NOT
16681: IFFALSE 16685
// exit ;
16683: GO 16701
// ibrahimInDepot := true ;
16685: LD_ADDR_EXP 25
16689: PUSH
16690: LD_INT 1
16692: ST_TO_ADDR
// allowConvoys := true ;
16693: LD_ADDR_EXP 12
16697: PUSH
16698: LD_INT 1
16700: ST_TO_ADDR
// end ;
16701: PPOPN 5
16703: END
// export function IbrahimQuery ; begin
16704: LD_INT 0
16706: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16707: LD_STRING IbrahimQuery
16709: PPUSH
16710: CALL_OW 97
16714: PUSH
16715: LD_INT 1
16717: DOUBLE
16718: EQUAL
16719: IFTRUE 16723
16721: GO 17005
16723: POP
// begin allowConvoys := false ;
16724: LD_ADDR_EXP 12
16728: PUSH
16729: LD_INT 0
16731: ST_TO_ADDR
// ibrahimInDepot := false ;
16732: LD_ADDR_EXP 25
16736: PUSH
16737: LD_INT 0
16739: ST_TO_ADDR
// InGameOn ;
16740: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16744: LD_EXP 28
16748: PPUSH
16749: CALL_OW 87
// wait ( 0 0$1 ) ;
16753: LD_INT 35
16755: PPUSH
16756: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16760: LD_EXP 28
16764: PPUSH
16765: LD_STRING DH-1-interrogation
16767: PPUSH
16768: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16772: LD_EXP 38
16776: PPUSH
16777: LD_STRING DI-1-interrogation
16779: PPUSH
16780: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16784: LD_EXP 28
16788: PPUSH
16789: LD_STRING DH-2-interrogation
16791: PPUSH
16792: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16796: LD_EXP 38
16800: PPUSH
16801: LD_STRING DI-2-interrogation
16803: PPUSH
16804: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16808: LD_EXP 28
16812: PPUSH
16813: LD_STRING DH-3-interrogation
16815: PPUSH
16816: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16820: LD_EXP 38
16824: PPUSH
16825: LD_STRING DI-3-interrogation
16827: PPUSH
16828: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16832: LD_EXP 28
16836: PPUSH
16837: LD_STRING DH-4-interrogation
16839: PPUSH
16840: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16844: LD_EXP 38
16848: PPUSH
16849: LD_STRING DI-4-interrogation
16851: PPUSH
16852: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16856: LD_EXP 28
16860: PPUSH
16861: LD_STRING DH-5-interrogation
16863: PPUSH
16864: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16868: LD_EXP 38
16872: PPUSH
16873: LD_STRING DI-5-interrogation
16875: PPUSH
16876: CALL_OW 88
// wait ( 0 0$1 ) ;
16880: LD_INT 35
16882: PPUSH
16883: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16887: LD_STRING IbrahimDecisionQuery
16889: PPUSH
16890: CALL_OW 97
16894: PUSH
16895: LD_INT 1
16897: DOUBLE
16898: EQUAL
16899: IFTRUE 16903
16901: GO 16927
16903: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16904: LD_EXP 38
16908: PPUSH
16909: LD_STRING DI-1-kill
16911: PPUSH
16912: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16916: LD_EXP 38
16920: PPUSH
16921: CALL_OW 66
// end ; 2 :
16925: GO 16999
16927: LD_INT 2
16929: DOUBLE
16930: EQUAL
16931: IFTRUE 16935
16933: GO 16998
16935: POP
// begin SetSide ( Ibrahim , 6 ) ;
16936: LD_EXP 38
16940: PPUSH
16941: LD_INT 6
16943: PPUSH
16944: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16948: LD_EXP 38
16952: PPUSH
16953: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16957: LD_EXP 38
16961: PPUSH
16962: LD_INT 32
16964: PPUSH
16965: LD_INT 5
16967: PPUSH
16968: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16972: LD_EXP 28
16976: PPUSH
16977: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16981: LD_EXP 28
16985: PPUSH
16986: LD_INT 36
16988: PPUSH
16989: LD_INT 21
16991: PPUSH
16992: CALL_OW 171
// end ; end ;
16996: GO 16999
16998: POP
// InGameOff ;
16999: CALL_OW 9
// end ; 2 :
17003: GO 17019
17005: LD_INT 2
17007: DOUBLE
17008: EQUAL
17009: IFTRUE 17013
17011: GO 17018
17013: POP
// exit ; end ;
17014: GO 17057
17016: GO 17019
17018: POP
// allowConvoys := true ;
17019: LD_ADDR_EXP 12
17023: PUSH
17024: LD_INT 1
17026: ST_TO_ADDR
// wait ( 2 2$40 ) ;
17027: LD_INT 5600
17029: PPUSH
17030: CALL_OW 67
// ComMoveXY ( Ibrahim , 38 , 28 ) ;
17034: LD_EXP 38
17038: PPUSH
17039: LD_INT 38
17041: PPUSH
17042: LD_INT 28
17044: PPUSH
17045: CALL_OW 111
// ibrahimIsFree := true ;
17049: LD_ADDR_EXP 26
17053: PUSH
17054: LD_INT 1
17056: ST_TO_ADDR
// end ;
17057: LD_VAR 0 1
17061: RET
// every 0 0$1 trigger ibrahimIsFree and IsOk ( Ibrahim ) and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b , p , depot , x , y ;
17062: LD_EXP 26
17066: PUSH
17067: LD_EXP 38
17071: PPUSH
17072: CALL_OW 302
17076: AND
17077: PUSH
17078: LD_EXP 38
17082: PPUSH
17083: LD_INT 7
17085: PPUSH
17086: CALL_OW 308
17090: AND
17091: PUSH
17092: LD_INT 6
17094: PPUSH
17095: LD_EXP 28
17099: PPUSH
17100: CALL_OW 292
17104: AND
17105: PUSH
17106: LD_INT 22
17108: PUSH
17109: LD_INT 4
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: PPUSH
17116: CALL_OW 69
17120: NOT
17121: AND
17122: PUSH
17123: LD_INT 22
17125: PUSH
17126: LD_INT 1
17128: PUSH
17129: EMPTY
17130: LIST
17131: LIST
17132: PUSH
17133: LD_INT 21
17135: PUSH
17136: LD_INT 1
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: PUSH
17143: EMPTY
17144: LIST
17145: LIST
17146: PPUSH
17147: CALL_OW 69
17151: NOT
17152: AND
17153: IFFALSE 17913
17155: GO 17157
17157: DISABLE
17158: LD_INT 0
17160: PPUSH
17161: PPUSH
17162: PPUSH
17163: PPUSH
17164: PPUSH
17165: PPUSH
// begin allowConvoys := false ;
17166: LD_ADDR_EXP 12
17170: PUSH
17171: LD_INT 0
17173: ST_TO_ADDR
// depot := usDepot ;
17174: LD_ADDR_VAR 0 4
17178: PUSH
17179: LD_INT 11
17181: ST_TO_ADDR
// if not usDepot and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) then
17182: LD_INT 11
17184: NOT
17185: PUSH
17186: LD_INT 22
17188: PUSH
17189: LD_INT 2
17191: PUSH
17192: EMPTY
17193: LIST
17194: LIST
17195: PUSH
17196: LD_INT 50
17198: PUSH
17199: EMPTY
17200: LIST
17201: PUSH
17202: LD_INT 30
17204: PUSH
17205: LD_INT 0
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: PPUSH
17217: CALL_OW 69
17221: AND
17222: IFFALSE 17269
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
17224: LD_ADDR_VAR 0 4
17228: PUSH
17229: LD_INT 22
17231: PUSH
17232: LD_INT 2
17234: PUSH
17235: EMPTY
17236: LIST
17237: LIST
17238: PUSH
17239: LD_INT 50
17241: PUSH
17242: EMPTY
17243: LIST
17244: PUSH
17245: LD_INT 30
17247: PUSH
17248: LD_INT 0
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: LIST
17259: PPUSH
17260: CALL_OW 69
17264: PUSH
17265: LD_INT 1
17267: ARRAY
17268: ST_TO_ADDR
// InGameOn ;
17269: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
17273: LD_EXP 38
17277: PPUSH
17278: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
17282: LD_EXP 28
17286: PPUSH
17287: LD_EXP 38
17291: PPUSH
17292: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
17296: LD_EXP 38
17300: PPUSH
17301: LD_EXP 28
17305: PPUSH
17306: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
17310: LD_EXP 38
17314: PPUSH
17315: LD_STRING DI-1-free
17317: PPUSH
17318: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
17322: LD_EXP 28
17326: PPUSH
17327: LD_STRING DH-1-free
17329: PPUSH
17330: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
17334: LD_EXP 38
17338: PPUSH
17339: LD_STRING DI-2-free
17341: PPUSH
17342: CALL_OW 88
// changeClass := 0 ;
17346: LD_ADDR_VAR 0 1
17350: PUSH
17351: LD_INT 0
17353: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
17354: LD_STRING IbrahimJoinQuery
17356: PPUSH
17357: CALL_OW 97
17361: PUSH
17362: LD_INT 1
17364: DOUBLE
17365: EQUAL
17366: IFTRUE 17370
17368: GO 17381
17370: POP
// begin changeClass := 1 ;
17371: LD_ADDR_VAR 0 1
17375: PUSH
17376: LD_INT 1
17378: ST_TO_ADDR
// end ; 2 :
17379: GO 17621
17381: LD_INT 2
17383: DOUBLE
17384: EQUAL
17385: IFTRUE 17389
17387: GO 17541
17389: POP
// begin Say ( Heike , DH-1-decline ) ;
17390: LD_EXP 28
17394: PPUSH
17395: LD_STRING DH-1-decline
17397: PPUSH
17398: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
17402: LD_EXP 38
17406: PPUSH
17407: LD_STRING DI-1-decline
17409: PPUSH
17410: CALL_OW 88
// InGameOff ;
17414: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
17418: LD_EXP 38
17422: PPUSH
17423: LD_INT 30
17425: PPUSH
17426: LD_INT 1
17428: PPUSH
17429: CALL_OW 111
// p := 0 ;
17433: LD_ADDR_VAR 0 3
17437: PUSH
17438: LD_INT 0
17440: ST_TO_ADDR
// repeat p := p + 1 ;
17441: LD_ADDR_VAR 0 3
17445: PUSH
17446: LD_VAR 0 3
17450: PUSH
17451: LD_INT 1
17453: PLUS
17454: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17455: LD_INT 35
17457: PPUSH
17458: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) or p > 10 ;
17462: LD_EXP 38
17466: PPUSH
17467: LD_INT 30
17469: PPUSH
17470: LD_INT 1
17472: PPUSH
17473: CALL_OW 307
17477: PUSH
17478: LD_INT 22
17480: PUSH
17481: LD_INT 2
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: PUSH
17488: LD_INT 101
17490: PUSH
17491: LD_INT 6
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: PUSH
17498: EMPTY
17499: LIST
17500: LIST
17501: PPUSH
17502: CALL_OW 69
17506: NOT
17507: OR
17508: PUSH
17509: LD_VAR 0 3
17513: PUSH
17514: LD_INT 10
17516: GREATER
17517: OR
17518: IFFALSE 17441
// RemoveUnit ( Ibrahim ) ;
17520: LD_EXP 38
17524: PPUSH
17525: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17529: LD_INT 1
17531: PPUSH
17532: LD_STRING 03_IbrahimHasEscaped
17534: PPUSH
17535: CALL_OW 39
// end ; 3 :
17539: GO 17621
17541: LD_INT 3
17543: DOUBLE
17544: EQUAL
17545: IFTRUE 17549
17547: GO 17620
17549: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17550: LD_EXP 28
17554: PPUSH
17555: LD_STRING DH-1-radio-hq
17557: PPUSH
17558: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17562: LD_EXP 37
17566: PPUSH
17567: LD_STRING DO-1-radio-hq
17569: PPUSH
17570: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17574: LD_EXP 28
17578: PPUSH
17579: LD_STRING DH-2-radio-hq
17581: PPUSH
17582: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17586: LD_EXP 37
17590: PPUSH
17591: LD_STRING DO-2-radio-hq
17593: PPUSH
17594: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17598: LD_EXP 28
17602: PPUSH
17603: LD_STRING DH-3-radio-hq
17605: PPUSH
17606: CALL_OW 88
// changeClass := 1 ;
17610: LD_ADDR_VAR 0 1
17614: PUSH
17615: LD_INT 1
17617: ST_TO_ADDR
// end ; end ;
17618: GO 17621
17620: POP
// if changeClass then
17621: LD_VAR 0 1
17625: IFFALSE 17913
// begin Say ( Heike , DH-1-agree ) ;
17627: LD_EXP 28
17631: PPUSH
17632: LD_STRING DH-1-agree
17634: PPUSH
17635: CALL_OW 88
// if IsOk ( Givi ) then
17639: LD_EXP 29
17643: PPUSH
17644: CALL_OW 302
17648: IFFALSE 17686
// begin Say ( Givi , DG-1-agree ) ;
17650: LD_EXP 29
17654: PPUSH
17655: LD_STRING DG-1-agree
17657: PPUSH
17658: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17662: LD_EXP 28
17666: PPUSH
17667: LD_STRING DH-2-agree
17669: PPUSH
17670: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17674: LD_EXP 29
17678: PPUSH
17679: LD_STRING DG-2-agree
17681: PPUSH
17682: CALL_OW 88
// end ; if UnitsInside ( depot ) = 6 then
17686: LD_VAR 0 4
17690: PPUSH
17691: CALL_OW 313
17695: PUSH
17696: LD_INT 6
17698: EQUAL
17699: IFFALSE 17719
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
17701: LD_VAR 0 4
17705: PPUSH
17706: CALL_OW 313
17710: PUSH
17711: LD_INT 1
17713: ARRAY
17714: PPUSH
17715: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17719: LD_EXP 38
17723: PPUSH
17724: LD_INT 2
17726: PPUSH
17727: CALL_OW 235
// x := GetX ( Ibrahim ) ;
17731: LD_ADDR_VAR 0 5
17735: PUSH
17736: LD_EXP 38
17740: PPUSH
17741: CALL_OW 250
17745: ST_TO_ADDR
// y := GetY ( Ibrahim ) ;
17746: LD_ADDR_VAR 0 6
17750: PUSH
17751: LD_EXP 38
17755: PPUSH
17756: CALL_OW 251
17760: ST_TO_ADDR
// if depot then
17761: LD_VAR 0 4
17765: IFFALSE 17814
// begin ComEnterUnit ( Ibrahim , depot ) ;
17767: LD_EXP 38
17771: PPUSH
17772: LD_VAR 0 4
17776: PPUSH
17777: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17781: LD_INT 35
17783: PPUSH
17784: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17788: LD_EXP 38
17792: PPUSH
17793: CALL_OW 310
17797: IFFALSE 17781
// b := IsInUnit ( Ibrahim ) ;
17799: LD_ADDR_VAR 0 2
17803: PUSH
17804: LD_EXP 38
17808: PPUSH
17809: CALL_OW 310
17813: ST_TO_ADDR
// end ; RemoveUnit ( Ibrahim ) ;
17814: LD_EXP 38
17818: PPUSH
17819: CALL_OW 64
// uc_side := 2 ;
17823: LD_ADDR_OWVAR 20
17827: PUSH
17828: LD_INT 2
17830: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17831: LD_ADDR_EXP 38
17835: PUSH
17836: LD_STRING Ibrahim
17838: PPUSH
17839: LD_INT 0
17841: PPUSH
17842: LD_STRING 
17844: PPUSH
17845: CALL 313 0 3
17849: ST_TO_ADDR
// if depot then
17850: LD_VAR 0 4
17854: IFFALSE 17872
// PlaceHumanInUnit ( Ibrahim , b ) else
17856: LD_EXP 38
17860: PPUSH
17861: LD_VAR 0 2
17865: PPUSH
17866: CALL_OW 52
17870: GO 17894
// PlaceUnitXY ( Ibrahim , x , y , false ) ;
17872: LD_EXP 38
17876: PPUSH
17877: LD_VAR 0 5
17881: PPUSH
17882: LD_VAR 0 6
17886: PPUSH
17887: LD_INT 0
17889: PPUSH
17890: CALL_OW 48
// InGameOff ;
17894: CALL_OW 9
// allowConvoys := true ;
17898: LD_ADDR_EXP 12
17902: PUSH
17903: LD_INT 1
17905: ST_TO_ADDR
// SetAchievement ( ACH_IBRAHIM ) ;
17906: LD_STRING ACH_IBRAHIM
17908: PPUSH
17909: CALL_OW 543
// end ; end ;
17913: PPOPN 6
17915: END
// every 0 0$1 trigger GetLives ( Kaia ) < 3 do
17916: LD_EXP 33
17920: PPUSH
17921: CALL_OW 256
17925: PUSH
17926: LD_INT 3
17928: LESS
17929: IFFALSE 17996
17931: GO 17933
17933: DISABLE
// begin DialogueOn ;
17934: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
17938: LD_EXP 33
17942: PPUSH
17943: CALL_OW 87
// ForceSay ( Kaia , DK-keydeath-1 ) ;
17947: LD_EXP 33
17951: PPUSH
17952: LD_STRING DK-keydeath-1
17954: PPUSH
17955: CALL_OW 91
// Say ( Heike , DH-keydeath-2 ) ;
17959: LD_EXP 28
17963: PPUSH
17964: LD_STRING DH-keydeath-2
17966: PPUSH
17967: CALL_OW 88
// Say ( Heike , DH-keydeath-3 ) ;
17971: LD_EXP 28
17975: PPUSH
17976: LD_STRING DH-keydeath-3
17978: PPUSH
17979: CALL_OW 88
// DialogueOff ;
17983: CALL_OW 7
// KillUnit ( Kaia ) ;
17987: LD_EXP 33
17991: PPUSH
17992: CALL_OW 66
// end ;
17996: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 do
17997: LD_EXP 11
18001: PUSH
18002: LD_EXP 21
18006: PUSH
18007: LD_INT 1
18009: LESS
18010: AND
18011: PUSH
18012: LD_INT 22
18014: PUSH
18015: LD_INT 1
18017: PUSH
18018: EMPTY
18019: LIST
18020: LIST
18021: PUSH
18022: LD_INT 25
18024: PUSH
18025: LD_INT 1
18027: PUSH
18028: EMPTY
18029: LIST
18030: LIST
18031: PUSH
18032: EMPTY
18033: LIST
18034: LIST
18035: PPUSH
18036: CALL_OW 69
18040: PUSH
18041: LD_INT 0
18043: EQUAL
18044: AND
18045: IFFALSE 18436
18047: GO 18049
18049: DISABLE
// begin DialogueOn ;
18050: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
18054: LD_EXP 28
18058: PPUSH
18059: LD_STRING DH-1-final
18061: PPUSH
18062: CALL_OW 88
// if tick <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
18066: LD_OWVAR 1
18070: PUSH
18071: LD_INT 126000
18073: PUSH
18074: LD_INT 115500
18076: PUSH
18077: LD_INT 105000
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: LIST
18084: PUSH
18085: LD_OWVAR 67
18089: ARRAY
18090: LESSEQUAL
18091: IFFALSE 18105
// AddMedal ( med1 , 1 ) else
18093: LD_STRING med1
18095: PPUSH
18096: LD_INT 1
18098: PPUSH
18099: CALL_OW 101
18103: GO 18116
// AddMedal ( med1 , - 1 ) ;
18105: LD_STRING med1
18107: PPUSH
18108: LD_INT 1
18110: NEG
18111: PPUSH
18112: CALL_OW 101
// if vehCounter >= 2 then
18116: LD_EXP 22
18120: PUSH
18121: LD_INT 2
18123: GREATEREQUAL
18124: IFFALSE 18138
// AddMedal ( med2 , 1 ) else
18126: LD_STRING med2
18128: PPUSH
18129: LD_INT 1
18131: PPUSH
18132: CALL_OW 101
18136: GO 18149
// AddMedal ( med2 , - 1 ) ;
18138: LD_STRING med2
18140: PPUSH
18141: LD_INT 1
18143: NEG
18144: PPUSH
18145: CALL_OW 101
// if deadCounter = 0 then
18149: LD_EXP 9
18153: PUSH
18154: LD_INT 0
18156: EQUAL
18157: IFFALSE 18171
// AddMedal ( med3 , 1 ) else
18159: LD_STRING med3
18161: PPUSH
18162: LD_INT 1
18164: PPUSH
18165: CALL_OW 101
18169: GO 18182
// AddMedal ( med3 , - 1 ) ;
18171: LD_STRING med3
18173: PPUSH
18174: LD_INT 1
18176: NEG
18177: PPUSH
18178: CALL_OW 101
// GiveMedals ( MAIN ) ;
18182: LD_STRING MAIN
18184: PPUSH
18185: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
18189: LD_INT 22
18191: PUSH
18192: LD_INT 2
18194: PUSH
18195: EMPTY
18196: LIST
18197: LIST
18198: PUSH
18199: LD_INT 23
18201: PUSH
18202: LD_INT 2
18204: PUSH
18205: EMPTY
18206: LIST
18207: LIST
18208: PUSH
18209: LD_INT 21
18211: PUSH
18212: LD_INT 1
18214: PUSH
18215: EMPTY
18216: LIST
18217: LIST
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: LIST
18223: PPUSH
18224: CALL_OW 69
18228: PPUSH
18229: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
18233: LD_EXP 28
18237: PPUSH
18238: LD_STRING 03_Heike
18240: PPUSH
18241: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
18245: LD_EXP 32
18249: PPUSH
18250: LD_STRING 03_Aviradze
18252: PPUSH
18253: CALL_OW 38
// if Givi then
18257: LD_EXP 29
18261: IFFALSE 18275
// SaveCharacters ( Givi , 03_Givi ) ;
18263: LD_EXP 29
18267: PPUSH
18268: LD_STRING 03_Givi
18270: PPUSH
18271: CALL_OW 38
// if Mike then
18275: LD_EXP 30
18279: IFFALSE 18293
// SaveCharacters ( Mike , 03_Mike ) ;
18281: LD_EXP 30
18285: PPUSH
18286: LD_STRING 03_Mike
18288: PPUSH
18289: CALL_OW 38
// if Kamil then
18293: LD_EXP 31
18297: IFFALSE 18311
// SaveCharacters ( Kamil , 03_Kamil ) ;
18299: LD_EXP 31
18303: PPUSH
18304: LD_STRING 03_Kamil
18306: PPUSH
18307: CALL_OW 38
// if Kaia then
18311: LD_EXP 33
18315: IFFALSE 18329
// SaveCharacters ( Kaia , 03_Kaia ) ;
18317: LD_EXP 33
18321: PPUSH
18322: LD_STRING 03_Kaia
18324: PPUSH
18325: CALL_OW 38
// if Sophia then
18329: LD_EXP 34
18333: IFFALSE 18347
// SaveCharacters ( Sophia , 03_Sophia ) ;
18335: LD_EXP 34
18339: PPUSH
18340: LD_STRING 03_Sophia
18342: PPUSH
18343: CALL_OW 38
// if Markov then
18347: LD_EXP 35
18351: IFFALSE 18365
// SaveCharacters ( Markov , 03_Markov ) ;
18353: LD_EXP 35
18357: PPUSH
18358: LD_STRING 03_Markov
18360: PPUSH
18361: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
18365: LD_EXP 38
18369: PUSH
18370: LD_EXP 38
18374: PPUSH
18375: CALL_OW 255
18379: PUSH
18380: LD_INT 2
18382: EQUAL
18383: AND
18384: IFFALSE 18398
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
18386: LD_EXP 38
18390: PPUSH
18391: LD_STRING 03_Ibrahim
18393: PPUSH
18394: CALL_OW 38
// if heikeSecondSquad then
18398: LD_EXP 42
18402: IFFALSE 18416
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
18404: LD_EXP 42
18408: PPUSH
18409: LD_STRING 03_others
18411: PPUSH
18412: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
18416: LD_EXP 9
18420: PPUSH
18421: LD_STRING 03_DeadCounter
18423: PPUSH
18424: CALL_OW 39
// YouWin ;
18428: CALL_OW 103
// DialogueOff ;
18432: CALL_OW 7
// end ; end_of_file
18436: END
// on UnitDestroyed ( un ) do begin if un = Heike then
18437: LD_VAR 0 1
18441: PUSH
18442: LD_EXP 28
18446: EQUAL
18447: IFFALSE 18456
// YouLost ( Heike ) ;
18449: LD_STRING Heike
18451: PPUSH
18452: CALL_OW 104
// if un = Aviradze then
18456: LD_VAR 0 1
18460: PUSH
18461: LD_EXP 32
18465: EQUAL
18466: IFFALSE 18475
// YouLost ( Aviradze ) ;
18468: LD_STRING Aviradze
18470: PPUSH
18471: CALL_OW 104
// if un = usDepot and not retreatAllowed then
18475: LD_VAR 0 1
18479: PUSH
18480: LD_INT 11
18482: EQUAL
18483: PUSH
18484: LD_EXP 11
18488: NOT
18489: AND
18490: IFFALSE 18499
// YouLost ( Depot ) ;
18492: LD_STRING Depot
18494: PPUSH
18495: CALL_OW 104
// if un = arDepot then
18499: LD_VAR 0 1
18503: PUSH
18504: LD_INT 5
18506: EQUAL
18507: IFFALSE 18516
// YouLost ( FarmerDepot ) ;
18509: LD_STRING FarmerDepot
18511: PPUSH
18512: CALL_OW 104
// if un = Farmer then
18516: LD_VAR 0 1
18520: PUSH
18521: LD_EXP 36
18525: EQUAL
18526: IFFALSE 18535
// YouLost ( Farmer ) ;
18528: LD_STRING Farmer
18530: PPUSH
18531: CALL_OW 104
// if un in usForces then
18535: LD_VAR 0 1
18539: PUSH
18540: LD_EXP 44
18544: IN
18545: IFFALSE 18563
// usForces := usForces diff un ;
18547: LD_ADDR_EXP 44
18551: PUSH
18552: LD_EXP 44
18556: PUSH
18557: LD_VAR 0 1
18561: DIFF
18562: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
18563: LD_VAR 0 1
18567: PUSH
18568: LD_INT 22
18570: PUSH
18571: LD_INT 2
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: LD_INT 23
18580: PUSH
18581: LD_INT 2
18583: PUSH
18584: EMPTY
18585: LIST
18586: LIST
18587: PUSH
18588: LD_INT 21
18590: PUSH
18591: LD_INT 1
18593: PUSH
18594: EMPTY
18595: LIST
18596: LIST
18597: PUSH
18598: EMPTY
18599: LIST
18600: LIST
18601: LIST
18602: PPUSH
18603: CALL_OW 69
18607: IN
18608: IFFALSE 18624
// deadCounter := deadCounter + 1 ;
18610: LD_ADDR_EXP 9
18614: PUSH
18615: LD_EXP 9
18619: PUSH
18620: LD_INT 1
18622: PLUS
18623: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
18624: LD_VAR 0 1
18628: PUSH
18629: LD_INT 22
18631: PUSH
18632: LD_INT 4
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: PUSH
18639: LD_INT 34
18641: PUSH
18642: LD_INT 12
18644: PUSH
18645: EMPTY
18646: LIST
18647: LIST
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: PPUSH
18653: CALL_OW 69
18657: IN
18658: PUSH
18659: LD_EXP 18
18663: NOT
18664: AND
18665: IFFALSE 18675
// firstConvoyDestroyed := true ;
18667: LD_ADDR_EXP 18
18671: PUSH
18672: LD_INT 1
18674: ST_TO_ADDR
// if un in usAttackers then
18675: LD_VAR 0 1
18679: PUSH
18680: LD_EXP 47
18684: IN
18685: IFFALSE 18703
// usAttackers := usAttackers diff un ;
18687: LD_ADDR_EXP 47
18691: PUSH
18692: LD_EXP 47
18696: PUSH
18697: LD_VAR 0 1
18701: DIFF
18702: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) then
18703: LD_VAR 0 1
18707: PUSH
18708: LD_INT 22
18710: PUSH
18711: LD_INT 5
18713: PUSH
18714: EMPTY
18715: LIST
18716: LIST
18717: PUSH
18718: LD_INT 21
18720: PUSH
18721: LD_INT 1
18723: PUSH
18724: EMPTY
18725: LIST
18726: LIST
18727: PUSH
18728: EMPTY
18729: LIST
18730: LIST
18731: PPUSH
18732: CALL_OW 69
18736: IN
18737: IFFALSE 18753
// farmerHumanLoseCounter := farmerHumanLoseCounter + 1 ;
18739: LD_ADDR_EXP 20
18743: PUSH
18744: LD_EXP 20
18748: PUSH
18749: LD_INT 1
18751: PLUS
18752: ST_TO_ADDR
// end ;
18753: PPOPN 1
18755: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18756: LD_VAR 0 2
18760: PUSH
18761: LD_EXP 38
18765: EQUAL
18766: PUSH
18767: LD_EXP 25
18771: AND
18772: IFFALSE 18818
// begin Video ( true ) ;
18774: LD_INT 1
18776: PPUSH
18777: CALL 1036 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
18781: LD_EXP 38
18785: PPUSH
18786: LD_INT 11
18788: PPUSH
18789: CALL_OW 120
// repeat wait ( 3 ) ;
18793: LD_INT 3
18795: PPUSH
18796: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18800: LD_EXP 38
18804: PPUSH
18805: CALL_OW 310
18809: IFFALSE 18793
// Video ( false ) ;
18811: LD_INT 0
18813: PPUSH
18814: CALL 1036 0 1
// end ; end ;
18818: PPOPN 2
18820: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
18821: LD_VAR 0 2
18825: PUSH
18826: LD_EXP 28
18830: EQUAL
18831: PUSH
18832: LD_VAR 0 1
18836: PUSH
18837: LD_INT 11
18839: EQUAL
18840: AND
18841: PUSH
18842: LD_EXP 25
18846: AND
18847: IFFALSE 18853
// IbrahimQuery ;
18849: CALL 16704 0 0
// end ;
18853: PPOPN 2
18855: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin ComStop ( newId ) ;
18856: LD_VAR 0 1
18860: PPUSH
18861: CALL_OW 141
// if oldId in usAttackers then
18865: LD_VAR 0 2
18869: PUSH
18870: LD_EXP 47
18874: IN
18875: IFFALSE 18893
// usAttackers := usAttackers diff oldId ;
18877: LD_ADDR_EXP 47
18881: PUSH
18882: LD_EXP 47
18886: PUSH
18887: LD_VAR 0 2
18891: DIFF
18892: ST_TO_ADDR
// if newId in usAttackers then
18893: LD_VAR 0 1
18897: PUSH
18898: LD_EXP 47
18902: IN
18903: IFFALSE 18921
// usAttackers := usAttackers diff newId ;
18905: LD_ADDR_EXP 47
18909: PUSH
18910: LD_EXP 47
18914: PUSH
18915: LD_VAR 0 1
18919: DIFF
18920: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
18921: LD_VAR 0 3
18925: PUSH
18926: LD_INT 4
18928: EQUAL
18929: PUSH
18930: LD_EXP 18
18934: NOT
18935: AND
18936: IFFALSE 18946
// firstConvoyDestroyed := true ;
18938: LD_ADDR_EXP 18
18942: PUSH
18943: LD_INT 1
18945: ST_TO_ADDR
// if GetWeapon ( newId ) = us_cargo_bay then
18946: LD_VAR 0 1
18950: PPUSH
18951: CALL_OW 264
18955: PUSH
18956: LD_INT 12
18958: EQUAL
18959: IFFALSE 18997
// begin capturedCargoCounter := capturedCargoCounter + 1 ;
18961: LD_ADDR_EXP 13
18965: PUSH
18966: LD_EXP 13
18970: PUSH
18971: LD_INT 1
18973: PLUS
18974: ST_TO_ADDR
// if GetCargo ( newId , mat_cans ) = 0 then
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_INT 1
18982: PPUSH
18983: CALL_OW 289
18987: PUSH
18988: LD_INT 0
18990: EQUAL
18991: IFFALSE 18997
// EmptyCargoDialog ;
18993: CALL 15434 0 0
// end ; end ;
18997: PPOPN 4
18999: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
19000: LD_VAR 0 1
19004: PUSH
19005: LD_INT 2
19007: EQUAL
19008: PUSH
19009: LD_VAR 0 2
19013: PUSH
19014: LD_INT 5
19016: EQUAL
19017: AND
19018: IFFALSE 19027
// YouLost ( Attack ) ;
19020: LD_STRING Attack
19022: PPUSH
19023: CALL_OW 104
// end ;
19027: PPOPN 2
19029: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 and not americanBaseCaptured then
19030: LD_VAR 0 1
19034: PPUSH
19035: CALL_OW 255
19039: PUSH
19040: LD_INT 1
19042: EQUAL
19043: PUSH
19044: LD_EXP 6
19048: NOT
19049: AND
19050: IFFALSE 19184
// begin if GetBType ( b ) = b_lab then
19052: LD_VAR 0 1
19056: PPUSH
19057: CALL_OW 266
19061: PUSH
19062: LD_INT 6
19064: EQUAL
19065: IFFALSE 19105
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
19067: LD_EXP 44
19071: PPUSH
19072: LD_INT 25
19074: PUSH
19075: LD_INT 4
19077: PUSH
19078: EMPTY
19079: LIST
19080: LIST
19081: PPUSH
19082: CALL_OW 72
19086: PPUSH
19087: LD_VAR 0 1
19091: PPUSH
19092: CALL_OW 120
// AmLabResearch ( b ) ;
19096: LD_VAR 0 1
19100: PPUSH
19101: CALL 6086 0 1
// end ; if GetBType ( b ) = b_armoury then
19105: LD_VAR 0 1
19109: PPUSH
19110: CALL_OW 266
19114: PUSH
19115: LD_INT 4
19117: EQUAL
19118: IFFALSE 19166
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
19120: LD_EXP 44
19124: PPUSH
19125: LD_INT 25
19127: PUSH
19128: LD_INT 1
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: PUSH
19135: LD_INT 3
19137: PUSH
19138: LD_INT 54
19140: PUSH
19141: EMPTY
19142: LIST
19143: PUSH
19144: EMPTY
19145: LIST
19146: LIST
19147: PUSH
19148: EMPTY
19149: LIST
19150: LIST
19151: PPUSH
19152: CALL_OW 72
19156: PPUSH
19157: LD_VAR 0 1
19161: PPUSH
19162: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
19166: LD_ADDR_EXP 46
19170: PUSH
19171: LD_EXP 46
19175: PPUSH
19176: LD_INT 1
19178: PPUSH
19179: CALL_OW 3
19183: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
19184: LD_VAR 0 1
19188: PPUSH
19189: CALL_OW 255
19193: PUSH
19194: LD_INT 5
19196: EQUAL
19197: IFFALSE 19211
// SetBLevel ( b , 5 ) ;
19199: LD_VAR 0 1
19203: PPUSH
19204: LD_INT 5
19206: PPUSH
19207: CALL_OW 241
// end ;
19211: PPOPN 1
19213: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
19214: LD_VAR 0 1
19218: PPUSH
19219: CALL_OW 255
19223: PUSH
19224: LD_INT 2
19226: EQUAL
19227: IFFALSE 19243
// vehCounter := vehCounter + 1 ;
19229: LD_ADDR_EXP 22
19233: PUSH
19234: LD_EXP 22
19238: PUSH
19239: LD_INT 1
19241: PLUS
19242: ST_TO_ADDR
// end ;
19243: PPOPN 2
19245: END
// on SailEvent ( event ) do begin if event = eventAttack then
19246: LD_VAR 0 1
19250: PUSH
19251: LD_EXP 24
19255: EQUAL
19256: IFFALSE 19262
// AmericanAttack ;
19258: CALL 7534 0 0
// end ; end_of_file
19262: PPOPN 1
19264: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 5 5$00 , 4 4$40 , 4 4$30 ] [ Difficulty ] do
19265: LD_OWVAR 1
19269: PUSH
19270: LD_INT 10500
19272: PUSH
19273: LD_INT 9800
19275: PUSH
19276: LD_INT 9450
19278: PUSH
19279: EMPTY
19280: LIST
19281: LIST
19282: LIST
19283: PUSH
19284: LD_OWVAR 67
19288: ARRAY
19289: LESSEQUAL
19290: IFFALSE 19317
19292: GO 19294
19294: DISABLE
// begin enable ;
19295: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
19296: LD_INT 1
19298: PPUSH
19299: LD_INT 5
19301: PPUSH
19302: CALL_OW 12
19306: PPUSH
19307: LD_INT 9
19309: PPUSH
19310: LD_INT 1
19312: PPUSH
19313: CALL_OW 55
// end ;
19317: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 27 27$00 , 26 26$30 , 26 26$00 ] [ Difficulty ] do
19318: LD_EXP 6
19322: PUSH
19323: LD_OWVAR 1
19327: PUSH
19328: LD_INT 56700
19330: PUSH
19331: LD_INT 55650
19333: PUSH
19334: LD_INT 54600
19336: PUSH
19337: EMPTY
19338: LIST
19339: LIST
19340: LIST
19341: PUSH
19342: LD_OWVAR 67
19346: ARRAY
19347: LESSEQUAL
19348: AND
19349: IFFALSE 19376
19351: GO 19353
19353: DISABLE
// begin enable ;
19354: ENABLE
// CreateCratesArea ( rand ( 3 , 5 ) , cratesArea , true ) ;
19355: LD_INT 3
19357: PPUSH
19358: LD_INT 5
19360: PPUSH
19361: CALL_OW 12
19365: PPUSH
19366: LD_INT 9
19368: PPUSH
19369: LD_INT 1
19371: PPUSH
19372: CALL_OW 55
// end ; end_of_file
19376: END
// every 0 0$1 trigger not retreatAllowed and farmerRequestedCrates and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
19377: LD_EXP 11
19381: NOT
19382: PUSH
19383: LD_EXP 16
19387: AND
19388: PUSH
19389: LD_EXP 4
19393: AND
19394: PUSH
19395: LD_EXP 15
19399: PUSH
19400: LD_EXP 16
19404: LESSEQUAL
19405: AND
19406: IFFALSE 19496
19408: GO 19410
19410: DISABLE
// begin enable ;
19411: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
19412: LD_ADDR_OWVAR 47
19416: PUSH
19417: LD_STRING #X103-1
19419: PUSH
19420: LD_EXP 15
19424: PUSH
19425: LD_EXP 16
19429: PUSH
19430: EMPTY
19431: LIST
19432: LIST
19433: LIST
19434: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
19435: LD_ADDR_EXP 15
19439: PUSH
19440: LD_INT 5
19442: PPUSH
19443: CALL_OW 274
19447: PPUSH
19448: LD_INT 1
19450: PPUSH
19451: CALL_OW 275
19455: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
19456: LD_INT 10
19458: PPUSH
19459: LD_INT 1
19461: PPUSH
19462: CALL_OW 287
19466: PUSH
19467: LD_INT 0
19469: EQUAL
19470: IFFALSE 19488
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
19472: LD_ADDR_EXP 17
19476: PUSH
19477: LD_EXP 17
19481: PUSH
19482: LD_INT 35
19484: MINUS
19485: ST_TO_ADDR
19486: GO 19496
// farmerCratesCounter := 30 30$00 ;
19488: LD_ADDR_EXP 17
19492: PUSH
19493: LD_INT 63000
19495: ST_TO_ADDR
// end ; end_of_file
19496: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
19497: LD_INT 0
19499: PPUSH
// ar_crane := 88 ;
19500: LD_ADDR_EXP 54
19504: PUSH
19505: LD_INT 88
19507: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
19508: LD_ADDR_EXP 49
19512: PUSH
19513: LD_INT 89
19515: ST_TO_ADDR
// us_hack := 99 ;
19516: LD_ADDR_EXP 50
19520: PUSH
19521: LD_INT 99
19523: ST_TO_ADDR
// us_artillery := 97 ;
19524: LD_ADDR_EXP 51
19528: PUSH
19529: LD_INT 97
19531: ST_TO_ADDR
// ar_bio_bomb := 91 ;
19532: LD_ADDR_EXP 52
19536: PUSH
19537: LD_INT 91
19539: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
19540: LD_ADDR_EXP 53
19544: PUSH
19545: LD_INT 92
19547: ST_TO_ADDR
// ru_radar := 98 ;
19548: LD_ADDR_EXP 48
19552: PUSH
19553: LD_INT 98
19555: ST_TO_ADDR
// tech_Artillery := 80 ;
19556: LD_ADDR_EXP 55
19560: PUSH
19561: LD_INT 80
19563: ST_TO_ADDR
// tech_RadMat := 81 ;
19564: LD_ADDR_EXP 56
19568: PUSH
19569: LD_INT 81
19571: ST_TO_ADDR
// tech_BasicTools := 82 ;
19572: LD_ADDR_EXP 57
19576: PUSH
19577: LD_INT 82
19579: ST_TO_ADDR
// tech_Cargo := 83 ;
19580: LD_ADDR_EXP 58
19584: PUSH
19585: LD_INT 83
19587: ST_TO_ADDR
// tech_Track := 84 ;
19588: LD_ADDR_EXP 59
19592: PUSH
19593: LD_INT 84
19595: ST_TO_ADDR
// tech_Crane := 85 ;
19596: LD_ADDR_EXP 60
19600: PUSH
19601: LD_INT 85
19603: ST_TO_ADDR
// tech_Bulldozer := 86 ;
19604: LD_ADDR_EXP 61
19608: PUSH
19609: LD_INT 86
19611: ST_TO_ADDR
// tech_Hovercraft := 87 ;
19612: LD_ADDR_EXP 62
19616: PUSH
19617: LD_INT 87
19619: ST_TO_ADDR
// end ;
19620: LD_VAR 0 1
19624: RET
// every 1 do
19625: GO 19627
19627: DISABLE
// InitGlobalVariables ; end_of_file
19628: CALL 19497 0 0
19632: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
19633: LD_VAR 0 2
19637: PUSH
19638: LD_INT 100
19640: EQUAL
19641: IFFALSE 20590
// begin if not StreamModeActive then
19643: LD_EXP 63
19647: NOT
19648: IFFALSE 19658
// StreamModeActive := true ;
19650: LD_ADDR_EXP 63
19654: PUSH
19655: LD_INT 1
19657: ST_TO_ADDR
// if p3 = 0 then
19658: LD_VAR 0 3
19662: PUSH
19663: LD_INT 0
19665: EQUAL
19666: IFFALSE 19672
// InitStreamMode ;
19668: CALL 20823 0 0
// if p3 = 1 then
19672: LD_VAR 0 3
19676: PUSH
19677: LD_INT 1
19679: EQUAL
19680: IFFALSE 19690
// sRocket := true ;
19682: LD_ADDR_EXP 68
19686: PUSH
19687: LD_INT 1
19689: ST_TO_ADDR
// if p3 = 2 then
19690: LD_VAR 0 3
19694: PUSH
19695: LD_INT 2
19697: EQUAL
19698: IFFALSE 19708
// sSpeed := true ;
19700: LD_ADDR_EXP 67
19704: PUSH
19705: LD_INT 1
19707: ST_TO_ADDR
// if p3 = 3 then
19708: LD_VAR 0 3
19712: PUSH
19713: LD_INT 3
19715: EQUAL
19716: IFFALSE 19726
// sEngine := true ;
19718: LD_ADDR_EXP 69
19722: PUSH
19723: LD_INT 1
19725: ST_TO_ADDR
// if p3 = 4 then
19726: LD_VAR 0 3
19730: PUSH
19731: LD_INT 4
19733: EQUAL
19734: IFFALSE 19744
// sSpec := true ;
19736: LD_ADDR_EXP 66
19740: PUSH
19741: LD_INT 1
19743: ST_TO_ADDR
// if p3 = 5 then
19744: LD_VAR 0 3
19748: PUSH
19749: LD_INT 5
19751: EQUAL
19752: IFFALSE 19762
// sLevel := true ;
19754: LD_ADDR_EXP 70
19758: PUSH
19759: LD_INT 1
19761: ST_TO_ADDR
// if p3 = 6 then
19762: LD_VAR 0 3
19766: PUSH
19767: LD_INT 6
19769: EQUAL
19770: IFFALSE 19780
// sArmoury := true ;
19772: LD_ADDR_EXP 71
19776: PUSH
19777: LD_INT 1
19779: ST_TO_ADDR
// if p3 = 7 then
19780: LD_VAR 0 3
19784: PUSH
19785: LD_INT 7
19787: EQUAL
19788: IFFALSE 19798
// sRadar := true ;
19790: LD_ADDR_EXP 72
19794: PUSH
19795: LD_INT 1
19797: ST_TO_ADDR
// if p3 = 8 then
19798: LD_VAR 0 3
19802: PUSH
19803: LD_INT 8
19805: EQUAL
19806: IFFALSE 19816
// sBunker := true ;
19808: LD_ADDR_EXP 73
19812: PUSH
19813: LD_INT 1
19815: ST_TO_ADDR
// if p3 = 9 then
19816: LD_VAR 0 3
19820: PUSH
19821: LD_INT 9
19823: EQUAL
19824: IFFALSE 19834
// sHack := true ;
19826: LD_ADDR_EXP 74
19830: PUSH
19831: LD_INT 1
19833: ST_TO_ADDR
// if p3 = 10 then
19834: LD_VAR 0 3
19838: PUSH
19839: LD_INT 10
19841: EQUAL
19842: IFFALSE 19852
// sFire := true ;
19844: LD_ADDR_EXP 75
19848: PUSH
19849: LD_INT 1
19851: ST_TO_ADDR
// if p3 = 11 then
19852: LD_VAR 0 3
19856: PUSH
19857: LD_INT 11
19859: EQUAL
19860: IFFALSE 19870
// sRefresh := true ;
19862: LD_ADDR_EXP 76
19866: PUSH
19867: LD_INT 1
19869: ST_TO_ADDR
// if p3 = 12 then
19870: LD_VAR 0 3
19874: PUSH
19875: LD_INT 12
19877: EQUAL
19878: IFFALSE 19888
// sExp := true ;
19880: LD_ADDR_EXP 77
19884: PUSH
19885: LD_INT 1
19887: ST_TO_ADDR
// if p3 = 13 then
19888: LD_VAR 0 3
19892: PUSH
19893: LD_INT 13
19895: EQUAL
19896: IFFALSE 19906
// sDepot := true ;
19898: LD_ADDR_EXP 78
19902: PUSH
19903: LD_INT 1
19905: ST_TO_ADDR
// if p3 = 14 then
19906: LD_VAR 0 3
19910: PUSH
19911: LD_INT 14
19913: EQUAL
19914: IFFALSE 19924
// sFlag := true ;
19916: LD_ADDR_EXP 79
19920: PUSH
19921: LD_INT 1
19923: ST_TO_ADDR
// if p3 = 15 then
19924: LD_VAR 0 3
19928: PUSH
19929: LD_INT 15
19931: EQUAL
19932: IFFALSE 19942
// sKamikadze := true ;
19934: LD_ADDR_EXP 87
19938: PUSH
19939: LD_INT 1
19941: ST_TO_ADDR
// if p3 = 16 then
19942: LD_VAR 0 3
19946: PUSH
19947: LD_INT 16
19949: EQUAL
19950: IFFALSE 19960
// sTroll := true ;
19952: LD_ADDR_EXP 88
19956: PUSH
19957: LD_INT 1
19959: ST_TO_ADDR
// if p3 = 17 then
19960: LD_VAR 0 3
19964: PUSH
19965: LD_INT 17
19967: EQUAL
19968: IFFALSE 19978
// sSlow := true ;
19970: LD_ADDR_EXP 89
19974: PUSH
19975: LD_INT 1
19977: ST_TO_ADDR
// if p3 = 18 then
19978: LD_VAR 0 3
19982: PUSH
19983: LD_INT 18
19985: EQUAL
19986: IFFALSE 19996
// sLack := true ;
19988: LD_ADDR_EXP 90
19992: PUSH
19993: LD_INT 1
19995: ST_TO_ADDR
// if p3 = 19 then
19996: LD_VAR 0 3
20000: PUSH
20001: LD_INT 19
20003: EQUAL
20004: IFFALSE 20014
// sTank := true ;
20006: LD_ADDR_EXP 92
20010: PUSH
20011: LD_INT 1
20013: ST_TO_ADDR
// if p3 = 20 then
20014: LD_VAR 0 3
20018: PUSH
20019: LD_INT 20
20021: EQUAL
20022: IFFALSE 20032
// sRemote := true ;
20024: LD_ADDR_EXP 93
20028: PUSH
20029: LD_INT 1
20031: ST_TO_ADDR
// if p3 = 21 then
20032: LD_VAR 0 3
20036: PUSH
20037: LD_INT 21
20039: EQUAL
20040: IFFALSE 20050
// sPowell := true ;
20042: LD_ADDR_EXP 94
20046: PUSH
20047: LD_INT 1
20049: ST_TO_ADDR
// if p3 = 22 then
20050: LD_VAR 0 3
20054: PUSH
20055: LD_INT 22
20057: EQUAL
20058: IFFALSE 20068
// sTeleport := true ;
20060: LD_ADDR_EXP 97
20064: PUSH
20065: LD_INT 1
20067: ST_TO_ADDR
// if p3 = 23 then
20068: LD_VAR 0 3
20072: PUSH
20073: LD_INT 23
20075: EQUAL
20076: IFFALSE 20086
// sOilTower := true ;
20078: LD_ADDR_EXP 99
20082: PUSH
20083: LD_INT 1
20085: ST_TO_ADDR
// if p3 = 24 then
20086: LD_VAR 0 3
20090: PUSH
20091: LD_INT 24
20093: EQUAL
20094: IFFALSE 20104
// sShovel := true ;
20096: LD_ADDR_EXP 100
20100: PUSH
20101: LD_INT 1
20103: ST_TO_ADDR
// if p3 = 25 then
20104: LD_VAR 0 3
20108: PUSH
20109: LD_INT 25
20111: EQUAL
20112: IFFALSE 20122
// sSheik := true ;
20114: LD_ADDR_EXP 101
20118: PUSH
20119: LD_INT 1
20121: ST_TO_ADDR
// if p3 = 26 then
20122: LD_VAR 0 3
20126: PUSH
20127: LD_INT 26
20129: EQUAL
20130: IFFALSE 20140
// sEarthquake := true ;
20132: LD_ADDR_EXP 103
20136: PUSH
20137: LD_INT 1
20139: ST_TO_ADDR
// if p3 = 27 then
20140: LD_VAR 0 3
20144: PUSH
20145: LD_INT 27
20147: EQUAL
20148: IFFALSE 20158
// sAI := true ;
20150: LD_ADDR_EXP 104
20154: PUSH
20155: LD_INT 1
20157: ST_TO_ADDR
// if p3 = 28 then
20158: LD_VAR 0 3
20162: PUSH
20163: LD_INT 28
20165: EQUAL
20166: IFFALSE 20176
// sCargo := true ;
20168: LD_ADDR_EXP 107
20172: PUSH
20173: LD_INT 1
20175: ST_TO_ADDR
// if p3 = 29 then
20176: LD_VAR 0 3
20180: PUSH
20181: LD_INT 29
20183: EQUAL
20184: IFFALSE 20194
// sDLaser := true ;
20186: LD_ADDR_EXP 108
20190: PUSH
20191: LD_INT 1
20193: ST_TO_ADDR
// if p3 = 30 then
20194: LD_VAR 0 3
20198: PUSH
20199: LD_INT 30
20201: EQUAL
20202: IFFALSE 20212
// sExchange := true ;
20204: LD_ADDR_EXP 109
20208: PUSH
20209: LD_INT 1
20211: ST_TO_ADDR
// if p3 = 31 then
20212: LD_VAR 0 3
20216: PUSH
20217: LD_INT 31
20219: EQUAL
20220: IFFALSE 20230
// sFac := true ;
20222: LD_ADDR_EXP 110
20226: PUSH
20227: LD_INT 1
20229: ST_TO_ADDR
// if p3 = 32 then
20230: LD_VAR 0 3
20234: PUSH
20235: LD_INT 32
20237: EQUAL
20238: IFFALSE 20248
// sPower := true ;
20240: LD_ADDR_EXP 111
20244: PUSH
20245: LD_INT 1
20247: ST_TO_ADDR
// if p3 = 33 then
20248: LD_VAR 0 3
20252: PUSH
20253: LD_INT 33
20255: EQUAL
20256: IFFALSE 20266
// sRandom := true ;
20258: LD_ADDR_EXP 112
20262: PUSH
20263: LD_INT 1
20265: ST_TO_ADDR
// if p3 = 34 then
20266: LD_VAR 0 3
20270: PUSH
20271: LD_INT 34
20273: EQUAL
20274: IFFALSE 20284
// sShield := true ;
20276: LD_ADDR_EXP 113
20280: PUSH
20281: LD_INT 1
20283: ST_TO_ADDR
// if p3 = 35 then
20284: LD_VAR 0 3
20288: PUSH
20289: LD_INT 35
20291: EQUAL
20292: IFFALSE 20302
// sTime := true ;
20294: LD_ADDR_EXP 114
20298: PUSH
20299: LD_INT 1
20301: ST_TO_ADDR
// if p3 = 36 then
20302: LD_VAR 0 3
20306: PUSH
20307: LD_INT 36
20309: EQUAL
20310: IFFALSE 20320
// sTools := true ;
20312: LD_ADDR_EXP 115
20316: PUSH
20317: LD_INT 1
20319: ST_TO_ADDR
// if p3 = 101 then
20320: LD_VAR 0 3
20324: PUSH
20325: LD_INT 101
20327: EQUAL
20328: IFFALSE 20338
// sSold := true ;
20330: LD_ADDR_EXP 80
20334: PUSH
20335: LD_INT 1
20337: ST_TO_ADDR
// if p3 = 102 then
20338: LD_VAR 0 3
20342: PUSH
20343: LD_INT 102
20345: EQUAL
20346: IFFALSE 20356
// sDiff := true ;
20348: LD_ADDR_EXP 81
20352: PUSH
20353: LD_INT 1
20355: ST_TO_ADDR
// if p3 = 103 then
20356: LD_VAR 0 3
20360: PUSH
20361: LD_INT 103
20363: EQUAL
20364: IFFALSE 20374
// sFog := true ;
20366: LD_ADDR_EXP 84
20370: PUSH
20371: LD_INT 1
20373: ST_TO_ADDR
// if p3 = 104 then
20374: LD_VAR 0 3
20378: PUSH
20379: LD_INT 104
20381: EQUAL
20382: IFFALSE 20392
// sReset := true ;
20384: LD_ADDR_EXP 85
20388: PUSH
20389: LD_INT 1
20391: ST_TO_ADDR
// if p3 = 105 then
20392: LD_VAR 0 3
20396: PUSH
20397: LD_INT 105
20399: EQUAL
20400: IFFALSE 20410
// sSun := true ;
20402: LD_ADDR_EXP 86
20406: PUSH
20407: LD_INT 1
20409: ST_TO_ADDR
// if p3 = 106 then
20410: LD_VAR 0 3
20414: PUSH
20415: LD_INT 106
20417: EQUAL
20418: IFFALSE 20428
// sTiger := true ;
20420: LD_ADDR_EXP 82
20424: PUSH
20425: LD_INT 1
20427: ST_TO_ADDR
// if p3 = 107 then
20428: LD_VAR 0 3
20432: PUSH
20433: LD_INT 107
20435: EQUAL
20436: IFFALSE 20446
// sBomb := true ;
20438: LD_ADDR_EXP 83
20442: PUSH
20443: LD_INT 1
20445: ST_TO_ADDR
// if p3 = 108 then
20446: LD_VAR 0 3
20450: PUSH
20451: LD_INT 108
20453: EQUAL
20454: IFFALSE 20464
// sWound := true ;
20456: LD_ADDR_EXP 91
20460: PUSH
20461: LD_INT 1
20463: ST_TO_ADDR
// if p3 = 109 then
20464: LD_VAR 0 3
20468: PUSH
20469: LD_INT 109
20471: EQUAL
20472: IFFALSE 20482
// sBetray := true ;
20474: LD_ADDR_EXP 95
20478: PUSH
20479: LD_INT 1
20481: ST_TO_ADDR
// if p3 = 110 then
20482: LD_VAR 0 3
20486: PUSH
20487: LD_INT 110
20489: EQUAL
20490: IFFALSE 20500
// sContamin := true ;
20492: LD_ADDR_EXP 96
20496: PUSH
20497: LD_INT 1
20499: ST_TO_ADDR
// if p3 = 111 then
20500: LD_VAR 0 3
20504: PUSH
20505: LD_INT 111
20507: EQUAL
20508: IFFALSE 20518
// sOil := true ;
20510: LD_ADDR_EXP 98
20514: PUSH
20515: LD_INT 1
20517: ST_TO_ADDR
// if p3 = 112 then
20518: LD_VAR 0 3
20522: PUSH
20523: LD_INT 112
20525: EQUAL
20526: IFFALSE 20536
// sStu := true ;
20528: LD_ADDR_EXP 102
20532: PUSH
20533: LD_INT 1
20535: ST_TO_ADDR
// if p3 = 113 then
20536: LD_VAR 0 3
20540: PUSH
20541: LD_INT 113
20543: EQUAL
20544: IFFALSE 20554
// sBazooka := true ;
20546: LD_ADDR_EXP 105
20550: PUSH
20551: LD_INT 1
20553: ST_TO_ADDR
// if p3 = 114 then
20554: LD_VAR 0 3
20558: PUSH
20559: LD_INT 114
20561: EQUAL
20562: IFFALSE 20572
// sMortar := true ;
20564: LD_ADDR_EXP 106
20568: PUSH
20569: LD_INT 1
20571: ST_TO_ADDR
// if p3 = 115 then
20572: LD_VAR 0 3
20576: PUSH
20577: LD_INT 115
20579: EQUAL
20580: IFFALSE 20590
// sRanger := true ;
20582: LD_ADDR_EXP 116
20586: PUSH
20587: LD_INT 1
20589: ST_TO_ADDR
// end ; if p2 = 101 then
20590: LD_VAR 0 2
20594: PUSH
20595: LD_INT 101
20597: EQUAL
20598: IFFALSE 20801
// begin case p3 of 1 :
20600: LD_VAR 0 3
20604: PUSH
20605: LD_INT 1
20607: DOUBLE
20608: EQUAL
20609: IFTRUE 20613
20611: GO 20620
20613: POP
// hHackUnlimitedResources ; 2 :
20614: CALL 30895 0 0
20618: GO 20801
20620: LD_INT 2
20622: DOUBLE
20623: EQUAL
20624: IFTRUE 20628
20626: GO 20635
20628: POP
// hHackSetLevel10 ; 3 :
20629: CALL 31028 0 0
20633: GO 20801
20635: LD_INT 3
20637: DOUBLE
20638: EQUAL
20639: IFTRUE 20643
20641: GO 20650
20643: POP
// hHackSetLevel10YourUnits ; 4 :
20644: CALL 31113 0 0
20648: GO 20801
20650: LD_INT 4
20652: DOUBLE
20653: EQUAL
20654: IFTRUE 20658
20656: GO 20680
20658: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
20659: LD_VAR 0 4
20663: PPUSH
20664: LD_VAR 0 5
20668: PPUSH
20669: LD_VAR 0 6
20673: PPUSH
20674: CALL 31203 0 3
20678: GO 20801
20680: LD_INT 5
20682: DOUBLE
20683: EQUAL
20684: IFTRUE 20688
20686: GO 20695
20688: POP
// hHackSpawnVehicle ; 6 :
20689: CALL 31264 0 0
20693: GO 20801
20695: LD_INT 6
20697: DOUBLE
20698: EQUAL
20699: IFTRUE 20703
20701: GO 20710
20703: POP
// hHackInvincible ; 7 :
20704: CALL 31810 0 0
20708: GO 20801
20710: LD_INT 7
20712: DOUBLE
20713: EQUAL
20714: IFTRUE 20718
20716: GO 20725
20718: POP
// hHackInvisible ; 8 :
20719: CALL 31921 0 0
20723: GO 20801
20725: LD_INT 8
20727: DOUBLE
20728: EQUAL
20729: IFTRUE 20733
20731: GO 20740
20733: POP
// hHackChangeYourSide ; 9 :
20734: CALL 31978 0 0
20738: GO 20801
20740: LD_INT 9
20742: DOUBLE
20743: EQUAL
20744: IFTRUE 20748
20746: GO 20755
20748: POP
// hHackChangeUnitSide ; 10 :
20749: CALL 32020 0 0
20753: GO 20801
20755: LD_INT 10
20757: DOUBLE
20758: EQUAL
20759: IFTRUE 20763
20761: GO 20770
20763: POP
// hHackFog ; 11 :
20764: CALL 32121 0 0
20768: GO 20801
20770: LD_INT 11
20772: DOUBLE
20773: EQUAL
20774: IFTRUE 20778
20776: GO 20785
20778: POP
// hHackApeman ; 12 :
20779: CALL 32136 0 0
20783: GO 20801
20785: LD_INT 12
20787: DOUBLE
20788: EQUAL
20789: IFTRUE 20793
20791: GO 20800
20793: POP
// hHackBoom ; end ;
20794: CALL 32221 0 0
20798: GO 20801
20800: POP
// end ; end ;
20801: PPOPN 6
20803: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
20804: GO 20806
20806: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
20807: LD_STRING initStreamRollete();
20809: PPUSH
20810: CALL_OW 559
// InitStreamMode ;
20814: CALL 20823 0 0
// DefineStreamItems ( ) ;
20818: CALL 21263 0 0
// end ;
20822: END
// function InitStreamMode ; begin
20823: LD_INT 0
20825: PPUSH
// streamModeActive := false ;
20826: LD_ADDR_EXP 63
20830: PUSH
20831: LD_INT 0
20833: ST_TO_ADDR
// normalCounter := 36 ;
20834: LD_ADDR_EXP 64
20838: PUSH
20839: LD_INT 36
20841: ST_TO_ADDR
// hardcoreCounter := 16 ;
20842: LD_ADDR_EXP 65
20846: PUSH
20847: LD_INT 16
20849: ST_TO_ADDR
// sRocket := false ;
20850: LD_ADDR_EXP 68
20854: PUSH
20855: LD_INT 0
20857: ST_TO_ADDR
// sSpeed := false ;
20858: LD_ADDR_EXP 67
20862: PUSH
20863: LD_INT 0
20865: ST_TO_ADDR
// sEngine := false ;
20866: LD_ADDR_EXP 69
20870: PUSH
20871: LD_INT 0
20873: ST_TO_ADDR
// sSpec := false ;
20874: LD_ADDR_EXP 66
20878: PUSH
20879: LD_INT 0
20881: ST_TO_ADDR
// sLevel := false ;
20882: LD_ADDR_EXP 70
20886: PUSH
20887: LD_INT 0
20889: ST_TO_ADDR
// sArmoury := false ;
20890: LD_ADDR_EXP 71
20894: PUSH
20895: LD_INT 0
20897: ST_TO_ADDR
// sRadar := false ;
20898: LD_ADDR_EXP 72
20902: PUSH
20903: LD_INT 0
20905: ST_TO_ADDR
// sBunker := false ;
20906: LD_ADDR_EXP 73
20910: PUSH
20911: LD_INT 0
20913: ST_TO_ADDR
// sHack := false ;
20914: LD_ADDR_EXP 74
20918: PUSH
20919: LD_INT 0
20921: ST_TO_ADDR
// sFire := false ;
20922: LD_ADDR_EXP 75
20926: PUSH
20927: LD_INT 0
20929: ST_TO_ADDR
// sRefresh := false ;
20930: LD_ADDR_EXP 76
20934: PUSH
20935: LD_INT 0
20937: ST_TO_ADDR
// sExp := false ;
20938: LD_ADDR_EXP 77
20942: PUSH
20943: LD_INT 0
20945: ST_TO_ADDR
// sDepot := false ;
20946: LD_ADDR_EXP 78
20950: PUSH
20951: LD_INT 0
20953: ST_TO_ADDR
// sFlag := false ;
20954: LD_ADDR_EXP 79
20958: PUSH
20959: LD_INT 0
20961: ST_TO_ADDR
// sKamikadze := false ;
20962: LD_ADDR_EXP 87
20966: PUSH
20967: LD_INT 0
20969: ST_TO_ADDR
// sTroll := false ;
20970: LD_ADDR_EXP 88
20974: PUSH
20975: LD_INT 0
20977: ST_TO_ADDR
// sSlow := false ;
20978: LD_ADDR_EXP 89
20982: PUSH
20983: LD_INT 0
20985: ST_TO_ADDR
// sLack := false ;
20986: LD_ADDR_EXP 90
20990: PUSH
20991: LD_INT 0
20993: ST_TO_ADDR
// sTank := false ;
20994: LD_ADDR_EXP 92
20998: PUSH
20999: LD_INT 0
21001: ST_TO_ADDR
// sRemote := false ;
21002: LD_ADDR_EXP 93
21006: PUSH
21007: LD_INT 0
21009: ST_TO_ADDR
// sPowell := false ;
21010: LD_ADDR_EXP 94
21014: PUSH
21015: LD_INT 0
21017: ST_TO_ADDR
// sTeleport := false ;
21018: LD_ADDR_EXP 97
21022: PUSH
21023: LD_INT 0
21025: ST_TO_ADDR
// sOilTower := false ;
21026: LD_ADDR_EXP 99
21030: PUSH
21031: LD_INT 0
21033: ST_TO_ADDR
// sShovel := false ;
21034: LD_ADDR_EXP 100
21038: PUSH
21039: LD_INT 0
21041: ST_TO_ADDR
// sSheik := false ;
21042: LD_ADDR_EXP 101
21046: PUSH
21047: LD_INT 0
21049: ST_TO_ADDR
// sEarthquake := false ;
21050: LD_ADDR_EXP 103
21054: PUSH
21055: LD_INT 0
21057: ST_TO_ADDR
// sAI := false ;
21058: LD_ADDR_EXP 104
21062: PUSH
21063: LD_INT 0
21065: ST_TO_ADDR
// sCargo := false ;
21066: LD_ADDR_EXP 107
21070: PUSH
21071: LD_INT 0
21073: ST_TO_ADDR
// sDLaser := false ;
21074: LD_ADDR_EXP 108
21078: PUSH
21079: LD_INT 0
21081: ST_TO_ADDR
// sExchange := false ;
21082: LD_ADDR_EXP 109
21086: PUSH
21087: LD_INT 0
21089: ST_TO_ADDR
// sFac := false ;
21090: LD_ADDR_EXP 110
21094: PUSH
21095: LD_INT 0
21097: ST_TO_ADDR
// sPower := false ;
21098: LD_ADDR_EXP 111
21102: PUSH
21103: LD_INT 0
21105: ST_TO_ADDR
// sRandom := false ;
21106: LD_ADDR_EXP 112
21110: PUSH
21111: LD_INT 0
21113: ST_TO_ADDR
// sShield := false ;
21114: LD_ADDR_EXP 113
21118: PUSH
21119: LD_INT 0
21121: ST_TO_ADDR
// sTime := false ;
21122: LD_ADDR_EXP 114
21126: PUSH
21127: LD_INT 0
21129: ST_TO_ADDR
// sTools := false ;
21130: LD_ADDR_EXP 115
21134: PUSH
21135: LD_INT 0
21137: ST_TO_ADDR
// sSold := false ;
21138: LD_ADDR_EXP 80
21142: PUSH
21143: LD_INT 0
21145: ST_TO_ADDR
// sDiff := false ;
21146: LD_ADDR_EXP 81
21150: PUSH
21151: LD_INT 0
21153: ST_TO_ADDR
// sFog := false ;
21154: LD_ADDR_EXP 84
21158: PUSH
21159: LD_INT 0
21161: ST_TO_ADDR
// sReset := false ;
21162: LD_ADDR_EXP 85
21166: PUSH
21167: LD_INT 0
21169: ST_TO_ADDR
// sSun := false ;
21170: LD_ADDR_EXP 86
21174: PUSH
21175: LD_INT 0
21177: ST_TO_ADDR
// sTiger := false ;
21178: LD_ADDR_EXP 82
21182: PUSH
21183: LD_INT 0
21185: ST_TO_ADDR
// sBomb := false ;
21186: LD_ADDR_EXP 83
21190: PUSH
21191: LD_INT 0
21193: ST_TO_ADDR
// sWound := false ;
21194: LD_ADDR_EXP 91
21198: PUSH
21199: LD_INT 0
21201: ST_TO_ADDR
// sBetray := false ;
21202: LD_ADDR_EXP 95
21206: PUSH
21207: LD_INT 0
21209: ST_TO_ADDR
// sContamin := false ;
21210: LD_ADDR_EXP 96
21214: PUSH
21215: LD_INT 0
21217: ST_TO_ADDR
// sOil := false ;
21218: LD_ADDR_EXP 98
21222: PUSH
21223: LD_INT 0
21225: ST_TO_ADDR
// sStu := false ;
21226: LD_ADDR_EXP 102
21230: PUSH
21231: LD_INT 0
21233: ST_TO_ADDR
// sBazooka := false ;
21234: LD_ADDR_EXP 105
21238: PUSH
21239: LD_INT 0
21241: ST_TO_ADDR
// sMortar := false ;
21242: LD_ADDR_EXP 106
21246: PUSH
21247: LD_INT 0
21249: ST_TO_ADDR
// sRanger := false ;
21250: LD_ADDR_EXP 116
21254: PUSH
21255: LD_INT 0
21257: ST_TO_ADDR
// end ;
21258: LD_VAR 0 1
21262: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
21263: LD_INT 0
21265: PPUSH
21266: PPUSH
21267: PPUSH
21268: PPUSH
21269: PPUSH
// result := [ ] ;
21270: LD_ADDR_VAR 0 1
21274: PUSH
21275: EMPTY
21276: ST_TO_ADDR
// if campaign_id = 1 then
21277: LD_OWVAR 69
21281: PUSH
21282: LD_INT 1
21284: EQUAL
21285: IFFALSE 24223
// begin case mission_number of 1 :
21287: LD_OWVAR 70
21291: PUSH
21292: LD_INT 1
21294: DOUBLE
21295: EQUAL
21296: IFTRUE 21300
21298: GO 21364
21300: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
21301: LD_ADDR_VAR 0 1
21305: PUSH
21306: LD_INT 2
21308: PUSH
21309: LD_INT 4
21311: PUSH
21312: LD_INT 11
21314: PUSH
21315: LD_INT 12
21317: PUSH
21318: LD_INT 15
21320: PUSH
21321: LD_INT 16
21323: PUSH
21324: LD_INT 22
21326: PUSH
21327: LD_INT 23
21329: PUSH
21330: LD_INT 26
21332: PUSH
21333: EMPTY
21334: LIST
21335: LIST
21336: LIST
21337: LIST
21338: LIST
21339: LIST
21340: LIST
21341: LIST
21342: LIST
21343: PUSH
21344: LD_INT 101
21346: PUSH
21347: LD_INT 102
21349: PUSH
21350: LD_INT 106
21352: PUSH
21353: EMPTY
21354: LIST
21355: LIST
21356: LIST
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: ST_TO_ADDR
21362: GO 24221
21364: LD_INT 2
21366: DOUBLE
21367: EQUAL
21368: IFTRUE 21372
21370: GO 21444
21372: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
21373: LD_ADDR_VAR 0 1
21377: PUSH
21378: LD_INT 2
21380: PUSH
21381: LD_INT 4
21383: PUSH
21384: LD_INT 11
21386: PUSH
21387: LD_INT 12
21389: PUSH
21390: LD_INT 15
21392: PUSH
21393: LD_INT 16
21395: PUSH
21396: LD_INT 22
21398: PUSH
21399: LD_INT 23
21401: PUSH
21402: LD_INT 26
21404: PUSH
21405: EMPTY
21406: LIST
21407: LIST
21408: LIST
21409: LIST
21410: LIST
21411: LIST
21412: LIST
21413: LIST
21414: LIST
21415: PUSH
21416: LD_INT 101
21418: PUSH
21419: LD_INT 102
21421: PUSH
21422: LD_INT 105
21424: PUSH
21425: LD_INT 106
21427: PUSH
21428: LD_INT 108
21430: PUSH
21431: EMPTY
21432: LIST
21433: LIST
21434: LIST
21435: LIST
21436: LIST
21437: PUSH
21438: EMPTY
21439: LIST
21440: LIST
21441: ST_TO_ADDR
21442: GO 24221
21444: LD_INT 3
21446: DOUBLE
21447: EQUAL
21448: IFTRUE 21452
21450: GO 21528
21452: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
21453: LD_ADDR_VAR 0 1
21457: PUSH
21458: LD_INT 2
21460: PUSH
21461: LD_INT 4
21463: PUSH
21464: LD_INT 5
21466: PUSH
21467: LD_INT 11
21469: PUSH
21470: LD_INT 12
21472: PUSH
21473: LD_INT 15
21475: PUSH
21476: LD_INT 16
21478: PUSH
21479: LD_INT 22
21481: PUSH
21482: LD_INT 26
21484: PUSH
21485: LD_INT 36
21487: PUSH
21488: EMPTY
21489: LIST
21490: LIST
21491: LIST
21492: LIST
21493: LIST
21494: LIST
21495: LIST
21496: LIST
21497: LIST
21498: LIST
21499: PUSH
21500: LD_INT 101
21502: PUSH
21503: LD_INT 102
21505: PUSH
21506: LD_INT 105
21508: PUSH
21509: LD_INT 106
21511: PUSH
21512: LD_INT 108
21514: PUSH
21515: EMPTY
21516: LIST
21517: LIST
21518: LIST
21519: LIST
21520: LIST
21521: PUSH
21522: EMPTY
21523: LIST
21524: LIST
21525: ST_TO_ADDR
21526: GO 24221
21528: LD_INT 4
21530: DOUBLE
21531: EQUAL
21532: IFTRUE 21536
21534: GO 21620
21536: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
21537: LD_ADDR_VAR 0 1
21541: PUSH
21542: LD_INT 2
21544: PUSH
21545: LD_INT 4
21547: PUSH
21548: LD_INT 5
21550: PUSH
21551: LD_INT 8
21553: PUSH
21554: LD_INT 11
21556: PUSH
21557: LD_INT 12
21559: PUSH
21560: LD_INT 15
21562: PUSH
21563: LD_INT 16
21565: PUSH
21566: LD_INT 22
21568: PUSH
21569: LD_INT 23
21571: PUSH
21572: LD_INT 26
21574: PUSH
21575: LD_INT 36
21577: PUSH
21578: EMPTY
21579: LIST
21580: LIST
21581: LIST
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: LIST
21591: PUSH
21592: LD_INT 101
21594: PUSH
21595: LD_INT 102
21597: PUSH
21598: LD_INT 105
21600: PUSH
21601: LD_INT 106
21603: PUSH
21604: LD_INT 108
21606: PUSH
21607: EMPTY
21608: LIST
21609: LIST
21610: LIST
21611: LIST
21612: LIST
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: ST_TO_ADDR
21618: GO 24221
21620: LD_INT 5
21622: DOUBLE
21623: EQUAL
21624: IFTRUE 21628
21626: GO 21728
21628: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
21629: LD_ADDR_VAR 0 1
21633: PUSH
21634: LD_INT 2
21636: PUSH
21637: LD_INT 4
21639: PUSH
21640: LD_INT 5
21642: PUSH
21643: LD_INT 6
21645: PUSH
21646: LD_INT 8
21648: PUSH
21649: LD_INT 11
21651: PUSH
21652: LD_INT 12
21654: PUSH
21655: LD_INT 15
21657: PUSH
21658: LD_INT 16
21660: PUSH
21661: LD_INT 22
21663: PUSH
21664: LD_INT 23
21666: PUSH
21667: LD_INT 25
21669: PUSH
21670: LD_INT 26
21672: PUSH
21673: LD_INT 36
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: LIST
21680: LIST
21681: LIST
21682: LIST
21683: LIST
21684: LIST
21685: LIST
21686: LIST
21687: LIST
21688: LIST
21689: LIST
21690: LIST
21691: PUSH
21692: LD_INT 101
21694: PUSH
21695: LD_INT 102
21697: PUSH
21698: LD_INT 105
21700: PUSH
21701: LD_INT 106
21703: PUSH
21704: LD_INT 108
21706: PUSH
21707: LD_INT 109
21709: PUSH
21710: LD_INT 112
21712: PUSH
21713: EMPTY
21714: LIST
21715: LIST
21716: LIST
21717: LIST
21718: LIST
21719: LIST
21720: LIST
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: ST_TO_ADDR
21726: GO 24221
21728: LD_INT 6
21730: DOUBLE
21731: EQUAL
21732: IFTRUE 21736
21734: GO 21856
21736: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
21737: LD_ADDR_VAR 0 1
21741: PUSH
21742: LD_INT 2
21744: PUSH
21745: LD_INT 4
21747: PUSH
21748: LD_INT 5
21750: PUSH
21751: LD_INT 6
21753: PUSH
21754: LD_INT 8
21756: PUSH
21757: LD_INT 11
21759: PUSH
21760: LD_INT 12
21762: PUSH
21763: LD_INT 15
21765: PUSH
21766: LD_INT 16
21768: PUSH
21769: LD_INT 20
21771: PUSH
21772: LD_INT 21
21774: PUSH
21775: LD_INT 22
21777: PUSH
21778: LD_INT 23
21780: PUSH
21781: LD_INT 25
21783: PUSH
21784: LD_INT 26
21786: PUSH
21787: LD_INT 30
21789: PUSH
21790: LD_INT 31
21792: PUSH
21793: LD_INT 32
21795: PUSH
21796: LD_INT 36
21798: PUSH
21799: EMPTY
21800: LIST
21801: LIST
21802: LIST
21803: LIST
21804: LIST
21805: LIST
21806: LIST
21807: LIST
21808: LIST
21809: LIST
21810: LIST
21811: LIST
21812: LIST
21813: LIST
21814: LIST
21815: LIST
21816: LIST
21817: LIST
21818: LIST
21819: PUSH
21820: LD_INT 101
21822: PUSH
21823: LD_INT 102
21825: PUSH
21826: LD_INT 105
21828: PUSH
21829: LD_INT 106
21831: PUSH
21832: LD_INT 108
21834: PUSH
21835: LD_INT 109
21837: PUSH
21838: LD_INT 112
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: LIST
21845: LIST
21846: LIST
21847: LIST
21848: LIST
21849: PUSH
21850: EMPTY
21851: LIST
21852: LIST
21853: ST_TO_ADDR
21854: GO 24221
21856: LD_INT 7
21858: DOUBLE
21859: EQUAL
21860: IFTRUE 21864
21862: GO 21964
21864: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
21865: LD_ADDR_VAR 0 1
21869: PUSH
21870: LD_INT 2
21872: PUSH
21873: LD_INT 4
21875: PUSH
21876: LD_INT 5
21878: PUSH
21879: LD_INT 7
21881: PUSH
21882: LD_INT 11
21884: PUSH
21885: LD_INT 12
21887: PUSH
21888: LD_INT 15
21890: PUSH
21891: LD_INT 16
21893: PUSH
21894: LD_INT 20
21896: PUSH
21897: LD_INT 21
21899: PUSH
21900: LD_INT 22
21902: PUSH
21903: LD_INT 23
21905: PUSH
21906: LD_INT 25
21908: PUSH
21909: LD_INT 26
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: LIST
21916: LIST
21917: LIST
21918: LIST
21919: LIST
21920: LIST
21921: LIST
21922: LIST
21923: LIST
21924: LIST
21925: LIST
21926: LIST
21927: PUSH
21928: LD_INT 101
21930: PUSH
21931: LD_INT 102
21933: PUSH
21934: LD_INT 103
21936: PUSH
21937: LD_INT 105
21939: PUSH
21940: LD_INT 106
21942: PUSH
21943: LD_INT 108
21945: PUSH
21946: LD_INT 112
21948: PUSH
21949: EMPTY
21950: LIST
21951: LIST
21952: LIST
21953: LIST
21954: LIST
21955: LIST
21956: LIST
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: ST_TO_ADDR
21962: GO 24221
21964: LD_INT 8
21966: DOUBLE
21967: EQUAL
21968: IFTRUE 21972
21970: GO 22100
21972: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
21973: LD_ADDR_VAR 0 1
21977: PUSH
21978: LD_INT 2
21980: PUSH
21981: LD_INT 4
21983: PUSH
21984: LD_INT 5
21986: PUSH
21987: LD_INT 6
21989: PUSH
21990: LD_INT 7
21992: PUSH
21993: LD_INT 8
21995: PUSH
21996: LD_INT 11
21998: PUSH
21999: LD_INT 12
22001: PUSH
22002: LD_INT 15
22004: PUSH
22005: LD_INT 16
22007: PUSH
22008: LD_INT 20
22010: PUSH
22011: LD_INT 21
22013: PUSH
22014: LD_INT 22
22016: PUSH
22017: LD_INT 23
22019: PUSH
22020: LD_INT 25
22022: PUSH
22023: LD_INT 26
22025: PUSH
22026: LD_INT 30
22028: PUSH
22029: LD_INT 31
22031: PUSH
22032: LD_INT 32
22034: PUSH
22035: LD_INT 36
22037: PUSH
22038: EMPTY
22039: LIST
22040: LIST
22041: LIST
22042: LIST
22043: LIST
22044: LIST
22045: LIST
22046: LIST
22047: LIST
22048: LIST
22049: LIST
22050: LIST
22051: LIST
22052: LIST
22053: LIST
22054: LIST
22055: LIST
22056: LIST
22057: LIST
22058: LIST
22059: PUSH
22060: LD_INT 101
22062: PUSH
22063: LD_INT 102
22065: PUSH
22066: LD_INT 103
22068: PUSH
22069: LD_INT 105
22071: PUSH
22072: LD_INT 106
22074: PUSH
22075: LD_INT 108
22077: PUSH
22078: LD_INT 109
22080: PUSH
22081: LD_INT 112
22083: PUSH
22084: EMPTY
22085: LIST
22086: LIST
22087: LIST
22088: LIST
22089: LIST
22090: LIST
22091: LIST
22092: LIST
22093: PUSH
22094: EMPTY
22095: LIST
22096: LIST
22097: ST_TO_ADDR
22098: GO 24221
22100: LD_INT 9
22102: DOUBLE
22103: EQUAL
22104: IFTRUE 22108
22106: GO 22244
22108: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
22109: LD_ADDR_VAR 0 1
22113: PUSH
22114: LD_INT 2
22116: PUSH
22117: LD_INT 4
22119: PUSH
22120: LD_INT 5
22122: PUSH
22123: LD_INT 6
22125: PUSH
22126: LD_INT 7
22128: PUSH
22129: LD_INT 8
22131: PUSH
22132: LD_INT 11
22134: PUSH
22135: LD_INT 12
22137: PUSH
22138: LD_INT 15
22140: PUSH
22141: LD_INT 16
22143: PUSH
22144: LD_INT 20
22146: PUSH
22147: LD_INT 21
22149: PUSH
22150: LD_INT 22
22152: PUSH
22153: LD_INT 23
22155: PUSH
22156: LD_INT 25
22158: PUSH
22159: LD_INT 26
22161: PUSH
22162: LD_INT 28
22164: PUSH
22165: LD_INT 30
22167: PUSH
22168: LD_INT 31
22170: PUSH
22171: LD_INT 32
22173: PUSH
22174: LD_INT 36
22176: PUSH
22177: EMPTY
22178: LIST
22179: LIST
22180: LIST
22181: LIST
22182: LIST
22183: LIST
22184: LIST
22185: LIST
22186: LIST
22187: LIST
22188: LIST
22189: LIST
22190: LIST
22191: LIST
22192: LIST
22193: LIST
22194: LIST
22195: LIST
22196: LIST
22197: LIST
22198: LIST
22199: PUSH
22200: LD_INT 101
22202: PUSH
22203: LD_INT 102
22205: PUSH
22206: LD_INT 103
22208: PUSH
22209: LD_INT 105
22211: PUSH
22212: LD_INT 106
22214: PUSH
22215: LD_INT 108
22217: PUSH
22218: LD_INT 109
22220: PUSH
22221: LD_INT 112
22223: PUSH
22224: LD_INT 114
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: LIST
22231: LIST
22232: LIST
22233: LIST
22234: LIST
22235: LIST
22236: LIST
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: ST_TO_ADDR
22242: GO 24221
22244: LD_INT 10
22246: DOUBLE
22247: EQUAL
22248: IFTRUE 22252
22250: GO 22436
22252: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
22253: LD_ADDR_VAR 0 1
22257: PUSH
22258: LD_INT 2
22260: PUSH
22261: LD_INT 4
22263: PUSH
22264: LD_INT 5
22266: PUSH
22267: LD_INT 6
22269: PUSH
22270: LD_INT 7
22272: PUSH
22273: LD_INT 8
22275: PUSH
22276: LD_INT 9
22278: PUSH
22279: LD_INT 10
22281: PUSH
22282: LD_INT 11
22284: PUSH
22285: LD_INT 12
22287: PUSH
22288: LD_INT 13
22290: PUSH
22291: LD_INT 14
22293: PUSH
22294: LD_INT 15
22296: PUSH
22297: LD_INT 16
22299: PUSH
22300: LD_INT 17
22302: PUSH
22303: LD_INT 18
22305: PUSH
22306: LD_INT 19
22308: PUSH
22309: LD_INT 20
22311: PUSH
22312: LD_INT 21
22314: PUSH
22315: LD_INT 22
22317: PUSH
22318: LD_INT 23
22320: PUSH
22321: LD_INT 24
22323: PUSH
22324: LD_INT 25
22326: PUSH
22327: LD_INT 26
22329: PUSH
22330: LD_INT 28
22332: PUSH
22333: LD_INT 30
22335: PUSH
22336: LD_INT 31
22338: PUSH
22339: LD_INT 32
22341: PUSH
22342: LD_INT 36
22344: PUSH
22345: EMPTY
22346: LIST
22347: LIST
22348: LIST
22349: LIST
22350: LIST
22351: LIST
22352: LIST
22353: LIST
22354: LIST
22355: LIST
22356: LIST
22357: LIST
22358: LIST
22359: LIST
22360: LIST
22361: LIST
22362: LIST
22363: LIST
22364: LIST
22365: LIST
22366: LIST
22367: LIST
22368: LIST
22369: LIST
22370: LIST
22371: LIST
22372: LIST
22373: LIST
22374: LIST
22375: PUSH
22376: LD_INT 101
22378: PUSH
22379: LD_INT 102
22381: PUSH
22382: LD_INT 103
22384: PUSH
22385: LD_INT 104
22387: PUSH
22388: LD_INT 105
22390: PUSH
22391: LD_INT 106
22393: PUSH
22394: LD_INT 107
22396: PUSH
22397: LD_INT 108
22399: PUSH
22400: LD_INT 109
22402: PUSH
22403: LD_INT 110
22405: PUSH
22406: LD_INT 111
22408: PUSH
22409: LD_INT 112
22411: PUSH
22412: LD_INT 114
22414: PUSH
22415: EMPTY
22416: LIST
22417: LIST
22418: LIST
22419: LIST
22420: LIST
22421: LIST
22422: LIST
22423: LIST
22424: LIST
22425: LIST
22426: LIST
22427: LIST
22428: LIST
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: ST_TO_ADDR
22434: GO 24221
22436: LD_INT 11
22438: DOUBLE
22439: EQUAL
22440: IFTRUE 22444
22442: GO 22636
22444: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
22445: LD_ADDR_VAR 0 1
22449: PUSH
22450: LD_INT 2
22452: PUSH
22453: LD_INT 3
22455: PUSH
22456: LD_INT 4
22458: PUSH
22459: LD_INT 5
22461: PUSH
22462: LD_INT 6
22464: PUSH
22465: LD_INT 7
22467: PUSH
22468: LD_INT 8
22470: PUSH
22471: LD_INT 9
22473: PUSH
22474: LD_INT 10
22476: PUSH
22477: LD_INT 11
22479: PUSH
22480: LD_INT 12
22482: PUSH
22483: LD_INT 13
22485: PUSH
22486: LD_INT 14
22488: PUSH
22489: LD_INT 15
22491: PUSH
22492: LD_INT 16
22494: PUSH
22495: LD_INT 17
22497: PUSH
22498: LD_INT 18
22500: PUSH
22501: LD_INT 19
22503: PUSH
22504: LD_INT 20
22506: PUSH
22507: LD_INT 21
22509: PUSH
22510: LD_INT 22
22512: PUSH
22513: LD_INT 23
22515: PUSH
22516: LD_INT 24
22518: PUSH
22519: LD_INT 25
22521: PUSH
22522: LD_INT 26
22524: PUSH
22525: LD_INT 28
22527: PUSH
22528: LD_INT 30
22530: PUSH
22531: LD_INT 31
22533: PUSH
22534: LD_INT 32
22536: PUSH
22537: LD_INT 34
22539: PUSH
22540: LD_INT 36
22542: PUSH
22543: EMPTY
22544: LIST
22545: LIST
22546: LIST
22547: LIST
22548: LIST
22549: LIST
22550: LIST
22551: LIST
22552: LIST
22553: LIST
22554: LIST
22555: LIST
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: LIST
22561: LIST
22562: LIST
22563: LIST
22564: LIST
22565: LIST
22566: LIST
22567: LIST
22568: LIST
22569: LIST
22570: LIST
22571: LIST
22572: LIST
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 101
22578: PUSH
22579: LD_INT 102
22581: PUSH
22582: LD_INT 103
22584: PUSH
22585: LD_INT 104
22587: PUSH
22588: LD_INT 105
22590: PUSH
22591: LD_INT 106
22593: PUSH
22594: LD_INT 107
22596: PUSH
22597: LD_INT 108
22599: PUSH
22600: LD_INT 109
22602: PUSH
22603: LD_INT 110
22605: PUSH
22606: LD_INT 111
22608: PUSH
22609: LD_INT 112
22611: PUSH
22612: LD_INT 114
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: LIST
22619: LIST
22620: LIST
22621: LIST
22622: LIST
22623: LIST
22624: LIST
22625: LIST
22626: LIST
22627: LIST
22628: LIST
22629: PUSH
22630: EMPTY
22631: LIST
22632: LIST
22633: ST_TO_ADDR
22634: GO 24221
22636: LD_INT 12
22638: DOUBLE
22639: EQUAL
22640: IFTRUE 22644
22642: GO 22852
22644: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
22645: LD_ADDR_VAR 0 1
22649: PUSH
22650: LD_INT 1
22652: PUSH
22653: LD_INT 2
22655: PUSH
22656: LD_INT 3
22658: PUSH
22659: LD_INT 4
22661: PUSH
22662: LD_INT 5
22664: PUSH
22665: LD_INT 6
22667: PUSH
22668: LD_INT 7
22670: PUSH
22671: LD_INT 8
22673: PUSH
22674: LD_INT 9
22676: PUSH
22677: LD_INT 10
22679: PUSH
22680: LD_INT 11
22682: PUSH
22683: LD_INT 12
22685: PUSH
22686: LD_INT 13
22688: PUSH
22689: LD_INT 14
22691: PUSH
22692: LD_INT 15
22694: PUSH
22695: LD_INT 16
22697: PUSH
22698: LD_INT 17
22700: PUSH
22701: LD_INT 18
22703: PUSH
22704: LD_INT 19
22706: PUSH
22707: LD_INT 20
22709: PUSH
22710: LD_INT 21
22712: PUSH
22713: LD_INT 22
22715: PUSH
22716: LD_INT 23
22718: PUSH
22719: LD_INT 24
22721: PUSH
22722: LD_INT 25
22724: PUSH
22725: LD_INT 26
22727: PUSH
22728: LD_INT 27
22730: PUSH
22731: LD_INT 28
22733: PUSH
22734: LD_INT 30
22736: PUSH
22737: LD_INT 31
22739: PUSH
22740: LD_INT 32
22742: PUSH
22743: LD_INT 33
22745: PUSH
22746: LD_INT 34
22748: PUSH
22749: LD_INT 36
22751: PUSH
22752: EMPTY
22753: LIST
22754: LIST
22755: LIST
22756: LIST
22757: LIST
22758: LIST
22759: LIST
22760: LIST
22761: LIST
22762: LIST
22763: LIST
22764: LIST
22765: LIST
22766: LIST
22767: LIST
22768: LIST
22769: LIST
22770: LIST
22771: LIST
22772: LIST
22773: LIST
22774: LIST
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: LIST
22780: LIST
22781: LIST
22782: LIST
22783: LIST
22784: LIST
22785: LIST
22786: LIST
22787: PUSH
22788: LD_INT 101
22790: PUSH
22791: LD_INT 102
22793: PUSH
22794: LD_INT 103
22796: PUSH
22797: LD_INT 104
22799: PUSH
22800: LD_INT 105
22802: PUSH
22803: LD_INT 106
22805: PUSH
22806: LD_INT 107
22808: PUSH
22809: LD_INT 108
22811: PUSH
22812: LD_INT 109
22814: PUSH
22815: LD_INT 110
22817: PUSH
22818: LD_INT 111
22820: PUSH
22821: LD_INT 112
22823: PUSH
22824: LD_INT 113
22826: PUSH
22827: LD_INT 114
22829: PUSH
22830: EMPTY
22831: LIST
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: LIST
22841: LIST
22842: LIST
22843: LIST
22844: LIST
22845: PUSH
22846: EMPTY
22847: LIST
22848: LIST
22849: ST_TO_ADDR
22850: GO 24221
22852: LD_INT 13
22854: DOUBLE
22855: EQUAL
22856: IFTRUE 22860
22858: GO 23056
22860: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
22861: LD_ADDR_VAR 0 1
22865: PUSH
22866: LD_INT 1
22868: PUSH
22869: LD_INT 2
22871: PUSH
22872: LD_INT 3
22874: PUSH
22875: LD_INT 4
22877: PUSH
22878: LD_INT 5
22880: PUSH
22881: LD_INT 8
22883: PUSH
22884: LD_INT 9
22886: PUSH
22887: LD_INT 10
22889: PUSH
22890: LD_INT 11
22892: PUSH
22893: LD_INT 12
22895: PUSH
22896: LD_INT 14
22898: PUSH
22899: LD_INT 15
22901: PUSH
22902: LD_INT 16
22904: PUSH
22905: LD_INT 17
22907: PUSH
22908: LD_INT 18
22910: PUSH
22911: LD_INT 19
22913: PUSH
22914: LD_INT 20
22916: PUSH
22917: LD_INT 21
22919: PUSH
22920: LD_INT 22
22922: PUSH
22923: LD_INT 23
22925: PUSH
22926: LD_INT 24
22928: PUSH
22929: LD_INT 25
22931: PUSH
22932: LD_INT 26
22934: PUSH
22935: LD_INT 27
22937: PUSH
22938: LD_INT 28
22940: PUSH
22941: LD_INT 30
22943: PUSH
22944: LD_INT 31
22946: PUSH
22947: LD_INT 32
22949: PUSH
22950: LD_INT 33
22952: PUSH
22953: LD_INT 34
22955: PUSH
22956: LD_INT 36
22958: PUSH
22959: EMPTY
22960: LIST
22961: LIST
22962: LIST
22963: LIST
22964: LIST
22965: LIST
22966: LIST
22967: LIST
22968: LIST
22969: LIST
22970: LIST
22971: LIST
22972: LIST
22973: LIST
22974: LIST
22975: LIST
22976: LIST
22977: LIST
22978: LIST
22979: LIST
22980: LIST
22981: LIST
22982: LIST
22983: LIST
22984: LIST
22985: LIST
22986: LIST
22987: LIST
22988: LIST
22989: LIST
22990: LIST
22991: PUSH
22992: LD_INT 101
22994: PUSH
22995: LD_INT 102
22997: PUSH
22998: LD_INT 103
23000: PUSH
23001: LD_INT 104
23003: PUSH
23004: LD_INT 105
23006: PUSH
23007: LD_INT 106
23009: PUSH
23010: LD_INT 107
23012: PUSH
23013: LD_INT 108
23015: PUSH
23016: LD_INT 109
23018: PUSH
23019: LD_INT 110
23021: PUSH
23022: LD_INT 111
23024: PUSH
23025: LD_INT 112
23027: PUSH
23028: LD_INT 113
23030: PUSH
23031: LD_INT 114
23033: PUSH
23034: EMPTY
23035: LIST
23036: LIST
23037: LIST
23038: LIST
23039: LIST
23040: LIST
23041: LIST
23042: LIST
23043: LIST
23044: LIST
23045: LIST
23046: LIST
23047: LIST
23048: LIST
23049: PUSH
23050: EMPTY
23051: LIST
23052: LIST
23053: ST_TO_ADDR
23054: GO 24221
23056: LD_INT 14
23058: DOUBLE
23059: EQUAL
23060: IFTRUE 23064
23062: GO 23276
23064: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
23065: LD_ADDR_VAR 0 1
23069: PUSH
23070: LD_INT 1
23072: PUSH
23073: LD_INT 2
23075: PUSH
23076: LD_INT 3
23078: PUSH
23079: LD_INT 4
23081: PUSH
23082: LD_INT 5
23084: PUSH
23085: LD_INT 6
23087: PUSH
23088: LD_INT 7
23090: PUSH
23091: LD_INT 8
23093: PUSH
23094: LD_INT 9
23096: PUSH
23097: LD_INT 10
23099: PUSH
23100: LD_INT 11
23102: PUSH
23103: LD_INT 12
23105: PUSH
23106: LD_INT 13
23108: PUSH
23109: LD_INT 14
23111: PUSH
23112: LD_INT 15
23114: PUSH
23115: LD_INT 16
23117: PUSH
23118: LD_INT 17
23120: PUSH
23121: LD_INT 18
23123: PUSH
23124: LD_INT 19
23126: PUSH
23127: LD_INT 20
23129: PUSH
23130: LD_INT 21
23132: PUSH
23133: LD_INT 22
23135: PUSH
23136: LD_INT 23
23138: PUSH
23139: LD_INT 24
23141: PUSH
23142: LD_INT 25
23144: PUSH
23145: LD_INT 26
23147: PUSH
23148: LD_INT 27
23150: PUSH
23151: LD_INT 28
23153: PUSH
23154: LD_INT 29
23156: PUSH
23157: LD_INT 30
23159: PUSH
23160: LD_INT 31
23162: PUSH
23163: LD_INT 32
23165: PUSH
23166: LD_INT 33
23168: PUSH
23169: LD_INT 34
23171: PUSH
23172: LD_INT 36
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: LIST
23179: LIST
23180: LIST
23181: LIST
23182: LIST
23183: LIST
23184: LIST
23185: LIST
23186: LIST
23187: LIST
23188: LIST
23189: LIST
23190: LIST
23191: LIST
23192: LIST
23193: LIST
23194: LIST
23195: LIST
23196: LIST
23197: LIST
23198: LIST
23199: LIST
23200: LIST
23201: LIST
23202: LIST
23203: LIST
23204: LIST
23205: LIST
23206: LIST
23207: LIST
23208: LIST
23209: LIST
23210: LIST
23211: PUSH
23212: LD_INT 101
23214: PUSH
23215: LD_INT 102
23217: PUSH
23218: LD_INT 103
23220: PUSH
23221: LD_INT 104
23223: PUSH
23224: LD_INT 105
23226: PUSH
23227: LD_INT 106
23229: PUSH
23230: LD_INT 107
23232: PUSH
23233: LD_INT 108
23235: PUSH
23236: LD_INT 109
23238: PUSH
23239: LD_INT 110
23241: PUSH
23242: LD_INT 111
23244: PUSH
23245: LD_INT 112
23247: PUSH
23248: LD_INT 113
23250: PUSH
23251: LD_INT 114
23253: PUSH
23254: EMPTY
23255: LIST
23256: LIST
23257: LIST
23258: LIST
23259: LIST
23260: LIST
23261: LIST
23262: LIST
23263: LIST
23264: LIST
23265: LIST
23266: LIST
23267: LIST
23268: LIST
23269: PUSH
23270: EMPTY
23271: LIST
23272: LIST
23273: ST_TO_ADDR
23274: GO 24221
23276: LD_INT 15
23278: DOUBLE
23279: EQUAL
23280: IFTRUE 23284
23282: GO 23496
23284: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
23285: LD_ADDR_VAR 0 1
23289: PUSH
23290: LD_INT 1
23292: PUSH
23293: LD_INT 2
23295: PUSH
23296: LD_INT 3
23298: PUSH
23299: LD_INT 4
23301: PUSH
23302: LD_INT 5
23304: PUSH
23305: LD_INT 6
23307: PUSH
23308: LD_INT 7
23310: PUSH
23311: LD_INT 8
23313: PUSH
23314: LD_INT 9
23316: PUSH
23317: LD_INT 10
23319: PUSH
23320: LD_INT 11
23322: PUSH
23323: LD_INT 12
23325: PUSH
23326: LD_INT 13
23328: PUSH
23329: LD_INT 14
23331: PUSH
23332: LD_INT 15
23334: PUSH
23335: LD_INT 16
23337: PUSH
23338: LD_INT 17
23340: PUSH
23341: LD_INT 18
23343: PUSH
23344: LD_INT 19
23346: PUSH
23347: LD_INT 20
23349: PUSH
23350: LD_INT 21
23352: PUSH
23353: LD_INT 22
23355: PUSH
23356: LD_INT 23
23358: PUSH
23359: LD_INT 24
23361: PUSH
23362: LD_INT 25
23364: PUSH
23365: LD_INT 26
23367: PUSH
23368: LD_INT 27
23370: PUSH
23371: LD_INT 28
23373: PUSH
23374: LD_INT 29
23376: PUSH
23377: LD_INT 30
23379: PUSH
23380: LD_INT 31
23382: PUSH
23383: LD_INT 32
23385: PUSH
23386: LD_INT 33
23388: PUSH
23389: LD_INT 34
23391: PUSH
23392: LD_INT 36
23394: PUSH
23395: EMPTY
23396: LIST
23397: LIST
23398: LIST
23399: LIST
23400: LIST
23401: LIST
23402: LIST
23403: LIST
23404: LIST
23405: LIST
23406: LIST
23407: LIST
23408: LIST
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: LIST
23415: LIST
23416: LIST
23417: LIST
23418: LIST
23419: LIST
23420: LIST
23421: LIST
23422: LIST
23423: LIST
23424: LIST
23425: LIST
23426: LIST
23427: LIST
23428: LIST
23429: LIST
23430: LIST
23431: PUSH
23432: LD_INT 101
23434: PUSH
23435: LD_INT 102
23437: PUSH
23438: LD_INT 103
23440: PUSH
23441: LD_INT 104
23443: PUSH
23444: LD_INT 105
23446: PUSH
23447: LD_INT 106
23449: PUSH
23450: LD_INT 107
23452: PUSH
23453: LD_INT 108
23455: PUSH
23456: LD_INT 109
23458: PUSH
23459: LD_INT 110
23461: PUSH
23462: LD_INT 111
23464: PUSH
23465: LD_INT 112
23467: PUSH
23468: LD_INT 113
23470: PUSH
23471: LD_INT 114
23473: PUSH
23474: EMPTY
23475: LIST
23476: LIST
23477: LIST
23478: LIST
23479: LIST
23480: LIST
23481: LIST
23482: LIST
23483: LIST
23484: LIST
23485: LIST
23486: LIST
23487: LIST
23488: LIST
23489: PUSH
23490: EMPTY
23491: LIST
23492: LIST
23493: ST_TO_ADDR
23494: GO 24221
23496: LD_INT 16
23498: DOUBLE
23499: EQUAL
23500: IFTRUE 23504
23502: GO 23628
23504: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
23505: LD_ADDR_VAR 0 1
23509: PUSH
23510: LD_INT 2
23512: PUSH
23513: LD_INT 4
23515: PUSH
23516: LD_INT 5
23518: PUSH
23519: LD_INT 7
23521: PUSH
23522: LD_INT 11
23524: PUSH
23525: LD_INT 12
23527: PUSH
23528: LD_INT 15
23530: PUSH
23531: LD_INT 16
23533: PUSH
23534: LD_INT 20
23536: PUSH
23537: LD_INT 21
23539: PUSH
23540: LD_INT 22
23542: PUSH
23543: LD_INT 23
23545: PUSH
23546: LD_INT 25
23548: PUSH
23549: LD_INT 26
23551: PUSH
23552: LD_INT 30
23554: PUSH
23555: LD_INT 31
23557: PUSH
23558: LD_INT 32
23560: PUSH
23561: LD_INT 33
23563: PUSH
23564: LD_INT 34
23566: PUSH
23567: EMPTY
23568: LIST
23569: LIST
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: LIST
23575: LIST
23576: LIST
23577: LIST
23578: LIST
23579: LIST
23580: LIST
23581: LIST
23582: LIST
23583: LIST
23584: LIST
23585: LIST
23586: LIST
23587: PUSH
23588: LD_INT 101
23590: PUSH
23591: LD_INT 102
23593: PUSH
23594: LD_INT 103
23596: PUSH
23597: LD_INT 106
23599: PUSH
23600: LD_INT 108
23602: PUSH
23603: LD_INT 112
23605: PUSH
23606: LD_INT 113
23608: PUSH
23609: LD_INT 114
23611: PUSH
23612: EMPTY
23613: LIST
23614: LIST
23615: LIST
23616: LIST
23617: LIST
23618: LIST
23619: LIST
23620: LIST
23621: PUSH
23622: EMPTY
23623: LIST
23624: LIST
23625: ST_TO_ADDR
23626: GO 24221
23628: LD_INT 17
23630: DOUBLE
23631: EQUAL
23632: IFTRUE 23636
23634: GO 23848
23636: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
23637: LD_ADDR_VAR 0 1
23641: PUSH
23642: LD_INT 1
23644: PUSH
23645: LD_INT 2
23647: PUSH
23648: LD_INT 3
23650: PUSH
23651: LD_INT 4
23653: PUSH
23654: LD_INT 5
23656: PUSH
23657: LD_INT 6
23659: PUSH
23660: LD_INT 7
23662: PUSH
23663: LD_INT 8
23665: PUSH
23666: LD_INT 9
23668: PUSH
23669: LD_INT 10
23671: PUSH
23672: LD_INT 11
23674: PUSH
23675: LD_INT 12
23677: PUSH
23678: LD_INT 13
23680: PUSH
23681: LD_INT 14
23683: PUSH
23684: LD_INT 15
23686: PUSH
23687: LD_INT 16
23689: PUSH
23690: LD_INT 17
23692: PUSH
23693: LD_INT 18
23695: PUSH
23696: LD_INT 19
23698: PUSH
23699: LD_INT 20
23701: PUSH
23702: LD_INT 21
23704: PUSH
23705: LD_INT 22
23707: PUSH
23708: LD_INT 23
23710: PUSH
23711: LD_INT 24
23713: PUSH
23714: LD_INT 25
23716: PUSH
23717: LD_INT 26
23719: PUSH
23720: LD_INT 27
23722: PUSH
23723: LD_INT 28
23725: PUSH
23726: LD_INT 29
23728: PUSH
23729: LD_INT 30
23731: PUSH
23732: LD_INT 31
23734: PUSH
23735: LD_INT 32
23737: PUSH
23738: LD_INT 33
23740: PUSH
23741: LD_INT 34
23743: PUSH
23744: LD_INT 36
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: LIST
23751: LIST
23752: LIST
23753: LIST
23754: LIST
23755: LIST
23756: LIST
23757: LIST
23758: LIST
23759: LIST
23760: LIST
23761: LIST
23762: LIST
23763: LIST
23764: LIST
23765: LIST
23766: LIST
23767: LIST
23768: LIST
23769: LIST
23770: LIST
23771: LIST
23772: LIST
23773: LIST
23774: LIST
23775: LIST
23776: LIST
23777: LIST
23778: LIST
23779: LIST
23780: LIST
23781: LIST
23782: LIST
23783: PUSH
23784: LD_INT 101
23786: PUSH
23787: LD_INT 102
23789: PUSH
23790: LD_INT 103
23792: PUSH
23793: LD_INT 104
23795: PUSH
23796: LD_INT 105
23798: PUSH
23799: LD_INT 106
23801: PUSH
23802: LD_INT 107
23804: PUSH
23805: LD_INT 108
23807: PUSH
23808: LD_INT 109
23810: PUSH
23811: LD_INT 110
23813: PUSH
23814: LD_INT 111
23816: PUSH
23817: LD_INT 112
23819: PUSH
23820: LD_INT 113
23822: PUSH
23823: LD_INT 114
23825: PUSH
23826: EMPTY
23827: LIST
23828: LIST
23829: LIST
23830: LIST
23831: LIST
23832: LIST
23833: LIST
23834: LIST
23835: LIST
23836: LIST
23837: LIST
23838: LIST
23839: LIST
23840: LIST
23841: PUSH
23842: EMPTY
23843: LIST
23844: LIST
23845: ST_TO_ADDR
23846: GO 24221
23848: LD_INT 18
23850: DOUBLE
23851: EQUAL
23852: IFTRUE 23856
23854: GO 23992
23856: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
23857: LD_ADDR_VAR 0 1
23861: PUSH
23862: LD_INT 2
23864: PUSH
23865: LD_INT 4
23867: PUSH
23868: LD_INT 5
23870: PUSH
23871: LD_INT 7
23873: PUSH
23874: LD_INT 11
23876: PUSH
23877: LD_INT 12
23879: PUSH
23880: LD_INT 15
23882: PUSH
23883: LD_INT 16
23885: PUSH
23886: LD_INT 20
23888: PUSH
23889: LD_INT 21
23891: PUSH
23892: LD_INT 22
23894: PUSH
23895: LD_INT 23
23897: PUSH
23898: LD_INT 25
23900: PUSH
23901: LD_INT 26
23903: PUSH
23904: LD_INT 30
23906: PUSH
23907: LD_INT 31
23909: PUSH
23910: LD_INT 32
23912: PUSH
23913: LD_INT 33
23915: PUSH
23916: LD_INT 34
23918: PUSH
23919: LD_INT 35
23921: PUSH
23922: LD_INT 36
23924: PUSH
23925: EMPTY
23926: LIST
23927: LIST
23928: LIST
23929: LIST
23930: LIST
23931: LIST
23932: LIST
23933: LIST
23934: LIST
23935: LIST
23936: LIST
23937: LIST
23938: LIST
23939: LIST
23940: LIST
23941: LIST
23942: LIST
23943: LIST
23944: LIST
23945: LIST
23946: LIST
23947: PUSH
23948: LD_INT 101
23950: PUSH
23951: LD_INT 102
23953: PUSH
23954: LD_INT 103
23956: PUSH
23957: LD_INT 106
23959: PUSH
23960: LD_INT 108
23962: PUSH
23963: LD_INT 112
23965: PUSH
23966: LD_INT 113
23968: PUSH
23969: LD_INT 114
23971: PUSH
23972: LD_INT 115
23974: PUSH
23975: EMPTY
23976: LIST
23977: LIST
23978: LIST
23979: LIST
23980: LIST
23981: LIST
23982: LIST
23983: LIST
23984: LIST
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: ST_TO_ADDR
23990: GO 24221
23992: LD_INT 19
23994: DOUBLE
23995: EQUAL
23996: IFTRUE 24000
23998: GO 24220
24000: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
24001: LD_ADDR_VAR 0 1
24005: PUSH
24006: LD_INT 1
24008: PUSH
24009: LD_INT 2
24011: PUSH
24012: LD_INT 3
24014: PUSH
24015: LD_INT 4
24017: PUSH
24018: LD_INT 5
24020: PUSH
24021: LD_INT 6
24023: PUSH
24024: LD_INT 7
24026: PUSH
24027: LD_INT 8
24029: PUSH
24030: LD_INT 9
24032: PUSH
24033: LD_INT 10
24035: PUSH
24036: LD_INT 11
24038: PUSH
24039: LD_INT 12
24041: PUSH
24042: LD_INT 13
24044: PUSH
24045: LD_INT 14
24047: PUSH
24048: LD_INT 15
24050: PUSH
24051: LD_INT 16
24053: PUSH
24054: LD_INT 17
24056: PUSH
24057: LD_INT 18
24059: PUSH
24060: LD_INT 19
24062: PUSH
24063: LD_INT 20
24065: PUSH
24066: LD_INT 21
24068: PUSH
24069: LD_INT 22
24071: PUSH
24072: LD_INT 23
24074: PUSH
24075: LD_INT 24
24077: PUSH
24078: LD_INT 25
24080: PUSH
24081: LD_INT 26
24083: PUSH
24084: LD_INT 27
24086: PUSH
24087: LD_INT 28
24089: PUSH
24090: LD_INT 29
24092: PUSH
24093: LD_INT 30
24095: PUSH
24096: LD_INT 31
24098: PUSH
24099: LD_INT 32
24101: PUSH
24102: LD_INT 33
24104: PUSH
24105: LD_INT 34
24107: PUSH
24108: LD_INT 35
24110: PUSH
24111: LD_INT 36
24113: PUSH
24114: EMPTY
24115: LIST
24116: LIST
24117: LIST
24118: LIST
24119: LIST
24120: LIST
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: LIST
24137: LIST
24138: LIST
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: LIST
24144: LIST
24145: LIST
24146: LIST
24147: LIST
24148: LIST
24149: LIST
24150: LIST
24151: PUSH
24152: LD_INT 101
24154: PUSH
24155: LD_INT 102
24157: PUSH
24158: LD_INT 103
24160: PUSH
24161: LD_INT 104
24163: PUSH
24164: LD_INT 105
24166: PUSH
24167: LD_INT 106
24169: PUSH
24170: LD_INT 107
24172: PUSH
24173: LD_INT 108
24175: PUSH
24176: LD_INT 109
24178: PUSH
24179: LD_INT 110
24181: PUSH
24182: LD_INT 111
24184: PUSH
24185: LD_INT 112
24187: PUSH
24188: LD_INT 113
24190: PUSH
24191: LD_INT 114
24193: PUSH
24194: LD_INT 115
24196: PUSH
24197: EMPTY
24198: LIST
24199: LIST
24200: LIST
24201: LIST
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: LIST
24207: LIST
24208: LIST
24209: LIST
24210: LIST
24211: LIST
24212: LIST
24213: PUSH
24214: EMPTY
24215: LIST
24216: LIST
24217: ST_TO_ADDR
24218: GO 24221
24220: POP
// end else
24221: GO 24440
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
24223: LD_ADDR_VAR 0 1
24227: PUSH
24228: LD_INT 1
24230: PUSH
24231: LD_INT 2
24233: PUSH
24234: LD_INT 3
24236: PUSH
24237: LD_INT 4
24239: PUSH
24240: LD_INT 5
24242: PUSH
24243: LD_INT 6
24245: PUSH
24246: LD_INT 7
24248: PUSH
24249: LD_INT 8
24251: PUSH
24252: LD_INT 9
24254: PUSH
24255: LD_INT 10
24257: PUSH
24258: LD_INT 11
24260: PUSH
24261: LD_INT 12
24263: PUSH
24264: LD_INT 13
24266: PUSH
24267: LD_INT 14
24269: PUSH
24270: LD_INT 15
24272: PUSH
24273: LD_INT 16
24275: PUSH
24276: LD_INT 17
24278: PUSH
24279: LD_INT 18
24281: PUSH
24282: LD_INT 19
24284: PUSH
24285: LD_INT 20
24287: PUSH
24288: LD_INT 21
24290: PUSH
24291: LD_INT 22
24293: PUSH
24294: LD_INT 23
24296: PUSH
24297: LD_INT 24
24299: PUSH
24300: LD_INT 25
24302: PUSH
24303: LD_INT 26
24305: PUSH
24306: LD_INT 27
24308: PUSH
24309: LD_INT 28
24311: PUSH
24312: LD_INT 29
24314: PUSH
24315: LD_INT 30
24317: PUSH
24318: LD_INT 31
24320: PUSH
24321: LD_INT 32
24323: PUSH
24324: LD_INT 33
24326: PUSH
24327: LD_INT 34
24329: PUSH
24330: LD_INT 35
24332: PUSH
24333: LD_INT 36
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: LIST
24346: LIST
24347: LIST
24348: LIST
24349: LIST
24350: LIST
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: LIST
24356: LIST
24357: LIST
24358: LIST
24359: LIST
24360: LIST
24361: LIST
24362: LIST
24363: LIST
24364: LIST
24365: LIST
24366: LIST
24367: LIST
24368: LIST
24369: LIST
24370: LIST
24371: LIST
24372: LIST
24373: PUSH
24374: LD_INT 101
24376: PUSH
24377: LD_INT 102
24379: PUSH
24380: LD_INT 103
24382: PUSH
24383: LD_INT 104
24385: PUSH
24386: LD_INT 105
24388: PUSH
24389: LD_INT 106
24391: PUSH
24392: LD_INT 107
24394: PUSH
24395: LD_INT 108
24397: PUSH
24398: LD_INT 109
24400: PUSH
24401: LD_INT 110
24403: PUSH
24404: LD_INT 111
24406: PUSH
24407: LD_INT 112
24409: PUSH
24410: LD_INT 113
24412: PUSH
24413: LD_INT 114
24415: PUSH
24416: LD_INT 115
24418: PUSH
24419: EMPTY
24420: LIST
24421: LIST
24422: LIST
24423: LIST
24424: LIST
24425: LIST
24426: LIST
24427: LIST
24428: LIST
24429: LIST
24430: LIST
24431: LIST
24432: LIST
24433: LIST
24434: LIST
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: ST_TO_ADDR
// if result then
24440: LD_VAR 0 1
24444: IFFALSE 24733
// begin normal :=  ;
24446: LD_ADDR_VAR 0 3
24450: PUSH
24451: LD_STRING 
24453: ST_TO_ADDR
// hardcore :=  ;
24454: LD_ADDR_VAR 0 4
24458: PUSH
24459: LD_STRING 
24461: ST_TO_ADDR
// for i = 1 to normalCounter do
24462: LD_ADDR_VAR 0 5
24466: PUSH
24467: DOUBLE
24468: LD_INT 1
24470: DEC
24471: ST_TO_ADDR
24472: LD_EXP 64
24476: PUSH
24477: FOR_TO
24478: IFFALSE 24579
// begin tmp := 0 ;
24480: LD_ADDR_VAR 0 2
24484: PUSH
24485: LD_STRING 0
24487: ST_TO_ADDR
// if result [ 1 ] then
24488: LD_VAR 0 1
24492: PUSH
24493: LD_INT 1
24495: ARRAY
24496: IFFALSE 24561
// if result [ 1 ] [ 1 ] = i then
24498: LD_VAR 0 1
24502: PUSH
24503: LD_INT 1
24505: ARRAY
24506: PUSH
24507: LD_INT 1
24509: ARRAY
24510: PUSH
24511: LD_VAR 0 5
24515: EQUAL
24516: IFFALSE 24561
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
24518: LD_ADDR_VAR 0 1
24522: PUSH
24523: LD_VAR 0 1
24527: PPUSH
24528: LD_INT 1
24530: PPUSH
24531: LD_VAR 0 1
24535: PUSH
24536: LD_INT 1
24538: ARRAY
24539: PPUSH
24540: LD_INT 1
24542: PPUSH
24543: CALL_OW 3
24547: PPUSH
24548: CALL_OW 1
24552: ST_TO_ADDR
// tmp := 1 ;
24553: LD_ADDR_VAR 0 2
24557: PUSH
24558: LD_STRING 1
24560: ST_TO_ADDR
// end ; normal := normal & tmp ;
24561: LD_ADDR_VAR 0 3
24565: PUSH
24566: LD_VAR 0 3
24570: PUSH
24571: LD_VAR 0 2
24575: STR
24576: ST_TO_ADDR
// end ;
24577: GO 24477
24579: POP
24580: POP
// for i = 1 to hardcoreCounter do
24581: LD_ADDR_VAR 0 5
24585: PUSH
24586: DOUBLE
24587: LD_INT 1
24589: DEC
24590: ST_TO_ADDR
24591: LD_EXP 65
24595: PUSH
24596: FOR_TO
24597: IFFALSE 24702
// begin tmp := 0 ;
24599: LD_ADDR_VAR 0 2
24603: PUSH
24604: LD_STRING 0
24606: ST_TO_ADDR
// if result [ 2 ] then
24607: LD_VAR 0 1
24611: PUSH
24612: LD_INT 2
24614: ARRAY
24615: IFFALSE 24684
// if result [ 2 ] [ 1 ] = 100 + i then
24617: LD_VAR 0 1
24621: PUSH
24622: LD_INT 2
24624: ARRAY
24625: PUSH
24626: LD_INT 1
24628: ARRAY
24629: PUSH
24630: LD_INT 100
24632: PUSH
24633: LD_VAR 0 5
24637: PLUS
24638: EQUAL
24639: IFFALSE 24684
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
24641: LD_ADDR_VAR 0 1
24645: PUSH
24646: LD_VAR 0 1
24650: PPUSH
24651: LD_INT 2
24653: PPUSH
24654: LD_VAR 0 1
24658: PUSH
24659: LD_INT 2
24661: ARRAY
24662: PPUSH
24663: LD_INT 1
24665: PPUSH
24666: CALL_OW 3
24670: PPUSH
24671: CALL_OW 1
24675: ST_TO_ADDR
// tmp := 1 ;
24676: LD_ADDR_VAR 0 2
24680: PUSH
24681: LD_STRING 1
24683: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
24684: LD_ADDR_VAR 0 4
24688: PUSH
24689: LD_VAR 0 4
24693: PUSH
24694: LD_VAR 0 2
24698: STR
24699: ST_TO_ADDR
// end ;
24700: GO 24596
24702: POP
24703: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
24704: LD_STRING getStreamItemsFromMission("
24706: PUSH
24707: LD_VAR 0 3
24711: STR
24712: PUSH
24713: LD_STRING ","
24715: STR
24716: PUSH
24717: LD_VAR 0 4
24721: STR
24722: PUSH
24723: LD_STRING ")
24725: STR
24726: PPUSH
24727: CALL_OW 559
// end else
24731: GO 24740
// ToLua ( getStreamItemsFromMission("","") ) ;
24733: LD_STRING getStreamItemsFromMission("","")
24735: PPUSH
24736: CALL_OW 559
// end ;
24740: LD_VAR 0 1
24744: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
24745: LD_EXP 63
24749: PUSH
24750: LD_EXP 68
24754: AND
24755: IFFALSE 24879
24757: GO 24759
24759: DISABLE
24760: LD_INT 0
24762: PPUSH
24763: PPUSH
// begin enable ;
24764: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
24765: LD_ADDR_VAR 0 2
24769: PUSH
24770: LD_INT 22
24772: PUSH
24773: LD_OWVAR 2
24777: PUSH
24778: EMPTY
24779: LIST
24780: LIST
24781: PUSH
24782: LD_INT 2
24784: PUSH
24785: LD_INT 34
24787: PUSH
24788: LD_INT 7
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 34
24797: PUSH
24798: LD_INT 45
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: LD_INT 34
24807: PUSH
24808: LD_INT 28
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 34
24817: PUSH
24818: LD_INT 47
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: LIST
24829: LIST
24830: LIST
24831: PUSH
24832: EMPTY
24833: LIST
24834: LIST
24835: PPUSH
24836: CALL_OW 69
24840: ST_TO_ADDR
// if not tmp then
24841: LD_VAR 0 2
24845: NOT
24846: IFFALSE 24850
// exit ;
24848: GO 24879
// for i in tmp do
24850: LD_ADDR_VAR 0 1
24854: PUSH
24855: LD_VAR 0 2
24859: PUSH
24860: FOR_IN
24861: IFFALSE 24877
// begin SetLives ( i , 0 ) ;
24863: LD_VAR 0 1
24867: PPUSH
24868: LD_INT 0
24870: PPUSH
24871: CALL_OW 234
// end ;
24875: GO 24860
24877: POP
24878: POP
// end ;
24879: PPOPN 2
24881: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
24882: LD_EXP 63
24886: PUSH
24887: LD_EXP 69
24891: AND
24892: IFFALSE 24976
24894: GO 24896
24896: DISABLE
24897: LD_INT 0
24899: PPUSH
24900: PPUSH
// begin enable ;
24901: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
24902: LD_ADDR_VAR 0 2
24906: PUSH
24907: LD_INT 22
24909: PUSH
24910: LD_OWVAR 2
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: PUSH
24919: LD_INT 32
24921: PUSH
24922: LD_INT 3
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PPUSH
24933: CALL_OW 69
24937: ST_TO_ADDR
// if not tmp then
24938: LD_VAR 0 2
24942: NOT
24943: IFFALSE 24947
// exit ;
24945: GO 24976
// for i in tmp do
24947: LD_ADDR_VAR 0 1
24951: PUSH
24952: LD_VAR 0 2
24956: PUSH
24957: FOR_IN
24958: IFFALSE 24974
// begin SetLives ( i , 0 ) ;
24960: LD_VAR 0 1
24964: PPUSH
24965: LD_INT 0
24967: PPUSH
24968: CALL_OW 234
// end ;
24972: GO 24957
24974: POP
24975: POP
// end ;
24976: PPOPN 2
24978: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
24979: LD_EXP 63
24983: PUSH
24984: LD_EXP 66
24988: AND
24989: IFFALSE 25082
24991: GO 24993
24993: DISABLE
24994: LD_INT 0
24996: PPUSH
// begin enable ;
24997: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
24998: LD_ADDR_VAR 0 1
25002: PUSH
25003: LD_INT 22
25005: PUSH
25006: LD_OWVAR 2
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 2
25017: PUSH
25018: LD_INT 25
25020: PUSH
25021: LD_INT 5
25023: PUSH
25024: EMPTY
25025: LIST
25026: LIST
25027: PUSH
25028: LD_INT 25
25030: PUSH
25031: LD_INT 9
25033: PUSH
25034: EMPTY
25035: LIST
25036: LIST
25037: PUSH
25038: LD_INT 25
25040: PUSH
25041: LD_INT 8
25043: PUSH
25044: EMPTY
25045: LIST
25046: LIST
25047: PUSH
25048: EMPTY
25049: LIST
25050: LIST
25051: LIST
25052: LIST
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PPUSH
25058: CALL_OW 69
25062: PUSH
25063: FOR_IN
25064: IFFALSE 25080
// begin SetClass ( i , 1 ) ;
25066: LD_VAR 0 1
25070: PPUSH
25071: LD_INT 1
25073: PPUSH
25074: CALL_OW 336
// end ;
25078: GO 25063
25080: POP
25081: POP
// end ;
25082: PPOPN 1
25084: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
25085: LD_EXP 63
25089: PUSH
25090: LD_EXP 67
25094: AND
25095: PUSH
25096: LD_OWVAR 65
25100: PUSH
25101: LD_INT 7
25103: LESS
25104: AND
25105: IFFALSE 25119
25107: GO 25109
25109: DISABLE
// begin enable ;
25110: ENABLE
// game_speed := 7 ;
25111: LD_ADDR_OWVAR 65
25115: PUSH
25116: LD_INT 7
25118: ST_TO_ADDR
// end ;
25119: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
25120: LD_EXP 63
25124: PUSH
25125: LD_EXP 70
25129: AND
25130: IFFALSE 25332
25132: GO 25134
25134: DISABLE
25135: LD_INT 0
25137: PPUSH
25138: PPUSH
25139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
25140: LD_ADDR_VAR 0 3
25144: PUSH
25145: LD_INT 81
25147: PUSH
25148: LD_OWVAR 2
25152: PUSH
25153: EMPTY
25154: LIST
25155: LIST
25156: PUSH
25157: LD_INT 21
25159: PUSH
25160: LD_INT 1
25162: PUSH
25163: EMPTY
25164: LIST
25165: LIST
25166: PUSH
25167: EMPTY
25168: LIST
25169: LIST
25170: PPUSH
25171: CALL_OW 69
25175: ST_TO_ADDR
// if not tmp then
25176: LD_VAR 0 3
25180: NOT
25181: IFFALSE 25185
// exit ;
25183: GO 25332
// if tmp > 5 then
25185: LD_VAR 0 3
25189: PUSH
25190: LD_INT 5
25192: GREATER
25193: IFFALSE 25205
// k := 5 else
25195: LD_ADDR_VAR 0 2
25199: PUSH
25200: LD_INT 5
25202: ST_TO_ADDR
25203: GO 25215
// k := tmp ;
25205: LD_ADDR_VAR 0 2
25209: PUSH
25210: LD_VAR 0 3
25214: ST_TO_ADDR
// for i := 1 to k do
25215: LD_ADDR_VAR 0 1
25219: PUSH
25220: DOUBLE
25221: LD_INT 1
25223: DEC
25224: ST_TO_ADDR
25225: LD_VAR 0 2
25229: PUSH
25230: FOR_TO
25231: IFFALSE 25330
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
25233: LD_VAR 0 3
25237: PUSH
25238: LD_VAR 0 1
25242: ARRAY
25243: PPUSH
25244: LD_VAR 0 1
25248: PUSH
25249: LD_INT 4
25251: MOD
25252: PUSH
25253: LD_INT 1
25255: PLUS
25256: PPUSH
25257: CALL_OW 259
25261: PUSH
25262: LD_INT 10
25264: LESS
25265: IFFALSE 25328
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
25267: LD_VAR 0 3
25271: PUSH
25272: LD_VAR 0 1
25276: ARRAY
25277: PPUSH
25278: LD_VAR 0 1
25282: PUSH
25283: LD_INT 4
25285: MOD
25286: PUSH
25287: LD_INT 1
25289: PLUS
25290: PPUSH
25291: LD_VAR 0 3
25295: PUSH
25296: LD_VAR 0 1
25300: ARRAY
25301: PPUSH
25302: LD_VAR 0 1
25306: PUSH
25307: LD_INT 4
25309: MOD
25310: PUSH
25311: LD_INT 1
25313: PLUS
25314: PPUSH
25315: CALL_OW 259
25319: PUSH
25320: LD_INT 1
25322: PLUS
25323: PPUSH
25324: CALL_OW 237
25328: GO 25230
25330: POP
25331: POP
// end ;
25332: PPOPN 3
25334: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
25335: LD_EXP 63
25339: PUSH
25340: LD_EXP 71
25344: AND
25345: IFFALSE 25365
25347: GO 25349
25349: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
25350: LD_INT 4
25352: PPUSH
25353: LD_OWVAR 2
25357: PPUSH
25358: LD_INT 0
25360: PPUSH
25361: CALL_OW 324
25365: END
// every 0 0$1 trigger StreamModeActive and sShovel do
25366: LD_EXP 63
25370: PUSH
25371: LD_EXP 100
25375: AND
25376: IFFALSE 25396
25378: GO 25380
25380: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
25381: LD_INT 19
25383: PPUSH
25384: LD_OWVAR 2
25388: PPUSH
25389: LD_INT 0
25391: PPUSH
25392: CALL_OW 324
25396: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
25397: LD_EXP 63
25401: PUSH
25402: LD_EXP 72
25406: AND
25407: IFFALSE 25509
25409: GO 25411
25411: DISABLE
25412: LD_INT 0
25414: PPUSH
25415: PPUSH
// begin enable ;
25416: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
25417: LD_ADDR_VAR 0 2
25421: PUSH
25422: LD_INT 22
25424: PUSH
25425: LD_OWVAR 2
25429: PUSH
25430: EMPTY
25431: LIST
25432: LIST
25433: PUSH
25434: LD_INT 2
25436: PUSH
25437: LD_INT 34
25439: PUSH
25440: LD_INT 11
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: PUSH
25447: LD_INT 34
25449: PUSH
25450: LD_INT 30
25452: PUSH
25453: EMPTY
25454: LIST
25455: LIST
25456: PUSH
25457: EMPTY
25458: LIST
25459: LIST
25460: LIST
25461: PUSH
25462: EMPTY
25463: LIST
25464: LIST
25465: PPUSH
25466: CALL_OW 69
25470: ST_TO_ADDR
// if not tmp then
25471: LD_VAR 0 2
25475: NOT
25476: IFFALSE 25480
// exit ;
25478: GO 25509
// for i in tmp do
25480: LD_ADDR_VAR 0 1
25484: PUSH
25485: LD_VAR 0 2
25489: PUSH
25490: FOR_IN
25491: IFFALSE 25507
// begin SetLives ( i , 0 ) ;
25493: LD_VAR 0 1
25497: PPUSH
25498: LD_INT 0
25500: PPUSH
25501: CALL_OW 234
// end ;
25505: GO 25490
25507: POP
25508: POP
// end ;
25509: PPOPN 2
25511: END
// every 0 0$1 trigger StreamModeActive and sBunker do
25512: LD_EXP 63
25516: PUSH
25517: LD_EXP 73
25521: AND
25522: IFFALSE 25542
25524: GO 25526
25526: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
25527: LD_INT 32
25529: PPUSH
25530: LD_OWVAR 2
25534: PPUSH
25535: LD_INT 0
25537: PPUSH
25538: CALL_OW 324
25542: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
25543: LD_EXP 63
25547: PUSH
25548: LD_EXP 74
25552: AND
25553: IFFALSE 25734
25555: GO 25557
25557: DISABLE
25558: LD_INT 0
25560: PPUSH
25561: PPUSH
25562: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
25563: LD_ADDR_VAR 0 2
25567: PUSH
25568: LD_INT 22
25570: PUSH
25571: LD_OWVAR 2
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: PUSH
25580: LD_INT 33
25582: PUSH
25583: LD_INT 3
25585: PUSH
25586: EMPTY
25587: LIST
25588: LIST
25589: PUSH
25590: EMPTY
25591: LIST
25592: LIST
25593: PPUSH
25594: CALL_OW 69
25598: ST_TO_ADDR
// if not tmp then
25599: LD_VAR 0 2
25603: NOT
25604: IFFALSE 25608
// exit ;
25606: GO 25734
// side := 0 ;
25608: LD_ADDR_VAR 0 3
25612: PUSH
25613: LD_INT 0
25615: ST_TO_ADDR
// for i := 1 to 8 do
25616: LD_ADDR_VAR 0 1
25620: PUSH
25621: DOUBLE
25622: LD_INT 1
25624: DEC
25625: ST_TO_ADDR
25626: LD_INT 8
25628: PUSH
25629: FOR_TO
25630: IFFALSE 25678
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
25632: LD_OWVAR 2
25636: PUSH
25637: LD_VAR 0 1
25641: NONEQUAL
25642: PUSH
25643: LD_OWVAR 2
25647: PPUSH
25648: LD_VAR 0 1
25652: PPUSH
25653: CALL_OW 81
25657: PUSH
25658: LD_INT 2
25660: EQUAL
25661: AND
25662: IFFALSE 25676
// begin side := i ;
25664: LD_ADDR_VAR 0 3
25668: PUSH
25669: LD_VAR 0 1
25673: ST_TO_ADDR
// break ;
25674: GO 25678
// end ;
25676: GO 25629
25678: POP
25679: POP
// if not side then
25680: LD_VAR 0 3
25684: NOT
25685: IFFALSE 25689
// exit ;
25687: GO 25734
// for i := 1 to tmp do
25689: LD_ADDR_VAR 0 1
25693: PUSH
25694: DOUBLE
25695: LD_INT 1
25697: DEC
25698: ST_TO_ADDR
25699: LD_VAR 0 2
25703: PUSH
25704: FOR_TO
25705: IFFALSE 25732
// if Prob ( 60 ) then
25707: LD_INT 60
25709: PPUSH
25710: CALL_OW 13
25714: IFFALSE 25730
// SetSide ( i , side ) ;
25716: LD_VAR 0 1
25720: PPUSH
25721: LD_VAR 0 3
25725: PPUSH
25726: CALL_OW 235
25730: GO 25704
25732: POP
25733: POP
// end ;
25734: PPOPN 3
25736: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
25737: LD_EXP 63
25741: PUSH
25742: LD_EXP 76
25746: AND
25747: IFFALSE 25866
25749: GO 25751
25751: DISABLE
25752: LD_INT 0
25754: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
25755: LD_ADDR_VAR 0 1
25759: PUSH
25760: LD_INT 22
25762: PUSH
25763: LD_OWVAR 2
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: PUSH
25772: LD_INT 21
25774: PUSH
25775: LD_INT 1
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: PUSH
25782: LD_INT 3
25784: PUSH
25785: LD_INT 23
25787: PUSH
25788: LD_INT 0
25790: PUSH
25791: EMPTY
25792: LIST
25793: LIST
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: PUSH
25799: EMPTY
25800: LIST
25801: LIST
25802: LIST
25803: PPUSH
25804: CALL_OW 69
25808: PUSH
25809: FOR_IN
25810: IFFALSE 25864
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
25812: LD_VAR 0 1
25816: PPUSH
25817: CALL_OW 257
25821: PUSH
25822: LD_INT 1
25824: PUSH
25825: LD_INT 2
25827: PUSH
25828: LD_INT 3
25830: PUSH
25831: LD_INT 4
25833: PUSH
25834: EMPTY
25835: LIST
25836: LIST
25837: LIST
25838: LIST
25839: IN
25840: IFFALSE 25862
// SetClass ( un , rand ( 1 , 4 ) ) ;
25842: LD_VAR 0 1
25846: PPUSH
25847: LD_INT 1
25849: PPUSH
25850: LD_INT 4
25852: PPUSH
25853: CALL_OW 12
25857: PPUSH
25858: CALL_OW 336
25862: GO 25809
25864: POP
25865: POP
// end ;
25866: PPOPN 1
25868: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
25869: LD_EXP 63
25873: PUSH
25874: LD_EXP 75
25878: AND
25879: IFFALSE 25958
25881: GO 25883
25883: DISABLE
25884: LD_INT 0
25886: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
25887: LD_ADDR_VAR 0 1
25891: PUSH
25892: LD_INT 22
25894: PUSH
25895: LD_OWVAR 2
25899: PUSH
25900: EMPTY
25901: LIST
25902: LIST
25903: PUSH
25904: LD_INT 21
25906: PUSH
25907: LD_INT 3
25909: PUSH
25910: EMPTY
25911: LIST
25912: LIST
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: PPUSH
25918: CALL_OW 69
25922: ST_TO_ADDR
// if not tmp then
25923: LD_VAR 0 1
25927: NOT
25928: IFFALSE 25932
// exit ;
25930: GO 25958
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
25932: LD_VAR 0 1
25936: PUSH
25937: LD_INT 1
25939: PPUSH
25940: LD_VAR 0 1
25944: PPUSH
25945: CALL_OW 12
25949: ARRAY
25950: PPUSH
25951: LD_INT 100
25953: PPUSH
25954: CALL_OW 234
// end ;
25958: PPOPN 1
25960: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
25961: LD_EXP 63
25965: PUSH
25966: LD_EXP 77
25970: AND
25971: IFFALSE 26069
25973: GO 25975
25975: DISABLE
25976: LD_INT 0
25978: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
25979: LD_ADDR_VAR 0 1
25983: PUSH
25984: LD_INT 22
25986: PUSH
25987: LD_OWVAR 2
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: PUSH
25996: LD_INT 21
25998: PUSH
25999: LD_INT 1
26001: PUSH
26002: EMPTY
26003: LIST
26004: LIST
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PPUSH
26010: CALL_OW 69
26014: ST_TO_ADDR
// if not tmp then
26015: LD_VAR 0 1
26019: NOT
26020: IFFALSE 26024
// exit ;
26022: GO 26069
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
26024: LD_VAR 0 1
26028: PUSH
26029: LD_INT 1
26031: PPUSH
26032: LD_VAR 0 1
26036: PPUSH
26037: CALL_OW 12
26041: ARRAY
26042: PPUSH
26043: LD_INT 1
26045: PPUSH
26046: LD_INT 4
26048: PPUSH
26049: CALL_OW 12
26053: PPUSH
26054: LD_INT 3000
26056: PPUSH
26057: LD_INT 9000
26059: PPUSH
26060: CALL_OW 12
26064: PPUSH
26065: CALL_OW 492
// end ;
26069: PPOPN 1
26071: END
// every 0 0$1 trigger StreamModeActive and sDepot do
26072: LD_EXP 63
26076: PUSH
26077: LD_EXP 78
26081: AND
26082: IFFALSE 26102
26084: GO 26086
26086: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
26087: LD_INT 1
26089: PPUSH
26090: LD_OWVAR 2
26094: PPUSH
26095: LD_INT 0
26097: PPUSH
26098: CALL_OW 324
26102: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
26103: LD_EXP 63
26107: PUSH
26108: LD_EXP 79
26112: AND
26113: IFFALSE 26196
26115: GO 26117
26117: DISABLE
26118: LD_INT 0
26120: PPUSH
26121: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
26122: LD_ADDR_VAR 0 2
26126: PUSH
26127: LD_INT 22
26129: PUSH
26130: LD_OWVAR 2
26134: PUSH
26135: EMPTY
26136: LIST
26137: LIST
26138: PUSH
26139: LD_INT 21
26141: PUSH
26142: LD_INT 3
26144: PUSH
26145: EMPTY
26146: LIST
26147: LIST
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: PPUSH
26153: CALL_OW 69
26157: ST_TO_ADDR
// if not tmp then
26158: LD_VAR 0 2
26162: NOT
26163: IFFALSE 26167
// exit ;
26165: GO 26196
// for i in tmp do
26167: LD_ADDR_VAR 0 1
26171: PUSH
26172: LD_VAR 0 2
26176: PUSH
26177: FOR_IN
26178: IFFALSE 26194
// SetBLevel ( i , 10 ) ;
26180: LD_VAR 0 1
26184: PPUSH
26185: LD_INT 10
26187: PPUSH
26188: CALL_OW 241
26192: GO 26177
26194: POP
26195: POP
// end ;
26196: PPOPN 2
26198: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
26199: LD_EXP 63
26203: PUSH
26204: LD_EXP 80
26208: AND
26209: IFFALSE 26320
26211: GO 26213
26213: DISABLE
26214: LD_INT 0
26216: PPUSH
26217: PPUSH
26218: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26219: LD_ADDR_VAR 0 3
26223: PUSH
26224: LD_INT 22
26226: PUSH
26227: LD_OWVAR 2
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: PUSH
26236: LD_INT 25
26238: PUSH
26239: LD_INT 1
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: PUSH
26246: EMPTY
26247: LIST
26248: LIST
26249: PPUSH
26250: CALL_OW 69
26254: ST_TO_ADDR
// if not tmp then
26255: LD_VAR 0 3
26259: NOT
26260: IFFALSE 26264
// exit ;
26262: GO 26320
// un := tmp [ rand ( 1 , tmp ) ] ;
26264: LD_ADDR_VAR 0 2
26268: PUSH
26269: LD_VAR 0 3
26273: PUSH
26274: LD_INT 1
26276: PPUSH
26277: LD_VAR 0 3
26281: PPUSH
26282: CALL_OW 12
26286: ARRAY
26287: ST_TO_ADDR
// if Crawls ( un ) then
26288: LD_VAR 0 2
26292: PPUSH
26293: CALL_OW 318
26297: IFFALSE 26308
// ComWalk ( un ) ;
26299: LD_VAR 0 2
26303: PPUSH
26304: CALL_OW 138
// SetClass ( un , class_sniper ) ;
26308: LD_VAR 0 2
26312: PPUSH
26313: LD_INT 5
26315: PPUSH
26316: CALL_OW 336
// end ;
26320: PPOPN 3
26322: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
26323: LD_EXP 63
26327: PUSH
26328: LD_EXP 81
26332: AND
26333: PUSH
26334: LD_OWVAR 67
26338: PUSH
26339: LD_INT 3
26341: LESS
26342: AND
26343: IFFALSE 26362
26345: GO 26347
26347: DISABLE
// Difficulty := Difficulty + 1 ;
26348: LD_ADDR_OWVAR 67
26352: PUSH
26353: LD_OWVAR 67
26357: PUSH
26358: LD_INT 1
26360: PLUS
26361: ST_TO_ADDR
26362: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
26363: LD_EXP 63
26367: PUSH
26368: LD_EXP 82
26372: AND
26373: IFFALSE 26476
26375: GO 26377
26377: DISABLE
26378: LD_INT 0
26380: PPUSH
// begin for i := 1 to 5 do
26381: LD_ADDR_VAR 0 1
26385: PUSH
26386: DOUBLE
26387: LD_INT 1
26389: DEC
26390: ST_TO_ADDR
26391: LD_INT 5
26393: PUSH
26394: FOR_TO
26395: IFFALSE 26474
// begin uc_nation := nation_nature ;
26397: LD_ADDR_OWVAR 21
26401: PUSH
26402: LD_INT 0
26404: ST_TO_ADDR
// uc_side := 0 ;
26405: LD_ADDR_OWVAR 20
26409: PUSH
26410: LD_INT 0
26412: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
26413: LD_ADDR_OWVAR 29
26417: PUSH
26418: LD_INT 12
26420: PUSH
26421: LD_INT 12
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: ST_TO_ADDR
// hc_agressivity := 20 ;
26428: LD_ADDR_OWVAR 35
26432: PUSH
26433: LD_INT 20
26435: ST_TO_ADDR
// hc_class := class_tiger ;
26436: LD_ADDR_OWVAR 28
26440: PUSH
26441: LD_INT 14
26443: ST_TO_ADDR
// hc_gallery :=  ;
26444: LD_ADDR_OWVAR 33
26448: PUSH
26449: LD_STRING 
26451: ST_TO_ADDR
// hc_name :=  ;
26452: LD_ADDR_OWVAR 26
26456: PUSH
26457: LD_STRING 
26459: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
26460: CALL_OW 44
26464: PPUSH
26465: LD_INT 0
26467: PPUSH
26468: CALL_OW 51
// end ;
26472: GO 26394
26474: POP
26475: POP
// end ;
26476: PPOPN 1
26478: END
// every 0 0$1 trigger StreamModeActive and sBomb do
26479: LD_EXP 63
26483: PUSH
26484: LD_EXP 83
26488: AND
26489: IFFALSE 26498
26491: GO 26493
26493: DISABLE
// StreamSibBomb ;
26494: CALL 26499 0 0
26498: END
// export function StreamSibBomb ; var i , x , y ; begin
26499: LD_INT 0
26501: PPUSH
26502: PPUSH
26503: PPUSH
26504: PPUSH
// result := false ;
26505: LD_ADDR_VAR 0 1
26509: PUSH
26510: LD_INT 0
26512: ST_TO_ADDR
// for i := 1 to 16 do
26513: LD_ADDR_VAR 0 2
26517: PUSH
26518: DOUBLE
26519: LD_INT 1
26521: DEC
26522: ST_TO_ADDR
26523: LD_INT 16
26525: PUSH
26526: FOR_TO
26527: IFFALSE 26726
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
26529: LD_ADDR_VAR 0 3
26533: PUSH
26534: LD_INT 10
26536: PUSH
26537: LD_INT 20
26539: PUSH
26540: LD_INT 30
26542: PUSH
26543: LD_INT 40
26545: PUSH
26546: LD_INT 50
26548: PUSH
26549: LD_INT 60
26551: PUSH
26552: LD_INT 70
26554: PUSH
26555: LD_INT 80
26557: PUSH
26558: LD_INT 90
26560: PUSH
26561: LD_INT 100
26563: PUSH
26564: LD_INT 110
26566: PUSH
26567: LD_INT 120
26569: PUSH
26570: LD_INT 130
26572: PUSH
26573: LD_INT 140
26575: PUSH
26576: LD_INT 150
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: LIST
26583: LIST
26584: LIST
26585: LIST
26586: LIST
26587: LIST
26588: LIST
26589: LIST
26590: LIST
26591: LIST
26592: LIST
26593: LIST
26594: LIST
26595: PUSH
26596: LD_INT 1
26598: PPUSH
26599: LD_INT 15
26601: PPUSH
26602: CALL_OW 12
26606: ARRAY
26607: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
26608: LD_ADDR_VAR 0 4
26612: PUSH
26613: LD_INT 10
26615: PUSH
26616: LD_INT 20
26618: PUSH
26619: LD_INT 30
26621: PUSH
26622: LD_INT 40
26624: PUSH
26625: LD_INT 50
26627: PUSH
26628: LD_INT 60
26630: PUSH
26631: LD_INT 70
26633: PUSH
26634: LD_INT 80
26636: PUSH
26637: LD_INT 90
26639: PUSH
26640: LD_INT 100
26642: PUSH
26643: LD_INT 110
26645: PUSH
26646: LD_INT 120
26648: PUSH
26649: LD_INT 130
26651: PUSH
26652: LD_INT 140
26654: PUSH
26655: LD_INT 150
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: PUSH
26675: LD_INT 1
26677: PPUSH
26678: LD_INT 15
26680: PPUSH
26681: CALL_OW 12
26685: ARRAY
26686: ST_TO_ADDR
// if ValidHex ( x , y ) then
26687: LD_VAR 0 3
26691: PPUSH
26692: LD_VAR 0 4
26696: PPUSH
26697: CALL_OW 488
26701: IFFALSE 26724
// begin result := [ x , y ] ;
26703: LD_ADDR_VAR 0 1
26707: PUSH
26708: LD_VAR 0 3
26712: PUSH
26713: LD_VAR 0 4
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: ST_TO_ADDR
// break ;
26722: GO 26726
// end ; end ;
26724: GO 26526
26726: POP
26727: POP
// if result then
26728: LD_VAR 0 1
26732: IFFALSE 26792
// begin ToLua ( playSibBomb() ) ;
26734: LD_STRING playSibBomb()
26736: PPUSH
26737: CALL_OW 559
// wait ( 0 0$14 ) ;
26741: LD_INT 490
26743: PPUSH
26744: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
26748: LD_VAR 0 1
26752: PUSH
26753: LD_INT 1
26755: ARRAY
26756: PPUSH
26757: LD_VAR 0 1
26761: PUSH
26762: LD_INT 2
26764: ARRAY
26765: PPUSH
26766: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
26770: LD_VAR 0 1
26774: PUSH
26775: LD_INT 1
26777: ARRAY
26778: PPUSH
26779: LD_VAR 0 1
26783: PUSH
26784: LD_INT 2
26786: ARRAY
26787: PPUSH
26788: CALL_OW 429
// end ; end ;
26792: LD_VAR 0 1
26796: RET
// every 0 0$1 trigger StreamModeActive and sReset do
26797: LD_EXP 63
26801: PUSH
26802: LD_EXP 85
26806: AND
26807: IFFALSE 26819
26809: GO 26811
26811: DISABLE
// YouLost (  ) ;
26812: LD_STRING 
26814: PPUSH
26815: CALL_OW 104
26819: END
// every 0 0$1 trigger StreamModeActive and sFog do
26820: LD_EXP 63
26824: PUSH
26825: LD_EXP 84
26829: AND
26830: IFFALSE 26844
26832: GO 26834
26834: DISABLE
// FogOff ( your_side ) ;
26835: LD_OWVAR 2
26839: PPUSH
26840: CALL_OW 344
26844: END
// every 0 0$1 trigger StreamModeActive and sSun do
26845: LD_EXP 63
26849: PUSH
26850: LD_EXP 86
26854: AND
26855: IFFALSE 26883
26857: GO 26859
26859: DISABLE
// begin solar_recharge_percent := 0 ;
26860: LD_ADDR_OWVAR 79
26864: PUSH
26865: LD_INT 0
26867: ST_TO_ADDR
// wait ( 5 5$00 ) ;
26868: LD_INT 10500
26870: PPUSH
26871: CALL_OW 67
// solar_recharge_percent := 100 ;
26875: LD_ADDR_OWVAR 79
26879: PUSH
26880: LD_INT 100
26882: ST_TO_ADDR
// end ;
26883: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
26884: LD_EXP 63
26888: PUSH
26889: LD_EXP 87
26893: AND
26894: IFFALSE 27133
26896: GO 26898
26898: DISABLE
26899: LD_INT 0
26901: PPUSH
26902: PPUSH
26903: PPUSH
// begin tmp := [ ] ;
26904: LD_ADDR_VAR 0 3
26908: PUSH
26909: EMPTY
26910: ST_TO_ADDR
// for i := 1 to 6 do
26911: LD_ADDR_VAR 0 1
26915: PUSH
26916: DOUBLE
26917: LD_INT 1
26919: DEC
26920: ST_TO_ADDR
26921: LD_INT 6
26923: PUSH
26924: FOR_TO
26925: IFFALSE 27030
// begin uc_nation := nation_nature ;
26927: LD_ADDR_OWVAR 21
26931: PUSH
26932: LD_INT 0
26934: ST_TO_ADDR
// uc_side := 0 ;
26935: LD_ADDR_OWVAR 20
26939: PUSH
26940: LD_INT 0
26942: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
26943: LD_ADDR_OWVAR 29
26947: PUSH
26948: LD_INT 12
26950: PUSH
26951: LD_INT 12
26953: PUSH
26954: EMPTY
26955: LIST
26956: LIST
26957: ST_TO_ADDR
// hc_agressivity := 20 ;
26958: LD_ADDR_OWVAR 35
26962: PUSH
26963: LD_INT 20
26965: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
26966: LD_ADDR_OWVAR 28
26970: PUSH
26971: LD_INT 17
26973: ST_TO_ADDR
// hc_gallery :=  ;
26974: LD_ADDR_OWVAR 33
26978: PUSH
26979: LD_STRING 
26981: ST_TO_ADDR
// hc_name :=  ;
26982: LD_ADDR_OWVAR 26
26986: PUSH
26987: LD_STRING 
26989: ST_TO_ADDR
// un := CreateHuman ;
26990: LD_ADDR_VAR 0 2
26994: PUSH
26995: CALL_OW 44
26999: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
27000: LD_VAR 0 2
27004: PPUSH
27005: LD_INT 1
27007: PPUSH
27008: CALL_OW 51
// tmp := tmp ^ un ;
27012: LD_ADDR_VAR 0 3
27016: PUSH
27017: LD_VAR 0 3
27021: PUSH
27022: LD_VAR 0 2
27026: ADD
27027: ST_TO_ADDR
// end ;
27028: GO 26924
27030: POP
27031: POP
// repeat wait ( 0 0$1 ) ;
27032: LD_INT 35
27034: PPUSH
27035: CALL_OW 67
// for un in tmp do
27039: LD_ADDR_VAR 0 2
27043: PUSH
27044: LD_VAR 0 3
27048: PUSH
27049: FOR_IN
27050: IFFALSE 27124
// begin if IsDead ( un ) then
27052: LD_VAR 0 2
27056: PPUSH
27057: CALL_OW 301
27061: IFFALSE 27081
// begin tmp := tmp diff un ;
27063: LD_ADDR_VAR 0 3
27067: PUSH
27068: LD_VAR 0 3
27072: PUSH
27073: LD_VAR 0 2
27077: DIFF
27078: ST_TO_ADDR
// continue ;
27079: GO 27049
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
27081: LD_VAR 0 2
27085: PPUSH
27086: LD_INT 3
27088: PUSH
27089: LD_INT 22
27091: PUSH
27092: LD_INT 0
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: PUSH
27099: EMPTY
27100: LIST
27101: LIST
27102: PPUSH
27103: CALL_OW 69
27107: PPUSH
27108: LD_VAR 0 2
27112: PPUSH
27113: CALL_OW 74
27117: PPUSH
27118: CALL_OW 115
// end ;
27122: GO 27049
27124: POP
27125: POP
// until not tmp ;
27126: LD_VAR 0 3
27130: NOT
27131: IFFALSE 27032
// end ;
27133: PPOPN 3
27135: END
// every 0 0$1 trigger StreamModeActive and sTroll do
27136: LD_EXP 63
27140: PUSH
27141: LD_EXP 88
27145: AND
27146: IFFALSE 27200
27148: GO 27150
27150: DISABLE
// begin ToLua ( displayTroll(); ) ;
27151: LD_STRING displayTroll();
27153: PPUSH
27154: CALL_OW 559
// wait ( 3 3$00 ) ;
27158: LD_INT 6300
27160: PPUSH
27161: CALL_OW 67
// ToLua ( hideTroll(); ) ;
27165: LD_STRING hideTroll();
27167: PPUSH
27168: CALL_OW 559
// wait ( 1 1$00 ) ;
27172: LD_INT 2100
27174: PPUSH
27175: CALL_OW 67
// ToLua ( displayTroll(); ) ;
27179: LD_STRING displayTroll();
27181: PPUSH
27182: CALL_OW 559
// wait ( 1 1$00 ) ;
27186: LD_INT 2100
27188: PPUSH
27189: CALL_OW 67
// ToLua ( hideTroll(); ) ;
27193: LD_STRING hideTroll();
27195: PPUSH
27196: CALL_OW 559
// end ;
27200: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
27201: LD_EXP 63
27205: PUSH
27206: LD_EXP 89
27210: AND
27211: IFFALSE 27274
27213: GO 27215
27215: DISABLE
27216: LD_INT 0
27218: PPUSH
// begin p := 0 ;
27219: LD_ADDR_VAR 0 1
27223: PUSH
27224: LD_INT 0
27226: ST_TO_ADDR
// repeat game_speed := 1 ;
27227: LD_ADDR_OWVAR 65
27231: PUSH
27232: LD_INT 1
27234: ST_TO_ADDR
// wait ( 0 0$1 ) ;
27235: LD_INT 35
27237: PPUSH
27238: CALL_OW 67
// p := p + 1 ;
27242: LD_ADDR_VAR 0 1
27246: PUSH
27247: LD_VAR 0 1
27251: PUSH
27252: LD_INT 1
27254: PLUS
27255: ST_TO_ADDR
// until p >= 60 ;
27256: LD_VAR 0 1
27260: PUSH
27261: LD_INT 60
27263: GREATEREQUAL
27264: IFFALSE 27227
// game_speed := 4 ;
27266: LD_ADDR_OWVAR 65
27270: PUSH
27271: LD_INT 4
27273: ST_TO_ADDR
// end ;
27274: PPOPN 1
27276: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
27277: LD_EXP 63
27281: PUSH
27282: LD_EXP 90
27286: AND
27287: IFFALSE 27433
27289: GO 27291
27291: DISABLE
27292: LD_INT 0
27294: PPUSH
27295: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27296: LD_ADDR_VAR 0 1
27300: PUSH
27301: LD_INT 22
27303: PUSH
27304: LD_OWVAR 2
27308: PUSH
27309: EMPTY
27310: LIST
27311: LIST
27312: PUSH
27313: LD_INT 2
27315: PUSH
27316: LD_INT 30
27318: PUSH
27319: LD_INT 0
27321: PUSH
27322: EMPTY
27323: LIST
27324: LIST
27325: PUSH
27326: LD_INT 30
27328: PUSH
27329: LD_INT 1
27331: PUSH
27332: EMPTY
27333: LIST
27334: LIST
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: LIST
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PPUSH
27345: CALL_OW 69
27349: ST_TO_ADDR
// if not depot then
27350: LD_VAR 0 1
27354: NOT
27355: IFFALSE 27359
// exit ;
27357: GO 27433
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
27359: LD_ADDR_VAR 0 2
27363: PUSH
27364: LD_VAR 0 1
27368: PUSH
27369: LD_INT 1
27371: PPUSH
27372: LD_VAR 0 1
27376: PPUSH
27377: CALL_OW 12
27381: ARRAY
27382: PPUSH
27383: CALL_OW 274
27387: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
27388: LD_VAR 0 2
27392: PPUSH
27393: LD_INT 1
27395: PPUSH
27396: LD_INT 0
27398: PPUSH
27399: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
27403: LD_VAR 0 2
27407: PPUSH
27408: LD_INT 2
27410: PPUSH
27411: LD_INT 0
27413: PPUSH
27414: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
27418: LD_VAR 0 2
27422: PPUSH
27423: LD_INT 3
27425: PPUSH
27426: LD_INT 0
27428: PPUSH
27429: CALL_OW 277
// end ;
27433: PPOPN 2
27435: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
27436: LD_EXP 63
27440: PUSH
27441: LD_EXP 91
27445: AND
27446: IFFALSE 27543
27448: GO 27450
27450: DISABLE
27451: LD_INT 0
27453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
27454: LD_ADDR_VAR 0 1
27458: PUSH
27459: LD_INT 22
27461: PUSH
27462: LD_OWVAR 2
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: PUSH
27471: LD_INT 21
27473: PUSH
27474: LD_INT 1
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: LD_INT 3
27483: PUSH
27484: LD_INT 23
27486: PUSH
27487: LD_INT 0
27489: PUSH
27490: EMPTY
27491: LIST
27492: LIST
27493: PUSH
27494: EMPTY
27495: LIST
27496: LIST
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: LIST
27502: PPUSH
27503: CALL_OW 69
27507: ST_TO_ADDR
// if not tmp then
27508: LD_VAR 0 1
27512: NOT
27513: IFFALSE 27517
// exit ;
27515: GO 27543
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
27517: LD_VAR 0 1
27521: PUSH
27522: LD_INT 1
27524: PPUSH
27525: LD_VAR 0 1
27529: PPUSH
27530: CALL_OW 12
27534: ARRAY
27535: PPUSH
27536: LD_INT 200
27538: PPUSH
27539: CALL_OW 234
// end ;
27543: PPOPN 1
27545: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
27546: LD_EXP 63
27550: PUSH
27551: LD_EXP 92
27555: AND
27556: IFFALSE 27635
27558: GO 27560
27560: DISABLE
27561: LD_INT 0
27563: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
27564: LD_ADDR_VAR 0 1
27568: PUSH
27569: LD_INT 22
27571: PUSH
27572: LD_OWVAR 2
27576: PUSH
27577: EMPTY
27578: LIST
27579: LIST
27580: PUSH
27581: LD_INT 21
27583: PUSH
27584: LD_INT 2
27586: PUSH
27587: EMPTY
27588: LIST
27589: LIST
27590: PUSH
27591: EMPTY
27592: LIST
27593: LIST
27594: PPUSH
27595: CALL_OW 69
27599: ST_TO_ADDR
// if not tmp then
27600: LD_VAR 0 1
27604: NOT
27605: IFFALSE 27609
// exit ;
27607: GO 27635
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
27609: LD_VAR 0 1
27613: PUSH
27614: LD_INT 1
27616: PPUSH
27617: LD_VAR 0 1
27621: PPUSH
27622: CALL_OW 12
27626: ARRAY
27627: PPUSH
27628: LD_INT 60
27630: PPUSH
27631: CALL_OW 234
// end ;
27635: PPOPN 1
27637: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
27638: LD_EXP 63
27642: PUSH
27643: LD_EXP 93
27647: AND
27648: IFFALSE 27747
27650: GO 27652
27652: DISABLE
27653: LD_INT 0
27655: PPUSH
27656: PPUSH
// begin enable ;
27657: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
27658: LD_ADDR_VAR 0 1
27662: PUSH
27663: LD_INT 22
27665: PUSH
27666: LD_OWVAR 2
27670: PUSH
27671: EMPTY
27672: LIST
27673: LIST
27674: PUSH
27675: LD_INT 61
27677: PUSH
27678: EMPTY
27679: LIST
27680: PUSH
27681: LD_INT 33
27683: PUSH
27684: LD_INT 2
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: LIST
27695: PPUSH
27696: CALL_OW 69
27700: ST_TO_ADDR
// if not tmp then
27701: LD_VAR 0 1
27705: NOT
27706: IFFALSE 27710
// exit ;
27708: GO 27747
// for i in tmp do
27710: LD_ADDR_VAR 0 2
27714: PUSH
27715: LD_VAR 0 1
27719: PUSH
27720: FOR_IN
27721: IFFALSE 27745
// if IsControledBy ( i ) then
27723: LD_VAR 0 2
27727: PPUSH
27728: CALL_OW 312
27732: IFFALSE 27743
// ComUnlink ( i ) ;
27734: LD_VAR 0 2
27738: PPUSH
27739: CALL_OW 136
27743: GO 27720
27745: POP
27746: POP
// end ;
27747: PPOPN 2
27749: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
27750: LD_EXP 63
27754: PUSH
27755: LD_EXP 94
27759: AND
27760: IFFALSE 27900
27762: GO 27764
27764: DISABLE
27765: LD_INT 0
27767: PPUSH
27768: PPUSH
// begin ToLua ( displayPowell(); ) ;
27769: LD_STRING displayPowell();
27771: PPUSH
27772: CALL_OW 559
// uc_side := 0 ;
27776: LD_ADDR_OWVAR 20
27780: PUSH
27781: LD_INT 0
27783: ST_TO_ADDR
// uc_nation := 2 ;
27784: LD_ADDR_OWVAR 21
27788: PUSH
27789: LD_INT 2
27791: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
27792: LD_ADDR_OWVAR 37
27796: PUSH
27797: LD_INT 14
27799: ST_TO_ADDR
// vc_engine := engine_siberite ;
27800: LD_ADDR_OWVAR 39
27804: PUSH
27805: LD_INT 3
27807: ST_TO_ADDR
// vc_control := control_apeman ;
27808: LD_ADDR_OWVAR 38
27812: PUSH
27813: LD_INT 5
27815: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
27816: LD_ADDR_OWVAR 40
27820: PUSH
27821: LD_INT 29
27823: ST_TO_ADDR
// un := CreateVehicle ;
27824: LD_ADDR_VAR 0 2
27828: PUSH
27829: CALL_OW 45
27833: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27834: LD_VAR 0 2
27838: PPUSH
27839: LD_INT 1
27841: PPUSH
27842: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27846: LD_INT 35
27848: PPUSH
27849: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27853: LD_VAR 0 2
27857: PPUSH
27858: LD_INT 22
27860: PUSH
27861: LD_OWVAR 2
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PPUSH
27870: CALL_OW 69
27874: PPUSH
27875: LD_VAR 0 2
27879: PPUSH
27880: CALL_OW 74
27884: PPUSH
27885: CALL_OW 115
// until IsDead ( un ) ;
27889: LD_VAR 0 2
27893: PPUSH
27894: CALL_OW 301
27898: IFFALSE 27846
// end ;
27900: PPOPN 2
27902: END
// every 0 0$1 trigger StreamModeActive and sStu do
27903: LD_EXP 63
27907: PUSH
27908: LD_EXP 102
27912: AND
27913: IFFALSE 27929
27915: GO 27917
27917: DISABLE
// begin ToLua ( displayStucuk(); ) ;
27918: LD_STRING displayStucuk();
27920: PPUSH
27921: CALL_OW 559
// ResetFog ;
27925: CALL_OW 335
// end ;
27929: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
27930: LD_EXP 63
27934: PUSH
27935: LD_EXP 95
27939: AND
27940: IFFALSE 28081
27942: GO 27944
27944: DISABLE
27945: LD_INT 0
27947: PPUSH
27948: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27949: LD_ADDR_VAR 0 2
27953: PUSH
27954: LD_INT 22
27956: PUSH
27957: LD_OWVAR 2
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 21
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: EMPTY
27977: LIST
27978: LIST
27979: PPUSH
27980: CALL_OW 69
27984: ST_TO_ADDR
// if not tmp then
27985: LD_VAR 0 2
27989: NOT
27990: IFFALSE 27994
// exit ;
27992: GO 28081
// un := tmp [ rand ( 1 , tmp ) ] ;
27994: LD_ADDR_VAR 0 1
27998: PUSH
27999: LD_VAR 0 2
28003: PUSH
28004: LD_INT 1
28006: PPUSH
28007: LD_VAR 0 2
28011: PPUSH
28012: CALL_OW 12
28016: ARRAY
28017: ST_TO_ADDR
// SetSide ( un , 0 ) ;
28018: LD_VAR 0 1
28022: PPUSH
28023: LD_INT 0
28025: PPUSH
28026: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
28030: LD_VAR 0 1
28034: PPUSH
28035: LD_OWVAR 3
28039: PUSH
28040: LD_VAR 0 1
28044: DIFF
28045: PPUSH
28046: LD_VAR 0 1
28050: PPUSH
28051: CALL_OW 74
28055: PPUSH
28056: CALL_OW 115
// wait ( 0 0$20 ) ;
28060: LD_INT 700
28062: PPUSH
28063: CALL_OW 67
// SetSide ( un , your_side ) ;
28067: LD_VAR 0 1
28071: PPUSH
28072: LD_OWVAR 2
28076: PPUSH
28077: CALL_OW 235
// end ;
28081: PPOPN 2
28083: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
28084: LD_EXP 63
28088: PUSH
28089: LD_EXP 96
28093: AND
28094: IFFALSE 28200
28096: GO 28098
28098: DISABLE
28099: LD_INT 0
28101: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28102: LD_ADDR_VAR 0 1
28106: PUSH
28107: LD_INT 22
28109: PUSH
28110: LD_OWVAR 2
28114: PUSH
28115: EMPTY
28116: LIST
28117: LIST
28118: PUSH
28119: LD_INT 2
28121: PUSH
28122: LD_INT 30
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: LD_INT 30
28134: PUSH
28135: LD_INT 1
28137: PUSH
28138: EMPTY
28139: LIST
28140: LIST
28141: PUSH
28142: EMPTY
28143: LIST
28144: LIST
28145: LIST
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PPUSH
28151: CALL_OW 69
28155: ST_TO_ADDR
// if not depot then
28156: LD_VAR 0 1
28160: NOT
28161: IFFALSE 28165
// exit ;
28163: GO 28200
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
28165: LD_VAR 0 1
28169: PUSH
28170: LD_INT 1
28172: ARRAY
28173: PPUSH
28174: CALL_OW 250
28178: PPUSH
28179: LD_VAR 0 1
28183: PUSH
28184: LD_INT 1
28186: ARRAY
28187: PPUSH
28188: CALL_OW 251
28192: PPUSH
28193: LD_INT 70
28195: PPUSH
28196: CALL_OW 495
// end ;
28200: PPOPN 1
28202: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
28203: LD_EXP 63
28207: PUSH
28208: LD_EXP 97
28212: AND
28213: IFFALSE 28424
28215: GO 28217
28217: DISABLE
28218: LD_INT 0
28220: PPUSH
28221: PPUSH
28222: PPUSH
28223: PPUSH
28224: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
28225: LD_ADDR_VAR 0 5
28229: PUSH
28230: LD_INT 22
28232: PUSH
28233: LD_OWVAR 2
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: PUSH
28242: LD_INT 21
28244: PUSH
28245: LD_INT 1
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: PPUSH
28256: CALL_OW 69
28260: ST_TO_ADDR
// if not tmp then
28261: LD_VAR 0 5
28265: NOT
28266: IFFALSE 28270
// exit ;
28268: GO 28424
// for i in tmp do
28270: LD_ADDR_VAR 0 1
28274: PUSH
28275: LD_VAR 0 5
28279: PUSH
28280: FOR_IN
28281: IFFALSE 28422
// begin d := rand ( 0 , 5 ) ;
28283: LD_ADDR_VAR 0 4
28287: PUSH
28288: LD_INT 0
28290: PPUSH
28291: LD_INT 5
28293: PPUSH
28294: CALL_OW 12
28298: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
28299: LD_ADDR_VAR 0 2
28303: PUSH
28304: LD_VAR 0 1
28308: PPUSH
28309: CALL_OW 250
28313: PPUSH
28314: LD_VAR 0 4
28318: PPUSH
28319: LD_INT 3
28321: PPUSH
28322: LD_INT 12
28324: PPUSH
28325: CALL_OW 12
28329: PPUSH
28330: CALL_OW 272
28334: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
28335: LD_ADDR_VAR 0 3
28339: PUSH
28340: LD_VAR 0 1
28344: PPUSH
28345: CALL_OW 251
28349: PPUSH
28350: LD_VAR 0 4
28354: PPUSH
28355: LD_INT 3
28357: PPUSH
28358: LD_INT 12
28360: PPUSH
28361: CALL_OW 12
28365: PPUSH
28366: CALL_OW 273
28370: ST_TO_ADDR
// if ValidHex ( x , y ) then
28371: LD_VAR 0 2
28375: PPUSH
28376: LD_VAR 0 3
28380: PPUSH
28381: CALL_OW 488
28385: IFFALSE 28420
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
28387: LD_VAR 0 1
28391: PPUSH
28392: LD_VAR 0 2
28396: PPUSH
28397: LD_VAR 0 3
28401: PPUSH
28402: LD_INT 3
28404: PPUSH
28405: LD_INT 6
28407: PPUSH
28408: CALL_OW 12
28412: PPUSH
28413: LD_INT 1
28415: PPUSH
28416: CALL_OW 483
// end ;
28420: GO 28280
28422: POP
28423: POP
// end ;
28424: PPOPN 5
28426: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
28427: LD_EXP 63
28431: PUSH
28432: LD_EXP 98
28436: AND
28437: IFFALSE 28531
28439: GO 28441
28441: DISABLE
28442: LD_INT 0
28444: PPUSH
28445: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
28446: LD_ADDR_VAR 0 2
28450: PUSH
28451: LD_INT 22
28453: PUSH
28454: LD_OWVAR 2
28458: PUSH
28459: EMPTY
28460: LIST
28461: LIST
28462: PUSH
28463: LD_INT 32
28465: PUSH
28466: LD_INT 1
28468: PUSH
28469: EMPTY
28470: LIST
28471: LIST
28472: PUSH
28473: LD_INT 21
28475: PUSH
28476: LD_INT 2
28478: PUSH
28479: EMPTY
28480: LIST
28481: LIST
28482: PUSH
28483: EMPTY
28484: LIST
28485: LIST
28486: LIST
28487: PPUSH
28488: CALL_OW 69
28492: ST_TO_ADDR
// if not tmp then
28493: LD_VAR 0 2
28497: NOT
28498: IFFALSE 28502
// exit ;
28500: GO 28531
// for i in tmp do
28502: LD_ADDR_VAR 0 1
28506: PUSH
28507: LD_VAR 0 2
28511: PUSH
28512: FOR_IN
28513: IFFALSE 28529
// SetFuel ( i , 0 ) ;
28515: LD_VAR 0 1
28519: PPUSH
28520: LD_INT 0
28522: PPUSH
28523: CALL_OW 240
28527: GO 28512
28529: POP
28530: POP
// end ;
28531: PPOPN 2
28533: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
28534: LD_EXP 63
28538: PUSH
28539: LD_EXP 99
28543: AND
28544: IFFALSE 28610
28546: GO 28548
28548: DISABLE
28549: LD_INT 0
28551: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28552: LD_ADDR_VAR 0 1
28556: PUSH
28557: LD_INT 22
28559: PUSH
28560: LD_OWVAR 2
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 30
28571: PUSH
28572: LD_INT 29
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PPUSH
28583: CALL_OW 69
28587: ST_TO_ADDR
// if not tmp then
28588: LD_VAR 0 1
28592: NOT
28593: IFFALSE 28597
// exit ;
28595: GO 28610
// DestroyUnit ( tmp [ 1 ] ) ;
28597: LD_VAR 0 1
28601: PUSH
28602: LD_INT 1
28604: ARRAY
28605: PPUSH
28606: CALL_OW 65
// end ;
28610: PPOPN 1
28612: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
28613: LD_EXP 63
28617: PUSH
28618: LD_EXP 101
28622: AND
28623: IFFALSE 28752
28625: GO 28627
28627: DISABLE
28628: LD_INT 0
28630: PPUSH
// begin uc_side := 0 ;
28631: LD_ADDR_OWVAR 20
28635: PUSH
28636: LD_INT 0
28638: ST_TO_ADDR
// uc_nation := nation_arabian ;
28639: LD_ADDR_OWVAR 21
28643: PUSH
28644: LD_INT 2
28646: ST_TO_ADDR
// hc_gallery :=  ;
28647: LD_ADDR_OWVAR 33
28651: PUSH
28652: LD_STRING 
28654: ST_TO_ADDR
// hc_name :=  ;
28655: LD_ADDR_OWVAR 26
28659: PUSH
28660: LD_STRING 
28662: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
28663: LD_INT 1
28665: PPUSH
28666: LD_INT 11
28668: PPUSH
28669: LD_INT 10
28671: PPUSH
28672: CALL_OW 380
// un := CreateHuman ;
28676: LD_ADDR_VAR 0 1
28680: PUSH
28681: CALL_OW 44
28685: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28686: LD_VAR 0 1
28690: PPUSH
28691: LD_INT 1
28693: PPUSH
28694: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
28698: LD_INT 35
28700: PPUSH
28701: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
28705: LD_VAR 0 1
28709: PPUSH
28710: LD_INT 22
28712: PUSH
28713: LD_OWVAR 2
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PPUSH
28722: CALL_OW 69
28726: PPUSH
28727: LD_VAR 0 1
28731: PPUSH
28732: CALL_OW 74
28736: PPUSH
28737: CALL_OW 115
// until IsDead ( un ) ;
28741: LD_VAR 0 1
28745: PPUSH
28746: CALL_OW 301
28750: IFFALSE 28698
// end ;
28752: PPOPN 1
28754: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
28755: LD_EXP 63
28759: PUSH
28760: LD_EXP 103
28764: AND
28765: IFFALSE 28777
28767: GO 28769
28769: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
28770: LD_STRING earthquake(getX(game), 0, 32)
28772: PPUSH
28773: CALL_OW 559
28777: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
28778: LD_EXP 63
28782: PUSH
28783: LD_EXP 104
28787: AND
28788: IFFALSE 28879
28790: GO 28792
28792: DISABLE
28793: LD_INT 0
28795: PPUSH
// begin enable ;
28796: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
28797: LD_ADDR_VAR 0 1
28801: PUSH
28802: LD_INT 22
28804: PUSH
28805: LD_OWVAR 2
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: LD_INT 21
28816: PUSH
28817: LD_INT 2
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PUSH
28824: LD_INT 33
28826: PUSH
28827: LD_INT 3
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: LIST
28838: PPUSH
28839: CALL_OW 69
28843: ST_TO_ADDR
// if not tmp then
28844: LD_VAR 0 1
28848: NOT
28849: IFFALSE 28853
// exit ;
28851: GO 28879
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28853: LD_VAR 0 1
28857: PUSH
28858: LD_INT 1
28860: PPUSH
28861: LD_VAR 0 1
28865: PPUSH
28866: CALL_OW 12
28870: ARRAY
28871: PPUSH
28872: LD_INT 1
28874: PPUSH
28875: CALL_OW 234
// end ;
28879: PPOPN 1
28881: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
28882: LD_EXP 63
28886: PUSH
28887: LD_EXP 105
28891: AND
28892: IFFALSE 29033
28894: GO 28896
28896: DISABLE
28897: LD_INT 0
28899: PPUSH
28900: PPUSH
28901: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28902: LD_ADDR_VAR 0 3
28906: PUSH
28907: LD_INT 22
28909: PUSH
28910: LD_OWVAR 2
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: PUSH
28919: LD_INT 25
28921: PUSH
28922: LD_INT 1
28924: PUSH
28925: EMPTY
28926: LIST
28927: LIST
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PPUSH
28933: CALL_OW 69
28937: ST_TO_ADDR
// if not tmp then
28938: LD_VAR 0 3
28942: NOT
28943: IFFALSE 28947
// exit ;
28945: GO 29033
// un := tmp [ rand ( 1 , tmp ) ] ;
28947: LD_ADDR_VAR 0 2
28951: PUSH
28952: LD_VAR 0 3
28956: PUSH
28957: LD_INT 1
28959: PPUSH
28960: LD_VAR 0 3
28964: PPUSH
28965: CALL_OW 12
28969: ARRAY
28970: ST_TO_ADDR
// if Crawls ( un ) then
28971: LD_VAR 0 2
28975: PPUSH
28976: CALL_OW 318
28980: IFFALSE 28991
// ComWalk ( un ) ;
28982: LD_VAR 0 2
28986: PPUSH
28987: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
28991: LD_VAR 0 2
28995: PPUSH
28996: LD_INT 9
28998: PPUSH
28999: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
29003: LD_INT 28
29005: PPUSH
29006: LD_OWVAR 2
29010: PPUSH
29011: LD_INT 2
29013: PPUSH
29014: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
29018: LD_INT 29
29020: PPUSH
29021: LD_OWVAR 2
29025: PPUSH
29026: LD_INT 2
29028: PPUSH
29029: CALL_OW 322
// end ;
29033: PPOPN 3
29035: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
29036: LD_EXP 63
29040: PUSH
29041: LD_EXP 106
29045: AND
29046: IFFALSE 29157
29048: GO 29050
29050: DISABLE
29051: LD_INT 0
29053: PPUSH
29054: PPUSH
29055: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
29056: LD_ADDR_VAR 0 3
29060: PUSH
29061: LD_INT 22
29063: PUSH
29064: LD_OWVAR 2
29068: PUSH
29069: EMPTY
29070: LIST
29071: LIST
29072: PUSH
29073: LD_INT 25
29075: PUSH
29076: LD_INT 1
29078: PUSH
29079: EMPTY
29080: LIST
29081: LIST
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PPUSH
29087: CALL_OW 69
29091: ST_TO_ADDR
// if not tmp then
29092: LD_VAR 0 3
29096: NOT
29097: IFFALSE 29101
// exit ;
29099: GO 29157
// un := tmp [ rand ( 1 , tmp ) ] ;
29101: LD_ADDR_VAR 0 2
29105: PUSH
29106: LD_VAR 0 3
29110: PUSH
29111: LD_INT 1
29113: PPUSH
29114: LD_VAR 0 3
29118: PPUSH
29119: CALL_OW 12
29123: ARRAY
29124: ST_TO_ADDR
// if Crawls ( un ) then
29125: LD_VAR 0 2
29129: PPUSH
29130: CALL_OW 318
29134: IFFALSE 29145
// ComWalk ( un ) ;
29136: LD_VAR 0 2
29140: PPUSH
29141: CALL_OW 138
// SetClass ( un , class_mortar ) ;
29145: LD_VAR 0 2
29149: PPUSH
29150: LD_INT 8
29152: PPUSH
29153: CALL_OW 336
// end ;
29157: PPOPN 3
29159: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
29160: LD_EXP 63
29164: PUSH
29165: LD_EXP 107
29169: AND
29170: IFFALSE 29314
29172: GO 29174
29174: DISABLE
29175: LD_INT 0
29177: PPUSH
29178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
29179: LD_ADDR_VAR 0 2
29183: PUSH
29184: LD_INT 22
29186: PUSH
29187: LD_OWVAR 2
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 21
29198: PUSH
29199: LD_INT 2
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PUSH
29206: LD_INT 2
29208: PUSH
29209: LD_INT 34
29211: PUSH
29212: LD_INT 12
29214: PUSH
29215: EMPTY
29216: LIST
29217: LIST
29218: PUSH
29219: LD_INT 34
29221: PUSH
29222: LD_INT 51
29224: PUSH
29225: EMPTY
29226: LIST
29227: LIST
29228: PUSH
29229: LD_INT 34
29231: PUSH
29232: LD_INT 32
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: EMPTY
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: LIST
29249: PPUSH
29250: CALL_OW 69
29254: ST_TO_ADDR
// if not tmp then
29255: LD_VAR 0 2
29259: NOT
29260: IFFALSE 29264
// exit ;
29262: GO 29314
// for i in tmp do
29264: LD_ADDR_VAR 0 1
29268: PUSH
29269: LD_VAR 0 2
29273: PUSH
29274: FOR_IN
29275: IFFALSE 29312
// if GetCargo ( i , mat_artifact ) = 0 then
29277: LD_VAR 0 1
29281: PPUSH
29282: LD_INT 4
29284: PPUSH
29285: CALL_OW 289
29289: PUSH
29290: LD_INT 0
29292: EQUAL
29293: IFFALSE 29310
// SetCargo ( i , mat_siberit , 100 ) ;
29295: LD_VAR 0 1
29299: PPUSH
29300: LD_INT 3
29302: PPUSH
29303: LD_INT 100
29305: PPUSH
29306: CALL_OW 290
29310: GO 29274
29312: POP
29313: POP
// end ;
29314: PPOPN 2
29316: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
29317: LD_EXP 63
29321: PUSH
29322: LD_EXP 108
29326: AND
29327: IFFALSE 29510
29329: GO 29331
29331: DISABLE
29332: LD_INT 0
29334: PPUSH
29335: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
29336: LD_ADDR_VAR 0 2
29340: PUSH
29341: LD_INT 22
29343: PUSH
29344: LD_OWVAR 2
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PPUSH
29353: CALL_OW 69
29357: ST_TO_ADDR
// if not tmp then
29358: LD_VAR 0 2
29362: NOT
29363: IFFALSE 29367
// exit ;
29365: GO 29510
// for i := 1 to 2 do
29367: LD_ADDR_VAR 0 1
29371: PUSH
29372: DOUBLE
29373: LD_INT 1
29375: DEC
29376: ST_TO_ADDR
29377: LD_INT 2
29379: PUSH
29380: FOR_TO
29381: IFFALSE 29508
// begin uc_side := your_side ;
29383: LD_ADDR_OWVAR 20
29387: PUSH
29388: LD_OWVAR 2
29392: ST_TO_ADDR
// uc_nation := nation_american ;
29393: LD_ADDR_OWVAR 21
29397: PUSH
29398: LD_INT 1
29400: ST_TO_ADDR
// vc_chassis := us_morphling ;
29401: LD_ADDR_OWVAR 37
29405: PUSH
29406: LD_INT 5
29408: ST_TO_ADDR
// vc_engine := engine_siberite ;
29409: LD_ADDR_OWVAR 39
29413: PUSH
29414: LD_INT 3
29416: ST_TO_ADDR
// vc_control := control_computer ;
29417: LD_ADDR_OWVAR 38
29421: PUSH
29422: LD_INT 3
29424: ST_TO_ADDR
// vc_weapon := us_double_laser ;
29425: LD_ADDR_OWVAR 40
29429: PUSH
29430: LD_INT 10
29432: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
29433: LD_VAR 0 2
29437: PUSH
29438: LD_INT 1
29440: ARRAY
29441: PPUSH
29442: CALL_OW 310
29446: NOT
29447: IFFALSE 29494
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
29449: CALL_OW 45
29453: PPUSH
29454: LD_VAR 0 2
29458: PUSH
29459: LD_INT 1
29461: ARRAY
29462: PPUSH
29463: CALL_OW 250
29467: PPUSH
29468: LD_VAR 0 2
29472: PUSH
29473: LD_INT 1
29475: ARRAY
29476: PPUSH
29477: CALL_OW 251
29481: PPUSH
29482: LD_INT 12
29484: PPUSH
29485: LD_INT 1
29487: PPUSH
29488: CALL_OW 50
29492: GO 29506
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
29494: CALL_OW 45
29498: PPUSH
29499: LD_INT 1
29501: PPUSH
29502: CALL_OW 51
// end ;
29506: GO 29380
29508: POP
29509: POP
// end ;
29510: PPOPN 2
29512: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
29513: LD_EXP 63
29517: PUSH
29518: LD_EXP 109
29522: AND
29523: IFFALSE 29745
29525: GO 29527
29527: DISABLE
29528: LD_INT 0
29530: PPUSH
29531: PPUSH
29532: PPUSH
29533: PPUSH
29534: PPUSH
29535: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29536: LD_ADDR_VAR 0 6
29540: PUSH
29541: LD_INT 22
29543: PUSH
29544: LD_OWVAR 2
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: LD_INT 21
29555: PUSH
29556: LD_INT 1
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 3
29565: PUSH
29566: LD_INT 23
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: LIST
29584: PPUSH
29585: CALL_OW 69
29589: ST_TO_ADDR
// if not tmp then
29590: LD_VAR 0 6
29594: NOT
29595: IFFALSE 29599
// exit ;
29597: GO 29745
// s1 := rand ( 1 , 4 ) ;
29599: LD_ADDR_VAR 0 2
29603: PUSH
29604: LD_INT 1
29606: PPUSH
29607: LD_INT 4
29609: PPUSH
29610: CALL_OW 12
29614: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
29615: LD_ADDR_VAR 0 4
29619: PUSH
29620: LD_VAR 0 6
29624: PUSH
29625: LD_INT 1
29627: ARRAY
29628: PPUSH
29629: LD_VAR 0 2
29633: PPUSH
29634: CALL_OW 259
29638: ST_TO_ADDR
// if s1 = 1 then
29639: LD_VAR 0 2
29643: PUSH
29644: LD_INT 1
29646: EQUAL
29647: IFFALSE 29667
// s2 := rand ( 2 , 4 ) else
29649: LD_ADDR_VAR 0 3
29653: PUSH
29654: LD_INT 2
29656: PPUSH
29657: LD_INT 4
29659: PPUSH
29660: CALL_OW 12
29664: ST_TO_ADDR
29665: GO 29675
// s2 := 1 ;
29667: LD_ADDR_VAR 0 3
29671: PUSH
29672: LD_INT 1
29674: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
29675: LD_ADDR_VAR 0 5
29679: PUSH
29680: LD_VAR 0 6
29684: PUSH
29685: LD_INT 1
29687: ARRAY
29688: PPUSH
29689: LD_VAR 0 3
29693: PPUSH
29694: CALL_OW 259
29698: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
29699: LD_VAR 0 6
29703: PUSH
29704: LD_INT 1
29706: ARRAY
29707: PPUSH
29708: LD_VAR 0 2
29712: PPUSH
29713: LD_VAR 0 5
29717: PPUSH
29718: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
29722: LD_VAR 0 6
29726: PUSH
29727: LD_INT 1
29729: ARRAY
29730: PPUSH
29731: LD_VAR 0 3
29735: PPUSH
29736: LD_VAR 0 4
29740: PPUSH
29741: CALL_OW 237
// end ;
29745: PPOPN 6
29747: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
29748: LD_EXP 63
29752: PUSH
29753: LD_EXP 110
29757: AND
29758: IFFALSE 29837
29760: GO 29762
29762: DISABLE
29763: LD_INT 0
29765: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
29766: LD_ADDR_VAR 0 1
29770: PUSH
29771: LD_INT 22
29773: PUSH
29774: LD_OWVAR 2
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: LD_INT 30
29785: PUSH
29786: LD_INT 3
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PPUSH
29797: CALL_OW 69
29801: ST_TO_ADDR
// if not tmp then
29802: LD_VAR 0 1
29806: NOT
29807: IFFALSE 29811
// exit ;
29809: GO 29837
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
29811: LD_VAR 0 1
29815: PUSH
29816: LD_INT 1
29818: PPUSH
29819: LD_VAR 0 1
29823: PPUSH
29824: CALL_OW 12
29828: ARRAY
29829: PPUSH
29830: LD_INT 1
29832: PPUSH
29833: CALL_OW 234
// end ;
29837: PPOPN 1
29839: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
29840: LD_EXP 63
29844: PUSH
29845: LD_EXP 111
29849: AND
29850: IFFALSE 29962
29852: GO 29854
29854: DISABLE
29855: LD_INT 0
29857: PPUSH
29858: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
29859: LD_ADDR_VAR 0 2
29863: PUSH
29864: LD_INT 22
29866: PUSH
29867: LD_OWVAR 2
29871: PUSH
29872: EMPTY
29873: LIST
29874: LIST
29875: PUSH
29876: LD_INT 2
29878: PUSH
29879: LD_INT 30
29881: PUSH
29882: LD_INT 27
29884: PUSH
29885: EMPTY
29886: LIST
29887: LIST
29888: PUSH
29889: LD_INT 30
29891: PUSH
29892: LD_INT 26
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 30
29901: PUSH
29902: LD_INT 28
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: LIST
29913: LIST
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PPUSH
29919: CALL_OW 69
29923: ST_TO_ADDR
// if not tmp then
29924: LD_VAR 0 2
29928: NOT
29929: IFFALSE 29933
// exit ;
29931: GO 29962
// for i in tmp do
29933: LD_ADDR_VAR 0 1
29937: PUSH
29938: LD_VAR 0 2
29942: PUSH
29943: FOR_IN
29944: IFFALSE 29960
// SetLives ( i , 1 ) ;
29946: LD_VAR 0 1
29950: PPUSH
29951: LD_INT 1
29953: PPUSH
29954: CALL_OW 234
29958: GO 29943
29960: POP
29961: POP
// end ;
29962: PPOPN 2
29964: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
29965: LD_EXP 63
29969: PUSH
29970: LD_EXP 112
29974: AND
29975: IFFALSE 30249
29977: GO 29979
29979: DISABLE
29980: LD_INT 0
29982: PPUSH
29983: PPUSH
29984: PPUSH
// begin i := rand ( 1 , 7 ) ;
29985: LD_ADDR_VAR 0 1
29989: PUSH
29990: LD_INT 1
29992: PPUSH
29993: LD_INT 7
29995: PPUSH
29996: CALL_OW 12
30000: ST_TO_ADDR
// case i of 1 :
30001: LD_VAR 0 1
30005: PUSH
30006: LD_INT 1
30008: DOUBLE
30009: EQUAL
30010: IFTRUE 30014
30012: GO 30024
30014: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
30015: LD_STRING earthquake(getX(game), 0, 32)
30017: PPUSH
30018: CALL_OW 559
30022: GO 30249
30024: LD_INT 2
30026: DOUBLE
30027: EQUAL
30028: IFTRUE 30032
30030: GO 30046
30032: POP
// begin ToLua ( displayStucuk(); ) ;
30033: LD_STRING displayStucuk();
30035: PPUSH
30036: CALL_OW 559
// ResetFog ;
30040: CALL_OW 335
// end ; 3 :
30044: GO 30249
30046: LD_INT 3
30048: DOUBLE
30049: EQUAL
30050: IFTRUE 30054
30052: GO 30158
30054: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
30055: LD_ADDR_VAR 0 2
30059: PUSH
30060: LD_INT 22
30062: PUSH
30063: LD_OWVAR 2
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 25
30074: PUSH
30075: LD_INT 1
30077: PUSH
30078: EMPTY
30079: LIST
30080: LIST
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PPUSH
30086: CALL_OW 69
30090: ST_TO_ADDR
// if not tmp then
30091: LD_VAR 0 2
30095: NOT
30096: IFFALSE 30100
// exit ;
30098: GO 30249
// un := tmp [ rand ( 1 , tmp ) ] ;
30100: LD_ADDR_VAR 0 3
30104: PUSH
30105: LD_VAR 0 2
30109: PUSH
30110: LD_INT 1
30112: PPUSH
30113: LD_VAR 0 2
30117: PPUSH
30118: CALL_OW 12
30122: ARRAY
30123: ST_TO_ADDR
// if Crawls ( un ) then
30124: LD_VAR 0 3
30128: PPUSH
30129: CALL_OW 318
30133: IFFALSE 30144
// ComWalk ( un ) ;
30135: LD_VAR 0 3
30139: PPUSH
30140: CALL_OW 138
// SetClass ( un , class_mortar ) ;
30144: LD_VAR 0 3
30148: PPUSH
30149: LD_INT 8
30151: PPUSH
30152: CALL_OW 336
// end ; 4 :
30156: GO 30249
30158: LD_INT 4
30160: DOUBLE
30161: EQUAL
30162: IFTRUE 30166
30164: GO 30227
30166: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
30167: LD_ADDR_VAR 0 2
30171: PUSH
30172: LD_INT 22
30174: PUSH
30175: LD_OWVAR 2
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PUSH
30184: LD_INT 30
30186: PUSH
30187: LD_INT 29
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PPUSH
30198: CALL_OW 69
30202: ST_TO_ADDR
// if not tmp then
30203: LD_VAR 0 2
30207: NOT
30208: IFFALSE 30212
// exit ;
30210: GO 30249
// DestroyUnit ( tmp [ 1 ] ) ;
30212: LD_VAR 0 2
30216: PUSH
30217: LD_INT 1
30219: ARRAY
30220: PPUSH
30221: CALL_OW 65
// end ; 5 .. 7 :
30225: GO 30249
30227: LD_INT 5
30229: DOUBLE
30230: GREATEREQUAL
30231: IFFALSE 30239
30233: LD_INT 7
30235: DOUBLE
30236: LESSEQUAL
30237: IFTRUE 30241
30239: GO 30248
30241: POP
// StreamSibBomb ; end ;
30242: CALL 26499 0 0
30246: GO 30249
30248: POP
// end ;
30249: PPOPN 3
30251: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
30252: LD_EXP 63
30256: PUSH
30257: LD_EXP 113
30261: AND
30262: IFFALSE 30418
30264: GO 30266
30266: DISABLE
30267: LD_INT 0
30269: PPUSH
30270: PPUSH
30271: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
30272: LD_ADDR_VAR 0 2
30276: PUSH
30277: LD_INT 81
30279: PUSH
30280: LD_OWVAR 2
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: LD_INT 2
30291: PUSH
30292: LD_INT 21
30294: PUSH
30295: LD_INT 1
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PUSH
30302: LD_INT 21
30304: PUSH
30305: LD_INT 2
30307: PUSH
30308: EMPTY
30309: LIST
30310: LIST
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: LIST
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PPUSH
30321: CALL_OW 69
30325: ST_TO_ADDR
// if not tmp then
30326: LD_VAR 0 2
30330: NOT
30331: IFFALSE 30335
// exit ;
30333: GO 30418
// p := 0 ;
30335: LD_ADDR_VAR 0 3
30339: PUSH
30340: LD_INT 0
30342: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30343: LD_INT 35
30345: PPUSH
30346: CALL_OW 67
// p := p + 1 ;
30350: LD_ADDR_VAR 0 3
30354: PUSH
30355: LD_VAR 0 3
30359: PUSH
30360: LD_INT 1
30362: PLUS
30363: ST_TO_ADDR
// for i in tmp do
30364: LD_ADDR_VAR 0 1
30368: PUSH
30369: LD_VAR 0 2
30373: PUSH
30374: FOR_IN
30375: IFFALSE 30406
// if GetLives ( i ) < 1000 then
30377: LD_VAR 0 1
30381: PPUSH
30382: CALL_OW 256
30386: PUSH
30387: LD_INT 1000
30389: LESS
30390: IFFALSE 30404
// SetLives ( i , 1000 ) ;
30392: LD_VAR 0 1
30396: PPUSH
30397: LD_INT 1000
30399: PPUSH
30400: CALL_OW 234
30404: GO 30374
30406: POP
30407: POP
// until p > 20 ;
30408: LD_VAR 0 3
30412: PUSH
30413: LD_INT 20
30415: GREATER
30416: IFFALSE 30343
// end ;
30418: PPOPN 3
30420: END
// every 0 0$1 trigger StreamModeActive and sTime do
30421: LD_EXP 63
30425: PUSH
30426: LD_EXP 114
30430: AND
30431: IFFALSE 30466
30433: GO 30435
30435: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
30436: LD_INT 28
30438: PPUSH
30439: LD_OWVAR 2
30443: PPUSH
30444: LD_INT 2
30446: PPUSH
30447: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
30451: LD_INT 30
30453: PPUSH
30454: LD_OWVAR 2
30458: PPUSH
30459: LD_INT 2
30461: PPUSH
30462: CALL_OW 322
// end ;
30466: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
30467: LD_EXP 63
30471: PUSH
30472: LD_EXP 115
30476: AND
30477: IFFALSE 30598
30479: GO 30481
30481: DISABLE
30482: LD_INT 0
30484: PPUSH
30485: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
30486: LD_ADDR_VAR 0 2
30490: PUSH
30491: LD_INT 22
30493: PUSH
30494: LD_OWVAR 2
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: PUSH
30503: LD_INT 21
30505: PUSH
30506: LD_INT 1
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 3
30515: PUSH
30516: LD_INT 23
30518: PUSH
30519: LD_INT 0
30521: PUSH
30522: EMPTY
30523: LIST
30524: LIST
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: LIST
30534: PPUSH
30535: CALL_OW 69
30539: ST_TO_ADDR
// if not tmp then
30540: LD_VAR 0 2
30544: NOT
30545: IFFALSE 30549
// exit ;
30547: GO 30598
// for i in tmp do
30549: LD_ADDR_VAR 0 1
30553: PUSH
30554: LD_VAR 0 2
30558: PUSH
30559: FOR_IN
30560: IFFALSE 30596
// begin if Crawls ( i ) then
30562: LD_VAR 0 1
30566: PPUSH
30567: CALL_OW 318
30571: IFFALSE 30582
// ComWalk ( i ) ;
30573: LD_VAR 0 1
30577: PPUSH
30578: CALL_OW 138
// SetClass ( i , 2 ) ;
30582: LD_VAR 0 1
30586: PPUSH
30587: LD_INT 2
30589: PPUSH
30590: CALL_OW 336
// end ;
30594: GO 30559
30596: POP
30597: POP
// end ;
30598: PPOPN 2
30600: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
30601: LD_EXP 63
30605: PUSH
30606: LD_EXP 116
30610: AND
30611: IFFALSE 30892
30613: GO 30615
30615: DISABLE
30616: LD_INT 0
30618: PPUSH
30619: PPUSH
30620: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
30621: LD_OWVAR 2
30625: PPUSH
30626: LD_INT 9
30628: PPUSH
30629: LD_INT 1
30631: PPUSH
30632: LD_INT 1
30634: PPUSH
30635: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
30639: LD_INT 9
30641: PPUSH
30642: LD_OWVAR 2
30646: PPUSH
30647: CALL_OW 343
// uc_side := 9 ;
30651: LD_ADDR_OWVAR 20
30655: PUSH
30656: LD_INT 9
30658: ST_TO_ADDR
// uc_nation := 2 ;
30659: LD_ADDR_OWVAR 21
30663: PUSH
30664: LD_INT 2
30666: ST_TO_ADDR
// hc_name := Dark Warrior ;
30667: LD_ADDR_OWVAR 26
30671: PUSH
30672: LD_STRING Dark Warrior
30674: ST_TO_ADDR
// hc_gallery :=  ;
30675: LD_ADDR_OWVAR 33
30679: PUSH
30680: LD_STRING 
30682: ST_TO_ADDR
// hc_noskilllimit := true ;
30683: LD_ADDR_OWVAR 76
30687: PUSH
30688: LD_INT 1
30690: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
30691: LD_ADDR_OWVAR 31
30695: PUSH
30696: LD_INT 30
30698: PUSH
30699: LD_INT 30
30701: PUSH
30702: LD_INT 30
30704: PUSH
30705: LD_INT 30
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: LIST
30712: LIST
30713: ST_TO_ADDR
// un := CreateHuman ;
30714: LD_ADDR_VAR 0 3
30718: PUSH
30719: CALL_OW 44
30723: ST_TO_ADDR
// hc_noskilllimit := false ;
30724: LD_ADDR_OWVAR 76
30728: PUSH
30729: LD_INT 0
30731: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
30732: LD_VAR 0 3
30736: PPUSH
30737: LD_INT 1
30739: PPUSH
30740: CALL_OW 51
// p := 0 ;
30744: LD_ADDR_VAR 0 2
30748: PUSH
30749: LD_INT 0
30751: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30752: LD_INT 35
30754: PPUSH
30755: CALL_OW 67
// p := p + 1 ;
30759: LD_ADDR_VAR 0 2
30763: PUSH
30764: LD_VAR 0 2
30768: PUSH
30769: LD_INT 1
30771: PLUS
30772: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
30773: LD_VAR 0 3
30777: PPUSH
30778: CALL_OW 256
30782: PUSH
30783: LD_INT 1000
30785: LESS
30786: IFFALSE 30800
// SetLives ( un , 1000 ) ;
30788: LD_VAR 0 3
30792: PPUSH
30793: LD_INT 1000
30795: PPUSH
30796: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
30800: LD_VAR 0 3
30804: PPUSH
30805: LD_INT 81
30807: PUSH
30808: LD_OWVAR 2
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 91
30819: PUSH
30820: LD_VAR 0 3
30824: PUSH
30825: LD_INT 30
30827: PUSH
30828: EMPTY
30829: LIST
30830: LIST
30831: LIST
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PPUSH
30837: CALL_OW 69
30841: PPUSH
30842: LD_VAR 0 3
30846: PPUSH
30847: CALL_OW 74
30851: PPUSH
30852: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
30856: LD_VAR 0 2
30860: PUSH
30861: LD_INT 60
30863: GREATER
30864: PUSH
30865: LD_VAR 0 3
30869: PPUSH
30870: CALL_OW 301
30874: OR
30875: IFFALSE 30752
// if un then
30877: LD_VAR 0 3
30881: IFFALSE 30892
// RemoveUnit ( un ) ;
30883: LD_VAR 0 3
30887: PPUSH
30888: CALL_OW 64
// end ;
30892: PPOPN 3
30894: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
30895: LD_INT 0
30897: PPUSH
30898: PPUSH
30899: PPUSH
30900: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
30901: LD_ADDR_VAR 0 4
30905: PUSH
30906: LD_INT 22
30908: PUSH
30909: LD_OWVAR 2
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 2
30920: PUSH
30921: LD_INT 30
30923: PUSH
30924: LD_INT 0
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 30
30933: PUSH
30934: LD_INT 1
30936: PUSH
30937: EMPTY
30938: LIST
30939: LIST
30940: PUSH
30941: EMPTY
30942: LIST
30943: LIST
30944: LIST
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PPUSH
30950: CALL_OW 69
30954: ST_TO_ADDR
// if not tmp then
30955: LD_VAR 0 4
30959: NOT
30960: IFFALSE 30964
// exit ;
30962: GO 31023
// for i in tmp do
30964: LD_ADDR_VAR 0 2
30968: PUSH
30969: LD_VAR 0 4
30973: PUSH
30974: FOR_IN
30975: IFFALSE 31021
// for j = 1 to 3 do
30977: LD_ADDR_VAR 0 3
30981: PUSH
30982: DOUBLE
30983: LD_INT 1
30985: DEC
30986: ST_TO_ADDR
30987: LD_INT 3
30989: PUSH
30990: FOR_TO
30991: IFFALSE 31017
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
30993: LD_VAR 0 2
30997: PPUSH
30998: CALL_OW 274
31002: PPUSH
31003: LD_VAR 0 3
31007: PPUSH
31008: LD_INT 99999
31010: PPUSH
31011: CALL_OW 277
31015: GO 30990
31017: POP
31018: POP
31019: GO 30974
31021: POP
31022: POP
// end ;
31023: LD_VAR 0 1
31027: RET
// export function hHackSetLevel10 ; var i , j ; begin
31028: LD_INT 0
31030: PPUSH
31031: PPUSH
31032: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
31033: LD_ADDR_VAR 0 2
31037: PUSH
31038: LD_INT 21
31040: PUSH
31041: LD_INT 1
31043: PUSH
31044: EMPTY
31045: LIST
31046: LIST
31047: PPUSH
31048: CALL_OW 69
31052: PUSH
31053: FOR_IN
31054: IFFALSE 31106
// if IsSelected ( i ) then
31056: LD_VAR 0 2
31060: PPUSH
31061: CALL_OW 306
31065: IFFALSE 31104
// begin for j := 1 to 4 do
31067: LD_ADDR_VAR 0 3
31071: PUSH
31072: DOUBLE
31073: LD_INT 1
31075: DEC
31076: ST_TO_ADDR
31077: LD_INT 4
31079: PUSH
31080: FOR_TO
31081: IFFALSE 31102
// SetSkill ( i , j , 10 ) ;
31083: LD_VAR 0 2
31087: PPUSH
31088: LD_VAR 0 3
31092: PPUSH
31093: LD_INT 10
31095: PPUSH
31096: CALL_OW 237
31100: GO 31080
31102: POP
31103: POP
// end ;
31104: GO 31053
31106: POP
31107: POP
// end ;
31108: LD_VAR 0 1
31112: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
31113: LD_INT 0
31115: PPUSH
31116: PPUSH
31117: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
31118: LD_ADDR_VAR 0 2
31122: PUSH
31123: LD_INT 22
31125: PUSH
31126: LD_OWVAR 2
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: PUSH
31135: LD_INT 21
31137: PUSH
31138: LD_INT 1
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: EMPTY
31146: LIST
31147: LIST
31148: PPUSH
31149: CALL_OW 69
31153: PUSH
31154: FOR_IN
31155: IFFALSE 31196
// begin for j := 1 to 4 do
31157: LD_ADDR_VAR 0 3
31161: PUSH
31162: DOUBLE
31163: LD_INT 1
31165: DEC
31166: ST_TO_ADDR
31167: LD_INT 4
31169: PUSH
31170: FOR_TO
31171: IFFALSE 31192
// SetSkill ( i , j , 10 ) ;
31173: LD_VAR 0 2
31177: PPUSH
31178: LD_VAR 0 3
31182: PPUSH
31183: LD_INT 10
31185: PPUSH
31186: CALL_OW 237
31190: GO 31170
31192: POP
31193: POP
// end ;
31194: GO 31154
31196: POP
31197: POP
// end ;
31198: LD_VAR 0 1
31202: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
31203: LD_INT 0
31205: PPUSH
// uc_side := your_side ;
31206: LD_ADDR_OWVAR 20
31210: PUSH
31211: LD_OWVAR 2
31215: ST_TO_ADDR
// uc_nation := nation ;
31216: LD_ADDR_OWVAR 21
31220: PUSH
31221: LD_VAR 0 1
31225: ST_TO_ADDR
// InitHc ;
31226: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
31230: LD_INT 0
31232: PPUSH
31233: LD_VAR 0 2
31237: PPUSH
31238: LD_VAR 0 3
31242: PPUSH
31243: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
31247: CALL_OW 44
31251: PPUSH
31252: LD_INT 1
31254: PPUSH
31255: CALL_OW 51
// end ;
31259: LD_VAR 0 4
31263: RET
// export function hHackSpawnVehicle ; begin
31264: LD_INT 0
31266: PPUSH
// uc_side := your_side ;
31267: LD_ADDR_OWVAR 20
31271: PUSH
31272: LD_OWVAR 2
31276: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
31277: LD_ADDR_OWVAR 21
31281: PUSH
31282: LD_INT 1
31284: PPUSH
31285: LD_INT 3
31287: PPUSH
31288: CALL_OW 12
31292: ST_TO_ADDR
// InitVc ;
31293: CALL_OW 20
// case uc_nation of 1 :
31297: LD_OWVAR 21
31301: PUSH
31302: LD_INT 1
31304: DOUBLE
31305: EQUAL
31306: IFTRUE 31310
31308: GO 31454
31310: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
31311: LD_ADDR_OWVAR 37
31315: PUSH
31316: LD_INT 1
31318: PUSH
31319: LD_INT 2
31321: PUSH
31322: LD_INT 3
31324: PUSH
31325: LD_INT 4
31327: PUSH
31328: LD_INT 5
31330: PUSH
31331: EMPTY
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 1
31340: PPUSH
31341: LD_INT 5
31343: PPUSH
31344: CALL_OW 12
31348: ARRAY
31349: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31350: LD_ADDR_OWVAR 39
31354: PUSH
31355: LD_INT 1
31357: PPUSH
31358: LD_INT 3
31360: PPUSH
31361: CALL_OW 12
31365: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
31366: LD_ADDR_OWVAR 38
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: LD_INT 3
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 1
31387: PPUSH
31388: LD_INT 3
31390: PPUSH
31391: CALL_OW 12
31395: ARRAY
31396: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
31397: LD_ADDR_OWVAR 40
31401: PUSH
31402: LD_INT 2
31404: PUSH
31405: LD_INT 4
31407: PUSH
31408: LD_INT 5
31410: PUSH
31411: LD_INT 3
31413: PUSH
31414: LD_INT 7
31416: PUSH
31417: LD_INT 8
31419: PUSH
31420: LD_INT 9
31422: PUSH
31423: LD_INT 10
31425: PUSH
31426: LD_INT 6
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 1
31442: PPUSH
31443: LD_INT 9
31445: PPUSH
31446: CALL_OW 12
31450: ARRAY
31451: ST_TO_ADDR
// end ; 2 :
31452: GO 31719
31454: LD_INT 2
31456: DOUBLE
31457: EQUAL
31458: IFTRUE 31462
31460: GO 31586
31462: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
31463: LD_ADDR_OWVAR 37
31467: PUSH
31468: LD_INT 11
31470: PUSH
31471: LD_INT 12
31473: PUSH
31474: LD_INT 13
31476: PUSH
31477: LD_INT 14
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: PUSH
31486: LD_INT 1
31488: PPUSH
31489: LD_INT 4
31491: PPUSH
31492: CALL_OW 12
31496: ARRAY
31497: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31498: LD_ADDR_OWVAR 39
31502: PUSH
31503: LD_INT 1
31505: PPUSH
31506: LD_INT 3
31508: PPUSH
31509: CALL_OW 12
31513: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
31514: LD_ADDR_OWVAR 38
31518: PUSH
31519: LD_INT 1
31521: PUSH
31522: LD_INT 2
31524: PUSH
31525: LD_INT 5
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: LIST
31532: PUSH
31533: LD_INT 1
31535: PPUSH
31536: LD_INT 3
31538: PPUSH
31539: CALL_OW 12
31543: ARRAY
31544: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
31545: LD_ADDR_OWVAR 40
31549: PUSH
31550: LD_INT 24
31552: PUSH
31553: LD_INT 26
31555: PUSH
31556: LD_INT 27
31558: PUSH
31559: LD_INT 28
31561: PUSH
31562: LD_INT 29
31564: PUSH
31565: EMPTY
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 1
31574: PPUSH
31575: LD_INT 5
31577: PPUSH
31578: CALL_OW 12
31582: ARRAY
31583: ST_TO_ADDR
// end ; 3 :
31584: GO 31719
31586: LD_INT 3
31588: DOUBLE
31589: EQUAL
31590: IFTRUE 31594
31592: GO 31718
31594: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
31595: LD_ADDR_OWVAR 37
31599: PUSH
31600: LD_INT 21
31602: PUSH
31603: LD_INT 23
31605: PUSH
31606: LD_INT 22
31608: PUSH
31609: LD_INT 24
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 1
31620: PPUSH
31621: LD_INT 4
31623: PPUSH
31624: CALL_OW 12
31628: ARRAY
31629: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31630: LD_ADDR_OWVAR 39
31634: PUSH
31635: LD_INT 1
31637: PPUSH
31638: LD_INT 3
31640: PPUSH
31641: CALL_OW 12
31645: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
31646: LD_ADDR_OWVAR 38
31650: PUSH
31651: LD_INT 1
31653: PUSH
31654: LD_INT 3
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: LD_INT 1
31663: PPUSH
31664: LD_INT 2
31666: PPUSH
31667: CALL_OW 12
31671: ARRAY
31672: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
31673: LD_ADDR_OWVAR 40
31677: PUSH
31678: LD_INT 42
31680: PUSH
31681: LD_INT 43
31683: PUSH
31684: LD_INT 44
31686: PUSH
31687: LD_INT 46
31689: PUSH
31690: LD_INT 48
31692: PUSH
31693: LD_INT 47
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: LIST
31700: LIST
31701: LIST
31702: LIST
31703: PUSH
31704: LD_INT 1
31706: PPUSH
31707: LD_INT 6
31709: PPUSH
31710: CALL_OW 12
31714: ARRAY
31715: ST_TO_ADDR
// end ; end ;
31716: GO 31719
31718: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
31719: CALL_OW 45
31723: PPUSH
31724: LD_INT 1
31726: PPUSH
31727: CALL_OW 51
// end ;
31731: LD_VAR 0 1
31735: RET
// export hInvincible ; every 1 do
31736: GO 31738
31738: DISABLE
// hInvincible := [ ] ;
31739: LD_ADDR_EXP 117
31743: PUSH
31744: EMPTY
31745: ST_TO_ADDR
31746: END
// every 10 do var i ;
31747: GO 31749
31749: DISABLE
31750: LD_INT 0
31752: PPUSH
// begin enable ;
31753: ENABLE
// if not hInvincible then
31754: LD_EXP 117
31758: NOT
31759: IFFALSE 31763
// exit ;
31761: GO 31807
// for i in hInvincible do
31763: LD_ADDR_VAR 0 1
31767: PUSH
31768: LD_EXP 117
31772: PUSH
31773: FOR_IN
31774: IFFALSE 31805
// if GetLives ( i ) < 1000 then
31776: LD_VAR 0 1
31780: PPUSH
31781: CALL_OW 256
31785: PUSH
31786: LD_INT 1000
31788: LESS
31789: IFFALSE 31803
// SetLives ( i , 1000 ) ;
31791: LD_VAR 0 1
31795: PPUSH
31796: LD_INT 1000
31798: PPUSH
31799: CALL_OW 234
31803: GO 31773
31805: POP
31806: POP
// end ;
31807: PPOPN 1
31809: END
// export function hHackInvincible ; var i ; begin
31810: LD_INT 0
31812: PPUSH
31813: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
31814: LD_ADDR_VAR 0 2
31818: PUSH
31819: LD_INT 2
31821: PUSH
31822: LD_INT 21
31824: PUSH
31825: LD_INT 1
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 21
31834: PUSH
31835: LD_INT 2
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: LIST
31846: PPUSH
31847: CALL_OW 69
31851: PUSH
31852: FOR_IN
31853: IFFALSE 31914
// if IsSelected ( i ) then
31855: LD_VAR 0 2
31859: PPUSH
31860: CALL_OW 306
31864: IFFALSE 31912
// begin if i in hInvincible then
31866: LD_VAR 0 2
31870: PUSH
31871: LD_EXP 117
31875: IN
31876: IFFALSE 31896
// hInvincible := hInvincible diff i else
31878: LD_ADDR_EXP 117
31882: PUSH
31883: LD_EXP 117
31887: PUSH
31888: LD_VAR 0 2
31892: DIFF
31893: ST_TO_ADDR
31894: GO 31912
// hInvincible := hInvincible union i ;
31896: LD_ADDR_EXP 117
31900: PUSH
31901: LD_EXP 117
31905: PUSH
31906: LD_VAR 0 2
31910: UNION
31911: ST_TO_ADDR
// end ;
31912: GO 31852
31914: POP
31915: POP
// end ;
31916: LD_VAR 0 1
31920: RET
// export function hHackInvisible ; var i , j ; begin
31921: LD_INT 0
31923: PPUSH
31924: PPUSH
31925: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
31926: LD_ADDR_VAR 0 2
31930: PUSH
31931: LD_INT 21
31933: PUSH
31934: LD_INT 1
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PPUSH
31941: CALL_OW 69
31945: PUSH
31946: FOR_IN
31947: IFFALSE 31971
// if IsSelected ( i ) then
31949: LD_VAR 0 2
31953: PPUSH
31954: CALL_OW 306
31958: IFFALSE 31969
// ComForceInvisible ( i ) ;
31960: LD_VAR 0 2
31964: PPUSH
31965: CALL_OW 496
31969: GO 31946
31971: POP
31972: POP
// end ;
31973: LD_VAR 0 1
31977: RET
// export function hHackChangeYourSide ; begin
31978: LD_INT 0
31980: PPUSH
// if your_side = 8 then
31981: LD_OWVAR 2
31985: PUSH
31986: LD_INT 8
31988: EQUAL
31989: IFFALSE 32001
// your_side := 0 else
31991: LD_ADDR_OWVAR 2
31995: PUSH
31996: LD_INT 0
31998: ST_TO_ADDR
31999: GO 32015
// your_side := your_side + 1 ;
32001: LD_ADDR_OWVAR 2
32005: PUSH
32006: LD_OWVAR 2
32010: PUSH
32011: LD_INT 1
32013: PLUS
32014: ST_TO_ADDR
// end ;
32015: LD_VAR 0 1
32019: RET
// export function hHackChangeUnitSide ; var i , j ; begin
32020: LD_INT 0
32022: PPUSH
32023: PPUSH
32024: PPUSH
// for i in all_units do
32025: LD_ADDR_VAR 0 2
32029: PUSH
32030: LD_OWVAR 3
32034: PUSH
32035: FOR_IN
32036: IFFALSE 32114
// if IsSelected ( i ) then
32038: LD_VAR 0 2
32042: PPUSH
32043: CALL_OW 306
32047: IFFALSE 32112
// begin j := GetSide ( i ) ;
32049: LD_ADDR_VAR 0 3
32053: PUSH
32054: LD_VAR 0 2
32058: PPUSH
32059: CALL_OW 255
32063: ST_TO_ADDR
// if j = 8 then
32064: LD_VAR 0 3
32068: PUSH
32069: LD_INT 8
32071: EQUAL
32072: IFFALSE 32084
// j := 0 else
32074: LD_ADDR_VAR 0 3
32078: PUSH
32079: LD_INT 0
32081: ST_TO_ADDR
32082: GO 32098
// j := j + 1 ;
32084: LD_ADDR_VAR 0 3
32088: PUSH
32089: LD_VAR 0 3
32093: PUSH
32094: LD_INT 1
32096: PLUS
32097: ST_TO_ADDR
// SetSide ( i , j ) ;
32098: LD_VAR 0 2
32102: PPUSH
32103: LD_VAR 0 3
32107: PPUSH
32108: CALL_OW 235
// end ;
32112: GO 32035
32114: POP
32115: POP
// end ;
32116: LD_VAR 0 1
32120: RET
// export function hHackFog ; begin
32121: LD_INT 0
32123: PPUSH
// FogOff ( true ) ;
32124: LD_INT 1
32126: PPUSH
32127: CALL_OW 344
// end ;
32131: LD_VAR 0 1
32135: RET
// export function hHackApeman ; begin
32136: LD_INT 0
32138: PPUSH
// uc_side := your_side ;
32139: LD_ADDR_OWVAR 20
32143: PUSH
32144: LD_OWVAR 2
32148: ST_TO_ADDR
// uc_nation := 0 ;
32149: LD_ADDR_OWVAR 21
32153: PUSH
32154: LD_INT 0
32156: ST_TO_ADDR
// hc_name :=  ;
32157: LD_ADDR_OWVAR 26
32161: PUSH
32162: LD_STRING 
32164: ST_TO_ADDR
// hc_gallery :=  ;
32165: LD_ADDR_OWVAR 33
32169: PUSH
32170: LD_STRING 
32172: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
32173: LD_ADDR_OWVAR 31
32177: PUSH
32178: LD_INT 0
32180: PUSH
32181: LD_INT 0
32183: PUSH
32184: LD_INT 0
32186: PUSH
32187: LD_INT 0
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: ST_TO_ADDR
// hc_class := class_apeman ;
32196: LD_ADDR_OWVAR 28
32200: PUSH
32201: LD_INT 12
32203: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
32204: CALL_OW 44
32208: PPUSH
32209: LD_INT 1
32211: PPUSH
32212: CALL_OW 51
// end ;
32216: LD_VAR 0 1
32220: RET
// export function hHackBoom ; begin
32221: LD_INT 0
32223: PPUSH
// uc_side := your_side ;
32224: LD_ADDR_OWVAR 20
32228: PUSH
32229: LD_OWVAR 2
32233: ST_TO_ADDR
// uc_nation := 1 ;
32234: LD_ADDR_OWVAR 21
32238: PUSH
32239: LD_INT 1
32241: ST_TO_ADDR
// vc_chassis := us_morphling ;
32242: LD_ADDR_OWVAR 37
32246: PUSH
32247: LD_INT 5
32249: ST_TO_ADDR
// vc_engine := engine_siberite ;
32250: LD_ADDR_OWVAR 39
32254: PUSH
32255: LD_INT 3
32257: ST_TO_ADDR
// vc_control := control_computer ;
32258: LD_ADDR_OWVAR 38
32262: PUSH
32263: LD_INT 3
32265: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
32266: LD_ADDR_OWVAR 40
32270: PUSH
32271: LD_INT 8
32273: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
32274: CALL_OW 45
32278: PPUSH
32279: LD_INT 1
32281: PPUSH
32282: CALL_OW 51
// end ;
32286: LD_VAR 0 1
32290: RET
