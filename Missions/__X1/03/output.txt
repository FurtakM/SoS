// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 38 0 0
// PrepareNature ;
   8: CALL 665 0 0
// PrepareArabian ;
  12: CALL 1980 0 0
// PrepareAmerican ;
  16: CALL 4932 0 0
// if debug then
  20: LD_EXP 1
  24: IFFALSE 33
// FogOff ( 2 ) ;
  26: LD_INT 2
  28: PPUSH
  29: CALL_OW 344
// Action ;
  33: CALL 9599 0 0
// end ;
  37: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , capturedCargoCounter , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , farmerHumanLoseCounter , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := false ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 0
  48: ST_TO_ADDR
// prefix := 02_ ;
  49: LD_ADDR_EXP 2
  53: PUSH
  54: LD_STRING 02_
  56: ST_TO_ADDR
// eventAttack := 1 ;
  57: LD_ADDR_EXP 22
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// deadCounter := 0 ;
  65: LD_ADDR_EXP 8
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// gameStarted := false ;
  73: LD_ADDR_EXP 3
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// farmerBaseReady := false ;
  81: LD_ADDR_EXP 4
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// americanBaseSpoted := false ;
  89: LD_ADDR_EXP 5
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// americanBaseCaptured := false ;
  97: LD_ADDR_EXP 6
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// americanHasEscaped := false ;
 105: LD_ADDR_EXP 7
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// workshopBuilded := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// retreatAllowed := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// allowConvoys := false ;
 129: LD_ADDR_EXP 11
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// farmerCrates := 0 ;
 137: LD_ADDR_EXP 13
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 145: LD_ADDR_EXP 14
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 153: LD_ADDR_EXP 15
 157: PUSH
 158: LD_INT 63000
 160: PUSH
 161: LD_INT 52500
 163: PUSH
 164: LD_INT 46200
 166: PUSH
 167: EMPTY
 168: LIST
 169: LIST
 170: LIST
 171: PUSH
 172: LD_OWVAR 67
 176: ARRAY
 177: ST_TO_ADDR
// farmerHumanLoseCounter := 0 ;
 178: LD_ADDR_EXP 18
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 186: LD_ADDR_EXP 16
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// attackWave := 1 ;
 194: LD_ADDR_EXP 17
 198: PUSH
 199: LD_INT 1
 201: ST_TO_ADDR
// omarCargoCounter := [ 6 , 8 , 10 ] [ Difficulty ] ;
 202: LD_ADDR_EXP 19
 206: PUSH
 207: LD_INT 6
 209: PUSH
 210: LD_INT 8
 212: PUSH
 213: LD_INT 10
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: PUSH
 221: LD_OWVAR 67
 225: ARRAY
 226: ST_TO_ADDR
// vehCounter := 0 ;
 227: LD_ADDR_EXP 20
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// convoyCounter := 0 ;
 235: LD_ADDR_EXP 21
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// ibrahimInDepot := false ;
 243: LD_ADDR_EXP 23
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// ibrahimIsFree := false ;
 251: LD_ADDR_EXP 24
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// maxConvoys := [ 16 , 15 , 14 ] [ Difficulty ] ;
 259: LD_ADDR_EXP 25
 263: PUSH
 264: LD_INT 16
 266: PUSH
 267: LD_INT 15
 269: PUSH
 270: LD_INT 14
 272: PUSH
 273: EMPTY
 274: LIST
 275: LIST
 276: LIST
 277: PUSH
 278: LD_OWVAR 67
 282: ARRAY
 283: ST_TO_ADDR
// capturedCargoCounter := 0 ;
 284: LD_ADDR_EXP 12
 288: PUSH
 289: LD_INT 0
 291: ST_TO_ADDR
// end ; end_of_file
 292: LD_VAR 0 1
 296: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 297: LD_INT 0
 299: PPUSH
 300: PPUSH
// if exist_mode then
 301: LD_VAR 0 2
 305: IFFALSE 330
// unit := CreateCharacter ( prefix & ident ) else
 307: LD_ADDR_VAR 0 5
 311: PUSH
 312: LD_VAR 0 3
 316: PUSH
 317: LD_VAR 0 1
 321: STR
 322: PPUSH
 323: CALL_OW 34
 327: ST_TO_ADDR
 328: GO 345
// unit := NewCharacter ( ident ) ;
 330: LD_ADDR_VAR 0 5
 334: PUSH
 335: LD_VAR 0 1
 339: PPUSH
 340: CALL_OW 25
 344: ST_TO_ADDR
// result := unit ;
 345: LD_ADDR_VAR 0 4
 349: PUSH
 350: LD_VAR 0 5
 354: ST_TO_ADDR
// end ;
 355: LD_VAR 0 4
 359: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 360: LD_INT 0
 362: PPUSH
// uc_side := side ;
 363: LD_ADDR_OWVAR 20
 367: PUSH
 368: LD_VAR 0 1
 372: ST_TO_ADDR
// uc_nation := nation ;
 373: LD_ADDR_OWVAR 21
 377: PUSH
 378: LD_VAR 0 2
 382: ST_TO_ADDR
// vc_chassis := chassis ;
 383: LD_ADDR_OWVAR 37
 387: PUSH
 388: LD_VAR 0 3
 392: ST_TO_ADDR
// vc_engine := engine ;
 393: LD_ADDR_OWVAR 39
 397: PUSH
 398: LD_VAR 0 4
 402: ST_TO_ADDR
// vc_control := control ;
 403: LD_ADDR_OWVAR 38
 407: PUSH
 408: LD_VAR 0 5
 412: ST_TO_ADDR
// vc_weapon := weapon ;
 413: LD_ADDR_OWVAR 40
 417: PUSH
 418: LD_VAR 0 6
 422: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 423: LD_ADDR_OWVAR 41
 427: PUSH
 428: LD_VAR 0 7
 432: ST_TO_ADDR
// result := CreateVehicle ;
 433: LD_ADDR_VAR 0 8
 437: PUSH
 438: CALL_OW 45
 442: ST_TO_ADDR
// end ;
 443: LD_VAR 0 8
 447: RET
// export function SayX ( units , ident ) ; var i ; begin
 448: LD_INT 0
 450: PPUSH
 451: PPUSH
// result := false ;
 452: LD_ADDR_VAR 0 3
 456: PUSH
 457: LD_INT 0
 459: ST_TO_ADDR
// if not units then
 460: LD_VAR 0 1
 464: NOT
 465: IFFALSE 469
// exit ;
 467: GO 523
// for i in units do
 469: LD_ADDR_VAR 0 4
 473: PUSH
 474: LD_VAR 0 1
 478: PUSH
 479: FOR_IN
 480: IFFALSE 521
// if IsOk ( i ) then
 482: LD_VAR 0 4
 486: PPUSH
 487: CALL_OW 302
 491: IFFALSE 519
// begin Say ( i , ident ) ;
 493: LD_VAR 0 4
 497: PPUSH
 498: LD_VAR 0 2
 502: PPUSH
 503: CALL_OW 88
// result := i ;
 507: LD_ADDR_VAR 0 3
 511: PUSH
 512: LD_VAR 0 4
 516: ST_TO_ADDR
// break ;
 517: GO 521
// end ;
 519: GO 479
 521: POP
 522: POP
// end ;
 523: LD_VAR 0 3
 527: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 528: LD_INT 0
 530: PPUSH
 531: PPUSH
// InitUc ;
 532: CALL_OW 18
// InitHc ;
 536: CALL_OW 19
// uc_side := 0 ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_INT 0
 547: ST_TO_ADDR
// uc_nation := 0 ;
 548: LD_ADDR_OWVAR 21
 552: PUSH
 553: LD_INT 0
 555: ST_TO_ADDR
// for i = 1 to amount do
 556: LD_ADDR_VAR 0 4
 560: PUSH
 561: DOUBLE
 562: LD_INT 1
 564: DEC
 565: ST_TO_ADDR
 566: LD_VAR 0 2
 570: PUSH
 571: FOR_TO
 572: IFFALSE 654
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 574: LD_ADDR_OWVAR 29
 578: PUSH
 579: LD_INT 9
 581: PPUSH
 582: LD_INT 12
 584: PPUSH
 585: CALL_OW 12
 589: PUSH
 590: LD_INT 9
 592: PPUSH
 593: LD_INT 12
 595: PPUSH
 596: CALL_OW 12
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 605: LD_ADDR_OWVAR 35
 609: PUSH
 610: LD_INT 1
 612: NEG
 613: PPUSH
 614: LD_INT 1
 616: PPUSH
 617: CALL_OW 12
 621: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 622: LD_INT 0
 624: PPUSH
 625: LD_INT 12
 627: PPUSH
 628: LD_INT 1
 630: PPUSH
 631: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 635: CALL_OW 44
 639: PPUSH
 640: LD_VAR 0 1
 644: PPUSH
 645: LD_INT 0
 647: PPUSH
 648: CALL_OW 49
// end ;
 652: GO 571
 654: POP
 655: POP
// InitHc ;
 656: CALL_OW 19
// end ;
 660: LD_VAR 0 3
 664: RET
// export function PrepareNature ; var i ; begin
 665: LD_INT 0
 667: PPUSH
 668: PPUSH
// SpawnApeman ( forest , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PUSH
 675: LD_INT 4
 677: PUSH
 678: LD_INT 4
 680: PUSH
 681: EMPTY
 682: LIST
 683: LIST
 684: LIST
 685: PUSH
 686: LD_OWVAR 67
 690: ARRAY
 691: PPUSH
 692: CALL 528 0 2
// for i := 1 to 2 do
 696: LD_ADDR_VAR 0 2
 700: PUSH
 701: DOUBLE
 702: LD_INT 1
 704: DEC
 705: ST_TO_ADDR
 706: LD_INT 2
 708: PUSH
 709: FOR_TO
 710: IFFALSE 745
// begin hc_class := 21 ;
 712: LD_ADDR_OWVAR 28
 716: PUSH
 717: LD_INT 21
 719: ST_TO_ADDR
// hc_gallery :=  ;
 720: LD_ADDR_OWVAR 33
 724: PUSH
 725: LD_STRING 
 727: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 728: CALL_OW 44
 732: PPUSH
 733: LD_INT 2
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 49
// end ;
 743: GO 709
 745: POP
 746: POP
// for i := 1 to 2 do
 747: LD_ADDR_VAR 0 2
 751: PUSH
 752: DOUBLE
 753: LD_INT 1
 755: DEC
 756: ST_TO_ADDR
 757: LD_INT 2
 759: PUSH
 760: FOR_TO
 761: IFFALSE 796
// begin hc_class := 18 ;
 763: LD_ADDR_OWVAR 28
 767: PUSH
 768: LD_INT 18
 770: ST_TO_ADDR
// hc_gallery :=  ;
 771: LD_ADDR_OWVAR 33
 775: PUSH
 776: LD_STRING 
 778: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 779: CALL_OW 44
 783: PPUSH
 784: LD_INT 2
 786: PPUSH
 787: LD_INT 0
 789: PPUSH
 790: CALL_OW 49
// end ;
 794: GO 760
 796: POP
 797: POP
// for i := 1 to 2 do
 798: LD_ADDR_VAR 0 2
 802: PUSH
 803: DOUBLE
 804: LD_INT 1
 806: DEC
 807: ST_TO_ADDR
 808: LD_INT 2
 810: PUSH
 811: FOR_TO
 812: IFFALSE 847
// begin hc_class := 13 ;
 814: LD_ADDR_OWVAR 28
 818: PUSH
 819: LD_INT 13
 821: ST_TO_ADDR
// hc_gallery :=  ;
 822: LD_ADDR_OWVAR 33
 826: PUSH
 827: LD_STRING 
 829: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 830: CALL_OW 44
 834: PPUSH
 835: LD_INT 2
 837: PPUSH
 838: LD_INT 0
 840: PPUSH
 841: CALL_OW 49
// end ;
 845: GO 811
 847: POP
 848: POP
// end ;
 849: LD_VAR 0 1
 853: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 854: LD_INT 0
 856: PPUSH
 857: PPUSH
 858: PPUSH
// if not observer or not unit then
 859: LD_VAR 0 1
 863: NOT
 864: PUSH
 865: LD_VAR 0 2
 869: NOT
 870: OR
 871: IFFALSE 875
// exit ;
 873: GO 923
// if not See ( GetSide ( observer ) , unit ) then
 875: LD_VAR 0 1
 879: PPUSH
 880: CALL_OW 255
 884: PPUSH
 885: LD_VAR 0 2
 889: PPUSH
 890: CALL_OW 292
 894: NOT
 895: IFFALSE 899
// exit ;
 897: GO 923
// result := GetDistUnits ( observer , unit ) < 12 ;
 899: LD_ADDR_VAR 0 3
 903: PUSH
 904: LD_VAR 0 1
 908: PPUSH
 909: LD_VAR 0 2
 913: PPUSH
 914: CALL_OW 296
 918: PUSH
 919: LD_INT 12
 921: LESS
 922: ST_TO_ADDR
// end ;
 923: LD_VAR 0 3
 927: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 928: LD_INT 0
 930: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 931: LD_VAR 0 2
 935: PUSH
 936: LD_INT 1
 938: ARRAY
 939: PPUSH
 940: LD_VAR 0 2
 944: PUSH
 945: LD_INT 2
 947: ARRAY
 948: PPUSH
 949: CALL_OW 488
 953: PUSH
 954: LD_VAR 0 2
 958: PUSH
 959: LD_INT 1
 961: ARRAY
 962: PPUSH
 963: LD_VAR 0 2
 967: PUSH
 968: LD_INT 2
 970: ARRAY
 971: PPUSH
 972: CALL_OW 428
 976: PUSH
 977: LD_INT 0
 979: EQUAL
 980: AND
 981: IFFALSE 1015
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 983: LD_VAR 0 1
 987: PPUSH
 988: LD_VAR 0 2
 992: PUSH
 993: LD_INT 1
 995: ARRAY
 996: PPUSH
 997: LD_VAR 0 2
1001: PUSH
1002: LD_INT 2
1004: ARRAY
1005: PPUSH
1006: LD_VAR 0 3
1010: PPUSH
1011: CALL_OW 48
// end ;
1015: LD_VAR 0 4
1019: RET
// export function Video ( mode ) ; begin
1020: LD_INT 0
1022: PPUSH
// ingame_video = mode ;
1023: LD_ADDR_OWVAR 52
1027: PUSH
1028: LD_VAR 0 1
1032: ST_TO_ADDR
// interface_hidden = mode ;
1033: LD_ADDR_OWVAR 54
1037: PUSH
1038: LD_VAR 0 1
1042: ST_TO_ADDR
// end ;
1043: LD_VAR 0 2
1047: RET
// export function ReverseArray ( array ) ; var i ; begin
1048: LD_INT 0
1050: PPUSH
1051: PPUSH
// if not array then
1052: LD_VAR 0 1
1056: NOT
1057: IFFALSE 1061
// exit ;
1059: GO 1119
// result := [ ] ;
1061: LD_ADDR_VAR 0 2
1065: PUSH
1066: EMPTY
1067: ST_TO_ADDR
// for i := 1 to array do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: DOUBLE
1074: LD_INT 1
1076: DEC
1077: ST_TO_ADDR
1078: LD_VAR 0 1
1082: PUSH
1083: FOR_TO
1084: IFFALSE 1117
// result := Insert ( result , 1 , array [ i ] ) ;
1086: LD_ADDR_VAR 0 2
1090: PUSH
1091: LD_VAR 0 2
1095: PPUSH
1096: LD_INT 1
1098: PPUSH
1099: LD_VAR 0 1
1103: PUSH
1104: LD_VAR 0 3
1108: ARRAY
1109: PPUSH
1110: CALL_OW 2
1114: ST_TO_ADDR
1115: GO 1083
1117: POP
1118: POP
// end ;
1119: LD_VAR 0 2
1123: RET
// export function ComExit ( unit ) ; begin
1124: LD_INT 0
1126: PPUSH
// result := IsInUnit ( unit ) ;
1127: LD_ADDR_VAR 0 2
1131: PUSH
1132: LD_VAR 0 1
1136: PPUSH
1137: CALL_OW 310
1141: ST_TO_ADDR
// if not result then
1142: LD_VAR 0 2
1146: NOT
1147: IFFALSE 1151
// exit ;
1149: GO 1186
// if GetType ( result ) = unit_vehicle then
1151: LD_VAR 0 2
1155: PPUSH
1156: CALL_OW 247
1160: PUSH
1161: LD_INT 2
1163: EQUAL
1164: IFFALSE 1177
// ComExitVehicle ( unit ) else
1166: LD_VAR 0 1
1170: PPUSH
1171: CALL_OW 121
1175: GO 1186
// ComExitBuilding ( unit ) ;
1177: LD_VAR 0 1
1181: PPUSH
1182: CALL_OW 122
// end ;
1186: LD_VAR 0 2
1190: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1191: LD_INT 0
1193: PPUSH
1194: PPUSH
// if not side or not nation then
1195: LD_VAR 0 1
1199: NOT
1200: PUSH
1201: LD_VAR 0 2
1205: NOT
1206: OR
1207: IFFALSE 1211
// exit ;
1209: GO 1975
// case nation of nation_american :
1211: LD_VAR 0 2
1215: PUSH
1216: LD_INT 1
1218: DOUBLE
1219: EQUAL
1220: IFTRUE 1224
1222: GO 1438
1224: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1225: LD_ADDR_VAR 0 4
1229: PUSH
1230: LD_INT 35
1232: PUSH
1233: LD_INT 45
1235: PUSH
1236: LD_INT 46
1238: PUSH
1239: LD_INT 47
1241: PUSH
1242: LD_INT 82
1244: PUSH
1245: LD_INT 83
1247: PUSH
1248: LD_INT 84
1250: PUSH
1251: LD_INT 85
1253: PUSH
1254: LD_INT 86
1256: PUSH
1257: LD_INT 1
1259: PUSH
1260: LD_INT 2
1262: PUSH
1263: LD_INT 6
1265: PUSH
1266: LD_INT 15
1268: PUSH
1269: LD_INT 16
1271: PUSH
1272: LD_INT 7
1274: PUSH
1275: LD_INT 12
1277: PUSH
1278: LD_INT 13
1280: PUSH
1281: LD_INT 10
1283: PUSH
1284: LD_INT 14
1286: PUSH
1287: LD_INT 20
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 22
1295: PUSH
1296: LD_INT 25
1298: PUSH
1299: LD_INT 32
1301: PUSH
1302: LD_INT 27
1304: PUSH
1305: LD_INT 36
1307: PUSH
1308: LD_INT 69
1310: PUSH
1311: LD_INT 39
1313: PUSH
1314: LD_INT 34
1316: PUSH
1317: LD_INT 40
1319: PUSH
1320: LD_INT 48
1322: PUSH
1323: LD_INT 49
1325: PUSH
1326: LD_INT 50
1328: PUSH
1329: LD_INT 51
1331: PUSH
1332: LD_INT 52
1334: PUSH
1335: LD_INT 53
1337: PUSH
1338: LD_INT 54
1340: PUSH
1341: LD_INT 55
1343: PUSH
1344: LD_INT 56
1346: PUSH
1347: LD_INT 57
1349: PUSH
1350: LD_INT 58
1352: PUSH
1353: LD_INT 59
1355: PUSH
1356: LD_INT 60
1358: PUSH
1359: LD_INT 61
1361: PUSH
1362: LD_INT 62
1364: PUSH
1365: LD_INT 80
1367: PUSH
1368: LD_INT 82
1370: PUSH
1371: LD_INT 83
1373: PUSH
1374: LD_INT 84
1376: PUSH
1377: LD_INT 85
1379: PUSH
1380: LD_INT 86
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: ST_TO_ADDR
1436: GO 1899
1438: LD_INT 2
1440: DOUBLE
1441: EQUAL
1442: IFTRUE 1446
1444: GO 1668
1446: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1447: LD_ADDR_VAR 0 4
1451: PUSH
1452: LD_INT 35
1454: PUSH
1455: LD_INT 45
1457: PUSH
1458: LD_INT 46
1460: PUSH
1461: LD_INT 47
1463: PUSH
1464: LD_INT 82
1466: PUSH
1467: LD_INT 83
1469: PUSH
1470: LD_INT 84
1472: PUSH
1473: LD_INT 85
1475: PUSH
1476: LD_INT 87
1478: PUSH
1479: LD_INT 70
1481: PUSH
1482: LD_INT 1
1484: PUSH
1485: LD_INT 11
1487: PUSH
1488: LD_INT 3
1490: PUSH
1491: LD_INT 4
1493: PUSH
1494: LD_INT 5
1496: PUSH
1497: LD_INT 6
1499: PUSH
1500: LD_INT 15
1502: PUSH
1503: LD_INT 18
1505: PUSH
1506: LD_INT 7
1508: PUSH
1509: LD_INT 17
1511: PUSH
1512: LD_INT 8
1514: PUSH
1515: LD_INT 20
1517: PUSH
1518: LD_INT 21
1520: PUSH
1521: LD_INT 22
1523: PUSH
1524: LD_INT 72
1526: PUSH
1527: LD_INT 26
1529: PUSH
1530: LD_INT 69
1532: PUSH
1533: LD_INT 39
1535: PUSH
1536: LD_INT 40
1538: PUSH
1539: LD_INT 41
1541: PUSH
1542: LD_INT 42
1544: PUSH
1545: LD_INT 43
1547: PUSH
1548: LD_INT 48
1550: PUSH
1551: LD_INT 49
1553: PUSH
1554: LD_INT 50
1556: PUSH
1557: LD_INT 51
1559: PUSH
1560: LD_INT 52
1562: PUSH
1563: LD_INT 53
1565: PUSH
1566: LD_INT 54
1568: PUSH
1569: LD_INT 55
1571: PUSH
1572: LD_INT 56
1574: PUSH
1575: LD_INT 60
1577: PUSH
1578: LD_INT 61
1580: PUSH
1581: LD_INT 62
1583: PUSH
1584: LD_INT 66
1586: PUSH
1587: LD_INT 67
1589: PUSH
1590: LD_INT 68
1592: PUSH
1593: LD_INT 81
1595: PUSH
1596: LD_INT 82
1598: PUSH
1599: LD_INT 83
1601: PUSH
1602: LD_INT 84
1604: PUSH
1605: LD_INT 85
1607: PUSH
1608: LD_INT 87
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: LIST
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: ST_TO_ADDR
1666: GO 1899
1668: LD_INT 3
1670: DOUBLE
1671: EQUAL
1672: IFTRUE 1676
1674: GO 1898
1676: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1677: LD_ADDR_VAR 0 4
1681: PUSH
1682: LD_INT 46
1684: PUSH
1685: LD_INT 47
1687: PUSH
1688: LD_INT 1
1690: PUSH
1691: LD_INT 2
1693: PUSH
1694: LD_INT 82
1696: PUSH
1697: LD_INT 83
1699: PUSH
1700: LD_INT 84
1702: PUSH
1703: LD_INT 85
1705: PUSH
1706: LD_INT 86
1708: PUSH
1709: LD_INT 11
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 20
1717: PUSH
1718: LD_INT 19
1720: PUSH
1721: LD_INT 21
1723: PUSH
1724: LD_INT 24
1726: PUSH
1727: LD_INT 22
1729: PUSH
1730: LD_INT 25
1732: PUSH
1733: LD_INT 28
1735: PUSH
1736: LD_INT 29
1738: PUSH
1739: LD_INT 30
1741: PUSH
1742: LD_INT 31
1744: PUSH
1745: LD_INT 37
1747: PUSH
1748: LD_INT 38
1750: PUSH
1751: LD_INT 32
1753: PUSH
1754: LD_INT 27
1756: PUSH
1757: LD_INT 33
1759: PUSH
1760: LD_INT 69
1762: PUSH
1763: LD_INT 39
1765: PUSH
1766: LD_INT 34
1768: PUSH
1769: LD_INT 40
1771: PUSH
1772: LD_INT 71
1774: PUSH
1775: LD_INT 23
1777: PUSH
1778: LD_INT 44
1780: PUSH
1781: LD_INT 48
1783: PUSH
1784: LD_INT 49
1786: PUSH
1787: LD_INT 50
1789: PUSH
1790: LD_INT 51
1792: PUSH
1793: LD_INT 52
1795: PUSH
1796: LD_INT 53
1798: PUSH
1799: LD_INT 54
1801: PUSH
1802: LD_INT 55
1804: PUSH
1805: LD_INT 56
1807: PUSH
1808: LD_INT 57
1810: PUSH
1811: LD_INT 58
1813: PUSH
1814: LD_INT 59
1816: PUSH
1817: LD_INT 63
1819: PUSH
1820: LD_INT 64
1822: PUSH
1823: LD_INT 65
1825: PUSH
1826: LD_INT 82
1828: PUSH
1829: LD_INT 83
1831: PUSH
1832: LD_INT 84
1834: PUSH
1835: LD_INT 85
1837: PUSH
1838: LD_INT 86
1840: PUSH
1841: EMPTY
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: ST_TO_ADDR
1896: GO 1899
1898: POP
// if state > - 1 and state < 3 then
1899: LD_VAR 0 3
1903: PUSH
1904: LD_INT 1
1906: NEG
1907: GREATER
1908: PUSH
1909: LD_VAR 0 3
1913: PUSH
1914: LD_INT 3
1916: LESS
1917: AND
1918: IFFALSE 1975
// for i in result do
1920: LD_ADDR_VAR 0 5
1924: PUSH
1925: LD_VAR 0 4
1929: PUSH
1930: FOR_IN
1931: IFFALSE 1973
// if GetTech ( i , side ) <> state then
1933: LD_VAR 0 5
1937: PPUSH
1938: LD_VAR 0 1
1942: PPUSH
1943: CALL_OW 321
1947: PUSH
1948: LD_VAR 0 3
1952: NONEQUAL
1953: IFFALSE 1971
// result := result diff i ;
1955: LD_ADDR_VAR 0 4
1959: PUSH
1960: LD_VAR 0 4
1964: PUSH
1965: LD_VAR 0 5
1969: DIFF
1970: ST_TO_ADDR
1971: GO 1930
1973: POP
1974: POP
// end ; end_of_file
1975: LD_VAR 0 4
1979: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1980: LD_INT 0
1982: PPUSH
1983: PPUSH
1984: PPUSH
1985: PPUSH
// uc_side := 5 ;
1986: LD_ADDR_OWVAR 20
1990: PUSH
1991: LD_INT 5
1993: ST_TO_ADDR
// uc_nation := 2 ;
1994: LD_ADDR_OWVAR 21
1998: PUSH
1999: LD_INT 2
2001: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
2002: LD_INT 5
2004: PPUSH
2005: CALL_OW 274
2009: PPUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 45
2015: PPUSH
2016: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
2020: LD_ADDR_EXP 34
2024: PUSH
2025: LD_STRING Farmer
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: LD_STRING 
2033: PPUSH
2034: CALL 297 0 3
2038: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2039: LD_ADDR_EXP 35
2043: PUSH
2044: LD_STRING Omar
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: LD_STRING 
2052: PPUSH
2053: CALL 297 0 3
2057: ST_TO_ADDR
// omarSquad := [ ] ;
2058: LD_ADDR_EXP 38
2062: PUSH
2063: EMPTY
2064: ST_TO_ADDR
// heikeSquad := [ ] ;
2065: LD_ADDR_EXP 39
2069: PUSH
2070: EMPTY
2071: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2072: LD_ADDR_EXP 40
2076: PUSH
2077: EMPTY
2078: ST_TO_ADDR
// omarCargo := [ ] ;
2079: LD_ADDR_EXP 41
2083: PUSH
2084: EMPTY
2085: ST_TO_ADDR
// for i := 1 to 5 do
2086: LD_ADDR_VAR 0 2
2090: PUSH
2091: DOUBLE
2092: LD_INT 1
2094: DEC
2095: ST_TO_ADDR
2096: LD_INT 5
2098: PUSH
2099: FOR_TO
2100: IFFALSE 2258
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2102: LD_INT 0
2104: PPUSH
2105: LD_INT 1
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 1
2116: PUSH
2117: LD_INT 1
2119: PUSH
2120: EMPTY
2121: LIST
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: PUSH
2127: LD_VAR 0 2
2131: ARRAY
2132: PPUSH
2133: LD_INT 3
2135: PPUSH
2136: CALL_OW 380
// un := CreateHuman ;
2140: LD_ADDR_VAR 0 3
2144: PUSH
2145: CALL_OW 44
2149: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2150: LD_ADDR_EXP 38
2154: PUSH
2155: LD_EXP 38
2159: PUSH
2160: LD_VAR 0 3
2164: UNION
2165: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2166: LD_VAR 0 3
2170: PPUSH
2171: LD_INT 87
2173: PUSH
2174: LD_INT 30
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: PUSH
2181: LD_INT 91
2183: PUSH
2184: LD_INT 32
2186: PUSH
2187: EMPTY
2188: LIST
2189: LIST
2190: PUSH
2191: LD_INT 82
2193: PUSH
2194: LD_INT 15
2196: PUSH
2197: EMPTY
2198: LIST
2199: LIST
2200: PUSH
2201: LD_INT 79
2203: PUSH
2204: LD_INT 14
2206: PUSH
2207: EMPTY
2208: LIST
2209: LIST
2210: PUSH
2211: LD_INT 82
2213: PUSH
2214: LD_INT 13
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: LIST
2225: LIST
2226: LIST
2227: PUSH
2228: LD_VAR 0 2
2232: ARRAY
2233: PPUSH
2234: LD_INT 0
2236: PPUSH
2237: CALL 928 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2241: LD_VAR 0 3
2245: PPUSH
2246: LD_INT 93
2248: PPUSH
2249: LD_INT 21
2251: PPUSH
2252: CALL_OW 118
// end ;
2256: GO 2099
2258: POP
2259: POP
// uc_side := 2 ;
2260: LD_ADDR_OWVAR 20
2264: PUSH
2265: LD_INT 2
2267: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2268: LD_ADDR_EXP 26
2272: PUSH
2273: LD_STRING Heike
2275: PPUSH
2276: LD_EXP 1
2280: NOT
2281: PPUSH
2282: LD_EXP 2
2286: PPUSH
2287: CALL 297 0 3
2291: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2292: LD_ADDR_EXP 30
2296: PUSH
2297: LD_STRING Aviradze
2299: PPUSH
2300: LD_EXP 1
2304: NOT
2305: PPUSH
2306: LD_EXP 2
2310: PPUSH
2311: CALL 297 0 3
2315: ST_TO_ADDR
// tmp := [ ] ;
2316: LD_ADDR_VAR 0 4
2320: PUSH
2321: EMPTY
2322: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2323: LD_ADDR_EXP 27
2327: PUSH
2328: LD_STRING Givi
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_EXP 2
2341: PPUSH
2342: CALL 297 0 3
2346: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2347: LD_ADDR_EXP 28
2351: PUSH
2352: LD_STRING Mike
2354: PPUSH
2355: LD_EXP 1
2359: NOT
2360: PPUSH
2361: LD_EXP 2
2365: PPUSH
2366: CALL 297 0 3
2370: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2371: LD_ADDR_EXP 29
2375: PUSH
2376: LD_STRING Kamil
2378: PPUSH
2379: LD_EXP 1
2383: NOT
2384: PPUSH
2385: LD_EXP 2
2389: PPUSH
2390: CALL 297 0 3
2394: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2395: LD_ADDR_EXP 31
2399: PUSH
2400: LD_STRING Kaia
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_EXP 2
2413: PPUSH
2414: CALL 297 0 3
2418: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2419: LD_ADDR_EXP 32
2423: PUSH
2424: LD_STRING Sophia
2426: PPUSH
2427: LD_EXP 1
2431: NOT
2432: PPUSH
2433: LD_EXP 2
2437: PPUSH
2438: CALL 297 0 3
2442: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2443: LD_ADDR_EXP 33
2447: PUSH
2448: LD_STRING Markov
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_EXP 2
2461: PPUSH
2462: CALL 297 0 3
2466: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2467: LD_ADDR_EXP 40
2471: PUSH
2472: LD_STRING 02_others
2474: PPUSH
2475: CALL_OW 31
2479: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2480: LD_ADDR_VAR 0 4
2484: PUSH
2485: LD_EXP 28
2489: PUSH
2490: LD_EXP 29
2494: PUSH
2495: LD_EXP 31
2499: PUSH
2500: LD_EXP 32
2504: PUSH
2505: LD_EXP 33
2509: PUSH
2510: LD_EXP 27
2514: PUSH
2515: EMPTY
2516: LIST
2517: LIST
2518: LIST
2519: LIST
2520: LIST
2521: LIST
2522: PUSH
2523: LD_EXP 40
2527: ADD
2528: PUSH
2529: LD_INT 0
2531: DIFF
2532: ST_TO_ADDR
// heikeSquad := tmp ;
2533: LD_ADDR_EXP 39
2537: PUSH
2538: LD_VAR 0 4
2542: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 02_ape ) ;
2543: LD_ADDR_VAR 0 4
2547: PUSH
2548: LD_VAR 0 4
2552: PUSH
2553: LD_STRING 02_ape
2555: PPUSH
2556: CALL_OW 31
2560: UNION
2561: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2562: LD_EXP 26
2566: PPUSH
2567: LD_INT 92
2569: PPUSH
2570: LD_INT 17
2572: PPUSH
2573: LD_INT 0
2575: PPUSH
2576: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2580: LD_EXP 34
2584: PPUSH
2585: LD_INT 95
2587: PPUSH
2588: LD_INT 19
2590: PPUSH
2591: LD_INT 0
2593: PPUSH
2594: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2598: LD_EXP 35
2602: PPUSH
2603: LD_INT 89
2605: PPUSH
2606: LD_INT 25
2608: PPUSH
2609: LD_INT 0
2611: PPUSH
2612: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2616: LD_EXP 30
2620: PPUSH
2621: LD_INT 92
2623: PPUSH
2624: LD_INT 27
2626: PPUSH
2627: LD_INT 0
2629: PPUSH
2630: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2634: LD_EXP 35
2638: PPUSH
2639: LD_EXP 30
2643: PPUSH
2644: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2648: LD_EXP 30
2652: PPUSH
2653: LD_EXP 35
2657: PPUSH
2658: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2662: LD_EXP 26
2666: PUSH
2667: LD_EXP 34
2671: PUSH
2672: EMPTY
2673: LIST
2674: LIST
2675: PPUSH
2676: LD_EXP 35
2680: PPUSH
2681: CALL_OW 119
// if tmp then
2685: LD_VAR 0 4
2689: IFFALSE 2743
// for i in tmp do
2691: LD_ADDR_VAR 0 2
2695: PUSH
2696: LD_VAR 0 4
2700: PUSH
2701: FOR_IN
2702: IFFALSE 2741
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2704: LD_VAR 0 2
2708: PPUSH
2709: LD_INT 94
2711: PPUSH
2712: LD_INT 14
2714: PPUSH
2715: LD_INT 4
2717: PPUSH
2718: LD_INT 0
2720: PPUSH
2721: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2725: LD_VAR 0 2
2729: PPUSH
2730: LD_EXP 26
2734: PPUSH
2735: CALL_OW 119
// end ;
2739: GO 2701
2741: POP
2742: POP
// farmerSquad := [ ] ;
2743: LD_ADDR_EXP 37
2747: PUSH
2748: EMPTY
2749: ST_TO_ADDR
// uc_side := 5 ;
2750: LD_ADDR_OWVAR 20
2754: PUSH
2755: LD_INT 5
2757: ST_TO_ADDR
// uc_nation := 2 ;
2758: LD_ADDR_OWVAR 21
2762: PUSH
2763: LD_INT 2
2765: ST_TO_ADDR
// for i := 1 to 4 do
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: DOUBLE
2772: LD_INT 1
2774: DEC
2775: ST_TO_ADDR
2776: LD_INT 4
2778: PUSH
2779: FOR_TO
2780: IFFALSE 2858
// begin PrepareHuman ( false , 1 , 2 ) ;
2782: LD_INT 0
2784: PPUSH
2785: LD_INT 1
2787: PPUSH
2788: LD_INT 2
2790: PPUSH
2791: CALL_OW 380
// un := CreateHuman ;
2795: LD_ADDR_VAR 0 3
2799: PUSH
2800: CALL_OW 44
2804: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2805: LD_VAR 0 3
2809: PPUSH
2810: LD_INT 102
2812: PPUSH
2813: LD_INT 27
2815: PPUSH
2816: LD_INT 4
2818: PPUSH
2819: LD_INT 0
2821: PPUSH
2822: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2826: LD_ADDR_EXP 37
2830: PUSH
2831: LD_EXP 37
2835: PUSH
2836: LD_VAR 0 3
2840: UNION
2841: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2842: LD_VAR 0 3
2846: PPUSH
2847: LD_EXP 35
2851: PPUSH
2852: CALL_OW 119
// end ;
2856: GO 2779
2858: POP
2859: POP
// for i := 1 to 2 do
2860: LD_ADDR_VAR 0 2
2864: PUSH
2865: DOUBLE
2866: LD_INT 1
2868: DEC
2869: ST_TO_ADDR
2870: LD_INT 2
2872: PUSH
2873: FOR_TO
2874: IFFALSE 2952
// begin PrepareHuman ( false , 2 , 2 ) ;
2876: LD_INT 0
2878: PPUSH
2879: LD_INT 2
2881: PPUSH
2882: LD_INT 2
2884: PPUSH
2885: CALL_OW 380
// un := CreateHuman ;
2889: LD_ADDR_VAR 0 3
2893: PUSH
2894: CALL_OW 44
2898: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2899: LD_VAR 0 3
2903: PPUSH
2904: LD_INT 108
2906: PPUSH
2907: LD_INT 62
2909: PPUSH
2910: LD_INT 2
2912: PPUSH
2913: LD_INT 0
2915: PPUSH
2916: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2920: LD_ADDR_EXP 37
2924: PUSH
2925: LD_EXP 37
2929: PUSH
2930: LD_VAR 0 3
2934: UNION
2935: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2936: LD_VAR 0 3
2940: PPUSH
2941: LD_EXP 35
2945: PPUSH
2946: CALL_OW 119
// end ;
2950: GO 2873
2952: POP
2953: POP
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
2954: LD_INT 109
2956: PPUSH
2957: LD_INT 63
2959: PPUSH
2960: LD_INT 2
2962: PPUSH
2963: LD_INT 15
2965: NEG
2966: PPUSH
2967: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
2971: LD_INT 109
2973: PPUSH
2974: LD_INT 63
2976: PPUSH
2977: LD_INT 2
2979: PPUSH
2980: CALL_OW 331
// end ;
2984: LD_VAR 0 1
2988: RET
// export function PrepareIbrahim ( x , y ) ; begin
2989: LD_INT 0
2991: PPUSH
// uc_side := 6 ;
2992: LD_ADDR_OWVAR 20
2996: PUSH
2997: LD_INT 6
2999: ST_TO_ADDR
// uc_nation := 3 ;
3000: LD_ADDR_OWVAR 21
3004: PUSH
3005: LD_INT 3
3007: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3008: LD_ADDR_EXP 36
3012: PUSH
3013: LD_STRING IbrahimRu
3015: PPUSH
3016: LD_INT 0
3018: PPUSH
3019: LD_STRING 
3021: PPUSH
3022: CALL 297 0 3
3026: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3027: LD_EXP 36
3031: PPUSH
3032: LD_VAR 0 1
3036: PPUSH
3037: LD_VAR 0 2
3041: PPUSH
3042: LD_INT 8
3044: PPUSH
3045: LD_INT 1
3047: PPUSH
3048: CALL_OW 50
// end ;
3052: LD_VAR 0 3
3056: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3057: LD_EXP 35
3061: PUSH
3062: LD_EXP 38
3066: ADD
3067: PPUSH
3068: LD_INT 95
3070: PUSH
3071: LD_INT 3
3073: PUSH
3074: EMPTY
3075: LIST
3076: LIST
3077: PPUSH
3078: CALL_OW 72
3082: IFFALSE 3138
3084: GO 3086
3086: DISABLE
3087: LD_INT 0
3089: PPUSH
// begin enable ;
3090: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3091: LD_ADDR_VAR 0 1
3095: PUSH
3096: LD_EXP 35
3100: PUSH
3101: LD_EXP 38
3105: ADD
3106: PPUSH
3107: LD_INT 95
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PPUSH
3117: CALL_OW 72
3121: PUSH
3122: FOR_IN
3123: IFFALSE 3136
// RemoveUnit ( i ) ;
3125: LD_VAR 0 1
3129: PPUSH
3130: CALL_OW 64
3134: GO 3122
3136: POP
3137: POP
// end ;
3138: PPOPN 1
3140: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3141: LD_EXP 3
3145: PUSH
3146: LD_EXP 34
3150: PPUSH
3151: LD_INT 4
3153: PPUSH
3154: CALL_OW 308
3158: AND
3159: IFFALSE 3942
3161: GO 3163
3163: DISABLE
3164: LD_INT 0
3166: PPUSH
3167: PPUSH
3168: PPUSH
3169: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3170: LD_EXP 34
3174: PPUSH
3175: LD_INT 110
3177: PPUSH
3178: LD_INT 60
3180: PPUSH
3181: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3185: LD_EXP 34
3189: PPUSH
3190: LD_INT 110
3192: PPUSH
3193: LD_INT 61
3195: PPUSH
3196: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3200: LD_ADDR_VAR 0 2
3204: PUSH
3205: LD_EXP 37
3209: PPUSH
3210: LD_INT 25
3212: PUSH
3213: LD_INT 1
3215: PUSH
3216: EMPTY
3217: LIST
3218: LIST
3219: PPUSH
3220: CALL_OW 72
3224: ST_TO_ADDR
// if tmp then
3225: LD_VAR 0 2
3229: IFFALSE 3323
// begin for i := 1 to 2 do
3231: LD_ADDR_VAR 0 1
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 2
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3321
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3247: LD_VAR 0 2
3251: PUSH
3252: LD_VAR 0 1
3256: ARRAY
3257: PPUSH
3258: LD_INT 5
3260: PPUSH
3261: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3265: LD_VAR 0 2
3269: PUSH
3270: LD_VAR 0 1
3274: ARRAY
3275: PPUSH
3276: LD_INT 2
3278: PPUSH
3279: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3283: LD_VAR 0 2
3287: PUSH
3288: LD_VAR 0 1
3292: ARRAY
3293: PPUSH
3294: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3298: LD_VAR 0 2
3302: PUSH
3303: LD_VAR 0 1
3307: ARRAY
3308: PPUSH
3309: LD_INT 107
3311: PPUSH
3312: LD_INT 66
3314: PPUSH
3315: CALL_OW 171
// end ;
3319: GO 3244
3321: POP
3322: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3323: LD_ADDR_VAR 0 2
3327: PUSH
3328: LD_EXP 37
3332: PPUSH
3333: LD_INT 25
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PPUSH
3343: CALL_OW 72
3347: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3348: LD_INT 35
3350: PPUSH
3351: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3355: LD_ADDR_VAR 0 2
3359: PUSH
3360: LD_EXP 37
3364: PPUSH
3365: LD_INT 25
3367: PUSH
3368: LD_INT 2
3370: PUSH
3371: EMPTY
3372: LIST
3373: LIST
3374: PPUSH
3375: CALL_OW 72
3379: ST_TO_ADDR
// until tmp ;
3380: LD_VAR 0 2
3384: IFFALSE 3348
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3386: LD_VAR 0 2
3390: PPUSH
3391: LD_INT 31
3393: PPUSH
3394: LD_INT 102
3396: PPUSH
3397: LD_INT 69
3399: PPUSH
3400: LD_INT 2
3402: PPUSH
3403: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3407: LD_INT 35
3409: PPUSH
3410: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3414: LD_EXP 37
3418: PPUSH
3419: LD_INT 3
3421: PUSH
3422: LD_INT 60
3424: PUSH
3425: EMPTY
3426: LIST
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 25
3434: PUSH
3435: LD_INT 2
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: PPUSH
3446: CALL_OW 72
3450: IFFALSE 3407
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3452: LD_ADDR_VAR 0 2
3456: PUSH
3457: LD_EXP 37
3461: PPUSH
3462: LD_INT 25
3464: PUSH
3465: LD_INT 2
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: PPUSH
3472: CALL_OW 72
3476: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3477: LD_VAR 0 2
3481: PPUSH
3482: LD_INT 4
3484: PPUSH
3485: LD_INT 116
3487: PPUSH
3488: LD_INT 70
3490: PPUSH
3491: LD_INT 5
3493: PPUSH
3494: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3498: LD_VAR 0 2
3502: PPUSH
3503: LD_INT 31
3505: PPUSH
3506: LD_INT 108
3508: PPUSH
3509: LD_INT 50
3511: PPUSH
3512: LD_INT 2
3514: PPUSH
3515: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3519: LD_INT 35
3521: PPUSH
3522: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3526: LD_INT 22
3528: PUSH
3529: LD_INT 5
3531: PUSH
3532: EMPTY
3533: LIST
3534: LIST
3535: PUSH
3536: LD_INT 30
3538: PUSH
3539: LD_INT 4
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 3
3548: PUSH
3549: LD_INT 57
3551: PUSH
3552: EMPTY
3553: LIST
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: LIST
3563: PPUSH
3564: CALL_OW 69
3568: IFFALSE 3519
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3570: LD_ADDR_VAR 0 3
3574: PUSH
3575: LD_INT 22
3577: PUSH
3578: LD_INT 5
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: PUSH
3585: LD_INT 30
3587: PUSH
3588: LD_INT 4
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 3
3597: PUSH
3598: LD_INT 57
3600: PUSH
3601: EMPTY
3602: LIST
3603: PUSH
3604: EMPTY
3605: LIST
3606: LIST
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: PPUSH
3613: CALL_OW 69
3617: PUSH
3618: LD_INT 1
3620: ARRAY
3621: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3622: LD_ADDR_VAR 0 2
3626: PUSH
3627: LD_EXP 37
3631: PPUSH
3632: LD_INT 25
3634: PUSH
3635: LD_INT 1
3637: PUSH
3638: EMPTY
3639: LIST
3640: LIST
3641: PPUSH
3642: CALL_OW 72
3646: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3647: LD_VAR 0 2
3651: PPUSH
3652: LD_VAR 0 3
3656: PPUSH
3657: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3661: LD_INT 35
3663: PPUSH
3664: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3668: LD_INT 22
3670: PUSH
3671: LD_INT 5
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: PUSH
3678: LD_INT 30
3680: PUSH
3681: LD_INT 31
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: PUSH
3688: LD_INT 3
3690: PUSH
3691: LD_INT 57
3693: PUSH
3694: EMPTY
3695: LIST
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: PUSH
3701: EMPTY
3702: LIST
3703: LIST
3704: LIST
3705: PPUSH
3706: CALL_OW 69
3710: PUSH
3711: LD_INT 2
3713: GREATEREQUAL
3714: IFFALSE 3661
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3716: LD_ADDR_VAR 0 2
3720: PUSH
3721: LD_EXP 37
3725: PPUSH
3726: LD_INT 25
3728: PUSH
3729: LD_INT 2
3731: PUSH
3732: EMPTY
3733: LIST
3734: LIST
3735: PPUSH
3736: CALL_OW 72
3740: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3741: LD_VAR 0 2
3745: PUSH
3746: LD_INT 1
3748: ARRAY
3749: PPUSH
3750: LD_INT 5
3752: PPUSH
3753: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3757: LD_VAR 0 2
3761: PUSH
3762: LD_INT 2
3764: ARRAY
3765: PUSH
3766: LD_VAR 0 2
3770: PUSH
3771: LD_INT 3
3773: ARRAY
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: PPUSH
3779: LD_VAR 0 3
3783: PPUSH
3784: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3788: LD_VAR 0 2
3792: PUSH
3793: LD_INT 2
3795: ARRAY
3796: PUSH
3797: LD_VAR 0 2
3801: PUSH
3802: LD_INT 3
3804: ARRAY
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PPUSH
3810: LD_INT 1
3812: PPUSH
3813: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3817: LD_VAR 0 2
3821: PUSH
3822: LD_INT 2
3824: ARRAY
3825: PUSH
3826: LD_VAR 0 2
3830: PUSH
3831: LD_INT 3
3833: ARRAY
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PPUSH
3839: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3843: LD_ADDR_VAR 0 4
3847: PUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: EMPTY
3855: LIST
3856: LIST
3857: PUSH
3858: LD_INT 30
3860: PUSH
3861: LD_INT 31
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PPUSH
3872: CALL_OW 69
3876: ST_TO_ADDR
// for i := 1 to 2 do
3877: LD_ADDR_VAR 0 1
3881: PUSH
3882: DOUBLE
3883: LD_INT 1
3885: DEC
3886: ST_TO_ADDR
3887: LD_INT 2
3889: PUSH
3890: FOR_TO
3891: IFFALSE 3925
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3893: LD_VAR 0 2
3897: PUSH
3898: LD_VAR 0 1
3902: PUSH
3903: LD_INT 1
3905: PLUS
3906: ARRAY
3907: PPUSH
3908: LD_VAR 0 4
3912: PUSH
3913: LD_VAR 0 1
3917: ARRAY
3918: PPUSH
3919: CALL_OW 180
3923: GO 3890
3925: POP
3926: POP
// wait ( 1 1$00 ) ;
3927: LD_INT 2100
3929: PPUSH
3930: CALL_OW 67
// farmerBaseReady := true ;
3934: LD_ADDR_EXP 4
3938: PUSH
3939: LD_INT 1
3941: ST_TO_ADDR
// end ;
3942: PPOPN 4
3944: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
3945: LD_EXP 4
3949: PUSH
3950: LD_EXP 10
3954: NOT
3955: AND
3956: IFFALSE 4478
3958: GO 3960
3960: DISABLE
3961: LD_INT 0
3963: PPUSH
3964: PPUSH
3965: PPUSH
3966: PPUSH
3967: PPUSH
// begin enable ;
3968: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
3969: LD_ADDR_VAR 0 3
3973: PUSH
3974: LD_EXP 37
3978: PPUSH
3979: LD_INT 25
3981: PUSH
3982: LD_INT 1
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: PPUSH
3989: CALL_OW 72
3993: PUSH
3994: LD_EXP 34
3998: ADD
3999: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: LD_EXP 37
4009: PPUSH
4010: LD_INT 25
4012: PUSH
4013: LD_INT 2
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: PPUSH
4020: CALL_OW 72
4024: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4025: LD_ADDR_VAR 0 5
4029: PUSH
4030: LD_INT 22
4032: PUSH
4033: LD_INT 5
4035: PUSH
4036: EMPTY
4037: LIST
4038: LIST
4039: PUSH
4040: LD_INT 21
4042: PUSH
4043: LD_INT 3
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: PUSH
4050: LD_INT 3
4052: PUSH
4053: LD_INT 24
4055: PUSH
4056: LD_INT 1000
4058: PUSH
4059: EMPTY
4060: LIST
4061: LIST
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: PPUSH
4072: CALL_OW 69
4076: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4077: LD_ADDR_VAR 0 4
4081: PUSH
4082: LD_INT 22
4084: PUSH
4085: LD_INT 5
4087: PUSH
4088: EMPTY
4089: LIST
4090: LIST
4091: PUSH
4092: LD_INT 30
4094: PUSH
4095: LD_INT 4
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: PPUSH
4106: CALL_OW 69
4110: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4111: LD_VAR 0 4
4115: PUSH
4116: LD_INT 1
4118: ARRAY
4119: PPUSH
4120: CALL_OW 302
4124: IFFALSE 4188
// for i in sol do
4126: LD_ADDR_VAR 0 1
4130: PUSH
4131: LD_VAR 0 3
4135: PUSH
4136: FOR_IN
4137: IFFALSE 4186
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4139: LD_VAR 0 1
4143: PPUSH
4144: CALL_OW 256
4148: PUSH
4149: LD_INT 999
4151: LESS
4152: PUSH
4153: LD_VAR 0 1
4157: PPUSH
4158: CALL_OW 310
4162: NOT
4163: AND
4164: IFFALSE 4184
// ComEnterUnit ( i , arm [ 1 ] ) ;
4166: LD_VAR 0 1
4170: PPUSH
4171: LD_VAR 0 4
4175: PUSH
4176: LD_INT 1
4178: ARRAY
4179: PPUSH
4180: CALL_OW 120
4184: GO 4136
4186: POP
4187: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4188: LD_VAR 0 2
4192: NOT
4193: PUSH
4194: LD_INT 22
4196: PUSH
4197: LD_INT 1
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: LD_INT 21
4206: PUSH
4207: LD_INT 1
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: PPUSH
4218: CALL_OW 69
4222: NOT
4223: AND
4224: IFFALSE 4316
// begin uc_side := 5 ;
4226: LD_ADDR_OWVAR 20
4230: PUSH
4231: LD_INT 5
4233: ST_TO_ADDR
// uc_nation := 2 ;
4234: LD_ADDR_OWVAR 21
4238: PUSH
4239: LD_INT 2
4241: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4242: LD_INT 0
4244: PPUSH
4245: LD_INT 2
4247: PPUSH
4248: LD_INT 2
4250: PPUSH
4251: CALL_OW 380
// eng := CreateHuman ;
4255: LD_ADDR_VAR 0 2
4259: PUSH
4260: CALL_OW 44
4264: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4265: LD_VAR 0 2
4269: PPUSH
4270: LD_INT 102
4272: PPUSH
4273: LD_INT 8
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_INT 110
4290: PPUSH
4291: LD_INT 60
4293: PPUSH
4294: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4298: LD_ADDR_EXP 37
4302: PUSH
4303: LD_EXP 37
4307: PUSH
4308: LD_VAR 0 2
4312: UNION
4313: ST_TO_ADDR
// end else
4314: GO 4478
// begin for i in eng do
4316: LD_ADDR_VAR 0 1
4320: PUSH
4321: LD_VAR 0 2
4325: PUSH
4326: FOR_IN
4327: IFFALSE 4476
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4329: LD_INT 10
4331: PPUSH
4332: LD_INT 1
4334: PPUSH
4335: CALL_OW 287
4339: IFFALSE 4390
// begin if IsInUnit ( i ) then
4341: LD_VAR 0 1
4345: PPUSH
4346: CALL_OW 310
4350: IFFALSE 4361
// ComExitBuilding ( i ) ;
4352: LD_VAR 0 1
4356: PPUSH
4357: CALL_OW 122
// if not IsInArea ( i , collectFarmerArea ) then
4361: LD_VAR 0 1
4365: PPUSH
4366: LD_INT 10
4368: PPUSH
4369: CALL_OW 308
4373: NOT
4374: IFFALSE 4388
// AddComMoveToArea ( i , collectFarmerArea ) ;
4376: LD_VAR 0 1
4380: PPUSH
4381: LD_INT 10
4383: PPUSH
4384: CALL_OW 173
// end else
4388: GO 4474
// begin if damagedBuilding then
4390: LD_VAR 0 5
4394: IFFALSE 4438
// begin if IsInUnit ( i ) then
4396: LD_VAR 0 1
4400: PPUSH
4401: CALL_OW 310
4405: IFFALSE 4418
// ComExitBuilding ( i ) else
4407: LD_VAR 0 1
4411: PPUSH
4412: CALL_OW 122
4416: GO 4436
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4418: LD_VAR 0 1
4422: PPUSH
4423: LD_VAR 0 5
4427: PUSH
4428: LD_INT 1
4430: ARRAY
4431: PPUSH
4432: CALL_OW 130
// end else
4436: GO 4474
// if not IsInUnit ( i ) and not HasTask ( i ) then
4438: LD_VAR 0 1
4442: PPUSH
4443: CALL_OW 310
4447: NOT
4448: PUSH
4449: LD_VAR 0 1
4453: PPUSH
4454: CALL_OW 314
4458: NOT
4459: AND
4460: IFFALSE 4474
// ComEnterUnit ( i , arDepot ) ;
4462: LD_VAR 0 1
4466: PPUSH
4467: LD_INT 5
4469: PPUSH
4470: CALL_OW 120
// end ; end ;
4474: GO 4326
4476: POP
4477: POP
// end ; end ;
4478: PPOPN 5
4480: END
// export function StartCargoEvacuation ; begin
4481: LD_INT 0
4483: PPUSH
// while omarCargoCounter > 0 do
4484: LD_EXP 19
4488: PUSH
4489: LD_INT 0
4491: GREATER
4492: IFFALSE 4809
// begin wait ( 0 0$40 ) ;
4494: LD_INT 1400
4496: PPUSH
4497: CALL_OW 67
// omarCargo := PrepareCargo ;
4501: LD_ADDR_EXP 41
4505: PUSH
4506: CALL 4814 0 0
4510: ST_TO_ADDR
// SetTag ( omarCargo , 0 ) ;
4511: LD_EXP 41
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 109
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4523: LD_EXP 41
4527: PPUSH
4528: LD_INT 107
4530: PPUSH
4531: LD_INT 59
4533: PPUSH
4534: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4538: LD_INT 35
4540: PPUSH
4541: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4545: LD_EXP 41
4549: PPUSH
4550: LD_INT 107
4552: PPUSH
4553: LD_INT 59
4555: PPUSH
4556: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4560: LD_EXP 41
4564: PPUSH
4565: CALL_OW 302
4569: NOT
4570: PUSH
4571: LD_EXP 41
4575: PPUSH
4576: CALL_OW 301
4580: OR
4581: IFFALSE 4585
// continue ;
4583: GO 4538
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4585: LD_EXP 41
4589: PPUSH
4590: LD_INT 107
4592: PPUSH
4593: LD_INT 59
4595: PPUSH
4596: CALL_OW 307
4600: PUSH
4601: LD_EXP 41
4605: PPUSH
4606: LD_INT 5
4608: PPUSH
4609: CALL_OW 296
4613: PUSH
4614: LD_INT 6
4616: LESS
4617: OR
4618: IFFALSE 4538
// SetTag ( omarCargo , 1 ) ;
4620: LD_EXP 41
4624: PPUSH
4625: LD_INT 1
4627: PPUSH
4628: CALL_OW 109
// wait ( 0 0$05 ) ;
4632: LD_INT 175
4634: PPUSH
4635: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4639: LD_EXP 41
4643: PPUSH
4644: LD_INT 5
4646: PPUSH
4647: LD_INT 1
4649: PPUSH
4650: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4654: LD_EXP 41
4658: PPUSH
4659: LD_INT 103
4661: PPUSH
4662: LD_INT 9
4664: PPUSH
4665: CALL_OW 171
// wait ( 0 0$1 ) ;
4669: LD_INT 35
4671: PPUSH
4672: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
4676: LD_EXP 41
4680: PPUSH
4681: LD_INT 1
4683: PPUSH
4684: LD_INT 100
4686: PPUSH
4687: CALL_OW 290
// repeat wait ( 0 0$1 ) ;
4691: LD_INT 35
4693: PPUSH
4694: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4698: LD_EXP 41
4702: PPUSH
4703: LD_INT 103
4705: PPUSH
4706: LD_INT 9
4708: PPUSH
4709: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4713: LD_EXP 41
4717: PPUSH
4718: CALL_OW 302
4722: NOT
4723: PUSH
4724: LD_EXP 41
4728: PPUSH
4729: CALL_OW 301
4733: OR
4734: IFFALSE 4738
// continue ;
4736: GO 4691
// until ( IsAt ( omarCargo , 103 , 9 ) or IsInArea ( omarCargo , northRoad ) ) and GetTag ( omarCargo ) > 0 ;
4738: LD_EXP 41
4742: PPUSH
4743: LD_INT 103
4745: PPUSH
4746: LD_INT 9
4748: PPUSH
4749: CALL_OW 307
4753: PUSH
4754: LD_EXP 41
4758: PPUSH
4759: LD_INT 3
4761: PPUSH
4762: CALL_OW 308
4766: OR
4767: PUSH
4768: LD_EXP 41
4772: PPUSH
4773: CALL_OW 110
4777: PUSH
4778: LD_INT 0
4780: GREATER
4781: AND
4782: IFFALSE 4691
// RemoveUnit ( omarCargo ) ;
4784: LD_EXP 41
4788: PPUSH
4789: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4793: LD_ADDR_EXP 19
4797: PUSH
4798: LD_EXP 19
4802: PUSH
4803: LD_INT 1
4805: MINUS
4806: ST_TO_ADDR
// end ;
4807: GO 4484
// end ;
4809: LD_VAR 0 1
4813: RET
// export function PrepareCargo ; var un , veh ; begin
4814: LD_INT 0
4816: PPUSH
4817: PPUSH
4818: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4819: LD_ADDR_VAR 0 3
4823: PUSH
4824: LD_INT 5
4826: PPUSH
4827: LD_INT 2
4829: PPUSH
4830: LD_INT 13
4832: PPUSH
4833: LD_INT 1
4835: PPUSH
4836: LD_INT 1
4838: PPUSH
4839: LD_INT 32
4841: PPUSH
4842: LD_INT 80
4844: PPUSH
4845: CALL 360 0 7
4849: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4850: LD_VAR 0 3
4854: PPUSH
4855: LD_INT 4
4857: PPUSH
4858: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4862: LD_VAR 0 3
4866: PPUSH
4867: LD_INT 101
4869: PPUSH
4870: LD_INT 8
4872: PPUSH
4873: LD_INT 0
4875: PPUSH
4876: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4880: LD_INT 0
4882: PPUSH
4883: LD_INT 3
4885: PPUSH
4886: LD_INT 2
4888: PPUSH
4889: CALL_OW 380
// un := CreateHuman ;
4893: LD_ADDR_VAR 0 2
4897: PUSH
4898: CALL_OW 44
4902: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4903: LD_VAR 0 2
4907: PPUSH
4908: LD_VAR 0 3
4912: PPUSH
4913: CALL_OW 52
// result := veh ;
4917: LD_ADDR_VAR 0 1
4921: PUSH
4922: LD_VAR 0 3
4926: ST_TO_ADDR
// end ; end_of_file
4927: LD_VAR 0 1
4931: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
4932: LD_INT 0
4934: PPUSH
4935: PPUSH
4936: PPUSH
// usForces := [ ] ;
4937: LD_ADDR_EXP 42
4941: PUSH
4942: EMPTY
4943: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
4944: LD_ADDR_EXP 44
4948: PUSH
4949: LD_INT 6
4951: PUSH
4952: LD_INT 32
4954: PUSH
4955: LD_INT 27
4957: PUSH
4958: LD_INT 1
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: LIST
4965: LIST
4966: PUSH
4967: LD_INT 4
4969: PUSH
4970: LD_INT 43
4972: PUSH
4973: LD_INT 24
4975: PUSH
4976: LD_INT 5
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: LIST
4983: LIST
4984: PUSH
4985: LD_INT 27
4987: PUSH
4988: LD_INT 29
4990: PUSH
4991: LD_INT 21
4993: PUSH
4994: LD_INT 0
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: LIST
5007: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
5008: LD_INT 11
5010: PPUSH
5011: CALL_OW 274
5015: PPUSH
5016: LD_INT 1
5018: PPUSH
5019: LD_INT 150
5021: PUSH
5022: LD_INT 120
5024: PUSH
5025: LD_INT 100
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: LIST
5032: PUSH
5033: LD_OWVAR 67
5037: ARRAY
5038: PPUSH
5039: CALL_OW 277
// if Difficulty = 1 then
5043: LD_OWVAR 67
5047: PUSH
5048: LD_INT 1
5050: EQUAL
5051: IFFALSE 5060
// RemoveUnit ( hillBun ) ;
5053: LD_INT 14
5055: PPUSH
5056: CALL_OW 64
// uc_side := 1 ;
5060: LD_ADDR_OWVAR 20
5064: PUSH
5065: LD_INT 1
5067: ST_TO_ADDR
// uc_nation := 1 ;
5068: LD_ADDR_OWVAR 21
5072: PUSH
5073: LD_INT 1
5075: ST_TO_ADDR
// hc_gallery :=  ;
5076: LD_ADDR_OWVAR 33
5080: PUSH
5081: LD_STRING 
5083: ST_TO_ADDR
// hc_name :=  ;
5084: LD_ADDR_OWVAR 26
5088: PUSH
5089: LD_STRING 
5091: ST_TO_ADDR
// hc_importance := 0 ;
5092: LD_ADDR_OWVAR 32
5096: PUSH
5097: LD_INT 0
5099: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5100: LD_INT 1
5102: PPUSH
5103: LD_INT 1
5105: PPUSH
5106: LD_INT 3
5108: PPUSH
5109: CALL_OW 380
// usCommander := CreateHuman ;
5113: LD_ADDR_EXP 43
5117: PUSH
5118: CALL_OW 44
5122: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5123: LD_EXP 43
5127: PPUSH
5128: LD_INT 11
5130: PPUSH
5131: CALL_OW 52
// if Difficulty > 1 then
5135: LD_OWVAR 67
5139: PUSH
5140: LD_INT 1
5142: GREATER
5143: IFFALSE 5225
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5145: LD_INT 0
5147: PPUSH
5148: LD_INT 1
5150: PPUSH
5151: LD_INT 1
5153: PUSH
5154: LD_INT 2
5156: PUSH
5157: LD_INT 3
5159: PUSH
5160: EMPTY
5161: LIST
5162: LIST
5163: LIST
5164: PUSH
5165: LD_OWVAR 67
5169: ARRAY
5170: PPUSH
5171: CALL_OW 380
// un := CreateHuman ;
5175: LD_ADDR_VAR 0 3
5179: PUSH
5180: CALL_OW 44
5184: ST_TO_ADDR
// usForces := usForces union un ;
5185: LD_ADDR_EXP 42
5189: PUSH
5190: LD_EXP 42
5194: PUSH
5195: LD_VAR 0 3
5199: UNION
5200: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5201: LD_VAR 0 3
5205: PPUSH
5206: LD_INT 1
5208: PPUSH
5209: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 14
5220: PPUSH
5221: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5225: LD_ADDR_VAR 0 2
5229: PUSH
5230: DOUBLE
5231: LD_INT 1
5233: DEC
5234: ST_TO_ADDR
5235: LD_INT 2
5237: PUSH
5238: LD_INT 3
5240: PUSH
5241: LD_INT 4
5243: PUSH
5244: EMPTY
5245: LIST
5246: LIST
5247: LIST
5248: PUSH
5249: LD_OWVAR 67
5253: ARRAY
5254: PUSH
5255: FOR_TO
5256: IFFALSE 5398
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5258: LD_INT 0
5260: PPUSH
5261: LD_INT 1
5263: PPUSH
5264: LD_INT 1
5266: PUSH
5267: LD_INT 2
5269: PUSH
5270: LD_INT 3
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PUSH
5278: LD_OWVAR 67
5282: ARRAY
5283: PPUSH
5284: CALL_OW 380
// un := CreateHuman ;
5288: LD_ADDR_VAR 0 3
5292: PUSH
5293: CALL_OW 44
5297: ST_TO_ADDR
// usForces := usForces union un ;
5298: LD_ADDR_EXP 42
5302: PUSH
5303: LD_EXP 42
5307: PUSH
5308: LD_VAR 0 3
5312: UNION
5313: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5314: LD_VAR 0 3
5318: PPUSH
5319: LD_INT 39
5321: PPUSH
5322: LD_INT 24
5324: PPUSH
5325: LD_INT 4
5327: PPUSH
5328: LD_INT 0
5330: PPUSH
5331: CALL_OW 50
// if i < 3 then
5335: LD_VAR 0 2
5339: PUSH
5340: LD_INT 3
5342: LESS
5343: IFFALSE 5396
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 22
5352: PUSH
5353: LD_INT 1
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: PUSH
5360: LD_INT 58
5362: PUSH
5363: EMPTY
5364: LIST
5365: PUSH
5366: LD_INT 30
5368: PUSH
5369: LD_INT 31
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: PUSH
5376: EMPTY
5377: LIST
5378: LIST
5379: LIST
5380: PPUSH
5381: CALL_OW 69
5385: PUSH
5386: LD_VAR 0 2
5390: ARRAY
5391: PPUSH
5392: CALL_OW 120
// end ;
5396: GO 5255
5398: POP
5399: POP
// for i := 1 to 2 do
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: DOUBLE
5406: LD_INT 1
5408: DEC
5409: ST_TO_ADDR
5410: LD_INT 2
5412: PUSH
5413: FOR_TO
5414: IFFALSE 5478
// begin PrepareHuman ( false , 2 , 2 ) ;
5416: LD_INT 0
5418: PPUSH
5419: LD_INT 2
5421: PPUSH
5422: LD_INT 2
5424: PPUSH
5425: CALL_OW 380
// un := CreateHuman ;
5429: LD_ADDR_VAR 0 3
5433: PUSH
5434: CALL_OW 44
5438: ST_TO_ADDR
// usForces := usForces union un ;
5439: LD_ADDR_EXP 42
5443: PUSH
5444: LD_EXP 42
5448: PUSH
5449: LD_VAR 0 3
5453: UNION
5454: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5455: LD_VAR 0 3
5459: PPUSH
5460: LD_INT 39
5462: PPUSH
5463: LD_INT 24
5465: PPUSH
5466: LD_INT 4
5468: PPUSH
5469: LD_INT 0
5471: PPUSH
5472: CALL_OW 50
// end ;
5476: GO 5413
5478: POP
5479: POP
// PrepareHuman ( false , 4 , 1 ) ;
5480: LD_INT 0
5482: PPUSH
5483: LD_INT 4
5485: PPUSH
5486: LD_INT 1
5488: PPUSH
5489: CALL_OW 380
// un := CreateHuman ;
5493: LD_ADDR_VAR 0 3
5497: PUSH
5498: CALL_OW 44
5502: ST_TO_ADDR
// usForces := usForces union un ;
5503: LD_ADDR_EXP 42
5507: PUSH
5508: LD_EXP 42
5512: PUSH
5513: LD_VAR 0 3
5517: UNION
5518: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5519: LD_VAR 0 3
5523: PPUSH
5524: LD_INT 39
5526: PPUSH
5527: LD_INT 24
5529: PPUSH
5530: LD_INT 4
5532: PPUSH
5533: LD_INT 0
5535: PPUSH
5536: CALL_OW 50
// end ;
5540: LD_VAR 0 1
5544: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
5545: LD_EXP 42
5549: PUSH
5550: LD_EXP 6
5554: NOT
5555: AND
5556: IFFALSE 5987
5558: GO 5560
5560: DISABLE
5561: LD_INT 0
5563: PPUSH
5564: PPUSH
5565: PPUSH
5566: PPUSH
5567: PPUSH
// begin enable ;
5568: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5569: LD_ADDR_VAR 0 3
5573: PUSH
5574: LD_EXP 42
5578: PPUSH
5579: LD_INT 25
5581: PUSH
5582: LD_INT 2
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PPUSH
5589: CALL_OW 72
5593: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5594: LD_ADDR_VAR 0 4
5598: PUSH
5599: LD_EXP 42
5603: PPUSH
5604: LD_INT 25
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 72
5618: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5619: LD_ADDR_VAR 0 5
5623: PUSH
5624: LD_EXP 42
5628: PPUSH
5629: LD_INT 25
5631: PUSH
5632: LD_INT 4
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 72
5643: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5644: LD_INT 7
5646: PPUSH
5647: LD_INT 22
5649: PUSH
5650: LD_INT 2
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: PPUSH
5657: CALL_OW 70
5661: PUSH
5662: LD_INT 1
5664: EQUAL
5665: IFFALSE 5741
// for i in sol do
5667: LD_ADDR_VAR 0 1
5671: PUSH
5672: LD_VAR 0 4
5676: PUSH
5677: FOR_IN
5678: IFFALSE 5739
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5680: LD_VAR 0 1
5684: PPUSH
5685: CALL_OW 310
5689: NOT
5690: PUSH
5691: LD_VAR 0 1
5695: PPUSH
5696: CALL_OW 310
5700: PPUSH
5701: CALL_OW 266
5705: PUSH
5706: LD_INT 4
5708: EQUAL
5709: NOT
5710: OR
5711: IFFALSE 5737
// begin ComExitBuilding ( i ) ;
5713: LD_VAR 0 1
5717: PPUSH
5718: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5722: LD_VAR 0 1
5726: PPUSH
5727: LD_INT 37
5729: PPUSH
5730: LD_INT 23
5732: PPUSH
5733: CALL_OW 174
// end ;
5737: GO 5677
5739: POP
5740: POP
// if eng then
5741: LD_VAR 0 3
5745: IFFALSE 5987
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5747: LD_ADDR_VAR 0 2
5751: PUSH
5752: LD_INT 22
5754: PUSH
5755: LD_INT 1
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 95
5764: PUSH
5765: LD_INT 7
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: PUSH
5772: LD_INT 21
5774: PUSH
5775: LD_INT 3
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: PUSH
5782: LD_INT 3
5784: PUSH
5785: LD_INT 24
5787: PUSH
5788: LD_INT 1000
5790: PUSH
5791: EMPTY
5792: LIST
5793: LIST
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: PPUSH
5805: CALL_OW 69
5809: ST_TO_ADDR
// if b then
5810: LD_VAR 0 2
5814: IFFALSE 5845
// begin ComExitBuilding ( eng ) ;
5816: LD_VAR 0 3
5820: PPUSH
5821: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5825: LD_VAR 0 3
5829: PPUSH
5830: LD_VAR 0 2
5834: PUSH
5835: LD_INT 1
5837: ARRAY
5838: PPUSH
5839: CALL_OW 190
// end else
5843: GO 5987
// begin for i in eng do
5845: LD_ADDR_VAR 0 1
5849: PUSH
5850: LD_VAR 0 3
5854: PUSH
5855: FOR_IN
5856: IFFALSE 5985
// if not HasTask ( i ) then
5858: LD_VAR 0 1
5862: PPUSH
5863: CALL_OW 314
5867: NOT
5868: IFFALSE 5983
// begin if americanBuildList then
5870: LD_EXP 44
5874: IFFALSE 5959
// begin if IsInUnit ( i ) then
5876: LD_VAR 0 1
5880: PPUSH
5881: CALL_OW 310
5885: IFFALSE 5896
// ComExitBuilding ( i ) ;
5887: LD_VAR 0 1
5891: PPUSH
5892: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5896: LD_VAR 0 1
5900: PPUSH
5901: LD_EXP 44
5905: PUSH
5906: LD_INT 1
5908: ARRAY
5909: PUSH
5910: LD_INT 1
5912: ARRAY
5913: PPUSH
5914: LD_EXP 44
5918: PUSH
5919: LD_INT 1
5921: ARRAY
5922: PUSH
5923: LD_INT 2
5925: ARRAY
5926: PPUSH
5927: LD_EXP 44
5931: PUSH
5932: LD_INT 1
5934: ARRAY
5935: PUSH
5936: LD_INT 3
5938: ARRAY
5939: PPUSH
5940: LD_EXP 44
5944: PUSH
5945: LD_INT 1
5947: ARRAY
5948: PUSH
5949: LD_INT 4
5951: ARRAY
5952: PPUSH
5953: CALL_OW 205
// end else
5957: GO 5983
// if not IsInUnit ( i ) then
5959: LD_VAR 0 1
5963: PPUSH
5964: CALL_OW 310
5968: NOT
5969: IFFALSE 5983
// ComEnterUnit ( i , usDepot ) ;
5971: LD_VAR 0 1
5975: PPUSH
5976: LD_INT 11
5978: PPUSH
5979: CALL_OW 120
// end ;
5983: GO 5855
5985: POP
5986: POP
// end ; end ; end ;
5987: PPOPN 5
5989: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
5990: LD_INT 0
5992: PPUSH
5993: PPUSH
5994: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_INT 35
6002: PUSH
6003: LD_INT 45
6005: PUSH
6006: LD_INT 48
6008: PUSH
6009: LD_EXP 53
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: ST_TO_ADDR
// for i in tech do
6020: LD_ADDR_VAR 0 4
6024: PUSH
6025: LD_VAR 0 3
6029: PUSH
6030: FOR_IN
6031: IFFALSE 6049
// AddComResearch ( lab , i ) ;
6033: LD_VAR 0 1
6037: PPUSH
6038: LD_VAR 0 4
6042: PPUSH
6043: CALL_OW 184
6047: GO 6030
6049: POP
6050: POP
// end ;
6051: LD_VAR 0 2
6055: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
6056: LD_EXP 11
6060: PUSH
6061: LD_EXP 21
6065: PUSH
6066: LD_EXP 25
6070: LESSEQUAL
6071: AND
6072: IFFALSE 6097
6074: GO 6076
6076: DISABLE
// begin enable ;
6077: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6078: LD_INT 35
6080: PPUSH
6081: LD_INT 2065
6083: PPUSH
6084: CALL_OW 12
6088: PPUSH
6089: CALL_OW 67
// SendConvoy ;
6093: CALL 6195 0 0
// end ;
6097: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6098: LD_EXP 6
6102: PUSH
6103: LD_EXP 16
6107: AND
6108: IFFALSE 6194
6110: GO 6112
6112: DISABLE
// begin if americanHasEscaped then
6113: LD_EXP 7
6117: IFFALSE 6128
// wait ( 3 3$20 ) else
6119: LD_INT 7000
6121: PPUSH
6122: CALL_OW 67
6126: GO 6135
// wait ( 6 6$40 ) ;
6128: LD_INT 14000
6130: PPUSH
6131: CALL_OW 67
// SendAttack ;
6135: CALL 6927 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6139: LD_INT 14000
6141: PUSH
6142: LD_INT 11900
6144: PUSH
6145: LD_INT 9800
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: LIST
6152: PUSH
6153: LD_OWVAR 67
6157: ARRAY
6158: PPUSH
6159: CALL_OW 67
// SendAttack ;
6163: CALL 6927 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6167: LD_EXP 17
6171: PUSH
6172: LD_INT 6
6174: PUSH
6175: LD_INT 7
6177: PUSH
6178: LD_INT 8
6180: PUSH
6181: EMPTY
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_OWVAR 67
6190: ARRAY
6191: LESS
6192: IFFALSE 6139
// end ;
6194: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6195: LD_INT 0
6197: PPUSH
6198: PPUSH
6199: PPUSH
6200: PPUSH
6201: PPUSH
6202: PPUSH
6203: PPUSH
6204: PPUSH
// road := rand ( 1 , 2 ) ;
6205: LD_ADDR_VAR 0 4
6209: PUSH
6210: LD_INT 1
6212: PPUSH
6213: LD_INT 2
6215: PPUSH
6216: CALL_OW 12
6220: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6221: LD_ADDR_VAR 0 8
6225: PUSH
6226: LD_INT 3
6228: PUSH
6229: LD_INT 8
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_VAR 0 4
6240: ARRAY
6241: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6242: LD_ADDR_VAR 0 5
6246: PUSH
6247: LD_INT 35
6249: PUSH
6250: LD_INT 66
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: PUSH
6261: LD_INT 101
6263: PUSH
6264: LD_INT 8
6266: PUSH
6267: LD_INT 4
6269: PUSH
6270: EMPTY
6271: LIST
6272: LIST
6273: LIST
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6279: LD_ADDR_VAR 0 6
6283: PUSH
6284: LD_INT 34
6286: PUSH
6287: LD_INT 67
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 38
6296: PUSH
6297: LD_INT 62
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 43
6306: PUSH
6307: LD_INT 54
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PUSH
6314: LD_INT 57
6316: PUSH
6317: LD_INT 57
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: PUSH
6324: LD_INT 77
6326: PUSH
6327: LD_INT 71
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PUSH
6334: LD_INT 86
6336: PUSH
6337: LD_INT 60
6339: PUSH
6340: EMPTY
6341: LIST
6342: LIST
6343: PUSH
6344: LD_INT 89
6346: PUSH
6347: LD_INT 35
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: PUSH
6354: LD_INT 93
6356: PUSH
6357: LD_INT 17
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 97
6366: PUSH
6367: LD_INT 10
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PUSH
6374: LD_INT 103
6376: PUSH
6377: LD_INT 9
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: LIST
6394: LIST
6395: ST_TO_ADDR
// if road = 2 then
6396: LD_VAR 0 4
6400: PUSH
6401: LD_INT 2
6403: EQUAL
6404: IFFALSE 6421
// points := ReverseArray ( points ) ;
6406: LD_ADDR_VAR 0 6
6410: PUSH
6411: LD_VAR 0 6
6415: PPUSH
6416: CALL 1048 0 1
6420: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6421: LD_INT 4
6423: PPUSH
6424: LD_INT 1
6426: PPUSH
6427: LD_INT 2
6429: PPUSH
6430: LD_INT 1
6432: PPUSH
6433: LD_INT 1
6435: PPUSH
6436: LD_INT 12
6438: PPUSH
6439: LD_INT 80
6441: PPUSH
6442: CALL 360 0 7
// veh := CreateVehicle ;
6446: LD_ADDR_VAR 0 3
6450: PUSH
6451: CALL_OW 45
6455: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6456: LD_VAR 0 3
6460: PPUSH
6461: LD_VAR 0 5
6465: PUSH
6466: LD_VAR 0 4
6470: ARRAY
6471: PUSH
6472: LD_INT 3
6474: ARRAY
6475: PPUSH
6476: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6480: LD_VAR 0 3
6484: PPUSH
6485: LD_VAR 0 5
6489: PUSH
6490: LD_VAR 0 4
6494: ARRAY
6495: PUSH
6496: LD_INT 1
6498: ARRAY
6499: PPUSH
6500: LD_VAR 0 5
6504: PUSH
6505: LD_VAR 0 4
6509: ARRAY
6510: PUSH
6511: LD_INT 2
6513: ARRAY
6514: PPUSH
6515: LD_INT 0
6517: PPUSH
6518: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6522: LD_INT 0
6524: PPUSH
6525: LD_INT 1
6527: PPUSH
6528: LD_OWVAR 67
6532: PPUSH
6533: CALL_OW 380
// un := CreateHuman ;
6537: LD_ADDR_VAR 0 2
6541: PUSH
6542: CALL_OW 44
6546: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6547: LD_VAR 0 2
6551: PPUSH
6552: LD_VAR 0 3
6556: PPUSH
6557: CALL_OW 52
// if ( Prob ( [ 60 , 56 , 52 ] [ Difficulty ] ) + tick mod 30 ) or convoyCounter < 4 then
6561: LD_INT 60
6563: PUSH
6564: LD_INT 56
6566: PUSH
6567: LD_INT 52
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: LIST
6574: PUSH
6575: LD_OWVAR 67
6579: ARRAY
6580: PPUSH
6581: CALL_OW 13
6585: PUSH
6586: LD_OWVAR 1
6590: PUSH
6591: LD_INT 30
6593: MOD
6594: PLUS
6595: PUSH
6596: LD_EXP 21
6600: PUSH
6601: LD_INT 4
6603: LESS
6604: OR
6605: IFFALSE 6622
// SetCargo ( veh , mat_cans , 100 ) ;
6607: LD_VAR 0 3
6611: PPUSH
6612: LD_INT 1
6614: PPUSH
6615: LD_INT 100
6617: PPUSH
6618: CALL_OW 290
// for i := 2 to points do
6622: LD_ADDR_VAR 0 7
6626: PUSH
6627: DOUBLE
6628: LD_INT 2
6630: DEC
6631: ST_TO_ADDR
6632: LD_VAR 0 6
6636: PUSH
6637: FOR_TO
6638: IFFALSE 6681
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6640: LD_VAR 0 3
6644: PPUSH
6645: LD_VAR 0 6
6649: PUSH
6650: LD_VAR 0 7
6654: ARRAY
6655: PUSH
6656: LD_INT 1
6658: ARRAY
6659: PPUSH
6660: LD_VAR 0 6
6664: PUSH
6665: LD_VAR 0 7
6669: ARRAY
6670: PUSH
6671: LD_INT 2
6673: ARRAY
6674: PPUSH
6675: CALL_OW 171
6679: GO 6637
6681: POP
6682: POP
// convoyCounter := convoyCounter + 1 ;
6683: LD_ADDR_EXP 21
6687: PUSH
6688: LD_EXP 21
6692: PUSH
6693: LD_INT 1
6695: PLUS
6696: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6697: LD_INT 35
6699: PPUSH
6700: CALL_OW 67
// if not HasTask ( veh ) then
6704: LD_VAR 0 3
6708: PPUSH
6709: CALL_OW 314
6713: NOT
6714: IFFALSE 6755
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6716: LD_VAR 0 3
6720: PPUSH
6721: LD_VAR 0 6
6725: PUSH
6726: LD_VAR 0 6
6730: ARRAY
6731: PUSH
6732: LD_INT 1
6734: ARRAY
6735: PPUSH
6736: LD_VAR 0 6
6740: PUSH
6741: LD_VAR 0 6
6745: ARRAY
6746: PUSH
6747: LD_INT 2
6749: ARRAY
6750: PPUSH
6751: CALL_OW 111
// if not IsOk ( veh ) then
6755: LD_VAR 0 3
6759: PPUSH
6760: CALL_OW 302
6764: NOT
6765: IFFALSE 6806
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6767: LD_VAR 0 2
6771: PPUSH
6772: LD_VAR 0 6
6776: PUSH
6777: LD_VAR 0 6
6781: ARRAY
6782: PUSH
6783: LD_INT 1
6785: ARRAY
6786: PPUSH
6787: LD_VAR 0 6
6791: PUSH
6792: LD_VAR 0 6
6796: ARRAY
6797: PUSH
6798: LD_INT 2
6800: ARRAY
6801: PPUSH
6802: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6806: LD_VAR 0 3
6810: PPUSH
6811: LD_VAR 0 8
6815: PPUSH
6816: CALL_OW 308
6820: PUSH
6821: LD_VAR 0 2
6825: PPUSH
6826: LD_VAR 0 8
6830: PPUSH
6831: CALL_OW 308
6835: OR
6836: IFFALSE 6697
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6838: LD_VAR 0 2
6842: PPUSH
6843: CALL_OW 302
6847: PUSH
6848: LD_VAR 0 3
6852: PPUSH
6853: CALL_OW 302
6857: NOT
6858: AND
6859: PUSH
6860: LD_VAR 0 2
6864: PPUSH
6865: LD_VAR 0 8
6869: PPUSH
6870: CALL_OW 308
6874: AND
6875: IFFALSE 6886
// RemoveUnit ( un ) ;
6877: LD_VAR 0 2
6881: PPUSH
6882: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6886: LD_VAR 0 3
6890: PPUSH
6891: LD_VAR 0 8
6895: PPUSH
6896: CALL_OW 308
6900: PUSH
6901: LD_VAR 0 3
6905: PPUSH
6906: CALL_OW 302
6910: AND
6911: IFFALSE 6922
// RemoveUnit ( veh ) ;
6913: LD_VAR 0 3
6917: PPUSH
6918: CALL_OW 64
// end ;
6922: LD_VAR 0 1
6926: RET
// export function SendAttack ; var un , veh , i ; begin
6927: LD_INT 0
6929: PPUSH
6930: PPUSH
6931: PPUSH
6932: PPUSH
// IncomingAttack ;
6933: CALL 15414 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
6937: LD_INT 2100
6939: PPUSH
6940: LD_INT 3500
6942: PPUSH
6943: CALL_OW 12
6947: PPUSH
6948: CALL_OW 67
// for i := 1 to [ 3 , 3 , 4 ] [ Difficulty ] + attackWave div 3 do
6952: LD_ADDR_VAR 0 4
6956: PUSH
6957: DOUBLE
6958: LD_INT 1
6960: DEC
6961: ST_TO_ADDR
6962: LD_INT 3
6964: PUSH
6965: LD_INT 3
6967: PUSH
6968: LD_INT 4
6970: PUSH
6971: EMPTY
6972: LIST
6973: LIST
6974: LIST
6975: PUSH
6976: LD_OWVAR 67
6980: ARRAY
6981: PUSH
6982: LD_EXP 17
6986: PUSH
6987: LD_INT 3
6989: DIV
6990: PLUS
6991: PUSH
6992: FOR_TO
6993: IFFALSE 7105
// begin uc_side := 1 ;
6995: LD_ADDR_OWVAR 20
6999: PUSH
7000: LD_INT 1
7002: ST_TO_ADDR
// uc_nation := 1 ;
7003: LD_ADDR_OWVAR 21
7007: PUSH
7008: LD_INT 1
7010: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
7011: LD_INT 0
7013: PPUSH
7014: LD_INT 1
7016: PPUSH
7017: LD_INT 2
7019: PUSH
7020: LD_INT 3
7022: PUSH
7023: LD_INT 4
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: LIST
7030: PUSH
7031: LD_OWVAR 67
7035: ARRAY
7036: PPUSH
7037: CALL_OW 380
// un := CreateHuman ;
7041: LD_ADDR_VAR 0 2
7045: PUSH
7046: CALL_OW 44
7050: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7051: LD_VAR 0 2
7055: PPUSH
7056: LD_INT 37
7058: PPUSH
7059: LD_INT 70
7061: PPUSH
7062: LD_INT 3
7064: PPUSH
7065: LD_INT 0
7067: PPUSH
7068: CALL_OW 50
// usAttackers := usAttackers union un ;
7072: LD_ADDR_EXP 45
7076: PUSH
7077: LD_EXP 45
7081: PUSH
7082: LD_VAR 0 2
7086: UNION
7087: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7088: LD_VAR 0 2
7092: PPUSH
7093: LD_INT 40
7095: PPUSH
7096: LD_INT 65
7098: PPUSH
7099: CALL_OW 111
// end ;
7103: GO 6992
7105: POP
7106: POP
// uc_side := 1 ;
7107: LD_ADDR_OWVAR 20
7111: PUSH
7112: LD_INT 1
7114: ST_TO_ADDR
// uc_nation := 1 ;
7115: LD_ADDR_OWVAR 21
7119: PUSH
7120: LD_INT 1
7122: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7123: LD_INT 0
7125: PPUSH
7126: LD_INT 4
7128: PPUSH
7129: LD_INT 2
7131: PPUSH
7132: CALL_OW 380
// un := CreateHuman ;
7136: LD_ADDR_VAR 0 2
7140: PUSH
7141: CALL_OW 44
7145: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7146: LD_VAR 0 2
7150: PPUSH
7151: LD_INT 37
7153: PPUSH
7154: LD_INT 70
7156: PPUSH
7157: LD_INT 3
7159: PPUSH
7160: LD_INT 0
7162: PPUSH
7163: CALL_OW 50
// usAttackers := usAttackers union un ;
7167: LD_ADDR_EXP 45
7171: PUSH
7172: LD_EXP 45
7176: PUSH
7177: LD_VAR 0 2
7181: UNION
7182: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7183: LD_VAR 0 2
7187: PPUSH
7188: LD_INT 40
7190: PPUSH
7191: LD_INT 65
7193: PPUSH
7194: CALL_OW 111
// if attackWave > 1 or Difficulty > 1 then
7198: LD_EXP 17
7202: PUSH
7203: LD_INT 1
7205: GREATER
7206: PUSH
7207: LD_OWVAR 67
7211: PUSH
7212: LD_INT 1
7214: GREATER
7215: OR
7216: IFFALSE 7419
// begin for i := 1 to Difficulty + attackWave div 4 do
7218: LD_ADDR_VAR 0 4
7222: PUSH
7223: DOUBLE
7224: LD_INT 1
7226: DEC
7227: ST_TO_ADDR
7228: LD_OWVAR 67
7232: PUSH
7233: LD_EXP 17
7237: PUSH
7238: LD_INT 4
7240: DIV
7241: PLUS
7242: PUSH
7243: FOR_TO
7244: IFFALSE 7417
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7246: LD_ADDR_VAR 0 3
7250: PUSH
7251: LD_INT 1
7253: PPUSH
7254: LD_INT 1
7256: PPUSH
7257: LD_INT 2
7259: PPUSH
7260: LD_INT 1
7262: PPUSH
7263: LD_INT 1
7265: PPUSH
7266: LD_INT 4
7268: PUSH
7269: LD_INT 3
7271: PUSH
7272: LD_INT 2
7274: PUSH
7275: EMPTY
7276: LIST
7277: LIST
7278: LIST
7279: PUSH
7280: LD_INT 1
7282: PPUSH
7283: LD_INT 3
7285: PPUSH
7286: CALL_OW 12
7290: ARRAY
7291: PPUSH
7292: LD_INT 90
7294: PPUSH
7295: CALL 360 0 7
7299: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7300: LD_VAR 0 3
7304: PPUSH
7305: LD_INT 35
7307: PPUSH
7308: LD_INT 65
7310: PPUSH
7311: LD_INT 0
7313: PPUSH
7314: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7318: LD_INT 0
7320: PPUSH
7321: LD_INT 3
7323: PPUSH
7324: LD_OWVAR 67
7328: PUSH
7329: LD_INT 1
7331: PLUS
7332: PPUSH
7333: CALL_OW 380
// un := CreateHuman ;
7337: LD_ADDR_VAR 0 2
7341: PUSH
7342: CALL_OW 44
7346: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7347: LD_VAR 0 2
7351: PPUSH
7352: LD_VAR 0 3
7356: PPUSH
7357: CALL_OW 52
// usAttackers := usAttackers union un ;
7361: LD_ADDR_EXP 45
7365: PUSH
7366: LD_EXP 45
7370: PUSH
7371: LD_VAR 0 2
7375: UNION
7376: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7377: LD_VAR 0 3
7381: PPUSH
7382: LD_INT 39
7384: PPUSH
7385: LD_INT 60
7387: PPUSH
7388: CALL_OW 111
// wait ( 0 0$2 ) ;
7392: LD_INT 70
7394: PPUSH
7395: CALL_OW 67
// usAttackers := usAttackers union veh ;
7399: LD_ADDR_EXP 45
7403: PUSH
7404: LD_EXP 45
7408: PUSH
7409: LD_VAR 0 3
7413: UNION
7414: ST_TO_ADDR
// end ;
7415: GO 7243
7417: POP
7418: POP
// end ; attackWave := attackWave + 1 ;
7419: LD_ADDR_EXP 17
7423: PUSH
7424: LD_EXP 17
7428: PUSH
7429: LD_INT 1
7431: PLUS
7432: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7433: LD_EXP 22
7437: PPUSH
7438: CALL_OW 427
// end ;
7442: LD_VAR 0 1
7446: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7447: LD_INT 0
7449: PPUSH
7450: PPUSH
7451: PPUSH
7452: PPUSH
7453: PPUSH
7454: PPUSH
7455: PPUSH
7456: PPUSH
7457: PPUSH
7458: PPUSH
7459: PPUSH
// if retreatAllowed then
7460: LD_EXP 10
7464: IFFALSE 7476
// strategy := 2 else
7466: LD_ADDR_VAR 0 5
7470: PUSH
7471: LD_INT 2
7473: ST_TO_ADDR
7474: GO 7492
// strategy := rand ( 0 , 2 ) ;
7476: LD_ADDR_VAR 0 5
7480: PUSH
7481: LD_INT 0
7483: PPUSH
7484: LD_INT 2
7486: PPUSH
7487: CALL_OW 12
7491: ST_TO_ADDR
// attackFormula := [ ] ;
7492: LD_ADDR_VAR 0 6
7496: PUSH
7497: EMPTY
7498: ST_TO_ADDR
// case strategy of 0 :
7499: LD_VAR 0 5
7503: PUSH
7504: LD_INT 0
7506: DOUBLE
7507: EQUAL
7508: IFTRUE 7512
7510: GO 7842
7512: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7513: LD_INT 11
7515: PPUSH
7516: LD_INT 22
7518: PUSH
7519: LD_INT 2
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 30
7528: PUSH
7529: LD_INT 4
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PPUSH
7540: CALL_OW 70
7544: NOT
7545: IFFALSE 7617
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7547: LD_ADDR_VAR 0 6
7551: PUSH
7552: LD_INT 41
7554: PUSH
7555: LD_INT 34
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: PUSH
7562: EMPTY
7563: LIST
7564: PUSH
7565: LD_INT 53
7567: PUSH
7568: LD_INT 62
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 37
7577: PUSH
7578: LD_INT 63
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 44
7587: PUSH
7588: LD_INT 45
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PUSH
7595: LD_INT 37
7597: PUSH
7598: LD_INT 28
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: LIST
7613: LIST
7614: ST_TO_ADDR
7615: GO 7840
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7617: LD_INT 12
7619: PPUSH
7620: LD_INT 22
7622: PUSH
7623: LD_INT 2
7625: PUSH
7626: EMPTY
7627: LIST
7628: LIST
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 30
7635: PUSH
7636: LD_INT 4
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PUSH
7643: LD_INT 30
7645: PUSH
7646: LD_INT 31
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 30
7655: PUSH
7656: LD_INT 32
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: LIST
7667: LIST
7668: PUSH
7669: EMPTY
7670: LIST
7671: LIST
7672: PPUSH
7673: CALL_OW 70
7677: NOT
7678: IFFALSE 7761
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7680: LD_ADDR_VAR 0 6
7684: PUSH
7685: LD_INT 27
7687: PUSH
7688: LD_INT 42
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: LD_INT 27
7697: PUSH
7698: LD_INT 32
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: PUSH
7705: EMPTY
7706: LIST
7707: LIST
7708: PUSH
7709: LD_INT 53
7711: PUSH
7712: LD_INT 62
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: PUSH
7719: LD_INT 37
7721: PUSH
7722: LD_INT 63
7724: PUSH
7725: EMPTY
7726: LIST
7727: LIST
7728: PUSH
7729: LD_INT 44
7731: PUSH
7732: LD_INT 45
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: PUSH
7739: LD_INT 37
7741: PUSH
7742: LD_INT 28
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: ST_TO_ADDR
7759: GO 7840
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7761: LD_ADDR_VAR 0 6
7765: PUSH
7766: LD_INT 71
7768: PUSH
7769: LD_INT 67
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PUSH
7776: LD_INT 54
7778: PUSH
7779: LD_INT 35
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 63
7792: PUSH
7793: LD_INT 40
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: LD_INT 37
7802: PUSH
7803: LD_INT 63
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: PUSH
7810: LD_INT 44
7812: PUSH
7813: LD_INT 45
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: LD_INT 37
7822: PUSH
7823: LD_INT 28
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: PUSH
7830: EMPTY
7831: LIST
7832: LIST
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: LIST
7838: LIST
7839: ST_TO_ADDR
// end ; 1 :
7840: GO 8045
7842: LD_INT 1
7844: DOUBLE
7845: EQUAL
7846: IFTRUE 7850
7848: GO 7954
7850: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7851: LD_ADDR_VAR 0 6
7855: PUSH
7856: LD_INT 71
7858: PUSH
7859: LD_INT 67
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PUSH
7866: LD_INT 82
7868: PUSH
7869: LD_INT 23
7871: PUSH
7872: EMPTY
7873: LIST
7874: LIST
7875: PUSH
7876: LD_INT 53
7878: PUSH
7879: LD_INT 7
7881: PUSH
7882: EMPTY
7883: LIST
7884: LIST
7885: PUSH
7886: LD_INT 43
7888: PUSH
7889: LD_INT 10
7891: PUSH
7892: EMPTY
7893: LIST
7894: LIST
7895: PUSH
7896: EMPTY
7897: LIST
7898: LIST
7899: LIST
7900: LIST
7901: PUSH
7902: LD_INT 53
7904: PUSH
7905: LD_INT 62
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: LD_INT 37
7914: PUSH
7915: LD_INT 63
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PUSH
7922: LD_INT 44
7924: PUSH
7925: LD_INT 45
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PUSH
7932: LD_INT 37
7934: PUSH
7935: LD_INT 28
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PUSH
7946: EMPTY
7947: LIST
7948: LIST
7949: LIST
7950: LIST
7951: ST_TO_ADDR
7952: GO 8045
7954: LD_INT 2
7956: DOUBLE
7957: EQUAL
7958: IFTRUE 7962
7960: GO 8044
7962: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
7963: LD_ADDR_VAR 0 6
7967: PUSH
7968: LD_INT 90
7970: PUSH
7971: LD_INT 59
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: PUSH
7978: LD_INT 108
7980: PUSH
7981: LD_INT 64
7983: PUSH
7984: EMPTY
7985: LIST
7986: LIST
7987: PUSH
7988: EMPTY
7989: LIST
7990: LIST
7991: PUSH
7992: LD_INT 82
7994: PUSH
7995: LD_INT 75
7997: PUSH
7998: EMPTY
7999: LIST
8000: LIST
8001: PUSH
8002: LD_INT 73
8004: PUSH
8005: LD_INT 67
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: PUSH
8012: LD_INT 101
8014: PUSH
8015: LD_INT 65
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 108
8024: PUSH
8025: LD_INT 62
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: EMPTY
8033: LIST
8034: LIST
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: LIST
8040: LIST
8041: ST_TO_ADDR
8042: GO 8045
8044: POP
// if not attackFormula then
8045: LD_VAR 0 6
8049: NOT
8050: IFFALSE 8054
// exit ;
8052: GO 9486
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8054: LD_ADDR_VAR 0 7
8058: PUSH
8059: LD_EXP 45
8063: PPUSH
8064: LD_INT 25
8066: PUSH
8067: LD_INT 1
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PPUSH
8074: CALL_OW 72
8078: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8079: LD_ADDR_VAR 0 8
8083: PUSH
8084: LD_EXP 45
8088: PPUSH
8089: LD_INT 25
8091: PUSH
8092: LD_INT 4
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PPUSH
8099: CALL_OW 72
8103: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8104: LD_ADDR_VAR 0 9
8108: PUSH
8109: LD_EXP 45
8113: PPUSH
8114: LD_INT 25
8116: PUSH
8117: LD_INT 3
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PPUSH
8124: CALL_OW 72
8128: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8129: LD_ADDR_VAR 0 10
8133: PUSH
8134: LD_EXP 45
8138: PPUSH
8139: LD_INT 21
8141: PUSH
8142: LD_INT 2
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PPUSH
8149: CALL_OW 72
8153: ST_TO_ADDR
// if sci then
8154: LD_VAR 0 8
8158: IFFALSE 8195
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8160: LD_VAR 0 8
8164: PPUSH
8165: LD_VAR 0 6
8169: PUSH
8170: LD_INT 2
8172: ARRAY
8173: PUSH
8174: LD_INT 1
8176: ARRAY
8177: PPUSH
8178: LD_VAR 0 6
8182: PUSH
8183: LD_INT 2
8185: ARRAY
8186: PUSH
8187: LD_INT 2
8189: ARRAY
8190: PPUSH
8191: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8195: LD_INT 35
8197: PPUSH
8198: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8202: LD_ADDR_VAR 0 7
8206: PUSH
8207: LD_EXP 45
8211: PPUSH
8212: LD_INT 25
8214: PUSH
8215: LD_INT 1
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: PPUSH
8222: CALL_OW 72
8226: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8227: LD_ADDR_VAR 0 8
8231: PUSH
8232: LD_EXP 45
8236: PPUSH
8237: LD_INT 25
8239: PUSH
8240: LD_INT 4
8242: PUSH
8243: EMPTY
8244: LIST
8245: LIST
8246: PPUSH
8247: CALL_OW 72
8251: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8252: LD_ADDR_VAR 0 9
8256: PUSH
8257: LD_EXP 45
8261: PPUSH
8262: LD_INT 25
8264: PUSH
8265: LD_INT 3
8267: PUSH
8268: EMPTY
8269: LIST
8270: LIST
8271: PPUSH
8272: CALL_OW 72
8276: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8277: LD_ADDR_VAR 0 10
8281: PUSH
8282: LD_EXP 45
8286: PPUSH
8287: LD_INT 21
8289: PUSH
8290: LD_INT 2
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: PPUSH
8297: CALL_OW 72
8301: ST_TO_ADDR
// if sol then
8302: LD_VAR 0 7
8306: IFFALSE 8701
// begin for i in sol do
8308: LD_ADDR_VAR 0 2
8312: PUSH
8313: LD_VAR 0 7
8317: PUSH
8318: FOR_IN
8319: IFFALSE 8699
// begin tag := GetTag ( i ) ;
8321: LD_ADDR_VAR 0 4
8325: PUSH
8326: LD_VAR 0 2
8330: PPUSH
8331: CALL_OW 110
8335: ST_TO_ADDR
// if not tag then
8336: LD_VAR 0 4
8340: NOT
8341: IFFALSE 8459
// begin if GetLives ( i ) = 1000 then
8343: LD_VAR 0 2
8347: PPUSH
8348: CALL_OW 256
8352: PUSH
8353: LD_INT 1000
8355: EQUAL
8356: IFFALSE 8372
// SetTag ( i , 1 ) else
8358: LD_VAR 0 2
8362: PPUSH
8363: LD_INT 1
8365: PPUSH
8366: CALL_OW 109
8370: GO 8457
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8372: LD_VAR 0 2
8376: PPUSH
8377: LD_VAR 0 6
8381: PUSH
8382: LD_INT 2
8384: ARRAY
8385: PUSH
8386: LD_INT 1
8388: ARRAY
8389: PPUSH
8390: LD_VAR 0 6
8394: PUSH
8395: LD_INT 2
8397: ARRAY
8398: PUSH
8399: LD_INT 2
8401: ARRAY
8402: PPUSH
8403: CALL_OW 297
8407: PUSH
8408: LD_INT 6
8410: GREATER
8411: IFFALSE 8457
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8413: LD_VAR 0 2
8417: PPUSH
8418: LD_VAR 0 6
8422: PUSH
8423: LD_INT 2
8425: ARRAY
8426: PUSH
8427: LD_INT 1
8429: ARRAY
8430: PPUSH
8431: LD_VAR 0 6
8435: PUSH
8436: LD_INT 2
8438: ARRAY
8439: PUSH
8440: LD_INT 2
8442: ARRAY
8443: PPUSH
8444: CALL_OW 111
// AddComHold ( i ) ;
8448: LD_VAR 0 2
8452: PPUSH
8453: CALL_OW 200
// end ; end else
8457: GO 8697
// begin if GetLives ( i ) < 720 then
8459: LD_VAR 0 2
8463: PPUSH
8464: CALL_OW 256
8468: PUSH
8469: LD_INT 720
8471: LESS
8472: IFFALSE 8488
// SetTag ( i , 0 ) else
8474: LD_VAR 0 2
8478: PPUSH
8479: LD_INT 0
8481: PPUSH
8482: CALL_OW 109
8486: GO 8697
// if tag <= attackFormula [ 1 ] then
8488: LD_VAR 0 4
8492: PUSH
8493: LD_VAR 0 6
8497: PUSH
8498: LD_INT 1
8500: ARRAY
8501: LESSEQUAL
8502: IFFALSE 8663
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8504: LD_VAR 0 2
8508: PPUSH
8509: LD_VAR 0 6
8513: PUSH
8514: LD_INT 1
8516: ARRAY
8517: PUSH
8518: LD_VAR 0 4
8522: ARRAY
8523: PUSH
8524: LD_INT 1
8526: ARRAY
8527: PPUSH
8528: LD_VAR 0 6
8532: PUSH
8533: LD_INT 1
8535: ARRAY
8536: PUSH
8537: LD_VAR 0 4
8541: ARRAY
8542: PUSH
8543: LD_INT 2
8545: ARRAY
8546: PPUSH
8547: CALL_OW 297
8551: PUSH
8552: LD_INT 6
8554: GREATER
8555: IFFALSE 8606
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8557: LD_VAR 0 2
8561: PPUSH
8562: LD_VAR 0 6
8566: PUSH
8567: LD_INT 1
8569: ARRAY
8570: PUSH
8571: LD_VAR 0 4
8575: ARRAY
8576: PUSH
8577: LD_INT 1
8579: ARRAY
8580: PPUSH
8581: LD_VAR 0 6
8585: PUSH
8586: LD_INT 1
8588: ARRAY
8589: PUSH
8590: LD_VAR 0 4
8594: ARRAY
8595: PUSH
8596: LD_INT 2
8598: ARRAY
8599: PPUSH
8600: CALL_OW 114
8604: GO 8661
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8606: LD_INT 81
8608: PUSH
8609: LD_INT 1
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PUSH
8616: LD_INT 91
8618: PUSH
8619: LD_VAR 0 2
8623: PUSH
8624: LD_INT 10
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: LIST
8631: PUSH
8632: EMPTY
8633: LIST
8634: LIST
8635: PPUSH
8636: CALL_OW 69
8640: NOT
8641: IFFALSE 8661
// SetTag ( i , tag + 1 ) ;
8643: LD_VAR 0 2
8647: PPUSH
8648: LD_VAR 0 4
8652: PUSH
8653: LD_INT 1
8655: PLUS
8656: PPUSH
8657: CALL_OW 109
// end else
8661: GO 8697
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8663: LD_VAR 0 2
8667: PPUSH
8668: LD_INT 81
8670: PUSH
8671: LD_INT 1
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: PPUSH
8678: CALL_OW 69
8682: PPUSH
8683: LD_VAR 0 2
8687: PPUSH
8688: CALL_OW 74
8692: PPUSH
8693: CALL_OW 115
// end ; end ;
8697: GO 8318
8699: POP
8700: POP
// end ; if sci then
8701: LD_VAR 0 8
8705: IFFALSE 8864
// begin if not sol and not mech then
8707: LD_VAR 0 7
8711: NOT
8712: PUSH
8713: LD_VAR 0 9
8717: NOT
8718: AND
8719: IFFALSE 8771
// begin for i in sci do
8721: LD_ADDR_VAR 0 2
8725: PUSH
8726: LD_VAR 0 8
8730: PUSH
8731: FOR_IN
8732: IFFALSE 8767
// begin usForces := usForces union i ;
8734: LD_ADDR_EXP 42
8738: PUSH
8739: LD_EXP 42
8743: PUSH
8744: LD_VAR 0 2
8748: UNION
8749: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8750: LD_VAR 0 2
8754: PPUSH
8755: LD_INT 34
8757: PPUSH
8758: LD_INT 68
8760: PPUSH
8761: CALL_OW 111
// end ;
8765: GO 8731
8767: POP
8768: POP
// end else
8769: GO 8864
// for i in sci do
8771: LD_ADDR_VAR 0 2
8775: PUSH
8776: LD_VAR 0 8
8780: PUSH
8781: FOR_IN
8782: IFFALSE 8862
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8784: LD_VAR 0 2
8788: PPUSH
8789: LD_VAR 0 6
8793: PUSH
8794: LD_INT 2
8796: ARRAY
8797: PUSH
8798: LD_INT 1
8800: ARRAY
8801: PPUSH
8802: LD_VAR 0 6
8806: PUSH
8807: LD_INT 2
8809: ARRAY
8810: PUSH
8811: LD_INT 2
8813: ARRAY
8814: PPUSH
8815: CALL_OW 297
8819: PUSH
8820: LD_INT 8
8822: GREATER
8823: IFFALSE 8860
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8825: LD_VAR 0 2
8829: PPUSH
8830: LD_VAR 0 6
8834: PUSH
8835: LD_INT 2
8837: ARRAY
8838: PUSH
8839: LD_INT 1
8841: ARRAY
8842: PPUSH
8843: LD_VAR 0 6
8847: PUSH
8848: LD_INT 2
8850: ARRAY
8851: PUSH
8852: LD_INT 2
8854: ARRAY
8855: PPUSH
8856: CALL_OW 111
8860: GO 8781
8862: POP
8863: POP
// end ; if tanks and mech then
8864: LD_VAR 0 10
8868: PUSH
8869: LD_VAR 0 9
8873: AND
8874: IFFALSE 9479
// begin for i in mech do
8876: LD_ADDR_VAR 0 2
8880: PUSH
8881: LD_VAR 0 9
8885: PUSH
8886: FOR_IN
8887: IFFALSE 9477
// begin tag := GetTag ( i ) ;
8889: LD_ADDR_VAR 0 4
8893: PUSH
8894: LD_VAR 0 2
8898: PPUSH
8899: CALL_OW 110
8903: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8904: LD_ADDR_VAR 0 11
8908: PUSH
8909: LD_VAR 0 2
8913: PPUSH
8914: CALL_OW 310
8918: ST_TO_ADDR
// if not tag then
8919: LD_VAR 0 4
8923: NOT
8924: IFFALSE 9237
// begin if veh then
8926: LD_VAR 0 11
8930: IFFALSE 9079
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
8932: LD_VAR 0 11
8936: PPUSH
8937: CALL_OW 256
8941: PUSH
8942: LD_INT 1000
8944: EQUAL
8945: PUSH
8946: LD_VAR 0 11
8950: PPUSH
8951: CALL_OW 261
8955: PUSH
8956: LD_INT 60
8958: GREATER
8959: AND
8960: IFFALSE 8976
// SetTag ( i , 1 ) else
8962: LD_VAR 0 2
8966: PPUSH
8967: LD_INT 1
8969: PPUSH
8970: CALL_OW 109
8974: GO 9077
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
8976: LD_VAR 0 2
8980: PPUSH
8981: LD_VAR 0 6
8985: PUSH
8986: LD_INT 3
8988: ARRAY
8989: PUSH
8990: LD_INT 1
8992: ARRAY
8993: PPUSH
8994: LD_VAR 0 6
8998: PUSH
8999: LD_INT 3
9001: ARRAY
9002: PUSH
9003: LD_INT 2
9005: ARRAY
9006: PPUSH
9007: CALL_OW 297
9011: PUSH
9012: LD_INT 7
9014: GREATER
9015: IFFALSE 9054
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
9017: LD_VAR 0 2
9021: PPUSH
9022: LD_VAR 0 6
9026: PUSH
9027: LD_INT 3
9029: ARRAY
9030: PUSH
9031: LD_INT 1
9033: ARRAY
9034: PPUSH
9035: LD_VAR 0 6
9039: PUSH
9040: LD_INT 3
9042: ARRAY
9043: PUSH
9044: LD_INT 2
9046: ARRAY
9047: PPUSH
9048: CALL_OW 111
9052: GO 9077
// begin ComExitVehicle ( i ) ;
9054: LD_VAR 0 2
9058: PPUSH
9059: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
9063: LD_VAR 0 2
9067: PPUSH
9068: LD_VAR 0 11
9072: PPUSH
9073: CALL_OW 189
// end ; end else
9077: GO 9235
// if GetLives ( i ) < 700 then
9079: LD_VAR 0 2
9083: PPUSH
9084: CALL_OW 256
9088: PUSH
9089: LD_INT 700
9091: LESS
9092: IFFALSE 9143
// begin usAttackers := usAttackers diff i ;
9094: LD_ADDR_EXP 45
9098: PUSH
9099: LD_EXP 45
9103: PUSH
9104: LD_VAR 0 2
9108: DIFF
9109: ST_TO_ADDR
// usForces := usForces union i ;
9110: LD_ADDR_EXP 42
9114: PUSH
9115: LD_EXP 42
9119: PUSH
9120: LD_VAR 0 2
9124: UNION
9125: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9126: LD_VAR 0 2
9130: PPUSH
9131: LD_INT 34
9133: PPUSH
9134: LD_INT 68
9136: PPUSH
9137: CALL_OW 111
// end else
9141: GO 9235
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9143: LD_VAR 0 10
9147: PPUSH
9148: LD_INT 58
9150: PUSH
9151: EMPTY
9152: LIST
9153: PUSH
9154: LD_INT 24
9156: PUSH
9157: LD_INT 1000
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PUSH
9164: EMPTY
9165: LIST
9166: LIST
9167: PPUSH
9168: CALL_OW 72
9172: PUSH
9173: LD_VAR 0 2
9177: PPUSH
9178: CALL_OW 314
9182: NOT
9183: AND
9184: IFFALSE 9235
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9186: LD_VAR 0 2
9190: PPUSH
9191: LD_VAR 0 10
9195: PPUSH
9196: LD_INT 58
9198: PUSH
9199: EMPTY
9200: LIST
9201: PUSH
9202: LD_INT 24
9204: PUSH
9205: LD_INT 1000
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: PPUSH
9216: CALL_OW 72
9220: PPUSH
9221: LD_VAR 0 2
9225: PPUSH
9226: CALL_OW 74
9230: PPUSH
9231: CALL_OW 120
// end else
9235: GO 9475
// begin if GetLives ( veh ) < 620 then
9237: LD_VAR 0 11
9241: PPUSH
9242: CALL_OW 256
9246: PUSH
9247: LD_INT 620
9249: LESS
9250: IFFALSE 9266
// SetTag ( i , 0 ) else
9252: LD_VAR 0 2
9256: PPUSH
9257: LD_INT 0
9259: PPUSH
9260: CALL_OW 109
9264: GO 9475
// if tag <= attackFormula [ 4 ] then
9266: LD_VAR 0 4
9270: PUSH
9271: LD_VAR 0 6
9275: PUSH
9276: LD_INT 4
9278: ARRAY
9279: LESSEQUAL
9280: IFFALSE 9441
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9282: LD_VAR 0 2
9286: PPUSH
9287: LD_VAR 0 6
9291: PUSH
9292: LD_INT 4
9294: ARRAY
9295: PUSH
9296: LD_VAR 0 4
9300: ARRAY
9301: PUSH
9302: LD_INT 1
9304: ARRAY
9305: PPUSH
9306: LD_VAR 0 6
9310: PUSH
9311: LD_INT 4
9313: ARRAY
9314: PUSH
9315: LD_VAR 0 4
9319: ARRAY
9320: PUSH
9321: LD_INT 2
9323: ARRAY
9324: PPUSH
9325: CALL_OW 297
9329: PUSH
9330: LD_INT 6
9332: GREATER
9333: IFFALSE 9384
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9335: LD_VAR 0 2
9339: PPUSH
9340: LD_VAR 0 6
9344: PUSH
9345: LD_INT 4
9347: ARRAY
9348: PUSH
9349: LD_VAR 0 4
9353: ARRAY
9354: PUSH
9355: LD_INT 1
9357: ARRAY
9358: PPUSH
9359: LD_VAR 0 6
9363: PUSH
9364: LD_INT 4
9366: ARRAY
9367: PUSH
9368: LD_VAR 0 4
9372: ARRAY
9373: PUSH
9374: LD_INT 2
9376: ARRAY
9377: PPUSH
9378: CALL_OW 114
9382: GO 9439
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9384: LD_INT 81
9386: PUSH
9387: LD_INT 1
9389: PUSH
9390: EMPTY
9391: LIST
9392: LIST
9393: PUSH
9394: LD_INT 91
9396: PUSH
9397: LD_VAR 0 2
9401: PUSH
9402: LD_INT 10
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: LIST
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PPUSH
9414: CALL_OW 69
9418: NOT
9419: IFFALSE 9439
// SetTag ( i , tag + 1 ) ;
9421: LD_VAR 0 2
9425: PPUSH
9426: LD_VAR 0 4
9430: PUSH
9431: LD_INT 1
9433: PLUS
9434: PPUSH
9435: CALL_OW 109
// end else
9439: GO 9475
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9441: LD_VAR 0 2
9445: PPUSH
9446: LD_INT 81
9448: PUSH
9449: LD_INT 1
9451: PUSH
9452: EMPTY
9453: LIST
9454: LIST
9455: PPUSH
9456: CALL_OW 69
9460: PPUSH
9461: LD_VAR 0 2
9465: PPUSH
9466: CALL_OW 74
9470: PPUSH
9471: CALL_OW 115
// end ; end ;
9475: GO 8886
9477: POP
9478: POP
// end ; until not usAttackers ;
9479: LD_EXP 45
9483: NOT
9484: IFFALSE 8195
// end ;
9486: LD_VAR 0 1
9490: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do var i ;
9491: LD_INT 22
9493: PUSH
9494: LD_INT 1
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: PUSH
9501: LD_INT 32
9503: PUSH
9504: LD_INT 1
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: PUSH
9511: EMPTY
9512: LIST
9513: LIST
9514: PPUSH
9515: CALL_OW 69
9519: IFFALSE 9596
9521: GO 9523
9523: DISABLE
9524: LD_INT 0
9526: PPUSH
// begin enable ;
9527: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do
9528: LD_ADDR_VAR 0 1
9532: PUSH
9533: LD_INT 22
9535: PUSH
9536: LD_INT 1
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PUSH
9543: LD_INT 32
9545: PUSH
9546: LD_INT 1
9548: PUSH
9549: EMPTY
9550: LIST
9551: LIST
9552: PUSH
9553: EMPTY
9554: LIST
9555: LIST
9556: PPUSH
9557: CALL_OW 69
9561: PUSH
9562: FOR_IN
9563: IFFALSE 9594
// if GetFuel ( i ) < 10 then
9565: LD_VAR 0 1
9569: PPUSH
9570: CALL_OW 261
9574: PUSH
9575: LD_INT 10
9577: LESS
9578: IFFALSE 9592
// SetFuel ( i , 10 ) ;
9580: LD_VAR 0 1
9584: PPUSH
9585: LD_INT 10
9587: PPUSH
9588: CALL_OW 240
9592: GO 9562
9594: POP
9595: POP
// end ; end_of_file
9596: PPOPN 1
9598: END
// export function Action ; var hasAll , i , tmp ; begin
9599: LD_INT 0
9601: PPUSH
9602: PPUSH
9603: PPUSH
9604: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9605: LD_ADDR_VAR 0 2
9609: PUSH
9610: LD_INT 22
9612: PUSH
9613: LD_INT 2
9615: PUSH
9616: EMPTY
9617: LIST
9618: LIST
9619: PUSH
9620: LD_INT 21
9622: PUSH
9623: LD_INT 1
9625: PUSH
9626: EMPTY
9627: LIST
9628: LIST
9629: PUSH
9630: LD_INT 23
9632: PUSH
9633: LD_INT 2
9635: PUSH
9636: EMPTY
9637: LIST
9638: LIST
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: LIST
9644: PPUSH
9645: CALL_OW 69
9649: PUSH
9650: LD_INT 7
9652: GREATEREQUAL
9653: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9654: LD_VAR 0 2
9658: PPUSH
9659: LD_STRING 03_HasAll
9661: PPUSH
9662: CALL_OW 39
// Video ( true ) ;
9666: LD_INT 1
9668: PPUSH
9669: CALL 1020 0 1
// CenterNowOnUnits ( Heike ) ;
9673: LD_EXP 26
9677: PPUSH
9678: CALL_OW 87
// wait ( 0 0$2 ) ;
9682: LD_INT 70
9684: PPUSH
9685: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9689: LD_EXP 34
9693: PPUSH
9694: LD_STRING DF-1-start
9696: PPUSH
9697: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9701: LD_EXP 26
9705: PPUSH
9706: LD_EXP 34
9710: PPUSH
9711: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9715: LD_EXP 26
9719: PPUSH
9720: LD_STRING DH-1-start
9722: PPUSH
9723: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9727: LD_EXP 35
9731: PPUSH
9732: LD_INT 92
9734: PPUSH
9735: LD_INT 21
9737: PPUSH
9738: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9742: LD_EXP 30
9746: PPUSH
9747: LD_INT 94
9749: PPUSH
9750: LD_INT 23
9752: PPUSH
9753: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9757: LD_EXP 38
9761: PUSH
9762: LD_INT 1
9764: ARRAY
9765: PPUSH
9766: LD_INT 90
9768: PPUSH
9769: LD_INT 23
9771: PPUSH
9772: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9776: LD_EXP 38
9780: PUSH
9781: LD_INT 2
9783: ARRAY
9784: PPUSH
9785: LD_INT 93
9787: PPUSH
9788: LD_INT 25
9790: PPUSH
9791: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9795: LD_EXP 38
9799: PPUSH
9800: LD_EXP 35
9804: PPUSH
9805: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9809: LD_EXP 35
9813: PUSH
9814: LD_EXP 30
9818: PUSH
9819: EMPTY
9820: LIST
9821: LIST
9822: PPUSH
9823: LD_EXP 26
9827: PPUSH
9828: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9832: LD_EXP 26
9836: PPUSH
9837: LD_EXP 35
9841: PPUSH
9842: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9846: LD_INT 35
9848: PPUSH
9849: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9853: LD_EXP 35
9857: PPUSH
9858: LD_INT 92
9860: PPUSH
9861: LD_INT 21
9863: PPUSH
9864: CALL_OW 307
9868: IFFALSE 9846
// Say ( Omar , DO-1-start ) ;
9870: LD_EXP 35
9874: PPUSH
9875: LD_STRING DO-1-start
9877: PPUSH
9878: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9882: LD_EXP 26
9886: PPUSH
9887: LD_STRING DH-2-start
9889: PPUSH
9890: CALL_OW 88
// if hasAll then
9894: LD_VAR 0 2
9898: IFFALSE 10026
// begin Say ( Omar , DO-2-start ) ;
9900: LD_EXP 35
9904: PPUSH
9905: LD_STRING DO-2-start
9907: PPUSH
9908: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9912: LD_EXP 35
9916: PPUSH
9917: LD_STRING DO-3-start
9919: PPUSH
9920: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
9924: LD_EXP 26
9928: PPUSH
9929: LD_STRING DH-3-start
9931: PPUSH
9932: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
9936: LD_EXP 34
9940: PPUSH
9941: LD_STRING DF-2-start
9943: PPUSH
9944: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9948: LD_EXP 35
9952: PPUSH
9953: LD_EXP 34
9957: PPUSH
9958: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
9962: LD_EXP 35
9966: PPUSH
9967: LD_STRING DO-4-start
9969: PPUSH
9970: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
9974: LD_EXP 34
9978: PPUSH
9979: LD_STRING DF-3-start
9981: PPUSH
9982: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
9986: LD_EXP 35
9990: PPUSH
9991: LD_STRING DO-5-start
9993: PPUSH
9994: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
9998: LD_EXP 34
10002: PPUSH
10003: LD_STRING DF-4-start
10005: PPUSH
10006: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10010: LD_EXP 35
10014: PPUSH
10015: LD_EXP 26
10019: PPUSH
10020: CALL_OW 119
// end else
10024: GO 10126
// begin Say ( Omar , DO-2-start-a ) ;
10026: LD_EXP 35
10030: PPUSH
10031: LD_STRING DO-2-start-a
10033: PPUSH
10034: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
10038: LD_EXP 35
10042: PPUSH
10043: LD_STRING DO-3-start-a
10045: PPUSH
10046: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
10050: LD_EXP 26
10054: PPUSH
10055: LD_STRING DH-3-start-a
10057: PPUSH
10058: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
10062: LD_EXP 34
10066: PPUSH
10067: LD_STRING DF-2-start-a
10069: PPUSH
10070: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10074: LD_EXP 35
10078: PPUSH
10079: LD_EXP 34
10083: PPUSH
10084: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
10088: LD_EXP 35
10092: PPUSH
10093: LD_STRING DO-4-start-a
10095: PPUSH
10096: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
10100: LD_EXP 34
10104: PPUSH
10105: LD_STRING DF-3-start-a
10107: PPUSH
10108: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10112: LD_EXP 35
10116: PPUSH
10117: LD_EXP 26
10121: PPUSH
10122: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
10126: LD_INT 10
10128: PPUSH
10129: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
10133: LD_EXP 35
10137: PPUSH
10138: LD_STRING DO-1-mission
10140: PPUSH
10141: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
10145: LD_EXP 35
10149: PPUSH
10150: LD_STRING DO-2-mission
10152: PPUSH
10153: CALL_OW 88
// if not hasAll then
10157: LD_VAR 0 2
10161: NOT
10162: IFFALSE 10176
// Say ( Omar , DO-3-mission ) ;
10164: LD_EXP 35
10168: PPUSH
10169: LD_STRING DO-3-mission
10171: PPUSH
10172: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
10176: LD_EXP 35
10180: PPUSH
10181: LD_STRING DO-4-mission
10183: PPUSH
10184: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
10188: LD_EXP 26
10192: PPUSH
10193: LD_STRING DH-1-mission
10195: PPUSH
10196: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10200: LD_EXP 34
10204: PPUSH
10205: LD_STRING DF-1-mission
10207: PPUSH
10208: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10212: LD_EXP 35
10216: PPUSH
10217: LD_STRING DO-5-mission
10219: PPUSH
10220: CALL_OW 88
// if not hasAll then
10224: LD_VAR 0 2
10228: NOT
10229: IFFALSE 10364
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10231: LD_ADDR_VAR 0 4
10235: PUSH
10236: LD_INT 22
10238: PUSH
10239: LD_INT 2
10241: PUSH
10242: EMPTY
10243: LIST
10244: LIST
10245: PUSH
10246: LD_INT 21
10248: PUSH
10249: LD_INT 1
10251: PUSH
10252: EMPTY
10253: LIST
10254: LIST
10255: PUSH
10256: LD_INT 23
10258: PUSH
10259: LD_INT 2
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: EMPTY
10267: LIST
10268: LIST
10269: LIST
10270: PPUSH
10271: CALL_OW 69
10275: ST_TO_ADDR
// for i := 7 downto tmp do
10276: LD_ADDR_VAR 0 3
10280: PUSH
10281: DOUBLE
10282: LD_INT 7
10284: INC
10285: ST_TO_ADDR
10286: LD_VAR 0 4
10290: PUSH
10291: FOR_DOWNTO
10292: IFFALSE 10362
// begin if omarSquad < 3 then
10294: LD_EXP 38
10298: PUSH
10299: LD_INT 3
10301: LESS
10302: IFFALSE 10306
// break ;
10304: GO 10362
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10306: LD_EXP 38
10310: PUSH
10311: LD_INT 3
10313: ARRAY
10314: PPUSH
10315: LD_INT 2
10317: PPUSH
10318: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10322: LD_ADDR_EXP 40
10326: PUSH
10327: LD_EXP 40
10331: PUSH
10332: LD_EXP 38
10336: PUSH
10337: LD_INT 3
10339: ARRAY
10340: UNION
10341: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10342: LD_ADDR_EXP 38
10346: PUSH
10347: LD_EXP 38
10351: PPUSH
10352: LD_INT 3
10354: PPUSH
10355: CALL_OW 3
10359: ST_TO_ADDR
// end ;
10360: GO 10291
10362: POP
10363: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10364: LD_EXP 35
10368: PUSH
10369: LD_EXP 38
10373: ADD
10374: PPUSH
10375: LD_INT 103
10377: PPUSH
10378: LD_INT 9
10380: PPUSH
10381: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10385: LD_VAR 0 2
10389: PUSH
10390: LD_EXP 31
10394: PPUSH
10395: CALL_OW 302
10399: AND
10400: IFFALSE 10461
// begin wait ( 0 0$3 ) ;
10402: LD_INT 105
10404: PPUSH
10405: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10409: LD_EXP 31
10413: PPUSH
10414: LD_EXP 34
10418: PPUSH
10419: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10423: LD_EXP 31
10427: PPUSH
10428: LD_STRING DK-1-side
10430: PPUSH
10431: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10435: LD_EXP 34
10439: PPUSH
10440: LD_EXP 31
10444: PPUSH
10445: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10449: LD_EXP 34
10453: PPUSH
10454: LD_STRING DF-1-side
10456: PPUSH
10457: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10461: LD_INT 22
10463: PUSH
10464: LD_INT 2
10466: PUSH
10467: EMPTY
10468: LIST
10469: LIST
10470: PPUSH
10471: CALL_OW 69
10475: PPUSH
10476: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10480: LD_EXP 34
10484: PUSH
10485: LD_EXP 37
10489: ADD
10490: PPUSH
10491: LD_INT 108
10493: PPUSH
10494: LD_INT 62
10496: PPUSH
10497: CALL_OW 111
// gameStarted := true ;
10501: LD_ADDR_EXP 3
10505: PUSH
10506: LD_INT 1
10508: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10509: LD_INT 105
10511: PPUSH
10512: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10516: LD_EXP 26
10520: PPUSH
10521: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10525: LD_EXP 26
10529: PPUSH
10530: LD_EXP 30
10534: PPUSH
10535: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10539: LD_INT 22
10541: PUSH
10542: LD_INT 2
10544: PUSH
10545: EMPTY
10546: LIST
10547: LIST
10548: PPUSH
10549: CALL_OW 69
10553: PUSH
10554: LD_EXP 26
10558: DIFF
10559: PPUSH
10560: LD_EXP 26
10564: PPUSH
10565: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10569: LD_EXP 26
10573: PPUSH
10574: LD_STRING DH-1-explore
10576: PPUSH
10577: CALL_OW 88
// if Givi then
10581: LD_EXP 27
10585: IFFALSE 10601
// Say ( Givi , DG-1-explore ) else
10587: LD_EXP 27
10591: PPUSH
10592: LD_STRING DG-1-explore
10594: PPUSH
10595: CALL_OW 88
10599: GO 10638
// if heikeSecondSquad then
10601: LD_EXP 40
10605: IFFALSE 10638
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10607: LD_EXP 40
10611: PPUSH
10612: LD_INT 26
10614: PUSH
10615: LD_INT 1
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: PPUSH
10622: CALL_OW 72
10626: PUSH
10627: LD_INT 1
10629: ARRAY
10630: PPUSH
10631: LD_STRING DArm-1-explore
10633: PPUSH
10634: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10638: LD_EXP 30
10642: PPUSH
10643: LD_STRING DA-1-explore
10645: PPUSH
10646: CALL_OW 88
// if Sophia then
10650: LD_EXP 32
10654: IFFALSE 10732
// begin Say ( Sophia , DS-2-explore ) ;
10656: LD_EXP 32
10660: PPUSH
10661: LD_STRING DS-2-explore
10663: PPUSH
10664: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10668: LD_EXP 30
10672: PPUSH
10673: LD_STRING DA-2-explore
10675: PPUSH
10676: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10680: LD_EXP 32
10684: PPUSH
10685: LD_EXP 30
10689: PPUSH
10690: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10694: LD_EXP 30
10698: PPUSH
10699: LD_EXP 32
10703: PPUSH
10704: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10708: LD_EXP 32
10712: PPUSH
10713: LD_STRING DS-3-explore
10715: PPUSH
10716: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10720: LD_EXP 30
10724: PPUSH
10725: LD_STRING DA-3-explore
10727: PPUSH
10728: CALL_OW 88
// end ; if Mike then
10732: LD_EXP 28
10736: IFFALSE 10792
// begin Say ( Mike , DM-1-explore ) ;
10738: LD_EXP 28
10742: PPUSH
10743: LD_STRING DM-1-explore
10745: PPUSH
10746: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10750: LD_EXP 26
10754: PPUSH
10755: LD_STRING DH-2-explore
10757: PPUSH
10758: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10762: LD_EXP 28
10766: PPUSH
10767: LD_STRING DM-2-explore
10769: PPUSH
10770: CALL_OW 88
// if Kaia then
10774: LD_EXP 31
10778: IFFALSE 10792
// Say ( Kaia , DK-1-explore ) ;
10780: LD_EXP 31
10784: PPUSH
10785: LD_STRING DK-1-explore
10787: PPUSH
10788: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10792: LD_INT 22
10794: PUSH
10795: LD_INT 2
10797: PUSH
10798: EMPTY
10799: LIST
10800: LIST
10801: PPUSH
10802: CALL_OW 69
10806: PPUSH
10807: CALL_OW 139
// Video ( false ) ;
10811: LD_INT 0
10813: PPUSH
10814: CALL 1020 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10818: LD_STRING BuildBase
10820: PPUSH
10821: CALL_OW 337
// SaveForQuickRestart ;
10825: CALL_OW 22
// end ;
10829: LD_VAR 0 1
10833: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10834: LD_EXP 5
10838: NOT
10839: PUSH
10840: LD_EXP 6
10844: NOT
10845: AND
10846: PUSH
10847: LD_INT 5
10849: PPUSH
10850: LD_INT 22
10852: PUSH
10853: LD_INT 2
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: PPUSH
10860: CALL_OW 70
10864: AND
10865: PUSH
10866: LD_EXP 6
10870: NOT
10871: AND
10872: IFFALSE 10957
10874: GO 10876
10876: DISABLE
// begin if Mike then
10877: LD_EXP 28
10881: IFFALSE 10897
// Say ( Mike , DM-1-scout ) else
10883: LD_EXP 28
10887: PPUSH
10888: LD_STRING DM-1-scout
10890: PPUSH
10891: CALL_OW 88
10895: GO 10928
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10897: LD_EXP 40
10901: PPUSH
10902: LD_INT 26
10904: PUSH
10905: LD_INT 1
10907: PUSH
10908: EMPTY
10909: LIST
10910: LIST
10911: PPUSH
10912: CALL_OW 72
10916: PUSH
10917: LD_INT 1
10919: ARRAY
10920: PPUSH
10921: LD_STRING DArm-1-explore
10923: PPUSH
10924: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
10928: LD_INT 54
10930: PPUSH
10931: LD_INT 35
10933: PPUSH
10934: LD_INT 2
10936: PPUSH
10937: LD_INT 1
10939: PPUSH
10940: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
10944: LD_INT 54
10946: PPUSH
10947: LD_INT 35
10949: PPUSH
10950: LD_INT 2
10952: PPUSH
10953: CALL_OW 331
// end ;
10957: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
10958: LD_INT 6
10960: PPUSH
10961: LD_INT 22
10963: PUSH
10964: LD_INT 2
10966: PUSH
10967: EMPTY
10968: LIST
10969: LIST
10970: PPUSH
10971: CALL_OW 70
10975: PUSH
10976: LD_EXP 6
10980: NOT
10981: AND
10982: IFFALSE 11236
10984: GO 10986
10986: DISABLE
10987: LD_INT 0
10989: PPUSH
10990: PPUSH
10991: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
10992: LD_ADDR_VAR 0 1
10996: PUSH
10997: LD_EXP 40
11001: PPUSH
11002: LD_INT 26
11004: PUSH
11005: LD_INT 1
11007: PUSH
11008: EMPTY
11009: LIST
11010: LIST
11011: PPUSH
11012: CALL_OW 72
11016: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
11017: LD_ADDR_VAR 0 2
11021: PUSH
11022: LD_EXP 40
11026: PPUSH
11027: LD_INT 26
11029: PUSH
11030: LD_INT 2
11032: PUSH
11033: EMPTY
11034: LIST
11035: LIST
11036: PPUSH
11037: CALL_OW 72
11041: ST_TO_ADDR
// DialogueOn ;
11042: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
11046: LD_INT 36
11048: PPUSH
11049: LD_INT 22
11051: PPUSH
11052: LD_INT 2
11054: PPUSH
11055: LD_INT 8
11057: PPUSH
11058: CALL_OW 330
// dwait ( 0 0$1 ) ;
11062: LD_INT 35
11064: PPUSH
11065: CALL_OW 68
// speakerOk := false ;
11069: LD_ADDR_VAR 0 3
11073: PUSH
11074: LD_INT 0
11076: ST_TO_ADDR
// if Mike then
11077: LD_EXP 28
11081: IFFALSE 11103
// speakerOk := Say ( Mike , DM-1-spot ) else
11083: LD_ADDR_VAR 0 3
11087: PUSH
11088: LD_EXP 28
11092: PPUSH
11093: LD_STRING DM-1-spot
11095: PPUSH
11096: CALL_OW 88
11100: ST_TO_ADDR
11101: GO 11131
// if randomMen then
11103: LD_VAR 0 1
11107: IFFALSE 11131
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11109: LD_ADDR_VAR 0 3
11113: PUSH
11114: LD_VAR 0 1
11118: PUSH
11119: LD_INT 1
11121: ARRAY
11122: PPUSH
11123: LD_STRING DArm-1-spot-a
11125: PPUSH
11126: CALL_OW 88
11130: ST_TO_ADDR
// if speakerOk then
11131: LD_VAR 0 3
11135: IFFALSE 11179
// begin if Givi then
11137: LD_EXP 27
11141: IFFALSE 11157
// Say ( Givi , DG-1-spot ) else
11143: LD_EXP 27
11147: PPUSH
11148: LD_STRING DG-1-spot
11150: PPUSH
11151: CALL_OW 88
11155: GO 11179
// if randomWomen then
11157: LD_VAR 0 2
11161: IFFALSE 11179
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
11163: LD_VAR 0 2
11167: PUSH
11168: LD_INT 1
11170: ARRAY
11171: PPUSH
11172: LD_STRING DArf-1-spot-a
11174: PPUSH
11175: CALL_OW 88
// end ; if Mike then
11179: LD_EXP 28
11183: IFFALSE 11199
// Say ( Heike , DH-1-spot ) else
11185: LD_EXP 26
11189: PPUSH
11190: LD_STRING DH-1-spot
11192: PPUSH
11193: CALL_OW 88
11197: GO 11211
// Say ( Heike , DH-1-spot-a ) ;
11199: LD_EXP 26
11203: PPUSH
11204: LD_STRING DH-1-spot-a
11206: PPUSH
11207: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11211: LD_INT 36
11213: PPUSH
11214: LD_INT 22
11216: PPUSH
11217: LD_INT 2
11219: PPUSH
11220: CALL_OW 331
// DialogueOff ;
11224: CALL_OW 7
// americanBaseSpoted := true ;
11228: LD_ADDR_EXP 5
11232: PUSH
11233: LD_INT 1
11235: ST_TO_ADDR
// end ;
11236: PPOPN 3
11238: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11239: LD_EXP 5
11243: NOT
11244: PUSH
11245: LD_INT 22
11247: PUSH
11248: LD_INT 2
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PUSH
11255: LD_INT 101
11257: PUSH
11258: LD_INT 1
11260: PUSH
11261: EMPTY
11262: LIST
11263: LIST
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: PPUSH
11269: CALL_OW 69
11273: AND
11274: PUSH
11275: LD_EXP 6
11279: NOT
11280: AND
11281: IFFALSE 11367
11283: GO 11285
11285: DISABLE
11286: LD_INT 0
11288: PPUSH
// begin americanBaseSpoted := true ;
11289: LD_ADDR_EXP 5
11293: PUSH
11294: LD_INT 1
11296: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11297: LD_ADDR_VAR 0 1
11301: PUSH
11302: LD_EXP 40
11306: PPUSH
11307: LD_INT 26
11309: PUSH
11310: LD_INT 1
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: PPUSH
11317: CALL_OW 72
11321: ST_TO_ADDR
// if not randomMen then
11322: LD_VAR 0 1
11326: NOT
11327: IFFALSE 11331
// exit ;
11329: GO 11367
// DialogueOn ;
11331: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11335: LD_VAR 0 1
11339: PUSH
11340: LD_INT 1
11342: ARRAY
11343: PPUSH
11344: LD_STRING DArm-1-spot-a
11346: PPUSH
11347: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11351: LD_EXP 26
11355: PPUSH
11356: LD_STRING DH-1-spot-a
11358: PPUSH
11359: CALL_OW 88
// DialogueOff ;
11363: CALL_OW 7
// end ;
11367: PPOPN 1
11369: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or usForces <= 4 do var i , p ;
11370: LD_INT 11
11372: PPUSH
11373: CALL_OW 255
11377: PUSH
11378: LD_INT 2
11380: EQUAL
11381: PUSH
11382: LD_INT 7
11384: PPUSH
11385: LD_INT 22
11387: PUSH
11388: LD_INT 1
11390: PUSH
11391: EMPTY
11392: LIST
11393: LIST
11394: PUSH
11395: LD_INT 3
11397: PUSH
11398: LD_INT 50
11400: PUSH
11401: EMPTY
11402: LIST
11403: PUSH
11404: EMPTY
11405: LIST
11406: LIST
11407: PUSH
11408: LD_INT 30
11410: PUSH
11411: LD_INT 31
11413: PUSH
11414: EMPTY
11415: LIST
11416: LIST
11417: PUSH
11418: EMPTY
11419: LIST
11420: LIST
11421: LIST
11422: PPUSH
11423: CALL_OW 70
11427: OR
11428: PUSH
11429: LD_INT 7
11431: PPUSH
11432: LD_INT 22
11434: PUSH
11435: LD_INT 2
11437: PUSH
11438: EMPTY
11439: LIST
11440: LIST
11441: PPUSH
11442: CALL_OW 70
11446: PUSH
11447: LD_INT 1
11449: GREATER
11450: OR
11451: PUSH
11452: LD_EXP 42
11456: PUSH
11457: LD_INT 4
11459: LESSEQUAL
11460: OR
11461: IFFALSE 11985
11463: GO 11465
11465: DISABLE
11466: LD_INT 0
11468: PPUSH
11469: PPUSH
// begin wait ( 0 0$3 ) ;
11470: LD_INT 105
11472: PPUSH
11473: CALL_OW 67
// if IsOk ( usCommander ) then
11477: LD_EXP 43
11481: PPUSH
11482: CALL_OW 302
11486: IFFALSE 11516
// begin usForces := usForces union usCommander ;
11488: LD_ADDR_EXP 42
11492: PUSH
11493: LD_EXP 42
11497: PUSH
11498: LD_EXP 43
11502: UNION
11503: ST_TO_ADDR
// Say ( usCommander , DUsm-1-assault ) ;
11504: LD_EXP 43
11508: PPUSH
11509: LD_STRING DUsm-1-assault
11511: PPUSH
11512: CALL_OW 88
// end ; for i in usForces do
11516: LD_ADDR_VAR 0 1
11520: PUSH
11521: LD_EXP 42
11525: PUSH
11526: FOR_IN
11527: IFFALSE 11573
// begin if IsInUnit ( i ) then
11529: LD_VAR 0 1
11533: PPUSH
11534: CALL_OW 310
11538: IFFALSE 11549
// ComExitBuilding ( i ) ;
11540: LD_VAR 0 1
11544: PPUSH
11545: CALL_OW 122
// wait ( 3 ) ;
11549: LD_INT 3
11551: PPUSH
11552: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11556: LD_VAR 0 1
11560: PPUSH
11561: LD_INT 34
11563: PPUSH
11564: LD_INT 67
11566: PPUSH
11567: CALL_OW 111
// end ;
11571: GO 11526
11573: POP
11574: POP
// Say ( Heike , DH-1-assault ) ;
11575: LD_EXP 26
11579: PPUSH
11580: LD_STRING DH-1-assault
11582: PPUSH
11583: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11587: LD_INT 35
11589: PPUSH
11590: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11594: LD_VAR 0 1
11598: PPUSH
11599: LD_INT 34
11601: PPUSH
11602: LD_INT 67
11604: PPUSH
11605: CALL_OW 111
// until not usForces ;
11609: LD_EXP 42
11613: NOT
11614: IFFALSE 11587
// music_nat := 2 ;
11616: LD_ADDR_OWVAR 71
11620: PUSH
11621: LD_INT 2
11623: ST_TO_ADDR
// music_class := music_victory ;
11624: LD_ADDR_OWVAR 72
11628: PUSH
11629: LD_INT 4
11631: ST_TO_ADDR
// if not americanHasEscaped then
11632: LD_EXP 7
11636: NOT
11637: IFFALSE 11658
// begin Say ( Heike , DH-2-assault ) ;
11639: LD_EXP 26
11643: PPUSH
11644: LD_STRING DH-2-assault
11646: PPUSH
11647: CALL_OW 88
// SetAchievement ( ACH_CLEAN ) ;
11651: LD_STRING ACH_CLEAN
11653: PPUSH
11654: CALL_OW 543
// end ; wait ( 0 0$2 ) ;
11658: LD_INT 70
11660: PPUSH
11661: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11665: LD_INT 35
11667: PPUSH
11668: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11672: LD_INT 22
11674: PUSH
11675: LD_INT 2
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: PUSH
11682: LD_INT 21
11684: PUSH
11685: LD_INT 1
11687: PUSH
11688: EMPTY
11689: LIST
11690: LIST
11691: PUSH
11692: LD_INT 3
11694: PUSH
11695: LD_INT 50
11697: PUSH
11698: EMPTY
11699: LIST
11700: PUSH
11701: EMPTY
11702: LIST
11703: LIST
11704: PUSH
11705: EMPTY
11706: LIST
11707: LIST
11708: LIST
11709: PPUSH
11710: CALL_OW 69
11714: NOT
11715: IFFALSE 11665
// Video ( true ) ;
11717: LD_INT 1
11719: PPUSH
11720: CALL 1020 0 1
// if not GetSide ( usDepot ) = 2 then
11724: LD_INT 11
11726: PPUSH
11727: CALL_OW 255
11731: PUSH
11732: LD_INT 2
11734: EQUAL
11735: NOT
11736: IFFALSE 11748
// SetSide ( usDepot , 2 ) ;
11738: LD_INT 11
11740: PPUSH
11741: LD_INT 2
11743: PPUSH
11744: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11748: LD_INT 35
11750: PPUSH
11751: LD_INT 22
11753: PPUSH
11754: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11758: LD_EXP 26
11762: PPUSH
11763: LD_INT 35
11765: PPUSH
11766: LD_INT 22
11768: PPUSH
11769: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11773: LD_EXP 26
11777: PPUSH
11778: LD_INT 38
11780: PPUSH
11781: LD_INT 25
11783: PPUSH
11784: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11788: LD_EXP 39
11792: PUSH
11793: LD_EXP 40
11797: UNION
11798: PPUSH
11799: LD_INT 39
11801: PPUSH
11802: LD_INT 26
11804: PPUSH
11805: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11809: LD_EXP 39
11813: PUSH
11814: LD_EXP 40
11818: UNION
11819: PPUSH
11820: LD_EXP 26
11824: PPUSH
11825: CALL_OW 179
// p := 0 ;
11829: LD_ADDR_VAR 0 2
11833: PUSH
11834: LD_INT 0
11836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11837: LD_INT 35
11839: PPUSH
11840: CALL_OW 67
// p := p + 1 ;
11844: LD_ADDR_VAR 0 2
11848: PUSH
11849: LD_VAR 0 2
11853: PUSH
11854: LD_INT 1
11856: PLUS
11857: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11858: LD_EXP 26
11862: PPUSH
11863: CALL_OW 314
11867: NOT
11868: PUSH
11869: LD_VAR 0 2
11873: PUSH
11874: LD_INT 10
11876: GREATER
11877: OR
11878: IFFALSE 11837
// Say ( Heike , DH-1-capture ) ;
11880: LD_EXP 26
11884: PPUSH
11885: LD_STRING DH-1-capture
11887: PPUSH
11888: CALL_OW 88
// if Markov then
11892: LD_EXP 33
11896: IFFALSE 11910
// Say ( Markov , DMar-1-capture ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_STRING DMar-1-capture
11905: PPUSH
11906: CALL_OW 88
// if Sophia then
11910: LD_EXP 32
11914: IFFALSE 11940
// begin Say ( Heike , DH-2-capture ) ;
11916: LD_EXP 26
11920: PPUSH
11921: LD_STRING DH-2-capture
11923: PPUSH
11924: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
11928: LD_EXP 32
11932: PPUSH
11933: LD_STRING DS-1-capture
11935: PPUSH
11936: CALL_OW 88
// end ; Video ( false ) ;
11940: LD_INT 0
11942: PPUSH
11943: CALL 1020 0 1
// music_nat := music_auto ;
11947: LD_ADDR_OWVAR 71
11951: PUSH
11952: LD_INT 0
11954: ST_TO_ADDR
// music_class := music_auto ;
11955: LD_ADDR_OWVAR 72
11959: PUSH
11960: LD_INT 0
11962: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
11963: LD_STRING ConstructBase
11965: PPUSH
11966: CALL_OW 337
// wait ( 0 0$3 ) ;
11970: LD_INT 105
11972: PPUSH
11973: CALL_OW 67
// americanBaseCaptured := true ;
11977: LD_ADDR_EXP 6
11981: PUSH
11982: LD_INT 1
11984: ST_TO_ADDR
// end ;
11985: PPOPN 2
11987: END
// every 0 0$1 trigger capturedCargoCounter >= 3 do
11988: LD_EXP 12
11992: PUSH
11993: LD_INT 3
11995: GREATEREQUAL
11996: IFFALSE 12008
11998: GO 12000
12000: DISABLE
// SetAchievement ( ACH_ENG ) ;
12001: LD_STRING ACH_ENG
12003: PPUSH
12004: CALL_OW 543
12008: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) >= 4 do
12009: LD_INT 22
12011: PUSH
12012: LD_INT 2
12014: PUSH
12015: EMPTY
12016: LIST
12017: LIST
12018: PUSH
12019: LD_INT 25
12021: PUSH
12022: LD_INT 15
12024: PUSH
12025: EMPTY
12026: LIST
12027: LIST
12028: PUSH
12029: EMPTY
12030: LIST
12031: LIST
12032: PPUSH
12033: CALL_OW 69
12037: PUSH
12038: LD_INT 4
12040: GREATEREQUAL
12041: IFFALSE 12053
12043: GO 12045
12045: DISABLE
// SetAchievement ( ACH_APEGEN ) ;
12046: LD_STRING ACH_APEGEN
12048: PPUSH
12049: CALL_OW 543
12053: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
12054: LD_INT 22
12056: PUSH
12057: LD_INT 2
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: LD_INT 30
12066: PUSH
12067: LD_INT 2
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: LD_INT 3
12076: PUSH
12077: LD_INT 57
12079: PUSH
12080: EMPTY
12081: LIST
12082: PUSH
12083: EMPTY
12084: LIST
12085: LIST
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: LIST
12091: PPUSH
12092: CALL_OW 69
12096: IFFALSE 12339
12098: GO 12100
12100: DISABLE
// begin workshopBuilded := true ;
12101: LD_ADDR_EXP 9
12105: PUSH
12106: LD_INT 1
12108: ST_TO_ADDR
// if IsOk ( Markov ) then
12109: LD_EXP 33
12113: PPUSH
12114: CALL_OW 302
12118: IFFALSE 12177
// begin Say ( Heike , DH-1-shop-a ) ;
12120: LD_EXP 26
12124: PPUSH
12125: LD_STRING DH-1-shop-a
12127: PPUSH
12128: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
12132: LD_INT 47
12134: PPUSH
12135: LD_INT 2
12137: PPUSH
12138: CALL_OW 321
12142: PUSH
12143: LD_INT 2
12145: EQUAL
12146: PUSH
12147: LD_INT 45
12149: PPUSH
12150: LD_INT 2
12152: PPUSH
12153: CALL_OW 321
12157: PUSH
12158: LD_INT 2
12160: EQUAL
12161: AND
12162: NOT
12163: IFFALSE 12177
// Say ( Markov , DMar-1-shop-a ) ;
12165: LD_EXP 33
12169: PPUSH
12170: LD_STRING DMar-1-shop-a
12172: PPUSH
12173: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
12177: LD_INT 35
12179: PPUSH
12180: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched or GetTech ( tech_SolEng , 2 ) = state_researched ;
12184: LD_INT 47
12186: PPUSH
12187: LD_INT 2
12189: PPUSH
12190: CALL_OW 321
12194: PUSH
12195: LD_INT 2
12197: EQUAL
12198: PUSH
12199: LD_INT 45
12201: PPUSH
12202: LD_INT 2
12204: PPUSH
12205: CALL_OW 321
12209: PUSH
12210: LD_INT 2
12212: EQUAL
12213: OR
12214: IFFALSE 12177
// DialogueOn ;
12216: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
12220: LD_EXP 33
12224: PPUSH
12225: LD_STRING DMar-1-shop
12227: PPUSH
12228: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
12232: LD_EXP 26
12236: PPUSH
12237: LD_STRING DH-1-shop
12239: PPUSH
12240: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12244: LD_EXP 33
12248: PPUSH
12249: LD_STRING DMar-2-shop
12251: PPUSH
12252: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12256: LD_EXP 33
12260: PPUSH
12261: LD_STRING DMar-3-shop
12263: PPUSH
12264: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12268: LD_EXP 26
12272: PPUSH
12273: LD_STRING DH-2-shop
12275: PPUSH
12276: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12280: LD_EXP 33
12284: PPUSH
12285: LD_STRING DMar-4-shop
12287: PPUSH
12288: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12292: LD_EXP 26
12296: PPUSH
12297: LD_STRING DH-3-shop
12299: PPUSH
12300: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12304: LD_EXP 33
12308: PPUSH
12309: LD_STRING DMar-5-shop
12311: PPUSH
12312: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12316: LD_EXP 26
12320: PPUSH
12321: LD_STRING DH-4-shop
12323: PPUSH
12324: CALL_OW 88
// DialogueOff ;
12328: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12332: LD_STRING ConstructVeh
12334: PPUSH
12335: CALL_OW 337
// end ;
12339: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12340: LD_INT 2
12342: PPUSH
12343: LD_INT 2
12345: PPUSH
12346: LD_INT 1
12348: PPUSH
12349: CALL 1191 0 3
12353: PUSH
12354: LD_INT 0
12356: EQUAL
12357: IFFALSE 12369
12359: GO 12361
12361: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12362: LD_STRING Techs
12364: PPUSH
12365: CALL_OW 337
12369: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12370: LD_EXP 33
12374: PPUSH
12375: CALL_OW 302
12379: PUSH
12380: LD_INT 22
12382: PUSH
12383: LD_INT 2
12385: PUSH
12386: EMPTY
12387: LIST
12388: LIST
12389: PUSH
12390: LD_INT 2
12392: PUSH
12393: LD_INT 34
12395: PUSH
12396: LD_INT 22
12398: PUSH
12399: EMPTY
12400: LIST
12401: LIST
12402: PUSH
12403: LD_INT 35
12405: PUSH
12406: LD_INT 22
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: PUSH
12413: EMPTY
12414: LIST
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PPUSH
12422: CALL_OW 69
12426: AND
12427: IFFALSE 12534
12429: GO 12431
12431: DISABLE
// begin DialogueOn ;
12432: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12436: LD_INT 22
12438: PUSH
12439: LD_INT 2
12441: PUSH
12442: EMPTY
12443: LIST
12444: LIST
12445: PUSH
12446: LD_INT 2
12448: PUSH
12449: LD_INT 34
12451: PUSH
12452: LD_INT 22
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: PUSH
12459: LD_INT 35
12461: PUSH
12462: LD_INT 22
12464: PUSH
12465: EMPTY
12466: LIST
12467: LIST
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: LIST
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: PPUSH
12478: CALL_OW 69
12482: PPUSH
12483: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12487: LD_INT 10
12489: PPUSH
12490: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12494: LD_EXP 26
12498: PPUSH
12499: LD_STRING DH-1-bal
12501: PPUSH
12502: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12506: LD_EXP 33
12510: PPUSH
12511: LD_STRING DMar-1-bal
12513: PPUSH
12514: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12518: LD_EXP 26
12522: PPUSH
12523: LD_STRING DH-2-bal
12525: PPUSH
12526: CALL_OW 88
// DialogueOff ;
12530: CALL_OW 7
// end ;
12534: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12535: LD_EXP 30
12539: PPUSH
12540: CALL_OW 302
12544: PUSH
12545: LD_INT 22
12547: PUSH
12548: LD_INT 2
12550: PUSH
12551: EMPTY
12552: LIST
12553: LIST
12554: PUSH
12555: LD_INT 30
12557: PUSH
12558: LD_INT 6
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PPUSH
12569: CALL_OW 69
12573: AND
12574: IFFALSE 12635
12576: GO 12578
12578: DISABLE
// begin DialogueOn ;
12579: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12583: LD_EXP 30
12587: PPUSH
12588: LD_STRING DA-1-lab
12590: PPUSH
12591: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12595: LD_EXP 26
12599: PPUSH
12600: LD_STRING DH-1-lab
12602: PPUSH
12603: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12607: LD_EXP 30
12611: PPUSH
12612: LD_STRING DA-2-lab
12614: PPUSH
12615: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12619: LD_EXP 26
12623: PPUSH
12624: LD_STRING DH-2-lab
12626: PPUSH
12627: CALL_OW 88
// DialogueOff ;
12631: CALL_OW 7
// end ;
12635: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12636: LD_EXP 31
12640: PPUSH
12641: CALL_OW 302
12645: PUSH
12646: LD_INT 22
12648: PUSH
12649: LD_INT 2
12651: PUSH
12652: EMPTY
12653: LIST
12654: LIST
12655: PUSH
12656: LD_INT 25
12658: PUSH
12659: LD_INT 15
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: PPUSH
12670: CALL_OW 69
12674: AND
12675: PUSH
12676: LD_INT 81
12678: PUSH
12679: LD_INT 2
12681: PUSH
12682: EMPTY
12683: LIST
12684: LIST
12685: PPUSH
12686: CALL_OW 69
12690: NOT
12691: AND
12692: IFFALSE 12866
12694: GO 12696
12696: DISABLE
12697: LD_INT 0
12699: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12700: LD_ADDR_VAR 0 1
12704: PUSH
12705: LD_INT 22
12707: PUSH
12708: LD_INT 2
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PUSH
12715: LD_INT 25
12717: PUSH
12718: LD_INT 15
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: EMPTY
12726: LIST
12727: LIST
12728: PPUSH
12729: CALL_OW 69
12733: ST_TO_ADDR
// InGameOn ;
12734: CALL_OW 8
// CenterNowOnUnits ( ape [ 1 ] ) ;
12738: LD_VAR 0 1
12742: PUSH
12743: LD_INT 1
12745: ARRAY
12746: PPUSH
12747: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12751: LD_VAR 0 1
12755: PUSH
12756: LD_INT 1
12758: ARRAY
12759: PPUSH
12760: CALL_OW 122
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12764: LD_VAR 0 1
12768: PUSH
12769: LD_INT 1
12771: ARRAY
12772: PPUSH
12773: LD_INT 35
12775: PPUSH
12776: LD_INT 28
12778: PPUSH
12779: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12783: LD_VAR 0 1
12787: PUSH
12788: LD_INT 1
12790: ARRAY
12791: PPUSH
12792: LD_INT 36
12794: PPUSH
12795: LD_INT 17
12797: PPUSH
12798: CALL_OW 171
// Say ( Kaia , DK-1-apesol ) ;
12802: LD_EXP 31
12806: PPUSH
12807: LD_STRING DK-1-apesol
12809: PPUSH
12810: CALL_OW 88
// Say ( Aviradze , DA-1-apesol ) ;
12814: LD_EXP 30
12818: PPUSH
12819: LD_STRING DA-1-apesol
12821: PPUSH
12822: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12826: LD_EXP 31
12830: PPUSH
12831: LD_STRING DK-2-apesol
12833: PPUSH
12834: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12838: LD_EXP 30
12842: PPUSH
12843: LD_STRING DA-2-apesol
12845: PPUSH
12846: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12850: LD_EXP 31
12854: PPUSH
12855: LD_STRING DK-3-apesol
12857: PPUSH
12858: CALL_OW 88
// InGameOff ;
12862: CALL_OW 9
// end ;
12866: PPOPN 1
12868: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12869: LD_EXP 32
12873: PPUSH
12874: CALL_OW 302
12878: PUSH
12879: LD_INT 22
12881: PUSH
12882: LD_INT 2
12884: PUSH
12885: EMPTY
12886: LIST
12887: LIST
12888: PUSH
12889: LD_INT 25
12891: PUSH
12892: LD_INT 16
12894: PUSH
12895: EMPTY
12896: LIST
12897: LIST
12898: PUSH
12899: EMPTY
12900: LIST
12901: LIST
12902: PPUSH
12903: CALL_OW 69
12907: AND
12908: PUSH
12909: LD_INT 81
12911: PUSH
12912: LD_INT 2
12914: PUSH
12915: EMPTY
12916: LIST
12917: LIST
12918: PPUSH
12919: CALL_OW 69
12923: NOT
12924: AND
12925: IFFALSE 13188
12927: GO 12929
12929: DISABLE
12930: LD_INT 0
12932: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
12933: LD_ADDR_VAR 0 1
12937: PUSH
12938: LD_INT 22
12940: PUSH
12941: LD_INT 2
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PUSH
12948: LD_INT 25
12950: PUSH
12951: LD_INT 16
12953: PUSH
12954: EMPTY
12955: LIST
12956: LIST
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: PPUSH
12962: CALL_OW 69
12966: ST_TO_ADDR
// InGameOn ;
12967: CALL_OW 8
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
12971: LD_INT 5
12973: PPUSH
12974: LD_INT 35
12976: PPUSH
12977: LD_INT 22
12979: PPUSH
12980: LD_INT 1
12982: PPUSH
12983: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
12987: LD_EXP 32
12991: PPUSH
12992: LD_VAR 0 1
12996: PUSH
12997: LD_INT 1
12999: ARRAY
13000: PPUSH
13001: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
13005: LD_VAR 0 1
13009: PUSH
13010: LD_INT 1
13012: ARRAY
13013: PPUSH
13014: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
13018: LD_VAR 0 1
13022: PUSH
13023: LD_INT 1
13025: ARRAY
13026: PPUSH
13027: CALL_OW 122
// wait ( 0 0$2 ) ;
13031: LD_INT 70
13033: PPUSH
13034: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
13038: LD_EXP 32
13042: PPUSH
13043: LD_STRING DS-1-apeeng
13045: PPUSH
13046: CALL_OW 88
// if IsOk ( Kamil ) then
13050: LD_EXP 29
13054: PPUSH
13055: CALL_OW 302
13059: IFFALSE 13184
// begin Say ( Kamil , DKam-1-apeeng ) ;
13061: LD_EXP 29
13065: PPUSH
13066: LD_STRING DKam-1-apeeng
13068: PPUSH
13069: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
13073: LD_EXP 32
13077: PPUSH
13078: LD_STRING DS-2-apeeng
13080: PPUSH
13081: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
13085: LD_EXP 29
13089: PPUSH
13090: LD_STRING DKam-2-apeeng
13092: PPUSH
13093: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
13097: LD_EXP 32
13101: PPUSH
13102: LD_STRING DS-3-apeeng
13104: PPUSH
13105: CALL_OW 88
// if not IsOK ( Kaia ) then
13109: LD_EXP 31
13113: PPUSH
13114: CALL_OW 302
13118: NOT
13119: IFFALSE 13127
// begin InGameOff ;
13121: CALL_OW 9
// exit ;
13125: GO 13188
// end ; Say ( Kaia , DK-1-apeeng ) ;
13127: LD_EXP 31
13131: PPUSH
13132: LD_STRING DK-1-apeeng
13134: PPUSH
13135: CALL_OW 88
// if not IsOk ( Givi ) then
13139: LD_EXP 27
13143: PPUSH
13144: CALL_OW 302
13148: NOT
13149: IFFALSE 13160
// begin Video ( false ) ;
13151: LD_INT 0
13153: PPUSH
13154: CALL 1020 0 1
// exit ;
13158: GO 13188
// end ; Say ( Givi , DG-1-apeeng ) ;
13160: LD_EXP 27
13164: PPUSH
13165: LD_STRING DG-1-apeeng
13167: PPUSH
13168: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
13172: LD_EXP 31
13176: PPUSH
13177: LD_STRING DK-2-apeeng
13179: PPUSH
13180: CALL_OW 88
// end ; InGameOff ;
13184: CALL_OW 9
// end ;
13188: PPOPN 1
13190: END
// every 0 0$10 trigger farmerBaseReady and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) do
13191: LD_EXP 4
13195: PUSH
13196: LD_INT 22
13198: PUSH
13199: LD_INT 2
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: PUSH
13206: LD_INT 30
13208: PUSH
13209: LD_INT 0
13211: PUSH
13212: EMPTY
13213: LIST
13214: LIST
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PPUSH
13220: CALL_OW 69
13224: AND
13225: IFFALSE 13390
13227: GO 13229
13229: DISABLE
// begin wait ( 0 0$10 ) ;
13230: LD_INT 350
13232: PPUSH
13233: CALL_OW 67
// DialogueOn ;
13237: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
13241: LD_EXP 34
13245: PPUSH
13246: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
13250: LD_EXP 34
13254: PPUSH
13255: LD_STRING DF-1-distribution
13257: PPUSH
13258: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
13262: LD_EXP 26
13266: PPUSH
13267: LD_STRING DH-2-distribution
13269: PPUSH
13270: CALL_OW 88
// if IsOk ( Kaia ) then
13274: LD_EXP 31
13278: PPUSH
13279: CALL_OW 302
13283: IFFALSE 13344
// begin Say ( Kaia , DK-1-distribution ) ;
13285: LD_EXP 31
13289: PPUSH
13290: LD_STRING DK-1-distribution
13292: PPUSH
13293: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13297: LD_EXP 26
13301: PPUSH
13302: LD_STRING DH-1-distribution
13304: PPUSH
13305: CALL_OW 88
// if IsOk ( Givi ) then
13309: LD_EXP 27
13313: PPUSH
13314: CALL_OW 302
13318: IFFALSE 13344
// begin Say ( Givi , DG-1-distribution ) ;
13320: LD_EXP 27
13324: PPUSH
13325: LD_STRING DG-1-distribution
13327: PPUSH
13328: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13332: LD_EXP 26
13336: PPUSH
13337: LD_STRING DH-3-distribution
13339: PPUSH
13340: CALL_OW 88
// end ; end ; DialogueOff ;
13344: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13348: LD_STRING Crates1
13350: PPUSH
13351: CALL_OW 337
// farmerRequestedCrates := 300 ;
13355: LD_ADDR_EXP 14
13359: PUSH
13360: LD_INT 300
13362: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13363: LD_STRING FarmerCrates
13365: PPUSH
13366: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13370: LD_INT 10
13372: PPUSH
13373: LD_INT 1
13375: PPUSH
13376: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13380: LD_INT 108
13382: PPUSH
13383: LD_INT 61
13385: PPUSH
13386: CALL_OW 86
// end ;
13390: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13391: LD_EXP 6
13395: PUSH
13396: LD_INT 22
13398: PUSH
13399: LD_INT 2
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PUSH
13406: LD_INT 3
13408: PUSH
13409: LD_INT 57
13411: PUSH
13412: EMPTY
13413: LIST
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: PUSH
13419: LD_INT 2
13421: PUSH
13422: LD_INT 30
13424: PUSH
13425: LD_INT 6
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: PUSH
13432: LD_INT 30
13434: PUSH
13435: LD_INT 7
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: LIST
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: AND
13457: PUSH
13458: LD_INT 22
13460: PUSH
13461: LD_INT 2
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: PUSH
13468: LD_INT 3
13470: PUSH
13471: LD_INT 57
13473: PUSH
13474: EMPTY
13475: LIST
13476: PUSH
13477: EMPTY
13478: LIST
13479: LIST
13480: PUSH
13481: LD_INT 30
13483: PUSH
13484: LD_INT 4
13486: PUSH
13487: EMPTY
13488: LIST
13489: LIST
13490: PUSH
13491: EMPTY
13492: LIST
13493: LIST
13494: LIST
13495: PPUSH
13496: CALL_OW 69
13500: AND
13501: IFFALSE 13665
13503: GO 13505
13505: DISABLE
13506: LD_INT 0
13508: PPUSH
// begin wait ( 0 0$10 ) ;
13509: LD_INT 350
13511: PPUSH
13512: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13516: LD_ADDR_VAR 0 1
13520: PUSH
13521: LD_EXP 40
13525: PPUSH
13526: LD_INT 26
13528: PUSH
13529: LD_INT 1
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: LD_INT 25
13538: PUSH
13539: LD_INT 2
13541: PUSH
13542: EMPTY
13543: LIST
13544: LIST
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: PPUSH
13550: CALL_OW 72
13554: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13555: LD_EXP 26
13559: PPUSH
13560: LD_STRING DH-1-task
13562: PPUSH
13563: CALL_OW 88
// if IsOk ( Sophia ) then
13567: LD_EXP 32
13571: PPUSH
13572: CALL_OW 302
13576: IFFALSE 13616
// begin Say ( Sophia , DS-1-task ) ;
13578: LD_EXP 32
13582: PPUSH
13583: LD_STRING DS-1-task
13585: PPUSH
13586: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13590: LD_EXP 32
13594: PPUSH
13595: LD_STRING DS-2-task
13597: PPUSH
13598: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13602: LD_EXP 26
13606: PPUSH
13607: LD_STRING DH-2-task
13609: PPUSH
13610: CALL_OW 88
// end else
13614: GO 13650
// if eng then
13616: LD_VAR 0 1
13620: IFFALSE 13650
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13622: LD_VAR 0 1
13626: PUSH
13627: LD_INT 1
13629: ARRAY
13630: PPUSH
13631: LD_STRING DArm-1-task
13633: PPUSH
13634: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13638: LD_EXP 26
13642: PPUSH
13643: LD_STRING DH-2-task
13645: PPUSH
13646: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13650: LD_STRING BaseConstructed
13652: PPUSH
13653: CALL_OW 337
// allowConvoys := true ;
13657: LD_ADDR_EXP 11
13661: PUSH
13662: LD_INT 1
13664: ST_TO_ADDR
// end ;
13665: PPOPN 1
13667: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13668: LD_INT 22
13670: PUSH
13671: LD_INT 4
13673: PUSH
13674: EMPTY
13675: LIST
13676: LIST
13677: PUSH
13678: LD_INT 34
13680: PUSH
13681: LD_INT 12
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: PUSH
13688: EMPTY
13689: LIST
13690: LIST
13691: PPUSH
13692: CALL_OW 69
13696: IFFALSE 13864
13698: GO 13700
13700: DISABLE
13701: LD_INT 0
13703: PPUSH
13704: PPUSH
13705: PPUSH
// begin wait ( 0 0$2 ) ;
13706: LD_INT 70
13708: PPUSH
13709: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13713: LD_ADDR_VAR 0 1
13717: PUSH
13718: LD_INT 22
13720: PUSH
13721: LD_INT 4
13723: PUSH
13724: EMPTY
13725: LIST
13726: LIST
13727: PUSH
13728: LD_INT 34
13730: PUSH
13731: LD_INT 12
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: PUSH
13738: EMPTY
13739: LIST
13740: LIST
13741: PPUSH
13742: CALL_OW 69
13746: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13747: LD_ADDR_VAR 0 2
13751: PUSH
13752: LD_VAR 0 1
13756: PUSH
13757: LD_INT 1
13759: ARRAY
13760: PPUSH
13761: CALL_OW 250
13765: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13766: LD_ADDR_VAR 0 3
13770: PUSH
13771: LD_VAR 0 1
13775: PUSH
13776: LD_INT 1
13778: ARRAY
13779: PPUSH
13780: CALL_OW 251
13784: ST_TO_ADDR
// DialogueOn ;
13785: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13789: LD_VAR 0 2
13793: PPUSH
13794: LD_VAR 0 3
13798: PPUSH
13799: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13803: LD_VAR 0 2
13807: PPUSH
13808: LD_VAR 0 3
13812: PPUSH
13813: LD_INT 2
13815: PPUSH
13816: LD_INT 6
13818: NEG
13819: PPUSH
13820: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13824: LD_INT 10
13826: PPUSH
13827: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13831: LD_EXP 26
13835: PPUSH
13836: LD_STRING DH-1-seecargo
13838: PPUSH
13839: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13843: LD_VAR 0 2
13847: PPUSH
13848: LD_VAR 0 3
13852: PPUSH
13853: LD_INT 2
13855: PPUSH
13856: CALL_OW 331
// DialogueOff ;
13860: CALL_OW 7
// end ;
13864: PPOPN 3
13866: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13867: LD_EXP 4
13871: PUSH
13872: LD_EXP 13
13876: PUSH
13877: LD_INT 300
13879: GREATEREQUAL
13880: AND
13881: IFFALSE 13953
13883: GO 13885
13885: DISABLE
// begin DialogueOn ;
13886: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13890: LD_EXP 34
13894: PPUSH
13895: LD_STRING DF-1-delivery-2
13897: PPUSH
13898: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13902: LD_EXP 26
13906: PPUSH
13907: LD_STRING DH-1-delivery-2
13909: PPUSH
13910: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
13914: LD_EXP 34
13918: PPUSH
13919: LD_STRING DF-2-delivery-2
13921: PPUSH
13922: CALL_OW 94
// DialogueOff ;
13926: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
13930: LD_STRING Crates2
13932: PPUSH
13933: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13937: LD_ADDR_EXP 15
13941: PUSH
13942: LD_INT 63000
13944: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
13945: LD_ADDR_EXP 14
13949: PUSH
13950: LD_INT 600
13952: ST_TO_ADDR
// end ;
13953: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 do
13954: LD_EXP 4
13958: PUSH
13959: LD_EXP 13
13963: PUSH
13964: LD_INT 600
13966: GREATEREQUAL
13967: AND
13968: IFFALSE 14134
13970: GO 13972
13972: DISABLE
// begin DialogueOn ;
13973: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
13977: LD_EXP 34
13981: PPUSH
13982: LD_STRING DF-1-delivery-3
13984: PPUSH
13985: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
13989: LD_EXP 26
13993: PPUSH
13994: LD_STRING DH-1-delivery-3
13996: PPUSH
13997: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
14001: LD_EXP 34
14005: PPUSH
14006: LD_STRING DF-2-delivery-3
14008: PPUSH
14009: CALL_OW 94
// if IsOk ( Kaia ) then
14013: LD_EXP 31
14017: PPUSH
14018: CALL_OW 302
14022: IFFALSE 14072
// begin Say ( Kaia , DK-1-delivery-3 ) ;
14024: LD_EXP 31
14028: PPUSH
14029: LD_STRING DK-1-delivery-3
14031: PPUSH
14032: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
14036: LD_EXP 26
14040: PPUSH
14041: LD_STRING DH-2-delivery-3
14043: PPUSH
14044: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
14048: LD_EXP 27
14052: PPUSH
14053: LD_STRING DG-1-delivery-3
14055: PPUSH
14056: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
14060: LD_EXP 28
14064: PPUSH
14065: LD_STRING DM-1-delivery-3
14067: PPUSH
14068: CALL_OW 88
// end ; DialogueOff ;
14072: CALL_OW 7
// if Difficulty = 2 then
14076: LD_OWVAR 67
14080: PUSH
14081: LD_INT 2
14083: EQUAL
14084: IFFALSE 14111
// begin ChangeMissionObjectives ( Crates3 ) ;
14086: LD_STRING Crates3
14088: PPUSH
14089: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14093: LD_ADDR_EXP 15
14097: PUSH
14098: LD_INT 63000
14100: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
14101: LD_ADDR_EXP 14
14105: PUSH
14106: LD_INT 900
14108: ST_TO_ADDR
// end else
14109: GO 14134
// begin ChangeMissionObjectives ( Crates4 ) ;
14111: LD_STRING Crates4
14113: PPUSH
14114: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14118: LD_ADDR_EXP 15
14122: PUSH
14123: LD_INT 63000
14125: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
14126: LD_ADDR_EXP 14
14130: PUSH
14131: LD_INT 1200
14133: ST_TO_ADDR
// end ; end ;
14134: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
14135: LD_EXP 4
14139: PUSH
14140: LD_EXP 13
14144: PUSH
14145: LD_INT 600
14147: PUSH
14148: LD_INT 900
14150: PUSH
14151: LD_INT 1200
14153: PUSH
14154: EMPTY
14155: LIST
14156: LIST
14157: LIST
14158: PUSH
14159: LD_OWVAR 67
14163: ARRAY
14164: GREATEREQUAL
14165: AND
14166: PUSH
14167: LD_EXP 14
14171: PUSH
14172: LD_EXP 15
14176: LESSEQUAL
14177: AND
14178: IFFALSE 14251
14180: GO 14182
14182: DISABLE
// begin retreatAllowed := true ;
14183: LD_ADDR_EXP 10
14187: PUSH
14188: LD_INT 1
14190: ST_TO_ADDR
// display_strings := [ ] ;
14191: LD_ADDR_OWVAR 47
14195: PUSH
14196: EMPTY
14197: ST_TO_ADDR
// DialogueOn ;
14198: CALL_OW 6
// Video ( true ) ;
14202: LD_INT 1
14204: PPUSH
14205: CALL 1020 0 1
// SayRadio ( Omar , DO-radio-end ) ;
14209: LD_EXP 35
14213: PPUSH
14214: LD_STRING DO-radio-end
14216: PPUSH
14217: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
14221: LD_EXP 26
14225: PPUSH
14226: LD_STRING DH-1-radio-end
14228: PPUSH
14229: CALL_OW 88
// Video ( false ) ;
14233: LD_INT 0
14235: PPUSH
14236: CALL 1020 0 1
// DialogueOff ;
14240: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
14244: LD_STRING Retreat
14246: PPUSH
14247: CALL_OW 337
// end ;
14251: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
14252: LD_EXP 10
14256: IFFALSE 14391
14258: GO 14260
14260: DISABLE
14261: LD_INT 0
14263: PPUSH
14264: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
14265: LD_INT 10
14267: PPUSH
14268: LD_INT 0
14270: PPUSH
14271: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
14275: LD_ADDR_VAR 0 1
14279: PUSH
14280: LD_EXP 37
14284: PPUSH
14285: LD_INT 25
14287: PUSH
14288: LD_INT 2
14290: PUSH
14291: EMPTY
14292: LIST
14293: LIST
14294: PPUSH
14295: CALL_OW 72
14299: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14300: LD_VAR 0 1
14304: PUSH
14305: LD_INT 102
14307: PPUSH
14308: LD_INT 69
14310: PPUSH
14311: CALL_OW 428
14315: PUSH
14316: LD_INT 0
14318: EQUAL
14319: AND
14320: IFFALSE 14387
// begin for i in tmp do
14322: LD_ADDR_VAR 0 2
14326: PUSH
14327: LD_VAR 0 1
14331: PUSH
14332: FOR_IN
14333: IFFALSE 14357
// if IsInUnit ( i ) then
14335: LD_VAR 0 2
14339: PPUSH
14340: CALL_OW 310
14344: IFFALSE 14355
// ComExitBuilding ( i ) ;
14346: LD_VAR 0 2
14350: PPUSH
14351: CALL_OW 122
14355: GO 14332
14357: POP
14358: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14359: LD_VAR 0 1
14363: PPUSH
14364: LD_INT 31
14366: PPUSH
14367: LD_INT 102
14369: PPUSH
14370: LD_INT 69
14372: PPUSH
14373: LD_INT 2
14375: PPUSH
14376: CALL_OW 205
// wait ( 0 0$3 ) ;
14380: LD_INT 105
14382: PPUSH
14383: CALL_OW 67
// end ; StartCargoEvacuation ;
14387: CALL 4481 0 0
// end ;
14391: PPOPN 2
14393: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14394: LD_EXP 10
14398: NOT
14399: PUSH
14400: LD_INT 5
14402: PPUSH
14403: CALL_OW 301
14407: AND
14408: IFFALSE 14432
14410: GO 14412
14412: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
14413: LD_EXP 34
14417: PPUSH
14418: LD_STRING DF-1-failure
14420: PPUSH
14421: CALL_OW 94
// YouLost ( FarmerDepot ) ;
14425: LD_STRING FarmerDepot
14427: PPUSH
14428: CALL_OW 104
// end ;
14432: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 and not FilterAllUnits ( [ f_enemy , 2 ] ) do var i , max , tmp ;
14433: LD_EXP 10
14437: PUSH
14438: LD_EXP 26
14442: PPUSH
14443: LD_EXP 34
14447: PPUSH
14448: CALL_OW 296
14452: PUSH
14453: LD_INT 6
14455: LESS
14456: AND
14457: PUSH
14458: LD_INT 81
14460: PUSH
14461: LD_INT 2
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: PPUSH
14468: CALL_OW 69
14472: NOT
14473: AND
14474: IFFALSE 15071
14476: GO 14478
14478: DISABLE
14479: LD_INT 0
14481: PPUSH
14482: PPUSH
14483: PPUSH
// begin allowConvoys := false ;
14484: LD_ADDR_EXP 11
14488: PUSH
14489: LD_INT 0
14491: ST_TO_ADDR
// InGameOn ;
14492: CALL_OW 8
// ComTurnUnit ( Heike , Farmer ) ;
14496: LD_EXP 26
14500: PPUSH
14501: LD_EXP 34
14505: PPUSH
14506: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14510: LD_EXP 34
14514: PPUSH
14515: LD_EXP 26
14519: PPUSH
14520: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14524: LD_EXP 34
14528: PPUSH
14529: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14533: LD_EXP 26
14537: PPUSH
14538: LD_STRING DH-1-end
14540: PPUSH
14541: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14545: LD_EXP 34
14549: PPUSH
14550: LD_STRING DF-1-end
14552: PPUSH
14553: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14557: LD_EXP 34
14561: PPUSH
14562: LD_STRING DF-2-end
14564: PPUSH
14565: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14569: LD_EXP 26
14573: PPUSH
14574: LD_STRING DH-2-end
14576: PPUSH
14577: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14581: LD_EXP 34
14585: PPUSH
14586: LD_STRING DF-3-end
14588: PPUSH
14589: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14593: LD_EXP 26
14597: PPUSH
14598: LD_STRING DH-3-end
14600: PPUSH
14601: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14605: LD_EXP 27
14609: PPUSH
14610: LD_STRING DG-1-end
14612: PPUSH
14613: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14617: LD_EXP 26
14621: PPUSH
14622: LD_STRING DH-4-end
14624: PPUSH
14625: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14629: LD_EXP 34
14633: PPUSH
14634: LD_STRING DF-4-end
14636: PPUSH
14637: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14641: LD_EXP 26
14645: PPUSH
14646: LD_STRING DH-5-end
14648: PPUSH
14649: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14653: LD_EXP 34
14657: PPUSH
14658: LD_STRING DF-5-end
14660: PPUSH
14661: CALL_OW 88
// InGameOff ;
14665: CALL_OW 9
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14669: LD_ADDR_VAR 0 2
14673: PUSH
14674: LD_INT 4
14676: PUSH
14677: LD_INT 3
14679: PUSH
14680: LD_INT 2
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: LIST
14687: PUSH
14688: LD_OWVAR 67
14692: ARRAY
14693: ST_TO_ADDR
// if farmerSquad < max then
14694: LD_EXP 37
14698: PUSH
14699: LD_VAR 0 2
14703: LESS
14704: IFFALSE 14716
// max := farmerSquad ;
14706: LD_ADDR_VAR 0 2
14710: PUSH
14711: LD_EXP 37
14715: ST_TO_ADDR
// for i := 1 to max do
14716: LD_ADDR_VAR 0 1
14720: PUSH
14721: DOUBLE
14722: LD_INT 1
14724: DEC
14725: ST_TO_ADDR
14726: LD_VAR 0 2
14730: PUSH
14731: FOR_TO
14732: IFFALSE 14770
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14734: LD_EXP 37
14738: PUSH
14739: LD_INT 1
14741: ARRAY
14742: PPUSH
14743: LD_INT 2
14745: PPUSH
14746: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14750: LD_ADDR_EXP 37
14754: PUSH
14755: LD_EXP 37
14759: PPUSH
14760: LD_INT 1
14762: PPUSH
14763: CALL_OW 3
14767: ST_TO_ADDR
// end ;
14768: GO 14731
14770: POP
14771: POP
// for i in Farmer ^ farmerSquad do
14772: LD_ADDR_VAR 0 1
14776: PUSH
14777: LD_EXP 34
14781: PUSH
14782: LD_EXP 37
14786: ADD
14787: PUSH
14788: FOR_IN
14789: IFFALSE 14828
// begin if IsInUnit ( i ) then
14791: LD_VAR 0 1
14795: PPUSH
14796: CALL_OW 310
14800: IFFALSE 14811
// ComExitBuilding ( i ) ;
14802: LD_VAR 0 1
14806: PPUSH
14807: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14811: LD_VAR 0 1
14815: PPUSH
14816: LD_INT 102
14818: PPUSH
14819: LD_INT 7
14821: PPUSH
14822: CALL_OW 171
// end ;
14826: GO 14788
14828: POP
14829: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14830: LD_ADDR_VAR 0 1
14834: PUSH
14835: LD_INT 22
14837: PUSH
14838: LD_INT 5
14840: PUSH
14841: EMPTY
14842: LIST
14843: LIST
14844: PUSH
14845: LD_INT 21
14847: PUSH
14848: LD_INT 3
14850: PUSH
14851: EMPTY
14852: LIST
14853: LIST
14854: PUSH
14855: EMPTY
14856: LIST
14857: LIST
14858: PPUSH
14859: CALL_OW 69
14863: PUSH
14864: LD_INT 5
14866: DIFF
14867: PUSH
14868: FOR_IN
14869: IFFALSE 14885
// SetSide ( i , 2 ) ;
14871: LD_VAR 0 1
14875: PPUSH
14876: LD_INT 2
14878: PPUSH
14879: CALL_OW 235
14883: GO 14868
14885: POP
14886: POP
// repeat wait ( 0 0$1 ) ;
14887: LD_INT 35
14889: PPUSH
14890: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
14894: LD_ADDR_VAR 0 3
14898: PUSH
14899: LD_EXP 34
14903: PUSH
14904: LD_EXP 37
14908: ADD
14909: PPUSH
14910: LD_INT 95
14912: PUSH
14913: LD_INT 3
14915: PUSH
14916: EMPTY
14917: LIST
14918: LIST
14919: PPUSH
14920: CALL_OW 72
14924: ST_TO_ADDR
// if tmp then
14925: LD_VAR 0 3
14929: IFFALSE 14973
// for i in tmp do
14931: LD_ADDR_VAR 0 1
14935: PUSH
14936: LD_VAR 0 3
14940: PUSH
14941: FOR_IN
14942: IFFALSE 14971
// begin farmerSquad := farmerSquad diff i ;
14944: LD_ADDR_EXP 37
14948: PUSH
14949: LD_EXP 37
14953: PUSH
14954: LD_VAR 0 1
14958: DIFF
14959: ST_TO_ADDR
// RemoveUnit ( i ) ;
14960: LD_VAR 0 1
14964: PPUSH
14965: CALL_OW 64
// end ;
14969: GO 14941
14971: POP
14972: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
14973: LD_EXP 37
14977: PUSH
14978: EMPTY
14979: EQUAL
14980: PUSH
14981: LD_EXP 34
14985: PPUSH
14986: CALL_OW 305
14990: NOT
14991: AND
14992: IFFALSE 14887
// if farmerHumanLoseCounter = 0 then
14994: LD_EXP 18
14998: PUSH
14999: LD_INT 0
15001: EQUAL
15002: IFFALSE 15011
// SetAchievement ( ACH_BABY ) ;
15004: LD_STRING ACH_BABY
15006: PPUSH
15007: CALL_OW 543
// wait ( 1 1$00 ) ;
15011: LD_INT 2100
15013: PPUSH
15014: CALL_OW 67
// SendAttack ;
15018: CALL 6927 0 0
// wait ( [ 2 2$00 , 1 1$30 , 1 1$00 ] [ Difficulty ] ) ;
15022: LD_INT 4200
15024: PUSH
15025: LD_INT 3150
15027: PUSH
15028: LD_INT 2100
15030: PUSH
15031: EMPTY
15032: LIST
15033: LIST
15034: LIST
15035: PUSH
15036: LD_OWVAR 67
15040: ARRAY
15041: PPUSH
15042: CALL_OW 67
// SendAttack ;
15046: CALL 6927 0 0
// if Difficulty > 2 then
15050: LD_OWVAR 67
15054: PUSH
15055: LD_INT 2
15057: GREATER
15058: IFFALSE 15071
// begin wait ( 2 2$30 ) ;
15060: LD_INT 5250
15062: PPUSH
15063: CALL_OW 67
// SendAttack ;
15067: CALL 6927 0 0
// end ; end ;
15071: PPOPN 3
15073: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
15074: LD_EXP 15
15078: PUSH
15079: LD_INT 18900
15081: LESSEQUAL
15082: IFFALSE 15131
15084: GO 15086
15086: DISABLE
// begin DialogueOn ;
15087: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
15091: LD_EXP 34
15095: PPUSH
15096: LD_STRING DF-1-distribution-a
15098: PPUSH
15099: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
15103: LD_EXP 26
15107: PPUSH
15108: LD_STRING DH-1-distribution-a
15110: PPUSH
15111: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
15115: LD_EXP 34
15119: PPUSH
15120: LD_STRING DF-2-distribution-a
15122: PPUSH
15123: CALL_OW 94
// DialogueOff ;
15127: CALL_OW 7
// end ;
15131: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
15132: LD_EXP 15
15136: PUSH
15137: LD_INT 0
15139: LESSEQUAL
15140: IFFALSE 15172
15142: GO 15144
15144: DISABLE
// begin DialogueOn ;
15145: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
15149: LD_EXP 34
15153: PPUSH
15154: LD_STRING DF-3-distribution-a
15156: PPUSH
15157: CALL_OW 94
// YouLost ( Distribution ) ;
15161: LD_STRING Distribution
15163: PPUSH
15164: CALL_OW 104
// DialogueOff ;
15168: CALL_OW 7
// end ;
15172: END
// every 0 0$1 trigger vehCounter >= 2 do
15173: LD_EXP 20
15177: PUSH
15178: LD_INT 2
15180: GREATEREQUAL
15181: IFFALSE 15193
15183: GO 15185
15185: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
15186: LD_STRING VehConstructed
15188: PPUSH
15189: CALL_OW 337
15193: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
15194: LD_INT 22
15196: PUSH
15197: LD_INT 2
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: PUSH
15204: LD_INT 34
15206: PUSH
15207: LD_INT 12
15209: PUSH
15210: EMPTY
15211: LIST
15212: LIST
15213: PUSH
15214: EMPTY
15215: LIST
15216: LIST
15217: PPUSH
15218: CALL_OW 69
15222: IFFALSE 15282
15224: GO 15226
15226: DISABLE
// begin DialogueOn ;
15227: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
15231: LD_EXP 26
15235: PPUSH
15236: LD_STRING DH-1-truck
15238: PPUSH
15239: CALL_OW 88
// if IsOk ( Markov ) then
15243: LD_EXP 33
15247: PPUSH
15248: CALL_OW 302
15252: IFFALSE 15278
// begin Say ( Markov , DMar-1-truck ) ;
15254: LD_EXP 33
15258: PPUSH
15259: LD_STRING DMar-1-truck
15261: PPUSH
15262: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
15266: LD_EXP 26
15270: PPUSH
15271: LD_STRING DH-2-truck
15273: PPUSH
15274: CALL_OW 88
// end ; DialogueOff ;
15278: CALL_OW 7
// end ;
15282: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
15283: LD_INT 0
15285: PPUSH
15286: PPUSH
15287: PPUSH
// if IsOk ( Givi ) then
15288: LD_EXP 27
15292: PPUSH
15293: CALL_OW 302
15297: IFFALSE 15313
// begin Say ( Givi , DG-1-nocargo ) ;
15299: LD_EXP 27
15303: PPUSH
15304: LD_STRING DG-1-nocargo
15306: PPUSH
15307: CALL_OW 88
// exit ;
15311: GO 15409
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15313: LD_ADDR_VAR 0 2
15317: PUSH
15318: LD_EXP 40
15322: PPUSH
15323: LD_INT 26
15325: PUSH
15326: LD_INT 1
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: PPUSH
15333: CALL_OW 72
15337: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15338: LD_ADDR_VAR 0 3
15342: PUSH
15343: LD_EXP 40
15347: PPUSH
15348: LD_INT 26
15350: PUSH
15351: LD_INT 2
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: PPUSH
15358: CALL_OW 72
15362: ST_TO_ADDR
// if randomMen then
15363: LD_VAR 0 2
15367: IFFALSE 15387
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15369: LD_VAR 0 2
15373: PUSH
15374: LD_INT 1
15376: ARRAY
15377: PPUSH
15378: LD_STRING DArm-1-nocargo
15380: PPUSH
15381: CALL_OW 88
15385: GO 15409
// if randomWomen then
15387: LD_VAR 0 3
15391: IFFALSE 15409
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15393: LD_VAR 0 3
15397: PUSH
15398: LD_INT 1
15400: ARRAY
15401: PPUSH
15402: LD_STRING DArf-1-nocargo
15404: PPUSH
15405: CALL_OW 88
// end ;
15409: LD_VAR 0 1
15413: RET
// export function IncomingAttack ; begin
15414: LD_INT 0
15416: PPUSH
// if attackWave = 1 then
15417: LD_EXP 17
15421: PUSH
15422: LD_INT 1
15424: EQUAL
15425: IFFALSE 15496
// begin DialogueOn ;
15427: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15431: LD_EXP 35
15435: PPUSH
15436: LD_STRING DO-1-radio-1
15438: PPUSH
15439: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15443: LD_EXP 26
15447: PPUSH
15448: LD_STRING DH-1-radio-1-
15450: PPUSH
15451: CALL_OW 88
// if IsOk ( Markov ) then
15455: LD_EXP 33
15459: PPUSH
15460: CALL_OW 302
15464: IFFALSE 15490
// begin Say ( Markov , DMar-1-radio-1 ) ;
15466: LD_EXP 33
15470: PPUSH
15471: LD_STRING DMar-1-radio-1
15473: PPUSH
15474: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15478: LD_EXP 26
15482: PPUSH
15483: LD_STRING DH-2-radio-1
15485: PPUSH
15486: CALL_OW 88
// end ; DialogueOff ;
15490: CALL_OW 7
// end else
15494: GO 15520
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15496: LD_EXP 35
15500: PPUSH
15501: LD_STRING DO-1-radio-u
15503: PPUSH
15504: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15508: LD_EXP 26
15512: PPUSH
15513: LD_STRING DH-1-radio-u
15515: PPUSH
15516: CALL_OW 88
// end ; end ;
15520: LD_VAR 0 1
15524: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15525: LD_EXP 42
15529: PPUSH
15530: LD_INT 95
15532: PUSH
15533: LD_INT 8
15535: PUSH
15536: EMPTY
15537: LIST
15538: LIST
15539: PPUSH
15540: CALL_OW 72
15544: IFFALSE 15647
15546: GO 15548
15548: DISABLE
15549: LD_INT 0
15551: PPUSH
// begin enable ;
15552: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15553: LD_ADDR_VAR 0 1
15557: PUSH
15558: LD_EXP 42
15562: PPUSH
15563: LD_INT 95
15565: PUSH
15566: LD_INT 8
15568: PUSH
15569: EMPTY
15570: LIST
15571: LIST
15572: PPUSH
15573: CALL_OW 72
15577: PUSH
15578: FOR_IN
15579: IFFALSE 15608
// begin usForces := usForces diff i ;
15581: LD_ADDR_EXP 42
15585: PUSH
15586: LD_EXP 42
15590: PUSH
15591: LD_VAR 0 1
15595: DIFF
15596: ST_TO_ADDR
// RemoveUnit ( i ) ;
15597: LD_VAR 0 1
15601: PPUSH
15602: CALL_OW 64
// end ;
15606: GO 15578
15608: POP
15609: POP
// if not americanHasEscaped and attackWave = 1 then
15610: LD_EXP 7
15614: NOT
15615: PUSH
15616: LD_EXP 17
15620: PUSH
15621: LD_INT 1
15623: EQUAL
15624: AND
15625: IFFALSE 15647
// begin americanHasEscaped := true ;
15627: LD_ADDR_EXP 7
15631: PUSH
15632: LD_INT 1
15634: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15635: LD_EXP 26
15639: PPUSH
15640: LD_STRING DH-2-assault-a
15642: PPUSH
15643: CALL_OW 88
// end ; end ;
15647: PPOPN 1
15649: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) do
15650: LD_INT 4
15652: PPUSH
15653: LD_INT 22
15655: PUSH
15656: LD_INT 1
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: PPUSH
15663: CALL_OW 70
15667: IFFALSE 15684
15669: GO 15671
15671: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15672: LD_EXP 34
15676: PPUSH
15677: LD_STRING DF-1-attack
15679: PPUSH
15680: CALL_OW 94
15684: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15685: LD_INT 5
15687: PPUSH
15688: CALL_OW 255
15692: PUSH
15693: LD_INT 2
15695: EQUAL
15696: IFFALSE 15708
15698: GO 15700
15700: DISABLE
// YouLost ( Attack ) ;
15701: LD_STRING Attack
15703: PPUSH
15704: CALL_OW 104
15708: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 90 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot ;
15709: LD_INT 22
15711: PUSH
15712: LD_INT 1
15714: PUSH
15715: EMPTY
15716: LIST
15717: LIST
15718: PUSH
15719: LD_INT 21
15721: PUSH
15722: LD_INT 1
15724: PUSH
15725: EMPTY
15726: LIST
15727: LIST
15728: PUSH
15729: EMPTY
15730: LIST
15731: LIST
15732: PPUSH
15733: CALL_OW 69
15737: NOT
15738: PUSH
15739: LD_INT 22
15741: PUSH
15742: LD_INT 4
15744: PUSH
15745: EMPTY
15746: LIST
15747: LIST
15748: PPUSH
15749: CALL_OW 69
15753: NOT
15754: AND
15755: PUSH
15756: LD_EXP 10
15760: NOT
15761: AND
15762: PUSH
15763: LD_EXP 13
15767: PUSH
15768: LD_INT 90
15770: GREATER
15771: AND
15772: PUSH
15773: LD_INT 7
15775: PPUSH
15776: LD_INT 22
15778: PUSH
15779: LD_INT 2
15781: PUSH
15782: EMPTY
15783: LIST
15784: LIST
15785: PUSH
15786: LD_INT 21
15788: PUSH
15789: LD_INT 1
15791: PUSH
15792: EMPTY
15793: LIST
15794: LIST
15795: PUSH
15796: EMPTY
15797: LIST
15798: LIST
15799: PPUSH
15800: CALL_OW 70
15804: AND
15805: PUSH
15806: LD_INT 22
15808: PUSH
15809: LD_INT 2
15811: PUSH
15812: EMPTY
15813: LIST
15814: LIST
15815: PUSH
15816: LD_INT 50
15818: PUSH
15819: EMPTY
15820: LIST
15821: PUSH
15822: LD_INT 30
15824: PUSH
15825: LD_INT 0
15827: PUSH
15828: EMPTY
15829: LIST
15830: LIST
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: LIST
15836: PPUSH
15837: CALL_OW 69
15841: AND
15842: IFFALSE 16543
15844: GO 15846
15846: DISABLE
15847: LD_INT 0
15849: PPUSH
15850: PPUSH
15851: PPUSH
15852: PPUSH
15853: PPUSH
// begin depot := usDepot ;
15854: LD_ADDR_VAR 0 5
15858: PUSH
15859: LD_INT 11
15861: ST_TO_ADDR
// if not depot then
15862: LD_VAR 0 5
15866: NOT
15867: IFFALSE 15907
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
15869: LD_ADDR_VAR 0 5
15873: PUSH
15874: LD_INT 22
15876: PUSH
15877: LD_INT 2
15879: PUSH
15880: EMPTY
15881: LIST
15882: LIST
15883: PUSH
15884: LD_INT 30
15886: PUSH
15887: LD_INT 0
15889: PUSH
15890: EMPTY
15891: LIST
15892: LIST
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: PPUSH
15898: CALL_OW 69
15902: PUSH
15903: LD_INT 1
15905: ARRAY
15906: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15907: LD_ADDR_VAR 0 1
15911: PUSH
15912: LD_EXP 40
15916: PPUSH
15917: LD_INT 26
15919: PUSH
15920: LD_INT 1
15922: PUSH
15923: EMPTY
15924: LIST
15925: LIST
15926: PPUSH
15927: CALL_OW 72
15931: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15932: LD_ADDR_VAR 0 2
15936: PUSH
15937: LD_EXP 40
15941: PPUSH
15942: LD_INT 26
15944: PUSH
15945: LD_INT 2
15947: PUSH
15948: EMPTY
15949: LIST
15950: LIST
15951: PPUSH
15952: CALL_OW 72
15956: ST_TO_ADDR
// if IsOk ( Kaia ) then
15957: LD_EXP 31
15961: PPUSH
15962: CALL_OW 302
15966: IFFALSE 15987
// speaker := [ Kaia , DK ] else
15968: LD_ADDR_VAR 0 3
15972: PUSH
15973: LD_EXP 31
15977: PUSH
15978: LD_STRING DK
15980: PUSH
15981: EMPTY
15982: LIST
15983: LIST
15984: ST_TO_ADDR
15985: GO 16067
// if randomMen then
15987: LD_VAR 0 1
15991: IFFALSE 16026
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
15993: LD_ADDR_VAR 0 3
15997: PUSH
15998: LD_VAR 0 1
16002: PUSH
16003: LD_INT 1
16005: PPUSH
16006: LD_VAR 0 1
16010: PPUSH
16011: CALL_OW 12
16015: ARRAY
16016: PUSH
16017: LD_STRING DArm
16019: PUSH
16020: EMPTY
16021: LIST
16022: LIST
16023: ST_TO_ADDR
16024: GO 16067
// if randomWomen then
16026: LD_VAR 0 2
16030: IFFALSE 16065
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
16032: LD_ADDR_VAR 0 3
16036: PUSH
16037: LD_VAR 0 2
16041: PUSH
16042: LD_INT 1
16044: PPUSH
16045: LD_VAR 0 2
16049: PPUSH
16050: CALL_OW 12
16054: ARRAY
16055: PUSH
16056: LD_STRING DArf
16058: PUSH
16059: EMPTY
16060: LIST
16061: LIST
16062: ST_TO_ADDR
16063: GO 16067
// exit ;
16065: GO 16543
// if IsInUnit ( speaker [ 1 ] ) then
16067: LD_VAR 0 3
16071: PUSH
16072: LD_INT 1
16074: ARRAY
16075: PPUSH
16076: CALL_OW 310
16080: IFFALSE 16103
// place := IsInUnit ( speaker [ 1 ] ) else
16082: LD_ADDR_VAR 0 4
16086: PUSH
16087: LD_VAR 0 3
16091: PUSH
16092: LD_INT 1
16094: ARRAY
16095: PPUSH
16096: CALL_OW 310
16100: ST_TO_ADDR
16101: GO 16117
// place := speaker [ 1 ] ;
16103: LD_ADDR_VAR 0 4
16107: PUSH
16108: LD_VAR 0 3
16112: PUSH
16113: LD_INT 1
16115: ARRAY
16116: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
16117: LD_VAR 0 4
16121: PPUSH
16122: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
16126: LD_VAR 0 4
16130: PPUSH
16131: CALL_OW 250
16135: PPUSH
16136: LD_VAR 0 4
16140: PPUSH
16141: CALL_OW 251
16145: PPUSH
16146: CALL 2989 0 2
// wait ( 0 0$2 ) ;
16150: LD_INT 70
16152: PPUSH
16153: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
16157: LD_EXP 36
16161: PPUSH
16162: CALL_OW 305
16166: NOT
16167: IFFALSE 16171
// exit ;
16169: GO 16543
// allowConvoys := false ;
16171: LD_ADDR_EXP 11
16175: PUSH
16176: LD_INT 0
16178: ST_TO_ADDR
// InGameOn ;
16179: CALL_OW 8
// wait ( 0 0$1 ) ;
16183: LD_INT 35
16185: PPUSH
16186: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
16190: LD_EXP 36
16194: PPUSH
16195: LD_STRING DI-1-land
16197: PPUSH
16198: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
16202: LD_VAR 0 3
16206: PUSH
16207: LD_INT 1
16209: ARRAY
16210: PPUSH
16211: CALL_OW 310
16215: IFFALSE 16230
// ComExit ( speaker [ 1 ] ) ;
16217: LD_VAR 0 3
16221: PUSH
16222: LD_INT 1
16224: ARRAY
16225: PPUSH
16226: CALL 1124 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
16230: LD_VAR 0 3
16234: PUSH
16235: LD_INT 1
16237: ARRAY
16238: PPUSH
16239: LD_EXP 36
16243: PPUSH
16244: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
16248: LD_VAR 0 3
16252: PUSH
16253: LD_INT 1
16255: ARRAY
16256: PPUSH
16257: LD_EXP 36
16261: PPUSH
16262: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
16266: LD_EXP 36
16270: PPUSH
16271: LD_VAR 0 3
16275: PUSH
16276: LD_INT 1
16278: ARRAY
16279: PPUSH
16280: CALL_OW 119
// wait ( 0 0$1 ) ;
16284: LD_INT 35
16286: PPUSH
16287: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
16291: LD_VAR 0 3
16295: PUSH
16296: LD_INT 1
16298: ARRAY
16299: PPUSH
16300: LD_VAR 0 3
16304: PUSH
16305: LD_INT 2
16307: ARRAY
16308: PUSH
16309: LD_STRING -1-land
16311: STR
16312: PPUSH
16313: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16317: LD_EXP 36
16321: PPUSH
16322: LD_STRING DI-2-land
16324: PPUSH
16325: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16329: LD_VAR 0 3
16333: PUSH
16334: LD_INT 1
16336: ARRAY
16337: PPUSH
16338: LD_VAR 0 3
16342: PUSH
16343: LD_INT 2
16345: ARRAY
16346: PUSH
16347: LD_STRING -2-land
16349: STR
16350: PPUSH
16351: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16355: LD_VAR 0 3
16359: PUSH
16360: LD_INT 1
16362: ARRAY
16363: PPUSH
16364: LD_VAR 0 3
16368: PUSH
16369: LD_INT 2
16371: ARRAY
16372: PUSH
16373: LD_STRING -3-land
16375: STR
16376: PPUSH
16377: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16381: LD_EXP 26
16385: PPUSH
16386: LD_STRING DH-1-land
16388: PPUSH
16389: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16393: LD_VAR 0 5
16397: PPUSH
16398: CALL_OW 313
16402: PUSH
16403: LD_INT 6
16405: EQUAL
16406: IFFALSE 16426
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16408: LD_VAR 0 5
16412: PPUSH
16413: CALL_OW 313
16417: PUSH
16418: LD_INT 1
16420: ARRAY
16421: PPUSH
16422: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16426: LD_EXP 36
16430: PPUSH
16431: LD_INT 2
16433: PPUSH
16434: CALL_OW 235
// CenterOnUnits ( depot ) ;
16438: LD_VAR 0 5
16442: PPUSH
16443: CALL_OW 85
// ComEnterUnit ( Ibrahim , depot ) ;
16447: LD_EXP 36
16451: PPUSH
16452: LD_VAR 0 5
16456: PPUSH
16457: CALL_OW 120
// ComEnterUnit ( speaker [ 1 ] , depot ) ;
16461: LD_VAR 0 3
16465: PUSH
16466: LD_INT 1
16468: ARRAY
16469: PPUSH
16470: LD_VAR 0 5
16474: PPUSH
16475: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
16479: LD_INT 35
16481: PPUSH
16482: CALL_OW 67
// until IsInUnit ( Ibrahim ) or not IsOk ( Ibrahim ) ;
16486: LD_EXP 36
16490: PPUSH
16491: CALL_OW 310
16495: PUSH
16496: LD_EXP 36
16500: PPUSH
16501: CALL_OW 302
16505: NOT
16506: OR
16507: IFFALSE 16479
// InGameOff ;
16509: CALL_OW 9
// if not IsOk ( Ibrahim ) then
16513: LD_EXP 36
16517: PPUSH
16518: CALL_OW 302
16522: NOT
16523: IFFALSE 16527
// exit ;
16525: GO 16543
// ibrahimInDepot := true ;
16527: LD_ADDR_EXP 23
16531: PUSH
16532: LD_INT 1
16534: ST_TO_ADDR
// allowConvoys := true ;
16535: LD_ADDR_EXP 11
16539: PUSH
16540: LD_INT 1
16542: ST_TO_ADDR
// end ;
16543: PPOPN 5
16545: END
// export function IbrahimQuery ; begin
16546: LD_INT 0
16548: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16549: LD_STRING IbrahimQuery
16551: PPUSH
16552: CALL_OW 97
16556: PUSH
16557: LD_INT 1
16559: DOUBLE
16560: EQUAL
16561: IFTRUE 16565
16563: GO 16847
16565: POP
// begin allowConvoys := false ;
16566: LD_ADDR_EXP 11
16570: PUSH
16571: LD_INT 0
16573: ST_TO_ADDR
// ibrahimInDepot := false ;
16574: LD_ADDR_EXP 23
16578: PUSH
16579: LD_INT 0
16581: ST_TO_ADDR
// InGameOn ;
16582: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16586: LD_EXP 26
16590: PPUSH
16591: CALL_OW 87
// wait ( 0 0$1 ) ;
16595: LD_INT 35
16597: PPUSH
16598: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16602: LD_EXP 26
16606: PPUSH
16607: LD_STRING DH-1-interrogation
16609: PPUSH
16610: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16614: LD_EXP 36
16618: PPUSH
16619: LD_STRING DI-1-interrogation
16621: PPUSH
16622: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16626: LD_EXP 26
16630: PPUSH
16631: LD_STRING DH-2-interrogation
16633: PPUSH
16634: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16638: LD_EXP 36
16642: PPUSH
16643: LD_STRING DI-2-interrogation
16645: PPUSH
16646: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16650: LD_EXP 26
16654: PPUSH
16655: LD_STRING DH-3-interrogation
16657: PPUSH
16658: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16662: LD_EXP 36
16666: PPUSH
16667: LD_STRING DI-3-interrogation
16669: PPUSH
16670: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16674: LD_EXP 26
16678: PPUSH
16679: LD_STRING DH-4-interrogation
16681: PPUSH
16682: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16686: LD_EXP 36
16690: PPUSH
16691: LD_STRING DI-4-interrogation
16693: PPUSH
16694: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16698: LD_EXP 26
16702: PPUSH
16703: LD_STRING DH-5-interrogation
16705: PPUSH
16706: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16710: LD_EXP 36
16714: PPUSH
16715: LD_STRING DI-5-interrogation
16717: PPUSH
16718: CALL_OW 88
// wait ( 0 0$1 ) ;
16722: LD_INT 35
16724: PPUSH
16725: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16729: LD_STRING IbrahimDecisionQuery
16731: PPUSH
16732: CALL_OW 97
16736: PUSH
16737: LD_INT 1
16739: DOUBLE
16740: EQUAL
16741: IFTRUE 16745
16743: GO 16769
16745: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16746: LD_EXP 36
16750: PPUSH
16751: LD_STRING DI-1-kill
16753: PPUSH
16754: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16758: LD_EXP 36
16762: PPUSH
16763: CALL_OW 66
// end ; 2 :
16767: GO 16841
16769: LD_INT 2
16771: DOUBLE
16772: EQUAL
16773: IFTRUE 16777
16775: GO 16840
16777: POP
// begin SetSide ( Ibrahim , 6 ) ;
16778: LD_EXP 36
16782: PPUSH
16783: LD_INT 6
16785: PPUSH
16786: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16790: LD_EXP 36
16794: PPUSH
16795: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16799: LD_EXP 36
16803: PPUSH
16804: LD_INT 32
16806: PPUSH
16807: LD_INT 5
16809: PPUSH
16810: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16814: LD_EXP 26
16818: PPUSH
16819: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16823: LD_EXP 26
16827: PPUSH
16828: LD_INT 36
16830: PPUSH
16831: LD_INT 21
16833: PPUSH
16834: CALL_OW 171
// end ; end ;
16838: GO 16841
16840: POP
// InGameOff ;
16841: CALL_OW 9
// end ; 2 :
16845: GO 16861
16847: LD_INT 2
16849: DOUBLE
16850: EQUAL
16851: IFTRUE 16855
16853: GO 16860
16855: POP
// exit ; end ;
16856: GO 16899
16858: GO 16861
16860: POP
// allowConvoys := true ;
16861: LD_ADDR_EXP 11
16865: PUSH
16866: LD_INT 1
16868: ST_TO_ADDR
// wait ( 2 2$40 ) ;
16869: LD_INT 5600
16871: PPUSH
16872: CALL_OW 67
// ComMoveXY ( Ibrahim , 38 , 28 ) ;
16876: LD_EXP 36
16880: PPUSH
16881: LD_INT 38
16883: PPUSH
16884: LD_INT 28
16886: PPUSH
16887: CALL_OW 111
// ibrahimIsFree := true ;
16891: LD_ADDR_EXP 24
16895: PUSH
16896: LD_INT 1
16898: ST_TO_ADDR
// end ;
16899: LD_VAR 0 1
16903: RET
// every 0 0$1 trigger ibrahimIsFree and IsOk ( Ibrahim ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b , p , depot ;
16904: LD_EXP 24
16908: PUSH
16909: LD_EXP 36
16913: PPUSH
16914: CALL_OW 302
16918: AND
16919: PUSH
16920: LD_INT 22
16922: PUSH
16923: LD_INT 2
16925: PUSH
16926: EMPTY
16927: LIST
16928: LIST
16929: PUSH
16930: LD_INT 50
16932: PUSH
16933: EMPTY
16934: LIST
16935: PUSH
16936: LD_INT 30
16938: PUSH
16939: LD_INT 0
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: PUSH
16946: EMPTY
16947: LIST
16948: LIST
16949: LIST
16950: PPUSH
16951: CALL_OW 69
16955: AND
16956: PUSH
16957: LD_EXP 36
16961: PPUSH
16962: LD_INT 7
16964: PPUSH
16965: CALL_OW 308
16969: AND
16970: PUSH
16971: LD_INT 6
16973: PPUSH
16974: LD_EXP 26
16978: PPUSH
16979: CALL_OW 292
16983: AND
16984: PUSH
16985: LD_INT 22
16987: PUSH
16988: LD_INT 4
16990: PUSH
16991: EMPTY
16992: LIST
16993: LIST
16994: PPUSH
16995: CALL_OW 69
16999: NOT
17000: AND
17001: PUSH
17002: LD_INT 22
17004: PUSH
17005: LD_INT 1
17007: PUSH
17008: EMPTY
17009: LIST
17010: LIST
17011: PUSH
17012: LD_INT 21
17014: PUSH
17015: LD_INT 1
17017: PUSH
17018: EMPTY
17019: LIST
17020: LIST
17021: PUSH
17022: EMPTY
17023: LIST
17024: LIST
17025: PPUSH
17026: CALL_OW 69
17030: NOT
17031: AND
17032: IFFALSE 17687
17034: GO 17036
17036: DISABLE
17037: LD_INT 0
17039: PPUSH
17040: PPUSH
17041: PPUSH
17042: PPUSH
// begin allowConvoys := false ;
17043: LD_ADDR_EXP 11
17047: PUSH
17048: LD_INT 0
17050: ST_TO_ADDR
// depot := usDepot ;
17051: LD_ADDR_VAR 0 4
17055: PUSH
17056: LD_INT 11
17058: ST_TO_ADDR
// if not usDepot then
17059: LD_INT 11
17061: NOT
17062: IFFALSE 17109
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
17064: LD_ADDR_VAR 0 4
17068: PUSH
17069: LD_INT 22
17071: PUSH
17072: LD_INT 2
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PUSH
17079: LD_INT 50
17081: PUSH
17082: EMPTY
17083: LIST
17084: PUSH
17085: LD_INT 30
17087: PUSH
17088: LD_INT 0
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: LIST
17099: PPUSH
17100: CALL_OW 69
17104: PUSH
17105: LD_INT 1
17107: ARRAY
17108: ST_TO_ADDR
// InGameOn ;
17109: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
17113: LD_EXP 36
17117: PPUSH
17118: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
17122: LD_EXP 26
17126: PPUSH
17127: LD_EXP 36
17131: PPUSH
17132: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
17136: LD_EXP 36
17140: PPUSH
17141: LD_EXP 26
17145: PPUSH
17146: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
17150: LD_EXP 36
17154: PPUSH
17155: LD_STRING DI-1-free
17157: PPUSH
17158: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
17162: LD_EXP 26
17166: PPUSH
17167: LD_STRING DH-1-free
17169: PPUSH
17170: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
17174: LD_EXP 36
17178: PPUSH
17179: LD_STRING DI-2-free
17181: PPUSH
17182: CALL_OW 88
// changeClass := 0 ;
17186: LD_ADDR_VAR 0 1
17190: PUSH
17191: LD_INT 0
17193: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
17194: LD_STRING IbrahimJoinQuery
17196: PPUSH
17197: CALL_OW 97
17201: PUSH
17202: LD_INT 1
17204: DOUBLE
17205: EQUAL
17206: IFTRUE 17210
17208: GO 17221
17210: POP
// begin changeClass := 1 ;
17211: LD_ADDR_VAR 0 1
17215: PUSH
17216: LD_INT 1
17218: ST_TO_ADDR
// end ; 2 :
17219: GO 17461
17221: LD_INT 2
17223: DOUBLE
17224: EQUAL
17225: IFTRUE 17229
17227: GO 17381
17229: POP
// begin Say ( Heike , DH-1-decline ) ;
17230: LD_EXP 26
17234: PPUSH
17235: LD_STRING DH-1-decline
17237: PPUSH
17238: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
17242: LD_EXP 36
17246: PPUSH
17247: LD_STRING DI-1-decline
17249: PPUSH
17250: CALL_OW 88
// InGameOff ;
17254: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
17258: LD_EXP 36
17262: PPUSH
17263: LD_INT 30
17265: PPUSH
17266: LD_INT 1
17268: PPUSH
17269: CALL_OW 111
// p := 0 ;
17273: LD_ADDR_VAR 0 3
17277: PUSH
17278: LD_INT 0
17280: ST_TO_ADDR
// repeat p := p + 1 ;
17281: LD_ADDR_VAR 0 3
17285: PUSH
17286: LD_VAR 0 3
17290: PUSH
17291: LD_INT 1
17293: PLUS
17294: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17295: LD_INT 35
17297: PPUSH
17298: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) or p > 10 ;
17302: LD_EXP 36
17306: PPUSH
17307: LD_INT 30
17309: PPUSH
17310: LD_INT 1
17312: PPUSH
17313: CALL_OW 307
17317: PUSH
17318: LD_INT 22
17320: PUSH
17321: LD_INT 2
17323: PUSH
17324: EMPTY
17325: LIST
17326: LIST
17327: PUSH
17328: LD_INT 101
17330: PUSH
17331: LD_INT 6
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: PUSH
17338: EMPTY
17339: LIST
17340: LIST
17341: PPUSH
17342: CALL_OW 69
17346: NOT
17347: OR
17348: PUSH
17349: LD_VAR 0 3
17353: PUSH
17354: LD_INT 10
17356: GREATER
17357: OR
17358: IFFALSE 17281
// RemoveUnit ( Ibrahim ) ;
17360: LD_EXP 36
17364: PPUSH
17365: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17369: LD_INT 1
17371: PPUSH
17372: LD_STRING 03_IbrahimHasEscaped
17374: PPUSH
17375: CALL_OW 39
// end ; 3 :
17379: GO 17461
17381: LD_INT 3
17383: DOUBLE
17384: EQUAL
17385: IFTRUE 17389
17387: GO 17460
17389: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17390: LD_EXP 26
17394: PPUSH
17395: LD_STRING DH-1-radio-hq
17397: PPUSH
17398: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17402: LD_EXP 35
17406: PPUSH
17407: LD_STRING DO-1-radio-hq
17409: PPUSH
17410: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17414: LD_EXP 26
17418: PPUSH
17419: LD_STRING DH-2-radio-hq
17421: PPUSH
17422: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17426: LD_EXP 35
17430: PPUSH
17431: LD_STRING DO-2-radio-hq
17433: PPUSH
17434: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17438: LD_EXP 26
17442: PPUSH
17443: LD_STRING DH-3-radio-hq
17445: PPUSH
17446: CALL_OW 88
// changeClass := 1 ;
17450: LD_ADDR_VAR 0 1
17454: PUSH
17455: LD_INT 1
17457: ST_TO_ADDR
// end ; end ;
17458: GO 17461
17460: POP
// if changeClass then
17461: LD_VAR 0 1
17465: IFFALSE 17687
// begin Say ( Heike , DH-1-agree ) ;
17467: LD_EXP 26
17471: PPUSH
17472: LD_STRING DH-1-agree
17474: PPUSH
17475: CALL_OW 88
// if IsOk ( Givi ) then
17479: LD_EXP 27
17483: PPUSH
17484: CALL_OW 302
17488: IFFALSE 17526
// begin Say ( Givi , DG-1-agree ) ;
17490: LD_EXP 27
17494: PPUSH
17495: LD_STRING DG-1-agree
17497: PPUSH
17498: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17502: LD_EXP 26
17506: PPUSH
17507: LD_STRING DH-2-agree
17509: PPUSH
17510: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17514: LD_EXP 27
17518: PPUSH
17519: LD_STRING DG-2-agree
17521: PPUSH
17522: CALL_OW 88
// end ; if UnitsInside ( depot ) = 6 then
17526: LD_VAR 0 4
17530: PPUSH
17531: CALL_OW 313
17535: PUSH
17536: LD_INT 6
17538: EQUAL
17539: IFFALSE 17559
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
17541: LD_VAR 0 4
17545: PPUSH
17546: CALL_OW 313
17550: PUSH
17551: LD_INT 1
17553: ARRAY
17554: PPUSH
17555: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17559: LD_EXP 36
17563: PPUSH
17564: LD_INT 2
17566: PPUSH
17567: CALL_OW 235
// ComEnterUnit ( Ibrahim , depot ) ;
17571: LD_EXP 36
17575: PPUSH
17576: LD_VAR 0 4
17580: PPUSH
17581: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17585: LD_INT 35
17587: PPUSH
17588: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17592: LD_EXP 36
17596: PPUSH
17597: CALL_OW 310
17601: IFFALSE 17585
// b := IsInUnit ( Ibrahim ) ;
17603: LD_ADDR_VAR 0 2
17607: PUSH
17608: LD_EXP 36
17612: PPUSH
17613: CALL_OW 310
17617: ST_TO_ADDR
// RemoveUnit ( Ibrahim ) ;
17618: LD_EXP 36
17622: PPUSH
17623: CALL_OW 64
// uc_side := 2 ;
17627: LD_ADDR_OWVAR 20
17631: PUSH
17632: LD_INT 2
17634: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17635: LD_ADDR_EXP 36
17639: PUSH
17640: LD_STRING Ibrahim
17642: PPUSH
17643: LD_INT 0
17645: PPUSH
17646: LD_STRING 
17648: PPUSH
17649: CALL 297 0 3
17653: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , b ) ;
17654: LD_EXP 36
17658: PPUSH
17659: LD_VAR 0 2
17663: PPUSH
17664: CALL_OW 52
// InGameOff ;
17668: CALL_OW 9
// allowConvoys := true ;
17672: LD_ADDR_EXP 11
17676: PUSH
17677: LD_INT 1
17679: ST_TO_ADDR
// SetAchievement ( ACH_IBRAHIM ) ;
17680: LD_STRING ACH_IBRAHIM
17682: PPUSH
17683: CALL_OW 543
// end ; end ;
17687: PPOPN 4
17689: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 do
17690: LD_EXP 10
17694: PUSH
17695: LD_EXP 19
17699: PUSH
17700: LD_INT 1
17702: LESS
17703: AND
17704: IFFALSE 18095
17706: GO 17708
17708: DISABLE
// begin DialogueOn ;
17709: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
17713: LD_EXP 26
17717: PPUSH
17718: LD_STRING DH-1-final
17720: PPUSH
17721: CALL_OW 88
// if tick <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
17725: LD_OWVAR 1
17729: PUSH
17730: LD_INT 126000
17732: PUSH
17733: LD_INT 115500
17735: PUSH
17736: LD_INT 105000
17738: PUSH
17739: EMPTY
17740: LIST
17741: LIST
17742: LIST
17743: PUSH
17744: LD_OWVAR 67
17748: ARRAY
17749: LESSEQUAL
17750: IFFALSE 17764
// AddMedal ( med1 , 1 ) else
17752: LD_STRING med1
17754: PPUSH
17755: LD_INT 1
17757: PPUSH
17758: CALL_OW 101
17762: GO 17775
// AddMedal ( med1 , - 1 ) ;
17764: LD_STRING med1
17766: PPUSH
17767: LD_INT 1
17769: NEG
17770: PPUSH
17771: CALL_OW 101
// if vehCounter >= 2 then
17775: LD_EXP 20
17779: PUSH
17780: LD_INT 2
17782: GREATEREQUAL
17783: IFFALSE 17797
// AddMedal ( med2 , 1 ) else
17785: LD_STRING med2
17787: PPUSH
17788: LD_INT 1
17790: PPUSH
17791: CALL_OW 101
17795: GO 17808
// AddMedal ( med2 , - 1 ) ;
17797: LD_STRING med2
17799: PPUSH
17800: LD_INT 1
17802: NEG
17803: PPUSH
17804: CALL_OW 101
// if deadCounter = 0 then
17808: LD_EXP 8
17812: PUSH
17813: LD_INT 0
17815: EQUAL
17816: IFFALSE 17830
// AddMedal ( med3 , 1 ) else
17818: LD_STRING med3
17820: PPUSH
17821: LD_INT 1
17823: PPUSH
17824: CALL_OW 101
17828: GO 17841
// AddMedal ( med3 , - 1 ) ;
17830: LD_STRING med3
17832: PPUSH
17833: LD_INT 1
17835: NEG
17836: PPUSH
17837: CALL_OW 101
// GiveMedals ( MAIN ) ;
17841: LD_STRING MAIN
17843: PPUSH
17844: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
17848: LD_INT 22
17850: PUSH
17851: LD_INT 2
17853: PUSH
17854: EMPTY
17855: LIST
17856: LIST
17857: PUSH
17858: LD_INT 23
17860: PUSH
17861: LD_INT 2
17863: PUSH
17864: EMPTY
17865: LIST
17866: LIST
17867: PUSH
17868: LD_INT 21
17870: PUSH
17871: LD_INT 1
17873: PUSH
17874: EMPTY
17875: LIST
17876: LIST
17877: PUSH
17878: EMPTY
17879: LIST
17880: LIST
17881: LIST
17882: PPUSH
17883: CALL_OW 69
17887: PPUSH
17888: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
17892: LD_EXP 26
17896: PPUSH
17897: LD_STRING 03_Heike
17899: PPUSH
17900: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
17904: LD_EXP 30
17908: PPUSH
17909: LD_STRING 03_Aviradze
17911: PPUSH
17912: CALL_OW 38
// if Givi then
17916: LD_EXP 27
17920: IFFALSE 17934
// SaveCharacters ( Givi , 03_Givi ) ;
17922: LD_EXP 27
17926: PPUSH
17927: LD_STRING 03_Givi
17929: PPUSH
17930: CALL_OW 38
// if Mike then
17934: LD_EXP 28
17938: IFFALSE 17952
// SaveCharacters ( Mike , 03_Mike ) ;
17940: LD_EXP 28
17944: PPUSH
17945: LD_STRING 03_Mike
17947: PPUSH
17948: CALL_OW 38
// if Kamil then
17952: LD_EXP 29
17956: IFFALSE 17970
// SaveCharacters ( Kamil , 03_Kamil ) ;
17958: LD_EXP 29
17962: PPUSH
17963: LD_STRING 03_Kamil
17965: PPUSH
17966: CALL_OW 38
// if Kaia then
17970: LD_EXP 31
17974: IFFALSE 17988
// SaveCharacters ( Kaia , 03_Kaia ) ;
17976: LD_EXP 31
17980: PPUSH
17981: LD_STRING 03_Kaia
17983: PPUSH
17984: CALL_OW 38
// if Sophia then
17988: LD_EXP 32
17992: IFFALSE 18006
// SaveCharacters ( Sophia , 03_Sophia ) ;
17994: LD_EXP 32
17998: PPUSH
17999: LD_STRING 03_Sophia
18001: PPUSH
18002: CALL_OW 38
// if Markov then
18006: LD_EXP 33
18010: IFFALSE 18024
// SaveCharacters ( Markov , 03_Markov ) ;
18012: LD_EXP 33
18016: PPUSH
18017: LD_STRING 03_Markov
18019: PPUSH
18020: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
18024: LD_EXP 36
18028: PUSH
18029: LD_EXP 36
18033: PPUSH
18034: CALL_OW 255
18038: PUSH
18039: LD_INT 2
18041: EQUAL
18042: AND
18043: IFFALSE 18057
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
18045: LD_EXP 36
18049: PPUSH
18050: LD_STRING 03_Ibrahim
18052: PPUSH
18053: CALL_OW 38
// if heikeSecondSquad then
18057: LD_EXP 40
18061: IFFALSE 18075
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
18063: LD_EXP 40
18067: PPUSH
18068: LD_STRING 03_others
18070: PPUSH
18071: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
18075: LD_EXP 8
18079: PPUSH
18080: LD_STRING 03_DeadCounter
18082: PPUSH
18083: CALL_OW 39
// YouWin ;
18087: CALL_OW 103
// DialogueOff ;
18091: CALL_OW 7
// end ; end_of_file
18095: END
// on UnitDestroyed ( un ) do begin if un = Heike then
18096: LD_VAR 0 1
18100: PUSH
18101: LD_EXP 26
18105: EQUAL
18106: IFFALSE 18115
// YouLost ( Heike ) ;
18108: LD_STRING Heike
18110: PPUSH
18111: CALL_OW 104
// if un = Aviradze then
18115: LD_VAR 0 1
18119: PUSH
18120: LD_EXP 30
18124: EQUAL
18125: IFFALSE 18134
// YouLost ( Aviradze ) ;
18127: LD_STRING Aviradze
18129: PPUSH
18130: CALL_OW 104
// if un = usDepot and not retreatAllowed then
18134: LD_VAR 0 1
18138: PUSH
18139: LD_INT 11
18141: EQUAL
18142: PUSH
18143: LD_EXP 10
18147: NOT
18148: AND
18149: IFFALSE 18158
// YouLost ( Depot ) ;
18151: LD_STRING Depot
18153: PPUSH
18154: CALL_OW 104
// if un = arDepot then
18158: LD_VAR 0 1
18162: PUSH
18163: LD_INT 5
18165: EQUAL
18166: IFFALSE 18175
// YouLost ( FarmerDepot ) ;
18168: LD_STRING FarmerDepot
18170: PPUSH
18171: CALL_OW 104
// if un = Farmer then
18175: LD_VAR 0 1
18179: PUSH
18180: LD_EXP 34
18184: EQUAL
18185: IFFALSE 18194
// YouLost ( Farmer ) ;
18187: LD_STRING Farmer
18189: PPUSH
18190: CALL_OW 104
// if un in usForces then
18194: LD_VAR 0 1
18198: PUSH
18199: LD_EXP 42
18203: IN
18204: IFFALSE 18222
// usForces := usForces diff un ;
18206: LD_ADDR_EXP 42
18210: PUSH
18211: LD_EXP 42
18215: PUSH
18216: LD_VAR 0 1
18220: DIFF
18221: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
18222: LD_VAR 0 1
18226: PUSH
18227: LD_INT 22
18229: PUSH
18230: LD_INT 2
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: PUSH
18237: LD_INT 23
18239: PUSH
18240: LD_INT 2
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: PUSH
18247: LD_INT 21
18249: PUSH
18250: LD_INT 1
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: LIST
18261: PPUSH
18262: CALL_OW 69
18266: IN
18267: IFFALSE 18283
// deadCounter := deadCounter + 1 ;
18269: LD_ADDR_EXP 8
18273: PUSH
18274: LD_EXP 8
18278: PUSH
18279: LD_INT 1
18281: PLUS
18282: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
18283: LD_VAR 0 1
18287: PUSH
18288: LD_INT 22
18290: PUSH
18291: LD_INT 4
18293: PUSH
18294: EMPTY
18295: LIST
18296: LIST
18297: PUSH
18298: LD_INT 34
18300: PUSH
18301: LD_INT 12
18303: PUSH
18304: EMPTY
18305: LIST
18306: LIST
18307: PUSH
18308: EMPTY
18309: LIST
18310: LIST
18311: PPUSH
18312: CALL_OW 69
18316: IN
18317: PUSH
18318: LD_EXP 16
18322: NOT
18323: AND
18324: IFFALSE 18334
// firstConvoyDestroyed := true ;
18326: LD_ADDR_EXP 16
18330: PUSH
18331: LD_INT 1
18333: ST_TO_ADDR
// if un in usAttackers then
18334: LD_VAR 0 1
18338: PUSH
18339: LD_EXP 45
18343: IN
18344: IFFALSE 18362
// usAttackers := usAttackers diff un ;
18346: LD_ADDR_EXP 45
18350: PUSH
18351: LD_EXP 45
18355: PUSH
18356: LD_VAR 0 1
18360: DIFF
18361: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) then
18362: LD_VAR 0 1
18366: PUSH
18367: LD_INT 22
18369: PUSH
18370: LD_INT 5
18372: PUSH
18373: EMPTY
18374: LIST
18375: LIST
18376: PUSH
18377: LD_INT 21
18379: PUSH
18380: LD_INT 1
18382: PUSH
18383: EMPTY
18384: LIST
18385: LIST
18386: PUSH
18387: EMPTY
18388: LIST
18389: LIST
18390: PPUSH
18391: CALL_OW 69
18395: IN
18396: IFFALSE 18412
// farmerHumanLoseCounter := farmerHumanLoseCounter + 1 ;
18398: LD_ADDR_EXP 18
18402: PUSH
18403: LD_EXP 18
18407: PUSH
18408: LD_INT 1
18410: PLUS
18411: ST_TO_ADDR
// end ;
18412: PPOPN 1
18414: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18415: LD_VAR 0 2
18419: PUSH
18420: LD_EXP 36
18424: EQUAL
18425: PUSH
18426: LD_EXP 23
18430: AND
18431: IFFALSE 18477
// begin Video ( true ) ;
18433: LD_INT 1
18435: PPUSH
18436: CALL 1020 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
18440: LD_EXP 36
18444: PPUSH
18445: LD_INT 11
18447: PPUSH
18448: CALL_OW 120
// repeat wait ( 3 ) ;
18452: LD_INT 3
18454: PPUSH
18455: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18459: LD_EXP 36
18463: PPUSH
18464: CALL_OW 310
18468: IFFALSE 18452
// Video ( false ) ;
18470: LD_INT 0
18472: PPUSH
18473: CALL 1020 0 1
// end ; end ;
18477: PPOPN 2
18479: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
18480: LD_VAR 0 2
18484: PUSH
18485: LD_EXP 26
18489: EQUAL
18490: PUSH
18491: LD_VAR 0 1
18495: PUSH
18496: LD_INT 11
18498: EQUAL
18499: AND
18500: PUSH
18501: LD_EXP 23
18505: AND
18506: IFFALSE 18512
// IbrahimQuery ;
18508: CALL 16546 0 0
// end ;
18512: PPOPN 2
18514: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin ComStop ( newId ) ;
18515: LD_VAR 0 1
18519: PPUSH
18520: CALL_OW 141
// if oldId in usAttackers then
18524: LD_VAR 0 2
18528: PUSH
18529: LD_EXP 45
18533: IN
18534: IFFALSE 18552
// usAttackers := usAttackers diff oldId ;
18536: LD_ADDR_EXP 45
18540: PUSH
18541: LD_EXP 45
18545: PUSH
18546: LD_VAR 0 2
18550: DIFF
18551: ST_TO_ADDR
// if newId in usAttackers then
18552: LD_VAR 0 1
18556: PUSH
18557: LD_EXP 45
18561: IN
18562: IFFALSE 18580
// usAttackers := usAttackers diff newId ;
18564: LD_ADDR_EXP 45
18568: PUSH
18569: LD_EXP 45
18573: PUSH
18574: LD_VAR 0 1
18578: DIFF
18579: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
18580: LD_VAR 0 3
18584: PUSH
18585: LD_INT 4
18587: EQUAL
18588: PUSH
18589: LD_EXP 16
18593: NOT
18594: AND
18595: IFFALSE 18605
// firstConvoyDestroyed := true ;
18597: LD_ADDR_EXP 16
18601: PUSH
18602: LD_INT 1
18604: ST_TO_ADDR
// if GetWeapon ( newId ) = us_cargo_bay then
18605: LD_VAR 0 1
18609: PPUSH
18610: CALL_OW 264
18614: PUSH
18615: LD_INT 12
18617: EQUAL
18618: IFFALSE 18656
// begin capturedCargoCounter := capturedCargoCounter + 1 ;
18620: LD_ADDR_EXP 12
18624: PUSH
18625: LD_EXP 12
18629: PUSH
18630: LD_INT 1
18632: PLUS
18633: ST_TO_ADDR
// if GetCargo ( newId , mat_cans ) = 0 then
18634: LD_VAR 0 1
18638: PPUSH
18639: LD_INT 1
18641: PPUSH
18642: CALL_OW 289
18646: PUSH
18647: LD_INT 0
18649: EQUAL
18650: IFFALSE 18656
// EmptyCargoDialog ;
18652: CALL 15283 0 0
// end ; end ;
18656: PPOPN 4
18658: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
18659: LD_VAR 0 1
18663: PUSH
18664: LD_INT 2
18666: EQUAL
18667: PUSH
18668: LD_VAR 0 2
18672: PUSH
18673: LD_INT 5
18675: EQUAL
18676: AND
18677: IFFALSE 18686
// YouLost ( Attack ) ;
18679: LD_STRING Attack
18681: PPUSH
18682: CALL_OW 104
// end ;
18686: PPOPN 2
18688: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 and not americanBaseCaptured then
18689: LD_VAR 0 1
18693: PPUSH
18694: CALL_OW 255
18698: PUSH
18699: LD_INT 1
18701: EQUAL
18702: PUSH
18703: LD_EXP 6
18707: NOT
18708: AND
18709: IFFALSE 18843
// begin if GetBType ( b ) = b_lab then
18711: LD_VAR 0 1
18715: PPUSH
18716: CALL_OW 266
18720: PUSH
18721: LD_INT 6
18723: EQUAL
18724: IFFALSE 18764
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
18726: LD_EXP 42
18730: PPUSH
18731: LD_INT 25
18733: PUSH
18734: LD_INT 4
18736: PUSH
18737: EMPTY
18738: LIST
18739: LIST
18740: PPUSH
18741: CALL_OW 72
18745: PPUSH
18746: LD_VAR 0 1
18750: PPUSH
18751: CALL_OW 120
// AmLabResearch ( b ) ;
18755: LD_VAR 0 1
18759: PPUSH
18760: CALL 5990 0 1
// end ; if GetBType ( b ) = b_armoury then
18764: LD_VAR 0 1
18768: PPUSH
18769: CALL_OW 266
18773: PUSH
18774: LD_INT 4
18776: EQUAL
18777: IFFALSE 18825
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
18779: LD_EXP 42
18783: PPUSH
18784: LD_INT 25
18786: PUSH
18787: LD_INT 1
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: PUSH
18794: LD_INT 3
18796: PUSH
18797: LD_INT 54
18799: PUSH
18800: EMPTY
18801: LIST
18802: PUSH
18803: EMPTY
18804: LIST
18805: LIST
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: PPUSH
18811: CALL_OW 72
18815: PPUSH
18816: LD_VAR 0 1
18820: PPUSH
18821: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
18825: LD_ADDR_EXP 44
18829: PUSH
18830: LD_EXP 44
18834: PPUSH
18835: LD_INT 1
18837: PPUSH
18838: CALL_OW 3
18842: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
18843: LD_VAR 0 1
18847: PPUSH
18848: CALL_OW 255
18852: PUSH
18853: LD_INT 5
18855: EQUAL
18856: IFFALSE 18870
// SetBLevel ( b , 5 ) ;
18858: LD_VAR 0 1
18862: PPUSH
18863: LD_INT 5
18865: PPUSH
18866: CALL_OW 241
// end ;
18870: PPOPN 1
18872: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
18873: LD_VAR 0 1
18877: PPUSH
18878: CALL_OW 255
18882: PUSH
18883: LD_INT 2
18885: EQUAL
18886: IFFALSE 18902
// vehCounter := vehCounter + 1 ;
18888: LD_ADDR_EXP 20
18892: PUSH
18893: LD_EXP 20
18897: PUSH
18898: LD_INT 1
18900: PLUS
18901: ST_TO_ADDR
// end ;
18902: PPOPN 2
18904: END
// on SailEvent ( event ) do begin if event = eventAttack then
18905: LD_VAR 0 1
18909: PUSH
18910: LD_EXP 22
18914: EQUAL
18915: IFFALSE 18921
// AmericanAttack ;
18917: CALL 7447 0 0
// end ; end_of_file
18921: PPOPN 1
18923: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 4 4$00 , 3 3$00 , 2 2$30 ] [ Difficulty ] do
18924: LD_OWVAR 1
18928: PUSH
18929: LD_INT 8400
18931: PUSH
18932: LD_INT 6300
18934: PUSH
18935: LD_INT 5250
18937: PUSH
18938: EMPTY
18939: LIST
18940: LIST
18941: LIST
18942: PUSH
18943: LD_OWVAR 67
18947: ARRAY
18948: LESSEQUAL
18949: IFFALSE 18976
18951: GO 18953
18953: DISABLE
// begin enable ;
18954: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18955: LD_INT 1
18957: PPUSH
18958: LD_INT 5
18960: PPUSH
18961: CALL_OW 12
18965: PPUSH
18966: LD_INT 9
18968: PPUSH
18969: LD_INT 1
18971: PPUSH
18972: CALL_OW 55
// end ;
18976: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 26 26$00 , 23 23$00 , 20 20$00 ] [ Difficulty ] do
18977: LD_EXP 6
18981: PUSH
18982: LD_OWVAR 1
18986: PUSH
18987: LD_INT 54600
18989: PUSH
18990: LD_INT 48300
18992: PUSH
18993: LD_INT 42000
18995: PUSH
18996: EMPTY
18997: LIST
18998: LIST
18999: LIST
19000: PUSH
19001: LD_OWVAR 67
19005: ARRAY
19006: LESSEQUAL
19007: AND
19008: IFFALSE 19035
19010: GO 19012
19012: DISABLE
// begin enable ;
19013: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
19014: LD_INT 1
19016: PPUSH
19017: LD_INT 5
19019: PPUSH
19020: CALL_OW 12
19024: PPUSH
19025: LD_INT 9
19027: PPUSH
19028: LD_INT 1
19030: PPUSH
19031: CALL_OW 55
// end ; end_of_file
19035: END
// every 0 0$1 trigger not retreatAllowed and farmerRequestedCrates and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
19036: LD_EXP 10
19040: NOT
19041: PUSH
19042: LD_EXP 14
19046: AND
19047: PUSH
19048: LD_EXP 4
19052: AND
19053: PUSH
19054: LD_EXP 13
19058: PUSH
19059: LD_EXP 14
19063: LESSEQUAL
19064: AND
19065: IFFALSE 19155
19067: GO 19069
19069: DISABLE
// begin enable ;
19070: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
19071: LD_ADDR_OWVAR 47
19075: PUSH
19076: LD_STRING #X103-1
19078: PUSH
19079: LD_EXP 13
19083: PUSH
19084: LD_EXP 14
19088: PUSH
19089: EMPTY
19090: LIST
19091: LIST
19092: LIST
19093: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
19094: LD_ADDR_EXP 13
19098: PUSH
19099: LD_INT 5
19101: PPUSH
19102: CALL_OW 274
19106: PPUSH
19107: LD_INT 1
19109: PPUSH
19110: CALL_OW 275
19114: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
19115: LD_INT 10
19117: PPUSH
19118: LD_INT 1
19120: PPUSH
19121: CALL_OW 287
19125: PUSH
19126: LD_INT 0
19128: EQUAL
19129: IFFALSE 19147
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
19131: LD_ADDR_EXP 15
19135: PUSH
19136: LD_EXP 15
19140: PUSH
19141: LD_INT 35
19143: MINUS
19144: ST_TO_ADDR
19145: GO 19155
// farmerCratesCounter := 30 30$00 ;
19147: LD_ADDR_EXP 15
19151: PUSH
19152: LD_INT 63000
19154: ST_TO_ADDR
// end ; end_of_file
19155: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
19156: GO 19158
19158: DISABLE
// begin ru_radar := 98 ;
19159: LD_ADDR_EXP 46
19163: PUSH
19164: LD_INT 98
19166: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
19167: LD_ADDR_EXP 47
19171: PUSH
19172: LD_INT 89
19174: ST_TO_ADDR
// us_hack := 99 ;
19175: LD_ADDR_EXP 48
19179: PUSH
19180: LD_INT 99
19182: ST_TO_ADDR
// us_artillery := 97 ;
19183: LD_ADDR_EXP 49
19187: PUSH
19188: LD_INT 97
19190: ST_TO_ADDR
// ar_bio_bomb := 91 ;
19191: LD_ADDR_EXP 50
19195: PUSH
19196: LD_INT 91
19198: ST_TO_ADDR
// tech_Artillery := 80 ;
19199: LD_ADDR_EXP 51
19203: PUSH
19204: LD_INT 80
19206: ST_TO_ADDR
// tech_RadMat := 81 ;
19207: LD_ADDR_EXP 52
19211: PUSH
19212: LD_INT 81
19214: ST_TO_ADDR
// tech_BasicTools := 82 ;
19215: LD_ADDR_EXP 53
19219: PUSH
19220: LD_INT 82
19222: ST_TO_ADDR
// tech_Cargo := 83 ;
19223: LD_ADDR_EXP 54
19227: PUSH
19228: LD_INT 83
19230: ST_TO_ADDR
// tech_Track := 84 ;
19231: LD_ADDR_EXP 55
19235: PUSH
19236: LD_INT 84
19238: ST_TO_ADDR
// tech_Crane := 85 ;
19239: LD_ADDR_EXP 56
19243: PUSH
19244: LD_INT 85
19246: ST_TO_ADDR
// tech_Bulldozer := 86 ;
19247: LD_ADDR_EXP 57
19251: PUSH
19252: LD_INT 86
19254: ST_TO_ADDR
// tech_Hovercraft := 87 ;
19255: LD_ADDR_EXP 58
19259: PUSH
19260: LD_INT 87
19262: ST_TO_ADDR
// end ;
19263: END
