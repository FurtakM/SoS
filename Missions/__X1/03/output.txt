// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 25 0 0
// PrepareNature ;
   8: CALL 636 0 0
// PrepareArabian ;
  12: CALL 1951 0 0
// PrepareAmerican ;
  16: CALL 4869 0 0
// Action ;
  20: CALL 9405 0 0
// end ;
  24: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// prefix := 02_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 02_
  43: ST_TO_ADDR
// eventAttack := 1 ;
  44: LD_ADDR_EXP 20
  48: PUSH
  49: LD_INT 1
  51: ST_TO_ADDR
// deadCounter := 0 ;
  52: LD_ADDR_EXP 8
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// gameStarted := false ;
  60: LD_ADDR_EXP 3
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// farmerBaseReady := false ;
  68: LD_ADDR_EXP 4
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// americanBaseSpoted := false ;
  76: LD_ADDR_EXP 5
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// americanBaseCaptured := false ;
  84: LD_ADDR_EXP 6
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// americanHasEscaped := false ;
  92: LD_ADDR_EXP 7
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// workshopBuilded := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// retreatAllowed := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// allowConvoys := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// farmerCrates := 0 ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 63000
 147: PUSH
 148: LD_INT 52500
 150: PUSH
 151: LD_INT 46200
 153: PUSH
 154: EMPTY
 155: LIST
 156: LIST
 157: LIST
 158: PUSH
 159: LD_OWVAR 67
 163: ARRAY
 164: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 165: LD_ADDR_EXP 15
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// attackWave := 1 ;
 173: LD_ADDR_EXP 16
 177: PUSH
 178: LD_INT 1
 180: ST_TO_ADDR
// omarCargoCounter := [ 6 , 9 , 12 ] [ Difficulty ] ;
 181: LD_ADDR_EXP 17
 185: PUSH
 186: LD_INT 6
 188: PUSH
 189: LD_INT 9
 191: PUSH
 192: LD_INT 12
 194: PUSH
 195: EMPTY
 196: LIST
 197: LIST
 198: LIST
 199: PUSH
 200: LD_OWVAR 67
 204: ARRAY
 205: ST_TO_ADDR
// vehCounter := 0 ;
 206: LD_ADDR_EXP 18
 210: PUSH
 211: LD_INT 0
 213: ST_TO_ADDR
// convoyCounter := 0 ;
 214: LD_ADDR_EXP 19
 218: PUSH
 219: LD_INT 0
 221: ST_TO_ADDR
// ibrahimInDepot := false ;
 222: LD_ADDR_EXP 21
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// ibrahimIsFree := false ;
 230: LD_ADDR_EXP 22
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// maxConvoys := [ 16 , 15 , 14 ] [ Difficulty ] ;
 238: LD_ADDR_EXP 23
 242: PUSH
 243: LD_INT 16
 245: PUSH
 246: LD_INT 15
 248: PUSH
 249: LD_INT 14
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: PUSH
 257: LD_OWVAR 67
 261: ARRAY
 262: ST_TO_ADDR
// end ; end_of_file
 263: LD_VAR 0 1
 267: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 268: LD_INT 0
 270: PPUSH
 271: PPUSH
// if exist_mode then
 272: LD_VAR 0 2
 276: IFFALSE 301
// unit := CreateCharacter ( prefix & ident ) else
 278: LD_ADDR_VAR 0 5
 282: PUSH
 283: LD_VAR 0 3
 287: PUSH
 288: LD_VAR 0 1
 292: STR
 293: PPUSH
 294: CALL_OW 34
 298: ST_TO_ADDR
 299: GO 316
// unit := NewCharacter ( ident ) ;
 301: LD_ADDR_VAR 0 5
 305: PUSH
 306: LD_VAR 0 1
 310: PPUSH
 311: CALL_OW 25
 315: ST_TO_ADDR
// result := unit ;
 316: LD_ADDR_VAR 0 4
 320: PUSH
 321: LD_VAR 0 5
 325: ST_TO_ADDR
// end ;
 326: LD_VAR 0 4
 330: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 331: LD_INT 0
 333: PPUSH
// uc_side := side ;
 334: LD_ADDR_OWVAR 20
 338: PUSH
 339: LD_VAR 0 1
 343: ST_TO_ADDR
// uc_nation := nation ;
 344: LD_ADDR_OWVAR 21
 348: PUSH
 349: LD_VAR 0 2
 353: ST_TO_ADDR
// vc_chassis := chassis ;
 354: LD_ADDR_OWVAR 37
 358: PUSH
 359: LD_VAR 0 3
 363: ST_TO_ADDR
// vc_engine := engine ;
 364: LD_ADDR_OWVAR 39
 368: PUSH
 369: LD_VAR 0 4
 373: ST_TO_ADDR
// vc_control := control ;
 374: LD_ADDR_OWVAR 38
 378: PUSH
 379: LD_VAR 0 5
 383: ST_TO_ADDR
// vc_weapon := weapon ;
 384: LD_ADDR_OWVAR 40
 388: PUSH
 389: LD_VAR 0 6
 393: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 394: LD_ADDR_OWVAR 41
 398: PUSH
 399: LD_VAR 0 7
 403: ST_TO_ADDR
// result := CreateVehicle ;
 404: LD_ADDR_VAR 0 8
 408: PUSH
 409: CALL_OW 45
 413: ST_TO_ADDR
// end ;
 414: LD_VAR 0 8
 418: RET
// export function SayX ( units , ident ) ; var i ; begin
 419: LD_INT 0
 421: PPUSH
 422: PPUSH
// result := false ;
 423: LD_ADDR_VAR 0 3
 427: PUSH
 428: LD_INT 0
 430: ST_TO_ADDR
// if not units then
 431: LD_VAR 0 1
 435: NOT
 436: IFFALSE 440
// exit ;
 438: GO 494
// for i in units do
 440: LD_ADDR_VAR 0 4
 444: PUSH
 445: LD_VAR 0 1
 449: PUSH
 450: FOR_IN
 451: IFFALSE 492
// if IsOk ( i ) then
 453: LD_VAR 0 4
 457: PPUSH
 458: CALL_OW 302
 462: IFFALSE 490
// begin Say ( i , ident ) ;
 464: LD_VAR 0 4
 468: PPUSH
 469: LD_VAR 0 2
 473: PPUSH
 474: CALL_OW 88
// result := i ;
 478: LD_ADDR_VAR 0 3
 482: PUSH
 483: LD_VAR 0 4
 487: ST_TO_ADDR
// break ;
 488: GO 492
// end ;
 490: GO 450
 492: POP
 493: POP
// end ;
 494: LD_VAR 0 3
 498: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 499: LD_INT 0
 501: PPUSH
 502: PPUSH
// InitUc ;
 503: CALL_OW 18
// InitHc ;
 507: CALL_OW 19
// uc_side := 0 ;
 511: LD_ADDR_OWVAR 20
 515: PUSH
 516: LD_INT 0
 518: ST_TO_ADDR
// uc_nation := 0 ;
 519: LD_ADDR_OWVAR 21
 523: PUSH
 524: LD_INT 0
 526: ST_TO_ADDR
// for i = 1 to amount do
 527: LD_ADDR_VAR 0 4
 531: PUSH
 532: DOUBLE
 533: LD_INT 1
 535: DEC
 536: ST_TO_ADDR
 537: LD_VAR 0 2
 541: PUSH
 542: FOR_TO
 543: IFFALSE 625
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 545: LD_ADDR_OWVAR 29
 549: PUSH
 550: LD_INT 9
 552: PPUSH
 553: LD_INT 12
 555: PPUSH
 556: CALL_OW 12
 560: PUSH
 561: LD_INT 9
 563: PPUSH
 564: LD_INT 12
 566: PPUSH
 567: CALL_OW 12
 571: PUSH
 572: EMPTY
 573: LIST
 574: LIST
 575: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 576: LD_ADDR_OWVAR 35
 580: PUSH
 581: LD_INT 1
 583: NEG
 584: PPUSH
 585: LD_INT 1
 587: PPUSH
 588: CALL_OW 12
 592: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 593: LD_INT 0
 595: PPUSH
 596: LD_INT 12
 598: PPUSH
 599: LD_INT 1
 601: PPUSH
 602: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 606: CALL_OW 44
 610: PPUSH
 611: LD_VAR 0 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL_OW 49
// end ;
 623: GO 542
 625: POP
 626: POP
// InitHc ;
 627: CALL_OW 19
// end ;
 631: LD_VAR 0 3
 635: RET
// export function PrepareNature ; var i ; begin
 636: LD_INT 0
 638: PPUSH
 639: PPUSH
// SpawnApeman ( forest , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
 640: LD_INT 2
 642: PPUSH
 643: LD_INT 4
 645: PUSH
 646: LD_INT 4
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: EMPTY
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: LD_OWVAR 67
 661: ARRAY
 662: PPUSH
 663: CALL 499 0 2
// for i := 1 to 3 do
 667: LD_ADDR_VAR 0 2
 671: PUSH
 672: DOUBLE
 673: LD_INT 1
 675: DEC
 676: ST_TO_ADDR
 677: LD_INT 3
 679: PUSH
 680: FOR_TO
 681: IFFALSE 716
// begin hc_class := 21 ;
 683: LD_ADDR_OWVAR 28
 687: PUSH
 688: LD_INT 21
 690: ST_TO_ADDR
// hc_gallery :=  ;
 691: LD_ADDR_OWVAR 33
 695: PUSH
 696: LD_STRING 
 698: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 699: CALL_OW 44
 703: PPUSH
 704: LD_INT 2
 706: PPUSH
 707: LD_INT 0
 709: PPUSH
 710: CALL_OW 49
// end ;
 714: GO 680
 716: POP
 717: POP
// for i := 1 to 2 do
 718: LD_ADDR_VAR 0 2
 722: PUSH
 723: DOUBLE
 724: LD_INT 1
 726: DEC
 727: ST_TO_ADDR
 728: LD_INT 2
 730: PUSH
 731: FOR_TO
 732: IFFALSE 767
// begin hc_class := 18 ;
 734: LD_ADDR_OWVAR 28
 738: PUSH
 739: LD_INT 18
 741: ST_TO_ADDR
// hc_gallery :=  ;
 742: LD_ADDR_OWVAR 33
 746: PUSH
 747: LD_STRING 
 749: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 750: CALL_OW 44
 754: PPUSH
 755: LD_INT 2
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 49
// end ;
 765: GO 731
 767: POP
 768: POP
// for i := 1 to 2 do
 769: LD_ADDR_VAR 0 2
 773: PUSH
 774: DOUBLE
 775: LD_INT 1
 777: DEC
 778: ST_TO_ADDR
 779: LD_INT 2
 781: PUSH
 782: FOR_TO
 783: IFFALSE 818
// begin hc_class := 13 ;
 785: LD_ADDR_OWVAR 28
 789: PUSH
 790: LD_INT 13
 792: ST_TO_ADDR
// hc_gallery :=  ;
 793: LD_ADDR_OWVAR 33
 797: PUSH
 798: LD_STRING 
 800: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 801: CALL_OW 44
 805: PPUSH
 806: LD_INT 2
 808: PPUSH
 809: LD_INT 0
 811: PPUSH
 812: CALL_OW 49
// end ;
 816: GO 782
 818: POP
 819: POP
// end ;
 820: LD_VAR 0 1
 824: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 825: LD_INT 0
 827: PPUSH
 828: PPUSH
 829: PPUSH
// if not observer or not unit then
 830: LD_VAR 0 1
 834: NOT
 835: PUSH
 836: LD_VAR 0 2
 840: NOT
 841: OR
 842: IFFALSE 846
// exit ;
 844: GO 894
// if not See ( GetSide ( observer ) , unit ) then
 846: LD_VAR 0 1
 850: PPUSH
 851: CALL_OW 255
 855: PPUSH
 856: LD_VAR 0 2
 860: PPUSH
 861: CALL_OW 292
 865: NOT
 866: IFFALSE 870
// exit ;
 868: GO 894
// result := GetDistUnits ( observer , unit ) < 12 ;
 870: LD_ADDR_VAR 0 3
 874: PUSH
 875: LD_VAR 0 1
 879: PPUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 296
 889: PUSH
 890: LD_INT 12
 892: LESS
 893: ST_TO_ADDR
// end ;
 894: LD_VAR 0 3
 898: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 899: LD_INT 0
 901: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 1
 909: ARRAY
 910: PPUSH
 911: LD_VAR 0 2
 915: PUSH
 916: LD_INT 2
 918: ARRAY
 919: PPUSH
 920: CALL_OW 488
 924: PUSH
 925: LD_VAR 0 2
 929: PUSH
 930: LD_INT 1
 932: ARRAY
 933: PPUSH
 934: LD_VAR 0 2
 938: PUSH
 939: LD_INT 2
 941: ARRAY
 942: PPUSH
 943: CALL_OW 428
 947: PUSH
 948: LD_INT 0
 950: EQUAL
 951: AND
 952: IFFALSE 986
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 954: LD_VAR 0 1
 958: PPUSH
 959: LD_VAR 0 2
 963: PUSH
 964: LD_INT 1
 966: ARRAY
 967: PPUSH
 968: LD_VAR 0 2
 972: PUSH
 973: LD_INT 2
 975: ARRAY
 976: PPUSH
 977: LD_VAR 0 3
 981: PPUSH
 982: CALL_OW 48
// end ;
 986: LD_VAR 0 4
 990: RET
// export function Video ( mode ) ; begin
 991: LD_INT 0
 993: PPUSH
// ingame_video = mode ;
 994: LD_ADDR_OWVAR 52
 998: PUSH
 999: LD_VAR 0 1
1003: ST_TO_ADDR
// interface_hidden = mode ;
1004: LD_ADDR_OWVAR 54
1008: PUSH
1009: LD_VAR 0 1
1013: ST_TO_ADDR
// end ;
1014: LD_VAR 0 2
1018: RET
// export function ReverseArray ( array ) ; var i ; begin
1019: LD_INT 0
1021: PPUSH
1022: PPUSH
// if not array then
1023: LD_VAR 0 1
1027: NOT
1028: IFFALSE 1032
// exit ;
1030: GO 1090
// result := [ ] ;
1032: LD_ADDR_VAR 0 2
1036: PUSH
1037: EMPTY
1038: ST_TO_ADDR
// for i := 1 to array do
1039: LD_ADDR_VAR 0 3
1043: PUSH
1044: DOUBLE
1045: LD_INT 1
1047: DEC
1048: ST_TO_ADDR
1049: LD_VAR 0 1
1053: PUSH
1054: FOR_TO
1055: IFFALSE 1088
// result := Insert ( result , 1 , array [ i ] ) ;
1057: LD_ADDR_VAR 0 2
1061: PUSH
1062: LD_VAR 0 2
1066: PPUSH
1067: LD_INT 1
1069: PPUSH
1070: LD_VAR 0 1
1074: PUSH
1075: LD_VAR 0 3
1079: ARRAY
1080: PPUSH
1081: CALL_OW 2
1085: ST_TO_ADDR
1086: GO 1054
1088: POP
1089: POP
// end ;
1090: LD_VAR 0 2
1094: RET
// export function ComExit ( unit ) ; begin
1095: LD_INT 0
1097: PPUSH
// result := IsInUnit ( unit ) ;
1098: LD_ADDR_VAR 0 2
1102: PUSH
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 310
1112: ST_TO_ADDR
// if not result then
1113: LD_VAR 0 2
1117: NOT
1118: IFFALSE 1122
// exit ;
1120: GO 1157
// if GetType ( result ) = unit_vehicle then
1122: LD_VAR 0 2
1126: PPUSH
1127: CALL_OW 247
1131: PUSH
1132: LD_INT 2
1134: EQUAL
1135: IFFALSE 1148
// ComExitVehicle ( unit ) else
1137: LD_VAR 0 1
1141: PPUSH
1142: CALL_OW 121
1146: GO 1157
// ComExitBuilding ( unit ) ;
1148: LD_VAR 0 1
1152: PPUSH
1153: CALL_OW 122
// end ;
1157: LD_VAR 0 2
1161: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1162: LD_INT 0
1164: PPUSH
1165: PPUSH
// if not side or not nation then
1166: LD_VAR 0 1
1170: NOT
1171: PUSH
1172: LD_VAR 0 2
1176: NOT
1177: OR
1178: IFFALSE 1182
// exit ;
1180: GO 1946
// case nation of nation_american :
1182: LD_VAR 0 2
1186: PUSH
1187: LD_INT 1
1189: DOUBLE
1190: EQUAL
1191: IFTRUE 1195
1193: GO 1409
1195: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1196: LD_ADDR_VAR 0 4
1200: PUSH
1201: LD_INT 35
1203: PUSH
1204: LD_INT 45
1206: PUSH
1207: LD_INT 46
1209: PUSH
1210: LD_INT 47
1212: PUSH
1213: LD_INT 82
1215: PUSH
1216: LD_INT 83
1218: PUSH
1219: LD_INT 84
1221: PUSH
1222: LD_INT 85
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: LD_INT 6
1236: PUSH
1237: LD_INT 15
1239: PUSH
1240: LD_INT 16
1242: PUSH
1243: LD_INT 7
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: LD_INT 10
1254: PUSH
1255: LD_INT 14
1257: PUSH
1258: LD_INT 20
1260: PUSH
1261: LD_INT 21
1263: PUSH
1264: LD_INT 22
1266: PUSH
1267: LD_INT 25
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 27
1275: PUSH
1276: LD_INT 36
1278: PUSH
1279: LD_INT 69
1281: PUSH
1282: LD_INT 39
1284: PUSH
1285: LD_INT 34
1287: PUSH
1288: LD_INT 40
1290: PUSH
1291: LD_INT 48
1293: PUSH
1294: LD_INT 49
1296: PUSH
1297: LD_INT 50
1299: PUSH
1300: LD_INT 51
1302: PUSH
1303: LD_INT 52
1305: PUSH
1306: LD_INT 53
1308: PUSH
1309: LD_INT 54
1311: PUSH
1312: LD_INT 55
1314: PUSH
1315: LD_INT 56
1317: PUSH
1318: LD_INT 57
1320: PUSH
1321: LD_INT 58
1323: PUSH
1324: LD_INT 59
1326: PUSH
1327: LD_INT 60
1329: PUSH
1330: LD_INT 61
1332: PUSH
1333: LD_INT 62
1335: PUSH
1336: LD_INT 80
1338: PUSH
1339: LD_INT 82
1341: PUSH
1342: LD_INT 83
1344: PUSH
1345: LD_INT 84
1347: PUSH
1348: LD_INT 85
1350: PUSH
1351: LD_INT 86
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: LIST
1366: LIST
1367: LIST
1368: LIST
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: ST_TO_ADDR
1407: GO 1870
1409: LD_INT 2
1411: DOUBLE
1412: EQUAL
1413: IFTRUE 1417
1415: GO 1639
1417: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1418: LD_ADDR_VAR 0 4
1422: PUSH
1423: LD_INT 35
1425: PUSH
1426: LD_INT 45
1428: PUSH
1429: LD_INT 46
1431: PUSH
1432: LD_INT 47
1434: PUSH
1435: LD_INT 82
1437: PUSH
1438: LD_INT 83
1440: PUSH
1441: LD_INT 84
1443: PUSH
1444: LD_INT 85
1446: PUSH
1447: LD_INT 87
1449: PUSH
1450: LD_INT 70
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 11
1458: PUSH
1459: LD_INT 3
1461: PUSH
1462: LD_INT 4
1464: PUSH
1465: LD_INT 5
1467: PUSH
1468: LD_INT 6
1470: PUSH
1471: LD_INT 15
1473: PUSH
1474: LD_INT 18
1476: PUSH
1477: LD_INT 7
1479: PUSH
1480: LD_INT 17
1482: PUSH
1483: LD_INT 8
1485: PUSH
1486: LD_INT 20
1488: PUSH
1489: LD_INT 21
1491: PUSH
1492: LD_INT 22
1494: PUSH
1495: LD_INT 72
1497: PUSH
1498: LD_INT 26
1500: PUSH
1501: LD_INT 69
1503: PUSH
1504: LD_INT 39
1506: PUSH
1507: LD_INT 40
1509: PUSH
1510: LD_INT 41
1512: PUSH
1513: LD_INT 42
1515: PUSH
1516: LD_INT 43
1518: PUSH
1519: LD_INT 48
1521: PUSH
1522: LD_INT 49
1524: PUSH
1525: LD_INT 50
1527: PUSH
1528: LD_INT 51
1530: PUSH
1531: LD_INT 52
1533: PUSH
1534: LD_INT 53
1536: PUSH
1537: LD_INT 54
1539: PUSH
1540: LD_INT 55
1542: PUSH
1543: LD_INT 56
1545: PUSH
1546: LD_INT 60
1548: PUSH
1549: LD_INT 61
1551: PUSH
1552: LD_INT 62
1554: PUSH
1555: LD_INT 66
1557: PUSH
1558: LD_INT 67
1560: PUSH
1561: LD_INT 68
1563: PUSH
1564: LD_INT 81
1566: PUSH
1567: LD_INT 82
1569: PUSH
1570: LD_INT 83
1572: PUSH
1573: LD_INT 84
1575: PUSH
1576: LD_INT 85
1578: PUSH
1579: LD_INT 87
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: LIST
1588: LIST
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: LIST
1594: LIST
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: LIST
1610: LIST
1611: LIST
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: LIST
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: ST_TO_ADDR
1637: GO 1870
1639: LD_INT 3
1641: DOUBLE
1642: EQUAL
1643: IFTRUE 1647
1645: GO 1869
1647: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1648: LD_ADDR_VAR 0 4
1652: PUSH
1653: LD_INT 46
1655: PUSH
1656: LD_INT 47
1658: PUSH
1659: LD_INT 1
1661: PUSH
1662: LD_INT 2
1664: PUSH
1665: LD_INT 82
1667: PUSH
1668: LD_INT 83
1670: PUSH
1671: LD_INT 84
1673: PUSH
1674: LD_INT 85
1676: PUSH
1677: LD_INT 86
1679: PUSH
1680: LD_INT 11
1682: PUSH
1683: LD_INT 9
1685: PUSH
1686: LD_INT 20
1688: PUSH
1689: LD_INT 19
1691: PUSH
1692: LD_INT 21
1694: PUSH
1695: LD_INT 24
1697: PUSH
1698: LD_INT 22
1700: PUSH
1701: LD_INT 25
1703: PUSH
1704: LD_INT 28
1706: PUSH
1707: LD_INT 29
1709: PUSH
1710: LD_INT 30
1712: PUSH
1713: LD_INT 31
1715: PUSH
1716: LD_INT 37
1718: PUSH
1719: LD_INT 38
1721: PUSH
1722: LD_INT 32
1724: PUSH
1725: LD_INT 27
1727: PUSH
1728: LD_INT 33
1730: PUSH
1731: LD_INT 69
1733: PUSH
1734: LD_INT 39
1736: PUSH
1737: LD_INT 34
1739: PUSH
1740: LD_INT 40
1742: PUSH
1743: LD_INT 71
1745: PUSH
1746: LD_INT 23
1748: PUSH
1749: LD_INT 44
1751: PUSH
1752: LD_INT 48
1754: PUSH
1755: LD_INT 49
1757: PUSH
1758: LD_INT 50
1760: PUSH
1761: LD_INT 51
1763: PUSH
1764: LD_INT 52
1766: PUSH
1767: LD_INT 53
1769: PUSH
1770: LD_INT 54
1772: PUSH
1773: LD_INT 55
1775: PUSH
1776: LD_INT 56
1778: PUSH
1779: LD_INT 57
1781: PUSH
1782: LD_INT 58
1784: PUSH
1785: LD_INT 59
1787: PUSH
1788: LD_INT 63
1790: PUSH
1791: LD_INT 64
1793: PUSH
1794: LD_INT 65
1796: PUSH
1797: LD_INT 82
1799: PUSH
1800: LD_INT 83
1802: PUSH
1803: LD_INT 84
1805: PUSH
1806: LD_INT 85
1808: PUSH
1809: LD_INT 86
1811: PUSH
1812: EMPTY
1813: LIST
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: ST_TO_ADDR
1867: GO 1870
1869: POP
// if state > - 1 and state < 3 then
1870: LD_VAR 0 3
1874: PUSH
1875: LD_INT 1
1877: NEG
1878: GREATER
1879: PUSH
1880: LD_VAR 0 3
1884: PUSH
1885: LD_INT 3
1887: LESS
1888: AND
1889: IFFALSE 1946
// for i in result do
1891: LD_ADDR_VAR 0 5
1895: PUSH
1896: LD_VAR 0 4
1900: PUSH
1901: FOR_IN
1902: IFFALSE 1944
// if GetTech ( i , side ) <> state then
1904: LD_VAR 0 5
1908: PPUSH
1909: LD_VAR 0 1
1913: PPUSH
1914: CALL_OW 321
1918: PUSH
1919: LD_VAR 0 3
1923: NONEQUAL
1924: IFFALSE 1942
// result := result diff i ;
1926: LD_ADDR_VAR 0 4
1930: PUSH
1931: LD_VAR 0 4
1935: PUSH
1936: LD_VAR 0 5
1940: DIFF
1941: ST_TO_ADDR
1942: GO 1901
1944: POP
1945: POP
// end ; end_of_file
1946: LD_VAR 0 4
1950: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1951: LD_INT 0
1953: PPUSH
1954: PPUSH
1955: PPUSH
1956: PPUSH
// uc_side := 5 ;
1957: LD_ADDR_OWVAR 20
1961: PUSH
1962: LD_INT 5
1964: ST_TO_ADDR
// uc_nation := 2 ;
1965: LD_ADDR_OWVAR 21
1969: PUSH
1970: LD_INT 2
1972: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
1973: LD_INT 5
1975: PPUSH
1976: CALL_OW 274
1980: PPUSH
1981: LD_INT 1
1983: PPUSH
1984: LD_INT 45
1986: PPUSH
1987: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
1991: LD_ADDR_EXP 32
1995: PUSH
1996: LD_STRING Farmer
1998: PPUSH
1999: LD_INT 0
2001: PPUSH
2002: LD_STRING 
2004: PPUSH
2005: CALL 268 0 3
2009: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2010: LD_ADDR_EXP 33
2014: PUSH
2015: LD_STRING Omar
2017: PPUSH
2018: LD_INT 0
2020: PPUSH
2021: LD_STRING 
2023: PPUSH
2024: CALL 268 0 3
2028: ST_TO_ADDR
// omarSquad := [ ] ;
2029: LD_ADDR_EXP 36
2033: PUSH
2034: EMPTY
2035: ST_TO_ADDR
// heikeSquad := [ ] ;
2036: LD_ADDR_EXP 37
2040: PUSH
2041: EMPTY
2042: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2043: LD_ADDR_EXP 38
2047: PUSH
2048: EMPTY
2049: ST_TO_ADDR
// omarCargo := [ ] ;
2050: LD_ADDR_EXP 39
2054: PUSH
2055: EMPTY
2056: ST_TO_ADDR
// for i := 1 to 5 do
2057: LD_ADDR_VAR 0 2
2061: PUSH
2062: DOUBLE
2063: LD_INT 1
2065: DEC
2066: ST_TO_ADDR
2067: LD_INT 5
2069: PUSH
2070: FOR_TO
2071: IFFALSE 2229
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2073: LD_INT 0
2075: PPUSH
2076: LD_INT 1
2078: PUSH
2079: LD_INT 1
2081: PUSH
2082: LD_INT 2
2084: PUSH
2085: LD_INT 1
2087: PUSH
2088: LD_INT 1
2090: PUSH
2091: EMPTY
2092: LIST
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_VAR 0 2
2102: ARRAY
2103: PPUSH
2104: LD_INT 3
2106: PPUSH
2107: CALL_OW 380
// un := CreateHuman ;
2111: LD_ADDR_VAR 0 3
2115: PUSH
2116: CALL_OW 44
2120: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2121: LD_ADDR_EXP 36
2125: PUSH
2126: LD_EXP 36
2130: PUSH
2131: LD_VAR 0 3
2135: UNION
2136: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2137: LD_VAR 0 3
2141: PPUSH
2142: LD_INT 87
2144: PUSH
2145: LD_INT 30
2147: PUSH
2148: EMPTY
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 91
2154: PUSH
2155: LD_INT 32
2157: PUSH
2158: EMPTY
2159: LIST
2160: LIST
2161: PUSH
2162: LD_INT 82
2164: PUSH
2165: LD_INT 15
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: PUSH
2172: LD_INT 79
2174: PUSH
2175: LD_INT 14
2177: PUSH
2178: EMPTY
2179: LIST
2180: LIST
2181: PUSH
2182: LD_INT 82
2184: PUSH
2185: LD_INT 13
2187: PUSH
2188: EMPTY
2189: LIST
2190: LIST
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: PUSH
2199: LD_VAR 0 2
2203: ARRAY
2204: PPUSH
2205: LD_INT 0
2207: PPUSH
2208: CALL 899 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2212: LD_VAR 0 3
2216: PPUSH
2217: LD_INT 93
2219: PPUSH
2220: LD_INT 21
2222: PPUSH
2223: CALL_OW 118
// end ;
2227: GO 2070
2229: POP
2230: POP
// uc_side := 2 ;
2231: LD_ADDR_OWVAR 20
2235: PUSH
2236: LD_INT 2
2238: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2239: LD_ADDR_EXP 24
2243: PUSH
2244: LD_STRING Heike
2246: PPUSH
2247: LD_EXP 1
2251: NOT
2252: PPUSH
2253: LD_EXP 2
2257: PPUSH
2258: CALL 268 0 3
2262: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2263: LD_ADDR_EXP 28
2267: PUSH
2268: LD_STRING Aviradze
2270: PPUSH
2271: LD_EXP 1
2275: NOT
2276: PPUSH
2277: LD_EXP 2
2281: PPUSH
2282: CALL 268 0 3
2286: ST_TO_ADDR
// tmp := [ ] ;
2287: LD_ADDR_VAR 0 4
2291: PUSH
2292: EMPTY
2293: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2294: LD_ADDR_EXP 25
2298: PUSH
2299: LD_STRING Givi
2301: PPUSH
2302: LD_EXP 1
2306: NOT
2307: PPUSH
2308: LD_EXP 2
2312: PPUSH
2313: CALL 268 0 3
2317: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2318: LD_ADDR_EXP 26
2322: PUSH
2323: LD_STRING Mike
2325: PPUSH
2326: LD_EXP 1
2330: NOT
2331: PPUSH
2332: LD_EXP 2
2336: PPUSH
2337: CALL 268 0 3
2341: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2342: LD_ADDR_EXP 27
2346: PUSH
2347: LD_STRING Kamil
2349: PPUSH
2350: LD_EXP 1
2354: NOT
2355: PPUSH
2356: LD_EXP 2
2360: PPUSH
2361: CALL 268 0 3
2365: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2366: LD_ADDR_EXP 29
2370: PUSH
2371: LD_STRING Kaia
2373: PPUSH
2374: LD_EXP 1
2378: NOT
2379: PPUSH
2380: LD_EXP 2
2384: PPUSH
2385: CALL 268 0 3
2389: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2390: LD_ADDR_EXP 30
2394: PUSH
2395: LD_STRING Sophia
2397: PPUSH
2398: LD_EXP 1
2402: NOT
2403: PPUSH
2404: LD_EXP 2
2408: PPUSH
2409: CALL 268 0 3
2413: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2414: LD_ADDR_EXP 31
2418: PUSH
2419: LD_STRING Markov
2421: PPUSH
2422: LD_EXP 1
2426: NOT
2427: PPUSH
2428: LD_EXP 2
2432: PPUSH
2433: CALL 268 0 3
2437: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2438: LD_ADDR_EXP 38
2442: PUSH
2443: LD_STRING 02_others
2445: PPUSH
2446: CALL_OW 31
2450: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2451: LD_ADDR_VAR 0 4
2455: PUSH
2456: LD_EXP 26
2460: PUSH
2461: LD_EXP 27
2465: PUSH
2466: LD_EXP 29
2470: PUSH
2471: LD_EXP 30
2475: PUSH
2476: LD_EXP 31
2480: PUSH
2481: LD_EXP 25
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: LIST
2490: LIST
2491: LIST
2492: LIST
2493: PUSH
2494: LD_EXP 38
2498: ADD
2499: PUSH
2500: LD_INT 0
2502: DIFF
2503: ST_TO_ADDR
// heikeSquad := tmp ;
2504: LD_ADDR_EXP 37
2508: PUSH
2509: LD_VAR 0 4
2513: ST_TO_ADDR
// uc_nation := 0 ;
2514: LD_ADDR_OWVAR 21
2518: PUSH
2519: LD_INT 0
2521: ST_TO_ADDR
// hc_class := class_apeman ;
2522: LD_ADDR_OWVAR 28
2526: PUSH
2527: LD_INT 12
2529: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
2530: LD_ADDR_OWVAR 31
2534: PUSH
2535: LD_INT 0
2537: PUSH
2538: LD_INT 0
2540: PUSH
2541: LD_INT 0
2543: PUSH
2544: LD_INT 0
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: ST_TO_ADDR
// hc_gallery :=  ;
2553: LD_ADDR_OWVAR 33
2557: PUSH
2558: LD_STRING 
2560: ST_TO_ADDR
// hc_name :=  ;
2561: LD_ADDR_OWVAR 26
2565: PUSH
2566: LD_STRING 
2568: ST_TO_ADDR
// tmp := tmp union CreateHuman ;
2569: LD_ADDR_VAR 0 4
2573: PUSH
2574: LD_VAR 0 4
2578: PUSH
2579: CALL_OW 44
2583: UNION
2584: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2585: LD_EXP 24
2589: PPUSH
2590: LD_INT 92
2592: PPUSH
2593: LD_INT 17
2595: PPUSH
2596: LD_INT 0
2598: PPUSH
2599: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2603: LD_EXP 32
2607: PPUSH
2608: LD_INT 95
2610: PPUSH
2611: LD_INT 19
2613: PPUSH
2614: LD_INT 0
2616: PPUSH
2617: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2621: LD_EXP 33
2625: PPUSH
2626: LD_INT 89
2628: PPUSH
2629: LD_INT 25
2631: PPUSH
2632: LD_INT 0
2634: PPUSH
2635: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2639: LD_EXP 28
2643: PPUSH
2644: LD_INT 92
2646: PPUSH
2647: LD_INT 27
2649: PPUSH
2650: LD_INT 0
2652: PPUSH
2653: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2657: LD_EXP 33
2661: PPUSH
2662: LD_EXP 28
2666: PPUSH
2667: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2671: LD_EXP 28
2675: PPUSH
2676: LD_EXP 33
2680: PPUSH
2681: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2685: LD_EXP 24
2689: PUSH
2690: LD_EXP 32
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: PPUSH
2699: LD_EXP 33
2703: PPUSH
2704: CALL_OW 119
// if tmp then
2708: LD_VAR 0 4
2712: IFFALSE 2766
// for i in tmp do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: LD_VAR 0 4
2723: PUSH
2724: FOR_IN
2725: IFFALSE 2764
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2727: LD_VAR 0 2
2731: PPUSH
2732: LD_INT 94
2734: PPUSH
2735: LD_INT 14
2737: PPUSH
2738: LD_INT 4
2740: PPUSH
2741: LD_INT 0
2743: PPUSH
2744: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2748: LD_VAR 0 2
2752: PPUSH
2753: LD_EXP 24
2757: PPUSH
2758: CALL_OW 119
// end ;
2762: GO 2724
2764: POP
2765: POP
// farmerSquad := [ ] ;
2766: LD_ADDR_EXP 35
2770: PUSH
2771: EMPTY
2772: ST_TO_ADDR
// uc_side := 5 ;
2773: LD_ADDR_OWVAR 20
2777: PUSH
2778: LD_INT 5
2780: ST_TO_ADDR
// uc_nation := 2 ;
2781: LD_ADDR_OWVAR 21
2785: PUSH
2786: LD_INT 2
2788: ST_TO_ADDR
// for i := 1 to 4 do
2789: LD_ADDR_VAR 0 2
2793: PUSH
2794: DOUBLE
2795: LD_INT 1
2797: DEC
2798: ST_TO_ADDR
2799: LD_INT 4
2801: PUSH
2802: FOR_TO
2803: IFFALSE 2881
// begin PrepareHuman ( false , 1 , 2 ) ;
2805: LD_INT 0
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_INT 2
2813: PPUSH
2814: CALL_OW 380
// un := CreateHuman ;
2818: LD_ADDR_VAR 0 3
2822: PUSH
2823: CALL_OW 44
2827: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2828: LD_VAR 0 3
2832: PPUSH
2833: LD_INT 102
2835: PPUSH
2836: LD_INT 27
2838: PPUSH
2839: LD_INT 4
2841: PPUSH
2842: LD_INT 0
2844: PPUSH
2845: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2849: LD_ADDR_EXP 35
2853: PUSH
2854: LD_EXP 35
2858: PUSH
2859: LD_VAR 0 3
2863: UNION
2864: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2865: LD_VAR 0 3
2869: PPUSH
2870: LD_EXP 33
2874: PPUSH
2875: CALL_OW 119
// end ;
2879: GO 2802
2881: POP
2882: POP
// PrepareHuman ( false , 2 , 2 ) ;
2883: LD_INT 0
2885: PPUSH
2886: LD_INT 2
2888: PPUSH
2889: LD_INT 2
2891: PPUSH
2892: CALL_OW 380
// un := CreateHuman ;
2896: LD_ADDR_VAR 0 3
2900: PUSH
2901: CALL_OW 44
2905: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2906: LD_VAR 0 3
2910: PPUSH
2911: LD_INT 108
2913: PPUSH
2914: LD_INT 62
2916: PPUSH
2917: LD_INT 2
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2927: LD_ADDR_EXP 35
2931: PUSH
2932: LD_EXP 35
2936: PUSH
2937: LD_VAR 0 3
2941: UNION
2942: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2943: LD_VAR 0 3
2947: PPUSH
2948: LD_EXP 33
2952: PPUSH
2953: CALL_OW 119
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
2957: LD_INT 109
2959: PPUSH
2960: LD_INT 63
2962: PPUSH
2963: LD_INT 2
2965: PPUSH
2966: LD_INT 15
2968: NEG
2969: PPUSH
2970: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
2974: LD_INT 109
2976: PPUSH
2977: LD_INT 63
2979: PPUSH
2980: LD_INT 2
2982: PPUSH
2983: CALL_OW 331
// end ;
2987: LD_VAR 0 1
2991: RET
// export function PrepareIbrahim ( x , y ) ; begin
2992: LD_INT 0
2994: PPUSH
// uc_side := 6 ;
2995: LD_ADDR_OWVAR 20
2999: PUSH
3000: LD_INT 6
3002: ST_TO_ADDR
// uc_nation := 3 ;
3003: LD_ADDR_OWVAR 21
3007: PUSH
3008: LD_INT 3
3010: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3011: LD_ADDR_EXP 34
3015: PUSH
3016: LD_STRING IbrahimRu
3018: PPUSH
3019: LD_INT 0
3021: PPUSH
3022: LD_STRING 
3024: PPUSH
3025: CALL 268 0 3
3029: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3030: LD_EXP 34
3034: PPUSH
3035: LD_VAR 0 1
3039: PPUSH
3040: LD_VAR 0 2
3044: PPUSH
3045: LD_INT 8
3047: PPUSH
3048: LD_INT 1
3050: PPUSH
3051: CALL_OW 50
// end ;
3055: LD_VAR 0 3
3059: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3060: LD_EXP 33
3064: PUSH
3065: LD_EXP 36
3069: ADD
3070: PPUSH
3071: LD_INT 95
3073: PUSH
3074: LD_INT 3
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: PPUSH
3081: CALL_OW 72
3085: IFFALSE 3141
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
// begin enable ;
3093: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3094: LD_ADDR_VAR 0 1
3098: PUSH
3099: LD_EXP 33
3103: PUSH
3104: LD_EXP 36
3108: ADD
3109: PPUSH
3110: LD_INT 95
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL_OW 72
3124: PUSH
3125: FOR_IN
3126: IFFALSE 3139
// RemoveUnit ( i ) ;
3128: LD_VAR 0 1
3132: PPUSH
3133: CALL_OW 64
3137: GO 3125
3139: POP
3140: POP
// end ;
3141: PPOPN 1
3143: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3144: LD_EXP 3
3148: PUSH
3149: LD_EXP 32
3153: PPUSH
3154: LD_INT 4
3156: PPUSH
3157: CALL_OW 308
3161: AND
3162: IFFALSE 3945
3164: GO 3166
3166: DISABLE
3167: LD_INT 0
3169: PPUSH
3170: PPUSH
3171: PPUSH
3172: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3173: LD_EXP 32
3177: PPUSH
3178: LD_INT 110
3180: PPUSH
3181: LD_INT 60
3183: PPUSH
3184: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3188: LD_EXP 32
3192: PPUSH
3193: LD_INT 110
3195: PPUSH
3196: LD_INT 61
3198: PPUSH
3199: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3203: LD_ADDR_VAR 0 2
3207: PUSH
3208: LD_EXP 35
3212: PPUSH
3213: LD_INT 25
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL_OW 72
3227: ST_TO_ADDR
// if tmp then
3228: LD_VAR 0 2
3232: IFFALSE 3326
// begin for i := 1 to 2 do
3234: LD_ADDR_VAR 0 1
3238: PUSH
3239: DOUBLE
3240: LD_INT 1
3242: DEC
3243: ST_TO_ADDR
3244: LD_INT 2
3246: PUSH
3247: FOR_TO
3248: IFFALSE 3324
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3250: LD_VAR 0 2
3254: PUSH
3255: LD_VAR 0 1
3259: ARRAY
3260: PPUSH
3261: LD_INT 5
3263: PPUSH
3264: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3268: LD_VAR 0 2
3272: PUSH
3273: LD_VAR 0 1
3277: ARRAY
3278: PPUSH
3279: LD_INT 2
3281: PPUSH
3282: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3286: LD_VAR 0 2
3290: PUSH
3291: LD_VAR 0 1
3295: ARRAY
3296: PPUSH
3297: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3301: LD_VAR 0 2
3305: PUSH
3306: LD_VAR 0 1
3310: ARRAY
3311: PPUSH
3312: LD_INT 107
3314: PPUSH
3315: LD_INT 66
3317: PPUSH
3318: CALL_OW 171
// end ;
3322: GO 3247
3324: POP
3325: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3326: LD_ADDR_VAR 0 2
3330: PUSH
3331: LD_EXP 35
3335: PPUSH
3336: LD_INT 25
3338: PUSH
3339: LD_INT 2
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PPUSH
3346: CALL_OW 72
3350: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3351: LD_INT 35
3353: PPUSH
3354: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3358: LD_ADDR_VAR 0 2
3362: PUSH
3363: LD_EXP 35
3367: PPUSH
3368: LD_INT 25
3370: PUSH
3371: LD_INT 2
3373: PUSH
3374: EMPTY
3375: LIST
3376: LIST
3377: PPUSH
3378: CALL_OW 72
3382: ST_TO_ADDR
// until tmp ;
3383: LD_VAR 0 2
3387: IFFALSE 3351
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3389: LD_VAR 0 2
3393: PPUSH
3394: LD_INT 31
3396: PPUSH
3397: LD_INT 102
3399: PPUSH
3400: LD_INT 69
3402: PPUSH
3403: LD_INT 2
3405: PPUSH
3406: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3410: LD_INT 35
3412: PPUSH
3413: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3417: LD_EXP 35
3421: PPUSH
3422: LD_INT 3
3424: PUSH
3425: LD_INT 60
3427: PUSH
3428: EMPTY
3429: LIST
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 25
3437: PUSH
3438: LD_INT 2
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: PPUSH
3449: CALL_OW 72
3453: IFFALSE 3410
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3455: LD_ADDR_VAR 0 2
3459: PUSH
3460: LD_EXP 35
3464: PPUSH
3465: LD_INT 25
3467: PUSH
3468: LD_INT 2
3470: PUSH
3471: EMPTY
3472: LIST
3473: LIST
3474: PPUSH
3475: CALL_OW 72
3479: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3480: LD_VAR 0 2
3484: PPUSH
3485: LD_INT 4
3487: PPUSH
3488: LD_INT 116
3490: PPUSH
3491: LD_INT 70
3493: PPUSH
3494: LD_INT 5
3496: PPUSH
3497: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3501: LD_VAR 0 2
3505: PPUSH
3506: LD_INT 31
3508: PPUSH
3509: LD_INT 108
3511: PPUSH
3512: LD_INT 50
3514: PPUSH
3515: LD_INT 2
3517: PPUSH
3518: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3522: LD_INT 35
3524: PPUSH
3525: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3529: LD_INT 22
3531: PUSH
3532: LD_INT 5
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 30
3541: PUSH
3542: LD_INT 4
3544: PUSH
3545: EMPTY
3546: LIST
3547: LIST
3548: PUSH
3549: LD_INT 3
3551: PUSH
3552: LD_INT 57
3554: PUSH
3555: EMPTY
3556: LIST
3557: PUSH
3558: EMPTY
3559: LIST
3560: LIST
3561: PUSH
3562: EMPTY
3563: LIST
3564: LIST
3565: LIST
3566: PPUSH
3567: CALL_OW 69
3571: IFFALSE 3522
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3573: LD_ADDR_VAR 0 3
3577: PUSH
3578: LD_INT 22
3580: PUSH
3581: LD_INT 5
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: PUSH
3588: LD_INT 30
3590: PUSH
3591: LD_INT 4
3593: PUSH
3594: EMPTY
3595: LIST
3596: LIST
3597: PUSH
3598: LD_INT 3
3600: PUSH
3601: LD_INT 57
3603: PUSH
3604: EMPTY
3605: LIST
3606: PUSH
3607: EMPTY
3608: LIST
3609: LIST
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: LIST
3615: PPUSH
3616: CALL_OW 69
3620: PUSH
3621: LD_INT 1
3623: ARRAY
3624: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3625: LD_ADDR_VAR 0 2
3629: PUSH
3630: LD_EXP 35
3634: PPUSH
3635: LD_INT 25
3637: PUSH
3638: LD_INT 1
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PPUSH
3645: CALL_OW 72
3649: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3650: LD_VAR 0 2
3654: PPUSH
3655: LD_VAR 0 3
3659: PPUSH
3660: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3664: LD_INT 35
3666: PPUSH
3667: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3671: LD_INT 22
3673: PUSH
3674: LD_INT 5
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 30
3683: PUSH
3684: LD_INT 31
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: LD_INT 3
3693: PUSH
3694: LD_INT 57
3696: PUSH
3697: EMPTY
3698: LIST
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: EMPTY
3705: LIST
3706: LIST
3707: LIST
3708: PPUSH
3709: CALL_OW 69
3713: PUSH
3714: LD_INT 2
3716: GREATEREQUAL
3717: IFFALSE 3664
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3719: LD_ADDR_VAR 0 2
3723: PUSH
3724: LD_EXP 35
3728: PPUSH
3729: LD_INT 25
3731: PUSH
3732: LD_INT 2
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PPUSH
3739: CALL_OW 72
3743: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3744: LD_VAR 0 2
3748: PUSH
3749: LD_INT 1
3751: ARRAY
3752: PPUSH
3753: LD_INT 5
3755: PPUSH
3756: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3760: LD_VAR 0 2
3764: PUSH
3765: LD_INT 2
3767: ARRAY
3768: PUSH
3769: LD_VAR 0 2
3773: PUSH
3774: LD_INT 3
3776: ARRAY
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PPUSH
3782: LD_VAR 0 3
3786: PPUSH
3787: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3791: LD_VAR 0 2
3795: PUSH
3796: LD_INT 2
3798: ARRAY
3799: PUSH
3800: LD_VAR 0 2
3804: PUSH
3805: LD_INT 3
3807: ARRAY
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PPUSH
3813: LD_INT 1
3815: PPUSH
3816: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3820: LD_VAR 0 2
3824: PUSH
3825: LD_INT 2
3827: ARRAY
3828: PUSH
3829: LD_VAR 0 2
3833: PUSH
3834: LD_INT 3
3836: ARRAY
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: PPUSH
3842: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3846: LD_ADDR_VAR 0 4
3850: PUSH
3851: LD_INT 22
3853: PUSH
3854: LD_INT 5
3856: PUSH
3857: EMPTY
3858: LIST
3859: LIST
3860: PUSH
3861: LD_INT 30
3863: PUSH
3864: LD_INT 31
3866: PUSH
3867: EMPTY
3868: LIST
3869: LIST
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: PPUSH
3875: CALL_OW 69
3879: ST_TO_ADDR
// for i := 1 to 2 do
3880: LD_ADDR_VAR 0 1
3884: PUSH
3885: DOUBLE
3886: LD_INT 1
3888: DEC
3889: ST_TO_ADDR
3890: LD_INT 2
3892: PUSH
3893: FOR_TO
3894: IFFALSE 3928
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3896: LD_VAR 0 2
3900: PUSH
3901: LD_VAR 0 1
3905: PUSH
3906: LD_INT 1
3908: PLUS
3909: ARRAY
3910: PPUSH
3911: LD_VAR 0 4
3915: PUSH
3916: LD_VAR 0 1
3920: ARRAY
3921: PPUSH
3922: CALL_OW 180
3926: GO 3893
3928: POP
3929: POP
// wait ( 1 1$00 ) ;
3930: LD_INT 2100
3932: PPUSH
3933: CALL_OW 67
// farmerBaseReady := true ;
3937: LD_ADDR_EXP 4
3941: PUSH
3942: LD_INT 1
3944: ST_TO_ADDR
// end ;
3945: PPOPN 4
3947: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
3948: LD_EXP 4
3952: PUSH
3953: LD_EXP 10
3957: NOT
3958: AND
3959: IFFALSE 4454
3961: GO 3963
3963: DISABLE
3964: LD_INT 0
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
3970: PPUSH
// begin enable ;
3971: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
3972: LD_ADDR_VAR 0 3
3976: PUSH
3977: LD_EXP 35
3981: PPUSH
3982: LD_INT 25
3984: PUSH
3985: LD_INT 1
3987: PUSH
3988: EMPTY
3989: LIST
3990: LIST
3991: PPUSH
3992: CALL_OW 72
3996: PUSH
3997: LD_EXP 32
4001: ADD
4002: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4003: LD_ADDR_VAR 0 2
4007: PUSH
4008: LD_EXP 35
4012: PPUSH
4013: LD_INT 25
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: EMPTY
4020: LIST
4021: LIST
4022: PPUSH
4023: CALL_OW 72
4027: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4028: LD_ADDR_VAR 0 5
4032: PUSH
4033: LD_INT 22
4035: PUSH
4036: LD_INT 5
4038: PUSH
4039: EMPTY
4040: LIST
4041: LIST
4042: PUSH
4043: LD_INT 21
4045: PUSH
4046: LD_INT 3
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PUSH
4053: LD_INT 3
4055: PUSH
4056: LD_INT 24
4058: PUSH
4059: LD_INT 1000
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: PPUSH
4075: CALL_OW 69
4079: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4080: LD_ADDR_VAR 0 4
4084: PUSH
4085: LD_INT 22
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: PUSH
4095: LD_INT 30
4097: PUSH
4098: LD_INT 4
4100: PUSH
4101: EMPTY
4102: LIST
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PPUSH
4109: CALL_OW 69
4113: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4114: LD_VAR 0 4
4118: PUSH
4119: LD_INT 1
4121: ARRAY
4122: PPUSH
4123: CALL_OW 302
4127: IFFALSE 4191
// for i in sol do
4129: LD_ADDR_VAR 0 1
4133: PUSH
4134: LD_VAR 0 3
4138: PUSH
4139: FOR_IN
4140: IFFALSE 4189
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4142: LD_VAR 0 1
4146: PPUSH
4147: CALL_OW 256
4151: PUSH
4152: LD_INT 999
4154: LESS
4155: PUSH
4156: LD_VAR 0 1
4160: PPUSH
4161: CALL_OW 310
4165: NOT
4166: AND
4167: IFFALSE 4187
// ComEnterUnit ( i , arm [ 1 ] ) ;
4169: LD_VAR 0 1
4173: PPUSH
4174: LD_VAR 0 4
4178: PUSH
4179: LD_INT 1
4181: ARRAY
4182: PPUSH
4183: CALL_OW 120
4187: GO 4139
4189: POP
4190: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4191: LD_VAR 0 2
4195: NOT
4196: PUSH
4197: LD_INT 22
4199: PUSH
4200: LD_INT 1
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 21
4209: PUSH
4210: LD_INT 1
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PPUSH
4221: CALL_OW 69
4225: NOT
4226: AND
4227: IFFALSE 4319
// begin uc_side := 5 ;
4229: LD_ADDR_OWVAR 20
4233: PUSH
4234: LD_INT 5
4236: ST_TO_ADDR
// uc_nation := 2 ;
4237: LD_ADDR_OWVAR 21
4241: PUSH
4242: LD_INT 2
4244: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4245: LD_INT 0
4247: PPUSH
4248: LD_INT 2
4250: PPUSH
4251: LD_INT 2
4253: PPUSH
4254: CALL_OW 380
// eng := CreateHuman ;
4258: LD_ADDR_VAR 0 2
4262: PUSH
4263: CALL_OW 44
4267: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4268: LD_VAR 0 2
4272: PPUSH
4273: LD_INT 102
4275: PPUSH
4276: LD_INT 8
4278: PPUSH
4279: LD_INT 0
4281: PPUSH
4282: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4286: LD_VAR 0 2
4290: PPUSH
4291: LD_INT 110
4293: PPUSH
4294: LD_INT 60
4296: PPUSH
4297: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4301: LD_ADDR_EXP 35
4305: PUSH
4306: LD_EXP 35
4310: PUSH
4311: LD_VAR 0 2
4315: UNION
4316: ST_TO_ADDR
// end else
4317: GO 4454
// begin for i in eng do
4319: LD_ADDR_VAR 0 1
4323: PUSH
4324: LD_VAR 0 2
4328: PUSH
4329: FOR_IN
4330: IFFALSE 4452
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4332: LD_INT 10
4334: PPUSH
4335: LD_INT 1
4337: PPUSH
4338: CALL_OW 287
4342: IFFALSE 4366
// begin if IsInUnit ( i ) then
4344: LD_VAR 0 1
4348: PPUSH
4349: CALL_OW 310
4353: IFFALSE 4364
// ComExitBuilding ( i ) ;
4355: LD_VAR 0 1
4359: PPUSH
4360: CALL_OW 122
// end else
4364: GO 4450
// begin if damagedBuilding then
4366: LD_VAR 0 5
4370: IFFALSE 4414
// begin if IsInUnit ( i ) then
4372: LD_VAR 0 1
4376: PPUSH
4377: CALL_OW 310
4381: IFFALSE 4394
// ComExitBuilding ( i ) else
4383: LD_VAR 0 1
4387: PPUSH
4388: CALL_OW 122
4392: GO 4412
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4394: LD_VAR 0 1
4398: PPUSH
4399: LD_VAR 0 5
4403: PUSH
4404: LD_INT 1
4406: ARRAY
4407: PPUSH
4408: CALL_OW 130
// end else
4412: GO 4450
// if not IsInUnit ( i ) and not HasTask ( i ) then
4414: LD_VAR 0 1
4418: PPUSH
4419: CALL_OW 310
4423: NOT
4424: PUSH
4425: LD_VAR 0 1
4429: PPUSH
4430: CALL_OW 314
4434: NOT
4435: AND
4436: IFFALSE 4450
// ComEnterUnit ( i , arDepot ) ;
4438: LD_VAR 0 1
4442: PPUSH
4443: LD_INT 5
4445: PPUSH
4446: CALL_OW 120
// end ; end ;
4450: GO 4329
4452: POP
4453: POP
// end ; end ;
4454: PPOPN 5
4456: END
// export function StartCargoEvacuation ; begin
4457: LD_INT 0
4459: PPUSH
// while GetResourceType ( GetBase ( arDepot ) , mat_cans ) > 0 and omarCargoCounter > 0 do
4460: LD_INT 5
4462: PPUSH
4463: CALL_OW 274
4467: PPUSH
4468: LD_INT 1
4470: PPUSH
4471: CALL_OW 275
4475: PUSH
4476: LD_INT 0
4478: GREATER
4479: PUSH
4480: LD_EXP 17
4484: PUSH
4485: LD_INT 0
4487: GREATER
4488: AND
4489: IFFALSE 4746
// begin wait ( 1 1$20 ) ;
4491: LD_INT 2800
4493: PPUSH
4494: CALL_OW 67
// omarCargo := PrepareCargo ;
4498: LD_ADDR_EXP 39
4502: PUSH
4503: CALL 4751 0 0
4507: ST_TO_ADDR
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4508: LD_EXP 39
4512: PPUSH
4513: LD_INT 107
4515: PPUSH
4516: LD_INT 59
4518: PPUSH
4519: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4523: LD_INT 35
4525: PPUSH
4526: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4530: LD_EXP 39
4534: PPUSH
4535: LD_INT 107
4537: PPUSH
4538: LD_INT 59
4540: PPUSH
4541: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4545: LD_EXP 39
4549: PPUSH
4550: CALL_OW 302
4554: NOT
4555: PUSH
4556: LD_EXP 39
4560: PPUSH
4561: CALL_OW 301
4565: OR
4566: IFFALSE 4570
// continue ;
4568: GO 4523
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4570: LD_EXP 39
4574: PPUSH
4575: LD_INT 107
4577: PPUSH
4578: LD_INT 59
4580: PPUSH
4581: CALL_OW 307
4585: PUSH
4586: LD_EXP 39
4590: PPUSH
4591: LD_INT 5
4593: PPUSH
4594: CALL_OW 296
4598: PUSH
4599: LD_INT 6
4601: LESS
4602: OR
4603: IFFALSE 4523
// wait ( 0 0$05 ) ;
4605: LD_INT 175
4607: PPUSH
4608: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4612: LD_EXP 39
4616: PPUSH
4617: LD_INT 5
4619: PPUSH
4620: LD_INT 1
4622: PPUSH
4623: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4627: LD_EXP 39
4631: PPUSH
4632: LD_INT 103
4634: PPUSH
4635: LD_INT 9
4637: PPUSH
4638: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4642: LD_INT 35
4644: PPUSH
4645: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4649: LD_EXP 39
4653: PPUSH
4654: LD_INT 103
4656: PPUSH
4657: LD_INT 9
4659: PPUSH
4660: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4664: LD_EXP 39
4668: PPUSH
4669: CALL_OW 302
4673: NOT
4674: PUSH
4675: LD_EXP 39
4679: PPUSH
4680: CALL_OW 301
4684: OR
4685: IFFALSE 4689
// continue ;
4687: GO 4642
// until IsInArea ( omarCargo , northRoad ) and GetCargo ( omarCargo , mat_cans ) > 0 ;
4689: LD_EXP 39
4693: PPUSH
4694: LD_INT 3
4696: PPUSH
4697: CALL_OW 308
4701: PUSH
4702: LD_EXP 39
4706: PPUSH
4707: LD_INT 1
4709: PPUSH
4710: CALL_OW 289
4714: PUSH
4715: LD_INT 0
4717: GREATER
4718: AND
4719: IFFALSE 4642
// RemoveUnit ( omarCargo ) ;
4721: LD_EXP 39
4725: PPUSH
4726: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4730: LD_ADDR_EXP 17
4734: PUSH
4735: LD_EXP 17
4739: PUSH
4740: LD_INT 1
4742: MINUS
4743: ST_TO_ADDR
// end ;
4744: GO 4460
// end ;
4746: LD_VAR 0 1
4750: RET
// export function PrepareCargo ; var un , veh ; begin
4751: LD_INT 0
4753: PPUSH
4754: PPUSH
4755: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4756: LD_ADDR_VAR 0 3
4760: PUSH
4761: LD_INT 5
4763: PPUSH
4764: LD_INT 2
4766: PPUSH
4767: LD_INT 13
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 32
4778: PPUSH
4779: LD_INT 80
4781: PPUSH
4782: CALL 331 0 7
4786: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4787: LD_VAR 0 3
4791: PPUSH
4792: LD_INT 4
4794: PPUSH
4795: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4799: LD_VAR 0 3
4803: PPUSH
4804: LD_INT 101
4806: PPUSH
4807: LD_INT 8
4809: PPUSH
4810: LD_INT 0
4812: PPUSH
4813: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4817: LD_INT 0
4819: PPUSH
4820: LD_INT 3
4822: PPUSH
4823: LD_INT 2
4825: PPUSH
4826: CALL_OW 380
// un := CreateHuman ;
4830: LD_ADDR_VAR 0 2
4834: PUSH
4835: CALL_OW 44
4839: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4840: LD_VAR 0 2
4844: PPUSH
4845: LD_VAR 0 3
4849: PPUSH
4850: CALL_OW 52
// result := veh ;
4854: LD_ADDR_VAR 0 1
4858: PUSH
4859: LD_VAR 0 3
4863: ST_TO_ADDR
// end ; end_of_file
4864: LD_VAR 0 1
4868: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
4869: LD_INT 0
4871: PPUSH
4872: PPUSH
4873: PPUSH
// usForces := [ ] ;
4874: LD_ADDR_EXP 40
4878: PUSH
4879: EMPTY
4880: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
4881: LD_ADDR_EXP 42
4885: PUSH
4886: LD_INT 6
4888: PUSH
4889: LD_INT 32
4891: PUSH
4892: LD_INT 27
4894: PUSH
4895: LD_INT 1
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 4
4906: PUSH
4907: LD_INT 43
4909: PUSH
4910: LD_INT 24
4912: PUSH
4913: LD_INT 5
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: PUSH
4922: LD_INT 27
4924: PUSH
4925: LD_INT 29
4927: PUSH
4928: LD_INT 21
4930: PUSH
4931: LD_INT 0
4933: PUSH
4934: EMPTY
4935: LIST
4936: LIST
4937: LIST
4938: LIST
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
4945: LD_INT 11
4947: PPUSH
4948: CALL_OW 274
4952: PPUSH
4953: LD_INT 1
4955: PPUSH
4956: LD_INT 150
4958: PUSH
4959: LD_INT 120
4961: PUSH
4962: LD_INT 100
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: LIST
4969: PUSH
4970: LD_OWVAR 67
4974: ARRAY
4975: PPUSH
4976: CALL_OW 277
// if Difficulty = 1 then
4980: LD_OWVAR 67
4984: PUSH
4985: LD_INT 1
4987: EQUAL
4988: IFFALSE 4997
// RemoveUnit ( hillBun ) ;
4990: LD_INT 14
4992: PPUSH
4993: CALL_OW 64
// uc_side := 1 ;
4997: LD_ADDR_OWVAR 20
5001: PUSH
5002: LD_INT 1
5004: ST_TO_ADDR
// uc_nation := 1 ;
5005: LD_ADDR_OWVAR 21
5009: PUSH
5010: LD_INT 1
5012: ST_TO_ADDR
// hc_gallery :=  ;
5013: LD_ADDR_OWVAR 33
5017: PUSH
5018: LD_STRING 
5020: ST_TO_ADDR
// hc_name :=  ;
5021: LD_ADDR_OWVAR 26
5025: PUSH
5026: LD_STRING 
5028: ST_TO_ADDR
// hc_importance := 0 ;
5029: LD_ADDR_OWVAR 32
5033: PUSH
5034: LD_INT 0
5036: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5037: LD_INT 1
5039: PPUSH
5040: LD_INT 1
5042: PPUSH
5043: LD_INT 3
5045: PPUSH
5046: CALL_OW 380
// usCommander := CreateHuman ;
5050: LD_ADDR_EXP 41
5054: PUSH
5055: CALL_OW 44
5059: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5060: LD_EXP 41
5064: PPUSH
5065: LD_INT 11
5067: PPUSH
5068: CALL_OW 52
// if hillBun then
5072: LD_INT 14
5074: IFFALSE 5156
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5076: LD_INT 0
5078: PPUSH
5079: LD_INT 1
5081: PPUSH
5082: LD_INT 1
5084: PUSH
5085: LD_INT 2
5087: PUSH
5088: LD_INT 3
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: LIST
5095: PUSH
5096: LD_OWVAR 67
5100: ARRAY
5101: PPUSH
5102: CALL_OW 380
// un := CreateHuman ;
5106: LD_ADDR_VAR 0 3
5110: PUSH
5111: CALL_OW 44
5115: ST_TO_ADDR
// usForces := usForces union un ;
5116: LD_ADDR_EXP 40
5120: PUSH
5121: LD_EXP 40
5125: PUSH
5126: LD_VAR 0 3
5130: UNION
5131: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5132: LD_VAR 0 3
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5144: LD_VAR 0 3
5148: PPUSH
5149: LD_INT 14
5151: PPUSH
5152: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5156: LD_ADDR_VAR 0 2
5160: PUSH
5161: DOUBLE
5162: LD_INT 1
5164: DEC
5165: ST_TO_ADDR
5166: LD_INT 2
5168: PUSH
5169: LD_INT 3
5171: PUSH
5172: LD_INT 4
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: LD_OWVAR 67
5184: ARRAY
5185: PUSH
5186: FOR_TO
5187: IFFALSE 5329
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5189: LD_INT 0
5191: PPUSH
5192: LD_INT 1
5194: PPUSH
5195: LD_INT 1
5197: PUSH
5198: LD_INT 2
5200: PUSH
5201: LD_INT 3
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: LIST
5208: PUSH
5209: LD_OWVAR 67
5213: ARRAY
5214: PPUSH
5215: CALL_OW 380
// un := CreateHuman ;
5219: LD_ADDR_VAR 0 3
5223: PUSH
5224: CALL_OW 44
5228: ST_TO_ADDR
// usForces := usForces union un ;
5229: LD_ADDR_EXP 40
5233: PUSH
5234: LD_EXP 40
5238: PUSH
5239: LD_VAR 0 3
5243: UNION
5244: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5245: LD_VAR 0 3
5249: PPUSH
5250: LD_INT 39
5252: PPUSH
5253: LD_INT 24
5255: PPUSH
5256: LD_INT 4
5258: PPUSH
5259: LD_INT 0
5261: PPUSH
5262: CALL_OW 50
// if i < 3 then
5266: LD_VAR 0 2
5270: PUSH
5271: LD_INT 3
5273: LESS
5274: IFFALSE 5327
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5276: LD_VAR 0 3
5280: PPUSH
5281: LD_INT 22
5283: PUSH
5284: LD_INT 1
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: LD_INT 58
5293: PUSH
5294: EMPTY
5295: LIST
5296: PUSH
5297: LD_INT 30
5299: PUSH
5300: LD_INT 31
5302: PUSH
5303: EMPTY
5304: LIST
5305: LIST
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 69
5316: PUSH
5317: LD_VAR 0 2
5321: ARRAY
5322: PPUSH
5323: CALL_OW 120
// end ;
5327: GO 5186
5329: POP
5330: POP
// for i := 1 to 2 do
5331: LD_ADDR_VAR 0 2
5335: PUSH
5336: DOUBLE
5337: LD_INT 1
5339: DEC
5340: ST_TO_ADDR
5341: LD_INT 2
5343: PUSH
5344: FOR_TO
5345: IFFALSE 5409
// begin PrepareHuman ( false , 2 , 2 ) ;
5347: LD_INT 0
5349: PPUSH
5350: LD_INT 2
5352: PPUSH
5353: LD_INT 2
5355: PPUSH
5356: CALL_OW 380
// un := CreateHuman ;
5360: LD_ADDR_VAR 0 3
5364: PUSH
5365: CALL_OW 44
5369: ST_TO_ADDR
// usForces := usForces union un ;
5370: LD_ADDR_EXP 40
5374: PUSH
5375: LD_EXP 40
5379: PUSH
5380: LD_VAR 0 3
5384: UNION
5385: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5386: LD_VAR 0 3
5390: PPUSH
5391: LD_INT 39
5393: PPUSH
5394: LD_INT 24
5396: PPUSH
5397: LD_INT 4
5399: PPUSH
5400: LD_INT 0
5402: PPUSH
5403: CALL_OW 50
// end ;
5407: GO 5344
5409: POP
5410: POP
// PrepareHuman ( false , 4 , 1 ) ;
5411: LD_INT 0
5413: PPUSH
5414: LD_INT 4
5416: PPUSH
5417: LD_INT 1
5419: PPUSH
5420: CALL_OW 380
// un := CreateHuman ;
5424: LD_ADDR_VAR 0 3
5428: PUSH
5429: CALL_OW 44
5433: ST_TO_ADDR
// usForces := usForces union un ;
5434: LD_ADDR_EXP 40
5438: PUSH
5439: LD_EXP 40
5443: PUSH
5444: LD_VAR 0 3
5448: UNION
5449: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5450: LD_VAR 0 3
5454: PPUSH
5455: LD_INT 39
5457: PPUSH
5458: LD_INT 24
5460: PPUSH
5461: LD_INT 4
5463: PPUSH
5464: LD_INT 0
5466: PPUSH
5467: CALL_OW 50
// end ;
5471: LD_VAR 0 1
5475: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
5476: LD_EXP 40
5480: PUSH
5481: LD_EXP 6
5485: NOT
5486: AND
5487: IFFALSE 5918
5489: GO 5491
5491: DISABLE
5492: LD_INT 0
5494: PPUSH
5495: PPUSH
5496: PPUSH
5497: PPUSH
5498: PPUSH
// begin enable ;
5499: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5500: LD_ADDR_VAR 0 3
5504: PUSH
5505: LD_EXP 40
5509: PPUSH
5510: LD_INT 25
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL_OW 72
5524: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5525: LD_ADDR_VAR 0 4
5529: PUSH
5530: LD_EXP 40
5534: PPUSH
5535: LD_INT 25
5537: PUSH
5538: LD_INT 1
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PPUSH
5545: CALL_OW 72
5549: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5550: LD_ADDR_VAR 0 5
5554: PUSH
5555: LD_EXP 40
5559: PPUSH
5560: LD_INT 25
5562: PUSH
5563: LD_INT 4
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PPUSH
5570: CALL_OW 72
5574: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5575: LD_INT 7
5577: PPUSH
5578: LD_INT 22
5580: PUSH
5581: LD_INT 2
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PPUSH
5588: CALL_OW 70
5592: PUSH
5593: LD_INT 1
5595: EQUAL
5596: IFFALSE 5672
// for i in sol do
5598: LD_ADDR_VAR 0 1
5602: PUSH
5603: LD_VAR 0 4
5607: PUSH
5608: FOR_IN
5609: IFFALSE 5670
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5611: LD_VAR 0 1
5615: PPUSH
5616: CALL_OW 310
5620: NOT
5621: PUSH
5622: LD_VAR 0 1
5626: PPUSH
5627: CALL_OW 310
5631: PPUSH
5632: CALL_OW 266
5636: PUSH
5637: LD_INT 4
5639: EQUAL
5640: NOT
5641: OR
5642: IFFALSE 5668
// begin ComExitBuilding ( i ) ;
5644: LD_VAR 0 1
5648: PPUSH
5649: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5653: LD_VAR 0 1
5657: PPUSH
5658: LD_INT 37
5660: PPUSH
5661: LD_INT 23
5663: PPUSH
5664: CALL_OW 174
// end ;
5668: GO 5608
5670: POP
5671: POP
// if eng then
5672: LD_VAR 0 3
5676: IFFALSE 5918
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5678: LD_ADDR_VAR 0 2
5682: PUSH
5683: LD_INT 22
5685: PUSH
5686: LD_INT 1
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: PUSH
5693: LD_INT 95
5695: PUSH
5696: LD_INT 7
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: PUSH
5703: LD_INT 21
5705: PUSH
5706: LD_INT 3
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 3
5715: PUSH
5716: LD_INT 24
5718: PUSH
5719: LD_INT 1000
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL_OW 69
5740: ST_TO_ADDR
// if b then
5741: LD_VAR 0 2
5745: IFFALSE 5776
// begin ComExitBuilding ( eng ) ;
5747: LD_VAR 0 3
5751: PPUSH
5752: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5756: LD_VAR 0 3
5760: PPUSH
5761: LD_VAR 0 2
5765: PUSH
5766: LD_INT 1
5768: ARRAY
5769: PPUSH
5770: CALL_OW 190
// end else
5774: GO 5918
// begin for i in eng do
5776: LD_ADDR_VAR 0 1
5780: PUSH
5781: LD_VAR 0 3
5785: PUSH
5786: FOR_IN
5787: IFFALSE 5916
// if not HasTask ( i ) then
5789: LD_VAR 0 1
5793: PPUSH
5794: CALL_OW 314
5798: NOT
5799: IFFALSE 5914
// begin if americanBuildList then
5801: LD_EXP 42
5805: IFFALSE 5890
// begin if IsInUnit ( i ) then
5807: LD_VAR 0 1
5811: PPUSH
5812: CALL_OW 310
5816: IFFALSE 5827
// ComExitBuilding ( i ) ;
5818: LD_VAR 0 1
5822: PPUSH
5823: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5827: LD_VAR 0 1
5831: PPUSH
5832: LD_EXP 42
5836: PUSH
5837: LD_INT 1
5839: ARRAY
5840: PUSH
5841: LD_INT 1
5843: ARRAY
5844: PPUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_INT 2
5856: ARRAY
5857: PPUSH
5858: LD_EXP 42
5862: PUSH
5863: LD_INT 1
5865: ARRAY
5866: PUSH
5867: LD_INT 3
5869: ARRAY
5870: PPUSH
5871: LD_EXP 42
5875: PUSH
5876: LD_INT 1
5878: ARRAY
5879: PUSH
5880: LD_INT 4
5882: ARRAY
5883: PPUSH
5884: CALL_OW 205
// end else
5888: GO 5914
// if not IsInUnit ( i ) then
5890: LD_VAR 0 1
5894: PPUSH
5895: CALL_OW 310
5899: NOT
5900: IFFALSE 5914
// ComEnterUnit ( i , usDepot ) ;
5902: LD_VAR 0 1
5906: PPUSH
5907: LD_INT 11
5909: PPUSH
5910: CALL_OW 120
// end ;
5914: GO 5786
5916: POP
5917: POP
// end ; end ; end ;
5918: PPOPN 5
5920: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
5921: LD_INT 0
5923: PPUSH
5924: PPUSH
5925: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
5926: LD_ADDR_VAR 0 3
5930: PUSH
5931: LD_INT 35
5933: PUSH
5934: LD_INT 45
5936: PUSH
5937: LD_INT 48
5939: PUSH
5940: LD_EXP 51
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: ST_TO_ADDR
// for i in tech do
5951: LD_ADDR_VAR 0 4
5955: PUSH
5956: LD_VAR 0 3
5960: PUSH
5961: FOR_IN
5962: IFFALSE 5980
// AddComResearch ( lab , i ) ;
5964: LD_VAR 0 1
5968: PPUSH
5969: LD_VAR 0 4
5973: PPUSH
5974: CALL_OW 184
5978: GO 5961
5980: POP
5981: POP
// end ;
5982: LD_VAR 0 2
5986: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
5987: LD_EXP 11
5991: PUSH
5992: LD_EXP 19
5996: PUSH
5997: LD_EXP 23
6001: LESSEQUAL
6002: AND
6003: IFFALSE 6028
6005: GO 6007
6007: DISABLE
// begin enable ;
6008: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6009: LD_INT 35
6011: PPUSH
6012: LD_INT 2065
6014: PPUSH
6015: CALL_OW 12
6019: PPUSH
6020: CALL_OW 67
// SendConvoy ;
6024: CALL 6126 0 0
// end ;
6028: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6029: LD_EXP 6
6033: PUSH
6034: LD_EXP 15
6038: AND
6039: IFFALSE 6125
6041: GO 6043
6043: DISABLE
// begin if americanHasEscaped then
6044: LD_EXP 7
6048: IFFALSE 6059
// wait ( 3 3$20 ) else
6050: LD_INT 7000
6052: PPUSH
6053: CALL_OW 67
6057: GO 6066
// wait ( 6 6$40 ) ;
6059: LD_INT 14000
6061: PPUSH
6062: CALL_OW 67
// SendAttack ;
6066: CALL 6841 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6070: LD_INT 14000
6072: PUSH
6073: LD_INT 11900
6075: PUSH
6076: LD_INT 9800
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_OWVAR 67
6088: ARRAY
6089: PPUSH
6090: CALL_OW 67
// SendAttack ;
6094: CALL 6841 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6098: LD_EXP 16
6102: PUSH
6103: LD_INT 6
6105: PUSH
6106: LD_INT 7
6108: PUSH
6109: LD_INT 8
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: PUSH
6117: LD_OWVAR 67
6121: ARRAY
6122: LESS
6123: IFFALSE 6070
// end ;
6125: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6126: LD_INT 0
6128: PPUSH
6129: PPUSH
6130: PPUSH
6131: PPUSH
6132: PPUSH
6133: PPUSH
6134: PPUSH
6135: PPUSH
// road := rand ( 1 , 2 ) ;
6136: LD_ADDR_VAR 0 4
6140: PUSH
6141: LD_INT 1
6143: PPUSH
6144: LD_INT 2
6146: PPUSH
6147: CALL_OW 12
6151: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6152: LD_ADDR_VAR 0 8
6156: PUSH
6157: LD_INT 3
6159: PUSH
6160: LD_INT 8
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: PUSH
6167: LD_VAR 0 4
6171: ARRAY
6172: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6173: LD_ADDR_VAR 0 5
6177: PUSH
6178: LD_INT 35
6180: PUSH
6181: LD_INT 66
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 101
6194: PUSH
6195: LD_INT 8
6197: PUSH
6198: LD_INT 4
6200: PUSH
6201: EMPTY
6202: LIST
6203: LIST
6204: LIST
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6210: LD_ADDR_VAR 0 6
6214: PUSH
6215: LD_INT 34
6217: PUSH
6218: LD_INT 67
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: LD_INT 38
6227: PUSH
6228: LD_INT 62
6230: PUSH
6231: EMPTY
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 43
6237: PUSH
6238: LD_INT 54
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 57
6247: PUSH
6248: LD_INT 57
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: PUSH
6255: LD_INT 77
6257: PUSH
6258: LD_INT 71
6260: PUSH
6261: EMPTY
6262: LIST
6263: LIST
6264: PUSH
6265: LD_INT 86
6267: PUSH
6268: LD_INT 60
6270: PUSH
6271: EMPTY
6272: LIST
6273: LIST
6274: PUSH
6275: LD_INT 89
6277: PUSH
6278: LD_INT 35
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PUSH
6285: LD_INT 93
6287: PUSH
6288: LD_INT 17
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: PUSH
6295: LD_INT 97
6297: PUSH
6298: LD_INT 10
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: LD_INT 103
6307: PUSH
6308: LD_INT 9
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: ST_TO_ADDR
// if road = 2 then
6327: LD_VAR 0 4
6331: PUSH
6332: LD_INT 2
6334: EQUAL
6335: IFFALSE 6352
// points := ReverseArray ( points ) ;
6337: LD_ADDR_VAR 0 6
6341: PUSH
6342: LD_VAR 0 6
6346: PPUSH
6347: CALL 1019 0 1
6351: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6352: LD_INT 4
6354: PPUSH
6355: LD_INT 1
6357: PPUSH
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 1
6363: PPUSH
6364: LD_INT 1
6366: PPUSH
6367: LD_INT 12
6369: PPUSH
6370: LD_INT 80
6372: PPUSH
6373: CALL 331 0 7
// veh := CreateVehicle ;
6377: LD_ADDR_VAR 0 3
6381: PUSH
6382: CALL_OW 45
6386: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6387: LD_VAR 0 3
6391: PPUSH
6392: LD_VAR 0 5
6396: PUSH
6397: LD_VAR 0 4
6401: ARRAY
6402: PUSH
6403: LD_INT 3
6405: ARRAY
6406: PPUSH
6407: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6411: LD_VAR 0 3
6415: PPUSH
6416: LD_VAR 0 5
6420: PUSH
6421: LD_VAR 0 4
6425: ARRAY
6426: PUSH
6427: LD_INT 1
6429: ARRAY
6430: PPUSH
6431: LD_VAR 0 5
6435: PUSH
6436: LD_VAR 0 4
6440: ARRAY
6441: PUSH
6442: LD_INT 2
6444: ARRAY
6445: PPUSH
6446: LD_INT 0
6448: PPUSH
6449: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6453: LD_INT 0
6455: PPUSH
6456: LD_INT 1
6458: PPUSH
6459: LD_OWVAR 67
6463: PPUSH
6464: CALL_OW 380
// un := CreateHuman ;
6468: LD_ADDR_VAR 0 2
6472: PUSH
6473: CALL_OW 44
6477: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6478: LD_VAR 0 2
6482: PPUSH
6483: LD_VAR 0 3
6487: PPUSH
6488: CALL_OW 52
// if Prob ( 50 + tick mod 30 ) or convoyCounter < 3 then
6492: LD_INT 50
6494: PUSH
6495: LD_OWVAR 1
6499: PUSH
6500: LD_INT 30
6502: MOD
6503: PLUS
6504: PPUSH
6505: CALL_OW 13
6509: PUSH
6510: LD_EXP 19
6514: PUSH
6515: LD_INT 3
6517: LESS
6518: OR
6519: IFFALSE 6536
// SetCargo ( veh , mat_cans , 100 ) ;
6521: LD_VAR 0 3
6525: PPUSH
6526: LD_INT 1
6528: PPUSH
6529: LD_INT 100
6531: PPUSH
6532: CALL_OW 290
// for i := 2 to points do
6536: LD_ADDR_VAR 0 7
6540: PUSH
6541: DOUBLE
6542: LD_INT 2
6544: DEC
6545: ST_TO_ADDR
6546: LD_VAR 0 6
6550: PUSH
6551: FOR_TO
6552: IFFALSE 6595
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6554: LD_VAR 0 3
6558: PPUSH
6559: LD_VAR 0 6
6563: PUSH
6564: LD_VAR 0 7
6568: ARRAY
6569: PUSH
6570: LD_INT 1
6572: ARRAY
6573: PPUSH
6574: LD_VAR 0 6
6578: PUSH
6579: LD_VAR 0 7
6583: ARRAY
6584: PUSH
6585: LD_INT 2
6587: ARRAY
6588: PPUSH
6589: CALL_OW 171
6593: GO 6551
6595: POP
6596: POP
// convoyCounter := convoyCounter + 1 ;
6597: LD_ADDR_EXP 19
6601: PUSH
6602: LD_EXP 19
6606: PUSH
6607: LD_INT 1
6609: PLUS
6610: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6611: LD_INT 35
6613: PPUSH
6614: CALL_OW 67
// if not HasTask ( veh ) then
6618: LD_VAR 0 3
6622: PPUSH
6623: CALL_OW 314
6627: NOT
6628: IFFALSE 6669
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6630: LD_VAR 0 3
6634: PPUSH
6635: LD_VAR 0 6
6639: PUSH
6640: LD_VAR 0 6
6644: ARRAY
6645: PUSH
6646: LD_INT 1
6648: ARRAY
6649: PPUSH
6650: LD_VAR 0 6
6654: PUSH
6655: LD_VAR 0 6
6659: ARRAY
6660: PUSH
6661: LD_INT 2
6663: ARRAY
6664: PPUSH
6665: CALL_OW 111
// if not IsOk ( veh ) then
6669: LD_VAR 0 3
6673: PPUSH
6674: CALL_OW 302
6678: NOT
6679: IFFALSE 6720
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6681: LD_VAR 0 2
6685: PPUSH
6686: LD_VAR 0 6
6690: PUSH
6691: LD_VAR 0 6
6695: ARRAY
6696: PUSH
6697: LD_INT 1
6699: ARRAY
6700: PPUSH
6701: LD_VAR 0 6
6705: PUSH
6706: LD_VAR 0 6
6710: ARRAY
6711: PUSH
6712: LD_INT 2
6714: ARRAY
6715: PPUSH
6716: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6720: LD_VAR 0 3
6724: PPUSH
6725: LD_VAR 0 8
6729: PPUSH
6730: CALL_OW 308
6734: PUSH
6735: LD_VAR 0 2
6739: PPUSH
6740: LD_VAR 0 8
6744: PPUSH
6745: CALL_OW 308
6749: OR
6750: IFFALSE 6611
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6752: LD_VAR 0 2
6756: PPUSH
6757: CALL_OW 302
6761: PUSH
6762: LD_VAR 0 3
6766: PPUSH
6767: CALL_OW 302
6771: NOT
6772: AND
6773: PUSH
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_VAR 0 8
6783: PPUSH
6784: CALL_OW 308
6788: AND
6789: IFFALSE 6800
// RemoveUnit ( un ) ;
6791: LD_VAR 0 2
6795: PPUSH
6796: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6800: LD_VAR 0 3
6804: PPUSH
6805: LD_VAR 0 8
6809: PPUSH
6810: CALL_OW 308
6814: PUSH
6815: LD_VAR 0 3
6819: PPUSH
6820: CALL_OW 302
6824: AND
6825: IFFALSE 6836
// RemoveUnit ( veh ) ;
6827: LD_VAR 0 3
6831: PPUSH
6832: CALL_OW 64
// end ;
6836: LD_VAR 0 1
6840: RET
// export function SendAttack ; var un , veh , i ; begin
6841: LD_INT 0
6843: PPUSH
6844: PPUSH
6845: PPUSH
6846: PPUSH
// IncomingAttack ;
6847: CALL 15139 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
6851: LD_INT 2100
6853: PPUSH
6854: LD_INT 3500
6856: PPUSH
6857: CALL_OW 12
6861: PPUSH
6862: CALL_OW 67
// for i := 1 to [ 3 , 3 , 4 ] [ Difficulty ] + attackWave div 3 do
6866: LD_ADDR_VAR 0 4
6870: PUSH
6871: DOUBLE
6872: LD_INT 1
6874: DEC
6875: ST_TO_ADDR
6876: LD_INT 3
6878: PUSH
6879: LD_INT 3
6881: PUSH
6882: LD_INT 4
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: LIST
6889: PUSH
6890: LD_OWVAR 67
6894: ARRAY
6895: PUSH
6896: LD_EXP 16
6900: PUSH
6901: LD_INT 3
6903: DIV
6904: PLUS
6905: PUSH
6906: FOR_TO
6907: IFFALSE 7019
// begin uc_side := 1 ;
6909: LD_ADDR_OWVAR 20
6913: PUSH
6914: LD_INT 1
6916: ST_TO_ADDR
// uc_nation := 1 ;
6917: LD_ADDR_OWVAR 21
6921: PUSH
6922: LD_INT 1
6924: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
6925: LD_INT 0
6927: PPUSH
6928: LD_INT 1
6930: PPUSH
6931: LD_INT 2
6933: PUSH
6934: LD_INT 3
6936: PUSH
6937: LD_INT 4
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: PUSH
6945: LD_OWVAR 67
6949: ARRAY
6950: PPUSH
6951: CALL_OW 380
// un := CreateHuman ;
6955: LD_ADDR_VAR 0 2
6959: PUSH
6960: CALL_OW 44
6964: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
6965: LD_VAR 0 2
6969: PPUSH
6970: LD_INT 37
6972: PPUSH
6973: LD_INT 70
6975: PPUSH
6976: LD_INT 3
6978: PPUSH
6979: LD_INT 0
6981: PPUSH
6982: CALL_OW 50
// usAttackers := usAttackers union un ;
6986: LD_ADDR_EXP 43
6990: PUSH
6991: LD_EXP 43
6995: PUSH
6996: LD_VAR 0 2
7000: UNION
7001: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7002: LD_VAR 0 2
7006: PPUSH
7007: LD_INT 40
7009: PPUSH
7010: LD_INT 65
7012: PPUSH
7013: CALL_OW 111
// end ;
7017: GO 6906
7019: POP
7020: POP
// uc_side := 1 ;
7021: LD_ADDR_OWVAR 20
7025: PUSH
7026: LD_INT 1
7028: ST_TO_ADDR
// uc_nation := 1 ;
7029: LD_ADDR_OWVAR 21
7033: PUSH
7034: LD_INT 1
7036: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7037: LD_INT 0
7039: PPUSH
7040: LD_INT 4
7042: PPUSH
7043: LD_INT 2
7045: PPUSH
7046: CALL_OW 380
// un := CreateHuman ;
7050: LD_ADDR_VAR 0 2
7054: PUSH
7055: CALL_OW 44
7059: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7060: LD_VAR 0 2
7064: PPUSH
7065: LD_INT 37
7067: PPUSH
7068: LD_INT 70
7070: PPUSH
7071: LD_INT 3
7073: PPUSH
7074: LD_INT 0
7076: PPUSH
7077: CALL_OW 50
// usAttackers := usAttackers union un ;
7081: LD_ADDR_EXP 43
7085: PUSH
7086: LD_EXP 43
7090: PUSH
7091: LD_VAR 0 2
7095: UNION
7096: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7097: LD_VAR 0 2
7101: PPUSH
7102: LD_INT 40
7104: PPUSH
7105: LD_INT 65
7107: PPUSH
7108: CALL_OW 111
// if attackWave > 1 or Difficulty > 1 then
7112: LD_EXP 16
7116: PUSH
7117: LD_INT 1
7119: GREATER
7120: PUSH
7121: LD_OWVAR 67
7125: PUSH
7126: LD_INT 1
7128: GREATER
7129: OR
7130: IFFALSE 7333
// begin for i := 1 to Difficulty + attackWave div 4 do
7132: LD_ADDR_VAR 0 4
7136: PUSH
7137: DOUBLE
7138: LD_INT 1
7140: DEC
7141: ST_TO_ADDR
7142: LD_OWVAR 67
7146: PUSH
7147: LD_EXP 16
7151: PUSH
7152: LD_INT 4
7154: DIV
7155: PLUS
7156: PUSH
7157: FOR_TO
7158: IFFALSE 7331
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7160: LD_ADDR_VAR 0 3
7164: PUSH
7165: LD_INT 1
7167: PPUSH
7168: LD_INT 1
7170: PPUSH
7171: LD_INT 2
7173: PPUSH
7174: LD_INT 2
7176: PPUSH
7177: LD_INT 1
7179: PPUSH
7180: LD_INT 4
7182: PUSH
7183: LD_INT 3
7185: PUSH
7186: LD_INT 2
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: PUSH
7194: LD_INT 1
7196: PPUSH
7197: LD_INT 3
7199: PPUSH
7200: CALL_OW 12
7204: ARRAY
7205: PPUSH
7206: LD_INT 90
7208: PPUSH
7209: CALL 331 0 7
7213: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7214: LD_VAR 0 3
7218: PPUSH
7219: LD_INT 35
7221: PPUSH
7222: LD_INT 65
7224: PPUSH
7225: LD_INT 0
7227: PPUSH
7228: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7232: LD_INT 0
7234: PPUSH
7235: LD_INT 3
7237: PPUSH
7238: LD_OWVAR 67
7242: PUSH
7243: LD_INT 1
7245: PLUS
7246: PPUSH
7247: CALL_OW 380
// un := CreateHuman ;
7251: LD_ADDR_VAR 0 2
7255: PUSH
7256: CALL_OW 44
7260: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7261: LD_VAR 0 2
7265: PPUSH
7266: LD_VAR 0 3
7270: PPUSH
7271: CALL_OW 52
// usAttackers := usAttackers union un ;
7275: LD_ADDR_EXP 43
7279: PUSH
7280: LD_EXP 43
7284: PUSH
7285: LD_VAR 0 2
7289: UNION
7290: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7291: LD_VAR 0 3
7295: PPUSH
7296: LD_INT 39
7298: PPUSH
7299: LD_INT 60
7301: PPUSH
7302: CALL_OW 111
// wait ( 0 0$2 ) ;
7306: LD_INT 70
7308: PPUSH
7309: CALL_OW 67
// usAttackers := usAttackers union veh ;
7313: LD_ADDR_EXP 43
7317: PUSH
7318: LD_EXP 43
7322: PUSH
7323: LD_VAR 0 3
7327: UNION
7328: ST_TO_ADDR
// end ;
7329: GO 7157
7331: POP
7332: POP
// end ; attackWave := attackWave + 1 ;
7333: LD_ADDR_EXP 16
7337: PUSH
7338: LD_EXP 16
7342: PUSH
7343: LD_INT 1
7345: PLUS
7346: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7347: LD_EXP 20
7351: PPUSH
7352: CALL_OW 427
// end ;
7356: LD_VAR 0 1
7360: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7361: LD_INT 0
7363: PPUSH
7364: PPUSH
7365: PPUSH
7366: PPUSH
7367: PPUSH
7368: PPUSH
7369: PPUSH
7370: PPUSH
7371: PPUSH
7372: PPUSH
7373: PPUSH
// if retreatAllowed then
7374: LD_EXP 10
7378: IFFALSE 7390
// strategy := 2 else
7380: LD_ADDR_VAR 0 5
7384: PUSH
7385: LD_INT 2
7387: ST_TO_ADDR
7388: GO 7406
// strategy := rand ( 0 , 2 ) ;
7390: LD_ADDR_VAR 0 5
7394: PUSH
7395: LD_INT 0
7397: PPUSH
7398: LD_INT 2
7400: PPUSH
7401: CALL_OW 12
7405: ST_TO_ADDR
// attackFormula := [ ] ;
7406: LD_ADDR_VAR 0 6
7410: PUSH
7411: EMPTY
7412: ST_TO_ADDR
// case strategy of 0 :
7413: LD_VAR 0 5
7417: PUSH
7418: LD_INT 0
7420: DOUBLE
7421: EQUAL
7422: IFTRUE 7426
7424: GO 7756
7426: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7427: LD_INT 11
7429: PPUSH
7430: LD_INT 22
7432: PUSH
7433: LD_INT 2
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PUSH
7440: LD_INT 30
7442: PUSH
7443: LD_INT 4
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PPUSH
7454: CALL_OW 70
7458: NOT
7459: IFFALSE 7531
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7461: LD_ADDR_VAR 0 6
7465: PUSH
7466: LD_INT 41
7468: PUSH
7469: LD_INT 34
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: PUSH
7476: EMPTY
7477: LIST
7478: PUSH
7479: LD_INT 53
7481: PUSH
7482: LD_INT 62
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 37
7491: PUSH
7492: LD_INT 63
7494: PUSH
7495: EMPTY
7496: LIST
7497: LIST
7498: PUSH
7499: LD_INT 44
7501: PUSH
7502: LD_INT 45
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 37
7511: PUSH
7512: LD_INT 28
7514: PUSH
7515: EMPTY
7516: LIST
7517: LIST
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: LIST
7527: LIST
7528: ST_TO_ADDR
7529: GO 7754
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7531: LD_INT 12
7533: PPUSH
7534: LD_INT 22
7536: PUSH
7537: LD_INT 2
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: LD_INT 2
7546: PUSH
7547: LD_INT 30
7549: PUSH
7550: LD_INT 4
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 30
7559: PUSH
7560: LD_INT 31
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 30
7569: PUSH
7570: LD_INT 32
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 70
7591: NOT
7592: IFFALSE 7675
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7594: LD_ADDR_VAR 0 6
7598: PUSH
7599: LD_INT 27
7601: PUSH
7602: LD_INT 42
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 27
7611: PUSH
7612: LD_INT 32
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: LD_INT 53
7625: PUSH
7626: LD_INT 62
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: LD_INT 37
7635: PUSH
7636: LD_INT 63
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PUSH
7643: LD_INT 44
7645: PUSH
7646: LD_INT 45
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 37
7655: PUSH
7656: LD_INT 28
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: LIST
7671: LIST
7672: ST_TO_ADDR
7673: GO 7754
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7675: LD_ADDR_VAR 0 6
7679: PUSH
7680: LD_INT 71
7682: PUSH
7683: LD_INT 67
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 54
7692: PUSH
7693: LD_INT 35
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 63
7706: PUSH
7707: LD_INT 40
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: LD_INT 37
7716: PUSH
7717: LD_INT 63
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PUSH
7724: LD_INT 44
7726: PUSH
7727: LD_INT 45
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PUSH
7734: LD_INT 37
7736: PUSH
7737: LD_INT 28
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: PUSH
7744: EMPTY
7745: LIST
7746: LIST
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: ST_TO_ADDR
// end ; 1 :
7754: GO 7959
7756: LD_INT 1
7758: DOUBLE
7759: EQUAL
7760: IFTRUE 7764
7762: GO 7868
7764: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7765: LD_ADDR_VAR 0 6
7769: PUSH
7770: LD_INT 71
7772: PUSH
7773: LD_INT 67
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: PUSH
7780: LD_INT 82
7782: PUSH
7783: LD_INT 23
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 53
7792: PUSH
7793: LD_INT 7
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: LD_INT 43
7802: PUSH
7803: LD_INT 10
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 53
7818: PUSH
7819: LD_INT 62
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 37
7828: PUSH
7829: LD_INT 63
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: LD_INT 44
7838: PUSH
7839: LD_INT 45
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 37
7848: PUSH
7849: LD_INT 28
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: ST_TO_ADDR
7866: GO 7959
7868: LD_INT 2
7870: DOUBLE
7871: EQUAL
7872: IFTRUE 7876
7874: GO 7958
7876: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
7877: LD_ADDR_VAR 0 6
7881: PUSH
7882: LD_INT 90
7884: PUSH
7885: LD_INT 59
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 108
7894: PUSH
7895: LD_INT 64
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: PUSH
7906: LD_INT 82
7908: PUSH
7909: LD_INT 75
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PUSH
7916: LD_INT 73
7918: PUSH
7919: LD_INT 67
7921: PUSH
7922: EMPTY
7923: LIST
7924: LIST
7925: PUSH
7926: LD_INT 101
7928: PUSH
7929: LD_INT 65
7931: PUSH
7932: EMPTY
7933: LIST
7934: LIST
7935: PUSH
7936: LD_INT 108
7938: PUSH
7939: LD_INT 62
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PUSH
7946: EMPTY
7947: LIST
7948: LIST
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: LIST
7954: LIST
7955: ST_TO_ADDR
7956: GO 7959
7958: POP
// if not attackFormula then
7959: LD_VAR 0 6
7963: NOT
7964: IFFALSE 7968
// exit ;
7966: GO 9400
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
7968: LD_ADDR_VAR 0 7
7972: PUSH
7973: LD_EXP 43
7977: PPUSH
7978: LD_INT 25
7980: PUSH
7981: LD_INT 1
7983: PUSH
7984: EMPTY
7985: LIST
7986: LIST
7987: PPUSH
7988: CALL_OW 72
7992: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
7993: LD_ADDR_VAR 0 8
7997: PUSH
7998: LD_EXP 43
8002: PPUSH
8003: LD_INT 25
8005: PUSH
8006: LD_INT 4
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8018: LD_ADDR_VAR 0 9
8022: PUSH
8023: LD_EXP 43
8027: PPUSH
8028: LD_INT 25
8030: PUSH
8031: LD_INT 3
8033: PUSH
8034: EMPTY
8035: LIST
8036: LIST
8037: PPUSH
8038: CALL_OW 72
8042: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8043: LD_ADDR_VAR 0 10
8047: PUSH
8048: LD_EXP 43
8052: PPUSH
8053: LD_INT 21
8055: PUSH
8056: LD_INT 2
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: PPUSH
8063: CALL_OW 72
8067: ST_TO_ADDR
// if sci then
8068: LD_VAR 0 8
8072: IFFALSE 8109
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8074: LD_VAR 0 8
8078: PPUSH
8079: LD_VAR 0 6
8083: PUSH
8084: LD_INT 2
8086: ARRAY
8087: PUSH
8088: LD_INT 1
8090: ARRAY
8091: PPUSH
8092: LD_VAR 0 6
8096: PUSH
8097: LD_INT 2
8099: ARRAY
8100: PUSH
8101: LD_INT 2
8103: ARRAY
8104: PPUSH
8105: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8109: LD_INT 35
8111: PPUSH
8112: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8116: LD_ADDR_VAR 0 7
8120: PUSH
8121: LD_EXP 43
8125: PPUSH
8126: LD_INT 25
8128: PUSH
8129: LD_INT 1
8131: PUSH
8132: EMPTY
8133: LIST
8134: LIST
8135: PPUSH
8136: CALL_OW 72
8140: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8141: LD_ADDR_VAR 0 8
8145: PUSH
8146: LD_EXP 43
8150: PPUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 4
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PPUSH
8161: CALL_OW 72
8165: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8166: LD_ADDR_VAR 0 9
8170: PUSH
8171: LD_EXP 43
8175: PPUSH
8176: LD_INT 25
8178: PUSH
8179: LD_INT 3
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: PPUSH
8186: CALL_OW 72
8190: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8191: LD_ADDR_VAR 0 10
8195: PUSH
8196: LD_EXP 43
8200: PPUSH
8201: LD_INT 21
8203: PUSH
8204: LD_INT 2
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 72
8215: ST_TO_ADDR
// if sol then
8216: LD_VAR 0 7
8220: IFFALSE 8615
// begin for i in sol do
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 7
8231: PUSH
8232: FOR_IN
8233: IFFALSE 8613
// begin tag := GetTag ( i ) ;
8235: LD_ADDR_VAR 0 4
8239: PUSH
8240: LD_VAR 0 2
8244: PPUSH
8245: CALL_OW 110
8249: ST_TO_ADDR
// if not tag then
8250: LD_VAR 0 4
8254: NOT
8255: IFFALSE 8373
// begin if GetLives ( i ) = 1000 then
8257: LD_VAR 0 2
8261: PPUSH
8262: CALL_OW 256
8266: PUSH
8267: LD_INT 1000
8269: EQUAL
8270: IFFALSE 8286
// SetTag ( i , 1 ) else
8272: LD_VAR 0 2
8276: PPUSH
8277: LD_INT 1
8279: PPUSH
8280: CALL_OW 109
8284: GO 8371
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8286: LD_VAR 0 2
8290: PPUSH
8291: LD_VAR 0 6
8295: PUSH
8296: LD_INT 2
8298: ARRAY
8299: PUSH
8300: LD_INT 1
8302: ARRAY
8303: PPUSH
8304: LD_VAR 0 6
8308: PUSH
8309: LD_INT 2
8311: ARRAY
8312: PUSH
8313: LD_INT 2
8315: ARRAY
8316: PPUSH
8317: CALL_OW 297
8321: PUSH
8322: LD_INT 6
8324: GREATER
8325: IFFALSE 8371
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8327: LD_VAR 0 2
8331: PPUSH
8332: LD_VAR 0 6
8336: PUSH
8337: LD_INT 2
8339: ARRAY
8340: PUSH
8341: LD_INT 1
8343: ARRAY
8344: PPUSH
8345: LD_VAR 0 6
8349: PUSH
8350: LD_INT 2
8352: ARRAY
8353: PUSH
8354: LD_INT 2
8356: ARRAY
8357: PPUSH
8358: CALL_OW 111
// AddComHold ( i ) ;
8362: LD_VAR 0 2
8366: PPUSH
8367: CALL_OW 200
// end ; end else
8371: GO 8611
// begin if GetLives ( i ) < 720 then
8373: LD_VAR 0 2
8377: PPUSH
8378: CALL_OW 256
8382: PUSH
8383: LD_INT 720
8385: LESS
8386: IFFALSE 8402
// SetTag ( i , 0 ) else
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 0
8395: PPUSH
8396: CALL_OW 109
8400: GO 8611
// if tag <= attackFormula [ 1 ] then
8402: LD_VAR 0 4
8406: PUSH
8407: LD_VAR 0 6
8411: PUSH
8412: LD_INT 1
8414: ARRAY
8415: LESSEQUAL
8416: IFFALSE 8577
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8418: LD_VAR 0 2
8422: PPUSH
8423: LD_VAR 0 6
8427: PUSH
8428: LD_INT 1
8430: ARRAY
8431: PUSH
8432: LD_VAR 0 4
8436: ARRAY
8437: PUSH
8438: LD_INT 1
8440: ARRAY
8441: PPUSH
8442: LD_VAR 0 6
8446: PUSH
8447: LD_INT 1
8449: ARRAY
8450: PUSH
8451: LD_VAR 0 4
8455: ARRAY
8456: PUSH
8457: LD_INT 2
8459: ARRAY
8460: PPUSH
8461: CALL_OW 297
8465: PUSH
8466: LD_INT 6
8468: GREATER
8469: IFFALSE 8520
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_VAR 0 6
8480: PUSH
8481: LD_INT 1
8483: ARRAY
8484: PUSH
8485: LD_VAR 0 4
8489: ARRAY
8490: PUSH
8491: LD_INT 1
8493: ARRAY
8494: PPUSH
8495: LD_VAR 0 6
8499: PUSH
8500: LD_INT 1
8502: ARRAY
8503: PUSH
8504: LD_VAR 0 4
8508: ARRAY
8509: PUSH
8510: LD_INT 2
8512: ARRAY
8513: PPUSH
8514: CALL_OW 114
8518: GO 8575
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8520: LD_INT 81
8522: PUSH
8523: LD_INT 1
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PUSH
8530: LD_INT 91
8532: PUSH
8533: LD_VAR 0 2
8537: PUSH
8538: LD_INT 10
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: LIST
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PPUSH
8550: CALL_OW 69
8554: NOT
8555: IFFALSE 8575
// SetTag ( i , tag + 1 ) ;
8557: LD_VAR 0 2
8561: PPUSH
8562: LD_VAR 0 4
8566: PUSH
8567: LD_INT 1
8569: PLUS
8570: PPUSH
8571: CALL_OW 109
// end else
8575: GO 8611
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8577: LD_VAR 0 2
8581: PPUSH
8582: LD_INT 81
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: PPUSH
8592: CALL_OW 69
8596: PPUSH
8597: LD_VAR 0 2
8601: PPUSH
8602: CALL_OW 74
8606: PPUSH
8607: CALL_OW 115
// end ; end ;
8611: GO 8232
8613: POP
8614: POP
// end ; if sci then
8615: LD_VAR 0 8
8619: IFFALSE 8778
// begin if not sol and not mech then
8621: LD_VAR 0 7
8625: NOT
8626: PUSH
8627: LD_VAR 0 9
8631: NOT
8632: AND
8633: IFFALSE 8685
// begin for i in sci do
8635: LD_ADDR_VAR 0 2
8639: PUSH
8640: LD_VAR 0 8
8644: PUSH
8645: FOR_IN
8646: IFFALSE 8681
// begin usForces := usForces union i ;
8648: LD_ADDR_EXP 40
8652: PUSH
8653: LD_EXP 40
8657: PUSH
8658: LD_VAR 0 2
8662: UNION
8663: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8664: LD_VAR 0 2
8668: PPUSH
8669: LD_INT 34
8671: PPUSH
8672: LD_INT 68
8674: PPUSH
8675: CALL_OW 111
// end ;
8679: GO 8645
8681: POP
8682: POP
// end else
8683: GO 8778
// for i in sci do
8685: LD_ADDR_VAR 0 2
8689: PUSH
8690: LD_VAR 0 8
8694: PUSH
8695: FOR_IN
8696: IFFALSE 8776
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8698: LD_VAR 0 2
8702: PPUSH
8703: LD_VAR 0 6
8707: PUSH
8708: LD_INT 2
8710: ARRAY
8711: PUSH
8712: LD_INT 1
8714: ARRAY
8715: PPUSH
8716: LD_VAR 0 6
8720: PUSH
8721: LD_INT 2
8723: ARRAY
8724: PUSH
8725: LD_INT 2
8727: ARRAY
8728: PPUSH
8729: CALL_OW 297
8733: PUSH
8734: LD_INT 8
8736: GREATER
8737: IFFALSE 8774
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8739: LD_VAR 0 2
8743: PPUSH
8744: LD_VAR 0 6
8748: PUSH
8749: LD_INT 2
8751: ARRAY
8752: PUSH
8753: LD_INT 1
8755: ARRAY
8756: PPUSH
8757: LD_VAR 0 6
8761: PUSH
8762: LD_INT 2
8764: ARRAY
8765: PUSH
8766: LD_INT 2
8768: ARRAY
8769: PPUSH
8770: CALL_OW 111
8774: GO 8695
8776: POP
8777: POP
// end ; if tanks and mech then
8778: LD_VAR 0 10
8782: PUSH
8783: LD_VAR 0 9
8787: AND
8788: IFFALSE 9393
// begin for i in mech do
8790: LD_ADDR_VAR 0 2
8794: PUSH
8795: LD_VAR 0 9
8799: PUSH
8800: FOR_IN
8801: IFFALSE 9391
// begin tag := GetTag ( i ) ;
8803: LD_ADDR_VAR 0 4
8807: PUSH
8808: LD_VAR 0 2
8812: PPUSH
8813: CALL_OW 110
8817: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8818: LD_ADDR_VAR 0 11
8822: PUSH
8823: LD_VAR 0 2
8827: PPUSH
8828: CALL_OW 310
8832: ST_TO_ADDR
// if not tag then
8833: LD_VAR 0 4
8837: NOT
8838: IFFALSE 9151
// begin if veh then
8840: LD_VAR 0 11
8844: IFFALSE 8993
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
8846: LD_VAR 0 11
8850: PPUSH
8851: CALL_OW 256
8855: PUSH
8856: LD_INT 1000
8858: EQUAL
8859: PUSH
8860: LD_VAR 0 11
8864: PPUSH
8865: CALL_OW 261
8869: PUSH
8870: LD_INT 60
8872: GREATER
8873: AND
8874: IFFALSE 8890
// SetTag ( i , 1 ) else
8876: LD_VAR 0 2
8880: PPUSH
8881: LD_INT 1
8883: PPUSH
8884: CALL_OW 109
8888: GO 8991
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
8890: LD_VAR 0 2
8894: PPUSH
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 3
8902: ARRAY
8903: PUSH
8904: LD_INT 1
8906: ARRAY
8907: PPUSH
8908: LD_VAR 0 6
8912: PUSH
8913: LD_INT 3
8915: ARRAY
8916: PUSH
8917: LD_INT 2
8919: ARRAY
8920: PPUSH
8921: CALL_OW 297
8925: PUSH
8926: LD_INT 7
8928: GREATER
8929: IFFALSE 8968
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
8931: LD_VAR 0 2
8935: PPUSH
8936: LD_VAR 0 6
8940: PUSH
8941: LD_INT 3
8943: ARRAY
8944: PUSH
8945: LD_INT 1
8947: ARRAY
8948: PPUSH
8949: LD_VAR 0 6
8953: PUSH
8954: LD_INT 3
8956: ARRAY
8957: PUSH
8958: LD_INT 2
8960: ARRAY
8961: PPUSH
8962: CALL_OW 111
8966: GO 8991
// begin ComExitVehicle ( i ) ;
8968: LD_VAR 0 2
8972: PPUSH
8973: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
8977: LD_VAR 0 2
8981: PPUSH
8982: LD_VAR 0 11
8986: PPUSH
8987: CALL_OW 189
// end ; end else
8991: GO 9149
// if GetLives ( i ) < 700 then
8993: LD_VAR 0 2
8997: PPUSH
8998: CALL_OW 256
9002: PUSH
9003: LD_INT 700
9005: LESS
9006: IFFALSE 9057
// begin usAttackers := usAttackers diff i ;
9008: LD_ADDR_EXP 43
9012: PUSH
9013: LD_EXP 43
9017: PUSH
9018: LD_VAR 0 2
9022: DIFF
9023: ST_TO_ADDR
// usForces := usForces union i ;
9024: LD_ADDR_EXP 40
9028: PUSH
9029: LD_EXP 40
9033: PUSH
9034: LD_VAR 0 2
9038: UNION
9039: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9040: LD_VAR 0 2
9044: PPUSH
9045: LD_INT 34
9047: PPUSH
9048: LD_INT 68
9050: PPUSH
9051: CALL_OW 111
// end else
9055: GO 9149
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9057: LD_VAR 0 10
9061: PPUSH
9062: LD_INT 58
9064: PUSH
9065: EMPTY
9066: LIST
9067: PUSH
9068: LD_INT 24
9070: PUSH
9071: LD_INT 1000
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PPUSH
9082: CALL_OW 72
9086: PUSH
9087: LD_VAR 0 2
9091: PPUSH
9092: CALL_OW 314
9096: NOT
9097: AND
9098: IFFALSE 9149
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9100: LD_VAR 0 2
9104: PPUSH
9105: LD_VAR 0 10
9109: PPUSH
9110: LD_INT 58
9112: PUSH
9113: EMPTY
9114: LIST
9115: PUSH
9116: LD_INT 24
9118: PUSH
9119: LD_INT 1000
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PPUSH
9130: CALL_OW 72
9134: PPUSH
9135: LD_VAR 0 2
9139: PPUSH
9140: CALL_OW 74
9144: PPUSH
9145: CALL_OW 120
// end else
9149: GO 9389
// begin if GetLives ( veh ) < 620 then
9151: LD_VAR 0 11
9155: PPUSH
9156: CALL_OW 256
9160: PUSH
9161: LD_INT 620
9163: LESS
9164: IFFALSE 9180
// SetTag ( i , 0 ) else
9166: LD_VAR 0 2
9170: PPUSH
9171: LD_INT 0
9173: PPUSH
9174: CALL_OW 109
9178: GO 9389
// if tag <= attackFormula [ 4 ] then
9180: LD_VAR 0 4
9184: PUSH
9185: LD_VAR 0 6
9189: PUSH
9190: LD_INT 4
9192: ARRAY
9193: LESSEQUAL
9194: IFFALSE 9355
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9196: LD_VAR 0 2
9200: PPUSH
9201: LD_VAR 0 6
9205: PUSH
9206: LD_INT 4
9208: ARRAY
9209: PUSH
9210: LD_VAR 0 4
9214: ARRAY
9215: PUSH
9216: LD_INT 1
9218: ARRAY
9219: PPUSH
9220: LD_VAR 0 6
9224: PUSH
9225: LD_INT 4
9227: ARRAY
9228: PUSH
9229: LD_VAR 0 4
9233: ARRAY
9234: PUSH
9235: LD_INT 2
9237: ARRAY
9238: PPUSH
9239: CALL_OW 297
9243: PUSH
9244: LD_INT 6
9246: GREATER
9247: IFFALSE 9298
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9249: LD_VAR 0 2
9253: PPUSH
9254: LD_VAR 0 6
9258: PUSH
9259: LD_INT 4
9261: ARRAY
9262: PUSH
9263: LD_VAR 0 4
9267: ARRAY
9268: PUSH
9269: LD_INT 1
9271: ARRAY
9272: PPUSH
9273: LD_VAR 0 6
9277: PUSH
9278: LD_INT 4
9280: ARRAY
9281: PUSH
9282: LD_VAR 0 4
9286: ARRAY
9287: PUSH
9288: LD_INT 2
9290: ARRAY
9291: PPUSH
9292: CALL_OW 114
9296: GO 9353
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9298: LD_INT 81
9300: PUSH
9301: LD_INT 1
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: PUSH
9308: LD_INT 91
9310: PUSH
9311: LD_VAR 0 2
9315: PUSH
9316: LD_INT 10
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: LIST
9323: PUSH
9324: EMPTY
9325: LIST
9326: LIST
9327: PPUSH
9328: CALL_OW 69
9332: NOT
9333: IFFALSE 9353
// SetTag ( i , tag + 1 ) ;
9335: LD_VAR 0 2
9339: PPUSH
9340: LD_VAR 0 4
9344: PUSH
9345: LD_INT 1
9347: PLUS
9348: PPUSH
9349: CALL_OW 109
// end else
9353: GO 9389
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9355: LD_VAR 0 2
9359: PPUSH
9360: LD_INT 81
9362: PUSH
9363: LD_INT 1
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: PPUSH
9370: CALL_OW 69
9374: PPUSH
9375: LD_VAR 0 2
9379: PPUSH
9380: CALL_OW 74
9384: PPUSH
9385: CALL_OW 115
// end ; end ;
9389: GO 8800
9391: POP
9392: POP
// end ; until not usAttackers ;
9393: LD_EXP 43
9397: NOT
9398: IFFALSE 8109
// end ; end_of_file
9400: LD_VAR 0 1
9404: RET
// export function Action ; var hasAll , i , tmp ; begin
9405: LD_INT 0
9407: PPUSH
9408: PPUSH
9409: PPUSH
9410: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9411: LD_ADDR_VAR 0 2
9415: PUSH
9416: LD_INT 22
9418: PUSH
9419: LD_INT 2
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: PUSH
9426: LD_INT 21
9428: PUSH
9429: LD_INT 1
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PUSH
9436: LD_INT 23
9438: PUSH
9439: LD_INT 2
9441: PUSH
9442: EMPTY
9443: LIST
9444: LIST
9445: PUSH
9446: EMPTY
9447: LIST
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: PUSH
9456: LD_INT 7
9458: GREATEREQUAL
9459: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9460: LD_VAR 0 2
9464: PPUSH
9465: LD_STRING 03_HasAll
9467: PPUSH
9468: CALL_OW 39
// Video ( true ) ;
9472: LD_INT 1
9474: PPUSH
9475: CALL 991 0 1
// CenterNowOnUnits ( Heike ) ;
9479: LD_EXP 24
9483: PPUSH
9484: CALL_OW 87
// wait ( 0 0$2 ) ;
9488: LD_INT 70
9490: PPUSH
9491: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9495: LD_EXP 32
9499: PPUSH
9500: LD_STRING DF-1-start
9502: PPUSH
9503: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9507: LD_EXP 24
9511: PPUSH
9512: LD_EXP 32
9516: PPUSH
9517: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9521: LD_EXP 24
9525: PPUSH
9526: LD_STRING DH-1-start
9528: PPUSH
9529: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9533: LD_EXP 33
9537: PPUSH
9538: LD_INT 92
9540: PPUSH
9541: LD_INT 21
9543: PPUSH
9544: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9548: LD_EXP 28
9552: PPUSH
9553: LD_INT 94
9555: PPUSH
9556: LD_INT 23
9558: PPUSH
9559: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9563: LD_EXP 36
9567: PUSH
9568: LD_INT 1
9570: ARRAY
9571: PPUSH
9572: LD_INT 90
9574: PPUSH
9575: LD_INT 23
9577: PPUSH
9578: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9582: LD_EXP 36
9586: PUSH
9587: LD_INT 2
9589: ARRAY
9590: PPUSH
9591: LD_INT 93
9593: PPUSH
9594: LD_INT 25
9596: PPUSH
9597: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9601: LD_EXP 36
9605: PPUSH
9606: LD_EXP 33
9610: PPUSH
9611: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9615: LD_EXP 33
9619: PUSH
9620: LD_EXP 28
9624: PUSH
9625: EMPTY
9626: LIST
9627: LIST
9628: PPUSH
9629: LD_EXP 24
9633: PPUSH
9634: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9638: LD_EXP 24
9642: PPUSH
9643: LD_EXP 33
9647: PPUSH
9648: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9652: LD_INT 35
9654: PPUSH
9655: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9659: LD_EXP 33
9663: PPUSH
9664: LD_INT 92
9666: PPUSH
9667: LD_INT 21
9669: PPUSH
9670: CALL_OW 307
9674: IFFALSE 9652
// Say ( Omar , DO-1-start ) ;
9676: LD_EXP 33
9680: PPUSH
9681: LD_STRING DO-1-start
9683: PPUSH
9684: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9688: LD_EXP 24
9692: PPUSH
9693: LD_STRING DH-2-start
9695: PPUSH
9696: CALL_OW 88
// if hasAll then
9700: LD_VAR 0 2
9704: IFFALSE 9832
// begin Say ( Omar , DO-2-start ) ;
9706: LD_EXP 33
9710: PPUSH
9711: LD_STRING DO-2-start
9713: PPUSH
9714: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9718: LD_EXP 33
9722: PPUSH
9723: LD_STRING DO-3-start
9725: PPUSH
9726: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
9730: LD_EXP 24
9734: PPUSH
9735: LD_STRING DH-3-start
9737: PPUSH
9738: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
9742: LD_EXP 32
9746: PPUSH
9747: LD_STRING DF-2-start
9749: PPUSH
9750: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9754: LD_EXP 33
9758: PPUSH
9759: LD_EXP 32
9763: PPUSH
9764: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
9768: LD_EXP 33
9772: PPUSH
9773: LD_STRING DO-4-start
9775: PPUSH
9776: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
9780: LD_EXP 32
9784: PPUSH
9785: LD_STRING DF-3-start
9787: PPUSH
9788: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
9792: LD_EXP 33
9796: PPUSH
9797: LD_STRING DO-5-start
9799: PPUSH
9800: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
9804: LD_EXP 32
9808: PPUSH
9809: LD_STRING DF-4-start
9811: PPUSH
9812: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
9816: LD_EXP 33
9820: PPUSH
9821: LD_EXP 24
9825: PPUSH
9826: CALL_OW 119
// end else
9830: GO 9932
// begin Say ( Omar , DO-2-start-a ) ;
9832: LD_EXP 33
9836: PPUSH
9837: LD_STRING DO-2-start-a
9839: PPUSH
9840: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
9844: LD_EXP 33
9848: PPUSH
9849: LD_STRING DO-3-start-a
9851: PPUSH
9852: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
9856: LD_EXP 24
9860: PPUSH
9861: LD_STRING DH-3-start-a
9863: PPUSH
9864: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
9868: LD_EXP 32
9872: PPUSH
9873: LD_STRING DF-2-start-a
9875: PPUSH
9876: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9880: LD_EXP 33
9884: PPUSH
9885: LD_EXP 32
9889: PPUSH
9890: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
9894: LD_EXP 33
9898: PPUSH
9899: LD_STRING DO-4-start-a
9901: PPUSH
9902: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
9906: LD_EXP 32
9910: PPUSH
9911: LD_STRING DF-3-start-a
9913: PPUSH
9914: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
9918: LD_EXP 33
9922: PPUSH
9923: LD_EXP 24
9927: PPUSH
9928: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
9932: LD_INT 10
9934: PPUSH
9935: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
9939: LD_EXP 33
9943: PPUSH
9944: LD_STRING DO-1-mission
9946: PPUSH
9947: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
9951: LD_EXP 33
9955: PPUSH
9956: LD_STRING DO-2-mission
9958: PPUSH
9959: CALL_OW 88
// if not hasAll then
9963: LD_VAR 0 2
9967: NOT
9968: IFFALSE 9982
// Say ( Omar , DO-3-mission ) ;
9970: LD_EXP 33
9974: PPUSH
9975: LD_STRING DO-3-mission
9977: PPUSH
9978: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
9982: LD_EXP 33
9986: PPUSH
9987: LD_STRING DO-4-mission
9989: PPUSH
9990: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
9994: LD_EXP 24
9998: PPUSH
9999: LD_STRING DH-1-mission
10001: PPUSH
10002: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10006: LD_EXP 32
10010: PPUSH
10011: LD_STRING DF-1-mission
10013: PPUSH
10014: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10018: LD_EXP 33
10022: PPUSH
10023: LD_STRING DO-5-mission
10025: PPUSH
10026: CALL_OW 88
// if not hasAll then
10030: LD_VAR 0 2
10034: NOT
10035: IFFALSE 10170
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10037: LD_ADDR_VAR 0 4
10041: PUSH
10042: LD_INT 22
10044: PUSH
10045: LD_INT 2
10047: PUSH
10048: EMPTY
10049: LIST
10050: LIST
10051: PUSH
10052: LD_INT 21
10054: PUSH
10055: LD_INT 1
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: PUSH
10062: LD_INT 23
10064: PUSH
10065: LD_INT 2
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: LIST
10076: PPUSH
10077: CALL_OW 69
10081: ST_TO_ADDR
// for i := 7 downto tmp do
10082: LD_ADDR_VAR 0 3
10086: PUSH
10087: DOUBLE
10088: LD_INT 7
10090: INC
10091: ST_TO_ADDR
10092: LD_VAR 0 4
10096: PUSH
10097: FOR_DOWNTO
10098: IFFALSE 10168
// begin if omarSquad < 3 then
10100: LD_EXP 36
10104: PUSH
10105: LD_INT 3
10107: LESS
10108: IFFALSE 10112
// break ;
10110: GO 10168
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10112: LD_EXP 36
10116: PUSH
10117: LD_INT 3
10119: ARRAY
10120: PPUSH
10121: LD_INT 2
10123: PPUSH
10124: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10128: LD_ADDR_EXP 38
10132: PUSH
10133: LD_EXP 38
10137: PUSH
10138: LD_EXP 36
10142: PUSH
10143: LD_INT 3
10145: ARRAY
10146: UNION
10147: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10148: LD_ADDR_EXP 36
10152: PUSH
10153: LD_EXP 36
10157: PPUSH
10158: LD_INT 3
10160: PPUSH
10161: CALL_OW 3
10165: ST_TO_ADDR
// end ;
10166: GO 10097
10168: POP
10169: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10170: LD_EXP 33
10174: PUSH
10175: LD_EXP 36
10179: ADD
10180: PPUSH
10181: LD_INT 103
10183: PPUSH
10184: LD_INT 9
10186: PPUSH
10187: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10191: LD_VAR 0 2
10195: PUSH
10196: LD_EXP 29
10200: PPUSH
10201: CALL_OW 302
10205: AND
10206: IFFALSE 10267
// begin wait ( 0 0$3 ) ;
10208: LD_INT 105
10210: PPUSH
10211: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10215: LD_EXP 29
10219: PPUSH
10220: LD_EXP 32
10224: PPUSH
10225: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10229: LD_EXP 29
10233: PPUSH
10234: LD_STRING DK-1-side
10236: PPUSH
10237: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10241: LD_EXP 32
10245: PPUSH
10246: LD_EXP 29
10250: PPUSH
10251: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10255: LD_EXP 32
10259: PPUSH
10260: LD_STRING DF-1-side
10262: PPUSH
10263: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10267: LD_INT 22
10269: PUSH
10270: LD_INT 2
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PPUSH
10277: CALL_OW 69
10281: PPUSH
10282: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10286: LD_EXP 32
10290: PUSH
10291: LD_EXP 35
10295: ADD
10296: PPUSH
10297: LD_INT 108
10299: PPUSH
10300: LD_INT 62
10302: PPUSH
10303: CALL_OW 111
// gameStarted := true ;
10307: LD_ADDR_EXP 3
10311: PUSH
10312: LD_INT 1
10314: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10315: LD_INT 105
10317: PPUSH
10318: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10322: LD_EXP 24
10326: PPUSH
10327: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10331: LD_EXP 24
10335: PPUSH
10336: LD_EXP 28
10340: PPUSH
10341: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10345: LD_INT 22
10347: PUSH
10348: LD_INT 2
10350: PUSH
10351: EMPTY
10352: LIST
10353: LIST
10354: PPUSH
10355: CALL_OW 69
10359: PUSH
10360: LD_EXP 24
10364: DIFF
10365: PPUSH
10366: LD_EXP 24
10370: PPUSH
10371: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10375: LD_EXP 24
10379: PPUSH
10380: LD_STRING DH-1-explore
10382: PPUSH
10383: CALL_OW 88
// if Givi then
10387: LD_EXP 25
10391: IFFALSE 10407
// Say ( Givi , DG-1-explore ) else
10393: LD_EXP 25
10397: PPUSH
10398: LD_STRING DG-1-explore
10400: PPUSH
10401: CALL_OW 88
10405: GO 10444
// if heikeSecondSquad then
10407: LD_EXP 38
10411: IFFALSE 10444
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10413: LD_EXP 38
10417: PPUSH
10418: LD_INT 26
10420: PUSH
10421: LD_INT 1
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: PPUSH
10428: CALL_OW 72
10432: PUSH
10433: LD_INT 1
10435: ARRAY
10436: PPUSH
10437: LD_STRING DArm-1-explore
10439: PPUSH
10440: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10444: LD_EXP 28
10448: PPUSH
10449: LD_STRING DA-1-explore
10451: PPUSH
10452: CALL_OW 88
// if Sophia then
10456: LD_EXP 30
10460: IFFALSE 10538
// begin Say ( Sophia , DS-2-explore ) ;
10462: LD_EXP 30
10466: PPUSH
10467: LD_STRING DS-2-explore
10469: PPUSH
10470: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10474: LD_EXP 28
10478: PPUSH
10479: LD_STRING DA-2-explore
10481: PPUSH
10482: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10486: LD_EXP 30
10490: PPUSH
10491: LD_EXP 28
10495: PPUSH
10496: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10500: LD_EXP 28
10504: PPUSH
10505: LD_EXP 30
10509: PPUSH
10510: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10514: LD_EXP 30
10518: PPUSH
10519: LD_STRING DS-3-explore
10521: PPUSH
10522: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10526: LD_EXP 28
10530: PPUSH
10531: LD_STRING DA-3-explore
10533: PPUSH
10534: CALL_OW 88
// end ; if Mike then
10538: LD_EXP 26
10542: IFFALSE 10598
// begin Say ( Mike , DM-1-explore ) ;
10544: LD_EXP 26
10548: PPUSH
10549: LD_STRING DM-1-explore
10551: PPUSH
10552: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10556: LD_EXP 24
10560: PPUSH
10561: LD_STRING DH-2-explore
10563: PPUSH
10564: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10568: LD_EXP 26
10572: PPUSH
10573: LD_STRING DM-2-explore
10575: PPUSH
10576: CALL_OW 88
// if Kaia then
10580: LD_EXP 29
10584: IFFALSE 10598
// Say ( Kaia , DK-1-explore ) ;
10586: LD_EXP 29
10590: PPUSH
10591: LD_STRING DK-1-explore
10593: PPUSH
10594: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10598: LD_INT 22
10600: PUSH
10601: LD_INT 2
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: PPUSH
10613: CALL_OW 139
// Video ( false ) ;
10617: LD_INT 0
10619: PPUSH
10620: CALL 991 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10624: LD_STRING BuildBase
10626: PPUSH
10627: CALL_OW 337
// SaveForQuickRestart ;
10631: CALL_OW 22
// end ;
10635: LD_VAR 0 1
10639: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10640: LD_EXP 5
10644: NOT
10645: PUSH
10646: LD_EXP 6
10650: NOT
10651: AND
10652: PUSH
10653: LD_INT 5
10655: PPUSH
10656: LD_INT 22
10658: PUSH
10659: LD_INT 2
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 70
10670: AND
10671: PUSH
10672: LD_EXP 6
10676: NOT
10677: AND
10678: IFFALSE 10763
10680: GO 10682
10682: DISABLE
// begin if Mike then
10683: LD_EXP 26
10687: IFFALSE 10703
// Say ( Mike , DM-1-scout ) else
10689: LD_EXP 26
10693: PPUSH
10694: LD_STRING DM-1-scout
10696: PPUSH
10697: CALL_OW 88
10701: GO 10734
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10703: LD_EXP 38
10707: PPUSH
10708: LD_INT 26
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 72
10722: PUSH
10723: LD_INT 1
10725: ARRAY
10726: PPUSH
10727: LD_STRING DArm-1-explore
10729: PPUSH
10730: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
10734: LD_INT 54
10736: PPUSH
10737: LD_INT 35
10739: PPUSH
10740: LD_INT 2
10742: PPUSH
10743: LD_INT 1
10745: PPUSH
10746: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
10750: LD_INT 54
10752: PPUSH
10753: LD_INT 35
10755: PPUSH
10756: LD_INT 2
10758: PPUSH
10759: CALL_OW 331
// end ;
10763: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
10764: LD_INT 6
10766: PPUSH
10767: LD_INT 22
10769: PUSH
10770: LD_INT 2
10772: PUSH
10773: EMPTY
10774: LIST
10775: LIST
10776: PPUSH
10777: CALL_OW 70
10781: PUSH
10782: LD_EXP 6
10786: NOT
10787: AND
10788: IFFALSE 11042
10790: GO 10792
10792: DISABLE
10793: LD_INT 0
10795: PPUSH
10796: PPUSH
10797: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
10798: LD_ADDR_VAR 0 1
10802: PUSH
10803: LD_EXP 38
10807: PPUSH
10808: LD_INT 26
10810: PUSH
10811: LD_INT 1
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 72
10822: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
10823: LD_ADDR_VAR 0 2
10827: PUSH
10828: LD_EXP 38
10832: PPUSH
10833: LD_INT 26
10835: PUSH
10836: LD_INT 2
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: PPUSH
10843: CALL_OW 72
10847: ST_TO_ADDR
// DialogueOn ;
10848: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
10852: LD_INT 36
10854: PPUSH
10855: LD_INT 22
10857: PPUSH
10858: LD_INT 2
10860: PPUSH
10861: LD_INT 8
10863: PPUSH
10864: CALL_OW 330
// dwait ( 0 0$1 ) ;
10868: LD_INT 35
10870: PPUSH
10871: CALL_OW 68
// speakerOk := false ;
10875: LD_ADDR_VAR 0 3
10879: PUSH
10880: LD_INT 0
10882: ST_TO_ADDR
// if Mike then
10883: LD_EXP 26
10887: IFFALSE 10909
// speakerOk := Say ( Mike , DM-1-spot ) else
10889: LD_ADDR_VAR 0 3
10893: PUSH
10894: LD_EXP 26
10898: PPUSH
10899: LD_STRING DM-1-spot
10901: PPUSH
10902: CALL_OW 88
10906: ST_TO_ADDR
10907: GO 10937
// if randomMen then
10909: LD_VAR 0 1
10913: IFFALSE 10937
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
10915: LD_ADDR_VAR 0 3
10919: PUSH
10920: LD_VAR 0 1
10924: PUSH
10925: LD_INT 1
10927: ARRAY
10928: PPUSH
10929: LD_STRING DArm-1-spot-a
10931: PPUSH
10932: CALL_OW 88
10936: ST_TO_ADDR
// if speakerOk then
10937: LD_VAR 0 3
10941: IFFALSE 10985
// begin if Givi then
10943: LD_EXP 25
10947: IFFALSE 10963
// Say ( Givi , DG-1-spot ) else
10949: LD_EXP 25
10953: PPUSH
10954: LD_STRING DG-1-spot
10956: PPUSH
10957: CALL_OW 88
10961: GO 10985
// if randomWomen then
10963: LD_VAR 0 2
10967: IFFALSE 10985
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
10969: LD_VAR 0 2
10973: PUSH
10974: LD_INT 1
10976: ARRAY
10977: PPUSH
10978: LD_STRING DArf-1-spot-a
10980: PPUSH
10981: CALL_OW 88
// end ; if Mike then
10985: LD_EXP 26
10989: IFFALSE 11005
// Say ( Heike , DH-1-spot ) else
10991: LD_EXP 24
10995: PPUSH
10996: LD_STRING DH-1-spot
10998: PPUSH
10999: CALL_OW 88
11003: GO 11017
// Say ( Heike , DH-1-spot-a ) ;
11005: LD_EXP 24
11009: PPUSH
11010: LD_STRING DH-1-spot-a
11012: PPUSH
11013: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11017: LD_INT 36
11019: PPUSH
11020: LD_INT 22
11022: PPUSH
11023: LD_INT 2
11025: PPUSH
11026: CALL_OW 331
// DialogueOff ;
11030: CALL_OW 7
// americanBaseSpoted := true ;
11034: LD_ADDR_EXP 5
11038: PUSH
11039: LD_INT 1
11041: ST_TO_ADDR
// end ;
11042: PPOPN 3
11044: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11045: LD_EXP 5
11049: NOT
11050: PUSH
11051: LD_INT 22
11053: PUSH
11054: LD_INT 2
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: PUSH
11061: LD_INT 101
11063: PUSH
11064: LD_INT 1
11066: PUSH
11067: EMPTY
11068: LIST
11069: LIST
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PPUSH
11075: CALL_OW 69
11079: AND
11080: PUSH
11081: LD_EXP 6
11085: NOT
11086: AND
11087: IFFALSE 11173
11089: GO 11091
11091: DISABLE
11092: LD_INT 0
11094: PPUSH
// begin americanBaseSpoted := true ;
11095: LD_ADDR_EXP 5
11099: PUSH
11100: LD_INT 1
11102: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11103: LD_ADDR_VAR 0 1
11107: PUSH
11108: LD_EXP 38
11112: PPUSH
11113: LD_INT 26
11115: PUSH
11116: LD_INT 1
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: PPUSH
11123: CALL_OW 72
11127: ST_TO_ADDR
// if not randomMen then
11128: LD_VAR 0 1
11132: NOT
11133: IFFALSE 11137
// exit ;
11135: GO 11173
// DialogueOn ;
11137: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11141: LD_VAR 0 1
11145: PUSH
11146: LD_INT 1
11148: ARRAY
11149: PPUSH
11150: LD_STRING DArm-1-spot-a
11152: PPUSH
11153: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11157: LD_EXP 24
11161: PPUSH
11162: LD_STRING DH-1-spot-a
11164: PPUSH
11165: CALL_OW 88
// DialogueOff ;
11169: CALL_OW 7
// end ;
11173: PPOPN 1
11175: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) do var i , p ;
11176: LD_INT 11
11178: PPUSH
11179: CALL_OW 255
11183: PUSH
11184: LD_INT 2
11186: EQUAL
11187: PUSH
11188: LD_INT 7
11190: PPUSH
11191: LD_INT 22
11193: PUSH
11194: LD_INT 1
11196: PUSH
11197: EMPTY
11198: LIST
11199: LIST
11200: PUSH
11201: LD_INT 3
11203: PUSH
11204: LD_INT 50
11206: PUSH
11207: EMPTY
11208: LIST
11209: PUSH
11210: EMPTY
11211: LIST
11212: LIST
11213: PUSH
11214: LD_INT 30
11216: PUSH
11217: LD_INT 31
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: LIST
11228: PPUSH
11229: CALL_OW 70
11233: OR
11234: PUSH
11235: LD_INT 7
11237: PPUSH
11238: LD_INT 22
11240: PUSH
11241: LD_INT 2
11243: PUSH
11244: EMPTY
11245: LIST
11246: LIST
11247: PPUSH
11248: CALL_OW 70
11252: PUSH
11253: LD_INT 1
11255: GREATER
11256: OR
11257: PUSH
11258: LD_INT 6
11260: PPUSH
11261: LD_INT 22
11263: PUSH
11264: LD_INT 2
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: PPUSH
11271: CALL_OW 70
11275: OR
11276: IFFALSE 11812
11278: GO 11280
11280: DISABLE
11281: LD_INT 0
11283: PPUSH
11284: PPUSH
// begin americanBaseCaptured := true ;
11285: LD_ADDR_EXP 6
11289: PUSH
11290: LD_INT 1
11292: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11293: LD_INT 105
11295: PPUSH
11296: CALL_OW 67
// if IsOk ( usCommander ) then
11300: LD_EXP 41
11304: PPUSH
11305: CALL_OW 302
11309: IFFALSE 11372
// begin usForces := usForces union usCommander ;
11311: LD_ADDR_EXP 40
11315: PUSH
11316: LD_EXP 40
11320: PUSH
11321: LD_EXP 41
11325: UNION
11326: ST_TO_ADDR
// if FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) then
11327: LD_INT 6
11329: PPUSH
11330: LD_INT 22
11332: PUSH
11333: LD_INT 2
11335: PUSH
11336: EMPTY
11337: LIST
11338: LIST
11339: PPUSH
11340: CALL_OW 70
11344: IFFALSE 11360
// Say ( usCommander , DUsm-2-assault ) else
11346: LD_EXP 41
11350: PPUSH
11351: LD_STRING DUsm-2-assault
11353: PPUSH
11354: CALL_OW 88
11358: GO 11372
// Say ( usCommander , DUsm-1-assault ) ;
11360: LD_EXP 41
11364: PPUSH
11365: LD_STRING DUsm-1-assault
11367: PPUSH
11368: CALL_OW 88
// end ; for i in usForces do
11372: LD_ADDR_VAR 0 1
11376: PUSH
11377: LD_EXP 40
11381: PUSH
11382: FOR_IN
11383: IFFALSE 11422
// begin if IsInUnit ( i ) then
11385: LD_VAR 0 1
11389: PPUSH
11390: CALL_OW 310
11394: IFFALSE 11405
// ComExitBuilding ( i ) ;
11396: LD_VAR 0 1
11400: PPUSH
11401: CALL_OW 122
// AddComMoveXY ( i , 34 , 67 ) ;
11405: LD_VAR 0 1
11409: PPUSH
11410: LD_INT 34
11412: PPUSH
11413: LD_INT 67
11415: PPUSH
11416: CALL_OW 171
// end ;
11420: GO 11382
11422: POP
11423: POP
// Say ( Heike , DH-1-assault ) ;
11424: LD_EXP 24
11428: PPUSH
11429: LD_STRING DH-1-assault
11431: PPUSH
11432: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11436: LD_INT 35
11438: PPUSH
11439: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11443: LD_VAR 0 1
11447: PPUSH
11448: LD_INT 34
11450: PPUSH
11451: LD_INT 67
11453: PPUSH
11454: CALL_OW 111
// until not usForces ;
11458: LD_EXP 40
11462: NOT
11463: IFFALSE 11436
// music_nat := 2 ;
11465: LD_ADDR_OWVAR 71
11469: PUSH
11470: LD_INT 2
11472: ST_TO_ADDR
// music_class := music_victory ;
11473: LD_ADDR_OWVAR 72
11477: PUSH
11478: LD_INT 4
11480: ST_TO_ADDR
// if not americanHasEscaped then
11481: LD_EXP 7
11485: NOT
11486: IFFALSE 11500
// Say ( Heike , DH-2-assault ) ;
11488: LD_EXP 24
11492: PPUSH
11493: LD_STRING DH-2-assault
11495: PPUSH
11496: CALL_OW 88
// wait ( 0 0$2 ) ;
11500: LD_INT 70
11502: PPUSH
11503: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11507: LD_INT 35
11509: PPUSH
11510: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11514: LD_INT 22
11516: PUSH
11517: LD_INT 2
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: PUSH
11524: LD_INT 21
11526: PUSH
11527: LD_INT 1
11529: PUSH
11530: EMPTY
11531: LIST
11532: LIST
11533: PUSH
11534: LD_INT 3
11536: PUSH
11537: LD_INT 50
11539: PUSH
11540: EMPTY
11541: LIST
11542: PUSH
11543: EMPTY
11544: LIST
11545: LIST
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: LIST
11551: PPUSH
11552: CALL_OW 69
11556: NOT
11557: IFFALSE 11507
// Video ( true ) ;
11559: LD_INT 1
11561: PPUSH
11562: CALL 991 0 1
// if not GetSide ( usDepot ) = 2 then
11566: LD_INT 11
11568: PPUSH
11569: CALL_OW 255
11573: PUSH
11574: LD_INT 2
11576: EQUAL
11577: NOT
11578: IFFALSE 11590
// SetSide ( usDepot , 2 ) ;
11580: LD_INT 11
11582: PPUSH
11583: LD_INT 2
11585: PPUSH
11586: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11590: LD_INT 35
11592: PPUSH
11593: LD_INT 22
11595: PPUSH
11596: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11600: LD_EXP 24
11604: PPUSH
11605: LD_INT 35
11607: PPUSH
11608: LD_INT 22
11610: PPUSH
11611: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11615: LD_EXP 24
11619: PPUSH
11620: LD_INT 38
11622: PPUSH
11623: LD_INT 25
11625: PPUSH
11626: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11630: LD_EXP 37
11634: PUSH
11635: LD_EXP 38
11639: UNION
11640: PPUSH
11641: LD_INT 39
11643: PPUSH
11644: LD_INT 26
11646: PPUSH
11647: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11651: LD_EXP 37
11655: PUSH
11656: LD_EXP 38
11660: UNION
11661: PPUSH
11662: LD_EXP 24
11666: PPUSH
11667: CALL_OW 179
// p := 0 ;
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_INT 0
11678: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11679: LD_INT 35
11681: PPUSH
11682: CALL_OW 67
// p := p + 1 ;
11686: LD_ADDR_VAR 0 2
11690: PUSH
11691: LD_VAR 0 2
11695: PUSH
11696: LD_INT 1
11698: PLUS
11699: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11700: LD_EXP 24
11704: PPUSH
11705: CALL_OW 314
11709: NOT
11710: PUSH
11711: LD_VAR 0 2
11715: PUSH
11716: LD_INT 10
11718: GREATER
11719: OR
11720: IFFALSE 11679
// Say ( Heike , DH-1-capture ) ;
11722: LD_EXP 24
11726: PPUSH
11727: LD_STRING DH-1-capture
11729: PPUSH
11730: CALL_OW 88
// if Markov then
11734: LD_EXP 31
11738: IFFALSE 11752
// Say ( Markov , DMar-1-capture ) ;
11740: LD_EXP 31
11744: PPUSH
11745: LD_STRING DMar-1-capture
11747: PPUSH
11748: CALL_OW 88
// if Sophia then
11752: LD_EXP 30
11756: IFFALSE 11782
// begin Say ( Heike , DH-2-capture ) ;
11758: LD_EXP 24
11762: PPUSH
11763: LD_STRING DH-2-capture
11765: PPUSH
11766: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
11770: LD_EXP 30
11774: PPUSH
11775: LD_STRING DS-1-capture
11777: PPUSH
11778: CALL_OW 88
// end ; Video ( false ) ;
11782: LD_INT 0
11784: PPUSH
11785: CALL 991 0 1
// music_nat := music_auto ;
11789: LD_ADDR_OWVAR 71
11793: PUSH
11794: LD_INT 0
11796: ST_TO_ADDR
// music_class := music_auto ;
11797: LD_ADDR_OWVAR 72
11801: PUSH
11802: LD_INT 0
11804: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
11805: LD_STRING ConstructBase
11807: PPUSH
11808: CALL_OW 337
// end ;
11812: PPOPN 2
11814: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
11815: LD_INT 22
11817: PUSH
11818: LD_INT 2
11820: PUSH
11821: EMPTY
11822: LIST
11823: LIST
11824: PUSH
11825: LD_INT 30
11827: PUSH
11828: LD_INT 2
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 3
11837: PUSH
11838: LD_INT 57
11840: PUSH
11841: EMPTY
11842: LIST
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: LIST
11852: PPUSH
11853: CALL_OW 69
11857: IFFALSE 12100
11859: GO 11861
11861: DISABLE
// begin workshopBuilded := true ;
11862: LD_ADDR_EXP 9
11866: PUSH
11867: LD_INT 1
11869: ST_TO_ADDR
// if IsOk ( Markov ) then
11870: LD_EXP 31
11874: PPUSH
11875: CALL_OW 302
11879: IFFALSE 11938
// begin Say ( Heike , DH-1-shop-a ) ;
11881: LD_EXP 24
11885: PPUSH
11886: LD_STRING DH-1-shop-a
11888: PPUSH
11889: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
11893: LD_INT 47
11895: PPUSH
11896: LD_INT 2
11898: PPUSH
11899: CALL_OW 321
11903: PUSH
11904: LD_INT 2
11906: EQUAL
11907: PUSH
11908: LD_INT 45
11910: PPUSH
11911: LD_INT 2
11913: PPUSH
11914: CALL_OW 321
11918: PUSH
11919: LD_INT 2
11921: EQUAL
11922: AND
11923: NOT
11924: IFFALSE 11938
// Say ( Markov , DMar-1-shop-a ) ;
11926: LD_EXP 31
11930: PPUSH
11931: LD_STRING DMar-1-shop-a
11933: PPUSH
11934: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
11938: LD_INT 35
11940: PPUSH
11941: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ;
11945: LD_INT 47
11947: PPUSH
11948: LD_INT 2
11950: PPUSH
11951: CALL_OW 321
11955: PUSH
11956: LD_INT 2
11958: EQUAL
11959: PUSH
11960: LD_INT 45
11962: PPUSH
11963: LD_INT 2
11965: PPUSH
11966: CALL_OW 321
11970: PUSH
11971: LD_INT 2
11973: EQUAL
11974: AND
11975: IFFALSE 11938
// DialogueOn ;
11977: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
11981: LD_EXP 31
11985: PPUSH
11986: LD_STRING DMar-1-shop
11988: PPUSH
11989: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
11993: LD_EXP 24
11997: PPUSH
11998: LD_STRING DH-1-shop
12000: PPUSH
12001: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12005: LD_EXP 31
12009: PPUSH
12010: LD_STRING DMar-2-shop
12012: PPUSH
12013: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12017: LD_EXP 31
12021: PPUSH
12022: LD_STRING DMar-3-shop
12024: PPUSH
12025: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12029: LD_EXP 24
12033: PPUSH
12034: LD_STRING DH-2-shop
12036: PPUSH
12037: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12041: LD_EXP 31
12045: PPUSH
12046: LD_STRING DMar-4-shop
12048: PPUSH
12049: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12053: LD_EXP 24
12057: PPUSH
12058: LD_STRING DH-3-shop
12060: PPUSH
12061: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12065: LD_EXP 31
12069: PPUSH
12070: LD_STRING DMar-5-shop
12072: PPUSH
12073: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12077: LD_EXP 24
12081: PPUSH
12082: LD_STRING DH-4-shop
12084: PPUSH
12085: CALL_OW 88
// DialogueOff ;
12089: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12093: LD_STRING ConstructVeh
12095: PPUSH
12096: CALL_OW 337
// end ;
12100: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12101: LD_INT 2
12103: PPUSH
12104: LD_INT 2
12106: PPUSH
12107: LD_INT 1
12109: PPUSH
12110: CALL 1162 0 3
12114: PUSH
12115: LD_INT 0
12117: EQUAL
12118: IFFALSE 12130
12120: GO 12122
12122: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12123: LD_STRING Techs
12125: PPUSH
12126: CALL_OW 337
12130: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12131: LD_EXP 31
12135: PPUSH
12136: CALL_OW 302
12140: PUSH
12141: LD_INT 22
12143: PUSH
12144: LD_INT 2
12146: PUSH
12147: EMPTY
12148: LIST
12149: LIST
12150: PUSH
12151: LD_INT 2
12153: PUSH
12154: LD_INT 34
12156: PUSH
12157: LD_INT 22
12159: PUSH
12160: EMPTY
12161: LIST
12162: LIST
12163: PUSH
12164: LD_INT 35
12166: PUSH
12167: LD_INT 22
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: PUSH
12174: EMPTY
12175: LIST
12176: LIST
12177: LIST
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 69
12187: AND
12188: IFFALSE 12295
12190: GO 12192
12192: DISABLE
// begin DialogueOn ;
12193: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12197: LD_INT 22
12199: PUSH
12200: LD_INT 2
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: LD_INT 2
12209: PUSH
12210: LD_INT 34
12212: PUSH
12213: LD_INT 22
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: LD_INT 35
12222: PUSH
12223: LD_INT 22
12225: PUSH
12226: EMPTY
12227: LIST
12228: LIST
12229: PUSH
12230: EMPTY
12231: LIST
12232: LIST
12233: LIST
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: PPUSH
12239: CALL_OW 69
12243: PPUSH
12244: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12248: LD_INT 10
12250: PPUSH
12251: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12255: LD_EXP 24
12259: PPUSH
12260: LD_STRING DH-1-bal
12262: PPUSH
12263: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12267: LD_EXP 31
12271: PPUSH
12272: LD_STRING DMar-1-bal
12274: PPUSH
12275: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12279: LD_EXP 24
12283: PPUSH
12284: LD_STRING DH-2-bal
12286: PPUSH
12287: CALL_OW 88
// DialogueOff ;
12291: CALL_OW 7
// end ;
12295: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12296: LD_EXP 28
12300: PPUSH
12301: CALL_OW 302
12305: PUSH
12306: LD_INT 22
12308: PUSH
12309: LD_INT 2
12311: PUSH
12312: EMPTY
12313: LIST
12314: LIST
12315: PUSH
12316: LD_INT 30
12318: PUSH
12319: LD_INT 6
12321: PUSH
12322: EMPTY
12323: LIST
12324: LIST
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PPUSH
12330: CALL_OW 69
12334: AND
12335: IFFALSE 12396
12337: GO 12339
12339: DISABLE
// begin DialogueOn ;
12340: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12344: LD_EXP 28
12348: PPUSH
12349: LD_STRING DA-1-lab
12351: PPUSH
12352: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12356: LD_EXP 24
12360: PPUSH
12361: LD_STRING DH-1-lab
12363: PPUSH
12364: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12368: LD_EXP 28
12372: PPUSH
12373: LD_STRING DA-2-lab
12375: PPUSH
12376: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12380: LD_EXP 24
12384: PPUSH
12385: LD_STRING DH-2-lab
12387: PPUSH
12388: CALL_OW 88
// DialogueOff ;
12392: CALL_OW 7
// end ;
12396: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) do var ape ;
12397: LD_EXP 29
12401: PPUSH
12402: CALL_OW 302
12406: PUSH
12407: LD_INT 22
12409: PUSH
12410: LD_INT 2
12412: PUSH
12413: EMPTY
12414: LIST
12415: LIST
12416: PUSH
12417: LD_INT 25
12419: PUSH
12420: LD_INT 15
12422: PUSH
12423: EMPTY
12424: LIST
12425: LIST
12426: PUSH
12427: EMPTY
12428: LIST
12429: LIST
12430: PPUSH
12431: CALL_OW 69
12435: AND
12436: IFFALSE 12616
12438: GO 12440
12440: DISABLE
12441: LD_INT 0
12443: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12444: LD_ADDR_VAR 0 1
12448: PUSH
12449: LD_INT 22
12451: PUSH
12452: LD_INT 2
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: PUSH
12459: LD_INT 25
12461: PUSH
12462: LD_INT 15
12464: PUSH
12465: EMPTY
12466: LIST
12467: LIST
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: PPUSH
12473: CALL_OW 69
12477: ST_TO_ADDR
// Video ( true ) ;
12478: LD_INT 1
12480: PPUSH
12481: CALL 991 0 1
// CenterNowOnUnits ( ape [ 1 ] ) ;
12485: LD_VAR 0 1
12489: PUSH
12490: LD_INT 1
12492: ARRAY
12493: PPUSH
12494: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12498: LD_VAR 0 1
12502: PUSH
12503: LD_INT 1
12505: ARRAY
12506: PPUSH
12507: CALL_OW 122
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12511: LD_VAR 0 1
12515: PUSH
12516: LD_INT 1
12518: ARRAY
12519: PPUSH
12520: LD_INT 35
12522: PPUSH
12523: LD_INT 28
12525: PPUSH
12526: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12530: LD_VAR 0 1
12534: PUSH
12535: LD_INT 1
12537: ARRAY
12538: PPUSH
12539: LD_INT 36
12541: PPUSH
12542: LD_INT 17
12544: PPUSH
12545: CALL_OW 171
// Say ( Kaia , DK-1-apesol ) ;
12549: LD_EXP 29
12553: PPUSH
12554: LD_STRING DK-1-apesol
12556: PPUSH
12557: CALL_OW 88
// Say ( Aviradze , DA-1-apesol ) ;
12561: LD_EXP 28
12565: PPUSH
12566: LD_STRING DA-1-apesol
12568: PPUSH
12569: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12573: LD_EXP 29
12577: PPUSH
12578: LD_STRING DK-2-apesol
12580: PPUSH
12581: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12585: LD_EXP 28
12589: PPUSH
12590: LD_STRING DA-2-apesol
12592: PPUSH
12593: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12597: LD_EXP 29
12601: PPUSH
12602: LD_STRING DK-3-apesol
12604: PPUSH
12605: CALL_OW 88
// Video ( false ) ;
12609: LD_INT 0
12611: PPUSH
12612: CALL 991 0 1
// end ;
12616: PPOPN 1
12618: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) do var ape ;
12619: LD_EXP 30
12623: PPUSH
12624: CALL_OW 302
12628: PUSH
12629: LD_INT 22
12631: PUSH
12632: LD_INT 2
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: LD_INT 25
12641: PUSH
12642: LD_INT 16
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PUSH
12649: EMPTY
12650: LIST
12651: LIST
12652: PPUSH
12653: CALL_OW 69
12657: AND
12658: IFFALSE 12930
12660: GO 12662
12662: DISABLE
12663: LD_INT 0
12665: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
12666: LD_ADDR_VAR 0 1
12670: PUSH
12671: LD_INT 22
12673: PUSH
12674: LD_INT 2
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: LD_INT 25
12683: PUSH
12684: LD_INT 16
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: PPUSH
12695: CALL_OW 69
12699: ST_TO_ADDR
// Video ( true ) ;
12700: LD_INT 1
12702: PPUSH
12703: CALL 991 0 1
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
12707: LD_INT 5
12709: PPUSH
12710: LD_INT 35
12712: PPUSH
12713: LD_INT 22
12715: PPUSH
12716: LD_INT 1
12718: PPUSH
12719: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
12723: LD_EXP 30
12727: PPUSH
12728: LD_VAR 0 1
12732: PUSH
12733: LD_INT 1
12735: ARRAY
12736: PPUSH
12737: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
12741: LD_VAR 0 1
12745: PUSH
12746: LD_INT 1
12748: ARRAY
12749: PPUSH
12750: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12754: LD_VAR 0 1
12758: PUSH
12759: LD_INT 1
12761: ARRAY
12762: PPUSH
12763: CALL_OW 122
// wait ( 0 0$2 ) ;
12767: LD_INT 70
12769: PPUSH
12770: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
12774: LD_EXP 30
12778: PPUSH
12779: LD_STRING DS-1-apeeng
12781: PPUSH
12782: CALL_OW 88
// if IsOk ( Kamil ) then
12786: LD_EXP 27
12790: PPUSH
12791: CALL_OW 302
12795: IFFALSE 12923
// begin Say ( Kamil , DKam-1-apeeng ) ;
12797: LD_EXP 27
12801: PPUSH
12802: LD_STRING DKam-1-apeeng
12804: PPUSH
12805: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
12809: LD_EXP 30
12813: PPUSH
12814: LD_STRING DS-2-apeeng
12816: PPUSH
12817: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
12821: LD_EXP 27
12825: PPUSH
12826: LD_STRING DKam-2-apeeng
12828: PPUSH
12829: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
12833: LD_EXP 30
12837: PPUSH
12838: LD_STRING DS-3-apeeng
12840: PPUSH
12841: CALL_OW 88
// if not IsOK ( Kaia ) then
12845: LD_EXP 29
12849: PPUSH
12850: CALL_OW 302
12854: NOT
12855: IFFALSE 12866
// begin Video ( false ) ;
12857: LD_INT 0
12859: PPUSH
12860: CALL 991 0 1
// exit ;
12864: GO 12930
// end ; Say ( Kaia , DK-1-apeeng ) ;
12866: LD_EXP 29
12870: PPUSH
12871: LD_STRING DK-1-apeeng
12873: PPUSH
12874: CALL_OW 88
// if not IsOk ( Givi ) then
12878: LD_EXP 25
12882: PPUSH
12883: CALL_OW 302
12887: NOT
12888: IFFALSE 12899
// begin Video ( false ) ;
12890: LD_INT 0
12892: PPUSH
12893: CALL 991 0 1
// exit ;
12897: GO 12930
// end ; Say ( Givi , DG-1-apeeng ) ;
12899: LD_EXP 25
12903: PPUSH
12904: LD_STRING DG-1-apeeng
12906: PPUSH
12907: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
12911: LD_EXP 29
12915: PPUSH
12916: LD_STRING DK-2-apeeng
12918: PPUSH
12919: CALL_OW 88
// end ; Video ( false ) ;
12923: LD_INT 0
12925: PPUSH
12926: CALL 991 0 1
// end ;
12930: PPOPN 1
12932: END
// every 0 0$1 trigger farmerBaseReady and americanBaseCaptured do
12933: LD_EXP 4
12937: PUSH
12938: LD_EXP 6
12942: AND
12943: IFFALSE 13108
12945: GO 12947
12947: DISABLE
// begin wait ( 0 0$20 ) ;
12948: LD_INT 700
12950: PPUSH
12951: CALL_OW 67
// DialogueOn ;
12955: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
12959: LD_EXP 32
12963: PPUSH
12964: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
12968: LD_EXP 32
12972: PPUSH
12973: LD_STRING DF-1-distribution
12975: PPUSH
12976: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
12980: LD_EXP 24
12984: PPUSH
12985: LD_STRING DH-2-distribution
12987: PPUSH
12988: CALL_OW 88
// if IsOk ( Kaia ) then
12992: LD_EXP 29
12996: PPUSH
12997: CALL_OW 302
13001: IFFALSE 13062
// begin Say ( Kaia , DK-1-distribution ) ;
13003: LD_EXP 29
13007: PPUSH
13008: LD_STRING DK-1-distribution
13010: PPUSH
13011: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13015: LD_EXP 24
13019: PPUSH
13020: LD_STRING DH-1-distribution
13022: PPUSH
13023: CALL_OW 88
// if IsOk ( Givi ) then
13027: LD_EXP 25
13031: PPUSH
13032: CALL_OW 302
13036: IFFALSE 13062
// begin Say ( Givi , DG-1-distribution ) ;
13038: LD_EXP 25
13042: PPUSH
13043: LD_STRING DG-1-distribution
13045: PPUSH
13046: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13050: LD_EXP 24
13054: PPUSH
13055: LD_STRING DH-3-distribution
13057: PPUSH
13058: CALL_OW 88
// end ; end ; DialogueOff ;
13062: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13066: LD_STRING Crates1
13068: PPUSH
13069: CALL_OW 337
// farmerRequestedCrates := 300 ;
13073: LD_ADDR_EXP 13
13077: PUSH
13078: LD_INT 300
13080: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13081: LD_STRING FarmerCrates
13083: PPUSH
13084: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13088: LD_INT 10
13090: PPUSH
13091: LD_INT 1
13093: PPUSH
13094: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13098: LD_INT 108
13100: PPUSH
13101: LD_INT 61
13103: PPUSH
13104: CALL_OW 86
// end ;
13108: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13109: LD_EXP 6
13113: PUSH
13114: LD_INT 22
13116: PUSH
13117: LD_INT 2
13119: PUSH
13120: EMPTY
13121: LIST
13122: LIST
13123: PUSH
13124: LD_INT 3
13126: PUSH
13127: LD_INT 57
13129: PUSH
13130: EMPTY
13131: LIST
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: PUSH
13137: LD_INT 2
13139: PUSH
13140: LD_INT 30
13142: PUSH
13143: LD_INT 6
13145: PUSH
13146: EMPTY
13147: LIST
13148: LIST
13149: PUSH
13150: LD_INT 30
13152: PUSH
13153: LD_INT 7
13155: PUSH
13156: EMPTY
13157: LIST
13158: LIST
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: LIST
13164: PUSH
13165: EMPTY
13166: LIST
13167: LIST
13168: LIST
13169: PPUSH
13170: CALL_OW 69
13174: AND
13175: PUSH
13176: LD_INT 22
13178: PUSH
13179: LD_INT 2
13181: PUSH
13182: EMPTY
13183: LIST
13184: LIST
13185: PUSH
13186: LD_INT 3
13188: PUSH
13189: LD_INT 57
13191: PUSH
13192: EMPTY
13193: LIST
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 30
13201: PUSH
13202: LD_INT 4
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PUSH
13209: EMPTY
13210: LIST
13211: LIST
13212: LIST
13213: PPUSH
13214: CALL_OW 69
13218: AND
13219: IFFALSE 13383
13221: GO 13223
13223: DISABLE
13224: LD_INT 0
13226: PPUSH
// begin wait ( 0 0$10 ) ;
13227: LD_INT 350
13229: PPUSH
13230: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13234: LD_ADDR_VAR 0 1
13238: PUSH
13239: LD_EXP 38
13243: PPUSH
13244: LD_INT 26
13246: PUSH
13247: LD_INT 1
13249: PUSH
13250: EMPTY
13251: LIST
13252: LIST
13253: PUSH
13254: LD_INT 25
13256: PUSH
13257: LD_INT 2
13259: PUSH
13260: EMPTY
13261: LIST
13262: LIST
13263: PUSH
13264: EMPTY
13265: LIST
13266: LIST
13267: PPUSH
13268: CALL_OW 72
13272: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13273: LD_EXP 24
13277: PPUSH
13278: LD_STRING DH-1-task
13280: PPUSH
13281: CALL_OW 88
// if IsOk ( Sophia ) then
13285: LD_EXP 30
13289: PPUSH
13290: CALL_OW 302
13294: IFFALSE 13334
// begin Say ( Sophia , DS-1-task ) ;
13296: LD_EXP 30
13300: PPUSH
13301: LD_STRING DS-1-task
13303: PPUSH
13304: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13308: LD_EXP 30
13312: PPUSH
13313: LD_STRING DS-2-task
13315: PPUSH
13316: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13320: LD_EXP 24
13324: PPUSH
13325: LD_STRING DH-2-task
13327: PPUSH
13328: CALL_OW 88
// end else
13332: GO 13368
// if eng then
13334: LD_VAR 0 1
13338: IFFALSE 13368
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13340: LD_VAR 0 1
13344: PUSH
13345: LD_INT 1
13347: ARRAY
13348: PPUSH
13349: LD_STRING DArm-1-task
13351: PPUSH
13352: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13356: LD_EXP 24
13360: PPUSH
13361: LD_STRING DH-2-task
13363: PPUSH
13364: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13368: LD_STRING BaseConstructed
13370: PPUSH
13371: CALL_OW 337
// allowConvoys := true ;
13375: LD_ADDR_EXP 11
13379: PUSH
13380: LD_INT 1
13382: ST_TO_ADDR
// end ;
13383: PPOPN 1
13385: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13386: LD_INT 22
13388: PUSH
13389: LD_INT 4
13391: PUSH
13392: EMPTY
13393: LIST
13394: LIST
13395: PUSH
13396: LD_INT 34
13398: PUSH
13399: LD_INT 12
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PPUSH
13410: CALL_OW 69
13414: IFFALSE 13582
13416: GO 13418
13418: DISABLE
13419: LD_INT 0
13421: PPUSH
13422: PPUSH
13423: PPUSH
// begin wait ( 0 0$2 ) ;
13424: LD_INT 70
13426: PPUSH
13427: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13431: LD_ADDR_VAR 0 1
13435: PUSH
13436: LD_INT 22
13438: PUSH
13439: LD_INT 4
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: PUSH
13446: LD_INT 34
13448: PUSH
13449: LD_INT 12
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PPUSH
13460: CALL_OW 69
13464: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13465: LD_ADDR_VAR 0 2
13469: PUSH
13470: LD_VAR 0 1
13474: PUSH
13475: LD_INT 1
13477: ARRAY
13478: PPUSH
13479: CALL_OW 250
13483: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13484: LD_ADDR_VAR 0 3
13488: PUSH
13489: LD_VAR 0 1
13493: PUSH
13494: LD_INT 1
13496: ARRAY
13497: PPUSH
13498: CALL_OW 251
13502: ST_TO_ADDR
// DialogueOn ;
13503: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13507: LD_VAR 0 2
13511: PPUSH
13512: LD_VAR 0 3
13516: PPUSH
13517: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13521: LD_VAR 0 2
13525: PPUSH
13526: LD_VAR 0 3
13530: PPUSH
13531: LD_INT 2
13533: PPUSH
13534: LD_INT 6
13536: NEG
13537: PPUSH
13538: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13542: LD_INT 10
13544: PPUSH
13545: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13549: LD_EXP 24
13553: PPUSH
13554: LD_STRING DH-1-seecargo
13556: PPUSH
13557: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13561: LD_VAR 0 2
13565: PPUSH
13566: LD_VAR 0 3
13570: PPUSH
13571: LD_INT 2
13573: PPUSH
13574: CALL_OW 331
// DialogueOff ;
13578: CALL_OW 7
// end ;
13582: PPOPN 3
13584: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13585: LD_EXP 4
13589: PUSH
13590: LD_EXP 12
13594: PUSH
13595: LD_INT 300
13597: GREATEREQUAL
13598: AND
13599: IFFALSE 13671
13601: GO 13603
13603: DISABLE
// begin DialogueOn ;
13604: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13608: LD_EXP 32
13612: PPUSH
13613: LD_STRING DF-1-delivery-2
13615: PPUSH
13616: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13620: LD_EXP 24
13624: PPUSH
13625: LD_STRING DH-1-delivery-2
13627: PPUSH
13628: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
13632: LD_EXP 32
13636: PPUSH
13637: LD_STRING DF-2-delivery-2
13639: PPUSH
13640: CALL_OW 94
// DialogueOff ;
13644: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
13648: LD_STRING Crates2
13650: PPUSH
13651: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13655: LD_ADDR_EXP 14
13659: PUSH
13660: LD_INT 63000
13662: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
13663: LD_ADDR_EXP 13
13667: PUSH
13668: LD_INT 600
13670: ST_TO_ADDR
// end ;
13671: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 do
13672: LD_EXP 4
13676: PUSH
13677: LD_EXP 12
13681: PUSH
13682: LD_INT 600
13684: GREATEREQUAL
13685: AND
13686: IFFALSE 13852
13688: GO 13690
13690: DISABLE
// begin DialogueOn ;
13691: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
13695: LD_EXP 32
13699: PPUSH
13700: LD_STRING DF-1-delivery-3
13702: PPUSH
13703: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
13707: LD_EXP 24
13711: PPUSH
13712: LD_STRING DH-1-delivery-3
13714: PPUSH
13715: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
13719: LD_EXP 32
13723: PPUSH
13724: LD_STRING DF-2-delivery-3
13726: PPUSH
13727: CALL_OW 94
// if IsOk ( Kaia ) then
13731: LD_EXP 29
13735: PPUSH
13736: CALL_OW 302
13740: IFFALSE 13790
// begin Say ( Kaia , DK-1-delivery-3 ) ;
13742: LD_EXP 29
13746: PPUSH
13747: LD_STRING DK-1-delivery-3
13749: PPUSH
13750: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
13754: LD_EXP 24
13758: PPUSH
13759: LD_STRING DH-2-delivery-3
13761: PPUSH
13762: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
13766: LD_EXP 25
13770: PPUSH
13771: LD_STRING DG-1-delivery-3
13773: PPUSH
13774: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
13778: LD_EXP 26
13782: PPUSH
13783: LD_STRING DM-1-delivery-3
13785: PPUSH
13786: CALL_OW 88
// end ; DialogueOff ;
13790: CALL_OW 7
// if Difficulty = 2 then
13794: LD_OWVAR 67
13798: PUSH
13799: LD_INT 2
13801: EQUAL
13802: IFFALSE 13829
// begin ChangeMissionObjectives ( Crates3 ) ;
13804: LD_STRING Crates3
13806: PPUSH
13807: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13811: LD_ADDR_EXP 14
13815: PUSH
13816: LD_INT 63000
13818: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
13819: LD_ADDR_EXP 13
13823: PUSH
13824: LD_INT 900
13826: ST_TO_ADDR
// end else
13827: GO 13852
// begin ChangeMissionObjectives ( Crates4 ) ;
13829: LD_STRING Crates4
13831: PPUSH
13832: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13836: LD_ADDR_EXP 14
13840: PUSH
13841: LD_INT 63000
13843: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
13844: LD_ADDR_EXP 13
13848: PUSH
13849: LD_INT 1200
13851: ST_TO_ADDR
// end ; end ;
13852: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
13853: LD_EXP 4
13857: PUSH
13858: LD_EXP 12
13862: PUSH
13863: LD_INT 600
13865: PUSH
13866: LD_INT 900
13868: PUSH
13869: LD_INT 1200
13871: PUSH
13872: EMPTY
13873: LIST
13874: LIST
13875: LIST
13876: PUSH
13877: LD_OWVAR 67
13881: ARRAY
13882: GREATEREQUAL
13883: AND
13884: PUSH
13885: LD_EXP 13
13889: PUSH
13890: LD_EXP 14
13894: LESSEQUAL
13895: AND
13896: IFFALSE 13969
13898: GO 13900
13900: DISABLE
// begin retreatAllowed := true ;
13901: LD_ADDR_EXP 10
13905: PUSH
13906: LD_INT 1
13908: ST_TO_ADDR
// display_strings := [ ] ;
13909: LD_ADDR_OWVAR 47
13913: PUSH
13914: EMPTY
13915: ST_TO_ADDR
// DialogueOn ;
13916: CALL_OW 6
// Video ( true ) ;
13920: LD_INT 1
13922: PPUSH
13923: CALL 991 0 1
// SayRadio ( Omar , DO-radio-end ) ;
13927: LD_EXP 33
13931: PPUSH
13932: LD_STRING DO-radio-end
13934: PPUSH
13935: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
13939: LD_EXP 24
13943: PPUSH
13944: LD_STRING DH-1-radio-end
13946: PPUSH
13947: CALL_OW 88
// Video ( false ) ;
13951: LD_INT 0
13953: PPUSH
13954: CALL 991 0 1
// DialogueOff ;
13958: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
13962: LD_STRING Retreat
13964: PPUSH
13965: CALL_OW 337
// end ;
13969: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
13970: LD_EXP 10
13974: IFFALSE 14144
13976: GO 13978
13978: DISABLE
13979: LD_INT 0
13981: PPUSH
13982: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
13983: LD_INT 10
13985: PPUSH
13986: LD_INT 0
13988: PPUSH
13989: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
13993: LD_ADDR_VAR 0 1
13997: PUSH
13998: LD_EXP 35
14002: PPUSH
14003: LD_INT 25
14005: PUSH
14006: LD_INT 2
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: PPUSH
14013: CALL_OW 72
14017: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14018: LD_VAR 0 1
14022: PUSH
14023: LD_INT 102
14025: PPUSH
14026: LD_INT 69
14028: PPUSH
14029: CALL_OW 428
14033: PUSH
14034: LD_INT 0
14036: EQUAL
14037: AND
14038: IFFALSE 14140
// begin SetResourceType ( GetBase ( arDepot ) , mat_cans , GetResourceType ( GetBase ( arDepot ) , mat_cans ) + 10 ) ;
14040: LD_INT 5
14042: PPUSH
14043: CALL_OW 274
14047: PPUSH
14048: LD_INT 1
14050: PPUSH
14051: LD_INT 5
14053: PPUSH
14054: CALL_OW 274
14058: PPUSH
14059: LD_INT 1
14061: PPUSH
14062: CALL_OW 275
14066: PUSH
14067: LD_INT 10
14069: PLUS
14070: PPUSH
14071: CALL_OW 277
// for i in tmp do
14075: LD_ADDR_VAR 0 2
14079: PUSH
14080: LD_VAR 0 1
14084: PUSH
14085: FOR_IN
14086: IFFALSE 14110
// if IsInUnit ( i ) then
14088: LD_VAR 0 2
14092: PPUSH
14093: CALL_OW 310
14097: IFFALSE 14108
// ComExitBuilding ( i ) ;
14099: LD_VAR 0 2
14103: PPUSH
14104: CALL_OW 122
14108: GO 14085
14110: POP
14111: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14112: LD_VAR 0 1
14116: PPUSH
14117: LD_INT 31
14119: PPUSH
14120: LD_INT 102
14122: PPUSH
14123: LD_INT 69
14125: PPUSH
14126: LD_INT 2
14128: PPUSH
14129: CALL_OW 205
// wait ( 0 0$3 ) ;
14133: LD_INT 105
14135: PPUSH
14136: CALL_OW 67
// end ; StartCargoEvacuation ;
14140: CALL 4457 0 0
// end ;
14144: PPOPN 2
14146: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14147: LD_EXP 10
14151: NOT
14152: PUSH
14153: LD_INT 5
14155: PPUSH
14156: CALL_OW 301
14160: AND
14161: IFFALSE 14185
14163: GO 14165
14165: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
14166: LD_EXP 32
14170: PPUSH
14171: LD_STRING DF-1-failure
14173: PPUSH
14174: CALL_OW 94
// YouLost ( FarmerDepot ) ;
14178: LD_STRING FarmerDepot
14180: PPUSH
14181: CALL_OW 104
// end ;
14185: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 do var i , max , tmp ;
14186: LD_EXP 10
14190: PUSH
14191: LD_EXP 24
14195: PPUSH
14196: LD_EXP 32
14200: PPUSH
14201: CALL_OW 296
14205: PUSH
14206: LD_INT 6
14208: LESS
14209: AND
14210: IFFALSE 14796
14212: GO 14214
14214: DISABLE
14215: LD_INT 0
14217: PPUSH
14218: PPUSH
14219: PPUSH
// begin allowConvoys := false ;
14220: LD_ADDR_EXP 11
14224: PUSH
14225: LD_INT 0
14227: ST_TO_ADDR
// Video ( true ) ;
14228: LD_INT 1
14230: PPUSH
14231: CALL 991 0 1
// ComTurnUnit ( Heike , Farmer ) ;
14235: LD_EXP 24
14239: PPUSH
14240: LD_EXP 32
14244: PPUSH
14245: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14249: LD_EXP 32
14253: PPUSH
14254: LD_EXP 24
14258: PPUSH
14259: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14263: LD_EXP 32
14267: PPUSH
14268: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14272: LD_EXP 24
14276: PPUSH
14277: LD_STRING DH-1-end
14279: PPUSH
14280: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14284: LD_EXP 32
14288: PPUSH
14289: LD_STRING DF-1-end
14291: PPUSH
14292: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14296: LD_EXP 32
14300: PPUSH
14301: LD_STRING DF-2-end
14303: PPUSH
14304: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14308: LD_EXP 24
14312: PPUSH
14313: LD_STRING DH-2-end
14315: PPUSH
14316: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14320: LD_EXP 32
14324: PPUSH
14325: LD_STRING DF-3-end
14327: PPUSH
14328: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14332: LD_EXP 24
14336: PPUSH
14337: LD_STRING DH-3-end
14339: PPUSH
14340: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14344: LD_EXP 25
14348: PPUSH
14349: LD_STRING DG-1-end
14351: PPUSH
14352: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14356: LD_EXP 24
14360: PPUSH
14361: LD_STRING DH-4-end
14363: PPUSH
14364: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14368: LD_EXP 32
14372: PPUSH
14373: LD_STRING DF-4-end
14375: PPUSH
14376: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14380: LD_EXP 24
14384: PPUSH
14385: LD_STRING DH-5-end
14387: PPUSH
14388: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14392: LD_EXP 32
14396: PPUSH
14397: LD_STRING DF-5-end
14399: PPUSH
14400: CALL_OW 88
// Video ( false ) ;
14404: LD_INT 0
14406: PPUSH
14407: CALL 991 0 1
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14411: LD_ADDR_VAR 0 2
14415: PUSH
14416: LD_INT 4
14418: PUSH
14419: LD_INT 3
14421: PUSH
14422: LD_INT 2
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: LIST
14429: PUSH
14430: LD_OWVAR 67
14434: ARRAY
14435: ST_TO_ADDR
// if farmerSquad < max then
14436: LD_EXP 35
14440: PUSH
14441: LD_VAR 0 2
14445: LESS
14446: IFFALSE 14458
// max := farmerSquad ;
14448: LD_ADDR_VAR 0 2
14452: PUSH
14453: LD_EXP 35
14457: ST_TO_ADDR
// for i := 1 to max do
14458: LD_ADDR_VAR 0 1
14462: PUSH
14463: DOUBLE
14464: LD_INT 1
14466: DEC
14467: ST_TO_ADDR
14468: LD_VAR 0 2
14472: PUSH
14473: FOR_TO
14474: IFFALSE 14512
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14476: LD_EXP 35
14480: PUSH
14481: LD_INT 1
14483: ARRAY
14484: PPUSH
14485: LD_INT 2
14487: PPUSH
14488: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14492: LD_ADDR_EXP 35
14496: PUSH
14497: LD_EXP 35
14501: PPUSH
14502: LD_INT 1
14504: PPUSH
14505: CALL_OW 3
14509: ST_TO_ADDR
// end ;
14510: GO 14473
14512: POP
14513: POP
// for i in Farmer ^ farmerSquad do
14514: LD_ADDR_VAR 0 1
14518: PUSH
14519: LD_EXP 32
14523: PUSH
14524: LD_EXP 35
14528: ADD
14529: PUSH
14530: FOR_IN
14531: IFFALSE 14570
// begin if IsInUnit ( i ) then
14533: LD_VAR 0 1
14537: PPUSH
14538: CALL_OW 310
14542: IFFALSE 14553
// ComExitBuilding ( i ) ;
14544: LD_VAR 0 1
14548: PPUSH
14549: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14553: LD_VAR 0 1
14557: PPUSH
14558: LD_INT 102
14560: PPUSH
14561: LD_INT 7
14563: PPUSH
14564: CALL_OW 171
// end ;
14568: GO 14530
14570: POP
14571: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14572: LD_ADDR_VAR 0 1
14576: PUSH
14577: LD_INT 22
14579: PUSH
14580: LD_INT 5
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PUSH
14587: LD_INT 21
14589: PUSH
14590: LD_INT 3
14592: PUSH
14593: EMPTY
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: PPUSH
14601: CALL_OW 69
14605: PUSH
14606: LD_INT 5
14608: DIFF
14609: PUSH
14610: FOR_IN
14611: IFFALSE 14627
// SetSide ( i , 2 ) ;
14613: LD_VAR 0 1
14617: PPUSH
14618: LD_INT 2
14620: PPUSH
14621: CALL_OW 235
14625: GO 14610
14627: POP
14628: POP
// repeat wait ( 0 0$1 ) ;
14629: LD_INT 35
14631: PPUSH
14632: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
14636: LD_ADDR_VAR 0 3
14640: PUSH
14641: LD_EXP 32
14645: PUSH
14646: LD_EXP 35
14650: ADD
14651: PPUSH
14652: LD_INT 95
14654: PUSH
14655: LD_INT 3
14657: PUSH
14658: EMPTY
14659: LIST
14660: LIST
14661: PPUSH
14662: CALL_OW 72
14666: ST_TO_ADDR
// if tmp then
14667: LD_VAR 0 3
14671: IFFALSE 14715
// for i in tmp do
14673: LD_ADDR_VAR 0 1
14677: PUSH
14678: LD_VAR 0 3
14682: PUSH
14683: FOR_IN
14684: IFFALSE 14713
// begin farmerSquad := farmerSquad diff i ;
14686: LD_ADDR_EXP 35
14690: PUSH
14691: LD_EXP 35
14695: PUSH
14696: LD_VAR 0 1
14700: DIFF
14701: ST_TO_ADDR
// RemoveUnit ( i ) ;
14702: LD_VAR 0 1
14706: PPUSH
14707: CALL_OW 64
// end ;
14711: GO 14683
14713: POP
14714: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
14715: LD_EXP 35
14719: PUSH
14720: EMPTY
14721: EQUAL
14722: PUSH
14723: LD_EXP 32
14727: PPUSH
14728: CALL_OW 305
14732: NOT
14733: AND
14734: IFFALSE 14629
// wait ( 1 1$00 ) ;
14736: LD_INT 2100
14738: PPUSH
14739: CALL_OW 67
// SendAttack ;
14743: CALL 6841 0 0
// wait ( [ 5 5$00 , 4 4$30 , 4 4$00 ] [ Difficulty ] ) ;
14747: LD_INT 10500
14749: PUSH
14750: LD_INT 9450
14752: PUSH
14753: LD_INT 8400
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: LIST
14760: PUSH
14761: LD_OWVAR 67
14765: ARRAY
14766: PPUSH
14767: CALL_OW 67
// SendAttack ;
14771: CALL 6841 0 0
// if Difficulty > 2 then
14775: LD_OWVAR 67
14779: PUSH
14780: LD_INT 2
14782: GREATER
14783: IFFALSE 14796
// begin wait ( 4 4$00 ) ;
14785: LD_INT 8400
14787: PPUSH
14788: CALL_OW 67
// SendAttack ;
14792: CALL 6841 0 0
// end ; end ;
14796: PPOPN 3
14798: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
14799: LD_EXP 14
14803: PUSH
14804: LD_INT 18900
14806: LESSEQUAL
14807: IFFALSE 14856
14809: GO 14811
14811: DISABLE
// begin DialogueOn ;
14812: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
14816: LD_EXP 32
14820: PPUSH
14821: LD_STRING DF-1-distribution-a
14823: PPUSH
14824: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
14828: LD_EXP 24
14832: PPUSH
14833: LD_STRING DH-1-distribution-a
14835: PPUSH
14836: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
14840: LD_EXP 32
14844: PPUSH
14845: LD_STRING DF-2-distribution-a
14847: PPUSH
14848: CALL_OW 94
// DialogueOff ;
14852: CALL_OW 7
// end ;
14856: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
14857: LD_EXP 14
14861: PUSH
14862: LD_INT 0
14864: LESSEQUAL
14865: IFFALSE 14897
14867: GO 14869
14869: DISABLE
// begin DialogueOn ;
14870: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
14874: LD_EXP 32
14878: PPUSH
14879: LD_STRING DF-3-distribution-a
14881: PPUSH
14882: CALL_OW 94
// YouLost ( Distribution ) ;
14886: LD_STRING Distribution
14888: PPUSH
14889: CALL_OW 104
// DialogueOff ;
14893: CALL_OW 7
// end ;
14897: END
// every 0 0$1 trigger vehCounter >= 2 do
14898: LD_EXP 18
14902: PUSH
14903: LD_INT 2
14905: GREATEREQUAL
14906: IFFALSE 14918
14908: GO 14910
14910: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
14911: LD_STRING VehConstructed
14913: PPUSH
14914: CALL_OW 337
14918: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
14919: LD_INT 22
14921: PUSH
14922: LD_INT 2
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PUSH
14929: LD_INT 34
14931: PUSH
14932: LD_INT 12
14934: PUSH
14935: EMPTY
14936: LIST
14937: LIST
14938: PUSH
14939: EMPTY
14940: LIST
14941: LIST
14942: PPUSH
14943: CALL_OW 69
14947: IFFALSE 15007
14949: GO 14951
14951: DISABLE
// begin DialogueOn ;
14952: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
14956: LD_EXP 24
14960: PPUSH
14961: LD_STRING DH-1-truck
14963: PPUSH
14964: CALL_OW 88
// if IsOk ( Markov ) then
14968: LD_EXP 31
14972: PPUSH
14973: CALL_OW 302
14977: IFFALSE 15003
// begin Say ( Markov , DMar-1-truck ) ;
14979: LD_EXP 31
14983: PPUSH
14984: LD_STRING DMar-1-truck
14986: PPUSH
14987: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
14991: LD_EXP 24
14995: PPUSH
14996: LD_STRING DH-2-truck
14998: PPUSH
14999: CALL_OW 88
// end ; DialogueOff ;
15003: CALL_OW 7
// end ;
15007: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
15008: LD_INT 0
15010: PPUSH
15011: PPUSH
15012: PPUSH
// if IsOk ( Givi ) then
15013: LD_EXP 25
15017: PPUSH
15018: CALL_OW 302
15022: IFFALSE 15038
// begin Say ( Givi , DG-1-nocargo ) ;
15024: LD_EXP 25
15028: PPUSH
15029: LD_STRING DG-1-nocargo
15031: PPUSH
15032: CALL_OW 88
// exit ;
15036: GO 15134
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15038: LD_ADDR_VAR 0 2
15042: PUSH
15043: LD_EXP 38
15047: PPUSH
15048: LD_INT 26
15050: PUSH
15051: LD_INT 1
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: PPUSH
15058: CALL_OW 72
15062: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15063: LD_ADDR_VAR 0 3
15067: PUSH
15068: LD_EXP 38
15072: PPUSH
15073: LD_INT 26
15075: PUSH
15076: LD_INT 2
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PPUSH
15083: CALL_OW 72
15087: ST_TO_ADDR
// if randomMen then
15088: LD_VAR 0 2
15092: IFFALSE 15112
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15094: LD_VAR 0 2
15098: PUSH
15099: LD_INT 1
15101: ARRAY
15102: PPUSH
15103: LD_STRING DArm-1-nocargo
15105: PPUSH
15106: CALL_OW 88
15110: GO 15134
// if randomWomen then
15112: LD_VAR 0 3
15116: IFFALSE 15134
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15118: LD_VAR 0 3
15122: PUSH
15123: LD_INT 1
15125: ARRAY
15126: PPUSH
15127: LD_STRING DArf-1-nocargo
15129: PPUSH
15130: CALL_OW 88
// end ;
15134: LD_VAR 0 1
15138: RET
// export function IncomingAttack ; begin
15139: LD_INT 0
15141: PPUSH
// if attackWave = 1 then
15142: LD_EXP 16
15146: PUSH
15147: LD_INT 1
15149: EQUAL
15150: IFFALSE 15221
// begin DialogueOn ;
15152: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15156: LD_EXP 33
15160: PPUSH
15161: LD_STRING DO-1-radio-1
15163: PPUSH
15164: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15168: LD_EXP 24
15172: PPUSH
15173: LD_STRING DH-1-radio-1-
15175: PPUSH
15176: CALL_OW 88
// if IsOk ( Markov ) then
15180: LD_EXP 31
15184: PPUSH
15185: CALL_OW 302
15189: IFFALSE 15215
// begin Say ( Markov , DMar-1-radio-1 ) ;
15191: LD_EXP 31
15195: PPUSH
15196: LD_STRING DMar-1-radio-1
15198: PPUSH
15199: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15203: LD_EXP 24
15207: PPUSH
15208: LD_STRING DH-2-radio-1
15210: PPUSH
15211: CALL_OW 88
// end ; DialogueOff ;
15215: CALL_OW 7
// end else
15219: GO 15245
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15221: LD_EXP 33
15225: PPUSH
15226: LD_STRING DO-1-radio-u
15228: PPUSH
15229: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15233: LD_EXP 24
15237: PPUSH
15238: LD_STRING DH-1-radio-u
15240: PPUSH
15241: CALL_OW 88
// end ; end ;
15245: LD_VAR 0 1
15249: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15250: LD_EXP 40
15254: PPUSH
15255: LD_INT 95
15257: PUSH
15258: LD_INT 8
15260: PUSH
15261: EMPTY
15262: LIST
15263: LIST
15264: PPUSH
15265: CALL_OW 72
15269: IFFALSE 15372
15271: GO 15273
15273: DISABLE
15274: LD_INT 0
15276: PPUSH
// begin enable ;
15277: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15278: LD_ADDR_VAR 0 1
15282: PUSH
15283: LD_EXP 40
15287: PPUSH
15288: LD_INT 95
15290: PUSH
15291: LD_INT 8
15293: PUSH
15294: EMPTY
15295: LIST
15296: LIST
15297: PPUSH
15298: CALL_OW 72
15302: PUSH
15303: FOR_IN
15304: IFFALSE 15333
// begin usForces := usForces diff i ;
15306: LD_ADDR_EXP 40
15310: PUSH
15311: LD_EXP 40
15315: PUSH
15316: LD_VAR 0 1
15320: DIFF
15321: ST_TO_ADDR
// RemoveUnit ( i ) ;
15322: LD_VAR 0 1
15326: PPUSH
15327: CALL_OW 64
// end ;
15331: GO 15303
15333: POP
15334: POP
// if not americanHasEscaped and attackWave = 1 then
15335: LD_EXP 7
15339: NOT
15340: PUSH
15341: LD_EXP 16
15345: PUSH
15346: LD_INT 1
15348: EQUAL
15349: AND
15350: IFFALSE 15372
// begin americanHasEscaped := true ;
15352: LD_ADDR_EXP 7
15356: PUSH
15357: LD_INT 1
15359: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15360: LD_EXP 24
15364: PPUSH
15365: LD_STRING DH-2-assault-a
15367: PPUSH
15368: CALL_OW 88
// end ; end ;
15372: PPOPN 1
15374: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) do
15375: LD_INT 4
15377: PPUSH
15378: LD_INT 22
15380: PUSH
15381: LD_INT 1
15383: PUSH
15384: EMPTY
15385: LIST
15386: LIST
15387: PPUSH
15388: CALL_OW 70
15392: IFFALSE 15409
15394: GO 15396
15396: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15397: LD_EXP 32
15401: PPUSH
15402: LD_STRING DF-1-attack
15404: PPUSH
15405: CALL_OW 94
15409: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15410: LD_INT 5
15412: PPUSH
15413: CALL_OW 255
15417: PUSH
15418: LD_INT 2
15420: EQUAL
15421: IFFALSE 15433
15423: GO 15425
15425: DISABLE
// YouLost ( Attack ) ;
15426: LD_STRING Attack
15428: PPUSH
15429: CALL_OW 104
15433: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 90 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot , p ;
15434: LD_INT 22
15436: PUSH
15437: LD_INT 1
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 21
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: PUSH
15454: EMPTY
15455: LIST
15456: LIST
15457: PPUSH
15458: CALL_OW 69
15462: NOT
15463: PUSH
15464: LD_INT 22
15466: PUSH
15467: LD_INT 4
15469: PUSH
15470: EMPTY
15471: LIST
15472: LIST
15473: PPUSH
15474: CALL_OW 69
15478: NOT
15479: AND
15480: PUSH
15481: LD_EXP 10
15485: NOT
15486: AND
15487: PUSH
15488: LD_EXP 12
15492: PUSH
15493: LD_INT 90
15495: GREATER
15496: AND
15497: PUSH
15498: LD_INT 7
15500: PPUSH
15501: LD_INT 22
15503: PUSH
15504: LD_INT 2
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PUSH
15511: LD_INT 21
15513: PUSH
15514: LD_INT 1
15516: PUSH
15517: EMPTY
15518: LIST
15519: LIST
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: PPUSH
15525: CALL_OW 70
15529: AND
15530: PUSH
15531: LD_INT 22
15533: PUSH
15534: LD_INT 2
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: PUSH
15541: LD_INT 50
15543: PUSH
15544: EMPTY
15545: LIST
15546: PUSH
15547: LD_INT 30
15549: PUSH
15550: LD_INT 0
15552: PUSH
15553: EMPTY
15554: LIST
15555: LIST
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: LIST
15561: PPUSH
15562: CALL_OW 69
15566: AND
15567: IFFALSE 16397
15569: GO 15571
15571: DISABLE
15572: LD_INT 0
15574: PPUSH
15575: PPUSH
15576: PPUSH
15577: PPUSH
15578: PPUSH
15579: PPUSH
// begin depot := usDepot ;
15580: LD_ADDR_VAR 0 5
15584: PUSH
15585: LD_INT 11
15587: ST_TO_ADDR
// if not depot then
15588: LD_VAR 0 5
15592: NOT
15593: IFFALSE 15633
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
15595: LD_ADDR_VAR 0 5
15599: PUSH
15600: LD_INT 22
15602: PUSH
15603: LD_INT 2
15605: PUSH
15606: EMPTY
15607: LIST
15608: LIST
15609: PUSH
15610: LD_INT 30
15612: PUSH
15613: LD_INT 0
15615: PUSH
15616: EMPTY
15617: LIST
15618: LIST
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: PPUSH
15624: CALL_OW 69
15628: PUSH
15629: LD_INT 1
15631: ARRAY
15632: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15633: LD_ADDR_VAR 0 1
15637: PUSH
15638: LD_EXP 38
15642: PPUSH
15643: LD_INT 26
15645: PUSH
15646: LD_INT 1
15648: PUSH
15649: EMPTY
15650: LIST
15651: LIST
15652: PPUSH
15653: CALL_OW 72
15657: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15658: LD_ADDR_VAR 0 2
15662: PUSH
15663: LD_EXP 38
15667: PPUSH
15668: LD_INT 26
15670: PUSH
15671: LD_INT 2
15673: PUSH
15674: EMPTY
15675: LIST
15676: LIST
15677: PPUSH
15678: CALL_OW 72
15682: ST_TO_ADDR
// if IsOk ( Kaia ) then
15683: LD_EXP 29
15687: PPUSH
15688: CALL_OW 302
15692: IFFALSE 15713
// speaker := [ Kaia , DK ] else
15694: LD_ADDR_VAR 0 3
15698: PUSH
15699: LD_EXP 29
15703: PUSH
15704: LD_STRING DK
15706: PUSH
15707: EMPTY
15708: LIST
15709: LIST
15710: ST_TO_ADDR
15711: GO 15793
// if randomMen then
15713: LD_VAR 0 1
15717: IFFALSE 15752
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
15719: LD_ADDR_VAR 0 3
15723: PUSH
15724: LD_VAR 0 1
15728: PUSH
15729: LD_INT 1
15731: PPUSH
15732: LD_VAR 0 1
15736: PPUSH
15737: CALL_OW 12
15741: ARRAY
15742: PUSH
15743: LD_STRING DArm
15745: PUSH
15746: EMPTY
15747: LIST
15748: LIST
15749: ST_TO_ADDR
15750: GO 15793
// if randomWomen then
15752: LD_VAR 0 2
15756: IFFALSE 15791
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
15758: LD_ADDR_VAR 0 3
15762: PUSH
15763: LD_VAR 0 2
15767: PUSH
15768: LD_INT 1
15770: PPUSH
15771: LD_VAR 0 2
15775: PPUSH
15776: CALL_OW 12
15780: ARRAY
15781: PUSH
15782: LD_STRING DArf
15784: PUSH
15785: EMPTY
15786: LIST
15787: LIST
15788: ST_TO_ADDR
15789: GO 15793
// exit ;
15791: GO 16397
// if IsInUnit ( speaker [ 1 ] ) then
15793: LD_VAR 0 3
15797: PUSH
15798: LD_INT 1
15800: ARRAY
15801: PPUSH
15802: CALL_OW 310
15806: IFFALSE 15829
// place := IsInUnit ( speaker [ 1 ] ) else
15808: LD_ADDR_VAR 0 4
15812: PUSH
15813: LD_VAR 0 3
15817: PUSH
15818: LD_INT 1
15820: ARRAY
15821: PPUSH
15822: CALL_OW 310
15826: ST_TO_ADDR
15827: GO 15843
// place := speaker [ 1 ] ;
15829: LD_ADDR_VAR 0 4
15833: PUSH
15834: LD_VAR 0 3
15838: PUSH
15839: LD_INT 1
15841: ARRAY
15842: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
15843: LD_VAR 0 4
15847: PPUSH
15848: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
15852: LD_VAR 0 4
15856: PPUSH
15857: CALL_OW 250
15861: PPUSH
15862: LD_VAR 0 4
15866: PPUSH
15867: CALL_OW 251
15871: PPUSH
15872: CALL 2992 0 2
// wait ( 0 0$2 ) ;
15876: LD_INT 70
15878: PPUSH
15879: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
15883: LD_EXP 34
15887: PPUSH
15888: CALL_OW 305
15892: NOT
15893: IFFALSE 15897
// exit ;
15895: GO 16397
// allowConvoys := false ;
15897: LD_ADDR_EXP 11
15901: PUSH
15902: LD_INT 0
15904: ST_TO_ADDR
// InGameOn ;
15905: CALL_OW 8
// wait ( 0 0$1 ) ;
15909: LD_INT 35
15911: PPUSH
15912: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
15916: LD_EXP 34
15920: PPUSH
15921: LD_STRING DI-1-land
15923: PPUSH
15924: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
15928: LD_VAR 0 3
15932: PUSH
15933: LD_INT 1
15935: ARRAY
15936: PPUSH
15937: CALL_OW 310
15941: IFFALSE 15956
// ComExit ( speaker [ 1 ] ) ;
15943: LD_VAR 0 3
15947: PUSH
15948: LD_INT 1
15950: ARRAY
15951: PPUSH
15952: CALL 1095 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
15956: LD_VAR 0 3
15960: PUSH
15961: LD_INT 1
15963: ARRAY
15964: PPUSH
15965: LD_EXP 34
15969: PPUSH
15970: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
15974: LD_VAR 0 3
15978: PUSH
15979: LD_INT 1
15981: ARRAY
15982: PPUSH
15983: LD_EXP 34
15987: PPUSH
15988: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
15992: LD_EXP 34
15996: PPUSH
15997: LD_VAR 0 3
16001: PUSH
16002: LD_INT 1
16004: ARRAY
16005: PPUSH
16006: CALL_OW 119
// wait ( 0 0$1 ) ;
16010: LD_INT 35
16012: PPUSH
16013: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
16017: LD_VAR 0 3
16021: PUSH
16022: LD_INT 1
16024: ARRAY
16025: PPUSH
16026: LD_VAR 0 3
16030: PUSH
16031: LD_INT 2
16033: ARRAY
16034: PUSH
16035: LD_STRING -1-land
16037: STR
16038: PPUSH
16039: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16043: LD_EXP 34
16047: PPUSH
16048: LD_STRING DI-2-land
16050: PPUSH
16051: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16055: LD_VAR 0 3
16059: PUSH
16060: LD_INT 1
16062: ARRAY
16063: PPUSH
16064: LD_VAR 0 3
16068: PUSH
16069: LD_INT 2
16071: ARRAY
16072: PUSH
16073: LD_STRING -2-land
16075: STR
16076: PPUSH
16077: CALL_OW 88
// if IsInUnit ( Heike ) then
16081: LD_EXP 24
16085: PPUSH
16086: CALL_OW 310
16090: IFFALSE 16101
// ComExitBuilding ( Heike ) ;
16092: LD_EXP 24
16096: PPUSH
16097: CALL_OW 122
// AddComMoveXY ( Heike , 34 , 21 ) ;
16101: LD_EXP 24
16105: PPUSH
16106: LD_INT 34
16108: PPUSH
16109: LD_INT 21
16111: PPUSH
16112: CALL_OW 171
// AddComTurnUnit ( Heike , speaker [ 1 ] ) ;
16116: LD_EXP 24
16120: PPUSH
16121: LD_VAR 0 3
16125: PUSH
16126: LD_INT 1
16128: ARRAY
16129: PPUSH
16130: CALL_OW 179
// ComMoveXY ( Ibrahim , 36 , 22 ) ;
16134: LD_EXP 34
16138: PPUSH
16139: LD_INT 36
16141: PPUSH
16142: LD_INT 22
16144: PPUSH
16145: CALL_OW 111
// ComMoveXY ( speaker [ 1 ] , 35 , 22 ) ;
16149: LD_VAR 0 3
16153: PUSH
16154: LD_INT 1
16156: ARRAY
16157: PPUSH
16158: LD_INT 35
16160: PPUSH
16161: LD_INT 22
16163: PPUSH
16164: CALL_OW 111
// AddComTurnUnit ( [ Ibrahim , speaker [ 1 ] ] , Heike ) ;
16168: LD_EXP 34
16172: PUSH
16173: LD_VAR 0 3
16177: PUSH
16178: LD_INT 1
16180: ARRAY
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: PPUSH
16186: LD_EXP 24
16190: PPUSH
16191: CALL_OW 179
// p := 0 ;
16195: LD_ADDR_VAR 0 6
16199: PUSH
16200: LD_INT 0
16202: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
16203: LD_INT 70
16205: PPUSH
16206: CALL_OW 67
// p := p + 1 ;
16210: LD_ADDR_VAR 0 6
16214: PUSH
16215: LD_VAR 0 6
16219: PUSH
16220: LD_INT 1
16222: PLUS
16223: ST_TO_ADDR
// CenterOnUnits ( speaker [ 1 ] ) ;
16224: LD_VAR 0 3
16228: PUSH
16229: LD_INT 1
16231: ARRAY
16232: PPUSH
16233: CALL_OW 85
// until GetDistUnits ( speaker [ 1 ] , depot ) < 12 or p > 5 ;
16237: LD_VAR 0 3
16241: PUSH
16242: LD_INT 1
16244: ARRAY
16245: PPUSH
16246: LD_VAR 0 5
16250: PPUSH
16251: CALL_OW 296
16255: PUSH
16256: LD_INT 12
16258: LESS
16259: PUSH
16260: LD_VAR 0 6
16264: PUSH
16265: LD_INT 5
16267: GREATER
16268: OR
16269: IFFALSE 16203
// CenterOnUnits ( depot ) ;
16271: LD_VAR 0 5
16275: PPUSH
16276: CALL_OW 85
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16280: LD_VAR 0 3
16284: PUSH
16285: LD_INT 1
16287: ARRAY
16288: PPUSH
16289: LD_VAR 0 3
16293: PUSH
16294: LD_INT 2
16296: ARRAY
16297: PUSH
16298: LD_STRING -3-land
16300: STR
16301: PPUSH
16302: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16306: LD_EXP 24
16310: PPUSH
16311: LD_STRING DH-1-land
16313: PPUSH
16314: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16318: LD_VAR 0 5
16322: PPUSH
16323: CALL_OW 313
16327: PUSH
16328: LD_INT 6
16330: EQUAL
16331: IFFALSE 16351
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16333: LD_VAR 0 5
16337: PPUSH
16338: CALL_OW 313
16342: PUSH
16343: LD_INT 1
16345: ARRAY
16346: PPUSH
16347: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16351: LD_EXP 34
16355: PPUSH
16356: LD_INT 2
16358: PPUSH
16359: CALL_OW 235
// ComEnterUnit ( Ibrahim , depot ) ;
16363: LD_EXP 34
16367: PPUSH
16368: LD_VAR 0 5
16372: PPUSH
16373: CALL_OW 120
// InGameOff ;
16377: CALL_OW 9
// ibrahimInDepot := true ;
16381: LD_ADDR_EXP 21
16385: PUSH
16386: LD_INT 1
16388: ST_TO_ADDR
// allowConvoys := true ;
16389: LD_ADDR_EXP 11
16393: PUSH
16394: LD_INT 1
16396: ST_TO_ADDR
// end ;
16397: PPOPN 6
16399: END
// export function IbrahimQuery ; begin
16400: LD_INT 0
16402: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16403: LD_STRING IbrahimQuery
16405: PPUSH
16406: CALL_OW 97
16410: PUSH
16411: LD_INT 1
16413: DOUBLE
16414: EQUAL
16415: IFTRUE 16419
16417: GO 16728
16419: POP
// begin allowConvoys := false ;
16420: LD_ADDR_EXP 11
16424: PUSH
16425: LD_INT 0
16427: ST_TO_ADDR
// ibrahimInDepot := false ;
16428: LD_ADDR_EXP 21
16432: PUSH
16433: LD_INT 0
16435: ST_TO_ADDR
// InGameOn ;
16436: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16440: LD_EXP 24
16444: PPUSH
16445: CALL_OW 87
// wait ( 0 0$1 ) ;
16449: LD_INT 35
16451: PPUSH
16452: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16456: LD_EXP 24
16460: PPUSH
16461: LD_STRING DH-1-interrogation
16463: PPUSH
16464: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16468: LD_EXP 34
16472: PPUSH
16473: LD_STRING DI-1-interrogation
16475: PPUSH
16476: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16480: LD_EXP 24
16484: PPUSH
16485: LD_STRING DH-2-interrogation
16487: PPUSH
16488: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16492: LD_EXP 34
16496: PPUSH
16497: LD_STRING DI-2-interrogation
16499: PPUSH
16500: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16504: LD_EXP 24
16508: PPUSH
16509: LD_STRING DH-3-interrogation
16511: PPUSH
16512: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16516: LD_EXP 34
16520: PPUSH
16521: LD_STRING DI-3-interrogation
16523: PPUSH
16524: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16528: LD_EXP 24
16532: PPUSH
16533: LD_STRING DH-4-interrogation
16535: PPUSH
16536: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16540: LD_EXP 34
16544: PPUSH
16545: LD_STRING DI-4-interrogation
16547: PPUSH
16548: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16552: LD_EXP 24
16556: PPUSH
16557: LD_STRING DH-5-interrogation
16559: PPUSH
16560: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16564: LD_EXP 34
16568: PPUSH
16569: LD_STRING DI-5-interrogation
16571: PPUSH
16572: CALL_OW 88
// wait ( 0 0$1 ) ;
16576: LD_INT 35
16578: PPUSH
16579: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16583: LD_STRING IbrahimDecisionQuery
16585: PPUSH
16586: CALL_OW 97
16590: PUSH
16591: LD_INT 1
16593: DOUBLE
16594: EQUAL
16595: IFTRUE 16599
16597: GO 16623
16599: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16600: LD_EXP 34
16604: PPUSH
16605: LD_STRING DI-1-kill
16607: PPUSH
16608: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16612: LD_EXP 34
16616: PPUSH
16617: CALL_OW 66
// end ; 2 :
16621: GO 16722
16623: LD_INT 2
16625: DOUBLE
16626: EQUAL
16627: IFTRUE 16631
16629: GO 16721
16631: POP
// begin SetSide ( Ibrahim , 6 ) ;
16632: LD_EXP 34
16636: PPUSH
16637: LD_INT 6
16639: PPUSH
16640: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16644: LD_EXP 34
16648: PPUSH
16649: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16653: LD_EXP 34
16657: PPUSH
16658: LD_INT 32
16660: PPUSH
16661: LD_INT 5
16663: PPUSH
16664: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16668: LD_EXP 24
16672: PPUSH
16673: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16677: LD_EXP 24
16681: PPUSH
16682: LD_INT 36
16684: PPUSH
16685: LD_INT 21
16687: PPUSH
16688: CALL_OW 171
// AddComWait ( Ibrahim , 1 1$20 ) ;
16692: LD_EXP 34
16696: PPUSH
16697: LD_INT 2800
16699: PPUSH
16700: CALL_OW 202
// AddComMoveXY ( Ibrahim , 38 , 28 ) ;
16704: LD_EXP 34
16708: PPUSH
16709: LD_INT 38
16711: PPUSH
16712: LD_INT 28
16714: PPUSH
16715: CALL_OW 171
// end ; end ;
16719: GO 16722
16721: POP
// InGameOff ;
16722: CALL_OW 9
// end ; 2 :
16726: GO 16742
16728: LD_INT 2
16730: DOUBLE
16731: EQUAL
16732: IFTRUE 16736
16734: GO 16741
16736: POP
// exit ; end ;
16737: GO 16765
16739: GO 16742
16741: POP
// allowConvoys := true ;
16742: LD_ADDR_EXP 11
16746: PUSH
16747: LD_INT 1
16749: ST_TO_ADDR
// wait ( 0 0$40 ) ;
16750: LD_INT 1400
16752: PPUSH
16753: CALL_OW 67
// ibrahimIsFree := true ;
16757: LD_ADDR_EXP 22
16761: PUSH
16762: LD_INT 1
16764: ST_TO_ADDR
// end ;
16765: LD_VAR 0 1
16769: RET
// every 0 0$10 trigger ibrahimIsFree and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b , p , depot ;
16770: LD_EXP 22
16774: PUSH
16775: LD_INT 22
16777: PUSH
16778: LD_INT 2
16780: PUSH
16781: EMPTY
16782: LIST
16783: LIST
16784: PUSH
16785: LD_INT 50
16787: PUSH
16788: EMPTY
16789: LIST
16790: PUSH
16791: LD_INT 30
16793: PUSH
16794: LD_INT 0
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PUSH
16801: EMPTY
16802: LIST
16803: LIST
16804: LIST
16805: PPUSH
16806: CALL_OW 69
16810: AND
16811: PUSH
16812: LD_EXP 34
16816: PPUSH
16817: LD_INT 7
16819: PPUSH
16820: CALL_OW 308
16824: AND
16825: PUSH
16826: LD_INT 6
16828: PPUSH
16829: LD_EXP 24
16833: PPUSH
16834: CALL_OW 292
16838: AND
16839: PUSH
16840: LD_INT 22
16842: PUSH
16843: LD_INT 4
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PPUSH
16850: CALL_OW 69
16854: NOT
16855: AND
16856: PUSH
16857: LD_INT 22
16859: PUSH
16860: LD_INT 1
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PUSH
16867: LD_INT 21
16869: PUSH
16870: LD_INT 1
16872: PUSH
16873: EMPTY
16874: LIST
16875: LIST
16876: PUSH
16877: EMPTY
16878: LIST
16879: LIST
16880: PPUSH
16881: CALL_OW 69
16885: NOT
16886: AND
16887: IFFALSE 17527
16889: GO 16891
16891: DISABLE
16892: LD_INT 0
16894: PPUSH
16895: PPUSH
16896: PPUSH
16897: PPUSH
// begin allowConvoys := false ;
16898: LD_ADDR_EXP 11
16902: PUSH
16903: LD_INT 0
16905: ST_TO_ADDR
// if not usDepot then
16906: LD_INT 11
16908: NOT
16909: IFFALSE 16956
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
16911: LD_ADDR_VAR 0 4
16915: PUSH
16916: LD_INT 22
16918: PUSH
16919: LD_INT 2
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: PUSH
16926: LD_INT 50
16928: PUSH
16929: EMPTY
16930: LIST
16931: PUSH
16932: LD_INT 30
16934: PUSH
16935: LD_INT 0
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: LIST
16946: PPUSH
16947: CALL_OW 69
16951: PUSH
16952: LD_INT 1
16954: ARRAY
16955: ST_TO_ADDR
// InGameOn ;
16956: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
16960: LD_EXP 34
16964: PPUSH
16965: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
16969: LD_EXP 24
16973: PPUSH
16974: LD_EXP 34
16978: PPUSH
16979: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
16983: LD_EXP 34
16987: PPUSH
16988: LD_EXP 24
16992: PPUSH
16993: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
16997: LD_EXP 34
17001: PPUSH
17002: LD_STRING DI-1-free
17004: PPUSH
17005: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
17009: LD_EXP 24
17013: PPUSH
17014: LD_STRING DH-1-free
17016: PPUSH
17017: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
17021: LD_EXP 34
17025: PPUSH
17026: LD_STRING DI-2-free
17028: PPUSH
17029: CALL_OW 88
// changeClass := 0 ;
17033: LD_ADDR_VAR 0 1
17037: PUSH
17038: LD_INT 0
17040: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
17041: LD_STRING IbrahimJoinQuery
17043: PPUSH
17044: CALL_OW 97
17048: PUSH
17049: LD_INT 1
17051: DOUBLE
17052: EQUAL
17053: IFTRUE 17057
17055: GO 17068
17057: POP
// begin changeClass := 1 ;
17058: LD_ADDR_VAR 0 1
17062: PUSH
17063: LD_INT 1
17065: ST_TO_ADDR
// end ; 2 :
17066: GO 17308
17068: LD_INT 2
17070: DOUBLE
17071: EQUAL
17072: IFTRUE 17076
17074: GO 17228
17076: POP
// begin Say ( Heike , DH-1-decline ) ;
17077: LD_EXP 24
17081: PPUSH
17082: LD_STRING DH-1-decline
17084: PPUSH
17085: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
17089: LD_EXP 34
17093: PPUSH
17094: LD_STRING DI-1-decline
17096: PPUSH
17097: CALL_OW 88
// InGameOff ;
17101: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
17105: LD_EXP 34
17109: PPUSH
17110: LD_INT 30
17112: PPUSH
17113: LD_INT 1
17115: PPUSH
17116: CALL_OW 111
// p := 0 ;
17120: LD_ADDR_VAR 0 3
17124: PUSH
17125: LD_INT 0
17127: ST_TO_ADDR
// repeat p := p + 1 ;
17128: LD_ADDR_VAR 0 3
17132: PUSH
17133: LD_VAR 0 3
17137: PUSH
17138: LD_INT 1
17140: PLUS
17141: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17142: LD_INT 35
17144: PPUSH
17145: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) or p > 10 ;
17149: LD_EXP 34
17153: PPUSH
17154: LD_INT 30
17156: PPUSH
17157: LD_INT 1
17159: PPUSH
17160: CALL_OW 307
17164: PUSH
17165: LD_INT 22
17167: PUSH
17168: LD_INT 2
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PUSH
17175: LD_INT 101
17177: PUSH
17178: LD_INT 6
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: PUSH
17185: EMPTY
17186: LIST
17187: LIST
17188: PPUSH
17189: CALL_OW 69
17193: NOT
17194: OR
17195: PUSH
17196: LD_VAR 0 3
17200: PUSH
17201: LD_INT 10
17203: GREATER
17204: OR
17205: IFFALSE 17128
// RemoveUnit ( Ibrahim ) ;
17207: LD_EXP 34
17211: PPUSH
17212: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17216: LD_INT 1
17218: PPUSH
17219: LD_STRING 03_IbrahimHasEscaped
17221: PPUSH
17222: CALL_OW 39
// end ; 3 :
17226: GO 17308
17228: LD_INT 3
17230: DOUBLE
17231: EQUAL
17232: IFTRUE 17236
17234: GO 17307
17236: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17237: LD_EXP 24
17241: PPUSH
17242: LD_STRING DH-1-radio-hq
17244: PPUSH
17245: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17249: LD_EXP 33
17253: PPUSH
17254: LD_STRING DO-1-radio-hq
17256: PPUSH
17257: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17261: LD_EXP 24
17265: PPUSH
17266: LD_STRING DH-2-radio-hq
17268: PPUSH
17269: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17273: LD_EXP 33
17277: PPUSH
17278: LD_STRING DO-2-radio-hq
17280: PPUSH
17281: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17285: LD_EXP 24
17289: PPUSH
17290: LD_STRING DH-3-radio-hq
17292: PPUSH
17293: CALL_OW 88
// changeClass := 1 ;
17297: LD_ADDR_VAR 0 1
17301: PUSH
17302: LD_INT 1
17304: ST_TO_ADDR
// end ; end ;
17305: GO 17308
17307: POP
// if changeClass then
17308: LD_VAR 0 1
17312: IFFALSE 17527
// begin Say ( Heike , DH-1-agree ) ;
17314: LD_EXP 24
17318: PPUSH
17319: LD_STRING DH-1-agree
17321: PPUSH
17322: CALL_OW 88
// if IsOk ( Givi ) then
17326: LD_EXP 25
17330: PPUSH
17331: CALL_OW 302
17335: IFFALSE 17373
// begin Say ( Givi , DG-1-agree ) ;
17337: LD_EXP 25
17341: PPUSH
17342: LD_STRING DG-1-agree
17344: PPUSH
17345: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17349: LD_EXP 24
17353: PPUSH
17354: LD_STRING DH-2-agree
17356: PPUSH
17357: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17361: LD_EXP 25
17365: PPUSH
17366: LD_STRING DG-2-agree
17368: PPUSH
17369: CALL_OW 88
// end ; if UnitsInside ( depot ) = 6 then
17373: LD_VAR 0 4
17377: PPUSH
17378: CALL_OW 313
17382: PUSH
17383: LD_INT 6
17385: EQUAL
17386: IFFALSE 17406
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
17388: LD_VAR 0 4
17392: PPUSH
17393: CALL_OW 313
17397: PUSH
17398: LD_INT 1
17400: ARRAY
17401: PPUSH
17402: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17406: LD_EXP 34
17410: PPUSH
17411: LD_INT 2
17413: PPUSH
17414: CALL_OW 235
// ComEnterUnit ( Ibrahim , depot ) ;
17418: LD_EXP 34
17422: PPUSH
17423: LD_VAR 0 4
17427: PPUSH
17428: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17432: LD_INT 35
17434: PPUSH
17435: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17439: LD_EXP 34
17443: PPUSH
17444: CALL_OW 310
17448: IFFALSE 17432
// b := IsInUnit ( Ibrahim ) ;
17450: LD_ADDR_VAR 0 2
17454: PUSH
17455: LD_EXP 34
17459: PPUSH
17460: CALL_OW 310
17464: ST_TO_ADDR
// RemoveUnit ( Ibrahim ) ;
17465: LD_EXP 34
17469: PPUSH
17470: CALL_OW 64
// uc_side := 2 ;
17474: LD_ADDR_OWVAR 20
17478: PUSH
17479: LD_INT 2
17481: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17482: LD_ADDR_EXP 34
17486: PUSH
17487: LD_STRING Ibrahim
17489: PPUSH
17490: LD_INT 0
17492: PPUSH
17493: LD_STRING 
17495: PPUSH
17496: CALL 268 0 3
17500: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , b ) ;
17501: LD_EXP 34
17505: PPUSH
17506: LD_VAR 0 2
17510: PPUSH
17511: CALL_OW 52
// InGameOff ;
17515: CALL_OW 9
// allowConvoys := true ;
17519: LD_ADDR_EXP 11
17523: PUSH
17524: LD_INT 1
17526: ST_TO_ADDR
// end ; end ;
17527: PPOPN 4
17529: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 do
17530: LD_EXP 10
17534: PUSH
17535: LD_EXP 17
17539: PUSH
17540: LD_INT 1
17542: LESS
17543: AND
17544: IFFALSE 17935
17546: GO 17548
17548: DISABLE
// begin DialogueOn ;
17549: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
17553: LD_EXP 24
17557: PPUSH
17558: LD_STRING DH-1-final
17560: PPUSH
17561: CALL_OW 88
// if tick <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
17565: LD_OWVAR 1
17569: PUSH
17570: LD_INT 126000
17572: PUSH
17573: LD_INT 115500
17575: PUSH
17576: LD_INT 105000
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: LIST
17583: PUSH
17584: LD_OWVAR 67
17588: ARRAY
17589: LESSEQUAL
17590: IFFALSE 17604
// AddMedal ( med1 , 1 ) else
17592: LD_STRING med1
17594: PPUSH
17595: LD_INT 1
17597: PPUSH
17598: CALL_OW 101
17602: GO 17615
// AddMedal ( med1 , - 1 ) ;
17604: LD_STRING med1
17606: PPUSH
17607: LD_INT 1
17609: NEG
17610: PPUSH
17611: CALL_OW 101
// if vehCounter >= 2 then
17615: LD_EXP 18
17619: PUSH
17620: LD_INT 2
17622: GREATEREQUAL
17623: IFFALSE 17637
// AddMedal ( med2 , 1 ) else
17625: LD_STRING med2
17627: PPUSH
17628: LD_INT 1
17630: PPUSH
17631: CALL_OW 101
17635: GO 17648
// AddMedal ( med2 , - 1 ) ;
17637: LD_STRING med2
17639: PPUSH
17640: LD_INT 1
17642: NEG
17643: PPUSH
17644: CALL_OW 101
// if deadCounter = 0 then
17648: LD_EXP 8
17652: PUSH
17653: LD_INT 0
17655: EQUAL
17656: IFFALSE 17670
// AddMedal ( med3 , 1 ) else
17658: LD_STRING med3
17660: PPUSH
17661: LD_INT 1
17663: PPUSH
17664: CALL_OW 101
17668: GO 17681
// AddMedal ( med3 , - 1 ) ;
17670: LD_STRING med3
17672: PPUSH
17673: LD_INT 1
17675: NEG
17676: PPUSH
17677: CALL_OW 101
// GiveMedals ( MAIN ) ;
17681: LD_STRING MAIN
17683: PPUSH
17684: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
17688: LD_INT 22
17690: PUSH
17691: LD_INT 2
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: PUSH
17698: LD_INT 23
17700: PUSH
17701: LD_INT 2
17703: PUSH
17704: EMPTY
17705: LIST
17706: LIST
17707: PUSH
17708: LD_INT 21
17710: PUSH
17711: LD_INT 1
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: PUSH
17718: EMPTY
17719: LIST
17720: LIST
17721: LIST
17722: PPUSH
17723: CALL_OW 69
17727: PPUSH
17728: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
17732: LD_EXP 24
17736: PPUSH
17737: LD_STRING 03_Heike
17739: PPUSH
17740: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
17744: LD_EXP 28
17748: PPUSH
17749: LD_STRING 03_Aviradze
17751: PPUSH
17752: CALL_OW 38
// if Givi then
17756: LD_EXP 25
17760: IFFALSE 17774
// SaveCharacters ( Givi , 03_Givi ) ;
17762: LD_EXP 25
17766: PPUSH
17767: LD_STRING 03_Givi
17769: PPUSH
17770: CALL_OW 38
// if Mike then
17774: LD_EXP 26
17778: IFFALSE 17792
// SaveCharacters ( Mike , 03_Mike ) ;
17780: LD_EXP 26
17784: PPUSH
17785: LD_STRING 03_Mike
17787: PPUSH
17788: CALL_OW 38
// if Kamil then
17792: LD_EXP 27
17796: IFFALSE 17810
// SaveCharacters ( Kamil , 03_Kamil ) ;
17798: LD_EXP 27
17802: PPUSH
17803: LD_STRING 03_Kamil
17805: PPUSH
17806: CALL_OW 38
// if Kaia then
17810: LD_EXP 29
17814: IFFALSE 17828
// SaveCharacters ( Kaia , 03_Kaia ) ;
17816: LD_EXP 29
17820: PPUSH
17821: LD_STRING 03_Kaia
17823: PPUSH
17824: CALL_OW 38
// if Sophia then
17828: LD_EXP 30
17832: IFFALSE 17846
// SaveCharacters ( Sophia , 03_Sophia ) ;
17834: LD_EXP 30
17838: PPUSH
17839: LD_STRING 03_Sophia
17841: PPUSH
17842: CALL_OW 38
// if Markov then
17846: LD_EXP 31
17850: IFFALSE 17864
// SaveCharacters ( Markov , 03_Markov ) ;
17852: LD_EXP 31
17856: PPUSH
17857: LD_STRING 03_Markov
17859: PPUSH
17860: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
17864: LD_EXP 34
17868: PUSH
17869: LD_EXP 34
17873: PPUSH
17874: CALL_OW 255
17878: PUSH
17879: LD_INT 2
17881: EQUAL
17882: AND
17883: IFFALSE 17897
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
17885: LD_EXP 34
17889: PPUSH
17890: LD_STRING 03_Ibrahim
17892: PPUSH
17893: CALL_OW 38
// if heikeSecondSquad then
17897: LD_EXP 38
17901: IFFALSE 17915
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
17903: LD_EXP 38
17907: PPUSH
17908: LD_STRING 03_others
17910: PPUSH
17911: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
17915: LD_EXP 8
17919: PPUSH
17920: LD_STRING 03_DeadCounter
17922: PPUSH
17923: CALL_OW 39
// YouWin ;
17927: CALL_OW 103
// DialogueOff ;
17931: CALL_OW 7
// end ; end_of_file
17935: END
// on UnitDestroyed ( un ) do begin if un = Heike then
17936: LD_VAR 0 1
17940: PUSH
17941: LD_EXP 24
17945: EQUAL
17946: IFFALSE 17955
// YouLost ( Heike ) ;
17948: LD_STRING Heike
17950: PPUSH
17951: CALL_OW 104
// if un = Aviradze then
17955: LD_VAR 0 1
17959: PUSH
17960: LD_EXP 28
17964: EQUAL
17965: IFFALSE 17974
// YouLost ( Aviradze ) ;
17967: LD_STRING Aviradze
17969: PPUSH
17970: CALL_OW 104
// if un = usDepot and not retreatAllowed then
17974: LD_VAR 0 1
17978: PUSH
17979: LD_INT 11
17981: EQUAL
17982: PUSH
17983: LD_EXP 10
17987: NOT
17988: AND
17989: IFFALSE 17998
// YouLost ( Depot ) ;
17991: LD_STRING Depot
17993: PPUSH
17994: CALL_OW 104
// if un = arDepot then
17998: LD_VAR 0 1
18002: PUSH
18003: LD_INT 5
18005: EQUAL
18006: IFFALSE 18015
// YouLost ( FarmerDepot ) ;
18008: LD_STRING FarmerDepot
18010: PPUSH
18011: CALL_OW 104
// if un = Farmer then
18015: LD_VAR 0 1
18019: PUSH
18020: LD_EXP 32
18024: EQUAL
18025: IFFALSE 18034
// YouLost ( Farmer ) ;
18027: LD_STRING Farmer
18029: PPUSH
18030: CALL_OW 104
// if un in usForces then
18034: LD_VAR 0 1
18038: PUSH
18039: LD_EXP 40
18043: IN
18044: IFFALSE 18062
// usForces := usForces diff un ;
18046: LD_ADDR_EXP 40
18050: PUSH
18051: LD_EXP 40
18055: PUSH
18056: LD_VAR 0 1
18060: DIFF
18061: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
18062: LD_VAR 0 1
18066: PUSH
18067: LD_INT 22
18069: PUSH
18070: LD_INT 2
18072: PUSH
18073: EMPTY
18074: LIST
18075: LIST
18076: PUSH
18077: LD_INT 23
18079: PUSH
18080: LD_INT 2
18082: PUSH
18083: EMPTY
18084: LIST
18085: LIST
18086: PUSH
18087: LD_INT 21
18089: PUSH
18090: LD_INT 1
18092: PUSH
18093: EMPTY
18094: LIST
18095: LIST
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: LIST
18101: PPUSH
18102: CALL_OW 69
18106: IN
18107: IFFALSE 18123
// deadCounter := deadCounter + 1 ;
18109: LD_ADDR_EXP 8
18113: PUSH
18114: LD_EXP 8
18118: PUSH
18119: LD_INT 1
18121: PLUS
18122: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
18123: LD_VAR 0 1
18127: PUSH
18128: LD_INT 22
18130: PUSH
18131: LD_INT 4
18133: PUSH
18134: EMPTY
18135: LIST
18136: LIST
18137: PUSH
18138: LD_INT 34
18140: PUSH
18141: LD_INT 12
18143: PUSH
18144: EMPTY
18145: LIST
18146: LIST
18147: PUSH
18148: EMPTY
18149: LIST
18150: LIST
18151: PPUSH
18152: CALL_OW 69
18156: IN
18157: PUSH
18158: LD_EXP 15
18162: NOT
18163: AND
18164: IFFALSE 18174
// firstConvoyDestroyed := true ;
18166: LD_ADDR_EXP 15
18170: PUSH
18171: LD_INT 1
18173: ST_TO_ADDR
// if un in usAttackers then
18174: LD_VAR 0 1
18178: PUSH
18179: LD_EXP 43
18183: IN
18184: IFFALSE 18202
// usAttackers := usAttackers diff un ;
18186: LD_ADDR_EXP 43
18190: PUSH
18191: LD_EXP 43
18195: PUSH
18196: LD_VAR 0 1
18200: DIFF
18201: ST_TO_ADDR
// end ;
18202: PPOPN 1
18204: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18205: LD_VAR 0 2
18209: PUSH
18210: LD_EXP 34
18214: EQUAL
18215: PUSH
18216: LD_EXP 21
18220: AND
18221: IFFALSE 18267
// begin Video ( true ) ;
18223: LD_INT 1
18225: PPUSH
18226: CALL 991 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
18230: LD_EXP 34
18234: PPUSH
18235: LD_INT 11
18237: PPUSH
18238: CALL_OW 120
// repeat wait ( 3 ) ;
18242: LD_INT 3
18244: PPUSH
18245: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18249: LD_EXP 34
18253: PPUSH
18254: CALL_OW 310
18258: IFFALSE 18242
// Video ( false ) ;
18260: LD_INT 0
18262: PPUSH
18263: CALL 991 0 1
// end ; end ;
18267: PPOPN 2
18269: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
18270: LD_VAR 0 2
18274: PUSH
18275: LD_EXP 24
18279: EQUAL
18280: PUSH
18281: LD_VAR 0 1
18285: PUSH
18286: LD_INT 11
18288: EQUAL
18289: AND
18290: PUSH
18291: LD_EXP 21
18295: AND
18296: IFFALSE 18302
// IbrahimQuery ;
18298: CALL 16400 0 0
// end ;
18302: PPOPN 2
18304: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin if oldId in usAttackers then
18305: LD_VAR 0 2
18309: PUSH
18310: LD_EXP 43
18314: IN
18315: IFFALSE 18333
// usAttackers := usAttackers diff oldId ;
18317: LD_ADDR_EXP 43
18321: PUSH
18322: LD_EXP 43
18326: PUSH
18327: LD_VAR 0 2
18331: DIFF
18332: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
18333: LD_VAR 0 3
18337: PUSH
18338: LD_INT 4
18340: EQUAL
18341: PUSH
18342: LD_EXP 15
18346: NOT
18347: AND
18348: IFFALSE 18358
// firstConvoyDestroyed := true ;
18350: LD_ADDR_EXP 15
18354: PUSH
18355: LD_INT 1
18357: ST_TO_ADDR
// if GetWeapon ( oldId ) = us_cargo_bay and GetCargo ( oldId , mat_cans ) = 0 then
18358: LD_VAR 0 2
18362: PPUSH
18363: CALL_OW 264
18367: PUSH
18368: LD_INT 12
18370: EQUAL
18371: PUSH
18372: LD_VAR 0 2
18376: PPUSH
18377: LD_INT 1
18379: PPUSH
18380: CALL_OW 289
18384: PUSH
18385: LD_INT 0
18387: EQUAL
18388: AND
18389: IFFALSE 18395
// EmptyCargoDialog ;
18391: CALL 15008 0 0
// end ;
18395: PPOPN 4
18397: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
18398: LD_VAR 0 1
18402: PUSH
18403: LD_INT 2
18405: EQUAL
18406: PUSH
18407: LD_VAR 0 2
18411: PUSH
18412: LD_INT 5
18414: EQUAL
18415: AND
18416: IFFALSE 18425
// YouLost ( Attack ) ;
18418: LD_STRING Attack
18420: PPUSH
18421: CALL_OW 104
// end ;
18425: PPOPN 2
18427: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 then
18428: LD_VAR 0 1
18432: PPUSH
18433: CALL_OW 255
18437: PUSH
18438: LD_INT 1
18440: EQUAL
18441: IFFALSE 18575
// begin if GetBType ( b ) = b_lab then
18443: LD_VAR 0 1
18447: PPUSH
18448: CALL_OW 266
18452: PUSH
18453: LD_INT 6
18455: EQUAL
18456: IFFALSE 18496
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
18458: LD_EXP 40
18462: PPUSH
18463: LD_INT 25
18465: PUSH
18466: LD_INT 4
18468: PUSH
18469: EMPTY
18470: LIST
18471: LIST
18472: PPUSH
18473: CALL_OW 72
18477: PPUSH
18478: LD_VAR 0 1
18482: PPUSH
18483: CALL_OW 120
// AmLabResearch ( b ) ;
18487: LD_VAR 0 1
18491: PPUSH
18492: CALL 5921 0 1
// end ; if GetBType ( b ) = b_armoury then
18496: LD_VAR 0 1
18500: PPUSH
18501: CALL_OW 266
18505: PUSH
18506: LD_INT 4
18508: EQUAL
18509: IFFALSE 18557
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
18511: LD_EXP 40
18515: PPUSH
18516: LD_INT 25
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: EMPTY
18523: LIST
18524: LIST
18525: PUSH
18526: LD_INT 3
18528: PUSH
18529: LD_INT 54
18531: PUSH
18532: EMPTY
18533: LIST
18534: PUSH
18535: EMPTY
18536: LIST
18537: LIST
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 72
18547: PPUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
18557: LD_ADDR_EXP 42
18561: PUSH
18562: LD_EXP 42
18566: PPUSH
18567: LD_INT 1
18569: PPUSH
18570: CALL_OW 3
18574: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
18575: LD_VAR 0 1
18579: PPUSH
18580: CALL_OW 255
18584: PUSH
18585: LD_INT 5
18587: EQUAL
18588: IFFALSE 18602
// SetBLevel ( b , 5 ) ;
18590: LD_VAR 0 1
18594: PPUSH
18595: LD_INT 5
18597: PPUSH
18598: CALL_OW 241
// end ;
18602: PPOPN 1
18604: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
18605: LD_VAR 0 1
18609: PPUSH
18610: CALL_OW 255
18614: PUSH
18615: LD_INT 2
18617: EQUAL
18618: IFFALSE 18634
// vehCounter := vehCounter + 1 ;
18620: LD_ADDR_EXP 18
18624: PUSH
18625: LD_EXP 18
18629: PUSH
18630: LD_INT 1
18632: PLUS
18633: ST_TO_ADDR
// end ;
18634: PPOPN 2
18636: END
// on SailEvent ( event ) do begin if event = eventAttack then
18637: LD_VAR 0 1
18641: PUSH
18642: LD_EXP 20
18646: EQUAL
18647: IFFALSE 18653
// AmericanAttack ;
18649: CALL 7361 0 0
// end ; end_of_file
18653: PPOPN 1
18655: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 4 4$00 , 3 3$00 , 2 2$30 ] [ Difficulty ] do
18656: LD_OWVAR 1
18660: PUSH
18661: LD_INT 8400
18663: PUSH
18664: LD_INT 6300
18666: PUSH
18667: LD_INT 5250
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: PUSH
18675: LD_OWVAR 67
18679: ARRAY
18680: LESSEQUAL
18681: IFFALSE 18708
18683: GO 18685
18685: DISABLE
// begin enable ;
18686: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18687: LD_INT 1
18689: PPUSH
18690: LD_INT 5
18692: PPUSH
18693: CALL_OW 12
18697: PPUSH
18698: LD_INT 9
18700: PPUSH
18701: LD_INT 1
18703: PPUSH
18704: CALL_OW 55
// end ;
18708: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 26 26$00 , 23 23$00 , 20 20$00 ] [ Difficulty ] do
18709: LD_EXP 6
18713: PUSH
18714: LD_OWVAR 1
18718: PUSH
18719: LD_INT 54600
18721: PUSH
18722: LD_INT 48300
18724: PUSH
18725: LD_INT 42000
18727: PUSH
18728: EMPTY
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: LD_OWVAR 67
18737: ARRAY
18738: LESSEQUAL
18739: AND
18740: IFFALSE 18767
18742: GO 18744
18744: DISABLE
// begin enable ;
18745: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18746: LD_INT 1
18748: PPUSH
18749: LD_INT 5
18751: PPUSH
18752: CALL_OW 12
18756: PPUSH
18757: LD_INT 9
18759: PPUSH
18760: LD_INT 1
18762: PPUSH
18763: CALL_OW 55
// end ; end_of_file
18767: END
// every 0 0$1 trigger not retreatAllowed and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
18768: LD_EXP 10
18772: NOT
18773: PUSH
18774: LD_EXP 4
18778: AND
18779: PUSH
18780: LD_EXP 12
18784: PUSH
18785: LD_EXP 13
18789: LESSEQUAL
18790: AND
18791: IFFALSE 18881
18793: GO 18795
18795: DISABLE
// begin enable ;
18796: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
18797: LD_ADDR_OWVAR 47
18801: PUSH
18802: LD_STRING #X103-1
18804: PUSH
18805: LD_EXP 12
18809: PUSH
18810: LD_EXP 13
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: LIST
18819: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
18820: LD_ADDR_EXP 12
18824: PUSH
18825: LD_INT 5
18827: PPUSH
18828: CALL_OW 274
18832: PPUSH
18833: LD_INT 1
18835: PPUSH
18836: CALL_OW 275
18840: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
18841: LD_INT 10
18843: PPUSH
18844: LD_INT 1
18846: PPUSH
18847: CALL_OW 287
18851: PUSH
18852: LD_INT 0
18854: EQUAL
18855: IFFALSE 18873
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
18857: LD_ADDR_EXP 14
18861: PUSH
18862: LD_EXP 14
18866: PUSH
18867: LD_INT 35
18869: MINUS
18870: ST_TO_ADDR
18871: GO 18881
// farmerCratesCounter := 30 30$00 ;
18873: LD_ADDR_EXP 14
18877: PUSH
18878: LD_INT 63000
18880: ST_TO_ADDR
// end ; end_of_file
18881: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18882: GO 18884
18884: DISABLE
// begin ru_radar := 98 ;
18885: LD_ADDR_EXP 44
18889: PUSH
18890: LD_INT 98
18892: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18893: LD_ADDR_EXP 45
18897: PUSH
18898: LD_INT 89
18900: ST_TO_ADDR
// us_hack := 99 ;
18901: LD_ADDR_EXP 46
18905: PUSH
18906: LD_INT 99
18908: ST_TO_ADDR
// us_artillery := 97 ;
18909: LD_ADDR_EXP 47
18913: PUSH
18914: LD_INT 97
18916: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18917: LD_ADDR_EXP 48
18921: PUSH
18922: LD_INT 91
18924: ST_TO_ADDR
// tech_Artillery := 80 ;
18925: LD_ADDR_EXP 49
18929: PUSH
18930: LD_INT 80
18932: ST_TO_ADDR
// tech_RadMat := 81 ;
18933: LD_ADDR_EXP 50
18937: PUSH
18938: LD_INT 81
18940: ST_TO_ADDR
// tech_BasicTools := 82 ;
18941: LD_ADDR_EXP 51
18945: PUSH
18946: LD_INT 82
18948: ST_TO_ADDR
// tech_Cargo := 83 ;
18949: LD_ADDR_EXP 52
18953: PUSH
18954: LD_INT 83
18956: ST_TO_ADDR
// tech_Track := 84 ;
18957: LD_ADDR_EXP 53
18961: PUSH
18962: LD_INT 84
18964: ST_TO_ADDR
// tech_Crane := 85 ;
18965: LD_ADDR_EXP 54
18969: PUSH
18970: LD_INT 85
18972: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18973: LD_ADDR_EXP 55
18977: PUSH
18978: LD_INT 86
18980: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18981: LD_ADDR_EXP 56
18985: PUSH
18986: LD_INT 87
18988: ST_TO_ADDR
// end ;
18989: END
