// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 17 0 0
// PrepareNature ;
   8: CALL 409 0 0
// PrepareArabian ;
  12: CALL 764 0 0
// end ;
  16: END
// export debug , prefix ; function Init ; begin
  17: LD_INT 0
  19: PPUSH
// debug := true ;
  20: LD_ADDR_EXP 1
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// prefix := 02_ ;
  28: LD_ADDR_EXP 2
  32: PUSH
  33: LD_STRING 02_
  35: ST_TO_ADDR
// end ; end_of_file
  36: LD_VAR 0 1
  40: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
  41: LD_INT 0
  43: PPUSH
  44: PPUSH
// if exist_mode then
  45: LD_VAR 0 2
  49: IFFALSE 74
// unit := CreateCharacter ( prefix & ident ) else
  51: LD_ADDR_VAR 0 5
  55: PUSH
  56: LD_VAR 0 3
  60: PUSH
  61: LD_VAR 0 1
  65: STR
  66: PPUSH
  67: CALL_OW 34
  71: ST_TO_ADDR
  72: GO 89
// unit := NewCharacter ( ident ) ;
  74: LD_ADDR_VAR 0 5
  78: PUSH
  79: LD_VAR 0 1
  83: PPUSH
  84: CALL_OW 25
  88: ST_TO_ADDR
// result := unit ;
  89: LD_ADDR_VAR 0 4
  93: PUSH
  94: LD_VAR 0 5
  98: ST_TO_ADDR
// end ;
  99: LD_VAR 0 4
 103: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 104: LD_INT 0
 106: PPUSH
// uc_side := side ;
 107: LD_ADDR_OWVAR 20
 111: PUSH
 112: LD_VAR 0 1
 116: ST_TO_ADDR
// uc_nation := nation ;
 117: LD_ADDR_OWVAR 21
 121: PUSH
 122: LD_VAR 0 2
 126: ST_TO_ADDR
// vc_chassis := chassis ;
 127: LD_ADDR_OWVAR 37
 131: PUSH
 132: LD_VAR 0 3
 136: ST_TO_ADDR
// vc_engine := engine ;
 137: LD_ADDR_OWVAR 39
 141: PUSH
 142: LD_VAR 0 4
 146: ST_TO_ADDR
// vc_control := control ;
 147: LD_ADDR_OWVAR 38
 151: PUSH
 152: LD_VAR 0 5
 156: ST_TO_ADDR
// vc_weapon := weapon ;
 157: LD_ADDR_OWVAR 40
 161: PUSH
 162: LD_VAR 0 6
 166: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 167: LD_ADDR_OWVAR 41
 171: PUSH
 172: LD_VAR 0 7
 176: ST_TO_ADDR
// result := CreateVehicle ;
 177: LD_ADDR_VAR 0 8
 181: PUSH
 182: CALL_OW 45
 186: ST_TO_ADDR
// end ;
 187: LD_VAR 0 8
 191: RET
// export function SayX ( units , ident ) ; var i ; begin
 192: LD_INT 0
 194: PPUSH
 195: PPUSH
// result := false ;
 196: LD_ADDR_VAR 0 3
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// if not units then
 204: LD_VAR 0 1
 208: NOT
 209: IFFALSE 213
// exit ;
 211: GO 267
// for i in units do
 213: LD_ADDR_VAR 0 4
 217: PUSH
 218: LD_VAR 0 1
 222: PUSH
 223: FOR_IN
 224: IFFALSE 265
// if IsOk ( i ) then
 226: LD_VAR 0 4
 230: PPUSH
 231: CALL_OW 302
 235: IFFALSE 263
// begin Say ( i , ident ) ;
 237: LD_VAR 0 4
 241: PPUSH
 242: LD_VAR 0 2
 246: PPUSH
 247: CALL_OW 88
// result := i ;
 251: LD_ADDR_VAR 0 3
 255: PUSH
 256: LD_VAR 0 4
 260: ST_TO_ADDR
// break ;
 261: GO 265
// end ;
 263: GO 223
 265: POP
 266: POP
// end ;
 267: LD_VAR 0 3
 271: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 272: LD_INT 0
 274: PPUSH
 275: PPUSH
// InitUc ;
 276: CALL_OW 18
// InitHc ;
 280: CALL_OW 19
// uc_side := 0 ;
 284: LD_ADDR_OWVAR 20
 288: PUSH
 289: LD_INT 0
 291: ST_TO_ADDR
// uc_nation := 0 ;
 292: LD_ADDR_OWVAR 21
 296: PUSH
 297: LD_INT 0
 299: ST_TO_ADDR
// for i = 1 to amount do
 300: LD_ADDR_VAR 0 4
 304: PUSH
 305: DOUBLE
 306: LD_INT 1
 308: DEC
 309: ST_TO_ADDR
 310: LD_VAR 0 2
 314: PUSH
 315: FOR_TO
 316: IFFALSE 398
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 318: LD_ADDR_OWVAR 29
 322: PUSH
 323: LD_INT 9
 325: PPUSH
 326: LD_INT 12
 328: PPUSH
 329: CALL_OW 12
 333: PUSH
 334: LD_INT 9
 336: PPUSH
 337: LD_INT 12
 339: PPUSH
 340: CALL_OW 12
 344: PUSH
 345: EMPTY
 346: LIST
 347: LIST
 348: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 349: LD_ADDR_OWVAR 35
 353: PUSH
 354: LD_INT 1
 356: NEG
 357: PPUSH
 358: LD_INT 1
 360: PPUSH
 361: CALL_OW 12
 365: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 366: LD_INT 0
 368: PPUSH
 369: LD_INT 12
 371: PPUSH
 372: LD_INT 1
 374: PPUSH
 375: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 379: CALL_OW 44
 383: PPUSH
 384: LD_VAR 0 1
 388: PPUSH
 389: LD_INT 0
 391: PPUSH
 392: CALL_OW 49
// end ;
 396: GO 315
 398: POP
 399: POP
// InitHc ;
 400: CALL_OW 19
// end ;
 404: LD_VAR 0 3
 408: RET
// export function PrepareNature ; var i ; begin
 409: LD_INT 0
 411: PPUSH
 412: PPUSH
// SpawnApeman ( forest , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
 413: LD_INT 2
 415: PPUSH
 416: LD_INT 4
 418: PUSH
 419: LD_INT 4
 421: PUSH
 422: LD_INT 3
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: PUSH
 430: LD_OWVAR 67
 434: ARRAY
 435: PPUSH
 436: CALL 272 0 2
// for i := 1 to 3 do
 440: LD_ADDR_VAR 0 2
 444: PUSH
 445: DOUBLE
 446: LD_INT 1
 448: DEC
 449: ST_TO_ADDR
 450: LD_INT 3
 452: PUSH
 453: FOR_TO
 454: IFFALSE 489
// begin hc_class := 21 ;
 456: LD_ADDR_OWVAR 28
 460: PUSH
 461: LD_INT 21
 463: ST_TO_ADDR
// hc_gallery :=  ;
 464: LD_ADDR_OWVAR 33
 468: PUSH
 469: LD_STRING 
 471: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 472: CALL_OW 44
 476: PPUSH
 477: LD_INT 2
 479: PPUSH
 480: LD_INT 0
 482: PPUSH
 483: CALL_OW 49
// end ;
 487: GO 453
 489: POP
 490: POP
// for i := 1 to 2 do
 491: LD_ADDR_VAR 0 2
 495: PUSH
 496: DOUBLE
 497: LD_INT 1
 499: DEC
 500: ST_TO_ADDR
 501: LD_INT 2
 503: PUSH
 504: FOR_TO
 505: IFFALSE 540
// begin hc_class := 18 ;
 507: LD_ADDR_OWVAR 28
 511: PUSH
 512: LD_INT 18
 514: ST_TO_ADDR
// hc_gallery :=  ;
 515: LD_ADDR_OWVAR 33
 519: PUSH
 520: LD_STRING 
 522: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 523: CALL_OW 44
 527: PPUSH
 528: LD_INT 2
 530: PPUSH
 531: LD_INT 0
 533: PPUSH
 534: CALL_OW 49
// end ;
 538: GO 504
 540: POP
 541: POP
// for i := 1 to 2 do
 542: LD_ADDR_VAR 0 2
 546: PUSH
 547: DOUBLE
 548: LD_INT 1
 550: DEC
 551: ST_TO_ADDR
 552: LD_INT 2
 554: PUSH
 555: FOR_TO
 556: IFFALSE 591
// begin hc_class := 13 ;
 558: LD_ADDR_OWVAR 28
 562: PUSH
 563: LD_INT 13
 565: ST_TO_ADDR
// hc_gallery :=  ;
 566: LD_ADDR_OWVAR 33
 570: PUSH
 571: LD_STRING 
 573: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 574: CALL_OW 44
 578: PPUSH
 579: LD_INT 2
 581: PPUSH
 582: LD_INT 0
 584: PPUSH
 585: CALL_OW 49
// end ;
 589: GO 555
 591: POP
 592: POP
// end ;
 593: LD_VAR 0 1
 597: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 598: LD_INT 0
 600: PPUSH
 601: PPUSH
 602: PPUSH
// if not observer or not unit then
 603: LD_VAR 0 1
 607: NOT
 608: PUSH
 609: LD_VAR 0 2
 613: NOT
 614: OR
 615: IFFALSE 619
// exit ;
 617: GO 667
// if not See ( GetSide ( observer ) , unit ) then
 619: LD_VAR 0 1
 623: PPUSH
 624: CALL_OW 255
 628: PPUSH
 629: LD_VAR 0 2
 633: PPUSH
 634: CALL_OW 292
 638: NOT
 639: IFFALSE 643
// exit ;
 641: GO 667
// result := GetDistUnits ( observer , unit ) < 12 ;
 643: LD_ADDR_VAR 0 3
 647: PUSH
 648: LD_VAR 0 1
 652: PPUSH
 653: LD_VAR 0 2
 657: PPUSH
 658: CALL_OW 296
 662: PUSH
 663: LD_INT 12
 665: LESS
 666: ST_TO_ADDR
// end ;
 667: LD_VAR 0 3
 671: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 672: LD_INT 0
 674: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 675: LD_VAR 0 2
 679: PUSH
 680: LD_INT 1
 682: ARRAY
 683: PPUSH
 684: LD_VAR 0 2
 688: PUSH
 689: LD_INT 2
 691: ARRAY
 692: PPUSH
 693: CALL_OW 488
 697: PUSH
 698: LD_VAR 0 2
 702: PUSH
 703: LD_INT 1
 705: ARRAY
 706: PPUSH
 707: LD_VAR 0 2
 711: PUSH
 712: LD_INT 2
 714: ARRAY
 715: PPUSH
 716: CALL_OW 428
 720: PUSH
 721: LD_INT 0
 723: EQUAL
 724: AND
 725: IFFALSE 759
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 727: LD_VAR 0 1
 731: PPUSH
 732: LD_VAR 0 2
 736: PUSH
 737: LD_INT 1
 739: ARRAY
 740: PPUSH
 741: LD_VAR 0 2
 745: PUSH
 746: LD_INT 2
 748: ARRAY
 749: PPUSH
 750: LD_VAR 0 3
 754: PPUSH
 755: CALL_OW 48
// end ; end_of_file
 759: LD_VAR 0 4
 763: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar ; export function PrepareArabian ; var i , un , tmp ; begin
 764: LD_INT 0
 766: PPUSH
 767: PPUSH
 768: PPUSH
 769: PPUSH
// uc_side := 5 ;
 770: LD_ADDR_OWVAR 20
 774: PUSH
 775: LD_INT 5
 777: ST_TO_ADDR
// uc_nation := 2 ;
 778: LD_ADDR_OWVAR 21
 782: PUSH
 783: LD_INT 2
 785: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
 786: LD_ADDR_EXP 11
 790: PUSH
 791: LD_STRING Farmer
 793: PPUSH
 794: LD_INT 0
 796: PPUSH
 797: LD_STRING 
 799: PPUSH
 800: CALL 41 0 3
 804: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
 805: LD_ADDR_EXP 12
 809: PUSH
 810: LD_STRING Omar
 812: PPUSH
 813: LD_INT 0
 815: PPUSH
 816: LD_STRING 
 818: PPUSH
 819: CALL 41 0 3
 823: ST_TO_ADDR
// for i := 1 to 2 do
 824: LD_ADDR_VAR 0 2
 828: PUSH
 829: DOUBLE
 830: LD_INT 1
 832: DEC
 833: ST_TO_ADDR
 834: LD_INT 2
 836: PUSH
 837: FOR_TO
 838: IFFALSE 922
// begin PrepareHuman ( false , 1 , 3 ) ;
 840: LD_INT 0
 842: PPUSH
 843: LD_INT 1
 845: PPUSH
 846: LD_INT 3
 848: PPUSH
 849: CALL_OW 380
// un := CreateHuman ;
 853: LD_ADDR_VAR 0 3
 857: PUSH
 858: CALL_OW 44
 862: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] ] [ i ] , false ) ;
 863: LD_VAR 0 3
 867: PPUSH
 868: LD_INT 87
 870: PUSH
 871: LD_INT 30
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: PUSH
 878: LD_INT 91
 880: PUSH
 881: LD_INT 32
 883: PUSH
 884: EMPTY
 885: LIST
 886: LIST
 887: PUSH
 888: EMPTY
 889: LIST
 890: LIST
 891: PUSH
 892: LD_VAR 0 2
 896: ARRAY
 897: PPUSH
 898: LD_INT 0
 900: PPUSH
 901: CALL 672 0 3
// ComTurnXY ( un , 93 , 21 ) ;
 905: LD_VAR 0 3
 909: PPUSH
 910: LD_INT 93
 912: PPUSH
 913: LD_INT 21
 915: PPUSH
 916: CALL_OW 118
// end ;
 920: GO 837
 922: POP
 923: POP
// uc_side := 2 ;
 924: LD_ADDR_OWVAR 20
 928: PUSH
 929: LD_INT 2
 931: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
 932: LD_ADDR_EXP 3
 936: PUSH
 937: LD_STRING Heike
 939: PPUSH
 940: LD_EXP 1
 944: NOT
 945: PPUSH
 946: LD_EXP 2
 950: PPUSH
 951: CALL 41 0 3
 955: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
 956: LD_ADDR_EXP 7
 960: PUSH
 961: LD_STRING Aviradze
 963: PPUSH
 964: LD_EXP 1
 968: NOT
 969: PPUSH
 970: LD_EXP 2
 974: PPUSH
 975: CALL 41 0 3
 979: ST_TO_ADDR
// tmp := [ ] ;
 980: LD_ADDR_VAR 0 4
 984: PUSH
 985: EMPTY
 986: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
 987: LD_ADDR_EXP 4
 991: PUSH
 992: LD_STRING Givi
 994: PPUSH
 995: LD_EXP 1
 999: NOT
1000: PPUSH
1001: LD_EXP 2
1005: PPUSH
1006: CALL 41 0 3
1010: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
1011: LD_ADDR_EXP 5
1015: PUSH
1016: LD_STRING Mike
1018: PPUSH
1019: LD_EXP 1
1023: NOT
1024: PPUSH
1025: LD_EXP 2
1029: PPUSH
1030: CALL 41 0 3
1034: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
1035: LD_ADDR_EXP 6
1039: PUSH
1040: LD_STRING Kamil
1042: PPUSH
1043: LD_EXP 1
1047: NOT
1048: PPUSH
1049: LD_EXP 2
1053: PPUSH
1054: CALL 41 0 3
1058: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
1059: LD_ADDR_EXP 8
1063: PUSH
1064: LD_STRING Kaia
1066: PPUSH
1067: LD_EXP 1
1071: NOT
1072: PPUSH
1073: LD_EXP 2
1077: PPUSH
1078: CALL 41 0 3
1082: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
1083: LD_ADDR_EXP 9
1087: PUSH
1088: LD_STRING Sophia
1090: PPUSH
1091: LD_EXP 1
1095: NOT
1096: PPUSH
1097: LD_EXP 2
1101: PPUSH
1102: CALL 41 0 3
1106: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
1107: LD_ADDR_EXP 10
1111: PUSH
1112: LD_STRING Markov
1114: PPUSH
1115: LD_EXP 1
1119: NOT
1120: PPUSH
1121: LD_EXP 2
1125: PPUSH
1126: CALL 41 0 3
1130: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov ] ^ CreateCharacterSet ( 02_others ) diff 0 ;
1131: LD_ADDR_VAR 0 4
1135: PUSH
1136: LD_EXP 5
1140: PUSH
1141: LD_EXP 6
1145: PUSH
1146: LD_EXP 8
1150: PUSH
1151: LD_EXP 9
1155: PUSH
1156: LD_EXP 10
1160: PUSH
1161: EMPTY
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_STRING 02_others
1170: PPUSH
1171: CALL_OW 31
1175: ADD
1176: PUSH
1177: LD_INT 0
1179: DIFF
1180: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
1181: LD_EXP 3
1185: PPUSH
1186: LD_INT 92
1188: PPUSH
1189: LD_INT 17
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
1199: LD_EXP 11
1203: PPUSH
1204: LD_INT 95
1206: PPUSH
1207: LD_INT 19
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
1217: LD_EXP 12
1221: PPUSH
1222: LD_INT 89
1224: PPUSH
1225: LD_INT 25
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
1235: LD_EXP 7
1239: PPUSH
1240: LD_INT 92
1242: PPUSH
1243: LD_INT 27
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
1253: LD_EXP 12
1257: PPUSH
1258: LD_EXP 7
1262: PPUSH
1263: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
1267: LD_EXP 7
1271: PPUSH
1272: LD_EXP 12
1276: PPUSH
1277: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
1281: LD_EXP 3
1285: PUSH
1286: LD_EXP 11
1290: PUSH
1291: EMPTY
1292: LIST
1293: LIST
1294: PPUSH
1295: LD_EXP 12
1299: PPUSH
1300: CALL_OW 119
// if tmp then
1304: LD_VAR 0 4
1308: IFFALSE 1362
// for i in tmp do
1310: LD_ADDR_VAR 0 2
1314: PUSH
1315: LD_VAR 0 4
1319: PUSH
1320: FOR_IN
1321: IFFALSE 1360
// begin PlaceUnitXYR ( i , 95 , 11 , 4 , false ) ;
1323: LD_VAR 0 2
1327: PPUSH
1328: LD_INT 95
1330: PPUSH
1331: LD_INT 11
1333: PPUSH
1334: LD_INT 4
1336: PPUSH
1337: LD_INT 0
1339: PPUSH
1340: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
1344: LD_VAR 0 2
1348: PPUSH
1349: LD_EXP 3
1353: PPUSH
1354: CALL_OW 119
// end ;
1358: GO 1320
1360: POP
1361: POP
// end ; end_of_file end_of_file end_of_file end_of_file
1362: LD_VAR 0 1
1366: RET
