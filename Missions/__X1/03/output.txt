// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 38 0 0
// PrepareNature ;
   8: CALL 665 0 0
// PrepareArabian ;
  12: CALL 1980 0 0
// PrepareAmerican ;
  16: CALL 4932 0 0
// if debug then
  20: LD_EXP 1
  24: IFFALSE 33
// FogOff ( 2 ) ;
  26: LD_INT 2
  28: PPUSH
  29: CALL_OW 344
// Action ;
  33: CALL 9610 0 0
// end ;
  37: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , capturedCargoCounter , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , farmerHumanLoseCounter , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := false ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 0
  48: ST_TO_ADDR
// prefix := 02_ ;
  49: LD_ADDR_EXP 2
  53: PUSH
  54: LD_STRING 02_
  56: ST_TO_ADDR
// eventAttack := 1 ;
  57: LD_ADDR_EXP 22
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// deadCounter := 0 ;
  65: LD_ADDR_EXP 8
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// gameStarted := false ;
  73: LD_ADDR_EXP 3
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// farmerBaseReady := false ;
  81: LD_ADDR_EXP 4
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// americanBaseSpoted := false ;
  89: LD_ADDR_EXP 5
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// americanBaseCaptured := false ;
  97: LD_ADDR_EXP 6
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// americanHasEscaped := false ;
 105: LD_ADDR_EXP 7
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// workshopBuilded := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// retreatAllowed := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// allowConvoys := false ;
 129: LD_ADDR_EXP 11
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// farmerCrates := 0 ;
 137: LD_ADDR_EXP 13
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 145: LD_ADDR_EXP 14
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 153: LD_ADDR_EXP 15
 157: PUSH
 158: LD_INT 63000
 160: PUSH
 161: LD_INT 52500
 163: PUSH
 164: LD_INT 46200
 166: PUSH
 167: EMPTY
 168: LIST
 169: LIST
 170: LIST
 171: PUSH
 172: LD_OWVAR 67
 176: ARRAY
 177: ST_TO_ADDR
// farmerHumanLoseCounter := 0 ;
 178: LD_ADDR_EXP 18
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 186: LD_ADDR_EXP 16
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// attackWave := 1 ;
 194: LD_ADDR_EXP 17
 198: PUSH
 199: LD_INT 1
 201: ST_TO_ADDR
// omarCargoCounter := [ 6 , 8 , 10 ] [ Difficulty ] ;
 202: LD_ADDR_EXP 19
 206: PUSH
 207: LD_INT 6
 209: PUSH
 210: LD_INT 8
 212: PUSH
 213: LD_INT 10
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: PUSH
 221: LD_OWVAR 67
 225: ARRAY
 226: ST_TO_ADDR
// vehCounter := 0 ;
 227: LD_ADDR_EXP 20
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// convoyCounter := 0 ;
 235: LD_ADDR_EXP 21
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// ibrahimInDepot := false ;
 243: LD_ADDR_EXP 23
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// ibrahimIsFree := false ;
 251: LD_ADDR_EXP 24
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// maxConvoys := [ 16 , 15 , 14 ] [ Difficulty ] ;
 259: LD_ADDR_EXP 25
 263: PUSH
 264: LD_INT 16
 266: PUSH
 267: LD_INT 15
 269: PUSH
 270: LD_INT 14
 272: PUSH
 273: EMPTY
 274: LIST
 275: LIST
 276: LIST
 277: PUSH
 278: LD_OWVAR 67
 282: ARRAY
 283: ST_TO_ADDR
// capturedCargoCounter := 0 ;
 284: LD_ADDR_EXP 12
 288: PUSH
 289: LD_INT 0
 291: ST_TO_ADDR
// end ; end_of_file
 292: LD_VAR 0 1
 296: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 297: LD_INT 0
 299: PPUSH
 300: PPUSH
// if exist_mode then
 301: LD_VAR 0 2
 305: IFFALSE 330
// unit := CreateCharacter ( prefix & ident ) else
 307: LD_ADDR_VAR 0 5
 311: PUSH
 312: LD_VAR 0 3
 316: PUSH
 317: LD_VAR 0 1
 321: STR
 322: PPUSH
 323: CALL_OW 34
 327: ST_TO_ADDR
 328: GO 345
// unit := NewCharacter ( ident ) ;
 330: LD_ADDR_VAR 0 5
 334: PUSH
 335: LD_VAR 0 1
 339: PPUSH
 340: CALL_OW 25
 344: ST_TO_ADDR
// result := unit ;
 345: LD_ADDR_VAR 0 4
 349: PUSH
 350: LD_VAR 0 5
 354: ST_TO_ADDR
// end ;
 355: LD_VAR 0 4
 359: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 360: LD_INT 0
 362: PPUSH
// uc_side := side ;
 363: LD_ADDR_OWVAR 20
 367: PUSH
 368: LD_VAR 0 1
 372: ST_TO_ADDR
// uc_nation := nation ;
 373: LD_ADDR_OWVAR 21
 377: PUSH
 378: LD_VAR 0 2
 382: ST_TO_ADDR
// vc_chassis := chassis ;
 383: LD_ADDR_OWVAR 37
 387: PUSH
 388: LD_VAR 0 3
 392: ST_TO_ADDR
// vc_engine := engine ;
 393: LD_ADDR_OWVAR 39
 397: PUSH
 398: LD_VAR 0 4
 402: ST_TO_ADDR
// vc_control := control ;
 403: LD_ADDR_OWVAR 38
 407: PUSH
 408: LD_VAR 0 5
 412: ST_TO_ADDR
// vc_weapon := weapon ;
 413: LD_ADDR_OWVAR 40
 417: PUSH
 418: LD_VAR 0 6
 422: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 423: LD_ADDR_OWVAR 41
 427: PUSH
 428: LD_VAR 0 7
 432: ST_TO_ADDR
// result := CreateVehicle ;
 433: LD_ADDR_VAR 0 8
 437: PUSH
 438: CALL_OW 45
 442: ST_TO_ADDR
// end ;
 443: LD_VAR 0 8
 447: RET
// export function SayX ( units , ident ) ; var i ; begin
 448: LD_INT 0
 450: PPUSH
 451: PPUSH
// result := false ;
 452: LD_ADDR_VAR 0 3
 456: PUSH
 457: LD_INT 0
 459: ST_TO_ADDR
// if not units then
 460: LD_VAR 0 1
 464: NOT
 465: IFFALSE 469
// exit ;
 467: GO 523
// for i in units do
 469: LD_ADDR_VAR 0 4
 473: PUSH
 474: LD_VAR 0 1
 478: PUSH
 479: FOR_IN
 480: IFFALSE 521
// if IsOk ( i ) then
 482: LD_VAR 0 4
 486: PPUSH
 487: CALL_OW 302
 491: IFFALSE 519
// begin Say ( i , ident ) ;
 493: LD_VAR 0 4
 497: PPUSH
 498: LD_VAR 0 2
 502: PPUSH
 503: CALL_OW 88
// result := i ;
 507: LD_ADDR_VAR 0 3
 511: PUSH
 512: LD_VAR 0 4
 516: ST_TO_ADDR
// break ;
 517: GO 521
// end ;
 519: GO 479
 521: POP
 522: POP
// end ;
 523: LD_VAR 0 3
 527: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 528: LD_INT 0
 530: PPUSH
 531: PPUSH
// InitUc ;
 532: CALL_OW 18
// InitHc ;
 536: CALL_OW 19
// uc_side := 0 ;
 540: LD_ADDR_OWVAR 20
 544: PUSH
 545: LD_INT 0
 547: ST_TO_ADDR
// uc_nation := 0 ;
 548: LD_ADDR_OWVAR 21
 552: PUSH
 553: LD_INT 0
 555: ST_TO_ADDR
// for i = 1 to amount do
 556: LD_ADDR_VAR 0 4
 560: PUSH
 561: DOUBLE
 562: LD_INT 1
 564: DEC
 565: ST_TO_ADDR
 566: LD_VAR 0 2
 570: PUSH
 571: FOR_TO
 572: IFFALSE 654
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 574: LD_ADDR_OWVAR 29
 578: PUSH
 579: LD_INT 9
 581: PPUSH
 582: LD_INT 12
 584: PPUSH
 585: CALL_OW 12
 589: PUSH
 590: LD_INT 9
 592: PPUSH
 593: LD_INT 12
 595: PPUSH
 596: CALL_OW 12
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 605: LD_ADDR_OWVAR 35
 609: PUSH
 610: LD_INT 1
 612: NEG
 613: PPUSH
 614: LD_INT 1
 616: PPUSH
 617: CALL_OW 12
 621: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 622: LD_INT 0
 624: PPUSH
 625: LD_INT 12
 627: PPUSH
 628: LD_INT 1
 630: PPUSH
 631: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 635: CALL_OW 44
 639: PPUSH
 640: LD_VAR 0 1
 644: PPUSH
 645: LD_INT 0
 647: PPUSH
 648: CALL_OW 49
// end ;
 652: GO 571
 654: POP
 655: POP
// InitHc ;
 656: CALL_OW 19
// end ;
 660: LD_VAR 0 3
 664: RET
// export function PrepareNature ; var i ; begin
 665: LD_INT 0
 667: PPUSH
 668: PPUSH
// SpawnApeman ( forest , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PUSH
 675: LD_INT 4
 677: PUSH
 678: LD_INT 4
 680: PUSH
 681: EMPTY
 682: LIST
 683: LIST
 684: LIST
 685: PUSH
 686: LD_OWVAR 67
 690: ARRAY
 691: PPUSH
 692: CALL 528 0 2
// for i := 1 to 2 do
 696: LD_ADDR_VAR 0 2
 700: PUSH
 701: DOUBLE
 702: LD_INT 1
 704: DEC
 705: ST_TO_ADDR
 706: LD_INT 2
 708: PUSH
 709: FOR_TO
 710: IFFALSE 745
// begin hc_class := 21 ;
 712: LD_ADDR_OWVAR 28
 716: PUSH
 717: LD_INT 21
 719: ST_TO_ADDR
// hc_gallery :=  ;
 720: LD_ADDR_OWVAR 33
 724: PUSH
 725: LD_STRING 
 727: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 728: CALL_OW 44
 732: PPUSH
 733: LD_INT 2
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 49
// end ;
 743: GO 709
 745: POP
 746: POP
// for i := 1 to 2 do
 747: LD_ADDR_VAR 0 2
 751: PUSH
 752: DOUBLE
 753: LD_INT 1
 755: DEC
 756: ST_TO_ADDR
 757: LD_INT 2
 759: PUSH
 760: FOR_TO
 761: IFFALSE 796
// begin hc_class := 18 ;
 763: LD_ADDR_OWVAR 28
 767: PUSH
 768: LD_INT 18
 770: ST_TO_ADDR
// hc_gallery :=  ;
 771: LD_ADDR_OWVAR 33
 775: PUSH
 776: LD_STRING 
 778: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 779: CALL_OW 44
 783: PPUSH
 784: LD_INT 2
 786: PPUSH
 787: LD_INT 0
 789: PPUSH
 790: CALL_OW 49
// end ;
 794: GO 760
 796: POP
 797: POP
// for i := 1 to 2 do
 798: LD_ADDR_VAR 0 2
 802: PUSH
 803: DOUBLE
 804: LD_INT 1
 806: DEC
 807: ST_TO_ADDR
 808: LD_INT 2
 810: PUSH
 811: FOR_TO
 812: IFFALSE 847
// begin hc_class := 13 ;
 814: LD_ADDR_OWVAR 28
 818: PUSH
 819: LD_INT 13
 821: ST_TO_ADDR
// hc_gallery :=  ;
 822: LD_ADDR_OWVAR 33
 826: PUSH
 827: LD_STRING 
 829: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 830: CALL_OW 44
 834: PPUSH
 835: LD_INT 2
 837: PPUSH
 838: LD_INT 0
 840: PPUSH
 841: CALL_OW 49
// end ;
 845: GO 811
 847: POP
 848: POP
// end ;
 849: LD_VAR 0 1
 853: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 854: LD_INT 0
 856: PPUSH
 857: PPUSH
 858: PPUSH
// if not observer or not unit then
 859: LD_VAR 0 1
 863: NOT
 864: PUSH
 865: LD_VAR 0 2
 869: NOT
 870: OR
 871: IFFALSE 875
// exit ;
 873: GO 923
// if not See ( GetSide ( observer ) , unit ) then
 875: LD_VAR 0 1
 879: PPUSH
 880: CALL_OW 255
 884: PPUSH
 885: LD_VAR 0 2
 889: PPUSH
 890: CALL_OW 292
 894: NOT
 895: IFFALSE 899
// exit ;
 897: GO 923
// result := GetDistUnits ( observer , unit ) < 12 ;
 899: LD_ADDR_VAR 0 3
 903: PUSH
 904: LD_VAR 0 1
 908: PPUSH
 909: LD_VAR 0 2
 913: PPUSH
 914: CALL_OW 296
 918: PUSH
 919: LD_INT 12
 921: LESS
 922: ST_TO_ADDR
// end ;
 923: LD_VAR 0 3
 927: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 928: LD_INT 0
 930: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 931: LD_VAR 0 2
 935: PUSH
 936: LD_INT 1
 938: ARRAY
 939: PPUSH
 940: LD_VAR 0 2
 944: PUSH
 945: LD_INT 2
 947: ARRAY
 948: PPUSH
 949: CALL_OW 488
 953: PUSH
 954: LD_VAR 0 2
 958: PUSH
 959: LD_INT 1
 961: ARRAY
 962: PPUSH
 963: LD_VAR 0 2
 967: PUSH
 968: LD_INT 2
 970: ARRAY
 971: PPUSH
 972: CALL_OW 428
 976: PUSH
 977: LD_INT 0
 979: EQUAL
 980: AND
 981: IFFALSE 1015
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 983: LD_VAR 0 1
 987: PPUSH
 988: LD_VAR 0 2
 992: PUSH
 993: LD_INT 1
 995: ARRAY
 996: PPUSH
 997: LD_VAR 0 2
1001: PUSH
1002: LD_INT 2
1004: ARRAY
1005: PPUSH
1006: LD_VAR 0 3
1010: PPUSH
1011: CALL_OW 48
// end ;
1015: LD_VAR 0 4
1019: RET
// export function Video ( mode ) ; begin
1020: LD_INT 0
1022: PPUSH
// ingame_video = mode ;
1023: LD_ADDR_OWVAR 52
1027: PUSH
1028: LD_VAR 0 1
1032: ST_TO_ADDR
// interface_hidden = mode ;
1033: LD_ADDR_OWVAR 54
1037: PUSH
1038: LD_VAR 0 1
1042: ST_TO_ADDR
// end ;
1043: LD_VAR 0 2
1047: RET
// export function ReverseArray ( array ) ; var i ; begin
1048: LD_INT 0
1050: PPUSH
1051: PPUSH
// if not array then
1052: LD_VAR 0 1
1056: NOT
1057: IFFALSE 1061
// exit ;
1059: GO 1119
// result := [ ] ;
1061: LD_ADDR_VAR 0 2
1065: PUSH
1066: EMPTY
1067: ST_TO_ADDR
// for i := 1 to array do
1068: LD_ADDR_VAR 0 3
1072: PUSH
1073: DOUBLE
1074: LD_INT 1
1076: DEC
1077: ST_TO_ADDR
1078: LD_VAR 0 1
1082: PUSH
1083: FOR_TO
1084: IFFALSE 1117
// result := Insert ( result , 1 , array [ i ] ) ;
1086: LD_ADDR_VAR 0 2
1090: PUSH
1091: LD_VAR 0 2
1095: PPUSH
1096: LD_INT 1
1098: PPUSH
1099: LD_VAR 0 1
1103: PUSH
1104: LD_VAR 0 3
1108: ARRAY
1109: PPUSH
1110: CALL_OW 2
1114: ST_TO_ADDR
1115: GO 1083
1117: POP
1118: POP
// end ;
1119: LD_VAR 0 2
1123: RET
// export function ComExit ( unit ) ; begin
1124: LD_INT 0
1126: PPUSH
// result := IsInUnit ( unit ) ;
1127: LD_ADDR_VAR 0 2
1131: PUSH
1132: LD_VAR 0 1
1136: PPUSH
1137: CALL_OW 310
1141: ST_TO_ADDR
// if not result then
1142: LD_VAR 0 2
1146: NOT
1147: IFFALSE 1151
// exit ;
1149: GO 1186
// if GetType ( result ) = unit_vehicle then
1151: LD_VAR 0 2
1155: PPUSH
1156: CALL_OW 247
1160: PUSH
1161: LD_INT 2
1163: EQUAL
1164: IFFALSE 1177
// ComExitVehicle ( unit ) else
1166: LD_VAR 0 1
1170: PPUSH
1171: CALL_OW 121
1175: GO 1186
// ComExitBuilding ( unit ) ;
1177: LD_VAR 0 1
1181: PPUSH
1182: CALL_OW 122
// end ;
1186: LD_VAR 0 2
1190: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1191: LD_INT 0
1193: PPUSH
1194: PPUSH
// if not side or not nation then
1195: LD_VAR 0 1
1199: NOT
1200: PUSH
1201: LD_VAR 0 2
1205: NOT
1206: OR
1207: IFFALSE 1211
// exit ;
1209: GO 1975
// case nation of nation_american :
1211: LD_VAR 0 2
1215: PUSH
1216: LD_INT 1
1218: DOUBLE
1219: EQUAL
1220: IFTRUE 1224
1222: GO 1438
1224: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1225: LD_ADDR_VAR 0 4
1229: PUSH
1230: LD_INT 35
1232: PUSH
1233: LD_INT 45
1235: PUSH
1236: LD_INT 46
1238: PUSH
1239: LD_INT 47
1241: PUSH
1242: LD_INT 82
1244: PUSH
1245: LD_INT 83
1247: PUSH
1248: LD_INT 84
1250: PUSH
1251: LD_INT 85
1253: PUSH
1254: LD_INT 86
1256: PUSH
1257: LD_INT 1
1259: PUSH
1260: LD_INT 2
1262: PUSH
1263: LD_INT 6
1265: PUSH
1266: LD_INT 15
1268: PUSH
1269: LD_INT 16
1271: PUSH
1272: LD_INT 7
1274: PUSH
1275: LD_INT 12
1277: PUSH
1278: LD_INT 13
1280: PUSH
1281: LD_INT 10
1283: PUSH
1284: LD_INT 14
1286: PUSH
1287: LD_INT 20
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 22
1295: PUSH
1296: LD_INT 25
1298: PUSH
1299: LD_INT 32
1301: PUSH
1302: LD_INT 27
1304: PUSH
1305: LD_INT 36
1307: PUSH
1308: LD_INT 69
1310: PUSH
1311: LD_INT 39
1313: PUSH
1314: LD_INT 34
1316: PUSH
1317: LD_INT 40
1319: PUSH
1320: LD_INT 48
1322: PUSH
1323: LD_INT 49
1325: PUSH
1326: LD_INT 50
1328: PUSH
1329: LD_INT 51
1331: PUSH
1332: LD_INT 52
1334: PUSH
1335: LD_INT 53
1337: PUSH
1338: LD_INT 54
1340: PUSH
1341: LD_INT 55
1343: PUSH
1344: LD_INT 56
1346: PUSH
1347: LD_INT 57
1349: PUSH
1350: LD_INT 58
1352: PUSH
1353: LD_INT 59
1355: PUSH
1356: LD_INT 60
1358: PUSH
1359: LD_INT 61
1361: PUSH
1362: LD_INT 62
1364: PUSH
1365: LD_INT 80
1367: PUSH
1368: LD_INT 82
1370: PUSH
1371: LD_INT 83
1373: PUSH
1374: LD_INT 84
1376: PUSH
1377: LD_INT 85
1379: PUSH
1380: LD_INT 86
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: ST_TO_ADDR
1436: GO 1899
1438: LD_INT 2
1440: DOUBLE
1441: EQUAL
1442: IFTRUE 1446
1444: GO 1668
1446: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1447: LD_ADDR_VAR 0 4
1451: PUSH
1452: LD_INT 35
1454: PUSH
1455: LD_INT 45
1457: PUSH
1458: LD_INT 46
1460: PUSH
1461: LD_INT 47
1463: PUSH
1464: LD_INT 82
1466: PUSH
1467: LD_INT 83
1469: PUSH
1470: LD_INT 84
1472: PUSH
1473: LD_INT 85
1475: PUSH
1476: LD_INT 87
1478: PUSH
1479: LD_INT 70
1481: PUSH
1482: LD_INT 1
1484: PUSH
1485: LD_INT 11
1487: PUSH
1488: LD_INT 3
1490: PUSH
1491: LD_INT 4
1493: PUSH
1494: LD_INT 5
1496: PUSH
1497: LD_INT 6
1499: PUSH
1500: LD_INT 15
1502: PUSH
1503: LD_INT 18
1505: PUSH
1506: LD_INT 7
1508: PUSH
1509: LD_INT 17
1511: PUSH
1512: LD_INT 8
1514: PUSH
1515: LD_INT 20
1517: PUSH
1518: LD_INT 21
1520: PUSH
1521: LD_INT 22
1523: PUSH
1524: LD_INT 72
1526: PUSH
1527: LD_INT 26
1529: PUSH
1530: LD_INT 69
1532: PUSH
1533: LD_INT 39
1535: PUSH
1536: LD_INT 40
1538: PUSH
1539: LD_INT 41
1541: PUSH
1542: LD_INT 42
1544: PUSH
1545: LD_INT 43
1547: PUSH
1548: LD_INT 48
1550: PUSH
1551: LD_INT 49
1553: PUSH
1554: LD_INT 50
1556: PUSH
1557: LD_INT 51
1559: PUSH
1560: LD_INT 52
1562: PUSH
1563: LD_INT 53
1565: PUSH
1566: LD_INT 54
1568: PUSH
1569: LD_INT 55
1571: PUSH
1572: LD_INT 56
1574: PUSH
1575: LD_INT 60
1577: PUSH
1578: LD_INT 61
1580: PUSH
1581: LD_INT 62
1583: PUSH
1584: LD_INT 66
1586: PUSH
1587: LD_INT 67
1589: PUSH
1590: LD_INT 68
1592: PUSH
1593: LD_INT 81
1595: PUSH
1596: LD_INT 82
1598: PUSH
1599: LD_INT 83
1601: PUSH
1602: LD_INT 84
1604: PUSH
1605: LD_INT 85
1607: PUSH
1608: LD_INT 87
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: LIST
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: ST_TO_ADDR
1666: GO 1899
1668: LD_INT 3
1670: DOUBLE
1671: EQUAL
1672: IFTRUE 1676
1674: GO 1898
1676: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1677: LD_ADDR_VAR 0 4
1681: PUSH
1682: LD_INT 46
1684: PUSH
1685: LD_INT 47
1687: PUSH
1688: LD_INT 1
1690: PUSH
1691: LD_INT 2
1693: PUSH
1694: LD_INT 82
1696: PUSH
1697: LD_INT 83
1699: PUSH
1700: LD_INT 84
1702: PUSH
1703: LD_INT 85
1705: PUSH
1706: LD_INT 86
1708: PUSH
1709: LD_INT 11
1711: PUSH
1712: LD_INT 9
1714: PUSH
1715: LD_INT 20
1717: PUSH
1718: LD_INT 19
1720: PUSH
1721: LD_INT 21
1723: PUSH
1724: LD_INT 24
1726: PUSH
1727: LD_INT 22
1729: PUSH
1730: LD_INT 25
1732: PUSH
1733: LD_INT 28
1735: PUSH
1736: LD_INT 29
1738: PUSH
1739: LD_INT 30
1741: PUSH
1742: LD_INT 31
1744: PUSH
1745: LD_INT 37
1747: PUSH
1748: LD_INT 38
1750: PUSH
1751: LD_INT 32
1753: PUSH
1754: LD_INT 27
1756: PUSH
1757: LD_INT 33
1759: PUSH
1760: LD_INT 69
1762: PUSH
1763: LD_INT 39
1765: PUSH
1766: LD_INT 34
1768: PUSH
1769: LD_INT 40
1771: PUSH
1772: LD_INT 71
1774: PUSH
1775: LD_INT 23
1777: PUSH
1778: LD_INT 44
1780: PUSH
1781: LD_INT 48
1783: PUSH
1784: LD_INT 49
1786: PUSH
1787: LD_INT 50
1789: PUSH
1790: LD_INT 51
1792: PUSH
1793: LD_INT 52
1795: PUSH
1796: LD_INT 53
1798: PUSH
1799: LD_INT 54
1801: PUSH
1802: LD_INT 55
1804: PUSH
1805: LD_INT 56
1807: PUSH
1808: LD_INT 57
1810: PUSH
1811: LD_INT 58
1813: PUSH
1814: LD_INT 59
1816: PUSH
1817: LD_INT 63
1819: PUSH
1820: LD_INT 64
1822: PUSH
1823: LD_INT 65
1825: PUSH
1826: LD_INT 82
1828: PUSH
1829: LD_INT 83
1831: PUSH
1832: LD_INT 84
1834: PUSH
1835: LD_INT 85
1837: PUSH
1838: LD_INT 86
1840: PUSH
1841: EMPTY
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: ST_TO_ADDR
1896: GO 1899
1898: POP
// if state > - 1 and state < 3 then
1899: LD_VAR 0 3
1903: PUSH
1904: LD_INT 1
1906: NEG
1907: GREATER
1908: PUSH
1909: LD_VAR 0 3
1913: PUSH
1914: LD_INT 3
1916: LESS
1917: AND
1918: IFFALSE 1975
// for i in result do
1920: LD_ADDR_VAR 0 5
1924: PUSH
1925: LD_VAR 0 4
1929: PUSH
1930: FOR_IN
1931: IFFALSE 1973
// if GetTech ( i , side ) <> state then
1933: LD_VAR 0 5
1937: PPUSH
1938: LD_VAR 0 1
1942: PPUSH
1943: CALL_OW 321
1947: PUSH
1948: LD_VAR 0 3
1952: NONEQUAL
1953: IFFALSE 1971
// result := result diff i ;
1955: LD_ADDR_VAR 0 4
1959: PUSH
1960: LD_VAR 0 4
1964: PUSH
1965: LD_VAR 0 5
1969: DIFF
1970: ST_TO_ADDR
1971: GO 1930
1973: POP
1974: POP
// end ; end_of_file
1975: LD_VAR 0 4
1979: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1980: LD_INT 0
1982: PPUSH
1983: PPUSH
1984: PPUSH
1985: PPUSH
// uc_side := 5 ;
1986: LD_ADDR_OWVAR 20
1990: PUSH
1991: LD_INT 5
1993: ST_TO_ADDR
// uc_nation := 2 ;
1994: LD_ADDR_OWVAR 21
1998: PUSH
1999: LD_INT 2
2001: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
2002: LD_INT 5
2004: PPUSH
2005: CALL_OW 274
2009: PPUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 45
2015: PPUSH
2016: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
2020: LD_ADDR_EXP 34
2024: PUSH
2025: LD_STRING Farmer
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: LD_STRING 
2033: PPUSH
2034: CALL 297 0 3
2038: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2039: LD_ADDR_EXP 35
2043: PUSH
2044: LD_STRING Omar
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: LD_STRING 
2052: PPUSH
2053: CALL 297 0 3
2057: ST_TO_ADDR
// omarSquad := [ ] ;
2058: LD_ADDR_EXP 38
2062: PUSH
2063: EMPTY
2064: ST_TO_ADDR
// heikeSquad := [ ] ;
2065: LD_ADDR_EXP 39
2069: PUSH
2070: EMPTY
2071: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2072: LD_ADDR_EXP 40
2076: PUSH
2077: EMPTY
2078: ST_TO_ADDR
// omarCargo := [ ] ;
2079: LD_ADDR_EXP 41
2083: PUSH
2084: EMPTY
2085: ST_TO_ADDR
// for i := 1 to 5 do
2086: LD_ADDR_VAR 0 2
2090: PUSH
2091: DOUBLE
2092: LD_INT 1
2094: DEC
2095: ST_TO_ADDR
2096: LD_INT 5
2098: PUSH
2099: FOR_TO
2100: IFFALSE 2258
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2102: LD_INT 0
2104: PPUSH
2105: LD_INT 1
2107: PUSH
2108: LD_INT 1
2110: PUSH
2111: LD_INT 2
2113: PUSH
2114: LD_INT 1
2116: PUSH
2117: LD_INT 1
2119: PUSH
2120: EMPTY
2121: LIST
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: PUSH
2127: LD_VAR 0 2
2131: ARRAY
2132: PPUSH
2133: LD_INT 3
2135: PPUSH
2136: CALL_OW 380
// un := CreateHuman ;
2140: LD_ADDR_VAR 0 3
2144: PUSH
2145: CALL_OW 44
2149: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2150: LD_ADDR_EXP 38
2154: PUSH
2155: LD_EXP 38
2159: PUSH
2160: LD_VAR 0 3
2164: UNION
2165: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2166: LD_VAR 0 3
2170: PPUSH
2171: LD_INT 87
2173: PUSH
2174: LD_INT 30
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: PUSH
2181: LD_INT 91
2183: PUSH
2184: LD_INT 32
2186: PUSH
2187: EMPTY
2188: LIST
2189: LIST
2190: PUSH
2191: LD_INT 82
2193: PUSH
2194: LD_INT 15
2196: PUSH
2197: EMPTY
2198: LIST
2199: LIST
2200: PUSH
2201: LD_INT 79
2203: PUSH
2204: LD_INT 14
2206: PUSH
2207: EMPTY
2208: LIST
2209: LIST
2210: PUSH
2211: LD_INT 82
2213: PUSH
2214: LD_INT 13
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: PUSH
2221: EMPTY
2222: LIST
2223: LIST
2224: LIST
2225: LIST
2226: LIST
2227: PUSH
2228: LD_VAR 0 2
2232: ARRAY
2233: PPUSH
2234: LD_INT 0
2236: PPUSH
2237: CALL 928 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2241: LD_VAR 0 3
2245: PPUSH
2246: LD_INT 93
2248: PPUSH
2249: LD_INT 21
2251: PPUSH
2252: CALL_OW 118
// end ;
2256: GO 2099
2258: POP
2259: POP
// uc_side := 2 ;
2260: LD_ADDR_OWVAR 20
2264: PUSH
2265: LD_INT 2
2267: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2268: LD_ADDR_EXP 26
2272: PUSH
2273: LD_STRING Heike
2275: PPUSH
2276: LD_EXP 1
2280: NOT
2281: PPUSH
2282: LD_EXP 2
2286: PPUSH
2287: CALL 297 0 3
2291: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2292: LD_ADDR_EXP 30
2296: PUSH
2297: LD_STRING Aviradze
2299: PPUSH
2300: LD_EXP 1
2304: NOT
2305: PPUSH
2306: LD_EXP 2
2310: PPUSH
2311: CALL 297 0 3
2315: ST_TO_ADDR
// tmp := [ ] ;
2316: LD_ADDR_VAR 0 4
2320: PUSH
2321: EMPTY
2322: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2323: LD_ADDR_EXP 27
2327: PUSH
2328: LD_STRING Givi
2330: PPUSH
2331: LD_EXP 1
2335: NOT
2336: PPUSH
2337: LD_EXP 2
2341: PPUSH
2342: CALL 297 0 3
2346: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2347: LD_ADDR_EXP 28
2351: PUSH
2352: LD_STRING Mike
2354: PPUSH
2355: LD_EXP 1
2359: NOT
2360: PPUSH
2361: LD_EXP 2
2365: PPUSH
2366: CALL 297 0 3
2370: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2371: LD_ADDR_EXP 29
2375: PUSH
2376: LD_STRING Kamil
2378: PPUSH
2379: LD_EXP 1
2383: NOT
2384: PPUSH
2385: LD_EXP 2
2389: PPUSH
2390: CALL 297 0 3
2394: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2395: LD_ADDR_EXP 31
2399: PUSH
2400: LD_STRING Kaia
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_EXP 2
2413: PPUSH
2414: CALL 297 0 3
2418: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2419: LD_ADDR_EXP 32
2423: PUSH
2424: LD_STRING Sophia
2426: PPUSH
2427: LD_EXP 1
2431: NOT
2432: PPUSH
2433: LD_EXP 2
2437: PPUSH
2438: CALL 297 0 3
2442: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2443: LD_ADDR_EXP 33
2447: PUSH
2448: LD_STRING Markov
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_EXP 2
2461: PPUSH
2462: CALL 297 0 3
2466: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2467: LD_ADDR_EXP 40
2471: PUSH
2472: LD_STRING 02_others
2474: PPUSH
2475: CALL_OW 31
2479: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2480: LD_ADDR_VAR 0 4
2484: PUSH
2485: LD_EXP 28
2489: PUSH
2490: LD_EXP 29
2494: PUSH
2495: LD_EXP 31
2499: PUSH
2500: LD_EXP 32
2504: PUSH
2505: LD_EXP 33
2509: PUSH
2510: LD_EXP 27
2514: PUSH
2515: EMPTY
2516: LIST
2517: LIST
2518: LIST
2519: LIST
2520: LIST
2521: LIST
2522: PUSH
2523: LD_EXP 40
2527: ADD
2528: PUSH
2529: LD_INT 0
2531: DIFF
2532: ST_TO_ADDR
// heikeSquad := tmp ;
2533: LD_ADDR_EXP 39
2537: PUSH
2538: LD_VAR 0 4
2542: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 02_ape ) ;
2543: LD_ADDR_VAR 0 4
2547: PUSH
2548: LD_VAR 0 4
2552: PUSH
2553: LD_STRING 02_ape
2555: PPUSH
2556: CALL_OW 31
2560: UNION
2561: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2562: LD_EXP 26
2566: PPUSH
2567: LD_INT 92
2569: PPUSH
2570: LD_INT 17
2572: PPUSH
2573: LD_INT 0
2575: PPUSH
2576: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2580: LD_EXP 34
2584: PPUSH
2585: LD_INT 95
2587: PPUSH
2588: LD_INT 19
2590: PPUSH
2591: LD_INT 0
2593: PPUSH
2594: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2598: LD_EXP 35
2602: PPUSH
2603: LD_INT 89
2605: PPUSH
2606: LD_INT 25
2608: PPUSH
2609: LD_INT 0
2611: PPUSH
2612: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2616: LD_EXP 30
2620: PPUSH
2621: LD_INT 92
2623: PPUSH
2624: LD_INT 27
2626: PPUSH
2627: LD_INT 0
2629: PPUSH
2630: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2634: LD_EXP 35
2638: PPUSH
2639: LD_EXP 30
2643: PPUSH
2644: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2648: LD_EXP 30
2652: PPUSH
2653: LD_EXP 35
2657: PPUSH
2658: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2662: LD_EXP 26
2666: PUSH
2667: LD_EXP 34
2671: PUSH
2672: EMPTY
2673: LIST
2674: LIST
2675: PPUSH
2676: LD_EXP 35
2680: PPUSH
2681: CALL_OW 119
// if tmp then
2685: LD_VAR 0 4
2689: IFFALSE 2743
// for i in tmp do
2691: LD_ADDR_VAR 0 2
2695: PUSH
2696: LD_VAR 0 4
2700: PUSH
2701: FOR_IN
2702: IFFALSE 2741
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2704: LD_VAR 0 2
2708: PPUSH
2709: LD_INT 94
2711: PPUSH
2712: LD_INT 14
2714: PPUSH
2715: LD_INT 4
2717: PPUSH
2718: LD_INT 0
2720: PPUSH
2721: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2725: LD_VAR 0 2
2729: PPUSH
2730: LD_EXP 26
2734: PPUSH
2735: CALL_OW 119
// end ;
2739: GO 2701
2741: POP
2742: POP
// farmerSquad := [ ] ;
2743: LD_ADDR_EXP 37
2747: PUSH
2748: EMPTY
2749: ST_TO_ADDR
// uc_side := 5 ;
2750: LD_ADDR_OWVAR 20
2754: PUSH
2755: LD_INT 5
2757: ST_TO_ADDR
// uc_nation := 2 ;
2758: LD_ADDR_OWVAR 21
2762: PUSH
2763: LD_INT 2
2765: ST_TO_ADDR
// for i := 1 to 4 do
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: DOUBLE
2772: LD_INT 1
2774: DEC
2775: ST_TO_ADDR
2776: LD_INT 4
2778: PUSH
2779: FOR_TO
2780: IFFALSE 2858
// begin PrepareHuman ( false , 1 , 2 ) ;
2782: LD_INT 0
2784: PPUSH
2785: LD_INT 1
2787: PPUSH
2788: LD_INT 2
2790: PPUSH
2791: CALL_OW 380
// un := CreateHuman ;
2795: LD_ADDR_VAR 0 3
2799: PUSH
2800: CALL_OW 44
2804: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2805: LD_VAR 0 3
2809: PPUSH
2810: LD_INT 102
2812: PPUSH
2813: LD_INT 27
2815: PPUSH
2816: LD_INT 4
2818: PPUSH
2819: LD_INT 0
2821: PPUSH
2822: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2826: LD_ADDR_EXP 37
2830: PUSH
2831: LD_EXP 37
2835: PUSH
2836: LD_VAR 0 3
2840: UNION
2841: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2842: LD_VAR 0 3
2846: PPUSH
2847: LD_EXP 35
2851: PPUSH
2852: CALL_OW 119
// end ;
2856: GO 2779
2858: POP
2859: POP
// for i := 1 to 2 do
2860: LD_ADDR_VAR 0 2
2864: PUSH
2865: DOUBLE
2866: LD_INT 1
2868: DEC
2869: ST_TO_ADDR
2870: LD_INT 2
2872: PUSH
2873: FOR_TO
2874: IFFALSE 2952
// begin PrepareHuman ( false , 2 , 2 ) ;
2876: LD_INT 0
2878: PPUSH
2879: LD_INT 2
2881: PPUSH
2882: LD_INT 2
2884: PPUSH
2885: CALL_OW 380
// un := CreateHuman ;
2889: LD_ADDR_VAR 0 3
2893: PUSH
2894: CALL_OW 44
2898: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2899: LD_VAR 0 3
2903: PPUSH
2904: LD_INT 108
2906: PPUSH
2907: LD_INT 62
2909: PPUSH
2910: LD_INT 2
2912: PPUSH
2913: LD_INT 0
2915: PPUSH
2916: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2920: LD_ADDR_EXP 37
2924: PUSH
2925: LD_EXP 37
2929: PUSH
2930: LD_VAR 0 3
2934: UNION
2935: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2936: LD_VAR 0 3
2940: PPUSH
2941: LD_EXP 35
2945: PPUSH
2946: CALL_OW 119
// end ;
2950: GO 2873
2952: POP
2953: POP
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
2954: LD_INT 109
2956: PPUSH
2957: LD_INT 63
2959: PPUSH
2960: LD_INT 2
2962: PPUSH
2963: LD_INT 15
2965: NEG
2966: PPUSH
2967: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
2971: LD_INT 109
2973: PPUSH
2974: LD_INT 63
2976: PPUSH
2977: LD_INT 2
2979: PPUSH
2980: CALL_OW 331
// end ;
2984: LD_VAR 0 1
2988: RET
// export function PrepareIbrahim ( x , y ) ; begin
2989: LD_INT 0
2991: PPUSH
// uc_side := 6 ;
2992: LD_ADDR_OWVAR 20
2996: PUSH
2997: LD_INT 6
2999: ST_TO_ADDR
// uc_nation := 3 ;
3000: LD_ADDR_OWVAR 21
3004: PUSH
3005: LD_INT 3
3007: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3008: LD_ADDR_EXP 36
3012: PUSH
3013: LD_STRING IbrahimRu
3015: PPUSH
3016: LD_INT 0
3018: PPUSH
3019: LD_STRING 
3021: PPUSH
3022: CALL 297 0 3
3026: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3027: LD_EXP 36
3031: PPUSH
3032: LD_VAR 0 1
3036: PPUSH
3037: LD_VAR 0 2
3041: PPUSH
3042: LD_INT 8
3044: PPUSH
3045: LD_INT 1
3047: PPUSH
3048: CALL_OW 50
// end ;
3052: LD_VAR 0 3
3056: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3057: LD_EXP 35
3061: PUSH
3062: LD_EXP 38
3066: ADD
3067: PPUSH
3068: LD_INT 95
3070: PUSH
3071: LD_INT 3
3073: PUSH
3074: EMPTY
3075: LIST
3076: LIST
3077: PPUSH
3078: CALL_OW 72
3082: IFFALSE 3138
3084: GO 3086
3086: DISABLE
3087: LD_INT 0
3089: PPUSH
// begin enable ;
3090: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3091: LD_ADDR_VAR 0 1
3095: PUSH
3096: LD_EXP 35
3100: PUSH
3101: LD_EXP 38
3105: ADD
3106: PPUSH
3107: LD_INT 95
3109: PUSH
3110: LD_INT 3
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: PPUSH
3117: CALL_OW 72
3121: PUSH
3122: FOR_IN
3123: IFFALSE 3136
// RemoveUnit ( i ) ;
3125: LD_VAR 0 1
3129: PPUSH
3130: CALL_OW 64
3134: GO 3122
3136: POP
3137: POP
// end ;
3138: PPOPN 1
3140: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3141: LD_EXP 3
3145: PUSH
3146: LD_EXP 34
3150: PPUSH
3151: LD_INT 4
3153: PPUSH
3154: CALL_OW 308
3158: AND
3159: IFFALSE 3942
3161: GO 3163
3163: DISABLE
3164: LD_INT 0
3166: PPUSH
3167: PPUSH
3168: PPUSH
3169: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3170: LD_EXP 34
3174: PPUSH
3175: LD_INT 110
3177: PPUSH
3178: LD_INT 60
3180: PPUSH
3181: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3185: LD_EXP 34
3189: PPUSH
3190: LD_INT 110
3192: PPUSH
3193: LD_INT 61
3195: PPUSH
3196: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3200: LD_ADDR_VAR 0 2
3204: PUSH
3205: LD_EXP 37
3209: PPUSH
3210: LD_INT 25
3212: PUSH
3213: LD_INT 1
3215: PUSH
3216: EMPTY
3217: LIST
3218: LIST
3219: PPUSH
3220: CALL_OW 72
3224: ST_TO_ADDR
// if tmp then
3225: LD_VAR 0 2
3229: IFFALSE 3323
// begin for i := 1 to 2 do
3231: LD_ADDR_VAR 0 1
3235: PUSH
3236: DOUBLE
3237: LD_INT 1
3239: DEC
3240: ST_TO_ADDR
3241: LD_INT 2
3243: PUSH
3244: FOR_TO
3245: IFFALSE 3321
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3247: LD_VAR 0 2
3251: PUSH
3252: LD_VAR 0 1
3256: ARRAY
3257: PPUSH
3258: LD_INT 5
3260: PPUSH
3261: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3265: LD_VAR 0 2
3269: PUSH
3270: LD_VAR 0 1
3274: ARRAY
3275: PPUSH
3276: LD_INT 2
3278: PPUSH
3279: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3283: LD_VAR 0 2
3287: PUSH
3288: LD_VAR 0 1
3292: ARRAY
3293: PPUSH
3294: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3298: LD_VAR 0 2
3302: PUSH
3303: LD_VAR 0 1
3307: ARRAY
3308: PPUSH
3309: LD_INT 107
3311: PPUSH
3312: LD_INT 66
3314: PPUSH
3315: CALL_OW 171
// end ;
3319: GO 3244
3321: POP
3322: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3323: LD_ADDR_VAR 0 2
3327: PUSH
3328: LD_EXP 37
3332: PPUSH
3333: LD_INT 25
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PPUSH
3343: CALL_OW 72
3347: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3348: LD_INT 35
3350: PPUSH
3351: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3355: LD_ADDR_VAR 0 2
3359: PUSH
3360: LD_EXP 37
3364: PPUSH
3365: LD_INT 25
3367: PUSH
3368: LD_INT 2
3370: PUSH
3371: EMPTY
3372: LIST
3373: LIST
3374: PPUSH
3375: CALL_OW 72
3379: ST_TO_ADDR
// until tmp ;
3380: LD_VAR 0 2
3384: IFFALSE 3348
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3386: LD_VAR 0 2
3390: PPUSH
3391: LD_INT 31
3393: PPUSH
3394: LD_INT 102
3396: PPUSH
3397: LD_INT 69
3399: PPUSH
3400: LD_INT 2
3402: PPUSH
3403: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3407: LD_INT 35
3409: PPUSH
3410: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3414: LD_EXP 37
3418: PPUSH
3419: LD_INT 3
3421: PUSH
3422: LD_INT 60
3424: PUSH
3425: EMPTY
3426: LIST
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 25
3434: PUSH
3435: LD_INT 2
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: PPUSH
3446: CALL_OW 72
3450: IFFALSE 3407
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3452: LD_ADDR_VAR 0 2
3456: PUSH
3457: LD_EXP 37
3461: PPUSH
3462: LD_INT 25
3464: PUSH
3465: LD_INT 2
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: PPUSH
3472: CALL_OW 72
3476: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3477: LD_VAR 0 2
3481: PPUSH
3482: LD_INT 4
3484: PPUSH
3485: LD_INT 116
3487: PPUSH
3488: LD_INT 70
3490: PPUSH
3491: LD_INT 5
3493: PPUSH
3494: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3498: LD_VAR 0 2
3502: PPUSH
3503: LD_INT 31
3505: PPUSH
3506: LD_INT 108
3508: PPUSH
3509: LD_INT 50
3511: PPUSH
3512: LD_INT 2
3514: PPUSH
3515: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3519: LD_INT 35
3521: PPUSH
3522: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3526: LD_INT 22
3528: PUSH
3529: LD_INT 5
3531: PUSH
3532: EMPTY
3533: LIST
3534: LIST
3535: PUSH
3536: LD_INT 30
3538: PUSH
3539: LD_INT 4
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 3
3548: PUSH
3549: LD_INT 57
3551: PUSH
3552: EMPTY
3553: LIST
3554: PUSH
3555: EMPTY
3556: LIST
3557: LIST
3558: PUSH
3559: EMPTY
3560: LIST
3561: LIST
3562: LIST
3563: PPUSH
3564: CALL_OW 69
3568: IFFALSE 3519
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3570: LD_ADDR_VAR 0 3
3574: PUSH
3575: LD_INT 22
3577: PUSH
3578: LD_INT 5
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: PUSH
3585: LD_INT 30
3587: PUSH
3588: LD_INT 4
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: LD_INT 3
3597: PUSH
3598: LD_INT 57
3600: PUSH
3601: EMPTY
3602: LIST
3603: PUSH
3604: EMPTY
3605: LIST
3606: LIST
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: PPUSH
3613: CALL_OW 69
3617: PUSH
3618: LD_INT 1
3620: ARRAY
3621: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3622: LD_ADDR_VAR 0 2
3626: PUSH
3627: LD_EXP 37
3631: PPUSH
3632: LD_INT 25
3634: PUSH
3635: LD_INT 1
3637: PUSH
3638: EMPTY
3639: LIST
3640: LIST
3641: PPUSH
3642: CALL_OW 72
3646: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3647: LD_VAR 0 2
3651: PPUSH
3652: LD_VAR 0 3
3656: PPUSH
3657: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3661: LD_INT 35
3663: PPUSH
3664: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3668: LD_INT 22
3670: PUSH
3671: LD_INT 5
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: PUSH
3678: LD_INT 30
3680: PUSH
3681: LD_INT 31
3683: PUSH
3684: EMPTY
3685: LIST
3686: LIST
3687: PUSH
3688: LD_INT 3
3690: PUSH
3691: LD_INT 57
3693: PUSH
3694: EMPTY
3695: LIST
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: PUSH
3701: EMPTY
3702: LIST
3703: LIST
3704: LIST
3705: PPUSH
3706: CALL_OW 69
3710: PUSH
3711: LD_INT 2
3713: GREATEREQUAL
3714: IFFALSE 3661
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3716: LD_ADDR_VAR 0 2
3720: PUSH
3721: LD_EXP 37
3725: PPUSH
3726: LD_INT 25
3728: PUSH
3729: LD_INT 2
3731: PUSH
3732: EMPTY
3733: LIST
3734: LIST
3735: PPUSH
3736: CALL_OW 72
3740: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3741: LD_VAR 0 2
3745: PUSH
3746: LD_INT 1
3748: ARRAY
3749: PPUSH
3750: LD_INT 5
3752: PPUSH
3753: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3757: LD_VAR 0 2
3761: PUSH
3762: LD_INT 2
3764: ARRAY
3765: PUSH
3766: LD_VAR 0 2
3770: PUSH
3771: LD_INT 3
3773: ARRAY
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: PPUSH
3779: LD_VAR 0 3
3783: PPUSH
3784: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3788: LD_VAR 0 2
3792: PUSH
3793: LD_INT 2
3795: ARRAY
3796: PUSH
3797: LD_VAR 0 2
3801: PUSH
3802: LD_INT 3
3804: ARRAY
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PPUSH
3810: LD_INT 1
3812: PPUSH
3813: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3817: LD_VAR 0 2
3821: PUSH
3822: LD_INT 2
3824: ARRAY
3825: PUSH
3826: LD_VAR 0 2
3830: PUSH
3831: LD_INT 3
3833: ARRAY
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PPUSH
3839: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3843: LD_ADDR_VAR 0 4
3847: PUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: EMPTY
3855: LIST
3856: LIST
3857: PUSH
3858: LD_INT 30
3860: PUSH
3861: LD_INT 31
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PPUSH
3872: CALL_OW 69
3876: ST_TO_ADDR
// for i := 1 to 2 do
3877: LD_ADDR_VAR 0 1
3881: PUSH
3882: DOUBLE
3883: LD_INT 1
3885: DEC
3886: ST_TO_ADDR
3887: LD_INT 2
3889: PUSH
3890: FOR_TO
3891: IFFALSE 3925
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3893: LD_VAR 0 2
3897: PUSH
3898: LD_VAR 0 1
3902: PUSH
3903: LD_INT 1
3905: PLUS
3906: ARRAY
3907: PPUSH
3908: LD_VAR 0 4
3912: PUSH
3913: LD_VAR 0 1
3917: ARRAY
3918: PPUSH
3919: CALL_OW 180
3923: GO 3890
3925: POP
3926: POP
// wait ( 1 1$00 ) ;
3927: LD_INT 2100
3929: PPUSH
3930: CALL_OW 67
// farmerBaseReady := true ;
3934: LD_ADDR_EXP 4
3938: PUSH
3939: LD_INT 1
3941: ST_TO_ADDR
// end ;
3942: PPOPN 4
3944: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
3945: LD_EXP 4
3949: PUSH
3950: LD_EXP 10
3954: NOT
3955: AND
3956: IFFALSE 4478
3958: GO 3960
3960: DISABLE
3961: LD_INT 0
3963: PPUSH
3964: PPUSH
3965: PPUSH
3966: PPUSH
3967: PPUSH
// begin enable ;
3968: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
3969: LD_ADDR_VAR 0 3
3973: PUSH
3974: LD_EXP 37
3978: PPUSH
3979: LD_INT 25
3981: PUSH
3982: LD_INT 1
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: PPUSH
3989: CALL_OW 72
3993: PUSH
3994: LD_EXP 34
3998: ADD
3999: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: LD_EXP 37
4009: PPUSH
4010: LD_INT 25
4012: PUSH
4013: LD_INT 2
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: PPUSH
4020: CALL_OW 72
4024: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4025: LD_ADDR_VAR 0 5
4029: PUSH
4030: LD_INT 22
4032: PUSH
4033: LD_INT 5
4035: PUSH
4036: EMPTY
4037: LIST
4038: LIST
4039: PUSH
4040: LD_INT 21
4042: PUSH
4043: LD_INT 3
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: PUSH
4050: LD_INT 3
4052: PUSH
4053: LD_INT 24
4055: PUSH
4056: LD_INT 1000
4058: PUSH
4059: EMPTY
4060: LIST
4061: LIST
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: EMPTY
4068: LIST
4069: LIST
4070: LIST
4071: PPUSH
4072: CALL_OW 69
4076: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4077: LD_ADDR_VAR 0 4
4081: PUSH
4082: LD_INT 22
4084: PUSH
4085: LD_INT 5
4087: PUSH
4088: EMPTY
4089: LIST
4090: LIST
4091: PUSH
4092: LD_INT 30
4094: PUSH
4095: LD_INT 4
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: PUSH
4102: EMPTY
4103: LIST
4104: LIST
4105: PPUSH
4106: CALL_OW 69
4110: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4111: LD_VAR 0 4
4115: PUSH
4116: LD_INT 1
4118: ARRAY
4119: PPUSH
4120: CALL_OW 302
4124: IFFALSE 4188
// for i in sol do
4126: LD_ADDR_VAR 0 1
4130: PUSH
4131: LD_VAR 0 3
4135: PUSH
4136: FOR_IN
4137: IFFALSE 4186
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4139: LD_VAR 0 1
4143: PPUSH
4144: CALL_OW 256
4148: PUSH
4149: LD_INT 999
4151: LESS
4152: PUSH
4153: LD_VAR 0 1
4157: PPUSH
4158: CALL_OW 310
4162: NOT
4163: AND
4164: IFFALSE 4184
// ComEnterUnit ( i , arm [ 1 ] ) ;
4166: LD_VAR 0 1
4170: PPUSH
4171: LD_VAR 0 4
4175: PUSH
4176: LD_INT 1
4178: ARRAY
4179: PPUSH
4180: CALL_OW 120
4184: GO 4136
4186: POP
4187: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4188: LD_VAR 0 2
4192: NOT
4193: PUSH
4194: LD_INT 22
4196: PUSH
4197: LD_INT 1
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PUSH
4204: LD_INT 21
4206: PUSH
4207: LD_INT 1
4209: PUSH
4210: EMPTY
4211: LIST
4212: LIST
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: PPUSH
4218: CALL_OW 69
4222: NOT
4223: AND
4224: IFFALSE 4316
// begin uc_side := 5 ;
4226: LD_ADDR_OWVAR 20
4230: PUSH
4231: LD_INT 5
4233: ST_TO_ADDR
// uc_nation := 2 ;
4234: LD_ADDR_OWVAR 21
4238: PUSH
4239: LD_INT 2
4241: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4242: LD_INT 0
4244: PPUSH
4245: LD_INT 2
4247: PPUSH
4248: LD_INT 2
4250: PPUSH
4251: CALL_OW 380
// eng := CreateHuman ;
4255: LD_ADDR_VAR 0 2
4259: PUSH
4260: CALL_OW 44
4264: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4265: LD_VAR 0 2
4269: PPUSH
4270: LD_INT 102
4272: PPUSH
4273: LD_INT 8
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_INT 110
4290: PPUSH
4291: LD_INT 60
4293: PPUSH
4294: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4298: LD_ADDR_EXP 37
4302: PUSH
4303: LD_EXP 37
4307: PUSH
4308: LD_VAR 0 2
4312: UNION
4313: ST_TO_ADDR
// end else
4314: GO 4478
// begin for i in eng do
4316: LD_ADDR_VAR 0 1
4320: PUSH
4321: LD_VAR 0 2
4325: PUSH
4326: FOR_IN
4327: IFFALSE 4476
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4329: LD_INT 10
4331: PPUSH
4332: LD_INT 1
4334: PPUSH
4335: CALL_OW 287
4339: IFFALSE 4390
// begin if IsInUnit ( i ) then
4341: LD_VAR 0 1
4345: PPUSH
4346: CALL_OW 310
4350: IFFALSE 4361
// ComExitBuilding ( i ) ;
4352: LD_VAR 0 1
4356: PPUSH
4357: CALL_OW 122
// if not IsInArea ( i , collectFarmerArea ) then
4361: LD_VAR 0 1
4365: PPUSH
4366: LD_INT 10
4368: PPUSH
4369: CALL_OW 308
4373: NOT
4374: IFFALSE 4388
// AddComMoveToArea ( i , collectFarmerArea ) ;
4376: LD_VAR 0 1
4380: PPUSH
4381: LD_INT 10
4383: PPUSH
4384: CALL_OW 173
// end else
4388: GO 4474
// begin if damagedBuilding then
4390: LD_VAR 0 5
4394: IFFALSE 4438
// begin if IsInUnit ( i ) then
4396: LD_VAR 0 1
4400: PPUSH
4401: CALL_OW 310
4405: IFFALSE 4418
// ComExitBuilding ( i ) else
4407: LD_VAR 0 1
4411: PPUSH
4412: CALL_OW 122
4416: GO 4436
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4418: LD_VAR 0 1
4422: PPUSH
4423: LD_VAR 0 5
4427: PUSH
4428: LD_INT 1
4430: ARRAY
4431: PPUSH
4432: CALL_OW 130
// end else
4436: GO 4474
// if not IsInUnit ( i ) and not HasTask ( i ) then
4438: LD_VAR 0 1
4442: PPUSH
4443: CALL_OW 310
4447: NOT
4448: PUSH
4449: LD_VAR 0 1
4453: PPUSH
4454: CALL_OW 314
4458: NOT
4459: AND
4460: IFFALSE 4474
// ComEnterUnit ( i , arDepot ) ;
4462: LD_VAR 0 1
4466: PPUSH
4467: LD_INT 5
4469: PPUSH
4470: CALL_OW 120
// end ; end ;
4474: GO 4326
4476: POP
4477: POP
// end ; end ;
4478: PPOPN 5
4480: END
// export function StartCargoEvacuation ; begin
4481: LD_INT 0
4483: PPUSH
// while omarCargoCounter > 0 do
4484: LD_EXP 19
4488: PUSH
4489: LD_INT 0
4491: GREATER
4492: IFFALSE 4809
// begin wait ( 0 0$40 ) ;
4494: LD_INT 1400
4496: PPUSH
4497: CALL_OW 67
// omarCargo := PrepareCargo ;
4501: LD_ADDR_EXP 41
4505: PUSH
4506: CALL 4814 0 0
4510: ST_TO_ADDR
// SetTag ( omarCargo , 0 ) ;
4511: LD_EXP 41
4515: PPUSH
4516: LD_INT 0
4518: PPUSH
4519: CALL_OW 109
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4523: LD_EXP 41
4527: PPUSH
4528: LD_INT 107
4530: PPUSH
4531: LD_INT 59
4533: PPUSH
4534: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4538: LD_INT 35
4540: PPUSH
4541: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4545: LD_EXP 41
4549: PPUSH
4550: LD_INT 107
4552: PPUSH
4553: LD_INT 59
4555: PPUSH
4556: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4560: LD_EXP 41
4564: PPUSH
4565: CALL_OW 302
4569: NOT
4570: PUSH
4571: LD_EXP 41
4575: PPUSH
4576: CALL_OW 301
4580: OR
4581: IFFALSE 4585
// continue ;
4583: GO 4538
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4585: LD_EXP 41
4589: PPUSH
4590: LD_INT 107
4592: PPUSH
4593: LD_INT 59
4595: PPUSH
4596: CALL_OW 307
4600: PUSH
4601: LD_EXP 41
4605: PPUSH
4606: LD_INT 5
4608: PPUSH
4609: CALL_OW 296
4613: PUSH
4614: LD_INT 6
4616: LESS
4617: OR
4618: IFFALSE 4538
// SetTag ( omarCargo , 1 ) ;
4620: LD_EXP 41
4624: PPUSH
4625: LD_INT 1
4627: PPUSH
4628: CALL_OW 109
// wait ( 0 0$05 ) ;
4632: LD_INT 175
4634: PPUSH
4635: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4639: LD_EXP 41
4643: PPUSH
4644: LD_INT 5
4646: PPUSH
4647: LD_INT 1
4649: PPUSH
4650: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4654: LD_EXP 41
4658: PPUSH
4659: LD_INT 103
4661: PPUSH
4662: LD_INT 9
4664: PPUSH
4665: CALL_OW 171
// wait ( 0 0$1 ) ;
4669: LD_INT 35
4671: PPUSH
4672: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
4676: LD_EXP 41
4680: PPUSH
4681: LD_INT 1
4683: PPUSH
4684: LD_INT 100
4686: PPUSH
4687: CALL_OW 290
// repeat wait ( 0 0$1 ) ;
4691: LD_INT 35
4693: PPUSH
4694: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4698: LD_EXP 41
4702: PPUSH
4703: LD_INT 103
4705: PPUSH
4706: LD_INT 9
4708: PPUSH
4709: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4713: LD_EXP 41
4717: PPUSH
4718: CALL_OW 302
4722: NOT
4723: PUSH
4724: LD_EXP 41
4728: PPUSH
4729: CALL_OW 301
4733: OR
4734: IFFALSE 4738
// continue ;
4736: GO 4691
// until ( IsAt ( omarCargo , 103 , 9 ) or IsInArea ( omarCargo , northRoad ) ) and GetTag ( omarCargo ) > 0 ;
4738: LD_EXP 41
4742: PPUSH
4743: LD_INT 103
4745: PPUSH
4746: LD_INT 9
4748: PPUSH
4749: CALL_OW 307
4753: PUSH
4754: LD_EXP 41
4758: PPUSH
4759: LD_INT 3
4761: PPUSH
4762: CALL_OW 308
4766: OR
4767: PUSH
4768: LD_EXP 41
4772: PPUSH
4773: CALL_OW 110
4777: PUSH
4778: LD_INT 0
4780: GREATER
4781: AND
4782: IFFALSE 4691
// RemoveUnit ( omarCargo ) ;
4784: LD_EXP 41
4788: PPUSH
4789: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4793: LD_ADDR_EXP 19
4797: PUSH
4798: LD_EXP 19
4802: PUSH
4803: LD_INT 1
4805: MINUS
4806: ST_TO_ADDR
// end ;
4807: GO 4484
// end ;
4809: LD_VAR 0 1
4813: RET
// export function PrepareCargo ; var un , veh ; begin
4814: LD_INT 0
4816: PPUSH
4817: PPUSH
4818: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4819: LD_ADDR_VAR 0 3
4823: PUSH
4824: LD_INT 5
4826: PPUSH
4827: LD_INT 2
4829: PPUSH
4830: LD_INT 13
4832: PPUSH
4833: LD_INT 1
4835: PPUSH
4836: LD_INT 1
4838: PPUSH
4839: LD_INT 32
4841: PPUSH
4842: LD_INT 80
4844: PPUSH
4845: CALL 360 0 7
4849: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4850: LD_VAR 0 3
4854: PPUSH
4855: LD_INT 4
4857: PPUSH
4858: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4862: LD_VAR 0 3
4866: PPUSH
4867: LD_INT 101
4869: PPUSH
4870: LD_INT 8
4872: PPUSH
4873: LD_INT 0
4875: PPUSH
4876: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4880: LD_INT 0
4882: PPUSH
4883: LD_INT 3
4885: PPUSH
4886: LD_INT 2
4888: PPUSH
4889: CALL_OW 380
// un := CreateHuman ;
4893: LD_ADDR_VAR 0 2
4897: PUSH
4898: CALL_OW 44
4902: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4903: LD_VAR 0 2
4907: PPUSH
4908: LD_VAR 0 3
4912: PPUSH
4913: CALL_OW 52
// result := veh ;
4917: LD_ADDR_VAR 0 1
4921: PUSH
4922: LD_VAR 0 3
4926: ST_TO_ADDR
// end ; end_of_file
4927: LD_VAR 0 1
4931: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
4932: LD_INT 0
4934: PPUSH
4935: PPUSH
4936: PPUSH
// usForces := [ ] ;
4937: LD_ADDR_EXP 42
4941: PUSH
4942: EMPTY
4943: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
4944: LD_ADDR_EXP 44
4948: PUSH
4949: LD_INT 6
4951: PUSH
4952: LD_INT 32
4954: PUSH
4955: LD_INT 27
4957: PUSH
4958: LD_INT 1
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: LIST
4965: LIST
4966: PUSH
4967: LD_INT 4
4969: PUSH
4970: LD_INT 43
4972: PUSH
4973: LD_INT 24
4975: PUSH
4976: LD_INT 5
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: LIST
4983: LIST
4984: PUSH
4985: LD_INT 27
4987: PUSH
4988: LD_INT 29
4990: PUSH
4991: LD_INT 21
4993: PUSH
4994: LD_INT 0
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: LIST
5007: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
5008: LD_INT 11
5010: PPUSH
5011: CALL_OW 274
5015: PPUSH
5016: LD_INT 1
5018: PPUSH
5019: LD_INT 150
5021: PUSH
5022: LD_INT 120
5024: PUSH
5025: LD_INT 100
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: LIST
5032: PUSH
5033: LD_OWVAR 67
5037: ARRAY
5038: PPUSH
5039: CALL_OW 277
// if Difficulty = 1 then
5043: LD_OWVAR 67
5047: PUSH
5048: LD_INT 1
5050: EQUAL
5051: IFFALSE 5060
// RemoveUnit ( hillBun ) ;
5053: LD_INT 14
5055: PPUSH
5056: CALL_OW 64
// uc_side := 1 ;
5060: LD_ADDR_OWVAR 20
5064: PUSH
5065: LD_INT 1
5067: ST_TO_ADDR
// uc_nation := 1 ;
5068: LD_ADDR_OWVAR 21
5072: PUSH
5073: LD_INT 1
5075: ST_TO_ADDR
// hc_gallery :=  ;
5076: LD_ADDR_OWVAR 33
5080: PUSH
5081: LD_STRING 
5083: ST_TO_ADDR
// hc_name :=  ;
5084: LD_ADDR_OWVAR 26
5088: PUSH
5089: LD_STRING 
5091: ST_TO_ADDR
// hc_importance := 0 ;
5092: LD_ADDR_OWVAR 32
5096: PUSH
5097: LD_INT 0
5099: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5100: LD_INT 1
5102: PPUSH
5103: LD_INT 1
5105: PPUSH
5106: LD_INT 3
5108: PPUSH
5109: CALL_OW 380
// usCommander := CreateHuman ;
5113: LD_ADDR_EXP 43
5117: PUSH
5118: CALL_OW 44
5122: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5123: LD_EXP 43
5127: PPUSH
5128: LD_INT 11
5130: PPUSH
5131: CALL_OW 52
// if Difficulty > 1 then
5135: LD_OWVAR 67
5139: PUSH
5140: LD_INT 1
5142: GREATER
5143: IFFALSE 5225
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5145: LD_INT 0
5147: PPUSH
5148: LD_INT 1
5150: PPUSH
5151: LD_INT 1
5153: PUSH
5154: LD_INT 2
5156: PUSH
5157: LD_INT 3
5159: PUSH
5160: EMPTY
5161: LIST
5162: LIST
5163: LIST
5164: PUSH
5165: LD_OWVAR 67
5169: ARRAY
5170: PPUSH
5171: CALL_OW 380
// un := CreateHuman ;
5175: LD_ADDR_VAR 0 3
5179: PUSH
5180: CALL_OW 44
5184: ST_TO_ADDR
// usForces := usForces union un ;
5185: LD_ADDR_EXP 42
5189: PUSH
5190: LD_EXP 42
5194: PUSH
5195: LD_VAR 0 3
5199: UNION
5200: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5201: LD_VAR 0 3
5205: PPUSH
5206: LD_INT 1
5208: PPUSH
5209: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5213: LD_VAR 0 3
5217: PPUSH
5218: LD_INT 14
5220: PPUSH
5221: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5225: LD_ADDR_VAR 0 2
5229: PUSH
5230: DOUBLE
5231: LD_INT 1
5233: DEC
5234: ST_TO_ADDR
5235: LD_INT 2
5237: PUSH
5238: LD_INT 3
5240: PUSH
5241: LD_INT 4
5243: PUSH
5244: EMPTY
5245: LIST
5246: LIST
5247: LIST
5248: PUSH
5249: LD_OWVAR 67
5253: ARRAY
5254: PUSH
5255: FOR_TO
5256: IFFALSE 5398
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5258: LD_INT 0
5260: PPUSH
5261: LD_INT 1
5263: PPUSH
5264: LD_INT 1
5266: PUSH
5267: LD_INT 2
5269: PUSH
5270: LD_INT 3
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: PUSH
5278: LD_OWVAR 67
5282: ARRAY
5283: PPUSH
5284: CALL_OW 380
// un := CreateHuman ;
5288: LD_ADDR_VAR 0 3
5292: PUSH
5293: CALL_OW 44
5297: ST_TO_ADDR
// usForces := usForces union un ;
5298: LD_ADDR_EXP 42
5302: PUSH
5303: LD_EXP 42
5307: PUSH
5308: LD_VAR 0 3
5312: UNION
5313: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5314: LD_VAR 0 3
5318: PPUSH
5319: LD_INT 39
5321: PPUSH
5322: LD_INT 24
5324: PPUSH
5325: LD_INT 4
5327: PPUSH
5328: LD_INT 0
5330: PPUSH
5331: CALL_OW 50
// if i < 3 then
5335: LD_VAR 0 2
5339: PUSH
5340: LD_INT 3
5342: LESS
5343: IFFALSE 5396
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5345: LD_VAR 0 3
5349: PPUSH
5350: LD_INT 22
5352: PUSH
5353: LD_INT 1
5355: PUSH
5356: EMPTY
5357: LIST
5358: LIST
5359: PUSH
5360: LD_INT 58
5362: PUSH
5363: EMPTY
5364: LIST
5365: PUSH
5366: LD_INT 30
5368: PUSH
5369: LD_INT 31
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: PUSH
5376: EMPTY
5377: LIST
5378: LIST
5379: LIST
5380: PPUSH
5381: CALL_OW 69
5385: PUSH
5386: LD_VAR 0 2
5390: ARRAY
5391: PPUSH
5392: CALL_OW 120
// end ;
5396: GO 5255
5398: POP
5399: POP
// for i := 1 to 2 do
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: DOUBLE
5406: LD_INT 1
5408: DEC
5409: ST_TO_ADDR
5410: LD_INT 2
5412: PUSH
5413: FOR_TO
5414: IFFALSE 5478
// begin PrepareHuman ( false , 2 , 2 ) ;
5416: LD_INT 0
5418: PPUSH
5419: LD_INT 2
5421: PPUSH
5422: LD_INT 2
5424: PPUSH
5425: CALL_OW 380
// un := CreateHuman ;
5429: LD_ADDR_VAR 0 3
5433: PUSH
5434: CALL_OW 44
5438: ST_TO_ADDR
// usForces := usForces union un ;
5439: LD_ADDR_EXP 42
5443: PUSH
5444: LD_EXP 42
5448: PUSH
5449: LD_VAR 0 3
5453: UNION
5454: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5455: LD_VAR 0 3
5459: PPUSH
5460: LD_INT 39
5462: PPUSH
5463: LD_INT 24
5465: PPUSH
5466: LD_INT 4
5468: PPUSH
5469: LD_INT 0
5471: PPUSH
5472: CALL_OW 50
// end ;
5476: GO 5413
5478: POP
5479: POP
// PrepareHuman ( false , 4 , 1 ) ;
5480: LD_INT 0
5482: PPUSH
5483: LD_INT 4
5485: PPUSH
5486: LD_INT 1
5488: PPUSH
5489: CALL_OW 380
// un := CreateHuman ;
5493: LD_ADDR_VAR 0 3
5497: PUSH
5498: CALL_OW 44
5502: ST_TO_ADDR
// usForces := usForces union un ;
5503: LD_ADDR_EXP 42
5507: PUSH
5508: LD_EXP 42
5512: PUSH
5513: LD_VAR 0 3
5517: UNION
5518: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5519: LD_VAR 0 3
5523: PPUSH
5524: LD_INT 39
5526: PPUSH
5527: LD_INT 24
5529: PPUSH
5530: LD_INT 4
5532: PPUSH
5533: LD_INT 0
5535: PPUSH
5536: CALL_OW 50
// end ;
5540: LD_VAR 0 1
5544: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
5545: LD_EXP 42
5549: PUSH
5550: LD_EXP 6
5554: NOT
5555: AND
5556: IFFALSE 5987
5558: GO 5560
5560: DISABLE
5561: LD_INT 0
5563: PPUSH
5564: PPUSH
5565: PPUSH
5566: PPUSH
5567: PPUSH
// begin enable ;
5568: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5569: LD_ADDR_VAR 0 3
5573: PUSH
5574: LD_EXP 42
5578: PPUSH
5579: LD_INT 25
5581: PUSH
5582: LD_INT 2
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: PPUSH
5589: CALL_OW 72
5593: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5594: LD_ADDR_VAR 0 4
5598: PUSH
5599: LD_EXP 42
5603: PPUSH
5604: LD_INT 25
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 72
5618: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5619: LD_ADDR_VAR 0 5
5623: PUSH
5624: LD_EXP 42
5628: PPUSH
5629: LD_INT 25
5631: PUSH
5632: LD_INT 4
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: PPUSH
5639: CALL_OW 72
5643: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5644: LD_INT 7
5646: PPUSH
5647: LD_INT 22
5649: PUSH
5650: LD_INT 2
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: PPUSH
5657: CALL_OW 70
5661: PUSH
5662: LD_INT 1
5664: EQUAL
5665: IFFALSE 5741
// for i in sol do
5667: LD_ADDR_VAR 0 1
5671: PUSH
5672: LD_VAR 0 4
5676: PUSH
5677: FOR_IN
5678: IFFALSE 5739
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5680: LD_VAR 0 1
5684: PPUSH
5685: CALL_OW 310
5689: NOT
5690: PUSH
5691: LD_VAR 0 1
5695: PPUSH
5696: CALL_OW 310
5700: PPUSH
5701: CALL_OW 266
5705: PUSH
5706: LD_INT 4
5708: EQUAL
5709: NOT
5710: OR
5711: IFFALSE 5737
// begin ComExitBuilding ( i ) ;
5713: LD_VAR 0 1
5717: PPUSH
5718: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5722: LD_VAR 0 1
5726: PPUSH
5727: LD_INT 37
5729: PPUSH
5730: LD_INT 23
5732: PPUSH
5733: CALL_OW 174
// end ;
5737: GO 5677
5739: POP
5740: POP
// if eng then
5741: LD_VAR 0 3
5745: IFFALSE 5987
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5747: LD_ADDR_VAR 0 2
5751: PUSH
5752: LD_INT 22
5754: PUSH
5755: LD_INT 1
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 95
5764: PUSH
5765: LD_INT 7
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: PUSH
5772: LD_INT 21
5774: PUSH
5775: LD_INT 3
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: PUSH
5782: LD_INT 3
5784: PUSH
5785: LD_INT 24
5787: PUSH
5788: LD_INT 1000
5790: PUSH
5791: EMPTY
5792: LIST
5793: LIST
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: PUSH
5799: EMPTY
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: PPUSH
5805: CALL_OW 69
5809: ST_TO_ADDR
// if b then
5810: LD_VAR 0 2
5814: IFFALSE 5845
// begin ComExitBuilding ( eng ) ;
5816: LD_VAR 0 3
5820: PPUSH
5821: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5825: LD_VAR 0 3
5829: PPUSH
5830: LD_VAR 0 2
5834: PUSH
5835: LD_INT 1
5837: ARRAY
5838: PPUSH
5839: CALL_OW 190
// end else
5843: GO 5987
// begin for i in eng do
5845: LD_ADDR_VAR 0 1
5849: PUSH
5850: LD_VAR 0 3
5854: PUSH
5855: FOR_IN
5856: IFFALSE 5985
// if not HasTask ( i ) then
5858: LD_VAR 0 1
5862: PPUSH
5863: CALL_OW 314
5867: NOT
5868: IFFALSE 5983
// begin if americanBuildList then
5870: LD_EXP 44
5874: IFFALSE 5959
// begin if IsInUnit ( i ) then
5876: LD_VAR 0 1
5880: PPUSH
5881: CALL_OW 310
5885: IFFALSE 5896
// ComExitBuilding ( i ) ;
5887: LD_VAR 0 1
5891: PPUSH
5892: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5896: LD_VAR 0 1
5900: PPUSH
5901: LD_EXP 44
5905: PUSH
5906: LD_INT 1
5908: ARRAY
5909: PUSH
5910: LD_INT 1
5912: ARRAY
5913: PPUSH
5914: LD_EXP 44
5918: PUSH
5919: LD_INT 1
5921: ARRAY
5922: PUSH
5923: LD_INT 2
5925: ARRAY
5926: PPUSH
5927: LD_EXP 44
5931: PUSH
5932: LD_INT 1
5934: ARRAY
5935: PUSH
5936: LD_INT 3
5938: ARRAY
5939: PPUSH
5940: LD_EXP 44
5944: PUSH
5945: LD_INT 1
5947: ARRAY
5948: PUSH
5949: LD_INT 4
5951: ARRAY
5952: PPUSH
5953: CALL_OW 205
// end else
5957: GO 5983
// if not IsInUnit ( i ) then
5959: LD_VAR 0 1
5963: PPUSH
5964: CALL_OW 310
5968: NOT
5969: IFFALSE 5983
// ComEnterUnit ( i , usDepot ) ;
5971: LD_VAR 0 1
5975: PPUSH
5976: LD_INT 11
5978: PPUSH
5979: CALL_OW 120
// end ;
5983: GO 5855
5985: POP
5986: POP
// end ; end ; end ;
5987: PPOPN 5
5989: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
5990: LD_INT 0
5992: PPUSH
5993: PPUSH
5994: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
5995: LD_ADDR_VAR 0 3
5999: PUSH
6000: LD_INT 35
6002: PUSH
6003: LD_INT 45
6005: PUSH
6006: LD_INT 48
6008: PUSH
6009: LD_EXP 54
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: ST_TO_ADDR
// for i in tech do
6020: LD_ADDR_VAR 0 4
6024: PUSH
6025: LD_VAR 0 3
6029: PUSH
6030: FOR_IN
6031: IFFALSE 6049
// AddComResearch ( lab , i ) ;
6033: LD_VAR 0 1
6037: PPUSH
6038: LD_VAR 0 4
6042: PPUSH
6043: CALL_OW 184
6047: GO 6030
6049: POP
6050: POP
// end ;
6051: LD_VAR 0 2
6055: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
6056: LD_EXP 11
6060: PUSH
6061: LD_EXP 21
6065: PUSH
6066: LD_EXP 25
6070: LESSEQUAL
6071: AND
6072: IFFALSE 6097
6074: GO 6076
6076: DISABLE
// begin enable ;
6077: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6078: LD_INT 35
6080: PPUSH
6081: LD_INT 2065
6083: PPUSH
6084: CALL_OW 12
6088: PPUSH
6089: CALL_OW 67
// SendConvoy ;
6093: CALL 6195 0 0
// end ;
6097: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6098: LD_EXP 6
6102: PUSH
6103: LD_EXP 16
6107: AND
6108: IFFALSE 6194
6110: GO 6112
6112: DISABLE
// begin if americanHasEscaped then
6113: LD_EXP 7
6117: IFFALSE 6128
// wait ( 3 3$20 ) else
6119: LD_INT 7000
6121: PPUSH
6122: CALL_OW 67
6126: GO 6135
// wait ( 6 6$40 ) ;
6128: LD_INT 14000
6130: PPUSH
6131: CALL_OW 67
// SendAttack ;
6135: CALL 6938 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6139: LD_INT 14000
6141: PUSH
6142: LD_INT 11900
6144: PUSH
6145: LD_INT 9800
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: LIST
6152: PUSH
6153: LD_OWVAR 67
6157: ARRAY
6158: PPUSH
6159: CALL_OW 67
// SendAttack ;
6163: CALL 6938 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6167: LD_EXP 17
6171: PUSH
6172: LD_INT 6
6174: PUSH
6175: LD_INT 7
6177: PUSH
6178: LD_INT 8
6180: PUSH
6181: EMPTY
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_OWVAR 67
6190: ARRAY
6191: LESS
6192: IFFALSE 6139
// end ;
6194: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6195: LD_INT 0
6197: PPUSH
6198: PPUSH
6199: PPUSH
6200: PPUSH
6201: PPUSH
6202: PPUSH
6203: PPUSH
6204: PPUSH
// road := rand ( 1 , 2 ) ;
6205: LD_ADDR_VAR 0 4
6209: PUSH
6210: LD_INT 1
6212: PPUSH
6213: LD_INT 2
6215: PPUSH
6216: CALL_OW 12
6220: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6221: LD_ADDR_VAR 0 8
6225: PUSH
6226: LD_INT 3
6228: PUSH
6229: LD_INT 8
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_VAR 0 4
6240: ARRAY
6241: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6242: LD_ADDR_VAR 0 5
6246: PUSH
6247: LD_INT 35
6249: PUSH
6250: LD_INT 66
6252: PUSH
6253: LD_INT 1
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: PUSH
6261: LD_INT 101
6263: PUSH
6264: LD_INT 8
6266: PUSH
6267: LD_INT 4
6269: PUSH
6270: EMPTY
6271: LIST
6272: LIST
6273: LIST
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6279: LD_ADDR_VAR 0 6
6283: PUSH
6284: LD_INT 34
6286: PUSH
6287: LD_INT 67
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 38
6296: PUSH
6297: LD_INT 62
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 43
6306: PUSH
6307: LD_INT 54
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PUSH
6314: LD_INT 57
6316: PUSH
6317: LD_INT 57
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: PUSH
6324: LD_INT 77
6326: PUSH
6327: LD_INT 71
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PUSH
6334: LD_INT 86
6336: PUSH
6337: LD_INT 60
6339: PUSH
6340: EMPTY
6341: LIST
6342: LIST
6343: PUSH
6344: LD_INT 89
6346: PUSH
6347: LD_INT 35
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: PUSH
6354: LD_INT 93
6356: PUSH
6357: LD_INT 17
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 97
6366: PUSH
6367: LD_INT 10
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PUSH
6374: LD_INT 103
6376: PUSH
6377: LD_INT 9
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: LIST
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: LIST
6394: LIST
6395: ST_TO_ADDR
// if road = 2 then
6396: LD_VAR 0 4
6400: PUSH
6401: LD_INT 2
6403: EQUAL
6404: IFFALSE 6421
// points := ReverseArray ( points ) ;
6406: LD_ADDR_VAR 0 6
6410: PUSH
6411: LD_VAR 0 6
6415: PPUSH
6416: CALL 1048 0 1
6420: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6421: LD_INT 4
6423: PPUSH
6424: LD_INT 1
6426: PPUSH
6427: LD_INT 2
6429: PPUSH
6430: LD_INT 1
6432: PPUSH
6433: LD_INT 1
6435: PPUSH
6436: LD_INT 12
6438: PPUSH
6439: LD_INT 80
6441: PPUSH
6442: CALL 360 0 7
// veh := CreateVehicle ;
6446: LD_ADDR_VAR 0 3
6450: PUSH
6451: CALL_OW 45
6455: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6456: LD_VAR 0 3
6460: PPUSH
6461: LD_VAR 0 5
6465: PUSH
6466: LD_VAR 0 4
6470: ARRAY
6471: PUSH
6472: LD_INT 3
6474: ARRAY
6475: PPUSH
6476: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6480: LD_VAR 0 3
6484: PPUSH
6485: LD_VAR 0 5
6489: PUSH
6490: LD_VAR 0 4
6494: ARRAY
6495: PUSH
6496: LD_INT 1
6498: ARRAY
6499: PPUSH
6500: LD_VAR 0 5
6504: PUSH
6505: LD_VAR 0 4
6509: ARRAY
6510: PUSH
6511: LD_INT 2
6513: ARRAY
6514: PPUSH
6515: LD_INT 0
6517: PPUSH
6518: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6522: LD_INT 0
6524: PPUSH
6525: LD_INT 1
6527: PPUSH
6528: LD_OWVAR 67
6532: PPUSH
6533: CALL_OW 380
// un := CreateHuman ;
6537: LD_ADDR_VAR 0 2
6541: PUSH
6542: CALL_OW 44
6546: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6547: LD_VAR 0 2
6551: PPUSH
6552: LD_VAR 0 3
6556: PPUSH
6557: CALL_OW 52
// if ( Prob ( [ 60 , 56 , 52 ] [ Difficulty ] ) + tick mod 30 ) or convoyCounter < 4 then
6561: LD_INT 60
6563: PUSH
6564: LD_INT 56
6566: PUSH
6567: LD_INT 52
6569: PUSH
6570: EMPTY
6571: LIST
6572: LIST
6573: LIST
6574: PUSH
6575: LD_OWVAR 67
6579: ARRAY
6580: PPUSH
6581: CALL_OW 13
6585: PUSH
6586: LD_OWVAR 1
6590: PUSH
6591: LD_INT 30
6593: MOD
6594: PLUS
6595: PUSH
6596: LD_EXP 21
6600: PUSH
6601: LD_INT 4
6603: LESS
6604: OR
6605: IFFALSE 6622
// SetCargo ( veh , mat_cans , 100 ) ;
6607: LD_VAR 0 3
6611: PPUSH
6612: LD_INT 1
6614: PPUSH
6615: LD_INT 100
6617: PPUSH
6618: CALL_OW 290
// for i := 2 to points do
6622: LD_ADDR_VAR 0 7
6626: PUSH
6627: DOUBLE
6628: LD_INT 2
6630: DEC
6631: ST_TO_ADDR
6632: LD_VAR 0 6
6636: PUSH
6637: FOR_TO
6638: IFFALSE 6681
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6640: LD_VAR 0 3
6644: PPUSH
6645: LD_VAR 0 6
6649: PUSH
6650: LD_VAR 0 7
6654: ARRAY
6655: PUSH
6656: LD_INT 1
6658: ARRAY
6659: PPUSH
6660: LD_VAR 0 6
6664: PUSH
6665: LD_VAR 0 7
6669: ARRAY
6670: PUSH
6671: LD_INT 2
6673: ARRAY
6674: PPUSH
6675: CALL_OW 171
6679: GO 6637
6681: POP
6682: POP
// convoyCounter := convoyCounter + 1 ;
6683: LD_ADDR_EXP 21
6687: PUSH
6688: LD_EXP 21
6692: PUSH
6693: LD_INT 1
6695: PLUS
6696: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6697: LD_INT 35
6699: PPUSH
6700: CALL_OW 67
// if not HasTask ( veh ) and IsOk ( veh ) then
6704: LD_VAR 0 3
6708: PPUSH
6709: CALL_OW 314
6713: NOT
6714: PUSH
6715: LD_VAR 0 3
6719: PPUSH
6720: CALL_OW 302
6724: AND
6725: IFFALSE 6766
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6727: LD_VAR 0 3
6731: PPUSH
6732: LD_VAR 0 6
6736: PUSH
6737: LD_VAR 0 6
6741: ARRAY
6742: PUSH
6743: LD_INT 1
6745: ARRAY
6746: PPUSH
6747: LD_VAR 0 6
6751: PUSH
6752: LD_VAR 0 6
6756: ARRAY
6757: PUSH
6758: LD_INT 2
6760: ARRAY
6761: PPUSH
6762: CALL_OW 111
// if not IsInUnit ( un ) then
6766: LD_VAR 0 2
6770: PPUSH
6771: CALL_OW 310
6775: NOT
6776: IFFALSE 6817
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6778: LD_VAR 0 2
6782: PPUSH
6783: LD_VAR 0 6
6787: PUSH
6788: LD_VAR 0 6
6792: ARRAY
6793: PUSH
6794: LD_INT 1
6796: ARRAY
6797: PPUSH
6798: LD_VAR 0 6
6802: PUSH
6803: LD_VAR 0 6
6807: ARRAY
6808: PUSH
6809: LD_INT 2
6811: ARRAY
6812: PPUSH
6813: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6817: LD_VAR 0 3
6821: PPUSH
6822: LD_VAR 0 8
6826: PPUSH
6827: CALL_OW 308
6831: PUSH
6832: LD_VAR 0 2
6836: PPUSH
6837: LD_VAR 0 8
6841: PPUSH
6842: CALL_OW 308
6846: OR
6847: IFFALSE 6697
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6849: LD_VAR 0 2
6853: PPUSH
6854: CALL_OW 302
6858: PUSH
6859: LD_VAR 0 3
6863: PPUSH
6864: CALL_OW 302
6868: NOT
6869: AND
6870: PUSH
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_VAR 0 8
6880: PPUSH
6881: CALL_OW 308
6885: AND
6886: IFFALSE 6897
// RemoveUnit ( un ) ;
6888: LD_VAR 0 2
6892: PPUSH
6893: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6897: LD_VAR 0 3
6901: PPUSH
6902: LD_VAR 0 8
6906: PPUSH
6907: CALL_OW 308
6911: PUSH
6912: LD_VAR 0 3
6916: PPUSH
6917: CALL_OW 302
6921: AND
6922: IFFALSE 6933
// RemoveUnit ( veh ) ;
6924: LD_VAR 0 3
6928: PPUSH
6929: CALL_OW 64
// end ;
6933: LD_VAR 0 1
6937: RET
// export function SendAttack ; var un , veh , i ; begin
6938: LD_INT 0
6940: PPUSH
6941: PPUSH
6942: PPUSH
6943: PPUSH
// IncomingAttack ;
6944: CALL 15413 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
6948: LD_INT 2100
6950: PPUSH
6951: LD_INT 3500
6953: PPUSH
6954: CALL_OW 12
6958: PPUSH
6959: CALL_OW 67
// for i := 1 to [ 3 , 3 , 4 ] [ Difficulty ] + attackWave div 3 do
6963: LD_ADDR_VAR 0 4
6967: PUSH
6968: DOUBLE
6969: LD_INT 1
6971: DEC
6972: ST_TO_ADDR
6973: LD_INT 3
6975: PUSH
6976: LD_INT 3
6978: PUSH
6979: LD_INT 4
6981: PUSH
6982: EMPTY
6983: LIST
6984: LIST
6985: LIST
6986: PUSH
6987: LD_OWVAR 67
6991: ARRAY
6992: PUSH
6993: LD_EXP 17
6997: PUSH
6998: LD_INT 3
7000: DIV
7001: PLUS
7002: PUSH
7003: FOR_TO
7004: IFFALSE 7116
// begin uc_side := 1 ;
7006: LD_ADDR_OWVAR 20
7010: PUSH
7011: LD_INT 1
7013: ST_TO_ADDR
// uc_nation := 1 ;
7014: LD_ADDR_OWVAR 21
7018: PUSH
7019: LD_INT 1
7021: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
7022: LD_INT 0
7024: PPUSH
7025: LD_INT 1
7027: PPUSH
7028: LD_INT 2
7030: PUSH
7031: LD_INT 3
7033: PUSH
7034: LD_INT 4
7036: PUSH
7037: EMPTY
7038: LIST
7039: LIST
7040: LIST
7041: PUSH
7042: LD_OWVAR 67
7046: ARRAY
7047: PPUSH
7048: CALL_OW 380
// un := CreateHuman ;
7052: LD_ADDR_VAR 0 2
7056: PUSH
7057: CALL_OW 44
7061: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7062: LD_VAR 0 2
7066: PPUSH
7067: LD_INT 37
7069: PPUSH
7070: LD_INT 70
7072: PPUSH
7073: LD_INT 3
7075: PPUSH
7076: LD_INT 0
7078: PPUSH
7079: CALL_OW 50
// usAttackers := usAttackers union un ;
7083: LD_ADDR_EXP 45
7087: PUSH
7088: LD_EXP 45
7092: PUSH
7093: LD_VAR 0 2
7097: UNION
7098: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7099: LD_VAR 0 2
7103: PPUSH
7104: LD_INT 40
7106: PPUSH
7107: LD_INT 65
7109: PPUSH
7110: CALL_OW 111
// end ;
7114: GO 7003
7116: POP
7117: POP
// uc_side := 1 ;
7118: LD_ADDR_OWVAR 20
7122: PUSH
7123: LD_INT 1
7125: ST_TO_ADDR
// uc_nation := 1 ;
7126: LD_ADDR_OWVAR 21
7130: PUSH
7131: LD_INT 1
7133: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7134: LD_INT 0
7136: PPUSH
7137: LD_INT 4
7139: PPUSH
7140: LD_INT 2
7142: PPUSH
7143: CALL_OW 380
// un := CreateHuman ;
7147: LD_ADDR_VAR 0 2
7151: PUSH
7152: CALL_OW 44
7156: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7157: LD_VAR 0 2
7161: PPUSH
7162: LD_INT 37
7164: PPUSH
7165: LD_INT 70
7167: PPUSH
7168: LD_INT 3
7170: PPUSH
7171: LD_INT 0
7173: PPUSH
7174: CALL_OW 50
// usAttackers := usAttackers union un ;
7178: LD_ADDR_EXP 45
7182: PUSH
7183: LD_EXP 45
7187: PUSH
7188: LD_VAR 0 2
7192: UNION
7193: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7194: LD_VAR 0 2
7198: PPUSH
7199: LD_INT 40
7201: PPUSH
7202: LD_INT 65
7204: PPUSH
7205: CALL_OW 111
// if attackWave > 1 or Difficulty > 1 then
7209: LD_EXP 17
7213: PUSH
7214: LD_INT 1
7216: GREATER
7217: PUSH
7218: LD_OWVAR 67
7222: PUSH
7223: LD_INT 1
7225: GREATER
7226: OR
7227: IFFALSE 7430
// begin for i := 1 to Difficulty + attackWave div 4 do
7229: LD_ADDR_VAR 0 4
7233: PUSH
7234: DOUBLE
7235: LD_INT 1
7237: DEC
7238: ST_TO_ADDR
7239: LD_OWVAR 67
7243: PUSH
7244: LD_EXP 17
7248: PUSH
7249: LD_INT 4
7251: DIV
7252: PLUS
7253: PUSH
7254: FOR_TO
7255: IFFALSE 7428
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7257: LD_ADDR_VAR 0 3
7261: PUSH
7262: LD_INT 1
7264: PPUSH
7265: LD_INT 1
7267: PPUSH
7268: LD_INT 2
7270: PPUSH
7271: LD_INT 1
7273: PPUSH
7274: LD_INT 1
7276: PPUSH
7277: LD_INT 4
7279: PUSH
7280: LD_INT 3
7282: PUSH
7283: LD_INT 2
7285: PUSH
7286: EMPTY
7287: LIST
7288: LIST
7289: LIST
7290: PUSH
7291: LD_INT 1
7293: PPUSH
7294: LD_INT 3
7296: PPUSH
7297: CALL_OW 12
7301: ARRAY
7302: PPUSH
7303: LD_INT 90
7305: PPUSH
7306: CALL 360 0 7
7310: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7311: LD_VAR 0 3
7315: PPUSH
7316: LD_INT 35
7318: PPUSH
7319: LD_INT 65
7321: PPUSH
7322: LD_INT 0
7324: PPUSH
7325: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7329: LD_INT 0
7331: PPUSH
7332: LD_INT 3
7334: PPUSH
7335: LD_OWVAR 67
7339: PUSH
7340: LD_INT 1
7342: PLUS
7343: PPUSH
7344: CALL_OW 380
// un := CreateHuman ;
7348: LD_ADDR_VAR 0 2
7352: PUSH
7353: CALL_OW 44
7357: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7358: LD_VAR 0 2
7362: PPUSH
7363: LD_VAR 0 3
7367: PPUSH
7368: CALL_OW 52
// usAttackers := usAttackers union un ;
7372: LD_ADDR_EXP 45
7376: PUSH
7377: LD_EXP 45
7381: PUSH
7382: LD_VAR 0 2
7386: UNION
7387: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7388: LD_VAR 0 3
7392: PPUSH
7393: LD_INT 39
7395: PPUSH
7396: LD_INT 60
7398: PPUSH
7399: CALL_OW 111
// wait ( 0 0$2 ) ;
7403: LD_INT 70
7405: PPUSH
7406: CALL_OW 67
// usAttackers := usAttackers union veh ;
7410: LD_ADDR_EXP 45
7414: PUSH
7415: LD_EXP 45
7419: PUSH
7420: LD_VAR 0 3
7424: UNION
7425: ST_TO_ADDR
// end ;
7426: GO 7254
7428: POP
7429: POP
// end ; attackWave := attackWave + 1 ;
7430: LD_ADDR_EXP 17
7434: PUSH
7435: LD_EXP 17
7439: PUSH
7440: LD_INT 1
7442: PLUS
7443: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7444: LD_EXP 22
7448: PPUSH
7449: CALL_OW 427
// end ;
7453: LD_VAR 0 1
7457: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7458: LD_INT 0
7460: PPUSH
7461: PPUSH
7462: PPUSH
7463: PPUSH
7464: PPUSH
7465: PPUSH
7466: PPUSH
7467: PPUSH
7468: PPUSH
7469: PPUSH
7470: PPUSH
// if retreatAllowed then
7471: LD_EXP 10
7475: IFFALSE 7487
// strategy := 2 else
7477: LD_ADDR_VAR 0 5
7481: PUSH
7482: LD_INT 2
7484: ST_TO_ADDR
7485: GO 7503
// strategy := rand ( 0 , 2 ) ;
7487: LD_ADDR_VAR 0 5
7491: PUSH
7492: LD_INT 0
7494: PPUSH
7495: LD_INT 2
7497: PPUSH
7498: CALL_OW 12
7502: ST_TO_ADDR
// attackFormula := [ ] ;
7503: LD_ADDR_VAR 0 6
7507: PUSH
7508: EMPTY
7509: ST_TO_ADDR
// case strategy of 0 :
7510: LD_VAR 0 5
7514: PUSH
7515: LD_INT 0
7517: DOUBLE
7518: EQUAL
7519: IFTRUE 7523
7521: GO 7853
7523: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7524: LD_INT 11
7526: PPUSH
7527: LD_INT 22
7529: PUSH
7530: LD_INT 2
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 30
7539: PUSH
7540: LD_INT 4
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PPUSH
7551: CALL_OW 70
7555: NOT
7556: IFFALSE 7628
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7558: LD_ADDR_VAR 0 6
7562: PUSH
7563: LD_INT 41
7565: PUSH
7566: LD_INT 34
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: PUSH
7573: EMPTY
7574: LIST
7575: PUSH
7576: LD_INT 53
7578: PUSH
7579: LD_INT 62
7581: PUSH
7582: EMPTY
7583: LIST
7584: LIST
7585: PUSH
7586: LD_INT 37
7588: PUSH
7589: LD_INT 63
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: LD_INT 44
7598: PUSH
7599: LD_INT 45
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: PUSH
7606: LD_INT 37
7608: PUSH
7609: LD_INT 28
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: PUSH
7616: EMPTY
7617: LIST
7618: LIST
7619: PUSH
7620: EMPTY
7621: LIST
7622: LIST
7623: LIST
7624: LIST
7625: ST_TO_ADDR
7626: GO 7851
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7628: LD_INT 12
7630: PPUSH
7631: LD_INT 22
7633: PUSH
7634: LD_INT 2
7636: PUSH
7637: EMPTY
7638: LIST
7639: LIST
7640: PUSH
7641: LD_INT 2
7643: PUSH
7644: LD_INT 30
7646: PUSH
7647: LD_INT 4
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: PUSH
7654: LD_INT 30
7656: PUSH
7657: LD_INT 31
7659: PUSH
7660: EMPTY
7661: LIST
7662: LIST
7663: PUSH
7664: LD_INT 30
7666: PUSH
7667: LD_INT 32
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: PPUSH
7684: CALL_OW 70
7688: NOT
7689: IFFALSE 7772
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7691: LD_ADDR_VAR 0 6
7695: PUSH
7696: LD_INT 27
7698: PUSH
7699: LD_INT 42
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: LD_INT 27
7708: PUSH
7709: LD_INT 32
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: PUSH
7720: LD_INT 53
7722: PUSH
7723: LD_INT 62
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PUSH
7730: LD_INT 37
7732: PUSH
7733: LD_INT 63
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 44
7742: PUSH
7743: LD_INT 45
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: LD_INT 37
7752: PUSH
7753: LD_INT 28
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PUSH
7760: EMPTY
7761: LIST
7762: LIST
7763: PUSH
7764: EMPTY
7765: LIST
7766: LIST
7767: LIST
7768: LIST
7769: ST_TO_ADDR
7770: GO 7851
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7772: LD_ADDR_VAR 0 6
7776: PUSH
7777: LD_INT 71
7779: PUSH
7780: LD_INT 67
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: PUSH
7787: LD_INT 54
7789: PUSH
7790: LD_INT 35
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: PUSH
7797: EMPTY
7798: LIST
7799: LIST
7800: PUSH
7801: LD_INT 63
7803: PUSH
7804: LD_INT 40
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PUSH
7811: LD_INT 37
7813: PUSH
7814: LD_INT 63
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PUSH
7821: LD_INT 44
7823: PUSH
7824: LD_INT 45
7826: PUSH
7827: EMPTY
7828: LIST
7829: LIST
7830: PUSH
7831: LD_INT 37
7833: PUSH
7834: LD_INT 28
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: LIST
7849: LIST
7850: ST_TO_ADDR
// end ; 1 :
7851: GO 8056
7853: LD_INT 1
7855: DOUBLE
7856: EQUAL
7857: IFTRUE 7861
7859: GO 7965
7861: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7862: LD_ADDR_VAR 0 6
7866: PUSH
7867: LD_INT 71
7869: PUSH
7870: LD_INT 67
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: PUSH
7877: LD_INT 82
7879: PUSH
7880: LD_INT 23
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PUSH
7887: LD_INT 53
7889: PUSH
7890: LD_INT 7
7892: PUSH
7893: EMPTY
7894: LIST
7895: LIST
7896: PUSH
7897: LD_INT 43
7899: PUSH
7900: LD_INT 10
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: EMPTY
7908: LIST
7909: LIST
7910: LIST
7911: LIST
7912: PUSH
7913: LD_INT 53
7915: PUSH
7916: LD_INT 62
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: PUSH
7923: LD_INT 37
7925: PUSH
7926: LD_INT 63
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PUSH
7933: LD_INT 44
7935: PUSH
7936: LD_INT 45
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: PUSH
7943: LD_INT 37
7945: PUSH
7946: LD_INT 28
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PUSH
7953: EMPTY
7954: LIST
7955: LIST
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: LIST
7961: LIST
7962: ST_TO_ADDR
7963: GO 8056
7965: LD_INT 2
7967: DOUBLE
7968: EQUAL
7969: IFTRUE 7973
7971: GO 8055
7973: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
7974: LD_ADDR_VAR 0 6
7978: PUSH
7979: LD_INT 90
7981: PUSH
7982: LD_INT 59
7984: PUSH
7985: EMPTY
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 108
7991: PUSH
7992: LD_INT 64
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PUSH
8003: LD_INT 82
8005: PUSH
8006: LD_INT 75
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PUSH
8013: LD_INT 73
8015: PUSH
8016: LD_INT 67
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: PUSH
8023: LD_INT 101
8025: PUSH
8026: LD_INT 65
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 108
8035: PUSH
8036: LD_INT 62
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: PUSH
8043: EMPTY
8044: LIST
8045: LIST
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: LIST
8052: ST_TO_ADDR
8053: GO 8056
8055: POP
// if not attackFormula then
8056: LD_VAR 0 6
8060: NOT
8061: IFFALSE 8065
// exit ;
8063: GO 9497
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8065: LD_ADDR_VAR 0 7
8069: PUSH
8070: LD_EXP 45
8074: PPUSH
8075: LD_INT 25
8077: PUSH
8078: LD_INT 1
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PPUSH
8085: CALL_OW 72
8089: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8090: LD_ADDR_VAR 0 8
8094: PUSH
8095: LD_EXP 45
8099: PPUSH
8100: LD_INT 25
8102: PUSH
8103: LD_INT 4
8105: PUSH
8106: EMPTY
8107: LIST
8108: LIST
8109: PPUSH
8110: CALL_OW 72
8114: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8115: LD_ADDR_VAR 0 9
8119: PUSH
8120: LD_EXP 45
8124: PPUSH
8125: LD_INT 25
8127: PUSH
8128: LD_INT 3
8130: PUSH
8131: EMPTY
8132: LIST
8133: LIST
8134: PPUSH
8135: CALL_OW 72
8139: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8140: LD_ADDR_VAR 0 10
8144: PUSH
8145: LD_EXP 45
8149: PPUSH
8150: LD_INT 21
8152: PUSH
8153: LD_INT 2
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PPUSH
8160: CALL_OW 72
8164: ST_TO_ADDR
// if sci then
8165: LD_VAR 0 8
8169: IFFALSE 8206
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8171: LD_VAR 0 8
8175: PPUSH
8176: LD_VAR 0 6
8180: PUSH
8181: LD_INT 2
8183: ARRAY
8184: PUSH
8185: LD_INT 1
8187: ARRAY
8188: PPUSH
8189: LD_VAR 0 6
8193: PUSH
8194: LD_INT 2
8196: ARRAY
8197: PUSH
8198: LD_INT 2
8200: ARRAY
8201: PPUSH
8202: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8206: LD_INT 35
8208: PPUSH
8209: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8213: LD_ADDR_VAR 0 7
8217: PUSH
8218: LD_EXP 45
8222: PPUSH
8223: LD_INT 25
8225: PUSH
8226: LD_INT 1
8228: PUSH
8229: EMPTY
8230: LIST
8231: LIST
8232: PPUSH
8233: CALL_OW 72
8237: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8238: LD_ADDR_VAR 0 8
8242: PUSH
8243: LD_EXP 45
8247: PPUSH
8248: LD_INT 25
8250: PUSH
8251: LD_INT 4
8253: PUSH
8254: EMPTY
8255: LIST
8256: LIST
8257: PPUSH
8258: CALL_OW 72
8262: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8263: LD_ADDR_VAR 0 9
8267: PUSH
8268: LD_EXP 45
8272: PPUSH
8273: LD_INT 25
8275: PUSH
8276: LD_INT 3
8278: PUSH
8279: EMPTY
8280: LIST
8281: LIST
8282: PPUSH
8283: CALL_OW 72
8287: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8288: LD_ADDR_VAR 0 10
8292: PUSH
8293: LD_EXP 45
8297: PPUSH
8298: LD_INT 21
8300: PUSH
8301: LD_INT 2
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PPUSH
8308: CALL_OW 72
8312: ST_TO_ADDR
// if sol then
8313: LD_VAR 0 7
8317: IFFALSE 8712
// begin for i in sol do
8319: LD_ADDR_VAR 0 2
8323: PUSH
8324: LD_VAR 0 7
8328: PUSH
8329: FOR_IN
8330: IFFALSE 8710
// begin tag := GetTag ( i ) ;
8332: LD_ADDR_VAR 0 4
8336: PUSH
8337: LD_VAR 0 2
8341: PPUSH
8342: CALL_OW 110
8346: ST_TO_ADDR
// if not tag then
8347: LD_VAR 0 4
8351: NOT
8352: IFFALSE 8470
// begin if GetLives ( i ) = 1000 then
8354: LD_VAR 0 2
8358: PPUSH
8359: CALL_OW 256
8363: PUSH
8364: LD_INT 1000
8366: EQUAL
8367: IFFALSE 8383
// SetTag ( i , 1 ) else
8369: LD_VAR 0 2
8373: PPUSH
8374: LD_INT 1
8376: PPUSH
8377: CALL_OW 109
8381: GO 8468
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8383: LD_VAR 0 2
8387: PPUSH
8388: LD_VAR 0 6
8392: PUSH
8393: LD_INT 2
8395: ARRAY
8396: PUSH
8397: LD_INT 1
8399: ARRAY
8400: PPUSH
8401: LD_VAR 0 6
8405: PUSH
8406: LD_INT 2
8408: ARRAY
8409: PUSH
8410: LD_INT 2
8412: ARRAY
8413: PPUSH
8414: CALL_OW 297
8418: PUSH
8419: LD_INT 6
8421: GREATER
8422: IFFALSE 8468
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8424: LD_VAR 0 2
8428: PPUSH
8429: LD_VAR 0 6
8433: PUSH
8434: LD_INT 2
8436: ARRAY
8437: PUSH
8438: LD_INT 1
8440: ARRAY
8441: PPUSH
8442: LD_VAR 0 6
8446: PUSH
8447: LD_INT 2
8449: ARRAY
8450: PUSH
8451: LD_INT 2
8453: ARRAY
8454: PPUSH
8455: CALL_OW 111
// AddComHold ( i ) ;
8459: LD_VAR 0 2
8463: PPUSH
8464: CALL_OW 200
// end ; end else
8468: GO 8708
// begin if GetLives ( i ) < 720 then
8470: LD_VAR 0 2
8474: PPUSH
8475: CALL_OW 256
8479: PUSH
8480: LD_INT 720
8482: LESS
8483: IFFALSE 8499
// SetTag ( i , 0 ) else
8485: LD_VAR 0 2
8489: PPUSH
8490: LD_INT 0
8492: PPUSH
8493: CALL_OW 109
8497: GO 8708
// if tag <= attackFormula [ 1 ] then
8499: LD_VAR 0 4
8503: PUSH
8504: LD_VAR 0 6
8508: PUSH
8509: LD_INT 1
8511: ARRAY
8512: LESSEQUAL
8513: IFFALSE 8674
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8515: LD_VAR 0 2
8519: PPUSH
8520: LD_VAR 0 6
8524: PUSH
8525: LD_INT 1
8527: ARRAY
8528: PUSH
8529: LD_VAR 0 4
8533: ARRAY
8534: PUSH
8535: LD_INT 1
8537: ARRAY
8538: PPUSH
8539: LD_VAR 0 6
8543: PUSH
8544: LD_INT 1
8546: ARRAY
8547: PUSH
8548: LD_VAR 0 4
8552: ARRAY
8553: PUSH
8554: LD_INT 2
8556: ARRAY
8557: PPUSH
8558: CALL_OW 297
8562: PUSH
8563: LD_INT 6
8565: GREATER
8566: IFFALSE 8617
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8568: LD_VAR 0 2
8572: PPUSH
8573: LD_VAR 0 6
8577: PUSH
8578: LD_INT 1
8580: ARRAY
8581: PUSH
8582: LD_VAR 0 4
8586: ARRAY
8587: PUSH
8588: LD_INT 1
8590: ARRAY
8591: PPUSH
8592: LD_VAR 0 6
8596: PUSH
8597: LD_INT 1
8599: ARRAY
8600: PUSH
8601: LD_VAR 0 4
8605: ARRAY
8606: PUSH
8607: LD_INT 2
8609: ARRAY
8610: PPUSH
8611: CALL_OW 114
8615: GO 8672
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8617: LD_INT 81
8619: PUSH
8620: LD_INT 1
8622: PUSH
8623: EMPTY
8624: LIST
8625: LIST
8626: PUSH
8627: LD_INT 91
8629: PUSH
8630: LD_VAR 0 2
8634: PUSH
8635: LD_INT 10
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PPUSH
8647: CALL_OW 69
8651: NOT
8652: IFFALSE 8672
// SetTag ( i , tag + 1 ) ;
8654: LD_VAR 0 2
8658: PPUSH
8659: LD_VAR 0 4
8663: PUSH
8664: LD_INT 1
8666: PLUS
8667: PPUSH
8668: CALL_OW 109
// end else
8672: GO 8708
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8674: LD_VAR 0 2
8678: PPUSH
8679: LD_INT 81
8681: PUSH
8682: LD_INT 1
8684: PUSH
8685: EMPTY
8686: LIST
8687: LIST
8688: PPUSH
8689: CALL_OW 69
8693: PPUSH
8694: LD_VAR 0 2
8698: PPUSH
8699: CALL_OW 74
8703: PPUSH
8704: CALL_OW 115
// end ; end ;
8708: GO 8329
8710: POP
8711: POP
// end ; if sci then
8712: LD_VAR 0 8
8716: IFFALSE 8875
// begin if not sol and not mech then
8718: LD_VAR 0 7
8722: NOT
8723: PUSH
8724: LD_VAR 0 9
8728: NOT
8729: AND
8730: IFFALSE 8782
// begin for i in sci do
8732: LD_ADDR_VAR 0 2
8736: PUSH
8737: LD_VAR 0 8
8741: PUSH
8742: FOR_IN
8743: IFFALSE 8778
// begin usForces := usForces union i ;
8745: LD_ADDR_EXP 42
8749: PUSH
8750: LD_EXP 42
8754: PUSH
8755: LD_VAR 0 2
8759: UNION
8760: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8761: LD_VAR 0 2
8765: PPUSH
8766: LD_INT 34
8768: PPUSH
8769: LD_INT 68
8771: PPUSH
8772: CALL_OW 111
// end ;
8776: GO 8742
8778: POP
8779: POP
// end else
8780: GO 8875
// for i in sci do
8782: LD_ADDR_VAR 0 2
8786: PUSH
8787: LD_VAR 0 8
8791: PUSH
8792: FOR_IN
8793: IFFALSE 8873
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8795: LD_VAR 0 2
8799: PPUSH
8800: LD_VAR 0 6
8804: PUSH
8805: LD_INT 2
8807: ARRAY
8808: PUSH
8809: LD_INT 1
8811: ARRAY
8812: PPUSH
8813: LD_VAR 0 6
8817: PUSH
8818: LD_INT 2
8820: ARRAY
8821: PUSH
8822: LD_INT 2
8824: ARRAY
8825: PPUSH
8826: CALL_OW 297
8830: PUSH
8831: LD_INT 8
8833: GREATER
8834: IFFALSE 8871
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8836: LD_VAR 0 2
8840: PPUSH
8841: LD_VAR 0 6
8845: PUSH
8846: LD_INT 2
8848: ARRAY
8849: PUSH
8850: LD_INT 1
8852: ARRAY
8853: PPUSH
8854: LD_VAR 0 6
8858: PUSH
8859: LD_INT 2
8861: ARRAY
8862: PUSH
8863: LD_INT 2
8865: ARRAY
8866: PPUSH
8867: CALL_OW 111
8871: GO 8792
8873: POP
8874: POP
// end ; if tanks and mech then
8875: LD_VAR 0 10
8879: PUSH
8880: LD_VAR 0 9
8884: AND
8885: IFFALSE 9490
// begin for i in mech do
8887: LD_ADDR_VAR 0 2
8891: PUSH
8892: LD_VAR 0 9
8896: PUSH
8897: FOR_IN
8898: IFFALSE 9488
// begin tag := GetTag ( i ) ;
8900: LD_ADDR_VAR 0 4
8904: PUSH
8905: LD_VAR 0 2
8909: PPUSH
8910: CALL_OW 110
8914: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8915: LD_ADDR_VAR 0 11
8919: PUSH
8920: LD_VAR 0 2
8924: PPUSH
8925: CALL_OW 310
8929: ST_TO_ADDR
// if not tag then
8930: LD_VAR 0 4
8934: NOT
8935: IFFALSE 9248
// begin if veh then
8937: LD_VAR 0 11
8941: IFFALSE 9090
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
8943: LD_VAR 0 11
8947: PPUSH
8948: CALL_OW 256
8952: PUSH
8953: LD_INT 1000
8955: EQUAL
8956: PUSH
8957: LD_VAR 0 11
8961: PPUSH
8962: CALL_OW 261
8966: PUSH
8967: LD_INT 60
8969: GREATER
8970: AND
8971: IFFALSE 8987
// SetTag ( i , 1 ) else
8973: LD_VAR 0 2
8977: PPUSH
8978: LD_INT 1
8980: PPUSH
8981: CALL_OW 109
8985: GO 9088
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
8987: LD_VAR 0 2
8991: PPUSH
8992: LD_VAR 0 6
8996: PUSH
8997: LD_INT 3
8999: ARRAY
9000: PUSH
9001: LD_INT 1
9003: ARRAY
9004: PPUSH
9005: LD_VAR 0 6
9009: PUSH
9010: LD_INT 3
9012: ARRAY
9013: PUSH
9014: LD_INT 2
9016: ARRAY
9017: PPUSH
9018: CALL_OW 297
9022: PUSH
9023: LD_INT 7
9025: GREATER
9026: IFFALSE 9065
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
9028: LD_VAR 0 2
9032: PPUSH
9033: LD_VAR 0 6
9037: PUSH
9038: LD_INT 3
9040: ARRAY
9041: PUSH
9042: LD_INT 1
9044: ARRAY
9045: PPUSH
9046: LD_VAR 0 6
9050: PUSH
9051: LD_INT 3
9053: ARRAY
9054: PUSH
9055: LD_INT 2
9057: ARRAY
9058: PPUSH
9059: CALL_OW 111
9063: GO 9088
// begin ComExitVehicle ( i ) ;
9065: LD_VAR 0 2
9069: PPUSH
9070: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
9074: LD_VAR 0 2
9078: PPUSH
9079: LD_VAR 0 11
9083: PPUSH
9084: CALL_OW 189
// end ; end else
9088: GO 9246
// if GetLives ( i ) < 700 then
9090: LD_VAR 0 2
9094: PPUSH
9095: CALL_OW 256
9099: PUSH
9100: LD_INT 700
9102: LESS
9103: IFFALSE 9154
// begin usAttackers := usAttackers diff i ;
9105: LD_ADDR_EXP 45
9109: PUSH
9110: LD_EXP 45
9114: PUSH
9115: LD_VAR 0 2
9119: DIFF
9120: ST_TO_ADDR
// usForces := usForces union i ;
9121: LD_ADDR_EXP 42
9125: PUSH
9126: LD_EXP 42
9130: PUSH
9131: LD_VAR 0 2
9135: UNION
9136: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9137: LD_VAR 0 2
9141: PPUSH
9142: LD_INT 34
9144: PPUSH
9145: LD_INT 68
9147: PPUSH
9148: CALL_OW 111
// end else
9152: GO 9246
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9154: LD_VAR 0 10
9158: PPUSH
9159: LD_INT 58
9161: PUSH
9162: EMPTY
9163: LIST
9164: PUSH
9165: LD_INT 24
9167: PUSH
9168: LD_INT 1000
9170: PUSH
9171: EMPTY
9172: LIST
9173: LIST
9174: PUSH
9175: EMPTY
9176: LIST
9177: LIST
9178: PPUSH
9179: CALL_OW 72
9183: PUSH
9184: LD_VAR 0 2
9188: PPUSH
9189: CALL_OW 314
9193: NOT
9194: AND
9195: IFFALSE 9246
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9197: LD_VAR 0 2
9201: PPUSH
9202: LD_VAR 0 10
9206: PPUSH
9207: LD_INT 58
9209: PUSH
9210: EMPTY
9211: LIST
9212: PUSH
9213: LD_INT 24
9215: PUSH
9216: LD_INT 1000
9218: PUSH
9219: EMPTY
9220: LIST
9221: LIST
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: PPUSH
9227: CALL_OW 72
9231: PPUSH
9232: LD_VAR 0 2
9236: PPUSH
9237: CALL_OW 74
9241: PPUSH
9242: CALL_OW 120
// end else
9246: GO 9486
// begin if GetLives ( veh ) < 620 then
9248: LD_VAR 0 11
9252: PPUSH
9253: CALL_OW 256
9257: PUSH
9258: LD_INT 620
9260: LESS
9261: IFFALSE 9277
// SetTag ( i , 0 ) else
9263: LD_VAR 0 2
9267: PPUSH
9268: LD_INT 0
9270: PPUSH
9271: CALL_OW 109
9275: GO 9486
// if tag <= attackFormula [ 4 ] then
9277: LD_VAR 0 4
9281: PUSH
9282: LD_VAR 0 6
9286: PUSH
9287: LD_INT 4
9289: ARRAY
9290: LESSEQUAL
9291: IFFALSE 9452
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9293: LD_VAR 0 2
9297: PPUSH
9298: LD_VAR 0 6
9302: PUSH
9303: LD_INT 4
9305: ARRAY
9306: PUSH
9307: LD_VAR 0 4
9311: ARRAY
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PPUSH
9317: LD_VAR 0 6
9321: PUSH
9322: LD_INT 4
9324: ARRAY
9325: PUSH
9326: LD_VAR 0 4
9330: ARRAY
9331: PUSH
9332: LD_INT 2
9334: ARRAY
9335: PPUSH
9336: CALL_OW 297
9340: PUSH
9341: LD_INT 6
9343: GREATER
9344: IFFALSE 9395
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9346: LD_VAR 0 2
9350: PPUSH
9351: LD_VAR 0 6
9355: PUSH
9356: LD_INT 4
9358: ARRAY
9359: PUSH
9360: LD_VAR 0 4
9364: ARRAY
9365: PUSH
9366: LD_INT 1
9368: ARRAY
9369: PPUSH
9370: LD_VAR 0 6
9374: PUSH
9375: LD_INT 4
9377: ARRAY
9378: PUSH
9379: LD_VAR 0 4
9383: ARRAY
9384: PUSH
9385: LD_INT 2
9387: ARRAY
9388: PPUSH
9389: CALL_OW 114
9393: GO 9450
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9395: LD_INT 81
9397: PUSH
9398: LD_INT 1
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: PUSH
9405: LD_INT 91
9407: PUSH
9408: LD_VAR 0 2
9412: PUSH
9413: LD_INT 10
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PPUSH
9425: CALL_OW 69
9429: NOT
9430: IFFALSE 9450
// SetTag ( i , tag + 1 ) ;
9432: LD_VAR 0 2
9436: PPUSH
9437: LD_VAR 0 4
9441: PUSH
9442: LD_INT 1
9444: PLUS
9445: PPUSH
9446: CALL_OW 109
// end else
9450: GO 9486
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9452: LD_VAR 0 2
9456: PPUSH
9457: LD_INT 81
9459: PUSH
9460: LD_INT 1
9462: PUSH
9463: EMPTY
9464: LIST
9465: LIST
9466: PPUSH
9467: CALL_OW 69
9471: PPUSH
9472: LD_VAR 0 2
9476: PPUSH
9477: CALL_OW 74
9481: PPUSH
9482: CALL_OW 115
// end ; end ;
9486: GO 8897
9488: POP
9489: POP
// end ; until not usAttackers ;
9490: LD_EXP 45
9494: NOT
9495: IFFALSE 8206
// end ;
9497: LD_VAR 0 1
9501: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do var i ;
9502: LD_INT 22
9504: PUSH
9505: LD_INT 1
9507: PUSH
9508: EMPTY
9509: LIST
9510: LIST
9511: PUSH
9512: LD_INT 32
9514: PUSH
9515: LD_INT 1
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: PPUSH
9526: CALL_OW 69
9530: IFFALSE 9607
9532: GO 9534
9534: DISABLE
9535: LD_INT 0
9537: PPUSH
// begin enable ;
9538: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do
9539: LD_ADDR_VAR 0 1
9543: PUSH
9544: LD_INT 22
9546: PUSH
9547: LD_INT 1
9549: PUSH
9550: EMPTY
9551: LIST
9552: LIST
9553: PUSH
9554: LD_INT 32
9556: PUSH
9557: LD_INT 1
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: PPUSH
9568: CALL_OW 69
9572: PUSH
9573: FOR_IN
9574: IFFALSE 9605
// if GetFuel ( i ) < 10 then
9576: LD_VAR 0 1
9580: PPUSH
9581: CALL_OW 261
9585: PUSH
9586: LD_INT 10
9588: LESS
9589: IFFALSE 9603
// SetFuel ( i , 10 ) ;
9591: LD_VAR 0 1
9595: PPUSH
9596: LD_INT 10
9598: PPUSH
9599: CALL_OW 240
9603: GO 9573
9605: POP
9606: POP
// end ; end_of_file
9607: PPOPN 1
9609: END
// export function Action ; var hasAll , i , tmp ; begin
9610: LD_INT 0
9612: PPUSH
9613: PPUSH
9614: PPUSH
9615: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9616: LD_ADDR_VAR 0 2
9620: PUSH
9621: LD_INT 22
9623: PUSH
9624: LD_INT 2
9626: PUSH
9627: EMPTY
9628: LIST
9629: LIST
9630: PUSH
9631: LD_INT 21
9633: PUSH
9634: LD_INT 1
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: PUSH
9641: LD_INT 23
9643: PUSH
9644: LD_INT 2
9646: PUSH
9647: EMPTY
9648: LIST
9649: LIST
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: LIST
9655: PPUSH
9656: CALL_OW 69
9660: PUSH
9661: LD_INT 7
9663: GREATEREQUAL
9664: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9665: LD_VAR 0 2
9669: PPUSH
9670: LD_STRING 03_HasAll
9672: PPUSH
9673: CALL_OW 39
// Video ( true ) ;
9677: LD_INT 1
9679: PPUSH
9680: CALL 1020 0 1
// CenterNowOnUnits ( Heike ) ;
9684: LD_EXP 26
9688: PPUSH
9689: CALL_OW 87
// wait ( 0 0$2 ) ;
9693: LD_INT 70
9695: PPUSH
9696: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9700: LD_EXP 34
9704: PPUSH
9705: LD_STRING DF-1-start
9707: PPUSH
9708: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9712: LD_EXP 26
9716: PPUSH
9717: LD_EXP 34
9721: PPUSH
9722: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9726: LD_EXP 26
9730: PPUSH
9731: LD_STRING DH-1-start
9733: PPUSH
9734: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9738: LD_EXP 35
9742: PPUSH
9743: LD_INT 92
9745: PPUSH
9746: LD_INT 21
9748: PPUSH
9749: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9753: LD_EXP 30
9757: PPUSH
9758: LD_INT 94
9760: PPUSH
9761: LD_INT 23
9763: PPUSH
9764: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9768: LD_EXP 38
9772: PUSH
9773: LD_INT 1
9775: ARRAY
9776: PPUSH
9777: LD_INT 90
9779: PPUSH
9780: LD_INT 23
9782: PPUSH
9783: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9787: LD_EXP 38
9791: PUSH
9792: LD_INT 2
9794: ARRAY
9795: PPUSH
9796: LD_INT 93
9798: PPUSH
9799: LD_INT 25
9801: PPUSH
9802: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9806: LD_EXP 38
9810: PPUSH
9811: LD_EXP 35
9815: PPUSH
9816: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9820: LD_EXP 35
9824: PUSH
9825: LD_EXP 30
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: LD_EXP 26
9838: PPUSH
9839: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9843: LD_EXP 26
9847: PPUSH
9848: LD_EXP 35
9852: PPUSH
9853: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9857: LD_INT 35
9859: PPUSH
9860: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9864: LD_EXP 35
9868: PPUSH
9869: LD_INT 92
9871: PPUSH
9872: LD_INT 21
9874: PPUSH
9875: CALL_OW 307
9879: IFFALSE 9857
// Say ( Omar , DO-1-start ) ;
9881: LD_EXP 35
9885: PPUSH
9886: LD_STRING DO-1-start
9888: PPUSH
9889: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9893: LD_EXP 26
9897: PPUSH
9898: LD_STRING DH-2-start
9900: PPUSH
9901: CALL_OW 88
// if hasAll then
9905: LD_VAR 0 2
9909: IFFALSE 10037
// begin Say ( Omar , DO-2-start ) ;
9911: LD_EXP 35
9915: PPUSH
9916: LD_STRING DO-2-start
9918: PPUSH
9919: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9923: LD_EXP 35
9927: PPUSH
9928: LD_STRING DO-3-start
9930: PPUSH
9931: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
9935: LD_EXP 26
9939: PPUSH
9940: LD_STRING DH-3-start
9942: PPUSH
9943: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
9947: LD_EXP 34
9951: PPUSH
9952: LD_STRING DF-2-start
9954: PPUSH
9955: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9959: LD_EXP 35
9963: PPUSH
9964: LD_EXP 34
9968: PPUSH
9969: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
9973: LD_EXP 35
9977: PPUSH
9978: LD_STRING DO-4-start
9980: PPUSH
9981: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
9985: LD_EXP 34
9989: PPUSH
9990: LD_STRING DF-3-start
9992: PPUSH
9993: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
9997: LD_EXP 35
10001: PPUSH
10002: LD_STRING DO-5-start
10004: PPUSH
10005: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
10009: LD_EXP 34
10013: PPUSH
10014: LD_STRING DF-4-start
10016: PPUSH
10017: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10021: LD_EXP 35
10025: PPUSH
10026: LD_EXP 26
10030: PPUSH
10031: CALL_OW 119
// end else
10035: GO 10137
// begin Say ( Omar , DO-2-start-a ) ;
10037: LD_EXP 35
10041: PPUSH
10042: LD_STRING DO-2-start-a
10044: PPUSH
10045: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
10049: LD_EXP 35
10053: PPUSH
10054: LD_STRING DO-3-start-a
10056: PPUSH
10057: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
10061: LD_EXP 26
10065: PPUSH
10066: LD_STRING DH-3-start-a
10068: PPUSH
10069: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
10073: LD_EXP 34
10077: PPUSH
10078: LD_STRING DF-2-start-a
10080: PPUSH
10081: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10085: LD_EXP 35
10089: PPUSH
10090: LD_EXP 34
10094: PPUSH
10095: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
10099: LD_EXP 35
10103: PPUSH
10104: LD_STRING DO-4-start-a
10106: PPUSH
10107: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
10111: LD_EXP 34
10115: PPUSH
10116: LD_STRING DF-3-start-a
10118: PPUSH
10119: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10123: LD_EXP 35
10127: PPUSH
10128: LD_EXP 26
10132: PPUSH
10133: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
10137: LD_INT 10
10139: PPUSH
10140: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
10144: LD_EXP 35
10148: PPUSH
10149: LD_STRING DO-1-mission
10151: PPUSH
10152: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
10156: LD_EXP 35
10160: PPUSH
10161: LD_STRING DO-2-mission
10163: PPUSH
10164: CALL_OW 88
// if not hasAll then
10168: LD_VAR 0 2
10172: NOT
10173: IFFALSE 10187
// Say ( Omar , DO-3-mission ) ;
10175: LD_EXP 35
10179: PPUSH
10180: LD_STRING DO-3-mission
10182: PPUSH
10183: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
10187: LD_EXP 35
10191: PPUSH
10192: LD_STRING DO-4-mission
10194: PPUSH
10195: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
10199: LD_EXP 26
10203: PPUSH
10204: LD_STRING DH-1-mission
10206: PPUSH
10207: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10211: LD_EXP 34
10215: PPUSH
10216: LD_STRING DF-1-mission
10218: PPUSH
10219: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10223: LD_EXP 35
10227: PPUSH
10228: LD_STRING DO-5-mission
10230: PPUSH
10231: CALL_OW 88
// if not hasAll then
10235: LD_VAR 0 2
10239: NOT
10240: IFFALSE 10375
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10242: LD_ADDR_VAR 0 4
10246: PUSH
10247: LD_INT 22
10249: PUSH
10250: LD_INT 2
10252: PUSH
10253: EMPTY
10254: LIST
10255: LIST
10256: PUSH
10257: LD_INT 21
10259: PUSH
10260: LD_INT 1
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: PUSH
10267: LD_INT 23
10269: PUSH
10270: LD_INT 2
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: LIST
10281: PPUSH
10282: CALL_OW 69
10286: ST_TO_ADDR
// for i := 7 downto tmp do
10287: LD_ADDR_VAR 0 3
10291: PUSH
10292: DOUBLE
10293: LD_INT 7
10295: INC
10296: ST_TO_ADDR
10297: LD_VAR 0 4
10301: PUSH
10302: FOR_DOWNTO
10303: IFFALSE 10373
// begin if omarSquad < 3 then
10305: LD_EXP 38
10309: PUSH
10310: LD_INT 3
10312: LESS
10313: IFFALSE 10317
// break ;
10315: GO 10373
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10317: LD_EXP 38
10321: PUSH
10322: LD_INT 3
10324: ARRAY
10325: PPUSH
10326: LD_INT 2
10328: PPUSH
10329: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10333: LD_ADDR_EXP 40
10337: PUSH
10338: LD_EXP 40
10342: PUSH
10343: LD_EXP 38
10347: PUSH
10348: LD_INT 3
10350: ARRAY
10351: UNION
10352: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10353: LD_ADDR_EXP 38
10357: PUSH
10358: LD_EXP 38
10362: PPUSH
10363: LD_INT 3
10365: PPUSH
10366: CALL_OW 3
10370: ST_TO_ADDR
// end ;
10371: GO 10302
10373: POP
10374: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10375: LD_EXP 35
10379: PUSH
10380: LD_EXP 38
10384: ADD
10385: PPUSH
10386: LD_INT 103
10388: PPUSH
10389: LD_INT 9
10391: PPUSH
10392: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10396: LD_VAR 0 2
10400: PUSH
10401: LD_EXP 31
10405: PPUSH
10406: CALL_OW 302
10410: AND
10411: IFFALSE 10472
// begin wait ( 0 0$3 ) ;
10413: LD_INT 105
10415: PPUSH
10416: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10420: LD_EXP 31
10424: PPUSH
10425: LD_EXP 34
10429: PPUSH
10430: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10434: LD_EXP 31
10438: PPUSH
10439: LD_STRING DK-1-side
10441: PPUSH
10442: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10446: LD_EXP 34
10450: PPUSH
10451: LD_EXP 31
10455: PPUSH
10456: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10460: LD_EXP 34
10464: PPUSH
10465: LD_STRING DF-1-side
10467: PPUSH
10468: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10472: LD_INT 22
10474: PUSH
10475: LD_INT 2
10477: PUSH
10478: EMPTY
10479: LIST
10480: LIST
10481: PPUSH
10482: CALL_OW 69
10486: PPUSH
10487: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10491: LD_EXP 34
10495: PUSH
10496: LD_EXP 37
10500: ADD
10501: PPUSH
10502: LD_INT 108
10504: PPUSH
10505: LD_INT 62
10507: PPUSH
10508: CALL_OW 111
// gameStarted := true ;
10512: LD_ADDR_EXP 3
10516: PUSH
10517: LD_INT 1
10519: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10520: LD_INT 105
10522: PPUSH
10523: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10527: LD_EXP 26
10531: PPUSH
10532: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10536: LD_EXP 26
10540: PPUSH
10541: LD_EXP 30
10545: PPUSH
10546: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10550: LD_INT 22
10552: PUSH
10553: LD_INT 2
10555: PUSH
10556: EMPTY
10557: LIST
10558: LIST
10559: PPUSH
10560: CALL_OW 69
10564: PUSH
10565: LD_EXP 26
10569: DIFF
10570: PPUSH
10571: LD_EXP 26
10575: PPUSH
10576: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10580: LD_EXP 26
10584: PPUSH
10585: LD_STRING DH-1-explore
10587: PPUSH
10588: CALL_OW 88
// if Givi then
10592: LD_EXP 27
10596: IFFALSE 10612
// Say ( Givi , DG-1-explore ) else
10598: LD_EXP 27
10602: PPUSH
10603: LD_STRING DG-1-explore
10605: PPUSH
10606: CALL_OW 88
10610: GO 10649
// if heikeSecondSquad then
10612: LD_EXP 40
10616: IFFALSE 10649
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10618: LD_EXP 40
10622: PPUSH
10623: LD_INT 26
10625: PUSH
10626: LD_INT 1
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PPUSH
10633: CALL_OW 72
10637: PUSH
10638: LD_INT 1
10640: ARRAY
10641: PPUSH
10642: LD_STRING DArm-1-explore
10644: PPUSH
10645: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10649: LD_EXP 30
10653: PPUSH
10654: LD_STRING DA-1-explore
10656: PPUSH
10657: CALL_OW 88
// if Sophia then
10661: LD_EXP 32
10665: IFFALSE 10743
// begin Say ( Sophia , DS-2-explore ) ;
10667: LD_EXP 32
10671: PPUSH
10672: LD_STRING DS-2-explore
10674: PPUSH
10675: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10679: LD_EXP 30
10683: PPUSH
10684: LD_STRING DA-2-explore
10686: PPUSH
10687: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10691: LD_EXP 32
10695: PPUSH
10696: LD_EXP 30
10700: PPUSH
10701: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10705: LD_EXP 30
10709: PPUSH
10710: LD_EXP 32
10714: PPUSH
10715: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10719: LD_EXP 32
10723: PPUSH
10724: LD_STRING DS-3-explore
10726: PPUSH
10727: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10731: LD_EXP 30
10735: PPUSH
10736: LD_STRING DA-3-explore
10738: PPUSH
10739: CALL_OW 88
// end ; if Mike then
10743: LD_EXP 28
10747: IFFALSE 10803
// begin Say ( Mike , DM-1-explore ) ;
10749: LD_EXP 28
10753: PPUSH
10754: LD_STRING DM-1-explore
10756: PPUSH
10757: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10761: LD_EXP 26
10765: PPUSH
10766: LD_STRING DH-2-explore
10768: PPUSH
10769: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10773: LD_EXP 28
10777: PPUSH
10778: LD_STRING DM-2-explore
10780: PPUSH
10781: CALL_OW 88
// if Kaia then
10785: LD_EXP 31
10789: IFFALSE 10803
// Say ( Kaia , DK-1-explore ) ;
10791: LD_EXP 31
10795: PPUSH
10796: LD_STRING DK-1-explore
10798: PPUSH
10799: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10803: LD_INT 22
10805: PUSH
10806: LD_INT 2
10808: PUSH
10809: EMPTY
10810: LIST
10811: LIST
10812: PPUSH
10813: CALL_OW 69
10817: PPUSH
10818: CALL_OW 139
// Video ( false ) ;
10822: LD_INT 0
10824: PPUSH
10825: CALL 1020 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10829: LD_STRING BuildBase
10831: PPUSH
10832: CALL_OW 337
// SaveForQuickRestart ;
10836: CALL_OW 22
// end ;
10840: LD_VAR 0 1
10844: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10845: LD_EXP 5
10849: NOT
10850: PUSH
10851: LD_EXP 6
10855: NOT
10856: AND
10857: PUSH
10858: LD_INT 5
10860: PPUSH
10861: LD_INT 22
10863: PUSH
10864: LD_INT 2
10866: PUSH
10867: EMPTY
10868: LIST
10869: LIST
10870: PPUSH
10871: CALL_OW 70
10875: AND
10876: PUSH
10877: LD_EXP 6
10881: NOT
10882: AND
10883: IFFALSE 10968
10885: GO 10887
10887: DISABLE
// begin if Mike then
10888: LD_EXP 28
10892: IFFALSE 10908
// Say ( Mike , DM-1-scout ) else
10894: LD_EXP 28
10898: PPUSH
10899: LD_STRING DM-1-scout
10901: PPUSH
10902: CALL_OW 88
10906: GO 10939
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10908: LD_EXP 40
10912: PPUSH
10913: LD_INT 26
10915: PUSH
10916: LD_INT 1
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: PPUSH
10923: CALL_OW 72
10927: PUSH
10928: LD_INT 1
10930: ARRAY
10931: PPUSH
10932: LD_STRING DArm-1-explore
10934: PPUSH
10935: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
10939: LD_INT 54
10941: PPUSH
10942: LD_INT 35
10944: PPUSH
10945: LD_INT 2
10947: PPUSH
10948: LD_INT 1
10950: PPUSH
10951: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
10955: LD_INT 54
10957: PPUSH
10958: LD_INT 35
10960: PPUSH
10961: LD_INT 2
10963: PPUSH
10964: CALL_OW 331
// end ;
10968: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
10969: LD_INT 6
10971: PPUSH
10972: LD_INT 22
10974: PUSH
10975: LD_INT 2
10977: PUSH
10978: EMPTY
10979: LIST
10980: LIST
10981: PPUSH
10982: CALL_OW 70
10986: PUSH
10987: LD_EXP 6
10991: NOT
10992: AND
10993: IFFALSE 11247
10995: GO 10997
10997: DISABLE
10998: LD_INT 0
11000: PPUSH
11001: PPUSH
11002: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11003: LD_ADDR_VAR 0 1
11007: PUSH
11008: LD_EXP 40
11012: PPUSH
11013: LD_INT 26
11015: PUSH
11016: LD_INT 1
11018: PUSH
11019: EMPTY
11020: LIST
11021: LIST
11022: PPUSH
11023: CALL_OW 72
11027: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
11028: LD_ADDR_VAR 0 2
11032: PUSH
11033: LD_EXP 40
11037: PPUSH
11038: LD_INT 26
11040: PUSH
11041: LD_INT 2
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PPUSH
11048: CALL_OW 72
11052: ST_TO_ADDR
// DialogueOn ;
11053: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
11057: LD_INT 36
11059: PPUSH
11060: LD_INT 22
11062: PPUSH
11063: LD_INT 2
11065: PPUSH
11066: LD_INT 8
11068: PPUSH
11069: CALL_OW 330
// dwait ( 0 0$1 ) ;
11073: LD_INT 35
11075: PPUSH
11076: CALL_OW 68
// speakerOk := false ;
11080: LD_ADDR_VAR 0 3
11084: PUSH
11085: LD_INT 0
11087: ST_TO_ADDR
// if Mike then
11088: LD_EXP 28
11092: IFFALSE 11114
// speakerOk := Say ( Mike , DM-1-spot ) else
11094: LD_ADDR_VAR 0 3
11098: PUSH
11099: LD_EXP 28
11103: PPUSH
11104: LD_STRING DM-1-spot
11106: PPUSH
11107: CALL_OW 88
11111: ST_TO_ADDR
11112: GO 11142
// if randomMen then
11114: LD_VAR 0 1
11118: IFFALSE 11142
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11120: LD_ADDR_VAR 0 3
11124: PUSH
11125: LD_VAR 0 1
11129: PUSH
11130: LD_INT 1
11132: ARRAY
11133: PPUSH
11134: LD_STRING DArm-1-spot-a
11136: PPUSH
11137: CALL_OW 88
11141: ST_TO_ADDR
// if speakerOk then
11142: LD_VAR 0 3
11146: IFFALSE 11190
// begin if Givi then
11148: LD_EXP 27
11152: IFFALSE 11168
// Say ( Givi , DG-1-spot ) else
11154: LD_EXP 27
11158: PPUSH
11159: LD_STRING DG-1-spot
11161: PPUSH
11162: CALL_OW 88
11166: GO 11190
// if randomWomen then
11168: LD_VAR 0 2
11172: IFFALSE 11190
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
11174: LD_VAR 0 2
11178: PUSH
11179: LD_INT 1
11181: ARRAY
11182: PPUSH
11183: LD_STRING DArf-1-spot-a
11185: PPUSH
11186: CALL_OW 88
// end ; if Mike then
11190: LD_EXP 28
11194: IFFALSE 11210
// Say ( Heike , DH-1-spot ) else
11196: LD_EXP 26
11200: PPUSH
11201: LD_STRING DH-1-spot
11203: PPUSH
11204: CALL_OW 88
11208: GO 11222
// Say ( Heike , DH-1-spot-a ) ;
11210: LD_EXP 26
11214: PPUSH
11215: LD_STRING DH-1-spot-a
11217: PPUSH
11218: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11222: LD_INT 36
11224: PPUSH
11225: LD_INT 22
11227: PPUSH
11228: LD_INT 2
11230: PPUSH
11231: CALL_OW 331
// DialogueOff ;
11235: CALL_OW 7
// americanBaseSpoted := true ;
11239: LD_ADDR_EXP 5
11243: PUSH
11244: LD_INT 1
11246: ST_TO_ADDR
// end ;
11247: PPOPN 3
11249: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11250: LD_EXP 5
11254: NOT
11255: PUSH
11256: LD_INT 22
11258: PUSH
11259: LD_INT 2
11261: PUSH
11262: EMPTY
11263: LIST
11264: LIST
11265: PUSH
11266: LD_INT 101
11268: PUSH
11269: LD_INT 1
11271: PUSH
11272: EMPTY
11273: LIST
11274: LIST
11275: PUSH
11276: EMPTY
11277: LIST
11278: LIST
11279: PPUSH
11280: CALL_OW 69
11284: AND
11285: PUSH
11286: LD_EXP 6
11290: NOT
11291: AND
11292: IFFALSE 11378
11294: GO 11296
11296: DISABLE
11297: LD_INT 0
11299: PPUSH
// begin americanBaseSpoted := true ;
11300: LD_ADDR_EXP 5
11304: PUSH
11305: LD_INT 1
11307: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11308: LD_ADDR_VAR 0 1
11312: PUSH
11313: LD_EXP 40
11317: PPUSH
11318: LD_INT 26
11320: PUSH
11321: LD_INT 1
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PPUSH
11328: CALL_OW 72
11332: ST_TO_ADDR
// if not randomMen then
11333: LD_VAR 0 1
11337: NOT
11338: IFFALSE 11342
// exit ;
11340: GO 11378
// DialogueOn ;
11342: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11346: LD_VAR 0 1
11350: PUSH
11351: LD_INT 1
11353: ARRAY
11354: PPUSH
11355: LD_STRING DArm-1-spot-a
11357: PPUSH
11358: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11362: LD_EXP 26
11366: PPUSH
11367: LD_STRING DH-1-spot-a
11369: PPUSH
11370: CALL_OW 88
// DialogueOff ;
11374: CALL_OW 7
// end ;
11378: PPOPN 1
11380: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or usForces <= 4 do var i , p ;
11381: LD_INT 11
11383: PPUSH
11384: CALL_OW 255
11388: PUSH
11389: LD_INT 2
11391: EQUAL
11392: PUSH
11393: LD_INT 7
11395: PPUSH
11396: LD_INT 22
11398: PUSH
11399: LD_INT 1
11401: PUSH
11402: EMPTY
11403: LIST
11404: LIST
11405: PUSH
11406: LD_INT 3
11408: PUSH
11409: LD_INT 50
11411: PUSH
11412: EMPTY
11413: LIST
11414: PUSH
11415: EMPTY
11416: LIST
11417: LIST
11418: PUSH
11419: LD_INT 30
11421: PUSH
11422: LD_INT 31
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: LIST
11433: PPUSH
11434: CALL_OW 70
11438: OR
11439: PUSH
11440: LD_INT 7
11442: PPUSH
11443: LD_INT 22
11445: PUSH
11446: LD_INT 2
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PPUSH
11453: CALL_OW 70
11457: PUSH
11458: LD_INT 1
11460: GREATER
11461: OR
11462: PUSH
11463: LD_EXP 42
11467: PUSH
11468: LD_INT 4
11470: LESSEQUAL
11471: OR
11472: IFFALSE 11990
11474: GO 11476
11476: DISABLE
11477: LD_INT 0
11479: PPUSH
11480: PPUSH
// begin wait ( 0 0$3 ) ;
11481: LD_INT 105
11483: PPUSH
11484: CALL_OW 67
// if IsOk ( usCommander ) then
11488: LD_EXP 43
11492: PPUSH
11493: CALL_OW 302
11497: IFFALSE 11527
// begin usForces := usForces union usCommander ;
11499: LD_ADDR_EXP 42
11503: PUSH
11504: LD_EXP 42
11508: PUSH
11509: LD_EXP 43
11513: UNION
11514: ST_TO_ADDR
// Say ( usCommander , DUsm-1-assault ) ;
11515: LD_EXP 43
11519: PPUSH
11520: LD_STRING DUsm-1-assault
11522: PPUSH
11523: CALL_OW 88
// end ; for i in usForces do
11527: LD_ADDR_VAR 0 1
11531: PUSH
11532: LD_EXP 42
11536: PUSH
11537: FOR_IN
11538: IFFALSE 11584
// begin if IsInUnit ( i ) then
11540: LD_VAR 0 1
11544: PPUSH
11545: CALL_OW 310
11549: IFFALSE 11560
// ComExitBuilding ( i ) ;
11551: LD_VAR 0 1
11555: PPUSH
11556: CALL_OW 122
// wait ( 3 ) ;
11560: LD_INT 3
11562: PPUSH
11563: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11567: LD_VAR 0 1
11571: PPUSH
11572: LD_INT 34
11574: PPUSH
11575: LD_INT 67
11577: PPUSH
11578: CALL_OW 111
// end ;
11582: GO 11537
11584: POP
11585: POP
// Say ( Heike , DH-1-assault ) ;
11586: LD_EXP 26
11590: PPUSH
11591: LD_STRING DH-1-assault
11593: PPUSH
11594: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11598: LD_INT 35
11600: PPUSH
11601: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11605: LD_VAR 0 1
11609: PPUSH
11610: LD_INT 34
11612: PPUSH
11613: LD_INT 67
11615: PPUSH
11616: CALL_OW 111
// until not usForces ;
11620: LD_EXP 42
11624: NOT
11625: IFFALSE 11598
// music_nat := 2 ;
11627: LD_ADDR_OWVAR 71
11631: PUSH
11632: LD_INT 2
11634: ST_TO_ADDR
// music_class := music_victory ;
11635: LD_ADDR_OWVAR 72
11639: PUSH
11640: LD_INT 4
11642: ST_TO_ADDR
// if not americanHasEscaped then
11643: LD_EXP 7
11647: NOT
11648: IFFALSE 11669
// begin Say ( Heike , DH-2-assault ) ;
11650: LD_EXP 26
11654: PPUSH
11655: LD_STRING DH-2-assault
11657: PPUSH
11658: CALL_OW 88
// SetAchievement ( ACH_CLEAN ) ;
11662: LD_STRING ACH_CLEAN
11664: PPUSH
11665: CALL_OW 543
// end ; wait ( 0 0$2 ) ;
11669: LD_INT 70
11671: PPUSH
11672: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11676: LD_INT 35
11678: PPUSH
11679: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11683: LD_INT 22
11685: PUSH
11686: LD_INT 2
11688: PUSH
11689: EMPTY
11690: LIST
11691: LIST
11692: PUSH
11693: LD_INT 21
11695: PUSH
11696: LD_INT 1
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: PUSH
11703: LD_INT 3
11705: PUSH
11706: LD_INT 50
11708: PUSH
11709: EMPTY
11710: LIST
11711: PUSH
11712: EMPTY
11713: LIST
11714: LIST
11715: PUSH
11716: EMPTY
11717: LIST
11718: LIST
11719: LIST
11720: PPUSH
11721: CALL_OW 69
11725: NOT
11726: IFFALSE 11676
// InGameOn ;
11728: CALL_OW 8
// if not GetSide ( usDepot ) = 2 then
11732: LD_INT 11
11734: PPUSH
11735: CALL_OW 255
11739: PUSH
11740: LD_INT 2
11742: EQUAL
11743: NOT
11744: IFFALSE 11756
// SetSide ( usDepot , 2 ) ;
11746: LD_INT 11
11748: PPUSH
11749: LD_INT 2
11751: PPUSH
11752: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11756: LD_INT 35
11758: PPUSH
11759: LD_INT 22
11761: PPUSH
11762: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11766: LD_EXP 26
11770: PPUSH
11771: LD_INT 35
11773: PPUSH
11774: LD_INT 22
11776: PPUSH
11777: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11781: LD_EXP 26
11785: PPUSH
11786: LD_INT 38
11788: PPUSH
11789: LD_INT 25
11791: PPUSH
11792: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11796: LD_EXP 39
11800: PUSH
11801: LD_EXP 40
11805: UNION
11806: PPUSH
11807: LD_INT 39
11809: PPUSH
11810: LD_INT 26
11812: PPUSH
11813: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11817: LD_EXP 39
11821: PUSH
11822: LD_EXP 40
11826: UNION
11827: PPUSH
11828: LD_EXP 26
11832: PPUSH
11833: CALL_OW 179
// p := 0 ;
11837: LD_ADDR_VAR 0 2
11841: PUSH
11842: LD_INT 0
11844: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11845: LD_INT 35
11847: PPUSH
11848: CALL_OW 67
// p := p + 1 ;
11852: LD_ADDR_VAR 0 2
11856: PUSH
11857: LD_VAR 0 2
11861: PUSH
11862: LD_INT 1
11864: PLUS
11865: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11866: LD_EXP 26
11870: PPUSH
11871: CALL_OW 314
11875: NOT
11876: PUSH
11877: LD_VAR 0 2
11881: PUSH
11882: LD_INT 10
11884: GREATER
11885: OR
11886: IFFALSE 11845
// Say ( Heike , DH-1-capture ) ;
11888: LD_EXP 26
11892: PPUSH
11893: LD_STRING DH-1-capture
11895: PPUSH
11896: CALL_OW 88
// if Markov then
11900: LD_EXP 33
11904: IFFALSE 11918
// Say ( Markov , DMar-1-capture ) ;
11906: LD_EXP 33
11910: PPUSH
11911: LD_STRING DMar-1-capture
11913: PPUSH
11914: CALL_OW 88
// if Sophia then
11918: LD_EXP 32
11922: IFFALSE 11948
// begin Say ( Heike , DH-2-capture ) ;
11924: LD_EXP 26
11928: PPUSH
11929: LD_STRING DH-2-capture
11931: PPUSH
11932: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
11936: LD_EXP 32
11940: PPUSH
11941: LD_STRING DS-1-capture
11943: PPUSH
11944: CALL_OW 88
// end ; InGameOff ;
11948: CALL_OW 9
// music_nat := music_auto ;
11952: LD_ADDR_OWVAR 71
11956: PUSH
11957: LD_INT 0
11959: ST_TO_ADDR
// music_class := music_auto ;
11960: LD_ADDR_OWVAR 72
11964: PUSH
11965: LD_INT 0
11967: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
11968: LD_STRING ConstructBase
11970: PPUSH
11971: CALL_OW 337
// wait ( 0 0$3 ) ;
11975: LD_INT 105
11977: PPUSH
11978: CALL_OW 67
// americanBaseCaptured := true ;
11982: LD_ADDR_EXP 6
11986: PUSH
11987: LD_INT 1
11989: ST_TO_ADDR
// end ;
11990: PPOPN 2
11992: END
// every 0 0$1 trigger capturedCargoCounter >= 3 do
11993: LD_EXP 12
11997: PUSH
11998: LD_INT 3
12000: GREATEREQUAL
12001: IFFALSE 12013
12003: GO 12005
12005: DISABLE
// SetAchievement ( ACH_ENG ) ;
12006: LD_STRING ACH_ENG
12008: PPUSH
12009: CALL_OW 543
12013: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) >= 4 do
12014: LD_INT 22
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: LD_INT 25
12026: PUSH
12027: LD_INT 15
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PPUSH
12038: CALL_OW 69
12042: PUSH
12043: LD_INT 4
12045: GREATEREQUAL
12046: IFFALSE 12058
12048: GO 12050
12050: DISABLE
// SetAchievement ( ACH_APEGEN ) ;
12051: LD_STRING ACH_APEGEN
12053: PPUSH
12054: CALL_OW 543
12058: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
12059: LD_INT 22
12061: PUSH
12062: LD_INT 2
12064: PUSH
12065: EMPTY
12066: LIST
12067: LIST
12068: PUSH
12069: LD_INT 30
12071: PUSH
12072: LD_INT 2
12074: PUSH
12075: EMPTY
12076: LIST
12077: LIST
12078: PUSH
12079: LD_INT 3
12081: PUSH
12082: LD_INT 57
12084: PUSH
12085: EMPTY
12086: LIST
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: LIST
12096: PPUSH
12097: CALL_OW 69
12101: IFFALSE 12344
12103: GO 12105
12105: DISABLE
// begin workshopBuilded := true ;
12106: LD_ADDR_EXP 9
12110: PUSH
12111: LD_INT 1
12113: ST_TO_ADDR
// if IsOk ( Markov ) then
12114: LD_EXP 33
12118: PPUSH
12119: CALL_OW 302
12123: IFFALSE 12182
// begin Say ( Heike , DH-1-shop-a ) ;
12125: LD_EXP 26
12129: PPUSH
12130: LD_STRING DH-1-shop-a
12132: PPUSH
12133: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
12137: LD_INT 47
12139: PPUSH
12140: LD_INT 2
12142: PPUSH
12143: CALL_OW 321
12147: PUSH
12148: LD_INT 2
12150: EQUAL
12151: PUSH
12152: LD_INT 45
12154: PPUSH
12155: LD_INT 2
12157: PPUSH
12158: CALL_OW 321
12162: PUSH
12163: LD_INT 2
12165: EQUAL
12166: AND
12167: NOT
12168: IFFALSE 12182
// Say ( Markov , DMar-1-shop-a ) ;
12170: LD_EXP 33
12174: PPUSH
12175: LD_STRING DMar-1-shop-a
12177: PPUSH
12178: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
12182: LD_INT 35
12184: PPUSH
12185: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched or GetTech ( tech_SolEng , 2 ) = state_researched ;
12189: LD_INT 47
12191: PPUSH
12192: LD_INT 2
12194: PPUSH
12195: CALL_OW 321
12199: PUSH
12200: LD_INT 2
12202: EQUAL
12203: PUSH
12204: LD_INT 45
12206: PPUSH
12207: LD_INT 2
12209: PPUSH
12210: CALL_OW 321
12214: PUSH
12215: LD_INT 2
12217: EQUAL
12218: OR
12219: IFFALSE 12182
// DialogueOn ;
12221: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
12225: LD_EXP 33
12229: PPUSH
12230: LD_STRING DMar-1-shop
12232: PPUSH
12233: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
12237: LD_EXP 26
12241: PPUSH
12242: LD_STRING DH-1-shop
12244: PPUSH
12245: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12249: LD_EXP 33
12253: PPUSH
12254: LD_STRING DMar-2-shop
12256: PPUSH
12257: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12261: LD_EXP 33
12265: PPUSH
12266: LD_STRING DMar-3-shop
12268: PPUSH
12269: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12273: LD_EXP 26
12277: PPUSH
12278: LD_STRING DH-2-shop
12280: PPUSH
12281: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12285: LD_EXP 33
12289: PPUSH
12290: LD_STRING DMar-4-shop
12292: PPUSH
12293: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12297: LD_EXP 26
12301: PPUSH
12302: LD_STRING DH-3-shop
12304: PPUSH
12305: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12309: LD_EXP 33
12313: PPUSH
12314: LD_STRING DMar-5-shop
12316: PPUSH
12317: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12321: LD_EXP 26
12325: PPUSH
12326: LD_STRING DH-4-shop
12328: PPUSH
12329: CALL_OW 88
// DialogueOff ;
12333: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12337: LD_STRING ConstructVeh
12339: PPUSH
12340: CALL_OW 337
// end ;
12344: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12345: LD_INT 2
12347: PPUSH
12348: LD_INT 2
12350: PPUSH
12351: LD_INT 1
12353: PPUSH
12354: CALL 1191 0 3
12358: PUSH
12359: LD_INT 0
12361: EQUAL
12362: IFFALSE 12374
12364: GO 12366
12366: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12367: LD_STRING Techs
12369: PPUSH
12370: CALL_OW 337
12374: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12375: LD_EXP 33
12379: PPUSH
12380: CALL_OW 302
12384: PUSH
12385: LD_INT 22
12387: PUSH
12388: LD_INT 2
12390: PUSH
12391: EMPTY
12392: LIST
12393: LIST
12394: PUSH
12395: LD_INT 2
12397: PUSH
12398: LD_INT 34
12400: PUSH
12401: LD_INT 22
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 35
12410: PUSH
12411: LD_INT 22
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: LIST
12422: PUSH
12423: EMPTY
12424: LIST
12425: LIST
12426: PPUSH
12427: CALL_OW 69
12431: AND
12432: IFFALSE 12539
12434: GO 12436
12436: DISABLE
// begin DialogueOn ;
12437: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12441: LD_INT 22
12443: PUSH
12444: LD_INT 2
12446: PUSH
12447: EMPTY
12448: LIST
12449: LIST
12450: PUSH
12451: LD_INT 2
12453: PUSH
12454: LD_INT 34
12456: PUSH
12457: LD_INT 22
12459: PUSH
12460: EMPTY
12461: LIST
12462: LIST
12463: PUSH
12464: LD_INT 35
12466: PUSH
12467: LD_INT 22
12469: PUSH
12470: EMPTY
12471: LIST
12472: LIST
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: LIST
12478: PUSH
12479: EMPTY
12480: LIST
12481: LIST
12482: PPUSH
12483: CALL_OW 69
12487: PPUSH
12488: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12492: LD_INT 10
12494: PPUSH
12495: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12499: LD_EXP 26
12503: PPUSH
12504: LD_STRING DH-1-bal
12506: PPUSH
12507: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12511: LD_EXP 33
12515: PPUSH
12516: LD_STRING DMar-1-bal
12518: PPUSH
12519: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12523: LD_EXP 26
12527: PPUSH
12528: LD_STRING DH-2-bal
12530: PPUSH
12531: CALL_OW 88
// DialogueOff ;
12535: CALL_OW 7
// end ;
12539: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12540: LD_EXP 30
12544: PPUSH
12545: CALL_OW 302
12549: PUSH
12550: LD_INT 22
12552: PUSH
12553: LD_INT 2
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: LD_INT 30
12562: PUSH
12563: LD_INT 6
12565: PUSH
12566: EMPTY
12567: LIST
12568: LIST
12569: PUSH
12570: EMPTY
12571: LIST
12572: LIST
12573: PPUSH
12574: CALL_OW 69
12578: AND
12579: IFFALSE 12640
12581: GO 12583
12583: DISABLE
// begin DialogueOn ;
12584: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12588: LD_EXP 30
12592: PPUSH
12593: LD_STRING DA-1-lab
12595: PPUSH
12596: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12600: LD_EXP 26
12604: PPUSH
12605: LD_STRING DH-1-lab
12607: PPUSH
12608: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12612: LD_EXP 30
12616: PPUSH
12617: LD_STRING DA-2-lab
12619: PPUSH
12620: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12624: LD_EXP 26
12628: PPUSH
12629: LD_STRING DH-2-lab
12631: PPUSH
12632: CALL_OW 88
// DialogueOff ;
12636: CALL_OW 7
// end ;
12640: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12641: LD_EXP 31
12645: PPUSH
12646: CALL_OW 302
12650: PUSH
12651: LD_INT 22
12653: PUSH
12654: LD_INT 2
12656: PUSH
12657: EMPTY
12658: LIST
12659: LIST
12660: PUSH
12661: LD_INT 25
12663: PUSH
12664: LD_INT 15
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: PPUSH
12675: CALL_OW 69
12679: AND
12680: PUSH
12681: LD_INT 81
12683: PUSH
12684: LD_INT 2
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PPUSH
12691: CALL_OW 69
12695: NOT
12696: AND
12697: IFFALSE 12871
12699: GO 12701
12701: DISABLE
12702: LD_INT 0
12704: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12705: LD_ADDR_VAR 0 1
12709: PUSH
12710: LD_INT 22
12712: PUSH
12713: LD_INT 2
12715: PUSH
12716: EMPTY
12717: LIST
12718: LIST
12719: PUSH
12720: LD_INT 25
12722: PUSH
12723: LD_INT 15
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PPUSH
12734: CALL_OW 69
12738: ST_TO_ADDR
// InGameOn ;
12739: CALL_OW 8
// CenterNowOnUnits ( ape [ 1 ] ) ;
12743: LD_VAR 0 1
12747: PUSH
12748: LD_INT 1
12750: ARRAY
12751: PPUSH
12752: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12756: LD_VAR 0 1
12760: PUSH
12761: LD_INT 1
12763: ARRAY
12764: PPUSH
12765: CALL_OW 122
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12769: LD_VAR 0 1
12773: PUSH
12774: LD_INT 1
12776: ARRAY
12777: PPUSH
12778: LD_INT 35
12780: PPUSH
12781: LD_INT 28
12783: PPUSH
12784: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12788: LD_VAR 0 1
12792: PUSH
12793: LD_INT 1
12795: ARRAY
12796: PPUSH
12797: LD_INT 36
12799: PPUSH
12800: LD_INT 17
12802: PPUSH
12803: CALL_OW 171
// Say ( Kaia , DK-1-apesol ) ;
12807: LD_EXP 31
12811: PPUSH
12812: LD_STRING DK-1-apesol
12814: PPUSH
12815: CALL_OW 88
// Say ( Aviradze , DA-1-apesol ) ;
12819: LD_EXP 30
12823: PPUSH
12824: LD_STRING DA-1-apesol
12826: PPUSH
12827: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12831: LD_EXP 31
12835: PPUSH
12836: LD_STRING DK-2-apesol
12838: PPUSH
12839: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12843: LD_EXP 30
12847: PPUSH
12848: LD_STRING DA-2-apesol
12850: PPUSH
12851: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12855: LD_EXP 31
12859: PPUSH
12860: LD_STRING DK-3-apesol
12862: PPUSH
12863: CALL_OW 88
// InGameOff ;
12867: CALL_OW 9
// end ;
12871: PPOPN 1
12873: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12874: LD_EXP 32
12878: PPUSH
12879: CALL_OW 302
12883: PUSH
12884: LD_INT 22
12886: PUSH
12887: LD_INT 2
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: PUSH
12894: LD_INT 25
12896: PUSH
12897: LD_INT 16
12899: PUSH
12900: EMPTY
12901: LIST
12902: LIST
12903: PUSH
12904: EMPTY
12905: LIST
12906: LIST
12907: PPUSH
12908: CALL_OW 69
12912: AND
12913: PUSH
12914: LD_INT 81
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: EMPTY
12921: LIST
12922: LIST
12923: PPUSH
12924: CALL_OW 69
12928: NOT
12929: AND
12930: IFFALSE 13193
12932: GO 12934
12934: DISABLE
12935: LD_INT 0
12937: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
12938: LD_ADDR_VAR 0 1
12942: PUSH
12943: LD_INT 22
12945: PUSH
12946: LD_INT 2
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 25
12955: PUSH
12956: LD_INT 16
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PPUSH
12967: CALL_OW 69
12971: ST_TO_ADDR
// InGameOn ;
12972: CALL_OW 8
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
12976: LD_INT 5
12978: PPUSH
12979: LD_INT 35
12981: PPUSH
12982: LD_INT 22
12984: PPUSH
12985: LD_INT 1
12987: PPUSH
12988: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
12992: LD_EXP 32
12996: PPUSH
12997: LD_VAR 0 1
13001: PUSH
13002: LD_INT 1
13004: ARRAY
13005: PPUSH
13006: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
13010: LD_VAR 0 1
13014: PUSH
13015: LD_INT 1
13017: ARRAY
13018: PPUSH
13019: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
13023: LD_VAR 0 1
13027: PUSH
13028: LD_INT 1
13030: ARRAY
13031: PPUSH
13032: CALL_OW 122
// wait ( 0 0$2 ) ;
13036: LD_INT 70
13038: PPUSH
13039: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
13043: LD_EXP 32
13047: PPUSH
13048: LD_STRING DS-1-apeeng
13050: PPUSH
13051: CALL_OW 88
// if IsOk ( Kamil ) then
13055: LD_EXP 29
13059: PPUSH
13060: CALL_OW 302
13064: IFFALSE 13189
// begin Say ( Kamil , DKam-1-apeeng ) ;
13066: LD_EXP 29
13070: PPUSH
13071: LD_STRING DKam-1-apeeng
13073: PPUSH
13074: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
13078: LD_EXP 32
13082: PPUSH
13083: LD_STRING DS-2-apeeng
13085: PPUSH
13086: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
13090: LD_EXP 29
13094: PPUSH
13095: LD_STRING DKam-2-apeeng
13097: PPUSH
13098: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
13102: LD_EXP 32
13106: PPUSH
13107: LD_STRING DS-3-apeeng
13109: PPUSH
13110: CALL_OW 88
// if not IsOK ( Kaia ) then
13114: LD_EXP 31
13118: PPUSH
13119: CALL_OW 302
13123: NOT
13124: IFFALSE 13132
// begin InGameOff ;
13126: CALL_OW 9
// exit ;
13130: GO 13193
// end ; Say ( Kaia , DK-1-apeeng ) ;
13132: LD_EXP 31
13136: PPUSH
13137: LD_STRING DK-1-apeeng
13139: PPUSH
13140: CALL_OW 88
// if not IsOk ( Givi ) then
13144: LD_EXP 27
13148: PPUSH
13149: CALL_OW 302
13153: NOT
13154: IFFALSE 13165
// begin Video ( false ) ;
13156: LD_INT 0
13158: PPUSH
13159: CALL 1020 0 1
// exit ;
13163: GO 13193
// end ; Say ( Givi , DG-1-apeeng ) ;
13165: LD_EXP 27
13169: PPUSH
13170: LD_STRING DG-1-apeeng
13172: PPUSH
13173: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
13177: LD_EXP 31
13181: PPUSH
13182: LD_STRING DK-2-apeeng
13184: PPUSH
13185: CALL_OW 88
// end ; InGameOff ;
13189: CALL_OW 9
// end ;
13193: PPOPN 1
13195: END
// every 0 0$10 trigger farmerBaseReady and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) do
13196: LD_EXP 4
13200: PUSH
13201: LD_INT 22
13203: PUSH
13204: LD_INT 2
13206: PUSH
13207: EMPTY
13208: LIST
13209: LIST
13210: PUSH
13211: LD_INT 30
13213: PUSH
13214: LD_INT 0
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL_OW 69
13229: AND
13230: IFFALSE 13395
13232: GO 13234
13234: DISABLE
// begin wait ( 0 0$10 ) ;
13235: LD_INT 350
13237: PPUSH
13238: CALL_OW 67
// DialogueOn ;
13242: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
13246: LD_EXP 34
13250: PPUSH
13251: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
13255: LD_EXP 34
13259: PPUSH
13260: LD_STRING DF-1-distribution
13262: PPUSH
13263: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
13267: LD_EXP 26
13271: PPUSH
13272: LD_STRING DH-2-distribution
13274: PPUSH
13275: CALL_OW 88
// if IsOk ( Kaia ) then
13279: LD_EXP 31
13283: PPUSH
13284: CALL_OW 302
13288: IFFALSE 13349
// begin Say ( Kaia , DK-1-distribution ) ;
13290: LD_EXP 31
13294: PPUSH
13295: LD_STRING DK-1-distribution
13297: PPUSH
13298: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13302: LD_EXP 26
13306: PPUSH
13307: LD_STRING DH-1-distribution
13309: PPUSH
13310: CALL_OW 88
// if IsOk ( Givi ) then
13314: LD_EXP 27
13318: PPUSH
13319: CALL_OW 302
13323: IFFALSE 13349
// begin Say ( Givi , DG-1-distribution ) ;
13325: LD_EXP 27
13329: PPUSH
13330: LD_STRING DG-1-distribution
13332: PPUSH
13333: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13337: LD_EXP 26
13341: PPUSH
13342: LD_STRING DH-3-distribution
13344: PPUSH
13345: CALL_OW 88
// end ; end ; DialogueOff ;
13349: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13353: LD_STRING Crates1
13355: PPUSH
13356: CALL_OW 337
// farmerRequestedCrates := 300 ;
13360: LD_ADDR_EXP 14
13364: PUSH
13365: LD_INT 300
13367: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13368: LD_STRING FarmerCrates
13370: PPUSH
13371: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13375: LD_INT 10
13377: PPUSH
13378: LD_INT 1
13380: PPUSH
13381: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13385: LD_INT 108
13387: PPUSH
13388: LD_INT 61
13390: PPUSH
13391: CALL_OW 86
// end ;
13395: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13396: LD_EXP 6
13400: PUSH
13401: LD_INT 22
13403: PUSH
13404: LD_INT 2
13406: PUSH
13407: EMPTY
13408: LIST
13409: LIST
13410: PUSH
13411: LD_INT 3
13413: PUSH
13414: LD_INT 57
13416: PUSH
13417: EMPTY
13418: LIST
13419: PUSH
13420: EMPTY
13421: LIST
13422: LIST
13423: PUSH
13424: LD_INT 2
13426: PUSH
13427: LD_INT 30
13429: PUSH
13430: LD_INT 6
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: PUSH
13437: LD_INT 30
13439: PUSH
13440: LD_INT 7
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: LIST
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: LIST
13456: PPUSH
13457: CALL_OW 69
13461: AND
13462: PUSH
13463: LD_INT 22
13465: PUSH
13466: LD_INT 2
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: PUSH
13473: LD_INT 3
13475: PUSH
13476: LD_INT 57
13478: PUSH
13479: EMPTY
13480: LIST
13481: PUSH
13482: EMPTY
13483: LIST
13484: LIST
13485: PUSH
13486: LD_INT 30
13488: PUSH
13489: LD_INT 4
13491: PUSH
13492: EMPTY
13493: LIST
13494: LIST
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: LIST
13500: PPUSH
13501: CALL_OW 69
13505: AND
13506: IFFALSE 13670
13508: GO 13510
13510: DISABLE
13511: LD_INT 0
13513: PPUSH
// begin wait ( 0 0$10 ) ;
13514: LD_INT 350
13516: PPUSH
13517: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13521: LD_ADDR_VAR 0 1
13525: PUSH
13526: LD_EXP 40
13530: PPUSH
13531: LD_INT 26
13533: PUSH
13534: LD_INT 1
13536: PUSH
13537: EMPTY
13538: LIST
13539: LIST
13540: PUSH
13541: LD_INT 25
13543: PUSH
13544: LD_INT 2
13546: PUSH
13547: EMPTY
13548: LIST
13549: LIST
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PPUSH
13555: CALL_OW 72
13559: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13560: LD_EXP 26
13564: PPUSH
13565: LD_STRING DH-1-task
13567: PPUSH
13568: CALL_OW 88
// if IsOk ( Sophia ) then
13572: LD_EXP 32
13576: PPUSH
13577: CALL_OW 302
13581: IFFALSE 13621
// begin Say ( Sophia , DS-1-task ) ;
13583: LD_EXP 32
13587: PPUSH
13588: LD_STRING DS-1-task
13590: PPUSH
13591: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13595: LD_EXP 32
13599: PPUSH
13600: LD_STRING DS-2-task
13602: PPUSH
13603: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13607: LD_EXP 26
13611: PPUSH
13612: LD_STRING DH-2-task
13614: PPUSH
13615: CALL_OW 88
// end else
13619: GO 13655
// if eng then
13621: LD_VAR 0 1
13625: IFFALSE 13655
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13627: LD_VAR 0 1
13631: PUSH
13632: LD_INT 1
13634: ARRAY
13635: PPUSH
13636: LD_STRING DArm-1-task
13638: PPUSH
13639: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13643: LD_EXP 26
13647: PPUSH
13648: LD_STRING DH-2-task
13650: PPUSH
13651: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13655: LD_STRING BaseConstructed
13657: PPUSH
13658: CALL_OW 337
// allowConvoys := true ;
13662: LD_ADDR_EXP 11
13666: PUSH
13667: LD_INT 1
13669: ST_TO_ADDR
// end ;
13670: PPOPN 1
13672: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13673: LD_INT 22
13675: PUSH
13676: LD_INT 4
13678: PUSH
13679: EMPTY
13680: LIST
13681: LIST
13682: PUSH
13683: LD_INT 34
13685: PUSH
13686: LD_INT 12
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PUSH
13693: EMPTY
13694: LIST
13695: LIST
13696: PPUSH
13697: CALL_OW 69
13701: IFFALSE 13869
13703: GO 13705
13705: DISABLE
13706: LD_INT 0
13708: PPUSH
13709: PPUSH
13710: PPUSH
// begin wait ( 0 0$2 ) ;
13711: LD_INT 70
13713: PPUSH
13714: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13718: LD_ADDR_VAR 0 1
13722: PUSH
13723: LD_INT 22
13725: PUSH
13726: LD_INT 4
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: PUSH
13733: LD_INT 34
13735: PUSH
13736: LD_INT 12
13738: PUSH
13739: EMPTY
13740: LIST
13741: LIST
13742: PUSH
13743: EMPTY
13744: LIST
13745: LIST
13746: PPUSH
13747: CALL_OW 69
13751: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13752: LD_ADDR_VAR 0 2
13756: PUSH
13757: LD_VAR 0 1
13761: PUSH
13762: LD_INT 1
13764: ARRAY
13765: PPUSH
13766: CALL_OW 250
13770: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13771: LD_ADDR_VAR 0 3
13775: PUSH
13776: LD_VAR 0 1
13780: PUSH
13781: LD_INT 1
13783: ARRAY
13784: PPUSH
13785: CALL_OW 251
13789: ST_TO_ADDR
// DialogueOn ;
13790: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13794: LD_VAR 0 2
13798: PPUSH
13799: LD_VAR 0 3
13803: PPUSH
13804: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13808: LD_VAR 0 2
13812: PPUSH
13813: LD_VAR 0 3
13817: PPUSH
13818: LD_INT 2
13820: PPUSH
13821: LD_INT 6
13823: NEG
13824: PPUSH
13825: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13829: LD_INT 10
13831: PPUSH
13832: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13836: LD_EXP 26
13840: PPUSH
13841: LD_STRING DH-1-seecargo
13843: PPUSH
13844: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13848: LD_VAR 0 2
13852: PPUSH
13853: LD_VAR 0 3
13857: PPUSH
13858: LD_INT 2
13860: PPUSH
13861: CALL_OW 331
// DialogueOff ;
13865: CALL_OW 7
// end ;
13869: PPOPN 3
13871: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13872: LD_EXP 4
13876: PUSH
13877: LD_EXP 13
13881: PUSH
13882: LD_INT 300
13884: GREATEREQUAL
13885: AND
13886: IFFALSE 13958
13888: GO 13890
13890: DISABLE
// begin DialogueOn ;
13891: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13895: LD_EXP 34
13899: PPUSH
13900: LD_STRING DF-1-delivery-2
13902: PPUSH
13903: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13907: LD_EXP 26
13911: PPUSH
13912: LD_STRING DH-1-delivery-2
13914: PPUSH
13915: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
13919: LD_EXP 34
13923: PPUSH
13924: LD_STRING DF-2-delivery-2
13926: PPUSH
13927: CALL_OW 94
// DialogueOff ;
13931: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
13935: LD_STRING Crates2
13937: PPUSH
13938: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13942: LD_ADDR_EXP 15
13946: PUSH
13947: LD_INT 63000
13949: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
13950: LD_ADDR_EXP 14
13954: PUSH
13955: LD_INT 600
13957: ST_TO_ADDR
// end ;
13958: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 do
13959: LD_EXP 4
13963: PUSH
13964: LD_EXP 13
13968: PUSH
13969: LD_INT 600
13971: GREATEREQUAL
13972: AND
13973: IFFALSE 14139
13975: GO 13977
13977: DISABLE
// begin DialogueOn ;
13978: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
13982: LD_EXP 34
13986: PPUSH
13987: LD_STRING DF-1-delivery-3
13989: PPUSH
13990: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
13994: LD_EXP 26
13998: PPUSH
13999: LD_STRING DH-1-delivery-3
14001: PPUSH
14002: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
14006: LD_EXP 34
14010: PPUSH
14011: LD_STRING DF-2-delivery-3
14013: PPUSH
14014: CALL_OW 94
// if IsOk ( Kaia ) then
14018: LD_EXP 31
14022: PPUSH
14023: CALL_OW 302
14027: IFFALSE 14077
// begin Say ( Kaia , DK-1-delivery-3 ) ;
14029: LD_EXP 31
14033: PPUSH
14034: LD_STRING DK-1-delivery-3
14036: PPUSH
14037: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
14041: LD_EXP 26
14045: PPUSH
14046: LD_STRING DH-2-delivery-3
14048: PPUSH
14049: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
14053: LD_EXP 27
14057: PPUSH
14058: LD_STRING DG-1-delivery-3
14060: PPUSH
14061: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
14065: LD_EXP 28
14069: PPUSH
14070: LD_STRING DM-1-delivery-3
14072: PPUSH
14073: CALL_OW 88
// end ; DialogueOff ;
14077: CALL_OW 7
// if Difficulty = 2 then
14081: LD_OWVAR 67
14085: PUSH
14086: LD_INT 2
14088: EQUAL
14089: IFFALSE 14116
// begin ChangeMissionObjectives ( Crates3 ) ;
14091: LD_STRING Crates3
14093: PPUSH
14094: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14098: LD_ADDR_EXP 15
14102: PUSH
14103: LD_INT 63000
14105: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
14106: LD_ADDR_EXP 14
14110: PUSH
14111: LD_INT 900
14113: ST_TO_ADDR
// end else
14114: GO 14139
// begin ChangeMissionObjectives ( Crates4 ) ;
14116: LD_STRING Crates4
14118: PPUSH
14119: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14123: LD_ADDR_EXP 15
14127: PUSH
14128: LD_INT 63000
14130: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
14131: LD_ADDR_EXP 14
14135: PUSH
14136: LD_INT 1200
14138: ST_TO_ADDR
// end ; end ;
14139: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
14140: LD_EXP 4
14144: PUSH
14145: LD_EXP 13
14149: PUSH
14150: LD_INT 600
14152: PUSH
14153: LD_INT 900
14155: PUSH
14156: LD_INT 1200
14158: PUSH
14159: EMPTY
14160: LIST
14161: LIST
14162: LIST
14163: PUSH
14164: LD_OWVAR 67
14168: ARRAY
14169: GREATEREQUAL
14170: AND
14171: PUSH
14172: LD_EXP 14
14176: PUSH
14177: LD_EXP 15
14181: LESSEQUAL
14182: AND
14183: IFFALSE 14250
14185: GO 14187
14187: DISABLE
// begin retreatAllowed := true ;
14188: LD_ADDR_EXP 10
14192: PUSH
14193: LD_INT 1
14195: ST_TO_ADDR
// display_strings := [ ] ;
14196: LD_ADDR_OWVAR 47
14200: PUSH
14201: EMPTY
14202: ST_TO_ADDR
// DialogueOn ;
14203: CALL_OW 6
// InGameOn ;
14207: CALL_OW 8
// SayRadio ( Omar , DO-radio-end ) ;
14211: LD_EXP 35
14215: PPUSH
14216: LD_STRING DO-radio-end
14218: PPUSH
14219: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
14223: LD_EXP 26
14227: PPUSH
14228: LD_STRING DH-1-radio-end
14230: PPUSH
14231: CALL_OW 88
// InGameOff ;
14235: CALL_OW 9
// DialogueOff ;
14239: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
14243: LD_STRING Retreat
14245: PPUSH
14246: CALL_OW 337
// end ;
14250: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
14251: LD_EXP 10
14255: IFFALSE 14390
14257: GO 14259
14259: DISABLE
14260: LD_INT 0
14262: PPUSH
14263: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
14264: LD_INT 10
14266: PPUSH
14267: LD_INT 0
14269: PPUSH
14270: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
14274: LD_ADDR_VAR 0 1
14278: PUSH
14279: LD_EXP 37
14283: PPUSH
14284: LD_INT 25
14286: PUSH
14287: LD_INT 2
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: PPUSH
14294: CALL_OW 72
14298: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14299: LD_VAR 0 1
14303: PUSH
14304: LD_INT 102
14306: PPUSH
14307: LD_INT 69
14309: PPUSH
14310: CALL_OW 428
14314: PUSH
14315: LD_INT 0
14317: EQUAL
14318: AND
14319: IFFALSE 14386
// begin for i in tmp do
14321: LD_ADDR_VAR 0 2
14325: PUSH
14326: LD_VAR 0 1
14330: PUSH
14331: FOR_IN
14332: IFFALSE 14356
// if IsInUnit ( i ) then
14334: LD_VAR 0 2
14338: PPUSH
14339: CALL_OW 310
14343: IFFALSE 14354
// ComExitBuilding ( i ) ;
14345: LD_VAR 0 2
14349: PPUSH
14350: CALL_OW 122
14354: GO 14331
14356: POP
14357: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14358: LD_VAR 0 1
14362: PPUSH
14363: LD_INT 31
14365: PPUSH
14366: LD_INT 102
14368: PPUSH
14369: LD_INT 69
14371: PPUSH
14372: LD_INT 2
14374: PPUSH
14375: CALL_OW 205
// wait ( 0 0$3 ) ;
14379: LD_INT 105
14381: PPUSH
14382: CALL_OW 67
// end ; StartCargoEvacuation ;
14386: CALL 4481 0 0
// end ;
14390: PPOPN 2
14392: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14393: LD_EXP 10
14397: NOT
14398: PUSH
14399: LD_INT 5
14401: PPUSH
14402: CALL_OW 301
14406: AND
14407: IFFALSE 14431
14409: GO 14411
14411: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
14412: LD_EXP 34
14416: PPUSH
14417: LD_STRING DF-1-failure
14419: PPUSH
14420: CALL_OW 94
// YouLost ( FarmerDepot ) ;
14424: LD_STRING FarmerDepot
14426: PPUSH
14427: CALL_OW 104
// end ;
14431: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 and not FilterAllUnits ( [ f_enemy , 2 ] ) do var i , max , tmp ;
14432: LD_EXP 10
14436: PUSH
14437: LD_EXP 26
14441: PPUSH
14442: LD_EXP 34
14446: PPUSH
14447: CALL_OW 296
14451: PUSH
14452: LD_INT 6
14454: LESS
14455: AND
14456: PUSH
14457: LD_INT 81
14459: PUSH
14460: LD_INT 2
14462: PUSH
14463: EMPTY
14464: LIST
14465: LIST
14466: PPUSH
14467: CALL_OW 69
14471: NOT
14472: AND
14473: IFFALSE 15070
14475: GO 14477
14477: DISABLE
14478: LD_INT 0
14480: PPUSH
14481: PPUSH
14482: PPUSH
// begin allowConvoys := false ;
14483: LD_ADDR_EXP 11
14487: PUSH
14488: LD_INT 0
14490: ST_TO_ADDR
// InGameOn ;
14491: CALL_OW 8
// ComTurnUnit ( Heike , Farmer ) ;
14495: LD_EXP 26
14499: PPUSH
14500: LD_EXP 34
14504: PPUSH
14505: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14509: LD_EXP 34
14513: PPUSH
14514: LD_EXP 26
14518: PPUSH
14519: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14523: LD_EXP 34
14527: PPUSH
14528: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14532: LD_EXP 26
14536: PPUSH
14537: LD_STRING DH-1-end
14539: PPUSH
14540: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14544: LD_EXP 34
14548: PPUSH
14549: LD_STRING DF-1-end
14551: PPUSH
14552: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14556: LD_EXP 34
14560: PPUSH
14561: LD_STRING DF-2-end
14563: PPUSH
14564: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14568: LD_EXP 26
14572: PPUSH
14573: LD_STRING DH-2-end
14575: PPUSH
14576: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14580: LD_EXP 34
14584: PPUSH
14585: LD_STRING DF-3-end
14587: PPUSH
14588: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14592: LD_EXP 26
14596: PPUSH
14597: LD_STRING DH-3-end
14599: PPUSH
14600: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14604: LD_EXP 27
14608: PPUSH
14609: LD_STRING DG-1-end
14611: PPUSH
14612: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14616: LD_EXP 26
14620: PPUSH
14621: LD_STRING DH-4-end
14623: PPUSH
14624: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14628: LD_EXP 34
14632: PPUSH
14633: LD_STRING DF-4-end
14635: PPUSH
14636: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14640: LD_EXP 26
14644: PPUSH
14645: LD_STRING DH-5-end
14647: PPUSH
14648: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14652: LD_EXP 34
14656: PPUSH
14657: LD_STRING DF-5-end
14659: PPUSH
14660: CALL_OW 88
// InGameOff ;
14664: CALL_OW 9
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14668: LD_ADDR_VAR 0 2
14672: PUSH
14673: LD_INT 4
14675: PUSH
14676: LD_INT 3
14678: PUSH
14679: LD_INT 2
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: LIST
14686: PUSH
14687: LD_OWVAR 67
14691: ARRAY
14692: ST_TO_ADDR
// if farmerSquad < max then
14693: LD_EXP 37
14697: PUSH
14698: LD_VAR 0 2
14702: LESS
14703: IFFALSE 14715
// max := farmerSquad ;
14705: LD_ADDR_VAR 0 2
14709: PUSH
14710: LD_EXP 37
14714: ST_TO_ADDR
// for i := 1 to max do
14715: LD_ADDR_VAR 0 1
14719: PUSH
14720: DOUBLE
14721: LD_INT 1
14723: DEC
14724: ST_TO_ADDR
14725: LD_VAR 0 2
14729: PUSH
14730: FOR_TO
14731: IFFALSE 14769
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14733: LD_EXP 37
14737: PUSH
14738: LD_INT 1
14740: ARRAY
14741: PPUSH
14742: LD_INT 2
14744: PPUSH
14745: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14749: LD_ADDR_EXP 37
14753: PUSH
14754: LD_EXP 37
14758: PPUSH
14759: LD_INT 1
14761: PPUSH
14762: CALL_OW 3
14766: ST_TO_ADDR
// end ;
14767: GO 14730
14769: POP
14770: POP
// for i in Farmer ^ farmerSquad do
14771: LD_ADDR_VAR 0 1
14775: PUSH
14776: LD_EXP 34
14780: PUSH
14781: LD_EXP 37
14785: ADD
14786: PUSH
14787: FOR_IN
14788: IFFALSE 14827
// begin if IsInUnit ( i ) then
14790: LD_VAR 0 1
14794: PPUSH
14795: CALL_OW 310
14799: IFFALSE 14810
// ComExitBuilding ( i ) ;
14801: LD_VAR 0 1
14805: PPUSH
14806: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14810: LD_VAR 0 1
14814: PPUSH
14815: LD_INT 102
14817: PPUSH
14818: LD_INT 7
14820: PPUSH
14821: CALL_OW 171
// end ;
14825: GO 14787
14827: POP
14828: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14829: LD_ADDR_VAR 0 1
14833: PUSH
14834: LD_INT 22
14836: PUSH
14837: LD_INT 5
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: PUSH
14844: LD_INT 21
14846: PUSH
14847: LD_INT 3
14849: PUSH
14850: EMPTY
14851: LIST
14852: LIST
14853: PUSH
14854: EMPTY
14855: LIST
14856: LIST
14857: PPUSH
14858: CALL_OW 69
14862: PUSH
14863: LD_INT 5
14865: DIFF
14866: PUSH
14867: FOR_IN
14868: IFFALSE 14884
// SetSide ( i , 2 ) ;
14870: LD_VAR 0 1
14874: PPUSH
14875: LD_INT 2
14877: PPUSH
14878: CALL_OW 235
14882: GO 14867
14884: POP
14885: POP
// repeat wait ( 0 0$1 ) ;
14886: LD_INT 35
14888: PPUSH
14889: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
14893: LD_ADDR_VAR 0 3
14897: PUSH
14898: LD_EXP 34
14902: PUSH
14903: LD_EXP 37
14907: ADD
14908: PPUSH
14909: LD_INT 95
14911: PUSH
14912: LD_INT 3
14914: PUSH
14915: EMPTY
14916: LIST
14917: LIST
14918: PPUSH
14919: CALL_OW 72
14923: ST_TO_ADDR
// if tmp then
14924: LD_VAR 0 3
14928: IFFALSE 14972
// for i in tmp do
14930: LD_ADDR_VAR 0 1
14934: PUSH
14935: LD_VAR 0 3
14939: PUSH
14940: FOR_IN
14941: IFFALSE 14970
// begin farmerSquad := farmerSquad diff i ;
14943: LD_ADDR_EXP 37
14947: PUSH
14948: LD_EXP 37
14952: PUSH
14953: LD_VAR 0 1
14957: DIFF
14958: ST_TO_ADDR
// RemoveUnit ( i ) ;
14959: LD_VAR 0 1
14963: PPUSH
14964: CALL_OW 64
// end ;
14968: GO 14940
14970: POP
14971: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
14972: LD_EXP 37
14976: PUSH
14977: EMPTY
14978: EQUAL
14979: PUSH
14980: LD_EXP 34
14984: PPUSH
14985: CALL_OW 305
14989: NOT
14990: AND
14991: IFFALSE 14886
// if farmerHumanLoseCounter = 0 then
14993: LD_EXP 18
14997: PUSH
14998: LD_INT 0
15000: EQUAL
15001: IFFALSE 15010
// SetAchievement ( ACH_BABY ) ;
15003: LD_STRING ACH_BABY
15005: PPUSH
15006: CALL_OW 543
// wait ( 1 1$00 ) ;
15010: LD_INT 2100
15012: PPUSH
15013: CALL_OW 67
// SendAttack ;
15017: CALL 6938 0 0
// wait ( [ 2 2$00 , 1 1$30 , 1 1$00 ] [ Difficulty ] ) ;
15021: LD_INT 4200
15023: PUSH
15024: LD_INT 3150
15026: PUSH
15027: LD_INT 2100
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: LIST
15034: PUSH
15035: LD_OWVAR 67
15039: ARRAY
15040: PPUSH
15041: CALL_OW 67
// SendAttack ;
15045: CALL 6938 0 0
// if Difficulty > 2 then
15049: LD_OWVAR 67
15053: PUSH
15054: LD_INT 2
15056: GREATER
15057: IFFALSE 15070
// begin wait ( 2 2$30 ) ;
15059: LD_INT 5250
15061: PPUSH
15062: CALL_OW 67
// SendAttack ;
15066: CALL 6938 0 0
// end ; end ;
15070: PPOPN 3
15072: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
15073: LD_EXP 15
15077: PUSH
15078: LD_INT 18900
15080: LESSEQUAL
15081: IFFALSE 15130
15083: GO 15085
15085: DISABLE
// begin DialogueOn ;
15086: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
15090: LD_EXP 34
15094: PPUSH
15095: LD_STRING DF-1-distribution-a
15097: PPUSH
15098: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
15102: LD_EXP 26
15106: PPUSH
15107: LD_STRING DH-1-distribution-a
15109: PPUSH
15110: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
15114: LD_EXP 34
15118: PPUSH
15119: LD_STRING DF-2-distribution-a
15121: PPUSH
15122: CALL_OW 94
// DialogueOff ;
15126: CALL_OW 7
// end ;
15130: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
15131: LD_EXP 15
15135: PUSH
15136: LD_INT 0
15138: LESSEQUAL
15139: IFFALSE 15171
15141: GO 15143
15143: DISABLE
// begin DialogueOn ;
15144: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
15148: LD_EXP 34
15152: PPUSH
15153: LD_STRING DF-3-distribution-a
15155: PPUSH
15156: CALL_OW 94
// YouLost ( Distribution ) ;
15160: LD_STRING Distribution
15162: PPUSH
15163: CALL_OW 104
// DialogueOff ;
15167: CALL_OW 7
// end ;
15171: END
// every 0 0$1 trigger vehCounter >= 2 do
15172: LD_EXP 20
15176: PUSH
15177: LD_INT 2
15179: GREATEREQUAL
15180: IFFALSE 15192
15182: GO 15184
15184: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
15185: LD_STRING VehConstructed
15187: PPUSH
15188: CALL_OW 337
15192: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
15193: LD_INT 22
15195: PUSH
15196: LD_INT 2
15198: PUSH
15199: EMPTY
15200: LIST
15201: LIST
15202: PUSH
15203: LD_INT 34
15205: PUSH
15206: LD_INT 12
15208: PUSH
15209: EMPTY
15210: LIST
15211: LIST
15212: PUSH
15213: EMPTY
15214: LIST
15215: LIST
15216: PPUSH
15217: CALL_OW 69
15221: IFFALSE 15281
15223: GO 15225
15225: DISABLE
// begin DialogueOn ;
15226: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
15230: LD_EXP 26
15234: PPUSH
15235: LD_STRING DH-1-truck
15237: PPUSH
15238: CALL_OW 88
// if IsOk ( Markov ) then
15242: LD_EXP 33
15246: PPUSH
15247: CALL_OW 302
15251: IFFALSE 15277
// begin Say ( Markov , DMar-1-truck ) ;
15253: LD_EXP 33
15257: PPUSH
15258: LD_STRING DMar-1-truck
15260: PPUSH
15261: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
15265: LD_EXP 26
15269: PPUSH
15270: LD_STRING DH-2-truck
15272: PPUSH
15273: CALL_OW 88
// end ; DialogueOff ;
15277: CALL_OW 7
// end ;
15281: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
15282: LD_INT 0
15284: PPUSH
15285: PPUSH
15286: PPUSH
// if IsOk ( Givi ) then
15287: LD_EXP 27
15291: PPUSH
15292: CALL_OW 302
15296: IFFALSE 15312
// begin Say ( Givi , DG-1-nocargo ) ;
15298: LD_EXP 27
15302: PPUSH
15303: LD_STRING DG-1-nocargo
15305: PPUSH
15306: CALL_OW 88
// exit ;
15310: GO 15408
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15312: LD_ADDR_VAR 0 2
15316: PUSH
15317: LD_EXP 40
15321: PPUSH
15322: LD_INT 26
15324: PUSH
15325: LD_INT 1
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: PPUSH
15332: CALL_OW 72
15336: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15337: LD_ADDR_VAR 0 3
15341: PUSH
15342: LD_EXP 40
15346: PPUSH
15347: LD_INT 26
15349: PUSH
15350: LD_INT 2
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: PPUSH
15357: CALL_OW 72
15361: ST_TO_ADDR
// if randomMen then
15362: LD_VAR 0 2
15366: IFFALSE 15386
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15368: LD_VAR 0 2
15372: PUSH
15373: LD_INT 1
15375: ARRAY
15376: PPUSH
15377: LD_STRING DArm-1-nocargo
15379: PPUSH
15380: CALL_OW 88
15384: GO 15408
// if randomWomen then
15386: LD_VAR 0 3
15390: IFFALSE 15408
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15392: LD_VAR 0 3
15396: PUSH
15397: LD_INT 1
15399: ARRAY
15400: PPUSH
15401: LD_STRING DArf-1-nocargo
15403: PPUSH
15404: CALL_OW 88
// end ;
15408: LD_VAR 0 1
15412: RET
// export function IncomingAttack ; begin
15413: LD_INT 0
15415: PPUSH
// if attackWave = 1 then
15416: LD_EXP 17
15420: PUSH
15421: LD_INT 1
15423: EQUAL
15424: IFFALSE 15495
// begin DialogueOn ;
15426: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15430: LD_EXP 35
15434: PPUSH
15435: LD_STRING DO-1-radio-1
15437: PPUSH
15438: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15442: LD_EXP 26
15446: PPUSH
15447: LD_STRING DH-1-radio-1-
15449: PPUSH
15450: CALL_OW 88
// if IsOk ( Markov ) then
15454: LD_EXP 33
15458: PPUSH
15459: CALL_OW 302
15463: IFFALSE 15489
// begin Say ( Markov , DMar-1-radio-1 ) ;
15465: LD_EXP 33
15469: PPUSH
15470: LD_STRING DMar-1-radio-1
15472: PPUSH
15473: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15477: LD_EXP 26
15481: PPUSH
15482: LD_STRING DH-2-radio-1
15484: PPUSH
15485: CALL_OW 88
// end ; DialogueOff ;
15489: CALL_OW 7
// end else
15493: GO 15519
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15495: LD_EXP 35
15499: PPUSH
15500: LD_STRING DO-1-radio-u
15502: PPUSH
15503: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15507: LD_EXP 26
15511: PPUSH
15512: LD_STRING DH-1-radio-u
15514: PPUSH
15515: CALL_OW 88
// end ; end ;
15519: LD_VAR 0 1
15523: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15524: LD_EXP 42
15528: PPUSH
15529: LD_INT 95
15531: PUSH
15532: LD_INT 8
15534: PUSH
15535: EMPTY
15536: LIST
15537: LIST
15538: PPUSH
15539: CALL_OW 72
15543: IFFALSE 15646
15545: GO 15547
15547: DISABLE
15548: LD_INT 0
15550: PPUSH
// begin enable ;
15551: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15552: LD_ADDR_VAR 0 1
15556: PUSH
15557: LD_EXP 42
15561: PPUSH
15562: LD_INT 95
15564: PUSH
15565: LD_INT 8
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PPUSH
15572: CALL_OW 72
15576: PUSH
15577: FOR_IN
15578: IFFALSE 15607
// begin usForces := usForces diff i ;
15580: LD_ADDR_EXP 42
15584: PUSH
15585: LD_EXP 42
15589: PUSH
15590: LD_VAR 0 1
15594: DIFF
15595: ST_TO_ADDR
// RemoveUnit ( i ) ;
15596: LD_VAR 0 1
15600: PPUSH
15601: CALL_OW 64
// end ;
15605: GO 15577
15607: POP
15608: POP
// if not americanHasEscaped and attackWave = 1 then
15609: LD_EXP 7
15613: NOT
15614: PUSH
15615: LD_EXP 17
15619: PUSH
15620: LD_INT 1
15622: EQUAL
15623: AND
15624: IFFALSE 15646
// begin americanHasEscaped := true ;
15626: LD_ADDR_EXP 7
15630: PUSH
15631: LD_INT 1
15633: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15634: LD_EXP 26
15638: PPUSH
15639: LD_STRING DH-2-assault-a
15641: PPUSH
15642: CALL_OW 88
// end ; end ;
15646: PPOPN 1
15648: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) do
15649: LD_INT 4
15651: PPUSH
15652: LD_INT 22
15654: PUSH
15655: LD_INT 1
15657: PUSH
15658: EMPTY
15659: LIST
15660: LIST
15661: PPUSH
15662: CALL_OW 70
15666: IFFALSE 15683
15668: GO 15670
15670: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15671: LD_EXP 34
15675: PPUSH
15676: LD_STRING DF-1-attack
15678: PPUSH
15679: CALL_OW 94
15683: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15684: LD_INT 5
15686: PPUSH
15687: CALL_OW 255
15691: PUSH
15692: LD_INT 2
15694: EQUAL
15695: IFFALSE 15707
15697: GO 15699
15699: DISABLE
// YouLost ( Attack ) ;
15700: LD_STRING Attack
15702: PPUSH
15703: CALL_OW 104
15707: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 90 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot ;
15708: LD_INT 22
15710: PUSH
15711: LD_INT 1
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: PUSH
15718: LD_INT 21
15720: PUSH
15721: LD_INT 1
15723: PUSH
15724: EMPTY
15725: LIST
15726: LIST
15727: PUSH
15728: EMPTY
15729: LIST
15730: LIST
15731: PPUSH
15732: CALL_OW 69
15736: NOT
15737: PUSH
15738: LD_INT 22
15740: PUSH
15741: LD_INT 4
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: PPUSH
15748: CALL_OW 69
15752: NOT
15753: AND
15754: PUSH
15755: LD_EXP 10
15759: NOT
15760: AND
15761: PUSH
15762: LD_EXP 13
15766: PUSH
15767: LD_INT 90
15769: GREATER
15770: AND
15771: PUSH
15772: LD_INT 7
15774: PPUSH
15775: LD_INT 22
15777: PUSH
15778: LD_INT 2
15780: PUSH
15781: EMPTY
15782: LIST
15783: LIST
15784: PUSH
15785: LD_INT 21
15787: PUSH
15788: LD_INT 1
15790: PUSH
15791: EMPTY
15792: LIST
15793: LIST
15794: PUSH
15795: EMPTY
15796: LIST
15797: LIST
15798: PPUSH
15799: CALL_OW 70
15803: AND
15804: PUSH
15805: LD_INT 22
15807: PUSH
15808: LD_INT 2
15810: PUSH
15811: EMPTY
15812: LIST
15813: LIST
15814: PUSH
15815: LD_INT 50
15817: PUSH
15818: EMPTY
15819: LIST
15820: PUSH
15821: LD_INT 30
15823: PUSH
15824: LD_INT 0
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: LIST
15835: PPUSH
15836: CALL_OW 69
15840: AND
15841: IFFALSE 16542
15843: GO 15845
15845: DISABLE
15846: LD_INT 0
15848: PPUSH
15849: PPUSH
15850: PPUSH
15851: PPUSH
15852: PPUSH
// begin depot := usDepot ;
15853: LD_ADDR_VAR 0 5
15857: PUSH
15858: LD_INT 11
15860: ST_TO_ADDR
// if not depot then
15861: LD_VAR 0 5
15865: NOT
15866: IFFALSE 15906
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
15868: LD_ADDR_VAR 0 5
15872: PUSH
15873: LD_INT 22
15875: PUSH
15876: LD_INT 2
15878: PUSH
15879: EMPTY
15880: LIST
15881: LIST
15882: PUSH
15883: LD_INT 30
15885: PUSH
15886: LD_INT 0
15888: PUSH
15889: EMPTY
15890: LIST
15891: LIST
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: PPUSH
15897: CALL_OW 69
15901: PUSH
15902: LD_INT 1
15904: ARRAY
15905: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15906: LD_ADDR_VAR 0 1
15910: PUSH
15911: LD_EXP 40
15915: PPUSH
15916: LD_INT 26
15918: PUSH
15919: LD_INT 1
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PPUSH
15926: CALL_OW 72
15930: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15931: LD_ADDR_VAR 0 2
15935: PUSH
15936: LD_EXP 40
15940: PPUSH
15941: LD_INT 26
15943: PUSH
15944: LD_INT 2
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: PPUSH
15951: CALL_OW 72
15955: ST_TO_ADDR
// if IsOk ( Kaia ) then
15956: LD_EXP 31
15960: PPUSH
15961: CALL_OW 302
15965: IFFALSE 15986
// speaker := [ Kaia , DK ] else
15967: LD_ADDR_VAR 0 3
15971: PUSH
15972: LD_EXP 31
15976: PUSH
15977: LD_STRING DK
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: ST_TO_ADDR
15984: GO 16066
// if randomMen then
15986: LD_VAR 0 1
15990: IFFALSE 16025
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
15992: LD_ADDR_VAR 0 3
15996: PUSH
15997: LD_VAR 0 1
16001: PUSH
16002: LD_INT 1
16004: PPUSH
16005: LD_VAR 0 1
16009: PPUSH
16010: CALL_OW 12
16014: ARRAY
16015: PUSH
16016: LD_STRING DArm
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: ST_TO_ADDR
16023: GO 16066
// if randomWomen then
16025: LD_VAR 0 2
16029: IFFALSE 16064
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
16031: LD_ADDR_VAR 0 3
16035: PUSH
16036: LD_VAR 0 2
16040: PUSH
16041: LD_INT 1
16043: PPUSH
16044: LD_VAR 0 2
16048: PPUSH
16049: CALL_OW 12
16053: ARRAY
16054: PUSH
16055: LD_STRING DArf
16057: PUSH
16058: EMPTY
16059: LIST
16060: LIST
16061: ST_TO_ADDR
16062: GO 16066
// exit ;
16064: GO 16542
// if IsInUnit ( speaker [ 1 ] ) then
16066: LD_VAR 0 3
16070: PUSH
16071: LD_INT 1
16073: ARRAY
16074: PPUSH
16075: CALL_OW 310
16079: IFFALSE 16102
// place := IsInUnit ( speaker [ 1 ] ) else
16081: LD_ADDR_VAR 0 4
16085: PUSH
16086: LD_VAR 0 3
16090: PUSH
16091: LD_INT 1
16093: ARRAY
16094: PPUSH
16095: CALL_OW 310
16099: ST_TO_ADDR
16100: GO 16116
// place := speaker [ 1 ] ;
16102: LD_ADDR_VAR 0 4
16106: PUSH
16107: LD_VAR 0 3
16111: PUSH
16112: LD_INT 1
16114: ARRAY
16115: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
16116: LD_VAR 0 4
16120: PPUSH
16121: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
16125: LD_VAR 0 4
16129: PPUSH
16130: CALL_OW 250
16134: PPUSH
16135: LD_VAR 0 4
16139: PPUSH
16140: CALL_OW 251
16144: PPUSH
16145: CALL 2989 0 2
// wait ( 0 0$2 ) ;
16149: LD_INT 70
16151: PPUSH
16152: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
16156: LD_EXP 36
16160: PPUSH
16161: CALL_OW 305
16165: NOT
16166: IFFALSE 16170
// exit ;
16168: GO 16542
// allowConvoys := false ;
16170: LD_ADDR_EXP 11
16174: PUSH
16175: LD_INT 0
16177: ST_TO_ADDR
// InGameOn ;
16178: CALL_OW 8
// wait ( 0 0$1 ) ;
16182: LD_INT 35
16184: PPUSH
16185: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
16189: LD_EXP 36
16193: PPUSH
16194: LD_STRING DI-1-land
16196: PPUSH
16197: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
16201: LD_VAR 0 3
16205: PUSH
16206: LD_INT 1
16208: ARRAY
16209: PPUSH
16210: CALL_OW 310
16214: IFFALSE 16229
// ComExit ( speaker [ 1 ] ) ;
16216: LD_VAR 0 3
16220: PUSH
16221: LD_INT 1
16223: ARRAY
16224: PPUSH
16225: CALL 1124 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
16229: LD_VAR 0 3
16233: PUSH
16234: LD_INT 1
16236: ARRAY
16237: PPUSH
16238: LD_EXP 36
16242: PPUSH
16243: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
16247: LD_VAR 0 3
16251: PUSH
16252: LD_INT 1
16254: ARRAY
16255: PPUSH
16256: LD_EXP 36
16260: PPUSH
16261: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
16265: LD_EXP 36
16269: PPUSH
16270: LD_VAR 0 3
16274: PUSH
16275: LD_INT 1
16277: ARRAY
16278: PPUSH
16279: CALL_OW 119
// wait ( 0 0$1 ) ;
16283: LD_INT 35
16285: PPUSH
16286: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
16290: LD_VAR 0 3
16294: PUSH
16295: LD_INT 1
16297: ARRAY
16298: PPUSH
16299: LD_VAR 0 3
16303: PUSH
16304: LD_INT 2
16306: ARRAY
16307: PUSH
16308: LD_STRING -1-land
16310: STR
16311: PPUSH
16312: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16316: LD_EXP 36
16320: PPUSH
16321: LD_STRING DI-2-land
16323: PPUSH
16324: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16328: LD_VAR 0 3
16332: PUSH
16333: LD_INT 1
16335: ARRAY
16336: PPUSH
16337: LD_VAR 0 3
16341: PUSH
16342: LD_INT 2
16344: ARRAY
16345: PUSH
16346: LD_STRING -2-land
16348: STR
16349: PPUSH
16350: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16354: LD_VAR 0 3
16358: PUSH
16359: LD_INT 1
16361: ARRAY
16362: PPUSH
16363: LD_VAR 0 3
16367: PUSH
16368: LD_INT 2
16370: ARRAY
16371: PUSH
16372: LD_STRING -3-land
16374: STR
16375: PPUSH
16376: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16380: LD_EXP 26
16384: PPUSH
16385: LD_STRING DH-1-land
16387: PPUSH
16388: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16392: LD_VAR 0 5
16396: PPUSH
16397: CALL_OW 313
16401: PUSH
16402: LD_INT 6
16404: EQUAL
16405: IFFALSE 16425
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16407: LD_VAR 0 5
16411: PPUSH
16412: CALL_OW 313
16416: PUSH
16417: LD_INT 1
16419: ARRAY
16420: PPUSH
16421: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16425: LD_EXP 36
16429: PPUSH
16430: LD_INT 2
16432: PPUSH
16433: CALL_OW 235
// CenterOnUnits ( depot ) ;
16437: LD_VAR 0 5
16441: PPUSH
16442: CALL_OW 85
// ComEnterUnit ( Ibrahim , depot ) ;
16446: LD_EXP 36
16450: PPUSH
16451: LD_VAR 0 5
16455: PPUSH
16456: CALL_OW 120
// ComEnterUnit ( speaker [ 1 ] , depot ) ;
16460: LD_VAR 0 3
16464: PUSH
16465: LD_INT 1
16467: ARRAY
16468: PPUSH
16469: LD_VAR 0 5
16473: PPUSH
16474: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
16478: LD_INT 35
16480: PPUSH
16481: CALL_OW 67
// until IsInUnit ( Ibrahim ) or not IsOk ( Ibrahim ) ;
16485: LD_EXP 36
16489: PPUSH
16490: CALL_OW 310
16494: PUSH
16495: LD_EXP 36
16499: PPUSH
16500: CALL_OW 302
16504: NOT
16505: OR
16506: IFFALSE 16478
// InGameOff ;
16508: CALL_OW 9
// if not IsOk ( Ibrahim ) then
16512: LD_EXP 36
16516: PPUSH
16517: CALL_OW 302
16521: NOT
16522: IFFALSE 16526
// exit ;
16524: GO 16542
// ibrahimInDepot := true ;
16526: LD_ADDR_EXP 23
16530: PUSH
16531: LD_INT 1
16533: ST_TO_ADDR
// allowConvoys := true ;
16534: LD_ADDR_EXP 11
16538: PUSH
16539: LD_INT 1
16541: ST_TO_ADDR
// end ;
16542: PPOPN 5
16544: END
// export function IbrahimQuery ; begin
16545: LD_INT 0
16547: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16548: LD_STRING IbrahimQuery
16550: PPUSH
16551: CALL_OW 97
16555: PUSH
16556: LD_INT 1
16558: DOUBLE
16559: EQUAL
16560: IFTRUE 16564
16562: GO 16846
16564: POP
// begin allowConvoys := false ;
16565: LD_ADDR_EXP 11
16569: PUSH
16570: LD_INT 0
16572: ST_TO_ADDR
// ibrahimInDepot := false ;
16573: LD_ADDR_EXP 23
16577: PUSH
16578: LD_INT 0
16580: ST_TO_ADDR
// InGameOn ;
16581: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16585: LD_EXP 26
16589: PPUSH
16590: CALL_OW 87
// wait ( 0 0$1 ) ;
16594: LD_INT 35
16596: PPUSH
16597: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16601: LD_EXP 26
16605: PPUSH
16606: LD_STRING DH-1-interrogation
16608: PPUSH
16609: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16613: LD_EXP 36
16617: PPUSH
16618: LD_STRING DI-1-interrogation
16620: PPUSH
16621: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16625: LD_EXP 26
16629: PPUSH
16630: LD_STRING DH-2-interrogation
16632: PPUSH
16633: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16637: LD_EXP 36
16641: PPUSH
16642: LD_STRING DI-2-interrogation
16644: PPUSH
16645: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16649: LD_EXP 26
16653: PPUSH
16654: LD_STRING DH-3-interrogation
16656: PPUSH
16657: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16661: LD_EXP 36
16665: PPUSH
16666: LD_STRING DI-3-interrogation
16668: PPUSH
16669: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16673: LD_EXP 26
16677: PPUSH
16678: LD_STRING DH-4-interrogation
16680: PPUSH
16681: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16685: LD_EXP 36
16689: PPUSH
16690: LD_STRING DI-4-interrogation
16692: PPUSH
16693: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16697: LD_EXP 26
16701: PPUSH
16702: LD_STRING DH-5-interrogation
16704: PPUSH
16705: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16709: LD_EXP 36
16713: PPUSH
16714: LD_STRING DI-5-interrogation
16716: PPUSH
16717: CALL_OW 88
// wait ( 0 0$1 ) ;
16721: LD_INT 35
16723: PPUSH
16724: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16728: LD_STRING IbrahimDecisionQuery
16730: PPUSH
16731: CALL_OW 97
16735: PUSH
16736: LD_INT 1
16738: DOUBLE
16739: EQUAL
16740: IFTRUE 16744
16742: GO 16768
16744: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16745: LD_EXP 36
16749: PPUSH
16750: LD_STRING DI-1-kill
16752: PPUSH
16753: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16757: LD_EXP 36
16761: PPUSH
16762: CALL_OW 66
// end ; 2 :
16766: GO 16840
16768: LD_INT 2
16770: DOUBLE
16771: EQUAL
16772: IFTRUE 16776
16774: GO 16839
16776: POP
// begin SetSide ( Ibrahim , 6 ) ;
16777: LD_EXP 36
16781: PPUSH
16782: LD_INT 6
16784: PPUSH
16785: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16789: LD_EXP 36
16793: PPUSH
16794: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16798: LD_EXP 36
16802: PPUSH
16803: LD_INT 32
16805: PPUSH
16806: LD_INT 5
16808: PPUSH
16809: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16813: LD_EXP 26
16817: PPUSH
16818: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16822: LD_EXP 26
16826: PPUSH
16827: LD_INT 36
16829: PPUSH
16830: LD_INT 21
16832: PPUSH
16833: CALL_OW 171
// end ; end ;
16837: GO 16840
16839: POP
// InGameOff ;
16840: CALL_OW 9
// end ; 2 :
16844: GO 16860
16846: LD_INT 2
16848: DOUBLE
16849: EQUAL
16850: IFTRUE 16854
16852: GO 16859
16854: POP
// exit ; end ;
16855: GO 16898
16857: GO 16860
16859: POP
// allowConvoys := true ;
16860: LD_ADDR_EXP 11
16864: PUSH
16865: LD_INT 1
16867: ST_TO_ADDR
// wait ( 2 2$40 ) ;
16868: LD_INT 5600
16870: PPUSH
16871: CALL_OW 67
// ComMoveXY ( Ibrahim , 38 , 28 ) ;
16875: LD_EXP 36
16879: PPUSH
16880: LD_INT 38
16882: PPUSH
16883: LD_INT 28
16885: PPUSH
16886: CALL_OW 111
// ibrahimIsFree := true ;
16890: LD_ADDR_EXP 24
16894: PUSH
16895: LD_INT 1
16897: ST_TO_ADDR
// end ;
16898: LD_VAR 0 1
16902: RET
// every 0 0$1 trigger ibrahimIsFree and IsOk ( Ibrahim ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b , p , depot ;
16903: LD_EXP 24
16907: PUSH
16908: LD_EXP 36
16912: PPUSH
16913: CALL_OW 302
16917: AND
16918: PUSH
16919: LD_INT 22
16921: PUSH
16922: LD_INT 2
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: PUSH
16929: LD_INT 50
16931: PUSH
16932: EMPTY
16933: LIST
16934: PUSH
16935: LD_INT 30
16937: PUSH
16938: LD_INT 0
16940: PUSH
16941: EMPTY
16942: LIST
16943: LIST
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: LIST
16949: PPUSH
16950: CALL_OW 69
16954: AND
16955: PUSH
16956: LD_EXP 36
16960: PPUSH
16961: LD_INT 7
16963: PPUSH
16964: CALL_OW 308
16968: AND
16969: PUSH
16970: LD_INT 6
16972: PPUSH
16973: LD_EXP 26
16977: PPUSH
16978: CALL_OW 292
16982: AND
16983: PUSH
16984: LD_INT 22
16986: PUSH
16987: LD_INT 4
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: PPUSH
16994: CALL_OW 69
16998: NOT
16999: AND
17000: PUSH
17001: LD_INT 22
17003: PUSH
17004: LD_INT 1
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: PUSH
17011: LD_INT 21
17013: PUSH
17014: LD_INT 1
17016: PUSH
17017: EMPTY
17018: LIST
17019: LIST
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: PPUSH
17025: CALL_OW 69
17029: NOT
17030: AND
17031: IFFALSE 17686
17033: GO 17035
17035: DISABLE
17036: LD_INT 0
17038: PPUSH
17039: PPUSH
17040: PPUSH
17041: PPUSH
// begin allowConvoys := false ;
17042: LD_ADDR_EXP 11
17046: PUSH
17047: LD_INT 0
17049: ST_TO_ADDR
// depot := usDepot ;
17050: LD_ADDR_VAR 0 4
17054: PUSH
17055: LD_INT 11
17057: ST_TO_ADDR
// if not usDepot then
17058: LD_INT 11
17060: NOT
17061: IFFALSE 17108
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
17063: LD_ADDR_VAR 0 4
17067: PUSH
17068: LD_INT 22
17070: PUSH
17071: LD_INT 2
17073: PUSH
17074: EMPTY
17075: LIST
17076: LIST
17077: PUSH
17078: LD_INT 50
17080: PUSH
17081: EMPTY
17082: LIST
17083: PUSH
17084: LD_INT 30
17086: PUSH
17087: LD_INT 0
17089: PUSH
17090: EMPTY
17091: LIST
17092: LIST
17093: PUSH
17094: EMPTY
17095: LIST
17096: LIST
17097: LIST
17098: PPUSH
17099: CALL_OW 69
17103: PUSH
17104: LD_INT 1
17106: ARRAY
17107: ST_TO_ADDR
// InGameOn ;
17108: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
17112: LD_EXP 36
17116: PPUSH
17117: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
17121: LD_EXP 26
17125: PPUSH
17126: LD_EXP 36
17130: PPUSH
17131: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
17135: LD_EXP 36
17139: PPUSH
17140: LD_EXP 26
17144: PPUSH
17145: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
17149: LD_EXP 36
17153: PPUSH
17154: LD_STRING DI-1-free
17156: PPUSH
17157: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
17161: LD_EXP 26
17165: PPUSH
17166: LD_STRING DH-1-free
17168: PPUSH
17169: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
17173: LD_EXP 36
17177: PPUSH
17178: LD_STRING DI-2-free
17180: PPUSH
17181: CALL_OW 88
// changeClass := 0 ;
17185: LD_ADDR_VAR 0 1
17189: PUSH
17190: LD_INT 0
17192: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
17193: LD_STRING IbrahimJoinQuery
17195: PPUSH
17196: CALL_OW 97
17200: PUSH
17201: LD_INT 1
17203: DOUBLE
17204: EQUAL
17205: IFTRUE 17209
17207: GO 17220
17209: POP
// begin changeClass := 1 ;
17210: LD_ADDR_VAR 0 1
17214: PUSH
17215: LD_INT 1
17217: ST_TO_ADDR
// end ; 2 :
17218: GO 17460
17220: LD_INT 2
17222: DOUBLE
17223: EQUAL
17224: IFTRUE 17228
17226: GO 17380
17228: POP
// begin Say ( Heike , DH-1-decline ) ;
17229: LD_EXP 26
17233: PPUSH
17234: LD_STRING DH-1-decline
17236: PPUSH
17237: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
17241: LD_EXP 36
17245: PPUSH
17246: LD_STRING DI-1-decline
17248: PPUSH
17249: CALL_OW 88
// InGameOff ;
17253: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
17257: LD_EXP 36
17261: PPUSH
17262: LD_INT 30
17264: PPUSH
17265: LD_INT 1
17267: PPUSH
17268: CALL_OW 111
// p := 0 ;
17272: LD_ADDR_VAR 0 3
17276: PUSH
17277: LD_INT 0
17279: ST_TO_ADDR
// repeat p := p + 1 ;
17280: LD_ADDR_VAR 0 3
17284: PUSH
17285: LD_VAR 0 3
17289: PUSH
17290: LD_INT 1
17292: PLUS
17293: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17294: LD_INT 35
17296: PPUSH
17297: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) or p > 10 ;
17301: LD_EXP 36
17305: PPUSH
17306: LD_INT 30
17308: PPUSH
17309: LD_INT 1
17311: PPUSH
17312: CALL_OW 307
17316: PUSH
17317: LD_INT 22
17319: PUSH
17320: LD_INT 2
17322: PUSH
17323: EMPTY
17324: LIST
17325: LIST
17326: PUSH
17327: LD_INT 101
17329: PUSH
17330: LD_INT 6
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: PUSH
17337: EMPTY
17338: LIST
17339: LIST
17340: PPUSH
17341: CALL_OW 69
17345: NOT
17346: OR
17347: PUSH
17348: LD_VAR 0 3
17352: PUSH
17353: LD_INT 10
17355: GREATER
17356: OR
17357: IFFALSE 17280
// RemoveUnit ( Ibrahim ) ;
17359: LD_EXP 36
17363: PPUSH
17364: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17368: LD_INT 1
17370: PPUSH
17371: LD_STRING 03_IbrahimHasEscaped
17373: PPUSH
17374: CALL_OW 39
// end ; 3 :
17378: GO 17460
17380: LD_INT 3
17382: DOUBLE
17383: EQUAL
17384: IFTRUE 17388
17386: GO 17459
17388: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17389: LD_EXP 26
17393: PPUSH
17394: LD_STRING DH-1-radio-hq
17396: PPUSH
17397: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17401: LD_EXP 35
17405: PPUSH
17406: LD_STRING DO-1-radio-hq
17408: PPUSH
17409: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17413: LD_EXP 26
17417: PPUSH
17418: LD_STRING DH-2-radio-hq
17420: PPUSH
17421: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17425: LD_EXP 35
17429: PPUSH
17430: LD_STRING DO-2-radio-hq
17432: PPUSH
17433: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17437: LD_EXP 26
17441: PPUSH
17442: LD_STRING DH-3-radio-hq
17444: PPUSH
17445: CALL_OW 88
// changeClass := 1 ;
17449: LD_ADDR_VAR 0 1
17453: PUSH
17454: LD_INT 1
17456: ST_TO_ADDR
// end ; end ;
17457: GO 17460
17459: POP
// if changeClass then
17460: LD_VAR 0 1
17464: IFFALSE 17686
// begin Say ( Heike , DH-1-agree ) ;
17466: LD_EXP 26
17470: PPUSH
17471: LD_STRING DH-1-agree
17473: PPUSH
17474: CALL_OW 88
// if IsOk ( Givi ) then
17478: LD_EXP 27
17482: PPUSH
17483: CALL_OW 302
17487: IFFALSE 17525
// begin Say ( Givi , DG-1-agree ) ;
17489: LD_EXP 27
17493: PPUSH
17494: LD_STRING DG-1-agree
17496: PPUSH
17497: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17501: LD_EXP 26
17505: PPUSH
17506: LD_STRING DH-2-agree
17508: PPUSH
17509: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17513: LD_EXP 27
17517: PPUSH
17518: LD_STRING DG-2-agree
17520: PPUSH
17521: CALL_OW 88
// end ; if UnitsInside ( depot ) = 6 then
17525: LD_VAR 0 4
17529: PPUSH
17530: CALL_OW 313
17534: PUSH
17535: LD_INT 6
17537: EQUAL
17538: IFFALSE 17558
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
17540: LD_VAR 0 4
17544: PPUSH
17545: CALL_OW 313
17549: PUSH
17550: LD_INT 1
17552: ARRAY
17553: PPUSH
17554: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17558: LD_EXP 36
17562: PPUSH
17563: LD_INT 2
17565: PPUSH
17566: CALL_OW 235
// ComEnterUnit ( Ibrahim , depot ) ;
17570: LD_EXP 36
17574: PPUSH
17575: LD_VAR 0 4
17579: PPUSH
17580: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17584: LD_INT 35
17586: PPUSH
17587: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17591: LD_EXP 36
17595: PPUSH
17596: CALL_OW 310
17600: IFFALSE 17584
// b := IsInUnit ( Ibrahim ) ;
17602: LD_ADDR_VAR 0 2
17606: PUSH
17607: LD_EXP 36
17611: PPUSH
17612: CALL_OW 310
17616: ST_TO_ADDR
// RemoveUnit ( Ibrahim ) ;
17617: LD_EXP 36
17621: PPUSH
17622: CALL_OW 64
// uc_side := 2 ;
17626: LD_ADDR_OWVAR 20
17630: PUSH
17631: LD_INT 2
17633: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17634: LD_ADDR_EXP 36
17638: PUSH
17639: LD_STRING Ibrahim
17641: PPUSH
17642: LD_INT 0
17644: PPUSH
17645: LD_STRING 
17647: PPUSH
17648: CALL 297 0 3
17652: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , b ) ;
17653: LD_EXP 36
17657: PPUSH
17658: LD_VAR 0 2
17662: PPUSH
17663: CALL_OW 52
// InGameOff ;
17667: CALL_OW 9
// allowConvoys := true ;
17671: LD_ADDR_EXP 11
17675: PUSH
17676: LD_INT 1
17678: ST_TO_ADDR
// SetAchievement ( ACH_IBRAHIM ) ;
17679: LD_STRING ACH_IBRAHIM
17681: PPUSH
17682: CALL_OW 543
// end ; end ;
17686: PPOPN 4
17688: END
// every 0 0$1 trigger GetLives ( Kaia ) < 3 do
17689: LD_EXP 31
17693: PPUSH
17694: CALL_OW 256
17698: PUSH
17699: LD_INT 3
17701: LESS
17702: IFFALSE 17769
17704: GO 17706
17706: DISABLE
// begin DialogueOn ;
17707: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
17711: LD_EXP 31
17715: PPUSH
17716: CALL_OW 87
// ForceSay ( Kaia , DK-keydeath-1 ) ;
17720: LD_EXP 31
17724: PPUSH
17725: LD_STRING DK-keydeath-1
17727: PPUSH
17728: CALL_OW 91
// Say ( Heike , DH-keydeath-2 ) ;
17732: LD_EXP 26
17736: PPUSH
17737: LD_STRING DH-keydeath-2
17739: PPUSH
17740: CALL_OW 88
// Say ( Heike , DH-keydeath-3 ) ;
17744: LD_EXP 26
17748: PPUSH
17749: LD_STRING DH-keydeath-3
17751: PPUSH
17752: CALL_OW 88
// DialogueOff ;
17756: CALL_OW 7
// KillUnit ( Kaia ) ;
17760: LD_EXP 31
17764: PPUSH
17765: CALL_OW 66
// end ;
17769: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 do
17770: LD_EXP 10
17774: PUSH
17775: LD_EXP 19
17779: PUSH
17780: LD_INT 1
17782: LESS
17783: AND
17784: IFFALSE 18175
17786: GO 17788
17788: DISABLE
// begin DialogueOn ;
17789: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
17793: LD_EXP 26
17797: PPUSH
17798: LD_STRING DH-1-final
17800: PPUSH
17801: CALL_OW 88
// if tick <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
17805: LD_OWVAR 1
17809: PUSH
17810: LD_INT 126000
17812: PUSH
17813: LD_INT 115500
17815: PUSH
17816: LD_INT 105000
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: PUSH
17824: LD_OWVAR 67
17828: ARRAY
17829: LESSEQUAL
17830: IFFALSE 17844
// AddMedal ( med1 , 1 ) else
17832: LD_STRING med1
17834: PPUSH
17835: LD_INT 1
17837: PPUSH
17838: CALL_OW 101
17842: GO 17855
// AddMedal ( med1 , - 1 ) ;
17844: LD_STRING med1
17846: PPUSH
17847: LD_INT 1
17849: NEG
17850: PPUSH
17851: CALL_OW 101
// if vehCounter >= 2 then
17855: LD_EXP 20
17859: PUSH
17860: LD_INT 2
17862: GREATEREQUAL
17863: IFFALSE 17877
// AddMedal ( med2 , 1 ) else
17865: LD_STRING med2
17867: PPUSH
17868: LD_INT 1
17870: PPUSH
17871: CALL_OW 101
17875: GO 17888
// AddMedal ( med2 , - 1 ) ;
17877: LD_STRING med2
17879: PPUSH
17880: LD_INT 1
17882: NEG
17883: PPUSH
17884: CALL_OW 101
// if deadCounter = 0 then
17888: LD_EXP 8
17892: PUSH
17893: LD_INT 0
17895: EQUAL
17896: IFFALSE 17910
// AddMedal ( med3 , 1 ) else
17898: LD_STRING med3
17900: PPUSH
17901: LD_INT 1
17903: PPUSH
17904: CALL_OW 101
17908: GO 17921
// AddMedal ( med3 , - 1 ) ;
17910: LD_STRING med3
17912: PPUSH
17913: LD_INT 1
17915: NEG
17916: PPUSH
17917: CALL_OW 101
// GiveMedals ( MAIN ) ;
17921: LD_STRING MAIN
17923: PPUSH
17924: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
17928: LD_INT 22
17930: PUSH
17931: LD_INT 2
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: PUSH
17938: LD_INT 23
17940: PUSH
17941: LD_INT 2
17943: PUSH
17944: EMPTY
17945: LIST
17946: LIST
17947: PUSH
17948: LD_INT 21
17950: PUSH
17951: LD_INT 1
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: PUSH
17958: EMPTY
17959: LIST
17960: LIST
17961: LIST
17962: PPUSH
17963: CALL_OW 69
17967: PPUSH
17968: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
17972: LD_EXP 26
17976: PPUSH
17977: LD_STRING 03_Heike
17979: PPUSH
17980: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
17984: LD_EXP 30
17988: PPUSH
17989: LD_STRING 03_Aviradze
17991: PPUSH
17992: CALL_OW 38
// if Givi then
17996: LD_EXP 27
18000: IFFALSE 18014
// SaveCharacters ( Givi , 03_Givi ) ;
18002: LD_EXP 27
18006: PPUSH
18007: LD_STRING 03_Givi
18009: PPUSH
18010: CALL_OW 38
// if Mike then
18014: LD_EXP 28
18018: IFFALSE 18032
// SaveCharacters ( Mike , 03_Mike ) ;
18020: LD_EXP 28
18024: PPUSH
18025: LD_STRING 03_Mike
18027: PPUSH
18028: CALL_OW 38
// if Kamil then
18032: LD_EXP 29
18036: IFFALSE 18050
// SaveCharacters ( Kamil , 03_Kamil ) ;
18038: LD_EXP 29
18042: PPUSH
18043: LD_STRING 03_Kamil
18045: PPUSH
18046: CALL_OW 38
// if Kaia then
18050: LD_EXP 31
18054: IFFALSE 18068
// SaveCharacters ( Kaia , 03_Kaia ) ;
18056: LD_EXP 31
18060: PPUSH
18061: LD_STRING 03_Kaia
18063: PPUSH
18064: CALL_OW 38
// if Sophia then
18068: LD_EXP 32
18072: IFFALSE 18086
// SaveCharacters ( Sophia , 03_Sophia ) ;
18074: LD_EXP 32
18078: PPUSH
18079: LD_STRING 03_Sophia
18081: PPUSH
18082: CALL_OW 38
// if Markov then
18086: LD_EXP 33
18090: IFFALSE 18104
// SaveCharacters ( Markov , 03_Markov ) ;
18092: LD_EXP 33
18096: PPUSH
18097: LD_STRING 03_Markov
18099: PPUSH
18100: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
18104: LD_EXP 36
18108: PUSH
18109: LD_EXP 36
18113: PPUSH
18114: CALL_OW 255
18118: PUSH
18119: LD_INT 2
18121: EQUAL
18122: AND
18123: IFFALSE 18137
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
18125: LD_EXP 36
18129: PPUSH
18130: LD_STRING 03_Ibrahim
18132: PPUSH
18133: CALL_OW 38
// if heikeSecondSquad then
18137: LD_EXP 40
18141: IFFALSE 18155
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
18143: LD_EXP 40
18147: PPUSH
18148: LD_STRING 03_others
18150: PPUSH
18151: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
18155: LD_EXP 8
18159: PPUSH
18160: LD_STRING 03_DeadCounter
18162: PPUSH
18163: CALL_OW 39
// YouWin ;
18167: CALL_OW 103
// DialogueOff ;
18171: CALL_OW 7
// end ; end_of_file
18175: END
// on UnitDestroyed ( un ) do begin if un = Heike then
18176: LD_VAR 0 1
18180: PUSH
18181: LD_EXP 26
18185: EQUAL
18186: IFFALSE 18195
// YouLost ( Heike ) ;
18188: LD_STRING Heike
18190: PPUSH
18191: CALL_OW 104
// if un = Aviradze then
18195: LD_VAR 0 1
18199: PUSH
18200: LD_EXP 30
18204: EQUAL
18205: IFFALSE 18214
// YouLost ( Aviradze ) ;
18207: LD_STRING Aviradze
18209: PPUSH
18210: CALL_OW 104
// if un = usDepot and not retreatAllowed then
18214: LD_VAR 0 1
18218: PUSH
18219: LD_INT 11
18221: EQUAL
18222: PUSH
18223: LD_EXP 10
18227: NOT
18228: AND
18229: IFFALSE 18238
// YouLost ( Depot ) ;
18231: LD_STRING Depot
18233: PPUSH
18234: CALL_OW 104
// if un = arDepot then
18238: LD_VAR 0 1
18242: PUSH
18243: LD_INT 5
18245: EQUAL
18246: IFFALSE 18255
// YouLost ( FarmerDepot ) ;
18248: LD_STRING FarmerDepot
18250: PPUSH
18251: CALL_OW 104
// if un = Farmer then
18255: LD_VAR 0 1
18259: PUSH
18260: LD_EXP 34
18264: EQUAL
18265: IFFALSE 18274
// YouLost ( Farmer ) ;
18267: LD_STRING Farmer
18269: PPUSH
18270: CALL_OW 104
// if un in usForces then
18274: LD_VAR 0 1
18278: PUSH
18279: LD_EXP 42
18283: IN
18284: IFFALSE 18302
// usForces := usForces diff un ;
18286: LD_ADDR_EXP 42
18290: PUSH
18291: LD_EXP 42
18295: PUSH
18296: LD_VAR 0 1
18300: DIFF
18301: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
18302: LD_VAR 0 1
18306: PUSH
18307: LD_INT 22
18309: PUSH
18310: LD_INT 2
18312: PUSH
18313: EMPTY
18314: LIST
18315: LIST
18316: PUSH
18317: LD_INT 23
18319: PUSH
18320: LD_INT 2
18322: PUSH
18323: EMPTY
18324: LIST
18325: LIST
18326: PUSH
18327: LD_INT 21
18329: PUSH
18330: LD_INT 1
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: PUSH
18337: EMPTY
18338: LIST
18339: LIST
18340: LIST
18341: PPUSH
18342: CALL_OW 69
18346: IN
18347: IFFALSE 18363
// deadCounter := deadCounter + 1 ;
18349: LD_ADDR_EXP 8
18353: PUSH
18354: LD_EXP 8
18358: PUSH
18359: LD_INT 1
18361: PLUS
18362: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
18363: LD_VAR 0 1
18367: PUSH
18368: LD_INT 22
18370: PUSH
18371: LD_INT 4
18373: PUSH
18374: EMPTY
18375: LIST
18376: LIST
18377: PUSH
18378: LD_INT 34
18380: PUSH
18381: LD_INT 12
18383: PUSH
18384: EMPTY
18385: LIST
18386: LIST
18387: PUSH
18388: EMPTY
18389: LIST
18390: LIST
18391: PPUSH
18392: CALL_OW 69
18396: IN
18397: PUSH
18398: LD_EXP 16
18402: NOT
18403: AND
18404: IFFALSE 18414
// firstConvoyDestroyed := true ;
18406: LD_ADDR_EXP 16
18410: PUSH
18411: LD_INT 1
18413: ST_TO_ADDR
// if un in usAttackers then
18414: LD_VAR 0 1
18418: PUSH
18419: LD_EXP 45
18423: IN
18424: IFFALSE 18442
// usAttackers := usAttackers diff un ;
18426: LD_ADDR_EXP 45
18430: PUSH
18431: LD_EXP 45
18435: PUSH
18436: LD_VAR 0 1
18440: DIFF
18441: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) then
18442: LD_VAR 0 1
18446: PUSH
18447: LD_INT 22
18449: PUSH
18450: LD_INT 5
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: LD_INT 21
18459: PUSH
18460: LD_INT 1
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: PPUSH
18471: CALL_OW 69
18475: IN
18476: IFFALSE 18492
// farmerHumanLoseCounter := farmerHumanLoseCounter + 1 ;
18478: LD_ADDR_EXP 18
18482: PUSH
18483: LD_EXP 18
18487: PUSH
18488: LD_INT 1
18490: PLUS
18491: ST_TO_ADDR
// end ;
18492: PPOPN 1
18494: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18495: LD_VAR 0 2
18499: PUSH
18500: LD_EXP 36
18504: EQUAL
18505: PUSH
18506: LD_EXP 23
18510: AND
18511: IFFALSE 18557
// begin Video ( true ) ;
18513: LD_INT 1
18515: PPUSH
18516: CALL 1020 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
18520: LD_EXP 36
18524: PPUSH
18525: LD_INT 11
18527: PPUSH
18528: CALL_OW 120
// repeat wait ( 3 ) ;
18532: LD_INT 3
18534: PPUSH
18535: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18539: LD_EXP 36
18543: PPUSH
18544: CALL_OW 310
18548: IFFALSE 18532
// Video ( false ) ;
18550: LD_INT 0
18552: PPUSH
18553: CALL 1020 0 1
// end ; end ;
18557: PPOPN 2
18559: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
18560: LD_VAR 0 2
18564: PUSH
18565: LD_EXP 26
18569: EQUAL
18570: PUSH
18571: LD_VAR 0 1
18575: PUSH
18576: LD_INT 11
18578: EQUAL
18579: AND
18580: PUSH
18581: LD_EXP 23
18585: AND
18586: IFFALSE 18592
// IbrahimQuery ;
18588: CALL 16545 0 0
// end ;
18592: PPOPN 2
18594: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin ComStop ( newId ) ;
18595: LD_VAR 0 1
18599: PPUSH
18600: CALL_OW 141
// if oldId in usAttackers then
18604: LD_VAR 0 2
18608: PUSH
18609: LD_EXP 45
18613: IN
18614: IFFALSE 18632
// usAttackers := usAttackers diff oldId ;
18616: LD_ADDR_EXP 45
18620: PUSH
18621: LD_EXP 45
18625: PUSH
18626: LD_VAR 0 2
18630: DIFF
18631: ST_TO_ADDR
// if newId in usAttackers then
18632: LD_VAR 0 1
18636: PUSH
18637: LD_EXP 45
18641: IN
18642: IFFALSE 18660
// usAttackers := usAttackers diff newId ;
18644: LD_ADDR_EXP 45
18648: PUSH
18649: LD_EXP 45
18653: PUSH
18654: LD_VAR 0 1
18658: DIFF
18659: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
18660: LD_VAR 0 3
18664: PUSH
18665: LD_INT 4
18667: EQUAL
18668: PUSH
18669: LD_EXP 16
18673: NOT
18674: AND
18675: IFFALSE 18685
// firstConvoyDestroyed := true ;
18677: LD_ADDR_EXP 16
18681: PUSH
18682: LD_INT 1
18684: ST_TO_ADDR
// if GetWeapon ( newId ) = us_cargo_bay then
18685: LD_VAR 0 1
18689: PPUSH
18690: CALL_OW 264
18694: PUSH
18695: LD_INT 12
18697: EQUAL
18698: IFFALSE 18736
// begin capturedCargoCounter := capturedCargoCounter + 1 ;
18700: LD_ADDR_EXP 12
18704: PUSH
18705: LD_EXP 12
18709: PUSH
18710: LD_INT 1
18712: PLUS
18713: ST_TO_ADDR
// if GetCargo ( newId , mat_cans ) = 0 then
18714: LD_VAR 0 1
18718: PPUSH
18719: LD_INT 1
18721: PPUSH
18722: CALL_OW 289
18726: PUSH
18727: LD_INT 0
18729: EQUAL
18730: IFFALSE 18736
// EmptyCargoDialog ;
18732: CALL 15282 0 0
// end ; end ;
18736: PPOPN 4
18738: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
18739: LD_VAR 0 1
18743: PUSH
18744: LD_INT 2
18746: EQUAL
18747: PUSH
18748: LD_VAR 0 2
18752: PUSH
18753: LD_INT 5
18755: EQUAL
18756: AND
18757: IFFALSE 18766
// YouLost ( Attack ) ;
18759: LD_STRING Attack
18761: PPUSH
18762: CALL_OW 104
// end ;
18766: PPOPN 2
18768: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 and not americanBaseCaptured then
18769: LD_VAR 0 1
18773: PPUSH
18774: CALL_OW 255
18778: PUSH
18779: LD_INT 1
18781: EQUAL
18782: PUSH
18783: LD_EXP 6
18787: NOT
18788: AND
18789: IFFALSE 18923
// begin if GetBType ( b ) = b_lab then
18791: LD_VAR 0 1
18795: PPUSH
18796: CALL_OW 266
18800: PUSH
18801: LD_INT 6
18803: EQUAL
18804: IFFALSE 18844
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
18806: LD_EXP 42
18810: PPUSH
18811: LD_INT 25
18813: PUSH
18814: LD_INT 4
18816: PUSH
18817: EMPTY
18818: LIST
18819: LIST
18820: PPUSH
18821: CALL_OW 72
18825: PPUSH
18826: LD_VAR 0 1
18830: PPUSH
18831: CALL_OW 120
// AmLabResearch ( b ) ;
18835: LD_VAR 0 1
18839: PPUSH
18840: CALL 5990 0 1
// end ; if GetBType ( b ) = b_armoury then
18844: LD_VAR 0 1
18848: PPUSH
18849: CALL_OW 266
18853: PUSH
18854: LD_INT 4
18856: EQUAL
18857: IFFALSE 18905
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
18859: LD_EXP 42
18863: PPUSH
18864: LD_INT 25
18866: PUSH
18867: LD_INT 1
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: PUSH
18874: LD_INT 3
18876: PUSH
18877: LD_INT 54
18879: PUSH
18880: EMPTY
18881: LIST
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: PPUSH
18891: CALL_OW 72
18895: PPUSH
18896: LD_VAR 0 1
18900: PPUSH
18901: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
18905: LD_ADDR_EXP 44
18909: PUSH
18910: LD_EXP 44
18914: PPUSH
18915: LD_INT 1
18917: PPUSH
18918: CALL_OW 3
18922: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
18923: LD_VAR 0 1
18927: PPUSH
18928: CALL_OW 255
18932: PUSH
18933: LD_INT 5
18935: EQUAL
18936: IFFALSE 18950
// SetBLevel ( b , 5 ) ;
18938: LD_VAR 0 1
18942: PPUSH
18943: LD_INT 5
18945: PPUSH
18946: CALL_OW 241
// end ;
18950: PPOPN 1
18952: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
18953: LD_VAR 0 1
18957: PPUSH
18958: CALL_OW 255
18962: PUSH
18963: LD_INT 2
18965: EQUAL
18966: IFFALSE 18982
// vehCounter := vehCounter + 1 ;
18968: LD_ADDR_EXP 20
18972: PUSH
18973: LD_EXP 20
18977: PUSH
18978: LD_INT 1
18980: PLUS
18981: ST_TO_ADDR
// end ;
18982: PPOPN 2
18984: END
// on SailEvent ( event ) do begin if event = eventAttack then
18985: LD_VAR 0 1
18989: PUSH
18990: LD_EXP 22
18994: EQUAL
18995: IFFALSE 19001
// AmericanAttack ;
18997: CALL 7458 0 0
// end ; end_of_file
19001: PPOPN 1
19003: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 4 4$00 , 3 3$00 , 2 2$30 ] [ Difficulty ] do
19004: LD_OWVAR 1
19008: PUSH
19009: LD_INT 8400
19011: PUSH
19012: LD_INT 6300
19014: PUSH
19015: LD_INT 5250
19017: PUSH
19018: EMPTY
19019: LIST
19020: LIST
19021: LIST
19022: PUSH
19023: LD_OWVAR 67
19027: ARRAY
19028: LESSEQUAL
19029: IFFALSE 19056
19031: GO 19033
19033: DISABLE
// begin enable ;
19034: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
19035: LD_INT 1
19037: PPUSH
19038: LD_INT 5
19040: PPUSH
19041: CALL_OW 12
19045: PPUSH
19046: LD_INT 9
19048: PPUSH
19049: LD_INT 1
19051: PPUSH
19052: CALL_OW 55
// end ;
19056: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 26 26$00 , 23 23$00 , 20 20$00 ] [ Difficulty ] do
19057: LD_EXP 6
19061: PUSH
19062: LD_OWVAR 1
19066: PUSH
19067: LD_INT 54600
19069: PUSH
19070: LD_INT 48300
19072: PUSH
19073: LD_INT 42000
19075: PUSH
19076: EMPTY
19077: LIST
19078: LIST
19079: LIST
19080: PUSH
19081: LD_OWVAR 67
19085: ARRAY
19086: LESSEQUAL
19087: AND
19088: IFFALSE 19115
19090: GO 19092
19092: DISABLE
// begin enable ;
19093: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
19094: LD_INT 1
19096: PPUSH
19097: LD_INT 5
19099: PPUSH
19100: CALL_OW 12
19104: PPUSH
19105: LD_INT 9
19107: PPUSH
19108: LD_INT 1
19110: PPUSH
19111: CALL_OW 55
// end ; end_of_file
19115: END
// every 0 0$1 trigger not retreatAllowed and farmerRequestedCrates and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
19116: LD_EXP 10
19120: NOT
19121: PUSH
19122: LD_EXP 14
19126: AND
19127: PUSH
19128: LD_EXP 4
19132: AND
19133: PUSH
19134: LD_EXP 13
19138: PUSH
19139: LD_EXP 14
19143: LESSEQUAL
19144: AND
19145: IFFALSE 19235
19147: GO 19149
19149: DISABLE
// begin enable ;
19150: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
19151: LD_ADDR_OWVAR 47
19155: PUSH
19156: LD_STRING #X103-1
19158: PUSH
19159: LD_EXP 13
19163: PUSH
19164: LD_EXP 14
19168: PUSH
19169: EMPTY
19170: LIST
19171: LIST
19172: LIST
19173: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
19174: LD_ADDR_EXP 13
19178: PUSH
19179: LD_INT 5
19181: PPUSH
19182: CALL_OW 274
19186: PPUSH
19187: LD_INT 1
19189: PPUSH
19190: CALL_OW 275
19194: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
19195: LD_INT 10
19197: PPUSH
19198: LD_INT 1
19200: PPUSH
19201: CALL_OW 287
19205: PUSH
19206: LD_INT 0
19208: EQUAL
19209: IFFALSE 19227
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
19211: LD_ADDR_EXP 15
19215: PUSH
19216: LD_EXP 15
19220: PUSH
19221: LD_INT 35
19223: MINUS
19224: ST_TO_ADDR
19225: GO 19235
// farmerCratesCounter := 30 30$00 ;
19227: LD_ADDR_EXP 15
19231: PUSH
19232: LD_INT 63000
19234: ST_TO_ADDR
// end ; end_of_file
19235: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
19236: GO 19238
19238: DISABLE
// begin ru_radar := 98 ;
19239: LD_ADDR_EXP 46
19243: PUSH
19244: LD_INT 98
19246: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
19247: LD_ADDR_EXP 47
19251: PUSH
19252: LD_INT 89
19254: ST_TO_ADDR
// us_hack := 99 ;
19255: LD_ADDR_EXP 48
19259: PUSH
19260: LD_INT 99
19262: ST_TO_ADDR
// us_artillery := 97 ;
19263: LD_ADDR_EXP 49
19267: PUSH
19268: LD_INT 97
19270: ST_TO_ADDR
// ar_bio_bomb := 91 ;
19271: LD_ADDR_EXP 50
19275: PUSH
19276: LD_INT 91
19278: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
19279: LD_ADDR_EXP 51
19283: PUSH
19284: LD_INT 92
19286: ST_TO_ADDR
// tech_Artillery := 80 ;
19287: LD_ADDR_EXP 52
19291: PUSH
19292: LD_INT 80
19294: ST_TO_ADDR
// tech_RadMat := 81 ;
19295: LD_ADDR_EXP 53
19299: PUSH
19300: LD_INT 81
19302: ST_TO_ADDR
// tech_BasicTools := 82 ;
19303: LD_ADDR_EXP 54
19307: PUSH
19308: LD_INT 82
19310: ST_TO_ADDR
// tech_Cargo := 83 ;
19311: LD_ADDR_EXP 55
19315: PUSH
19316: LD_INT 83
19318: ST_TO_ADDR
// tech_Track := 84 ;
19319: LD_ADDR_EXP 56
19323: PUSH
19324: LD_INT 84
19326: ST_TO_ADDR
// tech_Crane := 85 ;
19327: LD_ADDR_EXP 57
19331: PUSH
19332: LD_INT 85
19334: ST_TO_ADDR
// tech_Bulldozer := 86 ;
19335: LD_ADDR_EXP 58
19339: PUSH
19340: LD_INT 86
19342: ST_TO_ADDR
// tech_Hovercraft := 87 ;
19343: LD_ADDR_EXP 59
19347: PUSH
19348: LD_INT 87
19350: ST_TO_ADDR
// end ;
19351: END
