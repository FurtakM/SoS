// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 25 0 0
// PrepareNature ;
   8: CALL 594 0 0
// PrepareArabian ;
  12: CALL 1909 0 0
// PrepareAmerican ;
  16: CALL 4687 0 0
// Action ;
  20: CALL 8784 0 0
// end ;
  24: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// prefix := 02_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 02_
  43: ST_TO_ADDR
// eventAttack := 1 ;
  44: LD_ADDR_EXP 20
  48: PUSH
  49: LD_INT 1
  51: ST_TO_ADDR
// deadCounter := 0 ;
  52: LD_ADDR_EXP 8
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// gameStarted := false ;
  60: LD_ADDR_EXP 3
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// farmerBaseReady := false ;
  68: LD_ADDR_EXP 4
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// americanBaseSpoted := false ;
  76: LD_ADDR_EXP 5
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// americanBaseCaptured := false ;
  84: LD_ADDR_EXP 6
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// americanHasEscaped := false ;
  92: LD_ADDR_EXP 7
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// workshopBuilded := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// retreatAllowed := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// allowConvoys := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// farmerCrates := 0 ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// farmerCratesCounter := 7 7$00 ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 14700
 147: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 148: LD_ADDR_EXP 15
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// attackWave := 1 ;
 156: LD_ADDR_EXP 16
 160: PUSH
 161: LD_INT 1
 163: ST_TO_ADDR
// omarCargoCounter := [ 6 , 9 , 12 ] [ Difficulty ] ;
 164: LD_ADDR_EXP 17
 168: PUSH
 169: LD_INT 6
 171: PUSH
 172: LD_INT 9
 174: PUSH
 175: LD_INT 12
 177: PUSH
 178: EMPTY
 179: LIST
 180: LIST
 181: LIST
 182: PUSH
 183: LD_OWVAR 67
 187: ARRAY
 188: ST_TO_ADDR
// vehCounter := 0 ;
 189: LD_ADDR_EXP 18
 193: PUSH
 194: LD_INT 0
 196: ST_TO_ADDR
// convoyCounter := 0 ;
 197: LD_ADDR_EXP 19
 201: PUSH
 202: LD_INT 0
 204: ST_TO_ADDR
// ibrahimInDepot := false ;
 205: LD_ADDR_EXP 21
 209: PUSH
 210: LD_INT 0
 212: ST_TO_ADDR
// ibrahimIsFree := false ;
 213: LD_ADDR_EXP 22
 217: PUSH
 218: LD_INT 0
 220: ST_TO_ADDR
// end ; end_of_file
 221: LD_VAR 0 1
 225: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 226: LD_INT 0
 228: PPUSH
 229: PPUSH
// if exist_mode then
 230: LD_VAR 0 2
 234: IFFALSE 259
// unit := CreateCharacter ( prefix & ident ) else
 236: LD_ADDR_VAR 0 5
 240: PUSH
 241: LD_VAR 0 3
 245: PUSH
 246: LD_VAR 0 1
 250: STR
 251: PPUSH
 252: CALL_OW 34
 256: ST_TO_ADDR
 257: GO 274
// unit := NewCharacter ( ident ) ;
 259: LD_ADDR_VAR 0 5
 263: PUSH
 264: LD_VAR 0 1
 268: PPUSH
 269: CALL_OW 25
 273: ST_TO_ADDR
// result := unit ;
 274: LD_ADDR_VAR 0 4
 278: PUSH
 279: LD_VAR 0 5
 283: ST_TO_ADDR
// end ;
 284: LD_VAR 0 4
 288: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 289: LD_INT 0
 291: PPUSH
// uc_side := side ;
 292: LD_ADDR_OWVAR 20
 296: PUSH
 297: LD_VAR 0 1
 301: ST_TO_ADDR
// uc_nation := nation ;
 302: LD_ADDR_OWVAR 21
 306: PUSH
 307: LD_VAR 0 2
 311: ST_TO_ADDR
// vc_chassis := chassis ;
 312: LD_ADDR_OWVAR 37
 316: PUSH
 317: LD_VAR 0 3
 321: ST_TO_ADDR
// vc_engine := engine ;
 322: LD_ADDR_OWVAR 39
 326: PUSH
 327: LD_VAR 0 4
 331: ST_TO_ADDR
// vc_control := control ;
 332: LD_ADDR_OWVAR 38
 336: PUSH
 337: LD_VAR 0 5
 341: ST_TO_ADDR
// vc_weapon := weapon ;
 342: LD_ADDR_OWVAR 40
 346: PUSH
 347: LD_VAR 0 6
 351: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 352: LD_ADDR_OWVAR 41
 356: PUSH
 357: LD_VAR 0 7
 361: ST_TO_ADDR
// result := CreateVehicle ;
 362: LD_ADDR_VAR 0 8
 366: PUSH
 367: CALL_OW 45
 371: ST_TO_ADDR
// end ;
 372: LD_VAR 0 8
 376: RET
// export function SayX ( units , ident ) ; var i ; begin
 377: LD_INT 0
 379: PPUSH
 380: PPUSH
// result := false ;
 381: LD_ADDR_VAR 0 3
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// if not units then
 389: LD_VAR 0 1
 393: NOT
 394: IFFALSE 398
// exit ;
 396: GO 452
// for i in units do
 398: LD_ADDR_VAR 0 4
 402: PUSH
 403: LD_VAR 0 1
 407: PUSH
 408: FOR_IN
 409: IFFALSE 450
// if IsOk ( i ) then
 411: LD_VAR 0 4
 415: PPUSH
 416: CALL_OW 302
 420: IFFALSE 448
// begin Say ( i , ident ) ;
 422: LD_VAR 0 4
 426: PPUSH
 427: LD_VAR 0 2
 431: PPUSH
 432: CALL_OW 88
// result := i ;
 436: LD_ADDR_VAR 0 3
 440: PUSH
 441: LD_VAR 0 4
 445: ST_TO_ADDR
// break ;
 446: GO 450
// end ;
 448: GO 408
 450: POP
 451: POP
// end ;
 452: LD_VAR 0 3
 456: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 457: LD_INT 0
 459: PPUSH
 460: PPUSH
// InitUc ;
 461: CALL_OW 18
// InitHc ;
 465: CALL_OW 19
// uc_side := 0 ;
 469: LD_ADDR_OWVAR 20
 473: PUSH
 474: LD_INT 0
 476: ST_TO_ADDR
// uc_nation := 0 ;
 477: LD_ADDR_OWVAR 21
 481: PUSH
 482: LD_INT 0
 484: ST_TO_ADDR
// for i = 1 to amount do
 485: LD_ADDR_VAR 0 4
 489: PUSH
 490: DOUBLE
 491: LD_INT 1
 493: DEC
 494: ST_TO_ADDR
 495: LD_VAR 0 2
 499: PUSH
 500: FOR_TO
 501: IFFALSE 583
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 503: LD_ADDR_OWVAR 29
 507: PUSH
 508: LD_INT 9
 510: PPUSH
 511: LD_INT 12
 513: PPUSH
 514: CALL_OW 12
 518: PUSH
 519: LD_INT 9
 521: PPUSH
 522: LD_INT 12
 524: PPUSH
 525: CALL_OW 12
 529: PUSH
 530: EMPTY
 531: LIST
 532: LIST
 533: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 534: LD_ADDR_OWVAR 35
 538: PUSH
 539: LD_INT 1
 541: NEG
 542: PPUSH
 543: LD_INT 1
 545: PPUSH
 546: CALL_OW 12
 550: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 551: LD_INT 0
 553: PPUSH
 554: LD_INT 12
 556: PPUSH
 557: LD_INT 1
 559: PPUSH
 560: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 564: CALL_OW 44
 568: PPUSH
 569: LD_VAR 0 1
 573: PPUSH
 574: LD_INT 0
 576: PPUSH
 577: CALL_OW 49
// end ;
 581: GO 500
 583: POP
 584: POP
// InitHc ;
 585: CALL_OW 19
// end ;
 589: LD_VAR 0 3
 593: RET
// export function PrepareNature ; var i ; begin
 594: LD_INT 0
 596: PPUSH
 597: PPUSH
// SpawnApeman ( forest , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
 598: LD_INT 2
 600: PPUSH
 601: LD_INT 4
 603: PUSH
 604: LD_INT 4
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: LIST
 614: PUSH
 615: LD_OWVAR 67
 619: ARRAY
 620: PPUSH
 621: CALL 457 0 2
// for i := 1 to 3 do
 625: LD_ADDR_VAR 0 2
 629: PUSH
 630: DOUBLE
 631: LD_INT 1
 633: DEC
 634: ST_TO_ADDR
 635: LD_INT 3
 637: PUSH
 638: FOR_TO
 639: IFFALSE 674
// begin hc_class := 21 ;
 641: LD_ADDR_OWVAR 28
 645: PUSH
 646: LD_INT 21
 648: ST_TO_ADDR
// hc_gallery :=  ;
 649: LD_ADDR_OWVAR 33
 653: PUSH
 654: LD_STRING 
 656: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 657: CALL_OW 44
 661: PPUSH
 662: LD_INT 2
 664: PPUSH
 665: LD_INT 0
 667: PPUSH
 668: CALL_OW 49
// end ;
 672: GO 638
 674: POP
 675: POP
// for i := 1 to 2 do
 676: LD_ADDR_VAR 0 2
 680: PUSH
 681: DOUBLE
 682: LD_INT 1
 684: DEC
 685: ST_TO_ADDR
 686: LD_INT 2
 688: PUSH
 689: FOR_TO
 690: IFFALSE 725
// begin hc_class := 18 ;
 692: LD_ADDR_OWVAR 28
 696: PUSH
 697: LD_INT 18
 699: ST_TO_ADDR
// hc_gallery :=  ;
 700: LD_ADDR_OWVAR 33
 704: PUSH
 705: LD_STRING 
 707: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 708: CALL_OW 44
 712: PPUSH
 713: LD_INT 2
 715: PPUSH
 716: LD_INT 0
 718: PPUSH
 719: CALL_OW 49
// end ;
 723: GO 689
 725: POP
 726: POP
// for i := 1 to 2 do
 727: LD_ADDR_VAR 0 2
 731: PUSH
 732: DOUBLE
 733: LD_INT 1
 735: DEC
 736: ST_TO_ADDR
 737: LD_INT 2
 739: PUSH
 740: FOR_TO
 741: IFFALSE 776
// begin hc_class := 13 ;
 743: LD_ADDR_OWVAR 28
 747: PUSH
 748: LD_INT 13
 750: ST_TO_ADDR
// hc_gallery :=  ;
 751: LD_ADDR_OWVAR 33
 755: PUSH
 756: LD_STRING 
 758: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 759: CALL_OW 44
 763: PPUSH
 764: LD_INT 2
 766: PPUSH
 767: LD_INT 0
 769: PPUSH
 770: CALL_OW 49
// end ;
 774: GO 740
 776: POP
 777: POP
// end ;
 778: LD_VAR 0 1
 782: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 783: LD_INT 0
 785: PPUSH
 786: PPUSH
 787: PPUSH
// if not observer or not unit then
 788: LD_VAR 0 1
 792: NOT
 793: PUSH
 794: LD_VAR 0 2
 798: NOT
 799: OR
 800: IFFALSE 804
// exit ;
 802: GO 852
// if not See ( GetSide ( observer ) , unit ) then
 804: LD_VAR 0 1
 808: PPUSH
 809: CALL_OW 255
 813: PPUSH
 814: LD_VAR 0 2
 818: PPUSH
 819: CALL_OW 292
 823: NOT
 824: IFFALSE 828
// exit ;
 826: GO 852
// result := GetDistUnits ( observer , unit ) < 12 ;
 828: LD_ADDR_VAR 0 3
 832: PUSH
 833: LD_VAR 0 1
 837: PPUSH
 838: LD_VAR 0 2
 842: PPUSH
 843: CALL_OW 296
 847: PUSH
 848: LD_INT 12
 850: LESS
 851: ST_TO_ADDR
// end ;
 852: LD_VAR 0 3
 856: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 857: LD_INT 0
 859: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 860: LD_VAR 0 2
 864: PUSH
 865: LD_INT 1
 867: ARRAY
 868: PPUSH
 869: LD_VAR 0 2
 873: PUSH
 874: LD_INT 2
 876: ARRAY
 877: PPUSH
 878: CALL_OW 488
 882: PUSH
 883: LD_VAR 0 2
 887: PUSH
 888: LD_INT 1
 890: ARRAY
 891: PPUSH
 892: LD_VAR 0 2
 896: PUSH
 897: LD_INT 2
 899: ARRAY
 900: PPUSH
 901: CALL_OW 428
 905: PUSH
 906: LD_INT 0
 908: EQUAL
 909: AND
 910: IFFALSE 944
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 912: LD_VAR 0 1
 916: PPUSH
 917: LD_VAR 0 2
 921: PUSH
 922: LD_INT 1
 924: ARRAY
 925: PPUSH
 926: LD_VAR 0 2
 930: PUSH
 931: LD_INT 2
 933: ARRAY
 934: PPUSH
 935: LD_VAR 0 3
 939: PPUSH
 940: CALL_OW 48
// end ;
 944: LD_VAR 0 4
 948: RET
// export function Video ( mode ) ; begin
 949: LD_INT 0
 951: PPUSH
// ingame_video = mode ;
 952: LD_ADDR_OWVAR 52
 956: PUSH
 957: LD_VAR 0 1
 961: ST_TO_ADDR
// interface_hidden = mode ;
 962: LD_ADDR_OWVAR 54
 966: PUSH
 967: LD_VAR 0 1
 971: ST_TO_ADDR
// end ;
 972: LD_VAR 0 2
 976: RET
// export function ReverseArray ( array ) ; var i ; begin
 977: LD_INT 0
 979: PPUSH
 980: PPUSH
// if not array then
 981: LD_VAR 0 1
 985: NOT
 986: IFFALSE 990
// exit ;
 988: GO 1048
// result := [ ] ;
 990: LD_ADDR_VAR 0 2
 994: PUSH
 995: EMPTY
 996: ST_TO_ADDR
// for i := 1 to array do
 997: LD_ADDR_VAR 0 3
1001: PUSH
1002: DOUBLE
1003: LD_INT 1
1005: DEC
1006: ST_TO_ADDR
1007: LD_VAR 0 1
1011: PUSH
1012: FOR_TO
1013: IFFALSE 1046
// result := Insert ( result , 1 , array [ i ] ) ;
1015: LD_ADDR_VAR 0 2
1019: PUSH
1020: LD_VAR 0 2
1024: PPUSH
1025: LD_INT 1
1027: PPUSH
1028: LD_VAR 0 1
1032: PUSH
1033: LD_VAR 0 3
1037: ARRAY
1038: PPUSH
1039: CALL_OW 2
1043: ST_TO_ADDR
1044: GO 1012
1046: POP
1047: POP
// end ;
1048: LD_VAR 0 2
1052: RET
// export function ComExit ( unit ) ; begin
1053: LD_INT 0
1055: PPUSH
// result := IsInUnit ( unit ) ;
1056: LD_ADDR_VAR 0 2
1060: PUSH
1061: LD_VAR 0 1
1065: PPUSH
1066: CALL_OW 310
1070: ST_TO_ADDR
// if not result then
1071: LD_VAR 0 2
1075: NOT
1076: IFFALSE 1080
// exit ;
1078: GO 1115
// if GetType ( result ) = unit_vehicle then
1080: LD_VAR 0 2
1084: PPUSH
1085: CALL_OW 247
1089: PUSH
1090: LD_INT 2
1092: EQUAL
1093: IFFALSE 1106
// ComExitVehicle ( unit ) else
1095: LD_VAR 0 1
1099: PPUSH
1100: CALL_OW 121
1104: GO 1115
// ComExitBuilding ( unit ) ;
1106: LD_VAR 0 1
1110: PPUSH
1111: CALL_OW 122
// end ;
1115: LD_VAR 0 2
1119: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1120: LD_INT 0
1122: PPUSH
1123: PPUSH
// if not side or not nation then
1124: LD_VAR 0 1
1128: NOT
1129: PUSH
1130: LD_VAR 0 2
1134: NOT
1135: OR
1136: IFFALSE 1140
// exit ;
1138: GO 1904
// case nation of nation_american :
1140: LD_VAR 0 2
1144: PUSH
1145: LD_INT 1
1147: DOUBLE
1148: EQUAL
1149: IFTRUE 1153
1151: GO 1367
1153: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1154: LD_ADDR_VAR 0 4
1158: PUSH
1159: LD_INT 35
1161: PUSH
1162: LD_INT 45
1164: PUSH
1165: LD_INT 46
1167: PUSH
1168: LD_INT 47
1170: PUSH
1171: LD_INT 82
1173: PUSH
1174: LD_INT 83
1176: PUSH
1177: LD_INT 84
1179: PUSH
1180: LD_INT 85
1182: PUSH
1183: LD_INT 86
1185: PUSH
1186: LD_INT 1
1188: PUSH
1189: LD_INT 2
1191: PUSH
1192: LD_INT 6
1194: PUSH
1195: LD_INT 15
1197: PUSH
1198: LD_INT 16
1200: PUSH
1201: LD_INT 7
1203: PUSH
1204: LD_INT 12
1206: PUSH
1207: LD_INT 13
1209: PUSH
1210: LD_INT 10
1212: PUSH
1213: LD_INT 14
1215: PUSH
1216: LD_INT 20
1218: PUSH
1219: LD_INT 21
1221: PUSH
1222: LD_INT 22
1224: PUSH
1225: LD_INT 25
1227: PUSH
1228: LD_INT 32
1230: PUSH
1231: LD_INT 27
1233: PUSH
1234: LD_INT 36
1236: PUSH
1237: LD_INT 69
1239: PUSH
1240: LD_INT 39
1242: PUSH
1243: LD_INT 34
1245: PUSH
1246: LD_INT 40
1248: PUSH
1249: LD_INT 48
1251: PUSH
1252: LD_INT 49
1254: PUSH
1255: LD_INT 50
1257: PUSH
1258: LD_INT 51
1260: PUSH
1261: LD_INT 52
1263: PUSH
1264: LD_INT 53
1266: PUSH
1267: LD_INT 54
1269: PUSH
1270: LD_INT 55
1272: PUSH
1273: LD_INT 56
1275: PUSH
1276: LD_INT 57
1278: PUSH
1279: LD_INT 58
1281: PUSH
1282: LD_INT 59
1284: PUSH
1285: LD_INT 60
1287: PUSH
1288: LD_INT 61
1290: PUSH
1291: LD_INT 62
1293: PUSH
1294: LD_INT 80
1296: PUSH
1297: LD_INT 82
1299: PUSH
1300: LD_INT 83
1302: PUSH
1303: LD_INT 84
1305: PUSH
1306: LD_INT 85
1308: PUSH
1309: LD_INT 86
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: LIST
1329: LIST
1330: LIST
1331: LIST
1332: LIST
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: ST_TO_ADDR
1365: GO 1828
1367: LD_INT 2
1369: DOUBLE
1370: EQUAL
1371: IFTRUE 1375
1373: GO 1597
1375: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1376: LD_ADDR_VAR 0 4
1380: PUSH
1381: LD_INT 35
1383: PUSH
1384: LD_INT 45
1386: PUSH
1387: LD_INT 46
1389: PUSH
1390: LD_INT 47
1392: PUSH
1393: LD_INT 82
1395: PUSH
1396: LD_INT 83
1398: PUSH
1399: LD_INT 84
1401: PUSH
1402: LD_INT 85
1404: PUSH
1405: LD_INT 87
1407: PUSH
1408: LD_INT 70
1410: PUSH
1411: LD_INT 1
1413: PUSH
1414: LD_INT 11
1416: PUSH
1417: LD_INT 3
1419: PUSH
1420: LD_INT 4
1422: PUSH
1423: LD_INT 5
1425: PUSH
1426: LD_INT 6
1428: PUSH
1429: LD_INT 15
1431: PUSH
1432: LD_INT 18
1434: PUSH
1435: LD_INT 7
1437: PUSH
1438: LD_INT 17
1440: PUSH
1441: LD_INT 8
1443: PUSH
1444: LD_INT 20
1446: PUSH
1447: LD_INT 21
1449: PUSH
1450: LD_INT 22
1452: PUSH
1453: LD_INT 72
1455: PUSH
1456: LD_INT 26
1458: PUSH
1459: LD_INT 69
1461: PUSH
1462: LD_INT 39
1464: PUSH
1465: LD_INT 40
1467: PUSH
1468: LD_INT 41
1470: PUSH
1471: LD_INT 42
1473: PUSH
1474: LD_INT 43
1476: PUSH
1477: LD_INT 48
1479: PUSH
1480: LD_INT 49
1482: PUSH
1483: LD_INT 50
1485: PUSH
1486: LD_INT 51
1488: PUSH
1489: LD_INT 52
1491: PUSH
1492: LD_INT 53
1494: PUSH
1495: LD_INT 54
1497: PUSH
1498: LD_INT 55
1500: PUSH
1501: LD_INT 56
1503: PUSH
1504: LD_INT 60
1506: PUSH
1507: LD_INT 61
1509: PUSH
1510: LD_INT 62
1512: PUSH
1513: LD_INT 66
1515: PUSH
1516: LD_INT 67
1518: PUSH
1519: LD_INT 68
1521: PUSH
1522: LD_INT 81
1524: PUSH
1525: LD_INT 82
1527: PUSH
1528: LD_INT 83
1530: PUSH
1531: LD_INT 84
1533: PUSH
1534: LD_INT 85
1536: PUSH
1537: LD_INT 87
1539: PUSH
1540: EMPTY
1541: LIST
1542: LIST
1543: LIST
1544: LIST
1545: LIST
1546: LIST
1547: LIST
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: LIST
1558: LIST
1559: LIST
1560: LIST
1561: LIST
1562: LIST
1563: LIST
1564: LIST
1565: LIST
1566: LIST
1567: LIST
1568: LIST
1569: LIST
1570: LIST
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: LIST
1577: LIST
1578: LIST
1579: LIST
1580: LIST
1581: LIST
1582: LIST
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: LIST
1588: LIST
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: LIST
1594: ST_TO_ADDR
1595: GO 1828
1597: LD_INT 3
1599: DOUBLE
1600: EQUAL
1601: IFTRUE 1605
1603: GO 1827
1605: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1606: LD_ADDR_VAR 0 4
1610: PUSH
1611: LD_INT 46
1613: PUSH
1614: LD_INT 47
1616: PUSH
1617: LD_INT 1
1619: PUSH
1620: LD_INT 2
1622: PUSH
1623: LD_INT 82
1625: PUSH
1626: LD_INT 83
1628: PUSH
1629: LD_INT 84
1631: PUSH
1632: LD_INT 85
1634: PUSH
1635: LD_INT 86
1637: PUSH
1638: LD_INT 11
1640: PUSH
1641: LD_INT 9
1643: PUSH
1644: LD_INT 20
1646: PUSH
1647: LD_INT 19
1649: PUSH
1650: LD_INT 21
1652: PUSH
1653: LD_INT 24
1655: PUSH
1656: LD_INT 22
1658: PUSH
1659: LD_INT 25
1661: PUSH
1662: LD_INT 28
1664: PUSH
1665: LD_INT 29
1667: PUSH
1668: LD_INT 30
1670: PUSH
1671: LD_INT 31
1673: PUSH
1674: LD_INT 37
1676: PUSH
1677: LD_INT 38
1679: PUSH
1680: LD_INT 32
1682: PUSH
1683: LD_INT 27
1685: PUSH
1686: LD_INT 33
1688: PUSH
1689: LD_INT 69
1691: PUSH
1692: LD_INT 39
1694: PUSH
1695: LD_INT 34
1697: PUSH
1698: LD_INT 40
1700: PUSH
1701: LD_INT 71
1703: PUSH
1704: LD_INT 23
1706: PUSH
1707: LD_INT 44
1709: PUSH
1710: LD_INT 48
1712: PUSH
1713: LD_INT 49
1715: PUSH
1716: LD_INT 50
1718: PUSH
1719: LD_INT 51
1721: PUSH
1722: LD_INT 52
1724: PUSH
1725: LD_INT 53
1727: PUSH
1728: LD_INT 54
1730: PUSH
1731: LD_INT 55
1733: PUSH
1734: LD_INT 56
1736: PUSH
1737: LD_INT 57
1739: PUSH
1740: LD_INT 58
1742: PUSH
1743: LD_INT 59
1745: PUSH
1746: LD_INT 63
1748: PUSH
1749: LD_INT 64
1751: PUSH
1752: LD_INT 65
1754: PUSH
1755: LD_INT 82
1757: PUSH
1758: LD_INT 83
1760: PUSH
1761: LD_INT 84
1763: PUSH
1764: LD_INT 85
1766: PUSH
1767: LD_INT 86
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: LIST
1808: LIST
1809: LIST
1810: LIST
1811: LIST
1812: LIST
1813: LIST
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: LIST
1824: ST_TO_ADDR
1825: GO 1828
1827: POP
// if state > - 1 and state < 3 then
1828: LD_VAR 0 3
1832: PUSH
1833: LD_INT 1
1835: NEG
1836: GREATER
1837: PUSH
1838: LD_VAR 0 3
1842: PUSH
1843: LD_INT 3
1845: LESS
1846: AND
1847: IFFALSE 1904
// for i in result do
1849: LD_ADDR_VAR 0 5
1853: PUSH
1854: LD_VAR 0 4
1858: PUSH
1859: FOR_IN
1860: IFFALSE 1902
// if GetTech ( i , side ) <> state then
1862: LD_VAR 0 5
1866: PPUSH
1867: LD_VAR 0 1
1871: PPUSH
1872: CALL_OW 321
1876: PUSH
1877: LD_VAR 0 3
1881: NONEQUAL
1882: IFFALSE 1900
// result := result diff i ;
1884: LD_ADDR_VAR 0 4
1888: PUSH
1889: LD_VAR 0 4
1893: PUSH
1894: LD_VAR 0 5
1898: DIFF
1899: ST_TO_ADDR
1900: GO 1859
1902: POP
1903: POP
// end ; end_of_file
1904: LD_VAR 0 4
1908: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1909: LD_INT 0
1911: PPUSH
1912: PPUSH
1913: PPUSH
1914: PPUSH
// uc_side := 5 ;
1915: LD_ADDR_OWVAR 20
1919: PUSH
1920: LD_INT 5
1922: ST_TO_ADDR
// uc_nation := 2 ;
1923: LD_ADDR_OWVAR 21
1927: PUSH
1928: LD_INT 2
1930: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
1931: LD_INT 5
1933: PPUSH
1934: CALL_OW 274
1938: PPUSH
1939: LD_INT 1
1941: PPUSH
1942: LD_INT 45
1944: PPUSH
1945: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
1949: LD_ADDR_EXP 31
1953: PUSH
1954: LD_STRING Farmer
1956: PPUSH
1957: LD_INT 0
1959: PPUSH
1960: LD_STRING 
1962: PPUSH
1963: CALL 226 0 3
1967: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
1968: LD_ADDR_EXP 32
1972: PUSH
1973: LD_STRING Omar
1975: PPUSH
1976: LD_INT 0
1978: PPUSH
1979: LD_STRING 
1981: PPUSH
1982: CALL 226 0 3
1986: ST_TO_ADDR
// omarSquad := [ ] ;
1987: LD_ADDR_EXP 35
1991: PUSH
1992: EMPTY
1993: ST_TO_ADDR
// heikeSquad := [ ] ;
1994: LD_ADDR_EXP 36
1998: PUSH
1999: EMPTY
2000: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2001: LD_ADDR_EXP 37
2005: PUSH
2006: EMPTY
2007: ST_TO_ADDR
// omarCargo := [ ] ;
2008: LD_ADDR_EXP 38
2012: PUSH
2013: EMPTY
2014: ST_TO_ADDR
// for i := 1 to 5 do
2015: LD_ADDR_VAR 0 2
2019: PUSH
2020: DOUBLE
2021: LD_INT 1
2023: DEC
2024: ST_TO_ADDR
2025: LD_INT 5
2027: PUSH
2028: FOR_TO
2029: IFFALSE 2187
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2031: LD_INT 0
2033: PPUSH
2034: LD_INT 1
2036: PUSH
2037: LD_INT 1
2039: PUSH
2040: LD_INT 2
2042: PUSH
2043: LD_INT 1
2045: PUSH
2046: LD_INT 1
2048: PUSH
2049: EMPTY
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: PUSH
2056: LD_VAR 0 2
2060: ARRAY
2061: PPUSH
2062: LD_INT 3
2064: PPUSH
2065: CALL_OW 380
// un := CreateHuman ;
2069: LD_ADDR_VAR 0 3
2073: PUSH
2074: CALL_OW 44
2078: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2079: LD_ADDR_EXP 35
2083: PUSH
2084: LD_EXP 35
2088: PUSH
2089: LD_VAR 0 3
2093: UNION
2094: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2095: LD_VAR 0 3
2099: PPUSH
2100: LD_INT 87
2102: PUSH
2103: LD_INT 30
2105: PUSH
2106: EMPTY
2107: LIST
2108: LIST
2109: PUSH
2110: LD_INT 91
2112: PUSH
2113: LD_INT 32
2115: PUSH
2116: EMPTY
2117: LIST
2118: LIST
2119: PUSH
2120: LD_INT 82
2122: PUSH
2123: LD_INT 15
2125: PUSH
2126: EMPTY
2127: LIST
2128: LIST
2129: PUSH
2130: LD_INT 79
2132: PUSH
2133: LD_INT 14
2135: PUSH
2136: EMPTY
2137: LIST
2138: LIST
2139: PUSH
2140: LD_INT 82
2142: PUSH
2143: LD_INT 13
2145: PUSH
2146: EMPTY
2147: LIST
2148: LIST
2149: PUSH
2150: EMPTY
2151: LIST
2152: LIST
2153: LIST
2154: LIST
2155: LIST
2156: PUSH
2157: LD_VAR 0 2
2161: ARRAY
2162: PPUSH
2163: LD_INT 0
2165: PPUSH
2166: CALL 857 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2170: LD_VAR 0 3
2174: PPUSH
2175: LD_INT 93
2177: PPUSH
2178: LD_INT 21
2180: PPUSH
2181: CALL_OW 118
// end ;
2185: GO 2028
2187: POP
2188: POP
// uc_side := 2 ;
2189: LD_ADDR_OWVAR 20
2193: PUSH
2194: LD_INT 2
2196: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2197: LD_ADDR_EXP 23
2201: PUSH
2202: LD_STRING Heike
2204: PPUSH
2205: LD_EXP 1
2209: NOT
2210: PPUSH
2211: LD_EXP 2
2215: PPUSH
2216: CALL 226 0 3
2220: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2221: LD_ADDR_EXP 27
2225: PUSH
2226: LD_STRING Aviradze
2228: PPUSH
2229: LD_EXP 1
2233: NOT
2234: PPUSH
2235: LD_EXP 2
2239: PPUSH
2240: CALL 226 0 3
2244: ST_TO_ADDR
// tmp := [ ] ;
2245: LD_ADDR_VAR 0 4
2249: PUSH
2250: EMPTY
2251: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2252: LD_ADDR_EXP 24
2256: PUSH
2257: LD_STRING Givi
2259: PPUSH
2260: LD_EXP 1
2264: NOT
2265: PPUSH
2266: LD_EXP 2
2270: PPUSH
2271: CALL 226 0 3
2275: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2276: LD_ADDR_EXP 25
2280: PUSH
2281: LD_STRING Mike
2283: PPUSH
2284: LD_EXP 1
2288: NOT
2289: PPUSH
2290: LD_EXP 2
2294: PPUSH
2295: CALL 226 0 3
2299: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2300: LD_ADDR_EXP 26
2304: PUSH
2305: LD_STRING Kamil
2307: PPUSH
2308: LD_EXP 1
2312: NOT
2313: PPUSH
2314: LD_EXP 2
2318: PPUSH
2319: CALL 226 0 3
2323: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2324: LD_ADDR_EXP 28
2328: PUSH
2329: LD_STRING Kaia
2331: PPUSH
2332: LD_EXP 1
2336: NOT
2337: PPUSH
2338: LD_EXP 2
2342: PPUSH
2343: CALL 226 0 3
2347: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2348: LD_ADDR_EXP 29
2352: PUSH
2353: LD_STRING Sophia
2355: PPUSH
2356: LD_EXP 1
2360: NOT
2361: PPUSH
2362: LD_EXP 2
2366: PPUSH
2367: CALL 226 0 3
2371: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2372: LD_ADDR_EXP 30
2376: PUSH
2377: LD_STRING Markov
2379: PPUSH
2380: LD_EXP 1
2384: NOT
2385: PPUSH
2386: LD_EXP 2
2390: PPUSH
2391: CALL 226 0 3
2395: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2396: LD_ADDR_EXP 37
2400: PUSH
2401: LD_STRING 02_others
2403: PPUSH
2404: CALL_OW 31
2408: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2409: LD_ADDR_VAR 0 4
2413: PUSH
2414: LD_EXP 25
2418: PUSH
2419: LD_EXP 26
2423: PUSH
2424: LD_EXP 28
2428: PUSH
2429: LD_EXP 29
2433: PUSH
2434: LD_EXP 30
2438: PUSH
2439: LD_EXP 24
2443: PUSH
2444: EMPTY
2445: LIST
2446: LIST
2447: LIST
2448: LIST
2449: LIST
2450: LIST
2451: PUSH
2452: LD_EXP 37
2456: ADD
2457: PUSH
2458: LD_INT 0
2460: DIFF
2461: ST_TO_ADDR
// heikeSquad := tmp ;
2462: LD_ADDR_EXP 36
2466: PUSH
2467: LD_VAR 0 4
2471: ST_TO_ADDR
// uc_nation := 0 ;
2472: LD_ADDR_OWVAR 21
2476: PUSH
2477: LD_INT 0
2479: ST_TO_ADDR
// hc_class := class_apeman ;
2480: LD_ADDR_OWVAR 28
2484: PUSH
2485: LD_INT 12
2487: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
2488: LD_ADDR_OWVAR 31
2492: PUSH
2493: LD_INT 0
2495: PUSH
2496: LD_INT 0
2498: PUSH
2499: LD_INT 0
2501: PUSH
2502: LD_INT 0
2504: PUSH
2505: EMPTY
2506: LIST
2507: LIST
2508: LIST
2509: LIST
2510: ST_TO_ADDR
// hc_gallery :=  ;
2511: LD_ADDR_OWVAR 33
2515: PUSH
2516: LD_STRING 
2518: ST_TO_ADDR
// hc_name :=  ;
2519: LD_ADDR_OWVAR 26
2523: PUSH
2524: LD_STRING 
2526: ST_TO_ADDR
// tmp := tmp union CreateHuman ;
2527: LD_ADDR_VAR 0 4
2531: PUSH
2532: LD_VAR 0 4
2536: PUSH
2537: CALL_OW 44
2541: UNION
2542: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2543: LD_EXP 23
2547: PPUSH
2548: LD_INT 92
2550: PPUSH
2551: LD_INT 17
2553: PPUSH
2554: LD_INT 0
2556: PPUSH
2557: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2561: LD_EXP 31
2565: PPUSH
2566: LD_INT 95
2568: PPUSH
2569: LD_INT 19
2571: PPUSH
2572: LD_INT 0
2574: PPUSH
2575: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2579: LD_EXP 32
2583: PPUSH
2584: LD_INT 89
2586: PPUSH
2587: LD_INT 25
2589: PPUSH
2590: LD_INT 0
2592: PPUSH
2593: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2597: LD_EXP 27
2601: PPUSH
2602: LD_INT 92
2604: PPUSH
2605: LD_INT 27
2607: PPUSH
2608: LD_INT 0
2610: PPUSH
2611: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2615: LD_EXP 32
2619: PPUSH
2620: LD_EXP 27
2624: PPUSH
2625: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2629: LD_EXP 27
2633: PPUSH
2634: LD_EXP 32
2638: PPUSH
2639: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2643: LD_EXP 23
2647: PUSH
2648: LD_EXP 31
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PPUSH
2657: LD_EXP 32
2661: PPUSH
2662: CALL_OW 119
// if tmp then
2666: LD_VAR 0 4
2670: IFFALSE 2724
// for i in tmp do
2672: LD_ADDR_VAR 0 2
2676: PUSH
2677: LD_VAR 0 4
2681: PUSH
2682: FOR_IN
2683: IFFALSE 2722
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2685: LD_VAR 0 2
2689: PPUSH
2690: LD_INT 94
2692: PPUSH
2693: LD_INT 14
2695: PPUSH
2696: LD_INT 4
2698: PPUSH
2699: LD_INT 0
2701: PPUSH
2702: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2706: LD_VAR 0 2
2710: PPUSH
2711: LD_EXP 23
2715: PPUSH
2716: CALL_OW 119
// end ;
2720: GO 2682
2722: POP
2723: POP
// farmerSquad := [ ] ;
2724: LD_ADDR_EXP 34
2728: PUSH
2729: EMPTY
2730: ST_TO_ADDR
// uc_side := 5 ;
2731: LD_ADDR_OWVAR 20
2735: PUSH
2736: LD_INT 5
2738: ST_TO_ADDR
// uc_nation := 2 ;
2739: LD_ADDR_OWVAR 21
2743: PUSH
2744: LD_INT 2
2746: ST_TO_ADDR
// for i := 1 to 4 do
2747: LD_ADDR_VAR 0 2
2751: PUSH
2752: DOUBLE
2753: LD_INT 1
2755: DEC
2756: ST_TO_ADDR
2757: LD_INT 4
2759: PUSH
2760: FOR_TO
2761: IFFALSE 2839
// begin PrepareHuman ( false , 1 , 2 ) ;
2763: LD_INT 0
2765: PPUSH
2766: LD_INT 1
2768: PPUSH
2769: LD_INT 2
2771: PPUSH
2772: CALL_OW 380
// un := CreateHuman ;
2776: LD_ADDR_VAR 0 3
2780: PUSH
2781: CALL_OW 44
2785: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2786: LD_VAR 0 3
2790: PPUSH
2791: LD_INT 102
2793: PPUSH
2794: LD_INT 27
2796: PPUSH
2797: LD_INT 4
2799: PPUSH
2800: LD_INT 0
2802: PPUSH
2803: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2807: LD_ADDR_EXP 34
2811: PUSH
2812: LD_EXP 34
2816: PUSH
2817: LD_VAR 0 3
2821: UNION
2822: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2823: LD_VAR 0 3
2827: PPUSH
2828: LD_EXP 32
2832: PPUSH
2833: CALL_OW 119
// end ;
2837: GO 2760
2839: POP
2840: POP
// PrepareHuman ( false , 2 , 2 ) ;
2841: LD_INT 0
2843: PPUSH
2844: LD_INT 2
2846: PPUSH
2847: LD_INT 2
2849: PPUSH
2850: CALL_OW 380
// un := CreateHuman ;
2854: LD_ADDR_VAR 0 3
2858: PUSH
2859: CALL_OW 44
2863: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2864: LD_VAR 0 3
2868: PPUSH
2869: LD_INT 108
2871: PPUSH
2872: LD_INT 62
2874: PPUSH
2875: LD_INT 2
2877: PPUSH
2878: LD_INT 0
2880: PPUSH
2881: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2885: LD_ADDR_EXP 34
2889: PUSH
2890: LD_EXP 34
2894: PUSH
2895: LD_VAR 0 3
2899: UNION
2900: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2901: LD_VAR 0 3
2905: PPUSH
2906: LD_EXP 32
2910: PPUSH
2911: CALL_OW 119
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
2915: LD_INT 109
2917: PPUSH
2918: LD_INT 63
2920: PPUSH
2921: LD_INT 2
2923: PPUSH
2924: LD_INT 15
2926: NEG
2927: PPUSH
2928: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
2932: LD_INT 109
2934: PPUSH
2935: LD_INT 63
2937: PPUSH
2938: LD_INT 2
2940: PPUSH
2941: CALL_OW 331
// end ;
2945: LD_VAR 0 1
2949: RET
// export function PrepareIbrahim ( x , y ) ; begin
2950: LD_INT 0
2952: PPUSH
// uc_side := 6 ;
2953: LD_ADDR_OWVAR 20
2957: PUSH
2958: LD_INT 6
2960: ST_TO_ADDR
// uc_nation := 3 ;
2961: LD_ADDR_OWVAR 21
2965: PUSH
2966: LD_INT 3
2968: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
2969: LD_ADDR_EXP 33
2973: PUSH
2974: LD_STRING IbrahimRu
2976: PPUSH
2977: LD_INT 0
2979: PPUSH
2980: LD_STRING 
2982: PPUSH
2983: CALL 226 0 3
2987: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
2988: LD_EXP 33
2992: PPUSH
2993: LD_VAR 0 1
2997: PPUSH
2998: LD_VAR 0 2
3002: PPUSH
3003: LD_INT 8
3005: PPUSH
3006: LD_INT 1
3008: PPUSH
3009: CALL_OW 50
// end ;
3013: LD_VAR 0 3
3017: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3018: LD_EXP 32
3022: PUSH
3023: LD_EXP 35
3027: ADD
3028: PPUSH
3029: LD_INT 95
3031: PUSH
3032: LD_INT 3
3034: PUSH
3035: EMPTY
3036: LIST
3037: LIST
3038: PPUSH
3039: CALL_OW 72
3043: IFFALSE 3099
3045: GO 3047
3047: DISABLE
3048: LD_INT 0
3050: PPUSH
// begin enable ;
3051: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3052: LD_ADDR_VAR 0 1
3056: PUSH
3057: LD_EXP 32
3061: PUSH
3062: LD_EXP 35
3066: ADD
3067: PPUSH
3068: LD_INT 95
3070: PUSH
3071: LD_INT 3
3073: PUSH
3074: EMPTY
3075: LIST
3076: LIST
3077: PPUSH
3078: CALL_OW 72
3082: PUSH
3083: FOR_IN
3084: IFFALSE 3097
// RemoveUnit ( i ) ;
3086: LD_VAR 0 1
3090: PPUSH
3091: CALL_OW 64
3095: GO 3083
3097: POP
3098: POP
// end ;
3099: PPOPN 1
3101: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3102: LD_EXP 3
3106: PUSH
3107: LD_EXP 31
3111: PPUSH
3112: LD_INT 4
3114: PPUSH
3115: CALL_OW 308
3119: AND
3120: IFFALSE 3903
3122: GO 3124
3124: DISABLE
3125: LD_INT 0
3127: PPUSH
3128: PPUSH
3129: PPUSH
3130: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3131: LD_EXP 31
3135: PPUSH
3136: LD_INT 110
3138: PPUSH
3139: LD_INT 60
3141: PPUSH
3142: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3146: LD_EXP 31
3150: PPUSH
3151: LD_INT 110
3153: PPUSH
3154: LD_INT 61
3156: PPUSH
3157: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3161: LD_ADDR_VAR 0 2
3165: PUSH
3166: LD_EXP 34
3170: PPUSH
3171: LD_INT 25
3173: PUSH
3174: LD_INT 1
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PPUSH
3181: CALL_OW 72
3185: ST_TO_ADDR
// if tmp then
3186: LD_VAR 0 2
3190: IFFALSE 3284
// begin for i := 1 to 2 do
3192: LD_ADDR_VAR 0 1
3196: PUSH
3197: DOUBLE
3198: LD_INT 1
3200: DEC
3201: ST_TO_ADDR
3202: LD_INT 2
3204: PUSH
3205: FOR_TO
3206: IFFALSE 3282
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3208: LD_VAR 0 2
3212: PUSH
3213: LD_VAR 0 1
3217: ARRAY
3218: PPUSH
3219: LD_INT 5
3221: PPUSH
3222: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3226: LD_VAR 0 2
3230: PUSH
3231: LD_VAR 0 1
3235: ARRAY
3236: PPUSH
3237: LD_INT 2
3239: PPUSH
3240: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3244: LD_VAR 0 2
3248: PUSH
3249: LD_VAR 0 1
3253: ARRAY
3254: PPUSH
3255: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3259: LD_VAR 0 2
3263: PUSH
3264: LD_VAR 0 1
3268: ARRAY
3269: PPUSH
3270: LD_INT 107
3272: PPUSH
3273: LD_INT 66
3275: PPUSH
3276: CALL_OW 171
// end ;
3280: GO 3205
3282: POP
3283: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3284: LD_ADDR_VAR 0 2
3288: PUSH
3289: LD_EXP 34
3293: PPUSH
3294: LD_INT 25
3296: PUSH
3297: LD_INT 2
3299: PUSH
3300: EMPTY
3301: LIST
3302: LIST
3303: PPUSH
3304: CALL_OW 72
3308: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3309: LD_INT 35
3311: PPUSH
3312: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3316: LD_ADDR_VAR 0 2
3320: PUSH
3321: LD_EXP 34
3325: PPUSH
3326: LD_INT 25
3328: PUSH
3329: LD_INT 2
3331: PUSH
3332: EMPTY
3333: LIST
3334: LIST
3335: PPUSH
3336: CALL_OW 72
3340: ST_TO_ADDR
// until tmp ;
3341: LD_VAR 0 2
3345: IFFALSE 3309
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3347: LD_VAR 0 2
3351: PPUSH
3352: LD_INT 31
3354: PPUSH
3355: LD_INT 102
3357: PPUSH
3358: LD_INT 69
3360: PPUSH
3361: LD_INT 2
3363: PPUSH
3364: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3368: LD_INT 35
3370: PPUSH
3371: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3375: LD_EXP 34
3379: PPUSH
3380: LD_INT 3
3382: PUSH
3383: LD_INT 60
3385: PUSH
3386: EMPTY
3387: LIST
3388: PUSH
3389: EMPTY
3390: LIST
3391: LIST
3392: PUSH
3393: LD_INT 25
3395: PUSH
3396: LD_INT 2
3398: PUSH
3399: EMPTY
3400: LIST
3401: LIST
3402: PUSH
3403: EMPTY
3404: LIST
3405: LIST
3406: PPUSH
3407: CALL_OW 72
3411: IFFALSE 3368
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3413: LD_ADDR_VAR 0 2
3417: PUSH
3418: LD_EXP 34
3422: PPUSH
3423: LD_INT 25
3425: PUSH
3426: LD_INT 2
3428: PUSH
3429: EMPTY
3430: LIST
3431: LIST
3432: PPUSH
3433: CALL_OW 72
3437: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3438: LD_VAR 0 2
3442: PPUSH
3443: LD_INT 4
3445: PPUSH
3446: LD_INT 116
3448: PPUSH
3449: LD_INT 70
3451: PPUSH
3452: LD_INT 5
3454: PPUSH
3455: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3459: LD_VAR 0 2
3463: PPUSH
3464: LD_INT 31
3466: PPUSH
3467: LD_INT 108
3469: PPUSH
3470: LD_INT 50
3472: PPUSH
3473: LD_INT 2
3475: PPUSH
3476: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3480: LD_INT 35
3482: PPUSH
3483: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3487: LD_INT 22
3489: PUSH
3490: LD_INT 5
3492: PUSH
3493: EMPTY
3494: LIST
3495: LIST
3496: PUSH
3497: LD_INT 30
3499: PUSH
3500: LD_INT 4
3502: PUSH
3503: EMPTY
3504: LIST
3505: LIST
3506: PUSH
3507: LD_INT 3
3509: PUSH
3510: LD_INT 57
3512: PUSH
3513: EMPTY
3514: LIST
3515: PUSH
3516: EMPTY
3517: LIST
3518: LIST
3519: PUSH
3520: EMPTY
3521: LIST
3522: LIST
3523: LIST
3524: PPUSH
3525: CALL_OW 69
3529: IFFALSE 3480
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3531: LD_ADDR_VAR 0 3
3535: PUSH
3536: LD_INT 22
3538: PUSH
3539: LD_INT 5
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: PUSH
3546: LD_INT 30
3548: PUSH
3549: LD_INT 4
3551: PUSH
3552: EMPTY
3553: LIST
3554: LIST
3555: PUSH
3556: LD_INT 3
3558: PUSH
3559: LD_INT 57
3561: PUSH
3562: EMPTY
3563: LIST
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: LIST
3573: PPUSH
3574: CALL_OW 69
3578: PUSH
3579: LD_INT 1
3581: ARRAY
3582: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3583: LD_ADDR_VAR 0 2
3587: PUSH
3588: LD_EXP 34
3592: PPUSH
3593: LD_INT 25
3595: PUSH
3596: LD_INT 1
3598: PUSH
3599: EMPTY
3600: LIST
3601: LIST
3602: PPUSH
3603: CALL_OW 72
3607: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3608: LD_VAR 0 2
3612: PPUSH
3613: LD_VAR 0 3
3617: PPUSH
3618: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3622: LD_INT 35
3624: PPUSH
3625: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3629: LD_INT 22
3631: PUSH
3632: LD_INT 5
3634: PUSH
3635: EMPTY
3636: LIST
3637: LIST
3638: PUSH
3639: LD_INT 30
3641: PUSH
3642: LD_INT 31
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 3
3651: PUSH
3652: LD_INT 57
3654: PUSH
3655: EMPTY
3656: LIST
3657: PUSH
3658: EMPTY
3659: LIST
3660: LIST
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: LIST
3666: PPUSH
3667: CALL_OW 69
3671: PUSH
3672: LD_INT 2
3674: GREATEREQUAL
3675: IFFALSE 3622
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3677: LD_ADDR_VAR 0 2
3681: PUSH
3682: LD_EXP 34
3686: PPUSH
3687: LD_INT 25
3689: PUSH
3690: LD_INT 2
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PPUSH
3697: CALL_OW 72
3701: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3702: LD_VAR 0 2
3706: PUSH
3707: LD_INT 1
3709: ARRAY
3710: PPUSH
3711: LD_INT 5
3713: PPUSH
3714: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3718: LD_VAR 0 2
3722: PUSH
3723: LD_INT 2
3725: ARRAY
3726: PUSH
3727: LD_VAR 0 2
3731: PUSH
3732: LD_INT 3
3734: ARRAY
3735: PUSH
3736: EMPTY
3737: LIST
3738: LIST
3739: PPUSH
3740: LD_VAR 0 3
3744: PPUSH
3745: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3749: LD_VAR 0 2
3753: PUSH
3754: LD_INT 2
3756: ARRAY
3757: PUSH
3758: LD_VAR 0 2
3762: PUSH
3763: LD_INT 3
3765: ARRAY
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: PPUSH
3771: LD_INT 1
3773: PPUSH
3774: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3778: LD_VAR 0 2
3782: PUSH
3783: LD_INT 2
3785: ARRAY
3786: PUSH
3787: LD_VAR 0 2
3791: PUSH
3792: LD_INT 3
3794: ARRAY
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: PPUSH
3800: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3804: LD_ADDR_VAR 0 4
3808: PUSH
3809: LD_INT 22
3811: PUSH
3812: LD_INT 5
3814: PUSH
3815: EMPTY
3816: LIST
3817: LIST
3818: PUSH
3819: LD_INT 30
3821: PUSH
3822: LD_INT 31
3824: PUSH
3825: EMPTY
3826: LIST
3827: LIST
3828: PUSH
3829: EMPTY
3830: LIST
3831: LIST
3832: PPUSH
3833: CALL_OW 69
3837: ST_TO_ADDR
// for i := 1 to 2 do
3838: LD_ADDR_VAR 0 1
3842: PUSH
3843: DOUBLE
3844: LD_INT 1
3846: DEC
3847: ST_TO_ADDR
3848: LD_INT 2
3850: PUSH
3851: FOR_TO
3852: IFFALSE 3886
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3854: LD_VAR 0 2
3858: PUSH
3859: LD_VAR 0 1
3863: PUSH
3864: LD_INT 1
3866: PLUS
3867: ARRAY
3868: PPUSH
3869: LD_VAR 0 4
3873: PUSH
3874: LD_VAR 0 1
3878: ARRAY
3879: PPUSH
3880: CALL_OW 180
3884: GO 3851
3886: POP
3887: POP
// wait ( 1 1$00 ) ;
3888: LD_INT 2100
3890: PPUSH
3891: CALL_OW 67
// farmerBaseReady := true ;
3895: LD_ADDR_EXP 4
3899: PUSH
3900: LD_INT 1
3902: ST_TO_ADDR
// end ;
3903: PPOPN 4
3905: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , damagedBuilding ;
3906: LD_EXP 4
3910: PUSH
3911: LD_EXP 10
3915: NOT
3916: AND
3917: IFFALSE 4237
3919: GO 3921
3921: DISABLE
3922: LD_INT 0
3924: PPUSH
3925: PPUSH
3926: PPUSH
// begin enable ;
3927: ENABLE
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3928: LD_ADDR_VAR 0 2
3932: PUSH
3933: LD_EXP 34
3937: PPUSH
3938: LD_INT 25
3940: PUSH
3941: LD_INT 2
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: PPUSH
3948: CALL_OW 72
3952: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3953: LD_ADDR_VAR 0 3
3957: PUSH
3958: LD_INT 22
3960: PUSH
3961: LD_INT 5
3963: PUSH
3964: EMPTY
3965: LIST
3966: LIST
3967: PUSH
3968: LD_INT 21
3970: PUSH
3971: LD_INT 3
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_INT 3
3980: PUSH
3981: LD_INT 24
3983: PUSH
3984: LD_INT 1000
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: PUSH
3991: EMPTY
3992: LIST
3993: LIST
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: LIST
3999: PPUSH
4000: CALL_OW 69
4004: ST_TO_ADDR
// if not eng then
4005: LD_VAR 0 2
4009: NOT
4010: IFFALSE 4102
// begin uc_side := 5 ;
4012: LD_ADDR_OWVAR 20
4016: PUSH
4017: LD_INT 5
4019: ST_TO_ADDR
// uc_nation := 2 ;
4020: LD_ADDR_OWVAR 21
4024: PUSH
4025: LD_INT 2
4027: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4028: LD_INT 0
4030: PPUSH
4031: LD_INT 2
4033: PPUSH
4034: LD_INT 2
4036: PPUSH
4037: CALL_OW 380
// eng := CreateHuman ;
4041: LD_ADDR_VAR 0 2
4045: PUSH
4046: CALL_OW 44
4050: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4051: LD_VAR 0 2
4055: PPUSH
4056: LD_INT 102
4058: PPUSH
4059: LD_INT 8
4061: PPUSH
4062: LD_INT 0
4064: PPUSH
4065: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4069: LD_VAR 0 2
4073: PPUSH
4074: LD_INT 110
4076: PPUSH
4077: LD_INT 60
4079: PPUSH
4080: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4084: LD_ADDR_EXP 34
4088: PUSH
4089: LD_EXP 34
4093: PUSH
4094: LD_VAR 0 2
4098: UNION
4099: ST_TO_ADDR
// end else
4100: GO 4237
// begin for i in eng do
4102: LD_ADDR_VAR 0 1
4106: PUSH
4107: LD_VAR 0 2
4111: PUSH
4112: FOR_IN
4113: IFFALSE 4235
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4115: LD_INT 10
4117: PPUSH
4118: LD_INT 1
4120: PPUSH
4121: CALL_OW 287
4125: IFFALSE 4149
// begin if IsInUnit ( i ) then
4127: LD_VAR 0 1
4131: PPUSH
4132: CALL_OW 310
4136: IFFALSE 4147
// ComExitBuilding ( i ) ;
4138: LD_VAR 0 1
4142: PPUSH
4143: CALL_OW 122
// end else
4147: GO 4233
// begin if damagedBuilding then
4149: LD_VAR 0 3
4153: IFFALSE 4197
// begin if IsInUnit ( i ) then
4155: LD_VAR 0 1
4159: PPUSH
4160: CALL_OW 310
4164: IFFALSE 4177
// ComExitBuilding ( i ) else
4166: LD_VAR 0 1
4170: PPUSH
4171: CALL_OW 122
4175: GO 4195
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4177: LD_VAR 0 1
4181: PPUSH
4182: LD_VAR 0 3
4186: PUSH
4187: LD_INT 1
4189: ARRAY
4190: PPUSH
4191: CALL_OW 130
// end else
4195: GO 4233
// if not IsInUnit ( i ) and not HasTask ( i ) then
4197: LD_VAR 0 1
4201: PPUSH
4202: CALL_OW 310
4206: NOT
4207: PUSH
4208: LD_VAR 0 1
4212: PPUSH
4213: CALL_OW 314
4217: NOT
4218: AND
4219: IFFALSE 4233
// ComEnterUnit ( i , arDepot ) ;
4221: LD_VAR 0 1
4225: PPUSH
4226: LD_INT 5
4228: PPUSH
4229: CALL_OW 120
// end ; end ;
4233: GO 4112
4235: POP
4236: POP
// end ; end ;
4237: PPOPN 3
4239: END
// export function StartCargoEvacuation ; begin
4240: LD_INT 0
4242: PPUSH
// while GetResourceType ( GetBase ( arDepot ) , mat_cans ) > 0 and omarCargoCounter > 0 do
4243: LD_INT 5
4245: PPUSH
4246: CALL_OW 274
4250: PPUSH
4251: LD_INT 1
4253: PPUSH
4254: CALL_OW 275
4258: PUSH
4259: LD_INT 0
4261: GREATER
4262: PUSH
4263: LD_EXP 17
4267: PUSH
4268: LD_INT 0
4270: GREATER
4271: AND
4272: IFFALSE 4564
// begin wait ( 1 1$20 ) ;
4274: LD_INT 2800
4276: PPUSH
4277: CALL_OW 67
// omarCargo := PrepareCargo ;
4281: LD_ADDR_EXP 38
4285: PUSH
4286: CALL 4569 0 0
4290: ST_TO_ADDR
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4291: LD_EXP 38
4295: PPUSH
4296: LD_INT 107
4298: PPUSH
4299: LD_INT 59
4301: PPUSH
4302: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4306: LD_INT 35
4308: PPUSH
4309: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4313: LD_EXP 38
4317: PPUSH
4318: LD_INT 107
4320: PPUSH
4321: LD_INT 59
4323: PPUSH
4324: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4328: LD_EXP 38
4332: PPUSH
4333: CALL_OW 302
4337: NOT
4338: PUSH
4339: LD_EXP 38
4343: PPUSH
4344: CALL_OW 301
4348: OR
4349: IFFALSE 4353
// continue ;
4351: GO 4306
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4353: LD_EXP 38
4357: PPUSH
4358: LD_INT 107
4360: PPUSH
4361: LD_INT 59
4363: PPUSH
4364: CALL_OW 307
4368: PUSH
4369: LD_EXP 38
4373: PPUSH
4374: LD_INT 5
4376: PPUSH
4377: CALL_OW 296
4381: PUSH
4382: LD_INT 6
4384: LESS
4385: OR
4386: IFFALSE 4306
// wait ( 0 0$05 ) ;
4388: LD_INT 175
4390: PPUSH
4391: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
4395: LD_EXP 38
4399: PPUSH
4400: LD_INT 1
4402: PPUSH
4403: LD_INT 100
4405: PPUSH
4406: CALL_OW 290
// SetResourceType ( GetBase ( arDepot ) , mat_cans , GetResourceType ( GetBase ( arDepot ) , mat_cans ) - 100 ) ;
4410: LD_INT 5
4412: PPUSH
4413: CALL_OW 274
4417: PPUSH
4418: LD_INT 1
4420: PPUSH
4421: LD_INT 5
4423: PPUSH
4424: CALL_OW 274
4428: PPUSH
4429: LD_INT 1
4431: PPUSH
4432: CALL_OW 275
4436: PUSH
4437: LD_INT 100
4439: MINUS
4440: PPUSH
4441: CALL_OW 277
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4445: LD_EXP 38
4449: PPUSH
4450: LD_INT 103
4452: PPUSH
4453: LD_INT 9
4455: PPUSH
4456: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4460: LD_INT 35
4462: PPUSH
4463: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4467: LD_EXP 38
4471: PPUSH
4472: LD_INT 103
4474: PPUSH
4475: LD_INT 9
4477: PPUSH
4478: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4482: LD_EXP 38
4486: PPUSH
4487: CALL_OW 302
4491: NOT
4492: PUSH
4493: LD_EXP 38
4497: PPUSH
4498: CALL_OW 301
4502: OR
4503: IFFALSE 4507
// continue ;
4505: GO 4460
// until IsInArea ( omarCargo , northRoad ) and GetCargo ( omarCargo , mat_cans ) > 0 ;
4507: LD_EXP 38
4511: PPUSH
4512: LD_INT 3
4514: PPUSH
4515: CALL_OW 308
4519: PUSH
4520: LD_EXP 38
4524: PPUSH
4525: LD_INT 1
4527: PPUSH
4528: CALL_OW 289
4532: PUSH
4533: LD_INT 0
4535: GREATER
4536: AND
4537: IFFALSE 4460
// RemoveUnit ( omarCargo ) ;
4539: LD_EXP 38
4543: PPUSH
4544: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4548: LD_ADDR_EXP 17
4552: PUSH
4553: LD_EXP 17
4557: PUSH
4558: LD_INT 1
4560: MINUS
4561: ST_TO_ADDR
// end ;
4562: GO 4243
// end ;
4564: LD_VAR 0 1
4568: RET
// export function PrepareCargo ; var un , veh ; begin
4569: LD_INT 0
4571: PPUSH
4572: PPUSH
4573: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4574: LD_ADDR_VAR 0 3
4578: PUSH
4579: LD_INT 5
4581: PPUSH
4582: LD_INT 2
4584: PPUSH
4585: LD_INT 13
4587: PPUSH
4588: LD_INT 1
4590: PPUSH
4591: LD_INT 1
4593: PPUSH
4594: LD_INT 32
4596: PPUSH
4597: LD_INT 80
4599: PPUSH
4600: CALL 289 0 7
4604: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4605: LD_VAR 0 3
4609: PPUSH
4610: LD_INT 4
4612: PPUSH
4613: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4617: LD_VAR 0 3
4621: PPUSH
4622: LD_INT 101
4624: PPUSH
4625: LD_INT 8
4627: PPUSH
4628: LD_INT 0
4630: PPUSH
4631: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4635: LD_INT 0
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 2
4643: PPUSH
4644: CALL_OW 380
// un := CreateHuman ;
4648: LD_ADDR_VAR 0 2
4652: PUSH
4653: CALL_OW 44
4657: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4658: LD_VAR 0 2
4662: PPUSH
4663: LD_VAR 0 3
4667: PPUSH
4668: CALL_OW 52
// result := veh ;
4672: LD_ADDR_VAR 0 1
4676: PUSH
4677: LD_VAR 0 3
4681: ST_TO_ADDR
// end ; end_of_file
4682: LD_VAR 0 1
4686: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
4687: LD_INT 0
4689: PPUSH
4690: PPUSH
4691: PPUSH
// usForces := [ ] ;
4692: LD_ADDR_EXP 39
4696: PUSH
4697: EMPTY
4698: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
4699: LD_ADDR_EXP 41
4703: PUSH
4704: LD_INT 6
4706: PUSH
4707: LD_INT 32
4709: PUSH
4710: LD_INT 27
4712: PUSH
4713: LD_INT 1
4715: PUSH
4716: EMPTY
4717: LIST
4718: LIST
4719: LIST
4720: LIST
4721: PUSH
4722: LD_INT 4
4724: PUSH
4725: LD_INT 43
4727: PUSH
4728: LD_INT 24
4730: PUSH
4731: LD_INT 5
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: LIST
4738: LIST
4739: PUSH
4740: LD_INT 27
4742: PUSH
4743: LD_INT 29
4745: PUSH
4746: LD_INT 21
4748: PUSH
4749: LD_INT 0
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: LIST
4761: LIST
4762: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
4763: LD_INT 11
4765: PPUSH
4766: CALL_OW 274
4770: PPUSH
4771: LD_INT 1
4773: PPUSH
4774: LD_INT 150
4776: PUSH
4777: LD_INT 120
4779: PUSH
4780: LD_INT 100
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: LIST
4787: PUSH
4788: LD_OWVAR 67
4792: ARRAY
4793: PPUSH
4794: CALL_OW 277
// uc_side := 1 ;
4798: LD_ADDR_OWVAR 20
4802: PUSH
4803: LD_INT 1
4805: ST_TO_ADDR
// uc_nation := 1 ;
4806: LD_ADDR_OWVAR 21
4810: PUSH
4811: LD_INT 1
4813: ST_TO_ADDR
// hc_gallery :=  ;
4814: LD_ADDR_OWVAR 33
4818: PUSH
4819: LD_STRING 
4821: ST_TO_ADDR
// hc_name :=  ;
4822: LD_ADDR_OWVAR 26
4826: PUSH
4827: LD_STRING 
4829: ST_TO_ADDR
// hc_importance := 0 ;
4830: LD_ADDR_OWVAR 32
4834: PUSH
4835: LD_INT 0
4837: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
4838: LD_INT 1
4840: PPUSH
4841: LD_INT 1
4843: PPUSH
4844: LD_INT 3
4846: PPUSH
4847: CALL_OW 380
// usCommander := CreateHuman ;
4851: LD_ADDR_EXP 40
4855: PUSH
4856: CALL_OW 44
4860: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
4861: LD_EXP 40
4865: PPUSH
4866: LD_INT 11
4868: PPUSH
4869: CALL_OW 52
// for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4873: LD_ADDR_VAR 0 2
4877: PUSH
4878: DOUBLE
4879: LD_INT 1
4881: DEC
4882: ST_TO_ADDR
4883: LD_INT 2
4885: PUSH
4886: LD_INT 3
4888: PUSH
4889: LD_INT 4
4891: PUSH
4892: EMPTY
4893: LIST
4894: LIST
4895: LIST
4896: PUSH
4897: LD_OWVAR 67
4901: ARRAY
4902: PUSH
4903: FOR_TO
4904: IFFALSE 5039
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
4906: LD_INT 0
4908: PPUSH
4909: LD_INT 1
4911: PPUSH
4912: LD_INT 1
4914: PUSH
4915: LD_INT 2
4917: PUSH
4918: LD_INT 3
4920: PUSH
4921: EMPTY
4922: LIST
4923: LIST
4924: LIST
4925: PUSH
4926: LD_OWVAR 67
4930: ARRAY
4931: PPUSH
4932: CALL_OW 380
// un := CreateHuman ;
4936: LD_ADDR_VAR 0 3
4940: PUSH
4941: CALL_OW 44
4945: ST_TO_ADDR
// usForces := usForces union un ;
4946: LD_ADDR_EXP 39
4950: PUSH
4951: LD_EXP 39
4955: PUSH
4956: LD_VAR 0 3
4960: UNION
4961: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
4962: LD_VAR 0 3
4966: PPUSH
4967: LD_INT 39
4969: PPUSH
4970: LD_INT 24
4972: PPUSH
4973: LD_INT 4
4975: PPUSH
4976: LD_INT 0
4978: PPUSH
4979: CALL_OW 50
// if i < 3 then
4983: LD_VAR 0 2
4987: PUSH
4988: LD_INT 3
4990: LESS
4991: IFFALSE 5037
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
4993: LD_VAR 0 3
4997: PPUSH
4998: LD_INT 22
5000: PUSH
5001: LD_INT 1
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: LD_INT 30
5010: PUSH
5011: LD_INT 31
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: PUSH
5018: EMPTY
5019: LIST
5020: LIST
5021: PPUSH
5022: CALL_OW 69
5026: PUSH
5027: LD_VAR 0 2
5031: ARRAY
5032: PPUSH
5033: CALL_OW 120
// end ;
5037: GO 4903
5039: POP
5040: POP
// for i := 1 to 2 do
5041: LD_ADDR_VAR 0 2
5045: PUSH
5046: DOUBLE
5047: LD_INT 1
5049: DEC
5050: ST_TO_ADDR
5051: LD_INT 2
5053: PUSH
5054: FOR_TO
5055: IFFALSE 5119
// begin PrepareHuman ( false , 2 , 2 ) ;
5057: LD_INT 0
5059: PPUSH
5060: LD_INT 2
5062: PPUSH
5063: LD_INT 2
5065: PPUSH
5066: CALL_OW 380
// un := CreateHuman ;
5070: LD_ADDR_VAR 0 3
5074: PUSH
5075: CALL_OW 44
5079: ST_TO_ADDR
// usForces := usForces union un ;
5080: LD_ADDR_EXP 39
5084: PUSH
5085: LD_EXP 39
5089: PUSH
5090: LD_VAR 0 3
5094: UNION
5095: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5096: LD_VAR 0 3
5100: PPUSH
5101: LD_INT 39
5103: PPUSH
5104: LD_INT 24
5106: PPUSH
5107: LD_INT 4
5109: PPUSH
5110: LD_INT 0
5112: PPUSH
5113: CALL_OW 50
// end ;
5117: GO 5054
5119: POP
5120: POP
// PrepareHuman ( false , 4 , 1 ) ;
5121: LD_INT 0
5123: PPUSH
5124: LD_INT 4
5126: PPUSH
5127: LD_INT 1
5129: PPUSH
5130: CALL_OW 380
// un := CreateHuman ;
5134: LD_ADDR_VAR 0 3
5138: PUSH
5139: CALL_OW 44
5143: ST_TO_ADDR
// usForces := usForces union un ;
5144: LD_ADDR_EXP 39
5148: PUSH
5149: LD_EXP 39
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5160: LD_VAR 0 3
5164: PPUSH
5165: LD_INT 39
5167: PPUSH
5168: LD_INT 24
5170: PPUSH
5171: LD_INT 4
5173: PPUSH
5174: LD_INT 0
5176: PPUSH
5177: CALL_OW 50
// end ;
5181: LD_VAR 0 1
5185: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
5186: LD_EXP 39
5190: PUSH
5191: LD_EXP 6
5195: NOT
5196: AND
5197: IFFALSE 5520
5199: GO 5201
5201: DISABLE
5202: LD_INT 0
5204: PPUSH
5205: PPUSH
5206: PPUSH
5207: PPUSH
5208: PPUSH
// begin enable ;
5209: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5210: LD_ADDR_VAR 0 3
5214: PUSH
5215: LD_EXP 39
5219: PPUSH
5220: LD_INT 25
5222: PUSH
5223: LD_INT 2
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PPUSH
5230: CALL_OW 72
5234: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5235: LD_ADDR_VAR 0 4
5239: PUSH
5240: LD_EXP 39
5244: PPUSH
5245: LD_INT 25
5247: PUSH
5248: LD_INT 1
5250: PUSH
5251: EMPTY
5252: LIST
5253: LIST
5254: PPUSH
5255: CALL_OW 72
5259: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5260: LD_ADDR_VAR 0 5
5264: PUSH
5265: LD_EXP 39
5269: PPUSH
5270: LD_INT 25
5272: PUSH
5273: LD_INT 4
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: PPUSH
5280: CALL_OW 72
5284: ST_TO_ADDR
// if eng then
5285: LD_VAR 0 3
5289: IFFALSE 5520
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5291: LD_ADDR_VAR 0 2
5295: PUSH
5296: LD_INT 22
5298: PUSH
5299: LD_INT 1
5301: PUSH
5302: EMPTY
5303: LIST
5304: LIST
5305: PUSH
5306: LD_INT 21
5308: PUSH
5309: LD_INT 3
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 3
5318: PUSH
5319: LD_INT 24
5321: PUSH
5322: LD_INT 1000
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: PUSH
5329: EMPTY
5330: LIST
5331: LIST
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PPUSH
5338: CALL_OW 69
5342: ST_TO_ADDR
// if b then
5343: LD_VAR 0 2
5347: IFFALSE 5378
// begin ComExitBuilding ( eng ) ;
5349: LD_VAR 0 3
5353: PPUSH
5354: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5358: LD_VAR 0 3
5362: PPUSH
5363: LD_VAR 0 2
5367: PUSH
5368: LD_INT 1
5370: ARRAY
5371: PPUSH
5372: CALL_OW 190
// end else
5376: GO 5520
// begin for i in eng do
5378: LD_ADDR_VAR 0 1
5382: PUSH
5383: LD_VAR 0 3
5387: PUSH
5388: FOR_IN
5389: IFFALSE 5518
// if not HasTask ( i ) then
5391: LD_VAR 0 1
5395: PPUSH
5396: CALL_OW 314
5400: NOT
5401: IFFALSE 5516
// begin if americanBuildList then
5403: LD_EXP 41
5407: IFFALSE 5492
// begin if IsInUnit ( i ) then
5409: LD_VAR 0 1
5413: PPUSH
5414: CALL_OW 310
5418: IFFALSE 5429
// ComExitBuilding ( i ) ;
5420: LD_VAR 0 1
5424: PPUSH
5425: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5429: LD_VAR 0 1
5433: PPUSH
5434: LD_EXP 41
5438: PUSH
5439: LD_INT 1
5441: ARRAY
5442: PUSH
5443: LD_INT 1
5445: ARRAY
5446: PPUSH
5447: LD_EXP 41
5451: PUSH
5452: LD_INT 1
5454: ARRAY
5455: PUSH
5456: LD_INT 2
5458: ARRAY
5459: PPUSH
5460: LD_EXP 41
5464: PUSH
5465: LD_INT 1
5467: ARRAY
5468: PUSH
5469: LD_INT 3
5471: ARRAY
5472: PPUSH
5473: LD_EXP 41
5477: PUSH
5478: LD_INT 1
5480: ARRAY
5481: PUSH
5482: LD_INT 4
5484: ARRAY
5485: PPUSH
5486: CALL_OW 205
// end else
5490: GO 5516
// if not IsInUnit ( i ) then
5492: LD_VAR 0 1
5496: PPUSH
5497: CALL_OW 310
5501: NOT
5502: IFFALSE 5516
// ComEnterUnit ( i , usDepot ) ;
5504: LD_VAR 0 1
5508: PPUSH
5509: LD_INT 11
5511: PPUSH
5512: CALL_OW 120
// end ;
5516: GO 5388
5518: POP
5519: POP
// end ; end ; end ;
5520: PPOPN 5
5522: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
5523: LD_INT 0
5525: PPUSH
5526: PPUSH
5527: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
5528: LD_ADDR_VAR 0 3
5532: PUSH
5533: LD_INT 35
5535: PUSH
5536: LD_INT 45
5538: PUSH
5539: LD_INT 48
5541: PUSH
5542: LD_EXP 50
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: LIST
5552: ST_TO_ADDR
// for i in tech do
5553: LD_ADDR_VAR 0 4
5557: PUSH
5558: LD_VAR 0 3
5562: PUSH
5563: FOR_IN
5564: IFFALSE 5582
// AddComResearch ( lab , i ) ;
5566: LD_VAR 0 1
5570: PPUSH
5571: LD_VAR 0 4
5575: PPUSH
5576: CALL_OW 184
5580: GO 5563
5582: POP
5583: POP
// end ;
5584: LD_VAR 0 2
5588: RET
// every 8 8$00 + 2 2$00 trigger allowConvoys and convoyCounter < 15 do
5589: LD_EXP 11
5593: PUSH
5594: LD_EXP 19
5598: PUSH
5599: LD_INT 15
5601: LESS
5602: AND
5603: IFFALSE 5613
5605: GO 5607
5607: DISABLE
// begin enable ;
5608: ENABLE
// SendConvoy ;
5609: CALL 5711 0 0
// end ;
5613: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
5614: LD_EXP 6
5618: PUSH
5619: LD_EXP 15
5623: AND
5624: IFFALSE 5710
5626: GO 5628
5628: DISABLE
// begin if americanHasEscaped then
5629: LD_EXP 7
5633: IFFALSE 5644
// wait ( 5 5$00 ) else
5635: LD_INT 10500
5637: PPUSH
5638: CALL_OW 67
5642: GO 5651
// wait ( 7 7$00 ) ;
5644: LD_INT 14700
5646: PPUSH
5647: CALL_OW 67
// SendAttack ;
5651: CALL 6297 0 0
// repeat wait ( [ 8 8$30 , 6 6$30 , 5 5$30 ] [ Difficulty ] ) ;
5655: LD_INT 17850
5657: PUSH
5658: LD_INT 13650
5660: PUSH
5661: LD_INT 11550
5663: PUSH
5664: EMPTY
5665: LIST
5666: LIST
5667: LIST
5668: PUSH
5669: LD_OWVAR 67
5673: ARRAY
5674: PPUSH
5675: CALL_OW 67
// SendAttack ;
5679: CALL 6297 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
5683: LD_EXP 16
5687: PUSH
5688: LD_INT 6
5690: PUSH
5691: LD_INT 7
5693: PUSH
5694: LD_INT 8
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: PUSH
5702: LD_OWVAR 67
5706: ARRAY
5707: LESS
5708: IFFALSE 5655
// end ;
5710: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
5711: LD_INT 0
5713: PPUSH
5714: PPUSH
5715: PPUSH
5716: PPUSH
5717: PPUSH
5718: PPUSH
5719: PPUSH
5720: PPUSH
// road := rand ( 1 , 2 ) ;
5721: LD_ADDR_VAR 0 4
5725: PUSH
5726: LD_INT 1
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 12
5736: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
5737: LD_ADDR_VAR 0 8
5741: PUSH
5742: LD_INT 3
5744: PUSH
5745: LD_INT 8
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: PUSH
5752: LD_VAR 0 4
5756: ARRAY
5757: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
5758: LD_ADDR_VAR 0 5
5762: PUSH
5763: LD_INT 35
5765: PUSH
5766: LD_INT 66
5768: PUSH
5769: LD_INT 1
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: LIST
5776: PUSH
5777: LD_INT 101
5779: PUSH
5780: LD_INT 8
5782: PUSH
5783: LD_INT 4
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: EMPTY
5792: LIST
5793: LIST
5794: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
5795: LD_ADDR_VAR 0 6
5799: PUSH
5800: LD_INT 34
5802: PUSH
5803: LD_INT 67
5805: PUSH
5806: EMPTY
5807: LIST
5808: LIST
5809: PUSH
5810: LD_INT 38
5812: PUSH
5813: LD_INT 62
5815: PUSH
5816: EMPTY
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 43
5822: PUSH
5823: LD_INT 54
5825: PUSH
5826: EMPTY
5827: LIST
5828: LIST
5829: PUSH
5830: LD_INT 57
5832: PUSH
5833: LD_INT 57
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: PUSH
5840: LD_INT 77
5842: PUSH
5843: LD_INT 71
5845: PUSH
5846: EMPTY
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 86
5852: PUSH
5853: LD_INT 60
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: PUSH
5860: LD_INT 89
5862: PUSH
5863: LD_INT 35
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PUSH
5870: LD_INT 93
5872: PUSH
5873: LD_INT 17
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PUSH
5880: LD_INT 97
5882: PUSH
5883: LD_INT 10
5885: PUSH
5886: EMPTY
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 103
5892: PUSH
5893: LD_INT 9
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: ST_TO_ADDR
// if road = 2 then
5912: LD_VAR 0 4
5916: PUSH
5917: LD_INT 2
5919: EQUAL
5920: IFFALSE 5937
// points := ReverseArray ( points ) ;
5922: LD_ADDR_VAR 0 6
5926: PUSH
5927: LD_VAR 0 6
5931: PPUSH
5932: CALL 977 0 1
5936: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
5937: LD_INT 4
5939: PPUSH
5940: LD_INT 1
5942: PPUSH
5943: LD_INT 2
5945: PPUSH
5946: LD_INT 1
5948: PPUSH
5949: LD_INT 1
5951: PPUSH
5952: LD_INT 12
5954: PPUSH
5955: LD_INT 80
5957: PPUSH
5958: CALL 289 0 7
// veh := CreateVehicle ;
5962: LD_ADDR_VAR 0 3
5966: PUSH
5967: CALL_OW 45
5971: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
5972: LD_VAR 0 3
5976: PPUSH
5977: LD_VAR 0 5
5981: PUSH
5982: LD_VAR 0 4
5986: ARRAY
5987: PUSH
5988: LD_INT 3
5990: ARRAY
5991: PPUSH
5992: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
5996: LD_VAR 0 3
6000: PPUSH
6001: LD_VAR 0 5
6005: PUSH
6006: LD_VAR 0 4
6010: ARRAY
6011: PUSH
6012: LD_INT 1
6014: ARRAY
6015: PPUSH
6016: LD_VAR 0 5
6020: PUSH
6021: LD_VAR 0 4
6025: ARRAY
6026: PUSH
6027: LD_INT 2
6029: ARRAY
6030: PPUSH
6031: LD_INT 0
6033: PPUSH
6034: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6038: LD_INT 0
6040: PPUSH
6041: LD_INT 1
6043: PPUSH
6044: LD_OWVAR 67
6048: PPUSH
6049: CALL_OW 380
// un := CreateHuman ;
6053: LD_ADDR_VAR 0 2
6057: PUSH
6058: CALL_OW 44
6062: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6063: LD_VAR 0 2
6067: PPUSH
6068: LD_VAR 0 3
6072: PPUSH
6073: CALL_OW 52
// if Prob ( 50 + tick mod 30 ) then
6077: LD_INT 50
6079: PUSH
6080: LD_OWVAR 1
6084: PUSH
6085: LD_INT 30
6087: MOD
6088: PLUS
6089: PPUSH
6090: CALL_OW 13
6094: IFFALSE 6111
// SetCargo ( veh , mat_cans , 100 ) ;
6096: LD_VAR 0 3
6100: PPUSH
6101: LD_INT 1
6103: PPUSH
6104: LD_INT 100
6106: PPUSH
6107: CALL_OW 290
// for i := 2 to points do
6111: LD_ADDR_VAR 0 7
6115: PUSH
6116: DOUBLE
6117: LD_INT 2
6119: DEC
6120: ST_TO_ADDR
6121: LD_VAR 0 6
6125: PUSH
6126: FOR_TO
6127: IFFALSE 6170
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6129: LD_VAR 0 3
6133: PPUSH
6134: LD_VAR 0 6
6138: PUSH
6139: LD_VAR 0 7
6143: ARRAY
6144: PUSH
6145: LD_INT 1
6147: ARRAY
6148: PPUSH
6149: LD_VAR 0 6
6153: PUSH
6154: LD_VAR 0 7
6158: ARRAY
6159: PUSH
6160: LD_INT 2
6162: ARRAY
6163: PPUSH
6164: CALL_OW 171
6168: GO 6126
6170: POP
6171: POP
// convoyCounter := convoyCounter + 1 ;
6172: LD_ADDR_EXP 19
6176: PUSH
6177: LD_EXP 19
6181: PUSH
6182: LD_INT 1
6184: PLUS
6185: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6186: LD_INT 35
6188: PPUSH
6189: CALL_OW 67
// if not HasTask ( veh ) then
6193: LD_VAR 0 3
6197: PPUSH
6198: CALL_OW 314
6202: NOT
6203: IFFALSE 6244
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6205: LD_VAR 0 3
6209: PPUSH
6210: LD_VAR 0 6
6214: PUSH
6215: LD_VAR 0 6
6219: ARRAY
6220: PUSH
6221: LD_INT 1
6223: ARRAY
6224: PPUSH
6225: LD_VAR 0 6
6229: PUSH
6230: LD_VAR 0 6
6234: ARRAY
6235: PUSH
6236: LD_INT 2
6238: ARRAY
6239: PPUSH
6240: CALL_OW 111
// if not IsOk ( veh ) then
6244: LD_VAR 0 3
6248: PPUSH
6249: CALL_OW 302
6253: NOT
6254: IFFALSE 6258
// break ;
6256: GO 6274
// until IsInArea ( veh , finalArea ) ;
6258: LD_VAR 0 3
6262: PPUSH
6263: LD_VAR 0 8
6267: PPUSH
6268: CALL_OW 308
6272: IFFALSE 6186
// RemoveUnit ( un ) ;
6274: LD_VAR 0 2
6278: PPUSH
6279: CALL_OW 64
// RemoveUnit ( veh ) ;
6283: LD_VAR 0 3
6287: PPUSH
6288: CALL_OW 64
// end ;
6292: LD_VAR 0 1
6296: RET
// export function SendAttack ; var un , veh , i ; begin
6297: LD_INT 0
6299: PPUSH
6300: PPUSH
6301: PPUSH
6302: PPUSH
// IncomingAttack ;
6303: CALL 13912 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
6307: LD_INT 2100
6309: PPUSH
6310: LD_INT 3500
6312: PPUSH
6313: CALL_OW 12
6317: PPUSH
6318: CALL_OW 67
// for i := 1 to [ 3 , 3 , 4 ] [ Difficulty ] + attackWave div 3 do
6322: LD_ADDR_VAR 0 4
6326: PUSH
6327: DOUBLE
6328: LD_INT 1
6330: DEC
6331: ST_TO_ADDR
6332: LD_INT 3
6334: PUSH
6335: LD_INT 3
6337: PUSH
6338: LD_INT 4
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_OWVAR 67
6350: ARRAY
6351: PUSH
6352: LD_EXP 16
6356: PUSH
6357: LD_INT 3
6359: DIV
6360: PLUS
6361: PUSH
6362: FOR_TO
6363: IFFALSE 6475
// begin uc_side := 1 ;
6365: LD_ADDR_OWVAR 20
6369: PUSH
6370: LD_INT 1
6372: ST_TO_ADDR
// uc_nation := 1 ;
6373: LD_ADDR_OWVAR 21
6377: PUSH
6378: LD_INT 1
6380: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
6381: LD_INT 0
6383: PPUSH
6384: LD_INT 1
6386: PPUSH
6387: LD_INT 2
6389: PUSH
6390: LD_INT 3
6392: PUSH
6393: LD_INT 4
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: LIST
6400: PUSH
6401: LD_OWVAR 67
6405: ARRAY
6406: PPUSH
6407: CALL_OW 380
// un := CreateHuman ;
6411: LD_ADDR_VAR 0 2
6415: PUSH
6416: CALL_OW 44
6420: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
6421: LD_VAR 0 2
6425: PPUSH
6426: LD_INT 37
6428: PPUSH
6429: LD_INT 70
6431: PPUSH
6432: LD_INT 3
6434: PPUSH
6435: LD_INT 0
6437: PPUSH
6438: CALL_OW 50
// usForces := usForces union un ;
6442: LD_ADDR_EXP 39
6446: PUSH
6447: LD_EXP 39
6451: PUSH
6452: LD_VAR 0 2
6456: UNION
6457: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
6458: LD_VAR 0 2
6462: PPUSH
6463: LD_INT 40
6465: PPUSH
6466: LD_INT 65
6468: PPUSH
6469: CALL_OW 111
// end ;
6473: GO 6362
6475: POP
6476: POP
// if attackWave > 2 then
6477: LD_EXP 16
6481: PUSH
6482: LD_INT 2
6484: GREATER
6485: IFFALSE 6578
// begin uc_side := 1 ;
6487: LD_ADDR_OWVAR 20
6491: PUSH
6492: LD_INT 1
6494: ST_TO_ADDR
// uc_nation := 1 ;
6495: LD_ADDR_OWVAR 21
6499: PUSH
6500: LD_INT 1
6502: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
6503: LD_INT 0
6505: PPUSH
6506: LD_INT 4
6508: PPUSH
6509: LD_INT 2
6511: PPUSH
6512: CALL_OW 380
// un := CreateHuman ;
6516: LD_ADDR_VAR 0 2
6520: PUSH
6521: CALL_OW 44
6525: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
6526: LD_VAR 0 2
6530: PPUSH
6531: LD_INT 37
6533: PPUSH
6534: LD_INT 70
6536: PPUSH
6537: LD_INT 3
6539: PPUSH
6540: LD_INT 0
6542: PPUSH
6543: CALL_OW 50
// usForces := usForces union un ;
6547: LD_ADDR_EXP 39
6551: PUSH
6552: LD_EXP 39
6556: PUSH
6557: LD_VAR 0 2
6561: UNION
6562: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
6563: LD_VAR 0 2
6567: PPUSH
6568: LD_INT 40
6570: PPUSH
6571: LD_INT 65
6573: PPUSH
6574: CALL_OW 111
// end ; if attackWave > 1 or Difficulty > 1 then
6578: LD_EXP 16
6582: PUSH
6583: LD_INT 1
6585: GREATER
6586: PUSH
6587: LD_OWVAR 67
6591: PUSH
6592: LD_INT 1
6594: GREATER
6595: OR
6596: IFFALSE 6783
// begin for i := 1 to Difficulty + attackWave div 4 do
6598: LD_ADDR_VAR 0 4
6602: PUSH
6603: DOUBLE
6604: LD_INT 1
6606: DEC
6607: ST_TO_ADDR
6608: LD_OWVAR 67
6612: PUSH
6613: LD_EXP 16
6617: PUSH
6618: LD_INT 4
6620: DIV
6621: PLUS
6622: PUSH
6623: FOR_TO
6624: IFFALSE 6781
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
6626: LD_ADDR_VAR 0 3
6630: PUSH
6631: LD_INT 1
6633: PPUSH
6634: LD_INT 1
6636: PPUSH
6637: LD_INT 2
6639: PPUSH
6640: LD_INT 2
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: LD_INT 4
6648: PUSH
6649: LD_INT 3
6651: PUSH
6652: LD_INT 2
6654: PUSH
6655: EMPTY
6656: LIST
6657: LIST
6658: LIST
6659: PUSH
6660: LD_INT 1
6662: PPUSH
6663: LD_INT 3
6665: PPUSH
6666: CALL_OW 12
6670: ARRAY
6671: PPUSH
6672: LD_INT 90
6674: PPUSH
6675: CALL 289 0 7
6679: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
6680: LD_VAR 0 3
6684: PPUSH
6685: LD_INT 35
6687: PPUSH
6688: LD_INT 65
6690: PPUSH
6691: LD_INT 0
6693: PPUSH
6694: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
6698: LD_INT 0
6700: PPUSH
6701: LD_INT 3
6703: PPUSH
6704: LD_OWVAR 67
6708: PUSH
6709: LD_INT 1
6711: PLUS
6712: PPUSH
6713: CALL_OW 380
// un := CreateHuman ;
6717: LD_ADDR_VAR 0 2
6721: PUSH
6722: CALL_OW 44
6726: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6727: LD_VAR 0 2
6731: PPUSH
6732: LD_VAR 0 3
6736: PPUSH
6737: CALL_OW 52
// ComMoveXY ( veh , 39 , 60 ) ;
6741: LD_VAR 0 3
6745: PPUSH
6746: LD_INT 39
6748: PPUSH
6749: LD_INT 60
6751: PPUSH
6752: CALL_OW 111
// wait ( 0 0$2 ) ;
6756: LD_INT 70
6758: PPUSH
6759: CALL_OW 67
// usForces := usForces union veh ;
6763: LD_ADDR_EXP 39
6767: PUSH
6768: LD_EXP 39
6772: PUSH
6773: LD_VAR 0 3
6777: UNION
6778: ST_TO_ADDR
// end ;
6779: GO 6623
6781: POP
6782: POP
// end ; attackWave := attackWave + 1 ;
6783: LD_ADDR_EXP 16
6787: PUSH
6788: LD_EXP 16
6792: PUSH
6793: LD_INT 1
6795: PLUS
6796: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
6797: LD_EXP 20
6801: PPUSH
6802: CALL_OW 427
// end ;
6806: LD_VAR 0 1
6810: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
6811: LD_INT 0
6813: PPUSH
6814: PPUSH
6815: PPUSH
6816: PPUSH
6817: PPUSH
6818: PPUSH
6819: PPUSH
6820: PPUSH
6821: PPUSH
6822: PPUSH
6823: PPUSH
// if retreatAllowed then
6824: LD_EXP 10
6828: IFFALSE 6840
// strategy := 2 else
6830: LD_ADDR_VAR 0 5
6834: PUSH
6835: LD_INT 2
6837: ST_TO_ADDR
6838: GO 6856
// strategy := rand ( 0 , 2 ) ;
6840: LD_ADDR_VAR 0 5
6844: PUSH
6845: LD_INT 0
6847: PPUSH
6848: LD_INT 2
6850: PPUSH
6851: CALL_OW 12
6855: ST_TO_ADDR
// attackFormula := [ ] ;
6856: LD_ADDR_VAR 0 6
6860: PUSH
6861: EMPTY
6862: ST_TO_ADDR
// case strategy of 0 :
6863: LD_VAR 0 5
6867: PUSH
6868: LD_INT 0
6870: DOUBLE
6871: EQUAL
6872: IFTRUE 6876
6874: GO 7173
6876: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
6877: LD_INT 11
6879: PPUSH
6880: LD_INT 22
6882: PUSH
6883: LD_INT 2
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PUSH
6890: LD_INT 30
6892: PUSH
6893: LD_INT 4
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PPUSH
6904: CALL_OW 70
6908: NOT
6909: IFFALSE 6970
// attackFormula := [ [ [ 41 , 34 ] ] , [ 33 , 46 ] , [ 41 , 34 ] , [ [ 39 , 53 ] ] ] else
6911: LD_ADDR_VAR 0 6
6915: PUSH
6916: LD_INT 41
6918: PUSH
6919: LD_INT 34
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PUSH
6926: EMPTY
6927: LIST
6928: PUSH
6929: LD_INT 33
6931: PUSH
6932: LD_INT 46
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: LD_INT 41
6941: PUSH
6942: LD_INT 34
6944: PUSH
6945: EMPTY
6946: LIST
6947: LIST
6948: PUSH
6949: LD_INT 39
6951: PUSH
6952: LD_INT 53
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: PUSH
6959: EMPTY
6960: LIST
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: ST_TO_ADDR
6968: GO 7171
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
6970: LD_INT 12
6972: PPUSH
6973: LD_INT 22
6975: PUSH
6976: LD_INT 2
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 2
6985: PUSH
6986: LD_INT 30
6988: PUSH
6989: LD_INT 4
6991: PUSH
6992: EMPTY
6993: LIST
6994: LIST
6995: PUSH
6996: LD_INT 30
6998: PUSH
6999: LD_INT 31
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: PUSH
7006: LD_INT 30
7008: PUSH
7009: LD_INT 32
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PUSH
7016: EMPTY
7017: LIST
7018: LIST
7019: LIST
7020: LIST
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PPUSH
7026: CALL_OW 70
7030: NOT
7031: IFFALSE 7103
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 33 , 46 ] , [ 41 , 34 ] , [ [ 39 , 53 ] ] ] else
7033: LD_ADDR_VAR 0 6
7037: PUSH
7038: LD_INT 27
7040: PUSH
7041: LD_INT 42
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: PUSH
7048: LD_INT 27
7050: PUSH
7051: LD_INT 32
7053: PUSH
7054: EMPTY
7055: LIST
7056: LIST
7057: PUSH
7058: EMPTY
7059: LIST
7060: LIST
7061: PUSH
7062: LD_INT 33
7064: PUSH
7065: LD_INT 46
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: LD_INT 41
7074: PUSH
7075: LD_INT 34
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 39
7084: PUSH
7085: LD_INT 53
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: PUSH
7095: EMPTY
7096: LIST
7097: LIST
7098: LIST
7099: LIST
7100: ST_TO_ADDR
7101: GO 7171
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 41 , 34 ] , [ [ 39 , 53 ] ] ] ;
7103: LD_ADDR_VAR 0 6
7107: PUSH
7108: LD_INT 71
7110: PUSH
7111: LD_INT 67
7113: PUSH
7114: EMPTY
7115: LIST
7116: LIST
7117: PUSH
7118: LD_INT 54
7120: PUSH
7121: LD_INT 35
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: PUSH
7128: EMPTY
7129: LIST
7130: LIST
7131: PUSH
7132: LD_INT 63
7134: PUSH
7135: LD_INT 40
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PUSH
7142: LD_INT 41
7144: PUSH
7145: LD_INT 34
7147: PUSH
7148: EMPTY
7149: LIST
7150: LIST
7151: PUSH
7152: LD_INT 39
7154: PUSH
7155: LD_INT 53
7157: PUSH
7158: EMPTY
7159: LIST
7160: LIST
7161: PUSH
7162: EMPTY
7163: LIST
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: ST_TO_ADDR
// end ; 1 :
7171: GO 7343
7173: LD_INT 1
7175: DOUBLE
7176: EQUAL
7177: IFTRUE 7181
7179: GO 7274
7181: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 63 , 40 ] , [ 41 , 34 ] , [ [ 39 , 53 ] ] ] ; 2 :
7182: LD_ADDR_VAR 0 6
7186: PUSH
7187: LD_INT 71
7189: PUSH
7190: LD_INT 67
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: PUSH
7197: LD_INT 82
7199: PUSH
7200: LD_INT 23
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: PUSH
7207: LD_INT 53
7209: PUSH
7210: LD_INT 7
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PUSH
7217: LD_INT 43
7219: PUSH
7220: LD_INT 10
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: LIST
7231: LIST
7232: PUSH
7233: LD_INT 63
7235: PUSH
7236: LD_INT 40
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: PUSH
7243: LD_INT 41
7245: PUSH
7246: LD_INT 34
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PUSH
7253: LD_INT 39
7255: PUSH
7256: LD_INT 53
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: EMPTY
7264: LIST
7265: PUSH
7266: EMPTY
7267: LIST
7268: LIST
7269: LIST
7270: LIST
7271: ST_TO_ADDR
7272: GO 7343
7274: LD_INT 2
7276: DOUBLE
7277: EQUAL
7278: IFTRUE 7282
7280: GO 7342
7282: POP
// attackFormula := [ [ [ 95 , 61 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 95 , 61 ] ] ] ; end ;
7283: LD_ADDR_VAR 0 6
7287: PUSH
7288: LD_INT 95
7290: PUSH
7291: LD_INT 61
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: PUSH
7298: EMPTY
7299: LIST
7300: PUSH
7301: LD_INT 82
7303: PUSH
7304: LD_INT 75
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: PUSH
7311: LD_INT 73
7313: PUSH
7314: LD_INT 67
7316: PUSH
7317: EMPTY
7318: LIST
7319: LIST
7320: PUSH
7321: LD_INT 95
7323: PUSH
7324: LD_INT 61
7326: PUSH
7327: EMPTY
7328: LIST
7329: LIST
7330: PUSH
7331: EMPTY
7332: LIST
7333: PUSH
7334: EMPTY
7335: LIST
7336: LIST
7337: LIST
7338: LIST
7339: ST_TO_ADDR
7340: GO 7343
7342: POP
// if not attackFormula then
7343: LD_VAR 0 6
7347: NOT
7348: IFFALSE 7352
// exit ;
7350: GO 8779
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
7352: LD_ADDR_VAR 0 7
7356: PUSH
7357: LD_EXP 42
7361: PPUSH
7362: LD_INT 25
7364: PUSH
7365: LD_INT 1
7367: PUSH
7368: EMPTY
7369: LIST
7370: LIST
7371: PPUSH
7372: CALL_OW 72
7376: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
7377: LD_ADDR_VAR 0 8
7381: PUSH
7382: LD_EXP 42
7386: PPUSH
7387: LD_INT 25
7389: PUSH
7390: LD_INT 4
7392: PUSH
7393: EMPTY
7394: LIST
7395: LIST
7396: PPUSH
7397: CALL_OW 72
7401: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
7402: LD_ADDR_VAR 0 9
7406: PUSH
7407: LD_EXP 42
7411: PPUSH
7412: LD_INT 25
7414: PUSH
7415: LD_INT 3
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: PPUSH
7422: CALL_OW 72
7426: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
7427: LD_ADDR_VAR 0 10
7431: PUSH
7432: LD_EXP 42
7436: PPUSH
7437: LD_INT 21
7439: PUSH
7440: LD_INT 2
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PPUSH
7447: CALL_OW 72
7451: ST_TO_ADDR
// if sci then
7452: LD_VAR 0 8
7456: IFFALSE 7493
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
7458: LD_VAR 0 8
7462: PPUSH
7463: LD_VAR 0 6
7467: PUSH
7468: LD_INT 2
7470: ARRAY
7471: PUSH
7472: LD_INT 1
7474: ARRAY
7475: PPUSH
7476: LD_VAR 0 6
7480: PUSH
7481: LD_INT 2
7483: ARRAY
7484: PUSH
7485: LD_INT 2
7487: ARRAY
7488: PPUSH
7489: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7493: LD_INT 35
7495: PPUSH
7496: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
7500: LD_ADDR_VAR 0 7
7504: PUSH
7505: LD_EXP 42
7509: PPUSH
7510: LD_INT 25
7512: PUSH
7513: LD_INT 1
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PPUSH
7520: CALL_OW 72
7524: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
7525: LD_ADDR_VAR 0 8
7529: PUSH
7530: LD_EXP 42
7534: PPUSH
7535: LD_INT 25
7537: PUSH
7538: LD_INT 4
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PPUSH
7545: CALL_OW 72
7549: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
7550: LD_ADDR_VAR 0 9
7554: PUSH
7555: LD_EXP 42
7559: PPUSH
7560: LD_INT 25
7562: PUSH
7563: LD_INT 3
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PPUSH
7570: CALL_OW 72
7574: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
7575: LD_ADDR_VAR 0 10
7579: PUSH
7580: LD_EXP 42
7584: PPUSH
7585: LD_INT 21
7587: PUSH
7588: LD_INT 2
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: PPUSH
7595: CALL_OW 72
7599: ST_TO_ADDR
// if sol then
7600: LD_VAR 0 7
7604: IFFALSE 7990
// begin for i in sol do
7606: LD_ADDR_VAR 0 2
7610: PUSH
7611: LD_VAR 0 7
7615: PUSH
7616: FOR_IN
7617: IFFALSE 7988
// begin tag := GetTag ( i ) ;
7619: LD_ADDR_VAR 0 4
7623: PUSH
7624: LD_VAR 0 2
7628: PPUSH
7629: CALL_OW 110
7633: ST_TO_ADDR
// if not tag then
7634: LD_VAR 0 4
7638: NOT
7639: IFFALSE 7748
// begin if GetLives ( i ) = 1000 then
7641: LD_VAR 0 2
7645: PPUSH
7646: CALL_OW 256
7650: PUSH
7651: LD_INT 1000
7653: EQUAL
7654: IFFALSE 7670
// SetTag ( i , 1 ) else
7656: LD_VAR 0 2
7660: PPUSH
7661: LD_INT 1
7663: PPUSH
7664: CALL_OW 109
7668: GO 7746
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
7670: LD_VAR 0 2
7674: PPUSH
7675: LD_VAR 0 6
7679: PUSH
7680: LD_INT 2
7682: ARRAY
7683: PUSH
7684: LD_INT 1
7686: ARRAY
7687: PPUSH
7688: LD_VAR 0 6
7692: PUSH
7693: LD_INT 2
7695: ARRAY
7696: PUSH
7697: LD_INT 2
7699: ARRAY
7700: PPUSH
7701: CALL_OW 297
7705: PUSH
7706: LD_INT 6
7708: GREATER
7709: IFFALSE 7746
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
7711: LD_VAR 0 2
7715: PPUSH
7716: LD_VAR 0 6
7720: PUSH
7721: LD_INT 2
7723: ARRAY
7724: PUSH
7725: LD_INT 1
7727: ARRAY
7728: PPUSH
7729: LD_VAR 0 6
7733: PUSH
7734: LD_INT 2
7736: ARRAY
7737: PUSH
7738: LD_INT 2
7740: ARRAY
7741: PPUSH
7742: CALL_OW 111
// end else
7746: GO 7986
// begin if GetLives ( i ) < 720 then
7748: LD_VAR 0 2
7752: PPUSH
7753: CALL_OW 256
7757: PUSH
7758: LD_INT 720
7760: LESS
7761: IFFALSE 7777
// SetTag ( i , 0 ) else
7763: LD_VAR 0 2
7767: PPUSH
7768: LD_INT 0
7770: PPUSH
7771: CALL_OW 109
7775: GO 7986
// if tag < attackFormula [ 1 ] then
7777: LD_VAR 0 4
7781: PUSH
7782: LD_VAR 0 6
7786: PUSH
7787: LD_INT 1
7789: ARRAY
7790: LESS
7791: IFFALSE 7952
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
7793: LD_VAR 0 2
7797: PPUSH
7798: LD_VAR 0 6
7802: PUSH
7803: LD_INT 1
7805: ARRAY
7806: PUSH
7807: LD_VAR 0 4
7811: ARRAY
7812: PUSH
7813: LD_INT 1
7815: ARRAY
7816: PPUSH
7817: LD_VAR 0 6
7821: PUSH
7822: LD_INT 1
7824: ARRAY
7825: PUSH
7826: LD_VAR 0 4
7830: ARRAY
7831: PUSH
7832: LD_INT 2
7834: ARRAY
7835: PPUSH
7836: CALL_OW 297
7840: PUSH
7841: LD_INT 6
7843: GREATER
7844: IFFALSE 7895
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
7846: LD_VAR 0 2
7850: PPUSH
7851: LD_VAR 0 6
7855: PUSH
7856: LD_INT 1
7858: ARRAY
7859: PUSH
7860: LD_VAR 0 4
7864: ARRAY
7865: PUSH
7866: LD_INT 1
7868: ARRAY
7869: PPUSH
7870: LD_VAR 0 6
7874: PUSH
7875: LD_INT 1
7877: ARRAY
7878: PUSH
7879: LD_VAR 0 4
7883: ARRAY
7884: PUSH
7885: LD_INT 2
7887: ARRAY
7888: PPUSH
7889: CALL_OW 114
7893: GO 7950
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
7895: LD_INT 81
7897: PUSH
7898: LD_INT 1
7900: PUSH
7901: EMPTY
7902: LIST
7903: LIST
7904: PUSH
7905: LD_INT 91
7907: PUSH
7908: LD_VAR 0 2
7912: PUSH
7913: LD_INT 10
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: LIST
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: PPUSH
7925: CALL_OW 69
7929: NOT
7930: IFFALSE 7950
// SetTag ( i , tag + 1 ) ;
7932: LD_VAR 0 2
7936: PPUSH
7937: LD_VAR 0 4
7941: PUSH
7942: LD_INT 1
7944: PLUS
7945: PPUSH
7946: CALL_OW 109
// end else
7950: GO 7986
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
7952: LD_VAR 0 2
7956: PPUSH
7957: LD_INT 81
7959: PUSH
7960: LD_INT 1
7962: PUSH
7963: EMPTY
7964: LIST
7965: LIST
7966: PPUSH
7967: CALL_OW 69
7971: PPUSH
7972: LD_VAR 0 2
7976: PPUSH
7977: CALL_OW 74
7981: PPUSH
7982: CALL_OW 115
// end ; end ;
7986: GO 7616
7988: POP
7989: POP
// end ; if sci then
7990: LD_VAR 0 8
7994: IFFALSE 8169
// begin if not sol and not mech then
7996: LD_VAR 0 7
8000: NOT
8001: PUSH
8002: LD_VAR 0 9
8006: NOT
8007: AND
8008: IFFALSE 8076
// begin for i in sci do
8010: LD_ADDR_VAR 0 2
8014: PUSH
8015: LD_VAR 0 8
8019: PUSH
8020: FOR_IN
8021: IFFALSE 8072
// begin usAttackers := usAttackers diff i ;
8023: LD_ADDR_EXP 42
8027: PUSH
8028: LD_EXP 42
8032: PUSH
8033: LD_VAR 0 2
8037: DIFF
8038: ST_TO_ADDR
// usForces := usForces union i ;
8039: LD_ADDR_EXP 39
8043: PUSH
8044: LD_EXP 39
8048: PUSH
8049: LD_VAR 0 2
8053: UNION
8054: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8055: LD_VAR 0 2
8059: PPUSH
8060: LD_INT 34
8062: PPUSH
8063: LD_INT 68
8065: PPUSH
8066: CALL_OW 111
// end ;
8070: GO 8020
8072: POP
8073: POP
// end else
8074: GO 8169
// for i in sci do
8076: LD_ADDR_VAR 0 2
8080: PUSH
8081: LD_VAR 0 8
8085: PUSH
8086: FOR_IN
8087: IFFALSE 8167
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8089: LD_VAR 0 2
8093: PPUSH
8094: LD_VAR 0 6
8098: PUSH
8099: LD_INT 2
8101: ARRAY
8102: PUSH
8103: LD_INT 1
8105: ARRAY
8106: PPUSH
8107: LD_VAR 0 6
8111: PUSH
8112: LD_INT 2
8114: ARRAY
8115: PUSH
8116: LD_INT 2
8118: ARRAY
8119: PPUSH
8120: CALL_OW 297
8124: PUSH
8125: LD_INT 8
8127: GREATER
8128: IFFALSE 8165
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8130: LD_VAR 0 2
8134: PPUSH
8135: LD_VAR 0 6
8139: PUSH
8140: LD_INT 2
8142: ARRAY
8143: PUSH
8144: LD_INT 1
8146: ARRAY
8147: PPUSH
8148: LD_VAR 0 6
8152: PUSH
8153: LD_INT 2
8155: ARRAY
8156: PUSH
8157: LD_INT 2
8159: ARRAY
8160: PPUSH
8161: CALL_OW 111
8165: GO 8086
8167: POP
8168: POP
// end ; if tanks and mech then
8169: LD_VAR 0 10
8173: PUSH
8174: LD_VAR 0 9
8178: AND
8179: IFFALSE 8772
// begin for i in mech do
8181: LD_ADDR_VAR 0 2
8185: PUSH
8186: LD_VAR 0 9
8190: PUSH
8191: FOR_IN
8192: IFFALSE 8770
// begin tag := GetTag ( i ) ;
8194: LD_ADDR_VAR 0 4
8198: PUSH
8199: LD_VAR 0 2
8203: PPUSH
8204: CALL_OW 110
8208: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8209: LD_ADDR_VAR 0 11
8213: PUSH
8214: LD_VAR 0 2
8218: PPUSH
8219: CALL_OW 310
8223: ST_TO_ADDR
// if not tag then
8224: LD_VAR 0 4
8228: NOT
8229: IFFALSE 8530
// begin if veh then
8231: LD_VAR 0 11
8235: IFFALSE 8384
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
8237: LD_VAR 0 11
8241: PPUSH
8242: CALL_OW 256
8246: PUSH
8247: LD_INT 1000
8249: EQUAL
8250: PUSH
8251: LD_VAR 0 11
8255: PPUSH
8256: CALL_OW 261
8260: PUSH
8261: LD_INT 60
8263: GREATER
8264: AND
8265: IFFALSE 8281
// SetTag ( i , 1 ) else
8267: LD_VAR 0 2
8271: PPUSH
8272: LD_INT 1
8274: PPUSH
8275: CALL_OW 109
8279: GO 8382
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
8281: LD_VAR 0 2
8285: PPUSH
8286: LD_VAR 0 6
8290: PUSH
8291: LD_INT 3
8293: ARRAY
8294: PUSH
8295: LD_INT 1
8297: ARRAY
8298: PPUSH
8299: LD_VAR 0 6
8303: PUSH
8304: LD_INT 3
8306: ARRAY
8307: PUSH
8308: LD_INT 2
8310: ARRAY
8311: PPUSH
8312: CALL_OW 297
8316: PUSH
8317: LD_INT 7
8319: GREATER
8320: IFFALSE 8359
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
8322: LD_VAR 0 2
8326: PPUSH
8327: LD_VAR 0 6
8331: PUSH
8332: LD_INT 3
8334: ARRAY
8335: PUSH
8336: LD_INT 1
8338: ARRAY
8339: PPUSH
8340: LD_VAR 0 6
8344: PUSH
8345: LD_INT 3
8347: ARRAY
8348: PUSH
8349: LD_INT 2
8351: ARRAY
8352: PPUSH
8353: CALL_OW 111
8357: GO 8382
// begin ComExitVehicle ( i ) ;
8359: LD_VAR 0 2
8363: PPUSH
8364: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
8368: LD_VAR 0 2
8372: PPUSH
8373: LD_VAR 0 11
8377: PPUSH
8378: CALL_OW 189
// end ; end else
8382: GO 8528
// if GetLives ( i ) < 700 then
8384: LD_VAR 0 2
8388: PPUSH
8389: CALL_OW 256
8393: PUSH
8394: LD_INT 700
8396: LESS
8397: IFFALSE 8448
// begin usAttackers := usAttackers diff i ;
8399: LD_ADDR_EXP 42
8403: PUSH
8404: LD_EXP 42
8408: PUSH
8409: LD_VAR 0 2
8413: DIFF
8414: ST_TO_ADDR
// usForces := usForces union i ;
8415: LD_ADDR_EXP 39
8419: PUSH
8420: LD_EXP 39
8424: PUSH
8425: LD_VAR 0 2
8429: UNION
8430: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8431: LD_VAR 0 2
8435: PPUSH
8436: LD_INT 34
8438: PPUSH
8439: LD_INT 68
8441: PPUSH
8442: CALL_OW 111
// end else
8446: GO 8528
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) then
8448: LD_VAR 0 10
8452: PPUSH
8453: LD_INT 58
8455: PUSH
8456: EMPTY
8457: LIST
8458: PUSH
8459: LD_INT 24
8461: PUSH
8462: LD_INT 1000
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PPUSH
8473: CALL_OW 72
8477: IFFALSE 8528
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
8479: LD_VAR 0 2
8483: PPUSH
8484: LD_VAR 0 10
8488: PPUSH
8489: LD_INT 58
8491: PUSH
8492: EMPTY
8493: LIST
8494: PUSH
8495: LD_INT 24
8497: PUSH
8498: LD_INT 1000
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: PUSH
8505: EMPTY
8506: LIST
8507: LIST
8508: PPUSH
8509: CALL_OW 72
8513: PPUSH
8514: LD_VAR 0 2
8518: PPUSH
8519: CALL_OW 74
8523: PPUSH
8524: CALL_OW 120
// end else
8528: GO 8768
// begin if GetLives ( veh ) < 620 then
8530: LD_VAR 0 11
8534: PPUSH
8535: CALL_OW 256
8539: PUSH
8540: LD_INT 620
8542: LESS
8543: IFFALSE 8559
// SetTag ( i , 0 ) else
8545: LD_VAR 0 2
8549: PPUSH
8550: LD_INT 0
8552: PPUSH
8553: CALL_OW 109
8557: GO 8768
// if tag < attackFormula [ 1 ] then
8559: LD_VAR 0 4
8563: PUSH
8564: LD_VAR 0 6
8568: PUSH
8569: LD_INT 1
8571: ARRAY
8572: LESS
8573: IFFALSE 8734
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8575: LD_VAR 0 2
8579: PPUSH
8580: LD_VAR 0 6
8584: PUSH
8585: LD_INT 1
8587: ARRAY
8588: PUSH
8589: LD_VAR 0 4
8593: ARRAY
8594: PUSH
8595: LD_INT 1
8597: ARRAY
8598: PPUSH
8599: LD_VAR 0 6
8603: PUSH
8604: LD_INT 1
8606: ARRAY
8607: PUSH
8608: LD_VAR 0 4
8612: ARRAY
8613: PUSH
8614: LD_INT 2
8616: ARRAY
8617: PPUSH
8618: CALL_OW 297
8622: PUSH
8623: LD_INT 6
8625: GREATER
8626: IFFALSE 8677
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8628: LD_VAR 0 2
8632: PPUSH
8633: LD_VAR 0 6
8637: PUSH
8638: LD_INT 1
8640: ARRAY
8641: PUSH
8642: LD_VAR 0 4
8646: ARRAY
8647: PUSH
8648: LD_INT 1
8650: ARRAY
8651: PPUSH
8652: LD_VAR 0 6
8656: PUSH
8657: LD_INT 1
8659: ARRAY
8660: PUSH
8661: LD_VAR 0 4
8665: ARRAY
8666: PUSH
8667: LD_INT 2
8669: ARRAY
8670: PPUSH
8671: CALL_OW 114
8675: GO 8732
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8677: LD_INT 81
8679: PUSH
8680: LD_INT 1
8682: PUSH
8683: EMPTY
8684: LIST
8685: LIST
8686: PUSH
8687: LD_INT 91
8689: PUSH
8690: LD_VAR 0 2
8694: PUSH
8695: LD_INT 10
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: LIST
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PPUSH
8707: CALL_OW 69
8711: NOT
8712: IFFALSE 8732
// SetTag ( i , tag + 1 ) ;
8714: LD_VAR 0 2
8718: PPUSH
8719: LD_VAR 0 4
8723: PUSH
8724: LD_INT 1
8726: PLUS
8727: PPUSH
8728: CALL_OW 109
// end else
8732: GO 8768
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8734: LD_VAR 0 2
8738: PPUSH
8739: LD_INT 81
8741: PUSH
8742: LD_INT 1
8744: PUSH
8745: EMPTY
8746: LIST
8747: LIST
8748: PPUSH
8749: CALL_OW 69
8753: PPUSH
8754: LD_VAR 0 2
8758: PPUSH
8759: CALL_OW 74
8763: PPUSH
8764: CALL_OW 115
// end ; end ;
8768: GO 8191
8770: POP
8771: POP
// end ; until not usAttackers ;
8772: LD_EXP 42
8776: NOT
8777: IFFALSE 7493
// end ; end_of_file
8779: LD_VAR 0 1
8783: RET
// export function Action ; var hasAll , i , tmp ; begin
8784: LD_INT 0
8786: PPUSH
8787: PPUSH
8788: PPUSH
8789: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
8790: LD_ADDR_VAR 0 2
8794: PUSH
8795: LD_INT 22
8797: PUSH
8798: LD_INT 2
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PUSH
8805: LD_INT 21
8807: PUSH
8808: LD_INT 1
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: PUSH
8815: LD_INT 23
8817: PUSH
8818: LD_INT 2
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PUSH
8825: EMPTY
8826: LIST
8827: LIST
8828: LIST
8829: PPUSH
8830: CALL_OW 69
8834: PUSH
8835: LD_INT 7
8837: GREATEREQUAL
8838: ST_TO_ADDR
// InGameOn ;
8839: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
8843: LD_EXP 23
8847: PPUSH
8848: CALL_OW 87
// wait ( 0 0$2 ) ;
8852: LD_INT 70
8854: PPUSH
8855: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
8859: LD_EXP 31
8863: PPUSH
8864: LD_STRING DF-1-start
8866: PPUSH
8867: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
8871: LD_EXP 23
8875: PPUSH
8876: LD_EXP 31
8880: PPUSH
8881: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
8885: LD_EXP 23
8889: PPUSH
8890: LD_STRING DH-1-start
8892: PPUSH
8893: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
8897: LD_EXP 32
8901: PPUSH
8902: LD_INT 92
8904: PPUSH
8905: LD_INT 21
8907: PPUSH
8908: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
8912: LD_EXP 27
8916: PPUSH
8917: LD_INT 94
8919: PPUSH
8920: LD_INT 23
8922: PPUSH
8923: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
8927: LD_EXP 35
8931: PUSH
8932: LD_INT 1
8934: ARRAY
8935: PPUSH
8936: LD_INT 90
8938: PPUSH
8939: LD_INT 23
8941: PPUSH
8942: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
8946: LD_EXP 35
8950: PUSH
8951: LD_INT 2
8953: ARRAY
8954: PPUSH
8955: LD_INT 93
8957: PPUSH
8958: LD_INT 25
8960: PPUSH
8961: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
8965: LD_EXP 35
8969: PPUSH
8970: LD_EXP 32
8974: PPUSH
8975: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
8979: LD_EXP 32
8983: PUSH
8984: LD_EXP 27
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: PPUSH
8993: LD_EXP 23
8997: PPUSH
8998: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9002: LD_EXP 23
9006: PPUSH
9007: LD_EXP 32
9011: PPUSH
9012: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9016: LD_INT 35
9018: PPUSH
9019: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9023: LD_EXP 32
9027: PPUSH
9028: LD_INT 92
9030: PPUSH
9031: LD_INT 21
9033: PPUSH
9034: CALL_OW 307
9038: IFFALSE 9016
// Say ( Omar , DO-1-start ) ;
9040: LD_EXP 32
9044: PPUSH
9045: LD_STRING DO-1-start
9047: PPUSH
9048: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9052: LD_EXP 23
9056: PPUSH
9057: LD_STRING DH-2-start
9059: PPUSH
9060: CALL_OW 88
// if hasAll then
9064: LD_VAR 0 2
9068: IFFALSE 9196
// begin Say ( Omar , DO-2-start ) ;
9070: LD_EXP 32
9074: PPUSH
9075: LD_STRING DO-2-start
9077: PPUSH
9078: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9082: LD_EXP 32
9086: PPUSH
9087: LD_STRING DO-3-start
9089: PPUSH
9090: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
9094: LD_EXP 23
9098: PPUSH
9099: LD_STRING DH-3-start
9101: PPUSH
9102: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
9106: LD_EXP 31
9110: PPUSH
9111: LD_STRING DF-2-start
9113: PPUSH
9114: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9118: LD_EXP 32
9122: PPUSH
9123: LD_EXP 31
9127: PPUSH
9128: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
9132: LD_EXP 32
9136: PPUSH
9137: LD_STRING DO-4-start
9139: PPUSH
9140: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
9144: LD_EXP 31
9148: PPUSH
9149: LD_STRING DF-3-start
9151: PPUSH
9152: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
9156: LD_EXP 32
9160: PPUSH
9161: LD_STRING DO-5-start
9163: PPUSH
9164: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
9168: LD_EXP 31
9172: PPUSH
9173: LD_STRING DF-4-start
9175: PPUSH
9176: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
9180: LD_EXP 32
9184: PPUSH
9185: LD_EXP 23
9189: PPUSH
9190: CALL_OW 119
// end else
9194: GO 9296
// begin Say ( Omar , DO-2-start-a ) ;
9196: LD_EXP 32
9200: PPUSH
9201: LD_STRING DO-2-start-a
9203: PPUSH
9204: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
9208: LD_EXP 32
9212: PPUSH
9213: LD_STRING DO-3-start-a
9215: PPUSH
9216: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
9220: LD_EXP 23
9224: PPUSH
9225: LD_STRING DH-3-start-a
9227: PPUSH
9228: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
9232: LD_EXP 31
9236: PPUSH
9237: LD_STRING DF-2-start-a
9239: PPUSH
9240: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9244: LD_EXP 32
9248: PPUSH
9249: LD_EXP 31
9253: PPUSH
9254: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
9258: LD_EXP 32
9262: PPUSH
9263: LD_STRING DO-4-start-a
9265: PPUSH
9266: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
9270: LD_EXP 31
9274: PPUSH
9275: LD_STRING DF-3-start-a
9277: PPUSH
9278: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
9282: LD_EXP 32
9286: PPUSH
9287: LD_EXP 23
9291: PPUSH
9292: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
9296: LD_INT 10
9298: PPUSH
9299: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
9303: LD_EXP 32
9307: PPUSH
9308: LD_STRING DO-1-mission
9310: PPUSH
9311: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
9315: LD_EXP 32
9319: PPUSH
9320: LD_STRING DO-2-mission
9322: PPUSH
9323: CALL_OW 88
// if not hasAll then
9327: LD_VAR 0 2
9331: NOT
9332: IFFALSE 9346
// Say ( Omar , DO-3-mission ) ;
9334: LD_EXP 32
9338: PPUSH
9339: LD_STRING DO-3-mission
9341: PPUSH
9342: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
9346: LD_EXP 32
9350: PPUSH
9351: LD_STRING DO-4-mission
9353: PPUSH
9354: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
9358: LD_EXP 23
9362: PPUSH
9363: LD_STRING DH-1-mission
9365: PPUSH
9366: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
9370: LD_EXP 31
9374: PPUSH
9375: LD_STRING DF-1-mission
9377: PPUSH
9378: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
9382: LD_EXP 32
9386: PPUSH
9387: LD_STRING DO-5-mission
9389: PPUSH
9390: CALL_OW 88
// if not hasAll then
9394: LD_VAR 0 2
9398: NOT
9399: IFFALSE 9534
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
9401: LD_ADDR_VAR 0 4
9405: PUSH
9406: LD_INT 22
9408: PUSH
9409: LD_INT 2
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: PUSH
9416: LD_INT 21
9418: PUSH
9419: LD_INT 1
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: PUSH
9426: LD_INT 23
9428: PUSH
9429: LD_INT 2
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PUSH
9436: EMPTY
9437: LIST
9438: LIST
9439: LIST
9440: PPUSH
9441: CALL_OW 69
9445: ST_TO_ADDR
// for i := 7 downto tmp do
9446: LD_ADDR_VAR 0 3
9450: PUSH
9451: DOUBLE
9452: LD_INT 7
9454: INC
9455: ST_TO_ADDR
9456: LD_VAR 0 4
9460: PUSH
9461: FOR_DOWNTO
9462: IFFALSE 9532
// begin if omarSquad < 3 then
9464: LD_EXP 35
9468: PUSH
9469: LD_INT 3
9471: LESS
9472: IFFALSE 9476
// break ;
9474: GO 9532
// SetSide ( omarSquad [ 3 ] , 2 ) ;
9476: LD_EXP 35
9480: PUSH
9481: LD_INT 3
9483: ARRAY
9484: PPUSH
9485: LD_INT 2
9487: PPUSH
9488: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
9492: LD_ADDR_EXP 37
9496: PUSH
9497: LD_EXP 37
9501: PUSH
9502: LD_EXP 35
9506: PUSH
9507: LD_INT 3
9509: ARRAY
9510: UNION
9511: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
9512: LD_ADDR_EXP 35
9516: PUSH
9517: LD_EXP 35
9521: PPUSH
9522: LD_INT 3
9524: PPUSH
9525: CALL_OW 3
9529: ST_TO_ADDR
// end ;
9530: GO 9461
9532: POP
9533: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
9534: LD_EXP 32
9538: PUSH
9539: LD_EXP 35
9543: ADD
9544: PPUSH
9545: LD_INT 103
9547: PPUSH
9548: LD_INT 9
9550: PPUSH
9551: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
9555: LD_VAR 0 2
9559: PUSH
9560: LD_EXP 28
9564: PPUSH
9565: CALL_OW 302
9569: AND
9570: IFFALSE 9631
// begin wait ( 0 0$3 ) ;
9572: LD_INT 105
9574: PPUSH
9575: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
9579: LD_EXP 28
9583: PPUSH
9584: LD_EXP 31
9588: PPUSH
9589: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
9593: LD_EXP 28
9597: PPUSH
9598: LD_STRING DK-1-side
9600: PPUSH
9601: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
9605: LD_EXP 31
9609: PPUSH
9610: LD_EXP 28
9614: PPUSH
9615: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
9619: LD_EXP 31
9623: PPUSH
9624: LD_STRING DF-1-side
9626: PPUSH
9627: CALL_OW 88
// end ; InGameOff ;
9631: CALL_OW 9
// ChangeMissionObjectives ( BuildBase ) ;
9635: LD_STRING BuildBase
9637: PPUSH
9638: CALL_OW 337
// ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
9642: LD_INT 22
9644: PUSH
9645: LD_INT 2
9647: PUSH
9648: EMPTY
9649: LIST
9650: LIST
9651: PPUSH
9652: CALL_OW 69
9656: PPUSH
9657: CALL_OW 139
// SaveForQuickRestart ;
9661: CALL_OW 22
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
9665: LD_EXP 31
9669: PUSH
9670: LD_EXP 34
9674: ADD
9675: PPUSH
9676: LD_INT 108
9678: PPUSH
9679: LD_INT 62
9681: PPUSH
9682: CALL_OW 111
// gameStarted := true ;
9686: LD_ADDR_EXP 3
9690: PUSH
9691: LD_INT 1
9693: ST_TO_ADDR
// end ;
9694: LD_VAR 0 1
9698: RET
// every 0 0$3 trigger gameStarted do
9699: LD_EXP 3
9703: IFFALSE 10017
9705: GO 9707
9707: DISABLE
// begin Video ( true ) ;
9708: LD_INT 1
9710: PPUSH
9711: CALL 949 0 1
// CenterOnUnits ( Heike ) ;
9715: LD_EXP 23
9719: PPUSH
9720: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
9724: LD_EXP 23
9728: PPUSH
9729: LD_EXP 27
9733: PPUSH
9734: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
9738: LD_INT 22
9740: PUSH
9741: LD_INT 2
9743: PUSH
9744: EMPTY
9745: LIST
9746: LIST
9747: PPUSH
9748: CALL_OW 69
9752: PUSH
9753: LD_EXP 23
9757: DIFF
9758: PPUSH
9759: LD_EXP 23
9763: PPUSH
9764: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
9768: LD_EXP 23
9772: PPUSH
9773: LD_STRING DH-1-explore
9775: PPUSH
9776: CALL_OW 88
// if Givi then
9780: LD_EXP 24
9784: IFFALSE 9800
// Say ( Givi , DG-1-explore ) else
9786: LD_EXP 24
9790: PPUSH
9791: LD_STRING DG-1-explore
9793: PPUSH
9794: CALL_OW 88
9798: GO 9837
// if heikeSecondSquad then
9800: LD_EXP 37
9804: IFFALSE 9837
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
9806: LD_EXP 37
9810: PPUSH
9811: LD_INT 26
9813: PUSH
9814: LD_INT 1
9816: PUSH
9817: EMPTY
9818: LIST
9819: LIST
9820: PPUSH
9821: CALL_OW 72
9825: PUSH
9826: LD_INT 1
9828: ARRAY
9829: PPUSH
9830: LD_STRING DArm-1-explore
9832: PPUSH
9833: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
9837: LD_EXP 27
9841: PPUSH
9842: LD_STRING DA-1-explore
9844: PPUSH
9845: CALL_OW 88
// if Sophia then
9849: LD_EXP 29
9853: IFFALSE 9931
// begin Say ( Sophia , DS-2-explore ) ;
9855: LD_EXP 29
9859: PPUSH
9860: LD_STRING DS-2-explore
9862: PPUSH
9863: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
9867: LD_EXP 27
9871: PPUSH
9872: LD_STRING DA-2-explore
9874: PPUSH
9875: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
9879: LD_EXP 29
9883: PPUSH
9884: LD_EXP 27
9888: PPUSH
9889: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
9893: LD_EXP 27
9897: PPUSH
9898: LD_EXP 29
9902: PPUSH
9903: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
9907: LD_EXP 29
9911: PPUSH
9912: LD_STRING DS-3-explore
9914: PPUSH
9915: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
9919: LD_EXP 27
9923: PPUSH
9924: LD_STRING DA-3-explore
9926: PPUSH
9927: CALL_OW 88
// end ; if Mike then
9931: LD_EXP 25
9935: IFFALSE 9991
// begin Say ( Mike , DM-1-explore ) ;
9937: LD_EXP 25
9941: PPUSH
9942: LD_STRING DM-1-explore
9944: PPUSH
9945: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
9949: LD_EXP 23
9953: PPUSH
9954: LD_STRING DH-2-explore
9956: PPUSH
9957: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
9961: LD_EXP 25
9965: PPUSH
9966: LD_STRING DM-2-explore
9968: PPUSH
9969: CALL_OW 88
// if Kaia then
9973: LD_EXP 28
9977: IFFALSE 9991
// Say ( Kaia , DK-1-explore ) ;
9979: LD_EXP 28
9983: PPUSH
9984: LD_STRING DK-1-explore
9986: PPUSH
9987: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
9991: LD_INT 22
9993: PUSH
9994: LD_INT 2
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PPUSH
10001: CALL_OW 69
10005: PPUSH
10006: CALL_OW 139
// Video ( false ) ;
10010: LD_INT 0
10012: PPUSH
10013: CALL 949 0 1
// end ;
10017: END
// every 0 0$1 trigger not americanBaseSpoted and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10018: LD_EXP 5
10022: NOT
10023: PUSH
10024: LD_INT 5
10026: PPUSH
10027: LD_INT 22
10029: PUSH
10030: LD_INT 2
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: PPUSH
10037: CALL_OW 70
10041: AND
10042: PUSH
10043: LD_EXP 6
10047: NOT
10048: AND
10049: IFFALSE 10134
10051: GO 10053
10053: DISABLE
// begin if Mike then
10054: LD_EXP 25
10058: IFFALSE 10074
// Say ( Mike , DM-1-scout ) else
10060: LD_EXP 25
10064: PPUSH
10065: LD_STRING DM-1-scout
10067: PPUSH
10068: CALL_OW 88
10072: GO 10105
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10074: LD_EXP 37
10078: PPUSH
10079: LD_INT 26
10081: PUSH
10082: LD_INT 1
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: PPUSH
10089: CALL_OW 72
10093: PUSH
10094: LD_INT 1
10096: ARRAY
10097: PPUSH
10098: LD_STRING DArm-1-explore
10100: PPUSH
10101: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
10105: LD_INT 54
10107: PPUSH
10108: LD_INT 35
10110: PPUSH
10111: LD_INT 2
10113: PPUSH
10114: LD_INT 1
10116: PPUSH
10117: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
10121: LD_INT 54
10123: PPUSH
10124: LD_INT 35
10126: PPUSH
10127: LD_INT 2
10129: PPUSH
10130: CALL_OW 331
// end ;
10134: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) do var randomMen , randomWomen , speakerOk ;
10135: LD_INT 6
10137: PPUSH
10138: LD_INT 22
10140: PUSH
10141: LD_INT 2
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 70
10152: IFFALSE 10406
10154: GO 10156
10156: DISABLE
10157: LD_INT 0
10159: PPUSH
10160: PPUSH
10161: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
10162: LD_ADDR_VAR 0 1
10166: PUSH
10167: LD_EXP 37
10171: PPUSH
10172: LD_INT 26
10174: PUSH
10175: LD_INT 1
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: PPUSH
10182: CALL_OW 72
10186: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
10187: LD_ADDR_VAR 0 2
10191: PUSH
10192: LD_EXP 37
10196: PPUSH
10197: LD_INT 26
10199: PUSH
10200: LD_INT 2
10202: PUSH
10203: EMPTY
10204: LIST
10205: LIST
10206: PPUSH
10207: CALL_OW 72
10211: ST_TO_ADDR
// DialogueOn ;
10212: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
10216: LD_INT 36
10218: PPUSH
10219: LD_INT 22
10221: PPUSH
10222: LD_INT 2
10224: PPUSH
10225: LD_INT 8
10227: PPUSH
10228: CALL_OW 330
// dwait ( 0 0$1 ) ;
10232: LD_INT 35
10234: PPUSH
10235: CALL_OW 68
// speakerOk := false ;
10239: LD_ADDR_VAR 0 3
10243: PUSH
10244: LD_INT 0
10246: ST_TO_ADDR
// if Mike then
10247: LD_EXP 25
10251: IFFALSE 10273
// speakerOk := Say ( Mike , DM-1-spot ) else
10253: LD_ADDR_VAR 0 3
10257: PUSH
10258: LD_EXP 25
10262: PPUSH
10263: LD_STRING DM-1-spot
10265: PPUSH
10266: CALL_OW 88
10270: ST_TO_ADDR
10271: GO 10301
// if randomMen then
10273: LD_VAR 0 1
10277: IFFALSE 10301
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
10279: LD_ADDR_VAR 0 3
10283: PUSH
10284: LD_VAR 0 1
10288: PUSH
10289: LD_INT 1
10291: ARRAY
10292: PPUSH
10293: LD_STRING DArm-1-spot-a
10295: PPUSH
10296: CALL_OW 88
10300: ST_TO_ADDR
// if speakerOk then
10301: LD_VAR 0 3
10305: IFFALSE 10349
// begin if Givi then
10307: LD_EXP 24
10311: IFFALSE 10327
// Say ( Givi , DG-1-spot ) else
10313: LD_EXP 24
10317: PPUSH
10318: LD_STRING DG-1-spot
10320: PPUSH
10321: CALL_OW 88
10325: GO 10349
// if randomWomen then
10327: LD_VAR 0 2
10331: IFFALSE 10349
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
10333: LD_VAR 0 2
10337: PUSH
10338: LD_INT 1
10340: ARRAY
10341: PPUSH
10342: LD_STRING DArf-1-spot-a
10344: PPUSH
10345: CALL_OW 88
// end ; if Mike then
10349: LD_EXP 25
10353: IFFALSE 10369
// Say ( Heike , DH-1-spot ) else
10355: LD_EXP 23
10359: PPUSH
10360: LD_STRING DH-1-spot
10362: PPUSH
10363: CALL_OW 88
10367: GO 10381
// Say ( Heike , DH-1-spot-a ) ;
10369: LD_EXP 23
10373: PPUSH
10374: LD_STRING DH-1-spot-a
10376: PPUSH
10377: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
10381: LD_INT 36
10383: PPUSH
10384: LD_INT 22
10386: PPUSH
10387: LD_INT 2
10389: PPUSH
10390: CALL_OW 331
// DialogueOff ;
10394: CALL_OW 7
// americanBaseSpoted := true ;
10398: LD_ADDR_EXP 5
10402: PUSH
10403: LD_INT 1
10405: ST_TO_ADDR
// end ;
10406: PPOPN 3
10408: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
10409: LD_EXP 5
10413: NOT
10414: PUSH
10415: LD_INT 22
10417: PUSH
10418: LD_INT 2
10420: PUSH
10421: EMPTY
10422: LIST
10423: LIST
10424: PUSH
10425: LD_INT 101
10427: PUSH
10428: LD_INT 1
10430: PUSH
10431: EMPTY
10432: LIST
10433: LIST
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PPUSH
10439: CALL_OW 69
10443: AND
10444: PUSH
10445: LD_EXP 6
10449: NOT
10450: AND
10451: IFFALSE 10537
10453: GO 10455
10455: DISABLE
10456: LD_INT 0
10458: PPUSH
// begin americanBaseSpoted := true ;
10459: LD_ADDR_EXP 5
10463: PUSH
10464: LD_INT 1
10466: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
10467: LD_ADDR_VAR 0 1
10471: PUSH
10472: LD_EXP 37
10476: PPUSH
10477: LD_INT 26
10479: PUSH
10480: LD_INT 1
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: PPUSH
10487: CALL_OW 72
10491: ST_TO_ADDR
// if not randomMen then
10492: LD_VAR 0 1
10496: NOT
10497: IFFALSE 10501
// exit ;
10499: GO 10537
// DialogueOn ;
10501: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
10505: LD_VAR 0 1
10509: PUSH
10510: LD_INT 1
10512: ARRAY
10513: PPUSH
10514: LD_STRING DArm-1-spot-a
10516: PPUSH
10517: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
10521: LD_EXP 23
10525: PPUSH
10526: LD_STRING DH-1-spot-a
10528: PPUSH
10529: CALL_OW 88
// DialogueOff ;
10533: CALL_OW 7
// end ;
10537: PPOPN 1
10539: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 do var i , p ;
10540: LD_INT 11
10542: PPUSH
10543: CALL_OW 255
10547: PUSH
10548: LD_INT 2
10550: EQUAL
10551: PUSH
10552: LD_INT 22
10554: PUSH
10555: LD_INT 1
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: PUSH
10562: LD_INT 3
10564: PUSH
10565: LD_INT 50
10567: PUSH
10568: EMPTY
10569: LIST
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PUSH
10575: LD_INT 30
10577: PUSH
10578: LD_INT 31
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: LIST
10589: PPUSH
10590: CALL_OW 69
10594: OR
10595: PUSH
10596: LD_INT 7
10598: PPUSH
10599: LD_INT 22
10601: PUSH
10602: LD_INT 2
10604: PUSH
10605: EMPTY
10606: LIST
10607: LIST
10608: PPUSH
10609: CALL_OW 70
10613: PUSH
10614: LD_INT 1
10616: GREATER
10617: OR
10618: IFFALSE 11074
10620: GO 10622
10622: DISABLE
10623: LD_INT 0
10625: PPUSH
10626: PPUSH
// begin americanBaseCaptured := true ;
10627: LD_ADDR_EXP 6
10631: PUSH
10632: LD_INT 1
10634: ST_TO_ADDR
// wait ( 0 0$2 ) ;
10635: LD_INT 70
10637: PPUSH
10638: CALL_OW 67
// if IsOk ( usCommander ) then
10642: LD_EXP 40
10646: PPUSH
10647: CALL_OW 302
10651: IFFALSE 10681
// begin usForces := usForces union usCommander ;
10653: LD_ADDR_EXP 39
10657: PUSH
10658: LD_EXP 39
10662: PUSH
10663: LD_EXP 40
10667: UNION
10668: ST_TO_ADDR
// Say ( usCommander , DUsm-1-assault ) ;
10669: LD_EXP 40
10673: PPUSH
10674: LD_STRING DUsm-1-assault
10676: PPUSH
10677: CALL_OW 88
// end ; for i in usForces do
10681: LD_ADDR_VAR 0 1
10685: PUSH
10686: LD_EXP 39
10690: PUSH
10691: FOR_IN
10692: IFFALSE 10731
// begin if IsInUnit ( i ) then
10694: LD_VAR 0 1
10698: PPUSH
10699: CALL_OW 310
10703: IFFALSE 10714
// ComExitBuilding ( i ) ;
10705: LD_VAR 0 1
10709: PPUSH
10710: CALL_OW 122
// AddComMoveXY ( i , 34 , 67 ) ;
10714: LD_VAR 0 1
10718: PPUSH
10719: LD_INT 34
10721: PPUSH
10722: LD_INT 67
10724: PPUSH
10725: CALL_OW 171
// end ;
10729: GO 10691
10731: POP
10732: POP
// Say ( Heike , DH-1-assault ) ;
10733: LD_EXP 23
10737: PPUSH
10738: LD_STRING DH-1-assault
10740: PPUSH
10741: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10745: LD_INT 35
10747: PPUSH
10748: CALL_OW 67
// until not usForces ;
10752: LD_EXP 39
10756: NOT
10757: IFFALSE 10745
// if not americanHasEscaped then
10759: LD_EXP 7
10763: NOT
10764: IFFALSE 10778
// Say ( Heike , DH-2-assault ) ;
10766: LD_EXP 23
10770: PPUSH
10771: LD_STRING DH-2-assault
10773: PPUSH
10774: CALL_OW 88
// wait ( 0 0$2 ) ;
10778: LD_INT 70
10780: PPUSH
10781: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10785: LD_INT 35
10787: PPUSH
10788: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
10792: LD_INT 22
10794: PUSH
10795: LD_INT 2
10797: PUSH
10798: EMPTY
10799: LIST
10800: LIST
10801: PUSH
10802: LD_INT 21
10804: PUSH
10805: LD_INT 1
10807: PUSH
10808: EMPTY
10809: LIST
10810: LIST
10811: PUSH
10812: LD_INT 3
10814: PUSH
10815: LD_INT 50
10817: PUSH
10818: EMPTY
10819: LIST
10820: PUSH
10821: EMPTY
10822: LIST
10823: LIST
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: LIST
10829: PPUSH
10830: CALL_OW 69
10834: NOT
10835: IFFALSE 10785
// Video ( true ) ;
10837: LD_INT 1
10839: PPUSH
10840: CALL 949 0 1
// if not GetSide ( usDepot ) = 2 then
10844: LD_INT 11
10846: PPUSH
10847: CALL_OW 255
10851: PUSH
10852: LD_INT 2
10854: EQUAL
10855: NOT
10856: IFFALSE 10868
// SetSide ( usDepot , 2 ) ;
10858: LD_INT 11
10860: PPUSH
10861: LD_INT 2
10863: PPUSH
10864: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
10868: LD_INT 35
10870: PPUSH
10871: LD_INT 22
10873: PPUSH
10874: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
10878: LD_EXP 23
10882: PPUSH
10883: LD_INT 35
10885: PPUSH
10886: LD_INT 22
10888: PPUSH
10889: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
10893: LD_EXP 23
10897: PPUSH
10898: LD_INT 38
10900: PPUSH
10901: LD_INT 25
10903: PPUSH
10904: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
10908: LD_EXP 36
10912: PUSH
10913: LD_EXP 37
10917: UNION
10918: PPUSH
10919: LD_INT 39
10921: PPUSH
10922: LD_INT 26
10924: PPUSH
10925: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
10929: LD_EXP 36
10933: PUSH
10934: LD_EXP 37
10938: UNION
10939: PPUSH
10940: LD_EXP 23
10944: PPUSH
10945: CALL_OW 179
// p := 0 ;
10949: LD_ADDR_VAR 0 2
10953: PUSH
10954: LD_INT 0
10956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10957: LD_INT 35
10959: PPUSH
10960: CALL_OW 67
// p := p + 1 ;
10964: LD_ADDR_VAR 0 2
10968: PUSH
10969: LD_VAR 0 2
10973: PUSH
10974: LD_INT 1
10976: PLUS
10977: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
10978: LD_EXP 23
10982: PPUSH
10983: CALL_OW 314
10987: NOT
10988: PUSH
10989: LD_VAR 0 2
10993: PUSH
10994: LD_INT 10
10996: GREATER
10997: OR
10998: IFFALSE 10957
// Say ( Heike , DH-1-capture ) ;
11000: LD_EXP 23
11004: PPUSH
11005: LD_STRING DH-1-capture
11007: PPUSH
11008: CALL_OW 88
// if Markov then
11012: LD_EXP 30
11016: IFFALSE 11030
// Say ( Markov , DMar-1-capture ) ;
11018: LD_EXP 30
11022: PPUSH
11023: LD_STRING DMar-1-capture
11025: PPUSH
11026: CALL_OW 88
// if Sophia then
11030: LD_EXP 29
11034: IFFALSE 11060
// begin Say ( Heike , DH-2-capture ) ;
11036: LD_EXP 23
11040: PPUSH
11041: LD_STRING DH-2-capture
11043: PPUSH
11044: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
11048: LD_EXP 29
11052: PPUSH
11053: LD_STRING DS-1-capture
11055: PPUSH
11056: CALL_OW 88
// end ; Video ( false ) ;
11060: LD_INT 0
11062: PPUSH
11063: CALL 949 0 1
// ChangeMissionObjectives ( ConstructBase ) ;
11067: LD_STRING ConstructBase
11069: PPUSH
11070: CALL_OW 337
// end ;
11074: PPOPN 2
11076: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
11077: LD_INT 22
11079: PUSH
11080: LD_INT 2
11082: PUSH
11083: EMPTY
11084: LIST
11085: LIST
11086: PUSH
11087: LD_INT 30
11089: PUSH
11090: LD_INT 2
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: PUSH
11097: LD_INT 3
11099: PUSH
11100: LD_INT 57
11102: PUSH
11103: EMPTY
11104: LIST
11105: PUSH
11106: EMPTY
11107: LIST
11108: LIST
11109: PUSH
11110: EMPTY
11111: LIST
11112: LIST
11113: LIST
11114: PPUSH
11115: CALL_OW 69
11119: IFFALSE 11207
11121: GO 11123
11123: DISABLE
// begin workshopBuilded := true ;
11124: LD_ADDR_EXP 9
11128: PUSH
11129: LD_INT 1
11131: ST_TO_ADDR
// if IsOk ( Markov ) then
11132: LD_EXP 30
11136: PPUSH
11137: CALL_OW 302
11141: IFFALSE 11200
// begin Say ( Heike , DH-1-shop ) ;
11143: LD_EXP 23
11147: PPUSH
11148: LD_STRING DH-1-shop
11150: PPUSH
11151: CALL_OW 88
// if not ( GetTech ( 2 , tech_OilEng ) = state_researched and GetTech ( 2 , tech_SolEng ) = state_researched ) then
11155: LD_INT 2
11157: PPUSH
11158: LD_INT 47
11160: PPUSH
11161: CALL_OW 321
11165: PUSH
11166: LD_INT 2
11168: EQUAL
11169: PUSH
11170: LD_INT 2
11172: PPUSH
11173: LD_INT 45
11175: PPUSH
11176: CALL_OW 321
11180: PUSH
11181: LD_INT 2
11183: EQUAL
11184: AND
11185: NOT
11186: IFFALSE 11200
// Say ( Markov , DMar-1-shop-a ) ;
11188: LD_EXP 30
11192: PPUSH
11193: LD_STRING DMar-1-shop-a
11195: PPUSH
11196: CALL_OW 88
// end ; ChangeMissionObjectives ( ConstructVeh ) ;
11200: LD_STRING ConstructVeh
11202: PPUSH
11203: CALL_OW 337
// end ;
11207: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
11208: LD_INT 2
11210: PPUSH
11211: LD_INT 2
11213: PPUSH
11214: LD_INT 1
11216: PPUSH
11217: CALL 1120 0 3
11221: PUSH
11222: LD_INT 0
11224: EQUAL
11225: IFFALSE 11237
11227: GO 11229
11229: DISABLE
// ChangeMissionObjectives ( Techs ) ;
11230: LD_STRING Techs
11232: PPUSH
11233: CALL_OW 337
11237: END
// every 0 0$1 trigger IsOk ( Markov ) and workshopBuilded and GetTech ( 2 , tech_OilEng ) = state_researched and GetTech ( 2 , tech_SolEng ) = state_researched do
11238: LD_EXP 30
11242: PPUSH
11243: CALL_OW 302
11247: PUSH
11248: LD_EXP 9
11252: AND
11253: PUSH
11254: LD_INT 2
11256: PPUSH
11257: LD_INT 47
11259: PPUSH
11260: CALL_OW 321
11264: PUSH
11265: LD_INT 2
11267: EQUAL
11268: AND
11269: PUSH
11270: LD_INT 2
11272: PPUSH
11273: LD_INT 45
11275: PPUSH
11276: CALL_OW 321
11280: PUSH
11281: LD_INT 2
11283: EQUAL
11284: AND
11285: IFFALSE 11406
11287: GO 11289
11289: DISABLE
// begin DialogueOn ;
11290: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
11294: LD_EXP 30
11298: PPUSH
11299: LD_STRING DMar-1-shop
11301: PPUSH
11302: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
11306: LD_EXP 23
11310: PPUSH
11311: LD_STRING DH-1-shop
11313: PPUSH
11314: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
11318: LD_EXP 30
11322: PPUSH
11323: LD_STRING DMar-2-shop
11325: PPUSH
11326: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
11330: LD_EXP 30
11334: PPUSH
11335: LD_STRING DMar-3-shop
11337: PPUSH
11338: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
11342: LD_EXP 23
11346: PPUSH
11347: LD_STRING DH-2-shop
11349: PPUSH
11350: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
11354: LD_EXP 30
11358: PPUSH
11359: LD_STRING DMar-4-shop
11361: PPUSH
11362: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
11366: LD_EXP 23
11370: PPUSH
11371: LD_STRING DH-3-shop
11373: PPUSH
11374: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
11378: LD_EXP 30
11382: PPUSH
11383: LD_STRING DMar-5-shop
11385: PPUSH
11386: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
11390: LD_EXP 23
11394: PPUSH
11395: LD_STRING DH-4-shop
11397: PPUSH
11398: CALL_OW 88
// DialogueOff ;
11402: CALL_OW 7
// end ;
11406: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
11407: LD_EXP 30
11411: PPUSH
11412: CALL_OW 302
11416: PUSH
11417: LD_INT 22
11419: PUSH
11420: LD_INT 2
11422: PUSH
11423: EMPTY
11424: LIST
11425: LIST
11426: PUSH
11427: LD_INT 2
11429: PUSH
11430: LD_INT 34
11432: PUSH
11433: LD_INT 22
11435: PUSH
11436: EMPTY
11437: LIST
11438: LIST
11439: PUSH
11440: LD_INT 35
11442: PUSH
11443: LD_INT 22
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PUSH
11450: EMPTY
11451: LIST
11452: LIST
11453: LIST
11454: PUSH
11455: EMPTY
11456: LIST
11457: LIST
11458: PPUSH
11459: CALL_OW 69
11463: AND
11464: IFFALSE 11571
11466: GO 11468
11468: DISABLE
// begin DialogueOn ;
11469: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
11473: LD_INT 22
11475: PUSH
11476: LD_INT 2
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: LD_INT 2
11485: PUSH
11486: LD_INT 34
11488: PUSH
11489: LD_INT 22
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: PUSH
11496: LD_INT 35
11498: PUSH
11499: LD_INT 22
11501: PUSH
11502: EMPTY
11503: LIST
11504: LIST
11505: PUSH
11506: EMPTY
11507: LIST
11508: LIST
11509: LIST
11510: PUSH
11511: EMPTY
11512: LIST
11513: LIST
11514: PPUSH
11515: CALL_OW 69
11519: PPUSH
11520: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11524: LD_INT 10
11526: PPUSH
11527: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
11531: LD_EXP 23
11535: PPUSH
11536: LD_STRING DH-1-bal
11538: PPUSH
11539: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
11543: LD_EXP 30
11547: PPUSH
11548: LD_STRING DMar-1-bal
11550: PPUSH
11551: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
11555: LD_EXP 23
11559: PPUSH
11560: LD_STRING DH-2-bal
11562: PPUSH
11563: CALL_OW 88
// DialogueOff ;
11567: CALL_OW 7
// end ;
11571: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
11572: LD_EXP 27
11576: PPUSH
11577: CALL_OW 302
11581: PUSH
11582: LD_INT 22
11584: PUSH
11585: LD_INT 2
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 30
11594: PUSH
11595: LD_INT 6
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: PPUSH
11606: CALL_OW 69
11610: AND
11611: IFFALSE 11672
11613: GO 11615
11615: DISABLE
// begin DialogueOn ;
11616: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
11620: LD_EXP 27
11624: PPUSH
11625: LD_STRING DA-1-lab
11627: PPUSH
11628: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
11632: LD_EXP 23
11636: PPUSH
11637: LD_STRING DH-1-lab
11639: PPUSH
11640: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
11644: LD_EXP 27
11648: PPUSH
11649: LD_STRING DA-2-lab
11651: PPUSH
11652: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
11656: LD_EXP 23
11660: PPUSH
11661: LD_STRING DH-2-lab
11663: PPUSH
11664: CALL_OW 88
// DialogueOff ;
11668: CALL_OW 7
// end ;
11672: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) do var ape ;
11673: LD_EXP 28
11677: PPUSH
11678: CALL_OW 302
11682: PUSH
11683: LD_INT 22
11685: PUSH
11686: LD_INT 2
11688: PUSH
11689: EMPTY
11690: LIST
11691: LIST
11692: PUSH
11693: LD_INT 25
11695: PUSH
11696: LD_INT 15
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: PUSH
11703: EMPTY
11704: LIST
11705: LIST
11706: PPUSH
11707: CALL_OW 69
11711: AND
11712: IFFALSE 11892
11714: GO 11716
11716: DISABLE
11717: LD_INT 0
11719: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
11720: LD_ADDR_VAR 0 1
11724: PUSH
11725: LD_INT 22
11727: PUSH
11728: LD_INT 2
11730: PUSH
11731: EMPTY
11732: LIST
11733: LIST
11734: PUSH
11735: LD_INT 25
11737: PUSH
11738: LD_INT 15
11740: PUSH
11741: EMPTY
11742: LIST
11743: LIST
11744: PUSH
11745: EMPTY
11746: LIST
11747: LIST
11748: PPUSH
11749: CALL_OW 69
11753: ST_TO_ADDR
// Video ( true ) ;
11754: LD_INT 1
11756: PPUSH
11757: CALL 949 0 1
// CenterNowOnUnits ( ape [ 1 ] ) ;
11761: LD_VAR 0 1
11765: PUSH
11766: LD_INT 1
11768: ARRAY
11769: PPUSH
11770: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
11774: LD_VAR 0 1
11778: PUSH
11779: LD_INT 1
11781: ARRAY
11782: PPUSH
11783: CALL_OW 122
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
11787: LD_VAR 0 1
11791: PUSH
11792: LD_INT 1
11794: ARRAY
11795: PPUSH
11796: LD_INT 35
11798: PPUSH
11799: LD_INT 28
11801: PPUSH
11802: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
11806: LD_VAR 0 1
11810: PUSH
11811: LD_INT 1
11813: ARRAY
11814: PPUSH
11815: LD_INT 36
11817: PPUSH
11818: LD_INT 17
11820: PPUSH
11821: CALL_OW 171
// Say ( Kaia , DK-1-apesol ) ;
11825: LD_EXP 28
11829: PPUSH
11830: LD_STRING DK-1-apesol
11832: PPUSH
11833: CALL_OW 88
// Say ( Aviradze , DA-1-apesol ) ;
11837: LD_EXP 27
11841: PPUSH
11842: LD_STRING DA-1-apesol
11844: PPUSH
11845: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
11849: LD_EXP 28
11853: PPUSH
11854: LD_STRING DK-2-apesol
11856: PPUSH
11857: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
11861: LD_EXP 27
11865: PPUSH
11866: LD_STRING DA-2-apesol
11868: PPUSH
11869: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
11873: LD_EXP 28
11877: PPUSH
11878: LD_STRING DK-3-apesol
11880: PPUSH
11881: CALL_OW 88
// Video ( false ) ;
11885: LD_INT 0
11887: PPUSH
11888: CALL 949 0 1
// end ;
11892: PPOPN 1
11894: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) do var ape ;
11895: LD_EXP 29
11899: PPUSH
11900: CALL_OW 302
11904: PUSH
11905: LD_INT 22
11907: PUSH
11908: LD_INT 2
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PUSH
11915: LD_INT 25
11917: PUSH
11918: LD_INT 16
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PPUSH
11929: CALL_OW 69
11933: AND
11934: IFFALSE 12206
11936: GO 11938
11938: DISABLE
11939: LD_INT 0
11941: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
11942: LD_ADDR_VAR 0 1
11946: PUSH
11947: LD_INT 22
11949: PUSH
11950: LD_INT 2
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 25
11959: PUSH
11960: LD_INT 16
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PPUSH
11971: CALL_OW 69
11975: ST_TO_ADDR
// Video ( true ) ;
11976: LD_INT 1
11978: PPUSH
11979: CALL 949 0 1
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
11983: LD_INT 5
11985: PPUSH
11986: LD_INT 35
11988: PPUSH
11989: LD_INT 22
11991: PPUSH
11992: LD_INT 1
11994: PPUSH
11995: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
11999: LD_EXP 29
12003: PPUSH
12004: LD_VAR 0 1
12008: PUSH
12009: LD_INT 1
12011: ARRAY
12012: PPUSH
12013: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
12017: LD_VAR 0 1
12021: PUSH
12022: LD_INT 1
12024: ARRAY
12025: PPUSH
12026: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12030: LD_VAR 0 1
12034: PUSH
12035: LD_INT 1
12037: ARRAY
12038: PPUSH
12039: CALL_OW 122
// wait ( 0 0$2 ) ;
12043: LD_INT 70
12045: PPUSH
12046: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
12050: LD_EXP 29
12054: PPUSH
12055: LD_STRING DS-1-apeeng
12057: PPUSH
12058: CALL_OW 88
// if IsOk ( Kamil ) then
12062: LD_EXP 26
12066: PPUSH
12067: CALL_OW 302
12071: IFFALSE 12199
// begin Say ( Kamil , DKam-1-apeeng ) ;
12073: LD_EXP 26
12077: PPUSH
12078: LD_STRING DKam-1-apeeng
12080: PPUSH
12081: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
12085: LD_EXP 29
12089: PPUSH
12090: LD_STRING DS-2-apeeng
12092: PPUSH
12093: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
12097: LD_EXP 26
12101: PPUSH
12102: LD_STRING DKam-2-apeeng
12104: PPUSH
12105: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
12109: LD_EXP 29
12113: PPUSH
12114: LD_STRING DS-3-apeeng
12116: PPUSH
12117: CALL_OW 88
// if not IsOK ( Kaia ) then
12121: LD_EXP 28
12125: PPUSH
12126: CALL_OW 302
12130: NOT
12131: IFFALSE 12142
// begin Video ( false ) ;
12133: LD_INT 0
12135: PPUSH
12136: CALL 949 0 1
// exit ;
12140: GO 12206
// end ; Say ( Kaia , DK-1-apeeng ) ;
12142: LD_EXP 28
12146: PPUSH
12147: LD_STRING DK-1-apeeng
12149: PPUSH
12150: CALL_OW 88
// if not IsOk ( Givi ) then
12154: LD_EXP 24
12158: PPUSH
12159: CALL_OW 302
12163: NOT
12164: IFFALSE 12175
// begin Video ( false ) ;
12166: LD_INT 0
12168: PPUSH
12169: CALL 949 0 1
// exit ;
12173: GO 12206
// end ; Say ( Givi , DG-1-apeeng ) ;
12175: LD_EXP 24
12179: PPUSH
12180: LD_STRING DG-1-apeeng
12182: PPUSH
12183: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
12187: LD_EXP 28
12191: PPUSH
12192: LD_STRING DK-2-apeeng
12194: PPUSH
12195: CALL_OW 88
// end ; Video ( false ) ;
12199: LD_INT 0
12201: PPUSH
12202: CALL 949 0 1
// end ;
12206: PPOPN 1
12208: END
// every 0 0$1 trigger farmerBaseReady do
12209: LD_EXP 4
12213: IFFALSE 12371
12215: GO 12217
12217: DISABLE
// begin DialogueOn ;
12218: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
12222: LD_EXP 31
12226: PPUSH
12227: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
12231: LD_EXP 31
12235: PPUSH
12236: LD_STRING DF-1-distribution
12238: PPUSH
12239: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
12243: LD_EXP 23
12247: PPUSH
12248: LD_STRING DH-2-distribution
12250: PPUSH
12251: CALL_OW 88
// if IsOk ( Kaia ) then
12255: LD_EXP 28
12259: PPUSH
12260: CALL_OW 302
12264: IFFALSE 12325
// begin Say ( Kaia , DK-1-distribution ) ;
12266: LD_EXP 28
12270: PPUSH
12271: LD_STRING DK-1-distribution
12273: PPUSH
12274: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
12278: LD_EXP 23
12282: PPUSH
12283: LD_STRING DH-1-distribution
12285: PPUSH
12286: CALL_OW 88
// if IsOk ( Givi ) then
12290: LD_EXP 24
12294: PPUSH
12295: CALL_OW 302
12299: IFFALSE 12325
// begin Say ( Givi , DG-1-distribution ) ;
12301: LD_EXP 24
12305: PPUSH
12306: LD_STRING DG-1-distribution
12308: PPUSH
12309: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
12313: LD_EXP 23
12317: PPUSH
12318: LD_STRING DH-3-distribution
12320: PPUSH
12321: CALL_OW 88
// end ; end ; DialogueOff ;
12325: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
12329: LD_STRING Crates1
12331: PPUSH
12332: CALL_OW 337
// farmerRequestedCrates := 300 ;
12336: LD_ADDR_EXP 13
12340: PUSH
12341: LD_INT 300
12343: ST_TO_ADDR
// Query ( FarmerCrates ) ;
12344: LD_STRING FarmerCrates
12346: PPUSH
12347: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
12351: LD_INT 10
12353: PPUSH
12354: LD_INT 1
12356: PPUSH
12357: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
12361: LD_INT 108
12363: PPUSH
12364: LD_INT 61
12366: PPUSH
12367: CALL_OW 86
// end ;
12371: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_lab ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
12372: LD_EXP 6
12376: PUSH
12377: LD_INT 22
12379: PUSH
12380: LD_INT 2
12382: PUSH
12383: EMPTY
12384: LIST
12385: LIST
12386: PUSH
12387: LD_INT 3
12389: PUSH
12390: LD_INT 57
12392: PUSH
12393: EMPTY
12394: LIST
12395: PUSH
12396: EMPTY
12397: LIST
12398: LIST
12399: PUSH
12400: LD_INT 30
12402: PUSH
12403: LD_INT 6
12405: PUSH
12406: EMPTY
12407: LIST
12408: LIST
12409: PUSH
12410: EMPTY
12411: LIST
12412: LIST
12413: LIST
12414: PPUSH
12415: CALL_OW 69
12419: AND
12420: PUSH
12421: LD_INT 22
12423: PUSH
12424: LD_INT 2
12426: PUSH
12427: EMPTY
12428: LIST
12429: LIST
12430: PUSH
12431: LD_INT 3
12433: PUSH
12434: LD_INT 57
12436: PUSH
12437: EMPTY
12438: LIST
12439: PUSH
12440: EMPTY
12441: LIST
12442: LIST
12443: PUSH
12444: LD_INT 30
12446: PUSH
12447: LD_INT 4
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: PUSH
12454: EMPTY
12455: LIST
12456: LIST
12457: LIST
12458: PPUSH
12459: CALL_OW 69
12463: AND
12464: IFFALSE 12616
12466: GO 12468
12468: DISABLE
12469: LD_INT 0
12471: PPUSH
// begin wait ( 0 0$10 ) ;
12472: LD_INT 350
12474: PPUSH
12475: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
12479: LD_ADDR_VAR 0 1
12483: PUSH
12484: LD_EXP 37
12488: PPUSH
12489: LD_INT 26
12491: PUSH
12492: LD_INT 1
12494: PUSH
12495: EMPTY
12496: LIST
12497: LIST
12498: PUSH
12499: LD_INT 25
12501: PUSH
12502: LD_INT 2
12504: PUSH
12505: EMPTY
12506: LIST
12507: LIST
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: PPUSH
12513: CALL_OW 72
12517: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
12518: LD_EXP 23
12522: PPUSH
12523: LD_STRING DH-1-task
12525: PPUSH
12526: CALL_OW 88
// if IsOk ( Sophia ) then
12530: LD_EXP 29
12534: PPUSH
12535: CALL_OW 302
12539: IFFALSE 12567
// begin Say ( Sophia , DS-1-task ) ;
12541: LD_EXP 29
12545: PPUSH
12546: LD_STRING DS-1-task
12548: PPUSH
12549: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
12553: LD_EXP 23
12557: PPUSH
12558: LD_STRING DH-2-task
12560: PPUSH
12561: CALL_OW 88
// end else
12565: GO 12601
// if eng then
12567: LD_VAR 0 1
12571: IFFALSE 12601
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
12573: LD_VAR 0 1
12577: PUSH
12578: LD_INT 1
12580: ARRAY
12581: PPUSH
12582: LD_STRING DArm-1-task
12584: PPUSH
12585: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
12589: LD_EXP 23
12593: PPUSH
12594: LD_STRING DH-2-task
12596: PPUSH
12597: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
12601: LD_STRING BaseConstructed
12603: PPUSH
12604: CALL_OW 337
// allowConvoys := true ;
12608: LD_ADDR_EXP 11
12612: PUSH
12613: LD_INT 1
12615: ST_TO_ADDR
// end ;
12616: PPOPN 1
12618: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
12619: LD_EXP 4
12623: PUSH
12624: LD_EXP 12
12628: PUSH
12629: LD_INT 300
12631: GREATEREQUAL
12632: AND
12633: IFFALSE 12705
12635: GO 12637
12637: DISABLE
// begin DialogueOn ;
12638: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
12642: LD_EXP 31
12646: PPUSH
12647: LD_STRING DF-1-delivery-2
12649: PPUSH
12650: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
12654: LD_EXP 23
12658: PPUSH
12659: LD_STRING DH-1-delivery-2
12661: PPUSH
12662: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
12666: LD_EXP 31
12670: PPUSH
12671: LD_STRING DF-2-delivery-2
12673: PPUSH
12674: CALL_OW 94
// DialogueOff ;
12678: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
12682: LD_STRING Crates2
12684: PPUSH
12685: CALL_OW 337
// farmerCratesCounter := 4 4$00 ;
12689: LD_ADDR_EXP 14
12693: PUSH
12694: LD_INT 8400
12696: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
12697: LD_ADDR_EXP 13
12701: PUSH
12702: LD_INT 600
12704: ST_TO_ADDR
// end ;
12705: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 and Difficulty > 1 do
12706: LD_EXP 4
12710: PUSH
12711: LD_EXP 12
12715: PUSH
12716: LD_INT 600
12718: GREATEREQUAL
12719: AND
12720: PUSH
12721: LD_OWVAR 67
12725: PUSH
12726: LD_INT 1
12728: GREATER
12729: AND
12730: IFFALSE 12896
12732: GO 12734
12734: DISABLE
// begin DialogueOn ;
12735: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
12739: LD_EXP 31
12743: PPUSH
12744: LD_STRING DF-1-delivery-3
12746: PPUSH
12747: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
12751: LD_EXP 23
12755: PPUSH
12756: LD_STRING DH-1-delivery-3
12758: PPUSH
12759: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
12763: LD_EXP 31
12767: PPUSH
12768: LD_STRING DF-2-delivery-3
12770: PPUSH
12771: CALL_OW 94
// if IsOk ( Kaia ) then
12775: LD_EXP 28
12779: PPUSH
12780: CALL_OW 302
12784: IFFALSE 12834
// begin Say ( Kaia , DK-1-delivery-3 ) ;
12786: LD_EXP 28
12790: PPUSH
12791: LD_STRING DK-1-delivery-3
12793: PPUSH
12794: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
12798: LD_EXP 23
12802: PPUSH
12803: LD_STRING DH-2-delivery-3
12805: PPUSH
12806: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
12810: LD_EXP 24
12814: PPUSH
12815: LD_STRING DG-1-delivery-3
12817: PPUSH
12818: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
12822: LD_EXP 25
12826: PPUSH
12827: LD_STRING DM-1-delivery-3
12829: PPUSH
12830: CALL_OW 88
// end ; DialogueOff ;
12834: CALL_OW 7
// if Difficulty = 2 then
12838: LD_OWVAR 67
12842: PUSH
12843: LD_INT 2
12845: EQUAL
12846: IFFALSE 12873
// begin ChangeMissionObjectives ( Crates3 ) ;
12848: LD_STRING Crates3
12850: PPUSH
12851: CALL_OW 337
// farmerCratesCounter := 5 5$00 ;
12855: LD_ADDR_EXP 14
12859: PUSH
12860: LD_INT 10500
12862: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
12863: LD_ADDR_EXP 13
12867: PUSH
12868: LD_INT 900
12870: ST_TO_ADDR
// end else
12871: GO 12896
// begin ChangeMissionObjectives ( Crates4 ) ;
12873: LD_STRING Crates4
12875: PPUSH
12876: CALL_OW 337
// farmerCratesCounter := 6 6$00 ;
12880: LD_ADDR_EXP 14
12884: PUSH
12885: LD_INT 12600
12887: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
12888: LD_ADDR_EXP 13
12892: PUSH
12893: LD_INT 1200
12895: ST_TO_ADDR
// end ; end ;
12896: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
12897: LD_EXP 4
12901: PUSH
12902: LD_EXP 12
12906: PUSH
12907: LD_INT 600
12909: PUSH
12910: LD_INT 900
12912: PUSH
12913: LD_INT 1200
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: PUSH
12921: LD_OWVAR 67
12925: ARRAY
12926: GREATEREQUAL
12927: AND
12928: PUSH
12929: LD_EXP 13
12933: PUSH
12934: LD_EXP 14
12938: LESSEQUAL
12939: AND
12940: IFFALSE 13013
12942: GO 12944
12944: DISABLE
// begin retreatAllowed := true ;
12945: LD_ADDR_EXP 10
12949: PUSH
12950: LD_INT 1
12952: ST_TO_ADDR
// display_strings := [ ] ;
12953: LD_ADDR_OWVAR 47
12957: PUSH
12958: EMPTY
12959: ST_TO_ADDR
// DialogueOn ;
12960: CALL_OW 6
// Video ( true ) ;
12964: LD_INT 1
12966: PPUSH
12967: CALL 949 0 1
// SayRadio ( Omar , DO-radio-end ) ;
12971: LD_EXP 32
12975: PPUSH
12976: LD_STRING DO-radio-end
12978: PPUSH
12979: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
12983: LD_EXP 23
12987: PPUSH
12988: LD_STRING DH-1-radio-end
12990: PPUSH
12991: CALL_OW 88
// Video ( false ) ;
12995: LD_INT 0
12997: PPUSH
12998: CALL 949 0 1
// DialogueOff ;
13002: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
13006: LD_STRING Retreat
13008: PPUSH
13009: CALL_OW 337
// end ;
13013: END
// every 0 0$1 trigger retreatAllowed do
13014: LD_EXP 10
13018: IFFALSE 13037
13020: GO 13022
13022: DISABLE
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
13023: LD_INT 10
13025: PPUSH
13026: LD_INT 0
13028: PPUSH
13029: CALL_OW 424
// StartCargoEvacuation ;
13033: CALL 4240 0 0
// end ;
13037: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
13038: LD_EXP 10
13042: NOT
13043: PUSH
13044: LD_INT 5
13046: PPUSH
13047: CALL_OW 301
13051: AND
13052: IFFALSE 13076
13054: GO 13056
13056: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
13057: LD_EXP 31
13061: PPUSH
13062: LD_STRING DF-1-failure
13064: PPUSH
13065: CALL_OW 94
// YouLost ( FarmerDepot ) ;
13069: LD_STRING FarmerDepot
13071: PPUSH
13072: CALL_OW 104
// end ;
13076: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 do var i , max , tmp ;
13077: LD_EXP 10
13081: PUSH
13082: LD_EXP 23
13086: PPUSH
13087: LD_EXP 31
13091: PPUSH
13092: CALL_OW 296
13096: PUSH
13097: LD_INT 6
13099: LESS
13100: AND
13101: IFFALSE 13656
13103: GO 13105
13105: DISABLE
13106: LD_INT 0
13108: PPUSH
13109: PPUSH
13110: PPUSH
// begin Video ( true ) ;
13111: LD_INT 1
13113: PPUSH
13114: CALL 949 0 1
// ComTurnUnit ( Heike , Farmer ) ;
13118: LD_EXP 23
13122: PPUSH
13123: LD_EXP 31
13127: PPUSH
13128: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
13132: LD_EXP 31
13136: PPUSH
13137: LD_EXP 23
13141: PPUSH
13142: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
13146: LD_EXP 31
13150: PPUSH
13151: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
13155: LD_EXP 23
13159: PPUSH
13160: LD_STRING DH-1-end
13162: PPUSH
13163: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
13167: LD_EXP 31
13171: PPUSH
13172: LD_STRING DF-1-end
13174: PPUSH
13175: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
13179: LD_EXP 31
13183: PPUSH
13184: LD_STRING DF-2-end
13186: PPUSH
13187: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
13191: LD_EXP 23
13195: PPUSH
13196: LD_STRING DH-2-end
13198: PPUSH
13199: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
13203: LD_EXP 31
13207: PPUSH
13208: LD_STRING DF-3-end
13210: PPUSH
13211: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
13215: LD_EXP 23
13219: PPUSH
13220: LD_STRING DH-3-end
13222: PPUSH
13223: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
13227: LD_EXP 24
13231: PPUSH
13232: LD_STRING DG-1-end
13234: PPUSH
13235: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
13239: LD_EXP 23
13243: PPUSH
13244: LD_STRING DH-4-end
13246: PPUSH
13247: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
13251: LD_EXP 31
13255: PPUSH
13256: LD_STRING DF-4-end
13258: PPUSH
13259: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
13263: LD_EXP 23
13267: PPUSH
13268: LD_STRING DH-5-end
13270: PPUSH
13271: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
13275: LD_EXP 31
13279: PPUSH
13280: LD_STRING DF-5-end
13282: PPUSH
13283: CALL_OW 88
// Video ( false ) ;
13287: LD_INT 0
13289: PPUSH
13290: CALL 949 0 1
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
13294: LD_ADDR_VAR 0 2
13298: PUSH
13299: LD_INT 4
13301: PUSH
13302: LD_INT 3
13304: PUSH
13305: LD_INT 2
13307: PUSH
13308: EMPTY
13309: LIST
13310: LIST
13311: LIST
13312: PUSH
13313: LD_OWVAR 67
13317: ARRAY
13318: ST_TO_ADDR
// if farmerSquad < max then
13319: LD_EXP 34
13323: PUSH
13324: LD_VAR 0 2
13328: LESS
13329: IFFALSE 13341
// max := farmerSquad ;
13331: LD_ADDR_VAR 0 2
13335: PUSH
13336: LD_EXP 34
13340: ST_TO_ADDR
// for i := 1 to max do
13341: LD_ADDR_VAR 0 1
13345: PUSH
13346: DOUBLE
13347: LD_INT 1
13349: DEC
13350: ST_TO_ADDR
13351: LD_VAR 0 2
13355: PUSH
13356: FOR_TO
13357: IFFALSE 13395
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
13359: LD_EXP 34
13363: PUSH
13364: LD_INT 1
13366: ARRAY
13367: PPUSH
13368: LD_INT 2
13370: PPUSH
13371: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
13375: LD_ADDR_EXP 34
13379: PUSH
13380: LD_EXP 34
13384: PPUSH
13385: LD_INT 1
13387: PPUSH
13388: CALL_OW 3
13392: ST_TO_ADDR
// end ;
13393: GO 13356
13395: POP
13396: POP
// for i in Farmer ^ farmerSquad do
13397: LD_ADDR_VAR 0 1
13401: PUSH
13402: LD_EXP 31
13406: PUSH
13407: LD_EXP 34
13411: ADD
13412: PUSH
13413: FOR_IN
13414: IFFALSE 13453
// begin if IsInUnit ( i ) then
13416: LD_VAR 0 1
13420: PPUSH
13421: CALL_OW 310
13425: IFFALSE 13436
// ComExitBuilding ( i ) ;
13427: LD_VAR 0 1
13431: PPUSH
13432: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
13436: LD_VAR 0 1
13440: PPUSH
13441: LD_INT 102
13443: PPUSH
13444: LD_INT 7
13446: PPUSH
13447: CALL_OW 171
// end ;
13451: GO 13413
13453: POP
13454: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
13455: LD_ADDR_VAR 0 1
13459: PUSH
13460: LD_INT 22
13462: PUSH
13463: LD_INT 5
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: LD_INT 21
13472: PUSH
13473: LD_INT 3
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: EMPTY
13481: LIST
13482: LIST
13483: PPUSH
13484: CALL_OW 69
13488: PUSH
13489: LD_INT 5
13491: DIFF
13492: PUSH
13493: FOR_IN
13494: IFFALSE 13510
// SetSide ( i , 2 ) ;
13496: LD_VAR 0 1
13500: PPUSH
13501: LD_INT 2
13503: PPUSH
13504: CALL_OW 235
13508: GO 13493
13510: POP
13511: POP
// repeat wait ( 0 0$1 ) ;
13512: LD_INT 35
13514: PPUSH
13515: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
13519: LD_ADDR_VAR 0 3
13523: PUSH
13524: LD_EXP 31
13528: PUSH
13529: LD_EXP 34
13533: ADD
13534: PPUSH
13535: LD_INT 95
13537: PUSH
13538: LD_INT 3
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PPUSH
13545: CALL_OW 72
13549: ST_TO_ADDR
// if tmp then
13550: LD_VAR 0 3
13554: IFFALSE 13610
// for i in tmp do
13556: LD_ADDR_VAR 0 1
13560: PUSH
13561: LD_VAR 0 3
13565: PUSH
13566: FOR_IN
13567: IFFALSE 13608
// begin if i in farmerSquad then
13569: LD_VAR 0 1
13573: PUSH
13574: LD_EXP 34
13578: IN
13579: IFFALSE 13597
// farmerSquad := farmerSquad diff i ;
13581: LD_ADDR_EXP 34
13585: PUSH
13586: LD_EXP 34
13590: PUSH
13591: LD_VAR 0 1
13595: DIFF
13596: ST_TO_ADDR
// RemoveUnit ( i ) ;
13597: LD_VAR 0 1
13601: PPUSH
13602: CALL_OW 64
// end ;
13606: GO 13566
13608: POP
13609: POP
// until not Farmer and not farmerSquad ;
13610: LD_EXP 31
13614: NOT
13615: PUSH
13616: LD_EXP 34
13620: NOT
13621: AND
13622: IFFALSE 13512
// wait ( 3 3$00 ) ;
13624: LD_INT 6300
13626: PPUSH
13627: CALL_OW 67
// SendAttack ;
13631: CALL 6297 0 0
// if Difficulty > 1 then
13635: LD_OWVAR 67
13639: PUSH
13640: LD_INT 1
13642: GREATER
13643: IFFALSE 13656
// begin wait ( 3 3$00 ) ;
13645: LD_INT 6300
13647: PPUSH
13648: CALL_OW 67
// SendAttack ;
13652: CALL 6297 0 0
// end ; end ;
13656: PPOPN 3
13658: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
13659: LD_EXP 14
13663: PUSH
13664: LD_INT 0
13666: LESSEQUAL
13667: IFFALSE 13716
13669: GO 13671
13671: DISABLE
// begin DialogueOn ;
13672: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
13676: LD_EXP 31
13680: PPUSH
13681: LD_STRING DF-1-distribution-a
13683: PPUSH
13684: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
13688: LD_EXP 23
13692: PPUSH
13693: LD_STRING DH-1-distribution-a
13695: PPUSH
13696: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
13700: LD_EXP 31
13704: PPUSH
13705: LD_STRING DF-2-distribution-a
13707: PPUSH
13708: CALL_OW 94
// DialogueOff ;
13712: CALL_OW 7
// end ;
13716: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
13717: LD_INT 22
13719: PUSH
13720: LD_INT 2
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PUSH
13727: LD_INT 34
13729: PUSH
13730: LD_INT 12
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: PPUSH
13741: CALL_OW 69
13745: IFFALSE 13805
13747: GO 13749
13749: DISABLE
// begin DialogueOn ;
13750: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
13754: LD_EXP 23
13758: PPUSH
13759: LD_STRING DH-1-truck
13761: PPUSH
13762: CALL_OW 88
// if IsOk ( Markov ) then
13766: LD_EXP 30
13770: PPUSH
13771: CALL_OW 302
13775: IFFALSE 13801
// begin Say ( Markov , DMar-1-truck ) ;
13777: LD_EXP 30
13781: PPUSH
13782: LD_STRING DMar-1-truck
13784: PPUSH
13785: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
13789: LD_EXP 23
13793: PPUSH
13794: LD_STRING DH-2-truck
13796: PPUSH
13797: CALL_OW 88
// end ; DialogueOff ;
13801: CALL_OW 7
// end ;
13805: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
13806: LD_INT 0
13808: PPUSH
13809: PPUSH
13810: PPUSH
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
13811: LD_ADDR_VAR 0 2
13815: PUSH
13816: LD_EXP 37
13820: PPUSH
13821: LD_INT 26
13823: PUSH
13824: LD_INT 1
13826: PUSH
13827: EMPTY
13828: LIST
13829: LIST
13830: PPUSH
13831: CALL_OW 72
13835: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
13836: LD_ADDR_VAR 0 3
13840: PUSH
13841: LD_EXP 37
13845: PPUSH
13846: LD_INT 26
13848: PUSH
13849: LD_INT 2
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PPUSH
13856: CALL_OW 72
13860: ST_TO_ADDR
// if randomMen then
13861: LD_VAR 0 2
13865: IFFALSE 13885
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
13867: LD_VAR 0 2
13871: PUSH
13872: LD_INT 1
13874: ARRAY
13875: PPUSH
13876: LD_STRING DArm-1-nocargo
13878: PPUSH
13879: CALL_OW 88
13883: GO 13907
// if randomWomen then
13885: LD_VAR 0 3
13889: IFFALSE 13907
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
13891: LD_VAR 0 3
13895: PUSH
13896: LD_INT 1
13898: ARRAY
13899: PPUSH
13900: LD_STRING DArf-1-nocargo
13902: PPUSH
13903: CALL_OW 88
// end ;
13907: LD_VAR 0 1
13911: RET
// export function IncomingAttack ; begin
13912: LD_INT 0
13914: PPUSH
// if attackWave = 1 then
13915: LD_EXP 16
13919: PUSH
13920: LD_INT 1
13922: EQUAL
13923: IFFALSE 13994
// begin DialogueOn ;
13925: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
13929: LD_EXP 32
13933: PPUSH
13934: LD_STRING DO-1-radio-1
13936: PPUSH
13937: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
13941: LD_EXP 23
13945: PPUSH
13946: LD_STRING DH-1-radio-1-
13948: PPUSH
13949: CALL_OW 88
// if IsOk ( Markov ) then
13953: LD_EXP 30
13957: PPUSH
13958: CALL_OW 302
13962: IFFALSE 13988
// begin Say ( Markov , DMar-1-radio-1 ) ;
13964: LD_EXP 30
13968: PPUSH
13969: LD_STRING DMar-1-radio-1
13971: PPUSH
13972: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
13976: LD_EXP 23
13980: PPUSH
13981: LD_STRING DH-2-radio-1
13983: PPUSH
13984: CALL_OW 88
// end ; DialogueOff ;
13988: CALL_OW 7
// end else
13992: GO 14018
// begin SayRadio ( Omar , DO-1-radio-u ) ;
13994: LD_EXP 32
13998: PPUSH
13999: LD_STRING DO-1-radio-u
14001: PPUSH
14002: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
14006: LD_EXP 23
14010: PPUSH
14011: LD_STRING DH-1-radio-u
14013: PPUSH
14014: CALL_OW 88
// end ; end ;
14018: LD_VAR 0 1
14022: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
14023: LD_EXP 39
14027: PPUSH
14028: LD_INT 95
14030: PUSH
14031: LD_INT 8
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: PPUSH
14038: CALL_OW 72
14042: IFFALSE 14145
14044: GO 14046
14046: DISABLE
14047: LD_INT 0
14049: PPUSH
// begin enable ;
14050: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
14051: LD_ADDR_VAR 0 1
14055: PUSH
14056: LD_EXP 39
14060: PPUSH
14061: LD_INT 95
14063: PUSH
14064: LD_INT 8
14066: PUSH
14067: EMPTY
14068: LIST
14069: LIST
14070: PPUSH
14071: CALL_OW 72
14075: PUSH
14076: FOR_IN
14077: IFFALSE 14106
// begin usForces := usForces diff i ;
14079: LD_ADDR_EXP 39
14083: PUSH
14084: LD_EXP 39
14088: PUSH
14089: LD_VAR 0 1
14093: DIFF
14094: ST_TO_ADDR
// RemoveUnit ( i ) ;
14095: LD_VAR 0 1
14099: PPUSH
14100: CALL_OW 64
// end ;
14104: GO 14076
14106: POP
14107: POP
// if not americanHasEscaped and attackWave = 1 then
14108: LD_EXP 7
14112: NOT
14113: PUSH
14114: LD_EXP 16
14118: PUSH
14119: LD_INT 1
14121: EQUAL
14122: AND
14123: IFFALSE 14145
// begin americanHasEscaped := true ;
14125: LD_ADDR_EXP 7
14129: PUSH
14130: LD_INT 1
14132: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
14133: LD_EXP 23
14137: PPUSH
14138: LD_STRING DH-2-assault-a
14140: PPUSH
14141: CALL_OW 88
// end ; end ;
14145: PPOPN 1
14147: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
14148: LD_INT 5
14150: PPUSH
14151: CALL_OW 255
14155: PUSH
14156: LD_INT 2
14158: EQUAL
14159: IFFALSE 14171
14161: GO 14163
14163: DISABLE
// YouLost ( Attack ) ;
14164: LD_STRING Attack
14166: PPUSH
14167: CALL_OW 104
14171: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not retreatAllowed and farmerCrates > 100 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) do var randomMen , randomWomen , speaker , place ;
14172: LD_INT 22
14174: PUSH
14175: LD_INT 1
14177: PUSH
14178: EMPTY
14179: LIST
14180: LIST
14181: PUSH
14182: LD_INT 21
14184: PUSH
14185: LD_INT 1
14187: PUSH
14188: EMPTY
14189: LIST
14190: LIST
14191: PUSH
14192: EMPTY
14193: LIST
14194: LIST
14195: PPUSH
14196: CALL_OW 69
14200: NOT
14201: PUSH
14202: LD_EXP 10
14206: NOT
14207: AND
14208: PUSH
14209: LD_EXP 12
14213: PUSH
14214: LD_INT 100
14216: GREATER
14217: AND
14218: PUSH
14219: LD_INT 7
14221: PPUSH
14222: LD_INT 22
14224: PUSH
14225: LD_INT 2
14227: PUSH
14228: EMPTY
14229: LIST
14230: LIST
14231: PUSH
14232: LD_INT 21
14234: PUSH
14235: LD_INT 1
14237: PUSH
14238: EMPTY
14239: LIST
14240: LIST
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: PPUSH
14246: CALL_OW 70
14250: AND
14251: IFFALSE 14954
14253: GO 14255
14255: DISABLE
14256: LD_INT 0
14258: PPUSH
14259: PPUSH
14260: PPUSH
14261: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
14262: LD_ADDR_VAR 0 1
14266: PUSH
14267: LD_EXP 37
14271: PPUSH
14272: LD_INT 26
14274: PUSH
14275: LD_INT 1
14277: PUSH
14278: EMPTY
14279: LIST
14280: LIST
14281: PPUSH
14282: CALL_OW 72
14286: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
14287: LD_ADDR_VAR 0 2
14291: PUSH
14292: LD_EXP 37
14296: PPUSH
14297: LD_INT 26
14299: PUSH
14300: LD_INT 2
14302: PUSH
14303: EMPTY
14304: LIST
14305: LIST
14306: PPUSH
14307: CALL_OW 72
14311: ST_TO_ADDR
// if IsOk ( Kaia ) then
14312: LD_EXP 28
14316: PPUSH
14317: CALL_OW 302
14321: IFFALSE 14342
// speaker := [ Kaia , DK ] else
14323: LD_ADDR_VAR 0 3
14327: PUSH
14328: LD_EXP 28
14332: PUSH
14333: LD_STRING DK
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: ST_TO_ADDR
14340: GO 14422
// if randomMen then
14342: LD_VAR 0 1
14346: IFFALSE 14381
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
14348: LD_ADDR_VAR 0 3
14352: PUSH
14353: LD_VAR 0 1
14357: PUSH
14358: LD_INT 1
14360: PPUSH
14361: LD_VAR 0 1
14365: PPUSH
14366: CALL_OW 12
14370: ARRAY
14371: PUSH
14372: LD_STRING DArm
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: ST_TO_ADDR
14379: GO 14422
// if randomWomen then
14381: LD_VAR 0 2
14385: IFFALSE 14420
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
14387: LD_ADDR_VAR 0 3
14391: PUSH
14392: LD_VAR 0 2
14396: PUSH
14397: LD_INT 1
14399: PPUSH
14400: LD_VAR 0 2
14404: PPUSH
14405: CALL_OW 12
14409: ARRAY
14410: PUSH
14411: LD_STRING DArf
14413: PUSH
14414: EMPTY
14415: LIST
14416: LIST
14417: ST_TO_ADDR
14418: GO 14422
// exit ;
14420: GO 14954
// if IsInUnit ( speaker [ 1 ] ) then
14422: LD_VAR 0 3
14426: PUSH
14427: LD_INT 1
14429: ARRAY
14430: PPUSH
14431: CALL_OW 310
14435: IFFALSE 14458
// place := IsInUnit ( speaker [ 1 ] ) else
14437: LD_ADDR_VAR 0 4
14441: PUSH
14442: LD_VAR 0 3
14446: PUSH
14447: LD_INT 1
14449: ARRAY
14450: PPUSH
14451: CALL_OW 310
14455: ST_TO_ADDR
14456: GO 14472
// place := speaker [ 1 ] ;
14458: LD_ADDR_VAR 0 4
14462: PUSH
14463: LD_VAR 0 3
14467: PUSH
14468: LD_INT 1
14470: ARRAY
14471: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
14472: LD_VAR 0 4
14476: PPUSH
14477: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
14481: LD_VAR 0 4
14485: PPUSH
14486: CALL_OW 250
14490: PPUSH
14491: LD_VAR 0 4
14495: PPUSH
14496: CALL_OW 251
14500: PPUSH
14501: CALL 2950 0 2
// wait ( 0 0$2 ) ;
14505: LD_INT 70
14507: PPUSH
14508: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
14512: LD_EXP 33
14516: PPUSH
14517: CALL_OW 305
14521: NOT
14522: IFFALSE 14526
// exit ;
14524: GO 14954
// Video ( true ) ;
14526: LD_INT 1
14528: PPUSH
14529: CALL 949 0 1
// wait ( 0 0$1 ) ;
14533: LD_INT 35
14535: PPUSH
14536: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
14540: LD_EXP 33
14544: PPUSH
14545: LD_STRING DI-1-land
14547: PPUSH
14548: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
14552: LD_VAR 0 3
14556: PUSH
14557: LD_INT 1
14559: ARRAY
14560: PPUSH
14561: CALL_OW 310
14565: IFFALSE 14580
// ComExit ( speaker [ 1 ] ) ;
14567: LD_VAR 0 3
14571: PUSH
14572: LD_INT 1
14574: ARRAY
14575: PPUSH
14576: CALL 1053 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
14580: LD_VAR 0 3
14584: PUSH
14585: LD_INT 1
14587: ARRAY
14588: PPUSH
14589: LD_EXP 33
14593: PPUSH
14594: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
14598: LD_VAR 0 3
14602: PUSH
14603: LD_INT 1
14605: ARRAY
14606: PPUSH
14607: LD_EXP 33
14611: PPUSH
14612: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
14616: LD_EXP 33
14620: PPUSH
14621: LD_VAR 0 3
14625: PUSH
14626: LD_INT 1
14628: ARRAY
14629: PPUSH
14630: CALL_OW 119
// wait ( 0 0$1 ) ;
14634: LD_INT 35
14636: PPUSH
14637: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
14641: LD_VAR 0 3
14645: PUSH
14646: LD_INT 1
14648: ARRAY
14649: PPUSH
14650: LD_VAR 0 3
14654: PUSH
14655: LD_INT 2
14657: ARRAY
14658: PUSH
14659: LD_STRING -1-land
14661: STR
14662: PPUSH
14663: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
14667: LD_EXP 33
14671: PPUSH
14672: LD_STRING DI-2-land
14674: PPUSH
14675: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
14679: LD_VAR 0 3
14683: PUSH
14684: LD_INT 1
14686: ARRAY
14687: PPUSH
14688: LD_VAR 0 3
14692: PUSH
14693: LD_INT 2
14695: ARRAY
14696: PUSH
14697: LD_STRING -2-land
14699: STR
14700: PPUSH
14701: CALL_OW 88
// if IsInUnit ( Heike ) then
14705: LD_EXP 23
14709: PPUSH
14710: CALL_OW 310
14714: IFFALSE 14725
// ComExitBuilding ( Heike ) ;
14716: LD_EXP 23
14720: PPUSH
14721: CALL_OW 122
// AddComMoveXY ( Heike , 34 , 21 ) ;
14725: LD_EXP 23
14729: PPUSH
14730: LD_INT 34
14732: PPUSH
14733: LD_INT 21
14735: PPUSH
14736: CALL_OW 171
// AddComTurnUnit ( Heike , speaker [ 1 ] ) ;
14740: LD_EXP 23
14744: PPUSH
14745: LD_VAR 0 3
14749: PUSH
14750: LD_INT 1
14752: ARRAY
14753: PPUSH
14754: CALL_OW 179
// ComMoveXY ( Ibrahim , 36 , 22 ) ;
14758: LD_EXP 33
14762: PPUSH
14763: LD_INT 36
14765: PPUSH
14766: LD_INT 22
14768: PPUSH
14769: CALL_OW 111
// ComMoveXY ( speaker [ 1 ] , 35 , 22 ) ;
14773: LD_VAR 0 3
14777: PUSH
14778: LD_INT 1
14780: ARRAY
14781: PPUSH
14782: LD_INT 35
14784: PPUSH
14785: LD_INT 22
14787: PPUSH
14788: CALL_OW 111
// AddComTurnUnit ( [ Ibrahim , speaker [ 1 ] ] , Heike ) ;
14792: LD_EXP 33
14796: PUSH
14797: LD_VAR 0 3
14801: PUSH
14802: LD_INT 1
14804: ARRAY
14805: PUSH
14806: EMPTY
14807: LIST
14808: LIST
14809: PPUSH
14810: LD_EXP 23
14814: PPUSH
14815: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
14819: LD_INT 35
14821: PPUSH
14822: CALL_OW 67
// until GetDistUnits ( speaker [ 1 ] , usDepot ) < 8 ;
14826: LD_VAR 0 3
14830: PUSH
14831: LD_INT 1
14833: ARRAY
14834: PPUSH
14835: LD_INT 11
14837: PPUSH
14838: CALL_OW 296
14842: PUSH
14843: LD_INT 8
14845: LESS
14846: IFFALSE 14819
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
14848: LD_VAR 0 3
14852: PUSH
14853: LD_INT 1
14855: ARRAY
14856: PPUSH
14857: LD_VAR 0 3
14861: PUSH
14862: LD_INT 2
14864: ARRAY
14865: PUSH
14866: LD_STRING -3-land
14868: STR
14869: PPUSH
14870: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
14874: LD_EXP 23
14878: PPUSH
14879: LD_STRING DH-1-land
14881: PPUSH
14882: CALL_OW 88
// if UnitsInside ( usDepot ) = 6 then
14886: LD_INT 11
14888: PPUSH
14889: CALL_OW 313
14893: PUSH
14894: LD_INT 6
14896: EQUAL
14897: IFFALSE 14915
// ComExitBuilding ( UnitsInside ( usDepot ) [ 1 ] ) ;
14899: LD_INT 11
14901: PPUSH
14902: CALL_OW 313
14906: PUSH
14907: LD_INT 1
14909: ARRAY
14910: PPUSH
14911: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
14915: LD_EXP 33
14919: PPUSH
14920: LD_INT 2
14922: PPUSH
14923: CALL_OW 235
// ComEnterUnit ( Ibrahim , usDepot ) ;
14927: LD_EXP 33
14931: PPUSH
14932: LD_INT 11
14934: PPUSH
14935: CALL_OW 120
// Video ( false ) ;
14939: LD_INT 0
14941: PPUSH
14942: CALL 949 0 1
// ibrahimInDepot := true ;
14946: LD_ADDR_EXP 21
14950: PUSH
14951: LD_INT 1
14953: ST_TO_ADDR
// end ;
14954: PPOPN 4
14956: END
// export function IbrahimQuery ; begin
14957: LD_INT 0
14959: PPUSH
// case Query ( IbrahimQuery ) of 1 :
14960: LD_STRING IbrahimQuery
14962: PPUSH
14963: CALL_OW 97
14967: PUSH
14968: LD_INT 1
14970: DOUBLE
14971: EQUAL
14972: IFTRUE 14976
14974: GO 15264
14976: POP
// begin Video ( true ) ;
14977: LD_INT 1
14979: PPUSH
14980: CALL 949 0 1
// ibrahimInDepot := false ;
14984: LD_ADDR_EXP 21
14988: PUSH
14989: LD_INT 0
14991: ST_TO_ADDR
// Say ( Heike , DH-1-interrogation ) ;
14992: LD_EXP 23
14996: PPUSH
14997: LD_STRING DH-1-interrogation
14999: PPUSH
15000: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
15004: LD_EXP 33
15008: PPUSH
15009: LD_STRING DI-1-interrogation
15011: PPUSH
15012: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
15016: LD_EXP 23
15020: PPUSH
15021: LD_STRING DH-2-interrogation
15023: PPUSH
15024: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
15028: LD_EXP 33
15032: PPUSH
15033: LD_STRING DI-2-interrogation
15035: PPUSH
15036: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
15040: LD_EXP 23
15044: PPUSH
15045: LD_STRING DH-3-interrogation
15047: PPUSH
15048: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
15052: LD_EXP 33
15056: PPUSH
15057: LD_STRING DI-3-interrogation
15059: PPUSH
15060: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
15064: LD_EXP 23
15068: PPUSH
15069: LD_STRING DH-4-interrogation
15071: PPUSH
15072: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
15076: LD_EXP 33
15080: PPUSH
15081: LD_STRING DI-4-interrogation
15083: PPUSH
15084: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
15088: LD_EXP 23
15092: PPUSH
15093: LD_STRING DH-5-interrogation
15095: PPUSH
15096: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
15100: LD_EXP 33
15104: PPUSH
15105: LD_STRING DI-5-interrogation
15107: PPUSH
15108: CALL_OW 88
// wait ( 0 0$1 ) ;
15112: LD_INT 35
15114: PPUSH
15115: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
15119: LD_STRING IbrahimDecisionQuery
15121: PPUSH
15122: CALL_OW 97
15126: PUSH
15127: LD_INT 1
15129: DOUBLE
15130: EQUAL
15131: IFTRUE 15135
15133: GO 15159
15135: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
15136: LD_EXP 33
15140: PPUSH
15141: LD_STRING DI-1-kill
15143: PPUSH
15144: CALL_OW 88
// KillUnit ( Ibrahim ) ;
15148: LD_EXP 33
15152: PPUSH
15153: CALL_OW 66
// end ; 2 :
15157: GO 15255
15159: LD_INT 2
15161: DOUBLE
15162: EQUAL
15163: IFTRUE 15167
15165: GO 15254
15167: POP
// begin ComExitBuilding ( Ibrahim ) ;
15168: LD_EXP 33
15172: PPUSH
15173: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
15177: LD_EXP 33
15181: PPUSH
15182: LD_INT 32
15184: PPUSH
15185: LD_INT 5
15187: PPUSH
15188: CALL_OW 171
// wait ( 0 0$3 ) ;
15192: LD_INT 105
15194: PPUSH
15195: CALL_OW 67
// ComExitBuilding ( Heike ) ;
15199: LD_EXP 23
15203: PPUSH
15204: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
15208: LD_EXP 23
15212: PPUSH
15213: LD_INT 36
15215: PPUSH
15216: LD_INT 21
15218: PPUSH
15219: CALL_OW 171
// AddComWait ( Ibrahim , 0 0$2 ) ;
15223: LD_EXP 33
15227: PPUSH
15228: LD_INT 70
15230: PPUSH
15231: CALL_OW 202
// AddComHold ( Ibrahim ) ;
15235: LD_EXP 33
15239: PPUSH
15240: CALL_OW 200
// ibrahimIsFree := true ;
15244: LD_ADDR_EXP 22
15248: PUSH
15249: LD_INT 1
15251: ST_TO_ADDR
// end ; end ;
15252: GO 15255
15254: POP
// Video ( false ) ;
15255: LD_INT 0
15257: PPUSH
15258: CALL 949 0 1
// end ; 2 :
15262: GO 15276
15264: LD_INT 2
15266: DOUBLE
15267: EQUAL
15268: IFTRUE 15272
15270: GO 15275
15272: POP
// ; end ;
15273: GO 15276
15275: POP
// end ;
15276: LD_VAR 0 1
15280: RET
// every 0 0$10 trigger ibrahimIsFree and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass ;
15281: LD_EXP 22
15285: PUSH
15286: LD_EXP 33
15290: PPUSH
15291: LD_INT 7
15293: PPUSH
15294: CALL_OW 308
15298: AND
15299: PUSH
15300: LD_INT 6
15302: PPUSH
15303: LD_EXP 23
15307: PPUSH
15308: CALL_OW 292
15312: AND
15313: PUSH
15314: LD_INT 22
15316: PUSH
15317: LD_INT 1
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: LD_INT 21
15326: PUSH
15327: LD_INT 1
15329: PUSH
15330: EMPTY
15331: LIST
15332: LIST
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: PPUSH
15338: CALL_OW 69
15342: NOT
15343: AND
15344: IFFALSE 15850
15346: GO 15348
15348: DISABLE
15349: LD_INT 0
15351: PPUSH
// begin Video ( true ) ;
15352: LD_INT 1
15354: PPUSH
15355: CALL 949 0 1
// CenterNowOnUnits ( Ibrahim ) ;
15359: LD_EXP 33
15363: PPUSH
15364: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
15368: LD_EXP 23
15372: PPUSH
15373: LD_EXP 33
15377: PPUSH
15378: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
15382: LD_EXP 33
15386: PPUSH
15387: LD_EXP 23
15391: PPUSH
15392: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
15396: LD_EXP 33
15400: PPUSH
15401: LD_STRING DI-1-free
15403: PPUSH
15404: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
15408: LD_EXP 23
15412: PPUSH
15413: LD_STRING DH-1-free
15415: PPUSH
15416: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
15420: LD_EXP 33
15424: PPUSH
15425: LD_STRING DI-2-free
15427: PPUSH
15428: CALL_OW 88
// changeClass := 0 ;
15432: LD_ADDR_VAR 0 1
15436: PUSH
15437: LD_INT 0
15439: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
15440: LD_STRING IbrahimJoinQuery
15442: PPUSH
15443: CALL_OW 97
15447: PUSH
15448: LD_INT 1
15450: DOUBLE
15451: EQUAL
15452: IFTRUE 15456
15454: GO 15467
15456: POP
// begin changeClass := 1 ;
15457: LD_ADDR_VAR 0 1
15461: PUSH
15462: LD_INT 1
15464: ST_TO_ADDR
// end ; 2 :
15465: GO 15671
15467: LD_INT 2
15469: DOUBLE
15470: EQUAL
15471: IFTRUE 15475
15473: GO 15591
15475: POP
// begin Say ( Heike , DH-1-decline ) ;
15476: LD_EXP 23
15480: PPUSH
15481: LD_STRING DH-1-decline
15483: PPUSH
15484: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
15488: LD_EXP 33
15492: PPUSH
15493: LD_STRING DI-1-decline
15495: PPUSH
15496: CALL_OW 88
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
15500: LD_EXP 33
15504: PPUSH
15505: LD_INT 30
15507: PPUSH
15508: LD_INT 1
15510: PPUSH
15511: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
15515: LD_INT 35
15517: PPUSH
15518: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) ;
15522: LD_EXP 33
15526: PPUSH
15527: LD_INT 30
15529: PPUSH
15530: LD_INT 1
15532: PPUSH
15533: CALL_OW 307
15537: PUSH
15538: LD_INT 22
15540: PUSH
15541: LD_INT 2
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PUSH
15548: LD_INT 101
15550: PUSH
15551: LD_INT 6
15553: PUSH
15554: EMPTY
15555: LIST
15556: LIST
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PPUSH
15562: CALL_OW 69
15566: NOT
15567: OR
15568: IFFALSE 15515
// RemoveUnit ( Ibrahim ) ;
15570: LD_EXP 33
15574: PPUSH
15575: CALL_OW 64
// SaveVariable ( 1 , IbrahimHasEscaped ) ;
15579: LD_INT 1
15581: PPUSH
15582: LD_STRING IbrahimHasEscaped
15584: PPUSH
15585: CALL_OW 39
// end ; 3 :
15589: GO 15671
15591: LD_INT 3
15593: DOUBLE
15594: EQUAL
15595: IFTRUE 15599
15597: GO 15670
15599: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
15600: LD_EXP 23
15604: PPUSH
15605: LD_STRING DH-1-radio-hq
15607: PPUSH
15608: CALL_OW 88
// Say ( Ibrahim , DO-1-radio-hq ) ;
15612: LD_EXP 33
15616: PPUSH
15617: LD_STRING DO-1-radio-hq
15619: PPUSH
15620: CALL_OW 88
// Say ( Heike , DH-2-radio-hq ) ;
15624: LD_EXP 23
15628: PPUSH
15629: LD_STRING DH-2-radio-hq
15631: PPUSH
15632: CALL_OW 88
// Say ( Ibrahim , DO-2-radio-hq ) ;
15636: LD_EXP 33
15640: PPUSH
15641: LD_STRING DO-2-radio-hq
15643: PPUSH
15644: CALL_OW 88
// Say ( Heike , DH-3-radio-hq ) ;
15648: LD_EXP 23
15652: PPUSH
15653: LD_STRING DH-3-radio-hq
15655: PPUSH
15656: CALL_OW 88
// changeClass := 1 ;
15660: LD_ADDR_VAR 0 1
15664: PUSH
15665: LD_INT 1
15667: ST_TO_ADDR
// end ; end ;
15668: GO 15671
15670: POP
// if changeClass then
15671: LD_VAR 0 1
15675: IFFALSE 15843
// begin Say ( Heike , DH-1-agree ) ;
15677: LD_EXP 23
15681: PPUSH
15682: LD_STRING DH-1-agree
15684: PPUSH
15685: CALL_OW 88
// if IsOk ( Givi ) then
15689: LD_EXP 24
15693: PPUSH
15694: CALL_OW 302
15698: IFFALSE 15736
// begin Say ( Givi , DG-1-agree ) ;
15700: LD_EXP 24
15704: PPUSH
15705: LD_STRING DG-1-agree
15707: PPUSH
15708: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
15712: LD_EXP 23
15716: PPUSH
15717: LD_STRING DH-2-agree
15719: PPUSH
15720: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
15724: LD_EXP 24
15728: PPUSH
15729: LD_STRING DG-2-agree
15731: PPUSH
15732: CALL_OW 88
// end ; if UnitsInside ( usDepot ) = 6 then
15736: LD_INT 11
15738: PPUSH
15739: CALL_OW 313
15743: PUSH
15744: LD_INT 6
15746: EQUAL
15747: IFFALSE 15765
// ComExitBuilding ( UnitsInside ( usDepot ) [ 1 ] ) ;
15749: LD_INT 11
15751: PPUSH
15752: CALL_OW 313
15756: PUSH
15757: LD_INT 1
15759: ARRAY
15760: PPUSH
15761: CALL_OW 122
// ComEnterUnit ( Ibrahim , usDepot ) ;
15765: LD_EXP 33
15769: PPUSH
15770: LD_INT 11
15772: PPUSH
15773: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
15777: LD_INT 35
15779: PPUSH
15780: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
15784: LD_EXP 33
15788: PPUSH
15789: CALL_OW 310
15793: IFFALSE 15777
// RemoveUnit ( Ibrahim ) ;
15795: LD_EXP 33
15799: PPUSH
15800: CALL_OW 64
// uc_side := 2 ;
15804: LD_ADDR_OWVAR 20
15808: PUSH
15809: LD_INT 2
15811: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
15812: LD_ADDR_EXP 33
15816: PUSH
15817: LD_STRING Ibrahim
15819: PPUSH
15820: LD_INT 0
15822: PPUSH
15823: LD_STRING 
15825: PPUSH
15826: CALL 226 0 3
15830: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , usDepot ) ;
15831: LD_EXP 33
15835: PPUSH
15836: LD_INT 11
15838: PPUSH
15839: CALL_OW 52
// end ; Video ( false ) ;
15843: LD_INT 0
15845: PPUSH
15846: CALL 949 0 1
// end ;
15850: PPOPN 1
15852: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 do
15853: LD_EXP 10
15857: PUSH
15858: LD_EXP 17
15862: PUSH
15863: LD_INT 1
15865: LESS
15866: AND
15867: IFFALSE 16246
15869: GO 15871
15871: DISABLE
// begin DialogueOn ;
15872: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
15876: LD_EXP 23
15880: PPUSH
15881: LD_STRING DH-1-final
15883: PPUSH
15884: CALL_OW 88
// if tick <= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
15888: LD_OWVAR 1
15892: PUSH
15893: LD_INT 126000
15895: PUSH
15896: LD_INT 105000
15898: PUSH
15899: LD_INT 94500
15901: PUSH
15902: EMPTY
15903: LIST
15904: LIST
15905: LIST
15906: PUSH
15907: LD_OWVAR 67
15911: ARRAY
15912: LESSEQUAL
15913: IFFALSE 15927
// AddMedal ( med1 , 1 ) else
15915: LD_STRING med1
15917: PPUSH
15918: LD_INT 1
15920: PPUSH
15921: CALL_OW 101
15925: GO 15938
// AddMedal ( med1 , - 1 ) ;
15927: LD_STRING med1
15929: PPUSH
15930: LD_INT 1
15932: NEG
15933: PPUSH
15934: CALL_OW 101
// if vehCounter >= 2 then
15938: LD_EXP 18
15942: PUSH
15943: LD_INT 2
15945: GREATEREQUAL
15946: IFFALSE 15960
// AddMedal ( med2 , 1 ) else
15948: LD_STRING med2
15950: PPUSH
15951: LD_INT 1
15953: PPUSH
15954: CALL_OW 101
15958: GO 15971
// AddMedal ( med2 , - 1 ) ;
15960: LD_STRING med2
15962: PPUSH
15963: LD_INT 1
15965: NEG
15966: PPUSH
15967: CALL_OW 101
// if deadCounter = 0 then
15971: LD_EXP 8
15975: PUSH
15976: LD_INT 0
15978: EQUAL
15979: IFFALSE 15993
// AddMedal ( med3 , 1 ) else
15981: LD_STRING med3
15983: PPUSH
15984: LD_INT 1
15986: PPUSH
15987: CALL_OW 101
15991: GO 16004
// AddMedal ( med3 , - 1 ) ;
15993: LD_STRING med3
15995: PPUSH
15996: LD_INT 1
15998: NEG
15999: PPUSH
16000: CALL_OW 101
// GiveMedals ( MAIN ) ;
16004: LD_STRING MAIN
16006: PPUSH
16007: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
16011: LD_INT 22
16013: PUSH
16014: LD_INT 2
16016: PUSH
16017: EMPTY
16018: LIST
16019: LIST
16020: PUSH
16021: LD_INT 23
16023: PUSH
16024: LD_INT 2
16026: PUSH
16027: EMPTY
16028: LIST
16029: LIST
16030: PUSH
16031: LD_INT 21
16033: PUSH
16034: LD_INT 1
16036: PUSH
16037: EMPTY
16038: LIST
16039: LIST
16040: PUSH
16041: EMPTY
16042: LIST
16043: LIST
16044: LIST
16045: PPUSH
16046: CALL_OW 69
16050: PPUSH
16051: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
16055: LD_EXP 23
16059: PPUSH
16060: LD_STRING 03_Heike
16062: PPUSH
16063: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
16067: LD_EXP 27
16071: PPUSH
16072: LD_STRING 03_Aviradze
16074: PPUSH
16075: CALL_OW 38
// if Givi then
16079: LD_EXP 24
16083: IFFALSE 16097
// SaveCharacters ( Givi , 03_Givi ) ;
16085: LD_EXP 24
16089: PPUSH
16090: LD_STRING 03_Givi
16092: PPUSH
16093: CALL_OW 38
// if Mike then
16097: LD_EXP 25
16101: IFFALSE 16115
// SaveCharacters ( Mike , 03_Mike ) ;
16103: LD_EXP 25
16107: PPUSH
16108: LD_STRING 03_Mike
16110: PPUSH
16111: CALL_OW 38
// if Kamil then
16115: LD_EXP 26
16119: IFFALSE 16133
// SaveCharacters ( Kamil , 03_Kamil ) ;
16121: LD_EXP 26
16125: PPUSH
16126: LD_STRING 03_Kamil
16128: PPUSH
16129: CALL_OW 38
// if Kaia then
16133: LD_EXP 28
16137: IFFALSE 16151
// SaveCharacters ( Kaia , 03_Kaia ) ;
16139: LD_EXP 28
16143: PPUSH
16144: LD_STRING 03_Kaia
16146: PPUSH
16147: CALL_OW 38
// if Sophia then
16151: LD_EXP 29
16155: IFFALSE 16169
// SaveCharacters ( Sophia , 03_Sophia ) ;
16157: LD_EXP 29
16161: PPUSH
16162: LD_STRING 03_Sophia
16164: PPUSH
16165: CALL_OW 38
// if Markov then
16169: LD_EXP 30
16173: IFFALSE 16187
// SaveCharacters ( Markov , 03_Markov ) ;
16175: LD_EXP 30
16179: PPUSH
16180: LD_STRING 03_Markov
16182: PPUSH
16183: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
16187: LD_EXP 33
16191: PUSH
16192: LD_EXP 33
16196: PPUSH
16197: CALL_OW 255
16201: PUSH
16202: LD_INT 2
16204: EQUAL
16205: AND
16206: IFFALSE 16220
// SaveCharacters ( Markov , 03_Ibrahim ) ;
16208: LD_EXP 30
16212: PPUSH
16213: LD_STRING 03_Ibrahim
16215: PPUSH
16216: CALL_OW 38
// if heikeSecondSquad then
16220: LD_EXP 37
16224: IFFALSE 16238
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
16226: LD_EXP 37
16230: PPUSH
16231: LD_STRING 03_others
16233: PPUSH
16234: CALL_OW 38
// YouWin ;
16238: CALL_OW 103
// DialogueOff ;
16242: CALL_OW 7
// end ; end_of_file
16246: END
// on UnitDestroyed ( un ) do begin if un = Heike then
16247: LD_VAR 0 1
16251: PUSH
16252: LD_EXP 23
16256: EQUAL
16257: IFFALSE 16266
// YouLost ( Heike ) ;
16259: LD_STRING Heike
16261: PPUSH
16262: CALL_OW 104
// if un = Aviradze then
16266: LD_VAR 0 1
16270: PUSH
16271: LD_EXP 27
16275: EQUAL
16276: IFFALSE 16285
// YouLost ( Aviradze ) ;
16278: LD_STRING Aviradze
16280: PPUSH
16281: CALL_OW 104
// if un = usDepot and not retreatAllowed then
16285: LD_VAR 0 1
16289: PUSH
16290: LD_INT 11
16292: EQUAL
16293: PUSH
16294: LD_EXP 10
16298: NOT
16299: AND
16300: IFFALSE 16309
// YouLost ( Depot ) ;
16302: LD_STRING Depot
16304: PPUSH
16305: CALL_OW 104
// if un = Farmer then
16309: LD_VAR 0 1
16313: PUSH
16314: LD_EXP 31
16318: EQUAL
16319: IFFALSE 16328
// YouLost ( Farmer ) ;
16321: LD_STRING Farmer
16323: PPUSH
16324: CALL_OW 104
// if un in usForces then
16328: LD_VAR 0 1
16332: PUSH
16333: LD_EXP 39
16337: IN
16338: IFFALSE 16356
// usForces := usForces diff un ;
16340: LD_ADDR_EXP 39
16344: PUSH
16345: LD_EXP 39
16349: PUSH
16350: LD_VAR 0 1
16354: DIFF
16355: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
16356: LD_VAR 0 1
16360: PUSH
16361: LD_INT 22
16363: PUSH
16364: LD_INT 2
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: PUSH
16371: LD_INT 23
16373: PUSH
16374: LD_INT 2
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: LD_INT 21
16383: PUSH
16384: LD_INT 1
16386: PUSH
16387: EMPTY
16388: LIST
16389: LIST
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: LIST
16395: PPUSH
16396: CALL_OW 69
16400: IN
16401: IFFALSE 16417
// deadCounter := deadCounter + 1 ;
16403: LD_ADDR_EXP 8
16407: PUSH
16408: LD_EXP 8
16412: PUSH
16413: LD_INT 1
16415: PLUS
16416: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
16417: LD_VAR 0 1
16421: PUSH
16422: LD_INT 22
16424: PUSH
16425: LD_INT 4
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: LD_INT 34
16434: PUSH
16435: LD_INT 12
16437: PUSH
16438: EMPTY
16439: LIST
16440: LIST
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: PPUSH
16446: CALL_OW 69
16450: IN
16451: PUSH
16452: LD_EXP 15
16456: NOT
16457: AND
16458: IFFALSE 16468
// firstConvoyDestroyed := true ;
16460: LD_ADDR_EXP 15
16464: PUSH
16465: LD_INT 1
16467: ST_TO_ADDR
// if un in usAttackers then
16468: LD_VAR 0 1
16472: PUSH
16473: LD_EXP 42
16477: IN
16478: IFFALSE 16496
// usAttackers := usAttackers diff un ;
16480: LD_ADDR_EXP 42
16484: PUSH
16485: LD_EXP 42
16489: PUSH
16490: LD_VAR 0 1
16494: DIFF
16495: ST_TO_ADDR
// end ;
16496: PPOPN 1
16498: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
16499: LD_VAR 0 2
16503: PUSH
16504: LD_EXP 33
16508: EQUAL
16509: PUSH
16510: LD_EXP 21
16514: AND
16515: IFFALSE 16550
// begin Video ( true ) ;
16517: LD_INT 1
16519: PPUSH
16520: CALL 949 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
16524: LD_EXP 33
16528: PPUSH
16529: LD_INT 11
16531: PPUSH
16532: CALL_OW 120
// wait ( 0 0$1 ) ;
16536: LD_INT 35
16538: PPUSH
16539: CALL_OW 67
// Video ( false ) ;
16543: LD_INT 0
16545: PPUSH
16546: CALL 949 0 1
// end ; end ;
16550: PPOPN 2
16552: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
16553: LD_VAR 0 2
16557: PUSH
16558: LD_EXP 23
16562: EQUAL
16563: PUSH
16564: LD_VAR 0 1
16568: PUSH
16569: LD_INT 11
16571: EQUAL
16572: AND
16573: PUSH
16574: LD_EXP 21
16578: AND
16579: IFFALSE 16585
// IbrahimQuery ;
16581: CALL 14957 0 0
// end ;
16585: PPOPN 2
16587: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin if oldId in usAttackers then
16588: LD_VAR 0 2
16592: PUSH
16593: LD_EXP 42
16597: IN
16598: IFFALSE 16616
// usAttackers := usAttackers diff oldId ;
16600: LD_ADDR_EXP 42
16604: PUSH
16605: LD_EXP 42
16609: PUSH
16610: LD_VAR 0 2
16614: DIFF
16615: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
16616: LD_VAR 0 3
16620: PUSH
16621: LD_INT 4
16623: EQUAL
16624: PUSH
16625: LD_EXP 15
16629: NOT
16630: AND
16631: IFFALSE 16641
// firstConvoyDestroyed := true ;
16633: LD_ADDR_EXP 15
16637: PUSH
16638: LD_INT 1
16640: ST_TO_ADDR
// if GetWeapon ( oldId ) = us_cargo_bay and GetCargo ( oldId , mat_cans ) = 0 then
16641: LD_VAR 0 2
16645: PPUSH
16646: CALL_OW 264
16650: PUSH
16651: LD_INT 12
16653: EQUAL
16654: PUSH
16655: LD_VAR 0 2
16659: PPUSH
16660: LD_INT 1
16662: PPUSH
16663: CALL_OW 289
16667: PUSH
16668: LD_INT 0
16670: EQUAL
16671: AND
16672: IFFALSE 16678
// EmptyCargoDialog ;
16674: CALL 13806 0 0
// end ;
16678: PPOPN 4
16680: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
16681: LD_VAR 0 1
16685: PUSH
16686: LD_INT 2
16688: EQUAL
16689: PUSH
16690: LD_VAR 0 2
16694: PUSH
16695: LD_INT 5
16697: EQUAL
16698: AND
16699: IFFALSE 16708
// YouLost ( Attack ) ;
16701: LD_STRING Attack
16703: PPUSH
16704: CALL_OW 104
// end ;
16708: PPOPN 2
16710: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 then
16711: LD_VAR 0 1
16715: PPUSH
16716: CALL_OW 255
16720: PUSH
16721: LD_INT 1
16723: EQUAL
16724: IFFALSE 16858
// begin if GetBType ( b ) = b_lab then
16726: LD_VAR 0 1
16730: PPUSH
16731: CALL_OW 266
16735: PUSH
16736: LD_INT 6
16738: EQUAL
16739: IFFALSE 16779
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
16741: LD_EXP 39
16745: PPUSH
16746: LD_INT 25
16748: PUSH
16749: LD_INT 4
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PPUSH
16756: CALL_OW 72
16760: PPUSH
16761: LD_VAR 0 1
16765: PPUSH
16766: CALL_OW 120
// AmLabResearch ( b ) ;
16770: LD_VAR 0 1
16774: PPUSH
16775: CALL 5523 0 1
// end ; if GetBType ( b ) = b_armoury then
16779: LD_VAR 0 1
16783: PPUSH
16784: CALL_OW 266
16788: PUSH
16789: LD_INT 4
16791: EQUAL
16792: IFFALSE 16840
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
16794: LD_EXP 39
16798: PPUSH
16799: LD_INT 25
16801: PUSH
16802: LD_INT 1
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PUSH
16809: LD_INT 3
16811: PUSH
16812: LD_INT 54
16814: PUSH
16815: EMPTY
16816: LIST
16817: PUSH
16818: EMPTY
16819: LIST
16820: LIST
16821: PUSH
16822: EMPTY
16823: LIST
16824: LIST
16825: PPUSH
16826: CALL_OW 72
16830: PPUSH
16831: LD_VAR 0 1
16835: PPUSH
16836: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
16840: LD_ADDR_EXP 41
16844: PUSH
16845: LD_EXP 41
16849: PPUSH
16850: LD_INT 1
16852: PPUSH
16853: CALL_OW 3
16857: ST_TO_ADDR
// end ; end ;
16858: PPOPN 1
16860: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
16861: LD_VAR 0 1
16865: PPUSH
16866: CALL_OW 255
16870: PUSH
16871: LD_INT 2
16873: EQUAL
16874: IFFALSE 16890
// vehCounter := vehCounter + 1 ;
16876: LD_ADDR_EXP 18
16880: PUSH
16881: LD_EXP 18
16885: PUSH
16886: LD_INT 1
16888: PLUS
16889: ST_TO_ADDR
// end ;
16890: PPOPN 2
16892: END
// on SailEvent ( event ) do begin if event = eventAttack then
16893: LD_VAR 0 1
16897: PUSH
16898: LD_EXP 20
16902: EQUAL
16903: IFFALSE 16909
// AmericanAttack ;
16905: CALL 6811 0 0
// end ; end_of_file
16909: PPOPN 1
16911: END
// every 0 0$40 + 0 0$10 trigger tick <= [ 3 3$00 , 2 2$00 , 1 1$30 ] [ Difficulty ] do
16912: LD_OWVAR 1
16916: PUSH
16917: LD_INT 6300
16919: PUSH
16920: LD_INT 4200
16922: PUSH
16923: LD_INT 3150
16925: PUSH
16926: EMPTY
16927: LIST
16928: LIST
16929: LIST
16930: PUSH
16931: LD_OWVAR 67
16935: ARRAY
16936: LESSEQUAL
16937: IFFALSE 16964
16939: GO 16941
16941: DISABLE
// begin enable ;
16942: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
16943: LD_INT 1
16945: PPUSH
16946: LD_INT 5
16948: PPUSH
16949: CALL_OW 12
16953: PPUSH
16954: LD_INT 9
16956: PPUSH
16957: LD_INT 1
16959: PPUSH
16960: CALL_OW 55
// end ;
16964: END
// every 1 1$30 + 0 0$20 trigger americanBaseCaptured and tick <= [ 25 25$00 , 20 20$00 , 18 18$00 ] [ Difficulty ] do
16965: LD_EXP 6
16969: PUSH
16970: LD_OWVAR 1
16974: PUSH
16975: LD_INT 52500
16977: PUSH
16978: LD_INT 42000
16980: PUSH
16981: LD_INT 37800
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: LIST
16988: PUSH
16989: LD_OWVAR 67
16993: ARRAY
16994: LESSEQUAL
16995: AND
16996: IFFALSE 17023
16998: GO 17000
17000: DISABLE
// begin enable ;
17001: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
17002: LD_INT 1
17004: PPUSH
17005: LD_INT 5
17007: PPUSH
17008: CALL_OW 12
17012: PPUSH
17013: LD_INT 9
17015: PPUSH
17016: LD_INT 1
17018: PPUSH
17019: CALL_OW 55
// end ; end_of_file
17023: END
// every 0 0$1 trigger not retreatAllowed and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
17024: LD_EXP 10
17028: NOT
17029: PUSH
17030: LD_EXP 4
17034: AND
17035: PUSH
17036: LD_EXP 12
17040: PUSH
17041: LD_EXP 13
17045: LESSEQUAL
17046: AND
17047: IFFALSE 17127
17049: GO 17051
17051: DISABLE
// begin enable ;
17052: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
17053: LD_ADDR_OWVAR 47
17057: PUSH
17058: LD_STRING #X103-1
17060: PUSH
17061: LD_EXP 12
17065: PUSH
17066: LD_EXP 13
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: LIST
17075: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
17076: LD_ADDR_EXP 12
17080: PUSH
17081: LD_INT 5
17083: PPUSH
17084: CALL_OW 274
17088: PPUSH
17089: LD_INT 1
17091: PPUSH
17092: CALL_OW 275
17096: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
17097: LD_INT 10
17099: PPUSH
17100: LD_INT 1
17102: PPUSH
17103: CALL_OW 287
17107: PUSH
17108: LD_INT 0
17110: EQUAL
17111: IFFALSE 17127
// farmerCratesCounter := farmerCratesCounter - 0 0$1 ;
17113: LD_ADDR_EXP 14
17117: PUSH
17118: LD_EXP 14
17122: PUSH
17123: LD_INT 35
17125: MINUS
17126: ST_TO_ADDR
// end ; end_of_file
17127: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
17128: GO 17130
17130: DISABLE
// begin ru_radar := 98 ;
17131: LD_ADDR_EXP 43
17135: PUSH
17136: LD_INT 98
17138: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
17139: LD_ADDR_EXP 44
17143: PUSH
17144: LD_INT 89
17146: ST_TO_ADDR
// us_hack := 99 ;
17147: LD_ADDR_EXP 45
17151: PUSH
17152: LD_INT 99
17154: ST_TO_ADDR
// us_artillery := 97 ;
17155: LD_ADDR_EXP 46
17159: PUSH
17160: LD_INT 97
17162: ST_TO_ADDR
// ar_bio_bomb := 91 ;
17163: LD_ADDR_EXP 47
17167: PUSH
17168: LD_INT 91
17170: ST_TO_ADDR
// tech_Artillery := 80 ;
17171: LD_ADDR_EXP 48
17175: PUSH
17176: LD_INT 80
17178: ST_TO_ADDR
// tech_RadMat := 81 ;
17179: LD_ADDR_EXP 49
17183: PUSH
17184: LD_INT 81
17186: ST_TO_ADDR
// tech_BasicTools := 82 ;
17187: LD_ADDR_EXP 50
17191: PUSH
17192: LD_INT 82
17194: ST_TO_ADDR
// tech_Cargo := 83 ;
17195: LD_ADDR_EXP 51
17199: PUSH
17200: LD_INT 83
17202: ST_TO_ADDR
// tech_Track := 84 ;
17203: LD_ADDR_EXP 52
17207: PUSH
17208: LD_INT 84
17210: ST_TO_ADDR
// tech_Crane := 85 ;
17211: LD_ADDR_EXP 53
17215: PUSH
17216: LD_INT 85
17218: ST_TO_ADDR
// tech_Bulldozer := 86 ;
17219: LD_ADDR_EXP 54
17223: PUSH
17224: LD_INT 86
17226: ST_TO_ADDR
// tech_Hovercraft := 87 ;
17227: LD_ADDR_EXP 55
17231: PUSH
17232: LD_INT 87
17234: ST_TO_ADDR
// end ;
17235: END
