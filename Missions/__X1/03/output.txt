// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 38 0 0
// PrepareNature ;
   8: CALL 649 0 0
// PrepareArabian ;
  12: CALL 1964 0 0
// PrepareAmerican ;
  16: CALL 4968 0 0
// if debug then
  20: LD_EXP 1
  24: IFFALSE 33
// FogOff ( 2 ) ;
  26: LD_INT 2
  28: PPUSH
  29: CALL_OW 344
// Action ;
  33: CALL 9629 0 0
// end ;
  37: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := false ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 0
  48: ST_TO_ADDR
// prefix := 02_ ;
  49: LD_ADDR_EXP 2
  53: PUSH
  54: LD_STRING 02_
  56: ST_TO_ADDR
// eventAttack := 1 ;
  57: LD_ADDR_EXP 20
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// deadCounter := 0 ;
  65: LD_ADDR_EXP 8
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// gameStarted := false ;
  73: LD_ADDR_EXP 3
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// farmerBaseReady := false ;
  81: LD_ADDR_EXP 4
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// americanBaseSpoted := false ;
  89: LD_ADDR_EXP 5
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// americanBaseCaptured := false ;
  97: LD_ADDR_EXP 6
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// americanHasEscaped := false ;
 105: LD_ADDR_EXP 7
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// workshopBuilded := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// retreatAllowed := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// allowConvoys := false ;
 129: LD_ADDR_EXP 11
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// farmerCrates := 0 ;
 137: LD_ADDR_EXP 12
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 145: LD_ADDR_EXP 13
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 153: LD_ADDR_EXP 14
 157: PUSH
 158: LD_INT 63000
 160: PUSH
 161: LD_INT 52500
 163: PUSH
 164: LD_INT 46200
 166: PUSH
 167: EMPTY
 168: LIST
 169: LIST
 170: LIST
 171: PUSH
 172: LD_OWVAR 67
 176: ARRAY
 177: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 178: LD_ADDR_EXP 15
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// attackWave := 1 ;
 186: LD_ADDR_EXP 16
 190: PUSH
 191: LD_INT 1
 193: ST_TO_ADDR
// omarCargoCounter := [ 6 , 8 , 10 ] [ Difficulty ] ;
 194: LD_ADDR_EXP 17
 198: PUSH
 199: LD_INT 6
 201: PUSH
 202: LD_INT 8
 204: PUSH
 205: LD_INT 10
 207: PUSH
 208: EMPTY
 209: LIST
 210: LIST
 211: LIST
 212: PUSH
 213: LD_OWVAR 67
 217: ARRAY
 218: ST_TO_ADDR
// vehCounter := 0 ;
 219: LD_ADDR_EXP 18
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// convoyCounter := 0 ;
 227: LD_ADDR_EXP 19
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// ibrahimInDepot := false ;
 235: LD_ADDR_EXP 21
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// ibrahimIsFree := false ;
 243: LD_ADDR_EXP 22
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// maxConvoys := [ 16 , 15 , 14 ] [ Difficulty ] ;
 251: LD_ADDR_EXP 23
 255: PUSH
 256: LD_INT 16
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 14
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: LIST
 269: PUSH
 270: LD_OWVAR 67
 274: ARRAY
 275: ST_TO_ADDR
// end ; end_of_file
 276: LD_VAR 0 1
 280: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 281: LD_INT 0
 283: PPUSH
 284: PPUSH
// if exist_mode then
 285: LD_VAR 0 2
 289: IFFALSE 314
// unit := CreateCharacter ( prefix & ident ) else
 291: LD_ADDR_VAR 0 5
 295: PUSH
 296: LD_VAR 0 3
 300: PUSH
 301: LD_VAR 0 1
 305: STR
 306: PPUSH
 307: CALL_OW 34
 311: ST_TO_ADDR
 312: GO 329
// unit := NewCharacter ( ident ) ;
 314: LD_ADDR_VAR 0 5
 318: PUSH
 319: LD_VAR 0 1
 323: PPUSH
 324: CALL_OW 25
 328: ST_TO_ADDR
// result := unit ;
 329: LD_ADDR_VAR 0 4
 333: PUSH
 334: LD_VAR 0 5
 338: ST_TO_ADDR
// end ;
 339: LD_VAR 0 4
 343: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 344: LD_INT 0
 346: PPUSH
// uc_side := side ;
 347: LD_ADDR_OWVAR 20
 351: PUSH
 352: LD_VAR 0 1
 356: ST_TO_ADDR
// uc_nation := nation ;
 357: LD_ADDR_OWVAR 21
 361: PUSH
 362: LD_VAR 0 2
 366: ST_TO_ADDR
// vc_chassis := chassis ;
 367: LD_ADDR_OWVAR 37
 371: PUSH
 372: LD_VAR 0 3
 376: ST_TO_ADDR
// vc_engine := engine ;
 377: LD_ADDR_OWVAR 39
 381: PUSH
 382: LD_VAR 0 4
 386: ST_TO_ADDR
// vc_control := control ;
 387: LD_ADDR_OWVAR 38
 391: PUSH
 392: LD_VAR 0 5
 396: ST_TO_ADDR
// vc_weapon := weapon ;
 397: LD_ADDR_OWVAR 40
 401: PUSH
 402: LD_VAR 0 6
 406: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 407: LD_ADDR_OWVAR 41
 411: PUSH
 412: LD_VAR 0 7
 416: ST_TO_ADDR
// result := CreateVehicle ;
 417: LD_ADDR_VAR 0 8
 421: PUSH
 422: CALL_OW 45
 426: ST_TO_ADDR
// end ;
 427: LD_VAR 0 8
 431: RET
// export function SayX ( units , ident ) ; var i ; begin
 432: LD_INT 0
 434: PPUSH
 435: PPUSH
// result := false ;
 436: LD_ADDR_VAR 0 3
 440: PUSH
 441: LD_INT 0
 443: ST_TO_ADDR
// if not units then
 444: LD_VAR 0 1
 448: NOT
 449: IFFALSE 453
// exit ;
 451: GO 507
// for i in units do
 453: LD_ADDR_VAR 0 4
 457: PUSH
 458: LD_VAR 0 1
 462: PUSH
 463: FOR_IN
 464: IFFALSE 505
// if IsOk ( i ) then
 466: LD_VAR 0 4
 470: PPUSH
 471: CALL_OW 302
 475: IFFALSE 503
// begin Say ( i , ident ) ;
 477: LD_VAR 0 4
 481: PPUSH
 482: LD_VAR 0 2
 486: PPUSH
 487: CALL_OW 88
// result := i ;
 491: LD_ADDR_VAR 0 3
 495: PUSH
 496: LD_VAR 0 4
 500: ST_TO_ADDR
// break ;
 501: GO 505
// end ;
 503: GO 463
 505: POP
 506: POP
// end ;
 507: LD_VAR 0 3
 511: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 512: LD_INT 0
 514: PPUSH
 515: PPUSH
// InitUc ;
 516: CALL_OW 18
// InitHc ;
 520: CALL_OW 19
// uc_side := 0 ;
 524: LD_ADDR_OWVAR 20
 528: PUSH
 529: LD_INT 0
 531: ST_TO_ADDR
// uc_nation := 0 ;
 532: LD_ADDR_OWVAR 21
 536: PUSH
 537: LD_INT 0
 539: ST_TO_ADDR
// for i = 1 to amount do
 540: LD_ADDR_VAR 0 4
 544: PUSH
 545: DOUBLE
 546: LD_INT 1
 548: DEC
 549: ST_TO_ADDR
 550: LD_VAR 0 2
 554: PUSH
 555: FOR_TO
 556: IFFALSE 638
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 558: LD_ADDR_OWVAR 29
 562: PUSH
 563: LD_INT 9
 565: PPUSH
 566: LD_INT 12
 568: PPUSH
 569: CALL_OW 12
 573: PUSH
 574: LD_INT 9
 576: PPUSH
 577: LD_INT 12
 579: PPUSH
 580: CALL_OW 12
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 589: LD_ADDR_OWVAR 35
 593: PUSH
 594: LD_INT 1
 596: NEG
 597: PPUSH
 598: LD_INT 1
 600: PPUSH
 601: CALL_OW 12
 605: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 606: LD_INT 0
 608: PPUSH
 609: LD_INT 12
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 619: CALL_OW 44
 623: PPUSH
 624: LD_VAR 0 1
 628: PPUSH
 629: LD_INT 0
 631: PPUSH
 632: CALL_OW 49
// end ;
 636: GO 555
 638: POP
 639: POP
// InitHc ;
 640: CALL_OW 19
// end ;
 644: LD_VAR 0 3
 648: RET
// export function PrepareNature ; var i ; begin
 649: LD_INT 0
 651: PPUSH
 652: PPUSH
// SpawnApeman ( forest , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
 653: LD_INT 2
 655: PPUSH
 656: LD_INT 5
 658: PUSH
 659: LD_INT 4
 661: PUSH
 662: LD_INT 4
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PPUSH
 676: CALL 512 0 2
// for i := 1 to 2 do
 680: LD_ADDR_VAR 0 2
 684: PUSH
 685: DOUBLE
 686: LD_INT 1
 688: DEC
 689: ST_TO_ADDR
 690: LD_INT 2
 692: PUSH
 693: FOR_TO
 694: IFFALSE 729
// begin hc_class := 21 ;
 696: LD_ADDR_OWVAR 28
 700: PUSH
 701: LD_INT 21
 703: ST_TO_ADDR
// hc_gallery :=  ;
 704: LD_ADDR_OWVAR 33
 708: PUSH
 709: LD_STRING 
 711: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 712: CALL_OW 44
 716: PPUSH
 717: LD_INT 2
 719: PPUSH
 720: LD_INT 0
 722: PPUSH
 723: CALL_OW 49
// end ;
 727: GO 693
 729: POP
 730: POP
// for i := 1 to 2 do
 731: LD_ADDR_VAR 0 2
 735: PUSH
 736: DOUBLE
 737: LD_INT 1
 739: DEC
 740: ST_TO_ADDR
 741: LD_INT 2
 743: PUSH
 744: FOR_TO
 745: IFFALSE 780
// begin hc_class := 18 ;
 747: LD_ADDR_OWVAR 28
 751: PUSH
 752: LD_INT 18
 754: ST_TO_ADDR
// hc_gallery :=  ;
 755: LD_ADDR_OWVAR 33
 759: PUSH
 760: LD_STRING 
 762: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 763: CALL_OW 44
 767: PPUSH
 768: LD_INT 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 49
// end ;
 778: GO 744
 780: POP
 781: POP
// for i := 1 to 2 do
 782: LD_ADDR_VAR 0 2
 786: PUSH
 787: DOUBLE
 788: LD_INT 1
 790: DEC
 791: ST_TO_ADDR
 792: LD_INT 2
 794: PUSH
 795: FOR_TO
 796: IFFALSE 831
// begin hc_class := 13 ;
 798: LD_ADDR_OWVAR 28
 802: PUSH
 803: LD_INT 13
 805: ST_TO_ADDR
// hc_gallery :=  ;
 806: LD_ADDR_OWVAR 33
 810: PUSH
 811: LD_STRING 
 813: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 814: CALL_OW 44
 818: PPUSH
 819: LD_INT 2
 821: PPUSH
 822: LD_INT 0
 824: PPUSH
 825: CALL_OW 49
// end ;
 829: GO 795
 831: POP
 832: POP
// end ;
 833: LD_VAR 0 1
 837: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 838: LD_INT 0
 840: PPUSH
 841: PPUSH
 842: PPUSH
// if not observer or not unit then
 843: LD_VAR 0 1
 847: NOT
 848: PUSH
 849: LD_VAR 0 2
 853: NOT
 854: OR
 855: IFFALSE 859
// exit ;
 857: GO 907
// if not See ( GetSide ( observer ) , unit ) then
 859: LD_VAR 0 1
 863: PPUSH
 864: CALL_OW 255
 868: PPUSH
 869: LD_VAR 0 2
 873: PPUSH
 874: CALL_OW 292
 878: NOT
 879: IFFALSE 883
// exit ;
 881: GO 907
// result := GetDistUnits ( observer , unit ) < 12 ;
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: LD_VAR 0 1
 892: PPUSH
 893: LD_VAR 0 2
 897: PPUSH
 898: CALL_OW 296
 902: PUSH
 903: LD_INT 12
 905: LESS
 906: ST_TO_ADDR
// end ;
 907: LD_VAR 0 3
 911: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 912: LD_INT 0
 914: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 915: LD_VAR 0 2
 919: PUSH
 920: LD_INT 1
 922: ARRAY
 923: PPUSH
 924: LD_VAR 0 2
 928: PUSH
 929: LD_INT 2
 931: ARRAY
 932: PPUSH
 933: CALL_OW 488
 937: PUSH
 938: LD_VAR 0 2
 942: PUSH
 943: LD_INT 1
 945: ARRAY
 946: PPUSH
 947: LD_VAR 0 2
 951: PUSH
 952: LD_INT 2
 954: ARRAY
 955: PPUSH
 956: CALL_OW 428
 960: PUSH
 961: LD_INT 0
 963: EQUAL
 964: AND
 965: IFFALSE 999
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 967: LD_VAR 0 1
 971: PPUSH
 972: LD_VAR 0 2
 976: PUSH
 977: LD_INT 1
 979: ARRAY
 980: PPUSH
 981: LD_VAR 0 2
 985: PUSH
 986: LD_INT 2
 988: ARRAY
 989: PPUSH
 990: LD_VAR 0 3
 994: PPUSH
 995: CALL_OW 48
// end ;
 999: LD_VAR 0 4
1003: RET
// export function Video ( mode ) ; begin
1004: LD_INT 0
1006: PPUSH
// ingame_video = mode ;
1007: LD_ADDR_OWVAR 52
1011: PUSH
1012: LD_VAR 0 1
1016: ST_TO_ADDR
// interface_hidden = mode ;
1017: LD_ADDR_OWVAR 54
1021: PUSH
1022: LD_VAR 0 1
1026: ST_TO_ADDR
// end ;
1027: LD_VAR 0 2
1031: RET
// export function ReverseArray ( array ) ; var i ; begin
1032: LD_INT 0
1034: PPUSH
1035: PPUSH
// if not array then
1036: LD_VAR 0 1
1040: NOT
1041: IFFALSE 1045
// exit ;
1043: GO 1103
// result := [ ] ;
1045: LD_ADDR_VAR 0 2
1049: PUSH
1050: EMPTY
1051: ST_TO_ADDR
// for i := 1 to array do
1052: LD_ADDR_VAR 0 3
1056: PUSH
1057: DOUBLE
1058: LD_INT 1
1060: DEC
1061: ST_TO_ADDR
1062: LD_VAR 0 1
1066: PUSH
1067: FOR_TO
1068: IFFALSE 1101
// result := Insert ( result , 1 , array [ i ] ) ;
1070: LD_ADDR_VAR 0 2
1074: PUSH
1075: LD_VAR 0 2
1079: PPUSH
1080: LD_INT 1
1082: PPUSH
1083: LD_VAR 0 1
1087: PUSH
1088: LD_VAR 0 3
1092: ARRAY
1093: PPUSH
1094: CALL_OW 2
1098: ST_TO_ADDR
1099: GO 1067
1101: POP
1102: POP
// end ;
1103: LD_VAR 0 2
1107: RET
// export function ComExit ( unit ) ; begin
1108: LD_INT 0
1110: PPUSH
// result := IsInUnit ( unit ) ;
1111: LD_ADDR_VAR 0 2
1115: PUSH
1116: LD_VAR 0 1
1120: PPUSH
1121: CALL_OW 310
1125: ST_TO_ADDR
// if not result then
1126: LD_VAR 0 2
1130: NOT
1131: IFFALSE 1135
// exit ;
1133: GO 1170
// if GetType ( result ) = unit_vehicle then
1135: LD_VAR 0 2
1139: PPUSH
1140: CALL_OW 247
1144: PUSH
1145: LD_INT 2
1147: EQUAL
1148: IFFALSE 1161
// ComExitVehicle ( unit ) else
1150: LD_VAR 0 1
1154: PPUSH
1155: CALL_OW 121
1159: GO 1170
// ComExitBuilding ( unit ) ;
1161: LD_VAR 0 1
1165: PPUSH
1166: CALL_OW 122
// end ;
1170: LD_VAR 0 2
1174: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1175: LD_INT 0
1177: PPUSH
1178: PPUSH
// if not side or not nation then
1179: LD_VAR 0 1
1183: NOT
1184: PUSH
1185: LD_VAR 0 2
1189: NOT
1190: OR
1191: IFFALSE 1195
// exit ;
1193: GO 1959
// case nation of nation_american :
1195: LD_VAR 0 2
1199: PUSH
1200: LD_INT 1
1202: DOUBLE
1203: EQUAL
1204: IFTRUE 1208
1206: GO 1422
1208: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1209: LD_ADDR_VAR 0 4
1213: PUSH
1214: LD_INT 35
1216: PUSH
1217: LD_INT 45
1219: PUSH
1220: LD_INT 46
1222: PUSH
1223: LD_INT 47
1225: PUSH
1226: LD_INT 82
1228: PUSH
1229: LD_INT 83
1231: PUSH
1232: LD_INT 84
1234: PUSH
1235: LD_INT 85
1237: PUSH
1238: LD_INT 86
1240: PUSH
1241: LD_INT 1
1243: PUSH
1244: LD_INT 2
1246: PUSH
1247: LD_INT 6
1249: PUSH
1250: LD_INT 15
1252: PUSH
1253: LD_INT 16
1255: PUSH
1256: LD_INT 7
1258: PUSH
1259: LD_INT 12
1261: PUSH
1262: LD_INT 13
1264: PUSH
1265: LD_INT 10
1267: PUSH
1268: LD_INT 14
1270: PUSH
1271: LD_INT 20
1273: PUSH
1274: LD_INT 21
1276: PUSH
1277: LD_INT 22
1279: PUSH
1280: LD_INT 25
1282: PUSH
1283: LD_INT 32
1285: PUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 36
1291: PUSH
1292: LD_INT 69
1294: PUSH
1295: LD_INT 39
1297: PUSH
1298: LD_INT 34
1300: PUSH
1301: LD_INT 40
1303: PUSH
1304: LD_INT 48
1306: PUSH
1307: LD_INT 49
1309: PUSH
1310: LD_INT 50
1312: PUSH
1313: LD_INT 51
1315: PUSH
1316: LD_INT 52
1318: PUSH
1319: LD_INT 53
1321: PUSH
1322: LD_INT 54
1324: PUSH
1325: LD_INT 55
1327: PUSH
1328: LD_INT 56
1330: PUSH
1331: LD_INT 57
1333: PUSH
1334: LD_INT 58
1336: PUSH
1337: LD_INT 59
1339: PUSH
1340: LD_INT 60
1342: PUSH
1343: LD_INT 61
1345: PUSH
1346: LD_INT 62
1348: PUSH
1349: LD_INT 80
1351: PUSH
1352: LD_INT 82
1354: PUSH
1355: LD_INT 83
1357: PUSH
1358: LD_INT 84
1360: PUSH
1361: LD_INT 85
1363: PUSH
1364: LD_INT 86
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: ST_TO_ADDR
1420: GO 1883
1422: LD_INT 2
1424: DOUBLE
1425: EQUAL
1426: IFTRUE 1430
1428: GO 1652
1430: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1431: LD_ADDR_VAR 0 4
1435: PUSH
1436: LD_INT 35
1438: PUSH
1439: LD_INT 45
1441: PUSH
1442: LD_INT 46
1444: PUSH
1445: LD_INT 47
1447: PUSH
1448: LD_INT 82
1450: PUSH
1451: LD_INT 83
1453: PUSH
1454: LD_INT 84
1456: PUSH
1457: LD_INT 85
1459: PUSH
1460: LD_INT 87
1462: PUSH
1463: LD_INT 70
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 11
1471: PUSH
1472: LD_INT 3
1474: PUSH
1475: LD_INT 4
1477: PUSH
1478: LD_INT 5
1480: PUSH
1481: LD_INT 6
1483: PUSH
1484: LD_INT 15
1486: PUSH
1487: LD_INT 18
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: LD_INT 17
1495: PUSH
1496: LD_INT 8
1498: PUSH
1499: LD_INT 20
1501: PUSH
1502: LD_INT 21
1504: PUSH
1505: LD_INT 22
1507: PUSH
1508: LD_INT 72
1510: PUSH
1511: LD_INT 26
1513: PUSH
1514: LD_INT 69
1516: PUSH
1517: LD_INT 39
1519: PUSH
1520: LD_INT 40
1522: PUSH
1523: LD_INT 41
1525: PUSH
1526: LD_INT 42
1528: PUSH
1529: LD_INT 43
1531: PUSH
1532: LD_INT 48
1534: PUSH
1535: LD_INT 49
1537: PUSH
1538: LD_INT 50
1540: PUSH
1541: LD_INT 51
1543: PUSH
1544: LD_INT 52
1546: PUSH
1547: LD_INT 53
1549: PUSH
1550: LD_INT 54
1552: PUSH
1553: LD_INT 55
1555: PUSH
1556: LD_INT 56
1558: PUSH
1559: LD_INT 60
1561: PUSH
1562: LD_INT 61
1564: PUSH
1565: LD_INT 62
1567: PUSH
1568: LD_INT 66
1570: PUSH
1571: LD_INT 67
1573: PUSH
1574: LD_INT 68
1576: PUSH
1577: LD_INT 81
1579: PUSH
1580: LD_INT 82
1582: PUSH
1583: LD_INT 83
1585: PUSH
1586: LD_INT 84
1588: PUSH
1589: LD_INT 85
1591: PUSH
1592: LD_INT 87
1594: PUSH
1595: EMPTY
1596: LIST
1597: LIST
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: LIST
1610: LIST
1611: LIST
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: LIST
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: ST_TO_ADDR
1650: GO 1883
1652: LD_INT 3
1654: DOUBLE
1655: EQUAL
1656: IFTRUE 1660
1658: GO 1882
1660: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1661: LD_ADDR_VAR 0 4
1665: PUSH
1666: LD_INT 46
1668: PUSH
1669: LD_INT 47
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 2
1677: PUSH
1678: LD_INT 82
1680: PUSH
1681: LD_INT 83
1683: PUSH
1684: LD_INT 84
1686: PUSH
1687: LD_INT 85
1689: PUSH
1690: LD_INT 86
1692: PUSH
1693: LD_INT 11
1695: PUSH
1696: LD_INT 9
1698: PUSH
1699: LD_INT 20
1701: PUSH
1702: LD_INT 19
1704: PUSH
1705: LD_INT 21
1707: PUSH
1708: LD_INT 24
1710: PUSH
1711: LD_INT 22
1713: PUSH
1714: LD_INT 25
1716: PUSH
1717: LD_INT 28
1719: PUSH
1720: LD_INT 29
1722: PUSH
1723: LD_INT 30
1725: PUSH
1726: LD_INT 31
1728: PUSH
1729: LD_INT 37
1731: PUSH
1732: LD_INT 38
1734: PUSH
1735: LD_INT 32
1737: PUSH
1738: LD_INT 27
1740: PUSH
1741: LD_INT 33
1743: PUSH
1744: LD_INT 69
1746: PUSH
1747: LD_INT 39
1749: PUSH
1750: LD_INT 34
1752: PUSH
1753: LD_INT 40
1755: PUSH
1756: LD_INT 71
1758: PUSH
1759: LD_INT 23
1761: PUSH
1762: LD_INT 44
1764: PUSH
1765: LD_INT 48
1767: PUSH
1768: LD_INT 49
1770: PUSH
1771: LD_INT 50
1773: PUSH
1774: LD_INT 51
1776: PUSH
1777: LD_INT 52
1779: PUSH
1780: LD_INT 53
1782: PUSH
1783: LD_INT 54
1785: PUSH
1786: LD_INT 55
1788: PUSH
1789: LD_INT 56
1791: PUSH
1792: LD_INT 57
1794: PUSH
1795: LD_INT 58
1797: PUSH
1798: LD_INT 59
1800: PUSH
1801: LD_INT 63
1803: PUSH
1804: LD_INT 64
1806: PUSH
1807: LD_INT 65
1809: PUSH
1810: LD_INT 82
1812: PUSH
1813: LD_INT 83
1815: PUSH
1816: LD_INT 84
1818: PUSH
1819: LD_INT 85
1821: PUSH
1822: LD_INT 86
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: ST_TO_ADDR
1880: GO 1883
1882: POP
// if state > - 1 and state < 3 then
1883: LD_VAR 0 3
1887: PUSH
1888: LD_INT 1
1890: NEG
1891: GREATER
1892: PUSH
1893: LD_VAR 0 3
1897: PUSH
1898: LD_INT 3
1900: LESS
1901: AND
1902: IFFALSE 1959
// for i in result do
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 4
1913: PUSH
1914: FOR_IN
1915: IFFALSE 1957
// if GetTech ( i , side ) <> state then
1917: LD_VAR 0 5
1921: PPUSH
1922: LD_VAR 0 1
1926: PPUSH
1927: CALL_OW 321
1931: PUSH
1932: LD_VAR 0 3
1936: NONEQUAL
1937: IFFALSE 1955
// result := result diff i ;
1939: LD_ADDR_VAR 0 4
1943: PUSH
1944: LD_VAR 0 4
1948: PUSH
1949: LD_VAR 0 5
1953: DIFF
1954: ST_TO_ADDR
1955: GO 1914
1957: POP
1958: POP
// end ; end_of_file
1959: LD_VAR 0 4
1963: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1964: LD_INT 0
1966: PPUSH
1967: PPUSH
1968: PPUSH
1969: PPUSH
// uc_side := 5 ;
1970: LD_ADDR_OWVAR 20
1974: PUSH
1975: LD_INT 5
1977: ST_TO_ADDR
// uc_nation := 2 ;
1978: LD_ADDR_OWVAR 21
1982: PUSH
1983: LD_INT 2
1985: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
1986: LD_INT 5
1988: PPUSH
1989: CALL_OW 274
1993: PPUSH
1994: LD_INT 1
1996: PPUSH
1997: LD_INT 45
1999: PPUSH
2000: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
2004: LD_ADDR_EXP 32
2008: PUSH
2009: LD_STRING Farmer
2011: PPUSH
2012: LD_INT 0
2014: PPUSH
2015: LD_STRING 
2017: PPUSH
2018: CALL 281 0 3
2022: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2023: LD_ADDR_EXP 33
2027: PUSH
2028: LD_STRING Omar
2030: PPUSH
2031: LD_INT 0
2033: PPUSH
2034: LD_STRING 
2036: PPUSH
2037: CALL 281 0 3
2041: ST_TO_ADDR
// omarSquad := [ ] ;
2042: LD_ADDR_EXP 36
2046: PUSH
2047: EMPTY
2048: ST_TO_ADDR
// heikeSquad := [ ] ;
2049: LD_ADDR_EXP 37
2053: PUSH
2054: EMPTY
2055: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2056: LD_ADDR_EXP 38
2060: PUSH
2061: EMPTY
2062: ST_TO_ADDR
// omarCargo := [ ] ;
2063: LD_ADDR_EXP 39
2067: PUSH
2068: EMPTY
2069: ST_TO_ADDR
// for i := 1 to 5 do
2070: LD_ADDR_VAR 0 2
2074: PUSH
2075: DOUBLE
2076: LD_INT 1
2078: DEC
2079: ST_TO_ADDR
2080: LD_INT 5
2082: PUSH
2083: FOR_TO
2084: IFFALSE 2242
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2086: LD_INT 0
2088: PPUSH
2089: LD_INT 1
2091: PUSH
2092: LD_INT 1
2094: PUSH
2095: LD_INT 2
2097: PUSH
2098: LD_INT 1
2100: PUSH
2101: LD_INT 1
2103: PUSH
2104: EMPTY
2105: LIST
2106: LIST
2107: LIST
2108: LIST
2109: LIST
2110: PUSH
2111: LD_VAR 0 2
2115: ARRAY
2116: PPUSH
2117: LD_INT 3
2119: PPUSH
2120: CALL_OW 380
// un := CreateHuman ;
2124: LD_ADDR_VAR 0 3
2128: PUSH
2129: CALL_OW 44
2133: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2134: LD_ADDR_EXP 36
2138: PUSH
2139: LD_EXP 36
2143: PUSH
2144: LD_VAR 0 3
2148: UNION
2149: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2150: LD_VAR 0 3
2154: PPUSH
2155: LD_INT 87
2157: PUSH
2158: LD_INT 30
2160: PUSH
2161: EMPTY
2162: LIST
2163: LIST
2164: PUSH
2165: LD_INT 91
2167: PUSH
2168: LD_INT 32
2170: PUSH
2171: EMPTY
2172: LIST
2173: LIST
2174: PUSH
2175: LD_INT 82
2177: PUSH
2178: LD_INT 15
2180: PUSH
2181: EMPTY
2182: LIST
2183: LIST
2184: PUSH
2185: LD_INT 79
2187: PUSH
2188: LD_INT 14
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: PUSH
2195: LD_INT 82
2197: PUSH
2198: LD_INT 13
2200: PUSH
2201: EMPTY
2202: LIST
2203: LIST
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: LIST
2209: LIST
2210: LIST
2211: PUSH
2212: LD_VAR 0 2
2216: ARRAY
2217: PPUSH
2218: LD_INT 0
2220: PPUSH
2221: CALL 912 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2225: LD_VAR 0 3
2229: PPUSH
2230: LD_INT 93
2232: PPUSH
2233: LD_INT 21
2235: PPUSH
2236: CALL_OW 118
// end ;
2240: GO 2083
2242: POP
2243: POP
// uc_side := 2 ;
2244: LD_ADDR_OWVAR 20
2248: PUSH
2249: LD_INT 2
2251: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2252: LD_ADDR_EXP 24
2256: PUSH
2257: LD_STRING Heike
2259: PPUSH
2260: LD_EXP 1
2264: NOT
2265: PPUSH
2266: LD_EXP 2
2270: PPUSH
2271: CALL 281 0 3
2275: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2276: LD_ADDR_EXP 28
2280: PUSH
2281: LD_STRING Aviradze
2283: PPUSH
2284: LD_EXP 1
2288: NOT
2289: PPUSH
2290: LD_EXP 2
2294: PPUSH
2295: CALL 281 0 3
2299: ST_TO_ADDR
// tmp := [ ] ;
2300: LD_ADDR_VAR 0 4
2304: PUSH
2305: EMPTY
2306: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2307: LD_ADDR_EXP 25
2311: PUSH
2312: LD_STRING Givi
2314: PPUSH
2315: LD_EXP 1
2319: NOT
2320: PPUSH
2321: LD_EXP 2
2325: PPUSH
2326: CALL 281 0 3
2330: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2331: LD_ADDR_EXP 26
2335: PUSH
2336: LD_STRING Mike
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_EXP 2
2349: PPUSH
2350: CALL 281 0 3
2354: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2355: LD_ADDR_EXP 27
2359: PUSH
2360: LD_STRING Kamil
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_EXP 2
2373: PPUSH
2374: CALL 281 0 3
2378: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2379: LD_ADDR_EXP 29
2383: PUSH
2384: LD_STRING Kaia
2386: PPUSH
2387: LD_EXP 1
2391: NOT
2392: PPUSH
2393: LD_EXP 2
2397: PPUSH
2398: CALL 281 0 3
2402: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2403: LD_ADDR_EXP 30
2407: PUSH
2408: LD_STRING Sophia
2410: PPUSH
2411: LD_EXP 1
2415: NOT
2416: PPUSH
2417: LD_EXP 2
2421: PPUSH
2422: CALL 281 0 3
2426: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2427: LD_ADDR_EXP 31
2431: PUSH
2432: LD_STRING Markov
2434: PPUSH
2435: LD_EXP 1
2439: NOT
2440: PPUSH
2441: LD_EXP 2
2445: PPUSH
2446: CALL 281 0 3
2450: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2451: LD_ADDR_EXP 38
2455: PUSH
2456: LD_STRING 02_others
2458: PPUSH
2459: CALL_OW 31
2463: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2464: LD_ADDR_VAR 0 4
2468: PUSH
2469: LD_EXP 26
2473: PUSH
2474: LD_EXP 27
2478: PUSH
2479: LD_EXP 29
2483: PUSH
2484: LD_EXP 30
2488: PUSH
2489: LD_EXP 31
2493: PUSH
2494: LD_EXP 25
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: LIST
2503: LIST
2504: LIST
2505: LIST
2506: PUSH
2507: LD_EXP 38
2511: ADD
2512: PUSH
2513: LD_INT 0
2515: DIFF
2516: ST_TO_ADDR
// heikeSquad := tmp ;
2517: LD_ADDR_EXP 37
2521: PUSH
2522: LD_VAR 0 4
2526: ST_TO_ADDR
// uc_nation := 0 ;
2527: LD_ADDR_OWVAR 21
2531: PUSH
2532: LD_INT 0
2534: ST_TO_ADDR
// hc_class := class_apeman ;
2535: LD_ADDR_OWVAR 28
2539: PUSH
2540: LD_INT 12
2542: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
2543: LD_ADDR_OWVAR 31
2547: PUSH
2548: LD_INT 0
2550: PUSH
2551: LD_INT 0
2553: PUSH
2554: LD_INT 0
2556: PUSH
2557: LD_INT 0
2559: PUSH
2560: EMPTY
2561: LIST
2562: LIST
2563: LIST
2564: LIST
2565: ST_TO_ADDR
// hc_gallery :=  ;
2566: LD_ADDR_OWVAR 33
2570: PUSH
2571: LD_STRING 
2573: ST_TO_ADDR
// hc_name :=  ;
2574: LD_ADDR_OWVAR 26
2578: PUSH
2579: LD_STRING 
2581: ST_TO_ADDR
// tmp := tmp union CreateHuman ;
2582: LD_ADDR_VAR 0 4
2586: PUSH
2587: LD_VAR 0 4
2591: PUSH
2592: CALL_OW 44
2596: UNION
2597: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2598: LD_EXP 24
2602: PPUSH
2603: LD_INT 92
2605: PPUSH
2606: LD_INT 17
2608: PPUSH
2609: LD_INT 0
2611: PPUSH
2612: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2616: LD_EXP 32
2620: PPUSH
2621: LD_INT 95
2623: PPUSH
2624: LD_INT 19
2626: PPUSH
2627: LD_INT 0
2629: PPUSH
2630: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2634: LD_EXP 33
2638: PPUSH
2639: LD_INT 89
2641: PPUSH
2642: LD_INT 25
2644: PPUSH
2645: LD_INT 0
2647: PPUSH
2648: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2652: LD_EXP 28
2656: PPUSH
2657: LD_INT 92
2659: PPUSH
2660: LD_INT 27
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2670: LD_EXP 33
2674: PPUSH
2675: LD_EXP 28
2679: PPUSH
2680: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2684: LD_EXP 28
2688: PPUSH
2689: LD_EXP 33
2693: PPUSH
2694: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2698: LD_EXP 24
2702: PUSH
2703: LD_EXP 32
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PPUSH
2712: LD_EXP 33
2716: PPUSH
2717: CALL_OW 119
// if tmp then
2721: LD_VAR 0 4
2725: IFFALSE 2779
// for i in tmp do
2727: LD_ADDR_VAR 0 2
2731: PUSH
2732: LD_VAR 0 4
2736: PUSH
2737: FOR_IN
2738: IFFALSE 2777
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2740: LD_VAR 0 2
2744: PPUSH
2745: LD_INT 94
2747: PPUSH
2748: LD_INT 14
2750: PPUSH
2751: LD_INT 4
2753: PPUSH
2754: LD_INT 0
2756: PPUSH
2757: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2761: LD_VAR 0 2
2765: PPUSH
2766: LD_EXP 24
2770: PPUSH
2771: CALL_OW 119
// end ;
2775: GO 2737
2777: POP
2778: POP
// farmerSquad := [ ] ;
2779: LD_ADDR_EXP 35
2783: PUSH
2784: EMPTY
2785: ST_TO_ADDR
// uc_side := 5 ;
2786: LD_ADDR_OWVAR 20
2790: PUSH
2791: LD_INT 5
2793: ST_TO_ADDR
// uc_nation := 2 ;
2794: LD_ADDR_OWVAR 21
2798: PUSH
2799: LD_INT 2
2801: ST_TO_ADDR
// for i := 1 to 4 do
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: DOUBLE
2808: LD_INT 1
2810: DEC
2811: ST_TO_ADDR
2812: LD_INT 4
2814: PUSH
2815: FOR_TO
2816: IFFALSE 2894
// begin PrepareHuman ( false , 1 , 2 ) ;
2818: LD_INT 0
2820: PPUSH
2821: LD_INT 1
2823: PPUSH
2824: LD_INT 2
2826: PPUSH
2827: CALL_OW 380
// un := CreateHuman ;
2831: LD_ADDR_VAR 0 3
2835: PUSH
2836: CALL_OW 44
2840: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2841: LD_VAR 0 3
2845: PPUSH
2846: LD_INT 102
2848: PPUSH
2849: LD_INT 27
2851: PPUSH
2852: LD_INT 4
2854: PPUSH
2855: LD_INT 0
2857: PPUSH
2858: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2862: LD_ADDR_EXP 35
2866: PUSH
2867: LD_EXP 35
2871: PUSH
2872: LD_VAR 0 3
2876: UNION
2877: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2878: LD_VAR 0 3
2882: PPUSH
2883: LD_EXP 33
2887: PPUSH
2888: CALL_OW 119
// end ;
2892: GO 2815
2894: POP
2895: POP
// for i := 1 to 2 do
2896: LD_ADDR_VAR 0 2
2900: PUSH
2901: DOUBLE
2902: LD_INT 1
2904: DEC
2905: ST_TO_ADDR
2906: LD_INT 2
2908: PUSH
2909: FOR_TO
2910: IFFALSE 2988
// begin PrepareHuman ( false , 2 , 2 ) ;
2912: LD_INT 0
2914: PPUSH
2915: LD_INT 2
2917: PPUSH
2918: LD_INT 2
2920: PPUSH
2921: CALL_OW 380
// un := CreateHuman ;
2925: LD_ADDR_VAR 0 3
2929: PUSH
2930: CALL_OW 44
2934: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2935: LD_VAR 0 3
2939: PPUSH
2940: LD_INT 108
2942: PPUSH
2943: LD_INT 62
2945: PPUSH
2946: LD_INT 2
2948: PPUSH
2949: LD_INT 0
2951: PPUSH
2952: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2956: LD_ADDR_EXP 35
2960: PUSH
2961: LD_EXP 35
2965: PUSH
2966: LD_VAR 0 3
2970: UNION
2971: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2972: LD_VAR 0 3
2976: PPUSH
2977: LD_EXP 33
2981: PPUSH
2982: CALL_OW 119
// end ;
2986: GO 2909
2988: POP
2989: POP
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
2990: LD_INT 109
2992: PPUSH
2993: LD_INT 63
2995: PPUSH
2996: LD_INT 2
2998: PPUSH
2999: LD_INT 15
3001: NEG
3002: PPUSH
3003: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
3007: LD_INT 109
3009: PPUSH
3010: LD_INT 63
3012: PPUSH
3013: LD_INT 2
3015: PPUSH
3016: CALL_OW 331
// end ;
3020: LD_VAR 0 1
3024: RET
// export function PrepareIbrahim ( x , y ) ; begin
3025: LD_INT 0
3027: PPUSH
// uc_side := 6 ;
3028: LD_ADDR_OWVAR 20
3032: PUSH
3033: LD_INT 6
3035: ST_TO_ADDR
// uc_nation := 3 ;
3036: LD_ADDR_OWVAR 21
3040: PUSH
3041: LD_INT 3
3043: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3044: LD_ADDR_EXP 34
3048: PUSH
3049: LD_STRING IbrahimRu
3051: PPUSH
3052: LD_INT 0
3054: PPUSH
3055: LD_STRING 
3057: PPUSH
3058: CALL 281 0 3
3062: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3063: LD_EXP 34
3067: PPUSH
3068: LD_VAR 0 1
3072: PPUSH
3073: LD_VAR 0 2
3077: PPUSH
3078: LD_INT 8
3080: PPUSH
3081: LD_INT 1
3083: PPUSH
3084: CALL_OW 50
// end ;
3088: LD_VAR 0 3
3092: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3093: LD_EXP 33
3097: PUSH
3098: LD_EXP 36
3102: ADD
3103: PPUSH
3104: LD_INT 95
3106: PUSH
3107: LD_INT 3
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PPUSH
3114: CALL_OW 72
3118: IFFALSE 3174
3120: GO 3122
3122: DISABLE
3123: LD_INT 0
3125: PPUSH
// begin enable ;
3126: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3127: LD_ADDR_VAR 0 1
3131: PUSH
3132: LD_EXP 33
3136: PUSH
3137: LD_EXP 36
3141: ADD
3142: PPUSH
3143: LD_INT 95
3145: PUSH
3146: LD_INT 3
3148: PUSH
3149: EMPTY
3150: LIST
3151: LIST
3152: PPUSH
3153: CALL_OW 72
3157: PUSH
3158: FOR_IN
3159: IFFALSE 3172
// RemoveUnit ( i ) ;
3161: LD_VAR 0 1
3165: PPUSH
3166: CALL_OW 64
3170: GO 3158
3172: POP
3173: POP
// end ;
3174: PPOPN 1
3176: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3177: LD_EXP 3
3181: PUSH
3182: LD_EXP 32
3186: PPUSH
3187: LD_INT 4
3189: PPUSH
3190: CALL_OW 308
3194: AND
3195: IFFALSE 3978
3197: GO 3199
3199: DISABLE
3200: LD_INT 0
3202: PPUSH
3203: PPUSH
3204: PPUSH
3205: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3206: LD_EXP 32
3210: PPUSH
3211: LD_INT 110
3213: PPUSH
3214: LD_INT 60
3216: PPUSH
3217: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3221: LD_EXP 32
3225: PPUSH
3226: LD_INT 110
3228: PPUSH
3229: LD_INT 61
3231: PPUSH
3232: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3236: LD_ADDR_VAR 0 2
3240: PUSH
3241: LD_EXP 35
3245: PPUSH
3246: LD_INT 25
3248: PUSH
3249: LD_INT 1
3251: PUSH
3252: EMPTY
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL_OW 72
3260: ST_TO_ADDR
// if tmp then
3261: LD_VAR 0 2
3265: IFFALSE 3359
// begin for i := 1 to 2 do
3267: LD_ADDR_VAR 0 1
3271: PUSH
3272: DOUBLE
3273: LD_INT 1
3275: DEC
3276: ST_TO_ADDR
3277: LD_INT 2
3279: PUSH
3280: FOR_TO
3281: IFFALSE 3357
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3283: LD_VAR 0 2
3287: PUSH
3288: LD_VAR 0 1
3292: ARRAY
3293: PPUSH
3294: LD_INT 5
3296: PPUSH
3297: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3301: LD_VAR 0 2
3305: PUSH
3306: LD_VAR 0 1
3310: ARRAY
3311: PPUSH
3312: LD_INT 2
3314: PPUSH
3315: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3319: LD_VAR 0 2
3323: PUSH
3324: LD_VAR 0 1
3328: ARRAY
3329: PPUSH
3330: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3334: LD_VAR 0 2
3338: PUSH
3339: LD_VAR 0 1
3343: ARRAY
3344: PPUSH
3345: LD_INT 107
3347: PPUSH
3348: LD_INT 66
3350: PPUSH
3351: CALL_OW 171
// end ;
3355: GO 3280
3357: POP
3358: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3359: LD_ADDR_VAR 0 2
3363: PUSH
3364: LD_EXP 35
3368: PPUSH
3369: LD_INT 25
3371: PUSH
3372: LD_INT 2
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: PPUSH
3379: CALL_OW 72
3383: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3384: LD_INT 35
3386: PPUSH
3387: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3391: LD_ADDR_VAR 0 2
3395: PUSH
3396: LD_EXP 35
3400: PPUSH
3401: LD_INT 25
3403: PUSH
3404: LD_INT 2
3406: PUSH
3407: EMPTY
3408: LIST
3409: LIST
3410: PPUSH
3411: CALL_OW 72
3415: ST_TO_ADDR
// until tmp ;
3416: LD_VAR 0 2
3420: IFFALSE 3384
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3422: LD_VAR 0 2
3426: PPUSH
3427: LD_INT 31
3429: PPUSH
3430: LD_INT 102
3432: PPUSH
3433: LD_INT 69
3435: PPUSH
3436: LD_INT 2
3438: PPUSH
3439: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3443: LD_INT 35
3445: PPUSH
3446: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3450: LD_EXP 35
3454: PPUSH
3455: LD_INT 3
3457: PUSH
3458: LD_INT 60
3460: PUSH
3461: EMPTY
3462: LIST
3463: PUSH
3464: EMPTY
3465: LIST
3466: LIST
3467: PUSH
3468: LD_INT 25
3470: PUSH
3471: LD_INT 2
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: PUSH
3478: EMPTY
3479: LIST
3480: LIST
3481: PPUSH
3482: CALL_OW 72
3486: IFFALSE 3443
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3488: LD_ADDR_VAR 0 2
3492: PUSH
3493: LD_EXP 35
3497: PPUSH
3498: LD_INT 25
3500: PUSH
3501: LD_INT 2
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: PPUSH
3508: CALL_OW 72
3512: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3513: LD_VAR 0 2
3517: PPUSH
3518: LD_INT 4
3520: PPUSH
3521: LD_INT 116
3523: PPUSH
3524: LD_INT 70
3526: PPUSH
3527: LD_INT 5
3529: PPUSH
3530: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3534: LD_VAR 0 2
3538: PPUSH
3539: LD_INT 31
3541: PPUSH
3542: LD_INT 108
3544: PPUSH
3545: LD_INT 50
3547: PPUSH
3548: LD_INT 2
3550: PPUSH
3551: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3555: LD_INT 35
3557: PPUSH
3558: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3562: LD_INT 22
3564: PUSH
3565: LD_INT 5
3567: PUSH
3568: EMPTY
3569: LIST
3570: LIST
3571: PUSH
3572: LD_INT 30
3574: PUSH
3575: LD_INT 4
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 3
3584: PUSH
3585: LD_INT 57
3587: PUSH
3588: EMPTY
3589: LIST
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 69
3604: IFFALSE 3555
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3606: LD_ADDR_VAR 0 3
3610: PUSH
3611: LD_INT 22
3613: PUSH
3614: LD_INT 5
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PUSH
3621: LD_INT 30
3623: PUSH
3624: LD_INT 4
3626: PUSH
3627: EMPTY
3628: LIST
3629: LIST
3630: PUSH
3631: LD_INT 3
3633: PUSH
3634: LD_INT 57
3636: PUSH
3637: EMPTY
3638: LIST
3639: PUSH
3640: EMPTY
3641: LIST
3642: LIST
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: LIST
3648: PPUSH
3649: CALL_OW 69
3653: PUSH
3654: LD_INT 1
3656: ARRAY
3657: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3658: LD_ADDR_VAR 0 2
3662: PUSH
3663: LD_EXP 35
3667: PPUSH
3668: LD_INT 25
3670: PUSH
3671: LD_INT 1
3673: PUSH
3674: EMPTY
3675: LIST
3676: LIST
3677: PPUSH
3678: CALL_OW 72
3682: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3683: LD_VAR 0 2
3687: PPUSH
3688: LD_VAR 0 3
3692: PPUSH
3693: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3697: LD_INT 35
3699: PPUSH
3700: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3704: LD_INT 22
3706: PUSH
3707: LD_INT 5
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: LD_INT 30
3716: PUSH
3717: LD_INT 31
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PUSH
3724: LD_INT 3
3726: PUSH
3727: LD_INT 57
3729: PUSH
3730: EMPTY
3731: LIST
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: PPUSH
3742: CALL_OW 69
3746: PUSH
3747: LD_INT 2
3749: GREATEREQUAL
3750: IFFALSE 3697
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3752: LD_ADDR_VAR 0 2
3756: PUSH
3757: LD_EXP 35
3761: PPUSH
3762: LD_INT 25
3764: PUSH
3765: LD_INT 2
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PPUSH
3772: CALL_OW 72
3776: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3777: LD_VAR 0 2
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: PPUSH
3786: LD_INT 5
3788: PPUSH
3789: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3793: LD_VAR 0 2
3797: PUSH
3798: LD_INT 2
3800: ARRAY
3801: PUSH
3802: LD_VAR 0 2
3806: PUSH
3807: LD_INT 3
3809: ARRAY
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: LD_VAR 0 3
3819: PPUSH
3820: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3824: LD_VAR 0 2
3828: PUSH
3829: LD_INT 2
3831: ARRAY
3832: PUSH
3833: LD_VAR 0 2
3837: PUSH
3838: LD_INT 3
3840: ARRAY
3841: PUSH
3842: EMPTY
3843: LIST
3844: LIST
3845: PPUSH
3846: LD_INT 1
3848: PPUSH
3849: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3853: LD_VAR 0 2
3857: PUSH
3858: LD_INT 2
3860: ARRAY
3861: PUSH
3862: LD_VAR 0 2
3866: PUSH
3867: LD_INT 3
3869: ARRAY
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: PPUSH
3875: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3879: LD_ADDR_VAR 0 4
3883: PUSH
3884: LD_INT 22
3886: PUSH
3887: LD_INT 5
3889: PUSH
3890: EMPTY
3891: LIST
3892: LIST
3893: PUSH
3894: LD_INT 30
3896: PUSH
3897: LD_INT 31
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: PPUSH
3908: CALL_OW 69
3912: ST_TO_ADDR
// for i := 1 to 2 do
3913: LD_ADDR_VAR 0 1
3917: PUSH
3918: DOUBLE
3919: LD_INT 1
3921: DEC
3922: ST_TO_ADDR
3923: LD_INT 2
3925: PUSH
3926: FOR_TO
3927: IFFALSE 3961
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3929: LD_VAR 0 2
3933: PUSH
3934: LD_VAR 0 1
3938: PUSH
3939: LD_INT 1
3941: PLUS
3942: ARRAY
3943: PPUSH
3944: LD_VAR 0 4
3948: PUSH
3949: LD_VAR 0 1
3953: ARRAY
3954: PPUSH
3955: CALL_OW 180
3959: GO 3926
3961: POP
3962: POP
// wait ( 1 1$00 ) ;
3963: LD_INT 2100
3965: PPUSH
3966: CALL_OW 67
// farmerBaseReady := true ;
3970: LD_ADDR_EXP 4
3974: PUSH
3975: LD_INT 1
3977: ST_TO_ADDR
// end ;
3978: PPOPN 4
3980: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
3981: LD_EXP 4
3985: PUSH
3986: LD_EXP 10
3990: NOT
3991: AND
3992: IFFALSE 4514
3994: GO 3996
3996: DISABLE
3997: LD_INT 0
3999: PPUSH
4000: PPUSH
4001: PPUSH
4002: PPUSH
4003: PPUSH
// begin enable ;
4004: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
4005: LD_ADDR_VAR 0 3
4009: PUSH
4010: LD_EXP 35
4014: PPUSH
4015: LD_INT 25
4017: PUSH
4018: LD_INT 1
4020: PUSH
4021: EMPTY
4022: LIST
4023: LIST
4024: PPUSH
4025: CALL_OW 72
4029: PUSH
4030: LD_EXP 32
4034: ADD
4035: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4036: LD_ADDR_VAR 0 2
4040: PUSH
4041: LD_EXP 35
4045: PPUSH
4046: LD_INT 25
4048: PUSH
4049: LD_INT 2
4051: PUSH
4052: EMPTY
4053: LIST
4054: LIST
4055: PPUSH
4056: CALL_OW 72
4060: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4061: LD_ADDR_VAR 0 5
4065: PUSH
4066: LD_INT 22
4068: PUSH
4069: LD_INT 5
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: PUSH
4076: LD_INT 21
4078: PUSH
4079: LD_INT 3
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 3
4088: PUSH
4089: LD_INT 24
4091: PUSH
4092: LD_INT 1000
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: PUSH
4099: EMPTY
4100: LIST
4101: LIST
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: PPUSH
4108: CALL_OW 69
4112: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4113: LD_ADDR_VAR 0 4
4117: PUSH
4118: LD_INT 22
4120: PUSH
4121: LD_INT 5
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: PUSH
4128: LD_INT 30
4130: PUSH
4131: LD_INT 4
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: PPUSH
4142: CALL_OW 69
4146: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4147: LD_VAR 0 4
4151: PUSH
4152: LD_INT 1
4154: ARRAY
4155: PPUSH
4156: CALL_OW 302
4160: IFFALSE 4224
// for i in sol do
4162: LD_ADDR_VAR 0 1
4166: PUSH
4167: LD_VAR 0 3
4171: PUSH
4172: FOR_IN
4173: IFFALSE 4222
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4175: LD_VAR 0 1
4179: PPUSH
4180: CALL_OW 256
4184: PUSH
4185: LD_INT 999
4187: LESS
4188: PUSH
4189: LD_VAR 0 1
4193: PPUSH
4194: CALL_OW 310
4198: NOT
4199: AND
4200: IFFALSE 4220
// ComEnterUnit ( i , arm [ 1 ] ) ;
4202: LD_VAR 0 1
4206: PPUSH
4207: LD_VAR 0 4
4211: PUSH
4212: LD_INT 1
4214: ARRAY
4215: PPUSH
4216: CALL_OW 120
4220: GO 4172
4222: POP
4223: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4224: LD_VAR 0 2
4228: NOT
4229: PUSH
4230: LD_INT 22
4232: PUSH
4233: LD_INT 1
4235: PUSH
4236: EMPTY
4237: LIST
4238: LIST
4239: PUSH
4240: LD_INT 21
4242: PUSH
4243: LD_INT 1
4245: PUSH
4246: EMPTY
4247: LIST
4248: LIST
4249: PUSH
4250: EMPTY
4251: LIST
4252: LIST
4253: PPUSH
4254: CALL_OW 69
4258: NOT
4259: AND
4260: IFFALSE 4352
// begin uc_side := 5 ;
4262: LD_ADDR_OWVAR 20
4266: PUSH
4267: LD_INT 5
4269: ST_TO_ADDR
// uc_nation := 2 ;
4270: LD_ADDR_OWVAR 21
4274: PUSH
4275: LD_INT 2
4277: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4278: LD_INT 0
4280: PPUSH
4281: LD_INT 2
4283: PPUSH
4284: LD_INT 2
4286: PPUSH
4287: CALL_OW 380
// eng := CreateHuman ;
4291: LD_ADDR_VAR 0 2
4295: PUSH
4296: CALL_OW 44
4300: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4301: LD_VAR 0 2
4305: PPUSH
4306: LD_INT 102
4308: PPUSH
4309: LD_INT 8
4311: PPUSH
4312: LD_INT 0
4314: PPUSH
4315: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4319: LD_VAR 0 2
4323: PPUSH
4324: LD_INT 110
4326: PPUSH
4327: LD_INT 60
4329: PPUSH
4330: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4334: LD_ADDR_EXP 35
4338: PUSH
4339: LD_EXP 35
4343: PUSH
4344: LD_VAR 0 2
4348: UNION
4349: ST_TO_ADDR
// end else
4350: GO 4514
// begin for i in eng do
4352: LD_ADDR_VAR 0 1
4356: PUSH
4357: LD_VAR 0 2
4361: PUSH
4362: FOR_IN
4363: IFFALSE 4512
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4365: LD_INT 10
4367: PPUSH
4368: LD_INT 1
4370: PPUSH
4371: CALL_OW 287
4375: IFFALSE 4426
// begin if IsInUnit ( i ) then
4377: LD_VAR 0 1
4381: PPUSH
4382: CALL_OW 310
4386: IFFALSE 4397
// ComExitBuilding ( i ) ;
4388: LD_VAR 0 1
4392: PPUSH
4393: CALL_OW 122
// if not IsInArea ( i , collectFarmerArea ) then
4397: LD_VAR 0 1
4401: PPUSH
4402: LD_INT 10
4404: PPUSH
4405: CALL_OW 308
4409: NOT
4410: IFFALSE 4424
// AddComMoveToArea ( i , collectFarmerArea ) ;
4412: LD_VAR 0 1
4416: PPUSH
4417: LD_INT 10
4419: PPUSH
4420: CALL_OW 173
// end else
4424: GO 4510
// begin if damagedBuilding then
4426: LD_VAR 0 5
4430: IFFALSE 4474
// begin if IsInUnit ( i ) then
4432: LD_VAR 0 1
4436: PPUSH
4437: CALL_OW 310
4441: IFFALSE 4454
// ComExitBuilding ( i ) else
4443: LD_VAR 0 1
4447: PPUSH
4448: CALL_OW 122
4452: GO 4472
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4454: LD_VAR 0 1
4458: PPUSH
4459: LD_VAR 0 5
4463: PUSH
4464: LD_INT 1
4466: ARRAY
4467: PPUSH
4468: CALL_OW 130
// end else
4472: GO 4510
// if not IsInUnit ( i ) and not HasTask ( i ) then
4474: LD_VAR 0 1
4478: PPUSH
4479: CALL_OW 310
4483: NOT
4484: PUSH
4485: LD_VAR 0 1
4489: PPUSH
4490: CALL_OW 314
4494: NOT
4495: AND
4496: IFFALSE 4510
// ComEnterUnit ( i , arDepot ) ;
4498: LD_VAR 0 1
4502: PPUSH
4503: LD_INT 5
4505: PPUSH
4506: CALL_OW 120
// end ; end ;
4510: GO 4362
4512: POP
4513: POP
// end ; end ;
4514: PPOPN 5
4516: END
// export function StartCargoEvacuation ; begin
4517: LD_INT 0
4519: PPUSH
// while omarCargoCounter > 0 do
4520: LD_EXP 17
4524: PUSH
4525: LD_INT 0
4527: GREATER
4528: IFFALSE 4845
// begin wait ( 0 0$40 ) ;
4530: LD_INT 1400
4532: PPUSH
4533: CALL_OW 67
// omarCargo := PrepareCargo ;
4537: LD_ADDR_EXP 39
4541: PUSH
4542: CALL 4850 0 0
4546: ST_TO_ADDR
// SetTag ( omarCargo , 0 ) ;
4547: LD_EXP 39
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 109
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4559: LD_EXP 39
4563: PPUSH
4564: LD_INT 107
4566: PPUSH
4567: LD_INT 59
4569: PPUSH
4570: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4574: LD_INT 35
4576: PPUSH
4577: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4581: LD_EXP 39
4585: PPUSH
4586: LD_INT 107
4588: PPUSH
4589: LD_INT 59
4591: PPUSH
4592: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4596: LD_EXP 39
4600: PPUSH
4601: CALL_OW 302
4605: NOT
4606: PUSH
4607: LD_EXP 39
4611: PPUSH
4612: CALL_OW 301
4616: OR
4617: IFFALSE 4621
// continue ;
4619: GO 4574
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4621: LD_EXP 39
4625: PPUSH
4626: LD_INT 107
4628: PPUSH
4629: LD_INT 59
4631: PPUSH
4632: CALL_OW 307
4636: PUSH
4637: LD_EXP 39
4641: PPUSH
4642: LD_INT 5
4644: PPUSH
4645: CALL_OW 296
4649: PUSH
4650: LD_INT 6
4652: LESS
4653: OR
4654: IFFALSE 4574
// SetTag ( omarCargo , 1 ) ;
4656: LD_EXP 39
4660: PPUSH
4661: LD_INT 1
4663: PPUSH
4664: CALL_OW 109
// wait ( 0 0$05 ) ;
4668: LD_INT 175
4670: PPUSH
4671: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4675: LD_EXP 39
4679: PPUSH
4680: LD_INT 5
4682: PPUSH
4683: LD_INT 1
4685: PPUSH
4686: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4690: LD_EXP 39
4694: PPUSH
4695: LD_INT 103
4697: PPUSH
4698: LD_INT 9
4700: PPUSH
4701: CALL_OW 171
// wait ( 0 0$1 ) ;
4705: LD_INT 35
4707: PPUSH
4708: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
4712: LD_EXP 39
4716: PPUSH
4717: LD_INT 1
4719: PPUSH
4720: LD_INT 100
4722: PPUSH
4723: CALL_OW 290
// repeat wait ( 0 0$1 ) ;
4727: LD_INT 35
4729: PPUSH
4730: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4734: LD_EXP 39
4738: PPUSH
4739: LD_INT 103
4741: PPUSH
4742: LD_INT 9
4744: PPUSH
4745: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4749: LD_EXP 39
4753: PPUSH
4754: CALL_OW 302
4758: NOT
4759: PUSH
4760: LD_EXP 39
4764: PPUSH
4765: CALL_OW 301
4769: OR
4770: IFFALSE 4774
// continue ;
4772: GO 4727
// until ( IsAt ( omarCargo , 103 , 9 ) or IsInArea ( omarCargo , northRoad ) ) and GetTag ( omarCargo ) > 0 ;
4774: LD_EXP 39
4778: PPUSH
4779: LD_INT 103
4781: PPUSH
4782: LD_INT 9
4784: PPUSH
4785: CALL_OW 307
4789: PUSH
4790: LD_EXP 39
4794: PPUSH
4795: LD_INT 3
4797: PPUSH
4798: CALL_OW 308
4802: OR
4803: PUSH
4804: LD_EXP 39
4808: PPUSH
4809: CALL_OW 110
4813: PUSH
4814: LD_INT 0
4816: GREATER
4817: AND
4818: IFFALSE 4727
// RemoveUnit ( omarCargo ) ;
4820: LD_EXP 39
4824: PPUSH
4825: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4829: LD_ADDR_EXP 17
4833: PUSH
4834: LD_EXP 17
4838: PUSH
4839: LD_INT 1
4841: MINUS
4842: ST_TO_ADDR
// end ;
4843: GO 4520
// end ;
4845: LD_VAR 0 1
4849: RET
// export function PrepareCargo ; var un , veh ; begin
4850: LD_INT 0
4852: PPUSH
4853: PPUSH
4854: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4855: LD_ADDR_VAR 0 3
4859: PUSH
4860: LD_INT 5
4862: PPUSH
4863: LD_INT 2
4865: PPUSH
4866: LD_INT 13
4868: PPUSH
4869: LD_INT 1
4871: PPUSH
4872: LD_INT 1
4874: PPUSH
4875: LD_INT 32
4877: PPUSH
4878: LD_INT 80
4880: PPUSH
4881: CALL 344 0 7
4885: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4886: LD_VAR 0 3
4890: PPUSH
4891: LD_INT 4
4893: PPUSH
4894: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4898: LD_VAR 0 3
4902: PPUSH
4903: LD_INT 101
4905: PPUSH
4906: LD_INT 8
4908: PPUSH
4909: LD_INT 0
4911: PPUSH
4912: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4916: LD_INT 0
4918: PPUSH
4919: LD_INT 3
4921: PPUSH
4922: LD_INT 2
4924: PPUSH
4925: CALL_OW 380
// un := CreateHuman ;
4929: LD_ADDR_VAR 0 2
4933: PUSH
4934: CALL_OW 44
4938: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4939: LD_VAR 0 2
4943: PPUSH
4944: LD_VAR 0 3
4948: PPUSH
4949: CALL_OW 52
// result := veh ;
4953: LD_ADDR_VAR 0 1
4957: PUSH
4958: LD_VAR 0 3
4962: ST_TO_ADDR
// end ; end_of_file
4963: LD_VAR 0 1
4967: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
4968: LD_INT 0
4970: PPUSH
4971: PPUSH
4972: PPUSH
// usForces := [ ] ;
4973: LD_ADDR_EXP 40
4977: PUSH
4978: EMPTY
4979: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
4980: LD_ADDR_EXP 42
4984: PUSH
4985: LD_INT 6
4987: PUSH
4988: LD_INT 32
4990: PUSH
4991: LD_INT 27
4993: PUSH
4994: LD_INT 1
4996: PUSH
4997: EMPTY
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 4
5005: PUSH
5006: LD_INT 43
5008: PUSH
5009: LD_INT 24
5011: PUSH
5012: LD_INT 5
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: LIST
5019: LIST
5020: PUSH
5021: LD_INT 27
5023: PUSH
5024: LD_INT 29
5026: PUSH
5027: LD_INT 21
5029: PUSH
5030: LD_INT 0
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: LIST
5037: LIST
5038: PUSH
5039: EMPTY
5040: LIST
5041: LIST
5042: LIST
5043: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
5044: LD_INT 11
5046: PPUSH
5047: CALL_OW 274
5051: PPUSH
5052: LD_INT 1
5054: PPUSH
5055: LD_INT 150
5057: PUSH
5058: LD_INT 120
5060: PUSH
5061: LD_INT 100
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: LIST
5068: PUSH
5069: LD_OWVAR 67
5073: ARRAY
5074: PPUSH
5075: CALL_OW 277
// if Difficulty = 1 then
5079: LD_OWVAR 67
5083: PUSH
5084: LD_INT 1
5086: EQUAL
5087: IFFALSE 5096
// RemoveUnit ( hillBun ) ;
5089: LD_INT 14
5091: PPUSH
5092: CALL_OW 64
// uc_side := 1 ;
5096: LD_ADDR_OWVAR 20
5100: PUSH
5101: LD_INT 1
5103: ST_TO_ADDR
// uc_nation := 1 ;
5104: LD_ADDR_OWVAR 21
5108: PUSH
5109: LD_INT 1
5111: ST_TO_ADDR
// hc_gallery :=  ;
5112: LD_ADDR_OWVAR 33
5116: PUSH
5117: LD_STRING 
5119: ST_TO_ADDR
// hc_name :=  ;
5120: LD_ADDR_OWVAR 26
5124: PUSH
5125: LD_STRING 
5127: ST_TO_ADDR
// hc_importance := 0 ;
5128: LD_ADDR_OWVAR 32
5132: PUSH
5133: LD_INT 0
5135: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5136: LD_INT 1
5138: PPUSH
5139: LD_INT 1
5141: PPUSH
5142: LD_INT 3
5144: PPUSH
5145: CALL_OW 380
// usCommander := CreateHuman ;
5149: LD_ADDR_EXP 41
5153: PUSH
5154: CALL_OW 44
5158: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5159: LD_EXP 41
5163: PPUSH
5164: LD_INT 11
5166: PPUSH
5167: CALL_OW 52
// if hillBun then
5171: LD_INT 14
5173: IFFALSE 5255
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5175: LD_INT 0
5177: PPUSH
5178: LD_INT 1
5180: PPUSH
5181: LD_INT 1
5183: PUSH
5184: LD_INT 2
5186: PUSH
5187: LD_INT 3
5189: PUSH
5190: EMPTY
5191: LIST
5192: LIST
5193: LIST
5194: PUSH
5195: LD_OWVAR 67
5199: ARRAY
5200: PPUSH
5201: CALL_OW 380
// un := CreateHuman ;
5205: LD_ADDR_VAR 0 3
5209: PUSH
5210: CALL_OW 44
5214: ST_TO_ADDR
// usForces := usForces union un ;
5215: LD_ADDR_EXP 40
5219: PUSH
5220: LD_EXP 40
5224: PUSH
5225: LD_VAR 0 3
5229: UNION
5230: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5231: LD_VAR 0 3
5235: PPUSH
5236: LD_INT 1
5238: PPUSH
5239: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5243: LD_VAR 0 3
5247: PPUSH
5248: LD_INT 14
5250: PPUSH
5251: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5255: LD_ADDR_VAR 0 2
5259: PUSH
5260: DOUBLE
5261: LD_INT 1
5263: DEC
5264: ST_TO_ADDR
5265: LD_INT 2
5267: PUSH
5268: LD_INT 3
5270: PUSH
5271: LD_INT 4
5273: PUSH
5274: EMPTY
5275: LIST
5276: LIST
5277: LIST
5278: PUSH
5279: LD_OWVAR 67
5283: ARRAY
5284: PUSH
5285: FOR_TO
5286: IFFALSE 5428
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5288: LD_INT 0
5290: PPUSH
5291: LD_INT 1
5293: PPUSH
5294: LD_INT 1
5296: PUSH
5297: LD_INT 2
5299: PUSH
5300: LD_INT 3
5302: PUSH
5303: EMPTY
5304: LIST
5305: LIST
5306: LIST
5307: PUSH
5308: LD_OWVAR 67
5312: ARRAY
5313: PPUSH
5314: CALL_OW 380
// un := CreateHuman ;
5318: LD_ADDR_VAR 0 3
5322: PUSH
5323: CALL_OW 44
5327: ST_TO_ADDR
// usForces := usForces union un ;
5328: LD_ADDR_EXP 40
5332: PUSH
5333: LD_EXP 40
5337: PUSH
5338: LD_VAR 0 3
5342: UNION
5343: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5344: LD_VAR 0 3
5348: PPUSH
5349: LD_INT 39
5351: PPUSH
5352: LD_INT 24
5354: PPUSH
5355: LD_INT 4
5357: PPUSH
5358: LD_INT 0
5360: PPUSH
5361: CALL_OW 50
// if i < 3 then
5365: LD_VAR 0 2
5369: PUSH
5370: LD_INT 3
5372: LESS
5373: IFFALSE 5426
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5375: LD_VAR 0 3
5379: PPUSH
5380: LD_INT 22
5382: PUSH
5383: LD_INT 1
5385: PUSH
5386: EMPTY
5387: LIST
5388: LIST
5389: PUSH
5390: LD_INT 58
5392: PUSH
5393: EMPTY
5394: LIST
5395: PUSH
5396: LD_INT 30
5398: PUSH
5399: LD_INT 31
5401: PUSH
5402: EMPTY
5403: LIST
5404: LIST
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: PPUSH
5411: CALL_OW 69
5415: PUSH
5416: LD_VAR 0 2
5420: ARRAY
5421: PPUSH
5422: CALL_OW 120
// end ;
5426: GO 5285
5428: POP
5429: POP
// for i := 1 to 2 do
5430: LD_ADDR_VAR 0 2
5434: PUSH
5435: DOUBLE
5436: LD_INT 1
5438: DEC
5439: ST_TO_ADDR
5440: LD_INT 2
5442: PUSH
5443: FOR_TO
5444: IFFALSE 5508
// begin PrepareHuman ( false , 2 , 2 ) ;
5446: LD_INT 0
5448: PPUSH
5449: LD_INT 2
5451: PPUSH
5452: LD_INT 2
5454: PPUSH
5455: CALL_OW 380
// un := CreateHuman ;
5459: LD_ADDR_VAR 0 3
5463: PUSH
5464: CALL_OW 44
5468: ST_TO_ADDR
// usForces := usForces union un ;
5469: LD_ADDR_EXP 40
5473: PUSH
5474: LD_EXP 40
5478: PUSH
5479: LD_VAR 0 3
5483: UNION
5484: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5485: LD_VAR 0 3
5489: PPUSH
5490: LD_INT 39
5492: PPUSH
5493: LD_INT 24
5495: PPUSH
5496: LD_INT 4
5498: PPUSH
5499: LD_INT 0
5501: PPUSH
5502: CALL_OW 50
// end ;
5506: GO 5443
5508: POP
5509: POP
// PrepareHuman ( false , 4 , 1 ) ;
5510: LD_INT 0
5512: PPUSH
5513: LD_INT 4
5515: PPUSH
5516: LD_INT 1
5518: PPUSH
5519: CALL_OW 380
// un := CreateHuman ;
5523: LD_ADDR_VAR 0 3
5527: PUSH
5528: CALL_OW 44
5532: ST_TO_ADDR
// usForces := usForces union un ;
5533: LD_ADDR_EXP 40
5537: PUSH
5538: LD_EXP 40
5542: PUSH
5543: LD_VAR 0 3
5547: UNION
5548: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5549: LD_VAR 0 3
5553: PPUSH
5554: LD_INT 39
5556: PPUSH
5557: LD_INT 24
5559: PPUSH
5560: LD_INT 4
5562: PPUSH
5563: LD_INT 0
5565: PPUSH
5566: CALL_OW 50
// end ;
5570: LD_VAR 0 1
5574: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
5575: LD_EXP 40
5579: PUSH
5580: LD_EXP 6
5584: NOT
5585: AND
5586: IFFALSE 6017
5588: GO 5590
5590: DISABLE
5591: LD_INT 0
5593: PPUSH
5594: PPUSH
5595: PPUSH
5596: PPUSH
5597: PPUSH
// begin enable ;
5598: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5599: LD_ADDR_VAR 0 3
5603: PUSH
5604: LD_EXP 40
5608: PPUSH
5609: LD_INT 25
5611: PUSH
5612: LD_INT 2
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PPUSH
5619: CALL_OW 72
5623: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5624: LD_ADDR_VAR 0 4
5628: PUSH
5629: LD_EXP 40
5633: PPUSH
5634: LD_INT 25
5636: PUSH
5637: LD_INT 1
5639: PUSH
5640: EMPTY
5641: LIST
5642: LIST
5643: PPUSH
5644: CALL_OW 72
5648: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5649: LD_ADDR_VAR 0 5
5653: PUSH
5654: LD_EXP 40
5658: PPUSH
5659: LD_INT 25
5661: PUSH
5662: LD_INT 4
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL_OW 72
5673: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5674: LD_INT 7
5676: PPUSH
5677: LD_INT 22
5679: PUSH
5680: LD_INT 2
5682: PUSH
5683: EMPTY
5684: LIST
5685: LIST
5686: PPUSH
5687: CALL_OW 70
5691: PUSH
5692: LD_INT 1
5694: EQUAL
5695: IFFALSE 5771
// for i in sol do
5697: LD_ADDR_VAR 0 1
5701: PUSH
5702: LD_VAR 0 4
5706: PUSH
5707: FOR_IN
5708: IFFALSE 5769
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5710: LD_VAR 0 1
5714: PPUSH
5715: CALL_OW 310
5719: NOT
5720: PUSH
5721: LD_VAR 0 1
5725: PPUSH
5726: CALL_OW 310
5730: PPUSH
5731: CALL_OW 266
5735: PUSH
5736: LD_INT 4
5738: EQUAL
5739: NOT
5740: OR
5741: IFFALSE 5767
// begin ComExitBuilding ( i ) ;
5743: LD_VAR 0 1
5747: PPUSH
5748: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5752: LD_VAR 0 1
5756: PPUSH
5757: LD_INT 37
5759: PPUSH
5760: LD_INT 23
5762: PPUSH
5763: CALL_OW 174
// end ;
5767: GO 5707
5769: POP
5770: POP
// if eng then
5771: LD_VAR 0 3
5775: IFFALSE 6017
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5777: LD_ADDR_VAR 0 2
5781: PUSH
5782: LD_INT 22
5784: PUSH
5785: LD_INT 1
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: PUSH
5792: LD_INT 95
5794: PUSH
5795: LD_INT 7
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: PUSH
5802: LD_INT 21
5804: PUSH
5805: LD_INT 3
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: PUSH
5812: LD_INT 3
5814: PUSH
5815: LD_INT 24
5817: PUSH
5818: LD_INT 1000
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: PUSH
5825: EMPTY
5826: LIST
5827: LIST
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: LIST
5833: LIST
5834: PPUSH
5835: CALL_OW 69
5839: ST_TO_ADDR
// if b then
5840: LD_VAR 0 2
5844: IFFALSE 5875
// begin ComExitBuilding ( eng ) ;
5846: LD_VAR 0 3
5850: PPUSH
5851: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5855: LD_VAR 0 3
5859: PPUSH
5860: LD_VAR 0 2
5864: PUSH
5865: LD_INT 1
5867: ARRAY
5868: PPUSH
5869: CALL_OW 190
// end else
5873: GO 6017
// begin for i in eng do
5875: LD_ADDR_VAR 0 1
5879: PUSH
5880: LD_VAR 0 3
5884: PUSH
5885: FOR_IN
5886: IFFALSE 6015
// if not HasTask ( i ) then
5888: LD_VAR 0 1
5892: PPUSH
5893: CALL_OW 314
5897: NOT
5898: IFFALSE 6013
// begin if americanBuildList then
5900: LD_EXP 42
5904: IFFALSE 5989
// begin if IsInUnit ( i ) then
5906: LD_VAR 0 1
5910: PPUSH
5911: CALL_OW 310
5915: IFFALSE 5926
// ComExitBuilding ( i ) ;
5917: LD_VAR 0 1
5921: PPUSH
5922: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5926: LD_VAR 0 1
5930: PPUSH
5931: LD_EXP 42
5935: PUSH
5936: LD_INT 1
5938: ARRAY
5939: PUSH
5940: LD_INT 1
5942: ARRAY
5943: PPUSH
5944: LD_EXP 42
5948: PUSH
5949: LD_INT 1
5951: ARRAY
5952: PUSH
5953: LD_INT 2
5955: ARRAY
5956: PPUSH
5957: LD_EXP 42
5961: PUSH
5962: LD_INT 1
5964: ARRAY
5965: PUSH
5966: LD_INT 3
5968: ARRAY
5969: PPUSH
5970: LD_EXP 42
5974: PUSH
5975: LD_INT 1
5977: ARRAY
5978: PUSH
5979: LD_INT 4
5981: ARRAY
5982: PPUSH
5983: CALL_OW 205
// end else
5987: GO 6013
// if not IsInUnit ( i ) then
5989: LD_VAR 0 1
5993: PPUSH
5994: CALL_OW 310
5998: NOT
5999: IFFALSE 6013
// ComEnterUnit ( i , usDepot ) ;
6001: LD_VAR 0 1
6005: PPUSH
6006: LD_INT 11
6008: PPUSH
6009: CALL_OW 120
// end ;
6013: GO 5885
6015: POP
6016: POP
// end ; end ; end ;
6017: PPOPN 5
6019: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
6020: LD_INT 0
6022: PPUSH
6023: PPUSH
6024: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
6025: LD_ADDR_VAR 0 3
6029: PUSH
6030: LD_INT 35
6032: PUSH
6033: LD_INT 45
6035: PUSH
6036: LD_INT 48
6038: PUSH
6039: LD_EXP 51
6043: PUSH
6044: EMPTY
6045: LIST
6046: LIST
6047: LIST
6048: LIST
6049: ST_TO_ADDR
// for i in tech do
6050: LD_ADDR_VAR 0 4
6054: PUSH
6055: LD_VAR 0 3
6059: PUSH
6060: FOR_IN
6061: IFFALSE 6079
// AddComResearch ( lab , i ) ;
6063: LD_VAR 0 1
6067: PPUSH
6068: LD_VAR 0 4
6072: PPUSH
6073: CALL_OW 184
6077: GO 6060
6079: POP
6080: POP
// end ;
6081: LD_VAR 0 2
6085: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
6086: LD_EXP 11
6090: PUSH
6091: LD_EXP 19
6095: PUSH
6096: LD_EXP 23
6100: LESSEQUAL
6101: AND
6102: IFFALSE 6127
6104: GO 6106
6106: DISABLE
// begin enable ;
6107: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6108: LD_INT 35
6110: PPUSH
6111: LD_INT 2065
6113: PPUSH
6114: CALL_OW 12
6118: PPUSH
6119: CALL_OW 67
// SendConvoy ;
6123: CALL 6225 0 0
// end ;
6127: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6128: LD_EXP 6
6132: PUSH
6133: LD_EXP 15
6137: AND
6138: IFFALSE 6224
6140: GO 6142
6142: DISABLE
// begin if americanHasEscaped then
6143: LD_EXP 7
6147: IFFALSE 6158
// wait ( 3 3$20 ) else
6149: LD_INT 7000
6151: PPUSH
6152: CALL_OW 67
6156: GO 6165
// wait ( 6 6$40 ) ;
6158: LD_INT 14000
6160: PPUSH
6161: CALL_OW 67
// SendAttack ;
6165: CALL 6957 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6169: LD_INT 14000
6171: PUSH
6172: LD_INT 11900
6174: PUSH
6175: LD_INT 9800
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: PUSH
6183: LD_OWVAR 67
6187: ARRAY
6188: PPUSH
6189: CALL_OW 67
// SendAttack ;
6193: CALL 6957 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6197: LD_EXP 16
6201: PUSH
6202: LD_INT 6
6204: PUSH
6205: LD_INT 7
6207: PUSH
6208: LD_INT 8
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: PUSH
6216: LD_OWVAR 67
6220: ARRAY
6221: LESS
6222: IFFALSE 6169
// end ;
6224: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6225: LD_INT 0
6227: PPUSH
6228: PPUSH
6229: PPUSH
6230: PPUSH
6231: PPUSH
6232: PPUSH
6233: PPUSH
6234: PPUSH
// road := rand ( 1 , 2 ) ;
6235: LD_ADDR_VAR 0 4
6239: PUSH
6240: LD_INT 1
6242: PPUSH
6243: LD_INT 2
6245: PPUSH
6246: CALL_OW 12
6250: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6251: LD_ADDR_VAR 0 8
6255: PUSH
6256: LD_INT 3
6258: PUSH
6259: LD_INT 8
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: PUSH
6266: LD_VAR 0 4
6270: ARRAY
6271: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6272: LD_ADDR_VAR 0 5
6276: PUSH
6277: LD_INT 35
6279: PUSH
6280: LD_INT 66
6282: PUSH
6283: LD_INT 1
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: LIST
6290: PUSH
6291: LD_INT 101
6293: PUSH
6294: LD_INT 8
6296: PUSH
6297: LD_INT 4
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: LIST
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6309: LD_ADDR_VAR 0 6
6313: PUSH
6314: LD_INT 34
6316: PUSH
6317: LD_INT 67
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: PUSH
6324: LD_INT 38
6326: PUSH
6327: LD_INT 62
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PUSH
6334: LD_INT 43
6336: PUSH
6337: LD_INT 54
6339: PUSH
6340: EMPTY
6341: LIST
6342: LIST
6343: PUSH
6344: LD_INT 57
6346: PUSH
6347: LD_INT 57
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: PUSH
6354: LD_INT 77
6356: PUSH
6357: LD_INT 71
6359: PUSH
6360: EMPTY
6361: LIST
6362: LIST
6363: PUSH
6364: LD_INT 86
6366: PUSH
6367: LD_INT 60
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PUSH
6374: LD_INT 89
6376: PUSH
6377: LD_INT 35
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: PUSH
6384: LD_INT 93
6386: PUSH
6387: LD_INT 17
6389: PUSH
6390: EMPTY
6391: LIST
6392: LIST
6393: PUSH
6394: LD_INT 97
6396: PUSH
6397: LD_INT 10
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: PUSH
6404: LD_INT 103
6406: PUSH
6407: LD_INT 9
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PUSH
6414: EMPTY
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: LIST
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: LIST
6425: ST_TO_ADDR
// if road = 2 then
6426: LD_VAR 0 4
6430: PUSH
6431: LD_INT 2
6433: EQUAL
6434: IFFALSE 6451
// points := ReverseArray ( points ) ;
6436: LD_ADDR_VAR 0 6
6440: PUSH
6441: LD_VAR 0 6
6445: PPUSH
6446: CALL 1032 0 1
6450: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6451: LD_INT 4
6453: PPUSH
6454: LD_INT 1
6456: PPUSH
6457: LD_INT 2
6459: PPUSH
6460: LD_INT 1
6462: PPUSH
6463: LD_INT 1
6465: PPUSH
6466: LD_INT 12
6468: PPUSH
6469: LD_INT 80
6471: PPUSH
6472: CALL 344 0 7
// veh := CreateVehicle ;
6476: LD_ADDR_VAR 0 3
6480: PUSH
6481: CALL_OW 45
6485: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6486: LD_VAR 0 3
6490: PPUSH
6491: LD_VAR 0 5
6495: PUSH
6496: LD_VAR 0 4
6500: ARRAY
6501: PUSH
6502: LD_INT 3
6504: ARRAY
6505: PPUSH
6506: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6510: LD_VAR 0 3
6514: PPUSH
6515: LD_VAR 0 5
6519: PUSH
6520: LD_VAR 0 4
6524: ARRAY
6525: PUSH
6526: LD_INT 1
6528: ARRAY
6529: PPUSH
6530: LD_VAR 0 5
6534: PUSH
6535: LD_VAR 0 4
6539: ARRAY
6540: PUSH
6541: LD_INT 2
6543: ARRAY
6544: PPUSH
6545: LD_INT 0
6547: PPUSH
6548: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6552: LD_INT 0
6554: PPUSH
6555: LD_INT 1
6557: PPUSH
6558: LD_OWVAR 67
6562: PPUSH
6563: CALL_OW 380
// un := CreateHuman ;
6567: LD_ADDR_VAR 0 2
6571: PUSH
6572: CALL_OW 44
6576: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6577: LD_VAR 0 2
6581: PPUSH
6582: LD_VAR 0 3
6586: PPUSH
6587: CALL_OW 52
// if ( Prob ( [ 60 , 56 , 52 ] [ Difficulty ] ) + tick mod 30 ) or convoyCounter < 4 then
6591: LD_INT 60
6593: PUSH
6594: LD_INT 56
6596: PUSH
6597: LD_INT 52
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: PUSH
6605: LD_OWVAR 67
6609: ARRAY
6610: PPUSH
6611: CALL_OW 13
6615: PUSH
6616: LD_OWVAR 1
6620: PUSH
6621: LD_INT 30
6623: MOD
6624: PLUS
6625: PUSH
6626: LD_EXP 19
6630: PUSH
6631: LD_INT 4
6633: LESS
6634: OR
6635: IFFALSE 6652
// SetCargo ( veh , mat_cans , 100 ) ;
6637: LD_VAR 0 3
6641: PPUSH
6642: LD_INT 1
6644: PPUSH
6645: LD_INT 100
6647: PPUSH
6648: CALL_OW 290
// for i := 2 to points do
6652: LD_ADDR_VAR 0 7
6656: PUSH
6657: DOUBLE
6658: LD_INT 2
6660: DEC
6661: ST_TO_ADDR
6662: LD_VAR 0 6
6666: PUSH
6667: FOR_TO
6668: IFFALSE 6711
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6670: LD_VAR 0 3
6674: PPUSH
6675: LD_VAR 0 6
6679: PUSH
6680: LD_VAR 0 7
6684: ARRAY
6685: PUSH
6686: LD_INT 1
6688: ARRAY
6689: PPUSH
6690: LD_VAR 0 6
6694: PUSH
6695: LD_VAR 0 7
6699: ARRAY
6700: PUSH
6701: LD_INT 2
6703: ARRAY
6704: PPUSH
6705: CALL_OW 171
6709: GO 6667
6711: POP
6712: POP
// convoyCounter := convoyCounter + 1 ;
6713: LD_ADDR_EXP 19
6717: PUSH
6718: LD_EXP 19
6722: PUSH
6723: LD_INT 1
6725: PLUS
6726: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6727: LD_INT 35
6729: PPUSH
6730: CALL_OW 67
// if not HasTask ( veh ) then
6734: LD_VAR 0 3
6738: PPUSH
6739: CALL_OW 314
6743: NOT
6744: IFFALSE 6785
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6746: LD_VAR 0 3
6750: PPUSH
6751: LD_VAR 0 6
6755: PUSH
6756: LD_VAR 0 6
6760: ARRAY
6761: PUSH
6762: LD_INT 1
6764: ARRAY
6765: PPUSH
6766: LD_VAR 0 6
6770: PUSH
6771: LD_VAR 0 6
6775: ARRAY
6776: PUSH
6777: LD_INT 2
6779: ARRAY
6780: PPUSH
6781: CALL_OW 111
// if not IsOk ( veh ) then
6785: LD_VAR 0 3
6789: PPUSH
6790: CALL_OW 302
6794: NOT
6795: IFFALSE 6836
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6797: LD_VAR 0 2
6801: PPUSH
6802: LD_VAR 0 6
6806: PUSH
6807: LD_VAR 0 6
6811: ARRAY
6812: PUSH
6813: LD_INT 1
6815: ARRAY
6816: PPUSH
6817: LD_VAR 0 6
6821: PUSH
6822: LD_VAR 0 6
6826: ARRAY
6827: PUSH
6828: LD_INT 2
6830: ARRAY
6831: PPUSH
6832: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6836: LD_VAR 0 3
6840: PPUSH
6841: LD_VAR 0 8
6845: PPUSH
6846: CALL_OW 308
6850: PUSH
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_VAR 0 8
6860: PPUSH
6861: CALL_OW 308
6865: OR
6866: IFFALSE 6727
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6868: LD_VAR 0 2
6872: PPUSH
6873: CALL_OW 302
6877: PUSH
6878: LD_VAR 0 3
6882: PPUSH
6883: CALL_OW 302
6887: NOT
6888: AND
6889: PUSH
6890: LD_VAR 0 2
6894: PPUSH
6895: LD_VAR 0 8
6899: PPUSH
6900: CALL_OW 308
6904: AND
6905: IFFALSE 6916
// RemoveUnit ( un ) ;
6907: LD_VAR 0 2
6911: PPUSH
6912: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6916: LD_VAR 0 3
6920: PPUSH
6921: LD_VAR 0 8
6925: PPUSH
6926: CALL_OW 308
6930: PUSH
6931: LD_VAR 0 3
6935: PPUSH
6936: CALL_OW 302
6940: AND
6941: IFFALSE 6952
// RemoveUnit ( veh ) ;
6943: LD_VAR 0 3
6947: PPUSH
6948: CALL_OW 64
// end ;
6952: LD_VAR 0 1
6956: RET
// export function SendAttack ; var un , veh , i ; begin
6957: LD_INT 0
6959: PPUSH
6960: PPUSH
6961: PPUSH
6962: PPUSH
// IncomingAttack ;
6963: CALL 15352 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
6967: LD_INT 2100
6969: PPUSH
6970: LD_INT 3500
6972: PPUSH
6973: CALL_OW 12
6977: PPUSH
6978: CALL_OW 67
// for i := 1 to [ 3 , 3 , 4 ] [ Difficulty ] + attackWave div 3 do
6982: LD_ADDR_VAR 0 4
6986: PUSH
6987: DOUBLE
6988: LD_INT 1
6990: DEC
6991: ST_TO_ADDR
6992: LD_INT 3
6994: PUSH
6995: LD_INT 3
6997: PUSH
6998: LD_INT 4
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: LIST
7005: PUSH
7006: LD_OWVAR 67
7010: ARRAY
7011: PUSH
7012: LD_EXP 16
7016: PUSH
7017: LD_INT 3
7019: DIV
7020: PLUS
7021: PUSH
7022: FOR_TO
7023: IFFALSE 7135
// begin uc_side := 1 ;
7025: LD_ADDR_OWVAR 20
7029: PUSH
7030: LD_INT 1
7032: ST_TO_ADDR
// uc_nation := 1 ;
7033: LD_ADDR_OWVAR 21
7037: PUSH
7038: LD_INT 1
7040: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
7041: LD_INT 0
7043: PPUSH
7044: LD_INT 1
7046: PPUSH
7047: LD_INT 2
7049: PUSH
7050: LD_INT 3
7052: PUSH
7053: LD_INT 4
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: LIST
7060: PUSH
7061: LD_OWVAR 67
7065: ARRAY
7066: PPUSH
7067: CALL_OW 380
// un := CreateHuman ;
7071: LD_ADDR_VAR 0 2
7075: PUSH
7076: CALL_OW 44
7080: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7081: LD_VAR 0 2
7085: PPUSH
7086: LD_INT 37
7088: PPUSH
7089: LD_INT 70
7091: PPUSH
7092: LD_INT 3
7094: PPUSH
7095: LD_INT 0
7097: PPUSH
7098: CALL_OW 50
// usAttackers := usAttackers union un ;
7102: LD_ADDR_EXP 43
7106: PUSH
7107: LD_EXP 43
7111: PUSH
7112: LD_VAR 0 2
7116: UNION
7117: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7118: LD_VAR 0 2
7122: PPUSH
7123: LD_INT 40
7125: PPUSH
7126: LD_INT 65
7128: PPUSH
7129: CALL_OW 111
// end ;
7133: GO 7022
7135: POP
7136: POP
// uc_side := 1 ;
7137: LD_ADDR_OWVAR 20
7141: PUSH
7142: LD_INT 1
7144: ST_TO_ADDR
// uc_nation := 1 ;
7145: LD_ADDR_OWVAR 21
7149: PUSH
7150: LD_INT 1
7152: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7153: LD_INT 0
7155: PPUSH
7156: LD_INT 4
7158: PPUSH
7159: LD_INT 2
7161: PPUSH
7162: CALL_OW 380
// un := CreateHuman ;
7166: LD_ADDR_VAR 0 2
7170: PUSH
7171: CALL_OW 44
7175: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7176: LD_VAR 0 2
7180: PPUSH
7181: LD_INT 37
7183: PPUSH
7184: LD_INT 70
7186: PPUSH
7187: LD_INT 3
7189: PPUSH
7190: LD_INT 0
7192: PPUSH
7193: CALL_OW 50
// usAttackers := usAttackers union un ;
7197: LD_ADDR_EXP 43
7201: PUSH
7202: LD_EXP 43
7206: PUSH
7207: LD_VAR 0 2
7211: UNION
7212: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7213: LD_VAR 0 2
7217: PPUSH
7218: LD_INT 40
7220: PPUSH
7221: LD_INT 65
7223: PPUSH
7224: CALL_OW 111
// if attackWave > 1 or Difficulty > 1 then
7228: LD_EXP 16
7232: PUSH
7233: LD_INT 1
7235: GREATER
7236: PUSH
7237: LD_OWVAR 67
7241: PUSH
7242: LD_INT 1
7244: GREATER
7245: OR
7246: IFFALSE 7449
// begin for i := 1 to Difficulty + attackWave div 4 do
7248: LD_ADDR_VAR 0 4
7252: PUSH
7253: DOUBLE
7254: LD_INT 1
7256: DEC
7257: ST_TO_ADDR
7258: LD_OWVAR 67
7262: PUSH
7263: LD_EXP 16
7267: PUSH
7268: LD_INT 4
7270: DIV
7271: PLUS
7272: PUSH
7273: FOR_TO
7274: IFFALSE 7447
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7276: LD_ADDR_VAR 0 3
7280: PUSH
7281: LD_INT 1
7283: PPUSH
7284: LD_INT 1
7286: PPUSH
7287: LD_INT 2
7289: PPUSH
7290: LD_INT 1
7292: PPUSH
7293: LD_INT 1
7295: PPUSH
7296: LD_INT 4
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: LD_INT 2
7304: PUSH
7305: EMPTY
7306: LIST
7307: LIST
7308: LIST
7309: PUSH
7310: LD_INT 1
7312: PPUSH
7313: LD_INT 3
7315: PPUSH
7316: CALL_OW 12
7320: ARRAY
7321: PPUSH
7322: LD_INT 90
7324: PPUSH
7325: CALL 344 0 7
7329: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7330: LD_VAR 0 3
7334: PPUSH
7335: LD_INT 35
7337: PPUSH
7338: LD_INT 65
7340: PPUSH
7341: LD_INT 0
7343: PPUSH
7344: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7348: LD_INT 0
7350: PPUSH
7351: LD_INT 3
7353: PPUSH
7354: LD_OWVAR 67
7358: PUSH
7359: LD_INT 1
7361: PLUS
7362: PPUSH
7363: CALL_OW 380
// un := CreateHuman ;
7367: LD_ADDR_VAR 0 2
7371: PUSH
7372: CALL_OW 44
7376: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7377: LD_VAR 0 2
7381: PPUSH
7382: LD_VAR 0 3
7386: PPUSH
7387: CALL_OW 52
// usAttackers := usAttackers union un ;
7391: LD_ADDR_EXP 43
7395: PUSH
7396: LD_EXP 43
7400: PUSH
7401: LD_VAR 0 2
7405: UNION
7406: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7407: LD_VAR 0 3
7411: PPUSH
7412: LD_INT 39
7414: PPUSH
7415: LD_INT 60
7417: PPUSH
7418: CALL_OW 111
// wait ( 0 0$2 ) ;
7422: LD_INT 70
7424: PPUSH
7425: CALL_OW 67
// usAttackers := usAttackers union veh ;
7429: LD_ADDR_EXP 43
7433: PUSH
7434: LD_EXP 43
7438: PUSH
7439: LD_VAR 0 3
7443: UNION
7444: ST_TO_ADDR
// end ;
7445: GO 7273
7447: POP
7448: POP
// end ; attackWave := attackWave + 1 ;
7449: LD_ADDR_EXP 16
7453: PUSH
7454: LD_EXP 16
7458: PUSH
7459: LD_INT 1
7461: PLUS
7462: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7463: LD_EXP 20
7467: PPUSH
7468: CALL_OW 427
// end ;
7472: LD_VAR 0 1
7476: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7477: LD_INT 0
7479: PPUSH
7480: PPUSH
7481: PPUSH
7482: PPUSH
7483: PPUSH
7484: PPUSH
7485: PPUSH
7486: PPUSH
7487: PPUSH
7488: PPUSH
7489: PPUSH
// if retreatAllowed then
7490: LD_EXP 10
7494: IFFALSE 7506
// strategy := 2 else
7496: LD_ADDR_VAR 0 5
7500: PUSH
7501: LD_INT 2
7503: ST_TO_ADDR
7504: GO 7522
// strategy := rand ( 0 , 2 ) ;
7506: LD_ADDR_VAR 0 5
7510: PUSH
7511: LD_INT 0
7513: PPUSH
7514: LD_INT 2
7516: PPUSH
7517: CALL_OW 12
7521: ST_TO_ADDR
// attackFormula := [ ] ;
7522: LD_ADDR_VAR 0 6
7526: PUSH
7527: EMPTY
7528: ST_TO_ADDR
// case strategy of 0 :
7529: LD_VAR 0 5
7533: PUSH
7534: LD_INT 0
7536: DOUBLE
7537: EQUAL
7538: IFTRUE 7542
7540: GO 7872
7542: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7543: LD_INT 11
7545: PPUSH
7546: LD_INT 22
7548: PUSH
7549: LD_INT 2
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 30
7558: PUSH
7559: LD_INT 4
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PPUSH
7570: CALL_OW 70
7574: NOT
7575: IFFALSE 7647
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7577: LD_ADDR_VAR 0 6
7581: PUSH
7582: LD_INT 41
7584: PUSH
7585: LD_INT 34
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: EMPTY
7593: LIST
7594: PUSH
7595: LD_INT 53
7597: PUSH
7598: LD_INT 62
7600: PUSH
7601: EMPTY
7602: LIST
7603: LIST
7604: PUSH
7605: LD_INT 37
7607: PUSH
7608: LD_INT 63
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PUSH
7615: LD_INT 44
7617: PUSH
7618: LD_INT 45
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: PUSH
7625: LD_INT 37
7627: PUSH
7628: LD_INT 28
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: LIST
7643: LIST
7644: ST_TO_ADDR
7645: GO 7870
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7647: LD_INT 12
7649: PPUSH
7650: LD_INT 22
7652: PUSH
7653: LD_INT 2
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: PUSH
7660: LD_INT 2
7662: PUSH
7663: LD_INT 30
7665: PUSH
7666: LD_INT 4
7668: PUSH
7669: EMPTY
7670: LIST
7671: LIST
7672: PUSH
7673: LD_INT 30
7675: PUSH
7676: LD_INT 31
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 30
7685: PUSH
7686: LD_INT 32
7688: PUSH
7689: EMPTY
7690: LIST
7691: LIST
7692: PUSH
7693: EMPTY
7694: LIST
7695: LIST
7696: LIST
7697: LIST
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: PPUSH
7703: CALL_OW 70
7707: NOT
7708: IFFALSE 7791
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7710: LD_ADDR_VAR 0 6
7714: PUSH
7715: LD_INT 27
7717: PUSH
7718: LD_INT 42
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 27
7727: PUSH
7728: LD_INT 32
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: PUSH
7739: LD_INT 53
7741: PUSH
7742: LD_INT 62
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: LD_INT 37
7751: PUSH
7752: LD_INT 63
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 44
7761: PUSH
7762: LD_INT 45
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: PUSH
7769: LD_INT 37
7771: PUSH
7772: LD_INT 28
7774: PUSH
7775: EMPTY
7776: LIST
7777: LIST
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: LIST
7787: LIST
7788: ST_TO_ADDR
7789: GO 7870
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7791: LD_ADDR_VAR 0 6
7795: PUSH
7796: LD_INT 71
7798: PUSH
7799: LD_INT 67
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: LD_INT 54
7808: PUSH
7809: LD_INT 35
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: LD_INT 63
7822: PUSH
7823: LD_INT 40
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: PUSH
7830: LD_INT 37
7832: PUSH
7833: LD_INT 63
7835: PUSH
7836: EMPTY
7837: LIST
7838: LIST
7839: PUSH
7840: LD_INT 44
7842: PUSH
7843: LD_INT 45
7845: PUSH
7846: EMPTY
7847: LIST
7848: LIST
7849: PUSH
7850: LD_INT 37
7852: PUSH
7853: LD_INT 28
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: PUSH
7864: EMPTY
7865: LIST
7866: LIST
7867: LIST
7868: LIST
7869: ST_TO_ADDR
// end ; 1 :
7870: GO 8075
7872: LD_INT 1
7874: DOUBLE
7875: EQUAL
7876: IFTRUE 7880
7878: GO 7984
7880: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7881: LD_ADDR_VAR 0 6
7885: PUSH
7886: LD_INT 71
7888: PUSH
7889: LD_INT 67
7891: PUSH
7892: EMPTY
7893: LIST
7894: LIST
7895: PUSH
7896: LD_INT 82
7898: PUSH
7899: LD_INT 23
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: PUSH
7906: LD_INT 53
7908: PUSH
7909: LD_INT 7
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PUSH
7916: LD_INT 43
7918: PUSH
7919: LD_INT 10
7921: PUSH
7922: EMPTY
7923: LIST
7924: LIST
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: LIST
7930: LIST
7931: PUSH
7932: LD_INT 53
7934: PUSH
7935: LD_INT 62
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PUSH
7942: LD_INT 37
7944: PUSH
7945: LD_INT 63
7947: PUSH
7948: EMPTY
7949: LIST
7950: LIST
7951: PUSH
7952: LD_INT 44
7954: PUSH
7955: LD_INT 45
7957: PUSH
7958: EMPTY
7959: LIST
7960: LIST
7961: PUSH
7962: LD_INT 37
7964: PUSH
7965: LD_INT 28
7967: PUSH
7968: EMPTY
7969: LIST
7970: LIST
7971: PUSH
7972: EMPTY
7973: LIST
7974: LIST
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: LIST
7980: LIST
7981: ST_TO_ADDR
7982: GO 8075
7984: LD_INT 2
7986: DOUBLE
7987: EQUAL
7988: IFTRUE 7992
7990: GO 8074
7992: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
7993: LD_ADDR_VAR 0 6
7997: PUSH
7998: LD_INT 90
8000: PUSH
8001: LD_INT 59
8003: PUSH
8004: EMPTY
8005: LIST
8006: LIST
8007: PUSH
8008: LD_INT 108
8010: PUSH
8011: LD_INT 64
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: PUSH
8022: LD_INT 82
8024: PUSH
8025: LD_INT 75
8027: PUSH
8028: EMPTY
8029: LIST
8030: LIST
8031: PUSH
8032: LD_INT 73
8034: PUSH
8035: LD_INT 67
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PUSH
8042: LD_INT 101
8044: PUSH
8045: LD_INT 65
8047: PUSH
8048: EMPTY
8049: LIST
8050: LIST
8051: PUSH
8052: LD_INT 108
8054: PUSH
8055: LD_INT 62
8057: PUSH
8058: EMPTY
8059: LIST
8060: LIST
8061: PUSH
8062: EMPTY
8063: LIST
8064: LIST
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: ST_TO_ADDR
8072: GO 8075
8074: POP
// if not attackFormula then
8075: LD_VAR 0 6
8079: NOT
8080: IFFALSE 8084
// exit ;
8082: GO 9516
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8084: LD_ADDR_VAR 0 7
8088: PUSH
8089: LD_EXP 43
8093: PPUSH
8094: LD_INT 25
8096: PUSH
8097: LD_INT 1
8099: PUSH
8100: EMPTY
8101: LIST
8102: LIST
8103: PPUSH
8104: CALL_OW 72
8108: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8109: LD_ADDR_VAR 0 8
8113: PUSH
8114: LD_EXP 43
8118: PPUSH
8119: LD_INT 25
8121: PUSH
8122: LD_INT 4
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: PPUSH
8129: CALL_OW 72
8133: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8134: LD_ADDR_VAR 0 9
8138: PUSH
8139: LD_EXP 43
8143: PPUSH
8144: LD_INT 25
8146: PUSH
8147: LD_INT 3
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PPUSH
8154: CALL_OW 72
8158: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8159: LD_ADDR_VAR 0 10
8163: PUSH
8164: LD_EXP 43
8168: PPUSH
8169: LD_INT 21
8171: PUSH
8172: LD_INT 2
8174: PUSH
8175: EMPTY
8176: LIST
8177: LIST
8178: PPUSH
8179: CALL_OW 72
8183: ST_TO_ADDR
// if sci then
8184: LD_VAR 0 8
8188: IFFALSE 8225
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8190: LD_VAR 0 8
8194: PPUSH
8195: LD_VAR 0 6
8199: PUSH
8200: LD_INT 2
8202: ARRAY
8203: PUSH
8204: LD_INT 1
8206: ARRAY
8207: PPUSH
8208: LD_VAR 0 6
8212: PUSH
8213: LD_INT 2
8215: ARRAY
8216: PUSH
8217: LD_INT 2
8219: ARRAY
8220: PPUSH
8221: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8225: LD_INT 35
8227: PPUSH
8228: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8232: LD_ADDR_VAR 0 7
8236: PUSH
8237: LD_EXP 43
8241: PPUSH
8242: LD_INT 25
8244: PUSH
8245: LD_INT 1
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: PPUSH
8252: CALL_OW 72
8256: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8257: LD_ADDR_VAR 0 8
8261: PUSH
8262: LD_EXP 43
8266: PPUSH
8267: LD_INT 25
8269: PUSH
8270: LD_INT 4
8272: PUSH
8273: EMPTY
8274: LIST
8275: LIST
8276: PPUSH
8277: CALL_OW 72
8281: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8282: LD_ADDR_VAR 0 9
8286: PUSH
8287: LD_EXP 43
8291: PPUSH
8292: LD_INT 25
8294: PUSH
8295: LD_INT 3
8297: PUSH
8298: EMPTY
8299: LIST
8300: LIST
8301: PPUSH
8302: CALL_OW 72
8306: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8307: LD_ADDR_VAR 0 10
8311: PUSH
8312: LD_EXP 43
8316: PPUSH
8317: LD_INT 21
8319: PUSH
8320: LD_INT 2
8322: PUSH
8323: EMPTY
8324: LIST
8325: LIST
8326: PPUSH
8327: CALL_OW 72
8331: ST_TO_ADDR
// if sol then
8332: LD_VAR 0 7
8336: IFFALSE 8731
// begin for i in sol do
8338: LD_ADDR_VAR 0 2
8342: PUSH
8343: LD_VAR 0 7
8347: PUSH
8348: FOR_IN
8349: IFFALSE 8729
// begin tag := GetTag ( i ) ;
8351: LD_ADDR_VAR 0 4
8355: PUSH
8356: LD_VAR 0 2
8360: PPUSH
8361: CALL_OW 110
8365: ST_TO_ADDR
// if not tag then
8366: LD_VAR 0 4
8370: NOT
8371: IFFALSE 8489
// begin if GetLives ( i ) = 1000 then
8373: LD_VAR 0 2
8377: PPUSH
8378: CALL_OW 256
8382: PUSH
8383: LD_INT 1000
8385: EQUAL
8386: IFFALSE 8402
// SetTag ( i , 1 ) else
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 1
8395: PPUSH
8396: CALL_OW 109
8400: GO 8487
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8402: LD_VAR 0 2
8406: PPUSH
8407: LD_VAR 0 6
8411: PUSH
8412: LD_INT 2
8414: ARRAY
8415: PUSH
8416: LD_INT 1
8418: ARRAY
8419: PPUSH
8420: LD_VAR 0 6
8424: PUSH
8425: LD_INT 2
8427: ARRAY
8428: PUSH
8429: LD_INT 2
8431: ARRAY
8432: PPUSH
8433: CALL_OW 297
8437: PUSH
8438: LD_INT 6
8440: GREATER
8441: IFFALSE 8487
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8443: LD_VAR 0 2
8447: PPUSH
8448: LD_VAR 0 6
8452: PUSH
8453: LD_INT 2
8455: ARRAY
8456: PUSH
8457: LD_INT 1
8459: ARRAY
8460: PPUSH
8461: LD_VAR 0 6
8465: PUSH
8466: LD_INT 2
8468: ARRAY
8469: PUSH
8470: LD_INT 2
8472: ARRAY
8473: PPUSH
8474: CALL_OW 111
// AddComHold ( i ) ;
8478: LD_VAR 0 2
8482: PPUSH
8483: CALL_OW 200
// end ; end else
8487: GO 8727
// begin if GetLives ( i ) < 720 then
8489: LD_VAR 0 2
8493: PPUSH
8494: CALL_OW 256
8498: PUSH
8499: LD_INT 720
8501: LESS
8502: IFFALSE 8518
// SetTag ( i , 0 ) else
8504: LD_VAR 0 2
8508: PPUSH
8509: LD_INT 0
8511: PPUSH
8512: CALL_OW 109
8516: GO 8727
// if tag <= attackFormula [ 1 ] then
8518: LD_VAR 0 4
8522: PUSH
8523: LD_VAR 0 6
8527: PUSH
8528: LD_INT 1
8530: ARRAY
8531: LESSEQUAL
8532: IFFALSE 8693
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 6
8543: PUSH
8544: LD_INT 1
8546: ARRAY
8547: PUSH
8548: LD_VAR 0 4
8552: ARRAY
8553: PUSH
8554: LD_INT 1
8556: ARRAY
8557: PPUSH
8558: LD_VAR 0 6
8562: PUSH
8563: LD_INT 1
8565: ARRAY
8566: PUSH
8567: LD_VAR 0 4
8571: ARRAY
8572: PUSH
8573: LD_INT 2
8575: ARRAY
8576: PPUSH
8577: CALL_OW 297
8581: PUSH
8582: LD_INT 6
8584: GREATER
8585: IFFALSE 8636
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8587: LD_VAR 0 2
8591: PPUSH
8592: LD_VAR 0 6
8596: PUSH
8597: LD_INT 1
8599: ARRAY
8600: PUSH
8601: LD_VAR 0 4
8605: ARRAY
8606: PUSH
8607: LD_INT 1
8609: ARRAY
8610: PPUSH
8611: LD_VAR 0 6
8615: PUSH
8616: LD_INT 1
8618: ARRAY
8619: PUSH
8620: LD_VAR 0 4
8624: ARRAY
8625: PUSH
8626: LD_INT 2
8628: ARRAY
8629: PPUSH
8630: CALL_OW 114
8634: GO 8691
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8636: LD_INT 81
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: PUSH
8646: LD_INT 91
8648: PUSH
8649: LD_VAR 0 2
8653: PUSH
8654: LD_INT 10
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: LIST
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PPUSH
8666: CALL_OW 69
8670: NOT
8671: IFFALSE 8691
// SetTag ( i , tag + 1 ) ;
8673: LD_VAR 0 2
8677: PPUSH
8678: LD_VAR 0 4
8682: PUSH
8683: LD_INT 1
8685: PLUS
8686: PPUSH
8687: CALL_OW 109
// end else
8691: GO 8727
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8693: LD_VAR 0 2
8697: PPUSH
8698: LD_INT 81
8700: PUSH
8701: LD_INT 1
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PPUSH
8708: CALL_OW 69
8712: PPUSH
8713: LD_VAR 0 2
8717: PPUSH
8718: CALL_OW 74
8722: PPUSH
8723: CALL_OW 115
// end ; end ;
8727: GO 8348
8729: POP
8730: POP
// end ; if sci then
8731: LD_VAR 0 8
8735: IFFALSE 8894
// begin if not sol and not mech then
8737: LD_VAR 0 7
8741: NOT
8742: PUSH
8743: LD_VAR 0 9
8747: NOT
8748: AND
8749: IFFALSE 8801
// begin for i in sci do
8751: LD_ADDR_VAR 0 2
8755: PUSH
8756: LD_VAR 0 8
8760: PUSH
8761: FOR_IN
8762: IFFALSE 8797
// begin usForces := usForces union i ;
8764: LD_ADDR_EXP 40
8768: PUSH
8769: LD_EXP 40
8773: PUSH
8774: LD_VAR 0 2
8778: UNION
8779: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8780: LD_VAR 0 2
8784: PPUSH
8785: LD_INT 34
8787: PPUSH
8788: LD_INT 68
8790: PPUSH
8791: CALL_OW 111
// end ;
8795: GO 8761
8797: POP
8798: POP
// end else
8799: GO 8894
// for i in sci do
8801: LD_ADDR_VAR 0 2
8805: PUSH
8806: LD_VAR 0 8
8810: PUSH
8811: FOR_IN
8812: IFFALSE 8892
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8814: LD_VAR 0 2
8818: PPUSH
8819: LD_VAR 0 6
8823: PUSH
8824: LD_INT 2
8826: ARRAY
8827: PUSH
8828: LD_INT 1
8830: ARRAY
8831: PPUSH
8832: LD_VAR 0 6
8836: PUSH
8837: LD_INT 2
8839: ARRAY
8840: PUSH
8841: LD_INT 2
8843: ARRAY
8844: PPUSH
8845: CALL_OW 297
8849: PUSH
8850: LD_INT 8
8852: GREATER
8853: IFFALSE 8890
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8855: LD_VAR 0 2
8859: PPUSH
8860: LD_VAR 0 6
8864: PUSH
8865: LD_INT 2
8867: ARRAY
8868: PUSH
8869: LD_INT 1
8871: ARRAY
8872: PPUSH
8873: LD_VAR 0 6
8877: PUSH
8878: LD_INT 2
8880: ARRAY
8881: PUSH
8882: LD_INT 2
8884: ARRAY
8885: PPUSH
8886: CALL_OW 111
8890: GO 8811
8892: POP
8893: POP
// end ; if tanks and mech then
8894: LD_VAR 0 10
8898: PUSH
8899: LD_VAR 0 9
8903: AND
8904: IFFALSE 9509
// begin for i in mech do
8906: LD_ADDR_VAR 0 2
8910: PUSH
8911: LD_VAR 0 9
8915: PUSH
8916: FOR_IN
8917: IFFALSE 9507
// begin tag := GetTag ( i ) ;
8919: LD_ADDR_VAR 0 4
8923: PUSH
8924: LD_VAR 0 2
8928: PPUSH
8929: CALL_OW 110
8933: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8934: LD_ADDR_VAR 0 11
8938: PUSH
8939: LD_VAR 0 2
8943: PPUSH
8944: CALL_OW 310
8948: ST_TO_ADDR
// if not tag then
8949: LD_VAR 0 4
8953: NOT
8954: IFFALSE 9267
// begin if veh then
8956: LD_VAR 0 11
8960: IFFALSE 9109
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
8962: LD_VAR 0 11
8966: PPUSH
8967: CALL_OW 256
8971: PUSH
8972: LD_INT 1000
8974: EQUAL
8975: PUSH
8976: LD_VAR 0 11
8980: PPUSH
8981: CALL_OW 261
8985: PUSH
8986: LD_INT 60
8988: GREATER
8989: AND
8990: IFFALSE 9006
// SetTag ( i , 1 ) else
8992: LD_VAR 0 2
8996: PPUSH
8997: LD_INT 1
8999: PPUSH
9000: CALL_OW 109
9004: GO 9107
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
9006: LD_VAR 0 2
9010: PPUSH
9011: LD_VAR 0 6
9015: PUSH
9016: LD_INT 3
9018: ARRAY
9019: PUSH
9020: LD_INT 1
9022: ARRAY
9023: PPUSH
9024: LD_VAR 0 6
9028: PUSH
9029: LD_INT 3
9031: ARRAY
9032: PUSH
9033: LD_INT 2
9035: ARRAY
9036: PPUSH
9037: CALL_OW 297
9041: PUSH
9042: LD_INT 7
9044: GREATER
9045: IFFALSE 9084
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
9047: LD_VAR 0 2
9051: PPUSH
9052: LD_VAR 0 6
9056: PUSH
9057: LD_INT 3
9059: ARRAY
9060: PUSH
9061: LD_INT 1
9063: ARRAY
9064: PPUSH
9065: LD_VAR 0 6
9069: PUSH
9070: LD_INT 3
9072: ARRAY
9073: PUSH
9074: LD_INT 2
9076: ARRAY
9077: PPUSH
9078: CALL_OW 111
9082: GO 9107
// begin ComExitVehicle ( i ) ;
9084: LD_VAR 0 2
9088: PPUSH
9089: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
9093: LD_VAR 0 2
9097: PPUSH
9098: LD_VAR 0 11
9102: PPUSH
9103: CALL_OW 189
// end ; end else
9107: GO 9265
// if GetLives ( i ) < 700 then
9109: LD_VAR 0 2
9113: PPUSH
9114: CALL_OW 256
9118: PUSH
9119: LD_INT 700
9121: LESS
9122: IFFALSE 9173
// begin usAttackers := usAttackers diff i ;
9124: LD_ADDR_EXP 43
9128: PUSH
9129: LD_EXP 43
9133: PUSH
9134: LD_VAR 0 2
9138: DIFF
9139: ST_TO_ADDR
// usForces := usForces union i ;
9140: LD_ADDR_EXP 40
9144: PUSH
9145: LD_EXP 40
9149: PUSH
9150: LD_VAR 0 2
9154: UNION
9155: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9156: LD_VAR 0 2
9160: PPUSH
9161: LD_INT 34
9163: PPUSH
9164: LD_INT 68
9166: PPUSH
9167: CALL_OW 111
// end else
9171: GO 9265
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9173: LD_VAR 0 10
9177: PPUSH
9178: LD_INT 58
9180: PUSH
9181: EMPTY
9182: LIST
9183: PUSH
9184: LD_INT 24
9186: PUSH
9187: LD_INT 1000
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: PUSH
9194: EMPTY
9195: LIST
9196: LIST
9197: PPUSH
9198: CALL_OW 72
9202: PUSH
9203: LD_VAR 0 2
9207: PPUSH
9208: CALL_OW 314
9212: NOT
9213: AND
9214: IFFALSE 9265
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9216: LD_VAR 0 2
9220: PPUSH
9221: LD_VAR 0 10
9225: PPUSH
9226: LD_INT 58
9228: PUSH
9229: EMPTY
9230: LIST
9231: PUSH
9232: LD_INT 24
9234: PUSH
9235: LD_INT 1000
9237: PUSH
9238: EMPTY
9239: LIST
9240: LIST
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: PPUSH
9246: CALL_OW 72
9250: PPUSH
9251: LD_VAR 0 2
9255: PPUSH
9256: CALL_OW 74
9260: PPUSH
9261: CALL_OW 120
// end else
9265: GO 9505
// begin if GetLives ( veh ) < 620 then
9267: LD_VAR 0 11
9271: PPUSH
9272: CALL_OW 256
9276: PUSH
9277: LD_INT 620
9279: LESS
9280: IFFALSE 9296
// SetTag ( i , 0 ) else
9282: LD_VAR 0 2
9286: PPUSH
9287: LD_INT 0
9289: PPUSH
9290: CALL_OW 109
9294: GO 9505
// if tag <= attackFormula [ 4 ] then
9296: LD_VAR 0 4
9300: PUSH
9301: LD_VAR 0 6
9305: PUSH
9306: LD_INT 4
9308: ARRAY
9309: LESSEQUAL
9310: IFFALSE 9471
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9312: LD_VAR 0 2
9316: PPUSH
9317: LD_VAR 0 6
9321: PUSH
9322: LD_INT 4
9324: ARRAY
9325: PUSH
9326: LD_VAR 0 4
9330: ARRAY
9331: PUSH
9332: LD_INT 1
9334: ARRAY
9335: PPUSH
9336: LD_VAR 0 6
9340: PUSH
9341: LD_INT 4
9343: ARRAY
9344: PUSH
9345: LD_VAR 0 4
9349: ARRAY
9350: PUSH
9351: LD_INT 2
9353: ARRAY
9354: PPUSH
9355: CALL_OW 297
9359: PUSH
9360: LD_INT 6
9362: GREATER
9363: IFFALSE 9414
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9365: LD_VAR 0 2
9369: PPUSH
9370: LD_VAR 0 6
9374: PUSH
9375: LD_INT 4
9377: ARRAY
9378: PUSH
9379: LD_VAR 0 4
9383: ARRAY
9384: PUSH
9385: LD_INT 1
9387: ARRAY
9388: PPUSH
9389: LD_VAR 0 6
9393: PUSH
9394: LD_INT 4
9396: ARRAY
9397: PUSH
9398: LD_VAR 0 4
9402: ARRAY
9403: PUSH
9404: LD_INT 2
9406: ARRAY
9407: PPUSH
9408: CALL_OW 114
9412: GO 9469
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9414: LD_INT 81
9416: PUSH
9417: LD_INT 1
9419: PUSH
9420: EMPTY
9421: LIST
9422: LIST
9423: PUSH
9424: LD_INT 91
9426: PUSH
9427: LD_VAR 0 2
9431: PUSH
9432: LD_INT 10
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: LIST
9439: PUSH
9440: EMPTY
9441: LIST
9442: LIST
9443: PPUSH
9444: CALL_OW 69
9448: NOT
9449: IFFALSE 9469
// SetTag ( i , tag + 1 ) ;
9451: LD_VAR 0 2
9455: PPUSH
9456: LD_VAR 0 4
9460: PUSH
9461: LD_INT 1
9463: PLUS
9464: PPUSH
9465: CALL_OW 109
// end else
9469: GO 9505
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9471: LD_VAR 0 2
9475: PPUSH
9476: LD_INT 81
9478: PUSH
9479: LD_INT 1
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: PPUSH
9486: CALL_OW 69
9490: PPUSH
9491: LD_VAR 0 2
9495: PPUSH
9496: CALL_OW 74
9500: PPUSH
9501: CALL_OW 115
// end ; end ;
9505: GO 8916
9507: POP
9508: POP
// end ; until not usAttackers ;
9509: LD_EXP 43
9513: NOT
9514: IFFALSE 8225
// end ;
9516: LD_VAR 0 1
9520: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do var i ;
9521: LD_INT 22
9523: PUSH
9524: LD_INT 1
9526: PUSH
9527: EMPTY
9528: LIST
9529: LIST
9530: PUSH
9531: LD_INT 32
9533: PUSH
9534: LD_INT 1
9536: PUSH
9537: EMPTY
9538: LIST
9539: LIST
9540: PUSH
9541: EMPTY
9542: LIST
9543: LIST
9544: PPUSH
9545: CALL_OW 69
9549: IFFALSE 9626
9551: GO 9553
9553: DISABLE
9554: LD_INT 0
9556: PPUSH
// begin enable ;
9557: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do
9558: LD_ADDR_VAR 0 1
9562: PUSH
9563: LD_INT 22
9565: PUSH
9566: LD_INT 1
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: PUSH
9573: LD_INT 32
9575: PUSH
9576: LD_INT 1
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: PPUSH
9587: CALL_OW 69
9591: PUSH
9592: FOR_IN
9593: IFFALSE 9624
// if GetFuel ( i ) < 10 then
9595: LD_VAR 0 1
9599: PPUSH
9600: CALL_OW 261
9604: PUSH
9605: LD_INT 10
9607: LESS
9608: IFFALSE 9622
// SetFuel ( i , 10 ) ;
9610: LD_VAR 0 1
9614: PPUSH
9615: LD_INT 10
9617: PPUSH
9618: CALL_OW 240
9622: GO 9592
9624: POP
9625: POP
// end ; end_of_file
9626: PPOPN 1
9628: END
// export function Action ; var hasAll , i , tmp ; begin
9629: LD_INT 0
9631: PPUSH
9632: PPUSH
9633: PPUSH
9634: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9635: LD_ADDR_VAR 0 2
9639: PUSH
9640: LD_INT 22
9642: PUSH
9643: LD_INT 2
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 21
9652: PUSH
9653: LD_INT 1
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: LD_INT 23
9662: PUSH
9663: LD_INT 2
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: LIST
9674: PPUSH
9675: CALL_OW 69
9679: PUSH
9680: LD_INT 7
9682: GREATEREQUAL
9683: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9684: LD_VAR 0 2
9688: PPUSH
9689: LD_STRING 03_HasAll
9691: PPUSH
9692: CALL_OW 39
// Video ( true ) ;
9696: LD_INT 1
9698: PPUSH
9699: CALL 1004 0 1
// CenterNowOnUnits ( Heike ) ;
9703: LD_EXP 24
9707: PPUSH
9708: CALL_OW 87
// wait ( 0 0$2 ) ;
9712: LD_INT 70
9714: PPUSH
9715: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9719: LD_EXP 32
9723: PPUSH
9724: LD_STRING DF-1-start
9726: PPUSH
9727: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9731: LD_EXP 24
9735: PPUSH
9736: LD_EXP 32
9740: PPUSH
9741: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9745: LD_EXP 24
9749: PPUSH
9750: LD_STRING DH-1-start
9752: PPUSH
9753: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9757: LD_EXP 33
9761: PPUSH
9762: LD_INT 92
9764: PPUSH
9765: LD_INT 21
9767: PPUSH
9768: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9772: LD_EXP 28
9776: PPUSH
9777: LD_INT 94
9779: PPUSH
9780: LD_INT 23
9782: PPUSH
9783: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9787: LD_EXP 36
9791: PUSH
9792: LD_INT 1
9794: ARRAY
9795: PPUSH
9796: LD_INT 90
9798: PPUSH
9799: LD_INT 23
9801: PPUSH
9802: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9806: LD_EXP 36
9810: PUSH
9811: LD_INT 2
9813: ARRAY
9814: PPUSH
9815: LD_INT 93
9817: PPUSH
9818: LD_INT 25
9820: PPUSH
9821: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9825: LD_EXP 36
9829: PPUSH
9830: LD_EXP 33
9834: PPUSH
9835: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9839: LD_EXP 33
9843: PUSH
9844: LD_EXP 28
9848: PUSH
9849: EMPTY
9850: LIST
9851: LIST
9852: PPUSH
9853: LD_EXP 24
9857: PPUSH
9858: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9862: LD_EXP 24
9866: PPUSH
9867: LD_EXP 33
9871: PPUSH
9872: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9876: LD_INT 35
9878: PPUSH
9879: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9883: LD_EXP 33
9887: PPUSH
9888: LD_INT 92
9890: PPUSH
9891: LD_INT 21
9893: PPUSH
9894: CALL_OW 307
9898: IFFALSE 9876
// Say ( Omar , DO-1-start ) ;
9900: LD_EXP 33
9904: PPUSH
9905: LD_STRING DO-1-start
9907: PPUSH
9908: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9912: LD_EXP 24
9916: PPUSH
9917: LD_STRING DH-2-start
9919: PPUSH
9920: CALL_OW 88
// if hasAll then
9924: LD_VAR 0 2
9928: IFFALSE 10056
// begin Say ( Omar , DO-2-start ) ;
9930: LD_EXP 33
9934: PPUSH
9935: LD_STRING DO-2-start
9937: PPUSH
9938: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9942: LD_EXP 33
9946: PPUSH
9947: LD_STRING DO-3-start
9949: PPUSH
9950: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
9954: LD_EXP 24
9958: PPUSH
9959: LD_STRING DH-3-start
9961: PPUSH
9962: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
9966: LD_EXP 32
9970: PPUSH
9971: LD_STRING DF-2-start
9973: PPUSH
9974: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9978: LD_EXP 33
9982: PPUSH
9983: LD_EXP 32
9987: PPUSH
9988: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
9992: LD_EXP 33
9996: PPUSH
9997: LD_STRING DO-4-start
9999: PPUSH
10000: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
10004: LD_EXP 32
10008: PPUSH
10009: LD_STRING DF-3-start
10011: PPUSH
10012: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
10016: LD_EXP 33
10020: PPUSH
10021: LD_STRING DO-5-start
10023: PPUSH
10024: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
10028: LD_EXP 32
10032: PPUSH
10033: LD_STRING DF-4-start
10035: PPUSH
10036: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10040: LD_EXP 33
10044: PPUSH
10045: LD_EXP 24
10049: PPUSH
10050: CALL_OW 119
// end else
10054: GO 10156
// begin Say ( Omar , DO-2-start-a ) ;
10056: LD_EXP 33
10060: PPUSH
10061: LD_STRING DO-2-start-a
10063: PPUSH
10064: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
10068: LD_EXP 33
10072: PPUSH
10073: LD_STRING DO-3-start-a
10075: PPUSH
10076: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
10080: LD_EXP 24
10084: PPUSH
10085: LD_STRING DH-3-start-a
10087: PPUSH
10088: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
10092: LD_EXP 32
10096: PPUSH
10097: LD_STRING DF-2-start-a
10099: PPUSH
10100: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10104: LD_EXP 33
10108: PPUSH
10109: LD_EXP 32
10113: PPUSH
10114: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
10118: LD_EXP 33
10122: PPUSH
10123: LD_STRING DO-4-start-a
10125: PPUSH
10126: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
10130: LD_EXP 32
10134: PPUSH
10135: LD_STRING DF-3-start-a
10137: PPUSH
10138: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10142: LD_EXP 33
10146: PPUSH
10147: LD_EXP 24
10151: PPUSH
10152: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
10156: LD_INT 10
10158: PPUSH
10159: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
10163: LD_EXP 33
10167: PPUSH
10168: LD_STRING DO-1-mission
10170: PPUSH
10171: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
10175: LD_EXP 33
10179: PPUSH
10180: LD_STRING DO-2-mission
10182: PPUSH
10183: CALL_OW 88
// if not hasAll then
10187: LD_VAR 0 2
10191: NOT
10192: IFFALSE 10206
// Say ( Omar , DO-3-mission ) ;
10194: LD_EXP 33
10198: PPUSH
10199: LD_STRING DO-3-mission
10201: PPUSH
10202: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
10206: LD_EXP 33
10210: PPUSH
10211: LD_STRING DO-4-mission
10213: PPUSH
10214: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
10218: LD_EXP 24
10222: PPUSH
10223: LD_STRING DH-1-mission
10225: PPUSH
10226: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10230: LD_EXP 32
10234: PPUSH
10235: LD_STRING DF-1-mission
10237: PPUSH
10238: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10242: LD_EXP 33
10246: PPUSH
10247: LD_STRING DO-5-mission
10249: PPUSH
10250: CALL_OW 88
// if not hasAll then
10254: LD_VAR 0 2
10258: NOT
10259: IFFALSE 10394
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10261: LD_ADDR_VAR 0 4
10265: PUSH
10266: LD_INT 22
10268: PUSH
10269: LD_INT 2
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: PUSH
10276: LD_INT 21
10278: PUSH
10279: LD_INT 1
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: PUSH
10286: LD_INT 23
10288: PUSH
10289: LD_INT 2
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: LIST
10300: PPUSH
10301: CALL_OW 69
10305: ST_TO_ADDR
// for i := 7 downto tmp do
10306: LD_ADDR_VAR 0 3
10310: PUSH
10311: DOUBLE
10312: LD_INT 7
10314: INC
10315: ST_TO_ADDR
10316: LD_VAR 0 4
10320: PUSH
10321: FOR_DOWNTO
10322: IFFALSE 10392
// begin if omarSquad < 3 then
10324: LD_EXP 36
10328: PUSH
10329: LD_INT 3
10331: LESS
10332: IFFALSE 10336
// break ;
10334: GO 10392
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10336: LD_EXP 36
10340: PUSH
10341: LD_INT 3
10343: ARRAY
10344: PPUSH
10345: LD_INT 2
10347: PPUSH
10348: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10352: LD_ADDR_EXP 38
10356: PUSH
10357: LD_EXP 38
10361: PUSH
10362: LD_EXP 36
10366: PUSH
10367: LD_INT 3
10369: ARRAY
10370: UNION
10371: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10372: LD_ADDR_EXP 36
10376: PUSH
10377: LD_EXP 36
10381: PPUSH
10382: LD_INT 3
10384: PPUSH
10385: CALL_OW 3
10389: ST_TO_ADDR
// end ;
10390: GO 10321
10392: POP
10393: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10394: LD_EXP 33
10398: PUSH
10399: LD_EXP 36
10403: ADD
10404: PPUSH
10405: LD_INT 103
10407: PPUSH
10408: LD_INT 9
10410: PPUSH
10411: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10415: LD_VAR 0 2
10419: PUSH
10420: LD_EXP 29
10424: PPUSH
10425: CALL_OW 302
10429: AND
10430: IFFALSE 10491
// begin wait ( 0 0$3 ) ;
10432: LD_INT 105
10434: PPUSH
10435: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10439: LD_EXP 29
10443: PPUSH
10444: LD_EXP 32
10448: PPUSH
10449: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10453: LD_EXP 29
10457: PPUSH
10458: LD_STRING DK-1-side
10460: PPUSH
10461: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10465: LD_EXP 32
10469: PPUSH
10470: LD_EXP 29
10474: PPUSH
10475: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10479: LD_EXP 32
10483: PPUSH
10484: LD_STRING DF-1-side
10486: PPUSH
10487: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10491: LD_INT 22
10493: PUSH
10494: LD_INT 2
10496: PUSH
10497: EMPTY
10498: LIST
10499: LIST
10500: PPUSH
10501: CALL_OW 69
10505: PPUSH
10506: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10510: LD_EXP 32
10514: PUSH
10515: LD_EXP 35
10519: ADD
10520: PPUSH
10521: LD_INT 108
10523: PPUSH
10524: LD_INT 62
10526: PPUSH
10527: CALL_OW 111
// gameStarted := true ;
10531: LD_ADDR_EXP 3
10535: PUSH
10536: LD_INT 1
10538: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10539: LD_INT 105
10541: PPUSH
10542: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10546: LD_EXP 24
10550: PPUSH
10551: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10555: LD_EXP 24
10559: PPUSH
10560: LD_EXP 28
10564: PPUSH
10565: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10569: LD_INT 22
10571: PUSH
10572: LD_INT 2
10574: PUSH
10575: EMPTY
10576: LIST
10577: LIST
10578: PPUSH
10579: CALL_OW 69
10583: PUSH
10584: LD_EXP 24
10588: DIFF
10589: PPUSH
10590: LD_EXP 24
10594: PPUSH
10595: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10599: LD_EXP 24
10603: PPUSH
10604: LD_STRING DH-1-explore
10606: PPUSH
10607: CALL_OW 88
// if Givi then
10611: LD_EXP 25
10615: IFFALSE 10631
// Say ( Givi , DG-1-explore ) else
10617: LD_EXP 25
10621: PPUSH
10622: LD_STRING DG-1-explore
10624: PPUSH
10625: CALL_OW 88
10629: GO 10668
// if heikeSecondSquad then
10631: LD_EXP 38
10635: IFFALSE 10668
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10637: LD_EXP 38
10641: PPUSH
10642: LD_INT 26
10644: PUSH
10645: LD_INT 1
10647: PUSH
10648: EMPTY
10649: LIST
10650: LIST
10651: PPUSH
10652: CALL_OW 72
10656: PUSH
10657: LD_INT 1
10659: ARRAY
10660: PPUSH
10661: LD_STRING DArm-1-explore
10663: PPUSH
10664: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10668: LD_EXP 28
10672: PPUSH
10673: LD_STRING DA-1-explore
10675: PPUSH
10676: CALL_OW 88
// if Sophia then
10680: LD_EXP 30
10684: IFFALSE 10762
// begin Say ( Sophia , DS-2-explore ) ;
10686: LD_EXP 30
10690: PPUSH
10691: LD_STRING DS-2-explore
10693: PPUSH
10694: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10698: LD_EXP 28
10702: PPUSH
10703: LD_STRING DA-2-explore
10705: PPUSH
10706: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10710: LD_EXP 30
10714: PPUSH
10715: LD_EXP 28
10719: PPUSH
10720: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10724: LD_EXP 28
10728: PPUSH
10729: LD_EXP 30
10733: PPUSH
10734: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10738: LD_EXP 30
10742: PPUSH
10743: LD_STRING DS-3-explore
10745: PPUSH
10746: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10750: LD_EXP 28
10754: PPUSH
10755: LD_STRING DA-3-explore
10757: PPUSH
10758: CALL_OW 88
// end ; if Mike then
10762: LD_EXP 26
10766: IFFALSE 10822
// begin Say ( Mike , DM-1-explore ) ;
10768: LD_EXP 26
10772: PPUSH
10773: LD_STRING DM-1-explore
10775: PPUSH
10776: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10780: LD_EXP 24
10784: PPUSH
10785: LD_STRING DH-2-explore
10787: PPUSH
10788: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10792: LD_EXP 26
10796: PPUSH
10797: LD_STRING DM-2-explore
10799: PPUSH
10800: CALL_OW 88
// if Kaia then
10804: LD_EXP 29
10808: IFFALSE 10822
// Say ( Kaia , DK-1-explore ) ;
10810: LD_EXP 29
10814: PPUSH
10815: LD_STRING DK-1-explore
10817: PPUSH
10818: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10822: LD_INT 22
10824: PUSH
10825: LD_INT 2
10827: PUSH
10828: EMPTY
10829: LIST
10830: LIST
10831: PPUSH
10832: CALL_OW 69
10836: PPUSH
10837: CALL_OW 139
// Video ( false ) ;
10841: LD_INT 0
10843: PPUSH
10844: CALL 1004 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10848: LD_STRING BuildBase
10850: PPUSH
10851: CALL_OW 337
// SaveForQuickRestart ;
10855: CALL_OW 22
// end ;
10859: LD_VAR 0 1
10863: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10864: LD_EXP 5
10868: NOT
10869: PUSH
10870: LD_EXP 6
10874: NOT
10875: AND
10876: PUSH
10877: LD_INT 5
10879: PPUSH
10880: LD_INT 22
10882: PUSH
10883: LD_INT 2
10885: PUSH
10886: EMPTY
10887: LIST
10888: LIST
10889: PPUSH
10890: CALL_OW 70
10894: AND
10895: PUSH
10896: LD_EXP 6
10900: NOT
10901: AND
10902: IFFALSE 10987
10904: GO 10906
10906: DISABLE
// begin if Mike then
10907: LD_EXP 26
10911: IFFALSE 10927
// Say ( Mike , DM-1-scout ) else
10913: LD_EXP 26
10917: PPUSH
10918: LD_STRING DM-1-scout
10920: PPUSH
10921: CALL_OW 88
10925: GO 10958
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10927: LD_EXP 38
10931: PPUSH
10932: LD_INT 26
10934: PUSH
10935: LD_INT 1
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PPUSH
10942: CALL_OW 72
10946: PUSH
10947: LD_INT 1
10949: ARRAY
10950: PPUSH
10951: LD_STRING DArm-1-explore
10953: PPUSH
10954: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
10958: LD_INT 54
10960: PPUSH
10961: LD_INT 35
10963: PPUSH
10964: LD_INT 2
10966: PPUSH
10967: LD_INT 1
10969: PPUSH
10970: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
10974: LD_INT 54
10976: PPUSH
10977: LD_INT 35
10979: PPUSH
10980: LD_INT 2
10982: PPUSH
10983: CALL_OW 331
// end ;
10987: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
10988: LD_INT 6
10990: PPUSH
10991: LD_INT 22
10993: PUSH
10994: LD_INT 2
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: PPUSH
11001: CALL_OW 70
11005: PUSH
11006: LD_EXP 6
11010: NOT
11011: AND
11012: IFFALSE 11266
11014: GO 11016
11016: DISABLE
11017: LD_INT 0
11019: PPUSH
11020: PPUSH
11021: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11022: LD_ADDR_VAR 0 1
11026: PUSH
11027: LD_EXP 38
11031: PPUSH
11032: LD_INT 26
11034: PUSH
11035: LD_INT 1
11037: PUSH
11038: EMPTY
11039: LIST
11040: LIST
11041: PPUSH
11042: CALL_OW 72
11046: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
11047: LD_ADDR_VAR 0 2
11051: PUSH
11052: LD_EXP 38
11056: PPUSH
11057: LD_INT 26
11059: PUSH
11060: LD_INT 2
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PPUSH
11067: CALL_OW 72
11071: ST_TO_ADDR
// DialogueOn ;
11072: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
11076: LD_INT 36
11078: PPUSH
11079: LD_INT 22
11081: PPUSH
11082: LD_INT 2
11084: PPUSH
11085: LD_INT 8
11087: PPUSH
11088: CALL_OW 330
// dwait ( 0 0$1 ) ;
11092: LD_INT 35
11094: PPUSH
11095: CALL_OW 68
// speakerOk := false ;
11099: LD_ADDR_VAR 0 3
11103: PUSH
11104: LD_INT 0
11106: ST_TO_ADDR
// if Mike then
11107: LD_EXP 26
11111: IFFALSE 11133
// speakerOk := Say ( Mike , DM-1-spot ) else
11113: LD_ADDR_VAR 0 3
11117: PUSH
11118: LD_EXP 26
11122: PPUSH
11123: LD_STRING DM-1-spot
11125: PPUSH
11126: CALL_OW 88
11130: ST_TO_ADDR
11131: GO 11161
// if randomMen then
11133: LD_VAR 0 1
11137: IFFALSE 11161
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11139: LD_ADDR_VAR 0 3
11143: PUSH
11144: LD_VAR 0 1
11148: PUSH
11149: LD_INT 1
11151: ARRAY
11152: PPUSH
11153: LD_STRING DArm-1-spot-a
11155: PPUSH
11156: CALL_OW 88
11160: ST_TO_ADDR
// if speakerOk then
11161: LD_VAR 0 3
11165: IFFALSE 11209
// begin if Givi then
11167: LD_EXP 25
11171: IFFALSE 11187
// Say ( Givi , DG-1-spot ) else
11173: LD_EXP 25
11177: PPUSH
11178: LD_STRING DG-1-spot
11180: PPUSH
11181: CALL_OW 88
11185: GO 11209
// if randomWomen then
11187: LD_VAR 0 2
11191: IFFALSE 11209
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
11193: LD_VAR 0 2
11197: PUSH
11198: LD_INT 1
11200: ARRAY
11201: PPUSH
11202: LD_STRING DArf-1-spot-a
11204: PPUSH
11205: CALL_OW 88
// end ; if Mike then
11209: LD_EXP 26
11213: IFFALSE 11229
// Say ( Heike , DH-1-spot ) else
11215: LD_EXP 24
11219: PPUSH
11220: LD_STRING DH-1-spot
11222: PPUSH
11223: CALL_OW 88
11227: GO 11241
// Say ( Heike , DH-1-spot-a ) ;
11229: LD_EXP 24
11233: PPUSH
11234: LD_STRING DH-1-spot-a
11236: PPUSH
11237: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11241: LD_INT 36
11243: PPUSH
11244: LD_INT 22
11246: PPUSH
11247: LD_INT 2
11249: PPUSH
11250: CALL_OW 331
// DialogueOff ;
11254: CALL_OW 7
// americanBaseSpoted := true ;
11258: LD_ADDR_EXP 5
11262: PUSH
11263: LD_INT 1
11265: ST_TO_ADDR
// end ;
11266: PPOPN 3
11268: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11269: LD_EXP 5
11273: NOT
11274: PUSH
11275: LD_INT 22
11277: PUSH
11278: LD_INT 2
11280: PUSH
11281: EMPTY
11282: LIST
11283: LIST
11284: PUSH
11285: LD_INT 101
11287: PUSH
11288: LD_INT 1
11290: PUSH
11291: EMPTY
11292: LIST
11293: LIST
11294: PUSH
11295: EMPTY
11296: LIST
11297: LIST
11298: PPUSH
11299: CALL_OW 69
11303: AND
11304: PUSH
11305: LD_EXP 6
11309: NOT
11310: AND
11311: IFFALSE 11397
11313: GO 11315
11315: DISABLE
11316: LD_INT 0
11318: PPUSH
// begin americanBaseSpoted := true ;
11319: LD_ADDR_EXP 5
11323: PUSH
11324: LD_INT 1
11326: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11327: LD_ADDR_VAR 0 1
11331: PUSH
11332: LD_EXP 38
11336: PPUSH
11337: LD_INT 26
11339: PUSH
11340: LD_INT 1
11342: PUSH
11343: EMPTY
11344: LIST
11345: LIST
11346: PPUSH
11347: CALL_OW 72
11351: ST_TO_ADDR
// if not randomMen then
11352: LD_VAR 0 1
11356: NOT
11357: IFFALSE 11361
// exit ;
11359: GO 11397
// DialogueOn ;
11361: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11365: LD_VAR 0 1
11369: PUSH
11370: LD_INT 1
11372: ARRAY
11373: PPUSH
11374: LD_STRING DArm-1-spot-a
11376: PPUSH
11377: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11381: LD_EXP 24
11385: PPUSH
11386: LD_STRING DH-1-spot-a
11388: PPUSH
11389: CALL_OW 88
// DialogueOff ;
11393: CALL_OW 7
// end ;
11397: PPOPN 1
11399: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) do var i , p ;
11400: LD_INT 11
11402: PPUSH
11403: CALL_OW 255
11407: PUSH
11408: LD_INT 2
11410: EQUAL
11411: PUSH
11412: LD_INT 7
11414: PPUSH
11415: LD_INT 22
11417: PUSH
11418: LD_INT 1
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: PUSH
11425: LD_INT 3
11427: PUSH
11428: LD_INT 50
11430: PUSH
11431: EMPTY
11432: LIST
11433: PUSH
11434: EMPTY
11435: LIST
11436: LIST
11437: PUSH
11438: LD_INT 30
11440: PUSH
11441: LD_INT 31
11443: PUSH
11444: EMPTY
11445: LIST
11446: LIST
11447: PUSH
11448: EMPTY
11449: LIST
11450: LIST
11451: LIST
11452: PPUSH
11453: CALL_OW 70
11457: OR
11458: PUSH
11459: LD_INT 7
11461: PPUSH
11462: LD_INT 22
11464: PUSH
11465: LD_INT 2
11467: PUSH
11468: EMPTY
11469: LIST
11470: LIST
11471: PPUSH
11472: CALL_OW 70
11476: PUSH
11477: LD_INT 1
11479: GREATER
11480: OR
11481: PUSH
11482: LD_INT 6
11484: PPUSH
11485: LD_INT 22
11487: PUSH
11488: LD_INT 2
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: PPUSH
11495: CALL_OW 70
11499: OR
11500: IFFALSE 12043
11502: GO 11504
11504: DISABLE
11505: LD_INT 0
11507: PPUSH
11508: PPUSH
// begin americanBaseCaptured := true ;
11509: LD_ADDR_EXP 6
11513: PUSH
11514: LD_INT 1
11516: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11517: LD_INT 105
11519: PPUSH
11520: CALL_OW 67
// if IsOk ( usCommander ) then
11524: LD_EXP 41
11528: PPUSH
11529: CALL_OW 302
11533: IFFALSE 11596
// begin usForces := usForces union usCommander ;
11535: LD_ADDR_EXP 40
11539: PUSH
11540: LD_EXP 40
11544: PUSH
11545: LD_EXP 41
11549: UNION
11550: ST_TO_ADDR
// if FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) then
11551: LD_INT 6
11553: PPUSH
11554: LD_INT 22
11556: PUSH
11557: LD_INT 2
11559: PUSH
11560: EMPTY
11561: LIST
11562: LIST
11563: PPUSH
11564: CALL_OW 70
11568: IFFALSE 11584
// Say ( usCommander , DUsm-2-assault ) else
11570: LD_EXP 41
11574: PPUSH
11575: LD_STRING DUsm-2-assault
11577: PPUSH
11578: CALL_OW 88
11582: GO 11596
// Say ( usCommander , DUsm-1-assault ) ;
11584: LD_EXP 41
11588: PPUSH
11589: LD_STRING DUsm-1-assault
11591: PPUSH
11592: CALL_OW 88
// end ; for i in usForces do
11596: LD_ADDR_VAR 0 1
11600: PUSH
11601: LD_EXP 40
11605: PUSH
11606: FOR_IN
11607: IFFALSE 11653
// begin if IsInUnit ( i ) then
11609: LD_VAR 0 1
11613: PPUSH
11614: CALL_OW 310
11618: IFFALSE 11629
// ComExitBuilding ( i ) ;
11620: LD_VAR 0 1
11624: PPUSH
11625: CALL_OW 122
// wait ( 3 ) ;
11629: LD_INT 3
11631: PPUSH
11632: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11636: LD_VAR 0 1
11640: PPUSH
11641: LD_INT 34
11643: PPUSH
11644: LD_INT 67
11646: PPUSH
11647: CALL_OW 111
// end ;
11651: GO 11606
11653: POP
11654: POP
// Say ( Heike , DH-1-assault ) ;
11655: LD_EXP 24
11659: PPUSH
11660: LD_STRING DH-1-assault
11662: PPUSH
11663: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11667: LD_INT 35
11669: PPUSH
11670: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11674: LD_VAR 0 1
11678: PPUSH
11679: LD_INT 34
11681: PPUSH
11682: LD_INT 67
11684: PPUSH
11685: CALL_OW 111
// until not usForces ;
11689: LD_EXP 40
11693: NOT
11694: IFFALSE 11667
// music_nat := 2 ;
11696: LD_ADDR_OWVAR 71
11700: PUSH
11701: LD_INT 2
11703: ST_TO_ADDR
// music_class := music_victory ;
11704: LD_ADDR_OWVAR 72
11708: PUSH
11709: LD_INT 4
11711: ST_TO_ADDR
// if not americanHasEscaped then
11712: LD_EXP 7
11716: NOT
11717: IFFALSE 11731
// Say ( Heike , DH-2-assault ) ;
11719: LD_EXP 24
11723: PPUSH
11724: LD_STRING DH-2-assault
11726: PPUSH
11727: CALL_OW 88
// wait ( 0 0$2 ) ;
11731: LD_INT 70
11733: PPUSH
11734: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11738: LD_INT 35
11740: PPUSH
11741: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11745: LD_INT 22
11747: PUSH
11748: LD_INT 2
11750: PUSH
11751: EMPTY
11752: LIST
11753: LIST
11754: PUSH
11755: LD_INT 21
11757: PUSH
11758: LD_INT 1
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 3
11767: PUSH
11768: LD_INT 50
11770: PUSH
11771: EMPTY
11772: LIST
11773: PUSH
11774: EMPTY
11775: LIST
11776: LIST
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: LIST
11782: PPUSH
11783: CALL_OW 69
11787: NOT
11788: IFFALSE 11738
// Video ( true ) ;
11790: LD_INT 1
11792: PPUSH
11793: CALL 1004 0 1
// if not GetSide ( usDepot ) = 2 then
11797: LD_INT 11
11799: PPUSH
11800: CALL_OW 255
11804: PUSH
11805: LD_INT 2
11807: EQUAL
11808: NOT
11809: IFFALSE 11821
// SetSide ( usDepot , 2 ) ;
11811: LD_INT 11
11813: PPUSH
11814: LD_INT 2
11816: PPUSH
11817: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11821: LD_INT 35
11823: PPUSH
11824: LD_INT 22
11826: PPUSH
11827: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11831: LD_EXP 24
11835: PPUSH
11836: LD_INT 35
11838: PPUSH
11839: LD_INT 22
11841: PPUSH
11842: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11846: LD_EXP 24
11850: PPUSH
11851: LD_INT 38
11853: PPUSH
11854: LD_INT 25
11856: PPUSH
11857: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11861: LD_EXP 37
11865: PUSH
11866: LD_EXP 38
11870: UNION
11871: PPUSH
11872: LD_INT 39
11874: PPUSH
11875: LD_INT 26
11877: PPUSH
11878: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11882: LD_EXP 37
11886: PUSH
11887: LD_EXP 38
11891: UNION
11892: PPUSH
11893: LD_EXP 24
11897: PPUSH
11898: CALL_OW 179
// p := 0 ;
11902: LD_ADDR_VAR 0 2
11906: PUSH
11907: LD_INT 0
11909: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11910: LD_INT 35
11912: PPUSH
11913: CALL_OW 67
// p := p + 1 ;
11917: LD_ADDR_VAR 0 2
11921: PUSH
11922: LD_VAR 0 2
11926: PUSH
11927: LD_INT 1
11929: PLUS
11930: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11931: LD_EXP 24
11935: PPUSH
11936: CALL_OW 314
11940: NOT
11941: PUSH
11942: LD_VAR 0 2
11946: PUSH
11947: LD_INT 10
11949: GREATER
11950: OR
11951: IFFALSE 11910
// Say ( Heike , DH-1-capture ) ;
11953: LD_EXP 24
11957: PPUSH
11958: LD_STRING DH-1-capture
11960: PPUSH
11961: CALL_OW 88
// if Markov then
11965: LD_EXP 31
11969: IFFALSE 11983
// Say ( Markov , DMar-1-capture ) ;
11971: LD_EXP 31
11975: PPUSH
11976: LD_STRING DMar-1-capture
11978: PPUSH
11979: CALL_OW 88
// if Sophia then
11983: LD_EXP 30
11987: IFFALSE 12013
// begin Say ( Heike , DH-2-capture ) ;
11989: LD_EXP 24
11993: PPUSH
11994: LD_STRING DH-2-capture
11996: PPUSH
11997: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
12001: LD_EXP 30
12005: PPUSH
12006: LD_STRING DS-1-capture
12008: PPUSH
12009: CALL_OW 88
// end ; Video ( false ) ;
12013: LD_INT 0
12015: PPUSH
12016: CALL 1004 0 1
// music_nat := music_auto ;
12020: LD_ADDR_OWVAR 71
12024: PUSH
12025: LD_INT 0
12027: ST_TO_ADDR
// music_class := music_auto ;
12028: LD_ADDR_OWVAR 72
12032: PUSH
12033: LD_INT 0
12035: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
12036: LD_STRING ConstructBase
12038: PPUSH
12039: CALL_OW 337
// end ;
12043: PPOPN 2
12045: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
12046: LD_INT 22
12048: PUSH
12049: LD_INT 2
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PUSH
12056: LD_INT 30
12058: PUSH
12059: LD_INT 2
12061: PUSH
12062: EMPTY
12063: LIST
12064: LIST
12065: PUSH
12066: LD_INT 3
12068: PUSH
12069: LD_INT 57
12071: PUSH
12072: EMPTY
12073: LIST
12074: PUSH
12075: EMPTY
12076: LIST
12077: LIST
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: LIST
12083: PPUSH
12084: CALL_OW 69
12088: IFFALSE 12331
12090: GO 12092
12092: DISABLE
// begin workshopBuilded := true ;
12093: LD_ADDR_EXP 9
12097: PUSH
12098: LD_INT 1
12100: ST_TO_ADDR
// if IsOk ( Markov ) then
12101: LD_EXP 31
12105: PPUSH
12106: CALL_OW 302
12110: IFFALSE 12169
// begin Say ( Heike , DH-1-shop-a ) ;
12112: LD_EXP 24
12116: PPUSH
12117: LD_STRING DH-1-shop-a
12119: PPUSH
12120: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
12124: LD_INT 47
12126: PPUSH
12127: LD_INT 2
12129: PPUSH
12130: CALL_OW 321
12134: PUSH
12135: LD_INT 2
12137: EQUAL
12138: PUSH
12139: LD_INT 45
12141: PPUSH
12142: LD_INT 2
12144: PPUSH
12145: CALL_OW 321
12149: PUSH
12150: LD_INT 2
12152: EQUAL
12153: AND
12154: NOT
12155: IFFALSE 12169
// Say ( Markov , DMar-1-shop-a ) ;
12157: LD_EXP 31
12161: PPUSH
12162: LD_STRING DMar-1-shop-a
12164: PPUSH
12165: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
12169: LD_INT 35
12171: PPUSH
12172: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched or GetTech ( tech_SolEng , 2 ) = state_researched ;
12176: LD_INT 47
12178: PPUSH
12179: LD_INT 2
12181: PPUSH
12182: CALL_OW 321
12186: PUSH
12187: LD_INT 2
12189: EQUAL
12190: PUSH
12191: LD_INT 45
12193: PPUSH
12194: LD_INT 2
12196: PPUSH
12197: CALL_OW 321
12201: PUSH
12202: LD_INT 2
12204: EQUAL
12205: OR
12206: IFFALSE 12169
// DialogueOn ;
12208: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
12212: LD_EXP 31
12216: PPUSH
12217: LD_STRING DMar-1-shop
12219: PPUSH
12220: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
12224: LD_EXP 24
12228: PPUSH
12229: LD_STRING DH-1-shop
12231: PPUSH
12232: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12236: LD_EXP 31
12240: PPUSH
12241: LD_STRING DMar-2-shop
12243: PPUSH
12244: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12248: LD_EXP 31
12252: PPUSH
12253: LD_STRING DMar-3-shop
12255: PPUSH
12256: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12260: LD_EXP 24
12264: PPUSH
12265: LD_STRING DH-2-shop
12267: PPUSH
12268: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12272: LD_EXP 31
12276: PPUSH
12277: LD_STRING DMar-4-shop
12279: PPUSH
12280: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12284: LD_EXP 24
12288: PPUSH
12289: LD_STRING DH-3-shop
12291: PPUSH
12292: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12296: LD_EXP 31
12300: PPUSH
12301: LD_STRING DMar-5-shop
12303: PPUSH
12304: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12308: LD_EXP 24
12312: PPUSH
12313: LD_STRING DH-4-shop
12315: PPUSH
12316: CALL_OW 88
// DialogueOff ;
12320: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12324: LD_STRING ConstructVeh
12326: PPUSH
12327: CALL_OW 337
// end ;
12331: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12332: LD_INT 2
12334: PPUSH
12335: LD_INT 2
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL 1175 0 3
12345: PUSH
12346: LD_INT 0
12348: EQUAL
12349: IFFALSE 12361
12351: GO 12353
12353: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12354: LD_STRING Techs
12356: PPUSH
12357: CALL_OW 337
12361: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12362: LD_EXP 31
12366: PPUSH
12367: CALL_OW 302
12371: PUSH
12372: LD_INT 22
12374: PUSH
12375: LD_INT 2
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: PUSH
12382: LD_INT 2
12384: PUSH
12385: LD_INT 34
12387: PUSH
12388: LD_INT 22
12390: PUSH
12391: EMPTY
12392: LIST
12393: LIST
12394: PUSH
12395: LD_INT 35
12397: PUSH
12398: LD_INT 22
12400: PUSH
12401: EMPTY
12402: LIST
12403: LIST
12404: PUSH
12405: EMPTY
12406: LIST
12407: LIST
12408: LIST
12409: PUSH
12410: EMPTY
12411: LIST
12412: LIST
12413: PPUSH
12414: CALL_OW 69
12418: AND
12419: IFFALSE 12526
12421: GO 12423
12423: DISABLE
// begin DialogueOn ;
12424: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12428: LD_INT 22
12430: PUSH
12431: LD_INT 2
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: LD_INT 2
12440: PUSH
12441: LD_INT 34
12443: PUSH
12444: LD_INT 22
12446: PUSH
12447: EMPTY
12448: LIST
12449: LIST
12450: PUSH
12451: LD_INT 35
12453: PUSH
12454: LD_INT 22
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: PUSH
12461: EMPTY
12462: LIST
12463: LIST
12464: LIST
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PPUSH
12470: CALL_OW 69
12474: PPUSH
12475: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12479: LD_INT 10
12481: PPUSH
12482: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12486: LD_EXP 24
12490: PPUSH
12491: LD_STRING DH-1-bal
12493: PPUSH
12494: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12498: LD_EXP 31
12502: PPUSH
12503: LD_STRING DMar-1-bal
12505: PPUSH
12506: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12510: LD_EXP 24
12514: PPUSH
12515: LD_STRING DH-2-bal
12517: PPUSH
12518: CALL_OW 88
// DialogueOff ;
12522: CALL_OW 7
// end ;
12526: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12527: LD_EXP 28
12531: PPUSH
12532: CALL_OW 302
12536: PUSH
12537: LD_INT 22
12539: PUSH
12540: LD_INT 2
12542: PUSH
12543: EMPTY
12544: LIST
12545: LIST
12546: PUSH
12547: LD_INT 30
12549: PUSH
12550: LD_INT 6
12552: PUSH
12553: EMPTY
12554: LIST
12555: LIST
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PPUSH
12561: CALL_OW 69
12565: AND
12566: IFFALSE 12627
12568: GO 12570
12570: DISABLE
// begin DialogueOn ;
12571: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12575: LD_EXP 28
12579: PPUSH
12580: LD_STRING DA-1-lab
12582: PPUSH
12583: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12587: LD_EXP 24
12591: PPUSH
12592: LD_STRING DH-1-lab
12594: PPUSH
12595: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12599: LD_EXP 28
12603: PPUSH
12604: LD_STRING DA-2-lab
12606: PPUSH
12607: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12611: LD_EXP 24
12615: PPUSH
12616: LD_STRING DH-2-lab
12618: PPUSH
12619: CALL_OW 88
// DialogueOff ;
12623: CALL_OW 7
// end ;
12627: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) do var ape ;
12628: LD_EXP 29
12632: PPUSH
12633: CALL_OW 302
12637: PUSH
12638: LD_INT 22
12640: PUSH
12641: LD_INT 2
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: PUSH
12648: LD_INT 25
12650: PUSH
12651: LD_INT 15
12653: PUSH
12654: EMPTY
12655: LIST
12656: LIST
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PPUSH
12662: CALL_OW 69
12666: AND
12667: IFFALSE 12847
12669: GO 12671
12671: DISABLE
12672: LD_INT 0
12674: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12675: LD_ADDR_VAR 0 1
12679: PUSH
12680: LD_INT 22
12682: PUSH
12683: LD_INT 2
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: PUSH
12690: LD_INT 25
12692: PUSH
12693: LD_INT 15
12695: PUSH
12696: EMPTY
12697: LIST
12698: LIST
12699: PUSH
12700: EMPTY
12701: LIST
12702: LIST
12703: PPUSH
12704: CALL_OW 69
12708: ST_TO_ADDR
// Video ( true ) ;
12709: LD_INT 1
12711: PPUSH
12712: CALL 1004 0 1
// CenterNowOnUnits ( ape [ 1 ] ) ;
12716: LD_VAR 0 1
12720: PUSH
12721: LD_INT 1
12723: ARRAY
12724: PPUSH
12725: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12729: LD_VAR 0 1
12733: PUSH
12734: LD_INT 1
12736: ARRAY
12737: PPUSH
12738: CALL_OW 122
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12742: LD_VAR 0 1
12746: PUSH
12747: LD_INT 1
12749: ARRAY
12750: PPUSH
12751: LD_INT 35
12753: PPUSH
12754: LD_INT 28
12756: PPUSH
12757: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12761: LD_VAR 0 1
12765: PUSH
12766: LD_INT 1
12768: ARRAY
12769: PPUSH
12770: LD_INT 36
12772: PPUSH
12773: LD_INT 17
12775: PPUSH
12776: CALL_OW 171
// Say ( Kaia , DK-1-apesol ) ;
12780: LD_EXP 29
12784: PPUSH
12785: LD_STRING DK-1-apesol
12787: PPUSH
12788: CALL_OW 88
// Say ( Aviradze , DA-1-apesol ) ;
12792: LD_EXP 28
12796: PPUSH
12797: LD_STRING DA-1-apesol
12799: PPUSH
12800: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12804: LD_EXP 29
12808: PPUSH
12809: LD_STRING DK-2-apesol
12811: PPUSH
12812: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12816: LD_EXP 28
12820: PPUSH
12821: LD_STRING DA-2-apesol
12823: PPUSH
12824: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12828: LD_EXP 29
12832: PPUSH
12833: LD_STRING DK-3-apesol
12835: PPUSH
12836: CALL_OW 88
// Video ( false ) ;
12840: LD_INT 0
12842: PPUSH
12843: CALL 1004 0 1
// end ;
12847: PPOPN 1
12849: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) do var ape ;
12850: LD_EXP 30
12854: PPUSH
12855: CALL_OW 302
12859: PUSH
12860: LD_INT 22
12862: PUSH
12863: LD_INT 2
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: PUSH
12870: LD_INT 25
12872: PUSH
12873: LD_INT 16
12875: PUSH
12876: EMPTY
12877: LIST
12878: LIST
12879: PUSH
12880: EMPTY
12881: LIST
12882: LIST
12883: PPUSH
12884: CALL_OW 69
12888: AND
12889: IFFALSE 13161
12891: GO 12893
12893: DISABLE
12894: LD_INT 0
12896: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
12897: LD_ADDR_VAR 0 1
12901: PUSH
12902: LD_INT 22
12904: PUSH
12905: LD_INT 2
12907: PUSH
12908: EMPTY
12909: LIST
12910: LIST
12911: PUSH
12912: LD_INT 25
12914: PUSH
12915: LD_INT 16
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PPUSH
12926: CALL_OW 69
12930: ST_TO_ADDR
// Video ( true ) ;
12931: LD_INT 1
12933: PPUSH
12934: CALL 1004 0 1
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
12938: LD_INT 5
12940: PPUSH
12941: LD_INT 35
12943: PPUSH
12944: LD_INT 22
12946: PPUSH
12947: LD_INT 1
12949: PPUSH
12950: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
12954: LD_EXP 30
12958: PPUSH
12959: LD_VAR 0 1
12963: PUSH
12964: LD_INT 1
12966: ARRAY
12967: PPUSH
12968: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
12972: LD_VAR 0 1
12976: PUSH
12977: LD_INT 1
12979: ARRAY
12980: PPUSH
12981: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12985: LD_VAR 0 1
12989: PUSH
12990: LD_INT 1
12992: ARRAY
12993: PPUSH
12994: CALL_OW 122
// wait ( 0 0$2 ) ;
12998: LD_INT 70
13000: PPUSH
13001: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
13005: LD_EXP 30
13009: PPUSH
13010: LD_STRING DS-1-apeeng
13012: PPUSH
13013: CALL_OW 88
// if IsOk ( Kamil ) then
13017: LD_EXP 27
13021: PPUSH
13022: CALL_OW 302
13026: IFFALSE 13154
// begin Say ( Kamil , DKam-1-apeeng ) ;
13028: LD_EXP 27
13032: PPUSH
13033: LD_STRING DKam-1-apeeng
13035: PPUSH
13036: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
13040: LD_EXP 30
13044: PPUSH
13045: LD_STRING DS-2-apeeng
13047: PPUSH
13048: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
13052: LD_EXP 27
13056: PPUSH
13057: LD_STRING DKam-2-apeeng
13059: PPUSH
13060: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
13064: LD_EXP 30
13068: PPUSH
13069: LD_STRING DS-3-apeeng
13071: PPUSH
13072: CALL_OW 88
// if not IsOK ( Kaia ) then
13076: LD_EXP 29
13080: PPUSH
13081: CALL_OW 302
13085: NOT
13086: IFFALSE 13097
// begin Video ( false ) ;
13088: LD_INT 0
13090: PPUSH
13091: CALL 1004 0 1
// exit ;
13095: GO 13161
// end ; Say ( Kaia , DK-1-apeeng ) ;
13097: LD_EXP 29
13101: PPUSH
13102: LD_STRING DK-1-apeeng
13104: PPUSH
13105: CALL_OW 88
// if not IsOk ( Givi ) then
13109: LD_EXP 25
13113: PPUSH
13114: CALL_OW 302
13118: NOT
13119: IFFALSE 13130
// begin Video ( false ) ;
13121: LD_INT 0
13123: PPUSH
13124: CALL 1004 0 1
// exit ;
13128: GO 13161
// end ; Say ( Givi , DG-1-apeeng ) ;
13130: LD_EXP 25
13134: PPUSH
13135: LD_STRING DG-1-apeeng
13137: PPUSH
13138: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
13142: LD_EXP 29
13146: PPUSH
13147: LD_STRING DK-2-apeeng
13149: PPUSH
13150: CALL_OW 88
// end ; Video ( false ) ;
13154: LD_INT 0
13156: PPUSH
13157: CALL 1004 0 1
// end ;
13161: PPOPN 1
13163: END
// every 0 0$1 trigger farmerBaseReady and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) do
13164: LD_EXP 4
13168: PUSH
13169: LD_INT 22
13171: PUSH
13172: LD_INT 2
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: PUSH
13179: LD_INT 30
13181: PUSH
13182: LD_INT 0
13184: PUSH
13185: EMPTY
13186: LIST
13187: LIST
13188: PUSH
13189: EMPTY
13190: LIST
13191: LIST
13192: PPUSH
13193: CALL_OW 69
13197: AND
13198: IFFALSE 13356
13200: GO 13202
13202: DISABLE
// begin DialogueOn ;
13203: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
13207: LD_EXP 32
13211: PPUSH
13212: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
13216: LD_EXP 32
13220: PPUSH
13221: LD_STRING DF-1-distribution
13223: PPUSH
13224: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
13228: LD_EXP 24
13232: PPUSH
13233: LD_STRING DH-2-distribution
13235: PPUSH
13236: CALL_OW 88
// if IsOk ( Kaia ) then
13240: LD_EXP 29
13244: PPUSH
13245: CALL_OW 302
13249: IFFALSE 13310
// begin Say ( Kaia , DK-1-distribution ) ;
13251: LD_EXP 29
13255: PPUSH
13256: LD_STRING DK-1-distribution
13258: PPUSH
13259: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13263: LD_EXP 24
13267: PPUSH
13268: LD_STRING DH-1-distribution
13270: PPUSH
13271: CALL_OW 88
// if IsOk ( Givi ) then
13275: LD_EXP 25
13279: PPUSH
13280: CALL_OW 302
13284: IFFALSE 13310
// begin Say ( Givi , DG-1-distribution ) ;
13286: LD_EXP 25
13290: PPUSH
13291: LD_STRING DG-1-distribution
13293: PPUSH
13294: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13298: LD_EXP 24
13302: PPUSH
13303: LD_STRING DH-3-distribution
13305: PPUSH
13306: CALL_OW 88
// end ; end ; DialogueOff ;
13310: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13314: LD_STRING Crates1
13316: PPUSH
13317: CALL_OW 337
// farmerRequestedCrates := 300 ;
13321: LD_ADDR_EXP 13
13325: PUSH
13326: LD_INT 300
13328: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13329: LD_STRING FarmerCrates
13331: PPUSH
13332: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13336: LD_INT 10
13338: PPUSH
13339: LD_INT 1
13341: PPUSH
13342: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13346: LD_INT 108
13348: PPUSH
13349: LD_INT 61
13351: PPUSH
13352: CALL_OW 86
// end ;
13356: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13357: LD_EXP 6
13361: PUSH
13362: LD_INT 22
13364: PUSH
13365: LD_INT 2
13367: PUSH
13368: EMPTY
13369: LIST
13370: LIST
13371: PUSH
13372: LD_INT 3
13374: PUSH
13375: LD_INT 57
13377: PUSH
13378: EMPTY
13379: LIST
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PUSH
13385: LD_INT 2
13387: PUSH
13388: LD_INT 30
13390: PUSH
13391: LD_INT 6
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: LD_INT 30
13400: PUSH
13401: LD_INT 7
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: LIST
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: LIST
13417: PPUSH
13418: CALL_OW 69
13422: AND
13423: PUSH
13424: LD_INT 22
13426: PUSH
13427: LD_INT 2
13429: PUSH
13430: EMPTY
13431: LIST
13432: LIST
13433: PUSH
13434: LD_INT 3
13436: PUSH
13437: LD_INT 57
13439: PUSH
13440: EMPTY
13441: LIST
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: PUSH
13447: LD_INT 30
13449: PUSH
13450: LD_INT 4
13452: PUSH
13453: EMPTY
13454: LIST
13455: LIST
13456: PUSH
13457: EMPTY
13458: LIST
13459: LIST
13460: LIST
13461: PPUSH
13462: CALL_OW 69
13466: AND
13467: IFFALSE 13631
13469: GO 13471
13471: DISABLE
13472: LD_INT 0
13474: PPUSH
// begin wait ( 0 0$10 ) ;
13475: LD_INT 350
13477: PPUSH
13478: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13482: LD_ADDR_VAR 0 1
13486: PUSH
13487: LD_EXP 38
13491: PPUSH
13492: LD_INT 26
13494: PUSH
13495: LD_INT 1
13497: PUSH
13498: EMPTY
13499: LIST
13500: LIST
13501: PUSH
13502: LD_INT 25
13504: PUSH
13505: LD_INT 2
13507: PUSH
13508: EMPTY
13509: LIST
13510: LIST
13511: PUSH
13512: EMPTY
13513: LIST
13514: LIST
13515: PPUSH
13516: CALL_OW 72
13520: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13521: LD_EXP 24
13525: PPUSH
13526: LD_STRING DH-1-task
13528: PPUSH
13529: CALL_OW 88
// if IsOk ( Sophia ) then
13533: LD_EXP 30
13537: PPUSH
13538: CALL_OW 302
13542: IFFALSE 13582
// begin Say ( Sophia , DS-1-task ) ;
13544: LD_EXP 30
13548: PPUSH
13549: LD_STRING DS-1-task
13551: PPUSH
13552: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13556: LD_EXP 30
13560: PPUSH
13561: LD_STRING DS-2-task
13563: PPUSH
13564: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13568: LD_EXP 24
13572: PPUSH
13573: LD_STRING DH-2-task
13575: PPUSH
13576: CALL_OW 88
// end else
13580: GO 13616
// if eng then
13582: LD_VAR 0 1
13586: IFFALSE 13616
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13588: LD_VAR 0 1
13592: PUSH
13593: LD_INT 1
13595: ARRAY
13596: PPUSH
13597: LD_STRING DArm-1-task
13599: PPUSH
13600: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13604: LD_EXP 24
13608: PPUSH
13609: LD_STRING DH-2-task
13611: PPUSH
13612: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13616: LD_STRING BaseConstructed
13618: PPUSH
13619: CALL_OW 337
// allowConvoys := true ;
13623: LD_ADDR_EXP 11
13627: PUSH
13628: LD_INT 1
13630: ST_TO_ADDR
// end ;
13631: PPOPN 1
13633: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13634: LD_INT 22
13636: PUSH
13637: LD_INT 4
13639: PUSH
13640: EMPTY
13641: LIST
13642: LIST
13643: PUSH
13644: LD_INT 34
13646: PUSH
13647: LD_INT 12
13649: PUSH
13650: EMPTY
13651: LIST
13652: LIST
13653: PUSH
13654: EMPTY
13655: LIST
13656: LIST
13657: PPUSH
13658: CALL_OW 69
13662: IFFALSE 13830
13664: GO 13666
13666: DISABLE
13667: LD_INT 0
13669: PPUSH
13670: PPUSH
13671: PPUSH
// begin wait ( 0 0$2 ) ;
13672: LD_INT 70
13674: PPUSH
13675: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13679: LD_ADDR_VAR 0 1
13683: PUSH
13684: LD_INT 22
13686: PUSH
13687: LD_INT 4
13689: PUSH
13690: EMPTY
13691: LIST
13692: LIST
13693: PUSH
13694: LD_INT 34
13696: PUSH
13697: LD_INT 12
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: PPUSH
13708: CALL_OW 69
13712: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13713: LD_ADDR_VAR 0 2
13717: PUSH
13718: LD_VAR 0 1
13722: PUSH
13723: LD_INT 1
13725: ARRAY
13726: PPUSH
13727: CALL_OW 250
13731: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13732: LD_ADDR_VAR 0 3
13736: PUSH
13737: LD_VAR 0 1
13741: PUSH
13742: LD_INT 1
13744: ARRAY
13745: PPUSH
13746: CALL_OW 251
13750: ST_TO_ADDR
// DialogueOn ;
13751: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13755: LD_VAR 0 2
13759: PPUSH
13760: LD_VAR 0 3
13764: PPUSH
13765: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13769: LD_VAR 0 2
13773: PPUSH
13774: LD_VAR 0 3
13778: PPUSH
13779: LD_INT 2
13781: PPUSH
13782: LD_INT 6
13784: NEG
13785: PPUSH
13786: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13790: LD_INT 10
13792: PPUSH
13793: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13797: LD_EXP 24
13801: PPUSH
13802: LD_STRING DH-1-seecargo
13804: PPUSH
13805: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13809: LD_VAR 0 2
13813: PPUSH
13814: LD_VAR 0 3
13818: PPUSH
13819: LD_INT 2
13821: PPUSH
13822: CALL_OW 331
// DialogueOff ;
13826: CALL_OW 7
// end ;
13830: PPOPN 3
13832: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13833: LD_EXP 4
13837: PUSH
13838: LD_EXP 12
13842: PUSH
13843: LD_INT 300
13845: GREATEREQUAL
13846: AND
13847: IFFALSE 13919
13849: GO 13851
13851: DISABLE
// begin DialogueOn ;
13852: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13856: LD_EXP 32
13860: PPUSH
13861: LD_STRING DF-1-delivery-2
13863: PPUSH
13864: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13868: LD_EXP 24
13872: PPUSH
13873: LD_STRING DH-1-delivery-2
13875: PPUSH
13876: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
13880: LD_EXP 32
13884: PPUSH
13885: LD_STRING DF-2-delivery-2
13887: PPUSH
13888: CALL_OW 94
// DialogueOff ;
13892: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
13896: LD_STRING Crates2
13898: PPUSH
13899: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13903: LD_ADDR_EXP 14
13907: PUSH
13908: LD_INT 63000
13910: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
13911: LD_ADDR_EXP 13
13915: PUSH
13916: LD_INT 600
13918: ST_TO_ADDR
// end ;
13919: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 do
13920: LD_EXP 4
13924: PUSH
13925: LD_EXP 12
13929: PUSH
13930: LD_INT 600
13932: GREATEREQUAL
13933: AND
13934: IFFALSE 14100
13936: GO 13938
13938: DISABLE
// begin DialogueOn ;
13939: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
13943: LD_EXP 32
13947: PPUSH
13948: LD_STRING DF-1-delivery-3
13950: PPUSH
13951: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
13955: LD_EXP 24
13959: PPUSH
13960: LD_STRING DH-1-delivery-3
13962: PPUSH
13963: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
13967: LD_EXP 32
13971: PPUSH
13972: LD_STRING DF-2-delivery-3
13974: PPUSH
13975: CALL_OW 94
// if IsOk ( Kaia ) then
13979: LD_EXP 29
13983: PPUSH
13984: CALL_OW 302
13988: IFFALSE 14038
// begin Say ( Kaia , DK-1-delivery-3 ) ;
13990: LD_EXP 29
13994: PPUSH
13995: LD_STRING DK-1-delivery-3
13997: PPUSH
13998: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
14002: LD_EXP 24
14006: PPUSH
14007: LD_STRING DH-2-delivery-3
14009: PPUSH
14010: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
14014: LD_EXP 25
14018: PPUSH
14019: LD_STRING DG-1-delivery-3
14021: PPUSH
14022: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
14026: LD_EXP 26
14030: PPUSH
14031: LD_STRING DM-1-delivery-3
14033: PPUSH
14034: CALL_OW 88
// end ; DialogueOff ;
14038: CALL_OW 7
// if Difficulty = 2 then
14042: LD_OWVAR 67
14046: PUSH
14047: LD_INT 2
14049: EQUAL
14050: IFFALSE 14077
// begin ChangeMissionObjectives ( Crates3 ) ;
14052: LD_STRING Crates3
14054: PPUSH
14055: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14059: LD_ADDR_EXP 14
14063: PUSH
14064: LD_INT 63000
14066: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
14067: LD_ADDR_EXP 13
14071: PUSH
14072: LD_INT 900
14074: ST_TO_ADDR
// end else
14075: GO 14100
// begin ChangeMissionObjectives ( Crates4 ) ;
14077: LD_STRING Crates4
14079: PPUSH
14080: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14084: LD_ADDR_EXP 14
14088: PUSH
14089: LD_INT 63000
14091: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
14092: LD_ADDR_EXP 13
14096: PUSH
14097: LD_INT 1200
14099: ST_TO_ADDR
// end ; end ;
14100: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
14101: LD_EXP 4
14105: PUSH
14106: LD_EXP 12
14110: PUSH
14111: LD_INT 600
14113: PUSH
14114: LD_INT 900
14116: PUSH
14117: LD_INT 1200
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: LIST
14124: PUSH
14125: LD_OWVAR 67
14129: ARRAY
14130: GREATEREQUAL
14131: AND
14132: PUSH
14133: LD_EXP 13
14137: PUSH
14138: LD_EXP 14
14142: LESSEQUAL
14143: AND
14144: IFFALSE 14217
14146: GO 14148
14148: DISABLE
// begin retreatAllowed := true ;
14149: LD_ADDR_EXP 10
14153: PUSH
14154: LD_INT 1
14156: ST_TO_ADDR
// display_strings := [ ] ;
14157: LD_ADDR_OWVAR 47
14161: PUSH
14162: EMPTY
14163: ST_TO_ADDR
// DialogueOn ;
14164: CALL_OW 6
// Video ( true ) ;
14168: LD_INT 1
14170: PPUSH
14171: CALL 1004 0 1
// SayRadio ( Omar , DO-radio-end ) ;
14175: LD_EXP 33
14179: PPUSH
14180: LD_STRING DO-radio-end
14182: PPUSH
14183: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
14187: LD_EXP 24
14191: PPUSH
14192: LD_STRING DH-1-radio-end
14194: PPUSH
14195: CALL_OW 88
// Video ( false ) ;
14199: LD_INT 0
14201: PPUSH
14202: CALL 1004 0 1
// DialogueOff ;
14206: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
14210: LD_STRING Retreat
14212: PPUSH
14213: CALL_OW 337
// end ;
14217: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
14218: LD_EXP 10
14222: IFFALSE 14357
14224: GO 14226
14226: DISABLE
14227: LD_INT 0
14229: PPUSH
14230: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
14231: LD_INT 10
14233: PPUSH
14234: LD_INT 0
14236: PPUSH
14237: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
14241: LD_ADDR_VAR 0 1
14245: PUSH
14246: LD_EXP 35
14250: PPUSH
14251: LD_INT 25
14253: PUSH
14254: LD_INT 2
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PPUSH
14261: CALL_OW 72
14265: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14266: LD_VAR 0 1
14270: PUSH
14271: LD_INT 102
14273: PPUSH
14274: LD_INT 69
14276: PPUSH
14277: CALL_OW 428
14281: PUSH
14282: LD_INT 0
14284: EQUAL
14285: AND
14286: IFFALSE 14353
// begin for i in tmp do
14288: LD_ADDR_VAR 0 2
14292: PUSH
14293: LD_VAR 0 1
14297: PUSH
14298: FOR_IN
14299: IFFALSE 14323
// if IsInUnit ( i ) then
14301: LD_VAR 0 2
14305: PPUSH
14306: CALL_OW 310
14310: IFFALSE 14321
// ComExitBuilding ( i ) ;
14312: LD_VAR 0 2
14316: PPUSH
14317: CALL_OW 122
14321: GO 14298
14323: POP
14324: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14325: LD_VAR 0 1
14329: PPUSH
14330: LD_INT 31
14332: PPUSH
14333: LD_INT 102
14335: PPUSH
14336: LD_INT 69
14338: PPUSH
14339: LD_INT 2
14341: PPUSH
14342: CALL_OW 205
// wait ( 0 0$3 ) ;
14346: LD_INT 105
14348: PPUSH
14349: CALL_OW 67
// end ; StartCargoEvacuation ;
14353: CALL 4517 0 0
// end ;
14357: PPOPN 2
14359: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14360: LD_EXP 10
14364: NOT
14365: PUSH
14366: LD_INT 5
14368: PPUSH
14369: CALL_OW 301
14373: AND
14374: IFFALSE 14398
14376: GO 14378
14378: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
14379: LD_EXP 32
14383: PPUSH
14384: LD_STRING DF-1-failure
14386: PPUSH
14387: CALL_OW 94
// YouLost ( FarmerDepot ) ;
14391: LD_STRING FarmerDepot
14393: PPUSH
14394: CALL_OW 104
// end ;
14398: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 do var i , max , tmp ;
14399: LD_EXP 10
14403: PUSH
14404: LD_EXP 24
14408: PPUSH
14409: LD_EXP 32
14413: PPUSH
14414: CALL_OW 296
14418: PUSH
14419: LD_INT 6
14421: LESS
14422: AND
14423: IFFALSE 15009
14425: GO 14427
14427: DISABLE
14428: LD_INT 0
14430: PPUSH
14431: PPUSH
14432: PPUSH
// begin allowConvoys := false ;
14433: LD_ADDR_EXP 11
14437: PUSH
14438: LD_INT 0
14440: ST_TO_ADDR
// Video ( true ) ;
14441: LD_INT 1
14443: PPUSH
14444: CALL 1004 0 1
// ComTurnUnit ( Heike , Farmer ) ;
14448: LD_EXP 24
14452: PPUSH
14453: LD_EXP 32
14457: PPUSH
14458: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14462: LD_EXP 32
14466: PPUSH
14467: LD_EXP 24
14471: PPUSH
14472: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14476: LD_EXP 32
14480: PPUSH
14481: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14485: LD_EXP 24
14489: PPUSH
14490: LD_STRING DH-1-end
14492: PPUSH
14493: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14497: LD_EXP 32
14501: PPUSH
14502: LD_STRING DF-1-end
14504: PPUSH
14505: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14509: LD_EXP 32
14513: PPUSH
14514: LD_STRING DF-2-end
14516: PPUSH
14517: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14521: LD_EXP 24
14525: PPUSH
14526: LD_STRING DH-2-end
14528: PPUSH
14529: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14533: LD_EXP 32
14537: PPUSH
14538: LD_STRING DF-3-end
14540: PPUSH
14541: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14545: LD_EXP 24
14549: PPUSH
14550: LD_STRING DH-3-end
14552: PPUSH
14553: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14557: LD_EXP 25
14561: PPUSH
14562: LD_STRING DG-1-end
14564: PPUSH
14565: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14569: LD_EXP 24
14573: PPUSH
14574: LD_STRING DH-4-end
14576: PPUSH
14577: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14581: LD_EXP 32
14585: PPUSH
14586: LD_STRING DF-4-end
14588: PPUSH
14589: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14593: LD_EXP 24
14597: PPUSH
14598: LD_STRING DH-5-end
14600: PPUSH
14601: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14605: LD_EXP 32
14609: PPUSH
14610: LD_STRING DF-5-end
14612: PPUSH
14613: CALL_OW 88
// Video ( false ) ;
14617: LD_INT 0
14619: PPUSH
14620: CALL 1004 0 1
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14624: LD_ADDR_VAR 0 2
14628: PUSH
14629: LD_INT 4
14631: PUSH
14632: LD_INT 3
14634: PUSH
14635: LD_INT 2
14637: PUSH
14638: EMPTY
14639: LIST
14640: LIST
14641: LIST
14642: PUSH
14643: LD_OWVAR 67
14647: ARRAY
14648: ST_TO_ADDR
// if farmerSquad < max then
14649: LD_EXP 35
14653: PUSH
14654: LD_VAR 0 2
14658: LESS
14659: IFFALSE 14671
// max := farmerSquad ;
14661: LD_ADDR_VAR 0 2
14665: PUSH
14666: LD_EXP 35
14670: ST_TO_ADDR
// for i := 1 to max do
14671: LD_ADDR_VAR 0 1
14675: PUSH
14676: DOUBLE
14677: LD_INT 1
14679: DEC
14680: ST_TO_ADDR
14681: LD_VAR 0 2
14685: PUSH
14686: FOR_TO
14687: IFFALSE 14725
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14689: LD_EXP 35
14693: PUSH
14694: LD_INT 1
14696: ARRAY
14697: PPUSH
14698: LD_INT 2
14700: PPUSH
14701: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14705: LD_ADDR_EXP 35
14709: PUSH
14710: LD_EXP 35
14714: PPUSH
14715: LD_INT 1
14717: PPUSH
14718: CALL_OW 3
14722: ST_TO_ADDR
// end ;
14723: GO 14686
14725: POP
14726: POP
// for i in Farmer ^ farmerSquad do
14727: LD_ADDR_VAR 0 1
14731: PUSH
14732: LD_EXP 32
14736: PUSH
14737: LD_EXP 35
14741: ADD
14742: PUSH
14743: FOR_IN
14744: IFFALSE 14783
// begin if IsInUnit ( i ) then
14746: LD_VAR 0 1
14750: PPUSH
14751: CALL_OW 310
14755: IFFALSE 14766
// ComExitBuilding ( i ) ;
14757: LD_VAR 0 1
14761: PPUSH
14762: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14766: LD_VAR 0 1
14770: PPUSH
14771: LD_INT 102
14773: PPUSH
14774: LD_INT 7
14776: PPUSH
14777: CALL_OW 171
// end ;
14781: GO 14743
14783: POP
14784: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14785: LD_ADDR_VAR 0 1
14789: PUSH
14790: LD_INT 22
14792: PUSH
14793: LD_INT 5
14795: PUSH
14796: EMPTY
14797: LIST
14798: LIST
14799: PUSH
14800: LD_INT 21
14802: PUSH
14803: LD_INT 3
14805: PUSH
14806: EMPTY
14807: LIST
14808: LIST
14809: PUSH
14810: EMPTY
14811: LIST
14812: LIST
14813: PPUSH
14814: CALL_OW 69
14818: PUSH
14819: LD_INT 5
14821: DIFF
14822: PUSH
14823: FOR_IN
14824: IFFALSE 14840
// SetSide ( i , 2 ) ;
14826: LD_VAR 0 1
14830: PPUSH
14831: LD_INT 2
14833: PPUSH
14834: CALL_OW 235
14838: GO 14823
14840: POP
14841: POP
// repeat wait ( 0 0$1 ) ;
14842: LD_INT 35
14844: PPUSH
14845: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
14849: LD_ADDR_VAR 0 3
14853: PUSH
14854: LD_EXP 32
14858: PUSH
14859: LD_EXP 35
14863: ADD
14864: PPUSH
14865: LD_INT 95
14867: PUSH
14868: LD_INT 3
14870: PUSH
14871: EMPTY
14872: LIST
14873: LIST
14874: PPUSH
14875: CALL_OW 72
14879: ST_TO_ADDR
// if tmp then
14880: LD_VAR 0 3
14884: IFFALSE 14928
// for i in tmp do
14886: LD_ADDR_VAR 0 1
14890: PUSH
14891: LD_VAR 0 3
14895: PUSH
14896: FOR_IN
14897: IFFALSE 14926
// begin farmerSquad := farmerSquad diff i ;
14899: LD_ADDR_EXP 35
14903: PUSH
14904: LD_EXP 35
14908: PUSH
14909: LD_VAR 0 1
14913: DIFF
14914: ST_TO_ADDR
// RemoveUnit ( i ) ;
14915: LD_VAR 0 1
14919: PPUSH
14920: CALL_OW 64
// end ;
14924: GO 14896
14926: POP
14927: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
14928: LD_EXP 35
14932: PUSH
14933: EMPTY
14934: EQUAL
14935: PUSH
14936: LD_EXP 32
14940: PPUSH
14941: CALL_OW 305
14945: NOT
14946: AND
14947: IFFALSE 14842
// wait ( 1 1$00 ) ;
14949: LD_INT 2100
14951: PPUSH
14952: CALL_OW 67
// SendAttack ;
14956: CALL 6957 0 0
// wait ( [ 5 5$00 , 4 4$30 , 4 4$00 ] [ Difficulty ] ) ;
14960: LD_INT 10500
14962: PUSH
14963: LD_INT 9450
14965: PUSH
14966: LD_INT 8400
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: LIST
14973: PUSH
14974: LD_OWVAR 67
14978: ARRAY
14979: PPUSH
14980: CALL_OW 67
// SendAttack ;
14984: CALL 6957 0 0
// if Difficulty > 2 then
14988: LD_OWVAR 67
14992: PUSH
14993: LD_INT 2
14995: GREATER
14996: IFFALSE 15009
// begin wait ( 4 4$00 ) ;
14998: LD_INT 8400
15000: PPUSH
15001: CALL_OW 67
// SendAttack ;
15005: CALL 6957 0 0
// end ; end ;
15009: PPOPN 3
15011: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
15012: LD_EXP 14
15016: PUSH
15017: LD_INT 18900
15019: LESSEQUAL
15020: IFFALSE 15069
15022: GO 15024
15024: DISABLE
// begin DialogueOn ;
15025: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
15029: LD_EXP 32
15033: PPUSH
15034: LD_STRING DF-1-distribution-a
15036: PPUSH
15037: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
15041: LD_EXP 24
15045: PPUSH
15046: LD_STRING DH-1-distribution-a
15048: PPUSH
15049: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
15053: LD_EXP 32
15057: PPUSH
15058: LD_STRING DF-2-distribution-a
15060: PPUSH
15061: CALL_OW 94
// DialogueOff ;
15065: CALL_OW 7
// end ;
15069: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
15070: LD_EXP 14
15074: PUSH
15075: LD_INT 0
15077: LESSEQUAL
15078: IFFALSE 15110
15080: GO 15082
15082: DISABLE
// begin DialogueOn ;
15083: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
15087: LD_EXP 32
15091: PPUSH
15092: LD_STRING DF-3-distribution-a
15094: PPUSH
15095: CALL_OW 94
// YouLost ( Distribution ) ;
15099: LD_STRING Distribution
15101: PPUSH
15102: CALL_OW 104
// DialogueOff ;
15106: CALL_OW 7
// end ;
15110: END
// every 0 0$1 trigger vehCounter >= 2 do
15111: LD_EXP 18
15115: PUSH
15116: LD_INT 2
15118: GREATEREQUAL
15119: IFFALSE 15131
15121: GO 15123
15123: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
15124: LD_STRING VehConstructed
15126: PPUSH
15127: CALL_OW 337
15131: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
15132: LD_INT 22
15134: PUSH
15135: LD_INT 2
15137: PUSH
15138: EMPTY
15139: LIST
15140: LIST
15141: PUSH
15142: LD_INT 34
15144: PUSH
15145: LD_INT 12
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: PUSH
15152: EMPTY
15153: LIST
15154: LIST
15155: PPUSH
15156: CALL_OW 69
15160: IFFALSE 15220
15162: GO 15164
15164: DISABLE
// begin DialogueOn ;
15165: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
15169: LD_EXP 24
15173: PPUSH
15174: LD_STRING DH-1-truck
15176: PPUSH
15177: CALL_OW 88
// if IsOk ( Markov ) then
15181: LD_EXP 31
15185: PPUSH
15186: CALL_OW 302
15190: IFFALSE 15216
// begin Say ( Markov , DMar-1-truck ) ;
15192: LD_EXP 31
15196: PPUSH
15197: LD_STRING DMar-1-truck
15199: PPUSH
15200: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
15204: LD_EXP 24
15208: PPUSH
15209: LD_STRING DH-2-truck
15211: PPUSH
15212: CALL_OW 88
// end ; DialogueOff ;
15216: CALL_OW 7
// end ;
15220: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
15221: LD_INT 0
15223: PPUSH
15224: PPUSH
15225: PPUSH
// if IsOk ( Givi ) then
15226: LD_EXP 25
15230: PPUSH
15231: CALL_OW 302
15235: IFFALSE 15251
// begin Say ( Givi , DG-1-nocargo ) ;
15237: LD_EXP 25
15241: PPUSH
15242: LD_STRING DG-1-nocargo
15244: PPUSH
15245: CALL_OW 88
// exit ;
15249: GO 15347
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15251: LD_ADDR_VAR 0 2
15255: PUSH
15256: LD_EXP 38
15260: PPUSH
15261: LD_INT 26
15263: PUSH
15264: LD_INT 1
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: PPUSH
15271: CALL_OW 72
15275: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15276: LD_ADDR_VAR 0 3
15280: PUSH
15281: LD_EXP 38
15285: PPUSH
15286: LD_INT 26
15288: PUSH
15289: LD_INT 2
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PPUSH
15296: CALL_OW 72
15300: ST_TO_ADDR
// if randomMen then
15301: LD_VAR 0 2
15305: IFFALSE 15325
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15307: LD_VAR 0 2
15311: PUSH
15312: LD_INT 1
15314: ARRAY
15315: PPUSH
15316: LD_STRING DArm-1-nocargo
15318: PPUSH
15319: CALL_OW 88
15323: GO 15347
// if randomWomen then
15325: LD_VAR 0 3
15329: IFFALSE 15347
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15331: LD_VAR 0 3
15335: PUSH
15336: LD_INT 1
15338: ARRAY
15339: PPUSH
15340: LD_STRING DArf-1-nocargo
15342: PPUSH
15343: CALL_OW 88
// end ;
15347: LD_VAR 0 1
15351: RET
// export function IncomingAttack ; begin
15352: LD_INT 0
15354: PPUSH
// if attackWave = 1 then
15355: LD_EXP 16
15359: PUSH
15360: LD_INT 1
15362: EQUAL
15363: IFFALSE 15434
// begin DialogueOn ;
15365: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15369: LD_EXP 33
15373: PPUSH
15374: LD_STRING DO-1-radio-1
15376: PPUSH
15377: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15381: LD_EXP 24
15385: PPUSH
15386: LD_STRING DH-1-radio-1-
15388: PPUSH
15389: CALL_OW 88
// if IsOk ( Markov ) then
15393: LD_EXP 31
15397: PPUSH
15398: CALL_OW 302
15402: IFFALSE 15428
// begin Say ( Markov , DMar-1-radio-1 ) ;
15404: LD_EXP 31
15408: PPUSH
15409: LD_STRING DMar-1-radio-1
15411: PPUSH
15412: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15416: LD_EXP 24
15420: PPUSH
15421: LD_STRING DH-2-radio-1
15423: PPUSH
15424: CALL_OW 88
// end ; DialogueOff ;
15428: CALL_OW 7
// end else
15432: GO 15458
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15434: LD_EXP 33
15438: PPUSH
15439: LD_STRING DO-1-radio-u
15441: PPUSH
15442: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15446: LD_EXP 24
15450: PPUSH
15451: LD_STRING DH-1-radio-u
15453: PPUSH
15454: CALL_OW 88
// end ; end ;
15458: LD_VAR 0 1
15462: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15463: LD_EXP 40
15467: PPUSH
15468: LD_INT 95
15470: PUSH
15471: LD_INT 8
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: PPUSH
15478: CALL_OW 72
15482: IFFALSE 15585
15484: GO 15486
15486: DISABLE
15487: LD_INT 0
15489: PPUSH
// begin enable ;
15490: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15491: LD_ADDR_VAR 0 1
15495: PUSH
15496: LD_EXP 40
15500: PPUSH
15501: LD_INT 95
15503: PUSH
15504: LD_INT 8
15506: PUSH
15507: EMPTY
15508: LIST
15509: LIST
15510: PPUSH
15511: CALL_OW 72
15515: PUSH
15516: FOR_IN
15517: IFFALSE 15546
// begin usForces := usForces diff i ;
15519: LD_ADDR_EXP 40
15523: PUSH
15524: LD_EXP 40
15528: PUSH
15529: LD_VAR 0 1
15533: DIFF
15534: ST_TO_ADDR
// RemoveUnit ( i ) ;
15535: LD_VAR 0 1
15539: PPUSH
15540: CALL_OW 64
// end ;
15544: GO 15516
15546: POP
15547: POP
// if not americanHasEscaped and attackWave = 1 then
15548: LD_EXP 7
15552: NOT
15553: PUSH
15554: LD_EXP 16
15558: PUSH
15559: LD_INT 1
15561: EQUAL
15562: AND
15563: IFFALSE 15585
// begin americanHasEscaped := true ;
15565: LD_ADDR_EXP 7
15569: PUSH
15570: LD_INT 1
15572: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15573: LD_EXP 24
15577: PPUSH
15578: LD_STRING DH-2-assault-a
15580: PPUSH
15581: CALL_OW 88
// end ; end ;
15585: PPOPN 1
15587: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) do
15588: LD_INT 4
15590: PPUSH
15591: LD_INT 22
15593: PUSH
15594: LD_INT 1
15596: PUSH
15597: EMPTY
15598: LIST
15599: LIST
15600: PPUSH
15601: CALL_OW 70
15605: IFFALSE 15622
15607: GO 15609
15609: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15610: LD_EXP 32
15614: PPUSH
15615: LD_STRING DF-1-attack
15617: PPUSH
15618: CALL_OW 94
15622: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15623: LD_INT 5
15625: PPUSH
15626: CALL_OW 255
15630: PUSH
15631: LD_INT 2
15633: EQUAL
15634: IFFALSE 15646
15636: GO 15638
15638: DISABLE
// YouLost ( Attack ) ;
15639: LD_STRING Attack
15641: PPUSH
15642: CALL_OW 104
15646: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 90 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot ;
15647: LD_INT 22
15649: PUSH
15650: LD_INT 1
15652: PUSH
15653: EMPTY
15654: LIST
15655: LIST
15656: PUSH
15657: LD_INT 21
15659: PUSH
15660: LD_INT 1
15662: PUSH
15663: EMPTY
15664: LIST
15665: LIST
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: PPUSH
15671: CALL_OW 69
15675: NOT
15676: PUSH
15677: LD_INT 22
15679: PUSH
15680: LD_INT 4
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: PPUSH
15687: CALL_OW 69
15691: NOT
15692: AND
15693: PUSH
15694: LD_EXP 10
15698: NOT
15699: AND
15700: PUSH
15701: LD_EXP 12
15705: PUSH
15706: LD_INT 90
15708: GREATER
15709: AND
15710: PUSH
15711: LD_INT 7
15713: PPUSH
15714: LD_INT 22
15716: PUSH
15717: LD_INT 2
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PUSH
15724: LD_INT 21
15726: PUSH
15727: LD_INT 1
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: PUSH
15734: EMPTY
15735: LIST
15736: LIST
15737: PPUSH
15738: CALL_OW 70
15742: AND
15743: PUSH
15744: LD_INT 22
15746: PUSH
15747: LD_INT 2
15749: PUSH
15750: EMPTY
15751: LIST
15752: LIST
15753: PUSH
15754: LD_INT 50
15756: PUSH
15757: EMPTY
15758: LIST
15759: PUSH
15760: LD_INT 30
15762: PUSH
15763: LD_INT 0
15765: PUSH
15766: EMPTY
15767: LIST
15768: LIST
15769: PUSH
15770: EMPTY
15771: LIST
15772: LIST
15773: LIST
15774: PPUSH
15775: CALL_OW 69
15779: AND
15780: IFFALSE 16437
15782: GO 15784
15784: DISABLE
15785: LD_INT 0
15787: PPUSH
15788: PPUSH
15789: PPUSH
15790: PPUSH
15791: PPUSH
// begin depot := usDepot ;
15792: LD_ADDR_VAR 0 5
15796: PUSH
15797: LD_INT 11
15799: ST_TO_ADDR
// if not depot then
15800: LD_VAR 0 5
15804: NOT
15805: IFFALSE 15845
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
15807: LD_ADDR_VAR 0 5
15811: PUSH
15812: LD_INT 22
15814: PUSH
15815: LD_INT 2
15817: PUSH
15818: EMPTY
15819: LIST
15820: LIST
15821: PUSH
15822: LD_INT 30
15824: PUSH
15825: LD_INT 0
15827: PUSH
15828: EMPTY
15829: LIST
15830: LIST
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: PPUSH
15836: CALL_OW 69
15840: PUSH
15841: LD_INT 1
15843: ARRAY
15844: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15845: LD_ADDR_VAR 0 1
15849: PUSH
15850: LD_EXP 38
15854: PPUSH
15855: LD_INT 26
15857: PUSH
15858: LD_INT 1
15860: PUSH
15861: EMPTY
15862: LIST
15863: LIST
15864: PPUSH
15865: CALL_OW 72
15869: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15870: LD_ADDR_VAR 0 2
15874: PUSH
15875: LD_EXP 38
15879: PPUSH
15880: LD_INT 26
15882: PUSH
15883: LD_INT 2
15885: PUSH
15886: EMPTY
15887: LIST
15888: LIST
15889: PPUSH
15890: CALL_OW 72
15894: ST_TO_ADDR
// if IsOk ( Kaia ) then
15895: LD_EXP 29
15899: PPUSH
15900: CALL_OW 302
15904: IFFALSE 15925
// speaker := [ Kaia , DK ] else
15906: LD_ADDR_VAR 0 3
15910: PUSH
15911: LD_EXP 29
15915: PUSH
15916: LD_STRING DK
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: ST_TO_ADDR
15923: GO 16005
// if randomMen then
15925: LD_VAR 0 1
15929: IFFALSE 15964
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
15931: LD_ADDR_VAR 0 3
15935: PUSH
15936: LD_VAR 0 1
15940: PUSH
15941: LD_INT 1
15943: PPUSH
15944: LD_VAR 0 1
15948: PPUSH
15949: CALL_OW 12
15953: ARRAY
15954: PUSH
15955: LD_STRING DArm
15957: PUSH
15958: EMPTY
15959: LIST
15960: LIST
15961: ST_TO_ADDR
15962: GO 16005
// if randomWomen then
15964: LD_VAR 0 2
15968: IFFALSE 16003
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
15970: LD_ADDR_VAR 0 3
15974: PUSH
15975: LD_VAR 0 2
15979: PUSH
15980: LD_INT 1
15982: PPUSH
15983: LD_VAR 0 2
15987: PPUSH
15988: CALL_OW 12
15992: ARRAY
15993: PUSH
15994: LD_STRING DArf
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: ST_TO_ADDR
16001: GO 16005
// exit ;
16003: GO 16437
// if IsInUnit ( speaker [ 1 ] ) then
16005: LD_VAR 0 3
16009: PUSH
16010: LD_INT 1
16012: ARRAY
16013: PPUSH
16014: CALL_OW 310
16018: IFFALSE 16041
// place := IsInUnit ( speaker [ 1 ] ) else
16020: LD_ADDR_VAR 0 4
16024: PUSH
16025: LD_VAR 0 3
16029: PUSH
16030: LD_INT 1
16032: ARRAY
16033: PPUSH
16034: CALL_OW 310
16038: ST_TO_ADDR
16039: GO 16055
// place := speaker [ 1 ] ;
16041: LD_ADDR_VAR 0 4
16045: PUSH
16046: LD_VAR 0 3
16050: PUSH
16051: LD_INT 1
16053: ARRAY
16054: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
16055: LD_VAR 0 4
16059: PPUSH
16060: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
16064: LD_VAR 0 4
16068: PPUSH
16069: CALL_OW 250
16073: PPUSH
16074: LD_VAR 0 4
16078: PPUSH
16079: CALL_OW 251
16083: PPUSH
16084: CALL 3025 0 2
// wait ( 0 0$2 ) ;
16088: LD_INT 70
16090: PPUSH
16091: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
16095: LD_EXP 34
16099: PPUSH
16100: CALL_OW 305
16104: NOT
16105: IFFALSE 16109
// exit ;
16107: GO 16437
// allowConvoys := false ;
16109: LD_ADDR_EXP 11
16113: PUSH
16114: LD_INT 0
16116: ST_TO_ADDR
// InGameOn ;
16117: CALL_OW 8
// wait ( 0 0$1 ) ;
16121: LD_INT 35
16123: PPUSH
16124: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
16128: LD_EXP 34
16132: PPUSH
16133: LD_STRING DI-1-land
16135: PPUSH
16136: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
16140: LD_VAR 0 3
16144: PUSH
16145: LD_INT 1
16147: ARRAY
16148: PPUSH
16149: CALL_OW 310
16153: IFFALSE 16168
// ComExit ( speaker [ 1 ] ) ;
16155: LD_VAR 0 3
16159: PUSH
16160: LD_INT 1
16162: ARRAY
16163: PPUSH
16164: CALL 1108 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
16168: LD_VAR 0 3
16172: PUSH
16173: LD_INT 1
16175: ARRAY
16176: PPUSH
16177: LD_EXP 34
16181: PPUSH
16182: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
16186: LD_VAR 0 3
16190: PUSH
16191: LD_INT 1
16193: ARRAY
16194: PPUSH
16195: LD_EXP 34
16199: PPUSH
16200: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
16204: LD_EXP 34
16208: PPUSH
16209: LD_VAR 0 3
16213: PUSH
16214: LD_INT 1
16216: ARRAY
16217: PPUSH
16218: CALL_OW 119
// wait ( 0 0$1 ) ;
16222: LD_INT 35
16224: PPUSH
16225: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
16229: LD_VAR 0 3
16233: PUSH
16234: LD_INT 1
16236: ARRAY
16237: PPUSH
16238: LD_VAR 0 3
16242: PUSH
16243: LD_INT 2
16245: ARRAY
16246: PUSH
16247: LD_STRING -1-land
16249: STR
16250: PPUSH
16251: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16255: LD_EXP 34
16259: PPUSH
16260: LD_STRING DI-2-land
16262: PPUSH
16263: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16267: LD_VAR 0 3
16271: PUSH
16272: LD_INT 1
16274: ARRAY
16275: PPUSH
16276: LD_VAR 0 3
16280: PUSH
16281: LD_INT 2
16283: ARRAY
16284: PUSH
16285: LD_STRING -2-land
16287: STR
16288: PPUSH
16289: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16293: LD_VAR 0 3
16297: PUSH
16298: LD_INT 1
16300: ARRAY
16301: PPUSH
16302: LD_VAR 0 3
16306: PUSH
16307: LD_INT 2
16309: ARRAY
16310: PUSH
16311: LD_STRING -3-land
16313: STR
16314: PPUSH
16315: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16319: LD_EXP 24
16323: PPUSH
16324: LD_STRING DH-1-land
16326: PPUSH
16327: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16331: LD_VAR 0 5
16335: PPUSH
16336: CALL_OW 313
16340: PUSH
16341: LD_INT 6
16343: EQUAL
16344: IFFALSE 16364
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16346: LD_VAR 0 5
16350: PPUSH
16351: CALL_OW 313
16355: PUSH
16356: LD_INT 1
16358: ARRAY
16359: PPUSH
16360: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16364: LD_EXP 34
16368: PPUSH
16369: LD_INT 2
16371: PPUSH
16372: CALL_OW 235
// CenterOnUnits ( depot ) ;
16376: LD_VAR 0 5
16380: PPUSH
16381: CALL_OW 85
// ComEnterUnit ( Ibrahim , depot ) ;
16385: LD_EXP 34
16389: PPUSH
16390: LD_VAR 0 5
16394: PPUSH
16395: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
16399: LD_INT 35
16401: PPUSH
16402: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
16406: LD_EXP 34
16410: PPUSH
16411: CALL_OW 310
16415: IFFALSE 16399
// InGameOff ;
16417: CALL_OW 9
// ibrahimInDepot := true ;
16421: LD_ADDR_EXP 21
16425: PUSH
16426: LD_INT 1
16428: ST_TO_ADDR
// allowConvoys := true ;
16429: LD_ADDR_EXP 11
16433: PUSH
16434: LD_INT 1
16436: ST_TO_ADDR
// end ;
16437: PPOPN 5
16439: END
// export function IbrahimQuery ; begin
16440: LD_INT 0
16442: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16443: LD_STRING IbrahimQuery
16445: PPUSH
16446: CALL_OW 97
16450: PUSH
16451: LD_INT 1
16453: DOUBLE
16454: EQUAL
16455: IFTRUE 16459
16457: GO 16768
16459: POP
// begin allowConvoys := false ;
16460: LD_ADDR_EXP 11
16464: PUSH
16465: LD_INT 0
16467: ST_TO_ADDR
// ibrahimInDepot := false ;
16468: LD_ADDR_EXP 21
16472: PUSH
16473: LD_INT 0
16475: ST_TO_ADDR
// InGameOn ;
16476: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16480: LD_EXP 24
16484: PPUSH
16485: CALL_OW 87
// wait ( 0 0$1 ) ;
16489: LD_INT 35
16491: PPUSH
16492: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16496: LD_EXP 24
16500: PPUSH
16501: LD_STRING DH-1-interrogation
16503: PPUSH
16504: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16508: LD_EXP 34
16512: PPUSH
16513: LD_STRING DI-1-interrogation
16515: PPUSH
16516: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16520: LD_EXP 24
16524: PPUSH
16525: LD_STRING DH-2-interrogation
16527: PPUSH
16528: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16532: LD_EXP 34
16536: PPUSH
16537: LD_STRING DI-2-interrogation
16539: PPUSH
16540: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16544: LD_EXP 24
16548: PPUSH
16549: LD_STRING DH-3-interrogation
16551: PPUSH
16552: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16556: LD_EXP 34
16560: PPUSH
16561: LD_STRING DI-3-interrogation
16563: PPUSH
16564: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16568: LD_EXP 24
16572: PPUSH
16573: LD_STRING DH-4-interrogation
16575: PPUSH
16576: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16580: LD_EXP 34
16584: PPUSH
16585: LD_STRING DI-4-interrogation
16587: PPUSH
16588: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16592: LD_EXP 24
16596: PPUSH
16597: LD_STRING DH-5-interrogation
16599: PPUSH
16600: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16604: LD_EXP 34
16608: PPUSH
16609: LD_STRING DI-5-interrogation
16611: PPUSH
16612: CALL_OW 88
// wait ( 0 0$1 ) ;
16616: LD_INT 35
16618: PPUSH
16619: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16623: LD_STRING IbrahimDecisionQuery
16625: PPUSH
16626: CALL_OW 97
16630: PUSH
16631: LD_INT 1
16633: DOUBLE
16634: EQUAL
16635: IFTRUE 16639
16637: GO 16663
16639: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16640: LD_EXP 34
16644: PPUSH
16645: LD_STRING DI-1-kill
16647: PPUSH
16648: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16652: LD_EXP 34
16656: PPUSH
16657: CALL_OW 66
// end ; 2 :
16661: GO 16762
16663: LD_INT 2
16665: DOUBLE
16666: EQUAL
16667: IFTRUE 16671
16669: GO 16761
16671: POP
// begin SetSide ( Ibrahim , 6 ) ;
16672: LD_EXP 34
16676: PPUSH
16677: LD_INT 6
16679: PPUSH
16680: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16684: LD_EXP 34
16688: PPUSH
16689: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16693: LD_EXP 34
16697: PPUSH
16698: LD_INT 32
16700: PPUSH
16701: LD_INT 5
16703: PPUSH
16704: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16708: LD_EXP 24
16712: PPUSH
16713: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16717: LD_EXP 24
16721: PPUSH
16722: LD_INT 36
16724: PPUSH
16725: LD_INT 21
16727: PPUSH
16728: CALL_OW 171
// AddComWait ( Ibrahim , 1 1$20 ) ;
16732: LD_EXP 34
16736: PPUSH
16737: LD_INT 2800
16739: PPUSH
16740: CALL_OW 202
// AddComMoveXY ( Ibrahim , 38 , 28 ) ;
16744: LD_EXP 34
16748: PPUSH
16749: LD_INT 38
16751: PPUSH
16752: LD_INT 28
16754: PPUSH
16755: CALL_OW 171
// end ; end ;
16759: GO 16762
16761: POP
// InGameOff ;
16762: CALL_OW 9
// end ; 2 :
16766: GO 16782
16768: LD_INT 2
16770: DOUBLE
16771: EQUAL
16772: IFTRUE 16776
16774: GO 16781
16776: POP
// exit ; end ;
16777: GO 16805
16779: GO 16782
16781: POP
// allowConvoys := true ;
16782: LD_ADDR_EXP 11
16786: PUSH
16787: LD_INT 1
16789: ST_TO_ADDR
// wait ( 0 0$40 ) ;
16790: LD_INT 1400
16792: PPUSH
16793: CALL_OW 67
// ibrahimIsFree := true ;
16797: LD_ADDR_EXP 22
16801: PUSH
16802: LD_INT 1
16804: ST_TO_ADDR
// end ;
16805: LD_VAR 0 1
16809: RET
// every 0 0$10 trigger ibrahimIsFree and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b , p , depot ;
16810: LD_EXP 22
16814: PUSH
16815: LD_INT 22
16817: PUSH
16818: LD_INT 2
16820: PUSH
16821: EMPTY
16822: LIST
16823: LIST
16824: PUSH
16825: LD_INT 50
16827: PUSH
16828: EMPTY
16829: LIST
16830: PUSH
16831: LD_INT 30
16833: PUSH
16834: LD_INT 0
16836: PUSH
16837: EMPTY
16838: LIST
16839: LIST
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: LIST
16845: PPUSH
16846: CALL_OW 69
16850: AND
16851: PUSH
16852: LD_EXP 34
16856: PPUSH
16857: LD_INT 7
16859: PPUSH
16860: CALL_OW 308
16864: AND
16865: PUSH
16866: LD_INT 6
16868: PPUSH
16869: LD_EXP 24
16873: PPUSH
16874: CALL_OW 292
16878: AND
16879: PUSH
16880: LD_INT 22
16882: PUSH
16883: LD_INT 4
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: PPUSH
16890: CALL_OW 69
16894: NOT
16895: AND
16896: PUSH
16897: LD_INT 22
16899: PUSH
16900: LD_INT 1
16902: PUSH
16903: EMPTY
16904: LIST
16905: LIST
16906: PUSH
16907: LD_INT 21
16909: PUSH
16910: LD_INT 1
16912: PUSH
16913: EMPTY
16914: LIST
16915: LIST
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: PPUSH
16921: CALL_OW 69
16925: NOT
16926: AND
16927: IFFALSE 17575
16929: GO 16931
16931: DISABLE
16932: LD_INT 0
16934: PPUSH
16935: PPUSH
16936: PPUSH
16937: PPUSH
// begin allowConvoys := false ;
16938: LD_ADDR_EXP 11
16942: PUSH
16943: LD_INT 0
16945: ST_TO_ADDR
// depot := usDepot ;
16946: LD_ADDR_VAR 0 4
16950: PUSH
16951: LD_INT 11
16953: ST_TO_ADDR
// if not usDepot then
16954: LD_INT 11
16956: NOT
16957: IFFALSE 17004
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
16959: LD_ADDR_VAR 0 4
16963: PUSH
16964: LD_INT 22
16966: PUSH
16967: LD_INT 2
16969: PUSH
16970: EMPTY
16971: LIST
16972: LIST
16973: PUSH
16974: LD_INT 50
16976: PUSH
16977: EMPTY
16978: LIST
16979: PUSH
16980: LD_INT 30
16982: PUSH
16983: LD_INT 0
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: EMPTY
16991: LIST
16992: LIST
16993: LIST
16994: PPUSH
16995: CALL_OW 69
16999: PUSH
17000: LD_INT 1
17002: ARRAY
17003: ST_TO_ADDR
// InGameOn ;
17004: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
17008: LD_EXP 34
17012: PPUSH
17013: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
17017: LD_EXP 24
17021: PPUSH
17022: LD_EXP 34
17026: PPUSH
17027: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
17031: LD_EXP 34
17035: PPUSH
17036: LD_EXP 24
17040: PPUSH
17041: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
17045: LD_EXP 34
17049: PPUSH
17050: LD_STRING DI-1-free
17052: PPUSH
17053: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
17057: LD_EXP 24
17061: PPUSH
17062: LD_STRING DH-1-free
17064: PPUSH
17065: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
17069: LD_EXP 34
17073: PPUSH
17074: LD_STRING DI-2-free
17076: PPUSH
17077: CALL_OW 88
// changeClass := 0 ;
17081: LD_ADDR_VAR 0 1
17085: PUSH
17086: LD_INT 0
17088: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
17089: LD_STRING IbrahimJoinQuery
17091: PPUSH
17092: CALL_OW 97
17096: PUSH
17097: LD_INT 1
17099: DOUBLE
17100: EQUAL
17101: IFTRUE 17105
17103: GO 17116
17105: POP
// begin changeClass := 1 ;
17106: LD_ADDR_VAR 0 1
17110: PUSH
17111: LD_INT 1
17113: ST_TO_ADDR
// end ; 2 :
17114: GO 17356
17116: LD_INT 2
17118: DOUBLE
17119: EQUAL
17120: IFTRUE 17124
17122: GO 17276
17124: POP
// begin Say ( Heike , DH-1-decline ) ;
17125: LD_EXP 24
17129: PPUSH
17130: LD_STRING DH-1-decline
17132: PPUSH
17133: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
17137: LD_EXP 34
17141: PPUSH
17142: LD_STRING DI-1-decline
17144: PPUSH
17145: CALL_OW 88
// InGameOff ;
17149: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
17153: LD_EXP 34
17157: PPUSH
17158: LD_INT 30
17160: PPUSH
17161: LD_INT 1
17163: PPUSH
17164: CALL_OW 111
// p := 0 ;
17168: LD_ADDR_VAR 0 3
17172: PUSH
17173: LD_INT 0
17175: ST_TO_ADDR
// repeat p := p + 1 ;
17176: LD_ADDR_VAR 0 3
17180: PUSH
17181: LD_VAR 0 3
17185: PUSH
17186: LD_INT 1
17188: PLUS
17189: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17190: LD_INT 35
17192: PPUSH
17193: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) or p > 10 ;
17197: LD_EXP 34
17201: PPUSH
17202: LD_INT 30
17204: PPUSH
17205: LD_INT 1
17207: PPUSH
17208: CALL_OW 307
17212: PUSH
17213: LD_INT 22
17215: PUSH
17216: LD_INT 2
17218: PUSH
17219: EMPTY
17220: LIST
17221: LIST
17222: PUSH
17223: LD_INT 101
17225: PUSH
17226: LD_INT 6
17228: PUSH
17229: EMPTY
17230: LIST
17231: LIST
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: PPUSH
17237: CALL_OW 69
17241: NOT
17242: OR
17243: PUSH
17244: LD_VAR 0 3
17248: PUSH
17249: LD_INT 10
17251: GREATER
17252: OR
17253: IFFALSE 17176
// RemoveUnit ( Ibrahim ) ;
17255: LD_EXP 34
17259: PPUSH
17260: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17264: LD_INT 1
17266: PPUSH
17267: LD_STRING 03_IbrahimHasEscaped
17269: PPUSH
17270: CALL_OW 39
// end ; 3 :
17274: GO 17356
17276: LD_INT 3
17278: DOUBLE
17279: EQUAL
17280: IFTRUE 17284
17282: GO 17355
17284: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17285: LD_EXP 24
17289: PPUSH
17290: LD_STRING DH-1-radio-hq
17292: PPUSH
17293: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17297: LD_EXP 33
17301: PPUSH
17302: LD_STRING DO-1-radio-hq
17304: PPUSH
17305: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17309: LD_EXP 24
17313: PPUSH
17314: LD_STRING DH-2-radio-hq
17316: PPUSH
17317: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17321: LD_EXP 33
17325: PPUSH
17326: LD_STRING DO-2-radio-hq
17328: PPUSH
17329: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17333: LD_EXP 24
17337: PPUSH
17338: LD_STRING DH-3-radio-hq
17340: PPUSH
17341: CALL_OW 88
// changeClass := 1 ;
17345: LD_ADDR_VAR 0 1
17349: PUSH
17350: LD_INT 1
17352: ST_TO_ADDR
// end ; end ;
17353: GO 17356
17355: POP
// if changeClass then
17356: LD_VAR 0 1
17360: IFFALSE 17575
// begin Say ( Heike , DH-1-agree ) ;
17362: LD_EXP 24
17366: PPUSH
17367: LD_STRING DH-1-agree
17369: PPUSH
17370: CALL_OW 88
// if IsOk ( Givi ) then
17374: LD_EXP 25
17378: PPUSH
17379: CALL_OW 302
17383: IFFALSE 17421
// begin Say ( Givi , DG-1-agree ) ;
17385: LD_EXP 25
17389: PPUSH
17390: LD_STRING DG-1-agree
17392: PPUSH
17393: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17397: LD_EXP 24
17401: PPUSH
17402: LD_STRING DH-2-agree
17404: PPUSH
17405: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17409: LD_EXP 25
17413: PPUSH
17414: LD_STRING DG-2-agree
17416: PPUSH
17417: CALL_OW 88
// end ; if UnitsInside ( depot ) = 6 then
17421: LD_VAR 0 4
17425: PPUSH
17426: CALL_OW 313
17430: PUSH
17431: LD_INT 6
17433: EQUAL
17434: IFFALSE 17454
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
17436: LD_VAR 0 4
17440: PPUSH
17441: CALL_OW 313
17445: PUSH
17446: LD_INT 1
17448: ARRAY
17449: PPUSH
17450: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17454: LD_EXP 34
17458: PPUSH
17459: LD_INT 2
17461: PPUSH
17462: CALL_OW 235
// ComEnterUnit ( Ibrahim , depot ) ;
17466: LD_EXP 34
17470: PPUSH
17471: LD_VAR 0 4
17475: PPUSH
17476: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17480: LD_INT 35
17482: PPUSH
17483: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17487: LD_EXP 34
17491: PPUSH
17492: CALL_OW 310
17496: IFFALSE 17480
// b := IsInUnit ( Ibrahim ) ;
17498: LD_ADDR_VAR 0 2
17502: PUSH
17503: LD_EXP 34
17507: PPUSH
17508: CALL_OW 310
17512: ST_TO_ADDR
// RemoveUnit ( Ibrahim ) ;
17513: LD_EXP 34
17517: PPUSH
17518: CALL_OW 64
// uc_side := 2 ;
17522: LD_ADDR_OWVAR 20
17526: PUSH
17527: LD_INT 2
17529: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17530: LD_ADDR_EXP 34
17534: PUSH
17535: LD_STRING Ibrahim
17537: PPUSH
17538: LD_INT 0
17540: PPUSH
17541: LD_STRING 
17543: PPUSH
17544: CALL 281 0 3
17548: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , b ) ;
17549: LD_EXP 34
17553: PPUSH
17554: LD_VAR 0 2
17558: PPUSH
17559: CALL_OW 52
// InGameOff ;
17563: CALL_OW 9
// allowConvoys := true ;
17567: LD_ADDR_EXP 11
17571: PUSH
17572: LD_INT 1
17574: ST_TO_ADDR
// end ; end ;
17575: PPOPN 4
17577: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 do
17578: LD_EXP 10
17582: PUSH
17583: LD_EXP 17
17587: PUSH
17588: LD_INT 1
17590: LESS
17591: AND
17592: IFFALSE 17983
17594: GO 17596
17596: DISABLE
// begin DialogueOn ;
17597: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
17601: LD_EXP 24
17605: PPUSH
17606: LD_STRING DH-1-final
17608: PPUSH
17609: CALL_OW 88
// if tick <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
17613: LD_OWVAR 1
17617: PUSH
17618: LD_INT 126000
17620: PUSH
17621: LD_INT 115500
17623: PUSH
17624: LD_INT 105000
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: LIST
17631: PUSH
17632: LD_OWVAR 67
17636: ARRAY
17637: LESSEQUAL
17638: IFFALSE 17652
// AddMedal ( med1 , 1 ) else
17640: LD_STRING med1
17642: PPUSH
17643: LD_INT 1
17645: PPUSH
17646: CALL_OW 101
17650: GO 17663
// AddMedal ( med1 , - 1 ) ;
17652: LD_STRING med1
17654: PPUSH
17655: LD_INT 1
17657: NEG
17658: PPUSH
17659: CALL_OW 101
// if vehCounter >= 2 then
17663: LD_EXP 18
17667: PUSH
17668: LD_INT 2
17670: GREATEREQUAL
17671: IFFALSE 17685
// AddMedal ( med2 , 1 ) else
17673: LD_STRING med2
17675: PPUSH
17676: LD_INT 1
17678: PPUSH
17679: CALL_OW 101
17683: GO 17696
// AddMedal ( med2 , - 1 ) ;
17685: LD_STRING med2
17687: PPUSH
17688: LD_INT 1
17690: NEG
17691: PPUSH
17692: CALL_OW 101
// if deadCounter = 0 then
17696: LD_EXP 8
17700: PUSH
17701: LD_INT 0
17703: EQUAL
17704: IFFALSE 17718
// AddMedal ( med3 , 1 ) else
17706: LD_STRING med3
17708: PPUSH
17709: LD_INT 1
17711: PPUSH
17712: CALL_OW 101
17716: GO 17729
// AddMedal ( med3 , - 1 ) ;
17718: LD_STRING med3
17720: PPUSH
17721: LD_INT 1
17723: NEG
17724: PPUSH
17725: CALL_OW 101
// GiveMedals ( MAIN ) ;
17729: LD_STRING MAIN
17731: PPUSH
17732: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
17736: LD_INT 22
17738: PUSH
17739: LD_INT 2
17741: PUSH
17742: EMPTY
17743: LIST
17744: LIST
17745: PUSH
17746: LD_INT 23
17748: PUSH
17749: LD_INT 2
17751: PUSH
17752: EMPTY
17753: LIST
17754: LIST
17755: PUSH
17756: LD_INT 21
17758: PUSH
17759: LD_INT 1
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: LIST
17770: PPUSH
17771: CALL_OW 69
17775: PPUSH
17776: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
17780: LD_EXP 24
17784: PPUSH
17785: LD_STRING 03_Heike
17787: PPUSH
17788: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
17792: LD_EXP 28
17796: PPUSH
17797: LD_STRING 03_Aviradze
17799: PPUSH
17800: CALL_OW 38
// if Givi then
17804: LD_EXP 25
17808: IFFALSE 17822
// SaveCharacters ( Givi , 03_Givi ) ;
17810: LD_EXP 25
17814: PPUSH
17815: LD_STRING 03_Givi
17817: PPUSH
17818: CALL_OW 38
// if Mike then
17822: LD_EXP 26
17826: IFFALSE 17840
// SaveCharacters ( Mike , 03_Mike ) ;
17828: LD_EXP 26
17832: PPUSH
17833: LD_STRING 03_Mike
17835: PPUSH
17836: CALL_OW 38
// if Kamil then
17840: LD_EXP 27
17844: IFFALSE 17858
// SaveCharacters ( Kamil , 03_Kamil ) ;
17846: LD_EXP 27
17850: PPUSH
17851: LD_STRING 03_Kamil
17853: PPUSH
17854: CALL_OW 38
// if Kaia then
17858: LD_EXP 29
17862: IFFALSE 17876
// SaveCharacters ( Kaia , 03_Kaia ) ;
17864: LD_EXP 29
17868: PPUSH
17869: LD_STRING 03_Kaia
17871: PPUSH
17872: CALL_OW 38
// if Sophia then
17876: LD_EXP 30
17880: IFFALSE 17894
// SaveCharacters ( Sophia , 03_Sophia ) ;
17882: LD_EXP 30
17886: PPUSH
17887: LD_STRING 03_Sophia
17889: PPUSH
17890: CALL_OW 38
// if Markov then
17894: LD_EXP 31
17898: IFFALSE 17912
// SaveCharacters ( Markov , 03_Markov ) ;
17900: LD_EXP 31
17904: PPUSH
17905: LD_STRING 03_Markov
17907: PPUSH
17908: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
17912: LD_EXP 34
17916: PUSH
17917: LD_EXP 34
17921: PPUSH
17922: CALL_OW 255
17926: PUSH
17927: LD_INT 2
17929: EQUAL
17930: AND
17931: IFFALSE 17945
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
17933: LD_EXP 34
17937: PPUSH
17938: LD_STRING 03_Ibrahim
17940: PPUSH
17941: CALL_OW 38
// if heikeSecondSquad then
17945: LD_EXP 38
17949: IFFALSE 17963
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
17951: LD_EXP 38
17955: PPUSH
17956: LD_STRING 03_others
17958: PPUSH
17959: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
17963: LD_EXP 8
17967: PPUSH
17968: LD_STRING 03_DeadCounter
17970: PPUSH
17971: CALL_OW 39
// YouWin ;
17975: CALL_OW 103
// DialogueOff ;
17979: CALL_OW 7
// end ; end_of_file
17983: END
// on UnitDestroyed ( un ) do begin if un = Heike then
17984: LD_VAR 0 1
17988: PUSH
17989: LD_EXP 24
17993: EQUAL
17994: IFFALSE 18003
// YouLost ( Heike ) ;
17996: LD_STRING Heike
17998: PPUSH
17999: CALL_OW 104
// if un = Aviradze then
18003: LD_VAR 0 1
18007: PUSH
18008: LD_EXP 28
18012: EQUAL
18013: IFFALSE 18022
// YouLost ( Aviradze ) ;
18015: LD_STRING Aviradze
18017: PPUSH
18018: CALL_OW 104
// if un = usDepot and not retreatAllowed then
18022: LD_VAR 0 1
18026: PUSH
18027: LD_INT 11
18029: EQUAL
18030: PUSH
18031: LD_EXP 10
18035: NOT
18036: AND
18037: IFFALSE 18046
// YouLost ( Depot ) ;
18039: LD_STRING Depot
18041: PPUSH
18042: CALL_OW 104
// if un = arDepot then
18046: LD_VAR 0 1
18050: PUSH
18051: LD_INT 5
18053: EQUAL
18054: IFFALSE 18063
// YouLost ( FarmerDepot ) ;
18056: LD_STRING FarmerDepot
18058: PPUSH
18059: CALL_OW 104
// if un = Farmer then
18063: LD_VAR 0 1
18067: PUSH
18068: LD_EXP 32
18072: EQUAL
18073: IFFALSE 18082
// YouLost ( Farmer ) ;
18075: LD_STRING Farmer
18077: PPUSH
18078: CALL_OW 104
// if un in usForces then
18082: LD_VAR 0 1
18086: PUSH
18087: LD_EXP 40
18091: IN
18092: IFFALSE 18110
// usForces := usForces diff un ;
18094: LD_ADDR_EXP 40
18098: PUSH
18099: LD_EXP 40
18103: PUSH
18104: LD_VAR 0 1
18108: DIFF
18109: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
18110: LD_VAR 0 1
18114: PUSH
18115: LD_INT 22
18117: PUSH
18118: LD_INT 2
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 23
18127: PUSH
18128: LD_INT 2
18130: PUSH
18131: EMPTY
18132: LIST
18133: LIST
18134: PUSH
18135: LD_INT 21
18137: PUSH
18138: LD_INT 1
18140: PUSH
18141: EMPTY
18142: LIST
18143: LIST
18144: PUSH
18145: EMPTY
18146: LIST
18147: LIST
18148: LIST
18149: PPUSH
18150: CALL_OW 69
18154: IN
18155: IFFALSE 18171
// deadCounter := deadCounter + 1 ;
18157: LD_ADDR_EXP 8
18161: PUSH
18162: LD_EXP 8
18166: PUSH
18167: LD_INT 1
18169: PLUS
18170: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
18171: LD_VAR 0 1
18175: PUSH
18176: LD_INT 22
18178: PUSH
18179: LD_INT 4
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: PUSH
18186: LD_INT 34
18188: PUSH
18189: LD_INT 12
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: PUSH
18196: EMPTY
18197: LIST
18198: LIST
18199: PPUSH
18200: CALL_OW 69
18204: IN
18205: PUSH
18206: LD_EXP 15
18210: NOT
18211: AND
18212: IFFALSE 18222
// firstConvoyDestroyed := true ;
18214: LD_ADDR_EXP 15
18218: PUSH
18219: LD_INT 1
18221: ST_TO_ADDR
// if un in usAttackers then
18222: LD_VAR 0 1
18226: PUSH
18227: LD_EXP 43
18231: IN
18232: IFFALSE 18250
// usAttackers := usAttackers diff un ;
18234: LD_ADDR_EXP 43
18238: PUSH
18239: LD_EXP 43
18243: PUSH
18244: LD_VAR 0 1
18248: DIFF
18249: ST_TO_ADDR
// end ;
18250: PPOPN 1
18252: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18253: LD_VAR 0 2
18257: PUSH
18258: LD_EXP 34
18262: EQUAL
18263: PUSH
18264: LD_EXP 21
18268: AND
18269: IFFALSE 18315
// begin Video ( true ) ;
18271: LD_INT 1
18273: PPUSH
18274: CALL 1004 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
18278: LD_EXP 34
18282: PPUSH
18283: LD_INT 11
18285: PPUSH
18286: CALL_OW 120
// repeat wait ( 3 ) ;
18290: LD_INT 3
18292: PPUSH
18293: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18297: LD_EXP 34
18301: PPUSH
18302: CALL_OW 310
18306: IFFALSE 18290
// Video ( false ) ;
18308: LD_INT 0
18310: PPUSH
18311: CALL 1004 0 1
// end ; end ;
18315: PPOPN 2
18317: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
18318: LD_VAR 0 2
18322: PUSH
18323: LD_EXP 24
18327: EQUAL
18328: PUSH
18329: LD_VAR 0 1
18333: PUSH
18334: LD_INT 11
18336: EQUAL
18337: AND
18338: PUSH
18339: LD_EXP 21
18343: AND
18344: IFFALSE 18350
// IbrahimQuery ;
18346: CALL 16440 0 0
// end ;
18350: PPOPN 2
18352: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin ComStop ( newId ) ;
18353: LD_VAR 0 1
18357: PPUSH
18358: CALL_OW 141
// if oldId in usAttackers then
18362: LD_VAR 0 2
18366: PUSH
18367: LD_EXP 43
18371: IN
18372: IFFALSE 18390
// usAttackers := usAttackers diff oldId ;
18374: LD_ADDR_EXP 43
18378: PUSH
18379: LD_EXP 43
18383: PUSH
18384: LD_VAR 0 2
18388: DIFF
18389: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
18390: LD_VAR 0 3
18394: PUSH
18395: LD_INT 4
18397: EQUAL
18398: PUSH
18399: LD_EXP 15
18403: NOT
18404: AND
18405: IFFALSE 18415
// firstConvoyDestroyed := true ;
18407: LD_ADDR_EXP 15
18411: PUSH
18412: LD_INT 1
18414: ST_TO_ADDR
// if GetWeapon ( oldId ) = us_cargo_bay and GetCargo ( oldId , mat_cans ) = 0 then
18415: LD_VAR 0 2
18419: PPUSH
18420: CALL_OW 264
18424: PUSH
18425: LD_INT 12
18427: EQUAL
18428: PUSH
18429: LD_VAR 0 2
18433: PPUSH
18434: LD_INT 1
18436: PPUSH
18437: CALL_OW 289
18441: PUSH
18442: LD_INT 0
18444: EQUAL
18445: AND
18446: IFFALSE 18452
// EmptyCargoDialog ;
18448: CALL 15221 0 0
// end ;
18452: PPOPN 4
18454: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
18455: LD_VAR 0 1
18459: PUSH
18460: LD_INT 2
18462: EQUAL
18463: PUSH
18464: LD_VAR 0 2
18468: PUSH
18469: LD_INT 5
18471: EQUAL
18472: AND
18473: IFFALSE 18482
// YouLost ( Attack ) ;
18475: LD_STRING Attack
18477: PPUSH
18478: CALL_OW 104
// end ;
18482: PPOPN 2
18484: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 and not americanBaseCaptured then
18485: LD_VAR 0 1
18489: PPUSH
18490: CALL_OW 255
18494: PUSH
18495: LD_INT 1
18497: EQUAL
18498: PUSH
18499: LD_EXP 6
18503: NOT
18504: AND
18505: IFFALSE 18639
// begin if GetBType ( b ) = b_lab then
18507: LD_VAR 0 1
18511: PPUSH
18512: CALL_OW 266
18516: PUSH
18517: LD_INT 6
18519: EQUAL
18520: IFFALSE 18560
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
18522: LD_EXP 40
18526: PPUSH
18527: LD_INT 25
18529: PUSH
18530: LD_INT 4
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: PPUSH
18537: CALL_OW 72
18541: PPUSH
18542: LD_VAR 0 1
18546: PPUSH
18547: CALL_OW 120
// AmLabResearch ( b ) ;
18551: LD_VAR 0 1
18555: PPUSH
18556: CALL 6020 0 1
// end ; if GetBType ( b ) = b_armoury then
18560: LD_VAR 0 1
18564: PPUSH
18565: CALL_OW 266
18569: PUSH
18570: LD_INT 4
18572: EQUAL
18573: IFFALSE 18621
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
18575: LD_EXP 40
18579: PPUSH
18580: LD_INT 25
18582: PUSH
18583: LD_INT 1
18585: PUSH
18586: EMPTY
18587: LIST
18588: LIST
18589: PUSH
18590: LD_INT 3
18592: PUSH
18593: LD_INT 54
18595: PUSH
18596: EMPTY
18597: LIST
18598: PUSH
18599: EMPTY
18600: LIST
18601: LIST
18602: PUSH
18603: EMPTY
18604: LIST
18605: LIST
18606: PPUSH
18607: CALL_OW 72
18611: PPUSH
18612: LD_VAR 0 1
18616: PPUSH
18617: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
18621: LD_ADDR_EXP 42
18625: PUSH
18626: LD_EXP 42
18630: PPUSH
18631: LD_INT 1
18633: PPUSH
18634: CALL_OW 3
18638: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
18639: LD_VAR 0 1
18643: PPUSH
18644: CALL_OW 255
18648: PUSH
18649: LD_INT 5
18651: EQUAL
18652: IFFALSE 18666
// SetBLevel ( b , 5 ) ;
18654: LD_VAR 0 1
18658: PPUSH
18659: LD_INT 5
18661: PPUSH
18662: CALL_OW 241
// end ;
18666: PPOPN 1
18668: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
18669: LD_VAR 0 1
18673: PPUSH
18674: CALL_OW 255
18678: PUSH
18679: LD_INT 2
18681: EQUAL
18682: IFFALSE 18698
// vehCounter := vehCounter + 1 ;
18684: LD_ADDR_EXP 18
18688: PUSH
18689: LD_EXP 18
18693: PUSH
18694: LD_INT 1
18696: PLUS
18697: ST_TO_ADDR
// end ;
18698: PPOPN 2
18700: END
// on SailEvent ( event ) do begin if event = eventAttack then
18701: LD_VAR 0 1
18705: PUSH
18706: LD_EXP 20
18710: EQUAL
18711: IFFALSE 18717
// AmericanAttack ;
18713: CALL 7477 0 0
// end ; end_of_file
18717: PPOPN 1
18719: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 4 4$00 , 3 3$00 , 2 2$30 ] [ Difficulty ] do
18720: LD_OWVAR 1
18724: PUSH
18725: LD_INT 8400
18727: PUSH
18728: LD_INT 6300
18730: PUSH
18731: LD_INT 5250
18733: PUSH
18734: EMPTY
18735: LIST
18736: LIST
18737: LIST
18738: PUSH
18739: LD_OWVAR 67
18743: ARRAY
18744: LESSEQUAL
18745: IFFALSE 18772
18747: GO 18749
18749: DISABLE
// begin enable ;
18750: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18751: LD_INT 1
18753: PPUSH
18754: LD_INT 5
18756: PPUSH
18757: CALL_OW 12
18761: PPUSH
18762: LD_INT 9
18764: PPUSH
18765: LD_INT 1
18767: PPUSH
18768: CALL_OW 55
// end ;
18772: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 26 26$00 , 23 23$00 , 20 20$00 ] [ Difficulty ] do
18773: LD_EXP 6
18777: PUSH
18778: LD_OWVAR 1
18782: PUSH
18783: LD_INT 54600
18785: PUSH
18786: LD_INT 48300
18788: PUSH
18789: LD_INT 42000
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: LIST
18796: PUSH
18797: LD_OWVAR 67
18801: ARRAY
18802: LESSEQUAL
18803: AND
18804: IFFALSE 18831
18806: GO 18808
18808: DISABLE
// begin enable ;
18809: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18810: LD_INT 1
18812: PPUSH
18813: LD_INT 5
18815: PPUSH
18816: CALL_OW 12
18820: PPUSH
18821: LD_INT 9
18823: PPUSH
18824: LD_INT 1
18826: PPUSH
18827: CALL_OW 55
// end ; end_of_file
18831: END
// every 0 0$1 trigger not retreatAllowed and farmerRequestedCrates and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
18832: LD_EXP 10
18836: NOT
18837: PUSH
18838: LD_EXP 13
18842: AND
18843: PUSH
18844: LD_EXP 4
18848: AND
18849: PUSH
18850: LD_EXP 12
18854: PUSH
18855: LD_EXP 13
18859: LESSEQUAL
18860: AND
18861: IFFALSE 18951
18863: GO 18865
18865: DISABLE
// begin enable ;
18866: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
18867: LD_ADDR_OWVAR 47
18871: PUSH
18872: LD_STRING #X103-1
18874: PUSH
18875: LD_EXP 12
18879: PUSH
18880: LD_EXP 13
18884: PUSH
18885: EMPTY
18886: LIST
18887: LIST
18888: LIST
18889: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
18890: LD_ADDR_EXP 12
18894: PUSH
18895: LD_INT 5
18897: PPUSH
18898: CALL_OW 274
18902: PPUSH
18903: LD_INT 1
18905: PPUSH
18906: CALL_OW 275
18910: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
18911: LD_INT 10
18913: PPUSH
18914: LD_INT 1
18916: PPUSH
18917: CALL_OW 287
18921: PUSH
18922: LD_INT 0
18924: EQUAL
18925: IFFALSE 18943
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
18927: LD_ADDR_EXP 14
18931: PUSH
18932: LD_EXP 14
18936: PUSH
18937: LD_INT 35
18939: MINUS
18940: ST_TO_ADDR
18941: GO 18951
// farmerCratesCounter := 30 30$00 ;
18943: LD_ADDR_EXP 14
18947: PUSH
18948: LD_INT 63000
18950: ST_TO_ADDR
// end ; end_of_file
18951: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18952: GO 18954
18954: DISABLE
// begin ru_radar := 98 ;
18955: LD_ADDR_EXP 44
18959: PUSH
18960: LD_INT 98
18962: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18963: LD_ADDR_EXP 45
18967: PUSH
18968: LD_INT 89
18970: ST_TO_ADDR
// us_hack := 99 ;
18971: LD_ADDR_EXP 46
18975: PUSH
18976: LD_INT 99
18978: ST_TO_ADDR
// us_artillery := 97 ;
18979: LD_ADDR_EXP 47
18983: PUSH
18984: LD_INT 97
18986: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18987: LD_ADDR_EXP 48
18991: PUSH
18992: LD_INT 91
18994: ST_TO_ADDR
// tech_Artillery := 80 ;
18995: LD_ADDR_EXP 49
18999: PUSH
19000: LD_INT 80
19002: ST_TO_ADDR
// tech_RadMat := 81 ;
19003: LD_ADDR_EXP 50
19007: PUSH
19008: LD_INT 81
19010: ST_TO_ADDR
// tech_BasicTools := 82 ;
19011: LD_ADDR_EXP 51
19015: PUSH
19016: LD_INT 82
19018: ST_TO_ADDR
// tech_Cargo := 83 ;
19019: LD_ADDR_EXP 52
19023: PUSH
19024: LD_INT 83
19026: ST_TO_ADDR
// tech_Track := 84 ;
19027: LD_ADDR_EXP 53
19031: PUSH
19032: LD_INT 84
19034: ST_TO_ADDR
// tech_Crane := 85 ;
19035: LD_ADDR_EXP 54
19039: PUSH
19040: LD_INT 85
19042: ST_TO_ADDR
// tech_Bulldozer := 86 ;
19043: LD_ADDR_EXP 55
19047: PUSH
19048: LD_INT 86
19050: ST_TO_ADDR
// tech_Hovercraft := 87 ;
19051: LD_ADDR_EXP 56
19055: PUSH
19056: LD_INT 87
19058: ST_TO_ADDR
// end ;
19059: END
