// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 38 0 0
// PrepareNature ;
   8: CALL 607 0 0
// PrepareArabian ;
  12: CALL 1133 0 0
// PrepareAmerican ;
  16: CALL 3911 0 0
// if debug then
  20: LD_EXP 1
  24: IFFALSE 33
// FogOff ( 2 ) ;
  26: LD_INT 2
  28: PPUSH
  29: CALL_OW 344
// Action ;
  33: CALL 7985 0 0
// end ;
  37: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := false ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 0
  48: ST_TO_ADDR
// prefix := 02_ ;
  49: LD_ADDR_EXP 2
  53: PUSH
  54: LD_STRING 02_
  56: ST_TO_ADDR
// eventAttack := 1 ;
  57: LD_ADDR_EXP 20
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// deadCounter := 0 ;
  65: LD_ADDR_EXP 8
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// gameStarted := false ;
  73: LD_ADDR_EXP 3
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// farmerBaseReady := false ;
  81: LD_ADDR_EXP 4
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// americanBaseSpoted := false ;
  89: LD_ADDR_EXP 5
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// americanBaseCaptured := false ;
  97: LD_ADDR_EXP 6
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// americanHasEscaped := false ;
 105: LD_ADDR_EXP 7
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// workshopBuilded := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// retreatAllowed := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// allowConvoys := false ;
 129: LD_ADDR_EXP 11
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// farmerCrates := 0 ;
 137: LD_ADDR_EXP 12
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 145: LD_ADDR_EXP 13
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// farmerCratesCounter := 4 4$00 ;
 153: LD_ADDR_EXP 14
 157: PUSH
 158: LD_INT 8400
 160: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 161: LD_ADDR_EXP 15
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// attackWave := 1 ;
 169: LD_ADDR_EXP 16
 173: PUSH
 174: LD_INT 1
 176: ST_TO_ADDR
// omarCargoCounter := [ 6 , 9 , 12 ] [ Difficulty ] ;
 177: LD_ADDR_EXP 17
 181: PUSH
 182: LD_INT 6
 184: PUSH
 185: LD_INT 9
 187: PUSH
 188: LD_INT 12
 190: PUSH
 191: EMPTY
 192: LIST
 193: LIST
 194: LIST
 195: PUSH
 196: LD_OWVAR 67
 200: ARRAY
 201: ST_TO_ADDR
// vehCounter := 0 ;
 202: LD_ADDR_EXP 18
 206: PUSH
 207: LD_INT 0
 209: ST_TO_ADDR
// convoyCounter := 0 ;
 210: LD_ADDR_EXP 19
 214: PUSH
 215: LD_INT 0
 217: ST_TO_ADDR
// ibrahimInDepot := false ;
 218: LD_ADDR_EXP 21
 222: PUSH
 223: LD_INT 0
 225: ST_TO_ADDR
// ibrahimIsFree := false ;
 226: LD_ADDR_EXP 22
 230: PUSH
 231: LD_INT 0
 233: ST_TO_ADDR
// end ; end_of_file
 234: LD_VAR 0 1
 238: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 239: LD_INT 0
 241: PPUSH
 242: PPUSH
// if exist_mode then
 243: LD_VAR 0 2
 247: IFFALSE 272
// unit := CreateCharacter ( prefix & ident ) else
 249: LD_ADDR_VAR 0 5
 253: PUSH
 254: LD_VAR 0 3
 258: PUSH
 259: LD_VAR 0 1
 263: STR
 264: PPUSH
 265: CALL_OW 34
 269: ST_TO_ADDR
 270: GO 287
// unit := NewCharacter ( ident ) ;
 272: LD_ADDR_VAR 0 5
 276: PUSH
 277: LD_VAR 0 1
 281: PPUSH
 282: CALL_OW 25
 286: ST_TO_ADDR
// result := unit ;
 287: LD_ADDR_VAR 0 4
 291: PUSH
 292: LD_VAR 0 5
 296: ST_TO_ADDR
// end ;
 297: LD_VAR 0 4
 301: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 302: LD_INT 0
 304: PPUSH
// uc_side := side ;
 305: LD_ADDR_OWVAR 20
 309: PUSH
 310: LD_VAR 0 1
 314: ST_TO_ADDR
// uc_nation := nation ;
 315: LD_ADDR_OWVAR 21
 319: PUSH
 320: LD_VAR 0 2
 324: ST_TO_ADDR
// vc_chassis := chassis ;
 325: LD_ADDR_OWVAR 37
 329: PUSH
 330: LD_VAR 0 3
 334: ST_TO_ADDR
// vc_engine := engine ;
 335: LD_ADDR_OWVAR 39
 339: PUSH
 340: LD_VAR 0 4
 344: ST_TO_ADDR
// vc_control := control ;
 345: LD_ADDR_OWVAR 38
 349: PUSH
 350: LD_VAR 0 5
 354: ST_TO_ADDR
// vc_weapon := weapon ;
 355: LD_ADDR_OWVAR 40
 359: PUSH
 360: LD_VAR 0 6
 364: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 365: LD_ADDR_OWVAR 41
 369: PUSH
 370: LD_VAR 0 7
 374: ST_TO_ADDR
// result := CreateVehicle ;
 375: LD_ADDR_VAR 0 8
 379: PUSH
 380: CALL_OW 45
 384: ST_TO_ADDR
// end ;
 385: LD_VAR 0 8
 389: RET
// export function SayX ( units , ident ) ; var i ; begin
 390: LD_INT 0
 392: PPUSH
 393: PPUSH
// result := false ;
 394: LD_ADDR_VAR 0 3
 398: PUSH
 399: LD_INT 0
 401: ST_TO_ADDR
// if not units then
 402: LD_VAR 0 1
 406: NOT
 407: IFFALSE 411
// exit ;
 409: GO 465
// for i in units do
 411: LD_ADDR_VAR 0 4
 415: PUSH
 416: LD_VAR 0 1
 420: PUSH
 421: FOR_IN
 422: IFFALSE 463
// if IsOk ( i ) then
 424: LD_VAR 0 4
 428: PPUSH
 429: CALL_OW 302
 433: IFFALSE 461
// begin Say ( i , ident ) ;
 435: LD_VAR 0 4
 439: PPUSH
 440: LD_VAR 0 2
 444: PPUSH
 445: CALL_OW 88
// result := i ;
 449: LD_ADDR_VAR 0 3
 453: PUSH
 454: LD_VAR 0 4
 458: ST_TO_ADDR
// break ;
 459: GO 463
// end ;
 461: GO 421
 463: POP
 464: POP
// end ;
 465: LD_VAR 0 3
 469: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 470: LD_INT 0
 472: PPUSH
 473: PPUSH
// InitUc ;
 474: CALL_OW 18
// InitHc ;
 478: CALL_OW 19
// uc_side := 0 ;
 482: LD_ADDR_OWVAR 20
 486: PUSH
 487: LD_INT 0
 489: ST_TO_ADDR
// uc_nation := 0 ;
 490: LD_ADDR_OWVAR 21
 494: PUSH
 495: LD_INT 0
 497: ST_TO_ADDR
// for i = 1 to amount do
 498: LD_ADDR_VAR 0 4
 502: PUSH
 503: DOUBLE
 504: LD_INT 1
 506: DEC
 507: ST_TO_ADDR
 508: LD_VAR 0 2
 512: PUSH
 513: FOR_TO
 514: IFFALSE 596
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 516: LD_ADDR_OWVAR 29
 520: PUSH
 521: LD_INT 9
 523: PPUSH
 524: LD_INT 12
 526: PPUSH
 527: CALL_OW 12
 531: PUSH
 532: LD_INT 9
 534: PPUSH
 535: LD_INT 12
 537: PPUSH
 538: CALL_OW 12
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 547: LD_ADDR_OWVAR 35
 551: PUSH
 552: LD_INT 1
 554: NEG
 555: PPUSH
 556: LD_INT 1
 558: PPUSH
 559: CALL_OW 12
 563: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 564: LD_INT 0
 566: PPUSH
 567: LD_INT 12
 569: PPUSH
 570: LD_INT 1
 572: PPUSH
 573: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 577: CALL_OW 44
 581: PPUSH
 582: LD_VAR 0 1
 586: PPUSH
 587: LD_INT 0
 589: PPUSH
 590: CALL_OW 49
// end ;
 594: GO 513
 596: POP
 597: POP
// InitHc ;
 598: CALL_OW 19
// end ;
 602: LD_VAR 0 3
 606: RET
// export function PrepareNature ; var i ; begin
 607: LD_INT 0
 609: PPUSH
 610: PPUSH
// SpawnApeman ( forest , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
 611: LD_INT 2
 613: PPUSH
 614: LD_INT 4
 616: PUSH
 617: LD_INT 4
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: PUSH
 628: LD_OWVAR 67
 632: ARRAY
 633: PPUSH
 634: CALL 470 0 2
// for i := 1 to 3 do
 638: LD_ADDR_VAR 0 2
 642: PUSH
 643: DOUBLE
 644: LD_INT 1
 646: DEC
 647: ST_TO_ADDR
 648: LD_INT 3
 650: PUSH
 651: FOR_TO
 652: IFFALSE 687
// begin hc_class := 21 ;
 654: LD_ADDR_OWVAR 28
 658: PUSH
 659: LD_INT 21
 661: ST_TO_ADDR
// hc_gallery :=  ;
 662: LD_ADDR_OWVAR 33
 666: PUSH
 667: LD_STRING 
 669: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 670: CALL_OW 44
 674: PPUSH
 675: LD_INT 2
 677: PPUSH
 678: LD_INT 0
 680: PPUSH
 681: CALL_OW 49
// end ;
 685: GO 651
 687: POP
 688: POP
// for i := 1 to 2 do
 689: LD_ADDR_VAR 0 2
 693: PUSH
 694: DOUBLE
 695: LD_INT 1
 697: DEC
 698: ST_TO_ADDR
 699: LD_INT 2
 701: PUSH
 702: FOR_TO
 703: IFFALSE 738
// begin hc_class := 18 ;
 705: LD_ADDR_OWVAR 28
 709: PUSH
 710: LD_INT 18
 712: ST_TO_ADDR
// hc_gallery :=  ;
 713: LD_ADDR_OWVAR 33
 717: PUSH
 718: LD_STRING 
 720: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 721: CALL_OW 44
 725: PPUSH
 726: LD_INT 2
 728: PPUSH
 729: LD_INT 0
 731: PPUSH
 732: CALL_OW 49
// end ;
 736: GO 702
 738: POP
 739: POP
// for i := 1 to 2 do
 740: LD_ADDR_VAR 0 2
 744: PUSH
 745: DOUBLE
 746: LD_INT 1
 748: DEC
 749: ST_TO_ADDR
 750: LD_INT 2
 752: PUSH
 753: FOR_TO
 754: IFFALSE 789
// begin hc_class := 13 ;
 756: LD_ADDR_OWVAR 28
 760: PUSH
 761: LD_INT 13
 763: ST_TO_ADDR
// hc_gallery :=  ;
 764: LD_ADDR_OWVAR 33
 768: PUSH
 769: LD_STRING 
 771: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 772: CALL_OW 44
 776: PPUSH
 777: LD_INT 2
 779: PPUSH
 780: LD_INT 0
 782: PPUSH
 783: CALL_OW 49
// end ;
 787: GO 753
 789: POP
 790: POP
// end ;
 791: LD_VAR 0 1
 795: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 796: LD_INT 0
 798: PPUSH
 799: PPUSH
 800: PPUSH
// if not observer or not unit then
 801: LD_VAR 0 1
 805: NOT
 806: PUSH
 807: LD_VAR 0 2
 811: NOT
 812: OR
 813: IFFALSE 817
// exit ;
 815: GO 865
// if not See ( GetSide ( observer ) , unit ) then
 817: LD_VAR 0 1
 821: PPUSH
 822: CALL_OW 255
 826: PPUSH
 827: LD_VAR 0 2
 831: PPUSH
 832: CALL_OW 292
 836: NOT
 837: IFFALSE 841
// exit ;
 839: GO 865
// result := GetDistUnits ( observer , unit ) < 12 ;
 841: LD_ADDR_VAR 0 3
 845: PUSH
 846: LD_VAR 0 1
 850: PPUSH
 851: LD_VAR 0 2
 855: PPUSH
 856: CALL_OW 296
 860: PUSH
 861: LD_INT 12
 863: LESS
 864: ST_TO_ADDR
// end ;
 865: LD_VAR 0 3
 869: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 870: LD_INT 0
 872: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 873: LD_VAR 0 2
 877: PUSH
 878: LD_INT 1
 880: ARRAY
 881: PPUSH
 882: LD_VAR 0 2
 886: PUSH
 887: LD_INT 2
 889: ARRAY
 890: PPUSH
 891: CALL_OW 488
 895: PUSH
 896: LD_VAR 0 2
 900: PUSH
 901: LD_INT 1
 903: ARRAY
 904: PPUSH
 905: LD_VAR 0 2
 909: PUSH
 910: LD_INT 2
 912: ARRAY
 913: PPUSH
 914: CALL_OW 428
 918: PUSH
 919: LD_INT 0
 921: EQUAL
 922: AND
 923: IFFALSE 957
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 925: LD_VAR 0 1
 929: PPUSH
 930: LD_VAR 0 2
 934: PUSH
 935: LD_INT 1
 937: ARRAY
 938: PPUSH
 939: LD_VAR 0 2
 943: PUSH
 944: LD_INT 2
 946: ARRAY
 947: PPUSH
 948: LD_VAR 0 3
 952: PPUSH
 953: CALL_OW 48
// end ;
 957: LD_VAR 0 4
 961: RET
// export function Video ( mode ) ; begin
 962: LD_INT 0
 964: PPUSH
// ingame_video = mode ;
 965: LD_ADDR_OWVAR 52
 969: PUSH
 970: LD_VAR 0 1
 974: ST_TO_ADDR
// interface_hidden = mode ;
 975: LD_ADDR_OWVAR 54
 979: PUSH
 980: LD_VAR 0 1
 984: ST_TO_ADDR
// end ;
 985: LD_VAR 0 2
 989: RET
// export function ReverseArray ( array ) ; var i ; begin
 990: LD_INT 0
 992: PPUSH
 993: PPUSH
// if not array then
 994: LD_VAR 0 1
 998: NOT
 999: IFFALSE 1003
// exit ;
1001: GO 1061
// result := [ ] ;
1003: LD_ADDR_VAR 0 2
1007: PUSH
1008: EMPTY
1009: ST_TO_ADDR
// for i := 1 to array do
1010: LD_ADDR_VAR 0 3
1014: PUSH
1015: DOUBLE
1016: LD_INT 1
1018: DEC
1019: ST_TO_ADDR
1020: LD_VAR 0 1
1024: PUSH
1025: FOR_TO
1026: IFFALSE 1059
// result := Insert ( result , 1 , array [ i ] ) ;
1028: LD_ADDR_VAR 0 2
1032: PUSH
1033: LD_VAR 0 2
1037: PPUSH
1038: LD_INT 1
1040: PPUSH
1041: LD_VAR 0 1
1045: PUSH
1046: LD_VAR 0 3
1050: ARRAY
1051: PPUSH
1052: CALL_OW 2
1056: ST_TO_ADDR
1057: GO 1025
1059: POP
1060: POP
// end ;
1061: LD_VAR 0 2
1065: RET
// export function ComExit ( unit ) ; begin
1066: LD_INT 0
1068: PPUSH
// result := IsInUnit ( unit ) ;
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: LD_VAR 0 1
1078: PPUSH
1079: CALL_OW 310
1083: ST_TO_ADDR
// if not result then
1084: LD_VAR 0 2
1088: NOT
1089: IFFALSE 1093
// exit ;
1091: GO 1128
// if GetType ( result ) = unit_vehicle then
1093: LD_VAR 0 2
1097: PPUSH
1098: CALL_OW 247
1102: PUSH
1103: LD_INT 2
1105: EQUAL
1106: IFFALSE 1119
// ComExitVehicle ( unit ) else
1108: LD_VAR 0 1
1112: PPUSH
1113: CALL_OW 121
1117: GO 1128
// ComExitBuilding ( unit ) ;
1119: LD_VAR 0 1
1123: PPUSH
1124: CALL_OW 122
// end ; end_of_file
1128: LD_VAR 0 2
1132: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1133: LD_INT 0
1135: PPUSH
1136: PPUSH
1137: PPUSH
1138: PPUSH
// uc_side := 5 ;
1139: LD_ADDR_OWVAR 20
1143: PUSH
1144: LD_INT 5
1146: ST_TO_ADDR
// uc_nation := 2 ;
1147: LD_ADDR_OWVAR 21
1151: PUSH
1152: LD_INT 2
1154: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
1155: LD_INT 5
1157: PPUSH
1158: CALL_OW 274
1162: PPUSH
1163: LD_INT 1
1165: PPUSH
1166: LD_INT 45
1168: PPUSH
1169: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
1173: LD_ADDR_EXP 31
1177: PUSH
1178: LD_STRING Farmer
1180: PPUSH
1181: LD_INT 0
1183: PPUSH
1184: LD_STRING 
1186: PPUSH
1187: CALL 239 0 3
1191: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
1192: LD_ADDR_EXP 32
1196: PUSH
1197: LD_STRING Omar
1199: PPUSH
1200: LD_INT 0
1202: PPUSH
1203: LD_STRING 
1205: PPUSH
1206: CALL 239 0 3
1210: ST_TO_ADDR
// omarSquad := [ ] ;
1211: LD_ADDR_EXP 35
1215: PUSH
1216: EMPTY
1217: ST_TO_ADDR
// heikeSquad := [ ] ;
1218: LD_ADDR_EXP 36
1222: PUSH
1223: EMPTY
1224: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
1225: LD_ADDR_EXP 37
1229: PUSH
1230: EMPTY
1231: ST_TO_ADDR
// omarCargo := [ ] ;
1232: LD_ADDR_EXP 38
1236: PUSH
1237: EMPTY
1238: ST_TO_ADDR
// for i := 1 to 5 do
1239: LD_ADDR_VAR 0 2
1243: PUSH
1244: DOUBLE
1245: LD_INT 1
1247: DEC
1248: ST_TO_ADDR
1249: LD_INT 5
1251: PUSH
1252: FOR_TO
1253: IFFALSE 1411
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
1255: LD_INT 0
1257: PPUSH
1258: LD_INT 1
1260: PUSH
1261: LD_INT 1
1263: PUSH
1264: LD_INT 2
1266: PUSH
1267: LD_INT 1
1269: PUSH
1270: LD_INT 1
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: LIST
1279: PUSH
1280: LD_VAR 0 2
1284: ARRAY
1285: PPUSH
1286: LD_INT 3
1288: PPUSH
1289: CALL_OW 380
// un := CreateHuman ;
1293: LD_ADDR_VAR 0 3
1297: PUSH
1298: CALL_OW 44
1302: ST_TO_ADDR
// omarSquad := omarSquad union un ;
1303: LD_ADDR_EXP 35
1307: PUSH
1308: LD_EXP 35
1312: PUSH
1313: LD_VAR 0 3
1317: UNION
1318: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
1319: LD_VAR 0 3
1323: PPUSH
1324: LD_INT 87
1326: PUSH
1327: LD_INT 30
1329: PUSH
1330: EMPTY
1331: LIST
1332: LIST
1333: PUSH
1334: LD_INT 91
1336: PUSH
1337: LD_INT 32
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: PUSH
1344: LD_INT 82
1346: PUSH
1347: LD_INT 15
1349: PUSH
1350: EMPTY
1351: LIST
1352: LIST
1353: PUSH
1354: LD_INT 79
1356: PUSH
1357: LD_INT 14
1359: PUSH
1360: EMPTY
1361: LIST
1362: LIST
1363: PUSH
1364: LD_INT 82
1366: PUSH
1367: LD_INT 13
1369: PUSH
1370: EMPTY
1371: LIST
1372: LIST
1373: PUSH
1374: EMPTY
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: PUSH
1381: LD_VAR 0 2
1385: ARRAY
1386: PPUSH
1387: LD_INT 0
1389: PPUSH
1390: CALL 870 0 3
// ComTurnXY ( un , 93 , 21 ) ;
1394: LD_VAR 0 3
1398: PPUSH
1399: LD_INT 93
1401: PPUSH
1402: LD_INT 21
1404: PPUSH
1405: CALL_OW 118
// end ;
1409: GO 1252
1411: POP
1412: POP
// uc_side := 2 ;
1413: LD_ADDR_OWVAR 20
1417: PUSH
1418: LD_INT 2
1420: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
1421: LD_ADDR_EXP 23
1425: PUSH
1426: LD_STRING Heike
1428: PPUSH
1429: LD_EXP 1
1433: NOT
1434: PPUSH
1435: LD_EXP 2
1439: PPUSH
1440: CALL 239 0 3
1444: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
1445: LD_ADDR_EXP 27
1449: PUSH
1450: LD_STRING Aviradze
1452: PPUSH
1453: LD_EXP 1
1457: NOT
1458: PPUSH
1459: LD_EXP 2
1463: PPUSH
1464: CALL 239 0 3
1468: ST_TO_ADDR
// tmp := [ ] ;
1469: LD_ADDR_VAR 0 4
1473: PUSH
1474: EMPTY
1475: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
1476: LD_ADDR_EXP 24
1480: PUSH
1481: LD_STRING Givi
1483: PPUSH
1484: LD_EXP 1
1488: NOT
1489: PPUSH
1490: LD_EXP 2
1494: PPUSH
1495: CALL 239 0 3
1499: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
1500: LD_ADDR_EXP 25
1504: PUSH
1505: LD_STRING Mike
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_EXP 2
1518: PPUSH
1519: CALL 239 0 3
1523: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
1524: LD_ADDR_EXP 26
1528: PUSH
1529: LD_STRING Kamil
1531: PPUSH
1532: LD_EXP 1
1536: NOT
1537: PPUSH
1538: LD_EXP 2
1542: PPUSH
1543: CALL 239 0 3
1547: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
1548: LD_ADDR_EXP 28
1552: PUSH
1553: LD_STRING Kaia
1555: PPUSH
1556: LD_EXP 1
1560: NOT
1561: PPUSH
1562: LD_EXP 2
1566: PPUSH
1567: CALL 239 0 3
1571: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
1572: LD_ADDR_EXP 29
1576: PUSH
1577: LD_STRING Sophia
1579: PPUSH
1580: LD_EXP 1
1584: NOT
1585: PPUSH
1586: LD_EXP 2
1590: PPUSH
1591: CALL 239 0 3
1595: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
1596: LD_ADDR_EXP 30
1600: PUSH
1601: LD_STRING Markov
1603: PPUSH
1604: LD_EXP 1
1608: NOT
1609: PPUSH
1610: LD_EXP 2
1614: PPUSH
1615: CALL 239 0 3
1619: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
1620: LD_ADDR_EXP 37
1624: PUSH
1625: LD_STRING 02_others
1627: PPUSH
1628: CALL_OW 31
1632: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
1633: LD_ADDR_VAR 0 4
1637: PUSH
1638: LD_EXP 25
1642: PUSH
1643: LD_EXP 26
1647: PUSH
1648: LD_EXP 28
1652: PUSH
1653: LD_EXP 29
1657: PUSH
1658: LD_EXP 30
1662: PUSH
1663: LD_EXP 24
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: LD_EXP 37
1680: ADD
1681: PUSH
1682: LD_INT 0
1684: DIFF
1685: ST_TO_ADDR
// heikeSquad := tmp ;
1686: LD_ADDR_EXP 36
1690: PUSH
1691: LD_VAR 0 4
1695: ST_TO_ADDR
// uc_nation := 0 ;
1696: LD_ADDR_OWVAR 21
1700: PUSH
1701: LD_INT 0
1703: ST_TO_ADDR
// hc_class := class_apeman ;
1704: LD_ADDR_OWVAR 28
1708: PUSH
1709: LD_INT 12
1711: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
1712: LD_ADDR_OWVAR 31
1716: PUSH
1717: LD_INT 0
1719: PUSH
1720: LD_INT 0
1722: PUSH
1723: LD_INT 0
1725: PUSH
1726: LD_INT 0
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: LIST
1733: LIST
1734: ST_TO_ADDR
// hc_gallery :=  ;
1735: LD_ADDR_OWVAR 33
1739: PUSH
1740: LD_STRING 
1742: ST_TO_ADDR
// hc_name :=  ;
1743: LD_ADDR_OWVAR 26
1747: PUSH
1748: LD_STRING 
1750: ST_TO_ADDR
// tmp := tmp union CreateHuman ;
1751: LD_ADDR_VAR 0 4
1755: PUSH
1756: LD_VAR 0 4
1760: PUSH
1761: CALL_OW 44
1765: UNION
1766: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
1767: LD_EXP 23
1771: PPUSH
1772: LD_INT 92
1774: PPUSH
1775: LD_INT 17
1777: PPUSH
1778: LD_INT 0
1780: PPUSH
1781: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
1785: LD_EXP 31
1789: PPUSH
1790: LD_INT 95
1792: PPUSH
1793: LD_INT 19
1795: PPUSH
1796: LD_INT 0
1798: PPUSH
1799: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
1803: LD_EXP 32
1807: PPUSH
1808: LD_INT 89
1810: PPUSH
1811: LD_INT 25
1813: PPUSH
1814: LD_INT 0
1816: PPUSH
1817: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
1821: LD_EXP 27
1825: PPUSH
1826: LD_INT 92
1828: PPUSH
1829: LD_INT 27
1831: PPUSH
1832: LD_INT 0
1834: PPUSH
1835: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
1839: LD_EXP 32
1843: PPUSH
1844: LD_EXP 27
1848: PPUSH
1849: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
1853: LD_EXP 27
1857: PPUSH
1858: LD_EXP 32
1862: PPUSH
1863: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
1867: LD_EXP 23
1871: PUSH
1872: LD_EXP 31
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: PPUSH
1881: LD_EXP 32
1885: PPUSH
1886: CALL_OW 119
// if tmp then
1890: LD_VAR 0 4
1894: IFFALSE 1948
// for i in tmp do
1896: LD_ADDR_VAR 0 2
1900: PUSH
1901: LD_VAR 0 4
1905: PUSH
1906: FOR_IN
1907: IFFALSE 1946
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
1909: LD_VAR 0 2
1913: PPUSH
1914: LD_INT 94
1916: PPUSH
1917: LD_INT 14
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 0
1925: PPUSH
1926: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
1930: LD_VAR 0 2
1934: PPUSH
1935: LD_EXP 23
1939: PPUSH
1940: CALL_OW 119
// end ;
1944: GO 1906
1946: POP
1947: POP
// farmerSquad := [ ] ;
1948: LD_ADDR_EXP 34
1952: PUSH
1953: EMPTY
1954: ST_TO_ADDR
// uc_side := 5 ;
1955: LD_ADDR_OWVAR 20
1959: PUSH
1960: LD_INT 5
1962: ST_TO_ADDR
// uc_nation := 2 ;
1963: LD_ADDR_OWVAR 21
1967: PUSH
1968: LD_INT 2
1970: ST_TO_ADDR
// for i := 1 to 4 do
1971: LD_ADDR_VAR 0 2
1975: PUSH
1976: DOUBLE
1977: LD_INT 1
1979: DEC
1980: ST_TO_ADDR
1981: LD_INT 4
1983: PUSH
1984: FOR_TO
1985: IFFALSE 2063
// begin PrepareHuman ( false , 1 , 2 ) ;
1987: LD_INT 0
1989: PPUSH
1990: LD_INT 1
1992: PPUSH
1993: LD_INT 2
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 3
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2010: LD_VAR 0 3
2014: PPUSH
2015: LD_INT 102
2017: PPUSH
2018: LD_INT 27
2020: PPUSH
2021: LD_INT 4
2023: PPUSH
2024: LD_INT 0
2026: PPUSH
2027: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2031: LD_ADDR_EXP 34
2035: PUSH
2036: LD_EXP 34
2040: PUSH
2041: LD_VAR 0 3
2045: UNION
2046: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2047: LD_VAR 0 3
2051: PPUSH
2052: LD_EXP 32
2056: PPUSH
2057: CALL_OW 119
// end ;
2061: GO 1984
2063: POP
2064: POP
// PrepareHuman ( false , 2 , 2 ) ;
2065: LD_INT 0
2067: PPUSH
2068: LD_INT 2
2070: PPUSH
2071: LD_INT 2
2073: PPUSH
2074: CALL_OW 380
// un := CreateHuman ;
2078: LD_ADDR_VAR 0 3
2082: PUSH
2083: CALL_OW 44
2087: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2088: LD_VAR 0 3
2092: PPUSH
2093: LD_INT 108
2095: PPUSH
2096: LD_INT 62
2098: PPUSH
2099: LD_INT 2
2101: PPUSH
2102: LD_INT 0
2104: PPUSH
2105: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2109: LD_ADDR_EXP 34
2113: PUSH
2114: LD_EXP 34
2118: PUSH
2119: LD_VAR 0 3
2123: UNION
2124: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2125: LD_VAR 0 3
2129: PPUSH
2130: LD_EXP 32
2134: PPUSH
2135: CALL_OW 119
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
2139: LD_INT 109
2141: PPUSH
2142: LD_INT 63
2144: PPUSH
2145: LD_INT 2
2147: PPUSH
2148: LD_INT 15
2150: NEG
2151: PPUSH
2152: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
2156: LD_INT 109
2158: PPUSH
2159: LD_INT 63
2161: PPUSH
2162: LD_INT 2
2164: PPUSH
2165: CALL_OW 331
// end ;
2169: LD_VAR 0 1
2173: RET
// export function PrepareIbrahim ( x , y ) ; begin
2174: LD_INT 0
2176: PPUSH
// uc_side := 6 ;
2177: LD_ADDR_OWVAR 20
2181: PUSH
2182: LD_INT 6
2184: ST_TO_ADDR
// uc_nation := 3 ;
2185: LD_ADDR_OWVAR 21
2189: PUSH
2190: LD_INT 3
2192: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
2193: LD_ADDR_EXP 33
2197: PUSH
2198: LD_STRING IbrahimRu
2200: PPUSH
2201: LD_INT 0
2203: PPUSH
2204: LD_STRING 
2206: PPUSH
2207: CALL 239 0 3
2211: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
2212: LD_EXP 33
2216: PPUSH
2217: LD_VAR 0 1
2221: PPUSH
2222: LD_VAR 0 2
2226: PPUSH
2227: LD_INT 8
2229: PPUSH
2230: LD_INT 1
2232: PPUSH
2233: CALL_OW 50
// end ;
2237: LD_VAR 0 3
2241: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
2242: LD_EXP 32
2246: PUSH
2247: LD_EXP 35
2251: ADD
2252: PPUSH
2253: LD_INT 95
2255: PUSH
2256: LD_INT 3
2258: PUSH
2259: EMPTY
2260: LIST
2261: LIST
2262: PPUSH
2263: CALL_OW 72
2267: IFFALSE 2323
2269: GO 2271
2271: DISABLE
2272: LD_INT 0
2274: PPUSH
// begin enable ;
2275: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
2276: LD_ADDR_VAR 0 1
2280: PUSH
2281: LD_EXP 32
2285: PUSH
2286: LD_EXP 35
2290: ADD
2291: PPUSH
2292: LD_INT 95
2294: PUSH
2295: LD_INT 3
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: PPUSH
2302: CALL_OW 72
2306: PUSH
2307: FOR_IN
2308: IFFALSE 2321
// RemoveUnit ( i ) ;
2310: LD_VAR 0 1
2314: PPUSH
2315: CALL_OW 64
2319: GO 2307
2321: POP
2322: POP
// end ;
2323: PPOPN 1
2325: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
2326: LD_EXP 3
2330: PUSH
2331: LD_EXP 31
2335: PPUSH
2336: LD_INT 4
2338: PPUSH
2339: CALL_OW 308
2343: AND
2344: IFFALSE 3127
2346: GO 2348
2348: DISABLE
2349: LD_INT 0
2351: PPUSH
2352: PPUSH
2353: PPUSH
2354: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
2355: LD_EXP 31
2359: PPUSH
2360: LD_INT 110
2362: PPUSH
2363: LD_INT 60
2365: PPUSH
2366: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
2370: LD_EXP 31
2374: PPUSH
2375: LD_INT 110
2377: PPUSH
2378: LD_INT 61
2380: PPUSH
2381: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
2385: LD_ADDR_VAR 0 2
2389: PUSH
2390: LD_EXP 34
2394: PPUSH
2395: LD_INT 25
2397: PUSH
2398: LD_INT 1
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: PPUSH
2405: CALL_OW 72
2409: ST_TO_ADDR
// if tmp then
2410: LD_VAR 0 2
2414: IFFALSE 2508
// begin for i := 1 to 2 do
2416: LD_ADDR_VAR 0 1
2420: PUSH
2421: DOUBLE
2422: LD_INT 1
2424: DEC
2425: ST_TO_ADDR
2426: LD_INT 2
2428: PUSH
2429: FOR_TO
2430: IFFALSE 2506
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
2432: LD_VAR 0 2
2436: PUSH
2437: LD_VAR 0 1
2441: ARRAY
2442: PPUSH
2443: LD_INT 5
2445: PPUSH
2446: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
2450: LD_VAR 0 2
2454: PUSH
2455: LD_VAR 0 1
2459: ARRAY
2460: PPUSH
2461: LD_INT 2
2463: PPUSH
2464: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
2468: LD_VAR 0 2
2472: PUSH
2473: LD_VAR 0 1
2477: ARRAY
2478: PPUSH
2479: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
2483: LD_VAR 0 2
2487: PUSH
2488: LD_VAR 0 1
2492: ARRAY
2493: PPUSH
2494: LD_INT 107
2496: PPUSH
2497: LD_INT 66
2499: PPUSH
2500: CALL_OW 171
// end ;
2504: GO 2429
2506: POP
2507: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
2508: LD_ADDR_VAR 0 2
2512: PUSH
2513: LD_EXP 34
2517: PPUSH
2518: LD_INT 25
2520: PUSH
2521: LD_INT 2
2523: PUSH
2524: EMPTY
2525: LIST
2526: LIST
2527: PPUSH
2528: CALL_OW 72
2532: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2533: LD_INT 35
2535: PPUSH
2536: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
2540: LD_ADDR_VAR 0 2
2544: PUSH
2545: LD_EXP 34
2549: PPUSH
2550: LD_INT 25
2552: PUSH
2553: LD_INT 2
2555: PUSH
2556: EMPTY
2557: LIST
2558: LIST
2559: PPUSH
2560: CALL_OW 72
2564: ST_TO_ADDR
// until tmp ;
2565: LD_VAR 0 2
2569: IFFALSE 2533
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
2571: LD_VAR 0 2
2575: PPUSH
2576: LD_INT 31
2578: PPUSH
2579: LD_INT 102
2581: PPUSH
2582: LD_INT 69
2584: PPUSH
2585: LD_INT 2
2587: PPUSH
2588: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
2592: LD_INT 35
2594: PPUSH
2595: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
2599: LD_EXP 34
2603: PPUSH
2604: LD_INT 3
2606: PUSH
2607: LD_INT 60
2609: PUSH
2610: EMPTY
2611: LIST
2612: PUSH
2613: EMPTY
2614: LIST
2615: LIST
2616: PUSH
2617: LD_INT 25
2619: PUSH
2620: LD_INT 2
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PPUSH
2631: CALL_OW 72
2635: IFFALSE 2592
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
2637: LD_ADDR_VAR 0 2
2641: PUSH
2642: LD_EXP 34
2646: PPUSH
2647: LD_INT 25
2649: PUSH
2650: LD_INT 2
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PPUSH
2657: CALL_OW 72
2661: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
2662: LD_VAR 0 2
2666: PPUSH
2667: LD_INT 4
2669: PPUSH
2670: LD_INT 116
2672: PPUSH
2673: LD_INT 70
2675: PPUSH
2676: LD_INT 5
2678: PPUSH
2679: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
2683: LD_VAR 0 2
2687: PPUSH
2688: LD_INT 31
2690: PPUSH
2691: LD_INT 108
2693: PPUSH
2694: LD_INT 50
2696: PPUSH
2697: LD_INT 2
2699: PPUSH
2700: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
2704: LD_INT 35
2706: PPUSH
2707: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
2711: LD_INT 22
2713: PUSH
2714: LD_INT 5
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: PUSH
2721: LD_INT 30
2723: PUSH
2724: LD_INT 4
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: PUSH
2731: LD_INT 3
2733: PUSH
2734: LD_INT 57
2736: PUSH
2737: EMPTY
2738: LIST
2739: PUSH
2740: EMPTY
2741: LIST
2742: LIST
2743: PUSH
2744: EMPTY
2745: LIST
2746: LIST
2747: LIST
2748: PPUSH
2749: CALL_OW 69
2753: IFFALSE 2704
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
2755: LD_ADDR_VAR 0 3
2759: PUSH
2760: LD_INT 22
2762: PUSH
2763: LD_INT 5
2765: PUSH
2766: EMPTY
2767: LIST
2768: LIST
2769: PUSH
2770: LD_INT 30
2772: PUSH
2773: LD_INT 4
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 3
2782: PUSH
2783: LD_INT 57
2785: PUSH
2786: EMPTY
2787: LIST
2788: PUSH
2789: EMPTY
2790: LIST
2791: LIST
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: LIST
2797: PPUSH
2798: CALL_OW 69
2802: PUSH
2803: LD_INT 1
2805: ARRAY
2806: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
2807: LD_ADDR_VAR 0 2
2811: PUSH
2812: LD_EXP 34
2816: PPUSH
2817: LD_INT 25
2819: PUSH
2820: LD_INT 1
2822: PUSH
2823: EMPTY
2824: LIST
2825: LIST
2826: PPUSH
2827: CALL_OW 72
2831: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
2832: LD_VAR 0 2
2836: PPUSH
2837: LD_VAR 0 3
2841: PPUSH
2842: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
2846: LD_INT 35
2848: PPUSH
2849: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
2853: LD_INT 22
2855: PUSH
2856: LD_INT 5
2858: PUSH
2859: EMPTY
2860: LIST
2861: LIST
2862: PUSH
2863: LD_INT 30
2865: PUSH
2866: LD_INT 31
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: PUSH
2873: LD_INT 3
2875: PUSH
2876: LD_INT 57
2878: PUSH
2879: EMPTY
2880: LIST
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: LIST
2890: PPUSH
2891: CALL_OW 69
2895: PUSH
2896: LD_INT 2
2898: GREATEREQUAL
2899: IFFALSE 2846
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
2901: LD_ADDR_VAR 0 2
2905: PUSH
2906: LD_EXP 34
2910: PPUSH
2911: LD_INT 25
2913: PUSH
2914: LD_INT 2
2916: PUSH
2917: EMPTY
2918: LIST
2919: LIST
2920: PPUSH
2921: CALL_OW 72
2925: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
2926: LD_VAR 0 2
2930: PUSH
2931: LD_INT 1
2933: ARRAY
2934: PPUSH
2935: LD_INT 5
2937: PPUSH
2938: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
2942: LD_VAR 0 2
2946: PUSH
2947: LD_INT 2
2949: ARRAY
2950: PUSH
2951: LD_VAR 0 2
2955: PUSH
2956: LD_INT 3
2958: ARRAY
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: PPUSH
2964: LD_VAR 0 3
2968: PPUSH
2969: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
2973: LD_VAR 0 2
2977: PUSH
2978: LD_INT 2
2980: ARRAY
2981: PUSH
2982: LD_VAR 0 2
2986: PUSH
2987: LD_INT 3
2989: ARRAY
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: PPUSH
2995: LD_INT 1
2997: PPUSH
2998: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3002: LD_VAR 0 2
3006: PUSH
3007: LD_INT 2
3009: ARRAY
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_INT 3
3018: ARRAY
3019: PUSH
3020: EMPTY
3021: LIST
3022: LIST
3023: PPUSH
3024: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3028: LD_ADDR_VAR 0 4
3032: PUSH
3033: LD_INT 22
3035: PUSH
3036: LD_INT 5
3038: PUSH
3039: EMPTY
3040: LIST
3041: LIST
3042: PUSH
3043: LD_INT 30
3045: PUSH
3046: LD_INT 31
3048: PUSH
3049: EMPTY
3050: LIST
3051: LIST
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: PPUSH
3057: CALL_OW 69
3061: ST_TO_ADDR
// for i := 1 to 2 do
3062: LD_ADDR_VAR 0 1
3066: PUSH
3067: DOUBLE
3068: LD_INT 1
3070: DEC
3071: ST_TO_ADDR
3072: LD_INT 2
3074: PUSH
3075: FOR_TO
3076: IFFALSE 3110
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3078: LD_VAR 0 2
3082: PUSH
3083: LD_VAR 0 1
3087: PUSH
3088: LD_INT 1
3090: PLUS
3091: ARRAY
3092: PPUSH
3093: LD_VAR 0 4
3097: PUSH
3098: LD_VAR 0 1
3102: ARRAY
3103: PPUSH
3104: CALL_OW 180
3108: GO 3075
3110: POP
3111: POP
// wait ( 1 1$00 ) ;
3112: LD_INT 2100
3114: PPUSH
3115: CALL_OW 67
// farmerBaseReady := true ;
3119: LD_ADDR_EXP 4
3123: PUSH
3124: LD_INT 1
3126: ST_TO_ADDR
// end ;
3127: PPOPN 4
3129: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , damagedBuilding ;
3130: LD_EXP 4
3134: PUSH
3135: LD_EXP 10
3139: NOT
3140: AND
3141: IFFALSE 3461
3143: GO 3145
3145: DISABLE
3146: LD_INT 0
3148: PPUSH
3149: PPUSH
3150: PPUSH
// begin enable ;
3151: ENABLE
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3152: LD_ADDR_VAR 0 2
3156: PUSH
3157: LD_EXP 34
3161: PPUSH
3162: LD_INT 25
3164: PUSH
3165: LD_INT 2
3167: PUSH
3168: EMPTY
3169: LIST
3170: LIST
3171: PPUSH
3172: CALL_OW 72
3176: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
3177: LD_ADDR_VAR 0 3
3181: PUSH
3182: LD_INT 22
3184: PUSH
3185: LD_INT 5
3187: PUSH
3188: EMPTY
3189: LIST
3190: LIST
3191: PUSH
3192: LD_INT 21
3194: PUSH
3195: LD_INT 3
3197: PUSH
3198: EMPTY
3199: LIST
3200: LIST
3201: PUSH
3202: LD_INT 3
3204: PUSH
3205: LD_INT 24
3207: PUSH
3208: LD_INT 1000
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: CALL_OW 69
3228: ST_TO_ADDR
// if not eng then
3229: LD_VAR 0 2
3233: NOT
3234: IFFALSE 3326
// begin uc_side := 5 ;
3236: LD_ADDR_OWVAR 20
3240: PUSH
3241: LD_INT 5
3243: ST_TO_ADDR
// uc_nation := 2 ;
3244: LD_ADDR_OWVAR 21
3248: PUSH
3249: LD_INT 2
3251: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
3252: LD_INT 0
3254: PPUSH
3255: LD_INT 2
3257: PPUSH
3258: LD_INT 2
3260: PPUSH
3261: CALL_OW 380
// eng := CreateHuman ;
3265: LD_ADDR_VAR 0 2
3269: PUSH
3270: CALL_OW 44
3274: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
3275: LD_VAR 0 2
3279: PPUSH
3280: LD_INT 102
3282: PPUSH
3283: LD_INT 8
3285: PPUSH
3286: LD_INT 0
3288: PPUSH
3289: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
3293: LD_VAR 0 2
3297: PPUSH
3298: LD_INT 110
3300: PPUSH
3301: LD_INT 60
3303: PPUSH
3304: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
3308: LD_ADDR_EXP 34
3312: PUSH
3313: LD_EXP 34
3317: PUSH
3318: LD_VAR 0 2
3322: UNION
3323: ST_TO_ADDR
// end else
3324: GO 3461
// begin for i in eng do
3326: LD_ADDR_VAR 0 1
3330: PUSH
3331: LD_VAR 0 2
3335: PUSH
3336: FOR_IN
3337: IFFALSE 3459
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
3339: LD_INT 10
3341: PPUSH
3342: LD_INT 1
3344: PPUSH
3345: CALL_OW 287
3349: IFFALSE 3373
// begin if IsInUnit ( i ) then
3351: LD_VAR 0 1
3355: PPUSH
3356: CALL_OW 310
3360: IFFALSE 3371
// ComExitBuilding ( i ) ;
3362: LD_VAR 0 1
3366: PPUSH
3367: CALL_OW 122
// end else
3371: GO 3457
// begin if damagedBuilding then
3373: LD_VAR 0 3
3377: IFFALSE 3421
// begin if IsInUnit ( i ) then
3379: LD_VAR 0 1
3383: PPUSH
3384: CALL_OW 310
3388: IFFALSE 3401
// ComExitBuilding ( i ) else
3390: LD_VAR 0 1
3394: PPUSH
3395: CALL_OW 122
3399: GO 3419
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
3401: LD_VAR 0 1
3405: PPUSH
3406: LD_VAR 0 3
3410: PUSH
3411: LD_INT 1
3413: ARRAY
3414: PPUSH
3415: CALL_OW 130
// end else
3419: GO 3457
// if not IsInUnit ( i ) and not HasTask ( i ) then
3421: LD_VAR 0 1
3425: PPUSH
3426: CALL_OW 310
3430: NOT
3431: PUSH
3432: LD_VAR 0 1
3436: PPUSH
3437: CALL_OW 314
3441: NOT
3442: AND
3443: IFFALSE 3457
// ComEnterUnit ( i , arDepot ) ;
3445: LD_VAR 0 1
3449: PPUSH
3450: LD_INT 5
3452: PPUSH
3453: CALL_OW 120
// end ; end ;
3457: GO 3336
3459: POP
3460: POP
// end ; end ;
3461: PPOPN 3
3463: END
// export function StartCargoEvacuation ; begin
3464: LD_INT 0
3466: PPUSH
// while GetResourceType ( GetBase ( arDepot ) , mat_cans ) > 0 and omarCargoCounter > 0 do
3467: LD_INT 5
3469: PPUSH
3470: CALL_OW 274
3474: PPUSH
3475: LD_INT 1
3477: PPUSH
3478: CALL_OW 275
3482: PUSH
3483: LD_INT 0
3485: GREATER
3486: PUSH
3487: LD_EXP 17
3491: PUSH
3492: LD_INT 0
3494: GREATER
3495: AND
3496: IFFALSE 3788
// begin wait ( 1 1$20 ) ;
3498: LD_INT 2800
3500: PPUSH
3501: CALL_OW 67
// omarCargo := PrepareCargo ;
3505: LD_ADDR_EXP 38
3509: PUSH
3510: CALL 3793 0 0
3514: ST_TO_ADDR
// ComMoveXY ( omarCargo , 107 , 59 ) ;
3515: LD_EXP 38
3519: PPUSH
3520: LD_INT 107
3522: PPUSH
3523: LD_INT 59
3525: PPUSH
3526: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
3530: LD_INT 35
3532: PPUSH
3533: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
3537: LD_EXP 38
3541: PPUSH
3542: LD_INT 107
3544: PPUSH
3545: LD_INT 59
3547: PPUSH
3548: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
3552: LD_EXP 38
3556: PPUSH
3557: CALL_OW 302
3561: NOT
3562: PUSH
3563: LD_EXP 38
3567: PPUSH
3568: CALL_OW 301
3572: OR
3573: IFFALSE 3577
// continue ;
3575: GO 3530
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
3577: LD_EXP 38
3581: PPUSH
3582: LD_INT 107
3584: PPUSH
3585: LD_INT 59
3587: PPUSH
3588: CALL_OW 307
3592: PUSH
3593: LD_EXP 38
3597: PPUSH
3598: LD_INT 5
3600: PPUSH
3601: CALL_OW 296
3605: PUSH
3606: LD_INT 6
3608: LESS
3609: OR
3610: IFFALSE 3530
// wait ( 0 0$05 ) ;
3612: LD_INT 175
3614: PPUSH
3615: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
3619: LD_EXP 38
3623: PPUSH
3624: LD_INT 1
3626: PPUSH
3627: LD_INT 100
3629: PPUSH
3630: CALL_OW 290
// SetResourceType ( GetBase ( arDepot ) , mat_cans , GetResourceType ( GetBase ( arDepot ) , mat_cans ) - 100 ) ;
3634: LD_INT 5
3636: PPUSH
3637: CALL_OW 274
3641: PPUSH
3642: LD_INT 1
3644: PPUSH
3645: LD_INT 5
3647: PPUSH
3648: CALL_OW 274
3652: PPUSH
3653: LD_INT 1
3655: PPUSH
3656: CALL_OW 275
3660: PUSH
3661: LD_INT 100
3663: MINUS
3664: PPUSH
3665: CALL_OW 277
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
3669: LD_EXP 38
3673: PPUSH
3674: LD_INT 103
3676: PPUSH
3677: LD_INT 9
3679: PPUSH
3680: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
3684: LD_INT 35
3686: PPUSH
3687: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
3691: LD_EXP 38
3695: PPUSH
3696: LD_INT 103
3698: PPUSH
3699: LD_INT 9
3701: PPUSH
3702: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
3706: LD_EXP 38
3710: PPUSH
3711: CALL_OW 302
3715: NOT
3716: PUSH
3717: LD_EXP 38
3721: PPUSH
3722: CALL_OW 301
3726: OR
3727: IFFALSE 3731
// continue ;
3729: GO 3684
// until IsInArea ( omarCargo , northRoad ) and GetCargo ( omarCargo , mat_cans ) > 0 ;
3731: LD_EXP 38
3735: PPUSH
3736: LD_INT 3
3738: PPUSH
3739: CALL_OW 308
3743: PUSH
3744: LD_EXP 38
3748: PPUSH
3749: LD_INT 1
3751: PPUSH
3752: CALL_OW 289
3756: PUSH
3757: LD_INT 0
3759: GREATER
3760: AND
3761: IFFALSE 3684
// RemoveUnit ( omarCargo ) ;
3763: LD_EXP 38
3767: PPUSH
3768: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
3772: LD_ADDR_EXP 17
3776: PUSH
3777: LD_EXP 17
3781: PUSH
3782: LD_INT 1
3784: MINUS
3785: ST_TO_ADDR
// end ;
3786: GO 3467
// end ;
3788: LD_VAR 0 1
3792: RET
// export function PrepareCargo ; var un , veh ; begin
3793: LD_INT 0
3795: PPUSH
3796: PPUSH
3797: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
3798: LD_ADDR_VAR 0 3
3802: PUSH
3803: LD_INT 5
3805: PPUSH
3806: LD_INT 2
3808: PPUSH
3809: LD_INT 13
3811: PPUSH
3812: LD_INT 1
3814: PPUSH
3815: LD_INT 1
3817: PPUSH
3818: LD_INT 32
3820: PPUSH
3821: LD_INT 80
3823: PPUSH
3824: CALL 302 0 7
3828: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3829: LD_VAR 0 3
3833: PPUSH
3834: LD_INT 4
3836: PPUSH
3837: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
3841: LD_VAR 0 3
3845: PPUSH
3846: LD_INT 101
3848: PPUSH
3849: LD_INT 8
3851: PPUSH
3852: LD_INT 0
3854: PPUSH
3855: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
3859: LD_INT 0
3861: PPUSH
3862: LD_INT 3
3864: PPUSH
3865: LD_INT 2
3867: PPUSH
3868: CALL_OW 380
// un := CreateHuman ;
3872: LD_ADDR_VAR 0 2
3876: PUSH
3877: CALL_OW 44
3881: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
3882: LD_VAR 0 2
3886: PPUSH
3887: LD_VAR 0 3
3891: PPUSH
3892: CALL_OW 52
// result := veh ;
3896: LD_ADDR_VAR 0 1
3900: PUSH
3901: LD_VAR 0 3
3905: ST_TO_ADDR
// end ; end_of_file
3906: LD_VAR 0 1
3910: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
3911: LD_INT 0
3913: PPUSH
3914: PPUSH
3915: PPUSH
// usForces := [ ] ;
3916: LD_ADDR_EXP 39
3920: PUSH
3921: EMPTY
3922: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
3923: LD_ADDR_EXP 41
3927: PUSH
3928: LD_INT 6
3930: PUSH
3931: LD_INT 32
3933: PUSH
3934: LD_INT 27
3936: PUSH
3937: LD_INT 1
3939: PUSH
3940: EMPTY
3941: LIST
3942: LIST
3943: LIST
3944: LIST
3945: PUSH
3946: LD_INT 4
3948: PUSH
3949: LD_INT 43
3951: PUSH
3952: LD_INT 24
3954: PUSH
3955: LD_INT 5
3957: PUSH
3958: EMPTY
3959: LIST
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 27
3966: PUSH
3967: LD_INT 29
3969: PUSH
3970: LD_INT 21
3972: PUSH
3973: LD_INT 0
3975: PUSH
3976: EMPTY
3977: LIST
3978: LIST
3979: LIST
3980: LIST
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: LIST
3986: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
3987: LD_INT 11
3989: PPUSH
3990: CALL_OW 274
3994: PPUSH
3995: LD_INT 1
3997: PPUSH
3998: LD_INT 150
4000: PUSH
4001: LD_INT 120
4003: PUSH
4004: LD_INT 100
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 277
// uc_side := 1 ;
4022: LD_ADDR_OWVAR 20
4026: PUSH
4027: LD_INT 1
4029: ST_TO_ADDR
// uc_nation := 1 ;
4030: LD_ADDR_OWVAR 21
4034: PUSH
4035: LD_INT 1
4037: ST_TO_ADDR
// hc_gallery :=  ;
4038: LD_ADDR_OWVAR 33
4042: PUSH
4043: LD_STRING 
4045: ST_TO_ADDR
// hc_name :=  ;
4046: LD_ADDR_OWVAR 26
4050: PUSH
4051: LD_STRING 
4053: ST_TO_ADDR
// hc_importance := 0 ;
4054: LD_ADDR_OWVAR 32
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
4062: LD_INT 1
4064: PPUSH
4065: LD_INT 1
4067: PPUSH
4068: LD_INT 3
4070: PPUSH
4071: CALL_OW 380
// usCommander := CreateHuman ;
4075: LD_ADDR_EXP 40
4079: PUSH
4080: CALL_OW 44
4084: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
4085: LD_EXP 40
4089: PPUSH
4090: LD_INT 11
4092: PPUSH
4093: CALL_OW 52
// for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
4097: LD_ADDR_VAR 0 2
4101: PUSH
4102: DOUBLE
4103: LD_INT 1
4105: DEC
4106: ST_TO_ADDR
4107: LD_INT 2
4109: PUSH
4110: LD_INT 3
4112: PUSH
4113: LD_INT 4
4115: PUSH
4116: EMPTY
4117: LIST
4118: LIST
4119: LIST
4120: PUSH
4121: LD_OWVAR 67
4125: ARRAY
4126: PUSH
4127: FOR_TO
4128: IFFALSE 4263
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
4130: LD_INT 0
4132: PPUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_INT 1
4138: PUSH
4139: LD_INT 2
4141: PUSH
4142: LD_INT 3
4144: PUSH
4145: EMPTY
4146: LIST
4147: LIST
4148: LIST
4149: PUSH
4150: LD_OWVAR 67
4154: ARRAY
4155: PPUSH
4156: CALL_OW 380
// un := CreateHuman ;
4160: LD_ADDR_VAR 0 3
4164: PUSH
4165: CALL_OW 44
4169: ST_TO_ADDR
// usForces := usForces union un ;
4170: LD_ADDR_EXP 39
4174: PUSH
4175: LD_EXP 39
4179: PUSH
4180: LD_VAR 0 3
4184: UNION
4185: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
4186: LD_VAR 0 3
4190: PPUSH
4191: LD_INT 39
4193: PPUSH
4194: LD_INT 24
4196: PPUSH
4197: LD_INT 4
4199: PPUSH
4200: LD_INT 0
4202: PPUSH
4203: CALL_OW 50
// if i < 3 then
4207: LD_VAR 0 2
4211: PUSH
4212: LD_INT 3
4214: LESS
4215: IFFALSE 4261
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
4217: LD_VAR 0 3
4221: PPUSH
4222: LD_INT 22
4224: PUSH
4225: LD_INT 1
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 30
4234: PUSH
4235: LD_INT 31
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: PPUSH
4246: CALL_OW 69
4250: PUSH
4251: LD_VAR 0 2
4255: ARRAY
4256: PPUSH
4257: CALL_OW 120
// end ;
4261: GO 4127
4263: POP
4264: POP
// for i := 1 to 2 do
4265: LD_ADDR_VAR 0 2
4269: PUSH
4270: DOUBLE
4271: LD_INT 1
4273: DEC
4274: ST_TO_ADDR
4275: LD_INT 2
4277: PUSH
4278: FOR_TO
4279: IFFALSE 4343
// begin PrepareHuman ( false , 2 , 2 ) ;
4281: LD_INT 0
4283: PPUSH
4284: LD_INT 2
4286: PPUSH
4287: LD_INT 2
4289: PPUSH
4290: CALL_OW 380
// un := CreateHuman ;
4294: LD_ADDR_VAR 0 3
4298: PUSH
4299: CALL_OW 44
4303: ST_TO_ADDR
// usForces := usForces union un ;
4304: LD_ADDR_EXP 39
4308: PUSH
4309: LD_EXP 39
4313: PUSH
4314: LD_VAR 0 3
4318: UNION
4319: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
4320: LD_VAR 0 3
4324: PPUSH
4325: LD_INT 39
4327: PPUSH
4328: LD_INT 24
4330: PPUSH
4331: LD_INT 4
4333: PPUSH
4334: LD_INT 0
4336: PPUSH
4337: CALL_OW 50
// end ;
4341: GO 4278
4343: POP
4344: POP
// PrepareHuman ( false , 4 , 1 ) ;
4345: LD_INT 0
4347: PPUSH
4348: LD_INT 4
4350: PPUSH
4351: LD_INT 1
4353: PPUSH
4354: CALL_OW 380
// un := CreateHuman ;
4358: LD_ADDR_VAR 0 3
4362: PUSH
4363: CALL_OW 44
4367: ST_TO_ADDR
// usForces := usForces union un ;
4368: LD_ADDR_EXP 39
4372: PUSH
4373: LD_EXP 39
4377: PUSH
4378: LD_VAR 0 3
4382: UNION
4383: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
4384: LD_VAR 0 3
4388: PPUSH
4389: LD_INT 39
4391: PPUSH
4392: LD_INT 24
4394: PPUSH
4395: LD_INT 4
4397: PPUSH
4398: LD_INT 0
4400: PPUSH
4401: CALL_OW 50
// end ;
4405: LD_VAR 0 1
4409: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
4410: LD_EXP 39
4414: PUSH
4415: LD_EXP 6
4419: NOT
4420: AND
4421: IFFALSE 4744
4423: GO 4425
4425: DISABLE
4426: LD_INT 0
4428: PPUSH
4429: PPUSH
4430: PPUSH
4431: PPUSH
4432: PPUSH
// begin enable ;
4433: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
4434: LD_ADDR_VAR 0 3
4438: PUSH
4439: LD_EXP 39
4443: PPUSH
4444: LD_INT 25
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PPUSH
4454: CALL_OW 72
4458: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
4459: LD_ADDR_VAR 0 4
4463: PUSH
4464: LD_EXP 39
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 1
4474: PUSH
4475: EMPTY
4476: LIST
4477: LIST
4478: PPUSH
4479: CALL_OW 72
4483: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
4484: LD_ADDR_VAR 0 5
4488: PUSH
4489: LD_EXP 39
4493: PPUSH
4494: LD_INT 25
4496: PUSH
4497: LD_INT 4
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: PPUSH
4504: CALL_OW 72
4508: ST_TO_ADDR
// if eng then
4509: LD_VAR 0 3
4513: IFFALSE 4744
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4515: LD_ADDR_VAR 0 2
4519: PUSH
4520: LD_INT 22
4522: PUSH
4523: LD_INT 1
4525: PUSH
4526: EMPTY
4527: LIST
4528: LIST
4529: PUSH
4530: LD_INT 21
4532: PUSH
4533: LD_INT 3
4535: PUSH
4536: EMPTY
4537: LIST
4538: LIST
4539: PUSH
4540: LD_INT 3
4542: PUSH
4543: LD_INT 24
4545: PUSH
4546: LD_INT 1000
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: LIST
4561: PPUSH
4562: CALL_OW 69
4566: ST_TO_ADDR
// if b then
4567: LD_VAR 0 2
4571: IFFALSE 4602
// begin ComExitBuilding ( eng ) ;
4573: LD_VAR 0 3
4577: PPUSH
4578: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
4582: LD_VAR 0 3
4586: PPUSH
4587: LD_VAR 0 2
4591: PUSH
4592: LD_INT 1
4594: ARRAY
4595: PPUSH
4596: CALL_OW 190
// end else
4600: GO 4744
// begin for i in eng do
4602: LD_ADDR_VAR 0 1
4606: PUSH
4607: LD_VAR 0 3
4611: PUSH
4612: FOR_IN
4613: IFFALSE 4742
// if not HasTask ( i ) then
4615: LD_VAR 0 1
4619: PPUSH
4620: CALL_OW 314
4624: NOT
4625: IFFALSE 4740
// begin if americanBuildList then
4627: LD_EXP 41
4631: IFFALSE 4716
// begin if IsInUnit ( i ) then
4633: LD_VAR 0 1
4637: PPUSH
4638: CALL_OW 310
4642: IFFALSE 4653
// ComExitBuilding ( i ) ;
4644: LD_VAR 0 1
4648: PPUSH
4649: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
4653: LD_VAR 0 1
4657: PPUSH
4658: LD_EXP 41
4662: PUSH
4663: LD_INT 1
4665: ARRAY
4666: PUSH
4667: LD_INT 1
4669: ARRAY
4670: PPUSH
4671: LD_EXP 41
4675: PUSH
4676: LD_INT 1
4678: ARRAY
4679: PUSH
4680: LD_INT 2
4682: ARRAY
4683: PPUSH
4684: LD_EXP 41
4688: PUSH
4689: LD_INT 1
4691: ARRAY
4692: PUSH
4693: LD_INT 3
4695: ARRAY
4696: PPUSH
4697: LD_EXP 41
4701: PUSH
4702: LD_INT 1
4704: ARRAY
4705: PUSH
4706: LD_INT 4
4708: ARRAY
4709: PPUSH
4710: CALL_OW 205
// end else
4714: GO 4740
// if not IsInUnit ( i ) then
4716: LD_VAR 0 1
4720: PPUSH
4721: CALL_OW 310
4725: NOT
4726: IFFALSE 4740
// ComEnterUnit ( i , usDepot ) ;
4728: LD_VAR 0 1
4732: PPUSH
4733: LD_INT 11
4735: PPUSH
4736: CALL_OW 120
// end ;
4740: GO 4612
4742: POP
4743: POP
// end ; end ; end ;
4744: PPOPN 5
4746: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
4747: LD_INT 0
4749: PPUSH
4750: PPUSH
4751: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
4752: LD_ADDR_VAR 0 3
4756: PUSH
4757: LD_INT 35
4759: PUSH
4760: LD_INT 45
4762: PUSH
4763: LD_INT 48
4765: PUSH
4766: LD_EXP 50
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: LIST
4775: LIST
4776: ST_TO_ADDR
// for i in tech do
4777: LD_ADDR_VAR 0 4
4781: PUSH
4782: LD_VAR 0 3
4786: PUSH
4787: FOR_IN
4788: IFFALSE 4806
// AddComResearch ( lab , i ) ;
4790: LD_VAR 0 1
4794: PPUSH
4795: LD_VAR 0 4
4799: PPUSH
4800: CALL_OW 184
4804: GO 4787
4806: POP
4807: POP
// end ;
4808: LD_VAR 0 2
4812: RET
// every 8 8$00 + 2 2$00 trigger allowConvoys and convoyCounter < 15 do
4813: LD_EXP 11
4817: PUSH
4818: LD_EXP 19
4822: PUSH
4823: LD_INT 15
4825: LESS
4826: AND
4827: IFFALSE 4837
4829: GO 4831
4831: DISABLE
// begin enable ;
4832: ENABLE
// SendConvoy ;
4833: CALL 4912 0 0
// end ;
4837: END
// every 0 0$1 trigger americanBaseCaptured do
4838: LD_EXP 6
4842: IFFALSE 4911
4844: GO 4846
4846: DISABLE
// begin if americanHasEscaped then
4847: LD_EXP 7
4851: IFFALSE 4862
// wait ( 6 6$00 ) else
4853: LD_INT 12600
4855: PPUSH
4856: CALL_OW 67
4860: GO 4869
// wait ( 9 9$00 ) ;
4862: LD_INT 18900
4864: PPUSH
4865: CALL_OW 67
// SendAttack ;
4869: CALL 5498 0 0
// repeat wait ( [ 6 6$30 , 6 6$00 , 5 5$30 ] [ Difficulty ] ) ;
4873: LD_INT 13650
4875: PUSH
4876: LD_INT 12600
4878: PUSH
4879: LD_INT 11550
4881: PUSH
4882: EMPTY
4883: LIST
4884: LIST
4885: LIST
4886: PUSH
4887: LD_OWVAR 67
4891: ARRAY
4892: PPUSH
4893: CALL_OW 67
// SendAttack ;
4897: CALL 5498 0 0
// until attackWave < 10 ;
4901: LD_EXP 16
4905: PUSH
4906: LD_INT 10
4908: LESS
4909: IFFALSE 4873
// end ;
4911: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
4912: LD_INT 0
4914: PPUSH
4915: PPUSH
4916: PPUSH
4917: PPUSH
4918: PPUSH
4919: PPUSH
4920: PPUSH
4921: PPUSH
// road := rand ( 1 , 2 ) ;
4922: LD_ADDR_VAR 0 4
4926: PUSH
4927: LD_INT 1
4929: PPUSH
4930: LD_INT 2
4932: PPUSH
4933: CALL_OW 12
4937: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
4938: LD_ADDR_VAR 0 8
4942: PUSH
4943: LD_INT 3
4945: PUSH
4946: LD_INT 8
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PUSH
4953: LD_VAR 0 4
4957: ARRAY
4958: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
4959: LD_ADDR_VAR 0 5
4963: PUSH
4964: LD_INT 35
4966: PUSH
4967: LD_INT 66
4969: PUSH
4970: LD_INT 1
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: LIST
4977: PUSH
4978: LD_INT 101
4980: PUSH
4981: LD_INT 8
4983: PUSH
4984: LD_INT 4
4986: PUSH
4987: EMPTY
4988: LIST
4989: LIST
4990: LIST
4991: PUSH
4992: EMPTY
4993: LIST
4994: LIST
4995: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
4996: LD_ADDR_VAR 0 6
5000: PUSH
5001: LD_INT 34
5003: PUSH
5004: LD_INT 67
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PUSH
5011: LD_INT 38
5013: PUSH
5014: LD_INT 62
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: PUSH
5021: LD_INT 43
5023: PUSH
5024: LD_INT 54
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 57
5033: PUSH
5034: LD_INT 57
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 77
5043: PUSH
5044: LD_INT 71
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: LD_INT 86
5053: PUSH
5054: LD_INT 60
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: PUSH
5061: LD_INT 89
5063: PUSH
5064: LD_INT 35
5066: PUSH
5067: EMPTY
5068: LIST
5069: LIST
5070: PUSH
5071: LD_INT 93
5073: PUSH
5074: LD_INT 17
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PUSH
5081: LD_INT 97
5083: PUSH
5084: LD_INT 10
5086: PUSH
5087: EMPTY
5088: LIST
5089: LIST
5090: PUSH
5091: LD_INT 103
5093: PUSH
5094: LD_INT 9
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: LIST
5105: LIST
5106: LIST
5107: LIST
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: ST_TO_ADDR
// if road = 2 then
5113: LD_VAR 0 4
5117: PUSH
5118: LD_INT 2
5120: EQUAL
5121: IFFALSE 5138
// points := ReverseArray ( points ) ;
5123: LD_ADDR_VAR 0 6
5127: PUSH
5128: LD_VAR 0 6
5132: PPUSH
5133: CALL 990 0 1
5137: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
5138: LD_INT 4
5140: PPUSH
5141: LD_INT 1
5143: PPUSH
5144: LD_INT 2
5146: PPUSH
5147: LD_INT 1
5149: PPUSH
5150: LD_INT 1
5152: PPUSH
5153: LD_INT 12
5155: PPUSH
5156: LD_INT 80
5158: PPUSH
5159: CALL 302 0 7
// veh := CreateVehicle ;
5163: LD_ADDR_VAR 0 3
5167: PUSH
5168: CALL_OW 45
5172: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
5173: LD_VAR 0 3
5177: PPUSH
5178: LD_VAR 0 5
5182: PUSH
5183: LD_VAR 0 4
5187: ARRAY
5188: PUSH
5189: LD_INT 3
5191: ARRAY
5192: PPUSH
5193: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
5197: LD_VAR 0 3
5201: PPUSH
5202: LD_VAR 0 5
5206: PUSH
5207: LD_VAR 0 4
5211: ARRAY
5212: PUSH
5213: LD_INT 1
5215: ARRAY
5216: PPUSH
5217: LD_VAR 0 5
5221: PUSH
5222: LD_VAR 0 4
5226: ARRAY
5227: PUSH
5228: LD_INT 2
5230: ARRAY
5231: PPUSH
5232: LD_INT 0
5234: PPUSH
5235: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
5239: LD_INT 0
5241: PPUSH
5242: LD_INT 1
5244: PPUSH
5245: LD_OWVAR 67
5249: PPUSH
5250: CALL_OW 380
// un := CreateHuman ;
5254: LD_ADDR_VAR 0 2
5258: PUSH
5259: CALL_OW 44
5263: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5264: LD_VAR 0 2
5268: PPUSH
5269: LD_VAR 0 3
5273: PPUSH
5274: CALL_OW 52
// if Prob ( 50 + tick mod 30 ) then
5278: LD_INT 50
5280: PUSH
5281: LD_OWVAR 1
5285: PUSH
5286: LD_INT 30
5288: MOD
5289: PLUS
5290: PPUSH
5291: CALL_OW 13
5295: IFFALSE 5312
// SetCargo ( veh , mat_cans , 100 ) ;
5297: LD_VAR 0 3
5301: PPUSH
5302: LD_INT 1
5304: PPUSH
5305: LD_INT 100
5307: PPUSH
5308: CALL_OW 290
// for i := 2 to points do
5312: LD_ADDR_VAR 0 7
5316: PUSH
5317: DOUBLE
5318: LD_INT 2
5320: DEC
5321: ST_TO_ADDR
5322: LD_VAR 0 6
5326: PUSH
5327: FOR_TO
5328: IFFALSE 5371
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
5330: LD_VAR 0 3
5334: PPUSH
5335: LD_VAR 0 6
5339: PUSH
5340: LD_VAR 0 7
5344: ARRAY
5345: PUSH
5346: LD_INT 1
5348: ARRAY
5349: PPUSH
5350: LD_VAR 0 6
5354: PUSH
5355: LD_VAR 0 7
5359: ARRAY
5360: PUSH
5361: LD_INT 2
5363: ARRAY
5364: PPUSH
5365: CALL_OW 171
5369: GO 5327
5371: POP
5372: POP
// convoyCounter := convoyCounter + 1 ;
5373: LD_ADDR_EXP 19
5377: PUSH
5378: LD_EXP 19
5382: PUSH
5383: LD_INT 1
5385: PLUS
5386: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5387: LD_INT 35
5389: PPUSH
5390: CALL_OW 67
// if not HasTask ( veh ) then
5394: LD_VAR 0 3
5398: PPUSH
5399: CALL_OW 314
5403: NOT
5404: IFFALSE 5445
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
5406: LD_VAR 0 3
5410: PPUSH
5411: LD_VAR 0 6
5415: PUSH
5416: LD_VAR 0 6
5420: ARRAY
5421: PUSH
5422: LD_INT 1
5424: ARRAY
5425: PPUSH
5426: LD_VAR 0 6
5430: PUSH
5431: LD_VAR 0 6
5435: ARRAY
5436: PUSH
5437: LD_INT 2
5439: ARRAY
5440: PPUSH
5441: CALL_OW 111
// if not IsOk ( veh ) then
5445: LD_VAR 0 3
5449: PPUSH
5450: CALL_OW 302
5454: NOT
5455: IFFALSE 5459
// break ;
5457: GO 5475
// until IsInArea ( veh , finalArea ) ;
5459: LD_VAR 0 3
5463: PPUSH
5464: LD_VAR 0 8
5468: PPUSH
5469: CALL_OW 308
5473: IFFALSE 5387
// RemoveUnit ( un ) ;
5475: LD_VAR 0 2
5479: PPUSH
5480: CALL_OW 64
// RemoveUnit ( veh ) ;
5484: LD_VAR 0 3
5488: PPUSH
5489: CALL_OW 64
// end ;
5493: LD_VAR 0 1
5497: RET
// export function SendAttack ; var un , veh , i ; begin
5498: LD_INT 0
5500: PPUSH
5501: PPUSH
5502: PPUSH
5503: PPUSH
// IncomingAttack ;
5504: CALL 13015 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
5508: LD_INT 2100
5510: PPUSH
5511: LD_INT 3500
5513: PPUSH
5514: CALL_OW 12
5518: PPUSH
5519: CALL_OW 67
// for i := 1 to [ 3 , 3 , 4 ] [ Difficulty ] + attackWave div 3 do
5523: LD_ADDR_VAR 0 4
5527: PUSH
5528: DOUBLE
5529: LD_INT 1
5531: DEC
5532: ST_TO_ADDR
5533: LD_INT 3
5535: PUSH
5536: LD_INT 3
5538: PUSH
5539: LD_INT 4
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: LIST
5546: PUSH
5547: LD_OWVAR 67
5551: ARRAY
5552: PUSH
5553: LD_EXP 16
5557: PUSH
5558: LD_INT 3
5560: DIV
5561: PLUS
5562: PUSH
5563: FOR_TO
5564: IFFALSE 5676
// begin uc_side := 1 ;
5566: LD_ADDR_OWVAR 20
5570: PUSH
5571: LD_INT 1
5573: ST_TO_ADDR
// uc_nation := 1 ;
5574: LD_ADDR_OWVAR 21
5578: PUSH
5579: LD_INT 1
5581: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
5582: LD_INT 0
5584: PPUSH
5585: LD_INT 1
5587: PPUSH
5588: LD_INT 2
5590: PUSH
5591: LD_INT 3
5593: PUSH
5594: LD_INT 4
5596: PUSH
5597: EMPTY
5598: LIST
5599: LIST
5600: LIST
5601: PUSH
5602: LD_OWVAR 67
5606: ARRAY
5607: PPUSH
5608: CALL_OW 380
// un := CreateHuman ;
5612: LD_ADDR_VAR 0 2
5616: PUSH
5617: CALL_OW 44
5621: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
5622: LD_VAR 0 2
5626: PPUSH
5627: LD_INT 37
5629: PPUSH
5630: LD_INT 70
5632: PPUSH
5633: LD_INT 3
5635: PPUSH
5636: LD_INT 0
5638: PPUSH
5639: CALL_OW 50
// usForces := usForces union un ;
5643: LD_ADDR_EXP 39
5647: PUSH
5648: LD_EXP 39
5652: PUSH
5653: LD_VAR 0 2
5657: UNION
5658: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
5659: LD_VAR 0 2
5663: PPUSH
5664: LD_INT 40
5666: PPUSH
5667: LD_INT 65
5669: PPUSH
5670: CALL_OW 111
// end ;
5674: GO 5563
5676: POP
5677: POP
// if attackWave > 2 then
5678: LD_EXP 16
5682: PUSH
5683: LD_INT 2
5685: GREATER
5686: IFFALSE 5779
// begin uc_side := 1 ;
5688: LD_ADDR_OWVAR 20
5692: PUSH
5693: LD_INT 1
5695: ST_TO_ADDR
// uc_nation := 1 ;
5696: LD_ADDR_OWVAR 21
5700: PUSH
5701: LD_INT 1
5703: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
5704: LD_INT 0
5706: PPUSH
5707: LD_INT 4
5709: PPUSH
5710: LD_INT 2
5712: PPUSH
5713: CALL_OW 380
// un := CreateHuman ;
5717: LD_ADDR_VAR 0 2
5721: PUSH
5722: CALL_OW 44
5726: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
5727: LD_VAR 0 2
5731: PPUSH
5732: LD_INT 37
5734: PPUSH
5735: LD_INT 70
5737: PPUSH
5738: LD_INT 3
5740: PPUSH
5741: LD_INT 0
5743: PPUSH
5744: CALL_OW 50
// usForces := usForces union un ;
5748: LD_ADDR_EXP 39
5752: PUSH
5753: LD_EXP 39
5757: PUSH
5758: LD_VAR 0 2
5762: UNION
5763: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
5764: LD_VAR 0 2
5768: PPUSH
5769: LD_INT 40
5771: PPUSH
5772: LD_INT 65
5774: PPUSH
5775: CALL_OW 111
// end ; if attackWave > 1 or Difficulty > 1 then
5779: LD_EXP 16
5783: PUSH
5784: LD_INT 1
5786: GREATER
5787: PUSH
5788: LD_OWVAR 67
5792: PUSH
5793: LD_INT 1
5795: GREATER
5796: OR
5797: IFFALSE 5984
// begin for i := 1 to Difficulty + attackWave div 4 do
5799: LD_ADDR_VAR 0 4
5803: PUSH
5804: DOUBLE
5805: LD_INT 1
5807: DEC
5808: ST_TO_ADDR
5809: LD_OWVAR 67
5813: PUSH
5814: LD_EXP 16
5818: PUSH
5819: LD_INT 4
5821: DIV
5822: PLUS
5823: PUSH
5824: FOR_TO
5825: IFFALSE 5982
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5827: LD_ADDR_VAR 0 3
5831: PUSH
5832: LD_INT 1
5834: PPUSH
5835: LD_INT 1
5837: PPUSH
5838: LD_INT 2
5840: PPUSH
5841: LD_INT 2
5843: PPUSH
5844: LD_INT 1
5846: PPUSH
5847: LD_INT 4
5849: PUSH
5850: LD_INT 3
5852: PUSH
5853: LD_INT 2
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 1
5863: PPUSH
5864: LD_INT 3
5866: PPUSH
5867: CALL_OW 12
5871: ARRAY
5872: PPUSH
5873: LD_INT 90
5875: PPUSH
5876: CALL 302 0 7
5880: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
5881: LD_VAR 0 3
5885: PPUSH
5886: LD_INT 35
5888: PPUSH
5889: LD_INT 65
5891: PPUSH
5892: LD_INT 0
5894: PPUSH
5895: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
5899: LD_INT 0
5901: PPUSH
5902: LD_INT 3
5904: PPUSH
5905: LD_OWVAR 67
5909: PUSH
5910: LD_INT 1
5912: PLUS
5913: PPUSH
5914: CALL_OW 380
// un := CreateHuman ;
5918: LD_ADDR_VAR 0 2
5922: PUSH
5923: CALL_OW 44
5927: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
5928: LD_VAR 0 2
5932: PPUSH
5933: LD_VAR 0 3
5937: PPUSH
5938: CALL_OW 52
// ComMoveXY ( veh , 39 , 60 ) ;
5942: LD_VAR 0 3
5946: PPUSH
5947: LD_INT 39
5949: PPUSH
5950: LD_INT 60
5952: PPUSH
5953: CALL_OW 111
// wait ( 0 0$2 ) ;
5957: LD_INT 70
5959: PPUSH
5960: CALL_OW 67
// usForces := usForces union veh ;
5964: LD_ADDR_EXP 39
5968: PUSH
5969: LD_EXP 39
5973: PUSH
5974: LD_VAR 0 3
5978: UNION
5979: ST_TO_ADDR
// end ;
5980: GO 5824
5982: POP
5983: POP
// end ; attackWave := attackWave + 1 ;
5984: LD_ADDR_EXP 16
5988: PUSH
5989: LD_EXP 16
5993: PUSH
5994: LD_INT 1
5996: PLUS
5997: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
5998: LD_EXP 20
6002: PPUSH
6003: CALL_OW 427
// end ;
6007: LD_VAR 0 1
6011: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
6012: LD_INT 0
6014: PPUSH
6015: PPUSH
6016: PPUSH
6017: PPUSH
6018: PPUSH
6019: PPUSH
6020: PPUSH
6021: PPUSH
6022: PPUSH
6023: PPUSH
6024: PPUSH
// if retreatAllowed then
6025: LD_EXP 10
6029: IFFALSE 6041
// strategy := 2 else
6031: LD_ADDR_VAR 0 5
6035: PUSH
6036: LD_INT 2
6038: ST_TO_ADDR
6039: GO 6057
// strategy := rand ( 0 , 2 ) ;
6041: LD_ADDR_VAR 0 5
6045: PUSH
6046: LD_INT 0
6048: PPUSH
6049: LD_INT 2
6051: PPUSH
6052: CALL_OW 12
6056: ST_TO_ADDR
// attackFormula := [ ] ;
6057: LD_ADDR_VAR 0 6
6061: PUSH
6062: EMPTY
6063: ST_TO_ADDR
// case strategy of 0 :
6064: LD_VAR 0 5
6068: PUSH
6069: LD_INT 0
6071: DOUBLE
6072: EQUAL
6073: IFTRUE 6077
6075: GO 6374
6077: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
6078: LD_INT 11
6080: PPUSH
6081: LD_INT 22
6083: PUSH
6084: LD_INT 2
6086: PUSH
6087: EMPTY
6088: LIST
6089: LIST
6090: PUSH
6091: LD_INT 30
6093: PUSH
6094: LD_INT 4
6096: PUSH
6097: EMPTY
6098: LIST
6099: LIST
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PPUSH
6105: CALL_OW 70
6109: NOT
6110: IFFALSE 6171
// attackFormula := [ [ [ 41 , 34 ] ] , [ 33 , 46 ] , [ 41 , 34 ] , [ [ 39 , 53 ] ] ] else
6112: LD_ADDR_VAR 0 6
6116: PUSH
6117: LD_INT 41
6119: PUSH
6120: LD_INT 34
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: PUSH
6127: EMPTY
6128: LIST
6129: PUSH
6130: LD_INT 33
6132: PUSH
6133: LD_INT 46
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: PUSH
6140: LD_INT 41
6142: PUSH
6143: LD_INT 34
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: PUSH
6150: LD_INT 39
6152: PUSH
6153: LD_INT 53
6155: PUSH
6156: EMPTY
6157: LIST
6158: LIST
6159: PUSH
6160: EMPTY
6161: LIST
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: LIST
6167: LIST
6168: ST_TO_ADDR
6169: GO 6372
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
6171: LD_INT 12
6173: PPUSH
6174: LD_INT 22
6176: PUSH
6177: LD_INT 2
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 2
6186: PUSH
6187: LD_INT 30
6189: PUSH
6190: LD_INT 4
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 30
6199: PUSH
6200: LD_INT 31
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: PUSH
6207: LD_INT 30
6209: PUSH
6210: LD_INT 32
6212: PUSH
6213: EMPTY
6214: LIST
6215: LIST
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: LIST
6221: LIST
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PPUSH
6227: CALL_OW 70
6231: NOT
6232: IFFALSE 6304
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 33 , 46 ] , [ 41 , 34 ] , [ [ 39 , 53 ] ] ] else
6234: LD_ADDR_VAR 0 6
6238: PUSH
6239: LD_INT 27
6241: PUSH
6242: LD_INT 42
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: PUSH
6249: LD_INT 27
6251: PUSH
6252: LD_INT 32
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: PUSH
6259: EMPTY
6260: LIST
6261: LIST
6262: PUSH
6263: LD_INT 33
6265: PUSH
6266: LD_INT 46
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: PUSH
6273: LD_INT 41
6275: PUSH
6276: LD_INT 34
6278: PUSH
6279: EMPTY
6280: LIST
6281: LIST
6282: PUSH
6283: LD_INT 39
6285: PUSH
6286: LD_INT 53
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: PUSH
6293: EMPTY
6294: LIST
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: LIST
6300: LIST
6301: ST_TO_ADDR
6302: GO 6372
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 41 , 34 ] , [ [ 39 , 53 ] ] ] ;
6304: LD_ADDR_VAR 0 6
6308: PUSH
6309: LD_INT 71
6311: PUSH
6312: LD_INT 67
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: PUSH
6319: LD_INT 54
6321: PUSH
6322: LD_INT 35
6324: PUSH
6325: EMPTY
6326: LIST
6327: LIST
6328: PUSH
6329: EMPTY
6330: LIST
6331: LIST
6332: PUSH
6333: LD_INT 63
6335: PUSH
6336: LD_INT 40
6338: PUSH
6339: EMPTY
6340: LIST
6341: LIST
6342: PUSH
6343: LD_INT 41
6345: PUSH
6346: LD_INT 34
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: PUSH
6353: LD_INT 39
6355: PUSH
6356: LD_INT 53
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PUSH
6363: EMPTY
6364: LIST
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: LIST
6370: LIST
6371: ST_TO_ADDR
// end ; 1 :
6372: GO 6544
6374: LD_INT 1
6376: DOUBLE
6377: EQUAL
6378: IFTRUE 6382
6380: GO 6475
6382: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 63 , 40 ] , [ 41 , 34 ] , [ [ 39 , 53 ] ] ] ; 2 :
6383: LD_ADDR_VAR 0 6
6387: PUSH
6388: LD_INT 71
6390: PUSH
6391: LD_INT 67
6393: PUSH
6394: EMPTY
6395: LIST
6396: LIST
6397: PUSH
6398: LD_INT 82
6400: PUSH
6401: LD_INT 23
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: PUSH
6408: LD_INT 53
6410: PUSH
6411: LD_INT 7
6413: PUSH
6414: EMPTY
6415: LIST
6416: LIST
6417: PUSH
6418: LD_INT 43
6420: PUSH
6421: LD_INT 10
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: LIST
6432: LIST
6433: PUSH
6434: LD_INT 63
6436: PUSH
6437: LD_INT 40
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: PUSH
6444: LD_INT 41
6446: PUSH
6447: LD_INT 34
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 39
6456: PUSH
6457: LD_INT 53
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: EMPTY
6465: LIST
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: LIST
6471: LIST
6472: ST_TO_ADDR
6473: GO 6544
6475: LD_INT 2
6477: DOUBLE
6478: EQUAL
6479: IFTRUE 6483
6481: GO 6543
6483: POP
// attackFormula := [ [ [ 95 , 61 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 95 , 61 ] ] ] ; end ;
6484: LD_ADDR_VAR 0 6
6488: PUSH
6489: LD_INT 95
6491: PUSH
6492: LD_INT 61
6494: PUSH
6495: EMPTY
6496: LIST
6497: LIST
6498: PUSH
6499: EMPTY
6500: LIST
6501: PUSH
6502: LD_INT 82
6504: PUSH
6505: LD_INT 75
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 73
6514: PUSH
6515: LD_INT 67
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 95
6524: PUSH
6525: LD_INT 61
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: PUSH
6532: EMPTY
6533: LIST
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: LIST
6539: LIST
6540: ST_TO_ADDR
6541: GO 6544
6543: POP
// if not attackFormula then
6544: LD_VAR 0 6
6548: NOT
6549: IFFALSE 6553
// exit ;
6551: GO 7980
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
6553: LD_ADDR_VAR 0 7
6557: PUSH
6558: LD_EXP 42
6562: PPUSH
6563: LD_INT 25
6565: PUSH
6566: LD_INT 1
6568: PUSH
6569: EMPTY
6570: LIST
6571: LIST
6572: PPUSH
6573: CALL_OW 72
6577: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
6578: LD_ADDR_VAR 0 8
6582: PUSH
6583: LD_EXP 42
6587: PPUSH
6588: LD_INT 25
6590: PUSH
6591: LD_INT 4
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: PPUSH
6598: CALL_OW 72
6602: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
6603: LD_ADDR_VAR 0 9
6607: PUSH
6608: LD_EXP 42
6612: PPUSH
6613: LD_INT 25
6615: PUSH
6616: LD_INT 3
6618: PUSH
6619: EMPTY
6620: LIST
6621: LIST
6622: PPUSH
6623: CALL_OW 72
6627: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
6628: LD_ADDR_VAR 0 10
6632: PUSH
6633: LD_EXP 42
6637: PPUSH
6638: LD_INT 21
6640: PUSH
6641: LD_INT 2
6643: PUSH
6644: EMPTY
6645: LIST
6646: LIST
6647: PPUSH
6648: CALL_OW 72
6652: ST_TO_ADDR
// if sci then
6653: LD_VAR 0 8
6657: IFFALSE 6694
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
6659: LD_VAR 0 8
6663: PPUSH
6664: LD_VAR 0 6
6668: PUSH
6669: LD_INT 2
6671: ARRAY
6672: PUSH
6673: LD_INT 1
6675: ARRAY
6676: PPUSH
6677: LD_VAR 0 6
6681: PUSH
6682: LD_INT 2
6684: ARRAY
6685: PUSH
6686: LD_INT 2
6688: ARRAY
6689: PPUSH
6690: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6694: LD_INT 35
6696: PPUSH
6697: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
6701: LD_ADDR_VAR 0 7
6705: PUSH
6706: LD_EXP 42
6710: PPUSH
6711: LD_INT 25
6713: PUSH
6714: LD_INT 1
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: PPUSH
6721: CALL_OW 72
6725: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
6726: LD_ADDR_VAR 0 8
6730: PUSH
6731: LD_EXP 42
6735: PPUSH
6736: LD_INT 25
6738: PUSH
6739: LD_INT 4
6741: PUSH
6742: EMPTY
6743: LIST
6744: LIST
6745: PPUSH
6746: CALL_OW 72
6750: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
6751: LD_ADDR_VAR 0 9
6755: PUSH
6756: LD_EXP 42
6760: PPUSH
6761: LD_INT 25
6763: PUSH
6764: LD_INT 3
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: PPUSH
6771: CALL_OW 72
6775: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
6776: LD_ADDR_VAR 0 10
6780: PUSH
6781: LD_EXP 42
6785: PPUSH
6786: LD_INT 21
6788: PUSH
6789: LD_INT 2
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: PPUSH
6796: CALL_OW 72
6800: ST_TO_ADDR
// if sol then
6801: LD_VAR 0 7
6805: IFFALSE 7191
// begin for i in sol do
6807: LD_ADDR_VAR 0 2
6811: PUSH
6812: LD_VAR 0 7
6816: PUSH
6817: FOR_IN
6818: IFFALSE 7189
// begin tag := GetTag ( i ) ;
6820: LD_ADDR_VAR 0 4
6824: PUSH
6825: LD_VAR 0 2
6829: PPUSH
6830: CALL_OW 110
6834: ST_TO_ADDR
// if not tag then
6835: LD_VAR 0 4
6839: NOT
6840: IFFALSE 6949
// begin if GetLives ( i ) = 1000 then
6842: LD_VAR 0 2
6846: PPUSH
6847: CALL_OW 256
6851: PUSH
6852: LD_INT 1000
6854: EQUAL
6855: IFFALSE 6871
// SetTag ( i , 1 ) else
6857: LD_VAR 0 2
6861: PPUSH
6862: LD_INT 1
6864: PPUSH
6865: CALL_OW 109
6869: GO 6947
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_VAR 0 6
6880: PUSH
6881: LD_INT 2
6883: ARRAY
6884: PUSH
6885: LD_INT 1
6887: ARRAY
6888: PPUSH
6889: LD_VAR 0 6
6893: PUSH
6894: LD_INT 2
6896: ARRAY
6897: PUSH
6898: LD_INT 2
6900: ARRAY
6901: PPUSH
6902: CALL_OW 297
6906: PUSH
6907: LD_INT 6
6909: GREATER
6910: IFFALSE 6947
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
6912: LD_VAR 0 2
6916: PPUSH
6917: LD_VAR 0 6
6921: PUSH
6922: LD_INT 2
6924: ARRAY
6925: PUSH
6926: LD_INT 1
6928: ARRAY
6929: PPUSH
6930: LD_VAR 0 6
6934: PUSH
6935: LD_INT 2
6937: ARRAY
6938: PUSH
6939: LD_INT 2
6941: ARRAY
6942: PPUSH
6943: CALL_OW 111
// end else
6947: GO 7187
// begin if GetLives ( i ) < 720 then
6949: LD_VAR 0 2
6953: PPUSH
6954: CALL_OW 256
6958: PUSH
6959: LD_INT 720
6961: LESS
6962: IFFALSE 6978
// SetTag ( i , 0 ) else
6964: LD_VAR 0 2
6968: PPUSH
6969: LD_INT 0
6971: PPUSH
6972: CALL_OW 109
6976: GO 7187
// if tag < attackFormula [ 1 ] then
6978: LD_VAR 0 4
6982: PUSH
6983: LD_VAR 0 6
6987: PUSH
6988: LD_INT 1
6990: ARRAY
6991: LESS
6992: IFFALSE 7153
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
6994: LD_VAR 0 2
6998: PPUSH
6999: LD_VAR 0 6
7003: PUSH
7004: LD_INT 1
7006: ARRAY
7007: PUSH
7008: LD_VAR 0 4
7012: ARRAY
7013: PUSH
7014: LD_INT 1
7016: ARRAY
7017: PPUSH
7018: LD_VAR 0 6
7022: PUSH
7023: LD_INT 1
7025: ARRAY
7026: PUSH
7027: LD_VAR 0 4
7031: ARRAY
7032: PUSH
7033: LD_INT 2
7035: ARRAY
7036: PPUSH
7037: CALL_OW 297
7041: PUSH
7042: LD_INT 6
7044: GREATER
7045: IFFALSE 7096
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
7047: LD_VAR 0 2
7051: PPUSH
7052: LD_VAR 0 6
7056: PUSH
7057: LD_INT 1
7059: ARRAY
7060: PUSH
7061: LD_VAR 0 4
7065: ARRAY
7066: PUSH
7067: LD_INT 1
7069: ARRAY
7070: PPUSH
7071: LD_VAR 0 6
7075: PUSH
7076: LD_INT 1
7078: ARRAY
7079: PUSH
7080: LD_VAR 0 4
7084: ARRAY
7085: PUSH
7086: LD_INT 2
7088: ARRAY
7089: PPUSH
7090: CALL_OW 114
7094: GO 7151
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
7096: LD_INT 81
7098: PUSH
7099: LD_INT 1
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: PUSH
7106: LD_INT 91
7108: PUSH
7109: LD_VAR 0 2
7113: PUSH
7114: LD_INT 10
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: LIST
7121: PUSH
7122: EMPTY
7123: LIST
7124: LIST
7125: PPUSH
7126: CALL_OW 69
7130: NOT
7131: IFFALSE 7151
// SetTag ( i , tag + 1 ) ;
7133: LD_VAR 0 2
7137: PPUSH
7138: LD_VAR 0 4
7142: PUSH
7143: LD_INT 1
7145: PLUS
7146: PPUSH
7147: CALL_OW 109
// end else
7151: GO 7187
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
7153: LD_VAR 0 2
7157: PPUSH
7158: LD_INT 81
7160: PUSH
7161: LD_INT 1
7163: PUSH
7164: EMPTY
7165: LIST
7166: LIST
7167: PPUSH
7168: CALL_OW 69
7172: PPUSH
7173: LD_VAR 0 2
7177: PPUSH
7178: CALL_OW 74
7182: PPUSH
7183: CALL_OW 115
// end ; end ;
7187: GO 6817
7189: POP
7190: POP
// end ; if sci then
7191: LD_VAR 0 8
7195: IFFALSE 7370
// begin if not sol and not mech then
7197: LD_VAR 0 7
7201: NOT
7202: PUSH
7203: LD_VAR 0 9
7207: NOT
7208: AND
7209: IFFALSE 7277
// begin for i in sci do
7211: LD_ADDR_VAR 0 2
7215: PUSH
7216: LD_VAR 0 8
7220: PUSH
7221: FOR_IN
7222: IFFALSE 7273
// begin usAttackers := usAttackers diff i ;
7224: LD_ADDR_EXP 42
7228: PUSH
7229: LD_EXP 42
7233: PUSH
7234: LD_VAR 0 2
7238: DIFF
7239: ST_TO_ADDR
// usForces := usForces union i ;
7240: LD_ADDR_EXP 39
7244: PUSH
7245: LD_EXP 39
7249: PUSH
7250: LD_VAR 0 2
7254: UNION
7255: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
7256: LD_VAR 0 2
7260: PPUSH
7261: LD_INT 34
7263: PPUSH
7264: LD_INT 68
7266: PPUSH
7267: CALL_OW 111
// end ;
7271: GO 7221
7273: POP
7274: POP
// end else
7275: GO 7370
// for i in sci do
7277: LD_ADDR_VAR 0 2
7281: PUSH
7282: LD_VAR 0 8
7286: PUSH
7287: FOR_IN
7288: IFFALSE 7368
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
7290: LD_VAR 0 2
7294: PPUSH
7295: LD_VAR 0 6
7299: PUSH
7300: LD_INT 2
7302: ARRAY
7303: PUSH
7304: LD_INT 1
7306: ARRAY
7307: PPUSH
7308: LD_VAR 0 6
7312: PUSH
7313: LD_INT 2
7315: ARRAY
7316: PUSH
7317: LD_INT 2
7319: ARRAY
7320: PPUSH
7321: CALL_OW 297
7325: PUSH
7326: LD_INT 8
7328: GREATER
7329: IFFALSE 7366
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
7331: LD_VAR 0 2
7335: PPUSH
7336: LD_VAR 0 6
7340: PUSH
7341: LD_INT 2
7343: ARRAY
7344: PUSH
7345: LD_INT 1
7347: ARRAY
7348: PPUSH
7349: LD_VAR 0 6
7353: PUSH
7354: LD_INT 2
7356: ARRAY
7357: PUSH
7358: LD_INT 2
7360: ARRAY
7361: PPUSH
7362: CALL_OW 111
7366: GO 7287
7368: POP
7369: POP
// end ; if tanks and mech then
7370: LD_VAR 0 10
7374: PUSH
7375: LD_VAR 0 9
7379: AND
7380: IFFALSE 7973
// begin for i in mech do
7382: LD_ADDR_VAR 0 2
7386: PUSH
7387: LD_VAR 0 9
7391: PUSH
7392: FOR_IN
7393: IFFALSE 7971
// begin tag := GetTag ( i ) ;
7395: LD_ADDR_VAR 0 4
7399: PUSH
7400: LD_VAR 0 2
7404: PPUSH
7405: CALL_OW 110
7409: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
7410: LD_ADDR_VAR 0 11
7414: PUSH
7415: LD_VAR 0 2
7419: PPUSH
7420: CALL_OW 310
7424: ST_TO_ADDR
// if not tag then
7425: LD_VAR 0 4
7429: NOT
7430: IFFALSE 7731
// begin if veh then
7432: LD_VAR 0 11
7436: IFFALSE 7585
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
7438: LD_VAR 0 11
7442: PPUSH
7443: CALL_OW 256
7447: PUSH
7448: LD_INT 1000
7450: EQUAL
7451: PUSH
7452: LD_VAR 0 11
7456: PPUSH
7457: CALL_OW 261
7461: PUSH
7462: LD_INT 60
7464: GREATER
7465: AND
7466: IFFALSE 7482
// SetTag ( i , 1 ) else
7468: LD_VAR 0 2
7472: PPUSH
7473: LD_INT 1
7475: PPUSH
7476: CALL_OW 109
7480: GO 7583
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
7482: LD_VAR 0 2
7486: PPUSH
7487: LD_VAR 0 6
7491: PUSH
7492: LD_INT 3
7494: ARRAY
7495: PUSH
7496: LD_INT 1
7498: ARRAY
7499: PPUSH
7500: LD_VAR 0 6
7504: PUSH
7505: LD_INT 3
7507: ARRAY
7508: PUSH
7509: LD_INT 2
7511: ARRAY
7512: PPUSH
7513: CALL_OW 297
7517: PUSH
7518: LD_INT 7
7520: GREATER
7521: IFFALSE 7560
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
7523: LD_VAR 0 2
7527: PPUSH
7528: LD_VAR 0 6
7532: PUSH
7533: LD_INT 3
7535: ARRAY
7536: PUSH
7537: LD_INT 1
7539: ARRAY
7540: PPUSH
7541: LD_VAR 0 6
7545: PUSH
7546: LD_INT 3
7548: ARRAY
7549: PUSH
7550: LD_INT 2
7552: ARRAY
7553: PPUSH
7554: CALL_OW 111
7558: GO 7583
// begin ComExitVehicle ( i ) ;
7560: LD_VAR 0 2
7564: PPUSH
7565: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
7569: LD_VAR 0 2
7573: PPUSH
7574: LD_VAR 0 11
7578: PPUSH
7579: CALL_OW 189
// end ; end else
7583: GO 7729
// if GetLives ( i ) < 700 then
7585: LD_VAR 0 2
7589: PPUSH
7590: CALL_OW 256
7594: PUSH
7595: LD_INT 700
7597: LESS
7598: IFFALSE 7649
// begin usAttackers := usAttackers diff i ;
7600: LD_ADDR_EXP 42
7604: PUSH
7605: LD_EXP 42
7609: PUSH
7610: LD_VAR 0 2
7614: DIFF
7615: ST_TO_ADDR
// usForces := usForces union i ;
7616: LD_ADDR_EXP 39
7620: PUSH
7621: LD_EXP 39
7625: PUSH
7626: LD_VAR 0 2
7630: UNION
7631: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
7632: LD_VAR 0 2
7636: PPUSH
7637: LD_INT 34
7639: PPUSH
7640: LD_INT 68
7642: PPUSH
7643: CALL_OW 111
// end else
7647: GO 7729
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) then
7649: LD_VAR 0 10
7653: PPUSH
7654: LD_INT 58
7656: PUSH
7657: EMPTY
7658: LIST
7659: PUSH
7660: LD_INT 24
7662: PUSH
7663: LD_INT 1000
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: PPUSH
7674: CALL_OW 72
7678: IFFALSE 7729
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
7680: LD_VAR 0 2
7684: PPUSH
7685: LD_VAR 0 10
7689: PPUSH
7690: LD_INT 58
7692: PUSH
7693: EMPTY
7694: LIST
7695: PUSH
7696: LD_INT 24
7698: PUSH
7699: LD_INT 1000
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: PPUSH
7710: CALL_OW 72
7714: PPUSH
7715: LD_VAR 0 2
7719: PPUSH
7720: CALL_OW 74
7724: PPUSH
7725: CALL_OW 120
// end else
7729: GO 7969
// begin if GetLives ( veh ) < 620 then
7731: LD_VAR 0 11
7735: PPUSH
7736: CALL_OW 256
7740: PUSH
7741: LD_INT 620
7743: LESS
7744: IFFALSE 7760
// SetTag ( i , 0 ) else
7746: LD_VAR 0 2
7750: PPUSH
7751: LD_INT 0
7753: PPUSH
7754: CALL_OW 109
7758: GO 7969
// if tag < attackFormula [ 1 ] then
7760: LD_VAR 0 4
7764: PUSH
7765: LD_VAR 0 6
7769: PUSH
7770: LD_INT 1
7772: ARRAY
7773: LESS
7774: IFFALSE 7935
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_VAR 0 6
7785: PUSH
7786: LD_INT 1
7788: ARRAY
7789: PUSH
7790: LD_VAR 0 4
7794: ARRAY
7795: PUSH
7796: LD_INT 1
7798: ARRAY
7799: PPUSH
7800: LD_VAR 0 6
7804: PUSH
7805: LD_INT 1
7807: ARRAY
7808: PUSH
7809: LD_VAR 0 4
7813: ARRAY
7814: PUSH
7815: LD_INT 2
7817: ARRAY
7818: PPUSH
7819: CALL_OW 297
7823: PUSH
7824: LD_INT 6
7826: GREATER
7827: IFFALSE 7878
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
7829: LD_VAR 0 2
7833: PPUSH
7834: LD_VAR 0 6
7838: PUSH
7839: LD_INT 1
7841: ARRAY
7842: PUSH
7843: LD_VAR 0 4
7847: ARRAY
7848: PUSH
7849: LD_INT 1
7851: ARRAY
7852: PPUSH
7853: LD_VAR 0 6
7857: PUSH
7858: LD_INT 1
7860: ARRAY
7861: PUSH
7862: LD_VAR 0 4
7866: ARRAY
7867: PUSH
7868: LD_INT 2
7870: ARRAY
7871: PPUSH
7872: CALL_OW 114
7876: GO 7933
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
7878: LD_INT 81
7880: PUSH
7881: LD_INT 1
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: PUSH
7888: LD_INT 91
7890: PUSH
7891: LD_VAR 0 2
7895: PUSH
7896: LD_INT 10
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: LIST
7903: PUSH
7904: EMPTY
7905: LIST
7906: LIST
7907: PPUSH
7908: CALL_OW 69
7912: NOT
7913: IFFALSE 7933
// SetTag ( i , tag + 1 ) ;
7915: LD_VAR 0 2
7919: PPUSH
7920: LD_VAR 0 4
7924: PUSH
7925: LD_INT 1
7927: PLUS
7928: PPUSH
7929: CALL_OW 109
// end else
7933: GO 7969
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
7935: LD_VAR 0 2
7939: PPUSH
7940: LD_INT 81
7942: PUSH
7943: LD_INT 1
7945: PUSH
7946: EMPTY
7947: LIST
7948: LIST
7949: PPUSH
7950: CALL_OW 69
7954: PPUSH
7955: LD_VAR 0 2
7959: PPUSH
7960: CALL_OW 74
7964: PPUSH
7965: CALL_OW 115
// end ; end ;
7969: GO 7392
7971: POP
7972: POP
// end ; until not usAttackers ;
7973: LD_EXP 42
7977: NOT
7978: IFFALSE 6694
// end ; end_of_file
7980: LD_VAR 0 1
7984: RET
// export function Action ; var hasAll , i , tmp ; begin
7985: LD_INT 0
7987: PPUSH
7988: PPUSH
7989: PPUSH
7990: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
7991: LD_ADDR_VAR 0 2
7995: PUSH
7996: LD_INT 22
7998: PUSH
7999: LD_INT 2
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PUSH
8006: LD_INT 21
8008: PUSH
8009: LD_INT 1
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 23
8018: PUSH
8019: LD_INT 2
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: LIST
8030: PPUSH
8031: CALL_OW 69
8035: PUSH
8036: LD_INT 7
8038: GREATEREQUAL
8039: ST_TO_ADDR
// InGameOn ;
8040: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
8044: LD_EXP 23
8048: PPUSH
8049: CALL_OW 87
// wait ( 0 0$2 ) ;
8053: LD_INT 70
8055: PPUSH
8056: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
8060: LD_EXP 31
8064: PPUSH
8065: LD_STRING DF-1-start
8067: PPUSH
8068: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
8072: LD_EXP 23
8076: PPUSH
8077: LD_EXP 31
8081: PPUSH
8082: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
8086: LD_EXP 23
8090: PPUSH
8091: LD_STRING DH-1-start
8093: PPUSH
8094: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
8098: LD_EXP 32
8102: PPUSH
8103: LD_INT 92
8105: PPUSH
8106: LD_INT 21
8108: PPUSH
8109: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
8113: LD_EXP 27
8117: PPUSH
8118: LD_INT 94
8120: PPUSH
8121: LD_INT 23
8123: PPUSH
8124: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
8128: LD_EXP 35
8132: PUSH
8133: LD_INT 1
8135: ARRAY
8136: PPUSH
8137: LD_INT 90
8139: PPUSH
8140: LD_INT 23
8142: PPUSH
8143: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
8147: LD_EXP 35
8151: PUSH
8152: LD_INT 2
8154: ARRAY
8155: PPUSH
8156: LD_INT 93
8158: PPUSH
8159: LD_INT 25
8161: PPUSH
8162: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
8166: LD_EXP 35
8170: PPUSH
8171: LD_EXP 32
8175: PPUSH
8176: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
8180: LD_EXP 32
8184: PUSH
8185: LD_EXP 27
8189: PUSH
8190: EMPTY
8191: LIST
8192: LIST
8193: PPUSH
8194: LD_EXP 23
8198: PPUSH
8199: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
8203: LD_EXP 23
8207: PPUSH
8208: LD_EXP 32
8212: PPUSH
8213: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
8217: LD_INT 35
8219: PPUSH
8220: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
8224: LD_EXP 32
8228: PPUSH
8229: LD_INT 92
8231: PPUSH
8232: LD_INT 21
8234: PPUSH
8235: CALL_OW 307
8239: IFFALSE 8217
// Say ( Omar , DO-1-start ) ;
8241: LD_EXP 32
8245: PPUSH
8246: LD_STRING DO-1-start
8248: PPUSH
8249: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
8253: LD_EXP 23
8257: PPUSH
8258: LD_STRING DH-2-start
8260: PPUSH
8261: CALL_OW 88
// if hasAll then
8265: LD_VAR 0 2
8269: IFFALSE 8397
// begin Say ( Omar , DO-2-start ) ;
8271: LD_EXP 32
8275: PPUSH
8276: LD_STRING DO-2-start
8278: PPUSH
8279: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
8283: LD_EXP 32
8287: PPUSH
8288: LD_STRING DO-3-start
8290: PPUSH
8291: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
8295: LD_EXP 23
8299: PPUSH
8300: LD_STRING DH-3-start
8302: PPUSH
8303: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
8307: LD_EXP 31
8311: PPUSH
8312: LD_STRING DF-2-start
8314: PPUSH
8315: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
8319: LD_EXP 32
8323: PPUSH
8324: LD_EXP 31
8328: PPUSH
8329: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
8333: LD_EXP 32
8337: PPUSH
8338: LD_STRING DO-4-start
8340: PPUSH
8341: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
8345: LD_EXP 31
8349: PPUSH
8350: LD_STRING DF-3-start
8352: PPUSH
8353: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
8357: LD_EXP 32
8361: PPUSH
8362: LD_STRING DO-5-start
8364: PPUSH
8365: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
8369: LD_EXP 31
8373: PPUSH
8374: LD_STRING DF-4-start
8376: PPUSH
8377: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
8381: LD_EXP 32
8385: PPUSH
8386: LD_EXP 23
8390: PPUSH
8391: CALL_OW 119
// end else
8395: GO 8497
// begin Say ( Omar , DO-2-start-a ) ;
8397: LD_EXP 32
8401: PPUSH
8402: LD_STRING DO-2-start-a
8404: PPUSH
8405: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
8409: LD_EXP 32
8413: PPUSH
8414: LD_STRING DO-3-start-a
8416: PPUSH
8417: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
8421: LD_EXP 23
8425: PPUSH
8426: LD_STRING DH-3-start-a
8428: PPUSH
8429: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
8433: LD_EXP 31
8437: PPUSH
8438: LD_STRING DF-2-start-a
8440: PPUSH
8441: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
8445: LD_EXP 32
8449: PPUSH
8450: LD_EXP 31
8454: PPUSH
8455: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
8459: LD_EXP 32
8463: PPUSH
8464: LD_STRING DO-4-start-a
8466: PPUSH
8467: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
8471: LD_EXP 31
8475: PPUSH
8476: LD_STRING DF-3-start-a
8478: PPUSH
8479: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
8483: LD_EXP 32
8487: PPUSH
8488: LD_EXP 23
8492: PPUSH
8493: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
8497: LD_INT 10
8499: PPUSH
8500: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
8504: LD_EXP 32
8508: PPUSH
8509: LD_STRING DO-1-mission
8511: PPUSH
8512: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
8516: LD_EXP 32
8520: PPUSH
8521: LD_STRING DO-2-mission
8523: PPUSH
8524: CALL_OW 88
// if not hasAll then
8528: LD_VAR 0 2
8532: NOT
8533: IFFALSE 8547
// Say ( Omar , DO-3-mission ) ;
8535: LD_EXP 32
8539: PPUSH
8540: LD_STRING DO-3-mission
8542: PPUSH
8543: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
8547: LD_EXP 32
8551: PPUSH
8552: LD_STRING DO-4-mission
8554: PPUSH
8555: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
8559: LD_EXP 23
8563: PPUSH
8564: LD_STRING DH-1-mission
8566: PPUSH
8567: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
8571: LD_EXP 31
8575: PPUSH
8576: LD_STRING DF-1-mission
8578: PPUSH
8579: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
8583: LD_EXP 32
8587: PPUSH
8588: LD_STRING DO-5-mission
8590: PPUSH
8591: CALL_OW 88
// if not hasAll then
8595: LD_VAR 0 2
8599: NOT
8600: IFFALSE 8735
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
8602: LD_ADDR_VAR 0 4
8606: PUSH
8607: LD_INT 22
8609: PUSH
8610: LD_INT 2
8612: PUSH
8613: EMPTY
8614: LIST
8615: LIST
8616: PUSH
8617: LD_INT 21
8619: PUSH
8620: LD_INT 1
8622: PUSH
8623: EMPTY
8624: LIST
8625: LIST
8626: PUSH
8627: LD_INT 23
8629: PUSH
8630: LD_INT 2
8632: PUSH
8633: EMPTY
8634: LIST
8635: LIST
8636: PUSH
8637: EMPTY
8638: LIST
8639: LIST
8640: LIST
8641: PPUSH
8642: CALL_OW 69
8646: ST_TO_ADDR
// for i := 7 downto tmp do
8647: LD_ADDR_VAR 0 3
8651: PUSH
8652: DOUBLE
8653: LD_INT 7
8655: INC
8656: ST_TO_ADDR
8657: LD_VAR 0 4
8661: PUSH
8662: FOR_DOWNTO
8663: IFFALSE 8733
// begin if omarSquad < 3 then
8665: LD_EXP 35
8669: PUSH
8670: LD_INT 3
8672: LESS
8673: IFFALSE 8677
// break ;
8675: GO 8733
// SetSide ( omarSquad [ 3 ] , 2 ) ;
8677: LD_EXP 35
8681: PUSH
8682: LD_INT 3
8684: ARRAY
8685: PPUSH
8686: LD_INT 2
8688: PPUSH
8689: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
8693: LD_ADDR_EXP 37
8697: PUSH
8698: LD_EXP 37
8702: PUSH
8703: LD_EXP 35
8707: PUSH
8708: LD_INT 3
8710: ARRAY
8711: UNION
8712: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
8713: LD_ADDR_EXP 35
8717: PUSH
8718: LD_EXP 35
8722: PPUSH
8723: LD_INT 3
8725: PPUSH
8726: CALL_OW 3
8730: ST_TO_ADDR
// end ;
8731: GO 8662
8733: POP
8734: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
8735: LD_EXP 32
8739: PUSH
8740: LD_EXP 35
8744: ADD
8745: PPUSH
8746: LD_INT 103
8748: PPUSH
8749: LD_INT 9
8751: PPUSH
8752: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
8756: LD_VAR 0 2
8760: PUSH
8761: LD_EXP 28
8765: PPUSH
8766: CALL_OW 302
8770: AND
8771: IFFALSE 8832
// begin wait ( 0 0$3 ) ;
8773: LD_INT 105
8775: PPUSH
8776: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
8780: LD_EXP 28
8784: PPUSH
8785: LD_EXP 31
8789: PPUSH
8790: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
8794: LD_EXP 28
8798: PPUSH
8799: LD_STRING DK-1-side
8801: PPUSH
8802: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
8806: LD_EXP 31
8810: PPUSH
8811: LD_EXP 28
8815: PPUSH
8816: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
8820: LD_EXP 31
8824: PPUSH
8825: LD_STRING DF-1-side
8827: PPUSH
8828: CALL_OW 88
// end ; InGameOff ;
8832: CALL_OW 9
// ChangeMissionObjectives ( BuildBase ) ;
8836: LD_STRING BuildBase
8838: PPUSH
8839: CALL_OW 337
// ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
8843: LD_INT 22
8845: PUSH
8846: LD_INT 2
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: PPUSH
8853: CALL_OW 69
8857: PPUSH
8858: CALL_OW 139
// SaveForQuickRestart ;
8862: CALL_OW 22
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
8866: LD_EXP 31
8870: PUSH
8871: LD_EXP 34
8875: ADD
8876: PPUSH
8877: LD_INT 108
8879: PPUSH
8880: LD_INT 62
8882: PPUSH
8883: CALL_OW 111
// gameStarted := true ;
8887: LD_ADDR_EXP 3
8891: PUSH
8892: LD_INT 1
8894: ST_TO_ADDR
// end ;
8895: LD_VAR 0 1
8899: RET
// every 0 0$3 trigger gameStarted do
8900: LD_EXP 3
8904: IFFALSE 9218
8906: GO 8908
8908: DISABLE
// begin Video ( true ) ;
8909: LD_INT 1
8911: PPUSH
8912: CALL 962 0 1
// CenterOnUnits ( Heike ) ;
8916: LD_EXP 23
8920: PPUSH
8921: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
8925: LD_EXP 23
8929: PPUSH
8930: LD_EXP 27
8934: PPUSH
8935: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
8939: LD_INT 22
8941: PUSH
8942: LD_INT 2
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: PPUSH
8949: CALL_OW 69
8953: PUSH
8954: LD_EXP 23
8958: DIFF
8959: PPUSH
8960: LD_EXP 23
8964: PPUSH
8965: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
8969: LD_EXP 23
8973: PPUSH
8974: LD_STRING DH-1-explore
8976: PPUSH
8977: CALL_OW 88
// if Givi then
8981: LD_EXP 24
8985: IFFALSE 9001
// Say ( Givi , DG-1-explore ) else
8987: LD_EXP 24
8991: PPUSH
8992: LD_STRING DG-1-explore
8994: PPUSH
8995: CALL_OW 88
8999: GO 9038
// if heikeSecondSquad then
9001: LD_EXP 37
9005: IFFALSE 9038
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
9007: LD_EXP 37
9011: PPUSH
9012: LD_INT 26
9014: PUSH
9015: LD_INT 1
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: PPUSH
9022: CALL_OW 72
9026: PUSH
9027: LD_INT 1
9029: ARRAY
9030: PPUSH
9031: LD_STRING DArm-1-explore
9033: PPUSH
9034: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
9038: LD_EXP 27
9042: PPUSH
9043: LD_STRING DA-1-explore
9045: PPUSH
9046: CALL_OW 88
// if Sophia then
9050: LD_EXP 29
9054: IFFALSE 9132
// begin Say ( Sophia , DS-2-explore ) ;
9056: LD_EXP 29
9060: PPUSH
9061: LD_STRING DS-2-explore
9063: PPUSH
9064: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
9068: LD_EXP 27
9072: PPUSH
9073: LD_STRING DA-2-explore
9075: PPUSH
9076: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
9080: LD_EXP 29
9084: PPUSH
9085: LD_EXP 27
9089: PPUSH
9090: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
9094: LD_EXP 27
9098: PPUSH
9099: LD_EXP 29
9103: PPUSH
9104: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
9108: LD_EXP 29
9112: PPUSH
9113: LD_STRING DS-3-explore
9115: PPUSH
9116: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
9120: LD_EXP 27
9124: PPUSH
9125: LD_STRING DA-3-explore
9127: PPUSH
9128: CALL_OW 88
// end ; if Mike then
9132: LD_EXP 25
9136: IFFALSE 9192
// begin Say ( Mike , DM-1-explore ) ;
9138: LD_EXP 25
9142: PPUSH
9143: LD_STRING DM-1-explore
9145: PPUSH
9146: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
9150: LD_EXP 23
9154: PPUSH
9155: LD_STRING DH-2-explore
9157: PPUSH
9158: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
9162: LD_EXP 25
9166: PPUSH
9167: LD_STRING DM-2-explore
9169: PPUSH
9170: CALL_OW 88
// if Kaia then
9174: LD_EXP 28
9178: IFFALSE 9192
// Say ( Kaia , DK-1-explore ) ;
9180: LD_EXP 28
9184: PPUSH
9185: LD_STRING DK-1-explore
9187: PPUSH
9188: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
9192: LD_INT 22
9194: PUSH
9195: LD_INT 2
9197: PUSH
9198: EMPTY
9199: LIST
9200: LIST
9201: PPUSH
9202: CALL_OW 69
9206: PPUSH
9207: CALL_OW 139
// Video ( false ) ;
9211: LD_INT 0
9213: PPUSH
9214: CALL 962 0 1
// end ;
9218: END
// every 0 0$1 trigger not americanBaseSpoted and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
9219: LD_EXP 5
9223: NOT
9224: PUSH
9225: LD_INT 5
9227: PPUSH
9228: LD_INT 22
9230: PUSH
9231: LD_INT 2
9233: PUSH
9234: EMPTY
9235: LIST
9236: LIST
9237: PPUSH
9238: CALL_OW 70
9242: AND
9243: PUSH
9244: LD_EXP 6
9248: NOT
9249: AND
9250: IFFALSE 9335
9252: GO 9254
9254: DISABLE
// begin if Mike then
9255: LD_EXP 25
9259: IFFALSE 9275
// Say ( Mike , DM-1-scout ) else
9261: LD_EXP 25
9265: PPUSH
9266: LD_STRING DM-1-scout
9268: PPUSH
9269: CALL_OW 88
9273: GO 9306
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
9275: LD_EXP 37
9279: PPUSH
9280: LD_INT 26
9282: PUSH
9283: LD_INT 1
9285: PUSH
9286: EMPTY
9287: LIST
9288: LIST
9289: PPUSH
9290: CALL_OW 72
9294: PUSH
9295: LD_INT 1
9297: ARRAY
9298: PPUSH
9299: LD_STRING DArm-1-explore
9301: PPUSH
9302: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
9306: LD_INT 54
9308: PPUSH
9309: LD_INT 35
9311: PPUSH
9312: LD_INT 2
9314: PPUSH
9315: LD_INT 1
9317: PPUSH
9318: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
9322: LD_INT 54
9324: PPUSH
9325: LD_INT 35
9327: PPUSH
9328: LD_INT 2
9330: PPUSH
9331: CALL_OW 331
// end ;
9335: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) do var randomMen , randomWomen , speakerOk ;
9336: LD_INT 6
9338: PPUSH
9339: LD_INT 22
9341: PUSH
9342: LD_INT 2
9344: PUSH
9345: EMPTY
9346: LIST
9347: LIST
9348: PPUSH
9349: CALL_OW 70
9353: IFFALSE 9578
9355: GO 9357
9357: DISABLE
9358: LD_INT 0
9360: PPUSH
9361: PPUSH
9362: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
9363: LD_ADDR_VAR 0 1
9367: PUSH
9368: LD_EXP 37
9372: PPUSH
9373: LD_INT 26
9375: PUSH
9376: LD_INT 1
9378: PUSH
9379: EMPTY
9380: LIST
9381: LIST
9382: PPUSH
9383: CALL_OW 72
9387: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
9388: LD_ADDR_VAR 0 2
9392: PUSH
9393: LD_EXP 37
9397: PPUSH
9398: LD_INT 26
9400: PUSH
9401: LD_INT 2
9403: PUSH
9404: EMPTY
9405: LIST
9406: LIST
9407: PPUSH
9408: CALL_OW 72
9412: ST_TO_ADDR
// DialogueOn ;
9413: CALL_OW 6
// dwait ( 0 0$1 ) ;
9417: LD_INT 35
9419: PPUSH
9420: CALL_OW 68
// speakerOk := false ;
9424: LD_ADDR_VAR 0 3
9428: PUSH
9429: LD_INT 0
9431: ST_TO_ADDR
// if Mike then
9432: LD_EXP 25
9436: IFFALSE 9458
// speakerOk := Say ( Mike , DM-1-spot ) else
9438: LD_ADDR_VAR 0 3
9442: PUSH
9443: LD_EXP 25
9447: PPUSH
9448: LD_STRING DM-1-spot
9450: PPUSH
9451: CALL_OW 88
9455: ST_TO_ADDR
9456: GO 9486
// if randomMen then
9458: LD_VAR 0 1
9462: IFFALSE 9486
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
9464: LD_ADDR_VAR 0 3
9468: PUSH
9469: LD_VAR 0 1
9473: PUSH
9474: LD_INT 1
9476: ARRAY
9477: PPUSH
9478: LD_STRING DArm-1-spot-a
9480: PPUSH
9481: CALL_OW 88
9485: ST_TO_ADDR
// if speakerOk then
9486: LD_VAR 0 3
9490: IFFALSE 9534
// begin if Givi then
9492: LD_EXP 24
9496: IFFALSE 9512
// Say ( Givi , DG-1-spot ) else
9498: LD_EXP 24
9502: PPUSH
9503: LD_STRING DG-1-spot
9505: PPUSH
9506: CALL_OW 88
9510: GO 9534
// if randomWomen then
9512: LD_VAR 0 2
9516: IFFALSE 9534
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
9518: LD_VAR 0 2
9522: PUSH
9523: LD_INT 1
9525: ARRAY
9526: PPUSH
9527: LD_STRING DArf-1-spot-a
9529: PPUSH
9530: CALL_OW 88
// end ; if Mike then
9534: LD_EXP 25
9538: IFFALSE 9554
// Say ( Heike , DH-1-spot ) else
9540: LD_EXP 23
9544: PPUSH
9545: LD_STRING DH-1-spot
9547: PPUSH
9548: CALL_OW 88
9552: GO 9566
// Say ( Heike , DH-1-spot-a ) ;
9554: LD_EXP 23
9558: PPUSH
9559: LD_STRING DH-1-spot-a
9561: PPUSH
9562: CALL_OW 88
// DialogueOff ;
9566: CALL_OW 7
// americanBaseSpoted := true ;
9570: LD_ADDR_EXP 5
9574: PUSH
9575: LD_INT 1
9577: ST_TO_ADDR
// end ;
9578: PPOPN 3
9580: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
9581: LD_EXP 5
9585: NOT
9586: PUSH
9587: LD_INT 22
9589: PUSH
9590: LD_INT 2
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PUSH
9597: LD_INT 101
9599: PUSH
9600: LD_INT 1
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: EMPTY
9608: LIST
9609: LIST
9610: PPUSH
9611: CALL_OW 69
9615: AND
9616: PUSH
9617: LD_EXP 6
9621: NOT
9622: AND
9623: IFFALSE 9709
9625: GO 9627
9627: DISABLE
9628: LD_INT 0
9630: PPUSH
// begin americanBaseSpoted := true ;
9631: LD_ADDR_EXP 5
9635: PUSH
9636: LD_INT 1
9638: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
9639: LD_ADDR_VAR 0 1
9643: PUSH
9644: LD_EXP 37
9648: PPUSH
9649: LD_INT 26
9651: PUSH
9652: LD_INT 1
9654: PUSH
9655: EMPTY
9656: LIST
9657: LIST
9658: PPUSH
9659: CALL_OW 72
9663: ST_TO_ADDR
// if not randomMen then
9664: LD_VAR 0 1
9668: NOT
9669: IFFALSE 9673
// exit ;
9671: GO 9709
// DialogueOn ;
9673: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
9677: LD_VAR 0 1
9681: PUSH
9682: LD_INT 1
9684: ARRAY
9685: PPUSH
9686: LD_STRING DArm-1-spot-a
9688: PPUSH
9689: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
9693: LD_EXP 23
9697: PPUSH
9698: LD_STRING DH-1-spot-a
9700: PPUSH
9701: CALL_OW 88
// DialogueOff ;
9705: CALL_OW 7
// end ;
9709: PPOPN 1
9711: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 do var i , p ;
9712: LD_INT 11
9714: PPUSH
9715: CALL_OW 255
9719: PUSH
9720: LD_INT 2
9722: EQUAL
9723: PUSH
9724: LD_INT 22
9726: PUSH
9727: LD_INT 1
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: LD_INT 3
9736: PUSH
9737: LD_INT 50
9739: PUSH
9740: EMPTY
9741: LIST
9742: PUSH
9743: EMPTY
9744: LIST
9745: LIST
9746: PUSH
9747: LD_INT 30
9749: PUSH
9750: LD_INT 31
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: LIST
9761: PPUSH
9762: CALL_OW 69
9766: OR
9767: PUSH
9768: LD_INT 7
9770: PPUSH
9771: LD_INT 22
9773: PUSH
9774: LD_INT 2
9776: PUSH
9777: EMPTY
9778: LIST
9779: LIST
9780: PPUSH
9781: CALL_OW 70
9785: PUSH
9786: LD_INT 1
9788: GREATER
9789: OR
9790: IFFALSE 10246
9792: GO 9794
9794: DISABLE
9795: LD_INT 0
9797: PPUSH
9798: PPUSH
// begin americanBaseCaptured := true ;
9799: LD_ADDR_EXP 6
9803: PUSH
9804: LD_INT 1
9806: ST_TO_ADDR
// wait ( 0 0$2 ) ;
9807: LD_INT 70
9809: PPUSH
9810: CALL_OW 67
// if IsOk ( usCommander ) then
9814: LD_EXP 40
9818: PPUSH
9819: CALL_OW 302
9823: IFFALSE 9853
// begin usForces := usForces union usCommander ;
9825: LD_ADDR_EXP 39
9829: PUSH
9830: LD_EXP 39
9834: PUSH
9835: LD_EXP 40
9839: UNION
9840: ST_TO_ADDR
// Say ( usCommander , DUsm-1-assault ) ;
9841: LD_EXP 40
9845: PPUSH
9846: LD_STRING DUsm-1-assault
9848: PPUSH
9849: CALL_OW 88
// end ; for i in usForces do
9853: LD_ADDR_VAR 0 1
9857: PUSH
9858: LD_EXP 39
9862: PUSH
9863: FOR_IN
9864: IFFALSE 9903
// begin if IsInUnit ( i ) then
9866: LD_VAR 0 1
9870: PPUSH
9871: CALL_OW 310
9875: IFFALSE 9886
// ComExitBuilding ( i ) ;
9877: LD_VAR 0 1
9881: PPUSH
9882: CALL_OW 122
// AddComMoveXY ( i , 34 , 67 ) ;
9886: LD_VAR 0 1
9890: PPUSH
9891: LD_INT 34
9893: PPUSH
9894: LD_INT 67
9896: PPUSH
9897: CALL_OW 171
// end ;
9901: GO 9863
9903: POP
9904: POP
// Say ( Heike , DH-1-assault ) ;
9905: LD_EXP 23
9909: PPUSH
9910: LD_STRING DH-1-assault
9912: PPUSH
9913: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
9917: LD_INT 35
9919: PPUSH
9920: CALL_OW 67
// until not usForces ;
9924: LD_EXP 39
9928: NOT
9929: IFFALSE 9917
// if not americanHasEscaped then
9931: LD_EXP 7
9935: NOT
9936: IFFALSE 9950
// Say ( Heike , DH-2-assault ) ;
9938: LD_EXP 23
9942: PPUSH
9943: LD_STRING DH-2-assault
9945: PPUSH
9946: CALL_OW 88
// wait ( 0 0$2 ) ;
9950: LD_INT 70
9952: PPUSH
9953: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9957: LD_INT 35
9959: PPUSH
9960: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
9964: LD_INT 22
9966: PUSH
9967: LD_INT 2
9969: PUSH
9970: EMPTY
9971: LIST
9972: LIST
9973: PUSH
9974: LD_INT 21
9976: PUSH
9977: LD_INT 1
9979: PUSH
9980: EMPTY
9981: LIST
9982: LIST
9983: PUSH
9984: LD_INT 3
9986: PUSH
9987: LD_INT 50
9989: PUSH
9990: EMPTY
9991: LIST
9992: PUSH
9993: EMPTY
9994: LIST
9995: LIST
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: LIST
10001: PPUSH
10002: CALL_OW 69
10006: NOT
10007: IFFALSE 9957
// Video ( true ) ;
10009: LD_INT 1
10011: PPUSH
10012: CALL 962 0 1
// if not GetSide ( usDepot ) = 2 then
10016: LD_INT 11
10018: PPUSH
10019: CALL_OW 255
10023: PUSH
10024: LD_INT 2
10026: EQUAL
10027: NOT
10028: IFFALSE 10040
// SetSide ( usDepot , 2 ) ;
10030: LD_INT 11
10032: PPUSH
10033: LD_INT 2
10035: PPUSH
10036: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
10040: LD_INT 35
10042: PPUSH
10043: LD_INT 22
10045: PPUSH
10046: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
10050: LD_EXP 23
10054: PPUSH
10055: LD_INT 35
10057: PPUSH
10058: LD_INT 22
10060: PPUSH
10061: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
10065: LD_EXP 23
10069: PPUSH
10070: LD_INT 38
10072: PPUSH
10073: LD_INT 25
10075: PPUSH
10076: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
10080: LD_EXP 36
10084: PUSH
10085: LD_EXP 37
10089: UNION
10090: PPUSH
10091: LD_INT 39
10093: PPUSH
10094: LD_INT 26
10096: PPUSH
10097: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
10101: LD_EXP 36
10105: PUSH
10106: LD_EXP 37
10110: UNION
10111: PPUSH
10112: LD_EXP 23
10116: PPUSH
10117: CALL_OW 179
// p := 0 ;
10121: LD_ADDR_VAR 0 2
10125: PUSH
10126: LD_INT 0
10128: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10129: LD_INT 35
10131: PPUSH
10132: CALL_OW 67
// p := p + 1 ;
10136: LD_ADDR_VAR 0 2
10140: PUSH
10141: LD_VAR 0 2
10145: PUSH
10146: LD_INT 1
10148: PLUS
10149: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
10150: LD_EXP 23
10154: PPUSH
10155: CALL_OW 314
10159: NOT
10160: PUSH
10161: LD_VAR 0 2
10165: PUSH
10166: LD_INT 10
10168: GREATER
10169: OR
10170: IFFALSE 10129
// Say ( Heike , DH-1-capture ) ;
10172: LD_EXP 23
10176: PPUSH
10177: LD_STRING DH-1-capture
10179: PPUSH
10180: CALL_OW 88
// if Markov then
10184: LD_EXP 30
10188: IFFALSE 10202
// Say ( Markov , DMar-1-capture ) ;
10190: LD_EXP 30
10194: PPUSH
10195: LD_STRING DMar-1-capture
10197: PPUSH
10198: CALL_OW 88
// if Sophia then
10202: LD_EXP 29
10206: IFFALSE 10232
// begin Say ( Heike , DH-2-capture ) ;
10208: LD_EXP 23
10212: PPUSH
10213: LD_STRING DH-2-capture
10215: PPUSH
10216: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
10220: LD_EXP 29
10224: PPUSH
10225: LD_STRING DS-1-capture
10227: PPUSH
10228: CALL_OW 88
// end ; Video ( false ) ;
10232: LD_INT 0
10234: PPUSH
10235: CALL 962 0 1
// ChangeMissionObjectives ( ConstructBase ) ;
10239: LD_STRING ConstructBase
10241: PPUSH
10242: CALL_OW 337
// end ;
10246: PPOPN 2
10248: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
10249: LD_INT 22
10251: PUSH
10252: LD_INT 2
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PUSH
10259: LD_INT 30
10261: PUSH
10262: LD_INT 2
10264: PUSH
10265: EMPTY
10266: LIST
10267: LIST
10268: PUSH
10269: LD_INT 3
10271: PUSH
10272: LD_INT 57
10274: PUSH
10275: EMPTY
10276: LIST
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: LIST
10286: PPUSH
10287: CALL_OW 69
10291: IFFALSE 10382
10293: GO 10295
10295: DISABLE
// begin workshopBuilded := true ;
10296: LD_ADDR_EXP 9
10300: PUSH
10301: LD_INT 1
10303: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructVeh ) ;
10304: LD_STRING ConstructVeh
10306: PPUSH
10307: CALL_OW 337
// if not IsOk ( Markov ) then
10311: LD_EXP 30
10315: PPUSH
10316: CALL_OW 302
10320: NOT
10321: IFFALSE 10325
// exit ;
10323: GO 10382
// Say ( Heike , DH-1-shop ) ;
10325: LD_EXP 23
10329: PPUSH
10330: LD_STRING DH-1-shop
10332: PPUSH
10333: CALL_OW 88
// if not ( GetTech ( 2 , tech_OilEng ) = state_researched and GetTech ( 2 , tech_SolEng ) = state_researched ) then
10337: LD_INT 2
10339: PPUSH
10340: LD_INT 47
10342: PPUSH
10343: CALL_OW 321
10347: PUSH
10348: LD_INT 2
10350: EQUAL
10351: PUSH
10352: LD_INT 2
10354: PPUSH
10355: LD_INT 45
10357: PPUSH
10358: CALL_OW 321
10362: PUSH
10363: LD_INT 2
10365: EQUAL
10366: AND
10367: NOT
10368: IFFALSE 10382
// Say ( Markov , DMar-1-shop-a ) ;
10370: LD_EXP 30
10374: PPUSH
10375: LD_STRING DMar-1-shop-a
10377: PPUSH
10378: CALL_OW 88
// end ;
10382: END
// every 0 0$1 trigger IsOk ( Markov ) and workshopBuilded and GetTech ( 2 , tech_OilEng ) = state_researched and GetTech ( 2 , tech_SolEng ) = state_researched do
10383: LD_EXP 30
10387: PPUSH
10388: CALL_OW 302
10392: PUSH
10393: LD_EXP 9
10397: AND
10398: PUSH
10399: LD_INT 2
10401: PPUSH
10402: LD_INT 47
10404: PPUSH
10405: CALL_OW 321
10409: PUSH
10410: LD_INT 2
10412: EQUAL
10413: AND
10414: PUSH
10415: LD_INT 2
10417: PPUSH
10418: LD_INT 45
10420: PPUSH
10421: CALL_OW 321
10425: PUSH
10426: LD_INT 2
10428: EQUAL
10429: AND
10430: IFFALSE 10551
10432: GO 10434
10434: DISABLE
// begin DialogueOn ;
10435: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
10439: LD_EXP 30
10443: PPUSH
10444: LD_STRING DMar-1-shop
10446: PPUSH
10447: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
10451: LD_EXP 23
10455: PPUSH
10456: LD_STRING DH-1-shop
10458: PPUSH
10459: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
10463: LD_EXP 30
10467: PPUSH
10468: LD_STRING DMar-2-shop
10470: PPUSH
10471: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
10475: LD_EXP 30
10479: PPUSH
10480: LD_STRING DMar-3-shop
10482: PPUSH
10483: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
10487: LD_EXP 23
10491: PPUSH
10492: LD_STRING DH-2-shop
10494: PPUSH
10495: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
10499: LD_EXP 30
10503: PPUSH
10504: LD_STRING DMar-4-shop
10506: PPUSH
10507: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
10511: LD_EXP 23
10515: PPUSH
10516: LD_STRING DH-3-shop
10518: PPUSH
10519: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
10523: LD_EXP 30
10527: PPUSH
10528: LD_STRING DMar-5-shop
10530: PPUSH
10531: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
10535: LD_EXP 23
10539: PPUSH
10540: LD_STRING DH-4-shop
10542: PPUSH
10543: CALL_OW 88
// DialogueOff ;
10547: CALL_OW 7
// end ;
10551: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
10552: LD_EXP 30
10556: PPUSH
10557: CALL_OW 302
10561: PUSH
10562: LD_INT 22
10564: PUSH
10565: LD_INT 2
10567: PUSH
10568: EMPTY
10569: LIST
10570: LIST
10571: PUSH
10572: LD_INT 2
10574: PUSH
10575: LD_INT 34
10577: PUSH
10578: LD_INT 22
10580: PUSH
10581: EMPTY
10582: LIST
10583: LIST
10584: PUSH
10585: LD_INT 35
10587: PUSH
10588: LD_INT 22
10590: PUSH
10591: EMPTY
10592: LIST
10593: LIST
10594: PUSH
10595: EMPTY
10596: LIST
10597: LIST
10598: LIST
10599: PUSH
10600: EMPTY
10601: LIST
10602: LIST
10603: PPUSH
10604: CALL_OW 69
10608: AND
10609: IFFALSE 10716
10611: GO 10613
10613: DISABLE
// begin DialogueOn ;
10614: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
10618: LD_INT 22
10620: PUSH
10621: LD_INT 2
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: PUSH
10628: LD_INT 2
10630: PUSH
10631: LD_INT 34
10633: PUSH
10634: LD_INT 22
10636: PUSH
10637: EMPTY
10638: LIST
10639: LIST
10640: PUSH
10641: LD_INT 35
10643: PUSH
10644: LD_INT 22
10646: PUSH
10647: EMPTY
10648: LIST
10649: LIST
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: LIST
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: PPUSH
10660: CALL_OW 69
10664: PPUSH
10665: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
10669: LD_INT 10
10671: PPUSH
10672: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
10676: LD_EXP 23
10680: PPUSH
10681: LD_STRING DH-1-bal
10683: PPUSH
10684: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
10688: LD_EXP 30
10692: PPUSH
10693: LD_STRING DMar-1-bal
10695: PPUSH
10696: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
10700: LD_EXP 23
10704: PPUSH
10705: LD_STRING DH-2-bal
10707: PPUSH
10708: CALL_OW 88
// DialogueOff ;
10712: CALL_OW 7
// end ;
10716: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
10717: LD_EXP 27
10721: PPUSH
10722: CALL_OW 302
10726: PUSH
10727: LD_INT 22
10729: PUSH
10730: LD_INT 2
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PUSH
10737: LD_INT 30
10739: PUSH
10740: LD_INT 6
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PPUSH
10751: CALL_OW 69
10755: AND
10756: IFFALSE 10817
10758: GO 10760
10760: DISABLE
// begin DialogueOn ;
10761: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
10765: LD_EXP 27
10769: PPUSH
10770: LD_STRING DA-1-lab
10772: PPUSH
10773: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
10777: LD_EXP 23
10781: PPUSH
10782: LD_STRING DH-1-lab
10784: PPUSH
10785: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
10789: LD_EXP 27
10793: PPUSH
10794: LD_STRING DA-2-lab
10796: PPUSH
10797: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
10801: LD_EXP 23
10805: PPUSH
10806: LD_STRING DH-2-lab
10808: PPUSH
10809: CALL_OW 88
// DialogueOff ;
10813: CALL_OW 7
// end ;
10817: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) do var ape ;
10818: LD_EXP 28
10822: PPUSH
10823: CALL_OW 302
10827: PUSH
10828: LD_INT 22
10830: PUSH
10831: LD_INT 2
10833: PUSH
10834: EMPTY
10835: LIST
10836: LIST
10837: PUSH
10838: LD_INT 25
10840: PUSH
10841: LD_INT 15
10843: PUSH
10844: EMPTY
10845: LIST
10846: LIST
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PPUSH
10852: CALL_OW 69
10856: AND
10857: IFFALSE 11037
10859: GO 10861
10861: DISABLE
10862: LD_INT 0
10864: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
10865: LD_ADDR_VAR 0 1
10869: PUSH
10870: LD_INT 22
10872: PUSH
10873: LD_INT 2
10875: PUSH
10876: EMPTY
10877: LIST
10878: LIST
10879: PUSH
10880: LD_INT 25
10882: PUSH
10883: LD_INT 15
10885: PUSH
10886: EMPTY
10887: LIST
10888: LIST
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: PPUSH
10894: CALL_OW 69
10898: ST_TO_ADDR
// Video ( true ) ;
10899: LD_INT 1
10901: PPUSH
10902: CALL 962 0 1
// CenterNowOnUnits ( ape [ 1 ] ) ;
10906: LD_VAR 0 1
10910: PUSH
10911: LD_INT 1
10913: ARRAY
10914: PPUSH
10915: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
10919: LD_VAR 0 1
10923: PUSH
10924: LD_INT 1
10926: ARRAY
10927: PPUSH
10928: CALL_OW 122
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
10932: LD_VAR 0 1
10936: PUSH
10937: LD_INT 1
10939: ARRAY
10940: PPUSH
10941: LD_INT 35
10943: PPUSH
10944: LD_INT 28
10946: PPUSH
10947: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
10951: LD_VAR 0 1
10955: PUSH
10956: LD_INT 1
10958: ARRAY
10959: PPUSH
10960: LD_INT 36
10962: PPUSH
10963: LD_INT 17
10965: PPUSH
10966: CALL_OW 171
// Say ( Kaia , DK-1-apesol ) ;
10970: LD_EXP 28
10974: PPUSH
10975: LD_STRING DK-1-apesol
10977: PPUSH
10978: CALL_OW 88
// Say ( Aviradze , DA-1-apesol ) ;
10982: LD_EXP 27
10986: PPUSH
10987: LD_STRING DA-1-apesol
10989: PPUSH
10990: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
10994: LD_EXP 28
10998: PPUSH
10999: LD_STRING DK-2-apesol
11001: PPUSH
11002: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
11006: LD_EXP 27
11010: PPUSH
11011: LD_STRING DA-2-apesol
11013: PPUSH
11014: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
11018: LD_EXP 28
11022: PPUSH
11023: LD_STRING DK-3-apesol
11025: PPUSH
11026: CALL_OW 88
// Video ( false ) ;
11030: LD_INT 0
11032: PPUSH
11033: CALL 962 0 1
// end ;
11037: PPOPN 1
11039: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) do var ape ;
11040: LD_EXP 29
11044: PPUSH
11045: CALL_OW 302
11049: PUSH
11050: LD_INT 22
11052: PUSH
11053: LD_INT 2
11055: PUSH
11056: EMPTY
11057: LIST
11058: LIST
11059: PUSH
11060: LD_INT 25
11062: PUSH
11063: LD_INT 16
11065: PUSH
11066: EMPTY
11067: LIST
11068: LIST
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PPUSH
11074: CALL_OW 69
11078: AND
11079: IFFALSE 11351
11081: GO 11083
11083: DISABLE
11084: LD_INT 0
11086: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
11087: LD_ADDR_VAR 0 1
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_INT 2
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: LD_INT 25
11104: PUSH
11105: LD_INT 16
11107: PUSH
11108: EMPTY
11109: LIST
11110: LIST
11111: PUSH
11112: EMPTY
11113: LIST
11114: LIST
11115: PPUSH
11116: CALL_OW 69
11120: ST_TO_ADDR
// Video ( true ) ;
11121: LD_INT 1
11123: PPUSH
11124: CALL 962 0 1
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
11128: LD_INT 5
11130: PPUSH
11131: LD_INT 35
11133: PPUSH
11134: LD_INT 22
11136: PPUSH
11137: LD_INT 1
11139: PPUSH
11140: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
11144: LD_EXP 29
11148: PPUSH
11149: LD_VAR 0 1
11153: PUSH
11154: LD_INT 1
11156: ARRAY
11157: PPUSH
11158: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
11162: LD_VAR 0 1
11166: PUSH
11167: LD_INT 1
11169: ARRAY
11170: PPUSH
11171: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
11175: LD_VAR 0 1
11179: PUSH
11180: LD_INT 1
11182: ARRAY
11183: PPUSH
11184: CALL_OW 122
// wait ( 0 0$2 ) ;
11188: LD_INT 70
11190: PPUSH
11191: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
11195: LD_EXP 29
11199: PPUSH
11200: LD_STRING DS-1-apeeng
11202: PPUSH
11203: CALL_OW 88
// if IsOk ( Kamil ) then
11207: LD_EXP 26
11211: PPUSH
11212: CALL_OW 302
11216: IFFALSE 11344
// begin Say ( Kamil , DKam-1-apeeng ) ;
11218: LD_EXP 26
11222: PPUSH
11223: LD_STRING DKam-1-apeeng
11225: PPUSH
11226: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
11230: LD_EXP 29
11234: PPUSH
11235: LD_STRING DS-2-apeeng
11237: PPUSH
11238: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
11242: LD_EXP 26
11246: PPUSH
11247: LD_STRING DKam-2-apeeng
11249: PPUSH
11250: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
11254: LD_EXP 29
11258: PPUSH
11259: LD_STRING DS-3-apeeng
11261: PPUSH
11262: CALL_OW 88
// if not IsOK ( Kaia ) then
11266: LD_EXP 28
11270: PPUSH
11271: CALL_OW 302
11275: NOT
11276: IFFALSE 11287
// begin Video ( false ) ;
11278: LD_INT 0
11280: PPUSH
11281: CALL 962 0 1
// exit ;
11285: GO 11351
// end ; Say ( Kaia , DK-1-apeeng ) ;
11287: LD_EXP 28
11291: PPUSH
11292: LD_STRING DK-1-apeeng
11294: PPUSH
11295: CALL_OW 88
// if not IsOk ( Givi ) then
11299: LD_EXP 24
11303: PPUSH
11304: CALL_OW 302
11308: NOT
11309: IFFALSE 11320
// begin Video ( false ) ;
11311: LD_INT 0
11313: PPUSH
11314: CALL 962 0 1
// exit ;
11318: GO 11351
// end ; Say ( Givi , DG-1-apeeng ) ;
11320: LD_EXP 24
11324: PPUSH
11325: LD_STRING DG-1-apeeng
11327: PPUSH
11328: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
11332: LD_EXP 28
11336: PPUSH
11337: LD_STRING DK-2-apeeng
11339: PPUSH
11340: CALL_OW 88
// end ; Video ( false ) ;
11344: LD_INT 0
11346: PPUSH
11347: CALL 962 0 1
// end ;
11351: PPOPN 1
11353: END
// every 0 0$1 trigger farmerBaseReady do
11354: LD_EXP 4
11358: IFFALSE 11516
11360: GO 11362
11362: DISABLE
// begin DialogueOn ;
11363: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
11367: LD_EXP 31
11371: PPUSH
11372: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
11376: LD_EXP 31
11380: PPUSH
11381: LD_STRING DF-1-distribution
11383: PPUSH
11384: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
11388: LD_EXP 23
11392: PPUSH
11393: LD_STRING DH-2-distribution
11395: PPUSH
11396: CALL_OW 88
// if IsOk ( Kaia ) then
11400: LD_EXP 28
11404: PPUSH
11405: CALL_OW 302
11409: IFFALSE 11470
// begin Say ( Kaia , DK-1-distribution ) ;
11411: LD_EXP 28
11415: PPUSH
11416: LD_STRING DK-1-distribution
11418: PPUSH
11419: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
11423: LD_EXP 23
11427: PPUSH
11428: LD_STRING DH-1-distribution
11430: PPUSH
11431: CALL_OW 88
// if IsOk ( Givi ) then
11435: LD_EXP 24
11439: PPUSH
11440: CALL_OW 302
11444: IFFALSE 11470
// begin Say ( Givi , DG-1-distribution ) ;
11446: LD_EXP 24
11450: PPUSH
11451: LD_STRING DG-1-distribution
11453: PPUSH
11454: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
11458: LD_EXP 23
11462: PPUSH
11463: LD_STRING DH-3-distribution
11465: PPUSH
11466: CALL_OW 88
// end ; end ; DialogueOff ;
11470: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
11474: LD_STRING Crates1
11476: PPUSH
11477: CALL_OW 337
// farmerRequestedCrates := 300 ;
11481: LD_ADDR_EXP 13
11485: PUSH
11486: LD_INT 300
11488: ST_TO_ADDR
// Query ( FarmerCrates ) ;
11489: LD_STRING FarmerCrates
11491: PPUSH
11492: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
11496: LD_INT 10
11498: PPUSH
11499: LD_INT 1
11501: PPUSH
11502: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
11506: LD_INT 108
11508: PPUSH
11509: LD_INT 61
11511: PPUSH
11512: CALL_OW 86
// end ;
11516: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_lab ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
11517: LD_EXP 6
11521: PUSH
11522: LD_INT 22
11524: PUSH
11525: LD_INT 2
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: PUSH
11532: LD_INT 3
11534: PUSH
11535: LD_INT 57
11537: PUSH
11538: EMPTY
11539: LIST
11540: PUSH
11541: EMPTY
11542: LIST
11543: LIST
11544: PUSH
11545: LD_INT 30
11547: PUSH
11548: LD_INT 6
11550: PUSH
11551: EMPTY
11552: LIST
11553: LIST
11554: PUSH
11555: EMPTY
11556: LIST
11557: LIST
11558: LIST
11559: PPUSH
11560: CALL_OW 69
11564: AND
11565: PUSH
11566: LD_INT 22
11568: PUSH
11569: LD_INT 2
11571: PUSH
11572: EMPTY
11573: LIST
11574: LIST
11575: PUSH
11576: LD_INT 3
11578: PUSH
11579: LD_INT 57
11581: PUSH
11582: EMPTY
11583: LIST
11584: PUSH
11585: EMPTY
11586: LIST
11587: LIST
11588: PUSH
11589: LD_INT 30
11591: PUSH
11592: LD_INT 4
11594: PUSH
11595: EMPTY
11596: LIST
11597: LIST
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: LIST
11603: PPUSH
11604: CALL_OW 69
11608: AND
11609: IFFALSE 11761
11611: GO 11613
11613: DISABLE
11614: LD_INT 0
11616: PPUSH
// begin wait ( 0 0$10 ) ;
11617: LD_INT 350
11619: PPUSH
11620: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
11624: LD_ADDR_VAR 0 1
11628: PUSH
11629: LD_EXP 37
11633: PPUSH
11634: LD_INT 26
11636: PUSH
11637: LD_INT 1
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PUSH
11644: LD_INT 25
11646: PUSH
11647: LD_INT 2
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: PUSH
11654: EMPTY
11655: LIST
11656: LIST
11657: PPUSH
11658: CALL_OW 72
11662: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
11663: LD_EXP 23
11667: PPUSH
11668: LD_STRING DH-1-task
11670: PPUSH
11671: CALL_OW 88
// if IsOk ( Sophia ) then
11675: LD_EXP 29
11679: PPUSH
11680: CALL_OW 302
11684: IFFALSE 11712
// begin Say ( Sophia , DS-1-task ) ;
11686: LD_EXP 29
11690: PPUSH
11691: LD_STRING DS-1-task
11693: PPUSH
11694: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
11698: LD_EXP 23
11702: PPUSH
11703: LD_STRING DH-2-task
11705: PPUSH
11706: CALL_OW 88
// end else
11710: GO 11746
// if eng then
11712: LD_VAR 0 1
11716: IFFALSE 11746
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
11718: LD_VAR 0 1
11722: PUSH
11723: LD_INT 1
11725: ARRAY
11726: PPUSH
11727: LD_STRING DArm-1-task
11729: PPUSH
11730: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
11734: LD_EXP 23
11738: PPUSH
11739: LD_STRING DH-2-task
11741: PPUSH
11742: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
11746: LD_STRING BaseConstructed
11748: PPUSH
11749: CALL_OW 337
// allowConvoys := true ;
11753: LD_ADDR_EXP 11
11757: PUSH
11758: LD_INT 1
11760: ST_TO_ADDR
// end ;
11761: PPOPN 1
11763: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
11764: LD_EXP 4
11768: PUSH
11769: LD_EXP 12
11773: PUSH
11774: LD_INT 300
11776: GREATEREQUAL
11777: AND
11778: IFFALSE 11850
11780: GO 11782
11782: DISABLE
// begin DialogueOn ;
11783: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
11787: LD_EXP 31
11791: PPUSH
11792: LD_STRING DF-1-delivery-2
11794: PPUSH
11795: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
11799: LD_EXP 23
11803: PPUSH
11804: LD_STRING DH-1-delivery-2
11806: PPUSH
11807: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
11811: LD_EXP 31
11815: PPUSH
11816: LD_STRING DF-2-delivery-2
11818: PPUSH
11819: CALL_OW 94
// DialogueOff ;
11823: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
11827: LD_STRING Crates2
11829: PPUSH
11830: CALL_OW 337
// farmerCratesCounter := 4 4$00 ;
11834: LD_ADDR_EXP 14
11838: PUSH
11839: LD_INT 8400
11841: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
11842: LD_ADDR_EXP 13
11846: PUSH
11847: LD_INT 600
11849: ST_TO_ADDR
// end ;
11850: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 and Difficulty > 1 do
11851: LD_EXP 4
11855: PUSH
11856: LD_EXP 12
11860: PUSH
11861: LD_INT 600
11863: GREATEREQUAL
11864: AND
11865: PUSH
11866: LD_OWVAR 67
11870: PUSH
11871: LD_INT 1
11873: GREATER
11874: AND
11875: IFFALSE 12041
11877: GO 11879
11879: DISABLE
// begin DialogueOn ;
11880: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
11884: LD_EXP 31
11888: PPUSH
11889: LD_STRING DF-1-delivery-3
11891: PPUSH
11892: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
11896: LD_EXP 23
11900: PPUSH
11901: LD_STRING DH-1-delivery-3
11903: PPUSH
11904: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
11908: LD_EXP 31
11912: PPUSH
11913: LD_STRING DF-2-delivery-3
11915: PPUSH
11916: CALL_OW 94
// if IsOk ( Kaia ) then
11920: LD_EXP 28
11924: PPUSH
11925: CALL_OW 302
11929: IFFALSE 11979
// begin Say ( Kaia , DK-1-delivery-3 ) ;
11931: LD_EXP 28
11935: PPUSH
11936: LD_STRING DK-1-delivery-3
11938: PPUSH
11939: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
11943: LD_EXP 23
11947: PPUSH
11948: LD_STRING DH-2-delivery-3
11950: PPUSH
11951: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
11955: LD_EXP 24
11959: PPUSH
11960: LD_STRING DG-1-delivery-3
11962: PPUSH
11963: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
11967: LD_EXP 25
11971: PPUSH
11972: LD_STRING DM-1-delivery-3
11974: PPUSH
11975: CALL_OW 88
// end ; DialogueOff ;
11979: CALL_OW 7
// if Difficulty = 2 then
11983: LD_OWVAR 67
11987: PUSH
11988: LD_INT 2
11990: EQUAL
11991: IFFALSE 12018
// begin ChangeMissionObjectives ( Crates3 ) ;
11993: LD_STRING Crates3
11995: PPUSH
11996: CALL_OW 337
// farmerCratesCounter := 5 5$00 ;
12000: LD_ADDR_EXP 14
12004: PUSH
12005: LD_INT 10500
12007: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
12008: LD_ADDR_EXP 13
12012: PUSH
12013: LD_INT 900
12015: ST_TO_ADDR
// end else
12016: GO 12041
// begin ChangeMissionObjectives ( Crates4 ) ;
12018: LD_STRING Crates4
12020: PPUSH
12021: CALL_OW 337
// farmerCratesCounter := 6 6$00 ;
12025: LD_ADDR_EXP 14
12029: PUSH
12030: LD_INT 12600
12032: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
12033: LD_ADDR_EXP 13
12037: PUSH
12038: LD_INT 1200
12040: ST_TO_ADDR
// end ; end ;
12041: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
12042: LD_EXP 4
12046: PUSH
12047: LD_EXP 12
12051: PUSH
12052: LD_INT 600
12054: PUSH
12055: LD_INT 900
12057: PUSH
12058: LD_INT 1200
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: LIST
12065: PUSH
12066: LD_OWVAR 67
12070: ARRAY
12071: GREATEREQUAL
12072: AND
12073: PUSH
12074: LD_EXP 13
12078: PUSH
12079: LD_EXP 14
12083: LESSEQUAL
12084: AND
12085: IFFALSE 12158
12087: GO 12089
12089: DISABLE
// begin retreatAllowed := true ;
12090: LD_ADDR_EXP 10
12094: PUSH
12095: LD_INT 1
12097: ST_TO_ADDR
// display_strings := [ ] ;
12098: LD_ADDR_OWVAR 47
12102: PUSH
12103: EMPTY
12104: ST_TO_ADDR
// DialogueOn ;
12105: CALL_OW 6
// Video ( true ) ;
12109: LD_INT 1
12111: PPUSH
12112: CALL 962 0 1
// SayRadio ( Omar , DO-radio-end ) ;
12116: LD_EXP 32
12120: PPUSH
12121: LD_STRING DO-radio-end
12123: PPUSH
12124: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
12128: LD_EXP 23
12132: PPUSH
12133: LD_STRING DH-1-radio-end
12135: PPUSH
12136: CALL_OW 88
// Video ( false ) ;
12140: LD_INT 0
12142: PPUSH
12143: CALL 962 0 1
// DialogueOff ;
12147: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
12151: LD_STRING Retreat
12153: PPUSH
12154: CALL_OW 337
// end ;
12158: END
// every 0 0$1 trigger retreatAllowed do
12159: LD_EXP 10
12163: IFFALSE 12172
12165: GO 12167
12167: DISABLE
// StartCargoEvacuation ;
12168: CALL 3464 0 0
12172: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
12173: LD_EXP 10
12177: NOT
12178: PUSH
12179: LD_INT 5
12181: PPUSH
12182: CALL_OW 301
12186: AND
12187: IFFALSE 12211
12189: GO 12191
12191: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
12192: LD_EXP 31
12196: PPUSH
12197: LD_STRING DF-1-failure
12199: PPUSH
12200: CALL_OW 94
// YouLost ( FarmerDepot ) ;
12204: LD_STRING FarmerDepot
12206: PPUSH
12207: CALL_OW 104
// end ;
12211: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 do var i , max , tmp ;
12212: LD_EXP 10
12216: PUSH
12217: LD_EXP 23
12221: PPUSH
12222: LD_EXP 31
12226: PPUSH
12227: CALL_OW 296
12231: PUSH
12232: LD_INT 6
12234: LESS
12235: AND
12236: IFFALSE 12759
12238: GO 12240
12240: DISABLE
12241: LD_INT 0
12243: PPUSH
12244: PPUSH
12245: PPUSH
// begin Video ( true ) ;
12246: LD_INT 1
12248: PPUSH
12249: CALL 962 0 1
// ComTurnUnit ( Heike , Farmer ) ;
12253: LD_EXP 23
12257: PPUSH
12258: LD_EXP 31
12262: PPUSH
12263: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
12267: LD_EXP 31
12271: PPUSH
12272: LD_EXP 23
12276: PPUSH
12277: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
12281: LD_EXP 31
12285: PPUSH
12286: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
12290: LD_EXP 23
12294: PPUSH
12295: LD_STRING DH-1-end
12297: PPUSH
12298: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
12302: LD_EXP 31
12306: PPUSH
12307: LD_STRING DF-1-end
12309: PPUSH
12310: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
12314: LD_EXP 31
12318: PPUSH
12319: LD_STRING DF-2-end
12321: PPUSH
12322: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
12326: LD_EXP 23
12330: PPUSH
12331: LD_STRING DH-2-end
12333: PPUSH
12334: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
12338: LD_EXP 31
12342: PPUSH
12343: LD_STRING DF-3-end
12345: PPUSH
12346: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
12350: LD_EXP 23
12354: PPUSH
12355: LD_STRING DH-3-end
12357: PPUSH
12358: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
12362: LD_EXP 24
12366: PPUSH
12367: LD_STRING DG-1-end
12369: PPUSH
12370: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
12374: LD_EXP 23
12378: PPUSH
12379: LD_STRING DH-4-end
12381: PPUSH
12382: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
12386: LD_EXP 31
12390: PPUSH
12391: LD_STRING DF-4-end
12393: PPUSH
12394: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
12398: LD_EXP 23
12402: PPUSH
12403: LD_STRING DH-5-end
12405: PPUSH
12406: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
12410: LD_EXP 31
12414: PPUSH
12415: LD_STRING DF-5-end
12417: PPUSH
12418: CALL_OW 88
// Video ( false ) ;
12422: LD_INT 0
12424: PPUSH
12425: CALL 962 0 1
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
12429: LD_ADDR_VAR 0 2
12433: PUSH
12434: LD_INT 4
12436: PUSH
12437: LD_INT 3
12439: PUSH
12440: LD_INT 2
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: LIST
12447: PUSH
12448: LD_OWVAR 67
12452: ARRAY
12453: ST_TO_ADDR
// if farmerSquad < max then
12454: LD_EXP 34
12458: PUSH
12459: LD_VAR 0 2
12463: LESS
12464: IFFALSE 12476
// max := farmerSquad ;
12466: LD_ADDR_VAR 0 2
12470: PUSH
12471: LD_EXP 34
12475: ST_TO_ADDR
// for i := 1 to max do
12476: LD_ADDR_VAR 0 1
12480: PUSH
12481: DOUBLE
12482: LD_INT 1
12484: DEC
12485: ST_TO_ADDR
12486: LD_VAR 0 2
12490: PUSH
12491: FOR_TO
12492: IFFALSE 12530
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
12494: LD_EXP 34
12498: PUSH
12499: LD_INT 1
12501: ARRAY
12502: PPUSH
12503: LD_INT 2
12505: PPUSH
12506: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
12510: LD_ADDR_EXP 34
12514: PUSH
12515: LD_EXP 34
12519: PPUSH
12520: LD_INT 1
12522: PPUSH
12523: CALL_OW 3
12527: ST_TO_ADDR
// end ;
12528: GO 12491
12530: POP
12531: POP
// for i in Farmer ^ farmerSquad do
12532: LD_ADDR_VAR 0 1
12536: PUSH
12537: LD_EXP 31
12541: PUSH
12542: LD_EXP 34
12546: ADD
12547: PUSH
12548: FOR_IN
12549: IFFALSE 12588
// begin if IsInUnit ( i ) then
12551: LD_VAR 0 1
12555: PPUSH
12556: CALL_OW 310
12560: IFFALSE 12571
// ComExitBuilding ( i ) ;
12562: LD_VAR 0 1
12566: PPUSH
12567: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
12571: LD_VAR 0 1
12575: PPUSH
12576: LD_INT 102
12578: PPUSH
12579: LD_INT 7
12581: PPUSH
12582: CALL_OW 171
// end ;
12586: GO 12548
12588: POP
12589: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
12590: LD_ADDR_VAR 0 1
12594: PUSH
12595: LD_INT 22
12597: PUSH
12598: LD_INT 5
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 21
12607: PUSH
12608: LD_INT 3
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: PPUSH
12619: CALL_OW 69
12623: PUSH
12624: LD_INT 5
12626: DIFF
12627: PUSH
12628: FOR_IN
12629: IFFALSE 12645
// SetSide ( i , 2 ) ;
12631: LD_VAR 0 1
12635: PPUSH
12636: LD_INT 2
12638: PPUSH
12639: CALL_OW 235
12643: GO 12628
12645: POP
12646: POP
// repeat wait ( 0 0$1 ) ;
12647: LD_INT 35
12649: PPUSH
12650: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
12654: LD_ADDR_VAR 0 3
12658: PUSH
12659: LD_EXP 31
12663: PUSH
12664: LD_EXP 34
12668: ADD
12669: PPUSH
12670: LD_INT 95
12672: PUSH
12673: LD_INT 3
12675: PUSH
12676: EMPTY
12677: LIST
12678: LIST
12679: PPUSH
12680: CALL_OW 72
12684: ST_TO_ADDR
// if tmp then
12685: LD_VAR 0 3
12689: IFFALSE 12745
// for i in tmp do
12691: LD_ADDR_VAR 0 1
12695: PUSH
12696: LD_VAR 0 3
12700: PUSH
12701: FOR_IN
12702: IFFALSE 12743
// begin if i in farmerSquad then
12704: LD_VAR 0 1
12708: PUSH
12709: LD_EXP 34
12713: IN
12714: IFFALSE 12732
// farmerSquad := farmerSquad diff i ;
12716: LD_ADDR_EXP 34
12720: PUSH
12721: LD_EXP 34
12725: PUSH
12726: LD_VAR 0 1
12730: DIFF
12731: ST_TO_ADDR
// RemoveUnit ( i ) ;
12732: LD_VAR 0 1
12736: PPUSH
12737: CALL_OW 64
// end ;
12741: GO 12701
12743: POP
12744: POP
// until not Farmer and not farmerSquad ;
12745: LD_EXP 31
12749: NOT
12750: PUSH
12751: LD_EXP 34
12755: NOT
12756: AND
12757: IFFALSE 12647
// end ;
12759: PPOPN 3
12761: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
12762: LD_EXP 14
12766: PUSH
12767: LD_INT 0
12769: LESSEQUAL
12770: IFFALSE 12819
12772: GO 12774
12774: DISABLE
// begin DialogueOn ;
12775: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
12779: LD_EXP 31
12783: PPUSH
12784: LD_STRING DF-1-distribution-a
12786: PPUSH
12787: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
12791: LD_EXP 23
12795: PPUSH
12796: LD_STRING DH-1-distribution-a
12798: PPUSH
12799: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
12803: LD_EXP 31
12807: PPUSH
12808: LD_STRING DF-2-distribution-a
12810: PPUSH
12811: CALL_OW 94
// DialogueOff ;
12815: CALL_OW 7
// end ;
12819: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
12820: LD_INT 22
12822: PUSH
12823: LD_INT 2
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: PUSH
12830: LD_INT 34
12832: PUSH
12833: LD_INT 12
12835: PUSH
12836: EMPTY
12837: LIST
12838: LIST
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: PPUSH
12844: CALL_OW 69
12848: IFFALSE 12908
12850: GO 12852
12852: DISABLE
// begin DialogueOn ;
12853: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
12857: LD_EXP 23
12861: PPUSH
12862: LD_STRING DH-1-truck
12864: PPUSH
12865: CALL_OW 88
// if IsOk ( Markov ) then
12869: LD_EXP 30
12873: PPUSH
12874: CALL_OW 302
12878: IFFALSE 12904
// begin Say ( Markov , DMar-1-truck ) ;
12880: LD_EXP 30
12884: PPUSH
12885: LD_STRING DMar-1-truck
12887: PPUSH
12888: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
12892: LD_EXP 23
12896: PPUSH
12897: LD_STRING DH-2-truck
12899: PPUSH
12900: CALL_OW 88
// end ; DialogueOff ;
12904: CALL_OW 7
// end ;
12908: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
12909: LD_INT 0
12911: PPUSH
12912: PPUSH
12913: PPUSH
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
12914: LD_ADDR_VAR 0 2
12918: PUSH
12919: LD_EXP 37
12923: PPUSH
12924: LD_INT 26
12926: PUSH
12927: LD_INT 1
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: PPUSH
12934: CALL_OW 72
12938: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
12939: LD_ADDR_VAR 0 3
12943: PUSH
12944: LD_EXP 37
12948: PPUSH
12949: LD_INT 26
12951: PUSH
12952: LD_INT 2
12954: PUSH
12955: EMPTY
12956: LIST
12957: LIST
12958: PPUSH
12959: CALL_OW 72
12963: ST_TO_ADDR
// if randomMen then
12964: LD_VAR 0 2
12968: IFFALSE 12988
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
12970: LD_VAR 0 2
12974: PUSH
12975: LD_INT 1
12977: ARRAY
12978: PPUSH
12979: LD_STRING DArm-1-nocargo
12981: PPUSH
12982: CALL_OW 88
12986: GO 13010
// if randomWomen then
12988: LD_VAR 0 3
12992: IFFALSE 13010
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
12994: LD_VAR 0 3
12998: PUSH
12999: LD_INT 1
13001: ARRAY
13002: PPUSH
13003: LD_STRING DArf-1-nocargo
13005: PPUSH
13006: CALL_OW 88
// end ;
13010: LD_VAR 0 1
13014: RET
// export function IncomingAttack ; begin
13015: LD_INT 0
13017: PPUSH
// if attackWave = 1 then
13018: LD_EXP 16
13022: PUSH
13023: LD_INT 1
13025: EQUAL
13026: IFFALSE 13097
// begin DialogueOn ;
13028: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
13032: LD_EXP 32
13036: PPUSH
13037: LD_STRING DO-1-radio-1
13039: PPUSH
13040: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
13044: LD_EXP 23
13048: PPUSH
13049: LD_STRING DH-1-radio-1-
13051: PPUSH
13052: CALL_OW 88
// if IsOk ( Markov ) then
13056: LD_EXP 30
13060: PPUSH
13061: CALL_OW 302
13065: IFFALSE 13091
// begin Say ( Markov , DMar-1-radio-1 ) ;
13067: LD_EXP 30
13071: PPUSH
13072: LD_STRING DMar-1-radio-1
13074: PPUSH
13075: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
13079: LD_EXP 23
13083: PPUSH
13084: LD_STRING DH-2-radio-1
13086: PPUSH
13087: CALL_OW 88
// end ; DialogueOff ;
13091: CALL_OW 7
// end else
13095: GO 13121
// begin SayRadio ( Omar , DO-1-radio-u ) ;
13097: LD_EXP 32
13101: PPUSH
13102: LD_STRING DO-1-radio-u
13104: PPUSH
13105: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
13109: LD_EXP 23
13113: PPUSH
13114: LD_STRING DH-1-radio-u
13116: PPUSH
13117: CALL_OW 88
// end ; end ;
13121: LD_VAR 0 1
13125: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
13126: LD_EXP 39
13130: PPUSH
13131: LD_INT 95
13133: PUSH
13134: LD_INT 8
13136: PUSH
13137: EMPTY
13138: LIST
13139: LIST
13140: PPUSH
13141: CALL_OW 72
13145: IFFALSE 13248
13147: GO 13149
13149: DISABLE
13150: LD_INT 0
13152: PPUSH
// begin enable ;
13153: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
13154: LD_ADDR_VAR 0 1
13158: PUSH
13159: LD_EXP 39
13163: PPUSH
13164: LD_INT 95
13166: PUSH
13167: LD_INT 8
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PPUSH
13174: CALL_OW 72
13178: PUSH
13179: FOR_IN
13180: IFFALSE 13209
// begin usForces := usForces diff i ;
13182: LD_ADDR_EXP 39
13186: PUSH
13187: LD_EXP 39
13191: PUSH
13192: LD_VAR 0 1
13196: DIFF
13197: ST_TO_ADDR
// RemoveUnit ( i ) ;
13198: LD_VAR 0 1
13202: PPUSH
13203: CALL_OW 64
// end ;
13207: GO 13179
13209: POP
13210: POP
// if not americanHasEscaped and attackWave = 1 then
13211: LD_EXP 7
13215: NOT
13216: PUSH
13217: LD_EXP 16
13221: PUSH
13222: LD_INT 1
13224: EQUAL
13225: AND
13226: IFFALSE 13248
// begin americanHasEscaped := true ;
13228: LD_ADDR_EXP 7
13232: PUSH
13233: LD_INT 1
13235: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
13236: LD_EXP 23
13240: PPUSH
13241: LD_STRING DH-2-assault-a
13243: PPUSH
13244: CALL_OW 88
// end ; end ;
13248: PPOPN 1
13250: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
13251: LD_INT 5
13253: PPUSH
13254: CALL_OW 255
13258: PUSH
13259: LD_INT 2
13261: EQUAL
13262: IFFALSE 13274
13264: GO 13266
13266: DISABLE
// YouLost ( Attack ) ;
13267: LD_STRING Attack
13269: PPUSH
13270: CALL_OW 104
13274: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not retreatAllowed and farmerCrates > 100 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) do var randomMen , randomWomen , speaker , place ;
13275: LD_INT 22
13277: PUSH
13278: LD_INT 1
13280: PUSH
13281: EMPTY
13282: LIST
13283: LIST
13284: PUSH
13285: LD_INT 21
13287: PUSH
13288: LD_INT 1
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: PPUSH
13299: CALL_OW 69
13303: NOT
13304: PUSH
13305: LD_EXP 10
13309: NOT
13310: AND
13311: PUSH
13312: LD_EXP 12
13316: PUSH
13317: LD_INT 100
13319: GREATER
13320: AND
13321: PUSH
13322: LD_INT 7
13324: PPUSH
13325: LD_INT 22
13327: PUSH
13328: LD_INT 2
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PUSH
13335: LD_INT 21
13337: PUSH
13338: LD_INT 1
13340: PUSH
13341: EMPTY
13342: LIST
13343: LIST
13344: PUSH
13345: EMPTY
13346: LIST
13347: LIST
13348: PPUSH
13349: CALL_OW 70
13353: AND
13354: IFFALSE 14057
13356: GO 13358
13358: DISABLE
13359: LD_INT 0
13361: PPUSH
13362: PPUSH
13363: PPUSH
13364: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
13365: LD_ADDR_VAR 0 1
13369: PUSH
13370: LD_EXP 37
13374: PPUSH
13375: LD_INT 26
13377: PUSH
13378: LD_INT 1
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PPUSH
13385: CALL_OW 72
13389: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
13390: LD_ADDR_VAR 0 2
13394: PUSH
13395: LD_EXP 37
13399: PPUSH
13400: LD_INT 26
13402: PUSH
13403: LD_INT 2
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PPUSH
13410: CALL_OW 72
13414: ST_TO_ADDR
// if IsOk ( Kaia ) then
13415: LD_EXP 28
13419: PPUSH
13420: CALL_OW 302
13424: IFFALSE 13445
// speaker := [ Kaia , DK ] else
13426: LD_ADDR_VAR 0 3
13430: PUSH
13431: LD_EXP 28
13435: PUSH
13436: LD_STRING DK
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: ST_TO_ADDR
13443: GO 13525
// if randomMen then
13445: LD_VAR 0 1
13449: IFFALSE 13484
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
13451: LD_ADDR_VAR 0 3
13455: PUSH
13456: LD_VAR 0 1
13460: PUSH
13461: LD_INT 1
13463: PPUSH
13464: LD_VAR 0 1
13468: PPUSH
13469: CALL_OW 12
13473: ARRAY
13474: PUSH
13475: LD_STRING DArm
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: ST_TO_ADDR
13482: GO 13525
// if randomWomen then
13484: LD_VAR 0 2
13488: IFFALSE 13523
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
13490: LD_ADDR_VAR 0 3
13494: PUSH
13495: LD_VAR 0 2
13499: PUSH
13500: LD_INT 1
13502: PPUSH
13503: LD_VAR 0 2
13507: PPUSH
13508: CALL_OW 12
13512: ARRAY
13513: PUSH
13514: LD_STRING DArf
13516: PUSH
13517: EMPTY
13518: LIST
13519: LIST
13520: ST_TO_ADDR
13521: GO 13525
// exit ;
13523: GO 14057
// if IsInUnit ( speaker [ 1 ] ) then
13525: LD_VAR 0 3
13529: PUSH
13530: LD_INT 1
13532: ARRAY
13533: PPUSH
13534: CALL_OW 310
13538: IFFALSE 13561
// place := IsInUnit ( speaker [ 1 ] ) else
13540: LD_ADDR_VAR 0 4
13544: PUSH
13545: LD_VAR 0 3
13549: PUSH
13550: LD_INT 1
13552: ARRAY
13553: PPUSH
13554: CALL_OW 310
13558: ST_TO_ADDR
13559: GO 13575
// place := speaker [ 1 ] ;
13561: LD_ADDR_VAR 0 4
13565: PUSH
13566: LD_VAR 0 3
13570: PUSH
13571: LD_INT 1
13573: ARRAY
13574: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
13575: LD_VAR 0 4
13579: PPUSH
13580: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
13584: LD_VAR 0 4
13588: PPUSH
13589: CALL_OW 250
13593: PPUSH
13594: LD_VAR 0 4
13598: PPUSH
13599: CALL_OW 251
13603: PPUSH
13604: CALL 2174 0 2
// wait ( 0 0$2 ) ;
13608: LD_INT 70
13610: PPUSH
13611: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
13615: LD_EXP 33
13619: PPUSH
13620: CALL_OW 305
13624: NOT
13625: IFFALSE 13629
// exit ;
13627: GO 14057
// Video ( true ) ;
13629: LD_INT 1
13631: PPUSH
13632: CALL 962 0 1
// wait ( 0 0$1 ) ;
13636: LD_INT 35
13638: PPUSH
13639: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
13643: LD_EXP 33
13647: PPUSH
13648: LD_STRING DI-1-land
13650: PPUSH
13651: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
13655: LD_VAR 0 3
13659: PUSH
13660: LD_INT 1
13662: ARRAY
13663: PPUSH
13664: CALL_OW 310
13668: IFFALSE 13683
// ComExit ( speaker [ 1 ] ) ;
13670: LD_VAR 0 3
13674: PUSH
13675: LD_INT 1
13677: ARRAY
13678: PPUSH
13679: CALL 1066 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
13683: LD_VAR 0 3
13687: PUSH
13688: LD_INT 1
13690: ARRAY
13691: PPUSH
13692: LD_EXP 33
13696: PPUSH
13697: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
13701: LD_VAR 0 3
13705: PUSH
13706: LD_INT 1
13708: ARRAY
13709: PPUSH
13710: LD_EXP 33
13714: PPUSH
13715: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
13719: LD_EXP 33
13723: PPUSH
13724: LD_VAR 0 3
13728: PUSH
13729: LD_INT 1
13731: ARRAY
13732: PPUSH
13733: CALL_OW 119
// wait ( 0 0$1 ) ;
13737: LD_INT 35
13739: PPUSH
13740: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
13744: LD_VAR 0 3
13748: PUSH
13749: LD_INT 1
13751: ARRAY
13752: PPUSH
13753: LD_VAR 0 3
13757: PUSH
13758: LD_INT 2
13760: ARRAY
13761: PUSH
13762: LD_STRING -1-land
13764: STR
13765: PPUSH
13766: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
13770: LD_EXP 33
13774: PPUSH
13775: LD_STRING DI-2-land
13777: PPUSH
13778: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
13782: LD_VAR 0 3
13786: PUSH
13787: LD_INT 1
13789: ARRAY
13790: PPUSH
13791: LD_VAR 0 3
13795: PUSH
13796: LD_INT 2
13798: ARRAY
13799: PUSH
13800: LD_STRING -2-land
13802: STR
13803: PPUSH
13804: CALL_OW 88
// if IsInUnit ( Heike ) then
13808: LD_EXP 23
13812: PPUSH
13813: CALL_OW 310
13817: IFFALSE 13828
// ComExitBuilding ( Heike ) ;
13819: LD_EXP 23
13823: PPUSH
13824: CALL_OW 122
// AddComMoveXY ( Heike , 34 , 21 ) ;
13828: LD_EXP 23
13832: PPUSH
13833: LD_INT 34
13835: PPUSH
13836: LD_INT 21
13838: PPUSH
13839: CALL_OW 171
// AddComTurnUnit ( Heike , speaker [ 1 ] ) ;
13843: LD_EXP 23
13847: PPUSH
13848: LD_VAR 0 3
13852: PUSH
13853: LD_INT 1
13855: ARRAY
13856: PPUSH
13857: CALL_OW 179
// ComMoveXY ( Ibrahim , 36 , 22 ) ;
13861: LD_EXP 33
13865: PPUSH
13866: LD_INT 36
13868: PPUSH
13869: LD_INT 22
13871: PPUSH
13872: CALL_OW 111
// ComMoveXY ( speaker [ 1 ] , 35 , 22 ) ;
13876: LD_VAR 0 3
13880: PUSH
13881: LD_INT 1
13883: ARRAY
13884: PPUSH
13885: LD_INT 35
13887: PPUSH
13888: LD_INT 22
13890: PPUSH
13891: CALL_OW 111
// AddComTurnUnit ( [ Ibrahim , speaker [ 1 ] ] , Heike ) ;
13895: LD_EXP 33
13899: PUSH
13900: LD_VAR 0 3
13904: PUSH
13905: LD_INT 1
13907: ARRAY
13908: PUSH
13909: EMPTY
13910: LIST
13911: LIST
13912: PPUSH
13913: LD_EXP 23
13917: PPUSH
13918: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
13922: LD_INT 35
13924: PPUSH
13925: CALL_OW 67
// until GetDistUnits ( speaker [ 1 ] , usDepot ) < 8 ;
13929: LD_VAR 0 3
13933: PUSH
13934: LD_INT 1
13936: ARRAY
13937: PPUSH
13938: LD_INT 11
13940: PPUSH
13941: CALL_OW 296
13945: PUSH
13946: LD_INT 8
13948: LESS
13949: IFFALSE 13922
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
13951: LD_VAR 0 3
13955: PUSH
13956: LD_INT 1
13958: ARRAY
13959: PPUSH
13960: LD_VAR 0 3
13964: PUSH
13965: LD_INT 2
13967: ARRAY
13968: PUSH
13969: LD_STRING -3-land
13971: STR
13972: PPUSH
13973: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
13977: LD_EXP 23
13981: PPUSH
13982: LD_STRING DH-1-land
13984: PPUSH
13985: CALL_OW 88
// if UnitsInside ( usDepot ) = 6 then
13989: LD_INT 11
13991: PPUSH
13992: CALL_OW 313
13996: PUSH
13997: LD_INT 6
13999: EQUAL
14000: IFFALSE 14018
// ComExitBuilding ( UnitsInside ( usDepot ) [ 1 ] ) ;
14002: LD_INT 11
14004: PPUSH
14005: CALL_OW 313
14009: PUSH
14010: LD_INT 1
14012: ARRAY
14013: PPUSH
14014: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
14018: LD_EXP 33
14022: PPUSH
14023: LD_INT 2
14025: PPUSH
14026: CALL_OW 235
// ComEnterUnit ( Ibrahim , usDepot ) ;
14030: LD_EXP 33
14034: PPUSH
14035: LD_INT 11
14037: PPUSH
14038: CALL_OW 120
// Video ( false ) ;
14042: LD_INT 0
14044: PPUSH
14045: CALL 962 0 1
// ibrahimInDepot := true ;
14049: LD_ADDR_EXP 21
14053: PUSH
14054: LD_INT 1
14056: ST_TO_ADDR
// end ;
14057: PPOPN 4
14059: END
// export function IbrahimQuery ; begin
14060: LD_INT 0
14062: PPUSH
// case Query ( IbrahimQuery ) of 1 :
14063: LD_STRING IbrahimQuery
14065: PPUSH
14066: CALL_OW 97
14070: PUSH
14071: LD_INT 1
14073: DOUBLE
14074: EQUAL
14075: IFTRUE 14079
14077: GO 14367
14079: POP
// begin Video ( true ) ;
14080: LD_INT 1
14082: PPUSH
14083: CALL 962 0 1
// ibrahimInDepot := false ;
14087: LD_ADDR_EXP 21
14091: PUSH
14092: LD_INT 0
14094: ST_TO_ADDR
// Say ( Heike , DH-1-interrogation ) ;
14095: LD_EXP 23
14099: PPUSH
14100: LD_STRING DH-1-interrogation
14102: PPUSH
14103: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
14107: LD_EXP 33
14111: PPUSH
14112: LD_STRING DI-1-interrogation
14114: PPUSH
14115: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
14119: LD_EXP 23
14123: PPUSH
14124: LD_STRING DH-2-interrogation
14126: PPUSH
14127: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
14131: LD_EXP 33
14135: PPUSH
14136: LD_STRING DI-2-interrogation
14138: PPUSH
14139: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
14143: LD_EXP 23
14147: PPUSH
14148: LD_STRING DH-3-interrogation
14150: PPUSH
14151: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
14155: LD_EXP 33
14159: PPUSH
14160: LD_STRING DI-3-interrogation
14162: PPUSH
14163: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
14167: LD_EXP 23
14171: PPUSH
14172: LD_STRING DH-4-interrogation
14174: PPUSH
14175: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
14179: LD_EXP 33
14183: PPUSH
14184: LD_STRING DI-4-interrogation
14186: PPUSH
14187: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
14191: LD_EXP 23
14195: PPUSH
14196: LD_STRING DH-5-interrogation
14198: PPUSH
14199: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
14203: LD_EXP 33
14207: PPUSH
14208: LD_STRING DI-5-interrogation
14210: PPUSH
14211: CALL_OW 88
// wait ( 0 0$1 ) ;
14215: LD_INT 35
14217: PPUSH
14218: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
14222: LD_STRING IbrahimDecisionQuery
14224: PPUSH
14225: CALL_OW 97
14229: PUSH
14230: LD_INT 1
14232: DOUBLE
14233: EQUAL
14234: IFTRUE 14238
14236: GO 14262
14238: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
14239: LD_EXP 33
14243: PPUSH
14244: LD_STRING DI-1-kill
14246: PPUSH
14247: CALL_OW 88
// KillUnit ( Ibrahim ) ;
14251: LD_EXP 33
14255: PPUSH
14256: CALL_OW 66
// end ; 2 :
14260: GO 14358
14262: LD_INT 2
14264: DOUBLE
14265: EQUAL
14266: IFTRUE 14270
14268: GO 14357
14270: POP
// begin ComExitBuilding ( Ibrahim ) ;
14271: LD_EXP 33
14275: PPUSH
14276: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
14280: LD_EXP 33
14284: PPUSH
14285: LD_INT 32
14287: PPUSH
14288: LD_INT 5
14290: PPUSH
14291: CALL_OW 171
// wait ( 0 0$3 ) ;
14295: LD_INT 105
14297: PPUSH
14298: CALL_OW 67
// ComExitBuilding ( Heike ) ;
14302: LD_EXP 23
14306: PPUSH
14307: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
14311: LD_EXP 23
14315: PPUSH
14316: LD_INT 36
14318: PPUSH
14319: LD_INT 21
14321: PPUSH
14322: CALL_OW 171
// AddComWait ( Ibrahim , 0 0$2 ) ;
14326: LD_EXP 33
14330: PPUSH
14331: LD_INT 70
14333: PPUSH
14334: CALL_OW 202
// AddComHold ( Ibrahim ) ;
14338: LD_EXP 33
14342: PPUSH
14343: CALL_OW 200
// ibrahimIsFree := true ;
14347: LD_ADDR_EXP 22
14351: PUSH
14352: LD_INT 1
14354: ST_TO_ADDR
// end ; end ;
14355: GO 14358
14357: POP
// Video ( false ) ;
14358: LD_INT 0
14360: PPUSH
14361: CALL 962 0 1
// end ; 2 :
14365: GO 14379
14367: LD_INT 2
14369: DOUBLE
14370: EQUAL
14371: IFTRUE 14375
14373: GO 14378
14375: POP
// ; end ;
14376: GO 14379
14378: POP
// end ;
14379: LD_VAR 0 1
14383: RET
// every 0 0$10 trigger ibrahimIsFree and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass ;
14384: LD_EXP 22
14388: PUSH
14389: LD_EXP 33
14393: PPUSH
14394: LD_INT 7
14396: PPUSH
14397: CALL_OW 308
14401: AND
14402: PUSH
14403: LD_INT 6
14405: PPUSH
14406: LD_EXP 23
14410: PPUSH
14411: CALL_OW 292
14415: AND
14416: PUSH
14417: LD_INT 22
14419: PUSH
14420: LD_INT 1
14422: PUSH
14423: EMPTY
14424: LIST
14425: LIST
14426: PUSH
14427: LD_INT 21
14429: PUSH
14430: LD_INT 1
14432: PUSH
14433: EMPTY
14434: LIST
14435: LIST
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PPUSH
14441: CALL_OW 69
14445: NOT
14446: AND
14447: IFFALSE 14953
14449: GO 14451
14451: DISABLE
14452: LD_INT 0
14454: PPUSH
// begin Video ( true ) ;
14455: LD_INT 1
14457: PPUSH
14458: CALL 962 0 1
// CenterNowOnUnits ( Ibrahim ) ;
14462: LD_EXP 33
14466: PPUSH
14467: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
14471: LD_EXP 23
14475: PPUSH
14476: LD_EXP 33
14480: PPUSH
14481: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
14485: LD_EXP 33
14489: PPUSH
14490: LD_EXP 23
14494: PPUSH
14495: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
14499: LD_EXP 33
14503: PPUSH
14504: LD_STRING DI-1-free
14506: PPUSH
14507: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
14511: LD_EXP 23
14515: PPUSH
14516: LD_STRING DH-1-free
14518: PPUSH
14519: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
14523: LD_EXP 33
14527: PPUSH
14528: LD_STRING DI-2-free
14530: PPUSH
14531: CALL_OW 88
// changeClass := 0 ;
14535: LD_ADDR_VAR 0 1
14539: PUSH
14540: LD_INT 0
14542: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
14543: LD_STRING IbrahimJoinQuery
14545: PPUSH
14546: CALL_OW 97
14550: PUSH
14551: LD_INT 1
14553: DOUBLE
14554: EQUAL
14555: IFTRUE 14559
14557: GO 14570
14559: POP
// begin changeClass := 1 ;
14560: LD_ADDR_VAR 0 1
14564: PUSH
14565: LD_INT 1
14567: ST_TO_ADDR
// end ; 2 :
14568: GO 14774
14570: LD_INT 2
14572: DOUBLE
14573: EQUAL
14574: IFTRUE 14578
14576: GO 14694
14578: POP
// begin Say ( Heike , DH-1-decline ) ;
14579: LD_EXP 23
14583: PPUSH
14584: LD_STRING DH-1-decline
14586: PPUSH
14587: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
14591: LD_EXP 33
14595: PPUSH
14596: LD_STRING DI-1-decline
14598: PPUSH
14599: CALL_OW 88
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
14603: LD_EXP 33
14607: PPUSH
14608: LD_INT 30
14610: PPUSH
14611: LD_INT 1
14613: PPUSH
14614: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14618: LD_INT 35
14620: PPUSH
14621: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) ;
14625: LD_EXP 33
14629: PPUSH
14630: LD_INT 30
14632: PPUSH
14633: LD_INT 1
14635: PPUSH
14636: CALL_OW 307
14640: PUSH
14641: LD_INT 22
14643: PUSH
14644: LD_INT 2
14646: PUSH
14647: EMPTY
14648: LIST
14649: LIST
14650: PUSH
14651: LD_INT 101
14653: PUSH
14654: LD_INT 6
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: PUSH
14661: EMPTY
14662: LIST
14663: LIST
14664: PPUSH
14665: CALL_OW 69
14669: NOT
14670: OR
14671: IFFALSE 14618
// RemoveUnit ( Ibrahim ) ;
14673: LD_EXP 33
14677: PPUSH
14678: CALL_OW 64
// SaveVariable ( 1 , IbrahimHasEscaped ) ;
14682: LD_INT 1
14684: PPUSH
14685: LD_STRING IbrahimHasEscaped
14687: PPUSH
14688: CALL_OW 39
// end ; 3 :
14692: GO 14774
14694: LD_INT 3
14696: DOUBLE
14697: EQUAL
14698: IFTRUE 14702
14700: GO 14773
14702: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
14703: LD_EXP 23
14707: PPUSH
14708: LD_STRING DH-1-radio-hq
14710: PPUSH
14711: CALL_OW 88
// Say ( Ibrahim , DO-1-radio-hq ) ;
14715: LD_EXP 33
14719: PPUSH
14720: LD_STRING DO-1-radio-hq
14722: PPUSH
14723: CALL_OW 88
// Say ( Heike , DH-2-radio-hq ) ;
14727: LD_EXP 23
14731: PPUSH
14732: LD_STRING DH-2-radio-hq
14734: PPUSH
14735: CALL_OW 88
// Say ( Ibrahim , DO-2-radio-hq ) ;
14739: LD_EXP 33
14743: PPUSH
14744: LD_STRING DO-2-radio-hq
14746: PPUSH
14747: CALL_OW 88
// Say ( Heike , DH-3-radio-hq ) ;
14751: LD_EXP 23
14755: PPUSH
14756: LD_STRING DH-3-radio-hq
14758: PPUSH
14759: CALL_OW 88
// changeClass := 1 ;
14763: LD_ADDR_VAR 0 1
14767: PUSH
14768: LD_INT 1
14770: ST_TO_ADDR
// end ; end ;
14771: GO 14774
14773: POP
// if changeClass then
14774: LD_VAR 0 1
14778: IFFALSE 14946
// begin Say ( Heike , DH-1-agree ) ;
14780: LD_EXP 23
14784: PPUSH
14785: LD_STRING DH-1-agree
14787: PPUSH
14788: CALL_OW 88
// if IsOk ( Givi ) then
14792: LD_EXP 24
14796: PPUSH
14797: CALL_OW 302
14801: IFFALSE 14839
// begin Say ( Givi , DG-1-agree ) ;
14803: LD_EXP 24
14807: PPUSH
14808: LD_STRING DG-1-agree
14810: PPUSH
14811: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
14815: LD_EXP 23
14819: PPUSH
14820: LD_STRING DH-2-agree
14822: PPUSH
14823: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
14827: LD_EXP 24
14831: PPUSH
14832: LD_STRING DG-2-agree
14834: PPUSH
14835: CALL_OW 88
// end ; if UnitsInside ( usDepot ) = 6 then
14839: LD_INT 11
14841: PPUSH
14842: CALL_OW 313
14846: PUSH
14847: LD_INT 6
14849: EQUAL
14850: IFFALSE 14868
// ComExitBuilding ( UnitsInside ( usDepot ) [ 1 ] ) ;
14852: LD_INT 11
14854: PPUSH
14855: CALL_OW 313
14859: PUSH
14860: LD_INT 1
14862: ARRAY
14863: PPUSH
14864: CALL_OW 122
// ComEnterUnit ( Ibrahim , usDepot ) ;
14868: LD_EXP 33
14872: PPUSH
14873: LD_INT 11
14875: PPUSH
14876: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
14880: LD_INT 35
14882: PPUSH
14883: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
14887: LD_EXP 33
14891: PPUSH
14892: CALL_OW 310
14896: IFFALSE 14880
// RemoveUnit ( Ibrahim ) ;
14898: LD_EXP 33
14902: PPUSH
14903: CALL_OW 64
// uc_side := 2 ;
14907: LD_ADDR_OWVAR 20
14911: PUSH
14912: LD_INT 2
14914: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
14915: LD_ADDR_EXP 33
14919: PUSH
14920: LD_STRING Ibrahim
14922: PPUSH
14923: LD_INT 0
14925: PPUSH
14926: LD_STRING 
14928: PPUSH
14929: CALL 239 0 3
14933: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , usDepot ) ;
14934: LD_EXP 33
14938: PPUSH
14939: LD_INT 11
14941: PPUSH
14942: CALL_OW 52
// end ; Video ( false ) ;
14946: LD_INT 0
14948: PPUSH
14949: CALL 962 0 1
// end ;
14953: PPOPN 1
14955: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 do
14956: LD_EXP 10
14960: PUSH
14961: LD_EXP 17
14965: PUSH
14966: LD_INT 1
14968: LESS
14969: AND
14970: IFFALSE 15349
14972: GO 14974
14974: DISABLE
// begin DialogueOn ;
14975: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
14979: LD_EXP 23
14983: PPUSH
14984: LD_STRING DH-1-final
14986: PPUSH
14987: CALL_OW 88
// if tick <= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
14991: LD_OWVAR 1
14995: PUSH
14996: LD_INT 126000
14998: PUSH
14999: LD_INT 105000
15001: PUSH
15002: LD_INT 94500
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: LIST
15009: PUSH
15010: LD_OWVAR 67
15014: ARRAY
15015: LESSEQUAL
15016: IFFALSE 15030
// AddMedal ( med1 , 1 ) else
15018: LD_STRING med1
15020: PPUSH
15021: LD_INT 1
15023: PPUSH
15024: CALL_OW 101
15028: GO 15041
// AddMedal ( med1 , - 1 ) ;
15030: LD_STRING med1
15032: PPUSH
15033: LD_INT 1
15035: NEG
15036: PPUSH
15037: CALL_OW 101
// if vehCounter >= 2 then
15041: LD_EXP 18
15045: PUSH
15046: LD_INT 2
15048: GREATEREQUAL
15049: IFFALSE 15063
// AddMedal ( med2 , 1 ) else
15051: LD_STRING med2
15053: PPUSH
15054: LD_INT 1
15056: PPUSH
15057: CALL_OW 101
15061: GO 15074
// AddMedal ( med2 , - 1 ) ;
15063: LD_STRING med2
15065: PPUSH
15066: LD_INT 1
15068: NEG
15069: PPUSH
15070: CALL_OW 101
// if deadCounter = 0 then
15074: LD_EXP 8
15078: PUSH
15079: LD_INT 0
15081: EQUAL
15082: IFFALSE 15096
// AddMedal ( med3 , 1 ) else
15084: LD_STRING med3
15086: PPUSH
15087: LD_INT 1
15089: PPUSH
15090: CALL_OW 101
15094: GO 15107
// AddMedal ( med3 , - 1 ) ;
15096: LD_STRING med3
15098: PPUSH
15099: LD_INT 1
15101: NEG
15102: PPUSH
15103: CALL_OW 101
// GiveMedals ( MAIN ) ;
15107: LD_STRING MAIN
15109: PPUSH
15110: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
15114: LD_INT 22
15116: PUSH
15117: LD_INT 2
15119: PUSH
15120: EMPTY
15121: LIST
15122: LIST
15123: PUSH
15124: LD_INT 23
15126: PUSH
15127: LD_INT 2
15129: PUSH
15130: EMPTY
15131: LIST
15132: LIST
15133: PUSH
15134: LD_INT 21
15136: PUSH
15137: LD_INT 1
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: LIST
15147: LIST
15148: PPUSH
15149: CALL_OW 69
15153: PPUSH
15154: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
15158: LD_EXP 23
15162: PPUSH
15163: LD_STRING 03_Heike
15165: PPUSH
15166: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
15170: LD_EXP 27
15174: PPUSH
15175: LD_STRING 03_Aviradze
15177: PPUSH
15178: CALL_OW 38
// if Givi then
15182: LD_EXP 24
15186: IFFALSE 15200
// SaveCharacters ( Givi , 03_Givi ) ;
15188: LD_EXP 24
15192: PPUSH
15193: LD_STRING 03_Givi
15195: PPUSH
15196: CALL_OW 38
// if Mike then
15200: LD_EXP 25
15204: IFFALSE 15218
// SaveCharacters ( Mike , 03_Mike ) ;
15206: LD_EXP 25
15210: PPUSH
15211: LD_STRING 03_Mike
15213: PPUSH
15214: CALL_OW 38
// if Kamil then
15218: LD_EXP 26
15222: IFFALSE 15236
// SaveCharacters ( Kamil , 03_Kamil ) ;
15224: LD_EXP 26
15228: PPUSH
15229: LD_STRING 03_Kamil
15231: PPUSH
15232: CALL_OW 38
// if Kaia then
15236: LD_EXP 28
15240: IFFALSE 15254
// SaveCharacters ( Kaia , 03_Kaia ) ;
15242: LD_EXP 28
15246: PPUSH
15247: LD_STRING 03_Kaia
15249: PPUSH
15250: CALL_OW 38
// if Sophia then
15254: LD_EXP 29
15258: IFFALSE 15272
// SaveCharacters ( Sophia , 03_Sophia ) ;
15260: LD_EXP 29
15264: PPUSH
15265: LD_STRING 03_Sophia
15267: PPUSH
15268: CALL_OW 38
// if Markov then
15272: LD_EXP 30
15276: IFFALSE 15290
// SaveCharacters ( Markov , 03_Markov ) ;
15278: LD_EXP 30
15282: PPUSH
15283: LD_STRING 03_Markov
15285: PPUSH
15286: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
15290: LD_EXP 33
15294: PUSH
15295: LD_EXP 33
15299: PPUSH
15300: CALL_OW 255
15304: PUSH
15305: LD_INT 2
15307: EQUAL
15308: AND
15309: IFFALSE 15323
// SaveCharacters ( Markov , 03_Ibrahim ) ;
15311: LD_EXP 30
15315: PPUSH
15316: LD_STRING 03_Ibrahim
15318: PPUSH
15319: CALL_OW 38
// if heikeSecondSquad then
15323: LD_EXP 37
15327: IFFALSE 15341
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
15329: LD_EXP 37
15333: PPUSH
15334: LD_STRING 03_others
15336: PPUSH
15337: CALL_OW 38
// YouWin ;
15341: CALL_OW 103
// DialogueOff ;
15345: CALL_OW 7
// end ; end_of_file
15349: END
// on UnitDestroyed ( un ) do begin if un = Heike then
15350: LD_VAR 0 1
15354: PUSH
15355: LD_EXP 23
15359: EQUAL
15360: IFFALSE 15369
// YouLost ( Heike ) ;
15362: LD_STRING Heike
15364: PPUSH
15365: CALL_OW 104
// if un = Aviradze then
15369: LD_VAR 0 1
15373: PUSH
15374: LD_EXP 27
15378: EQUAL
15379: IFFALSE 15388
// YouLost ( Aviradze ) ;
15381: LD_STRING Aviradze
15383: PPUSH
15384: CALL_OW 104
// if un = usDepot and not retreatAllowed then
15388: LD_VAR 0 1
15392: PUSH
15393: LD_INT 11
15395: EQUAL
15396: PUSH
15397: LD_EXP 10
15401: NOT
15402: AND
15403: IFFALSE 15412
// YouLost ( Depot ) ;
15405: LD_STRING Depot
15407: PPUSH
15408: CALL_OW 104
// if un = Farmer then
15412: LD_VAR 0 1
15416: PUSH
15417: LD_EXP 31
15421: EQUAL
15422: IFFALSE 15431
// YouLost ( Farmer ) ;
15424: LD_STRING Farmer
15426: PPUSH
15427: CALL_OW 104
// if un in usForces then
15431: LD_VAR 0 1
15435: PUSH
15436: LD_EXP 39
15440: IN
15441: IFFALSE 15459
// usForces := usForces diff un ;
15443: LD_ADDR_EXP 39
15447: PUSH
15448: LD_EXP 39
15452: PUSH
15453: LD_VAR 0 1
15457: DIFF
15458: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
15459: LD_VAR 0 1
15463: PUSH
15464: LD_INT 22
15466: PUSH
15467: LD_INT 2
15469: PUSH
15470: EMPTY
15471: LIST
15472: LIST
15473: PUSH
15474: LD_INT 23
15476: PUSH
15477: LD_INT 2
15479: PUSH
15480: EMPTY
15481: LIST
15482: LIST
15483: PUSH
15484: LD_INT 21
15486: PUSH
15487: LD_INT 1
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: LIST
15498: PPUSH
15499: CALL_OW 69
15503: IN
15504: IFFALSE 15520
// deadCounter := deadCounter + 1 ;
15506: LD_ADDR_EXP 8
15510: PUSH
15511: LD_EXP 8
15515: PUSH
15516: LD_INT 1
15518: PLUS
15519: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
15520: LD_VAR 0 1
15524: PUSH
15525: LD_INT 22
15527: PUSH
15528: LD_INT 4
15530: PUSH
15531: EMPTY
15532: LIST
15533: LIST
15534: PUSH
15535: LD_INT 34
15537: PUSH
15538: LD_INT 12
15540: PUSH
15541: EMPTY
15542: LIST
15543: LIST
15544: PUSH
15545: EMPTY
15546: LIST
15547: LIST
15548: PPUSH
15549: CALL_OW 69
15553: IN
15554: PUSH
15555: LD_EXP 15
15559: NOT
15560: AND
15561: IFFALSE 15571
// firstConvoyDestroyed := true ;
15563: LD_ADDR_EXP 15
15567: PUSH
15568: LD_INT 1
15570: ST_TO_ADDR
// if un in usAttackers then
15571: LD_VAR 0 1
15575: PUSH
15576: LD_EXP 42
15580: IN
15581: IFFALSE 15599
// usAttackers := usAttackers diff un ;
15583: LD_ADDR_EXP 42
15587: PUSH
15588: LD_EXP 42
15592: PUSH
15593: LD_VAR 0 1
15597: DIFF
15598: ST_TO_ADDR
// end ;
15599: PPOPN 1
15601: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
15602: LD_VAR 0 2
15606: PUSH
15607: LD_EXP 33
15611: EQUAL
15612: PUSH
15613: LD_EXP 21
15617: AND
15618: IFFALSE 15653
// begin Video ( true ) ;
15620: LD_INT 1
15622: PPUSH
15623: CALL 962 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
15627: LD_EXP 33
15631: PPUSH
15632: LD_INT 11
15634: PPUSH
15635: CALL_OW 120
// wait ( 0 0$1 ) ;
15639: LD_INT 35
15641: PPUSH
15642: CALL_OW 67
// Video ( false ) ;
15646: LD_INT 0
15648: PPUSH
15649: CALL 962 0 1
// end ; end ;
15653: PPOPN 2
15655: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
15656: LD_VAR 0 2
15660: PUSH
15661: LD_EXP 23
15665: EQUAL
15666: PUSH
15667: LD_VAR 0 1
15671: PUSH
15672: LD_INT 11
15674: EQUAL
15675: AND
15676: PUSH
15677: LD_EXP 21
15681: AND
15682: IFFALSE 15688
// IbrahimQuery ;
15684: CALL 14060 0 0
// end ;
15688: PPOPN 2
15690: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin if oldId in usAttackers then
15691: LD_VAR 0 2
15695: PUSH
15696: LD_EXP 42
15700: IN
15701: IFFALSE 15719
// usAttackers := usAttackers diff oldId ;
15703: LD_ADDR_EXP 42
15707: PUSH
15708: LD_EXP 42
15712: PUSH
15713: LD_VAR 0 2
15717: DIFF
15718: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
15719: LD_VAR 0 3
15723: PUSH
15724: LD_INT 4
15726: EQUAL
15727: PUSH
15728: LD_EXP 15
15732: NOT
15733: AND
15734: IFFALSE 15744
// firstConvoyDestroyed := true ;
15736: LD_ADDR_EXP 15
15740: PUSH
15741: LD_INT 1
15743: ST_TO_ADDR
// if GetWeapon ( oldId ) = us_cargo_bay and GetCargo ( oldId , mat_cans ) = 0 then
15744: LD_VAR 0 2
15748: PPUSH
15749: CALL_OW 264
15753: PUSH
15754: LD_INT 12
15756: EQUAL
15757: PUSH
15758: LD_VAR 0 2
15762: PPUSH
15763: LD_INT 1
15765: PPUSH
15766: CALL_OW 289
15770: PUSH
15771: LD_INT 0
15773: EQUAL
15774: AND
15775: IFFALSE 15781
// EmptyCargoDialog ;
15777: CALL 12909 0 0
// end ;
15781: PPOPN 4
15783: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
15784: LD_VAR 0 1
15788: PUSH
15789: LD_INT 2
15791: EQUAL
15792: PUSH
15793: LD_VAR 0 2
15797: PUSH
15798: LD_INT 5
15800: EQUAL
15801: AND
15802: IFFALSE 15811
// YouLost ( Attack ) ;
15804: LD_STRING Attack
15806: PPUSH
15807: CALL_OW 104
// end ;
15811: PPOPN 2
15813: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 then
15814: LD_VAR 0 1
15818: PPUSH
15819: CALL_OW 255
15823: PUSH
15824: LD_INT 1
15826: EQUAL
15827: IFFALSE 15961
// begin if GetBType ( b ) = b_lab then
15829: LD_VAR 0 1
15833: PPUSH
15834: CALL_OW 266
15838: PUSH
15839: LD_INT 6
15841: EQUAL
15842: IFFALSE 15882
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
15844: LD_EXP 39
15848: PPUSH
15849: LD_INT 25
15851: PUSH
15852: LD_INT 4
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: PPUSH
15859: CALL_OW 72
15863: PPUSH
15864: LD_VAR 0 1
15868: PPUSH
15869: CALL_OW 120
// AmLabResearch ( b ) ;
15873: LD_VAR 0 1
15877: PPUSH
15878: CALL 4747 0 1
// end ; if GetBType ( b ) = b_armoury then
15882: LD_VAR 0 1
15886: PPUSH
15887: CALL_OW 266
15891: PUSH
15892: LD_INT 4
15894: EQUAL
15895: IFFALSE 15943
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
15897: LD_EXP 39
15901: PPUSH
15902: LD_INT 25
15904: PUSH
15905: LD_INT 1
15907: PUSH
15908: EMPTY
15909: LIST
15910: LIST
15911: PUSH
15912: LD_INT 3
15914: PUSH
15915: LD_INT 54
15917: PUSH
15918: EMPTY
15919: LIST
15920: PUSH
15921: EMPTY
15922: LIST
15923: LIST
15924: PUSH
15925: EMPTY
15926: LIST
15927: LIST
15928: PPUSH
15929: CALL_OW 72
15933: PPUSH
15934: LD_VAR 0 1
15938: PPUSH
15939: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
15943: LD_ADDR_EXP 41
15947: PUSH
15948: LD_EXP 41
15952: PPUSH
15953: LD_INT 1
15955: PPUSH
15956: CALL_OW 3
15960: ST_TO_ADDR
// end ; end ;
15961: PPOPN 1
15963: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
15964: LD_VAR 0 1
15968: PPUSH
15969: CALL_OW 255
15973: PUSH
15974: LD_INT 2
15976: EQUAL
15977: IFFALSE 15993
// vehCounter := vehCounter + 1 ;
15979: LD_ADDR_EXP 18
15983: PUSH
15984: LD_EXP 18
15988: PUSH
15989: LD_INT 1
15991: PLUS
15992: ST_TO_ADDR
// end ;
15993: PPOPN 2
15995: END
// on SailEvent ( event ) do begin if event = eventAttack then
15996: LD_VAR 0 1
16000: PUSH
16001: LD_EXP 20
16005: EQUAL
16006: IFFALSE 16012
// AmericanAttack ;
16008: CALL 6012 0 0
// end ; end_of_file
16012: PPOPN 1
16014: END
// every 0 0$40 + 0 0$10 trigger tick <= [ 3 3$00 , 2 2$00 , 1 1$30 ] [ Difficulty ] do
16015: LD_OWVAR 1
16019: PUSH
16020: LD_INT 6300
16022: PUSH
16023: LD_INT 4200
16025: PUSH
16026: LD_INT 3150
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: LIST
16033: PUSH
16034: LD_OWVAR 67
16038: ARRAY
16039: LESSEQUAL
16040: IFFALSE 16067
16042: GO 16044
16044: DISABLE
// begin enable ;
16045: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
16046: LD_INT 1
16048: PPUSH
16049: LD_INT 5
16051: PPUSH
16052: CALL_OW 12
16056: PPUSH
16057: LD_INT 9
16059: PPUSH
16060: LD_INT 1
16062: PPUSH
16063: CALL_OW 55
// end ;
16067: END
// every 1 1$30 + 0 0$20 trigger americanBaseCaptured and tick <= [ 25 25$00 , 20 20$00 , 18 18$00 ] [ Difficulty ] do
16068: LD_EXP 6
16072: PUSH
16073: LD_OWVAR 1
16077: PUSH
16078: LD_INT 52500
16080: PUSH
16081: LD_INT 42000
16083: PUSH
16084: LD_INT 37800
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: LIST
16091: PUSH
16092: LD_OWVAR 67
16096: ARRAY
16097: LESSEQUAL
16098: AND
16099: IFFALSE 16126
16101: GO 16103
16103: DISABLE
// begin enable ;
16104: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
16105: LD_INT 1
16107: PPUSH
16108: LD_INT 5
16110: PPUSH
16111: CALL_OW 12
16115: PPUSH
16116: LD_INT 9
16118: PPUSH
16119: LD_INT 1
16121: PPUSH
16122: CALL_OW 55
// end ; end_of_file
16126: END
// every 0 0$1 trigger not retreatAllowed and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
16127: LD_EXP 10
16131: NOT
16132: PUSH
16133: LD_EXP 4
16137: AND
16138: PUSH
16139: LD_EXP 12
16143: PUSH
16144: LD_EXP 13
16148: LESSEQUAL
16149: AND
16150: IFFALSE 16230
16152: GO 16154
16154: DISABLE
// begin enable ;
16155: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
16156: LD_ADDR_OWVAR 47
16160: PUSH
16161: LD_STRING #X103-1
16163: PUSH
16164: LD_EXP 12
16168: PUSH
16169: LD_EXP 13
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: LIST
16178: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
16179: LD_ADDR_EXP 12
16183: PUSH
16184: LD_INT 5
16186: PPUSH
16187: CALL_OW 274
16191: PPUSH
16192: LD_INT 1
16194: PPUSH
16195: CALL_OW 275
16199: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
16200: LD_INT 10
16202: PPUSH
16203: LD_INT 1
16205: PPUSH
16206: CALL_OW 287
16210: PUSH
16211: LD_INT 0
16213: EQUAL
16214: IFFALSE 16230
// farmerCratesCounter := farmerCratesCounter - 0 0$1 ;
16216: LD_ADDR_EXP 14
16220: PUSH
16221: LD_EXP 14
16225: PUSH
16226: LD_INT 35
16228: MINUS
16229: ST_TO_ADDR
// end ; end_of_file
16230: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
16231: GO 16233
16233: DISABLE
// begin ru_radar := 98 ;
16234: LD_ADDR_EXP 43
16238: PUSH
16239: LD_INT 98
16241: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
16242: LD_ADDR_EXP 44
16246: PUSH
16247: LD_INT 89
16249: ST_TO_ADDR
// us_hack := 99 ;
16250: LD_ADDR_EXP 45
16254: PUSH
16255: LD_INT 99
16257: ST_TO_ADDR
// us_artillery := 97 ;
16258: LD_ADDR_EXP 46
16262: PUSH
16263: LD_INT 97
16265: ST_TO_ADDR
// ar_bio_bomb := 91 ;
16266: LD_ADDR_EXP 47
16270: PUSH
16271: LD_INT 91
16273: ST_TO_ADDR
// tech_Artillery := 80 ;
16274: LD_ADDR_EXP 48
16278: PUSH
16279: LD_INT 80
16281: ST_TO_ADDR
// tech_RadMat := 81 ;
16282: LD_ADDR_EXP 49
16286: PUSH
16287: LD_INT 81
16289: ST_TO_ADDR
// tech_BasicTools := 82 ;
16290: LD_ADDR_EXP 50
16294: PUSH
16295: LD_INT 82
16297: ST_TO_ADDR
// tech_Cargo := 83 ;
16298: LD_ADDR_EXP 51
16302: PUSH
16303: LD_INT 83
16305: ST_TO_ADDR
// tech_Track := 84 ;
16306: LD_ADDR_EXP 52
16310: PUSH
16311: LD_INT 84
16313: ST_TO_ADDR
// tech_Crane := 85 ;
16314: LD_ADDR_EXP 53
16318: PUSH
16319: LD_INT 85
16321: ST_TO_ADDR
// tech_Bulldozer := 86 ;
16322: LD_ADDR_EXP 54
16326: PUSH
16327: LD_INT 86
16329: ST_TO_ADDR
// tech_Hovercraft := 87 ;
16330: LD_ADDR_EXP 55
16334: PUSH
16335: LD_INT 87
16337: ST_TO_ADDR
// end ;
16338: END
