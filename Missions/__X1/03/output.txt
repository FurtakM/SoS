// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 25 0 0
// PrepareNature ;
   8: CALL 636 0 0
// PrepareArabian ;
  12: CALL 1951 0 0
// PrepareAmerican ;
  16: CALL 4869 0 0
// Action ;
  20: CALL 9405 0 0
// end ;
  24: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// prefix := 02_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 02_
  43: ST_TO_ADDR
// eventAttack := 1 ;
  44: LD_ADDR_EXP 20
  48: PUSH
  49: LD_INT 1
  51: ST_TO_ADDR
// deadCounter := 0 ;
  52: LD_ADDR_EXP 8
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// gameStarted := false ;
  60: LD_ADDR_EXP 3
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// farmerBaseReady := false ;
  68: LD_ADDR_EXP 4
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// americanBaseSpoted := false ;
  76: LD_ADDR_EXP 5
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// americanBaseCaptured := false ;
  84: LD_ADDR_EXP 6
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// americanHasEscaped := false ;
  92: LD_ADDR_EXP 7
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// workshopBuilded := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// retreatAllowed := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// allowConvoys := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// farmerCrates := 0 ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 63000
 147: PUSH
 148: LD_INT 52500
 150: PUSH
 151: LD_INT 46200
 153: PUSH
 154: EMPTY
 155: LIST
 156: LIST
 157: LIST
 158: PUSH
 159: LD_OWVAR 67
 163: ARRAY
 164: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 165: LD_ADDR_EXP 15
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// attackWave := 1 ;
 173: LD_ADDR_EXP 16
 177: PUSH
 178: LD_INT 1
 180: ST_TO_ADDR
// omarCargoCounter := [ 6 , 9 , 12 ] [ Difficulty ] ;
 181: LD_ADDR_EXP 17
 185: PUSH
 186: LD_INT 6
 188: PUSH
 189: LD_INT 9
 191: PUSH
 192: LD_INT 12
 194: PUSH
 195: EMPTY
 196: LIST
 197: LIST
 198: LIST
 199: PUSH
 200: LD_OWVAR 67
 204: ARRAY
 205: ST_TO_ADDR
// vehCounter := 0 ;
 206: LD_ADDR_EXP 18
 210: PUSH
 211: LD_INT 0
 213: ST_TO_ADDR
// convoyCounter := 0 ;
 214: LD_ADDR_EXP 19
 218: PUSH
 219: LD_INT 0
 221: ST_TO_ADDR
// ibrahimInDepot := false ;
 222: LD_ADDR_EXP 21
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// ibrahimIsFree := false ;
 230: LD_ADDR_EXP 22
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// maxConvoys := [ 16 , 15 , 14 ] [ Difficulty ] ;
 238: LD_ADDR_EXP 23
 242: PUSH
 243: LD_INT 16
 245: PUSH
 246: LD_INT 15
 248: PUSH
 249: LD_INT 14
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: PUSH
 257: LD_OWVAR 67
 261: ARRAY
 262: ST_TO_ADDR
// end ; end_of_file
 263: LD_VAR 0 1
 267: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 268: LD_INT 0
 270: PPUSH
 271: PPUSH
// if exist_mode then
 272: LD_VAR 0 2
 276: IFFALSE 301
// unit := CreateCharacter ( prefix & ident ) else
 278: LD_ADDR_VAR 0 5
 282: PUSH
 283: LD_VAR 0 3
 287: PUSH
 288: LD_VAR 0 1
 292: STR
 293: PPUSH
 294: CALL_OW 34
 298: ST_TO_ADDR
 299: GO 316
// unit := NewCharacter ( ident ) ;
 301: LD_ADDR_VAR 0 5
 305: PUSH
 306: LD_VAR 0 1
 310: PPUSH
 311: CALL_OW 25
 315: ST_TO_ADDR
// result := unit ;
 316: LD_ADDR_VAR 0 4
 320: PUSH
 321: LD_VAR 0 5
 325: ST_TO_ADDR
// end ;
 326: LD_VAR 0 4
 330: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 331: LD_INT 0
 333: PPUSH
// uc_side := side ;
 334: LD_ADDR_OWVAR 20
 338: PUSH
 339: LD_VAR 0 1
 343: ST_TO_ADDR
// uc_nation := nation ;
 344: LD_ADDR_OWVAR 21
 348: PUSH
 349: LD_VAR 0 2
 353: ST_TO_ADDR
// vc_chassis := chassis ;
 354: LD_ADDR_OWVAR 37
 358: PUSH
 359: LD_VAR 0 3
 363: ST_TO_ADDR
// vc_engine := engine ;
 364: LD_ADDR_OWVAR 39
 368: PUSH
 369: LD_VAR 0 4
 373: ST_TO_ADDR
// vc_control := control ;
 374: LD_ADDR_OWVAR 38
 378: PUSH
 379: LD_VAR 0 5
 383: ST_TO_ADDR
// vc_weapon := weapon ;
 384: LD_ADDR_OWVAR 40
 388: PUSH
 389: LD_VAR 0 6
 393: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 394: LD_ADDR_OWVAR 41
 398: PUSH
 399: LD_VAR 0 7
 403: ST_TO_ADDR
// result := CreateVehicle ;
 404: LD_ADDR_VAR 0 8
 408: PUSH
 409: CALL_OW 45
 413: ST_TO_ADDR
// end ;
 414: LD_VAR 0 8
 418: RET
// export function SayX ( units , ident ) ; var i ; begin
 419: LD_INT 0
 421: PPUSH
 422: PPUSH
// result := false ;
 423: LD_ADDR_VAR 0 3
 427: PUSH
 428: LD_INT 0
 430: ST_TO_ADDR
// if not units then
 431: LD_VAR 0 1
 435: NOT
 436: IFFALSE 440
// exit ;
 438: GO 494
// for i in units do
 440: LD_ADDR_VAR 0 4
 444: PUSH
 445: LD_VAR 0 1
 449: PUSH
 450: FOR_IN
 451: IFFALSE 492
// if IsOk ( i ) then
 453: LD_VAR 0 4
 457: PPUSH
 458: CALL_OW 302
 462: IFFALSE 490
// begin Say ( i , ident ) ;
 464: LD_VAR 0 4
 468: PPUSH
 469: LD_VAR 0 2
 473: PPUSH
 474: CALL_OW 88
// result := i ;
 478: LD_ADDR_VAR 0 3
 482: PUSH
 483: LD_VAR 0 4
 487: ST_TO_ADDR
// break ;
 488: GO 492
// end ;
 490: GO 450
 492: POP
 493: POP
// end ;
 494: LD_VAR 0 3
 498: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 499: LD_INT 0
 501: PPUSH
 502: PPUSH
// InitUc ;
 503: CALL_OW 18
// InitHc ;
 507: CALL_OW 19
// uc_side := 0 ;
 511: LD_ADDR_OWVAR 20
 515: PUSH
 516: LD_INT 0
 518: ST_TO_ADDR
// uc_nation := 0 ;
 519: LD_ADDR_OWVAR 21
 523: PUSH
 524: LD_INT 0
 526: ST_TO_ADDR
// for i = 1 to amount do
 527: LD_ADDR_VAR 0 4
 531: PUSH
 532: DOUBLE
 533: LD_INT 1
 535: DEC
 536: ST_TO_ADDR
 537: LD_VAR 0 2
 541: PUSH
 542: FOR_TO
 543: IFFALSE 625
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 545: LD_ADDR_OWVAR 29
 549: PUSH
 550: LD_INT 9
 552: PPUSH
 553: LD_INT 12
 555: PPUSH
 556: CALL_OW 12
 560: PUSH
 561: LD_INT 9
 563: PPUSH
 564: LD_INT 12
 566: PPUSH
 567: CALL_OW 12
 571: PUSH
 572: EMPTY
 573: LIST
 574: LIST
 575: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 576: LD_ADDR_OWVAR 35
 580: PUSH
 581: LD_INT 1
 583: NEG
 584: PPUSH
 585: LD_INT 1
 587: PPUSH
 588: CALL_OW 12
 592: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 593: LD_INT 0
 595: PPUSH
 596: LD_INT 12
 598: PPUSH
 599: LD_INT 1
 601: PPUSH
 602: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 606: CALL_OW 44
 610: PPUSH
 611: LD_VAR 0 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL_OW 49
// end ;
 623: GO 542
 625: POP
 626: POP
// InitHc ;
 627: CALL_OW 19
// end ;
 631: LD_VAR 0 3
 635: RET
// export function PrepareNature ; var i ; begin
 636: LD_INT 0
 638: PPUSH
 639: PPUSH
// SpawnApeman ( forest , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
 640: LD_INT 2
 642: PPUSH
 643: LD_INT 4
 645: PUSH
 646: LD_INT 4
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: EMPTY
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: LD_OWVAR 67
 661: ARRAY
 662: PPUSH
 663: CALL 499 0 2
// for i := 1 to 3 do
 667: LD_ADDR_VAR 0 2
 671: PUSH
 672: DOUBLE
 673: LD_INT 1
 675: DEC
 676: ST_TO_ADDR
 677: LD_INT 3
 679: PUSH
 680: FOR_TO
 681: IFFALSE 716
// begin hc_class := 21 ;
 683: LD_ADDR_OWVAR 28
 687: PUSH
 688: LD_INT 21
 690: ST_TO_ADDR
// hc_gallery :=  ;
 691: LD_ADDR_OWVAR 33
 695: PUSH
 696: LD_STRING 
 698: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 699: CALL_OW 44
 703: PPUSH
 704: LD_INT 2
 706: PPUSH
 707: LD_INT 0
 709: PPUSH
 710: CALL_OW 49
// end ;
 714: GO 680
 716: POP
 717: POP
// for i := 1 to 2 do
 718: LD_ADDR_VAR 0 2
 722: PUSH
 723: DOUBLE
 724: LD_INT 1
 726: DEC
 727: ST_TO_ADDR
 728: LD_INT 2
 730: PUSH
 731: FOR_TO
 732: IFFALSE 767
// begin hc_class := 18 ;
 734: LD_ADDR_OWVAR 28
 738: PUSH
 739: LD_INT 18
 741: ST_TO_ADDR
// hc_gallery :=  ;
 742: LD_ADDR_OWVAR 33
 746: PUSH
 747: LD_STRING 
 749: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 750: CALL_OW 44
 754: PPUSH
 755: LD_INT 2
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 49
// end ;
 765: GO 731
 767: POP
 768: POP
// for i := 1 to 2 do
 769: LD_ADDR_VAR 0 2
 773: PUSH
 774: DOUBLE
 775: LD_INT 1
 777: DEC
 778: ST_TO_ADDR
 779: LD_INT 2
 781: PUSH
 782: FOR_TO
 783: IFFALSE 818
// begin hc_class := 13 ;
 785: LD_ADDR_OWVAR 28
 789: PUSH
 790: LD_INT 13
 792: ST_TO_ADDR
// hc_gallery :=  ;
 793: LD_ADDR_OWVAR 33
 797: PUSH
 798: LD_STRING 
 800: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 801: CALL_OW 44
 805: PPUSH
 806: LD_INT 2
 808: PPUSH
 809: LD_INT 0
 811: PPUSH
 812: CALL_OW 49
// end ;
 816: GO 782
 818: POP
 819: POP
// end ;
 820: LD_VAR 0 1
 824: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 825: LD_INT 0
 827: PPUSH
 828: PPUSH
 829: PPUSH
// if not observer or not unit then
 830: LD_VAR 0 1
 834: NOT
 835: PUSH
 836: LD_VAR 0 2
 840: NOT
 841: OR
 842: IFFALSE 846
// exit ;
 844: GO 894
// if not See ( GetSide ( observer ) , unit ) then
 846: LD_VAR 0 1
 850: PPUSH
 851: CALL_OW 255
 855: PPUSH
 856: LD_VAR 0 2
 860: PPUSH
 861: CALL_OW 292
 865: NOT
 866: IFFALSE 870
// exit ;
 868: GO 894
// result := GetDistUnits ( observer , unit ) < 12 ;
 870: LD_ADDR_VAR 0 3
 874: PUSH
 875: LD_VAR 0 1
 879: PPUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 296
 889: PUSH
 890: LD_INT 12
 892: LESS
 893: ST_TO_ADDR
// end ;
 894: LD_VAR 0 3
 898: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 899: LD_INT 0
 901: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 1
 909: ARRAY
 910: PPUSH
 911: LD_VAR 0 2
 915: PUSH
 916: LD_INT 2
 918: ARRAY
 919: PPUSH
 920: CALL_OW 488
 924: PUSH
 925: LD_VAR 0 2
 929: PUSH
 930: LD_INT 1
 932: ARRAY
 933: PPUSH
 934: LD_VAR 0 2
 938: PUSH
 939: LD_INT 2
 941: ARRAY
 942: PPUSH
 943: CALL_OW 428
 947: PUSH
 948: LD_INT 0
 950: EQUAL
 951: AND
 952: IFFALSE 986
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 954: LD_VAR 0 1
 958: PPUSH
 959: LD_VAR 0 2
 963: PUSH
 964: LD_INT 1
 966: ARRAY
 967: PPUSH
 968: LD_VAR 0 2
 972: PUSH
 973: LD_INT 2
 975: ARRAY
 976: PPUSH
 977: LD_VAR 0 3
 981: PPUSH
 982: CALL_OW 48
// end ;
 986: LD_VAR 0 4
 990: RET
// export function Video ( mode ) ; begin
 991: LD_INT 0
 993: PPUSH
// ingame_video = mode ;
 994: LD_ADDR_OWVAR 52
 998: PUSH
 999: LD_VAR 0 1
1003: ST_TO_ADDR
// interface_hidden = mode ;
1004: LD_ADDR_OWVAR 54
1008: PUSH
1009: LD_VAR 0 1
1013: ST_TO_ADDR
// end ;
1014: LD_VAR 0 2
1018: RET
// export function ReverseArray ( array ) ; var i ; begin
1019: LD_INT 0
1021: PPUSH
1022: PPUSH
// if not array then
1023: LD_VAR 0 1
1027: NOT
1028: IFFALSE 1032
// exit ;
1030: GO 1090
// result := [ ] ;
1032: LD_ADDR_VAR 0 2
1036: PUSH
1037: EMPTY
1038: ST_TO_ADDR
// for i := 1 to array do
1039: LD_ADDR_VAR 0 3
1043: PUSH
1044: DOUBLE
1045: LD_INT 1
1047: DEC
1048: ST_TO_ADDR
1049: LD_VAR 0 1
1053: PUSH
1054: FOR_TO
1055: IFFALSE 1088
// result := Insert ( result , 1 , array [ i ] ) ;
1057: LD_ADDR_VAR 0 2
1061: PUSH
1062: LD_VAR 0 2
1066: PPUSH
1067: LD_INT 1
1069: PPUSH
1070: LD_VAR 0 1
1074: PUSH
1075: LD_VAR 0 3
1079: ARRAY
1080: PPUSH
1081: CALL_OW 2
1085: ST_TO_ADDR
1086: GO 1054
1088: POP
1089: POP
// end ;
1090: LD_VAR 0 2
1094: RET
// export function ComExit ( unit ) ; begin
1095: LD_INT 0
1097: PPUSH
// result := IsInUnit ( unit ) ;
1098: LD_ADDR_VAR 0 2
1102: PUSH
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 310
1112: ST_TO_ADDR
// if not result then
1113: LD_VAR 0 2
1117: NOT
1118: IFFALSE 1122
// exit ;
1120: GO 1157
// if GetType ( result ) = unit_vehicle then
1122: LD_VAR 0 2
1126: PPUSH
1127: CALL_OW 247
1131: PUSH
1132: LD_INT 2
1134: EQUAL
1135: IFFALSE 1148
// ComExitVehicle ( unit ) else
1137: LD_VAR 0 1
1141: PPUSH
1142: CALL_OW 121
1146: GO 1157
// ComExitBuilding ( unit ) ;
1148: LD_VAR 0 1
1152: PPUSH
1153: CALL_OW 122
// end ;
1157: LD_VAR 0 2
1161: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1162: LD_INT 0
1164: PPUSH
1165: PPUSH
// if not side or not nation then
1166: LD_VAR 0 1
1170: NOT
1171: PUSH
1172: LD_VAR 0 2
1176: NOT
1177: OR
1178: IFFALSE 1182
// exit ;
1180: GO 1946
// case nation of nation_american :
1182: LD_VAR 0 2
1186: PUSH
1187: LD_INT 1
1189: DOUBLE
1190: EQUAL
1191: IFTRUE 1195
1193: GO 1409
1195: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1196: LD_ADDR_VAR 0 4
1200: PUSH
1201: LD_INT 35
1203: PUSH
1204: LD_INT 45
1206: PUSH
1207: LD_INT 46
1209: PUSH
1210: LD_INT 47
1212: PUSH
1213: LD_INT 82
1215: PUSH
1216: LD_INT 83
1218: PUSH
1219: LD_INT 84
1221: PUSH
1222: LD_INT 85
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: LD_INT 6
1236: PUSH
1237: LD_INT 15
1239: PUSH
1240: LD_INT 16
1242: PUSH
1243: LD_INT 7
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: LD_INT 10
1254: PUSH
1255: LD_INT 14
1257: PUSH
1258: LD_INT 20
1260: PUSH
1261: LD_INT 21
1263: PUSH
1264: LD_INT 22
1266: PUSH
1267: LD_INT 25
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 27
1275: PUSH
1276: LD_INT 36
1278: PUSH
1279: LD_INT 69
1281: PUSH
1282: LD_INT 39
1284: PUSH
1285: LD_INT 34
1287: PUSH
1288: LD_INT 40
1290: PUSH
1291: LD_INT 48
1293: PUSH
1294: LD_INT 49
1296: PUSH
1297: LD_INT 50
1299: PUSH
1300: LD_INT 51
1302: PUSH
1303: LD_INT 52
1305: PUSH
1306: LD_INT 53
1308: PUSH
1309: LD_INT 54
1311: PUSH
1312: LD_INT 55
1314: PUSH
1315: LD_INT 56
1317: PUSH
1318: LD_INT 57
1320: PUSH
1321: LD_INT 58
1323: PUSH
1324: LD_INT 59
1326: PUSH
1327: LD_INT 60
1329: PUSH
1330: LD_INT 61
1332: PUSH
1333: LD_INT 62
1335: PUSH
1336: LD_INT 80
1338: PUSH
1339: LD_INT 82
1341: PUSH
1342: LD_INT 83
1344: PUSH
1345: LD_INT 84
1347: PUSH
1348: LD_INT 85
1350: PUSH
1351: LD_INT 86
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: LIST
1366: LIST
1367: LIST
1368: LIST
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: ST_TO_ADDR
1407: GO 1870
1409: LD_INT 2
1411: DOUBLE
1412: EQUAL
1413: IFTRUE 1417
1415: GO 1639
1417: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1418: LD_ADDR_VAR 0 4
1422: PUSH
1423: LD_INT 35
1425: PUSH
1426: LD_INT 45
1428: PUSH
1429: LD_INT 46
1431: PUSH
1432: LD_INT 47
1434: PUSH
1435: LD_INT 82
1437: PUSH
1438: LD_INT 83
1440: PUSH
1441: LD_INT 84
1443: PUSH
1444: LD_INT 85
1446: PUSH
1447: LD_INT 87
1449: PUSH
1450: LD_INT 70
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 11
1458: PUSH
1459: LD_INT 3
1461: PUSH
1462: LD_INT 4
1464: PUSH
1465: LD_INT 5
1467: PUSH
1468: LD_INT 6
1470: PUSH
1471: LD_INT 15
1473: PUSH
1474: LD_INT 18
1476: PUSH
1477: LD_INT 7
1479: PUSH
1480: LD_INT 17
1482: PUSH
1483: LD_INT 8
1485: PUSH
1486: LD_INT 20
1488: PUSH
1489: LD_INT 21
1491: PUSH
1492: LD_INT 22
1494: PUSH
1495: LD_INT 72
1497: PUSH
1498: LD_INT 26
1500: PUSH
1501: LD_INT 69
1503: PUSH
1504: LD_INT 39
1506: PUSH
1507: LD_INT 40
1509: PUSH
1510: LD_INT 41
1512: PUSH
1513: LD_INT 42
1515: PUSH
1516: LD_INT 43
1518: PUSH
1519: LD_INT 48
1521: PUSH
1522: LD_INT 49
1524: PUSH
1525: LD_INT 50
1527: PUSH
1528: LD_INT 51
1530: PUSH
1531: LD_INT 52
1533: PUSH
1534: LD_INT 53
1536: PUSH
1537: LD_INT 54
1539: PUSH
1540: LD_INT 55
1542: PUSH
1543: LD_INT 56
1545: PUSH
1546: LD_INT 60
1548: PUSH
1549: LD_INT 61
1551: PUSH
1552: LD_INT 62
1554: PUSH
1555: LD_INT 66
1557: PUSH
1558: LD_INT 67
1560: PUSH
1561: LD_INT 68
1563: PUSH
1564: LD_INT 81
1566: PUSH
1567: LD_INT 82
1569: PUSH
1570: LD_INT 83
1572: PUSH
1573: LD_INT 84
1575: PUSH
1576: LD_INT 85
1578: PUSH
1579: LD_INT 87
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: LIST
1588: LIST
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: LIST
1594: LIST
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: LIST
1610: LIST
1611: LIST
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: LIST
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: ST_TO_ADDR
1637: GO 1870
1639: LD_INT 3
1641: DOUBLE
1642: EQUAL
1643: IFTRUE 1647
1645: GO 1869
1647: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1648: LD_ADDR_VAR 0 4
1652: PUSH
1653: LD_INT 46
1655: PUSH
1656: LD_INT 47
1658: PUSH
1659: LD_INT 1
1661: PUSH
1662: LD_INT 2
1664: PUSH
1665: LD_INT 82
1667: PUSH
1668: LD_INT 83
1670: PUSH
1671: LD_INT 84
1673: PUSH
1674: LD_INT 85
1676: PUSH
1677: LD_INT 86
1679: PUSH
1680: LD_INT 11
1682: PUSH
1683: LD_INT 9
1685: PUSH
1686: LD_INT 20
1688: PUSH
1689: LD_INT 19
1691: PUSH
1692: LD_INT 21
1694: PUSH
1695: LD_INT 24
1697: PUSH
1698: LD_INT 22
1700: PUSH
1701: LD_INT 25
1703: PUSH
1704: LD_INT 28
1706: PUSH
1707: LD_INT 29
1709: PUSH
1710: LD_INT 30
1712: PUSH
1713: LD_INT 31
1715: PUSH
1716: LD_INT 37
1718: PUSH
1719: LD_INT 38
1721: PUSH
1722: LD_INT 32
1724: PUSH
1725: LD_INT 27
1727: PUSH
1728: LD_INT 33
1730: PUSH
1731: LD_INT 69
1733: PUSH
1734: LD_INT 39
1736: PUSH
1737: LD_INT 34
1739: PUSH
1740: LD_INT 40
1742: PUSH
1743: LD_INT 71
1745: PUSH
1746: LD_INT 23
1748: PUSH
1749: LD_INT 44
1751: PUSH
1752: LD_INT 48
1754: PUSH
1755: LD_INT 49
1757: PUSH
1758: LD_INT 50
1760: PUSH
1761: LD_INT 51
1763: PUSH
1764: LD_INT 52
1766: PUSH
1767: LD_INT 53
1769: PUSH
1770: LD_INT 54
1772: PUSH
1773: LD_INT 55
1775: PUSH
1776: LD_INT 56
1778: PUSH
1779: LD_INT 57
1781: PUSH
1782: LD_INT 58
1784: PUSH
1785: LD_INT 59
1787: PUSH
1788: LD_INT 63
1790: PUSH
1791: LD_INT 64
1793: PUSH
1794: LD_INT 65
1796: PUSH
1797: LD_INT 82
1799: PUSH
1800: LD_INT 83
1802: PUSH
1803: LD_INT 84
1805: PUSH
1806: LD_INT 85
1808: PUSH
1809: LD_INT 86
1811: PUSH
1812: EMPTY
1813: LIST
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: ST_TO_ADDR
1867: GO 1870
1869: POP
// if state > - 1 and state < 3 then
1870: LD_VAR 0 3
1874: PUSH
1875: LD_INT 1
1877: NEG
1878: GREATER
1879: PUSH
1880: LD_VAR 0 3
1884: PUSH
1885: LD_INT 3
1887: LESS
1888: AND
1889: IFFALSE 1946
// for i in result do
1891: LD_ADDR_VAR 0 5
1895: PUSH
1896: LD_VAR 0 4
1900: PUSH
1901: FOR_IN
1902: IFFALSE 1944
// if GetTech ( i , side ) <> state then
1904: LD_VAR 0 5
1908: PPUSH
1909: LD_VAR 0 1
1913: PPUSH
1914: CALL_OW 321
1918: PUSH
1919: LD_VAR 0 3
1923: NONEQUAL
1924: IFFALSE 1942
// result := result diff i ;
1926: LD_ADDR_VAR 0 4
1930: PUSH
1931: LD_VAR 0 4
1935: PUSH
1936: LD_VAR 0 5
1940: DIFF
1941: ST_TO_ADDR
1942: GO 1901
1944: POP
1945: POP
// end ; end_of_file
1946: LD_VAR 0 4
1950: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1951: LD_INT 0
1953: PPUSH
1954: PPUSH
1955: PPUSH
1956: PPUSH
// uc_side := 5 ;
1957: LD_ADDR_OWVAR 20
1961: PUSH
1962: LD_INT 5
1964: ST_TO_ADDR
// uc_nation := 2 ;
1965: LD_ADDR_OWVAR 21
1969: PUSH
1970: LD_INT 2
1972: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
1973: LD_INT 5
1975: PPUSH
1976: CALL_OW 274
1980: PPUSH
1981: LD_INT 1
1983: PPUSH
1984: LD_INT 45
1986: PPUSH
1987: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
1991: LD_ADDR_EXP 32
1995: PUSH
1996: LD_STRING Farmer
1998: PPUSH
1999: LD_INT 0
2001: PPUSH
2002: LD_STRING 
2004: PPUSH
2005: CALL 268 0 3
2009: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2010: LD_ADDR_EXP 33
2014: PUSH
2015: LD_STRING Omar
2017: PPUSH
2018: LD_INT 0
2020: PPUSH
2021: LD_STRING 
2023: PPUSH
2024: CALL 268 0 3
2028: ST_TO_ADDR
// omarSquad := [ ] ;
2029: LD_ADDR_EXP 36
2033: PUSH
2034: EMPTY
2035: ST_TO_ADDR
// heikeSquad := [ ] ;
2036: LD_ADDR_EXP 37
2040: PUSH
2041: EMPTY
2042: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2043: LD_ADDR_EXP 38
2047: PUSH
2048: EMPTY
2049: ST_TO_ADDR
// omarCargo := [ ] ;
2050: LD_ADDR_EXP 39
2054: PUSH
2055: EMPTY
2056: ST_TO_ADDR
// for i := 1 to 5 do
2057: LD_ADDR_VAR 0 2
2061: PUSH
2062: DOUBLE
2063: LD_INT 1
2065: DEC
2066: ST_TO_ADDR
2067: LD_INT 5
2069: PUSH
2070: FOR_TO
2071: IFFALSE 2229
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2073: LD_INT 0
2075: PPUSH
2076: LD_INT 1
2078: PUSH
2079: LD_INT 1
2081: PUSH
2082: LD_INT 2
2084: PUSH
2085: LD_INT 1
2087: PUSH
2088: LD_INT 1
2090: PUSH
2091: EMPTY
2092: LIST
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_VAR 0 2
2102: ARRAY
2103: PPUSH
2104: LD_INT 3
2106: PPUSH
2107: CALL_OW 380
// un := CreateHuman ;
2111: LD_ADDR_VAR 0 3
2115: PUSH
2116: CALL_OW 44
2120: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2121: LD_ADDR_EXP 36
2125: PUSH
2126: LD_EXP 36
2130: PUSH
2131: LD_VAR 0 3
2135: UNION
2136: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2137: LD_VAR 0 3
2141: PPUSH
2142: LD_INT 87
2144: PUSH
2145: LD_INT 30
2147: PUSH
2148: EMPTY
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 91
2154: PUSH
2155: LD_INT 32
2157: PUSH
2158: EMPTY
2159: LIST
2160: LIST
2161: PUSH
2162: LD_INT 82
2164: PUSH
2165: LD_INT 15
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: PUSH
2172: LD_INT 79
2174: PUSH
2175: LD_INT 14
2177: PUSH
2178: EMPTY
2179: LIST
2180: LIST
2181: PUSH
2182: LD_INT 82
2184: PUSH
2185: LD_INT 13
2187: PUSH
2188: EMPTY
2189: LIST
2190: LIST
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: PUSH
2199: LD_VAR 0 2
2203: ARRAY
2204: PPUSH
2205: LD_INT 0
2207: PPUSH
2208: CALL 899 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2212: LD_VAR 0 3
2216: PPUSH
2217: LD_INT 93
2219: PPUSH
2220: LD_INT 21
2222: PPUSH
2223: CALL_OW 118
// end ;
2227: GO 2070
2229: POP
2230: POP
// uc_side := 2 ;
2231: LD_ADDR_OWVAR 20
2235: PUSH
2236: LD_INT 2
2238: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2239: LD_ADDR_EXP 24
2243: PUSH
2244: LD_STRING Heike
2246: PPUSH
2247: LD_EXP 1
2251: NOT
2252: PPUSH
2253: LD_EXP 2
2257: PPUSH
2258: CALL 268 0 3
2262: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2263: LD_ADDR_EXP 28
2267: PUSH
2268: LD_STRING Aviradze
2270: PPUSH
2271: LD_EXP 1
2275: NOT
2276: PPUSH
2277: LD_EXP 2
2281: PPUSH
2282: CALL 268 0 3
2286: ST_TO_ADDR
// tmp := [ ] ;
2287: LD_ADDR_VAR 0 4
2291: PUSH
2292: EMPTY
2293: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2294: LD_ADDR_EXP 25
2298: PUSH
2299: LD_STRING Givi
2301: PPUSH
2302: LD_EXP 1
2306: NOT
2307: PPUSH
2308: LD_EXP 2
2312: PPUSH
2313: CALL 268 0 3
2317: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2318: LD_ADDR_EXP 26
2322: PUSH
2323: LD_STRING Mike
2325: PPUSH
2326: LD_EXP 1
2330: NOT
2331: PPUSH
2332: LD_EXP 2
2336: PPUSH
2337: CALL 268 0 3
2341: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2342: LD_ADDR_EXP 27
2346: PUSH
2347: LD_STRING Kamil
2349: PPUSH
2350: LD_EXP 1
2354: NOT
2355: PPUSH
2356: LD_EXP 2
2360: PPUSH
2361: CALL 268 0 3
2365: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2366: LD_ADDR_EXP 29
2370: PUSH
2371: LD_STRING Kaia
2373: PPUSH
2374: LD_EXP 1
2378: NOT
2379: PPUSH
2380: LD_EXP 2
2384: PPUSH
2385: CALL 268 0 3
2389: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2390: LD_ADDR_EXP 30
2394: PUSH
2395: LD_STRING Sophia
2397: PPUSH
2398: LD_EXP 1
2402: NOT
2403: PPUSH
2404: LD_EXP 2
2408: PPUSH
2409: CALL 268 0 3
2413: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2414: LD_ADDR_EXP 31
2418: PUSH
2419: LD_STRING Markov
2421: PPUSH
2422: LD_EXP 1
2426: NOT
2427: PPUSH
2428: LD_EXP 2
2432: PPUSH
2433: CALL 268 0 3
2437: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2438: LD_ADDR_EXP 38
2442: PUSH
2443: LD_STRING 02_others
2445: PPUSH
2446: CALL_OW 31
2450: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2451: LD_ADDR_VAR 0 4
2455: PUSH
2456: LD_EXP 26
2460: PUSH
2461: LD_EXP 27
2465: PUSH
2466: LD_EXP 29
2470: PUSH
2471: LD_EXP 30
2475: PUSH
2476: LD_EXP 31
2480: PUSH
2481: LD_EXP 25
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: LIST
2490: LIST
2491: LIST
2492: LIST
2493: PUSH
2494: LD_EXP 38
2498: ADD
2499: PUSH
2500: LD_INT 0
2502: DIFF
2503: ST_TO_ADDR
// heikeSquad := tmp ;
2504: LD_ADDR_EXP 37
2508: PUSH
2509: LD_VAR 0 4
2513: ST_TO_ADDR
// uc_nation := 0 ;
2514: LD_ADDR_OWVAR 21
2518: PUSH
2519: LD_INT 0
2521: ST_TO_ADDR
// hc_class := class_apeman ;
2522: LD_ADDR_OWVAR 28
2526: PUSH
2527: LD_INT 12
2529: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
2530: LD_ADDR_OWVAR 31
2534: PUSH
2535: LD_INT 0
2537: PUSH
2538: LD_INT 0
2540: PUSH
2541: LD_INT 0
2543: PUSH
2544: LD_INT 0
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: ST_TO_ADDR
// hc_gallery :=  ;
2553: LD_ADDR_OWVAR 33
2557: PUSH
2558: LD_STRING 
2560: ST_TO_ADDR
// hc_name :=  ;
2561: LD_ADDR_OWVAR 26
2565: PUSH
2566: LD_STRING 
2568: ST_TO_ADDR
// tmp := tmp union CreateHuman ;
2569: LD_ADDR_VAR 0 4
2573: PUSH
2574: LD_VAR 0 4
2578: PUSH
2579: CALL_OW 44
2583: UNION
2584: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2585: LD_EXP 24
2589: PPUSH
2590: LD_INT 92
2592: PPUSH
2593: LD_INT 17
2595: PPUSH
2596: LD_INT 0
2598: PPUSH
2599: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2603: LD_EXP 32
2607: PPUSH
2608: LD_INT 95
2610: PPUSH
2611: LD_INT 19
2613: PPUSH
2614: LD_INT 0
2616: PPUSH
2617: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2621: LD_EXP 33
2625: PPUSH
2626: LD_INT 89
2628: PPUSH
2629: LD_INT 25
2631: PPUSH
2632: LD_INT 0
2634: PPUSH
2635: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2639: LD_EXP 28
2643: PPUSH
2644: LD_INT 92
2646: PPUSH
2647: LD_INT 27
2649: PPUSH
2650: LD_INT 0
2652: PPUSH
2653: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2657: LD_EXP 33
2661: PPUSH
2662: LD_EXP 28
2666: PPUSH
2667: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2671: LD_EXP 28
2675: PPUSH
2676: LD_EXP 33
2680: PPUSH
2681: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2685: LD_EXP 24
2689: PUSH
2690: LD_EXP 32
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: PPUSH
2699: LD_EXP 33
2703: PPUSH
2704: CALL_OW 119
// if tmp then
2708: LD_VAR 0 4
2712: IFFALSE 2766
// for i in tmp do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: LD_VAR 0 4
2723: PUSH
2724: FOR_IN
2725: IFFALSE 2764
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2727: LD_VAR 0 2
2731: PPUSH
2732: LD_INT 94
2734: PPUSH
2735: LD_INT 14
2737: PPUSH
2738: LD_INT 4
2740: PPUSH
2741: LD_INT 0
2743: PPUSH
2744: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2748: LD_VAR 0 2
2752: PPUSH
2753: LD_EXP 24
2757: PPUSH
2758: CALL_OW 119
// end ;
2762: GO 2724
2764: POP
2765: POP
// farmerSquad := [ ] ;
2766: LD_ADDR_EXP 35
2770: PUSH
2771: EMPTY
2772: ST_TO_ADDR
// uc_side := 5 ;
2773: LD_ADDR_OWVAR 20
2777: PUSH
2778: LD_INT 5
2780: ST_TO_ADDR
// uc_nation := 2 ;
2781: LD_ADDR_OWVAR 21
2785: PUSH
2786: LD_INT 2
2788: ST_TO_ADDR
// for i := 1 to 4 do
2789: LD_ADDR_VAR 0 2
2793: PUSH
2794: DOUBLE
2795: LD_INT 1
2797: DEC
2798: ST_TO_ADDR
2799: LD_INT 4
2801: PUSH
2802: FOR_TO
2803: IFFALSE 2881
// begin PrepareHuman ( false , 1 , 2 ) ;
2805: LD_INT 0
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_INT 2
2813: PPUSH
2814: CALL_OW 380
// un := CreateHuman ;
2818: LD_ADDR_VAR 0 3
2822: PUSH
2823: CALL_OW 44
2827: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2828: LD_VAR 0 3
2832: PPUSH
2833: LD_INT 102
2835: PPUSH
2836: LD_INT 27
2838: PPUSH
2839: LD_INT 4
2841: PPUSH
2842: LD_INT 0
2844: PPUSH
2845: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2849: LD_ADDR_EXP 35
2853: PUSH
2854: LD_EXP 35
2858: PUSH
2859: LD_VAR 0 3
2863: UNION
2864: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2865: LD_VAR 0 3
2869: PPUSH
2870: LD_EXP 33
2874: PPUSH
2875: CALL_OW 119
// end ;
2879: GO 2802
2881: POP
2882: POP
// PrepareHuman ( false , 2 , 2 ) ;
2883: LD_INT 0
2885: PPUSH
2886: LD_INT 2
2888: PPUSH
2889: LD_INT 2
2891: PPUSH
2892: CALL_OW 380
// un := CreateHuman ;
2896: LD_ADDR_VAR 0 3
2900: PUSH
2901: CALL_OW 44
2905: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2906: LD_VAR 0 3
2910: PPUSH
2911: LD_INT 108
2913: PPUSH
2914: LD_INT 62
2916: PPUSH
2917: LD_INT 2
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2927: LD_ADDR_EXP 35
2931: PUSH
2932: LD_EXP 35
2936: PUSH
2937: LD_VAR 0 3
2941: UNION
2942: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2943: LD_VAR 0 3
2947: PPUSH
2948: LD_EXP 33
2952: PPUSH
2953: CALL_OW 119
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
2957: LD_INT 109
2959: PPUSH
2960: LD_INT 63
2962: PPUSH
2963: LD_INT 2
2965: PPUSH
2966: LD_INT 15
2968: NEG
2969: PPUSH
2970: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
2974: LD_INT 109
2976: PPUSH
2977: LD_INT 63
2979: PPUSH
2980: LD_INT 2
2982: PPUSH
2983: CALL_OW 331
// end ;
2987: LD_VAR 0 1
2991: RET
// export function PrepareIbrahim ( x , y ) ; begin
2992: LD_INT 0
2994: PPUSH
// uc_side := 6 ;
2995: LD_ADDR_OWVAR 20
2999: PUSH
3000: LD_INT 6
3002: ST_TO_ADDR
// uc_nation := 3 ;
3003: LD_ADDR_OWVAR 21
3007: PUSH
3008: LD_INT 3
3010: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3011: LD_ADDR_EXP 34
3015: PUSH
3016: LD_STRING IbrahimRu
3018: PPUSH
3019: LD_INT 0
3021: PPUSH
3022: LD_STRING 
3024: PPUSH
3025: CALL 268 0 3
3029: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3030: LD_EXP 34
3034: PPUSH
3035: LD_VAR 0 1
3039: PPUSH
3040: LD_VAR 0 2
3044: PPUSH
3045: LD_INT 8
3047: PPUSH
3048: LD_INT 1
3050: PPUSH
3051: CALL_OW 50
// end ;
3055: LD_VAR 0 3
3059: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3060: LD_EXP 33
3064: PUSH
3065: LD_EXP 36
3069: ADD
3070: PPUSH
3071: LD_INT 95
3073: PUSH
3074: LD_INT 3
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: PPUSH
3081: CALL_OW 72
3085: IFFALSE 3141
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
// begin enable ;
3093: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3094: LD_ADDR_VAR 0 1
3098: PUSH
3099: LD_EXP 33
3103: PUSH
3104: LD_EXP 36
3108: ADD
3109: PPUSH
3110: LD_INT 95
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL_OW 72
3124: PUSH
3125: FOR_IN
3126: IFFALSE 3139
// RemoveUnit ( i ) ;
3128: LD_VAR 0 1
3132: PPUSH
3133: CALL_OW 64
3137: GO 3125
3139: POP
3140: POP
// end ;
3141: PPOPN 1
3143: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3144: LD_EXP 3
3148: PUSH
3149: LD_EXP 32
3153: PPUSH
3154: LD_INT 4
3156: PPUSH
3157: CALL_OW 308
3161: AND
3162: IFFALSE 3945
3164: GO 3166
3166: DISABLE
3167: LD_INT 0
3169: PPUSH
3170: PPUSH
3171: PPUSH
3172: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3173: LD_EXP 32
3177: PPUSH
3178: LD_INT 110
3180: PPUSH
3181: LD_INT 60
3183: PPUSH
3184: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3188: LD_EXP 32
3192: PPUSH
3193: LD_INT 110
3195: PPUSH
3196: LD_INT 61
3198: PPUSH
3199: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3203: LD_ADDR_VAR 0 2
3207: PUSH
3208: LD_EXP 35
3212: PPUSH
3213: LD_INT 25
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL_OW 72
3227: ST_TO_ADDR
// if tmp then
3228: LD_VAR 0 2
3232: IFFALSE 3326
// begin for i := 1 to 2 do
3234: LD_ADDR_VAR 0 1
3238: PUSH
3239: DOUBLE
3240: LD_INT 1
3242: DEC
3243: ST_TO_ADDR
3244: LD_INT 2
3246: PUSH
3247: FOR_TO
3248: IFFALSE 3324
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3250: LD_VAR 0 2
3254: PUSH
3255: LD_VAR 0 1
3259: ARRAY
3260: PPUSH
3261: LD_INT 5
3263: PPUSH
3264: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3268: LD_VAR 0 2
3272: PUSH
3273: LD_VAR 0 1
3277: ARRAY
3278: PPUSH
3279: LD_INT 2
3281: PPUSH
3282: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3286: LD_VAR 0 2
3290: PUSH
3291: LD_VAR 0 1
3295: ARRAY
3296: PPUSH
3297: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3301: LD_VAR 0 2
3305: PUSH
3306: LD_VAR 0 1
3310: ARRAY
3311: PPUSH
3312: LD_INT 107
3314: PPUSH
3315: LD_INT 66
3317: PPUSH
3318: CALL_OW 171
// end ;
3322: GO 3247
3324: POP
3325: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3326: LD_ADDR_VAR 0 2
3330: PUSH
3331: LD_EXP 35
3335: PPUSH
3336: LD_INT 25
3338: PUSH
3339: LD_INT 2
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PPUSH
3346: CALL_OW 72
3350: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3351: LD_INT 35
3353: PPUSH
3354: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3358: LD_ADDR_VAR 0 2
3362: PUSH
3363: LD_EXP 35
3367: PPUSH
3368: LD_INT 25
3370: PUSH
3371: LD_INT 2
3373: PUSH
3374: EMPTY
3375: LIST
3376: LIST
3377: PPUSH
3378: CALL_OW 72
3382: ST_TO_ADDR
// until tmp ;
3383: LD_VAR 0 2
3387: IFFALSE 3351
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3389: LD_VAR 0 2
3393: PPUSH
3394: LD_INT 31
3396: PPUSH
3397: LD_INT 102
3399: PPUSH
3400: LD_INT 69
3402: PPUSH
3403: LD_INT 2
3405: PPUSH
3406: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3410: LD_INT 35
3412: PPUSH
3413: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3417: LD_EXP 35
3421: PPUSH
3422: LD_INT 3
3424: PUSH
3425: LD_INT 60
3427: PUSH
3428: EMPTY
3429: LIST
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 25
3437: PUSH
3438: LD_INT 2
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: PPUSH
3449: CALL_OW 72
3453: IFFALSE 3410
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3455: LD_ADDR_VAR 0 2
3459: PUSH
3460: LD_EXP 35
3464: PPUSH
3465: LD_INT 25
3467: PUSH
3468: LD_INT 2
3470: PUSH
3471: EMPTY
3472: LIST
3473: LIST
3474: PPUSH
3475: CALL_OW 72
3479: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3480: LD_VAR 0 2
3484: PPUSH
3485: LD_INT 4
3487: PPUSH
3488: LD_INT 116
3490: PPUSH
3491: LD_INT 70
3493: PPUSH
3494: LD_INT 5
3496: PPUSH
3497: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3501: LD_VAR 0 2
3505: PPUSH
3506: LD_INT 31
3508: PPUSH
3509: LD_INT 108
3511: PPUSH
3512: LD_INT 50
3514: PPUSH
3515: LD_INT 2
3517: PPUSH
3518: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3522: LD_INT 35
3524: PPUSH
3525: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3529: LD_INT 22
3531: PUSH
3532: LD_INT 5
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 30
3541: PUSH
3542: LD_INT 4
3544: PUSH
3545: EMPTY
3546: LIST
3547: LIST
3548: PUSH
3549: LD_INT 3
3551: PUSH
3552: LD_INT 57
3554: PUSH
3555: EMPTY
3556: LIST
3557: PUSH
3558: EMPTY
3559: LIST
3560: LIST
3561: PUSH
3562: EMPTY
3563: LIST
3564: LIST
3565: LIST
3566: PPUSH
3567: CALL_OW 69
3571: IFFALSE 3522
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3573: LD_ADDR_VAR 0 3
3577: PUSH
3578: LD_INT 22
3580: PUSH
3581: LD_INT 5
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: PUSH
3588: LD_INT 30
3590: PUSH
3591: LD_INT 4
3593: PUSH
3594: EMPTY
3595: LIST
3596: LIST
3597: PUSH
3598: LD_INT 3
3600: PUSH
3601: LD_INT 57
3603: PUSH
3604: EMPTY
3605: LIST
3606: PUSH
3607: EMPTY
3608: LIST
3609: LIST
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: LIST
3615: PPUSH
3616: CALL_OW 69
3620: PUSH
3621: LD_INT 1
3623: ARRAY
3624: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3625: LD_ADDR_VAR 0 2
3629: PUSH
3630: LD_EXP 35
3634: PPUSH
3635: LD_INT 25
3637: PUSH
3638: LD_INT 1
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PPUSH
3645: CALL_OW 72
3649: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3650: LD_VAR 0 2
3654: PPUSH
3655: LD_VAR 0 3
3659: PPUSH
3660: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3664: LD_INT 35
3666: PPUSH
3667: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3671: LD_INT 22
3673: PUSH
3674: LD_INT 5
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 30
3683: PUSH
3684: LD_INT 31
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: LD_INT 3
3693: PUSH
3694: LD_INT 57
3696: PUSH
3697: EMPTY
3698: LIST
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: EMPTY
3705: LIST
3706: LIST
3707: LIST
3708: PPUSH
3709: CALL_OW 69
3713: PUSH
3714: LD_INT 2
3716: GREATEREQUAL
3717: IFFALSE 3664
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3719: LD_ADDR_VAR 0 2
3723: PUSH
3724: LD_EXP 35
3728: PPUSH
3729: LD_INT 25
3731: PUSH
3732: LD_INT 2
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PPUSH
3739: CALL_OW 72
3743: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3744: LD_VAR 0 2
3748: PUSH
3749: LD_INT 1
3751: ARRAY
3752: PPUSH
3753: LD_INT 5
3755: PPUSH
3756: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3760: LD_VAR 0 2
3764: PUSH
3765: LD_INT 2
3767: ARRAY
3768: PUSH
3769: LD_VAR 0 2
3773: PUSH
3774: LD_INT 3
3776: ARRAY
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PPUSH
3782: LD_VAR 0 3
3786: PPUSH
3787: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3791: LD_VAR 0 2
3795: PUSH
3796: LD_INT 2
3798: ARRAY
3799: PUSH
3800: LD_VAR 0 2
3804: PUSH
3805: LD_INT 3
3807: ARRAY
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PPUSH
3813: LD_INT 1
3815: PPUSH
3816: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3820: LD_VAR 0 2
3824: PUSH
3825: LD_INT 2
3827: ARRAY
3828: PUSH
3829: LD_VAR 0 2
3833: PUSH
3834: LD_INT 3
3836: ARRAY
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: PPUSH
3842: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3846: LD_ADDR_VAR 0 4
3850: PUSH
3851: LD_INT 22
3853: PUSH
3854: LD_INT 5
3856: PUSH
3857: EMPTY
3858: LIST
3859: LIST
3860: PUSH
3861: LD_INT 30
3863: PUSH
3864: LD_INT 31
3866: PUSH
3867: EMPTY
3868: LIST
3869: LIST
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: PPUSH
3875: CALL_OW 69
3879: ST_TO_ADDR
// for i := 1 to 2 do
3880: LD_ADDR_VAR 0 1
3884: PUSH
3885: DOUBLE
3886: LD_INT 1
3888: DEC
3889: ST_TO_ADDR
3890: LD_INT 2
3892: PUSH
3893: FOR_TO
3894: IFFALSE 3928
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3896: LD_VAR 0 2
3900: PUSH
3901: LD_VAR 0 1
3905: PUSH
3906: LD_INT 1
3908: PLUS
3909: ARRAY
3910: PPUSH
3911: LD_VAR 0 4
3915: PUSH
3916: LD_VAR 0 1
3920: ARRAY
3921: PPUSH
3922: CALL_OW 180
3926: GO 3893
3928: POP
3929: POP
// wait ( 1 1$00 ) ;
3930: LD_INT 2100
3932: PPUSH
3933: CALL_OW 67
// farmerBaseReady := true ;
3937: LD_ADDR_EXP 4
3941: PUSH
3942: LD_INT 1
3944: ST_TO_ADDR
// end ;
3945: PPOPN 4
3947: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
3948: LD_EXP 4
3952: PUSH
3953: LD_EXP 10
3957: NOT
3958: AND
3959: IFFALSE 4454
3961: GO 3963
3963: DISABLE
3964: LD_INT 0
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
3970: PPUSH
// begin enable ;
3971: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
3972: LD_ADDR_VAR 0 3
3976: PUSH
3977: LD_EXP 35
3981: PPUSH
3982: LD_INT 25
3984: PUSH
3985: LD_INT 1
3987: PUSH
3988: EMPTY
3989: LIST
3990: LIST
3991: PPUSH
3992: CALL_OW 72
3996: PUSH
3997: LD_EXP 32
4001: ADD
4002: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4003: LD_ADDR_VAR 0 2
4007: PUSH
4008: LD_EXP 35
4012: PPUSH
4013: LD_INT 25
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: EMPTY
4020: LIST
4021: LIST
4022: PPUSH
4023: CALL_OW 72
4027: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4028: LD_ADDR_VAR 0 5
4032: PUSH
4033: LD_INT 22
4035: PUSH
4036: LD_INT 5
4038: PUSH
4039: EMPTY
4040: LIST
4041: LIST
4042: PUSH
4043: LD_INT 21
4045: PUSH
4046: LD_INT 3
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PUSH
4053: LD_INT 3
4055: PUSH
4056: LD_INT 24
4058: PUSH
4059: LD_INT 1000
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: PPUSH
4075: CALL_OW 69
4079: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4080: LD_ADDR_VAR 0 4
4084: PUSH
4085: LD_INT 22
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: PUSH
4095: LD_INT 30
4097: PUSH
4098: LD_INT 4
4100: PUSH
4101: EMPTY
4102: LIST
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PPUSH
4109: CALL_OW 69
4113: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4114: LD_VAR 0 4
4118: PUSH
4119: LD_INT 1
4121: ARRAY
4122: PPUSH
4123: CALL_OW 302
4127: IFFALSE 4191
// for i in sol do
4129: LD_ADDR_VAR 0 1
4133: PUSH
4134: LD_VAR 0 3
4138: PUSH
4139: FOR_IN
4140: IFFALSE 4189
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4142: LD_VAR 0 1
4146: PPUSH
4147: CALL_OW 256
4151: PUSH
4152: LD_INT 999
4154: LESS
4155: PUSH
4156: LD_VAR 0 1
4160: PPUSH
4161: CALL_OW 310
4165: NOT
4166: AND
4167: IFFALSE 4187
// ComEnterUnit ( i , arm [ 1 ] ) ;
4169: LD_VAR 0 1
4173: PPUSH
4174: LD_VAR 0 4
4178: PUSH
4179: LD_INT 1
4181: ARRAY
4182: PPUSH
4183: CALL_OW 120
4187: GO 4139
4189: POP
4190: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4191: LD_VAR 0 2
4195: NOT
4196: PUSH
4197: LD_INT 22
4199: PUSH
4200: LD_INT 1
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 21
4209: PUSH
4210: LD_INT 1
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PPUSH
4221: CALL_OW 69
4225: NOT
4226: AND
4227: IFFALSE 4319
// begin uc_side := 5 ;
4229: LD_ADDR_OWVAR 20
4233: PUSH
4234: LD_INT 5
4236: ST_TO_ADDR
// uc_nation := 2 ;
4237: LD_ADDR_OWVAR 21
4241: PUSH
4242: LD_INT 2
4244: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4245: LD_INT 0
4247: PPUSH
4248: LD_INT 2
4250: PPUSH
4251: LD_INT 2
4253: PPUSH
4254: CALL_OW 380
// eng := CreateHuman ;
4258: LD_ADDR_VAR 0 2
4262: PUSH
4263: CALL_OW 44
4267: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4268: LD_VAR 0 2
4272: PPUSH
4273: LD_INT 102
4275: PPUSH
4276: LD_INT 8
4278: PPUSH
4279: LD_INT 0
4281: PPUSH
4282: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4286: LD_VAR 0 2
4290: PPUSH
4291: LD_INT 110
4293: PPUSH
4294: LD_INT 60
4296: PPUSH
4297: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4301: LD_ADDR_EXP 35
4305: PUSH
4306: LD_EXP 35
4310: PUSH
4311: LD_VAR 0 2
4315: UNION
4316: ST_TO_ADDR
// end else
4317: GO 4454
// begin for i in eng do
4319: LD_ADDR_VAR 0 1
4323: PUSH
4324: LD_VAR 0 2
4328: PUSH
4329: FOR_IN
4330: IFFALSE 4452
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4332: LD_INT 10
4334: PPUSH
4335: LD_INT 1
4337: PPUSH
4338: CALL_OW 287
4342: IFFALSE 4366
// begin if IsInUnit ( i ) then
4344: LD_VAR 0 1
4348: PPUSH
4349: CALL_OW 310
4353: IFFALSE 4364
// ComExitBuilding ( i ) ;
4355: LD_VAR 0 1
4359: PPUSH
4360: CALL_OW 122
// end else
4364: GO 4450
// begin if damagedBuilding then
4366: LD_VAR 0 5
4370: IFFALSE 4414
// begin if IsInUnit ( i ) then
4372: LD_VAR 0 1
4376: PPUSH
4377: CALL_OW 310
4381: IFFALSE 4394
// ComExitBuilding ( i ) else
4383: LD_VAR 0 1
4387: PPUSH
4388: CALL_OW 122
4392: GO 4412
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4394: LD_VAR 0 1
4398: PPUSH
4399: LD_VAR 0 5
4403: PUSH
4404: LD_INT 1
4406: ARRAY
4407: PPUSH
4408: CALL_OW 130
// end else
4412: GO 4450
// if not IsInUnit ( i ) and not HasTask ( i ) then
4414: LD_VAR 0 1
4418: PPUSH
4419: CALL_OW 310
4423: NOT
4424: PUSH
4425: LD_VAR 0 1
4429: PPUSH
4430: CALL_OW 314
4434: NOT
4435: AND
4436: IFFALSE 4450
// ComEnterUnit ( i , arDepot ) ;
4438: LD_VAR 0 1
4442: PPUSH
4443: LD_INT 5
4445: PPUSH
4446: CALL_OW 120
// end ; end ;
4450: GO 4329
4452: POP
4453: POP
// end ; end ;
4454: PPOPN 5
4456: END
// export function StartCargoEvacuation ; begin
4457: LD_INT 0
4459: PPUSH
// while GetResourceType ( GetBase ( arDepot ) , mat_cans ) > 0 and omarCargoCounter > 0 do
4460: LD_INT 5
4462: PPUSH
4463: CALL_OW 274
4467: PPUSH
4468: LD_INT 1
4470: PPUSH
4471: CALL_OW 275
4475: PUSH
4476: LD_INT 0
4478: GREATER
4479: PUSH
4480: LD_EXP 17
4484: PUSH
4485: LD_INT 0
4487: GREATER
4488: AND
4489: IFFALSE 4746
// begin wait ( 1 1$20 ) ;
4491: LD_INT 2800
4493: PPUSH
4494: CALL_OW 67
// omarCargo := PrepareCargo ;
4498: LD_ADDR_EXP 39
4502: PUSH
4503: CALL 4751 0 0
4507: ST_TO_ADDR
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4508: LD_EXP 39
4512: PPUSH
4513: LD_INT 107
4515: PPUSH
4516: LD_INT 59
4518: PPUSH
4519: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4523: LD_INT 35
4525: PPUSH
4526: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4530: LD_EXP 39
4534: PPUSH
4535: LD_INT 107
4537: PPUSH
4538: LD_INT 59
4540: PPUSH
4541: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4545: LD_EXP 39
4549: PPUSH
4550: CALL_OW 302
4554: NOT
4555: PUSH
4556: LD_EXP 39
4560: PPUSH
4561: CALL_OW 301
4565: OR
4566: IFFALSE 4570
// continue ;
4568: GO 4523
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4570: LD_EXP 39
4574: PPUSH
4575: LD_INT 107
4577: PPUSH
4578: LD_INT 59
4580: PPUSH
4581: CALL_OW 307
4585: PUSH
4586: LD_EXP 39
4590: PPUSH
4591: LD_INT 5
4593: PPUSH
4594: CALL_OW 296
4598: PUSH
4599: LD_INT 6
4601: LESS
4602: OR
4603: IFFALSE 4523
// wait ( 0 0$05 ) ;
4605: LD_INT 175
4607: PPUSH
4608: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4612: LD_EXP 39
4616: PPUSH
4617: LD_INT 5
4619: PPUSH
4620: LD_INT 1
4622: PPUSH
4623: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4627: LD_EXP 39
4631: PPUSH
4632: LD_INT 103
4634: PPUSH
4635: LD_INT 9
4637: PPUSH
4638: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4642: LD_INT 35
4644: PPUSH
4645: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4649: LD_EXP 39
4653: PPUSH
4654: LD_INT 103
4656: PPUSH
4657: LD_INT 9
4659: PPUSH
4660: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4664: LD_EXP 39
4668: PPUSH
4669: CALL_OW 302
4673: NOT
4674: PUSH
4675: LD_EXP 39
4679: PPUSH
4680: CALL_OW 301
4684: OR
4685: IFFALSE 4689
// continue ;
4687: GO 4642
// until IsInArea ( omarCargo , northRoad ) and GetCargo ( omarCargo , mat_cans ) > 0 ;
4689: LD_EXP 39
4693: PPUSH
4694: LD_INT 3
4696: PPUSH
4697: CALL_OW 308
4701: PUSH
4702: LD_EXP 39
4706: PPUSH
4707: LD_INT 1
4709: PPUSH
4710: CALL_OW 289
4714: PUSH
4715: LD_INT 0
4717: GREATER
4718: AND
4719: IFFALSE 4642
// RemoveUnit ( omarCargo ) ;
4721: LD_EXP 39
4725: PPUSH
4726: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4730: LD_ADDR_EXP 17
4734: PUSH
4735: LD_EXP 17
4739: PUSH
4740: LD_INT 1
4742: MINUS
4743: ST_TO_ADDR
// end ;
4744: GO 4460
// end ;
4746: LD_VAR 0 1
4750: RET
// export function PrepareCargo ; var un , veh ; begin
4751: LD_INT 0
4753: PPUSH
4754: PPUSH
4755: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4756: LD_ADDR_VAR 0 3
4760: PUSH
4761: LD_INT 5
4763: PPUSH
4764: LD_INT 2
4766: PPUSH
4767: LD_INT 13
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 32
4778: PPUSH
4779: LD_INT 80
4781: PPUSH
4782: CALL 331 0 7
4786: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4787: LD_VAR 0 3
4791: PPUSH
4792: LD_INT 4
4794: PPUSH
4795: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4799: LD_VAR 0 3
4803: PPUSH
4804: LD_INT 101
4806: PPUSH
4807: LD_INT 8
4809: PPUSH
4810: LD_INT 0
4812: PPUSH
4813: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4817: LD_INT 0
4819: PPUSH
4820: LD_INT 3
4822: PPUSH
4823: LD_INT 2
4825: PPUSH
4826: CALL_OW 380
// un := CreateHuman ;
4830: LD_ADDR_VAR 0 2
4834: PUSH
4835: CALL_OW 44
4839: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4840: LD_VAR 0 2
4844: PPUSH
4845: LD_VAR 0 3
4849: PPUSH
4850: CALL_OW 52
// result := veh ;
4854: LD_ADDR_VAR 0 1
4858: PUSH
4859: LD_VAR 0 3
4863: ST_TO_ADDR
// end ; end_of_file
4864: LD_VAR 0 1
4868: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
4869: LD_INT 0
4871: PPUSH
4872: PPUSH
4873: PPUSH
// usForces := [ ] ;
4874: LD_ADDR_EXP 40
4878: PUSH
4879: EMPTY
4880: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
4881: LD_ADDR_EXP 42
4885: PUSH
4886: LD_INT 6
4888: PUSH
4889: LD_INT 32
4891: PUSH
4892: LD_INT 27
4894: PUSH
4895: LD_INT 1
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 4
4906: PUSH
4907: LD_INT 43
4909: PUSH
4910: LD_INT 24
4912: PUSH
4913: LD_INT 5
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: PUSH
4922: LD_INT 27
4924: PUSH
4925: LD_INT 29
4927: PUSH
4928: LD_INT 21
4930: PUSH
4931: LD_INT 0
4933: PUSH
4934: EMPTY
4935: LIST
4936: LIST
4937: LIST
4938: LIST
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
4945: LD_INT 11
4947: PPUSH
4948: CALL_OW 274
4952: PPUSH
4953: LD_INT 1
4955: PPUSH
4956: LD_INT 150
4958: PUSH
4959: LD_INT 120
4961: PUSH
4962: LD_INT 100
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: LIST
4969: PUSH
4970: LD_OWVAR 67
4974: ARRAY
4975: PPUSH
4976: CALL_OW 277
// if Difficulty = 1 then
4980: LD_OWVAR 67
4984: PUSH
4985: LD_INT 1
4987: EQUAL
4988: IFFALSE 4997
// RemoveUnit ( hillBun ) ;
4990: LD_INT 14
4992: PPUSH
4993: CALL_OW 64
// uc_side := 1 ;
4997: LD_ADDR_OWVAR 20
5001: PUSH
5002: LD_INT 1
5004: ST_TO_ADDR
// uc_nation := 1 ;
5005: LD_ADDR_OWVAR 21
5009: PUSH
5010: LD_INT 1
5012: ST_TO_ADDR
// hc_gallery :=  ;
5013: LD_ADDR_OWVAR 33
5017: PUSH
5018: LD_STRING 
5020: ST_TO_ADDR
// hc_name :=  ;
5021: LD_ADDR_OWVAR 26
5025: PUSH
5026: LD_STRING 
5028: ST_TO_ADDR
// hc_importance := 0 ;
5029: LD_ADDR_OWVAR 32
5033: PUSH
5034: LD_INT 0
5036: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5037: LD_INT 1
5039: PPUSH
5040: LD_INT 1
5042: PPUSH
5043: LD_INT 3
5045: PPUSH
5046: CALL_OW 380
// usCommander := CreateHuman ;
5050: LD_ADDR_EXP 41
5054: PUSH
5055: CALL_OW 44
5059: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5060: LD_EXP 41
5064: PPUSH
5065: LD_INT 11
5067: PPUSH
5068: CALL_OW 52
// if hillBun then
5072: LD_INT 14
5074: IFFALSE 5156
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5076: LD_INT 0
5078: PPUSH
5079: LD_INT 1
5081: PPUSH
5082: LD_INT 1
5084: PUSH
5085: LD_INT 2
5087: PUSH
5088: LD_INT 3
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: LIST
5095: PUSH
5096: LD_OWVAR 67
5100: ARRAY
5101: PPUSH
5102: CALL_OW 380
// un := CreateHuman ;
5106: LD_ADDR_VAR 0 3
5110: PUSH
5111: CALL_OW 44
5115: ST_TO_ADDR
// usForces := usForces union un ;
5116: LD_ADDR_EXP 40
5120: PUSH
5121: LD_EXP 40
5125: PUSH
5126: LD_VAR 0 3
5130: UNION
5131: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5132: LD_VAR 0 3
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5144: LD_VAR 0 3
5148: PPUSH
5149: LD_INT 14
5151: PPUSH
5152: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5156: LD_ADDR_VAR 0 2
5160: PUSH
5161: DOUBLE
5162: LD_INT 1
5164: DEC
5165: ST_TO_ADDR
5166: LD_INT 2
5168: PUSH
5169: LD_INT 3
5171: PUSH
5172: LD_INT 4
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: LD_OWVAR 67
5184: ARRAY
5185: PUSH
5186: FOR_TO
5187: IFFALSE 5329
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5189: LD_INT 0
5191: PPUSH
5192: LD_INT 1
5194: PPUSH
5195: LD_INT 1
5197: PUSH
5198: LD_INT 2
5200: PUSH
5201: LD_INT 3
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: LIST
5208: PUSH
5209: LD_OWVAR 67
5213: ARRAY
5214: PPUSH
5215: CALL_OW 380
// un := CreateHuman ;
5219: LD_ADDR_VAR 0 3
5223: PUSH
5224: CALL_OW 44
5228: ST_TO_ADDR
// usForces := usForces union un ;
5229: LD_ADDR_EXP 40
5233: PUSH
5234: LD_EXP 40
5238: PUSH
5239: LD_VAR 0 3
5243: UNION
5244: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5245: LD_VAR 0 3
5249: PPUSH
5250: LD_INT 39
5252: PPUSH
5253: LD_INT 24
5255: PPUSH
5256: LD_INT 4
5258: PPUSH
5259: LD_INT 0
5261: PPUSH
5262: CALL_OW 50
// if i < 3 then
5266: LD_VAR 0 2
5270: PUSH
5271: LD_INT 3
5273: LESS
5274: IFFALSE 5327
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5276: LD_VAR 0 3
5280: PPUSH
5281: LD_INT 22
5283: PUSH
5284: LD_INT 1
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: LD_INT 58
5293: PUSH
5294: EMPTY
5295: LIST
5296: PUSH
5297: LD_INT 30
5299: PUSH
5300: LD_INT 31
5302: PUSH
5303: EMPTY
5304: LIST
5305: LIST
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 69
5316: PUSH
5317: LD_VAR 0 2
5321: ARRAY
5322: PPUSH
5323: CALL_OW 120
// end ;
5327: GO 5186
5329: POP
5330: POP
// for i := 1 to 2 do
5331: LD_ADDR_VAR 0 2
5335: PUSH
5336: DOUBLE
5337: LD_INT 1
5339: DEC
5340: ST_TO_ADDR
5341: LD_INT 2
5343: PUSH
5344: FOR_TO
5345: IFFALSE 5409
// begin PrepareHuman ( false , 2 , 2 ) ;
5347: LD_INT 0
5349: PPUSH
5350: LD_INT 2
5352: PPUSH
5353: LD_INT 2
5355: PPUSH
5356: CALL_OW 380
// un := CreateHuman ;
5360: LD_ADDR_VAR 0 3
5364: PUSH
5365: CALL_OW 44
5369: ST_TO_ADDR
// usForces := usForces union un ;
5370: LD_ADDR_EXP 40
5374: PUSH
5375: LD_EXP 40
5379: PUSH
5380: LD_VAR 0 3
5384: UNION
5385: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5386: LD_VAR 0 3
5390: PPUSH
5391: LD_INT 39
5393: PPUSH
5394: LD_INT 24
5396: PPUSH
5397: LD_INT 4
5399: PPUSH
5400: LD_INT 0
5402: PPUSH
5403: CALL_OW 50
// end ;
5407: GO 5344
5409: POP
5410: POP
// PrepareHuman ( false , 4 , 1 ) ;
5411: LD_INT 0
5413: PPUSH
5414: LD_INT 4
5416: PPUSH
5417: LD_INT 1
5419: PPUSH
5420: CALL_OW 380
// un := CreateHuman ;
5424: LD_ADDR_VAR 0 3
5428: PUSH
5429: CALL_OW 44
5433: ST_TO_ADDR
// usForces := usForces union un ;
5434: LD_ADDR_EXP 40
5438: PUSH
5439: LD_EXP 40
5443: PUSH
5444: LD_VAR 0 3
5448: UNION
5449: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5450: LD_VAR 0 3
5454: PPUSH
5455: LD_INT 39
5457: PPUSH
5458: LD_INT 24
5460: PPUSH
5461: LD_INT 4
5463: PPUSH
5464: LD_INT 0
5466: PPUSH
5467: CALL_OW 50
// end ;
5471: LD_VAR 0 1
5475: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
5476: LD_EXP 40
5480: PUSH
5481: LD_EXP 6
5485: NOT
5486: AND
5487: IFFALSE 5918
5489: GO 5491
5491: DISABLE
5492: LD_INT 0
5494: PPUSH
5495: PPUSH
5496: PPUSH
5497: PPUSH
5498: PPUSH
// begin enable ;
5499: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5500: LD_ADDR_VAR 0 3
5504: PUSH
5505: LD_EXP 40
5509: PPUSH
5510: LD_INT 25
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL_OW 72
5524: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5525: LD_ADDR_VAR 0 4
5529: PUSH
5530: LD_EXP 40
5534: PPUSH
5535: LD_INT 25
5537: PUSH
5538: LD_INT 1
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PPUSH
5545: CALL_OW 72
5549: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5550: LD_ADDR_VAR 0 5
5554: PUSH
5555: LD_EXP 40
5559: PPUSH
5560: LD_INT 25
5562: PUSH
5563: LD_INT 4
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PPUSH
5570: CALL_OW 72
5574: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5575: LD_INT 7
5577: PPUSH
5578: LD_INT 22
5580: PUSH
5581: LD_INT 2
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PPUSH
5588: CALL_OW 70
5592: PUSH
5593: LD_INT 1
5595: EQUAL
5596: IFFALSE 5672
// for i in sol do
5598: LD_ADDR_VAR 0 1
5602: PUSH
5603: LD_VAR 0 4
5607: PUSH
5608: FOR_IN
5609: IFFALSE 5670
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5611: LD_VAR 0 1
5615: PPUSH
5616: CALL_OW 310
5620: NOT
5621: PUSH
5622: LD_VAR 0 1
5626: PPUSH
5627: CALL_OW 310
5631: PPUSH
5632: CALL_OW 266
5636: PUSH
5637: LD_INT 4
5639: EQUAL
5640: NOT
5641: OR
5642: IFFALSE 5668
// begin ComExitBuilding ( i ) ;
5644: LD_VAR 0 1
5648: PPUSH
5649: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5653: LD_VAR 0 1
5657: PPUSH
5658: LD_INT 37
5660: PPUSH
5661: LD_INT 23
5663: PPUSH
5664: CALL_OW 174
// end ;
5668: GO 5608
5670: POP
5671: POP
// if eng then
5672: LD_VAR 0 3
5676: IFFALSE 5918
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5678: LD_ADDR_VAR 0 2
5682: PUSH
5683: LD_INT 22
5685: PUSH
5686: LD_INT 1
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: PUSH
5693: LD_INT 95
5695: PUSH
5696: LD_INT 7
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: PUSH
5703: LD_INT 21
5705: PUSH
5706: LD_INT 3
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 3
5715: PUSH
5716: LD_INT 24
5718: PUSH
5719: LD_INT 1000
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL_OW 69
5740: ST_TO_ADDR
// if b then
5741: LD_VAR 0 2
5745: IFFALSE 5776
// begin ComExitBuilding ( eng ) ;
5747: LD_VAR 0 3
5751: PPUSH
5752: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5756: LD_VAR 0 3
5760: PPUSH
5761: LD_VAR 0 2
5765: PUSH
5766: LD_INT 1
5768: ARRAY
5769: PPUSH
5770: CALL_OW 190
// end else
5774: GO 5918
// begin for i in eng do
5776: LD_ADDR_VAR 0 1
5780: PUSH
5781: LD_VAR 0 3
5785: PUSH
5786: FOR_IN
5787: IFFALSE 5916
// if not HasTask ( i ) then
5789: LD_VAR 0 1
5793: PPUSH
5794: CALL_OW 314
5798: NOT
5799: IFFALSE 5914
// begin if americanBuildList then
5801: LD_EXP 42
5805: IFFALSE 5890
// begin if IsInUnit ( i ) then
5807: LD_VAR 0 1
5811: PPUSH
5812: CALL_OW 310
5816: IFFALSE 5827
// ComExitBuilding ( i ) ;
5818: LD_VAR 0 1
5822: PPUSH
5823: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5827: LD_VAR 0 1
5831: PPUSH
5832: LD_EXP 42
5836: PUSH
5837: LD_INT 1
5839: ARRAY
5840: PUSH
5841: LD_INT 1
5843: ARRAY
5844: PPUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_INT 2
5856: ARRAY
5857: PPUSH
5858: LD_EXP 42
5862: PUSH
5863: LD_INT 1
5865: ARRAY
5866: PUSH
5867: LD_INT 3
5869: ARRAY
5870: PPUSH
5871: LD_EXP 42
5875: PUSH
5876: LD_INT 1
5878: ARRAY
5879: PUSH
5880: LD_INT 4
5882: ARRAY
5883: PPUSH
5884: CALL_OW 205
// end else
5888: GO 5914
// if not IsInUnit ( i ) then
5890: LD_VAR 0 1
5894: PPUSH
5895: CALL_OW 310
5899: NOT
5900: IFFALSE 5914
// ComEnterUnit ( i , usDepot ) ;
5902: LD_VAR 0 1
5906: PPUSH
5907: LD_INT 11
5909: PPUSH
5910: CALL_OW 120
// end ;
5914: GO 5786
5916: POP
5917: POP
// end ; end ; end ;
5918: PPOPN 5
5920: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
5921: LD_INT 0
5923: PPUSH
5924: PPUSH
5925: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
5926: LD_ADDR_VAR 0 3
5930: PUSH
5931: LD_INT 35
5933: PUSH
5934: LD_INT 45
5936: PUSH
5937: LD_INT 48
5939: PUSH
5940: LD_EXP 51
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: ST_TO_ADDR
// for i in tech do
5951: LD_ADDR_VAR 0 4
5955: PUSH
5956: LD_VAR 0 3
5960: PUSH
5961: FOR_IN
5962: IFFALSE 5980
// AddComResearch ( lab , i ) ;
5964: LD_VAR 0 1
5968: PPUSH
5969: LD_VAR 0 4
5973: PPUSH
5974: CALL_OW 184
5978: GO 5961
5980: POP
5981: POP
// end ;
5982: LD_VAR 0 2
5986: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
5987: LD_EXP 11
5991: PUSH
5992: LD_EXP 19
5996: PUSH
5997: LD_EXP 23
6001: LESSEQUAL
6002: AND
6003: IFFALSE 6028
6005: GO 6007
6007: DISABLE
// begin enable ;
6008: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6009: LD_INT 35
6011: PPUSH
6012: LD_INT 2065
6014: PPUSH
6015: CALL_OW 12
6019: PPUSH
6020: CALL_OW 67
// SendConvoy ;
6024: CALL 6126 0 0
// end ;
6028: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6029: LD_EXP 6
6033: PUSH
6034: LD_EXP 15
6038: AND
6039: IFFALSE 6125
6041: GO 6043
6043: DISABLE
// begin if americanHasEscaped then
6044: LD_EXP 7
6048: IFFALSE 6059
// wait ( 3 3$20 ) else
6050: LD_INT 7000
6052: PPUSH
6053: CALL_OW 67
6057: GO 6066
// wait ( 6 6$40 ) ;
6059: LD_INT 14000
6061: PPUSH
6062: CALL_OW 67
// SendAttack ;
6066: CALL 6841 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6070: LD_INT 14000
6072: PUSH
6073: LD_INT 11900
6075: PUSH
6076: LD_INT 9800
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_OWVAR 67
6088: ARRAY
6089: PPUSH
6090: CALL_OW 67
// SendAttack ;
6094: CALL 6841 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6098: LD_EXP 16
6102: PUSH
6103: LD_INT 6
6105: PUSH
6106: LD_INT 7
6108: PUSH
6109: LD_INT 8
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: PUSH
6117: LD_OWVAR 67
6121: ARRAY
6122: LESS
6123: IFFALSE 6070
// end ;
6125: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6126: LD_INT 0
6128: PPUSH
6129: PPUSH
6130: PPUSH
6131: PPUSH
6132: PPUSH
6133: PPUSH
6134: PPUSH
6135: PPUSH
// road := rand ( 1 , 2 ) ;
6136: LD_ADDR_VAR 0 4
6140: PUSH
6141: LD_INT 1
6143: PPUSH
6144: LD_INT 2
6146: PPUSH
6147: CALL_OW 12
6151: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6152: LD_ADDR_VAR 0 8
6156: PUSH
6157: LD_INT 3
6159: PUSH
6160: LD_INT 8
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: PUSH
6167: LD_VAR 0 4
6171: ARRAY
6172: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6173: LD_ADDR_VAR 0 5
6177: PUSH
6178: LD_INT 35
6180: PUSH
6181: LD_INT 66
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 101
6194: PUSH
6195: LD_INT 8
6197: PUSH
6198: LD_INT 4
6200: PUSH
6201: EMPTY
6202: LIST
6203: LIST
6204: LIST
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6210: LD_ADDR_VAR 0 6
6214: PUSH
6215: LD_INT 34
6217: PUSH
6218: LD_INT 67
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: LD_INT 38
6227: PUSH
6228: LD_INT 62
6230: PUSH
6231: EMPTY
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 43
6237: PUSH
6238: LD_INT 54
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 57
6247: PUSH
6248: LD_INT 57
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: PUSH
6255: LD_INT 77
6257: PUSH
6258: LD_INT 71
6260: PUSH
6261: EMPTY
6262: LIST
6263: LIST
6264: PUSH
6265: LD_INT 86
6267: PUSH
6268: LD_INT 60
6270: PUSH
6271: EMPTY
6272: LIST
6273: LIST
6274: PUSH
6275: LD_INT 89
6277: PUSH
6278: LD_INT 35
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PUSH
6285: LD_INT 93
6287: PUSH
6288: LD_INT 17
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: PUSH
6295: LD_INT 97
6297: PUSH
6298: LD_INT 10
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: LD_INT 103
6307: PUSH
6308: LD_INT 9
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: ST_TO_ADDR
// if road = 2 then
6327: LD_VAR 0 4
6331: PUSH
6332: LD_INT 2
6334: EQUAL
6335: IFFALSE 6352
// points := ReverseArray ( points ) ;
6337: LD_ADDR_VAR 0 6
6341: PUSH
6342: LD_VAR 0 6
6346: PPUSH
6347: CALL 1019 0 1
6351: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6352: LD_INT 4
6354: PPUSH
6355: LD_INT 1
6357: PPUSH
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 1
6363: PPUSH
6364: LD_INT 1
6366: PPUSH
6367: LD_INT 12
6369: PPUSH
6370: LD_INT 80
6372: PPUSH
6373: CALL 331 0 7
// veh := CreateVehicle ;
6377: LD_ADDR_VAR 0 3
6381: PUSH
6382: CALL_OW 45
6386: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6387: LD_VAR 0 3
6391: PPUSH
6392: LD_VAR 0 5
6396: PUSH
6397: LD_VAR 0 4
6401: ARRAY
6402: PUSH
6403: LD_INT 3
6405: ARRAY
6406: PPUSH
6407: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6411: LD_VAR 0 3
6415: PPUSH
6416: LD_VAR 0 5
6420: PUSH
6421: LD_VAR 0 4
6425: ARRAY
6426: PUSH
6427: LD_INT 1
6429: ARRAY
6430: PPUSH
6431: LD_VAR 0 5
6435: PUSH
6436: LD_VAR 0 4
6440: ARRAY
6441: PUSH
6442: LD_INT 2
6444: ARRAY
6445: PPUSH
6446: LD_INT 0
6448: PPUSH
6449: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6453: LD_INT 0
6455: PPUSH
6456: LD_INT 1
6458: PPUSH
6459: LD_OWVAR 67
6463: PPUSH
6464: CALL_OW 380
// un := CreateHuman ;
6468: LD_ADDR_VAR 0 2
6472: PUSH
6473: CALL_OW 44
6477: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6478: LD_VAR 0 2
6482: PPUSH
6483: LD_VAR 0 3
6487: PPUSH
6488: CALL_OW 52
// if Prob ( 50 + tick mod 30 ) or convoyCounter < 3 then
6492: LD_INT 50
6494: PUSH
6495: LD_OWVAR 1
6499: PUSH
6500: LD_INT 30
6502: MOD
6503: PLUS
6504: PPUSH
6505: CALL_OW 13
6509: PUSH
6510: LD_EXP 19
6514: PUSH
6515: LD_INT 3
6517: LESS
6518: OR
6519: IFFALSE 6536
// SetCargo ( veh , mat_cans , 100 ) ;
6521: LD_VAR 0 3
6525: PPUSH
6526: LD_INT 1
6528: PPUSH
6529: LD_INT 100
6531: PPUSH
6532: CALL_OW 290
// for i := 2 to points do
6536: LD_ADDR_VAR 0 7
6540: PUSH
6541: DOUBLE
6542: LD_INT 2
6544: DEC
6545: ST_TO_ADDR
6546: LD_VAR 0 6
6550: PUSH
6551: FOR_TO
6552: IFFALSE 6595
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6554: LD_VAR 0 3
6558: PPUSH
6559: LD_VAR 0 6
6563: PUSH
6564: LD_VAR 0 7
6568: ARRAY
6569: PUSH
6570: LD_INT 1
6572: ARRAY
6573: PPUSH
6574: LD_VAR 0 6
6578: PUSH
6579: LD_VAR 0 7
6583: ARRAY
6584: PUSH
6585: LD_INT 2
6587: ARRAY
6588: PPUSH
6589: CALL_OW 171
6593: GO 6551
6595: POP
6596: POP
// convoyCounter := convoyCounter + 1 ;
6597: LD_ADDR_EXP 19
6601: PUSH
6602: LD_EXP 19
6606: PUSH
6607: LD_INT 1
6609: PLUS
6610: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6611: LD_INT 35
6613: PPUSH
6614: CALL_OW 67
// if not HasTask ( veh ) then
6618: LD_VAR 0 3
6622: PPUSH
6623: CALL_OW 314
6627: NOT
6628: IFFALSE 6669
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6630: LD_VAR 0 3
6634: PPUSH
6635: LD_VAR 0 6
6639: PUSH
6640: LD_VAR 0 6
6644: ARRAY
6645: PUSH
6646: LD_INT 1
6648: ARRAY
6649: PPUSH
6650: LD_VAR 0 6
6654: PUSH
6655: LD_VAR 0 6
6659: ARRAY
6660: PUSH
6661: LD_INT 2
6663: ARRAY
6664: PPUSH
6665: CALL_OW 111
// if not IsOk ( veh ) then
6669: LD_VAR 0 3
6673: PPUSH
6674: CALL_OW 302
6678: NOT
6679: IFFALSE 6720
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6681: LD_VAR 0 2
6685: PPUSH
6686: LD_VAR 0 6
6690: PUSH
6691: LD_VAR 0 6
6695: ARRAY
6696: PUSH
6697: LD_INT 1
6699: ARRAY
6700: PPUSH
6701: LD_VAR 0 6
6705: PUSH
6706: LD_VAR 0 6
6710: ARRAY
6711: PUSH
6712: LD_INT 2
6714: ARRAY
6715: PPUSH
6716: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6720: LD_VAR 0 3
6724: PPUSH
6725: LD_VAR 0 8
6729: PPUSH
6730: CALL_OW 308
6734: PUSH
6735: LD_VAR 0 2
6739: PPUSH
6740: LD_VAR 0 8
6744: PPUSH
6745: CALL_OW 308
6749: OR
6750: IFFALSE 6611
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6752: LD_VAR 0 2
6756: PPUSH
6757: CALL_OW 302
6761: PUSH
6762: LD_VAR 0 3
6766: PPUSH
6767: CALL_OW 302
6771: NOT
6772: AND
6773: PUSH
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_VAR 0 8
6783: PPUSH
6784: CALL_OW 308
6788: AND
6789: IFFALSE 6800
// RemoveUnit ( un ) ;
6791: LD_VAR 0 2
6795: PPUSH
6796: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6800: LD_VAR 0 3
6804: PPUSH
6805: LD_VAR 0 8
6809: PPUSH
6810: CALL_OW 308
6814: PUSH
6815: LD_VAR 0 3
6819: PPUSH
6820: CALL_OW 302
6824: AND
6825: IFFALSE 6836
// RemoveUnit ( veh ) ;
6827: LD_VAR 0 3
6831: PPUSH
6832: CALL_OW 64
// end ;
6836: LD_VAR 0 1
6840: RET
// export function SendAttack ; var un , veh , i ; begin
6841: LD_INT 0
6843: PPUSH
6844: PPUSH
6845: PPUSH
6846: PPUSH
// IncomingAttack ;
6847: CALL 15126 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
6851: LD_INT 2100
6853: PPUSH
6854: LD_INT 3500
6856: PPUSH
6857: CALL_OW 12
6861: PPUSH
6862: CALL_OW 67
// for i := 1 to [ 3 , 3 , 4 ] [ Difficulty ] + attackWave div 3 do
6866: LD_ADDR_VAR 0 4
6870: PUSH
6871: DOUBLE
6872: LD_INT 1
6874: DEC
6875: ST_TO_ADDR
6876: LD_INT 3
6878: PUSH
6879: LD_INT 3
6881: PUSH
6882: LD_INT 4
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: LIST
6889: PUSH
6890: LD_OWVAR 67
6894: ARRAY
6895: PUSH
6896: LD_EXP 16
6900: PUSH
6901: LD_INT 3
6903: DIV
6904: PLUS
6905: PUSH
6906: FOR_TO
6907: IFFALSE 7019
// begin uc_side := 1 ;
6909: LD_ADDR_OWVAR 20
6913: PUSH
6914: LD_INT 1
6916: ST_TO_ADDR
// uc_nation := 1 ;
6917: LD_ADDR_OWVAR 21
6921: PUSH
6922: LD_INT 1
6924: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
6925: LD_INT 0
6927: PPUSH
6928: LD_INT 1
6930: PPUSH
6931: LD_INT 2
6933: PUSH
6934: LD_INT 3
6936: PUSH
6937: LD_INT 4
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: PUSH
6945: LD_OWVAR 67
6949: ARRAY
6950: PPUSH
6951: CALL_OW 380
// un := CreateHuman ;
6955: LD_ADDR_VAR 0 2
6959: PUSH
6960: CALL_OW 44
6964: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
6965: LD_VAR 0 2
6969: PPUSH
6970: LD_INT 37
6972: PPUSH
6973: LD_INT 70
6975: PPUSH
6976: LD_INT 3
6978: PPUSH
6979: LD_INT 0
6981: PPUSH
6982: CALL_OW 50
// usAttackers := usAttackers union un ;
6986: LD_ADDR_EXP 43
6990: PUSH
6991: LD_EXP 43
6995: PUSH
6996: LD_VAR 0 2
7000: UNION
7001: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7002: LD_VAR 0 2
7006: PPUSH
7007: LD_INT 40
7009: PPUSH
7010: LD_INT 65
7012: PPUSH
7013: CALL_OW 111
// end ;
7017: GO 6906
7019: POP
7020: POP
// uc_side := 1 ;
7021: LD_ADDR_OWVAR 20
7025: PUSH
7026: LD_INT 1
7028: ST_TO_ADDR
// uc_nation := 1 ;
7029: LD_ADDR_OWVAR 21
7033: PUSH
7034: LD_INT 1
7036: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7037: LD_INT 0
7039: PPUSH
7040: LD_INT 4
7042: PPUSH
7043: LD_INT 2
7045: PPUSH
7046: CALL_OW 380
// un := CreateHuman ;
7050: LD_ADDR_VAR 0 2
7054: PUSH
7055: CALL_OW 44
7059: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7060: LD_VAR 0 2
7064: PPUSH
7065: LD_INT 37
7067: PPUSH
7068: LD_INT 70
7070: PPUSH
7071: LD_INT 3
7073: PPUSH
7074: LD_INT 0
7076: PPUSH
7077: CALL_OW 50
// usAttackers := usAttackers union un ;
7081: LD_ADDR_EXP 43
7085: PUSH
7086: LD_EXP 43
7090: PUSH
7091: LD_VAR 0 2
7095: UNION
7096: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7097: LD_VAR 0 2
7101: PPUSH
7102: LD_INT 40
7104: PPUSH
7105: LD_INT 65
7107: PPUSH
7108: CALL_OW 111
// if attackWave > 1 or Difficulty > 1 then
7112: LD_EXP 16
7116: PUSH
7117: LD_INT 1
7119: GREATER
7120: PUSH
7121: LD_OWVAR 67
7125: PUSH
7126: LD_INT 1
7128: GREATER
7129: OR
7130: IFFALSE 7333
// begin for i := 1 to Difficulty + attackWave div 4 do
7132: LD_ADDR_VAR 0 4
7136: PUSH
7137: DOUBLE
7138: LD_INT 1
7140: DEC
7141: ST_TO_ADDR
7142: LD_OWVAR 67
7146: PUSH
7147: LD_EXP 16
7151: PUSH
7152: LD_INT 4
7154: DIV
7155: PLUS
7156: PUSH
7157: FOR_TO
7158: IFFALSE 7331
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7160: LD_ADDR_VAR 0 3
7164: PUSH
7165: LD_INT 1
7167: PPUSH
7168: LD_INT 1
7170: PPUSH
7171: LD_INT 2
7173: PPUSH
7174: LD_INT 2
7176: PPUSH
7177: LD_INT 1
7179: PPUSH
7180: LD_INT 4
7182: PUSH
7183: LD_INT 3
7185: PUSH
7186: LD_INT 2
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: PUSH
7194: LD_INT 1
7196: PPUSH
7197: LD_INT 3
7199: PPUSH
7200: CALL_OW 12
7204: ARRAY
7205: PPUSH
7206: LD_INT 90
7208: PPUSH
7209: CALL 331 0 7
7213: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7214: LD_VAR 0 3
7218: PPUSH
7219: LD_INT 35
7221: PPUSH
7222: LD_INT 65
7224: PPUSH
7225: LD_INT 0
7227: PPUSH
7228: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7232: LD_INT 0
7234: PPUSH
7235: LD_INT 3
7237: PPUSH
7238: LD_OWVAR 67
7242: PUSH
7243: LD_INT 1
7245: PLUS
7246: PPUSH
7247: CALL_OW 380
// un := CreateHuman ;
7251: LD_ADDR_VAR 0 2
7255: PUSH
7256: CALL_OW 44
7260: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7261: LD_VAR 0 2
7265: PPUSH
7266: LD_VAR 0 3
7270: PPUSH
7271: CALL_OW 52
// usAttackers := usAttackers union un ;
7275: LD_ADDR_EXP 43
7279: PUSH
7280: LD_EXP 43
7284: PUSH
7285: LD_VAR 0 2
7289: UNION
7290: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7291: LD_VAR 0 3
7295: PPUSH
7296: LD_INT 39
7298: PPUSH
7299: LD_INT 60
7301: PPUSH
7302: CALL_OW 111
// wait ( 0 0$2 ) ;
7306: LD_INT 70
7308: PPUSH
7309: CALL_OW 67
// usAttackers := usAttackers union veh ;
7313: LD_ADDR_EXP 43
7317: PUSH
7318: LD_EXP 43
7322: PUSH
7323: LD_VAR 0 3
7327: UNION
7328: ST_TO_ADDR
// end ;
7329: GO 7157
7331: POP
7332: POP
// end ; attackWave := attackWave + 1 ;
7333: LD_ADDR_EXP 16
7337: PUSH
7338: LD_EXP 16
7342: PUSH
7343: LD_INT 1
7345: PLUS
7346: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7347: LD_EXP 20
7351: PPUSH
7352: CALL_OW 427
// end ;
7356: LD_VAR 0 1
7360: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7361: LD_INT 0
7363: PPUSH
7364: PPUSH
7365: PPUSH
7366: PPUSH
7367: PPUSH
7368: PPUSH
7369: PPUSH
7370: PPUSH
7371: PPUSH
7372: PPUSH
7373: PPUSH
// if retreatAllowed then
7374: LD_EXP 10
7378: IFFALSE 7390
// strategy := 2 else
7380: LD_ADDR_VAR 0 5
7384: PUSH
7385: LD_INT 2
7387: ST_TO_ADDR
7388: GO 7406
// strategy := rand ( 0 , 2 ) ;
7390: LD_ADDR_VAR 0 5
7394: PUSH
7395: LD_INT 0
7397: PPUSH
7398: LD_INT 2
7400: PPUSH
7401: CALL_OW 12
7405: ST_TO_ADDR
// attackFormula := [ ] ;
7406: LD_ADDR_VAR 0 6
7410: PUSH
7411: EMPTY
7412: ST_TO_ADDR
// case strategy of 0 :
7413: LD_VAR 0 5
7417: PUSH
7418: LD_INT 0
7420: DOUBLE
7421: EQUAL
7422: IFTRUE 7426
7424: GO 7756
7426: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7427: LD_INT 11
7429: PPUSH
7430: LD_INT 22
7432: PUSH
7433: LD_INT 2
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PUSH
7440: LD_INT 30
7442: PUSH
7443: LD_INT 4
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PPUSH
7454: CALL_OW 70
7458: NOT
7459: IFFALSE 7531
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7461: LD_ADDR_VAR 0 6
7465: PUSH
7466: LD_INT 41
7468: PUSH
7469: LD_INT 34
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: PUSH
7476: EMPTY
7477: LIST
7478: PUSH
7479: LD_INT 53
7481: PUSH
7482: LD_INT 62
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 37
7491: PUSH
7492: LD_INT 63
7494: PUSH
7495: EMPTY
7496: LIST
7497: LIST
7498: PUSH
7499: LD_INT 44
7501: PUSH
7502: LD_INT 45
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 37
7511: PUSH
7512: LD_INT 28
7514: PUSH
7515: EMPTY
7516: LIST
7517: LIST
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: LIST
7527: LIST
7528: ST_TO_ADDR
7529: GO 7754
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7531: LD_INT 12
7533: PPUSH
7534: LD_INT 22
7536: PUSH
7537: LD_INT 2
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: LD_INT 2
7546: PUSH
7547: LD_INT 30
7549: PUSH
7550: LD_INT 4
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 30
7559: PUSH
7560: LD_INT 31
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 30
7569: PUSH
7570: LD_INT 32
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 70
7591: NOT
7592: IFFALSE 7675
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7594: LD_ADDR_VAR 0 6
7598: PUSH
7599: LD_INT 27
7601: PUSH
7602: LD_INT 42
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 27
7611: PUSH
7612: LD_INT 32
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: LD_INT 53
7625: PUSH
7626: LD_INT 62
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: LD_INT 37
7635: PUSH
7636: LD_INT 63
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PUSH
7643: LD_INT 44
7645: PUSH
7646: LD_INT 45
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 37
7655: PUSH
7656: LD_INT 28
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: LIST
7671: LIST
7672: ST_TO_ADDR
7673: GO 7754
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7675: LD_ADDR_VAR 0 6
7679: PUSH
7680: LD_INT 71
7682: PUSH
7683: LD_INT 67
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 54
7692: PUSH
7693: LD_INT 35
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 63
7706: PUSH
7707: LD_INT 40
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: LD_INT 37
7716: PUSH
7717: LD_INT 63
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PUSH
7724: LD_INT 44
7726: PUSH
7727: LD_INT 45
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PUSH
7734: LD_INT 37
7736: PUSH
7737: LD_INT 28
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: PUSH
7744: EMPTY
7745: LIST
7746: LIST
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: ST_TO_ADDR
// end ; 1 :
7754: GO 7959
7756: LD_INT 1
7758: DOUBLE
7759: EQUAL
7760: IFTRUE 7764
7762: GO 7868
7764: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7765: LD_ADDR_VAR 0 6
7769: PUSH
7770: LD_INT 71
7772: PUSH
7773: LD_INT 67
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: PUSH
7780: LD_INT 82
7782: PUSH
7783: LD_INT 23
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 53
7792: PUSH
7793: LD_INT 7
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: LD_INT 43
7802: PUSH
7803: LD_INT 10
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 53
7818: PUSH
7819: LD_INT 62
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 37
7828: PUSH
7829: LD_INT 63
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: LD_INT 44
7838: PUSH
7839: LD_INT 45
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 37
7848: PUSH
7849: LD_INT 28
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: ST_TO_ADDR
7866: GO 7959
7868: LD_INT 2
7870: DOUBLE
7871: EQUAL
7872: IFTRUE 7876
7874: GO 7958
7876: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
7877: LD_ADDR_VAR 0 6
7881: PUSH
7882: LD_INT 90
7884: PUSH
7885: LD_INT 59
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 108
7894: PUSH
7895: LD_INT 64
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: PUSH
7906: LD_INT 82
7908: PUSH
7909: LD_INT 75
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PUSH
7916: LD_INT 73
7918: PUSH
7919: LD_INT 67
7921: PUSH
7922: EMPTY
7923: LIST
7924: LIST
7925: PUSH
7926: LD_INT 101
7928: PUSH
7929: LD_INT 65
7931: PUSH
7932: EMPTY
7933: LIST
7934: LIST
7935: PUSH
7936: LD_INT 108
7938: PUSH
7939: LD_INT 62
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PUSH
7946: EMPTY
7947: LIST
7948: LIST
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: LIST
7954: LIST
7955: ST_TO_ADDR
7956: GO 7959
7958: POP
// if not attackFormula then
7959: LD_VAR 0 6
7963: NOT
7964: IFFALSE 7968
// exit ;
7966: GO 9400
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
7968: LD_ADDR_VAR 0 7
7972: PUSH
7973: LD_EXP 43
7977: PPUSH
7978: LD_INT 25
7980: PUSH
7981: LD_INT 1
7983: PUSH
7984: EMPTY
7985: LIST
7986: LIST
7987: PPUSH
7988: CALL_OW 72
7992: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
7993: LD_ADDR_VAR 0 8
7997: PUSH
7998: LD_EXP 43
8002: PPUSH
8003: LD_INT 25
8005: PUSH
8006: LD_INT 4
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8018: LD_ADDR_VAR 0 9
8022: PUSH
8023: LD_EXP 43
8027: PPUSH
8028: LD_INT 25
8030: PUSH
8031: LD_INT 3
8033: PUSH
8034: EMPTY
8035: LIST
8036: LIST
8037: PPUSH
8038: CALL_OW 72
8042: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8043: LD_ADDR_VAR 0 10
8047: PUSH
8048: LD_EXP 43
8052: PPUSH
8053: LD_INT 21
8055: PUSH
8056: LD_INT 2
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: PPUSH
8063: CALL_OW 72
8067: ST_TO_ADDR
// if sci then
8068: LD_VAR 0 8
8072: IFFALSE 8109
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8074: LD_VAR 0 8
8078: PPUSH
8079: LD_VAR 0 6
8083: PUSH
8084: LD_INT 2
8086: ARRAY
8087: PUSH
8088: LD_INT 1
8090: ARRAY
8091: PPUSH
8092: LD_VAR 0 6
8096: PUSH
8097: LD_INT 2
8099: ARRAY
8100: PUSH
8101: LD_INT 2
8103: ARRAY
8104: PPUSH
8105: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8109: LD_INT 35
8111: PPUSH
8112: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8116: LD_ADDR_VAR 0 7
8120: PUSH
8121: LD_EXP 43
8125: PPUSH
8126: LD_INT 25
8128: PUSH
8129: LD_INT 1
8131: PUSH
8132: EMPTY
8133: LIST
8134: LIST
8135: PPUSH
8136: CALL_OW 72
8140: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8141: LD_ADDR_VAR 0 8
8145: PUSH
8146: LD_EXP 43
8150: PPUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 4
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PPUSH
8161: CALL_OW 72
8165: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8166: LD_ADDR_VAR 0 9
8170: PUSH
8171: LD_EXP 43
8175: PPUSH
8176: LD_INT 25
8178: PUSH
8179: LD_INT 3
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: PPUSH
8186: CALL_OW 72
8190: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8191: LD_ADDR_VAR 0 10
8195: PUSH
8196: LD_EXP 43
8200: PPUSH
8201: LD_INT 21
8203: PUSH
8204: LD_INT 2
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 72
8215: ST_TO_ADDR
// if sol then
8216: LD_VAR 0 7
8220: IFFALSE 8615
// begin for i in sol do
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 7
8231: PUSH
8232: FOR_IN
8233: IFFALSE 8613
// begin tag := GetTag ( i ) ;
8235: LD_ADDR_VAR 0 4
8239: PUSH
8240: LD_VAR 0 2
8244: PPUSH
8245: CALL_OW 110
8249: ST_TO_ADDR
// if not tag then
8250: LD_VAR 0 4
8254: NOT
8255: IFFALSE 8373
// begin if GetLives ( i ) = 1000 then
8257: LD_VAR 0 2
8261: PPUSH
8262: CALL_OW 256
8266: PUSH
8267: LD_INT 1000
8269: EQUAL
8270: IFFALSE 8286
// SetTag ( i , 1 ) else
8272: LD_VAR 0 2
8276: PPUSH
8277: LD_INT 1
8279: PPUSH
8280: CALL_OW 109
8284: GO 8371
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8286: LD_VAR 0 2
8290: PPUSH
8291: LD_VAR 0 6
8295: PUSH
8296: LD_INT 2
8298: ARRAY
8299: PUSH
8300: LD_INT 1
8302: ARRAY
8303: PPUSH
8304: LD_VAR 0 6
8308: PUSH
8309: LD_INT 2
8311: ARRAY
8312: PUSH
8313: LD_INT 2
8315: ARRAY
8316: PPUSH
8317: CALL_OW 297
8321: PUSH
8322: LD_INT 6
8324: GREATER
8325: IFFALSE 8371
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8327: LD_VAR 0 2
8331: PPUSH
8332: LD_VAR 0 6
8336: PUSH
8337: LD_INT 2
8339: ARRAY
8340: PUSH
8341: LD_INT 1
8343: ARRAY
8344: PPUSH
8345: LD_VAR 0 6
8349: PUSH
8350: LD_INT 2
8352: ARRAY
8353: PUSH
8354: LD_INT 2
8356: ARRAY
8357: PPUSH
8358: CALL_OW 111
// AddComHold ( i ) ;
8362: LD_VAR 0 2
8366: PPUSH
8367: CALL_OW 200
// end ; end else
8371: GO 8611
// begin if GetLives ( i ) < 720 then
8373: LD_VAR 0 2
8377: PPUSH
8378: CALL_OW 256
8382: PUSH
8383: LD_INT 720
8385: LESS
8386: IFFALSE 8402
// SetTag ( i , 0 ) else
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 0
8395: PPUSH
8396: CALL_OW 109
8400: GO 8611
// if tag <= attackFormula [ 1 ] then
8402: LD_VAR 0 4
8406: PUSH
8407: LD_VAR 0 6
8411: PUSH
8412: LD_INT 1
8414: ARRAY
8415: LESSEQUAL
8416: IFFALSE 8577
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8418: LD_VAR 0 2
8422: PPUSH
8423: LD_VAR 0 6
8427: PUSH
8428: LD_INT 1
8430: ARRAY
8431: PUSH
8432: LD_VAR 0 4
8436: ARRAY
8437: PUSH
8438: LD_INT 1
8440: ARRAY
8441: PPUSH
8442: LD_VAR 0 6
8446: PUSH
8447: LD_INT 1
8449: ARRAY
8450: PUSH
8451: LD_VAR 0 4
8455: ARRAY
8456: PUSH
8457: LD_INT 2
8459: ARRAY
8460: PPUSH
8461: CALL_OW 297
8465: PUSH
8466: LD_INT 6
8468: GREATER
8469: IFFALSE 8520
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_VAR 0 6
8480: PUSH
8481: LD_INT 1
8483: ARRAY
8484: PUSH
8485: LD_VAR 0 4
8489: ARRAY
8490: PUSH
8491: LD_INT 1
8493: ARRAY
8494: PPUSH
8495: LD_VAR 0 6
8499: PUSH
8500: LD_INT 1
8502: ARRAY
8503: PUSH
8504: LD_VAR 0 4
8508: ARRAY
8509: PUSH
8510: LD_INT 2
8512: ARRAY
8513: PPUSH
8514: CALL_OW 114
8518: GO 8575
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8520: LD_INT 81
8522: PUSH
8523: LD_INT 1
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PUSH
8530: LD_INT 91
8532: PUSH
8533: LD_VAR 0 2
8537: PUSH
8538: LD_INT 10
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: LIST
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PPUSH
8550: CALL_OW 69
8554: NOT
8555: IFFALSE 8575
// SetTag ( i , tag + 1 ) ;
8557: LD_VAR 0 2
8561: PPUSH
8562: LD_VAR 0 4
8566: PUSH
8567: LD_INT 1
8569: PLUS
8570: PPUSH
8571: CALL_OW 109
// end else
8575: GO 8611
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8577: LD_VAR 0 2
8581: PPUSH
8582: LD_INT 81
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: PPUSH
8592: CALL_OW 69
8596: PPUSH
8597: LD_VAR 0 2
8601: PPUSH
8602: CALL_OW 74
8606: PPUSH
8607: CALL_OW 115
// end ; end ;
8611: GO 8232
8613: POP
8614: POP
// end ; if sci then
8615: LD_VAR 0 8
8619: IFFALSE 8778
// begin if not sol and not mech then
8621: LD_VAR 0 7
8625: NOT
8626: PUSH
8627: LD_VAR 0 9
8631: NOT
8632: AND
8633: IFFALSE 8685
// begin for i in sci do
8635: LD_ADDR_VAR 0 2
8639: PUSH
8640: LD_VAR 0 8
8644: PUSH
8645: FOR_IN
8646: IFFALSE 8681
// begin usForces := usForces union i ;
8648: LD_ADDR_EXP 40
8652: PUSH
8653: LD_EXP 40
8657: PUSH
8658: LD_VAR 0 2
8662: UNION
8663: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8664: LD_VAR 0 2
8668: PPUSH
8669: LD_INT 34
8671: PPUSH
8672: LD_INT 68
8674: PPUSH
8675: CALL_OW 111
// end ;
8679: GO 8645
8681: POP
8682: POP
// end else
8683: GO 8778
// for i in sci do
8685: LD_ADDR_VAR 0 2
8689: PUSH
8690: LD_VAR 0 8
8694: PUSH
8695: FOR_IN
8696: IFFALSE 8776
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8698: LD_VAR 0 2
8702: PPUSH
8703: LD_VAR 0 6
8707: PUSH
8708: LD_INT 2
8710: ARRAY
8711: PUSH
8712: LD_INT 1
8714: ARRAY
8715: PPUSH
8716: LD_VAR 0 6
8720: PUSH
8721: LD_INT 2
8723: ARRAY
8724: PUSH
8725: LD_INT 2
8727: ARRAY
8728: PPUSH
8729: CALL_OW 297
8733: PUSH
8734: LD_INT 8
8736: GREATER
8737: IFFALSE 8774
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8739: LD_VAR 0 2
8743: PPUSH
8744: LD_VAR 0 6
8748: PUSH
8749: LD_INT 2
8751: ARRAY
8752: PUSH
8753: LD_INT 1
8755: ARRAY
8756: PPUSH
8757: LD_VAR 0 6
8761: PUSH
8762: LD_INT 2
8764: ARRAY
8765: PUSH
8766: LD_INT 2
8768: ARRAY
8769: PPUSH
8770: CALL_OW 111
8774: GO 8695
8776: POP
8777: POP
// end ; if tanks and mech then
8778: LD_VAR 0 10
8782: PUSH
8783: LD_VAR 0 9
8787: AND
8788: IFFALSE 9393
// begin for i in mech do
8790: LD_ADDR_VAR 0 2
8794: PUSH
8795: LD_VAR 0 9
8799: PUSH
8800: FOR_IN
8801: IFFALSE 9391
// begin tag := GetTag ( i ) ;
8803: LD_ADDR_VAR 0 4
8807: PUSH
8808: LD_VAR 0 2
8812: PPUSH
8813: CALL_OW 110
8817: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8818: LD_ADDR_VAR 0 11
8822: PUSH
8823: LD_VAR 0 2
8827: PPUSH
8828: CALL_OW 310
8832: ST_TO_ADDR
// if not tag then
8833: LD_VAR 0 4
8837: NOT
8838: IFFALSE 9151
// begin if veh then
8840: LD_VAR 0 11
8844: IFFALSE 8993
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
8846: LD_VAR 0 11
8850: PPUSH
8851: CALL_OW 256
8855: PUSH
8856: LD_INT 1000
8858: EQUAL
8859: PUSH
8860: LD_VAR 0 11
8864: PPUSH
8865: CALL_OW 261
8869: PUSH
8870: LD_INT 60
8872: GREATER
8873: AND
8874: IFFALSE 8890
// SetTag ( i , 1 ) else
8876: LD_VAR 0 2
8880: PPUSH
8881: LD_INT 1
8883: PPUSH
8884: CALL_OW 109
8888: GO 8991
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
8890: LD_VAR 0 2
8894: PPUSH
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 3
8902: ARRAY
8903: PUSH
8904: LD_INT 1
8906: ARRAY
8907: PPUSH
8908: LD_VAR 0 6
8912: PUSH
8913: LD_INT 3
8915: ARRAY
8916: PUSH
8917: LD_INT 2
8919: ARRAY
8920: PPUSH
8921: CALL_OW 297
8925: PUSH
8926: LD_INT 7
8928: GREATER
8929: IFFALSE 8968
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
8931: LD_VAR 0 2
8935: PPUSH
8936: LD_VAR 0 6
8940: PUSH
8941: LD_INT 3
8943: ARRAY
8944: PUSH
8945: LD_INT 1
8947: ARRAY
8948: PPUSH
8949: LD_VAR 0 6
8953: PUSH
8954: LD_INT 3
8956: ARRAY
8957: PUSH
8958: LD_INT 2
8960: ARRAY
8961: PPUSH
8962: CALL_OW 111
8966: GO 8991
// begin ComExitVehicle ( i ) ;
8968: LD_VAR 0 2
8972: PPUSH
8973: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
8977: LD_VAR 0 2
8981: PPUSH
8982: LD_VAR 0 11
8986: PPUSH
8987: CALL_OW 189
// end ; end else
8991: GO 9149
// if GetLives ( i ) < 700 then
8993: LD_VAR 0 2
8997: PPUSH
8998: CALL_OW 256
9002: PUSH
9003: LD_INT 700
9005: LESS
9006: IFFALSE 9057
// begin usAttackers := usAttackers diff i ;
9008: LD_ADDR_EXP 43
9012: PUSH
9013: LD_EXP 43
9017: PUSH
9018: LD_VAR 0 2
9022: DIFF
9023: ST_TO_ADDR
// usForces := usForces union i ;
9024: LD_ADDR_EXP 40
9028: PUSH
9029: LD_EXP 40
9033: PUSH
9034: LD_VAR 0 2
9038: UNION
9039: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9040: LD_VAR 0 2
9044: PPUSH
9045: LD_INT 34
9047: PPUSH
9048: LD_INT 68
9050: PPUSH
9051: CALL_OW 111
// end else
9055: GO 9149
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9057: LD_VAR 0 10
9061: PPUSH
9062: LD_INT 58
9064: PUSH
9065: EMPTY
9066: LIST
9067: PUSH
9068: LD_INT 24
9070: PUSH
9071: LD_INT 1000
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PPUSH
9082: CALL_OW 72
9086: PUSH
9087: LD_VAR 0 2
9091: PPUSH
9092: CALL_OW 314
9096: NOT
9097: AND
9098: IFFALSE 9149
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9100: LD_VAR 0 2
9104: PPUSH
9105: LD_VAR 0 10
9109: PPUSH
9110: LD_INT 58
9112: PUSH
9113: EMPTY
9114: LIST
9115: PUSH
9116: LD_INT 24
9118: PUSH
9119: LD_INT 1000
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PPUSH
9130: CALL_OW 72
9134: PPUSH
9135: LD_VAR 0 2
9139: PPUSH
9140: CALL_OW 74
9144: PPUSH
9145: CALL_OW 120
// end else
9149: GO 9389
// begin if GetLives ( veh ) < 620 then
9151: LD_VAR 0 11
9155: PPUSH
9156: CALL_OW 256
9160: PUSH
9161: LD_INT 620
9163: LESS
9164: IFFALSE 9180
// SetTag ( i , 0 ) else
9166: LD_VAR 0 2
9170: PPUSH
9171: LD_INT 0
9173: PPUSH
9174: CALL_OW 109
9178: GO 9389
// if tag <= attackFormula [ 4 ] then
9180: LD_VAR 0 4
9184: PUSH
9185: LD_VAR 0 6
9189: PUSH
9190: LD_INT 4
9192: ARRAY
9193: LESSEQUAL
9194: IFFALSE 9355
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9196: LD_VAR 0 2
9200: PPUSH
9201: LD_VAR 0 6
9205: PUSH
9206: LD_INT 4
9208: ARRAY
9209: PUSH
9210: LD_VAR 0 4
9214: ARRAY
9215: PUSH
9216: LD_INT 1
9218: ARRAY
9219: PPUSH
9220: LD_VAR 0 6
9224: PUSH
9225: LD_INT 4
9227: ARRAY
9228: PUSH
9229: LD_VAR 0 4
9233: ARRAY
9234: PUSH
9235: LD_INT 2
9237: ARRAY
9238: PPUSH
9239: CALL_OW 297
9243: PUSH
9244: LD_INT 6
9246: GREATER
9247: IFFALSE 9298
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9249: LD_VAR 0 2
9253: PPUSH
9254: LD_VAR 0 6
9258: PUSH
9259: LD_INT 4
9261: ARRAY
9262: PUSH
9263: LD_VAR 0 4
9267: ARRAY
9268: PUSH
9269: LD_INT 1
9271: ARRAY
9272: PPUSH
9273: LD_VAR 0 6
9277: PUSH
9278: LD_INT 4
9280: ARRAY
9281: PUSH
9282: LD_VAR 0 4
9286: ARRAY
9287: PUSH
9288: LD_INT 2
9290: ARRAY
9291: PPUSH
9292: CALL_OW 114
9296: GO 9353
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9298: LD_INT 81
9300: PUSH
9301: LD_INT 1
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: PUSH
9308: LD_INT 91
9310: PUSH
9311: LD_VAR 0 2
9315: PUSH
9316: LD_INT 10
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: LIST
9323: PUSH
9324: EMPTY
9325: LIST
9326: LIST
9327: PPUSH
9328: CALL_OW 69
9332: NOT
9333: IFFALSE 9353
// SetTag ( i , tag + 1 ) ;
9335: LD_VAR 0 2
9339: PPUSH
9340: LD_VAR 0 4
9344: PUSH
9345: LD_INT 1
9347: PLUS
9348: PPUSH
9349: CALL_OW 109
// end else
9353: GO 9389
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9355: LD_VAR 0 2
9359: PPUSH
9360: LD_INT 81
9362: PUSH
9363: LD_INT 1
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: PPUSH
9370: CALL_OW 69
9374: PPUSH
9375: LD_VAR 0 2
9379: PPUSH
9380: CALL_OW 74
9384: PPUSH
9385: CALL_OW 115
// end ; end ;
9389: GO 8800
9391: POP
9392: POP
// end ; until not usAttackers ;
9393: LD_EXP 43
9397: NOT
9398: IFFALSE 8109
// end ; end_of_file
9400: LD_VAR 0 1
9404: RET
// export function Action ; var hasAll , i , tmp ; begin
9405: LD_INT 0
9407: PPUSH
9408: PPUSH
9409: PPUSH
9410: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9411: LD_ADDR_VAR 0 2
9415: PUSH
9416: LD_INT 22
9418: PUSH
9419: LD_INT 2
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: PUSH
9426: LD_INT 21
9428: PUSH
9429: LD_INT 1
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PUSH
9436: LD_INT 23
9438: PUSH
9439: LD_INT 2
9441: PUSH
9442: EMPTY
9443: LIST
9444: LIST
9445: PUSH
9446: EMPTY
9447: LIST
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: PUSH
9456: LD_INT 7
9458: GREATEREQUAL
9459: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9460: LD_VAR 0 2
9464: PPUSH
9465: LD_STRING 03_HasAll
9467: PPUSH
9468: CALL_OW 39
// Video ( true ) ;
9472: LD_INT 1
9474: PPUSH
9475: CALL 991 0 1
// CenterNowOnUnits ( Heike ) ;
9479: LD_EXP 24
9483: PPUSH
9484: CALL_OW 87
// wait ( 0 0$2 ) ;
9488: LD_INT 70
9490: PPUSH
9491: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9495: LD_EXP 32
9499: PPUSH
9500: LD_STRING DF-1-start
9502: PPUSH
9503: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9507: LD_EXP 24
9511: PPUSH
9512: LD_EXP 32
9516: PPUSH
9517: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9521: LD_EXP 24
9525: PPUSH
9526: LD_STRING DH-1-start
9528: PPUSH
9529: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9533: LD_EXP 33
9537: PPUSH
9538: LD_INT 92
9540: PPUSH
9541: LD_INT 21
9543: PPUSH
9544: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9548: LD_EXP 28
9552: PPUSH
9553: LD_INT 94
9555: PPUSH
9556: LD_INT 23
9558: PPUSH
9559: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9563: LD_EXP 36
9567: PUSH
9568: LD_INT 1
9570: ARRAY
9571: PPUSH
9572: LD_INT 90
9574: PPUSH
9575: LD_INT 23
9577: PPUSH
9578: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9582: LD_EXP 36
9586: PUSH
9587: LD_INT 2
9589: ARRAY
9590: PPUSH
9591: LD_INT 93
9593: PPUSH
9594: LD_INT 25
9596: PPUSH
9597: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9601: LD_EXP 36
9605: PPUSH
9606: LD_EXP 33
9610: PPUSH
9611: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9615: LD_EXP 33
9619: PUSH
9620: LD_EXP 28
9624: PUSH
9625: EMPTY
9626: LIST
9627: LIST
9628: PPUSH
9629: LD_EXP 24
9633: PPUSH
9634: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9638: LD_EXP 24
9642: PPUSH
9643: LD_EXP 33
9647: PPUSH
9648: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9652: LD_INT 35
9654: PPUSH
9655: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9659: LD_EXP 33
9663: PPUSH
9664: LD_INT 92
9666: PPUSH
9667: LD_INT 21
9669: PPUSH
9670: CALL_OW 307
9674: IFFALSE 9652
// Say ( Omar , DO-1-start ) ;
9676: LD_EXP 33
9680: PPUSH
9681: LD_STRING DO-1-start
9683: PPUSH
9684: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9688: LD_EXP 24
9692: PPUSH
9693: LD_STRING DH-2-start
9695: PPUSH
9696: CALL_OW 88
// if hasAll then
9700: LD_VAR 0 2
9704: IFFALSE 9832
// begin Say ( Omar , DO-2-start ) ;
9706: LD_EXP 33
9710: PPUSH
9711: LD_STRING DO-2-start
9713: PPUSH
9714: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9718: LD_EXP 33
9722: PPUSH
9723: LD_STRING DO-3-start
9725: PPUSH
9726: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
9730: LD_EXP 24
9734: PPUSH
9735: LD_STRING DH-3-start
9737: PPUSH
9738: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
9742: LD_EXP 32
9746: PPUSH
9747: LD_STRING DF-2-start
9749: PPUSH
9750: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9754: LD_EXP 33
9758: PPUSH
9759: LD_EXP 32
9763: PPUSH
9764: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
9768: LD_EXP 33
9772: PPUSH
9773: LD_STRING DO-4-start
9775: PPUSH
9776: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
9780: LD_EXP 32
9784: PPUSH
9785: LD_STRING DF-3-start
9787: PPUSH
9788: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
9792: LD_EXP 33
9796: PPUSH
9797: LD_STRING DO-5-start
9799: PPUSH
9800: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
9804: LD_EXP 32
9808: PPUSH
9809: LD_STRING DF-4-start
9811: PPUSH
9812: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
9816: LD_EXP 33
9820: PPUSH
9821: LD_EXP 24
9825: PPUSH
9826: CALL_OW 119
// end else
9830: GO 9932
// begin Say ( Omar , DO-2-start-a ) ;
9832: LD_EXP 33
9836: PPUSH
9837: LD_STRING DO-2-start-a
9839: PPUSH
9840: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
9844: LD_EXP 33
9848: PPUSH
9849: LD_STRING DO-3-start-a
9851: PPUSH
9852: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
9856: LD_EXP 24
9860: PPUSH
9861: LD_STRING DH-3-start-a
9863: PPUSH
9864: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
9868: LD_EXP 32
9872: PPUSH
9873: LD_STRING DF-2-start-a
9875: PPUSH
9876: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9880: LD_EXP 33
9884: PPUSH
9885: LD_EXP 32
9889: PPUSH
9890: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
9894: LD_EXP 33
9898: PPUSH
9899: LD_STRING DO-4-start-a
9901: PPUSH
9902: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
9906: LD_EXP 32
9910: PPUSH
9911: LD_STRING DF-3-start-a
9913: PPUSH
9914: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
9918: LD_EXP 33
9922: PPUSH
9923: LD_EXP 24
9927: PPUSH
9928: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
9932: LD_INT 10
9934: PPUSH
9935: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
9939: LD_EXP 33
9943: PPUSH
9944: LD_STRING DO-1-mission
9946: PPUSH
9947: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
9951: LD_EXP 33
9955: PPUSH
9956: LD_STRING DO-2-mission
9958: PPUSH
9959: CALL_OW 88
// if not hasAll then
9963: LD_VAR 0 2
9967: NOT
9968: IFFALSE 9982
// Say ( Omar , DO-3-mission ) ;
9970: LD_EXP 33
9974: PPUSH
9975: LD_STRING DO-3-mission
9977: PPUSH
9978: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
9982: LD_EXP 33
9986: PPUSH
9987: LD_STRING DO-4-mission
9989: PPUSH
9990: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
9994: LD_EXP 24
9998: PPUSH
9999: LD_STRING DH-1-mission
10001: PPUSH
10002: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10006: LD_EXP 32
10010: PPUSH
10011: LD_STRING DF-1-mission
10013: PPUSH
10014: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10018: LD_EXP 33
10022: PPUSH
10023: LD_STRING DO-5-mission
10025: PPUSH
10026: CALL_OW 88
// if not hasAll then
10030: LD_VAR 0 2
10034: NOT
10035: IFFALSE 10170
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10037: LD_ADDR_VAR 0 4
10041: PUSH
10042: LD_INT 22
10044: PUSH
10045: LD_INT 2
10047: PUSH
10048: EMPTY
10049: LIST
10050: LIST
10051: PUSH
10052: LD_INT 21
10054: PUSH
10055: LD_INT 1
10057: PUSH
10058: EMPTY
10059: LIST
10060: LIST
10061: PUSH
10062: LD_INT 23
10064: PUSH
10065: LD_INT 2
10067: PUSH
10068: EMPTY
10069: LIST
10070: LIST
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: LIST
10076: PPUSH
10077: CALL_OW 69
10081: ST_TO_ADDR
// for i := 7 downto tmp do
10082: LD_ADDR_VAR 0 3
10086: PUSH
10087: DOUBLE
10088: LD_INT 7
10090: INC
10091: ST_TO_ADDR
10092: LD_VAR 0 4
10096: PUSH
10097: FOR_DOWNTO
10098: IFFALSE 10168
// begin if omarSquad < 3 then
10100: LD_EXP 36
10104: PUSH
10105: LD_INT 3
10107: LESS
10108: IFFALSE 10112
// break ;
10110: GO 10168
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10112: LD_EXP 36
10116: PUSH
10117: LD_INT 3
10119: ARRAY
10120: PPUSH
10121: LD_INT 2
10123: PPUSH
10124: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10128: LD_ADDR_EXP 38
10132: PUSH
10133: LD_EXP 38
10137: PUSH
10138: LD_EXP 36
10142: PUSH
10143: LD_INT 3
10145: ARRAY
10146: UNION
10147: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10148: LD_ADDR_EXP 36
10152: PUSH
10153: LD_EXP 36
10157: PPUSH
10158: LD_INT 3
10160: PPUSH
10161: CALL_OW 3
10165: ST_TO_ADDR
// end ;
10166: GO 10097
10168: POP
10169: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10170: LD_EXP 33
10174: PUSH
10175: LD_EXP 36
10179: ADD
10180: PPUSH
10181: LD_INT 103
10183: PPUSH
10184: LD_INT 9
10186: PPUSH
10187: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10191: LD_VAR 0 2
10195: PUSH
10196: LD_EXP 29
10200: PPUSH
10201: CALL_OW 302
10205: AND
10206: IFFALSE 10267
// begin wait ( 0 0$3 ) ;
10208: LD_INT 105
10210: PPUSH
10211: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10215: LD_EXP 29
10219: PPUSH
10220: LD_EXP 32
10224: PPUSH
10225: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10229: LD_EXP 29
10233: PPUSH
10234: LD_STRING DK-1-side
10236: PPUSH
10237: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10241: LD_EXP 32
10245: PPUSH
10246: LD_EXP 29
10250: PPUSH
10251: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10255: LD_EXP 32
10259: PPUSH
10260: LD_STRING DF-1-side
10262: PPUSH
10263: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10267: LD_INT 22
10269: PUSH
10270: LD_INT 2
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: PPUSH
10277: CALL_OW 69
10281: PPUSH
10282: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10286: LD_EXP 32
10290: PUSH
10291: LD_EXP 35
10295: ADD
10296: PPUSH
10297: LD_INT 108
10299: PPUSH
10300: LD_INT 62
10302: PPUSH
10303: CALL_OW 111
// gameStarted := true ;
10307: LD_ADDR_EXP 3
10311: PUSH
10312: LD_INT 1
10314: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10315: LD_INT 105
10317: PPUSH
10318: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10322: LD_EXP 24
10326: PPUSH
10327: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10331: LD_EXP 24
10335: PPUSH
10336: LD_EXP 28
10340: PPUSH
10341: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10345: LD_INT 22
10347: PUSH
10348: LD_INT 2
10350: PUSH
10351: EMPTY
10352: LIST
10353: LIST
10354: PPUSH
10355: CALL_OW 69
10359: PUSH
10360: LD_EXP 24
10364: DIFF
10365: PPUSH
10366: LD_EXP 24
10370: PPUSH
10371: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10375: LD_EXP 24
10379: PPUSH
10380: LD_STRING DH-1-explore
10382: PPUSH
10383: CALL_OW 88
// if Givi then
10387: LD_EXP 25
10391: IFFALSE 10407
// Say ( Givi , DG-1-explore ) else
10393: LD_EXP 25
10397: PPUSH
10398: LD_STRING DG-1-explore
10400: PPUSH
10401: CALL_OW 88
10405: GO 10444
// if heikeSecondSquad then
10407: LD_EXP 38
10411: IFFALSE 10444
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10413: LD_EXP 38
10417: PPUSH
10418: LD_INT 26
10420: PUSH
10421: LD_INT 1
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: PPUSH
10428: CALL_OW 72
10432: PUSH
10433: LD_INT 1
10435: ARRAY
10436: PPUSH
10437: LD_STRING DArm-1-explore
10439: PPUSH
10440: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10444: LD_EXP 28
10448: PPUSH
10449: LD_STRING DA-1-explore
10451: PPUSH
10452: CALL_OW 88
// if Sophia then
10456: LD_EXP 30
10460: IFFALSE 10538
// begin Say ( Sophia , DS-2-explore ) ;
10462: LD_EXP 30
10466: PPUSH
10467: LD_STRING DS-2-explore
10469: PPUSH
10470: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10474: LD_EXP 28
10478: PPUSH
10479: LD_STRING DA-2-explore
10481: PPUSH
10482: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10486: LD_EXP 30
10490: PPUSH
10491: LD_EXP 28
10495: PPUSH
10496: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10500: LD_EXP 28
10504: PPUSH
10505: LD_EXP 30
10509: PPUSH
10510: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10514: LD_EXP 30
10518: PPUSH
10519: LD_STRING DS-3-explore
10521: PPUSH
10522: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10526: LD_EXP 28
10530: PPUSH
10531: LD_STRING DA-3-explore
10533: PPUSH
10534: CALL_OW 88
// end ; if Mike then
10538: LD_EXP 26
10542: IFFALSE 10598
// begin Say ( Mike , DM-1-explore ) ;
10544: LD_EXP 26
10548: PPUSH
10549: LD_STRING DM-1-explore
10551: PPUSH
10552: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10556: LD_EXP 24
10560: PPUSH
10561: LD_STRING DH-2-explore
10563: PPUSH
10564: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10568: LD_EXP 26
10572: PPUSH
10573: LD_STRING DM-2-explore
10575: PPUSH
10576: CALL_OW 88
// if Kaia then
10580: LD_EXP 29
10584: IFFALSE 10598
// Say ( Kaia , DK-1-explore ) ;
10586: LD_EXP 29
10590: PPUSH
10591: LD_STRING DK-1-explore
10593: PPUSH
10594: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10598: LD_INT 22
10600: PUSH
10601: LD_INT 2
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PPUSH
10608: CALL_OW 69
10612: PPUSH
10613: CALL_OW 139
// Video ( false ) ;
10617: LD_INT 0
10619: PPUSH
10620: CALL 991 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10624: LD_STRING BuildBase
10626: PPUSH
10627: CALL_OW 337
// SaveForQuickRestart ;
10631: CALL_OW 22
// end ;
10635: LD_VAR 0 1
10639: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10640: LD_EXP 5
10644: NOT
10645: PUSH
10646: LD_EXP 6
10650: NOT
10651: AND
10652: PUSH
10653: LD_INT 5
10655: PPUSH
10656: LD_INT 22
10658: PUSH
10659: LD_INT 2
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 70
10670: AND
10671: PUSH
10672: LD_EXP 6
10676: NOT
10677: AND
10678: IFFALSE 10763
10680: GO 10682
10682: DISABLE
// begin if Mike then
10683: LD_EXP 26
10687: IFFALSE 10703
// Say ( Mike , DM-1-scout ) else
10689: LD_EXP 26
10693: PPUSH
10694: LD_STRING DM-1-scout
10696: PPUSH
10697: CALL_OW 88
10701: GO 10734
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10703: LD_EXP 38
10707: PPUSH
10708: LD_INT 26
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 72
10722: PUSH
10723: LD_INT 1
10725: ARRAY
10726: PPUSH
10727: LD_STRING DArm-1-explore
10729: PPUSH
10730: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
10734: LD_INT 54
10736: PPUSH
10737: LD_INT 35
10739: PPUSH
10740: LD_INT 2
10742: PPUSH
10743: LD_INT 1
10745: PPUSH
10746: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
10750: LD_INT 54
10752: PPUSH
10753: LD_INT 35
10755: PPUSH
10756: LD_INT 2
10758: PPUSH
10759: CALL_OW 331
// end ;
10763: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
10764: LD_INT 6
10766: PPUSH
10767: LD_INT 22
10769: PUSH
10770: LD_INT 2
10772: PUSH
10773: EMPTY
10774: LIST
10775: LIST
10776: PPUSH
10777: CALL_OW 70
10781: PUSH
10782: LD_EXP 6
10786: NOT
10787: AND
10788: IFFALSE 11042
10790: GO 10792
10792: DISABLE
10793: LD_INT 0
10795: PPUSH
10796: PPUSH
10797: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
10798: LD_ADDR_VAR 0 1
10802: PUSH
10803: LD_EXP 38
10807: PPUSH
10808: LD_INT 26
10810: PUSH
10811: LD_INT 1
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: PPUSH
10818: CALL_OW 72
10822: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
10823: LD_ADDR_VAR 0 2
10827: PUSH
10828: LD_EXP 38
10832: PPUSH
10833: LD_INT 26
10835: PUSH
10836: LD_INT 2
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: PPUSH
10843: CALL_OW 72
10847: ST_TO_ADDR
// DialogueOn ;
10848: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
10852: LD_INT 36
10854: PPUSH
10855: LD_INT 22
10857: PPUSH
10858: LD_INT 2
10860: PPUSH
10861: LD_INT 8
10863: PPUSH
10864: CALL_OW 330
// dwait ( 0 0$1 ) ;
10868: LD_INT 35
10870: PPUSH
10871: CALL_OW 68
// speakerOk := false ;
10875: LD_ADDR_VAR 0 3
10879: PUSH
10880: LD_INT 0
10882: ST_TO_ADDR
// if Mike then
10883: LD_EXP 26
10887: IFFALSE 10909
// speakerOk := Say ( Mike , DM-1-spot ) else
10889: LD_ADDR_VAR 0 3
10893: PUSH
10894: LD_EXP 26
10898: PPUSH
10899: LD_STRING DM-1-spot
10901: PPUSH
10902: CALL_OW 88
10906: ST_TO_ADDR
10907: GO 10937
// if randomMen then
10909: LD_VAR 0 1
10913: IFFALSE 10937
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
10915: LD_ADDR_VAR 0 3
10919: PUSH
10920: LD_VAR 0 1
10924: PUSH
10925: LD_INT 1
10927: ARRAY
10928: PPUSH
10929: LD_STRING DArm-1-spot-a
10931: PPUSH
10932: CALL_OW 88
10936: ST_TO_ADDR
// if speakerOk then
10937: LD_VAR 0 3
10941: IFFALSE 10985
// begin if Givi then
10943: LD_EXP 25
10947: IFFALSE 10963
// Say ( Givi , DG-1-spot ) else
10949: LD_EXP 25
10953: PPUSH
10954: LD_STRING DG-1-spot
10956: PPUSH
10957: CALL_OW 88
10961: GO 10985
// if randomWomen then
10963: LD_VAR 0 2
10967: IFFALSE 10985
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
10969: LD_VAR 0 2
10973: PUSH
10974: LD_INT 1
10976: ARRAY
10977: PPUSH
10978: LD_STRING DArf-1-spot-a
10980: PPUSH
10981: CALL_OW 88
// end ; if Mike then
10985: LD_EXP 26
10989: IFFALSE 11005
// Say ( Heike , DH-1-spot ) else
10991: LD_EXP 24
10995: PPUSH
10996: LD_STRING DH-1-spot
10998: PPUSH
10999: CALL_OW 88
11003: GO 11017
// Say ( Heike , DH-1-spot-a ) ;
11005: LD_EXP 24
11009: PPUSH
11010: LD_STRING DH-1-spot-a
11012: PPUSH
11013: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11017: LD_INT 36
11019: PPUSH
11020: LD_INT 22
11022: PPUSH
11023: LD_INT 2
11025: PPUSH
11026: CALL_OW 331
// DialogueOff ;
11030: CALL_OW 7
// americanBaseSpoted := true ;
11034: LD_ADDR_EXP 5
11038: PUSH
11039: LD_INT 1
11041: ST_TO_ADDR
// end ;
11042: PPOPN 3
11044: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11045: LD_EXP 5
11049: NOT
11050: PUSH
11051: LD_INT 22
11053: PUSH
11054: LD_INT 2
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: PUSH
11061: LD_INT 101
11063: PUSH
11064: LD_INT 1
11066: PUSH
11067: EMPTY
11068: LIST
11069: LIST
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: PPUSH
11075: CALL_OW 69
11079: AND
11080: PUSH
11081: LD_EXP 6
11085: NOT
11086: AND
11087: IFFALSE 11173
11089: GO 11091
11091: DISABLE
11092: LD_INT 0
11094: PPUSH
// begin americanBaseSpoted := true ;
11095: LD_ADDR_EXP 5
11099: PUSH
11100: LD_INT 1
11102: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11103: LD_ADDR_VAR 0 1
11107: PUSH
11108: LD_EXP 38
11112: PPUSH
11113: LD_INT 26
11115: PUSH
11116: LD_INT 1
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: PPUSH
11123: CALL_OW 72
11127: ST_TO_ADDR
// if not randomMen then
11128: LD_VAR 0 1
11132: NOT
11133: IFFALSE 11137
// exit ;
11135: GO 11173
// DialogueOn ;
11137: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11141: LD_VAR 0 1
11145: PUSH
11146: LD_INT 1
11148: ARRAY
11149: PPUSH
11150: LD_STRING DArm-1-spot-a
11152: PPUSH
11153: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11157: LD_EXP 24
11161: PPUSH
11162: LD_STRING DH-1-spot-a
11164: PPUSH
11165: CALL_OW 88
// DialogueOff ;
11169: CALL_OW 7
// end ;
11173: PPOPN 1
11175: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) do var i , p ;
11176: LD_INT 11
11178: PPUSH
11179: CALL_OW 255
11183: PUSH
11184: LD_INT 2
11186: EQUAL
11187: PUSH
11188: LD_INT 7
11190: PPUSH
11191: LD_INT 22
11193: PUSH
11194: LD_INT 1
11196: PUSH
11197: EMPTY
11198: LIST
11199: LIST
11200: PUSH
11201: LD_INT 3
11203: PUSH
11204: LD_INT 50
11206: PUSH
11207: EMPTY
11208: LIST
11209: PUSH
11210: EMPTY
11211: LIST
11212: LIST
11213: PUSH
11214: LD_INT 30
11216: PUSH
11217: LD_INT 31
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: LIST
11228: PPUSH
11229: CALL_OW 70
11233: OR
11234: PUSH
11235: LD_INT 7
11237: PPUSH
11238: LD_INT 22
11240: PUSH
11241: LD_INT 2
11243: PUSH
11244: EMPTY
11245: LIST
11246: LIST
11247: PPUSH
11248: CALL_OW 70
11252: PUSH
11253: LD_INT 1
11255: GREATER
11256: OR
11257: PUSH
11258: LD_INT 6
11260: PPUSH
11261: LD_INT 22
11263: PUSH
11264: LD_INT 2
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: PPUSH
11271: CALL_OW 70
11275: OR
11276: IFFALSE 11812
11278: GO 11280
11280: DISABLE
11281: LD_INT 0
11283: PPUSH
11284: PPUSH
// begin americanBaseCaptured := true ;
11285: LD_ADDR_EXP 6
11289: PUSH
11290: LD_INT 1
11292: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11293: LD_INT 105
11295: PPUSH
11296: CALL_OW 67
// if IsOk ( usCommander ) then
11300: LD_EXP 41
11304: PPUSH
11305: CALL_OW 302
11309: IFFALSE 11372
// begin usForces := usForces union usCommander ;
11311: LD_ADDR_EXP 40
11315: PUSH
11316: LD_EXP 40
11320: PUSH
11321: LD_EXP 41
11325: UNION
11326: ST_TO_ADDR
// if FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) then
11327: LD_INT 6
11329: PPUSH
11330: LD_INT 22
11332: PUSH
11333: LD_INT 2
11335: PUSH
11336: EMPTY
11337: LIST
11338: LIST
11339: PPUSH
11340: CALL_OW 70
11344: IFFALSE 11360
// Say ( usCommander , DUsm-2-assault ) else
11346: LD_EXP 41
11350: PPUSH
11351: LD_STRING DUsm-2-assault
11353: PPUSH
11354: CALL_OW 88
11358: GO 11372
// Say ( usCommander , DUsm-1-assault ) ;
11360: LD_EXP 41
11364: PPUSH
11365: LD_STRING DUsm-1-assault
11367: PPUSH
11368: CALL_OW 88
// end ; for i in usForces do
11372: LD_ADDR_VAR 0 1
11376: PUSH
11377: LD_EXP 40
11381: PUSH
11382: FOR_IN
11383: IFFALSE 11422
// begin if IsInUnit ( i ) then
11385: LD_VAR 0 1
11389: PPUSH
11390: CALL_OW 310
11394: IFFALSE 11405
// ComExitBuilding ( i ) ;
11396: LD_VAR 0 1
11400: PPUSH
11401: CALL_OW 122
// AddComMoveXY ( i , 34 , 67 ) ;
11405: LD_VAR 0 1
11409: PPUSH
11410: LD_INT 34
11412: PPUSH
11413: LD_INT 67
11415: PPUSH
11416: CALL_OW 171
// end ;
11420: GO 11382
11422: POP
11423: POP
// Say ( Heike , DH-1-assault ) ;
11424: LD_EXP 24
11428: PPUSH
11429: LD_STRING DH-1-assault
11431: PPUSH
11432: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11436: LD_INT 35
11438: PPUSH
11439: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11443: LD_VAR 0 1
11447: PPUSH
11448: LD_INT 34
11450: PPUSH
11451: LD_INT 67
11453: PPUSH
11454: CALL_OW 111
// until not usForces ;
11458: LD_EXP 40
11462: NOT
11463: IFFALSE 11436
// music_nat := 2 ;
11465: LD_ADDR_OWVAR 71
11469: PUSH
11470: LD_INT 2
11472: ST_TO_ADDR
// music_class := music_victory ;
11473: LD_ADDR_OWVAR 72
11477: PUSH
11478: LD_INT 4
11480: ST_TO_ADDR
// if not americanHasEscaped then
11481: LD_EXP 7
11485: NOT
11486: IFFALSE 11500
// Say ( Heike , DH-2-assault ) ;
11488: LD_EXP 24
11492: PPUSH
11493: LD_STRING DH-2-assault
11495: PPUSH
11496: CALL_OW 88
// wait ( 0 0$2 ) ;
11500: LD_INT 70
11502: PPUSH
11503: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11507: LD_INT 35
11509: PPUSH
11510: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11514: LD_INT 22
11516: PUSH
11517: LD_INT 2
11519: PUSH
11520: EMPTY
11521: LIST
11522: LIST
11523: PUSH
11524: LD_INT 21
11526: PUSH
11527: LD_INT 1
11529: PUSH
11530: EMPTY
11531: LIST
11532: LIST
11533: PUSH
11534: LD_INT 3
11536: PUSH
11537: LD_INT 50
11539: PUSH
11540: EMPTY
11541: LIST
11542: PUSH
11543: EMPTY
11544: LIST
11545: LIST
11546: PUSH
11547: EMPTY
11548: LIST
11549: LIST
11550: LIST
11551: PPUSH
11552: CALL_OW 69
11556: NOT
11557: IFFALSE 11507
// Video ( true ) ;
11559: LD_INT 1
11561: PPUSH
11562: CALL 991 0 1
// if not GetSide ( usDepot ) = 2 then
11566: LD_INT 11
11568: PPUSH
11569: CALL_OW 255
11573: PUSH
11574: LD_INT 2
11576: EQUAL
11577: NOT
11578: IFFALSE 11590
// SetSide ( usDepot , 2 ) ;
11580: LD_INT 11
11582: PPUSH
11583: LD_INT 2
11585: PPUSH
11586: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11590: LD_INT 35
11592: PPUSH
11593: LD_INT 22
11595: PPUSH
11596: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11600: LD_EXP 24
11604: PPUSH
11605: LD_INT 35
11607: PPUSH
11608: LD_INT 22
11610: PPUSH
11611: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11615: LD_EXP 24
11619: PPUSH
11620: LD_INT 38
11622: PPUSH
11623: LD_INT 25
11625: PPUSH
11626: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11630: LD_EXP 37
11634: PUSH
11635: LD_EXP 38
11639: UNION
11640: PPUSH
11641: LD_INT 39
11643: PPUSH
11644: LD_INT 26
11646: PPUSH
11647: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11651: LD_EXP 37
11655: PUSH
11656: LD_EXP 38
11660: UNION
11661: PPUSH
11662: LD_EXP 24
11666: PPUSH
11667: CALL_OW 179
// p := 0 ;
11671: LD_ADDR_VAR 0 2
11675: PUSH
11676: LD_INT 0
11678: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11679: LD_INT 35
11681: PPUSH
11682: CALL_OW 67
// p := p + 1 ;
11686: LD_ADDR_VAR 0 2
11690: PUSH
11691: LD_VAR 0 2
11695: PUSH
11696: LD_INT 1
11698: PLUS
11699: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11700: LD_EXP 24
11704: PPUSH
11705: CALL_OW 314
11709: NOT
11710: PUSH
11711: LD_VAR 0 2
11715: PUSH
11716: LD_INT 10
11718: GREATER
11719: OR
11720: IFFALSE 11679
// Say ( Heike , DH-1-capture ) ;
11722: LD_EXP 24
11726: PPUSH
11727: LD_STRING DH-1-capture
11729: PPUSH
11730: CALL_OW 88
// if Markov then
11734: LD_EXP 31
11738: IFFALSE 11752
// Say ( Markov , DMar-1-capture ) ;
11740: LD_EXP 31
11744: PPUSH
11745: LD_STRING DMar-1-capture
11747: PPUSH
11748: CALL_OW 88
// if Sophia then
11752: LD_EXP 30
11756: IFFALSE 11782
// begin Say ( Heike , DH-2-capture ) ;
11758: LD_EXP 24
11762: PPUSH
11763: LD_STRING DH-2-capture
11765: PPUSH
11766: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
11770: LD_EXP 30
11774: PPUSH
11775: LD_STRING DS-1-capture
11777: PPUSH
11778: CALL_OW 88
// end ; Video ( false ) ;
11782: LD_INT 0
11784: PPUSH
11785: CALL 991 0 1
// music_nat := music_auto ;
11789: LD_ADDR_OWVAR 71
11793: PUSH
11794: LD_INT 0
11796: ST_TO_ADDR
// music_class := music_auto ;
11797: LD_ADDR_OWVAR 72
11801: PUSH
11802: LD_INT 0
11804: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
11805: LD_STRING ConstructBase
11807: PPUSH
11808: CALL_OW 337
// end ;
11812: PPOPN 2
11814: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
11815: LD_INT 22
11817: PUSH
11818: LD_INT 2
11820: PUSH
11821: EMPTY
11822: LIST
11823: LIST
11824: PUSH
11825: LD_INT 30
11827: PUSH
11828: LD_INT 2
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: PUSH
11835: LD_INT 3
11837: PUSH
11838: LD_INT 57
11840: PUSH
11841: EMPTY
11842: LIST
11843: PUSH
11844: EMPTY
11845: LIST
11846: LIST
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: LIST
11852: PPUSH
11853: CALL_OW 69
11857: IFFALSE 12100
11859: GO 11861
11861: DISABLE
// begin workshopBuilded := true ;
11862: LD_ADDR_EXP 9
11866: PUSH
11867: LD_INT 1
11869: ST_TO_ADDR
// if IsOk ( Markov ) then
11870: LD_EXP 31
11874: PPUSH
11875: CALL_OW 302
11879: IFFALSE 11938
// begin Say ( Heike , DH-1-shop-a ) ;
11881: LD_EXP 24
11885: PPUSH
11886: LD_STRING DH-1-shop-a
11888: PPUSH
11889: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
11893: LD_INT 47
11895: PPUSH
11896: LD_INT 2
11898: PPUSH
11899: CALL_OW 321
11903: PUSH
11904: LD_INT 2
11906: EQUAL
11907: PUSH
11908: LD_INT 45
11910: PPUSH
11911: LD_INT 2
11913: PPUSH
11914: CALL_OW 321
11918: PUSH
11919: LD_INT 2
11921: EQUAL
11922: AND
11923: NOT
11924: IFFALSE 11938
// Say ( Markov , DMar-1-shop-a ) ;
11926: LD_EXP 31
11930: PPUSH
11931: LD_STRING DMar-1-shop-a
11933: PPUSH
11934: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
11938: LD_INT 35
11940: PPUSH
11941: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ;
11945: LD_INT 47
11947: PPUSH
11948: LD_INT 2
11950: PPUSH
11951: CALL_OW 321
11955: PUSH
11956: LD_INT 2
11958: EQUAL
11959: PUSH
11960: LD_INT 45
11962: PPUSH
11963: LD_INT 2
11965: PPUSH
11966: CALL_OW 321
11970: PUSH
11971: LD_INT 2
11973: EQUAL
11974: AND
11975: IFFALSE 11938
// DialogueOn ;
11977: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
11981: LD_EXP 31
11985: PPUSH
11986: LD_STRING DMar-1-shop
11988: PPUSH
11989: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
11993: LD_EXP 24
11997: PPUSH
11998: LD_STRING DH-1-shop
12000: PPUSH
12001: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12005: LD_EXP 31
12009: PPUSH
12010: LD_STRING DMar-2-shop
12012: PPUSH
12013: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12017: LD_EXP 31
12021: PPUSH
12022: LD_STRING DMar-3-shop
12024: PPUSH
12025: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12029: LD_EXP 24
12033: PPUSH
12034: LD_STRING DH-2-shop
12036: PPUSH
12037: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12041: LD_EXP 31
12045: PPUSH
12046: LD_STRING DMar-4-shop
12048: PPUSH
12049: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12053: LD_EXP 24
12057: PPUSH
12058: LD_STRING DH-3-shop
12060: PPUSH
12061: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12065: LD_EXP 31
12069: PPUSH
12070: LD_STRING DMar-5-shop
12072: PPUSH
12073: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12077: LD_EXP 24
12081: PPUSH
12082: LD_STRING DH-4-shop
12084: PPUSH
12085: CALL_OW 88
// DialogueOff ;
12089: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12093: LD_STRING ConstructVeh
12095: PPUSH
12096: CALL_OW 337
// end ;
12100: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12101: LD_INT 2
12103: PPUSH
12104: LD_INT 2
12106: PPUSH
12107: LD_INT 1
12109: PPUSH
12110: CALL 1162 0 3
12114: PUSH
12115: LD_INT 0
12117: EQUAL
12118: IFFALSE 12130
12120: GO 12122
12122: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12123: LD_STRING Techs
12125: PPUSH
12126: CALL_OW 337
12130: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12131: LD_EXP 31
12135: PPUSH
12136: CALL_OW 302
12140: PUSH
12141: LD_INT 22
12143: PUSH
12144: LD_INT 2
12146: PUSH
12147: EMPTY
12148: LIST
12149: LIST
12150: PUSH
12151: LD_INT 2
12153: PUSH
12154: LD_INT 34
12156: PUSH
12157: LD_INT 22
12159: PUSH
12160: EMPTY
12161: LIST
12162: LIST
12163: PUSH
12164: LD_INT 35
12166: PUSH
12167: LD_INT 22
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: PUSH
12174: EMPTY
12175: LIST
12176: LIST
12177: LIST
12178: PUSH
12179: EMPTY
12180: LIST
12181: LIST
12182: PPUSH
12183: CALL_OW 69
12187: AND
12188: IFFALSE 12295
12190: GO 12192
12192: DISABLE
// begin DialogueOn ;
12193: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12197: LD_INT 22
12199: PUSH
12200: LD_INT 2
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: LD_INT 2
12209: PUSH
12210: LD_INT 34
12212: PUSH
12213: LD_INT 22
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: LD_INT 35
12222: PUSH
12223: LD_INT 22
12225: PUSH
12226: EMPTY
12227: LIST
12228: LIST
12229: PUSH
12230: EMPTY
12231: LIST
12232: LIST
12233: LIST
12234: PUSH
12235: EMPTY
12236: LIST
12237: LIST
12238: PPUSH
12239: CALL_OW 69
12243: PPUSH
12244: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12248: LD_INT 10
12250: PPUSH
12251: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12255: LD_EXP 24
12259: PPUSH
12260: LD_STRING DH-1-bal
12262: PPUSH
12263: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12267: LD_EXP 31
12271: PPUSH
12272: LD_STRING DMar-1-bal
12274: PPUSH
12275: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12279: LD_EXP 24
12283: PPUSH
12284: LD_STRING DH-2-bal
12286: PPUSH
12287: CALL_OW 88
// DialogueOff ;
12291: CALL_OW 7
// end ;
12295: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12296: LD_EXP 28
12300: PPUSH
12301: CALL_OW 302
12305: PUSH
12306: LD_INT 22
12308: PUSH
12309: LD_INT 2
12311: PUSH
12312: EMPTY
12313: LIST
12314: LIST
12315: PUSH
12316: LD_INT 30
12318: PUSH
12319: LD_INT 6
12321: PUSH
12322: EMPTY
12323: LIST
12324: LIST
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PPUSH
12330: CALL_OW 69
12334: AND
12335: IFFALSE 12396
12337: GO 12339
12339: DISABLE
// begin DialogueOn ;
12340: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12344: LD_EXP 28
12348: PPUSH
12349: LD_STRING DA-1-lab
12351: PPUSH
12352: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12356: LD_EXP 24
12360: PPUSH
12361: LD_STRING DH-1-lab
12363: PPUSH
12364: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12368: LD_EXP 28
12372: PPUSH
12373: LD_STRING DA-2-lab
12375: PPUSH
12376: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12380: LD_EXP 24
12384: PPUSH
12385: LD_STRING DH-2-lab
12387: PPUSH
12388: CALL_OW 88
// DialogueOff ;
12392: CALL_OW 7
// end ;
12396: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) do var ape ;
12397: LD_EXP 29
12401: PPUSH
12402: CALL_OW 302
12406: PUSH
12407: LD_INT 22
12409: PUSH
12410: LD_INT 2
12412: PUSH
12413: EMPTY
12414: LIST
12415: LIST
12416: PUSH
12417: LD_INT 25
12419: PUSH
12420: LD_INT 15
12422: PUSH
12423: EMPTY
12424: LIST
12425: LIST
12426: PUSH
12427: EMPTY
12428: LIST
12429: LIST
12430: PPUSH
12431: CALL_OW 69
12435: AND
12436: IFFALSE 12616
12438: GO 12440
12440: DISABLE
12441: LD_INT 0
12443: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12444: LD_ADDR_VAR 0 1
12448: PUSH
12449: LD_INT 22
12451: PUSH
12452: LD_INT 2
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: PUSH
12459: LD_INT 25
12461: PUSH
12462: LD_INT 15
12464: PUSH
12465: EMPTY
12466: LIST
12467: LIST
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: PPUSH
12473: CALL_OW 69
12477: ST_TO_ADDR
// Video ( true ) ;
12478: LD_INT 1
12480: PPUSH
12481: CALL 991 0 1
// CenterNowOnUnits ( ape [ 1 ] ) ;
12485: LD_VAR 0 1
12489: PUSH
12490: LD_INT 1
12492: ARRAY
12493: PPUSH
12494: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12498: LD_VAR 0 1
12502: PUSH
12503: LD_INT 1
12505: ARRAY
12506: PPUSH
12507: CALL_OW 122
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12511: LD_VAR 0 1
12515: PUSH
12516: LD_INT 1
12518: ARRAY
12519: PPUSH
12520: LD_INT 35
12522: PPUSH
12523: LD_INT 28
12525: PPUSH
12526: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12530: LD_VAR 0 1
12534: PUSH
12535: LD_INT 1
12537: ARRAY
12538: PPUSH
12539: LD_INT 36
12541: PPUSH
12542: LD_INT 17
12544: PPUSH
12545: CALL_OW 171
// Say ( Kaia , DK-1-apesol ) ;
12549: LD_EXP 29
12553: PPUSH
12554: LD_STRING DK-1-apesol
12556: PPUSH
12557: CALL_OW 88
// Say ( Aviradze , DA-1-apesol ) ;
12561: LD_EXP 28
12565: PPUSH
12566: LD_STRING DA-1-apesol
12568: PPUSH
12569: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12573: LD_EXP 29
12577: PPUSH
12578: LD_STRING DK-2-apesol
12580: PPUSH
12581: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12585: LD_EXP 28
12589: PPUSH
12590: LD_STRING DA-2-apesol
12592: PPUSH
12593: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12597: LD_EXP 29
12601: PPUSH
12602: LD_STRING DK-3-apesol
12604: PPUSH
12605: CALL_OW 88
// Video ( false ) ;
12609: LD_INT 0
12611: PPUSH
12612: CALL 991 0 1
// end ;
12616: PPOPN 1
12618: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) do var ape ;
12619: LD_EXP 30
12623: PPUSH
12624: CALL_OW 302
12628: PUSH
12629: LD_INT 22
12631: PUSH
12632: LD_INT 2
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: PUSH
12639: LD_INT 25
12641: PUSH
12642: LD_INT 16
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: PUSH
12649: EMPTY
12650: LIST
12651: LIST
12652: PPUSH
12653: CALL_OW 69
12657: AND
12658: IFFALSE 12930
12660: GO 12662
12662: DISABLE
12663: LD_INT 0
12665: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
12666: LD_ADDR_VAR 0 1
12670: PUSH
12671: LD_INT 22
12673: PUSH
12674: LD_INT 2
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: LD_INT 25
12683: PUSH
12684: LD_INT 16
12686: PUSH
12687: EMPTY
12688: LIST
12689: LIST
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: PPUSH
12695: CALL_OW 69
12699: ST_TO_ADDR
// Video ( true ) ;
12700: LD_INT 1
12702: PPUSH
12703: CALL 991 0 1
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
12707: LD_INT 5
12709: PPUSH
12710: LD_INT 35
12712: PPUSH
12713: LD_INT 22
12715: PPUSH
12716: LD_INT 1
12718: PPUSH
12719: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
12723: LD_EXP 30
12727: PPUSH
12728: LD_VAR 0 1
12732: PUSH
12733: LD_INT 1
12735: ARRAY
12736: PPUSH
12737: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
12741: LD_VAR 0 1
12745: PUSH
12746: LD_INT 1
12748: ARRAY
12749: PPUSH
12750: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12754: LD_VAR 0 1
12758: PUSH
12759: LD_INT 1
12761: ARRAY
12762: PPUSH
12763: CALL_OW 122
// wait ( 0 0$2 ) ;
12767: LD_INT 70
12769: PPUSH
12770: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
12774: LD_EXP 30
12778: PPUSH
12779: LD_STRING DS-1-apeeng
12781: PPUSH
12782: CALL_OW 88
// if IsOk ( Kamil ) then
12786: LD_EXP 27
12790: PPUSH
12791: CALL_OW 302
12795: IFFALSE 12923
// begin Say ( Kamil , DKam-1-apeeng ) ;
12797: LD_EXP 27
12801: PPUSH
12802: LD_STRING DKam-1-apeeng
12804: PPUSH
12805: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
12809: LD_EXP 30
12813: PPUSH
12814: LD_STRING DS-2-apeeng
12816: PPUSH
12817: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
12821: LD_EXP 27
12825: PPUSH
12826: LD_STRING DKam-2-apeeng
12828: PPUSH
12829: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
12833: LD_EXP 30
12837: PPUSH
12838: LD_STRING DS-3-apeeng
12840: PPUSH
12841: CALL_OW 88
// if not IsOK ( Kaia ) then
12845: LD_EXP 29
12849: PPUSH
12850: CALL_OW 302
12854: NOT
12855: IFFALSE 12866
// begin Video ( false ) ;
12857: LD_INT 0
12859: PPUSH
12860: CALL 991 0 1
// exit ;
12864: GO 12930
// end ; Say ( Kaia , DK-1-apeeng ) ;
12866: LD_EXP 29
12870: PPUSH
12871: LD_STRING DK-1-apeeng
12873: PPUSH
12874: CALL_OW 88
// if not IsOk ( Givi ) then
12878: LD_EXP 25
12882: PPUSH
12883: CALL_OW 302
12887: NOT
12888: IFFALSE 12899
// begin Video ( false ) ;
12890: LD_INT 0
12892: PPUSH
12893: CALL 991 0 1
// exit ;
12897: GO 12930
// end ; Say ( Givi , DG-1-apeeng ) ;
12899: LD_EXP 25
12903: PPUSH
12904: LD_STRING DG-1-apeeng
12906: PPUSH
12907: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
12911: LD_EXP 29
12915: PPUSH
12916: LD_STRING DK-2-apeeng
12918: PPUSH
12919: CALL_OW 88
// end ; Video ( false ) ;
12923: LD_INT 0
12925: PPUSH
12926: CALL 991 0 1
// end ;
12930: PPOPN 1
12932: END
// every 0 0$1 trigger farmerBaseReady do
12933: LD_EXP 4
12937: IFFALSE 13095
12939: GO 12941
12941: DISABLE
// begin DialogueOn ;
12942: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
12946: LD_EXP 32
12950: PPUSH
12951: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
12955: LD_EXP 32
12959: PPUSH
12960: LD_STRING DF-1-distribution
12962: PPUSH
12963: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
12967: LD_EXP 24
12971: PPUSH
12972: LD_STRING DH-2-distribution
12974: PPUSH
12975: CALL_OW 88
// if IsOk ( Kaia ) then
12979: LD_EXP 29
12983: PPUSH
12984: CALL_OW 302
12988: IFFALSE 13049
// begin Say ( Kaia , DK-1-distribution ) ;
12990: LD_EXP 29
12994: PPUSH
12995: LD_STRING DK-1-distribution
12997: PPUSH
12998: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13002: LD_EXP 24
13006: PPUSH
13007: LD_STRING DH-1-distribution
13009: PPUSH
13010: CALL_OW 88
// if IsOk ( Givi ) then
13014: LD_EXP 25
13018: PPUSH
13019: CALL_OW 302
13023: IFFALSE 13049
// begin Say ( Givi , DG-1-distribution ) ;
13025: LD_EXP 25
13029: PPUSH
13030: LD_STRING DG-1-distribution
13032: PPUSH
13033: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13037: LD_EXP 24
13041: PPUSH
13042: LD_STRING DH-3-distribution
13044: PPUSH
13045: CALL_OW 88
// end ; end ; DialogueOff ;
13049: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13053: LD_STRING Crates1
13055: PPUSH
13056: CALL_OW 337
// farmerRequestedCrates := 300 ;
13060: LD_ADDR_EXP 13
13064: PUSH
13065: LD_INT 300
13067: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13068: LD_STRING FarmerCrates
13070: PPUSH
13071: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13075: LD_INT 10
13077: PPUSH
13078: LD_INT 1
13080: PPUSH
13081: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13085: LD_INT 108
13087: PPUSH
13088: LD_INT 61
13090: PPUSH
13091: CALL_OW 86
// end ;
13095: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13096: LD_EXP 6
13100: PUSH
13101: LD_INT 22
13103: PUSH
13104: LD_INT 2
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: PUSH
13111: LD_INT 3
13113: PUSH
13114: LD_INT 57
13116: PUSH
13117: EMPTY
13118: LIST
13119: PUSH
13120: EMPTY
13121: LIST
13122: LIST
13123: PUSH
13124: LD_INT 2
13126: PUSH
13127: LD_INT 30
13129: PUSH
13130: LD_INT 6
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: PUSH
13137: LD_INT 30
13139: PUSH
13140: LD_INT 7
13142: PUSH
13143: EMPTY
13144: LIST
13145: LIST
13146: PUSH
13147: EMPTY
13148: LIST
13149: LIST
13150: LIST
13151: PUSH
13152: EMPTY
13153: LIST
13154: LIST
13155: LIST
13156: PPUSH
13157: CALL_OW 69
13161: AND
13162: PUSH
13163: LD_INT 22
13165: PUSH
13166: LD_INT 2
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PUSH
13173: LD_INT 3
13175: PUSH
13176: LD_INT 57
13178: PUSH
13179: EMPTY
13180: LIST
13181: PUSH
13182: EMPTY
13183: LIST
13184: LIST
13185: PUSH
13186: LD_INT 30
13188: PUSH
13189: LD_INT 4
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PUSH
13196: EMPTY
13197: LIST
13198: LIST
13199: LIST
13200: PPUSH
13201: CALL_OW 69
13205: AND
13206: IFFALSE 13370
13208: GO 13210
13210: DISABLE
13211: LD_INT 0
13213: PPUSH
// begin wait ( 0 0$10 ) ;
13214: LD_INT 350
13216: PPUSH
13217: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13221: LD_ADDR_VAR 0 1
13225: PUSH
13226: LD_EXP 38
13230: PPUSH
13231: LD_INT 26
13233: PUSH
13234: LD_INT 1
13236: PUSH
13237: EMPTY
13238: LIST
13239: LIST
13240: PUSH
13241: LD_INT 25
13243: PUSH
13244: LD_INT 2
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: PUSH
13251: EMPTY
13252: LIST
13253: LIST
13254: PPUSH
13255: CALL_OW 72
13259: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13260: LD_EXP 24
13264: PPUSH
13265: LD_STRING DH-1-task
13267: PPUSH
13268: CALL_OW 88
// if IsOk ( Sophia ) then
13272: LD_EXP 30
13276: PPUSH
13277: CALL_OW 302
13281: IFFALSE 13321
// begin Say ( Sophia , DS-1-task ) ;
13283: LD_EXP 30
13287: PPUSH
13288: LD_STRING DS-1-task
13290: PPUSH
13291: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13295: LD_EXP 30
13299: PPUSH
13300: LD_STRING DS-2-task
13302: PPUSH
13303: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13307: LD_EXP 24
13311: PPUSH
13312: LD_STRING DH-2-task
13314: PPUSH
13315: CALL_OW 88
// end else
13319: GO 13355
// if eng then
13321: LD_VAR 0 1
13325: IFFALSE 13355
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13327: LD_VAR 0 1
13331: PUSH
13332: LD_INT 1
13334: ARRAY
13335: PPUSH
13336: LD_STRING DArm-1-task
13338: PPUSH
13339: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13343: LD_EXP 24
13347: PPUSH
13348: LD_STRING DH-2-task
13350: PPUSH
13351: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13355: LD_STRING BaseConstructed
13357: PPUSH
13358: CALL_OW 337
// allowConvoys := true ;
13362: LD_ADDR_EXP 11
13366: PUSH
13367: LD_INT 1
13369: ST_TO_ADDR
// end ;
13370: PPOPN 1
13372: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13373: LD_INT 22
13375: PUSH
13376: LD_INT 4
13378: PUSH
13379: EMPTY
13380: LIST
13381: LIST
13382: PUSH
13383: LD_INT 34
13385: PUSH
13386: LD_INT 12
13388: PUSH
13389: EMPTY
13390: LIST
13391: LIST
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: PPUSH
13397: CALL_OW 69
13401: IFFALSE 13569
13403: GO 13405
13405: DISABLE
13406: LD_INT 0
13408: PPUSH
13409: PPUSH
13410: PPUSH
// begin wait ( 0 0$2 ) ;
13411: LD_INT 70
13413: PPUSH
13414: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13418: LD_ADDR_VAR 0 1
13422: PUSH
13423: LD_INT 22
13425: PUSH
13426: LD_INT 4
13428: PUSH
13429: EMPTY
13430: LIST
13431: LIST
13432: PUSH
13433: LD_INT 34
13435: PUSH
13436: LD_INT 12
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: PPUSH
13447: CALL_OW 69
13451: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13452: LD_ADDR_VAR 0 2
13456: PUSH
13457: LD_VAR 0 1
13461: PUSH
13462: LD_INT 1
13464: ARRAY
13465: PPUSH
13466: CALL_OW 250
13470: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13471: LD_ADDR_VAR 0 3
13475: PUSH
13476: LD_VAR 0 1
13480: PUSH
13481: LD_INT 1
13483: ARRAY
13484: PPUSH
13485: CALL_OW 251
13489: ST_TO_ADDR
// DialogueOn ;
13490: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13494: LD_VAR 0 2
13498: PPUSH
13499: LD_VAR 0 3
13503: PPUSH
13504: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13508: LD_VAR 0 2
13512: PPUSH
13513: LD_VAR 0 3
13517: PPUSH
13518: LD_INT 2
13520: PPUSH
13521: LD_INT 6
13523: NEG
13524: PPUSH
13525: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13529: LD_INT 10
13531: PPUSH
13532: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13536: LD_EXP 24
13540: PPUSH
13541: LD_STRING DH-1-seecargo
13543: PPUSH
13544: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_VAR 0 3
13557: PPUSH
13558: LD_INT 2
13560: PPUSH
13561: CALL_OW 331
// DialogueOff ;
13565: CALL_OW 7
// end ;
13569: PPOPN 3
13571: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13572: LD_EXP 4
13576: PUSH
13577: LD_EXP 12
13581: PUSH
13582: LD_INT 300
13584: GREATEREQUAL
13585: AND
13586: IFFALSE 13658
13588: GO 13590
13590: DISABLE
// begin DialogueOn ;
13591: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13595: LD_EXP 32
13599: PPUSH
13600: LD_STRING DF-1-delivery-2
13602: PPUSH
13603: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13607: LD_EXP 24
13611: PPUSH
13612: LD_STRING DH-1-delivery-2
13614: PPUSH
13615: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
13619: LD_EXP 32
13623: PPUSH
13624: LD_STRING DF-2-delivery-2
13626: PPUSH
13627: CALL_OW 94
// DialogueOff ;
13631: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
13635: LD_STRING Crates2
13637: PPUSH
13638: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13642: LD_ADDR_EXP 14
13646: PUSH
13647: LD_INT 63000
13649: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
13650: LD_ADDR_EXP 13
13654: PUSH
13655: LD_INT 600
13657: ST_TO_ADDR
// end ;
13658: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 do
13659: LD_EXP 4
13663: PUSH
13664: LD_EXP 12
13668: PUSH
13669: LD_INT 600
13671: GREATEREQUAL
13672: AND
13673: IFFALSE 13839
13675: GO 13677
13677: DISABLE
// begin DialogueOn ;
13678: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
13682: LD_EXP 32
13686: PPUSH
13687: LD_STRING DF-1-delivery-3
13689: PPUSH
13690: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
13694: LD_EXP 24
13698: PPUSH
13699: LD_STRING DH-1-delivery-3
13701: PPUSH
13702: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
13706: LD_EXP 32
13710: PPUSH
13711: LD_STRING DF-2-delivery-3
13713: PPUSH
13714: CALL_OW 94
// if IsOk ( Kaia ) then
13718: LD_EXP 29
13722: PPUSH
13723: CALL_OW 302
13727: IFFALSE 13777
// begin Say ( Kaia , DK-1-delivery-3 ) ;
13729: LD_EXP 29
13733: PPUSH
13734: LD_STRING DK-1-delivery-3
13736: PPUSH
13737: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
13741: LD_EXP 24
13745: PPUSH
13746: LD_STRING DH-2-delivery-3
13748: PPUSH
13749: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
13753: LD_EXP 25
13757: PPUSH
13758: LD_STRING DG-1-delivery-3
13760: PPUSH
13761: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
13765: LD_EXP 26
13769: PPUSH
13770: LD_STRING DM-1-delivery-3
13772: PPUSH
13773: CALL_OW 88
// end ; DialogueOff ;
13777: CALL_OW 7
// if Difficulty = 2 then
13781: LD_OWVAR 67
13785: PUSH
13786: LD_INT 2
13788: EQUAL
13789: IFFALSE 13816
// begin ChangeMissionObjectives ( Crates3 ) ;
13791: LD_STRING Crates3
13793: PPUSH
13794: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13798: LD_ADDR_EXP 14
13802: PUSH
13803: LD_INT 63000
13805: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
13806: LD_ADDR_EXP 13
13810: PUSH
13811: LD_INT 900
13813: ST_TO_ADDR
// end else
13814: GO 13839
// begin ChangeMissionObjectives ( Crates4 ) ;
13816: LD_STRING Crates4
13818: PPUSH
13819: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13823: LD_ADDR_EXP 14
13827: PUSH
13828: LD_INT 63000
13830: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
13831: LD_ADDR_EXP 13
13835: PUSH
13836: LD_INT 1200
13838: ST_TO_ADDR
// end ; end ;
13839: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
13840: LD_EXP 4
13844: PUSH
13845: LD_EXP 12
13849: PUSH
13850: LD_INT 600
13852: PUSH
13853: LD_INT 900
13855: PUSH
13856: LD_INT 1200
13858: PUSH
13859: EMPTY
13860: LIST
13861: LIST
13862: LIST
13863: PUSH
13864: LD_OWVAR 67
13868: ARRAY
13869: GREATEREQUAL
13870: AND
13871: PUSH
13872: LD_EXP 13
13876: PUSH
13877: LD_EXP 14
13881: LESSEQUAL
13882: AND
13883: IFFALSE 13956
13885: GO 13887
13887: DISABLE
// begin retreatAllowed := true ;
13888: LD_ADDR_EXP 10
13892: PUSH
13893: LD_INT 1
13895: ST_TO_ADDR
// display_strings := [ ] ;
13896: LD_ADDR_OWVAR 47
13900: PUSH
13901: EMPTY
13902: ST_TO_ADDR
// DialogueOn ;
13903: CALL_OW 6
// Video ( true ) ;
13907: LD_INT 1
13909: PPUSH
13910: CALL 991 0 1
// SayRadio ( Omar , DO-radio-end ) ;
13914: LD_EXP 33
13918: PPUSH
13919: LD_STRING DO-radio-end
13921: PPUSH
13922: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
13926: LD_EXP 24
13930: PPUSH
13931: LD_STRING DH-1-radio-end
13933: PPUSH
13934: CALL_OW 88
// Video ( false ) ;
13938: LD_INT 0
13940: PPUSH
13941: CALL 991 0 1
// DialogueOff ;
13945: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
13949: LD_STRING Retreat
13951: PPUSH
13952: CALL_OW 337
// end ;
13956: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
13957: LD_EXP 10
13961: IFFALSE 14131
13963: GO 13965
13965: DISABLE
13966: LD_INT 0
13968: PPUSH
13969: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
13970: LD_INT 10
13972: PPUSH
13973: LD_INT 0
13975: PPUSH
13976: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
13980: LD_ADDR_VAR 0 1
13984: PUSH
13985: LD_EXP 35
13989: PPUSH
13990: LD_INT 25
13992: PUSH
13993: LD_INT 2
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: PPUSH
14000: CALL_OW 72
14004: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14005: LD_VAR 0 1
14009: PUSH
14010: LD_INT 102
14012: PPUSH
14013: LD_INT 69
14015: PPUSH
14016: CALL_OW 428
14020: PUSH
14021: LD_INT 0
14023: EQUAL
14024: AND
14025: IFFALSE 14127
// begin SetResourceType ( GetBase ( arDepot ) , mat_cans , GetResourceType ( GetBase ( arDepot ) , mat_cans ) + 10 ) ;
14027: LD_INT 5
14029: PPUSH
14030: CALL_OW 274
14034: PPUSH
14035: LD_INT 1
14037: PPUSH
14038: LD_INT 5
14040: PPUSH
14041: CALL_OW 274
14045: PPUSH
14046: LD_INT 1
14048: PPUSH
14049: CALL_OW 275
14053: PUSH
14054: LD_INT 10
14056: PLUS
14057: PPUSH
14058: CALL_OW 277
// for i in tmp do
14062: LD_ADDR_VAR 0 2
14066: PUSH
14067: LD_VAR 0 1
14071: PUSH
14072: FOR_IN
14073: IFFALSE 14097
// if IsInUnit ( i ) then
14075: LD_VAR 0 2
14079: PPUSH
14080: CALL_OW 310
14084: IFFALSE 14095
// ComExitBuilding ( i ) ;
14086: LD_VAR 0 2
14090: PPUSH
14091: CALL_OW 122
14095: GO 14072
14097: POP
14098: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14099: LD_VAR 0 1
14103: PPUSH
14104: LD_INT 31
14106: PPUSH
14107: LD_INT 102
14109: PPUSH
14110: LD_INT 69
14112: PPUSH
14113: LD_INT 2
14115: PPUSH
14116: CALL_OW 205
// wait ( 0 0$3 ) ;
14120: LD_INT 105
14122: PPUSH
14123: CALL_OW 67
// end ; StartCargoEvacuation ;
14127: CALL 4457 0 0
// end ;
14131: PPOPN 2
14133: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14134: LD_EXP 10
14138: NOT
14139: PUSH
14140: LD_INT 5
14142: PPUSH
14143: CALL_OW 301
14147: AND
14148: IFFALSE 14172
14150: GO 14152
14152: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
14153: LD_EXP 32
14157: PPUSH
14158: LD_STRING DF-1-failure
14160: PPUSH
14161: CALL_OW 94
// YouLost ( FarmerDepot ) ;
14165: LD_STRING FarmerDepot
14167: PPUSH
14168: CALL_OW 104
// end ;
14172: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 do var i , max , tmp ;
14173: LD_EXP 10
14177: PUSH
14178: LD_EXP 24
14182: PPUSH
14183: LD_EXP 32
14187: PPUSH
14188: CALL_OW 296
14192: PUSH
14193: LD_INT 6
14195: LESS
14196: AND
14197: IFFALSE 14783
14199: GO 14201
14201: DISABLE
14202: LD_INT 0
14204: PPUSH
14205: PPUSH
14206: PPUSH
// begin allowConvoys := false ;
14207: LD_ADDR_EXP 11
14211: PUSH
14212: LD_INT 0
14214: ST_TO_ADDR
// Video ( true ) ;
14215: LD_INT 1
14217: PPUSH
14218: CALL 991 0 1
// ComTurnUnit ( Heike , Farmer ) ;
14222: LD_EXP 24
14226: PPUSH
14227: LD_EXP 32
14231: PPUSH
14232: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14236: LD_EXP 32
14240: PPUSH
14241: LD_EXP 24
14245: PPUSH
14246: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14250: LD_EXP 32
14254: PPUSH
14255: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14259: LD_EXP 24
14263: PPUSH
14264: LD_STRING DH-1-end
14266: PPUSH
14267: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14271: LD_EXP 32
14275: PPUSH
14276: LD_STRING DF-1-end
14278: PPUSH
14279: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14283: LD_EXP 32
14287: PPUSH
14288: LD_STRING DF-2-end
14290: PPUSH
14291: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14295: LD_EXP 24
14299: PPUSH
14300: LD_STRING DH-2-end
14302: PPUSH
14303: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14307: LD_EXP 32
14311: PPUSH
14312: LD_STRING DF-3-end
14314: PPUSH
14315: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14319: LD_EXP 24
14323: PPUSH
14324: LD_STRING DH-3-end
14326: PPUSH
14327: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14331: LD_EXP 25
14335: PPUSH
14336: LD_STRING DG-1-end
14338: PPUSH
14339: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14343: LD_EXP 24
14347: PPUSH
14348: LD_STRING DH-4-end
14350: PPUSH
14351: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14355: LD_EXP 32
14359: PPUSH
14360: LD_STRING DF-4-end
14362: PPUSH
14363: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14367: LD_EXP 24
14371: PPUSH
14372: LD_STRING DH-5-end
14374: PPUSH
14375: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14379: LD_EXP 32
14383: PPUSH
14384: LD_STRING DF-5-end
14386: PPUSH
14387: CALL_OW 88
// Video ( false ) ;
14391: LD_INT 0
14393: PPUSH
14394: CALL 991 0 1
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14398: LD_ADDR_VAR 0 2
14402: PUSH
14403: LD_INT 4
14405: PUSH
14406: LD_INT 3
14408: PUSH
14409: LD_INT 2
14411: PUSH
14412: EMPTY
14413: LIST
14414: LIST
14415: LIST
14416: PUSH
14417: LD_OWVAR 67
14421: ARRAY
14422: ST_TO_ADDR
// if farmerSquad < max then
14423: LD_EXP 35
14427: PUSH
14428: LD_VAR 0 2
14432: LESS
14433: IFFALSE 14445
// max := farmerSquad ;
14435: LD_ADDR_VAR 0 2
14439: PUSH
14440: LD_EXP 35
14444: ST_TO_ADDR
// for i := 1 to max do
14445: LD_ADDR_VAR 0 1
14449: PUSH
14450: DOUBLE
14451: LD_INT 1
14453: DEC
14454: ST_TO_ADDR
14455: LD_VAR 0 2
14459: PUSH
14460: FOR_TO
14461: IFFALSE 14499
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14463: LD_EXP 35
14467: PUSH
14468: LD_INT 1
14470: ARRAY
14471: PPUSH
14472: LD_INT 2
14474: PPUSH
14475: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14479: LD_ADDR_EXP 35
14483: PUSH
14484: LD_EXP 35
14488: PPUSH
14489: LD_INT 1
14491: PPUSH
14492: CALL_OW 3
14496: ST_TO_ADDR
// end ;
14497: GO 14460
14499: POP
14500: POP
// for i in Farmer ^ farmerSquad do
14501: LD_ADDR_VAR 0 1
14505: PUSH
14506: LD_EXP 32
14510: PUSH
14511: LD_EXP 35
14515: ADD
14516: PUSH
14517: FOR_IN
14518: IFFALSE 14557
// begin if IsInUnit ( i ) then
14520: LD_VAR 0 1
14524: PPUSH
14525: CALL_OW 310
14529: IFFALSE 14540
// ComExitBuilding ( i ) ;
14531: LD_VAR 0 1
14535: PPUSH
14536: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14540: LD_VAR 0 1
14544: PPUSH
14545: LD_INT 102
14547: PPUSH
14548: LD_INT 7
14550: PPUSH
14551: CALL_OW 171
// end ;
14555: GO 14517
14557: POP
14558: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14559: LD_ADDR_VAR 0 1
14563: PUSH
14564: LD_INT 22
14566: PUSH
14567: LD_INT 5
14569: PUSH
14570: EMPTY
14571: LIST
14572: LIST
14573: PUSH
14574: LD_INT 21
14576: PUSH
14577: LD_INT 3
14579: PUSH
14580: EMPTY
14581: LIST
14582: LIST
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: PPUSH
14588: CALL_OW 69
14592: PUSH
14593: LD_INT 5
14595: DIFF
14596: PUSH
14597: FOR_IN
14598: IFFALSE 14614
// SetSide ( i , 2 ) ;
14600: LD_VAR 0 1
14604: PPUSH
14605: LD_INT 2
14607: PPUSH
14608: CALL_OW 235
14612: GO 14597
14614: POP
14615: POP
// repeat wait ( 0 0$1 ) ;
14616: LD_INT 35
14618: PPUSH
14619: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
14623: LD_ADDR_VAR 0 3
14627: PUSH
14628: LD_EXP 32
14632: PUSH
14633: LD_EXP 35
14637: ADD
14638: PPUSH
14639: LD_INT 95
14641: PUSH
14642: LD_INT 3
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: PPUSH
14649: CALL_OW 72
14653: ST_TO_ADDR
// if tmp then
14654: LD_VAR 0 3
14658: IFFALSE 14702
// for i in tmp do
14660: LD_ADDR_VAR 0 1
14664: PUSH
14665: LD_VAR 0 3
14669: PUSH
14670: FOR_IN
14671: IFFALSE 14700
// begin farmerSquad := farmerSquad diff i ;
14673: LD_ADDR_EXP 35
14677: PUSH
14678: LD_EXP 35
14682: PUSH
14683: LD_VAR 0 1
14687: DIFF
14688: ST_TO_ADDR
// RemoveUnit ( i ) ;
14689: LD_VAR 0 1
14693: PPUSH
14694: CALL_OW 64
// end ;
14698: GO 14670
14700: POP
14701: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
14702: LD_EXP 35
14706: PUSH
14707: EMPTY
14708: EQUAL
14709: PUSH
14710: LD_EXP 32
14714: PPUSH
14715: CALL_OW 305
14719: NOT
14720: AND
14721: IFFALSE 14616
// wait ( 1 1$00 ) ;
14723: LD_INT 2100
14725: PPUSH
14726: CALL_OW 67
// SendAttack ;
14730: CALL 6841 0 0
// wait ( [ 5 5$00 , 4 4$30 , 4 4$00 ] [ Difficulty ] ) ;
14734: LD_INT 10500
14736: PUSH
14737: LD_INT 9450
14739: PUSH
14740: LD_INT 8400
14742: PUSH
14743: EMPTY
14744: LIST
14745: LIST
14746: LIST
14747: PUSH
14748: LD_OWVAR 67
14752: ARRAY
14753: PPUSH
14754: CALL_OW 67
// SendAttack ;
14758: CALL 6841 0 0
// if Difficulty > 2 then
14762: LD_OWVAR 67
14766: PUSH
14767: LD_INT 2
14769: GREATER
14770: IFFALSE 14783
// begin wait ( 4 4$00 ) ;
14772: LD_INT 8400
14774: PPUSH
14775: CALL_OW 67
// SendAttack ;
14779: CALL 6841 0 0
// end ; end ;
14783: PPOPN 3
14785: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
14786: LD_EXP 14
14790: PUSH
14791: LD_INT 18900
14793: LESSEQUAL
14794: IFFALSE 14843
14796: GO 14798
14798: DISABLE
// begin DialogueOn ;
14799: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
14803: LD_EXP 32
14807: PPUSH
14808: LD_STRING DF-1-distribution-a
14810: PPUSH
14811: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
14815: LD_EXP 24
14819: PPUSH
14820: LD_STRING DH-1-distribution-a
14822: PPUSH
14823: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
14827: LD_EXP 32
14831: PPUSH
14832: LD_STRING DF-2-distribution-a
14834: PPUSH
14835: CALL_OW 94
// DialogueOff ;
14839: CALL_OW 7
// end ;
14843: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
14844: LD_EXP 14
14848: PUSH
14849: LD_INT 0
14851: LESSEQUAL
14852: IFFALSE 14884
14854: GO 14856
14856: DISABLE
// begin DialogueOn ;
14857: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
14861: LD_EXP 32
14865: PPUSH
14866: LD_STRING DF-3-distribution-a
14868: PPUSH
14869: CALL_OW 94
// YouLost ( Distribution ) ;
14873: LD_STRING Distribution
14875: PPUSH
14876: CALL_OW 104
// DialogueOff ;
14880: CALL_OW 7
// end ;
14884: END
// every 0 0$1 trigger vehCounter >= 2 do
14885: LD_EXP 18
14889: PUSH
14890: LD_INT 2
14892: GREATEREQUAL
14893: IFFALSE 14905
14895: GO 14897
14897: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
14898: LD_STRING VehConstructed
14900: PPUSH
14901: CALL_OW 337
14905: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
14906: LD_INT 22
14908: PUSH
14909: LD_INT 2
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: PUSH
14916: LD_INT 34
14918: PUSH
14919: LD_INT 12
14921: PUSH
14922: EMPTY
14923: LIST
14924: LIST
14925: PUSH
14926: EMPTY
14927: LIST
14928: LIST
14929: PPUSH
14930: CALL_OW 69
14934: IFFALSE 14994
14936: GO 14938
14938: DISABLE
// begin DialogueOn ;
14939: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
14943: LD_EXP 24
14947: PPUSH
14948: LD_STRING DH-1-truck
14950: PPUSH
14951: CALL_OW 88
// if IsOk ( Markov ) then
14955: LD_EXP 31
14959: PPUSH
14960: CALL_OW 302
14964: IFFALSE 14990
// begin Say ( Markov , DMar-1-truck ) ;
14966: LD_EXP 31
14970: PPUSH
14971: LD_STRING DMar-1-truck
14973: PPUSH
14974: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
14978: LD_EXP 24
14982: PPUSH
14983: LD_STRING DH-2-truck
14985: PPUSH
14986: CALL_OW 88
// end ; DialogueOff ;
14990: CALL_OW 7
// end ;
14994: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
14995: LD_INT 0
14997: PPUSH
14998: PPUSH
14999: PPUSH
// if IsOk ( Givi ) then
15000: LD_EXP 25
15004: PPUSH
15005: CALL_OW 302
15009: IFFALSE 15025
// begin Say ( Givi , DG-1-nocargo ) ;
15011: LD_EXP 25
15015: PPUSH
15016: LD_STRING DG-1-nocargo
15018: PPUSH
15019: CALL_OW 88
// exit ;
15023: GO 15121
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15025: LD_ADDR_VAR 0 2
15029: PUSH
15030: LD_EXP 38
15034: PPUSH
15035: LD_INT 26
15037: PUSH
15038: LD_INT 1
15040: PUSH
15041: EMPTY
15042: LIST
15043: LIST
15044: PPUSH
15045: CALL_OW 72
15049: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_EXP 38
15059: PPUSH
15060: LD_INT 26
15062: PUSH
15063: LD_INT 2
15065: PUSH
15066: EMPTY
15067: LIST
15068: LIST
15069: PPUSH
15070: CALL_OW 72
15074: ST_TO_ADDR
// if randomMen then
15075: LD_VAR 0 2
15079: IFFALSE 15099
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15081: LD_VAR 0 2
15085: PUSH
15086: LD_INT 1
15088: ARRAY
15089: PPUSH
15090: LD_STRING DArm-1-nocargo
15092: PPUSH
15093: CALL_OW 88
15097: GO 15121
// if randomWomen then
15099: LD_VAR 0 3
15103: IFFALSE 15121
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15105: LD_VAR 0 3
15109: PUSH
15110: LD_INT 1
15112: ARRAY
15113: PPUSH
15114: LD_STRING DArf-1-nocargo
15116: PPUSH
15117: CALL_OW 88
// end ;
15121: LD_VAR 0 1
15125: RET
// export function IncomingAttack ; begin
15126: LD_INT 0
15128: PPUSH
// if attackWave = 1 then
15129: LD_EXP 16
15133: PUSH
15134: LD_INT 1
15136: EQUAL
15137: IFFALSE 15208
// begin DialogueOn ;
15139: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15143: LD_EXP 33
15147: PPUSH
15148: LD_STRING DO-1-radio-1
15150: PPUSH
15151: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15155: LD_EXP 24
15159: PPUSH
15160: LD_STRING DH-1-radio-1-
15162: PPUSH
15163: CALL_OW 88
// if IsOk ( Markov ) then
15167: LD_EXP 31
15171: PPUSH
15172: CALL_OW 302
15176: IFFALSE 15202
// begin Say ( Markov , DMar-1-radio-1 ) ;
15178: LD_EXP 31
15182: PPUSH
15183: LD_STRING DMar-1-radio-1
15185: PPUSH
15186: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15190: LD_EXP 24
15194: PPUSH
15195: LD_STRING DH-2-radio-1
15197: PPUSH
15198: CALL_OW 88
// end ; DialogueOff ;
15202: CALL_OW 7
// end else
15206: GO 15232
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15208: LD_EXP 33
15212: PPUSH
15213: LD_STRING DO-1-radio-u
15215: PPUSH
15216: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15220: LD_EXP 24
15224: PPUSH
15225: LD_STRING DH-1-radio-u
15227: PPUSH
15228: CALL_OW 88
// end ; end ;
15232: LD_VAR 0 1
15236: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15237: LD_EXP 40
15241: PPUSH
15242: LD_INT 95
15244: PUSH
15245: LD_INT 8
15247: PUSH
15248: EMPTY
15249: LIST
15250: LIST
15251: PPUSH
15252: CALL_OW 72
15256: IFFALSE 15359
15258: GO 15260
15260: DISABLE
15261: LD_INT 0
15263: PPUSH
// begin enable ;
15264: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15265: LD_ADDR_VAR 0 1
15269: PUSH
15270: LD_EXP 40
15274: PPUSH
15275: LD_INT 95
15277: PUSH
15278: LD_INT 8
15280: PUSH
15281: EMPTY
15282: LIST
15283: LIST
15284: PPUSH
15285: CALL_OW 72
15289: PUSH
15290: FOR_IN
15291: IFFALSE 15320
// begin usForces := usForces diff i ;
15293: LD_ADDR_EXP 40
15297: PUSH
15298: LD_EXP 40
15302: PUSH
15303: LD_VAR 0 1
15307: DIFF
15308: ST_TO_ADDR
// RemoveUnit ( i ) ;
15309: LD_VAR 0 1
15313: PPUSH
15314: CALL_OW 64
// end ;
15318: GO 15290
15320: POP
15321: POP
// if not americanHasEscaped and attackWave = 1 then
15322: LD_EXP 7
15326: NOT
15327: PUSH
15328: LD_EXP 16
15332: PUSH
15333: LD_INT 1
15335: EQUAL
15336: AND
15337: IFFALSE 15359
// begin americanHasEscaped := true ;
15339: LD_ADDR_EXP 7
15343: PUSH
15344: LD_INT 1
15346: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15347: LD_EXP 24
15351: PPUSH
15352: LD_STRING DH-2-assault-a
15354: PPUSH
15355: CALL_OW 88
// end ; end ;
15359: PPOPN 1
15361: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) do
15362: LD_INT 4
15364: PPUSH
15365: LD_INT 22
15367: PUSH
15368: LD_INT 1
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PPUSH
15375: CALL_OW 70
15379: IFFALSE 15396
15381: GO 15383
15383: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15384: LD_EXP 32
15388: PPUSH
15389: LD_STRING DF-1-attack
15391: PPUSH
15392: CALL_OW 94
15396: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15397: LD_INT 5
15399: PPUSH
15400: CALL_OW 255
15404: PUSH
15405: LD_INT 2
15407: EQUAL
15408: IFFALSE 15420
15410: GO 15412
15412: DISABLE
// YouLost ( Attack ) ;
15413: LD_STRING Attack
15415: PPUSH
15416: CALL_OW 104
15420: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 160 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot ;
15421: LD_INT 22
15423: PUSH
15424: LD_INT 1
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PUSH
15431: LD_INT 21
15433: PUSH
15434: LD_INT 1
15436: PUSH
15437: EMPTY
15438: LIST
15439: LIST
15440: PUSH
15441: EMPTY
15442: LIST
15443: LIST
15444: PPUSH
15445: CALL_OW 69
15449: NOT
15450: PUSH
15451: LD_INT 22
15453: PUSH
15454: LD_INT 4
15456: PUSH
15457: EMPTY
15458: LIST
15459: LIST
15460: PPUSH
15461: CALL_OW 69
15465: NOT
15466: AND
15467: PUSH
15468: LD_EXP 10
15472: NOT
15473: AND
15474: PUSH
15475: LD_EXP 12
15479: PUSH
15480: LD_INT 160
15482: GREATER
15483: AND
15484: PUSH
15485: LD_INT 7
15487: PPUSH
15488: LD_INT 22
15490: PUSH
15491: LD_INT 2
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: LD_INT 21
15500: PUSH
15501: LD_INT 1
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: PUSH
15508: EMPTY
15509: LIST
15510: LIST
15511: PPUSH
15512: CALL_OW 70
15516: AND
15517: PUSH
15518: LD_INT 22
15520: PUSH
15521: LD_INT 2
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: PUSH
15528: LD_INT 30
15530: PUSH
15531: LD_INT 0
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PUSH
15538: EMPTY
15539: LIST
15540: LIST
15541: PPUSH
15542: CALL_OW 69
15546: AND
15547: IFFALSE 16344
15549: GO 15551
15551: DISABLE
15552: LD_INT 0
15554: PPUSH
15555: PPUSH
15556: PPUSH
15557: PPUSH
15558: PPUSH
// begin depot := usDepot ;
15559: LD_ADDR_VAR 0 5
15563: PUSH
15564: LD_INT 11
15566: ST_TO_ADDR
// if not depot then
15567: LD_VAR 0 5
15571: NOT
15572: IFFALSE 15612
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
15574: LD_ADDR_VAR 0 5
15578: PUSH
15579: LD_INT 22
15581: PUSH
15582: LD_INT 2
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: PUSH
15589: LD_INT 30
15591: PUSH
15592: LD_INT 0
15594: PUSH
15595: EMPTY
15596: LIST
15597: LIST
15598: PUSH
15599: EMPTY
15600: LIST
15601: LIST
15602: PPUSH
15603: CALL_OW 69
15607: PUSH
15608: LD_INT 1
15610: ARRAY
15611: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15612: LD_ADDR_VAR 0 1
15616: PUSH
15617: LD_EXP 38
15621: PPUSH
15622: LD_INT 26
15624: PUSH
15625: LD_INT 1
15627: PUSH
15628: EMPTY
15629: LIST
15630: LIST
15631: PPUSH
15632: CALL_OW 72
15636: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15637: LD_ADDR_VAR 0 2
15641: PUSH
15642: LD_EXP 38
15646: PPUSH
15647: LD_INT 26
15649: PUSH
15650: LD_INT 2
15652: PUSH
15653: EMPTY
15654: LIST
15655: LIST
15656: PPUSH
15657: CALL_OW 72
15661: ST_TO_ADDR
// if IsOk ( Kaia ) then
15662: LD_EXP 29
15666: PPUSH
15667: CALL_OW 302
15671: IFFALSE 15692
// speaker := [ Kaia , DK ] else
15673: LD_ADDR_VAR 0 3
15677: PUSH
15678: LD_EXP 29
15682: PUSH
15683: LD_STRING DK
15685: PUSH
15686: EMPTY
15687: LIST
15688: LIST
15689: ST_TO_ADDR
15690: GO 15772
// if randomMen then
15692: LD_VAR 0 1
15696: IFFALSE 15731
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
15698: LD_ADDR_VAR 0 3
15702: PUSH
15703: LD_VAR 0 1
15707: PUSH
15708: LD_INT 1
15710: PPUSH
15711: LD_VAR 0 1
15715: PPUSH
15716: CALL_OW 12
15720: ARRAY
15721: PUSH
15722: LD_STRING DArm
15724: PUSH
15725: EMPTY
15726: LIST
15727: LIST
15728: ST_TO_ADDR
15729: GO 15772
// if randomWomen then
15731: LD_VAR 0 2
15735: IFFALSE 15770
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
15737: LD_ADDR_VAR 0 3
15741: PUSH
15742: LD_VAR 0 2
15746: PUSH
15747: LD_INT 1
15749: PPUSH
15750: LD_VAR 0 2
15754: PPUSH
15755: CALL_OW 12
15759: ARRAY
15760: PUSH
15761: LD_STRING DArf
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: ST_TO_ADDR
15768: GO 15772
// exit ;
15770: GO 16344
// if IsInUnit ( speaker [ 1 ] ) then
15772: LD_VAR 0 3
15776: PUSH
15777: LD_INT 1
15779: ARRAY
15780: PPUSH
15781: CALL_OW 310
15785: IFFALSE 15808
// place := IsInUnit ( speaker [ 1 ] ) else
15787: LD_ADDR_VAR 0 4
15791: PUSH
15792: LD_VAR 0 3
15796: PUSH
15797: LD_INT 1
15799: ARRAY
15800: PPUSH
15801: CALL_OW 310
15805: ST_TO_ADDR
15806: GO 15822
// place := speaker [ 1 ] ;
15808: LD_ADDR_VAR 0 4
15812: PUSH
15813: LD_VAR 0 3
15817: PUSH
15818: LD_INT 1
15820: ARRAY
15821: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
15822: LD_VAR 0 4
15826: PPUSH
15827: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
15831: LD_VAR 0 4
15835: PPUSH
15836: CALL_OW 250
15840: PPUSH
15841: LD_VAR 0 4
15845: PPUSH
15846: CALL_OW 251
15850: PPUSH
15851: CALL 2992 0 2
// wait ( 0 0$2 ) ;
15855: LD_INT 70
15857: PPUSH
15858: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
15862: LD_EXP 34
15866: PPUSH
15867: CALL_OW 305
15871: NOT
15872: IFFALSE 15876
// exit ;
15874: GO 16344
// allowConvoys := false ;
15876: LD_ADDR_EXP 11
15880: PUSH
15881: LD_INT 0
15883: ST_TO_ADDR
// InGameOn ;
15884: CALL_OW 8
// wait ( 0 0$1 ) ;
15888: LD_INT 35
15890: PPUSH
15891: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
15895: LD_EXP 34
15899: PPUSH
15900: LD_STRING DI-1-land
15902: PPUSH
15903: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
15907: LD_VAR 0 3
15911: PUSH
15912: LD_INT 1
15914: ARRAY
15915: PPUSH
15916: CALL_OW 310
15920: IFFALSE 15935
// ComExit ( speaker [ 1 ] ) ;
15922: LD_VAR 0 3
15926: PUSH
15927: LD_INT 1
15929: ARRAY
15930: PPUSH
15931: CALL 1095 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
15935: LD_VAR 0 3
15939: PUSH
15940: LD_INT 1
15942: ARRAY
15943: PPUSH
15944: LD_EXP 34
15948: PPUSH
15949: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
15953: LD_VAR 0 3
15957: PUSH
15958: LD_INT 1
15960: ARRAY
15961: PPUSH
15962: LD_EXP 34
15966: PPUSH
15967: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
15971: LD_EXP 34
15975: PPUSH
15976: LD_VAR 0 3
15980: PUSH
15981: LD_INT 1
15983: ARRAY
15984: PPUSH
15985: CALL_OW 119
// wait ( 0 0$1 ) ;
15989: LD_INT 35
15991: PPUSH
15992: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
15996: LD_VAR 0 3
16000: PUSH
16001: LD_INT 1
16003: ARRAY
16004: PPUSH
16005: LD_VAR 0 3
16009: PUSH
16010: LD_INT 2
16012: ARRAY
16013: PUSH
16014: LD_STRING -1-land
16016: STR
16017: PPUSH
16018: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16022: LD_EXP 34
16026: PPUSH
16027: LD_STRING DI-2-land
16029: PPUSH
16030: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16034: LD_VAR 0 3
16038: PUSH
16039: LD_INT 1
16041: ARRAY
16042: PPUSH
16043: LD_VAR 0 3
16047: PUSH
16048: LD_INT 2
16050: ARRAY
16051: PUSH
16052: LD_STRING -2-land
16054: STR
16055: PPUSH
16056: CALL_OW 88
// if IsInUnit ( Heike ) then
16060: LD_EXP 24
16064: PPUSH
16065: CALL_OW 310
16069: IFFALSE 16080
// ComExitBuilding ( Heike ) ;
16071: LD_EXP 24
16075: PPUSH
16076: CALL_OW 122
// AddComMoveXY ( Heike , 34 , 21 ) ;
16080: LD_EXP 24
16084: PPUSH
16085: LD_INT 34
16087: PPUSH
16088: LD_INT 21
16090: PPUSH
16091: CALL_OW 171
// AddComTurnUnit ( Heike , speaker [ 1 ] ) ;
16095: LD_EXP 24
16099: PPUSH
16100: LD_VAR 0 3
16104: PUSH
16105: LD_INT 1
16107: ARRAY
16108: PPUSH
16109: CALL_OW 179
// ComMoveXY ( Ibrahim , 36 , 22 ) ;
16113: LD_EXP 34
16117: PPUSH
16118: LD_INT 36
16120: PPUSH
16121: LD_INT 22
16123: PPUSH
16124: CALL_OW 111
// ComMoveXY ( speaker [ 1 ] , 35 , 22 ) ;
16128: LD_VAR 0 3
16132: PUSH
16133: LD_INT 1
16135: ARRAY
16136: PPUSH
16137: LD_INT 35
16139: PPUSH
16140: LD_INT 22
16142: PPUSH
16143: CALL_OW 111
// AddComTurnUnit ( [ Ibrahim , speaker [ 1 ] ] , Heike ) ;
16147: LD_EXP 34
16151: PUSH
16152: LD_VAR 0 3
16156: PUSH
16157: LD_INT 1
16159: ARRAY
16160: PUSH
16161: EMPTY
16162: LIST
16163: LIST
16164: PPUSH
16165: LD_EXP 24
16169: PPUSH
16170: CALL_OW 179
// repeat wait ( 0 0$2 ) ;
16174: LD_INT 70
16176: PPUSH
16177: CALL_OW 67
// CenterOnUnits ( speaker [ 1 ] ) ;
16181: LD_VAR 0 3
16185: PUSH
16186: LD_INT 1
16188: ARRAY
16189: PPUSH
16190: CALL_OW 85
// until GetDistUnits ( speaker [ 1 ] , depot ) < 8 ;
16194: LD_VAR 0 3
16198: PUSH
16199: LD_INT 1
16201: ARRAY
16202: PPUSH
16203: LD_VAR 0 5
16207: PPUSH
16208: CALL_OW 296
16212: PUSH
16213: LD_INT 8
16215: LESS
16216: IFFALSE 16174
// CenterOnUnits ( depot ) ;
16218: LD_VAR 0 5
16222: PPUSH
16223: CALL_OW 85
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16227: LD_VAR 0 3
16231: PUSH
16232: LD_INT 1
16234: ARRAY
16235: PPUSH
16236: LD_VAR 0 3
16240: PUSH
16241: LD_INT 2
16243: ARRAY
16244: PUSH
16245: LD_STRING -3-land
16247: STR
16248: PPUSH
16249: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16253: LD_EXP 24
16257: PPUSH
16258: LD_STRING DH-1-land
16260: PPUSH
16261: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16265: LD_VAR 0 5
16269: PPUSH
16270: CALL_OW 313
16274: PUSH
16275: LD_INT 6
16277: EQUAL
16278: IFFALSE 16298
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16280: LD_VAR 0 5
16284: PPUSH
16285: CALL_OW 313
16289: PUSH
16290: LD_INT 1
16292: ARRAY
16293: PPUSH
16294: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16298: LD_EXP 34
16302: PPUSH
16303: LD_INT 2
16305: PPUSH
16306: CALL_OW 235
// ComEnterUnit ( Ibrahim , depot ) ;
16310: LD_EXP 34
16314: PPUSH
16315: LD_VAR 0 5
16319: PPUSH
16320: CALL_OW 120
// InGameOff ;
16324: CALL_OW 9
// ibrahimInDepot := true ;
16328: LD_ADDR_EXP 21
16332: PUSH
16333: LD_INT 1
16335: ST_TO_ADDR
// allowConvoys := true ;
16336: LD_ADDR_EXP 11
16340: PUSH
16341: LD_INT 1
16343: ST_TO_ADDR
// end ;
16344: PPOPN 5
16346: END
// export function IbrahimQuery ; begin
16347: LD_INT 0
16349: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16350: LD_STRING IbrahimQuery
16352: PPUSH
16353: CALL_OW 97
16357: PUSH
16358: LD_INT 1
16360: DOUBLE
16361: EQUAL
16362: IFTRUE 16366
16364: GO 16675
16366: POP
// begin allowConvoys := false ;
16367: LD_ADDR_EXP 11
16371: PUSH
16372: LD_INT 0
16374: ST_TO_ADDR
// ibrahimInDepot := false ;
16375: LD_ADDR_EXP 21
16379: PUSH
16380: LD_INT 0
16382: ST_TO_ADDR
// InGameOn ;
16383: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16387: LD_EXP 24
16391: PPUSH
16392: CALL_OW 87
// wait ( 0 0$1 ) ;
16396: LD_INT 35
16398: PPUSH
16399: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16403: LD_EXP 24
16407: PPUSH
16408: LD_STRING DH-1-interrogation
16410: PPUSH
16411: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16415: LD_EXP 34
16419: PPUSH
16420: LD_STRING DI-1-interrogation
16422: PPUSH
16423: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16427: LD_EXP 24
16431: PPUSH
16432: LD_STRING DH-2-interrogation
16434: PPUSH
16435: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16439: LD_EXP 34
16443: PPUSH
16444: LD_STRING DI-2-interrogation
16446: PPUSH
16447: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16451: LD_EXP 24
16455: PPUSH
16456: LD_STRING DH-3-interrogation
16458: PPUSH
16459: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16463: LD_EXP 34
16467: PPUSH
16468: LD_STRING DI-3-interrogation
16470: PPUSH
16471: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16475: LD_EXP 24
16479: PPUSH
16480: LD_STRING DH-4-interrogation
16482: PPUSH
16483: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16487: LD_EXP 34
16491: PPUSH
16492: LD_STRING DI-4-interrogation
16494: PPUSH
16495: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16499: LD_EXP 24
16503: PPUSH
16504: LD_STRING DH-5-interrogation
16506: PPUSH
16507: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16511: LD_EXP 34
16515: PPUSH
16516: LD_STRING DI-5-interrogation
16518: PPUSH
16519: CALL_OW 88
// wait ( 0 0$1 ) ;
16523: LD_INT 35
16525: PPUSH
16526: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16530: LD_STRING IbrahimDecisionQuery
16532: PPUSH
16533: CALL_OW 97
16537: PUSH
16538: LD_INT 1
16540: DOUBLE
16541: EQUAL
16542: IFTRUE 16546
16544: GO 16570
16546: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16547: LD_EXP 34
16551: PPUSH
16552: LD_STRING DI-1-kill
16554: PPUSH
16555: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16559: LD_EXP 34
16563: PPUSH
16564: CALL_OW 66
// end ; 2 :
16568: GO 16669
16570: LD_INT 2
16572: DOUBLE
16573: EQUAL
16574: IFTRUE 16578
16576: GO 16668
16578: POP
// begin SetSide ( Ibrahim , 6 ) ;
16579: LD_EXP 34
16583: PPUSH
16584: LD_INT 6
16586: PPUSH
16587: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16591: LD_EXP 34
16595: PPUSH
16596: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16600: LD_EXP 34
16604: PPUSH
16605: LD_INT 32
16607: PPUSH
16608: LD_INT 5
16610: PPUSH
16611: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16615: LD_EXP 24
16619: PPUSH
16620: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16624: LD_EXP 24
16628: PPUSH
16629: LD_INT 36
16631: PPUSH
16632: LD_INT 21
16634: PPUSH
16635: CALL_OW 171
// AddComWait ( Ibrahim , 1 1$20 ) ;
16639: LD_EXP 34
16643: PPUSH
16644: LD_INT 2800
16646: PPUSH
16647: CALL_OW 202
// AddComMoveXY ( Ibrahim , 38 , 28 ) ;
16651: LD_EXP 34
16655: PPUSH
16656: LD_INT 38
16658: PPUSH
16659: LD_INT 28
16661: PPUSH
16662: CALL_OW 171
// end ; end ;
16666: GO 16669
16668: POP
// InGameOff ;
16669: CALL_OW 9
// end ; 2 :
16673: GO 16689
16675: LD_INT 2
16677: DOUBLE
16678: EQUAL
16679: IFTRUE 16683
16681: GO 16688
16683: POP
// exit ; end ;
16684: GO 16712
16686: GO 16689
16688: POP
// allowConvoys := true ;
16689: LD_ADDR_EXP 11
16693: PUSH
16694: LD_INT 1
16696: ST_TO_ADDR
// wait ( 0 0$40 ) ;
16697: LD_INT 1400
16699: PPUSH
16700: CALL_OW 67
// ibrahimIsFree := true ;
16704: LD_ADDR_EXP 22
16708: PUSH
16709: LD_INT 1
16711: ST_TO_ADDR
// end ;
16712: LD_VAR 0 1
16716: RET
// every 0 0$10 trigger ibrahimIsFree and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b ;
16717: LD_EXP 22
16721: PUSH
16722: LD_EXP 34
16726: PPUSH
16727: LD_INT 7
16729: PPUSH
16730: CALL_OW 308
16734: AND
16735: PUSH
16736: LD_INT 6
16738: PPUSH
16739: LD_EXP 24
16743: PPUSH
16744: CALL_OW 292
16748: AND
16749: PUSH
16750: LD_INT 22
16752: PUSH
16753: LD_INT 4
16755: PUSH
16756: EMPTY
16757: LIST
16758: LIST
16759: PPUSH
16760: CALL_OW 69
16764: NOT
16765: AND
16766: PUSH
16767: LD_INT 22
16769: PUSH
16770: LD_INT 1
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: PUSH
16777: LD_INT 21
16779: PUSH
16780: LD_INT 1
16782: PUSH
16783: EMPTY
16784: LIST
16785: LIST
16786: PUSH
16787: EMPTY
16788: LIST
16789: LIST
16790: PPUSH
16791: CALL_OW 69
16795: NOT
16796: AND
16797: IFFALSE 17347
16799: GO 16801
16801: DISABLE
16802: LD_INT 0
16804: PPUSH
16805: PPUSH
// begin allowConvoys := false ;
16806: LD_ADDR_EXP 11
16810: PUSH
16811: LD_INT 0
16813: ST_TO_ADDR
// InGameOn ;
16814: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
16818: LD_EXP 34
16822: PPUSH
16823: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
16827: LD_EXP 24
16831: PPUSH
16832: LD_EXP 34
16836: PPUSH
16837: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
16841: LD_EXP 34
16845: PPUSH
16846: LD_EXP 24
16850: PPUSH
16851: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
16855: LD_EXP 34
16859: PPUSH
16860: LD_STRING DI-1-free
16862: PPUSH
16863: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
16867: LD_EXP 24
16871: PPUSH
16872: LD_STRING DH-1-free
16874: PPUSH
16875: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
16879: LD_EXP 34
16883: PPUSH
16884: LD_STRING DI-2-free
16886: PPUSH
16887: CALL_OW 88
// changeClass := 0 ;
16891: LD_ADDR_VAR 0 1
16895: PUSH
16896: LD_INT 0
16898: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
16899: LD_STRING IbrahimJoinQuery
16901: PPUSH
16902: CALL_OW 97
16906: PUSH
16907: LD_INT 1
16909: DOUBLE
16910: EQUAL
16911: IFTRUE 16915
16913: GO 16926
16915: POP
// begin changeClass := 1 ;
16916: LD_ADDR_VAR 0 1
16920: PUSH
16921: LD_INT 1
16923: ST_TO_ADDR
// end ; 2 :
16924: GO 17134
16926: LD_INT 2
16928: DOUBLE
16929: EQUAL
16930: IFTRUE 16934
16932: GO 17054
16934: POP
// begin Say ( Heike , DH-1-decline ) ;
16935: LD_EXP 24
16939: PPUSH
16940: LD_STRING DH-1-decline
16942: PPUSH
16943: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
16947: LD_EXP 34
16951: PPUSH
16952: LD_STRING DI-1-decline
16954: PPUSH
16955: CALL_OW 88
// InGameOff ;
16959: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
16963: LD_EXP 34
16967: PPUSH
16968: LD_INT 30
16970: PPUSH
16971: LD_INT 1
16973: PPUSH
16974: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
16978: LD_INT 35
16980: PPUSH
16981: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) ;
16985: LD_EXP 34
16989: PPUSH
16990: LD_INT 30
16992: PPUSH
16993: LD_INT 1
16995: PPUSH
16996: CALL_OW 307
17000: PUSH
17001: LD_INT 22
17003: PUSH
17004: LD_INT 2
17006: PUSH
17007: EMPTY
17008: LIST
17009: LIST
17010: PUSH
17011: LD_INT 101
17013: PUSH
17014: LD_INT 6
17016: PUSH
17017: EMPTY
17018: LIST
17019: LIST
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: PPUSH
17025: CALL_OW 69
17029: NOT
17030: OR
17031: IFFALSE 16978
// RemoveUnit ( Ibrahim ) ;
17033: LD_EXP 34
17037: PPUSH
17038: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17042: LD_INT 1
17044: PPUSH
17045: LD_STRING 03_IbrahimHasEscaped
17047: PPUSH
17048: CALL_OW 39
// end ; 3 :
17052: GO 17134
17054: LD_INT 3
17056: DOUBLE
17057: EQUAL
17058: IFTRUE 17062
17060: GO 17133
17062: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17063: LD_EXP 24
17067: PPUSH
17068: LD_STRING DH-1-radio-hq
17070: PPUSH
17071: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17075: LD_EXP 33
17079: PPUSH
17080: LD_STRING DO-1-radio-hq
17082: PPUSH
17083: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17087: LD_EXP 24
17091: PPUSH
17092: LD_STRING DH-2-radio-hq
17094: PPUSH
17095: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17099: LD_EXP 33
17103: PPUSH
17104: LD_STRING DO-2-radio-hq
17106: PPUSH
17107: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17111: LD_EXP 24
17115: PPUSH
17116: LD_STRING DH-3-radio-hq
17118: PPUSH
17119: CALL_OW 88
// changeClass := 1 ;
17123: LD_ADDR_VAR 0 1
17127: PUSH
17128: LD_INT 1
17130: ST_TO_ADDR
// end ; end ;
17131: GO 17134
17133: POP
// if changeClass then
17134: LD_VAR 0 1
17138: IFFALSE 17347
// begin Say ( Heike , DH-1-agree ) ;
17140: LD_EXP 24
17144: PPUSH
17145: LD_STRING DH-1-agree
17147: PPUSH
17148: CALL_OW 88
// if IsOk ( Givi ) then
17152: LD_EXP 25
17156: PPUSH
17157: CALL_OW 302
17161: IFFALSE 17199
// begin Say ( Givi , DG-1-agree ) ;
17163: LD_EXP 25
17167: PPUSH
17168: LD_STRING DG-1-agree
17170: PPUSH
17171: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17175: LD_EXP 24
17179: PPUSH
17180: LD_STRING DH-2-agree
17182: PPUSH
17183: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17187: LD_EXP 25
17191: PPUSH
17192: LD_STRING DG-2-agree
17194: PPUSH
17195: CALL_OW 88
// end ; if UnitsInside ( usDepot ) = 6 then
17199: LD_INT 11
17201: PPUSH
17202: CALL_OW 313
17206: PUSH
17207: LD_INT 6
17209: EQUAL
17210: IFFALSE 17228
// ComExitBuilding ( UnitsInside ( usDepot ) [ 1 ] ) ;
17212: LD_INT 11
17214: PPUSH
17215: CALL_OW 313
17219: PUSH
17220: LD_INT 1
17222: ARRAY
17223: PPUSH
17224: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17228: LD_EXP 34
17232: PPUSH
17233: LD_INT 2
17235: PPUSH
17236: CALL_OW 235
// ComEnterUnit ( Ibrahim , usDepot ) ;
17240: LD_EXP 34
17244: PPUSH
17245: LD_INT 11
17247: PPUSH
17248: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17252: LD_INT 35
17254: PPUSH
17255: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17259: LD_EXP 34
17263: PPUSH
17264: CALL_OW 310
17268: IFFALSE 17252
// b := IsInUnit ( Ibrahim ) ;
17270: LD_ADDR_VAR 0 2
17274: PUSH
17275: LD_EXP 34
17279: PPUSH
17280: CALL_OW 310
17284: ST_TO_ADDR
// RemoveUnit ( Ibrahim ) ;
17285: LD_EXP 34
17289: PPUSH
17290: CALL_OW 64
// uc_side := 2 ;
17294: LD_ADDR_OWVAR 20
17298: PUSH
17299: LD_INT 2
17301: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17302: LD_ADDR_EXP 34
17306: PUSH
17307: LD_STRING Ibrahim
17309: PPUSH
17310: LD_INT 0
17312: PPUSH
17313: LD_STRING 
17315: PPUSH
17316: CALL 268 0 3
17320: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , b ) ;
17321: LD_EXP 34
17325: PPUSH
17326: LD_VAR 0 2
17330: PPUSH
17331: CALL_OW 52
// InGameOff ;
17335: CALL_OW 9
// allowConvoys := true ;
17339: LD_ADDR_EXP 11
17343: PUSH
17344: LD_INT 1
17346: ST_TO_ADDR
// end ; end ;
17347: PPOPN 2
17349: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 do
17350: LD_EXP 10
17354: PUSH
17355: LD_EXP 17
17359: PUSH
17360: LD_INT 1
17362: LESS
17363: AND
17364: IFFALSE 17755
17366: GO 17368
17368: DISABLE
// begin DialogueOn ;
17369: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
17373: LD_EXP 24
17377: PPUSH
17378: LD_STRING DH-1-final
17380: PPUSH
17381: CALL_OW 88
// if tick <= [ 68 68$00 , 65 65$00 , 63 63$00 ] [ Difficulty ] then
17385: LD_OWVAR 1
17389: PUSH
17390: LD_INT 142800
17392: PUSH
17393: LD_INT 136500
17395: PUSH
17396: LD_INT 132300
17398: PUSH
17399: EMPTY
17400: LIST
17401: LIST
17402: LIST
17403: PUSH
17404: LD_OWVAR 67
17408: ARRAY
17409: LESSEQUAL
17410: IFFALSE 17424
// AddMedal ( med1 , 1 ) else
17412: LD_STRING med1
17414: PPUSH
17415: LD_INT 1
17417: PPUSH
17418: CALL_OW 101
17422: GO 17435
// AddMedal ( med1 , - 1 ) ;
17424: LD_STRING med1
17426: PPUSH
17427: LD_INT 1
17429: NEG
17430: PPUSH
17431: CALL_OW 101
// if vehCounter >= 2 then
17435: LD_EXP 18
17439: PUSH
17440: LD_INT 2
17442: GREATEREQUAL
17443: IFFALSE 17457
// AddMedal ( med2 , 1 ) else
17445: LD_STRING med2
17447: PPUSH
17448: LD_INT 1
17450: PPUSH
17451: CALL_OW 101
17455: GO 17468
// AddMedal ( med2 , - 1 ) ;
17457: LD_STRING med2
17459: PPUSH
17460: LD_INT 1
17462: NEG
17463: PPUSH
17464: CALL_OW 101
// if deadCounter = 0 then
17468: LD_EXP 8
17472: PUSH
17473: LD_INT 0
17475: EQUAL
17476: IFFALSE 17490
// AddMedal ( med3 , 1 ) else
17478: LD_STRING med3
17480: PPUSH
17481: LD_INT 1
17483: PPUSH
17484: CALL_OW 101
17488: GO 17501
// AddMedal ( med3 , - 1 ) ;
17490: LD_STRING med3
17492: PPUSH
17493: LD_INT 1
17495: NEG
17496: PPUSH
17497: CALL_OW 101
// GiveMedals ( MAIN ) ;
17501: LD_STRING MAIN
17503: PPUSH
17504: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
17508: LD_INT 22
17510: PUSH
17511: LD_INT 2
17513: PUSH
17514: EMPTY
17515: LIST
17516: LIST
17517: PUSH
17518: LD_INT 23
17520: PUSH
17521: LD_INT 2
17523: PUSH
17524: EMPTY
17525: LIST
17526: LIST
17527: PUSH
17528: LD_INT 21
17530: PUSH
17531: LD_INT 1
17533: PUSH
17534: EMPTY
17535: LIST
17536: LIST
17537: PUSH
17538: EMPTY
17539: LIST
17540: LIST
17541: LIST
17542: PPUSH
17543: CALL_OW 69
17547: PPUSH
17548: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
17552: LD_EXP 24
17556: PPUSH
17557: LD_STRING 03_Heike
17559: PPUSH
17560: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
17564: LD_EXP 28
17568: PPUSH
17569: LD_STRING 03_Aviradze
17571: PPUSH
17572: CALL_OW 38
// if Givi then
17576: LD_EXP 25
17580: IFFALSE 17594
// SaveCharacters ( Givi , 03_Givi ) ;
17582: LD_EXP 25
17586: PPUSH
17587: LD_STRING 03_Givi
17589: PPUSH
17590: CALL_OW 38
// if Mike then
17594: LD_EXP 26
17598: IFFALSE 17612
// SaveCharacters ( Mike , 03_Mike ) ;
17600: LD_EXP 26
17604: PPUSH
17605: LD_STRING 03_Mike
17607: PPUSH
17608: CALL_OW 38
// if Kamil then
17612: LD_EXP 27
17616: IFFALSE 17630
// SaveCharacters ( Kamil , 03_Kamil ) ;
17618: LD_EXP 27
17622: PPUSH
17623: LD_STRING 03_Kamil
17625: PPUSH
17626: CALL_OW 38
// if Kaia then
17630: LD_EXP 29
17634: IFFALSE 17648
// SaveCharacters ( Kaia , 03_Kaia ) ;
17636: LD_EXP 29
17640: PPUSH
17641: LD_STRING 03_Kaia
17643: PPUSH
17644: CALL_OW 38
// if Sophia then
17648: LD_EXP 30
17652: IFFALSE 17666
// SaveCharacters ( Sophia , 03_Sophia ) ;
17654: LD_EXP 30
17658: PPUSH
17659: LD_STRING 03_Sophia
17661: PPUSH
17662: CALL_OW 38
// if Markov then
17666: LD_EXP 31
17670: IFFALSE 17684
// SaveCharacters ( Markov , 03_Markov ) ;
17672: LD_EXP 31
17676: PPUSH
17677: LD_STRING 03_Markov
17679: PPUSH
17680: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
17684: LD_EXP 34
17688: PUSH
17689: LD_EXP 34
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: LD_INT 2
17701: EQUAL
17702: AND
17703: IFFALSE 17717
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
17705: LD_EXP 34
17709: PPUSH
17710: LD_STRING 03_Ibrahim
17712: PPUSH
17713: CALL_OW 38
// if heikeSecondSquad then
17717: LD_EXP 38
17721: IFFALSE 17735
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
17723: LD_EXP 38
17727: PPUSH
17728: LD_STRING 03_others
17730: PPUSH
17731: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
17735: LD_EXP 8
17739: PPUSH
17740: LD_STRING 03_DeadCounter
17742: PPUSH
17743: CALL_OW 39
// YouWin ;
17747: CALL_OW 103
// DialogueOff ;
17751: CALL_OW 7
// end ; end_of_file
17755: END
// on UnitDestroyed ( un ) do begin if un = Heike then
17756: LD_VAR 0 1
17760: PUSH
17761: LD_EXP 24
17765: EQUAL
17766: IFFALSE 17775
// YouLost ( Heike ) ;
17768: LD_STRING Heike
17770: PPUSH
17771: CALL_OW 104
// if un = Aviradze then
17775: LD_VAR 0 1
17779: PUSH
17780: LD_EXP 28
17784: EQUAL
17785: IFFALSE 17794
// YouLost ( Aviradze ) ;
17787: LD_STRING Aviradze
17789: PPUSH
17790: CALL_OW 104
// if un = usDepot and not retreatAllowed then
17794: LD_VAR 0 1
17798: PUSH
17799: LD_INT 11
17801: EQUAL
17802: PUSH
17803: LD_EXP 10
17807: NOT
17808: AND
17809: IFFALSE 17818
// YouLost ( Depot ) ;
17811: LD_STRING Depot
17813: PPUSH
17814: CALL_OW 104
// if un = arDepot then
17818: LD_VAR 0 1
17822: PUSH
17823: LD_INT 5
17825: EQUAL
17826: IFFALSE 17835
// YouLost ( FarmerDepot ) ;
17828: LD_STRING FarmerDepot
17830: PPUSH
17831: CALL_OW 104
// if un = Farmer then
17835: LD_VAR 0 1
17839: PUSH
17840: LD_EXP 32
17844: EQUAL
17845: IFFALSE 17854
// YouLost ( Farmer ) ;
17847: LD_STRING Farmer
17849: PPUSH
17850: CALL_OW 104
// if un in usForces then
17854: LD_VAR 0 1
17858: PUSH
17859: LD_EXP 40
17863: IN
17864: IFFALSE 17882
// usForces := usForces diff un ;
17866: LD_ADDR_EXP 40
17870: PUSH
17871: LD_EXP 40
17875: PUSH
17876: LD_VAR 0 1
17880: DIFF
17881: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
17882: LD_VAR 0 1
17886: PUSH
17887: LD_INT 22
17889: PUSH
17890: LD_INT 2
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: PUSH
17897: LD_INT 23
17899: PUSH
17900: LD_INT 2
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: PUSH
17907: LD_INT 21
17909: PUSH
17910: LD_INT 1
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: PUSH
17917: EMPTY
17918: LIST
17919: LIST
17920: LIST
17921: PPUSH
17922: CALL_OW 69
17926: IN
17927: IFFALSE 17943
// deadCounter := deadCounter + 1 ;
17929: LD_ADDR_EXP 8
17933: PUSH
17934: LD_EXP 8
17938: PUSH
17939: LD_INT 1
17941: PLUS
17942: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
17943: LD_VAR 0 1
17947: PUSH
17948: LD_INT 22
17950: PUSH
17951: LD_INT 4
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: PUSH
17958: LD_INT 34
17960: PUSH
17961: LD_INT 12
17963: PUSH
17964: EMPTY
17965: LIST
17966: LIST
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: PPUSH
17972: CALL_OW 69
17976: IN
17977: PUSH
17978: LD_EXP 15
17982: NOT
17983: AND
17984: IFFALSE 17994
// firstConvoyDestroyed := true ;
17986: LD_ADDR_EXP 15
17990: PUSH
17991: LD_INT 1
17993: ST_TO_ADDR
// if un in usAttackers then
17994: LD_VAR 0 1
17998: PUSH
17999: LD_EXP 43
18003: IN
18004: IFFALSE 18022
// usAttackers := usAttackers diff un ;
18006: LD_ADDR_EXP 43
18010: PUSH
18011: LD_EXP 43
18015: PUSH
18016: LD_VAR 0 1
18020: DIFF
18021: ST_TO_ADDR
// end ;
18022: PPOPN 1
18024: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18025: LD_VAR 0 2
18029: PUSH
18030: LD_EXP 34
18034: EQUAL
18035: PUSH
18036: LD_EXP 21
18040: AND
18041: IFFALSE 18087
// begin Video ( true ) ;
18043: LD_INT 1
18045: PPUSH
18046: CALL 991 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
18050: LD_EXP 34
18054: PPUSH
18055: LD_INT 11
18057: PPUSH
18058: CALL_OW 120
// repeat wait ( 3 ) ;
18062: LD_INT 3
18064: PPUSH
18065: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18069: LD_EXP 34
18073: PPUSH
18074: CALL_OW 310
18078: IFFALSE 18062
// Video ( false ) ;
18080: LD_INT 0
18082: PPUSH
18083: CALL 991 0 1
// end ; end ;
18087: PPOPN 2
18089: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
18090: LD_VAR 0 2
18094: PUSH
18095: LD_EXP 24
18099: EQUAL
18100: PUSH
18101: LD_VAR 0 1
18105: PUSH
18106: LD_INT 11
18108: EQUAL
18109: AND
18110: PUSH
18111: LD_EXP 21
18115: AND
18116: IFFALSE 18122
// IbrahimQuery ;
18118: CALL 16347 0 0
// end ;
18122: PPOPN 2
18124: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin if oldId in usAttackers then
18125: LD_VAR 0 2
18129: PUSH
18130: LD_EXP 43
18134: IN
18135: IFFALSE 18153
// usAttackers := usAttackers diff oldId ;
18137: LD_ADDR_EXP 43
18141: PUSH
18142: LD_EXP 43
18146: PUSH
18147: LD_VAR 0 2
18151: DIFF
18152: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
18153: LD_VAR 0 3
18157: PUSH
18158: LD_INT 4
18160: EQUAL
18161: PUSH
18162: LD_EXP 15
18166: NOT
18167: AND
18168: IFFALSE 18178
// firstConvoyDestroyed := true ;
18170: LD_ADDR_EXP 15
18174: PUSH
18175: LD_INT 1
18177: ST_TO_ADDR
// if GetWeapon ( oldId ) = us_cargo_bay and GetCargo ( oldId , mat_cans ) = 0 then
18178: LD_VAR 0 2
18182: PPUSH
18183: CALL_OW 264
18187: PUSH
18188: LD_INT 12
18190: EQUAL
18191: PUSH
18192: LD_VAR 0 2
18196: PPUSH
18197: LD_INT 1
18199: PPUSH
18200: CALL_OW 289
18204: PUSH
18205: LD_INT 0
18207: EQUAL
18208: AND
18209: IFFALSE 18215
// EmptyCargoDialog ;
18211: CALL 14995 0 0
// end ;
18215: PPOPN 4
18217: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
18218: LD_VAR 0 1
18222: PUSH
18223: LD_INT 2
18225: EQUAL
18226: PUSH
18227: LD_VAR 0 2
18231: PUSH
18232: LD_INT 5
18234: EQUAL
18235: AND
18236: IFFALSE 18245
// YouLost ( Attack ) ;
18238: LD_STRING Attack
18240: PPUSH
18241: CALL_OW 104
// end ;
18245: PPOPN 2
18247: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 then
18248: LD_VAR 0 1
18252: PPUSH
18253: CALL_OW 255
18257: PUSH
18258: LD_INT 1
18260: EQUAL
18261: IFFALSE 18395
// begin if GetBType ( b ) = b_lab then
18263: LD_VAR 0 1
18267: PPUSH
18268: CALL_OW 266
18272: PUSH
18273: LD_INT 6
18275: EQUAL
18276: IFFALSE 18316
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
18278: LD_EXP 40
18282: PPUSH
18283: LD_INT 25
18285: PUSH
18286: LD_INT 4
18288: PUSH
18289: EMPTY
18290: LIST
18291: LIST
18292: PPUSH
18293: CALL_OW 72
18297: PPUSH
18298: LD_VAR 0 1
18302: PPUSH
18303: CALL_OW 120
// AmLabResearch ( b ) ;
18307: LD_VAR 0 1
18311: PPUSH
18312: CALL 5921 0 1
// end ; if GetBType ( b ) = b_armoury then
18316: LD_VAR 0 1
18320: PPUSH
18321: CALL_OW 266
18325: PUSH
18326: LD_INT 4
18328: EQUAL
18329: IFFALSE 18377
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
18331: LD_EXP 40
18335: PPUSH
18336: LD_INT 25
18338: PUSH
18339: LD_INT 1
18341: PUSH
18342: EMPTY
18343: LIST
18344: LIST
18345: PUSH
18346: LD_INT 3
18348: PUSH
18349: LD_INT 54
18351: PUSH
18352: EMPTY
18353: LIST
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: PPUSH
18363: CALL_OW 72
18367: PPUSH
18368: LD_VAR 0 1
18372: PPUSH
18373: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
18377: LD_ADDR_EXP 42
18381: PUSH
18382: LD_EXP 42
18386: PPUSH
18387: LD_INT 1
18389: PPUSH
18390: CALL_OW 3
18394: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
18395: LD_VAR 0 1
18399: PPUSH
18400: CALL_OW 255
18404: PUSH
18405: LD_INT 5
18407: EQUAL
18408: IFFALSE 18422
// SetBLevel ( b , 5 ) ;
18410: LD_VAR 0 1
18414: PPUSH
18415: LD_INT 5
18417: PPUSH
18418: CALL_OW 241
// end ;
18422: PPOPN 1
18424: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
18425: LD_VAR 0 1
18429: PPUSH
18430: CALL_OW 255
18434: PUSH
18435: LD_INT 2
18437: EQUAL
18438: IFFALSE 18454
// vehCounter := vehCounter + 1 ;
18440: LD_ADDR_EXP 18
18444: PUSH
18445: LD_EXP 18
18449: PUSH
18450: LD_INT 1
18452: PLUS
18453: ST_TO_ADDR
// end ;
18454: PPOPN 2
18456: END
// on SailEvent ( event ) do begin if event = eventAttack then
18457: LD_VAR 0 1
18461: PUSH
18462: LD_EXP 20
18466: EQUAL
18467: IFFALSE 18473
// AmericanAttack ;
18469: CALL 7361 0 0
// end ; end_of_file
18473: PPOPN 1
18475: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 4 4$00 , 3 3$00 , 2 2$30 ] [ Difficulty ] do
18476: LD_OWVAR 1
18480: PUSH
18481: LD_INT 8400
18483: PUSH
18484: LD_INT 6300
18486: PUSH
18487: LD_INT 5250
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: LIST
18494: PUSH
18495: LD_OWVAR 67
18499: ARRAY
18500: LESSEQUAL
18501: IFFALSE 18528
18503: GO 18505
18505: DISABLE
// begin enable ;
18506: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18507: LD_INT 1
18509: PPUSH
18510: LD_INT 5
18512: PPUSH
18513: CALL_OW 12
18517: PPUSH
18518: LD_INT 9
18520: PPUSH
18521: LD_INT 1
18523: PPUSH
18524: CALL_OW 55
// end ;
18528: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 26 26$00 , 23 23$00 , 20 20$00 ] [ Difficulty ] do
18529: LD_EXP 6
18533: PUSH
18534: LD_OWVAR 1
18538: PUSH
18539: LD_INT 54600
18541: PUSH
18542: LD_INT 48300
18544: PUSH
18545: LD_INT 42000
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: LIST
18552: PUSH
18553: LD_OWVAR 67
18557: ARRAY
18558: LESSEQUAL
18559: AND
18560: IFFALSE 18587
18562: GO 18564
18564: DISABLE
// begin enable ;
18565: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18566: LD_INT 1
18568: PPUSH
18569: LD_INT 5
18571: PPUSH
18572: CALL_OW 12
18576: PPUSH
18577: LD_INT 9
18579: PPUSH
18580: LD_INT 1
18582: PPUSH
18583: CALL_OW 55
// end ; end_of_file
18587: END
// every 0 0$1 trigger not retreatAllowed and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
18588: LD_EXP 10
18592: NOT
18593: PUSH
18594: LD_EXP 4
18598: AND
18599: PUSH
18600: LD_EXP 12
18604: PUSH
18605: LD_EXP 13
18609: LESSEQUAL
18610: AND
18611: IFFALSE 18701
18613: GO 18615
18615: DISABLE
// begin enable ;
18616: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
18617: LD_ADDR_OWVAR 47
18621: PUSH
18622: LD_STRING #X103-1
18624: PUSH
18625: LD_EXP 12
18629: PUSH
18630: LD_EXP 13
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
18640: LD_ADDR_EXP 12
18644: PUSH
18645: LD_INT 5
18647: PPUSH
18648: CALL_OW 274
18652: PPUSH
18653: LD_INT 1
18655: PPUSH
18656: CALL_OW 275
18660: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
18661: LD_INT 10
18663: PPUSH
18664: LD_INT 1
18666: PPUSH
18667: CALL_OW 287
18671: PUSH
18672: LD_INT 0
18674: EQUAL
18675: IFFALSE 18693
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
18677: LD_ADDR_EXP 14
18681: PUSH
18682: LD_EXP 14
18686: PUSH
18687: LD_INT 35
18689: MINUS
18690: ST_TO_ADDR
18691: GO 18701
// farmerCratesCounter := 30 30$00 ;
18693: LD_ADDR_EXP 14
18697: PUSH
18698: LD_INT 63000
18700: ST_TO_ADDR
// end ; end_of_file
18701: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18702: GO 18704
18704: DISABLE
// begin ru_radar := 98 ;
18705: LD_ADDR_EXP 44
18709: PUSH
18710: LD_INT 98
18712: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18713: LD_ADDR_EXP 45
18717: PUSH
18718: LD_INT 89
18720: ST_TO_ADDR
// us_hack := 99 ;
18721: LD_ADDR_EXP 46
18725: PUSH
18726: LD_INT 99
18728: ST_TO_ADDR
// us_artillery := 97 ;
18729: LD_ADDR_EXP 47
18733: PUSH
18734: LD_INT 97
18736: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18737: LD_ADDR_EXP 48
18741: PUSH
18742: LD_INT 91
18744: ST_TO_ADDR
// tech_Artillery := 80 ;
18745: LD_ADDR_EXP 49
18749: PUSH
18750: LD_INT 80
18752: ST_TO_ADDR
// tech_RadMat := 81 ;
18753: LD_ADDR_EXP 50
18757: PUSH
18758: LD_INT 81
18760: ST_TO_ADDR
// tech_BasicTools := 82 ;
18761: LD_ADDR_EXP 51
18765: PUSH
18766: LD_INT 82
18768: ST_TO_ADDR
// tech_Cargo := 83 ;
18769: LD_ADDR_EXP 52
18773: PUSH
18774: LD_INT 83
18776: ST_TO_ADDR
// tech_Track := 84 ;
18777: LD_ADDR_EXP 53
18781: PUSH
18782: LD_INT 84
18784: ST_TO_ADDR
// tech_Crane := 85 ;
18785: LD_ADDR_EXP 54
18789: PUSH
18790: LD_INT 85
18792: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18793: LD_ADDR_EXP 55
18797: PUSH
18798: LD_INT 86
18800: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18801: LD_ADDR_EXP 56
18805: PUSH
18806: LD_INT 87
18808: ST_TO_ADDR
// end ;
18809: END
