// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 38 0 0
// PrepareNature ;
   8: CALL 673 0 0
// PrepareArabian ;
  12: CALL 1988 0 0
// PrepareAmerican ;
  16: CALL 5013 0 0
// if debug then
  20: LD_EXP 1
  24: IFFALSE 33
// FogOff ( 2 ) ;
  26: LD_INT 2
  28: PPUSH
  29: CALL_OW 344
// Action ;
  33: CALL 9665 0 0
// end ;
  37: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , allowCargoEvacuation , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , capturedCargoCounter , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , farmerHumanLoseCounter , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := false ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 0
  48: ST_TO_ADDR
// prefix := 02_ ;
  49: LD_ADDR_EXP 2
  53: PUSH
  54: LD_STRING 02_
  56: ST_TO_ADDR
// eventAttack := 1 ;
  57: LD_ADDR_EXP 23
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// deadCounter := 0 ;
  65: LD_ADDR_EXP 9
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// gameStarted := false ;
  73: LD_ADDR_EXP 3
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// farmerBaseReady := false ;
  81: LD_ADDR_EXP 4
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// americanBaseSpoted := false ;
  89: LD_ADDR_EXP 5
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// americanBaseCaptured := false ;
  97: LD_ADDR_EXP 6
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// americanHasEscaped := false ;
 105: LD_ADDR_EXP 8
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// workshopBuilded := false ;
 113: LD_ADDR_EXP 10
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// retreatAllowed := false ;
 121: LD_ADDR_EXP 11
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// allowConvoys := false ;
 129: LD_ADDR_EXP 12
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// farmerCrates := 0 ;
 137: LD_ADDR_EXP 14
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 145: LD_ADDR_EXP 15
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 153: LD_ADDR_EXP 16
 157: PUSH
 158: LD_INT 63000
 160: PUSH
 161: LD_INT 52500
 163: PUSH
 164: LD_INT 46200
 166: PUSH
 167: EMPTY
 168: LIST
 169: LIST
 170: LIST
 171: PUSH
 172: LD_OWVAR 67
 176: ARRAY
 177: ST_TO_ADDR
// farmerHumanLoseCounter := 0 ;
 178: LD_ADDR_EXP 19
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 186: LD_ADDR_EXP 17
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// attackWave := 1 ;
 194: LD_ADDR_EXP 18
 198: PUSH
 199: LD_INT 1
 201: ST_TO_ADDR
// omarCargoCounter := [ 6 , 8 , 10 ] [ Difficulty ] ;
 202: LD_ADDR_EXP 20
 206: PUSH
 207: LD_INT 6
 209: PUSH
 210: LD_INT 8
 212: PUSH
 213: LD_INT 10
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: PUSH
 221: LD_OWVAR 67
 225: ARRAY
 226: ST_TO_ADDR
// vehCounter := 0 ;
 227: LD_ADDR_EXP 21
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// convoyCounter := 0 ;
 235: LD_ADDR_EXP 22
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// ibrahimInDepot := false ;
 243: LD_ADDR_EXP 24
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// ibrahimIsFree := false ;
 251: LD_ADDR_EXP 25
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// maxConvoys := [ 16 , 15 , 14 ] [ Difficulty ] ;
 259: LD_ADDR_EXP 26
 263: PUSH
 264: LD_INT 16
 266: PUSH
 267: LD_INT 15
 269: PUSH
 270: LD_INT 14
 272: PUSH
 273: EMPTY
 274: LIST
 275: LIST
 276: LIST
 277: PUSH
 278: LD_OWVAR 67
 282: ARRAY
 283: ST_TO_ADDR
// capturedCargoCounter := 0 ;
 284: LD_ADDR_EXP 13
 288: PUSH
 289: LD_INT 0
 291: ST_TO_ADDR
// allowCargoEvacuation := false ;
 292: LD_ADDR_EXP 7
 296: PUSH
 297: LD_INT 0
 299: ST_TO_ADDR
// end ; end_of_file
 300: LD_VAR 0 1
 304: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 305: LD_INT 0
 307: PPUSH
 308: PPUSH
// if exist_mode then
 309: LD_VAR 0 2
 313: IFFALSE 338
// unit := CreateCharacter ( prefix & ident ) else
 315: LD_ADDR_VAR 0 5
 319: PUSH
 320: LD_VAR 0 3
 324: PUSH
 325: LD_VAR 0 1
 329: STR
 330: PPUSH
 331: CALL_OW 34
 335: ST_TO_ADDR
 336: GO 353
// unit := NewCharacter ( ident ) ;
 338: LD_ADDR_VAR 0 5
 342: PUSH
 343: LD_VAR 0 1
 347: PPUSH
 348: CALL_OW 25
 352: ST_TO_ADDR
// result := unit ;
 353: LD_ADDR_VAR 0 4
 357: PUSH
 358: LD_VAR 0 5
 362: ST_TO_ADDR
// end ;
 363: LD_VAR 0 4
 367: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 368: LD_INT 0
 370: PPUSH
// uc_side := side ;
 371: LD_ADDR_OWVAR 20
 375: PUSH
 376: LD_VAR 0 1
 380: ST_TO_ADDR
// uc_nation := nation ;
 381: LD_ADDR_OWVAR 21
 385: PUSH
 386: LD_VAR 0 2
 390: ST_TO_ADDR
// vc_chassis := chassis ;
 391: LD_ADDR_OWVAR 37
 395: PUSH
 396: LD_VAR 0 3
 400: ST_TO_ADDR
// vc_engine := engine ;
 401: LD_ADDR_OWVAR 39
 405: PUSH
 406: LD_VAR 0 4
 410: ST_TO_ADDR
// vc_control := control ;
 411: LD_ADDR_OWVAR 38
 415: PUSH
 416: LD_VAR 0 5
 420: ST_TO_ADDR
// vc_weapon := weapon ;
 421: LD_ADDR_OWVAR 40
 425: PUSH
 426: LD_VAR 0 6
 430: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 431: LD_ADDR_OWVAR 41
 435: PUSH
 436: LD_VAR 0 7
 440: ST_TO_ADDR
// result := CreateVehicle ;
 441: LD_ADDR_VAR 0 8
 445: PUSH
 446: CALL_OW 45
 450: ST_TO_ADDR
// end ;
 451: LD_VAR 0 8
 455: RET
// export function SayX ( units , ident ) ; var i ; begin
 456: LD_INT 0
 458: PPUSH
 459: PPUSH
// result := false ;
 460: LD_ADDR_VAR 0 3
 464: PUSH
 465: LD_INT 0
 467: ST_TO_ADDR
// if not units then
 468: LD_VAR 0 1
 472: NOT
 473: IFFALSE 477
// exit ;
 475: GO 531
// for i in units do
 477: LD_ADDR_VAR 0 4
 481: PUSH
 482: LD_VAR 0 1
 486: PUSH
 487: FOR_IN
 488: IFFALSE 529
// if IsOk ( i ) then
 490: LD_VAR 0 4
 494: PPUSH
 495: CALL_OW 302
 499: IFFALSE 527
// begin Say ( i , ident ) ;
 501: LD_VAR 0 4
 505: PPUSH
 506: LD_VAR 0 2
 510: PPUSH
 511: CALL_OW 88
// result := i ;
 515: LD_ADDR_VAR 0 3
 519: PUSH
 520: LD_VAR 0 4
 524: ST_TO_ADDR
// break ;
 525: GO 529
// end ;
 527: GO 487
 529: POP
 530: POP
// end ;
 531: LD_VAR 0 3
 535: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 536: LD_INT 0
 538: PPUSH
 539: PPUSH
// InitUc ;
 540: CALL_OW 18
// InitHc ;
 544: CALL_OW 19
// uc_side := 0 ;
 548: LD_ADDR_OWVAR 20
 552: PUSH
 553: LD_INT 0
 555: ST_TO_ADDR
// uc_nation := 0 ;
 556: LD_ADDR_OWVAR 21
 560: PUSH
 561: LD_INT 0
 563: ST_TO_ADDR
// for i = 1 to amount do
 564: LD_ADDR_VAR 0 4
 568: PUSH
 569: DOUBLE
 570: LD_INT 1
 572: DEC
 573: ST_TO_ADDR
 574: LD_VAR 0 2
 578: PUSH
 579: FOR_TO
 580: IFFALSE 662
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 582: LD_ADDR_OWVAR 29
 586: PUSH
 587: LD_INT 9
 589: PPUSH
 590: LD_INT 12
 592: PPUSH
 593: CALL_OW 12
 597: PUSH
 598: LD_INT 9
 600: PPUSH
 601: LD_INT 12
 603: PPUSH
 604: CALL_OW 12
 608: PUSH
 609: EMPTY
 610: LIST
 611: LIST
 612: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 613: LD_ADDR_OWVAR 35
 617: PUSH
 618: LD_INT 1
 620: NEG
 621: PPUSH
 622: LD_INT 1
 624: PPUSH
 625: CALL_OW 12
 629: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 630: LD_INT 0
 632: PPUSH
 633: LD_INT 12
 635: PPUSH
 636: LD_INT 1
 638: PPUSH
 639: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 643: CALL_OW 44
 647: PPUSH
 648: LD_VAR 0 1
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 579
 662: POP
 663: POP
// InitHc ;
 664: CALL_OW 19
// end ;
 668: LD_VAR 0 3
 672: RET
// export function PrepareNature ; var i ; begin
 673: LD_INT 0
 675: PPUSH
 676: PPUSH
// SpawnApeman ( forest , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
 677: LD_INT 2
 679: PPUSH
 680: LD_INT 5
 682: PUSH
 683: LD_INT 4
 685: PUSH
 686: LD_INT 4
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: PUSH
 694: LD_OWVAR 67
 698: ARRAY
 699: PPUSH
 700: CALL 536 0 2
// for i := 1 to 2 do
 704: LD_ADDR_VAR 0 2
 708: PUSH
 709: DOUBLE
 710: LD_INT 1
 712: DEC
 713: ST_TO_ADDR
 714: LD_INT 2
 716: PUSH
 717: FOR_TO
 718: IFFALSE 753
// begin hc_class := 21 ;
 720: LD_ADDR_OWVAR 28
 724: PUSH
 725: LD_INT 21
 727: ST_TO_ADDR
// hc_gallery :=  ;
 728: LD_ADDR_OWVAR 33
 732: PUSH
 733: LD_STRING 
 735: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 736: CALL_OW 44
 740: PPUSH
 741: LD_INT 2
 743: PPUSH
 744: LD_INT 0
 746: PPUSH
 747: CALL_OW 49
// end ;
 751: GO 717
 753: POP
 754: POP
// for i := 1 to 2 do
 755: LD_ADDR_VAR 0 2
 759: PUSH
 760: DOUBLE
 761: LD_INT 1
 763: DEC
 764: ST_TO_ADDR
 765: LD_INT 2
 767: PUSH
 768: FOR_TO
 769: IFFALSE 804
// begin hc_class := 18 ;
 771: LD_ADDR_OWVAR 28
 775: PUSH
 776: LD_INT 18
 778: ST_TO_ADDR
// hc_gallery :=  ;
 779: LD_ADDR_OWVAR 33
 783: PUSH
 784: LD_STRING 
 786: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 787: CALL_OW 44
 791: PPUSH
 792: LD_INT 2
 794: PPUSH
 795: LD_INT 0
 797: PPUSH
 798: CALL_OW 49
// end ;
 802: GO 768
 804: POP
 805: POP
// for i := 1 to 2 do
 806: LD_ADDR_VAR 0 2
 810: PUSH
 811: DOUBLE
 812: LD_INT 1
 814: DEC
 815: ST_TO_ADDR
 816: LD_INT 2
 818: PUSH
 819: FOR_TO
 820: IFFALSE 855
// begin hc_class := 13 ;
 822: LD_ADDR_OWVAR 28
 826: PUSH
 827: LD_INT 13
 829: ST_TO_ADDR
// hc_gallery :=  ;
 830: LD_ADDR_OWVAR 33
 834: PUSH
 835: LD_STRING 
 837: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 838: CALL_OW 44
 842: PPUSH
 843: LD_INT 2
 845: PPUSH
 846: LD_INT 0
 848: PPUSH
 849: CALL_OW 49
// end ;
 853: GO 819
 855: POP
 856: POP
// end ;
 857: LD_VAR 0 1
 861: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 862: LD_INT 0
 864: PPUSH
 865: PPUSH
 866: PPUSH
// if not observer or not unit then
 867: LD_VAR 0 1
 871: NOT
 872: PUSH
 873: LD_VAR 0 2
 877: NOT
 878: OR
 879: IFFALSE 883
// exit ;
 881: GO 931
// if not See ( GetSide ( observer ) , unit ) then
 883: LD_VAR 0 1
 887: PPUSH
 888: CALL_OW 255
 892: PPUSH
 893: LD_VAR 0 2
 897: PPUSH
 898: CALL_OW 292
 902: NOT
 903: IFFALSE 907
// exit ;
 905: GO 931
// result := GetDistUnits ( observer , unit ) < 12 ;
 907: LD_ADDR_VAR 0 3
 911: PUSH
 912: LD_VAR 0 1
 916: PPUSH
 917: LD_VAR 0 2
 921: PPUSH
 922: CALL_OW 296
 926: PUSH
 927: LD_INT 12
 929: LESS
 930: ST_TO_ADDR
// end ;
 931: LD_VAR 0 3
 935: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 936: LD_INT 0
 938: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 939: LD_VAR 0 2
 943: PUSH
 944: LD_INT 1
 946: ARRAY
 947: PPUSH
 948: LD_VAR 0 2
 952: PUSH
 953: LD_INT 2
 955: ARRAY
 956: PPUSH
 957: CALL_OW 488
 961: PUSH
 962: LD_VAR 0 2
 966: PUSH
 967: LD_INT 1
 969: ARRAY
 970: PPUSH
 971: LD_VAR 0 2
 975: PUSH
 976: LD_INT 2
 978: ARRAY
 979: PPUSH
 980: CALL_OW 428
 984: PUSH
 985: LD_INT 0
 987: EQUAL
 988: AND
 989: IFFALSE 1023
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 991: LD_VAR 0 1
 995: PPUSH
 996: LD_VAR 0 2
1000: PUSH
1001: LD_INT 1
1003: ARRAY
1004: PPUSH
1005: LD_VAR 0 2
1009: PUSH
1010: LD_INT 2
1012: ARRAY
1013: PPUSH
1014: LD_VAR 0 3
1018: PPUSH
1019: CALL_OW 48
// end ;
1023: LD_VAR 0 4
1027: RET
// export function Video ( mode ) ; begin
1028: LD_INT 0
1030: PPUSH
// ingame_video = mode ;
1031: LD_ADDR_OWVAR 52
1035: PUSH
1036: LD_VAR 0 1
1040: ST_TO_ADDR
// interface_hidden = mode ;
1041: LD_ADDR_OWVAR 54
1045: PUSH
1046: LD_VAR 0 1
1050: ST_TO_ADDR
// end ;
1051: LD_VAR 0 2
1055: RET
// export function ReverseArray ( array ) ; var i ; begin
1056: LD_INT 0
1058: PPUSH
1059: PPUSH
// if not array then
1060: LD_VAR 0 1
1064: NOT
1065: IFFALSE 1069
// exit ;
1067: GO 1127
// result := [ ] ;
1069: LD_ADDR_VAR 0 2
1073: PUSH
1074: EMPTY
1075: ST_TO_ADDR
// for i := 1 to array do
1076: LD_ADDR_VAR 0 3
1080: PUSH
1081: DOUBLE
1082: LD_INT 1
1084: DEC
1085: ST_TO_ADDR
1086: LD_VAR 0 1
1090: PUSH
1091: FOR_TO
1092: IFFALSE 1125
// result := Insert ( result , 1 , array [ i ] ) ;
1094: LD_ADDR_VAR 0 2
1098: PUSH
1099: LD_VAR 0 2
1103: PPUSH
1104: LD_INT 1
1106: PPUSH
1107: LD_VAR 0 1
1111: PUSH
1112: LD_VAR 0 3
1116: ARRAY
1117: PPUSH
1118: CALL_OW 2
1122: ST_TO_ADDR
1123: GO 1091
1125: POP
1126: POP
// end ;
1127: LD_VAR 0 2
1131: RET
// export function ComExit ( unit ) ; begin
1132: LD_INT 0
1134: PPUSH
// result := IsInUnit ( unit ) ;
1135: LD_ADDR_VAR 0 2
1139: PUSH
1140: LD_VAR 0 1
1144: PPUSH
1145: CALL_OW 310
1149: ST_TO_ADDR
// if not result then
1150: LD_VAR 0 2
1154: NOT
1155: IFFALSE 1159
// exit ;
1157: GO 1194
// if GetType ( result ) = unit_vehicle then
1159: LD_VAR 0 2
1163: PPUSH
1164: CALL_OW 247
1168: PUSH
1169: LD_INT 2
1171: EQUAL
1172: IFFALSE 1185
// ComExitVehicle ( unit ) else
1174: LD_VAR 0 1
1178: PPUSH
1179: CALL_OW 121
1183: GO 1194
// ComExitBuilding ( unit ) ;
1185: LD_VAR 0 1
1189: PPUSH
1190: CALL_OW 122
// end ;
1194: LD_VAR 0 2
1198: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1199: LD_INT 0
1201: PPUSH
1202: PPUSH
// if not side or not nation then
1203: LD_VAR 0 1
1207: NOT
1208: PUSH
1209: LD_VAR 0 2
1213: NOT
1214: OR
1215: IFFALSE 1219
// exit ;
1217: GO 1983
// case nation of nation_american :
1219: LD_VAR 0 2
1223: PUSH
1224: LD_INT 1
1226: DOUBLE
1227: EQUAL
1228: IFTRUE 1232
1230: GO 1446
1232: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1233: LD_ADDR_VAR 0 4
1237: PUSH
1238: LD_INT 35
1240: PUSH
1241: LD_INT 45
1243: PUSH
1244: LD_INT 46
1246: PUSH
1247: LD_INT 47
1249: PUSH
1250: LD_INT 82
1252: PUSH
1253: LD_INT 83
1255: PUSH
1256: LD_INT 84
1258: PUSH
1259: LD_INT 85
1261: PUSH
1262: LD_INT 86
1264: PUSH
1265: LD_INT 1
1267: PUSH
1268: LD_INT 2
1270: PUSH
1271: LD_INT 6
1273: PUSH
1274: LD_INT 15
1276: PUSH
1277: LD_INT 16
1279: PUSH
1280: LD_INT 7
1282: PUSH
1283: LD_INT 12
1285: PUSH
1286: LD_INT 13
1288: PUSH
1289: LD_INT 10
1291: PUSH
1292: LD_INT 14
1294: PUSH
1295: LD_INT 20
1297: PUSH
1298: LD_INT 21
1300: PUSH
1301: LD_INT 22
1303: PUSH
1304: LD_INT 25
1306: PUSH
1307: LD_INT 32
1309: PUSH
1310: LD_INT 27
1312: PUSH
1313: LD_INT 36
1315: PUSH
1316: LD_INT 69
1318: PUSH
1319: LD_INT 39
1321: PUSH
1322: LD_INT 34
1324: PUSH
1325: LD_INT 40
1327: PUSH
1328: LD_INT 48
1330: PUSH
1331: LD_INT 49
1333: PUSH
1334: LD_INT 50
1336: PUSH
1337: LD_INT 51
1339: PUSH
1340: LD_INT 52
1342: PUSH
1343: LD_INT 53
1345: PUSH
1346: LD_INT 54
1348: PUSH
1349: LD_INT 55
1351: PUSH
1352: LD_INT 56
1354: PUSH
1355: LD_INT 57
1357: PUSH
1358: LD_INT 58
1360: PUSH
1361: LD_INT 59
1363: PUSH
1364: LD_INT 60
1366: PUSH
1367: LD_INT 61
1369: PUSH
1370: LD_INT 62
1372: PUSH
1373: LD_INT 80
1375: PUSH
1376: LD_INT 82
1378: PUSH
1379: LD_INT 83
1381: PUSH
1382: LD_INT 84
1384: PUSH
1385: LD_INT 85
1387: PUSH
1388: LD_INT 86
1390: PUSH
1391: EMPTY
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: ST_TO_ADDR
1444: GO 1907
1446: LD_INT 2
1448: DOUBLE
1449: EQUAL
1450: IFTRUE 1454
1452: GO 1676
1454: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1455: LD_ADDR_VAR 0 4
1459: PUSH
1460: LD_INT 35
1462: PUSH
1463: LD_INT 45
1465: PUSH
1466: LD_INT 46
1468: PUSH
1469: LD_INT 47
1471: PUSH
1472: LD_INT 82
1474: PUSH
1475: LD_INT 83
1477: PUSH
1478: LD_INT 84
1480: PUSH
1481: LD_INT 85
1483: PUSH
1484: LD_INT 87
1486: PUSH
1487: LD_INT 70
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: LD_INT 11
1495: PUSH
1496: LD_INT 3
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 5
1504: PUSH
1505: LD_INT 6
1507: PUSH
1508: LD_INT 15
1510: PUSH
1511: LD_INT 18
1513: PUSH
1514: LD_INT 7
1516: PUSH
1517: LD_INT 17
1519: PUSH
1520: LD_INT 8
1522: PUSH
1523: LD_INT 20
1525: PUSH
1526: LD_INT 21
1528: PUSH
1529: LD_INT 22
1531: PUSH
1532: LD_INT 72
1534: PUSH
1535: LD_INT 26
1537: PUSH
1538: LD_INT 69
1540: PUSH
1541: LD_INT 39
1543: PUSH
1544: LD_INT 40
1546: PUSH
1547: LD_INT 41
1549: PUSH
1550: LD_INT 42
1552: PUSH
1553: LD_INT 43
1555: PUSH
1556: LD_INT 48
1558: PUSH
1559: LD_INT 49
1561: PUSH
1562: LD_INT 50
1564: PUSH
1565: LD_INT 51
1567: PUSH
1568: LD_INT 52
1570: PUSH
1571: LD_INT 53
1573: PUSH
1574: LD_INT 54
1576: PUSH
1577: LD_INT 55
1579: PUSH
1580: LD_INT 56
1582: PUSH
1583: LD_INT 60
1585: PUSH
1586: LD_INT 61
1588: PUSH
1589: LD_INT 62
1591: PUSH
1592: LD_INT 66
1594: PUSH
1595: LD_INT 67
1597: PUSH
1598: LD_INT 68
1600: PUSH
1601: LD_INT 81
1603: PUSH
1604: LD_INT 82
1606: PUSH
1607: LD_INT 83
1609: PUSH
1610: LD_INT 84
1612: PUSH
1613: LD_INT 85
1615: PUSH
1616: LD_INT 87
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: ST_TO_ADDR
1674: GO 1907
1676: LD_INT 3
1678: DOUBLE
1679: EQUAL
1680: IFTRUE 1684
1682: GO 1906
1684: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1685: LD_ADDR_VAR 0 4
1689: PUSH
1690: LD_INT 46
1692: PUSH
1693: LD_INT 47
1695: PUSH
1696: LD_INT 1
1698: PUSH
1699: LD_INT 2
1701: PUSH
1702: LD_INT 82
1704: PUSH
1705: LD_INT 83
1707: PUSH
1708: LD_INT 84
1710: PUSH
1711: LD_INT 85
1713: PUSH
1714: LD_INT 86
1716: PUSH
1717: LD_INT 11
1719: PUSH
1720: LD_INT 9
1722: PUSH
1723: LD_INT 20
1725: PUSH
1726: LD_INT 19
1728: PUSH
1729: LD_INT 21
1731: PUSH
1732: LD_INT 24
1734: PUSH
1735: LD_INT 22
1737: PUSH
1738: LD_INT 25
1740: PUSH
1741: LD_INT 28
1743: PUSH
1744: LD_INT 29
1746: PUSH
1747: LD_INT 30
1749: PUSH
1750: LD_INT 31
1752: PUSH
1753: LD_INT 37
1755: PUSH
1756: LD_INT 38
1758: PUSH
1759: LD_INT 32
1761: PUSH
1762: LD_INT 27
1764: PUSH
1765: LD_INT 33
1767: PUSH
1768: LD_INT 69
1770: PUSH
1771: LD_INT 39
1773: PUSH
1774: LD_INT 34
1776: PUSH
1777: LD_INT 40
1779: PUSH
1780: LD_INT 71
1782: PUSH
1783: LD_INT 23
1785: PUSH
1786: LD_INT 44
1788: PUSH
1789: LD_INT 48
1791: PUSH
1792: LD_INT 49
1794: PUSH
1795: LD_INT 50
1797: PUSH
1798: LD_INT 51
1800: PUSH
1801: LD_INT 52
1803: PUSH
1804: LD_INT 53
1806: PUSH
1807: LD_INT 54
1809: PUSH
1810: LD_INT 55
1812: PUSH
1813: LD_INT 56
1815: PUSH
1816: LD_INT 57
1818: PUSH
1819: LD_INT 58
1821: PUSH
1822: LD_INT 59
1824: PUSH
1825: LD_INT 63
1827: PUSH
1828: LD_INT 64
1830: PUSH
1831: LD_INT 65
1833: PUSH
1834: LD_INT 82
1836: PUSH
1837: LD_INT 83
1839: PUSH
1840: LD_INT 84
1842: PUSH
1843: LD_INT 85
1845: PUSH
1846: LD_INT 86
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: ST_TO_ADDR
1904: GO 1907
1906: POP
// if state > - 1 and state < 3 then
1907: LD_VAR 0 3
1911: PUSH
1912: LD_INT 1
1914: NEG
1915: GREATER
1916: PUSH
1917: LD_VAR 0 3
1921: PUSH
1922: LD_INT 3
1924: LESS
1925: AND
1926: IFFALSE 1983
// for i in result do
1928: LD_ADDR_VAR 0 5
1932: PUSH
1933: LD_VAR 0 4
1937: PUSH
1938: FOR_IN
1939: IFFALSE 1981
// if GetTech ( i , side ) <> state then
1941: LD_VAR 0 5
1945: PPUSH
1946: LD_VAR 0 1
1950: PPUSH
1951: CALL_OW 321
1955: PUSH
1956: LD_VAR 0 3
1960: NONEQUAL
1961: IFFALSE 1979
// result := result diff i ;
1963: LD_ADDR_VAR 0 4
1967: PUSH
1968: LD_VAR 0 4
1972: PUSH
1973: LD_VAR 0 5
1977: DIFF
1978: ST_TO_ADDR
1979: GO 1938
1981: POP
1982: POP
// end ; end_of_file
1983: LD_VAR 0 4
1987: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1988: LD_INT 0
1990: PPUSH
1991: PPUSH
1992: PPUSH
1993: PPUSH
// uc_side := 5 ;
1994: LD_ADDR_OWVAR 20
1998: PUSH
1999: LD_INT 5
2001: ST_TO_ADDR
// uc_nation := 2 ;
2002: LD_ADDR_OWVAR 21
2006: PUSH
2007: LD_INT 2
2009: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
2010: LD_INT 5
2012: PPUSH
2013: CALL_OW 274
2017: PPUSH
2018: LD_INT 1
2020: PPUSH
2021: LD_INT 45
2023: PPUSH
2024: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
2028: LD_ADDR_EXP 35
2032: PUSH
2033: LD_STRING Farmer
2035: PPUSH
2036: LD_INT 0
2038: PPUSH
2039: LD_STRING 
2041: PPUSH
2042: CALL 305 0 3
2046: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2047: LD_ADDR_EXP 36
2051: PUSH
2052: LD_STRING Omar
2054: PPUSH
2055: LD_INT 0
2057: PPUSH
2058: LD_STRING 
2060: PPUSH
2061: CALL 305 0 3
2065: ST_TO_ADDR
// omarSquad := [ ] ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: EMPTY
2072: ST_TO_ADDR
// heikeSquad := [ ] ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: EMPTY
2079: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2080: LD_ADDR_EXP 41
2084: PUSH
2085: EMPTY
2086: ST_TO_ADDR
// omarCargo := [ ] ;
2087: LD_ADDR_EXP 42
2091: PUSH
2092: EMPTY
2093: ST_TO_ADDR
// for i := 1 to 5 do
2094: LD_ADDR_VAR 0 2
2098: PUSH
2099: DOUBLE
2100: LD_INT 1
2102: DEC
2103: ST_TO_ADDR
2104: LD_INT 5
2106: PUSH
2107: FOR_TO
2108: IFFALSE 2266
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2110: LD_INT 0
2112: PPUSH
2113: LD_INT 1
2115: PUSH
2116: LD_INT 1
2118: PUSH
2119: LD_INT 2
2121: PUSH
2122: LD_INT 1
2124: PUSH
2125: LD_INT 1
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: LIST
2134: PUSH
2135: LD_VAR 0 2
2139: ARRAY
2140: PPUSH
2141: LD_INT 3
2143: PPUSH
2144: CALL_OW 380
// un := CreateHuman ;
2148: LD_ADDR_VAR 0 3
2152: PUSH
2153: CALL_OW 44
2157: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2158: LD_ADDR_EXP 39
2162: PUSH
2163: LD_EXP 39
2167: PUSH
2168: LD_VAR 0 3
2172: UNION
2173: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2174: LD_VAR 0 3
2178: PPUSH
2179: LD_INT 87
2181: PUSH
2182: LD_INT 30
2184: PUSH
2185: EMPTY
2186: LIST
2187: LIST
2188: PUSH
2189: LD_INT 91
2191: PUSH
2192: LD_INT 32
2194: PUSH
2195: EMPTY
2196: LIST
2197: LIST
2198: PUSH
2199: LD_INT 82
2201: PUSH
2202: LD_INT 15
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: PUSH
2209: LD_INT 79
2211: PUSH
2212: LD_INT 14
2214: PUSH
2215: EMPTY
2216: LIST
2217: LIST
2218: PUSH
2219: LD_INT 82
2221: PUSH
2222: LD_INT 13
2224: PUSH
2225: EMPTY
2226: LIST
2227: LIST
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: LIST
2233: LIST
2234: LIST
2235: PUSH
2236: LD_VAR 0 2
2240: ARRAY
2241: PPUSH
2242: LD_INT 0
2244: PPUSH
2245: CALL 936 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2249: LD_VAR 0 3
2253: PPUSH
2254: LD_INT 93
2256: PPUSH
2257: LD_INT 21
2259: PPUSH
2260: CALL_OW 118
// end ;
2264: GO 2107
2266: POP
2267: POP
// uc_side := 2 ;
2268: LD_ADDR_OWVAR 20
2272: PUSH
2273: LD_INT 2
2275: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2276: LD_ADDR_EXP 27
2280: PUSH
2281: LD_STRING Heike
2283: PPUSH
2284: LD_EXP 1
2288: NOT
2289: PPUSH
2290: LD_EXP 2
2294: PPUSH
2295: CALL 305 0 3
2299: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2300: LD_ADDR_EXP 31
2304: PUSH
2305: LD_STRING Aviradze
2307: PPUSH
2308: LD_EXP 1
2312: NOT
2313: PPUSH
2314: LD_EXP 2
2318: PPUSH
2319: CALL 305 0 3
2323: ST_TO_ADDR
// tmp := [ ] ;
2324: LD_ADDR_VAR 0 4
2328: PUSH
2329: EMPTY
2330: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2331: LD_ADDR_EXP 28
2335: PUSH
2336: LD_STRING Givi
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_EXP 2
2349: PPUSH
2350: CALL 305 0 3
2354: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2355: LD_ADDR_EXP 29
2359: PUSH
2360: LD_STRING Mike
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_EXP 2
2373: PPUSH
2374: CALL 305 0 3
2378: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2379: LD_ADDR_EXP 30
2383: PUSH
2384: LD_STRING Kamil
2386: PPUSH
2387: LD_EXP 1
2391: NOT
2392: PPUSH
2393: LD_EXP 2
2397: PPUSH
2398: CALL 305 0 3
2402: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2403: LD_ADDR_EXP 32
2407: PUSH
2408: LD_STRING Kaia
2410: PPUSH
2411: LD_EXP 1
2415: NOT
2416: PPUSH
2417: LD_EXP 2
2421: PPUSH
2422: CALL 305 0 3
2426: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2427: LD_ADDR_EXP 33
2431: PUSH
2432: LD_STRING Sophia
2434: PPUSH
2435: LD_EXP 1
2439: NOT
2440: PPUSH
2441: LD_EXP 2
2445: PPUSH
2446: CALL 305 0 3
2450: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2451: LD_ADDR_EXP 34
2455: PUSH
2456: LD_STRING Markov
2458: PPUSH
2459: LD_EXP 1
2463: NOT
2464: PPUSH
2465: LD_EXP 2
2469: PPUSH
2470: CALL 305 0 3
2474: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2475: LD_ADDR_EXP 41
2479: PUSH
2480: LD_STRING 02_others
2482: PPUSH
2483: CALL_OW 31
2487: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2488: LD_ADDR_VAR 0 4
2492: PUSH
2493: LD_EXP 29
2497: PUSH
2498: LD_EXP 30
2502: PUSH
2503: LD_EXP 32
2507: PUSH
2508: LD_EXP 33
2512: PUSH
2513: LD_EXP 34
2517: PUSH
2518: LD_EXP 28
2522: PUSH
2523: EMPTY
2524: LIST
2525: LIST
2526: LIST
2527: LIST
2528: LIST
2529: LIST
2530: PUSH
2531: LD_EXP 41
2535: ADD
2536: PUSH
2537: LD_INT 0
2539: DIFF
2540: ST_TO_ADDR
// heikeSquad := tmp ;
2541: LD_ADDR_EXP 40
2545: PUSH
2546: LD_VAR 0 4
2550: ST_TO_ADDR
// if UnitFilter ( heikeSquad , [ f_class , 1 ] ) < 3 then
2551: LD_EXP 40
2555: PPUSH
2556: LD_INT 25
2558: PUSH
2559: LD_INT 1
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PPUSH
2566: CALL_OW 72
2570: PUSH
2571: LD_INT 3
2573: LESS
2574: IFFALSE 2624
// begin SetClass ( Kaia , 1 ) ;
2576: LD_EXP 32
2580: PPUSH
2581: LD_INT 1
2583: PPUSH
2584: CALL_OW 336
// SetClass ( Mike , 1 ) ;
2588: LD_EXP 29
2592: PPUSH
2593: LD_INT 1
2595: PPUSH
2596: CALL_OW 336
// SetClass ( Givi , 1 ) ;
2600: LD_EXP 28
2604: PPUSH
2605: LD_INT 1
2607: PPUSH
2608: CALL_OW 336
// SetClass ( Heike , 1 ) ;
2612: LD_EXP 27
2616: PPUSH
2617: LD_INT 1
2619: PPUSH
2620: CALL_OW 336
// end ; tmp := tmp union CreateCharacterSet ( 02_ape ) ;
2624: LD_ADDR_VAR 0 4
2628: PUSH
2629: LD_VAR 0 4
2633: PUSH
2634: LD_STRING 02_ape
2636: PPUSH
2637: CALL_OW 31
2641: UNION
2642: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2643: LD_EXP 27
2647: PPUSH
2648: LD_INT 92
2650: PPUSH
2651: LD_INT 17
2653: PPUSH
2654: LD_INT 0
2656: PPUSH
2657: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2661: LD_EXP 35
2665: PPUSH
2666: LD_INT 95
2668: PPUSH
2669: LD_INT 19
2671: PPUSH
2672: LD_INT 0
2674: PPUSH
2675: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2679: LD_EXP 36
2683: PPUSH
2684: LD_INT 89
2686: PPUSH
2687: LD_INT 25
2689: PPUSH
2690: LD_INT 0
2692: PPUSH
2693: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2697: LD_EXP 31
2701: PPUSH
2702: LD_INT 92
2704: PPUSH
2705: LD_INT 27
2707: PPUSH
2708: LD_INT 0
2710: PPUSH
2711: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2715: LD_EXP 36
2719: PPUSH
2720: LD_EXP 31
2724: PPUSH
2725: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2729: LD_EXP 31
2733: PPUSH
2734: LD_EXP 36
2738: PPUSH
2739: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2743: LD_EXP 27
2747: PUSH
2748: LD_EXP 35
2752: PUSH
2753: EMPTY
2754: LIST
2755: LIST
2756: PPUSH
2757: LD_EXP 36
2761: PPUSH
2762: CALL_OW 119
// if tmp then
2766: LD_VAR 0 4
2770: IFFALSE 2824
// for i in tmp do
2772: LD_ADDR_VAR 0 2
2776: PUSH
2777: LD_VAR 0 4
2781: PUSH
2782: FOR_IN
2783: IFFALSE 2822
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2785: LD_VAR 0 2
2789: PPUSH
2790: LD_INT 94
2792: PPUSH
2793: LD_INT 14
2795: PPUSH
2796: LD_INT 4
2798: PPUSH
2799: LD_INT 0
2801: PPUSH
2802: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2806: LD_VAR 0 2
2810: PPUSH
2811: LD_EXP 27
2815: PPUSH
2816: CALL_OW 119
// end ;
2820: GO 2782
2822: POP
2823: POP
// farmerSquad := [ ] ;
2824: LD_ADDR_EXP 38
2828: PUSH
2829: EMPTY
2830: ST_TO_ADDR
// uc_side := 5 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 5
2838: ST_TO_ADDR
// uc_nation := 2 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 2
2846: ST_TO_ADDR
// for i := 1 to 4 do
2847: LD_ADDR_VAR 0 2
2851: PUSH
2852: DOUBLE
2853: LD_INT 1
2855: DEC
2856: ST_TO_ADDR
2857: LD_INT 4
2859: PUSH
2860: FOR_TO
2861: IFFALSE 2939
// begin PrepareHuman ( false , 1 , 2 ) ;
2863: LD_INT 0
2865: PPUSH
2866: LD_INT 1
2868: PPUSH
2869: LD_INT 2
2871: PPUSH
2872: CALL_OW 380
// un := CreateHuman ;
2876: LD_ADDR_VAR 0 3
2880: PUSH
2881: CALL_OW 44
2885: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2886: LD_VAR 0 3
2890: PPUSH
2891: LD_INT 102
2893: PPUSH
2894: LD_INT 27
2896: PPUSH
2897: LD_INT 4
2899: PPUSH
2900: LD_INT 0
2902: PPUSH
2903: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2907: LD_ADDR_EXP 38
2911: PUSH
2912: LD_EXP 38
2916: PUSH
2917: LD_VAR 0 3
2921: UNION
2922: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2923: LD_VAR 0 3
2927: PPUSH
2928: LD_EXP 36
2932: PPUSH
2933: CALL_OW 119
// end ;
2937: GO 2860
2939: POP
2940: POP
// for i := 1 to 2 do
2941: LD_ADDR_VAR 0 2
2945: PUSH
2946: DOUBLE
2947: LD_INT 1
2949: DEC
2950: ST_TO_ADDR
2951: LD_INT 2
2953: PUSH
2954: FOR_TO
2955: IFFALSE 3033
// begin PrepareHuman ( false , 2 , 2 ) ;
2957: LD_INT 0
2959: PPUSH
2960: LD_INT 2
2962: PPUSH
2963: LD_INT 2
2965: PPUSH
2966: CALL_OW 380
// un := CreateHuman ;
2970: LD_ADDR_VAR 0 3
2974: PUSH
2975: CALL_OW 44
2979: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2980: LD_VAR 0 3
2984: PPUSH
2985: LD_INT 108
2987: PPUSH
2988: LD_INT 62
2990: PPUSH
2991: LD_INT 2
2993: PPUSH
2994: LD_INT 0
2996: PPUSH
2997: CALL_OW 50
// farmerSquad := farmerSquad union un ;
3001: LD_ADDR_EXP 38
3005: PUSH
3006: LD_EXP 38
3010: PUSH
3011: LD_VAR 0 3
3015: UNION
3016: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
3017: LD_VAR 0 3
3021: PPUSH
3022: LD_EXP 36
3026: PPUSH
3027: CALL_OW 119
// end ;
3031: GO 2954
3033: POP
3034: POP
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
3035: LD_INT 109
3037: PPUSH
3038: LD_INT 63
3040: PPUSH
3041: LD_INT 2
3043: PPUSH
3044: LD_INT 15
3046: NEG
3047: PPUSH
3048: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
3052: LD_INT 109
3054: PPUSH
3055: LD_INT 63
3057: PPUSH
3058: LD_INT 2
3060: PPUSH
3061: CALL_OW 331
// end ;
3065: LD_VAR 0 1
3069: RET
// export function PrepareIbrahim ( x , y ) ; begin
3070: LD_INT 0
3072: PPUSH
// uc_side := 6 ;
3073: LD_ADDR_OWVAR 20
3077: PUSH
3078: LD_INT 6
3080: ST_TO_ADDR
// uc_nation := 3 ;
3081: LD_ADDR_OWVAR 21
3085: PUSH
3086: LD_INT 3
3088: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3089: LD_ADDR_EXP 37
3093: PUSH
3094: LD_STRING IbrahimRu
3096: PPUSH
3097: LD_INT 0
3099: PPUSH
3100: LD_STRING 
3102: PPUSH
3103: CALL 305 0 3
3107: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3108: LD_EXP 37
3112: PPUSH
3113: LD_VAR 0 1
3117: PPUSH
3118: LD_VAR 0 2
3122: PPUSH
3123: LD_INT 8
3125: PPUSH
3126: LD_INT 1
3128: PPUSH
3129: CALL_OW 50
// end ;
3133: LD_VAR 0 3
3137: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3138: LD_EXP 36
3142: PUSH
3143: LD_EXP 39
3147: ADD
3148: PPUSH
3149: LD_INT 95
3151: PUSH
3152: LD_INT 3
3154: PUSH
3155: EMPTY
3156: LIST
3157: LIST
3158: PPUSH
3159: CALL_OW 72
3163: IFFALSE 3219
3165: GO 3167
3167: DISABLE
3168: LD_INT 0
3170: PPUSH
// begin enable ;
3171: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3172: LD_ADDR_VAR 0 1
3176: PUSH
3177: LD_EXP 36
3181: PUSH
3182: LD_EXP 39
3186: ADD
3187: PPUSH
3188: LD_INT 95
3190: PUSH
3191: LD_INT 3
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: PPUSH
3198: CALL_OW 72
3202: PUSH
3203: FOR_IN
3204: IFFALSE 3217
// RemoveUnit ( i ) ;
3206: LD_VAR 0 1
3210: PPUSH
3211: CALL_OW 64
3215: GO 3203
3217: POP
3218: POP
// end ;
3219: PPOPN 1
3221: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3222: LD_EXP 3
3226: PUSH
3227: LD_EXP 35
3231: PPUSH
3232: LD_INT 4
3234: PPUSH
3235: CALL_OW 308
3239: AND
3240: IFFALSE 4023
3242: GO 3244
3244: DISABLE
3245: LD_INT 0
3247: PPUSH
3248: PPUSH
3249: PPUSH
3250: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3251: LD_EXP 35
3255: PPUSH
3256: LD_INT 110
3258: PPUSH
3259: LD_INT 60
3261: PPUSH
3262: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3266: LD_EXP 35
3270: PPUSH
3271: LD_INT 110
3273: PPUSH
3274: LD_INT 61
3276: PPUSH
3277: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3281: LD_ADDR_VAR 0 2
3285: PUSH
3286: LD_EXP 38
3290: PPUSH
3291: LD_INT 25
3293: PUSH
3294: LD_INT 1
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PPUSH
3301: CALL_OW 72
3305: ST_TO_ADDR
// if tmp then
3306: LD_VAR 0 2
3310: IFFALSE 3404
// begin for i := 1 to 2 do
3312: LD_ADDR_VAR 0 1
3316: PUSH
3317: DOUBLE
3318: LD_INT 1
3320: DEC
3321: ST_TO_ADDR
3322: LD_INT 2
3324: PUSH
3325: FOR_TO
3326: IFFALSE 3402
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3328: LD_VAR 0 2
3332: PUSH
3333: LD_VAR 0 1
3337: ARRAY
3338: PPUSH
3339: LD_INT 5
3341: PPUSH
3342: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3346: LD_VAR 0 2
3350: PUSH
3351: LD_VAR 0 1
3355: ARRAY
3356: PPUSH
3357: LD_INT 2
3359: PPUSH
3360: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3364: LD_VAR 0 2
3368: PUSH
3369: LD_VAR 0 1
3373: ARRAY
3374: PPUSH
3375: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3379: LD_VAR 0 2
3383: PUSH
3384: LD_VAR 0 1
3388: ARRAY
3389: PPUSH
3390: LD_INT 107
3392: PPUSH
3393: LD_INT 66
3395: PPUSH
3396: CALL_OW 171
// end ;
3400: GO 3325
3402: POP
3403: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3404: LD_ADDR_VAR 0 2
3408: PUSH
3409: LD_EXP 38
3413: PPUSH
3414: LD_INT 25
3416: PUSH
3417: LD_INT 2
3419: PUSH
3420: EMPTY
3421: LIST
3422: LIST
3423: PPUSH
3424: CALL_OW 72
3428: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3429: LD_INT 35
3431: PPUSH
3432: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3436: LD_ADDR_VAR 0 2
3440: PUSH
3441: LD_EXP 38
3445: PPUSH
3446: LD_INT 25
3448: PUSH
3449: LD_INT 2
3451: PUSH
3452: EMPTY
3453: LIST
3454: LIST
3455: PPUSH
3456: CALL_OW 72
3460: ST_TO_ADDR
// until tmp ;
3461: LD_VAR 0 2
3465: IFFALSE 3429
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3467: LD_VAR 0 2
3471: PPUSH
3472: LD_INT 31
3474: PPUSH
3475: LD_INT 102
3477: PPUSH
3478: LD_INT 69
3480: PPUSH
3481: LD_INT 2
3483: PPUSH
3484: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3488: LD_INT 35
3490: PPUSH
3491: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3495: LD_EXP 38
3499: PPUSH
3500: LD_INT 3
3502: PUSH
3503: LD_INT 60
3505: PUSH
3506: EMPTY
3507: LIST
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 25
3515: PUSH
3516: LD_INT 2
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: PPUSH
3527: CALL_OW 72
3531: IFFALSE 3488
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3533: LD_ADDR_VAR 0 2
3537: PUSH
3538: LD_EXP 38
3542: PPUSH
3543: LD_INT 25
3545: PUSH
3546: LD_INT 2
3548: PUSH
3549: EMPTY
3550: LIST
3551: LIST
3552: PPUSH
3553: CALL_OW 72
3557: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3558: LD_VAR 0 2
3562: PPUSH
3563: LD_INT 4
3565: PPUSH
3566: LD_INT 116
3568: PPUSH
3569: LD_INT 70
3571: PPUSH
3572: LD_INT 5
3574: PPUSH
3575: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3579: LD_VAR 0 2
3583: PPUSH
3584: LD_INT 31
3586: PPUSH
3587: LD_INT 108
3589: PPUSH
3590: LD_INT 50
3592: PPUSH
3593: LD_INT 2
3595: PPUSH
3596: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3600: LD_INT 35
3602: PPUSH
3603: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3607: LD_INT 22
3609: PUSH
3610: LD_INT 5
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: LD_INT 30
3619: PUSH
3620: LD_INT 4
3622: PUSH
3623: EMPTY
3624: LIST
3625: LIST
3626: PUSH
3627: LD_INT 3
3629: PUSH
3630: LD_INT 57
3632: PUSH
3633: EMPTY
3634: LIST
3635: PUSH
3636: EMPTY
3637: LIST
3638: LIST
3639: PUSH
3640: EMPTY
3641: LIST
3642: LIST
3643: LIST
3644: PPUSH
3645: CALL_OW 69
3649: IFFALSE 3600
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3651: LD_ADDR_VAR 0 3
3655: PUSH
3656: LD_INT 22
3658: PUSH
3659: LD_INT 5
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: PUSH
3666: LD_INT 30
3668: PUSH
3669: LD_INT 4
3671: PUSH
3672: EMPTY
3673: LIST
3674: LIST
3675: PUSH
3676: LD_INT 3
3678: PUSH
3679: LD_INT 57
3681: PUSH
3682: EMPTY
3683: LIST
3684: PUSH
3685: EMPTY
3686: LIST
3687: LIST
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: LIST
3693: PPUSH
3694: CALL_OW 69
3698: PUSH
3699: LD_INT 1
3701: ARRAY
3702: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3703: LD_ADDR_VAR 0 2
3707: PUSH
3708: LD_EXP 38
3712: PPUSH
3713: LD_INT 25
3715: PUSH
3716: LD_INT 1
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: PPUSH
3723: CALL_OW 72
3727: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3728: LD_VAR 0 2
3732: PPUSH
3733: LD_VAR 0 3
3737: PPUSH
3738: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3742: LD_INT 35
3744: PPUSH
3745: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3749: LD_INT 22
3751: PUSH
3752: LD_INT 5
3754: PUSH
3755: EMPTY
3756: LIST
3757: LIST
3758: PUSH
3759: LD_INT 30
3761: PUSH
3762: LD_INT 31
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: PUSH
3769: LD_INT 3
3771: PUSH
3772: LD_INT 57
3774: PUSH
3775: EMPTY
3776: LIST
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: LIST
3786: PPUSH
3787: CALL_OW 69
3791: PUSH
3792: LD_INT 2
3794: GREATEREQUAL
3795: IFFALSE 3742
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3797: LD_ADDR_VAR 0 2
3801: PUSH
3802: LD_EXP 38
3806: PPUSH
3807: LD_INT 25
3809: PUSH
3810: LD_INT 2
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PPUSH
3817: CALL_OW 72
3821: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3822: LD_VAR 0 2
3826: PUSH
3827: LD_INT 1
3829: ARRAY
3830: PPUSH
3831: LD_INT 5
3833: PPUSH
3834: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3838: LD_VAR 0 2
3842: PUSH
3843: LD_INT 2
3845: ARRAY
3846: PUSH
3847: LD_VAR 0 2
3851: PUSH
3852: LD_INT 3
3854: ARRAY
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PPUSH
3860: LD_VAR 0 3
3864: PPUSH
3865: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3869: LD_VAR 0 2
3873: PUSH
3874: LD_INT 2
3876: ARRAY
3877: PUSH
3878: LD_VAR 0 2
3882: PUSH
3883: LD_INT 3
3885: ARRAY
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: LD_INT 1
3893: PPUSH
3894: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3898: LD_VAR 0 2
3902: PUSH
3903: LD_INT 2
3905: ARRAY
3906: PUSH
3907: LD_VAR 0 2
3911: PUSH
3912: LD_INT 3
3914: ARRAY
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PPUSH
3920: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3924: LD_ADDR_VAR 0 4
3928: PUSH
3929: LD_INT 22
3931: PUSH
3932: LD_INT 5
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: PUSH
3939: LD_INT 30
3941: PUSH
3942: LD_INT 31
3944: PUSH
3945: EMPTY
3946: LIST
3947: LIST
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: PPUSH
3953: CALL_OW 69
3957: ST_TO_ADDR
// for i := 1 to 2 do
3958: LD_ADDR_VAR 0 1
3962: PUSH
3963: DOUBLE
3964: LD_INT 1
3966: DEC
3967: ST_TO_ADDR
3968: LD_INT 2
3970: PUSH
3971: FOR_TO
3972: IFFALSE 4006
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3974: LD_VAR 0 2
3978: PUSH
3979: LD_VAR 0 1
3983: PUSH
3984: LD_INT 1
3986: PLUS
3987: ARRAY
3988: PPUSH
3989: LD_VAR 0 4
3993: PUSH
3994: LD_VAR 0 1
3998: ARRAY
3999: PPUSH
4000: CALL_OW 180
4004: GO 3971
4006: POP
4007: POP
// wait ( 1 1$00 ) ;
4008: LD_INT 2100
4010: PPUSH
4011: CALL_OW 67
// farmerBaseReady := true ;
4015: LD_ADDR_EXP 4
4019: PUSH
4020: LD_INT 1
4022: ST_TO_ADDR
// end ;
4023: PPOPN 4
4025: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
4026: LD_EXP 4
4030: PUSH
4031: LD_EXP 11
4035: NOT
4036: AND
4037: IFFALSE 4559
4039: GO 4041
4041: DISABLE
4042: LD_INT 0
4044: PPUSH
4045: PPUSH
4046: PPUSH
4047: PPUSH
4048: PPUSH
// begin enable ;
4049: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
4050: LD_ADDR_VAR 0 3
4054: PUSH
4055: LD_EXP 38
4059: PPUSH
4060: LD_INT 25
4062: PUSH
4063: LD_INT 1
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: PPUSH
4070: CALL_OW 72
4074: PUSH
4075: LD_EXP 35
4079: ADD
4080: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4081: LD_ADDR_VAR 0 2
4085: PUSH
4086: LD_EXP 38
4090: PPUSH
4091: LD_INT 25
4093: PUSH
4094: LD_INT 2
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: PPUSH
4101: CALL_OW 72
4105: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4106: LD_ADDR_VAR 0 5
4110: PUSH
4111: LD_INT 22
4113: PUSH
4114: LD_INT 5
4116: PUSH
4117: EMPTY
4118: LIST
4119: LIST
4120: PUSH
4121: LD_INT 21
4123: PUSH
4124: LD_INT 3
4126: PUSH
4127: EMPTY
4128: LIST
4129: LIST
4130: PUSH
4131: LD_INT 3
4133: PUSH
4134: LD_INT 24
4136: PUSH
4137: LD_INT 1000
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: LIST
4152: PPUSH
4153: CALL_OW 69
4157: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4158: LD_ADDR_VAR 0 4
4162: PUSH
4163: LD_INT 22
4165: PUSH
4166: LD_INT 5
4168: PUSH
4169: EMPTY
4170: LIST
4171: LIST
4172: PUSH
4173: LD_INT 30
4175: PUSH
4176: LD_INT 4
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: PPUSH
4187: CALL_OW 69
4191: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4192: LD_VAR 0 4
4196: PUSH
4197: LD_INT 1
4199: ARRAY
4200: PPUSH
4201: CALL_OW 302
4205: IFFALSE 4269
// for i in sol do
4207: LD_ADDR_VAR 0 1
4211: PUSH
4212: LD_VAR 0 3
4216: PUSH
4217: FOR_IN
4218: IFFALSE 4267
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4220: LD_VAR 0 1
4224: PPUSH
4225: CALL_OW 256
4229: PUSH
4230: LD_INT 999
4232: LESS
4233: PUSH
4234: LD_VAR 0 1
4238: PPUSH
4239: CALL_OW 310
4243: NOT
4244: AND
4245: IFFALSE 4265
// ComEnterUnit ( i , arm [ 1 ] ) ;
4247: LD_VAR 0 1
4251: PPUSH
4252: LD_VAR 0 4
4256: PUSH
4257: LD_INT 1
4259: ARRAY
4260: PPUSH
4261: CALL_OW 120
4265: GO 4217
4267: POP
4268: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4269: LD_VAR 0 2
4273: NOT
4274: PUSH
4275: LD_INT 22
4277: PUSH
4278: LD_INT 1
4280: PUSH
4281: EMPTY
4282: LIST
4283: LIST
4284: PUSH
4285: LD_INT 21
4287: PUSH
4288: LD_INT 1
4290: PUSH
4291: EMPTY
4292: LIST
4293: LIST
4294: PUSH
4295: EMPTY
4296: LIST
4297: LIST
4298: PPUSH
4299: CALL_OW 69
4303: NOT
4304: AND
4305: IFFALSE 4397
// begin uc_side := 5 ;
4307: LD_ADDR_OWVAR 20
4311: PUSH
4312: LD_INT 5
4314: ST_TO_ADDR
// uc_nation := 2 ;
4315: LD_ADDR_OWVAR 21
4319: PUSH
4320: LD_INT 2
4322: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4323: LD_INT 0
4325: PPUSH
4326: LD_INT 2
4328: PPUSH
4329: LD_INT 2
4331: PPUSH
4332: CALL_OW 380
// eng := CreateHuman ;
4336: LD_ADDR_VAR 0 2
4340: PUSH
4341: CALL_OW 44
4345: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4346: LD_VAR 0 2
4350: PPUSH
4351: LD_INT 102
4353: PPUSH
4354: LD_INT 8
4356: PPUSH
4357: LD_INT 0
4359: PPUSH
4360: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4364: LD_VAR 0 2
4368: PPUSH
4369: LD_INT 110
4371: PPUSH
4372: LD_INT 60
4374: PPUSH
4375: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4379: LD_ADDR_EXP 38
4383: PUSH
4384: LD_EXP 38
4388: PUSH
4389: LD_VAR 0 2
4393: UNION
4394: ST_TO_ADDR
// end else
4395: GO 4559
// begin for i in eng do
4397: LD_ADDR_VAR 0 1
4401: PUSH
4402: LD_VAR 0 2
4406: PUSH
4407: FOR_IN
4408: IFFALSE 4557
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4410: LD_INT 10
4412: PPUSH
4413: LD_INT 1
4415: PPUSH
4416: CALL_OW 287
4420: IFFALSE 4471
// begin if IsInUnit ( i ) then
4422: LD_VAR 0 1
4426: PPUSH
4427: CALL_OW 310
4431: IFFALSE 4442
// ComExitBuilding ( i ) ;
4433: LD_VAR 0 1
4437: PPUSH
4438: CALL_OW 122
// if not IsInArea ( i , collectFarmerArea ) then
4442: LD_VAR 0 1
4446: PPUSH
4447: LD_INT 10
4449: PPUSH
4450: CALL_OW 308
4454: NOT
4455: IFFALSE 4469
// AddComMoveToArea ( i , collectFarmerArea ) ;
4457: LD_VAR 0 1
4461: PPUSH
4462: LD_INT 10
4464: PPUSH
4465: CALL_OW 173
// end else
4469: GO 4555
// begin if damagedBuilding then
4471: LD_VAR 0 5
4475: IFFALSE 4519
// begin if IsInUnit ( i ) then
4477: LD_VAR 0 1
4481: PPUSH
4482: CALL_OW 310
4486: IFFALSE 4499
// ComExitBuilding ( i ) else
4488: LD_VAR 0 1
4492: PPUSH
4493: CALL_OW 122
4497: GO 4517
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4499: LD_VAR 0 1
4503: PPUSH
4504: LD_VAR 0 5
4508: PUSH
4509: LD_INT 1
4511: ARRAY
4512: PPUSH
4513: CALL_OW 130
// end else
4517: GO 4555
// if not IsInUnit ( i ) and not HasTask ( i ) then
4519: LD_VAR 0 1
4523: PPUSH
4524: CALL_OW 310
4528: NOT
4529: PUSH
4530: LD_VAR 0 1
4534: PPUSH
4535: CALL_OW 314
4539: NOT
4540: AND
4541: IFFALSE 4555
// ComEnterUnit ( i , arDepot ) ;
4543: LD_VAR 0 1
4547: PPUSH
4548: LD_INT 5
4550: PPUSH
4551: CALL_OW 120
// end ; end ;
4555: GO 4407
4557: POP
4558: POP
// end ; end ;
4559: PPOPN 5
4561: END
// export function StartCargoEvacuation ; begin
4562: LD_INT 0
4564: PPUSH
// while omarCargoCounter > 0 do
4565: LD_EXP 20
4569: PUSH
4570: LD_INT 0
4572: GREATER
4573: IFFALSE 4890
// begin wait ( 0 0$40 ) ;
4575: LD_INT 1400
4577: PPUSH
4578: CALL_OW 67
// omarCargo := PrepareCargo ;
4582: LD_ADDR_EXP 42
4586: PUSH
4587: CALL 4895 0 0
4591: ST_TO_ADDR
// SetTag ( omarCargo , 0 ) ;
4592: LD_EXP 42
4596: PPUSH
4597: LD_INT 0
4599: PPUSH
4600: CALL_OW 109
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4604: LD_EXP 42
4608: PPUSH
4609: LD_INT 107
4611: PPUSH
4612: LD_INT 59
4614: PPUSH
4615: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4619: LD_INT 35
4621: PPUSH
4622: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4626: LD_EXP 42
4630: PPUSH
4631: LD_INT 107
4633: PPUSH
4634: LD_INT 59
4636: PPUSH
4637: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4641: LD_EXP 42
4645: PPUSH
4646: CALL_OW 302
4650: NOT
4651: PUSH
4652: LD_EXP 42
4656: PPUSH
4657: CALL_OW 301
4661: OR
4662: IFFALSE 4666
// continue ;
4664: GO 4619
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4666: LD_EXP 42
4670: PPUSH
4671: LD_INT 107
4673: PPUSH
4674: LD_INT 59
4676: PPUSH
4677: CALL_OW 307
4681: PUSH
4682: LD_EXP 42
4686: PPUSH
4687: LD_INT 5
4689: PPUSH
4690: CALL_OW 296
4694: PUSH
4695: LD_INT 6
4697: LESS
4698: OR
4699: IFFALSE 4619
// SetTag ( omarCargo , 1 ) ;
4701: LD_EXP 42
4705: PPUSH
4706: LD_INT 1
4708: PPUSH
4709: CALL_OW 109
// wait ( 0 0$05 ) ;
4713: LD_INT 175
4715: PPUSH
4716: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4720: LD_EXP 42
4724: PPUSH
4725: LD_INT 5
4727: PPUSH
4728: LD_INT 1
4730: PPUSH
4731: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4735: LD_EXP 42
4739: PPUSH
4740: LD_INT 103
4742: PPUSH
4743: LD_INT 9
4745: PPUSH
4746: CALL_OW 171
// wait ( 0 0$1 ) ;
4750: LD_INT 35
4752: PPUSH
4753: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
4757: LD_EXP 42
4761: PPUSH
4762: LD_INT 1
4764: PPUSH
4765: LD_INT 100
4767: PPUSH
4768: CALL_OW 290
// repeat wait ( 0 0$1 ) ;
4772: LD_INT 35
4774: PPUSH
4775: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4779: LD_EXP 42
4783: PPUSH
4784: LD_INT 103
4786: PPUSH
4787: LD_INT 9
4789: PPUSH
4790: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4794: LD_EXP 42
4798: PPUSH
4799: CALL_OW 302
4803: NOT
4804: PUSH
4805: LD_EXP 42
4809: PPUSH
4810: CALL_OW 301
4814: OR
4815: IFFALSE 4819
// continue ;
4817: GO 4772
// until ( IsAt ( omarCargo , 103 , 9 ) or IsInArea ( omarCargo , northRoad ) ) and GetTag ( omarCargo ) > 0 ;
4819: LD_EXP 42
4823: PPUSH
4824: LD_INT 103
4826: PPUSH
4827: LD_INT 9
4829: PPUSH
4830: CALL_OW 307
4834: PUSH
4835: LD_EXP 42
4839: PPUSH
4840: LD_INT 3
4842: PPUSH
4843: CALL_OW 308
4847: OR
4848: PUSH
4849: LD_EXP 42
4853: PPUSH
4854: CALL_OW 110
4858: PUSH
4859: LD_INT 0
4861: GREATER
4862: AND
4863: IFFALSE 4772
// RemoveUnit ( omarCargo ) ;
4865: LD_EXP 42
4869: PPUSH
4870: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4874: LD_ADDR_EXP 20
4878: PUSH
4879: LD_EXP 20
4883: PUSH
4884: LD_INT 1
4886: MINUS
4887: ST_TO_ADDR
// end ;
4888: GO 4565
// end ;
4890: LD_VAR 0 1
4894: RET
// export function PrepareCargo ; var un , veh ; begin
4895: LD_INT 0
4897: PPUSH
4898: PPUSH
4899: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4900: LD_ADDR_VAR 0 3
4904: PUSH
4905: LD_INT 5
4907: PPUSH
4908: LD_INT 2
4910: PPUSH
4911: LD_INT 13
4913: PPUSH
4914: LD_INT 1
4916: PPUSH
4917: LD_INT 1
4919: PPUSH
4920: LD_INT 32
4922: PPUSH
4923: LD_INT 80
4925: PPUSH
4926: CALL 368 0 7
4930: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4931: LD_VAR 0 3
4935: PPUSH
4936: LD_INT 4
4938: PPUSH
4939: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4943: LD_VAR 0 3
4947: PPUSH
4948: LD_INT 101
4950: PPUSH
4951: LD_INT 8
4953: PPUSH
4954: LD_INT 0
4956: PPUSH
4957: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4961: LD_INT 0
4963: PPUSH
4964: LD_INT 3
4966: PPUSH
4967: LD_INT 2
4969: PPUSH
4970: CALL_OW 380
// un := CreateHuman ;
4974: LD_ADDR_VAR 0 2
4978: PUSH
4979: CALL_OW 44
4983: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4984: LD_VAR 0 2
4988: PPUSH
4989: LD_VAR 0 3
4993: PPUSH
4994: CALL_OW 52
// result := veh ;
4998: LD_ADDR_VAR 0 1
5002: PUSH
5003: LD_VAR 0 3
5007: ST_TO_ADDR
// end ; end_of_file
5008: LD_VAR 0 1
5012: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
5013: LD_INT 0
5015: PPUSH
5016: PPUSH
5017: PPUSH
// usForces := [ ] ;
5018: LD_ADDR_EXP 43
5022: PUSH
5023: EMPTY
5024: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
5025: LD_ADDR_EXP 45
5029: PUSH
5030: LD_INT 6
5032: PUSH
5033: LD_INT 32
5035: PUSH
5036: LD_INT 27
5038: PUSH
5039: LD_INT 1
5041: PUSH
5042: EMPTY
5043: LIST
5044: LIST
5045: LIST
5046: LIST
5047: PUSH
5048: LD_INT 4
5050: PUSH
5051: LD_INT 43
5053: PUSH
5054: LD_INT 24
5056: PUSH
5057: LD_INT 5
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: LIST
5064: LIST
5065: PUSH
5066: LD_INT 27
5068: PUSH
5069: LD_INT 29
5071: PUSH
5072: LD_INT 21
5074: PUSH
5075: LD_INT 0
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: LIST
5088: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
5089: LD_INT 11
5091: PPUSH
5092: CALL_OW 274
5096: PPUSH
5097: LD_INT 1
5099: PPUSH
5100: LD_INT 150
5102: PUSH
5103: LD_INT 120
5105: PUSH
5106: LD_INT 100
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: LIST
5113: PUSH
5114: LD_OWVAR 67
5118: ARRAY
5119: PPUSH
5120: CALL_OW 277
// if Difficulty = 1 then
5124: LD_OWVAR 67
5128: PUSH
5129: LD_INT 1
5131: EQUAL
5132: IFFALSE 5141
// RemoveUnit ( hillBun ) ;
5134: LD_INT 14
5136: PPUSH
5137: CALL_OW 64
// uc_side := 1 ;
5141: LD_ADDR_OWVAR 20
5145: PUSH
5146: LD_INT 1
5148: ST_TO_ADDR
// uc_nation := 1 ;
5149: LD_ADDR_OWVAR 21
5153: PUSH
5154: LD_INT 1
5156: ST_TO_ADDR
// hc_gallery :=  ;
5157: LD_ADDR_OWVAR 33
5161: PUSH
5162: LD_STRING 
5164: ST_TO_ADDR
// hc_name :=  ;
5165: LD_ADDR_OWVAR 26
5169: PUSH
5170: LD_STRING 
5172: ST_TO_ADDR
// hc_importance := 0 ;
5173: LD_ADDR_OWVAR 32
5177: PUSH
5178: LD_INT 0
5180: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5181: LD_INT 1
5183: PPUSH
5184: LD_INT 1
5186: PPUSH
5187: LD_INT 3
5189: PPUSH
5190: CALL_OW 380
// usCommander := CreateHuman ;
5194: LD_ADDR_EXP 44
5198: PUSH
5199: CALL_OW 44
5203: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5204: LD_EXP 44
5208: PPUSH
5209: LD_INT 11
5211: PPUSH
5212: CALL_OW 52
// if Difficulty > 1 then
5216: LD_OWVAR 67
5220: PUSH
5221: LD_INT 1
5223: GREATER
5224: IFFALSE 5306
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5226: LD_INT 0
5228: PPUSH
5229: LD_INT 1
5231: PPUSH
5232: LD_INT 1
5234: PUSH
5235: LD_INT 2
5237: PUSH
5238: LD_INT 3
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: LIST
5245: PUSH
5246: LD_OWVAR 67
5250: ARRAY
5251: PPUSH
5252: CALL_OW 380
// un := CreateHuman ;
5256: LD_ADDR_VAR 0 3
5260: PUSH
5261: CALL_OW 44
5265: ST_TO_ADDR
// usForces := usForces union un ;
5266: LD_ADDR_EXP 43
5270: PUSH
5271: LD_EXP 43
5275: PUSH
5276: LD_VAR 0 3
5280: UNION
5281: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5282: LD_VAR 0 3
5286: PPUSH
5287: LD_INT 1
5289: PPUSH
5290: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5294: LD_VAR 0 3
5298: PPUSH
5299: LD_INT 14
5301: PPUSH
5302: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5306: LD_ADDR_VAR 0 2
5310: PUSH
5311: DOUBLE
5312: LD_INT 1
5314: DEC
5315: ST_TO_ADDR
5316: LD_INT 2
5318: PUSH
5319: LD_INT 3
5321: PUSH
5322: LD_INT 4
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: PUSH
5330: LD_OWVAR 67
5334: ARRAY
5335: PUSH
5336: FOR_TO
5337: IFFALSE 5479
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5339: LD_INT 0
5341: PPUSH
5342: LD_INT 1
5344: PPUSH
5345: LD_INT 1
5347: PUSH
5348: LD_INT 2
5350: PUSH
5351: LD_INT 3
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: LIST
5358: PUSH
5359: LD_OWVAR 67
5363: ARRAY
5364: PPUSH
5365: CALL_OW 380
// un := CreateHuman ;
5369: LD_ADDR_VAR 0 3
5373: PUSH
5374: CALL_OW 44
5378: ST_TO_ADDR
// usForces := usForces union un ;
5379: LD_ADDR_EXP 43
5383: PUSH
5384: LD_EXP 43
5388: PUSH
5389: LD_VAR 0 3
5393: UNION
5394: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5395: LD_VAR 0 3
5399: PPUSH
5400: LD_INT 39
5402: PPUSH
5403: LD_INT 24
5405: PPUSH
5406: LD_INT 4
5408: PPUSH
5409: LD_INT 0
5411: PPUSH
5412: CALL_OW 50
// if i < 3 then
5416: LD_VAR 0 2
5420: PUSH
5421: LD_INT 3
5423: LESS
5424: IFFALSE 5477
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5426: LD_VAR 0 3
5430: PPUSH
5431: LD_INT 22
5433: PUSH
5434: LD_INT 1
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: PUSH
5441: LD_INT 58
5443: PUSH
5444: EMPTY
5445: LIST
5446: PUSH
5447: LD_INT 30
5449: PUSH
5450: LD_INT 31
5452: PUSH
5453: EMPTY
5454: LIST
5455: LIST
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: LIST
5461: PPUSH
5462: CALL_OW 69
5466: PUSH
5467: LD_VAR 0 2
5471: ARRAY
5472: PPUSH
5473: CALL_OW 120
// end ;
5477: GO 5336
5479: POP
5480: POP
// for i := 1 to 2 do
5481: LD_ADDR_VAR 0 2
5485: PUSH
5486: DOUBLE
5487: LD_INT 1
5489: DEC
5490: ST_TO_ADDR
5491: LD_INT 2
5493: PUSH
5494: FOR_TO
5495: IFFALSE 5559
// begin PrepareHuman ( false , 2 , 2 ) ;
5497: LD_INT 0
5499: PPUSH
5500: LD_INT 2
5502: PPUSH
5503: LD_INT 2
5505: PPUSH
5506: CALL_OW 380
// un := CreateHuman ;
5510: LD_ADDR_VAR 0 3
5514: PUSH
5515: CALL_OW 44
5519: ST_TO_ADDR
// usForces := usForces union un ;
5520: LD_ADDR_EXP 43
5524: PUSH
5525: LD_EXP 43
5529: PUSH
5530: LD_VAR 0 3
5534: UNION
5535: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5536: LD_VAR 0 3
5540: PPUSH
5541: LD_INT 39
5543: PPUSH
5544: LD_INT 24
5546: PPUSH
5547: LD_INT 4
5549: PPUSH
5550: LD_INT 0
5552: PPUSH
5553: CALL_OW 50
// end ;
5557: GO 5494
5559: POP
5560: POP
// PrepareHuman ( false , 4 , 1 ) ;
5561: LD_INT 0
5563: PPUSH
5564: LD_INT 4
5566: PPUSH
5567: LD_INT 1
5569: PPUSH
5570: CALL_OW 380
// un := CreateHuman ;
5574: LD_ADDR_VAR 0 3
5578: PUSH
5579: CALL_OW 44
5583: ST_TO_ADDR
// usForces := usForces union un ;
5584: LD_ADDR_EXP 43
5588: PUSH
5589: LD_EXP 43
5593: PUSH
5594: LD_VAR 0 3
5598: UNION
5599: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5600: LD_VAR 0 3
5604: PPUSH
5605: LD_INT 39
5607: PPUSH
5608: LD_INT 24
5610: PPUSH
5611: LD_INT 4
5613: PPUSH
5614: LD_INT 0
5616: PPUSH
5617: CALL_OW 50
// end ;
5621: LD_VAR 0 1
5625: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
5626: LD_EXP 43
5630: PUSH
5631: LD_EXP 6
5635: NOT
5636: AND
5637: IFFALSE 6068
5639: GO 5641
5641: DISABLE
5642: LD_INT 0
5644: PPUSH
5645: PPUSH
5646: PPUSH
5647: PPUSH
5648: PPUSH
// begin enable ;
5649: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5650: LD_ADDR_VAR 0 3
5654: PUSH
5655: LD_EXP 43
5659: PPUSH
5660: LD_INT 25
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PPUSH
5670: CALL_OW 72
5674: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5675: LD_ADDR_VAR 0 4
5679: PUSH
5680: LD_EXP 43
5684: PPUSH
5685: LD_INT 25
5687: PUSH
5688: LD_INT 1
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: PPUSH
5695: CALL_OW 72
5699: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5700: LD_ADDR_VAR 0 5
5704: PUSH
5705: LD_EXP 43
5709: PPUSH
5710: LD_INT 25
5712: PUSH
5713: LD_INT 4
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: PPUSH
5720: CALL_OW 72
5724: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5725: LD_INT 7
5727: PPUSH
5728: LD_INT 22
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: PPUSH
5738: CALL_OW 70
5742: PUSH
5743: LD_INT 1
5745: EQUAL
5746: IFFALSE 5822
// for i in sol do
5748: LD_ADDR_VAR 0 1
5752: PUSH
5753: LD_VAR 0 4
5757: PUSH
5758: FOR_IN
5759: IFFALSE 5820
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5761: LD_VAR 0 1
5765: PPUSH
5766: CALL_OW 310
5770: NOT
5771: PUSH
5772: LD_VAR 0 1
5776: PPUSH
5777: CALL_OW 310
5781: PPUSH
5782: CALL_OW 266
5786: PUSH
5787: LD_INT 4
5789: EQUAL
5790: NOT
5791: OR
5792: IFFALSE 5818
// begin ComExitBuilding ( i ) ;
5794: LD_VAR 0 1
5798: PPUSH
5799: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5803: LD_VAR 0 1
5807: PPUSH
5808: LD_INT 37
5810: PPUSH
5811: LD_INT 23
5813: PPUSH
5814: CALL_OW 174
// end ;
5818: GO 5758
5820: POP
5821: POP
// if eng then
5822: LD_VAR 0 3
5826: IFFALSE 6068
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5828: LD_ADDR_VAR 0 2
5832: PUSH
5833: LD_INT 22
5835: PUSH
5836: LD_INT 1
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: LD_INT 95
5845: PUSH
5846: LD_INT 7
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: PUSH
5853: LD_INT 21
5855: PUSH
5856: LD_INT 3
5858: PUSH
5859: EMPTY
5860: LIST
5861: LIST
5862: PUSH
5863: LD_INT 3
5865: PUSH
5866: LD_INT 24
5868: PUSH
5869: LD_INT 1000
5871: PUSH
5872: EMPTY
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: PPUSH
5886: CALL_OW 69
5890: ST_TO_ADDR
// if b then
5891: LD_VAR 0 2
5895: IFFALSE 5926
// begin ComExitBuilding ( eng ) ;
5897: LD_VAR 0 3
5901: PPUSH
5902: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5906: LD_VAR 0 3
5910: PPUSH
5911: LD_VAR 0 2
5915: PUSH
5916: LD_INT 1
5918: ARRAY
5919: PPUSH
5920: CALL_OW 190
// end else
5924: GO 6068
// begin for i in eng do
5926: LD_ADDR_VAR 0 1
5930: PUSH
5931: LD_VAR 0 3
5935: PUSH
5936: FOR_IN
5937: IFFALSE 6066
// if not HasTask ( i ) then
5939: LD_VAR 0 1
5943: PPUSH
5944: CALL_OW 314
5948: NOT
5949: IFFALSE 6064
// begin if americanBuildList then
5951: LD_EXP 45
5955: IFFALSE 6040
// begin if IsInUnit ( i ) then
5957: LD_VAR 0 1
5961: PPUSH
5962: CALL_OW 310
5966: IFFALSE 5977
// ComExitBuilding ( i ) ;
5968: LD_VAR 0 1
5972: PPUSH
5973: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5977: LD_VAR 0 1
5981: PPUSH
5982: LD_EXP 45
5986: PUSH
5987: LD_INT 1
5989: ARRAY
5990: PUSH
5991: LD_INT 1
5993: ARRAY
5994: PPUSH
5995: LD_EXP 45
5999: PUSH
6000: LD_INT 1
6002: ARRAY
6003: PUSH
6004: LD_INT 2
6006: ARRAY
6007: PPUSH
6008: LD_EXP 45
6012: PUSH
6013: LD_INT 1
6015: ARRAY
6016: PUSH
6017: LD_INT 3
6019: ARRAY
6020: PPUSH
6021: LD_EXP 45
6025: PUSH
6026: LD_INT 1
6028: ARRAY
6029: PUSH
6030: LD_INT 4
6032: ARRAY
6033: PPUSH
6034: CALL_OW 205
// end else
6038: GO 6064
// if not IsInUnit ( i ) then
6040: LD_VAR 0 1
6044: PPUSH
6045: CALL_OW 310
6049: NOT
6050: IFFALSE 6064
// ComEnterUnit ( i , usDepot ) ;
6052: LD_VAR 0 1
6056: PPUSH
6057: LD_INT 11
6059: PPUSH
6060: CALL_OW 120
// end ;
6064: GO 5936
6066: POP
6067: POP
// end ; end ; end ;
6068: PPOPN 5
6070: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
6071: LD_INT 0
6073: PPUSH
6074: PPUSH
6075: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
6076: LD_ADDR_VAR 0 3
6080: PUSH
6081: LD_INT 35
6083: PUSH
6084: LD_INT 45
6086: PUSH
6087: LD_INT 48
6089: PUSH
6090: LD_EXP 56
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: LIST
6099: LIST
6100: ST_TO_ADDR
// for i in tech do
6101: LD_ADDR_VAR 0 4
6105: PUSH
6106: LD_VAR 0 3
6110: PUSH
6111: FOR_IN
6112: IFFALSE 6130
// AddComResearch ( lab , i ) ;
6114: LD_VAR 0 1
6118: PPUSH
6119: LD_VAR 0 4
6123: PPUSH
6124: CALL_OW 184
6128: GO 6111
6130: POP
6131: POP
// end ;
6132: LD_VAR 0 2
6136: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
6137: LD_EXP 12
6141: PUSH
6142: LD_EXP 22
6146: PUSH
6147: LD_EXP 26
6151: LESSEQUAL
6152: AND
6153: IFFALSE 6178
6155: GO 6157
6157: DISABLE
// begin enable ;
6158: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6159: LD_INT 35
6161: PPUSH
6162: LD_INT 2065
6164: PPUSH
6165: CALL_OW 12
6169: PPUSH
6170: CALL_OW 67
// SendConvoy ;
6174: CALL 6276 0 0
// end ;
6178: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6179: LD_EXP 6
6183: PUSH
6184: LD_EXP 17
6188: AND
6189: IFFALSE 6275
6191: GO 6193
6193: DISABLE
// begin if americanHasEscaped then
6194: LD_EXP 8
6198: IFFALSE 6209
// wait ( 3 3$20 ) else
6200: LD_INT 7000
6202: PPUSH
6203: CALL_OW 67
6207: GO 6216
// wait ( 6 6$40 ) ;
6209: LD_INT 14000
6211: PPUSH
6212: CALL_OW 67
// SendAttack ;
6216: CALL 7019 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6220: LD_INT 14000
6222: PUSH
6223: LD_INT 11900
6225: PUSH
6226: LD_INT 9800
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: PUSH
6234: LD_OWVAR 67
6238: ARRAY
6239: PPUSH
6240: CALL_OW 67
// SendAttack ;
6244: CALL 7019 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6248: LD_EXP 18
6252: PUSH
6253: LD_INT 6
6255: PUSH
6256: LD_INT 7
6258: PUSH
6259: LD_INT 8
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: PUSH
6267: LD_OWVAR 67
6271: ARRAY
6272: LESS
6273: IFFALSE 6220
// end ;
6275: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6276: LD_INT 0
6278: PPUSH
6279: PPUSH
6280: PPUSH
6281: PPUSH
6282: PPUSH
6283: PPUSH
6284: PPUSH
6285: PPUSH
// road := rand ( 1 , 2 ) ;
6286: LD_ADDR_VAR 0 4
6290: PUSH
6291: LD_INT 1
6293: PPUSH
6294: LD_INT 2
6296: PPUSH
6297: CALL_OW 12
6301: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6302: LD_ADDR_VAR 0 8
6306: PUSH
6307: LD_INT 3
6309: PUSH
6310: LD_INT 8
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: PUSH
6317: LD_VAR 0 4
6321: ARRAY
6322: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6323: LD_ADDR_VAR 0 5
6327: PUSH
6328: LD_INT 35
6330: PUSH
6331: LD_INT 66
6333: PUSH
6334: LD_INT 1
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 101
6344: PUSH
6345: LD_INT 8
6347: PUSH
6348: LD_INT 4
6350: PUSH
6351: EMPTY
6352: LIST
6353: LIST
6354: LIST
6355: PUSH
6356: EMPTY
6357: LIST
6358: LIST
6359: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6360: LD_ADDR_VAR 0 6
6364: PUSH
6365: LD_INT 34
6367: PUSH
6368: LD_INT 67
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: PUSH
6375: LD_INT 38
6377: PUSH
6378: LD_INT 62
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: PUSH
6385: LD_INT 43
6387: PUSH
6388: LD_INT 54
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: PUSH
6395: LD_INT 57
6397: PUSH
6398: LD_INT 57
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 77
6407: PUSH
6408: LD_INT 71
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: PUSH
6415: LD_INT 86
6417: PUSH
6418: LD_INT 60
6420: PUSH
6421: EMPTY
6422: LIST
6423: LIST
6424: PUSH
6425: LD_INT 89
6427: PUSH
6428: LD_INT 35
6430: PUSH
6431: EMPTY
6432: LIST
6433: LIST
6434: PUSH
6435: LD_INT 93
6437: PUSH
6438: LD_INT 17
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PUSH
6445: LD_INT 97
6447: PUSH
6448: LD_INT 10
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: PUSH
6455: LD_INT 103
6457: PUSH
6458: LD_INT 9
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: LIST
6472: LIST
6473: LIST
6474: LIST
6475: LIST
6476: ST_TO_ADDR
// if road = 2 then
6477: LD_VAR 0 4
6481: PUSH
6482: LD_INT 2
6484: EQUAL
6485: IFFALSE 6502
// points := ReverseArray ( points ) ;
6487: LD_ADDR_VAR 0 6
6491: PUSH
6492: LD_VAR 0 6
6496: PPUSH
6497: CALL 1056 0 1
6501: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6502: LD_INT 4
6504: PPUSH
6505: LD_INT 1
6507: PPUSH
6508: LD_INT 2
6510: PPUSH
6511: LD_INT 1
6513: PPUSH
6514: LD_INT 1
6516: PPUSH
6517: LD_INT 12
6519: PPUSH
6520: LD_INT 80
6522: PPUSH
6523: CALL 368 0 7
// veh := CreateVehicle ;
6527: LD_ADDR_VAR 0 3
6531: PUSH
6532: CALL_OW 45
6536: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6537: LD_VAR 0 3
6541: PPUSH
6542: LD_VAR 0 5
6546: PUSH
6547: LD_VAR 0 4
6551: ARRAY
6552: PUSH
6553: LD_INT 3
6555: ARRAY
6556: PPUSH
6557: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6561: LD_VAR 0 3
6565: PPUSH
6566: LD_VAR 0 5
6570: PUSH
6571: LD_VAR 0 4
6575: ARRAY
6576: PUSH
6577: LD_INT 1
6579: ARRAY
6580: PPUSH
6581: LD_VAR 0 5
6585: PUSH
6586: LD_VAR 0 4
6590: ARRAY
6591: PUSH
6592: LD_INT 2
6594: ARRAY
6595: PPUSH
6596: LD_INT 0
6598: PPUSH
6599: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6603: LD_INT 0
6605: PPUSH
6606: LD_INT 1
6608: PPUSH
6609: LD_OWVAR 67
6613: PPUSH
6614: CALL_OW 380
// un := CreateHuman ;
6618: LD_ADDR_VAR 0 2
6622: PUSH
6623: CALL_OW 44
6627: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6628: LD_VAR 0 2
6632: PPUSH
6633: LD_VAR 0 3
6637: PPUSH
6638: CALL_OW 52
// if ( Prob ( [ 60 , 56 , 52 ] [ Difficulty ] ) + tick mod 30 ) or convoyCounter < 4 then
6642: LD_INT 60
6644: PUSH
6645: LD_INT 56
6647: PUSH
6648: LD_INT 52
6650: PUSH
6651: EMPTY
6652: LIST
6653: LIST
6654: LIST
6655: PUSH
6656: LD_OWVAR 67
6660: ARRAY
6661: PPUSH
6662: CALL_OW 13
6666: PUSH
6667: LD_OWVAR 1
6671: PUSH
6672: LD_INT 30
6674: MOD
6675: PLUS
6676: PUSH
6677: LD_EXP 22
6681: PUSH
6682: LD_INT 4
6684: LESS
6685: OR
6686: IFFALSE 6703
// SetCargo ( veh , mat_cans , 100 ) ;
6688: LD_VAR 0 3
6692: PPUSH
6693: LD_INT 1
6695: PPUSH
6696: LD_INT 100
6698: PPUSH
6699: CALL_OW 290
// for i := 2 to points do
6703: LD_ADDR_VAR 0 7
6707: PUSH
6708: DOUBLE
6709: LD_INT 2
6711: DEC
6712: ST_TO_ADDR
6713: LD_VAR 0 6
6717: PUSH
6718: FOR_TO
6719: IFFALSE 6762
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6721: LD_VAR 0 3
6725: PPUSH
6726: LD_VAR 0 6
6730: PUSH
6731: LD_VAR 0 7
6735: ARRAY
6736: PUSH
6737: LD_INT 1
6739: ARRAY
6740: PPUSH
6741: LD_VAR 0 6
6745: PUSH
6746: LD_VAR 0 7
6750: ARRAY
6751: PUSH
6752: LD_INT 2
6754: ARRAY
6755: PPUSH
6756: CALL_OW 171
6760: GO 6718
6762: POP
6763: POP
// convoyCounter := convoyCounter + 1 ;
6764: LD_ADDR_EXP 22
6768: PUSH
6769: LD_EXP 22
6773: PUSH
6774: LD_INT 1
6776: PLUS
6777: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6778: LD_INT 35
6780: PPUSH
6781: CALL_OW 67
// if not HasTask ( veh ) and IsOk ( veh ) then
6785: LD_VAR 0 3
6789: PPUSH
6790: CALL_OW 314
6794: NOT
6795: PUSH
6796: LD_VAR 0 3
6800: PPUSH
6801: CALL_OW 302
6805: AND
6806: IFFALSE 6847
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6808: LD_VAR 0 3
6812: PPUSH
6813: LD_VAR 0 6
6817: PUSH
6818: LD_VAR 0 6
6822: ARRAY
6823: PUSH
6824: LD_INT 1
6826: ARRAY
6827: PPUSH
6828: LD_VAR 0 6
6832: PUSH
6833: LD_VAR 0 6
6837: ARRAY
6838: PUSH
6839: LD_INT 2
6841: ARRAY
6842: PPUSH
6843: CALL_OW 111
// if not IsInUnit ( un ) then
6847: LD_VAR 0 2
6851: PPUSH
6852: CALL_OW 310
6856: NOT
6857: IFFALSE 6898
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6859: LD_VAR 0 2
6863: PPUSH
6864: LD_VAR 0 6
6868: PUSH
6869: LD_VAR 0 6
6873: ARRAY
6874: PUSH
6875: LD_INT 1
6877: ARRAY
6878: PPUSH
6879: LD_VAR 0 6
6883: PUSH
6884: LD_VAR 0 6
6888: ARRAY
6889: PUSH
6890: LD_INT 2
6892: ARRAY
6893: PPUSH
6894: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6898: LD_VAR 0 3
6902: PPUSH
6903: LD_VAR 0 8
6907: PPUSH
6908: CALL_OW 308
6912: PUSH
6913: LD_VAR 0 2
6917: PPUSH
6918: LD_VAR 0 8
6922: PPUSH
6923: CALL_OW 308
6927: OR
6928: IFFALSE 6778
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6930: LD_VAR 0 2
6934: PPUSH
6935: CALL_OW 302
6939: PUSH
6940: LD_VAR 0 3
6944: PPUSH
6945: CALL_OW 302
6949: NOT
6950: AND
6951: PUSH
6952: LD_VAR 0 2
6956: PPUSH
6957: LD_VAR 0 8
6961: PPUSH
6962: CALL_OW 308
6966: AND
6967: IFFALSE 6978
// RemoveUnit ( un ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6978: LD_VAR 0 3
6982: PPUSH
6983: LD_VAR 0 8
6987: PPUSH
6988: CALL_OW 308
6992: PUSH
6993: LD_VAR 0 3
6997: PPUSH
6998: CALL_OW 302
7002: AND
7003: IFFALSE 7014
// RemoveUnit ( veh ) ;
7005: LD_VAR 0 3
7009: PPUSH
7010: CALL_OW 64
// end ;
7014: LD_VAR 0 1
7018: RET
// export function SendAttack ; var un , veh , i ; begin
7019: LD_INT 0
7021: PPUSH
7022: PPUSH
7023: PPUSH
7024: PPUSH
// IncomingAttack ;
7025: CALL 15524 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
7029: LD_INT 2100
7031: PPUSH
7032: LD_INT 3500
7034: PPUSH
7035: CALL_OW 12
7039: PPUSH
7040: CALL_OW 67
// for i := 1 to [ 3 , 4 , 4 ] [ Difficulty ] + attackWave div 3 do
7044: LD_ADDR_VAR 0 4
7048: PUSH
7049: DOUBLE
7050: LD_INT 1
7052: DEC
7053: ST_TO_ADDR
7054: LD_INT 3
7056: PUSH
7057: LD_INT 4
7059: PUSH
7060: LD_INT 4
7062: PUSH
7063: EMPTY
7064: LIST
7065: LIST
7066: LIST
7067: PUSH
7068: LD_OWVAR 67
7072: ARRAY
7073: PUSH
7074: LD_EXP 18
7078: PUSH
7079: LD_INT 3
7081: DIV
7082: PLUS
7083: PUSH
7084: FOR_TO
7085: IFFALSE 7197
// begin uc_side := 1 ;
7087: LD_ADDR_OWVAR 20
7091: PUSH
7092: LD_INT 1
7094: ST_TO_ADDR
// uc_nation := 1 ;
7095: LD_ADDR_OWVAR 21
7099: PUSH
7100: LD_INT 1
7102: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
7103: LD_INT 0
7105: PPUSH
7106: LD_INT 1
7108: PPUSH
7109: LD_INT 2
7111: PUSH
7112: LD_INT 3
7114: PUSH
7115: LD_INT 4
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: LIST
7122: PUSH
7123: LD_OWVAR 67
7127: ARRAY
7128: PPUSH
7129: CALL_OW 380
// un := CreateHuman ;
7133: LD_ADDR_VAR 0 2
7137: PUSH
7138: CALL_OW 44
7142: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7143: LD_VAR 0 2
7147: PPUSH
7148: LD_INT 37
7150: PPUSH
7151: LD_INT 70
7153: PPUSH
7154: LD_INT 3
7156: PPUSH
7157: LD_INT 0
7159: PPUSH
7160: CALL_OW 50
// usAttackers := usAttackers union un ;
7164: LD_ADDR_EXP 46
7168: PUSH
7169: LD_EXP 46
7173: PUSH
7174: LD_VAR 0 2
7178: UNION
7179: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7180: LD_VAR 0 2
7184: PPUSH
7185: LD_INT 40
7187: PPUSH
7188: LD_INT 65
7190: PPUSH
7191: CALL_OW 111
// end ;
7195: GO 7084
7197: POP
7198: POP
// uc_side := 1 ;
7199: LD_ADDR_OWVAR 20
7203: PUSH
7204: LD_INT 1
7206: ST_TO_ADDR
// uc_nation := 1 ;
7207: LD_ADDR_OWVAR 21
7211: PUSH
7212: LD_INT 1
7214: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7215: LD_INT 0
7217: PPUSH
7218: LD_INT 4
7220: PPUSH
7221: LD_INT 2
7223: PPUSH
7224: CALL_OW 380
// un := CreateHuman ;
7228: LD_ADDR_VAR 0 2
7232: PUSH
7233: CALL_OW 44
7237: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7238: LD_VAR 0 2
7242: PPUSH
7243: LD_INT 37
7245: PPUSH
7246: LD_INT 70
7248: PPUSH
7249: LD_INT 3
7251: PPUSH
7252: LD_INT 0
7254: PPUSH
7255: CALL_OW 50
// usAttackers := usAttackers union un ;
7259: LD_ADDR_EXP 46
7263: PUSH
7264: LD_EXP 46
7268: PUSH
7269: LD_VAR 0 2
7273: UNION
7274: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7275: LD_VAR 0 2
7279: PPUSH
7280: LD_INT 40
7282: PPUSH
7283: LD_INT 65
7285: PPUSH
7286: CALL_OW 111
// for i := 1 to Difficulty + attackWave div 4 do
7290: LD_ADDR_VAR 0 4
7294: PUSH
7295: DOUBLE
7296: LD_INT 1
7298: DEC
7299: ST_TO_ADDR
7300: LD_OWVAR 67
7304: PUSH
7305: LD_EXP 18
7309: PUSH
7310: LD_INT 4
7312: DIV
7313: PLUS
7314: PUSH
7315: FOR_TO
7316: IFFALSE 7489
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7318: LD_ADDR_VAR 0 3
7322: PUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 1
7328: PPUSH
7329: LD_INT 2
7331: PPUSH
7332: LD_INT 1
7334: PPUSH
7335: LD_INT 1
7337: PPUSH
7338: LD_INT 4
7340: PUSH
7341: LD_INT 3
7343: PUSH
7344: LD_INT 2
7346: PUSH
7347: EMPTY
7348: LIST
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 1
7354: PPUSH
7355: LD_INT 3
7357: PPUSH
7358: CALL_OW 12
7362: ARRAY
7363: PPUSH
7364: LD_INT 90
7366: PPUSH
7367: CALL 368 0 7
7371: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7372: LD_VAR 0 3
7376: PPUSH
7377: LD_INT 35
7379: PPUSH
7380: LD_INT 65
7382: PPUSH
7383: LD_INT 0
7385: PPUSH
7386: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7390: LD_INT 0
7392: PPUSH
7393: LD_INT 3
7395: PPUSH
7396: LD_OWVAR 67
7400: PUSH
7401: LD_INT 1
7403: PLUS
7404: PPUSH
7405: CALL_OW 380
// un := CreateHuman ;
7409: LD_ADDR_VAR 0 2
7413: PUSH
7414: CALL_OW 44
7418: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7419: LD_VAR 0 2
7423: PPUSH
7424: LD_VAR 0 3
7428: PPUSH
7429: CALL_OW 52
// usAttackers := usAttackers union un ;
7433: LD_ADDR_EXP 46
7437: PUSH
7438: LD_EXP 46
7442: PUSH
7443: LD_VAR 0 2
7447: UNION
7448: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7449: LD_VAR 0 3
7453: PPUSH
7454: LD_INT 39
7456: PPUSH
7457: LD_INT 60
7459: PPUSH
7460: CALL_OW 111
// wait ( 0 0$3 ) ;
7464: LD_INT 105
7466: PPUSH
7467: CALL_OW 67
// usAttackers := usAttackers union veh ;
7471: LD_ADDR_EXP 46
7475: PUSH
7476: LD_EXP 46
7480: PUSH
7481: LD_VAR 0 3
7485: UNION
7486: ST_TO_ADDR
// end ;
7487: GO 7315
7489: POP
7490: POP
// attackWave := attackWave + 1 ;
7491: LD_ADDR_EXP 18
7495: PUSH
7496: LD_EXP 18
7500: PUSH
7501: LD_INT 1
7503: PLUS
7504: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7505: LD_EXP 23
7509: PPUSH
7510: CALL_OW 427
// end ;
7514: LD_VAR 0 1
7518: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7519: LD_INT 0
7521: PPUSH
7522: PPUSH
7523: PPUSH
7524: PPUSH
7525: PPUSH
7526: PPUSH
7527: PPUSH
7528: PPUSH
7529: PPUSH
7530: PPUSH
7531: PPUSH
// if retreatAllowed then
7532: LD_EXP 11
7536: IFFALSE 7548
// strategy := 2 else
7538: LD_ADDR_VAR 0 5
7542: PUSH
7543: LD_INT 2
7545: ST_TO_ADDR
7546: GO 7564
// strategy := rand ( 0 , 2 ) ;
7548: LD_ADDR_VAR 0 5
7552: PUSH
7553: LD_INT 0
7555: PPUSH
7556: LD_INT 2
7558: PPUSH
7559: CALL_OW 12
7563: ST_TO_ADDR
// attackFormula := [ ] ;
7564: LD_ADDR_VAR 0 6
7568: PUSH
7569: EMPTY
7570: ST_TO_ADDR
// case strategy of 0 :
7571: LD_VAR 0 5
7575: PUSH
7576: LD_INT 0
7578: DOUBLE
7579: EQUAL
7580: IFTRUE 7584
7582: GO 7914
7584: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7585: LD_INT 11
7587: PPUSH
7588: LD_INT 22
7590: PUSH
7591: LD_INT 2
7593: PUSH
7594: EMPTY
7595: LIST
7596: LIST
7597: PUSH
7598: LD_INT 30
7600: PUSH
7601: LD_INT 4
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PPUSH
7612: CALL_OW 70
7616: NOT
7617: IFFALSE 7689
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7619: LD_ADDR_VAR 0 6
7623: PUSH
7624: LD_INT 41
7626: PUSH
7627: LD_INT 34
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: EMPTY
7635: LIST
7636: PUSH
7637: LD_INT 53
7639: PUSH
7640: LD_INT 62
7642: PUSH
7643: EMPTY
7644: LIST
7645: LIST
7646: PUSH
7647: LD_INT 37
7649: PUSH
7650: LD_INT 63
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: PUSH
7657: LD_INT 44
7659: PUSH
7660: LD_INT 45
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PUSH
7667: LD_INT 37
7669: PUSH
7670: LD_INT 28
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: LIST
7685: LIST
7686: ST_TO_ADDR
7687: GO 7912
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7689: LD_INT 12
7691: PPUSH
7692: LD_INT 22
7694: PUSH
7695: LD_INT 2
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: PUSH
7702: LD_INT 2
7704: PUSH
7705: LD_INT 30
7707: PUSH
7708: LD_INT 4
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: LD_INT 30
7717: PUSH
7718: LD_INT 31
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: PUSH
7725: LD_INT 30
7727: PUSH
7728: LD_INT 32
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: LIST
7739: LIST
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PPUSH
7745: CALL_OW 70
7749: NOT
7750: IFFALSE 7833
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7752: LD_ADDR_VAR 0 6
7756: PUSH
7757: LD_INT 27
7759: PUSH
7760: LD_INT 42
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PUSH
7767: LD_INT 27
7769: PUSH
7770: LD_INT 32
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: PUSH
7781: LD_INT 53
7783: PUSH
7784: LD_INT 62
7786: PUSH
7787: EMPTY
7788: LIST
7789: LIST
7790: PUSH
7791: LD_INT 37
7793: PUSH
7794: LD_INT 63
7796: PUSH
7797: EMPTY
7798: LIST
7799: LIST
7800: PUSH
7801: LD_INT 44
7803: PUSH
7804: LD_INT 45
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PUSH
7811: LD_INT 37
7813: PUSH
7814: LD_INT 28
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: LIST
7829: LIST
7830: ST_TO_ADDR
7831: GO 7912
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7833: LD_ADDR_VAR 0 6
7837: PUSH
7838: LD_INT 71
7840: PUSH
7841: LD_INT 67
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: PUSH
7848: LD_INT 54
7850: PUSH
7851: LD_INT 35
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PUSH
7862: LD_INT 63
7864: PUSH
7865: LD_INT 40
7867: PUSH
7868: EMPTY
7869: LIST
7870: LIST
7871: PUSH
7872: LD_INT 37
7874: PUSH
7875: LD_INT 63
7877: PUSH
7878: EMPTY
7879: LIST
7880: LIST
7881: PUSH
7882: LD_INT 44
7884: PUSH
7885: LD_INT 45
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 37
7894: PUSH
7895: LD_INT 28
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: LIST
7910: LIST
7911: ST_TO_ADDR
// end ; 1 :
7912: GO 8117
7914: LD_INT 1
7916: DOUBLE
7917: EQUAL
7918: IFTRUE 7922
7920: GO 8026
7922: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7923: LD_ADDR_VAR 0 6
7927: PUSH
7928: LD_INT 71
7930: PUSH
7931: LD_INT 67
7933: PUSH
7934: EMPTY
7935: LIST
7936: LIST
7937: PUSH
7938: LD_INT 82
7940: PUSH
7941: LD_INT 23
7943: PUSH
7944: EMPTY
7945: LIST
7946: LIST
7947: PUSH
7948: LD_INT 53
7950: PUSH
7951: LD_INT 7
7953: PUSH
7954: EMPTY
7955: LIST
7956: LIST
7957: PUSH
7958: LD_INT 43
7960: PUSH
7961: LD_INT 10
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: PUSH
7968: EMPTY
7969: LIST
7970: LIST
7971: LIST
7972: LIST
7973: PUSH
7974: LD_INT 53
7976: PUSH
7977: LD_INT 62
7979: PUSH
7980: EMPTY
7981: LIST
7982: LIST
7983: PUSH
7984: LD_INT 37
7986: PUSH
7987: LD_INT 63
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: PUSH
7994: LD_INT 44
7996: PUSH
7997: LD_INT 45
7999: PUSH
8000: EMPTY
8001: LIST
8002: LIST
8003: PUSH
8004: LD_INT 37
8006: PUSH
8007: LD_INT 28
8009: PUSH
8010: EMPTY
8011: LIST
8012: LIST
8013: PUSH
8014: EMPTY
8015: LIST
8016: LIST
8017: PUSH
8018: EMPTY
8019: LIST
8020: LIST
8021: LIST
8022: LIST
8023: ST_TO_ADDR
8024: GO 8117
8026: LD_INT 2
8028: DOUBLE
8029: EQUAL
8030: IFTRUE 8034
8032: GO 8116
8034: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
8035: LD_ADDR_VAR 0 6
8039: PUSH
8040: LD_INT 90
8042: PUSH
8043: LD_INT 59
8045: PUSH
8046: EMPTY
8047: LIST
8048: LIST
8049: PUSH
8050: LD_INT 108
8052: PUSH
8053: LD_INT 64
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PUSH
8060: EMPTY
8061: LIST
8062: LIST
8063: PUSH
8064: LD_INT 82
8066: PUSH
8067: LD_INT 75
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 73
8076: PUSH
8077: LD_INT 67
8079: PUSH
8080: EMPTY
8081: LIST
8082: LIST
8083: PUSH
8084: LD_INT 101
8086: PUSH
8087: LD_INT 65
8089: PUSH
8090: EMPTY
8091: LIST
8092: LIST
8093: PUSH
8094: LD_INT 108
8096: PUSH
8097: LD_INT 62
8099: PUSH
8100: EMPTY
8101: LIST
8102: LIST
8103: PUSH
8104: EMPTY
8105: LIST
8106: LIST
8107: PUSH
8108: EMPTY
8109: LIST
8110: LIST
8111: LIST
8112: LIST
8113: ST_TO_ADDR
8114: GO 8117
8116: POP
// if not attackFormula then
8117: LD_VAR 0 6
8121: NOT
8122: IFFALSE 8126
// exit ;
8124: GO 9552
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8126: LD_ADDR_VAR 0 7
8130: PUSH
8131: LD_EXP 46
8135: PPUSH
8136: LD_INT 25
8138: PUSH
8139: LD_INT 1
8141: PUSH
8142: EMPTY
8143: LIST
8144: LIST
8145: PPUSH
8146: CALL_OW 72
8150: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8151: LD_ADDR_VAR 0 8
8155: PUSH
8156: LD_EXP 46
8160: PPUSH
8161: LD_INT 25
8163: PUSH
8164: LD_INT 4
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PPUSH
8171: CALL_OW 72
8175: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8176: LD_ADDR_VAR 0 9
8180: PUSH
8181: LD_EXP 46
8185: PPUSH
8186: LD_INT 25
8188: PUSH
8189: LD_INT 3
8191: PUSH
8192: EMPTY
8193: LIST
8194: LIST
8195: PPUSH
8196: CALL_OW 72
8200: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8201: LD_ADDR_VAR 0 10
8205: PUSH
8206: LD_EXP 46
8210: PPUSH
8211: LD_INT 21
8213: PUSH
8214: LD_INT 2
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PPUSH
8221: CALL_OW 72
8225: ST_TO_ADDR
// if sci then
8226: LD_VAR 0 8
8230: IFFALSE 8267
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8232: LD_VAR 0 8
8236: PPUSH
8237: LD_VAR 0 6
8241: PUSH
8242: LD_INT 2
8244: ARRAY
8245: PUSH
8246: LD_INT 1
8248: ARRAY
8249: PPUSH
8250: LD_VAR 0 6
8254: PUSH
8255: LD_INT 2
8257: ARRAY
8258: PUSH
8259: LD_INT 2
8261: ARRAY
8262: PPUSH
8263: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8267: LD_INT 35
8269: PPUSH
8270: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8274: LD_ADDR_VAR 0 7
8278: PUSH
8279: LD_EXP 46
8283: PPUSH
8284: LD_INT 25
8286: PUSH
8287: LD_INT 1
8289: PUSH
8290: EMPTY
8291: LIST
8292: LIST
8293: PPUSH
8294: CALL_OW 72
8298: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8299: LD_ADDR_VAR 0 8
8303: PUSH
8304: LD_EXP 46
8308: PPUSH
8309: LD_INT 25
8311: PUSH
8312: LD_INT 4
8314: PUSH
8315: EMPTY
8316: LIST
8317: LIST
8318: PPUSH
8319: CALL_OW 72
8323: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8324: LD_ADDR_VAR 0 9
8328: PUSH
8329: LD_EXP 46
8333: PPUSH
8334: LD_INT 25
8336: PUSH
8337: LD_INT 3
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PPUSH
8344: CALL_OW 72
8348: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8349: LD_ADDR_VAR 0 10
8353: PUSH
8354: LD_EXP 46
8358: PPUSH
8359: LD_INT 21
8361: PUSH
8362: LD_INT 2
8364: PUSH
8365: EMPTY
8366: LIST
8367: LIST
8368: PPUSH
8369: CALL_OW 72
8373: ST_TO_ADDR
// if sol then
8374: LD_VAR 0 7
8378: IFFALSE 8773
// begin for i in sol do
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: LD_VAR 0 7
8389: PUSH
8390: FOR_IN
8391: IFFALSE 8771
// begin tag := GetTag ( i ) ;
8393: LD_ADDR_VAR 0 4
8397: PUSH
8398: LD_VAR 0 2
8402: PPUSH
8403: CALL_OW 110
8407: ST_TO_ADDR
// if not tag then
8408: LD_VAR 0 4
8412: NOT
8413: IFFALSE 8531
// begin if GetLives ( i ) = 1000 then
8415: LD_VAR 0 2
8419: PPUSH
8420: CALL_OW 256
8424: PUSH
8425: LD_INT 1000
8427: EQUAL
8428: IFFALSE 8444
// SetTag ( i , 1 ) else
8430: LD_VAR 0 2
8434: PPUSH
8435: LD_INT 1
8437: PPUSH
8438: CALL_OW 109
8442: GO 8529
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8444: LD_VAR 0 2
8448: PPUSH
8449: LD_VAR 0 6
8453: PUSH
8454: LD_INT 2
8456: ARRAY
8457: PUSH
8458: LD_INT 1
8460: ARRAY
8461: PPUSH
8462: LD_VAR 0 6
8466: PUSH
8467: LD_INT 2
8469: ARRAY
8470: PUSH
8471: LD_INT 2
8473: ARRAY
8474: PPUSH
8475: CALL_OW 297
8479: PUSH
8480: LD_INT 6
8482: GREATER
8483: IFFALSE 8529
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8485: LD_VAR 0 2
8489: PPUSH
8490: LD_VAR 0 6
8494: PUSH
8495: LD_INT 2
8497: ARRAY
8498: PUSH
8499: LD_INT 1
8501: ARRAY
8502: PPUSH
8503: LD_VAR 0 6
8507: PUSH
8508: LD_INT 2
8510: ARRAY
8511: PUSH
8512: LD_INT 2
8514: ARRAY
8515: PPUSH
8516: CALL_OW 111
// AddComHold ( i ) ;
8520: LD_VAR 0 2
8524: PPUSH
8525: CALL_OW 200
// end ; end else
8529: GO 8769
// begin if GetLives ( i ) < 720 then
8531: LD_VAR 0 2
8535: PPUSH
8536: CALL_OW 256
8540: PUSH
8541: LD_INT 720
8543: LESS
8544: IFFALSE 8560
// SetTag ( i , 0 ) else
8546: LD_VAR 0 2
8550: PPUSH
8551: LD_INT 0
8553: PPUSH
8554: CALL_OW 109
8558: GO 8769
// if tag <= attackFormula [ 1 ] then
8560: LD_VAR 0 4
8564: PUSH
8565: LD_VAR 0 6
8569: PUSH
8570: LD_INT 1
8572: ARRAY
8573: LESSEQUAL
8574: IFFALSE 8735
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8576: LD_VAR 0 2
8580: PPUSH
8581: LD_VAR 0 6
8585: PUSH
8586: LD_INT 1
8588: ARRAY
8589: PUSH
8590: LD_VAR 0 4
8594: ARRAY
8595: PUSH
8596: LD_INT 1
8598: ARRAY
8599: PPUSH
8600: LD_VAR 0 6
8604: PUSH
8605: LD_INT 1
8607: ARRAY
8608: PUSH
8609: LD_VAR 0 4
8613: ARRAY
8614: PUSH
8615: LD_INT 2
8617: ARRAY
8618: PPUSH
8619: CALL_OW 297
8623: PUSH
8624: LD_INT 6
8626: GREATER
8627: IFFALSE 8678
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8629: LD_VAR 0 2
8633: PPUSH
8634: LD_VAR 0 6
8638: PUSH
8639: LD_INT 1
8641: ARRAY
8642: PUSH
8643: LD_VAR 0 4
8647: ARRAY
8648: PUSH
8649: LD_INT 1
8651: ARRAY
8652: PPUSH
8653: LD_VAR 0 6
8657: PUSH
8658: LD_INT 1
8660: ARRAY
8661: PUSH
8662: LD_VAR 0 4
8666: ARRAY
8667: PUSH
8668: LD_INT 2
8670: ARRAY
8671: PPUSH
8672: CALL_OW 114
8676: GO 8733
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8678: LD_INT 81
8680: PUSH
8681: LD_INT 1
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: PUSH
8688: LD_INT 91
8690: PUSH
8691: LD_VAR 0 2
8695: PUSH
8696: LD_INT 10
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: LIST
8703: PUSH
8704: EMPTY
8705: LIST
8706: LIST
8707: PPUSH
8708: CALL_OW 69
8712: NOT
8713: IFFALSE 8733
// SetTag ( i , tag + 1 ) ;
8715: LD_VAR 0 2
8719: PPUSH
8720: LD_VAR 0 4
8724: PUSH
8725: LD_INT 1
8727: PLUS
8728: PPUSH
8729: CALL_OW 109
// end else
8733: GO 8769
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8735: LD_VAR 0 2
8739: PPUSH
8740: LD_INT 81
8742: PUSH
8743: LD_INT 1
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: PPUSH
8750: CALL_OW 69
8754: PPUSH
8755: LD_VAR 0 2
8759: PPUSH
8760: CALL_OW 74
8764: PPUSH
8765: CALL_OW 115
// end ; end ;
8769: GO 8390
8771: POP
8772: POP
// end ; if sci then
8773: LD_VAR 0 8
8777: IFFALSE 8936
// begin if not sol and not mech then
8779: LD_VAR 0 7
8783: NOT
8784: PUSH
8785: LD_VAR 0 9
8789: NOT
8790: AND
8791: IFFALSE 8843
// begin for i in sci do
8793: LD_ADDR_VAR 0 2
8797: PUSH
8798: LD_VAR 0 8
8802: PUSH
8803: FOR_IN
8804: IFFALSE 8839
// begin usForces := usForces union i ;
8806: LD_ADDR_EXP 43
8810: PUSH
8811: LD_EXP 43
8815: PUSH
8816: LD_VAR 0 2
8820: UNION
8821: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8822: LD_VAR 0 2
8826: PPUSH
8827: LD_INT 34
8829: PPUSH
8830: LD_INT 68
8832: PPUSH
8833: CALL_OW 111
// end ;
8837: GO 8803
8839: POP
8840: POP
// end else
8841: GO 8936
// for i in sci do
8843: LD_ADDR_VAR 0 2
8847: PUSH
8848: LD_VAR 0 8
8852: PUSH
8853: FOR_IN
8854: IFFALSE 8934
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8856: LD_VAR 0 2
8860: PPUSH
8861: LD_VAR 0 6
8865: PUSH
8866: LD_INT 2
8868: ARRAY
8869: PUSH
8870: LD_INT 1
8872: ARRAY
8873: PPUSH
8874: LD_VAR 0 6
8878: PUSH
8879: LD_INT 2
8881: ARRAY
8882: PUSH
8883: LD_INT 2
8885: ARRAY
8886: PPUSH
8887: CALL_OW 297
8891: PUSH
8892: LD_INT 8
8894: GREATER
8895: IFFALSE 8932
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8897: LD_VAR 0 2
8901: PPUSH
8902: LD_VAR 0 6
8906: PUSH
8907: LD_INT 2
8909: ARRAY
8910: PUSH
8911: LD_INT 1
8913: ARRAY
8914: PPUSH
8915: LD_VAR 0 6
8919: PUSH
8920: LD_INT 2
8922: ARRAY
8923: PUSH
8924: LD_INT 2
8926: ARRAY
8927: PPUSH
8928: CALL_OW 111
8932: GO 8853
8934: POP
8935: POP
// end ; if mech then
8936: LD_VAR 0 9
8940: IFFALSE 9545
// begin for i in mech do
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_VAR 0 9
8951: PUSH
8952: FOR_IN
8953: IFFALSE 9543
// begin tag := GetTag ( i ) ;
8955: LD_ADDR_VAR 0 4
8959: PUSH
8960: LD_VAR 0 2
8964: PPUSH
8965: CALL_OW 110
8969: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8970: LD_ADDR_VAR 0 11
8974: PUSH
8975: LD_VAR 0 2
8979: PPUSH
8980: CALL_OW 310
8984: ST_TO_ADDR
// if not tag then
8985: LD_VAR 0 4
8989: NOT
8990: IFFALSE 9303
// begin if veh then
8992: LD_VAR 0 11
8996: IFFALSE 9145
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
8998: LD_VAR 0 11
9002: PPUSH
9003: CALL_OW 256
9007: PUSH
9008: LD_INT 1000
9010: EQUAL
9011: PUSH
9012: LD_VAR 0 11
9016: PPUSH
9017: CALL_OW 261
9021: PUSH
9022: LD_INT 60
9024: GREATER
9025: AND
9026: IFFALSE 9042
// SetTag ( i , 1 ) else
9028: LD_VAR 0 2
9032: PPUSH
9033: LD_INT 1
9035: PPUSH
9036: CALL_OW 109
9040: GO 9143
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
9042: LD_VAR 0 2
9046: PPUSH
9047: LD_VAR 0 6
9051: PUSH
9052: LD_INT 3
9054: ARRAY
9055: PUSH
9056: LD_INT 1
9058: ARRAY
9059: PPUSH
9060: LD_VAR 0 6
9064: PUSH
9065: LD_INT 3
9067: ARRAY
9068: PUSH
9069: LD_INT 2
9071: ARRAY
9072: PPUSH
9073: CALL_OW 297
9077: PUSH
9078: LD_INT 7
9080: GREATER
9081: IFFALSE 9120
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
9083: LD_VAR 0 2
9087: PPUSH
9088: LD_VAR 0 6
9092: PUSH
9093: LD_INT 3
9095: ARRAY
9096: PUSH
9097: LD_INT 1
9099: ARRAY
9100: PPUSH
9101: LD_VAR 0 6
9105: PUSH
9106: LD_INT 3
9108: ARRAY
9109: PUSH
9110: LD_INT 2
9112: ARRAY
9113: PPUSH
9114: CALL_OW 111
9118: GO 9143
// begin ComExitVehicle ( i ) ;
9120: LD_VAR 0 2
9124: PPUSH
9125: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
9129: LD_VAR 0 2
9133: PPUSH
9134: LD_VAR 0 11
9138: PPUSH
9139: CALL_OW 189
// end ; end else
9143: GO 9301
// if GetLives ( i ) < 700 then
9145: LD_VAR 0 2
9149: PPUSH
9150: CALL_OW 256
9154: PUSH
9155: LD_INT 700
9157: LESS
9158: IFFALSE 9209
// begin usAttackers := usAttackers diff i ;
9160: LD_ADDR_EXP 46
9164: PUSH
9165: LD_EXP 46
9169: PUSH
9170: LD_VAR 0 2
9174: DIFF
9175: ST_TO_ADDR
// usForces := usForces union i ;
9176: LD_ADDR_EXP 43
9180: PUSH
9181: LD_EXP 43
9185: PUSH
9186: LD_VAR 0 2
9190: UNION
9191: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9192: LD_VAR 0 2
9196: PPUSH
9197: LD_INT 34
9199: PPUSH
9200: LD_INT 68
9202: PPUSH
9203: CALL_OW 111
// end else
9207: GO 9301
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9209: LD_VAR 0 10
9213: PPUSH
9214: LD_INT 58
9216: PUSH
9217: EMPTY
9218: LIST
9219: PUSH
9220: LD_INT 24
9222: PUSH
9223: LD_INT 1000
9225: PUSH
9226: EMPTY
9227: LIST
9228: LIST
9229: PUSH
9230: EMPTY
9231: LIST
9232: LIST
9233: PPUSH
9234: CALL_OW 72
9238: PUSH
9239: LD_VAR 0 2
9243: PPUSH
9244: CALL_OW 314
9248: NOT
9249: AND
9250: IFFALSE 9301
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9252: LD_VAR 0 2
9256: PPUSH
9257: LD_VAR 0 10
9261: PPUSH
9262: LD_INT 58
9264: PUSH
9265: EMPTY
9266: LIST
9267: PUSH
9268: LD_INT 24
9270: PUSH
9271: LD_INT 1000
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PUSH
9278: EMPTY
9279: LIST
9280: LIST
9281: PPUSH
9282: CALL_OW 72
9286: PPUSH
9287: LD_VAR 0 2
9291: PPUSH
9292: CALL_OW 74
9296: PPUSH
9297: CALL_OW 120
// end else
9301: GO 9541
// begin if GetLives ( veh ) < 720 then
9303: LD_VAR 0 11
9307: PPUSH
9308: CALL_OW 256
9312: PUSH
9313: LD_INT 720
9315: LESS
9316: IFFALSE 9332
// SetTag ( i , 0 ) else
9318: LD_VAR 0 2
9322: PPUSH
9323: LD_INT 0
9325: PPUSH
9326: CALL_OW 109
9330: GO 9541
// if tag <= attackFormula [ 4 ] then
9332: LD_VAR 0 4
9336: PUSH
9337: LD_VAR 0 6
9341: PUSH
9342: LD_INT 4
9344: ARRAY
9345: LESSEQUAL
9346: IFFALSE 9507
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9348: LD_VAR 0 2
9352: PPUSH
9353: LD_VAR 0 6
9357: PUSH
9358: LD_INT 4
9360: ARRAY
9361: PUSH
9362: LD_VAR 0 4
9366: ARRAY
9367: PUSH
9368: LD_INT 1
9370: ARRAY
9371: PPUSH
9372: LD_VAR 0 6
9376: PUSH
9377: LD_INT 4
9379: ARRAY
9380: PUSH
9381: LD_VAR 0 4
9385: ARRAY
9386: PUSH
9387: LD_INT 2
9389: ARRAY
9390: PPUSH
9391: CALL_OW 297
9395: PUSH
9396: LD_INT 6
9398: GREATER
9399: IFFALSE 9450
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9401: LD_VAR 0 2
9405: PPUSH
9406: LD_VAR 0 6
9410: PUSH
9411: LD_INT 4
9413: ARRAY
9414: PUSH
9415: LD_VAR 0 4
9419: ARRAY
9420: PUSH
9421: LD_INT 1
9423: ARRAY
9424: PPUSH
9425: LD_VAR 0 6
9429: PUSH
9430: LD_INT 4
9432: ARRAY
9433: PUSH
9434: LD_VAR 0 4
9438: ARRAY
9439: PUSH
9440: LD_INT 2
9442: ARRAY
9443: PPUSH
9444: CALL_OW 114
9448: GO 9505
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9450: LD_INT 81
9452: PUSH
9453: LD_INT 1
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: PUSH
9460: LD_INT 91
9462: PUSH
9463: LD_VAR 0 2
9467: PUSH
9468: LD_INT 10
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: PUSH
9476: EMPTY
9477: LIST
9478: LIST
9479: PPUSH
9480: CALL_OW 69
9484: NOT
9485: IFFALSE 9505
// SetTag ( i , tag + 1 ) ;
9487: LD_VAR 0 2
9491: PPUSH
9492: LD_VAR 0 4
9496: PUSH
9497: LD_INT 1
9499: PLUS
9500: PPUSH
9501: CALL_OW 109
// end else
9505: GO 9541
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9507: LD_VAR 0 2
9511: PPUSH
9512: LD_INT 81
9514: PUSH
9515: LD_INT 1
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: PPUSH
9522: CALL_OW 69
9526: PPUSH
9527: LD_VAR 0 2
9531: PPUSH
9532: CALL_OW 74
9536: PPUSH
9537: CALL_OW 115
// end ; end ;
9541: GO 8952
9543: POP
9544: POP
// end ; until not usAttackers ;
9545: LD_EXP 46
9549: NOT
9550: IFFALSE 8267
// end ;
9552: LD_VAR 0 1
9556: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do var i ;
9557: LD_INT 22
9559: PUSH
9560: LD_INT 1
9562: PUSH
9563: EMPTY
9564: LIST
9565: LIST
9566: PUSH
9567: LD_INT 32
9569: PUSH
9570: LD_INT 1
9572: PUSH
9573: EMPTY
9574: LIST
9575: LIST
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PPUSH
9581: CALL_OW 69
9585: IFFALSE 9662
9587: GO 9589
9589: DISABLE
9590: LD_INT 0
9592: PPUSH
// begin enable ;
9593: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do
9594: LD_ADDR_VAR 0 1
9598: PUSH
9599: LD_INT 22
9601: PUSH
9602: LD_INT 1
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: PUSH
9609: LD_INT 32
9611: PUSH
9612: LD_INT 1
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: PUSH
9619: EMPTY
9620: LIST
9621: LIST
9622: PPUSH
9623: CALL_OW 69
9627: PUSH
9628: FOR_IN
9629: IFFALSE 9660
// if GetFuel ( i ) < 10 then
9631: LD_VAR 0 1
9635: PPUSH
9636: CALL_OW 261
9640: PUSH
9641: LD_INT 10
9643: LESS
9644: IFFALSE 9658
// SetFuel ( i , 10 ) ;
9646: LD_VAR 0 1
9650: PPUSH
9651: LD_INT 10
9653: PPUSH
9654: CALL_OW 240
9658: GO 9628
9660: POP
9661: POP
// end ; end_of_file
9662: PPOPN 1
9664: END
// export function Action ; var hasAll , i , tmp ; begin
9665: LD_INT 0
9667: PPUSH
9668: PPUSH
9669: PPUSH
9670: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9671: LD_ADDR_VAR 0 2
9675: PUSH
9676: LD_INT 22
9678: PUSH
9679: LD_INT 2
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: PUSH
9686: LD_INT 21
9688: PUSH
9689: LD_INT 1
9691: PUSH
9692: EMPTY
9693: LIST
9694: LIST
9695: PUSH
9696: LD_INT 23
9698: PUSH
9699: LD_INT 2
9701: PUSH
9702: EMPTY
9703: LIST
9704: LIST
9705: PUSH
9706: EMPTY
9707: LIST
9708: LIST
9709: LIST
9710: PPUSH
9711: CALL_OW 69
9715: PUSH
9716: LD_INT 7
9718: GREATEREQUAL
9719: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9720: LD_VAR 0 2
9724: PPUSH
9725: LD_STRING 03_HasAll
9727: PPUSH
9728: CALL_OW 39
// Video ( true ) ;
9732: LD_INT 1
9734: PPUSH
9735: CALL 1028 0 1
// CenterNowOnUnits ( Heike ) ;
9739: LD_EXP 27
9743: PPUSH
9744: CALL_OW 87
// wait ( 0 0$2 ) ;
9748: LD_INT 70
9750: PPUSH
9751: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9755: LD_EXP 35
9759: PPUSH
9760: LD_STRING DF-1-start
9762: PPUSH
9763: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9767: LD_EXP 27
9771: PPUSH
9772: LD_EXP 35
9776: PPUSH
9777: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9781: LD_EXP 27
9785: PPUSH
9786: LD_STRING DH-1-start
9788: PPUSH
9789: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9793: LD_EXP 36
9797: PPUSH
9798: LD_INT 92
9800: PPUSH
9801: LD_INT 21
9803: PPUSH
9804: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9808: LD_EXP 31
9812: PPUSH
9813: LD_INT 94
9815: PPUSH
9816: LD_INT 23
9818: PPUSH
9819: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9823: LD_EXP 39
9827: PUSH
9828: LD_INT 1
9830: ARRAY
9831: PPUSH
9832: LD_INT 90
9834: PPUSH
9835: LD_INT 23
9837: PPUSH
9838: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9842: LD_EXP 39
9846: PUSH
9847: LD_INT 2
9849: ARRAY
9850: PPUSH
9851: LD_INT 93
9853: PPUSH
9854: LD_INT 25
9856: PPUSH
9857: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9861: LD_EXP 39
9865: PPUSH
9866: LD_EXP 36
9870: PPUSH
9871: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9875: LD_EXP 36
9879: PUSH
9880: LD_EXP 31
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: LD_EXP 27
9893: PPUSH
9894: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9898: LD_EXP 27
9902: PPUSH
9903: LD_EXP 36
9907: PPUSH
9908: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9912: LD_INT 35
9914: PPUSH
9915: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9919: LD_EXP 36
9923: PPUSH
9924: LD_INT 92
9926: PPUSH
9927: LD_INT 21
9929: PPUSH
9930: CALL_OW 307
9934: IFFALSE 9912
// Say ( Omar , DO-1-start ) ;
9936: LD_EXP 36
9940: PPUSH
9941: LD_STRING DO-1-start
9943: PPUSH
9944: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9948: LD_EXP 27
9952: PPUSH
9953: LD_STRING DH-2-start
9955: PPUSH
9956: CALL_OW 88
// if hasAll then
9960: LD_VAR 0 2
9964: IFFALSE 10092
// begin Say ( Omar , DO-2-start ) ;
9966: LD_EXP 36
9970: PPUSH
9971: LD_STRING DO-2-start
9973: PPUSH
9974: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9978: LD_EXP 36
9982: PPUSH
9983: LD_STRING DO-3-start
9985: PPUSH
9986: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
9990: LD_EXP 27
9994: PPUSH
9995: LD_STRING DH-3-start
9997: PPUSH
9998: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
10002: LD_EXP 35
10006: PPUSH
10007: LD_STRING DF-2-start
10009: PPUSH
10010: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10014: LD_EXP 36
10018: PPUSH
10019: LD_EXP 35
10023: PPUSH
10024: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
10028: LD_EXP 36
10032: PPUSH
10033: LD_STRING DO-4-start
10035: PPUSH
10036: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
10040: LD_EXP 35
10044: PPUSH
10045: LD_STRING DF-3-start
10047: PPUSH
10048: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
10052: LD_EXP 36
10056: PPUSH
10057: LD_STRING DO-5-start
10059: PPUSH
10060: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
10064: LD_EXP 35
10068: PPUSH
10069: LD_STRING DF-4-start
10071: PPUSH
10072: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10076: LD_EXP 36
10080: PPUSH
10081: LD_EXP 27
10085: PPUSH
10086: CALL_OW 119
// end else
10090: GO 10192
// begin Say ( Omar , DO-2-start-a ) ;
10092: LD_EXP 36
10096: PPUSH
10097: LD_STRING DO-2-start-a
10099: PPUSH
10100: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
10104: LD_EXP 36
10108: PPUSH
10109: LD_STRING DO-3-start-a
10111: PPUSH
10112: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
10116: LD_EXP 27
10120: PPUSH
10121: LD_STRING DH-3-start-a
10123: PPUSH
10124: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
10128: LD_EXP 35
10132: PPUSH
10133: LD_STRING DF-2-start-a
10135: PPUSH
10136: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10140: LD_EXP 36
10144: PPUSH
10145: LD_EXP 35
10149: PPUSH
10150: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
10154: LD_EXP 36
10158: PPUSH
10159: LD_STRING DO-4-start-a
10161: PPUSH
10162: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
10166: LD_EXP 35
10170: PPUSH
10171: LD_STRING DF-3-start-a
10173: PPUSH
10174: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10178: LD_EXP 36
10182: PPUSH
10183: LD_EXP 27
10187: PPUSH
10188: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
10192: LD_INT 10
10194: PPUSH
10195: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
10199: LD_EXP 36
10203: PPUSH
10204: LD_STRING DO-1-mission
10206: PPUSH
10207: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
10211: LD_EXP 36
10215: PPUSH
10216: LD_STRING DO-2-mission
10218: PPUSH
10219: CALL_OW 88
// if not hasAll then
10223: LD_VAR 0 2
10227: NOT
10228: IFFALSE 10242
// Say ( Omar , DO-3-mission ) ;
10230: LD_EXP 36
10234: PPUSH
10235: LD_STRING DO-3-mission
10237: PPUSH
10238: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
10242: LD_EXP 36
10246: PPUSH
10247: LD_STRING DO-4-mission
10249: PPUSH
10250: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
10254: LD_EXP 27
10258: PPUSH
10259: LD_STRING DH-1-mission
10261: PPUSH
10262: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10266: LD_EXP 35
10270: PPUSH
10271: LD_STRING DF-1-mission
10273: PPUSH
10274: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10278: LD_EXP 36
10282: PPUSH
10283: LD_STRING DO-5-mission
10285: PPUSH
10286: CALL_OW 88
// if not hasAll then
10290: LD_VAR 0 2
10294: NOT
10295: IFFALSE 10430
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10297: LD_ADDR_VAR 0 4
10301: PUSH
10302: LD_INT 22
10304: PUSH
10305: LD_INT 2
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: LD_INT 21
10314: PUSH
10315: LD_INT 1
10317: PUSH
10318: EMPTY
10319: LIST
10320: LIST
10321: PUSH
10322: LD_INT 23
10324: PUSH
10325: LD_INT 2
10327: PUSH
10328: EMPTY
10329: LIST
10330: LIST
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: LIST
10336: PPUSH
10337: CALL_OW 69
10341: ST_TO_ADDR
// for i := 7 downto tmp do
10342: LD_ADDR_VAR 0 3
10346: PUSH
10347: DOUBLE
10348: LD_INT 7
10350: INC
10351: ST_TO_ADDR
10352: LD_VAR 0 4
10356: PUSH
10357: FOR_DOWNTO
10358: IFFALSE 10428
// begin if omarSquad < 3 then
10360: LD_EXP 39
10364: PUSH
10365: LD_INT 3
10367: LESS
10368: IFFALSE 10372
// break ;
10370: GO 10428
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10372: LD_EXP 39
10376: PUSH
10377: LD_INT 3
10379: ARRAY
10380: PPUSH
10381: LD_INT 2
10383: PPUSH
10384: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10388: LD_ADDR_EXP 41
10392: PUSH
10393: LD_EXP 41
10397: PUSH
10398: LD_EXP 39
10402: PUSH
10403: LD_INT 3
10405: ARRAY
10406: UNION
10407: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10408: LD_ADDR_EXP 39
10412: PUSH
10413: LD_EXP 39
10417: PPUSH
10418: LD_INT 3
10420: PPUSH
10421: CALL_OW 3
10425: ST_TO_ADDR
// end ;
10426: GO 10357
10428: POP
10429: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10430: LD_EXP 36
10434: PUSH
10435: LD_EXP 39
10439: ADD
10440: PPUSH
10441: LD_INT 103
10443: PPUSH
10444: LD_INT 9
10446: PPUSH
10447: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10451: LD_VAR 0 2
10455: PUSH
10456: LD_EXP 32
10460: PPUSH
10461: CALL_OW 302
10465: AND
10466: IFFALSE 10527
// begin wait ( 0 0$3 ) ;
10468: LD_INT 105
10470: PPUSH
10471: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10475: LD_EXP 32
10479: PPUSH
10480: LD_EXP 35
10484: PPUSH
10485: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10489: LD_EXP 32
10493: PPUSH
10494: LD_STRING DK-1-side
10496: PPUSH
10497: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10501: LD_EXP 35
10505: PPUSH
10506: LD_EXP 32
10510: PPUSH
10511: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10515: LD_EXP 35
10519: PPUSH
10520: LD_STRING DF-1-side
10522: PPUSH
10523: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10527: LD_INT 22
10529: PUSH
10530: LD_INT 2
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PPUSH
10537: CALL_OW 69
10541: PPUSH
10542: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10546: LD_EXP 35
10550: PUSH
10551: LD_EXP 38
10555: ADD
10556: PPUSH
10557: LD_INT 108
10559: PPUSH
10560: LD_INT 62
10562: PPUSH
10563: CALL_OW 111
// gameStarted := true ;
10567: LD_ADDR_EXP 3
10571: PUSH
10572: LD_INT 1
10574: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10575: LD_INT 105
10577: PPUSH
10578: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10582: LD_EXP 27
10586: PPUSH
10587: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10591: LD_EXP 27
10595: PPUSH
10596: LD_EXP 31
10600: PPUSH
10601: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10605: LD_INT 22
10607: PUSH
10608: LD_INT 2
10610: PUSH
10611: EMPTY
10612: LIST
10613: LIST
10614: PPUSH
10615: CALL_OW 69
10619: PUSH
10620: LD_EXP 27
10624: DIFF
10625: PPUSH
10626: LD_EXP 27
10630: PPUSH
10631: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10635: LD_EXP 27
10639: PPUSH
10640: LD_STRING DH-1-explore
10642: PPUSH
10643: CALL_OW 88
// if Givi then
10647: LD_EXP 28
10651: IFFALSE 10667
// Say ( Givi , DG-1-explore ) else
10653: LD_EXP 28
10657: PPUSH
10658: LD_STRING DG-1-explore
10660: PPUSH
10661: CALL_OW 88
10665: GO 10704
// if heikeSecondSquad then
10667: LD_EXP 41
10671: IFFALSE 10704
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10673: LD_EXP 41
10677: PPUSH
10678: LD_INT 26
10680: PUSH
10681: LD_INT 1
10683: PUSH
10684: EMPTY
10685: LIST
10686: LIST
10687: PPUSH
10688: CALL_OW 72
10692: PUSH
10693: LD_INT 1
10695: ARRAY
10696: PPUSH
10697: LD_STRING DArm-1-explore
10699: PPUSH
10700: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10704: LD_EXP 31
10708: PPUSH
10709: LD_STRING DA-1-explore
10711: PPUSH
10712: CALL_OW 88
// if Sophia then
10716: LD_EXP 33
10720: IFFALSE 10798
// begin Say ( Sophia , DS-2-explore ) ;
10722: LD_EXP 33
10726: PPUSH
10727: LD_STRING DS-2-explore
10729: PPUSH
10730: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10734: LD_EXP 31
10738: PPUSH
10739: LD_STRING DA-2-explore
10741: PPUSH
10742: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10746: LD_EXP 33
10750: PPUSH
10751: LD_EXP 31
10755: PPUSH
10756: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10760: LD_EXP 31
10764: PPUSH
10765: LD_EXP 33
10769: PPUSH
10770: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10774: LD_EXP 33
10778: PPUSH
10779: LD_STRING DS-3-explore
10781: PPUSH
10782: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10786: LD_EXP 31
10790: PPUSH
10791: LD_STRING DA-3-explore
10793: PPUSH
10794: CALL_OW 88
// end ; if Mike then
10798: LD_EXP 29
10802: IFFALSE 10858
// begin Say ( Mike , DM-1-explore ) ;
10804: LD_EXP 29
10808: PPUSH
10809: LD_STRING DM-1-explore
10811: PPUSH
10812: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10816: LD_EXP 27
10820: PPUSH
10821: LD_STRING DH-2-explore
10823: PPUSH
10824: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10828: LD_EXP 29
10832: PPUSH
10833: LD_STRING DM-2-explore
10835: PPUSH
10836: CALL_OW 88
// if Kaia then
10840: LD_EXP 32
10844: IFFALSE 10858
// Say ( Kaia , DK-1-explore ) ;
10846: LD_EXP 32
10850: PPUSH
10851: LD_STRING DK-1-explore
10853: PPUSH
10854: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10858: LD_INT 22
10860: PUSH
10861: LD_INT 2
10863: PUSH
10864: EMPTY
10865: LIST
10866: LIST
10867: PPUSH
10868: CALL_OW 69
10872: PPUSH
10873: CALL_OW 139
// Video ( false ) ;
10877: LD_INT 0
10879: PPUSH
10880: CALL 1028 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10884: LD_STRING BuildBase
10886: PPUSH
10887: CALL_OW 337
// SaveForQuickRestart ;
10891: CALL_OW 22
// end ;
10895: LD_VAR 0 1
10899: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10900: LD_EXP 5
10904: NOT
10905: PUSH
10906: LD_EXP 6
10910: NOT
10911: AND
10912: PUSH
10913: LD_INT 5
10915: PPUSH
10916: LD_INT 22
10918: PUSH
10919: LD_INT 2
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PPUSH
10926: CALL_OW 70
10930: AND
10931: PUSH
10932: LD_EXP 6
10936: NOT
10937: AND
10938: IFFALSE 11023
10940: GO 10942
10942: DISABLE
// begin if Mike then
10943: LD_EXP 29
10947: IFFALSE 10963
// Say ( Mike , DM-1-scout ) else
10949: LD_EXP 29
10953: PPUSH
10954: LD_STRING DM-1-scout
10956: PPUSH
10957: CALL_OW 88
10961: GO 10994
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10963: LD_EXP 41
10967: PPUSH
10968: LD_INT 26
10970: PUSH
10971: LD_INT 1
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: PPUSH
10978: CALL_OW 72
10982: PUSH
10983: LD_INT 1
10985: ARRAY
10986: PPUSH
10987: LD_STRING DArm-1-explore
10989: PPUSH
10990: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
10994: LD_INT 54
10996: PPUSH
10997: LD_INT 35
10999: PPUSH
11000: LD_INT 2
11002: PPUSH
11003: LD_INT 1
11005: PPUSH
11006: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
11010: LD_INT 54
11012: PPUSH
11013: LD_INT 35
11015: PPUSH
11016: LD_INT 2
11018: PPUSH
11019: CALL_OW 331
// end ;
11023: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
11024: LD_INT 6
11026: PPUSH
11027: LD_INT 22
11029: PUSH
11030: LD_INT 2
11032: PUSH
11033: EMPTY
11034: LIST
11035: LIST
11036: PPUSH
11037: CALL_OW 70
11041: PUSH
11042: LD_EXP 6
11046: NOT
11047: AND
11048: IFFALSE 11302
11050: GO 11052
11052: DISABLE
11053: LD_INT 0
11055: PPUSH
11056: PPUSH
11057: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11058: LD_ADDR_VAR 0 1
11062: PUSH
11063: LD_EXP 41
11067: PPUSH
11068: LD_INT 26
11070: PUSH
11071: LD_INT 1
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: PPUSH
11078: CALL_OW 72
11082: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
11083: LD_ADDR_VAR 0 2
11087: PUSH
11088: LD_EXP 41
11092: PPUSH
11093: LD_INT 26
11095: PUSH
11096: LD_INT 2
11098: PUSH
11099: EMPTY
11100: LIST
11101: LIST
11102: PPUSH
11103: CALL_OW 72
11107: ST_TO_ADDR
// DialogueOn ;
11108: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
11112: LD_INT 36
11114: PPUSH
11115: LD_INT 22
11117: PPUSH
11118: LD_INT 2
11120: PPUSH
11121: LD_INT 8
11123: PPUSH
11124: CALL_OW 330
// dwait ( 0 0$1 ) ;
11128: LD_INT 35
11130: PPUSH
11131: CALL_OW 68
// speakerOk := false ;
11135: LD_ADDR_VAR 0 3
11139: PUSH
11140: LD_INT 0
11142: ST_TO_ADDR
// if Mike then
11143: LD_EXP 29
11147: IFFALSE 11169
// speakerOk := Say ( Mike , DM-1-spot ) else
11149: LD_ADDR_VAR 0 3
11153: PUSH
11154: LD_EXP 29
11158: PPUSH
11159: LD_STRING DM-1-spot
11161: PPUSH
11162: CALL_OW 88
11166: ST_TO_ADDR
11167: GO 11197
// if randomMen then
11169: LD_VAR 0 1
11173: IFFALSE 11197
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11175: LD_ADDR_VAR 0 3
11179: PUSH
11180: LD_VAR 0 1
11184: PUSH
11185: LD_INT 1
11187: ARRAY
11188: PPUSH
11189: LD_STRING DArm-1-spot-a
11191: PPUSH
11192: CALL_OW 88
11196: ST_TO_ADDR
// if speakerOk then
11197: LD_VAR 0 3
11201: IFFALSE 11245
// begin if Givi then
11203: LD_EXP 28
11207: IFFALSE 11223
// Say ( Givi , DG-1-spot ) else
11209: LD_EXP 28
11213: PPUSH
11214: LD_STRING DG-1-spot
11216: PPUSH
11217: CALL_OW 88
11221: GO 11245
// if randomWomen then
11223: LD_VAR 0 2
11227: IFFALSE 11245
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
11229: LD_VAR 0 2
11233: PUSH
11234: LD_INT 1
11236: ARRAY
11237: PPUSH
11238: LD_STRING DArf-1-spot-a
11240: PPUSH
11241: CALL_OW 88
// end ; if Mike then
11245: LD_EXP 29
11249: IFFALSE 11265
// Say ( Heike , DH-1-spot ) else
11251: LD_EXP 27
11255: PPUSH
11256: LD_STRING DH-1-spot
11258: PPUSH
11259: CALL_OW 88
11263: GO 11277
// Say ( Heike , DH-1-spot-a ) ;
11265: LD_EXP 27
11269: PPUSH
11270: LD_STRING DH-1-spot-a
11272: PPUSH
11273: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11277: LD_INT 36
11279: PPUSH
11280: LD_INT 22
11282: PPUSH
11283: LD_INT 2
11285: PPUSH
11286: CALL_OW 331
// DialogueOff ;
11290: CALL_OW 7
// americanBaseSpoted := true ;
11294: LD_ADDR_EXP 5
11298: PUSH
11299: LD_INT 1
11301: ST_TO_ADDR
// end ;
11302: PPOPN 3
11304: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11305: LD_EXP 5
11309: NOT
11310: PUSH
11311: LD_INT 22
11313: PUSH
11314: LD_INT 2
11316: PUSH
11317: EMPTY
11318: LIST
11319: LIST
11320: PUSH
11321: LD_INT 101
11323: PUSH
11324: LD_INT 1
11326: PUSH
11327: EMPTY
11328: LIST
11329: LIST
11330: PUSH
11331: EMPTY
11332: LIST
11333: LIST
11334: PPUSH
11335: CALL_OW 69
11339: AND
11340: PUSH
11341: LD_EXP 6
11345: NOT
11346: AND
11347: IFFALSE 11433
11349: GO 11351
11351: DISABLE
11352: LD_INT 0
11354: PPUSH
// begin americanBaseSpoted := true ;
11355: LD_ADDR_EXP 5
11359: PUSH
11360: LD_INT 1
11362: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11363: LD_ADDR_VAR 0 1
11367: PUSH
11368: LD_EXP 41
11372: PPUSH
11373: LD_INT 26
11375: PUSH
11376: LD_INT 1
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PPUSH
11383: CALL_OW 72
11387: ST_TO_ADDR
// if not randomMen then
11388: LD_VAR 0 1
11392: NOT
11393: IFFALSE 11397
// exit ;
11395: GO 11433
// DialogueOn ;
11397: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11401: LD_VAR 0 1
11405: PUSH
11406: LD_INT 1
11408: ARRAY
11409: PPUSH
11410: LD_STRING DArm-1-spot-a
11412: PPUSH
11413: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11417: LD_EXP 27
11421: PPUSH
11422: LD_STRING DH-1-spot-a
11424: PPUSH
11425: CALL_OW 88
// DialogueOff ;
11429: CALL_OW 7
// end ;
11433: PPOPN 1
11435: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or usForces <= 4 do var i , p ;
11436: LD_INT 11
11438: PPUSH
11439: CALL_OW 255
11443: PUSH
11444: LD_INT 2
11446: EQUAL
11447: PUSH
11448: LD_INT 7
11450: PPUSH
11451: LD_INT 22
11453: PUSH
11454: LD_INT 1
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: PUSH
11461: LD_INT 3
11463: PUSH
11464: LD_INT 50
11466: PUSH
11467: EMPTY
11468: LIST
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: PUSH
11474: LD_INT 30
11476: PUSH
11477: LD_INT 31
11479: PUSH
11480: EMPTY
11481: LIST
11482: LIST
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: LIST
11488: PPUSH
11489: CALL_OW 70
11493: OR
11494: PUSH
11495: LD_INT 7
11497: PPUSH
11498: LD_INT 22
11500: PUSH
11501: LD_INT 2
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PPUSH
11508: CALL_OW 70
11512: PUSH
11513: LD_INT 1
11515: GREATER
11516: OR
11517: PUSH
11518: LD_EXP 43
11522: PUSH
11523: LD_INT 4
11525: LESSEQUAL
11526: OR
11527: IFFALSE 12045
11529: GO 11531
11531: DISABLE
11532: LD_INT 0
11534: PPUSH
11535: PPUSH
// begin wait ( 0 0$3 ) ;
11536: LD_INT 105
11538: PPUSH
11539: CALL_OW 67
// if IsOk ( usCommander ) then
11543: LD_EXP 44
11547: PPUSH
11548: CALL_OW 302
11552: IFFALSE 11582
// begin usForces := usForces union usCommander ;
11554: LD_ADDR_EXP 43
11558: PUSH
11559: LD_EXP 43
11563: PUSH
11564: LD_EXP 44
11568: UNION
11569: ST_TO_ADDR
// Say ( usCommander , DUsm-1-assault ) ;
11570: LD_EXP 44
11574: PPUSH
11575: LD_STRING DUsm-1-assault
11577: PPUSH
11578: CALL_OW 88
// end ; for i in usForces do
11582: LD_ADDR_VAR 0 1
11586: PUSH
11587: LD_EXP 43
11591: PUSH
11592: FOR_IN
11593: IFFALSE 11639
// begin if IsInUnit ( i ) then
11595: LD_VAR 0 1
11599: PPUSH
11600: CALL_OW 310
11604: IFFALSE 11615
// ComExitBuilding ( i ) ;
11606: LD_VAR 0 1
11610: PPUSH
11611: CALL_OW 122
// wait ( 3 ) ;
11615: LD_INT 3
11617: PPUSH
11618: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11622: LD_VAR 0 1
11626: PPUSH
11627: LD_INT 34
11629: PPUSH
11630: LD_INT 67
11632: PPUSH
11633: CALL_OW 111
// end ;
11637: GO 11592
11639: POP
11640: POP
// Say ( Heike , DH-1-assault ) ;
11641: LD_EXP 27
11645: PPUSH
11646: LD_STRING DH-1-assault
11648: PPUSH
11649: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11653: LD_INT 35
11655: PPUSH
11656: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11660: LD_VAR 0 1
11664: PPUSH
11665: LD_INT 34
11667: PPUSH
11668: LD_INT 67
11670: PPUSH
11671: CALL_OW 111
// until not usForces ;
11675: LD_EXP 43
11679: NOT
11680: IFFALSE 11653
// music_nat := 2 ;
11682: LD_ADDR_OWVAR 71
11686: PUSH
11687: LD_INT 2
11689: ST_TO_ADDR
// music_class := music_victory ;
11690: LD_ADDR_OWVAR 72
11694: PUSH
11695: LD_INT 4
11697: ST_TO_ADDR
// if not americanHasEscaped then
11698: LD_EXP 8
11702: NOT
11703: IFFALSE 11724
// begin Say ( Heike , DH-2-assault ) ;
11705: LD_EXP 27
11709: PPUSH
11710: LD_STRING DH-2-assault
11712: PPUSH
11713: CALL_OW 88
// SetAchievement ( ACH_CLEAN ) ;
11717: LD_STRING ACH_CLEAN
11719: PPUSH
11720: CALL_OW 543
// end ; wait ( 0 0$2 ) ;
11724: LD_INT 70
11726: PPUSH
11727: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11731: LD_INT 35
11733: PPUSH
11734: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11738: LD_INT 22
11740: PUSH
11741: LD_INT 2
11743: PUSH
11744: EMPTY
11745: LIST
11746: LIST
11747: PUSH
11748: LD_INT 21
11750: PUSH
11751: LD_INT 1
11753: PUSH
11754: EMPTY
11755: LIST
11756: LIST
11757: PUSH
11758: LD_INT 3
11760: PUSH
11761: LD_INT 50
11763: PUSH
11764: EMPTY
11765: LIST
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: LIST
11775: PPUSH
11776: CALL_OW 69
11780: NOT
11781: IFFALSE 11731
// InGameOn ;
11783: CALL_OW 8
// if not GetSide ( usDepot ) = 2 then
11787: LD_INT 11
11789: PPUSH
11790: CALL_OW 255
11794: PUSH
11795: LD_INT 2
11797: EQUAL
11798: NOT
11799: IFFALSE 11811
// SetSide ( usDepot , 2 ) ;
11801: LD_INT 11
11803: PPUSH
11804: LD_INT 2
11806: PPUSH
11807: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11811: LD_INT 35
11813: PPUSH
11814: LD_INT 22
11816: PPUSH
11817: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11821: LD_EXP 27
11825: PPUSH
11826: LD_INT 35
11828: PPUSH
11829: LD_INT 22
11831: PPUSH
11832: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11836: LD_EXP 27
11840: PPUSH
11841: LD_INT 38
11843: PPUSH
11844: LD_INT 25
11846: PPUSH
11847: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11851: LD_EXP 40
11855: PUSH
11856: LD_EXP 41
11860: UNION
11861: PPUSH
11862: LD_INT 39
11864: PPUSH
11865: LD_INT 26
11867: PPUSH
11868: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11872: LD_EXP 40
11876: PUSH
11877: LD_EXP 41
11881: UNION
11882: PPUSH
11883: LD_EXP 27
11887: PPUSH
11888: CALL_OW 179
// p := 0 ;
11892: LD_ADDR_VAR 0 2
11896: PUSH
11897: LD_INT 0
11899: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11900: LD_INT 35
11902: PPUSH
11903: CALL_OW 67
// p := p + 1 ;
11907: LD_ADDR_VAR 0 2
11911: PUSH
11912: LD_VAR 0 2
11916: PUSH
11917: LD_INT 1
11919: PLUS
11920: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11921: LD_EXP 27
11925: PPUSH
11926: CALL_OW 314
11930: NOT
11931: PUSH
11932: LD_VAR 0 2
11936: PUSH
11937: LD_INT 10
11939: GREATER
11940: OR
11941: IFFALSE 11900
// Say ( Heike , DH-1-capture ) ;
11943: LD_EXP 27
11947: PPUSH
11948: LD_STRING DH-1-capture
11950: PPUSH
11951: CALL_OW 88
// if Markov then
11955: LD_EXP 34
11959: IFFALSE 11973
// Say ( Markov , DMar-1-capture ) ;
11961: LD_EXP 34
11965: PPUSH
11966: LD_STRING DMar-1-capture
11968: PPUSH
11969: CALL_OW 88
// if Sophia then
11973: LD_EXP 33
11977: IFFALSE 12003
// begin Say ( Heike , DH-2-capture ) ;
11979: LD_EXP 27
11983: PPUSH
11984: LD_STRING DH-2-capture
11986: PPUSH
11987: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
11991: LD_EXP 33
11995: PPUSH
11996: LD_STRING DS-1-capture
11998: PPUSH
11999: CALL_OW 88
// end ; InGameOff ;
12003: CALL_OW 9
// music_nat := music_auto ;
12007: LD_ADDR_OWVAR 71
12011: PUSH
12012: LD_INT 0
12014: ST_TO_ADDR
// music_class := music_auto ;
12015: LD_ADDR_OWVAR 72
12019: PUSH
12020: LD_INT 0
12022: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
12023: LD_STRING ConstructBase
12025: PPUSH
12026: CALL_OW 337
// wait ( 0 0$3 ) ;
12030: LD_INT 105
12032: PPUSH
12033: CALL_OW 67
// americanBaseCaptured := true ;
12037: LD_ADDR_EXP 6
12041: PUSH
12042: LD_INT 1
12044: ST_TO_ADDR
// end ;
12045: PPOPN 2
12047: END
// every 0 0$1 trigger capturedCargoCounter >= 3 do
12048: LD_EXP 13
12052: PUSH
12053: LD_INT 3
12055: GREATEREQUAL
12056: IFFALSE 12068
12058: GO 12060
12060: DISABLE
// SetAchievement ( ACH_ENG ) ;
12061: LD_STRING ACH_ENG
12063: PPUSH
12064: CALL_OW 543
12068: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) >= 4 do
12069: LD_INT 22
12071: PUSH
12072: LD_INT 2
12074: PUSH
12075: EMPTY
12076: LIST
12077: LIST
12078: PUSH
12079: LD_INT 25
12081: PUSH
12082: LD_INT 15
12084: PUSH
12085: EMPTY
12086: LIST
12087: LIST
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PPUSH
12093: CALL_OW 69
12097: PUSH
12098: LD_INT 4
12100: GREATEREQUAL
12101: IFFALSE 12113
12103: GO 12105
12105: DISABLE
// SetAchievement ( ACH_APEGEN ) ;
12106: LD_STRING ACH_APEGEN
12108: PPUSH
12109: CALL_OW 543
12113: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
12114: LD_INT 22
12116: PUSH
12117: LD_INT 2
12119: PUSH
12120: EMPTY
12121: LIST
12122: LIST
12123: PUSH
12124: LD_INT 30
12126: PUSH
12127: LD_INT 2
12129: PUSH
12130: EMPTY
12131: LIST
12132: LIST
12133: PUSH
12134: LD_INT 3
12136: PUSH
12137: LD_INT 57
12139: PUSH
12140: EMPTY
12141: LIST
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: EMPTY
12148: LIST
12149: LIST
12150: LIST
12151: PPUSH
12152: CALL_OW 69
12156: IFFALSE 12399
12158: GO 12160
12160: DISABLE
// begin workshopBuilded := true ;
12161: LD_ADDR_EXP 10
12165: PUSH
12166: LD_INT 1
12168: ST_TO_ADDR
// if IsOk ( Markov ) then
12169: LD_EXP 34
12173: PPUSH
12174: CALL_OW 302
12178: IFFALSE 12237
// begin Say ( Heike , DH-1-shop-a ) ;
12180: LD_EXP 27
12184: PPUSH
12185: LD_STRING DH-1-shop-a
12187: PPUSH
12188: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
12192: LD_INT 47
12194: PPUSH
12195: LD_INT 2
12197: PPUSH
12198: CALL_OW 321
12202: PUSH
12203: LD_INT 2
12205: EQUAL
12206: PUSH
12207: LD_INT 45
12209: PPUSH
12210: LD_INT 2
12212: PPUSH
12213: CALL_OW 321
12217: PUSH
12218: LD_INT 2
12220: EQUAL
12221: AND
12222: NOT
12223: IFFALSE 12237
// Say ( Markov , DMar-1-shop-a ) ;
12225: LD_EXP 34
12229: PPUSH
12230: LD_STRING DMar-1-shop-a
12232: PPUSH
12233: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
12237: LD_INT 35
12239: PPUSH
12240: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched or GetTech ( tech_SolEng , 2 ) = state_researched ;
12244: LD_INT 47
12246: PPUSH
12247: LD_INT 2
12249: PPUSH
12250: CALL_OW 321
12254: PUSH
12255: LD_INT 2
12257: EQUAL
12258: PUSH
12259: LD_INT 45
12261: PPUSH
12262: LD_INT 2
12264: PPUSH
12265: CALL_OW 321
12269: PUSH
12270: LD_INT 2
12272: EQUAL
12273: OR
12274: IFFALSE 12237
// DialogueOn ;
12276: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
12280: LD_EXP 34
12284: PPUSH
12285: LD_STRING DMar-1-shop
12287: PPUSH
12288: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
12292: LD_EXP 27
12296: PPUSH
12297: LD_STRING DH-1-shop
12299: PPUSH
12300: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12304: LD_EXP 34
12308: PPUSH
12309: LD_STRING DMar-2-shop
12311: PPUSH
12312: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12316: LD_EXP 34
12320: PPUSH
12321: LD_STRING DMar-3-shop
12323: PPUSH
12324: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12328: LD_EXP 27
12332: PPUSH
12333: LD_STRING DH-2-shop
12335: PPUSH
12336: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12340: LD_EXP 34
12344: PPUSH
12345: LD_STRING DMar-4-shop
12347: PPUSH
12348: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12352: LD_EXP 27
12356: PPUSH
12357: LD_STRING DH-3-shop
12359: PPUSH
12360: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12364: LD_EXP 34
12368: PPUSH
12369: LD_STRING DMar-5-shop
12371: PPUSH
12372: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12376: LD_EXP 27
12380: PPUSH
12381: LD_STRING DH-4-shop
12383: PPUSH
12384: CALL_OW 88
// DialogueOff ;
12388: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12392: LD_STRING ConstructVeh
12394: PPUSH
12395: CALL_OW 337
// end ;
12399: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12400: LD_INT 2
12402: PPUSH
12403: LD_INT 2
12405: PPUSH
12406: LD_INT 1
12408: PPUSH
12409: CALL 1199 0 3
12413: PUSH
12414: LD_INT 0
12416: EQUAL
12417: IFFALSE 12429
12419: GO 12421
12421: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12422: LD_STRING Techs
12424: PPUSH
12425: CALL_OW 337
12429: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12430: LD_EXP 34
12434: PPUSH
12435: CALL_OW 302
12439: PUSH
12440: LD_INT 22
12442: PUSH
12443: LD_INT 2
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: PUSH
12450: LD_INT 2
12452: PUSH
12453: LD_INT 34
12455: PUSH
12456: LD_INT 22
12458: PUSH
12459: EMPTY
12460: LIST
12461: LIST
12462: PUSH
12463: LD_INT 35
12465: PUSH
12466: LD_INT 22
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: PUSH
12473: EMPTY
12474: LIST
12475: LIST
12476: LIST
12477: PUSH
12478: EMPTY
12479: LIST
12480: LIST
12481: PPUSH
12482: CALL_OW 69
12486: AND
12487: IFFALSE 12594
12489: GO 12491
12491: DISABLE
// begin DialogueOn ;
12492: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12496: LD_INT 22
12498: PUSH
12499: LD_INT 2
12501: PUSH
12502: EMPTY
12503: LIST
12504: LIST
12505: PUSH
12506: LD_INT 2
12508: PUSH
12509: LD_INT 34
12511: PUSH
12512: LD_INT 22
12514: PUSH
12515: EMPTY
12516: LIST
12517: LIST
12518: PUSH
12519: LD_INT 35
12521: PUSH
12522: LD_INT 22
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: PUSH
12529: EMPTY
12530: LIST
12531: LIST
12532: LIST
12533: PUSH
12534: EMPTY
12535: LIST
12536: LIST
12537: PPUSH
12538: CALL_OW 69
12542: PPUSH
12543: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12547: LD_INT 10
12549: PPUSH
12550: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12554: LD_EXP 27
12558: PPUSH
12559: LD_STRING DH-1-bal
12561: PPUSH
12562: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12566: LD_EXP 34
12570: PPUSH
12571: LD_STRING DMar-1-bal
12573: PPUSH
12574: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12578: LD_EXP 27
12582: PPUSH
12583: LD_STRING DH-2-bal
12585: PPUSH
12586: CALL_OW 88
// DialogueOff ;
12590: CALL_OW 7
// end ;
12594: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12595: LD_EXP 31
12599: PPUSH
12600: CALL_OW 302
12604: PUSH
12605: LD_INT 22
12607: PUSH
12608: LD_INT 2
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 30
12617: PUSH
12618: LD_INT 6
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: PPUSH
12629: CALL_OW 69
12633: AND
12634: IFFALSE 12695
12636: GO 12638
12638: DISABLE
// begin DialogueOn ;
12639: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12643: LD_EXP 31
12647: PPUSH
12648: LD_STRING DA-1-lab
12650: PPUSH
12651: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12655: LD_EXP 27
12659: PPUSH
12660: LD_STRING DH-1-lab
12662: PPUSH
12663: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12667: LD_EXP 31
12671: PPUSH
12672: LD_STRING DA-2-lab
12674: PPUSH
12675: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12679: LD_EXP 27
12683: PPUSH
12684: LD_STRING DH-2-lab
12686: PPUSH
12687: CALL_OW 88
// DialogueOff ;
12691: CALL_OW 7
// end ;
12695: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12696: LD_EXP 32
12700: PPUSH
12701: CALL_OW 302
12705: PUSH
12706: LD_INT 22
12708: PUSH
12709: LD_INT 2
12711: PUSH
12712: EMPTY
12713: LIST
12714: LIST
12715: PUSH
12716: LD_INT 25
12718: PUSH
12719: LD_INT 15
12721: PUSH
12722: EMPTY
12723: LIST
12724: LIST
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: PPUSH
12730: CALL_OW 69
12734: AND
12735: PUSH
12736: LD_INT 81
12738: PUSH
12739: LD_INT 2
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: PPUSH
12746: CALL_OW 69
12750: NOT
12751: AND
12752: IFFALSE 12934
12754: GO 12756
12756: DISABLE
12757: LD_INT 0
12759: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12760: LD_ADDR_VAR 0 1
12764: PUSH
12765: LD_INT 22
12767: PUSH
12768: LD_INT 2
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 25
12777: PUSH
12778: LD_INT 15
12780: PUSH
12781: EMPTY
12782: LIST
12783: LIST
12784: PUSH
12785: EMPTY
12786: LIST
12787: LIST
12788: PPUSH
12789: CALL_OW 69
12793: ST_TO_ADDR
// InGameOn ;
12794: CALL_OW 8
// CenterNowOnUnits ( ape [ 1 ] ) ;
12798: LD_VAR 0 1
12802: PUSH
12803: LD_INT 1
12805: ARRAY
12806: PPUSH
12807: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12811: LD_VAR 0 1
12815: PUSH
12816: LD_INT 1
12818: ARRAY
12819: PPUSH
12820: CALL_OW 122
// Say ( Kaia , DK-1-apesol ) ;
12824: LD_EXP 32
12828: PPUSH
12829: LD_STRING DK-1-apesol
12831: PPUSH
12832: CALL_OW 88
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12836: LD_VAR 0 1
12840: PUSH
12841: LD_INT 1
12843: ARRAY
12844: PPUSH
12845: LD_INT 35
12847: PPUSH
12848: LD_INT 28
12850: PPUSH
12851: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12855: LD_VAR 0 1
12859: PUSH
12860: LD_INT 1
12862: ARRAY
12863: PPUSH
12864: LD_INT 36
12866: PPUSH
12867: LD_INT 17
12869: PPUSH
12870: CALL_OW 171
// DialogueOn ;
12874: CALL_OW 6
// Say ( Aviradze , DA-1-apesol ) ;
12878: LD_EXP 31
12882: PPUSH
12883: LD_STRING DA-1-apesol
12885: PPUSH
12886: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12890: LD_EXP 32
12894: PPUSH
12895: LD_STRING DK-2-apesol
12897: PPUSH
12898: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12902: LD_EXP 31
12906: PPUSH
12907: LD_STRING DA-2-apesol
12909: PPUSH
12910: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12914: LD_EXP 32
12918: PPUSH
12919: LD_STRING DK-3-apesol
12921: PPUSH
12922: CALL_OW 88
// DialogueOff ;
12926: CALL_OW 7
// InGameOff ;
12930: CALL_OW 9
// end ;
12934: PPOPN 1
12936: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12937: LD_EXP 33
12941: PPUSH
12942: CALL_OW 302
12946: PUSH
12947: LD_INT 22
12949: PUSH
12950: LD_INT 2
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: PUSH
12957: LD_INT 25
12959: PUSH
12960: LD_INT 16
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PPUSH
12971: CALL_OW 69
12975: AND
12976: PUSH
12977: LD_INT 81
12979: PUSH
12980: LD_INT 2
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PPUSH
12987: CALL_OW 69
12991: NOT
12992: AND
12993: IFFALSE 13256
12995: GO 12997
12997: DISABLE
12998: LD_INT 0
13000: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
13001: LD_ADDR_VAR 0 1
13005: PUSH
13006: LD_INT 22
13008: PUSH
13009: LD_INT 2
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: PUSH
13016: LD_INT 25
13018: PUSH
13019: LD_INT 16
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: PUSH
13026: EMPTY
13027: LIST
13028: LIST
13029: PPUSH
13030: CALL_OW 69
13034: ST_TO_ADDR
// InGameOn ;
13035: CALL_OW 8
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
13039: LD_INT 5
13041: PPUSH
13042: LD_INT 35
13044: PPUSH
13045: LD_INT 22
13047: PPUSH
13048: LD_INT 1
13050: PPUSH
13051: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
13055: LD_EXP 33
13059: PPUSH
13060: LD_VAR 0 1
13064: PUSH
13065: LD_INT 1
13067: ARRAY
13068: PPUSH
13069: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
13073: LD_VAR 0 1
13077: PUSH
13078: LD_INT 1
13080: ARRAY
13081: PPUSH
13082: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
13086: LD_VAR 0 1
13090: PUSH
13091: LD_INT 1
13093: ARRAY
13094: PPUSH
13095: CALL_OW 122
// wait ( 0 0$2 ) ;
13099: LD_INT 70
13101: PPUSH
13102: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
13106: LD_EXP 33
13110: PPUSH
13111: LD_STRING DS-1-apeeng
13113: PPUSH
13114: CALL_OW 88
// if IsOk ( Kamil ) then
13118: LD_EXP 30
13122: PPUSH
13123: CALL_OW 302
13127: IFFALSE 13252
// begin Say ( Kamil , DKam-1-apeeng ) ;
13129: LD_EXP 30
13133: PPUSH
13134: LD_STRING DKam-1-apeeng
13136: PPUSH
13137: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
13141: LD_EXP 33
13145: PPUSH
13146: LD_STRING DS-2-apeeng
13148: PPUSH
13149: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
13153: LD_EXP 30
13157: PPUSH
13158: LD_STRING DKam-2-apeeng
13160: PPUSH
13161: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
13165: LD_EXP 33
13169: PPUSH
13170: LD_STRING DS-3-apeeng
13172: PPUSH
13173: CALL_OW 88
// if not IsOK ( Kaia ) then
13177: LD_EXP 32
13181: PPUSH
13182: CALL_OW 302
13186: NOT
13187: IFFALSE 13195
// begin InGameOff ;
13189: CALL_OW 9
// exit ;
13193: GO 13256
// end ; Say ( Kaia , DK-1-apeeng ) ;
13195: LD_EXP 32
13199: PPUSH
13200: LD_STRING DK-1-apeeng
13202: PPUSH
13203: CALL_OW 88
// if not IsOk ( Givi ) then
13207: LD_EXP 28
13211: PPUSH
13212: CALL_OW 302
13216: NOT
13217: IFFALSE 13228
// begin Video ( false ) ;
13219: LD_INT 0
13221: PPUSH
13222: CALL 1028 0 1
// exit ;
13226: GO 13256
// end ; Say ( Givi , DG-1-apeeng ) ;
13228: LD_EXP 28
13232: PPUSH
13233: LD_STRING DG-1-apeeng
13235: PPUSH
13236: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
13240: LD_EXP 32
13244: PPUSH
13245: LD_STRING DK-2-apeeng
13247: PPUSH
13248: CALL_OW 88
// end ; InGameOff ;
13252: CALL_OW 9
// end ;
13256: PPOPN 1
13258: END
// every 0 0$10 trigger farmerBaseReady and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) do
13259: LD_EXP 4
13263: PUSH
13264: LD_INT 22
13266: PUSH
13267: LD_INT 2
13269: PUSH
13270: EMPTY
13271: LIST
13272: LIST
13273: PUSH
13274: LD_INT 30
13276: PUSH
13277: LD_INT 0
13279: PUSH
13280: EMPTY
13281: LIST
13282: LIST
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: PPUSH
13288: CALL_OW 69
13292: AND
13293: IFFALSE 13458
13295: GO 13297
13297: DISABLE
// begin wait ( 0 0$10 ) ;
13298: LD_INT 350
13300: PPUSH
13301: CALL_OW 67
// DialogueOn ;
13305: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
13309: LD_EXP 35
13313: PPUSH
13314: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
13318: LD_EXP 35
13322: PPUSH
13323: LD_STRING DF-1-distribution
13325: PPUSH
13326: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
13330: LD_EXP 27
13334: PPUSH
13335: LD_STRING DH-2-distribution
13337: PPUSH
13338: CALL_OW 88
// if IsOk ( Kaia ) then
13342: LD_EXP 32
13346: PPUSH
13347: CALL_OW 302
13351: IFFALSE 13412
// begin Say ( Kaia , DK-1-distribution ) ;
13353: LD_EXP 32
13357: PPUSH
13358: LD_STRING DK-1-distribution
13360: PPUSH
13361: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13365: LD_EXP 27
13369: PPUSH
13370: LD_STRING DH-1-distribution
13372: PPUSH
13373: CALL_OW 88
// if IsOk ( Givi ) then
13377: LD_EXP 28
13381: PPUSH
13382: CALL_OW 302
13386: IFFALSE 13412
// begin Say ( Givi , DG-1-distribution ) ;
13388: LD_EXP 28
13392: PPUSH
13393: LD_STRING DG-1-distribution
13395: PPUSH
13396: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13400: LD_EXP 27
13404: PPUSH
13405: LD_STRING DH-3-distribution
13407: PPUSH
13408: CALL_OW 88
// end ; end ; DialogueOff ;
13412: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13416: LD_STRING Crates1
13418: PPUSH
13419: CALL_OW 337
// farmerRequestedCrates := 300 ;
13423: LD_ADDR_EXP 15
13427: PUSH
13428: LD_INT 300
13430: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13431: LD_STRING FarmerCrates
13433: PPUSH
13434: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13438: LD_INT 10
13440: PPUSH
13441: LD_INT 1
13443: PPUSH
13444: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13448: LD_INT 108
13450: PPUSH
13451: LD_INT 61
13453: PPUSH
13454: CALL_OW 86
// end ;
13458: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13459: LD_EXP 6
13463: PUSH
13464: LD_INT 22
13466: PUSH
13467: LD_INT 2
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: LD_INT 3
13476: PUSH
13477: LD_INT 57
13479: PUSH
13480: EMPTY
13481: LIST
13482: PUSH
13483: EMPTY
13484: LIST
13485: LIST
13486: PUSH
13487: LD_INT 2
13489: PUSH
13490: LD_INT 30
13492: PUSH
13493: LD_INT 6
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PUSH
13500: LD_INT 30
13502: PUSH
13503: LD_INT 7
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: LIST
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: LIST
13519: PPUSH
13520: CALL_OW 69
13524: AND
13525: PUSH
13526: LD_INT 22
13528: PUSH
13529: LD_INT 2
13531: PUSH
13532: EMPTY
13533: LIST
13534: LIST
13535: PUSH
13536: LD_INT 3
13538: PUSH
13539: LD_INT 57
13541: PUSH
13542: EMPTY
13543: LIST
13544: PUSH
13545: EMPTY
13546: LIST
13547: LIST
13548: PUSH
13549: LD_INT 30
13551: PUSH
13552: LD_INT 4
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: LIST
13563: PPUSH
13564: CALL_OW 69
13568: AND
13569: IFFALSE 13733
13571: GO 13573
13573: DISABLE
13574: LD_INT 0
13576: PPUSH
// begin wait ( 0 0$10 ) ;
13577: LD_INT 350
13579: PPUSH
13580: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13584: LD_ADDR_VAR 0 1
13588: PUSH
13589: LD_EXP 41
13593: PPUSH
13594: LD_INT 26
13596: PUSH
13597: LD_INT 1
13599: PUSH
13600: EMPTY
13601: LIST
13602: LIST
13603: PUSH
13604: LD_INT 25
13606: PUSH
13607: LD_INT 2
13609: PUSH
13610: EMPTY
13611: LIST
13612: LIST
13613: PUSH
13614: EMPTY
13615: LIST
13616: LIST
13617: PPUSH
13618: CALL_OW 72
13622: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13623: LD_EXP 27
13627: PPUSH
13628: LD_STRING DH-1-task
13630: PPUSH
13631: CALL_OW 88
// if IsOk ( Sophia ) then
13635: LD_EXP 33
13639: PPUSH
13640: CALL_OW 302
13644: IFFALSE 13684
// begin Say ( Sophia , DS-1-task ) ;
13646: LD_EXP 33
13650: PPUSH
13651: LD_STRING DS-1-task
13653: PPUSH
13654: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13658: LD_EXP 33
13662: PPUSH
13663: LD_STRING DS-2-task
13665: PPUSH
13666: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13670: LD_EXP 27
13674: PPUSH
13675: LD_STRING DH-2-task
13677: PPUSH
13678: CALL_OW 88
// end else
13682: GO 13718
// if eng then
13684: LD_VAR 0 1
13688: IFFALSE 13718
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13690: LD_VAR 0 1
13694: PUSH
13695: LD_INT 1
13697: ARRAY
13698: PPUSH
13699: LD_STRING DArm-1-task
13701: PPUSH
13702: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13706: LD_EXP 27
13710: PPUSH
13711: LD_STRING DH-2-task
13713: PPUSH
13714: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13718: LD_STRING BaseConstructed
13720: PPUSH
13721: CALL_OW 337
// allowConvoys := true ;
13725: LD_ADDR_EXP 12
13729: PUSH
13730: LD_INT 1
13732: ST_TO_ADDR
// end ;
13733: PPOPN 1
13735: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13736: LD_INT 22
13738: PUSH
13739: LD_INT 4
13741: PUSH
13742: EMPTY
13743: LIST
13744: LIST
13745: PUSH
13746: LD_INT 34
13748: PUSH
13749: LD_INT 12
13751: PUSH
13752: EMPTY
13753: LIST
13754: LIST
13755: PUSH
13756: EMPTY
13757: LIST
13758: LIST
13759: PPUSH
13760: CALL_OW 69
13764: IFFALSE 13932
13766: GO 13768
13768: DISABLE
13769: LD_INT 0
13771: PPUSH
13772: PPUSH
13773: PPUSH
// begin wait ( 0 0$2 ) ;
13774: LD_INT 70
13776: PPUSH
13777: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13781: LD_ADDR_VAR 0 1
13785: PUSH
13786: LD_INT 22
13788: PUSH
13789: LD_INT 4
13791: PUSH
13792: EMPTY
13793: LIST
13794: LIST
13795: PUSH
13796: LD_INT 34
13798: PUSH
13799: LD_INT 12
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: PUSH
13806: EMPTY
13807: LIST
13808: LIST
13809: PPUSH
13810: CALL_OW 69
13814: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13815: LD_ADDR_VAR 0 2
13819: PUSH
13820: LD_VAR 0 1
13824: PUSH
13825: LD_INT 1
13827: ARRAY
13828: PPUSH
13829: CALL_OW 250
13833: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13834: LD_ADDR_VAR 0 3
13838: PUSH
13839: LD_VAR 0 1
13843: PUSH
13844: LD_INT 1
13846: ARRAY
13847: PPUSH
13848: CALL_OW 251
13852: ST_TO_ADDR
// DialogueOn ;
13853: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13857: LD_VAR 0 2
13861: PPUSH
13862: LD_VAR 0 3
13866: PPUSH
13867: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13871: LD_VAR 0 2
13875: PPUSH
13876: LD_VAR 0 3
13880: PPUSH
13881: LD_INT 2
13883: PPUSH
13884: LD_INT 6
13886: NEG
13887: PPUSH
13888: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13892: LD_INT 10
13894: PPUSH
13895: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13899: LD_EXP 27
13903: PPUSH
13904: LD_STRING DH-1-seecargo
13906: PPUSH
13907: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13911: LD_VAR 0 2
13915: PPUSH
13916: LD_VAR 0 3
13920: PPUSH
13921: LD_INT 2
13923: PPUSH
13924: CALL_OW 331
// DialogueOff ;
13928: CALL_OW 7
// end ;
13932: PPOPN 3
13934: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13935: LD_EXP 4
13939: PUSH
13940: LD_EXP 14
13944: PUSH
13945: LD_INT 300
13947: GREATEREQUAL
13948: AND
13949: IFFALSE 14021
13951: GO 13953
13953: DISABLE
// begin DialogueOn ;
13954: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13958: LD_EXP 35
13962: PPUSH
13963: LD_STRING DF-1-delivery-2
13965: PPUSH
13966: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13970: LD_EXP 27
13974: PPUSH
13975: LD_STRING DH-1-delivery-2
13977: PPUSH
13978: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
13982: LD_EXP 35
13986: PPUSH
13987: LD_STRING DF-2-delivery-2
13989: PPUSH
13990: CALL_OW 94
// DialogueOff ;
13994: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
13998: LD_STRING Crates2
14000: PPUSH
14001: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14005: LD_ADDR_EXP 16
14009: PUSH
14010: LD_INT 63000
14012: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
14013: LD_ADDR_EXP 15
14017: PUSH
14018: LD_INT 600
14020: ST_TO_ADDR
// end ;
14021: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 do
14022: LD_EXP 4
14026: PUSH
14027: LD_EXP 14
14031: PUSH
14032: LD_INT 600
14034: GREATEREQUAL
14035: AND
14036: IFFALSE 14202
14038: GO 14040
14040: DISABLE
// begin DialogueOn ;
14041: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
14045: LD_EXP 35
14049: PPUSH
14050: LD_STRING DF-1-delivery-3
14052: PPUSH
14053: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
14057: LD_EXP 27
14061: PPUSH
14062: LD_STRING DH-1-delivery-3
14064: PPUSH
14065: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
14069: LD_EXP 35
14073: PPUSH
14074: LD_STRING DF-2-delivery-3
14076: PPUSH
14077: CALL_OW 94
// if IsOk ( Kaia ) then
14081: LD_EXP 32
14085: PPUSH
14086: CALL_OW 302
14090: IFFALSE 14140
// begin Say ( Kaia , DK-1-delivery-3 ) ;
14092: LD_EXP 32
14096: PPUSH
14097: LD_STRING DK-1-delivery-3
14099: PPUSH
14100: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
14104: LD_EXP 27
14108: PPUSH
14109: LD_STRING DH-2-delivery-3
14111: PPUSH
14112: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
14116: LD_EXP 28
14120: PPUSH
14121: LD_STRING DG-1-delivery-3
14123: PPUSH
14124: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
14128: LD_EXP 29
14132: PPUSH
14133: LD_STRING DM-1-delivery-3
14135: PPUSH
14136: CALL_OW 88
// end ; DialogueOff ;
14140: CALL_OW 7
// if Difficulty = 2 then
14144: LD_OWVAR 67
14148: PUSH
14149: LD_INT 2
14151: EQUAL
14152: IFFALSE 14179
// begin ChangeMissionObjectives ( Crates3 ) ;
14154: LD_STRING Crates3
14156: PPUSH
14157: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14161: LD_ADDR_EXP 16
14165: PUSH
14166: LD_INT 63000
14168: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
14169: LD_ADDR_EXP 15
14173: PUSH
14174: LD_INT 900
14176: ST_TO_ADDR
// end else
14177: GO 14202
// begin ChangeMissionObjectives ( Crates4 ) ;
14179: LD_STRING Crates4
14181: PPUSH
14182: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14186: LD_ADDR_EXP 16
14190: PUSH
14191: LD_INT 63000
14193: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
14194: LD_ADDR_EXP 15
14198: PUSH
14199: LD_INT 1200
14201: ST_TO_ADDR
// end ; end ;
14202: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
14203: LD_EXP 4
14207: PUSH
14208: LD_EXP 14
14212: PUSH
14213: LD_INT 600
14215: PUSH
14216: LD_INT 900
14218: PUSH
14219: LD_INT 1200
14221: PUSH
14222: EMPTY
14223: LIST
14224: LIST
14225: LIST
14226: PUSH
14227: LD_OWVAR 67
14231: ARRAY
14232: GREATEREQUAL
14233: AND
14234: PUSH
14235: LD_EXP 15
14239: PUSH
14240: LD_EXP 16
14244: LESSEQUAL
14245: AND
14246: IFFALSE 14313
14248: GO 14250
14250: DISABLE
// begin retreatAllowed := true ;
14251: LD_ADDR_EXP 11
14255: PUSH
14256: LD_INT 1
14258: ST_TO_ADDR
// display_strings := [ ] ;
14259: LD_ADDR_OWVAR 47
14263: PUSH
14264: EMPTY
14265: ST_TO_ADDR
// DialogueOn ;
14266: CALL_OW 6
// InGameOn ;
14270: CALL_OW 8
// SayRadio ( Omar , DO-radio-end ) ;
14274: LD_EXP 36
14278: PPUSH
14279: LD_STRING DO-radio-end
14281: PPUSH
14282: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
14286: LD_EXP 27
14290: PPUSH
14291: LD_STRING DH-1-radio-end
14293: PPUSH
14294: CALL_OW 88
// InGameOff ;
14298: CALL_OW 9
// DialogueOff ;
14302: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
14306: LD_STRING Retreat
14308: PPUSH
14309: CALL_OW 337
// end ;
14313: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
14314: LD_EXP 11
14318: IFFALSE 14449
14320: GO 14322
14322: DISABLE
14323: LD_INT 0
14325: PPUSH
14326: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
14327: LD_INT 10
14329: PPUSH
14330: LD_INT 0
14332: PPUSH
14333: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
14337: LD_ADDR_VAR 0 1
14341: PUSH
14342: LD_EXP 38
14346: PPUSH
14347: LD_INT 25
14349: PUSH
14350: LD_INT 2
14352: PUSH
14353: EMPTY
14354: LIST
14355: LIST
14356: PPUSH
14357: CALL_OW 72
14361: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14362: LD_VAR 0 1
14366: PUSH
14367: LD_INT 102
14369: PPUSH
14370: LD_INT 69
14372: PPUSH
14373: CALL_OW 428
14377: PUSH
14378: LD_INT 0
14380: EQUAL
14381: AND
14382: IFFALSE 14449
// begin for i in tmp do
14384: LD_ADDR_VAR 0 2
14388: PUSH
14389: LD_VAR 0 1
14393: PUSH
14394: FOR_IN
14395: IFFALSE 14419
// if IsInUnit ( i ) then
14397: LD_VAR 0 2
14401: PPUSH
14402: CALL_OW 310
14406: IFFALSE 14417
// ComExitBuilding ( i ) ;
14408: LD_VAR 0 2
14412: PPUSH
14413: CALL_OW 122
14417: GO 14394
14419: POP
14420: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14421: LD_VAR 0 1
14425: PPUSH
14426: LD_INT 31
14428: PPUSH
14429: LD_INT 102
14431: PPUSH
14432: LD_INT 69
14434: PPUSH
14435: LD_INT 2
14437: PPUSH
14438: CALL_OW 205
// wait ( 0 0$3 ) ;
14442: LD_INT 105
14444: PPUSH
14445: CALL_OW 67
// end ; end ;
14449: PPOPN 2
14451: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14452: LD_EXP 11
14456: NOT
14457: PUSH
14458: LD_INT 5
14460: PPUSH
14461: CALL_OW 301
14465: AND
14466: IFFALSE 14490
14468: GO 14470
14470: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
14471: LD_EXP 35
14475: PPUSH
14476: LD_STRING DF-1-failure
14478: PPUSH
14479: CALL_OW 94
// YouLost ( FarmerDepot ) ;
14483: LD_STRING FarmerDepot
14485: PPUSH
14486: CALL_OW 104
// end ;
14490: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 and not FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_type , unit_human ] ] ) do var i , max , tmp ;
14491: LD_EXP 11
14495: PUSH
14496: LD_EXP 27
14500: PPUSH
14501: LD_EXP 35
14505: PPUSH
14506: CALL_OW 296
14510: PUSH
14511: LD_INT 6
14513: LESS
14514: AND
14515: PUSH
14516: LD_INT 81
14518: PUSH
14519: LD_INT 2
14521: PUSH
14522: EMPTY
14523: LIST
14524: LIST
14525: PUSH
14526: LD_INT 21
14528: PUSH
14529: LD_INT 1
14531: PUSH
14532: EMPTY
14533: LIST
14534: LIST
14535: PUSH
14536: EMPTY
14537: LIST
14538: LIST
14539: PPUSH
14540: CALL_OW 69
14544: NOT
14545: AND
14546: IFFALSE 15167
14548: GO 14550
14550: DISABLE
14551: LD_INT 0
14553: PPUSH
14554: PPUSH
14555: PPUSH
// begin allowConvoys := false ;
14556: LD_ADDR_EXP 12
14560: PUSH
14561: LD_INT 0
14563: ST_TO_ADDR
// InGameOn ;
14564: CALL_OW 8
// ComTurnUnit ( Heike , Farmer ) ;
14568: LD_EXP 27
14572: PPUSH
14573: LD_EXP 35
14577: PPUSH
14578: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14582: LD_EXP 35
14586: PPUSH
14587: LD_EXP 27
14591: PPUSH
14592: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14596: LD_EXP 35
14600: PPUSH
14601: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14605: LD_EXP 27
14609: PPUSH
14610: LD_STRING DH-1-end
14612: PPUSH
14613: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14617: LD_EXP 35
14621: PPUSH
14622: LD_STRING DF-1-end
14624: PPUSH
14625: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14629: LD_EXP 35
14633: PPUSH
14634: LD_STRING DF-2-end
14636: PPUSH
14637: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14641: LD_EXP 27
14645: PPUSH
14646: LD_STRING DH-2-end
14648: PPUSH
14649: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14653: LD_EXP 35
14657: PPUSH
14658: LD_STRING DF-3-end
14660: PPUSH
14661: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14665: LD_EXP 27
14669: PPUSH
14670: LD_STRING DH-3-end
14672: PPUSH
14673: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14677: LD_EXP 28
14681: PPUSH
14682: LD_STRING DG-1-end
14684: PPUSH
14685: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14689: LD_EXP 27
14693: PPUSH
14694: LD_STRING DH-4-end
14696: PPUSH
14697: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14701: LD_EXP 35
14705: PPUSH
14706: LD_STRING DF-4-end
14708: PPUSH
14709: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14713: LD_EXP 27
14717: PPUSH
14718: LD_STRING DH-5-end
14720: PPUSH
14721: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14725: LD_EXP 35
14729: PPUSH
14730: LD_STRING DF-5-end
14732: PPUSH
14733: CALL_OW 88
// InGameOff ;
14737: CALL_OW 9
// allowCargoEvacuation := true ;
14741: LD_ADDR_EXP 7
14745: PUSH
14746: LD_INT 1
14748: ST_TO_ADDR
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14749: LD_ADDR_VAR 0 2
14753: PUSH
14754: LD_INT 4
14756: PUSH
14757: LD_INT 3
14759: PUSH
14760: LD_INT 2
14762: PUSH
14763: EMPTY
14764: LIST
14765: LIST
14766: LIST
14767: PUSH
14768: LD_OWVAR 67
14772: ARRAY
14773: ST_TO_ADDR
// if farmerSquad < max then
14774: LD_EXP 38
14778: PUSH
14779: LD_VAR 0 2
14783: LESS
14784: IFFALSE 14796
// max := farmerSquad ;
14786: LD_ADDR_VAR 0 2
14790: PUSH
14791: LD_EXP 38
14795: ST_TO_ADDR
// for i := 1 to max do
14796: LD_ADDR_VAR 0 1
14800: PUSH
14801: DOUBLE
14802: LD_INT 1
14804: DEC
14805: ST_TO_ADDR
14806: LD_VAR 0 2
14810: PUSH
14811: FOR_TO
14812: IFFALSE 14850
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14814: LD_EXP 38
14818: PUSH
14819: LD_INT 1
14821: ARRAY
14822: PPUSH
14823: LD_INT 2
14825: PPUSH
14826: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14830: LD_ADDR_EXP 38
14834: PUSH
14835: LD_EXP 38
14839: PPUSH
14840: LD_INT 1
14842: PPUSH
14843: CALL_OW 3
14847: ST_TO_ADDR
// end ;
14848: GO 14811
14850: POP
14851: POP
// for i in Farmer ^ farmerSquad do
14852: LD_ADDR_VAR 0 1
14856: PUSH
14857: LD_EXP 35
14861: PUSH
14862: LD_EXP 38
14866: ADD
14867: PUSH
14868: FOR_IN
14869: IFFALSE 14908
// begin if IsInUnit ( i ) then
14871: LD_VAR 0 1
14875: PPUSH
14876: CALL_OW 310
14880: IFFALSE 14891
// ComExitBuilding ( i ) ;
14882: LD_VAR 0 1
14886: PPUSH
14887: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14891: LD_VAR 0 1
14895: PPUSH
14896: LD_INT 102
14898: PPUSH
14899: LD_INT 7
14901: PPUSH
14902: CALL_OW 171
// end ;
14906: GO 14868
14908: POP
14909: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14910: LD_ADDR_VAR 0 1
14914: PUSH
14915: LD_INT 22
14917: PUSH
14918: LD_INT 5
14920: PUSH
14921: EMPTY
14922: LIST
14923: LIST
14924: PUSH
14925: LD_INT 21
14927: PUSH
14928: LD_INT 3
14930: PUSH
14931: EMPTY
14932: LIST
14933: LIST
14934: PUSH
14935: EMPTY
14936: LIST
14937: LIST
14938: PPUSH
14939: CALL_OW 69
14943: PUSH
14944: LD_INT 5
14946: DIFF
14947: PUSH
14948: FOR_IN
14949: IFFALSE 14965
// SetSide ( i , 2 ) ;
14951: LD_VAR 0 1
14955: PPUSH
14956: LD_INT 2
14958: PPUSH
14959: CALL_OW 235
14963: GO 14948
14965: POP
14966: POP
// repeat wait ( 0 0$1 ) ;
14967: LD_INT 35
14969: PPUSH
14970: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
14974: LD_ADDR_VAR 0 3
14978: PUSH
14979: LD_EXP 35
14983: PUSH
14984: LD_EXP 38
14988: ADD
14989: PPUSH
14990: LD_INT 95
14992: PUSH
14993: LD_INT 3
14995: PUSH
14996: EMPTY
14997: LIST
14998: LIST
14999: PPUSH
15000: CALL_OW 72
15004: ST_TO_ADDR
// if tmp then
15005: LD_VAR 0 3
15009: IFFALSE 15053
// for i in tmp do
15011: LD_ADDR_VAR 0 1
15015: PUSH
15016: LD_VAR 0 3
15020: PUSH
15021: FOR_IN
15022: IFFALSE 15051
// begin farmerSquad := farmerSquad diff i ;
15024: LD_ADDR_EXP 38
15028: PUSH
15029: LD_EXP 38
15033: PUSH
15034: LD_VAR 0 1
15038: DIFF
15039: ST_TO_ADDR
// RemoveUnit ( i ) ;
15040: LD_VAR 0 1
15044: PPUSH
15045: CALL_OW 64
// end ;
15049: GO 15021
15051: POP
15052: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
15053: LD_EXP 38
15057: PUSH
15058: EMPTY
15059: EQUAL
15060: PUSH
15061: LD_EXP 35
15065: PPUSH
15066: CALL_OW 305
15070: NOT
15071: AND
15072: IFFALSE 14967
// if farmerHumanLoseCounter = 0 then
15074: LD_EXP 19
15078: PUSH
15079: LD_INT 0
15081: EQUAL
15082: IFFALSE 15091
// SetAchievement ( ACH_BABY ) ;
15084: LD_STRING ACH_BABY
15086: PPUSH
15087: CALL_OW 543
// wait ( 1 1$00 ) ;
15091: LD_INT 2100
15093: PPUSH
15094: CALL_OW 67
// SendAttack ;
15098: CALL 7019 0 0
// for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15102: LD_ADDR_VAR 0 1
15106: PUSH
15107: DOUBLE
15108: LD_INT 1
15110: DEC
15111: ST_TO_ADDR
15112: LD_INT 2
15114: PUSH
15115: LD_INT 3
15117: PUSH
15118: LD_INT 4
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: LIST
15125: PUSH
15126: LD_OWVAR 67
15130: ARRAY
15131: PUSH
15132: FOR_TO
15133: IFFALSE 15165
// begin wait ( [ 2 2$00 , 1 1$40 , 1 1$30 ] [ Difficulty ] ) ;
15135: LD_INT 4200
15137: PUSH
15138: LD_INT 3500
15140: PUSH
15141: LD_INT 3150
15143: PUSH
15144: EMPTY
15145: LIST
15146: LIST
15147: LIST
15148: PUSH
15149: LD_OWVAR 67
15153: ARRAY
15154: PPUSH
15155: CALL_OW 67
// SendAttack ;
15159: CALL 7019 0 0
// end ;
15163: GO 15132
15165: POP
15166: POP
// end ;
15167: PPOPN 3
15169: END
// every 0 0$1 trigger allowCargoEvacuation do
15170: LD_EXP 7
15174: IFFALSE 15183
15176: GO 15178
15178: DISABLE
// StartCargoEvacuation ;
15179: CALL 4562 0 0
15183: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
15184: LD_EXP 16
15188: PUSH
15189: LD_INT 18900
15191: LESSEQUAL
15192: IFFALSE 15241
15194: GO 15196
15196: DISABLE
// begin DialogueOn ;
15197: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
15201: LD_EXP 35
15205: PPUSH
15206: LD_STRING DF-1-distribution-a
15208: PPUSH
15209: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
15213: LD_EXP 27
15217: PPUSH
15218: LD_STRING DH-1-distribution-a
15220: PPUSH
15221: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
15225: LD_EXP 35
15229: PPUSH
15230: LD_STRING DF-2-distribution-a
15232: PPUSH
15233: CALL_OW 94
// DialogueOff ;
15237: CALL_OW 7
// end ;
15241: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
15242: LD_EXP 16
15246: PUSH
15247: LD_INT 0
15249: LESSEQUAL
15250: IFFALSE 15282
15252: GO 15254
15254: DISABLE
// begin DialogueOn ;
15255: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
15259: LD_EXP 35
15263: PPUSH
15264: LD_STRING DF-3-distribution-a
15266: PPUSH
15267: CALL_OW 94
// YouLost ( Distribution ) ;
15271: LD_STRING Distribution
15273: PPUSH
15274: CALL_OW 104
// DialogueOff ;
15278: CALL_OW 7
// end ;
15282: END
// every 0 0$1 trigger vehCounter >= 2 do
15283: LD_EXP 21
15287: PUSH
15288: LD_INT 2
15290: GREATEREQUAL
15291: IFFALSE 15303
15293: GO 15295
15295: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
15296: LD_STRING VehConstructed
15298: PPUSH
15299: CALL_OW 337
15303: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
15304: LD_INT 22
15306: PUSH
15307: LD_INT 2
15309: PUSH
15310: EMPTY
15311: LIST
15312: LIST
15313: PUSH
15314: LD_INT 34
15316: PUSH
15317: LD_INT 12
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PPUSH
15328: CALL_OW 69
15332: IFFALSE 15392
15334: GO 15336
15336: DISABLE
// begin DialogueOn ;
15337: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
15341: LD_EXP 27
15345: PPUSH
15346: LD_STRING DH-1-truck
15348: PPUSH
15349: CALL_OW 88
// if IsOk ( Markov ) then
15353: LD_EXP 34
15357: PPUSH
15358: CALL_OW 302
15362: IFFALSE 15388
// begin Say ( Markov , DMar-1-truck ) ;
15364: LD_EXP 34
15368: PPUSH
15369: LD_STRING DMar-1-truck
15371: PPUSH
15372: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
15376: LD_EXP 27
15380: PPUSH
15381: LD_STRING DH-2-truck
15383: PPUSH
15384: CALL_OW 88
// end ; DialogueOff ;
15388: CALL_OW 7
// end ;
15392: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
15393: LD_INT 0
15395: PPUSH
15396: PPUSH
15397: PPUSH
// if IsOk ( Givi ) then
15398: LD_EXP 28
15402: PPUSH
15403: CALL_OW 302
15407: IFFALSE 15423
// begin Say ( Givi , DG-1-nocargo ) ;
15409: LD_EXP 28
15413: PPUSH
15414: LD_STRING DG-1-nocargo
15416: PPUSH
15417: CALL_OW 88
// exit ;
15421: GO 15519
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15423: LD_ADDR_VAR 0 2
15427: PUSH
15428: LD_EXP 41
15432: PPUSH
15433: LD_INT 26
15435: PUSH
15436: LD_INT 1
15438: PUSH
15439: EMPTY
15440: LIST
15441: LIST
15442: PPUSH
15443: CALL_OW 72
15447: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15448: LD_ADDR_VAR 0 3
15452: PUSH
15453: LD_EXP 41
15457: PPUSH
15458: LD_INT 26
15460: PUSH
15461: LD_INT 2
15463: PUSH
15464: EMPTY
15465: LIST
15466: LIST
15467: PPUSH
15468: CALL_OW 72
15472: ST_TO_ADDR
// if randomMen then
15473: LD_VAR 0 2
15477: IFFALSE 15497
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15479: LD_VAR 0 2
15483: PUSH
15484: LD_INT 1
15486: ARRAY
15487: PPUSH
15488: LD_STRING DArm-1-nocargo
15490: PPUSH
15491: CALL_OW 88
15495: GO 15519
// if randomWomen then
15497: LD_VAR 0 3
15501: IFFALSE 15519
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15503: LD_VAR 0 3
15507: PUSH
15508: LD_INT 1
15510: ARRAY
15511: PPUSH
15512: LD_STRING DArf-1-nocargo
15514: PPUSH
15515: CALL_OW 88
// end ;
15519: LD_VAR 0 1
15523: RET
// export function IncomingAttack ; begin
15524: LD_INT 0
15526: PPUSH
// if attackWave = 1 then
15527: LD_EXP 18
15531: PUSH
15532: LD_INT 1
15534: EQUAL
15535: IFFALSE 15606
// begin DialogueOn ;
15537: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15541: LD_EXP 36
15545: PPUSH
15546: LD_STRING DO-1-radio-1
15548: PPUSH
15549: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15553: LD_EXP 27
15557: PPUSH
15558: LD_STRING DH-1-radio-1-
15560: PPUSH
15561: CALL_OW 88
// if IsOk ( Markov ) then
15565: LD_EXP 34
15569: PPUSH
15570: CALL_OW 302
15574: IFFALSE 15600
// begin Say ( Markov , DMar-1-radio-1 ) ;
15576: LD_EXP 34
15580: PPUSH
15581: LD_STRING DMar-1-radio-1
15583: PPUSH
15584: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15588: LD_EXP 27
15592: PPUSH
15593: LD_STRING DH-2-radio-1
15595: PPUSH
15596: CALL_OW 88
// end ; DialogueOff ;
15600: CALL_OW 7
// end else
15604: GO 15630
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15606: LD_EXP 36
15610: PPUSH
15611: LD_STRING DO-1-radio-u
15613: PPUSH
15614: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15618: LD_EXP 27
15622: PPUSH
15623: LD_STRING DH-1-radio-u
15625: PPUSH
15626: CALL_OW 88
// end ; end ;
15630: LD_VAR 0 1
15634: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15635: LD_EXP 43
15639: PPUSH
15640: LD_INT 95
15642: PUSH
15643: LD_INT 8
15645: PUSH
15646: EMPTY
15647: LIST
15648: LIST
15649: PPUSH
15650: CALL_OW 72
15654: IFFALSE 15757
15656: GO 15658
15658: DISABLE
15659: LD_INT 0
15661: PPUSH
// begin enable ;
15662: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15663: LD_ADDR_VAR 0 1
15667: PUSH
15668: LD_EXP 43
15672: PPUSH
15673: LD_INT 95
15675: PUSH
15676: LD_INT 8
15678: PUSH
15679: EMPTY
15680: LIST
15681: LIST
15682: PPUSH
15683: CALL_OW 72
15687: PUSH
15688: FOR_IN
15689: IFFALSE 15718
// begin usForces := usForces diff i ;
15691: LD_ADDR_EXP 43
15695: PUSH
15696: LD_EXP 43
15700: PUSH
15701: LD_VAR 0 1
15705: DIFF
15706: ST_TO_ADDR
// RemoveUnit ( i ) ;
15707: LD_VAR 0 1
15711: PPUSH
15712: CALL_OW 64
// end ;
15716: GO 15688
15718: POP
15719: POP
// if not americanHasEscaped and attackWave = 1 then
15720: LD_EXP 8
15724: NOT
15725: PUSH
15726: LD_EXP 18
15730: PUSH
15731: LD_INT 1
15733: EQUAL
15734: AND
15735: IFFALSE 15757
// begin americanHasEscaped := true ;
15737: LD_ADDR_EXP 8
15741: PUSH
15742: LD_INT 1
15744: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15745: LD_EXP 27
15749: PPUSH
15750: LD_STRING DH-2-assault-a
15752: PPUSH
15753: CALL_OW 88
// end ; end ;
15757: PPOPN 1
15759: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) and not retreatAllowed do
15760: LD_INT 4
15762: PPUSH
15763: LD_INT 22
15765: PUSH
15766: LD_INT 1
15768: PUSH
15769: EMPTY
15770: LIST
15771: LIST
15772: PPUSH
15773: CALL_OW 70
15777: PUSH
15778: LD_EXP 11
15782: NOT
15783: AND
15784: IFFALSE 15801
15786: GO 15788
15788: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15789: LD_EXP 35
15793: PPUSH
15794: LD_STRING DF-1-attack
15796: PPUSH
15797: CALL_OW 94
15801: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15802: LD_INT 5
15804: PPUSH
15805: CALL_OW 255
15809: PUSH
15810: LD_INT 2
15812: EQUAL
15813: IFFALSE 15825
15815: GO 15817
15817: DISABLE
// YouLost ( Attack ) ;
15818: LD_STRING Attack
15820: PPUSH
15821: CALL_OW 104
15825: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 90 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot ;
15826: LD_INT 22
15828: PUSH
15829: LD_INT 1
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: PUSH
15836: LD_INT 21
15838: PUSH
15839: LD_INT 1
15841: PUSH
15842: EMPTY
15843: LIST
15844: LIST
15845: PUSH
15846: EMPTY
15847: LIST
15848: LIST
15849: PPUSH
15850: CALL_OW 69
15854: NOT
15855: PUSH
15856: LD_INT 22
15858: PUSH
15859: LD_INT 4
15861: PUSH
15862: EMPTY
15863: LIST
15864: LIST
15865: PPUSH
15866: CALL_OW 69
15870: NOT
15871: AND
15872: PUSH
15873: LD_EXP 11
15877: NOT
15878: AND
15879: PUSH
15880: LD_EXP 14
15884: PUSH
15885: LD_INT 90
15887: GREATER
15888: AND
15889: PUSH
15890: LD_INT 7
15892: PPUSH
15893: LD_INT 22
15895: PUSH
15896: LD_INT 2
15898: PUSH
15899: EMPTY
15900: LIST
15901: LIST
15902: PUSH
15903: LD_INT 21
15905: PUSH
15906: LD_INT 1
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: PPUSH
15917: CALL_OW 70
15921: AND
15922: PUSH
15923: LD_INT 22
15925: PUSH
15926: LD_INT 2
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PUSH
15933: LD_INT 50
15935: PUSH
15936: EMPTY
15937: LIST
15938: PUSH
15939: LD_INT 30
15941: PUSH
15942: LD_INT 0
15944: PUSH
15945: EMPTY
15946: LIST
15947: LIST
15948: PUSH
15949: EMPTY
15950: LIST
15951: LIST
15952: LIST
15953: PPUSH
15954: CALL_OW 69
15958: AND
15959: IFFALSE 16660
15961: GO 15963
15963: DISABLE
15964: LD_INT 0
15966: PPUSH
15967: PPUSH
15968: PPUSH
15969: PPUSH
15970: PPUSH
// begin depot := usDepot ;
15971: LD_ADDR_VAR 0 5
15975: PUSH
15976: LD_INT 11
15978: ST_TO_ADDR
// if not depot then
15979: LD_VAR 0 5
15983: NOT
15984: IFFALSE 16024
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
15986: LD_ADDR_VAR 0 5
15990: PUSH
15991: LD_INT 22
15993: PUSH
15994: LD_INT 2
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: PUSH
16001: LD_INT 30
16003: PUSH
16004: LD_INT 0
16006: PUSH
16007: EMPTY
16008: LIST
16009: LIST
16010: PUSH
16011: EMPTY
16012: LIST
16013: LIST
16014: PPUSH
16015: CALL_OW 69
16019: PUSH
16020: LD_INT 1
16022: ARRAY
16023: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
16024: LD_ADDR_VAR 0 1
16028: PUSH
16029: LD_EXP 41
16033: PPUSH
16034: LD_INT 26
16036: PUSH
16037: LD_INT 1
16039: PUSH
16040: EMPTY
16041: LIST
16042: LIST
16043: PPUSH
16044: CALL_OW 72
16048: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
16049: LD_ADDR_VAR 0 2
16053: PUSH
16054: LD_EXP 41
16058: PPUSH
16059: LD_INT 26
16061: PUSH
16062: LD_INT 2
16064: PUSH
16065: EMPTY
16066: LIST
16067: LIST
16068: PPUSH
16069: CALL_OW 72
16073: ST_TO_ADDR
// if IsOk ( Kaia ) then
16074: LD_EXP 32
16078: PPUSH
16079: CALL_OW 302
16083: IFFALSE 16104
// speaker := [ Kaia , DK ] else
16085: LD_ADDR_VAR 0 3
16089: PUSH
16090: LD_EXP 32
16094: PUSH
16095: LD_STRING DK
16097: PUSH
16098: EMPTY
16099: LIST
16100: LIST
16101: ST_TO_ADDR
16102: GO 16184
// if randomMen then
16104: LD_VAR 0 1
16108: IFFALSE 16143
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
16110: LD_ADDR_VAR 0 3
16114: PUSH
16115: LD_VAR 0 1
16119: PUSH
16120: LD_INT 1
16122: PPUSH
16123: LD_VAR 0 1
16127: PPUSH
16128: CALL_OW 12
16132: ARRAY
16133: PUSH
16134: LD_STRING DArm
16136: PUSH
16137: EMPTY
16138: LIST
16139: LIST
16140: ST_TO_ADDR
16141: GO 16184
// if randomWomen then
16143: LD_VAR 0 2
16147: IFFALSE 16182
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
16149: LD_ADDR_VAR 0 3
16153: PUSH
16154: LD_VAR 0 2
16158: PUSH
16159: LD_INT 1
16161: PPUSH
16162: LD_VAR 0 2
16166: PPUSH
16167: CALL_OW 12
16171: ARRAY
16172: PUSH
16173: LD_STRING DArf
16175: PUSH
16176: EMPTY
16177: LIST
16178: LIST
16179: ST_TO_ADDR
16180: GO 16184
// exit ;
16182: GO 16660
// if IsInUnit ( speaker [ 1 ] ) then
16184: LD_VAR 0 3
16188: PUSH
16189: LD_INT 1
16191: ARRAY
16192: PPUSH
16193: CALL_OW 310
16197: IFFALSE 16220
// place := IsInUnit ( speaker [ 1 ] ) else
16199: LD_ADDR_VAR 0 4
16203: PUSH
16204: LD_VAR 0 3
16208: PUSH
16209: LD_INT 1
16211: ARRAY
16212: PPUSH
16213: CALL_OW 310
16217: ST_TO_ADDR
16218: GO 16234
// place := speaker [ 1 ] ;
16220: LD_ADDR_VAR 0 4
16224: PUSH
16225: LD_VAR 0 3
16229: PUSH
16230: LD_INT 1
16232: ARRAY
16233: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
16234: LD_VAR 0 4
16238: PPUSH
16239: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
16243: LD_VAR 0 4
16247: PPUSH
16248: CALL_OW 250
16252: PPUSH
16253: LD_VAR 0 4
16257: PPUSH
16258: CALL_OW 251
16262: PPUSH
16263: CALL 3070 0 2
// wait ( 0 0$2 ) ;
16267: LD_INT 70
16269: PPUSH
16270: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
16274: LD_EXP 37
16278: PPUSH
16279: CALL_OW 305
16283: NOT
16284: IFFALSE 16288
// exit ;
16286: GO 16660
// allowConvoys := false ;
16288: LD_ADDR_EXP 12
16292: PUSH
16293: LD_INT 0
16295: ST_TO_ADDR
// InGameOn ;
16296: CALL_OW 8
// wait ( 0 0$1 ) ;
16300: LD_INT 35
16302: PPUSH
16303: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
16307: LD_EXP 37
16311: PPUSH
16312: LD_STRING DI-1-land
16314: PPUSH
16315: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
16319: LD_VAR 0 3
16323: PUSH
16324: LD_INT 1
16326: ARRAY
16327: PPUSH
16328: CALL_OW 310
16332: IFFALSE 16347
// ComExit ( speaker [ 1 ] ) ;
16334: LD_VAR 0 3
16338: PUSH
16339: LD_INT 1
16341: ARRAY
16342: PPUSH
16343: CALL 1132 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
16347: LD_VAR 0 3
16351: PUSH
16352: LD_INT 1
16354: ARRAY
16355: PPUSH
16356: LD_EXP 37
16360: PPUSH
16361: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
16365: LD_VAR 0 3
16369: PUSH
16370: LD_INT 1
16372: ARRAY
16373: PPUSH
16374: LD_EXP 37
16378: PPUSH
16379: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
16383: LD_EXP 37
16387: PPUSH
16388: LD_VAR 0 3
16392: PUSH
16393: LD_INT 1
16395: ARRAY
16396: PPUSH
16397: CALL_OW 119
// wait ( 0 0$1 ) ;
16401: LD_INT 35
16403: PPUSH
16404: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
16408: LD_VAR 0 3
16412: PUSH
16413: LD_INT 1
16415: ARRAY
16416: PPUSH
16417: LD_VAR 0 3
16421: PUSH
16422: LD_INT 2
16424: ARRAY
16425: PUSH
16426: LD_STRING -1-land
16428: STR
16429: PPUSH
16430: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16434: LD_EXP 37
16438: PPUSH
16439: LD_STRING DI-2-land
16441: PPUSH
16442: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16446: LD_VAR 0 3
16450: PUSH
16451: LD_INT 1
16453: ARRAY
16454: PPUSH
16455: LD_VAR 0 3
16459: PUSH
16460: LD_INT 2
16462: ARRAY
16463: PUSH
16464: LD_STRING -2-land
16466: STR
16467: PPUSH
16468: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16472: LD_VAR 0 3
16476: PUSH
16477: LD_INT 1
16479: ARRAY
16480: PPUSH
16481: LD_VAR 0 3
16485: PUSH
16486: LD_INT 2
16488: ARRAY
16489: PUSH
16490: LD_STRING -3-land
16492: STR
16493: PPUSH
16494: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16498: LD_EXP 27
16502: PPUSH
16503: LD_STRING DH-1-land
16505: PPUSH
16506: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16510: LD_VAR 0 5
16514: PPUSH
16515: CALL_OW 313
16519: PUSH
16520: LD_INT 6
16522: EQUAL
16523: IFFALSE 16543
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16525: LD_VAR 0 5
16529: PPUSH
16530: CALL_OW 313
16534: PUSH
16535: LD_INT 1
16537: ARRAY
16538: PPUSH
16539: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16543: LD_EXP 37
16547: PPUSH
16548: LD_INT 2
16550: PPUSH
16551: CALL_OW 235
// CenterOnUnits ( depot ) ;
16555: LD_VAR 0 5
16559: PPUSH
16560: CALL_OW 85
// ComEnterUnit ( Ibrahim , depot ) ;
16564: LD_EXP 37
16568: PPUSH
16569: LD_VAR 0 5
16573: PPUSH
16574: CALL_OW 120
// ComEnterUnit ( speaker [ 1 ] , depot ) ;
16578: LD_VAR 0 3
16582: PUSH
16583: LD_INT 1
16585: ARRAY
16586: PPUSH
16587: LD_VAR 0 5
16591: PPUSH
16592: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
16596: LD_INT 35
16598: PPUSH
16599: CALL_OW 67
// until IsInUnit ( Ibrahim ) or not IsOk ( Ibrahim ) ;
16603: LD_EXP 37
16607: PPUSH
16608: CALL_OW 310
16612: PUSH
16613: LD_EXP 37
16617: PPUSH
16618: CALL_OW 302
16622: NOT
16623: OR
16624: IFFALSE 16596
// InGameOff ;
16626: CALL_OW 9
// if not IsOk ( Ibrahim ) then
16630: LD_EXP 37
16634: PPUSH
16635: CALL_OW 302
16639: NOT
16640: IFFALSE 16644
// exit ;
16642: GO 16660
// ibrahimInDepot := true ;
16644: LD_ADDR_EXP 24
16648: PUSH
16649: LD_INT 1
16651: ST_TO_ADDR
// allowConvoys := true ;
16652: LD_ADDR_EXP 12
16656: PUSH
16657: LD_INT 1
16659: ST_TO_ADDR
// end ;
16660: PPOPN 5
16662: END
// export function IbrahimQuery ; begin
16663: LD_INT 0
16665: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16666: LD_STRING IbrahimQuery
16668: PPUSH
16669: CALL_OW 97
16673: PUSH
16674: LD_INT 1
16676: DOUBLE
16677: EQUAL
16678: IFTRUE 16682
16680: GO 16964
16682: POP
// begin allowConvoys := false ;
16683: LD_ADDR_EXP 12
16687: PUSH
16688: LD_INT 0
16690: ST_TO_ADDR
// ibrahimInDepot := false ;
16691: LD_ADDR_EXP 24
16695: PUSH
16696: LD_INT 0
16698: ST_TO_ADDR
// InGameOn ;
16699: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16703: LD_EXP 27
16707: PPUSH
16708: CALL_OW 87
// wait ( 0 0$1 ) ;
16712: LD_INT 35
16714: PPUSH
16715: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16719: LD_EXP 27
16723: PPUSH
16724: LD_STRING DH-1-interrogation
16726: PPUSH
16727: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16731: LD_EXP 37
16735: PPUSH
16736: LD_STRING DI-1-interrogation
16738: PPUSH
16739: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16743: LD_EXP 27
16747: PPUSH
16748: LD_STRING DH-2-interrogation
16750: PPUSH
16751: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16755: LD_EXP 37
16759: PPUSH
16760: LD_STRING DI-2-interrogation
16762: PPUSH
16763: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16767: LD_EXP 27
16771: PPUSH
16772: LD_STRING DH-3-interrogation
16774: PPUSH
16775: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16779: LD_EXP 37
16783: PPUSH
16784: LD_STRING DI-3-interrogation
16786: PPUSH
16787: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16791: LD_EXP 27
16795: PPUSH
16796: LD_STRING DH-4-interrogation
16798: PPUSH
16799: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16803: LD_EXP 37
16807: PPUSH
16808: LD_STRING DI-4-interrogation
16810: PPUSH
16811: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16815: LD_EXP 27
16819: PPUSH
16820: LD_STRING DH-5-interrogation
16822: PPUSH
16823: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16827: LD_EXP 37
16831: PPUSH
16832: LD_STRING DI-5-interrogation
16834: PPUSH
16835: CALL_OW 88
// wait ( 0 0$1 ) ;
16839: LD_INT 35
16841: PPUSH
16842: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16846: LD_STRING IbrahimDecisionQuery
16848: PPUSH
16849: CALL_OW 97
16853: PUSH
16854: LD_INT 1
16856: DOUBLE
16857: EQUAL
16858: IFTRUE 16862
16860: GO 16886
16862: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16863: LD_EXP 37
16867: PPUSH
16868: LD_STRING DI-1-kill
16870: PPUSH
16871: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16875: LD_EXP 37
16879: PPUSH
16880: CALL_OW 66
// end ; 2 :
16884: GO 16958
16886: LD_INT 2
16888: DOUBLE
16889: EQUAL
16890: IFTRUE 16894
16892: GO 16957
16894: POP
// begin SetSide ( Ibrahim , 6 ) ;
16895: LD_EXP 37
16899: PPUSH
16900: LD_INT 6
16902: PPUSH
16903: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16907: LD_EXP 37
16911: PPUSH
16912: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16916: LD_EXP 37
16920: PPUSH
16921: LD_INT 32
16923: PPUSH
16924: LD_INT 5
16926: PPUSH
16927: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16931: LD_EXP 27
16935: PPUSH
16936: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16940: LD_EXP 27
16944: PPUSH
16945: LD_INT 36
16947: PPUSH
16948: LD_INT 21
16950: PPUSH
16951: CALL_OW 171
// end ; end ;
16955: GO 16958
16957: POP
// InGameOff ;
16958: CALL_OW 9
// end ; 2 :
16962: GO 16978
16964: LD_INT 2
16966: DOUBLE
16967: EQUAL
16968: IFTRUE 16972
16970: GO 16977
16972: POP
// exit ; end ;
16973: GO 17016
16975: GO 16978
16977: POP
// allowConvoys := true ;
16978: LD_ADDR_EXP 12
16982: PUSH
16983: LD_INT 1
16985: ST_TO_ADDR
// wait ( 2 2$40 ) ;
16986: LD_INT 5600
16988: PPUSH
16989: CALL_OW 67
// ComMoveXY ( Ibrahim , 38 , 28 ) ;
16993: LD_EXP 37
16997: PPUSH
16998: LD_INT 38
17000: PPUSH
17001: LD_INT 28
17003: PPUSH
17004: CALL_OW 111
// ibrahimIsFree := true ;
17008: LD_ADDR_EXP 25
17012: PUSH
17013: LD_INT 1
17015: ST_TO_ADDR
// end ;
17016: LD_VAR 0 1
17020: RET
// every 0 0$1 trigger ibrahimIsFree and IsOk ( Ibrahim ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b , p , depot ;
17021: LD_EXP 25
17025: PUSH
17026: LD_EXP 37
17030: PPUSH
17031: CALL_OW 302
17035: AND
17036: PUSH
17037: LD_INT 22
17039: PUSH
17040: LD_INT 2
17042: PUSH
17043: EMPTY
17044: LIST
17045: LIST
17046: PUSH
17047: LD_INT 50
17049: PUSH
17050: EMPTY
17051: LIST
17052: PUSH
17053: LD_INT 30
17055: PUSH
17056: LD_INT 0
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: PUSH
17063: EMPTY
17064: LIST
17065: LIST
17066: LIST
17067: PPUSH
17068: CALL_OW 69
17072: AND
17073: PUSH
17074: LD_EXP 37
17078: PPUSH
17079: LD_INT 7
17081: PPUSH
17082: CALL_OW 308
17086: AND
17087: PUSH
17088: LD_INT 6
17090: PPUSH
17091: LD_EXP 27
17095: PPUSH
17096: CALL_OW 292
17100: AND
17101: PUSH
17102: LD_INT 22
17104: PUSH
17105: LD_INT 4
17107: PUSH
17108: EMPTY
17109: LIST
17110: LIST
17111: PPUSH
17112: CALL_OW 69
17116: NOT
17117: AND
17118: PUSH
17119: LD_INT 22
17121: PUSH
17122: LD_INT 1
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: PUSH
17129: LD_INT 21
17131: PUSH
17132: LD_INT 1
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: PPUSH
17143: CALL_OW 69
17147: NOT
17148: AND
17149: IFFALSE 17804
17151: GO 17153
17153: DISABLE
17154: LD_INT 0
17156: PPUSH
17157: PPUSH
17158: PPUSH
17159: PPUSH
// begin allowConvoys := false ;
17160: LD_ADDR_EXP 12
17164: PUSH
17165: LD_INT 0
17167: ST_TO_ADDR
// depot := usDepot ;
17168: LD_ADDR_VAR 0 4
17172: PUSH
17173: LD_INT 11
17175: ST_TO_ADDR
// if not usDepot then
17176: LD_INT 11
17178: NOT
17179: IFFALSE 17226
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
17181: LD_ADDR_VAR 0 4
17185: PUSH
17186: LD_INT 22
17188: PUSH
17189: LD_INT 2
17191: PUSH
17192: EMPTY
17193: LIST
17194: LIST
17195: PUSH
17196: LD_INT 50
17198: PUSH
17199: EMPTY
17200: LIST
17201: PUSH
17202: LD_INT 30
17204: PUSH
17205: LD_INT 0
17207: PUSH
17208: EMPTY
17209: LIST
17210: LIST
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: PPUSH
17217: CALL_OW 69
17221: PUSH
17222: LD_INT 1
17224: ARRAY
17225: ST_TO_ADDR
// InGameOn ;
17226: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
17230: LD_EXP 37
17234: PPUSH
17235: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
17239: LD_EXP 27
17243: PPUSH
17244: LD_EXP 37
17248: PPUSH
17249: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
17253: LD_EXP 37
17257: PPUSH
17258: LD_EXP 27
17262: PPUSH
17263: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
17267: LD_EXP 37
17271: PPUSH
17272: LD_STRING DI-1-free
17274: PPUSH
17275: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
17279: LD_EXP 27
17283: PPUSH
17284: LD_STRING DH-1-free
17286: PPUSH
17287: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
17291: LD_EXP 37
17295: PPUSH
17296: LD_STRING DI-2-free
17298: PPUSH
17299: CALL_OW 88
// changeClass := 0 ;
17303: LD_ADDR_VAR 0 1
17307: PUSH
17308: LD_INT 0
17310: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
17311: LD_STRING IbrahimJoinQuery
17313: PPUSH
17314: CALL_OW 97
17318: PUSH
17319: LD_INT 1
17321: DOUBLE
17322: EQUAL
17323: IFTRUE 17327
17325: GO 17338
17327: POP
// begin changeClass := 1 ;
17328: LD_ADDR_VAR 0 1
17332: PUSH
17333: LD_INT 1
17335: ST_TO_ADDR
// end ; 2 :
17336: GO 17578
17338: LD_INT 2
17340: DOUBLE
17341: EQUAL
17342: IFTRUE 17346
17344: GO 17498
17346: POP
// begin Say ( Heike , DH-1-decline ) ;
17347: LD_EXP 27
17351: PPUSH
17352: LD_STRING DH-1-decline
17354: PPUSH
17355: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
17359: LD_EXP 37
17363: PPUSH
17364: LD_STRING DI-1-decline
17366: PPUSH
17367: CALL_OW 88
// InGameOff ;
17371: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
17375: LD_EXP 37
17379: PPUSH
17380: LD_INT 30
17382: PPUSH
17383: LD_INT 1
17385: PPUSH
17386: CALL_OW 111
// p := 0 ;
17390: LD_ADDR_VAR 0 3
17394: PUSH
17395: LD_INT 0
17397: ST_TO_ADDR
// repeat p := p + 1 ;
17398: LD_ADDR_VAR 0 3
17402: PUSH
17403: LD_VAR 0 3
17407: PUSH
17408: LD_INT 1
17410: PLUS
17411: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17412: LD_INT 35
17414: PPUSH
17415: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) or p > 10 ;
17419: LD_EXP 37
17423: PPUSH
17424: LD_INT 30
17426: PPUSH
17427: LD_INT 1
17429: PPUSH
17430: CALL_OW 307
17434: PUSH
17435: LD_INT 22
17437: PUSH
17438: LD_INT 2
17440: PUSH
17441: EMPTY
17442: LIST
17443: LIST
17444: PUSH
17445: LD_INT 101
17447: PUSH
17448: LD_INT 6
17450: PUSH
17451: EMPTY
17452: LIST
17453: LIST
17454: PUSH
17455: EMPTY
17456: LIST
17457: LIST
17458: PPUSH
17459: CALL_OW 69
17463: NOT
17464: OR
17465: PUSH
17466: LD_VAR 0 3
17470: PUSH
17471: LD_INT 10
17473: GREATER
17474: OR
17475: IFFALSE 17398
// RemoveUnit ( Ibrahim ) ;
17477: LD_EXP 37
17481: PPUSH
17482: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17486: LD_INT 1
17488: PPUSH
17489: LD_STRING 03_IbrahimHasEscaped
17491: PPUSH
17492: CALL_OW 39
// end ; 3 :
17496: GO 17578
17498: LD_INT 3
17500: DOUBLE
17501: EQUAL
17502: IFTRUE 17506
17504: GO 17577
17506: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17507: LD_EXP 27
17511: PPUSH
17512: LD_STRING DH-1-radio-hq
17514: PPUSH
17515: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17519: LD_EXP 36
17523: PPUSH
17524: LD_STRING DO-1-radio-hq
17526: PPUSH
17527: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17531: LD_EXP 27
17535: PPUSH
17536: LD_STRING DH-2-radio-hq
17538: PPUSH
17539: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17543: LD_EXP 36
17547: PPUSH
17548: LD_STRING DO-2-radio-hq
17550: PPUSH
17551: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17555: LD_EXP 27
17559: PPUSH
17560: LD_STRING DH-3-radio-hq
17562: PPUSH
17563: CALL_OW 88
// changeClass := 1 ;
17567: LD_ADDR_VAR 0 1
17571: PUSH
17572: LD_INT 1
17574: ST_TO_ADDR
// end ; end ;
17575: GO 17578
17577: POP
// if changeClass then
17578: LD_VAR 0 1
17582: IFFALSE 17804
// begin Say ( Heike , DH-1-agree ) ;
17584: LD_EXP 27
17588: PPUSH
17589: LD_STRING DH-1-agree
17591: PPUSH
17592: CALL_OW 88
// if IsOk ( Givi ) then
17596: LD_EXP 28
17600: PPUSH
17601: CALL_OW 302
17605: IFFALSE 17643
// begin Say ( Givi , DG-1-agree ) ;
17607: LD_EXP 28
17611: PPUSH
17612: LD_STRING DG-1-agree
17614: PPUSH
17615: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17619: LD_EXP 27
17623: PPUSH
17624: LD_STRING DH-2-agree
17626: PPUSH
17627: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17631: LD_EXP 28
17635: PPUSH
17636: LD_STRING DG-2-agree
17638: PPUSH
17639: CALL_OW 88
// end ; if UnitsInside ( depot ) = 6 then
17643: LD_VAR 0 4
17647: PPUSH
17648: CALL_OW 313
17652: PUSH
17653: LD_INT 6
17655: EQUAL
17656: IFFALSE 17676
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
17658: LD_VAR 0 4
17662: PPUSH
17663: CALL_OW 313
17667: PUSH
17668: LD_INT 1
17670: ARRAY
17671: PPUSH
17672: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17676: LD_EXP 37
17680: PPUSH
17681: LD_INT 2
17683: PPUSH
17684: CALL_OW 235
// ComEnterUnit ( Ibrahim , depot ) ;
17688: LD_EXP 37
17692: PPUSH
17693: LD_VAR 0 4
17697: PPUSH
17698: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17702: LD_INT 35
17704: PPUSH
17705: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17709: LD_EXP 37
17713: PPUSH
17714: CALL_OW 310
17718: IFFALSE 17702
// b := IsInUnit ( Ibrahim ) ;
17720: LD_ADDR_VAR 0 2
17724: PUSH
17725: LD_EXP 37
17729: PPUSH
17730: CALL_OW 310
17734: ST_TO_ADDR
// RemoveUnit ( Ibrahim ) ;
17735: LD_EXP 37
17739: PPUSH
17740: CALL_OW 64
// uc_side := 2 ;
17744: LD_ADDR_OWVAR 20
17748: PUSH
17749: LD_INT 2
17751: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17752: LD_ADDR_EXP 37
17756: PUSH
17757: LD_STRING Ibrahim
17759: PPUSH
17760: LD_INT 0
17762: PPUSH
17763: LD_STRING 
17765: PPUSH
17766: CALL 305 0 3
17770: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , b ) ;
17771: LD_EXP 37
17775: PPUSH
17776: LD_VAR 0 2
17780: PPUSH
17781: CALL_OW 52
// InGameOff ;
17785: CALL_OW 9
// allowConvoys := true ;
17789: LD_ADDR_EXP 12
17793: PUSH
17794: LD_INT 1
17796: ST_TO_ADDR
// SetAchievement ( ACH_IBRAHIM ) ;
17797: LD_STRING ACH_IBRAHIM
17799: PPUSH
17800: CALL_OW 543
// end ; end ;
17804: PPOPN 4
17806: END
// every 0 0$1 trigger GetLives ( Kaia ) < 3 do
17807: LD_EXP 32
17811: PPUSH
17812: CALL_OW 256
17816: PUSH
17817: LD_INT 3
17819: LESS
17820: IFFALSE 17887
17822: GO 17824
17824: DISABLE
// begin DialogueOn ;
17825: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
17829: LD_EXP 32
17833: PPUSH
17834: CALL_OW 87
// ForceSay ( Kaia , DK-keydeath-1 ) ;
17838: LD_EXP 32
17842: PPUSH
17843: LD_STRING DK-keydeath-1
17845: PPUSH
17846: CALL_OW 91
// Say ( Heike , DH-keydeath-2 ) ;
17850: LD_EXP 27
17854: PPUSH
17855: LD_STRING DH-keydeath-2
17857: PPUSH
17858: CALL_OW 88
// Say ( Heike , DH-keydeath-3 ) ;
17862: LD_EXP 27
17866: PPUSH
17867: LD_STRING DH-keydeath-3
17869: PPUSH
17870: CALL_OW 88
// DialogueOff ;
17874: CALL_OW 7
// KillUnit ( Kaia ) ;
17878: LD_EXP 32
17882: PPUSH
17883: CALL_OW 66
// end ;
17887: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 do
17888: LD_EXP 11
17892: PUSH
17893: LD_EXP 20
17897: PUSH
17898: LD_INT 1
17900: LESS
17901: AND
17902: PUSH
17903: LD_INT 22
17905: PUSH
17906: LD_INT 1
17908: PUSH
17909: EMPTY
17910: LIST
17911: LIST
17912: PUSH
17913: LD_INT 25
17915: PUSH
17916: LD_INT 1
17918: PUSH
17919: EMPTY
17920: LIST
17921: LIST
17922: PUSH
17923: EMPTY
17924: LIST
17925: LIST
17926: PPUSH
17927: CALL_OW 69
17931: PUSH
17932: LD_INT 0
17934: EQUAL
17935: AND
17936: IFFALSE 18327
17938: GO 17940
17940: DISABLE
// begin DialogueOn ;
17941: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
17945: LD_EXP 27
17949: PPUSH
17950: LD_STRING DH-1-final
17952: PPUSH
17953: CALL_OW 88
// if tick <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
17957: LD_OWVAR 1
17961: PUSH
17962: LD_INT 126000
17964: PUSH
17965: LD_INT 115500
17967: PUSH
17968: LD_INT 105000
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: LIST
17975: PUSH
17976: LD_OWVAR 67
17980: ARRAY
17981: LESSEQUAL
17982: IFFALSE 17996
// AddMedal ( med1 , 1 ) else
17984: LD_STRING med1
17986: PPUSH
17987: LD_INT 1
17989: PPUSH
17990: CALL_OW 101
17994: GO 18007
// AddMedal ( med1 , - 1 ) ;
17996: LD_STRING med1
17998: PPUSH
17999: LD_INT 1
18001: NEG
18002: PPUSH
18003: CALL_OW 101
// if vehCounter >= 2 then
18007: LD_EXP 21
18011: PUSH
18012: LD_INT 2
18014: GREATEREQUAL
18015: IFFALSE 18029
// AddMedal ( med2 , 1 ) else
18017: LD_STRING med2
18019: PPUSH
18020: LD_INT 1
18022: PPUSH
18023: CALL_OW 101
18027: GO 18040
// AddMedal ( med2 , - 1 ) ;
18029: LD_STRING med2
18031: PPUSH
18032: LD_INT 1
18034: NEG
18035: PPUSH
18036: CALL_OW 101
// if deadCounter = 0 then
18040: LD_EXP 9
18044: PUSH
18045: LD_INT 0
18047: EQUAL
18048: IFFALSE 18062
// AddMedal ( med3 , 1 ) else
18050: LD_STRING med3
18052: PPUSH
18053: LD_INT 1
18055: PPUSH
18056: CALL_OW 101
18060: GO 18073
// AddMedal ( med3 , - 1 ) ;
18062: LD_STRING med3
18064: PPUSH
18065: LD_INT 1
18067: NEG
18068: PPUSH
18069: CALL_OW 101
// GiveMedals ( MAIN ) ;
18073: LD_STRING MAIN
18075: PPUSH
18076: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
18080: LD_INT 22
18082: PUSH
18083: LD_INT 2
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: PUSH
18090: LD_INT 23
18092: PUSH
18093: LD_INT 2
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: PUSH
18100: LD_INT 21
18102: PUSH
18103: LD_INT 1
18105: PUSH
18106: EMPTY
18107: LIST
18108: LIST
18109: PUSH
18110: EMPTY
18111: LIST
18112: LIST
18113: LIST
18114: PPUSH
18115: CALL_OW 69
18119: PPUSH
18120: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
18124: LD_EXP 27
18128: PPUSH
18129: LD_STRING 03_Heike
18131: PPUSH
18132: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
18136: LD_EXP 31
18140: PPUSH
18141: LD_STRING 03_Aviradze
18143: PPUSH
18144: CALL_OW 38
// if Givi then
18148: LD_EXP 28
18152: IFFALSE 18166
// SaveCharacters ( Givi , 03_Givi ) ;
18154: LD_EXP 28
18158: PPUSH
18159: LD_STRING 03_Givi
18161: PPUSH
18162: CALL_OW 38
// if Mike then
18166: LD_EXP 29
18170: IFFALSE 18184
// SaveCharacters ( Mike , 03_Mike ) ;
18172: LD_EXP 29
18176: PPUSH
18177: LD_STRING 03_Mike
18179: PPUSH
18180: CALL_OW 38
// if Kamil then
18184: LD_EXP 30
18188: IFFALSE 18202
// SaveCharacters ( Kamil , 03_Kamil ) ;
18190: LD_EXP 30
18194: PPUSH
18195: LD_STRING 03_Kamil
18197: PPUSH
18198: CALL_OW 38
// if Kaia then
18202: LD_EXP 32
18206: IFFALSE 18220
// SaveCharacters ( Kaia , 03_Kaia ) ;
18208: LD_EXP 32
18212: PPUSH
18213: LD_STRING 03_Kaia
18215: PPUSH
18216: CALL_OW 38
// if Sophia then
18220: LD_EXP 33
18224: IFFALSE 18238
// SaveCharacters ( Sophia , 03_Sophia ) ;
18226: LD_EXP 33
18230: PPUSH
18231: LD_STRING 03_Sophia
18233: PPUSH
18234: CALL_OW 38
// if Markov then
18238: LD_EXP 34
18242: IFFALSE 18256
// SaveCharacters ( Markov , 03_Markov ) ;
18244: LD_EXP 34
18248: PPUSH
18249: LD_STRING 03_Markov
18251: PPUSH
18252: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
18256: LD_EXP 37
18260: PUSH
18261: LD_EXP 37
18265: PPUSH
18266: CALL_OW 255
18270: PUSH
18271: LD_INT 2
18273: EQUAL
18274: AND
18275: IFFALSE 18289
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
18277: LD_EXP 37
18281: PPUSH
18282: LD_STRING 03_Ibrahim
18284: PPUSH
18285: CALL_OW 38
// if heikeSecondSquad then
18289: LD_EXP 41
18293: IFFALSE 18307
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
18295: LD_EXP 41
18299: PPUSH
18300: LD_STRING 03_others
18302: PPUSH
18303: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
18307: LD_EXP 9
18311: PPUSH
18312: LD_STRING 03_DeadCounter
18314: PPUSH
18315: CALL_OW 39
// YouWin ;
18319: CALL_OW 103
// DialogueOff ;
18323: CALL_OW 7
// end ; end_of_file
18327: END
// on UnitDestroyed ( un ) do begin if un = Heike then
18328: LD_VAR 0 1
18332: PUSH
18333: LD_EXP 27
18337: EQUAL
18338: IFFALSE 18347
// YouLost ( Heike ) ;
18340: LD_STRING Heike
18342: PPUSH
18343: CALL_OW 104
// if un = Aviradze then
18347: LD_VAR 0 1
18351: PUSH
18352: LD_EXP 31
18356: EQUAL
18357: IFFALSE 18366
// YouLost ( Aviradze ) ;
18359: LD_STRING Aviradze
18361: PPUSH
18362: CALL_OW 104
// if un = usDepot and not retreatAllowed then
18366: LD_VAR 0 1
18370: PUSH
18371: LD_INT 11
18373: EQUAL
18374: PUSH
18375: LD_EXP 11
18379: NOT
18380: AND
18381: IFFALSE 18390
// YouLost ( Depot ) ;
18383: LD_STRING Depot
18385: PPUSH
18386: CALL_OW 104
// if un = arDepot then
18390: LD_VAR 0 1
18394: PUSH
18395: LD_INT 5
18397: EQUAL
18398: IFFALSE 18407
// YouLost ( FarmerDepot ) ;
18400: LD_STRING FarmerDepot
18402: PPUSH
18403: CALL_OW 104
// if un = Farmer then
18407: LD_VAR 0 1
18411: PUSH
18412: LD_EXP 35
18416: EQUAL
18417: IFFALSE 18426
// YouLost ( Farmer ) ;
18419: LD_STRING Farmer
18421: PPUSH
18422: CALL_OW 104
// if un in usForces then
18426: LD_VAR 0 1
18430: PUSH
18431: LD_EXP 43
18435: IN
18436: IFFALSE 18454
// usForces := usForces diff un ;
18438: LD_ADDR_EXP 43
18442: PUSH
18443: LD_EXP 43
18447: PUSH
18448: LD_VAR 0 1
18452: DIFF
18453: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
18454: LD_VAR 0 1
18458: PUSH
18459: LD_INT 22
18461: PUSH
18462: LD_INT 2
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: PUSH
18469: LD_INT 23
18471: PUSH
18472: LD_INT 2
18474: PUSH
18475: EMPTY
18476: LIST
18477: LIST
18478: PUSH
18479: LD_INT 21
18481: PUSH
18482: LD_INT 1
18484: PUSH
18485: EMPTY
18486: LIST
18487: LIST
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: LIST
18493: PPUSH
18494: CALL_OW 69
18498: IN
18499: IFFALSE 18515
// deadCounter := deadCounter + 1 ;
18501: LD_ADDR_EXP 9
18505: PUSH
18506: LD_EXP 9
18510: PUSH
18511: LD_INT 1
18513: PLUS
18514: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
18515: LD_VAR 0 1
18519: PUSH
18520: LD_INT 22
18522: PUSH
18523: LD_INT 4
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PUSH
18530: LD_INT 34
18532: PUSH
18533: LD_INT 12
18535: PUSH
18536: EMPTY
18537: LIST
18538: LIST
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: PPUSH
18544: CALL_OW 69
18548: IN
18549: PUSH
18550: LD_EXP 17
18554: NOT
18555: AND
18556: IFFALSE 18566
// firstConvoyDestroyed := true ;
18558: LD_ADDR_EXP 17
18562: PUSH
18563: LD_INT 1
18565: ST_TO_ADDR
// if un in usAttackers then
18566: LD_VAR 0 1
18570: PUSH
18571: LD_EXP 46
18575: IN
18576: IFFALSE 18594
// usAttackers := usAttackers diff un ;
18578: LD_ADDR_EXP 46
18582: PUSH
18583: LD_EXP 46
18587: PUSH
18588: LD_VAR 0 1
18592: DIFF
18593: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) then
18594: LD_VAR 0 1
18598: PUSH
18599: LD_INT 22
18601: PUSH
18602: LD_INT 5
18604: PUSH
18605: EMPTY
18606: LIST
18607: LIST
18608: PUSH
18609: LD_INT 21
18611: PUSH
18612: LD_INT 1
18614: PUSH
18615: EMPTY
18616: LIST
18617: LIST
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: PPUSH
18623: CALL_OW 69
18627: IN
18628: IFFALSE 18644
// farmerHumanLoseCounter := farmerHumanLoseCounter + 1 ;
18630: LD_ADDR_EXP 19
18634: PUSH
18635: LD_EXP 19
18639: PUSH
18640: LD_INT 1
18642: PLUS
18643: ST_TO_ADDR
// end ;
18644: PPOPN 1
18646: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18647: LD_VAR 0 2
18651: PUSH
18652: LD_EXP 37
18656: EQUAL
18657: PUSH
18658: LD_EXP 24
18662: AND
18663: IFFALSE 18709
// begin Video ( true ) ;
18665: LD_INT 1
18667: PPUSH
18668: CALL 1028 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
18672: LD_EXP 37
18676: PPUSH
18677: LD_INT 11
18679: PPUSH
18680: CALL_OW 120
// repeat wait ( 3 ) ;
18684: LD_INT 3
18686: PPUSH
18687: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18691: LD_EXP 37
18695: PPUSH
18696: CALL_OW 310
18700: IFFALSE 18684
// Video ( false ) ;
18702: LD_INT 0
18704: PPUSH
18705: CALL 1028 0 1
// end ; end ;
18709: PPOPN 2
18711: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
18712: LD_VAR 0 2
18716: PUSH
18717: LD_EXP 27
18721: EQUAL
18722: PUSH
18723: LD_VAR 0 1
18727: PUSH
18728: LD_INT 11
18730: EQUAL
18731: AND
18732: PUSH
18733: LD_EXP 24
18737: AND
18738: IFFALSE 18744
// IbrahimQuery ;
18740: CALL 16663 0 0
// end ;
18744: PPOPN 2
18746: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin ComStop ( newId ) ;
18747: LD_VAR 0 1
18751: PPUSH
18752: CALL_OW 141
// if oldId in usAttackers then
18756: LD_VAR 0 2
18760: PUSH
18761: LD_EXP 46
18765: IN
18766: IFFALSE 18784
// usAttackers := usAttackers diff oldId ;
18768: LD_ADDR_EXP 46
18772: PUSH
18773: LD_EXP 46
18777: PUSH
18778: LD_VAR 0 2
18782: DIFF
18783: ST_TO_ADDR
// if newId in usAttackers then
18784: LD_VAR 0 1
18788: PUSH
18789: LD_EXP 46
18793: IN
18794: IFFALSE 18812
// usAttackers := usAttackers diff newId ;
18796: LD_ADDR_EXP 46
18800: PUSH
18801: LD_EXP 46
18805: PUSH
18806: LD_VAR 0 1
18810: DIFF
18811: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
18812: LD_VAR 0 3
18816: PUSH
18817: LD_INT 4
18819: EQUAL
18820: PUSH
18821: LD_EXP 17
18825: NOT
18826: AND
18827: IFFALSE 18837
// firstConvoyDestroyed := true ;
18829: LD_ADDR_EXP 17
18833: PUSH
18834: LD_INT 1
18836: ST_TO_ADDR
// if GetWeapon ( newId ) = us_cargo_bay then
18837: LD_VAR 0 1
18841: PPUSH
18842: CALL_OW 264
18846: PUSH
18847: LD_INT 12
18849: EQUAL
18850: IFFALSE 18888
// begin capturedCargoCounter := capturedCargoCounter + 1 ;
18852: LD_ADDR_EXP 13
18856: PUSH
18857: LD_EXP 13
18861: PUSH
18862: LD_INT 1
18864: PLUS
18865: ST_TO_ADDR
// if GetCargo ( newId , mat_cans ) = 0 then
18866: LD_VAR 0 1
18870: PPUSH
18871: LD_INT 1
18873: PPUSH
18874: CALL_OW 289
18878: PUSH
18879: LD_INT 0
18881: EQUAL
18882: IFFALSE 18888
// EmptyCargoDialog ;
18884: CALL 15393 0 0
// end ; end ;
18888: PPOPN 4
18890: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
18891: LD_VAR 0 1
18895: PUSH
18896: LD_INT 2
18898: EQUAL
18899: PUSH
18900: LD_VAR 0 2
18904: PUSH
18905: LD_INT 5
18907: EQUAL
18908: AND
18909: IFFALSE 18918
// YouLost ( Attack ) ;
18911: LD_STRING Attack
18913: PPUSH
18914: CALL_OW 104
// end ;
18918: PPOPN 2
18920: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 and not americanBaseCaptured then
18921: LD_VAR 0 1
18925: PPUSH
18926: CALL_OW 255
18930: PUSH
18931: LD_INT 1
18933: EQUAL
18934: PUSH
18935: LD_EXP 6
18939: NOT
18940: AND
18941: IFFALSE 19075
// begin if GetBType ( b ) = b_lab then
18943: LD_VAR 0 1
18947: PPUSH
18948: CALL_OW 266
18952: PUSH
18953: LD_INT 6
18955: EQUAL
18956: IFFALSE 18996
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
18958: LD_EXP 43
18962: PPUSH
18963: LD_INT 25
18965: PUSH
18966: LD_INT 4
18968: PUSH
18969: EMPTY
18970: LIST
18971: LIST
18972: PPUSH
18973: CALL_OW 72
18977: PPUSH
18978: LD_VAR 0 1
18982: PPUSH
18983: CALL_OW 120
// AmLabResearch ( b ) ;
18987: LD_VAR 0 1
18991: PPUSH
18992: CALL 6071 0 1
// end ; if GetBType ( b ) = b_armoury then
18996: LD_VAR 0 1
19000: PPUSH
19001: CALL_OW 266
19005: PUSH
19006: LD_INT 4
19008: EQUAL
19009: IFFALSE 19057
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
19011: LD_EXP 43
19015: PPUSH
19016: LD_INT 25
19018: PUSH
19019: LD_INT 1
19021: PUSH
19022: EMPTY
19023: LIST
19024: LIST
19025: PUSH
19026: LD_INT 3
19028: PUSH
19029: LD_INT 54
19031: PUSH
19032: EMPTY
19033: LIST
19034: PUSH
19035: EMPTY
19036: LIST
19037: LIST
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: PPUSH
19043: CALL_OW 72
19047: PPUSH
19048: LD_VAR 0 1
19052: PPUSH
19053: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
19057: LD_ADDR_EXP 45
19061: PUSH
19062: LD_EXP 45
19066: PPUSH
19067: LD_INT 1
19069: PPUSH
19070: CALL_OW 3
19074: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
19075: LD_VAR 0 1
19079: PPUSH
19080: CALL_OW 255
19084: PUSH
19085: LD_INT 5
19087: EQUAL
19088: IFFALSE 19102
// SetBLevel ( b , 5 ) ;
19090: LD_VAR 0 1
19094: PPUSH
19095: LD_INT 5
19097: PPUSH
19098: CALL_OW 241
// end ;
19102: PPOPN 1
19104: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
19105: LD_VAR 0 1
19109: PPUSH
19110: CALL_OW 255
19114: PUSH
19115: LD_INT 2
19117: EQUAL
19118: IFFALSE 19134
// vehCounter := vehCounter + 1 ;
19120: LD_ADDR_EXP 21
19124: PUSH
19125: LD_EXP 21
19129: PUSH
19130: LD_INT 1
19132: PLUS
19133: ST_TO_ADDR
// end ;
19134: PPOPN 2
19136: END
// on SailEvent ( event ) do begin if event = eventAttack then
19137: LD_VAR 0 1
19141: PUSH
19142: LD_EXP 23
19146: EQUAL
19147: IFFALSE 19153
// AmericanAttack ;
19149: CALL 7519 0 0
// end ; end_of_file
19153: PPOPN 1
19155: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 5 5$00 , 4 4$00 , 3 3$30 ] [ Difficulty ] do
19156: LD_OWVAR 1
19160: PUSH
19161: LD_INT 10500
19163: PUSH
19164: LD_INT 8400
19166: PUSH
19167: LD_INT 7350
19169: PUSH
19170: EMPTY
19171: LIST
19172: LIST
19173: LIST
19174: PUSH
19175: LD_OWVAR 67
19179: ARRAY
19180: LESSEQUAL
19181: IFFALSE 19208
19183: GO 19185
19185: DISABLE
// begin enable ;
19186: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
19187: LD_INT 1
19189: PPUSH
19190: LD_INT 5
19192: PPUSH
19193: CALL_OW 12
19197: PPUSH
19198: LD_INT 9
19200: PPUSH
19201: LD_INT 1
19203: PPUSH
19204: CALL_OW 55
// end ;
19208: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 26 26$00 , 25 25$00 , 24 24$00 ] [ Difficulty ] do
19209: LD_EXP 6
19213: PUSH
19214: LD_OWVAR 1
19218: PUSH
19219: LD_INT 54600
19221: PUSH
19222: LD_INT 52500
19224: PUSH
19225: LD_INT 50400
19227: PUSH
19228: EMPTY
19229: LIST
19230: LIST
19231: LIST
19232: PUSH
19233: LD_OWVAR 67
19237: ARRAY
19238: LESSEQUAL
19239: AND
19240: IFFALSE 19267
19242: GO 19244
19244: DISABLE
// begin enable ;
19245: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
19246: LD_INT 1
19248: PPUSH
19249: LD_INT 5
19251: PPUSH
19252: CALL_OW 12
19256: PPUSH
19257: LD_INT 9
19259: PPUSH
19260: LD_INT 1
19262: PPUSH
19263: CALL_OW 55
// end ; end_of_file
19267: END
// every 0 0$1 trigger not retreatAllowed and farmerRequestedCrates and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
19268: LD_EXP 11
19272: NOT
19273: PUSH
19274: LD_EXP 15
19278: AND
19279: PUSH
19280: LD_EXP 4
19284: AND
19285: PUSH
19286: LD_EXP 14
19290: PUSH
19291: LD_EXP 15
19295: LESSEQUAL
19296: AND
19297: IFFALSE 19387
19299: GO 19301
19301: DISABLE
// begin enable ;
19302: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
19303: LD_ADDR_OWVAR 47
19307: PUSH
19308: LD_STRING #X103-1
19310: PUSH
19311: LD_EXP 14
19315: PUSH
19316: LD_EXP 15
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: LIST
19325: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
19326: LD_ADDR_EXP 14
19330: PUSH
19331: LD_INT 5
19333: PPUSH
19334: CALL_OW 274
19338: PPUSH
19339: LD_INT 1
19341: PPUSH
19342: CALL_OW 275
19346: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
19347: LD_INT 10
19349: PPUSH
19350: LD_INT 1
19352: PPUSH
19353: CALL_OW 287
19357: PUSH
19358: LD_INT 0
19360: EQUAL
19361: IFFALSE 19379
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
19363: LD_ADDR_EXP 16
19367: PUSH
19368: LD_EXP 16
19372: PUSH
19373: LD_INT 35
19375: MINUS
19376: ST_TO_ADDR
19377: GO 19387
// farmerCratesCounter := 30 30$00 ;
19379: LD_ADDR_EXP 16
19383: PUSH
19384: LD_INT 63000
19386: ST_TO_ADDR
// end ; end_of_file
19387: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
19388: LD_INT 0
19390: PPUSH
// ar_crane := 88 ;
19391: LD_ADDR_EXP 53
19395: PUSH
19396: LD_INT 88
19398: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
19399: LD_ADDR_EXP 48
19403: PUSH
19404: LD_INT 89
19406: ST_TO_ADDR
// us_hack := 99 ;
19407: LD_ADDR_EXP 49
19411: PUSH
19412: LD_INT 99
19414: ST_TO_ADDR
// us_artillery := 97 ;
19415: LD_ADDR_EXP 50
19419: PUSH
19420: LD_INT 97
19422: ST_TO_ADDR
// ar_bio_bomb := 91 ;
19423: LD_ADDR_EXP 51
19427: PUSH
19428: LD_INT 91
19430: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
19431: LD_ADDR_EXP 52
19435: PUSH
19436: LD_INT 92
19438: ST_TO_ADDR
// ru_radar := 98 ;
19439: LD_ADDR_EXP 47
19443: PUSH
19444: LD_INT 98
19446: ST_TO_ADDR
// tech_Artillery := 80 ;
19447: LD_ADDR_EXP 54
19451: PUSH
19452: LD_INT 80
19454: ST_TO_ADDR
// tech_RadMat := 81 ;
19455: LD_ADDR_EXP 55
19459: PUSH
19460: LD_INT 81
19462: ST_TO_ADDR
// tech_BasicTools := 82 ;
19463: LD_ADDR_EXP 56
19467: PUSH
19468: LD_INT 82
19470: ST_TO_ADDR
// tech_Cargo := 83 ;
19471: LD_ADDR_EXP 57
19475: PUSH
19476: LD_INT 83
19478: ST_TO_ADDR
// tech_Track := 84 ;
19479: LD_ADDR_EXP 58
19483: PUSH
19484: LD_INT 84
19486: ST_TO_ADDR
// tech_Crane := 85 ;
19487: LD_ADDR_EXP 59
19491: PUSH
19492: LD_INT 85
19494: ST_TO_ADDR
// tech_Bulldozer := 86 ;
19495: LD_ADDR_EXP 60
19499: PUSH
19500: LD_INT 86
19502: ST_TO_ADDR
// tech_Hovercraft := 87 ;
19503: LD_ADDR_EXP 61
19507: PUSH
19508: LD_INT 87
19510: ST_TO_ADDR
// end ;
19511: LD_VAR 0 1
19515: RET
// every 1 do
19516: GO 19518
19518: DISABLE
// InitGlobalVariables ; end_of_file
19519: CALL 19388 0 0
19523: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
19524: LD_VAR 0 2
19528: PUSH
19529: LD_INT 100
19531: EQUAL
19532: IFFALSE 20481
// begin if not StreamModeActive then
19534: LD_EXP 62
19538: NOT
19539: IFFALSE 19549
// StreamModeActive := true ;
19541: LD_ADDR_EXP 62
19545: PUSH
19546: LD_INT 1
19548: ST_TO_ADDR
// if p3 = 0 then
19549: LD_VAR 0 3
19553: PUSH
19554: LD_INT 0
19556: EQUAL
19557: IFFALSE 19563
// InitStreamMode ;
19559: CALL 20714 0 0
// if p3 = 1 then
19563: LD_VAR 0 3
19567: PUSH
19568: LD_INT 1
19570: EQUAL
19571: IFFALSE 19581
// sRocket := true ;
19573: LD_ADDR_EXP 67
19577: PUSH
19578: LD_INT 1
19580: ST_TO_ADDR
// if p3 = 2 then
19581: LD_VAR 0 3
19585: PUSH
19586: LD_INT 2
19588: EQUAL
19589: IFFALSE 19599
// sSpeed := true ;
19591: LD_ADDR_EXP 66
19595: PUSH
19596: LD_INT 1
19598: ST_TO_ADDR
// if p3 = 3 then
19599: LD_VAR 0 3
19603: PUSH
19604: LD_INT 3
19606: EQUAL
19607: IFFALSE 19617
// sEngine := true ;
19609: LD_ADDR_EXP 68
19613: PUSH
19614: LD_INT 1
19616: ST_TO_ADDR
// if p3 = 4 then
19617: LD_VAR 0 3
19621: PUSH
19622: LD_INT 4
19624: EQUAL
19625: IFFALSE 19635
// sSpec := true ;
19627: LD_ADDR_EXP 65
19631: PUSH
19632: LD_INT 1
19634: ST_TO_ADDR
// if p3 = 5 then
19635: LD_VAR 0 3
19639: PUSH
19640: LD_INT 5
19642: EQUAL
19643: IFFALSE 19653
// sLevel := true ;
19645: LD_ADDR_EXP 69
19649: PUSH
19650: LD_INT 1
19652: ST_TO_ADDR
// if p3 = 6 then
19653: LD_VAR 0 3
19657: PUSH
19658: LD_INT 6
19660: EQUAL
19661: IFFALSE 19671
// sArmoury := true ;
19663: LD_ADDR_EXP 70
19667: PUSH
19668: LD_INT 1
19670: ST_TO_ADDR
// if p3 = 7 then
19671: LD_VAR 0 3
19675: PUSH
19676: LD_INT 7
19678: EQUAL
19679: IFFALSE 19689
// sRadar := true ;
19681: LD_ADDR_EXP 71
19685: PUSH
19686: LD_INT 1
19688: ST_TO_ADDR
// if p3 = 8 then
19689: LD_VAR 0 3
19693: PUSH
19694: LD_INT 8
19696: EQUAL
19697: IFFALSE 19707
// sBunker := true ;
19699: LD_ADDR_EXP 72
19703: PUSH
19704: LD_INT 1
19706: ST_TO_ADDR
// if p3 = 9 then
19707: LD_VAR 0 3
19711: PUSH
19712: LD_INT 9
19714: EQUAL
19715: IFFALSE 19725
// sHack := true ;
19717: LD_ADDR_EXP 73
19721: PUSH
19722: LD_INT 1
19724: ST_TO_ADDR
// if p3 = 10 then
19725: LD_VAR 0 3
19729: PUSH
19730: LD_INT 10
19732: EQUAL
19733: IFFALSE 19743
// sFire := true ;
19735: LD_ADDR_EXP 74
19739: PUSH
19740: LD_INT 1
19742: ST_TO_ADDR
// if p3 = 11 then
19743: LD_VAR 0 3
19747: PUSH
19748: LD_INT 11
19750: EQUAL
19751: IFFALSE 19761
// sRefresh := true ;
19753: LD_ADDR_EXP 75
19757: PUSH
19758: LD_INT 1
19760: ST_TO_ADDR
// if p3 = 12 then
19761: LD_VAR 0 3
19765: PUSH
19766: LD_INT 12
19768: EQUAL
19769: IFFALSE 19779
// sExp := true ;
19771: LD_ADDR_EXP 76
19775: PUSH
19776: LD_INT 1
19778: ST_TO_ADDR
// if p3 = 13 then
19779: LD_VAR 0 3
19783: PUSH
19784: LD_INT 13
19786: EQUAL
19787: IFFALSE 19797
// sDepot := true ;
19789: LD_ADDR_EXP 77
19793: PUSH
19794: LD_INT 1
19796: ST_TO_ADDR
// if p3 = 14 then
19797: LD_VAR 0 3
19801: PUSH
19802: LD_INT 14
19804: EQUAL
19805: IFFALSE 19815
// sFlag := true ;
19807: LD_ADDR_EXP 78
19811: PUSH
19812: LD_INT 1
19814: ST_TO_ADDR
// if p3 = 15 then
19815: LD_VAR 0 3
19819: PUSH
19820: LD_INT 15
19822: EQUAL
19823: IFFALSE 19833
// sKamikadze := true ;
19825: LD_ADDR_EXP 86
19829: PUSH
19830: LD_INT 1
19832: ST_TO_ADDR
// if p3 = 16 then
19833: LD_VAR 0 3
19837: PUSH
19838: LD_INT 16
19840: EQUAL
19841: IFFALSE 19851
// sTroll := true ;
19843: LD_ADDR_EXP 87
19847: PUSH
19848: LD_INT 1
19850: ST_TO_ADDR
// if p3 = 17 then
19851: LD_VAR 0 3
19855: PUSH
19856: LD_INT 17
19858: EQUAL
19859: IFFALSE 19869
// sSlow := true ;
19861: LD_ADDR_EXP 88
19865: PUSH
19866: LD_INT 1
19868: ST_TO_ADDR
// if p3 = 18 then
19869: LD_VAR 0 3
19873: PUSH
19874: LD_INT 18
19876: EQUAL
19877: IFFALSE 19887
// sLack := true ;
19879: LD_ADDR_EXP 89
19883: PUSH
19884: LD_INT 1
19886: ST_TO_ADDR
// if p3 = 19 then
19887: LD_VAR 0 3
19891: PUSH
19892: LD_INT 19
19894: EQUAL
19895: IFFALSE 19905
// sTank := true ;
19897: LD_ADDR_EXP 91
19901: PUSH
19902: LD_INT 1
19904: ST_TO_ADDR
// if p3 = 20 then
19905: LD_VAR 0 3
19909: PUSH
19910: LD_INT 20
19912: EQUAL
19913: IFFALSE 19923
// sRemote := true ;
19915: LD_ADDR_EXP 92
19919: PUSH
19920: LD_INT 1
19922: ST_TO_ADDR
// if p3 = 21 then
19923: LD_VAR 0 3
19927: PUSH
19928: LD_INT 21
19930: EQUAL
19931: IFFALSE 19941
// sPowell := true ;
19933: LD_ADDR_EXP 93
19937: PUSH
19938: LD_INT 1
19940: ST_TO_ADDR
// if p3 = 22 then
19941: LD_VAR 0 3
19945: PUSH
19946: LD_INT 22
19948: EQUAL
19949: IFFALSE 19959
// sTeleport := true ;
19951: LD_ADDR_EXP 96
19955: PUSH
19956: LD_INT 1
19958: ST_TO_ADDR
// if p3 = 23 then
19959: LD_VAR 0 3
19963: PUSH
19964: LD_INT 23
19966: EQUAL
19967: IFFALSE 19977
// sOilTower := true ;
19969: LD_ADDR_EXP 98
19973: PUSH
19974: LD_INT 1
19976: ST_TO_ADDR
// if p3 = 24 then
19977: LD_VAR 0 3
19981: PUSH
19982: LD_INT 24
19984: EQUAL
19985: IFFALSE 19995
// sShovel := true ;
19987: LD_ADDR_EXP 99
19991: PUSH
19992: LD_INT 1
19994: ST_TO_ADDR
// if p3 = 25 then
19995: LD_VAR 0 3
19999: PUSH
20000: LD_INT 25
20002: EQUAL
20003: IFFALSE 20013
// sSheik := true ;
20005: LD_ADDR_EXP 100
20009: PUSH
20010: LD_INT 1
20012: ST_TO_ADDR
// if p3 = 26 then
20013: LD_VAR 0 3
20017: PUSH
20018: LD_INT 26
20020: EQUAL
20021: IFFALSE 20031
// sEarthquake := true ;
20023: LD_ADDR_EXP 102
20027: PUSH
20028: LD_INT 1
20030: ST_TO_ADDR
// if p3 = 27 then
20031: LD_VAR 0 3
20035: PUSH
20036: LD_INT 27
20038: EQUAL
20039: IFFALSE 20049
// sAI := true ;
20041: LD_ADDR_EXP 103
20045: PUSH
20046: LD_INT 1
20048: ST_TO_ADDR
// if p3 = 28 then
20049: LD_VAR 0 3
20053: PUSH
20054: LD_INT 28
20056: EQUAL
20057: IFFALSE 20067
// sCargo := true ;
20059: LD_ADDR_EXP 106
20063: PUSH
20064: LD_INT 1
20066: ST_TO_ADDR
// if p3 = 29 then
20067: LD_VAR 0 3
20071: PUSH
20072: LD_INT 29
20074: EQUAL
20075: IFFALSE 20085
// sDLaser := true ;
20077: LD_ADDR_EXP 107
20081: PUSH
20082: LD_INT 1
20084: ST_TO_ADDR
// if p3 = 30 then
20085: LD_VAR 0 3
20089: PUSH
20090: LD_INT 30
20092: EQUAL
20093: IFFALSE 20103
// sExchange := true ;
20095: LD_ADDR_EXP 108
20099: PUSH
20100: LD_INT 1
20102: ST_TO_ADDR
// if p3 = 31 then
20103: LD_VAR 0 3
20107: PUSH
20108: LD_INT 31
20110: EQUAL
20111: IFFALSE 20121
// sFac := true ;
20113: LD_ADDR_EXP 109
20117: PUSH
20118: LD_INT 1
20120: ST_TO_ADDR
// if p3 = 32 then
20121: LD_VAR 0 3
20125: PUSH
20126: LD_INT 32
20128: EQUAL
20129: IFFALSE 20139
// sPower := true ;
20131: LD_ADDR_EXP 110
20135: PUSH
20136: LD_INT 1
20138: ST_TO_ADDR
// if p3 = 33 then
20139: LD_VAR 0 3
20143: PUSH
20144: LD_INT 33
20146: EQUAL
20147: IFFALSE 20157
// sRandom := true ;
20149: LD_ADDR_EXP 111
20153: PUSH
20154: LD_INT 1
20156: ST_TO_ADDR
// if p3 = 34 then
20157: LD_VAR 0 3
20161: PUSH
20162: LD_INT 34
20164: EQUAL
20165: IFFALSE 20175
// sShield := true ;
20167: LD_ADDR_EXP 112
20171: PUSH
20172: LD_INT 1
20174: ST_TO_ADDR
// if p3 = 35 then
20175: LD_VAR 0 3
20179: PUSH
20180: LD_INT 35
20182: EQUAL
20183: IFFALSE 20193
// sTime := true ;
20185: LD_ADDR_EXP 113
20189: PUSH
20190: LD_INT 1
20192: ST_TO_ADDR
// if p3 = 36 then
20193: LD_VAR 0 3
20197: PUSH
20198: LD_INT 36
20200: EQUAL
20201: IFFALSE 20211
// sTools := true ;
20203: LD_ADDR_EXP 114
20207: PUSH
20208: LD_INT 1
20210: ST_TO_ADDR
// if p3 = 101 then
20211: LD_VAR 0 3
20215: PUSH
20216: LD_INT 101
20218: EQUAL
20219: IFFALSE 20229
// sSold := true ;
20221: LD_ADDR_EXP 79
20225: PUSH
20226: LD_INT 1
20228: ST_TO_ADDR
// if p3 = 102 then
20229: LD_VAR 0 3
20233: PUSH
20234: LD_INT 102
20236: EQUAL
20237: IFFALSE 20247
// sDiff := true ;
20239: LD_ADDR_EXP 80
20243: PUSH
20244: LD_INT 1
20246: ST_TO_ADDR
// if p3 = 103 then
20247: LD_VAR 0 3
20251: PUSH
20252: LD_INT 103
20254: EQUAL
20255: IFFALSE 20265
// sFog := true ;
20257: LD_ADDR_EXP 83
20261: PUSH
20262: LD_INT 1
20264: ST_TO_ADDR
// if p3 = 104 then
20265: LD_VAR 0 3
20269: PUSH
20270: LD_INT 104
20272: EQUAL
20273: IFFALSE 20283
// sReset := true ;
20275: LD_ADDR_EXP 84
20279: PUSH
20280: LD_INT 1
20282: ST_TO_ADDR
// if p3 = 105 then
20283: LD_VAR 0 3
20287: PUSH
20288: LD_INT 105
20290: EQUAL
20291: IFFALSE 20301
// sSun := true ;
20293: LD_ADDR_EXP 85
20297: PUSH
20298: LD_INT 1
20300: ST_TO_ADDR
// if p3 = 106 then
20301: LD_VAR 0 3
20305: PUSH
20306: LD_INT 106
20308: EQUAL
20309: IFFALSE 20319
// sTiger := true ;
20311: LD_ADDR_EXP 81
20315: PUSH
20316: LD_INT 1
20318: ST_TO_ADDR
// if p3 = 107 then
20319: LD_VAR 0 3
20323: PUSH
20324: LD_INT 107
20326: EQUAL
20327: IFFALSE 20337
// sBomb := true ;
20329: LD_ADDR_EXP 82
20333: PUSH
20334: LD_INT 1
20336: ST_TO_ADDR
// if p3 = 108 then
20337: LD_VAR 0 3
20341: PUSH
20342: LD_INT 108
20344: EQUAL
20345: IFFALSE 20355
// sWound := true ;
20347: LD_ADDR_EXP 90
20351: PUSH
20352: LD_INT 1
20354: ST_TO_ADDR
// if p3 = 109 then
20355: LD_VAR 0 3
20359: PUSH
20360: LD_INT 109
20362: EQUAL
20363: IFFALSE 20373
// sBetray := true ;
20365: LD_ADDR_EXP 94
20369: PUSH
20370: LD_INT 1
20372: ST_TO_ADDR
// if p3 = 110 then
20373: LD_VAR 0 3
20377: PUSH
20378: LD_INT 110
20380: EQUAL
20381: IFFALSE 20391
// sContamin := true ;
20383: LD_ADDR_EXP 95
20387: PUSH
20388: LD_INT 1
20390: ST_TO_ADDR
// if p3 = 111 then
20391: LD_VAR 0 3
20395: PUSH
20396: LD_INT 111
20398: EQUAL
20399: IFFALSE 20409
// sOil := true ;
20401: LD_ADDR_EXP 97
20405: PUSH
20406: LD_INT 1
20408: ST_TO_ADDR
// if p3 = 112 then
20409: LD_VAR 0 3
20413: PUSH
20414: LD_INT 112
20416: EQUAL
20417: IFFALSE 20427
// sStu := true ;
20419: LD_ADDR_EXP 101
20423: PUSH
20424: LD_INT 1
20426: ST_TO_ADDR
// if p3 = 113 then
20427: LD_VAR 0 3
20431: PUSH
20432: LD_INT 113
20434: EQUAL
20435: IFFALSE 20445
// sBazooka := true ;
20437: LD_ADDR_EXP 104
20441: PUSH
20442: LD_INT 1
20444: ST_TO_ADDR
// if p3 = 114 then
20445: LD_VAR 0 3
20449: PUSH
20450: LD_INT 114
20452: EQUAL
20453: IFFALSE 20463
// sMortar := true ;
20455: LD_ADDR_EXP 105
20459: PUSH
20460: LD_INT 1
20462: ST_TO_ADDR
// if p3 = 115 then
20463: LD_VAR 0 3
20467: PUSH
20468: LD_INT 115
20470: EQUAL
20471: IFFALSE 20481
// sRanger := true ;
20473: LD_ADDR_EXP 115
20477: PUSH
20478: LD_INT 1
20480: ST_TO_ADDR
// end ; if p2 = 101 then
20481: LD_VAR 0 2
20485: PUSH
20486: LD_INT 101
20488: EQUAL
20489: IFFALSE 20692
// begin case p3 of 1 :
20491: LD_VAR 0 3
20495: PUSH
20496: LD_INT 1
20498: DOUBLE
20499: EQUAL
20500: IFTRUE 20504
20502: GO 20511
20504: POP
// hHackUnlimitedResources ; 2 :
20505: CALL 30786 0 0
20509: GO 20692
20511: LD_INT 2
20513: DOUBLE
20514: EQUAL
20515: IFTRUE 20519
20517: GO 20526
20519: POP
// hHackSetLevel10 ; 3 :
20520: CALL 30919 0 0
20524: GO 20692
20526: LD_INT 3
20528: DOUBLE
20529: EQUAL
20530: IFTRUE 20534
20532: GO 20541
20534: POP
// hHackSetLevel10YourUnits ; 4 :
20535: CALL 31004 0 0
20539: GO 20692
20541: LD_INT 4
20543: DOUBLE
20544: EQUAL
20545: IFTRUE 20549
20547: GO 20571
20549: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
20550: LD_VAR 0 4
20554: PPUSH
20555: LD_VAR 0 5
20559: PPUSH
20560: LD_VAR 0 6
20564: PPUSH
20565: CALL 31094 0 3
20569: GO 20692
20571: LD_INT 5
20573: DOUBLE
20574: EQUAL
20575: IFTRUE 20579
20577: GO 20586
20579: POP
// hHackSpawnVehicle ; 6 :
20580: CALL 31155 0 0
20584: GO 20692
20586: LD_INT 6
20588: DOUBLE
20589: EQUAL
20590: IFTRUE 20594
20592: GO 20601
20594: POP
// hHackInvincible ; 7 :
20595: CALL 31701 0 0
20599: GO 20692
20601: LD_INT 7
20603: DOUBLE
20604: EQUAL
20605: IFTRUE 20609
20607: GO 20616
20609: POP
// hHackInvisible ; 8 :
20610: CALL 31812 0 0
20614: GO 20692
20616: LD_INT 8
20618: DOUBLE
20619: EQUAL
20620: IFTRUE 20624
20622: GO 20631
20624: POP
// hHackChangeYourSide ; 9 :
20625: CALL 31869 0 0
20629: GO 20692
20631: LD_INT 9
20633: DOUBLE
20634: EQUAL
20635: IFTRUE 20639
20637: GO 20646
20639: POP
// hHackChangeUnitSide ; 10 :
20640: CALL 31911 0 0
20644: GO 20692
20646: LD_INT 10
20648: DOUBLE
20649: EQUAL
20650: IFTRUE 20654
20652: GO 20661
20654: POP
// hHackFog ; 11 :
20655: CALL 32012 0 0
20659: GO 20692
20661: LD_INT 11
20663: DOUBLE
20664: EQUAL
20665: IFTRUE 20669
20667: GO 20676
20669: POP
// hHackApeman ; 12 :
20670: CALL 32027 0 0
20674: GO 20692
20676: LD_INT 12
20678: DOUBLE
20679: EQUAL
20680: IFTRUE 20684
20682: GO 20691
20684: POP
// hHackBoom ; end ;
20685: CALL 32112 0 0
20689: GO 20692
20691: POP
// end ; end ;
20692: PPOPN 6
20694: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
20695: GO 20697
20697: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
20698: LD_STRING initStreamRollete();
20700: PPUSH
20701: CALL_OW 559
// InitStreamMode ;
20705: CALL 20714 0 0
// DefineStreamItems ( ) ;
20709: CALL 21154 0 0
// end ;
20713: END
// function InitStreamMode ; begin
20714: LD_INT 0
20716: PPUSH
// streamModeActive := false ;
20717: LD_ADDR_EXP 62
20721: PUSH
20722: LD_INT 0
20724: ST_TO_ADDR
// normalCounter := 36 ;
20725: LD_ADDR_EXP 63
20729: PUSH
20730: LD_INT 36
20732: ST_TO_ADDR
// hardcoreCounter := 16 ;
20733: LD_ADDR_EXP 64
20737: PUSH
20738: LD_INT 16
20740: ST_TO_ADDR
// sRocket := false ;
20741: LD_ADDR_EXP 67
20745: PUSH
20746: LD_INT 0
20748: ST_TO_ADDR
// sSpeed := false ;
20749: LD_ADDR_EXP 66
20753: PUSH
20754: LD_INT 0
20756: ST_TO_ADDR
// sEngine := false ;
20757: LD_ADDR_EXP 68
20761: PUSH
20762: LD_INT 0
20764: ST_TO_ADDR
// sSpec := false ;
20765: LD_ADDR_EXP 65
20769: PUSH
20770: LD_INT 0
20772: ST_TO_ADDR
// sLevel := false ;
20773: LD_ADDR_EXP 69
20777: PUSH
20778: LD_INT 0
20780: ST_TO_ADDR
// sArmoury := false ;
20781: LD_ADDR_EXP 70
20785: PUSH
20786: LD_INT 0
20788: ST_TO_ADDR
// sRadar := false ;
20789: LD_ADDR_EXP 71
20793: PUSH
20794: LD_INT 0
20796: ST_TO_ADDR
// sBunker := false ;
20797: LD_ADDR_EXP 72
20801: PUSH
20802: LD_INT 0
20804: ST_TO_ADDR
// sHack := false ;
20805: LD_ADDR_EXP 73
20809: PUSH
20810: LD_INT 0
20812: ST_TO_ADDR
// sFire := false ;
20813: LD_ADDR_EXP 74
20817: PUSH
20818: LD_INT 0
20820: ST_TO_ADDR
// sRefresh := false ;
20821: LD_ADDR_EXP 75
20825: PUSH
20826: LD_INT 0
20828: ST_TO_ADDR
// sExp := false ;
20829: LD_ADDR_EXP 76
20833: PUSH
20834: LD_INT 0
20836: ST_TO_ADDR
// sDepot := false ;
20837: LD_ADDR_EXP 77
20841: PUSH
20842: LD_INT 0
20844: ST_TO_ADDR
// sFlag := false ;
20845: LD_ADDR_EXP 78
20849: PUSH
20850: LD_INT 0
20852: ST_TO_ADDR
// sKamikadze := false ;
20853: LD_ADDR_EXP 86
20857: PUSH
20858: LD_INT 0
20860: ST_TO_ADDR
// sTroll := false ;
20861: LD_ADDR_EXP 87
20865: PUSH
20866: LD_INT 0
20868: ST_TO_ADDR
// sSlow := false ;
20869: LD_ADDR_EXP 88
20873: PUSH
20874: LD_INT 0
20876: ST_TO_ADDR
// sLack := false ;
20877: LD_ADDR_EXP 89
20881: PUSH
20882: LD_INT 0
20884: ST_TO_ADDR
// sTank := false ;
20885: LD_ADDR_EXP 91
20889: PUSH
20890: LD_INT 0
20892: ST_TO_ADDR
// sRemote := false ;
20893: LD_ADDR_EXP 92
20897: PUSH
20898: LD_INT 0
20900: ST_TO_ADDR
// sPowell := false ;
20901: LD_ADDR_EXP 93
20905: PUSH
20906: LD_INT 0
20908: ST_TO_ADDR
// sTeleport := false ;
20909: LD_ADDR_EXP 96
20913: PUSH
20914: LD_INT 0
20916: ST_TO_ADDR
// sOilTower := false ;
20917: LD_ADDR_EXP 98
20921: PUSH
20922: LD_INT 0
20924: ST_TO_ADDR
// sShovel := false ;
20925: LD_ADDR_EXP 99
20929: PUSH
20930: LD_INT 0
20932: ST_TO_ADDR
// sSheik := false ;
20933: LD_ADDR_EXP 100
20937: PUSH
20938: LD_INT 0
20940: ST_TO_ADDR
// sEarthquake := false ;
20941: LD_ADDR_EXP 102
20945: PUSH
20946: LD_INT 0
20948: ST_TO_ADDR
// sAI := false ;
20949: LD_ADDR_EXP 103
20953: PUSH
20954: LD_INT 0
20956: ST_TO_ADDR
// sCargo := false ;
20957: LD_ADDR_EXP 106
20961: PUSH
20962: LD_INT 0
20964: ST_TO_ADDR
// sDLaser := false ;
20965: LD_ADDR_EXP 107
20969: PUSH
20970: LD_INT 0
20972: ST_TO_ADDR
// sExchange := false ;
20973: LD_ADDR_EXP 108
20977: PUSH
20978: LD_INT 0
20980: ST_TO_ADDR
// sFac := false ;
20981: LD_ADDR_EXP 109
20985: PUSH
20986: LD_INT 0
20988: ST_TO_ADDR
// sPower := false ;
20989: LD_ADDR_EXP 110
20993: PUSH
20994: LD_INT 0
20996: ST_TO_ADDR
// sRandom := false ;
20997: LD_ADDR_EXP 111
21001: PUSH
21002: LD_INT 0
21004: ST_TO_ADDR
// sShield := false ;
21005: LD_ADDR_EXP 112
21009: PUSH
21010: LD_INT 0
21012: ST_TO_ADDR
// sTime := false ;
21013: LD_ADDR_EXP 113
21017: PUSH
21018: LD_INT 0
21020: ST_TO_ADDR
// sTools := false ;
21021: LD_ADDR_EXP 114
21025: PUSH
21026: LD_INT 0
21028: ST_TO_ADDR
// sSold := false ;
21029: LD_ADDR_EXP 79
21033: PUSH
21034: LD_INT 0
21036: ST_TO_ADDR
// sDiff := false ;
21037: LD_ADDR_EXP 80
21041: PUSH
21042: LD_INT 0
21044: ST_TO_ADDR
// sFog := false ;
21045: LD_ADDR_EXP 83
21049: PUSH
21050: LD_INT 0
21052: ST_TO_ADDR
// sReset := false ;
21053: LD_ADDR_EXP 84
21057: PUSH
21058: LD_INT 0
21060: ST_TO_ADDR
// sSun := false ;
21061: LD_ADDR_EXP 85
21065: PUSH
21066: LD_INT 0
21068: ST_TO_ADDR
// sTiger := false ;
21069: LD_ADDR_EXP 81
21073: PUSH
21074: LD_INT 0
21076: ST_TO_ADDR
// sBomb := false ;
21077: LD_ADDR_EXP 82
21081: PUSH
21082: LD_INT 0
21084: ST_TO_ADDR
// sWound := false ;
21085: LD_ADDR_EXP 90
21089: PUSH
21090: LD_INT 0
21092: ST_TO_ADDR
// sBetray := false ;
21093: LD_ADDR_EXP 94
21097: PUSH
21098: LD_INT 0
21100: ST_TO_ADDR
// sContamin := false ;
21101: LD_ADDR_EXP 95
21105: PUSH
21106: LD_INT 0
21108: ST_TO_ADDR
// sOil := false ;
21109: LD_ADDR_EXP 97
21113: PUSH
21114: LD_INT 0
21116: ST_TO_ADDR
// sStu := false ;
21117: LD_ADDR_EXP 101
21121: PUSH
21122: LD_INT 0
21124: ST_TO_ADDR
// sBazooka := false ;
21125: LD_ADDR_EXP 104
21129: PUSH
21130: LD_INT 0
21132: ST_TO_ADDR
// sMortar := false ;
21133: LD_ADDR_EXP 105
21137: PUSH
21138: LD_INT 0
21140: ST_TO_ADDR
// sRanger := false ;
21141: LD_ADDR_EXP 115
21145: PUSH
21146: LD_INT 0
21148: ST_TO_ADDR
// end ;
21149: LD_VAR 0 1
21153: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
21154: LD_INT 0
21156: PPUSH
21157: PPUSH
21158: PPUSH
21159: PPUSH
21160: PPUSH
// result := [ ] ;
21161: LD_ADDR_VAR 0 1
21165: PUSH
21166: EMPTY
21167: ST_TO_ADDR
// if campaign_id = 1 then
21168: LD_OWVAR 69
21172: PUSH
21173: LD_INT 1
21175: EQUAL
21176: IFFALSE 24114
// begin case mission_number of 1 :
21178: LD_OWVAR 70
21182: PUSH
21183: LD_INT 1
21185: DOUBLE
21186: EQUAL
21187: IFTRUE 21191
21189: GO 21255
21191: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
21192: LD_ADDR_VAR 0 1
21196: PUSH
21197: LD_INT 2
21199: PUSH
21200: LD_INT 4
21202: PUSH
21203: LD_INT 11
21205: PUSH
21206: LD_INT 12
21208: PUSH
21209: LD_INT 15
21211: PUSH
21212: LD_INT 16
21214: PUSH
21215: LD_INT 22
21217: PUSH
21218: LD_INT 23
21220: PUSH
21221: LD_INT 26
21223: PUSH
21224: EMPTY
21225: LIST
21226: LIST
21227: LIST
21228: LIST
21229: LIST
21230: LIST
21231: LIST
21232: LIST
21233: LIST
21234: PUSH
21235: LD_INT 101
21237: PUSH
21238: LD_INT 102
21240: PUSH
21241: LD_INT 106
21243: PUSH
21244: EMPTY
21245: LIST
21246: LIST
21247: LIST
21248: PUSH
21249: EMPTY
21250: LIST
21251: LIST
21252: ST_TO_ADDR
21253: GO 24112
21255: LD_INT 2
21257: DOUBLE
21258: EQUAL
21259: IFTRUE 21263
21261: GO 21335
21263: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
21264: LD_ADDR_VAR 0 1
21268: PUSH
21269: LD_INT 2
21271: PUSH
21272: LD_INT 4
21274: PUSH
21275: LD_INT 11
21277: PUSH
21278: LD_INT 12
21280: PUSH
21281: LD_INT 15
21283: PUSH
21284: LD_INT 16
21286: PUSH
21287: LD_INT 22
21289: PUSH
21290: LD_INT 23
21292: PUSH
21293: LD_INT 26
21295: PUSH
21296: EMPTY
21297: LIST
21298: LIST
21299: LIST
21300: LIST
21301: LIST
21302: LIST
21303: LIST
21304: LIST
21305: LIST
21306: PUSH
21307: LD_INT 101
21309: PUSH
21310: LD_INT 102
21312: PUSH
21313: LD_INT 105
21315: PUSH
21316: LD_INT 106
21318: PUSH
21319: LD_INT 108
21321: PUSH
21322: EMPTY
21323: LIST
21324: LIST
21325: LIST
21326: LIST
21327: LIST
21328: PUSH
21329: EMPTY
21330: LIST
21331: LIST
21332: ST_TO_ADDR
21333: GO 24112
21335: LD_INT 3
21337: DOUBLE
21338: EQUAL
21339: IFTRUE 21343
21341: GO 21419
21343: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
21344: LD_ADDR_VAR 0 1
21348: PUSH
21349: LD_INT 2
21351: PUSH
21352: LD_INT 4
21354: PUSH
21355: LD_INT 5
21357: PUSH
21358: LD_INT 11
21360: PUSH
21361: LD_INT 12
21363: PUSH
21364: LD_INT 15
21366: PUSH
21367: LD_INT 16
21369: PUSH
21370: LD_INT 22
21372: PUSH
21373: LD_INT 26
21375: PUSH
21376: LD_INT 36
21378: PUSH
21379: EMPTY
21380: LIST
21381: LIST
21382: LIST
21383: LIST
21384: LIST
21385: LIST
21386: LIST
21387: LIST
21388: LIST
21389: LIST
21390: PUSH
21391: LD_INT 101
21393: PUSH
21394: LD_INT 102
21396: PUSH
21397: LD_INT 105
21399: PUSH
21400: LD_INT 106
21402: PUSH
21403: LD_INT 108
21405: PUSH
21406: EMPTY
21407: LIST
21408: LIST
21409: LIST
21410: LIST
21411: LIST
21412: PUSH
21413: EMPTY
21414: LIST
21415: LIST
21416: ST_TO_ADDR
21417: GO 24112
21419: LD_INT 4
21421: DOUBLE
21422: EQUAL
21423: IFTRUE 21427
21425: GO 21511
21427: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
21428: LD_ADDR_VAR 0 1
21432: PUSH
21433: LD_INT 2
21435: PUSH
21436: LD_INT 4
21438: PUSH
21439: LD_INT 5
21441: PUSH
21442: LD_INT 8
21444: PUSH
21445: LD_INT 11
21447: PUSH
21448: LD_INT 12
21450: PUSH
21451: LD_INT 15
21453: PUSH
21454: LD_INT 16
21456: PUSH
21457: LD_INT 22
21459: PUSH
21460: LD_INT 23
21462: PUSH
21463: LD_INT 26
21465: PUSH
21466: LD_INT 36
21468: PUSH
21469: EMPTY
21470: LIST
21471: LIST
21472: LIST
21473: LIST
21474: LIST
21475: LIST
21476: LIST
21477: LIST
21478: LIST
21479: LIST
21480: LIST
21481: LIST
21482: PUSH
21483: LD_INT 101
21485: PUSH
21486: LD_INT 102
21488: PUSH
21489: LD_INT 105
21491: PUSH
21492: LD_INT 106
21494: PUSH
21495: LD_INT 108
21497: PUSH
21498: EMPTY
21499: LIST
21500: LIST
21501: LIST
21502: LIST
21503: LIST
21504: PUSH
21505: EMPTY
21506: LIST
21507: LIST
21508: ST_TO_ADDR
21509: GO 24112
21511: LD_INT 5
21513: DOUBLE
21514: EQUAL
21515: IFTRUE 21519
21517: GO 21619
21519: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
21520: LD_ADDR_VAR 0 1
21524: PUSH
21525: LD_INT 2
21527: PUSH
21528: LD_INT 4
21530: PUSH
21531: LD_INT 5
21533: PUSH
21534: LD_INT 6
21536: PUSH
21537: LD_INT 8
21539: PUSH
21540: LD_INT 11
21542: PUSH
21543: LD_INT 12
21545: PUSH
21546: LD_INT 15
21548: PUSH
21549: LD_INT 16
21551: PUSH
21552: LD_INT 22
21554: PUSH
21555: LD_INT 23
21557: PUSH
21558: LD_INT 25
21560: PUSH
21561: LD_INT 26
21563: PUSH
21564: LD_INT 36
21566: PUSH
21567: EMPTY
21568: LIST
21569: LIST
21570: LIST
21571: LIST
21572: LIST
21573: LIST
21574: LIST
21575: LIST
21576: LIST
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: LIST
21582: PUSH
21583: LD_INT 101
21585: PUSH
21586: LD_INT 102
21588: PUSH
21589: LD_INT 105
21591: PUSH
21592: LD_INT 106
21594: PUSH
21595: LD_INT 108
21597: PUSH
21598: LD_INT 109
21600: PUSH
21601: LD_INT 112
21603: PUSH
21604: EMPTY
21605: LIST
21606: LIST
21607: LIST
21608: LIST
21609: LIST
21610: LIST
21611: LIST
21612: PUSH
21613: EMPTY
21614: LIST
21615: LIST
21616: ST_TO_ADDR
21617: GO 24112
21619: LD_INT 6
21621: DOUBLE
21622: EQUAL
21623: IFTRUE 21627
21625: GO 21747
21627: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
21628: LD_ADDR_VAR 0 1
21632: PUSH
21633: LD_INT 2
21635: PUSH
21636: LD_INT 4
21638: PUSH
21639: LD_INT 5
21641: PUSH
21642: LD_INT 6
21644: PUSH
21645: LD_INT 8
21647: PUSH
21648: LD_INT 11
21650: PUSH
21651: LD_INT 12
21653: PUSH
21654: LD_INT 15
21656: PUSH
21657: LD_INT 16
21659: PUSH
21660: LD_INT 20
21662: PUSH
21663: LD_INT 21
21665: PUSH
21666: LD_INT 22
21668: PUSH
21669: LD_INT 23
21671: PUSH
21672: LD_INT 25
21674: PUSH
21675: LD_INT 26
21677: PUSH
21678: LD_INT 30
21680: PUSH
21681: LD_INT 31
21683: PUSH
21684: LD_INT 32
21686: PUSH
21687: LD_INT 36
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: LIST
21694: LIST
21695: LIST
21696: LIST
21697: LIST
21698: LIST
21699: LIST
21700: LIST
21701: LIST
21702: LIST
21703: LIST
21704: LIST
21705: LIST
21706: LIST
21707: LIST
21708: LIST
21709: LIST
21710: PUSH
21711: LD_INT 101
21713: PUSH
21714: LD_INT 102
21716: PUSH
21717: LD_INT 105
21719: PUSH
21720: LD_INT 106
21722: PUSH
21723: LD_INT 108
21725: PUSH
21726: LD_INT 109
21728: PUSH
21729: LD_INT 112
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: LIST
21736: LIST
21737: LIST
21738: LIST
21739: LIST
21740: PUSH
21741: EMPTY
21742: LIST
21743: LIST
21744: ST_TO_ADDR
21745: GO 24112
21747: LD_INT 7
21749: DOUBLE
21750: EQUAL
21751: IFTRUE 21755
21753: GO 21855
21755: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
21756: LD_ADDR_VAR 0 1
21760: PUSH
21761: LD_INT 2
21763: PUSH
21764: LD_INT 4
21766: PUSH
21767: LD_INT 5
21769: PUSH
21770: LD_INT 7
21772: PUSH
21773: LD_INT 11
21775: PUSH
21776: LD_INT 12
21778: PUSH
21779: LD_INT 15
21781: PUSH
21782: LD_INT 16
21784: PUSH
21785: LD_INT 20
21787: PUSH
21788: LD_INT 21
21790: PUSH
21791: LD_INT 22
21793: PUSH
21794: LD_INT 23
21796: PUSH
21797: LD_INT 25
21799: PUSH
21800: LD_INT 26
21802: PUSH
21803: EMPTY
21804: LIST
21805: LIST
21806: LIST
21807: LIST
21808: LIST
21809: LIST
21810: LIST
21811: LIST
21812: LIST
21813: LIST
21814: LIST
21815: LIST
21816: LIST
21817: LIST
21818: PUSH
21819: LD_INT 101
21821: PUSH
21822: LD_INT 102
21824: PUSH
21825: LD_INT 103
21827: PUSH
21828: LD_INT 105
21830: PUSH
21831: LD_INT 106
21833: PUSH
21834: LD_INT 108
21836: PUSH
21837: LD_INT 112
21839: PUSH
21840: EMPTY
21841: LIST
21842: LIST
21843: LIST
21844: LIST
21845: LIST
21846: LIST
21847: LIST
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: ST_TO_ADDR
21853: GO 24112
21855: LD_INT 8
21857: DOUBLE
21858: EQUAL
21859: IFTRUE 21863
21861: GO 21991
21863: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
21864: LD_ADDR_VAR 0 1
21868: PUSH
21869: LD_INT 2
21871: PUSH
21872: LD_INT 4
21874: PUSH
21875: LD_INT 5
21877: PUSH
21878: LD_INT 6
21880: PUSH
21881: LD_INT 7
21883: PUSH
21884: LD_INT 8
21886: PUSH
21887: LD_INT 11
21889: PUSH
21890: LD_INT 12
21892: PUSH
21893: LD_INT 15
21895: PUSH
21896: LD_INT 16
21898: PUSH
21899: LD_INT 20
21901: PUSH
21902: LD_INT 21
21904: PUSH
21905: LD_INT 22
21907: PUSH
21908: LD_INT 23
21910: PUSH
21911: LD_INT 25
21913: PUSH
21914: LD_INT 26
21916: PUSH
21917: LD_INT 30
21919: PUSH
21920: LD_INT 31
21922: PUSH
21923: LD_INT 32
21925: PUSH
21926: LD_INT 36
21928: PUSH
21929: EMPTY
21930: LIST
21931: LIST
21932: LIST
21933: LIST
21934: LIST
21935: LIST
21936: LIST
21937: LIST
21938: LIST
21939: LIST
21940: LIST
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: LIST
21946: LIST
21947: LIST
21948: LIST
21949: LIST
21950: PUSH
21951: LD_INT 101
21953: PUSH
21954: LD_INT 102
21956: PUSH
21957: LD_INT 103
21959: PUSH
21960: LD_INT 105
21962: PUSH
21963: LD_INT 106
21965: PUSH
21966: LD_INT 108
21968: PUSH
21969: LD_INT 109
21971: PUSH
21972: LD_INT 112
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: LIST
21983: LIST
21984: PUSH
21985: EMPTY
21986: LIST
21987: LIST
21988: ST_TO_ADDR
21989: GO 24112
21991: LD_INT 9
21993: DOUBLE
21994: EQUAL
21995: IFTRUE 21999
21997: GO 22135
21999: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
22000: LD_ADDR_VAR 0 1
22004: PUSH
22005: LD_INT 2
22007: PUSH
22008: LD_INT 4
22010: PUSH
22011: LD_INT 5
22013: PUSH
22014: LD_INT 6
22016: PUSH
22017: LD_INT 7
22019: PUSH
22020: LD_INT 8
22022: PUSH
22023: LD_INT 11
22025: PUSH
22026: LD_INT 12
22028: PUSH
22029: LD_INT 15
22031: PUSH
22032: LD_INT 16
22034: PUSH
22035: LD_INT 20
22037: PUSH
22038: LD_INT 21
22040: PUSH
22041: LD_INT 22
22043: PUSH
22044: LD_INT 23
22046: PUSH
22047: LD_INT 25
22049: PUSH
22050: LD_INT 26
22052: PUSH
22053: LD_INT 28
22055: PUSH
22056: LD_INT 30
22058: PUSH
22059: LD_INT 31
22061: PUSH
22062: LD_INT 32
22064: PUSH
22065: LD_INT 36
22067: PUSH
22068: EMPTY
22069: LIST
22070: LIST
22071: LIST
22072: LIST
22073: LIST
22074: LIST
22075: LIST
22076: LIST
22077: LIST
22078: LIST
22079: LIST
22080: LIST
22081: LIST
22082: LIST
22083: LIST
22084: LIST
22085: LIST
22086: LIST
22087: LIST
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 101
22093: PUSH
22094: LD_INT 102
22096: PUSH
22097: LD_INT 103
22099: PUSH
22100: LD_INT 105
22102: PUSH
22103: LD_INT 106
22105: PUSH
22106: LD_INT 108
22108: PUSH
22109: LD_INT 109
22111: PUSH
22112: LD_INT 112
22114: PUSH
22115: LD_INT 114
22117: PUSH
22118: EMPTY
22119: LIST
22120: LIST
22121: LIST
22122: LIST
22123: LIST
22124: LIST
22125: LIST
22126: LIST
22127: LIST
22128: PUSH
22129: EMPTY
22130: LIST
22131: LIST
22132: ST_TO_ADDR
22133: GO 24112
22135: LD_INT 10
22137: DOUBLE
22138: EQUAL
22139: IFTRUE 22143
22141: GO 22327
22143: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
22144: LD_ADDR_VAR 0 1
22148: PUSH
22149: LD_INT 2
22151: PUSH
22152: LD_INT 4
22154: PUSH
22155: LD_INT 5
22157: PUSH
22158: LD_INT 6
22160: PUSH
22161: LD_INT 7
22163: PUSH
22164: LD_INT 8
22166: PUSH
22167: LD_INT 9
22169: PUSH
22170: LD_INT 10
22172: PUSH
22173: LD_INT 11
22175: PUSH
22176: LD_INT 12
22178: PUSH
22179: LD_INT 13
22181: PUSH
22182: LD_INT 14
22184: PUSH
22185: LD_INT 15
22187: PUSH
22188: LD_INT 16
22190: PUSH
22191: LD_INT 17
22193: PUSH
22194: LD_INT 18
22196: PUSH
22197: LD_INT 19
22199: PUSH
22200: LD_INT 20
22202: PUSH
22203: LD_INT 21
22205: PUSH
22206: LD_INT 22
22208: PUSH
22209: LD_INT 23
22211: PUSH
22212: LD_INT 24
22214: PUSH
22215: LD_INT 25
22217: PUSH
22218: LD_INT 26
22220: PUSH
22221: LD_INT 28
22223: PUSH
22224: LD_INT 30
22226: PUSH
22227: LD_INT 31
22229: PUSH
22230: LD_INT 32
22232: PUSH
22233: LD_INT 36
22235: PUSH
22236: EMPTY
22237: LIST
22238: LIST
22239: LIST
22240: LIST
22241: LIST
22242: LIST
22243: LIST
22244: LIST
22245: LIST
22246: LIST
22247: LIST
22248: LIST
22249: LIST
22250: LIST
22251: LIST
22252: LIST
22253: LIST
22254: LIST
22255: LIST
22256: LIST
22257: LIST
22258: LIST
22259: LIST
22260: LIST
22261: LIST
22262: LIST
22263: LIST
22264: LIST
22265: LIST
22266: PUSH
22267: LD_INT 101
22269: PUSH
22270: LD_INT 102
22272: PUSH
22273: LD_INT 103
22275: PUSH
22276: LD_INT 104
22278: PUSH
22279: LD_INT 105
22281: PUSH
22282: LD_INT 106
22284: PUSH
22285: LD_INT 107
22287: PUSH
22288: LD_INT 108
22290: PUSH
22291: LD_INT 109
22293: PUSH
22294: LD_INT 110
22296: PUSH
22297: LD_INT 111
22299: PUSH
22300: LD_INT 112
22302: PUSH
22303: LD_INT 114
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: LIST
22310: LIST
22311: LIST
22312: LIST
22313: LIST
22314: LIST
22315: LIST
22316: LIST
22317: LIST
22318: LIST
22319: LIST
22320: PUSH
22321: EMPTY
22322: LIST
22323: LIST
22324: ST_TO_ADDR
22325: GO 24112
22327: LD_INT 11
22329: DOUBLE
22330: EQUAL
22331: IFTRUE 22335
22333: GO 22527
22335: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
22336: LD_ADDR_VAR 0 1
22340: PUSH
22341: LD_INT 2
22343: PUSH
22344: LD_INT 3
22346: PUSH
22347: LD_INT 4
22349: PUSH
22350: LD_INT 5
22352: PUSH
22353: LD_INT 6
22355: PUSH
22356: LD_INT 7
22358: PUSH
22359: LD_INT 8
22361: PUSH
22362: LD_INT 9
22364: PUSH
22365: LD_INT 10
22367: PUSH
22368: LD_INT 11
22370: PUSH
22371: LD_INT 12
22373: PUSH
22374: LD_INT 13
22376: PUSH
22377: LD_INT 14
22379: PUSH
22380: LD_INT 15
22382: PUSH
22383: LD_INT 16
22385: PUSH
22386: LD_INT 17
22388: PUSH
22389: LD_INT 18
22391: PUSH
22392: LD_INT 19
22394: PUSH
22395: LD_INT 20
22397: PUSH
22398: LD_INT 21
22400: PUSH
22401: LD_INT 22
22403: PUSH
22404: LD_INT 23
22406: PUSH
22407: LD_INT 24
22409: PUSH
22410: LD_INT 25
22412: PUSH
22413: LD_INT 26
22415: PUSH
22416: LD_INT 28
22418: PUSH
22419: LD_INT 30
22421: PUSH
22422: LD_INT 31
22424: PUSH
22425: LD_INT 32
22427: PUSH
22428: LD_INT 34
22430: PUSH
22431: LD_INT 36
22433: PUSH
22434: EMPTY
22435: LIST
22436: LIST
22437: LIST
22438: LIST
22439: LIST
22440: LIST
22441: LIST
22442: LIST
22443: LIST
22444: LIST
22445: LIST
22446: LIST
22447: LIST
22448: LIST
22449: LIST
22450: LIST
22451: LIST
22452: LIST
22453: LIST
22454: LIST
22455: LIST
22456: LIST
22457: LIST
22458: LIST
22459: LIST
22460: LIST
22461: LIST
22462: LIST
22463: LIST
22464: LIST
22465: LIST
22466: PUSH
22467: LD_INT 101
22469: PUSH
22470: LD_INT 102
22472: PUSH
22473: LD_INT 103
22475: PUSH
22476: LD_INT 104
22478: PUSH
22479: LD_INT 105
22481: PUSH
22482: LD_INT 106
22484: PUSH
22485: LD_INT 107
22487: PUSH
22488: LD_INT 108
22490: PUSH
22491: LD_INT 109
22493: PUSH
22494: LD_INT 110
22496: PUSH
22497: LD_INT 111
22499: PUSH
22500: LD_INT 112
22502: PUSH
22503: LD_INT 114
22505: PUSH
22506: EMPTY
22507: LIST
22508: LIST
22509: LIST
22510: LIST
22511: LIST
22512: LIST
22513: LIST
22514: LIST
22515: LIST
22516: LIST
22517: LIST
22518: LIST
22519: LIST
22520: PUSH
22521: EMPTY
22522: LIST
22523: LIST
22524: ST_TO_ADDR
22525: GO 24112
22527: LD_INT 12
22529: DOUBLE
22530: EQUAL
22531: IFTRUE 22535
22533: GO 22743
22535: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
22536: LD_ADDR_VAR 0 1
22540: PUSH
22541: LD_INT 1
22543: PUSH
22544: LD_INT 2
22546: PUSH
22547: LD_INT 3
22549: PUSH
22550: LD_INT 4
22552: PUSH
22553: LD_INT 5
22555: PUSH
22556: LD_INT 6
22558: PUSH
22559: LD_INT 7
22561: PUSH
22562: LD_INT 8
22564: PUSH
22565: LD_INT 9
22567: PUSH
22568: LD_INT 10
22570: PUSH
22571: LD_INT 11
22573: PUSH
22574: LD_INT 12
22576: PUSH
22577: LD_INT 13
22579: PUSH
22580: LD_INT 14
22582: PUSH
22583: LD_INT 15
22585: PUSH
22586: LD_INT 16
22588: PUSH
22589: LD_INT 17
22591: PUSH
22592: LD_INT 18
22594: PUSH
22595: LD_INT 19
22597: PUSH
22598: LD_INT 20
22600: PUSH
22601: LD_INT 21
22603: PUSH
22604: LD_INT 22
22606: PUSH
22607: LD_INT 23
22609: PUSH
22610: LD_INT 24
22612: PUSH
22613: LD_INT 25
22615: PUSH
22616: LD_INT 26
22618: PUSH
22619: LD_INT 27
22621: PUSH
22622: LD_INT 28
22624: PUSH
22625: LD_INT 30
22627: PUSH
22628: LD_INT 31
22630: PUSH
22631: LD_INT 32
22633: PUSH
22634: LD_INT 33
22636: PUSH
22637: LD_INT 34
22639: PUSH
22640: LD_INT 36
22642: PUSH
22643: EMPTY
22644: LIST
22645: LIST
22646: LIST
22647: LIST
22648: LIST
22649: LIST
22650: LIST
22651: LIST
22652: LIST
22653: LIST
22654: LIST
22655: LIST
22656: LIST
22657: LIST
22658: LIST
22659: LIST
22660: LIST
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: LIST
22671: LIST
22672: LIST
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: LIST
22678: PUSH
22679: LD_INT 101
22681: PUSH
22682: LD_INT 102
22684: PUSH
22685: LD_INT 103
22687: PUSH
22688: LD_INT 104
22690: PUSH
22691: LD_INT 105
22693: PUSH
22694: LD_INT 106
22696: PUSH
22697: LD_INT 107
22699: PUSH
22700: LD_INT 108
22702: PUSH
22703: LD_INT 109
22705: PUSH
22706: LD_INT 110
22708: PUSH
22709: LD_INT 111
22711: PUSH
22712: LD_INT 112
22714: PUSH
22715: LD_INT 113
22717: PUSH
22718: LD_INT 114
22720: PUSH
22721: EMPTY
22722: LIST
22723: LIST
22724: LIST
22725: LIST
22726: LIST
22727: LIST
22728: LIST
22729: LIST
22730: LIST
22731: LIST
22732: LIST
22733: LIST
22734: LIST
22735: LIST
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: ST_TO_ADDR
22741: GO 24112
22743: LD_INT 13
22745: DOUBLE
22746: EQUAL
22747: IFTRUE 22751
22749: GO 22947
22751: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
22752: LD_ADDR_VAR 0 1
22756: PUSH
22757: LD_INT 1
22759: PUSH
22760: LD_INT 2
22762: PUSH
22763: LD_INT 3
22765: PUSH
22766: LD_INT 4
22768: PUSH
22769: LD_INT 5
22771: PUSH
22772: LD_INT 8
22774: PUSH
22775: LD_INT 9
22777: PUSH
22778: LD_INT 10
22780: PUSH
22781: LD_INT 11
22783: PUSH
22784: LD_INT 12
22786: PUSH
22787: LD_INT 14
22789: PUSH
22790: LD_INT 15
22792: PUSH
22793: LD_INT 16
22795: PUSH
22796: LD_INT 17
22798: PUSH
22799: LD_INT 18
22801: PUSH
22802: LD_INT 19
22804: PUSH
22805: LD_INT 20
22807: PUSH
22808: LD_INT 21
22810: PUSH
22811: LD_INT 22
22813: PUSH
22814: LD_INT 23
22816: PUSH
22817: LD_INT 24
22819: PUSH
22820: LD_INT 25
22822: PUSH
22823: LD_INT 26
22825: PUSH
22826: LD_INT 27
22828: PUSH
22829: LD_INT 28
22831: PUSH
22832: LD_INT 30
22834: PUSH
22835: LD_INT 31
22837: PUSH
22838: LD_INT 32
22840: PUSH
22841: LD_INT 33
22843: PUSH
22844: LD_INT 34
22846: PUSH
22847: LD_INT 36
22849: PUSH
22850: EMPTY
22851: LIST
22852: LIST
22853: LIST
22854: LIST
22855: LIST
22856: LIST
22857: LIST
22858: LIST
22859: LIST
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: LIST
22865: LIST
22866: LIST
22867: LIST
22868: LIST
22869: LIST
22870: LIST
22871: LIST
22872: LIST
22873: LIST
22874: LIST
22875: LIST
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: LIST
22881: LIST
22882: PUSH
22883: LD_INT 101
22885: PUSH
22886: LD_INT 102
22888: PUSH
22889: LD_INT 103
22891: PUSH
22892: LD_INT 104
22894: PUSH
22895: LD_INT 105
22897: PUSH
22898: LD_INT 106
22900: PUSH
22901: LD_INT 107
22903: PUSH
22904: LD_INT 108
22906: PUSH
22907: LD_INT 109
22909: PUSH
22910: LD_INT 110
22912: PUSH
22913: LD_INT 111
22915: PUSH
22916: LD_INT 112
22918: PUSH
22919: LD_INT 113
22921: PUSH
22922: LD_INT 114
22924: PUSH
22925: EMPTY
22926: LIST
22927: LIST
22928: LIST
22929: LIST
22930: LIST
22931: LIST
22932: LIST
22933: LIST
22934: LIST
22935: LIST
22936: LIST
22937: LIST
22938: LIST
22939: LIST
22940: PUSH
22941: EMPTY
22942: LIST
22943: LIST
22944: ST_TO_ADDR
22945: GO 24112
22947: LD_INT 14
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 23167
22955: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
22956: LD_ADDR_VAR 0 1
22960: PUSH
22961: LD_INT 1
22963: PUSH
22964: LD_INT 2
22966: PUSH
22967: LD_INT 3
22969: PUSH
22970: LD_INT 4
22972: PUSH
22973: LD_INT 5
22975: PUSH
22976: LD_INT 6
22978: PUSH
22979: LD_INT 7
22981: PUSH
22982: LD_INT 8
22984: PUSH
22985: LD_INT 9
22987: PUSH
22988: LD_INT 10
22990: PUSH
22991: LD_INT 11
22993: PUSH
22994: LD_INT 12
22996: PUSH
22997: LD_INT 13
22999: PUSH
23000: LD_INT 14
23002: PUSH
23003: LD_INT 15
23005: PUSH
23006: LD_INT 16
23008: PUSH
23009: LD_INT 17
23011: PUSH
23012: LD_INT 18
23014: PUSH
23015: LD_INT 19
23017: PUSH
23018: LD_INT 20
23020: PUSH
23021: LD_INT 21
23023: PUSH
23024: LD_INT 22
23026: PUSH
23027: LD_INT 23
23029: PUSH
23030: LD_INT 24
23032: PUSH
23033: LD_INT 25
23035: PUSH
23036: LD_INT 26
23038: PUSH
23039: LD_INT 27
23041: PUSH
23042: LD_INT 28
23044: PUSH
23045: LD_INT 29
23047: PUSH
23048: LD_INT 30
23050: PUSH
23051: LD_INT 31
23053: PUSH
23054: LD_INT 32
23056: PUSH
23057: LD_INT 33
23059: PUSH
23060: LD_INT 34
23062: PUSH
23063: LD_INT 36
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: LIST
23070: LIST
23071: LIST
23072: LIST
23073: LIST
23074: LIST
23075: LIST
23076: LIST
23077: LIST
23078: LIST
23079: LIST
23080: LIST
23081: LIST
23082: LIST
23083: LIST
23084: LIST
23085: LIST
23086: LIST
23087: LIST
23088: LIST
23089: LIST
23090: LIST
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: LIST
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: LIST
23101: LIST
23102: PUSH
23103: LD_INT 101
23105: PUSH
23106: LD_INT 102
23108: PUSH
23109: LD_INT 103
23111: PUSH
23112: LD_INT 104
23114: PUSH
23115: LD_INT 105
23117: PUSH
23118: LD_INT 106
23120: PUSH
23121: LD_INT 107
23123: PUSH
23124: LD_INT 108
23126: PUSH
23127: LD_INT 109
23129: PUSH
23130: LD_INT 110
23132: PUSH
23133: LD_INT 111
23135: PUSH
23136: LD_INT 112
23138: PUSH
23139: LD_INT 113
23141: PUSH
23142: LD_INT 114
23144: PUSH
23145: EMPTY
23146: LIST
23147: LIST
23148: LIST
23149: LIST
23150: LIST
23151: LIST
23152: LIST
23153: LIST
23154: LIST
23155: LIST
23156: LIST
23157: LIST
23158: LIST
23159: LIST
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: ST_TO_ADDR
23165: GO 24112
23167: LD_INT 15
23169: DOUBLE
23170: EQUAL
23171: IFTRUE 23175
23173: GO 23387
23175: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
23176: LD_ADDR_VAR 0 1
23180: PUSH
23181: LD_INT 1
23183: PUSH
23184: LD_INT 2
23186: PUSH
23187: LD_INT 3
23189: PUSH
23190: LD_INT 4
23192: PUSH
23193: LD_INT 5
23195: PUSH
23196: LD_INT 6
23198: PUSH
23199: LD_INT 7
23201: PUSH
23202: LD_INT 8
23204: PUSH
23205: LD_INT 9
23207: PUSH
23208: LD_INT 10
23210: PUSH
23211: LD_INT 11
23213: PUSH
23214: LD_INT 12
23216: PUSH
23217: LD_INT 13
23219: PUSH
23220: LD_INT 14
23222: PUSH
23223: LD_INT 15
23225: PUSH
23226: LD_INT 16
23228: PUSH
23229: LD_INT 17
23231: PUSH
23232: LD_INT 18
23234: PUSH
23235: LD_INT 19
23237: PUSH
23238: LD_INT 20
23240: PUSH
23241: LD_INT 21
23243: PUSH
23244: LD_INT 22
23246: PUSH
23247: LD_INT 23
23249: PUSH
23250: LD_INT 24
23252: PUSH
23253: LD_INT 25
23255: PUSH
23256: LD_INT 26
23258: PUSH
23259: LD_INT 27
23261: PUSH
23262: LD_INT 28
23264: PUSH
23265: LD_INT 29
23267: PUSH
23268: LD_INT 30
23270: PUSH
23271: LD_INT 31
23273: PUSH
23274: LD_INT 32
23276: PUSH
23277: LD_INT 33
23279: PUSH
23280: LD_INT 34
23282: PUSH
23283: LD_INT 36
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: LIST
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: LIST
23295: LIST
23296: LIST
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: LIST
23302: LIST
23303: LIST
23304: LIST
23305: LIST
23306: LIST
23307: LIST
23308: LIST
23309: LIST
23310: LIST
23311: LIST
23312: LIST
23313: LIST
23314: LIST
23315: LIST
23316: LIST
23317: LIST
23318: LIST
23319: LIST
23320: LIST
23321: LIST
23322: PUSH
23323: LD_INT 101
23325: PUSH
23326: LD_INT 102
23328: PUSH
23329: LD_INT 103
23331: PUSH
23332: LD_INT 104
23334: PUSH
23335: LD_INT 105
23337: PUSH
23338: LD_INT 106
23340: PUSH
23341: LD_INT 107
23343: PUSH
23344: LD_INT 108
23346: PUSH
23347: LD_INT 109
23349: PUSH
23350: LD_INT 110
23352: PUSH
23353: LD_INT 111
23355: PUSH
23356: LD_INT 112
23358: PUSH
23359: LD_INT 113
23361: PUSH
23362: LD_INT 114
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: LIST
23369: LIST
23370: LIST
23371: LIST
23372: LIST
23373: LIST
23374: LIST
23375: LIST
23376: LIST
23377: LIST
23378: LIST
23379: LIST
23380: PUSH
23381: EMPTY
23382: LIST
23383: LIST
23384: ST_TO_ADDR
23385: GO 24112
23387: LD_INT 16
23389: DOUBLE
23390: EQUAL
23391: IFTRUE 23395
23393: GO 23519
23395: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
23396: LD_ADDR_VAR 0 1
23400: PUSH
23401: LD_INT 2
23403: PUSH
23404: LD_INT 4
23406: PUSH
23407: LD_INT 5
23409: PUSH
23410: LD_INT 7
23412: PUSH
23413: LD_INT 11
23415: PUSH
23416: LD_INT 12
23418: PUSH
23419: LD_INT 15
23421: PUSH
23422: LD_INT 16
23424: PUSH
23425: LD_INT 20
23427: PUSH
23428: LD_INT 21
23430: PUSH
23431: LD_INT 22
23433: PUSH
23434: LD_INT 23
23436: PUSH
23437: LD_INT 25
23439: PUSH
23440: LD_INT 26
23442: PUSH
23443: LD_INT 30
23445: PUSH
23446: LD_INT 31
23448: PUSH
23449: LD_INT 32
23451: PUSH
23452: LD_INT 33
23454: PUSH
23455: LD_INT 34
23457: PUSH
23458: EMPTY
23459: LIST
23460: LIST
23461: LIST
23462: LIST
23463: LIST
23464: LIST
23465: LIST
23466: LIST
23467: LIST
23468: LIST
23469: LIST
23470: LIST
23471: LIST
23472: LIST
23473: LIST
23474: LIST
23475: LIST
23476: LIST
23477: LIST
23478: PUSH
23479: LD_INT 101
23481: PUSH
23482: LD_INT 102
23484: PUSH
23485: LD_INT 103
23487: PUSH
23488: LD_INT 106
23490: PUSH
23491: LD_INT 108
23493: PUSH
23494: LD_INT 112
23496: PUSH
23497: LD_INT 113
23499: PUSH
23500: LD_INT 114
23502: PUSH
23503: EMPTY
23504: LIST
23505: LIST
23506: LIST
23507: LIST
23508: LIST
23509: LIST
23510: LIST
23511: LIST
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: ST_TO_ADDR
23517: GO 24112
23519: LD_INT 17
23521: DOUBLE
23522: EQUAL
23523: IFTRUE 23527
23525: GO 23739
23527: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
23528: LD_ADDR_VAR 0 1
23532: PUSH
23533: LD_INT 1
23535: PUSH
23536: LD_INT 2
23538: PUSH
23539: LD_INT 3
23541: PUSH
23542: LD_INT 4
23544: PUSH
23545: LD_INT 5
23547: PUSH
23548: LD_INT 6
23550: PUSH
23551: LD_INT 7
23553: PUSH
23554: LD_INT 8
23556: PUSH
23557: LD_INT 9
23559: PUSH
23560: LD_INT 10
23562: PUSH
23563: LD_INT 11
23565: PUSH
23566: LD_INT 12
23568: PUSH
23569: LD_INT 13
23571: PUSH
23572: LD_INT 14
23574: PUSH
23575: LD_INT 15
23577: PUSH
23578: LD_INT 16
23580: PUSH
23581: LD_INT 17
23583: PUSH
23584: LD_INT 18
23586: PUSH
23587: LD_INT 19
23589: PUSH
23590: LD_INT 20
23592: PUSH
23593: LD_INT 21
23595: PUSH
23596: LD_INT 22
23598: PUSH
23599: LD_INT 23
23601: PUSH
23602: LD_INT 24
23604: PUSH
23605: LD_INT 25
23607: PUSH
23608: LD_INT 26
23610: PUSH
23611: LD_INT 27
23613: PUSH
23614: LD_INT 28
23616: PUSH
23617: LD_INT 29
23619: PUSH
23620: LD_INT 30
23622: PUSH
23623: LD_INT 31
23625: PUSH
23626: LD_INT 32
23628: PUSH
23629: LD_INT 33
23631: PUSH
23632: LD_INT 34
23634: PUSH
23635: LD_INT 36
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: LIST
23642: LIST
23643: LIST
23644: LIST
23645: LIST
23646: LIST
23647: LIST
23648: LIST
23649: LIST
23650: LIST
23651: LIST
23652: LIST
23653: LIST
23654: LIST
23655: LIST
23656: LIST
23657: LIST
23658: LIST
23659: LIST
23660: LIST
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: LIST
23666: LIST
23667: LIST
23668: LIST
23669: LIST
23670: LIST
23671: LIST
23672: LIST
23673: LIST
23674: PUSH
23675: LD_INT 101
23677: PUSH
23678: LD_INT 102
23680: PUSH
23681: LD_INT 103
23683: PUSH
23684: LD_INT 104
23686: PUSH
23687: LD_INT 105
23689: PUSH
23690: LD_INT 106
23692: PUSH
23693: LD_INT 107
23695: PUSH
23696: LD_INT 108
23698: PUSH
23699: LD_INT 109
23701: PUSH
23702: LD_INT 110
23704: PUSH
23705: LD_INT 111
23707: PUSH
23708: LD_INT 112
23710: PUSH
23711: LD_INT 113
23713: PUSH
23714: LD_INT 114
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: LIST
23721: LIST
23722: LIST
23723: LIST
23724: LIST
23725: LIST
23726: LIST
23727: LIST
23728: LIST
23729: LIST
23730: LIST
23731: LIST
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: ST_TO_ADDR
23737: GO 24112
23739: LD_INT 18
23741: DOUBLE
23742: EQUAL
23743: IFTRUE 23747
23745: GO 23883
23747: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
23748: LD_ADDR_VAR 0 1
23752: PUSH
23753: LD_INT 2
23755: PUSH
23756: LD_INT 4
23758: PUSH
23759: LD_INT 5
23761: PUSH
23762: LD_INT 7
23764: PUSH
23765: LD_INT 11
23767: PUSH
23768: LD_INT 12
23770: PUSH
23771: LD_INT 15
23773: PUSH
23774: LD_INT 16
23776: PUSH
23777: LD_INT 20
23779: PUSH
23780: LD_INT 21
23782: PUSH
23783: LD_INT 22
23785: PUSH
23786: LD_INT 23
23788: PUSH
23789: LD_INT 25
23791: PUSH
23792: LD_INT 26
23794: PUSH
23795: LD_INT 30
23797: PUSH
23798: LD_INT 31
23800: PUSH
23801: LD_INT 32
23803: PUSH
23804: LD_INT 33
23806: PUSH
23807: LD_INT 34
23809: PUSH
23810: LD_INT 35
23812: PUSH
23813: LD_INT 36
23815: PUSH
23816: EMPTY
23817: LIST
23818: LIST
23819: LIST
23820: LIST
23821: LIST
23822: LIST
23823: LIST
23824: LIST
23825: LIST
23826: LIST
23827: LIST
23828: LIST
23829: LIST
23830: LIST
23831: LIST
23832: LIST
23833: LIST
23834: LIST
23835: LIST
23836: LIST
23837: LIST
23838: PUSH
23839: LD_INT 101
23841: PUSH
23842: LD_INT 102
23844: PUSH
23845: LD_INT 103
23847: PUSH
23848: LD_INT 106
23850: PUSH
23851: LD_INT 108
23853: PUSH
23854: LD_INT 112
23856: PUSH
23857: LD_INT 113
23859: PUSH
23860: LD_INT 114
23862: PUSH
23863: LD_INT 115
23865: PUSH
23866: EMPTY
23867: LIST
23868: LIST
23869: LIST
23870: LIST
23871: LIST
23872: LIST
23873: LIST
23874: LIST
23875: LIST
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: ST_TO_ADDR
23881: GO 24112
23883: LD_INT 19
23885: DOUBLE
23886: EQUAL
23887: IFTRUE 23891
23889: GO 24111
23891: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
23892: LD_ADDR_VAR 0 1
23896: PUSH
23897: LD_INT 1
23899: PUSH
23900: LD_INT 2
23902: PUSH
23903: LD_INT 3
23905: PUSH
23906: LD_INT 4
23908: PUSH
23909: LD_INT 5
23911: PUSH
23912: LD_INT 6
23914: PUSH
23915: LD_INT 7
23917: PUSH
23918: LD_INT 8
23920: PUSH
23921: LD_INT 9
23923: PUSH
23924: LD_INT 10
23926: PUSH
23927: LD_INT 11
23929: PUSH
23930: LD_INT 12
23932: PUSH
23933: LD_INT 13
23935: PUSH
23936: LD_INT 14
23938: PUSH
23939: LD_INT 15
23941: PUSH
23942: LD_INT 16
23944: PUSH
23945: LD_INT 17
23947: PUSH
23948: LD_INT 18
23950: PUSH
23951: LD_INT 19
23953: PUSH
23954: LD_INT 20
23956: PUSH
23957: LD_INT 21
23959: PUSH
23960: LD_INT 22
23962: PUSH
23963: LD_INT 23
23965: PUSH
23966: LD_INT 24
23968: PUSH
23969: LD_INT 25
23971: PUSH
23972: LD_INT 26
23974: PUSH
23975: LD_INT 27
23977: PUSH
23978: LD_INT 28
23980: PUSH
23981: LD_INT 29
23983: PUSH
23984: LD_INT 30
23986: PUSH
23987: LD_INT 31
23989: PUSH
23990: LD_INT 32
23992: PUSH
23993: LD_INT 33
23995: PUSH
23996: LD_INT 34
23998: PUSH
23999: LD_INT 35
24001: PUSH
24002: LD_INT 36
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: LIST
24009: LIST
24010: LIST
24011: LIST
24012: LIST
24013: LIST
24014: LIST
24015: LIST
24016: LIST
24017: LIST
24018: LIST
24019: LIST
24020: LIST
24021: LIST
24022: LIST
24023: LIST
24024: LIST
24025: LIST
24026: LIST
24027: LIST
24028: LIST
24029: LIST
24030: LIST
24031: LIST
24032: LIST
24033: LIST
24034: LIST
24035: LIST
24036: LIST
24037: LIST
24038: LIST
24039: LIST
24040: LIST
24041: LIST
24042: PUSH
24043: LD_INT 101
24045: PUSH
24046: LD_INT 102
24048: PUSH
24049: LD_INT 103
24051: PUSH
24052: LD_INT 104
24054: PUSH
24055: LD_INT 105
24057: PUSH
24058: LD_INT 106
24060: PUSH
24061: LD_INT 107
24063: PUSH
24064: LD_INT 108
24066: PUSH
24067: LD_INT 109
24069: PUSH
24070: LD_INT 110
24072: PUSH
24073: LD_INT 111
24075: PUSH
24076: LD_INT 112
24078: PUSH
24079: LD_INT 113
24081: PUSH
24082: LD_INT 114
24084: PUSH
24085: LD_INT 115
24087: PUSH
24088: EMPTY
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: LIST
24094: LIST
24095: LIST
24096: LIST
24097: LIST
24098: LIST
24099: LIST
24100: LIST
24101: LIST
24102: LIST
24103: LIST
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: ST_TO_ADDR
24109: GO 24112
24111: POP
// end else
24112: GO 24331
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
24114: LD_ADDR_VAR 0 1
24118: PUSH
24119: LD_INT 1
24121: PUSH
24122: LD_INT 2
24124: PUSH
24125: LD_INT 3
24127: PUSH
24128: LD_INT 4
24130: PUSH
24131: LD_INT 5
24133: PUSH
24134: LD_INT 6
24136: PUSH
24137: LD_INT 7
24139: PUSH
24140: LD_INT 8
24142: PUSH
24143: LD_INT 9
24145: PUSH
24146: LD_INT 10
24148: PUSH
24149: LD_INT 11
24151: PUSH
24152: LD_INT 12
24154: PUSH
24155: LD_INT 13
24157: PUSH
24158: LD_INT 14
24160: PUSH
24161: LD_INT 15
24163: PUSH
24164: LD_INT 16
24166: PUSH
24167: LD_INT 17
24169: PUSH
24170: LD_INT 18
24172: PUSH
24173: LD_INT 19
24175: PUSH
24176: LD_INT 20
24178: PUSH
24179: LD_INT 21
24181: PUSH
24182: LD_INT 22
24184: PUSH
24185: LD_INT 23
24187: PUSH
24188: LD_INT 24
24190: PUSH
24191: LD_INT 25
24193: PUSH
24194: LD_INT 26
24196: PUSH
24197: LD_INT 27
24199: PUSH
24200: LD_INT 28
24202: PUSH
24203: LD_INT 29
24205: PUSH
24206: LD_INT 30
24208: PUSH
24209: LD_INT 31
24211: PUSH
24212: LD_INT 32
24214: PUSH
24215: LD_INT 33
24217: PUSH
24218: LD_INT 34
24220: PUSH
24221: LD_INT 35
24223: PUSH
24224: LD_INT 36
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: LIST
24235: LIST
24236: LIST
24237: LIST
24238: LIST
24239: LIST
24240: LIST
24241: LIST
24242: LIST
24243: LIST
24244: LIST
24245: LIST
24246: LIST
24247: LIST
24248: LIST
24249: LIST
24250: LIST
24251: LIST
24252: LIST
24253: LIST
24254: LIST
24255: LIST
24256: LIST
24257: LIST
24258: LIST
24259: LIST
24260: LIST
24261: LIST
24262: LIST
24263: LIST
24264: PUSH
24265: LD_INT 101
24267: PUSH
24268: LD_INT 102
24270: PUSH
24271: LD_INT 103
24273: PUSH
24274: LD_INT 104
24276: PUSH
24277: LD_INT 105
24279: PUSH
24280: LD_INT 106
24282: PUSH
24283: LD_INT 107
24285: PUSH
24286: LD_INT 108
24288: PUSH
24289: LD_INT 109
24291: PUSH
24292: LD_INT 110
24294: PUSH
24295: LD_INT 111
24297: PUSH
24298: LD_INT 112
24300: PUSH
24301: LD_INT 113
24303: PUSH
24304: LD_INT 114
24306: PUSH
24307: LD_INT 115
24309: PUSH
24310: EMPTY
24311: LIST
24312: LIST
24313: LIST
24314: LIST
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: LIST
24320: LIST
24321: LIST
24322: LIST
24323: LIST
24324: LIST
24325: LIST
24326: PUSH
24327: EMPTY
24328: LIST
24329: LIST
24330: ST_TO_ADDR
// if result then
24331: LD_VAR 0 1
24335: IFFALSE 24624
// begin normal :=  ;
24337: LD_ADDR_VAR 0 3
24341: PUSH
24342: LD_STRING 
24344: ST_TO_ADDR
// hardcore :=  ;
24345: LD_ADDR_VAR 0 4
24349: PUSH
24350: LD_STRING 
24352: ST_TO_ADDR
// for i = 1 to normalCounter do
24353: LD_ADDR_VAR 0 5
24357: PUSH
24358: DOUBLE
24359: LD_INT 1
24361: DEC
24362: ST_TO_ADDR
24363: LD_EXP 63
24367: PUSH
24368: FOR_TO
24369: IFFALSE 24470
// begin tmp := 0 ;
24371: LD_ADDR_VAR 0 2
24375: PUSH
24376: LD_STRING 0
24378: ST_TO_ADDR
// if result [ 1 ] then
24379: LD_VAR 0 1
24383: PUSH
24384: LD_INT 1
24386: ARRAY
24387: IFFALSE 24452
// if result [ 1 ] [ 1 ] = i then
24389: LD_VAR 0 1
24393: PUSH
24394: LD_INT 1
24396: ARRAY
24397: PUSH
24398: LD_INT 1
24400: ARRAY
24401: PUSH
24402: LD_VAR 0 5
24406: EQUAL
24407: IFFALSE 24452
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
24409: LD_ADDR_VAR 0 1
24413: PUSH
24414: LD_VAR 0 1
24418: PPUSH
24419: LD_INT 1
24421: PPUSH
24422: LD_VAR 0 1
24426: PUSH
24427: LD_INT 1
24429: ARRAY
24430: PPUSH
24431: LD_INT 1
24433: PPUSH
24434: CALL_OW 3
24438: PPUSH
24439: CALL_OW 1
24443: ST_TO_ADDR
// tmp := 1 ;
24444: LD_ADDR_VAR 0 2
24448: PUSH
24449: LD_STRING 1
24451: ST_TO_ADDR
// end ; normal := normal & tmp ;
24452: LD_ADDR_VAR 0 3
24456: PUSH
24457: LD_VAR 0 3
24461: PUSH
24462: LD_VAR 0 2
24466: STR
24467: ST_TO_ADDR
// end ;
24468: GO 24368
24470: POP
24471: POP
// for i = 1 to hardcoreCounter do
24472: LD_ADDR_VAR 0 5
24476: PUSH
24477: DOUBLE
24478: LD_INT 1
24480: DEC
24481: ST_TO_ADDR
24482: LD_EXP 64
24486: PUSH
24487: FOR_TO
24488: IFFALSE 24593
// begin tmp := 0 ;
24490: LD_ADDR_VAR 0 2
24494: PUSH
24495: LD_STRING 0
24497: ST_TO_ADDR
// if result [ 2 ] then
24498: LD_VAR 0 1
24502: PUSH
24503: LD_INT 2
24505: ARRAY
24506: IFFALSE 24575
// if result [ 2 ] [ 1 ] = 100 + i then
24508: LD_VAR 0 1
24512: PUSH
24513: LD_INT 2
24515: ARRAY
24516: PUSH
24517: LD_INT 1
24519: ARRAY
24520: PUSH
24521: LD_INT 100
24523: PUSH
24524: LD_VAR 0 5
24528: PLUS
24529: EQUAL
24530: IFFALSE 24575
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
24532: LD_ADDR_VAR 0 1
24536: PUSH
24537: LD_VAR 0 1
24541: PPUSH
24542: LD_INT 2
24544: PPUSH
24545: LD_VAR 0 1
24549: PUSH
24550: LD_INT 2
24552: ARRAY
24553: PPUSH
24554: LD_INT 1
24556: PPUSH
24557: CALL_OW 3
24561: PPUSH
24562: CALL_OW 1
24566: ST_TO_ADDR
// tmp := 1 ;
24567: LD_ADDR_VAR 0 2
24571: PUSH
24572: LD_STRING 1
24574: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
24575: LD_ADDR_VAR 0 4
24579: PUSH
24580: LD_VAR 0 4
24584: PUSH
24585: LD_VAR 0 2
24589: STR
24590: ST_TO_ADDR
// end ;
24591: GO 24487
24593: POP
24594: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
24595: LD_STRING getStreamItemsFromMission("
24597: PUSH
24598: LD_VAR 0 3
24602: STR
24603: PUSH
24604: LD_STRING ","
24606: STR
24607: PUSH
24608: LD_VAR 0 4
24612: STR
24613: PUSH
24614: LD_STRING ")
24616: STR
24617: PPUSH
24618: CALL_OW 559
// end else
24622: GO 24631
// ToLua ( getStreamItemsFromMission("","") ) ;
24624: LD_STRING getStreamItemsFromMission("","")
24626: PPUSH
24627: CALL_OW 559
// end ;
24631: LD_VAR 0 1
24635: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
24636: LD_EXP 62
24640: PUSH
24641: LD_EXP 67
24645: AND
24646: IFFALSE 24770
24648: GO 24650
24650: DISABLE
24651: LD_INT 0
24653: PPUSH
24654: PPUSH
// begin enable ;
24655: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
24656: LD_ADDR_VAR 0 2
24660: PUSH
24661: LD_INT 22
24663: PUSH
24664: LD_OWVAR 2
24668: PUSH
24669: EMPTY
24670: LIST
24671: LIST
24672: PUSH
24673: LD_INT 2
24675: PUSH
24676: LD_INT 34
24678: PUSH
24679: LD_INT 7
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: PUSH
24686: LD_INT 34
24688: PUSH
24689: LD_INT 45
24691: PUSH
24692: EMPTY
24693: LIST
24694: LIST
24695: PUSH
24696: LD_INT 34
24698: PUSH
24699: LD_INT 28
24701: PUSH
24702: EMPTY
24703: LIST
24704: LIST
24705: PUSH
24706: LD_INT 34
24708: PUSH
24709: LD_INT 47
24711: PUSH
24712: EMPTY
24713: LIST
24714: LIST
24715: PUSH
24716: EMPTY
24717: LIST
24718: LIST
24719: LIST
24720: LIST
24721: LIST
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PPUSH
24727: CALL_OW 69
24731: ST_TO_ADDR
// if not tmp then
24732: LD_VAR 0 2
24736: NOT
24737: IFFALSE 24741
// exit ;
24739: GO 24770
// for i in tmp do
24741: LD_ADDR_VAR 0 1
24745: PUSH
24746: LD_VAR 0 2
24750: PUSH
24751: FOR_IN
24752: IFFALSE 24768
// begin SetLives ( i , 0 ) ;
24754: LD_VAR 0 1
24758: PPUSH
24759: LD_INT 0
24761: PPUSH
24762: CALL_OW 234
// end ;
24766: GO 24751
24768: POP
24769: POP
// end ;
24770: PPOPN 2
24772: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
24773: LD_EXP 62
24777: PUSH
24778: LD_EXP 68
24782: AND
24783: IFFALSE 24867
24785: GO 24787
24787: DISABLE
24788: LD_INT 0
24790: PPUSH
24791: PPUSH
// begin enable ;
24792: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
24793: LD_ADDR_VAR 0 2
24797: PUSH
24798: LD_INT 22
24800: PUSH
24801: LD_OWVAR 2
24805: PUSH
24806: EMPTY
24807: LIST
24808: LIST
24809: PUSH
24810: LD_INT 32
24812: PUSH
24813: LD_INT 3
24815: PUSH
24816: EMPTY
24817: LIST
24818: LIST
24819: PUSH
24820: EMPTY
24821: LIST
24822: LIST
24823: PPUSH
24824: CALL_OW 69
24828: ST_TO_ADDR
// if not tmp then
24829: LD_VAR 0 2
24833: NOT
24834: IFFALSE 24838
// exit ;
24836: GO 24867
// for i in tmp do
24838: LD_ADDR_VAR 0 1
24842: PUSH
24843: LD_VAR 0 2
24847: PUSH
24848: FOR_IN
24849: IFFALSE 24865
// begin SetLives ( i , 0 ) ;
24851: LD_VAR 0 1
24855: PPUSH
24856: LD_INT 0
24858: PPUSH
24859: CALL_OW 234
// end ;
24863: GO 24848
24865: POP
24866: POP
// end ;
24867: PPOPN 2
24869: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
24870: LD_EXP 62
24874: PUSH
24875: LD_EXP 65
24879: AND
24880: IFFALSE 24973
24882: GO 24884
24884: DISABLE
24885: LD_INT 0
24887: PPUSH
// begin enable ;
24888: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
24889: LD_ADDR_VAR 0 1
24893: PUSH
24894: LD_INT 22
24896: PUSH
24897: LD_OWVAR 2
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PUSH
24906: LD_INT 2
24908: PUSH
24909: LD_INT 25
24911: PUSH
24912: LD_INT 5
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: PUSH
24919: LD_INT 25
24921: PUSH
24922: LD_INT 9
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PUSH
24929: LD_INT 25
24931: PUSH
24932: LD_INT 8
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: LIST
24943: LIST
24944: PUSH
24945: EMPTY
24946: LIST
24947: LIST
24948: PPUSH
24949: CALL_OW 69
24953: PUSH
24954: FOR_IN
24955: IFFALSE 24971
// begin SetClass ( i , 1 ) ;
24957: LD_VAR 0 1
24961: PPUSH
24962: LD_INT 1
24964: PPUSH
24965: CALL_OW 336
// end ;
24969: GO 24954
24971: POP
24972: POP
// end ;
24973: PPOPN 1
24975: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
24976: LD_EXP 62
24980: PUSH
24981: LD_EXP 66
24985: AND
24986: PUSH
24987: LD_OWVAR 65
24991: PUSH
24992: LD_INT 7
24994: LESS
24995: AND
24996: IFFALSE 25010
24998: GO 25000
25000: DISABLE
// begin enable ;
25001: ENABLE
// game_speed := 7 ;
25002: LD_ADDR_OWVAR 65
25006: PUSH
25007: LD_INT 7
25009: ST_TO_ADDR
// end ;
25010: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
25011: LD_EXP 62
25015: PUSH
25016: LD_EXP 69
25020: AND
25021: IFFALSE 25223
25023: GO 25025
25025: DISABLE
25026: LD_INT 0
25028: PPUSH
25029: PPUSH
25030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
25031: LD_ADDR_VAR 0 3
25035: PUSH
25036: LD_INT 81
25038: PUSH
25039: LD_OWVAR 2
25043: PUSH
25044: EMPTY
25045: LIST
25046: LIST
25047: PUSH
25048: LD_INT 21
25050: PUSH
25051: LD_INT 1
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: PPUSH
25062: CALL_OW 69
25066: ST_TO_ADDR
// if not tmp then
25067: LD_VAR 0 3
25071: NOT
25072: IFFALSE 25076
// exit ;
25074: GO 25223
// if tmp > 5 then
25076: LD_VAR 0 3
25080: PUSH
25081: LD_INT 5
25083: GREATER
25084: IFFALSE 25096
// k := 5 else
25086: LD_ADDR_VAR 0 2
25090: PUSH
25091: LD_INT 5
25093: ST_TO_ADDR
25094: GO 25106
// k := tmp ;
25096: LD_ADDR_VAR 0 2
25100: PUSH
25101: LD_VAR 0 3
25105: ST_TO_ADDR
// for i := 1 to k do
25106: LD_ADDR_VAR 0 1
25110: PUSH
25111: DOUBLE
25112: LD_INT 1
25114: DEC
25115: ST_TO_ADDR
25116: LD_VAR 0 2
25120: PUSH
25121: FOR_TO
25122: IFFALSE 25221
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
25124: LD_VAR 0 3
25128: PUSH
25129: LD_VAR 0 1
25133: ARRAY
25134: PPUSH
25135: LD_VAR 0 1
25139: PUSH
25140: LD_INT 4
25142: MOD
25143: PUSH
25144: LD_INT 1
25146: PLUS
25147: PPUSH
25148: CALL_OW 259
25152: PUSH
25153: LD_INT 10
25155: LESS
25156: IFFALSE 25219
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
25158: LD_VAR 0 3
25162: PUSH
25163: LD_VAR 0 1
25167: ARRAY
25168: PPUSH
25169: LD_VAR 0 1
25173: PUSH
25174: LD_INT 4
25176: MOD
25177: PUSH
25178: LD_INT 1
25180: PLUS
25181: PPUSH
25182: LD_VAR 0 3
25186: PUSH
25187: LD_VAR 0 1
25191: ARRAY
25192: PPUSH
25193: LD_VAR 0 1
25197: PUSH
25198: LD_INT 4
25200: MOD
25201: PUSH
25202: LD_INT 1
25204: PLUS
25205: PPUSH
25206: CALL_OW 259
25210: PUSH
25211: LD_INT 1
25213: PLUS
25214: PPUSH
25215: CALL_OW 237
25219: GO 25121
25221: POP
25222: POP
// end ;
25223: PPOPN 3
25225: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
25226: LD_EXP 62
25230: PUSH
25231: LD_EXP 70
25235: AND
25236: IFFALSE 25256
25238: GO 25240
25240: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
25241: LD_INT 4
25243: PPUSH
25244: LD_OWVAR 2
25248: PPUSH
25249: LD_INT 0
25251: PPUSH
25252: CALL_OW 324
25256: END
// every 0 0$1 trigger StreamModeActive and sShovel do
25257: LD_EXP 62
25261: PUSH
25262: LD_EXP 99
25266: AND
25267: IFFALSE 25287
25269: GO 25271
25271: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
25272: LD_INT 19
25274: PPUSH
25275: LD_OWVAR 2
25279: PPUSH
25280: LD_INT 0
25282: PPUSH
25283: CALL_OW 324
25287: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
25288: LD_EXP 62
25292: PUSH
25293: LD_EXP 71
25297: AND
25298: IFFALSE 25400
25300: GO 25302
25302: DISABLE
25303: LD_INT 0
25305: PPUSH
25306: PPUSH
// begin enable ;
25307: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
25308: LD_ADDR_VAR 0 2
25312: PUSH
25313: LD_INT 22
25315: PUSH
25316: LD_OWVAR 2
25320: PUSH
25321: EMPTY
25322: LIST
25323: LIST
25324: PUSH
25325: LD_INT 2
25327: PUSH
25328: LD_INT 34
25330: PUSH
25331: LD_INT 11
25333: PUSH
25334: EMPTY
25335: LIST
25336: LIST
25337: PUSH
25338: LD_INT 34
25340: PUSH
25341: LD_INT 30
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: LIST
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: PPUSH
25357: CALL_OW 69
25361: ST_TO_ADDR
// if not tmp then
25362: LD_VAR 0 2
25366: NOT
25367: IFFALSE 25371
// exit ;
25369: GO 25400
// for i in tmp do
25371: LD_ADDR_VAR 0 1
25375: PUSH
25376: LD_VAR 0 2
25380: PUSH
25381: FOR_IN
25382: IFFALSE 25398
// begin SetLives ( i , 0 ) ;
25384: LD_VAR 0 1
25388: PPUSH
25389: LD_INT 0
25391: PPUSH
25392: CALL_OW 234
// end ;
25396: GO 25381
25398: POP
25399: POP
// end ;
25400: PPOPN 2
25402: END
// every 0 0$1 trigger StreamModeActive and sBunker do
25403: LD_EXP 62
25407: PUSH
25408: LD_EXP 72
25412: AND
25413: IFFALSE 25433
25415: GO 25417
25417: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
25418: LD_INT 32
25420: PPUSH
25421: LD_OWVAR 2
25425: PPUSH
25426: LD_INT 0
25428: PPUSH
25429: CALL_OW 324
25433: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
25434: LD_EXP 62
25438: PUSH
25439: LD_EXP 73
25443: AND
25444: IFFALSE 25625
25446: GO 25448
25448: DISABLE
25449: LD_INT 0
25451: PPUSH
25452: PPUSH
25453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
25454: LD_ADDR_VAR 0 2
25458: PUSH
25459: LD_INT 22
25461: PUSH
25462: LD_OWVAR 2
25466: PUSH
25467: EMPTY
25468: LIST
25469: LIST
25470: PUSH
25471: LD_INT 33
25473: PUSH
25474: LD_INT 3
25476: PUSH
25477: EMPTY
25478: LIST
25479: LIST
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PPUSH
25485: CALL_OW 69
25489: ST_TO_ADDR
// if not tmp then
25490: LD_VAR 0 2
25494: NOT
25495: IFFALSE 25499
// exit ;
25497: GO 25625
// side := 0 ;
25499: LD_ADDR_VAR 0 3
25503: PUSH
25504: LD_INT 0
25506: ST_TO_ADDR
// for i := 1 to 8 do
25507: LD_ADDR_VAR 0 1
25511: PUSH
25512: DOUBLE
25513: LD_INT 1
25515: DEC
25516: ST_TO_ADDR
25517: LD_INT 8
25519: PUSH
25520: FOR_TO
25521: IFFALSE 25569
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
25523: LD_OWVAR 2
25527: PUSH
25528: LD_VAR 0 1
25532: NONEQUAL
25533: PUSH
25534: LD_OWVAR 2
25538: PPUSH
25539: LD_VAR 0 1
25543: PPUSH
25544: CALL_OW 81
25548: PUSH
25549: LD_INT 2
25551: EQUAL
25552: AND
25553: IFFALSE 25567
// begin side := i ;
25555: LD_ADDR_VAR 0 3
25559: PUSH
25560: LD_VAR 0 1
25564: ST_TO_ADDR
// break ;
25565: GO 25569
// end ;
25567: GO 25520
25569: POP
25570: POP
// if not side then
25571: LD_VAR 0 3
25575: NOT
25576: IFFALSE 25580
// exit ;
25578: GO 25625
// for i := 1 to tmp do
25580: LD_ADDR_VAR 0 1
25584: PUSH
25585: DOUBLE
25586: LD_INT 1
25588: DEC
25589: ST_TO_ADDR
25590: LD_VAR 0 2
25594: PUSH
25595: FOR_TO
25596: IFFALSE 25623
// if Prob ( 60 ) then
25598: LD_INT 60
25600: PPUSH
25601: CALL_OW 13
25605: IFFALSE 25621
// SetSide ( i , side ) ;
25607: LD_VAR 0 1
25611: PPUSH
25612: LD_VAR 0 3
25616: PPUSH
25617: CALL_OW 235
25621: GO 25595
25623: POP
25624: POP
// end ;
25625: PPOPN 3
25627: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
25628: LD_EXP 62
25632: PUSH
25633: LD_EXP 75
25637: AND
25638: IFFALSE 25757
25640: GO 25642
25642: DISABLE
25643: LD_INT 0
25645: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
25646: LD_ADDR_VAR 0 1
25650: PUSH
25651: LD_INT 22
25653: PUSH
25654: LD_OWVAR 2
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 21
25665: PUSH
25666: LD_INT 1
25668: PUSH
25669: EMPTY
25670: LIST
25671: LIST
25672: PUSH
25673: LD_INT 3
25675: PUSH
25676: LD_INT 23
25678: PUSH
25679: LD_INT 0
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: EMPTY
25691: LIST
25692: LIST
25693: LIST
25694: PPUSH
25695: CALL_OW 69
25699: PUSH
25700: FOR_IN
25701: IFFALSE 25755
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
25703: LD_VAR 0 1
25707: PPUSH
25708: CALL_OW 257
25712: PUSH
25713: LD_INT 1
25715: PUSH
25716: LD_INT 2
25718: PUSH
25719: LD_INT 3
25721: PUSH
25722: LD_INT 4
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: LIST
25729: LIST
25730: IN
25731: IFFALSE 25753
// SetClass ( un , rand ( 1 , 4 ) ) ;
25733: LD_VAR 0 1
25737: PPUSH
25738: LD_INT 1
25740: PPUSH
25741: LD_INT 4
25743: PPUSH
25744: CALL_OW 12
25748: PPUSH
25749: CALL_OW 336
25753: GO 25700
25755: POP
25756: POP
// end ;
25757: PPOPN 1
25759: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
25760: LD_EXP 62
25764: PUSH
25765: LD_EXP 74
25769: AND
25770: IFFALSE 25849
25772: GO 25774
25774: DISABLE
25775: LD_INT 0
25777: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
25778: LD_ADDR_VAR 0 1
25782: PUSH
25783: LD_INT 22
25785: PUSH
25786: LD_OWVAR 2
25790: PUSH
25791: EMPTY
25792: LIST
25793: LIST
25794: PUSH
25795: LD_INT 21
25797: PUSH
25798: LD_INT 3
25800: PUSH
25801: EMPTY
25802: LIST
25803: LIST
25804: PUSH
25805: EMPTY
25806: LIST
25807: LIST
25808: PPUSH
25809: CALL_OW 69
25813: ST_TO_ADDR
// if not tmp then
25814: LD_VAR 0 1
25818: NOT
25819: IFFALSE 25823
// exit ;
25821: GO 25849
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
25823: LD_VAR 0 1
25827: PUSH
25828: LD_INT 1
25830: PPUSH
25831: LD_VAR 0 1
25835: PPUSH
25836: CALL_OW 12
25840: ARRAY
25841: PPUSH
25842: LD_INT 100
25844: PPUSH
25845: CALL_OW 234
// end ;
25849: PPOPN 1
25851: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
25852: LD_EXP 62
25856: PUSH
25857: LD_EXP 76
25861: AND
25862: IFFALSE 25960
25864: GO 25866
25866: DISABLE
25867: LD_INT 0
25869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
25870: LD_ADDR_VAR 0 1
25874: PUSH
25875: LD_INT 22
25877: PUSH
25878: LD_OWVAR 2
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: PUSH
25887: LD_INT 21
25889: PUSH
25890: LD_INT 1
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: EMPTY
25898: LIST
25899: LIST
25900: PPUSH
25901: CALL_OW 69
25905: ST_TO_ADDR
// if not tmp then
25906: LD_VAR 0 1
25910: NOT
25911: IFFALSE 25915
// exit ;
25913: GO 25960
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
25915: LD_VAR 0 1
25919: PUSH
25920: LD_INT 1
25922: PPUSH
25923: LD_VAR 0 1
25927: PPUSH
25928: CALL_OW 12
25932: ARRAY
25933: PPUSH
25934: LD_INT 1
25936: PPUSH
25937: LD_INT 4
25939: PPUSH
25940: CALL_OW 12
25944: PPUSH
25945: LD_INT 3000
25947: PPUSH
25948: LD_INT 9000
25950: PPUSH
25951: CALL_OW 12
25955: PPUSH
25956: CALL_OW 492
// end ;
25960: PPOPN 1
25962: END
// every 0 0$1 trigger StreamModeActive and sDepot do
25963: LD_EXP 62
25967: PUSH
25968: LD_EXP 77
25972: AND
25973: IFFALSE 25993
25975: GO 25977
25977: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
25978: LD_INT 1
25980: PPUSH
25981: LD_OWVAR 2
25985: PPUSH
25986: LD_INT 0
25988: PPUSH
25989: CALL_OW 324
25993: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
25994: LD_EXP 62
25998: PUSH
25999: LD_EXP 78
26003: AND
26004: IFFALSE 26087
26006: GO 26008
26008: DISABLE
26009: LD_INT 0
26011: PPUSH
26012: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
26013: LD_ADDR_VAR 0 2
26017: PUSH
26018: LD_INT 22
26020: PUSH
26021: LD_OWVAR 2
26025: PUSH
26026: EMPTY
26027: LIST
26028: LIST
26029: PUSH
26030: LD_INT 21
26032: PUSH
26033: LD_INT 3
26035: PUSH
26036: EMPTY
26037: LIST
26038: LIST
26039: PUSH
26040: EMPTY
26041: LIST
26042: LIST
26043: PPUSH
26044: CALL_OW 69
26048: ST_TO_ADDR
// if not tmp then
26049: LD_VAR 0 2
26053: NOT
26054: IFFALSE 26058
// exit ;
26056: GO 26087
// for i in tmp do
26058: LD_ADDR_VAR 0 1
26062: PUSH
26063: LD_VAR 0 2
26067: PUSH
26068: FOR_IN
26069: IFFALSE 26085
// SetBLevel ( i , 10 ) ;
26071: LD_VAR 0 1
26075: PPUSH
26076: LD_INT 10
26078: PPUSH
26079: CALL_OW 241
26083: GO 26068
26085: POP
26086: POP
// end ;
26087: PPOPN 2
26089: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
26090: LD_EXP 62
26094: PUSH
26095: LD_EXP 79
26099: AND
26100: IFFALSE 26211
26102: GO 26104
26104: DISABLE
26105: LD_INT 0
26107: PPUSH
26108: PPUSH
26109: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26110: LD_ADDR_VAR 0 3
26114: PUSH
26115: LD_INT 22
26117: PUSH
26118: LD_OWVAR 2
26122: PUSH
26123: EMPTY
26124: LIST
26125: LIST
26126: PUSH
26127: LD_INT 25
26129: PUSH
26130: LD_INT 1
26132: PUSH
26133: EMPTY
26134: LIST
26135: LIST
26136: PUSH
26137: EMPTY
26138: LIST
26139: LIST
26140: PPUSH
26141: CALL_OW 69
26145: ST_TO_ADDR
// if not tmp then
26146: LD_VAR 0 3
26150: NOT
26151: IFFALSE 26155
// exit ;
26153: GO 26211
// un := tmp [ rand ( 1 , tmp ) ] ;
26155: LD_ADDR_VAR 0 2
26159: PUSH
26160: LD_VAR 0 3
26164: PUSH
26165: LD_INT 1
26167: PPUSH
26168: LD_VAR 0 3
26172: PPUSH
26173: CALL_OW 12
26177: ARRAY
26178: ST_TO_ADDR
// if Crawls ( un ) then
26179: LD_VAR 0 2
26183: PPUSH
26184: CALL_OW 318
26188: IFFALSE 26199
// ComWalk ( un ) ;
26190: LD_VAR 0 2
26194: PPUSH
26195: CALL_OW 138
// SetClass ( un , class_sniper ) ;
26199: LD_VAR 0 2
26203: PPUSH
26204: LD_INT 5
26206: PPUSH
26207: CALL_OW 336
// end ;
26211: PPOPN 3
26213: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
26214: LD_EXP 62
26218: PUSH
26219: LD_EXP 80
26223: AND
26224: PUSH
26225: LD_OWVAR 67
26229: PUSH
26230: LD_INT 3
26232: LESS
26233: AND
26234: IFFALSE 26253
26236: GO 26238
26238: DISABLE
// Difficulty := Difficulty + 1 ;
26239: LD_ADDR_OWVAR 67
26243: PUSH
26244: LD_OWVAR 67
26248: PUSH
26249: LD_INT 1
26251: PLUS
26252: ST_TO_ADDR
26253: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
26254: LD_EXP 62
26258: PUSH
26259: LD_EXP 81
26263: AND
26264: IFFALSE 26367
26266: GO 26268
26268: DISABLE
26269: LD_INT 0
26271: PPUSH
// begin for i := 1 to 5 do
26272: LD_ADDR_VAR 0 1
26276: PUSH
26277: DOUBLE
26278: LD_INT 1
26280: DEC
26281: ST_TO_ADDR
26282: LD_INT 5
26284: PUSH
26285: FOR_TO
26286: IFFALSE 26365
// begin uc_nation := nation_nature ;
26288: LD_ADDR_OWVAR 21
26292: PUSH
26293: LD_INT 0
26295: ST_TO_ADDR
// uc_side := 0 ;
26296: LD_ADDR_OWVAR 20
26300: PUSH
26301: LD_INT 0
26303: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
26304: LD_ADDR_OWVAR 29
26308: PUSH
26309: LD_INT 12
26311: PUSH
26312: LD_INT 12
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: ST_TO_ADDR
// hc_agressivity := 20 ;
26319: LD_ADDR_OWVAR 35
26323: PUSH
26324: LD_INT 20
26326: ST_TO_ADDR
// hc_class := class_tiger ;
26327: LD_ADDR_OWVAR 28
26331: PUSH
26332: LD_INT 14
26334: ST_TO_ADDR
// hc_gallery :=  ;
26335: LD_ADDR_OWVAR 33
26339: PUSH
26340: LD_STRING 
26342: ST_TO_ADDR
// hc_name :=  ;
26343: LD_ADDR_OWVAR 26
26347: PUSH
26348: LD_STRING 
26350: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
26351: CALL_OW 44
26355: PPUSH
26356: LD_INT 0
26358: PPUSH
26359: CALL_OW 51
// end ;
26363: GO 26285
26365: POP
26366: POP
// end ;
26367: PPOPN 1
26369: END
// every 0 0$1 trigger StreamModeActive and sBomb do
26370: LD_EXP 62
26374: PUSH
26375: LD_EXP 82
26379: AND
26380: IFFALSE 26389
26382: GO 26384
26384: DISABLE
// StreamSibBomb ;
26385: CALL 26390 0 0
26389: END
// export function StreamSibBomb ; var i , x , y ; begin
26390: LD_INT 0
26392: PPUSH
26393: PPUSH
26394: PPUSH
26395: PPUSH
// result := false ;
26396: LD_ADDR_VAR 0 1
26400: PUSH
26401: LD_INT 0
26403: ST_TO_ADDR
// for i := 1 to 16 do
26404: LD_ADDR_VAR 0 2
26408: PUSH
26409: DOUBLE
26410: LD_INT 1
26412: DEC
26413: ST_TO_ADDR
26414: LD_INT 16
26416: PUSH
26417: FOR_TO
26418: IFFALSE 26617
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
26420: LD_ADDR_VAR 0 3
26424: PUSH
26425: LD_INT 10
26427: PUSH
26428: LD_INT 20
26430: PUSH
26431: LD_INT 30
26433: PUSH
26434: LD_INT 40
26436: PUSH
26437: LD_INT 50
26439: PUSH
26440: LD_INT 60
26442: PUSH
26443: LD_INT 70
26445: PUSH
26446: LD_INT 80
26448: PUSH
26449: LD_INT 90
26451: PUSH
26452: LD_INT 100
26454: PUSH
26455: LD_INT 110
26457: PUSH
26458: LD_INT 120
26460: PUSH
26461: LD_INT 130
26463: PUSH
26464: LD_INT 140
26466: PUSH
26467: LD_INT 150
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: LIST
26474: LIST
26475: LIST
26476: LIST
26477: LIST
26478: LIST
26479: LIST
26480: LIST
26481: LIST
26482: LIST
26483: LIST
26484: LIST
26485: LIST
26486: PUSH
26487: LD_INT 1
26489: PPUSH
26490: LD_INT 15
26492: PPUSH
26493: CALL_OW 12
26497: ARRAY
26498: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
26499: LD_ADDR_VAR 0 4
26503: PUSH
26504: LD_INT 10
26506: PUSH
26507: LD_INT 20
26509: PUSH
26510: LD_INT 30
26512: PUSH
26513: LD_INT 40
26515: PUSH
26516: LD_INT 50
26518: PUSH
26519: LD_INT 60
26521: PUSH
26522: LD_INT 70
26524: PUSH
26525: LD_INT 80
26527: PUSH
26528: LD_INT 90
26530: PUSH
26531: LD_INT 100
26533: PUSH
26534: LD_INT 110
26536: PUSH
26537: LD_INT 120
26539: PUSH
26540: LD_INT 130
26542: PUSH
26543: LD_INT 140
26545: PUSH
26546: LD_INT 150
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 1
26568: PPUSH
26569: LD_INT 15
26571: PPUSH
26572: CALL_OW 12
26576: ARRAY
26577: ST_TO_ADDR
// if ValidHex ( x , y ) then
26578: LD_VAR 0 3
26582: PPUSH
26583: LD_VAR 0 4
26587: PPUSH
26588: CALL_OW 488
26592: IFFALSE 26615
// begin result := [ x , y ] ;
26594: LD_ADDR_VAR 0 1
26598: PUSH
26599: LD_VAR 0 3
26603: PUSH
26604: LD_VAR 0 4
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: ST_TO_ADDR
// break ;
26613: GO 26617
// end ; end ;
26615: GO 26417
26617: POP
26618: POP
// if result then
26619: LD_VAR 0 1
26623: IFFALSE 26683
// begin ToLua ( playSibBomb() ) ;
26625: LD_STRING playSibBomb()
26627: PPUSH
26628: CALL_OW 559
// wait ( 0 0$14 ) ;
26632: LD_INT 490
26634: PPUSH
26635: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
26639: LD_VAR 0 1
26643: PUSH
26644: LD_INT 1
26646: ARRAY
26647: PPUSH
26648: LD_VAR 0 1
26652: PUSH
26653: LD_INT 2
26655: ARRAY
26656: PPUSH
26657: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
26661: LD_VAR 0 1
26665: PUSH
26666: LD_INT 1
26668: ARRAY
26669: PPUSH
26670: LD_VAR 0 1
26674: PUSH
26675: LD_INT 2
26677: ARRAY
26678: PPUSH
26679: CALL_OW 429
// end ; end ;
26683: LD_VAR 0 1
26687: RET
// every 0 0$1 trigger StreamModeActive and sReset do
26688: LD_EXP 62
26692: PUSH
26693: LD_EXP 84
26697: AND
26698: IFFALSE 26710
26700: GO 26702
26702: DISABLE
// YouLost (  ) ;
26703: LD_STRING 
26705: PPUSH
26706: CALL_OW 104
26710: END
// every 0 0$1 trigger StreamModeActive and sFog do
26711: LD_EXP 62
26715: PUSH
26716: LD_EXP 83
26720: AND
26721: IFFALSE 26735
26723: GO 26725
26725: DISABLE
// FogOff ( your_side ) ;
26726: LD_OWVAR 2
26730: PPUSH
26731: CALL_OW 344
26735: END
// every 0 0$1 trigger StreamModeActive and sSun do
26736: LD_EXP 62
26740: PUSH
26741: LD_EXP 85
26745: AND
26746: IFFALSE 26774
26748: GO 26750
26750: DISABLE
// begin solar_recharge_percent := 0 ;
26751: LD_ADDR_OWVAR 79
26755: PUSH
26756: LD_INT 0
26758: ST_TO_ADDR
// wait ( 5 5$00 ) ;
26759: LD_INT 10500
26761: PPUSH
26762: CALL_OW 67
// solar_recharge_percent := 100 ;
26766: LD_ADDR_OWVAR 79
26770: PUSH
26771: LD_INT 100
26773: ST_TO_ADDR
// end ;
26774: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
26775: LD_EXP 62
26779: PUSH
26780: LD_EXP 86
26784: AND
26785: IFFALSE 27024
26787: GO 26789
26789: DISABLE
26790: LD_INT 0
26792: PPUSH
26793: PPUSH
26794: PPUSH
// begin tmp := [ ] ;
26795: LD_ADDR_VAR 0 3
26799: PUSH
26800: EMPTY
26801: ST_TO_ADDR
// for i := 1 to 6 do
26802: LD_ADDR_VAR 0 1
26806: PUSH
26807: DOUBLE
26808: LD_INT 1
26810: DEC
26811: ST_TO_ADDR
26812: LD_INT 6
26814: PUSH
26815: FOR_TO
26816: IFFALSE 26921
// begin uc_nation := nation_nature ;
26818: LD_ADDR_OWVAR 21
26822: PUSH
26823: LD_INT 0
26825: ST_TO_ADDR
// uc_side := 0 ;
26826: LD_ADDR_OWVAR 20
26830: PUSH
26831: LD_INT 0
26833: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
26834: LD_ADDR_OWVAR 29
26838: PUSH
26839: LD_INT 12
26841: PUSH
26842: LD_INT 12
26844: PUSH
26845: EMPTY
26846: LIST
26847: LIST
26848: ST_TO_ADDR
// hc_agressivity := 20 ;
26849: LD_ADDR_OWVAR 35
26853: PUSH
26854: LD_INT 20
26856: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
26857: LD_ADDR_OWVAR 28
26861: PUSH
26862: LD_INT 17
26864: ST_TO_ADDR
// hc_gallery :=  ;
26865: LD_ADDR_OWVAR 33
26869: PUSH
26870: LD_STRING 
26872: ST_TO_ADDR
// hc_name :=  ;
26873: LD_ADDR_OWVAR 26
26877: PUSH
26878: LD_STRING 
26880: ST_TO_ADDR
// un := CreateHuman ;
26881: LD_ADDR_VAR 0 2
26885: PUSH
26886: CALL_OW 44
26890: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
26891: LD_VAR 0 2
26895: PPUSH
26896: LD_INT 1
26898: PPUSH
26899: CALL_OW 51
// tmp := tmp ^ un ;
26903: LD_ADDR_VAR 0 3
26907: PUSH
26908: LD_VAR 0 3
26912: PUSH
26913: LD_VAR 0 2
26917: ADD
26918: ST_TO_ADDR
// end ;
26919: GO 26815
26921: POP
26922: POP
// repeat wait ( 0 0$1 ) ;
26923: LD_INT 35
26925: PPUSH
26926: CALL_OW 67
// for un in tmp do
26930: LD_ADDR_VAR 0 2
26934: PUSH
26935: LD_VAR 0 3
26939: PUSH
26940: FOR_IN
26941: IFFALSE 27015
// begin if IsDead ( un ) then
26943: LD_VAR 0 2
26947: PPUSH
26948: CALL_OW 301
26952: IFFALSE 26972
// begin tmp := tmp diff un ;
26954: LD_ADDR_VAR 0 3
26958: PUSH
26959: LD_VAR 0 3
26963: PUSH
26964: LD_VAR 0 2
26968: DIFF
26969: ST_TO_ADDR
// continue ;
26970: GO 26940
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
26972: LD_VAR 0 2
26976: PPUSH
26977: LD_INT 3
26979: PUSH
26980: LD_INT 22
26982: PUSH
26983: LD_INT 0
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PUSH
26990: EMPTY
26991: LIST
26992: LIST
26993: PPUSH
26994: CALL_OW 69
26998: PPUSH
26999: LD_VAR 0 2
27003: PPUSH
27004: CALL_OW 74
27008: PPUSH
27009: CALL_OW 115
// end ;
27013: GO 26940
27015: POP
27016: POP
// until not tmp ;
27017: LD_VAR 0 3
27021: NOT
27022: IFFALSE 26923
// end ;
27024: PPOPN 3
27026: END
// every 0 0$1 trigger StreamModeActive and sTroll do
27027: LD_EXP 62
27031: PUSH
27032: LD_EXP 87
27036: AND
27037: IFFALSE 27091
27039: GO 27041
27041: DISABLE
// begin ToLua ( displayTroll(); ) ;
27042: LD_STRING displayTroll();
27044: PPUSH
27045: CALL_OW 559
// wait ( 3 3$00 ) ;
27049: LD_INT 6300
27051: PPUSH
27052: CALL_OW 67
// ToLua ( hideTroll(); ) ;
27056: LD_STRING hideTroll();
27058: PPUSH
27059: CALL_OW 559
// wait ( 1 1$00 ) ;
27063: LD_INT 2100
27065: PPUSH
27066: CALL_OW 67
// ToLua ( displayTroll(); ) ;
27070: LD_STRING displayTroll();
27072: PPUSH
27073: CALL_OW 559
// wait ( 1 1$00 ) ;
27077: LD_INT 2100
27079: PPUSH
27080: CALL_OW 67
// ToLua ( hideTroll(); ) ;
27084: LD_STRING hideTroll();
27086: PPUSH
27087: CALL_OW 559
// end ;
27091: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
27092: LD_EXP 62
27096: PUSH
27097: LD_EXP 88
27101: AND
27102: IFFALSE 27165
27104: GO 27106
27106: DISABLE
27107: LD_INT 0
27109: PPUSH
// begin p := 0 ;
27110: LD_ADDR_VAR 0 1
27114: PUSH
27115: LD_INT 0
27117: ST_TO_ADDR
// repeat game_speed := 1 ;
27118: LD_ADDR_OWVAR 65
27122: PUSH
27123: LD_INT 1
27125: ST_TO_ADDR
// wait ( 0 0$1 ) ;
27126: LD_INT 35
27128: PPUSH
27129: CALL_OW 67
// p := p + 1 ;
27133: LD_ADDR_VAR 0 1
27137: PUSH
27138: LD_VAR 0 1
27142: PUSH
27143: LD_INT 1
27145: PLUS
27146: ST_TO_ADDR
// until p >= 60 ;
27147: LD_VAR 0 1
27151: PUSH
27152: LD_INT 60
27154: GREATEREQUAL
27155: IFFALSE 27118
// game_speed := 4 ;
27157: LD_ADDR_OWVAR 65
27161: PUSH
27162: LD_INT 4
27164: ST_TO_ADDR
// end ;
27165: PPOPN 1
27167: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
27168: LD_EXP 62
27172: PUSH
27173: LD_EXP 89
27177: AND
27178: IFFALSE 27324
27180: GO 27182
27182: DISABLE
27183: LD_INT 0
27185: PPUSH
27186: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27187: LD_ADDR_VAR 0 1
27191: PUSH
27192: LD_INT 22
27194: PUSH
27195: LD_OWVAR 2
27199: PUSH
27200: EMPTY
27201: LIST
27202: LIST
27203: PUSH
27204: LD_INT 2
27206: PUSH
27207: LD_INT 30
27209: PUSH
27210: LD_INT 0
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: PUSH
27217: LD_INT 30
27219: PUSH
27220: LD_INT 1
27222: PUSH
27223: EMPTY
27224: LIST
27225: LIST
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: LIST
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PPUSH
27236: CALL_OW 69
27240: ST_TO_ADDR
// if not depot then
27241: LD_VAR 0 1
27245: NOT
27246: IFFALSE 27250
// exit ;
27248: GO 27324
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
27250: LD_ADDR_VAR 0 2
27254: PUSH
27255: LD_VAR 0 1
27259: PUSH
27260: LD_INT 1
27262: PPUSH
27263: LD_VAR 0 1
27267: PPUSH
27268: CALL_OW 12
27272: ARRAY
27273: PPUSH
27274: CALL_OW 274
27278: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
27279: LD_VAR 0 2
27283: PPUSH
27284: LD_INT 1
27286: PPUSH
27287: LD_INT 0
27289: PPUSH
27290: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
27294: LD_VAR 0 2
27298: PPUSH
27299: LD_INT 2
27301: PPUSH
27302: LD_INT 0
27304: PPUSH
27305: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
27309: LD_VAR 0 2
27313: PPUSH
27314: LD_INT 3
27316: PPUSH
27317: LD_INT 0
27319: PPUSH
27320: CALL_OW 277
// end ;
27324: PPOPN 2
27326: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
27327: LD_EXP 62
27331: PUSH
27332: LD_EXP 90
27336: AND
27337: IFFALSE 27434
27339: GO 27341
27341: DISABLE
27342: LD_INT 0
27344: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
27345: LD_ADDR_VAR 0 1
27349: PUSH
27350: LD_INT 22
27352: PUSH
27353: LD_OWVAR 2
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: PUSH
27362: LD_INT 21
27364: PUSH
27365: LD_INT 1
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: LD_INT 3
27374: PUSH
27375: LD_INT 23
27377: PUSH
27378: LD_INT 0
27380: PUSH
27381: EMPTY
27382: LIST
27383: LIST
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: LIST
27393: PPUSH
27394: CALL_OW 69
27398: ST_TO_ADDR
// if not tmp then
27399: LD_VAR 0 1
27403: NOT
27404: IFFALSE 27408
// exit ;
27406: GO 27434
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
27408: LD_VAR 0 1
27412: PUSH
27413: LD_INT 1
27415: PPUSH
27416: LD_VAR 0 1
27420: PPUSH
27421: CALL_OW 12
27425: ARRAY
27426: PPUSH
27427: LD_INT 200
27429: PPUSH
27430: CALL_OW 234
// end ;
27434: PPOPN 1
27436: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
27437: LD_EXP 62
27441: PUSH
27442: LD_EXP 91
27446: AND
27447: IFFALSE 27526
27449: GO 27451
27451: DISABLE
27452: LD_INT 0
27454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
27455: LD_ADDR_VAR 0 1
27459: PUSH
27460: LD_INT 22
27462: PUSH
27463: LD_OWVAR 2
27467: PUSH
27468: EMPTY
27469: LIST
27470: LIST
27471: PUSH
27472: LD_INT 21
27474: PUSH
27475: LD_INT 2
27477: PUSH
27478: EMPTY
27479: LIST
27480: LIST
27481: PUSH
27482: EMPTY
27483: LIST
27484: LIST
27485: PPUSH
27486: CALL_OW 69
27490: ST_TO_ADDR
// if not tmp then
27491: LD_VAR 0 1
27495: NOT
27496: IFFALSE 27500
// exit ;
27498: GO 27526
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
27500: LD_VAR 0 1
27504: PUSH
27505: LD_INT 1
27507: PPUSH
27508: LD_VAR 0 1
27512: PPUSH
27513: CALL_OW 12
27517: ARRAY
27518: PPUSH
27519: LD_INT 60
27521: PPUSH
27522: CALL_OW 234
// end ;
27526: PPOPN 1
27528: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
27529: LD_EXP 62
27533: PUSH
27534: LD_EXP 92
27538: AND
27539: IFFALSE 27638
27541: GO 27543
27543: DISABLE
27544: LD_INT 0
27546: PPUSH
27547: PPUSH
// begin enable ;
27548: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
27549: LD_ADDR_VAR 0 1
27553: PUSH
27554: LD_INT 22
27556: PUSH
27557: LD_OWVAR 2
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 61
27568: PUSH
27569: EMPTY
27570: LIST
27571: PUSH
27572: LD_INT 33
27574: PUSH
27575: LD_INT 2
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: PPUSH
27587: CALL_OW 69
27591: ST_TO_ADDR
// if not tmp then
27592: LD_VAR 0 1
27596: NOT
27597: IFFALSE 27601
// exit ;
27599: GO 27638
// for i in tmp do
27601: LD_ADDR_VAR 0 2
27605: PUSH
27606: LD_VAR 0 1
27610: PUSH
27611: FOR_IN
27612: IFFALSE 27636
// if IsControledBy ( i ) then
27614: LD_VAR 0 2
27618: PPUSH
27619: CALL_OW 312
27623: IFFALSE 27634
// ComUnlink ( i ) ;
27625: LD_VAR 0 2
27629: PPUSH
27630: CALL_OW 136
27634: GO 27611
27636: POP
27637: POP
// end ;
27638: PPOPN 2
27640: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
27641: LD_EXP 62
27645: PUSH
27646: LD_EXP 93
27650: AND
27651: IFFALSE 27791
27653: GO 27655
27655: DISABLE
27656: LD_INT 0
27658: PPUSH
27659: PPUSH
// begin ToLua ( displayPowell(); ) ;
27660: LD_STRING displayPowell();
27662: PPUSH
27663: CALL_OW 559
// uc_side := 0 ;
27667: LD_ADDR_OWVAR 20
27671: PUSH
27672: LD_INT 0
27674: ST_TO_ADDR
// uc_nation := 2 ;
27675: LD_ADDR_OWVAR 21
27679: PUSH
27680: LD_INT 2
27682: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
27683: LD_ADDR_OWVAR 37
27687: PUSH
27688: LD_INT 14
27690: ST_TO_ADDR
// vc_engine := engine_siberite ;
27691: LD_ADDR_OWVAR 39
27695: PUSH
27696: LD_INT 3
27698: ST_TO_ADDR
// vc_control := control_apeman ;
27699: LD_ADDR_OWVAR 38
27703: PUSH
27704: LD_INT 5
27706: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
27707: LD_ADDR_OWVAR 40
27711: PUSH
27712: LD_INT 29
27714: ST_TO_ADDR
// un := CreateVehicle ;
27715: LD_ADDR_VAR 0 2
27719: PUSH
27720: CALL_OW 45
27724: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27725: LD_VAR 0 2
27729: PPUSH
27730: LD_INT 1
27732: PPUSH
27733: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27737: LD_INT 35
27739: PPUSH
27740: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27744: LD_VAR 0 2
27748: PPUSH
27749: LD_INT 22
27751: PUSH
27752: LD_OWVAR 2
27756: PUSH
27757: EMPTY
27758: LIST
27759: LIST
27760: PPUSH
27761: CALL_OW 69
27765: PPUSH
27766: LD_VAR 0 2
27770: PPUSH
27771: CALL_OW 74
27775: PPUSH
27776: CALL_OW 115
// until IsDead ( un ) ;
27780: LD_VAR 0 2
27784: PPUSH
27785: CALL_OW 301
27789: IFFALSE 27737
// end ;
27791: PPOPN 2
27793: END
// every 0 0$1 trigger StreamModeActive and sStu do
27794: LD_EXP 62
27798: PUSH
27799: LD_EXP 101
27803: AND
27804: IFFALSE 27820
27806: GO 27808
27808: DISABLE
// begin ToLua ( displayStucuk(); ) ;
27809: LD_STRING displayStucuk();
27811: PPUSH
27812: CALL_OW 559
// ResetFog ;
27816: CALL_OW 335
// end ;
27820: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
27821: LD_EXP 62
27825: PUSH
27826: LD_EXP 94
27830: AND
27831: IFFALSE 27972
27833: GO 27835
27835: DISABLE
27836: LD_INT 0
27838: PPUSH
27839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27840: LD_ADDR_VAR 0 2
27844: PUSH
27845: LD_INT 22
27847: PUSH
27848: LD_OWVAR 2
27852: PUSH
27853: EMPTY
27854: LIST
27855: LIST
27856: PUSH
27857: LD_INT 21
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: EMPTY
27864: LIST
27865: LIST
27866: PUSH
27867: EMPTY
27868: LIST
27869: LIST
27870: PPUSH
27871: CALL_OW 69
27875: ST_TO_ADDR
// if not tmp then
27876: LD_VAR 0 2
27880: NOT
27881: IFFALSE 27885
// exit ;
27883: GO 27972
// un := tmp [ rand ( 1 , tmp ) ] ;
27885: LD_ADDR_VAR 0 1
27889: PUSH
27890: LD_VAR 0 2
27894: PUSH
27895: LD_INT 1
27897: PPUSH
27898: LD_VAR 0 2
27902: PPUSH
27903: CALL_OW 12
27907: ARRAY
27908: ST_TO_ADDR
// SetSide ( un , 0 ) ;
27909: LD_VAR 0 1
27913: PPUSH
27914: LD_INT 0
27916: PPUSH
27917: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
27921: LD_VAR 0 1
27925: PPUSH
27926: LD_OWVAR 3
27930: PUSH
27931: LD_VAR 0 1
27935: DIFF
27936: PPUSH
27937: LD_VAR 0 1
27941: PPUSH
27942: CALL_OW 74
27946: PPUSH
27947: CALL_OW 115
// wait ( 0 0$20 ) ;
27951: LD_INT 700
27953: PPUSH
27954: CALL_OW 67
// SetSide ( un , your_side ) ;
27958: LD_VAR 0 1
27962: PPUSH
27963: LD_OWVAR 2
27967: PPUSH
27968: CALL_OW 235
// end ;
27972: PPOPN 2
27974: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
27975: LD_EXP 62
27979: PUSH
27980: LD_EXP 95
27984: AND
27985: IFFALSE 28091
27987: GO 27989
27989: DISABLE
27990: LD_INT 0
27992: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27993: LD_ADDR_VAR 0 1
27997: PUSH
27998: LD_INT 22
28000: PUSH
28001: LD_OWVAR 2
28005: PUSH
28006: EMPTY
28007: LIST
28008: LIST
28009: PUSH
28010: LD_INT 2
28012: PUSH
28013: LD_INT 30
28015: PUSH
28016: LD_INT 0
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: LD_INT 30
28025: PUSH
28026: LD_INT 1
28028: PUSH
28029: EMPTY
28030: LIST
28031: LIST
28032: PUSH
28033: EMPTY
28034: LIST
28035: LIST
28036: LIST
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PPUSH
28042: CALL_OW 69
28046: ST_TO_ADDR
// if not depot then
28047: LD_VAR 0 1
28051: NOT
28052: IFFALSE 28056
// exit ;
28054: GO 28091
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
28056: LD_VAR 0 1
28060: PUSH
28061: LD_INT 1
28063: ARRAY
28064: PPUSH
28065: CALL_OW 250
28069: PPUSH
28070: LD_VAR 0 1
28074: PUSH
28075: LD_INT 1
28077: ARRAY
28078: PPUSH
28079: CALL_OW 251
28083: PPUSH
28084: LD_INT 70
28086: PPUSH
28087: CALL_OW 495
// end ;
28091: PPOPN 1
28093: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
28094: LD_EXP 62
28098: PUSH
28099: LD_EXP 96
28103: AND
28104: IFFALSE 28315
28106: GO 28108
28108: DISABLE
28109: LD_INT 0
28111: PPUSH
28112: PPUSH
28113: PPUSH
28114: PPUSH
28115: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
28116: LD_ADDR_VAR 0 5
28120: PUSH
28121: LD_INT 22
28123: PUSH
28124: LD_OWVAR 2
28128: PUSH
28129: EMPTY
28130: LIST
28131: LIST
28132: PUSH
28133: LD_INT 21
28135: PUSH
28136: LD_INT 1
28138: PUSH
28139: EMPTY
28140: LIST
28141: LIST
28142: PUSH
28143: EMPTY
28144: LIST
28145: LIST
28146: PPUSH
28147: CALL_OW 69
28151: ST_TO_ADDR
// if not tmp then
28152: LD_VAR 0 5
28156: NOT
28157: IFFALSE 28161
// exit ;
28159: GO 28315
// for i in tmp do
28161: LD_ADDR_VAR 0 1
28165: PUSH
28166: LD_VAR 0 5
28170: PUSH
28171: FOR_IN
28172: IFFALSE 28313
// begin d := rand ( 0 , 5 ) ;
28174: LD_ADDR_VAR 0 4
28178: PUSH
28179: LD_INT 0
28181: PPUSH
28182: LD_INT 5
28184: PPUSH
28185: CALL_OW 12
28189: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
28190: LD_ADDR_VAR 0 2
28194: PUSH
28195: LD_VAR 0 1
28199: PPUSH
28200: CALL_OW 250
28204: PPUSH
28205: LD_VAR 0 4
28209: PPUSH
28210: LD_INT 3
28212: PPUSH
28213: LD_INT 12
28215: PPUSH
28216: CALL_OW 12
28220: PPUSH
28221: CALL_OW 272
28225: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
28226: LD_ADDR_VAR 0 3
28230: PUSH
28231: LD_VAR 0 1
28235: PPUSH
28236: CALL_OW 251
28240: PPUSH
28241: LD_VAR 0 4
28245: PPUSH
28246: LD_INT 3
28248: PPUSH
28249: LD_INT 12
28251: PPUSH
28252: CALL_OW 12
28256: PPUSH
28257: CALL_OW 273
28261: ST_TO_ADDR
// if ValidHex ( x , y ) then
28262: LD_VAR 0 2
28266: PPUSH
28267: LD_VAR 0 3
28271: PPUSH
28272: CALL_OW 488
28276: IFFALSE 28311
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
28278: LD_VAR 0 1
28282: PPUSH
28283: LD_VAR 0 2
28287: PPUSH
28288: LD_VAR 0 3
28292: PPUSH
28293: LD_INT 3
28295: PPUSH
28296: LD_INT 6
28298: PPUSH
28299: CALL_OW 12
28303: PPUSH
28304: LD_INT 1
28306: PPUSH
28307: CALL_OW 483
// end ;
28311: GO 28171
28313: POP
28314: POP
// end ;
28315: PPOPN 5
28317: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
28318: LD_EXP 62
28322: PUSH
28323: LD_EXP 97
28327: AND
28328: IFFALSE 28422
28330: GO 28332
28332: DISABLE
28333: LD_INT 0
28335: PPUSH
28336: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
28337: LD_ADDR_VAR 0 2
28341: PUSH
28342: LD_INT 22
28344: PUSH
28345: LD_OWVAR 2
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 32
28356: PUSH
28357: LD_INT 1
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: LD_INT 21
28366: PUSH
28367: LD_INT 2
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PUSH
28374: EMPTY
28375: LIST
28376: LIST
28377: LIST
28378: PPUSH
28379: CALL_OW 69
28383: ST_TO_ADDR
// if not tmp then
28384: LD_VAR 0 2
28388: NOT
28389: IFFALSE 28393
// exit ;
28391: GO 28422
// for i in tmp do
28393: LD_ADDR_VAR 0 1
28397: PUSH
28398: LD_VAR 0 2
28402: PUSH
28403: FOR_IN
28404: IFFALSE 28420
// SetFuel ( i , 0 ) ;
28406: LD_VAR 0 1
28410: PPUSH
28411: LD_INT 0
28413: PPUSH
28414: CALL_OW 240
28418: GO 28403
28420: POP
28421: POP
// end ;
28422: PPOPN 2
28424: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
28425: LD_EXP 62
28429: PUSH
28430: LD_EXP 98
28434: AND
28435: IFFALSE 28501
28437: GO 28439
28439: DISABLE
28440: LD_INT 0
28442: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28443: LD_ADDR_VAR 0 1
28447: PUSH
28448: LD_INT 22
28450: PUSH
28451: LD_OWVAR 2
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: LD_INT 30
28462: PUSH
28463: LD_INT 29
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: PPUSH
28474: CALL_OW 69
28478: ST_TO_ADDR
// if not tmp then
28479: LD_VAR 0 1
28483: NOT
28484: IFFALSE 28488
// exit ;
28486: GO 28501
// DestroyUnit ( tmp [ 1 ] ) ;
28488: LD_VAR 0 1
28492: PUSH
28493: LD_INT 1
28495: ARRAY
28496: PPUSH
28497: CALL_OW 65
// end ;
28501: PPOPN 1
28503: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
28504: LD_EXP 62
28508: PUSH
28509: LD_EXP 100
28513: AND
28514: IFFALSE 28643
28516: GO 28518
28518: DISABLE
28519: LD_INT 0
28521: PPUSH
// begin uc_side := 0 ;
28522: LD_ADDR_OWVAR 20
28526: PUSH
28527: LD_INT 0
28529: ST_TO_ADDR
// uc_nation := nation_arabian ;
28530: LD_ADDR_OWVAR 21
28534: PUSH
28535: LD_INT 2
28537: ST_TO_ADDR
// hc_gallery :=  ;
28538: LD_ADDR_OWVAR 33
28542: PUSH
28543: LD_STRING 
28545: ST_TO_ADDR
// hc_name :=  ;
28546: LD_ADDR_OWVAR 26
28550: PUSH
28551: LD_STRING 
28553: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
28554: LD_INT 1
28556: PPUSH
28557: LD_INT 11
28559: PPUSH
28560: LD_INT 10
28562: PPUSH
28563: CALL_OW 380
// un := CreateHuman ;
28567: LD_ADDR_VAR 0 1
28571: PUSH
28572: CALL_OW 44
28576: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28577: LD_VAR 0 1
28581: PPUSH
28582: LD_INT 1
28584: PPUSH
28585: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
28589: LD_INT 35
28591: PPUSH
28592: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
28596: LD_VAR 0 1
28600: PPUSH
28601: LD_INT 22
28603: PUSH
28604: LD_OWVAR 2
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PPUSH
28613: CALL_OW 69
28617: PPUSH
28618: LD_VAR 0 1
28622: PPUSH
28623: CALL_OW 74
28627: PPUSH
28628: CALL_OW 115
// until IsDead ( un ) ;
28632: LD_VAR 0 1
28636: PPUSH
28637: CALL_OW 301
28641: IFFALSE 28589
// end ;
28643: PPOPN 1
28645: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
28646: LD_EXP 62
28650: PUSH
28651: LD_EXP 102
28655: AND
28656: IFFALSE 28668
28658: GO 28660
28660: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
28661: LD_STRING earthquake(getX(game), 0, 32)
28663: PPUSH
28664: CALL_OW 559
28668: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
28669: LD_EXP 62
28673: PUSH
28674: LD_EXP 103
28678: AND
28679: IFFALSE 28770
28681: GO 28683
28683: DISABLE
28684: LD_INT 0
28686: PPUSH
// begin enable ;
28687: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
28688: LD_ADDR_VAR 0 1
28692: PUSH
28693: LD_INT 22
28695: PUSH
28696: LD_OWVAR 2
28700: PUSH
28701: EMPTY
28702: LIST
28703: LIST
28704: PUSH
28705: LD_INT 21
28707: PUSH
28708: LD_INT 2
28710: PUSH
28711: EMPTY
28712: LIST
28713: LIST
28714: PUSH
28715: LD_INT 33
28717: PUSH
28718: LD_INT 3
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: EMPTY
28726: LIST
28727: LIST
28728: LIST
28729: PPUSH
28730: CALL_OW 69
28734: ST_TO_ADDR
// if not tmp then
28735: LD_VAR 0 1
28739: NOT
28740: IFFALSE 28744
// exit ;
28742: GO 28770
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28744: LD_VAR 0 1
28748: PUSH
28749: LD_INT 1
28751: PPUSH
28752: LD_VAR 0 1
28756: PPUSH
28757: CALL_OW 12
28761: ARRAY
28762: PPUSH
28763: LD_INT 1
28765: PPUSH
28766: CALL_OW 234
// end ;
28770: PPOPN 1
28772: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
28773: LD_EXP 62
28777: PUSH
28778: LD_EXP 104
28782: AND
28783: IFFALSE 28924
28785: GO 28787
28787: DISABLE
28788: LD_INT 0
28790: PPUSH
28791: PPUSH
28792: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28793: LD_ADDR_VAR 0 3
28797: PUSH
28798: LD_INT 22
28800: PUSH
28801: LD_OWVAR 2
28805: PUSH
28806: EMPTY
28807: LIST
28808: LIST
28809: PUSH
28810: LD_INT 25
28812: PUSH
28813: LD_INT 1
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: EMPTY
28821: LIST
28822: LIST
28823: PPUSH
28824: CALL_OW 69
28828: ST_TO_ADDR
// if not tmp then
28829: LD_VAR 0 3
28833: NOT
28834: IFFALSE 28838
// exit ;
28836: GO 28924
// un := tmp [ rand ( 1 , tmp ) ] ;
28838: LD_ADDR_VAR 0 2
28842: PUSH
28843: LD_VAR 0 3
28847: PUSH
28848: LD_INT 1
28850: PPUSH
28851: LD_VAR 0 3
28855: PPUSH
28856: CALL_OW 12
28860: ARRAY
28861: ST_TO_ADDR
// if Crawls ( un ) then
28862: LD_VAR 0 2
28866: PPUSH
28867: CALL_OW 318
28871: IFFALSE 28882
// ComWalk ( un ) ;
28873: LD_VAR 0 2
28877: PPUSH
28878: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
28882: LD_VAR 0 2
28886: PPUSH
28887: LD_INT 9
28889: PPUSH
28890: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
28894: LD_INT 28
28896: PPUSH
28897: LD_OWVAR 2
28901: PPUSH
28902: LD_INT 2
28904: PPUSH
28905: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
28909: LD_INT 29
28911: PPUSH
28912: LD_OWVAR 2
28916: PPUSH
28917: LD_INT 2
28919: PPUSH
28920: CALL_OW 322
// end ;
28924: PPOPN 3
28926: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
28927: LD_EXP 62
28931: PUSH
28932: LD_EXP 105
28936: AND
28937: IFFALSE 29048
28939: GO 28941
28941: DISABLE
28942: LD_INT 0
28944: PPUSH
28945: PPUSH
28946: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28947: LD_ADDR_VAR 0 3
28951: PUSH
28952: LD_INT 22
28954: PUSH
28955: LD_OWVAR 2
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: PUSH
28964: LD_INT 25
28966: PUSH
28967: LD_INT 1
28969: PUSH
28970: EMPTY
28971: LIST
28972: LIST
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PPUSH
28978: CALL_OW 69
28982: ST_TO_ADDR
// if not tmp then
28983: LD_VAR 0 3
28987: NOT
28988: IFFALSE 28992
// exit ;
28990: GO 29048
// un := tmp [ rand ( 1 , tmp ) ] ;
28992: LD_ADDR_VAR 0 2
28996: PUSH
28997: LD_VAR 0 3
29001: PUSH
29002: LD_INT 1
29004: PPUSH
29005: LD_VAR 0 3
29009: PPUSH
29010: CALL_OW 12
29014: ARRAY
29015: ST_TO_ADDR
// if Crawls ( un ) then
29016: LD_VAR 0 2
29020: PPUSH
29021: CALL_OW 318
29025: IFFALSE 29036
// ComWalk ( un ) ;
29027: LD_VAR 0 2
29031: PPUSH
29032: CALL_OW 138
// SetClass ( un , class_mortar ) ;
29036: LD_VAR 0 2
29040: PPUSH
29041: LD_INT 8
29043: PPUSH
29044: CALL_OW 336
// end ;
29048: PPOPN 3
29050: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
29051: LD_EXP 62
29055: PUSH
29056: LD_EXP 106
29060: AND
29061: IFFALSE 29205
29063: GO 29065
29065: DISABLE
29066: LD_INT 0
29068: PPUSH
29069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
29070: LD_ADDR_VAR 0 2
29074: PUSH
29075: LD_INT 22
29077: PUSH
29078: LD_OWVAR 2
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 21
29089: PUSH
29090: LD_INT 2
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 2
29099: PUSH
29100: LD_INT 34
29102: PUSH
29103: LD_INT 12
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 34
29112: PUSH
29113: LD_INT 51
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 34
29122: PUSH
29123: LD_INT 32
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: EMPTY
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: LIST
29140: PPUSH
29141: CALL_OW 69
29145: ST_TO_ADDR
// if not tmp then
29146: LD_VAR 0 2
29150: NOT
29151: IFFALSE 29155
// exit ;
29153: GO 29205
// for i in tmp do
29155: LD_ADDR_VAR 0 1
29159: PUSH
29160: LD_VAR 0 2
29164: PUSH
29165: FOR_IN
29166: IFFALSE 29203
// if GetCargo ( i , mat_artifact ) = 0 then
29168: LD_VAR 0 1
29172: PPUSH
29173: LD_INT 4
29175: PPUSH
29176: CALL_OW 289
29180: PUSH
29181: LD_INT 0
29183: EQUAL
29184: IFFALSE 29201
// SetCargo ( i , mat_siberit , 100 ) ;
29186: LD_VAR 0 1
29190: PPUSH
29191: LD_INT 3
29193: PPUSH
29194: LD_INT 100
29196: PPUSH
29197: CALL_OW 290
29201: GO 29165
29203: POP
29204: POP
// end ;
29205: PPOPN 2
29207: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
29208: LD_EXP 62
29212: PUSH
29213: LD_EXP 107
29217: AND
29218: IFFALSE 29401
29220: GO 29222
29222: DISABLE
29223: LD_INT 0
29225: PPUSH
29226: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
29227: LD_ADDR_VAR 0 2
29231: PUSH
29232: LD_INT 22
29234: PUSH
29235: LD_OWVAR 2
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: PPUSH
29244: CALL_OW 69
29248: ST_TO_ADDR
// if not tmp then
29249: LD_VAR 0 2
29253: NOT
29254: IFFALSE 29258
// exit ;
29256: GO 29401
// for i := 1 to 2 do
29258: LD_ADDR_VAR 0 1
29262: PUSH
29263: DOUBLE
29264: LD_INT 1
29266: DEC
29267: ST_TO_ADDR
29268: LD_INT 2
29270: PUSH
29271: FOR_TO
29272: IFFALSE 29399
// begin uc_side := your_side ;
29274: LD_ADDR_OWVAR 20
29278: PUSH
29279: LD_OWVAR 2
29283: ST_TO_ADDR
// uc_nation := nation_american ;
29284: LD_ADDR_OWVAR 21
29288: PUSH
29289: LD_INT 1
29291: ST_TO_ADDR
// vc_chassis := us_morphling ;
29292: LD_ADDR_OWVAR 37
29296: PUSH
29297: LD_INT 5
29299: ST_TO_ADDR
// vc_engine := engine_siberite ;
29300: LD_ADDR_OWVAR 39
29304: PUSH
29305: LD_INT 3
29307: ST_TO_ADDR
// vc_control := control_computer ;
29308: LD_ADDR_OWVAR 38
29312: PUSH
29313: LD_INT 3
29315: ST_TO_ADDR
// vc_weapon := us_double_laser ;
29316: LD_ADDR_OWVAR 40
29320: PUSH
29321: LD_INT 10
29323: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
29324: LD_VAR 0 2
29328: PUSH
29329: LD_INT 1
29331: ARRAY
29332: PPUSH
29333: CALL_OW 310
29337: NOT
29338: IFFALSE 29385
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
29340: CALL_OW 45
29344: PPUSH
29345: LD_VAR 0 2
29349: PUSH
29350: LD_INT 1
29352: ARRAY
29353: PPUSH
29354: CALL_OW 250
29358: PPUSH
29359: LD_VAR 0 2
29363: PUSH
29364: LD_INT 1
29366: ARRAY
29367: PPUSH
29368: CALL_OW 251
29372: PPUSH
29373: LD_INT 12
29375: PPUSH
29376: LD_INT 1
29378: PPUSH
29379: CALL_OW 50
29383: GO 29397
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
29385: CALL_OW 45
29389: PPUSH
29390: LD_INT 1
29392: PPUSH
29393: CALL_OW 51
// end ;
29397: GO 29271
29399: POP
29400: POP
// end ;
29401: PPOPN 2
29403: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
29404: LD_EXP 62
29408: PUSH
29409: LD_EXP 108
29413: AND
29414: IFFALSE 29636
29416: GO 29418
29418: DISABLE
29419: LD_INT 0
29421: PPUSH
29422: PPUSH
29423: PPUSH
29424: PPUSH
29425: PPUSH
29426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29427: LD_ADDR_VAR 0 6
29431: PUSH
29432: LD_INT 22
29434: PUSH
29435: LD_OWVAR 2
29439: PUSH
29440: EMPTY
29441: LIST
29442: LIST
29443: PUSH
29444: LD_INT 21
29446: PUSH
29447: LD_INT 1
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: PUSH
29454: LD_INT 3
29456: PUSH
29457: LD_INT 23
29459: PUSH
29460: LD_INT 0
29462: PUSH
29463: EMPTY
29464: LIST
29465: LIST
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: LIST
29475: PPUSH
29476: CALL_OW 69
29480: ST_TO_ADDR
// if not tmp then
29481: LD_VAR 0 6
29485: NOT
29486: IFFALSE 29490
// exit ;
29488: GO 29636
// s1 := rand ( 1 , 4 ) ;
29490: LD_ADDR_VAR 0 2
29494: PUSH
29495: LD_INT 1
29497: PPUSH
29498: LD_INT 4
29500: PPUSH
29501: CALL_OW 12
29505: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
29506: LD_ADDR_VAR 0 4
29510: PUSH
29511: LD_VAR 0 6
29515: PUSH
29516: LD_INT 1
29518: ARRAY
29519: PPUSH
29520: LD_VAR 0 2
29524: PPUSH
29525: CALL_OW 259
29529: ST_TO_ADDR
// if s1 = 1 then
29530: LD_VAR 0 2
29534: PUSH
29535: LD_INT 1
29537: EQUAL
29538: IFFALSE 29558
// s2 := rand ( 2 , 4 ) else
29540: LD_ADDR_VAR 0 3
29544: PUSH
29545: LD_INT 2
29547: PPUSH
29548: LD_INT 4
29550: PPUSH
29551: CALL_OW 12
29555: ST_TO_ADDR
29556: GO 29566
// s2 := 1 ;
29558: LD_ADDR_VAR 0 3
29562: PUSH
29563: LD_INT 1
29565: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
29566: LD_ADDR_VAR 0 5
29570: PUSH
29571: LD_VAR 0 6
29575: PUSH
29576: LD_INT 1
29578: ARRAY
29579: PPUSH
29580: LD_VAR 0 3
29584: PPUSH
29585: CALL_OW 259
29589: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
29590: LD_VAR 0 6
29594: PUSH
29595: LD_INT 1
29597: ARRAY
29598: PPUSH
29599: LD_VAR 0 2
29603: PPUSH
29604: LD_VAR 0 5
29608: PPUSH
29609: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
29613: LD_VAR 0 6
29617: PUSH
29618: LD_INT 1
29620: ARRAY
29621: PPUSH
29622: LD_VAR 0 3
29626: PPUSH
29627: LD_VAR 0 4
29631: PPUSH
29632: CALL_OW 237
// end ;
29636: PPOPN 6
29638: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
29639: LD_EXP 62
29643: PUSH
29644: LD_EXP 109
29648: AND
29649: IFFALSE 29728
29651: GO 29653
29653: DISABLE
29654: LD_INT 0
29656: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
29657: LD_ADDR_VAR 0 1
29661: PUSH
29662: LD_INT 22
29664: PUSH
29665: LD_OWVAR 2
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 30
29676: PUSH
29677: LD_INT 3
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PPUSH
29688: CALL_OW 69
29692: ST_TO_ADDR
// if not tmp then
29693: LD_VAR 0 1
29697: NOT
29698: IFFALSE 29702
// exit ;
29700: GO 29728
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
29702: LD_VAR 0 1
29706: PUSH
29707: LD_INT 1
29709: PPUSH
29710: LD_VAR 0 1
29714: PPUSH
29715: CALL_OW 12
29719: ARRAY
29720: PPUSH
29721: LD_INT 1
29723: PPUSH
29724: CALL_OW 234
// end ;
29728: PPOPN 1
29730: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
29731: LD_EXP 62
29735: PUSH
29736: LD_EXP 110
29740: AND
29741: IFFALSE 29853
29743: GO 29745
29745: DISABLE
29746: LD_INT 0
29748: PPUSH
29749: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
29750: LD_ADDR_VAR 0 2
29754: PUSH
29755: LD_INT 22
29757: PUSH
29758: LD_OWVAR 2
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 2
29769: PUSH
29770: LD_INT 30
29772: PUSH
29773: LD_INT 27
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: LD_INT 30
29782: PUSH
29783: LD_INT 26
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 30
29792: PUSH
29793: LD_INT 28
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: EMPTY
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PPUSH
29810: CALL_OW 69
29814: ST_TO_ADDR
// if not tmp then
29815: LD_VAR 0 2
29819: NOT
29820: IFFALSE 29824
// exit ;
29822: GO 29853
// for i in tmp do
29824: LD_ADDR_VAR 0 1
29828: PUSH
29829: LD_VAR 0 2
29833: PUSH
29834: FOR_IN
29835: IFFALSE 29851
// SetLives ( i , 1 ) ;
29837: LD_VAR 0 1
29841: PPUSH
29842: LD_INT 1
29844: PPUSH
29845: CALL_OW 234
29849: GO 29834
29851: POP
29852: POP
// end ;
29853: PPOPN 2
29855: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
29856: LD_EXP 62
29860: PUSH
29861: LD_EXP 111
29865: AND
29866: IFFALSE 30140
29868: GO 29870
29870: DISABLE
29871: LD_INT 0
29873: PPUSH
29874: PPUSH
29875: PPUSH
// begin i := rand ( 1 , 7 ) ;
29876: LD_ADDR_VAR 0 1
29880: PUSH
29881: LD_INT 1
29883: PPUSH
29884: LD_INT 7
29886: PPUSH
29887: CALL_OW 12
29891: ST_TO_ADDR
// case i of 1 :
29892: LD_VAR 0 1
29896: PUSH
29897: LD_INT 1
29899: DOUBLE
29900: EQUAL
29901: IFTRUE 29905
29903: GO 29915
29905: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
29906: LD_STRING earthquake(getX(game), 0, 32)
29908: PPUSH
29909: CALL_OW 559
29913: GO 30140
29915: LD_INT 2
29917: DOUBLE
29918: EQUAL
29919: IFTRUE 29923
29921: GO 29937
29923: POP
// begin ToLua ( displayStucuk(); ) ;
29924: LD_STRING displayStucuk();
29926: PPUSH
29927: CALL_OW 559
// ResetFog ;
29931: CALL_OW 335
// end ; 3 :
29935: GO 30140
29937: LD_INT 3
29939: DOUBLE
29940: EQUAL
29941: IFTRUE 29945
29943: GO 30049
29945: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
29946: LD_ADDR_VAR 0 2
29950: PUSH
29951: LD_INT 22
29953: PUSH
29954: LD_OWVAR 2
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: LD_INT 25
29965: PUSH
29966: LD_INT 1
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PPUSH
29977: CALL_OW 69
29981: ST_TO_ADDR
// if not tmp then
29982: LD_VAR 0 2
29986: NOT
29987: IFFALSE 29991
// exit ;
29989: GO 30140
// un := tmp [ rand ( 1 , tmp ) ] ;
29991: LD_ADDR_VAR 0 3
29995: PUSH
29996: LD_VAR 0 2
30000: PUSH
30001: LD_INT 1
30003: PPUSH
30004: LD_VAR 0 2
30008: PPUSH
30009: CALL_OW 12
30013: ARRAY
30014: ST_TO_ADDR
// if Crawls ( un ) then
30015: LD_VAR 0 3
30019: PPUSH
30020: CALL_OW 318
30024: IFFALSE 30035
// ComWalk ( un ) ;
30026: LD_VAR 0 3
30030: PPUSH
30031: CALL_OW 138
// SetClass ( un , class_mortar ) ;
30035: LD_VAR 0 3
30039: PPUSH
30040: LD_INT 8
30042: PPUSH
30043: CALL_OW 336
// end ; 4 :
30047: GO 30140
30049: LD_INT 4
30051: DOUBLE
30052: EQUAL
30053: IFTRUE 30057
30055: GO 30118
30057: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
30058: LD_ADDR_VAR 0 2
30062: PUSH
30063: LD_INT 22
30065: PUSH
30066: LD_OWVAR 2
30070: PUSH
30071: EMPTY
30072: LIST
30073: LIST
30074: PUSH
30075: LD_INT 30
30077: PUSH
30078: LD_INT 29
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PPUSH
30089: CALL_OW 69
30093: ST_TO_ADDR
// if not tmp then
30094: LD_VAR 0 2
30098: NOT
30099: IFFALSE 30103
// exit ;
30101: GO 30140
// DestroyUnit ( tmp [ 1 ] ) ;
30103: LD_VAR 0 2
30107: PUSH
30108: LD_INT 1
30110: ARRAY
30111: PPUSH
30112: CALL_OW 65
// end ; 5 .. 7 :
30116: GO 30140
30118: LD_INT 5
30120: DOUBLE
30121: GREATEREQUAL
30122: IFFALSE 30130
30124: LD_INT 7
30126: DOUBLE
30127: LESSEQUAL
30128: IFTRUE 30132
30130: GO 30139
30132: POP
// StreamSibBomb ; end ;
30133: CALL 26390 0 0
30137: GO 30140
30139: POP
// end ;
30140: PPOPN 3
30142: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
30143: LD_EXP 62
30147: PUSH
30148: LD_EXP 112
30152: AND
30153: IFFALSE 30309
30155: GO 30157
30157: DISABLE
30158: LD_INT 0
30160: PPUSH
30161: PPUSH
30162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
30163: LD_ADDR_VAR 0 2
30167: PUSH
30168: LD_INT 81
30170: PUSH
30171: LD_OWVAR 2
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 2
30182: PUSH
30183: LD_INT 21
30185: PUSH
30186: LD_INT 1
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 21
30195: PUSH
30196: LD_INT 2
30198: PUSH
30199: EMPTY
30200: LIST
30201: LIST
30202: PUSH
30203: EMPTY
30204: LIST
30205: LIST
30206: LIST
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PPUSH
30212: CALL_OW 69
30216: ST_TO_ADDR
// if not tmp then
30217: LD_VAR 0 2
30221: NOT
30222: IFFALSE 30226
// exit ;
30224: GO 30309
// p := 0 ;
30226: LD_ADDR_VAR 0 3
30230: PUSH
30231: LD_INT 0
30233: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30234: LD_INT 35
30236: PPUSH
30237: CALL_OW 67
// p := p + 1 ;
30241: LD_ADDR_VAR 0 3
30245: PUSH
30246: LD_VAR 0 3
30250: PUSH
30251: LD_INT 1
30253: PLUS
30254: ST_TO_ADDR
// for i in tmp do
30255: LD_ADDR_VAR 0 1
30259: PUSH
30260: LD_VAR 0 2
30264: PUSH
30265: FOR_IN
30266: IFFALSE 30297
// if GetLives ( i ) < 1000 then
30268: LD_VAR 0 1
30272: PPUSH
30273: CALL_OW 256
30277: PUSH
30278: LD_INT 1000
30280: LESS
30281: IFFALSE 30295
// SetLives ( i , 1000 ) ;
30283: LD_VAR 0 1
30287: PPUSH
30288: LD_INT 1000
30290: PPUSH
30291: CALL_OW 234
30295: GO 30265
30297: POP
30298: POP
// until p > 20 ;
30299: LD_VAR 0 3
30303: PUSH
30304: LD_INT 20
30306: GREATER
30307: IFFALSE 30234
// end ;
30309: PPOPN 3
30311: END
// every 0 0$1 trigger StreamModeActive and sTime do
30312: LD_EXP 62
30316: PUSH
30317: LD_EXP 113
30321: AND
30322: IFFALSE 30357
30324: GO 30326
30326: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
30327: LD_INT 28
30329: PPUSH
30330: LD_OWVAR 2
30334: PPUSH
30335: LD_INT 2
30337: PPUSH
30338: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
30342: LD_INT 30
30344: PPUSH
30345: LD_OWVAR 2
30349: PPUSH
30350: LD_INT 2
30352: PPUSH
30353: CALL_OW 322
// end ;
30357: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
30358: LD_EXP 62
30362: PUSH
30363: LD_EXP 114
30367: AND
30368: IFFALSE 30489
30370: GO 30372
30372: DISABLE
30373: LD_INT 0
30375: PPUSH
30376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
30377: LD_ADDR_VAR 0 2
30381: PUSH
30382: LD_INT 22
30384: PUSH
30385: LD_OWVAR 2
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: PUSH
30394: LD_INT 21
30396: PUSH
30397: LD_INT 1
30399: PUSH
30400: EMPTY
30401: LIST
30402: LIST
30403: PUSH
30404: LD_INT 3
30406: PUSH
30407: LD_INT 23
30409: PUSH
30410: LD_INT 0
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: EMPTY
30418: LIST
30419: LIST
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: LIST
30425: PPUSH
30426: CALL_OW 69
30430: ST_TO_ADDR
// if not tmp then
30431: LD_VAR 0 2
30435: NOT
30436: IFFALSE 30440
// exit ;
30438: GO 30489
// for i in tmp do
30440: LD_ADDR_VAR 0 1
30444: PUSH
30445: LD_VAR 0 2
30449: PUSH
30450: FOR_IN
30451: IFFALSE 30487
// begin if Crawls ( i ) then
30453: LD_VAR 0 1
30457: PPUSH
30458: CALL_OW 318
30462: IFFALSE 30473
// ComWalk ( i ) ;
30464: LD_VAR 0 1
30468: PPUSH
30469: CALL_OW 138
// SetClass ( i , 2 ) ;
30473: LD_VAR 0 1
30477: PPUSH
30478: LD_INT 2
30480: PPUSH
30481: CALL_OW 336
// end ;
30485: GO 30450
30487: POP
30488: POP
// end ;
30489: PPOPN 2
30491: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
30492: LD_EXP 62
30496: PUSH
30497: LD_EXP 115
30501: AND
30502: IFFALSE 30783
30504: GO 30506
30506: DISABLE
30507: LD_INT 0
30509: PPUSH
30510: PPUSH
30511: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
30512: LD_OWVAR 2
30516: PPUSH
30517: LD_INT 9
30519: PPUSH
30520: LD_INT 1
30522: PPUSH
30523: LD_INT 1
30525: PPUSH
30526: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
30530: LD_INT 9
30532: PPUSH
30533: LD_OWVAR 2
30537: PPUSH
30538: CALL_OW 343
// uc_side := 9 ;
30542: LD_ADDR_OWVAR 20
30546: PUSH
30547: LD_INT 9
30549: ST_TO_ADDR
// uc_nation := 2 ;
30550: LD_ADDR_OWVAR 21
30554: PUSH
30555: LD_INT 2
30557: ST_TO_ADDR
// hc_name := Dark Warrior ;
30558: LD_ADDR_OWVAR 26
30562: PUSH
30563: LD_STRING Dark Warrior
30565: ST_TO_ADDR
// hc_gallery :=  ;
30566: LD_ADDR_OWVAR 33
30570: PUSH
30571: LD_STRING 
30573: ST_TO_ADDR
// hc_noskilllimit := true ;
30574: LD_ADDR_OWVAR 76
30578: PUSH
30579: LD_INT 1
30581: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
30582: LD_ADDR_OWVAR 31
30586: PUSH
30587: LD_INT 30
30589: PUSH
30590: LD_INT 30
30592: PUSH
30593: LD_INT 30
30595: PUSH
30596: LD_INT 30
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: ST_TO_ADDR
// un := CreateHuman ;
30605: LD_ADDR_VAR 0 3
30609: PUSH
30610: CALL_OW 44
30614: ST_TO_ADDR
// hc_noskilllimit := false ;
30615: LD_ADDR_OWVAR 76
30619: PUSH
30620: LD_INT 0
30622: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
30623: LD_VAR 0 3
30627: PPUSH
30628: LD_INT 1
30630: PPUSH
30631: CALL_OW 51
// p := 0 ;
30635: LD_ADDR_VAR 0 2
30639: PUSH
30640: LD_INT 0
30642: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30643: LD_INT 35
30645: PPUSH
30646: CALL_OW 67
// p := p + 1 ;
30650: LD_ADDR_VAR 0 2
30654: PUSH
30655: LD_VAR 0 2
30659: PUSH
30660: LD_INT 1
30662: PLUS
30663: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
30664: LD_VAR 0 3
30668: PPUSH
30669: CALL_OW 256
30673: PUSH
30674: LD_INT 1000
30676: LESS
30677: IFFALSE 30691
// SetLives ( un , 1000 ) ;
30679: LD_VAR 0 3
30683: PPUSH
30684: LD_INT 1000
30686: PPUSH
30687: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
30691: LD_VAR 0 3
30695: PPUSH
30696: LD_INT 81
30698: PUSH
30699: LD_OWVAR 2
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: PUSH
30708: LD_INT 91
30710: PUSH
30711: LD_VAR 0 3
30715: PUSH
30716: LD_INT 30
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: LIST
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PPUSH
30728: CALL_OW 69
30732: PPUSH
30733: LD_VAR 0 3
30737: PPUSH
30738: CALL_OW 74
30742: PPUSH
30743: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
30747: LD_VAR 0 2
30751: PUSH
30752: LD_INT 60
30754: GREATER
30755: PUSH
30756: LD_VAR 0 3
30760: PPUSH
30761: CALL_OW 301
30765: OR
30766: IFFALSE 30643
// if un then
30768: LD_VAR 0 3
30772: IFFALSE 30783
// RemoveUnit ( un ) ;
30774: LD_VAR 0 3
30778: PPUSH
30779: CALL_OW 64
// end ;
30783: PPOPN 3
30785: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
30786: LD_INT 0
30788: PPUSH
30789: PPUSH
30790: PPUSH
30791: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
30792: LD_ADDR_VAR 0 4
30796: PUSH
30797: LD_INT 22
30799: PUSH
30800: LD_OWVAR 2
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: LD_INT 30
30814: PUSH
30815: LD_INT 0
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: PUSH
30822: LD_INT 30
30824: PUSH
30825: LD_INT 1
30827: PUSH
30828: EMPTY
30829: LIST
30830: LIST
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: LIST
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PPUSH
30841: CALL_OW 69
30845: ST_TO_ADDR
// if not tmp then
30846: LD_VAR 0 4
30850: NOT
30851: IFFALSE 30855
// exit ;
30853: GO 30914
// for i in tmp do
30855: LD_ADDR_VAR 0 2
30859: PUSH
30860: LD_VAR 0 4
30864: PUSH
30865: FOR_IN
30866: IFFALSE 30912
// for j = 1 to 3 do
30868: LD_ADDR_VAR 0 3
30872: PUSH
30873: DOUBLE
30874: LD_INT 1
30876: DEC
30877: ST_TO_ADDR
30878: LD_INT 3
30880: PUSH
30881: FOR_TO
30882: IFFALSE 30908
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
30884: LD_VAR 0 2
30888: PPUSH
30889: CALL_OW 274
30893: PPUSH
30894: LD_VAR 0 3
30898: PPUSH
30899: LD_INT 99999
30901: PPUSH
30902: CALL_OW 277
30906: GO 30881
30908: POP
30909: POP
30910: GO 30865
30912: POP
30913: POP
// end ;
30914: LD_VAR 0 1
30918: RET
// export function hHackSetLevel10 ; var i , j ; begin
30919: LD_INT 0
30921: PPUSH
30922: PPUSH
30923: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
30924: LD_ADDR_VAR 0 2
30928: PUSH
30929: LD_INT 21
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PPUSH
30939: CALL_OW 69
30943: PUSH
30944: FOR_IN
30945: IFFALSE 30997
// if IsSelected ( i ) then
30947: LD_VAR 0 2
30951: PPUSH
30952: CALL_OW 306
30956: IFFALSE 30995
// begin for j := 1 to 4 do
30958: LD_ADDR_VAR 0 3
30962: PUSH
30963: DOUBLE
30964: LD_INT 1
30966: DEC
30967: ST_TO_ADDR
30968: LD_INT 4
30970: PUSH
30971: FOR_TO
30972: IFFALSE 30993
// SetSkill ( i , j , 10 ) ;
30974: LD_VAR 0 2
30978: PPUSH
30979: LD_VAR 0 3
30983: PPUSH
30984: LD_INT 10
30986: PPUSH
30987: CALL_OW 237
30991: GO 30971
30993: POP
30994: POP
// end ;
30995: GO 30944
30997: POP
30998: POP
// end ;
30999: LD_VAR 0 1
31003: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
31004: LD_INT 0
31006: PPUSH
31007: PPUSH
31008: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
31009: LD_ADDR_VAR 0 2
31013: PUSH
31014: LD_INT 22
31016: PUSH
31017: LD_OWVAR 2
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 21
31028: PUSH
31029: LD_INT 1
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PPUSH
31040: CALL_OW 69
31044: PUSH
31045: FOR_IN
31046: IFFALSE 31087
// begin for j := 1 to 4 do
31048: LD_ADDR_VAR 0 3
31052: PUSH
31053: DOUBLE
31054: LD_INT 1
31056: DEC
31057: ST_TO_ADDR
31058: LD_INT 4
31060: PUSH
31061: FOR_TO
31062: IFFALSE 31083
// SetSkill ( i , j , 10 ) ;
31064: LD_VAR 0 2
31068: PPUSH
31069: LD_VAR 0 3
31073: PPUSH
31074: LD_INT 10
31076: PPUSH
31077: CALL_OW 237
31081: GO 31061
31083: POP
31084: POP
// end ;
31085: GO 31045
31087: POP
31088: POP
// end ;
31089: LD_VAR 0 1
31093: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
31094: LD_INT 0
31096: PPUSH
// uc_side := your_side ;
31097: LD_ADDR_OWVAR 20
31101: PUSH
31102: LD_OWVAR 2
31106: ST_TO_ADDR
// uc_nation := nation ;
31107: LD_ADDR_OWVAR 21
31111: PUSH
31112: LD_VAR 0 1
31116: ST_TO_ADDR
// InitHc ;
31117: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
31121: LD_INT 0
31123: PPUSH
31124: LD_VAR 0 2
31128: PPUSH
31129: LD_VAR 0 3
31133: PPUSH
31134: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
31138: CALL_OW 44
31142: PPUSH
31143: LD_INT 1
31145: PPUSH
31146: CALL_OW 51
// end ;
31150: LD_VAR 0 4
31154: RET
// export function hHackSpawnVehicle ; begin
31155: LD_INT 0
31157: PPUSH
// uc_side := your_side ;
31158: LD_ADDR_OWVAR 20
31162: PUSH
31163: LD_OWVAR 2
31167: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
31168: LD_ADDR_OWVAR 21
31172: PUSH
31173: LD_INT 1
31175: PPUSH
31176: LD_INT 3
31178: PPUSH
31179: CALL_OW 12
31183: ST_TO_ADDR
// InitVc ;
31184: CALL_OW 20
// case uc_nation of 1 :
31188: LD_OWVAR 21
31192: PUSH
31193: LD_INT 1
31195: DOUBLE
31196: EQUAL
31197: IFTRUE 31201
31199: GO 31345
31201: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
31202: LD_ADDR_OWVAR 37
31206: PUSH
31207: LD_INT 1
31209: PUSH
31210: LD_INT 2
31212: PUSH
31213: LD_INT 3
31215: PUSH
31216: LD_INT 4
31218: PUSH
31219: LD_INT 5
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: LIST
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: PPUSH
31232: LD_INT 5
31234: PPUSH
31235: CALL_OW 12
31239: ARRAY
31240: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31241: LD_ADDR_OWVAR 39
31245: PUSH
31246: LD_INT 1
31248: PPUSH
31249: LD_INT 3
31251: PPUSH
31252: CALL_OW 12
31256: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
31257: LD_ADDR_OWVAR 38
31261: PUSH
31262: LD_INT 1
31264: PUSH
31265: LD_INT 2
31267: PUSH
31268: LD_INT 3
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 1
31278: PPUSH
31279: LD_INT 3
31281: PPUSH
31282: CALL_OW 12
31286: ARRAY
31287: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
31288: LD_ADDR_OWVAR 40
31292: PUSH
31293: LD_INT 2
31295: PUSH
31296: LD_INT 4
31298: PUSH
31299: LD_INT 5
31301: PUSH
31302: LD_INT 3
31304: PUSH
31305: LD_INT 7
31307: PUSH
31308: LD_INT 8
31310: PUSH
31311: LD_INT 9
31313: PUSH
31314: LD_INT 10
31316: PUSH
31317: LD_INT 6
31319: PUSH
31320: EMPTY
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 1
31333: PPUSH
31334: LD_INT 9
31336: PPUSH
31337: CALL_OW 12
31341: ARRAY
31342: ST_TO_ADDR
// end ; 2 :
31343: GO 31610
31345: LD_INT 2
31347: DOUBLE
31348: EQUAL
31349: IFTRUE 31353
31351: GO 31477
31353: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
31354: LD_ADDR_OWVAR 37
31358: PUSH
31359: LD_INT 11
31361: PUSH
31362: LD_INT 12
31364: PUSH
31365: LD_INT 13
31367: PUSH
31368: LD_INT 14
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 1
31379: PPUSH
31380: LD_INT 4
31382: PPUSH
31383: CALL_OW 12
31387: ARRAY
31388: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31389: LD_ADDR_OWVAR 39
31393: PUSH
31394: LD_INT 1
31396: PPUSH
31397: LD_INT 3
31399: PPUSH
31400: CALL_OW 12
31404: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
31405: LD_ADDR_OWVAR 38
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: LD_INT 2
31415: PUSH
31416: LD_INT 5
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: LIST
31423: PUSH
31424: LD_INT 1
31426: PPUSH
31427: LD_INT 3
31429: PPUSH
31430: CALL_OW 12
31434: ARRAY
31435: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
31436: LD_ADDR_OWVAR 40
31440: PUSH
31441: LD_INT 24
31443: PUSH
31444: LD_INT 26
31446: PUSH
31447: LD_INT 27
31449: PUSH
31450: LD_INT 28
31452: PUSH
31453: LD_INT 29
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 1
31465: PPUSH
31466: LD_INT 5
31468: PPUSH
31469: CALL_OW 12
31473: ARRAY
31474: ST_TO_ADDR
// end ; 3 :
31475: GO 31610
31477: LD_INT 3
31479: DOUBLE
31480: EQUAL
31481: IFTRUE 31485
31483: GO 31609
31485: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
31486: LD_ADDR_OWVAR 37
31490: PUSH
31491: LD_INT 21
31493: PUSH
31494: LD_INT 23
31496: PUSH
31497: LD_INT 22
31499: PUSH
31500: LD_INT 24
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: PUSH
31509: LD_INT 1
31511: PPUSH
31512: LD_INT 4
31514: PPUSH
31515: CALL_OW 12
31519: ARRAY
31520: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31521: LD_ADDR_OWVAR 39
31525: PUSH
31526: LD_INT 1
31528: PPUSH
31529: LD_INT 3
31531: PPUSH
31532: CALL_OW 12
31536: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
31537: LD_ADDR_OWVAR 38
31541: PUSH
31542: LD_INT 1
31544: PUSH
31545: LD_INT 3
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 1
31554: PPUSH
31555: LD_INT 2
31557: PPUSH
31558: CALL_OW 12
31562: ARRAY
31563: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
31564: LD_ADDR_OWVAR 40
31568: PUSH
31569: LD_INT 42
31571: PUSH
31572: LD_INT 43
31574: PUSH
31575: LD_INT 44
31577: PUSH
31578: LD_INT 46
31580: PUSH
31581: LD_INT 48
31583: PUSH
31584: LD_INT 47
31586: PUSH
31587: EMPTY
31588: LIST
31589: LIST
31590: LIST
31591: LIST
31592: LIST
31593: LIST
31594: PUSH
31595: LD_INT 1
31597: PPUSH
31598: LD_INT 6
31600: PPUSH
31601: CALL_OW 12
31605: ARRAY
31606: ST_TO_ADDR
// end ; end ;
31607: GO 31610
31609: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
31610: CALL_OW 45
31614: PPUSH
31615: LD_INT 1
31617: PPUSH
31618: CALL_OW 51
// end ;
31622: LD_VAR 0 1
31626: RET
// export hInvincible ; every 1 do
31627: GO 31629
31629: DISABLE
// hInvincible := [ ] ;
31630: LD_ADDR_EXP 116
31634: PUSH
31635: EMPTY
31636: ST_TO_ADDR
31637: END
// every 10 do var i ;
31638: GO 31640
31640: DISABLE
31641: LD_INT 0
31643: PPUSH
// begin enable ;
31644: ENABLE
// if not hInvincible then
31645: LD_EXP 116
31649: NOT
31650: IFFALSE 31654
// exit ;
31652: GO 31698
// for i in hInvincible do
31654: LD_ADDR_VAR 0 1
31658: PUSH
31659: LD_EXP 116
31663: PUSH
31664: FOR_IN
31665: IFFALSE 31696
// if GetLives ( i ) < 1000 then
31667: LD_VAR 0 1
31671: PPUSH
31672: CALL_OW 256
31676: PUSH
31677: LD_INT 1000
31679: LESS
31680: IFFALSE 31694
// SetLives ( i , 1000 ) ;
31682: LD_VAR 0 1
31686: PPUSH
31687: LD_INT 1000
31689: PPUSH
31690: CALL_OW 234
31694: GO 31664
31696: POP
31697: POP
// end ;
31698: PPOPN 1
31700: END
// export function hHackInvincible ; var i ; begin
31701: LD_INT 0
31703: PPUSH
31704: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
31705: LD_ADDR_VAR 0 2
31709: PUSH
31710: LD_INT 2
31712: PUSH
31713: LD_INT 21
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 21
31725: PUSH
31726: LD_INT 2
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: LIST
31737: PPUSH
31738: CALL_OW 69
31742: PUSH
31743: FOR_IN
31744: IFFALSE 31805
// if IsSelected ( i ) then
31746: LD_VAR 0 2
31750: PPUSH
31751: CALL_OW 306
31755: IFFALSE 31803
// begin if i in hInvincible then
31757: LD_VAR 0 2
31761: PUSH
31762: LD_EXP 116
31766: IN
31767: IFFALSE 31787
// hInvincible := hInvincible diff i else
31769: LD_ADDR_EXP 116
31773: PUSH
31774: LD_EXP 116
31778: PUSH
31779: LD_VAR 0 2
31783: DIFF
31784: ST_TO_ADDR
31785: GO 31803
// hInvincible := hInvincible union i ;
31787: LD_ADDR_EXP 116
31791: PUSH
31792: LD_EXP 116
31796: PUSH
31797: LD_VAR 0 2
31801: UNION
31802: ST_TO_ADDR
// end ;
31803: GO 31743
31805: POP
31806: POP
// end ;
31807: LD_VAR 0 1
31811: RET
// export function hHackInvisible ; var i , j ; begin
31812: LD_INT 0
31814: PPUSH
31815: PPUSH
31816: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
31817: LD_ADDR_VAR 0 2
31821: PUSH
31822: LD_INT 21
31824: PUSH
31825: LD_INT 1
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PPUSH
31832: CALL_OW 69
31836: PUSH
31837: FOR_IN
31838: IFFALSE 31862
// if IsSelected ( i ) then
31840: LD_VAR 0 2
31844: PPUSH
31845: CALL_OW 306
31849: IFFALSE 31860
// ComForceInvisible ( i ) ;
31851: LD_VAR 0 2
31855: PPUSH
31856: CALL_OW 496
31860: GO 31837
31862: POP
31863: POP
// end ;
31864: LD_VAR 0 1
31868: RET
// export function hHackChangeYourSide ; begin
31869: LD_INT 0
31871: PPUSH
// if your_side = 8 then
31872: LD_OWVAR 2
31876: PUSH
31877: LD_INT 8
31879: EQUAL
31880: IFFALSE 31892
// your_side := 0 else
31882: LD_ADDR_OWVAR 2
31886: PUSH
31887: LD_INT 0
31889: ST_TO_ADDR
31890: GO 31906
// your_side := your_side + 1 ;
31892: LD_ADDR_OWVAR 2
31896: PUSH
31897: LD_OWVAR 2
31901: PUSH
31902: LD_INT 1
31904: PLUS
31905: ST_TO_ADDR
// end ;
31906: LD_VAR 0 1
31910: RET
// export function hHackChangeUnitSide ; var i , j ; begin
31911: LD_INT 0
31913: PPUSH
31914: PPUSH
31915: PPUSH
// for i in all_units do
31916: LD_ADDR_VAR 0 2
31920: PUSH
31921: LD_OWVAR 3
31925: PUSH
31926: FOR_IN
31927: IFFALSE 32005
// if IsSelected ( i ) then
31929: LD_VAR 0 2
31933: PPUSH
31934: CALL_OW 306
31938: IFFALSE 32003
// begin j := GetSide ( i ) ;
31940: LD_ADDR_VAR 0 3
31944: PUSH
31945: LD_VAR 0 2
31949: PPUSH
31950: CALL_OW 255
31954: ST_TO_ADDR
// if j = 8 then
31955: LD_VAR 0 3
31959: PUSH
31960: LD_INT 8
31962: EQUAL
31963: IFFALSE 31975
// j := 0 else
31965: LD_ADDR_VAR 0 3
31969: PUSH
31970: LD_INT 0
31972: ST_TO_ADDR
31973: GO 31989
// j := j + 1 ;
31975: LD_ADDR_VAR 0 3
31979: PUSH
31980: LD_VAR 0 3
31984: PUSH
31985: LD_INT 1
31987: PLUS
31988: ST_TO_ADDR
// SetSide ( i , j ) ;
31989: LD_VAR 0 2
31993: PPUSH
31994: LD_VAR 0 3
31998: PPUSH
31999: CALL_OW 235
// end ;
32003: GO 31926
32005: POP
32006: POP
// end ;
32007: LD_VAR 0 1
32011: RET
// export function hHackFog ; begin
32012: LD_INT 0
32014: PPUSH
// FogOff ( true ) ;
32015: LD_INT 1
32017: PPUSH
32018: CALL_OW 344
// end ;
32022: LD_VAR 0 1
32026: RET
// export function hHackApeman ; begin
32027: LD_INT 0
32029: PPUSH
// uc_side := your_side ;
32030: LD_ADDR_OWVAR 20
32034: PUSH
32035: LD_OWVAR 2
32039: ST_TO_ADDR
// uc_nation := 0 ;
32040: LD_ADDR_OWVAR 21
32044: PUSH
32045: LD_INT 0
32047: ST_TO_ADDR
// hc_name :=  ;
32048: LD_ADDR_OWVAR 26
32052: PUSH
32053: LD_STRING 
32055: ST_TO_ADDR
// hc_gallery :=  ;
32056: LD_ADDR_OWVAR 33
32060: PUSH
32061: LD_STRING 
32063: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
32064: LD_ADDR_OWVAR 31
32068: PUSH
32069: LD_INT 0
32071: PUSH
32072: LD_INT 0
32074: PUSH
32075: LD_INT 0
32077: PUSH
32078: LD_INT 0
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: ST_TO_ADDR
// hc_class := class_apeman ;
32087: LD_ADDR_OWVAR 28
32091: PUSH
32092: LD_INT 12
32094: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
32095: CALL_OW 44
32099: PPUSH
32100: LD_INT 1
32102: PPUSH
32103: CALL_OW 51
// end ;
32107: LD_VAR 0 1
32111: RET
// export function hHackBoom ; begin
32112: LD_INT 0
32114: PPUSH
// uc_side := your_side ;
32115: LD_ADDR_OWVAR 20
32119: PUSH
32120: LD_OWVAR 2
32124: ST_TO_ADDR
// uc_nation := 1 ;
32125: LD_ADDR_OWVAR 21
32129: PUSH
32130: LD_INT 1
32132: ST_TO_ADDR
// vc_chassis := us_morphling ;
32133: LD_ADDR_OWVAR 37
32137: PUSH
32138: LD_INT 5
32140: ST_TO_ADDR
// vc_engine := engine_siberite ;
32141: LD_ADDR_OWVAR 39
32145: PUSH
32146: LD_INT 3
32148: ST_TO_ADDR
// vc_control := control_computer ;
32149: LD_ADDR_OWVAR 38
32153: PUSH
32154: LD_INT 3
32156: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
32157: LD_ADDR_OWVAR 40
32161: PUSH
32162: LD_INT 8
32164: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
32165: CALL_OW 45
32169: PPUSH
32170: LD_INT 1
32172: PPUSH
32173: CALL_OW 51
// end ;
32177: LD_VAR 0 1
32181: RET
