// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 38 0 0
// PrepareNature ;
   8: CALL 649 0 0
// PrepareArabian ;
  12: CALL 1964 0 0
// PrepareAmerican ;
  16: CALL 4921 0 0
// if debug then
  20: LD_EXP 1
  24: IFFALSE 33
// FogOff ( 2 ) ;
  26: LD_INT 2
  28: PPUSH
  29: CALL_OW 344
// Action ;
  33: CALL 9565 0 0
// end ;
  37: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := false ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 0
  48: ST_TO_ADDR
// prefix := 02_ ;
  49: LD_ADDR_EXP 2
  53: PUSH
  54: LD_STRING 02_
  56: ST_TO_ADDR
// eventAttack := 1 ;
  57: LD_ADDR_EXP 20
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// deadCounter := 0 ;
  65: LD_ADDR_EXP 8
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// gameStarted := false ;
  73: LD_ADDR_EXP 3
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// farmerBaseReady := false ;
  81: LD_ADDR_EXP 4
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// americanBaseSpoted := false ;
  89: LD_ADDR_EXP 5
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// americanBaseCaptured := false ;
  97: LD_ADDR_EXP 6
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// americanHasEscaped := false ;
 105: LD_ADDR_EXP 7
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// workshopBuilded := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// retreatAllowed := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// allowConvoys := false ;
 129: LD_ADDR_EXP 11
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// farmerCrates := 0 ;
 137: LD_ADDR_EXP 12
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 145: LD_ADDR_EXP 13
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 153: LD_ADDR_EXP 14
 157: PUSH
 158: LD_INT 63000
 160: PUSH
 161: LD_INT 52500
 163: PUSH
 164: LD_INT 46200
 166: PUSH
 167: EMPTY
 168: LIST
 169: LIST
 170: LIST
 171: PUSH
 172: LD_OWVAR 67
 176: ARRAY
 177: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 178: LD_ADDR_EXP 15
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// attackWave := 1 ;
 186: LD_ADDR_EXP 16
 190: PUSH
 191: LD_INT 1
 193: ST_TO_ADDR
// omarCargoCounter := [ 6 , 8 , 10 ] [ Difficulty ] ;
 194: LD_ADDR_EXP 17
 198: PUSH
 199: LD_INT 6
 201: PUSH
 202: LD_INT 8
 204: PUSH
 205: LD_INT 10
 207: PUSH
 208: EMPTY
 209: LIST
 210: LIST
 211: LIST
 212: PUSH
 213: LD_OWVAR 67
 217: ARRAY
 218: ST_TO_ADDR
// vehCounter := 0 ;
 219: LD_ADDR_EXP 18
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// convoyCounter := 0 ;
 227: LD_ADDR_EXP 19
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// ibrahimInDepot := false ;
 235: LD_ADDR_EXP 21
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// ibrahimIsFree := false ;
 243: LD_ADDR_EXP 22
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// maxConvoys := [ 16 , 15 , 14 ] [ Difficulty ] ;
 251: LD_ADDR_EXP 23
 255: PUSH
 256: LD_INT 16
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 14
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: LIST
 269: PUSH
 270: LD_OWVAR 67
 274: ARRAY
 275: ST_TO_ADDR
// end ; end_of_file
 276: LD_VAR 0 1
 280: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 281: LD_INT 0
 283: PPUSH
 284: PPUSH
// if exist_mode then
 285: LD_VAR 0 2
 289: IFFALSE 314
// unit := CreateCharacter ( prefix & ident ) else
 291: LD_ADDR_VAR 0 5
 295: PUSH
 296: LD_VAR 0 3
 300: PUSH
 301: LD_VAR 0 1
 305: STR
 306: PPUSH
 307: CALL_OW 34
 311: ST_TO_ADDR
 312: GO 329
// unit := NewCharacter ( ident ) ;
 314: LD_ADDR_VAR 0 5
 318: PUSH
 319: LD_VAR 0 1
 323: PPUSH
 324: CALL_OW 25
 328: ST_TO_ADDR
// result := unit ;
 329: LD_ADDR_VAR 0 4
 333: PUSH
 334: LD_VAR 0 5
 338: ST_TO_ADDR
// end ;
 339: LD_VAR 0 4
 343: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 344: LD_INT 0
 346: PPUSH
// uc_side := side ;
 347: LD_ADDR_OWVAR 20
 351: PUSH
 352: LD_VAR 0 1
 356: ST_TO_ADDR
// uc_nation := nation ;
 357: LD_ADDR_OWVAR 21
 361: PUSH
 362: LD_VAR 0 2
 366: ST_TO_ADDR
// vc_chassis := chassis ;
 367: LD_ADDR_OWVAR 37
 371: PUSH
 372: LD_VAR 0 3
 376: ST_TO_ADDR
// vc_engine := engine ;
 377: LD_ADDR_OWVAR 39
 381: PUSH
 382: LD_VAR 0 4
 386: ST_TO_ADDR
// vc_control := control ;
 387: LD_ADDR_OWVAR 38
 391: PUSH
 392: LD_VAR 0 5
 396: ST_TO_ADDR
// vc_weapon := weapon ;
 397: LD_ADDR_OWVAR 40
 401: PUSH
 402: LD_VAR 0 6
 406: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 407: LD_ADDR_OWVAR 41
 411: PUSH
 412: LD_VAR 0 7
 416: ST_TO_ADDR
// result := CreateVehicle ;
 417: LD_ADDR_VAR 0 8
 421: PUSH
 422: CALL_OW 45
 426: ST_TO_ADDR
// end ;
 427: LD_VAR 0 8
 431: RET
// export function SayX ( units , ident ) ; var i ; begin
 432: LD_INT 0
 434: PPUSH
 435: PPUSH
// result := false ;
 436: LD_ADDR_VAR 0 3
 440: PUSH
 441: LD_INT 0
 443: ST_TO_ADDR
// if not units then
 444: LD_VAR 0 1
 448: NOT
 449: IFFALSE 453
// exit ;
 451: GO 507
// for i in units do
 453: LD_ADDR_VAR 0 4
 457: PUSH
 458: LD_VAR 0 1
 462: PUSH
 463: FOR_IN
 464: IFFALSE 505
// if IsOk ( i ) then
 466: LD_VAR 0 4
 470: PPUSH
 471: CALL_OW 302
 475: IFFALSE 503
// begin Say ( i , ident ) ;
 477: LD_VAR 0 4
 481: PPUSH
 482: LD_VAR 0 2
 486: PPUSH
 487: CALL_OW 88
// result := i ;
 491: LD_ADDR_VAR 0 3
 495: PUSH
 496: LD_VAR 0 4
 500: ST_TO_ADDR
// break ;
 501: GO 505
// end ;
 503: GO 463
 505: POP
 506: POP
// end ;
 507: LD_VAR 0 3
 511: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 512: LD_INT 0
 514: PPUSH
 515: PPUSH
// InitUc ;
 516: CALL_OW 18
// InitHc ;
 520: CALL_OW 19
// uc_side := 0 ;
 524: LD_ADDR_OWVAR 20
 528: PUSH
 529: LD_INT 0
 531: ST_TO_ADDR
// uc_nation := 0 ;
 532: LD_ADDR_OWVAR 21
 536: PUSH
 537: LD_INT 0
 539: ST_TO_ADDR
// for i = 1 to amount do
 540: LD_ADDR_VAR 0 4
 544: PUSH
 545: DOUBLE
 546: LD_INT 1
 548: DEC
 549: ST_TO_ADDR
 550: LD_VAR 0 2
 554: PUSH
 555: FOR_TO
 556: IFFALSE 638
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 558: LD_ADDR_OWVAR 29
 562: PUSH
 563: LD_INT 9
 565: PPUSH
 566: LD_INT 12
 568: PPUSH
 569: CALL_OW 12
 573: PUSH
 574: LD_INT 9
 576: PPUSH
 577: LD_INT 12
 579: PPUSH
 580: CALL_OW 12
 584: PUSH
 585: EMPTY
 586: LIST
 587: LIST
 588: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 589: LD_ADDR_OWVAR 35
 593: PUSH
 594: LD_INT 1
 596: NEG
 597: PPUSH
 598: LD_INT 1
 600: PPUSH
 601: CALL_OW 12
 605: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 606: LD_INT 0
 608: PPUSH
 609: LD_INT 12
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 619: CALL_OW 44
 623: PPUSH
 624: LD_VAR 0 1
 628: PPUSH
 629: LD_INT 0
 631: PPUSH
 632: CALL_OW 49
// end ;
 636: GO 555
 638: POP
 639: POP
// InitHc ;
 640: CALL_OW 19
// end ;
 644: LD_VAR 0 3
 648: RET
// export function PrepareNature ; var i ; begin
 649: LD_INT 0
 651: PPUSH
 652: PPUSH
// SpawnApeman ( forest , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
 653: LD_INT 2
 655: PPUSH
 656: LD_INT 4
 658: PUSH
 659: LD_INT 4
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_OWVAR 67
 674: ARRAY
 675: PPUSH
 676: CALL 512 0 2
// for i := 1 to 2 do
 680: LD_ADDR_VAR 0 2
 684: PUSH
 685: DOUBLE
 686: LD_INT 1
 688: DEC
 689: ST_TO_ADDR
 690: LD_INT 2
 692: PUSH
 693: FOR_TO
 694: IFFALSE 729
// begin hc_class := 21 ;
 696: LD_ADDR_OWVAR 28
 700: PUSH
 701: LD_INT 21
 703: ST_TO_ADDR
// hc_gallery :=  ;
 704: LD_ADDR_OWVAR 33
 708: PUSH
 709: LD_STRING 
 711: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 712: CALL_OW 44
 716: PPUSH
 717: LD_INT 2
 719: PPUSH
 720: LD_INT 0
 722: PPUSH
 723: CALL_OW 49
// end ;
 727: GO 693
 729: POP
 730: POP
// for i := 1 to 2 do
 731: LD_ADDR_VAR 0 2
 735: PUSH
 736: DOUBLE
 737: LD_INT 1
 739: DEC
 740: ST_TO_ADDR
 741: LD_INT 2
 743: PUSH
 744: FOR_TO
 745: IFFALSE 780
// begin hc_class := 18 ;
 747: LD_ADDR_OWVAR 28
 751: PUSH
 752: LD_INT 18
 754: ST_TO_ADDR
// hc_gallery :=  ;
 755: LD_ADDR_OWVAR 33
 759: PUSH
 760: LD_STRING 
 762: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 763: CALL_OW 44
 767: PPUSH
 768: LD_INT 2
 770: PPUSH
 771: LD_INT 0
 773: PPUSH
 774: CALL_OW 49
// end ;
 778: GO 744
 780: POP
 781: POP
// for i := 1 to 2 do
 782: LD_ADDR_VAR 0 2
 786: PUSH
 787: DOUBLE
 788: LD_INT 1
 790: DEC
 791: ST_TO_ADDR
 792: LD_INT 2
 794: PUSH
 795: FOR_TO
 796: IFFALSE 831
// begin hc_class := 13 ;
 798: LD_ADDR_OWVAR 28
 802: PUSH
 803: LD_INT 13
 805: ST_TO_ADDR
// hc_gallery :=  ;
 806: LD_ADDR_OWVAR 33
 810: PUSH
 811: LD_STRING 
 813: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 814: CALL_OW 44
 818: PPUSH
 819: LD_INT 2
 821: PPUSH
 822: LD_INT 0
 824: PPUSH
 825: CALL_OW 49
// end ;
 829: GO 795
 831: POP
 832: POP
// end ;
 833: LD_VAR 0 1
 837: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 838: LD_INT 0
 840: PPUSH
 841: PPUSH
 842: PPUSH
// if not observer or not unit then
 843: LD_VAR 0 1
 847: NOT
 848: PUSH
 849: LD_VAR 0 2
 853: NOT
 854: OR
 855: IFFALSE 859
// exit ;
 857: GO 907
// if not See ( GetSide ( observer ) , unit ) then
 859: LD_VAR 0 1
 863: PPUSH
 864: CALL_OW 255
 868: PPUSH
 869: LD_VAR 0 2
 873: PPUSH
 874: CALL_OW 292
 878: NOT
 879: IFFALSE 883
// exit ;
 881: GO 907
// result := GetDistUnits ( observer , unit ) < 12 ;
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: LD_VAR 0 1
 892: PPUSH
 893: LD_VAR 0 2
 897: PPUSH
 898: CALL_OW 296
 902: PUSH
 903: LD_INT 12
 905: LESS
 906: ST_TO_ADDR
// end ;
 907: LD_VAR 0 3
 911: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 912: LD_INT 0
 914: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 915: LD_VAR 0 2
 919: PUSH
 920: LD_INT 1
 922: ARRAY
 923: PPUSH
 924: LD_VAR 0 2
 928: PUSH
 929: LD_INT 2
 931: ARRAY
 932: PPUSH
 933: CALL_OW 488
 937: PUSH
 938: LD_VAR 0 2
 942: PUSH
 943: LD_INT 1
 945: ARRAY
 946: PPUSH
 947: LD_VAR 0 2
 951: PUSH
 952: LD_INT 2
 954: ARRAY
 955: PPUSH
 956: CALL_OW 428
 960: PUSH
 961: LD_INT 0
 963: EQUAL
 964: AND
 965: IFFALSE 999
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 967: LD_VAR 0 1
 971: PPUSH
 972: LD_VAR 0 2
 976: PUSH
 977: LD_INT 1
 979: ARRAY
 980: PPUSH
 981: LD_VAR 0 2
 985: PUSH
 986: LD_INT 2
 988: ARRAY
 989: PPUSH
 990: LD_VAR 0 3
 994: PPUSH
 995: CALL_OW 48
// end ;
 999: LD_VAR 0 4
1003: RET
// export function Video ( mode ) ; begin
1004: LD_INT 0
1006: PPUSH
// ingame_video = mode ;
1007: LD_ADDR_OWVAR 52
1011: PUSH
1012: LD_VAR 0 1
1016: ST_TO_ADDR
// interface_hidden = mode ;
1017: LD_ADDR_OWVAR 54
1021: PUSH
1022: LD_VAR 0 1
1026: ST_TO_ADDR
// end ;
1027: LD_VAR 0 2
1031: RET
// export function ReverseArray ( array ) ; var i ; begin
1032: LD_INT 0
1034: PPUSH
1035: PPUSH
// if not array then
1036: LD_VAR 0 1
1040: NOT
1041: IFFALSE 1045
// exit ;
1043: GO 1103
// result := [ ] ;
1045: LD_ADDR_VAR 0 2
1049: PUSH
1050: EMPTY
1051: ST_TO_ADDR
// for i := 1 to array do
1052: LD_ADDR_VAR 0 3
1056: PUSH
1057: DOUBLE
1058: LD_INT 1
1060: DEC
1061: ST_TO_ADDR
1062: LD_VAR 0 1
1066: PUSH
1067: FOR_TO
1068: IFFALSE 1101
// result := Insert ( result , 1 , array [ i ] ) ;
1070: LD_ADDR_VAR 0 2
1074: PUSH
1075: LD_VAR 0 2
1079: PPUSH
1080: LD_INT 1
1082: PPUSH
1083: LD_VAR 0 1
1087: PUSH
1088: LD_VAR 0 3
1092: ARRAY
1093: PPUSH
1094: CALL_OW 2
1098: ST_TO_ADDR
1099: GO 1067
1101: POP
1102: POP
// end ;
1103: LD_VAR 0 2
1107: RET
// export function ComExit ( unit ) ; begin
1108: LD_INT 0
1110: PPUSH
// result := IsInUnit ( unit ) ;
1111: LD_ADDR_VAR 0 2
1115: PUSH
1116: LD_VAR 0 1
1120: PPUSH
1121: CALL_OW 310
1125: ST_TO_ADDR
// if not result then
1126: LD_VAR 0 2
1130: NOT
1131: IFFALSE 1135
// exit ;
1133: GO 1170
// if GetType ( result ) = unit_vehicle then
1135: LD_VAR 0 2
1139: PPUSH
1140: CALL_OW 247
1144: PUSH
1145: LD_INT 2
1147: EQUAL
1148: IFFALSE 1161
// ComExitVehicle ( unit ) else
1150: LD_VAR 0 1
1154: PPUSH
1155: CALL_OW 121
1159: GO 1170
// ComExitBuilding ( unit ) ;
1161: LD_VAR 0 1
1165: PPUSH
1166: CALL_OW 122
// end ;
1170: LD_VAR 0 2
1174: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1175: LD_INT 0
1177: PPUSH
1178: PPUSH
// if not side or not nation then
1179: LD_VAR 0 1
1183: NOT
1184: PUSH
1185: LD_VAR 0 2
1189: NOT
1190: OR
1191: IFFALSE 1195
// exit ;
1193: GO 1959
// case nation of nation_american :
1195: LD_VAR 0 2
1199: PUSH
1200: LD_INT 1
1202: DOUBLE
1203: EQUAL
1204: IFTRUE 1208
1206: GO 1422
1208: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1209: LD_ADDR_VAR 0 4
1213: PUSH
1214: LD_INT 35
1216: PUSH
1217: LD_INT 45
1219: PUSH
1220: LD_INT 46
1222: PUSH
1223: LD_INT 47
1225: PUSH
1226: LD_INT 82
1228: PUSH
1229: LD_INT 83
1231: PUSH
1232: LD_INT 84
1234: PUSH
1235: LD_INT 85
1237: PUSH
1238: LD_INT 86
1240: PUSH
1241: LD_INT 1
1243: PUSH
1244: LD_INT 2
1246: PUSH
1247: LD_INT 6
1249: PUSH
1250: LD_INT 15
1252: PUSH
1253: LD_INT 16
1255: PUSH
1256: LD_INT 7
1258: PUSH
1259: LD_INT 12
1261: PUSH
1262: LD_INT 13
1264: PUSH
1265: LD_INT 10
1267: PUSH
1268: LD_INT 14
1270: PUSH
1271: LD_INT 20
1273: PUSH
1274: LD_INT 21
1276: PUSH
1277: LD_INT 22
1279: PUSH
1280: LD_INT 25
1282: PUSH
1283: LD_INT 32
1285: PUSH
1286: LD_INT 27
1288: PUSH
1289: LD_INT 36
1291: PUSH
1292: LD_INT 69
1294: PUSH
1295: LD_INT 39
1297: PUSH
1298: LD_INT 34
1300: PUSH
1301: LD_INT 40
1303: PUSH
1304: LD_INT 48
1306: PUSH
1307: LD_INT 49
1309: PUSH
1310: LD_INT 50
1312: PUSH
1313: LD_INT 51
1315: PUSH
1316: LD_INT 52
1318: PUSH
1319: LD_INT 53
1321: PUSH
1322: LD_INT 54
1324: PUSH
1325: LD_INT 55
1327: PUSH
1328: LD_INT 56
1330: PUSH
1331: LD_INT 57
1333: PUSH
1334: LD_INT 58
1336: PUSH
1337: LD_INT 59
1339: PUSH
1340: LD_INT 60
1342: PUSH
1343: LD_INT 61
1345: PUSH
1346: LD_INT 62
1348: PUSH
1349: LD_INT 80
1351: PUSH
1352: LD_INT 82
1354: PUSH
1355: LD_INT 83
1357: PUSH
1358: LD_INT 84
1360: PUSH
1361: LD_INT 85
1363: PUSH
1364: LD_INT 86
1366: PUSH
1367: EMPTY
1368: LIST
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: ST_TO_ADDR
1420: GO 1883
1422: LD_INT 2
1424: DOUBLE
1425: EQUAL
1426: IFTRUE 1430
1428: GO 1652
1430: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1431: LD_ADDR_VAR 0 4
1435: PUSH
1436: LD_INT 35
1438: PUSH
1439: LD_INT 45
1441: PUSH
1442: LD_INT 46
1444: PUSH
1445: LD_INT 47
1447: PUSH
1448: LD_INT 82
1450: PUSH
1451: LD_INT 83
1453: PUSH
1454: LD_INT 84
1456: PUSH
1457: LD_INT 85
1459: PUSH
1460: LD_INT 87
1462: PUSH
1463: LD_INT 70
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 11
1471: PUSH
1472: LD_INT 3
1474: PUSH
1475: LD_INT 4
1477: PUSH
1478: LD_INT 5
1480: PUSH
1481: LD_INT 6
1483: PUSH
1484: LD_INT 15
1486: PUSH
1487: LD_INT 18
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: LD_INT 17
1495: PUSH
1496: LD_INT 8
1498: PUSH
1499: LD_INT 20
1501: PUSH
1502: LD_INT 21
1504: PUSH
1505: LD_INT 22
1507: PUSH
1508: LD_INT 72
1510: PUSH
1511: LD_INT 26
1513: PUSH
1514: LD_INT 69
1516: PUSH
1517: LD_INT 39
1519: PUSH
1520: LD_INT 40
1522: PUSH
1523: LD_INT 41
1525: PUSH
1526: LD_INT 42
1528: PUSH
1529: LD_INT 43
1531: PUSH
1532: LD_INT 48
1534: PUSH
1535: LD_INT 49
1537: PUSH
1538: LD_INT 50
1540: PUSH
1541: LD_INT 51
1543: PUSH
1544: LD_INT 52
1546: PUSH
1547: LD_INT 53
1549: PUSH
1550: LD_INT 54
1552: PUSH
1553: LD_INT 55
1555: PUSH
1556: LD_INT 56
1558: PUSH
1559: LD_INT 60
1561: PUSH
1562: LD_INT 61
1564: PUSH
1565: LD_INT 62
1567: PUSH
1568: LD_INT 66
1570: PUSH
1571: LD_INT 67
1573: PUSH
1574: LD_INT 68
1576: PUSH
1577: LD_INT 81
1579: PUSH
1580: LD_INT 82
1582: PUSH
1583: LD_INT 83
1585: PUSH
1586: LD_INT 84
1588: PUSH
1589: LD_INT 85
1591: PUSH
1592: LD_INT 87
1594: PUSH
1595: EMPTY
1596: LIST
1597: LIST
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: LIST
1610: LIST
1611: LIST
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: LIST
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: ST_TO_ADDR
1650: GO 1883
1652: LD_INT 3
1654: DOUBLE
1655: EQUAL
1656: IFTRUE 1660
1658: GO 1882
1660: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1661: LD_ADDR_VAR 0 4
1665: PUSH
1666: LD_INT 46
1668: PUSH
1669: LD_INT 47
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 2
1677: PUSH
1678: LD_INT 82
1680: PUSH
1681: LD_INT 83
1683: PUSH
1684: LD_INT 84
1686: PUSH
1687: LD_INT 85
1689: PUSH
1690: LD_INT 86
1692: PUSH
1693: LD_INT 11
1695: PUSH
1696: LD_INT 9
1698: PUSH
1699: LD_INT 20
1701: PUSH
1702: LD_INT 19
1704: PUSH
1705: LD_INT 21
1707: PUSH
1708: LD_INT 24
1710: PUSH
1711: LD_INT 22
1713: PUSH
1714: LD_INT 25
1716: PUSH
1717: LD_INT 28
1719: PUSH
1720: LD_INT 29
1722: PUSH
1723: LD_INT 30
1725: PUSH
1726: LD_INT 31
1728: PUSH
1729: LD_INT 37
1731: PUSH
1732: LD_INT 38
1734: PUSH
1735: LD_INT 32
1737: PUSH
1738: LD_INT 27
1740: PUSH
1741: LD_INT 33
1743: PUSH
1744: LD_INT 69
1746: PUSH
1747: LD_INT 39
1749: PUSH
1750: LD_INT 34
1752: PUSH
1753: LD_INT 40
1755: PUSH
1756: LD_INT 71
1758: PUSH
1759: LD_INT 23
1761: PUSH
1762: LD_INT 44
1764: PUSH
1765: LD_INT 48
1767: PUSH
1768: LD_INT 49
1770: PUSH
1771: LD_INT 50
1773: PUSH
1774: LD_INT 51
1776: PUSH
1777: LD_INT 52
1779: PUSH
1780: LD_INT 53
1782: PUSH
1783: LD_INT 54
1785: PUSH
1786: LD_INT 55
1788: PUSH
1789: LD_INT 56
1791: PUSH
1792: LD_INT 57
1794: PUSH
1795: LD_INT 58
1797: PUSH
1798: LD_INT 59
1800: PUSH
1801: LD_INT 63
1803: PUSH
1804: LD_INT 64
1806: PUSH
1807: LD_INT 65
1809: PUSH
1810: LD_INT 82
1812: PUSH
1813: LD_INT 83
1815: PUSH
1816: LD_INT 84
1818: PUSH
1819: LD_INT 85
1821: PUSH
1822: LD_INT 86
1824: PUSH
1825: EMPTY
1826: LIST
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: ST_TO_ADDR
1880: GO 1883
1882: POP
// if state > - 1 and state < 3 then
1883: LD_VAR 0 3
1887: PUSH
1888: LD_INT 1
1890: NEG
1891: GREATER
1892: PUSH
1893: LD_VAR 0 3
1897: PUSH
1898: LD_INT 3
1900: LESS
1901: AND
1902: IFFALSE 1959
// for i in result do
1904: LD_ADDR_VAR 0 5
1908: PUSH
1909: LD_VAR 0 4
1913: PUSH
1914: FOR_IN
1915: IFFALSE 1957
// if GetTech ( i , side ) <> state then
1917: LD_VAR 0 5
1921: PPUSH
1922: LD_VAR 0 1
1926: PPUSH
1927: CALL_OW 321
1931: PUSH
1932: LD_VAR 0 3
1936: NONEQUAL
1937: IFFALSE 1955
// result := result diff i ;
1939: LD_ADDR_VAR 0 4
1943: PUSH
1944: LD_VAR 0 4
1948: PUSH
1949: LD_VAR 0 5
1953: DIFF
1954: ST_TO_ADDR
1955: GO 1914
1957: POP
1958: POP
// end ; end_of_file
1959: LD_VAR 0 4
1963: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1964: LD_INT 0
1966: PPUSH
1967: PPUSH
1968: PPUSH
1969: PPUSH
// uc_side := 5 ;
1970: LD_ADDR_OWVAR 20
1974: PUSH
1975: LD_INT 5
1977: ST_TO_ADDR
// uc_nation := 2 ;
1978: LD_ADDR_OWVAR 21
1982: PUSH
1983: LD_INT 2
1985: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
1986: LD_INT 5
1988: PPUSH
1989: CALL_OW 274
1993: PPUSH
1994: LD_INT 1
1996: PPUSH
1997: LD_INT 45
1999: PPUSH
2000: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
2004: LD_ADDR_EXP 32
2008: PUSH
2009: LD_STRING Farmer
2011: PPUSH
2012: LD_INT 0
2014: PPUSH
2015: LD_STRING 
2017: PPUSH
2018: CALL 281 0 3
2022: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2023: LD_ADDR_EXP 33
2027: PUSH
2028: LD_STRING Omar
2030: PPUSH
2031: LD_INT 0
2033: PPUSH
2034: LD_STRING 
2036: PPUSH
2037: CALL 281 0 3
2041: ST_TO_ADDR
// omarSquad := [ ] ;
2042: LD_ADDR_EXP 36
2046: PUSH
2047: EMPTY
2048: ST_TO_ADDR
// heikeSquad := [ ] ;
2049: LD_ADDR_EXP 37
2053: PUSH
2054: EMPTY
2055: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2056: LD_ADDR_EXP 38
2060: PUSH
2061: EMPTY
2062: ST_TO_ADDR
// omarCargo := [ ] ;
2063: LD_ADDR_EXP 39
2067: PUSH
2068: EMPTY
2069: ST_TO_ADDR
// for i := 1 to 5 do
2070: LD_ADDR_VAR 0 2
2074: PUSH
2075: DOUBLE
2076: LD_INT 1
2078: DEC
2079: ST_TO_ADDR
2080: LD_INT 5
2082: PUSH
2083: FOR_TO
2084: IFFALSE 2242
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2086: LD_INT 0
2088: PPUSH
2089: LD_INT 1
2091: PUSH
2092: LD_INT 1
2094: PUSH
2095: LD_INT 2
2097: PUSH
2098: LD_INT 1
2100: PUSH
2101: LD_INT 1
2103: PUSH
2104: EMPTY
2105: LIST
2106: LIST
2107: LIST
2108: LIST
2109: LIST
2110: PUSH
2111: LD_VAR 0 2
2115: ARRAY
2116: PPUSH
2117: LD_INT 3
2119: PPUSH
2120: CALL_OW 380
// un := CreateHuman ;
2124: LD_ADDR_VAR 0 3
2128: PUSH
2129: CALL_OW 44
2133: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2134: LD_ADDR_EXP 36
2138: PUSH
2139: LD_EXP 36
2143: PUSH
2144: LD_VAR 0 3
2148: UNION
2149: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2150: LD_VAR 0 3
2154: PPUSH
2155: LD_INT 87
2157: PUSH
2158: LD_INT 30
2160: PUSH
2161: EMPTY
2162: LIST
2163: LIST
2164: PUSH
2165: LD_INT 91
2167: PUSH
2168: LD_INT 32
2170: PUSH
2171: EMPTY
2172: LIST
2173: LIST
2174: PUSH
2175: LD_INT 82
2177: PUSH
2178: LD_INT 15
2180: PUSH
2181: EMPTY
2182: LIST
2183: LIST
2184: PUSH
2185: LD_INT 79
2187: PUSH
2188: LD_INT 14
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: PUSH
2195: LD_INT 82
2197: PUSH
2198: LD_INT 13
2200: PUSH
2201: EMPTY
2202: LIST
2203: LIST
2204: PUSH
2205: EMPTY
2206: LIST
2207: LIST
2208: LIST
2209: LIST
2210: LIST
2211: PUSH
2212: LD_VAR 0 2
2216: ARRAY
2217: PPUSH
2218: LD_INT 0
2220: PPUSH
2221: CALL 912 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2225: LD_VAR 0 3
2229: PPUSH
2230: LD_INT 93
2232: PPUSH
2233: LD_INT 21
2235: PPUSH
2236: CALL_OW 118
// end ;
2240: GO 2083
2242: POP
2243: POP
// uc_side := 2 ;
2244: LD_ADDR_OWVAR 20
2248: PUSH
2249: LD_INT 2
2251: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2252: LD_ADDR_EXP 24
2256: PUSH
2257: LD_STRING Heike
2259: PPUSH
2260: LD_EXP 1
2264: NOT
2265: PPUSH
2266: LD_EXP 2
2270: PPUSH
2271: CALL 281 0 3
2275: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2276: LD_ADDR_EXP 28
2280: PUSH
2281: LD_STRING Aviradze
2283: PPUSH
2284: LD_EXP 1
2288: NOT
2289: PPUSH
2290: LD_EXP 2
2294: PPUSH
2295: CALL 281 0 3
2299: ST_TO_ADDR
// tmp := [ ] ;
2300: LD_ADDR_VAR 0 4
2304: PUSH
2305: EMPTY
2306: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2307: LD_ADDR_EXP 25
2311: PUSH
2312: LD_STRING Givi
2314: PPUSH
2315: LD_EXP 1
2319: NOT
2320: PPUSH
2321: LD_EXP 2
2325: PPUSH
2326: CALL 281 0 3
2330: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2331: LD_ADDR_EXP 26
2335: PUSH
2336: LD_STRING Mike
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_EXP 2
2349: PPUSH
2350: CALL 281 0 3
2354: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2355: LD_ADDR_EXP 27
2359: PUSH
2360: LD_STRING Kamil
2362: PPUSH
2363: LD_EXP 1
2367: NOT
2368: PPUSH
2369: LD_EXP 2
2373: PPUSH
2374: CALL 281 0 3
2378: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2379: LD_ADDR_EXP 29
2383: PUSH
2384: LD_STRING Kaia
2386: PPUSH
2387: LD_EXP 1
2391: NOT
2392: PPUSH
2393: LD_EXP 2
2397: PPUSH
2398: CALL 281 0 3
2402: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2403: LD_ADDR_EXP 30
2407: PUSH
2408: LD_STRING Sophia
2410: PPUSH
2411: LD_EXP 1
2415: NOT
2416: PPUSH
2417: LD_EXP 2
2421: PPUSH
2422: CALL 281 0 3
2426: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2427: LD_ADDR_EXP 31
2431: PUSH
2432: LD_STRING Markov
2434: PPUSH
2435: LD_EXP 1
2439: NOT
2440: PPUSH
2441: LD_EXP 2
2445: PPUSH
2446: CALL 281 0 3
2450: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2451: LD_ADDR_EXP 38
2455: PUSH
2456: LD_STRING 02_others
2458: PPUSH
2459: CALL_OW 31
2463: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2464: LD_ADDR_VAR 0 4
2468: PUSH
2469: LD_EXP 26
2473: PUSH
2474: LD_EXP 27
2478: PUSH
2479: LD_EXP 29
2483: PUSH
2484: LD_EXP 30
2488: PUSH
2489: LD_EXP 31
2493: PUSH
2494: LD_EXP 25
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: LIST
2503: LIST
2504: LIST
2505: LIST
2506: PUSH
2507: LD_EXP 38
2511: ADD
2512: PUSH
2513: LD_INT 0
2515: DIFF
2516: ST_TO_ADDR
// heikeSquad := tmp ;
2517: LD_ADDR_EXP 37
2521: PUSH
2522: LD_VAR 0 4
2526: ST_TO_ADDR
// uc_nation := 0 ;
2527: LD_ADDR_OWVAR 21
2531: PUSH
2532: LD_INT 0
2534: ST_TO_ADDR
// hc_class := class_apeman ;
2535: LD_ADDR_OWVAR 28
2539: PUSH
2540: LD_INT 12
2542: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
2543: LD_ADDR_OWVAR 31
2547: PUSH
2548: LD_INT 0
2550: PUSH
2551: LD_INT 0
2553: PUSH
2554: LD_INT 0
2556: PUSH
2557: LD_INT 0
2559: PUSH
2560: EMPTY
2561: LIST
2562: LIST
2563: LIST
2564: LIST
2565: ST_TO_ADDR
// hc_gallery :=  ;
2566: LD_ADDR_OWVAR 33
2570: PUSH
2571: LD_STRING 
2573: ST_TO_ADDR
// hc_name :=  ;
2574: LD_ADDR_OWVAR 26
2578: PUSH
2579: LD_STRING 
2581: ST_TO_ADDR
// tmp := tmp union CreateHuman ;
2582: LD_ADDR_VAR 0 4
2586: PUSH
2587: LD_VAR 0 4
2591: PUSH
2592: CALL_OW 44
2596: UNION
2597: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2598: LD_EXP 24
2602: PPUSH
2603: LD_INT 92
2605: PPUSH
2606: LD_INT 17
2608: PPUSH
2609: LD_INT 0
2611: PPUSH
2612: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2616: LD_EXP 32
2620: PPUSH
2621: LD_INT 95
2623: PPUSH
2624: LD_INT 19
2626: PPUSH
2627: LD_INT 0
2629: PPUSH
2630: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2634: LD_EXP 33
2638: PPUSH
2639: LD_INT 89
2641: PPUSH
2642: LD_INT 25
2644: PPUSH
2645: LD_INT 0
2647: PPUSH
2648: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2652: LD_EXP 28
2656: PPUSH
2657: LD_INT 92
2659: PPUSH
2660: LD_INT 27
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2670: LD_EXP 33
2674: PPUSH
2675: LD_EXP 28
2679: PPUSH
2680: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2684: LD_EXP 28
2688: PPUSH
2689: LD_EXP 33
2693: PPUSH
2694: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2698: LD_EXP 24
2702: PUSH
2703: LD_EXP 32
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: PPUSH
2712: LD_EXP 33
2716: PPUSH
2717: CALL_OW 119
// if tmp then
2721: LD_VAR 0 4
2725: IFFALSE 2779
// for i in tmp do
2727: LD_ADDR_VAR 0 2
2731: PUSH
2732: LD_VAR 0 4
2736: PUSH
2737: FOR_IN
2738: IFFALSE 2777
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2740: LD_VAR 0 2
2744: PPUSH
2745: LD_INT 94
2747: PPUSH
2748: LD_INT 14
2750: PPUSH
2751: LD_INT 4
2753: PPUSH
2754: LD_INT 0
2756: PPUSH
2757: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2761: LD_VAR 0 2
2765: PPUSH
2766: LD_EXP 24
2770: PPUSH
2771: CALL_OW 119
// end ;
2775: GO 2737
2777: POP
2778: POP
// farmerSquad := [ ] ;
2779: LD_ADDR_EXP 35
2783: PUSH
2784: EMPTY
2785: ST_TO_ADDR
// uc_side := 5 ;
2786: LD_ADDR_OWVAR 20
2790: PUSH
2791: LD_INT 5
2793: ST_TO_ADDR
// uc_nation := 2 ;
2794: LD_ADDR_OWVAR 21
2798: PUSH
2799: LD_INT 2
2801: ST_TO_ADDR
// for i := 1 to 4 do
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: DOUBLE
2808: LD_INT 1
2810: DEC
2811: ST_TO_ADDR
2812: LD_INT 4
2814: PUSH
2815: FOR_TO
2816: IFFALSE 2894
// begin PrepareHuman ( false , 1 , 2 ) ;
2818: LD_INT 0
2820: PPUSH
2821: LD_INT 1
2823: PPUSH
2824: LD_INT 2
2826: PPUSH
2827: CALL_OW 380
// un := CreateHuman ;
2831: LD_ADDR_VAR 0 3
2835: PUSH
2836: CALL_OW 44
2840: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2841: LD_VAR 0 3
2845: PPUSH
2846: LD_INT 102
2848: PPUSH
2849: LD_INT 27
2851: PPUSH
2852: LD_INT 4
2854: PPUSH
2855: LD_INT 0
2857: PPUSH
2858: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2862: LD_ADDR_EXP 35
2866: PUSH
2867: LD_EXP 35
2871: PUSH
2872: LD_VAR 0 3
2876: UNION
2877: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2878: LD_VAR 0 3
2882: PPUSH
2883: LD_EXP 33
2887: PPUSH
2888: CALL_OW 119
// end ;
2892: GO 2815
2894: POP
2895: POP
// PrepareHuman ( false , 2 , 2 ) ;
2896: LD_INT 0
2898: PPUSH
2899: LD_INT 2
2901: PPUSH
2902: LD_INT 2
2904: PPUSH
2905: CALL_OW 380
// un := CreateHuman ;
2909: LD_ADDR_VAR 0 3
2913: PUSH
2914: CALL_OW 44
2918: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2919: LD_VAR 0 3
2923: PPUSH
2924: LD_INT 108
2926: PPUSH
2927: LD_INT 62
2929: PPUSH
2930: LD_INT 2
2932: PPUSH
2933: LD_INT 0
2935: PPUSH
2936: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2940: LD_ADDR_EXP 35
2944: PUSH
2945: LD_EXP 35
2949: PUSH
2950: LD_VAR 0 3
2954: UNION
2955: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2956: LD_VAR 0 3
2960: PPUSH
2961: LD_EXP 33
2965: PPUSH
2966: CALL_OW 119
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
2970: LD_INT 109
2972: PPUSH
2973: LD_INT 63
2975: PPUSH
2976: LD_INT 2
2978: PPUSH
2979: LD_INT 15
2981: NEG
2982: PPUSH
2983: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
2987: LD_INT 109
2989: PPUSH
2990: LD_INT 63
2992: PPUSH
2993: LD_INT 2
2995: PPUSH
2996: CALL_OW 331
// end ;
3000: LD_VAR 0 1
3004: RET
// export function PrepareIbrahim ( x , y ) ; begin
3005: LD_INT 0
3007: PPUSH
// uc_side := 6 ;
3008: LD_ADDR_OWVAR 20
3012: PUSH
3013: LD_INT 6
3015: ST_TO_ADDR
// uc_nation := 3 ;
3016: LD_ADDR_OWVAR 21
3020: PUSH
3021: LD_INT 3
3023: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3024: LD_ADDR_EXP 34
3028: PUSH
3029: LD_STRING IbrahimRu
3031: PPUSH
3032: LD_INT 0
3034: PPUSH
3035: LD_STRING 
3037: PPUSH
3038: CALL 281 0 3
3042: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3043: LD_EXP 34
3047: PPUSH
3048: LD_VAR 0 1
3052: PPUSH
3053: LD_VAR 0 2
3057: PPUSH
3058: LD_INT 8
3060: PPUSH
3061: LD_INT 1
3063: PPUSH
3064: CALL_OW 50
// end ;
3068: LD_VAR 0 3
3072: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3073: LD_EXP 33
3077: PUSH
3078: LD_EXP 36
3082: ADD
3083: PPUSH
3084: LD_INT 95
3086: PUSH
3087: LD_INT 3
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: PPUSH
3094: CALL_OW 72
3098: IFFALSE 3154
3100: GO 3102
3102: DISABLE
3103: LD_INT 0
3105: PPUSH
// begin enable ;
3106: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3107: LD_ADDR_VAR 0 1
3111: PUSH
3112: LD_EXP 33
3116: PUSH
3117: LD_EXP 36
3121: ADD
3122: PPUSH
3123: LD_INT 95
3125: PUSH
3126: LD_INT 3
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PPUSH
3133: CALL_OW 72
3137: PUSH
3138: FOR_IN
3139: IFFALSE 3152
// RemoveUnit ( i ) ;
3141: LD_VAR 0 1
3145: PPUSH
3146: CALL_OW 64
3150: GO 3138
3152: POP
3153: POP
// end ;
3154: PPOPN 1
3156: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3157: LD_EXP 3
3161: PUSH
3162: LD_EXP 32
3166: PPUSH
3167: LD_INT 4
3169: PPUSH
3170: CALL_OW 308
3174: AND
3175: IFFALSE 3958
3177: GO 3179
3179: DISABLE
3180: LD_INT 0
3182: PPUSH
3183: PPUSH
3184: PPUSH
3185: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3186: LD_EXP 32
3190: PPUSH
3191: LD_INT 110
3193: PPUSH
3194: LD_INT 60
3196: PPUSH
3197: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3201: LD_EXP 32
3205: PPUSH
3206: LD_INT 110
3208: PPUSH
3209: LD_INT 61
3211: PPUSH
3212: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3216: LD_ADDR_VAR 0 2
3220: PUSH
3221: LD_EXP 35
3225: PPUSH
3226: LD_INT 25
3228: PUSH
3229: LD_INT 1
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: PPUSH
3236: CALL_OW 72
3240: ST_TO_ADDR
// if tmp then
3241: LD_VAR 0 2
3245: IFFALSE 3339
// begin for i := 1 to 2 do
3247: LD_ADDR_VAR 0 1
3251: PUSH
3252: DOUBLE
3253: LD_INT 1
3255: DEC
3256: ST_TO_ADDR
3257: LD_INT 2
3259: PUSH
3260: FOR_TO
3261: IFFALSE 3337
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3263: LD_VAR 0 2
3267: PUSH
3268: LD_VAR 0 1
3272: ARRAY
3273: PPUSH
3274: LD_INT 5
3276: PPUSH
3277: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3281: LD_VAR 0 2
3285: PUSH
3286: LD_VAR 0 1
3290: ARRAY
3291: PPUSH
3292: LD_INT 2
3294: PPUSH
3295: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3299: LD_VAR 0 2
3303: PUSH
3304: LD_VAR 0 1
3308: ARRAY
3309: PPUSH
3310: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3314: LD_VAR 0 2
3318: PUSH
3319: LD_VAR 0 1
3323: ARRAY
3324: PPUSH
3325: LD_INT 107
3327: PPUSH
3328: LD_INT 66
3330: PPUSH
3331: CALL_OW 171
// end ;
3335: GO 3260
3337: POP
3338: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3339: LD_ADDR_VAR 0 2
3343: PUSH
3344: LD_EXP 35
3348: PPUSH
3349: LD_INT 25
3351: PUSH
3352: LD_INT 2
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: PPUSH
3359: CALL_OW 72
3363: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3364: LD_INT 35
3366: PPUSH
3367: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3371: LD_ADDR_VAR 0 2
3375: PUSH
3376: LD_EXP 35
3380: PPUSH
3381: LD_INT 25
3383: PUSH
3384: LD_INT 2
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: PPUSH
3391: CALL_OW 72
3395: ST_TO_ADDR
// until tmp ;
3396: LD_VAR 0 2
3400: IFFALSE 3364
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3402: LD_VAR 0 2
3406: PPUSH
3407: LD_INT 31
3409: PPUSH
3410: LD_INT 102
3412: PPUSH
3413: LD_INT 69
3415: PPUSH
3416: LD_INT 2
3418: PPUSH
3419: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3423: LD_INT 35
3425: PPUSH
3426: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3430: LD_EXP 35
3434: PPUSH
3435: LD_INT 3
3437: PUSH
3438: LD_INT 60
3440: PUSH
3441: EMPTY
3442: LIST
3443: PUSH
3444: EMPTY
3445: LIST
3446: LIST
3447: PUSH
3448: LD_INT 25
3450: PUSH
3451: LD_INT 2
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: PUSH
3458: EMPTY
3459: LIST
3460: LIST
3461: PPUSH
3462: CALL_OW 72
3466: IFFALSE 3423
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3468: LD_ADDR_VAR 0 2
3472: PUSH
3473: LD_EXP 35
3477: PPUSH
3478: LD_INT 25
3480: PUSH
3481: LD_INT 2
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PPUSH
3488: CALL_OW 72
3492: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3493: LD_VAR 0 2
3497: PPUSH
3498: LD_INT 4
3500: PPUSH
3501: LD_INT 116
3503: PPUSH
3504: LD_INT 70
3506: PPUSH
3507: LD_INT 5
3509: PPUSH
3510: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3514: LD_VAR 0 2
3518: PPUSH
3519: LD_INT 31
3521: PPUSH
3522: LD_INT 108
3524: PPUSH
3525: LD_INT 50
3527: PPUSH
3528: LD_INT 2
3530: PPUSH
3531: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3535: LD_INT 35
3537: PPUSH
3538: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3542: LD_INT 22
3544: PUSH
3545: LD_INT 5
3547: PUSH
3548: EMPTY
3549: LIST
3550: LIST
3551: PUSH
3552: LD_INT 30
3554: PUSH
3555: LD_INT 4
3557: PUSH
3558: EMPTY
3559: LIST
3560: LIST
3561: PUSH
3562: LD_INT 3
3564: PUSH
3565: LD_INT 57
3567: PUSH
3568: EMPTY
3569: LIST
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: LIST
3579: PPUSH
3580: CALL_OW 69
3584: IFFALSE 3535
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3586: LD_ADDR_VAR 0 3
3590: PUSH
3591: LD_INT 22
3593: PUSH
3594: LD_INT 5
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: PUSH
3601: LD_INT 30
3603: PUSH
3604: LD_INT 4
3606: PUSH
3607: EMPTY
3608: LIST
3609: LIST
3610: PUSH
3611: LD_INT 3
3613: PUSH
3614: LD_INT 57
3616: PUSH
3617: EMPTY
3618: LIST
3619: PUSH
3620: EMPTY
3621: LIST
3622: LIST
3623: PUSH
3624: EMPTY
3625: LIST
3626: LIST
3627: LIST
3628: PPUSH
3629: CALL_OW 69
3633: PUSH
3634: LD_INT 1
3636: ARRAY
3637: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3638: LD_ADDR_VAR 0 2
3642: PUSH
3643: LD_EXP 35
3647: PPUSH
3648: LD_INT 25
3650: PUSH
3651: LD_INT 1
3653: PUSH
3654: EMPTY
3655: LIST
3656: LIST
3657: PPUSH
3658: CALL_OW 72
3662: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3663: LD_VAR 0 2
3667: PPUSH
3668: LD_VAR 0 3
3672: PPUSH
3673: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3677: LD_INT 35
3679: PPUSH
3680: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3684: LD_INT 22
3686: PUSH
3687: LD_INT 5
3689: PUSH
3690: EMPTY
3691: LIST
3692: LIST
3693: PUSH
3694: LD_INT 30
3696: PUSH
3697: LD_INT 31
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: LD_INT 3
3706: PUSH
3707: LD_INT 57
3709: PUSH
3710: EMPTY
3711: LIST
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: LIST
3721: PPUSH
3722: CALL_OW 69
3726: PUSH
3727: LD_INT 2
3729: GREATEREQUAL
3730: IFFALSE 3677
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3732: LD_ADDR_VAR 0 2
3736: PUSH
3737: LD_EXP 35
3741: PPUSH
3742: LD_INT 25
3744: PUSH
3745: LD_INT 2
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 72
3756: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3757: LD_VAR 0 2
3761: PUSH
3762: LD_INT 1
3764: ARRAY
3765: PPUSH
3766: LD_INT 5
3768: PPUSH
3769: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3773: LD_VAR 0 2
3777: PUSH
3778: LD_INT 2
3780: ARRAY
3781: PUSH
3782: LD_VAR 0 2
3786: PUSH
3787: LD_INT 3
3789: ARRAY
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: PPUSH
3795: LD_VAR 0 3
3799: PPUSH
3800: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3804: LD_VAR 0 2
3808: PUSH
3809: LD_INT 2
3811: ARRAY
3812: PUSH
3813: LD_VAR 0 2
3817: PUSH
3818: LD_INT 3
3820: ARRAY
3821: PUSH
3822: EMPTY
3823: LIST
3824: LIST
3825: PPUSH
3826: LD_INT 1
3828: PPUSH
3829: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3833: LD_VAR 0 2
3837: PUSH
3838: LD_INT 2
3840: ARRAY
3841: PUSH
3842: LD_VAR 0 2
3846: PUSH
3847: LD_INT 3
3849: ARRAY
3850: PUSH
3851: EMPTY
3852: LIST
3853: LIST
3854: PPUSH
3855: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3859: LD_ADDR_VAR 0 4
3863: PUSH
3864: LD_INT 22
3866: PUSH
3867: LD_INT 5
3869: PUSH
3870: EMPTY
3871: LIST
3872: LIST
3873: PUSH
3874: LD_INT 30
3876: PUSH
3877: LD_INT 31
3879: PUSH
3880: EMPTY
3881: LIST
3882: LIST
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PPUSH
3888: CALL_OW 69
3892: ST_TO_ADDR
// for i := 1 to 2 do
3893: LD_ADDR_VAR 0 1
3897: PUSH
3898: DOUBLE
3899: LD_INT 1
3901: DEC
3902: ST_TO_ADDR
3903: LD_INT 2
3905: PUSH
3906: FOR_TO
3907: IFFALSE 3941
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3909: LD_VAR 0 2
3913: PUSH
3914: LD_VAR 0 1
3918: PUSH
3919: LD_INT 1
3921: PLUS
3922: ARRAY
3923: PPUSH
3924: LD_VAR 0 4
3928: PUSH
3929: LD_VAR 0 1
3933: ARRAY
3934: PPUSH
3935: CALL_OW 180
3939: GO 3906
3941: POP
3942: POP
// wait ( 1 1$00 ) ;
3943: LD_INT 2100
3945: PPUSH
3946: CALL_OW 67
// farmerBaseReady := true ;
3950: LD_ADDR_EXP 4
3954: PUSH
3955: LD_INT 1
3957: ST_TO_ADDR
// end ;
3958: PPOPN 4
3960: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
3961: LD_EXP 4
3965: PUSH
3966: LD_EXP 10
3970: NOT
3971: AND
3972: IFFALSE 4467
3974: GO 3976
3976: DISABLE
3977: LD_INT 0
3979: PPUSH
3980: PPUSH
3981: PPUSH
3982: PPUSH
3983: PPUSH
// begin enable ;
3984: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
3985: LD_ADDR_VAR 0 3
3989: PUSH
3990: LD_EXP 35
3994: PPUSH
3995: LD_INT 25
3997: PUSH
3998: LD_INT 1
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: PPUSH
4005: CALL_OW 72
4009: PUSH
4010: LD_EXP 32
4014: ADD
4015: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4016: LD_ADDR_VAR 0 2
4020: PUSH
4021: LD_EXP 35
4025: PPUSH
4026: LD_INT 25
4028: PUSH
4029: LD_INT 2
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: PPUSH
4036: CALL_OW 72
4040: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4041: LD_ADDR_VAR 0 5
4045: PUSH
4046: LD_INT 22
4048: PUSH
4049: LD_INT 5
4051: PUSH
4052: EMPTY
4053: LIST
4054: LIST
4055: PUSH
4056: LD_INT 21
4058: PUSH
4059: LD_INT 3
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: PUSH
4066: LD_INT 3
4068: PUSH
4069: LD_INT 24
4071: PUSH
4072: LD_INT 1000
4074: PUSH
4075: EMPTY
4076: LIST
4077: LIST
4078: PUSH
4079: EMPTY
4080: LIST
4081: LIST
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: LIST
4087: PPUSH
4088: CALL_OW 69
4092: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4093: LD_ADDR_VAR 0 4
4097: PUSH
4098: LD_INT 22
4100: PUSH
4101: LD_INT 5
4103: PUSH
4104: EMPTY
4105: LIST
4106: LIST
4107: PUSH
4108: LD_INT 30
4110: PUSH
4111: LD_INT 4
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: PUSH
4118: EMPTY
4119: LIST
4120: LIST
4121: PPUSH
4122: CALL_OW 69
4126: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4127: LD_VAR 0 4
4131: PUSH
4132: LD_INT 1
4134: ARRAY
4135: PPUSH
4136: CALL_OW 302
4140: IFFALSE 4204
// for i in sol do
4142: LD_ADDR_VAR 0 1
4146: PUSH
4147: LD_VAR 0 3
4151: PUSH
4152: FOR_IN
4153: IFFALSE 4202
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4155: LD_VAR 0 1
4159: PPUSH
4160: CALL_OW 256
4164: PUSH
4165: LD_INT 999
4167: LESS
4168: PUSH
4169: LD_VAR 0 1
4173: PPUSH
4174: CALL_OW 310
4178: NOT
4179: AND
4180: IFFALSE 4200
// ComEnterUnit ( i , arm [ 1 ] ) ;
4182: LD_VAR 0 1
4186: PPUSH
4187: LD_VAR 0 4
4191: PUSH
4192: LD_INT 1
4194: ARRAY
4195: PPUSH
4196: CALL_OW 120
4200: GO 4152
4202: POP
4203: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4204: LD_VAR 0 2
4208: NOT
4209: PUSH
4210: LD_INT 22
4212: PUSH
4213: LD_INT 1
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: PUSH
4220: LD_INT 21
4222: PUSH
4223: LD_INT 1
4225: PUSH
4226: EMPTY
4227: LIST
4228: LIST
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PPUSH
4234: CALL_OW 69
4238: NOT
4239: AND
4240: IFFALSE 4332
// begin uc_side := 5 ;
4242: LD_ADDR_OWVAR 20
4246: PUSH
4247: LD_INT 5
4249: ST_TO_ADDR
// uc_nation := 2 ;
4250: LD_ADDR_OWVAR 21
4254: PUSH
4255: LD_INT 2
4257: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4258: LD_INT 0
4260: PPUSH
4261: LD_INT 2
4263: PPUSH
4264: LD_INT 2
4266: PPUSH
4267: CALL_OW 380
// eng := CreateHuman ;
4271: LD_ADDR_VAR 0 2
4275: PUSH
4276: CALL_OW 44
4280: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4281: LD_VAR 0 2
4285: PPUSH
4286: LD_INT 102
4288: PPUSH
4289: LD_INT 8
4291: PPUSH
4292: LD_INT 0
4294: PPUSH
4295: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4299: LD_VAR 0 2
4303: PPUSH
4304: LD_INT 110
4306: PPUSH
4307: LD_INT 60
4309: PPUSH
4310: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4314: LD_ADDR_EXP 35
4318: PUSH
4319: LD_EXP 35
4323: PUSH
4324: LD_VAR 0 2
4328: UNION
4329: ST_TO_ADDR
// end else
4330: GO 4467
// begin for i in eng do
4332: LD_ADDR_VAR 0 1
4336: PUSH
4337: LD_VAR 0 2
4341: PUSH
4342: FOR_IN
4343: IFFALSE 4465
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4345: LD_INT 10
4347: PPUSH
4348: LD_INT 1
4350: PPUSH
4351: CALL_OW 287
4355: IFFALSE 4379
// begin if IsInUnit ( i ) then
4357: LD_VAR 0 1
4361: PPUSH
4362: CALL_OW 310
4366: IFFALSE 4377
// ComExitBuilding ( i ) ;
4368: LD_VAR 0 1
4372: PPUSH
4373: CALL_OW 122
// end else
4377: GO 4463
// begin if damagedBuilding then
4379: LD_VAR 0 5
4383: IFFALSE 4427
// begin if IsInUnit ( i ) then
4385: LD_VAR 0 1
4389: PPUSH
4390: CALL_OW 310
4394: IFFALSE 4407
// ComExitBuilding ( i ) else
4396: LD_VAR 0 1
4400: PPUSH
4401: CALL_OW 122
4405: GO 4425
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4407: LD_VAR 0 1
4411: PPUSH
4412: LD_VAR 0 5
4416: PUSH
4417: LD_INT 1
4419: ARRAY
4420: PPUSH
4421: CALL_OW 130
// end else
4425: GO 4463
// if not IsInUnit ( i ) and not HasTask ( i ) then
4427: LD_VAR 0 1
4431: PPUSH
4432: CALL_OW 310
4436: NOT
4437: PUSH
4438: LD_VAR 0 1
4442: PPUSH
4443: CALL_OW 314
4447: NOT
4448: AND
4449: IFFALSE 4463
// ComEnterUnit ( i , arDepot ) ;
4451: LD_VAR 0 1
4455: PPUSH
4456: LD_INT 5
4458: PPUSH
4459: CALL_OW 120
// end ; end ;
4463: GO 4342
4465: POP
4466: POP
// end ; end ;
4467: PPOPN 5
4469: END
// export function StartCargoEvacuation ; begin
4470: LD_INT 0
4472: PPUSH
// while omarCargoCounter > 0 do
4473: LD_EXP 17
4477: PUSH
4478: LD_INT 0
4480: GREATER
4481: IFFALSE 4798
// begin wait ( 0 0$40 ) ;
4483: LD_INT 1400
4485: PPUSH
4486: CALL_OW 67
// omarCargo := PrepareCargo ;
4490: LD_ADDR_EXP 39
4494: PUSH
4495: CALL 4803 0 0
4499: ST_TO_ADDR
// SetTag ( omarCargo , 0 ) ;
4500: LD_EXP 39
4504: PPUSH
4505: LD_INT 0
4507: PPUSH
4508: CALL_OW 109
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4512: LD_EXP 39
4516: PPUSH
4517: LD_INT 107
4519: PPUSH
4520: LD_INT 59
4522: PPUSH
4523: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4527: LD_INT 35
4529: PPUSH
4530: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4534: LD_EXP 39
4538: PPUSH
4539: LD_INT 107
4541: PPUSH
4542: LD_INT 59
4544: PPUSH
4545: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4549: LD_EXP 39
4553: PPUSH
4554: CALL_OW 302
4558: NOT
4559: PUSH
4560: LD_EXP 39
4564: PPUSH
4565: CALL_OW 301
4569: OR
4570: IFFALSE 4574
// continue ;
4572: GO 4527
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4574: LD_EXP 39
4578: PPUSH
4579: LD_INT 107
4581: PPUSH
4582: LD_INT 59
4584: PPUSH
4585: CALL_OW 307
4589: PUSH
4590: LD_EXP 39
4594: PPUSH
4595: LD_INT 5
4597: PPUSH
4598: CALL_OW 296
4602: PUSH
4603: LD_INT 6
4605: LESS
4606: OR
4607: IFFALSE 4527
// SetTag ( omarCargo , 1 ) ;
4609: LD_EXP 39
4613: PPUSH
4614: LD_INT 1
4616: PPUSH
4617: CALL_OW 109
// wait ( 0 0$05 ) ;
4621: LD_INT 175
4623: PPUSH
4624: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4628: LD_EXP 39
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_INT 1
4638: PPUSH
4639: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4643: LD_EXP 39
4647: PPUSH
4648: LD_INT 103
4650: PPUSH
4651: LD_INT 9
4653: PPUSH
4654: CALL_OW 171
// wait ( 0 0$1 ) ;
4658: LD_INT 35
4660: PPUSH
4661: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
4665: LD_EXP 39
4669: PPUSH
4670: LD_INT 1
4672: PPUSH
4673: LD_INT 100
4675: PPUSH
4676: CALL_OW 290
// repeat wait ( 0 0$1 ) ;
4680: LD_INT 35
4682: PPUSH
4683: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4687: LD_EXP 39
4691: PPUSH
4692: LD_INT 103
4694: PPUSH
4695: LD_INT 9
4697: PPUSH
4698: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4702: LD_EXP 39
4706: PPUSH
4707: CALL_OW 302
4711: NOT
4712: PUSH
4713: LD_EXP 39
4717: PPUSH
4718: CALL_OW 301
4722: OR
4723: IFFALSE 4727
// continue ;
4725: GO 4680
// until ( IsAt ( omarCargo , 103 , 9 ) or IsInArea ( omarCargo , northRoad ) ) and GetTag ( omarCargo ) > 0 ;
4727: LD_EXP 39
4731: PPUSH
4732: LD_INT 103
4734: PPUSH
4735: LD_INT 9
4737: PPUSH
4738: CALL_OW 307
4742: PUSH
4743: LD_EXP 39
4747: PPUSH
4748: LD_INT 3
4750: PPUSH
4751: CALL_OW 308
4755: OR
4756: PUSH
4757: LD_EXP 39
4761: PPUSH
4762: CALL_OW 110
4766: PUSH
4767: LD_INT 0
4769: GREATER
4770: AND
4771: IFFALSE 4680
// RemoveUnit ( omarCargo ) ;
4773: LD_EXP 39
4777: PPUSH
4778: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4782: LD_ADDR_EXP 17
4786: PUSH
4787: LD_EXP 17
4791: PUSH
4792: LD_INT 1
4794: MINUS
4795: ST_TO_ADDR
// end ;
4796: GO 4473
// end ;
4798: LD_VAR 0 1
4802: RET
// export function PrepareCargo ; var un , veh ; begin
4803: LD_INT 0
4805: PPUSH
4806: PPUSH
4807: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4808: LD_ADDR_VAR 0 3
4812: PUSH
4813: LD_INT 5
4815: PPUSH
4816: LD_INT 2
4818: PPUSH
4819: LD_INT 13
4821: PPUSH
4822: LD_INT 1
4824: PPUSH
4825: LD_INT 1
4827: PPUSH
4828: LD_INT 32
4830: PPUSH
4831: LD_INT 80
4833: PPUSH
4834: CALL 344 0 7
4838: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4839: LD_VAR 0 3
4843: PPUSH
4844: LD_INT 4
4846: PPUSH
4847: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4851: LD_VAR 0 3
4855: PPUSH
4856: LD_INT 101
4858: PPUSH
4859: LD_INT 8
4861: PPUSH
4862: LD_INT 0
4864: PPUSH
4865: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4869: LD_INT 0
4871: PPUSH
4872: LD_INT 3
4874: PPUSH
4875: LD_INT 2
4877: PPUSH
4878: CALL_OW 380
// un := CreateHuman ;
4882: LD_ADDR_VAR 0 2
4886: PUSH
4887: CALL_OW 44
4891: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4892: LD_VAR 0 2
4896: PPUSH
4897: LD_VAR 0 3
4901: PPUSH
4902: CALL_OW 52
// result := veh ;
4906: LD_ADDR_VAR 0 1
4910: PUSH
4911: LD_VAR 0 3
4915: ST_TO_ADDR
// end ; end_of_file
4916: LD_VAR 0 1
4920: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
4921: LD_INT 0
4923: PPUSH
4924: PPUSH
4925: PPUSH
// usForces := [ ] ;
4926: LD_ADDR_EXP 40
4930: PUSH
4931: EMPTY
4932: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
4933: LD_ADDR_EXP 42
4937: PUSH
4938: LD_INT 6
4940: PUSH
4941: LD_INT 32
4943: PUSH
4944: LD_INT 27
4946: PUSH
4947: LD_INT 1
4949: PUSH
4950: EMPTY
4951: LIST
4952: LIST
4953: LIST
4954: LIST
4955: PUSH
4956: LD_INT 4
4958: PUSH
4959: LD_INT 43
4961: PUSH
4962: LD_INT 24
4964: PUSH
4965: LD_INT 5
4967: PUSH
4968: EMPTY
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: PUSH
4974: LD_INT 27
4976: PUSH
4977: LD_INT 29
4979: PUSH
4980: LD_INT 21
4982: PUSH
4983: LD_INT 0
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: LIST
4990: LIST
4991: PUSH
4992: EMPTY
4993: LIST
4994: LIST
4995: LIST
4996: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
4997: LD_INT 11
4999: PPUSH
5000: CALL_OW 274
5004: PPUSH
5005: LD_INT 1
5007: PPUSH
5008: LD_INT 150
5010: PUSH
5011: LD_INT 120
5013: PUSH
5014: LD_INT 100
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: LIST
5021: PUSH
5022: LD_OWVAR 67
5026: ARRAY
5027: PPUSH
5028: CALL_OW 277
// if Difficulty = 1 then
5032: LD_OWVAR 67
5036: PUSH
5037: LD_INT 1
5039: EQUAL
5040: IFFALSE 5049
// RemoveUnit ( hillBun ) ;
5042: LD_INT 14
5044: PPUSH
5045: CALL_OW 64
// uc_side := 1 ;
5049: LD_ADDR_OWVAR 20
5053: PUSH
5054: LD_INT 1
5056: ST_TO_ADDR
// uc_nation := 1 ;
5057: LD_ADDR_OWVAR 21
5061: PUSH
5062: LD_INT 1
5064: ST_TO_ADDR
// hc_gallery :=  ;
5065: LD_ADDR_OWVAR 33
5069: PUSH
5070: LD_STRING 
5072: ST_TO_ADDR
// hc_name :=  ;
5073: LD_ADDR_OWVAR 26
5077: PUSH
5078: LD_STRING 
5080: ST_TO_ADDR
// hc_importance := 0 ;
5081: LD_ADDR_OWVAR 32
5085: PUSH
5086: LD_INT 0
5088: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5089: LD_INT 1
5091: PPUSH
5092: LD_INT 1
5094: PPUSH
5095: LD_INT 3
5097: PPUSH
5098: CALL_OW 380
// usCommander := CreateHuman ;
5102: LD_ADDR_EXP 41
5106: PUSH
5107: CALL_OW 44
5111: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5112: LD_EXP 41
5116: PPUSH
5117: LD_INT 11
5119: PPUSH
5120: CALL_OW 52
// if hillBun then
5124: LD_INT 14
5126: IFFALSE 5208
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5128: LD_INT 0
5130: PPUSH
5131: LD_INT 1
5133: PPUSH
5134: LD_INT 1
5136: PUSH
5137: LD_INT 2
5139: PUSH
5140: LD_INT 3
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: LIST
5147: PUSH
5148: LD_OWVAR 67
5152: ARRAY
5153: PPUSH
5154: CALL_OW 380
// un := CreateHuman ;
5158: LD_ADDR_VAR 0 3
5162: PUSH
5163: CALL_OW 44
5167: ST_TO_ADDR
// usForces := usForces union un ;
5168: LD_ADDR_EXP 40
5172: PUSH
5173: LD_EXP 40
5177: PUSH
5178: LD_VAR 0 3
5182: UNION
5183: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5184: LD_VAR 0 3
5188: PPUSH
5189: LD_INT 1
5191: PPUSH
5192: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5196: LD_VAR 0 3
5200: PPUSH
5201: LD_INT 14
5203: PPUSH
5204: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5208: LD_ADDR_VAR 0 2
5212: PUSH
5213: DOUBLE
5214: LD_INT 1
5216: DEC
5217: ST_TO_ADDR
5218: LD_INT 2
5220: PUSH
5221: LD_INT 3
5223: PUSH
5224: LD_INT 4
5226: PUSH
5227: EMPTY
5228: LIST
5229: LIST
5230: LIST
5231: PUSH
5232: LD_OWVAR 67
5236: ARRAY
5237: PUSH
5238: FOR_TO
5239: IFFALSE 5381
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5241: LD_INT 0
5243: PPUSH
5244: LD_INT 1
5246: PPUSH
5247: LD_INT 1
5249: PUSH
5250: LD_INT 2
5252: PUSH
5253: LD_INT 3
5255: PUSH
5256: EMPTY
5257: LIST
5258: LIST
5259: LIST
5260: PUSH
5261: LD_OWVAR 67
5265: ARRAY
5266: PPUSH
5267: CALL_OW 380
// un := CreateHuman ;
5271: LD_ADDR_VAR 0 3
5275: PUSH
5276: CALL_OW 44
5280: ST_TO_ADDR
// usForces := usForces union un ;
5281: LD_ADDR_EXP 40
5285: PUSH
5286: LD_EXP 40
5290: PUSH
5291: LD_VAR 0 3
5295: UNION
5296: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5297: LD_VAR 0 3
5301: PPUSH
5302: LD_INT 39
5304: PPUSH
5305: LD_INT 24
5307: PPUSH
5308: LD_INT 4
5310: PPUSH
5311: LD_INT 0
5313: PPUSH
5314: CALL_OW 50
// if i < 3 then
5318: LD_VAR 0 2
5322: PUSH
5323: LD_INT 3
5325: LESS
5326: IFFALSE 5379
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5328: LD_VAR 0 3
5332: PPUSH
5333: LD_INT 22
5335: PUSH
5336: LD_INT 1
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PUSH
5343: LD_INT 58
5345: PUSH
5346: EMPTY
5347: LIST
5348: PUSH
5349: LD_INT 30
5351: PUSH
5352: LD_INT 31
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL_OW 69
5368: PUSH
5369: LD_VAR 0 2
5373: ARRAY
5374: PPUSH
5375: CALL_OW 120
// end ;
5379: GO 5238
5381: POP
5382: POP
// for i := 1 to 2 do
5383: LD_ADDR_VAR 0 2
5387: PUSH
5388: DOUBLE
5389: LD_INT 1
5391: DEC
5392: ST_TO_ADDR
5393: LD_INT 2
5395: PUSH
5396: FOR_TO
5397: IFFALSE 5461
// begin PrepareHuman ( false , 2 , 2 ) ;
5399: LD_INT 0
5401: PPUSH
5402: LD_INT 2
5404: PPUSH
5405: LD_INT 2
5407: PPUSH
5408: CALL_OW 380
// un := CreateHuman ;
5412: LD_ADDR_VAR 0 3
5416: PUSH
5417: CALL_OW 44
5421: ST_TO_ADDR
// usForces := usForces union un ;
5422: LD_ADDR_EXP 40
5426: PUSH
5427: LD_EXP 40
5431: PUSH
5432: LD_VAR 0 3
5436: UNION
5437: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5438: LD_VAR 0 3
5442: PPUSH
5443: LD_INT 39
5445: PPUSH
5446: LD_INT 24
5448: PPUSH
5449: LD_INT 4
5451: PPUSH
5452: LD_INT 0
5454: PPUSH
5455: CALL_OW 50
// end ;
5459: GO 5396
5461: POP
5462: POP
// PrepareHuman ( false , 4 , 1 ) ;
5463: LD_INT 0
5465: PPUSH
5466: LD_INT 4
5468: PPUSH
5469: LD_INT 1
5471: PPUSH
5472: CALL_OW 380
// un := CreateHuman ;
5476: LD_ADDR_VAR 0 3
5480: PUSH
5481: CALL_OW 44
5485: ST_TO_ADDR
// usForces := usForces union un ;
5486: LD_ADDR_EXP 40
5490: PUSH
5491: LD_EXP 40
5495: PUSH
5496: LD_VAR 0 3
5500: UNION
5501: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5502: LD_VAR 0 3
5506: PPUSH
5507: LD_INT 39
5509: PPUSH
5510: LD_INT 24
5512: PPUSH
5513: LD_INT 4
5515: PPUSH
5516: LD_INT 0
5518: PPUSH
5519: CALL_OW 50
// end ;
5523: LD_VAR 0 1
5527: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
5528: LD_EXP 40
5532: PUSH
5533: LD_EXP 6
5537: NOT
5538: AND
5539: IFFALSE 5970
5541: GO 5543
5543: DISABLE
5544: LD_INT 0
5546: PPUSH
5547: PPUSH
5548: PPUSH
5549: PPUSH
5550: PPUSH
// begin enable ;
5551: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5552: LD_ADDR_VAR 0 3
5556: PUSH
5557: LD_EXP 40
5561: PPUSH
5562: LD_INT 25
5564: PUSH
5565: LD_INT 2
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL_OW 72
5576: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5577: LD_ADDR_VAR 0 4
5581: PUSH
5582: LD_EXP 40
5586: PPUSH
5587: LD_INT 25
5589: PUSH
5590: LD_INT 1
5592: PUSH
5593: EMPTY
5594: LIST
5595: LIST
5596: PPUSH
5597: CALL_OW 72
5601: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5602: LD_ADDR_VAR 0 5
5606: PUSH
5607: LD_EXP 40
5611: PPUSH
5612: LD_INT 25
5614: PUSH
5615: LD_INT 4
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: PPUSH
5622: CALL_OW 72
5626: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5627: LD_INT 7
5629: PPUSH
5630: LD_INT 22
5632: PUSH
5633: LD_INT 2
5635: PUSH
5636: EMPTY
5637: LIST
5638: LIST
5639: PPUSH
5640: CALL_OW 70
5644: PUSH
5645: LD_INT 1
5647: EQUAL
5648: IFFALSE 5724
// for i in sol do
5650: LD_ADDR_VAR 0 1
5654: PUSH
5655: LD_VAR 0 4
5659: PUSH
5660: FOR_IN
5661: IFFALSE 5722
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5663: LD_VAR 0 1
5667: PPUSH
5668: CALL_OW 310
5672: NOT
5673: PUSH
5674: LD_VAR 0 1
5678: PPUSH
5679: CALL_OW 310
5683: PPUSH
5684: CALL_OW 266
5688: PUSH
5689: LD_INT 4
5691: EQUAL
5692: NOT
5693: OR
5694: IFFALSE 5720
// begin ComExitBuilding ( i ) ;
5696: LD_VAR 0 1
5700: PPUSH
5701: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5705: LD_VAR 0 1
5709: PPUSH
5710: LD_INT 37
5712: PPUSH
5713: LD_INT 23
5715: PPUSH
5716: CALL_OW 174
// end ;
5720: GO 5660
5722: POP
5723: POP
// if eng then
5724: LD_VAR 0 3
5728: IFFALSE 5970
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5730: LD_ADDR_VAR 0 2
5734: PUSH
5735: LD_INT 22
5737: PUSH
5738: LD_INT 1
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: PUSH
5745: LD_INT 95
5747: PUSH
5748: LD_INT 7
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 21
5757: PUSH
5758: LD_INT 3
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 3
5767: PUSH
5768: LD_INT 24
5770: PUSH
5771: LD_INT 1000
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: PPUSH
5788: CALL_OW 69
5792: ST_TO_ADDR
// if b then
5793: LD_VAR 0 2
5797: IFFALSE 5828
// begin ComExitBuilding ( eng ) ;
5799: LD_VAR 0 3
5803: PPUSH
5804: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5808: LD_VAR 0 3
5812: PPUSH
5813: LD_VAR 0 2
5817: PUSH
5818: LD_INT 1
5820: ARRAY
5821: PPUSH
5822: CALL_OW 190
// end else
5826: GO 5970
// begin for i in eng do
5828: LD_ADDR_VAR 0 1
5832: PUSH
5833: LD_VAR 0 3
5837: PUSH
5838: FOR_IN
5839: IFFALSE 5968
// if not HasTask ( i ) then
5841: LD_VAR 0 1
5845: PPUSH
5846: CALL_OW 314
5850: NOT
5851: IFFALSE 5966
// begin if americanBuildList then
5853: LD_EXP 42
5857: IFFALSE 5942
// begin if IsInUnit ( i ) then
5859: LD_VAR 0 1
5863: PPUSH
5864: CALL_OW 310
5868: IFFALSE 5879
// ComExitBuilding ( i ) ;
5870: LD_VAR 0 1
5874: PPUSH
5875: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5879: LD_VAR 0 1
5883: PPUSH
5884: LD_EXP 42
5888: PUSH
5889: LD_INT 1
5891: ARRAY
5892: PUSH
5893: LD_INT 1
5895: ARRAY
5896: PPUSH
5897: LD_EXP 42
5901: PUSH
5902: LD_INT 1
5904: ARRAY
5905: PUSH
5906: LD_INT 2
5908: ARRAY
5909: PPUSH
5910: LD_EXP 42
5914: PUSH
5915: LD_INT 1
5917: ARRAY
5918: PUSH
5919: LD_INT 3
5921: ARRAY
5922: PPUSH
5923: LD_EXP 42
5927: PUSH
5928: LD_INT 1
5930: ARRAY
5931: PUSH
5932: LD_INT 4
5934: ARRAY
5935: PPUSH
5936: CALL_OW 205
// end else
5940: GO 5966
// if not IsInUnit ( i ) then
5942: LD_VAR 0 1
5946: PPUSH
5947: CALL_OW 310
5951: NOT
5952: IFFALSE 5966
// ComEnterUnit ( i , usDepot ) ;
5954: LD_VAR 0 1
5958: PPUSH
5959: LD_INT 11
5961: PPUSH
5962: CALL_OW 120
// end ;
5966: GO 5838
5968: POP
5969: POP
// end ; end ; end ;
5970: PPOPN 5
5972: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
5973: LD_INT 0
5975: PPUSH
5976: PPUSH
5977: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
5978: LD_ADDR_VAR 0 3
5982: PUSH
5983: LD_INT 35
5985: PUSH
5986: LD_INT 45
5988: PUSH
5989: LD_INT 48
5991: PUSH
5992: LD_EXP 51
5996: PUSH
5997: EMPTY
5998: LIST
5999: LIST
6000: LIST
6001: LIST
6002: ST_TO_ADDR
// for i in tech do
6003: LD_ADDR_VAR 0 4
6007: PUSH
6008: LD_VAR 0 3
6012: PUSH
6013: FOR_IN
6014: IFFALSE 6032
// AddComResearch ( lab , i ) ;
6016: LD_VAR 0 1
6020: PPUSH
6021: LD_VAR 0 4
6025: PPUSH
6026: CALL_OW 184
6030: GO 6013
6032: POP
6033: POP
// end ;
6034: LD_VAR 0 2
6038: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
6039: LD_EXP 11
6043: PUSH
6044: LD_EXP 19
6048: PUSH
6049: LD_EXP 23
6053: LESSEQUAL
6054: AND
6055: IFFALSE 6080
6057: GO 6059
6059: DISABLE
// begin enable ;
6060: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6061: LD_INT 35
6063: PPUSH
6064: LD_INT 2065
6066: PPUSH
6067: CALL_OW 12
6071: PPUSH
6072: CALL_OW 67
// SendConvoy ;
6076: CALL 6178 0 0
// end ;
6080: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6081: LD_EXP 6
6085: PUSH
6086: LD_EXP 15
6090: AND
6091: IFFALSE 6177
6093: GO 6095
6095: DISABLE
// begin if americanHasEscaped then
6096: LD_EXP 7
6100: IFFALSE 6111
// wait ( 3 3$20 ) else
6102: LD_INT 7000
6104: PPUSH
6105: CALL_OW 67
6109: GO 6118
// wait ( 6 6$40 ) ;
6111: LD_INT 14000
6113: PPUSH
6114: CALL_OW 67
// SendAttack ;
6118: CALL 6893 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6122: LD_INT 14000
6124: PUSH
6125: LD_INT 11900
6127: PUSH
6128: LD_INT 9800
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: PUSH
6136: LD_OWVAR 67
6140: ARRAY
6141: PPUSH
6142: CALL_OW 67
// SendAttack ;
6146: CALL 6893 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6150: LD_EXP 16
6154: PUSH
6155: LD_INT 6
6157: PUSH
6158: LD_INT 7
6160: PUSH
6161: LD_INT 8
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: PUSH
6169: LD_OWVAR 67
6173: ARRAY
6174: LESS
6175: IFFALSE 6122
// end ;
6177: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6178: LD_INT 0
6180: PPUSH
6181: PPUSH
6182: PPUSH
6183: PPUSH
6184: PPUSH
6185: PPUSH
6186: PPUSH
6187: PPUSH
// road := rand ( 1 , 2 ) ;
6188: LD_ADDR_VAR 0 4
6192: PUSH
6193: LD_INT 1
6195: PPUSH
6196: LD_INT 2
6198: PPUSH
6199: CALL_OW 12
6203: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6204: LD_ADDR_VAR 0 8
6208: PUSH
6209: LD_INT 3
6211: PUSH
6212: LD_INT 8
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: PUSH
6219: LD_VAR 0 4
6223: ARRAY
6224: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6225: LD_ADDR_VAR 0 5
6229: PUSH
6230: LD_INT 35
6232: PUSH
6233: LD_INT 66
6235: PUSH
6236: LD_INT 1
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: PUSH
6244: LD_INT 101
6246: PUSH
6247: LD_INT 8
6249: PUSH
6250: LD_INT 4
6252: PUSH
6253: EMPTY
6254: LIST
6255: LIST
6256: LIST
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6262: LD_ADDR_VAR 0 6
6266: PUSH
6267: LD_INT 34
6269: PUSH
6270: LD_INT 67
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: PUSH
6277: LD_INT 38
6279: PUSH
6280: LD_INT 62
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: PUSH
6287: LD_INT 43
6289: PUSH
6290: LD_INT 54
6292: PUSH
6293: EMPTY
6294: LIST
6295: LIST
6296: PUSH
6297: LD_INT 57
6299: PUSH
6300: LD_INT 57
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: PUSH
6307: LD_INT 77
6309: PUSH
6310: LD_INT 71
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: PUSH
6317: LD_INT 86
6319: PUSH
6320: LD_INT 60
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: PUSH
6327: LD_INT 89
6329: PUSH
6330: LD_INT 35
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: PUSH
6337: LD_INT 93
6339: PUSH
6340: LD_INT 17
6342: PUSH
6343: EMPTY
6344: LIST
6345: LIST
6346: PUSH
6347: LD_INT 97
6349: PUSH
6350: LD_INT 10
6352: PUSH
6353: EMPTY
6354: LIST
6355: LIST
6356: PUSH
6357: LD_INT 103
6359: PUSH
6360: LD_INT 9
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: PUSH
6367: EMPTY
6368: LIST
6369: LIST
6370: LIST
6371: LIST
6372: LIST
6373: LIST
6374: LIST
6375: LIST
6376: LIST
6377: LIST
6378: ST_TO_ADDR
// if road = 2 then
6379: LD_VAR 0 4
6383: PUSH
6384: LD_INT 2
6386: EQUAL
6387: IFFALSE 6404
// points := ReverseArray ( points ) ;
6389: LD_ADDR_VAR 0 6
6393: PUSH
6394: LD_VAR 0 6
6398: PPUSH
6399: CALL 1032 0 1
6403: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6404: LD_INT 4
6406: PPUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: LD_INT 1
6415: PPUSH
6416: LD_INT 1
6418: PPUSH
6419: LD_INT 12
6421: PPUSH
6422: LD_INT 80
6424: PPUSH
6425: CALL 344 0 7
// veh := CreateVehicle ;
6429: LD_ADDR_VAR 0 3
6433: PUSH
6434: CALL_OW 45
6438: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6439: LD_VAR 0 3
6443: PPUSH
6444: LD_VAR 0 5
6448: PUSH
6449: LD_VAR 0 4
6453: ARRAY
6454: PUSH
6455: LD_INT 3
6457: ARRAY
6458: PPUSH
6459: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6463: LD_VAR 0 3
6467: PPUSH
6468: LD_VAR 0 5
6472: PUSH
6473: LD_VAR 0 4
6477: ARRAY
6478: PUSH
6479: LD_INT 1
6481: ARRAY
6482: PPUSH
6483: LD_VAR 0 5
6487: PUSH
6488: LD_VAR 0 4
6492: ARRAY
6493: PUSH
6494: LD_INT 2
6496: ARRAY
6497: PPUSH
6498: LD_INT 0
6500: PPUSH
6501: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6505: LD_INT 0
6507: PPUSH
6508: LD_INT 1
6510: PPUSH
6511: LD_OWVAR 67
6515: PPUSH
6516: CALL_OW 380
// un := CreateHuman ;
6520: LD_ADDR_VAR 0 2
6524: PUSH
6525: CALL_OW 44
6529: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6530: LD_VAR 0 2
6534: PPUSH
6535: LD_VAR 0 3
6539: PPUSH
6540: CALL_OW 52
// if Prob ( 50 + tick mod 30 ) or convoyCounter < 3 then
6544: LD_INT 50
6546: PUSH
6547: LD_OWVAR 1
6551: PUSH
6552: LD_INT 30
6554: MOD
6555: PLUS
6556: PPUSH
6557: CALL_OW 13
6561: PUSH
6562: LD_EXP 19
6566: PUSH
6567: LD_INT 3
6569: LESS
6570: OR
6571: IFFALSE 6588
// SetCargo ( veh , mat_cans , 100 ) ;
6573: LD_VAR 0 3
6577: PPUSH
6578: LD_INT 1
6580: PPUSH
6581: LD_INT 100
6583: PPUSH
6584: CALL_OW 290
// for i := 2 to points do
6588: LD_ADDR_VAR 0 7
6592: PUSH
6593: DOUBLE
6594: LD_INT 2
6596: DEC
6597: ST_TO_ADDR
6598: LD_VAR 0 6
6602: PUSH
6603: FOR_TO
6604: IFFALSE 6647
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6606: LD_VAR 0 3
6610: PPUSH
6611: LD_VAR 0 6
6615: PUSH
6616: LD_VAR 0 7
6620: ARRAY
6621: PUSH
6622: LD_INT 1
6624: ARRAY
6625: PPUSH
6626: LD_VAR 0 6
6630: PUSH
6631: LD_VAR 0 7
6635: ARRAY
6636: PUSH
6637: LD_INT 2
6639: ARRAY
6640: PPUSH
6641: CALL_OW 171
6645: GO 6603
6647: POP
6648: POP
// convoyCounter := convoyCounter + 1 ;
6649: LD_ADDR_EXP 19
6653: PUSH
6654: LD_EXP 19
6658: PUSH
6659: LD_INT 1
6661: PLUS
6662: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6663: LD_INT 35
6665: PPUSH
6666: CALL_OW 67
// if not HasTask ( veh ) then
6670: LD_VAR 0 3
6674: PPUSH
6675: CALL_OW 314
6679: NOT
6680: IFFALSE 6721
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6682: LD_VAR 0 3
6686: PPUSH
6687: LD_VAR 0 6
6691: PUSH
6692: LD_VAR 0 6
6696: ARRAY
6697: PUSH
6698: LD_INT 1
6700: ARRAY
6701: PPUSH
6702: LD_VAR 0 6
6706: PUSH
6707: LD_VAR 0 6
6711: ARRAY
6712: PUSH
6713: LD_INT 2
6715: ARRAY
6716: PPUSH
6717: CALL_OW 111
// if not IsOk ( veh ) then
6721: LD_VAR 0 3
6725: PPUSH
6726: CALL_OW 302
6730: NOT
6731: IFFALSE 6772
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6733: LD_VAR 0 2
6737: PPUSH
6738: LD_VAR 0 6
6742: PUSH
6743: LD_VAR 0 6
6747: ARRAY
6748: PUSH
6749: LD_INT 1
6751: ARRAY
6752: PPUSH
6753: LD_VAR 0 6
6757: PUSH
6758: LD_VAR 0 6
6762: ARRAY
6763: PUSH
6764: LD_INT 2
6766: ARRAY
6767: PPUSH
6768: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6772: LD_VAR 0 3
6776: PPUSH
6777: LD_VAR 0 8
6781: PPUSH
6782: CALL_OW 308
6786: PUSH
6787: LD_VAR 0 2
6791: PPUSH
6792: LD_VAR 0 8
6796: PPUSH
6797: CALL_OW 308
6801: OR
6802: IFFALSE 6663
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6804: LD_VAR 0 2
6808: PPUSH
6809: CALL_OW 302
6813: PUSH
6814: LD_VAR 0 3
6818: PPUSH
6819: CALL_OW 302
6823: NOT
6824: AND
6825: PUSH
6826: LD_VAR 0 2
6830: PPUSH
6831: LD_VAR 0 8
6835: PPUSH
6836: CALL_OW 308
6840: AND
6841: IFFALSE 6852
// RemoveUnit ( un ) ;
6843: LD_VAR 0 2
6847: PPUSH
6848: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6852: LD_VAR 0 3
6856: PPUSH
6857: LD_VAR 0 8
6861: PPUSH
6862: CALL_OW 308
6866: PUSH
6867: LD_VAR 0 3
6871: PPUSH
6872: CALL_OW 302
6876: AND
6877: IFFALSE 6888
// RemoveUnit ( veh ) ;
6879: LD_VAR 0 3
6883: PPUSH
6884: CALL_OW 64
// end ;
6888: LD_VAR 0 1
6892: RET
// export function SendAttack ; var un , veh , i ; begin
6893: LD_INT 0
6895: PPUSH
6896: PPUSH
6897: PPUSH
6898: PPUSH
// IncomingAttack ;
6899: CALL 15288 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
6903: LD_INT 2100
6905: PPUSH
6906: LD_INT 3500
6908: PPUSH
6909: CALL_OW 12
6913: PPUSH
6914: CALL_OW 67
// for i := 1 to [ 3 , 3 , 4 ] [ Difficulty ] + attackWave div 3 do
6918: LD_ADDR_VAR 0 4
6922: PUSH
6923: DOUBLE
6924: LD_INT 1
6926: DEC
6927: ST_TO_ADDR
6928: LD_INT 3
6930: PUSH
6931: LD_INT 3
6933: PUSH
6934: LD_INT 4
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: LIST
6941: PUSH
6942: LD_OWVAR 67
6946: ARRAY
6947: PUSH
6948: LD_EXP 16
6952: PUSH
6953: LD_INT 3
6955: DIV
6956: PLUS
6957: PUSH
6958: FOR_TO
6959: IFFALSE 7071
// begin uc_side := 1 ;
6961: LD_ADDR_OWVAR 20
6965: PUSH
6966: LD_INT 1
6968: ST_TO_ADDR
// uc_nation := 1 ;
6969: LD_ADDR_OWVAR 21
6973: PUSH
6974: LD_INT 1
6976: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
6977: LD_INT 0
6979: PPUSH
6980: LD_INT 1
6982: PPUSH
6983: LD_INT 2
6985: PUSH
6986: LD_INT 3
6988: PUSH
6989: LD_INT 4
6991: PUSH
6992: EMPTY
6993: LIST
6994: LIST
6995: LIST
6996: PUSH
6997: LD_OWVAR 67
7001: ARRAY
7002: PPUSH
7003: CALL_OW 380
// un := CreateHuman ;
7007: LD_ADDR_VAR 0 2
7011: PUSH
7012: CALL_OW 44
7016: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7017: LD_VAR 0 2
7021: PPUSH
7022: LD_INT 37
7024: PPUSH
7025: LD_INT 70
7027: PPUSH
7028: LD_INT 3
7030: PPUSH
7031: LD_INT 0
7033: PPUSH
7034: CALL_OW 50
// usAttackers := usAttackers union un ;
7038: LD_ADDR_EXP 43
7042: PUSH
7043: LD_EXP 43
7047: PUSH
7048: LD_VAR 0 2
7052: UNION
7053: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7054: LD_VAR 0 2
7058: PPUSH
7059: LD_INT 40
7061: PPUSH
7062: LD_INT 65
7064: PPUSH
7065: CALL_OW 111
// end ;
7069: GO 6958
7071: POP
7072: POP
// uc_side := 1 ;
7073: LD_ADDR_OWVAR 20
7077: PUSH
7078: LD_INT 1
7080: ST_TO_ADDR
// uc_nation := 1 ;
7081: LD_ADDR_OWVAR 21
7085: PUSH
7086: LD_INT 1
7088: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7089: LD_INT 0
7091: PPUSH
7092: LD_INT 4
7094: PPUSH
7095: LD_INT 2
7097: PPUSH
7098: CALL_OW 380
// un := CreateHuman ;
7102: LD_ADDR_VAR 0 2
7106: PUSH
7107: CALL_OW 44
7111: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7112: LD_VAR 0 2
7116: PPUSH
7117: LD_INT 37
7119: PPUSH
7120: LD_INT 70
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: LD_INT 0
7128: PPUSH
7129: CALL_OW 50
// usAttackers := usAttackers union un ;
7133: LD_ADDR_EXP 43
7137: PUSH
7138: LD_EXP 43
7142: PUSH
7143: LD_VAR 0 2
7147: UNION
7148: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7149: LD_VAR 0 2
7153: PPUSH
7154: LD_INT 40
7156: PPUSH
7157: LD_INT 65
7159: PPUSH
7160: CALL_OW 111
// if attackWave > 1 or Difficulty > 1 then
7164: LD_EXP 16
7168: PUSH
7169: LD_INT 1
7171: GREATER
7172: PUSH
7173: LD_OWVAR 67
7177: PUSH
7178: LD_INT 1
7180: GREATER
7181: OR
7182: IFFALSE 7385
// begin for i := 1 to Difficulty + attackWave div 4 do
7184: LD_ADDR_VAR 0 4
7188: PUSH
7189: DOUBLE
7190: LD_INT 1
7192: DEC
7193: ST_TO_ADDR
7194: LD_OWVAR 67
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: LD_INT 4
7206: DIV
7207: PLUS
7208: PUSH
7209: FOR_TO
7210: IFFALSE 7383
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7212: LD_ADDR_VAR 0 3
7216: PUSH
7217: LD_INT 1
7219: PPUSH
7220: LD_INT 1
7222: PPUSH
7223: LD_INT 2
7225: PPUSH
7226: LD_INT 1
7228: PPUSH
7229: LD_INT 1
7231: PPUSH
7232: LD_INT 4
7234: PUSH
7235: LD_INT 3
7237: PUSH
7238: LD_INT 2
7240: PUSH
7241: EMPTY
7242: LIST
7243: LIST
7244: LIST
7245: PUSH
7246: LD_INT 1
7248: PPUSH
7249: LD_INT 3
7251: PPUSH
7252: CALL_OW 12
7256: ARRAY
7257: PPUSH
7258: LD_INT 90
7260: PPUSH
7261: CALL 344 0 7
7265: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7266: LD_VAR 0 3
7270: PPUSH
7271: LD_INT 35
7273: PPUSH
7274: LD_INT 65
7276: PPUSH
7277: LD_INT 0
7279: PPUSH
7280: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7284: LD_INT 0
7286: PPUSH
7287: LD_INT 3
7289: PPUSH
7290: LD_OWVAR 67
7294: PUSH
7295: LD_INT 1
7297: PLUS
7298: PPUSH
7299: CALL_OW 380
// un := CreateHuman ;
7303: LD_ADDR_VAR 0 2
7307: PUSH
7308: CALL_OW 44
7312: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7313: LD_VAR 0 2
7317: PPUSH
7318: LD_VAR 0 3
7322: PPUSH
7323: CALL_OW 52
// usAttackers := usAttackers union un ;
7327: LD_ADDR_EXP 43
7331: PUSH
7332: LD_EXP 43
7336: PUSH
7337: LD_VAR 0 2
7341: UNION
7342: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7343: LD_VAR 0 3
7347: PPUSH
7348: LD_INT 39
7350: PPUSH
7351: LD_INT 60
7353: PPUSH
7354: CALL_OW 111
// wait ( 0 0$2 ) ;
7358: LD_INT 70
7360: PPUSH
7361: CALL_OW 67
// usAttackers := usAttackers union veh ;
7365: LD_ADDR_EXP 43
7369: PUSH
7370: LD_EXP 43
7374: PUSH
7375: LD_VAR 0 3
7379: UNION
7380: ST_TO_ADDR
// end ;
7381: GO 7209
7383: POP
7384: POP
// end ; attackWave := attackWave + 1 ;
7385: LD_ADDR_EXP 16
7389: PUSH
7390: LD_EXP 16
7394: PUSH
7395: LD_INT 1
7397: PLUS
7398: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7399: LD_EXP 20
7403: PPUSH
7404: CALL_OW 427
// end ;
7408: LD_VAR 0 1
7412: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7413: LD_INT 0
7415: PPUSH
7416: PPUSH
7417: PPUSH
7418: PPUSH
7419: PPUSH
7420: PPUSH
7421: PPUSH
7422: PPUSH
7423: PPUSH
7424: PPUSH
7425: PPUSH
// if retreatAllowed then
7426: LD_EXP 10
7430: IFFALSE 7442
// strategy := 2 else
7432: LD_ADDR_VAR 0 5
7436: PUSH
7437: LD_INT 2
7439: ST_TO_ADDR
7440: GO 7458
// strategy := rand ( 0 , 2 ) ;
7442: LD_ADDR_VAR 0 5
7446: PUSH
7447: LD_INT 0
7449: PPUSH
7450: LD_INT 2
7452: PPUSH
7453: CALL_OW 12
7457: ST_TO_ADDR
// attackFormula := [ ] ;
7458: LD_ADDR_VAR 0 6
7462: PUSH
7463: EMPTY
7464: ST_TO_ADDR
// case strategy of 0 :
7465: LD_VAR 0 5
7469: PUSH
7470: LD_INT 0
7472: DOUBLE
7473: EQUAL
7474: IFTRUE 7478
7476: GO 7808
7478: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7479: LD_INT 11
7481: PPUSH
7482: LD_INT 22
7484: PUSH
7485: LD_INT 2
7487: PUSH
7488: EMPTY
7489: LIST
7490: LIST
7491: PUSH
7492: LD_INT 30
7494: PUSH
7495: LD_INT 4
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PPUSH
7506: CALL_OW 70
7510: NOT
7511: IFFALSE 7583
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7513: LD_ADDR_VAR 0 6
7517: PUSH
7518: LD_INT 41
7520: PUSH
7521: LD_INT 34
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: PUSH
7528: EMPTY
7529: LIST
7530: PUSH
7531: LD_INT 53
7533: PUSH
7534: LD_INT 62
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: PUSH
7541: LD_INT 37
7543: PUSH
7544: LD_INT 63
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: LD_INT 44
7553: PUSH
7554: LD_INT 45
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PUSH
7561: LD_INT 37
7563: PUSH
7564: LD_INT 28
7566: PUSH
7567: EMPTY
7568: LIST
7569: LIST
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: LIST
7579: LIST
7580: ST_TO_ADDR
7581: GO 7806
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7583: LD_INT 12
7585: PPUSH
7586: LD_INT 22
7588: PUSH
7589: LD_INT 2
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: LD_INT 2
7598: PUSH
7599: LD_INT 30
7601: PUSH
7602: LD_INT 4
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 30
7611: PUSH
7612: LD_INT 31
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: LD_INT 30
7621: PUSH
7622: LD_INT 32
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: CALL_OW 70
7643: NOT
7644: IFFALSE 7727
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7646: LD_ADDR_VAR 0 6
7650: PUSH
7651: LD_INT 27
7653: PUSH
7654: LD_INT 42
7656: PUSH
7657: EMPTY
7658: LIST
7659: LIST
7660: PUSH
7661: LD_INT 27
7663: PUSH
7664: LD_INT 32
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 53
7677: PUSH
7678: LD_INT 62
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 37
7687: PUSH
7688: LD_INT 63
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: LD_INT 44
7697: PUSH
7698: LD_INT 45
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: PUSH
7705: LD_INT 37
7707: PUSH
7708: LD_INT 28
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: LIST
7723: LIST
7724: ST_TO_ADDR
7725: GO 7806
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7727: LD_ADDR_VAR 0 6
7731: PUSH
7732: LD_INT 71
7734: PUSH
7735: LD_INT 67
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PUSH
7742: LD_INT 54
7744: PUSH
7745: LD_INT 35
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: PUSH
7752: EMPTY
7753: LIST
7754: LIST
7755: PUSH
7756: LD_INT 63
7758: PUSH
7759: LD_INT 40
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PUSH
7766: LD_INT 37
7768: PUSH
7769: LD_INT 63
7771: PUSH
7772: EMPTY
7773: LIST
7774: LIST
7775: PUSH
7776: LD_INT 44
7778: PUSH
7779: LD_INT 45
7781: PUSH
7782: EMPTY
7783: LIST
7784: LIST
7785: PUSH
7786: LD_INT 37
7788: PUSH
7789: LD_INT 28
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: ST_TO_ADDR
// end ; 1 :
7806: GO 8011
7808: LD_INT 1
7810: DOUBLE
7811: EQUAL
7812: IFTRUE 7816
7814: GO 7920
7816: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7817: LD_ADDR_VAR 0 6
7821: PUSH
7822: LD_INT 71
7824: PUSH
7825: LD_INT 67
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: PUSH
7832: LD_INT 82
7834: PUSH
7835: LD_INT 23
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PUSH
7842: LD_INT 53
7844: PUSH
7845: LD_INT 7
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: PUSH
7852: LD_INT 43
7854: PUSH
7855: LD_INT 10
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: LIST
7866: LIST
7867: PUSH
7868: LD_INT 53
7870: PUSH
7871: LD_INT 62
7873: PUSH
7874: EMPTY
7875: LIST
7876: LIST
7877: PUSH
7878: LD_INT 37
7880: PUSH
7881: LD_INT 63
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: PUSH
7888: LD_INT 44
7890: PUSH
7891: LD_INT 45
7893: PUSH
7894: EMPTY
7895: LIST
7896: LIST
7897: PUSH
7898: LD_INT 37
7900: PUSH
7901: LD_INT 28
7903: PUSH
7904: EMPTY
7905: LIST
7906: LIST
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: LIST
7916: LIST
7917: ST_TO_ADDR
7918: GO 8011
7920: LD_INT 2
7922: DOUBLE
7923: EQUAL
7924: IFTRUE 7928
7926: GO 8010
7928: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
7929: LD_ADDR_VAR 0 6
7933: PUSH
7934: LD_INT 90
7936: PUSH
7937: LD_INT 59
7939: PUSH
7940: EMPTY
7941: LIST
7942: LIST
7943: PUSH
7944: LD_INT 108
7946: PUSH
7947: LD_INT 64
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: PUSH
7954: EMPTY
7955: LIST
7956: LIST
7957: PUSH
7958: LD_INT 82
7960: PUSH
7961: LD_INT 75
7963: PUSH
7964: EMPTY
7965: LIST
7966: LIST
7967: PUSH
7968: LD_INT 73
7970: PUSH
7971: LD_INT 67
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: PUSH
7978: LD_INT 101
7980: PUSH
7981: LD_INT 65
7983: PUSH
7984: EMPTY
7985: LIST
7986: LIST
7987: PUSH
7988: LD_INT 108
7990: PUSH
7991: LD_INT 62
7993: PUSH
7994: EMPTY
7995: LIST
7996: LIST
7997: PUSH
7998: EMPTY
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: LIST
8006: LIST
8007: ST_TO_ADDR
8008: GO 8011
8010: POP
// if not attackFormula then
8011: LD_VAR 0 6
8015: NOT
8016: IFFALSE 8020
// exit ;
8018: GO 9452
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8020: LD_ADDR_VAR 0 7
8024: PUSH
8025: LD_EXP 43
8029: PPUSH
8030: LD_INT 25
8032: PUSH
8033: LD_INT 1
8035: PUSH
8036: EMPTY
8037: LIST
8038: LIST
8039: PPUSH
8040: CALL_OW 72
8044: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8045: LD_ADDR_VAR 0 8
8049: PUSH
8050: LD_EXP 43
8054: PPUSH
8055: LD_INT 25
8057: PUSH
8058: LD_INT 4
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: PPUSH
8065: CALL_OW 72
8069: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8070: LD_ADDR_VAR 0 9
8074: PUSH
8075: LD_EXP 43
8079: PPUSH
8080: LD_INT 25
8082: PUSH
8083: LD_INT 3
8085: PUSH
8086: EMPTY
8087: LIST
8088: LIST
8089: PPUSH
8090: CALL_OW 72
8094: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8095: LD_ADDR_VAR 0 10
8099: PUSH
8100: LD_EXP 43
8104: PPUSH
8105: LD_INT 21
8107: PUSH
8108: LD_INT 2
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: PPUSH
8115: CALL_OW 72
8119: ST_TO_ADDR
// if sci then
8120: LD_VAR 0 8
8124: IFFALSE 8161
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8126: LD_VAR 0 8
8130: PPUSH
8131: LD_VAR 0 6
8135: PUSH
8136: LD_INT 2
8138: ARRAY
8139: PUSH
8140: LD_INT 1
8142: ARRAY
8143: PPUSH
8144: LD_VAR 0 6
8148: PUSH
8149: LD_INT 2
8151: ARRAY
8152: PUSH
8153: LD_INT 2
8155: ARRAY
8156: PPUSH
8157: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8161: LD_INT 35
8163: PPUSH
8164: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8168: LD_ADDR_VAR 0 7
8172: PUSH
8173: LD_EXP 43
8177: PPUSH
8178: LD_INT 25
8180: PUSH
8181: LD_INT 1
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: PPUSH
8188: CALL_OW 72
8192: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8193: LD_ADDR_VAR 0 8
8197: PUSH
8198: LD_EXP 43
8202: PPUSH
8203: LD_INT 25
8205: PUSH
8206: LD_INT 4
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 72
8217: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8218: LD_ADDR_VAR 0 9
8222: PUSH
8223: LD_EXP 43
8227: PPUSH
8228: LD_INT 25
8230: PUSH
8231: LD_INT 3
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: PPUSH
8238: CALL_OW 72
8242: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8243: LD_ADDR_VAR 0 10
8247: PUSH
8248: LD_EXP 43
8252: PPUSH
8253: LD_INT 21
8255: PUSH
8256: LD_INT 2
8258: PUSH
8259: EMPTY
8260: LIST
8261: LIST
8262: PPUSH
8263: CALL_OW 72
8267: ST_TO_ADDR
// if sol then
8268: LD_VAR 0 7
8272: IFFALSE 8667
// begin for i in sol do
8274: LD_ADDR_VAR 0 2
8278: PUSH
8279: LD_VAR 0 7
8283: PUSH
8284: FOR_IN
8285: IFFALSE 8665
// begin tag := GetTag ( i ) ;
8287: LD_ADDR_VAR 0 4
8291: PUSH
8292: LD_VAR 0 2
8296: PPUSH
8297: CALL_OW 110
8301: ST_TO_ADDR
// if not tag then
8302: LD_VAR 0 4
8306: NOT
8307: IFFALSE 8425
// begin if GetLives ( i ) = 1000 then
8309: LD_VAR 0 2
8313: PPUSH
8314: CALL_OW 256
8318: PUSH
8319: LD_INT 1000
8321: EQUAL
8322: IFFALSE 8338
// SetTag ( i , 1 ) else
8324: LD_VAR 0 2
8328: PPUSH
8329: LD_INT 1
8331: PPUSH
8332: CALL_OW 109
8336: GO 8423
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8338: LD_VAR 0 2
8342: PPUSH
8343: LD_VAR 0 6
8347: PUSH
8348: LD_INT 2
8350: ARRAY
8351: PUSH
8352: LD_INT 1
8354: ARRAY
8355: PPUSH
8356: LD_VAR 0 6
8360: PUSH
8361: LD_INT 2
8363: ARRAY
8364: PUSH
8365: LD_INT 2
8367: ARRAY
8368: PPUSH
8369: CALL_OW 297
8373: PUSH
8374: LD_INT 6
8376: GREATER
8377: IFFALSE 8423
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8379: LD_VAR 0 2
8383: PPUSH
8384: LD_VAR 0 6
8388: PUSH
8389: LD_INT 2
8391: ARRAY
8392: PUSH
8393: LD_INT 1
8395: ARRAY
8396: PPUSH
8397: LD_VAR 0 6
8401: PUSH
8402: LD_INT 2
8404: ARRAY
8405: PUSH
8406: LD_INT 2
8408: ARRAY
8409: PPUSH
8410: CALL_OW 111
// AddComHold ( i ) ;
8414: LD_VAR 0 2
8418: PPUSH
8419: CALL_OW 200
// end ; end else
8423: GO 8663
// begin if GetLives ( i ) < 720 then
8425: LD_VAR 0 2
8429: PPUSH
8430: CALL_OW 256
8434: PUSH
8435: LD_INT 720
8437: LESS
8438: IFFALSE 8454
// SetTag ( i , 0 ) else
8440: LD_VAR 0 2
8444: PPUSH
8445: LD_INT 0
8447: PPUSH
8448: CALL_OW 109
8452: GO 8663
// if tag <= attackFormula [ 1 ] then
8454: LD_VAR 0 4
8458: PUSH
8459: LD_VAR 0 6
8463: PUSH
8464: LD_INT 1
8466: ARRAY
8467: LESSEQUAL
8468: IFFALSE 8629
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8470: LD_VAR 0 2
8474: PPUSH
8475: LD_VAR 0 6
8479: PUSH
8480: LD_INT 1
8482: ARRAY
8483: PUSH
8484: LD_VAR 0 4
8488: ARRAY
8489: PUSH
8490: LD_INT 1
8492: ARRAY
8493: PPUSH
8494: LD_VAR 0 6
8498: PUSH
8499: LD_INT 1
8501: ARRAY
8502: PUSH
8503: LD_VAR 0 4
8507: ARRAY
8508: PUSH
8509: LD_INT 2
8511: ARRAY
8512: PPUSH
8513: CALL_OW 297
8517: PUSH
8518: LD_INT 6
8520: GREATER
8521: IFFALSE 8572
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8523: LD_VAR 0 2
8527: PPUSH
8528: LD_VAR 0 6
8532: PUSH
8533: LD_INT 1
8535: ARRAY
8536: PUSH
8537: LD_VAR 0 4
8541: ARRAY
8542: PUSH
8543: LD_INT 1
8545: ARRAY
8546: PPUSH
8547: LD_VAR 0 6
8551: PUSH
8552: LD_INT 1
8554: ARRAY
8555: PUSH
8556: LD_VAR 0 4
8560: ARRAY
8561: PUSH
8562: LD_INT 2
8564: ARRAY
8565: PPUSH
8566: CALL_OW 114
8570: GO 8627
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8572: LD_INT 81
8574: PUSH
8575: LD_INT 1
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: PUSH
8582: LD_INT 91
8584: PUSH
8585: LD_VAR 0 2
8589: PUSH
8590: LD_INT 10
8592: PUSH
8593: EMPTY
8594: LIST
8595: LIST
8596: LIST
8597: PUSH
8598: EMPTY
8599: LIST
8600: LIST
8601: PPUSH
8602: CALL_OW 69
8606: NOT
8607: IFFALSE 8627
// SetTag ( i , tag + 1 ) ;
8609: LD_VAR 0 2
8613: PPUSH
8614: LD_VAR 0 4
8618: PUSH
8619: LD_INT 1
8621: PLUS
8622: PPUSH
8623: CALL_OW 109
// end else
8627: GO 8663
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8629: LD_VAR 0 2
8633: PPUSH
8634: LD_INT 81
8636: PUSH
8637: LD_INT 1
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PPUSH
8644: CALL_OW 69
8648: PPUSH
8649: LD_VAR 0 2
8653: PPUSH
8654: CALL_OW 74
8658: PPUSH
8659: CALL_OW 115
// end ; end ;
8663: GO 8284
8665: POP
8666: POP
// end ; if sci then
8667: LD_VAR 0 8
8671: IFFALSE 8830
// begin if not sol and not mech then
8673: LD_VAR 0 7
8677: NOT
8678: PUSH
8679: LD_VAR 0 9
8683: NOT
8684: AND
8685: IFFALSE 8737
// begin for i in sci do
8687: LD_ADDR_VAR 0 2
8691: PUSH
8692: LD_VAR 0 8
8696: PUSH
8697: FOR_IN
8698: IFFALSE 8733
// begin usForces := usForces union i ;
8700: LD_ADDR_EXP 40
8704: PUSH
8705: LD_EXP 40
8709: PUSH
8710: LD_VAR 0 2
8714: UNION
8715: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8716: LD_VAR 0 2
8720: PPUSH
8721: LD_INT 34
8723: PPUSH
8724: LD_INT 68
8726: PPUSH
8727: CALL_OW 111
// end ;
8731: GO 8697
8733: POP
8734: POP
// end else
8735: GO 8830
// for i in sci do
8737: LD_ADDR_VAR 0 2
8741: PUSH
8742: LD_VAR 0 8
8746: PUSH
8747: FOR_IN
8748: IFFALSE 8828
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8750: LD_VAR 0 2
8754: PPUSH
8755: LD_VAR 0 6
8759: PUSH
8760: LD_INT 2
8762: ARRAY
8763: PUSH
8764: LD_INT 1
8766: ARRAY
8767: PPUSH
8768: LD_VAR 0 6
8772: PUSH
8773: LD_INT 2
8775: ARRAY
8776: PUSH
8777: LD_INT 2
8779: ARRAY
8780: PPUSH
8781: CALL_OW 297
8785: PUSH
8786: LD_INT 8
8788: GREATER
8789: IFFALSE 8826
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8791: LD_VAR 0 2
8795: PPUSH
8796: LD_VAR 0 6
8800: PUSH
8801: LD_INT 2
8803: ARRAY
8804: PUSH
8805: LD_INT 1
8807: ARRAY
8808: PPUSH
8809: LD_VAR 0 6
8813: PUSH
8814: LD_INT 2
8816: ARRAY
8817: PUSH
8818: LD_INT 2
8820: ARRAY
8821: PPUSH
8822: CALL_OW 111
8826: GO 8747
8828: POP
8829: POP
// end ; if tanks and mech then
8830: LD_VAR 0 10
8834: PUSH
8835: LD_VAR 0 9
8839: AND
8840: IFFALSE 9445
// begin for i in mech do
8842: LD_ADDR_VAR 0 2
8846: PUSH
8847: LD_VAR 0 9
8851: PUSH
8852: FOR_IN
8853: IFFALSE 9443
// begin tag := GetTag ( i ) ;
8855: LD_ADDR_VAR 0 4
8859: PUSH
8860: LD_VAR 0 2
8864: PPUSH
8865: CALL_OW 110
8869: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8870: LD_ADDR_VAR 0 11
8874: PUSH
8875: LD_VAR 0 2
8879: PPUSH
8880: CALL_OW 310
8884: ST_TO_ADDR
// if not tag then
8885: LD_VAR 0 4
8889: NOT
8890: IFFALSE 9203
// begin if veh then
8892: LD_VAR 0 11
8896: IFFALSE 9045
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
8898: LD_VAR 0 11
8902: PPUSH
8903: CALL_OW 256
8907: PUSH
8908: LD_INT 1000
8910: EQUAL
8911: PUSH
8912: LD_VAR 0 11
8916: PPUSH
8917: CALL_OW 261
8921: PUSH
8922: LD_INT 60
8924: GREATER
8925: AND
8926: IFFALSE 8942
// SetTag ( i , 1 ) else
8928: LD_VAR 0 2
8932: PPUSH
8933: LD_INT 1
8935: PPUSH
8936: CALL_OW 109
8940: GO 9043
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
8942: LD_VAR 0 2
8946: PPUSH
8947: LD_VAR 0 6
8951: PUSH
8952: LD_INT 3
8954: ARRAY
8955: PUSH
8956: LD_INT 1
8958: ARRAY
8959: PPUSH
8960: LD_VAR 0 6
8964: PUSH
8965: LD_INT 3
8967: ARRAY
8968: PUSH
8969: LD_INT 2
8971: ARRAY
8972: PPUSH
8973: CALL_OW 297
8977: PUSH
8978: LD_INT 7
8980: GREATER
8981: IFFALSE 9020
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
8983: LD_VAR 0 2
8987: PPUSH
8988: LD_VAR 0 6
8992: PUSH
8993: LD_INT 3
8995: ARRAY
8996: PUSH
8997: LD_INT 1
8999: ARRAY
9000: PPUSH
9001: LD_VAR 0 6
9005: PUSH
9006: LD_INT 3
9008: ARRAY
9009: PUSH
9010: LD_INT 2
9012: ARRAY
9013: PPUSH
9014: CALL_OW 111
9018: GO 9043
// begin ComExitVehicle ( i ) ;
9020: LD_VAR 0 2
9024: PPUSH
9025: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
9029: LD_VAR 0 2
9033: PPUSH
9034: LD_VAR 0 11
9038: PPUSH
9039: CALL_OW 189
// end ; end else
9043: GO 9201
// if GetLives ( i ) < 700 then
9045: LD_VAR 0 2
9049: PPUSH
9050: CALL_OW 256
9054: PUSH
9055: LD_INT 700
9057: LESS
9058: IFFALSE 9109
// begin usAttackers := usAttackers diff i ;
9060: LD_ADDR_EXP 43
9064: PUSH
9065: LD_EXP 43
9069: PUSH
9070: LD_VAR 0 2
9074: DIFF
9075: ST_TO_ADDR
// usForces := usForces union i ;
9076: LD_ADDR_EXP 40
9080: PUSH
9081: LD_EXP 40
9085: PUSH
9086: LD_VAR 0 2
9090: UNION
9091: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9092: LD_VAR 0 2
9096: PPUSH
9097: LD_INT 34
9099: PPUSH
9100: LD_INT 68
9102: PPUSH
9103: CALL_OW 111
// end else
9107: GO 9201
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9109: LD_VAR 0 10
9113: PPUSH
9114: LD_INT 58
9116: PUSH
9117: EMPTY
9118: LIST
9119: PUSH
9120: LD_INT 24
9122: PUSH
9123: LD_INT 1000
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PPUSH
9134: CALL_OW 72
9138: PUSH
9139: LD_VAR 0 2
9143: PPUSH
9144: CALL_OW 314
9148: NOT
9149: AND
9150: IFFALSE 9201
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9152: LD_VAR 0 2
9156: PPUSH
9157: LD_VAR 0 10
9161: PPUSH
9162: LD_INT 58
9164: PUSH
9165: EMPTY
9166: LIST
9167: PUSH
9168: LD_INT 24
9170: PUSH
9171: LD_INT 1000
9173: PUSH
9174: EMPTY
9175: LIST
9176: LIST
9177: PUSH
9178: EMPTY
9179: LIST
9180: LIST
9181: PPUSH
9182: CALL_OW 72
9186: PPUSH
9187: LD_VAR 0 2
9191: PPUSH
9192: CALL_OW 74
9196: PPUSH
9197: CALL_OW 120
// end else
9201: GO 9441
// begin if GetLives ( veh ) < 620 then
9203: LD_VAR 0 11
9207: PPUSH
9208: CALL_OW 256
9212: PUSH
9213: LD_INT 620
9215: LESS
9216: IFFALSE 9232
// SetTag ( i , 0 ) else
9218: LD_VAR 0 2
9222: PPUSH
9223: LD_INT 0
9225: PPUSH
9226: CALL_OW 109
9230: GO 9441
// if tag <= attackFormula [ 4 ] then
9232: LD_VAR 0 4
9236: PUSH
9237: LD_VAR 0 6
9241: PUSH
9242: LD_INT 4
9244: ARRAY
9245: LESSEQUAL
9246: IFFALSE 9407
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9248: LD_VAR 0 2
9252: PPUSH
9253: LD_VAR 0 6
9257: PUSH
9258: LD_INT 4
9260: ARRAY
9261: PUSH
9262: LD_VAR 0 4
9266: ARRAY
9267: PUSH
9268: LD_INT 1
9270: ARRAY
9271: PPUSH
9272: LD_VAR 0 6
9276: PUSH
9277: LD_INT 4
9279: ARRAY
9280: PUSH
9281: LD_VAR 0 4
9285: ARRAY
9286: PUSH
9287: LD_INT 2
9289: ARRAY
9290: PPUSH
9291: CALL_OW 297
9295: PUSH
9296: LD_INT 6
9298: GREATER
9299: IFFALSE 9350
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9301: LD_VAR 0 2
9305: PPUSH
9306: LD_VAR 0 6
9310: PUSH
9311: LD_INT 4
9313: ARRAY
9314: PUSH
9315: LD_VAR 0 4
9319: ARRAY
9320: PUSH
9321: LD_INT 1
9323: ARRAY
9324: PPUSH
9325: LD_VAR 0 6
9329: PUSH
9330: LD_INT 4
9332: ARRAY
9333: PUSH
9334: LD_VAR 0 4
9338: ARRAY
9339: PUSH
9340: LD_INT 2
9342: ARRAY
9343: PPUSH
9344: CALL_OW 114
9348: GO 9405
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9350: LD_INT 81
9352: PUSH
9353: LD_INT 1
9355: PUSH
9356: EMPTY
9357: LIST
9358: LIST
9359: PUSH
9360: LD_INT 91
9362: PUSH
9363: LD_VAR 0 2
9367: PUSH
9368: LD_INT 10
9370: PUSH
9371: EMPTY
9372: LIST
9373: LIST
9374: LIST
9375: PUSH
9376: EMPTY
9377: LIST
9378: LIST
9379: PPUSH
9380: CALL_OW 69
9384: NOT
9385: IFFALSE 9405
// SetTag ( i , tag + 1 ) ;
9387: LD_VAR 0 2
9391: PPUSH
9392: LD_VAR 0 4
9396: PUSH
9397: LD_INT 1
9399: PLUS
9400: PPUSH
9401: CALL_OW 109
// end else
9405: GO 9441
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9407: LD_VAR 0 2
9411: PPUSH
9412: LD_INT 81
9414: PUSH
9415: LD_INT 1
9417: PUSH
9418: EMPTY
9419: LIST
9420: LIST
9421: PPUSH
9422: CALL_OW 69
9426: PPUSH
9427: LD_VAR 0 2
9431: PPUSH
9432: CALL_OW 74
9436: PPUSH
9437: CALL_OW 115
// end ; end ;
9441: GO 8852
9443: POP
9444: POP
// end ; until not usAttackers ;
9445: LD_EXP 43
9449: NOT
9450: IFFALSE 8161
// end ;
9452: LD_VAR 0 1
9456: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do var i ;
9457: LD_INT 22
9459: PUSH
9460: LD_INT 1
9462: PUSH
9463: EMPTY
9464: LIST
9465: LIST
9466: PUSH
9467: LD_INT 32
9469: PUSH
9470: LD_INT 1
9472: PUSH
9473: EMPTY
9474: LIST
9475: LIST
9476: PUSH
9477: EMPTY
9478: LIST
9479: LIST
9480: PPUSH
9481: CALL_OW 69
9485: IFFALSE 9562
9487: GO 9489
9489: DISABLE
9490: LD_INT 0
9492: PPUSH
// begin enable ;
9493: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do
9494: LD_ADDR_VAR 0 1
9498: PUSH
9499: LD_INT 22
9501: PUSH
9502: LD_INT 1
9504: PUSH
9505: EMPTY
9506: LIST
9507: LIST
9508: PUSH
9509: LD_INT 32
9511: PUSH
9512: LD_INT 1
9514: PUSH
9515: EMPTY
9516: LIST
9517: LIST
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: PPUSH
9523: CALL_OW 69
9527: PUSH
9528: FOR_IN
9529: IFFALSE 9560
// if GetFuel ( i ) < 10 then
9531: LD_VAR 0 1
9535: PPUSH
9536: CALL_OW 261
9540: PUSH
9541: LD_INT 10
9543: LESS
9544: IFFALSE 9558
// SetFuel ( i , 10 ) ;
9546: LD_VAR 0 1
9550: PPUSH
9551: LD_INT 10
9553: PPUSH
9554: CALL_OW 240
9558: GO 9528
9560: POP
9561: POP
// end ; end_of_file
9562: PPOPN 1
9564: END
// export function Action ; var hasAll , i , tmp ; begin
9565: LD_INT 0
9567: PPUSH
9568: PPUSH
9569: PPUSH
9570: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9571: LD_ADDR_VAR 0 2
9575: PUSH
9576: LD_INT 22
9578: PUSH
9579: LD_INT 2
9581: PUSH
9582: EMPTY
9583: LIST
9584: LIST
9585: PUSH
9586: LD_INT 21
9588: PUSH
9589: LD_INT 1
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PUSH
9596: LD_INT 23
9598: PUSH
9599: LD_INT 2
9601: PUSH
9602: EMPTY
9603: LIST
9604: LIST
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: LIST
9610: PPUSH
9611: CALL_OW 69
9615: PUSH
9616: LD_INT 7
9618: GREATEREQUAL
9619: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9620: LD_VAR 0 2
9624: PPUSH
9625: LD_STRING 03_HasAll
9627: PPUSH
9628: CALL_OW 39
// Video ( true ) ;
9632: LD_INT 1
9634: PPUSH
9635: CALL 1004 0 1
// CenterNowOnUnits ( Heike ) ;
9639: LD_EXP 24
9643: PPUSH
9644: CALL_OW 87
// wait ( 0 0$2 ) ;
9648: LD_INT 70
9650: PPUSH
9651: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9655: LD_EXP 32
9659: PPUSH
9660: LD_STRING DF-1-start
9662: PPUSH
9663: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9667: LD_EXP 24
9671: PPUSH
9672: LD_EXP 32
9676: PPUSH
9677: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9681: LD_EXP 24
9685: PPUSH
9686: LD_STRING DH-1-start
9688: PPUSH
9689: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9693: LD_EXP 33
9697: PPUSH
9698: LD_INT 92
9700: PPUSH
9701: LD_INT 21
9703: PPUSH
9704: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9708: LD_EXP 28
9712: PPUSH
9713: LD_INT 94
9715: PPUSH
9716: LD_INT 23
9718: PPUSH
9719: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9723: LD_EXP 36
9727: PUSH
9728: LD_INT 1
9730: ARRAY
9731: PPUSH
9732: LD_INT 90
9734: PPUSH
9735: LD_INT 23
9737: PPUSH
9738: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9742: LD_EXP 36
9746: PUSH
9747: LD_INT 2
9749: ARRAY
9750: PPUSH
9751: LD_INT 93
9753: PPUSH
9754: LD_INT 25
9756: PPUSH
9757: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9761: LD_EXP 36
9765: PPUSH
9766: LD_EXP 33
9770: PPUSH
9771: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9775: LD_EXP 33
9779: PUSH
9780: LD_EXP 28
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PPUSH
9789: LD_EXP 24
9793: PPUSH
9794: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9798: LD_EXP 24
9802: PPUSH
9803: LD_EXP 33
9807: PPUSH
9808: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9812: LD_INT 35
9814: PPUSH
9815: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9819: LD_EXP 33
9823: PPUSH
9824: LD_INT 92
9826: PPUSH
9827: LD_INT 21
9829: PPUSH
9830: CALL_OW 307
9834: IFFALSE 9812
// Say ( Omar , DO-1-start ) ;
9836: LD_EXP 33
9840: PPUSH
9841: LD_STRING DO-1-start
9843: PPUSH
9844: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9848: LD_EXP 24
9852: PPUSH
9853: LD_STRING DH-2-start
9855: PPUSH
9856: CALL_OW 88
// if hasAll then
9860: LD_VAR 0 2
9864: IFFALSE 9992
// begin Say ( Omar , DO-2-start ) ;
9866: LD_EXP 33
9870: PPUSH
9871: LD_STRING DO-2-start
9873: PPUSH
9874: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9878: LD_EXP 33
9882: PPUSH
9883: LD_STRING DO-3-start
9885: PPUSH
9886: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
9890: LD_EXP 24
9894: PPUSH
9895: LD_STRING DH-3-start
9897: PPUSH
9898: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
9902: LD_EXP 32
9906: PPUSH
9907: LD_STRING DF-2-start
9909: PPUSH
9910: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9914: LD_EXP 33
9918: PPUSH
9919: LD_EXP 32
9923: PPUSH
9924: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
9928: LD_EXP 33
9932: PPUSH
9933: LD_STRING DO-4-start
9935: PPUSH
9936: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
9940: LD_EXP 32
9944: PPUSH
9945: LD_STRING DF-3-start
9947: PPUSH
9948: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
9952: LD_EXP 33
9956: PPUSH
9957: LD_STRING DO-5-start
9959: PPUSH
9960: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
9964: LD_EXP 32
9968: PPUSH
9969: LD_STRING DF-4-start
9971: PPUSH
9972: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
9976: LD_EXP 33
9980: PPUSH
9981: LD_EXP 24
9985: PPUSH
9986: CALL_OW 119
// end else
9990: GO 10092
// begin Say ( Omar , DO-2-start-a ) ;
9992: LD_EXP 33
9996: PPUSH
9997: LD_STRING DO-2-start-a
9999: PPUSH
10000: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
10004: LD_EXP 33
10008: PPUSH
10009: LD_STRING DO-3-start-a
10011: PPUSH
10012: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
10016: LD_EXP 24
10020: PPUSH
10021: LD_STRING DH-3-start-a
10023: PPUSH
10024: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
10028: LD_EXP 32
10032: PPUSH
10033: LD_STRING DF-2-start-a
10035: PPUSH
10036: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10040: LD_EXP 33
10044: PPUSH
10045: LD_EXP 32
10049: PPUSH
10050: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
10054: LD_EXP 33
10058: PPUSH
10059: LD_STRING DO-4-start-a
10061: PPUSH
10062: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
10066: LD_EXP 32
10070: PPUSH
10071: LD_STRING DF-3-start-a
10073: PPUSH
10074: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10078: LD_EXP 33
10082: PPUSH
10083: LD_EXP 24
10087: PPUSH
10088: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
10092: LD_INT 10
10094: PPUSH
10095: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
10099: LD_EXP 33
10103: PPUSH
10104: LD_STRING DO-1-mission
10106: PPUSH
10107: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
10111: LD_EXP 33
10115: PPUSH
10116: LD_STRING DO-2-mission
10118: PPUSH
10119: CALL_OW 88
// if not hasAll then
10123: LD_VAR 0 2
10127: NOT
10128: IFFALSE 10142
// Say ( Omar , DO-3-mission ) ;
10130: LD_EXP 33
10134: PPUSH
10135: LD_STRING DO-3-mission
10137: PPUSH
10138: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
10142: LD_EXP 33
10146: PPUSH
10147: LD_STRING DO-4-mission
10149: PPUSH
10150: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
10154: LD_EXP 24
10158: PPUSH
10159: LD_STRING DH-1-mission
10161: PPUSH
10162: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10166: LD_EXP 32
10170: PPUSH
10171: LD_STRING DF-1-mission
10173: PPUSH
10174: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10178: LD_EXP 33
10182: PPUSH
10183: LD_STRING DO-5-mission
10185: PPUSH
10186: CALL_OW 88
// if not hasAll then
10190: LD_VAR 0 2
10194: NOT
10195: IFFALSE 10330
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10197: LD_ADDR_VAR 0 4
10201: PUSH
10202: LD_INT 22
10204: PUSH
10205: LD_INT 2
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PUSH
10212: LD_INT 21
10214: PUSH
10215: LD_INT 1
10217: PUSH
10218: EMPTY
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 23
10224: PUSH
10225: LD_INT 2
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: LIST
10236: PPUSH
10237: CALL_OW 69
10241: ST_TO_ADDR
// for i := 7 downto tmp do
10242: LD_ADDR_VAR 0 3
10246: PUSH
10247: DOUBLE
10248: LD_INT 7
10250: INC
10251: ST_TO_ADDR
10252: LD_VAR 0 4
10256: PUSH
10257: FOR_DOWNTO
10258: IFFALSE 10328
// begin if omarSquad < 3 then
10260: LD_EXP 36
10264: PUSH
10265: LD_INT 3
10267: LESS
10268: IFFALSE 10272
// break ;
10270: GO 10328
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10272: LD_EXP 36
10276: PUSH
10277: LD_INT 3
10279: ARRAY
10280: PPUSH
10281: LD_INT 2
10283: PPUSH
10284: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10288: LD_ADDR_EXP 38
10292: PUSH
10293: LD_EXP 38
10297: PUSH
10298: LD_EXP 36
10302: PUSH
10303: LD_INT 3
10305: ARRAY
10306: UNION
10307: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10308: LD_ADDR_EXP 36
10312: PUSH
10313: LD_EXP 36
10317: PPUSH
10318: LD_INT 3
10320: PPUSH
10321: CALL_OW 3
10325: ST_TO_ADDR
// end ;
10326: GO 10257
10328: POP
10329: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10330: LD_EXP 33
10334: PUSH
10335: LD_EXP 36
10339: ADD
10340: PPUSH
10341: LD_INT 103
10343: PPUSH
10344: LD_INT 9
10346: PPUSH
10347: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10351: LD_VAR 0 2
10355: PUSH
10356: LD_EXP 29
10360: PPUSH
10361: CALL_OW 302
10365: AND
10366: IFFALSE 10427
// begin wait ( 0 0$3 ) ;
10368: LD_INT 105
10370: PPUSH
10371: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10375: LD_EXP 29
10379: PPUSH
10380: LD_EXP 32
10384: PPUSH
10385: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10389: LD_EXP 29
10393: PPUSH
10394: LD_STRING DK-1-side
10396: PPUSH
10397: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10401: LD_EXP 32
10405: PPUSH
10406: LD_EXP 29
10410: PPUSH
10411: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10415: LD_EXP 32
10419: PPUSH
10420: LD_STRING DF-1-side
10422: PPUSH
10423: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10427: LD_INT 22
10429: PUSH
10430: LD_INT 2
10432: PUSH
10433: EMPTY
10434: LIST
10435: LIST
10436: PPUSH
10437: CALL_OW 69
10441: PPUSH
10442: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10446: LD_EXP 32
10450: PUSH
10451: LD_EXP 35
10455: ADD
10456: PPUSH
10457: LD_INT 108
10459: PPUSH
10460: LD_INT 62
10462: PPUSH
10463: CALL_OW 111
// gameStarted := true ;
10467: LD_ADDR_EXP 3
10471: PUSH
10472: LD_INT 1
10474: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10475: LD_INT 105
10477: PPUSH
10478: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10482: LD_EXP 24
10486: PPUSH
10487: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10491: LD_EXP 24
10495: PPUSH
10496: LD_EXP 28
10500: PPUSH
10501: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10505: LD_INT 22
10507: PUSH
10508: LD_INT 2
10510: PUSH
10511: EMPTY
10512: LIST
10513: LIST
10514: PPUSH
10515: CALL_OW 69
10519: PUSH
10520: LD_EXP 24
10524: DIFF
10525: PPUSH
10526: LD_EXP 24
10530: PPUSH
10531: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10535: LD_EXP 24
10539: PPUSH
10540: LD_STRING DH-1-explore
10542: PPUSH
10543: CALL_OW 88
// if Givi then
10547: LD_EXP 25
10551: IFFALSE 10567
// Say ( Givi , DG-1-explore ) else
10553: LD_EXP 25
10557: PPUSH
10558: LD_STRING DG-1-explore
10560: PPUSH
10561: CALL_OW 88
10565: GO 10604
// if heikeSecondSquad then
10567: LD_EXP 38
10571: IFFALSE 10604
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10573: LD_EXP 38
10577: PPUSH
10578: LD_INT 26
10580: PUSH
10581: LD_INT 1
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PPUSH
10588: CALL_OW 72
10592: PUSH
10593: LD_INT 1
10595: ARRAY
10596: PPUSH
10597: LD_STRING DArm-1-explore
10599: PPUSH
10600: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10604: LD_EXP 28
10608: PPUSH
10609: LD_STRING DA-1-explore
10611: PPUSH
10612: CALL_OW 88
// if Sophia then
10616: LD_EXP 30
10620: IFFALSE 10698
// begin Say ( Sophia , DS-2-explore ) ;
10622: LD_EXP 30
10626: PPUSH
10627: LD_STRING DS-2-explore
10629: PPUSH
10630: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10634: LD_EXP 28
10638: PPUSH
10639: LD_STRING DA-2-explore
10641: PPUSH
10642: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10646: LD_EXP 30
10650: PPUSH
10651: LD_EXP 28
10655: PPUSH
10656: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10660: LD_EXP 28
10664: PPUSH
10665: LD_EXP 30
10669: PPUSH
10670: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10674: LD_EXP 30
10678: PPUSH
10679: LD_STRING DS-3-explore
10681: PPUSH
10682: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10686: LD_EXP 28
10690: PPUSH
10691: LD_STRING DA-3-explore
10693: PPUSH
10694: CALL_OW 88
// end ; if Mike then
10698: LD_EXP 26
10702: IFFALSE 10758
// begin Say ( Mike , DM-1-explore ) ;
10704: LD_EXP 26
10708: PPUSH
10709: LD_STRING DM-1-explore
10711: PPUSH
10712: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10716: LD_EXP 24
10720: PPUSH
10721: LD_STRING DH-2-explore
10723: PPUSH
10724: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10728: LD_EXP 26
10732: PPUSH
10733: LD_STRING DM-2-explore
10735: PPUSH
10736: CALL_OW 88
// if Kaia then
10740: LD_EXP 29
10744: IFFALSE 10758
// Say ( Kaia , DK-1-explore ) ;
10746: LD_EXP 29
10750: PPUSH
10751: LD_STRING DK-1-explore
10753: PPUSH
10754: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10758: LD_INT 22
10760: PUSH
10761: LD_INT 2
10763: PUSH
10764: EMPTY
10765: LIST
10766: LIST
10767: PPUSH
10768: CALL_OW 69
10772: PPUSH
10773: CALL_OW 139
// Video ( false ) ;
10777: LD_INT 0
10779: PPUSH
10780: CALL 1004 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10784: LD_STRING BuildBase
10786: PPUSH
10787: CALL_OW 337
// SaveForQuickRestart ;
10791: CALL_OW 22
// end ;
10795: LD_VAR 0 1
10799: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10800: LD_EXP 5
10804: NOT
10805: PUSH
10806: LD_EXP 6
10810: NOT
10811: AND
10812: PUSH
10813: LD_INT 5
10815: PPUSH
10816: LD_INT 22
10818: PUSH
10819: LD_INT 2
10821: PUSH
10822: EMPTY
10823: LIST
10824: LIST
10825: PPUSH
10826: CALL_OW 70
10830: AND
10831: PUSH
10832: LD_EXP 6
10836: NOT
10837: AND
10838: IFFALSE 10923
10840: GO 10842
10842: DISABLE
// begin if Mike then
10843: LD_EXP 26
10847: IFFALSE 10863
// Say ( Mike , DM-1-scout ) else
10849: LD_EXP 26
10853: PPUSH
10854: LD_STRING DM-1-scout
10856: PPUSH
10857: CALL_OW 88
10861: GO 10894
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10863: LD_EXP 38
10867: PPUSH
10868: LD_INT 26
10870: PUSH
10871: LD_INT 1
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PPUSH
10878: CALL_OW 72
10882: PUSH
10883: LD_INT 1
10885: ARRAY
10886: PPUSH
10887: LD_STRING DArm-1-explore
10889: PPUSH
10890: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
10894: LD_INT 54
10896: PPUSH
10897: LD_INT 35
10899: PPUSH
10900: LD_INT 2
10902: PPUSH
10903: LD_INT 1
10905: PPUSH
10906: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
10910: LD_INT 54
10912: PPUSH
10913: LD_INT 35
10915: PPUSH
10916: LD_INT 2
10918: PPUSH
10919: CALL_OW 331
// end ;
10923: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
10924: LD_INT 6
10926: PPUSH
10927: LD_INT 22
10929: PUSH
10930: LD_INT 2
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: PPUSH
10937: CALL_OW 70
10941: PUSH
10942: LD_EXP 6
10946: NOT
10947: AND
10948: IFFALSE 11202
10950: GO 10952
10952: DISABLE
10953: LD_INT 0
10955: PPUSH
10956: PPUSH
10957: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
10958: LD_ADDR_VAR 0 1
10962: PUSH
10963: LD_EXP 38
10967: PPUSH
10968: LD_INT 26
10970: PUSH
10971: LD_INT 1
10973: PUSH
10974: EMPTY
10975: LIST
10976: LIST
10977: PPUSH
10978: CALL_OW 72
10982: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
10983: LD_ADDR_VAR 0 2
10987: PUSH
10988: LD_EXP 38
10992: PPUSH
10993: LD_INT 26
10995: PUSH
10996: LD_INT 2
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: PPUSH
11003: CALL_OW 72
11007: ST_TO_ADDR
// DialogueOn ;
11008: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
11012: LD_INT 36
11014: PPUSH
11015: LD_INT 22
11017: PPUSH
11018: LD_INT 2
11020: PPUSH
11021: LD_INT 8
11023: PPUSH
11024: CALL_OW 330
// dwait ( 0 0$1 ) ;
11028: LD_INT 35
11030: PPUSH
11031: CALL_OW 68
// speakerOk := false ;
11035: LD_ADDR_VAR 0 3
11039: PUSH
11040: LD_INT 0
11042: ST_TO_ADDR
// if Mike then
11043: LD_EXP 26
11047: IFFALSE 11069
// speakerOk := Say ( Mike , DM-1-spot ) else
11049: LD_ADDR_VAR 0 3
11053: PUSH
11054: LD_EXP 26
11058: PPUSH
11059: LD_STRING DM-1-spot
11061: PPUSH
11062: CALL_OW 88
11066: ST_TO_ADDR
11067: GO 11097
// if randomMen then
11069: LD_VAR 0 1
11073: IFFALSE 11097
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11075: LD_ADDR_VAR 0 3
11079: PUSH
11080: LD_VAR 0 1
11084: PUSH
11085: LD_INT 1
11087: ARRAY
11088: PPUSH
11089: LD_STRING DArm-1-spot-a
11091: PPUSH
11092: CALL_OW 88
11096: ST_TO_ADDR
// if speakerOk then
11097: LD_VAR 0 3
11101: IFFALSE 11145
// begin if Givi then
11103: LD_EXP 25
11107: IFFALSE 11123
// Say ( Givi , DG-1-spot ) else
11109: LD_EXP 25
11113: PPUSH
11114: LD_STRING DG-1-spot
11116: PPUSH
11117: CALL_OW 88
11121: GO 11145
// if randomWomen then
11123: LD_VAR 0 2
11127: IFFALSE 11145
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
11129: LD_VAR 0 2
11133: PUSH
11134: LD_INT 1
11136: ARRAY
11137: PPUSH
11138: LD_STRING DArf-1-spot-a
11140: PPUSH
11141: CALL_OW 88
// end ; if Mike then
11145: LD_EXP 26
11149: IFFALSE 11165
// Say ( Heike , DH-1-spot ) else
11151: LD_EXP 24
11155: PPUSH
11156: LD_STRING DH-1-spot
11158: PPUSH
11159: CALL_OW 88
11163: GO 11177
// Say ( Heike , DH-1-spot-a ) ;
11165: LD_EXP 24
11169: PPUSH
11170: LD_STRING DH-1-spot-a
11172: PPUSH
11173: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11177: LD_INT 36
11179: PPUSH
11180: LD_INT 22
11182: PPUSH
11183: LD_INT 2
11185: PPUSH
11186: CALL_OW 331
// DialogueOff ;
11190: CALL_OW 7
// americanBaseSpoted := true ;
11194: LD_ADDR_EXP 5
11198: PUSH
11199: LD_INT 1
11201: ST_TO_ADDR
// end ;
11202: PPOPN 3
11204: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11205: LD_EXP 5
11209: NOT
11210: PUSH
11211: LD_INT 22
11213: PUSH
11214: LD_INT 2
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: LD_INT 101
11223: PUSH
11224: LD_INT 1
11226: PUSH
11227: EMPTY
11228: LIST
11229: LIST
11230: PUSH
11231: EMPTY
11232: LIST
11233: LIST
11234: PPUSH
11235: CALL_OW 69
11239: AND
11240: PUSH
11241: LD_EXP 6
11245: NOT
11246: AND
11247: IFFALSE 11333
11249: GO 11251
11251: DISABLE
11252: LD_INT 0
11254: PPUSH
// begin americanBaseSpoted := true ;
11255: LD_ADDR_EXP 5
11259: PUSH
11260: LD_INT 1
11262: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11263: LD_ADDR_VAR 0 1
11267: PUSH
11268: LD_EXP 38
11272: PPUSH
11273: LD_INT 26
11275: PUSH
11276: LD_INT 1
11278: PUSH
11279: EMPTY
11280: LIST
11281: LIST
11282: PPUSH
11283: CALL_OW 72
11287: ST_TO_ADDR
// if not randomMen then
11288: LD_VAR 0 1
11292: NOT
11293: IFFALSE 11297
// exit ;
11295: GO 11333
// DialogueOn ;
11297: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11301: LD_VAR 0 1
11305: PUSH
11306: LD_INT 1
11308: ARRAY
11309: PPUSH
11310: LD_STRING DArm-1-spot-a
11312: PPUSH
11313: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11317: LD_EXP 24
11321: PPUSH
11322: LD_STRING DH-1-spot-a
11324: PPUSH
11325: CALL_OW 88
// DialogueOff ;
11329: CALL_OW 7
// end ;
11333: PPOPN 1
11335: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) do var i , p ;
11336: LD_INT 11
11338: PPUSH
11339: CALL_OW 255
11343: PUSH
11344: LD_INT 2
11346: EQUAL
11347: PUSH
11348: LD_INT 7
11350: PPUSH
11351: LD_INT 22
11353: PUSH
11354: LD_INT 1
11356: PUSH
11357: EMPTY
11358: LIST
11359: LIST
11360: PUSH
11361: LD_INT 3
11363: PUSH
11364: LD_INT 50
11366: PUSH
11367: EMPTY
11368: LIST
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: PUSH
11374: LD_INT 30
11376: PUSH
11377: LD_INT 31
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: PUSH
11384: EMPTY
11385: LIST
11386: LIST
11387: LIST
11388: PPUSH
11389: CALL_OW 70
11393: OR
11394: PUSH
11395: LD_INT 7
11397: PPUSH
11398: LD_INT 22
11400: PUSH
11401: LD_INT 2
11403: PUSH
11404: EMPTY
11405: LIST
11406: LIST
11407: PPUSH
11408: CALL_OW 70
11412: PUSH
11413: LD_INT 1
11415: GREATER
11416: OR
11417: PUSH
11418: LD_INT 6
11420: PPUSH
11421: LD_INT 22
11423: PUSH
11424: LD_INT 2
11426: PUSH
11427: EMPTY
11428: LIST
11429: LIST
11430: PPUSH
11431: CALL_OW 70
11435: OR
11436: IFFALSE 11979
11438: GO 11440
11440: DISABLE
11441: LD_INT 0
11443: PPUSH
11444: PPUSH
// begin americanBaseCaptured := true ;
11445: LD_ADDR_EXP 6
11449: PUSH
11450: LD_INT 1
11452: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11453: LD_INT 105
11455: PPUSH
11456: CALL_OW 67
// if IsOk ( usCommander ) then
11460: LD_EXP 41
11464: PPUSH
11465: CALL_OW 302
11469: IFFALSE 11532
// begin usForces := usForces union usCommander ;
11471: LD_ADDR_EXP 40
11475: PUSH
11476: LD_EXP 40
11480: PUSH
11481: LD_EXP 41
11485: UNION
11486: ST_TO_ADDR
// if FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) then
11487: LD_INT 6
11489: PPUSH
11490: LD_INT 22
11492: PUSH
11493: LD_INT 2
11495: PUSH
11496: EMPTY
11497: LIST
11498: LIST
11499: PPUSH
11500: CALL_OW 70
11504: IFFALSE 11520
// Say ( usCommander , DUsm-2-assault ) else
11506: LD_EXP 41
11510: PPUSH
11511: LD_STRING DUsm-2-assault
11513: PPUSH
11514: CALL_OW 88
11518: GO 11532
// Say ( usCommander , DUsm-1-assault ) ;
11520: LD_EXP 41
11524: PPUSH
11525: LD_STRING DUsm-1-assault
11527: PPUSH
11528: CALL_OW 88
// end ; for i in usForces do
11532: LD_ADDR_VAR 0 1
11536: PUSH
11537: LD_EXP 40
11541: PUSH
11542: FOR_IN
11543: IFFALSE 11589
// begin if IsInUnit ( i ) then
11545: LD_VAR 0 1
11549: PPUSH
11550: CALL_OW 310
11554: IFFALSE 11565
// ComExitBuilding ( i ) ;
11556: LD_VAR 0 1
11560: PPUSH
11561: CALL_OW 122
// wait ( 3 ) ;
11565: LD_INT 3
11567: PPUSH
11568: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11572: LD_VAR 0 1
11576: PPUSH
11577: LD_INT 34
11579: PPUSH
11580: LD_INT 67
11582: PPUSH
11583: CALL_OW 111
// end ;
11587: GO 11542
11589: POP
11590: POP
// Say ( Heike , DH-1-assault ) ;
11591: LD_EXP 24
11595: PPUSH
11596: LD_STRING DH-1-assault
11598: PPUSH
11599: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11603: LD_INT 35
11605: PPUSH
11606: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11610: LD_VAR 0 1
11614: PPUSH
11615: LD_INT 34
11617: PPUSH
11618: LD_INT 67
11620: PPUSH
11621: CALL_OW 111
// until not usForces ;
11625: LD_EXP 40
11629: NOT
11630: IFFALSE 11603
// music_nat := 2 ;
11632: LD_ADDR_OWVAR 71
11636: PUSH
11637: LD_INT 2
11639: ST_TO_ADDR
// music_class := music_victory ;
11640: LD_ADDR_OWVAR 72
11644: PUSH
11645: LD_INT 4
11647: ST_TO_ADDR
// if not americanHasEscaped then
11648: LD_EXP 7
11652: NOT
11653: IFFALSE 11667
// Say ( Heike , DH-2-assault ) ;
11655: LD_EXP 24
11659: PPUSH
11660: LD_STRING DH-2-assault
11662: PPUSH
11663: CALL_OW 88
// wait ( 0 0$2 ) ;
11667: LD_INT 70
11669: PPUSH
11670: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11674: LD_INT 35
11676: PPUSH
11677: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11681: LD_INT 22
11683: PUSH
11684: LD_INT 2
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 21
11693: PUSH
11694: LD_INT 1
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: PUSH
11701: LD_INT 3
11703: PUSH
11704: LD_INT 50
11706: PUSH
11707: EMPTY
11708: LIST
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: PUSH
11714: EMPTY
11715: LIST
11716: LIST
11717: LIST
11718: PPUSH
11719: CALL_OW 69
11723: NOT
11724: IFFALSE 11674
// Video ( true ) ;
11726: LD_INT 1
11728: PPUSH
11729: CALL 1004 0 1
// if not GetSide ( usDepot ) = 2 then
11733: LD_INT 11
11735: PPUSH
11736: CALL_OW 255
11740: PUSH
11741: LD_INT 2
11743: EQUAL
11744: NOT
11745: IFFALSE 11757
// SetSide ( usDepot , 2 ) ;
11747: LD_INT 11
11749: PPUSH
11750: LD_INT 2
11752: PPUSH
11753: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11757: LD_INT 35
11759: PPUSH
11760: LD_INT 22
11762: PPUSH
11763: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11767: LD_EXP 24
11771: PPUSH
11772: LD_INT 35
11774: PPUSH
11775: LD_INT 22
11777: PPUSH
11778: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11782: LD_EXP 24
11786: PPUSH
11787: LD_INT 38
11789: PPUSH
11790: LD_INT 25
11792: PPUSH
11793: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11797: LD_EXP 37
11801: PUSH
11802: LD_EXP 38
11806: UNION
11807: PPUSH
11808: LD_INT 39
11810: PPUSH
11811: LD_INT 26
11813: PPUSH
11814: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11818: LD_EXP 37
11822: PUSH
11823: LD_EXP 38
11827: UNION
11828: PPUSH
11829: LD_EXP 24
11833: PPUSH
11834: CALL_OW 179
// p := 0 ;
11838: LD_ADDR_VAR 0 2
11842: PUSH
11843: LD_INT 0
11845: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11846: LD_INT 35
11848: PPUSH
11849: CALL_OW 67
// p := p + 1 ;
11853: LD_ADDR_VAR 0 2
11857: PUSH
11858: LD_VAR 0 2
11862: PUSH
11863: LD_INT 1
11865: PLUS
11866: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11867: LD_EXP 24
11871: PPUSH
11872: CALL_OW 314
11876: NOT
11877: PUSH
11878: LD_VAR 0 2
11882: PUSH
11883: LD_INT 10
11885: GREATER
11886: OR
11887: IFFALSE 11846
// Say ( Heike , DH-1-capture ) ;
11889: LD_EXP 24
11893: PPUSH
11894: LD_STRING DH-1-capture
11896: PPUSH
11897: CALL_OW 88
// if Markov then
11901: LD_EXP 31
11905: IFFALSE 11919
// Say ( Markov , DMar-1-capture ) ;
11907: LD_EXP 31
11911: PPUSH
11912: LD_STRING DMar-1-capture
11914: PPUSH
11915: CALL_OW 88
// if Sophia then
11919: LD_EXP 30
11923: IFFALSE 11949
// begin Say ( Heike , DH-2-capture ) ;
11925: LD_EXP 24
11929: PPUSH
11930: LD_STRING DH-2-capture
11932: PPUSH
11933: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
11937: LD_EXP 30
11941: PPUSH
11942: LD_STRING DS-1-capture
11944: PPUSH
11945: CALL_OW 88
// end ; Video ( false ) ;
11949: LD_INT 0
11951: PPUSH
11952: CALL 1004 0 1
// music_nat := music_auto ;
11956: LD_ADDR_OWVAR 71
11960: PUSH
11961: LD_INT 0
11963: ST_TO_ADDR
// music_class := music_auto ;
11964: LD_ADDR_OWVAR 72
11968: PUSH
11969: LD_INT 0
11971: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
11972: LD_STRING ConstructBase
11974: PPUSH
11975: CALL_OW 337
// end ;
11979: PPOPN 2
11981: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
11982: LD_INT 22
11984: PUSH
11985: LD_INT 2
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PUSH
11992: LD_INT 30
11994: PUSH
11995: LD_INT 2
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: PUSH
12002: LD_INT 3
12004: PUSH
12005: LD_INT 57
12007: PUSH
12008: EMPTY
12009: LIST
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: PUSH
12015: EMPTY
12016: LIST
12017: LIST
12018: LIST
12019: PPUSH
12020: CALL_OW 69
12024: IFFALSE 12267
12026: GO 12028
12028: DISABLE
// begin workshopBuilded := true ;
12029: LD_ADDR_EXP 9
12033: PUSH
12034: LD_INT 1
12036: ST_TO_ADDR
// if IsOk ( Markov ) then
12037: LD_EXP 31
12041: PPUSH
12042: CALL_OW 302
12046: IFFALSE 12105
// begin Say ( Heike , DH-1-shop-a ) ;
12048: LD_EXP 24
12052: PPUSH
12053: LD_STRING DH-1-shop-a
12055: PPUSH
12056: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
12060: LD_INT 47
12062: PPUSH
12063: LD_INT 2
12065: PPUSH
12066: CALL_OW 321
12070: PUSH
12071: LD_INT 2
12073: EQUAL
12074: PUSH
12075: LD_INT 45
12077: PPUSH
12078: LD_INT 2
12080: PPUSH
12081: CALL_OW 321
12085: PUSH
12086: LD_INT 2
12088: EQUAL
12089: AND
12090: NOT
12091: IFFALSE 12105
// Say ( Markov , DMar-1-shop-a ) ;
12093: LD_EXP 31
12097: PPUSH
12098: LD_STRING DMar-1-shop-a
12100: PPUSH
12101: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
12105: LD_INT 35
12107: PPUSH
12108: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched or GetTech ( tech_SolEng , 2 ) = state_researched ;
12112: LD_INT 47
12114: PPUSH
12115: LD_INT 2
12117: PPUSH
12118: CALL_OW 321
12122: PUSH
12123: LD_INT 2
12125: EQUAL
12126: PUSH
12127: LD_INT 45
12129: PPUSH
12130: LD_INT 2
12132: PPUSH
12133: CALL_OW 321
12137: PUSH
12138: LD_INT 2
12140: EQUAL
12141: OR
12142: IFFALSE 12105
// DialogueOn ;
12144: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
12148: LD_EXP 31
12152: PPUSH
12153: LD_STRING DMar-1-shop
12155: PPUSH
12156: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
12160: LD_EXP 24
12164: PPUSH
12165: LD_STRING DH-1-shop
12167: PPUSH
12168: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12172: LD_EXP 31
12176: PPUSH
12177: LD_STRING DMar-2-shop
12179: PPUSH
12180: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12184: LD_EXP 31
12188: PPUSH
12189: LD_STRING DMar-3-shop
12191: PPUSH
12192: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12196: LD_EXP 24
12200: PPUSH
12201: LD_STRING DH-2-shop
12203: PPUSH
12204: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12208: LD_EXP 31
12212: PPUSH
12213: LD_STRING DMar-4-shop
12215: PPUSH
12216: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12220: LD_EXP 24
12224: PPUSH
12225: LD_STRING DH-3-shop
12227: PPUSH
12228: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12232: LD_EXP 31
12236: PPUSH
12237: LD_STRING DMar-5-shop
12239: PPUSH
12240: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12244: LD_EXP 24
12248: PPUSH
12249: LD_STRING DH-4-shop
12251: PPUSH
12252: CALL_OW 88
// DialogueOff ;
12256: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12260: LD_STRING ConstructVeh
12262: PPUSH
12263: CALL_OW 337
// end ;
12267: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12268: LD_INT 2
12270: PPUSH
12271: LD_INT 2
12273: PPUSH
12274: LD_INT 1
12276: PPUSH
12277: CALL 1175 0 3
12281: PUSH
12282: LD_INT 0
12284: EQUAL
12285: IFFALSE 12297
12287: GO 12289
12289: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12290: LD_STRING Techs
12292: PPUSH
12293: CALL_OW 337
12297: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12298: LD_EXP 31
12302: PPUSH
12303: CALL_OW 302
12307: PUSH
12308: LD_INT 22
12310: PUSH
12311: LD_INT 2
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PUSH
12318: LD_INT 2
12320: PUSH
12321: LD_INT 34
12323: PUSH
12324: LD_INT 22
12326: PUSH
12327: EMPTY
12328: LIST
12329: LIST
12330: PUSH
12331: LD_INT 35
12333: PUSH
12334: LD_INT 22
12336: PUSH
12337: EMPTY
12338: LIST
12339: LIST
12340: PUSH
12341: EMPTY
12342: LIST
12343: LIST
12344: LIST
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PPUSH
12350: CALL_OW 69
12354: AND
12355: IFFALSE 12462
12357: GO 12359
12359: DISABLE
// begin DialogueOn ;
12360: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12364: LD_INT 22
12366: PUSH
12367: LD_INT 2
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: PUSH
12374: LD_INT 2
12376: PUSH
12377: LD_INT 34
12379: PUSH
12380: LD_INT 22
12382: PUSH
12383: EMPTY
12384: LIST
12385: LIST
12386: PUSH
12387: LD_INT 35
12389: PUSH
12390: LD_INT 22
12392: PUSH
12393: EMPTY
12394: LIST
12395: LIST
12396: PUSH
12397: EMPTY
12398: LIST
12399: LIST
12400: LIST
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: PPUSH
12406: CALL_OW 69
12410: PPUSH
12411: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12415: LD_INT 10
12417: PPUSH
12418: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12422: LD_EXP 24
12426: PPUSH
12427: LD_STRING DH-1-bal
12429: PPUSH
12430: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12434: LD_EXP 31
12438: PPUSH
12439: LD_STRING DMar-1-bal
12441: PPUSH
12442: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12446: LD_EXP 24
12450: PPUSH
12451: LD_STRING DH-2-bal
12453: PPUSH
12454: CALL_OW 88
// DialogueOff ;
12458: CALL_OW 7
// end ;
12462: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12463: LD_EXP 28
12467: PPUSH
12468: CALL_OW 302
12472: PUSH
12473: LD_INT 22
12475: PUSH
12476: LD_INT 2
12478: PUSH
12479: EMPTY
12480: LIST
12481: LIST
12482: PUSH
12483: LD_INT 30
12485: PUSH
12486: LD_INT 6
12488: PUSH
12489: EMPTY
12490: LIST
12491: LIST
12492: PUSH
12493: EMPTY
12494: LIST
12495: LIST
12496: PPUSH
12497: CALL_OW 69
12501: AND
12502: IFFALSE 12563
12504: GO 12506
12506: DISABLE
// begin DialogueOn ;
12507: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12511: LD_EXP 28
12515: PPUSH
12516: LD_STRING DA-1-lab
12518: PPUSH
12519: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12523: LD_EXP 24
12527: PPUSH
12528: LD_STRING DH-1-lab
12530: PPUSH
12531: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12535: LD_EXP 28
12539: PPUSH
12540: LD_STRING DA-2-lab
12542: PPUSH
12543: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12547: LD_EXP 24
12551: PPUSH
12552: LD_STRING DH-2-lab
12554: PPUSH
12555: CALL_OW 88
// DialogueOff ;
12559: CALL_OW 7
// end ;
12563: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) do var ape ;
12564: LD_EXP 29
12568: PPUSH
12569: CALL_OW 302
12573: PUSH
12574: LD_INT 22
12576: PUSH
12577: LD_INT 2
12579: PUSH
12580: EMPTY
12581: LIST
12582: LIST
12583: PUSH
12584: LD_INT 25
12586: PUSH
12587: LD_INT 15
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: PUSH
12594: EMPTY
12595: LIST
12596: LIST
12597: PPUSH
12598: CALL_OW 69
12602: AND
12603: IFFALSE 12783
12605: GO 12607
12607: DISABLE
12608: LD_INT 0
12610: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12611: LD_ADDR_VAR 0 1
12615: PUSH
12616: LD_INT 22
12618: PUSH
12619: LD_INT 2
12621: PUSH
12622: EMPTY
12623: LIST
12624: LIST
12625: PUSH
12626: LD_INT 25
12628: PUSH
12629: LD_INT 15
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: PUSH
12636: EMPTY
12637: LIST
12638: LIST
12639: PPUSH
12640: CALL_OW 69
12644: ST_TO_ADDR
// Video ( true ) ;
12645: LD_INT 1
12647: PPUSH
12648: CALL 1004 0 1
// CenterNowOnUnits ( ape [ 1 ] ) ;
12652: LD_VAR 0 1
12656: PUSH
12657: LD_INT 1
12659: ARRAY
12660: PPUSH
12661: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12665: LD_VAR 0 1
12669: PUSH
12670: LD_INT 1
12672: ARRAY
12673: PPUSH
12674: CALL_OW 122
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12678: LD_VAR 0 1
12682: PUSH
12683: LD_INT 1
12685: ARRAY
12686: PPUSH
12687: LD_INT 35
12689: PPUSH
12690: LD_INT 28
12692: PPUSH
12693: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12697: LD_VAR 0 1
12701: PUSH
12702: LD_INT 1
12704: ARRAY
12705: PPUSH
12706: LD_INT 36
12708: PPUSH
12709: LD_INT 17
12711: PPUSH
12712: CALL_OW 171
// Say ( Kaia , DK-1-apesol ) ;
12716: LD_EXP 29
12720: PPUSH
12721: LD_STRING DK-1-apesol
12723: PPUSH
12724: CALL_OW 88
// Say ( Aviradze , DA-1-apesol ) ;
12728: LD_EXP 28
12732: PPUSH
12733: LD_STRING DA-1-apesol
12735: PPUSH
12736: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12740: LD_EXP 29
12744: PPUSH
12745: LD_STRING DK-2-apesol
12747: PPUSH
12748: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12752: LD_EXP 28
12756: PPUSH
12757: LD_STRING DA-2-apesol
12759: PPUSH
12760: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12764: LD_EXP 29
12768: PPUSH
12769: LD_STRING DK-3-apesol
12771: PPUSH
12772: CALL_OW 88
// Video ( false ) ;
12776: LD_INT 0
12778: PPUSH
12779: CALL 1004 0 1
// end ;
12783: PPOPN 1
12785: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) do var ape ;
12786: LD_EXP 30
12790: PPUSH
12791: CALL_OW 302
12795: PUSH
12796: LD_INT 22
12798: PUSH
12799: LD_INT 2
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: LD_INT 25
12808: PUSH
12809: LD_INT 16
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PPUSH
12820: CALL_OW 69
12824: AND
12825: IFFALSE 13097
12827: GO 12829
12829: DISABLE
12830: LD_INT 0
12832: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
12833: LD_ADDR_VAR 0 1
12837: PUSH
12838: LD_INT 22
12840: PUSH
12841: LD_INT 2
12843: PUSH
12844: EMPTY
12845: LIST
12846: LIST
12847: PUSH
12848: LD_INT 25
12850: PUSH
12851: LD_INT 16
12853: PUSH
12854: EMPTY
12855: LIST
12856: LIST
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: PPUSH
12862: CALL_OW 69
12866: ST_TO_ADDR
// Video ( true ) ;
12867: LD_INT 1
12869: PPUSH
12870: CALL 1004 0 1
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
12874: LD_INT 5
12876: PPUSH
12877: LD_INT 35
12879: PPUSH
12880: LD_INT 22
12882: PPUSH
12883: LD_INT 1
12885: PPUSH
12886: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
12890: LD_EXP 30
12894: PPUSH
12895: LD_VAR 0 1
12899: PUSH
12900: LD_INT 1
12902: ARRAY
12903: PPUSH
12904: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
12908: LD_VAR 0 1
12912: PUSH
12913: LD_INT 1
12915: ARRAY
12916: PPUSH
12917: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12921: LD_VAR 0 1
12925: PUSH
12926: LD_INT 1
12928: ARRAY
12929: PPUSH
12930: CALL_OW 122
// wait ( 0 0$2 ) ;
12934: LD_INT 70
12936: PPUSH
12937: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
12941: LD_EXP 30
12945: PPUSH
12946: LD_STRING DS-1-apeeng
12948: PPUSH
12949: CALL_OW 88
// if IsOk ( Kamil ) then
12953: LD_EXP 27
12957: PPUSH
12958: CALL_OW 302
12962: IFFALSE 13090
// begin Say ( Kamil , DKam-1-apeeng ) ;
12964: LD_EXP 27
12968: PPUSH
12969: LD_STRING DKam-1-apeeng
12971: PPUSH
12972: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
12976: LD_EXP 30
12980: PPUSH
12981: LD_STRING DS-2-apeeng
12983: PPUSH
12984: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
12988: LD_EXP 27
12992: PPUSH
12993: LD_STRING DKam-2-apeeng
12995: PPUSH
12996: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
13000: LD_EXP 30
13004: PPUSH
13005: LD_STRING DS-3-apeeng
13007: PPUSH
13008: CALL_OW 88
// if not IsOK ( Kaia ) then
13012: LD_EXP 29
13016: PPUSH
13017: CALL_OW 302
13021: NOT
13022: IFFALSE 13033
// begin Video ( false ) ;
13024: LD_INT 0
13026: PPUSH
13027: CALL 1004 0 1
// exit ;
13031: GO 13097
// end ; Say ( Kaia , DK-1-apeeng ) ;
13033: LD_EXP 29
13037: PPUSH
13038: LD_STRING DK-1-apeeng
13040: PPUSH
13041: CALL_OW 88
// if not IsOk ( Givi ) then
13045: LD_EXP 25
13049: PPUSH
13050: CALL_OW 302
13054: NOT
13055: IFFALSE 13066
// begin Video ( false ) ;
13057: LD_INT 0
13059: PPUSH
13060: CALL 1004 0 1
// exit ;
13064: GO 13097
// end ; Say ( Givi , DG-1-apeeng ) ;
13066: LD_EXP 25
13070: PPUSH
13071: LD_STRING DG-1-apeeng
13073: PPUSH
13074: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
13078: LD_EXP 29
13082: PPUSH
13083: LD_STRING DK-2-apeeng
13085: PPUSH
13086: CALL_OW 88
// end ; Video ( false ) ;
13090: LD_INT 0
13092: PPUSH
13093: CALL 1004 0 1
// end ;
13097: PPOPN 1
13099: END
// every 0 0$1 trigger farmerBaseReady and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) do
13100: LD_EXP 4
13104: PUSH
13105: LD_INT 22
13107: PUSH
13108: LD_INT 2
13110: PUSH
13111: EMPTY
13112: LIST
13113: LIST
13114: PUSH
13115: LD_INT 30
13117: PUSH
13118: LD_INT 0
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PUSH
13125: EMPTY
13126: LIST
13127: LIST
13128: PPUSH
13129: CALL_OW 69
13133: AND
13134: IFFALSE 13292
13136: GO 13138
13138: DISABLE
// begin DialogueOn ;
13139: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
13143: LD_EXP 32
13147: PPUSH
13148: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
13152: LD_EXP 32
13156: PPUSH
13157: LD_STRING DF-1-distribution
13159: PPUSH
13160: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
13164: LD_EXP 24
13168: PPUSH
13169: LD_STRING DH-2-distribution
13171: PPUSH
13172: CALL_OW 88
// if IsOk ( Kaia ) then
13176: LD_EXP 29
13180: PPUSH
13181: CALL_OW 302
13185: IFFALSE 13246
// begin Say ( Kaia , DK-1-distribution ) ;
13187: LD_EXP 29
13191: PPUSH
13192: LD_STRING DK-1-distribution
13194: PPUSH
13195: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13199: LD_EXP 24
13203: PPUSH
13204: LD_STRING DH-1-distribution
13206: PPUSH
13207: CALL_OW 88
// if IsOk ( Givi ) then
13211: LD_EXP 25
13215: PPUSH
13216: CALL_OW 302
13220: IFFALSE 13246
// begin Say ( Givi , DG-1-distribution ) ;
13222: LD_EXP 25
13226: PPUSH
13227: LD_STRING DG-1-distribution
13229: PPUSH
13230: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13234: LD_EXP 24
13238: PPUSH
13239: LD_STRING DH-3-distribution
13241: PPUSH
13242: CALL_OW 88
// end ; end ; DialogueOff ;
13246: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13250: LD_STRING Crates1
13252: PPUSH
13253: CALL_OW 337
// farmerRequestedCrates := 300 ;
13257: LD_ADDR_EXP 13
13261: PUSH
13262: LD_INT 300
13264: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13265: LD_STRING FarmerCrates
13267: PPUSH
13268: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13272: LD_INT 10
13274: PPUSH
13275: LD_INT 1
13277: PPUSH
13278: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13282: LD_INT 108
13284: PPUSH
13285: LD_INT 61
13287: PPUSH
13288: CALL_OW 86
// end ;
13292: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13293: LD_EXP 6
13297: PUSH
13298: LD_INT 22
13300: PUSH
13301: LD_INT 2
13303: PUSH
13304: EMPTY
13305: LIST
13306: LIST
13307: PUSH
13308: LD_INT 3
13310: PUSH
13311: LD_INT 57
13313: PUSH
13314: EMPTY
13315: LIST
13316: PUSH
13317: EMPTY
13318: LIST
13319: LIST
13320: PUSH
13321: LD_INT 2
13323: PUSH
13324: LD_INT 30
13326: PUSH
13327: LD_INT 6
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: PUSH
13334: LD_INT 30
13336: PUSH
13337: LD_INT 7
13339: PUSH
13340: EMPTY
13341: LIST
13342: LIST
13343: PUSH
13344: EMPTY
13345: LIST
13346: LIST
13347: LIST
13348: PUSH
13349: EMPTY
13350: LIST
13351: LIST
13352: LIST
13353: PPUSH
13354: CALL_OW 69
13358: AND
13359: PUSH
13360: LD_INT 22
13362: PUSH
13363: LD_INT 2
13365: PUSH
13366: EMPTY
13367: LIST
13368: LIST
13369: PUSH
13370: LD_INT 3
13372: PUSH
13373: LD_INT 57
13375: PUSH
13376: EMPTY
13377: LIST
13378: PUSH
13379: EMPTY
13380: LIST
13381: LIST
13382: PUSH
13383: LD_INT 30
13385: PUSH
13386: LD_INT 4
13388: PUSH
13389: EMPTY
13390: LIST
13391: LIST
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: LIST
13397: PPUSH
13398: CALL_OW 69
13402: AND
13403: IFFALSE 13567
13405: GO 13407
13407: DISABLE
13408: LD_INT 0
13410: PPUSH
// begin wait ( 0 0$10 ) ;
13411: LD_INT 350
13413: PPUSH
13414: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13418: LD_ADDR_VAR 0 1
13422: PUSH
13423: LD_EXP 38
13427: PPUSH
13428: LD_INT 26
13430: PUSH
13431: LD_INT 1
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 25
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 72
13456: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13457: LD_EXP 24
13461: PPUSH
13462: LD_STRING DH-1-task
13464: PPUSH
13465: CALL_OW 88
// if IsOk ( Sophia ) then
13469: LD_EXP 30
13473: PPUSH
13474: CALL_OW 302
13478: IFFALSE 13518
// begin Say ( Sophia , DS-1-task ) ;
13480: LD_EXP 30
13484: PPUSH
13485: LD_STRING DS-1-task
13487: PPUSH
13488: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13492: LD_EXP 30
13496: PPUSH
13497: LD_STRING DS-2-task
13499: PPUSH
13500: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13504: LD_EXP 24
13508: PPUSH
13509: LD_STRING DH-2-task
13511: PPUSH
13512: CALL_OW 88
// end else
13516: GO 13552
// if eng then
13518: LD_VAR 0 1
13522: IFFALSE 13552
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13524: LD_VAR 0 1
13528: PUSH
13529: LD_INT 1
13531: ARRAY
13532: PPUSH
13533: LD_STRING DArm-1-task
13535: PPUSH
13536: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13540: LD_EXP 24
13544: PPUSH
13545: LD_STRING DH-2-task
13547: PPUSH
13548: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13552: LD_STRING BaseConstructed
13554: PPUSH
13555: CALL_OW 337
// allowConvoys := true ;
13559: LD_ADDR_EXP 11
13563: PUSH
13564: LD_INT 1
13566: ST_TO_ADDR
// end ;
13567: PPOPN 1
13569: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13570: LD_INT 22
13572: PUSH
13573: LD_INT 4
13575: PUSH
13576: EMPTY
13577: LIST
13578: LIST
13579: PUSH
13580: LD_INT 34
13582: PUSH
13583: LD_INT 12
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: PPUSH
13594: CALL_OW 69
13598: IFFALSE 13766
13600: GO 13602
13602: DISABLE
13603: LD_INT 0
13605: PPUSH
13606: PPUSH
13607: PPUSH
// begin wait ( 0 0$2 ) ;
13608: LD_INT 70
13610: PPUSH
13611: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13615: LD_ADDR_VAR 0 1
13619: PUSH
13620: LD_INT 22
13622: PUSH
13623: LD_INT 4
13625: PUSH
13626: EMPTY
13627: LIST
13628: LIST
13629: PUSH
13630: LD_INT 34
13632: PUSH
13633: LD_INT 12
13635: PUSH
13636: EMPTY
13637: LIST
13638: LIST
13639: PUSH
13640: EMPTY
13641: LIST
13642: LIST
13643: PPUSH
13644: CALL_OW 69
13648: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13649: LD_ADDR_VAR 0 2
13653: PUSH
13654: LD_VAR 0 1
13658: PUSH
13659: LD_INT 1
13661: ARRAY
13662: PPUSH
13663: CALL_OW 250
13667: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13668: LD_ADDR_VAR 0 3
13672: PUSH
13673: LD_VAR 0 1
13677: PUSH
13678: LD_INT 1
13680: ARRAY
13681: PPUSH
13682: CALL_OW 251
13686: ST_TO_ADDR
// DialogueOn ;
13687: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13691: LD_VAR 0 2
13695: PPUSH
13696: LD_VAR 0 3
13700: PPUSH
13701: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13705: LD_VAR 0 2
13709: PPUSH
13710: LD_VAR 0 3
13714: PPUSH
13715: LD_INT 2
13717: PPUSH
13718: LD_INT 6
13720: NEG
13721: PPUSH
13722: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13726: LD_INT 10
13728: PPUSH
13729: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13733: LD_EXP 24
13737: PPUSH
13738: LD_STRING DH-1-seecargo
13740: PPUSH
13741: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13745: LD_VAR 0 2
13749: PPUSH
13750: LD_VAR 0 3
13754: PPUSH
13755: LD_INT 2
13757: PPUSH
13758: CALL_OW 331
// DialogueOff ;
13762: CALL_OW 7
// end ;
13766: PPOPN 3
13768: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13769: LD_EXP 4
13773: PUSH
13774: LD_EXP 12
13778: PUSH
13779: LD_INT 300
13781: GREATEREQUAL
13782: AND
13783: IFFALSE 13855
13785: GO 13787
13787: DISABLE
// begin DialogueOn ;
13788: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13792: LD_EXP 32
13796: PPUSH
13797: LD_STRING DF-1-delivery-2
13799: PPUSH
13800: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13804: LD_EXP 24
13808: PPUSH
13809: LD_STRING DH-1-delivery-2
13811: PPUSH
13812: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
13816: LD_EXP 32
13820: PPUSH
13821: LD_STRING DF-2-delivery-2
13823: PPUSH
13824: CALL_OW 94
// DialogueOff ;
13828: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
13832: LD_STRING Crates2
13834: PPUSH
13835: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13839: LD_ADDR_EXP 14
13843: PUSH
13844: LD_INT 63000
13846: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
13847: LD_ADDR_EXP 13
13851: PUSH
13852: LD_INT 600
13854: ST_TO_ADDR
// end ;
13855: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 do
13856: LD_EXP 4
13860: PUSH
13861: LD_EXP 12
13865: PUSH
13866: LD_INT 600
13868: GREATEREQUAL
13869: AND
13870: IFFALSE 14036
13872: GO 13874
13874: DISABLE
// begin DialogueOn ;
13875: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
13879: LD_EXP 32
13883: PPUSH
13884: LD_STRING DF-1-delivery-3
13886: PPUSH
13887: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
13891: LD_EXP 24
13895: PPUSH
13896: LD_STRING DH-1-delivery-3
13898: PPUSH
13899: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
13903: LD_EXP 32
13907: PPUSH
13908: LD_STRING DF-2-delivery-3
13910: PPUSH
13911: CALL_OW 94
// if IsOk ( Kaia ) then
13915: LD_EXP 29
13919: PPUSH
13920: CALL_OW 302
13924: IFFALSE 13974
// begin Say ( Kaia , DK-1-delivery-3 ) ;
13926: LD_EXP 29
13930: PPUSH
13931: LD_STRING DK-1-delivery-3
13933: PPUSH
13934: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
13938: LD_EXP 24
13942: PPUSH
13943: LD_STRING DH-2-delivery-3
13945: PPUSH
13946: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
13950: LD_EXP 25
13954: PPUSH
13955: LD_STRING DG-1-delivery-3
13957: PPUSH
13958: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
13962: LD_EXP 26
13966: PPUSH
13967: LD_STRING DM-1-delivery-3
13969: PPUSH
13970: CALL_OW 88
// end ; DialogueOff ;
13974: CALL_OW 7
// if Difficulty = 2 then
13978: LD_OWVAR 67
13982: PUSH
13983: LD_INT 2
13985: EQUAL
13986: IFFALSE 14013
// begin ChangeMissionObjectives ( Crates3 ) ;
13988: LD_STRING Crates3
13990: PPUSH
13991: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13995: LD_ADDR_EXP 14
13999: PUSH
14000: LD_INT 63000
14002: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
14003: LD_ADDR_EXP 13
14007: PUSH
14008: LD_INT 900
14010: ST_TO_ADDR
// end else
14011: GO 14036
// begin ChangeMissionObjectives ( Crates4 ) ;
14013: LD_STRING Crates4
14015: PPUSH
14016: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14020: LD_ADDR_EXP 14
14024: PUSH
14025: LD_INT 63000
14027: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
14028: LD_ADDR_EXP 13
14032: PUSH
14033: LD_INT 1200
14035: ST_TO_ADDR
// end ; end ;
14036: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
14037: LD_EXP 4
14041: PUSH
14042: LD_EXP 12
14046: PUSH
14047: LD_INT 600
14049: PUSH
14050: LD_INT 900
14052: PUSH
14053: LD_INT 1200
14055: PUSH
14056: EMPTY
14057: LIST
14058: LIST
14059: LIST
14060: PUSH
14061: LD_OWVAR 67
14065: ARRAY
14066: GREATEREQUAL
14067: AND
14068: PUSH
14069: LD_EXP 13
14073: PUSH
14074: LD_EXP 14
14078: LESSEQUAL
14079: AND
14080: IFFALSE 14153
14082: GO 14084
14084: DISABLE
// begin retreatAllowed := true ;
14085: LD_ADDR_EXP 10
14089: PUSH
14090: LD_INT 1
14092: ST_TO_ADDR
// display_strings := [ ] ;
14093: LD_ADDR_OWVAR 47
14097: PUSH
14098: EMPTY
14099: ST_TO_ADDR
// DialogueOn ;
14100: CALL_OW 6
// Video ( true ) ;
14104: LD_INT 1
14106: PPUSH
14107: CALL 1004 0 1
// SayRadio ( Omar , DO-radio-end ) ;
14111: LD_EXP 33
14115: PPUSH
14116: LD_STRING DO-radio-end
14118: PPUSH
14119: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
14123: LD_EXP 24
14127: PPUSH
14128: LD_STRING DH-1-radio-end
14130: PPUSH
14131: CALL_OW 88
// Video ( false ) ;
14135: LD_INT 0
14137: PPUSH
14138: CALL 1004 0 1
// DialogueOff ;
14142: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
14146: LD_STRING Retreat
14148: PPUSH
14149: CALL_OW 337
// end ;
14153: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
14154: LD_EXP 10
14158: IFFALSE 14293
14160: GO 14162
14162: DISABLE
14163: LD_INT 0
14165: PPUSH
14166: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
14167: LD_INT 10
14169: PPUSH
14170: LD_INT 0
14172: PPUSH
14173: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
14177: LD_ADDR_VAR 0 1
14181: PUSH
14182: LD_EXP 35
14186: PPUSH
14187: LD_INT 25
14189: PUSH
14190: LD_INT 2
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: PPUSH
14197: CALL_OW 72
14201: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14202: LD_VAR 0 1
14206: PUSH
14207: LD_INT 102
14209: PPUSH
14210: LD_INT 69
14212: PPUSH
14213: CALL_OW 428
14217: PUSH
14218: LD_INT 0
14220: EQUAL
14221: AND
14222: IFFALSE 14289
// begin for i in tmp do
14224: LD_ADDR_VAR 0 2
14228: PUSH
14229: LD_VAR 0 1
14233: PUSH
14234: FOR_IN
14235: IFFALSE 14259
// if IsInUnit ( i ) then
14237: LD_VAR 0 2
14241: PPUSH
14242: CALL_OW 310
14246: IFFALSE 14257
// ComExitBuilding ( i ) ;
14248: LD_VAR 0 2
14252: PPUSH
14253: CALL_OW 122
14257: GO 14234
14259: POP
14260: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14261: LD_VAR 0 1
14265: PPUSH
14266: LD_INT 31
14268: PPUSH
14269: LD_INT 102
14271: PPUSH
14272: LD_INT 69
14274: PPUSH
14275: LD_INT 2
14277: PPUSH
14278: CALL_OW 205
// wait ( 0 0$3 ) ;
14282: LD_INT 105
14284: PPUSH
14285: CALL_OW 67
// end ; StartCargoEvacuation ;
14289: CALL 4470 0 0
// end ;
14293: PPOPN 2
14295: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14296: LD_EXP 10
14300: NOT
14301: PUSH
14302: LD_INT 5
14304: PPUSH
14305: CALL_OW 301
14309: AND
14310: IFFALSE 14334
14312: GO 14314
14314: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
14315: LD_EXP 32
14319: PPUSH
14320: LD_STRING DF-1-failure
14322: PPUSH
14323: CALL_OW 94
// YouLost ( FarmerDepot ) ;
14327: LD_STRING FarmerDepot
14329: PPUSH
14330: CALL_OW 104
// end ;
14334: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 do var i , max , tmp ;
14335: LD_EXP 10
14339: PUSH
14340: LD_EXP 24
14344: PPUSH
14345: LD_EXP 32
14349: PPUSH
14350: CALL_OW 296
14354: PUSH
14355: LD_INT 6
14357: LESS
14358: AND
14359: IFFALSE 14945
14361: GO 14363
14363: DISABLE
14364: LD_INT 0
14366: PPUSH
14367: PPUSH
14368: PPUSH
// begin allowConvoys := false ;
14369: LD_ADDR_EXP 11
14373: PUSH
14374: LD_INT 0
14376: ST_TO_ADDR
// Video ( true ) ;
14377: LD_INT 1
14379: PPUSH
14380: CALL 1004 0 1
// ComTurnUnit ( Heike , Farmer ) ;
14384: LD_EXP 24
14388: PPUSH
14389: LD_EXP 32
14393: PPUSH
14394: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14398: LD_EXP 32
14402: PPUSH
14403: LD_EXP 24
14407: PPUSH
14408: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14412: LD_EXP 32
14416: PPUSH
14417: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14421: LD_EXP 24
14425: PPUSH
14426: LD_STRING DH-1-end
14428: PPUSH
14429: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14433: LD_EXP 32
14437: PPUSH
14438: LD_STRING DF-1-end
14440: PPUSH
14441: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14445: LD_EXP 32
14449: PPUSH
14450: LD_STRING DF-2-end
14452: PPUSH
14453: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14457: LD_EXP 24
14461: PPUSH
14462: LD_STRING DH-2-end
14464: PPUSH
14465: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14469: LD_EXP 32
14473: PPUSH
14474: LD_STRING DF-3-end
14476: PPUSH
14477: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14481: LD_EXP 24
14485: PPUSH
14486: LD_STRING DH-3-end
14488: PPUSH
14489: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14493: LD_EXP 25
14497: PPUSH
14498: LD_STRING DG-1-end
14500: PPUSH
14501: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14505: LD_EXP 24
14509: PPUSH
14510: LD_STRING DH-4-end
14512: PPUSH
14513: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14517: LD_EXP 32
14521: PPUSH
14522: LD_STRING DF-4-end
14524: PPUSH
14525: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14529: LD_EXP 24
14533: PPUSH
14534: LD_STRING DH-5-end
14536: PPUSH
14537: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14541: LD_EXP 32
14545: PPUSH
14546: LD_STRING DF-5-end
14548: PPUSH
14549: CALL_OW 88
// Video ( false ) ;
14553: LD_INT 0
14555: PPUSH
14556: CALL 1004 0 1
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14560: LD_ADDR_VAR 0 2
14564: PUSH
14565: LD_INT 4
14567: PUSH
14568: LD_INT 3
14570: PUSH
14571: LD_INT 2
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: LIST
14578: PUSH
14579: LD_OWVAR 67
14583: ARRAY
14584: ST_TO_ADDR
// if farmerSquad < max then
14585: LD_EXP 35
14589: PUSH
14590: LD_VAR 0 2
14594: LESS
14595: IFFALSE 14607
// max := farmerSquad ;
14597: LD_ADDR_VAR 0 2
14601: PUSH
14602: LD_EXP 35
14606: ST_TO_ADDR
// for i := 1 to max do
14607: LD_ADDR_VAR 0 1
14611: PUSH
14612: DOUBLE
14613: LD_INT 1
14615: DEC
14616: ST_TO_ADDR
14617: LD_VAR 0 2
14621: PUSH
14622: FOR_TO
14623: IFFALSE 14661
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14625: LD_EXP 35
14629: PUSH
14630: LD_INT 1
14632: ARRAY
14633: PPUSH
14634: LD_INT 2
14636: PPUSH
14637: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14641: LD_ADDR_EXP 35
14645: PUSH
14646: LD_EXP 35
14650: PPUSH
14651: LD_INT 1
14653: PPUSH
14654: CALL_OW 3
14658: ST_TO_ADDR
// end ;
14659: GO 14622
14661: POP
14662: POP
// for i in Farmer ^ farmerSquad do
14663: LD_ADDR_VAR 0 1
14667: PUSH
14668: LD_EXP 32
14672: PUSH
14673: LD_EXP 35
14677: ADD
14678: PUSH
14679: FOR_IN
14680: IFFALSE 14719
// begin if IsInUnit ( i ) then
14682: LD_VAR 0 1
14686: PPUSH
14687: CALL_OW 310
14691: IFFALSE 14702
// ComExitBuilding ( i ) ;
14693: LD_VAR 0 1
14697: PPUSH
14698: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14702: LD_VAR 0 1
14706: PPUSH
14707: LD_INT 102
14709: PPUSH
14710: LD_INT 7
14712: PPUSH
14713: CALL_OW 171
// end ;
14717: GO 14679
14719: POP
14720: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14721: LD_ADDR_VAR 0 1
14725: PUSH
14726: LD_INT 22
14728: PUSH
14729: LD_INT 5
14731: PUSH
14732: EMPTY
14733: LIST
14734: LIST
14735: PUSH
14736: LD_INT 21
14738: PUSH
14739: LD_INT 3
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: EMPTY
14747: LIST
14748: LIST
14749: PPUSH
14750: CALL_OW 69
14754: PUSH
14755: LD_INT 5
14757: DIFF
14758: PUSH
14759: FOR_IN
14760: IFFALSE 14776
// SetSide ( i , 2 ) ;
14762: LD_VAR 0 1
14766: PPUSH
14767: LD_INT 2
14769: PPUSH
14770: CALL_OW 235
14774: GO 14759
14776: POP
14777: POP
// repeat wait ( 0 0$1 ) ;
14778: LD_INT 35
14780: PPUSH
14781: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
14785: LD_ADDR_VAR 0 3
14789: PUSH
14790: LD_EXP 32
14794: PUSH
14795: LD_EXP 35
14799: ADD
14800: PPUSH
14801: LD_INT 95
14803: PUSH
14804: LD_INT 3
14806: PUSH
14807: EMPTY
14808: LIST
14809: LIST
14810: PPUSH
14811: CALL_OW 72
14815: ST_TO_ADDR
// if tmp then
14816: LD_VAR 0 3
14820: IFFALSE 14864
// for i in tmp do
14822: LD_ADDR_VAR 0 1
14826: PUSH
14827: LD_VAR 0 3
14831: PUSH
14832: FOR_IN
14833: IFFALSE 14862
// begin farmerSquad := farmerSquad diff i ;
14835: LD_ADDR_EXP 35
14839: PUSH
14840: LD_EXP 35
14844: PUSH
14845: LD_VAR 0 1
14849: DIFF
14850: ST_TO_ADDR
// RemoveUnit ( i ) ;
14851: LD_VAR 0 1
14855: PPUSH
14856: CALL_OW 64
// end ;
14860: GO 14832
14862: POP
14863: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
14864: LD_EXP 35
14868: PUSH
14869: EMPTY
14870: EQUAL
14871: PUSH
14872: LD_EXP 32
14876: PPUSH
14877: CALL_OW 305
14881: NOT
14882: AND
14883: IFFALSE 14778
// wait ( 1 1$00 ) ;
14885: LD_INT 2100
14887: PPUSH
14888: CALL_OW 67
// SendAttack ;
14892: CALL 6893 0 0
// wait ( [ 5 5$00 , 4 4$30 , 4 4$00 ] [ Difficulty ] ) ;
14896: LD_INT 10500
14898: PUSH
14899: LD_INT 9450
14901: PUSH
14902: LD_INT 8400
14904: PUSH
14905: EMPTY
14906: LIST
14907: LIST
14908: LIST
14909: PUSH
14910: LD_OWVAR 67
14914: ARRAY
14915: PPUSH
14916: CALL_OW 67
// SendAttack ;
14920: CALL 6893 0 0
// if Difficulty > 2 then
14924: LD_OWVAR 67
14928: PUSH
14929: LD_INT 2
14931: GREATER
14932: IFFALSE 14945
// begin wait ( 4 4$00 ) ;
14934: LD_INT 8400
14936: PPUSH
14937: CALL_OW 67
// SendAttack ;
14941: CALL 6893 0 0
// end ; end ;
14945: PPOPN 3
14947: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
14948: LD_EXP 14
14952: PUSH
14953: LD_INT 18900
14955: LESSEQUAL
14956: IFFALSE 15005
14958: GO 14960
14960: DISABLE
// begin DialogueOn ;
14961: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
14965: LD_EXP 32
14969: PPUSH
14970: LD_STRING DF-1-distribution-a
14972: PPUSH
14973: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
14977: LD_EXP 24
14981: PPUSH
14982: LD_STRING DH-1-distribution-a
14984: PPUSH
14985: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
14989: LD_EXP 32
14993: PPUSH
14994: LD_STRING DF-2-distribution-a
14996: PPUSH
14997: CALL_OW 94
// DialogueOff ;
15001: CALL_OW 7
// end ;
15005: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
15006: LD_EXP 14
15010: PUSH
15011: LD_INT 0
15013: LESSEQUAL
15014: IFFALSE 15046
15016: GO 15018
15018: DISABLE
// begin DialogueOn ;
15019: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
15023: LD_EXP 32
15027: PPUSH
15028: LD_STRING DF-3-distribution-a
15030: PPUSH
15031: CALL_OW 94
// YouLost ( Distribution ) ;
15035: LD_STRING Distribution
15037: PPUSH
15038: CALL_OW 104
// DialogueOff ;
15042: CALL_OW 7
// end ;
15046: END
// every 0 0$1 trigger vehCounter >= 2 do
15047: LD_EXP 18
15051: PUSH
15052: LD_INT 2
15054: GREATEREQUAL
15055: IFFALSE 15067
15057: GO 15059
15059: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
15060: LD_STRING VehConstructed
15062: PPUSH
15063: CALL_OW 337
15067: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
15068: LD_INT 22
15070: PUSH
15071: LD_INT 2
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: PUSH
15078: LD_INT 34
15080: PUSH
15081: LD_INT 12
15083: PUSH
15084: EMPTY
15085: LIST
15086: LIST
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: PPUSH
15092: CALL_OW 69
15096: IFFALSE 15156
15098: GO 15100
15100: DISABLE
// begin DialogueOn ;
15101: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
15105: LD_EXP 24
15109: PPUSH
15110: LD_STRING DH-1-truck
15112: PPUSH
15113: CALL_OW 88
// if IsOk ( Markov ) then
15117: LD_EXP 31
15121: PPUSH
15122: CALL_OW 302
15126: IFFALSE 15152
// begin Say ( Markov , DMar-1-truck ) ;
15128: LD_EXP 31
15132: PPUSH
15133: LD_STRING DMar-1-truck
15135: PPUSH
15136: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
15140: LD_EXP 24
15144: PPUSH
15145: LD_STRING DH-2-truck
15147: PPUSH
15148: CALL_OW 88
// end ; DialogueOff ;
15152: CALL_OW 7
// end ;
15156: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
15157: LD_INT 0
15159: PPUSH
15160: PPUSH
15161: PPUSH
// if IsOk ( Givi ) then
15162: LD_EXP 25
15166: PPUSH
15167: CALL_OW 302
15171: IFFALSE 15187
// begin Say ( Givi , DG-1-nocargo ) ;
15173: LD_EXP 25
15177: PPUSH
15178: LD_STRING DG-1-nocargo
15180: PPUSH
15181: CALL_OW 88
// exit ;
15185: GO 15283
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15187: LD_ADDR_VAR 0 2
15191: PUSH
15192: LD_EXP 38
15196: PPUSH
15197: LD_INT 26
15199: PUSH
15200: LD_INT 1
15202: PUSH
15203: EMPTY
15204: LIST
15205: LIST
15206: PPUSH
15207: CALL_OW 72
15211: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15212: LD_ADDR_VAR 0 3
15216: PUSH
15217: LD_EXP 38
15221: PPUSH
15222: LD_INT 26
15224: PUSH
15225: LD_INT 2
15227: PUSH
15228: EMPTY
15229: LIST
15230: LIST
15231: PPUSH
15232: CALL_OW 72
15236: ST_TO_ADDR
// if randomMen then
15237: LD_VAR 0 2
15241: IFFALSE 15261
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15243: LD_VAR 0 2
15247: PUSH
15248: LD_INT 1
15250: ARRAY
15251: PPUSH
15252: LD_STRING DArm-1-nocargo
15254: PPUSH
15255: CALL_OW 88
15259: GO 15283
// if randomWomen then
15261: LD_VAR 0 3
15265: IFFALSE 15283
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15267: LD_VAR 0 3
15271: PUSH
15272: LD_INT 1
15274: ARRAY
15275: PPUSH
15276: LD_STRING DArf-1-nocargo
15278: PPUSH
15279: CALL_OW 88
// end ;
15283: LD_VAR 0 1
15287: RET
// export function IncomingAttack ; begin
15288: LD_INT 0
15290: PPUSH
// if attackWave = 1 then
15291: LD_EXP 16
15295: PUSH
15296: LD_INT 1
15298: EQUAL
15299: IFFALSE 15370
// begin DialogueOn ;
15301: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15305: LD_EXP 33
15309: PPUSH
15310: LD_STRING DO-1-radio-1
15312: PPUSH
15313: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15317: LD_EXP 24
15321: PPUSH
15322: LD_STRING DH-1-radio-1-
15324: PPUSH
15325: CALL_OW 88
// if IsOk ( Markov ) then
15329: LD_EXP 31
15333: PPUSH
15334: CALL_OW 302
15338: IFFALSE 15364
// begin Say ( Markov , DMar-1-radio-1 ) ;
15340: LD_EXP 31
15344: PPUSH
15345: LD_STRING DMar-1-radio-1
15347: PPUSH
15348: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15352: LD_EXP 24
15356: PPUSH
15357: LD_STRING DH-2-radio-1
15359: PPUSH
15360: CALL_OW 88
// end ; DialogueOff ;
15364: CALL_OW 7
// end else
15368: GO 15394
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15370: LD_EXP 33
15374: PPUSH
15375: LD_STRING DO-1-radio-u
15377: PPUSH
15378: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15382: LD_EXP 24
15386: PPUSH
15387: LD_STRING DH-1-radio-u
15389: PPUSH
15390: CALL_OW 88
// end ; end ;
15394: LD_VAR 0 1
15398: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15399: LD_EXP 40
15403: PPUSH
15404: LD_INT 95
15406: PUSH
15407: LD_INT 8
15409: PUSH
15410: EMPTY
15411: LIST
15412: LIST
15413: PPUSH
15414: CALL_OW 72
15418: IFFALSE 15521
15420: GO 15422
15422: DISABLE
15423: LD_INT 0
15425: PPUSH
// begin enable ;
15426: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15427: LD_ADDR_VAR 0 1
15431: PUSH
15432: LD_EXP 40
15436: PPUSH
15437: LD_INT 95
15439: PUSH
15440: LD_INT 8
15442: PUSH
15443: EMPTY
15444: LIST
15445: LIST
15446: PPUSH
15447: CALL_OW 72
15451: PUSH
15452: FOR_IN
15453: IFFALSE 15482
// begin usForces := usForces diff i ;
15455: LD_ADDR_EXP 40
15459: PUSH
15460: LD_EXP 40
15464: PUSH
15465: LD_VAR 0 1
15469: DIFF
15470: ST_TO_ADDR
// RemoveUnit ( i ) ;
15471: LD_VAR 0 1
15475: PPUSH
15476: CALL_OW 64
// end ;
15480: GO 15452
15482: POP
15483: POP
// if not americanHasEscaped and attackWave = 1 then
15484: LD_EXP 7
15488: NOT
15489: PUSH
15490: LD_EXP 16
15494: PUSH
15495: LD_INT 1
15497: EQUAL
15498: AND
15499: IFFALSE 15521
// begin americanHasEscaped := true ;
15501: LD_ADDR_EXP 7
15505: PUSH
15506: LD_INT 1
15508: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15509: LD_EXP 24
15513: PPUSH
15514: LD_STRING DH-2-assault-a
15516: PPUSH
15517: CALL_OW 88
// end ; end ;
15521: PPOPN 1
15523: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) do
15524: LD_INT 4
15526: PPUSH
15527: LD_INT 22
15529: PUSH
15530: LD_INT 1
15532: PUSH
15533: EMPTY
15534: LIST
15535: LIST
15536: PPUSH
15537: CALL_OW 70
15541: IFFALSE 15558
15543: GO 15545
15545: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15546: LD_EXP 32
15550: PPUSH
15551: LD_STRING DF-1-attack
15553: PPUSH
15554: CALL_OW 94
15558: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15559: LD_INT 5
15561: PPUSH
15562: CALL_OW 255
15566: PUSH
15567: LD_INT 2
15569: EQUAL
15570: IFFALSE 15582
15572: GO 15574
15574: DISABLE
// YouLost ( Attack ) ;
15575: LD_STRING Attack
15577: PPUSH
15578: CALL_OW 104
15582: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 90 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot ;
15583: LD_INT 22
15585: PUSH
15586: LD_INT 1
15588: PUSH
15589: EMPTY
15590: LIST
15591: LIST
15592: PUSH
15593: LD_INT 21
15595: PUSH
15596: LD_INT 1
15598: PUSH
15599: EMPTY
15600: LIST
15601: LIST
15602: PUSH
15603: EMPTY
15604: LIST
15605: LIST
15606: PPUSH
15607: CALL_OW 69
15611: NOT
15612: PUSH
15613: LD_INT 22
15615: PUSH
15616: LD_INT 4
15618: PUSH
15619: EMPTY
15620: LIST
15621: LIST
15622: PPUSH
15623: CALL_OW 69
15627: NOT
15628: AND
15629: PUSH
15630: LD_EXP 10
15634: NOT
15635: AND
15636: PUSH
15637: LD_EXP 12
15641: PUSH
15642: LD_INT 90
15644: GREATER
15645: AND
15646: PUSH
15647: LD_INT 7
15649: PPUSH
15650: LD_INT 22
15652: PUSH
15653: LD_INT 2
15655: PUSH
15656: EMPTY
15657: LIST
15658: LIST
15659: PUSH
15660: LD_INT 21
15662: PUSH
15663: LD_INT 1
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: PPUSH
15674: CALL_OW 70
15678: AND
15679: PUSH
15680: LD_INT 22
15682: PUSH
15683: LD_INT 2
15685: PUSH
15686: EMPTY
15687: LIST
15688: LIST
15689: PUSH
15690: LD_INT 50
15692: PUSH
15693: EMPTY
15694: LIST
15695: PUSH
15696: LD_INT 30
15698: PUSH
15699: LD_INT 0
15701: PUSH
15702: EMPTY
15703: LIST
15704: LIST
15705: PUSH
15706: EMPTY
15707: LIST
15708: LIST
15709: LIST
15710: PPUSH
15711: CALL_OW 69
15715: AND
15716: IFFALSE 16373
15718: GO 15720
15720: DISABLE
15721: LD_INT 0
15723: PPUSH
15724: PPUSH
15725: PPUSH
15726: PPUSH
15727: PPUSH
// begin depot := usDepot ;
15728: LD_ADDR_VAR 0 5
15732: PUSH
15733: LD_INT 11
15735: ST_TO_ADDR
// if not depot then
15736: LD_VAR 0 5
15740: NOT
15741: IFFALSE 15781
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
15743: LD_ADDR_VAR 0 5
15747: PUSH
15748: LD_INT 22
15750: PUSH
15751: LD_INT 2
15753: PUSH
15754: EMPTY
15755: LIST
15756: LIST
15757: PUSH
15758: LD_INT 30
15760: PUSH
15761: LD_INT 0
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PPUSH
15772: CALL_OW 69
15776: PUSH
15777: LD_INT 1
15779: ARRAY
15780: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15781: LD_ADDR_VAR 0 1
15785: PUSH
15786: LD_EXP 38
15790: PPUSH
15791: LD_INT 26
15793: PUSH
15794: LD_INT 1
15796: PUSH
15797: EMPTY
15798: LIST
15799: LIST
15800: PPUSH
15801: CALL_OW 72
15805: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15806: LD_ADDR_VAR 0 2
15810: PUSH
15811: LD_EXP 38
15815: PPUSH
15816: LD_INT 26
15818: PUSH
15819: LD_INT 2
15821: PUSH
15822: EMPTY
15823: LIST
15824: LIST
15825: PPUSH
15826: CALL_OW 72
15830: ST_TO_ADDR
// if IsOk ( Kaia ) then
15831: LD_EXP 29
15835: PPUSH
15836: CALL_OW 302
15840: IFFALSE 15861
// speaker := [ Kaia , DK ] else
15842: LD_ADDR_VAR 0 3
15846: PUSH
15847: LD_EXP 29
15851: PUSH
15852: LD_STRING DK
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: ST_TO_ADDR
15859: GO 15941
// if randomMen then
15861: LD_VAR 0 1
15865: IFFALSE 15900
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
15867: LD_ADDR_VAR 0 3
15871: PUSH
15872: LD_VAR 0 1
15876: PUSH
15877: LD_INT 1
15879: PPUSH
15880: LD_VAR 0 1
15884: PPUSH
15885: CALL_OW 12
15889: ARRAY
15890: PUSH
15891: LD_STRING DArm
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: ST_TO_ADDR
15898: GO 15941
// if randomWomen then
15900: LD_VAR 0 2
15904: IFFALSE 15939
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
15906: LD_ADDR_VAR 0 3
15910: PUSH
15911: LD_VAR 0 2
15915: PUSH
15916: LD_INT 1
15918: PPUSH
15919: LD_VAR 0 2
15923: PPUSH
15924: CALL_OW 12
15928: ARRAY
15929: PUSH
15930: LD_STRING DArf
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: ST_TO_ADDR
15937: GO 15941
// exit ;
15939: GO 16373
// if IsInUnit ( speaker [ 1 ] ) then
15941: LD_VAR 0 3
15945: PUSH
15946: LD_INT 1
15948: ARRAY
15949: PPUSH
15950: CALL_OW 310
15954: IFFALSE 15977
// place := IsInUnit ( speaker [ 1 ] ) else
15956: LD_ADDR_VAR 0 4
15960: PUSH
15961: LD_VAR 0 3
15965: PUSH
15966: LD_INT 1
15968: ARRAY
15969: PPUSH
15970: CALL_OW 310
15974: ST_TO_ADDR
15975: GO 15991
// place := speaker [ 1 ] ;
15977: LD_ADDR_VAR 0 4
15981: PUSH
15982: LD_VAR 0 3
15986: PUSH
15987: LD_INT 1
15989: ARRAY
15990: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
15991: LD_VAR 0 4
15995: PPUSH
15996: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
16000: LD_VAR 0 4
16004: PPUSH
16005: CALL_OW 250
16009: PPUSH
16010: LD_VAR 0 4
16014: PPUSH
16015: CALL_OW 251
16019: PPUSH
16020: CALL 3005 0 2
// wait ( 0 0$2 ) ;
16024: LD_INT 70
16026: PPUSH
16027: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
16031: LD_EXP 34
16035: PPUSH
16036: CALL_OW 305
16040: NOT
16041: IFFALSE 16045
// exit ;
16043: GO 16373
// allowConvoys := false ;
16045: LD_ADDR_EXP 11
16049: PUSH
16050: LD_INT 0
16052: ST_TO_ADDR
// InGameOn ;
16053: CALL_OW 8
// wait ( 0 0$1 ) ;
16057: LD_INT 35
16059: PPUSH
16060: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
16064: LD_EXP 34
16068: PPUSH
16069: LD_STRING DI-1-land
16071: PPUSH
16072: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
16076: LD_VAR 0 3
16080: PUSH
16081: LD_INT 1
16083: ARRAY
16084: PPUSH
16085: CALL_OW 310
16089: IFFALSE 16104
// ComExit ( speaker [ 1 ] ) ;
16091: LD_VAR 0 3
16095: PUSH
16096: LD_INT 1
16098: ARRAY
16099: PPUSH
16100: CALL 1108 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
16104: LD_VAR 0 3
16108: PUSH
16109: LD_INT 1
16111: ARRAY
16112: PPUSH
16113: LD_EXP 34
16117: PPUSH
16118: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
16122: LD_VAR 0 3
16126: PUSH
16127: LD_INT 1
16129: ARRAY
16130: PPUSH
16131: LD_EXP 34
16135: PPUSH
16136: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
16140: LD_EXP 34
16144: PPUSH
16145: LD_VAR 0 3
16149: PUSH
16150: LD_INT 1
16152: ARRAY
16153: PPUSH
16154: CALL_OW 119
// wait ( 0 0$1 ) ;
16158: LD_INT 35
16160: PPUSH
16161: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
16165: LD_VAR 0 3
16169: PUSH
16170: LD_INT 1
16172: ARRAY
16173: PPUSH
16174: LD_VAR 0 3
16178: PUSH
16179: LD_INT 2
16181: ARRAY
16182: PUSH
16183: LD_STRING -1-land
16185: STR
16186: PPUSH
16187: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16191: LD_EXP 34
16195: PPUSH
16196: LD_STRING DI-2-land
16198: PPUSH
16199: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16203: LD_VAR 0 3
16207: PUSH
16208: LD_INT 1
16210: ARRAY
16211: PPUSH
16212: LD_VAR 0 3
16216: PUSH
16217: LD_INT 2
16219: ARRAY
16220: PUSH
16221: LD_STRING -2-land
16223: STR
16224: PPUSH
16225: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16229: LD_VAR 0 3
16233: PUSH
16234: LD_INT 1
16236: ARRAY
16237: PPUSH
16238: LD_VAR 0 3
16242: PUSH
16243: LD_INT 2
16245: ARRAY
16246: PUSH
16247: LD_STRING -3-land
16249: STR
16250: PPUSH
16251: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16255: LD_EXP 24
16259: PPUSH
16260: LD_STRING DH-1-land
16262: PPUSH
16263: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16267: LD_VAR 0 5
16271: PPUSH
16272: CALL_OW 313
16276: PUSH
16277: LD_INT 6
16279: EQUAL
16280: IFFALSE 16300
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16282: LD_VAR 0 5
16286: PPUSH
16287: CALL_OW 313
16291: PUSH
16292: LD_INT 1
16294: ARRAY
16295: PPUSH
16296: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16300: LD_EXP 34
16304: PPUSH
16305: LD_INT 2
16307: PPUSH
16308: CALL_OW 235
// CenterOnUnits ( depot ) ;
16312: LD_VAR 0 5
16316: PPUSH
16317: CALL_OW 85
// ComEnterUnit ( Ibrahim , depot ) ;
16321: LD_EXP 34
16325: PPUSH
16326: LD_VAR 0 5
16330: PPUSH
16331: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
16335: LD_INT 35
16337: PPUSH
16338: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
16342: LD_EXP 34
16346: PPUSH
16347: CALL_OW 310
16351: IFFALSE 16335
// InGameOff ;
16353: CALL_OW 9
// ibrahimInDepot := true ;
16357: LD_ADDR_EXP 21
16361: PUSH
16362: LD_INT 1
16364: ST_TO_ADDR
// allowConvoys := true ;
16365: LD_ADDR_EXP 11
16369: PUSH
16370: LD_INT 1
16372: ST_TO_ADDR
// end ;
16373: PPOPN 5
16375: END
// export function IbrahimQuery ; begin
16376: LD_INT 0
16378: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16379: LD_STRING IbrahimQuery
16381: PPUSH
16382: CALL_OW 97
16386: PUSH
16387: LD_INT 1
16389: DOUBLE
16390: EQUAL
16391: IFTRUE 16395
16393: GO 16704
16395: POP
// begin allowConvoys := false ;
16396: LD_ADDR_EXP 11
16400: PUSH
16401: LD_INT 0
16403: ST_TO_ADDR
// ibrahimInDepot := false ;
16404: LD_ADDR_EXP 21
16408: PUSH
16409: LD_INT 0
16411: ST_TO_ADDR
// InGameOn ;
16412: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16416: LD_EXP 24
16420: PPUSH
16421: CALL_OW 87
// wait ( 0 0$1 ) ;
16425: LD_INT 35
16427: PPUSH
16428: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16432: LD_EXP 24
16436: PPUSH
16437: LD_STRING DH-1-interrogation
16439: PPUSH
16440: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16444: LD_EXP 34
16448: PPUSH
16449: LD_STRING DI-1-interrogation
16451: PPUSH
16452: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16456: LD_EXP 24
16460: PPUSH
16461: LD_STRING DH-2-interrogation
16463: PPUSH
16464: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16468: LD_EXP 34
16472: PPUSH
16473: LD_STRING DI-2-interrogation
16475: PPUSH
16476: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16480: LD_EXP 24
16484: PPUSH
16485: LD_STRING DH-3-interrogation
16487: PPUSH
16488: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16492: LD_EXP 34
16496: PPUSH
16497: LD_STRING DI-3-interrogation
16499: PPUSH
16500: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16504: LD_EXP 24
16508: PPUSH
16509: LD_STRING DH-4-interrogation
16511: PPUSH
16512: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16516: LD_EXP 34
16520: PPUSH
16521: LD_STRING DI-4-interrogation
16523: PPUSH
16524: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16528: LD_EXP 24
16532: PPUSH
16533: LD_STRING DH-5-interrogation
16535: PPUSH
16536: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16540: LD_EXP 34
16544: PPUSH
16545: LD_STRING DI-5-interrogation
16547: PPUSH
16548: CALL_OW 88
// wait ( 0 0$1 ) ;
16552: LD_INT 35
16554: PPUSH
16555: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16559: LD_STRING IbrahimDecisionQuery
16561: PPUSH
16562: CALL_OW 97
16566: PUSH
16567: LD_INT 1
16569: DOUBLE
16570: EQUAL
16571: IFTRUE 16575
16573: GO 16599
16575: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16576: LD_EXP 34
16580: PPUSH
16581: LD_STRING DI-1-kill
16583: PPUSH
16584: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16588: LD_EXP 34
16592: PPUSH
16593: CALL_OW 66
// end ; 2 :
16597: GO 16698
16599: LD_INT 2
16601: DOUBLE
16602: EQUAL
16603: IFTRUE 16607
16605: GO 16697
16607: POP
// begin SetSide ( Ibrahim , 6 ) ;
16608: LD_EXP 34
16612: PPUSH
16613: LD_INT 6
16615: PPUSH
16616: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16620: LD_EXP 34
16624: PPUSH
16625: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16629: LD_EXP 34
16633: PPUSH
16634: LD_INT 32
16636: PPUSH
16637: LD_INT 5
16639: PPUSH
16640: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16644: LD_EXP 24
16648: PPUSH
16649: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16653: LD_EXP 24
16657: PPUSH
16658: LD_INT 36
16660: PPUSH
16661: LD_INT 21
16663: PPUSH
16664: CALL_OW 171
// AddComWait ( Ibrahim , 1 1$20 ) ;
16668: LD_EXP 34
16672: PPUSH
16673: LD_INT 2800
16675: PPUSH
16676: CALL_OW 202
// AddComMoveXY ( Ibrahim , 38 , 28 ) ;
16680: LD_EXP 34
16684: PPUSH
16685: LD_INT 38
16687: PPUSH
16688: LD_INT 28
16690: PPUSH
16691: CALL_OW 171
// end ; end ;
16695: GO 16698
16697: POP
// InGameOff ;
16698: CALL_OW 9
// end ; 2 :
16702: GO 16718
16704: LD_INT 2
16706: DOUBLE
16707: EQUAL
16708: IFTRUE 16712
16710: GO 16717
16712: POP
// exit ; end ;
16713: GO 16741
16715: GO 16718
16717: POP
// allowConvoys := true ;
16718: LD_ADDR_EXP 11
16722: PUSH
16723: LD_INT 1
16725: ST_TO_ADDR
// wait ( 0 0$40 ) ;
16726: LD_INT 1400
16728: PPUSH
16729: CALL_OW 67
// ibrahimIsFree := true ;
16733: LD_ADDR_EXP 22
16737: PUSH
16738: LD_INT 1
16740: ST_TO_ADDR
// end ;
16741: LD_VAR 0 1
16745: RET
// every 0 0$10 trigger ibrahimIsFree and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b , p , depot ;
16746: LD_EXP 22
16750: PUSH
16751: LD_INT 22
16753: PUSH
16754: LD_INT 2
16756: PUSH
16757: EMPTY
16758: LIST
16759: LIST
16760: PUSH
16761: LD_INT 50
16763: PUSH
16764: EMPTY
16765: LIST
16766: PUSH
16767: LD_INT 30
16769: PUSH
16770: LD_INT 0
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: PUSH
16777: EMPTY
16778: LIST
16779: LIST
16780: LIST
16781: PPUSH
16782: CALL_OW 69
16786: AND
16787: PUSH
16788: LD_EXP 34
16792: PPUSH
16793: LD_INT 7
16795: PPUSH
16796: CALL_OW 308
16800: AND
16801: PUSH
16802: LD_INT 6
16804: PPUSH
16805: LD_EXP 24
16809: PPUSH
16810: CALL_OW 292
16814: AND
16815: PUSH
16816: LD_INT 22
16818: PUSH
16819: LD_INT 4
16821: PUSH
16822: EMPTY
16823: LIST
16824: LIST
16825: PPUSH
16826: CALL_OW 69
16830: NOT
16831: AND
16832: PUSH
16833: LD_INT 22
16835: PUSH
16836: LD_INT 1
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PUSH
16843: LD_INT 21
16845: PUSH
16846: LD_INT 1
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PPUSH
16857: CALL_OW 69
16861: NOT
16862: AND
16863: IFFALSE 17511
16865: GO 16867
16867: DISABLE
16868: LD_INT 0
16870: PPUSH
16871: PPUSH
16872: PPUSH
16873: PPUSH
// begin allowConvoys := false ;
16874: LD_ADDR_EXP 11
16878: PUSH
16879: LD_INT 0
16881: ST_TO_ADDR
// depot := usDepot ;
16882: LD_ADDR_VAR 0 4
16886: PUSH
16887: LD_INT 11
16889: ST_TO_ADDR
// if not usDepot then
16890: LD_INT 11
16892: NOT
16893: IFFALSE 16940
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
16895: LD_ADDR_VAR 0 4
16899: PUSH
16900: LD_INT 22
16902: PUSH
16903: LD_INT 2
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: LD_INT 50
16912: PUSH
16913: EMPTY
16914: LIST
16915: PUSH
16916: LD_INT 30
16918: PUSH
16919: LD_INT 0
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: PUSH
16926: EMPTY
16927: LIST
16928: LIST
16929: LIST
16930: PPUSH
16931: CALL_OW 69
16935: PUSH
16936: LD_INT 1
16938: ARRAY
16939: ST_TO_ADDR
// InGameOn ;
16940: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
16944: LD_EXP 34
16948: PPUSH
16949: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
16953: LD_EXP 24
16957: PPUSH
16958: LD_EXP 34
16962: PPUSH
16963: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
16967: LD_EXP 34
16971: PPUSH
16972: LD_EXP 24
16976: PPUSH
16977: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
16981: LD_EXP 34
16985: PPUSH
16986: LD_STRING DI-1-free
16988: PPUSH
16989: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
16993: LD_EXP 24
16997: PPUSH
16998: LD_STRING DH-1-free
17000: PPUSH
17001: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
17005: LD_EXP 34
17009: PPUSH
17010: LD_STRING DI-2-free
17012: PPUSH
17013: CALL_OW 88
// changeClass := 0 ;
17017: LD_ADDR_VAR 0 1
17021: PUSH
17022: LD_INT 0
17024: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
17025: LD_STRING IbrahimJoinQuery
17027: PPUSH
17028: CALL_OW 97
17032: PUSH
17033: LD_INT 1
17035: DOUBLE
17036: EQUAL
17037: IFTRUE 17041
17039: GO 17052
17041: POP
// begin changeClass := 1 ;
17042: LD_ADDR_VAR 0 1
17046: PUSH
17047: LD_INT 1
17049: ST_TO_ADDR
// end ; 2 :
17050: GO 17292
17052: LD_INT 2
17054: DOUBLE
17055: EQUAL
17056: IFTRUE 17060
17058: GO 17212
17060: POP
// begin Say ( Heike , DH-1-decline ) ;
17061: LD_EXP 24
17065: PPUSH
17066: LD_STRING DH-1-decline
17068: PPUSH
17069: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
17073: LD_EXP 34
17077: PPUSH
17078: LD_STRING DI-1-decline
17080: PPUSH
17081: CALL_OW 88
// InGameOff ;
17085: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
17089: LD_EXP 34
17093: PPUSH
17094: LD_INT 30
17096: PPUSH
17097: LD_INT 1
17099: PPUSH
17100: CALL_OW 111
// p := 0 ;
17104: LD_ADDR_VAR 0 3
17108: PUSH
17109: LD_INT 0
17111: ST_TO_ADDR
// repeat p := p + 1 ;
17112: LD_ADDR_VAR 0 3
17116: PUSH
17117: LD_VAR 0 3
17121: PUSH
17122: LD_INT 1
17124: PLUS
17125: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17126: LD_INT 35
17128: PPUSH
17129: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) or p > 10 ;
17133: LD_EXP 34
17137: PPUSH
17138: LD_INT 30
17140: PPUSH
17141: LD_INT 1
17143: PPUSH
17144: CALL_OW 307
17148: PUSH
17149: LD_INT 22
17151: PUSH
17152: LD_INT 2
17154: PUSH
17155: EMPTY
17156: LIST
17157: LIST
17158: PUSH
17159: LD_INT 101
17161: PUSH
17162: LD_INT 6
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: PUSH
17169: EMPTY
17170: LIST
17171: LIST
17172: PPUSH
17173: CALL_OW 69
17177: NOT
17178: OR
17179: PUSH
17180: LD_VAR 0 3
17184: PUSH
17185: LD_INT 10
17187: GREATER
17188: OR
17189: IFFALSE 17112
// RemoveUnit ( Ibrahim ) ;
17191: LD_EXP 34
17195: PPUSH
17196: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17200: LD_INT 1
17202: PPUSH
17203: LD_STRING 03_IbrahimHasEscaped
17205: PPUSH
17206: CALL_OW 39
// end ; 3 :
17210: GO 17292
17212: LD_INT 3
17214: DOUBLE
17215: EQUAL
17216: IFTRUE 17220
17218: GO 17291
17220: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17221: LD_EXP 24
17225: PPUSH
17226: LD_STRING DH-1-radio-hq
17228: PPUSH
17229: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17233: LD_EXP 33
17237: PPUSH
17238: LD_STRING DO-1-radio-hq
17240: PPUSH
17241: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17245: LD_EXP 24
17249: PPUSH
17250: LD_STRING DH-2-radio-hq
17252: PPUSH
17253: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17257: LD_EXP 33
17261: PPUSH
17262: LD_STRING DO-2-radio-hq
17264: PPUSH
17265: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17269: LD_EXP 24
17273: PPUSH
17274: LD_STRING DH-3-radio-hq
17276: PPUSH
17277: CALL_OW 88
// changeClass := 1 ;
17281: LD_ADDR_VAR 0 1
17285: PUSH
17286: LD_INT 1
17288: ST_TO_ADDR
// end ; end ;
17289: GO 17292
17291: POP
// if changeClass then
17292: LD_VAR 0 1
17296: IFFALSE 17511
// begin Say ( Heike , DH-1-agree ) ;
17298: LD_EXP 24
17302: PPUSH
17303: LD_STRING DH-1-agree
17305: PPUSH
17306: CALL_OW 88
// if IsOk ( Givi ) then
17310: LD_EXP 25
17314: PPUSH
17315: CALL_OW 302
17319: IFFALSE 17357
// begin Say ( Givi , DG-1-agree ) ;
17321: LD_EXP 25
17325: PPUSH
17326: LD_STRING DG-1-agree
17328: PPUSH
17329: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17333: LD_EXP 24
17337: PPUSH
17338: LD_STRING DH-2-agree
17340: PPUSH
17341: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17345: LD_EXP 25
17349: PPUSH
17350: LD_STRING DG-2-agree
17352: PPUSH
17353: CALL_OW 88
// end ; if UnitsInside ( depot ) = 6 then
17357: LD_VAR 0 4
17361: PPUSH
17362: CALL_OW 313
17366: PUSH
17367: LD_INT 6
17369: EQUAL
17370: IFFALSE 17390
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
17372: LD_VAR 0 4
17376: PPUSH
17377: CALL_OW 313
17381: PUSH
17382: LD_INT 1
17384: ARRAY
17385: PPUSH
17386: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17390: LD_EXP 34
17394: PPUSH
17395: LD_INT 2
17397: PPUSH
17398: CALL_OW 235
// ComEnterUnit ( Ibrahim , depot ) ;
17402: LD_EXP 34
17406: PPUSH
17407: LD_VAR 0 4
17411: PPUSH
17412: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17416: LD_INT 35
17418: PPUSH
17419: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17423: LD_EXP 34
17427: PPUSH
17428: CALL_OW 310
17432: IFFALSE 17416
// b := IsInUnit ( Ibrahim ) ;
17434: LD_ADDR_VAR 0 2
17438: PUSH
17439: LD_EXP 34
17443: PPUSH
17444: CALL_OW 310
17448: ST_TO_ADDR
// RemoveUnit ( Ibrahim ) ;
17449: LD_EXP 34
17453: PPUSH
17454: CALL_OW 64
// uc_side := 2 ;
17458: LD_ADDR_OWVAR 20
17462: PUSH
17463: LD_INT 2
17465: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17466: LD_ADDR_EXP 34
17470: PUSH
17471: LD_STRING Ibrahim
17473: PPUSH
17474: LD_INT 0
17476: PPUSH
17477: LD_STRING 
17479: PPUSH
17480: CALL 281 0 3
17484: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , b ) ;
17485: LD_EXP 34
17489: PPUSH
17490: LD_VAR 0 2
17494: PPUSH
17495: CALL_OW 52
// InGameOff ;
17499: CALL_OW 9
// allowConvoys := true ;
17503: LD_ADDR_EXP 11
17507: PUSH
17508: LD_INT 1
17510: ST_TO_ADDR
// end ; end ;
17511: PPOPN 4
17513: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 do
17514: LD_EXP 10
17518: PUSH
17519: LD_EXP 17
17523: PUSH
17524: LD_INT 1
17526: LESS
17527: AND
17528: IFFALSE 17919
17530: GO 17532
17532: DISABLE
// begin DialogueOn ;
17533: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
17537: LD_EXP 24
17541: PPUSH
17542: LD_STRING DH-1-final
17544: PPUSH
17545: CALL_OW 88
// if tick <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
17549: LD_OWVAR 1
17553: PUSH
17554: LD_INT 126000
17556: PUSH
17557: LD_INT 115500
17559: PUSH
17560: LD_INT 105000
17562: PUSH
17563: EMPTY
17564: LIST
17565: LIST
17566: LIST
17567: PUSH
17568: LD_OWVAR 67
17572: ARRAY
17573: LESSEQUAL
17574: IFFALSE 17588
// AddMedal ( med1 , 1 ) else
17576: LD_STRING med1
17578: PPUSH
17579: LD_INT 1
17581: PPUSH
17582: CALL_OW 101
17586: GO 17599
// AddMedal ( med1 , - 1 ) ;
17588: LD_STRING med1
17590: PPUSH
17591: LD_INT 1
17593: NEG
17594: PPUSH
17595: CALL_OW 101
// if vehCounter >= 2 then
17599: LD_EXP 18
17603: PUSH
17604: LD_INT 2
17606: GREATEREQUAL
17607: IFFALSE 17621
// AddMedal ( med2 , 1 ) else
17609: LD_STRING med2
17611: PPUSH
17612: LD_INT 1
17614: PPUSH
17615: CALL_OW 101
17619: GO 17632
// AddMedal ( med2 , - 1 ) ;
17621: LD_STRING med2
17623: PPUSH
17624: LD_INT 1
17626: NEG
17627: PPUSH
17628: CALL_OW 101
// if deadCounter = 0 then
17632: LD_EXP 8
17636: PUSH
17637: LD_INT 0
17639: EQUAL
17640: IFFALSE 17654
// AddMedal ( med3 , 1 ) else
17642: LD_STRING med3
17644: PPUSH
17645: LD_INT 1
17647: PPUSH
17648: CALL_OW 101
17652: GO 17665
// AddMedal ( med3 , - 1 ) ;
17654: LD_STRING med3
17656: PPUSH
17657: LD_INT 1
17659: NEG
17660: PPUSH
17661: CALL_OW 101
// GiveMedals ( MAIN ) ;
17665: LD_STRING MAIN
17667: PPUSH
17668: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
17672: LD_INT 22
17674: PUSH
17675: LD_INT 2
17677: PUSH
17678: EMPTY
17679: LIST
17680: LIST
17681: PUSH
17682: LD_INT 23
17684: PUSH
17685: LD_INT 2
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: PUSH
17692: LD_INT 21
17694: PUSH
17695: LD_INT 1
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: PUSH
17702: EMPTY
17703: LIST
17704: LIST
17705: LIST
17706: PPUSH
17707: CALL_OW 69
17711: PPUSH
17712: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
17716: LD_EXP 24
17720: PPUSH
17721: LD_STRING 03_Heike
17723: PPUSH
17724: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
17728: LD_EXP 28
17732: PPUSH
17733: LD_STRING 03_Aviradze
17735: PPUSH
17736: CALL_OW 38
// if Givi then
17740: LD_EXP 25
17744: IFFALSE 17758
// SaveCharacters ( Givi , 03_Givi ) ;
17746: LD_EXP 25
17750: PPUSH
17751: LD_STRING 03_Givi
17753: PPUSH
17754: CALL_OW 38
// if Mike then
17758: LD_EXP 26
17762: IFFALSE 17776
// SaveCharacters ( Mike , 03_Mike ) ;
17764: LD_EXP 26
17768: PPUSH
17769: LD_STRING 03_Mike
17771: PPUSH
17772: CALL_OW 38
// if Kamil then
17776: LD_EXP 27
17780: IFFALSE 17794
// SaveCharacters ( Kamil , 03_Kamil ) ;
17782: LD_EXP 27
17786: PPUSH
17787: LD_STRING 03_Kamil
17789: PPUSH
17790: CALL_OW 38
// if Kaia then
17794: LD_EXP 29
17798: IFFALSE 17812
// SaveCharacters ( Kaia , 03_Kaia ) ;
17800: LD_EXP 29
17804: PPUSH
17805: LD_STRING 03_Kaia
17807: PPUSH
17808: CALL_OW 38
// if Sophia then
17812: LD_EXP 30
17816: IFFALSE 17830
// SaveCharacters ( Sophia , 03_Sophia ) ;
17818: LD_EXP 30
17822: PPUSH
17823: LD_STRING 03_Sophia
17825: PPUSH
17826: CALL_OW 38
// if Markov then
17830: LD_EXP 31
17834: IFFALSE 17848
// SaveCharacters ( Markov , 03_Markov ) ;
17836: LD_EXP 31
17840: PPUSH
17841: LD_STRING 03_Markov
17843: PPUSH
17844: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
17848: LD_EXP 34
17852: PUSH
17853: LD_EXP 34
17857: PPUSH
17858: CALL_OW 255
17862: PUSH
17863: LD_INT 2
17865: EQUAL
17866: AND
17867: IFFALSE 17881
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
17869: LD_EXP 34
17873: PPUSH
17874: LD_STRING 03_Ibrahim
17876: PPUSH
17877: CALL_OW 38
// if heikeSecondSquad then
17881: LD_EXP 38
17885: IFFALSE 17899
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
17887: LD_EXP 38
17891: PPUSH
17892: LD_STRING 03_others
17894: PPUSH
17895: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
17899: LD_EXP 8
17903: PPUSH
17904: LD_STRING 03_DeadCounter
17906: PPUSH
17907: CALL_OW 39
// YouWin ;
17911: CALL_OW 103
// DialogueOff ;
17915: CALL_OW 7
// end ; end_of_file
17919: END
// on UnitDestroyed ( un ) do begin if un = Heike then
17920: LD_VAR 0 1
17924: PUSH
17925: LD_EXP 24
17929: EQUAL
17930: IFFALSE 17939
// YouLost ( Heike ) ;
17932: LD_STRING Heike
17934: PPUSH
17935: CALL_OW 104
// if un = Aviradze then
17939: LD_VAR 0 1
17943: PUSH
17944: LD_EXP 28
17948: EQUAL
17949: IFFALSE 17958
// YouLost ( Aviradze ) ;
17951: LD_STRING Aviradze
17953: PPUSH
17954: CALL_OW 104
// if un = usDepot and not retreatAllowed then
17958: LD_VAR 0 1
17962: PUSH
17963: LD_INT 11
17965: EQUAL
17966: PUSH
17967: LD_EXP 10
17971: NOT
17972: AND
17973: IFFALSE 17982
// YouLost ( Depot ) ;
17975: LD_STRING Depot
17977: PPUSH
17978: CALL_OW 104
// if un = arDepot then
17982: LD_VAR 0 1
17986: PUSH
17987: LD_INT 5
17989: EQUAL
17990: IFFALSE 17999
// YouLost ( FarmerDepot ) ;
17992: LD_STRING FarmerDepot
17994: PPUSH
17995: CALL_OW 104
// if un = Farmer then
17999: LD_VAR 0 1
18003: PUSH
18004: LD_EXP 32
18008: EQUAL
18009: IFFALSE 18018
// YouLost ( Farmer ) ;
18011: LD_STRING Farmer
18013: PPUSH
18014: CALL_OW 104
// if un in usForces then
18018: LD_VAR 0 1
18022: PUSH
18023: LD_EXP 40
18027: IN
18028: IFFALSE 18046
// usForces := usForces diff un ;
18030: LD_ADDR_EXP 40
18034: PUSH
18035: LD_EXP 40
18039: PUSH
18040: LD_VAR 0 1
18044: DIFF
18045: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
18046: LD_VAR 0 1
18050: PUSH
18051: LD_INT 22
18053: PUSH
18054: LD_INT 2
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: PUSH
18061: LD_INT 23
18063: PUSH
18064: LD_INT 2
18066: PUSH
18067: EMPTY
18068: LIST
18069: LIST
18070: PUSH
18071: LD_INT 21
18073: PUSH
18074: LD_INT 1
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: LIST
18085: PPUSH
18086: CALL_OW 69
18090: IN
18091: IFFALSE 18107
// deadCounter := deadCounter + 1 ;
18093: LD_ADDR_EXP 8
18097: PUSH
18098: LD_EXP 8
18102: PUSH
18103: LD_INT 1
18105: PLUS
18106: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
18107: LD_VAR 0 1
18111: PUSH
18112: LD_INT 22
18114: PUSH
18115: LD_INT 4
18117: PUSH
18118: EMPTY
18119: LIST
18120: LIST
18121: PUSH
18122: LD_INT 34
18124: PUSH
18125: LD_INT 12
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: PUSH
18132: EMPTY
18133: LIST
18134: LIST
18135: PPUSH
18136: CALL_OW 69
18140: IN
18141: PUSH
18142: LD_EXP 15
18146: NOT
18147: AND
18148: IFFALSE 18158
// firstConvoyDestroyed := true ;
18150: LD_ADDR_EXP 15
18154: PUSH
18155: LD_INT 1
18157: ST_TO_ADDR
// if un in usAttackers then
18158: LD_VAR 0 1
18162: PUSH
18163: LD_EXP 43
18167: IN
18168: IFFALSE 18186
// usAttackers := usAttackers diff un ;
18170: LD_ADDR_EXP 43
18174: PUSH
18175: LD_EXP 43
18179: PUSH
18180: LD_VAR 0 1
18184: DIFF
18185: ST_TO_ADDR
// end ;
18186: PPOPN 1
18188: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18189: LD_VAR 0 2
18193: PUSH
18194: LD_EXP 34
18198: EQUAL
18199: PUSH
18200: LD_EXP 21
18204: AND
18205: IFFALSE 18251
// begin Video ( true ) ;
18207: LD_INT 1
18209: PPUSH
18210: CALL 1004 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
18214: LD_EXP 34
18218: PPUSH
18219: LD_INT 11
18221: PPUSH
18222: CALL_OW 120
// repeat wait ( 3 ) ;
18226: LD_INT 3
18228: PPUSH
18229: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18233: LD_EXP 34
18237: PPUSH
18238: CALL_OW 310
18242: IFFALSE 18226
// Video ( false ) ;
18244: LD_INT 0
18246: PPUSH
18247: CALL 1004 0 1
// end ; end ;
18251: PPOPN 2
18253: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
18254: LD_VAR 0 2
18258: PUSH
18259: LD_EXP 24
18263: EQUAL
18264: PUSH
18265: LD_VAR 0 1
18269: PUSH
18270: LD_INT 11
18272: EQUAL
18273: AND
18274: PUSH
18275: LD_EXP 21
18279: AND
18280: IFFALSE 18286
// IbrahimQuery ;
18282: CALL 16376 0 0
// end ;
18286: PPOPN 2
18288: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin ComStop ( newId ) ;
18289: LD_VAR 0 1
18293: PPUSH
18294: CALL_OW 141
// if oldId in usAttackers then
18298: LD_VAR 0 2
18302: PUSH
18303: LD_EXP 43
18307: IN
18308: IFFALSE 18326
// usAttackers := usAttackers diff oldId ;
18310: LD_ADDR_EXP 43
18314: PUSH
18315: LD_EXP 43
18319: PUSH
18320: LD_VAR 0 2
18324: DIFF
18325: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
18326: LD_VAR 0 3
18330: PUSH
18331: LD_INT 4
18333: EQUAL
18334: PUSH
18335: LD_EXP 15
18339: NOT
18340: AND
18341: IFFALSE 18351
// firstConvoyDestroyed := true ;
18343: LD_ADDR_EXP 15
18347: PUSH
18348: LD_INT 1
18350: ST_TO_ADDR
// if GetWeapon ( oldId ) = us_cargo_bay and GetCargo ( oldId , mat_cans ) = 0 then
18351: LD_VAR 0 2
18355: PPUSH
18356: CALL_OW 264
18360: PUSH
18361: LD_INT 12
18363: EQUAL
18364: PUSH
18365: LD_VAR 0 2
18369: PPUSH
18370: LD_INT 1
18372: PPUSH
18373: CALL_OW 289
18377: PUSH
18378: LD_INT 0
18380: EQUAL
18381: AND
18382: IFFALSE 18388
// EmptyCargoDialog ;
18384: CALL 15157 0 0
// end ;
18388: PPOPN 4
18390: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
18391: LD_VAR 0 1
18395: PUSH
18396: LD_INT 2
18398: EQUAL
18399: PUSH
18400: LD_VAR 0 2
18404: PUSH
18405: LD_INT 5
18407: EQUAL
18408: AND
18409: IFFALSE 18418
// YouLost ( Attack ) ;
18411: LD_STRING Attack
18413: PPUSH
18414: CALL_OW 104
// end ;
18418: PPOPN 2
18420: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 and not americanBaseCaptured then
18421: LD_VAR 0 1
18425: PPUSH
18426: CALL_OW 255
18430: PUSH
18431: LD_INT 1
18433: EQUAL
18434: PUSH
18435: LD_EXP 6
18439: NOT
18440: AND
18441: IFFALSE 18575
// begin if GetBType ( b ) = b_lab then
18443: LD_VAR 0 1
18447: PPUSH
18448: CALL_OW 266
18452: PUSH
18453: LD_INT 6
18455: EQUAL
18456: IFFALSE 18496
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
18458: LD_EXP 40
18462: PPUSH
18463: LD_INT 25
18465: PUSH
18466: LD_INT 4
18468: PUSH
18469: EMPTY
18470: LIST
18471: LIST
18472: PPUSH
18473: CALL_OW 72
18477: PPUSH
18478: LD_VAR 0 1
18482: PPUSH
18483: CALL_OW 120
// AmLabResearch ( b ) ;
18487: LD_VAR 0 1
18491: PPUSH
18492: CALL 5973 0 1
// end ; if GetBType ( b ) = b_armoury then
18496: LD_VAR 0 1
18500: PPUSH
18501: CALL_OW 266
18505: PUSH
18506: LD_INT 4
18508: EQUAL
18509: IFFALSE 18557
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
18511: LD_EXP 40
18515: PPUSH
18516: LD_INT 25
18518: PUSH
18519: LD_INT 1
18521: PUSH
18522: EMPTY
18523: LIST
18524: LIST
18525: PUSH
18526: LD_INT 3
18528: PUSH
18529: LD_INT 54
18531: PUSH
18532: EMPTY
18533: LIST
18534: PUSH
18535: EMPTY
18536: LIST
18537: LIST
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: PPUSH
18543: CALL_OW 72
18547: PPUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
18557: LD_ADDR_EXP 42
18561: PUSH
18562: LD_EXP 42
18566: PPUSH
18567: LD_INT 1
18569: PPUSH
18570: CALL_OW 3
18574: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
18575: LD_VAR 0 1
18579: PPUSH
18580: CALL_OW 255
18584: PUSH
18585: LD_INT 5
18587: EQUAL
18588: IFFALSE 18602
// SetBLevel ( b , 5 ) ;
18590: LD_VAR 0 1
18594: PPUSH
18595: LD_INT 5
18597: PPUSH
18598: CALL_OW 241
// end ;
18602: PPOPN 1
18604: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
18605: LD_VAR 0 1
18609: PPUSH
18610: CALL_OW 255
18614: PUSH
18615: LD_INT 2
18617: EQUAL
18618: IFFALSE 18634
// vehCounter := vehCounter + 1 ;
18620: LD_ADDR_EXP 18
18624: PUSH
18625: LD_EXP 18
18629: PUSH
18630: LD_INT 1
18632: PLUS
18633: ST_TO_ADDR
// end ;
18634: PPOPN 2
18636: END
// on SailEvent ( event ) do begin if event = eventAttack then
18637: LD_VAR 0 1
18641: PUSH
18642: LD_EXP 20
18646: EQUAL
18647: IFFALSE 18653
// AmericanAttack ;
18649: CALL 7413 0 0
// end ; end_of_file
18653: PPOPN 1
18655: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 4 4$00 , 3 3$00 , 2 2$30 ] [ Difficulty ] do
18656: LD_OWVAR 1
18660: PUSH
18661: LD_INT 8400
18663: PUSH
18664: LD_INT 6300
18666: PUSH
18667: LD_INT 5250
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: PUSH
18675: LD_OWVAR 67
18679: ARRAY
18680: LESSEQUAL
18681: IFFALSE 18708
18683: GO 18685
18685: DISABLE
// begin enable ;
18686: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18687: LD_INT 1
18689: PPUSH
18690: LD_INT 5
18692: PPUSH
18693: CALL_OW 12
18697: PPUSH
18698: LD_INT 9
18700: PPUSH
18701: LD_INT 1
18703: PPUSH
18704: CALL_OW 55
// end ;
18708: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 26 26$00 , 23 23$00 , 20 20$00 ] [ Difficulty ] do
18709: LD_EXP 6
18713: PUSH
18714: LD_OWVAR 1
18718: PUSH
18719: LD_INT 54600
18721: PUSH
18722: LD_INT 48300
18724: PUSH
18725: LD_INT 42000
18727: PUSH
18728: EMPTY
18729: LIST
18730: LIST
18731: LIST
18732: PUSH
18733: LD_OWVAR 67
18737: ARRAY
18738: LESSEQUAL
18739: AND
18740: IFFALSE 18767
18742: GO 18744
18744: DISABLE
// begin enable ;
18745: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18746: LD_INT 1
18748: PPUSH
18749: LD_INT 5
18751: PPUSH
18752: CALL_OW 12
18756: PPUSH
18757: LD_INT 9
18759: PPUSH
18760: LD_INT 1
18762: PPUSH
18763: CALL_OW 55
// end ; end_of_file
18767: END
// every 0 0$1 trigger not retreatAllowed and farmerRequestedCrates and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
18768: LD_EXP 10
18772: NOT
18773: PUSH
18774: LD_EXP 13
18778: AND
18779: PUSH
18780: LD_EXP 4
18784: AND
18785: PUSH
18786: LD_EXP 12
18790: PUSH
18791: LD_EXP 13
18795: LESSEQUAL
18796: AND
18797: IFFALSE 18887
18799: GO 18801
18801: DISABLE
// begin enable ;
18802: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
18803: LD_ADDR_OWVAR 47
18807: PUSH
18808: LD_STRING #X103-1
18810: PUSH
18811: LD_EXP 12
18815: PUSH
18816: LD_EXP 13
18820: PUSH
18821: EMPTY
18822: LIST
18823: LIST
18824: LIST
18825: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
18826: LD_ADDR_EXP 12
18830: PUSH
18831: LD_INT 5
18833: PPUSH
18834: CALL_OW 274
18838: PPUSH
18839: LD_INT 1
18841: PPUSH
18842: CALL_OW 275
18846: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
18847: LD_INT 10
18849: PPUSH
18850: LD_INT 1
18852: PPUSH
18853: CALL_OW 287
18857: PUSH
18858: LD_INT 0
18860: EQUAL
18861: IFFALSE 18879
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
18863: LD_ADDR_EXP 14
18867: PUSH
18868: LD_EXP 14
18872: PUSH
18873: LD_INT 35
18875: MINUS
18876: ST_TO_ADDR
18877: GO 18887
// farmerCratesCounter := 30 30$00 ;
18879: LD_ADDR_EXP 14
18883: PUSH
18884: LD_INT 63000
18886: ST_TO_ADDR
// end ; end_of_file
18887: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18888: GO 18890
18890: DISABLE
// begin ru_radar := 98 ;
18891: LD_ADDR_EXP 44
18895: PUSH
18896: LD_INT 98
18898: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18899: LD_ADDR_EXP 45
18903: PUSH
18904: LD_INT 89
18906: ST_TO_ADDR
// us_hack := 99 ;
18907: LD_ADDR_EXP 46
18911: PUSH
18912: LD_INT 99
18914: ST_TO_ADDR
// us_artillery := 97 ;
18915: LD_ADDR_EXP 47
18919: PUSH
18920: LD_INT 97
18922: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18923: LD_ADDR_EXP 48
18927: PUSH
18928: LD_INT 91
18930: ST_TO_ADDR
// tech_Artillery := 80 ;
18931: LD_ADDR_EXP 49
18935: PUSH
18936: LD_INT 80
18938: ST_TO_ADDR
// tech_RadMat := 81 ;
18939: LD_ADDR_EXP 50
18943: PUSH
18944: LD_INT 81
18946: ST_TO_ADDR
// tech_BasicTools := 82 ;
18947: LD_ADDR_EXP 51
18951: PUSH
18952: LD_INT 82
18954: ST_TO_ADDR
// tech_Cargo := 83 ;
18955: LD_ADDR_EXP 52
18959: PUSH
18960: LD_INT 83
18962: ST_TO_ADDR
// tech_Track := 84 ;
18963: LD_ADDR_EXP 53
18967: PUSH
18968: LD_INT 84
18970: ST_TO_ADDR
// tech_Crane := 85 ;
18971: LD_ADDR_EXP 54
18975: PUSH
18976: LD_INT 85
18978: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18979: LD_ADDR_EXP 55
18983: PUSH
18984: LD_INT 86
18986: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18987: LD_ADDR_EXP 56
18991: PUSH
18992: LD_INT 87
18994: ST_TO_ADDR
// end ;
18995: END
