// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 38 0 0
// PrepareNature ;
   8: CALL 681 0 0
// PrepareArabian ;
  12: CALL 1996 0 0
// PrepareAmerican ;
  16: CALL 5021 0 0
// if debug then
  20: LD_EXP 1
  24: IFFALSE 33
// FogOff ( 2 ) ;
  26: LD_INT 2
  28: PPUSH
  29: CALL_OW 344
// Action ;
  33: CALL 9859 0 0
// end ;
  37: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , allowCargoEvacuation , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , capturedCargoCounter , americanStartRun , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , farmerHumanLoseCounter , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := false ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 0
  48: ST_TO_ADDR
// prefix := 02_ ;
  49: LD_ADDR_EXP 2
  53: PUSH
  54: LD_STRING 02_
  56: ST_TO_ADDR
// eventAttack := 1 ;
  57: LD_ADDR_EXP 24
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// deadCounter := 0 ;
  65: LD_ADDR_EXP 9
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// gameStarted := false ;
  73: LD_ADDR_EXP 3
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// farmerBaseReady := false ;
  81: LD_ADDR_EXP 4
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// americanBaseSpoted := false ;
  89: LD_ADDR_EXP 5
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// americanBaseCaptured := false ;
  97: LD_ADDR_EXP 6
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// americanHasEscaped := false ;
 105: LD_ADDR_EXP 8
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// workshopBuilded := false ;
 113: LD_ADDR_EXP 10
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// retreatAllowed := false ;
 121: LD_ADDR_EXP 11
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// allowConvoys := false ;
 129: LD_ADDR_EXP 12
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// farmerCrates := 0 ;
 137: LD_ADDR_EXP 15
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 145: LD_ADDR_EXP 16
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 153: LD_ADDR_EXP 17
 157: PUSH
 158: LD_INT 63000
 160: PUSH
 161: LD_INT 52500
 163: PUSH
 164: LD_INT 46200
 166: PUSH
 167: EMPTY
 168: LIST
 169: LIST
 170: LIST
 171: PUSH
 172: LD_OWVAR 67
 176: ARRAY
 177: ST_TO_ADDR
// farmerHumanLoseCounter := 0 ;
 178: LD_ADDR_EXP 20
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 186: LD_ADDR_EXP 18
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// attackWave := 1 ;
 194: LD_ADDR_EXP 19
 198: PUSH
 199: LD_INT 1
 201: ST_TO_ADDR
// omarCargoCounter := [ 6 , 8 , 10 ] [ Difficulty ] ;
 202: LD_ADDR_EXP 21
 206: PUSH
 207: LD_INT 6
 209: PUSH
 210: LD_INT 8
 212: PUSH
 213: LD_INT 10
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: PUSH
 221: LD_OWVAR 67
 225: ARRAY
 226: ST_TO_ADDR
// vehCounter := 0 ;
 227: LD_ADDR_EXP 22
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// convoyCounter := 0 ;
 235: LD_ADDR_EXP 23
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// ibrahimInDepot := false ;
 243: LD_ADDR_EXP 25
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// ibrahimIsFree := false ;
 251: LD_ADDR_EXP 26
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// maxConvoys := [ 16 , 16 , 15 ] [ Difficulty ] ;
 259: LD_ADDR_EXP 27
 263: PUSH
 264: LD_INT 16
 266: PUSH
 267: LD_INT 16
 269: PUSH
 270: LD_INT 15
 272: PUSH
 273: EMPTY
 274: LIST
 275: LIST
 276: LIST
 277: PUSH
 278: LD_OWVAR 67
 282: ARRAY
 283: ST_TO_ADDR
// capturedCargoCounter := 0 ;
 284: LD_ADDR_EXP 13
 288: PUSH
 289: LD_INT 0
 291: ST_TO_ADDR
// allowCargoEvacuation := false ;
 292: LD_ADDR_EXP 7
 296: PUSH
 297: LD_INT 0
 299: ST_TO_ADDR
// americanStartRun := false ;
 300: LD_ADDR_EXP 14
 304: PUSH
 305: LD_INT 0
 307: ST_TO_ADDR
// end ; end_of_file
 308: LD_VAR 0 1
 312: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 313: LD_INT 0
 315: PPUSH
 316: PPUSH
// if exist_mode then
 317: LD_VAR 0 2
 321: IFFALSE 346
// unit := CreateCharacter ( prefix & ident ) else
 323: LD_ADDR_VAR 0 5
 327: PUSH
 328: LD_VAR 0 3
 332: PUSH
 333: LD_VAR 0 1
 337: STR
 338: PPUSH
 339: CALL_OW 34
 343: ST_TO_ADDR
 344: GO 361
// unit := NewCharacter ( ident ) ;
 346: LD_ADDR_VAR 0 5
 350: PUSH
 351: LD_VAR 0 1
 355: PPUSH
 356: CALL_OW 25
 360: ST_TO_ADDR
// result := unit ;
 361: LD_ADDR_VAR 0 4
 365: PUSH
 366: LD_VAR 0 5
 370: ST_TO_ADDR
// end ;
 371: LD_VAR 0 4
 375: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 376: LD_INT 0
 378: PPUSH
// uc_side := side ;
 379: LD_ADDR_OWVAR 20
 383: PUSH
 384: LD_VAR 0 1
 388: ST_TO_ADDR
// uc_nation := nation ;
 389: LD_ADDR_OWVAR 21
 393: PUSH
 394: LD_VAR 0 2
 398: ST_TO_ADDR
// vc_chassis := chassis ;
 399: LD_ADDR_OWVAR 37
 403: PUSH
 404: LD_VAR 0 3
 408: ST_TO_ADDR
// vc_engine := engine ;
 409: LD_ADDR_OWVAR 39
 413: PUSH
 414: LD_VAR 0 4
 418: ST_TO_ADDR
// vc_control := control ;
 419: LD_ADDR_OWVAR 38
 423: PUSH
 424: LD_VAR 0 5
 428: ST_TO_ADDR
// vc_weapon := weapon ;
 429: LD_ADDR_OWVAR 40
 433: PUSH
 434: LD_VAR 0 6
 438: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 439: LD_ADDR_OWVAR 41
 443: PUSH
 444: LD_VAR 0 7
 448: ST_TO_ADDR
// result := CreateVehicle ;
 449: LD_ADDR_VAR 0 8
 453: PUSH
 454: CALL_OW 45
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 8
 463: RET
// export function SayX ( units , ident ) ; var i ; begin
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// result := false ;
 468: LD_ADDR_VAR 0 3
 472: PUSH
 473: LD_INT 0
 475: ST_TO_ADDR
// if not units then
 476: LD_VAR 0 1
 480: NOT
 481: IFFALSE 485
// exit ;
 483: GO 539
// for i in units do
 485: LD_ADDR_VAR 0 4
 489: PUSH
 490: LD_VAR 0 1
 494: PUSH
 495: FOR_IN
 496: IFFALSE 537
// if IsOk ( i ) then
 498: LD_VAR 0 4
 502: PPUSH
 503: CALL_OW 302
 507: IFFALSE 535
// begin Say ( i , ident ) ;
 509: LD_VAR 0 4
 513: PPUSH
 514: LD_VAR 0 2
 518: PPUSH
 519: CALL_OW 88
// result := i ;
 523: LD_ADDR_VAR 0 3
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// break ;
 533: GO 537
// end ;
 535: GO 495
 537: POP
 538: POP
// end ;
 539: LD_VAR 0 3
 543: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 544: LD_INT 0
 546: PPUSH
 547: PPUSH
// InitUc ;
 548: CALL_OW 18
// InitHc ;
 552: CALL_OW 19
// uc_side := 0 ;
 556: LD_ADDR_OWVAR 20
 560: PUSH
 561: LD_INT 0
 563: ST_TO_ADDR
// uc_nation := 0 ;
 564: LD_ADDR_OWVAR 21
 568: PUSH
 569: LD_INT 0
 571: ST_TO_ADDR
// for i = 1 to amount do
 572: LD_ADDR_VAR 0 4
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 2
 586: PUSH
 587: FOR_TO
 588: IFFALSE 670
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 590: LD_ADDR_OWVAR 29
 594: PUSH
 595: LD_INT 9
 597: PPUSH
 598: LD_INT 12
 600: PPUSH
 601: CALL_OW 12
 605: PUSH
 606: LD_INT 9
 608: PPUSH
 609: LD_INT 12
 611: PPUSH
 612: CALL_OW 12
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 621: LD_ADDR_OWVAR 35
 625: PUSH
 626: LD_INT 1
 628: NEG
 629: PPUSH
 630: LD_INT 1
 632: PPUSH
 633: CALL_OW 12
 637: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 638: LD_INT 0
 640: PPUSH
 641: LD_INT 12
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 651: CALL_OW 44
 655: PPUSH
 656: LD_VAR 0 1
 660: PPUSH
 661: LD_INT 0
 663: PPUSH
 664: CALL_OW 49
// end ;
 668: GO 587
 670: POP
 671: POP
// InitHc ;
 672: CALL_OW 19
// end ;
 676: LD_VAR 0 3
 680: RET
// export function PrepareNature ; var i ; begin
 681: LD_INT 0
 683: PPUSH
 684: PPUSH
// SpawnApeman ( forest , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
 685: LD_INT 2
 687: PPUSH
 688: LD_INT 5
 690: PUSH
 691: LD_INT 4
 693: PUSH
 694: LD_INT 4
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_OWVAR 67
 706: ARRAY
 707: PPUSH
 708: CALL 544 0 2
// for i := 1 to 2 do
 712: LD_ADDR_VAR 0 2
 716: PUSH
 717: DOUBLE
 718: LD_INT 1
 720: DEC
 721: ST_TO_ADDR
 722: LD_INT 2
 724: PUSH
 725: FOR_TO
 726: IFFALSE 761
// begin hc_class := 21 ;
 728: LD_ADDR_OWVAR 28
 732: PUSH
 733: LD_INT 21
 735: ST_TO_ADDR
// hc_gallery :=  ;
 736: LD_ADDR_OWVAR 33
 740: PUSH
 741: LD_STRING 
 743: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 744: CALL_OW 44
 748: PPUSH
 749: LD_INT 2
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL_OW 49
// end ;
 759: GO 725
 761: POP
 762: POP
// for i := 1 to 2 do
 763: LD_ADDR_VAR 0 2
 767: PUSH
 768: DOUBLE
 769: LD_INT 1
 771: DEC
 772: ST_TO_ADDR
 773: LD_INT 2
 775: PUSH
 776: FOR_TO
 777: IFFALSE 812
// begin hc_class := 18 ;
 779: LD_ADDR_OWVAR 28
 783: PUSH
 784: LD_INT 18
 786: ST_TO_ADDR
// hc_gallery :=  ;
 787: LD_ADDR_OWVAR 33
 791: PUSH
 792: LD_STRING 
 794: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 795: CALL_OW 44
 799: PPUSH
 800: LD_INT 2
 802: PPUSH
 803: LD_INT 0
 805: PPUSH
 806: CALL_OW 49
// end ;
 810: GO 776
 812: POP
 813: POP
// for i := 1 to 2 do
 814: LD_ADDR_VAR 0 2
 818: PUSH
 819: DOUBLE
 820: LD_INT 1
 822: DEC
 823: ST_TO_ADDR
 824: LD_INT 2
 826: PUSH
 827: FOR_TO
 828: IFFALSE 863
// begin hc_class := 13 ;
 830: LD_ADDR_OWVAR 28
 834: PUSH
 835: LD_INT 13
 837: ST_TO_ADDR
// hc_gallery :=  ;
 838: LD_ADDR_OWVAR 33
 842: PUSH
 843: LD_STRING 
 845: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 846: CALL_OW 44
 850: PPUSH
 851: LD_INT 2
 853: PPUSH
 854: LD_INT 0
 856: PPUSH
 857: CALL_OW 49
// end ;
 861: GO 827
 863: POP
 864: POP
// end ;
 865: LD_VAR 0 1
 869: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 870: LD_INT 0
 872: PPUSH
 873: PPUSH
 874: PPUSH
// if not observer or not unit then
 875: LD_VAR 0 1
 879: NOT
 880: PUSH
 881: LD_VAR 0 2
 885: NOT
 886: OR
 887: IFFALSE 891
// exit ;
 889: GO 939
// if not See ( GetSide ( observer ) , unit ) then
 891: LD_VAR 0 1
 895: PPUSH
 896: CALL_OW 255
 900: PPUSH
 901: LD_VAR 0 2
 905: PPUSH
 906: CALL_OW 292
 910: NOT
 911: IFFALSE 915
// exit ;
 913: GO 939
// result := GetDistUnits ( observer , unit ) < 12 ;
 915: LD_ADDR_VAR 0 3
 919: PUSH
 920: LD_VAR 0 1
 924: PPUSH
 925: LD_VAR 0 2
 929: PPUSH
 930: CALL_OW 296
 934: PUSH
 935: LD_INT 12
 937: LESS
 938: ST_TO_ADDR
// end ;
 939: LD_VAR 0 3
 943: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 944: LD_INT 0
 946: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 947: LD_VAR 0 2
 951: PUSH
 952: LD_INT 1
 954: ARRAY
 955: PPUSH
 956: LD_VAR 0 2
 960: PUSH
 961: LD_INT 2
 963: ARRAY
 964: PPUSH
 965: CALL_OW 488
 969: PUSH
 970: LD_VAR 0 2
 974: PUSH
 975: LD_INT 1
 977: ARRAY
 978: PPUSH
 979: LD_VAR 0 2
 983: PUSH
 984: LD_INT 2
 986: ARRAY
 987: PPUSH
 988: CALL_OW 428
 992: PUSH
 993: LD_INT 0
 995: EQUAL
 996: AND
 997: IFFALSE 1031
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 999: LD_VAR 0 1
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_INT 1
1011: ARRAY
1012: PPUSH
1013: LD_VAR 0 2
1017: PUSH
1018: LD_INT 2
1020: ARRAY
1021: PPUSH
1022: LD_VAR 0 3
1026: PPUSH
1027: CALL_OW 48
// end ;
1031: LD_VAR 0 4
1035: RET
// export function Video ( mode ) ; begin
1036: LD_INT 0
1038: PPUSH
// ingame_video = mode ;
1039: LD_ADDR_OWVAR 52
1043: PUSH
1044: LD_VAR 0 1
1048: ST_TO_ADDR
// interface_hidden = mode ;
1049: LD_ADDR_OWVAR 54
1053: PUSH
1054: LD_VAR 0 1
1058: ST_TO_ADDR
// end ;
1059: LD_VAR 0 2
1063: RET
// export function ReverseArray ( array ) ; var i ; begin
1064: LD_INT 0
1066: PPUSH
1067: PPUSH
// if not array then
1068: LD_VAR 0 1
1072: NOT
1073: IFFALSE 1077
// exit ;
1075: GO 1135
// result := [ ] ;
1077: LD_ADDR_VAR 0 2
1081: PUSH
1082: EMPTY
1083: ST_TO_ADDR
// for i := 1 to array do
1084: LD_ADDR_VAR 0 3
1088: PUSH
1089: DOUBLE
1090: LD_INT 1
1092: DEC
1093: ST_TO_ADDR
1094: LD_VAR 0 1
1098: PUSH
1099: FOR_TO
1100: IFFALSE 1133
// result := Insert ( result , 1 , array [ i ] ) ;
1102: LD_ADDR_VAR 0 2
1106: PUSH
1107: LD_VAR 0 2
1111: PPUSH
1112: LD_INT 1
1114: PPUSH
1115: LD_VAR 0 1
1119: PUSH
1120: LD_VAR 0 3
1124: ARRAY
1125: PPUSH
1126: CALL_OW 2
1130: ST_TO_ADDR
1131: GO 1099
1133: POP
1134: POP
// end ;
1135: LD_VAR 0 2
1139: RET
// export function ComExit ( unit ) ; begin
1140: LD_INT 0
1142: PPUSH
// result := IsInUnit ( unit ) ;
1143: LD_ADDR_VAR 0 2
1147: PUSH
1148: LD_VAR 0 1
1152: PPUSH
1153: CALL_OW 310
1157: ST_TO_ADDR
// if not result then
1158: LD_VAR 0 2
1162: NOT
1163: IFFALSE 1167
// exit ;
1165: GO 1202
// if GetType ( result ) = unit_vehicle then
1167: LD_VAR 0 2
1171: PPUSH
1172: CALL_OW 247
1176: PUSH
1177: LD_INT 2
1179: EQUAL
1180: IFFALSE 1193
// ComExitVehicle ( unit ) else
1182: LD_VAR 0 1
1186: PPUSH
1187: CALL_OW 121
1191: GO 1202
// ComExitBuilding ( unit ) ;
1193: LD_VAR 0 1
1197: PPUSH
1198: CALL_OW 122
// end ;
1202: LD_VAR 0 2
1206: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1207: LD_INT 0
1209: PPUSH
1210: PPUSH
// if not side or not nation then
1211: LD_VAR 0 1
1215: NOT
1216: PUSH
1217: LD_VAR 0 2
1221: NOT
1222: OR
1223: IFFALSE 1227
// exit ;
1225: GO 1991
// case nation of nation_american :
1227: LD_VAR 0 2
1231: PUSH
1232: LD_INT 1
1234: DOUBLE
1235: EQUAL
1236: IFTRUE 1240
1238: GO 1454
1240: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1241: LD_ADDR_VAR 0 4
1245: PUSH
1246: LD_INT 35
1248: PUSH
1249: LD_INT 45
1251: PUSH
1252: LD_INT 46
1254: PUSH
1255: LD_INT 47
1257: PUSH
1258: LD_INT 82
1260: PUSH
1261: LD_INT 83
1263: PUSH
1264: LD_INT 84
1266: PUSH
1267: LD_INT 85
1269: PUSH
1270: LD_INT 86
1272: PUSH
1273: LD_INT 1
1275: PUSH
1276: LD_INT 2
1278: PUSH
1279: LD_INT 6
1281: PUSH
1282: LD_INT 15
1284: PUSH
1285: LD_INT 16
1287: PUSH
1288: LD_INT 7
1290: PUSH
1291: LD_INT 12
1293: PUSH
1294: LD_INT 13
1296: PUSH
1297: LD_INT 10
1299: PUSH
1300: LD_INT 14
1302: PUSH
1303: LD_INT 20
1305: PUSH
1306: LD_INT 21
1308: PUSH
1309: LD_INT 22
1311: PUSH
1312: LD_INT 25
1314: PUSH
1315: LD_INT 32
1317: PUSH
1318: LD_INT 27
1320: PUSH
1321: LD_INT 36
1323: PUSH
1324: LD_INT 69
1326: PUSH
1327: LD_INT 39
1329: PUSH
1330: LD_INT 34
1332: PUSH
1333: LD_INT 40
1335: PUSH
1336: LD_INT 48
1338: PUSH
1339: LD_INT 49
1341: PUSH
1342: LD_INT 50
1344: PUSH
1345: LD_INT 51
1347: PUSH
1348: LD_INT 52
1350: PUSH
1351: LD_INT 53
1353: PUSH
1354: LD_INT 54
1356: PUSH
1357: LD_INT 55
1359: PUSH
1360: LD_INT 56
1362: PUSH
1363: LD_INT 57
1365: PUSH
1366: LD_INT 58
1368: PUSH
1369: LD_INT 59
1371: PUSH
1372: LD_INT 60
1374: PUSH
1375: LD_INT 61
1377: PUSH
1378: LD_INT 62
1380: PUSH
1381: LD_INT 80
1383: PUSH
1384: LD_INT 82
1386: PUSH
1387: LD_INT 83
1389: PUSH
1390: LD_INT 84
1392: PUSH
1393: LD_INT 85
1395: PUSH
1396: LD_INT 86
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: ST_TO_ADDR
1452: GO 1915
1454: LD_INT 2
1456: DOUBLE
1457: EQUAL
1458: IFTRUE 1462
1460: GO 1684
1462: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1463: LD_ADDR_VAR 0 4
1467: PUSH
1468: LD_INT 35
1470: PUSH
1471: LD_INT 45
1473: PUSH
1474: LD_INT 46
1476: PUSH
1477: LD_INT 47
1479: PUSH
1480: LD_INT 82
1482: PUSH
1483: LD_INT 83
1485: PUSH
1486: LD_INT 84
1488: PUSH
1489: LD_INT 85
1491: PUSH
1492: LD_INT 87
1494: PUSH
1495: LD_INT 70
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 11
1503: PUSH
1504: LD_INT 3
1506: PUSH
1507: LD_INT 4
1509: PUSH
1510: LD_INT 5
1512: PUSH
1513: LD_INT 6
1515: PUSH
1516: LD_INT 15
1518: PUSH
1519: LD_INT 18
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: LD_INT 17
1527: PUSH
1528: LD_INT 8
1530: PUSH
1531: LD_INT 20
1533: PUSH
1534: LD_INT 21
1536: PUSH
1537: LD_INT 22
1539: PUSH
1540: LD_INT 72
1542: PUSH
1543: LD_INT 26
1545: PUSH
1546: LD_INT 69
1548: PUSH
1549: LD_INT 39
1551: PUSH
1552: LD_INT 40
1554: PUSH
1555: LD_INT 41
1557: PUSH
1558: LD_INT 42
1560: PUSH
1561: LD_INT 43
1563: PUSH
1564: LD_INT 48
1566: PUSH
1567: LD_INT 49
1569: PUSH
1570: LD_INT 50
1572: PUSH
1573: LD_INT 51
1575: PUSH
1576: LD_INT 52
1578: PUSH
1579: LD_INT 53
1581: PUSH
1582: LD_INT 54
1584: PUSH
1585: LD_INT 55
1587: PUSH
1588: LD_INT 56
1590: PUSH
1591: LD_INT 60
1593: PUSH
1594: LD_INT 61
1596: PUSH
1597: LD_INT 62
1599: PUSH
1600: LD_INT 66
1602: PUSH
1603: LD_INT 67
1605: PUSH
1606: LD_INT 68
1608: PUSH
1609: LD_INT 81
1611: PUSH
1612: LD_INT 82
1614: PUSH
1615: LD_INT 83
1617: PUSH
1618: LD_INT 84
1620: PUSH
1621: LD_INT 85
1623: PUSH
1624: LD_INT 87
1626: PUSH
1627: EMPTY
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: ST_TO_ADDR
1682: GO 1915
1684: LD_INT 3
1686: DOUBLE
1687: EQUAL
1688: IFTRUE 1692
1690: GO 1914
1692: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1693: LD_ADDR_VAR 0 4
1697: PUSH
1698: LD_INT 46
1700: PUSH
1701: LD_INT 47
1703: PUSH
1704: LD_INT 1
1706: PUSH
1707: LD_INT 2
1709: PUSH
1710: LD_INT 82
1712: PUSH
1713: LD_INT 83
1715: PUSH
1716: LD_INT 84
1718: PUSH
1719: LD_INT 85
1721: PUSH
1722: LD_INT 86
1724: PUSH
1725: LD_INT 11
1727: PUSH
1728: LD_INT 9
1730: PUSH
1731: LD_INT 20
1733: PUSH
1734: LD_INT 19
1736: PUSH
1737: LD_INT 21
1739: PUSH
1740: LD_INT 24
1742: PUSH
1743: LD_INT 22
1745: PUSH
1746: LD_INT 25
1748: PUSH
1749: LD_INT 28
1751: PUSH
1752: LD_INT 29
1754: PUSH
1755: LD_INT 30
1757: PUSH
1758: LD_INT 31
1760: PUSH
1761: LD_INT 37
1763: PUSH
1764: LD_INT 38
1766: PUSH
1767: LD_INT 32
1769: PUSH
1770: LD_INT 27
1772: PUSH
1773: LD_INT 33
1775: PUSH
1776: LD_INT 69
1778: PUSH
1779: LD_INT 39
1781: PUSH
1782: LD_INT 34
1784: PUSH
1785: LD_INT 40
1787: PUSH
1788: LD_INT 71
1790: PUSH
1791: LD_INT 23
1793: PUSH
1794: LD_INT 44
1796: PUSH
1797: LD_INT 48
1799: PUSH
1800: LD_INT 49
1802: PUSH
1803: LD_INT 50
1805: PUSH
1806: LD_INT 51
1808: PUSH
1809: LD_INT 52
1811: PUSH
1812: LD_INT 53
1814: PUSH
1815: LD_INT 54
1817: PUSH
1818: LD_INT 55
1820: PUSH
1821: LD_INT 56
1823: PUSH
1824: LD_INT 57
1826: PUSH
1827: LD_INT 58
1829: PUSH
1830: LD_INT 59
1832: PUSH
1833: LD_INT 63
1835: PUSH
1836: LD_INT 64
1838: PUSH
1839: LD_INT 65
1841: PUSH
1842: LD_INT 82
1844: PUSH
1845: LD_INT 83
1847: PUSH
1848: LD_INT 84
1850: PUSH
1851: LD_INT 85
1853: PUSH
1854: LD_INT 86
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: ST_TO_ADDR
1912: GO 1915
1914: POP
// if state > - 1 and state < 3 then
1915: LD_VAR 0 3
1919: PUSH
1920: LD_INT 1
1922: NEG
1923: GREATER
1924: PUSH
1925: LD_VAR 0 3
1929: PUSH
1930: LD_INT 3
1932: LESS
1933: AND
1934: IFFALSE 1991
// for i in result do
1936: LD_ADDR_VAR 0 5
1940: PUSH
1941: LD_VAR 0 4
1945: PUSH
1946: FOR_IN
1947: IFFALSE 1989
// if GetTech ( i , side ) <> state then
1949: LD_VAR 0 5
1953: PPUSH
1954: LD_VAR 0 1
1958: PPUSH
1959: CALL_OW 321
1963: PUSH
1964: LD_VAR 0 3
1968: NONEQUAL
1969: IFFALSE 1987
// result := result diff i ;
1971: LD_ADDR_VAR 0 4
1975: PUSH
1976: LD_VAR 0 4
1980: PUSH
1981: LD_VAR 0 5
1985: DIFF
1986: ST_TO_ADDR
1987: GO 1946
1989: POP
1990: POP
// end ; end_of_file
1991: LD_VAR 0 4
1995: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1996: LD_INT 0
1998: PPUSH
1999: PPUSH
2000: PPUSH
2001: PPUSH
// uc_side := 5 ;
2002: LD_ADDR_OWVAR 20
2006: PUSH
2007: LD_INT 5
2009: ST_TO_ADDR
// uc_nation := 2 ;
2010: LD_ADDR_OWVAR 21
2014: PUSH
2015: LD_INT 2
2017: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
2018: LD_INT 5
2020: PPUSH
2021: CALL_OW 274
2025: PPUSH
2026: LD_INT 1
2028: PPUSH
2029: LD_INT 45
2031: PPUSH
2032: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
2036: LD_ADDR_EXP 36
2040: PUSH
2041: LD_STRING Farmer
2043: PPUSH
2044: LD_INT 0
2046: PPUSH
2047: LD_STRING 
2049: PPUSH
2050: CALL 313 0 3
2054: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2055: LD_ADDR_EXP 37
2059: PUSH
2060: LD_STRING Omar
2062: PPUSH
2063: LD_INT 0
2065: PPUSH
2066: LD_STRING 
2068: PPUSH
2069: CALL 313 0 3
2073: ST_TO_ADDR
// omarSquad := [ ] ;
2074: LD_ADDR_EXP 40
2078: PUSH
2079: EMPTY
2080: ST_TO_ADDR
// heikeSquad := [ ] ;
2081: LD_ADDR_EXP 41
2085: PUSH
2086: EMPTY
2087: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2088: LD_ADDR_EXP 42
2092: PUSH
2093: EMPTY
2094: ST_TO_ADDR
// omarCargo := [ ] ;
2095: LD_ADDR_EXP 43
2099: PUSH
2100: EMPTY
2101: ST_TO_ADDR
// for i := 1 to 5 do
2102: LD_ADDR_VAR 0 2
2106: PUSH
2107: DOUBLE
2108: LD_INT 1
2110: DEC
2111: ST_TO_ADDR
2112: LD_INT 5
2114: PUSH
2115: FOR_TO
2116: IFFALSE 2274
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2118: LD_INT 0
2120: PPUSH
2121: LD_INT 1
2123: PUSH
2124: LD_INT 1
2126: PUSH
2127: LD_INT 2
2129: PUSH
2130: LD_INT 1
2132: PUSH
2133: LD_INT 1
2135: PUSH
2136: EMPTY
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: PUSH
2143: LD_VAR 0 2
2147: ARRAY
2148: PPUSH
2149: LD_INT 3
2151: PPUSH
2152: CALL_OW 380
// un := CreateHuman ;
2156: LD_ADDR_VAR 0 3
2160: PUSH
2161: CALL_OW 44
2165: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2166: LD_ADDR_EXP 40
2170: PUSH
2171: LD_EXP 40
2175: PUSH
2176: LD_VAR 0 3
2180: UNION
2181: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2182: LD_VAR 0 3
2186: PPUSH
2187: LD_INT 87
2189: PUSH
2190: LD_INT 30
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 91
2199: PUSH
2200: LD_INT 32
2202: PUSH
2203: EMPTY
2204: LIST
2205: LIST
2206: PUSH
2207: LD_INT 82
2209: PUSH
2210: LD_INT 15
2212: PUSH
2213: EMPTY
2214: LIST
2215: LIST
2216: PUSH
2217: LD_INT 79
2219: PUSH
2220: LD_INT 14
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: PUSH
2227: LD_INT 82
2229: PUSH
2230: LD_INT 13
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: LIST
2241: LIST
2242: LIST
2243: PUSH
2244: LD_VAR 0 2
2248: ARRAY
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL 944 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2257: LD_VAR 0 3
2261: PPUSH
2262: LD_INT 93
2264: PPUSH
2265: LD_INT 21
2267: PPUSH
2268: CALL_OW 118
// end ;
2272: GO 2115
2274: POP
2275: POP
// uc_side := 2 ;
2276: LD_ADDR_OWVAR 20
2280: PUSH
2281: LD_INT 2
2283: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2284: LD_ADDR_EXP 28
2288: PUSH
2289: LD_STRING Heike
2291: PPUSH
2292: LD_EXP 1
2296: NOT
2297: PPUSH
2298: LD_EXP 2
2302: PPUSH
2303: CALL 313 0 3
2307: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2308: LD_ADDR_EXP 32
2312: PUSH
2313: LD_STRING Aviradze
2315: PPUSH
2316: LD_EXP 1
2320: NOT
2321: PPUSH
2322: LD_EXP 2
2326: PPUSH
2327: CALL 313 0 3
2331: ST_TO_ADDR
// tmp := [ ] ;
2332: LD_ADDR_VAR 0 4
2336: PUSH
2337: EMPTY
2338: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2339: LD_ADDR_EXP 29
2343: PUSH
2344: LD_STRING Givi
2346: PPUSH
2347: LD_EXP 1
2351: NOT
2352: PPUSH
2353: LD_EXP 2
2357: PPUSH
2358: CALL 313 0 3
2362: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2363: LD_ADDR_EXP 30
2367: PUSH
2368: LD_STRING Mike
2370: PPUSH
2371: LD_EXP 1
2375: NOT
2376: PPUSH
2377: LD_EXP 2
2381: PPUSH
2382: CALL 313 0 3
2386: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2387: LD_ADDR_EXP 31
2391: PUSH
2392: LD_STRING Kamil
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_EXP 2
2405: PPUSH
2406: CALL 313 0 3
2410: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2411: LD_ADDR_EXP 33
2415: PUSH
2416: LD_STRING Kaia
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_EXP 2
2429: PPUSH
2430: CALL 313 0 3
2434: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2435: LD_ADDR_EXP 34
2439: PUSH
2440: LD_STRING Sophia
2442: PPUSH
2443: LD_EXP 1
2447: NOT
2448: PPUSH
2449: LD_EXP 2
2453: PPUSH
2454: CALL 313 0 3
2458: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2459: LD_ADDR_EXP 35
2463: PUSH
2464: LD_STRING Markov
2466: PPUSH
2467: LD_EXP 1
2471: NOT
2472: PPUSH
2473: LD_EXP 2
2477: PPUSH
2478: CALL 313 0 3
2482: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2483: LD_ADDR_EXP 42
2487: PUSH
2488: LD_STRING 02_others
2490: PPUSH
2491: CALL_OW 31
2495: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2496: LD_ADDR_VAR 0 4
2500: PUSH
2501: LD_EXP 30
2505: PUSH
2506: LD_EXP 31
2510: PUSH
2511: LD_EXP 33
2515: PUSH
2516: LD_EXP 34
2520: PUSH
2521: LD_EXP 35
2525: PUSH
2526: LD_EXP 29
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: LIST
2535: LIST
2536: LIST
2537: LIST
2538: PUSH
2539: LD_EXP 42
2543: ADD
2544: PUSH
2545: LD_INT 0
2547: DIFF
2548: ST_TO_ADDR
// heikeSquad := tmp ;
2549: LD_ADDR_EXP 41
2553: PUSH
2554: LD_VAR 0 4
2558: ST_TO_ADDR
// if UnitFilter ( heikeSquad , [ f_class , 1 ] ) < 3 then
2559: LD_EXP 41
2563: PPUSH
2564: LD_INT 25
2566: PUSH
2567: LD_INT 1
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PPUSH
2574: CALL_OW 72
2578: PUSH
2579: LD_INT 3
2581: LESS
2582: IFFALSE 2632
// begin SetClass ( Kaia , 1 ) ;
2584: LD_EXP 33
2588: PPUSH
2589: LD_INT 1
2591: PPUSH
2592: CALL_OW 336
// SetClass ( Mike , 1 ) ;
2596: LD_EXP 30
2600: PPUSH
2601: LD_INT 1
2603: PPUSH
2604: CALL_OW 336
// SetClass ( Givi , 1 ) ;
2608: LD_EXP 29
2612: PPUSH
2613: LD_INT 1
2615: PPUSH
2616: CALL_OW 336
// SetClass ( Heike , 1 ) ;
2620: LD_EXP 28
2624: PPUSH
2625: LD_INT 1
2627: PPUSH
2628: CALL_OW 336
// end ; tmp := tmp union CreateCharacterSet ( 02_ape ) ;
2632: LD_ADDR_VAR 0 4
2636: PUSH
2637: LD_VAR 0 4
2641: PUSH
2642: LD_STRING 02_ape
2644: PPUSH
2645: CALL_OW 31
2649: UNION
2650: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2651: LD_EXP 28
2655: PPUSH
2656: LD_INT 92
2658: PPUSH
2659: LD_INT 17
2661: PPUSH
2662: LD_INT 0
2664: PPUSH
2665: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2669: LD_EXP 36
2673: PPUSH
2674: LD_INT 95
2676: PPUSH
2677: LD_INT 19
2679: PPUSH
2680: LD_INT 0
2682: PPUSH
2683: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2687: LD_EXP 37
2691: PPUSH
2692: LD_INT 89
2694: PPUSH
2695: LD_INT 25
2697: PPUSH
2698: LD_INT 0
2700: PPUSH
2701: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2705: LD_EXP 32
2709: PPUSH
2710: LD_INT 92
2712: PPUSH
2713: LD_INT 27
2715: PPUSH
2716: LD_INT 0
2718: PPUSH
2719: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2723: LD_EXP 37
2727: PPUSH
2728: LD_EXP 32
2732: PPUSH
2733: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2737: LD_EXP 32
2741: PPUSH
2742: LD_EXP 37
2746: PPUSH
2747: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2751: LD_EXP 28
2755: PUSH
2756: LD_EXP 36
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PPUSH
2765: LD_EXP 37
2769: PPUSH
2770: CALL_OW 119
// if tmp then
2774: LD_VAR 0 4
2778: IFFALSE 2832
// for i in tmp do
2780: LD_ADDR_VAR 0 2
2784: PUSH
2785: LD_VAR 0 4
2789: PUSH
2790: FOR_IN
2791: IFFALSE 2830
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2793: LD_VAR 0 2
2797: PPUSH
2798: LD_INT 94
2800: PPUSH
2801: LD_INT 14
2803: PPUSH
2804: LD_INT 4
2806: PPUSH
2807: LD_INT 0
2809: PPUSH
2810: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2814: LD_VAR 0 2
2818: PPUSH
2819: LD_EXP 28
2823: PPUSH
2824: CALL_OW 119
// end ;
2828: GO 2790
2830: POP
2831: POP
// farmerSquad := [ ] ;
2832: LD_ADDR_EXP 39
2836: PUSH
2837: EMPTY
2838: ST_TO_ADDR
// uc_side := 5 ;
2839: LD_ADDR_OWVAR 20
2843: PUSH
2844: LD_INT 5
2846: ST_TO_ADDR
// uc_nation := 2 ;
2847: LD_ADDR_OWVAR 21
2851: PUSH
2852: LD_INT 2
2854: ST_TO_ADDR
// for i := 1 to 4 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 4
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2947
// begin PrepareHuman ( false , 1 , 2 ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 1
2876: PPUSH
2877: LD_INT 2
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 3
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2894: LD_VAR 0 3
2898: PPUSH
2899: LD_INT 102
2901: PPUSH
2902: LD_INT 27
2904: PPUSH
2905: LD_INT 4
2907: PPUSH
2908: LD_INT 0
2910: PPUSH
2911: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2915: LD_ADDR_EXP 39
2919: PUSH
2920: LD_EXP 39
2924: PUSH
2925: LD_VAR 0 3
2929: UNION
2930: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2931: LD_VAR 0 3
2935: PPUSH
2936: LD_EXP 37
2940: PPUSH
2941: CALL_OW 119
// end ;
2945: GO 2868
2947: POP
2948: POP
// for i := 1 to 2 do
2949: LD_ADDR_VAR 0 2
2953: PUSH
2954: DOUBLE
2955: LD_INT 1
2957: DEC
2958: ST_TO_ADDR
2959: LD_INT 2
2961: PUSH
2962: FOR_TO
2963: IFFALSE 3041
// begin PrepareHuman ( false , 2 , 2 ) ;
2965: LD_INT 0
2967: PPUSH
2968: LD_INT 2
2970: PPUSH
2971: LD_INT 2
2973: PPUSH
2974: CALL_OW 380
// un := CreateHuman ;
2978: LD_ADDR_VAR 0 3
2982: PUSH
2983: CALL_OW 44
2987: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2988: LD_VAR 0 3
2992: PPUSH
2993: LD_INT 108
2995: PPUSH
2996: LD_INT 62
2998: PPUSH
2999: LD_INT 2
3001: PPUSH
3002: LD_INT 0
3004: PPUSH
3005: CALL_OW 50
// farmerSquad := farmerSquad union un ;
3009: LD_ADDR_EXP 39
3013: PUSH
3014: LD_EXP 39
3018: PUSH
3019: LD_VAR 0 3
3023: UNION
3024: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
3025: LD_VAR 0 3
3029: PPUSH
3030: LD_EXP 37
3034: PPUSH
3035: CALL_OW 119
// end ;
3039: GO 2962
3041: POP
3042: POP
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
3043: LD_INT 109
3045: PPUSH
3046: LD_INT 63
3048: PPUSH
3049: LD_INT 2
3051: PPUSH
3052: LD_INT 15
3054: NEG
3055: PPUSH
3056: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
3060: LD_INT 109
3062: PPUSH
3063: LD_INT 63
3065: PPUSH
3066: LD_INT 2
3068: PPUSH
3069: CALL_OW 331
// end ;
3073: LD_VAR 0 1
3077: RET
// export function PrepareIbrahim ( x , y ) ; begin
3078: LD_INT 0
3080: PPUSH
// uc_side := 6 ;
3081: LD_ADDR_OWVAR 20
3085: PUSH
3086: LD_INT 6
3088: ST_TO_ADDR
// uc_nation := 3 ;
3089: LD_ADDR_OWVAR 21
3093: PUSH
3094: LD_INT 3
3096: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3097: LD_ADDR_EXP 38
3101: PUSH
3102: LD_STRING IbrahimRu
3104: PPUSH
3105: LD_INT 0
3107: PPUSH
3108: LD_STRING 
3110: PPUSH
3111: CALL 313 0 3
3115: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3116: LD_EXP 38
3120: PPUSH
3121: LD_VAR 0 1
3125: PPUSH
3126: LD_VAR 0 2
3130: PPUSH
3131: LD_INT 8
3133: PPUSH
3134: LD_INT 1
3136: PPUSH
3137: CALL_OW 50
// end ;
3141: LD_VAR 0 3
3145: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3146: LD_EXP 37
3150: PUSH
3151: LD_EXP 40
3155: ADD
3156: PPUSH
3157: LD_INT 95
3159: PUSH
3160: LD_INT 3
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL_OW 72
3171: IFFALSE 3227
3173: GO 3175
3175: DISABLE
3176: LD_INT 0
3178: PPUSH
// begin enable ;
3179: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3180: LD_ADDR_VAR 0 1
3184: PUSH
3185: LD_EXP 37
3189: PUSH
3190: LD_EXP 40
3194: ADD
3195: PPUSH
3196: LD_INT 95
3198: PUSH
3199: LD_INT 3
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PPUSH
3206: CALL_OW 72
3210: PUSH
3211: FOR_IN
3212: IFFALSE 3225
// RemoveUnit ( i ) ;
3214: LD_VAR 0 1
3218: PPUSH
3219: CALL_OW 64
3223: GO 3211
3225: POP
3226: POP
// end ;
3227: PPOPN 1
3229: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3230: LD_EXP 3
3234: PUSH
3235: LD_EXP 36
3239: PPUSH
3240: LD_INT 4
3242: PPUSH
3243: CALL_OW 308
3247: AND
3248: IFFALSE 4031
3250: GO 3252
3252: DISABLE
3253: LD_INT 0
3255: PPUSH
3256: PPUSH
3257: PPUSH
3258: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3259: LD_EXP 36
3263: PPUSH
3264: LD_INT 110
3266: PPUSH
3267: LD_INT 60
3269: PPUSH
3270: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3274: LD_EXP 36
3278: PPUSH
3279: LD_INT 110
3281: PPUSH
3282: LD_INT 61
3284: PPUSH
3285: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3289: LD_ADDR_VAR 0 2
3293: PUSH
3294: LD_EXP 39
3298: PPUSH
3299: LD_INT 25
3301: PUSH
3302: LD_INT 1
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PPUSH
3309: CALL_OW 72
3313: ST_TO_ADDR
// if tmp then
3314: LD_VAR 0 2
3318: IFFALSE 3412
// begin for i := 1 to 2 do
3320: LD_ADDR_VAR 0 1
3324: PUSH
3325: DOUBLE
3326: LD_INT 1
3328: DEC
3329: ST_TO_ADDR
3330: LD_INT 2
3332: PUSH
3333: FOR_TO
3334: IFFALSE 3410
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3336: LD_VAR 0 2
3340: PUSH
3341: LD_VAR 0 1
3345: ARRAY
3346: PPUSH
3347: LD_INT 5
3349: PPUSH
3350: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3354: LD_VAR 0 2
3358: PUSH
3359: LD_VAR 0 1
3363: ARRAY
3364: PPUSH
3365: LD_INT 2
3367: PPUSH
3368: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3372: LD_VAR 0 2
3376: PUSH
3377: LD_VAR 0 1
3381: ARRAY
3382: PPUSH
3383: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3387: LD_VAR 0 2
3391: PUSH
3392: LD_VAR 0 1
3396: ARRAY
3397: PPUSH
3398: LD_INT 107
3400: PPUSH
3401: LD_INT 66
3403: PPUSH
3404: CALL_OW 171
// end ;
3408: GO 3333
3410: POP
3411: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3412: LD_ADDR_VAR 0 2
3416: PUSH
3417: LD_EXP 39
3421: PPUSH
3422: LD_INT 25
3424: PUSH
3425: LD_INT 2
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PPUSH
3432: CALL_OW 72
3436: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3437: LD_INT 35
3439: PPUSH
3440: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3444: LD_ADDR_VAR 0 2
3448: PUSH
3449: LD_EXP 39
3453: PPUSH
3454: LD_INT 25
3456: PUSH
3457: LD_INT 2
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: PPUSH
3464: CALL_OW 72
3468: ST_TO_ADDR
// until tmp ;
3469: LD_VAR 0 2
3473: IFFALSE 3437
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3475: LD_VAR 0 2
3479: PPUSH
3480: LD_INT 31
3482: PPUSH
3483: LD_INT 102
3485: PPUSH
3486: LD_INT 69
3488: PPUSH
3489: LD_INT 2
3491: PPUSH
3492: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3496: LD_INT 35
3498: PPUSH
3499: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3503: LD_EXP 39
3507: PPUSH
3508: LD_INT 3
3510: PUSH
3511: LD_INT 60
3513: PUSH
3514: EMPTY
3515: LIST
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: PUSH
3521: LD_INT 25
3523: PUSH
3524: LD_INT 2
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: PPUSH
3535: CALL_OW 72
3539: IFFALSE 3496
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: LD_EXP 39
3550: PPUSH
3551: LD_INT 25
3553: PUSH
3554: LD_INT 2
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: PPUSH
3561: CALL_OW 72
3565: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3566: LD_VAR 0 2
3570: PPUSH
3571: LD_INT 4
3573: PPUSH
3574: LD_INT 116
3576: PPUSH
3577: LD_INT 70
3579: PPUSH
3580: LD_INT 5
3582: PPUSH
3583: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3587: LD_VAR 0 2
3591: PPUSH
3592: LD_INT 31
3594: PPUSH
3595: LD_INT 108
3597: PPUSH
3598: LD_INT 50
3600: PPUSH
3601: LD_INT 2
3603: PPUSH
3604: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3608: LD_INT 35
3610: PPUSH
3611: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3615: LD_INT 22
3617: PUSH
3618: LD_INT 5
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: PUSH
3625: LD_INT 30
3627: PUSH
3628: LD_INT 4
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 3
3637: PUSH
3638: LD_INT 57
3640: PUSH
3641: EMPTY
3642: LIST
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: LIST
3652: PPUSH
3653: CALL_OW 69
3657: IFFALSE 3608
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3659: LD_ADDR_VAR 0 3
3663: PUSH
3664: LD_INT 22
3666: PUSH
3667: LD_INT 5
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: PUSH
3674: LD_INT 30
3676: PUSH
3677: LD_INT 4
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: PUSH
3684: LD_INT 3
3686: PUSH
3687: LD_INT 57
3689: PUSH
3690: EMPTY
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: LIST
3701: PPUSH
3702: CALL_OW 69
3706: PUSH
3707: LD_INT 1
3709: ARRAY
3710: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3711: LD_ADDR_VAR 0 2
3715: PUSH
3716: LD_EXP 39
3720: PPUSH
3721: LD_INT 25
3723: PUSH
3724: LD_INT 1
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PPUSH
3731: CALL_OW 72
3735: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3736: LD_VAR 0 2
3740: PPUSH
3741: LD_VAR 0 3
3745: PPUSH
3746: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3750: LD_INT 35
3752: PPUSH
3753: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3757: LD_INT 22
3759: PUSH
3760: LD_INT 5
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: LD_INT 30
3769: PUSH
3770: LD_INT 31
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 3
3779: PUSH
3780: LD_INT 57
3782: PUSH
3783: EMPTY
3784: LIST
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: LIST
3794: PPUSH
3795: CALL_OW 69
3799: PUSH
3800: LD_INT 2
3802: GREATEREQUAL
3803: IFFALSE 3750
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3805: LD_ADDR_VAR 0 2
3809: PUSH
3810: LD_EXP 39
3814: PPUSH
3815: LD_INT 25
3817: PUSH
3818: LD_INT 2
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PPUSH
3825: CALL_OW 72
3829: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3830: LD_VAR 0 2
3834: PUSH
3835: LD_INT 1
3837: ARRAY
3838: PPUSH
3839: LD_INT 5
3841: PPUSH
3842: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3846: LD_VAR 0 2
3850: PUSH
3851: LD_INT 2
3853: ARRAY
3854: PUSH
3855: LD_VAR 0 2
3859: PUSH
3860: LD_INT 3
3862: ARRAY
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: LD_VAR 0 3
3872: PPUSH
3873: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3877: LD_VAR 0 2
3881: PUSH
3882: LD_INT 2
3884: ARRAY
3885: PUSH
3886: LD_VAR 0 2
3890: PUSH
3891: LD_INT 3
3893: ARRAY
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PPUSH
3899: LD_INT 1
3901: PPUSH
3902: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3906: LD_VAR 0 2
3910: PUSH
3911: LD_INT 2
3913: ARRAY
3914: PUSH
3915: LD_VAR 0 2
3919: PUSH
3920: LD_INT 3
3922: ARRAY
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PPUSH
3928: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3932: LD_ADDR_VAR 0 4
3936: PUSH
3937: LD_INT 22
3939: PUSH
3940: LD_INT 5
3942: PUSH
3943: EMPTY
3944: LIST
3945: LIST
3946: PUSH
3947: LD_INT 30
3949: PUSH
3950: LD_INT 31
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: PUSH
3957: EMPTY
3958: LIST
3959: LIST
3960: PPUSH
3961: CALL_OW 69
3965: ST_TO_ADDR
// for i := 1 to 2 do
3966: LD_ADDR_VAR 0 1
3970: PUSH
3971: DOUBLE
3972: LD_INT 1
3974: DEC
3975: ST_TO_ADDR
3976: LD_INT 2
3978: PUSH
3979: FOR_TO
3980: IFFALSE 4014
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3982: LD_VAR 0 2
3986: PUSH
3987: LD_VAR 0 1
3991: PUSH
3992: LD_INT 1
3994: PLUS
3995: ARRAY
3996: PPUSH
3997: LD_VAR 0 4
4001: PUSH
4002: LD_VAR 0 1
4006: ARRAY
4007: PPUSH
4008: CALL_OW 180
4012: GO 3979
4014: POP
4015: POP
// wait ( 1 1$00 ) ;
4016: LD_INT 2100
4018: PPUSH
4019: CALL_OW 67
// farmerBaseReady := true ;
4023: LD_ADDR_EXP 4
4027: PUSH
4028: LD_INT 1
4030: ST_TO_ADDR
// end ;
4031: PPOPN 4
4033: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
4034: LD_EXP 4
4038: PUSH
4039: LD_EXP 11
4043: NOT
4044: AND
4045: IFFALSE 4567
4047: GO 4049
4049: DISABLE
4050: LD_INT 0
4052: PPUSH
4053: PPUSH
4054: PPUSH
4055: PPUSH
4056: PPUSH
// begin enable ;
4057: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
4058: LD_ADDR_VAR 0 3
4062: PUSH
4063: LD_EXP 39
4067: PPUSH
4068: LD_INT 25
4070: PUSH
4071: LD_INT 1
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: PPUSH
4078: CALL_OW 72
4082: PUSH
4083: LD_EXP 36
4087: ADD
4088: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4089: LD_ADDR_VAR 0 2
4093: PUSH
4094: LD_EXP 39
4098: PPUSH
4099: LD_INT 25
4101: PUSH
4102: LD_INT 2
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PPUSH
4109: CALL_OW 72
4113: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4114: LD_ADDR_VAR 0 5
4118: PUSH
4119: LD_INT 22
4121: PUSH
4122: LD_INT 5
4124: PUSH
4125: EMPTY
4126: LIST
4127: LIST
4128: PUSH
4129: LD_INT 21
4131: PUSH
4132: LD_INT 3
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PUSH
4139: LD_INT 3
4141: PUSH
4142: LD_INT 24
4144: PUSH
4145: LD_INT 1000
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: PUSH
4152: EMPTY
4153: LIST
4154: LIST
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: LIST
4160: PPUSH
4161: CALL_OW 69
4165: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4166: LD_ADDR_VAR 0 4
4170: PUSH
4171: LD_INT 22
4173: PUSH
4174: LD_INT 5
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: LD_INT 30
4183: PUSH
4184: LD_INT 4
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: PPUSH
4195: CALL_OW 69
4199: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4200: LD_VAR 0 4
4204: PUSH
4205: LD_INT 1
4207: ARRAY
4208: PPUSH
4209: CALL_OW 302
4213: IFFALSE 4277
// for i in sol do
4215: LD_ADDR_VAR 0 1
4219: PUSH
4220: LD_VAR 0 3
4224: PUSH
4225: FOR_IN
4226: IFFALSE 4275
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4228: LD_VAR 0 1
4232: PPUSH
4233: CALL_OW 256
4237: PUSH
4238: LD_INT 999
4240: LESS
4241: PUSH
4242: LD_VAR 0 1
4246: PPUSH
4247: CALL_OW 310
4251: NOT
4252: AND
4253: IFFALSE 4273
// ComEnterUnit ( i , arm [ 1 ] ) ;
4255: LD_VAR 0 1
4259: PPUSH
4260: LD_VAR 0 4
4264: PUSH
4265: LD_INT 1
4267: ARRAY
4268: PPUSH
4269: CALL_OW 120
4273: GO 4225
4275: POP
4276: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4277: LD_VAR 0 2
4281: NOT
4282: PUSH
4283: LD_INT 22
4285: PUSH
4286: LD_INT 1
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 21
4295: PUSH
4296: LD_INT 1
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PPUSH
4307: CALL_OW 69
4311: NOT
4312: AND
4313: IFFALSE 4405
// begin uc_side := 5 ;
4315: LD_ADDR_OWVAR 20
4319: PUSH
4320: LD_INT 5
4322: ST_TO_ADDR
// uc_nation := 2 ;
4323: LD_ADDR_OWVAR 21
4327: PUSH
4328: LD_INT 2
4330: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4331: LD_INT 0
4333: PPUSH
4334: LD_INT 2
4336: PPUSH
4337: LD_INT 2
4339: PPUSH
4340: CALL_OW 380
// eng := CreateHuman ;
4344: LD_ADDR_VAR 0 2
4348: PUSH
4349: CALL_OW 44
4353: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4354: LD_VAR 0 2
4358: PPUSH
4359: LD_INT 102
4361: PPUSH
4362: LD_INT 8
4364: PPUSH
4365: LD_INT 0
4367: PPUSH
4368: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4372: LD_VAR 0 2
4376: PPUSH
4377: LD_INT 110
4379: PPUSH
4380: LD_INT 60
4382: PPUSH
4383: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4387: LD_ADDR_EXP 39
4391: PUSH
4392: LD_EXP 39
4396: PUSH
4397: LD_VAR 0 2
4401: UNION
4402: ST_TO_ADDR
// end else
4403: GO 4567
// begin for i in eng do
4405: LD_ADDR_VAR 0 1
4409: PUSH
4410: LD_VAR 0 2
4414: PUSH
4415: FOR_IN
4416: IFFALSE 4565
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4418: LD_INT 10
4420: PPUSH
4421: LD_INT 1
4423: PPUSH
4424: CALL_OW 287
4428: IFFALSE 4479
// begin if IsInUnit ( i ) then
4430: LD_VAR 0 1
4434: PPUSH
4435: CALL_OW 310
4439: IFFALSE 4450
// ComExitBuilding ( i ) ;
4441: LD_VAR 0 1
4445: PPUSH
4446: CALL_OW 122
// if not IsInArea ( i , collectFarmerArea ) then
4450: LD_VAR 0 1
4454: PPUSH
4455: LD_INT 10
4457: PPUSH
4458: CALL_OW 308
4462: NOT
4463: IFFALSE 4477
// AddComMoveToArea ( i , collectFarmerArea ) ;
4465: LD_VAR 0 1
4469: PPUSH
4470: LD_INT 10
4472: PPUSH
4473: CALL_OW 173
// end else
4477: GO 4563
// begin if damagedBuilding then
4479: LD_VAR 0 5
4483: IFFALSE 4527
// begin if IsInUnit ( i ) then
4485: LD_VAR 0 1
4489: PPUSH
4490: CALL_OW 310
4494: IFFALSE 4507
// ComExitBuilding ( i ) else
4496: LD_VAR 0 1
4500: PPUSH
4501: CALL_OW 122
4505: GO 4525
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4507: LD_VAR 0 1
4511: PPUSH
4512: LD_VAR 0 5
4516: PUSH
4517: LD_INT 1
4519: ARRAY
4520: PPUSH
4521: CALL_OW 130
// end else
4525: GO 4563
// if not IsInUnit ( i ) and not HasTask ( i ) then
4527: LD_VAR 0 1
4531: PPUSH
4532: CALL_OW 310
4536: NOT
4537: PUSH
4538: LD_VAR 0 1
4542: PPUSH
4543: CALL_OW 314
4547: NOT
4548: AND
4549: IFFALSE 4563
// ComEnterUnit ( i , arDepot ) ;
4551: LD_VAR 0 1
4555: PPUSH
4556: LD_INT 5
4558: PPUSH
4559: CALL_OW 120
// end ; end ;
4563: GO 4415
4565: POP
4566: POP
// end ; end ;
4567: PPOPN 5
4569: END
// export function StartCargoEvacuation ; begin
4570: LD_INT 0
4572: PPUSH
// while omarCargoCounter > 0 do
4573: LD_EXP 21
4577: PUSH
4578: LD_INT 0
4580: GREATER
4581: IFFALSE 4898
// begin wait ( 0 0$40 ) ;
4583: LD_INT 1400
4585: PPUSH
4586: CALL_OW 67
// omarCargo := PrepareCargo ;
4590: LD_ADDR_EXP 43
4594: PUSH
4595: CALL 4903 0 0
4599: ST_TO_ADDR
// SetTag ( omarCargo , 0 ) ;
4600: LD_EXP 43
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 109
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4612: LD_EXP 43
4616: PPUSH
4617: LD_INT 107
4619: PPUSH
4620: LD_INT 59
4622: PPUSH
4623: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4627: LD_INT 35
4629: PPUSH
4630: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4634: LD_EXP 43
4638: PPUSH
4639: LD_INT 107
4641: PPUSH
4642: LD_INT 59
4644: PPUSH
4645: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4649: LD_EXP 43
4653: PPUSH
4654: CALL_OW 302
4658: NOT
4659: PUSH
4660: LD_EXP 43
4664: PPUSH
4665: CALL_OW 301
4669: OR
4670: IFFALSE 4674
// continue ;
4672: GO 4627
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4674: LD_EXP 43
4678: PPUSH
4679: LD_INT 107
4681: PPUSH
4682: LD_INT 59
4684: PPUSH
4685: CALL_OW 307
4689: PUSH
4690: LD_EXP 43
4694: PPUSH
4695: LD_INT 5
4697: PPUSH
4698: CALL_OW 296
4702: PUSH
4703: LD_INT 6
4705: LESS
4706: OR
4707: IFFALSE 4627
// SetTag ( omarCargo , 1 ) ;
4709: LD_EXP 43
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 109
// wait ( 0 0$05 ) ;
4721: LD_INT 175
4723: PPUSH
4724: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4728: LD_EXP 43
4732: PPUSH
4733: LD_INT 5
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4743: LD_EXP 43
4747: PPUSH
4748: LD_INT 103
4750: PPUSH
4751: LD_INT 9
4753: PPUSH
4754: CALL_OW 171
// wait ( 0 0$1 ) ;
4758: LD_INT 35
4760: PPUSH
4761: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
4765: LD_EXP 43
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 100
4775: PPUSH
4776: CALL_OW 290
// repeat wait ( 0 0$1 ) ;
4780: LD_INT 35
4782: PPUSH
4783: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4787: LD_EXP 43
4791: PPUSH
4792: LD_INT 103
4794: PPUSH
4795: LD_INT 9
4797: PPUSH
4798: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4802: LD_EXP 43
4806: PPUSH
4807: CALL_OW 302
4811: NOT
4812: PUSH
4813: LD_EXP 43
4817: PPUSH
4818: CALL_OW 301
4822: OR
4823: IFFALSE 4827
// continue ;
4825: GO 4780
// until ( IsAt ( omarCargo , 103 , 9 ) or IsInArea ( omarCargo , northRoad ) ) and GetTag ( omarCargo ) > 0 ;
4827: LD_EXP 43
4831: PPUSH
4832: LD_INT 103
4834: PPUSH
4835: LD_INT 9
4837: PPUSH
4838: CALL_OW 307
4842: PUSH
4843: LD_EXP 43
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 308
4855: OR
4856: PUSH
4857: LD_EXP 43
4861: PPUSH
4862: CALL_OW 110
4866: PUSH
4867: LD_INT 0
4869: GREATER
4870: AND
4871: IFFALSE 4780
// RemoveUnit ( omarCargo ) ;
4873: LD_EXP 43
4877: PPUSH
4878: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4882: LD_ADDR_EXP 21
4886: PUSH
4887: LD_EXP 21
4891: PUSH
4892: LD_INT 1
4894: MINUS
4895: ST_TO_ADDR
// end ;
4896: GO 4573
// end ;
4898: LD_VAR 0 1
4902: RET
// export function PrepareCargo ; var un , veh ; begin
4903: LD_INT 0
4905: PPUSH
4906: PPUSH
4907: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4908: LD_ADDR_VAR 0 3
4912: PUSH
4913: LD_INT 5
4915: PPUSH
4916: LD_INT 2
4918: PPUSH
4919: LD_INT 13
4921: PPUSH
4922: LD_INT 1
4924: PPUSH
4925: LD_INT 1
4927: PPUSH
4928: LD_INT 32
4930: PPUSH
4931: LD_INT 80
4933: PPUSH
4934: CALL 376 0 7
4938: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4939: LD_VAR 0 3
4943: PPUSH
4944: LD_INT 4
4946: PPUSH
4947: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4951: LD_VAR 0 3
4955: PPUSH
4956: LD_INT 101
4958: PPUSH
4959: LD_INT 8
4961: PPUSH
4962: LD_INT 0
4964: PPUSH
4965: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4969: LD_INT 0
4971: PPUSH
4972: LD_INT 3
4974: PPUSH
4975: LD_INT 2
4977: PPUSH
4978: CALL_OW 380
// un := CreateHuman ;
4982: LD_ADDR_VAR 0 2
4986: PUSH
4987: CALL_OW 44
4991: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4992: LD_VAR 0 2
4996: PPUSH
4997: LD_VAR 0 3
5001: PPUSH
5002: CALL_OW 52
// result := veh ;
5006: LD_ADDR_VAR 0 1
5010: PUSH
5011: LD_VAR 0 3
5015: ST_TO_ADDR
// end ; end_of_file
5016: LD_VAR 0 1
5020: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
5021: LD_INT 0
5023: PPUSH
5024: PPUSH
5025: PPUSH
// usForces := [ ] ;
5026: LD_ADDR_EXP 44
5030: PUSH
5031: EMPTY
5032: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
5033: LD_ADDR_EXP 46
5037: PUSH
5038: LD_INT 6
5040: PUSH
5041: LD_INT 32
5043: PUSH
5044: LD_INT 27
5046: PUSH
5047: LD_INT 1
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 4
5058: PUSH
5059: LD_INT 43
5061: PUSH
5062: LD_INT 24
5064: PUSH
5065: LD_INT 5
5067: PUSH
5068: EMPTY
5069: LIST
5070: LIST
5071: LIST
5072: LIST
5073: PUSH
5074: LD_INT 27
5076: PUSH
5077: LD_INT 29
5079: PUSH
5080: LD_INT 21
5082: PUSH
5083: LD_INT 0
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: LIST
5090: LIST
5091: PUSH
5092: EMPTY
5093: LIST
5094: LIST
5095: LIST
5096: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
5097: LD_INT 11
5099: PPUSH
5100: CALL_OW 274
5104: PPUSH
5105: LD_INT 1
5107: PPUSH
5108: LD_INT 150
5110: PUSH
5111: LD_INT 120
5113: PUSH
5114: LD_INT 100
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: PUSH
5122: LD_OWVAR 67
5126: ARRAY
5127: PPUSH
5128: CALL_OW 277
// if Difficulty = 1 then
5132: LD_OWVAR 67
5136: PUSH
5137: LD_INT 1
5139: EQUAL
5140: IFFALSE 5149
// RemoveUnit ( hillBun ) ;
5142: LD_INT 14
5144: PPUSH
5145: CALL_OW 64
// uc_side := 1 ;
5149: LD_ADDR_OWVAR 20
5153: PUSH
5154: LD_INT 1
5156: ST_TO_ADDR
// uc_nation := 1 ;
5157: LD_ADDR_OWVAR 21
5161: PUSH
5162: LD_INT 1
5164: ST_TO_ADDR
// hc_gallery :=  ;
5165: LD_ADDR_OWVAR 33
5169: PUSH
5170: LD_STRING 
5172: ST_TO_ADDR
// hc_name :=  ;
5173: LD_ADDR_OWVAR 26
5177: PUSH
5178: LD_STRING 
5180: ST_TO_ADDR
// hc_importance := 0 ;
5181: LD_ADDR_OWVAR 32
5185: PUSH
5186: LD_INT 0
5188: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5189: LD_INT 1
5191: PPUSH
5192: LD_INT 1
5194: PPUSH
5195: LD_INT 3
5197: PPUSH
5198: CALL_OW 380
// usCommander := CreateHuman ;
5202: LD_ADDR_EXP 45
5206: PUSH
5207: CALL_OW 44
5211: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5212: LD_EXP 45
5216: PPUSH
5217: LD_INT 11
5219: PPUSH
5220: CALL_OW 52
// if Difficulty > 1 then
5224: LD_OWVAR 67
5228: PUSH
5229: LD_INT 1
5231: GREATER
5232: IFFALSE 5314
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5234: LD_INT 0
5236: PPUSH
5237: LD_INT 1
5239: PPUSH
5240: LD_INT 1
5242: PUSH
5243: LD_INT 2
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: LIST
5253: PUSH
5254: LD_OWVAR 67
5258: ARRAY
5259: PPUSH
5260: CALL_OW 380
// un := CreateHuman ;
5264: LD_ADDR_VAR 0 3
5268: PUSH
5269: CALL_OW 44
5273: ST_TO_ADDR
// usForces := usForces union un ;
5274: LD_ADDR_EXP 44
5278: PUSH
5279: LD_EXP 44
5283: PUSH
5284: LD_VAR 0 3
5288: UNION
5289: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5290: LD_VAR 0 3
5294: PPUSH
5295: LD_INT 1
5297: PPUSH
5298: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5302: LD_VAR 0 3
5306: PPUSH
5307: LD_INT 14
5309: PPUSH
5310: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5314: LD_ADDR_VAR 0 2
5318: PUSH
5319: DOUBLE
5320: LD_INT 1
5322: DEC
5323: ST_TO_ADDR
5324: LD_INT 2
5326: PUSH
5327: LD_INT 3
5329: PUSH
5330: LD_INT 4
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PUSH
5344: FOR_TO
5345: IFFALSE 5487
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5347: LD_INT 0
5349: PPUSH
5350: LD_INT 1
5352: PPUSH
5353: LD_INT 1
5355: PUSH
5356: LD_INT 2
5358: PUSH
5359: LD_INT 3
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: LIST
5366: PUSH
5367: LD_OWVAR 67
5371: ARRAY
5372: PPUSH
5373: CALL_OW 380
// un := CreateHuman ;
5377: LD_ADDR_VAR 0 3
5381: PUSH
5382: CALL_OW 44
5386: ST_TO_ADDR
// usForces := usForces union un ;
5387: LD_ADDR_EXP 44
5391: PUSH
5392: LD_EXP 44
5396: PUSH
5397: LD_VAR 0 3
5401: UNION
5402: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5403: LD_VAR 0 3
5407: PPUSH
5408: LD_INT 39
5410: PPUSH
5411: LD_INT 24
5413: PPUSH
5414: LD_INT 4
5416: PPUSH
5417: LD_INT 0
5419: PPUSH
5420: CALL_OW 50
// if i < 3 then
5424: LD_VAR 0 2
5428: PUSH
5429: LD_INT 3
5431: LESS
5432: IFFALSE 5485
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5434: LD_VAR 0 3
5438: PPUSH
5439: LD_INT 22
5441: PUSH
5442: LD_INT 1
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 58
5451: PUSH
5452: EMPTY
5453: LIST
5454: PUSH
5455: LD_INT 30
5457: PUSH
5458: LD_INT 31
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: PPUSH
5470: CALL_OW 69
5474: PUSH
5475: LD_VAR 0 2
5479: ARRAY
5480: PPUSH
5481: CALL_OW 120
// end ;
5485: GO 5344
5487: POP
5488: POP
// for i := 1 to 2 do
5489: LD_ADDR_VAR 0 2
5493: PUSH
5494: DOUBLE
5495: LD_INT 1
5497: DEC
5498: ST_TO_ADDR
5499: LD_INT 2
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5567
// begin PrepareHuman ( false , 2 , 2 ) ;
5505: LD_INT 0
5507: PPUSH
5508: LD_INT 2
5510: PPUSH
5511: LD_INT 2
5513: PPUSH
5514: CALL_OW 380
// un := CreateHuman ;
5518: LD_ADDR_VAR 0 3
5522: PUSH
5523: CALL_OW 44
5527: ST_TO_ADDR
// usForces := usForces union un ;
5528: LD_ADDR_EXP 44
5532: PUSH
5533: LD_EXP 44
5537: PUSH
5538: LD_VAR 0 3
5542: UNION
5543: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5544: LD_VAR 0 3
5548: PPUSH
5549: LD_INT 39
5551: PPUSH
5552: LD_INT 24
5554: PPUSH
5555: LD_INT 4
5557: PPUSH
5558: LD_INT 0
5560: PPUSH
5561: CALL_OW 50
// end ;
5565: GO 5502
5567: POP
5568: POP
// PrepareHuman ( false , 4 , 1 ) ;
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 4
5574: PPUSH
5575: LD_INT 1
5577: PPUSH
5578: CALL_OW 380
// un := CreateHuman ;
5582: LD_ADDR_VAR 0 3
5586: PUSH
5587: CALL_OW 44
5591: ST_TO_ADDR
// usForces := usForces union un ;
5592: LD_ADDR_EXP 44
5596: PUSH
5597: LD_EXP 44
5601: PUSH
5602: LD_VAR 0 3
5606: UNION
5607: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5608: LD_VAR 0 3
5612: PPUSH
5613: LD_INT 39
5615: PPUSH
5616: LD_INT 24
5618: PPUSH
5619: LD_INT 4
5621: PPUSH
5622: LD_INT 0
5624: PPUSH
5625: CALL_OW 50
// end ;
5629: LD_VAR 0 1
5633: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured and not americanStartRun do var i , b , eng , sol , sci ;
5634: LD_EXP 44
5638: PUSH
5639: LD_EXP 6
5643: NOT
5644: AND
5645: PUSH
5646: LD_EXP 14
5650: NOT
5651: AND
5652: IFFALSE 6083
5654: GO 5656
5656: DISABLE
5657: LD_INT 0
5659: PPUSH
5660: PPUSH
5661: PPUSH
5662: PPUSH
5663: PPUSH
// begin enable ;
5664: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5665: LD_ADDR_VAR 0 3
5669: PUSH
5670: LD_EXP 44
5674: PPUSH
5675: LD_INT 25
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PPUSH
5685: CALL_OW 72
5689: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5690: LD_ADDR_VAR 0 4
5694: PUSH
5695: LD_EXP 44
5699: PPUSH
5700: LD_INT 25
5702: PUSH
5703: LD_INT 1
5705: PUSH
5706: EMPTY
5707: LIST
5708: LIST
5709: PPUSH
5710: CALL_OW 72
5714: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5715: LD_ADDR_VAR 0 5
5719: PUSH
5720: LD_EXP 44
5724: PPUSH
5725: LD_INT 25
5727: PUSH
5728: LD_INT 4
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PPUSH
5735: CALL_OW 72
5739: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5740: LD_INT 7
5742: PPUSH
5743: LD_INT 22
5745: PUSH
5746: LD_INT 2
5748: PUSH
5749: EMPTY
5750: LIST
5751: LIST
5752: PPUSH
5753: CALL_OW 70
5757: PUSH
5758: LD_INT 1
5760: EQUAL
5761: IFFALSE 5837
// for i in sol do
5763: LD_ADDR_VAR 0 1
5767: PUSH
5768: LD_VAR 0 4
5772: PUSH
5773: FOR_IN
5774: IFFALSE 5835
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5776: LD_VAR 0 1
5780: PPUSH
5781: CALL_OW 310
5785: NOT
5786: PUSH
5787: LD_VAR 0 1
5791: PPUSH
5792: CALL_OW 310
5796: PPUSH
5797: CALL_OW 266
5801: PUSH
5802: LD_INT 4
5804: EQUAL
5805: NOT
5806: OR
5807: IFFALSE 5833
// begin ComExitBuilding ( i ) ;
5809: LD_VAR 0 1
5813: PPUSH
5814: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5818: LD_VAR 0 1
5822: PPUSH
5823: LD_INT 37
5825: PPUSH
5826: LD_INT 23
5828: PPUSH
5829: CALL_OW 174
// end ;
5833: GO 5773
5835: POP
5836: POP
// if eng then
5837: LD_VAR 0 3
5841: IFFALSE 6083
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 22
5850: PUSH
5851: LD_INT 1
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 95
5860: PUSH
5861: LD_INT 7
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 21
5870: PUSH
5871: LD_INT 3
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 3
5880: PUSH
5881: LD_INT 24
5883: PUSH
5884: LD_INT 1000
5886: PUSH
5887: EMPTY
5888: LIST
5889: LIST
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: PPUSH
5901: CALL_OW 69
5905: ST_TO_ADDR
// if b then
5906: LD_VAR 0 2
5910: IFFALSE 5941
// begin ComExitBuilding ( eng ) ;
5912: LD_VAR 0 3
5916: PPUSH
5917: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5921: LD_VAR 0 3
5925: PPUSH
5926: LD_VAR 0 2
5930: PUSH
5931: LD_INT 1
5933: ARRAY
5934: PPUSH
5935: CALL_OW 190
// end else
5939: GO 6083
// begin for i in eng do
5941: LD_ADDR_VAR 0 1
5945: PUSH
5946: LD_VAR 0 3
5950: PUSH
5951: FOR_IN
5952: IFFALSE 6081
// if not HasTask ( i ) then
5954: LD_VAR 0 1
5958: PPUSH
5959: CALL_OW 314
5963: NOT
5964: IFFALSE 6079
// begin if americanBuildList then
5966: LD_EXP 46
5970: IFFALSE 6055
// begin if IsInUnit ( i ) then
5972: LD_VAR 0 1
5976: PPUSH
5977: CALL_OW 310
5981: IFFALSE 5992
// ComExitBuilding ( i ) ;
5983: LD_VAR 0 1
5987: PPUSH
5988: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5992: LD_VAR 0 1
5996: PPUSH
5997: LD_EXP 46
6001: PUSH
6002: LD_INT 1
6004: ARRAY
6005: PUSH
6006: LD_INT 1
6008: ARRAY
6009: PPUSH
6010: LD_EXP 46
6014: PUSH
6015: LD_INT 1
6017: ARRAY
6018: PUSH
6019: LD_INT 2
6021: ARRAY
6022: PPUSH
6023: LD_EXP 46
6027: PUSH
6028: LD_INT 1
6030: ARRAY
6031: PUSH
6032: LD_INT 3
6034: ARRAY
6035: PPUSH
6036: LD_EXP 46
6040: PUSH
6041: LD_INT 1
6043: ARRAY
6044: PUSH
6045: LD_INT 4
6047: ARRAY
6048: PPUSH
6049: CALL_OW 205
// end else
6053: GO 6079
// if not IsInUnit ( i ) then
6055: LD_VAR 0 1
6059: PPUSH
6060: CALL_OW 310
6064: NOT
6065: IFFALSE 6079
// ComEnterUnit ( i , usDepot ) ;
6067: LD_VAR 0 1
6071: PPUSH
6072: LD_INT 11
6074: PPUSH
6075: CALL_OW 120
// end ;
6079: GO 5951
6081: POP
6082: POP
// end ; end ; end ;
6083: PPOPN 5
6085: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
6086: LD_INT 0
6088: PPUSH
6089: PPUSH
6090: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
6091: LD_ADDR_VAR 0 3
6095: PUSH
6096: LD_INT 35
6098: PUSH
6099: LD_INT 45
6101: PUSH
6102: LD_INT 48
6104: PUSH
6105: LD_EXP 57
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: LIST
6115: ST_TO_ADDR
// for i in tech do
6116: LD_ADDR_VAR 0 4
6120: PUSH
6121: LD_VAR 0 3
6125: PUSH
6126: FOR_IN
6127: IFFALSE 6145
// AddComResearch ( lab , i ) ;
6129: LD_VAR 0 1
6133: PPUSH
6134: LD_VAR 0 4
6138: PPUSH
6139: CALL_OW 184
6143: GO 6126
6145: POP
6146: POP
// end ;
6147: LD_VAR 0 2
6151: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
6152: LD_EXP 12
6156: PUSH
6157: LD_EXP 23
6161: PUSH
6162: LD_EXP 27
6166: LESSEQUAL
6167: AND
6168: IFFALSE 6193
6170: GO 6172
6172: DISABLE
// begin enable ;
6173: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6174: LD_INT 35
6176: PPUSH
6177: LD_INT 2065
6179: PPUSH
6180: CALL_OW 12
6184: PPUSH
6185: CALL_OW 67
// SendConvoy ;
6189: CALL 6291 0 0
// end ;
6193: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6194: LD_EXP 6
6198: PUSH
6199: LD_EXP 18
6203: AND
6204: IFFALSE 6290
6206: GO 6208
6208: DISABLE
// begin if americanHasEscaped then
6209: LD_EXP 8
6213: IFFALSE 6224
// wait ( 3 3$20 ) else
6215: LD_INT 7000
6217: PPUSH
6218: CALL_OW 67
6222: GO 6231
// wait ( 6 6$40 ) ;
6224: LD_INT 14000
6226: PPUSH
6227: CALL_OW 67
// SendAttack ;
6231: CALL 7034 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6235: LD_INT 14000
6237: PUSH
6238: LD_INT 11900
6240: PUSH
6241: LD_INT 9800
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: LIST
6248: PUSH
6249: LD_OWVAR 67
6253: ARRAY
6254: PPUSH
6255: CALL_OW 67
// SendAttack ;
6259: CALL 7034 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6263: LD_EXP 19
6267: PUSH
6268: LD_INT 6
6270: PUSH
6271: LD_INT 7
6273: PUSH
6274: LD_INT 8
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_OWVAR 67
6286: ARRAY
6287: LESS
6288: IFFALSE 6235
// end ;
6290: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6291: LD_INT 0
6293: PPUSH
6294: PPUSH
6295: PPUSH
6296: PPUSH
6297: PPUSH
6298: PPUSH
6299: PPUSH
6300: PPUSH
// road := rand ( 1 , 2 ) ;
6301: LD_ADDR_VAR 0 4
6305: PUSH
6306: LD_INT 1
6308: PPUSH
6309: LD_INT 2
6311: PPUSH
6312: CALL_OW 12
6316: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6317: LD_ADDR_VAR 0 8
6321: PUSH
6322: LD_INT 3
6324: PUSH
6325: LD_INT 8
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: PUSH
6332: LD_VAR 0 4
6336: ARRAY
6337: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6338: LD_ADDR_VAR 0 5
6342: PUSH
6343: LD_INT 35
6345: PUSH
6346: LD_INT 66
6348: PUSH
6349: LD_INT 1
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: LIST
6356: PUSH
6357: LD_INT 101
6359: PUSH
6360: LD_INT 8
6362: PUSH
6363: LD_INT 4
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: LIST
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6375: LD_ADDR_VAR 0 6
6379: PUSH
6380: LD_INT 34
6382: PUSH
6383: LD_INT 67
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: PUSH
6390: LD_INT 38
6392: PUSH
6393: LD_INT 62
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: PUSH
6400: LD_INT 43
6402: PUSH
6403: LD_INT 54
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 57
6412: PUSH
6413: LD_INT 57
6415: PUSH
6416: EMPTY
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 77
6422: PUSH
6423: LD_INT 71
6425: PUSH
6426: EMPTY
6427: LIST
6428: LIST
6429: PUSH
6430: LD_INT 86
6432: PUSH
6433: LD_INT 60
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: LD_INT 89
6442: PUSH
6443: LD_INT 35
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: PUSH
6450: LD_INT 93
6452: PUSH
6453: LD_INT 17
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 97
6462: PUSH
6463: LD_INT 10
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 103
6472: PUSH
6473: LD_INT 9
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: LIST
6491: ST_TO_ADDR
// if road = 2 then
6492: LD_VAR 0 4
6496: PUSH
6497: LD_INT 2
6499: EQUAL
6500: IFFALSE 6517
// points := ReverseArray ( points ) ;
6502: LD_ADDR_VAR 0 6
6506: PUSH
6507: LD_VAR 0 6
6511: PPUSH
6512: CALL 1064 0 1
6516: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6517: LD_INT 4
6519: PPUSH
6520: LD_INT 1
6522: PPUSH
6523: LD_INT 2
6525: PPUSH
6526: LD_INT 1
6528: PPUSH
6529: LD_INT 1
6531: PPUSH
6532: LD_INT 12
6534: PPUSH
6535: LD_INT 80
6537: PPUSH
6538: CALL 376 0 7
// veh := CreateVehicle ;
6542: LD_ADDR_VAR 0 3
6546: PUSH
6547: CALL_OW 45
6551: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6552: LD_VAR 0 3
6556: PPUSH
6557: LD_VAR 0 5
6561: PUSH
6562: LD_VAR 0 4
6566: ARRAY
6567: PUSH
6568: LD_INT 3
6570: ARRAY
6571: PPUSH
6572: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6576: LD_VAR 0 3
6580: PPUSH
6581: LD_VAR 0 5
6585: PUSH
6586: LD_VAR 0 4
6590: ARRAY
6591: PUSH
6592: LD_INT 1
6594: ARRAY
6595: PPUSH
6596: LD_VAR 0 5
6600: PUSH
6601: LD_VAR 0 4
6605: ARRAY
6606: PUSH
6607: LD_INT 2
6609: ARRAY
6610: PPUSH
6611: LD_INT 0
6613: PPUSH
6614: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6618: LD_INT 0
6620: PPUSH
6621: LD_INT 1
6623: PPUSH
6624: LD_OWVAR 67
6628: PPUSH
6629: CALL_OW 380
// un := CreateHuman ;
6633: LD_ADDR_VAR 0 2
6637: PUSH
6638: CALL_OW 44
6642: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6643: LD_VAR 0 2
6647: PPUSH
6648: LD_VAR 0 3
6652: PPUSH
6653: CALL_OW 52
// if ( Prob ( [ 60 , 56 , 52 ] [ Difficulty ] ) + tick mod 30 ) or convoyCounter < 4 then
6657: LD_INT 60
6659: PUSH
6660: LD_INT 56
6662: PUSH
6663: LD_INT 52
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: LIST
6670: PUSH
6671: LD_OWVAR 67
6675: ARRAY
6676: PPUSH
6677: CALL_OW 13
6681: PUSH
6682: LD_OWVAR 1
6686: PUSH
6687: LD_INT 30
6689: MOD
6690: PLUS
6691: PUSH
6692: LD_EXP 23
6696: PUSH
6697: LD_INT 4
6699: LESS
6700: OR
6701: IFFALSE 6718
// SetCargo ( veh , mat_cans , 100 ) ;
6703: LD_VAR 0 3
6707: PPUSH
6708: LD_INT 1
6710: PPUSH
6711: LD_INT 100
6713: PPUSH
6714: CALL_OW 290
// for i := 2 to points do
6718: LD_ADDR_VAR 0 7
6722: PUSH
6723: DOUBLE
6724: LD_INT 2
6726: DEC
6727: ST_TO_ADDR
6728: LD_VAR 0 6
6732: PUSH
6733: FOR_TO
6734: IFFALSE 6777
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6736: LD_VAR 0 3
6740: PPUSH
6741: LD_VAR 0 6
6745: PUSH
6746: LD_VAR 0 7
6750: ARRAY
6751: PUSH
6752: LD_INT 1
6754: ARRAY
6755: PPUSH
6756: LD_VAR 0 6
6760: PUSH
6761: LD_VAR 0 7
6765: ARRAY
6766: PUSH
6767: LD_INT 2
6769: ARRAY
6770: PPUSH
6771: CALL_OW 171
6775: GO 6733
6777: POP
6778: POP
// convoyCounter := convoyCounter + 1 ;
6779: LD_ADDR_EXP 23
6783: PUSH
6784: LD_EXP 23
6788: PUSH
6789: LD_INT 1
6791: PLUS
6792: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6793: LD_INT 35
6795: PPUSH
6796: CALL_OW 67
// if not HasTask ( veh ) and IsOk ( veh ) then
6800: LD_VAR 0 3
6804: PPUSH
6805: CALL_OW 314
6809: NOT
6810: PUSH
6811: LD_VAR 0 3
6815: PPUSH
6816: CALL_OW 302
6820: AND
6821: IFFALSE 6862
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6823: LD_VAR 0 3
6827: PPUSH
6828: LD_VAR 0 6
6832: PUSH
6833: LD_VAR 0 6
6837: ARRAY
6838: PUSH
6839: LD_INT 1
6841: ARRAY
6842: PPUSH
6843: LD_VAR 0 6
6847: PUSH
6848: LD_VAR 0 6
6852: ARRAY
6853: PUSH
6854: LD_INT 2
6856: ARRAY
6857: PPUSH
6858: CALL_OW 111
// if not IsInUnit ( un ) then
6862: LD_VAR 0 2
6866: PPUSH
6867: CALL_OW 310
6871: NOT
6872: IFFALSE 6913
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6874: LD_VAR 0 2
6878: PPUSH
6879: LD_VAR 0 6
6883: PUSH
6884: LD_VAR 0 6
6888: ARRAY
6889: PUSH
6890: LD_INT 1
6892: ARRAY
6893: PPUSH
6894: LD_VAR 0 6
6898: PUSH
6899: LD_VAR 0 6
6903: ARRAY
6904: PUSH
6905: LD_INT 2
6907: ARRAY
6908: PPUSH
6909: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6913: LD_VAR 0 3
6917: PPUSH
6918: LD_VAR 0 8
6922: PPUSH
6923: CALL_OW 308
6927: PUSH
6928: LD_VAR 0 2
6932: PPUSH
6933: LD_VAR 0 8
6937: PPUSH
6938: CALL_OW 308
6942: OR
6943: IFFALSE 6793
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6945: LD_VAR 0 2
6949: PPUSH
6950: CALL_OW 302
6954: PUSH
6955: LD_VAR 0 3
6959: PPUSH
6960: CALL_OW 302
6964: NOT
6965: AND
6966: PUSH
6967: LD_VAR 0 2
6971: PPUSH
6972: LD_VAR 0 8
6976: PPUSH
6977: CALL_OW 308
6981: AND
6982: IFFALSE 6993
// RemoveUnit ( un ) ;
6984: LD_VAR 0 2
6988: PPUSH
6989: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6993: LD_VAR 0 3
6997: PPUSH
6998: LD_VAR 0 8
7002: PPUSH
7003: CALL_OW 308
7007: PUSH
7008: LD_VAR 0 3
7012: PPUSH
7013: CALL_OW 302
7017: AND
7018: IFFALSE 7029
// RemoveUnit ( veh ) ;
7020: LD_VAR 0 3
7024: PPUSH
7025: CALL_OW 64
// end ;
7029: LD_VAR 0 1
7033: RET
// export function SendAttack ; var un , veh , i ; begin
7034: LD_INT 0
7036: PPUSH
7037: PPUSH
7038: PPUSH
7039: PPUSH
// IncomingAttack ;
7040: CALL 15744 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
7044: LD_INT 2100
7046: PPUSH
7047: LD_INT 3500
7049: PPUSH
7050: CALL_OW 12
7054: PPUSH
7055: CALL_OW 67
// for i := 1 to [ 3 , 4 , 4 ] [ Difficulty ] + attackWave div 3 do
7059: LD_ADDR_VAR 0 4
7063: PUSH
7064: DOUBLE
7065: LD_INT 1
7067: DEC
7068: ST_TO_ADDR
7069: LD_INT 3
7071: PUSH
7072: LD_INT 4
7074: PUSH
7075: LD_INT 4
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: LIST
7082: PUSH
7083: LD_OWVAR 67
7087: ARRAY
7088: PUSH
7089: LD_EXP 19
7093: PUSH
7094: LD_INT 3
7096: DIV
7097: PLUS
7098: PUSH
7099: FOR_TO
7100: IFFALSE 7212
// begin uc_side := 1 ;
7102: LD_ADDR_OWVAR 20
7106: PUSH
7107: LD_INT 1
7109: ST_TO_ADDR
// uc_nation := 1 ;
7110: LD_ADDR_OWVAR 21
7114: PUSH
7115: LD_INT 1
7117: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
7118: LD_INT 0
7120: PPUSH
7121: LD_INT 1
7123: PPUSH
7124: LD_INT 2
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: ARRAY
7143: PPUSH
7144: CALL_OW 380
// un := CreateHuman ;
7148: LD_ADDR_VAR 0 2
7152: PUSH
7153: CALL_OW 44
7157: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7158: LD_VAR 0 2
7162: PPUSH
7163: LD_INT 37
7165: PPUSH
7166: LD_INT 70
7168: PPUSH
7169: LD_INT 3
7171: PPUSH
7172: LD_INT 0
7174: PPUSH
7175: CALL_OW 50
// usAttackers := usAttackers union un ;
7179: LD_ADDR_EXP 47
7183: PUSH
7184: LD_EXP 47
7188: PUSH
7189: LD_VAR 0 2
7193: UNION
7194: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7195: LD_VAR 0 2
7199: PPUSH
7200: LD_INT 40
7202: PPUSH
7203: LD_INT 65
7205: PPUSH
7206: CALL_OW 111
// end ;
7210: GO 7099
7212: POP
7213: POP
// uc_side := 1 ;
7214: LD_ADDR_OWVAR 20
7218: PUSH
7219: LD_INT 1
7221: ST_TO_ADDR
// uc_nation := 1 ;
7222: LD_ADDR_OWVAR 21
7226: PUSH
7227: LD_INT 1
7229: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7230: LD_INT 0
7232: PPUSH
7233: LD_INT 4
7235: PPUSH
7236: LD_INT 2
7238: PPUSH
7239: CALL_OW 380
// un := CreateHuman ;
7243: LD_ADDR_VAR 0 2
7247: PUSH
7248: CALL_OW 44
7252: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7253: LD_VAR 0 2
7257: PPUSH
7258: LD_INT 37
7260: PPUSH
7261: LD_INT 70
7263: PPUSH
7264: LD_INT 3
7266: PPUSH
7267: LD_INT 0
7269: PPUSH
7270: CALL_OW 50
// usAttackers := usAttackers union un ;
7274: LD_ADDR_EXP 47
7278: PUSH
7279: LD_EXP 47
7283: PUSH
7284: LD_VAR 0 2
7288: UNION
7289: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7290: LD_VAR 0 2
7294: PPUSH
7295: LD_INT 40
7297: PPUSH
7298: LD_INT 65
7300: PPUSH
7301: CALL_OW 111
// for i := 1 to Difficulty + attackWave div 4 do
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: DOUBLE
7311: LD_INT 1
7313: DEC
7314: ST_TO_ADDR
7315: LD_OWVAR 67
7319: PUSH
7320: LD_EXP 19
7324: PUSH
7325: LD_INT 4
7327: DIV
7328: PLUS
7329: PUSH
7330: FOR_TO
7331: IFFALSE 7504
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7333: LD_ADDR_VAR 0 3
7337: PUSH
7338: LD_INT 1
7340: PPUSH
7341: LD_INT 1
7343: PPUSH
7344: LD_INT 2
7346: PPUSH
7347: LD_INT 1
7349: PPUSH
7350: LD_INT 1
7352: PPUSH
7353: LD_INT 4
7355: PUSH
7356: LD_INT 3
7358: PUSH
7359: LD_INT 2
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: PUSH
7367: LD_INT 1
7369: PPUSH
7370: LD_INT 3
7372: PPUSH
7373: CALL_OW 12
7377: ARRAY
7378: PPUSH
7379: LD_INT 90
7381: PPUSH
7382: CALL 376 0 7
7386: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7387: LD_VAR 0 3
7391: PPUSH
7392: LD_INT 35
7394: PPUSH
7395: LD_INT 65
7397: PPUSH
7398: LD_INT 0
7400: PPUSH
7401: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7405: LD_INT 0
7407: PPUSH
7408: LD_INT 3
7410: PPUSH
7411: LD_OWVAR 67
7415: PUSH
7416: LD_INT 1
7418: PLUS
7419: PPUSH
7420: CALL_OW 380
// un := CreateHuman ;
7424: LD_ADDR_VAR 0 2
7428: PUSH
7429: CALL_OW 44
7433: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7434: LD_VAR 0 2
7438: PPUSH
7439: LD_VAR 0 3
7443: PPUSH
7444: CALL_OW 52
// usAttackers := usAttackers union un ;
7448: LD_ADDR_EXP 47
7452: PUSH
7453: LD_EXP 47
7457: PUSH
7458: LD_VAR 0 2
7462: UNION
7463: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7464: LD_VAR 0 3
7468: PPUSH
7469: LD_INT 39
7471: PPUSH
7472: LD_INT 60
7474: PPUSH
7475: CALL_OW 111
// wait ( 0 0$3 ) ;
7479: LD_INT 105
7481: PPUSH
7482: CALL_OW 67
// usAttackers := usAttackers union veh ;
7486: LD_ADDR_EXP 47
7490: PUSH
7491: LD_EXP 47
7495: PUSH
7496: LD_VAR 0 3
7500: UNION
7501: ST_TO_ADDR
// end ;
7502: GO 7330
7504: POP
7505: POP
// attackWave := attackWave + 1 ;
7506: LD_ADDR_EXP 19
7510: PUSH
7511: LD_EXP 19
7515: PUSH
7516: LD_INT 1
7518: PLUS
7519: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7520: LD_EXP 24
7524: PPUSH
7525: CALL_OW 427
// end ;
7529: LD_VAR 0 1
7533: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7534: LD_INT 0
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
7543: PPUSH
7544: PPUSH
7545: PPUSH
7546: PPUSH
// if retreatAllowed then
7547: LD_EXP 11
7551: IFFALSE 7563
// strategy := 2 else
7553: LD_ADDR_VAR 0 5
7557: PUSH
7558: LD_INT 2
7560: ST_TO_ADDR
7561: GO 7579
// strategy := rand ( 0 , 2 ) ;
7563: LD_ADDR_VAR 0 5
7567: PUSH
7568: LD_INT 0
7570: PPUSH
7571: LD_INT 2
7573: PPUSH
7574: CALL_OW 12
7578: ST_TO_ADDR
// attackFormula := [ ] ;
7579: LD_ADDR_VAR 0 6
7583: PUSH
7584: EMPTY
7585: ST_TO_ADDR
// case strategy of 0 :
7586: LD_VAR 0 5
7590: PUSH
7591: LD_INT 0
7593: DOUBLE
7594: EQUAL
7595: IFTRUE 7599
7597: GO 7929
7599: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7600: LD_INT 11
7602: PPUSH
7603: LD_INT 22
7605: PUSH
7606: LD_INT 2
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 30
7615: PUSH
7616: LD_INT 4
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: PPUSH
7627: CALL_OW 70
7631: NOT
7632: IFFALSE 7704
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7634: LD_ADDR_VAR 0 6
7638: PUSH
7639: LD_INT 41
7641: PUSH
7642: LD_INT 34
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: PUSH
7649: EMPTY
7650: LIST
7651: PUSH
7652: LD_INT 53
7654: PUSH
7655: LD_INT 62
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 37
7664: PUSH
7665: LD_INT 63
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: LD_INT 44
7674: PUSH
7675: LD_INT 45
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: LD_INT 37
7684: PUSH
7685: LD_INT 28
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: ST_TO_ADDR
7702: GO 7927
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7704: LD_INT 12
7706: PPUSH
7707: LD_INT 22
7709: PUSH
7710: LD_INT 2
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PUSH
7717: LD_INT 2
7719: PUSH
7720: LD_INT 30
7722: PUSH
7723: LD_INT 4
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PUSH
7730: LD_INT 30
7732: PUSH
7733: LD_INT 31
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 30
7742: PUSH
7743: LD_INT 32
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PPUSH
7760: CALL_OW 70
7764: NOT
7765: IFFALSE 7848
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7767: LD_ADDR_VAR 0 6
7771: PUSH
7772: LD_INT 27
7774: PUSH
7775: LD_INT 42
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 27
7784: PUSH
7785: LD_INT 32
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: LD_INT 53
7798: PUSH
7799: LD_INT 62
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: LD_INT 37
7808: PUSH
7809: LD_INT 63
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 44
7818: PUSH
7819: LD_INT 45
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 37
7828: PUSH
7829: LD_INT 28
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: EMPTY
7837: LIST
7838: LIST
7839: PUSH
7840: EMPTY
7841: LIST
7842: LIST
7843: LIST
7844: LIST
7845: ST_TO_ADDR
7846: GO 7927
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7848: LD_ADDR_VAR 0 6
7852: PUSH
7853: LD_INT 71
7855: PUSH
7856: LD_INT 67
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 54
7865: PUSH
7866: LD_INT 35
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: PUSH
7877: LD_INT 63
7879: PUSH
7880: LD_INT 40
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PUSH
7887: LD_INT 37
7889: PUSH
7890: LD_INT 63
7892: PUSH
7893: EMPTY
7894: LIST
7895: LIST
7896: PUSH
7897: LD_INT 44
7899: PUSH
7900: LD_INT 45
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 37
7909: PUSH
7910: LD_INT 28
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: EMPTY
7918: LIST
7919: LIST
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: LIST
7926: ST_TO_ADDR
// end ; 1 :
7927: GO 8132
7929: LD_INT 1
7931: DOUBLE
7932: EQUAL
7933: IFTRUE 7937
7935: GO 8041
7937: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7938: LD_ADDR_VAR 0 6
7942: PUSH
7943: LD_INT 71
7945: PUSH
7946: LD_INT 67
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PUSH
7953: LD_INT 82
7955: PUSH
7956: LD_INT 23
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: PUSH
7963: LD_INT 53
7965: PUSH
7966: LD_INT 7
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PUSH
7973: LD_INT 43
7975: PUSH
7976: LD_INT 10
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 53
7991: PUSH
7992: LD_INT 62
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: PUSH
7999: LD_INT 37
8001: PUSH
8002: LD_INT 63
8004: PUSH
8005: EMPTY
8006: LIST
8007: LIST
8008: PUSH
8009: LD_INT 44
8011: PUSH
8012: LD_INT 45
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 37
8021: PUSH
8022: LD_INT 28
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: EMPTY
8034: LIST
8035: LIST
8036: LIST
8037: LIST
8038: ST_TO_ADDR
8039: GO 8132
8041: LD_INT 2
8043: DOUBLE
8044: EQUAL
8045: IFTRUE 8049
8047: GO 8131
8049: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
8050: LD_ADDR_VAR 0 6
8054: PUSH
8055: LD_INT 90
8057: PUSH
8058: LD_INT 59
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: PUSH
8065: LD_INT 108
8067: PUSH
8068: LD_INT 64
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: PUSH
8079: LD_INT 82
8081: PUSH
8082: LD_INT 75
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PUSH
8089: LD_INT 73
8091: PUSH
8092: LD_INT 67
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 101
8101: PUSH
8102: LD_INT 65
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 108
8111: PUSH
8112: LD_INT 62
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: LIST
8127: LIST
8128: ST_TO_ADDR
8129: GO 8132
8131: POP
// if not attackFormula then
8132: LD_VAR 0 6
8136: NOT
8137: IFFALSE 8141
// exit ;
8139: GO 9746
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8141: LD_ADDR_VAR 0 7
8145: PUSH
8146: LD_EXP 47
8150: PPUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 1
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PPUSH
8161: CALL_OW 72
8165: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8166: LD_ADDR_VAR 0 8
8170: PUSH
8171: LD_EXP 47
8175: PPUSH
8176: LD_INT 25
8178: PUSH
8179: LD_INT 4
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: PPUSH
8186: CALL_OW 72
8190: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8191: LD_ADDR_VAR 0 9
8195: PUSH
8196: LD_EXP 47
8200: PPUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 72
8215: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8216: LD_ADDR_VAR 0 10
8220: PUSH
8221: LD_EXP 47
8225: PPUSH
8226: LD_INT 21
8228: PUSH
8229: LD_INT 2
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PPUSH
8236: CALL_OW 72
8240: ST_TO_ADDR
// if sci then
8241: LD_VAR 0 8
8245: IFFALSE 8282
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8247: LD_VAR 0 8
8251: PPUSH
8252: LD_VAR 0 6
8256: PUSH
8257: LD_INT 2
8259: ARRAY
8260: PUSH
8261: LD_INT 1
8263: ARRAY
8264: PPUSH
8265: LD_VAR 0 6
8269: PUSH
8270: LD_INT 2
8272: ARRAY
8273: PUSH
8274: LD_INT 2
8276: ARRAY
8277: PPUSH
8278: CALL_OW 111
// repeat wait ( 10 ) ;
8282: LD_INT 10
8284: PPUSH
8285: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8289: LD_ADDR_VAR 0 7
8293: PUSH
8294: LD_EXP 47
8298: PPUSH
8299: LD_INT 25
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: EMPTY
8306: LIST
8307: LIST
8308: PPUSH
8309: CALL_OW 72
8313: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8314: LD_ADDR_VAR 0 8
8318: PUSH
8319: LD_EXP 47
8323: PPUSH
8324: LD_INT 25
8326: PUSH
8327: LD_INT 4
8329: PUSH
8330: EMPTY
8331: LIST
8332: LIST
8333: PPUSH
8334: CALL_OW 72
8338: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8339: LD_ADDR_VAR 0 9
8343: PUSH
8344: LD_EXP 47
8348: PPUSH
8349: LD_INT 25
8351: PUSH
8352: LD_INT 3
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: PPUSH
8359: CALL_OW 72
8363: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8364: LD_ADDR_VAR 0 10
8368: PUSH
8369: LD_EXP 47
8373: PPUSH
8374: LD_INT 21
8376: PUSH
8377: LD_INT 2
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 72
8388: ST_TO_ADDR
// if sol then
8389: LD_VAR 0 7
8393: IFFALSE 8814
// begin for i in sol do
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 7
8404: PUSH
8405: FOR_IN
8406: IFFALSE 8812
// begin tag := GetTag ( i ) ;
8408: LD_ADDR_VAR 0 4
8412: PUSH
8413: LD_VAR 0 2
8417: PPUSH
8418: CALL_OW 110
8422: ST_TO_ADDR
// if not tag then
8423: LD_VAR 0 4
8427: NOT
8428: IFFALSE 8537
// begin if GetLives ( i ) = 1000 then
8430: LD_VAR 0 2
8434: PPUSH
8435: CALL_OW 256
8439: PUSH
8440: LD_INT 1000
8442: EQUAL
8443: IFFALSE 8459
// SetTag ( i , 1 ) else
8445: LD_VAR 0 2
8449: PPUSH
8450: LD_INT 1
8452: PPUSH
8453: CALL_OW 109
8457: GO 8535
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 10 then
8459: LD_VAR 0 2
8463: PPUSH
8464: LD_VAR 0 6
8468: PUSH
8469: LD_INT 2
8471: ARRAY
8472: PUSH
8473: LD_INT 1
8475: ARRAY
8476: PPUSH
8477: LD_VAR 0 6
8481: PUSH
8482: LD_INT 2
8484: ARRAY
8485: PUSH
8486: LD_INT 2
8488: ARRAY
8489: PPUSH
8490: CALL_OW 297
8494: PUSH
8495: LD_INT 10
8497: GREATER
8498: IFFALSE 8535
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8500: LD_VAR 0 2
8504: PPUSH
8505: LD_VAR 0 6
8509: PUSH
8510: LD_INT 2
8512: ARRAY
8513: PUSH
8514: LD_INT 1
8516: ARRAY
8517: PPUSH
8518: LD_VAR 0 6
8522: PUSH
8523: LD_INT 2
8525: ARRAY
8526: PUSH
8527: LD_INT 2
8529: ARRAY
8530: PPUSH
8531: CALL_OW 111
// end else
8535: GO 8810
// begin if GetLives ( i ) < 720 then
8537: LD_VAR 0 2
8541: PPUSH
8542: CALL_OW 256
8546: PUSH
8547: LD_INT 720
8549: LESS
8550: IFFALSE 8601
// begin SetTag ( i , 0 ) ;
8552: LD_VAR 0 2
8556: PPUSH
8557: LD_INT 0
8559: PPUSH
8560: CALL_OW 109
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8564: LD_VAR 0 2
8568: PPUSH
8569: LD_VAR 0 6
8573: PUSH
8574: LD_INT 2
8576: ARRAY
8577: PUSH
8578: LD_INT 1
8580: ARRAY
8581: PPUSH
8582: LD_VAR 0 6
8586: PUSH
8587: LD_INT 2
8589: ARRAY
8590: PUSH
8591: LD_INT 2
8593: ARRAY
8594: PPUSH
8595: CALL_OW 111
// end else
8599: GO 8810
// if tag <= attackFormula [ 1 ] then
8601: LD_VAR 0 4
8605: PUSH
8606: LD_VAR 0 6
8610: PUSH
8611: LD_INT 1
8613: ARRAY
8614: LESSEQUAL
8615: IFFALSE 8776
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8617: LD_VAR 0 2
8621: PPUSH
8622: LD_VAR 0 6
8626: PUSH
8627: LD_INT 1
8629: ARRAY
8630: PUSH
8631: LD_VAR 0 4
8635: ARRAY
8636: PUSH
8637: LD_INT 1
8639: ARRAY
8640: PPUSH
8641: LD_VAR 0 6
8645: PUSH
8646: LD_INT 1
8648: ARRAY
8649: PUSH
8650: LD_VAR 0 4
8654: ARRAY
8655: PUSH
8656: LD_INT 2
8658: ARRAY
8659: PPUSH
8660: CALL_OW 297
8664: PUSH
8665: LD_INT 6
8667: GREATER
8668: IFFALSE 8719
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8670: LD_VAR 0 2
8674: PPUSH
8675: LD_VAR 0 6
8679: PUSH
8680: LD_INT 1
8682: ARRAY
8683: PUSH
8684: LD_VAR 0 4
8688: ARRAY
8689: PUSH
8690: LD_INT 1
8692: ARRAY
8693: PPUSH
8694: LD_VAR 0 6
8698: PUSH
8699: LD_INT 1
8701: ARRAY
8702: PUSH
8703: LD_VAR 0 4
8707: ARRAY
8708: PUSH
8709: LD_INT 2
8711: ARRAY
8712: PPUSH
8713: CALL_OW 114
8717: GO 8774
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8719: LD_INT 81
8721: PUSH
8722: LD_INT 1
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: PUSH
8729: LD_INT 91
8731: PUSH
8732: LD_VAR 0 2
8736: PUSH
8737: LD_INT 10
8739: PUSH
8740: EMPTY
8741: LIST
8742: LIST
8743: LIST
8744: PUSH
8745: EMPTY
8746: LIST
8747: LIST
8748: PPUSH
8749: CALL_OW 69
8753: NOT
8754: IFFALSE 8774
// SetTag ( i , tag + 1 ) ;
8756: LD_VAR 0 2
8760: PPUSH
8761: LD_VAR 0 4
8765: PUSH
8766: LD_INT 1
8768: PLUS
8769: PPUSH
8770: CALL_OW 109
// end else
8774: GO 8810
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8776: LD_VAR 0 2
8780: PPUSH
8781: LD_INT 81
8783: PUSH
8784: LD_INT 1
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PPUSH
8791: CALL_OW 69
8795: PPUSH
8796: LD_VAR 0 2
8800: PPUSH
8801: CALL_OW 74
8805: PPUSH
8806: CALL_OW 115
// end ; end ;
8810: GO 8405
8812: POP
8813: POP
// end ; if sci then
8814: LD_VAR 0 8
8818: IFFALSE 9087
// begin if not sol and not mech then
8820: LD_VAR 0 7
8824: NOT
8825: PUSH
8826: LD_VAR 0 9
8830: NOT
8831: AND
8832: IFFALSE 8884
// begin for i in sci do
8834: LD_ADDR_VAR 0 2
8838: PUSH
8839: LD_VAR 0 8
8843: PUSH
8844: FOR_IN
8845: IFFALSE 8880
// begin usForces := usForces union i ;
8847: LD_ADDR_EXP 44
8851: PUSH
8852: LD_EXP 44
8856: PUSH
8857: LD_VAR 0 2
8861: UNION
8862: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8863: LD_VAR 0 2
8867: PPUSH
8868: LD_INT 34
8870: PPUSH
8871: LD_INT 68
8873: PPUSH
8874: CALL_OW 111
// end ;
8878: GO 8844
8880: POP
8881: POP
// end else
8882: GO 9087
// for i in sci do
8884: LD_ADDR_VAR 0 2
8888: PUSH
8889: LD_VAR 0 8
8893: PUSH
8894: FOR_IN
8895: IFFALSE 9085
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 10 then
8897: LD_VAR 0 2
8901: PPUSH
8902: LD_VAR 0 6
8906: PUSH
8907: LD_INT 2
8909: ARRAY
8910: PUSH
8911: LD_INT 1
8913: ARRAY
8914: PPUSH
8915: LD_VAR 0 6
8919: PUSH
8920: LD_INT 2
8922: ARRAY
8923: PUSH
8924: LD_INT 2
8926: ARRAY
8927: PPUSH
8928: CALL_OW 297
8932: PUSH
8933: LD_INT 10
8935: GREATER
8936: IFFALSE 8975
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) else
8938: LD_VAR 0 2
8942: PPUSH
8943: LD_VAR 0 6
8947: PUSH
8948: LD_INT 2
8950: ARRAY
8951: PUSH
8952: LD_INT 1
8954: ARRAY
8955: PPUSH
8956: LD_VAR 0 6
8960: PUSH
8961: LD_INT 2
8963: ARRAY
8964: PUSH
8965: LD_INT 2
8967: ARRAY
8968: PPUSH
8969: CALL_OW 111
8973: GO 9083
// if UnitFilter ( sol , [ [ f_not , [ f_lives , 1000 ] ] , [ f_dist , i , 10 ] ] ) then
8975: LD_VAR 0 7
8979: PPUSH
8980: LD_INT 3
8982: PUSH
8983: LD_INT 24
8985: PUSH
8986: LD_INT 1000
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: PUSH
8993: EMPTY
8994: LIST
8995: LIST
8996: PUSH
8997: LD_INT 91
8999: PUSH
9000: LD_VAR 0 2
9004: PUSH
9005: LD_INT 10
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: PPUSH
9017: CALL_OW 72
9021: IFFALSE 9083
// ComHeal ( i , UnitFilter ( sol , [ [ f_not , [ f_lives , 1000 ] ] , [ f_dist , i , 10 ] ] ) [ 1 ] ) ;
9023: LD_VAR 0 2
9027: PPUSH
9028: LD_VAR 0 7
9032: PPUSH
9033: LD_INT 3
9035: PUSH
9036: LD_INT 24
9038: PUSH
9039: LD_INT 1000
9041: PUSH
9042: EMPTY
9043: LIST
9044: LIST
9045: PUSH
9046: EMPTY
9047: LIST
9048: LIST
9049: PUSH
9050: LD_INT 91
9052: PUSH
9053: LD_VAR 0 2
9057: PUSH
9058: LD_INT 10
9060: PUSH
9061: EMPTY
9062: LIST
9063: LIST
9064: LIST
9065: PUSH
9066: EMPTY
9067: LIST
9068: LIST
9069: PPUSH
9070: CALL_OW 72
9074: PUSH
9075: LD_INT 1
9077: ARRAY
9078: PPUSH
9079: CALL_OW 128
9083: GO 8894
9085: POP
9086: POP
// end ; if mech then
9087: LD_VAR 0 9
9091: IFFALSE 9728
// begin for i in mech do
9093: LD_ADDR_VAR 0 2
9097: PUSH
9098: LD_VAR 0 9
9102: PUSH
9103: FOR_IN
9104: IFFALSE 9726
// begin tag := GetTag ( i ) ;
9106: LD_ADDR_VAR 0 4
9110: PUSH
9111: LD_VAR 0 2
9115: PPUSH
9116: CALL_OW 110
9120: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
9121: LD_ADDR_VAR 0 11
9125: PUSH
9126: LD_VAR 0 2
9130: PPUSH
9131: CALL_OW 310
9135: ST_TO_ADDR
// if not tag then
9136: LD_VAR 0 4
9140: NOT
9141: IFFALSE 9439
// begin if veh then
9143: LD_VAR 0 11
9147: IFFALSE 9281
// begin if GetLives ( veh ) = 1000 then
9149: LD_VAR 0 11
9153: PPUSH
9154: CALL_OW 256
9158: PUSH
9159: LD_INT 1000
9161: EQUAL
9162: IFFALSE 9178
// SetTag ( i , 1 ) else
9164: LD_VAR 0 2
9168: PPUSH
9169: LD_INT 1
9171: PPUSH
9172: CALL_OW 109
9176: GO 9279
// if GetDistUnitXY ( veh , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
9178: LD_VAR 0 11
9182: PPUSH
9183: LD_VAR 0 6
9187: PUSH
9188: LD_INT 3
9190: ARRAY
9191: PUSH
9192: LD_INT 1
9194: ARRAY
9195: PPUSH
9196: LD_VAR 0 6
9200: PUSH
9201: LD_INT 3
9203: ARRAY
9204: PUSH
9205: LD_INT 2
9207: ARRAY
9208: PPUSH
9209: CALL_OW 297
9213: PUSH
9214: LD_INT 7
9216: GREATER
9217: IFFALSE 9256
// ComMoveXY ( veh , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
9219: LD_VAR 0 11
9223: PPUSH
9224: LD_VAR 0 6
9228: PUSH
9229: LD_INT 3
9231: ARRAY
9232: PUSH
9233: LD_INT 1
9235: ARRAY
9236: PPUSH
9237: LD_VAR 0 6
9241: PUSH
9242: LD_INT 3
9244: ARRAY
9245: PUSH
9246: LD_INT 2
9248: ARRAY
9249: PPUSH
9250: CALL_OW 111
9254: GO 9279
// begin ComExitVehicle ( i ) ;
9256: LD_VAR 0 2
9260: PPUSH
9261: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
9265: LD_VAR 0 2
9269: PPUSH
9270: LD_VAR 0 11
9274: PPUSH
9275: CALL_OW 189
// end ; end else
9279: GO 9437
// if GetLives ( i ) < 400 then
9281: LD_VAR 0 2
9285: PPUSH
9286: CALL_OW 256
9290: PUSH
9291: LD_INT 400
9293: LESS
9294: IFFALSE 9345
// begin usAttackers := usAttackers diff i ;
9296: LD_ADDR_EXP 47
9300: PUSH
9301: LD_EXP 47
9305: PUSH
9306: LD_VAR 0 2
9310: DIFF
9311: ST_TO_ADDR
// usForces := usForces union i ;
9312: LD_ADDR_EXP 44
9316: PUSH
9317: LD_EXP 44
9321: PUSH
9322: LD_VAR 0 2
9326: UNION
9327: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9328: LD_VAR 0 2
9332: PPUSH
9333: LD_INT 34
9335: PPUSH
9336: LD_INT 68
9338: PPUSH
9339: CALL_OW 111
// end else
9343: GO 9437
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9345: LD_VAR 0 10
9349: PPUSH
9350: LD_INT 58
9352: PUSH
9353: EMPTY
9354: LIST
9355: PUSH
9356: LD_INT 24
9358: PUSH
9359: LD_INT 1000
9361: PUSH
9362: EMPTY
9363: LIST
9364: LIST
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: PPUSH
9370: CALL_OW 72
9374: PUSH
9375: LD_VAR 0 2
9379: PPUSH
9380: CALL_OW 314
9384: NOT
9385: AND
9386: IFFALSE 9437
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 250 ] ] ) , i ) ) ;
9388: LD_VAR 0 2
9392: PPUSH
9393: LD_VAR 0 10
9397: PPUSH
9398: LD_INT 58
9400: PUSH
9401: EMPTY
9402: LIST
9403: PUSH
9404: LD_INT 24
9406: PUSH
9407: LD_INT 250
9409: PUSH
9410: EMPTY
9411: LIST
9412: LIST
9413: PUSH
9414: EMPTY
9415: LIST
9416: LIST
9417: PPUSH
9418: CALL_OW 72
9422: PPUSH
9423: LD_VAR 0 2
9427: PPUSH
9428: CALL_OW 74
9432: PPUSH
9433: CALL_OW 120
// end else
9437: GO 9724
// begin if veh and GetLives ( veh ) < 720 then
9439: LD_VAR 0 11
9443: PUSH
9444: LD_VAR 0 11
9448: PPUSH
9449: CALL_OW 256
9453: PUSH
9454: LD_INT 720
9456: LESS
9457: AND
9458: IFFALSE 9509
// begin SetTag ( i , 0 ) ;
9460: LD_VAR 0 2
9464: PPUSH
9465: LD_INT 0
9467: PPUSH
9468: CALL_OW 109
// ComMoveXY ( veh , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) ;
9472: LD_VAR 0 11
9476: PPUSH
9477: LD_VAR 0 6
9481: PUSH
9482: LD_INT 3
9484: ARRAY
9485: PUSH
9486: LD_INT 1
9488: ARRAY
9489: PPUSH
9490: LD_VAR 0 6
9494: PUSH
9495: LD_INT 3
9497: ARRAY
9498: PUSH
9499: LD_INT 2
9501: ARRAY
9502: PPUSH
9503: CALL_OW 111
// end else
9507: GO 9724
// if veh then
9509: LD_VAR 0 11
9513: IFFALSE 9724
// if tag <= attackFormula [ 4 ] then
9515: LD_VAR 0 4
9519: PUSH
9520: LD_VAR 0 6
9524: PUSH
9525: LD_INT 4
9527: ARRAY
9528: LESSEQUAL
9529: IFFALSE 9690
// begin if GetDistUnitXY ( veh , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9531: LD_VAR 0 11
9535: PPUSH
9536: LD_VAR 0 6
9540: PUSH
9541: LD_INT 4
9543: ARRAY
9544: PUSH
9545: LD_VAR 0 4
9549: ARRAY
9550: PUSH
9551: LD_INT 1
9553: ARRAY
9554: PPUSH
9555: LD_VAR 0 6
9559: PUSH
9560: LD_INT 4
9562: ARRAY
9563: PUSH
9564: LD_VAR 0 4
9568: ARRAY
9569: PUSH
9570: LD_INT 2
9572: ARRAY
9573: PPUSH
9574: CALL_OW 297
9578: PUSH
9579: LD_INT 6
9581: GREATER
9582: IFFALSE 9633
// ComAgressiveMove ( veh , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9584: LD_VAR 0 11
9588: PPUSH
9589: LD_VAR 0 6
9593: PUSH
9594: LD_INT 4
9596: ARRAY
9597: PUSH
9598: LD_VAR 0 4
9602: ARRAY
9603: PUSH
9604: LD_INT 1
9606: ARRAY
9607: PPUSH
9608: LD_VAR 0 6
9612: PUSH
9613: LD_INT 4
9615: ARRAY
9616: PUSH
9617: LD_VAR 0 4
9621: ARRAY
9622: PUSH
9623: LD_INT 2
9625: ARRAY
9626: PPUSH
9627: CALL_OW 114
9631: GO 9688
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , veh , 10 ] ] ) then
9633: LD_INT 81
9635: PUSH
9636: LD_INT 1
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: PUSH
9643: LD_INT 91
9645: PUSH
9646: LD_VAR 0 11
9650: PUSH
9651: LD_INT 10
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: LIST
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: PPUSH
9663: CALL_OW 69
9667: NOT
9668: IFFALSE 9688
// SetTag ( i , tag + 1 ) ;
9670: LD_VAR 0 2
9674: PPUSH
9675: LD_VAR 0 4
9679: PUSH
9680: LD_INT 1
9682: PLUS
9683: PPUSH
9684: CALL_OW 109
// end else
9688: GO 9724
// ComAttackUnit ( veh , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9690: LD_VAR 0 11
9694: PPUSH
9695: LD_INT 81
9697: PUSH
9698: LD_INT 1
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: PPUSH
9705: CALL_OW 69
9709: PPUSH
9710: LD_VAR 0 2
9714: PPUSH
9715: CALL_OW 74
9719: PPUSH
9720: CALL_OW 115
// end ; end ;
9724: GO 9103
9726: POP
9727: POP
// end ; until not UnitFilter ( usAttackers , [ f_placed ] ) ;
9728: LD_EXP 47
9732: PPUSH
9733: LD_INT 52
9735: PUSH
9736: EMPTY
9737: LIST
9738: PPUSH
9739: CALL_OW 72
9743: NOT
9744: IFFALSE 8282
// end ;
9746: LD_VAR 0 1
9750: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do var i ;
9751: LD_INT 22
9753: PUSH
9754: LD_INT 1
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: PUSH
9761: LD_INT 32
9763: PUSH
9764: LD_INT 1
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: PPUSH
9775: CALL_OW 69
9779: IFFALSE 9856
9781: GO 9783
9783: DISABLE
9784: LD_INT 0
9786: PPUSH
// begin enable ;
9787: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do
9788: LD_ADDR_VAR 0 1
9792: PUSH
9793: LD_INT 22
9795: PUSH
9796: LD_INT 1
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: PUSH
9803: LD_INT 32
9805: PUSH
9806: LD_INT 1
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: EMPTY
9814: LIST
9815: LIST
9816: PPUSH
9817: CALL_OW 69
9821: PUSH
9822: FOR_IN
9823: IFFALSE 9854
// if GetFuel ( i ) < 10 then
9825: LD_VAR 0 1
9829: PPUSH
9830: CALL_OW 261
9834: PUSH
9835: LD_INT 10
9837: LESS
9838: IFFALSE 9852
// SetFuel ( i , 10 ) ;
9840: LD_VAR 0 1
9844: PPUSH
9845: LD_INT 10
9847: PPUSH
9848: CALL_OW 240
9852: GO 9822
9854: POP
9855: POP
// end ; end_of_file
9856: PPOPN 1
9858: END
// export function Action ; var hasAll , i , tmp ; begin
9859: LD_INT 0
9861: PPUSH
9862: PPUSH
9863: PPUSH
9864: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9865: LD_ADDR_VAR 0 2
9869: PUSH
9870: LD_INT 22
9872: PUSH
9873: LD_INT 2
9875: PUSH
9876: EMPTY
9877: LIST
9878: LIST
9879: PUSH
9880: LD_INT 21
9882: PUSH
9883: LD_INT 1
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: PUSH
9890: LD_INT 23
9892: PUSH
9893: LD_INT 2
9895: PUSH
9896: EMPTY
9897: LIST
9898: LIST
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: LIST
9904: PPUSH
9905: CALL_OW 69
9909: PUSH
9910: LD_INT 7
9912: GREATEREQUAL
9913: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9914: LD_VAR 0 2
9918: PPUSH
9919: LD_STRING 03_HasAll
9921: PPUSH
9922: CALL_OW 39
// Video ( true ) ;
9926: LD_INT 1
9928: PPUSH
9929: CALL 1036 0 1
// CenterNowOnUnits ( Heike ) ;
9933: LD_EXP 28
9937: PPUSH
9938: CALL_OW 87
// wait ( 0 0$2 ) ;
9942: LD_INT 70
9944: PPUSH
9945: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9949: LD_EXP 36
9953: PPUSH
9954: LD_STRING DF-1-start
9956: PPUSH
9957: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9961: LD_EXP 28
9965: PPUSH
9966: LD_EXP 36
9970: PPUSH
9971: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9975: LD_EXP 28
9979: PPUSH
9980: LD_STRING DH-1-start
9982: PPUSH
9983: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9987: LD_EXP 37
9991: PPUSH
9992: LD_INT 92
9994: PPUSH
9995: LD_INT 21
9997: PPUSH
9998: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
10002: LD_EXP 32
10006: PPUSH
10007: LD_INT 94
10009: PPUSH
10010: LD_INT 23
10012: PPUSH
10013: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
10017: LD_EXP 40
10021: PUSH
10022: LD_INT 1
10024: ARRAY
10025: PPUSH
10026: LD_INT 90
10028: PPUSH
10029: LD_INT 23
10031: PPUSH
10032: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
10036: LD_EXP 40
10040: PUSH
10041: LD_INT 2
10043: ARRAY
10044: PPUSH
10045: LD_INT 93
10047: PPUSH
10048: LD_INT 25
10050: PPUSH
10051: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
10055: LD_EXP 40
10059: PPUSH
10060: LD_EXP 37
10064: PPUSH
10065: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
10069: LD_EXP 37
10073: PUSH
10074: LD_EXP 32
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PPUSH
10083: LD_EXP 28
10087: PPUSH
10088: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
10092: LD_EXP 28
10096: PPUSH
10097: LD_EXP 37
10101: PPUSH
10102: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
10106: LD_INT 35
10108: PPUSH
10109: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
10113: LD_EXP 37
10117: PPUSH
10118: LD_INT 92
10120: PPUSH
10121: LD_INT 21
10123: PPUSH
10124: CALL_OW 307
10128: IFFALSE 10106
// Say ( Omar , DO-1-start ) ;
10130: LD_EXP 37
10134: PPUSH
10135: LD_STRING DO-1-start
10137: PPUSH
10138: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
10142: LD_EXP 28
10146: PPUSH
10147: LD_STRING DH-2-start
10149: PPUSH
10150: CALL_OW 88
// if hasAll then
10154: LD_VAR 0 2
10158: IFFALSE 10286
// begin Say ( Omar , DO-2-start ) ;
10160: LD_EXP 37
10164: PPUSH
10165: LD_STRING DO-2-start
10167: PPUSH
10168: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
10172: LD_EXP 37
10176: PPUSH
10177: LD_STRING DO-3-start
10179: PPUSH
10180: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
10184: LD_EXP 28
10188: PPUSH
10189: LD_STRING DH-3-start
10191: PPUSH
10192: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
10196: LD_EXP 36
10200: PPUSH
10201: LD_STRING DF-2-start
10203: PPUSH
10204: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10208: LD_EXP 37
10212: PPUSH
10213: LD_EXP 36
10217: PPUSH
10218: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
10222: LD_EXP 37
10226: PPUSH
10227: LD_STRING DO-4-start
10229: PPUSH
10230: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
10234: LD_EXP 36
10238: PPUSH
10239: LD_STRING DF-3-start
10241: PPUSH
10242: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
10246: LD_EXP 37
10250: PPUSH
10251: LD_STRING DO-5-start
10253: PPUSH
10254: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
10258: LD_EXP 36
10262: PPUSH
10263: LD_STRING DF-4-start
10265: PPUSH
10266: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10270: LD_EXP 37
10274: PPUSH
10275: LD_EXP 28
10279: PPUSH
10280: CALL_OW 119
// end else
10284: GO 10386
// begin Say ( Omar , DO-2-start-a ) ;
10286: LD_EXP 37
10290: PPUSH
10291: LD_STRING DO-2-start-a
10293: PPUSH
10294: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
10298: LD_EXP 37
10302: PPUSH
10303: LD_STRING DO-3-start-a
10305: PPUSH
10306: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
10310: LD_EXP 28
10314: PPUSH
10315: LD_STRING DH-3-start-a
10317: PPUSH
10318: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
10322: LD_EXP 36
10326: PPUSH
10327: LD_STRING DF-2-start-a
10329: PPUSH
10330: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10334: LD_EXP 37
10338: PPUSH
10339: LD_EXP 36
10343: PPUSH
10344: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
10348: LD_EXP 37
10352: PPUSH
10353: LD_STRING DO-4-start-a
10355: PPUSH
10356: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
10360: LD_EXP 36
10364: PPUSH
10365: LD_STRING DF-3-start-a
10367: PPUSH
10368: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10372: LD_EXP 37
10376: PPUSH
10377: LD_EXP 28
10381: PPUSH
10382: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
10386: LD_INT 10
10388: PPUSH
10389: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
10393: LD_EXP 37
10397: PPUSH
10398: LD_STRING DO-1-mission
10400: PPUSH
10401: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
10405: LD_EXP 37
10409: PPUSH
10410: LD_STRING DO-2-mission
10412: PPUSH
10413: CALL_OW 88
// if not hasAll then
10417: LD_VAR 0 2
10421: NOT
10422: IFFALSE 10436
// Say ( Omar , DO-3-mission ) ;
10424: LD_EXP 37
10428: PPUSH
10429: LD_STRING DO-3-mission
10431: PPUSH
10432: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
10436: LD_EXP 37
10440: PPUSH
10441: LD_STRING DO-4-mission
10443: PPUSH
10444: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
10448: LD_EXP 28
10452: PPUSH
10453: LD_STRING DH-1-mission
10455: PPUSH
10456: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10460: LD_EXP 36
10464: PPUSH
10465: LD_STRING DF-1-mission
10467: PPUSH
10468: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10472: LD_EXP 37
10476: PPUSH
10477: LD_STRING DO-5-mission
10479: PPUSH
10480: CALL_OW 88
// if not hasAll then
10484: LD_VAR 0 2
10488: NOT
10489: IFFALSE 10624
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10491: LD_ADDR_VAR 0 4
10495: PUSH
10496: LD_INT 22
10498: PUSH
10499: LD_INT 2
10501: PUSH
10502: EMPTY
10503: LIST
10504: LIST
10505: PUSH
10506: LD_INT 21
10508: PUSH
10509: LD_INT 1
10511: PUSH
10512: EMPTY
10513: LIST
10514: LIST
10515: PUSH
10516: LD_INT 23
10518: PUSH
10519: LD_INT 2
10521: PUSH
10522: EMPTY
10523: LIST
10524: LIST
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: LIST
10530: PPUSH
10531: CALL_OW 69
10535: ST_TO_ADDR
// for i := 7 downto tmp do
10536: LD_ADDR_VAR 0 3
10540: PUSH
10541: DOUBLE
10542: LD_INT 7
10544: INC
10545: ST_TO_ADDR
10546: LD_VAR 0 4
10550: PUSH
10551: FOR_DOWNTO
10552: IFFALSE 10622
// begin if omarSquad < 3 then
10554: LD_EXP 40
10558: PUSH
10559: LD_INT 3
10561: LESS
10562: IFFALSE 10566
// break ;
10564: GO 10622
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10566: LD_EXP 40
10570: PUSH
10571: LD_INT 3
10573: ARRAY
10574: PPUSH
10575: LD_INT 2
10577: PPUSH
10578: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10582: LD_ADDR_EXP 42
10586: PUSH
10587: LD_EXP 42
10591: PUSH
10592: LD_EXP 40
10596: PUSH
10597: LD_INT 3
10599: ARRAY
10600: UNION
10601: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10602: LD_ADDR_EXP 40
10606: PUSH
10607: LD_EXP 40
10611: PPUSH
10612: LD_INT 3
10614: PPUSH
10615: CALL_OW 3
10619: ST_TO_ADDR
// end ;
10620: GO 10551
10622: POP
10623: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10624: LD_EXP 37
10628: PUSH
10629: LD_EXP 40
10633: ADD
10634: PPUSH
10635: LD_INT 103
10637: PPUSH
10638: LD_INT 9
10640: PPUSH
10641: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10645: LD_VAR 0 2
10649: PUSH
10650: LD_EXP 33
10654: PPUSH
10655: CALL_OW 302
10659: AND
10660: IFFALSE 10721
// begin wait ( 0 0$3 ) ;
10662: LD_INT 105
10664: PPUSH
10665: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10669: LD_EXP 33
10673: PPUSH
10674: LD_EXP 36
10678: PPUSH
10679: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10683: LD_EXP 33
10687: PPUSH
10688: LD_STRING DK-1-side
10690: PPUSH
10691: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10695: LD_EXP 36
10699: PPUSH
10700: LD_EXP 33
10704: PPUSH
10705: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10709: LD_EXP 36
10713: PPUSH
10714: LD_STRING DF-1-side
10716: PPUSH
10717: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10721: LD_INT 22
10723: PUSH
10724: LD_INT 2
10726: PUSH
10727: EMPTY
10728: LIST
10729: LIST
10730: PPUSH
10731: CALL_OW 69
10735: PPUSH
10736: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10740: LD_EXP 36
10744: PUSH
10745: LD_EXP 39
10749: ADD
10750: PPUSH
10751: LD_INT 108
10753: PPUSH
10754: LD_INT 62
10756: PPUSH
10757: CALL_OW 111
// gameStarted := true ;
10761: LD_ADDR_EXP 3
10765: PUSH
10766: LD_INT 1
10768: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10769: LD_INT 105
10771: PPUSH
10772: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10776: LD_EXP 28
10780: PPUSH
10781: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10785: LD_EXP 28
10789: PPUSH
10790: LD_EXP 32
10794: PPUSH
10795: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10799: LD_INT 22
10801: PUSH
10802: LD_INT 2
10804: PUSH
10805: EMPTY
10806: LIST
10807: LIST
10808: PPUSH
10809: CALL_OW 69
10813: PUSH
10814: LD_EXP 28
10818: DIFF
10819: PPUSH
10820: LD_EXP 28
10824: PPUSH
10825: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10829: LD_EXP 28
10833: PPUSH
10834: LD_STRING DH-1-explore
10836: PPUSH
10837: CALL_OW 88
// if Givi then
10841: LD_EXP 29
10845: IFFALSE 10861
// Say ( Givi , DG-1-explore ) else
10847: LD_EXP 29
10851: PPUSH
10852: LD_STRING DG-1-explore
10854: PPUSH
10855: CALL_OW 88
10859: GO 10898
// if heikeSecondSquad then
10861: LD_EXP 42
10865: IFFALSE 10898
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10867: LD_EXP 42
10871: PPUSH
10872: LD_INT 26
10874: PUSH
10875: LD_INT 1
10877: PUSH
10878: EMPTY
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 72
10886: PUSH
10887: LD_INT 1
10889: ARRAY
10890: PPUSH
10891: LD_STRING DArm-1-explore
10893: PPUSH
10894: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10898: LD_EXP 32
10902: PPUSH
10903: LD_STRING DA-1-explore
10905: PPUSH
10906: CALL_OW 88
// if Sophia then
10910: LD_EXP 34
10914: IFFALSE 10992
// begin Say ( Sophia , DS-2-explore ) ;
10916: LD_EXP 34
10920: PPUSH
10921: LD_STRING DS-2-explore
10923: PPUSH
10924: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10928: LD_EXP 32
10932: PPUSH
10933: LD_STRING DA-2-explore
10935: PPUSH
10936: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10940: LD_EXP 34
10944: PPUSH
10945: LD_EXP 32
10949: PPUSH
10950: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10954: LD_EXP 32
10958: PPUSH
10959: LD_EXP 34
10963: PPUSH
10964: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10968: LD_EXP 34
10972: PPUSH
10973: LD_STRING DS-3-explore
10975: PPUSH
10976: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10980: LD_EXP 32
10984: PPUSH
10985: LD_STRING DA-3-explore
10987: PPUSH
10988: CALL_OW 88
// end ; if Mike then
10992: LD_EXP 30
10996: IFFALSE 11052
// begin Say ( Mike , DM-1-explore ) ;
10998: LD_EXP 30
11002: PPUSH
11003: LD_STRING DM-1-explore
11005: PPUSH
11006: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
11010: LD_EXP 28
11014: PPUSH
11015: LD_STRING DH-2-explore
11017: PPUSH
11018: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
11022: LD_EXP 30
11026: PPUSH
11027: LD_STRING DM-2-explore
11029: PPUSH
11030: CALL_OW 88
// if Kaia then
11034: LD_EXP 33
11038: IFFALSE 11052
// Say ( Kaia , DK-1-explore ) ;
11040: LD_EXP 33
11044: PPUSH
11045: LD_STRING DK-1-explore
11047: PPUSH
11048: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
11052: LD_INT 22
11054: PUSH
11055: LD_INT 2
11057: PUSH
11058: EMPTY
11059: LIST
11060: LIST
11061: PPUSH
11062: CALL_OW 69
11066: PPUSH
11067: CALL_OW 139
// Video ( false ) ;
11071: LD_INT 0
11073: PPUSH
11074: CALL 1036 0 1
// ChangeMissionObjectives ( BuildBase ) ;
11078: LD_STRING BuildBase
11080: PPUSH
11081: CALL_OW 337
// SaveForQuickRestart ;
11085: CALL_OW 22
// end ;
11089: LD_VAR 0 1
11093: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
11094: LD_EXP 5
11098: NOT
11099: PUSH
11100: LD_EXP 6
11104: NOT
11105: AND
11106: PUSH
11107: LD_INT 5
11109: PPUSH
11110: LD_INT 22
11112: PUSH
11113: LD_INT 2
11115: PUSH
11116: EMPTY
11117: LIST
11118: LIST
11119: PPUSH
11120: CALL_OW 70
11124: AND
11125: PUSH
11126: LD_EXP 6
11130: NOT
11131: AND
11132: IFFALSE 11217
11134: GO 11136
11136: DISABLE
// begin if Mike then
11137: LD_EXP 30
11141: IFFALSE 11157
// Say ( Mike , DM-1-scout ) else
11143: LD_EXP 30
11147: PPUSH
11148: LD_STRING DM-1-scout
11150: PPUSH
11151: CALL_OW 88
11155: GO 11188
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
11157: LD_EXP 42
11161: PPUSH
11162: LD_INT 26
11164: PUSH
11165: LD_INT 1
11167: PUSH
11168: EMPTY
11169: LIST
11170: LIST
11171: PPUSH
11172: CALL_OW 72
11176: PUSH
11177: LD_INT 1
11179: ARRAY
11180: PPUSH
11181: LD_STRING DArm-1-explore
11183: PPUSH
11184: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
11188: LD_INT 54
11190: PPUSH
11191: LD_INT 35
11193: PPUSH
11194: LD_INT 2
11196: PPUSH
11197: LD_INT 1
11199: PPUSH
11200: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
11204: LD_INT 54
11206: PPUSH
11207: LD_INT 35
11209: PPUSH
11210: LD_INT 2
11212: PPUSH
11213: CALL_OW 331
// end ;
11217: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
11218: LD_INT 6
11220: PPUSH
11221: LD_INT 22
11223: PUSH
11224: LD_INT 2
11226: PUSH
11227: EMPTY
11228: LIST
11229: LIST
11230: PPUSH
11231: CALL_OW 70
11235: PUSH
11236: LD_EXP 6
11240: NOT
11241: AND
11242: IFFALSE 11496
11244: GO 11246
11246: DISABLE
11247: LD_INT 0
11249: PPUSH
11250: PPUSH
11251: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11252: LD_ADDR_VAR 0 1
11256: PUSH
11257: LD_EXP 42
11261: PPUSH
11262: LD_INT 26
11264: PUSH
11265: LD_INT 1
11267: PUSH
11268: EMPTY
11269: LIST
11270: LIST
11271: PPUSH
11272: CALL_OW 72
11276: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
11277: LD_ADDR_VAR 0 2
11281: PUSH
11282: LD_EXP 42
11286: PPUSH
11287: LD_INT 26
11289: PUSH
11290: LD_INT 2
11292: PUSH
11293: EMPTY
11294: LIST
11295: LIST
11296: PPUSH
11297: CALL_OW 72
11301: ST_TO_ADDR
// DialogueOn ;
11302: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
11306: LD_INT 36
11308: PPUSH
11309: LD_INT 22
11311: PPUSH
11312: LD_INT 2
11314: PPUSH
11315: LD_INT 8
11317: PPUSH
11318: CALL_OW 330
// dwait ( 0 0$1 ) ;
11322: LD_INT 35
11324: PPUSH
11325: CALL_OW 68
// speakerOk := false ;
11329: LD_ADDR_VAR 0 3
11333: PUSH
11334: LD_INT 0
11336: ST_TO_ADDR
// if Mike then
11337: LD_EXP 30
11341: IFFALSE 11363
// speakerOk := Say ( Mike , DM-1-spot ) else
11343: LD_ADDR_VAR 0 3
11347: PUSH
11348: LD_EXP 30
11352: PPUSH
11353: LD_STRING DM-1-spot
11355: PPUSH
11356: CALL_OW 88
11360: ST_TO_ADDR
11361: GO 11391
// if randomMen then
11363: LD_VAR 0 1
11367: IFFALSE 11391
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11369: LD_ADDR_VAR 0 3
11373: PUSH
11374: LD_VAR 0 1
11378: PUSH
11379: LD_INT 1
11381: ARRAY
11382: PPUSH
11383: LD_STRING DArm-1-spot-a
11385: PPUSH
11386: CALL_OW 88
11390: ST_TO_ADDR
// if speakerOk then
11391: LD_VAR 0 3
11395: IFFALSE 11439
// begin if Givi then
11397: LD_EXP 29
11401: IFFALSE 11417
// Say ( Givi , DG-1-spot ) else
11403: LD_EXP 29
11407: PPUSH
11408: LD_STRING DG-1-spot
11410: PPUSH
11411: CALL_OW 88
11415: GO 11439
// if randomWomen then
11417: LD_VAR 0 2
11421: IFFALSE 11439
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
11423: LD_VAR 0 2
11427: PUSH
11428: LD_INT 1
11430: ARRAY
11431: PPUSH
11432: LD_STRING DArf-1-spot-a
11434: PPUSH
11435: CALL_OW 88
// end ; if Mike then
11439: LD_EXP 30
11443: IFFALSE 11459
// Say ( Heike , DH-1-spot ) else
11445: LD_EXP 28
11449: PPUSH
11450: LD_STRING DH-1-spot
11452: PPUSH
11453: CALL_OW 88
11457: GO 11471
// Say ( Heike , DH-1-spot-a ) ;
11459: LD_EXP 28
11463: PPUSH
11464: LD_STRING DH-1-spot-a
11466: PPUSH
11467: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11471: LD_INT 36
11473: PPUSH
11474: LD_INT 22
11476: PPUSH
11477: LD_INT 2
11479: PPUSH
11480: CALL_OW 331
// DialogueOff ;
11484: CALL_OW 7
// americanBaseSpoted := true ;
11488: LD_ADDR_EXP 5
11492: PUSH
11493: LD_INT 1
11495: ST_TO_ADDR
// end ;
11496: PPOPN 3
11498: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11499: LD_EXP 5
11503: NOT
11504: PUSH
11505: LD_INT 22
11507: PUSH
11508: LD_INT 2
11510: PUSH
11511: EMPTY
11512: LIST
11513: LIST
11514: PUSH
11515: LD_INT 101
11517: PUSH
11518: LD_INT 1
11520: PUSH
11521: EMPTY
11522: LIST
11523: LIST
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PPUSH
11529: CALL_OW 69
11533: AND
11534: PUSH
11535: LD_EXP 6
11539: NOT
11540: AND
11541: IFFALSE 11627
11543: GO 11545
11545: DISABLE
11546: LD_INT 0
11548: PPUSH
// begin americanBaseSpoted := true ;
11549: LD_ADDR_EXP 5
11553: PUSH
11554: LD_INT 1
11556: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11557: LD_ADDR_VAR 0 1
11561: PUSH
11562: LD_EXP 42
11566: PPUSH
11567: LD_INT 26
11569: PUSH
11570: LD_INT 1
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PPUSH
11577: CALL_OW 72
11581: ST_TO_ADDR
// if not randomMen then
11582: LD_VAR 0 1
11586: NOT
11587: IFFALSE 11591
// exit ;
11589: GO 11627
// DialogueOn ;
11591: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11595: LD_VAR 0 1
11599: PUSH
11600: LD_INT 1
11602: ARRAY
11603: PPUSH
11604: LD_STRING DArm-1-spot-a
11606: PPUSH
11607: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11611: LD_EXP 28
11615: PPUSH
11616: LD_STRING DH-1-spot-a
11618: PPUSH
11619: CALL_OW 88
// DialogueOff ;
11623: CALL_OW 7
// end ;
11627: PPOPN 1
11629: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or usForces <= 4 do var i , p ;
11630: LD_INT 11
11632: PPUSH
11633: CALL_OW 255
11637: PUSH
11638: LD_INT 2
11640: EQUAL
11641: PUSH
11642: LD_INT 7
11644: PPUSH
11645: LD_INT 22
11647: PUSH
11648: LD_INT 1
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 3
11657: PUSH
11658: LD_INT 50
11660: PUSH
11661: EMPTY
11662: LIST
11663: PUSH
11664: EMPTY
11665: LIST
11666: LIST
11667: PUSH
11668: LD_INT 30
11670: PUSH
11671: LD_INT 31
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: PUSH
11678: EMPTY
11679: LIST
11680: LIST
11681: LIST
11682: PPUSH
11683: CALL_OW 70
11687: OR
11688: PUSH
11689: LD_INT 7
11691: PPUSH
11692: LD_INT 22
11694: PUSH
11695: LD_INT 2
11697: PUSH
11698: EMPTY
11699: LIST
11700: LIST
11701: PPUSH
11702: CALL_OW 70
11706: PUSH
11707: LD_INT 1
11709: GREATER
11710: OR
11711: PUSH
11712: LD_EXP 44
11716: PUSH
11717: LD_INT 4
11719: LESSEQUAL
11720: OR
11721: IFFALSE 12247
11723: GO 11725
11725: DISABLE
11726: LD_INT 0
11728: PPUSH
11729: PPUSH
// begin wait ( 0 0$3 ) ;
11730: LD_INT 105
11732: PPUSH
11733: CALL_OW 67
// americanStartRun := true ;
11737: LD_ADDR_EXP 14
11741: PUSH
11742: LD_INT 1
11744: ST_TO_ADDR
// if IsOk ( usCommander ) then
11745: LD_EXP 45
11749: PPUSH
11750: CALL_OW 302
11754: IFFALSE 11784
// begin usForces := usForces union usCommander ;
11756: LD_ADDR_EXP 44
11760: PUSH
11761: LD_EXP 44
11765: PUSH
11766: LD_EXP 45
11770: UNION
11771: ST_TO_ADDR
// Say ( usCommander , DUsm-1-assault ) ;
11772: LD_EXP 45
11776: PPUSH
11777: LD_STRING DUsm-1-assault
11779: PPUSH
11780: CALL_OW 88
// end ; for i in usForces do
11784: LD_ADDR_VAR 0 1
11788: PUSH
11789: LD_EXP 44
11793: PUSH
11794: FOR_IN
11795: IFFALSE 11841
// begin if IsInUnit ( i ) then
11797: LD_VAR 0 1
11801: PPUSH
11802: CALL_OW 310
11806: IFFALSE 11817
// ComExitBuilding ( i ) ;
11808: LD_VAR 0 1
11812: PPUSH
11813: CALL_OW 122
// wait ( 3 ) ;
11817: LD_INT 3
11819: PPUSH
11820: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11824: LD_VAR 0 1
11828: PPUSH
11829: LD_INT 34
11831: PPUSH
11832: LD_INT 67
11834: PPUSH
11835: CALL_OW 111
// end ;
11839: GO 11794
11841: POP
11842: POP
// Say ( Heike , DH-1-assault ) ;
11843: LD_EXP 28
11847: PPUSH
11848: LD_STRING DH-1-assault
11850: PPUSH
11851: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11855: LD_INT 35
11857: PPUSH
11858: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11862: LD_VAR 0 1
11866: PPUSH
11867: LD_INT 34
11869: PPUSH
11870: LD_INT 67
11872: PPUSH
11873: CALL_OW 111
// until not usForces ;
11877: LD_EXP 44
11881: NOT
11882: IFFALSE 11855
// music_nat := 2 ;
11884: LD_ADDR_OWVAR 71
11888: PUSH
11889: LD_INT 2
11891: ST_TO_ADDR
// music_class := music_victory ;
11892: LD_ADDR_OWVAR 72
11896: PUSH
11897: LD_INT 4
11899: ST_TO_ADDR
// if not americanHasEscaped then
11900: LD_EXP 8
11904: NOT
11905: IFFALSE 11926
// begin Say ( Heike , DH-2-assault ) ;
11907: LD_EXP 28
11911: PPUSH
11912: LD_STRING DH-2-assault
11914: PPUSH
11915: CALL_OW 88
// SetAchievement ( ACH_CLEAN ) ;
11919: LD_STRING ACH_CLEAN
11921: PPUSH
11922: CALL_OW 543
// end ; wait ( 0 0$2 ) ;
11926: LD_INT 70
11928: PPUSH
11929: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11933: LD_INT 35
11935: PPUSH
11936: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11940: LD_INT 22
11942: PUSH
11943: LD_INT 2
11945: PUSH
11946: EMPTY
11947: LIST
11948: LIST
11949: PUSH
11950: LD_INT 21
11952: PUSH
11953: LD_INT 1
11955: PUSH
11956: EMPTY
11957: LIST
11958: LIST
11959: PUSH
11960: LD_INT 3
11962: PUSH
11963: LD_INT 50
11965: PUSH
11966: EMPTY
11967: LIST
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: LIST
11977: PPUSH
11978: CALL_OW 69
11982: NOT
11983: IFFALSE 11933
// InGameOn ;
11985: CALL_OW 8
// if not GetSide ( usDepot ) = 2 then
11989: LD_INT 11
11991: PPUSH
11992: CALL_OW 255
11996: PUSH
11997: LD_INT 2
11999: EQUAL
12000: NOT
12001: IFFALSE 12013
// SetSide ( usDepot , 2 ) ;
12003: LD_INT 11
12005: PPUSH
12006: LD_INT 2
12008: PPUSH
12009: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
12013: LD_INT 35
12015: PPUSH
12016: LD_INT 22
12018: PPUSH
12019: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
12023: LD_EXP 28
12027: PPUSH
12028: LD_INT 35
12030: PPUSH
12031: LD_INT 22
12033: PPUSH
12034: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
12038: LD_EXP 28
12042: PPUSH
12043: LD_INT 38
12045: PPUSH
12046: LD_INT 25
12048: PPUSH
12049: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
12053: LD_EXP 41
12057: PUSH
12058: LD_EXP 42
12062: UNION
12063: PPUSH
12064: LD_INT 39
12066: PPUSH
12067: LD_INT 26
12069: PPUSH
12070: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
12074: LD_EXP 41
12078: PUSH
12079: LD_EXP 42
12083: UNION
12084: PPUSH
12085: LD_EXP 28
12089: PPUSH
12090: CALL_OW 179
// p := 0 ;
12094: LD_ADDR_VAR 0 2
12098: PUSH
12099: LD_INT 0
12101: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12102: LD_INT 35
12104: PPUSH
12105: CALL_OW 67
// p := p + 1 ;
12109: LD_ADDR_VAR 0 2
12113: PUSH
12114: LD_VAR 0 2
12118: PUSH
12119: LD_INT 1
12121: PLUS
12122: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
12123: LD_EXP 28
12127: PPUSH
12128: CALL_OW 314
12132: NOT
12133: PUSH
12134: LD_VAR 0 2
12138: PUSH
12139: LD_INT 10
12141: GREATER
12142: OR
12143: IFFALSE 12102
// Say ( Heike , DH-1-capture ) ;
12145: LD_EXP 28
12149: PPUSH
12150: LD_STRING DH-1-capture
12152: PPUSH
12153: CALL_OW 88
// if Markov then
12157: LD_EXP 35
12161: IFFALSE 12175
// Say ( Markov , DMar-1-capture ) ;
12163: LD_EXP 35
12167: PPUSH
12168: LD_STRING DMar-1-capture
12170: PPUSH
12171: CALL_OW 88
// if Sophia then
12175: LD_EXP 34
12179: IFFALSE 12205
// begin Say ( Heike , DH-2-capture ) ;
12181: LD_EXP 28
12185: PPUSH
12186: LD_STRING DH-2-capture
12188: PPUSH
12189: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
12193: LD_EXP 34
12197: PPUSH
12198: LD_STRING DS-1-capture
12200: PPUSH
12201: CALL_OW 88
// end ; InGameOff ;
12205: CALL_OW 9
// music_nat := music_auto ;
12209: LD_ADDR_OWVAR 71
12213: PUSH
12214: LD_INT 0
12216: ST_TO_ADDR
// music_class := music_auto ;
12217: LD_ADDR_OWVAR 72
12221: PUSH
12222: LD_INT 0
12224: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
12225: LD_STRING ConstructBase
12227: PPUSH
12228: CALL_OW 337
// wait ( 0 0$3 ) ;
12232: LD_INT 105
12234: PPUSH
12235: CALL_OW 67
// americanBaseCaptured := true ;
12239: LD_ADDR_EXP 6
12243: PUSH
12244: LD_INT 1
12246: ST_TO_ADDR
// end ;
12247: PPOPN 2
12249: END
// every 0 0$1 trigger capturedCargoCounter >= 3 do
12250: LD_EXP 13
12254: PUSH
12255: LD_INT 3
12257: GREATEREQUAL
12258: IFFALSE 12270
12260: GO 12262
12262: DISABLE
// SetAchievement ( ACH_ENG ) ;
12263: LD_STRING ACH_ENG
12265: PPUSH
12266: CALL_OW 543
12270: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) >= 4 do
12271: LD_INT 22
12273: PUSH
12274: LD_INT 2
12276: PUSH
12277: EMPTY
12278: LIST
12279: LIST
12280: PUSH
12281: LD_INT 25
12283: PUSH
12284: LD_INT 15
12286: PUSH
12287: EMPTY
12288: LIST
12289: LIST
12290: PUSH
12291: EMPTY
12292: LIST
12293: LIST
12294: PPUSH
12295: CALL_OW 69
12299: PUSH
12300: LD_INT 4
12302: GREATEREQUAL
12303: IFFALSE 12315
12305: GO 12307
12307: DISABLE
// SetAchievement ( ACH_APEGEN ) ;
12308: LD_STRING ACH_APEGEN
12310: PPUSH
12311: CALL_OW 543
12315: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
12316: LD_INT 22
12318: PUSH
12319: LD_INT 2
12321: PUSH
12322: EMPTY
12323: LIST
12324: LIST
12325: PUSH
12326: LD_INT 30
12328: PUSH
12329: LD_INT 2
12331: PUSH
12332: EMPTY
12333: LIST
12334: LIST
12335: PUSH
12336: LD_INT 3
12338: PUSH
12339: LD_INT 57
12341: PUSH
12342: EMPTY
12343: LIST
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: PUSH
12349: EMPTY
12350: LIST
12351: LIST
12352: LIST
12353: PPUSH
12354: CALL_OW 69
12358: IFFALSE 12601
12360: GO 12362
12362: DISABLE
// begin workshopBuilded := true ;
12363: LD_ADDR_EXP 10
12367: PUSH
12368: LD_INT 1
12370: ST_TO_ADDR
// if IsOk ( Markov ) then
12371: LD_EXP 35
12375: PPUSH
12376: CALL_OW 302
12380: IFFALSE 12439
// begin Say ( Heike , DH-1-shop-a ) ;
12382: LD_EXP 28
12386: PPUSH
12387: LD_STRING DH-1-shop-a
12389: PPUSH
12390: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
12394: LD_INT 47
12396: PPUSH
12397: LD_INT 2
12399: PPUSH
12400: CALL_OW 321
12404: PUSH
12405: LD_INT 2
12407: EQUAL
12408: PUSH
12409: LD_INT 45
12411: PPUSH
12412: LD_INT 2
12414: PPUSH
12415: CALL_OW 321
12419: PUSH
12420: LD_INT 2
12422: EQUAL
12423: AND
12424: NOT
12425: IFFALSE 12439
// Say ( Markov , DMar-1-shop-a ) ;
12427: LD_EXP 35
12431: PPUSH
12432: LD_STRING DMar-1-shop-a
12434: PPUSH
12435: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
12439: LD_INT 35
12441: PPUSH
12442: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched or GetTech ( tech_SolEng , 2 ) = state_researched ;
12446: LD_INT 47
12448: PPUSH
12449: LD_INT 2
12451: PPUSH
12452: CALL_OW 321
12456: PUSH
12457: LD_INT 2
12459: EQUAL
12460: PUSH
12461: LD_INT 45
12463: PPUSH
12464: LD_INT 2
12466: PPUSH
12467: CALL_OW 321
12471: PUSH
12472: LD_INT 2
12474: EQUAL
12475: OR
12476: IFFALSE 12439
// DialogueOn ;
12478: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
12482: LD_EXP 35
12486: PPUSH
12487: LD_STRING DMar-1-shop
12489: PPUSH
12490: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
12494: LD_EXP 28
12498: PPUSH
12499: LD_STRING DH-1-shop
12501: PPUSH
12502: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12506: LD_EXP 35
12510: PPUSH
12511: LD_STRING DMar-2-shop
12513: PPUSH
12514: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12518: LD_EXP 35
12522: PPUSH
12523: LD_STRING DMar-3-shop
12525: PPUSH
12526: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12530: LD_EXP 28
12534: PPUSH
12535: LD_STRING DH-2-shop
12537: PPUSH
12538: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12542: LD_EXP 35
12546: PPUSH
12547: LD_STRING DMar-4-shop
12549: PPUSH
12550: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12554: LD_EXP 28
12558: PPUSH
12559: LD_STRING DH-3-shop
12561: PPUSH
12562: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12566: LD_EXP 35
12570: PPUSH
12571: LD_STRING DMar-5-shop
12573: PPUSH
12574: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12578: LD_EXP 28
12582: PPUSH
12583: LD_STRING DH-4-shop
12585: PPUSH
12586: CALL_OW 88
// DialogueOff ;
12590: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12594: LD_STRING ConstructVeh
12596: PPUSH
12597: CALL_OW 337
// end ;
12601: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12602: LD_INT 2
12604: PPUSH
12605: LD_INT 2
12607: PPUSH
12608: LD_INT 1
12610: PPUSH
12611: CALL 1207 0 3
12615: PUSH
12616: LD_INT 0
12618: EQUAL
12619: IFFALSE 12631
12621: GO 12623
12623: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12624: LD_STRING Techs
12626: PPUSH
12627: CALL_OW 337
12631: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12632: LD_EXP 35
12636: PPUSH
12637: CALL_OW 302
12641: PUSH
12642: LD_INT 22
12644: PUSH
12645: LD_INT 2
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: LD_INT 2
12654: PUSH
12655: LD_INT 34
12657: PUSH
12658: LD_INT 22
12660: PUSH
12661: EMPTY
12662: LIST
12663: LIST
12664: PUSH
12665: LD_INT 35
12667: PUSH
12668: LD_INT 22
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: LIST
12679: PUSH
12680: EMPTY
12681: LIST
12682: LIST
12683: PPUSH
12684: CALL_OW 69
12688: AND
12689: IFFALSE 12796
12691: GO 12693
12693: DISABLE
// begin DialogueOn ;
12694: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12698: LD_INT 22
12700: PUSH
12701: LD_INT 2
12703: PUSH
12704: EMPTY
12705: LIST
12706: LIST
12707: PUSH
12708: LD_INT 2
12710: PUSH
12711: LD_INT 34
12713: PUSH
12714: LD_INT 22
12716: PUSH
12717: EMPTY
12718: LIST
12719: LIST
12720: PUSH
12721: LD_INT 35
12723: PUSH
12724: LD_INT 22
12726: PUSH
12727: EMPTY
12728: LIST
12729: LIST
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: LIST
12735: PUSH
12736: EMPTY
12737: LIST
12738: LIST
12739: PPUSH
12740: CALL_OW 69
12744: PPUSH
12745: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12749: LD_INT 10
12751: PPUSH
12752: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12756: LD_EXP 28
12760: PPUSH
12761: LD_STRING DH-1-bal
12763: PPUSH
12764: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12768: LD_EXP 35
12772: PPUSH
12773: LD_STRING DMar-1-bal
12775: PPUSH
12776: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12780: LD_EXP 28
12784: PPUSH
12785: LD_STRING DH-2-bal
12787: PPUSH
12788: CALL_OW 88
// DialogueOff ;
12792: CALL_OW 7
// end ;
12796: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12797: LD_EXP 32
12801: PPUSH
12802: CALL_OW 302
12806: PUSH
12807: LD_INT 22
12809: PUSH
12810: LD_INT 2
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: LD_INT 30
12819: PUSH
12820: LD_INT 6
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PPUSH
12831: CALL_OW 69
12835: AND
12836: IFFALSE 12897
12838: GO 12840
12840: DISABLE
// begin DialogueOn ;
12841: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12845: LD_EXP 32
12849: PPUSH
12850: LD_STRING DA-1-lab
12852: PPUSH
12853: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12857: LD_EXP 28
12861: PPUSH
12862: LD_STRING DH-1-lab
12864: PPUSH
12865: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12869: LD_EXP 32
12873: PPUSH
12874: LD_STRING DA-2-lab
12876: PPUSH
12877: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12881: LD_EXP 28
12885: PPUSH
12886: LD_STRING DH-2-lab
12888: PPUSH
12889: CALL_OW 88
// DialogueOff ;
12893: CALL_OW 7
// end ;
12897: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12898: LD_EXP 33
12902: PPUSH
12903: CALL_OW 302
12907: PUSH
12908: LD_INT 22
12910: PUSH
12911: LD_INT 2
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: PUSH
12918: LD_INT 25
12920: PUSH
12921: LD_INT 15
12923: PUSH
12924: EMPTY
12925: LIST
12926: LIST
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: PPUSH
12932: CALL_OW 69
12936: AND
12937: PUSH
12938: LD_INT 81
12940: PUSH
12941: LD_INT 2
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PPUSH
12948: CALL_OW 69
12952: NOT
12953: AND
12954: IFFALSE 13136
12956: GO 12958
12958: DISABLE
12959: LD_INT 0
12961: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12962: LD_ADDR_VAR 0 1
12966: PUSH
12967: LD_INT 22
12969: PUSH
12970: LD_INT 2
12972: PUSH
12973: EMPTY
12974: LIST
12975: LIST
12976: PUSH
12977: LD_INT 25
12979: PUSH
12980: LD_INT 15
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: PPUSH
12991: CALL_OW 69
12995: ST_TO_ADDR
// InGameOn ;
12996: CALL_OW 8
// CenterNowOnUnits ( ape [ 1 ] ) ;
13000: LD_VAR 0 1
13004: PUSH
13005: LD_INT 1
13007: ARRAY
13008: PPUSH
13009: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
13013: LD_VAR 0 1
13017: PUSH
13018: LD_INT 1
13020: ARRAY
13021: PPUSH
13022: CALL_OW 122
// Say ( Kaia , DK-1-apesol ) ;
13026: LD_EXP 33
13030: PPUSH
13031: LD_STRING DK-1-apesol
13033: PPUSH
13034: CALL_OW 88
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
13038: LD_VAR 0 1
13042: PUSH
13043: LD_INT 1
13045: ARRAY
13046: PPUSH
13047: LD_INT 35
13049: PPUSH
13050: LD_INT 28
13052: PPUSH
13053: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
13057: LD_VAR 0 1
13061: PUSH
13062: LD_INT 1
13064: ARRAY
13065: PPUSH
13066: LD_INT 36
13068: PPUSH
13069: LD_INT 17
13071: PPUSH
13072: CALL_OW 171
// DialogueOn ;
13076: CALL_OW 6
// Say ( Aviradze , DA-1-apesol ) ;
13080: LD_EXP 32
13084: PPUSH
13085: LD_STRING DA-1-apesol
13087: PPUSH
13088: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
13092: LD_EXP 33
13096: PPUSH
13097: LD_STRING DK-2-apesol
13099: PPUSH
13100: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
13104: LD_EXP 32
13108: PPUSH
13109: LD_STRING DA-2-apesol
13111: PPUSH
13112: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
13116: LD_EXP 33
13120: PPUSH
13121: LD_STRING DK-3-apesol
13123: PPUSH
13124: CALL_OW 88
// DialogueOff ;
13128: CALL_OW 7
// InGameOff ;
13132: CALL_OW 9
// end ;
13136: PPOPN 1
13138: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
13139: LD_EXP 34
13143: PPUSH
13144: CALL_OW 302
13148: PUSH
13149: LD_INT 22
13151: PUSH
13152: LD_INT 2
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: PUSH
13159: LD_INT 25
13161: PUSH
13162: LD_INT 16
13164: PUSH
13165: EMPTY
13166: LIST
13167: LIST
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PPUSH
13173: CALL_OW 69
13177: AND
13178: PUSH
13179: LD_INT 81
13181: PUSH
13182: LD_INT 2
13184: PUSH
13185: EMPTY
13186: LIST
13187: LIST
13188: PPUSH
13189: CALL_OW 69
13193: NOT
13194: AND
13195: IFFALSE 13458
13197: GO 13199
13199: DISABLE
13200: LD_INT 0
13202: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
13203: LD_ADDR_VAR 0 1
13207: PUSH
13208: LD_INT 22
13210: PUSH
13211: LD_INT 2
13213: PUSH
13214: EMPTY
13215: LIST
13216: LIST
13217: PUSH
13218: LD_INT 25
13220: PUSH
13221: LD_INT 16
13223: PUSH
13224: EMPTY
13225: LIST
13226: LIST
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PPUSH
13232: CALL_OW 69
13236: ST_TO_ADDR
// InGameOn ;
13237: CALL_OW 8
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
13241: LD_INT 5
13243: PPUSH
13244: LD_INT 35
13246: PPUSH
13247: LD_INT 22
13249: PPUSH
13250: LD_INT 1
13252: PPUSH
13253: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
13257: LD_EXP 34
13261: PPUSH
13262: LD_VAR 0 1
13266: PUSH
13267: LD_INT 1
13269: ARRAY
13270: PPUSH
13271: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
13275: LD_VAR 0 1
13279: PUSH
13280: LD_INT 1
13282: ARRAY
13283: PPUSH
13284: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
13288: LD_VAR 0 1
13292: PUSH
13293: LD_INT 1
13295: ARRAY
13296: PPUSH
13297: CALL_OW 122
// wait ( 0 0$2 ) ;
13301: LD_INT 70
13303: PPUSH
13304: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
13308: LD_EXP 34
13312: PPUSH
13313: LD_STRING DS-1-apeeng
13315: PPUSH
13316: CALL_OW 88
// if IsOk ( Kamil ) then
13320: LD_EXP 31
13324: PPUSH
13325: CALL_OW 302
13329: IFFALSE 13454
// begin Say ( Kamil , DKam-1-apeeng ) ;
13331: LD_EXP 31
13335: PPUSH
13336: LD_STRING DKam-1-apeeng
13338: PPUSH
13339: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
13343: LD_EXP 34
13347: PPUSH
13348: LD_STRING DS-2-apeeng
13350: PPUSH
13351: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
13355: LD_EXP 31
13359: PPUSH
13360: LD_STRING DKam-2-apeeng
13362: PPUSH
13363: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
13367: LD_EXP 34
13371: PPUSH
13372: LD_STRING DS-3-apeeng
13374: PPUSH
13375: CALL_OW 88
// if not IsOK ( Kaia ) then
13379: LD_EXP 33
13383: PPUSH
13384: CALL_OW 302
13388: NOT
13389: IFFALSE 13397
// begin InGameOff ;
13391: CALL_OW 9
// exit ;
13395: GO 13458
// end ; Say ( Kaia , DK-1-apeeng ) ;
13397: LD_EXP 33
13401: PPUSH
13402: LD_STRING DK-1-apeeng
13404: PPUSH
13405: CALL_OW 88
// if not IsOk ( Givi ) then
13409: LD_EXP 29
13413: PPUSH
13414: CALL_OW 302
13418: NOT
13419: IFFALSE 13430
// begin Video ( false ) ;
13421: LD_INT 0
13423: PPUSH
13424: CALL 1036 0 1
// exit ;
13428: GO 13458
// end ; Say ( Givi , DG-1-apeeng ) ;
13430: LD_EXP 29
13434: PPUSH
13435: LD_STRING DG-1-apeeng
13437: PPUSH
13438: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
13442: LD_EXP 33
13446: PPUSH
13447: LD_STRING DK-2-apeeng
13449: PPUSH
13450: CALL_OW 88
// end ; InGameOff ;
13454: CALL_OW 9
// end ;
13458: PPOPN 1
13460: END
// every 0 0$10 trigger farmerBaseReady and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) do
13461: LD_EXP 4
13465: PUSH
13466: LD_INT 22
13468: PUSH
13469: LD_INT 2
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: PUSH
13476: LD_INT 30
13478: PUSH
13479: LD_INT 0
13481: PUSH
13482: EMPTY
13483: LIST
13484: LIST
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PPUSH
13490: CALL_OW 69
13494: AND
13495: IFFALSE 13660
13497: GO 13499
13499: DISABLE
// begin wait ( 0 0$10 ) ;
13500: LD_INT 350
13502: PPUSH
13503: CALL_OW 67
// DialogueOn ;
13507: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
13511: LD_EXP 36
13515: PPUSH
13516: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
13520: LD_EXP 36
13524: PPUSH
13525: LD_STRING DF-1-distribution
13527: PPUSH
13528: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
13532: LD_EXP 28
13536: PPUSH
13537: LD_STRING DH-2-distribution
13539: PPUSH
13540: CALL_OW 88
// if IsOk ( Kaia ) then
13544: LD_EXP 33
13548: PPUSH
13549: CALL_OW 302
13553: IFFALSE 13614
// begin Say ( Kaia , DK-1-distribution ) ;
13555: LD_EXP 33
13559: PPUSH
13560: LD_STRING DK-1-distribution
13562: PPUSH
13563: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13567: LD_EXP 28
13571: PPUSH
13572: LD_STRING DH-1-distribution
13574: PPUSH
13575: CALL_OW 88
// if IsOk ( Givi ) then
13579: LD_EXP 29
13583: PPUSH
13584: CALL_OW 302
13588: IFFALSE 13614
// begin Say ( Givi , DG-1-distribution ) ;
13590: LD_EXP 29
13594: PPUSH
13595: LD_STRING DG-1-distribution
13597: PPUSH
13598: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13602: LD_EXP 28
13606: PPUSH
13607: LD_STRING DH-3-distribution
13609: PPUSH
13610: CALL_OW 88
// end ; end ; DialogueOff ;
13614: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13618: LD_STRING Crates1
13620: PPUSH
13621: CALL_OW 337
// farmerRequestedCrates := 300 ;
13625: LD_ADDR_EXP 16
13629: PUSH
13630: LD_INT 300
13632: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13633: LD_STRING FarmerCrates
13635: PPUSH
13636: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13640: LD_INT 10
13642: PPUSH
13643: LD_INT 1
13645: PPUSH
13646: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13650: LD_INT 108
13652: PPUSH
13653: LD_INT 61
13655: PPUSH
13656: CALL_OW 86
// end ;
13660: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13661: LD_EXP 6
13665: PUSH
13666: LD_INT 22
13668: PUSH
13669: LD_INT 2
13671: PUSH
13672: EMPTY
13673: LIST
13674: LIST
13675: PUSH
13676: LD_INT 3
13678: PUSH
13679: LD_INT 57
13681: PUSH
13682: EMPTY
13683: LIST
13684: PUSH
13685: EMPTY
13686: LIST
13687: LIST
13688: PUSH
13689: LD_INT 2
13691: PUSH
13692: LD_INT 30
13694: PUSH
13695: LD_INT 6
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PUSH
13702: LD_INT 30
13704: PUSH
13705: LD_INT 7
13707: PUSH
13708: EMPTY
13709: LIST
13710: LIST
13711: PUSH
13712: EMPTY
13713: LIST
13714: LIST
13715: LIST
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: LIST
13721: PPUSH
13722: CALL_OW 69
13726: AND
13727: PUSH
13728: LD_INT 22
13730: PUSH
13731: LD_INT 2
13733: PUSH
13734: EMPTY
13735: LIST
13736: LIST
13737: PUSH
13738: LD_INT 3
13740: PUSH
13741: LD_INT 57
13743: PUSH
13744: EMPTY
13745: LIST
13746: PUSH
13747: EMPTY
13748: LIST
13749: LIST
13750: PUSH
13751: LD_INT 30
13753: PUSH
13754: LD_INT 4
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: PUSH
13761: EMPTY
13762: LIST
13763: LIST
13764: LIST
13765: PPUSH
13766: CALL_OW 69
13770: AND
13771: IFFALSE 13935
13773: GO 13775
13775: DISABLE
13776: LD_INT 0
13778: PPUSH
// begin wait ( 0 0$10 ) ;
13779: LD_INT 350
13781: PPUSH
13782: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13786: LD_ADDR_VAR 0 1
13790: PUSH
13791: LD_EXP 42
13795: PPUSH
13796: LD_INT 26
13798: PUSH
13799: LD_INT 1
13801: PUSH
13802: EMPTY
13803: LIST
13804: LIST
13805: PUSH
13806: LD_INT 25
13808: PUSH
13809: LD_INT 2
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: PPUSH
13820: CALL_OW 72
13824: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13825: LD_EXP 28
13829: PPUSH
13830: LD_STRING DH-1-task
13832: PPUSH
13833: CALL_OW 88
// if IsOk ( Sophia ) then
13837: LD_EXP 34
13841: PPUSH
13842: CALL_OW 302
13846: IFFALSE 13886
// begin Say ( Sophia , DS-1-task ) ;
13848: LD_EXP 34
13852: PPUSH
13853: LD_STRING DS-1-task
13855: PPUSH
13856: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13860: LD_EXP 34
13864: PPUSH
13865: LD_STRING DS-2-task
13867: PPUSH
13868: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13872: LD_EXP 28
13876: PPUSH
13877: LD_STRING DH-2-task
13879: PPUSH
13880: CALL_OW 88
// end else
13884: GO 13920
// if eng then
13886: LD_VAR 0 1
13890: IFFALSE 13920
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13892: LD_VAR 0 1
13896: PUSH
13897: LD_INT 1
13899: ARRAY
13900: PPUSH
13901: LD_STRING DArm-1-task
13903: PPUSH
13904: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13908: LD_EXP 28
13912: PPUSH
13913: LD_STRING DH-2-task
13915: PPUSH
13916: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13920: LD_STRING BaseConstructed
13922: PPUSH
13923: CALL_OW 337
// allowConvoys := true ;
13927: LD_ADDR_EXP 12
13931: PUSH
13932: LD_INT 1
13934: ST_TO_ADDR
// end ;
13935: PPOPN 1
13937: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13938: LD_INT 22
13940: PUSH
13941: LD_INT 4
13943: PUSH
13944: EMPTY
13945: LIST
13946: LIST
13947: PUSH
13948: LD_INT 34
13950: PUSH
13951: LD_INT 12
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: PPUSH
13962: CALL_OW 69
13966: IFFALSE 14134
13968: GO 13970
13970: DISABLE
13971: LD_INT 0
13973: PPUSH
13974: PPUSH
13975: PPUSH
// begin wait ( 0 0$2 ) ;
13976: LD_INT 70
13978: PPUSH
13979: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13983: LD_ADDR_VAR 0 1
13987: PUSH
13988: LD_INT 22
13990: PUSH
13991: LD_INT 4
13993: PUSH
13994: EMPTY
13995: LIST
13996: LIST
13997: PUSH
13998: LD_INT 34
14000: PUSH
14001: LD_INT 12
14003: PUSH
14004: EMPTY
14005: LIST
14006: LIST
14007: PUSH
14008: EMPTY
14009: LIST
14010: LIST
14011: PPUSH
14012: CALL_OW 69
14016: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
14017: LD_ADDR_VAR 0 2
14021: PUSH
14022: LD_VAR 0 1
14026: PUSH
14027: LD_INT 1
14029: ARRAY
14030: PPUSH
14031: CALL_OW 250
14035: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
14036: LD_ADDR_VAR 0 3
14040: PUSH
14041: LD_VAR 0 1
14045: PUSH
14046: LD_INT 1
14048: ARRAY
14049: PPUSH
14050: CALL_OW 251
14054: ST_TO_ADDR
// DialogueOn ;
14055: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
14059: LD_VAR 0 2
14063: PPUSH
14064: LD_VAR 0 3
14068: PPUSH
14069: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
14073: LD_VAR 0 2
14077: PPUSH
14078: LD_VAR 0 3
14082: PPUSH
14083: LD_INT 2
14085: PPUSH
14086: LD_INT 6
14088: NEG
14089: PPUSH
14090: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
14094: LD_INT 10
14096: PPUSH
14097: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
14101: LD_EXP 28
14105: PPUSH
14106: LD_STRING DH-1-seecargo
14108: PPUSH
14109: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
14113: LD_VAR 0 2
14117: PPUSH
14118: LD_VAR 0 3
14122: PPUSH
14123: LD_INT 2
14125: PPUSH
14126: CALL_OW 331
// DialogueOff ;
14130: CALL_OW 7
// end ;
14134: PPOPN 3
14136: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
14137: LD_EXP 4
14141: PUSH
14142: LD_EXP 15
14146: PUSH
14147: LD_INT 300
14149: GREATEREQUAL
14150: AND
14151: IFFALSE 14223
14153: GO 14155
14155: DISABLE
// begin DialogueOn ;
14156: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
14160: LD_EXP 36
14164: PPUSH
14165: LD_STRING DF-1-delivery-2
14167: PPUSH
14168: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
14172: LD_EXP 28
14176: PPUSH
14177: LD_STRING DH-1-delivery-2
14179: PPUSH
14180: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
14184: LD_EXP 36
14188: PPUSH
14189: LD_STRING DF-2-delivery-2
14191: PPUSH
14192: CALL_OW 94
// DialogueOff ;
14196: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
14200: LD_STRING Crates2
14202: PPUSH
14203: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14207: LD_ADDR_EXP 17
14211: PUSH
14212: LD_INT 63000
14214: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
14215: LD_ADDR_EXP 16
14219: PUSH
14220: LD_INT 600
14222: ST_TO_ADDR
// end ;
14223: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 and Difficulty > 1 do
14224: LD_EXP 4
14228: PUSH
14229: LD_EXP 15
14233: PUSH
14234: LD_INT 600
14236: GREATEREQUAL
14237: AND
14238: PUSH
14239: LD_OWVAR 67
14243: PUSH
14244: LD_INT 1
14246: GREATER
14247: AND
14248: IFFALSE 14414
14250: GO 14252
14252: DISABLE
// begin DialogueOn ;
14253: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
14257: LD_EXP 36
14261: PPUSH
14262: LD_STRING DF-1-delivery-3
14264: PPUSH
14265: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
14269: LD_EXP 28
14273: PPUSH
14274: LD_STRING DH-1-delivery-3
14276: PPUSH
14277: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
14281: LD_EXP 36
14285: PPUSH
14286: LD_STRING DF-2-delivery-3
14288: PPUSH
14289: CALL_OW 94
// if IsOk ( Kaia ) then
14293: LD_EXP 33
14297: PPUSH
14298: CALL_OW 302
14302: IFFALSE 14352
// begin Say ( Kaia , DK-1-delivery-3 ) ;
14304: LD_EXP 33
14308: PPUSH
14309: LD_STRING DK-1-delivery-3
14311: PPUSH
14312: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
14316: LD_EXP 28
14320: PPUSH
14321: LD_STRING DH-2-delivery-3
14323: PPUSH
14324: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
14328: LD_EXP 29
14332: PPUSH
14333: LD_STRING DG-1-delivery-3
14335: PPUSH
14336: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
14340: LD_EXP 30
14344: PPUSH
14345: LD_STRING DM-1-delivery-3
14347: PPUSH
14348: CALL_OW 88
// end ; DialogueOff ;
14352: CALL_OW 7
// if Difficulty = 2 then
14356: LD_OWVAR 67
14360: PUSH
14361: LD_INT 2
14363: EQUAL
14364: IFFALSE 14391
// begin ChangeMissionObjectives ( Crates3 ) ;
14366: LD_STRING Crates3
14368: PPUSH
14369: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14373: LD_ADDR_EXP 17
14377: PUSH
14378: LD_INT 63000
14380: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
14381: LD_ADDR_EXP 16
14385: PUSH
14386: LD_INT 900
14388: ST_TO_ADDR
// end else
14389: GO 14414
// begin ChangeMissionObjectives ( Crates4 ) ;
14391: LD_STRING Crates4
14393: PPUSH
14394: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14398: LD_ADDR_EXP 17
14402: PUSH
14403: LD_INT 63000
14405: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
14406: LD_ADDR_EXP 16
14410: PUSH
14411: LD_INT 1200
14413: ST_TO_ADDR
// end ; end ;
14414: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
14415: LD_EXP 4
14419: PUSH
14420: LD_EXP 15
14424: PUSH
14425: LD_INT 600
14427: PUSH
14428: LD_INT 900
14430: PUSH
14431: LD_INT 1200
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: LIST
14438: PUSH
14439: LD_OWVAR 67
14443: ARRAY
14444: GREATEREQUAL
14445: AND
14446: PUSH
14447: LD_EXP 16
14451: PUSH
14452: LD_EXP 17
14456: LESSEQUAL
14457: AND
14458: IFFALSE 14525
14460: GO 14462
14462: DISABLE
// begin retreatAllowed := true ;
14463: LD_ADDR_EXP 11
14467: PUSH
14468: LD_INT 1
14470: ST_TO_ADDR
// display_strings := [ ] ;
14471: LD_ADDR_OWVAR 47
14475: PUSH
14476: EMPTY
14477: ST_TO_ADDR
// DialogueOn ;
14478: CALL_OW 6
// InGameOn ;
14482: CALL_OW 8
// SayRadio ( Omar , DO-radio-end ) ;
14486: LD_EXP 37
14490: PPUSH
14491: LD_STRING DO-radio-end
14493: PPUSH
14494: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
14498: LD_EXP 28
14502: PPUSH
14503: LD_STRING DH-1-radio-end
14505: PPUSH
14506: CALL_OW 88
// InGameOff ;
14510: CALL_OW 9
// DialogueOff ;
14514: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
14518: LD_STRING Retreat
14520: PPUSH
14521: CALL_OW 337
// end ;
14525: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
14526: LD_EXP 11
14530: IFFALSE 14661
14532: GO 14534
14534: DISABLE
14535: LD_INT 0
14537: PPUSH
14538: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
14539: LD_INT 10
14541: PPUSH
14542: LD_INT 0
14544: PPUSH
14545: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
14549: LD_ADDR_VAR 0 1
14553: PUSH
14554: LD_EXP 39
14558: PPUSH
14559: LD_INT 25
14561: PUSH
14562: LD_INT 2
14564: PUSH
14565: EMPTY
14566: LIST
14567: LIST
14568: PPUSH
14569: CALL_OW 72
14573: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14574: LD_VAR 0 1
14578: PUSH
14579: LD_INT 102
14581: PPUSH
14582: LD_INT 69
14584: PPUSH
14585: CALL_OW 428
14589: PUSH
14590: LD_INT 0
14592: EQUAL
14593: AND
14594: IFFALSE 14661
// begin for i in tmp do
14596: LD_ADDR_VAR 0 2
14600: PUSH
14601: LD_VAR 0 1
14605: PUSH
14606: FOR_IN
14607: IFFALSE 14631
// if IsInUnit ( i ) then
14609: LD_VAR 0 2
14613: PPUSH
14614: CALL_OW 310
14618: IFFALSE 14629
// ComExitBuilding ( i ) ;
14620: LD_VAR 0 2
14624: PPUSH
14625: CALL_OW 122
14629: GO 14606
14631: POP
14632: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14633: LD_VAR 0 1
14637: PPUSH
14638: LD_INT 31
14640: PPUSH
14641: LD_INT 102
14643: PPUSH
14644: LD_INT 69
14646: PPUSH
14647: LD_INT 2
14649: PPUSH
14650: CALL_OW 205
// wait ( 0 0$3 ) ;
14654: LD_INT 105
14656: PPUSH
14657: CALL_OW 67
// end ; end ;
14661: PPOPN 2
14663: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14664: LD_EXP 11
14668: NOT
14669: PUSH
14670: LD_INT 5
14672: PPUSH
14673: CALL_OW 301
14677: AND
14678: IFFALSE 14710
14680: GO 14682
14682: DISABLE
// begin DialogueOn ;
14683: CALL_OW 6
// SayRadio ( Farmer , DF-1-failure ) ;
14687: LD_EXP 36
14691: PPUSH
14692: LD_STRING DF-1-failure
14694: PPUSH
14695: CALL_OW 94
// DialogueOff ;
14699: CALL_OW 7
// YouLost ( FarmerDepot ) ;
14703: LD_STRING FarmerDepot
14705: PPUSH
14706: CALL_OW 104
// end ;
14710: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 and not FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_type , unit_human ] ] ) do var i , max , tmp ;
14711: LD_EXP 11
14715: PUSH
14716: LD_EXP 28
14720: PPUSH
14721: LD_EXP 36
14725: PPUSH
14726: CALL_OW 296
14730: PUSH
14731: LD_INT 6
14733: LESS
14734: AND
14735: PUSH
14736: LD_INT 81
14738: PUSH
14739: LD_INT 2
14741: PUSH
14742: EMPTY
14743: LIST
14744: LIST
14745: PUSH
14746: LD_INT 21
14748: PUSH
14749: LD_INT 1
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PUSH
14756: EMPTY
14757: LIST
14758: LIST
14759: PPUSH
14760: CALL_OW 69
14764: NOT
14765: AND
14766: IFFALSE 15387
14768: GO 14770
14770: DISABLE
14771: LD_INT 0
14773: PPUSH
14774: PPUSH
14775: PPUSH
// begin allowConvoys := false ;
14776: LD_ADDR_EXP 12
14780: PUSH
14781: LD_INT 0
14783: ST_TO_ADDR
// InGameOn ;
14784: CALL_OW 8
// ComTurnUnit ( Heike , Farmer ) ;
14788: LD_EXP 28
14792: PPUSH
14793: LD_EXP 36
14797: PPUSH
14798: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14802: LD_EXP 36
14806: PPUSH
14807: LD_EXP 28
14811: PPUSH
14812: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14816: LD_EXP 36
14820: PPUSH
14821: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14825: LD_EXP 28
14829: PPUSH
14830: LD_STRING DH-1-end
14832: PPUSH
14833: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14837: LD_EXP 36
14841: PPUSH
14842: LD_STRING DF-1-end
14844: PPUSH
14845: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14849: LD_EXP 36
14853: PPUSH
14854: LD_STRING DF-2-end
14856: PPUSH
14857: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14861: LD_EXP 28
14865: PPUSH
14866: LD_STRING DH-2-end
14868: PPUSH
14869: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14873: LD_EXP 36
14877: PPUSH
14878: LD_STRING DF-3-end
14880: PPUSH
14881: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14885: LD_EXP 28
14889: PPUSH
14890: LD_STRING DH-3-end
14892: PPUSH
14893: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14897: LD_EXP 29
14901: PPUSH
14902: LD_STRING DG-1-end
14904: PPUSH
14905: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14909: LD_EXP 28
14913: PPUSH
14914: LD_STRING DH-4-end
14916: PPUSH
14917: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14921: LD_EXP 36
14925: PPUSH
14926: LD_STRING DF-4-end
14928: PPUSH
14929: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14933: LD_EXP 28
14937: PPUSH
14938: LD_STRING DH-5-end
14940: PPUSH
14941: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14945: LD_EXP 36
14949: PPUSH
14950: LD_STRING DF-5-end
14952: PPUSH
14953: CALL_OW 88
// InGameOff ;
14957: CALL_OW 9
// allowCargoEvacuation := true ;
14961: LD_ADDR_EXP 7
14965: PUSH
14966: LD_INT 1
14968: ST_TO_ADDR
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14969: LD_ADDR_VAR 0 2
14973: PUSH
14974: LD_INT 4
14976: PUSH
14977: LD_INT 3
14979: PUSH
14980: LD_INT 2
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: LIST
14987: PUSH
14988: LD_OWVAR 67
14992: ARRAY
14993: ST_TO_ADDR
// if farmerSquad < max then
14994: LD_EXP 39
14998: PUSH
14999: LD_VAR 0 2
15003: LESS
15004: IFFALSE 15016
// max := farmerSquad ;
15006: LD_ADDR_VAR 0 2
15010: PUSH
15011: LD_EXP 39
15015: ST_TO_ADDR
// for i := 1 to max do
15016: LD_ADDR_VAR 0 1
15020: PUSH
15021: DOUBLE
15022: LD_INT 1
15024: DEC
15025: ST_TO_ADDR
15026: LD_VAR 0 2
15030: PUSH
15031: FOR_TO
15032: IFFALSE 15070
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
15034: LD_EXP 39
15038: PUSH
15039: LD_INT 1
15041: ARRAY
15042: PPUSH
15043: LD_INT 2
15045: PPUSH
15046: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
15050: LD_ADDR_EXP 39
15054: PUSH
15055: LD_EXP 39
15059: PPUSH
15060: LD_INT 1
15062: PPUSH
15063: CALL_OW 3
15067: ST_TO_ADDR
// end ;
15068: GO 15031
15070: POP
15071: POP
// for i in Farmer ^ farmerSquad do
15072: LD_ADDR_VAR 0 1
15076: PUSH
15077: LD_EXP 36
15081: PUSH
15082: LD_EXP 39
15086: ADD
15087: PUSH
15088: FOR_IN
15089: IFFALSE 15128
// begin if IsInUnit ( i ) then
15091: LD_VAR 0 1
15095: PPUSH
15096: CALL_OW 310
15100: IFFALSE 15111
// ComExitBuilding ( i ) ;
15102: LD_VAR 0 1
15106: PPUSH
15107: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
15111: LD_VAR 0 1
15115: PPUSH
15116: LD_INT 102
15118: PPUSH
15119: LD_INT 7
15121: PPUSH
15122: CALL_OW 171
// end ;
15126: GO 15088
15128: POP
15129: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
15130: LD_ADDR_VAR 0 1
15134: PUSH
15135: LD_INT 22
15137: PUSH
15138: LD_INT 5
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: LD_INT 21
15147: PUSH
15148: LD_INT 3
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PPUSH
15159: CALL_OW 69
15163: PUSH
15164: LD_INT 5
15166: DIFF
15167: PUSH
15168: FOR_IN
15169: IFFALSE 15185
// SetSide ( i , 2 ) ;
15171: LD_VAR 0 1
15175: PPUSH
15176: LD_INT 2
15178: PPUSH
15179: CALL_OW 235
15183: GO 15168
15185: POP
15186: POP
// repeat wait ( 0 0$1 ) ;
15187: LD_INT 35
15189: PPUSH
15190: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
15194: LD_ADDR_VAR 0 3
15198: PUSH
15199: LD_EXP 36
15203: PUSH
15204: LD_EXP 39
15208: ADD
15209: PPUSH
15210: LD_INT 95
15212: PUSH
15213: LD_INT 3
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PPUSH
15220: CALL_OW 72
15224: ST_TO_ADDR
// if tmp then
15225: LD_VAR 0 3
15229: IFFALSE 15273
// for i in tmp do
15231: LD_ADDR_VAR 0 1
15235: PUSH
15236: LD_VAR 0 3
15240: PUSH
15241: FOR_IN
15242: IFFALSE 15271
// begin farmerSquad := farmerSquad diff i ;
15244: LD_ADDR_EXP 39
15248: PUSH
15249: LD_EXP 39
15253: PUSH
15254: LD_VAR 0 1
15258: DIFF
15259: ST_TO_ADDR
// RemoveUnit ( i ) ;
15260: LD_VAR 0 1
15264: PPUSH
15265: CALL_OW 64
// end ;
15269: GO 15241
15271: POP
15272: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
15273: LD_EXP 39
15277: PUSH
15278: EMPTY
15279: EQUAL
15280: PUSH
15281: LD_EXP 36
15285: PPUSH
15286: CALL_OW 305
15290: NOT
15291: AND
15292: IFFALSE 15187
// if farmerHumanLoseCounter = 0 then
15294: LD_EXP 20
15298: PUSH
15299: LD_INT 0
15301: EQUAL
15302: IFFALSE 15311
// SetAchievement ( ACH_BABY ) ;
15304: LD_STRING ACH_BABY
15306: PPUSH
15307: CALL_OW 543
// wait ( 1 1$00 ) ;
15311: LD_INT 2100
15313: PPUSH
15314: CALL_OW 67
// SendAttack ;
15318: CALL 7034 0 0
// for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: DOUBLE
15328: LD_INT 1
15330: DEC
15331: ST_TO_ADDR
15332: LD_INT 2
15334: PUSH
15335: LD_INT 3
15337: PUSH
15338: LD_INT 4
15340: PUSH
15341: EMPTY
15342: LIST
15343: LIST
15344: LIST
15345: PUSH
15346: LD_OWVAR 67
15350: ARRAY
15351: PUSH
15352: FOR_TO
15353: IFFALSE 15385
// begin wait ( [ 2 2$00 , 1 1$40 , 1 1$30 ] [ Difficulty ] ) ;
15355: LD_INT 4200
15357: PUSH
15358: LD_INT 3500
15360: PUSH
15361: LD_INT 3150
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: LIST
15368: PUSH
15369: LD_OWVAR 67
15373: ARRAY
15374: PPUSH
15375: CALL_OW 67
// SendAttack ;
15379: CALL 7034 0 0
// end ;
15383: GO 15352
15385: POP
15386: POP
// end ;
15387: PPOPN 3
15389: END
// every 0 0$1 trigger allowCargoEvacuation do
15390: LD_EXP 7
15394: IFFALSE 15403
15396: GO 15398
15398: DISABLE
// StartCargoEvacuation ;
15399: CALL 4570 0 0
15403: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
15404: LD_EXP 17
15408: PUSH
15409: LD_INT 18900
15411: LESSEQUAL
15412: IFFALSE 15461
15414: GO 15416
15416: DISABLE
// begin DialogueOn ;
15417: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
15421: LD_EXP 36
15425: PPUSH
15426: LD_STRING DF-1-distribution-a
15428: PPUSH
15429: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
15433: LD_EXP 28
15437: PPUSH
15438: LD_STRING DH-1-distribution-a
15440: PPUSH
15441: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
15445: LD_EXP 36
15449: PPUSH
15450: LD_STRING DF-2-distribution-a
15452: PPUSH
15453: CALL_OW 94
// DialogueOff ;
15457: CALL_OW 7
// end ;
15461: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
15462: LD_EXP 17
15466: PUSH
15467: LD_INT 0
15469: LESSEQUAL
15470: IFFALSE 15502
15472: GO 15474
15474: DISABLE
// begin DialogueOn ;
15475: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
15479: LD_EXP 36
15483: PPUSH
15484: LD_STRING DF-3-distribution-a
15486: PPUSH
15487: CALL_OW 94
// YouLost ( Distribution ) ;
15491: LD_STRING Distribution
15493: PPUSH
15494: CALL_OW 104
// DialogueOff ;
15498: CALL_OW 7
// end ;
15502: END
// every 0 0$1 trigger vehCounter >= 2 do
15503: LD_EXP 22
15507: PUSH
15508: LD_INT 2
15510: GREATEREQUAL
15511: IFFALSE 15523
15513: GO 15515
15515: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
15516: LD_STRING VehConstructed
15518: PPUSH
15519: CALL_OW 337
15523: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
15524: LD_INT 22
15526: PUSH
15527: LD_INT 2
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: PUSH
15534: LD_INT 34
15536: PUSH
15537: LD_INT 12
15539: PUSH
15540: EMPTY
15541: LIST
15542: LIST
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PPUSH
15548: CALL_OW 69
15552: IFFALSE 15612
15554: GO 15556
15556: DISABLE
// begin DialogueOn ;
15557: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
15561: LD_EXP 28
15565: PPUSH
15566: LD_STRING DH-1-truck
15568: PPUSH
15569: CALL_OW 88
// if IsOk ( Markov ) then
15573: LD_EXP 35
15577: PPUSH
15578: CALL_OW 302
15582: IFFALSE 15608
// begin Say ( Markov , DMar-1-truck ) ;
15584: LD_EXP 35
15588: PPUSH
15589: LD_STRING DMar-1-truck
15591: PPUSH
15592: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
15596: LD_EXP 28
15600: PPUSH
15601: LD_STRING DH-2-truck
15603: PPUSH
15604: CALL_OW 88
// end ; DialogueOff ;
15608: CALL_OW 7
// end ;
15612: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
15613: LD_INT 0
15615: PPUSH
15616: PPUSH
15617: PPUSH
// if IsOk ( Givi ) then
15618: LD_EXP 29
15622: PPUSH
15623: CALL_OW 302
15627: IFFALSE 15643
// begin Say ( Givi , DG-1-nocargo ) ;
15629: LD_EXP 29
15633: PPUSH
15634: LD_STRING DG-1-nocargo
15636: PPUSH
15637: CALL_OW 88
// exit ;
15641: GO 15739
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15643: LD_ADDR_VAR 0 2
15647: PUSH
15648: LD_EXP 42
15652: PPUSH
15653: LD_INT 26
15655: PUSH
15656: LD_INT 1
15658: PUSH
15659: EMPTY
15660: LIST
15661: LIST
15662: PPUSH
15663: CALL_OW 72
15667: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15668: LD_ADDR_VAR 0 3
15672: PUSH
15673: LD_EXP 42
15677: PPUSH
15678: LD_INT 26
15680: PUSH
15681: LD_INT 2
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: PPUSH
15688: CALL_OW 72
15692: ST_TO_ADDR
// if randomMen then
15693: LD_VAR 0 2
15697: IFFALSE 15717
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15699: LD_VAR 0 2
15703: PUSH
15704: LD_INT 1
15706: ARRAY
15707: PPUSH
15708: LD_STRING DArm-1-nocargo
15710: PPUSH
15711: CALL_OW 88
15715: GO 15739
// if randomWomen then
15717: LD_VAR 0 3
15721: IFFALSE 15739
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15723: LD_VAR 0 3
15727: PUSH
15728: LD_INT 1
15730: ARRAY
15731: PPUSH
15732: LD_STRING DArf-1-nocargo
15734: PPUSH
15735: CALL_OW 88
// end ;
15739: LD_VAR 0 1
15743: RET
// export function IncomingAttack ; begin
15744: LD_INT 0
15746: PPUSH
// if attackWave = 1 then
15747: LD_EXP 19
15751: PUSH
15752: LD_INT 1
15754: EQUAL
15755: IFFALSE 15826
// begin DialogueOn ;
15757: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15761: LD_EXP 37
15765: PPUSH
15766: LD_STRING DO-1-radio-1
15768: PPUSH
15769: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15773: LD_EXP 28
15777: PPUSH
15778: LD_STRING DH-1-radio-1-
15780: PPUSH
15781: CALL_OW 88
// if IsOk ( Markov ) then
15785: LD_EXP 35
15789: PPUSH
15790: CALL_OW 302
15794: IFFALSE 15820
// begin Say ( Markov , DMar-1-radio-1 ) ;
15796: LD_EXP 35
15800: PPUSH
15801: LD_STRING DMar-1-radio-1
15803: PPUSH
15804: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15808: LD_EXP 28
15812: PPUSH
15813: LD_STRING DH-2-radio-1
15815: PPUSH
15816: CALL_OW 88
// end ; DialogueOff ;
15820: CALL_OW 7
// end else
15824: GO 15850
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15826: LD_EXP 37
15830: PPUSH
15831: LD_STRING DO-1-radio-u
15833: PPUSH
15834: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15838: LD_EXP 28
15842: PPUSH
15843: LD_STRING DH-1-radio-u
15845: PPUSH
15846: CALL_OW 88
// end ; end ;
15850: LD_VAR 0 1
15854: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15855: LD_EXP 44
15859: PPUSH
15860: LD_INT 95
15862: PUSH
15863: LD_INT 8
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PPUSH
15870: CALL_OW 72
15874: IFFALSE 15977
15876: GO 15878
15878: DISABLE
15879: LD_INT 0
15881: PPUSH
// begin enable ;
15882: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15883: LD_ADDR_VAR 0 1
15887: PUSH
15888: LD_EXP 44
15892: PPUSH
15893: LD_INT 95
15895: PUSH
15896: LD_INT 8
15898: PUSH
15899: EMPTY
15900: LIST
15901: LIST
15902: PPUSH
15903: CALL_OW 72
15907: PUSH
15908: FOR_IN
15909: IFFALSE 15938
// begin usForces := usForces diff i ;
15911: LD_ADDR_EXP 44
15915: PUSH
15916: LD_EXP 44
15920: PUSH
15921: LD_VAR 0 1
15925: DIFF
15926: ST_TO_ADDR
// RemoveUnit ( i ) ;
15927: LD_VAR 0 1
15931: PPUSH
15932: CALL_OW 64
// end ;
15936: GO 15908
15938: POP
15939: POP
// if not americanHasEscaped and attackWave = 1 then
15940: LD_EXP 8
15944: NOT
15945: PUSH
15946: LD_EXP 19
15950: PUSH
15951: LD_INT 1
15953: EQUAL
15954: AND
15955: IFFALSE 15977
// begin americanHasEscaped := true ;
15957: LD_ADDR_EXP 8
15961: PUSH
15962: LD_INT 1
15964: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15965: LD_EXP 28
15969: PPUSH
15970: LD_STRING DH-2-assault-a
15972: PPUSH
15973: CALL_OW 88
// end ; end ;
15977: PPOPN 1
15979: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) and not retreatAllowed do
15980: LD_INT 4
15982: PPUSH
15983: LD_INT 22
15985: PUSH
15986: LD_INT 1
15988: PUSH
15989: EMPTY
15990: LIST
15991: LIST
15992: PPUSH
15993: CALL_OW 70
15997: PUSH
15998: LD_EXP 11
16002: NOT
16003: AND
16004: IFFALSE 16021
16006: GO 16008
16008: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
16009: LD_EXP 36
16013: PPUSH
16014: LD_STRING DF-1-attack
16016: PPUSH
16017: CALL_OW 94
16021: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
16022: LD_INT 5
16024: PPUSH
16025: CALL_OW 255
16029: PUSH
16030: LD_INT 2
16032: EQUAL
16033: IFFALSE 16045
16035: GO 16037
16037: DISABLE
// YouLost ( Attack ) ;
16038: LD_STRING Attack
16040: PPUSH
16041: CALL_OW 104
16045: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 90 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot ;
16046: LD_INT 22
16048: PUSH
16049: LD_INT 1
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PUSH
16056: LD_INT 21
16058: PUSH
16059: LD_INT 1
16061: PUSH
16062: EMPTY
16063: LIST
16064: LIST
16065: PUSH
16066: EMPTY
16067: LIST
16068: LIST
16069: PPUSH
16070: CALL_OW 69
16074: NOT
16075: PUSH
16076: LD_INT 22
16078: PUSH
16079: LD_INT 4
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: PPUSH
16086: CALL_OW 69
16090: NOT
16091: AND
16092: PUSH
16093: LD_EXP 11
16097: NOT
16098: AND
16099: PUSH
16100: LD_EXP 15
16104: PUSH
16105: LD_INT 90
16107: GREATER
16108: AND
16109: PUSH
16110: LD_INT 7
16112: PPUSH
16113: LD_INT 22
16115: PUSH
16116: LD_INT 2
16118: PUSH
16119: EMPTY
16120: LIST
16121: LIST
16122: PUSH
16123: LD_INT 21
16125: PUSH
16126: LD_INT 1
16128: PUSH
16129: EMPTY
16130: LIST
16131: LIST
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: PPUSH
16137: CALL_OW 70
16141: AND
16142: PUSH
16143: LD_INT 22
16145: PUSH
16146: LD_INT 2
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: PUSH
16153: LD_INT 50
16155: PUSH
16156: EMPTY
16157: LIST
16158: PUSH
16159: LD_INT 30
16161: PUSH
16162: LD_INT 0
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: LIST
16173: PPUSH
16174: CALL_OW 69
16178: AND
16179: IFFALSE 16880
16181: GO 16183
16183: DISABLE
16184: LD_INT 0
16186: PPUSH
16187: PPUSH
16188: PPUSH
16189: PPUSH
16190: PPUSH
// begin depot := usDepot ;
16191: LD_ADDR_VAR 0 5
16195: PUSH
16196: LD_INT 11
16198: ST_TO_ADDR
// if not depot then
16199: LD_VAR 0 5
16203: NOT
16204: IFFALSE 16244
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
16206: LD_ADDR_VAR 0 5
16210: PUSH
16211: LD_INT 22
16213: PUSH
16214: LD_INT 2
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: PUSH
16221: LD_INT 30
16223: PUSH
16224: LD_INT 0
16226: PUSH
16227: EMPTY
16228: LIST
16229: LIST
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: PPUSH
16235: CALL_OW 69
16239: PUSH
16240: LD_INT 1
16242: ARRAY
16243: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
16244: LD_ADDR_VAR 0 1
16248: PUSH
16249: LD_EXP 42
16253: PPUSH
16254: LD_INT 26
16256: PUSH
16257: LD_INT 1
16259: PUSH
16260: EMPTY
16261: LIST
16262: LIST
16263: PPUSH
16264: CALL_OW 72
16268: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
16269: LD_ADDR_VAR 0 2
16273: PUSH
16274: LD_EXP 42
16278: PPUSH
16279: LD_INT 26
16281: PUSH
16282: LD_INT 2
16284: PUSH
16285: EMPTY
16286: LIST
16287: LIST
16288: PPUSH
16289: CALL_OW 72
16293: ST_TO_ADDR
// if IsOk ( Kaia ) then
16294: LD_EXP 33
16298: PPUSH
16299: CALL_OW 302
16303: IFFALSE 16324
// speaker := [ Kaia , DK ] else
16305: LD_ADDR_VAR 0 3
16309: PUSH
16310: LD_EXP 33
16314: PUSH
16315: LD_STRING DK
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: ST_TO_ADDR
16322: GO 16404
// if randomMen then
16324: LD_VAR 0 1
16328: IFFALSE 16363
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
16330: LD_ADDR_VAR 0 3
16334: PUSH
16335: LD_VAR 0 1
16339: PUSH
16340: LD_INT 1
16342: PPUSH
16343: LD_VAR 0 1
16347: PPUSH
16348: CALL_OW 12
16352: ARRAY
16353: PUSH
16354: LD_STRING DArm
16356: PUSH
16357: EMPTY
16358: LIST
16359: LIST
16360: ST_TO_ADDR
16361: GO 16404
// if randomWomen then
16363: LD_VAR 0 2
16367: IFFALSE 16402
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
16369: LD_ADDR_VAR 0 3
16373: PUSH
16374: LD_VAR 0 2
16378: PUSH
16379: LD_INT 1
16381: PPUSH
16382: LD_VAR 0 2
16386: PPUSH
16387: CALL_OW 12
16391: ARRAY
16392: PUSH
16393: LD_STRING DArf
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: ST_TO_ADDR
16400: GO 16404
// exit ;
16402: GO 16880
// if IsInUnit ( speaker [ 1 ] ) then
16404: LD_VAR 0 3
16408: PUSH
16409: LD_INT 1
16411: ARRAY
16412: PPUSH
16413: CALL_OW 310
16417: IFFALSE 16440
// place := IsInUnit ( speaker [ 1 ] ) else
16419: LD_ADDR_VAR 0 4
16423: PUSH
16424: LD_VAR 0 3
16428: PUSH
16429: LD_INT 1
16431: ARRAY
16432: PPUSH
16433: CALL_OW 310
16437: ST_TO_ADDR
16438: GO 16454
// place := speaker [ 1 ] ;
16440: LD_ADDR_VAR 0 4
16444: PUSH
16445: LD_VAR 0 3
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
16454: LD_VAR 0 4
16458: PPUSH
16459: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
16463: LD_VAR 0 4
16467: PPUSH
16468: CALL_OW 250
16472: PPUSH
16473: LD_VAR 0 4
16477: PPUSH
16478: CALL_OW 251
16482: PPUSH
16483: CALL 3078 0 2
// wait ( 0 0$2 ) ;
16487: LD_INT 70
16489: PPUSH
16490: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
16494: LD_EXP 38
16498: PPUSH
16499: CALL_OW 305
16503: NOT
16504: IFFALSE 16508
// exit ;
16506: GO 16880
// allowConvoys := false ;
16508: LD_ADDR_EXP 12
16512: PUSH
16513: LD_INT 0
16515: ST_TO_ADDR
// InGameOn ;
16516: CALL_OW 8
// wait ( 0 0$1 ) ;
16520: LD_INT 35
16522: PPUSH
16523: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
16527: LD_EXP 38
16531: PPUSH
16532: LD_STRING DI-1-land
16534: PPUSH
16535: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
16539: LD_VAR 0 3
16543: PUSH
16544: LD_INT 1
16546: ARRAY
16547: PPUSH
16548: CALL_OW 310
16552: IFFALSE 16567
// ComExit ( speaker [ 1 ] ) ;
16554: LD_VAR 0 3
16558: PUSH
16559: LD_INT 1
16561: ARRAY
16562: PPUSH
16563: CALL 1140 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
16567: LD_VAR 0 3
16571: PUSH
16572: LD_INT 1
16574: ARRAY
16575: PPUSH
16576: LD_EXP 38
16580: PPUSH
16581: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
16585: LD_VAR 0 3
16589: PUSH
16590: LD_INT 1
16592: ARRAY
16593: PPUSH
16594: LD_EXP 38
16598: PPUSH
16599: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
16603: LD_EXP 38
16607: PPUSH
16608: LD_VAR 0 3
16612: PUSH
16613: LD_INT 1
16615: ARRAY
16616: PPUSH
16617: CALL_OW 119
// wait ( 0 0$1 ) ;
16621: LD_INT 35
16623: PPUSH
16624: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
16628: LD_VAR 0 3
16632: PUSH
16633: LD_INT 1
16635: ARRAY
16636: PPUSH
16637: LD_VAR 0 3
16641: PUSH
16642: LD_INT 2
16644: ARRAY
16645: PUSH
16646: LD_STRING -1-land
16648: STR
16649: PPUSH
16650: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16654: LD_EXP 38
16658: PPUSH
16659: LD_STRING DI-2-land
16661: PPUSH
16662: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16666: LD_VAR 0 3
16670: PUSH
16671: LD_INT 1
16673: ARRAY
16674: PPUSH
16675: LD_VAR 0 3
16679: PUSH
16680: LD_INT 2
16682: ARRAY
16683: PUSH
16684: LD_STRING -2-land
16686: STR
16687: PPUSH
16688: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16692: LD_VAR 0 3
16696: PUSH
16697: LD_INT 1
16699: ARRAY
16700: PPUSH
16701: LD_VAR 0 3
16705: PUSH
16706: LD_INT 2
16708: ARRAY
16709: PUSH
16710: LD_STRING -3-land
16712: STR
16713: PPUSH
16714: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16718: LD_EXP 28
16722: PPUSH
16723: LD_STRING DH-1-land
16725: PPUSH
16726: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16730: LD_VAR 0 5
16734: PPUSH
16735: CALL_OW 313
16739: PUSH
16740: LD_INT 6
16742: EQUAL
16743: IFFALSE 16763
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16745: LD_VAR 0 5
16749: PPUSH
16750: CALL_OW 313
16754: PUSH
16755: LD_INT 1
16757: ARRAY
16758: PPUSH
16759: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16763: LD_EXP 38
16767: PPUSH
16768: LD_INT 2
16770: PPUSH
16771: CALL_OW 235
// CenterOnUnits ( depot ) ;
16775: LD_VAR 0 5
16779: PPUSH
16780: CALL_OW 85
// ComEnterUnit ( Ibrahim , depot ) ;
16784: LD_EXP 38
16788: PPUSH
16789: LD_VAR 0 5
16793: PPUSH
16794: CALL_OW 120
// ComEnterUnit ( speaker [ 1 ] , depot ) ;
16798: LD_VAR 0 3
16802: PUSH
16803: LD_INT 1
16805: ARRAY
16806: PPUSH
16807: LD_VAR 0 5
16811: PPUSH
16812: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
16816: LD_INT 35
16818: PPUSH
16819: CALL_OW 67
// until IsInUnit ( Ibrahim ) or not IsOk ( Ibrahim ) ;
16823: LD_EXP 38
16827: PPUSH
16828: CALL_OW 310
16832: PUSH
16833: LD_EXP 38
16837: PPUSH
16838: CALL_OW 302
16842: NOT
16843: OR
16844: IFFALSE 16816
// InGameOff ;
16846: CALL_OW 9
// if not IsOk ( Ibrahim ) then
16850: LD_EXP 38
16854: PPUSH
16855: CALL_OW 302
16859: NOT
16860: IFFALSE 16864
// exit ;
16862: GO 16880
// ibrahimInDepot := true ;
16864: LD_ADDR_EXP 25
16868: PUSH
16869: LD_INT 1
16871: ST_TO_ADDR
// allowConvoys := true ;
16872: LD_ADDR_EXP 12
16876: PUSH
16877: LD_INT 1
16879: ST_TO_ADDR
// end ;
16880: PPOPN 5
16882: END
// export function IbrahimQuery ; begin
16883: LD_INT 0
16885: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16886: LD_STRING IbrahimQuery
16888: PPUSH
16889: CALL_OW 97
16893: PUSH
16894: LD_INT 1
16896: DOUBLE
16897: EQUAL
16898: IFTRUE 16902
16900: GO 17178
16902: POP
// begin allowConvoys := false ;
16903: LD_ADDR_EXP 12
16907: PUSH
16908: LD_INT 0
16910: ST_TO_ADDR
// ibrahimInDepot := false ;
16911: LD_ADDR_EXP 25
16915: PUSH
16916: LD_INT 0
16918: ST_TO_ADDR
// InGameOn ;
16919: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16923: LD_EXP 28
16927: PPUSH
16928: CALL_OW 87
// wait ( 0 0$1 ) ;
16932: LD_INT 35
16934: PPUSH
16935: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16939: LD_EXP 28
16943: PPUSH
16944: LD_STRING DH-1-interrogation
16946: PPUSH
16947: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16951: LD_EXP 38
16955: PPUSH
16956: LD_STRING DI-1-interrogation
16958: PPUSH
16959: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16963: LD_EXP 28
16967: PPUSH
16968: LD_STRING DH-2-interrogation
16970: PPUSH
16971: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16975: LD_EXP 38
16979: PPUSH
16980: LD_STRING DI-2-interrogation
16982: PPUSH
16983: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16987: LD_EXP 28
16991: PPUSH
16992: LD_STRING DH-3-interrogation
16994: PPUSH
16995: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16999: LD_EXP 38
17003: PPUSH
17004: LD_STRING DI-3-interrogation
17006: PPUSH
17007: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
17011: LD_EXP 28
17015: PPUSH
17016: LD_STRING DH-4-interrogation
17018: PPUSH
17019: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
17023: LD_EXP 38
17027: PPUSH
17028: LD_STRING DI-4-interrogation
17030: PPUSH
17031: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
17035: LD_EXP 28
17039: PPUSH
17040: LD_STRING DH-5-interrogation
17042: PPUSH
17043: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
17047: LD_EXP 38
17051: PPUSH
17052: LD_STRING DI-5-interrogation
17054: PPUSH
17055: CALL_OW 88
// wait ( 0 0$1 ) ;
17059: LD_INT 35
17061: PPUSH
17062: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
17066: LD_STRING IbrahimDecisionQuery
17068: PPUSH
17069: CALL_OW 97
17073: PUSH
17074: LD_INT 1
17076: DOUBLE
17077: EQUAL
17078: IFTRUE 17082
17080: GO 17106
17082: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
17083: LD_EXP 38
17087: PPUSH
17088: LD_STRING DI-1-kill
17090: PPUSH
17091: CALL_OW 88
// KillUnit ( Ibrahim ) ;
17095: LD_EXP 38
17099: PPUSH
17100: CALL_OW 66
// end ; 2 :
17104: GO 17172
17106: LD_INT 2
17108: DOUBLE
17109: EQUAL
17110: IFTRUE 17114
17112: GO 17171
17114: POP
// begin SetSide ( Ibrahim , 6 ) ;
17115: LD_EXP 38
17119: PPUSH
17120: LD_INT 6
17122: PPUSH
17123: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
17127: LD_EXP 38
17131: PPUSH
17132: CALL_OW 122
// AddComMoveXY ( Ibrahim , 66 , 2 ) ;
17136: LD_EXP 38
17140: PPUSH
17141: LD_INT 66
17143: PPUSH
17144: LD_INT 2
17146: PPUSH
17147: CALL_OW 171
// AddComHold ( Ibrahim ) ;
17151: LD_EXP 38
17155: PPUSH
17156: CALL_OW 200
// ComExitBuilding ( Heike ) ;
17160: LD_EXP 28
17164: PPUSH
17165: CALL_OW 122
// end ; end ;
17169: GO 17172
17171: POP
// InGameOff ;
17172: CALL_OW 9
// end ; 2 :
17176: GO 17192
17178: LD_INT 2
17180: DOUBLE
17181: EQUAL
17182: IFTRUE 17186
17184: GO 17191
17186: POP
// exit ; end ;
17187: GO 17230
17189: GO 17192
17191: POP
// allowConvoys := true ;
17192: LD_ADDR_EXP 12
17196: PUSH
17197: LD_INT 1
17199: ST_TO_ADDR
// wait ( 2 2$30 ) ;
17200: LD_INT 5250
17202: PPUSH
17203: CALL_OW 67
// ComMoveXY ( Ibrahim , 38 , 28 ) ;
17207: LD_EXP 38
17211: PPUSH
17212: LD_INT 38
17214: PPUSH
17215: LD_INT 28
17217: PPUSH
17218: CALL_OW 111
// ibrahimIsFree := true ;
17222: LD_ADDR_EXP 26
17226: PUSH
17227: LD_INT 1
17229: ST_TO_ADDR
// end ;
17230: LD_VAR 0 1
17234: RET
// every 0 0$1 trigger ibrahimIsFree and IsOk ( Ibrahim ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b , p , depot , x , y ;
17235: LD_EXP 26
17239: PUSH
17240: LD_EXP 38
17244: PPUSH
17245: CALL_OW 302
17249: AND
17250: PUSH
17251: LD_INT 6
17253: PPUSH
17254: LD_EXP 28
17258: PPUSH
17259: CALL_OW 292
17263: AND
17264: PUSH
17265: LD_INT 22
17267: PUSH
17268: LD_INT 4
17270: PUSH
17271: EMPTY
17272: LIST
17273: LIST
17274: PPUSH
17275: CALL_OW 69
17279: NOT
17280: AND
17281: PUSH
17282: LD_INT 22
17284: PUSH
17285: LD_INT 1
17287: PUSH
17288: EMPTY
17289: LIST
17290: LIST
17291: PUSH
17292: LD_INT 21
17294: PUSH
17295: LD_INT 1
17297: PUSH
17298: EMPTY
17299: LIST
17300: LIST
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: PPUSH
17306: CALL_OW 69
17310: NOT
17311: AND
17312: IFFALSE 18072
17314: GO 17316
17316: DISABLE
17317: LD_INT 0
17319: PPUSH
17320: PPUSH
17321: PPUSH
17322: PPUSH
17323: PPUSH
17324: PPUSH
// begin allowConvoys := false ;
17325: LD_ADDR_EXP 12
17329: PUSH
17330: LD_INT 0
17332: ST_TO_ADDR
// depot := usDepot ;
17333: LD_ADDR_VAR 0 4
17337: PUSH
17338: LD_INT 11
17340: ST_TO_ADDR
// if not usDepot and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) then
17341: LD_INT 11
17343: NOT
17344: PUSH
17345: LD_INT 22
17347: PUSH
17348: LD_INT 2
17350: PUSH
17351: EMPTY
17352: LIST
17353: LIST
17354: PUSH
17355: LD_INT 50
17357: PUSH
17358: EMPTY
17359: LIST
17360: PUSH
17361: LD_INT 30
17363: PUSH
17364: LD_INT 0
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: PUSH
17371: EMPTY
17372: LIST
17373: LIST
17374: LIST
17375: PPUSH
17376: CALL_OW 69
17380: AND
17381: IFFALSE 17428
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
17383: LD_ADDR_VAR 0 4
17387: PUSH
17388: LD_INT 22
17390: PUSH
17391: LD_INT 2
17393: PUSH
17394: EMPTY
17395: LIST
17396: LIST
17397: PUSH
17398: LD_INT 50
17400: PUSH
17401: EMPTY
17402: LIST
17403: PUSH
17404: LD_INT 30
17406: PUSH
17407: LD_INT 0
17409: PUSH
17410: EMPTY
17411: LIST
17412: LIST
17413: PUSH
17414: EMPTY
17415: LIST
17416: LIST
17417: LIST
17418: PPUSH
17419: CALL_OW 69
17423: PUSH
17424: LD_INT 1
17426: ARRAY
17427: ST_TO_ADDR
// InGameOn ;
17428: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
17432: LD_EXP 38
17436: PPUSH
17437: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
17441: LD_EXP 28
17445: PPUSH
17446: LD_EXP 38
17450: PPUSH
17451: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
17455: LD_EXP 38
17459: PPUSH
17460: LD_EXP 28
17464: PPUSH
17465: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
17469: LD_EXP 38
17473: PPUSH
17474: LD_STRING DI-1-free
17476: PPUSH
17477: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
17481: LD_EXP 28
17485: PPUSH
17486: LD_STRING DH-1-free
17488: PPUSH
17489: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
17493: LD_EXP 38
17497: PPUSH
17498: LD_STRING DI-2-free
17500: PPUSH
17501: CALL_OW 88
// changeClass := 0 ;
17505: LD_ADDR_VAR 0 1
17509: PUSH
17510: LD_INT 0
17512: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
17513: LD_STRING IbrahimJoinQuery
17515: PPUSH
17516: CALL_OW 97
17520: PUSH
17521: LD_INT 1
17523: DOUBLE
17524: EQUAL
17525: IFTRUE 17529
17527: GO 17540
17529: POP
// begin changeClass := 1 ;
17530: LD_ADDR_VAR 0 1
17534: PUSH
17535: LD_INT 1
17537: ST_TO_ADDR
// end ; 2 :
17538: GO 17780
17540: LD_INT 2
17542: DOUBLE
17543: EQUAL
17544: IFTRUE 17548
17546: GO 17700
17548: POP
// begin Say ( Heike , DH-1-decline ) ;
17549: LD_EXP 28
17553: PPUSH
17554: LD_STRING DH-1-decline
17556: PPUSH
17557: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
17561: LD_EXP 38
17565: PPUSH
17566: LD_STRING DI-1-decline
17568: PPUSH
17569: CALL_OW 88
// InGameOff ;
17573: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
17577: LD_EXP 38
17581: PPUSH
17582: LD_INT 30
17584: PPUSH
17585: LD_INT 1
17587: PPUSH
17588: CALL_OW 111
// p := 0 ;
17592: LD_ADDR_VAR 0 3
17596: PUSH
17597: LD_INT 0
17599: ST_TO_ADDR
// repeat p := p + 1 ;
17600: LD_ADDR_VAR 0 3
17604: PUSH
17605: LD_VAR 0 3
17609: PUSH
17610: LD_INT 1
17612: PLUS
17613: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17614: LD_INT 35
17616: PPUSH
17617: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) or p > 10 ;
17621: LD_EXP 38
17625: PPUSH
17626: LD_INT 30
17628: PPUSH
17629: LD_INT 1
17631: PPUSH
17632: CALL_OW 307
17636: PUSH
17637: LD_INT 22
17639: PUSH
17640: LD_INT 2
17642: PUSH
17643: EMPTY
17644: LIST
17645: LIST
17646: PUSH
17647: LD_INT 101
17649: PUSH
17650: LD_INT 6
17652: PUSH
17653: EMPTY
17654: LIST
17655: LIST
17656: PUSH
17657: EMPTY
17658: LIST
17659: LIST
17660: PPUSH
17661: CALL_OW 69
17665: NOT
17666: OR
17667: PUSH
17668: LD_VAR 0 3
17672: PUSH
17673: LD_INT 10
17675: GREATER
17676: OR
17677: IFFALSE 17600
// RemoveUnit ( Ibrahim ) ;
17679: LD_EXP 38
17683: PPUSH
17684: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17688: LD_INT 1
17690: PPUSH
17691: LD_STRING 03_IbrahimHasEscaped
17693: PPUSH
17694: CALL_OW 39
// end ; 3 :
17698: GO 17780
17700: LD_INT 3
17702: DOUBLE
17703: EQUAL
17704: IFTRUE 17708
17706: GO 17779
17708: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17709: LD_EXP 28
17713: PPUSH
17714: LD_STRING DH-1-radio-hq
17716: PPUSH
17717: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17721: LD_EXP 37
17725: PPUSH
17726: LD_STRING DO-1-radio-hq
17728: PPUSH
17729: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17733: LD_EXP 28
17737: PPUSH
17738: LD_STRING DH-2-radio-hq
17740: PPUSH
17741: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17745: LD_EXP 37
17749: PPUSH
17750: LD_STRING DO-2-radio-hq
17752: PPUSH
17753: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17757: LD_EXP 28
17761: PPUSH
17762: LD_STRING DH-3-radio-hq
17764: PPUSH
17765: CALL_OW 88
// changeClass := 1 ;
17769: LD_ADDR_VAR 0 1
17773: PUSH
17774: LD_INT 1
17776: ST_TO_ADDR
// end ; end ;
17777: GO 17780
17779: POP
// if changeClass then
17780: LD_VAR 0 1
17784: IFFALSE 18072
// begin Say ( Heike , DH-1-agree ) ;
17786: LD_EXP 28
17790: PPUSH
17791: LD_STRING DH-1-agree
17793: PPUSH
17794: CALL_OW 88
// if IsOk ( Givi ) then
17798: LD_EXP 29
17802: PPUSH
17803: CALL_OW 302
17807: IFFALSE 17845
// begin Say ( Givi , DG-1-agree ) ;
17809: LD_EXP 29
17813: PPUSH
17814: LD_STRING DG-1-agree
17816: PPUSH
17817: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17821: LD_EXP 28
17825: PPUSH
17826: LD_STRING DH-2-agree
17828: PPUSH
17829: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17833: LD_EXP 29
17837: PPUSH
17838: LD_STRING DG-2-agree
17840: PPUSH
17841: CALL_OW 88
// end ; if UnitsInside ( depot ) = 6 then
17845: LD_VAR 0 4
17849: PPUSH
17850: CALL_OW 313
17854: PUSH
17855: LD_INT 6
17857: EQUAL
17858: IFFALSE 17878
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
17860: LD_VAR 0 4
17864: PPUSH
17865: CALL_OW 313
17869: PUSH
17870: LD_INT 1
17872: ARRAY
17873: PPUSH
17874: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17878: LD_EXP 38
17882: PPUSH
17883: LD_INT 2
17885: PPUSH
17886: CALL_OW 235
// x := GetX ( Ibrahim ) ;
17890: LD_ADDR_VAR 0 5
17894: PUSH
17895: LD_EXP 38
17899: PPUSH
17900: CALL_OW 250
17904: ST_TO_ADDR
// y := GetY ( Ibrahim ) ;
17905: LD_ADDR_VAR 0 6
17909: PUSH
17910: LD_EXP 38
17914: PPUSH
17915: CALL_OW 251
17919: ST_TO_ADDR
// if depot then
17920: LD_VAR 0 4
17924: IFFALSE 17973
// begin ComEnterUnit ( Ibrahim , depot ) ;
17926: LD_EXP 38
17930: PPUSH
17931: LD_VAR 0 4
17935: PPUSH
17936: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17940: LD_INT 35
17942: PPUSH
17943: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17947: LD_EXP 38
17951: PPUSH
17952: CALL_OW 310
17956: IFFALSE 17940
// b := IsInUnit ( Ibrahim ) ;
17958: LD_ADDR_VAR 0 2
17962: PUSH
17963: LD_EXP 38
17967: PPUSH
17968: CALL_OW 310
17972: ST_TO_ADDR
// end ; RemoveUnit ( Ibrahim ) ;
17973: LD_EXP 38
17977: PPUSH
17978: CALL_OW 64
// uc_side := 2 ;
17982: LD_ADDR_OWVAR 20
17986: PUSH
17987: LD_INT 2
17989: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17990: LD_ADDR_EXP 38
17994: PUSH
17995: LD_STRING Ibrahim
17997: PPUSH
17998: LD_INT 0
18000: PPUSH
18001: LD_STRING 
18003: PPUSH
18004: CALL 313 0 3
18008: ST_TO_ADDR
// if depot then
18009: LD_VAR 0 4
18013: IFFALSE 18031
// PlaceHumanInUnit ( Ibrahim , b ) else
18015: LD_EXP 38
18019: PPUSH
18020: LD_VAR 0 2
18024: PPUSH
18025: CALL_OW 52
18029: GO 18053
// PlaceUnitXY ( Ibrahim , x , y , false ) ;
18031: LD_EXP 38
18035: PPUSH
18036: LD_VAR 0 5
18040: PPUSH
18041: LD_VAR 0 6
18045: PPUSH
18046: LD_INT 0
18048: PPUSH
18049: CALL_OW 48
// InGameOff ;
18053: CALL_OW 9
// allowConvoys := true ;
18057: LD_ADDR_EXP 12
18061: PUSH
18062: LD_INT 1
18064: ST_TO_ADDR
// SetAchievement ( ACH_IBRAHIM ) ;
18065: LD_STRING ACH_IBRAHIM
18067: PPUSH
18068: CALL_OW 543
// end ; end ;
18072: PPOPN 6
18074: END
// every 0 0$1 trigger GetLives ( Kaia ) < 3 do
18075: LD_EXP 33
18079: PPUSH
18080: CALL_OW 256
18084: PUSH
18085: LD_INT 3
18087: LESS
18088: IFFALSE 18155
18090: GO 18092
18092: DISABLE
// begin DialogueOn ;
18093: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
18097: LD_EXP 33
18101: PPUSH
18102: CALL_OW 87
// ForceSay ( Kaia , DK-keydeath-1 ) ;
18106: LD_EXP 33
18110: PPUSH
18111: LD_STRING DK-keydeath-1
18113: PPUSH
18114: CALL_OW 91
// Say ( Heike , DH-keydeath-2 ) ;
18118: LD_EXP 28
18122: PPUSH
18123: LD_STRING DH-keydeath-2
18125: PPUSH
18126: CALL_OW 88
// Say ( Heike , DH-keydeath-3 ) ;
18130: LD_EXP 28
18134: PPUSH
18135: LD_STRING DH-keydeath-3
18137: PPUSH
18138: CALL_OW 88
// DialogueOff ;
18142: CALL_OW 7
// KillUnit ( Kaia ) ;
18146: LD_EXP 33
18150: PPUSH
18151: CALL_OW 66
// end ;
18155: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 do
18156: LD_EXP 11
18160: PUSH
18161: LD_EXP 21
18165: PUSH
18166: LD_INT 1
18168: LESS
18169: AND
18170: PUSH
18171: LD_INT 22
18173: PUSH
18174: LD_INT 1
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: PUSH
18181: LD_INT 25
18183: PUSH
18184: LD_INT 1
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: PUSH
18191: EMPTY
18192: LIST
18193: LIST
18194: PPUSH
18195: CALL_OW 69
18199: PUSH
18200: LD_INT 0
18202: EQUAL
18203: AND
18204: IFFALSE 18595
18206: GO 18208
18208: DISABLE
// begin DialogueOn ;
18209: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
18213: LD_EXP 28
18217: PPUSH
18218: LD_STRING DH-1-final
18220: PPUSH
18221: CALL_OW 88
// if tick <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
18225: LD_OWVAR 1
18229: PUSH
18230: LD_INT 126000
18232: PUSH
18233: LD_INT 115500
18235: PUSH
18236: LD_INT 105000
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: LIST
18243: PUSH
18244: LD_OWVAR 67
18248: ARRAY
18249: LESSEQUAL
18250: IFFALSE 18264
// AddMedal ( med1 , 1 ) else
18252: LD_STRING med1
18254: PPUSH
18255: LD_INT 1
18257: PPUSH
18258: CALL_OW 101
18262: GO 18275
// AddMedal ( med1 , - 1 ) ;
18264: LD_STRING med1
18266: PPUSH
18267: LD_INT 1
18269: NEG
18270: PPUSH
18271: CALL_OW 101
// if vehCounter >= 2 then
18275: LD_EXP 22
18279: PUSH
18280: LD_INT 2
18282: GREATEREQUAL
18283: IFFALSE 18297
// AddMedal ( med2 , 1 ) else
18285: LD_STRING med2
18287: PPUSH
18288: LD_INT 1
18290: PPUSH
18291: CALL_OW 101
18295: GO 18308
// AddMedal ( med2 , - 1 ) ;
18297: LD_STRING med2
18299: PPUSH
18300: LD_INT 1
18302: NEG
18303: PPUSH
18304: CALL_OW 101
// if deadCounter = 0 then
18308: LD_EXP 9
18312: PUSH
18313: LD_INT 0
18315: EQUAL
18316: IFFALSE 18330
// AddMedal ( med3 , 1 ) else
18318: LD_STRING med3
18320: PPUSH
18321: LD_INT 1
18323: PPUSH
18324: CALL_OW 101
18328: GO 18341
// AddMedal ( med3 , - 1 ) ;
18330: LD_STRING med3
18332: PPUSH
18333: LD_INT 1
18335: NEG
18336: PPUSH
18337: CALL_OW 101
// GiveMedals ( MAIN ) ;
18341: LD_STRING MAIN
18343: PPUSH
18344: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
18348: LD_INT 22
18350: PUSH
18351: LD_INT 2
18353: PUSH
18354: EMPTY
18355: LIST
18356: LIST
18357: PUSH
18358: LD_INT 23
18360: PUSH
18361: LD_INT 2
18363: PUSH
18364: EMPTY
18365: LIST
18366: LIST
18367: PUSH
18368: LD_INT 21
18370: PUSH
18371: LD_INT 1
18373: PUSH
18374: EMPTY
18375: LIST
18376: LIST
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: LIST
18382: PPUSH
18383: CALL_OW 69
18387: PPUSH
18388: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
18392: LD_EXP 28
18396: PPUSH
18397: LD_STRING 03_Heike
18399: PPUSH
18400: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
18404: LD_EXP 32
18408: PPUSH
18409: LD_STRING 03_Aviradze
18411: PPUSH
18412: CALL_OW 38
// if Givi then
18416: LD_EXP 29
18420: IFFALSE 18434
// SaveCharacters ( Givi , 03_Givi ) ;
18422: LD_EXP 29
18426: PPUSH
18427: LD_STRING 03_Givi
18429: PPUSH
18430: CALL_OW 38
// if Mike then
18434: LD_EXP 30
18438: IFFALSE 18452
// SaveCharacters ( Mike , 03_Mike ) ;
18440: LD_EXP 30
18444: PPUSH
18445: LD_STRING 03_Mike
18447: PPUSH
18448: CALL_OW 38
// if Kamil then
18452: LD_EXP 31
18456: IFFALSE 18470
// SaveCharacters ( Kamil , 03_Kamil ) ;
18458: LD_EXP 31
18462: PPUSH
18463: LD_STRING 03_Kamil
18465: PPUSH
18466: CALL_OW 38
// if Kaia then
18470: LD_EXP 33
18474: IFFALSE 18488
// SaveCharacters ( Kaia , 03_Kaia ) ;
18476: LD_EXP 33
18480: PPUSH
18481: LD_STRING 03_Kaia
18483: PPUSH
18484: CALL_OW 38
// if Sophia then
18488: LD_EXP 34
18492: IFFALSE 18506
// SaveCharacters ( Sophia , 03_Sophia ) ;
18494: LD_EXP 34
18498: PPUSH
18499: LD_STRING 03_Sophia
18501: PPUSH
18502: CALL_OW 38
// if Markov then
18506: LD_EXP 35
18510: IFFALSE 18524
// SaveCharacters ( Markov , 03_Markov ) ;
18512: LD_EXP 35
18516: PPUSH
18517: LD_STRING 03_Markov
18519: PPUSH
18520: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
18524: LD_EXP 38
18528: PUSH
18529: LD_EXP 38
18533: PPUSH
18534: CALL_OW 255
18538: PUSH
18539: LD_INT 2
18541: EQUAL
18542: AND
18543: IFFALSE 18557
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
18545: LD_EXP 38
18549: PPUSH
18550: LD_STRING 03_Ibrahim
18552: PPUSH
18553: CALL_OW 38
// if heikeSecondSquad then
18557: LD_EXP 42
18561: IFFALSE 18575
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
18563: LD_EXP 42
18567: PPUSH
18568: LD_STRING 03_others
18570: PPUSH
18571: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
18575: LD_EXP 9
18579: PPUSH
18580: LD_STRING 03_DeadCounter
18582: PPUSH
18583: CALL_OW 39
// YouWin ;
18587: CALL_OW 103
// DialogueOff ;
18591: CALL_OW 7
// end ; end_of_file
18595: END
// on UnitDestroyed ( un ) do begin if un = Heike then
18596: LD_VAR 0 1
18600: PUSH
18601: LD_EXP 28
18605: EQUAL
18606: IFFALSE 18615
// YouLost ( Heike ) ;
18608: LD_STRING Heike
18610: PPUSH
18611: CALL_OW 104
// if un = Aviradze then
18615: LD_VAR 0 1
18619: PUSH
18620: LD_EXP 32
18624: EQUAL
18625: IFFALSE 18634
// YouLost ( Aviradze ) ;
18627: LD_STRING Aviradze
18629: PPUSH
18630: CALL_OW 104
// if un = usDepot and not retreatAllowed then
18634: LD_VAR 0 1
18638: PUSH
18639: LD_INT 11
18641: EQUAL
18642: PUSH
18643: LD_EXP 11
18647: NOT
18648: AND
18649: IFFALSE 18658
// YouLost ( Depot ) ;
18651: LD_STRING Depot
18653: PPUSH
18654: CALL_OW 104
// if un = arDepot then
18658: LD_VAR 0 1
18662: PUSH
18663: LD_INT 5
18665: EQUAL
18666: IFFALSE 18675
// YouLost ( FarmerDepot ) ;
18668: LD_STRING FarmerDepot
18670: PPUSH
18671: CALL_OW 104
// if un = Farmer then
18675: LD_VAR 0 1
18679: PUSH
18680: LD_EXP 36
18684: EQUAL
18685: IFFALSE 18694
// YouLost ( Farmer ) ;
18687: LD_STRING Farmer
18689: PPUSH
18690: CALL_OW 104
// if un in usForces then
18694: LD_VAR 0 1
18698: PUSH
18699: LD_EXP 44
18703: IN
18704: IFFALSE 18722
// usForces := usForces diff un ;
18706: LD_ADDR_EXP 44
18710: PUSH
18711: LD_EXP 44
18715: PUSH
18716: LD_VAR 0 1
18720: DIFF
18721: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
18722: LD_VAR 0 1
18726: PUSH
18727: LD_INT 22
18729: PUSH
18730: LD_INT 2
18732: PUSH
18733: EMPTY
18734: LIST
18735: LIST
18736: PUSH
18737: LD_INT 23
18739: PUSH
18740: LD_INT 2
18742: PUSH
18743: EMPTY
18744: LIST
18745: LIST
18746: PUSH
18747: LD_INT 21
18749: PUSH
18750: LD_INT 1
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: LIST
18761: PPUSH
18762: CALL_OW 69
18766: IN
18767: IFFALSE 18783
// deadCounter := deadCounter + 1 ;
18769: LD_ADDR_EXP 9
18773: PUSH
18774: LD_EXP 9
18778: PUSH
18779: LD_INT 1
18781: PLUS
18782: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
18783: LD_VAR 0 1
18787: PUSH
18788: LD_INT 22
18790: PUSH
18791: LD_INT 4
18793: PUSH
18794: EMPTY
18795: LIST
18796: LIST
18797: PUSH
18798: LD_INT 34
18800: PUSH
18801: LD_INT 12
18803: PUSH
18804: EMPTY
18805: LIST
18806: LIST
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PPUSH
18812: CALL_OW 69
18816: IN
18817: PUSH
18818: LD_EXP 18
18822: NOT
18823: AND
18824: IFFALSE 18834
// firstConvoyDestroyed := true ;
18826: LD_ADDR_EXP 18
18830: PUSH
18831: LD_INT 1
18833: ST_TO_ADDR
// if un in usAttackers then
18834: LD_VAR 0 1
18838: PUSH
18839: LD_EXP 47
18843: IN
18844: IFFALSE 18862
// usAttackers := usAttackers diff un ;
18846: LD_ADDR_EXP 47
18850: PUSH
18851: LD_EXP 47
18855: PUSH
18856: LD_VAR 0 1
18860: DIFF
18861: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) then
18862: LD_VAR 0 1
18866: PUSH
18867: LD_INT 22
18869: PUSH
18870: LD_INT 5
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: PUSH
18877: LD_INT 21
18879: PUSH
18880: LD_INT 1
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: PPUSH
18891: CALL_OW 69
18895: IN
18896: IFFALSE 18912
// farmerHumanLoseCounter := farmerHumanLoseCounter + 1 ;
18898: LD_ADDR_EXP 20
18902: PUSH
18903: LD_EXP 20
18907: PUSH
18908: LD_INT 1
18910: PLUS
18911: ST_TO_ADDR
// end ;
18912: PPOPN 1
18914: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18915: LD_VAR 0 2
18919: PUSH
18920: LD_EXP 38
18924: EQUAL
18925: PUSH
18926: LD_EXP 25
18930: AND
18931: IFFALSE 19070
// begin if FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) then
18933: LD_INT 22
18935: PUSH
18936: LD_INT 2
18938: PUSH
18939: EMPTY
18940: LIST
18941: LIST
18942: PUSH
18943: LD_INT 30
18945: PUSH
18946: LD_INT 0
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: PUSH
18953: EMPTY
18954: LIST
18955: LIST
18956: PPUSH
18957: CALL_OW 69
18961: IFFALSE 19003
// begin InGameOn ;
18963: CALL_OW 8
// ComEnterUnit ( Ibrahim , usDepot ) ;
18967: LD_EXP 38
18971: PPUSH
18972: LD_INT 11
18974: PPUSH
18975: CALL_OW 120
// repeat wait ( 3 ) ;
18979: LD_INT 3
18981: PPUSH
18982: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18986: LD_EXP 38
18990: PPUSH
18991: CALL_OW 310
18995: IFFALSE 18979
// InGameOff ;
18997: CALL_OW 9
// end else
19001: GO 19070
// begin ibrahimInDepot := false ;
19003: LD_ADDR_EXP 25
19007: PUSH
19008: LD_INT 0
19010: ST_TO_ADDR
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
19011: LD_EXP 38
19015: PPUSH
19016: LD_INT 30
19018: PPUSH
19019: LD_INT 1
19021: PPUSH
19022: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
19026: LD_INT 35
19028: PPUSH
19029: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or IsDead ( Ibrahim ) ;
19033: LD_EXP 38
19037: PPUSH
19038: LD_INT 30
19040: PPUSH
19041: LD_INT 1
19043: PPUSH
19044: CALL_OW 307
19048: PUSH
19049: LD_EXP 38
19053: PPUSH
19054: CALL_OW 301
19058: OR
19059: IFFALSE 19026
// RemoveUnit ( Ibrahim ) ;
19061: LD_EXP 38
19065: PPUSH
19066: CALL_OW 64
// end ; end ; end ;
19070: PPOPN 2
19072: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
19073: LD_VAR 0 2
19077: PUSH
19078: LD_EXP 28
19082: EQUAL
19083: PUSH
19084: LD_VAR 0 1
19088: PUSH
19089: LD_INT 11
19091: EQUAL
19092: AND
19093: PUSH
19094: LD_EXP 25
19098: AND
19099: IFFALSE 19105
// IbrahimQuery ;
19101: CALL 16883 0 0
// end ;
19105: PPOPN 2
19107: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin ComStop ( newId ) ;
19108: LD_VAR 0 1
19112: PPUSH
19113: CALL_OW 141
// if oldId in usAttackers then
19117: LD_VAR 0 2
19121: PUSH
19122: LD_EXP 47
19126: IN
19127: IFFALSE 19145
// usAttackers := usAttackers diff oldId ;
19129: LD_ADDR_EXP 47
19133: PUSH
19134: LD_EXP 47
19138: PUSH
19139: LD_VAR 0 2
19143: DIFF
19144: ST_TO_ADDR
// if newId in usAttackers then
19145: LD_VAR 0 1
19149: PUSH
19150: LD_EXP 47
19154: IN
19155: IFFALSE 19173
// usAttackers := usAttackers diff newId ;
19157: LD_ADDR_EXP 47
19161: PUSH
19162: LD_EXP 47
19166: PUSH
19167: LD_VAR 0 1
19171: DIFF
19172: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
19173: LD_VAR 0 3
19177: PUSH
19178: LD_INT 4
19180: EQUAL
19181: PUSH
19182: LD_EXP 18
19186: NOT
19187: AND
19188: IFFALSE 19198
// firstConvoyDestroyed := true ;
19190: LD_ADDR_EXP 18
19194: PUSH
19195: LD_INT 1
19197: ST_TO_ADDR
// if GetWeapon ( newId ) = us_cargo_bay then
19198: LD_VAR 0 1
19202: PPUSH
19203: CALL_OW 264
19207: PUSH
19208: LD_INT 12
19210: EQUAL
19211: IFFALSE 19249
// begin capturedCargoCounter := capturedCargoCounter + 1 ;
19213: LD_ADDR_EXP 13
19217: PUSH
19218: LD_EXP 13
19222: PUSH
19223: LD_INT 1
19225: PLUS
19226: ST_TO_ADDR
// if GetCargo ( newId , mat_cans ) = 0 then
19227: LD_VAR 0 1
19231: PPUSH
19232: LD_INT 1
19234: PPUSH
19235: CALL_OW 289
19239: PUSH
19240: LD_INT 0
19242: EQUAL
19243: IFFALSE 19249
// EmptyCargoDialog ;
19245: CALL 15613 0 0
// end ; end ;
19249: PPOPN 4
19251: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
19252: LD_VAR 0 1
19256: PUSH
19257: LD_INT 2
19259: EQUAL
19260: PUSH
19261: LD_VAR 0 2
19265: PUSH
19266: LD_INT 5
19268: EQUAL
19269: AND
19270: IFFALSE 19279
// YouLost ( Attack ) ;
19272: LD_STRING Attack
19274: PPUSH
19275: CALL_OW 104
// end ;
19279: PPOPN 2
19281: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 and not americanBaseCaptured then
19282: LD_VAR 0 1
19286: PPUSH
19287: CALL_OW 255
19291: PUSH
19292: LD_INT 1
19294: EQUAL
19295: PUSH
19296: LD_EXP 6
19300: NOT
19301: AND
19302: IFFALSE 19436
// begin if GetBType ( b ) = b_lab then
19304: LD_VAR 0 1
19308: PPUSH
19309: CALL_OW 266
19313: PUSH
19314: LD_INT 6
19316: EQUAL
19317: IFFALSE 19357
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
19319: LD_EXP 44
19323: PPUSH
19324: LD_INT 25
19326: PUSH
19327: LD_INT 4
19329: PUSH
19330: EMPTY
19331: LIST
19332: LIST
19333: PPUSH
19334: CALL_OW 72
19338: PPUSH
19339: LD_VAR 0 1
19343: PPUSH
19344: CALL_OW 120
// AmLabResearch ( b ) ;
19348: LD_VAR 0 1
19352: PPUSH
19353: CALL 6086 0 1
// end ; if GetBType ( b ) = b_armoury then
19357: LD_VAR 0 1
19361: PPUSH
19362: CALL_OW 266
19366: PUSH
19367: LD_INT 4
19369: EQUAL
19370: IFFALSE 19418
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
19372: LD_EXP 44
19376: PPUSH
19377: LD_INT 25
19379: PUSH
19380: LD_INT 1
19382: PUSH
19383: EMPTY
19384: LIST
19385: LIST
19386: PUSH
19387: LD_INT 3
19389: PUSH
19390: LD_INT 54
19392: PUSH
19393: EMPTY
19394: LIST
19395: PUSH
19396: EMPTY
19397: LIST
19398: LIST
19399: PUSH
19400: EMPTY
19401: LIST
19402: LIST
19403: PPUSH
19404: CALL_OW 72
19408: PPUSH
19409: LD_VAR 0 1
19413: PPUSH
19414: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
19418: LD_ADDR_EXP 46
19422: PUSH
19423: LD_EXP 46
19427: PPUSH
19428: LD_INT 1
19430: PPUSH
19431: CALL_OW 3
19435: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
19436: LD_VAR 0 1
19440: PPUSH
19441: CALL_OW 255
19445: PUSH
19446: LD_INT 5
19448: EQUAL
19449: IFFALSE 19463
// SetBLevel ( b , 5 ) ;
19451: LD_VAR 0 1
19455: PPUSH
19456: LD_INT 5
19458: PPUSH
19459: CALL_OW 241
// end ;
19463: PPOPN 1
19465: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
19466: LD_VAR 0 1
19470: PPUSH
19471: CALL_OW 255
19475: PUSH
19476: LD_INT 2
19478: EQUAL
19479: IFFALSE 19495
// vehCounter := vehCounter + 1 ;
19481: LD_ADDR_EXP 22
19485: PUSH
19486: LD_EXP 22
19490: PUSH
19491: LD_INT 1
19493: PLUS
19494: ST_TO_ADDR
// end ;
19495: PPOPN 2
19497: END
// on SailEvent ( event ) do begin if event = eventAttack then
19498: LD_VAR 0 1
19502: PUSH
19503: LD_EXP 24
19507: EQUAL
19508: IFFALSE 19514
// AmericanAttack ;
19510: CALL 7534 0 0
// end ; end_of_file
19514: PPOPN 1
19516: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 5 5$00 , 4 4$40 , 4 4$30 ] [ Difficulty ] do
19517: LD_OWVAR 1
19521: PUSH
19522: LD_INT 10500
19524: PUSH
19525: LD_INT 9800
19527: PUSH
19528: LD_INT 9450
19530: PUSH
19531: EMPTY
19532: LIST
19533: LIST
19534: LIST
19535: PUSH
19536: LD_OWVAR 67
19540: ARRAY
19541: LESSEQUAL
19542: IFFALSE 19569
19544: GO 19546
19546: DISABLE
// begin enable ;
19547: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
19548: LD_INT 1
19550: PPUSH
19551: LD_INT 5
19553: PPUSH
19554: CALL_OW 12
19558: PPUSH
19559: LD_INT 9
19561: PPUSH
19562: LD_INT 1
19564: PPUSH
19565: CALL_OW 55
// end ;
19569: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 27 27$00 , 26 26$30 , 26 26$00 ] [ Difficulty ] do
19570: LD_EXP 6
19574: PUSH
19575: LD_OWVAR 1
19579: PUSH
19580: LD_INT 56700
19582: PUSH
19583: LD_INT 55650
19585: PUSH
19586: LD_INT 54600
19588: PUSH
19589: EMPTY
19590: LIST
19591: LIST
19592: LIST
19593: PUSH
19594: LD_OWVAR 67
19598: ARRAY
19599: LESSEQUAL
19600: AND
19601: IFFALSE 19628
19603: GO 19605
19605: DISABLE
// begin enable ;
19606: ENABLE
// CreateCratesArea ( rand ( 3 , 5 ) , cratesArea , true ) ;
19607: LD_INT 3
19609: PPUSH
19610: LD_INT 5
19612: PPUSH
19613: CALL_OW 12
19617: PPUSH
19618: LD_INT 9
19620: PPUSH
19621: LD_INT 1
19623: PPUSH
19624: CALL_OW 55
// end ; end_of_file
19628: END
// every 0 0$1 trigger not retreatAllowed and farmerRequestedCrates and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
19629: LD_EXP 11
19633: NOT
19634: PUSH
19635: LD_EXP 16
19639: AND
19640: PUSH
19641: LD_EXP 4
19645: AND
19646: PUSH
19647: LD_EXP 15
19651: PUSH
19652: LD_EXP 16
19656: LESSEQUAL
19657: AND
19658: IFFALSE 19748
19660: GO 19662
19662: DISABLE
// begin enable ;
19663: ENABLE
// display_strings := [ #X103-1 , farmerRequestedCrates - farmerCrates ] ;
19664: LD_ADDR_OWVAR 47
19668: PUSH
19669: LD_STRING #X103-1
19671: PUSH
19672: LD_EXP 16
19676: PUSH
19677: LD_EXP 15
19681: MINUS
19682: PUSH
19683: EMPTY
19684: LIST
19685: LIST
19686: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
19687: LD_ADDR_EXP 15
19691: PUSH
19692: LD_INT 5
19694: PPUSH
19695: CALL_OW 274
19699: PPUSH
19700: LD_INT 1
19702: PPUSH
19703: CALL_OW 275
19707: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
19708: LD_INT 10
19710: PPUSH
19711: LD_INT 1
19713: PPUSH
19714: CALL_OW 287
19718: PUSH
19719: LD_INT 0
19721: EQUAL
19722: IFFALSE 19740
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
19724: LD_ADDR_EXP 17
19728: PUSH
19729: LD_EXP 17
19733: PUSH
19734: LD_INT 35
19736: MINUS
19737: ST_TO_ADDR
19738: GO 19748
// farmerCratesCounter := 30 30$00 ;
19740: LD_ADDR_EXP 17
19744: PUSH
19745: LD_INT 63000
19747: ST_TO_ADDR
// end ; end_of_file
19748: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
19749: LD_INT 0
19751: PPUSH
// ar_crane := 88 ;
19752: LD_ADDR_EXP 54
19756: PUSH
19757: LD_INT 88
19759: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
19760: LD_ADDR_EXP 49
19764: PUSH
19765: LD_INT 89
19767: ST_TO_ADDR
// us_hack := 99 ;
19768: LD_ADDR_EXP 50
19772: PUSH
19773: LD_INT 99
19775: ST_TO_ADDR
// us_artillery := 97 ;
19776: LD_ADDR_EXP 51
19780: PUSH
19781: LD_INT 97
19783: ST_TO_ADDR
// ar_bio_bomb := 91 ;
19784: LD_ADDR_EXP 52
19788: PUSH
19789: LD_INT 91
19791: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
19792: LD_ADDR_EXP 53
19796: PUSH
19797: LD_INT 92
19799: ST_TO_ADDR
// ru_radar := 98 ;
19800: LD_ADDR_EXP 48
19804: PUSH
19805: LD_INT 98
19807: ST_TO_ADDR
// tech_Artillery := 80 ;
19808: LD_ADDR_EXP 55
19812: PUSH
19813: LD_INT 80
19815: ST_TO_ADDR
// tech_RadMat := 81 ;
19816: LD_ADDR_EXP 56
19820: PUSH
19821: LD_INT 81
19823: ST_TO_ADDR
// tech_BasicTools := 82 ;
19824: LD_ADDR_EXP 57
19828: PUSH
19829: LD_INT 82
19831: ST_TO_ADDR
// tech_Cargo := 83 ;
19832: LD_ADDR_EXP 58
19836: PUSH
19837: LD_INT 83
19839: ST_TO_ADDR
// tech_Track := 84 ;
19840: LD_ADDR_EXP 59
19844: PUSH
19845: LD_INT 84
19847: ST_TO_ADDR
// tech_Crane := 85 ;
19848: LD_ADDR_EXP 60
19852: PUSH
19853: LD_INT 85
19855: ST_TO_ADDR
// tech_Bulldozer := 86 ;
19856: LD_ADDR_EXP 61
19860: PUSH
19861: LD_INT 86
19863: ST_TO_ADDR
// tech_Hovercraft := 87 ;
19864: LD_ADDR_EXP 62
19868: PUSH
19869: LD_INT 87
19871: ST_TO_ADDR
// end ;
19872: LD_VAR 0 1
19876: RET
// every 1 do
19877: GO 19879
19879: DISABLE
// InitGlobalVariables ; end_of_file
19880: CALL 19749 0 0
19884: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
19885: LD_VAR 0 2
19889: PUSH
19890: LD_INT 100
19892: EQUAL
19893: IFFALSE 20842
// begin if not StreamModeActive then
19895: LD_EXP 63
19899: NOT
19900: IFFALSE 19910
// StreamModeActive := true ;
19902: LD_ADDR_EXP 63
19906: PUSH
19907: LD_INT 1
19909: ST_TO_ADDR
// if p3 = 0 then
19910: LD_VAR 0 3
19914: PUSH
19915: LD_INT 0
19917: EQUAL
19918: IFFALSE 19924
// InitStreamMode ;
19920: CALL 21075 0 0
// if p3 = 1 then
19924: LD_VAR 0 3
19928: PUSH
19929: LD_INT 1
19931: EQUAL
19932: IFFALSE 19942
// sRocket := true ;
19934: LD_ADDR_EXP 68
19938: PUSH
19939: LD_INT 1
19941: ST_TO_ADDR
// if p3 = 2 then
19942: LD_VAR 0 3
19946: PUSH
19947: LD_INT 2
19949: EQUAL
19950: IFFALSE 19960
// sSpeed := true ;
19952: LD_ADDR_EXP 67
19956: PUSH
19957: LD_INT 1
19959: ST_TO_ADDR
// if p3 = 3 then
19960: LD_VAR 0 3
19964: PUSH
19965: LD_INT 3
19967: EQUAL
19968: IFFALSE 19978
// sEngine := true ;
19970: LD_ADDR_EXP 69
19974: PUSH
19975: LD_INT 1
19977: ST_TO_ADDR
// if p3 = 4 then
19978: LD_VAR 0 3
19982: PUSH
19983: LD_INT 4
19985: EQUAL
19986: IFFALSE 19996
// sSpec := true ;
19988: LD_ADDR_EXP 66
19992: PUSH
19993: LD_INT 1
19995: ST_TO_ADDR
// if p3 = 5 then
19996: LD_VAR 0 3
20000: PUSH
20001: LD_INT 5
20003: EQUAL
20004: IFFALSE 20014
// sLevel := true ;
20006: LD_ADDR_EXP 70
20010: PUSH
20011: LD_INT 1
20013: ST_TO_ADDR
// if p3 = 6 then
20014: LD_VAR 0 3
20018: PUSH
20019: LD_INT 6
20021: EQUAL
20022: IFFALSE 20032
// sArmoury := true ;
20024: LD_ADDR_EXP 71
20028: PUSH
20029: LD_INT 1
20031: ST_TO_ADDR
// if p3 = 7 then
20032: LD_VAR 0 3
20036: PUSH
20037: LD_INT 7
20039: EQUAL
20040: IFFALSE 20050
// sRadar := true ;
20042: LD_ADDR_EXP 72
20046: PUSH
20047: LD_INT 1
20049: ST_TO_ADDR
// if p3 = 8 then
20050: LD_VAR 0 3
20054: PUSH
20055: LD_INT 8
20057: EQUAL
20058: IFFALSE 20068
// sBunker := true ;
20060: LD_ADDR_EXP 73
20064: PUSH
20065: LD_INT 1
20067: ST_TO_ADDR
// if p3 = 9 then
20068: LD_VAR 0 3
20072: PUSH
20073: LD_INT 9
20075: EQUAL
20076: IFFALSE 20086
// sHack := true ;
20078: LD_ADDR_EXP 74
20082: PUSH
20083: LD_INT 1
20085: ST_TO_ADDR
// if p3 = 10 then
20086: LD_VAR 0 3
20090: PUSH
20091: LD_INT 10
20093: EQUAL
20094: IFFALSE 20104
// sFire := true ;
20096: LD_ADDR_EXP 75
20100: PUSH
20101: LD_INT 1
20103: ST_TO_ADDR
// if p3 = 11 then
20104: LD_VAR 0 3
20108: PUSH
20109: LD_INT 11
20111: EQUAL
20112: IFFALSE 20122
// sRefresh := true ;
20114: LD_ADDR_EXP 76
20118: PUSH
20119: LD_INT 1
20121: ST_TO_ADDR
// if p3 = 12 then
20122: LD_VAR 0 3
20126: PUSH
20127: LD_INT 12
20129: EQUAL
20130: IFFALSE 20140
// sExp := true ;
20132: LD_ADDR_EXP 77
20136: PUSH
20137: LD_INT 1
20139: ST_TO_ADDR
// if p3 = 13 then
20140: LD_VAR 0 3
20144: PUSH
20145: LD_INT 13
20147: EQUAL
20148: IFFALSE 20158
// sDepot := true ;
20150: LD_ADDR_EXP 78
20154: PUSH
20155: LD_INT 1
20157: ST_TO_ADDR
// if p3 = 14 then
20158: LD_VAR 0 3
20162: PUSH
20163: LD_INT 14
20165: EQUAL
20166: IFFALSE 20176
// sFlag := true ;
20168: LD_ADDR_EXP 79
20172: PUSH
20173: LD_INT 1
20175: ST_TO_ADDR
// if p3 = 15 then
20176: LD_VAR 0 3
20180: PUSH
20181: LD_INT 15
20183: EQUAL
20184: IFFALSE 20194
// sKamikadze := true ;
20186: LD_ADDR_EXP 87
20190: PUSH
20191: LD_INT 1
20193: ST_TO_ADDR
// if p3 = 16 then
20194: LD_VAR 0 3
20198: PUSH
20199: LD_INT 16
20201: EQUAL
20202: IFFALSE 20212
// sTroll := true ;
20204: LD_ADDR_EXP 88
20208: PUSH
20209: LD_INT 1
20211: ST_TO_ADDR
// if p3 = 17 then
20212: LD_VAR 0 3
20216: PUSH
20217: LD_INT 17
20219: EQUAL
20220: IFFALSE 20230
// sSlow := true ;
20222: LD_ADDR_EXP 89
20226: PUSH
20227: LD_INT 1
20229: ST_TO_ADDR
// if p3 = 18 then
20230: LD_VAR 0 3
20234: PUSH
20235: LD_INT 18
20237: EQUAL
20238: IFFALSE 20248
// sLack := true ;
20240: LD_ADDR_EXP 90
20244: PUSH
20245: LD_INT 1
20247: ST_TO_ADDR
// if p3 = 19 then
20248: LD_VAR 0 3
20252: PUSH
20253: LD_INT 19
20255: EQUAL
20256: IFFALSE 20266
// sTank := true ;
20258: LD_ADDR_EXP 92
20262: PUSH
20263: LD_INT 1
20265: ST_TO_ADDR
// if p3 = 20 then
20266: LD_VAR 0 3
20270: PUSH
20271: LD_INT 20
20273: EQUAL
20274: IFFALSE 20284
// sRemote := true ;
20276: LD_ADDR_EXP 93
20280: PUSH
20281: LD_INT 1
20283: ST_TO_ADDR
// if p3 = 21 then
20284: LD_VAR 0 3
20288: PUSH
20289: LD_INT 21
20291: EQUAL
20292: IFFALSE 20302
// sPowell := true ;
20294: LD_ADDR_EXP 94
20298: PUSH
20299: LD_INT 1
20301: ST_TO_ADDR
// if p3 = 22 then
20302: LD_VAR 0 3
20306: PUSH
20307: LD_INT 22
20309: EQUAL
20310: IFFALSE 20320
// sTeleport := true ;
20312: LD_ADDR_EXP 97
20316: PUSH
20317: LD_INT 1
20319: ST_TO_ADDR
// if p3 = 23 then
20320: LD_VAR 0 3
20324: PUSH
20325: LD_INT 23
20327: EQUAL
20328: IFFALSE 20338
// sOilTower := true ;
20330: LD_ADDR_EXP 99
20334: PUSH
20335: LD_INT 1
20337: ST_TO_ADDR
// if p3 = 24 then
20338: LD_VAR 0 3
20342: PUSH
20343: LD_INT 24
20345: EQUAL
20346: IFFALSE 20356
// sShovel := true ;
20348: LD_ADDR_EXP 100
20352: PUSH
20353: LD_INT 1
20355: ST_TO_ADDR
// if p3 = 25 then
20356: LD_VAR 0 3
20360: PUSH
20361: LD_INT 25
20363: EQUAL
20364: IFFALSE 20374
// sSheik := true ;
20366: LD_ADDR_EXP 101
20370: PUSH
20371: LD_INT 1
20373: ST_TO_ADDR
// if p3 = 26 then
20374: LD_VAR 0 3
20378: PUSH
20379: LD_INT 26
20381: EQUAL
20382: IFFALSE 20392
// sEarthquake := true ;
20384: LD_ADDR_EXP 103
20388: PUSH
20389: LD_INT 1
20391: ST_TO_ADDR
// if p3 = 27 then
20392: LD_VAR 0 3
20396: PUSH
20397: LD_INT 27
20399: EQUAL
20400: IFFALSE 20410
// sAI := true ;
20402: LD_ADDR_EXP 104
20406: PUSH
20407: LD_INT 1
20409: ST_TO_ADDR
// if p3 = 28 then
20410: LD_VAR 0 3
20414: PUSH
20415: LD_INT 28
20417: EQUAL
20418: IFFALSE 20428
// sCargo := true ;
20420: LD_ADDR_EXP 107
20424: PUSH
20425: LD_INT 1
20427: ST_TO_ADDR
// if p3 = 29 then
20428: LD_VAR 0 3
20432: PUSH
20433: LD_INT 29
20435: EQUAL
20436: IFFALSE 20446
// sDLaser := true ;
20438: LD_ADDR_EXP 108
20442: PUSH
20443: LD_INT 1
20445: ST_TO_ADDR
// if p3 = 30 then
20446: LD_VAR 0 3
20450: PUSH
20451: LD_INT 30
20453: EQUAL
20454: IFFALSE 20464
// sExchange := true ;
20456: LD_ADDR_EXP 109
20460: PUSH
20461: LD_INT 1
20463: ST_TO_ADDR
// if p3 = 31 then
20464: LD_VAR 0 3
20468: PUSH
20469: LD_INT 31
20471: EQUAL
20472: IFFALSE 20482
// sFac := true ;
20474: LD_ADDR_EXP 110
20478: PUSH
20479: LD_INT 1
20481: ST_TO_ADDR
// if p3 = 32 then
20482: LD_VAR 0 3
20486: PUSH
20487: LD_INT 32
20489: EQUAL
20490: IFFALSE 20500
// sPower := true ;
20492: LD_ADDR_EXP 111
20496: PUSH
20497: LD_INT 1
20499: ST_TO_ADDR
// if p3 = 33 then
20500: LD_VAR 0 3
20504: PUSH
20505: LD_INT 33
20507: EQUAL
20508: IFFALSE 20518
// sRandom := true ;
20510: LD_ADDR_EXP 112
20514: PUSH
20515: LD_INT 1
20517: ST_TO_ADDR
// if p3 = 34 then
20518: LD_VAR 0 3
20522: PUSH
20523: LD_INT 34
20525: EQUAL
20526: IFFALSE 20536
// sShield := true ;
20528: LD_ADDR_EXP 113
20532: PUSH
20533: LD_INT 1
20535: ST_TO_ADDR
// if p3 = 35 then
20536: LD_VAR 0 3
20540: PUSH
20541: LD_INT 35
20543: EQUAL
20544: IFFALSE 20554
// sTime := true ;
20546: LD_ADDR_EXP 114
20550: PUSH
20551: LD_INT 1
20553: ST_TO_ADDR
// if p3 = 36 then
20554: LD_VAR 0 3
20558: PUSH
20559: LD_INT 36
20561: EQUAL
20562: IFFALSE 20572
// sTools := true ;
20564: LD_ADDR_EXP 115
20568: PUSH
20569: LD_INT 1
20571: ST_TO_ADDR
// if p3 = 101 then
20572: LD_VAR 0 3
20576: PUSH
20577: LD_INT 101
20579: EQUAL
20580: IFFALSE 20590
// sSold := true ;
20582: LD_ADDR_EXP 80
20586: PUSH
20587: LD_INT 1
20589: ST_TO_ADDR
// if p3 = 102 then
20590: LD_VAR 0 3
20594: PUSH
20595: LD_INT 102
20597: EQUAL
20598: IFFALSE 20608
// sDiff := true ;
20600: LD_ADDR_EXP 81
20604: PUSH
20605: LD_INT 1
20607: ST_TO_ADDR
// if p3 = 103 then
20608: LD_VAR 0 3
20612: PUSH
20613: LD_INT 103
20615: EQUAL
20616: IFFALSE 20626
// sFog := true ;
20618: LD_ADDR_EXP 84
20622: PUSH
20623: LD_INT 1
20625: ST_TO_ADDR
// if p3 = 104 then
20626: LD_VAR 0 3
20630: PUSH
20631: LD_INT 104
20633: EQUAL
20634: IFFALSE 20644
// sReset := true ;
20636: LD_ADDR_EXP 85
20640: PUSH
20641: LD_INT 1
20643: ST_TO_ADDR
// if p3 = 105 then
20644: LD_VAR 0 3
20648: PUSH
20649: LD_INT 105
20651: EQUAL
20652: IFFALSE 20662
// sSun := true ;
20654: LD_ADDR_EXP 86
20658: PUSH
20659: LD_INT 1
20661: ST_TO_ADDR
// if p3 = 106 then
20662: LD_VAR 0 3
20666: PUSH
20667: LD_INT 106
20669: EQUAL
20670: IFFALSE 20680
// sTiger := true ;
20672: LD_ADDR_EXP 82
20676: PUSH
20677: LD_INT 1
20679: ST_TO_ADDR
// if p3 = 107 then
20680: LD_VAR 0 3
20684: PUSH
20685: LD_INT 107
20687: EQUAL
20688: IFFALSE 20698
// sBomb := true ;
20690: LD_ADDR_EXP 83
20694: PUSH
20695: LD_INT 1
20697: ST_TO_ADDR
// if p3 = 108 then
20698: LD_VAR 0 3
20702: PUSH
20703: LD_INT 108
20705: EQUAL
20706: IFFALSE 20716
// sWound := true ;
20708: LD_ADDR_EXP 91
20712: PUSH
20713: LD_INT 1
20715: ST_TO_ADDR
// if p3 = 109 then
20716: LD_VAR 0 3
20720: PUSH
20721: LD_INT 109
20723: EQUAL
20724: IFFALSE 20734
// sBetray := true ;
20726: LD_ADDR_EXP 95
20730: PUSH
20731: LD_INT 1
20733: ST_TO_ADDR
// if p3 = 110 then
20734: LD_VAR 0 3
20738: PUSH
20739: LD_INT 110
20741: EQUAL
20742: IFFALSE 20752
// sContamin := true ;
20744: LD_ADDR_EXP 96
20748: PUSH
20749: LD_INT 1
20751: ST_TO_ADDR
// if p3 = 111 then
20752: LD_VAR 0 3
20756: PUSH
20757: LD_INT 111
20759: EQUAL
20760: IFFALSE 20770
// sOil := true ;
20762: LD_ADDR_EXP 98
20766: PUSH
20767: LD_INT 1
20769: ST_TO_ADDR
// if p3 = 112 then
20770: LD_VAR 0 3
20774: PUSH
20775: LD_INT 112
20777: EQUAL
20778: IFFALSE 20788
// sStu := true ;
20780: LD_ADDR_EXP 102
20784: PUSH
20785: LD_INT 1
20787: ST_TO_ADDR
// if p3 = 113 then
20788: LD_VAR 0 3
20792: PUSH
20793: LD_INT 113
20795: EQUAL
20796: IFFALSE 20806
// sBazooka := true ;
20798: LD_ADDR_EXP 105
20802: PUSH
20803: LD_INT 1
20805: ST_TO_ADDR
// if p3 = 114 then
20806: LD_VAR 0 3
20810: PUSH
20811: LD_INT 114
20813: EQUAL
20814: IFFALSE 20824
// sMortar := true ;
20816: LD_ADDR_EXP 106
20820: PUSH
20821: LD_INT 1
20823: ST_TO_ADDR
// if p3 = 115 then
20824: LD_VAR 0 3
20828: PUSH
20829: LD_INT 115
20831: EQUAL
20832: IFFALSE 20842
// sRanger := true ;
20834: LD_ADDR_EXP 116
20838: PUSH
20839: LD_INT 1
20841: ST_TO_ADDR
// end ; if p2 = 101 then
20842: LD_VAR 0 2
20846: PUSH
20847: LD_INT 101
20849: EQUAL
20850: IFFALSE 21053
// begin case p3 of 1 :
20852: LD_VAR 0 3
20856: PUSH
20857: LD_INT 1
20859: DOUBLE
20860: EQUAL
20861: IFTRUE 20865
20863: GO 20872
20865: POP
// hHackUnlimitedResources ; 2 :
20866: CALL 31147 0 0
20870: GO 21053
20872: LD_INT 2
20874: DOUBLE
20875: EQUAL
20876: IFTRUE 20880
20878: GO 20887
20880: POP
// hHackSetLevel10 ; 3 :
20881: CALL 31280 0 0
20885: GO 21053
20887: LD_INT 3
20889: DOUBLE
20890: EQUAL
20891: IFTRUE 20895
20893: GO 20902
20895: POP
// hHackSetLevel10YourUnits ; 4 :
20896: CALL 31365 0 0
20900: GO 21053
20902: LD_INT 4
20904: DOUBLE
20905: EQUAL
20906: IFTRUE 20910
20908: GO 20932
20910: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
20911: LD_VAR 0 4
20915: PPUSH
20916: LD_VAR 0 5
20920: PPUSH
20921: LD_VAR 0 6
20925: PPUSH
20926: CALL 31455 0 3
20930: GO 21053
20932: LD_INT 5
20934: DOUBLE
20935: EQUAL
20936: IFTRUE 20940
20938: GO 20947
20940: POP
// hHackSpawnVehicle ; 6 :
20941: CALL 31516 0 0
20945: GO 21053
20947: LD_INT 6
20949: DOUBLE
20950: EQUAL
20951: IFTRUE 20955
20953: GO 20962
20955: POP
// hHackInvincible ; 7 :
20956: CALL 32062 0 0
20960: GO 21053
20962: LD_INT 7
20964: DOUBLE
20965: EQUAL
20966: IFTRUE 20970
20968: GO 20977
20970: POP
// hHackInvisible ; 8 :
20971: CALL 32173 0 0
20975: GO 21053
20977: LD_INT 8
20979: DOUBLE
20980: EQUAL
20981: IFTRUE 20985
20983: GO 20992
20985: POP
// hHackChangeYourSide ; 9 :
20986: CALL 32230 0 0
20990: GO 21053
20992: LD_INT 9
20994: DOUBLE
20995: EQUAL
20996: IFTRUE 21000
20998: GO 21007
21000: POP
// hHackChangeUnitSide ; 10 :
21001: CALL 32272 0 0
21005: GO 21053
21007: LD_INT 10
21009: DOUBLE
21010: EQUAL
21011: IFTRUE 21015
21013: GO 21022
21015: POP
// hHackFog ; 11 :
21016: CALL 32373 0 0
21020: GO 21053
21022: LD_INT 11
21024: DOUBLE
21025: EQUAL
21026: IFTRUE 21030
21028: GO 21037
21030: POP
// hHackApeman ; 12 :
21031: CALL 32388 0 0
21035: GO 21053
21037: LD_INT 12
21039: DOUBLE
21040: EQUAL
21041: IFTRUE 21045
21043: GO 21052
21045: POP
// hHackBoom ; end ;
21046: CALL 32473 0 0
21050: GO 21053
21052: POP
// end ; end ;
21053: PPOPN 6
21055: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
21056: GO 21058
21058: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
21059: LD_STRING initStreamRollete();
21061: PPUSH
21062: CALL_OW 559
// InitStreamMode ;
21066: CALL 21075 0 0
// DefineStreamItems ( ) ;
21070: CALL 21515 0 0
// end ;
21074: END
// function InitStreamMode ; begin
21075: LD_INT 0
21077: PPUSH
// streamModeActive := false ;
21078: LD_ADDR_EXP 63
21082: PUSH
21083: LD_INT 0
21085: ST_TO_ADDR
// normalCounter := 36 ;
21086: LD_ADDR_EXP 64
21090: PUSH
21091: LD_INT 36
21093: ST_TO_ADDR
// hardcoreCounter := 16 ;
21094: LD_ADDR_EXP 65
21098: PUSH
21099: LD_INT 16
21101: ST_TO_ADDR
// sRocket := false ;
21102: LD_ADDR_EXP 68
21106: PUSH
21107: LD_INT 0
21109: ST_TO_ADDR
// sSpeed := false ;
21110: LD_ADDR_EXP 67
21114: PUSH
21115: LD_INT 0
21117: ST_TO_ADDR
// sEngine := false ;
21118: LD_ADDR_EXP 69
21122: PUSH
21123: LD_INT 0
21125: ST_TO_ADDR
// sSpec := false ;
21126: LD_ADDR_EXP 66
21130: PUSH
21131: LD_INT 0
21133: ST_TO_ADDR
// sLevel := false ;
21134: LD_ADDR_EXP 70
21138: PUSH
21139: LD_INT 0
21141: ST_TO_ADDR
// sArmoury := false ;
21142: LD_ADDR_EXP 71
21146: PUSH
21147: LD_INT 0
21149: ST_TO_ADDR
// sRadar := false ;
21150: LD_ADDR_EXP 72
21154: PUSH
21155: LD_INT 0
21157: ST_TO_ADDR
// sBunker := false ;
21158: LD_ADDR_EXP 73
21162: PUSH
21163: LD_INT 0
21165: ST_TO_ADDR
// sHack := false ;
21166: LD_ADDR_EXP 74
21170: PUSH
21171: LD_INT 0
21173: ST_TO_ADDR
// sFire := false ;
21174: LD_ADDR_EXP 75
21178: PUSH
21179: LD_INT 0
21181: ST_TO_ADDR
// sRefresh := false ;
21182: LD_ADDR_EXP 76
21186: PUSH
21187: LD_INT 0
21189: ST_TO_ADDR
// sExp := false ;
21190: LD_ADDR_EXP 77
21194: PUSH
21195: LD_INT 0
21197: ST_TO_ADDR
// sDepot := false ;
21198: LD_ADDR_EXP 78
21202: PUSH
21203: LD_INT 0
21205: ST_TO_ADDR
// sFlag := false ;
21206: LD_ADDR_EXP 79
21210: PUSH
21211: LD_INT 0
21213: ST_TO_ADDR
// sKamikadze := false ;
21214: LD_ADDR_EXP 87
21218: PUSH
21219: LD_INT 0
21221: ST_TO_ADDR
// sTroll := false ;
21222: LD_ADDR_EXP 88
21226: PUSH
21227: LD_INT 0
21229: ST_TO_ADDR
// sSlow := false ;
21230: LD_ADDR_EXP 89
21234: PUSH
21235: LD_INT 0
21237: ST_TO_ADDR
// sLack := false ;
21238: LD_ADDR_EXP 90
21242: PUSH
21243: LD_INT 0
21245: ST_TO_ADDR
// sTank := false ;
21246: LD_ADDR_EXP 92
21250: PUSH
21251: LD_INT 0
21253: ST_TO_ADDR
// sRemote := false ;
21254: LD_ADDR_EXP 93
21258: PUSH
21259: LD_INT 0
21261: ST_TO_ADDR
// sPowell := false ;
21262: LD_ADDR_EXP 94
21266: PUSH
21267: LD_INT 0
21269: ST_TO_ADDR
// sTeleport := false ;
21270: LD_ADDR_EXP 97
21274: PUSH
21275: LD_INT 0
21277: ST_TO_ADDR
// sOilTower := false ;
21278: LD_ADDR_EXP 99
21282: PUSH
21283: LD_INT 0
21285: ST_TO_ADDR
// sShovel := false ;
21286: LD_ADDR_EXP 100
21290: PUSH
21291: LD_INT 0
21293: ST_TO_ADDR
// sSheik := false ;
21294: LD_ADDR_EXP 101
21298: PUSH
21299: LD_INT 0
21301: ST_TO_ADDR
// sEarthquake := false ;
21302: LD_ADDR_EXP 103
21306: PUSH
21307: LD_INT 0
21309: ST_TO_ADDR
// sAI := false ;
21310: LD_ADDR_EXP 104
21314: PUSH
21315: LD_INT 0
21317: ST_TO_ADDR
// sCargo := false ;
21318: LD_ADDR_EXP 107
21322: PUSH
21323: LD_INT 0
21325: ST_TO_ADDR
// sDLaser := false ;
21326: LD_ADDR_EXP 108
21330: PUSH
21331: LD_INT 0
21333: ST_TO_ADDR
// sExchange := false ;
21334: LD_ADDR_EXP 109
21338: PUSH
21339: LD_INT 0
21341: ST_TO_ADDR
// sFac := false ;
21342: LD_ADDR_EXP 110
21346: PUSH
21347: LD_INT 0
21349: ST_TO_ADDR
// sPower := false ;
21350: LD_ADDR_EXP 111
21354: PUSH
21355: LD_INT 0
21357: ST_TO_ADDR
// sRandom := false ;
21358: LD_ADDR_EXP 112
21362: PUSH
21363: LD_INT 0
21365: ST_TO_ADDR
// sShield := false ;
21366: LD_ADDR_EXP 113
21370: PUSH
21371: LD_INT 0
21373: ST_TO_ADDR
// sTime := false ;
21374: LD_ADDR_EXP 114
21378: PUSH
21379: LD_INT 0
21381: ST_TO_ADDR
// sTools := false ;
21382: LD_ADDR_EXP 115
21386: PUSH
21387: LD_INT 0
21389: ST_TO_ADDR
// sSold := false ;
21390: LD_ADDR_EXP 80
21394: PUSH
21395: LD_INT 0
21397: ST_TO_ADDR
// sDiff := false ;
21398: LD_ADDR_EXP 81
21402: PUSH
21403: LD_INT 0
21405: ST_TO_ADDR
// sFog := false ;
21406: LD_ADDR_EXP 84
21410: PUSH
21411: LD_INT 0
21413: ST_TO_ADDR
// sReset := false ;
21414: LD_ADDR_EXP 85
21418: PUSH
21419: LD_INT 0
21421: ST_TO_ADDR
// sSun := false ;
21422: LD_ADDR_EXP 86
21426: PUSH
21427: LD_INT 0
21429: ST_TO_ADDR
// sTiger := false ;
21430: LD_ADDR_EXP 82
21434: PUSH
21435: LD_INT 0
21437: ST_TO_ADDR
// sBomb := false ;
21438: LD_ADDR_EXP 83
21442: PUSH
21443: LD_INT 0
21445: ST_TO_ADDR
// sWound := false ;
21446: LD_ADDR_EXP 91
21450: PUSH
21451: LD_INT 0
21453: ST_TO_ADDR
// sBetray := false ;
21454: LD_ADDR_EXP 95
21458: PUSH
21459: LD_INT 0
21461: ST_TO_ADDR
// sContamin := false ;
21462: LD_ADDR_EXP 96
21466: PUSH
21467: LD_INT 0
21469: ST_TO_ADDR
// sOil := false ;
21470: LD_ADDR_EXP 98
21474: PUSH
21475: LD_INT 0
21477: ST_TO_ADDR
// sStu := false ;
21478: LD_ADDR_EXP 102
21482: PUSH
21483: LD_INT 0
21485: ST_TO_ADDR
// sBazooka := false ;
21486: LD_ADDR_EXP 105
21490: PUSH
21491: LD_INT 0
21493: ST_TO_ADDR
// sMortar := false ;
21494: LD_ADDR_EXP 106
21498: PUSH
21499: LD_INT 0
21501: ST_TO_ADDR
// sRanger := false ;
21502: LD_ADDR_EXP 116
21506: PUSH
21507: LD_INT 0
21509: ST_TO_ADDR
// end ;
21510: LD_VAR 0 1
21514: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
21515: LD_INT 0
21517: PPUSH
21518: PPUSH
21519: PPUSH
21520: PPUSH
21521: PPUSH
// result := [ ] ;
21522: LD_ADDR_VAR 0 1
21526: PUSH
21527: EMPTY
21528: ST_TO_ADDR
// if campaign_id = 1 then
21529: LD_OWVAR 69
21533: PUSH
21534: LD_INT 1
21536: EQUAL
21537: IFFALSE 24475
// begin case mission_number of 1 :
21539: LD_OWVAR 70
21543: PUSH
21544: LD_INT 1
21546: DOUBLE
21547: EQUAL
21548: IFTRUE 21552
21550: GO 21616
21552: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
21553: LD_ADDR_VAR 0 1
21557: PUSH
21558: LD_INT 2
21560: PUSH
21561: LD_INT 4
21563: PUSH
21564: LD_INT 11
21566: PUSH
21567: LD_INT 12
21569: PUSH
21570: LD_INT 15
21572: PUSH
21573: LD_INT 16
21575: PUSH
21576: LD_INT 22
21578: PUSH
21579: LD_INT 23
21581: PUSH
21582: LD_INT 26
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: LIST
21591: LIST
21592: LIST
21593: LIST
21594: LIST
21595: PUSH
21596: LD_INT 101
21598: PUSH
21599: LD_INT 102
21601: PUSH
21602: LD_INT 106
21604: PUSH
21605: EMPTY
21606: LIST
21607: LIST
21608: LIST
21609: PUSH
21610: EMPTY
21611: LIST
21612: LIST
21613: ST_TO_ADDR
21614: GO 24473
21616: LD_INT 2
21618: DOUBLE
21619: EQUAL
21620: IFTRUE 21624
21622: GO 21696
21624: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
21625: LD_ADDR_VAR 0 1
21629: PUSH
21630: LD_INT 2
21632: PUSH
21633: LD_INT 4
21635: PUSH
21636: LD_INT 11
21638: PUSH
21639: LD_INT 12
21641: PUSH
21642: LD_INT 15
21644: PUSH
21645: LD_INT 16
21647: PUSH
21648: LD_INT 22
21650: PUSH
21651: LD_INT 23
21653: PUSH
21654: LD_INT 26
21656: PUSH
21657: EMPTY
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: PUSH
21668: LD_INT 101
21670: PUSH
21671: LD_INT 102
21673: PUSH
21674: LD_INT 105
21676: PUSH
21677: LD_INT 106
21679: PUSH
21680: LD_INT 108
21682: PUSH
21683: EMPTY
21684: LIST
21685: LIST
21686: LIST
21687: LIST
21688: LIST
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: ST_TO_ADDR
21694: GO 24473
21696: LD_INT 3
21698: DOUBLE
21699: EQUAL
21700: IFTRUE 21704
21702: GO 21780
21704: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
21705: LD_ADDR_VAR 0 1
21709: PUSH
21710: LD_INT 2
21712: PUSH
21713: LD_INT 4
21715: PUSH
21716: LD_INT 5
21718: PUSH
21719: LD_INT 11
21721: PUSH
21722: LD_INT 12
21724: PUSH
21725: LD_INT 15
21727: PUSH
21728: LD_INT 16
21730: PUSH
21731: LD_INT 22
21733: PUSH
21734: LD_INT 26
21736: PUSH
21737: LD_INT 36
21739: PUSH
21740: EMPTY
21741: LIST
21742: LIST
21743: LIST
21744: LIST
21745: LIST
21746: LIST
21747: LIST
21748: LIST
21749: LIST
21750: LIST
21751: PUSH
21752: LD_INT 101
21754: PUSH
21755: LD_INT 102
21757: PUSH
21758: LD_INT 105
21760: PUSH
21761: LD_INT 106
21763: PUSH
21764: LD_INT 108
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: LIST
21772: LIST
21773: PUSH
21774: EMPTY
21775: LIST
21776: LIST
21777: ST_TO_ADDR
21778: GO 24473
21780: LD_INT 4
21782: DOUBLE
21783: EQUAL
21784: IFTRUE 21788
21786: GO 21872
21788: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
21789: LD_ADDR_VAR 0 1
21793: PUSH
21794: LD_INT 2
21796: PUSH
21797: LD_INT 4
21799: PUSH
21800: LD_INT 5
21802: PUSH
21803: LD_INT 8
21805: PUSH
21806: LD_INT 11
21808: PUSH
21809: LD_INT 12
21811: PUSH
21812: LD_INT 15
21814: PUSH
21815: LD_INT 16
21817: PUSH
21818: LD_INT 22
21820: PUSH
21821: LD_INT 23
21823: PUSH
21824: LD_INT 26
21826: PUSH
21827: LD_INT 36
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: LIST
21834: LIST
21835: LIST
21836: LIST
21837: LIST
21838: LIST
21839: LIST
21840: LIST
21841: LIST
21842: LIST
21843: PUSH
21844: LD_INT 101
21846: PUSH
21847: LD_INT 102
21849: PUSH
21850: LD_INT 105
21852: PUSH
21853: LD_INT 106
21855: PUSH
21856: LD_INT 108
21858: PUSH
21859: EMPTY
21860: LIST
21861: LIST
21862: LIST
21863: LIST
21864: LIST
21865: PUSH
21866: EMPTY
21867: LIST
21868: LIST
21869: ST_TO_ADDR
21870: GO 24473
21872: LD_INT 5
21874: DOUBLE
21875: EQUAL
21876: IFTRUE 21880
21878: GO 21980
21880: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
21881: LD_ADDR_VAR 0 1
21885: PUSH
21886: LD_INT 2
21888: PUSH
21889: LD_INT 4
21891: PUSH
21892: LD_INT 5
21894: PUSH
21895: LD_INT 6
21897: PUSH
21898: LD_INT 8
21900: PUSH
21901: LD_INT 11
21903: PUSH
21904: LD_INT 12
21906: PUSH
21907: LD_INT 15
21909: PUSH
21910: LD_INT 16
21912: PUSH
21913: LD_INT 22
21915: PUSH
21916: LD_INT 23
21918: PUSH
21919: LD_INT 25
21921: PUSH
21922: LD_INT 26
21924: PUSH
21925: LD_INT 36
21927: PUSH
21928: EMPTY
21929: LIST
21930: LIST
21931: LIST
21932: LIST
21933: LIST
21934: LIST
21935: LIST
21936: LIST
21937: LIST
21938: LIST
21939: LIST
21940: LIST
21941: LIST
21942: LIST
21943: PUSH
21944: LD_INT 101
21946: PUSH
21947: LD_INT 102
21949: PUSH
21950: LD_INT 105
21952: PUSH
21953: LD_INT 106
21955: PUSH
21956: LD_INT 108
21958: PUSH
21959: LD_INT 109
21961: PUSH
21962: LD_INT 112
21964: PUSH
21965: EMPTY
21966: LIST
21967: LIST
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: PUSH
21974: EMPTY
21975: LIST
21976: LIST
21977: ST_TO_ADDR
21978: GO 24473
21980: LD_INT 6
21982: DOUBLE
21983: EQUAL
21984: IFTRUE 21988
21986: GO 22108
21988: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
21989: LD_ADDR_VAR 0 1
21993: PUSH
21994: LD_INT 2
21996: PUSH
21997: LD_INT 4
21999: PUSH
22000: LD_INT 5
22002: PUSH
22003: LD_INT 6
22005: PUSH
22006: LD_INT 8
22008: PUSH
22009: LD_INT 11
22011: PUSH
22012: LD_INT 12
22014: PUSH
22015: LD_INT 15
22017: PUSH
22018: LD_INT 16
22020: PUSH
22021: LD_INT 20
22023: PUSH
22024: LD_INT 21
22026: PUSH
22027: LD_INT 22
22029: PUSH
22030: LD_INT 23
22032: PUSH
22033: LD_INT 25
22035: PUSH
22036: LD_INT 26
22038: PUSH
22039: LD_INT 30
22041: PUSH
22042: LD_INT 31
22044: PUSH
22045: LD_INT 32
22047: PUSH
22048: LD_INT 36
22050: PUSH
22051: EMPTY
22052: LIST
22053: LIST
22054: LIST
22055: LIST
22056: LIST
22057: LIST
22058: LIST
22059: LIST
22060: LIST
22061: LIST
22062: LIST
22063: LIST
22064: LIST
22065: LIST
22066: LIST
22067: LIST
22068: LIST
22069: LIST
22070: LIST
22071: PUSH
22072: LD_INT 101
22074: PUSH
22075: LD_INT 102
22077: PUSH
22078: LD_INT 105
22080: PUSH
22081: LD_INT 106
22083: PUSH
22084: LD_INT 108
22086: PUSH
22087: LD_INT 109
22089: PUSH
22090: LD_INT 112
22092: PUSH
22093: EMPTY
22094: LIST
22095: LIST
22096: LIST
22097: LIST
22098: LIST
22099: LIST
22100: LIST
22101: PUSH
22102: EMPTY
22103: LIST
22104: LIST
22105: ST_TO_ADDR
22106: GO 24473
22108: LD_INT 7
22110: DOUBLE
22111: EQUAL
22112: IFTRUE 22116
22114: GO 22216
22116: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
22117: LD_ADDR_VAR 0 1
22121: PUSH
22122: LD_INT 2
22124: PUSH
22125: LD_INT 4
22127: PUSH
22128: LD_INT 5
22130: PUSH
22131: LD_INT 7
22133: PUSH
22134: LD_INT 11
22136: PUSH
22137: LD_INT 12
22139: PUSH
22140: LD_INT 15
22142: PUSH
22143: LD_INT 16
22145: PUSH
22146: LD_INT 20
22148: PUSH
22149: LD_INT 21
22151: PUSH
22152: LD_INT 22
22154: PUSH
22155: LD_INT 23
22157: PUSH
22158: LD_INT 25
22160: PUSH
22161: LD_INT 26
22163: PUSH
22164: EMPTY
22165: LIST
22166: LIST
22167: LIST
22168: LIST
22169: LIST
22170: LIST
22171: LIST
22172: LIST
22173: LIST
22174: LIST
22175: LIST
22176: LIST
22177: LIST
22178: LIST
22179: PUSH
22180: LD_INT 101
22182: PUSH
22183: LD_INT 102
22185: PUSH
22186: LD_INT 103
22188: PUSH
22189: LD_INT 105
22191: PUSH
22192: LD_INT 106
22194: PUSH
22195: LD_INT 108
22197: PUSH
22198: LD_INT 112
22200: PUSH
22201: EMPTY
22202: LIST
22203: LIST
22204: LIST
22205: LIST
22206: LIST
22207: LIST
22208: LIST
22209: PUSH
22210: EMPTY
22211: LIST
22212: LIST
22213: ST_TO_ADDR
22214: GO 24473
22216: LD_INT 8
22218: DOUBLE
22219: EQUAL
22220: IFTRUE 22224
22222: GO 22352
22224: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
22225: LD_ADDR_VAR 0 1
22229: PUSH
22230: LD_INT 2
22232: PUSH
22233: LD_INT 4
22235: PUSH
22236: LD_INT 5
22238: PUSH
22239: LD_INT 6
22241: PUSH
22242: LD_INT 7
22244: PUSH
22245: LD_INT 8
22247: PUSH
22248: LD_INT 11
22250: PUSH
22251: LD_INT 12
22253: PUSH
22254: LD_INT 15
22256: PUSH
22257: LD_INT 16
22259: PUSH
22260: LD_INT 20
22262: PUSH
22263: LD_INT 21
22265: PUSH
22266: LD_INT 22
22268: PUSH
22269: LD_INT 23
22271: PUSH
22272: LD_INT 25
22274: PUSH
22275: LD_INT 26
22277: PUSH
22278: LD_INT 30
22280: PUSH
22281: LD_INT 31
22283: PUSH
22284: LD_INT 32
22286: PUSH
22287: LD_INT 36
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: LIST
22294: LIST
22295: LIST
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: LIST
22301: LIST
22302: LIST
22303: LIST
22304: LIST
22305: LIST
22306: LIST
22307: LIST
22308: LIST
22309: LIST
22310: LIST
22311: PUSH
22312: LD_INT 101
22314: PUSH
22315: LD_INT 102
22317: PUSH
22318: LD_INT 103
22320: PUSH
22321: LD_INT 105
22323: PUSH
22324: LD_INT 106
22326: PUSH
22327: LD_INT 108
22329: PUSH
22330: LD_INT 109
22332: PUSH
22333: LD_INT 112
22335: PUSH
22336: EMPTY
22337: LIST
22338: LIST
22339: LIST
22340: LIST
22341: LIST
22342: LIST
22343: LIST
22344: LIST
22345: PUSH
22346: EMPTY
22347: LIST
22348: LIST
22349: ST_TO_ADDR
22350: GO 24473
22352: LD_INT 9
22354: DOUBLE
22355: EQUAL
22356: IFTRUE 22360
22358: GO 22496
22360: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
22361: LD_ADDR_VAR 0 1
22365: PUSH
22366: LD_INT 2
22368: PUSH
22369: LD_INT 4
22371: PUSH
22372: LD_INT 5
22374: PUSH
22375: LD_INT 6
22377: PUSH
22378: LD_INT 7
22380: PUSH
22381: LD_INT 8
22383: PUSH
22384: LD_INT 11
22386: PUSH
22387: LD_INT 12
22389: PUSH
22390: LD_INT 15
22392: PUSH
22393: LD_INT 16
22395: PUSH
22396: LD_INT 20
22398: PUSH
22399: LD_INT 21
22401: PUSH
22402: LD_INT 22
22404: PUSH
22405: LD_INT 23
22407: PUSH
22408: LD_INT 25
22410: PUSH
22411: LD_INT 26
22413: PUSH
22414: LD_INT 28
22416: PUSH
22417: LD_INT 30
22419: PUSH
22420: LD_INT 31
22422: PUSH
22423: LD_INT 32
22425: PUSH
22426: LD_INT 36
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: LIST
22437: LIST
22438: LIST
22439: LIST
22440: LIST
22441: LIST
22442: LIST
22443: LIST
22444: LIST
22445: LIST
22446: LIST
22447: LIST
22448: LIST
22449: LIST
22450: LIST
22451: PUSH
22452: LD_INT 101
22454: PUSH
22455: LD_INT 102
22457: PUSH
22458: LD_INT 103
22460: PUSH
22461: LD_INT 105
22463: PUSH
22464: LD_INT 106
22466: PUSH
22467: LD_INT 108
22469: PUSH
22470: LD_INT 109
22472: PUSH
22473: LD_INT 112
22475: PUSH
22476: LD_INT 114
22478: PUSH
22479: EMPTY
22480: LIST
22481: LIST
22482: LIST
22483: LIST
22484: LIST
22485: LIST
22486: LIST
22487: LIST
22488: LIST
22489: PUSH
22490: EMPTY
22491: LIST
22492: LIST
22493: ST_TO_ADDR
22494: GO 24473
22496: LD_INT 10
22498: DOUBLE
22499: EQUAL
22500: IFTRUE 22504
22502: GO 22688
22504: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
22505: LD_ADDR_VAR 0 1
22509: PUSH
22510: LD_INT 2
22512: PUSH
22513: LD_INT 4
22515: PUSH
22516: LD_INT 5
22518: PUSH
22519: LD_INT 6
22521: PUSH
22522: LD_INT 7
22524: PUSH
22525: LD_INT 8
22527: PUSH
22528: LD_INT 9
22530: PUSH
22531: LD_INT 10
22533: PUSH
22534: LD_INT 11
22536: PUSH
22537: LD_INT 12
22539: PUSH
22540: LD_INT 13
22542: PUSH
22543: LD_INT 14
22545: PUSH
22546: LD_INT 15
22548: PUSH
22549: LD_INT 16
22551: PUSH
22552: LD_INT 17
22554: PUSH
22555: LD_INT 18
22557: PUSH
22558: LD_INT 19
22560: PUSH
22561: LD_INT 20
22563: PUSH
22564: LD_INT 21
22566: PUSH
22567: LD_INT 22
22569: PUSH
22570: LD_INT 23
22572: PUSH
22573: LD_INT 24
22575: PUSH
22576: LD_INT 25
22578: PUSH
22579: LD_INT 26
22581: PUSH
22582: LD_INT 28
22584: PUSH
22585: LD_INT 30
22587: PUSH
22588: LD_INT 31
22590: PUSH
22591: LD_INT 32
22593: PUSH
22594: LD_INT 36
22596: PUSH
22597: EMPTY
22598: LIST
22599: LIST
22600: LIST
22601: LIST
22602: LIST
22603: LIST
22604: LIST
22605: LIST
22606: LIST
22607: LIST
22608: LIST
22609: LIST
22610: LIST
22611: LIST
22612: LIST
22613: LIST
22614: LIST
22615: LIST
22616: LIST
22617: LIST
22618: LIST
22619: LIST
22620: LIST
22621: LIST
22622: LIST
22623: LIST
22624: LIST
22625: LIST
22626: LIST
22627: PUSH
22628: LD_INT 101
22630: PUSH
22631: LD_INT 102
22633: PUSH
22634: LD_INT 103
22636: PUSH
22637: LD_INT 104
22639: PUSH
22640: LD_INT 105
22642: PUSH
22643: LD_INT 106
22645: PUSH
22646: LD_INT 107
22648: PUSH
22649: LD_INT 108
22651: PUSH
22652: LD_INT 109
22654: PUSH
22655: LD_INT 110
22657: PUSH
22658: LD_INT 111
22660: PUSH
22661: LD_INT 112
22663: PUSH
22664: LD_INT 114
22666: PUSH
22667: EMPTY
22668: LIST
22669: LIST
22670: LIST
22671: LIST
22672: LIST
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: LIST
22681: PUSH
22682: EMPTY
22683: LIST
22684: LIST
22685: ST_TO_ADDR
22686: GO 24473
22688: LD_INT 11
22690: DOUBLE
22691: EQUAL
22692: IFTRUE 22696
22694: GO 22888
22696: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
22697: LD_ADDR_VAR 0 1
22701: PUSH
22702: LD_INT 2
22704: PUSH
22705: LD_INT 3
22707: PUSH
22708: LD_INT 4
22710: PUSH
22711: LD_INT 5
22713: PUSH
22714: LD_INT 6
22716: PUSH
22717: LD_INT 7
22719: PUSH
22720: LD_INT 8
22722: PUSH
22723: LD_INT 9
22725: PUSH
22726: LD_INT 10
22728: PUSH
22729: LD_INT 11
22731: PUSH
22732: LD_INT 12
22734: PUSH
22735: LD_INT 13
22737: PUSH
22738: LD_INT 14
22740: PUSH
22741: LD_INT 15
22743: PUSH
22744: LD_INT 16
22746: PUSH
22747: LD_INT 17
22749: PUSH
22750: LD_INT 18
22752: PUSH
22753: LD_INT 19
22755: PUSH
22756: LD_INT 20
22758: PUSH
22759: LD_INT 21
22761: PUSH
22762: LD_INT 22
22764: PUSH
22765: LD_INT 23
22767: PUSH
22768: LD_INT 24
22770: PUSH
22771: LD_INT 25
22773: PUSH
22774: LD_INT 26
22776: PUSH
22777: LD_INT 28
22779: PUSH
22780: LD_INT 30
22782: PUSH
22783: LD_INT 31
22785: PUSH
22786: LD_INT 32
22788: PUSH
22789: LD_INT 34
22791: PUSH
22792: LD_INT 36
22794: PUSH
22795: EMPTY
22796: LIST
22797: LIST
22798: LIST
22799: LIST
22800: LIST
22801: LIST
22802: LIST
22803: LIST
22804: LIST
22805: LIST
22806: LIST
22807: LIST
22808: LIST
22809: LIST
22810: LIST
22811: LIST
22812: LIST
22813: LIST
22814: LIST
22815: LIST
22816: LIST
22817: LIST
22818: LIST
22819: LIST
22820: LIST
22821: LIST
22822: LIST
22823: LIST
22824: LIST
22825: LIST
22826: LIST
22827: PUSH
22828: LD_INT 101
22830: PUSH
22831: LD_INT 102
22833: PUSH
22834: LD_INT 103
22836: PUSH
22837: LD_INT 104
22839: PUSH
22840: LD_INT 105
22842: PUSH
22843: LD_INT 106
22845: PUSH
22846: LD_INT 107
22848: PUSH
22849: LD_INT 108
22851: PUSH
22852: LD_INT 109
22854: PUSH
22855: LD_INT 110
22857: PUSH
22858: LD_INT 111
22860: PUSH
22861: LD_INT 112
22863: PUSH
22864: LD_INT 114
22866: PUSH
22867: EMPTY
22868: LIST
22869: LIST
22870: LIST
22871: LIST
22872: LIST
22873: LIST
22874: LIST
22875: LIST
22876: LIST
22877: LIST
22878: LIST
22879: LIST
22880: LIST
22881: PUSH
22882: EMPTY
22883: LIST
22884: LIST
22885: ST_TO_ADDR
22886: GO 24473
22888: LD_INT 12
22890: DOUBLE
22891: EQUAL
22892: IFTRUE 22896
22894: GO 23104
22896: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
22897: LD_ADDR_VAR 0 1
22901: PUSH
22902: LD_INT 1
22904: PUSH
22905: LD_INT 2
22907: PUSH
22908: LD_INT 3
22910: PUSH
22911: LD_INT 4
22913: PUSH
22914: LD_INT 5
22916: PUSH
22917: LD_INT 6
22919: PUSH
22920: LD_INT 7
22922: PUSH
22923: LD_INT 8
22925: PUSH
22926: LD_INT 9
22928: PUSH
22929: LD_INT 10
22931: PUSH
22932: LD_INT 11
22934: PUSH
22935: LD_INT 12
22937: PUSH
22938: LD_INT 13
22940: PUSH
22941: LD_INT 14
22943: PUSH
22944: LD_INT 15
22946: PUSH
22947: LD_INT 16
22949: PUSH
22950: LD_INT 17
22952: PUSH
22953: LD_INT 18
22955: PUSH
22956: LD_INT 19
22958: PUSH
22959: LD_INT 20
22961: PUSH
22962: LD_INT 21
22964: PUSH
22965: LD_INT 22
22967: PUSH
22968: LD_INT 23
22970: PUSH
22971: LD_INT 24
22973: PUSH
22974: LD_INT 25
22976: PUSH
22977: LD_INT 26
22979: PUSH
22980: LD_INT 27
22982: PUSH
22983: LD_INT 28
22985: PUSH
22986: LD_INT 30
22988: PUSH
22989: LD_INT 31
22991: PUSH
22992: LD_INT 32
22994: PUSH
22995: LD_INT 33
22997: PUSH
22998: LD_INT 34
23000: PUSH
23001: LD_INT 36
23003: PUSH
23004: EMPTY
23005: LIST
23006: LIST
23007: LIST
23008: LIST
23009: LIST
23010: LIST
23011: LIST
23012: LIST
23013: LIST
23014: LIST
23015: LIST
23016: LIST
23017: LIST
23018: LIST
23019: LIST
23020: LIST
23021: LIST
23022: LIST
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: LIST
23028: LIST
23029: LIST
23030: LIST
23031: LIST
23032: LIST
23033: LIST
23034: LIST
23035: LIST
23036: LIST
23037: LIST
23038: LIST
23039: PUSH
23040: LD_INT 101
23042: PUSH
23043: LD_INT 102
23045: PUSH
23046: LD_INT 103
23048: PUSH
23049: LD_INT 104
23051: PUSH
23052: LD_INT 105
23054: PUSH
23055: LD_INT 106
23057: PUSH
23058: LD_INT 107
23060: PUSH
23061: LD_INT 108
23063: PUSH
23064: LD_INT 109
23066: PUSH
23067: LD_INT 110
23069: PUSH
23070: LD_INT 111
23072: PUSH
23073: LD_INT 112
23075: PUSH
23076: LD_INT 113
23078: PUSH
23079: LD_INT 114
23081: PUSH
23082: EMPTY
23083: LIST
23084: LIST
23085: LIST
23086: LIST
23087: LIST
23088: LIST
23089: LIST
23090: LIST
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: LIST
23096: LIST
23097: PUSH
23098: EMPTY
23099: LIST
23100: LIST
23101: ST_TO_ADDR
23102: GO 24473
23104: LD_INT 13
23106: DOUBLE
23107: EQUAL
23108: IFTRUE 23112
23110: GO 23308
23112: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
23113: LD_ADDR_VAR 0 1
23117: PUSH
23118: LD_INT 1
23120: PUSH
23121: LD_INT 2
23123: PUSH
23124: LD_INT 3
23126: PUSH
23127: LD_INT 4
23129: PUSH
23130: LD_INT 5
23132: PUSH
23133: LD_INT 8
23135: PUSH
23136: LD_INT 9
23138: PUSH
23139: LD_INT 10
23141: PUSH
23142: LD_INT 11
23144: PUSH
23145: LD_INT 12
23147: PUSH
23148: LD_INT 14
23150: PUSH
23151: LD_INT 15
23153: PUSH
23154: LD_INT 16
23156: PUSH
23157: LD_INT 17
23159: PUSH
23160: LD_INT 18
23162: PUSH
23163: LD_INT 19
23165: PUSH
23166: LD_INT 20
23168: PUSH
23169: LD_INT 21
23171: PUSH
23172: LD_INT 22
23174: PUSH
23175: LD_INT 23
23177: PUSH
23178: LD_INT 24
23180: PUSH
23181: LD_INT 25
23183: PUSH
23184: LD_INT 26
23186: PUSH
23187: LD_INT 27
23189: PUSH
23190: LD_INT 28
23192: PUSH
23193: LD_INT 30
23195: PUSH
23196: LD_INT 31
23198: PUSH
23199: LD_INT 32
23201: PUSH
23202: LD_INT 33
23204: PUSH
23205: LD_INT 34
23207: PUSH
23208: LD_INT 36
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: LIST
23217: LIST
23218: LIST
23219: LIST
23220: LIST
23221: LIST
23222: LIST
23223: LIST
23224: LIST
23225: LIST
23226: LIST
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: LIST
23233: LIST
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: LIST
23239: LIST
23240: LIST
23241: LIST
23242: LIST
23243: PUSH
23244: LD_INT 101
23246: PUSH
23247: LD_INT 102
23249: PUSH
23250: LD_INT 103
23252: PUSH
23253: LD_INT 104
23255: PUSH
23256: LD_INT 105
23258: PUSH
23259: LD_INT 106
23261: PUSH
23262: LD_INT 107
23264: PUSH
23265: LD_INT 108
23267: PUSH
23268: LD_INT 109
23270: PUSH
23271: LD_INT 110
23273: PUSH
23274: LD_INT 111
23276: PUSH
23277: LD_INT 112
23279: PUSH
23280: LD_INT 113
23282: PUSH
23283: LD_INT 114
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: LIST
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: LIST
23295: LIST
23296: LIST
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: PUSH
23302: EMPTY
23303: LIST
23304: LIST
23305: ST_TO_ADDR
23306: GO 24473
23308: LD_INT 14
23310: DOUBLE
23311: EQUAL
23312: IFTRUE 23316
23314: GO 23528
23316: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
23317: LD_ADDR_VAR 0 1
23321: PUSH
23322: LD_INT 1
23324: PUSH
23325: LD_INT 2
23327: PUSH
23328: LD_INT 3
23330: PUSH
23331: LD_INT 4
23333: PUSH
23334: LD_INT 5
23336: PUSH
23337: LD_INT 6
23339: PUSH
23340: LD_INT 7
23342: PUSH
23343: LD_INT 8
23345: PUSH
23346: LD_INT 9
23348: PUSH
23349: LD_INT 10
23351: PUSH
23352: LD_INT 11
23354: PUSH
23355: LD_INT 12
23357: PUSH
23358: LD_INT 13
23360: PUSH
23361: LD_INT 14
23363: PUSH
23364: LD_INT 15
23366: PUSH
23367: LD_INT 16
23369: PUSH
23370: LD_INT 17
23372: PUSH
23373: LD_INT 18
23375: PUSH
23376: LD_INT 19
23378: PUSH
23379: LD_INT 20
23381: PUSH
23382: LD_INT 21
23384: PUSH
23385: LD_INT 22
23387: PUSH
23388: LD_INT 23
23390: PUSH
23391: LD_INT 24
23393: PUSH
23394: LD_INT 25
23396: PUSH
23397: LD_INT 26
23399: PUSH
23400: LD_INT 27
23402: PUSH
23403: LD_INT 28
23405: PUSH
23406: LD_INT 29
23408: PUSH
23409: LD_INT 30
23411: PUSH
23412: LD_INT 31
23414: PUSH
23415: LD_INT 32
23417: PUSH
23418: LD_INT 33
23420: PUSH
23421: LD_INT 34
23423: PUSH
23424: LD_INT 36
23426: PUSH
23427: EMPTY
23428: LIST
23429: LIST
23430: LIST
23431: LIST
23432: LIST
23433: LIST
23434: LIST
23435: LIST
23436: LIST
23437: LIST
23438: LIST
23439: LIST
23440: LIST
23441: LIST
23442: LIST
23443: LIST
23444: LIST
23445: LIST
23446: LIST
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: LIST
23452: LIST
23453: LIST
23454: LIST
23455: LIST
23456: LIST
23457: LIST
23458: LIST
23459: LIST
23460: LIST
23461: LIST
23462: LIST
23463: PUSH
23464: LD_INT 101
23466: PUSH
23467: LD_INT 102
23469: PUSH
23470: LD_INT 103
23472: PUSH
23473: LD_INT 104
23475: PUSH
23476: LD_INT 105
23478: PUSH
23479: LD_INT 106
23481: PUSH
23482: LD_INT 107
23484: PUSH
23485: LD_INT 108
23487: PUSH
23488: LD_INT 109
23490: PUSH
23491: LD_INT 110
23493: PUSH
23494: LD_INT 111
23496: PUSH
23497: LD_INT 112
23499: PUSH
23500: LD_INT 113
23502: PUSH
23503: LD_INT 114
23505: PUSH
23506: EMPTY
23507: LIST
23508: LIST
23509: LIST
23510: LIST
23511: LIST
23512: LIST
23513: LIST
23514: LIST
23515: LIST
23516: LIST
23517: LIST
23518: LIST
23519: LIST
23520: LIST
23521: PUSH
23522: EMPTY
23523: LIST
23524: LIST
23525: ST_TO_ADDR
23526: GO 24473
23528: LD_INT 15
23530: DOUBLE
23531: EQUAL
23532: IFTRUE 23536
23534: GO 23748
23536: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
23537: LD_ADDR_VAR 0 1
23541: PUSH
23542: LD_INT 1
23544: PUSH
23545: LD_INT 2
23547: PUSH
23548: LD_INT 3
23550: PUSH
23551: LD_INT 4
23553: PUSH
23554: LD_INT 5
23556: PUSH
23557: LD_INT 6
23559: PUSH
23560: LD_INT 7
23562: PUSH
23563: LD_INT 8
23565: PUSH
23566: LD_INT 9
23568: PUSH
23569: LD_INT 10
23571: PUSH
23572: LD_INT 11
23574: PUSH
23575: LD_INT 12
23577: PUSH
23578: LD_INT 13
23580: PUSH
23581: LD_INT 14
23583: PUSH
23584: LD_INT 15
23586: PUSH
23587: LD_INT 16
23589: PUSH
23590: LD_INT 17
23592: PUSH
23593: LD_INT 18
23595: PUSH
23596: LD_INT 19
23598: PUSH
23599: LD_INT 20
23601: PUSH
23602: LD_INT 21
23604: PUSH
23605: LD_INT 22
23607: PUSH
23608: LD_INT 23
23610: PUSH
23611: LD_INT 24
23613: PUSH
23614: LD_INT 25
23616: PUSH
23617: LD_INT 26
23619: PUSH
23620: LD_INT 27
23622: PUSH
23623: LD_INT 28
23625: PUSH
23626: LD_INT 29
23628: PUSH
23629: LD_INT 30
23631: PUSH
23632: LD_INT 31
23634: PUSH
23635: LD_INT 32
23637: PUSH
23638: LD_INT 33
23640: PUSH
23641: LD_INT 34
23643: PUSH
23644: LD_INT 36
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: LIST
23651: LIST
23652: LIST
23653: LIST
23654: LIST
23655: LIST
23656: LIST
23657: LIST
23658: LIST
23659: LIST
23660: LIST
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: LIST
23666: LIST
23667: LIST
23668: LIST
23669: LIST
23670: LIST
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: LIST
23676: LIST
23677: LIST
23678: LIST
23679: LIST
23680: LIST
23681: LIST
23682: LIST
23683: PUSH
23684: LD_INT 101
23686: PUSH
23687: LD_INT 102
23689: PUSH
23690: LD_INT 103
23692: PUSH
23693: LD_INT 104
23695: PUSH
23696: LD_INT 105
23698: PUSH
23699: LD_INT 106
23701: PUSH
23702: LD_INT 107
23704: PUSH
23705: LD_INT 108
23707: PUSH
23708: LD_INT 109
23710: PUSH
23711: LD_INT 110
23713: PUSH
23714: LD_INT 111
23716: PUSH
23717: LD_INT 112
23719: PUSH
23720: LD_INT 113
23722: PUSH
23723: LD_INT 114
23725: PUSH
23726: EMPTY
23727: LIST
23728: LIST
23729: LIST
23730: LIST
23731: LIST
23732: LIST
23733: LIST
23734: LIST
23735: LIST
23736: LIST
23737: LIST
23738: LIST
23739: LIST
23740: LIST
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: ST_TO_ADDR
23746: GO 24473
23748: LD_INT 16
23750: DOUBLE
23751: EQUAL
23752: IFTRUE 23756
23754: GO 23880
23756: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
23757: LD_ADDR_VAR 0 1
23761: PUSH
23762: LD_INT 2
23764: PUSH
23765: LD_INT 4
23767: PUSH
23768: LD_INT 5
23770: PUSH
23771: LD_INT 7
23773: PUSH
23774: LD_INT 11
23776: PUSH
23777: LD_INT 12
23779: PUSH
23780: LD_INT 15
23782: PUSH
23783: LD_INT 16
23785: PUSH
23786: LD_INT 20
23788: PUSH
23789: LD_INT 21
23791: PUSH
23792: LD_INT 22
23794: PUSH
23795: LD_INT 23
23797: PUSH
23798: LD_INT 25
23800: PUSH
23801: LD_INT 26
23803: PUSH
23804: LD_INT 30
23806: PUSH
23807: LD_INT 31
23809: PUSH
23810: LD_INT 32
23812: PUSH
23813: LD_INT 33
23815: PUSH
23816: LD_INT 34
23818: PUSH
23819: EMPTY
23820: LIST
23821: LIST
23822: LIST
23823: LIST
23824: LIST
23825: LIST
23826: LIST
23827: LIST
23828: LIST
23829: LIST
23830: LIST
23831: LIST
23832: LIST
23833: LIST
23834: LIST
23835: LIST
23836: LIST
23837: LIST
23838: LIST
23839: PUSH
23840: LD_INT 101
23842: PUSH
23843: LD_INT 102
23845: PUSH
23846: LD_INT 103
23848: PUSH
23849: LD_INT 106
23851: PUSH
23852: LD_INT 108
23854: PUSH
23855: LD_INT 112
23857: PUSH
23858: LD_INT 113
23860: PUSH
23861: LD_INT 114
23863: PUSH
23864: EMPTY
23865: LIST
23866: LIST
23867: LIST
23868: LIST
23869: LIST
23870: LIST
23871: LIST
23872: LIST
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: ST_TO_ADDR
23878: GO 24473
23880: LD_INT 17
23882: DOUBLE
23883: EQUAL
23884: IFTRUE 23888
23886: GO 24100
23888: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
23889: LD_ADDR_VAR 0 1
23893: PUSH
23894: LD_INT 1
23896: PUSH
23897: LD_INT 2
23899: PUSH
23900: LD_INT 3
23902: PUSH
23903: LD_INT 4
23905: PUSH
23906: LD_INT 5
23908: PUSH
23909: LD_INT 6
23911: PUSH
23912: LD_INT 7
23914: PUSH
23915: LD_INT 8
23917: PUSH
23918: LD_INT 9
23920: PUSH
23921: LD_INT 10
23923: PUSH
23924: LD_INT 11
23926: PUSH
23927: LD_INT 12
23929: PUSH
23930: LD_INT 13
23932: PUSH
23933: LD_INT 14
23935: PUSH
23936: LD_INT 15
23938: PUSH
23939: LD_INT 16
23941: PUSH
23942: LD_INT 17
23944: PUSH
23945: LD_INT 18
23947: PUSH
23948: LD_INT 19
23950: PUSH
23951: LD_INT 20
23953: PUSH
23954: LD_INT 21
23956: PUSH
23957: LD_INT 22
23959: PUSH
23960: LD_INT 23
23962: PUSH
23963: LD_INT 24
23965: PUSH
23966: LD_INT 25
23968: PUSH
23969: LD_INT 26
23971: PUSH
23972: LD_INT 27
23974: PUSH
23975: LD_INT 28
23977: PUSH
23978: LD_INT 29
23980: PUSH
23981: LD_INT 30
23983: PUSH
23984: LD_INT 31
23986: PUSH
23987: LD_INT 32
23989: PUSH
23990: LD_INT 33
23992: PUSH
23993: LD_INT 34
23995: PUSH
23996: LD_INT 36
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: LIST
24003: LIST
24004: LIST
24005: LIST
24006: LIST
24007: LIST
24008: LIST
24009: LIST
24010: LIST
24011: LIST
24012: LIST
24013: LIST
24014: LIST
24015: LIST
24016: LIST
24017: LIST
24018: LIST
24019: LIST
24020: LIST
24021: LIST
24022: LIST
24023: LIST
24024: LIST
24025: LIST
24026: LIST
24027: LIST
24028: LIST
24029: LIST
24030: LIST
24031: LIST
24032: LIST
24033: LIST
24034: LIST
24035: PUSH
24036: LD_INT 101
24038: PUSH
24039: LD_INT 102
24041: PUSH
24042: LD_INT 103
24044: PUSH
24045: LD_INT 104
24047: PUSH
24048: LD_INT 105
24050: PUSH
24051: LD_INT 106
24053: PUSH
24054: LD_INT 107
24056: PUSH
24057: LD_INT 108
24059: PUSH
24060: LD_INT 109
24062: PUSH
24063: LD_INT 110
24065: PUSH
24066: LD_INT 111
24068: PUSH
24069: LD_INT 112
24071: PUSH
24072: LD_INT 113
24074: PUSH
24075: LD_INT 114
24077: PUSH
24078: EMPTY
24079: LIST
24080: LIST
24081: LIST
24082: LIST
24083: LIST
24084: LIST
24085: LIST
24086: LIST
24087: LIST
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: LIST
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: ST_TO_ADDR
24098: GO 24473
24100: LD_INT 18
24102: DOUBLE
24103: EQUAL
24104: IFTRUE 24108
24106: GO 24244
24108: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
24109: LD_ADDR_VAR 0 1
24113: PUSH
24114: LD_INT 2
24116: PUSH
24117: LD_INT 4
24119: PUSH
24120: LD_INT 5
24122: PUSH
24123: LD_INT 7
24125: PUSH
24126: LD_INT 11
24128: PUSH
24129: LD_INT 12
24131: PUSH
24132: LD_INT 15
24134: PUSH
24135: LD_INT 16
24137: PUSH
24138: LD_INT 20
24140: PUSH
24141: LD_INT 21
24143: PUSH
24144: LD_INT 22
24146: PUSH
24147: LD_INT 23
24149: PUSH
24150: LD_INT 25
24152: PUSH
24153: LD_INT 26
24155: PUSH
24156: LD_INT 30
24158: PUSH
24159: LD_INT 31
24161: PUSH
24162: LD_INT 32
24164: PUSH
24165: LD_INT 33
24167: PUSH
24168: LD_INT 34
24170: PUSH
24171: LD_INT 35
24173: PUSH
24174: LD_INT 36
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: LIST
24181: LIST
24182: LIST
24183: LIST
24184: LIST
24185: LIST
24186: LIST
24187: LIST
24188: LIST
24189: LIST
24190: LIST
24191: LIST
24192: LIST
24193: LIST
24194: LIST
24195: LIST
24196: LIST
24197: LIST
24198: LIST
24199: PUSH
24200: LD_INT 101
24202: PUSH
24203: LD_INT 102
24205: PUSH
24206: LD_INT 103
24208: PUSH
24209: LD_INT 106
24211: PUSH
24212: LD_INT 108
24214: PUSH
24215: LD_INT 112
24217: PUSH
24218: LD_INT 113
24220: PUSH
24221: LD_INT 114
24223: PUSH
24224: LD_INT 115
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: LIST
24235: LIST
24236: LIST
24237: PUSH
24238: EMPTY
24239: LIST
24240: LIST
24241: ST_TO_ADDR
24242: GO 24473
24244: LD_INT 19
24246: DOUBLE
24247: EQUAL
24248: IFTRUE 24252
24250: GO 24472
24252: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
24253: LD_ADDR_VAR 0 1
24257: PUSH
24258: LD_INT 1
24260: PUSH
24261: LD_INT 2
24263: PUSH
24264: LD_INT 3
24266: PUSH
24267: LD_INT 4
24269: PUSH
24270: LD_INT 5
24272: PUSH
24273: LD_INT 6
24275: PUSH
24276: LD_INT 7
24278: PUSH
24279: LD_INT 8
24281: PUSH
24282: LD_INT 9
24284: PUSH
24285: LD_INT 10
24287: PUSH
24288: LD_INT 11
24290: PUSH
24291: LD_INT 12
24293: PUSH
24294: LD_INT 13
24296: PUSH
24297: LD_INT 14
24299: PUSH
24300: LD_INT 15
24302: PUSH
24303: LD_INT 16
24305: PUSH
24306: LD_INT 17
24308: PUSH
24309: LD_INT 18
24311: PUSH
24312: LD_INT 19
24314: PUSH
24315: LD_INT 20
24317: PUSH
24318: LD_INT 21
24320: PUSH
24321: LD_INT 22
24323: PUSH
24324: LD_INT 23
24326: PUSH
24327: LD_INT 24
24329: PUSH
24330: LD_INT 25
24332: PUSH
24333: LD_INT 26
24335: PUSH
24336: LD_INT 27
24338: PUSH
24339: LD_INT 28
24341: PUSH
24342: LD_INT 29
24344: PUSH
24345: LD_INT 30
24347: PUSH
24348: LD_INT 31
24350: PUSH
24351: LD_INT 32
24353: PUSH
24354: LD_INT 33
24356: PUSH
24357: LD_INT 34
24359: PUSH
24360: LD_INT 35
24362: PUSH
24363: LD_INT 36
24365: PUSH
24366: EMPTY
24367: LIST
24368: LIST
24369: LIST
24370: LIST
24371: LIST
24372: LIST
24373: LIST
24374: LIST
24375: LIST
24376: LIST
24377: LIST
24378: LIST
24379: LIST
24380: LIST
24381: LIST
24382: LIST
24383: LIST
24384: LIST
24385: LIST
24386: LIST
24387: LIST
24388: LIST
24389: LIST
24390: LIST
24391: LIST
24392: LIST
24393: LIST
24394: LIST
24395: LIST
24396: LIST
24397: LIST
24398: LIST
24399: LIST
24400: LIST
24401: LIST
24402: LIST
24403: PUSH
24404: LD_INT 101
24406: PUSH
24407: LD_INT 102
24409: PUSH
24410: LD_INT 103
24412: PUSH
24413: LD_INT 104
24415: PUSH
24416: LD_INT 105
24418: PUSH
24419: LD_INT 106
24421: PUSH
24422: LD_INT 107
24424: PUSH
24425: LD_INT 108
24427: PUSH
24428: LD_INT 109
24430: PUSH
24431: LD_INT 110
24433: PUSH
24434: LD_INT 111
24436: PUSH
24437: LD_INT 112
24439: PUSH
24440: LD_INT 113
24442: PUSH
24443: LD_INT 114
24445: PUSH
24446: LD_INT 115
24448: PUSH
24449: EMPTY
24450: LIST
24451: LIST
24452: LIST
24453: LIST
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: LIST
24459: LIST
24460: LIST
24461: LIST
24462: LIST
24463: LIST
24464: LIST
24465: PUSH
24466: EMPTY
24467: LIST
24468: LIST
24469: ST_TO_ADDR
24470: GO 24473
24472: POP
// end else
24473: GO 24692
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
24475: LD_ADDR_VAR 0 1
24479: PUSH
24480: LD_INT 1
24482: PUSH
24483: LD_INT 2
24485: PUSH
24486: LD_INT 3
24488: PUSH
24489: LD_INT 4
24491: PUSH
24492: LD_INT 5
24494: PUSH
24495: LD_INT 6
24497: PUSH
24498: LD_INT 7
24500: PUSH
24501: LD_INT 8
24503: PUSH
24504: LD_INT 9
24506: PUSH
24507: LD_INT 10
24509: PUSH
24510: LD_INT 11
24512: PUSH
24513: LD_INT 12
24515: PUSH
24516: LD_INT 13
24518: PUSH
24519: LD_INT 14
24521: PUSH
24522: LD_INT 15
24524: PUSH
24525: LD_INT 16
24527: PUSH
24528: LD_INT 17
24530: PUSH
24531: LD_INT 18
24533: PUSH
24534: LD_INT 19
24536: PUSH
24537: LD_INT 20
24539: PUSH
24540: LD_INT 21
24542: PUSH
24543: LD_INT 22
24545: PUSH
24546: LD_INT 23
24548: PUSH
24549: LD_INT 24
24551: PUSH
24552: LD_INT 25
24554: PUSH
24555: LD_INT 26
24557: PUSH
24558: LD_INT 27
24560: PUSH
24561: LD_INT 28
24563: PUSH
24564: LD_INT 29
24566: PUSH
24567: LD_INT 30
24569: PUSH
24570: LD_INT 31
24572: PUSH
24573: LD_INT 32
24575: PUSH
24576: LD_INT 33
24578: PUSH
24579: LD_INT 34
24581: PUSH
24582: LD_INT 35
24584: PUSH
24585: LD_INT 36
24587: PUSH
24588: EMPTY
24589: LIST
24590: LIST
24591: LIST
24592: LIST
24593: LIST
24594: LIST
24595: LIST
24596: LIST
24597: LIST
24598: LIST
24599: LIST
24600: LIST
24601: LIST
24602: LIST
24603: LIST
24604: LIST
24605: LIST
24606: LIST
24607: LIST
24608: LIST
24609: LIST
24610: LIST
24611: LIST
24612: LIST
24613: LIST
24614: LIST
24615: LIST
24616: LIST
24617: LIST
24618: LIST
24619: LIST
24620: LIST
24621: LIST
24622: LIST
24623: LIST
24624: LIST
24625: PUSH
24626: LD_INT 101
24628: PUSH
24629: LD_INT 102
24631: PUSH
24632: LD_INT 103
24634: PUSH
24635: LD_INT 104
24637: PUSH
24638: LD_INT 105
24640: PUSH
24641: LD_INT 106
24643: PUSH
24644: LD_INT 107
24646: PUSH
24647: LD_INT 108
24649: PUSH
24650: LD_INT 109
24652: PUSH
24653: LD_INT 110
24655: PUSH
24656: LD_INT 111
24658: PUSH
24659: LD_INT 112
24661: PUSH
24662: LD_INT 113
24664: PUSH
24665: LD_INT 114
24667: PUSH
24668: LD_INT 115
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: LIST
24675: LIST
24676: LIST
24677: LIST
24678: LIST
24679: LIST
24680: LIST
24681: LIST
24682: LIST
24683: LIST
24684: LIST
24685: LIST
24686: LIST
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: ST_TO_ADDR
// if result then
24692: LD_VAR 0 1
24696: IFFALSE 24985
// begin normal :=  ;
24698: LD_ADDR_VAR 0 3
24702: PUSH
24703: LD_STRING 
24705: ST_TO_ADDR
// hardcore :=  ;
24706: LD_ADDR_VAR 0 4
24710: PUSH
24711: LD_STRING 
24713: ST_TO_ADDR
// for i = 1 to normalCounter do
24714: LD_ADDR_VAR 0 5
24718: PUSH
24719: DOUBLE
24720: LD_INT 1
24722: DEC
24723: ST_TO_ADDR
24724: LD_EXP 64
24728: PUSH
24729: FOR_TO
24730: IFFALSE 24831
// begin tmp := 0 ;
24732: LD_ADDR_VAR 0 2
24736: PUSH
24737: LD_STRING 0
24739: ST_TO_ADDR
// if result [ 1 ] then
24740: LD_VAR 0 1
24744: PUSH
24745: LD_INT 1
24747: ARRAY
24748: IFFALSE 24813
// if result [ 1 ] [ 1 ] = i then
24750: LD_VAR 0 1
24754: PUSH
24755: LD_INT 1
24757: ARRAY
24758: PUSH
24759: LD_INT 1
24761: ARRAY
24762: PUSH
24763: LD_VAR 0 5
24767: EQUAL
24768: IFFALSE 24813
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
24770: LD_ADDR_VAR 0 1
24774: PUSH
24775: LD_VAR 0 1
24779: PPUSH
24780: LD_INT 1
24782: PPUSH
24783: LD_VAR 0 1
24787: PUSH
24788: LD_INT 1
24790: ARRAY
24791: PPUSH
24792: LD_INT 1
24794: PPUSH
24795: CALL_OW 3
24799: PPUSH
24800: CALL_OW 1
24804: ST_TO_ADDR
// tmp := 1 ;
24805: LD_ADDR_VAR 0 2
24809: PUSH
24810: LD_STRING 1
24812: ST_TO_ADDR
// end ; normal := normal & tmp ;
24813: LD_ADDR_VAR 0 3
24817: PUSH
24818: LD_VAR 0 3
24822: PUSH
24823: LD_VAR 0 2
24827: STR
24828: ST_TO_ADDR
// end ;
24829: GO 24729
24831: POP
24832: POP
// for i = 1 to hardcoreCounter do
24833: LD_ADDR_VAR 0 5
24837: PUSH
24838: DOUBLE
24839: LD_INT 1
24841: DEC
24842: ST_TO_ADDR
24843: LD_EXP 65
24847: PUSH
24848: FOR_TO
24849: IFFALSE 24954
// begin tmp := 0 ;
24851: LD_ADDR_VAR 0 2
24855: PUSH
24856: LD_STRING 0
24858: ST_TO_ADDR
// if result [ 2 ] then
24859: LD_VAR 0 1
24863: PUSH
24864: LD_INT 2
24866: ARRAY
24867: IFFALSE 24936
// if result [ 2 ] [ 1 ] = 100 + i then
24869: LD_VAR 0 1
24873: PUSH
24874: LD_INT 2
24876: ARRAY
24877: PUSH
24878: LD_INT 1
24880: ARRAY
24881: PUSH
24882: LD_INT 100
24884: PUSH
24885: LD_VAR 0 5
24889: PLUS
24890: EQUAL
24891: IFFALSE 24936
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
24893: LD_ADDR_VAR 0 1
24897: PUSH
24898: LD_VAR 0 1
24902: PPUSH
24903: LD_INT 2
24905: PPUSH
24906: LD_VAR 0 1
24910: PUSH
24911: LD_INT 2
24913: ARRAY
24914: PPUSH
24915: LD_INT 1
24917: PPUSH
24918: CALL_OW 3
24922: PPUSH
24923: CALL_OW 1
24927: ST_TO_ADDR
// tmp := 1 ;
24928: LD_ADDR_VAR 0 2
24932: PUSH
24933: LD_STRING 1
24935: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
24936: LD_ADDR_VAR 0 4
24940: PUSH
24941: LD_VAR 0 4
24945: PUSH
24946: LD_VAR 0 2
24950: STR
24951: ST_TO_ADDR
// end ;
24952: GO 24848
24954: POP
24955: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
24956: LD_STRING getStreamItemsFromMission("
24958: PUSH
24959: LD_VAR 0 3
24963: STR
24964: PUSH
24965: LD_STRING ","
24967: STR
24968: PUSH
24969: LD_VAR 0 4
24973: STR
24974: PUSH
24975: LD_STRING ")
24977: STR
24978: PPUSH
24979: CALL_OW 559
// end else
24983: GO 24992
// ToLua ( getStreamItemsFromMission("","") ) ;
24985: LD_STRING getStreamItemsFromMission("","")
24987: PPUSH
24988: CALL_OW 559
// end ;
24992: LD_VAR 0 1
24996: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
24997: LD_EXP 63
25001: PUSH
25002: LD_EXP 68
25006: AND
25007: IFFALSE 25131
25009: GO 25011
25011: DISABLE
25012: LD_INT 0
25014: PPUSH
25015: PPUSH
// begin enable ;
25016: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
25017: LD_ADDR_VAR 0 2
25021: PUSH
25022: LD_INT 22
25024: PUSH
25025: LD_OWVAR 2
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: PUSH
25034: LD_INT 2
25036: PUSH
25037: LD_INT 34
25039: PUSH
25040: LD_INT 7
25042: PUSH
25043: EMPTY
25044: LIST
25045: LIST
25046: PUSH
25047: LD_INT 34
25049: PUSH
25050: LD_INT 45
25052: PUSH
25053: EMPTY
25054: LIST
25055: LIST
25056: PUSH
25057: LD_INT 34
25059: PUSH
25060: LD_INT 28
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: PUSH
25067: LD_INT 34
25069: PUSH
25070: LD_INT 47
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: EMPTY
25078: LIST
25079: LIST
25080: LIST
25081: LIST
25082: LIST
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PPUSH
25088: CALL_OW 69
25092: ST_TO_ADDR
// if not tmp then
25093: LD_VAR 0 2
25097: NOT
25098: IFFALSE 25102
// exit ;
25100: GO 25131
// for i in tmp do
25102: LD_ADDR_VAR 0 1
25106: PUSH
25107: LD_VAR 0 2
25111: PUSH
25112: FOR_IN
25113: IFFALSE 25129
// begin SetLives ( i , 0 ) ;
25115: LD_VAR 0 1
25119: PPUSH
25120: LD_INT 0
25122: PPUSH
25123: CALL_OW 234
// end ;
25127: GO 25112
25129: POP
25130: POP
// end ;
25131: PPOPN 2
25133: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
25134: LD_EXP 63
25138: PUSH
25139: LD_EXP 69
25143: AND
25144: IFFALSE 25228
25146: GO 25148
25148: DISABLE
25149: LD_INT 0
25151: PPUSH
25152: PPUSH
// begin enable ;
25153: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
25154: LD_ADDR_VAR 0 2
25158: PUSH
25159: LD_INT 22
25161: PUSH
25162: LD_OWVAR 2
25166: PUSH
25167: EMPTY
25168: LIST
25169: LIST
25170: PUSH
25171: LD_INT 32
25173: PUSH
25174: LD_INT 3
25176: PUSH
25177: EMPTY
25178: LIST
25179: LIST
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: PPUSH
25185: CALL_OW 69
25189: ST_TO_ADDR
// if not tmp then
25190: LD_VAR 0 2
25194: NOT
25195: IFFALSE 25199
// exit ;
25197: GO 25228
// for i in tmp do
25199: LD_ADDR_VAR 0 1
25203: PUSH
25204: LD_VAR 0 2
25208: PUSH
25209: FOR_IN
25210: IFFALSE 25226
// begin SetLives ( i , 0 ) ;
25212: LD_VAR 0 1
25216: PPUSH
25217: LD_INT 0
25219: PPUSH
25220: CALL_OW 234
// end ;
25224: GO 25209
25226: POP
25227: POP
// end ;
25228: PPOPN 2
25230: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
25231: LD_EXP 63
25235: PUSH
25236: LD_EXP 66
25240: AND
25241: IFFALSE 25334
25243: GO 25245
25245: DISABLE
25246: LD_INT 0
25248: PPUSH
// begin enable ;
25249: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
25250: LD_ADDR_VAR 0 1
25254: PUSH
25255: LD_INT 22
25257: PUSH
25258: LD_OWVAR 2
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: PUSH
25267: LD_INT 2
25269: PUSH
25270: LD_INT 25
25272: PUSH
25273: LD_INT 5
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 25
25282: PUSH
25283: LD_INT 9
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: LD_INT 25
25292: PUSH
25293: LD_INT 8
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: EMPTY
25301: LIST
25302: LIST
25303: LIST
25304: LIST
25305: PUSH
25306: EMPTY
25307: LIST
25308: LIST
25309: PPUSH
25310: CALL_OW 69
25314: PUSH
25315: FOR_IN
25316: IFFALSE 25332
// begin SetClass ( i , 1 ) ;
25318: LD_VAR 0 1
25322: PPUSH
25323: LD_INT 1
25325: PPUSH
25326: CALL_OW 336
// end ;
25330: GO 25315
25332: POP
25333: POP
// end ;
25334: PPOPN 1
25336: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
25337: LD_EXP 63
25341: PUSH
25342: LD_EXP 67
25346: AND
25347: PUSH
25348: LD_OWVAR 65
25352: PUSH
25353: LD_INT 7
25355: LESS
25356: AND
25357: IFFALSE 25371
25359: GO 25361
25361: DISABLE
// begin enable ;
25362: ENABLE
// game_speed := 7 ;
25363: LD_ADDR_OWVAR 65
25367: PUSH
25368: LD_INT 7
25370: ST_TO_ADDR
// end ;
25371: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
25372: LD_EXP 63
25376: PUSH
25377: LD_EXP 70
25381: AND
25382: IFFALSE 25584
25384: GO 25386
25386: DISABLE
25387: LD_INT 0
25389: PPUSH
25390: PPUSH
25391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
25392: LD_ADDR_VAR 0 3
25396: PUSH
25397: LD_INT 81
25399: PUSH
25400: LD_OWVAR 2
25404: PUSH
25405: EMPTY
25406: LIST
25407: LIST
25408: PUSH
25409: LD_INT 21
25411: PUSH
25412: LD_INT 1
25414: PUSH
25415: EMPTY
25416: LIST
25417: LIST
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PPUSH
25423: CALL_OW 69
25427: ST_TO_ADDR
// if not tmp then
25428: LD_VAR 0 3
25432: NOT
25433: IFFALSE 25437
// exit ;
25435: GO 25584
// if tmp > 5 then
25437: LD_VAR 0 3
25441: PUSH
25442: LD_INT 5
25444: GREATER
25445: IFFALSE 25457
// k := 5 else
25447: LD_ADDR_VAR 0 2
25451: PUSH
25452: LD_INT 5
25454: ST_TO_ADDR
25455: GO 25467
// k := tmp ;
25457: LD_ADDR_VAR 0 2
25461: PUSH
25462: LD_VAR 0 3
25466: ST_TO_ADDR
// for i := 1 to k do
25467: LD_ADDR_VAR 0 1
25471: PUSH
25472: DOUBLE
25473: LD_INT 1
25475: DEC
25476: ST_TO_ADDR
25477: LD_VAR 0 2
25481: PUSH
25482: FOR_TO
25483: IFFALSE 25582
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
25485: LD_VAR 0 3
25489: PUSH
25490: LD_VAR 0 1
25494: ARRAY
25495: PPUSH
25496: LD_VAR 0 1
25500: PUSH
25501: LD_INT 4
25503: MOD
25504: PUSH
25505: LD_INT 1
25507: PLUS
25508: PPUSH
25509: CALL_OW 259
25513: PUSH
25514: LD_INT 10
25516: LESS
25517: IFFALSE 25580
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
25519: LD_VAR 0 3
25523: PUSH
25524: LD_VAR 0 1
25528: ARRAY
25529: PPUSH
25530: LD_VAR 0 1
25534: PUSH
25535: LD_INT 4
25537: MOD
25538: PUSH
25539: LD_INT 1
25541: PLUS
25542: PPUSH
25543: LD_VAR 0 3
25547: PUSH
25548: LD_VAR 0 1
25552: ARRAY
25553: PPUSH
25554: LD_VAR 0 1
25558: PUSH
25559: LD_INT 4
25561: MOD
25562: PUSH
25563: LD_INT 1
25565: PLUS
25566: PPUSH
25567: CALL_OW 259
25571: PUSH
25572: LD_INT 1
25574: PLUS
25575: PPUSH
25576: CALL_OW 237
25580: GO 25482
25582: POP
25583: POP
// end ;
25584: PPOPN 3
25586: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
25587: LD_EXP 63
25591: PUSH
25592: LD_EXP 71
25596: AND
25597: IFFALSE 25617
25599: GO 25601
25601: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
25602: LD_INT 4
25604: PPUSH
25605: LD_OWVAR 2
25609: PPUSH
25610: LD_INT 0
25612: PPUSH
25613: CALL_OW 324
25617: END
// every 0 0$1 trigger StreamModeActive and sShovel do
25618: LD_EXP 63
25622: PUSH
25623: LD_EXP 100
25627: AND
25628: IFFALSE 25648
25630: GO 25632
25632: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
25633: LD_INT 19
25635: PPUSH
25636: LD_OWVAR 2
25640: PPUSH
25641: LD_INT 0
25643: PPUSH
25644: CALL_OW 324
25648: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
25649: LD_EXP 63
25653: PUSH
25654: LD_EXP 72
25658: AND
25659: IFFALSE 25761
25661: GO 25663
25663: DISABLE
25664: LD_INT 0
25666: PPUSH
25667: PPUSH
// begin enable ;
25668: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
25669: LD_ADDR_VAR 0 2
25673: PUSH
25674: LD_INT 22
25676: PUSH
25677: LD_OWVAR 2
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 2
25688: PUSH
25689: LD_INT 34
25691: PUSH
25692: LD_INT 11
25694: PUSH
25695: EMPTY
25696: LIST
25697: LIST
25698: PUSH
25699: LD_INT 34
25701: PUSH
25702: LD_INT 30
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: LIST
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PPUSH
25718: CALL_OW 69
25722: ST_TO_ADDR
// if not tmp then
25723: LD_VAR 0 2
25727: NOT
25728: IFFALSE 25732
// exit ;
25730: GO 25761
// for i in tmp do
25732: LD_ADDR_VAR 0 1
25736: PUSH
25737: LD_VAR 0 2
25741: PUSH
25742: FOR_IN
25743: IFFALSE 25759
// begin SetLives ( i , 0 ) ;
25745: LD_VAR 0 1
25749: PPUSH
25750: LD_INT 0
25752: PPUSH
25753: CALL_OW 234
// end ;
25757: GO 25742
25759: POP
25760: POP
// end ;
25761: PPOPN 2
25763: END
// every 0 0$1 trigger StreamModeActive and sBunker do
25764: LD_EXP 63
25768: PUSH
25769: LD_EXP 73
25773: AND
25774: IFFALSE 25794
25776: GO 25778
25778: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
25779: LD_INT 32
25781: PPUSH
25782: LD_OWVAR 2
25786: PPUSH
25787: LD_INT 0
25789: PPUSH
25790: CALL_OW 324
25794: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
25795: LD_EXP 63
25799: PUSH
25800: LD_EXP 74
25804: AND
25805: IFFALSE 25986
25807: GO 25809
25809: DISABLE
25810: LD_INT 0
25812: PPUSH
25813: PPUSH
25814: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
25815: LD_ADDR_VAR 0 2
25819: PUSH
25820: LD_INT 22
25822: PUSH
25823: LD_OWVAR 2
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PUSH
25832: LD_INT 33
25834: PUSH
25835: LD_INT 3
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: PPUSH
25846: CALL_OW 69
25850: ST_TO_ADDR
// if not tmp then
25851: LD_VAR 0 2
25855: NOT
25856: IFFALSE 25860
// exit ;
25858: GO 25986
// side := 0 ;
25860: LD_ADDR_VAR 0 3
25864: PUSH
25865: LD_INT 0
25867: ST_TO_ADDR
// for i := 1 to 8 do
25868: LD_ADDR_VAR 0 1
25872: PUSH
25873: DOUBLE
25874: LD_INT 1
25876: DEC
25877: ST_TO_ADDR
25878: LD_INT 8
25880: PUSH
25881: FOR_TO
25882: IFFALSE 25930
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
25884: LD_OWVAR 2
25888: PUSH
25889: LD_VAR 0 1
25893: NONEQUAL
25894: PUSH
25895: LD_OWVAR 2
25899: PPUSH
25900: LD_VAR 0 1
25904: PPUSH
25905: CALL_OW 81
25909: PUSH
25910: LD_INT 2
25912: EQUAL
25913: AND
25914: IFFALSE 25928
// begin side := i ;
25916: LD_ADDR_VAR 0 3
25920: PUSH
25921: LD_VAR 0 1
25925: ST_TO_ADDR
// break ;
25926: GO 25930
// end ;
25928: GO 25881
25930: POP
25931: POP
// if not side then
25932: LD_VAR 0 3
25936: NOT
25937: IFFALSE 25941
// exit ;
25939: GO 25986
// for i := 1 to tmp do
25941: LD_ADDR_VAR 0 1
25945: PUSH
25946: DOUBLE
25947: LD_INT 1
25949: DEC
25950: ST_TO_ADDR
25951: LD_VAR 0 2
25955: PUSH
25956: FOR_TO
25957: IFFALSE 25984
// if Prob ( 60 ) then
25959: LD_INT 60
25961: PPUSH
25962: CALL_OW 13
25966: IFFALSE 25982
// SetSide ( i , side ) ;
25968: LD_VAR 0 1
25972: PPUSH
25973: LD_VAR 0 3
25977: PPUSH
25978: CALL_OW 235
25982: GO 25956
25984: POP
25985: POP
// end ;
25986: PPOPN 3
25988: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
25989: LD_EXP 63
25993: PUSH
25994: LD_EXP 76
25998: AND
25999: IFFALSE 26118
26001: GO 26003
26003: DISABLE
26004: LD_INT 0
26006: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
26007: LD_ADDR_VAR 0 1
26011: PUSH
26012: LD_INT 22
26014: PUSH
26015: LD_OWVAR 2
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: PUSH
26024: LD_INT 21
26026: PUSH
26027: LD_INT 1
26029: PUSH
26030: EMPTY
26031: LIST
26032: LIST
26033: PUSH
26034: LD_INT 3
26036: PUSH
26037: LD_INT 23
26039: PUSH
26040: LD_INT 0
26042: PUSH
26043: EMPTY
26044: LIST
26045: LIST
26046: PUSH
26047: EMPTY
26048: LIST
26049: LIST
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: LIST
26055: PPUSH
26056: CALL_OW 69
26060: PUSH
26061: FOR_IN
26062: IFFALSE 26116
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
26064: LD_VAR 0 1
26068: PPUSH
26069: CALL_OW 257
26073: PUSH
26074: LD_INT 1
26076: PUSH
26077: LD_INT 2
26079: PUSH
26080: LD_INT 3
26082: PUSH
26083: LD_INT 4
26085: PUSH
26086: EMPTY
26087: LIST
26088: LIST
26089: LIST
26090: LIST
26091: IN
26092: IFFALSE 26114
// SetClass ( un , rand ( 1 , 4 ) ) ;
26094: LD_VAR 0 1
26098: PPUSH
26099: LD_INT 1
26101: PPUSH
26102: LD_INT 4
26104: PPUSH
26105: CALL_OW 12
26109: PPUSH
26110: CALL_OW 336
26114: GO 26061
26116: POP
26117: POP
// end ;
26118: PPOPN 1
26120: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
26121: LD_EXP 63
26125: PUSH
26126: LD_EXP 75
26130: AND
26131: IFFALSE 26210
26133: GO 26135
26135: DISABLE
26136: LD_INT 0
26138: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
26139: LD_ADDR_VAR 0 1
26143: PUSH
26144: LD_INT 22
26146: PUSH
26147: LD_OWVAR 2
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: PUSH
26156: LD_INT 21
26158: PUSH
26159: LD_INT 3
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: EMPTY
26167: LIST
26168: LIST
26169: PPUSH
26170: CALL_OW 69
26174: ST_TO_ADDR
// if not tmp then
26175: LD_VAR 0 1
26179: NOT
26180: IFFALSE 26184
// exit ;
26182: GO 26210
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
26184: LD_VAR 0 1
26188: PUSH
26189: LD_INT 1
26191: PPUSH
26192: LD_VAR 0 1
26196: PPUSH
26197: CALL_OW 12
26201: ARRAY
26202: PPUSH
26203: LD_INT 100
26205: PPUSH
26206: CALL_OW 234
// end ;
26210: PPOPN 1
26212: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
26213: LD_EXP 63
26217: PUSH
26218: LD_EXP 77
26222: AND
26223: IFFALSE 26321
26225: GO 26227
26227: DISABLE
26228: LD_INT 0
26230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
26231: LD_ADDR_VAR 0 1
26235: PUSH
26236: LD_INT 22
26238: PUSH
26239: LD_OWVAR 2
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PUSH
26248: LD_INT 21
26250: PUSH
26251: LD_INT 1
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PPUSH
26262: CALL_OW 69
26266: ST_TO_ADDR
// if not tmp then
26267: LD_VAR 0 1
26271: NOT
26272: IFFALSE 26276
// exit ;
26274: GO 26321
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
26276: LD_VAR 0 1
26280: PUSH
26281: LD_INT 1
26283: PPUSH
26284: LD_VAR 0 1
26288: PPUSH
26289: CALL_OW 12
26293: ARRAY
26294: PPUSH
26295: LD_INT 1
26297: PPUSH
26298: LD_INT 4
26300: PPUSH
26301: CALL_OW 12
26305: PPUSH
26306: LD_INT 3000
26308: PPUSH
26309: LD_INT 9000
26311: PPUSH
26312: CALL_OW 12
26316: PPUSH
26317: CALL_OW 492
// end ;
26321: PPOPN 1
26323: END
// every 0 0$1 trigger StreamModeActive and sDepot do
26324: LD_EXP 63
26328: PUSH
26329: LD_EXP 78
26333: AND
26334: IFFALSE 26354
26336: GO 26338
26338: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
26339: LD_INT 1
26341: PPUSH
26342: LD_OWVAR 2
26346: PPUSH
26347: LD_INT 0
26349: PPUSH
26350: CALL_OW 324
26354: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
26355: LD_EXP 63
26359: PUSH
26360: LD_EXP 79
26364: AND
26365: IFFALSE 26448
26367: GO 26369
26369: DISABLE
26370: LD_INT 0
26372: PPUSH
26373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
26374: LD_ADDR_VAR 0 2
26378: PUSH
26379: LD_INT 22
26381: PUSH
26382: LD_OWVAR 2
26386: PUSH
26387: EMPTY
26388: LIST
26389: LIST
26390: PUSH
26391: LD_INT 21
26393: PUSH
26394: LD_INT 3
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PPUSH
26405: CALL_OW 69
26409: ST_TO_ADDR
// if not tmp then
26410: LD_VAR 0 2
26414: NOT
26415: IFFALSE 26419
// exit ;
26417: GO 26448
// for i in tmp do
26419: LD_ADDR_VAR 0 1
26423: PUSH
26424: LD_VAR 0 2
26428: PUSH
26429: FOR_IN
26430: IFFALSE 26446
// SetBLevel ( i , 10 ) ;
26432: LD_VAR 0 1
26436: PPUSH
26437: LD_INT 10
26439: PPUSH
26440: CALL_OW 241
26444: GO 26429
26446: POP
26447: POP
// end ;
26448: PPOPN 2
26450: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
26451: LD_EXP 63
26455: PUSH
26456: LD_EXP 80
26460: AND
26461: IFFALSE 26572
26463: GO 26465
26465: DISABLE
26466: LD_INT 0
26468: PPUSH
26469: PPUSH
26470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26471: LD_ADDR_VAR 0 3
26475: PUSH
26476: LD_INT 22
26478: PUSH
26479: LD_OWVAR 2
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: LD_INT 25
26490: PUSH
26491: LD_INT 1
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: PPUSH
26502: CALL_OW 69
26506: ST_TO_ADDR
// if not tmp then
26507: LD_VAR 0 3
26511: NOT
26512: IFFALSE 26516
// exit ;
26514: GO 26572
// un := tmp [ rand ( 1 , tmp ) ] ;
26516: LD_ADDR_VAR 0 2
26520: PUSH
26521: LD_VAR 0 3
26525: PUSH
26526: LD_INT 1
26528: PPUSH
26529: LD_VAR 0 3
26533: PPUSH
26534: CALL_OW 12
26538: ARRAY
26539: ST_TO_ADDR
// if Crawls ( un ) then
26540: LD_VAR 0 2
26544: PPUSH
26545: CALL_OW 318
26549: IFFALSE 26560
// ComWalk ( un ) ;
26551: LD_VAR 0 2
26555: PPUSH
26556: CALL_OW 138
// SetClass ( un , class_sniper ) ;
26560: LD_VAR 0 2
26564: PPUSH
26565: LD_INT 5
26567: PPUSH
26568: CALL_OW 336
// end ;
26572: PPOPN 3
26574: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
26575: LD_EXP 63
26579: PUSH
26580: LD_EXP 81
26584: AND
26585: PUSH
26586: LD_OWVAR 67
26590: PUSH
26591: LD_INT 3
26593: LESS
26594: AND
26595: IFFALSE 26614
26597: GO 26599
26599: DISABLE
// Difficulty := Difficulty + 1 ;
26600: LD_ADDR_OWVAR 67
26604: PUSH
26605: LD_OWVAR 67
26609: PUSH
26610: LD_INT 1
26612: PLUS
26613: ST_TO_ADDR
26614: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
26615: LD_EXP 63
26619: PUSH
26620: LD_EXP 82
26624: AND
26625: IFFALSE 26728
26627: GO 26629
26629: DISABLE
26630: LD_INT 0
26632: PPUSH
// begin for i := 1 to 5 do
26633: LD_ADDR_VAR 0 1
26637: PUSH
26638: DOUBLE
26639: LD_INT 1
26641: DEC
26642: ST_TO_ADDR
26643: LD_INT 5
26645: PUSH
26646: FOR_TO
26647: IFFALSE 26726
// begin uc_nation := nation_nature ;
26649: LD_ADDR_OWVAR 21
26653: PUSH
26654: LD_INT 0
26656: ST_TO_ADDR
// uc_side := 0 ;
26657: LD_ADDR_OWVAR 20
26661: PUSH
26662: LD_INT 0
26664: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
26665: LD_ADDR_OWVAR 29
26669: PUSH
26670: LD_INT 12
26672: PUSH
26673: LD_INT 12
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: ST_TO_ADDR
// hc_agressivity := 20 ;
26680: LD_ADDR_OWVAR 35
26684: PUSH
26685: LD_INT 20
26687: ST_TO_ADDR
// hc_class := class_tiger ;
26688: LD_ADDR_OWVAR 28
26692: PUSH
26693: LD_INT 14
26695: ST_TO_ADDR
// hc_gallery :=  ;
26696: LD_ADDR_OWVAR 33
26700: PUSH
26701: LD_STRING 
26703: ST_TO_ADDR
// hc_name :=  ;
26704: LD_ADDR_OWVAR 26
26708: PUSH
26709: LD_STRING 
26711: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
26712: CALL_OW 44
26716: PPUSH
26717: LD_INT 0
26719: PPUSH
26720: CALL_OW 51
// end ;
26724: GO 26646
26726: POP
26727: POP
// end ;
26728: PPOPN 1
26730: END
// every 0 0$1 trigger StreamModeActive and sBomb do
26731: LD_EXP 63
26735: PUSH
26736: LD_EXP 83
26740: AND
26741: IFFALSE 26750
26743: GO 26745
26745: DISABLE
// StreamSibBomb ;
26746: CALL 26751 0 0
26750: END
// export function StreamSibBomb ; var i , x , y ; begin
26751: LD_INT 0
26753: PPUSH
26754: PPUSH
26755: PPUSH
26756: PPUSH
// result := false ;
26757: LD_ADDR_VAR 0 1
26761: PUSH
26762: LD_INT 0
26764: ST_TO_ADDR
// for i := 1 to 16 do
26765: LD_ADDR_VAR 0 2
26769: PUSH
26770: DOUBLE
26771: LD_INT 1
26773: DEC
26774: ST_TO_ADDR
26775: LD_INT 16
26777: PUSH
26778: FOR_TO
26779: IFFALSE 26978
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
26781: LD_ADDR_VAR 0 3
26785: PUSH
26786: LD_INT 10
26788: PUSH
26789: LD_INT 20
26791: PUSH
26792: LD_INT 30
26794: PUSH
26795: LD_INT 40
26797: PUSH
26798: LD_INT 50
26800: PUSH
26801: LD_INT 60
26803: PUSH
26804: LD_INT 70
26806: PUSH
26807: LD_INT 80
26809: PUSH
26810: LD_INT 90
26812: PUSH
26813: LD_INT 100
26815: PUSH
26816: LD_INT 110
26818: PUSH
26819: LD_INT 120
26821: PUSH
26822: LD_INT 130
26824: PUSH
26825: LD_INT 140
26827: PUSH
26828: LD_INT 150
26830: PUSH
26831: EMPTY
26832: LIST
26833: LIST
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: LIST
26839: LIST
26840: LIST
26841: LIST
26842: LIST
26843: LIST
26844: LIST
26845: LIST
26846: LIST
26847: PUSH
26848: LD_INT 1
26850: PPUSH
26851: LD_INT 15
26853: PPUSH
26854: CALL_OW 12
26858: ARRAY
26859: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
26860: LD_ADDR_VAR 0 4
26864: PUSH
26865: LD_INT 10
26867: PUSH
26868: LD_INT 20
26870: PUSH
26871: LD_INT 30
26873: PUSH
26874: LD_INT 40
26876: PUSH
26877: LD_INT 50
26879: PUSH
26880: LD_INT 60
26882: PUSH
26883: LD_INT 70
26885: PUSH
26886: LD_INT 80
26888: PUSH
26889: LD_INT 90
26891: PUSH
26892: LD_INT 100
26894: PUSH
26895: LD_INT 110
26897: PUSH
26898: LD_INT 120
26900: PUSH
26901: LD_INT 130
26903: PUSH
26904: LD_INT 140
26906: PUSH
26907: LD_INT 150
26909: PUSH
26910: EMPTY
26911: LIST
26912: LIST
26913: LIST
26914: LIST
26915: LIST
26916: LIST
26917: LIST
26918: LIST
26919: LIST
26920: LIST
26921: LIST
26922: LIST
26923: LIST
26924: LIST
26925: LIST
26926: PUSH
26927: LD_INT 1
26929: PPUSH
26930: LD_INT 15
26932: PPUSH
26933: CALL_OW 12
26937: ARRAY
26938: ST_TO_ADDR
// if ValidHex ( x , y ) then
26939: LD_VAR 0 3
26943: PPUSH
26944: LD_VAR 0 4
26948: PPUSH
26949: CALL_OW 488
26953: IFFALSE 26976
// begin result := [ x , y ] ;
26955: LD_ADDR_VAR 0 1
26959: PUSH
26960: LD_VAR 0 3
26964: PUSH
26965: LD_VAR 0 4
26969: PUSH
26970: EMPTY
26971: LIST
26972: LIST
26973: ST_TO_ADDR
// break ;
26974: GO 26978
// end ; end ;
26976: GO 26778
26978: POP
26979: POP
// if result then
26980: LD_VAR 0 1
26984: IFFALSE 27044
// begin ToLua ( playSibBomb() ) ;
26986: LD_STRING playSibBomb()
26988: PPUSH
26989: CALL_OW 559
// wait ( 0 0$14 ) ;
26993: LD_INT 490
26995: PPUSH
26996: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
27000: LD_VAR 0 1
27004: PUSH
27005: LD_INT 1
27007: ARRAY
27008: PPUSH
27009: LD_VAR 0 1
27013: PUSH
27014: LD_INT 2
27016: ARRAY
27017: PPUSH
27018: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
27022: LD_VAR 0 1
27026: PUSH
27027: LD_INT 1
27029: ARRAY
27030: PPUSH
27031: LD_VAR 0 1
27035: PUSH
27036: LD_INT 2
27038: ARRAY
27039: PPUSH
27040: CALL_OW 429
// end ; end ;
27044: LD_VAR 0 1
27048: RET
// every 0 0$1 trigger StreamModeActive and sReset do
27049: LD_EXP 63
27053: PUSH
27054: LD_EXP 85
27058: AND
27059: IFFALSE 27071
27061: GO 27063
27063: DISABLE
// YouLost (  ) ;
27064: LD_STRING 
27066: PPUSH
27067: CALL_OW 104
27071: END
// every 0 0$1 trigger StreamModeActive and sFog do
27072: LD_EXP 63
27076: PUSH
27077: LD_EXP 84
27081: AND
27082: IFFALSE 27096
27084: GO 27086
27086: DISABLE
// FogOff ( your_side ) ;
27087: LD_OWVAR 2
27091: PPUSH
27092: CALL_OW 344
27096: END
// every 0 0$1 trigger StreamModeActive and sSun do
27097: LD_EXP 63
27101: PUSH
27102: LD_EXP 86
27106: AND
27107: IFFALSE 27135
27109: GO 27111
27111: DISABLE
// begin solar_recharge_percent := 0 ;
27112: LD_ADDR_OWVAR 79
27116: PUSH
27117: LD_INT 0
27119: ST_TO_ADDR
// wait ( 5 5$00 ) ;
27120: LD_INT 10500
27122: PPUSH
27123: CALL_OW 67
// solar_recharge_percent := 100 ;
27127: LD_ADDR_OWVAR 79
27131: PUSH
27132: LD_INT 100
27134: ST_TO_ADDR
// end ;
27135: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
27136: LD_EXP 63
27140: PUSH
27141: LD_EXP 87
27145: AND
27146: IFFALSE 27385
27148: GO 27150
27150: DISABLE
27151: LD_INT 0
27153: PPUSH
27154: PPUSH
27155: PPUSH
// begin tmp := [ ] ;
27156: LD_ADDR_VAR 0 3
27160: PUSH
27161: EMPTY
27162: ST_TO_ADDR
// for i := 1 to 6 do
27163: LD_ADDR_VAR 0 1
27167: PUSH
27168: DOUBLE
27169: LD_INT 1
27171: DEC
27172: ST_TO_ADDR
27173: LD_INT 6
27175: PUSH
27176: FOR_TO
27177: IFFALSE 27282
// begin uc_nation := nation_nature ;
27179: LD_ADDR_OWVAR 21
27183: PUSH
27184: LD_INT 0
27186: ST_TO_ADDR
// uc_side := 0 ;
27187: LD_ADDR_OWVAR 20
27191: PUSH
27192: LD_INT 0
27194: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
27195: LD_ADDR_OWVAR 29
27199: PUSH
27200: LD_INT 12
27202: PUSH
27203: LD_INT 12
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: ST_TO_ADDR
// hc_agressivity := 20 ;
27210: LD_ADDR_OWVAR 35
27214: PUSH
27215: LD_INT 20
27217: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
27218: LD_ADDR_OWVAR 28
27222: PUSH
27223: LD_INT 17
27225: ST_TO_ADDR
// hc_gallery :=  ;
27226: LD_ADDR_OWVAR 33
27230: PUSH
27231: LD_STRING 
27233: ST_TO_ADDR
// hc_name :=  ;
27234: LD_ADDR_OWVAR 26
27238: PUSH
27239: LD_STRING 
27241: ST_TO_ADDR
// un := CreateHuman ;
27242: LD_ADDR_VAR 0 2
27246: PUSH
27247: CALL_OW 44
27251: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
27252: LD_VAR 0 2
27256: PPUSH
27257: LD_INT 1
27259: PPUSH
27260: CALL_OW 51
// tmp := tmp ^ un ;
27264: LD_ADDR_VAR 0 3
27268: PUSH
27269: LD_VAR 0 3
27273: PUSH
27274: LD_VAR 0 2
27278: ADD
27279: ST_TO_ADDR
// end ;
27280: GO 27176
27282: POP
27283: POP
// repeat wait ( 0 0$1 ) ;
27284: LD_INT 35
27286: PPUSH
27287: CALL_OW 67
// for un in tmp do
27291: LD_ADDR_VAR 0 2
27295: PUSH
27296: LD_VAR 0 3
27300: PUSH
27301: FOR_IN
27302: IFFALSE 27376
// begin if IsDead ( un ) then
27304: LD_VAR 0 2
27308: PPUSH
27309: CALL_OW 301
27313: IFFALSE 27333
// begin tmp := tmp diff un ;
27315: LD_ADDR_VAR 0 3
27319: PUSH
27320: LD_VAR 0 3
27324: PUSH
27325: LD_VAR 0 2
27329: DIFF
27330: ST_TO_ADDR
// continue ;
27331: GO 27301
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
27333: LD_VAR 0 2
27337: PPUSH
27338: LD_INT 3
27340: PUSH
27341: LD_INT 22
27343: PUSH
27344: LD_INT 0
27346: PUSH
27347: EMPTY
27348: LIST
27349: LIST
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PPUSH
27355: CALL_OW 69
27359: PPUSH
27360: LD_VAR 0 2
27364: PPUSH
27365: CALL_OW 74
27369: PPUSH
27370: CALL_OW 115
// end ;
27374: GO 27301
27376: POP
27377: POP
// until not tmp ;
27378: LD_VAR 0 3
27382: NOT
27383: IFFALSE 27284
// end ;
27385: PPOPN 3
27387: END
// every 0 0$1 trigger StreamModeActive and sTroll do
27388: LD_EXP 63
27392: PUSH
27393: LD_EXP 88
27397: AND
27398: IFFALSE 27452
27400: GO 27402
27402: DISABLE
// begin ToLua ( displayTroll(); ) ;
27403: LD_STRING displayTroll();
27405: PPUSH
27406: CALL_OW 559
// wait ( 3 3$00 ) ;
27410: LD_INT 6300
27412: PPUSH
27413: CALL_OW 67
// ToLua ( hideTroll(); ) ;
27417: LD_STRING hideTroll();
27419: PPUSH
27420: CALL_OW 559
// wait ( 1 1$00 ) ;
27424: LD_INT 2100
27426: PPUSH
27427: CALL_OW 67
// ToLua ( displayTroll(); ) ;
27431: LD_STRING displayTroll();
27433: PPUSH
27434: CALL_OW 559
// wait ( 1 1$00 ) ;
27438: LD_INT 2100
27440: PPUSH
27441: CALL_OW 67
// ToLua ( hideTroll(); ) ;
27445: LD_STRING hideTroll();
27447: PPUSH
27448: CALL_OW 559
// end ;
27452: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
27453: LD_EXP 63
27457: PUSH
27458: LD_EXP 89
27462: AND
27463: IFFALSE 27526
27465: GO 27467
27467: DISABLE
27468: LD_INT 0
27470: PPUSH
// begin p := 0 ;
27471: LD_ADDR_VAR 0 1
27475: PUSH
27476: LD_INT 0
27478: ST_TO_ADDR
// repeat game_speed := 1 ;
27479: LD_ADDR_OWVAR 65
27483: PUSH
27484: LD_INT 1
27486: ST_TO_ADDR
// wait ( 0 0$1 ) ;
27487: LD_INT 35
27489: PPUSH
27490: CALL_OW 67
// p := p + 1 ;
27494: LD_ADDR_VAR 0 1
27498: PUSH
27499: LD_VAR 0 1
27503: PUSH
27504: LD_INT 1
27506: PLUS
27507: ST_TO_ADDR
// until p >= 60 ;
27508: LD_VAR 0 1
27512: PUSH
27513: LD_INT 60
27515: GREATEREQUAL
27516: IFFALSE 27479
// game_speed := 4 ;
27518: LD_ADDR_OWVAR 65
27522: PUSH
27523: LD_INT 4
27525: ST_TO_ADDR
// end ;
27526: PPOPN 1
27528: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
27529: LD_EXP 63
27533: PUSH
27534: LD_EXP 90
27538: AND
27539: IFFALSE 27685
27541: GO 27543
27543: DISABLE
27544: LD_INT 0
27546: PPUSH
27547: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27548: LD_ADDR_VAR 0 1
27552: PUSH
27553: LD_INT 22
27555: PUSH
27556: LD_OWVAR 2
27560: PUSH
27561: EMPTY
27562: LIST
27563: LIST
27564: PUSH
27565: LD_INT 2
27567: PUSH
27568: LD_INT 30
27570: PUSH
27571: LD_INT 0
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: LD_INT 30
27580: PUSH
27581: LD_INT 1
27583: PUSH
27584: EMPTY
27585: LIST
27586: LIST
27587: PUSH
27588: EMPTY
27589: LIST
27590: LIST
27591: LIST
27592: PUSH
27593: EMPTY
27594: LIST
27595: LIST
27596: PPUSH
27597: CALL_OW 69
27601: ST_TO_ADDR
// if not depot then
27602: LD_VAR 0 1
27606: NOT
27607: IFFALSE 27611
// exit ;
27609: GO 27685
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
27611: LD_ADDR_VAR 0 2
27615: PUSH
27616: LD_VAR 0 1
27620: PUSH
27621: LD_INT 1
27623: PPUSH
27624: LD_VAR 0 1
27628: PPUSH
27629: CALL_OW 12
27633: ARRAY
27634: PPUSH
27635: CALL_OW 274
27639: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
27640: LD_VAR 0 2
27644: PPUSH
27645: LD_INT 1
27647: PPUSH
27648: LD_INT 0
27650: PPUSH
27651: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
27655: LD_VAR 0 2
27659: PPUSH
27660: LD_INT 2
27662: PPUSH
27663: LD_INT 0
27665: PPUSH
27666: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
27670: LD_VAR 0 2
27674: PPUSH
27675: LD_INT 3
27677: PPUSH
27678: LD_INT 0
27680: PPUSH
27681: CALL_OW 277
// end ;
27685: PPOPN 2
27687: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
27688: LD_EXP 63
27692: PUSH
27693: LD_EXP 91
27697: AND
27698: IFFALSE 27795
27700: GO 27702
27702: DISABLE
27703: LD_INT 0
27705: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
27706: LD_ADDR_VAR 0 1
27710: PUSH
27711: LD_INT 22
27713: PUSH
27714: LD_OWVAR 2
27718: PUSH
27719: EMPTY
27720: LIST
27721: LIST
27722: PUSH
27723: LD_INT 21
27725: PUSH
27726: LD_INT 1
27728: PUSH
27729: EMPTY
27730: LIST
27731: LIST
27732: PUSH
27733: LD_INT 3
27735: PUSH
27736: LD_INT 23
27738: PUSH
27739: LD_INT 0
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: PUSH
27750: EMPTY
27751: LIST
27752: LIST
27753: LIST
27754: PPUSH
27755: CALL_OW 69
27759: ST_TO_ADDR
// if not tmp then
27760: LD_VAR 0 1
27764: NOT
27765: IFFALSE 27769
// exit ;
27767: GO 27795
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
27769: LD_VAR 0 1
27773: PUSH
27774: LD_INT 1
27776: PPUSH
27777: LD_VAR 0 1
27781: PPUSH
27782: CALL_OW 12
27786: ARRAY
27787: PPUSH
27788: LD_INT 200
27790: PPUSH
27791: CALL_OW 234
// end ;
27795: PPOPN 1
27797: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
27798: LD_EXP 63
27802: PUSH
27803: LD_EXP 92
27807: AND
27808: IFFALSE 27887
27810: GO 27812
27812: DISABLE
27813: LD_INT 0
27815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
27816: LD_ADDR_VAR 0 1
27820: PUSH
27821: LD_INT 22
27823: PUSH
27824: LD_OWVAR 2
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PUSH
27833: LD_INT 21
27835: PUSH
27836: LD_INT 2
27838: PUSH
27839: EMPTY
27840: LIST
27841: LIST
27842: PUSH
27843: EMPTY
27844: LIST
27845: LIST
27846: PPUSH
27847: CALL_OW 69
27851: ST_TO_ADDR
// if not tmp then
27852: LD_VAR 0 1
27856: NOT
27857: IFFALSE 27861
// exit ;
27859: GO 27887
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
27861: LD_VAR 0 1
27865: PUSH
27866: LD_INT 1
27868: PPUSH
27869: LD_VAR 0 1
27873: PPUSH
27874: CALL_OW 12
27878: ARRAY
27879: PPUSH
27880: LD_INT 60
27882: PPUSH
27883: CALL_OW 234
// end ;
27887: PPOPN 1
27889: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
27890: LD_EXP 63
27894: PUSH
27895: LD_EXP 93
27899: AND
27900: IFFALSE 27999
27902: GO 27904
27904: DISABLE
27905: LD_INT 0
27907: PPUSH
27908: PPUSH
// begin enable ;
27909: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
27910: LD_ADDR_VAR 0 1
27914: PUSH
27915: LD_INT 22
27917: PUSH
27918: LD_OWVAR 2
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 61
27929: PUSH
27930: EMPTY
27931: LIST
27932: PUSH
27933: LD_INT 33
27935: PUSH
27936: LD_INT 2
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: PUSH
27943: EMPTY
27944: LIST
27945: LIST
27946: LIST
27947: PPUSH
27948: CALL_OW 69
27952: ST_TO_ADDR
// if not tmp then
27953: LD_VAR 0 1
27957: NOT
27958: IFFALSE 27962
// exit ;
27960: GO 27999
// for i in tmp do
27962: LD_ADDR_VAR 0 2
27966: PUSH
27967: LD_VAR 0 1
27971: PUSH
27972: FOR_IN
27973: IFFALSE 27997
// if IsControledBy ( i ) then
27975: LD_VAR 0 2
27979: PPUSH
27980: CALL_OW 312
27984: IFFALSE 27995
// ComUnlink ( i ) ;
27986: LD_VAR 0 2
27990: PPUSH
27991: CALL_OW 136
27995: GO 27972
27997: POP
27998: POP
// end ;
27999: PPOPN 2
28001: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
28002: LD_EXP 63
28006: PUSH
28007: LD_EXP 94
28011: AND
28012: IFFALSE 28152
28014: GO 28016
28016: DISABLE
28017: LD_INT 0
28019: PPUSH
28020: PPUSH
// begin ToLua ( displayPowell(); ) ;
28021: LD_STRING displayPowell();
28023: PPUSH
28024: CALL_OW 559
// uc_side := 0 ;
28028: LD_ADDR_OWVAR 20
28032: PUSH
28033: LD_INT 0
28035: ST_TO_ADDR
// uc_nation := 2 ;
28036: LD_ADDR_OWVAR 21
28040: PUSH
28041: LD_INT 2
28043: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
28044: LD_ADDR_OWVAR 37
28048: PUSH
28049: LD_INT 14
28051: ST_TO_ADDR
// vc_engine := engine_siberite ;
28052: LD_ADDR_OWVAR 39
28056: PUSH
28057: LD_INT 3
28059: ST_TO_ADDR
// vc_control := control_apeman ;
28060: LD_ADDR_OWVAR 38
28064: PUSH
28065: LD_INT 5
28067: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
28068: LD_ADDR_OWVAR 40
28072: PUSH
28073: LD_INT 29
28075: ST_TO_ADDR
// un := CreateVehicle ;
28076: LD_ADDR_VAR 0 2
28080: PUSH
28081: CALL_OW 45
28085: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28086: LD_VAR 0 2
28090: PPUSH
28091: LD_INT 1
28093: PPUSH
28094: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
28098: LD_INT 35
28100: PPUSH
28101: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
28105: LD_VAR 0 2
28109: PPUSH
28110: LD_INT 22
28112: PUSH
28113: LD_OWVAR 2
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PPUSH
28122: CALL_OW 69
28126: PPUSH
28127: LD_VAR 0 2
28131: PPUSH
28132: CALL_OW 74
28136: PPUSH
28137: CALL_OW 115
// until IsDead ( un ) ;
28141: LD_VAR 0 2
28145: PPUSH
28146: CALL_OW 301
28150: IFFALSE 28098
// end ;
28152: PPOPN 2
28154: END
// every 0 0$1 trigger StreamModeActive and sStu do
28155: LD_EXP 63
28159: PUSH
28160: LD_EXP 102
28164: AND
28165: IFFALSE 28181
28167: GO 28169
28169: DISABLE
// begin ToLua ( displayStucuk(); ) ;
28170: LD_STRING displayStucuk();
28172: PPUSH
28173: CALL_OW 559
// ResetFog ;
28177: CALL_OW 335
// end ;
28181: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
28182: LD_EXP 63
28186: PUSH
28187: LD_EXP 95
28191: AND
28192: IFFALSE 28333
28194: GO 28196
28196: DISABLE
28197: LD_INT 0
28199: PPUSH
28200: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
28201: LD_ADDR_VAR 0 2
28205: PUSH
28206: LD_INT 22
28208: PUSH
28209: LD_OWVAR 2
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 21
28220: PUSH
28221: LD_INT 1
28223: PUSH
28224: EMPTY
28225: LIST
28226: LIST
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PPUSH
28232: CALL_OW 69
28236: ST_TO_ADDR
// if not tmp then
28237: LD_VAR 0 2
28241: NOT
28242: IFFALSE 28246
// exit ;
28244: GO 28333
// un := tmp [ rand ( 1 , tmp ) ] ;
28246: LD_ADDR_VAR 0 1
28250: PUSH
28251: LD_VAR 0 2
28255: PUSH
28256: LD_INT 1
28258: PPUSH
28259: LD_VAR 0 2
28263: PPUSH
28264: CALL_OW 12
28268: ARRAY
28269: ST_TO_ADDR
// SetSide ( un , 0 ) ;
28270: LD_VAR 0 1
28274: PPUSH
28275: LD_INT 0
28277: PPUSH
28278: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
28282: LD_VAR 0 1
28286: PPUSH
28287: LD_OWVAR 3
28291: PUSH
28292: LD_VAR 0 1
28296: DIFF
28297: PPUSH
28298: LD_VAR 0 1
28302: PPUSH
28303: CALL_OW 74
28307: PPUSH
28308: CALL_OW 115
// wait ( 0 0$20 ) ;
28312: LD_INT 700
28314: PPUSH
28315: CALL_OW 67
// SetSide ( un , your_side ) ;
28319: LD_VAR 0 1
28323: PPUSH
28324: LD_OWVAR 2
28328: PPUSH
28329: CALL_OW 235
// end ;
28333: PPOPN 2
28335: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
28336: LD_EXP 63
28340: PUSH
28341: LD_EXP 96
28345: AND
28346: IFFALSE 28452
28348: GO 28350
28350: DISABLE
28351: LD_INT 0
28353: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28354: LD_ADDR_VAR 0 1
28358: PUSH
28359: LD_INT 22
28361: PUSH
28362: LD_OWVAR 2
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PUSH
28371: LD_INT 2
28373: PUSH
28374: LD_INT 30
28376: PUSH
28377: LD_INT 0
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: PUSH
28384: LD_INT 30
28386: PUSH
28387: LD_INT 1
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: EMPTY
28395: LIST
28396: LIST
28397: LIST
28398: PUSH
28399: EMPTY
28400: LIST
28401: LIST
28402: PPUSH
28403: CALL_OW 69
28407: ST_TO_ADDR
// if not depot then
28408: LD_VAR 0 1
28412: NOT
28413: IFFALSE 28417
// exit ;
28415: GO 28452
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
28417: LD_VAR 0 1
28421: PUSH
28422: LD_INT 1
28424: ARRAY
28425: PPUSH
28426: CALL_OW 250
28430: PPUSH
28431: LD_VAR 0 1
28435: PUSH
28436: LD_INT 1
28438: ARRAY
28439: PPUSH
28440: CALL_OW 251
28444: PPUSH
28445: LD_INT 70
28447: PPUSH
28448: CALL_OW 495
// end ;
28452: PPOPN 1
28454: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
28455: LD_EXP 63
28459: PUSH
28460: LD_EXP 97
28464: AND
28465: IFFALSE 28676
28467: GO 28469
28469: DISABLE
28470: LD_INT 0
28472: PPUSH
28473: PPUSH
28474: PPUSH
28475: PPUSH
28476: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
28477: LD_ADDR_VAR 0 5
28481: PUSH
28482: LD_INT 22
28484: PUSH
28485: LD_OWVAR 2
28489: PUSH
28490: EMPTY
28491: LIST
28492: LIST
28493: PUSH
28494: LD_INT 21
28496: PUSH
28497: LD_INT 1
28499: PUSH
28500: EMPTY
28501: LIST
28502: LIST
28503: PUSH
28504: EMPTY
28505: LIST
28506: LIST
28507: PPUSH
28508: CALL_OW 69
28512: ST_TO_ADDR
// if not tmp then
28513: LD_VAR 0 5
28517: NOT
28518: IFFALSE 28522
// exit ;
28520: GO 28676
// for i in tmp do
28522: LD_ADDR_VAR 0 1
28526: PUSH
28527: LD_VAR 0 5
28531: PUSH
28532: FOR_IN
28533: IFFALSE 28674
// begin d := rand ( 0 , 5 ) ;
28535: LD_ADDR_VAR 0 4
28539: PUSH
28540: LD_INT 0
28542: PPUSH
28543: LD_INT 5
28545: PPUSH
28546: CALL_OW 12
28550: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
28551: LD_ADDR_VAR 0 2
28555: PUSH
28556: LD_VAR 0 1
28560: PPUSH
28561: CALL_OW 250
28565: PPUSH
28566: LD_VAR 0 4
28570: PPUSH
28571: LD_INT 3
28573: PPUSH
28574: LD_INT 12
28576: PPUSH
28577: CALL_OW 12
28581: PPUSH
28582: CALL_OW 272
28586: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
28587: LD_ADDR_VAR 0 3
28591: PUSH
28592: LD_VAR 0 1
28596: PPUSH
28597: CALL_OW 251
28601: PPUSH
28602: LD_VAR 0 4
28606: PPUSH
28607: LD_INT 3
28609: PPUSH
28610: LD_INT 12
28612: PPUSH
28613: CALL_OW 12
28617: PPUSH
28618: CALL_OW 273
28622: ST_TO_ADDR
// if ValidHex ( x , y ) then
28623: LD_VAR 0 2
28627: PPUSH
28628: LD_VAR 0 3
28632: PPUSH
28633: CALL_OW 488
28637: IFFALSE 28672
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
28639: LD_VAR 0 1
28643: PPUSH
28644: LD_VAR 0 2
28648: PPUSH
28649: LD_VAR 0 3
28653: PPUSH
28654: LD_INT 3
28656: PPUSH
28657: LD_INT 6
28659: PPUSH
28660: CALL_OW 12
28664: PPUSH
28665: LD_INT 1
28667: PPUSH
28668: CALL_OW 483
// end ;
28672: GO 28532
28674: POP
28675: POP
// end ;
28676: PPOPN 5
28678: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
28679: LD_EXP 63
28683: PUSH
28684: LD_EXP 98
28688: AND
28689: IFFALSE 28783
28691: GO 28693
28693: DISABLE
28694: LD_INT 0
28696: PPUSH
28697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
28698: LD_ADDR_VAR 0 2
28702: PUSH
28703: LD_INT 22
28705: PUSH
28706: LD_OWVAR 2
28710: PUSH
28711: EMPTY
28712: LIST
28713: LIST
28714: PUSH
28715: LD_INT 32
28717: PUSH
28718: LD_INT 1
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 21
28727: PUSH
28728: LD_INT 2
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: LIST
28739: PPUSH
28740: CALL_OW 69
28744: ST_TO_ADDR
// if not tmp then
28745: LD_VAR 0 2
28749: NOT
28750: IFFALSE 28754
// exit ;
28752: GO 28783
// for i in tmp do
28754: LD_ADDR_VAR 0 1
28758: PUSH
28759: LD_VAR 0 2
28763: PUSH
28764: FOR_IN
28765: IFFALSE 28781
// SetFuel ( i , 0 ) ;
28767: LD_VAR 0 1
28771: PPUSH
28772: LD_INT 0
28774: PPUSH
28775: CALL_OW 240
28779: GO 28764
28781: POP
28782: POP
// end ;
28783: PPOPN 2
28785: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
28786: LD_EXP 63
28790: PUSH
28791: LD_EXP 99
28795: AND
28796: IFFALSE 28862
28798: GO 28800
28800: DISABLE
28801: LD_INT 0
28803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28804: LD_ADDR_VAR 0 1
28808: PUSH
28809: LD_INT 22
28811: PUSH
28812: LD_OWVAR 2
28816: PUSH
28817: EMPTY
28818: LIST
28819: LIST
28820: PUSH
28821: LD_INT 30
28823: PUSH
28824: LD_INT 29
28826: PUSH
28827: EMPTY
28828: LIST
28829: LIST
28830: PUSH
28831: EMPTY
28832: LIST
28833: LIST
28834: PPUSH
28835: CALL_OW 69
28839: ST_TO_ADDR
// if not tmp then
28840: LD_VAR 0 1
28844: NOT
28845: IFFALSE 28849
// exit ;
28847: GO 28862
// DestroyUnit ( tmp [ 1 ] ) ;
28849: LD_VAR 0 1
28853: PUSH
28854: LD_INT 1
28856: ARRAY
28857: PPUSH
28858: CALL_OW 65
// end ;
28862: PPOPN 1
28864: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
28865: LD_EXP 63
28869: PUSH
28870: LD_EXP 101
28874: AND
28875: IFFALSE 29004
28877: GO 28879
28879: DISABLE
28880: LD_INT 0
28882: PPUSH
// begin uc_side := 0 ;
28883: LD_ADDR_OWVAR 20
28887: PUSH
28888: LD_INT 0
28890: ST_TO_ADDR
// uc_nation := nation_arabian ;
28891: LD_ADDR_OWVAR 21
28895: PUSH
28896: LD_INT 2
28898: ST_TO_ADDR
// hc_gallery :=  ;
28899: LD_ADDR_OWVAR 33
28903: PUSH
28904: LD_STRING 
28906: ST_TO_ADDR
// hc_name :=  ;
28907: LD_ADDR_OWVAR 26
28911: PUSH
28912: LD_STRING 
28914: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
28915: LD_INT 1
28917: PPUSH
28918: LD_INT 11
28920: PPUSH
28921: LD_INT 10
28923: PPUSH
28924: CALL_OW 380
// un := CreateHuman ;
28928: LD_ADDR_VAR 0 1
28932: PUSH
28933: CALL_OW 44
28937: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28938: LD_VAR 0 1
28942: PPUSH
28943: LD_INT 1
28945: PPUSH
28946: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
28950: LD_INT 35
28952: PPUSH
28953: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
28957: LD_VAR 0 1
28961: PPUSH
28962: LD_INT 22
28964: PUSH
28965: LD_OWVAR 2
28969: PUSH
28970: EMPTY
28971: LIST
28972: LIST
28973: PPUSH
28974: CALL_OW 69
28978: PPUSH
28979: LD_VAR 0 1
28983: PPUSH
28984: CALL_OW 74
28988: PPUSH
28989: CALL_OW 115
// until IsDead ( un ) ;
28993: LD_VAR 0 1
28997: PPUSH
28998: CALL_OW 301
29002: IFFALSE 28950
// end ;
29004: PPOPN 1
29006: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
29007: LD_EXP 63
29011: PUSH
29012: LD_EXP 103
29016: AND
29017: IFFALSE 29029
29019: GO 29021
29021: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
29022: LD_STRING earthquake(getX(game), 0, 32)
29024: PPUSH
29025: CALL_OW 559
29029: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
29030: LD_EXP 63
29034: PUSH
29035: LD_EXP 104
29039: AND
29040: IFFALSE 29131
29042: GO 29044
29044: DISABLE
29045: LD_INT 0
29047: PPUSH
// begin enable ;
29048: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
29049: LD_ADDR_VAR 0 1
29053: PUSH
29054: LD_INT 22
29056: PUSH
29057: LD_OWVAR 2
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 21
29068: PUSH
29069: LD_INT 2
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 33
29078: PUSH
29079: LD_INT 3
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: LIST
29090: PPUSH
29091: CALL_OW 69
29095: ST_TO_ADDR
// if not tmp then
29096: LD_VAR 0 1
29100: NOT
29101: IFFALSE 29105
// exit ;
29103: GO 29131
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
29105: LD_VAR 0 1
29109: PUSH
29110: LD_INT 1
29112: PPUSH
29113: LD_VAR 0 1
29117: PPUSH
29118: CALL_OW 12
29122: ARRAY
29123: PPUSH
29124: LD_INT 1
29126: PPUSH
29127: CALL_OW 234
// end ;
29131: PPOPN 1
29133: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
29134: LD_EXP 63
29138: PUSH
29139: LD_EXP 105
29143: AND
29144: IFFALSE 29285
29146: GO 29148
29148: DISABLE
29149: LD_INT 0
29151: PPUSH
29152: PPUSH
29153: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
29154: LD_ADDR_VAR 0 3
29158: PUSH
29159: LD_INT 22
29161: PUSH
29162: LD_OWVAR 2
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PUSH
29171: LD_INT 25
29173: PUSH
29174: LD_INT 1
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PPUSH
29185: CALL_OW 69
29189: ST_TO_ADDR
// if not tmp then
29190: LD_VAR 0 3
29194: NOT
29195: IFFALSE 29199
// exit ;
29197: GO 29285
// un := tmp [ rand ( 1 , tmp ) ] ;
29199: LD_ADDR_VAR 0 2
29203: PUSH
29204: LD_VAR 0 3
29208: PUSH
29209: LD_INT 1
29211: PPUSH
29212: LD_VAR 0 3
29216: PPUSH
29217: CALL_OW 12
29221: ARRAY
29222: ST_TO_ADDR
// if Crawls ( un ) then
29223: LD_VAR 0 2
29227: PPUSH
29228: CALL_OW 318
29232: IFFALSE 29243
// ComWalk ( un ) ;
29234: LD_VAR 0 2
29238: PPUSH
29239: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
29243: LD_VAR 0 2
29247: PPUSH
29248: LD_INT 9
29250: PPUSH
29251: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
29255: LD_INT 28
29257: PPUSH
29258: LD_OWVAR 2
29262: PPUSH
29263: LD_INT 2
29265: PPUSH
29266: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
29270: LD_INT 29
29272: PPUSH
29273: LD_OWVAR 2
29277: PPUSH
29278: LD_INT 2
29280: PPUSH
29281: CALL_OW 322
// end ;
29285: PPOPN 3
29287: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
29288: LD_EXP 63
29292: PUSH
29293: LD_EXP 106
29297: AND
29298: IFFALSE 29409
29300: GO 29302
29302: DISABLE
29303: LD_INT 0
29305: PPUSH
29306: PPUSH
29307: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
29308: LD_ADDR_VAR 0 3
29312: PUSH
29313: LD_INT 22
29315: PUSH
29316: LD_OWVAR 2
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 25
29327: PUSH
29328: LD_INT 1
29330: PUSH
29331: EMPTY
29332: LIST
29333: LIST
29334: PUSH
29335: EMPTY
29336: LIST
29337: LIST
29338: PPUSH
29339: CALL_OW 69
29343: ST_TO_ADDR
// if not tmp then
29344: LD_VAR 0 3
29348: NOT
29349: IFFALSE 29353
// exit ;
29351: GO 29409
// un := tmp [ rand ( 1 , tmp ) ] ;
29353: LD_ADDR_VAR 0 2
29357: PUSH
29358: LD_VAR 0 3
29362: PUSH
29363: LD_INT 1
29365: PPUSH
29366: LD_VAR 0 3
29370: PPUSH
29371: CALL_OW 12
29375: ARRAY
29376: ST_TO_ADDR
// if Crawls ( un ) then
29377: LD_VAR 0 2
29381: PPUSH
29382: CALL_OW 318
29386: IFFALSE 29397
// ComWalk ( un ) ;
29388: LD_VAR 0 2
29392: PPUSH
29393: CALL_OW 138
// SetClass ( un , class_mortar ) ;
29397: LD_VAR 0 2
29401: PPUSH
29402: LD_INT 8
29404: PPUSH
29405: CALL_OW 336
// end ;
29409: PPOPN 3
29411: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
29412: LD_EXP 63
29416: PUSH
29417: LD_EXP 107
29421: AND
29422: IFFALSE 29566
29424: GO 29426
29426: DISABLE
29427: LD_INT 0
29429: PPUSH
29430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
29431: LD_ADDR_VAR 0 2
29435: PUSH
29436: LD_INT 22
29438: PUSH
29439: LD_OWVAR 2
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: LD_INT 21
29450: PUSH
29451: LD_INT 2
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 2
29460: PUSH
29461: LD_INT 34
29463: PUSH
29464: LD_INT 12
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 34
29473: PUSH
29474: LD_INT 51
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 34
29483: PUSH
29484: LD_INT 32
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: LIST
29501: PPUSH
29502: CALL_OW 69
29506: ST_TO_ADDR
// if not tmp then
29507: LD_VAR 0 2
29511: NOT
29512: IFFALSE 29516
// exit ;
29514: GO 29566
// for i in tmp do
29516: LD_ADDR_VAR 0 1
29520: PUSH
29521: LD_VAR 0 2
29525: PUSH
29526: FOR_IN
29527: IFFALSE 29564
// if GetCargo ( i , mat_artifact ) = 0 then
29529: LD_VAR 0 1
29533: PPUSH
29534: LD_INT 4
29536: PPUSH
29537: CALL_OW 289
29541: PUSH
29542: LD_INT 0
29544: EQUAL
29545: IFFALSE 29562
// SetCargo ( i , mat_siberit , 100 ) ;
29547: LD_VAR 0 1
29551: PPUSH
29552: LD_INT 3
29554: PPUSH
29555: LD_INT 100
29557: PPUSH
29558: CALL_OW 290
29562: GO 29526
29564: POP
29565: POP
// end ;
29566: PPOPN 2
29568: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
29569: LD_EXP 63
29573: PUSH
29574: LD_EXP 108
29578: AND
29579: IFFALSE 29762
29581: GO 29583
29583: DISABLE
29584: LD_INT 0
29586: PPUSH
29587: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
29588: LD_ADDR_VAR 0 2
29592: PUSH
29593: LD_INT 22
29595: PUSH
29596: LD_OWVAR 2
29600: PUSH
29601: EMPTY
29602: LIST
29603: LIST
29604: PPUSH
29605: CALL_OW 69
29609: ST_TO_ADDR
// if not tmp then
29610: LD_VAR 0 2
29614: NOT
29615: IFFALSE 29619
// exit ;
29617: GO 29762
// for i := 1 to 2 do
29619: LD_ADDR_VAR 0 1
29623: PUSH
29624: DOUBLE
29625: LD_INT 1
29627: DEC
29628: ST_TO_ADDR
29629: LD_INT 2
29631: PUSH
29632: FOR_TO
29633: IFFALSE 29760
// begin uc_side := your_side ;
29635: LD_ADDR_OWVAR 20
29639: PUSH
29640: LD_OWVAR 2
29644: ST_TO_ADDR
// uc_nation := nation_american ;
29645: LD_ADDR_OWVAR 21
29649: PUSH
29650: LD_INT 1
29652: ST_TO_ADDR
// vc_chassis := us_morphling ;
29653: LD_ADDR_OWVAR 37
29657: PUSH
29658: LD_INT 5
29660: ST_TO_ADDR
// vc_engine := engine_siberite ;
29661: LD_ADDR_OWVAR 39
29665: PUSH
29666: LD_INT 3
29668: ST_TO_ADDR
// vc_control := control_computer ;
29669: LD_ADDR_OWVAR 38
29673: PUSH
29674: LD_INT 3
29676: ST_TO_ADDR
// vc_weapon := us_double_laser ;
29677: LD_ADDR_OWVAR 40
29681: PUSH
29682: LD_INT 10
29684: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
29685: LD_VAR 0 2
29689: PUSH
29690: LD_INT 1
29692: ARRAY
29693: PPUSH
29694: CALL_OW 310
29698: NOT
29699: IFFALSE 29746
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
29701: CALL_OW 45
29705: PPUSH
29706: LD_VAR 0 2
29710: PUSH
29711: LD_INT 1
29713: ARRAY
29714: PPUSH
29715: CALL_OW 250
29719: PPUSH
29720: LD_VAR 0 2
29724: PUSH
29725: LD_INT 1
29727: ARRAY
29728: PPUSH
29729: CALL_OW 251
29733: PPUSH
29734: LD_INT 12
29736: PPUSH
29737: LD_INT 1
29739: PPUSH
29740: CALL_OW 50
29744: GO 29758
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
29746: CALL_OW 45
29750: PPUSH
29751: LD_INT 1
29753: PPUSH
29754: CALL_OW 51
// end ;
29758: GO 29632
29760: POP
29761: POP
// end ;
29762: PPOPN 2
29764: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
29765: LD_EXP 63
29769: PUSH
29770: LD_EXP 109
29774: AND
29775: IFFALSE 29997
29777: GO 29779
29779: DISABLE
29780: LD_INT 0
29782: PPUSH
29783: PPUSH
29784: PPUSH
29785: PPUSH
29786: PPUSH
29787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29788: LD_ADDR_VAR 0 6
29792: PUSH
29793: LD_INT 22
29795: PUSH
29796: LD_OWVAR 2
29800: PUSH
29801: EMPTY
29802: LIST
29803: LIST
29804: PUSH
29805: LD_INT 21
29807: PUSH
29808: LD_INT 1
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 3
29817: PUSH
29818: LD_INT 23
29820: PUSH
29821: LD_INT 0
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: LIST
29836: PPUSH
29837: CALL_OW 69
29841: ST_TO_ADDR
// if not tmp then
29842: LD_VAR 0 6
29846: NOT
29847: IFFALSE 29851
// exit ;
29849: GO 29997
// s1 := rand ( 1 , 4 ) ;
29851: LD_ADDR_VAR 0 2
29855: PUSH
29856: LD_INT 1
29858: PPUSH
29859: LD_INT 4
29861: PPUSH
29862: CALL_OW 12
29866: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
29867: LD_ADDR_VAR 0 4
29871: PUSH
29872: LD_VAR 0 6
29876: PUSH
29877: LD_INT 1
29879: ARRAY
29880: PPUSH
29881: LD_VAR 0 2
29885: PPUSH
29886: CALL_OW 259
29890: ST_TO_ADDR
// if s1 = 1 then
29891: LD_VAR 0 2
29895: PUSH
29896: LD_INT 1
29898: EQUAL
29899: IFFALSE 29919
// s2 := rand ( 2 , 4 ) else
29901: LD_ADDR_VAR 0 3
29905: PUSH
29906: LD_INT 2
29908: PPUSH
29909: LD_INT 4
29911: PPUSH
29912: CALL_OW 12
29916: ST_TO_ADDR
29917: GO 29927
// s2 := 1 ;
29919: LD_ADDR_VAR 0 3
29923: PUSH
29924: LD_INT 1
29926: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
29927: LD_ADDR_VAR 0 5
29931: PUSH
29932: LD_VAR 0 6
29936: PUSH
29937: LD_INT 1
29939: ARRAY
29940: PPUSH
29941: LD_VAR 0 3
29945: PPUSH
29946: CALL_OW 259
29950: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
29951: LD_VAR 0 6
29955: PUSH
29956: LD_INT 1
29958: ARRAY
29959: PPUSH
29960: LD_VAR 0 2
29964: PPUSH
29965: LD_VAR 0 5
29969: PPUSH
29970: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
29974: LD_VAR 0 6
29978: PUSH
29979: LD_INT 1
29981: ARRAY
29982: PPUSH
29983: LD_VAR 0 3
29987: PPUSH
29988: LD_VAR 0 4
29992: PPUSH
29993: CALL_OW 237
// end ;
29997: PPOPN 6
29999: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
30000: LD_EXP 63
30004: PUSH
30005: LD_EXP 110
30009: AND
30010: IFFALSE 30089
30012: GO 30014
30014: DISABLE
30015: LD_INT 0
30017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
30018: LD_ADDR_VAR 0 1
30022: PUSH
30023: LD_INT 22
30025: PUSH
30026: LD_OWVAR 2
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 30
30037: PUSH
30038: LD_INT 3
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: PPUSH
30049: CALL_OW 69
30053: ST_TO_ADDR
// if not tmp then
30054: LD_VAR 0 1
30058: NOT
30059: IFFALSE 30063
// exit ;
30061: GO 30089
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
30063: LD_VAR 0 1
30067: PUSH
30068: LD_INT 1
30070: PPUSH
30071: LD_VAR 0 1
30075: PPUSH
30076: CALL_OW 12
30080: ARRAY
30081: PPUSH
30082: LD_INT 1
30084: PPUSH
30085: CALL_OW 234
// end ;
30089: PPOPN 1
30091: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
30092: LD_EXP 63
30096: PUSH
30097: LD_EXP 111
30101: AND
30102: IFFALSE 30214
30104: GO 30106
30106: DISABLE
30107: LD_INT 0
30109: PPUSH
30110: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
30111: LD_ADDR_VAR 0 2
30115: PUSH
30116: LD_INT 22
30118: PUSH
30119: LD_OWVAR 2
30123: PUSH
30124: EMPTY
30125: LIST
30126: LIST
30127: PUSH
30128: LD_INT 2
30130: PUSH
30131: LD_INT 30
30133: PUSH
30134: LD_INT 27
30136: PUSH
30137: EMPTY
30138: LIST
30139: LIST
30140: PUSH
30141: LD_INT 30
30143: PUSH
30144: LD_INT 26
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: PUSH
30151: LD_INT 30
30153: PUSH
30154: LD_INT 28
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: PUSH
30161: EMPTY
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PPUSH
30171: CALL_OW 69
30175: ST_TO_ADDR
// if not tmp then
30176: LD_VAR 0 2
30180: NOT
30181: IFFALSE 30185
// exit ;
30183: GO 30214
// for i in tmp do
30185: LD_ADDR_VAR 0 1
30189: PUSH
30190: LD_VAR 0 2
30194: PUSH
30195: FOR_IN
30196: IFFALSE 30212
// SetLives ( i , 1 ) ;
30198: LD_VAR 0 1
30202: PPUSH
30203: LD_INT 1
30205: PPUSH
30206: CALL_OW 234
30210: GO 30195
30212: POP
30213: POP
// end ;
30214: PPOPN 2
30216: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
30217: LD_EXP 63
30221: PUSH
30222: LD_EXP 112
30226: AND
30227: IFFALSE 30501
30229: GO 30231
30231: DISABLE
30232: LD_INT 0
30234: PPUSH
30235: PPUSH
30236: PPUSH
// begin i := rand ( 1 , 7 ) ;
30237: LD_ADDR_VAR 0 1
30241: PUSH
30242: LD_INT 1
30244: PPUSH
30245: LD_INT 7
30247: PPUSH
30248: CALL_OW 12
30252: ST_TO_ADDR
// case i of 1 :
30253: LD_VAR 0 1
30257: PUSH
30258: LD_INT 1
30260: DOUBLE
30261: EQUAL
30262: IFTRUE 30266
30264: GO 30276
30266: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
30267: LD_STRING earthquake(getX(game), 0, 32)
30269: PPUSH
30270: CALL_OW 559
30274: GO 30501
30276: LD_INT 2
30278: DOUBLE
30279: EQUAL
30280: IFTRUE 30284
30282: GO 30298
30284: POP
// begin ToLua ( displayStucuk(); ) ;
30285: LD_STRING displayStucuk();
30287: PPUSH
30288: CALL_OW 559
// ResetFog ;
30292: CALL_OW 335
// end ; 3 :
30296: GO 30501
30298: LD_INT 3
30300: DOUBLE
30301: EQUAL
30302: IFTRUE 30306
30304: GO 30410
30306: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
30307: LD_ADDR_VAR 0 2
30311: PUSH
30312: LD_INT 22
30314: PUSH
30315: LD_OWVAR 2
30319: PUSH
30320: EMPTY
30321: LIST
30322: LIST
30323: PUSH
30324: LD_INT 25
30326: PUSH
30327: LD_INT 1
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: PPUSH
30338: CALL_OW 69
30342: ST_TO_ADDR
// if not tmp then
30343: LD_VAR 0 2
30347: NOT
30348: IFFALSE 30352
// exit ;
30350: GO 30501
// un := tmp [ rand ( 1 , tmp ) ] ;
30352: LD_ADDR_VAR 0 3
30356: PUSH
30357: LD_VAR 0 2
30361: PUSH
30362: LD_INT 1
30364: PPUSH
30365: LD_VAR 0 2
30369: PPUSH
30370: CALL_OW 12
30374: ARRAY
30375: ST_TO_ADDR
// if Crawls ( un ) then
30376: LD_VAR 0 3
30380: PPUSH
30381: CALL_OW 318
30385: IFFALSE 30396
// ComWalk ( un ) ;
30387: LD_VAR 0 3
30391: PPUSH
30392: CALL_OW 138
// SetClass ( un , class_mortar ) ;
30396: LD_VAR 0 3
30400: PPUSH
30401: LD_INT 8
30403: PPUSH
30404: CALL_OW 336
// end ; 4 :
30408: GO 30501
30410: LD_INT 4
30412: DOUBLE
30413: EQUAL
30414: IFTRUE 30418
30416: GO 30479
30418: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
30419: LD_ADDR_VAR 0 2
30423: PUSH
30424: LD_INT 22
30426: PUSH
30427: LD_OWVAR 2
30431: PUSH
30432: EMPTY
30433: LIST
30434: LIST
30435: PUSH
30436: LD_INT 30
30438: PUSH
30439: LD_INT 29
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PPUSH
30450: CALL_OW 69
30454: ST_TO_ADDR
// if not tmp then
30455: LD_VAR 0 2
30459: NOT
30460: IFFALSE 30464
// exit ;
30462: GO 30501
// DestroyUnit ( tmp [ 1 ] ) ;
30464: LD_VAR 0 2
30468: PUSH
30469: LD_INT 1
30471: ARRAY
30472: PPUSH
30473: CALL_OW 65
// end ; 5 .. 7 :
30477: GO 30501
30479: LD_INT 5
30481: DOUBLE
30482: GREATEREQUAL
30483: IFFALSE 30491
30485: LD_INT 7
30487: DOUBLE
30488: LESSEQUAL
30489: IFTRUE 30493
30491: GO 30500
30493: POP
// StreamSibBomb ; end ;
30494: CALL 26751 0 0
30498: GO 30501
30500: POP
// end ;
30501: PPOPN 3
30503: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
30504: LD_EXP 63
30508: PUSH
30509: LD_EXP 113
30513: AND
30514: IFFALSE 30670
30516: GO 30518
30518: DISABLE
30519: LD_INT 0
30521: PPUSH
30522: PPUSH
30523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
30524: LD_ADDR_VAR 0 2
30528: PUSH
30529: LD_INT 81
30531: PUSH
30532: LD_OWVAR 2
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 2
30543: PUSH
30544: LD_INT 21
30546: PUSH
30547: LD_INT 1
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 21
30556: PUSH
30557: LD_INT 2
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: LIST
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PPUSH
30573: CALL_OW 69
30577: ST_TO_ADDR
// if not tmp then
30578: LD_VAR 0 2
30582: NOT
30583: IFFALSE 30587
// exit ;
30585: GO 30670
// p := 0 ;
30587: LD_ADDR_VAR 0 3
30591: PUSH
30592: LD_INT 0
30594: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30595: LD_INT 35
30597: PPUSH
30598: CALL_OW 67
// p := p + 1 ;
30602: LD_ADDR_VAR 0 3
30606: PUSH
30607: LD_VAR 0 3
30611: PUSH
30612: LD_INT 1
30614: PLUS
30615: ST_TO_ADDR
// for i in tmp do
30616: LD_ADDR_VAR 0 1
30620: PUSH
30621: LD_VAR 0 2
30625: PUSH
30626: FOR_IN
30627: IFFALSE 30658
// if GetLives ( i ) < 1000 then
30629: LD_VAR 0 1
30633: PPUSH
30634: CALL_OW 256
30638: PUSH
30639: LD_INT 1000
30641: LESS
30642: IFFALSE 30656
// SetLives ( i , 1000 ) ;
30644: LD_VAR 0 1
30648: PPUSH
30649: LD_INT 1000
30651: PPUSH
30652: CALL_OW 234
30656: GO 30626
30658: POP
30659: POP
// until p > 20 ;
30660: LD_VAR 0 3
30664: PUSH
30665: LD_INT 20
30667: GREATER
30668: IFFALSE 30595
// end ;
30670: PPOPN 3
30672: END
// every 0 0$1 trigger StreamModeActive and sTime do
30673: LD_EXP 63
30677: PUSH
30678: LD_EXP 114
30682: AND
30683: IFFALSE 30718
30685: GO 30687
30687: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
30688: LD_INT 28
30690: PPUSH
30691: LD_OWVAR 2
30695: PPUSH
30696: LD_INT 2
30698: PPUSH
30699: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
30703: LD_INT 30
30705: PPUSH
30706: LD_OWVAR 2
30710: PPUSH
30711: LD_INT 2
30713: PPUSH
30714: CALL_OW 322
// end ;
30718: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
30719: LD_EXP 63
30723: PUSH
30724: LD_EXP 115
30728: AND
30729: IFFALSE 30850
30731: GO 30733
30733: DISABLE
30734: LD_INT 0
30736: PPUSH
30737: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
30738: LD_ADDR_VAR 0 2
30742: PUSH
30743: LD_INT 22
30745: PUSH
30746: LD_OWVAR 2
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 21
30757: PUSH
30758: LD_INT 1
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 3
30767: PUSH
30768: LD_INT 23
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: LIST
30786: PPUSH
30787: CALL_OW 69
30791: ST_TO_ADDR
// if not tmp then
30792: LD_VAR 0 2
30796: NOT
30797: IFFALSE 30801
// exit ;
30799: GO 30850
// for i in tmp do
30801: LD_ADDR_VAR 0 1
30805: PUSH
30806: LD_VAR 0 2
30810: PUSH
30811: FOR_IN
30812: IFFALSE 30848
// begin if Crawls ( i ) then
30814: LD_VAR 0 1
30818: PPUSH
30819: CALL_OW 318
30823: IFFALSE 30834
// ComWalk ( i ) ;
30825: LD_VAR 0 1
30829: PPUSH
30830: CALL_OW 138
// SetClass ( i , 2 ) ;
30834: LD_VAR 0 1
30838: PPUSH
30839: LD_INT 2
30841: PPUSH
30842: CALL_OW 336
// end ;
30846: GO 30811
30848: POP
30849: POP
// end ;
30850: PPOPN 2
30852: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
30853: LD_EXP 63
30857: PUSH
30858: LD_EXP 116
30862: AND
30863: IFFALSE 31144
30865: GO 30867
30867: DISABLE
30868: LD_INT 0
30870: PPUSH
30871: PPUSH
30872: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
30873: LD_OWVAR 2
30877: PPUSH
30878: LD_INT 9
30880: PPUSH
30881: LD_INT 1
30883: PPUSH
30884: LD_INT 1
30886: PPUSH
30887: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
30891: LD_INT 9
30893: PPUSH
30894: LD_OWVAR 2
30898: PPUSH
30899: CALL_OW 343
// uc_side := 9 ;
30903: LD_ADDR_OWVAR 20
30907: PUSH
30908: LD_INT 9
30910: ST_TO_ADDR
// uc_nation := 2 ;
30911: LD_ADDR_OWVAR 21
30915: PUSH
30916: LD_INT 2
30918: ST_TO_ADDR
// hc_name := Dark Warrior ;
30919: LD_ADDR_OWVAR 26
30923: PUSH
30924: LD_STRING Dark Warrior
30926: ST_TO_ADDR
// hc_gallery :=  ;
30927: LD_ADDR_OWVAR 33
30931: PUSH
30932: LD_STRING 
30934: ST_TO_ADDR
// hc_noskilllimit := true ;
30935: LD_ADDR_OWVAR 76
30939: PUSH
30940: LD_INT 1
30942: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
30943: LD_ADDR_OWVAR 31
30947: PUSH
30948: LD_INT 30
30950: PUSH
30951: LD_INT 30
30953: PUSH
30954: LD_INT 30
30956: PUSH
30957: LD_INT 30
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: LIST
30964: LIST
30965: ST_TO_ADDR
// un := CreateHuman ;
30966: LD_ADDR_VAR 0 3
30970: PUSH
30971: CALL_OW 44
30975: ST_TO_ADDR
// hc_noskilllimit := false ;
30976: LD_ADDR_OWVAR 76
30980: PUSH
30981: LD_INT 0
30983: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
30984: LD_VAR 0 3
30988: PPUSH
30989: LD_INT 1
30991: PPUSH
30992: CALL_OW 51
// p := 0 ;
30996: LD_ADDR_VAR 0 2
31000: PUSH
31001: LD_INT 0
31003: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
31004: LD_INT 35
31006: PPUSH
31007: CALL_OW 67
// p := p + 1 ;
31011: LD_ADDR_VAR 0 2
31015: PUSH
31016: LD_VAR 0 2
31020: PUSH
31021: LD_INT 1
31023: PLUS
31024: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
31025: LD_VAR 0 3
31029: PPUSH
31030: CALL_OW 256
31034: PUSH
31035: LD_INT 1000
31037: LESS
31038: IFFALSE 31052
// SetLives ( un , 1000 ) ;
31040: LD_VAR 0 3
31044: PPUSH
31045: LD_INT 1000
31047: PPUSH
31048: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
31052: LD_VAR 0 3
31056: PPUSH
31057: LD_INT 81
31059: PUSH
31060: LD_OWVAR 2
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: PUSH
31069: LD_INT 91
31071: PUSH
31072: LD_VAR 0 3
31076: PUSH
31077: LD_INT 30
31079: PUSH
31080: EMPTY
31081: LIST
31082: LIST
31083: LIST
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PPUSH
31089: CALL_OW 69
31093: PPUSH
31094: LD_VAR 0 3
31098: PPUSH
31099: CALL_OW 74
31103: PPUSH
31104: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
31108: LD_VAR 0 2
31112: PUSH
31113: LD_INT 60
31115: GREATER
31116: PUSH
31117: LD_VAR 0 3
31121: PPUSH
31122: CALL_OW 301
31126: OR
31127: IFFALSE 31004
// if un then
31129: LD_VAR 0 3
31133: IFFALSE 31144
// RemoveUnit ( un ) ;
31135: LD_VAR 0 3
31139: PPUSH
31140: CALL_OW 64
// end ;
31144: PPOPN 3
31146: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
31147: LD_INT 0
31149: PPUSH
31150: PPUSH
31151: PPUSH
31152: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
31153: LD_ADDR_VAR 0 4
31157: PUSH
31158: LD_INT 22
31160: PUSH
31161: LD_OWVAR 2
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 2
31172: PUSH
31173: LD_INT 30
31175: PUSH
31176: LD_INT 0
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 30
31185: PUSH
31186: LD_INT 1
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: LIST
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PPUSH
31202: CALL_OW 69
31206: ST_TO_ADDR
// if not tmp then
31207: LD_VAR 0 4
31211: NOT
31212: IFFALSE 31216
// exit ;
31214: GO 31275
// for i in tmp do
31216: LD_ADDR_VAR 0 2
31220: PUSH
31221: LD_VAR 0 4
31225: PUSH
31226: FOR_IN
31227: IFFALSE 31273
// for j = 1 to 3 do
31229: LD_ADDR_VAR 0 3
31233: PUSH
31234: DOUBLE
31235: LD_INT 1
31237: DEC
31238: ST_TO_ADDR
31239: LD_INT 3
31241: PUSH
31242: FOR_TO
31243: IFFALSE 31269
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
31245: LD_VAR 0 2
31249: PPUSH
31250: CALL_OW 274
31254: PPUSH
31255: LD_VAR 0 3
31259: PPUSH
31260: LD_INT 99999
31262: PPUSH
31263: CALL_OW 277
31267: GO 31242
31269: POP
31270: POP
31271: GO 31226
31273: POP
31274: POP
// end ;
31275: LD_VAR 0 1
31279: RET
// export function hHackSetLevel10 ; var i , j ; begin
31280: LD_INT 0
31282: PPUSH
31283: PPUSH
31284: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
31285: LD_ADDR_VAR 0 2
31289: PUSH
31290: LD_INT 21
31292: PUSH
31293: LD_INT 1
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PPUSH
31300: CALL_OW 69
31304: PUSH
31305: FOR_IN
31306: IFFALSE 31358
// if IsSelected ( i ) then
31308: LD_VAR 0 2
31312: PPUSH
31313: CALL_OW 306
31317: IFFALSE 31356
// begin for j := 1 to 4 do
31319: LD_ADDR_VAR 0 3
31323: PUSH
31324: DOUBLE
31325: LD_INT 1
31327: DEC
31328: ST_TO_ADDR
31329: LD_INT 4
31331: PUSH
31332: FOR_TO
31333: IFFALSE 31354
// SetSkill ( i , j , 10 ) ;
31335: LD_VAR 0 2
31339: PPUSH
31340: LD_VAR 0 3
31344: PPUSH
31345: LD_INT 10
31347: PPUSH
31348: CALL_OW 237
31352: GO 31332
31354: POP
31355: POP
// end ;
31356: GO 31305
31358: POP
31359: POP
// end ;
31360: LD_VAR 0 1
31364: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
31365: LD_INT 0
31367: PPUSH
31368: PPUSH
31369: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
31370: LD_ADDR_VAR 0 2
31374: PUSH
31375: LD_INT 22
31377: PUSH
31378: LD_OWVAR 2
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 21
31389: PUSH
31390: LD_INT 1
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: EMPTY
31398: LIST
31399: LIST
31400: PPUSH
31401: CALL_OW 69
31405: PUSH
31406: FOR_IN
31407: IFFALSE 31448
// begin for j := 1 to 4 do
31409: LD_ADDR_VAR 0 3
31413: PUSH
31414: DOUBLE
31415: LD_INT 1
31417: DEC
31418: ST_TO_ADDR
31419: LD_INT 4
31421: PUSH
31422: FOR_TO
31423: IFFALSE 31444
// SetSkill ( i , j , 10 ) ;
31425: LD_VAR 0 2
31429: PPUSH
31430: LD_VAR 0 3
31434: PPUSH
31435: LD_INT 10
31437: PPUSH
31438: CALL_OW 237
31442: GO 31422
31444: POP
31445: POP
// end ;
31446: GO 31406
31448: POP
31449: POP
// end ;
31450: LD_VAR 0 1
31454: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
31455: LD_INT 0
31457: PPUSH
// uc_side := your_side ;
31458: LD_ADDR_OWVAR 20
31462: PUSH
31463: LD_OWVAR 2
31467: ST_TO_ADDR
// uc_nation := nation ;
31468: LD_ADDR_OWVAR 21
31472: PUSH
31473: LD_VAR 0 1
31477: ST_TO_ADDR
// InitHc ;
31478: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
31482: LD_INT 0
31484: PPUSH
31485: LD_VAR 0 2
31489: PPUSH
31490: LD_VAR 0 3
31494: PPUSH
31495: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
31499: CALL_OW 44
31503: PPUSH
31504: LD_INT 1
31506: PPUSH
31507: CALL_OW 51
// end ;
31511: LD_VAR 0 4
31515: RET
// export function hHackSpawnVehicle ; begin
31516: LD_INT 0
31518: PPUSH
// uc_side := your_side ;
31519: LD_ADDR_OWVAR 20
31523: PUSH
31524: LD_OWVAR 2
31528: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
31529: LD_ADDR_OWVAR 21
31533: PUSH
31534: LD_INT 1
31536: PPUSH
31537: LD_INT 3
31539: PPUSH
31540: CALL_OW 12
31544: ST_TO_ADDR
// InitVc ;
31545: CALL_OW 20
// case uc_nation of 1 :
31549: LD_OWVAR 21
31553: PUSH
31554: LD_INT 1
31556: DOUBLE
31557: EQUAL
31558: IFTRUE 31562
31560: GO 31706
31562: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
31563: LD_ADDR_OWVAR 37
31567: PUSH
31568: LD_INT 1
31570: PUSH
31571: LD_INT 2
31573: PUSH
31574: LD_INT 3
31576: PUSH
31577: LD_INT 4
31579: PUSH
31580: LD_INT 5
31582: PUSH
31583: EMPTY
31584: LIST
31585: LIST
31586: LIST
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 1
31592: PPUSH
31593: LD_INT 5
31595: PPUSH
31596: CALL_OW 12
31600: ARRAY
31601: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31602: LD_ADDR_OWVAR 39
31606: PUSH
31607: LD_INT 1
31609: PPUSH
31610: LD_INT 3
31612: PPUSH
31613: CALL_OW 12
31617: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
31618: LD_ADDR_OWVAR 38
31622: PUSH
31623: LD_INT 1
31625: PUSH
31626: LD_INT 2
31628: PUSH
31629: LD_INT 3
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 1
31639: PPUSH
31640: LD_INT 3
31642: PPUSH
31643: CALL_OW 12
31647: ARRAY
31648: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
31649: LD_ADDR_OWVAR 40
31653: PUSH
31654: LD_INT 2
31656: PUSH
31657: LD_INT 4
31659: PUSH
31660: LD_INT 5
31662: PUSH
31663: LD_INT 3
31665: PUSH
31666: LD_INT 7
31668: PUSH
31669: LD_INT 8
31671: PUSH
31672: LD_INT 9
31674: PUSH
31675: LD_INT 10
31677: PUSH
31678: LD_INT 6
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 1
31694: PPUSH
31695: LD_INT 9
31697: PPUSH
31698: CALL_OW 12
31702: ARRAY
31703: ST_TO_ADDR
// end ; 2 :
31704: GO 31971
31706: LD_INT 2
31708: DOUBLE
31709: EQUAL
31710: IFTRUE 31714
31712: GO 31838
31714: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
31715: LD_ADDR_OWVAR 37
31719: PUSH
31720: LD_INT 11
31722: PUSH
31723: LD_INT 12
31725: PUSH
31726: LD_INT 13
31728: PUSH
31729: LD_INT 14
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: PUSH
31738: LD_INT 1
31740: PPUSH
31741: LD_INT 4
31743: PPUSH
31744: CALL_OW 12
31748: ARRAY
31749: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31750: LD_ADDR_OWVAR 39
31754: PUSH
31755: LD_INT 1
31757: PPUSH
31758: LD_INT 3
31760: PPUSH
31761: CALL_OW 12
31765: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
31766: LD_ADDR_OWVAR 38
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: LD_INT 2
31776: PUSH
31777: LD_INT 5
31779: PUSH
31780: EMPTY
31781: LIST
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 1
31787: PPUSH
31788: LD_INT 3
31790: PPUSH
31791: CALL_OW 12
31795: ARRAY
31796: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
31797: LD_ADDR_OWVAR 40
31801: PUSH
31802: LD_INT 24
31804: PUSH
31805: LD_INT 26
31807: PUSH
31808: LD_INT 27
31810: PUSH
31811: LD_INT 28
31813: PUSH
31814: LD_INT 29
31816: PUSH
31817: EMPTY
31818: LIST
31819: LIST
31820: LIST
31821: LIST
31822: LIST
31823: PUSH
31824: LD_INT 1
31826: PPUSH
31827: LD_INT 5
31829: PPUSH
31830: CALL_OW 12
31834: ARRAY
31835: ST_TO_ADDR
// end ; 3 :
31836: GO 31971
31838: LD_INT 3
31840: DOUBLE
31841: EQUAL
31842: IFTRUE 31846
31844: GO 31970
31846: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
31847: LD_ADDR_OWVAR 37
31851: PUSH
31852: LD_INT 21
31854: PUSH
31855: LD_INT 23
31857: PUSH
31858: LD_INT 22
31860: PUSH
31861: LD_INT 24
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: PUSH
31870: LD_INT 1
31872: PPUSH
31873: LD_INT 4
31875: PPUSH
31876: CALL_OW 12
31880: ARRAY
31881: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31882: LD_ADDR_OWVAR 39
31886: PUSH
31887: LD_INT 1
31889: PPUSH
31890: LD_INT 3
31892: PPUSH
31893: CALL_OW 12
31897: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
31898: LD_ADDR_OWVAR 38
31902: PUSH
31903: LD_INT 1
31905: PUSH
31906: LD_INT 3
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 1
31915: PPUSH
31916: LD_INT 2
31918: PPUSH
31919: CALL_OW 12
31923: ARRAY
31924: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
31925: LD_ADDR_OWVAR 40
31929: PUSH
31930: LD_INT 42
31932: PUSH
31933: LD_INT 43
31935: PUSH
31936: LD_INT 44
31938: PUSH
31939: LD_INT 46
31941: PUSH
31942: LD_INT 48
31944: PUSH
31945: LD_INT 47
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 1
31958: PPUSH
31959: LD_INT 6
31961: PPUSH
31962: CALL_OW 12
31966: ARRAY
31967: ST_TO_ADDR
// end ; end ;
31968: GO 31971
31970: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
31971: CALL_OW 45
31975: PPUSH
31976: LD_INT 1
31978: PPUSH
31979: CALL_OW 51
// end ;
31983: LD_VAR 0 1
31987: RET
// export hInvincible ; every 1 do
31988: GO 31990
31990: DISABLE
// hInvincible := [ ] ;
31991: LD_ADDR_EXP 117
31995: PUSH
31996: EMPTY
31997: ST_TO_ADDR
31998: END
// every 10 do var i ;
31999: GO 32001
32001: DISABLE
32002: LD_INT 0
32004: PPUSH
// begin enable ;
32005: ENABLE
// if not hInvincible then
32006: LD_EXP 117
32010: NOT
32011: IFFALSE 32015
// exit ;
32013: GO 32059
// for i in hInvincible do
32015: LD_ADDR_VAR 0 1
32019: PUSH
32020: LD_EXP 117
32024: PUSH
32025: FOR_IN
32026: IFFALSE 32057
// if GetLives ( i ) < 1000 then
32028: LD_VAR 0 1
32032: PPUSH
32033: CALL_OW 256
32037: PUSH
32038: LD_INT 1000
32040: LESS
32041: IFFALSE 32055
// SetLives ( i , 1000 ) ;
32043: LD_VAR 0 1
32047: PPUSH
32048: LD_INT 1000
32050: PPUSH
32051: CALL_OW 234
32055: GO 32025
32057: POP
32058: POP
// end ;
32059: PPOPN 1
32061: END
// export function hHackInvincible ; var i ; begin
32062: LD_INT 0
32064: PPUSH
32065: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
32066: LD_ADDR_VAR 0 2
32070: PUSH
32071: LD_INT 2
32073: PUSH
32074: LD_INT 21
32076: PUSH
32077: LD_INT 1
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 21
32086: PUSH
32087: LD_INT 2
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: LIST
32098: PPUSH
32099: CALL_OW 69
32103: PUSH
32104: FOR_IN
32105: IFFALSE 32166
// if IsSelected ( i ) then
32107: LD_VAR 0 2
32111: PPUSH
32112: CALL_OW 306
32116: IFFALSE 32164
// begin if i in hInvincible then
32118: LD_VAR 0 2
32122: PUSH
32123: LD_EXP 117
32127: IN
32128: IFFALSE 32148
// hInvincible := hInvincible diff i else
32130: LD_ADDR_EXP 117
32134: PUSH
32135: LD_EXP 117
32139: PUSH
32140: LD_VAR 0 2
32144: DIFF
32145: ST_TO_ADDR
32146: GO 32164
// hInvincible := hInvincible union i ;
32148: LD_ADDR_EXP 117
32152: PUSH
32153: LD_EXP 117
32157: PUSH
32158: LD_VAR 0 2
32162: UNION
32163: ST_TO_ADDR
// end ;
32164: GO 32104
32166: POP
32167: POP
// end ;
32168: LD_VAR 0 1
32172: RET
// export function hHackInvisible ; var i , j ; begin
32173: LD_INT 0
32175: PPUSH
32176: PPUSH
32177: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
32178: LD_ADDR_VAR 0 2
32182: PUSH
32183: LD_INT 21
32185: PUSH
32186: LD_INT 1
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PPUSH
32193: CALL_OW 69
32197: PUSH
32198: FOR_IN
32199: IFFALSE 32223
// if IsSelected ( i ) then
32201: LD_VAR 0 2
32205: PPUSH
32206: CALL_OW 306
32210: IFFALSE 32221
// ComForceInvisible ( i ) ;
32212: LD_VAR 0 2
32216: PPUSH
32217: CALL_OW 496
32221: GO 32198
32223: POP
32224: POP
// end ;
32225: LD_VAR 0 1
32229: RET
// export function hHackChangeYourSide ; begin
32230: LD_INT 0
32232: PPUSH
// if your_side = 8 then
32233: LD_OWVAR 2
32237: PUSH
32238: LD_INT 8
32240: EQUAL
32241: IFFALSE 32253
// your_side := 0 else
32243: LD_ADDR_OWVAR 2
32247: PUSH
32248: LD_INT 0
32250: ST_TO_ADDR
32251: GO 32267
// your_side := your_side + 1 ;
32253: LD_ADDR_OWVAR 2
32257: PUSH
32258: LD_OWVAR 2
32262: PUSH
32263: LD_INT 1
32265: PLUS
32266: ST_TO_ADDR
// end ;
32267: LD_VAR 0 1
32271: RET
// export function hHackChangeUnitSide ; var i , j ; begin
32272: LD_INT 0
32274: PPUSH
32275: PPUSH
32276: PPUSH
// for i in all_units do
32277: LD_ADDR_VAR 0 2
32281: PUSH
32282: LD_OWVAR 3
32286: PUSH
32287: FOR_IN
32288: IFFALSE 32366
// if IsSelected ( i ) then
32290: LD_VAR 0 2
32294: PPUSH
32295: CALL_OW 306
32299: IFFALSE 32364
// begin j := GetSide ( i ) ;
32301: LD_ADDR_VAR 0 3
32305: PUSH
32306: LD_VAR 0 2
32310: PPUSH
32311: CALL_OW 255
32315: ST_TO_ADDR
// if j = 8 then
32316: LD_VAR 0 3
32320: PUSH
32321: LD_INT 8
32323: EQUAL
32324: IFFALSE 32336
// j := 0 else
32326: LD_ADDR_VAR 0 3
32330: PUSH
32331: LD_INT 0
32333: ST_TO_ADDR
32334: GO 32350
// j := j + 1 ;
32336: LD_ADDR_VAR 0 3
32340: PUSH
32341: LD_VAR 0 3
32345: PUSH
32346: LD_INT 1
32348: PLUS
32349: ST_TO_ADDR
// SetSide ( i , j ) ;
32350: LD_VAR 0 2
32354: PPUSH
32355: LD_VAR 0 3
32359: PPUSH
32360: CALL_OW 235
// end ;
32364: GO 32287
32366: POP
32367: POP
// end ;
32368: LD_VAR 0 1
32372: RET
// export function hHackFog ; begin
32373: LD_INT 0
32375: PPUSH
// FogOff ( true ) ;
32376: LD_INT 1
32378: PPUSH
32379: CALL_OW 344
// end ;
32383: LD_VAR 0 1
32387: RET
// export function hHackApeman ; begin
32388: LD_INT 0
32390: PPUSH
// uc_side := your_side ;
32391: LD_ADDR_OWVAR 20
32395: PUSH
32396: LD_OWVAR 2
32400: ST_TO_ADDR
// uc_nation := 0 ;
32401: LD_ADDR_OWVAR 21
32405: PUSH
32406: LD_INT 0
32408: ST_TO_ADDR
// hc_name :=  ;
32409: LD_ADDR_OWVAR 26
32413: PUSH
32414: LD_STRING 
32416: ST_TO_ADDR
// hc_gallery :=  ;
32417: LD_ADDR_OWVAR 33
32421: PUSH
32422: LD_STRING 
32424: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
32425: LD_ADDR_OWVAR 31
32429: PUSH
32430: LD_INT 0
32432: PUSH
32433: LD_INT 0
32435: PUSH
32436: LD_INT 0
32438: PUSH
32439: LD_INT 0
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: ST_TO_ADDR
// hc_class := class_apeman ;
32448: LD_ADDR_OWVAR 28
32452: PUSH
32453: LD_INT 12
32455: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
32456: CALL_OW 44
32460: PPUSH
32461: LD_INT 1
32463: PPUSH
32464: CALL_OW 51
// end ;
32468: LD_VAR 0 1
32472: RET
// export function hHackBoom ; begin
32473: LD_INT 0
32475: PPUSH
// uc_side := your_side ;
32476: LD_ADDR_OWVAR 20
32480: PUSH
32481: LD_OWVAR 2
32485: ST_TO_ADDR
// uc_nation := 1 ;
32486: LD_ADDR_OWVAR 21
32490: PUSH
32491: LD_INT 1
32493: ST_TO_ADDR
// vc_chassis := us_morphling ;
32494: LD_ADDR_OWVAR 37
32498: PUSH
32499: LD_INT 5
32501: ST_TO_ADDR
// vc_engine := engine_siberite ;
32502: LD_ADDR_OWVAR 39
32506: PUSH
32507: LD_INT 3
32509: ST_TO_ADDR
// vc_control := control_computer ;
32510: LD_ADDR_OWVAR 38
32514: PUSH
32515: LD_INT 3
32517: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
32518: LD_ADDR_OWVAR 40
32522: PUSH
32523: LD_INT 8
32525: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
32526: CALL_OW 45
32530: PPUSH
32531: LD_INT 1
32533: PPUSH
32534: CALL_OW 51
// end ;
32538: LD_VAR 0 1
32542: RET
