// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 38 0 0
// PrepareNature ;
   8: CALL 681 0 0
// PrepareArabian ;
  12: CALL 1996 0 0
// PrepareAmerican ;
  16: CALL 5021 0 0
// if debug then
  20: LD_EXP 1
  24: IFFALSE 33
// FogOff ( 2 ) ;
  26: LD_INT 2
  28: PPUSH
  29: CALL_OW 344
// Action ;
  33: CALL 9680 0 0
// end ;
  37: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , allowCargoEvacuation , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , capturedCargoCounter , americanStartRun , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , farmerHumanLoseCounter , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := false ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 0
  48: ST_TO_ADDR
// prefix := 02_ ;
  49: LD_ADDR_EXP 2
  53: PUSH
  54: LD_STRING 02_
  56: ST_TO_ADDR
// eventAttack := 1 ;
  57: LD_ADDR_EXP 24
  61: PUSH
  62: LD_INT 1
  64: ST_TO_ADDR
// deadCounter := 0 ;
  65: LD_ADDR_EXP 9
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// gameStarted := false ;
  73: LD_ADDR_EXP 3
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// farmerBaseReady := false ;
  81: LD_ADDR_EXP 4
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// americanBaseSpoted := false ;
  89: LD_ADDR_EXP 5
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// americanBaseCaptured := false ;
  97: LD_ADDR_EXP 6
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// americanHasEscaped := false ;
 105: LD_ADDR_EXP 8
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// workshopBuilded := false ;
 113: LD_ADDR_EXP 10
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// retreatAllowed := false ;
 121: LD_ADDR_EXP 11
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// allowConvoys := false ;
 129: LD_ADDR_EXP 12
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// farmerCrates := 0 ;
 137: LD_ADDR_EXP 15
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 145: LD_ADDR_EXP 16
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 153: LD_ADDR_EXP 17
 157: PUSH
 158: LD_INT 63000
 160: PUSH
 161: LD_INT 52500
 163: PUSH
 164: LD_INT 46200
 166: PUSH
 167: EMPTY
 168: LIST
 169: LIST
 170: LIST
 171: PUSH
 172: LD_OWVAR 67
 176: ARRAY
 177: ST_TO_ADDR
// farmerHumanLoseCounter := 0 ;
 178: LD_ADDR_EXP 20
 182: PUSH
 183: LD_INT 0
 185: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 186: LD_ADDR_EXP 18
 190: PUSH
 191: LD_INT 0
 193: ST_TO_ADDR
// attackWave := 1 ;
 194: LD_ADDR_EXP 19
 198: PUSH
 199: LD_INT 1
 201: ST_TO_ADDR
// omarCargoCounter := [ 6 , 8 , 10 ] [ Difficulty ] ;
 202: LD_ADDR_EXP 21
 206: PUSH
 207: LD_INT 6
 209: PUSH
 210: LD_INT 8
 212: PUSH
 213: LD_INT 10
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: PUSH
 221: LD_OWVAR 67
 225: ARRAY
 226: ST_TO_ADDR
// vehCounter := 0 ;
 227: LD_ADDR_EXP 22
 231: PUSH
 232: LD_INT 0
 234: ST_TO_ADDR
// convoyCounter := 0 ;
 235: LD_ADDR_EXP 23
 239: PUSH
 240: LD_INT 0
 242: ST_TO_ADDR
// ibrahimInDepot := false ;
 243: LD_ADDR_EXP 25
 247: PUSH
 248: LD_INT 0
 250: ST_TO_ADDR
// ibrahimIsFree := false ;
 251: LD_ADDR_EXP 26
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// maxConvoys := [ 16 , 16 , 15 ] [ Difficulty ] ;
 259: LD_ADDR_EXP 27
 263: PUSH
 264: LD_INT 16
 266: PUSH
 267: LD_INT 16
 269: PUSH
 270: LD_INT 15
 272: PUSH
 273: EMPTY
 274: LIST
 275: LIST
 276: LIST
 277: PUSH
 278: LD_OWVAR 67
 282: ARRAY
 283: ST_TO_ADDR
// capturedCargoCounter := 0 ;
 284: LD_ADDR_EXP 13
 288: PUSH
 289: LD_INT 0
 291: ST_TO_ADDR
// allowCargoEvacuation := false ;
 292: LD_ADDR_EXP 7
 296: PUSH
 297: LD_INT 0
 299: ST_TO_ADDR
// americanStartRun := false ;
 300: LD_ADDR_EXP 14
 304: PUSH
 305: LD_INT 0
 307: ST_TO_ADDR
// end ; end_of_file
 308: LD_VAR 0 1
 312: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 313: LD_INT 0
 315: PPUSH
 316: PPUSH
// if exist_mode then
 317: LD_VAR 0 2
 321: IFFALSE 346
// unit := CreateCharacter ( prefix & ident ) else
 323: LD_ADDR_VAR 0 5
 327: PUSH
 328: LD_VAR 0 3
 332: PUSH
 333: LD_VAR 0 1
 337: STR
 338: PPUSH
 339: CALL_OW 34
 343: ST_TO_ADDR
 344: GO 361
// unit := NewCharacter ( ident ) ;
 346: LD_ADDR_VAR 0 5
 350: PUSH
 351: LD_VAR 0 1
 355: PPUSH
 356: CALL_OW 25
 360: ST_TO_ADDR
// result := unit ;
 361: LD_ADDR_VAR 0 4
 365: PUSH
 366: LD_VAR 0 5
 370: ST_TO_ADDR
// end ;
 371: LD_VAR 0 4
 375: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 376: LD_INT 0
 378: PPUSH
// uc_side := side ;
 379: LD_ADDR_OWVAR 20
 383: PUSH
 384: LD_VAR 0 1
 388: ST_TO_ADDR
// uc_nation := nation ;
 389: LD_ADDR_OWVAR 21
 393: PUSH
 394: LD_VAR 0 2
 398: ST_TO_ADDR
// vc_chassis := chassis ;
 399: LD_ADDR_OWVAR 37
 403: PUSH
 404: LD_VAR 0 3
 408: ST_TO_ADDR
// vc_engine := engine ;
 409: LD_ADDR_OWVAR 39
 413: PUSH
 414: LD_VAR 0 4
 418: ST_TO_ADDR
// vc_control := control ;
 419: LD_ADDR_OWVAR 38
 423: PUSH
 424: LD_VAR 0 5
 428: ST_TO_ADDR
// vc_weapon := weapon ;
 429: LD_ADDR_OWVAR 40
 433: PUSH
 434: LD_VAR 0 6
 438: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 439: LD_ADDR_OWVAR 41
 443: PUSH
 444: LD_VAR 0 7
 448: ST_TO_ADDR
// result := CreateVehicle ;
 449: LD_ADDR_VAR 0 8
 453: PUSH
 454: CALL_OW 45
 458: ST_TO_ADDR
// end ;
 459: LD_VAR 0 8
 463: RET
// export function SayX ( units , ident ) ; var i ; begin
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// result := false ;
 468: LD_ADDR_VAR 0 3
 472: PUSH
 473: LD_INT 0
 475: ST_TO_ADDR
// if not units then
 476: LD_VAR 0 1
 480: NOT
 481: IFFALSE 485
// exit ;
 483: GO 539
// for i in units do
 485: LD_ADDR_VAR 0 4
 489: PUSH
 490: LD_VAR 0 1
 494: PUSH
 495: FOR_IN
 496: IFFALSE 537
// if IsOk ( i ) then
 498: LD_VAR 0 4
 502: PPUSH
 503: CALL_OW 302
 507: IFFALSE 535
// begin Say ( i , ident ) ;
 509: LD_VAR 0 4
 513: PPUSH
 514: LD_VAR 0 2
 518: PPUSH
 519: CALL_OW 88
// result := i ;
 523: LD_ADDR_VAR 0 3
 527: PUSH
 528: LD_VAR 0 4
 532: ST_TO_ADDR
// break ;
 533: GO 537
// end ;
 535: GO 495
 537: POP
 538: POP
// end ;
 539: LD_VAR 0 3
 543: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 544: LD_INT 0
 546: PPUSH
 547: PPUSH
// InitUc ;
 548: CALL_OW 18
// InitHc ;
 552: CALL_OW 19
// uc_side := 0 ;
 556: LD_ADDR_OWVAR 20
 560: PUSH
 561: LD_INT 0
 563: ST_TO_ADDR
// uc_nation := 0 ;
 564: LD_ADDR_OWVAR 21
 568: PUSH
 569: LD_INT 0
 571: ST_TO_ADDR
// for i = 1 to amount do
 572: LD_ADDR_VAR 0 4
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_VAR 0 2
 586: PUSH
 587: FOR_TO
 588: IFFALSE 670
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 590: LD_ADDR_OWVAR 29
 594: PUSH
 595: LD_INT 9
 597: PPUSH
 598: LD_INT 12
 600: PPUSH
 601: CALL_OW 12
 605: PUSH
 606: LD_INT 9
 608: PPUSH
 609: LD_INT 12
 611: PPUSH
 612: CALL_OW 12
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 621: LD_ADDR_OWVAR 35
 625: PUSH
 626: LD_INT 1
 628: NEG
 629: PPUSH
 630: LD_INT 1
 632: PPUSH
 633: CALL_OW 12
 637: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 638: LD_INT 0
 640: PPUSH
 641: LD_INT 12
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 651: CALL_OW 44
 655: PPUSH
 656: LD_VAR 0 1
 660: PPUSH
 661: LD_INT 0
 663: PPUSH
 664: CALL_OW 49
// end ;
 668: GO 587
 670: POP
 671: POP
// InitHc ;
 672: CALL_OW 19
// end ;
 676: LD_VAR 0 3
 680: RET
// export function PrepareNature ; var i ; begin
 681: LD_INT 0
 683: PPUSH
 684: PPUSH
// SpawnApeman ( forest , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
 685: LD_INT 2
 687: PPUSH
 688: LD_INT 5
 690: PUSH
 691: LD_INT 4
 693: PUSH
 694: LD_INT 4
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: PUSH
 702: LD_OWVAR 67
 706: ARRAY
 707: PPUSH
 708: CALL 544 0 2
// for i := 1 to 2 do
 712: LD_ADDR_VAR 0 2
 716: PUSH
 717: DOUBLE
 718: LD_INT 1
 720: DEC
 721: ST_TO_ADDR
 722: LD_INT 2
 724: PUSH
 725: FOR_TO
 726: IFFALSE 761
// begin hc_class := 21 ;
 728: LD_ADDR_OWVAR 28
 732: PUSH
 733: LD_INT 21
 735: ST_TO_ADDR
// hc_gallery :=  ;
 736: LD_ADDR_OWVAR 33
 740: PUSH
 741: LD_STRING 
 743: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 744: CALL_OW 44
 748: PPUSH
 749: LD_INT 2
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL_OW 49
// end ;
 759: GO 725
 761: POP
 762: POP
// for i := 1 to 2 do
 763: LD_ADDR_VAR 0 2
 767: PUSH
 768: DOUBLE
 769: LD_INT 1
 771: DEC
 772: ST_TO_ADDR
 773: LD_INT 2
 775: PUSH
 776: FOR_TO
 777: IFFALSE 812
// begin hc_class := 18 ;
 779: LD_ADDR_OWVAR 28
 783: PUSH
 784: LD_INT 18
 786: ST_TO_ADDR
// hc_gallery :=  ;
 787: LD_ADDR_OWVAR 33
 791: PUSH
 792: LD_STRING 
 794: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 795: CALL_OW 44
 799: PPUSH
 800: LD_INT 2
 802: PPUSH
 803: LD_INT 0
 805: PPUSH
 806: CALL_OW 49
// end ;
 810: GO 776
 812: POP
 813: POP
// for i := 1 to 2 do
 814: LD_ADDR_VAR 0 2
 818: PUSH
 819: DOUBLE
 820: LD_INT 1
 822: DEC
 823: ST_TO_ADDR
 824: LD_INT 2
 826: PUSH
 827: FOR_TO
 828: IFFALSE 863
// begin hc_class := 13 ;
 830: LD_ADDR_OWVAR 28
 834: PUSH
 835: LD_INT 13
 837: ST_TO_ADDR
// hc_gallery :=  ;
 838: LD_ADDR_OWVAR 33
 842: PUSH
 843: LD_STRING 
 845: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 846: CALL_OW 44
 850: PPUSH
 851: LD_INT 2
 853: PPUSH
 854: LD_INT 0
 856: PPUSH
 857: CALL_OW 49
// end ;
 861: GO 827
 863: POP
 864: POP
// end ;
 865: LD_VAR 0 1
 869: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 870: LD_INT 0
 872: PPUSH
 873: PPUSH
 874: PPUSH
// if not observer or not unit then
 875: LD_VAR 0 1
 879: NOT
 880: PUSH
 881: LD_VAR 0 2
 885: NOT
 886: OR
 887: IFFALSE 891
// exit ;
 889: GO 939
// if not See ( GetSide ( observer ) , unit ) then
 891: LD_VAR 0 1
 895: PPUSH
 896: CALL_OW 255
 900: PPUSH
 901: LD_VAR 0 2
 905: PPUSH
 906: CALL_OW 292
 910: NOT
 911: IFFALSE 915
// exit ;
 913: GO 939
// result := GetDistUnits ( observer , unit ) < 12 ;
 915: LD_ADDR_VAR 0 3
 919: PUSH
 920: LD_VAR 0 1
 924: PPUSH
 925: LD_VAR 0 2
 929: PPUSH
 930: CALL_OW 296
 934: PUSH
 935: LD_INT 12
 937: LESS
 938: ST_TO_ADDR
// end ;
 939: LD_VAR 0 3
 943: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 944: LD_INT 0
 946: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 947: LD_VAR 0 2
 951: PUSH
 952: LD_INT 1
 954: ARRAY
 955: PPUSH
 956: LD_VAR 0 2
 960: PUSH
 961: LD_INT 2
 963: ARRAY
 964: PPUSH
 965: CALL_OW 488
 969: PUSH
 970: LD_VAR 0 2
 974: PUSH
 975: LD_INT 1
 977: ARRAY
 978: PPUSH
 979: LD_VAR 0 2
 983: PUSH
 984: LD_INT 2
 986: ARRAY
 987: PPUSH
 988: CALL_OW 428
 992: PUSH
 993: LD_INT 0
 995: EQUAL
 996: AND
 997: IFFALSE 1031
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 999: LD_VAR 0 1
1003: PPUSH
1004: LD_VAR 0 2
1008: PUSH
1009: LD_INT 1
1011: ARRAY
1012: PPUSH
1013: LD_VAR 0 2
1017: PUSH
1018: LD_INT 2
1020: ARRAY
1021: PPUSH
1022: LD_VAR 0 3
1026: PPUSH
1027: CALL_OW 48
// end ;
1031: LD_VAR 0 4
1035: RET
// export function Video ( mode ) ; begin
1036: LD_INT 0
1038: PPUSH
// ingame_video = mode ;
1039: LD_ADDR_OWVAR 52
1043: PUSH
1044: LD_VAR 0 1
1048: ST_TO_ADDR
// interface_hidden = mode ;
1049: LD_ADDR_OWVAR 54
1053: PUSH
1054: LD_VAR 0 1
1058: ST_TO_ADDR
// end ;
1059: LD_VAR 0 2
1063: RET
// export function ReverseArray ( array ) ; var i ; begin
1064: LD_INT 0
1066: PPUSH
1067: PPUSH
// if not array then
1068: LD_VAR 0 1
1072: NOT
1073: IFFALSE 1077
// exit ;
1075: GO 1135
// result := [ ] ;
1077: LD_ADDR_VAR 0 2
1081: PUSH
1082: EMPTY
1083: ST_TO_ADDR
// for i := 1 to array do
1084: LD_ADDR_VAR 0 3
1088: PUSH
1089: DOUBLE
1090: LD_INT 1
1092: DEC
1093: ST_TO_ADDR
1094: LD_VAR 0 1
1098: PUSH
1099: FOR_TO
1100: IFFALSE 1133
// result := Insert ( result , 1 , array [ i ] ) ;
1102: LD_ADDR_VAR 0 2
1106: PUSH
1107: LD_VAR 0 2
1111: PPUSH
1112: LD_INT 1
1114: PPUSH
1115: LD_VAR 0 1
1119: PUSH
1120: LD_VAR 0 3
1124: ARRAY
1125: PPUSH
1126: CALL_OW 2
1130: ST_TO_ADDR
1131: GO 1099
1133: POP
1134: POP
// end ;
1135: LD_VAR 0 2
1139: RET
// export function ComExit ( unit ) ; begin
1140: LD_INT 0
1142: PPUSH
// result := IsInUnit ( unit ) ;
1143: LD_ADDR_VAR 0 2
1147: PUSH
1148: LD_VAR 0 1
1152: PPUSH
1153: CALL_OW 310
1157: ST_TO_ADDR
// if not result then
1158: LD_VAR 0 2
1162: NOT
1163: IFFALSE 1167
// exit ;
1165: GO 1202
// if GetType ( result ) = unit_vehicle then
1167: LD_VAR 0 2
1171: PPUSH
1172: CALL_OW 247
1176: PUSH
1177: LD_INT 2
1179: EQUAL
1180: IFFALSE 1193
// ComExitVehicle ( unit ) else
1182: LD_VAR 0 1
1186: PPUSH
1187: CALL_OW 121
1191: GO 1202
// ComExitBuilding ( unit ) ;
1193: LD_VAR 0 1
1197: PPUSH
1198: CALL_OW 122
// end ;
1202: LD_VAR 0 2
1206: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1207: LD_INT 0
1209: PPUSH
1210: PPUSH
// if not side or not nation then
1211: LD_VAR 0 1
1215: NOT
1216: PUSH
1217: LD_VAR 0 2
1221: NOT
1222: OR
1223: IFFALSE 1227
// exit ;
1225: GO 1991
// case nation of nation_american :
1227: LD_VAR 0 2
1231: PUSH
1232: LD_INT 1
1234: DOUBLE
1235: EQUAL
1236: IFTRUE 1240
1238: GO 1454
1240: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1241: LD_ADDR_VAR 0 4
1245: PUSH
1246: LD_INT 35
1248: PUSH
1249: LD_INT 45
1251: PUSH
1252: LD_INT 46
1254: PUSH
1255: LD_INT 47
1257: PUSH
1258: LD_INT 82
1260: PUSH
1261: LD_INT 83
1263: PUSH
1264: LD_INT 84
1266: PUSH
1267: LD_INT 85
1269: PUSH
1270: LD_INT 86
1272: PUSH
1273: LD_INT 1
1275: PUSH
1276: LD_INT 2
1278: PUSH
1279: LD_INT 6
1281: PUSH
1282: LD_INT 15
1284: PUSH
1285: LD_INT 16
1287: PUSH
1288: LD_INT 7
1290: PUSH
1291: LD_INT 12
1293: PUSH
1294: LD_INT 13
1296: PUSH
1297: LD_INT 10
1299: PUSH
1300: LD_INT 14
1302: PUSH
1303: LD_INT 20
1305: PUSH
1306: LD_INT 21
1308: PUSH
1309: LD_INT 22
1311: PUSH
1312: LD_INT 25
1314: PUSH
1315: LD_INT 32
1317: PUSH
1318: LD_INT 27
1320: PUSH
1321: LD_INT 36
1323: PUSH
1324: LD_INT 69
1326: PUSH
1327: LD_INT 39
1329: PUSH
1330: LD_INT 34
1332: PUSH
1333: LD_INT 40
1335: PUSH
1336: LD_INT 48
1338: PUSH
1339: LD_INT 49
1341: PUSH
1342: LD_INT 50
1344: PUSH
1345: LD_INT 51
1347: PUSH
1348: LD_INT 52
1350: PUSH
1351: LD_INT 53
1353: PUSH
1354: LD_INT 54
1356: PUSH
1357: LD_INT 55
1359: PUSH
1360: LD_INT 56
1362: PUSH
1363: LD_INT 57
1365: PUSH
1366: LD_INT 58
1368: PUSH
1369: LD_INT 59
1371: PUSH
1372: LD_INT 60
1374: PUSH
1375: LD_INT 61
1377: PUSH
1378: LD_INT 62
1380: PUSH
1381: LD_INT 80
1383: PUSH
1384: LD_INT 82
1386: PUSH
1387: LD_INT 83
1389: PUSH
1390: LD_INT 84
1392: PUSH
1393: LD_INT 85
1395: PUSH
1396: LD_INT 86
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: ST_TO_ADDR
1452: GO 1915
1454: LD_INT 2
1456: DOUBLE
1457: EQUAL
1458: IFTRUE 1462
1460: GO 1684
1462: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1463: LD_ADDR_VAR 0 4
1467: PUSH
1468: LD_INT 35
1470: PUSH
1471: LD_INT 45
1473: PUSH
1474: LD_INT 46
1476: PUSH
1477: LD_INT 47
1479: PUSH
1480: LD_INT 82
1482: PUSH
1483: LD_INT 83
1485: PUSH
1486: LD_INT 84
1488: PUSH
1489: LD_INT 85
1491: PUSH
1492: LD_INT 87
1494: PUSH
1495: LD_INT 70
1497: PUSH
1498: LD_INT 1
1500: PUSH
1501: LD_INT 11
1503: PUSH
1504: LD_INT 3
1506: PUSH
1507: LD_INT 4
1509: PUSH
1510: LD_INT 5
1512: PUSH
1513: LD_INT 6
1515: PUSH
1516: LD_INT 15
1518: PUSH
1519: LD_INT 18
1521: PUSH
1522: LD_INT 7
1524: PUSH
1525: LD_INT 17
1527: PUSH
1528: LD_INT 8
1530: PUSH
1531: LD_INT 20
1533: PUSH
1534: LD_INT 21
1536: PUSH
1537: LD_INT 22
1539: PUSH
1540: LD_INT 72
1542: PUSH
1543: LD_INT 26
1545: PUSH
1546: LD_INT 69
1548: PUSH
1549: LD_INT 39
1551: PUSH
1552: LD_INT 40
1554: PUSH
1555: LD_INT 41
1557: PUSH
1558: LD_INT 42
1560: PUSH
1561: LD_INT 43
1563: PUSH
1564: LD_INT 48
1566: PUSH
1567: LD_INT 49
1569: PUSH
1570: LD_INT 50
1572: PUSH
1573: LD_INT 51
1575: PUSH
1576: LD_INT 52
1578: PUSH
1579: LD_INT 53
1581: PUSH
1582: LD_INT 54
1584: PUSH
1585: LD_INT 55
1587: PUSH
1588: LD_INT 56
1590: PUSH
1591: LD_INT 60
1593: PUSH
1594: LD_INT 61
1596: PUSH
1597: LD_INT 62
1599: PUSH
1600: LD_INT 66
1602: PUSH
1603: LD_INT 67
1605: PUSH
1606: LD_INT 68
1608: PUSH
1609: LD_INT 81
1611: PUSH
1612: LD_INT 82
1614: PUSH
1615: LD_INT 83
1617: PUSH
1618: LD_INT 84
1620: PUSH
1621: LD_INT 85
1623: PUSH
1624: LD_INT 87
1626: PUSH
1627: EMPTY
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: ST_TO_ADDR
1682: GO 1915
1684: LD_INT 3
1686: DOUBLE
1687: EQUAL
1688: IFTRUE 1692
1690: GO 1914
1692: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1693: LD_ADDR_VAR 0 4
1697: PUSH
1698: LD_INT 46
1700: PUSH
1701: LD_INT 47
1703: PUSH
1704: LD_INT 1
1706: PUSH
1707: LD_INT 2
1709: PUSH
1710: LD_INT 82
1712: PUSH
1713: LD_INT 83
1715: PUSH
1716: LD_INT 84
1718: PUSH
1719: LD_INT 85
1721: PUSH
1722: LD_INT 86
1724: PUSH
1725: LD_INT 11
1727: PUSH
1728: LD_INT 9
1730: PUSH
1731: LD_INT 20
1733: PUSH
1734: LD_INT 19
1736: PUSH
1737: LD_INT 21
1739: PUSH
1740: LD_INT 24
1742: PUSH
1743: LD_INT 22
1745: PUSH
1746: LD_INT 25
1748: PUSH
1749: LD_INT 28
1751: PUSH
1752: LD_INT 29
1754: PUSH
1755: LD_INT 30
1757: PUSH
1758: LD_INT 31
1760: PUSH
1761: LD_INT 37
1763: PUSH
1764: LD_INT 38
1766: PUSH
1767: LD_INT 32
1769: PUSH
1770: LD_INT 27
1772: PUSH
1773: LD_INT 33
1775: PUSH
1776: LD_INT 69
1778: PUSH
1779: LD_INT 39
1781: PUSH
1782: LD_INT 34
1784: PUSH
1785: LD_INT 40
1787: PUSH
1788: LD_INT 71
1790: PUSH
1791: LD_INT 23
1793: PUSH
1794: LD_INT 44
1796: PUSH
1797: LD_INT 48
1799: PUSH
1800: LD_INT 49
1802: PUSH
1803: LD_INT 50
1805: PUSH
1806: LD_INT 51
1808: PUSH
1809: LD_INT 52
1811: PUSH
1812: LD_INT 53
1814: PUSH
1815: LD_INT 54
1817: PUSH
1818: LD_INT 55
1820: PUSH
1821: LD_INT 56
1823: PUSH
1824: LD_INT 57
1826: PUSH
1827: LD_INT 58
1829: PUSH
1830: LD_INT 59
1832: PUSH
1833: LD_INT 63
1835: PUSH
1836: LD_INT 64
1838: PUSH
1839: LD_INT 65
1841: PUSH
1842: LD_INT 82
1844: PUSH
1845: LD_INT 83
1847: PUSH
1848: LD_INT 84
1850: PUSH
1851: LD_INT 85
1853: PUSH
1854: LD_INT 86
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: ST_TO_ADDR
1912: GO 1915
1914: POP
// if state > - 1 and state < 3 then
1915: LD_VAR 0 3
1919: PUSH
1920: LD_INT 1
1922: NEG
1923: GREATER
1924: PUSH
1925: LD_VAR 0 3
1929: PUSH
1930: LD_INT 3
1932: LESS
1933: AND
1934: IFFALSE 1991
// for i in result do
1936: LD_ADDR_VAR 0 5
1940: PUSH
1941: LD_VAR 0 4
1945: PUSH
1946: FOR_IN
1947: IFFALSE 1989
// if GetTech ( i , side ) <> state then
1949: LD_VAR 0 5
1953: PPUSH
1954: LD_VAR 0 1
1958: PPUSH
1959: CALL_OW 321
1963: PUSH
1964: LD_VAR 0 3
1968: NONEQUAL
1969: IFFALSE 1987
// result := result diff i ;
1971: LD_ADDR_VAR 0 4
1975: PUSH
1976: LD_VAR 0 4
1980: PUSH
1981: LD_VAR 0 5
1985: DIFF
1986: ST_TO_ADDR
1987: GO 1946
1989: POP
1990: POP
// end ; end_of_file
1991: LD_VAR 0 4
1995: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1996: LD_INT 0
1998: PPUSH
1999: PPUSH
2000: PPUSH
2001: PPUSH
// uc_side := 5 ;
2002: LD_ADDR_OWVAR 20
2006: PUSH
2007: LD_INT 5
2009: ST_TO_ADDR
// uc_nation := 2 ;
2010: LD_ADDR_OWVAR 21
2014: PUSH
2015: LD_INT 2
2017: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
2018: LD_INT 5
2020: PPUSH
2021: CALL_OW 274
2025: PPUSH
2026: LD_INT 1
2028: PPUSH
2029: LD_INT 45
2031: PPUSH
2032: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
2036: LD_ADDR_EXP 36
2040: PUSH
2041: LD_STRING Farmer
2043: PPUSH
2044: LD_INT 0
2046: PPUSH
2047: LD_STRING 
2049: PPUSH
2050: CALL 313 0 3
2054: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2055: LD_ADDR_EXP 37
2059: PUSH
2060: LD_STRING Omar
2062: PPUSH
2063: LD_INT 0
2065: PPUSH
2066: LD_STRING 
2068: PPUSH
2069: CALL 313 0 3
2073: ST_TO_ADDR
// omarSquad := [ ] ;
2074: LD_ADDR_EXP 40
2078: PUSH
2079: EMPTY
2080: ST_TO_ADDR
// heikeSquad := [ ] ;
2081: LD_ADDR_EXP 41
2085: PUSH
2086: EMPTY
2087: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2088: LD_ADDR_EXP 42
2092: PUSH
2093: EMPTY
2094: ST_TO_ADDR
// omarCargo := [ ] ;
2095: LD_ADDR_EXP 43
2099: PUSH
2100: EMPTY
2101: ST_TO_ADDR
// for i := 1 to 5 do
2102: LD_ADDR_VAR 0 2
2106: PUSH
2107: DOUBLE
2108: LD_INT 1
2110: DEC
2111: ST_TO_ADDR
2112: LD_INT 5
2114: PUSH
2115: FOR_TO
2116: IFFALSE 2274
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2118: LD_INT 0
2120: PPUSH
2121: LD_INT 1
2123: PUSH
2124: LD_INT 1
2126: PUSH
2127: LD_INT 2
2129: PUSH
2130: LD_INT 1
2132: PUSH
2133: LD_INT 1
2135: PUSH
2136: EMPTY
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: PUSH
2143: LD_VAR 0 2
2147: ARRAY
2148: PPUSH
2149: LD_INT 3
2151: PPUSH
2152: CALL_OW 380
// un := CreateHuman ;
2156: LD_ADDR_VAR 0 3
2160: PUSH
2161: CALL_OW 44
2165: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2166: LD_ADDR_EXP 40
2170: PUSH
2171: LD_EXP 40
2175: PUSH
2176: LD_VAR 0 3
2180: UNION
2181: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2182: LD_VAR 0 3
2186: PPUSH
2187: LD_INT 87
2189: PUSH
2190: LD_INT 30
2192: PUSH
2193: EMPTY
2194: LIST
2195: LIST
2196: PUSH
2197: LD_INT 91
2199: PUSH
2200: LD_INT 32
2202: PUSH
2203: EMPTY
2204: LIST
2205: LIST
2206: PUSH
2207: LD_INT 82
2209: PUSH
2210: LD_INT 15
2212: PUSH
2213: EMPTY
2214: LIST
2215: LIST
2216: PUSH
2217: LD_INT 79
2219: PUSH
2220: LD_INT 14
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: PUSH
2227: LD_INT 82
2229: PUSH
2230: LD_INT 13
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: PUSH
2237: EMPTY
2238: LIST
2239: LIST
2240: LIST
2241: LIST
2242: LIST
2243: PUSH
2244: LD_VAR 0 2
2248: ARRAY
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL 944 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2257: LD_VAR 0 3
2261: PPUSH
2262: LD_INT 93
2264: PPUSH
2265: LD_INT 21
2267: PPUSH
2268: CALL_OW 118
// end ;
2272: GO 2115
2274: POP
2275: POP
// uc_side := 2 ;
2276: LD_ADDR_OWVAR 20
2280: PUSH
2281: LD_INT 2
2283: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2284: LD_ADDR_EXP 28
2288: PUSH
2289: LD_STRING Heike
2291: PPUSH
2292: LD_EXP 1
2296: NOT
2297: PPUSH
2298: LD_EXP 2
2302: PPUSH
2303: CALL 313 0 3
2307: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2308: LD_ADDR_EXP 32
2312: PUSH
2313: LD_STRING Aviradze
2315: PPUSH
2316: LD_EXP 1
2320: NOT
2321: PPUSH
2322: LD_EXP 2
2326: PPUSH
2327: CALL 313 0 3
2331: ST_TO_ADDR
// tmp := [ ] ;
2332: LD_ADDR_VAR 0 4
2336: PUSH
2337: EMPTY
2338: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2339: LD_ADDR_EXP 29
2343: PUSH
2344: LD_STRING Givi
2346: PPUSH
2347: LD_EXP 1
2351: NOT
2352: PPUSH
2353: LD_EXP 2
2357: PPUSH
2358: CALL 313 0 3
2362: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2363: LD_ADDR_EXP 30
2367: PUSH
2368: LD_STRING Mike
2370: PPUSH
2371: LD_EXP 1
2375: NOT
2376: PPUSH
2377: LD_EXP 2
2381: PPUSH
2382: CALL 313 0 3
2386: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2387: LD_ADDR_EXP 31
2391: PUSH
2392: LD_STRING Kamil
2394: PPUSH
2395: LD_EXP 1
2399: NOT
2400: PPUSH
2401: LD_EXP 2
2405: PPUSH
2406: CALL 313 0 3
2410: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2411: LD_ADDR_EXP 33
2415: PUSH
2416: LD_STRING Kaia
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_EXP 2
2429: PPUSH
2430: CALL 313 0 3
2434: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2435: LD_ADDR_EXP 34
2439: PUSH
2440: LD_STRING Sophia
2442: PPUSH
2443: LD_EXP 1
2447: NOT
2448: PPUSH
2449: LD_EXP 2
2453: PPUSH
2454: CALL 313 0 3
2458: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2459: LD_ADDR_EXP 35
2463: PUSH
2464: LD_STRING Markov
2466: PPUSH
2467: LD_EXP 1
2471: NOT
2472: PPUSH
2473: LD_EXP 2
2477: PPUSH
2478: CALL 313 0 3
2482: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2483: LD_ADDR_EXP 42
2487: PUSH
2488: LD_STRING 02_others
2490: PPUSH
2491: CALL_OW 31
2495: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2496: LD_ADDR_VAR 0 4
2500: PUSH
2501: LD_EXP 30
2505: PUSH
2506: LD_EXP 31
2510: PUSH
2511: LD_EXP 33
2515: PUSH
2516: LD_EXP 34
2520: PUSH
2521: LD_EXP 35
2525: PUSH
2526: LD_EXP 29
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: LIST
2535: LIST
2536: LIST
2537: LIST
2538: PUSH
2539: LD_EXP 42
2543: ADD
2544: PUSH
2545: LD_INT 0
2547: DIFF
2548: ST_TO_ADDR
// heikeSquad := tmp ;
2549: LD_ADDR_EXP 41
2553: PUSH
2554: LD_VAR 0 4
2558: ST_TO_ADDR
// if UnitFilter ( heikeSquad , [ f_class , 1 ] ) < 3 then
2559: LD_EXP 41
2563: PPUSH
2564: LD_INT 25
2566: PUSH
2567: LD_INT 1
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PPUSH
2574: CALL_OW 72
2578: PUSH
2579: LD_INT 3
2581: LESS
2582: IFFALSE 2632
// begin SetClass ( Kaia , 1 ) ;
2584: LD_EXP 33
2588: PPUSH
2589: LD_INT 1
2591: PPUSH
2592: CALL_OW 336
// SetClass ( Mike , 1 ) ;
2596: LD_EXP 30
2600: PPUSH
2601: LD_INT 1
2603: PPUSH
2604: CALL_OW 336
// SetClass ( Givi , 1 ) ;
2608: LD_EXP 29
2612: PPUSH
2613: LD_INT 1
2615: PPUSH
2616: CALL_OW 336
// SetClass ( Heike , 1 ) ;
2620: LD_EXP 28
2624: PPUSH
2625: LD_INT 1
2627: PPUSH
2628: CALL_OW 336
// end ; tmp := tmp union CreateCharacterSet ( 02_ape ) ;
2632: LD_ADDR_VAR 0 4
2636: PUSH
2637: LD_VAR 0 4
2641: PUSH
2642: LD_STRING 02_ape
2644: PPUSH
2645: CALL_OW 31
2649: UNION
2650: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2651: LD_EXP 28
2655: PPUSH
2656: LD_INT 92
2658: PPUSH
2659: LD_INT 17
2661: PPUSH
2662: LD_INT 0
2664: PPUSH
2665: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2669: LD_EXP 36
2673: PPUSH
2674: LD_INT 95
2676: PPUSH
2677: LD_INT 19
2679: PPUSH
2680: LD_INT 0
2682: PPUSH
2683: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2687: LD_EXP 37
2691: PPUSH
2692: LD_INT 89
2694: PPUSH
2695: LD_INT 25
2697: PPUSH
2698: LD_INT 0
2700: PPUSH
2701: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2705: LD_EXP 32
2709: PPUSH
2710: LD_INT 92
2712: PPUSH
2713: LD_INT 27
2715: PPUSH
2716: LD_INT 0
2718: PPUSH
2719: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2723: LD_EXP 37
2727: PPUSH
2728: LD_EXP 32
2732: PPUSH
2733: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2737: LD_EXP 32
2741: PPUSH
2742: LD_EXP 37
2746: PPUSH
2747: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2751: LD_EXP 28
2755: PUSH
2756: LD_EXP 36
2760: PUSH
2761: EMPTY
2762: LIST
2763: LIST
2764: PPUSH
2765: LD_EXP 37
2769: PPUSH
2770: CALL_OW 119
// if tmp then
2774: LD_VAR 0 4
2778: IFFALSE 2832
// for i in tmp do
2780: LD_ADDR_VAR 0 2
2784: PUSH
2785: LD_VAR 0 4
2789: PUSH
2790: FOR_IN
2791: IFFALSE 2830
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2793: LD_VAR 0 2
2797: PPUSH
2798: LD_INT 94
2800: PPUSH
2801: LD_INT 14
2803: PPUSH
2804: LD_INT 4
2806: PPUSH
2807: LD_INT 0
2809: PPUSH
2810: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2814: LD_VAR 0 2
2818: PPUSH
2819: LD_EXP 28
2823: PPUSH
2824: CALL_OW 119
// end ;
2828: GO 2790
2830: POP
2831: POP
// farmerSquad := [ ] ;
2832: LD_ADDR_EXP 39
2836: PUSH
2837: EMPTY
2838: ST_TO_ADDR
// uc_side := 5 ;
2839: LD_ADDR_OWVAR 20
2843: PUSH
2844: LD_INT 5
2846: ST_TO_ADDR
// uc_nation := 2 ;
2847: LD_ADDR_OWVAR 21
2851: PUSH
2852: LD_INT 2
2854: ST_TO_ADDR
// for i := 1 to 4 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 4
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2947
// begin PrepareHuman ( false , 1 , 2 ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 1
2876: PPUSH
2877: LD_INT 2
2879: PPUSH
2880: CALL_OW 380
// un := CreateHuman ;
2884: LD_ADDR_VAR 0 3
2888: PUSH
2889: CALL_OW 44
2893: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2894: LD_VAR 0 3
2898: PPUSH
2899: LD_INT 102
2901: PPUSH
2902: LD_INT 27
2904: PPUSH
2905: LD_INT 4
2907: PPUSH
2908: LD_INT 0
2910: PPUSH
2911: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2915: LD_ADDR_EXP 39
2919: PUSH
2920: LD_EXP 39
2924: PUSH
2925: LD_VAR 0 3
2929: UNION
2930: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2931: LD_VAR 0 3
2935: PPUSH
2936: LD_EXP 37
2940: PPUSH
2941: CALL_OW 119
// end ;
2945: GO 2868
2947: POP
2948: POP
// for i := 1 to 2 do
2949: LD_ADDR_VAR 0 2
2953: PUSH
2954: DOUBLE
2955: LD_INT 1
2957: DEC
2958: ST_TO_ADDR
2959: LD_INT 2
2961: PUSH
2962: FOR_TO
2963: IFFALSE 3041
// begin PrepareHuman ( false , 2 , 2 ) ;
2965: LD_INT 0
2967: PPUSH
2968: LD_INT 2
2970: PPUSH
2971: LD_INT 2
2973: PPUSH
2974: CALL_OW 380
// un := CreateHuman ;
2978: LD_ADDR_VAR 0 3
2982: PUSH
2983: CALL_OW 44
2987: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2988: LD_VAR 0 3
2992: PPUSH
2993: LD_INT 108
2995: PPUSH
2996: LD_INT 62
2998: PPUSH
2999: LD_INT 2
3001: PPUSH
3002: LD_INT 0
3004: PPUSH
3005: CALL_OW 50
// farmerSquad := farmerSquad union un ;
3009: LD_ADDR_EXP 39
3013: PUSH
3014: LD_EXP 39
3018: PUSH
3019: LD_VAR 0 3
3023: UNION
3024: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
3025: LD_VAR 0 3
3029: PPUSH
3030: LD_EXP 37
3034: PPUSH
3035: CALL_OW 119
// end ;
3039: GO 2962
3041: POP
3042: POP
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
3043: LD_INT 109
3045: PPUSH
3046: LD_INT 63
3048: PPUSH
3049: LD_INT 2
3051: PPUSH
3052: LD_INT 15
3054: NEG
3055: PPUSH
3056: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
3060: LD_INT 109
3062: PPUSH
3063: LD_INT 63
3065: PPUSH
3066: LD_INT 2
3068: PPUSH
3069: CALL_OW 331
// end ;
3073: LD_VAR 0 1
3077: RET
// export function PrepareIbrahim ( x , y ) ; begin
3078: LD_INT 0
3080: PPUSH
// uc_side := 6 ;
3081: LD_ADDR_OWVAR 20
3085: PUSH
3086: LD_INT 6
3088: ST_TO_ADDR
// uc_nation := 3 ;
3089: LD_ADDR_OWVAR 21
3093: PUSH
3094: LD_INT 3
3096: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3097: LD_ADDR_EXP 38
3101: PUSH
3102: LD_STRING IbrahimRu
3104: PPUSH
3105: LD_INT 0
3107: PPUSH
3108: LD_STRING 
3110: PPUSH
3111: CALL 313 0 3
3115: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3116: LD_EXP 38
3120: PPUSH
3121: LD_VAR 0 1
3125: PPUSH
3126: LD_VAR 0 2
3130: PPUSH
3131: LD_INT 8
3133: PPUSH
3134: LD_INT 1
3136: PPUSH
3137: CALL_OW 50
// end ;
3141: LD_VAR 0 3
3145: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3146: LD_EXP 37
3150: PUSH
3151: LD_EXP 40
3155: ADD
3156: PPUSH
3157: LD_INT 95
3159: PUSH
3160: LD_INT 3
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL_OW 72
3171: IFFALSE 3227
3173: GO 3175
3175: DISABLE
3176: LD_INT 0
3178: PPUSH
// begin enable ;
3179: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3180: LD_ADDR_VAR 0 1
3184: PUSH
3185: LD_EXP 37
3189: PUSH
3190: LD_EXP 40
3194: ADD
3195: PPUSH
3196: LD_INT 95
3198: PUSH
3199: LD_INT 3
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PPUSH
3206: CALL_OW 72
3210: PUSH
3211: FOR_IN
3212: IFFALSE 3225
// RemoveUnit ( i ) ;
3214: LD_VAR 0 1
3218: PPUSH
3219: CALL_OW 64
3223: GO 3211
3225: POP
3226: POP
// end ;
3227: PPOPN 1
3229: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3230: LD_EXP 3
3234: PUSH
3235: LD_EXP 36
3239: PPUSH
3240: LD_INT 4
3242: PPUSH
3243: CALL_OW 308
3247: AND
3248: IFFALSE 4031
3250: GO 3252
3252: DISABLE
3253: LD_INT 0
3255: PPUSH
3256: PPUSH
3257: PPUSH
3258: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3259: LD_EXP 36
3263: PPUSH
3264: LD_INT 110
3266: PPUSH
3267: LD_INT 60
3269: PPUSH
3270: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3274: LD_EXP 36
3278: PPUSH
3279: LD_INT 110
3281: PPUSH
3282: LD_INT 61
3284: PPUSH
3285: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3289: LD_ADDR_VAR 0 2
3293: PUSH
3294: LD_EXP 39
3298: PPUSH
3299: LD_INT 25
3301: PUSH
3302: LD_INT 1
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: PPUSH
3309: CALL_OW 72
3313: ST_TO_ADDR
// if tmp then
3314: LD_VAR 0 2
3318: IFFALSE 3412
// begin for i := 1 to 2 do
3320: LD_ADDR_VAR 0 1
3324: PUSH
3325: DOUBLE
3326: LD_INT 1
3328: DEC
3329: ST_TO_ADDR
3330: LD_INT 2
3332: PUSH
3333: FOR_TO
3334: IFFALSE 3410
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3336: LD_VAR 0 2
3340: PUSH
3341: LD_VAR 0 1
3345: ARRAY
3346: PPUSH
3347: LD_INT 5
3349: PPUSH
3350: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3354: LD_VAR 0 2
3358: PUSH
3359: LD_VAR 0 1
3363: ARRAY
3364: PPUSH
3365: LD_INT 2
3367: PPUSH
3368: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3372: LD_VAR 0 2
3376: PUSH
3377: LD_VAR 0 1
3381: ARRAY
3382: PPUSH
3383: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3387: LD_VAR 0 2
3391: PUSH
3392: LD_VAR 0 1
3396: ARRAY
3397: PPUSH
3398: LD_INT 107
3400: PPUSH
3401: LD_INT 66
3403: PPUSH
3404: CALL_OW 171
// end ;
3408: GO 3333
3410: POP
3411: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3412: LD_ADDR_VAR 0 2
3416: PUSH
3417: LD_EXP 39
3421: PPUSH
3422: LD_INT 25
3424: PUSH
3425: LD_INT 2
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PPUSH
3432: CALL_OW 72
3436: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3437: LD_INT 35
3439: PPUSH
3440: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3444: LD_ADDR_VAR 0 2
3448: PUSH
3449: LD_EXP 39
3453: PPUSH
3454: LD_INT 25
3456: PUSH
3457: LD_INT 2
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: PPUSH
3464: CALL_OW 72
3468: ST_TO_ADDR
// until tmp ;
3469: LD_VAR 0 2
3473: IFFALSE 3437
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3475: LD_VAR 0 2
3479: PPUSH
3480: LD_INT 31
3482: PPUSH
3483: LD_INT 102
3485: PPUSH
3486: LD_INT 69
3488: PPUSH
3489: LD_INT 2
3491: PPUSH
3492: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3496: LD_INT 35
3498: PPUSH
3499: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3503: LD_EXP 39
3507: PPUSH
3508: LD_INT 3
3510: PUSH
3511: LD_INT 60
3513: PUSH
3514: EMPTY
3515: LIST
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: PUSH
3521: LD_INT 25
3523: PUSH
3524: LD_INT 2
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PUSH
3531: EMPTY
3532: LIST
3533: LIST
3534: PPUSH
3535: CALL_OW 72
3539: IFFALSE 3496
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: LD_EXP 39
3550: PPUSH
3551: LD_INT 25
3553: PUSH
3554: LD_INT 2
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: PPUSH
3561: CALL_OW 72
3565: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3566: LD_VAR 0 2
3570: PPUSH
3571: LD_INT 4
3573: PPUSH
3574: LD_INT 116
3576: PPUSH
3577: LD_INT 70
3579: PPUSH
3580: LD_INT 5
3582: PPUSH
3583: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3587: LD_VAR 0 2
3591: PPUSH
3592: LD_INT 31
3594: PPUSH
3595: LD_INT 108
3597: PPUSH
3598: LD_INT 50
3600: PPUSH
3601: LD_INT 2
3603: PPUSH
3604: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3608: LD_INT 35
3610: PPUSH
3611: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3615: LD_INT 22
3617: PUSH
3618: LD_INT 5
3620: PUSH
3621: EMPTY
3622: LIST
3623: LIST
3624: PUSH
3625: LD_INT 30
3627: PUSH
3628: LD_INT 4
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: PUSH
3635: LD_INT 3
3637: PUSH
3638: LD_INT 57
3640: PUSH
3641: EMPTY
3642: LIST
3643: PUSH
3644: EMPTY
3645: LIST
3646: LIST
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: LIST
3652: PPUSH
3653: CALL_OW 69
3657: IFFALSE 3608
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3659: LD_ADDR_VAR 0 3
3663: PUSH
3664: LD_INT 22
3666: PUSH
3667: LD_INT 5
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: PUSH
3674: LD_INT 30
3676: PUSH
3677: LD_INT 4
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: PUSH
3684: LD_INT 3
3686: PUSH
3687: LD_INT 57
3689: PUSH
3690: EMPTY
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: EMPTY
3698: LIST
3699: LIST
3700: LIST
3701: PPUSH
3702: CALL_OW 69
3706: PUSH
3707: LD_INT 1
3709: ARRAY
3710: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3711: LD_ADDR_VAR 0 2
3715: PUSH
3716: LD_EXP 39
3720: PPUSH
3721: LD_INT 25
3723: PUSH
3724: LD_INT 1
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PPUSH
3731: CALL_OW 72
3735: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3736: LD_VAR 0 2
3740: PPUSH
3741: LD_VAR 0 3
3745: PPUSH
3746: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3750: LD_INT 35
3752: PPUSH
3753: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3757: LD_INT 22
3759: PUSH
3760: LD_INT 5
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: LD_INT 30
3769: PUSH
3770: LD_INT 31
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 3
3779: PUSH
3780: LD_INT 57
3782: PUSH
3783: EMPTY
3784: LIST
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: LIST
3794: PPUSH
3795: CALL_OW 69
3799: PUSH
3800: LD_INT 2
3802: GREATEREQUAL
3803: IFFALSE 3750
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3805: LD_ADDR_VAR 0 2
3809: PUSH
3810: LD_EXP 39
3814: PPUSH
3815: LD_INT 25
3817: PUSH
3818: LD_INT 2
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: PPUSH
3825: CALL_OW 72
3829: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3830: LD_VAR 0 2
3834: PUSH
3835: LD_INT 1
3837: ARRAY
3838: PPUSH
3839: LD_INT 5
3841: PPUSH
3842: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3846: LD_VAR 0 2
3850: PUSH
3851: LD_INT 2
3853: ARRAY
3854: PUSH
3855: LD_VAR 0 2
3859: PUSH
3860: LD_INT 3
3862: ARRAY
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: LD_VAR 0 3
3872: PPUSH
3873: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3877: LD_VAR 0 2
3881: PUSH
3882: LD_INT 2
3884: ARRAY
3885: PUSH
3886: LD_VAR 0 2
3890: PUSH
3891: LD_INT 3
3893: ARRAY
3894: PUSH
3895: EMPTY
3896: LIST
3897: LIST
3898: PPUSH
3899: LD_INT 1
3901: PPUSH
3902: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3906: LD_VAR 0 2
3910: PUSH
3911: LD_INT 2
3913: ARRAY
3914: PUSH
3915: LD_VAR 0 2
3919: PUSH
3920: LD_INT 3
3922: ARRAY
3923: PUSH
3924: EMPTY
3925: LIST
3926: LIST
3927: PPUSH
3928: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3932: LD_ADDR_VAR 0 4
3936: PUSH
3937: LD_INT 22
3939: PUSH
3940: LD_INT 5
3942: PUSH
3943: EMPTY
3944: LIST
3945: LIST
3946: PUSH
3947: LD_INT 30
3949: PUSH
3950: LD_INT 31
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: PUSH
3957: EMPTY
3958: LIST
3959: LIST
3960: PPUSH
3961: CALL_OW 69
3965: ST_TO_ADDR
// for i := 1 to 2 do
3966: LD_ADDR_VAR 0 1
3970: PUSH
3971: DOUBLE
3972: LD_INT 1
3974: DEC
3975: ST_TO_ADDR
3976: LD_INT 2
3978: PUSH
3979: FOR_TO
3980: IFFALSE 4014
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3982: LD_VAR 0 2
3986: PUSH
3987: LD_VAR 0 1
3991: PUSH
3992: LD_INT 1
3994: PLUS
3995: ARRAY
3996: PPUSH
3997: LD_VAR 0 4
4001: PUSH
4002: LD_VAR 0 1
4006: ARRAY
4007: PPUSH
4008: CALL_OW 180
4012: GO 3979
4014: POP
4015: POP
// wait ( 1 1$00 ) ;
4016: LD_INT 2100
4018: PPUSH
4019: CALL_OW 67
// farmerBaseReady := true ;
4023: LD_ADDR_EXP 4
4027: PUSH
4028: LD_INT 1
4030: ST_TO_ADDR
// end ;
4031: PPOPN 4
4033: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
4034: LD_EXP 4
4038: PUSH
4039: LD_EXP 11
4043: NOT
4044: AND
4045: IFFALSE 4567
4047: GO 4049
4049: DISABLE
4050: LD_INT 0
4052: PPUSH
4053: PPUSH
4054: PPUSH
4055: PPUSH
4056: PPUSH
// begin enable ;
4057: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
4058: LD_ADDR_VAR 0 3
4062: PUSH
4063: LD_EXP 39
4067: PPUSH
4068: LD_INT 25
4070: PUSH
4071: LD_INT 1
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: PPUSH
4078: CALL_OW 72
4082: PUSH
4083: LD_EXP 36
4087: ADD
4088: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4089: LD_ADDR_VAR 0 2
4093: PUSH
4094: LD_EXP 39
4098: PPUSH
4099: LD_INT 25
4101: PUSH
4102: LD_INT 2
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PPUSH
4109: CALL_OW 72
4113: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4114: LD_ADDR_VAR 0 5
4118: PUSH
4119: LD_INT 22
4121: PUSH
4122: LD_INT 5
4124: PUSH
4125: EMPTY
4126: LIST
4127: LIST
4128: PUSH
4129: LD_INT 21
4131: PUSH
4132: LD_INT 3
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PUSH
4139: LD_INT 3
4141: PUSH
4142: LD_INT 24
4144: PUSH
4145: LD_INT 1000
4147: PUSH
4148: EMPTY
4149: LIST
4150: LIST
4151: PUSH
4152: EMPTY
4153: LIST
4154: LIST
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: LIST
4160: PPUSH
4161: CALL_OW 69
4165: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4166: LD_ADDR_VAR 0 4
4170: PUSH
4171: LD_INT 22
4173: PUSH
4174: LD_INT 5
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: PUSH
4181: LD_INT 30
4183: PUSH
4184: LD_INT 4
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: EMPTY
4192: LIST
4193: LIST
4194: PPUSH
4195: CALL_OW 69
4199: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4200: LD_VAR 0 4
4204: PUSH
4205: LD_INT 1
4207: ARRAY
4208: PPUSH
4209: CALL_OW 302
4213: IFFALSE 4277
// for i in sol do
4215: LD_ADDR_VAR 0 1
4219: PUSH
4220: LD_VAR 0 3
4224: PUSH
4225: FOR_IN
4226: IFFALSE 4275
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4228: LD_VAR 0 1
4232: PPUSH
4233: CALL_OW 256
4237: PUSH
4238: LD_INT 999
4240: LESS
4241: PUSH
4242: LD_VAR 0 1
4246: PPUSH
4247: CALL_OW 310
4251: NOT
4252: AND
4253: IFFALSE 4273
// ComEnterUnit ( i , arm [ 1 ] ) ;
4255: LD_VAR 0 1
4259: PPUSH
4260: LD_VAR 0 4
4264: PUSH
4265: LD_INT 1
4267: ARRAY
4268: PPUSH
4269: CALL_OW 120
4273: GO 4225
4275: POP
4276: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4277: LD_VAR 0 2
4281: NOT
4282: PUSH
4283: LD_INT 22
4285: PUSH
4286: LD_INT 1
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: LD_INT 21
4295: PUSH
4296: LD_INT 1
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: PUSH
4303: EMPTY
4304: LIST
4305: LIST
4306: PPUSH
4307: CALL_OW 69
4311: NOT
4312: AND
4313: IFFALSE 4405
// begin uc_side := 5 ;
4315: LD_ADDR_OWVAR 20
4319: PUSH
4320: LD_INT 5
4322: ST_TO_ADDR
// uc_nation := 2 ;
4323: LD_ADDR_OWVAR 21
4327: PUSH
4328: LD_INT 2
4330: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4331: LD_INT 0
4333: PPUSH
4334: LD_INT 2
4336: PPUSH
4337: LD_INT 2
4339: PPUSH
4340: CALL_OW 380
// eng := CreateHuman ;
4344: LD_ADDR_VAR 0 2
4348: PUSH
4349: CALL_OW 44
4353: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4354: LD_VAR 0 2
4358: PPUSH
4359: LD_INT 102
4361: PPUSH
4362: LD_INT 8
4364: PPUSH
4365: LD_INT 0
4367: PPUSH
4368: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4372: LD_VAR 0 2
4376: PPUSH
4377: LD_INT 110
4379: PPUSH
4380: LD_INT 60
4382: PPUSH
4383: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4387: LD_ADDR_EXP 39
4391: PUSH
4392: LD_EXP 39
4396: PUSH
4397: LD_VAR 0 2
4401: UNION
4402: ST_TO_ADDR
// end else
4403: GO 4567
// begin for i in eng do
4405: LD_ADDR_VAR 0 1
4409: PUSH
4410: LD_VAR 0 2
4414: PUSH
4415: FOR_IN
4416: IFFALSE 4565
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4418: LD_INT 10
4420: PPUSH
4421: LD_INT 1
4423: PPUSH
4424: CALL_OW 287
4428: IFFALSE 4479
// begin if IsInUnit ( i ) then
4430: LD_VAR 0 1
4434: PPUSH
4435: CALL_OW 310
4439: IFFALSE 4450
// ComExitBuilding ( i ) ;
4441: LD_VAR 0 1
4445: PPUSH
4446: CALL_OW 122
// if not IsInArea ( i , collectFarmerArea ) then
4450: LD_VAR 0 1
4454: PPUSH
4455: LD_INT 10
4457: PPUSH
4458: CALL_OW 308
4462: NOT
4463: IFFALSE 4477
// AddComMoveToArea ( i , collectFarmerArea ) ;
4465: LD_VAR 0 1
4469: PPUSH
4470: LD_INT 10
4472: PPUSH
4473: CALL_OW 173
// end else
4477: GO 4563
// begin if damagedBuilding then
4479: LD_VAR 0 5
4483: IFFALSE 4527
// begin if IsInUnit ( i ) then
4485: LD_VAR 0 1
4489: PPUSH
4490: CALL_OW 310
4494: IFFALSE 4507
// ComExitBuilding ( i ) else
4496: LD_VAR 0 1
4500: PPUSH
4501: CALL_OW 122
4505: GO 4525
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4507: LD_VAR 0 1
4511: PPUSH
4512: LD_VAR 0 5
4516: PUSH
4517: LD_INT 1
4519: ARRAY
4520: PPUSH
4521: CALL_OW 130
// end else
4525: GO 4563
// if not IsInUnit ( i ) and not HasTask ( i ) then
4527: LD_VAR 0 1
4531: PPUSH
4532: CALL_OW 310
4536: NOT
4537: PUSH
4538: LD_VAR 0 1
4542: PPUSH
4543: CALL_OW 314
4547: NOT
4548: AND
4549: IFFALSE 4563
// ComEnterUnit ( i , arDepot ) ;
4551: LD_VAR 0 1
4555: PPUSH
4556: LD_INT 5
4558: PPUSH
4559: CALL_OW 120
// end ; end ;
4563: GO 4415
4565: POP
4566: POP
// end ; end ;
4567: PPOPN 5
4569: END
// export function StartCargoEvacuation ; begin
4570: LD_INT 0
4572: PPUSH
// while omarCargoCounter > 0 do
4573: LD_EXP 21
4577: PUSH
4578: LD_INT 0
4580: GREATER
4581: IFFALSE 4898
// begin wait ( 0 0$40 ) ;
4583: LD_INT 1400
4585: PPUSH
4586: CALL_OW 67
// omarCargo := PrepareCargo ;
4590: LD_ADDR_EXP 43
4594: PUSH
4595: CALL 4903 0 0
4599: ST_TO_ADDR
// SetTag ( omarCargo , 0 ) ;
4600: LD_EXP 43
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 109
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4612: LD_EXP 43
4616: PPUSH
4617: LD_INT 107
4619: PPUSH
4620: LD_INT 59
4622: PPUSH
4623: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4627: LD_INT 35
4629: PPUSH
4630: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4634: LD_EXP 43
4638: PPUSH
4639: LD_INT 107
4641: PPUSH
4642: LD_INT 59
4644: PPUSH
4645: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4649: LD_EXP 43
4653: PPUSH
4654: CALL_OW 302
4658: NOT
4659: PUSH
4660: LD_EXP 43
4664: PPUSH
4665: CALL_OW 301
4669: OR
4670: IFFALSE 4674
// continue ;
4672: GO 4627
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4674: LD_EXP 43
4678: PPUSH
4679: LD_INT 107
4681: PPUSH
4682: LD_INT 59
4684: PPUSH
4685: CALL_OW 307
4689: PUSH
4690: LD_EXP 43
4694: PPUSH
4695: LD_INT 5
4697: PPUSH
4698: CALL_OW 296
4702: PUSH
4703: LD_INT 6
4705: LESS
4706: OR
4707: IFFALSE 4627
// SetTag ( omarCargo , 1 ) ;
4709: LD_EXP 43
4713: PPUSH
4714: LD_INT 1
4716: PPUSH
4717: CALL_OW 109
// wait ( 0 0$05 ) ;
4721: LD_INT 175
4723: PPUSH
4724: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4728: LD_EXP 43
4732: PPUSH
4733: LD_INT 5
4735: PPUSH
4736: LD_INT 1
4738: PPUSH
4739: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4743: LD_EXP 43
4747: PPUSH
4748: LD_INT 103
4750: PPUSH
4751: LD_INT 9
4753: PPUSH
4754: CALL_OW 171
// wait ( 0 0$1 ) ;
4758: LD_INT 35
4760: PPUSH
4761: CALL_OW 67
// SetCargo ( omarCargo , mat_cans , 100 ) ;
4765: LD_EXP 43
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 100
4775: PPUSH
4776: CALL_OW 290
// repeat wait ( 0 0$1 ) ;
4780: LD_INT 35
4782: PPUSH
4783: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4787: LD_EXP 43
4791: PPUSH
4792: LD_INT 103
4794: PPUSH
4795: LD_INT 9
4797: PPUSH
4798: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4802: LD_EXP 43
4806: PPUSH
4807: CALL_OW 302
4811: NOT
4812: PUSH
4813: LD_EXP 43
4817: PPUSH
4818: CALL_OW 301
4822: OR
4823: IFFALSE 4827
// continue ;
4825: GO 4780
// until ( IsAt ( omarCargo , 103 , 9 ) or IsInArea ( omarCargo , northRoad ) ) and GetTag ( omarCargo ) > 0 ;
4827: LD_EXP 43
4831: PPUSH
4832: LD_INT 103
4834: PPUSH
4835: LD_INT 9
4837: PPUSH
4838: CALL_OW 307
4842: PUSH
4843: LD_EXP 43
4847: PPUSH
4848: LD_INT 3
4850: PPUSH
4851: CALL_OW 308
4855: OR
4856: PUSH
4857: LD_EXP 43
4861: PPUSH
4862: CALL_OW 110
4866: PUSH
4867: LD_INT 0
4869: GREATER
4870: AND
4871: IFFALSE 4780
// RemoveUnit ( omarCargo ) ;
4873: LD_EXP 43
4877: PPUSH
4878: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4882: LD_ADDR_EXP 21
4886: PUSH
4887: LD_EXP 21
4891: PUSH
4892: LD_INT 1
4894: MINUS
4895: ST_TO_ADDR
// end ;
4896: GO 4573
// end ;
4898: LD_VAR 0 1
4902: RET
// export function PrepareCargo ; var un , veh ; begin
4903: LD_INT 0
4905: PPUSH
4906: PPUSH
4907: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4908: LD_ADDR_VAR 0 3
4912: PUSH
4913: LD_INT 5
4915: PPUSH
4916: LD_INT 2
4918: PPUSH
4919: LD_INT 13
4921: PPUSH
4922: LD_INT 1
4924: PPUSH
4925: LD_INT 1
4927: PPUSH
4928: LD_INT 32
4930: PPUSH
4931: LD_INT 80
4933: PPUSH
4934: CALL 376 0 7
4938: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4939: LD_VAR 0 3
4943: PPUSH
4944: LD_INT 4
4946: PPUSH
4947: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4951: LD_VAR 0 3
4955: PPUSH
4956: LD_INT 101
4958: PPUSH
4959: LD_INT 8
4961: PPUSH
4962: LD_INT 0
4964: PPUSH
4965: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4969: LD_INT 0
4971: PPUSH
4972: LD_INT 3
4974: PPUSH
4975: LD_INT 2
4977: PPUSH
4978: CALL_OW 380
// un := CreateHuman ;
4982: LD_ADDR_VAR 0 2
4986: PUSH
4987: CALL_OW 44
4991: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4992: LD_VAR 0 2
4996: PPUSH
4997: LD_VAR 0 3
5001: PPUSH
5002: CALL_OW 52
// result := veh ;
5006: LD_ADDR_VAR 0 1
5010: PUSH
5011: LD_VAR 0 3
5015: ST_TO_ADDR
// end ; end_of_file
5016: LD_VAR 0 1
5020: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
5021: LD_INT 0
5023: PPUSH
5024: PPUSH
5025: PPUSH
// usForces := [ ] ;
5026: LD_ADDR_EXP 44
5030: PUSH
5031: EMPTY
5032: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
5033: LD_ADDR_EXP 46
5037: PUSH
5038: LD_INT 6
5040: PUSH
5041: LD_INT 32
5043: PUSH
5044: LD_INT 27
5046: PUSH
5047: LD_INT 1
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 4
5058: PUSH
5059: LD_INT 43
5061: PUSH
5062: LD_INT 24
5064: PUSH
5065: LD_INT 5
5067: PUSH
5068: EMPTY
5069: LIST
5070: LIST
5071: LIST
5072: LIST
5073: PUSH
5074: LD_INT 27
5076: PUSH
5077: LD_INT 29
5079: PUSH
5080: LD_INT 21
5082: PUSH
5083: LD_INT 0
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: LIST
5090: LIST
5091: PUSH
5092: EMPTY
5093: LIST
5094: LIST
5095: LIST
5096: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
5097: LD_INT 11
5099: PPUSH
5100: CALL_OW 274
5104: PPUSH
5105: LD_INT 1
5107: PPUSH
5108: LD_INT 150
5110: PUSH
5111: LD_INT 120
5113: PUSH
5114: LD_INT 100
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: LIST
5121: PUSH
5122: LD_OWVAR 67
5126: ARRAY
5127: PPUSH
5128: CALL_OW 277
// if Difficulty = 1 then
5132: LD_OWVAR 67
5136: PUSH
5137: LD_INT 1
5139: EQUAL
5140: IFFALSE 5149
// RemoveUnit ( hillBun ) ;
5142: LD_INT 14
5144: PPUSH
5145: CALL_OW 64
// uc_side := 1 ;
5149: LD_ADDR_OWVAR 20
5153: PUSH
5154: LD_INT 1
5156: ST_TO_ADDR
// uc_nation := 1 ;
5157: LD_ADDR_OWVAR 21
5161: PUSH
5162: LD_INT 1
5164: ST_TO_ADDR
// hc_gallery :=  ;
5165: LD_ADDR_OWVAR 33
5169: PUSH
5170: LD_STRING 
5172: ST_TO_ADDR
// hc_name :=  ;
5173: LD_ADDR_OWVAR 26
5177: PUSH
5178: LD_STRING 
5180: ST_TO_ADDR
// hc_importance := 0 ;
5181: LD_ADDR_OWVAR 32
5185: PUSH
5186: LD_INT 0
5188: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5189: LD_INT 1
5191: PPUSH
5192: LD_INT 1
5194: PPUSH
5195: LD_INT 3
5197: PPUSH
5198: CALL_OW 380
// usCommander := CreateHuman ;
5202: LD_ADDR_EXP 45
5206: PUSH
5207: CALL_OW 44
5211: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5212: LD_EXP 45
5216: PPUSH
5217: LD_INT 11
5219: PPUSH
5220: CALL_OW 52
// if Difficulty > 1 then
5224: LD_OWVAR 67
5228: PUSH
5229: LD_INT 1
5231: GREATER
5232: IFFALSE 5314
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5234: LD_INT 0
5236: PPUSH
5237: LD_INT 1
5239: PPUSH
5240: LD_INT 1
5242: PUSH
5243: LD_INT 2
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: LIST
5253: PUSH
5254: LD_OWVAR 67
5258: ARRAY
5259: PPUSH
5260: CALL_OW 380
// un := CreateHuman ;
5264: LD_ADDR_VAR 0 3
5268: PUSH
5269: CALL_OW 44
5273: ST_TO_ADDR
// usForces := usForces union un ;
5274: LD_ADDR_EXP 44
5278: PUSH
5279: LD_EXP 44
5283: PUSH
5284: LD_VAR 0 3
5288: UNION
5289: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5290: LD_VAR 0 3
5294: PPUSH
5295: LD_INT 1
5297: PPUSH
5298: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5302: LD_VAR 0 3
5306: PPUSH
5307: LD_INT 14
5309: PPUSH
5310: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5314: LD_ADDR_VAR 0 2
5318: PUSH
5319: DOUBLE
5320: LD_INT 1
5322: DEC
5323: ST_TO_ADDR
5324: LD_INT 2
5326: PUSH
5327: LD_INT 3
5329: PUSH
5330: LD_INT 4
5332: PUSH
5333: EMPTY
5334: LIST
5335: LIST
5336: LIST
5337: PUSH
5338: LD_OWVAR 67
5342: ARRAY
5343: PUSH
5344: FOR_TO
5345: IFFALSE 5487
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5347: LD_INT 0
5349: PPUSH
5350: LD_INT 1
5352: PPUSH
5353: LD_INT 1
5355: PUSH
5356: LD_INT 2
5358: PUSH
5359: LD_INT 3
5361: PUSH
5362: EMPTY
5363: LIST
5364: LIST
5365: LIST
5366: PUSH
5367: LD_OWVAR 67
5371: ARRAY
5372: PPUSH
5373: CALL_OW 380
// un := CreateHuman ;
5377: LD_ADDR_VAR 0 3
5381: PUSH
5382: CALL_OW 44
5386: ST_TO_ADDR
// usForces := usForces union un ;
5387: LD_ADDR_EXP 44
5391: PUSH
5392: LD_EXP 44
5396: PUSH
5397: LD_VAR 0 3
5401: UNION
5402: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5403: LD_VAR 0 3
5407: PPUSH
5408: LD_INT 39
5410: PPUSH
5411: LD_INT 24
5413: PPUSH
5414: LD_INT 4
5416: PPUSH
5417: LD_INT 0
5419: PPUSH
5420: CALL_OW 50
// if i < 3 then
5424: LD_VAR 0 2
5428: PUSH
5429: LD_INT 3
5431: LESS
5432: IFFALSE 5485
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5434: LD_VAR 0 3
5438: PPUSH
5439: LD_INT 22
5441: PUSH
5442: LD_INT 1
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 58
5451: PUSH
5452: EMPTY
5453: LIST
5454: PUSH
5455: LD_INT 30
5457: PUSH
5458: LD_INT 31
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: LIST
5469: PPUSH
5470: CALL_OW 69
5474: PUSH
5475: LD_VAR 0 2
5479: ARRAY
5480: PPUSH
5481: CALL_OW 120
// end ;
5485: GO 5344
5487: POP
5488: POP
// for i := 1 to 2 do
5489: LD_ADDR_VAR 0 2
5493: PUSH
5494: DOUBLE
5495: LD_INT 1
5497: DEC
5498: ST_TO_ADDR
5499: LD_INT 2
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5567
// begin PrepareHuman ( false , 2 , 2 ) ;
5505: LD_INT 0
5507: PPUSH
5508: LD_INT 2
5510: PPUSH
5511: LD_INT 2
5513: PPUSH
5514: CALL_OW 380
// un := CreateHuman ;
5518: LD_ADDR_VAR 0 3
5522: PUSH
5523: CALL_OW 44
5527: ST_TO_ADDR
// usForces := usForces union un ;
5528: LD_ADDR_EXP 44
5532: PUSH
5533: LD_EXP 44
5537: PUSH
5538: LD_VAR 0 3
5542: UNION
5543: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5544: LD_VAR 0 3
5548: PPUSH
5549: LD_INT 39
5551: PPUSH
5552: LD_INT 24
5554: PPUSH
5555: LD_INT 4
5557: PPUSH
5558: LD_INT 0
5560: PPUSH
5561: CALL_OW 50
// end ;
5565: GO 5502
5567: POP
5568: POP
// PrepareHuman ( false , 4 , 1 ) ;
5569: LD_INT 0
5571: PPUSH
5572: LD_INT 4
5574: PPUSH
5575: LD_INT 1
5577: PPUSH
5578: CALL_OW 380
// un := CreateHuman ;
5582: LD_ADDR_VAR 0 3
5586: PUSH
5587: CALL_OW 44
5591: ST_TO_ADDR
// usForces := usForces union un ;
5592: LD_ADDR_EXP 44
5596: PUSH
5597: LD_EXP 44
5601: PUSH
5602: LD_VAR 0 3
5606: UNION
5607: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5608: LD_VAR 0 3
5612: PPUSH
5613: LD_INT 39
5615: PPUSH
5616: LD_INT 24
5618: PPUSH
5619: LD_INT 4
5621: PPUSH
5622: LD_INT 0
5624: PPUSH
5625: CALL_OW 50
// end ;
5629: LD_VAR 0 1
5633: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured and not americanStartRun do var i , b , eng , sol , sci ;
5634: LD_EXP 44
5638: PUSH
5639: LD_EXP 6
5643: NOT
5644: AND
5645: PUSH
5646: LD_EXP 14
5650: NOT
5651: AND
5652: IFFALSE 6083
5654: GO 5656
5656: DISABLE
5657: LD_INT 0
5659: PPUSH
5660: PPUSH
5661: PPUSH
5662: PPUSH
5663: PPUSH
// begin enable ;
5664: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5665: LD_ADDR_VAR 0 3
5669: PUSH
5670: LD_EXP 44
5674: PPUSH
5675: LD_INT 25
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PPUSH
5685: CALL_OW 72
5689: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5690: LD_ADDR_VAR 0 4
5694: PUSH
5695: LD_EXP 44
5699: PPUSH
5700: LD_INT 25
5702: PUSH
5703: LD_INT 1
5705: PUSH
5706: EMPTY
5707: LIST
5708: LIST
5709: PPUSH
5710: CALL_OW 72
5714: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5715: LD_ADDR_VAR 0 5
5719: PUSH
5720: LD_EXP 44
5724: PPUSH
5725: LD_INT 25
5727: PUSH
5728: LD_INT 4
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: PPUSH
5735: CALL_OW 72
5739: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5740: LD_INT 7
5742: PPUSH
5743: LD_INT 22
5745: PUSH
5746: LD_INT 2
5748: PUSH
5749: EMPTY
5750: LIST
5751: LIST
5752: PPUSH
5753: CALL_OW 70
5757: PUSH
5758: LD_INT 1
5760: EQUAL
5761: IFFALSE 5837
// for i in sol do
5763: LD_ADDR_VAR 0 1
5767: PUSH
5768: LD_VAR 0 4
5772: PUSH
5773: FOR_IN
5774: IFFALSE 5835
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5776: LD_VAR 0 1
5780: PPUSH
5781: CALL_OW 310
5785: NOT
5786: PUSH
5787: LD_VAR 0 1
5791: PPUSH
5792: CALL_OW 310
5796: PPUSH
5797: CALL_OW 266
5801: PUSH
5802: LD_INT 4
5804: EQUAL
5805: NOT
5806: OR
5807: IFFALSE 5833
// begin ComExitBuilding ( i ) ;
5809: LD_VAR 0 1
5813: PPUSH
5814: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5818: LD_VAR 0 1
5822: PPUSH
5823: LD_INT 37
5825: PPUSH
5826: LD_INT 23
5828: PPUSH
5829: CALL_OW 174
// end ;
5833: GO 5773
5835: POP
5836: POP
// if eng then
5837: LD_VAR 0 3
5841: IFFALSE 6083
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 22
5850: PUSH
5851: LD_INT 1
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 95
5860: PUSH
5861: LD_INT 7
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 21
5870: PUSH
5871: LD_INT 3
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 3
5880: PUSH
5881: LD_INT 24
5883: PUSH
5884: LD_INT 1000
5886: PUSH
5887: EMPTY
5888: LIST
5889: LIST
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: PPUSH
5901: CALL_OW 69
5905: ST_TO_ADDR
// if b then
5906: LD_VAR 0 2
5910: IFFALSE 5941
// begin ComExitBuilding ( eng ) ;
5912: LD_VAR 0 3
5916: PPUSH
5917: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5921: LD_VAR 0 3
5925: PPUSH
5926: LD_VAR 0 2
5930: PUSH
5931: LD_INT 1
5933: ARRAY
5934: PPUSH
5935: CALL_OW 190
// end else
5939: GO 6083
// begin for i in eng do
5941: LD_ADDR_VAR 0 1
5945: PUSH
5946: LD_VAR 0 3
5950: PUSH
5951: FOR_IN
5952: IFFALSE 6081
// if not HasTask ( i ) then
5954: LD_VAR 0 1
5958: PPUSH
5959: CALL_OW 314
5963: NOT
5964: IFFALSE 6079
// begin if americanBuildList then
5966: LD_EXP 46
5970: IFFALSE 6055
// begin if IsInUnit ( i ) then
5972: LD_VAR 0 1
5976: PPUSH
5977: CALL_OW 310
5981: IFFALSE 5992
// ComExitBuilding ( i ) ;
5983: LD_VAR 0 1
5987: PPUSH
5988: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5992: LD_VAR 0 1
5996: PPUSH
5997: LD_EXP 46
6001: PUSH
6002: LD_INT 1
6004: ARRAY
6005: PUSH
6006: LD_INT 1
6008: ARRAY
6009: PPUSH
6010: LD_EXP 46
6014: PUSH
6015: LD_INT 1
6017: ARRAY
6018: PUSH
6019: LD_INT 2
6021: ARRAY
6022: PPUSH
6023: LD_EXP 46
6027: PUSH
6028: LD_INT 1
6030: ARRAY
6031: PUSH
6032: LD_INT 3
6034: ARRAY
6035: PPUSH
6036: LD_EXP 46
6040: PUSH
6041: LD_INT 1
6043: ARRAY
6044: PUSH
6045: LD_INT 4
6047: ARRAY
6048: PPUSH
6049: CALL_OW 205
// end else
6053: GO 6079
// if not IsInUnit ( i ) then
6055: LD_VAR 0 1
6059: PPUSH
6060: CALL_OW 310
6064: NOT
6065: IFFALSE 6079
// ComEnterUnit ( i , usDepot ) ;
6067: LD_VAR 0 1
6071: PPUSH
6072: LD_INT 11
6074: PPUSH
6075: CALL_OW 120
// end ;
6079: GO 5951
6081: POP
6082: POP
// end ; end ; end ;
6083: PPOPN 5
6085: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
6086: LD_INT 0
6088: PPUSH
6089: PPUSH
6090: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
6091: LD_ADDR_VAR 0 3
6095: PUSH
6096: LD_INT 35
6098: PUSH
6099: LD_INT 45
6101: PUSH
6102: LD_INT 48
6104: PUSH
6105: LD_EXP 57
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: LIST
6115: ST_TO_ADDR
// for i in tech do
6116: LD_ADDR_VAR 0 4
6120: PUSH
6121: LD_VAR 0 3
6125: PUSH
6126: FOR_IN
6127: IFFALSE 6145
// AddComResearch ( lab , i ) ;
6129: LD_VAR 0 1
6133: PPUSH
6134: LD_VAR 0 4
6138: PPUSH
6139: CALL_OW 184
6143: GO 6126
6145: POP
6146: POP
// end ;
6147: LD_VAR 0 2
6151: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
6152: LD_EXP 12
6156: PUSH
6157: LD_EXP 23
6161: PUSH
6162: LD_EXP 27
6166: LESSEQUAL
6167: AND
6168: IFFALSE 6193
6170: GO 6172
6172: DISABLE
// begin enable ;
6173: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6174: LD_INT 35
6176: PPUSH
6177: LD_INT 2065
6179: PPUSH
6180: CALL_OW 12
6184: PPUSH
6185: CALL_OW 67
// SendConvoy ;
6189: CALL 6291 0 0
// end ;
6193: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6194: LD_EXP 6
6198: PUSH
6199: LD_EXP 18
6203: AND
6204: IFFALSE 6290
6206: GO 6208
6208: DISABLE
// begin if americanHasEscaped then
6209: LD_EXP 8
6213: IFFALSE 6224
// wait ( 3 3$20 ) else
6215: LD_INT 7000
6217: PPUSH
6218: CALL_OW 67
6222: GO 6231
// wait ( 6 6$40 ) ;
6224: LD_INT 14000
6226: PPUSH
6227: CALL_OW 67
// SendAttack ;
6231: CALL 7034 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6235: LD_INT 14000
6237: PUSH
6238: LD_INT 11900
6240: PUSH
6241: LD_INT 9800
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: LIST
6248: PUSH
6249: LD_OWVAR 67
6253: ARRAY
6254: PPUSH
6255: CALL_OW 67
// SendAttack ;
6259: CALL 7034 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6263: LD_EXP 19
6267: PUSH
6268: LD_INT 6
6270: PUSH
6271: LD_INT 7
6273: PUSH
6274: LD_INT 8
6276: PUSH
6277: EMPTY
6278: LIST
6279: LIST
6280: LIST
6281: PUSH
6282: LD_OWVAR 67
6286: ARRAY
6287: LESS
6288: IFFALSE 6235
// end ;
6290: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6291: LD_INT 0
6293: PPUSH
6294: PPUSH
6295: PPUSH
6296: PPUSH
6297: PPUSH
6298: PPUSH
6299: PPUSH
6300: PPUSH
// road := rand ( 1 , 2 ) ;
6301: LD_ADDR_VAR 0 4
6305: PUSH
6306: LD_INT 1
6308: PPUSH
6309: LD_INT 2
6311: PPUSH
6312: CALL_OW 12
6316: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6317: LD_ADDR_VAR 0 8
6321: PUSH
6322: LD_INT 3
6324: PUSH
6325: LD_INT 8
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: PUSH
6332: LD_VAR 0 4
6336: ARRAY
6337: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6338: LD_ADDR_VAR 0 5
6342: PUSH
6343: LD_INT 35
6345: PUSH
6346: LD_INT 66
6348: PUSH
6349: LD_INT 1
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: LIST
6356: PUSH
6357: LD_INT 101
6359: PUSH
6360: LD_INT 8
6362: PUSH
6363: LD_INT 4
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: LIST
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6375: LD_ADDR_VAR 0 6
6379: PUSH
6380: LD_INT 34
6382: PUSH
6383: LD_INT 67
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: PUSH
6390: LD_INT 38
6392: PUSH
6393: LD_INT 62
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: PUSH
6400: LD_INT 43
6402: PUSH
6403: LD_INT 54
6405: PUSH
6406: EMPTY
6407: LIST
6408: LIST
6409: PUSH
6410: LD_INT 57
6412: PUSH
6413: LD_INT 57
6415: PUSH
6416: EMPTY
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 77
6422: PUSH
6423: LD_INT 71
6425: PUSH
6426: EMPTY
6427: LIST
6428: LIST
6429: PUSH
6430: LD_INT 86
6432: PUSH
6433: LD_INT 60
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: LD_INT 89
6442: PUSH
6443: LD_INT 35
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: PUSH
6450: LD_INT 93
6452: PUSH
6453: LD_INT 17
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 97
6462: PUSH
6463: LD_INT 10
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: PUSH
6470: LD_INT 103
6472: PUSH
6473: LD_INT 9
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: LIST
6490: LIST
6491: ST_TO_ADDR
// if road = 2 then
6492: LD_VAR 0 4
6496: PUSH
6497: LD_INT 2
6499: EQUAL
6500: IFFALSE 6517
// points := ReverseArray ( points ) ;
6502: LD_ADDR_VAR 0 6
6506: PUSH
6507: LD_VAR 0 6
6511: PPUSH
6512: CALL 1064 0 1
6516: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6517: LD_INT 4
6519: PPUSH
6520: LD_INT 1
6522: PPUSH
6523: LD_INT 2
6525: PPUSH
6526: LD_INT 1
6528: PPUSH
6529: LD_INT 1
6531: PPUSH
6532: LD_INT 12
6534: PPUSH
6535: LD_INT 80
6537: PPUSH
6538: CALL 376 0 7
// veh := CreateVehicle ;
6542: LD_ADDR_VAR 0 3
6546: PUSH
6547: CALL_OW 45
6551: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6552: LD_VAR 0 3
6556: PPUSH
6557: LD_VAR 0 5
6561: PUSH
6562: LD_VAR 0 4
6566: ARRAY
6567: PUSH
6568: LD_INT 3
6570: ARRAY
6571: PPUSH
6572: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6576: LD_VAR 0 3
6580: PPUSH
6581: LD_VAR 0 5
6585: PUSH
6586: LD_VAR 0 4
6590: ARRAY
6591: PUSH
6592: LD_INT 1
6594: ARRAY
6595: PPUSH
6596: LD_VAR 0 5
6600: PUSH
6601: LD_VAR 0 4
6605: ARRAY
6606: PUSH
6607: LD_INT 2
6609: ARRAY
6610: PPUSH
6611: LD_INT 0
6613: PPUSH
6614: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6618: LD_INT 0
6620: PPUSH
6621: LD_INT 1
6623: PPUSH
6624: LD_OWVAR 67
6628: PPUSH
6629: CALL_OW 380
// un := CreateHuman ;
6633: LD_ADDR_VAR 0 2
6637: PUSH
6638: CALL_OW 44
6642: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6643: LD_VAR 0 2
6647: PPUSH
6648: LD_VAR 0 3
6652: PPUSH
6653: CALL_OW 52
// if ( Prob ( [ 60 , 56 , 52 ] [ Difficulty ] ) + tick mod 30 ) or convoyCounter < 4 then
6657: LD_INT 60
6659: PUSH
6660: LD_INT 56
6662: PUSH
6663: LD_INT 52
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: LIST
6670: PUSH
6671: LD_OWVAR 67
6675: ARRAY
6676: PPUSH
6677: CALL_OW 13
6681: PUSH
6682: LD_OWVAR 1
6686: PUSH
6687: LD_INT 30
6689: MOD
6690: PLUS
6691: PUSH
6692: LD_EXP 23
6696: PUSH
6697: LD_INT 4
6699: LESS
6700: OR
6701: IFFALSE 6718
// SetCargo ( veh , mat_cans , 100 ) ;
6703: LD_VAR 0 3
6707: PPUSH
6708: LD_INT 1
6710: PPUSH
6711: LD_INT 100
6713: PPUSH
6714: CALL_OW 290
// for i := 2 to points do
6718: LD_ADDR_VAR 0 7
6722: PUSH
6723: DOUBLE
6724: LD_INT 2
6726: DEC
6727: ST_TO_ADDR
6728: LD_VAR 0 6
6732: PUSH
6733: FOR_TO
6734: IFFALSE 6777
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6736: LD_VAR 0 3
6740: PPUSH
6741: LD_VAR 0 6
6745: PUSH
6746: LD_VAR 0 7
6750: ARRAY
6751: PUSH
6752: LD_INT 1
6754: ARRAY
6755: PPUSH
6756: LD_VAR 0 6
6760: PUSH
6761: LD_VAR 0 7
6765: ARRAY
6766: PUSH
6767: LD_INT 2
6769: ARRAY
6770: PPUSH
6771: CALL_OW 171
6775: GO 6733
6777: POP
6778: POP
// convoyCounter := convoyCounter + 1 ;
6779: LD_ADDR_EXP 23
6783: PUSH
6784: LD_EXP 23
6788: PUSH
6789: LD_INT 1
6791: PLUS
6792: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6793: LD_INT 35
6795: PPUSH
6796: CALL_OW 67
// if not HasTask ( veh ) and IsOk ( veh ) then
6800: LD_VAR 0 3
6804: PPUSH
6805: CALL_OW 314
6809: NOT
6810: PUSH
6811: LD_VAR 0 3
6815: PPUSH
6816: CALL_OW 302
6820: AND
6821: IFFALSE 6862
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6823: LD_VAR 0 3
6827: PPUSH
6828: LD_VAR 0 6
6832: PUSH
6833: LD_VAR 0 6
6837: ARRAY
6838: PUSH
6839: LD_INT 1
6841: ARRAY
6842: PPUSH
6843: LD_VAR 0 6
6847: PUSH
6848: LD_VAR 0 6
6852: ARRAY
6853: PUSH
6854: LD_INT 2
6856: ARRAY
6857: PPUSH
6858: CALL_OW 111
// if not IsInUnit ( un ) then
6862: LD_VAR 0 2
6866: PPUSH
6867: CALL_OW 310
6871: NOT
6872: IFFALSE 6913
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6874: LD_VAR 0 2
6878: PPUSH
6879: LD_VAR 0 6
6883: PUSH
6884: LD_VAR 0 6
6888: ARRAY
6889: PUSH
6890: LD_INT 1
6892: ARRAY
6893: PPUSH
6894: LD_VAR 0 6
6898: PUSH
6899: LD_VAR 0 6
6903: ARRAY
6904: PUSH
6905: LD_INT 2
6907: ARRAY
6908: PPUSH
6909: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6913: LD_VAR 0 3
6917: PPUSH
6918: LD_VAR 0 8
6922: PPUSH
6923: CALL_OW 308
6927: PUSH
6928: LD_VAR 0 2
6932: PPUSH
6933: LD_VAR 0 8
6937: PPUSH
6938: CALL_OW 308
6942: OR
6943: IFFALSE 6793
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6945: LD_VAR 0 2
6949: PPUSH
6950: CALL_OW 302
6954: PUSH
6955: LD_VAR 0 3
6959: PPUSH
6960: CALL_OW 302
6964: NOT
6965: AND
6966: PUSH
6967: LD_VAR 0 2
6971: PPUSH
6972: LD_VAR 0 8
6976: PPUSH
6977: CALL_OW 308
6981: AND
6982: IFFALSE 6993
// RemoveUnit ( un ) ;
6984: LD_VAR 0 2
6988: PPUSH
6989: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6993: LD_VAR 0 3
6997: PPUSH
6998: LD_VAR 0 8
7002: PPUSH
7003: CALL_OW 308
7007: PUSH
7008: LD_VAR 0 3
7012: PPUSH
7013: CALL_OW 302
7017: AND
7018: IFFALSE 7029
// RemoveUnit ( veh ) ;
7020: LD_VAR 0 3
7024: PPUSH
7025: CALL_OW 64
// end ;
7029: LD_VAR 0 1
7033: RET
// export function SendAttack ; var un , veh , i ; begin
7034: LD_INT 0
7036: PPUSH
7037: PPUSH
7038: PPUSH
7039: PPUSH
// IncomingAttack ;
7040: CALL 15565 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
7044: LD_INT 2100
7046: PPUSH
7047: LD_INT 3500
7049: PPUSH
7050: CALL_OW 12
7054: PPUSH
7055: CALL_OW 67
// for i := 1 to [ 3 , 4 , 4 ] [ Difficulty ] + attackWave div 3 do
7059: LD_ADDR_VAR 0 4
7063: PUSH
7064: DOUBLE
7065: LD_INT 1
7067: DEC
7068: ST_TO_ADDR
7069: LD_INT 3
7071: PUSH
7072: LD_INT 4
7074: PUSH
7075: LD_INT 4
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: LIST
7082: PUSH
7083: LD_OWVAR 67
7087: ARRAY
7088: PUSH
7089: LD_EXP 19
7093: PUSH
7094: LD_INT 3
7096: DIV
7097: PLUS
7098: PUSH
7099: FOR_TO
7100: IFFALSE 7212
// begin uc_side := 1 ;
7102: LD_ADDR_OWVAR 20
7106: PUSH
7107: LD_INT 1
7109: ST_TO_ADDR
// uc_nation := 1 ;
7110: LD_ADDR_OWVAR 21
7114: PUSH
7115: LD_INT 1
7117: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
7118: LD_INT 0
7120: PPUSH
7121: LD_INT 1
7123: PPUSH
7124: LD_INT 2
7126: PUSH
7127: LD_INT 3
7129: PUSH
7130: LD_INT 4
7132: PUSH
7133: EMPTY
7134: LIST
7135: LIST
7136: LIST
7137: PUSH
7138: LD_OWVAR 67
7142: ARRAY
7143: PPUSH
7144: CALL_OW 380
// un := CreateHuman ;
7148: LD_ADDR_VAR 0 2
7152: PUSH
7153: CALL_OW 44
7157: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7158: LD_VAR 0 2
7162: PPUSH
7163: LD_INT 37
7165: PPUSH
7166: LD_INT 70
7168: PPUSH
7169: LD_INT 3
7171: PPUSH
7172: LD_INT 0
7174: PPUSH
7175: CALL_OW 50
// usAttackers := usAttackers union un ;
7179: LD_ADDR_EXP 47
7183: PUSH
7184: LD_EXP 47
7188: PUSH
7189: LD_VAR 0 2
7193: UNION
7194: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7195: LD_VAR 0 2
7199: PPUSH
7200: LD_INT 40
7202: PPUSH
7203: LD_INT 65
7205: PPUSH
7206: CALL_OW 111
// end ;
7210: GO 7099
7212: POP
7213: POP
// uc_side := 1 ;
7214: LD_ADDR_OWVAR 20
7218: PUSH
7219: LD_INT 1
7221: ST_TO_ADDR
// uc_nation := 1 ;
7222: LD_ADDR_OWVAR 21
7226: PUSH
7227: LD_INT 1
7229: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7230: LD_INT 0
7232: PPUSH
7233: LD_INT 4
7235: PPUSH
7236: LD_INT 2
7238: PPUSH
7239: CALL_OW 380
// un := CreateHuman ;
7243: LD_ADDR_VAR 0 2
7247: PUSH
7248: CALL_OW 44
7252: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7253: LD_VAR 0 2
7257: PPUSH
7258: LD_INT 37
7260: PPUSH
7261: LD_INT 70
7263: PPUSH
7264: LD_INT 3
7266: PPUSH
7267: LD_INT 0
7269: PPUSH
7270: CALL_OW 50
// usAttackers := usAttackers union un ;
7274: LD_ADDR_EXP 47
7278: PUSH
7279: LD_EXP 47
7283: PUSH
7284: LD_VAR 0 2
7288: UNION
7289: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7290: LD_VAR 0 2
7294: PPUSH
7295: LD_INT 40
7297: PPUSH
7298: LD_INT 65
7300: PPUSH
7301: CALL_OW 111
// for i := 1 to Difficulty + attackWave div 4 do
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: DOUBLE
7311: LD_INT 1
7313: DEC
7314: ST_TO_ADDR
7315: LD_OWVAR 67
7319: PUSH
7320: LD_EXP 19
7324: PUSH
7325: LD_INT 4
7327: DIV
7328: PLUS
7329: PUSH
7330: FOR_TO
7331: IFFALSE 7504
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7333: LD_ADDR_VAR 0 3
7337: PUSH
7338: LD_INT 1
7340: PPUSH
7341: LD_INT 1
7343: PPUSH
7344: LD_INT 2
7346: PPUSH
7347: LD_INT 1
7349: PPUSH
7350: LD_INT 1
7352: PPUSH
7353: LD_INT 4
7355: PUSH
7356: LD_INT 3
7358: PUSH
7359: LD_INT 2
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: LIST
7366: PUSH
7367: LD_INT 1
7369: PPUSH
7370: LD_INT 3
7372: PPUSH
7373: CALL_OW 12
7377: ARRAY
7378: PPUSH
7379: LD_INT 90
7381: PPUSH
7382: CALL 376 0 7
7386: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7387: LD_VAR 0 3
7391: PPUSH
7392: LD_INT 35
7394: PPUSH
7395: LD_INT 65
7397: PPUSH
7398: LD_INT 0
7400: PPUSH
7401: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7405: LD_INT 0
7407: PPUSH
7408: LD_INT 3
7410: PPUSH
7411: LD_OWVAR 67
7415: PUSH
7416: LD_INT 1
7418: PLUS
7419: PPUSH
7420: CALL_OW 380
// un := CreateHuman ;
7424: LD_ADDR_VAR 0 2
7428: PUSH
7429: CALL_OW 44
7433: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7434: LD_VAR 0 2
7438: PPUSH
7439: LD_VAR 0 3
7443: PPUSH
7444: CALL_OW 52
// usAttackers := usAttackers union un ;
7448: LD_ADDR_EXP 47
7452: PUSH
7453: LD_EXP 47
7457: PUSH
7458: LD_VAR 0 2
7462: UNION
7463: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7464: LD_VAR 0 3
7468: PPUSH
7469: LD_INT 39
7471: PPUSH
7472: LD_INT 60
7474: PPUSH
7475: CALL_OW 111
// wait ( 0 0$3 ) ;
7479: LD_INT 105
7481: PPUSH
7482: CALL_OW 67
// usAttackers := usAttackers union veh ;
7486: LD_ADDR_EXP 47
7490: PUSH
7491: LD_EXP 47
7495: PUSH
7496: LD_VAR 0 3
7500: UNION
7501: ST_TO_ADDR
// end ;
7502: GO 7330
7504: POP
7505: POP
// attackWave := attackWave + 1 ;
7506: LD_ADDR_EXP 19
7510: PUSH
7511: LD_EXP 19
7515: PUSH
7516: LD_INT 1
7518: PLUS
7519: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7520: LD_EXP 24
7524: PPUSH
7525: CALL_OW 427
// end ;
7529: LD_VAR 0 1
7533: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7534: LD_INT 0
7536: PPUSH
7537: PPUSH
7538: PPUSH
7539: PPUSH
7540: PPUSH
7541: PPUSH
7542: PPUSH
7543: PPUSH
7544: PPUSH
7545: PPUSH
7546: PPUSH
// if retreatAllowed then
7547: LD_EXP 11
7551: IFFALSE 7563
// strategy := 2 else
7553: LD_ADDR_VAR 0 5
7557: PUSH
7558: LD_INT 2
7560: ST_TO_ADDR
7561: GO 7579
// strategy := rand ( 0 , 2 ) ;
7563: LD_ADDR_VAR 0 5
7567: PUSH
7568: LD_INT 0
7570: PPUSH
7571: LD_INT 2
7573: PPUSH
7574: CALL_OW 12
7578: ST_TO_ADDR
// attackFormula := [ ] ;
7579: LD_ADDR_VAR 0 6
7583: PUSH
7584: EMPTY
7585: ST_TO_ADDR
// case strategy of 0 :
7586: LD_VAR 0 5
7590: PUSH
7591: LD_INT 0
7593: DOUBLE
7594: EQUAL
7595: IFTRUE 7599
7597: GO 7929
7599: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7600: LD_INT 11
7602: PPUSH
7603: LD_INT 22
7605: PUSH
7606: LD_INT 2
7608: PUSH
7609: EMPTY
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 30
7615: PUSH
7616: LD_INT 4
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: EMPTY
7624: LIST
7625: LIST
7626: PPUSH
7627: CALL_OW 70
7631: NOT
7632: IFFALSE 7704
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7634: LD_ADDR_VAR 0 6
7638: PUSH
7639: LD_INT 41
7641: PUSH
7642: LD_INT 34
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: PUSH
7649: EMPTY
7650: LIST
7651: PUSH
7652: LD_INT 53
7654: PUSH
7655: LD_INT 62
7657: PUSH
7658: EMPTY
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 37
7664: PUSH
7665: LD_INT 63
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PUSH
7672: LD_INT 44
7674: PUSH
7675: LD_INT 45
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PUSH
7682: LD_INT 37
7684: PUSH
7685: LD_INT 28
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: LIST
7700: LIST
7701: ST_TO_ADDR
7702: GO 7927
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7704: LD_INT 12
7706: PPUSH
7707: LD_INT 22
7709: PUSH
7710: LD_INT 2
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PUSH
7717: LD_INT 2
7719: PUSH
7720: LD_INT 30
7722: PUSH
7723: LD_INT 4
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PUSH
7730: LD_INT 30
7732: PUSH
7733: LD_INT 31
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 30
7742: PUSH
7743: LD_INT 32
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: LIST
7754: LIST
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PPUSH
7760: CALL_OW 70
7764: NOT
7765: IFFALSE 7848
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7767: LD_ADDR_VAR 0 6
7771: PUSH
7772: LD_INT 27
7774: PUSH
7775: LD_INT 42
7777: PUSH
7778: EMPTY
7779: LIST
7780: LIST
7781: PUSH
7782: LD_INT 27
7784: PUSH
7785: LD_INT 32
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: LD_INT 53
7798: PUSH
7799: LD_INT 62
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: LD_INT 37
7808: PUSH
7809: LD_INT 63
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 44
7818: PUSH
7819: LD_INT 45
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 37
7828: PUSH
7829: LD_INT 28
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: EMPTY
7837: LIST
7838: LIST
7839: PUSH
7840: EMPTY
7841: LIST
7842: LIST
7843: LIST
7844: LIST
7845: ST_TO_ADDR
7846: GO 7927
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7848: LD_ADDR_VAR 0 6
7852: PUSH
7853: LD_INT 71
7855: PUSH
7856: LD_INT 67
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 54
7865: PUSH
7866: LD_INT 35
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: PUSH
7877: LD_INT 63
7879: PUSH
7880: LD_INT 40
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PUSH
7887: LD_INT 37
7889: PUSH
7890: LD_INT 63
7892: PUSH
7893: EMPTY
7894: LIST
7895: LIST
7896: PUSH
7897: LD_INT 44
7899: PUSH
7900: LD_INT 45
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 37
7909: PUSH
7910: LD_INT 28
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: EMPTY
7918: LIST
7919: LIST
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: LIST
7926: ST_TO_ADDR
// end ; 1 :
7927: GO 8132
7929: LD_INT 1
7931: DOUBLE
7932: EQUAL
7933: IFTRUE 7937
7935: GO 8041
7937: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7938: LD_ADDR_VAR 0 6
7942: PUSH
7943: LD_INT 71
7945: PUSH
7946: LD_INT 67
7948: PUSH
7949: EMPTY
7950: LIST
7951: LIST
7952: PUSH
7953: LD_INT 82
7955: PUSH
7956: LD_INT 23
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: PUSH
7963: LD_INT 53
7965: PUSH
7966: LD_INT 7
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: PUSH
7973: LD_INT 43
7975: PUSH
7976: LD_INT 10
7978: PUSH
7979: EMPTY
7980: LIST
7981: LIST
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 53
7991: PUSH
7992: LD_INT 62
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: PUSH
7999: LD_INT 37
8001: PUSH
8002: LD_INT 63
8004: PUSH
8005: EMPTY
8006: LIST
8007: LIST
8008: PUSH
8009: LD_INT 44
8011: PUSH
8012: LD_INT 45
8014: PUSH
8015: EMPTY
8016: LIST
8017: LIST
8018: PUSH
8019: LD_INT 37
8021: PUSH
8022: LD_INT 28
8024: PUSH
8025: EMPTY
8026: LIST
8027: LIST
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: EMPTY
8034: LIST
8035: LIST
8036: LIST
8037: LIST
8038: ST_TO_ADDR
8039: GO 8132
8041: LD_INT 2
8043: DOUBLE
8044: EQUAL
8045: IFTRUE 8049
8047: GO 8131
8049: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
8050: LD_ADDR_VAR 0 6
8054: PUSH
8055: LD_INT 90
8057: PUSH
8058: LD_INT 59
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: PUSH
8065: LD_INT 108
8067: PUSH
8068: LD_INT 64
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: PUSH
8079: LD_INT 82
8081: PUSH
8082: LD_INT 75
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: PUSH
8089: LD_INT 73
8091: PUSH
8092: LD_INT 67
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PUSH
8099: LD_INT 101
8101: PUSH
8102: LD_INT 65
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: PUSH
8109: LD_INT 108
8111: PUSH
8112: LD_INT 62
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PUSH
8119: EMPTY
8120: LIST
8121: LIST
8122: PUSH
8123: EMPTY
8124: LIST
8125: LIST
8126: LIST
8127: LIST
8128: ST_TO_ADDR
8129: GO 8132
8131: POP
// if not attackFormula then
8132: LD_VAR 0 6
8136: NOT
8137: IFFALSE 8141
// exit ;
8139: GO 9567
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8141: LD_ADDR_VAR 0 7
8145: PUSH
8146: LD_EXP 47
8150: PPUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 1
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PPUSH
8161: CALL_OW 72
8165: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8166: LD_ADDR_VAR 0 8
8170: PUSH
8171: LD_EXP 47
8175: PPUSH
8176: LD_INT 25
8178: PUSH
8179: LD_INT 4
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: PPUSH
8186: CALL_OW 72
8190: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8191: LD_ADDR_VAR 0 9
8195: PUSH
8196: LD_EXP 47
8200: PPUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 3
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 72
8215: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8216: LD_ADDR_VAR 0 10
8220: PUSH
8221: LD_EXP 47
8225: PPUSH
8226: LD_INT 21
8228: PUSH
8229: LD_INT 2
8231: PUSH
8232: EMPTY
8233: LIST
8234: LIST
8235: PPUSH
8236: CALL_OW 72
8240: ST_TO_ADDR
// if sci then
8241: LD_VAR 0 8
8245: IFFALSE 8282
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8247: LD_VAR 0 8
8251: PPUSH
8252: LD_VAR 0 6
8256: PUSH
8257: LD_INT 2
8259: ARRAY
8260: PUSH
8261: LD_INT 1
8263: ARRAY
8264: PPUSH
8265: LD_VAR 0 6
8269: PUSH
8270: LD_INT 2
8272: ARRAY
8273: PUSH
8274: LD_INT 2
8276: ARRAY
8277: PPUSH
8278: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8282: LD_INT 35
8284: PPUSH
8285: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8289: LD_ADDR_VAR 0 7
8293: PUSH
8294: LD_EXP 47
8298: PPUSH
8299: LD_INT 25
8301: PUSH
8302: LD_INT 1
8304: PUSH
8305: EMPTY
8306: LIST
8307: LIST
8308: PPUSH
8309: CALL_OW 72
8313: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8314: LD_ADDR_VAR 0 8
8318: PUSH
8319: LD_EXP 47
8323: PPUSH
8324: LD_INT 25
8326: PUSH
8327: LD_INT 4
8329: PUSH
8330: EMPTY
8331: LIST
8332: LIST
8333: PPUSH
8334: CALL_OW 72
8338: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8339: LD_ADDR_VAR 0 9
8343: PUSH
8344: LD_EXP 47
8348: PPUSH
8349: LD_INT 25
8351: PUSH
8352: LD_INT 3
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: PPUSH
8359: CALL_OW 72
8363: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8364: LD_ADDR_VAR 0 10
8368: PUSH
8369: LD_EXP 47
8373: PPUSH
8374: LD_INT 21
8376: PUSH
8377: LD_INT 2
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 72
8388: ST_TO_ADDR
// if sol then
8389: LD_VAR 0 7
8393: IFFALSE 8788
// begin for i in sol do
8395: LD_ADDR_VAR 0 2
8399: PUSH
8400: LD_VAR 0 7
8404: PUSH
8405: FOR_IN
8406: IFFALSE 8786
// begin tag := GetTag ( i ) ;
8408: LD_ADDR_VAR 0 4
8412: PUSH
8413: LD_VAR 0 2
8417: PPUSH
8418: CALL_OW 110
8422: ST_TO_ADDR
// if not tag then
8423: LD_VAR 0 4
8427: NOT
8428: IFFALSE 8546
// begin if GetLives ( i ) = 1000 then
8430: LD_VAR 0 2
8434: PPUSH
8435: CALL_OW 256
8439: PUSH
8440: LD_INT 1000
8442: EQUAL
8443: IFFALSE 8459
// SetTag ( i , 1 ) else
8445: LD_VAR 0 2
8449: PPUSH
8450: LD_INT 1
8452: PPUSH
8453: CALL_OW 109
8457: GO 8544
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8459: LD_VAR 0 2
8463: PPUSH
8464: LD_VAR 0 6
8468: PUSH
8469: LD_INT 2
8471: ARRAY
8472: PUSH
8473: LD_INT 1
8475: ARRAY
8476: PPUSH
8477: LD_VAR 0 6
8481: PUSH
8482: LD_INT 2
8484: ARRAY
8485: PUSH
8486: LD_INT 2
8488: ARRAY
8489: PPUSH
8490: CALL_OW 297
8494: PUSH
8495: LD_INT 6
8497: GREATER
8498: IFFALSE 8544
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8500: LD_VAR 0 2
8504: PPUSH
8505: LD_VAR 0 6
8509: PUSH
8510: LD_INT 2
8512: ARRAY
8513: PUSH
8514: LD_INT 1
8516: ARRAY
8517: PPUSH
8518: LD_VAR 0 6
8522: PUSH
8523: LD_INT 2
8525: ARRAY
8526: PUSH
8527: LD_INT 2
8529: ARRAY
8530: PPUSH
8531: CALL_OW 111
// AddComHold ( i ) ;
8535: LD_VAR 0 2
8539: PPUSH
8540: CALL_OW 200
// end ; end else
8544: GO 8784
// begin if GetLives ( i ) < 720 then
8546: LD_VAR 0 2
8550: PPUSH
8551: CALL_OW 256
8555: PUSH
8556: LD_INT 720
8558: LESS
8559: IFFALSE 8575
// SetTag ( i , 0 ) else
8561: LD_VAR 0 2
8565: PPUSH
8566: LD_INT 0
8568: PPUSH
8569: CALL_OW 109
8573: GO 8784
// if tag <= attackFormula [ 1 ] then
8575: LD_VAR 0 4
8579: PUSH
8580: LD_VAR 0 6
8584: PUSH
8585: LD_INT 1
8587: ARRAY
8588: LESSEQUAL
8589: IFFALSE 8750
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8591: LD_VAR 0 2
8595: PPUSH
8596: LD_VAR 0 6
8600: PUSH
8601: LD_INT 1
8603: ARRAY
8604: PUSH
8605: LD_VAR 0 4
8609: ARRAY
8610: PUSH
8611: LD_INT 1
8613: ARRAY
8614: PPUSH
8615: LD_VAR 0 6
8619: PUSH
8620: LD_INT 1
8622: ARRAY
8623: PUSH
8624: LD_VAR 0 4
8628: ARRAY
8629: PUSH
8630: LD_INT 2
8632: ARRAY
8633: PPUSH
8634: CALL_OW 297
8638: PUSH
8639: LD_INT 6
8641: GREATER
8642: IFFALSE 8693
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8644: LD_VAR 0 2
8648: PPUSH
8649: LD_VAR 0 6
8653: PUSH
8654: LD_INT 1
8656: ARRAY
8657: PUSH
8658: LD_VAR 0 4
8662: ARRAY
8663: PUSH
8664: LD_INT 1
8666: ARRAY
8667: PPUSH
8668: LD_VAR 0 6
8672: PUSH
8673: LD_INT 1
8675: ARRAY
8676: PUSH
8677: LD_VAR 0 4
8681: ARRAY
8682: PUSH
8683: LD_INT 2
8685: ARRAY
8686: PPUSH
8687: CALL_OW 114
8691: GO 8748
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8693: LD_INT 81
8695: PUSH
8696: LD_INT 1
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PUSH
8703: LD_INT 91
8705: PUSH
8706: LD_VAR 0 2
8710: PUSH
8711: LD_INT 10
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: EMPTY
8720: LIST
8721: LIST
8722: PPUSH
8723: CALL_OW 69
8727: NOT
8728: IFFALSE 8748
// SetTag ( i , tag + 1 ) ;
8730: LD_VAR 0 2
8734: PPUSH
8735: LD_VAR 0 4
8739: PUSH
8740: LD_INT 1
8742: PLUS
8743: PPUSH
8744: CALL_OW 109
// end else
8748: GO 8784
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8750: LD_VAR 0 2
8754: PPUSH
8755: LD_INT 81
8757: PUSH
8758: LD_INT 1
8760: PUSH
8761: EMPTY
8762: LIST
8763: LIST
8764: PPUSH
8765: CALL_OW 69
8769: PPUSH
8770: LD_VAR 0 2
8774: PPUSH
8775: CALL_OW 74
8779: PPUSH
8780: CALL_OW 115
// end ; end ;
8784: GO 8405
8786: POP
8787: POP
// end ; if sci then
8788: LD_VAR 0 8
8792: IFFALSE 8951
// begin if not sol and not mech then
8794: LD_VAR 0 7
8798: NOT
8799: PUSH
8800: LD_VAR 0 9
8804: NOT
8805: AND
8806: IFFALSE 8858
// begin for i in sci do
8808: LD_ADDR_VAR 0 2
8812: PUSH
8813: LD_VAR 0 8
8817: PUSH
8818: FOR_IN
8819: IFFALSE 8854
// begin usForces := usForces union i ;
8821: LD_ADDR_EXP 44
8825: PUSH
8826: LD_EXP 44
8830: PUSH
8831: LD_VAR 0 2
8835: UNION
8836: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8837: LD_VAR 0 2
8841: PPUSH
8842: LD_INT 34
8844: PPUSH
8845: LD_INT 68
8847: PPUSH
8848: CALL_OW 111
// end ;
8852: GO 8818
8854: POP
8855: POP
// end else
8856: GO 8951
// for i in sci do
8858: LD_ADDR_VAR 0 2
8862: PUSH
8863: LD_VAR 0 8
8867: PUSH
8868: FOR_IN
8869: IFFALSE 8949
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8871: LD_VAR 0 2
8875: PPUSH
8876: LD_VAR 0 6
8880: PUSH
8881: LD_INT 2
8883: ARRAY
8884: PUSH
8885: LD_INT 1
8887: ARRAY
8888: PPUSH
8889: LD_VAR 0 6
8893: PUSH
8894: LD_INT 2
8896: ARRAY
8897: PUSH
8898: LD_INT 2
8900: ARRAY
8901: PPUSH
8902: CALL_OW 297
8906: PUSH
8907: LD_INT 8
8909: GREATER
8910: IFFALSE 8947
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8912: LD_VAR 0 2
8916: PPUSH
8917: LD_VAR 0 6
8921: PUSH
8922: LD_INT 2
8924: ARRAY
8925: PUSH
8926: LD_INT 1
8928: ARRAY
8929: PPUSH
8930: LD_VAR 0 6
8934: PUSH
8935: LD_INT 2
8937: ARRAY
8938: PUSH
8939: LD_INT 2
8941: ARRAY
8942: PPUSH
8943: CALL_OW 111
8947: GO 8868
8949: POP
8950: POP
// end ; if mech then
8951: LD_VAR 0 9
8955: IFFALSE 9560
// begin for i in mech do
8957: LD_ADDR_VAR 0 2
8961: PUSH
8962: LD_VAR 0 9
8966: PUSH
8967: FOR_IN
8968: IFFALSE 9558
// begin tag := GetTag ( i ) ;
8970: LD_ADDR_VAR 0 4
8974: PUSH
8975: LD_VAR 0 2
8979: PPUSH
8980: CALL_OW 110
8984: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8985: LD_ADDR_VAR 0 11
8989: PUSH
8990: LD_VAR 0 2
8994: PPUSH
8995: CALL_OW 310
8999: ST_TO_ADDR
// if not tag then
9000: LD_VAR 0 4
9004: NOT
9005: IFFALSE 9318
// begin if veh then
9007: LD_VAR 0 11
9011: IFFALSE 9160
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
9013: LD_VAR 0 11
9017: PPUSH
9018: CALL_OW 256
9022: PUSH
9023: LD_INT 1000
9025: EQUAL
9026: PUSH
9027: LD_VAR 0 11
9031: PPUSH
9032: CALL_OW 261
9036: PUSH
9037: LD_INT 60
9039: GREATER
9040: AND
9041: IFFALSE 9057
// SetTag ( i , 1 ) else
9043: LD_VAR 0 2
9047: PPUSH
9048: LD_INT 1
9050: PPUSH
9051: CALL_OW 109
9055: GO 9158
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
9057: LD_VAR 0 2
9061: PPUSH
9062: LD_VAR 0 6
9066: PUSH
9067: LD_INT 3
9069: ARRAY
9070: PUSH
9071: LD_INT 1
9073: ARRAY
9074: PPUSH
9075: LD_VAR 0 6
9079: PUSH
9080: LD_INT 3
9082: ARRAY
9083: PUSH
9084: LD_INT 2
9086: ARRAY
9087: PPUSH
9088: CALL_OW 297
9092: PUSH
9093: LD_INT 7
9095: GREATER
9096: IFFALSE 9135
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
9098: LD_VAR 0 2
9102: PPUSH
9103: LD_VAR 0 6
9107: PUSH
9108: LD_INT 3
9110: ARRAY
9111: PUSH
9112: LD_INT 1
9114: ARRAY
9115: PPUSH
9116: LD_VAR 0 6
9120: PUSH
9121: LD_INT 3
9123: ARRAY
9124: PUSH
9125: LD_INT 2
9127: ARRAY
9128: PPUSH
9129: CALL_OW 111
9133: GO 9158
// begin ComExitVehicle ( i ) ;
9135: LD_VAR 0 2
9139: PPUSH
9140: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
9144: LD_VAR 0 2
9148: PPUSH
9149: LD_VAR 0 11
9153: PPUSH
9154: CALL_OW 189
// end ; end else
9158: GO 9316
// if GetLives ( i ) < 700 then
9160: LD_VAR 0 2
9164: PPUSH
9165: CALL_OW 256
9169: PUSH
9170: LD_INT 700
9172: LESS
9173: IFFALSE 9224
// begin usAttackers := usAttackers diff i ;
9175: LD_ADDR_EXP 47
9179: PUSH
9180: LD_EXP 47
9184: PUSH
9185: LD_VAR 0 2
9189: DIFF
9190: ST_TO_ADDR
// usForces := usForces union i ;
9191: LD_ADDR_EXP 44
9195: PUSH
9196: LD_EXP 44
9200: PUSH
9201: LD_VAR 0 2
9205: UNION
9206: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9207: LD_VAR 0 2
9211: PPUSH
9212: LD_INT 34
9214: PPUSH
9215: LD_INT 68
9217: PPUSH
9218: CALL_OW 111
// end else
9222: GO 9316
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9224: LD_VAR 0 10
9228: PPUSH
9229: LD_INT 58
9231: PUSH
9232: EMPTY
9233: LIST
9234: PUSH
9235: LD_INT 24
9237: PUSH
9238: LD_INT 1000
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: PPUSH
9249: CALL_OW 72
9253: PUSH
9254: LD_VAR 0 2
9258: PPUSH
9259: CALL_OW 314
9263: NOT
9264: AND
9265: IFFALSE 9316
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9267: LD_VAR 0 2
9271: PPUSH
9272: LD_VAR 0 10
9276: PPUSH
9277: LD_INT 58
9279: PUSH
9280: EMPTY
9281: LIST
9282: PUSH
9283: LD_INT 24
9285: PUSH
9286: LD_INT 1000
9288: PUSH
9289: EMPTY
9290: LIST
9291: LIST
9292: PUSH
9293: EMPTY
9294: LIST
9295: LIST
9296: PPUSH
9297: CALL_OW 72
9301: PPUSH
9302: LD_VAR 0 2
9306: PPUSH
9307: CALL_OW 74
9311: PPUSH
9312: CALL_OW 120
// end else
9316: GO 9556
// begin if GetLives ( veh ) < 720 then
9318: LD_VAR 0 11
9322: PPUSH
9323: CALL_OW 256
9327: PUSH
9328: LD_INT 720
9330: LESS
9331: IFFALSE 9347
// SetTag ( i , 0 ) else
9333: LD_VAR 0 2
9337: PPUSH
9338: LD_INT 0
9340: PPUSH
9341: CALL_OW 109
9345: GO 9556
// if tag <= attackFormula [ 4 ] then
9347: LD_VAR 0 4
9351: PUSH
9352: LD_VAR 0 6
9356: PUSH
9357: LD_INT 4
9359: ARRAY
9360: LESSEQUAL
9361: IFFALSE 9522
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9363: LD_VAR 0 2
9367: PPUSH
9368: LD_VAR 0 6
9372: PUSH
9373: LD_INT 4
9375: ARRAY
9376: PUSH
9377: LD_VAR 0 4
9381: ARRAY
9382: PUSH
9383: LD_INT 1
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 6
9391: PUSH
9392: LD_INT 4
9394: ARRAY
9395: PUSH
9396: LD_VAR 0 4
9400: ARRAY
9401: PUSH
9402: LD_INT 2
9404: ARRAY
9405: PPUSH
9406: CALL_OW 297
9410: PUSH
9411: LD_INT 6
9413: GREATER
9414: IFFALSE 9465
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9416: LD_VAR 0 2
9420: PPUSH
9421: LD_VAR 0 6
9425: PUSH
9426: LD_INT 4
9428: ARRAY
9429: PUSH
9430: LD_VAR 0 4
9434: ARRAY
9435: PUSH
9436: LD_INT 1
9438: ARRAY
9439: PPUSH
9440: LD_VAR 0 6
9444: PUSH
9445: LD_INT 4
9447: ARRAY
9448: PUSH
9449: LD_VAR 0 4
9453: ARRAY
9454: PUSH
9455: LD_INT 2
9457: ARRAY
9458: PPUSH
9459: CALL_OW 114
9463: GO 9520
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9465: LD_INT 81
9467: PUSH
9468: LD_INT 1
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: PUSH
9475: LD_INT 91
9477: PUSH
9478: LD_VAR 0 2
9482: PUSH
9483: LD_INT 10
9485: PUSH
9486: EMPTY
9487: LIST
9488: LIST
9489: LIST
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: PPUSH
9495: CALL_OW 69
9499: NOT
9500: IFFALSE 9520
// SetTag ( i , tag + 1 ) ;
9502: LD_VAR 0 2
9506: PPUSH
9507: LD_VAR 0 4
9511: PUSH
9512: LD_INT 1
9514: PLUS
9515: PPUSH
9516: CALL_OW 109
// end else
9520: GO 9556
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9522: LD_VAR 0 2
9526: PPUSH
9527: LD_INT 81
9529: PUSH
9530: LD_INT 1
9532: PUSH
9533: EMPTY
9534: LIST
9535: LIST
9536: PPUSH
9537: CALL_OW 69
9541: PPUSH
9542: LD_VAR 0 2
9546: PPUSH
9547: CALL_OW 74
9551: PPUSH
9552: CALL_OW 115
// end ; end ;
9556: GO 8967
9558: POP
9559: POP
// end ; until not usAttackers ;
9560: LD_EXP 47
9564: NOT
9565: IFFALSE 8282
// end ;
9567: LD_VAR 0 1
9571: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do var i ;
9572: LD_INT 22
9574: PUSH
9575: LD_INT 1
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: PUSH
9582: LD_INT 32
9584: PUSH
9585: LD_INT 1
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PPUSH
9596: CALL_OW 69
9600: IFFALSE 9677
9602: GO 9604
9604: DISABLE
9605: LD_INT 0
9607: PPUSH
// begin enable ;
9608: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_engine , engine_combustion ] ] ) do
9609: LD_ADDR_VAR 0 1
9613: PUSH
9614: LD_INT 22
9616: PUSH
9617: LD_INT 1
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: LD_INT 32
9626: PUSH
9627: LD_INT 1
9629: PUSH
9630: EMPTY
9631: LIST
9632: LIST
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PPUSH
9638: CALL_OW 69
9642: PUSH
9643: FOR_IN
9644: IFFALSE 9675
// if GetFuel ( i ) < 10 then
9646: LD_VAR 0 1
9650: PPUSH
9651: CALL_OW 261
9655: PUSH
9656: LD_INT 10
9658: LESS
9659: IFFALSE 9673
// SetFuel ( i , 10 ) ;
9661: LD_VAR 0 1
9665: PPUSH
9666: LD_INT 10
9668: PPUSH
9669: CALL_OW 240
9673: GO 9643
9675: POP
9676: POP
// end ; end_of_file
9677: PPOPN 1
9679: END
// export function Action ; var hasAll , i , tmp ; begin
9680: LD_INT 0
9682: PPUSH
9683: PPUSH
9684: PPUSH
9685: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9686: LD_ADDR_VAR 0 2
9690: PUSH
9691: LD_INT 22
9693: PUSH
9694: LD_INT 2
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: PUSH
9701: LD_INT 21
9703: PUSH
9704: LD_INT 1
9706: PUSH
9707: EMPTY
9708: LIST
9709: LIST
9710: PUSH
9711: LD_INT 23
9713: PUSH
9714: LD_INT 2
9716: PUSH
9717: EMPTY
9718: LIST
9719: LIST
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: LIST
9725: PPUSH
9726: CALL_OW 69
9730: PUSH
9731: LD_INT 7
9733: GREATEREQUAL
9734: ST_TO_ADDR
// SaveVariable ( hasAll , 03_HasAll ) ;
9735: LD_VAR 0 2
9739: PPUSH
9740: LD_STRING 03_HasAll
9742: PPUSH
9743: CALL_OW 39
// Video ( true ) ;
9747: LD_INT 1
9749: PPUSH
9750: CALL 1036 0 1
// CenterNowOnUnits ( Heike ) ;
9754: LD_EXP 28
9758: PPUSH
9759: CALL_OW 87
// wait ( 0 0$2 ) ;
9763: LD_INT 70
9765: PPUSH
9766: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9770: LD_EXP 36
9774: PPUSH
9775: LD_STRING DF-1-start
9777: PPUSH
9778: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9782: LD_EXP 28
9786: PPUSH
9787: LD_EXP 36
9791: PPUSH
9792: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9796: LD_EXP 28
9800: PPUSH
9801: LD_STRING DH-1-start
9803: PPUSH
9804: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9808: LD_EXP 37
9812: PPUSH
9813: LD_INT 92
9815: PPUSH
9816: LD_INT 21
9818: PPUSH
9819: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9823: LD_EXP 32
9827: PPUSH
9828: LD_INT 94
9830: PPUSH
9831: LD_INT 23
9833: PPUSH
9834: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9838: LD_EXP 40
9842: PUSH
9843: LD_INT 1
9845: ARRAY
9846: PPUSH
9847: LD_INT 90
9849: PPUSH
9850: LD_INT 23
9852: PPUSH
9853: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9857: LD_EXP 40
9861: PUSH
9862: LD_INT 2
9864: ARRAY
9865: PPUSH
9866: LD_INT 93
9868: PPUSH
9869: LD_INT 25
9871: PPUSH
9872: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9876: LD_EXP 40
9880: PPUSH
9881: LD_EXP 37
9885: PPUSH
9886: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9890: LD_EXP 37
9894: PUSH
9895: LD_EXP 32
9899: PUSH
9900: EMPTY
9901: LIST
9902: LIST
9903: PPUSH
9904: LD_EXP 28
9908: PPUSH
9909: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9913: LD_EXP 28
9917: PPUSH
9918: LD_EXP 37
9922: PPUSH
9923: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9927: LD_INT 35
9929: PPUSH
9930: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9934: LD_EXP 37
9938: PPUSH
9939: LD_INT 92
9941: PPUSH
9942: LD_INT 21
9944: PPUSH
9945: CALL_OW 307
9949: IFFALSE 9927
// Say ( Omar , DO-1-start ) ;
9951: LD_EXP 37
9955: PPUSH
9956: LD_STRING DO-1-start
9958: PPUSH
9959: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9963: LD_EXP 28
9967: PPUSH
9968: LD_STRING DH-2-start
9970: PPUSH
9971: CALL_OW 88
// if hasAll then
9975: LD_VAR 0 2
9979: IFFALSE 10107
// begin Say ( Omar , DO-2-start ) ;
9981: LD_EXP 37
9985: PPUSH
9986: LD_STRING DO-2-start
9988: PPUSH
9989: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9993: LD_EXP 37
9997: PPUSH
9998: LD_STRING DO-3-start
10000: PPUSH
10001: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
10005: LD_EXP 28
10009: PPUSH
10010: LD_STRING DH-3-start
10012: PPUSH
10013: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
10017: LD_EXP 36
10021: PPUSH
10022: LD_STRING DF-2-start
10024: PPUSH
10025: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10029: LD_EXP 37
10033: PPUSH
10034: LD_EXP 36
10038: PPUSH
10039: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
10043: LD_EXP 37
10047: PPUSH
10048: LD_STRING DO-4-start
10050: PPUSH
10051: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
10055: LD_EXP 36
10059: PPUSH
10060: LD_STRING DF-3-start
10062: PPUSH
10063: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
10067: LD_EXP 37
10071: PPUSH
10072: LD_STRING DO-5-start
10074: PPUSH
10075: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
10079: LD_EXP 36
10083: PPUSH
10084: LD_STRING DF-4-start
10086: PPUSH
10087: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10091: LD_EXP 37
10095: PPUSH
10096: LD_EXP 28
10100: PPUSH
10101: CALL_OW 119
// end else
10105: GO 10207
// begin Say ( Omar , DO-2-start-a ) ;
10107: LD_EXP 37
10111: PPUSH
10112: LD_STRING DO-2-start-a
10114: PPUSH
10115: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
10119: LD_EXP 37
10123: PPUSH
10124: LD_STRING DO-3-start-a
10126: PPUSH
10127: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
10131: LD_EXP 28
10135: PPUSH
10136: LD_STRING DH-3-start-a
10138: PPUSH
10139: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
10143: LD_EXP 36
10147: PPUSH
10148: LD_STRING DF-2-start-a
10150: PPUSH
10151: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
10155: LD_EXP 37
10159: PPUSH
10160: LD_EXP 36
10164: PPUSH
10165: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
10169: LD_EXP 37
10173: PPUSH
10174: LD_STRING DO-4-start-a
10176: PPUSH
10177: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
10181: LD_EXP 36
10185: PPUSH
10186: LD_STRING DF-3-start-a
10188: PPUSH
10189: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
10193: LD_EXP 37
10197: PPUSH
10198: LD_EXP 28
10202: PPUSH
10203: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
10207: LD_INT 10
10209: PPUSH
10210: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
10214: LD_EXP 37
10218: PPUSH
10219: LD_STRING DO-1-mission
10221: PPUSH
10222: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
10226: LD_EXP 37
10230: PPUSH
10231: LD_STRING DO-2-mission
10233: PPUSH
10234: CALL_OW 88
// if not hasAll then
10238: LD_VAR 0 2
10242: NOT
10243: IFFALSE 10257
// Say ( Omar , DO-3-mission ) ;
10245: LD_EXP 37
10249: PPUSH
10250: LD_STRING DO-3-mission
10252: PPUSH
10253: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
10257: LD_EXP 37
10261: PPUSH
10262: LD_STRING DO-4-mission
10264: PPUSH
10265: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
10269: LD_EXP 28
10273: PPUSH
10274: LD_STRING DH-1-mission
10276: PPUSH
10277: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
10281: LD_EXP 36
10285: PPUSH
10286: LD_STRING DF-1-mission
10288: PPUSH
10289: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10293: LD_EXP 37
10297: PPUSH
10298: LD_STRING DO-5-mission
10300: PPUSH
10301: CALL_OW 88
// if not hasAll then
10305: LD_VAR 0 2
10309: NOT
10310: IFFALSE 10445
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10312: LD_ADDR_VAR 0 4
10316: PUSH
10317: LD_INT 22
10319: PUSH
10320: LD_INT 2
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PUSH
10327: LD_INT 21
10329: PUSH
10330: LD_INT 1
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PUSH
10337: LD_INT 23
10339: PUSH
10340: LD_INT 2
10342: PUSH
10343: EMPTY
10344: LIST
10345: LIST
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: LIST
10351: PPUSH
10352: CALL_OW 69
10356: ST_TO_ADDR
// for i := 7 downto tmp do
10357: LD_ADDR_VAR 0 3
10361: PUSH
10362: DOUBLE
10363: LD_INT 7
10365: INC
10366: ST_TO_ADDR
10367: LD_VAR 0 4
10371: PUSH
10372: FOR_DOWNTO
10373: IFFALSE 10443
// begin if omarSquad < 3 then
10375: LD_EXP 40
10379: PUSH
10380: LD_INT 3
10382: LESS
10383: IFFALSE 10387
// break ;
10385: GO 10443
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10387: LD_EXP 40
10391: PUSH
10392: LD_INT 3
10394: ARRAY
10395: PPUSH
10396: LD_INT 2
10398: PPUSH
10399: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10403: LD_ADDR_EXP 42
10407: PUSH
10408: LD_EXP 42
10412: PUSH
10413: LD_EXP 40
10417: PUSH
10418: LD_INT 3
10420: ARRAY
10421: UNION
10422: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10423: LD_ADDR_EXP 40
10427: PUSH
10428: LD_EXP 40
10432: PPUSH
10433: LD_INT 3
10435: PPUSH
10436: CALL_OW 3
10440: ST_TO_ADDR
// end ;
10441: GO 10372
10443: POP
10444: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10445: LD_EXP 37
10449: PUSH
10450: LD_EXP 40
10454: ADD
10455: PPUSH
10456: LD_INT 103
10458: PPUSH
10459: LD_INT 9
10461: PPUSH
10462: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10466: LD_VAR 0 2
10470: PUSH
10471: LD_EXP 33
10475: PPUSH
10476: CALL_OW 302
10480: AND
10481: IFFALSE 10542
// begin wait ( 0 0$3 ) ;
10483: LD_INT 105
10485: PPUSH
10486: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10490: LD_EXP 33
10494: PPUSH
10495: LD_EXP 36
10499: PPUSH
10500: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10504: LD_EXP 33
10508: PPUSH
10509: LD_STRING DK-1-side
10511: PPUSH
10512: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10516: LD_EXP 36
10520: PPUSH
10521: LD_EXP 33
10525: PPUSH
10526: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10530: LD_EXP 36
10534: PPUSH
10535: LD_STRING DF-1-side
10537: PPUSH
10538: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10542: LD_INT 22
10544: PUSH
10545: LD_INT 2
10547: PUSH
10548: EMPTY
10549: LIST
10550: LIST
10551: PPUSH
10552: CALL_OW 69
10556: PPUSH
10557: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10561: LD_EXP 36
10565: PUSH
10566: LD_EXP 39
10570: ADD
10571: PPUSH
10572: LD_INT 108
10574: PPUSH
10575: LD_INT 62
10577: PPUSH
10578: CALL_OW 111
// gameStarted := true ;
10582: LD_ADDR_EXP 3
10586: PUSH
10587: LD_INT 1
10589: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10590: LD_INT 105
10592: PPUSH
10593: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10597: LD_EXP 28
10601: PPUSH
10602: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10606: LD_EXP 28
10610: PPUSH
10611: LD_EXP 32
10615: PPUSH
10616: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10620: LD_INT 22
10622: PUSH
10623: LD_INT 2
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: PPUSH
10630: CALL_OW 69
10634: PUSH
10635: LD_EXP 28
10639: DIFF
10640: PPUSH
10641: LD_EXP 28
10645: PPUSH
10646: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10650: LD_EXP 28
10654: PPUSH
10655: LD_STRING DH-1-explore
10657: PPUSH
10658: CALL_OW 88
// if Givi then
10662: LD_EXP 29
10666: IFFALSE 10682
// Say ( Givi , DG-1-explore ) else
10668: LD_EXP 29
10672: PPUSH
10673: LD_STRING DG-1-explore
10675: PPUSH
10676: CALL_OW 88
10680: GO 10719
// if heikeSecondSquad then
10682: LD_EXP 42
10686: IFFALSE 10719
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10688: LD_EXP 42
10692: PPUSH
10693: LD_INT 26
10695: PUSH
10696: LD_INT 1
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PPUSH
10703: CALL_OW 72
10707: PUSH
10708: LD_INT 1
10710: ARRAY
10711: PPUSH
10712: LD_STRING DArm-1-explore
10714: PPUSH
10715: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10719: LD_EXP 32
10723: PPUSH
10724: LD_STRING DA-1-explore
10726: PPUSH
10727: CALL_OW 88
// if Sophia then
10731: LD_EXP 34
10735: IFFALSE 10813
// begin Say ( Sophia , DS-2-explore ) ;
10737: LD_EXP 34
10741: PPUSH
10742: LD_STRING DS-2-explore
10744: PPUSH
10745: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10749: LD_EXP 32
10753: PPUSH
10754: LD_STRING DA-2-explore
10756: PPUSH
10757: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10761: LD_EXP 34
10765: PPUSH
10766: LD_EXP 32
10770: PPUSH
10771: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10775: LD_EXP 32
10779: PPUSH
10780: LD_EXP 34
10784: PPUSH
10785: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10789: LD_EXP 34
10793: PPUSH
10794: LD_STRING DS-3-explore
10796: PPUSH
10797: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10801: LD_EXP 32
10805: PPUSH
10806: LD_STRING DA-3-explore
10808: PPUSH
10809: CALL_OW 88
// end ; if Mike then
10813: LD_EXP 30
10817: IFFALSE 10873
// begin Say ( Mike , DM-1-explore ) ;
10819: LD_EXP 30
10823: PPUSH
10824: LD_STRING DM-1-explore
10826: PPUSH
10827: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10831: LD_EXP 28
10835: PPUSH
10836: LD_STRING DH-2-explore
10838: PPUSH
10839: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10843: LD_EXP 30
10847: PPUSH
10848: LD_STRING DM-2-explore
10850: PPUSH
10851: CALL_OW 88
// if Kaia then
10855: LD_EXP 33
10859: IFFALSE 10873
// Say ( Kaia , DK-1-explore ) ;
10861: LD_EXP 33
10865: PPUSH
10866: LD_STRING DK-1-explore
10868: PPUSH
10869: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10873: LD_INT 22
10875: PUSH
10876: LD_INT 2
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: PPUSH
10883: CALL_OW 69
10887: PPUSH
10888: CALL_OW 139
// Video ( false ) ;
10892: LD_INT 0
10894: PPUSH
10895: CALL 1036 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10899: LD_STRING BuildBase
10901: PPUSH
10902: CALL_OW 337
// SaveForQuickRestart ;
10906: CALL_OW 22
// end ;
10910: LD_VAR 0 1
10914: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10915: LD_EXP 5
10919: NOT
10920: PUSH
10921: LD_EXP 6
10925: NOT
10926: AND
10927: PUSH
10928: LD_INT 5
10930: PPUSH
10931: LD_INT 22
10933: PUSH
10934: LD_INT 2
10936: PUSH
10937: EMPTY
10938: LIST
10939: LIST
10940: PPUSH
10941: CALL_OW 70
10945: AND
10946: PUSH
10947: LD_EXP 6
10951: NOT
10952: AND
10953: IFFALSE 11038
10955: GO 10957
10957: DISABLE
// begin if Mike then
10958: LD_EXP 30
10962: IFFALSE 10978
// Say ( Mike , DM-1-scout ) else
10964: LD_EXP 30
10968: PPUSH
10969: LD_STRING DM-1-scout
10971: PPUSH
10972: CALL_OW 88
10976: GO 11009
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10978: LD_EXP 42
10982: PPUSH
10983: LD_INT 26
10985: PUSH
10986: LD_INT 1
10988: PUSH
10989: EMPTY
10990: LIST
10991: LIST
10992: PPUSH
10993: CALL_OW 72
10997: PUSH
10998: LD_INT 1
11000: ARRAY
11001: PPUSH
11002: LD_STRING DArm-1-explore
11004: PPUSH
11005: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
11009: LD_INT 54
11011: PPUSH
11012: LD_INT 35
11014: PPUSH
11015: LD_INT 2
11017: PPUSH
11018: LD_INT 1
11020: PPUSH
11021: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
11025: LD_INT 54
11027: PPUSH
11028: LD_INT 35
11030: PPUSH
11031: LD_INT 2
11033: PPUSH
11034: CALL_OW 331
// end ;
11038: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
11039: LD_INT 6
11041: PPUSH
11042: LD_INT 22
11044: PUSH
11045: LD_INT 2
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: PPUSH
11052: CALL_OW 70
11056: PUSH
11057: LD_EXP 6
11061: NOT
11062: AND
11063: IFFALSE 11317
11065: GO 11067
11067: DISABLE
11068: LD_INT 0
11070: PPUSH
11071: PPUSH
11072: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11073: LD_ADDR_VAR 0 1
11077: PUSH
11078: LD_EXP 42
11082: PPUSH
11083: LD_INT 26
11085: PUSH
11086: LD_INT 1
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: PPUSH
11093: CALL_OW 72
11097: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
11098: LD_ADDR_VAR 0 2
11102: PUSH
11103: LD_EXP 42
11107: PPUSH
11108: LD_INT 26
11110: PUSH
11111: LD_INT 2
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PPUSH
11118: CALL_OW 72
11122: ST_TO_ADDR
// DialogueOn ;
11123: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
11127: LD_INT 36
11129: PPUSH
11130: LD_INT 22
11132: PPUSH
11133: LD_INT 2
11135: PPUSH
11136: LD_INT 8
11138: PPUSH
11139: CALL_OW 330
// dwait ( 0 0$1 ) ;
11143: LD_INT 35
11145: PPUSH
11146: CALL_OW 68
// speakerOk := false ;
11150: LD_ADDR_VAR 0 3
11154: PUSH
11155: LD_INT 0
11157: ST_TO_ADDR
// if Mike then
11158: LD_EXP 30
11162: IFFALSE 11184
// speakerOk := Say ( Mike , DM-1-spot ) else
11164: LD_ADDR_VAR 0 3
11168: PUSH
11169: LD_EXP 30
11173: PPUSH
11174: LD_STRING DM-1-spot
11176: PPUSH
11177: CALL_OW 88
11181: ST_TO_ADDR
11182: GO 11212
// if randomMen then
11184: LD_VAR 0 1
11188: IFFALSE 11212
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11190: LD_ADDR_VAR 0 3
11194: PUSH
11195: LD_VAR 0 1
11199: PUSH
11200: LD_INT 1
11202: ARRAY
11203: PPUSH
11204: LD_STRING DArm-1-spot-a
11206: PPUSH
11207: CALL_OW 88
11211: ST_TO_ADDR
// if speakerOk then
11212: LD_VAR 0 3
11216: IFFALSE 11260
// begin if Givi then
11218: LD_EXP 29
11222: IFFALSE 11238
// Say ( Givi , DG-1-spot ) else
11224: LD_EXP 29
11228: PPUSH
11229: LD_STRING DG-1-spot
11231: PPUSH
11232: CALL_OW 88
11236: GO 11260
// if randomWomen then
11238: LD_VAR 0 2
11242: IFFALSE 11260
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
11244: LD_VAR 0 2
11248: PUSH
11249: LD_INT 1
11251: ARRAY
11252: PPUSH
11253: LD_STRING DArf-1-spot-a
11255: PPUSH
11256: CALL_OW 88
// end ; if Mike then
11260: LD_EXP 30
11264: IFFALSE 11280
// Say ( Heike , DH-1-spot ) else
11266: LD_EXP 28
11270: PPUSH
11271: LD_STRING DH-1-spot
11273: PPUSH
11274: CALL_OW 88
11278: GO 11292
// Say ( Heike , DH-1-spot-a ) ;
11280: LD_EXP 28
11284: PPUSH
11285: LD_STRING DH-1-spot-a
11287: PPUSH
11288: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11292: LD_INT 36
11294: PPUSH
11295: LD_INT 22
11297: PPUSH
11298: LD_INT 2
11300: PPUSH
11301: CALL_OW 331
// DialogueOff ;
11305: CALL_OW 7
// americanBaseSpoted := true ;
11309: LD_ADDR_EXP 5
11313: PUSH
11314: LD_INT 1
11316: ST_TO_ADDR
// end ;
11317: PPOPN 3
11319: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11320: LD_EXP 5
11324: NOT
11325: PUSH
11326: LD_INT 22
11328: PUSH
11329: LD_INT 2
11331: PUSH
11332: EMPTY
11333: LIST
11334: LIST
11335: PUSH
11336: LD_INT 101
11338: PUSH
11339: LD_INT 1
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: PUSH
11346: EMPTY
11347: LIST
11348: LIST
11349: PPUSH
11350: CALL_OW 69
11354: AND
11355: PUSH
11356: LD_EXP 6
11360: NOT
11361: AND
11362: IFFALSE 11448
11364: GO 11366
11366: DISABLE
11367: LD_INT 0
11369: PPUSH
// begin americanBaseSpoted := true ;
11370: LD_ADDR_EXP 5
11374: PUSH
11375: LD_INT 1
11377: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11378: LD_ADDR_VAR 0 1
11382: PUSH
11383: LD_EXP 42
11387: PPUSH
11388: LD_INT 26
11390: PUSH
11391: LD_INT 1
11393: PUSH
11394: EMPTY
11395: LIST
11396: LIST
11397: PPUSH
11398: CALL_OW 72
11402: ST_TO_ADDR
// if not randomMen then
11403: LD_VAR 0 1
11407: NOT
11408: IFFALSE 11412
// exit ;
11410: GO 11448
// DialogueOn ;
11412: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11416: LD_VAR 0 1
11420: PUSH
11421: LD_INT 1
11423: ARRAY
11424: PPUSH
11425: LD_STRING DArm-1-spot-a
11427: PPUSH
11428: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11432: LD_EXP 28
11436: PPUSH
11437: LD_STRING DH-1-spot-a
11439: PPUSH
11440: CALL_OW 88
// DialogueOff ;
11444: CALL_OW 7
// end ;
11448: PPOPN 1
11450: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or usForces <= 4 do var i , p ;
11451: LD_INT 11
11453: PPUSH
11454: CALL_OW 255
11458: PUSH
11459: LD_INT 2
11461: EQUAL
11462: PUSH
11463: LD_INT 7
11465: PPUSH
11466: LD_INT 22
11468: PUSH
11469: LD_INT 1
11471: PUSH
11472: EMPTY
11473: LIST
11474: LIST
11475: PUSH
11476: LD_INT 3
11478: PUSH
11479: LD_INT 50
11481: PUSH
11482: EMPTY
11483: LIST
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: PUSH
11489: LD_INT 30
11491: PUSH
11492: LD_INT 31
11494: PUSH
11495: EMPTY
11496: LIST
11497: LIST
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: LIST
11503: PPUSH
11504: CALL_OW 70
11508: OR
11509: PUSH
11510: LD_INT 7
11512: PPUSH
11513: LD_INT 22
11515: PUSH
11516: LD_INT 2
11518: PUSH
11519: EMPTY
11520: LIST
11521: LIST
11522: PPUSH
11523: CALL_OW 70
11527: PUSH
11528: LD_INT 1
11530: GREATER
11531: OR
11532: PUSH
11533: LD_EXP 44
11537: PUSH
11538: LD_INT 4
11540: LESSEQUAL
11541: OR
11542: IFFALSE 12068
11544: GO 11546
11546: DISABLE
11547: LD_INT 0
11549: PPUSH
11550: PPUSH
// begin wait ( 0 0$3 ) ;
11551: LD_INT 105
11553: PPUSH
11554: CALL_OW 67
// americanStartRun := true ;
11558: LD_ADDR_EXP 14
11562: PUSH
11563: LD_INT 1
11565: ST_TO_ADDR
// if IsOk ( usCommander ) then
11566: LD_EXP 45
11570: PPUSH
11571: CALL_OW 302
11575: IFFALSE 11605
// begin usForces := usForces union usCommander ;
11577: LD_ADDR_EXP 44
11581: PUSH
11582: LD_EXP 44
11586: PUSH
11587: LD_EXP 45
11591: UNION
11592: ST_TO_ADDR
// Say ( usCommander , DUsm-1-assault ) ;
11593: LD_EXP 45
11597: PPUSH
11598: LD_STRING DUsm-1-assault
11600: PPUSH
11601: CALL_OW 88
// end ; for i in usForces do
11605: LD_ADDR_VAR 0 1
11609: PUSH
11610: LD_EXP 44
11614: PUSH
11615: FOR_IN
11616: IFFALSE 11662
// begin if IsInUnit ( i ) then
11618: LD_VAR 0 1
11622: PPUSH
11623: CALL_OW 310
11627: IFFALSE 11638
// ComExitBuilding ( i ) ;
11629: LD_VAR 0 1
11633: PPUSH
11634: CALL_OW 122
// wait ( 3 ) ;
11638: LD_INT 3
11640: PPUSH
11641: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11645: LD_VAR 0 1
11649: PPUSH
11650: LD_INT 34
11652: PPUSH
11653: LD_INT 67
11655: PPUSH
11656: CALL_OW 111
// end ;
11660: GO 11615
11662: POP
11663: POP
// Say ( Heike , DH-1-assault ) ;
11664: LD_EXP 28
11668: PPUSH
11669: LD_STRING DH-1-assault
11671: PPUSH
11672: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11676: LD_INT 35
11678: PPUSH
11679: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11683: LD_VAR 0 1
11687: PPUSH
11688: LD_INT 34
11690: PPUSH
11691: LD_INT 67
11693: PPUSH
11694: CALL_OW 111
// until not usForces ;
11698: LD_EXP 44
11702: NOT
11703: IFFALSE 11676
// music_nat := 2 ;
11705: LD_ADDR_OWVAR 71
11709: PUSH
11710: LD_INT 2
11712: ST_TO_ADDR
// music_class := music_victory ;
11713: LD_ADDR_OWVAR 72
11717: PUSH
11718: LD_INT 4
11720: ST_TO_ADDR
// if not americanHasEscaped then
11721: LD_EXP 8
11725: NOT
11726: IFFALSE 11747
// begin Say ( Heike , DH-2-assault ) ;
11728: LD_EXP 28
11732: PPUSH
11733: LD_STRING DH-2-assault
11735: PPUSH
11736: CALL_OW 88
// SetAchievement ( ACH_CLEAN ) ;
11740: LD_STRING ACH_CLEAN
11742: PPUSH
11743: CALL_OW 543
// end ; wait ( 0 0$2 ) ;
11747: LD_INT 70
11749: PPUSH
11750: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11754: LD_INT 35
11756: PPUSH
11757: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11761: LD_INT 22
11763: PUSH
11764: LD_INT 2
11766: PUSH
11767: EMPTY
11768: LIST
11769: LIST
11770: PUSH
11771: LD_INT 21
11773: PUSH
11774: LD_INT 1
11776: PUSH
11777: EMPTY
11778: LIST
11779: LIST
11780: PUSH
11781: LD_INT 3
11783: PUSH
11784: LD_INT 50
11786: PUSH
11787: EMPTY
11788: LIST
11789: PUSH
11790: EMPTY
11791: LIST
11792: LIST
11793: PUSH
11794: EMPTY
11795: LIST
11796: LIST
11797: LIST
11798: PPUSH
11799: CALL_OW 69
11803: NOT
11804: IFFALSE 11754
// InGameOn ;
11806: CALL_OW 8
// if not GetSide ( usDepot ) = 2 then
11810: LD_INT 11
11812: PPUSH
11813: CALL_OW 255
11817: PUSH
11818: LD_INT 2
11820: EQUAL
11821: NOT
11822: IFFALSE 11834
// SetSide ( usDepot , 2 ) ;
11824: LD_INT 11
11826: PPUSH
11827: LD_INT 2
11829: PPUSH
11830: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11834: LD_INT 35
11836: PPUSH
11837: LD_INT 22
11839: PPUSH
11840: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11844: LD_EXP 28
11848: PPUSH
11849: LD_INT 35
11851: PPUSH
11852: LD_INT 22
11854: PPUSH
11855: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11859: LD_EXP 28
11863: PPUSH
11864: LD_INT 38
11866: PPUSH
11867: LD_INT 25
11869: PPUSH
11870: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11874: LD_EXP 41
11878: PUSH
11879: LD_EXP 42
11883: UNION
11884: PPUSH
11885: LD_INT 39
11887: PPUSH
11888: LD_INT 26
11890: PPUSH
11891: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11895: LD_EXP 41
11899: PUSH
11900: LD_EXP 42
11904: UNION
11905: PPUSH
11906: LD_EXP 28
11910: PPUSH
11911: CALL_OW 179
// p := 0 ;
11915: LD_ADDR_VAR 0 2
11919: PUSH
11920: LD_INT 0
11922: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11923: LD_INT 35
11925: PPUSH
11926: CALL_OW 67
// p := p + 1 ;
11930: LD_ADDR_VAR 0 2
11934: PUSH
11935: LD_VAR 0 2
11939: PUSH
11940: LD_INT 1
11942: PLUS
11943: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11944: LD_EXP 28
11948: PPUSH
11949: CALL_OW 314
11953: NOT
11954: PUSH
11955: LD_VAR 0 2
11959: PUSH
11960: LD_INT 10
11962: GREATER
11963: OR
11964: IFFALSE 11923
// Say ( Heike , DH-1-capture ) ;
11966: LD_EXP 28
11970: PPUSH
11971: LD_STRING DH-1-capture
11973: PPUSH
11974: CALL_OW 88
// if Markov then
11978: LD_EXP 35
11982: IFFALSE 11996
// Say ( Markov , DMar-1-capture ) ;
11984: LD_EXP 35
11988: PPUSH
11989: LD_STRING DMar-1-capture
11991: PPUSH
11992: CALL_OW 88
// if Sophia then
11996: LD_EXP 34
12000: IFFALSE 12026
// begin Say ( Heike , DH-2-capture ) ;
12002: LD_EXP 28
12006: PPUSH
12007: LD_STRING DH-2-capture
12009: PPUSH
12010: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
12014: LD_EXP 34
12018: PPUSH
12019: LD_STRING DS-1-capture
12021: PPUSH
12022: CALL_OW 88
// end ; InGameOff ;
12026: CALL_OW 9
// music_nat := music_auto ;
12030: LD_ADDR_OWVAR 71
12034: PUSH
12035: LD_INT 0
12037: ST_TO_ADDR
// music_class := music_auto ;
12038: LD_ADDR_OWVAR 72
12042: PUSH
12043: LD_INT 0
12045: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
12046: LD_STRING ConstructBase
12048: PPUSH
12049: CALL_OW 337
// wait ( 0 0$3 ) ;
12053: LD_INT 105
12055: PPUSH
12056: CALL_OW 67
// americanBaseCaptured := true ;
12060: LD_ADDR_EXP 6
12064: PUSH
12065: LD_INT 1
12067: ST_TO_ADDR
// end ;
12068: PPOPN 2
12070: END
// every 0 0$1 trigger capturedCargoCounter >= 3 do
12071: LD_EXP 13
12075: PUSH
12076: LD_INT 3
12078: GREATEREQUAL
12079: IFFALSE 12091
12081: GO 12083
12083: DISABLE
// SetAchievement ( ACH_ENG ) ;
12084: LD_STRING ACH_ENG
12086: PPUSH
12087: CALL_OW 543
12091: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) >= 4 do
12092: LD_INT 22
12094: PUSH
12095: LD_INT 2
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PUSH
12102: LD_INT 25
12104: PUSH
12105: LD_INT 15
12107: PUSH
12108: EMPTY
12109: LIST
12110: LIST
12111: PUSH
12112: EMPTY
12113: LIST
12114: LIST
12115: PPUSH
12116: CALL_OW 69
12120: PUSH
12121: LD_INT 4
12123: GREATEREQUAL
12124: IFFALSE 12136
12126: GO 12128
12128: DISABLE
// SetAchievement ( ACH_APEGEN ) ;
12129: LD_STRING ACH_APEGEN
12131: PPUSH
12132: CALL_OW 543
12136: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
12137: LD_INT 22
12139: PUSH
12140: LD_INT 2
12142: PUSH
12143: EMPTY
12144: LIST
12145: LIST
12146: PUSH
12147: LD_INT 30
12149: PUSH
12150: LD_INT 2
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: PUSH
12157: LD_INT 3
12159: PUSH
12160: LD_INT 57
12162: PUSH
12163: EMPTY
12164: LIST
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: LIST
12174: PPUSH
12175: CALL_OW 69
12179: IFFALSE 12422
12181: GO 12183
12183: DISABLE
// begin workshopBuilded := true ;
12184: LD_ADDR_EXP 10
12188: PUSH
12189: LD_INT 1
12191: ST_TO_ADDR
// if IsOk ( Markov ) then
12192: LD_EXP 35
12196: PPUSH
12197: CALL_OW 302
12201: IFFALSE 12260
// begin Say ( Heike , DH-1-shop-a ) ;
12203: LD_EXP 28
12207: PPUSH
12208: LD_STRING DH-1-shop-a
12210: PPUSH
12211: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
12215: LD_INT 47
12217: PPUSH
12218: LD_INT 2
12220: PPUSH
12221: CALL_OW 321
12225: PUSH
12226: LD_INT 2
12228: EQUAL
12229: PUSH
12230: LD_INT 45
12232: PPUSH
12233: LD_INT 2
12235: PPUSH
12236: CALL_OW 321
12240: PUSH
12241: LD_INT 2
12243: EQUAL
12244: AND
12245: NOT
12246: IFFALSE 12260
// Say ( Markov , DMar-1-shop-a ) ;
12248: LD_EXP 35
12252: PPUSH
12253: LD_STRING DMar-1-shop-a
12255: PPUSH
12256: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
12260: LD_INT 35
12262: PPUSH
12263: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched or GetTech ( tech_SolEng , 2 ) = state_researched ;
12267: LD_INT 47
12269: PPUSH
12270: LD_INT 2
12272: PPUSH
12273: CALL_OW 321
12277: PUSH
12278: LD_INT 2
12280: EQUAL
12281: PUSH
12282: LD_INT 45
12284: PPUSH
12285: LD_INT 2
12287: PPUSH
12288: CALL_OW 321
12292: PUSH
12293: LD_INT 2
12295: EQUAL
12296: OR
12297: IFFALSE 12260
// DialogueOn ;
12299: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
12303: LD_EXP 35
12307: PPUSH
12308: LD_STRING DMar-1-shop
12310: PPUSH
12311: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
12315: LD_EXP 28
12319: PPUSH
12320: LD_STRING DH-1-shop
12322: PPUSH
12323: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
12327: LD_EXP 35
12331: PPUSH
12332: LD_STRING DMar-2-shop
12334: PPUSH
12335: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12339: LD_EXP 35
12343: PPUSH
12344: LD_STRING DMar-3-shop
12346: PPUSH
12347: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12351: LD_EXP 28
12355: PPUSH
12356: LD_STRING DH-2-shop
12358: PPUSH
12359: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12363: LD_EXP 35
12367: PPUSH
12368: LD_STRING DMar-4-shop
12370: PPUSH
12371: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12375: LD_EXP 28
12379: PPUSH
12380: LD_STRING DH-3-shop
12382: PPUSH
12383: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12387: LD_EXP 35
12391: PPUSH
12392: LD_STRING DMar-5-shop
12394: PPUSH
12395: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12399: LD_EXP 28
12403: PPUSH
12404: LD_STRING DH-4-shop
12406: PPUSH
12407: CALL_OW 88
// DialogueOff ;
12411: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12415: LD_STRING ConstructVeh
12417: PPUSH
12418: CALL_OW 337
// end ;
12422: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12423: LD_INT 2
12425: PPUSH
12426: LD_INT 2
12428: PPUSH
12429: LD_INT 1
12431: PPUSH
12432: CALL 1207 0 3
12436: PUSH
12437: LD_INT 0
12439: EQUAL
12440: IFFALSE 12452
12442: GO 12444
12444: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12445: LD_STRING Techs
12447: PPUSH
12448: CALL_OW 337
12452: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12453: LD_EXP 35
12457: PPUSH
12458: CALL_OW 302
12462: PUSH
12463: LD_INT 22
12465: PUSH
12466: LD_INT 2
12468: PUSH
12469: EMPTY
12470: LIST
12471: LIST
12472: PUSH
12473: LD_INT 2
12475: PUSH
12476: LD_INT 34
12478: PUSH
12479: LD_INT 22
12481: PUSH
12482: EMPTY
12483: LIST
12484: LIST
12485: PUSH
12486: LD_INT 35
12488: PUSH
12489: LD_INT 22
12491: PUSH
12492: EMPTY
12493: LIST
12494: LIST
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: LIST
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: PPUSH
12505: CALL_OW 69
12509: AND
12510: IFFALSE 12617
12512: GO 12514
12514: DISABLE
// begin DialogueOn ;
12515: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12519: LD_INT 22
12521: PUSH
12522: LD_INT 2
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: PUSH
12529: LD_INT 2
12531: PUSH
12532: LD_INT 34
12534: PUSH
12535: LD_INT 22
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PUSH
12542: LD_INT 35
12544: PUSH
12545: LD_INT 22
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: LIST
12556: PUSH
12557: EMPTY
12558: LIST
12559: LIST
12560: PPUSH
12561: CALL_OW 69
12565: PPUSH
12566: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12570: LD_INT 10
12572: PPUSH
12573: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12577: LD_EXP 28
12581: PPUSH
12582: LD_STRING DH-1-bal
12584: PPUSH
12585: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12589: LD_EXP 35
12593: PPUSH
12594: LD_STRING DMar-1-bal
12596: PPUSH
12597: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12601: LD_EXP 28
12605: PPUSH
12606: LD_STRING DH-2-bal
12608: PPUSH
12609: CALL_OW 88
// DialogueOff ;
12613: CALL_OW 7
// end ;
12617: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12618: LD_EXP 32
12622: PPUSH
12623: CALL_OW 302
12627: PUSH
12628: LD_INT 22
12630: PUSH
12631: LD_INT 2
12633: PUSH
12634: EMPTY
12635: LIST
12636: LIST
12637: PUSH
12638: LD_INT 30
12640: PUSH
12641: LD_INT 6
12643: PUSH
12644: EMPTY
12645: LIST
12646: LIST
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PPUSH
12652: CALL_OW 69
12656: AND
12657: IFFALSE 12718
12659: GO 12661
12661: DISABLE
// begin DialogueOn ;
12662: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12666: LD_EXP 32
12670: PPUSH
12671: LD_STRING DA-1-lab
12673: PPUSH
12674: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12678: LD_EXP 28
12682: PPUSH
12683: LD_STRING DH-1-lab
12685: PPUSH
12686: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12690: LD_EXP 32
12694: PPUSH
12695: LD_STRING DA-2-lab
12697: PPUSH
12698: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12702: LD_EXP 28
12706: PPUSH
12707: LD_STRING DH-2-lab
12709: PPUSH
12710: CALL_OW 88
// DialogueOff ;
12714: CALL_OW 7
// end ;
12718: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12719: LD_EXP 33
12723: PPUSH
12724: CALL_OW 302
12728: PUSH
12729: LD_INT 22
12731: PUSH
12732: LD_INT 2
12734: PUSH
12735: EMPTY
12736: LIST
12737: LIST
12738: PUSH
12739: LD_INT 25
12741: PUSH
12742: LD_INT 15
12744: PUSH
12745: EMPTY
12746: LIST
12747: LIST
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PPUSH
12753: CALL_OW 69
12757: AND
12758: PUSH
12759: LD_INT 81
12761: PUSH
12762: LD_INT 2
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: PPUSH
12769: CALL_OW 69
12773: NOT
12774: AND
12775: IFFALSE 12957
12777: GO 12779
12779: DISABLE
12780: LD_INT 0
12782: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12783: LD_ADDR_VAR 0 1
12787: PUSH
12788: LD_INT 22
12790: PUSH
12791: LD_INT 2
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: PUSH
12798: LD_INT 25
12800: PUSH
12801: LD_INT 15
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: EMPTY
12809: LIST
12810: LIST
12811: PPUSH
12812: CALL_OW 69
12816: ST_TO_ADDR
// InGameOn ;
12817: CALL_OW 8
// CenterNowOnUnits ( ape [ 1 ] ) ;
12821: LD_VAR 0 1
12825: PUSH
12826: LD_INT 1
12828: ARRAY
12829: PPUSH
12830: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12834: LD_VAR 0 1
12838: PUSH
12839: LD_INT 1
12841: ARRAY
12842: PPUSH
12843: CALL_OW 122
// Say ( Kaia , DK-1-apesol ) ;
12847: LD_EXP 33
12851: PPUSH
12852: LD_STRING DK-1-apesol
12854: PPUSH
12855: CALL_OW 88
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12859: LD_VAR 0 1
12863: PUSH
12864: LD_INT 1
12866: ARRAY
12867: PPUSH
12868: LD_INT 35
12870: PPUSH
12871: LD_INT 28
12873: PPUSH
12874: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12878: LD_VAR 0 1
12882: PUSH
12883: LD_INT 1
12885: ARRAY
12886: PPUSH
12887: LD_INT 36
12889: PPUSH
12890: LD_INT 17
12892: PPUSH
12893: CALL_OW 171
// DialogueOn ;
12897: CALL_OW 6
// Say ( Aviradze , DA-1-apesol ) ;
12901: LD_EXP 32
12905: PPUSH
12906: LD_STRING DA-1-apesol
12908: PPUSH
12909: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12913: LD_EXP 33
12917: PPUSH
12918: LD_STRING DK-2-apesol
12920: PPUSH
12921: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12925: LD_EXP 32
12929: PPUSH
12930: LD_STRING DA-2-apesol
12932: PPUSH
12933: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12937: LD_EXP 33
12941: PPUSH
12942: LD_STRING DK-3-apesol
12944: PPUSH
12945: CALL_OW 88
// DialogueOff ;
12949: CALL_OW 7
// InGameOff ;
12953: CALL_OW 9
// end ;
12957: PPOPN 1
12959: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) and not FilterAllUnits ( [ f_enemy , 2 ] ) do var ape ;
12960: LD_EXP 34
12964: PPUSH
12965: CALL_OW 302
12969: PUSH
12970: LD_INT 22
12972: PUSH
12973: LD_INT 2
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PUSH
12980: LD_INT 25
12982: PUSH
12983: LD_INT 16
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PPUSH
12994: CALL_OW 69
12998: AND
12999: PUSH
13000: LD_INT 81
13002: PUSH
13003: LD_INT 2
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: PPUSH
13010: CALL_OW 69
13014: NOT
13015: AND
13016: IFFALSE 13279
13018: GO 13020
13020: DISABLE
13021: LD_INT 0
13023: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
13024: LD_ADDR_VAR 0 1
13028: PUSH
13029: LD_INT 22
13031: PUSH
13032: LD_INT 2
13034: PUSH
13035: EMPTY
13036: LIST
13037: LIST
13038: PUSH
13039: LD_INT 25
13041: PUSH
13042: LD_INT 16
13044: PUSH
13045: EMPTY
13046: LIST
13047: LIST
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PPUSH
13053: CALL_OW 69
13057: ST_TO_ADDR
// InGameOn ;
13058: CALL_OW 8
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
13062: LD_INT 5
13064: PPUSH
13065: LD_INT 35
13067: PPUSH
13068: LD_INT 22
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
13078: LD_EXP 34
13082: PPUSH
13083: LD_VAR 0 1
13087: PUSH
13088: LD_INT 1
13090: ARRAY
13091: PPUSH
13092: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
13096: LD_VAR 0 1
13100: PUSH
13101: LD_INT 1
13103: ARRAY
13104: PPUSH
13105: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
13109: LD_VAR 0 1
13113: PUSH
13114: LD_INT 1
13116: ARRAY
13117: PPUSH
13118: CALL_OW 122
// wait ( 0 0$2 ) ;
13122: LD_INT 70
13124: PPUSH
13125: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
13129: LD_EXP 34
13133: PPUSH
13134: LD_STRING DS-1-apeeng
13136: PPUSH
13137: CALL_OW 88
// if IsOk ( Kamil ) then
13141: LD_EXP 31
13145: PPUSH
13146: CALL_OW 302
13150: IFFALSE 13275
// begin Say ( Kamil , DKam-1-apeeng ) ;
13152: LD_EXP 31
13156: PPUSH
13157: LD_STRING DKam-1-apeeng
13159: PPUSH
13160: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
13164: LD_EXP 34
13168: PPUSH
13169: LD_STRING DS-2-apeeng
13171: PPUSH
13172: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
13176: LD_EXP 31
13180: PPUSH
13181: LD_STRING DKam-2-apeeng
13183: PPUSH
13184: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
13188: LD_EXP 34
13192: PPUSH
13193: LD_STRING DS-3-apeeng
13195: PPUSH
13196: CALL_OW 88
// if not IsOK ( Kaia ) then
13200: LD_EXP 33
13204: PPUSH
13205: CALL_OW 302
13209: NOT
13210: IFFALSE 13218
// begin InGameOff ;
13212: CALL_OW 9
// exit ;
13216: GO 13279
// end ; Say ( Kaia , DK-1-apeeng ) ;
13218: LD_EXP 33
13222: PPUSH
13223: LD_STRING DK-1-apeeng
13225: PPUSH
13226: CALL_OW 88
// if not IsOk ( Givi ) then
13230: LD_EXP 29
13234: PPUSH
13235: CALL_OW 302
13239: NOT
13240: IFFALSE 13251
// begin Video ( false ) ;
13242: LD_INT 0
13244: PPUSH
13245: CALL 1036 0 1
// exit ;
13249: GO 13279
// end ; Say ( Givi , DG-1-apeeng ) ;
13251: LD_EXP 29
13255: PPUSH
13256: LD_STRING DG-1-apeeng
13258: PPUSH
13259: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
13263: LD_EXP 33
13267: PPUSH
13268: LD_STRING DK-2-apeeng
13270: PPUSH
13271: CALL_OW 88
// end ; InGameOff ;
13275: CALL_OW 9
// end ;
13279: PPOPN 1
13281: END
// every 0 0$10 trigger farmerBaseReady and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) do
13282: LD_EXP 4
13286: PUSH
13287: LD_INT 22
13289: PUSH
13290: LD_INT 2
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 30
13299: PUSH
13300: LD_INT 0
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: PUSH
13307: EMPTY
13308: LIST
13309: LIST
13310: PPUSH
13311: CALL_OW 69
13315: AND
13316: IFFALSE 13481
13318: GO 13320
13320: DISABLE
// begin wait ( 0 0$10 ) ;
13321: LD_INT 350
13323: PPUSH
13324: CALL_OW 67
// DialogueOn ;
13328: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
13332: LD_EXP 36
13336: PPUSH
13337: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
13341: LD_EXP 36
13345: PPUSH
13346: LD_STRING DF-1-distribution
13348: PPUSH
13349: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
13353: LD_EXP 28
13357: PPUSH
13358: LD_STRING DH-2-distribution
13360: PPUSH
13361: CALL_OW 88
// if IsOk ( Kaia ) then
13365: LD_EXP 33
13369: PPUSH
13370: CALL_OW 302
13374: IFFALSE 13435
// begin Say ( Kaia , DK-1-distribution ) ;
13376: LD_EXP 33
13380: PPUSH
13381: LD_STRING DK-1-distribution
13383: PPUSH
13384: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
13388: LD_EXP 28
13392: PPUSH
13393: LD_STRING DH-1-distribution
13395: PPUSH
13396: CALL_OW 88
// if IsOk ( Givi ) then
13400: LD_EXP 29
13404: PPUSH
13405: CALL_OW 302
13409: IFFALSE 13435
// begin Say ( Givi , DG-1-distribution ) ;
13411: LD_EXP 29
13415: PPUSH
13416: LD_STRING DG-1-distribution
13418: PPUSH
13419: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13423: LD_EXP 28
13427: PPUSH
13428: LD_STRING DH-3-distribution
13430: PPUSH
13431: CALL_OW 88
// end ; end ; DialogueOff ;
13435: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13439: LD_STRING Crates1
13441: PPUSH
13442: CALL_OW 337
// farmerRequestedCrates := 300 ;
13446: LD_ADDR_EXP 16
13450: PUSH
13451: LD_INT 300
13453: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13454: LD_STRING FarmerCrates
13456: PPUSH
13457: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13461: LD_INT 10
13463: PPUSH
13464: LD_INT 1
13466: PPUSH
13467: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13471: LD_INT 108
13473: PPUSH
13474: LD_INT 61
13476: PPUSH
13477: CALL_OW 86
// end ;
13481: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13482: LD_EXP 6
13486: PUSH
13487: LD_INT 22
13489: PUSH
13490: LD_INT 2
13492: PUSH
13493: EMPTY
13494: LIST
13495: LIST
13496: PUSH
13497: LD_INT 3
13499: PUSH
13500: LD_INT 57
13502: PUSH
13503: EMPTY
13504: LIST
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: PUSH
13510: LD_INT 2
13512: PUSH
13513: LD_INT 30
13515: PUSH
13516: LD_INT 6
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PUSH
13523: LD_INT 30
13525: PUSH
13526: LD_INT 7
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: PUSH
13533: EMPTY
13534: LIST
13535: LIST
13536: LIST
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: LIST
13542: PPUSH
13543: CALL_OW 69
13547: AND
13548: PUSH
13549: LD_INT 22
13551: PUSH
13552: LD_INT 2
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: LD_INT 3
13561: PUSH
13562: LD_INT 57
13564: PUSH
13565: EMPTY
13566: LIST
13567: PUSH
13568: EMPTY
13569: LIST
13570: LIST
13571: PUSH
13572: LD_INT 30
13574: PUSH
13575: LD_INT 4
13577: PUSH
13578: EMPTY
13579: LIST
13580: LIST
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: LIST
13586: PPUSH
13587: CALL_OW 69
13591: AND
13592: IFFALSE 13756
13594: GO 13596
13596: DISABLE
13597: LD_INT 0
13599: PPUSH
// begin wait ( 0 0$10 ) ;
13600: LD_INT 350
13602: PPUSH
13603: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13607: LD_ADDR_VAR 0 1
13611: PUSH
13612: LD_EXP 42
13616: PPUSH
13617: LD_INT 26
13619: PUSH
13620: LD_INT 1
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PUSH
13627: LD_INT 25
13629: PUSH
13630: LD_INT 2
13632: PUSH
13633: EMPTY
13634: LIST
13635: LIST
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PPUSH
13641: CALL_OW 72
13645: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13646: LD_EXP 28
13650: PPUSH
13651: LD_STRING DH-1-task
13653: PPUSH
13654: CALL_OW 88
// if IsOk ( Sophia ) then
13658: LD_EXP 34
13662: PPUSH
13663: CALL_OW 302
13667: IFFALSE 13707
// begin Say ( Sophia , DS-1-task ) ;
13669: LD_EXP 34
13673: PPUSH
13674: LD_STRING DS-1-task
13676: PPUSH
13677: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13681: LD_EXP 34
13685: PPUSH
13686: LD_STRING DS-2-task
13688: PPUSH
13689: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13693: LD_EXP 28
13697: PPUSH
13698: LD_STRING DH-2-task
13700: PPUSH
13701: CALL_OW 88
// end else
13705: GO 13741
// if eng then
13707: LD_VAR 0 1
13711: IFFALSE 13741
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13713: LD_VAR 0 1
13717: PUSH
13718: LD_INT 1
13720: ARRAY
13721: PPUSH
13722: LD_STRING DArm-1-task
13724: PPUSH
13725: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13729: LD_EXP 28
13733: PPUSH
13734: LD_STRING DH-2-task
13736: PPUSH
13737: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13741: LD_STRING BaseConstructed
13743: PPUSH
13744: CALL_OW 337
// allowConvoys := true ;
13748: LD_ADDR_EXP 12
13752: PUSH
13753: LD_INT 1
13755: ST_TO_ADDR
// end ;
13756: PPOPN 1
13758: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13759: LD_INT 22
13761: PUSH
13762: LD_INT 4
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: PUSH
13769: LD_INT 34
13771: PUSH
13772: LD_INT 12
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: PPUSH
13783: CALL_OW 69
13787: IFFALSE 13955
13789: GO 13791
13791: DISABLE
13792: LD_INT 0
13794: PPUSH
13795: PPUSH
13796: PPUSH
// begin wait ( 0 0$2 ) ;
13797: LD_INT 70
13799: PPUSH
13800: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13804: LD_ADDR_VAR 0 1
13808: PUSH
13809: LD_INT 22
13811: PUSH
13812: LD_INT 4
13814: PUSH
13815: EMPTY
13816: LIST
13817: LIST
13818: PUSH
13819: LD_INT 34
13821: PUSH
13822: LD_INT 12
13824: PUSH
13825: EMPTY
13826: LIST
13827: LIST
13828: PUSH
13829: EMPTY
13830: LIST
13831: LIST
13832: PPUSH
13833: CALL_OW 69
13837: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13838: LD_ADDR_VAR 0 2
13842: PUSH
13843: LD_VAR 0 1
13847: PUSH
13848: LD_INT 1
13850: ARRAY
13851: PPUSH
13852: CALL_OW 250
13856: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13857: LD_ADDR_VAR 0 3
13861: PUSH
13862: LD_VAR 0 1
13866: PUSH
13867: LD_INT 1
13869: ARRAY
13870: PPUSH
13871: CALL_OW 251
13875: ST_TO_ADDR
// DialogueOn ;
13876: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13880: LD_VAR 0 2
13884: PPUSH
13885: LD_VAR 0 3
13889: PPUSH
13890: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13894: LD_VAR 0 2
13898: PPUSH
13899: LD_VAR 0 3
13903: PPUSH
13904: LD_INT 2
13906: PPUSH
13907: LD_INT 6
13909: NEG
13910: PPUSH
13911: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13915: LD_INT 10
13917: PPUSH
13918: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13922: LD_EXP 28
13926: PPUSH
13927: LD_STRING DH-1-seecargo
13929: PPUSH
13930: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13934: LD_VAR 0 2
13938: PPUSH
13939: LD_VAR 0 3
13943: PPUSH
13944: LD_INT 2
13946: PPUSH
13947: CALL_OW 331
// DialogueOff ;
13951: CALL_OW 7
// end ;
13955: PPOPN 3
13957: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13958: LD_EXP 4
13962: PUSH
13963: LD_EXP 15
13967: PUSH
13968: LD_INT 300
13970: GREATEREQUAL
13971: AND
13972: IFFALSE 14044
13974: GO 13976
13976: DISABLE
// begin DialogueOn ;
13977: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13981: LD_EXP 36
13985: PPUSH
13986: LD_STRING DF-1-delivery-2
13988: PPUSH
13989: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13993: LD_EXP 28
13997: PPUSH
13998: LD_STRING DH-1-delivery-2
14000: PPUSH
14001: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
14005: LD_EXP 36
14009: PPUSH
14010: LD_STRING DF-2-delivery-2
14012: PPUSH
14013: CALL_OW 94
// DialogueOff ;
14017: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
14021: LD_STRING Crates2
14023: PPUSH
14024: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14028: LD_ADDR_EXP 17
14032: PUSH
14033: LD_INT 63000
14035: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
14036: LD_ADDR_EXP 16
14040: PUSH
14041: LD_INT 600
14043: ST_TO_ADDR
// end ;
14044: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 and Difficulty > 1 do
14045: LD_EXP 4
14049: PUSH
14050: LD_EXP 15
14054: PUSH
14055: LD_INT 600
14057: GREATEREQUAL
14058: AND
14059: PUSH
14060: LD_OWVAR 67
14064: PUSH
14065: LD_INT 1
14067: GREATER
14068: AND
14069: IFFALSE 14235
14071: GO 14073
14073: DISABLE
// begin DialogueOn ;
14074: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
14078: LD_EXP 36
14082: PPUSH
14083: LD_STRING DF-1-delivery-3
14085: PPUSH
14086: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
14090: LD_EXP 28
14094: PPUSH
14095: LD_STRING DH-1-delivery-3
14097: PPUSH
14098: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
14102: LD_EXP 36
14106: PPUSH
14107: LD_STRING DF-2-delivery-3
14109: PPUSH
14110: CALL_OW 94
// if IsOk ( Kaia ) then
14114: LD_EXP 33
14118: PPUSH
14119: CALL_OW 302
14123: IFFALSE 14173
// begin Say ( Kaia , DK-1-delivery-3 ) ;
14125: LD_EXP 33
14129: PPUSH
14130: LD_STRING DK-1-delivery-3
14132: PPUSH
14133: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
14137: LD_EXP 28
14141: PPUSH
14142: LD_STRING DH-2-delivery-3
14144: PPUSH
14145: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
14149: LD_EXP 29
14153: PPUSH
14154: LD_STRING DG-1-delivery-3
14156: PPUSH
14157: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
14161: LD_EXP 30
14165: PPUSH
14166: LD_STRING DM-1-delivery-3
14168: PPUSH
14169: CALL_OW 88
// end ; DialogueOff ;
14173: CALL_OW 7
// if Difficulty = 2 then
14177: LD_OWVAR 67
14181: PUSH
14182: LD_INT 2
14184: EQUAL
14185: IFFALSE 14212
// begin ChangeMissionObjectives ( Crates3 ) ;
14187: LD_STRING Crates3
14189: PPUSH
14190: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14194: LD_ADDR_EXP 17
14198: PUSH
14199: LD_INT 63000
14201: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
14202: LD_ADDR_EXP 16
14206: PUSH
14207: LD_INT 900
14209: ST_TO_ADDR
// end else
14210: GO 14235
// begin ChangeMissionObjectives ( Crates4 ) ;
14212: LD_STRING Crates4
14214: PPUSH
14215: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
14219: LD_ADDR_EXP 17
14223: PUSH
14224: LD_INT 63000
14226: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
14227: LD_ADDR_EXP 16
14231: PUSH
14232: LD_INT 1200
14234: ST_TO_ADDR
// end ; end ;
14235: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
14236: LD_EXP 4
14240: PUSH
14241: LD_EXP 15
14245: PUSH
14246: LD_INT 600
14248: PUSH
14249: LD_INT 900
14251: PUSH
14252: LD_INT 1200
14254: PUSH
14255: EMPTY
14256: LIST
14257: LIST
14258: LIST
14259: PUSH
14260: LD_OWVAR 67
14264: ARRAY
14265: GREATEREQUAL
14266: AND
14267: PUSH
14268: LD_EXP 16
14272: PUSH
14273: LD_EXP 17
14277: LESSEQUAL
14278: AND
14279: IFFALSE 14346
14281: GO 14283
14283: DISABLE
// begin retreatAllowed := true ;
14284: LD_ADDR_EXP 11
14288: PUSH
14289: LD_INT 1
14291: ST_TO_ADDR
// display_strings := [ ] ;
14292: LD_ADDR_OWVAR 47
14296: PUSH
14297: EMPTY
14298: ST_TO_ADDR
// DialogueOn ;
14299: CALL_OW 6
// InGameOn ;
14303: CALL_OW 8
// SayRadio ( Omar , DO-radio-end ) ;
14307: LD_EXP 37
14311: PPUSH
14312: LD_STRING DO-radio-end
14314: PPUSH
14315: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
14319: LD_EXP 28
14323: PPUSH
14324: LD_STRING DH-1-radio-end
14326: PPUSH
14327: CALL_OW 88
// InGameOff ;
14331: CALL_OW 9
// DialogueOff ;
14335: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
14339: LD_STRING Retreat
14341: PPUSH
14342: CALL_OW 337
// end ;
14346: END
// every 0 0$1 trigger retreatAllowed do var tmp , i ;
14347: LD_EXP 11
14351: IFFALSE 14482
14353: GO 14355
14355: DISABLE
14356: LD_INT 0
14358: PPUSH
14359: PPUSH
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
14360: LD_INT 10
14362: PPUSH
14363: LD_INT 0
14365: PPUSH
14366: CALL_OW 424
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
14370: LD_ADDR_VAR 0 1
14374: PUSH
14375: LD_EXP 39
14379: PPUSH
14380: LD_INT 25
14382: PUSH
14383: LD_INT 2
14385: PUSH
14386: EMPTY
14387: LIST
14388: LIST
14389: PPUSH
14390: CALL_OW 72
14394: ST_TO_ADDR
// if tmp and HexInfo ( 102 , 69 ) = 0 then
14395: LD_VAR 0 1
14399: PUSH
14400: LD_INT 102
14402: PPUSH
14403: LD_INT 69
14405: PPUSH
14406: CALL_OW 428
14410: PUSH
14411: LD_INT 0
14413: EQUAL
14414: AND
14415: IFFALSE 14482
// begin for i in tmp do
14417: LD_ADDR_VAR 0 2
14421: PUSH
14422: LD_VAR 0 1
14426: PUSH
14427: FOR_IN
14428: IFFALSE 14452
// if IsInUnit ( i ) then
14430: LD_VAR 0 2
14434: PPUSH
14435: CALL_OW 310
14439: IFFALSE 14450
// ComExitBuilding ( i ) ;
14441: LD_VAR 0 2
14445: PPUSH
14446: CALL_OW 122
14450: GO 14427
14452: POP
14453: POP
// AddComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
14454: LD_VAR 0 1
14458: PPUSH
14459: LD_INT 31
14461: PPUSH
14462: LD_INT 102
14464: PPUSH
14465: LD_INT 69
14467: PPUSH
14468: LD_INT 2
14470: PPUSH
14471: CALL_OW 205
// wait ( 0 0$3 ) ;
14475: LD_INT 105
14477: PPUSH
14478: CALL_OW 67
// end ; end ;
14482: PPOPN 2
14484: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
14485: LD_EXP 11
14489: NOT
14490: PUSH
14491: LD_INT 5
14493: PPUSH
14494: CALL_OW 301
14498: AND
14499: IFFALSE 14531
14501: GO 14503
14503: DISABLE
// begin DialogueOn ;
14504: CALL_OW 6
// SayRadio ( Farmer , DF-1-failure ) ;
14508: LD_EXP 36
14512: PPUSH
14513: LD_STRING DF-1-failure
14515: PPUSH
14516: CALL_OW 94
// DialogueOff ;
14520: CALL_OW 7
// YouLost ( FarmerDepot ) ;
14524: LD_STRING FarmerDepot
14526: PPUSH
14527: CALL_OW 104
// end ;
14531: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 and not FilterAllUnits ( [ [ f_enemy , 2 ] , [ f_type , unit_human ] ] ) do var i , max , tmp ;
14532: LD_EXP 11
14536: PUSH
14537: LD_EXP 28
14541: PPUSH
14542: LD_EXP 36
14546: PPUSH
14547: CALL_OW 296
14551: PUSH
14552: LD_INT 6
14554: LESS
14555: AND
14556: PUSH
14557: LD_INT 81
14559: PUSH
14560: LD_INT 2
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: PUSH
14567: LD_INT 21
14569: PUSH
14570: LD_INT 1
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: PPUSH
14581: CALL_OW 69
14585: NOT
14586: AND
14587: IFFALSE 15208
14589: GO 14591
14591: DISABLE
14592: LD_INT 0
14594: PPUSH
14595: PPUSH
14596: PPUSH
// begin allowConvoys := false ;
14597: LD_ADDR_EXP 12
14601: PUSH
14602: LD_INT 0
14604: ST_TO_ADDR
// InGameOn ;
14605: CALL_OW 8
// ComTurnUnit ( Heike , Farmer ) ;
14609: LD_EXP 28
14613: PPUSH
14614: LD_EXP 36
14618: PPUSH
14619: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14623: LD_EXP 36
14627: PPUSH
14628: LD_EXP 28
14632: PPUSH
14633: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14637: LD_EXP 36
14641: PPUSH
14642: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14646: LD_EXP 28
14650: PPUSH
14651: LD_STRING DH-1-end
14653: PPUSH
14654: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14658: LD_EXP 36
14662: PPUSH
14663: LD_STRING DF-1-end
14665: PPUSH
14666: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14670: LD_EXP 36
14674: PPUSH
14675: LD_STRING DF-2-end
14677: PPUSH
14678: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14682: LD_EXP 28
14686: PPUSH
14687: LD_STRING DH-2-end
14689: PPUSH
14690: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14694: LD_EXP 36
14698: PPUSH
14699: LD_STRING DF-3-end
14701: PPUSH
14702: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14706: LD_EXP 28
14710: PPUSH
14711: LD_STRING DH-3-end
14713: PPUSH
14714: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14718: LD_EXP 29
14722: PPUSH
14723: LD_STRING DG-1-end
14725: PPUSH
14726: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14730: LD_EXP 28
14734: PPUSH
14735: LD_STRING DH-4-end
14737: PPUSH
14738: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14742: LD_EXP 36
14746: PPUSH
14747: LD_STRING DF-4-end
14749: PPUSH
14750: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14754: LD_EXP 28
14758: PPUSH
14759: LD_STRING DH-5-end
14761: PPUSH
14762: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14766: LD_EXP 36
14770: PPUSH
14771: LD_STRING DF-5-end
14773: PPUSH
14774: CALL_OW 88
// InGameOff ;
14778: CALL_OW 9
// allowCargoEvacuation := true ;
14782: LD_ADDR_EXP 7
14786: PUSH
14787: LD_INT 1
14789: ST_TO_ADDR
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14790: LD_ADDR_VAR 0 2
14794: PUSH
14795: LD_INT 4
14797: PUSH
14798: LD_INT 3
14800: PUSH
14801: LD_INT 2
14803: PUSH
14804: EMPTY
14805: LIST
14806: LIST
14807: LIST
14808: PUSH
14809: LD_OWVAR 67
14813: ARRAY
14814: ST_TO_ADDR
// if farmerSquad < max then
14815: LD_EXP 39
14819: PUSH
14820: LD_VAR 0 2
14824: LESS
14825: IFFALSE 14837
// max := farmerSquad ;
14827: LD_ADDR_VAR 0 2
14831: PUSH
14832: LD_EXP 39
14836: ST_TO_ADDR
// for i := 1 to max do
14837: LD_ADDR_VAR 0 1
14841: PUSH
14842: DOUBLE
14843: LD_INT 1
14845: DEC
14846: ST_TO_ADDR
14847: LD_VAR 0 2
14851: PUSH
14852: FOR_TO
14853: IFFALSE 14891
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14855: LD_EXP 39
14859: PUSH
14860: LD_INT 1
14862: ARRAY
14863: PPUSH
14864: LD_INT 2
14866: PPUSH
14867: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14871: LD_ADDR_EXP 39
14875: PUSH
14876: LD_EXP 39
14880: PPUSH
14881: LD_INT 1
14883: PPUSH
14884: CALL_OW 3
14888: ST_TO_ADDR
// end ;
14889: GO 14852
14891: POP
14892: POP
// for i in Farmer ^ farmerSquad do
14893: LD_ADDR_VAR 0 1
14897: PUSH
14898: LD_EXP 36
14902: PUSH
14903: LD_EXP 39
14907: ADD
14908: PUSH
14909: FOR_IN
14910: IFFALSE 14949
// begin if IsInUnit ( i ) then
14912: LD_VAR 0 1
14916: PPUSH
14917: CALL_OW 310
14921: IFFALSE 14932
// ComExitBuilding ( i ) ;
14923: LD_VAR 0 1
14927: PPUSH
14928: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14932: LD_VAR 0 1
14936: PPUSH
14937: LD_INT 102
14939: PPUSH
14940: LD_INT 7
14942: PPUSH
14943: CALL_OW 171
// end ;
14947: GO 14909
14949: POP
14950: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14951: LD_ADDR_VAR 0 1
14955: PUSH
14956: LD_INT 22
14958: PUSH
14959: LD_INT 5
14961: PUSH
14962: EMPTY
14963: LIST
14964: LIST
14965: PUSH
14966: LD_INT 21
14968: PUSH
14969: LD_INT 3
14971: PUSH
14972: EMPTY
14973: LIST
14974: LIST
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: PPUSH
14980: CALL_OW 69
14984: PUSH
14985: LD_INT 5
14987: DIFF
14988: PUSH
14989: FOR_IN
14990: IFFALSE 15006
// SetSide ( i , 2 ) ;
14992: LD_VAR 0 1
14996: PPUSH
14997: LD_INT 2
14999: PPUSH
15000: CALL_OW 235
15004: GO 14989
15006: POP
15007: POP
// repeat wait ( 0 0$1 ) ;
15008: LD_INT 35
15010: PPUSH
15011: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
15015: LD_ADDR_VAR 0 3
15019: PUSH
15020: LD_EXP 36
15024: PUSH
15025: LD_EXP 39
15029: ADD
15030: PPUSH
15031: LD_INT 95
15033: PUSH
15034: LD_INT 3
15036: PUSH
15037: EMPTY
15038: LIST
15039: LIST
15040: PPUSH
15041: CALL_OW 72
15045: ST_TO_ADDR
// if tmp then
15046: LD_VAR 0 3
15050: IFFALSE 15094
// for i in tmp do
15052: LD_ADDR_VAR 0 1
15056: PUSH
15057: LD_VAR 0 3
15061: PUSH
15062: FOR_IN
15063: IFFALSE 15092
// begin farmerSquad := farmerSquad diff i ;
15065: LD_ADDR_EXP 39
15069: PUSH
15070: LD_EXP 39
15074: PUSH
15075: LD_VAR 0 1
15079: DIFF
15080: ST_TO_ADDR
// RemoveUnit ( i ) ;
15081: LD_VAR 0 1
15085: PPUSH
15086: CALL_OW 64
// end ;
15090: GO 15062
15092: POP
15093: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
15094: LD_EXP 39
15098: PUSH
15099: EMPTY
15100: EQUAL
15101: PUSH
15102: LD_EXP 36
15106: PPUSH
15107: CALL_OW 305
15111: NOT
15112: AND
15113: IFFALSE 15008
// if farmerHumanLoseCounter = 0 then
15115: LD_EXP 20
15119: PUSH
15120: LD_INT 0
15122: EQUAL
15123: IFFALSE 15132
// SetAchievement ( ACH_BABY ) ;
15125: LD_STRING ACH_BABY
15127: PPUSH
15128: CALL_OW 543
// wait ( 1 1$00 ) ;
15132: LD_INT 2100
15134: PPUSH
15135: CALL_OW 67
// SendAttack ;
15139: CALL 7034 0 0
// for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
15143: LD_ADDR_VAR 0 1
15147: PUSH
15148: DOUBLE
15149: LD_INT 1
15151: DEC
15152: ST_TO_ADDR
15153: LD_INT 2
15155: PUSH
15156: LD_INT 3
15158: PUSH
15159: LD_INT 4
15161: PUSH
15162: EMPTY
15163: LIST
15164: LIST
15165: LIST
15166: PUSH
15167: LD_OWVAR 67
15171: ARRAY
15172: PUSH
15173: FOR_TO
15174: IFFALSE 15206
// begin wait ( [ 2 2$00 , 1 1$40 , 1 1$30 ] [ Difficulty ] ) ;
15176: LD_INT 4200
15178: PUSH
15179: LD_INT 3500
15181: PUSH
15182: LD_INT 3150
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: LIST
15189: PUSH
15190: LD_OWVAR 67
15194: ARRAY
15195: PPUSH
15196: CALL_OW 67
// SendAttack ;
15200: CALL 7034 0 0
// end ;
15204: GO 15173
15206: POP
15207: POP
// end ;
15208: PPOPN 3
15210: END
// every 0 0$1 trigger allowCargoEvacuation do
15211: LD_EXP 7
15215: IFFALSE 15224
15217: GO 15219
15219: DISABLE
// StartCargoEvacuation ;
15220: CALL 4570 0 0
15224: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
15225: LD_EXP 17
15229: PUSH
15230: LD_INT 18900
15232: LESSEQUAL
15233: IFFALSE 15282
15235: GO 15237
15237: DISABLE
// begin DialogueOn ;
15238: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
15242: LD_EXP 36
15246: PPUSH
15247: LD_STRING DF-1-distribution-a
15249: PPUSH
15250: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
15254: LD_EXP 28
15258: PPUSH
15259: LD_STRING DH-1-distribution-a
15261: PPUSH
15262: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
15266: LD_EXP 36
15270: PPUSH
15271: LD_STRING DF-2-distribution-a
15273: PPUSH
15274: CALL_OW 94
// DialogueOff ;
15278: CALL_OW 7
// end ;
15282: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
15283: LD_EXP 17
15287: PUSH
15288: LD_INT 0
15290: LESSEQUAL
15291: IFFALSE 15323
15293: GO 15295
15295: DISABLE
// begin DialogueOn ;
15296: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
15300: LD_EXP 36
15304: PPUSH
15305: LD_STRING DF-3-distribution-a
15307: PPUSH
15308: CALL_OW 94
// YouLost ( Distribution ) ;
15312: LD_STRING Distribution
15314: PPUSH
15315: CALL_OW 104
// DialogueOff ;
15319: CALL_OW 7
// end ;
15323: END
// every 0 0$1 trigger vehCounter >= 2 do
15324: LD_EXP 22
15328: PUSH
15329: LD_INT 2
15331: GREATEREQUAL
15332: IFFALSE 15344
15334: GO 15336
15336: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
15337: LD_STRING VehConstructed
15339: PPUSH
15340: CALL_OW 337
15344: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
15345: LD_INT 22
15347: PUSH
15348: LD_INT 2
15350: PUSH
15351: EMPTY
15352: LIST
15353: LIST
15354: PUSH
15355: LD_INT 34
15357: PUSH
15358: LD_INT 12
15360: PUSH
15361: EMPTY
15362: LIST
15363: LIST
15364: PUSH
15365: EMPTY
15366: LIST
15367: LIST
15368: PPUSH
15369: CALL_OW 69
15373: IFFALSE 15433
15375: GO 15377
15377: DISABLE
// begin DialogueOn ;
15378: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
15382: LD_EXP 28
15386: PPUSH
15387: LD_STRING DH-1-truck
15389: PPUSH
15390: CALL_OW 88
// if IsOk ( Markov ) then
15394: LD_EXP 35
15398: PPUSH
15399: CALL_OW 302
15403: IFFALSE 15429
// begin Say ( Markov , DMar-1-truck ) ;
15405: LD_EXP 35
15409: PPUSH
15410: LD_STRING DMar-1-truck
15412: PPUSH
15413: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
15417: LD_EXP 28
15421: PPUSH
15422: LD_STRING DH-2-truck
15424: PPUSH
15425: CALL_OW 88
// end ; DialogueOff ;
15429: CALL_OW 7
// end ;
15433: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
15434: LD_INT 0
15436: PPUSH
15437: PPUSH
15438: PPUSH
// if IsOk ( Givi ) then
15439: LD_EXP 29
15443: PPUSH
15444: CALL_OW 302
15448: IFFALSE 15464
// begin Say ( Givi , DG-1-nocargo ) ;
15450: LD_EXP 29
15454: PPUSH
15455: LD_STRING DG-1-nocargo
15457: PPUSH
15458: CALL_OW 88
// exit ;
15462: GO 15560
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15464: LD_ADDR_VAR 0 2
15468: PUSH
15469: LD_EXP 42
15473: PPUSH
15474: LD_INT 26
15476: PUSH
15477: LD_INT 1
15479: PUSH
15480: EMPTY
15481: LIST
15482: LIST
15483: PPUSH
15484: CALL_OW 72
15488: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15489: LD_ADDR_VAR 0 3
15493: PUSH
15494: LD_EXP 42
15498: PPUSH
15499: LD_INT 26
15501: PUSH
15502: LD_INT 2
15504: PUSH
15505: EMPTY
15506: LIST
15507: LIST
15508: PPUSH
15509: CALL_OW 72
15513: ST_TO_ADDR
// if randomMen then
15514: LD_VAR 0 2
15518: IFFALSE 15538
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
15520: LD_VAR 0 2
15524: PUSH
15525: LD_INT 1
15527: ARRAY
15528: PPUSH
15529: LD_STRING DArm-1-nocargo
15531: PPUSH
15532: CALL_OW 88
15536: GO 15560
// if randomWomen then
15538: LD_VAR 0 3
15542: IFFALSE 15560
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
15544: LD_VAR 0 3
15548: PUSH
15549: LD_INT 1
15551: ARRAY
15552: PPUSH
15553: LD_STRING DArf-1-nocargo
15555: PPUSH
15556: CALL_OW 88
// end ;
15560: LD_VAR 0 1
15564: RET
// export function IncomingAttack ; begin
15565: LD_INT 0
15567: PPUSH
// if attackWave = 1 then
15568: LD_EXP 19
15572: PUSH
15573: LD_INT 1
15575: EQUAL
15576: IFFALSE 15647
// begin DialogueOn ;
15578: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
15582: LD_EXP 37
15586: PPUSH
15587: LD_STRING DO-1-radio-1
15589: PPUSH
15590: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
15594: LD_EXP 28
15598: PPUSH
15599: LD_STRING DH-1-radio-1-
15601: PPUSH
15602: CALL_OW 88
// if IsOk ( Markov ) then
15606: LD_EXP 35
15610: PPUSH
15611: CALL_OW 302
15615: IFFALSE 15641
// begin Say ( Markov , DMar-1-radio-1 ) ;
15617: LD_EXP 35
15621: PPUSH
15622: LD_STRING DMar-1-radio-1
15624: PPUSH
15625: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15629: LD_EXP 28
15633: PPUSH
15634: LD_STRING DH-2-radio-1
15636: PPUSH
15637: CALL_OW 88
// end ; DialogueOff ;
15641: CALL_OW 7
// end else
15645: GO 15671
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15647: LD_EXP 37
15651: PPUSH
15652: LD_STRING DO-1-radio-u
15654: PPUSH
15655: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15659: LD_EXP 28
15663: PPUSH
15664: LD_STRING DH-1-radio-u
15666: PPUSH
15667: CALL_OW 88
// end ; end ;
15671: LD_VAR 0 1
15675: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15676: LD_EXP 44
15680: PPUSH
15681: LD_INT 95
15683: PUSH
15684: LD_INT 8
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: PPUSH
15691: CALL_OW 72
15695: IFFALSE 15798
15697: GO 15699
15699: DISABLE
15700: LD_INT 0
15702: PPUSH
// begin enable ;
15703: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15704: LD_ADDR_VAR 0 1
15708: PUSH
15709: LD_EXP 44
15713: PPUSH
15714: LD_INT 95
15716: PUSH
15717: LD_INT 8
15719: PUSH
15720: EMPTY
15721: LIST
15722: LIST
15723: PPUSH
15724: CALL_OW 72
15728: PUSH
15729: FOR_IN
15730: IFFALSE 15759
// begin usForces := usForces diff i ;
15732: LD_ADDR_EXP 44
15736: PUSH
15737: LD_EXP 44
15741: PUSH
15742: LD_VAR 0 1
15746: DIFF
15747: ST_TO_ADDR
// RemoveUnit ( i ) ;
15748: LD_VAR 0 1
15752: PPUSH
15753: CALL_OW 64
// end ;
15757: GO 15729
15759: POP
15760: POP
// if not americanHasEscaped and attackWave = 1 then
15761: LD_EXP 8
15765: NOT
15766: PUSH
15767: LD_EXP 19
15771: PUSH
15772: LD_INT 1
15774: EQUAL
15775: AND
15776: IFFALSE 15798
// begin americanHasEscaped := true ;
15778: LD_ADDR_EXP 8
15782: PUSH
15783: LD_INT 1
15785: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15786: LD_EXP 28
15790: PPUSH
15791: LD_STRING DH-2-assault-a
15793: PPUSH
15794: CALL_OW 88
// end ; end ;
15798: PPOPN 1
15800: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) and not retreatAllowed do
15801: LD_INT 4
15803: PPUSH
15804: LD_INT 22
15806: PUSH
15807: LD_INT 1
15809: PUSH
15810: EMPTY
15811: LIST
15812: LIST
15813: PPUSH
15814: CALL_OW 70
15818: PUSH
15819: LD_EXP 11
15823: NOT
15824: AND
15825: IFFALSE 15842
15827: GO 15829
15829: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15830: LD_EXP 36
15834: PPUSH
15835: LD_STRING DF-1-attack
15837: PPUSH
15838: CALL_OW 94
15842: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15843: LD_INT 5
15845: PPUSH
15846: CALL_OW 255
15850: PUSH
15851: LD_INT 2
15853: EQUAL
15854: IFFALSE 15866
15856: GO 15858
15858: DISABLE
// YouLost ( Attack ) ;
15859: LD_STRING Attack
15861: PPUSH
15862: CALL_OW 104
15866: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 90 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) do var randomMen , randomWomen , speaker , place , depot ;
15867: LD_INT 22
15869: PUSH
15870: LD_INT 1
15872: PUSH
15873: EMPTY
15874: LIST
15875: LIST
15876: PUSH
15877: LD_INT 21
15879: PUSH
15880: LD_INT 1
15882: PUSH
15883: EMPTY
15884: LIST
15885: LIST
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PPUSH
15891: CALL_OW 69
15895: NOT
15896: PUSH
15897: LD_INT 22
15899: PUSH
15900: LD_INT 4
15902: PUSH
15903: EMPTY
15904: LIST
15905: LIST
15906: PPUSH
15907: CALL_OW 69
15911: NOT
15912: AND
15913: PUSH
15914: LD_EXP 11
15918: NOT
15919: AND
15920: PUSH
15921: LD_EXP 15
15925: PUSH
15926: LD_INT 90
15928: GREATER
15929: AND
15930: PUSH
15931: LD_INT 7
15933: PPUSH
15934: LD_INT 22
15936: PUSH
15937: LD_INT 2
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: PUSH
15944: LD_INT 21
15946: PUSH
15947: LD_INT 1
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: PUSH
15954: EMPTY
15955: LIST
15956: LIST
15957: PPUSH
15958: CALL_OW 70
15962: AND
15963: PUSH
15964: LD_INT 22
15966: PUSH
15967: LD_INT 2
15969: PUSH
15970: EMPTY
15971: LIST
15972: LIST
15973: PUSH
15974: LD_INT 50
15976: PUSH
15977: EMPTY
15978: LIST
15979: PUSH
15980: LD_INT 30
15982: PUSH
15983: LD_INT 0
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: LIST
15994: PPUSH
15995: CALL_OW 69
15999: AND
16000: IFFALSE 16701
16002: GO 16004
16004: DISABLE
16005: LD_INT 0
16007: PPUSH
16008: PPUSH
16009: PPUSH
16010: PPUSH
16011: PPUSH
// begin depot := usDepot ;
16012: LD_ADDR_VAR 0 5
16016: PUSH
16017: LD_INT 11
16019: ST_TO_ADDR
// if not depot then
16020: LD_VAR 0 5
16024: NOT
16025: IFFALSE 16065
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
16027: LD_ADDR_VAR 0 5
16031: PUSH
16032: LD_INT 22
16034: PUSH
16035: LD_INT 2
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: PUSH
16042: LD_INT 30
16044: PUSH
16045: LD_INT 0
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: PUSH
16052: EMPTY
16053: LIST
16054: LIST
16055: PPUSH
16056: CALL_OW 69
16060: PUSH
16061: LD_INT 1
16063: ARRAY
16064: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
16065: LD_ADDR_VAR 0 1
16069: PUSH
16070: LD_EXP 42
16074: PPUSH
16075: LD_INT 26
16077: PUSH
16078: LD_INT 1
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: PPUSH
16085: CALL_OW 72
16089: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
16090: LD_ADDR_VAR 0 2
16094: PUSH
16095: LD_EXP 42
16099: PPUSH
16100: LD_INT 26
16102: PUSH
16103: LD_INT 2
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: PPUSH
16110: CALL_OW 72
16114: ST_TO_ADDR
// if IsOk ( Kaia ) then
16115: LD_EXP 33
16119: PPUSH
16120: CALL_OW 302
16124: IFFALSE 16145
// speaker := [ Kaia , DK ] else
16126: LD_ADDR_VAR 0 3
16130: PUSH
16131: LD_EXP 33
16135: PUSH
16136: LD_STRING DK
16138: PUSH
16139: EMPTY
16140: LIST
16141: LIST
16142: ST_TO_ADDR
16143: GO 16225
// if randomMen then
16145: LD_VAR 0 1
16149: IFFALSE 16184
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
16151: LD_ADDR_VAR 0 3
16155: PUSH
16156: LD_VAR 0 1
16160: PUSH
16161: LD_INT 1
16163: PPUSH
16164: LD_VAR 0 1
16168: PPUSH
16169: CALL_OW 12
16173: ARRAY
16174: PUSH
16175: LD_STRING DArm
16177: PUSH
16178: EMPTY
16179: LIST
16180: LIST
16181: ST_TO_ADDR
16182: GO 16225
// if randomWomen then
16184: LD_VAR 0 2
16188: IFFALSE 16223
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
16190: LD_ADDR_VAR 0 3
16194: PUSH
16195: LD_VAR 0 2
16199: PUSH
16200: LD_INT 1
16202: PPUSH
16203: LD_VAR 0 2
16207: PPUSH
16208: CALL_OW 12
16212: ARRAY
16213: PUSH
16214: LD_STRING DArf
16216: PUSH
16217: EMPTY
16218: LIST
16219: LIST
16220: ST_TO_ADDR
16221: GO 16225
// exit ;
16223: GO 16701
// if IsInUnit ( speaker [ 1 ] ) then
16225: LD_VAR 0 3
16229: PUSH
16230: LD_INT 1
16232: ARRAY
16233: PPUSH
16234: CALL_OW 310
16238: IFFALSE 16261
// place := IsInUnit ( speaker [ 1 ] ) else
16240: LD_ADDR_VAR 0 4
16244: PUSH
16245: LD_VAR 0 3
16249: PUSH
16250: LD_INT 1
16252: ARRAY
16253: PPUSH
16254: CALL_OW 310
16258: ST_TO_ADDR
16259: GO 16275
// place := speaker [ 1 ] ;
16261: LD_ADDR_VAR 0 4
16265: PUSH
16266: LD_VAR 0 3
16270: PUSH
16271: LD_INT 1
16273: ARRAY
16274: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
16275: LD_VAR 0 4
16279: PPUSH
16280: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
16284: LD_VAR 0 4
16288: PPUSH
16289: CALL_OW 250
16293: PPUSH
16294: LD_VAR 0 4
16298: PPUSH
16299: CALL_OW 251
16303: PPUSH
16304: CALL 3078 0 2
// wait ( 0 0$2 ) ;
16308: LD_INT 70
16310: PPUSH
16311: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
16315: LD_EXP 38
16319: PPUSH
16320: CALL_OW 305
16324: NOT
16325: IFFALSE 16329
// exit ;
16327: GO 16701
// allowConvoys := false ;
16329: LD_ADDR_EXP 12
16333: PUSH
16334: LD_INT 0
16336: ST_TO_ADDR
// InGameOn ;
16337: CALL_OW 8
// wait ( 0 0$1 ) ;
16341: LD_INT 35
16343: PPUSH
16344: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
16348: LD_EXP 38
16352: PPUSH
16353: LD_STRING DI-1-land
16355: PPUSH
16356: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
16360: LD_VAR 0 3
16364: PUSH
16365: LD_INT 1
16367: ARRAY
16368: PPUSH
16369: CALL_OW 310
16373: IFFALSE 16388
// ComExit ( speaker [ 1 ] ) ;
16375: LD_VAR 0 3
16379: PUSH
16380: LD_INT 1
16382: ARRAY
16383: PPUSH
16384: CALL 1140 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
16388: LD_VAR 0 3
16392: PUSH
16393: LD_INT 1
16395: ARRAY
16396: PPUSH
16397: LD_EXP 38
16401: PPUSH
16402: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
16406: LD_VAR 0 3
16410: PUSH
16411: LD_INT 1
16413: ARRAY
16414: PPUSH
16415: LD_EXP 38
16419: PPUSH
16420: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
16424: LD_EXP 38
16428: PPUSH
16429: LD_VAR 0 3
16433: PUSH
16434: LD_INT 1
16436: ARRAY
16437: PPUSH
16438: CALL_OW 119
// wait ( 0 0$1 ) ;
16442: LD_INT 35
16444: PPUSH
16445: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
16449: LD_VAR 0 3
16453: PUSH
16454: LD_INT 1
16456: ARRAY
16457: PPUSH
16458: LD_VAR 0 3
16462: PUSH
16463: LD_INT 2
16465: ARRAY
16466: PUSH
16467: LD_STRING -1-land
16469: STR
16470: PPUSH
16471: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
16475: LD_EXP 38
16479: PPUSH
16480: LD_STRING DI-2-land
16482: PPUSH
16483: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
16487: LD_VAR 0 3
16491: PUSH
16492: LD_INT 1
16494: ARRAY
16495: PPUSH
16496: LD_VAR 0 3
16500: PUSH
16501: LD_INT 2
16503: ARRAY
16504: PUSH
16505: LD_STRING -2-land
16507: STR
16508: PPUSH
16509: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
16513: LD_VAR 0 3
16517: PUSH
16518: LD_INT 1
16520: ARRAY
16521: PPUSH
16522: LD_VAR 0 3
16526: PUSH
16527: LD_INT 2
16529: ARRAY
16530: PUSH
16531: LD_STRING -3-land
16533: STR
16534: PPUSH
16535: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16539: LD_EXP 28
16543: PPUSH
16544: LD_STRING DH-1-land
16546: PPUSH
16547: CALL_OW 88
// if UnitsInside ( depot ) = 6 then
16551: LD_VAR 0 5
16555: PPUSH
16556: CALL_OW 313
16560: PUSH
16561: LD_INT 6
16563: EQUAL
16564: IFFALSE 16584
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
16566: LD_VAR 0 5
16570: PPUSH
16571: CALL_OW 313
16575: PUSH
16576: LD_INT 1
16578: ARRAY
16579: PPUSH
16580: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16584: LD_EXP 38
16588: PPUSH
16589: LD_INT 2
16591: PPUSH
16592: CALL_OW 235
// CenterOnUnits ( depot ) ;
16596: LD_VAR 0 5
16600: PPUSH
16601: CALL_OW 85
// ComEnterUnit ( Ibrahim , depot ) ;
16605: LD_EXP 38
16609: PPUSH
16610: LD_VAR 0 5
16614: PPUSH
16615: CALL_OW 120
// ComEnterUnit ( speaker [ 1 ] , depot ) ;
16619: LD_VAR 0 3
16623: PUSH
16624: LD_INT 1
16626: ARRAY
16627: PPUSH
16628: LD_VAR 0 5
16632: PPUSH
16633: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
16637: LD_INT 35
16639: PPUSH
16640: CALL_OW 67
// until IsInUnit ( Ibrahim ) or not IsOk ( Ibrahim ) ;
16644: LD_EXP 38
16648: PPUSH
16649: CALL_OW 310
16653: PUSH
16654: LD_EXP 38
16658: PPUSH
16659: CALL_OW 302
16663: NOT
16664: OR
16665: IFFALSE 16637
// InGameOff ;
16667: CALL_OW 9
// if not IsOk ( Ibrahim ) then
16671: LD_EXP 38
16675: PPUSH
16676: CALL_OW 302
16680: NOT
16681: IFFALSE 16685
// exit ;
16683: GO 16701
// ibrahimInDepot := true ;
16685: LD_ADDR_EXP 25
16689: PUSH
16690: LD_INT 1
16692: ST_TO_ADDR
// allowConvoys := true ;
16693: LD_ADDR_EXP 12
16697: PUSH
16698: LD_INT 1
16700: ST_TO_ADDR
// end ;
16701: PPOPN 5
16703: END
// export function IbrahimQuery ; begin
16704: LD_INT 0
16706: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16707: LD_STRING IbrahimQuery
16709: PPUSH
16710: CALL_OW 97
16714: PUSH
16715: LD_INT 1
16717: DOUBLE
16718: EQUAL
16719: IFTRUE 16723
16721: GO 17005
16723: POP
// begin allowConvoys := false ;
16724: LD_ADDR_EXP 12
16728: PUSH
16729: LD_INT 0
16731: ST_TO_ADDR
// ibrahimInDepot := false ;
16732: LD_ADDR_EXP 25
16736: PUSH
16737: LD_INT 0
16739: ST_TO_ADDR
// InGameOn ;
16740: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16744: LD_EXP 28
16748: PPUSH
16749: CALL_OW 87
// wait ( 0 0$1 ) ;
16753: LD_INT 35
16755: PPUSH
16756: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16760: LD_EXP 28
16764: PPUSH
16765: LD_STRING DH-1-interrogation
16767: PPUSH
16768: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16772: LD_EXP 38
16776: PPUSH
16777: LD_STRING DI-1-interrogation
16779: PPUSH
16780: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16784: LD_EXP 28
16788: PPUSH
16789: LD_STRING DH-2-interrogation
16791: PPUSH
16792: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16796: LD_EXP 38
16800: PPUSH
16801: LD_STRING DI-2-interrogation
16803: PPUSH
16804: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16808: LD_EXP 28
16812: PPUSH
16813: LD_STRING DH-3-interrogation
16815: PPUSH
16816: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16820: LD_EXP 38
16824: PPUSH
16825: LD_STRING DI-3-interrogation
16827: PPUSH
16828: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16832: LD_EXP 28
16836: PPUSH
16837: LD_STRING DH-4-interrogation
16839: PPUSH
16840: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16844: LD_EXP 38
16848: PPUSH
16849: LD_STRING DI-4-interrogation
16851: PPUSH
16852: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16856: LD_EXP 28
16860: PPUSH
16861: LD_STRING DH-5-interrogation
16863: PPUSH
16864: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16868: LD_EXP 38
16872: PPUSH
16873: LD_STRING DI-5-interrogation
16875: PPUSH
16876: CALL_OW 88
// wait ( 0 0$1 ) ;
16880: LD_INT 35
16882: PPUSH
16883: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16887: LD_STRING IbrahimDecisionQuery
16889: PPUSH
16890: CALL_OW 97
16894: PUSH
16895: LD_INT 1
16897: DOUBLE
16898: EQUAL
16899: IFTRUE 16903
16901: GO 16927
16903: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16904: LD_EXP 38
16908: PPUSH
16909: LD_STRING DI-1-kill
16911: PPUSH
16912: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16916: LD_EXP 38
16920: PPUSH
16921: CALL_OW 66
// end ; 2 :
16925: GO 16999
16927: LD_INT 2
16929: DOUBLE
16930: EQUAL
16931: IFTRUE 16935
16933: GO 16998
16935: POP
// begin SetSide ( Ibrahim , 6 ) ;
16936: LD_EXP 38
16940: PPUSH
16941: LD_INT 6
16943: PPUSH
16944: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16948: LD_EXP 38
16952: PPUSH
16953: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16957: LD_EXP 38
16961: PPUSH
16962: LD_INT 32
16964: PPUSH
16965: LD_INT 5
16967: PPUSH
16968: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16972: LD_EXP 28
16976: PPUSH
16977: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16981: LD_EXP 28
16985: PPUSH
16986: LD_INT 36
16988: PPUSH
16989: LD_INT 21
16991: PPUSH
16992: CALL_OW 171
// end ; end ;
16996: GO 16999
16998: POP
// InGameOff ;
16999: CALL_OW 9
// end ; 2 :
17003: GO 17019
17005: LD_INT 2
17007: DOUBLE
17008: EQUAL
17009: IFTRUE 17013
17011: GO 17018
17013: POP
// exit ; end ;
17014: GO 17057
17016: GO 17019
17018: POP
// allowConvoys := true ;
17019: LD_ADDR_EXP 12
17023: PUSH
17024: LD_INT 1
17026: ST_TO_ADDR
// wait ( 2 2$40 ) ;
17027: LD_INT 5600
17029: PPUSH
17030: CALL_OW 67
// ComMoveXY ( Ibrahim , 38 , 28 ) ;
17034: LD_EXP 38
17038: PPUSH
17039: LD_INT 38
17041: PPUSH
17042: LD_INT 28
17044: PPUSH
17045: CALL_OW 111
// ibrahimIsFree := true ;
17049: LD_ADDR_EXP 26
17053: PUSH
17054: LD_INT 1
17056: ST_TO_ADDR
// end ;
17057: LD_VAR 0 1
17061: RET
// every 0 0$1 trigger ibrahimIsFree and IsOk ( Ibrahim ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b , p , depot ;
17062: LD_EXP 26
17066: PUSH
17067: LD_EXP 38
17071: PPUSH
17072: CALL_OW 302
17076: AND
17077: PUSH
17078: LD_INT 22
17080: PUSH
17081: LD_INT 2
17083: PUSH
17084: EMPTY
17085: LIST
17086: LIST
17087: PUSH
17088: LD_INT 50
17090: PUSH
17091: EMPTY
17092: LIST
17093: PUSH
17094: LD_INT 30
17096: PUSH
17097: LD_INT 0
17099: PUSH
17100: EMPTY
17101: LIST
17102: LIST
17103: PUSH
17104: EMPTY
17105: LIST
17106: LIST
17107: LIST
17108: PPUSH
17109: CALL_OW 69
17113: AND
17114: PUSH
17115: LD_EXP 38
17119: PPUSH
17120: LD_INT 7
17122: PPUSH
17123: CALL_OW 308
17127: AND
17128: PUSH
17129: LD_INT 6
17131: PPUSH
17132: LD_EXP 28
17136: PPUSH
17137: CALL_OW 292
17141: AND
17142: PUSH
17143: LD_INT 22
17145: PUSH
17146: LD_INT 4
17148: PUSH
17149: EMPTY
17150: LIST
17151: LIST
17152: PPUSH
17153: CALL_OW 69
17157: NOT
17158: AND
17159: PUSH
17160: LD_INT 22
17162: PUSH
17163: LD_INT 1
17165: PUSH
17166: EMPTY
17167: LIST
17168: LIST
17169: PUSH
17170: LD_INT 21
17172: PUSH
17173: LD_INT 1
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PPUSH
17184: CALL_OW 69
17188: NOT
17189: AND
17190: IFFALSE 17845
17192: GO 17194
17194: DISABLE
17195: LD_INT 0
17197: PPUSH
17198: PPUSH
17199: PPUSH
17200: PPUSH
// begin allowConvoys := false ;
17201: LD_ADDR_EXP 12
17205: PUSH
17206: LD_INT 0
17208: ST_TO_ADDR
// depot := usDepot ;
17209: LD_ADDR_VAR 0 4
17213: PUSH
17214: LD_INT 11
17216: ST_TO_ADDR
// if not usDepot then
17217: LD_INT 11
17219: NOT
17220: IFFALSE 17267
// depot := FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
17222: LD_ADDR_VAR 0 4
17226: PUSH
17227: LD_INT 22
17229: PUSH
17230: LD_INT 2
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: PUSH
17237: LD_INT 50
17239: PUSH
17240: EMPTY
17241: LIST
17242: PUSH
17243: LD_INT 30
17245: PUSH
17246: LD_INT 0
17248: PUSH
17249: EMPTY
17250: LIST
17251: LIST
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: PPUSH
17258: CALL_OW 69
17262: PUSH
17263: LD_INT 1
17265: ARRAY
17266: ST_TO_ADDR
// InGameOn ;
17267: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
17271: LD_EXP 38
17275: PPUSH
17276: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
17280: LD_EXP 28
17284: PPUSH
17285: LD_EXP 38
17289: PPUSH
17290: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
17294: LD_EXP 38
17298: PPUSH
17299: LD_EXP 28
17303: PPUSH
17304: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
17308: LD_EXP 38
17312: PPUSH
17313: LD_STRING DI-1-free
17315: PPUSH
17316: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
17320: LD_EXP 28
17324: PPUSH
17325: LD_STRING DH-1-free
17327: PPUSH
17328: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
17332: LD_EXP 38
17336: PPUSH
17337: LD_STRING DI-2-free
17339: PPUSH
17340: CALL_OW 88
// changeClass := 0 ;
17344: LD_ADDR_VAR 0 1
17348: PUSH
17349: LD_INT 0
17351: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
17352: LD_STRING IbrahimJoinQuery
17354: PPUSH
17355: CALL_OW 97
17359: PUSH
17360: LD_INT 1
17362: DOUBLE
17363: EQUAL
17364: IFTRUE 17368
17366: GO 17379
17368: POP
// begin changeClass := 1 ;
17369: LD_ADDR_VAR 0 1
17373: PUSH
17374: LD_INT 1
17376: ST_TO_ADDR
// end ; 2 :
17377: GO 17619
17379: LD_INT 2
17381: DOUBLE
17382: EQUAL
17383: IFTRUE 17387
17385: GO 17539
17387: POP
// begin Say ( Heike , DH-1-decline ) ;
17388: LD_EXP 28
17392: PPUSH
17393: LD_STRING DH-1-decline
17395: PPUSH
17396: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
17400: LD_EXP 38
17404: PPUSH
17405: LD_STRING DI-1-decline
17407: PPUSH
17408: CALL_OW 88
// InGameOff ;
17412: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
17416: LD_EXP 38
17420: PPUSH
17421: LD_INT 30
17423: PPUSH
17424: LD_INT 1
17426: PPUSH
17427: CALL_OW 111
// p := 0 ;
17431: LD_ADDR_VAR 0 3
17435: PUSH
17436: LD_INT 0
17438: ST_TO_ADDR
// repeat p := p + 1 ;
17439: LD_ADDR_VAR 0 3
17443: PUSH
17444: LD_VAR 0 3
17448: PUSH
17449: LD_INT 1
17451: PLUS
17452: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17453: LD_INT 35
17455: PPUSH
17456: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) or p > 10 ;
17460: LD_EXP 38
17464: PPUSH
17465: LD_INT 30
17467: PPUSH
17468: LD_INT 1
17470: PPUSH
17471: CALL_OW 307
17475: PUSH
17476: LD_INT 22
17478: PUSH
17479: LD_INT 2
17481: PUSH
17482: EMPTY
17483: LIST
17484: LIST
17485: PUSH
17486: LD_INT 101
17488: PUSH
17489: LD_INT 6
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: PPUSH
17500: CALL_OW 69
17504: NOT
17505: OR
17506: PUSH
17507: LD_VAR 0 3
17511: PUSH
17512: LD_INT 10
17514: GREATER
17515: OR
17516: IFFALSE 17439
// RemoveUnit ( Ibrahim ) ;
17518: LD_EXP 38
17522: PPUSH
17523: CALL_OW 64
// SaveVariable ( 1 , 03_IbrahimHasEscaped ) ;
17527: LD_INT 1
17529: PPUSH
17530: LD_STRING 03_IbrahimHasEscaped
17532: PPUSH
17533: CALL_OW 39
// end ; 3 :
17537: GO 17619
17539: LD_INT 3
17541: DOUBLE
17542: EQUAL
17543: IFTRUE 17547
17545: GO 17618
17547: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
17548: LD_EXP 28
17552: PPUSH
17553: LD_STRING DH-1-radio-hq
17555: PPUSH
17556: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
17560: LD_EXP 37
17564: PPUSH
17565: LD_STRING DO-1-radio-hq
17567: PPUSH
17568: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
17572: LD_EXP 28
17576: PPUSH
17577: LD_STRING DH-2-radio-hq
17579: PPUSH
17580: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
17584: LD_EXP 37
17588: PPUSH
17589: LD_STRING DO-2-radio-hq
17591: PPUSH
17592: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
17596: LD_EXP 28
17600: PPUSH
17601: LD_STRING DH-3-radio-hq
17603: PPUSH
17604: CALL_OW 88
// changeClass := 1 ;
17608: LD_ADDR_VAR 0 1
17612: PUSH
17613: LD_INT 1
17615: ST_TO_ADDR
// end ; end ;
17616: GO 17619
17618: POP
// if changeClass then
17619: LD_VAR 0 1
17623: IFFALSE 17845
// begin Say ( Heike , DH-1-agree ) ;
17625: LD_EXP 28
17629: PPUSH
17630: LD_STRING DH-1-agree
17632: PPUSH
17633: CALL_OW 88
// if IsOk ( Givi ) then
17637: LD_EXP 29
17641: PPUSH
17642: CALL_OW 302
17646: IFFALSE 17684
// begin Say ( Givi , DG-1-agree ) ;
17648: LD_EXP 29
17652: PPUSH
17653: LD_STRING DG-1-agree
17655: PPUSH
17656: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
17660: LD_EXP 28
17664: PPUSH
17665: LD_STRING DH-2-agree
17667: PPUSH
17668: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
17672: LD_EXP 29
17676: PPUSH
17677: LD_STRING DG-2-agree
17679: PPUSH
17680: CALL_OW 88
// end ; if UnitsInside ( depot ) = 6 then
17684: LD_VAR 0 4
17688: PPUSH
17689: CALL_OW 313
17693: PUSH
17694: LD_INT 6
17696: EQUAL
17697: IFFALSE 17717
// ComExitBuilding ( UnitsInside ( depot ) [ 1 ] ) ;
17699: LD_VAR 0 4
17703: PPUSH
17704: CALL_OW 313
17708: PUSH
17709: LD_INT 1
17711: ARRAY
17712: PPUSH
17713: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
17717: LD_EXP 38
17721: PPUSH
17722: LD_INT 2
17724: PPUSH
17725: CALL_OW 235
// ComEnterUnit ( Ibrahim , depot ) ;
17729: LD_EXP 38
17733: PPUSH
17734: LD_VAR 0 4
17738: PPUSH
17739: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
17743: LD_INT 35
17745: PPUSH
17746: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
17750: LD_EXP 38
17754: PPUSH
17755: CALL_OW 310
17759: IFFALSE 17743
// b := IsInUnit ( Ibrahim ) ;
17761: LD_ADDR_VAR 0 2
17765: PUSH
17766: LD_EXP 38
17770: PPUSH
17771: CALL_OW 310
17775: ST_TO_ADDR
// RemoveUnit ( Ibrahim ) ;
17776: LD_EXP 38
17780: PPUSH
17781: CALL_OW 64
// uc_side := 2 ;
17785: LD_ADDR_OWVAR 20
17789: PUSH
17790: LD_INT 2
17792: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17793: LD_ADDR_EXP 38
17797: PUSH
17798: LD_STRING Ibrahim
17800: PPUSH
17801: LD_INT 0
17803: PPUSH
17804: LD_STRING 
17806: PPUSH
17807: CALL 313 0 3
17811: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , b ) ;
17812: LD_EXP 38
17816: PPUSH
17817: LD_VAR 0 2
17821: PPUSH
17822: CALL_OW 52
// InGameOff ;
17826: CALL_OW 9
// allowConvoys := true ;
17830: LD_ADDR_EXP 12
17834: PUSH
17835: LD_INT 1
17837: ST_TO_ADDR
// SetAchievement ( ACH_IBRAHIM ) ;
17838: LD_STRING ACH_IBRAHIM
17840: PPUSH
17841: CALL_OW 543
// end ; end ;
17845: PPOPN 4
17847: END
// every 0 0$1 trigger GetLives ( Kaia ) < 3 do
17848: LD_EXP 33
17852: PPUSH
17853: CALL_OW 256
17857: PUSH
17858: LD_INT 3
17860: LESS
17861: IFFALSE 17928
17863: GO 17865
17865: DISABLE
// begin DialogueOn ;
17866: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
17870: LD_EXP 33
17874: PPUSH
17875: CALL_OW 87
// ForceSay ( Kaia , DK-keydeath-1 ) ;
17879: LD_EXP 33
17883: PPUSH
17884: LD_STRING DK-keydeath-1
17886: PPUSH
17887: CALL_OW 91
// Say ( Heike , DH-keydeath-2 ) ;
17891: LD_EXP 28
17895: PPUSH
17896: LD_STRING DH-keydeath-2
17898: PPUSH
17899: CALL_OW 88
// Say ( Heike , DH-keydeath-3 ) ;
17903: LD_EXP 28
17907: PPUSH
17908: LD_STRING DH-keydeath-3
17910: PPUSH
17911: CALL_OW 88
// DialogueOff ;
17915: CALL_OW 7
// KillUnit ( Kaia ) ;
17919: LD_EXP 33
17923: PPUSH
17924: CALL_OW 66
// end ;
17928: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) = 0 do
17929: LD_EXP 11
17933: PUSH
17934: LD_EXP 21
17938: PUSH
17939: LD_INT 1
17941: LESS
17942: AND
17943: PUSH
17944: LD_INT 22
17946: PUSH
17947: LD_INT 1
17949: PUSH
17950: EMPTY
17951: LIST
17952: LIST
17953: PUSH
17954: LD_INT 25
17956: PUSH
17957: LD_INT 1
17959: PUSH
17960: EMPTY
17961: LIST
17962: LIST
17963: PUSH
17964: EMPTY
17965: LIST
17966: LIST
17967: PPUSH
17968: CALL_OW 69
17972: PUSH
17973: LD_INT 0
17975: EQUAL
17976: AND
17977: IFFALSE 18368
17979: GO 17981
17981: DISABLE
// begin DialogueOn ;
17982: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
17986: LD_EXP 28
17990: PPUSH
17991: LD_STRING DH-1-final
17993: PPUSH
17994: CALL_OW 88
// if tick <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
17998: LD_OWVAR 1
18002: PUSH
18003: LD_INT 126000
18005: PUSH
18006: LD_INT 115500
18008: PUSH
18009: LD_INT 105000
18011: PUSH
18012: EMPTY
18013: LIST
18014: LIST
18015: LIST
18016: PUSH
18017: LD_OWVAR 67
18021: ARRAY
18022: LESSEQUAL
18023: IFFALSE 18037
// AddMedal ( med1 , 1 ) else
18025: LD_STRING med1
18027: PPUSH
18028: LD_INT 1
18030: PPUSH
18031: CALL_OW 101
18035: GO 18048
// AddMedal ( med1 , - 1 ) ;
18037: LD_STRING med1
18039: PPUSH
18040: LD_INT 1
18042: NEG
18043: PPUSH
18044: CALL_OW 101
// if vehCounter >= 2 then
18048: LD_EXP 22
18052: PUSH
18053: LD_INT 2
18055: GREATEREQUAL
18056: IFFALSE 18070
// AddMedal ( med2 , 1 ) else
18058: LD_STRING med2
18060: PPUSH
18061: LD_INT 1
18063: PPUSH
18064: CALL_OW 101
18068: GO 18081
// AddMedal ( med2 , - 1 ) ;
18070: LD_STRING med2
18072: PPUSH
18073: LD_INT 1
18075: NEG
18076: PPUSH
18077: CALL_OW 101
// if deadCounter = 0 then
18081: LD_EXP 9
18085: PUSH
18086: LD_INT 0
18088: EQUAL
18089: IFFALSE 18103
// AddMedal ( med3 , 1 ) else
18091: LD_STRING med3
18093: PPUSH
18094: LD_INT 1
18096: PPUSH
18097: CALL_OW 101
18101: GO 18114
// AddMedal ( med3 , - 1 ) ;
18103: LD_STRING med3
18105: PPUSH
18106: LD_INT 1
18108: NEG
18109: PPUSH
18110: CALL_OW 101
// GiveMedals ( MAIN ) ;
18114: LD_STRING MAIN
18116: PPUSH
18117: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
18121: LD_INT 22
18123: PUSH
18124: LD_INT 2
18126: PUSH
18127: EMPTY
18128: LIST
18129: LIST
18130: PUSH
18131: LD_INT 23
18133: PUSH
18134: LD_INT 2
18136: PUSH
18137: EMPTY
18138: LIST
18139: LIST
18140: PUSH
18141: LD_INT 21
18143: PUSH
18144: LD_INT 1
18146: PUSH
18147: EMPTY
18148: LIST
18149: LIST
18150: PUSH
18151: EMPTY
18152: LIST
18153: LIST
18154: LIST
18155: PPUSH
18156: CALL_OW 69
18160: PPUSH
18161: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
18165: LD_EXP 28
18169: PPUSH
18170: LD_STRING 03_Heike
18172: PPUSH
18173: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
18177: LD_EXP 32
18181: PPUSH
18182: LD_STRING 03_Aviradze
18184: PPUSH
18185: CALL_OW 38
// if Givi then
18189: LD_EXP 29
18193: IFFALSE 18207
// SaveCharacters ( Givi , 03_Givi ) ;
18195: LD_EXP 29
18199: PPUSH
18200: LD_STRING 03_Givi
18202: PPUSH
18203: CALL_OW 38
// if Mike then
18207: LD_EXP 30
18211: IFFALSE 18225
// SaveCharacters ( Mike , 03_Mike ) ;
18213: LD_EXP 30
18217: PPUSH
18218: LD_STRING 03_Mike
18220: PPUSH
18221: CALL_OW 38
// if Kamil then
18225: LD_EXP 31
18229: IFFALSE 18243
// SaveCharacters ( Kamil , 03_Kamil ) ;
18231: LD_EXP 31
18235: PPUSH
18236: LD_STRING 03_Kamil
18238: PPUSH
18239: CALL_OW 38
// if Kaia then
18243: LD_EXP 33
18247: IFFALSE 18261
// SaveCharacters ( Kaia , 03_Kaia ) ;
18249: LD_EXP 33
18253: PPUSH
18254: LD_STRING 03_Kaia
18256: PPUSH
18257: CALL_OW 38
// if Sophia then
18261: LD_EXP 34
18265: IFFALSE 18279
// SaveCharacters ( Sophia , 03_Sophia ) ;
18267: LD_EXP 34
18271: PPUSH
18272: LD_STRING 03_Sophia
18274: PPUSH
18275: CALL_OW 38
// if Markov then
18279: LD_EXP 35
18283: IFFALSE 18297
// SaveCharacters ( Markov , 03_Markov ) ;
18285: LD_EXP 35
18289: PPUSH
18290: LD_STRING 03_Markov
18292: PPUSH
18293: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
18297: LD_EXP 38
18301: PUSH
18302: LD_EXP 38
18306: PPUSH
18307: CALL_OW 255
18311: PUSH
18312: LD_INT 2
18314: EQUAL
18315: AND
18316: IFFALSE 18330
// SaveCharacters ( Ibrahim , 03_Ibrahim ) ;
18318: LD_EXP 38
18322: PPUSH
18323: LD_STRING 03_Ibrahim
18325: PPUSH
18326: CALL_OW 38
// if heikeSecondSquad then
18330: LD_EXP 42
18334: IFFALSE 18348
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
18336: LD_EXP 42
18340: PPUSH
18341: LD_STRING 03_others
18343: PPUSH
18344: CALL_OW 38
// SaveVariable ( deadCounter , 03_DeadCounter ) ;
18348: LD_EXP 9
18352: PPUSH
18353: LD_STRING 03_DeadCounter
18355: PPUSH
18356: CALL_OW 39
// YouWin ;
18360: CALL_OW 103
// DialogueOff ;
18364: CALL_OW 7
// end ; end_of_file
18368: END
// on UnitDestroyed ( un ) do begin if un = Heike then
18369: LD_VAR 0 1
18373: PUSH
18374: LD_EXP 28
18378: EQUAL
18379: IFFALSE 18388
// YouLost ( Heike ) ;
18381: LD_STRING Heike
18383: PPUSH
18384: CALL_OW 104
// if un = Aviradze then
18388: LD_VAR 0 1
18392: PUSH
18393: LD_EXP 32
18397: EQUAL
18398: IFFALSE 18407
// YouLost ( Aviradze ) ;
18400: LD_STRING Aviradze
18402: PPUSH
18403: CALL_OW 104
// if un = usDepot and not retreatAllowed then
18407: LD_VAR 0 1
18411: PUSH
18412: LD_INT 11
18414: EQUAL
18415: PUSH
18416: LD_EXP 11
18420: NOT
18421: AND
18422: IFFALSE 18431
// YouLost ( Depot ) ;
18424: LD_STRING Depot
18426: PPUSH
18427: CALL_OW 104
// if un = arDepot then
18431: LD_VAR 0 1
18435: PUSH
18436: LD_INT 5
18438: EQUAL
18439: IFFALSE 18448
// YouLost ( FarmerDepot ) ;
18441: LD_STRING FarmerDepot
18443: PPUSH
18444: CALL_OW 104
// if un = Farmer then
18448: LD_VAR 0 1
18452: PUSH
18453: LD_EXP 36
18457: EQUAL
18458: IFFALSE 18467
// YouLost ( Farmer ) ;
18460: LD_STRING Farmer
18462: PPUSH
18463: CALL_OW 104
// if un in usForces then
18467: LD_VAR 0 1
18471: PUSH
18472: LD_EXP 44
18476: IN
18477: IFFALSE 18495
// usForces := usForces diff un ;
18479: LD_ADDR_EXP 44
18483: PUSH
18484: LD_EXP 44
18488: PUSH
18489: LD_VAR 0 1
18493: DIFF
18494: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
18495: LD_VAR 0 1
18499: PUSH
18500: LD_INT 22
18502: PUSH
18503: LD_INT 2
18505: PUSH
18506: EMPTY
18507: LIST
18508: LIST
18509: PUSH
18510: LD_INT 23
18512: PUSH
18513: LD_INT 2
18515: PUSH
18516: EMPTY
18517: LIST
18518: LIST
18519: PUSH
18520: LD_INT 21
18522: PUSH
18523: LD_INT 1
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: LIST
18534: PPUSH
18535: CALL_OW 69
18539: IN
18540: IFFALSE 18556
// deadCounter := deadCounter + 1 ;
18542: LD_ADDR_EXP 9
18546: PUSH
18547: LD_EXP 9
18551: PUSH
18552: LD_INT 1
18554: PLUS
18555: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
18556: LD_VAR 0 1
18560: PUSH
18561: LD_INT 22
18563: PUSH
18564: LD_INT 4
18566: PUSH
18567: EMPTY
18568: LIST
18569: LIST
18570: PUSH
18571: LD_INT 34
18573: PUSH
18574: LD_INT 12
18576: PUSH
18577: EMPTY
18578: LIST
18579: LIST
18580: PUSH
18581: EMPTY
18582: LIST
18583: LIST
18584: PPUSH
18585: CALL_OW 69
18589: IN
18590: PUSH
18591: LD_EXP 18
18595: NOT
18596: AND
18597: IFFALSE 18607
// firstConvoyDestroyed := true ;
18599: LD_ADDR_EXP 18
18603: PUSH
18604: LD_INT 1
18606: ST_TO_ADDR
// if un in usAttackers then
18607: LD_VAR 0 1
18611: PUSH
18612: LD_EXP 47
18616: IN
18617: IFFALSE 18635
// usAttackers := usAttackers diff un ;
18619: LD_ADDR_EXP 47
18623: PUSH
18624: LD_EXP 47
18628: PUSH
18629: LD_VAR 0 1
18633: DIFF
18634: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_human ] ] ) then
18635: LD_VAR 0 1
18639: PUSH
18640: LD_INT 22
18642: PUSH
18643: LD_INT 5
18645: PUSH
18646: EMPTY
18647: LIST
18648: LIST
18649: PUSH
18650: LD_INT 21
18652: PUSH
18653: LD_INT 1
18655: PUSH
18656: EMPTY
18657: LIST
18658: LIST
18659: PUSH
18660: EMPTY
18661: LIST
18662: LIST
18663: PPUSH
18664: CALL_OW 69
18668: IN
18669: IFFALSE 18685
// farmerHumanLoseCounter := farmerHumanLoseCounter + 1 ;
18671: LD_ADDR_EXP 20
18675: PUSH
18676: LD_EXP 20
18680: PUSH
18681: LD_INT 1
18683: PLUS
18684: ST_TO_ADDR
// end ;
18685: PPOPN 1
18687: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
18688: LD_VAR 0 2
18692: PUSH
18693: LD_EXP 38
18697: EQUAL
18698: PUSH
18699: LD_EXP 25
18703: AND
18704: IFFALSE 18750
// begin Video ( true ) ;
18706: LD_INT 1
18708: PPUSH
18709: CALL 1036 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
18713: LD_EXP 38
18717: PPUSH
18718: LD_INT 11
18720: PPUSH
18721: CALL_OW 120
// repeat wait ( 3 ) ;
18725: LD_INT 3
18727: PPUSH
18728: CALL_OW 67
// until IsInUnit ( Ibrahim ) ;
18732: LD_EXP 38
18736: PPUSH
18737: CALL_OW 310
18741: IFFALSE 18725
// Video ( false ) ;
18743: LD_INT 0
18745: PPUSH
18746: CALL 1036 0 1
// end ; end ;
18750: PPOPN 2
18752: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
18753: LD_VAR 0 2
18757: PUSH
18758: LD_EXP 28
18762: EQUAL
18763: PUSH
18764: LD_VAR 0 1
18768: PUSH
18769: LD_INT 11
18771: EQUAL
18772: AND
18773: PUSH
18774: LD_EXP 25
18778: AND
18779: IFFALSE 18785
// IbrahimQuery ;
18781: CALL 16704 0 0
// end ;
18785: PPOPN 2
18787: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin ComStop ( newId ) ;
18788: LD_VAR 0 1
18792: PPUSH
18793: CALL_OW 141
// if oldId in usAttackers then
18797: LD_VAR 0 2
18801: PUSH
18802: LD_EXP 47
18806: IN
18807: IFFALSE 18825
// usAttackers := usAttackers diff oldId ;
18809: LD_ADDR_EXP 47
18813: PUSH
18814: LD_EXP 47
18818: PUSH
18819: LD_VAR 0 2
18823: DIFF
18824: ST_TO_ADDR
// if newId in usAttackers then
18825: LD_VAR 0 1
18829: PUSH
18830: LD_EXP 47
18834: IN
18835: IFFALSE 18853
// usAttackers := usAttackers diff newId ;
18837: LD_ADDR_EXP 47
18841: PUSH
18842: LD_EXP 47
18846: PUSH
18847: LD_VAR 0 1
18851: DIFF
18852: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
18853: LD_VAR 0 3
18857: PUSH
18858: LD_INT 4
18860: EQUAL
18861: PUSH
18862: LD_EXP 18
18866: NOT
18867: AND
18868: IFFALSE 18878
// firstConvoyDestroyed := true ;
18870: LD_ADDR_EXP 18
18874: PUSH
18875: LD_INT 1
18877: ST_TO_ADDR
// if GetWeapon ( newId ) = us_cargo_bay then
18878: LD_VAR 0 1
18882: PPUSH
18883: CALL_OW 264
18887: PUSH
18888: LD_INT 12
18890: EQUAL
18891: IFFALSE 18929
// begin capturedCargoCounter := capturedCargoCounter + 1 ;
18893: LD_ADDR_EXP 13
18897: PUSH
18898: LD_EXP 13
18902: PUSH
18903: LD_INT 1
18905: PLUS
18906: ST_TO_ADDR
// if GetCargo ( newId , mat_cans ) = 0 then
18907: LD_VAR 0 1
18911: PPUSH
18912: LD_INT 1
18914: PPUSH
18915: CALL_OW 289
18919: PUSH
18920: LD_INT 0
18922: EQUAL
18923: IFFALSE 18929
// EmptyCargoDialog ;
18925: CALL 15434 0 0
// end ; end ;
18929: PPOPN 4
18931: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
18932: LD_VAR 0 1
18936: PUSH
18937: LD_INT 2
18939: EQUAL
18940: PUSH
18941: LD_VAR 0 2
18945: PUSH
18946: LD_INT 5
18948: EQUAL
18949: AND
18950: IFFALSE 18959
// YouLost ( Attack ) ;
18952: LD_STRING Attack
18954: PPUSH
18955: CALL_OW 104
// end ;
18959: PPOPN 2
18961: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 and not americanBaseCaptured then
18962: LD_VAR 0 1
18966: PPUSH
18967: CALL_OW 255
18971: PUSH
18972: LD_INT 1
18974: EQUAL
18975: PUSH
18976: LD_EXP 6
18980: NOT
18981: AND
18982: IFFALSE 19116
// begin if GetBType ( b ) = b_lab then
18984: LD_VAR 0 1
18988: PPUSH
18989: CALL_OW 266
18993: PUSH
18994: LD_INT 6
18996: EQUAL
18997: IFFALSE 19037
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
18999: LD_EXP 44
19003: PPUSH
19004: LD_INT 25
19006: PUSH
19007: LD_INT 4
19009: PUSH
19010: EMPTY
19011: LIST
19012: LIST
19013: PPUSH
19014: CALL_OW 72
19018: PPUSH
19019: LD_VAR 0 1
19023: PPUSH
19024: CALL_OW 120
// AmLabResearch ( b ) ;
19028: LD_VAR 0 1
19032: PPUSH
19033: CALL 6086 0 1
// end ; if GetBType ( b ) = b_armoury then
19037: LD_VAR 0 1
19041: PPUSH
19042: CALL_OW 266
19046: PUSH
19047: LD_INT 4
19049: EQUAL
19050: IFFALSE 19098
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
19052: LD_EXP 44
19056: PPUSH
19057: LD_INT 25
19059: PUSH
19060: LD_INT 1
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: PUSH
19067: LD_INT 3
19069: PUSH
19070: LD_INT 54
19072: PUSH
19073: EMPTY
19074: LIST
19075: PUSH
19076: EMPTY
19077: LIST
19078: LIST
19079: PUSH
19080: EMPTY
19081: LIST
19082: LIST
19083: PPUSH
19084: CALL_OW 72
19088: PPUSH
19089: LD_VAR 0 1
19093: PPUSH
19094: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
19098: LD_ADDR_EXP 46
19102: PUSH
19103: LD_EXP 46
19107: PPUSH
19108: LD_INT 1
19110: PPUSH
19111: CALL_OW 3
19115: ST_TO_ADDR
// end ; if GetSide ( b ) = 5 then
19116: LD_VAR 0 1
19120: PPUSH
19121: CALL_OW 255
19125: PUSH
19126: LD_INT 5
19128: EQUAL
19129: IFFALSE 19143
// SetBLevel ( b , 5 ) ;
19131: LD_VAR 0 1
19135: PPUSH
19136: LD_INT 5
19138: PPUSH
19139: CALL_OW 241
// end ;
19143: PPOPN 1
19145: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
19146: LD_VAR 0 1
19150: PPUSH
19151: CALL_OW 255
19155: PUSH
19156: LD_INT 2
19158: EQUAL
19159: IFFALSE 19175
// vehCounter := vehCounter + 1 ;
19161: LD_ADDR_EXP 22
19165: PUSH
19166: LD_EXP 22
19170: PUSH
19171: LD_INT 1
19173: PLUS
19174: ST_TO_ADDR
// end ;
19175: PPOPN 2
19177: END
// on SailEvent ( event ) do begin if event = eventAttack then
19178: LD_VAR 0 1
19182: PUSH
19183: LD_EXP 24
19187: EQUAL
19188: IFFALSE 19194
// AmericanAttack ;
19190: CALL 7534 0 0
// end ; end_of_file
19194: PPOPN 1
19196: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 5 5$00 , 4 4$40 , 4 4$30 ] [ Difficulty ] do
19197: LD_OWVAR 1
19201: PUSH
19202: LD_INT 10500
19204: PUSH
19205: LD_INT 9800
19207: PUSH
19208: LD_INT 9450
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: LIST
19215: PUSH
19216: LD_OWVAR 67
19220: ARRAY
19221: LESSEQUAL
19222: IFFALSE 19249
19224: GO 19226
19226: DISABLE
// begin enable ;
19227: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
19228: LD_INT 1
19230: PPUSH
19231: LD_INT 5
19233: PPUSH
19234: CALL_OW 12
19238: PPUSH
19239: LD_INT 9
19241: PPUSH
19242: LD_INT 1
19244: PPUSH
19245: CALL_OW 55
// end ;
19249: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 27 27$00 , 26 26$30 , 26 26$00 ] [ Difficulty ] do
19250: LD_EXP 6
19254: PUSH
19255: LD_OWVAR 1
19259: PUSH
19260: LD_INT 56700
19262: PUSH
19263: LD_INT 55650
19265: PUSH
19266: LD_INT 54600
19268: PUSH
19269: EMPTY
19270: LIST
19271: LIST
19272: LIST
19273: PUSH
19274: LD_OWVAR 67
19278: ARRAY
19279: LESSEQUAL
19280: AND
19281: IFFALSE 19308
19283: GO 19285
19285: DISABLE
// begin enable ;
19286: ENABLE
// CreateCratesArea ( rand ( 3 , 5 ) , cratesArea , true ) ;
19287: LD_INT 3
19289: PPUSH
19290: LD_INT 5
19292: PPUSH
19293: CALL_OW 12
19297: PPUSH
19298: LD_INT 9
19300: PPUSH
19301: LD_INT 1
19303: PPUSH
19304: CALL_OW 55
// end ; end_of_file
19308: END
// every 0 0$1 trigger not retreatAllowed and farmerRequestedCrates and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
19309: LD_EXP 11
19313: NOT
19314: PUSH
19315: LD_EXP 16
19319: AND
19320: PUSH
19321: LD_EXP 4
19325: AND
19326: PUSH
19327: LD_EXP 15
19331: PUSH
19332: LD_EXP 16
19336: LESSEQUAL
19337: AND
19338: IFFALSE 19428
19340: GO 19342
19342: DISABLE
// begin enable ;
19343: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
19344: LD_ADDR_OWVAR 47
19348: PUSH
19349: LD_STRING #X103-1
19351: PUSH
19352: LD_EXP 15
19356: PUSH
19357: LD_EXP 16
19361: PUSH
19362: EMPTY
19363: LIST
19364: LIST
19365: LIST
19366: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
19367: LD_ADDR_EXP 15
19371: PUSH
19372: LD_INT 5
19374: PPUSH
19375: CALL_OW 274
19379: PPUSH
19380: LD_INT 1
19382: PPUSH
19383: CALL_OW 275
19387: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
19388: LD_INT 10
19390: PPUSH
19391: LD_INT 1
19393: PPUSH
19394: CALL_OW 287
19398: PUSH
19399: LD_INT 0
19401: EQUAL
19402: IFFALSE 19420
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
19404: LD_ADDR_EXP 17
19408: PUSH
19409: LD_EXP 17
19413: PUSH
19414: LD_INT 35
19416: MINUS
19417: ST_TO_ADDR
19418: GO 19428
// farmerCratesCounter := 30 30$00 ;
19420: LD_ADDR_EXP 17
19424: PUSH
19425: LD_INT 63000
19427: ST_TO_ADDR
// end ; end_of_file
19428: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
19429: LD_INT 0
19431: PPUSH
// ar_crane := 88 ;
19432: LD_ADDR_EXP 54
19436: PUSH
19437: LD_INT 88
19439: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
19440: LD_ADDR_EXP 49
19444: PUSH
19445: LD_INT 89
19447: ST_TO_ADDR
// us_hack := 99 ;
19448: LD_ADDR_EXP 50
19452: PUSH
19453: LD_INT 99
19455: ST_TO_ADDR
// us_artillery := 97 ;
19456: LD_ADDR_EXP 51
19460: PUSH
19461: LD_INT 97
19463: ST_TO_ADDR
// ar_bio_bomb := 91 ;
19464: LD_ADDR_EXP 52
19468: PUSH
19469: LD_INT 91
19471: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
19472: LD_ADDR_EXP 53
19476: PUSH
19477: LD_INT 92
19479: ST_TO_ADDR
// ru_radar := 98 ;
19480: LD_ADDR_EXP 48
19484: PUSH
19485: LD_INT 98
19487: ST_TO_ADDR
// tech_Artillery := 80 ;
19488: LD_ADDR_EXP 55
19492: PUSH
19493: LD_INT 80
19495: ST_TO_ADDR
// tech_RadMat := 81 ;
19496: LD_ADDR_EXP 56
19500: PUSH
19501: LD_INT 81
19503: ST_TO_ADDR
// tech_BasicTools := 82 ;
19504: LD_ADDR_EXP 57
19508: PUSH
19509: LD_INT 82
19511: ST_TO_ADDR
// tech_Cargo := 83 ;
19512: LD_ADDR_EXP 58
19516: PUSH
19517: LD_INT 83
19519: ST_TO_ADDR
// tech_Track := 84 ;
19520: LD_ADDR_EXP 59
19524: PUSH
19525: LD_INT 84
19527: ST_TO_ADDR
// tech_Crane := 85 ;
19528: LD_ADDR_EXP 60
19532: PUSH
19533: LD_INT 85
19535: ST_TO_ADDR
// tech_Bulldozer := 86 ;
19536: LD_ADDR_EXP 61
19540: PUSH
19541: LD_INT 86
19543: ST_TO_ADDR
// tech_Hovercraft := 87 ;
19544: LD_ADDR_EXP 62
19548: PUSH
19549: LD_INT 87
19551: ST_TO_ADDR
// end ;
19552: LD_VAR 0 1
19556: RET
// every 1 do
19557: GO 19559
19559: DISABLE
// InitGlobalVariables ; end_of_file
19560: CALL 19429 0 0
19564: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
19565: LD_VAR 0 2
19569: PUSH
19570: LD_INT 100
19572: EQUAL
19573: IFFALSE 20522
// begin if not StreamModeActive then
19575: LD_EXP 63
19579: NOT
19580: IFFALSE 19590
// StreamModeActive := true ;
19582: LD_ADDR_EXP 63
19586: PUSH
19587: LD_INT 1
19589: ST_TO_ADDR
// if p3 = 0 then
19590: LD_VAR 0 3
19594: PUSH
19595: LD_INT 0
19597: EQUAL
19598: IFFALSE 19604
// InitStreamMode ;
19600: CALL 20755 0 0
// if p3 = 1 then
19604: LD_VAR 0 3
19608: PUSH
19609: LD_INT 1
19611: EQUAL
19612: IFFALSE 19622
// sRocket := true ;
19614: LD_ADDR_EXP 68
19618: PUSH
19619: LD_INT 1
19621: ST_TO_ADDR
// if p3 = 2 then
19622: LD_VAR 0 3
19626: PUSH
19627: LD_INT 2
19629: EQUAL
19630: IFFALSE 19640
// sSpeed := true ;
19632: LD_ADDR_EXP 67
19636: PUSH
19637: LD_INT 1
19639: ST_TO_ADDR
// if p3 = 3 then
19640: LD_VAR 0 3
19644: PUSH
19645: LD_INT 3
19647: EQUAL
19648: IFFALSE 19658
// sEngine := true ;
19650: LD_ADDR_EXP 69
19654: PUSH
19655: LD_INT 1
19657: ST_TO_ADDR
// if p3 = 4 then
19658: LD_VAR 0 3
19662: PUSH
19663: LD_INT 4
19665: EQUAL
19666: IFFALSE 19676
// sSpec := true ;
19668: LD_ADDR_EXP 66
19672: PUSH
19673: LD_INT 1
19675: ST_TO_ADDR
// if p3 = 5 then
19676: LD_VAR 0 3
19680: PUSH
19681: LD_INT 5
19683: EQUAL
19684: IFFALSE 19694
// sLevel := true ;
19686: LD_ADDR_EXP 70
19690: PUSH
19691: LD_INT 1
19693: ST_TO_ADDR
// if p3 = 6 then
19694: LD_VAR 0 3
19698: PUSH
19699: LD_INT 6
19701: EQUAL
19702: IFFALSE 19712
// sArmoury := true ;
19704: LD_ADDR_EXP 71
19708: PUSH
19709: LD_INT 1
19711: ST_TO_ADDR
// if p3 = 7 then
19712: LD_VAR 0 3
19716: PUSH
19717: LD_INT 7
19719: EQUAL
19720: IFFALSE 19730
// sRadar := true ;
19722: LD_ADDR_EXP 72
19726: PUSH
19727: LD_INT 1
19729: ST_TO_ADDR
// if p3 = 8 then
19730: LD_VAR 0 3
19734: PUSH
19735: LD_INT 8
19737: EQUAL
19738: IFFALSE 19748
// sBunker := true ;
19740: LD_ADDR_EXP 73
19744: PUSH
19745: LD_INT 1
19747: ST_TO_ADDR
// if p3 = 9 then
19748: LD_VAR 0 3
19752: PUSH
19753: LD_INT 9
19755: EQUAL
19756: IFFALSE 19766
// sHack := true ;
19758: LD_ADDR_EXP 74
19762: PUSH
19763: LD_INT 1
19765: ST_TO_ADDR
// if p3 = 10 then
19766: LD_VAR 0 3
19770: PUSH
19771: LD_INT 10
19773: EQUAL
19774: IFFALSE 19784
// sFire := true ;
19776: LD_ADDR_EXP 75
19780: PUSH
19781: LD_INT 1
19783: ST_TO_ADDR
// if p3 = 11 then
19784: LD_VAR 0 3
19788: PUSH
19789: LD_INT 11
19791: EQUAL
19792: IFFALSE 19802
// sRefresh := true ;
19794: LD_ADDR_EXP 76
19798: PUSH
19799: LD_INT 1
19801: ST_TO_ADDR
// if p3 = 12 then
19802: LD_VAR 0 3
19806: PUSH
19807: LD_INT 12
19809: EQUAL
19810: IFFALSE 19820
// sExp := true ;
19812: LD_ADDR_EXP 77
19816: PUSH
19817: LD_INT 1
19819: ST_TO_ADDR
// if p3 = 13 then
19820: LD_VAR 0 3
19824: PUSH
19825: LD_INT 13
19827: EQUAL
19828: IFFALSE 19838
// sDepot := true ;
19830: LD_ADDR_EXP 78
19834: PUSH
19835: LD_INT 1
19837: ST_TO_ADDR
// if p3 = 14 then
19838: LD_VAR 0 3
19842: PUSH
19843: LD_INT 14
19845: EQUAL
19846: IFFALSE 19856
// sFlag := true ;
19848: LD_ADDR_EXP 79
19852: PUSH
19853: LD_INT 1
19855: ST_TO_ADDR
// if p3 = 15 then
19856: LD_VAR 0 3
19860: PUSH
19861: LD_INT 15
19863: EQUAL
19864: IFFALSE 19874
// sKamikadze := true ;
19866: LD_ADDR_EXP 87
19870: PUSH
19871: LD_INT 1
19873: ST_TO_ADDR
// if p3 = 16 then
19874: LD_VAR 0 3
19878: PUSH
19879: LD_INT 16
19881: EQUAL
19882: IFFALSE 19892
// sTroll := true ;
19884: LD_ADDR_EXP 88
19888: PUSH
19889: LD_INT 1
19891: ST_TO_ADDR
// if p3 = 17 then
19892: LD_VAR 0 3
19896: PUSH
19897: LD_INT 17
19899: EQUAL
19900: IFFALSE 19910
// sSlow := true ;
19902: LD_ADDR_EXP 89
19906: PUSH
19907: LD_INT 1
19909: ST_TO_ADDR
// if p3 = 18 then
19910: LD_VAR 0 3
19914: PUSH
19915: LD_INT 18
19917: EQUAL
19918: IFFALSE 19928
// sLack := true ;
19920: LD_ADDR_EXP 90
19924: PUSH
19925: LD_INT 1
19927: ST_TO_ADDR
// if p3 = 19 then
19928: LD_VAR 0 3
19932: PUSH
19933: LD_INT 19
19935: EQUAL
19936: IFFALSE 19946
// sTank := true ;
19938: LD_ADDR_EXP 92
19942: PUSH
19943: LD_INT 1
19945: ST_TO_ADDR
// if p3 = 20 then
19946: LD_VAR 0 3
19950: PUSH
19951: LD_INT 20
19953: EQUAL
19954: IFFALSE 19964
// sRemote := true ;
19956: LD_ADDR_EXP 93
19960: PUSH
19961: LD_INT 1
19963: ST_TO_ADDR
// if p3 = 21 then
19964: LD_VAR 0 3
19968: PUSH
19969: LD_INT 21
19971: EQUAL
19972: IFFALSE 19982
// sPowell := true ;
19974: LD_ADDR_EXP 94
19978: PUSH
19979: LD_INT 1
19981: ST_TO_ADDR
// if p3 = 22 then
19982: LD_VAR 0 3
19986: PUSH
19987: LD_INT 22
19989: EQUAL
19990: IFFALSE 20000
// sTeleport := true ;
19992: LD_ADDR_EXP 97
19996: PUSH
19997: LD_INT 1
19999: ST_TO_ADDR
// if p3 = 23 then
20000: LD_VAR 0 3
20004: PUSH
20005: LD_INT 23
20007: EQUAL
20008: IFFALSE 20018
// sOilTower := true ;
20010: LD_ADDR_EXP 99
20014: PUSH
20015: LD_INT 1
20017: ST_TO_ADDR
// if p3 = 24 then
20018: LD_VAR 0 3
20022: PUSH
20023: LD_INT 24
20025: EQUAL
20026: IFFALSE 20036
// sShovel := true ;
20028: LD_ADDR_EXP 100
20032: PUSH
20033: LD_INT 1
20035: ST_TO_ADDR
// if p3 = 25 then
20036: LD_VAR 0 3
20040: PUSH
20041: LD_INT 25
20043: EQUAL
20044: IFFALSE 20054
// sSheik := true ;
20046: LD_ADDR_EXP 101
20050: PUSH
20051: LD_INT 1
20053: ST_TO_ADDR
// if p3 = 26 then
20054: LD_VAR 0 3
20058: PUSH
20059: LD_INT 26
20061: EQUAL
20062: IFFALSE 20072
// sEarthquake := true ;
20064: LD_ADDR_EXP 103
20068: PUSH
20069: LD_INT 1
20071: ST_TO_ADDR
// if p3 = 27 then
20072: LD_VAR 0 3
20076: PUSH
20077: LD_INT 27
20079: EQUAL
20080: IFFALSE 20090
// sAI := true ;
20082: LD_ADDR_EXP 104
20086: PUSH
20087: LD_INT 1
20089: ST_TO_ADDR
// if p3 = 28 then
20090: LD_VAR 0 3
20094: PUSH
20095: LD_INT 28
20097: EQUAL
20098: IFFALSE 20108
// sCargo := true ;
20100: LD_ADDR_EXP 107
20104: PUSH
20105: LD_INT 1
20107: ST_TO_ADDR
// if p3 = 29 then
20108: LD_VAR 0 3
20112: PUSH
20113: LD_INT 29
20115: EQUAL
20116: IFFALSE 20126
// sDLaser := true ;
20118: LD_ADDR_EXP 108
20122: PUSH
20123: LD_INT 1
20125: ST_TO_ADDR
// if p3 = 30 then
20126: LD_VAR 0 3
20130: PUSH
20131: LD_INT 30
20133: EQUAL
20134: IFFALSE 20144
// sExchange := true ;
20136: LD_ADDR_EXP 109
20140: PUSH
20141: LD_INT 1
20143: ST_TO_ADDR
// if p3 = 31 then
20144: LD_VAR 0 3
20148: PUSH
20149: LD_INT 31
20151: EQUAL
20152: IFFALSE 20162
// sFac := true ;
20154: LD_ADDR_EXP 110
20158: PUSH
20159: LD_INT 1
20161: ST_TO_ADDR
// if p3 = 32 then
20162: LD_VAR 0 3
20166: PUSH
20167: LD_INT 32
20169: EQUAL
20170: IFFALSE 20180
// sPower := true ;
20172: LD_ADDR_EXP 111
20176: PUSH
20177: LD_INT 1
20179: ST_TO_ADDR
// if p3 = 33 then
20180: LD_VAR 0 3
20184: PUSH
20185: LD_INT 33
20187: EQUAL
20188: IFFALSE 20198
// sRandom := true ;
20190: LD_ADDR_EXP 112
20194: PUSH
20195: LD_INT 1
20197: ST_TO_ADDR
// if p3 = 34 then
20198: LD_VAR 0 3
20202: PUSH
20203: LD_INT 34
20205: EQUAL
20206: IFFALSE 20216
// sShield := true ;
20208: LD_ADDR_EXP 113
20212: PUSH
20213: LD_INT 1
20215: ST_TO_ADDR
// if p3 = 35 then
20216: LD_VAR 0 3
20220: PUSH
20221: LD_INT 35
20223: EQUAL
20224: IFFALSE 20234
// sTime := true ;
20226: LD_ADDR_EXP 114
20230: PUSH
20231: LD_INT 1
20233: ST_TO_ADDR
// if p3 = 36 then
20234: LD_VAR 0 3
20238: PUSH
20239: LD_INT 36
20241: EQUAL
20242: IFFALSE 20252
// sTools := true ;
20244: LD_ADDR_EXP 115
20248: PUSH
20249: LD_INT 1
20251: ST_TO_ADDR
// if p3 = 101 then
20252: LD_VAR 0 3
20256: PUSH
20257: LD_INT 101
20259: EQUAL
20260: IFFALSE 20270
// sSold := true ;
20262: LD_ADDR_EXP 80
20266: PUSH
20267: LD_INT 1
20269: ST_TO_ADDR
// if p3 = 102 then
20270: LD_VAR 0 3
20274: PUSH
20275: LD_INT 102
20277: EQUAL
20278: IFFALSE 20288
// sDiff := true ;
20280: LD_ADDR_EXP 81
20284: PUSH
20285: LD_INT 1
20287: ST_TO_ADDR
// if p3 = 103 then
20288: LD_VAR 0 3
20292: PUSH
20293: LD_INT 103
20295: EQUAL
20296: IFFALSE 20306
// sFog := true ;
20298: LD_ADDR_EXP 84
20302: PUSH
20303: LD_INT 1
20305: ST_TO_ADDR
// if p3 = 104 then
20306: LD_VAR 0 3
20310: PUSH
20311: LD_INT 104
20313: EQUAL
20314: IFFALSE 20324
// sReset := true ;
20316: LD_ADDR_EXP 85
20320: PUSH
20321: LD_INT 1
20323: ST_TO_ADDR
// if p3 = 105 then
20324: LD_VAR 0 3
20328: PUSH
20329: LD_INT 105
20331: EQUAL
20332: IFFALSE 20342
// sSun := true ;
20334: LD_ADDR_EXP 86
20338: PUSH
20339: LD_INT 1
20341: ST_TO_ADDR
// if p3 = 106 then
20342: LD_VAR 0 3
20346: PUSH
20347: LD_INT 106
20349: EQUAL
20350: IFFALSE 20360
// sTiger := true ;
20352: LD_ADDR_EXP 82
20356: PUSH
20357: LD_INT 1
20359: ST_TO_ADDR
// if p3 = 107 then
20360: LD_VAR 0 3
20364: PUSH
20365: LD_INT 107
20367: EQUAL
20368: IFFALSE 20378
// sBomb := true ;
20370: LD_ADDR_EXP 83
20374: PUSH
20375: LD_INT 1
20377: ST_TO_ADDR
// if p3 = 108 then
20378: LD_VAR 0 3
20382: PUSH
20383: LD_INT 108
20385: EQUAL
20386: IFFALSE 20396
// sWound := true ;
20388: LD_ADDR_EXP 91
20392: PUSH
20393: LD_INT 1
20395: ST_TO_ADDR
// if p3 = 109 then
20396: LD_VAR 0 3
20400: PUSH
20401: LD_INT 109
20403: EQUAL
20404: IFFALSE 20414
// sBetray := true ;
20406: LD_ADDR_EXP 95
20410: PUSH
20411: LD_INT 1
20413: ST_TO_ADDR
// if p3 = 110 then
20414: LD_VAR 0 3
20418: PUSH
20419: LD_INT 110
20421: EQUAL
20422: IFFALSE 20432
// sContamin := true ;
20424: LD_ADDR_EXP 96
20428: PUSH
20429: LD_INT 1
20431: ST_TO_ADDR
// if p3 = 111 then
20432: LD_VAR 0 3
20436: PUSH
20437: LD_INT 111
20439: EQUAL
20440: IFFALSE 20450
// sOil := true ;
20442: LD_ADDR_EXP 98
20446: PUSH
20447: LD_INT 1
20449: ST_TO_ADDR
// if p3 = 112 then
20450: LD_VAR 0 3
20454: PUSH
20455: LD_INT 112
20457: EQUAL
20458: IFFALSE 20468
// sStu := true ;
20460: LD_ADDR_EXP 102
20464: PUSH
20465: LD_INT 1
20467: ST_TO_ADDR
// if p3 = 113 then
20468: LD_VAR 0 3
20472: PUSH
20473: LD_INT 113
20475: EQUAL
20476: IFFALSE 20486
// sBazooka := true ;
20478: LD_ADDR_EXP 105
20482: PUSH
20483: LD_INT 1
20485: ST_TO_ADDR
// if p3 = 114 then
20486: LD_VAR 0 3
20490: PUSH
20491: LD_INT 114
20493: EQUAL
20494: IFFALSE 20504
// sMortar := true ;
20496: LD_ADDR_EXP 106
20500: PUSH
20501: LD_INT 1
20503: ST_TO_ADDR
// if p3 = 115 then
20504: LD_VAR 0 3
20508: PUSH
20509: LD_INT 115
20511: EQUAL
20512: IFFALSE 20522
// sRanger := true ;
20514: LD_ADDR_EXP 116
20518: PUSH
20519: LD_INT 1
20521: ST_TO_ADDR
// end ; if p2 = 101 then
20522: LD_VAR 0 2
20526: PUSH
20527: LD_INT 101
20529: EQUAL
20530: IFFALSE 20733
// begin case p3 of 1 :
20532: LD_VAR 0 3
20536: PUSH
20537: LD_INT 1
20539: DOUBLE
20540: EQUAL
20541: IFTRUE 20545
20543: GO 20552
20545: POP
// hHackUnlimitedResources ; 2 :
20546: CALL 30827 0 0
20550: GO 20733
20552: LD_INT 2
20554: DOUBLE
20555: EQUAL
20556: IFTRUE 20560
20558: GO 20567
20560: POP
// hHackSetLevel10 ; 3 :
20561: CALL 30960 0 0
20565: GO 20733
20567: LD_INT 3
20569: DOUBLE
20570: EQUAL
20571: IFTRUE 20575
20573: GO 20582
20575: POP
// hHackSetLevel10YourUnits ; 4 :
20576: CALL 31045 0 0
20580: GO 20733
20582: LD_INT 4
20584: DOUBLE
20585: EQUAL
20586: IFTRUE 20590
20588: GO 20612
20590: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
20591: LD_VAR 0 4
20595: PPUSH
20596: LD_VAR 0 5
20600: PPUSH
20601: LD_VAR 0 6
20605: PPUSH
20606: CALL 31135 0 3
20610: GO 20733
20612: LD_INT 5
20614: DOUBLE
20615: EQUAL
20616: IFTRUE 20620
20618: GO 20627
20620: POP
// hHackSpawnVehicle ; 6 :
20621: CALL 31196 0 0
20625: GO 20733
20627: LD_INT 6
20629: DOUBLE
20630: EQUAL
20631: IFTRUE 20635
20633: GO 20642
20635: POP
// hHackInvincible ; 7 :
20636: CALL 31742 0 0
20640: GO 20733
20642: LD_INT 7
20644: DOUBLE
20645: EQUAL
20646: IFTRUE 20650
20648: GO 20657
20650: POP
// hHackInvisible ; 8 :
20651: CALL 31853 0 0
20655: GO 20733
20657: LD_INT 8
20659: DOUBLE
20660: EQUAL
20661: IFTRUE 20665
20663: GO 20672
20665: POP
// hHackChangeYourSide ; 9 :
20666: CALL 31910 0 0
20670: GO 20733
20672: LD_INT 9
20674: DOUBLE
20675: EQUAL
20676: IFTRUE 20680
20678: GO 20687
20680: POP
// hHackChangeUnitSide ; 10 :
20681: CALL 31952 0 0
20685: GO 20733
20687: LD_INT 10
20689: DOUBLE
20690: EQUAL
20691: IFTRUE 20695
20693: GO 20702
20695: POP
// hHackFog ; 11 :
20696: CALL 32053 0 0
20700: GO 20733
20702: LD_INT 11
20704: DOUBLE
20705: EQUAL
20706: IFTRUE 20710
20708: GO 20717
20710: POP
// hHackApeman ; 12 :
20711: CALL 32068 0 0
20715: GO 20733
20717: LD_INT 12
20719: DOUBLE
20720: EQUAL
20721: IFTRUE 20725
20723: GO 20732
20725: POP
// hHackBoom ; end ;
20726: CALL 32153 0 0
20730: GO 20733
20732: POP
// end ; end ;
20733: PPOPN 6
20735: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
20736: GO 20738
20738: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
20739: LD_STRING initStreamRollete();
20741: PPUSH
20742: CALL_OW 559
// InitStreamMode ;
20746: CALL 20755 0 0
// DefineStreamItems ( ) ;
20750: CALL 21195 0 0
// end ;
20754: END
// function InitStreamMode ; begin
20755: LD_INT 0
20757: PPUSH
// streamModeActive := false ;
20758: LD_ADDR_EXP 63
20762: PUSH
20763: LD_INT 0
20765: ST_TO_ADDR
// normalCounter := 36 ;
20766: LD_ADDR_EXP 64
20770: PUSH
20771: LD_INT 36
20773: ST_TO_ADDR
// hardcoreCounter := 16 ;
20774: LD_ADDR_EXP 65
20778: PUSH
20779: LD_INT 16
20781: ST_TO_ADDR
// sRocket := false ;
20782: LD_ADDR_EXP 68
20786: PUSH
20787: LD_INT 0
20789: ST_TO_ADDR
// sSpeed := false ;
20790: LD_ADDR_EXP 67
20794: PUSH
20795: LD_INT 0
20797: ST_TO_ADDR
// sEngine := false ;
20798: LD_ADDR_EXP 69
20802: PUSH
20803: LD_INT 0
20805: ST_TO_ADDR
// sSpec := false ;
20806: LD_ADDR_EXP 66
20810: PUSH
20811: LD_INT 0
20813: ST_TO_ADDR
// sLevel := false ;
20814: LD_ADDR_EXP 70
20818: PUSH
20819: LD_INT 0
20821: ST_TO_ADDR
// sArmoury := false ;
20822: LD_ADDR_EXP 71
20826: PUSH
20827: LD_INT 0
20829: ST_TO_ADDR
// sRadar := false ;
20830: LD_ADDR_EXP 72
20834: PUSH
20835: LD_INT 0
20837: ST_TO_ADDR
// sBunker := false ;
20838: LD_ADDR_EXP 73
20842: PUSH
20843: LD_INT 0
20845: ST_TO_ADDR
// sHack := false ;
20846: LD_ADDR_EXP 74
20850: PUSH
20851: LD_INT 0
20853: ST_TO_ADDR
// sFire := false ;
20854: LD_ADDR_EXP 75
20858: PUSH
20859: LD_INT 0
20861: ST_TO_ADDR
// sRefresh := false ;
20862: LD_ADDR_EXP 76
20866: PUSH
20867: LD_INT 0
20869: ST_TO_ADDR
// sExp := false ;
20870: LD_ADDR_EXP 77
20874: PUSH
20875: LD_INT 0
20877: ST_TO_ADDR
// sDepot := false ;
20878: LD_ADDR_EXP 78
20882: PUSH
20883: LD_INT 0
20885: ST_TO_ADDR
// sFlag := false ;
20886: LD_ADDR_EXP 79
20890: PUSH
20891: LD_INT 0
20893: ST_TO_ADDR
// sKamikadze := false ;
20894: LD_ADDR_EXP 87
20898: PUSH
20899: LD_INT 0
20901: ST_TO_ADDR
// sTroll := false ;
20902: LD_ADDR_EXP 88
20906: PUSH
20907: LD_INT 0
20909: ST_TO_ADDR
// sSlow := false ;
20910: LD_ADDR_EXP 89
20914: PUSH
20915: LD_INT 0
20917: ST_TO_ADDR
// sLack := false ;
20918: LD_ADDR_EXP 90
20922: PUSH
20923: LD_INT 0
20925: ST_TO_ADDR
// sTank := false ;
20926: LD_ADDR_EXP 92
20930: PUSH
20931: LD_INT 0
20933: ST_TO_ADDR
// sRemote := false ;
20934: LD_ADDR_EXP 93
20938: PUSH
20939: LD_INT 0
20941: ST_TO_ADDR
// sPowell := false ;
20942: LD_ADDR_EXP 94
20946: PUSH
20947: LD_INT 0
20949: ST_TO_ADDR
// sTeleport := false ;
20950: LD_ADDR_EXP 97
20954: PUSH
20955: LD_INT 0
20957: ST_TO_ADDR
// sOilTower := false ;
20958: LD_ADDR_EXP 99
20962: PUSH
20963: LD_INT 0
20965: ST_TO_ADDR
// sShovel := false ;
20966: LD_ADDR_EXP 100
20970: PUSH
20971: LD_INT 0
20973: ST_TO_ADDR
// sSheik := false ;
20974: LD_ADDR_EXP 101
20978: PUSH
20979: LD_INT 0
20981: ST_TO_ADDR
// sEarthquake := false ;
20982: LD_ADDR_EXP 103
20986: PUSH
20987: LD_INT 0
20989: ST_TO_ADDR
// sAI := false ;
20990: LD_ADDR_EXP 104
20994: PUSH
20995: LD_INT 0
20997: ST_TO_ADDR
// sCargo := false ;
20998: LD_ADDR_EXP 107
21002: PUSH
21003: LD_INT 0
21005: ST_TO_ADDR
// sDLaser := false ;
21006: LD_ADDR_EXP 108
21010: PUSH
21011: LD_INT 0
21013: ST_TO_ADDR
// sExchange := false ;
21014: LD_ADDR_EXP 109
21018: PUSH
21019: LD_INT 0
21021: ST_TO_ADDR
// sFac := false ;
21022: LD_ADDR_EXP 110
21026: PUSH
21027: LD_INT 0
21029: ST_TO_ADDR
// sPower := false ;
21030: LD_ADDR_EXP 111
21034: PUSH
21035: LD_INT 0
21037: ST_TO_ADDR
// sRandom := false ;
21038: LD_ADDR_EXP 112
21042: PUSH
21043: LD_INT 0
21045: ST_TO_ADDR
// sShield := false ;
21046: LD_ADDR_EXP 113
21050: PUSH
21051: LD_INT 0
21053: ST_TO_ADDR
// sTime := false ;
21054: LD_ADDR_EXP 114
21058: PUSH
21059: LD_INT 0
21061: ST_TO_ADDR
// sTools := false ;
21062: LD_ADDR_EXP 115
21066: PUSH
21067: LD_INT 0
21069: ST_TO_ADDR
// sSold := false ;
21070: LD_ADDR_EXP 80
21074: PUSH
21075: LD_INT 0
21077: ST_TO_ADDR
// sDiff := false ;
21078: LD_ADDR_EXP 81
21082: PUSH
21083: LD_INT 0
21085: ST_TO_ADDR
// sFog := false ;
21086: LD_ADDR_EXP 84
21090: PUSH
21091: LD_INT 0
21093: ST_TO_ADDR
// sReset := false ;
21094: LD_ADDR_EXP 85
21098: PUSH
21099: LD_INT 0
21101: ST_TO_ADDR
// sSun := false ;
21102: LD_ADDR_EXP 86
21106: PUSH
21107: LD_INT 0
21109: ST_TO_ADDR
// sTiger := false ;
21110: LD_ADDR_EXP 82
21114: PUSH
21115: LD_INT 0
21117: ST_TO_ADDR
// sBomb := false ;
21118: LD_ADDR_EXP 83
21122: PUSH
21123: LD_INT 0
21125: ST_TO_ADDR
// sWound := false ;
21126: LD_ADDR_EXP 91
21130: PUSH
21131: LD_INT 0
21133: ST_TO_ADDR
// sBetray := false ;
21134: LD_ADDR_EXP 95
21138: PUSH
21139: LD_INT 0
21141: ST_TO_ADDR
// sContamin := false ;
21142: LD_ADDR_EXP 96
21146: PUSH
21147: LD_INT 0
21149: ST_TO_ADDR
// sOil := false ;
21150: LD_ADDR_EXP 98
21154: PUSH
21155: LD_INT 0
21157: ST_TO_ADDR
// sStu := false ;
21158: LD_ADDR_EXP 102
21162: PUSH
21163: LD_INT 0
21165: ST_TO_ADDR
// sBazooka := false ;
21166: LD_ADDR_EXP 105
21170: PUSH
21171: LD_INT 0
21173: ST_TO_ADDR
// sMortar := false ;
21174: LD_ADDR_EXP 106
21178: PUSH
21179: LD_INT 0
21181: ST_TO_ADDR
// sRanger := false ;
21182: LD_ADDR_EXP 116
21186: PUSH
21187: LD_INT 0
21189: ST_TO_ADDR
// end ;
21190: LD_VAR 0 1
21194: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
21195: LD_INT 0
21197: PPUSH
21198: PPUSH
21199: PPUSH
21200: PPUSH
21201: PPUSH
// result := [ ] ;
21202: LD_ADDR_VAR 0 1
21206: PUSH
21207: EMPTY
21208: ST_TO_ADDR
// if campaign_id = 1 then
21209: LD_OWVAR 69
21213: PUSH
21214: LD_INT 1
21216: EQUAL
21217: IFFALSE 24155
// begin case mission_number of 1 :
21219: LD_OWVAR 70
21223: PUSH
21224: LD_INT 1
21226: DOUBLE
21227: EQUAL
21228: IFTRUE 21232
21230: GO 21296
21232: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
21233: LD_ADDR_VAR 0 1
21237: PUSH
21238: LD_INT 2
21240: PUSH
21241: LD_INT 4
21243: PUSH
21244: LD_INT 11
21246: PUSH
21247: LD_INT 12
21249: PUSH
21250: LD_INT 15
21252: PUSH
21253: LD_INT 16
21255: PUSH
21256: LD_INT 22
21258: PUSH
21259: LD_INT 23
21261: PUSH
21262: LD_INT 26
21264: PUSH
21265: EMPTY
21266: LIST
21267: LIST
21268: LIST
21269: LIST
21270: LIST
21271: LIST
21272: LIST
21273: LIST
21274: LIST
21275: PUSH
21276: LD_INT 101
21278: PUSH
21279: LD_INT 102
21281: PUSH
21282: LD_INT 106
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: LIST
21289: PUSH
21290: EMPTY
21291: LIST
21292: LIST
21293: ST_TO_ADDR
21294: GO 24153
21296: LD_INT 2
21298: DOUBLE
21299: EQUAL
21300: IFTRUE 21304
21302: GO 21376
21304: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
21305: LD_ADDR_VAR 0 1
21309: PUSH
21310: LD_INT 2
21312: PUSH
21313: LD_INT 4
21315: PUSH
21316: LD_INT 11
21318: PUSH
21319: LD_INT 12
21321: PUSH
21322: LD_INT 15
21324: PUSH
21325: LD_INT 16
21327: PUSH
21328: LD_INT 22
21330: PUSH
21331: LD_INT 23
21333: PUSH
21334: LD_INT 26
21336: PUSH
21337: EMPTY
21338: LIST
21339: LIST
21340: LIST
21341: LIST
21342: LIST
21343: LIST
21344: LIST
21345: LIST
21346: LIST
21347: PUSH
21348: LD_INT 101
21350: PUSH
21351: LD_INT 102
21353: PUSH
21354: LD_INT 105
21356: PUSH
21357: LD_INT 106
21359: PUSH
21360: LD_INT 108
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: LIST
21367: LIST
21368: LIST
21369: PUSH
21370: EMPTY
21371: LIST
21372: LIST
21373: ST_TO_ADDR
21374: GO 24153
21376: LD_INT 3
21378: DOUBLE
21379: EQUAL
21380: IFTRUE 21384
21382: GO 21460
21384: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
21385: LD_ADDR_VAR 0 1
21389: PUSH
21390: LD_INT 2
21392: PUSH
21393: LD_INT 4
21395: PUSH
21396: LD_INT 5
21398: PUSH
21399: LD_INT 11
21401: PUSH
21402: LD_INT 12
21404: PUSH
21405: LD_INT 15
21407: PUSH
21408: LD_INT 16
21410: PUSH
21411: LD_INT 22
21413: PUSH
21414: LD_INT 26
21416: PUSH
21417: LD_INT 36
21419: PUSH
21420: EMPTY
21421: LIST
21422: LIST
21423: LIST
21424: LIST
21425: LIST
21426: LIST
21427: LIST
21428: LIST
21429: LIST
21430: LIST
21431: PUSH
21432: LD_INT 101
21434: PUSH
21435: LD_INT 102
21437: PUSH
21438: LD_INT 105
21440: PUSH
21441: LD_INT 106
21443: PUSH
21444: LD_INT 108
21446: PUSH
21447: EMPTY
21448: LIST
21449: LIST
21450: LIST
21451: LIST
21452: LIST
21453: PUSH
21454: EMPTY
21455: LIST
21456: LIST
21457: ST_TO_ADDR
21458: GO 24153
21460: LD_INT 4
21462: DOUBLE
21463: EQUAL
21464: IFTRUE 21468
21466: GO 21552
21468: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
21469: LD_ADDR_VAR 0 1
21473: PUSH
21474: LD_INT 2
21476: PUSH
21477: LD_INT 4
21479: PUSH
21480: LD_INT 5
21482: PUSH
21483: LD_INT 8
21485: PUSH
21486: LD_INT 11
21488: PUSH
21489: LD_INT 12
21491: PUSH
21492: LD_INT 15
21494: PUSH
21495: LD_INT 16
21497: PUSH
21498: LD_INT 22
21500: PUSH
21501: LD_INT 23
21503: PUSH
21504: LD_INT 26
21506: PUSH
21507: LD_INT 36
21509: PUSH
21510: EMPTY
21511: LIST
21512: LIST
21513: LIST
21514: LIST
21515: LIST
21516: LIST
21517: LIST
21518: LIST
21519: LIST
21520: LIST
21521: LIST
21522: LIST
21523: PUSH
21524: LD_INT 101
21526: PUSH
21527: LD_INT 102
21529: PUSH
21530: LD_INT 105
21532: PUSH
21533: LD_INT 106
21535: PUSH
21536: LD_INT 108
21538: PUSH
21539: EMPTY
21540: LIST
21541: LIST
21542: LIST
21543: LIST
21544: LIST
21545: PUSH
21546: EMPTY
21547: LIST
21548: LIST
21549: ST_TO_ADDR
21550: GO 24153
21552: LD_INT 5
21554: DOUBLE
21555: EQUAL
21556: IFTRUE 21560
21558: GO 21660
21560: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
21561: LD_ADDR_VAR 0 1
21565: PUSH
21566: LD_INT 2
21568: PUSH
21569: LD_INT 4
21571: PUSH
21572: LD_INT 5
21574: PUSH
21575: LD_INT 6
21577: PUSH
21578: LD_INT 8
21580: PUSH
21581: LD_INT 11
21583: PUSH
21584: LD_INT 12
21586: PUSH
21587: LD_INT 15
21589: PUSH
21590: LD_INT 16
21592: PUSH
21593: LD_INT 22
21595: PUSH
21596: LD_INT 23
21598: PUSH
21599: LD_INT 25
21601: PUSH
21602: LD_INT 26
21604: PUSH
21605: LD_INT 36
21607: PUSH
21608: EMPTY
21609: LIST
21610: LIST
21611: LIST
21612: LIST
21613: LIST
21614: LIST
21615: LIST
21616: LIST
21617: LIST
21618: LIST
21619: LIST
21620: LIST
21621: LIST
21622: LIST
21623: PUSH
21624: LD_INT 101
21626: PUSH
21627: LD_INT 102
21629: PUSH
21630: LD_INT 105
21632: PUSH
21633: LD_INT 106
21635: PUSH
21636: LD_INT 108
21638: PUSH
21639: LD_INT 109
21641: PUSH
21642: LD_INT 112
21644: PUSH
21645: EMPTY
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: LIST
21653: PUSH
21654: EMPTY
21655: LIST
21656: LIST
21657: ST_TO_ADDR
21658: GO 24153
21660: LD_INT 6
21662: DOUBLE
21663: EQUAL
21664: IFTRUE 21668
21666: GO 21788
21668: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
21669: LD_ADDR_VAR 0 1
21673: PUSH
21674: LD_INT 2
21676: PUSH
21677: LD_INT 4
21679: PUSH
21680: LD_INT 5
21682: PUSH
21683: LD_INT 6
21685: PUSH
21686: LD_INT 8
21688: PUSH
21689: LD_INT 11
21691: PUSH
21692: LD_INT 12
21694: PUSH
21695: LD_INT 15
21697: PUSH
21698: LD_INT 16
21700: PUSH
21701: LD_INT 20
21703: PUSH
21704: LD_INT 21
21706: PUSH
21707: LD_INT 22
21709: PUSH
21710: LD_INT 23
21712: PUSH
21713: LD_INT 25
21715: PUSH
21716: LD_INT 26
21718: PUSH
21719: LD_INT 30
21721: PUSH
21722: LD_INT 31
21724: PUSH
21725: LD_INT 32
21727: PUSH
21728: LD_INT 36
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: LIST
21735: LIST
21736: LIST
21737: LIST
21738: LIST
21739: LIST
21740: LIST
21741: LIST
21742: LIST
21743: LIST
21744: LIST
21745: LIST
21746: LIST
21747: LIST
21748: LIST
21749: LIST
21750: LIST
21751: PUSH
21752: LD_INT 101
21754: PUSH
21755: LD_INT 102
21757: PUSH
21758: LD_INT 105
21760: PUSH
21761: LD_INT 106
21763: PUSH
21764: LD_INT 108
21766: PUSH
21767: LD_INT 109
21769: PUSH
21770: LD_INT 112
21772: PUSH
21773: EMPTY
21774: LIST
21775: LIST
21776: LIST
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: ST_TO_ADDR
21786: GO 24153
21788: LD_INT 7
21790: DOUBLE
21791: EQUAL
21792: IFTRUE 21796
21794: GO 21896
21796: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
21797: LD_ADDR_VAR 0 1
21801: PUSH
21802: LD_INT 2
21804: PUSH
21805: LD_INT 4
21807: PUSH
21808: LD_INT 5
21810: PUSH
21811: LD_INT 7
21813: PUSH
21814: LD_INT 11
21816: PUSH
21817: LD_INT 12
21819: PUSH
21820: LD_INT 15
21822: PUSH
21823: LD_INT 16
21825: PUSH
21826: LD_INT 20
21828: PUSH
21829: LD_INT 21
21831: PUSH
21832: LD_INT 22
21834: PUSH
21835: LD_INT 23
21837: PUSH
21838: LD_INT 25
21840: PUSH
21841: LD_INT 26
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: LIST
21848: LIST
21849: LIST
21850: LIST
21851: LIST
21852: LIST
21853: LIST
21854: LIST
21855: LIST
21856: LIST
21857: LIST
21858: LIST
21859: PUSH
21860: LD_INT 101
21862: PUSH
21863: LD_INT 102
21865: PUSH
21866: LD_INT 103
21868: PUSH
21869: LD_INT 105
21871: PUSH
21872: LD_INT 106
21874: PUSH
21875: LD_INT 108
21877: PUSH
21878: LD_INT 112
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: LIST
21885: LIST
21886: LIST
21887: LIST
21888: LIST
21889: PUSH
21890: EMPTY
21891: LIST
21892: LIST
21893: ST_TO_ADDR
21894: GO 24153
21896: LD_INT 8
21898: DOUBLE
21899: EQUAL
21900: IFTRUE 21904
21902: GO 22032
21904: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
21905: LD_ADDR_VAR 0 1
21909: PUSH
21910: LD_INT 2
21912: PUSH
21913: LD_INT 4
21915: PUSH
21916: LD_INT 5
21918: PUSH
21919: LD_INT 6
21921: PUSH
21922: LD_INT 7
21924: PUSH
21925: LD_INT 8
21927: PUSH
21928: LD_INT 11
21930: PUSH
21931: LD_INT 12
21933: PUSH
21934: LD_INT 15
21936: PUSH
21937: LD_INT 16
21939: PUSH
21940: LD_INT 20
21942: PUSH
21943: LD_INT 21
21945: PUSH
21946: LD_INT 22
21948: PUSH
21949: LD_INT 23
21951: PUSH
21952: LD_INT 25
21954: PUSH
21955: LD_INT 26
21957: PUSH
21958: LD_INT 30
21960: PUSH
21961: LD_INT 31
21963: PUSH
21964: LD_INT 32
21966: PUSH
21967: LD_INT 36
21969: PUSH
21970: EMPTY
21971: LIST
21972: LIST
21973: LIST
21974: LIST
21975: LIST
21976: LIST
21977: LIST
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: LIST
21986: LIST
21987: LIST
21988: LIST
21989: LIST
21990: LIST
21991: PUSH
21992: LD_INT 101
21994: PUSH
21995: LD_INT 102
21997: PUSH
21998: LD_INT 103
22000: PUSH
22001: LD_INT 105
22003: PUSH
22004: LD_INT 106
22006: PUSH
22007: LD_INT 108
22009: PUSH
22010: LD_INT 109
22012: PUSH
22013: LD_INT 112
22015: PUSH
22016: EMPTY
22017: LIST
22018: LIST
22019: LIST
22020: LIST
22021: LIST
22022: LIST
22023: LIST
22024: LIST
22025: PUSH
22026: EMPTY
22027: LIST
22028: LIST
22029: ST_TO_ADDR
22030: GO 24153
22032: LD_INT 9
22034: DOUBLE
22035: EQUAL
22036: IFTRUE 22040
22038: GO 22176
22040: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
22041: LD_ADDR_VAR 0 1
22045: PUSH
22046: LD_INT 2
22048: PUSH
22049: LD_INT 4
22051: PUSH
22052: LD_INT 5
22054: PUSH
22055: LD_INT 6
22057: PUSH
22058: LD_INT 7
22060: PUSH
22061: LD_INT 8
22063: PUSH
22064: LD_INT 11
22066: PUSH
22067: LD_INT 12
22069: PUSH
22070: LD_INT 15
22072: PUSH
22073: LD_INT 16
22075: PUSH
22076: LD_INT 20
22078: PUSH
22079: LD_INT 21
22081: PUSH
22082: LD_INT 22
22084: PUSH
22085: LD_INT 23
22087: PUSH
22088: LD_INT 25
22090: PUSH
22091: LD_INT 26
22093: PUSH
22094: LD_INT 28
22096: PUSH
22097: LD_INT 30
22099: PUSH
22100: LD_INT 31
22102: PUSH
22103: LD_INT 32
22105: PUSH
22106: LD_INT 36
22108: PUSH
22109: EMPTY
22110: LIST
22111: LIST
22112: LIST
22113: LIST
22114: LIST
22115: LIST
22116: LIST
22117: LIST
22118: LIST
22119: LIST
22120: LIST
22121: LIST
22122: LIST
22123: LIST
22124: LIST
22125: LIST
22126: LIST
22127: LIST
22128: LIST
22129: LIST
22130: LIST
22131: PUSH
22132: LD_INT 101
22134: PUSH
22135: LD_INT 102
22137: PUSH
22138: LD_INT 103
22140: PUSH
22141: LD_INT 105
22143: PUSH
22144: LD_INT 106
22146: PUSH
22147: LD_INT 108
22149: PUSH
22150: LD_INT 109
22152: PUSH
22153: LD_INT 112
22155: PUSH
22156: LD_INT 114
22158: PUSH
22159: EMPTY
22160: LIST
22161: LIST
22162: LIST
22163: LIST
22164: LIST
22165: LIST
22166: LIST
22167: LIST
22168: LIST
22169: PUSH
22170: EMPTY
22171: LIST
22172: LIST
22173: ST_TO_ADDR
22174: GO 24153
22176: LD_INT 10
22178: DOUBLE
22179: EQUAL
22180: IFTRUE 22184
22182: GO 22368
22184: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
22185: LD_ADDR_VAR 0 1
22189: PUSH
22190: LD_INT 2
22192: PUSH
22193: LD_INT 4
22195: PUSH
22196: LD_INT 5
22198: PUSH
22199: LD_INT 6
22201: PUSH
22202: LD_INT 7
22204: PUSH
22205: LD_INT 8
22207: PUSH
22208: LD_INT 9
22210: PUSH
22211: LD_INT 10
22213: PUSH
22214: LD_INT 11
22216: PUSH
22217: LD_INT 12
22219: PUSH
22220: LD_INT 13
22222: PUSH
22223: LD_INT 14
22225: PUSH
22226: LD_INT 15
22228: PUSH
22229: LD_INT 16
22231: PUSH
22232: LD_INT 17
22234: PUSH
22235: LD_INT 18
22237: PUSH
22238: LD_INT 19
22240: PUSH
22241: LD_INT 20
22243: PUSH
22244: LD_INT 21
22246: PUSH
22247: LD_INT 22
22249: PUSH
22250: LD_INT 23
22252: PUSH
22253: LD_INT 24
22255: PUSH
22256: LD_INT 25
22258: PUSH
22259: LD_INT 26
22261: PUSH
22262: LD_INT 28
22264: PUSH
22265: LD_INT 30
22267: PUSH
22268: LD_INT 31
22270: PUSH
22271: LD_INT 32
22273: PUSH
22274: LD_INT 36
22276: PUSH
22277: EMPTY
22278: LIST
22279: LIST
22280: LIST
22281: LIST
22282: LIST
22283: LIST
22284: LIST
22285: LIST
22286: LIST
22287: LIST
22288: LIST
22289: LIST
22290: LIST
22291: LIST
22292: LIST
22293: LIST
22294: LIST
22295: LIST
22296: LIST
22297: LIST
22298: LIST
22299: LIST
22300: LIST
22301: LIST
22302: LIST
22303: LIST
22304: LIST
22305: LIST
22306: LIST
22307: PUSH
22308: LD_INT 101
22310: PUSH
22311: LD_INT 102
22313: PUSH
22314: LD_INT 103
22316: PUSH
22317: LD_INT 104
22319: PUSH
22320: LD_INT 105
22322: PUSH
22323: LD_INT 106
22325: PUSH
22326: LD_INT 107
22328: PUSH
22329: LD_INT 108
22331: PUSH
22332: LD_INT 109
22334: PUSH
22335: LD_INT 110
22337: PUSH
22338: LD_INT 111
22340: PUSH
22341: LD_INT 112
22343: PUSH
22344: LD_INT 114
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: LIST
22351: LIST
22352: LIST
22353: LIST
22354: LIST
22355: LIST
22356: LIST
22357: LIST
22358: LIST
22359: LIST
22360: LIST
22361: PUSH
22362: EMPTY
22363: LIST
22364: LIST
22365: ST_TO_ADDR
22366: GO 24153
22368: LD_INT 11
22370: DOUBLE
22371: EQUAL
22372: IFTRUE 22376
22374: GO 22568
22376: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
22377: LD_ADDR_VAR 0 1
22381: PUSH
22382: LD_INT 2
22384: PUSH
22385: LD_INT 3
22387: PUSH
22388: LD_INT 4
22390: PUSH
22391: LD_INT 5
22393: PUSH
22394: LD_INT 6
22396: PUSH
22397: LD_INT 7
22399: PUSH
22400: LD_INT 8
22402: PUSH
22403: LD_INT 9
22405: PUSH
22406: LD_INT 10
22408: PUSH
22409: LD_INT 11
22411: PUSH
22412: LD_INT 12
22414: PUSH
22415: LD_INT 13
22417: PUSH
22418: LD_INT 14
22420: PUSH
22421: LD_INT 15
22423: PUSH
22424: LD_INT 16
22426: PUSH
22427: LD_INT 17
22429: PUSH
22430: LD_INT 18
22432: PUSH
22433: LD_INT 19
22435: PUSH
22436: LD_INT 20
22438: PUSH
22439: LD_INT 21
22441: PUSH
22442: LD_INT 22
22444: PUSH
22445: LD_INT 23
22447: PUSH
22448: LD_INT 24
22450: PUSH
22451: LD_INT 25
22453: PUSH
22454: LD_INT 26
22456: PUSH
22457: LD_INT 28
22459: PUSH
22460: LD_INT 30
22462: PUSH
22463: LD_INT 31
22465: PUSH
22466: LD_INT 32
22468: PUSH
22469: LD_INT 34
22471: PUSH
22472: LD_INT 36
22474: PUSH
22475: EMPTY
22476: LIST
22477: LIST
22478: LIST
22479: LIST
22480: LIST
22481: LIST
22482: LIST
22483: LIST
22484: LIST
22485: LIST
22486: LIST
22487: LIST
22488: LIST
22489: LIST
22490: LIST
22491: LIST
22492: LIST
22493: LIST
22494: LIST
22495: LIST
22496: LIST
22497: LIST
22498: LIST
22499: LIST
22500: LIST
22501: LIST
22502: LIST
22503: LIST
22504: LIST
22505: LIST
22506: LIST
22507: PUSH
22508: LD_INT 101
22510: PUSH
22511: LD_INT 102
22513: PUSH
22514: LD_INT 103
22516: PUSH
22517: LD_INT 104
22519: PUSH
22520: LD_INT 105
22522: PUSH
22523: LD_INT 106
22525: PUSH
22526: LD_INT 107
22528: PUSH
22529: LD_INT 108
22531: PUSH
22532: LD_INT 109
22534: PUSH
22535: LD_INT 110
22537: PUSH
22538: LD_INT 111
22540: PUSH
22541: LD_INT 112
22543: PUSH
22544: LD_INT 114
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: LIST
22551: LIST
22552: LIST
22553: LIST
22554: LIST
22555: LIST
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: LIST
22561: PUSH
22562: EMPTY
22563: LIST
22564: LIST
22565: ST_TO_ADDR
22566: GO 24153
22568: LD_INT 12
22570: DOUBLE
22571: EQUAL
22572: IFTRUE 22576
22574: GO 22784
22576: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
22577: LD_ADDR_VAR 0 1
22581: PUSH
22582: LD_INT 1
22584: PUSH
22585: LD_INT 2
22587: PUSH
22588: LD_INT 3
22590: PUSH
22591: LD_INT 4
22593: PUSH
22594: LD_INT 5
22596: PUSH
22597: LD_INT 6
22599: PUSH
22600: LD_INT 7
22602: PUSH
22603: LD_INT 8
22605: PUSH
22606: LD_INT 9
22608: PUSH
22609: LD_INT 10
22611: PUSH
22612: LD_INT 11
22614: PUSH
22615: LD_INT 12
22617: PUSH
22618: LD_INT 13
22620: PUSH
22621: LD_INT 14
22623: PUSH
22624: LD_INT 15
22626: PUSH
22627: LD_INT 16
22629: PUSH
22630: LD_INT 17
22632: PUSH
22633: LD_INT 18
22635: PUSH
22636: LD_INT 19
22638: PUSH
22639: LD_INT 20
22641: PUSH
22642: LD_INT 21
22644: PUSH
22645: LD_INT 22
22647: PUSH
22648: LD_INT 23
22650: PUSH
22651: LD_INT 24
22653: PUSH
22654: LD_INT 25
22656: PUSH
22657: LD_INT 26
22659: PUSH
22660: LD_INT 27
22662: PUSH
22663: LD_INT 28
22665: PUSH
22666: LD_INT 30
22668: PUSH
22669: LD_INT 31
22671: PUSH
22672: LD_INT 32
22674: PUSH
22675: LD_INT 33
22677: PUSH
22678: LD_INT 34
22680: PUSH
22681: LD_INT 36
22683: PUSH
22684: EMPTY
22685: LIST
22686: LIST
22687: LIST
22688: LIST
22689: LIST
22690: LIST
22691: LIST
22692: LIST
22693: LIST
22694: LIST
22695: LIST
22696: LIST
22697: LIST
22698: LIST
22699: LIST
22700: LIST
22701: LIST
22702: LIST
22703: LIST
22704: LIST
22705: LIST
22706: LIST
22707: LIST
22708: LIST
22709: LIST
22710: LIST
22711: LIST
22712: LIST
22713: LIST
22714: LIST
22715: LIST
22716: LIST
22717: LIST
22718: LIST
22719: PUSH
22720: LD_INT 101
22722: PUSH
22723: LD_INT 102
22725: PUSH
22726: LD_INT 103
22728: PUSH
22729: LD_INT 104
22731: PUSH
22732: LD_INT 105
22734: PUSH
22735: LD_INT 106
22737: PUSH
22738: LD_INT 107
22740: PUSH
22741: LD_INT 108
22743: PUSH
22744: LD_INT 109
22746: PUSH
22747: LD_INT 110
22749: PUSH
22750: LD_INT 111
22752: PUSH
22753: LD_INT 112
22755: PUSH
22756: LD_INT 113
22758: PUSH
22759: LD_INT 114
22761: PUSH
22762: EMPTY
22763: LIST
22764: LIST
22765: LIST
22766: LIST
22767: LIST
22768: LIST
22769: LIST
22770: LIST
22771: LIST
22772: LIST
22773: LIST
22774: LIST
22775: LIST
22776: LIST
22777: PUSH
22778: EMPTY
22779: LIST
22780: LIST
22781: ST_TO_ADDR
22782: GO 24153
22784: LD_INT 13
22786: DOUBLE
22787: EQUAL
22788: IFTRUE 22792
22790: GO 22988
22792: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
22793: LD_ADDR_VAR 0 1
22797: PUSH
22798: LD_INT 1
22800: PUSH
22801: LD_INT 2
22803: PUSH
22804: LD_INT 3
22806: PUSH
22807: LD_INT 4
22809: PUSH
22810: LD_INT 5
22812: PUSH
22813: LD_INT 8
22815: PUSH
22816: LD_INT 9
22818: PUSH
22819: LD_INT 10
22821: PUSH
22822: LD_INT 11
22824: PUSH
22825: LD_INT 12
22827: PUSH
22828: LD_INT 14
22830: PUSH
22831: LD_INT 15
22833: PUSH
22834: LD_INT 16
22836: PUSH
22837: LD_INT 17
22839: PUSH
22840: LD_INT 18
22842: PUSH
22843: LD_INT 19
22845: PUSH
22846: LD_INT 20
22848: PUSH
22849: LD_INT 21
22851: PUSH
22852: LD_INT 22
22854: PUSH
22855: LD_INT 23
22857: PUSH
22858: LD_INT 24
22860: PUSH
22861: LD_INT 25
22863: PUSH
22864: LD_INT 26
22866: PUSH
22867: LD_INT 27
22869: PUSH
22870: LD_INT 28
22872: PUSH
22873: LD_INT 30
22875: PUSH
22876: LD_INT 31
22878: PUSH
22879: LD_INT 32
22881: PUSH
22882: LD_INT 33
22884: PUSH
22885: LD_INT 34
22887: PUSH
22888: LD_INT 36
22890: PUSH
22891: EMPTY
22892: LIST
22893: LIST
22894: LIST
22895: LIST
22896: LIST
22897: LIST
22898: LIST
22899: LIST
22900: LIST
22901: LIST
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: LIST
22907: LIST
22908: LIST
22909: LIST
22910: LIST
22911: LIST
22912: LIST
22913: LIST
22914: LIST
22915: LIST
22916: LIST
22917: LIST
22918: LIST
22919: LIST
22920: LIST
22921: LIST
22922: LIST
22923: PUSH
22924: LD_INT 101
22926: PUSH
22927: LD_INT 102
22929: PUSH
22930: LD_INT 103
22932: PUSH
22933: LD_INT 104
22935: PUSH
22936: LD_INT 105
22938: PUSH
22939: LD_INT 106
22941: PUSH
22942: LD_INT 107
22944: PUSH
22945: LD_INT 108
22947: PUSH
22948: LD_INT 109
22950: PUSH
22951: LD_INT 110
22953: PUSH
22954: LD_INT 111
22956: PUSH
22957: LD_INT 112
22959: PUSH
22960: LD_INT 113
22962: PUSH
22963: LD_INT 114
22965: PUSH
22966: EMPTY
22967: LIST
22968: LIST
22969: LIST
22970: LIST
22971: LIST
22972: LIST
22973: LIST
22974: LIST
22975: LIST
22976: LIST
22977: LIST
22978: LIST
22979: LIST
22980: LIST
22981: PUSH
22982: EMPTY
22983: LIST
22984: LIST
22985: ST_TO_ADDR
22986: GO 24153
22988: LD_INT 14
22990: DOUBLE
22991: EQUAL
22992: IFTRUE 22996
22994: GO 23208
22996: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
22997: LD_ADDR_VAR 0 1
23001: PUSH
23002: LD_INT 1
23004: PUSH
23005: LD_INT 2
23007: PUSH
23008: LD_INT 3
23010: PUSH
23011: LD_INT 4
23013: PUSH
23014: LD_INT 5
23016: PUSH
23017: LD_INT 6
23019: PUSH
23020: LD_INT 7
23022: PUSH
23023: LD_INT 8
23025: PUSH
23026: LD_INT 9
23028: PUSH
23029: LD_INT 10
23031: PUSH
23032: LD_INT 11
23034: PUSH
23035: LD_INT 12
23037: PUSH
23038: LD_INT 13
23040: PUSH
23041: LD_INT 14
23043: PUSH
23044: LD_INT 15
23046: PUSH
23047: LD_INT 16
23049: PUSH
23050: LD_INT 17
23052: PUSH
23053: LD_INT 18
23055: PUSH
23056: LD_INT 19
23058: PUSH
23059: LD_INT 20
23061: PUSH
23062: LD_INT 21
23064: PUSH
23065: LD_INT 22
23067: PUSH
23068: LD_INT 23
23070: PUSH
23071: LD_INT 24
23073: PUSH
23074: LD_INT 25
23076: PUSH
23077: LD_INT 26
23079: PUSH
23080: LD_INT 27
23082: PUSH
23083: LD_INT 28
23085: PUSH
23086: LD_INT 29
23088: PUSH
23089: LD_INT 30
23091: PUSH
23092: LD_INT 31
23094: PUSH
23095: LD_INT 32
23097: PUSH
23098: LD_INT 33
23100: PUSH
23101: LD_INT 34
23103: PUSH
23104: LD_INT 36
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: LIST
23111: LIST
23112: LIST
23113: LIST
23114: LIST
23115: LIST
23116: LIST
23117: LIST
23118: LIST
23119: LIST
23120: LIST
23121: LIST
23122: LIST
23123: LIST
23124: LIST
23125: LIST
23126: LIST
23127: LIST
23128: LIST
23129: LIST
23130: LIST
23131: LIST
23132: LIST
23133: LIST
23134: LIST
23135: LIST
23136: LIST
23137: LIST
23138: LIST
23139: LIST
23140: LIST
23141: LIST
23142: LIST
23143: PUSH
23144: LD_INT 101
23146: PUSH
23147: LD_INT 102
23149: PUSH
23150: LD_INT 103
23152: PUSH
23153: LD_INT 104
23155: PUSH
23156: LD_INT 105
23158: PUSH
23159: LD_INT 106
23161: PUSH
23162: LD_INT 107
23164: PUSH
23165: LD_INT 108
23167: PUSH
23168: LD_INT 109
23170: PUSH
23171: LD_INT 110
23173: PUSH
23174: LD_INT 111
23176: PUSH
23177: LD_INT 112
23179: PUSH
23180: LD_INT 113
23182: PUSH
23183: LD_INT 114
23185: PUSH
23186: EMPTY
23187: LIST
23188: LIST
23189: LIST
23190: LIST
23191: LIST
23192: LIST
23193: LIST
23194: LIST
23195: LIST
23196: LIST
23197: LIST
23198: LIST
23199: LIST
23200: LIST
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: ST_TO_ADDR
23206: GO 24153
23208: LD_INT 15
23210: DOUBLE
23211: EQUAL
23212: IFTRUE 23216
23214: GO 23428
23216: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
23217: LD_ADDR_VAR 0 1
23221: PUSH
23222: LD_INT 1
23224: PUSH
23225: LD_INT 2
23227: PUSH
23228: LD_INT 3
23230: PUSH
23231: LD_INT 4
23233: PUSH
23234: LD_INT 5
23236: PUSH
23237: LD_INT 6
23239: PUSH
23240: LD_INT 7
23242: PUSH
23243: LD_INT 8
23245: PUSH
23246: LD_INT 9
23248: PUSH
23249: LD_INT 10
23251: PUSH
23252: LD_INT 11
23254: PUSH
23255: LD_INT 12
23257: PUSH
23258: LD_INT 13
23260: PUSH
23261: LD_INT 14
23263: PUSH
23264: LD_INT 15
23266: PUSH
23267: LD_INT 16
23269: PUSH
23270: LD_INT 17
23272: PUSH
23273: LD_INT 18
23275: PUSH
23276: LD_INT 19
23278: PUSH
23279: LD_INT 20
23281: PUSH
23282: LD_INT 21
23284: PUSH
23285: LD_INT 22
23287: PUSH
23288: LD_INT 23
23290: PUSH
23291: LD_INT 24
23293: PUSH
23294: LD_INT 25
23296: PUSH
23297: LD_INT 26
23299: PUSH
23300: LD_INT 27
23302: PUSH
23303: LD_INT 28
23305: PUSH
23306: LD_INT 29
23308: PUSH
23309: LD_INT 30
23311: PUSH
23312: LD_INT 31
23314: PUSH
23315: LD_INT 32
23317: PUSH
23318: LD_INT 33
23320: PUSH
23321: LD_INT 34
23323: PUSH
23324: LD_INT 36
23326: PUSH
23327: EMPTY
23328: LIST
23329: LIST
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: LIST
23337: LIST
23338: LIST
23339: LIST
23340: LIST
23341: LIST
23342: LIST
23343: LIST
23344: LIST
23345: LIST
23346: LIST
23347: LIST
23348: LIST
23349: LIST
23350: LIST
23351: LIST
23352: LIST
23353: LIST
23354: LIST
23355: LIST
23356: LIST
23357: LIST
23358: LIST
23359: LIST
23360: LIST
23361: LIST
23362: LIST
23363: PUSH
23364: LD_INT 101
23366: PUSH
23367: LD_INT 102
23369: PUSH
23370: LD_INT 103
23372: PUSH
23373: LD_INT 104
23375: PUSH
23376: LD_INT 105
23378: PUSH
23379: LD_INT 106
23381: PUSH
23382: LD_INT 107
23384: PUSH
23385: LD_INT 108
23387: PUSH
23388: LD_INT 109
23390: PUSH
23391: LD_INT 110
23393: PUSH
23394: LD_INT 111
23396: PUSH
23397: LD_INT 112
23399: PUSH
23400: LD_INT 113
23402: PUSH
23403: LD_INT 114
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: LIST
23415: LIST
23416: LIST
23417: LIST
23418: LIST
23419: LIST
23420: LIST
23421: PUSH
23422: EMPTY
23423: LIST
23424: LIST
23425: ST_TO_ADDR
23426: GO 24153
23428: LD_INT 16
23430: DOUBLE
23431: EQUAL
23432: IFTRUE 23436
23434: GO 23560
23436: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
23437: LD_ADDR_VAR 0 1
23441: PUSH
23442: LD_INT 2
23444: PUSH
23445: LD_INT 4
23447: PUSH
23448: LD_INT 5
23450: PUSH
23451: LD_INT 7
23453: PUSH
23454: LD_INT 11
23456: PUSH
23457: LD_INT 12
23459: PUSH
23460: LD_INT 15
23462: PUSH
23463: LD_INT 16
23465: PUSH
23466: LD_INT 20
23468: PUSH
23469: LD_INT 21
23471: PUSH
23472: LD_INT 22
23474: PUSH
23475: LD_INT 23
23477: PUSH
23478: LD_INT 25
23480: PUSH
23481: LD_INT 26
23483: PUSH
23484: LD_INT 30
23486: PUSH
23487: LD_INT 31
23489: PUSH
23490: LD_INT 32
23492: PUSH
23493: LD_INT 33
23495: PUSH
23496: LD_INT 34
23498: PUSH
23499: EMPTY
23500: LIST
23501: LIST
23502: LIST
23503: LIST
23504: LIST
23505: LIST
23506: LIST
23507: LIST
23508: LIST
23509: LIST
23510: LIST
23511: LIST
23512: LIST
23513: LIST
23514: LIST
23515: LIST
23516: LIST
23517: LIST
23518: LIST
23519: PUSH
23520: LD_INT 101
23522: PUSH
23523: LD_INT 102
23525: PUSH
23526: LD_INT 103
23528: PUSH
23529: LD_INT 106
23531: PUSH
23532: LD_INT 108
23534: PUSH
23535: LD_INT 112
23537: PUSH
23538: LD_INT 113
23540: PUSH
23541: LD_INT 114
23543: PUSH
23544: EMPTY
23545: LIST
23546: LIST
23547: LIST
23548: LIST
23549: LIST
23550: LIST
23551: LIST
23552: LIST
23553: PUSH
23554: EMPTY
23555: LIST
23556: LIST
23557: ST_TO_ADDR
23558: GO 24153
23560: LD_INT 17
23562: DOUBLE
23563: EQUAL
23564: IFTRUE 23568
23566: GO 23780
23568: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
23569: LD_ADDR_VAR 0 1
23573: PUSH
23574: LD_INT 1
23576: PUSH
23577: LD_INT 2
23579: PUSH
23580: LD_INT 3
23582: PUSH
23583: LD_INT 4
23585: PUSH
23586: LD_INT 5
23588: PUSH
23589: LD_INT 6
23591: PUSH
23592: LD_INT 7
23594: PUSH
23595: LD_INT 8
23597: PUSH
23598: LD_INT 9
23600: PUSH
23601: LD_INT 10
23603: PUSH
23604: LD_INT 11
23606: PUSH
23607: LD_INT 12
23609: PUSH
23610: LD_INT 13
23612: PUSH
23613: LD_INT 14
23615: PUSH
23616: LD_INT 15
23618: PUSH
23619: LD_INT 16
23621: PUSH
23622: LD_INT 17
23624: PUSH
23625: LD_INT 18
23627: PUSH
23628: LD_INT 19
23630: PUSH
23631: LD_INT 20
23633: PUSH
23634: LD_INT 21
23636: PUSH
23637: LD_INT 22
23639: PUSH
23640: LD_INT 23
23642: PUSH
23643: LD_INT 24
23645: PUSH
23646: LD_INT 25
23648: PUSH
23649: LD_INT 26
23651: PUSH
23652: LD_INT 27
23654: PUSH
23655: LD_INT 28
23657: PUSH
23658: LD_INT 29
23660: PUSH
23661: LD_INT 30
23663: PUSH
23664: LD_INT 31
23666: PUSH
23667: LD_INT 32
23669: PUSH
23670: LD_INT 33
23672: PUSH
23673: LD_INT 34
23675: PUSH
23676: LD_INT 36
23678: PUSH
23679: EMPTY
23680: LIST
23681: LIST
23682: LIST
23683: LIST
23684: LIST
23685: LIST
23686: LIST
23687: LIST
23688: LIST
23689: LIST
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: LIST
23695: LIST
23696: LIST
23697: LIST
23698: LIST
23699: LIST
23700: LIST
23701: LIST
23702: LIST
23703: LIST
23704: LIST
23705: LIST
23706: LIST
23707: LIST
23708: LIST
23709: LIST
23710: LIST
23711: LIST
23712: LIST
23713: LIST
23714: LIST
23715: PUSH
23716: LD_INT 101
23718: PUSH
23719: LD_INT 102
23721: PUSH
23722: LD_INT 103
23724: PUSH
23725: LD_INT 104
23727: PUSH
23728: LD_INT 105
23730: PUSH
23731: LD_INT 106
23733: PUSH
23734: LD_INT 107
23736: PUSH
23737: LD_INT 108
23739: PUSH
23740: LD_INT 109
23742: PUSH
23743: LD_INT 110
23745: PUSH
23746: LD_INT 111
23748: PUSH
23749: LD_INT 112
23751: PUSH
23752: LD_INT 113
23754: PUSH
23755: LD_INT 114
23757: PUSH
23758: EMPTY
23759: LIST
23760: LIST
23761: LIST
23762: LIST
23763: LIST
23764: LIST
23765: LIST
23766: LIST
23767: LIST
23768: LIST
23769: LIST
23770: LIST
23771: LIST
23772: LIST
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: ST_TO_ADDR
23778: GO 24153
23780: LD_INT 18
23782: DOUBLE
23783: EQUAL
23784: IFTRUE 23788
23786: GO 23924
23788: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
23789: LD_ADDR_VAR 0 1
23793: PUSH
23794: LD_INT 2
23796: PUSH
23797: LD_INT 4
23799: PUSH
23800: LD_INT 5
23802: PUSH
23803: LD_INT 7
23805: PUSH
23806: LD_INT 11
23808: PUSH
23809: LD_INT 12
23811: PUSH
23812: LD_INT 15
23814: PUSH
23815: LD_INT 16
23817: PUSH
23818: LD_INT 20
23820: PUSH
23821: LD_INT 21
23823: PUSH
23824: LD_INT 22
23826: PUSH
23827: LD_INT 23
23829: PUSH
23830: LD_INT 25
23832: PUSH
23833: LD_INT 26
23835: PUSH
23836: LD_INT 30
23838: PUSH
23839: LD_INT 31
23841: PUSH
23842: LD_INT 32
23844: PUSH
23845: LD_INT 33
23847: PUSH
23848: LD_INT 34
23850: PUSH
23851: LD_INT 35
23853: PUSH
23854: LD_INT 36
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: LIST
23861: LIST
23862: LIST
23863: LIST
23864: LIST
23865: LIST
23866: LIST
23867: LIST
23868: LIST
23869: LIST
23870: LIST
23871: LIST
23872: LIST
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: LIST
23878: LIST
23879: PUSH
23880: LD_INT 101
23882: PUSH
23883: LD_INT 102
23885: PUSH
23886: LD_INT 103
23888: PUSH
23889: LD_INT 106
23891: PUSH
23892: LD_INT 108
23894: PUSH
23895: LD_INT 112
23897: PUSH
23898: LD_INT 113
23900: PUSH
23901: LD_INT 114
23903: PUSH
23904: LD_INT 115
23906: PUSH
23907: EMPTY
23908: LIST
23909: LIST
23910: LIST
23911: LIST
23912: LIST
23913: LIST
23914: LIST
23915: LIST
23916: LIST
23917: PUSH
23918: EMPTY
23919: LIST
23920: LIST
23921: ST_TO_ADDR
23922: GO 24153
23924: LD_INT 19
23926: DOUBLE
23927: EQUAL
23928: IFTRUE 23932
23930: GO 24152
23932: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
23933: LD_ADDR_VAR 0 1
23937: PUSH
23938: LD_INT 1
23940: PUSH
23941: LD_INT 2
23943: PUSH
23944: LD_INT 3
23946: PUSH
23947: LD_INT 4
23949: PUSH
23950: LD_INT 5
23952: PUSH
23953: LD_INT 6
23955: PUSH
23956: LD_INT 7
23958: PUSH
23959: LD_INT 8
23961: PUSH
23962: LD_INT 9
23964: PUSH
23965: LD_INT 10
23967: PUSH
23968: LD_INT 11
23970: PUSH
23971: LD_INT 12
23973: PUSH
23974: LD_INT 13
23976: PUSH
23977: LD_INT 14
23979: PUSH
23980: LD_INT 15
23982: PUSH
23983: LD_INT 16
23985: PUSH
23986: LD_INT 17
23988: PUSH
23989: LD_INT 18
23991: PUSH
23992: LD_INT 19
23994: PUSH
23995: LD_INT 20
23997: PUSH
23998: LD_INT 21
24000: PUSH
24001: LD_INT 22
24003: PUSH
24004: LD_INT 23
24006: PUSH
24007: LD_INT 24
24009: PUSH
24010: LD_INT 25
24012: PUSH
24013: LD_INT 26
24015: PUSH
24016: LD_INT 27
24018: PUSH
24019: LD_INT 28
24021: PUSH
24022: LD_INT 29
24024: PUSH
24025: LD_INT 30
24027: PUSH
24028: LD_INT 31
24030: PUSH
24031: LD_INT 32
24033: PUSH
24034: LD_INT 33
24036: PUSH
24037: LD_INT 34
24039: PUSH
24040: LD_INT 35
24042: PUSH
24043: LD_INT 36
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: LIST
24050: LIST
24051: LIST
24052: LIST
24053: LIST
24054: LIST
24055: LIST
24056: LIST
24057: LIST
24058: LIST
24059: LIST
24060: LIST
24061: LIST
24062: LIST
24063: LIST
24064: LIST
24065: LIST
24066: LIST
24067: LIST
24068: LIST
24069: LIST
24070: LIST
24071: LIST
24072: LIST
24073: LIST
24074: LIST
24075: LIST
24076: LIST
24077: LIST
24078: LIST
24079: LIST
24080: LIST
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 101
24086: PUSH
24087: LD_INT 102
24089: PUSH
24090: LD_INT 103
24092: PUSH
24093: LD_INT 104
24095: PUSH
24096: LD_INT 105
24098: PUSH
24099: LD_INT 106
24101: PUSH
24102: LD_INT 107
24104: PUSH
24105: LD_INT 108
24107: PUSH
24108: LD_INT 109
24110: PUSH
24111: LD_INT 110
24113: PUSH
24114: LD_INT 111
24116: PUSH
24117: LD_INT 112
24119: PUSH
24120: LD_INT 113
24122: PUSH
24123: LD_INT 114
24125: PUSH
24126: LD_INT 115
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: LIST
24137: LIST
24138: LIST
24139: LIST
24140: LIST
24141: LIST
24142: LIST
24143: LIST
24144: LIST
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: ST_TO_ADDR
24150: GO 24153
24152: POP
// end else
24153: GO 24372
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
24155: LD_ADDR_VAR 0 1
24159: PUSH
24160: LD_INT 1
24162: PUSH
24163: LD_INT 2
24165: PUSH
24166: LD_INT 3
24168: PUSH
24169: LD_INT 4
24171: PUSH
24172: LD_INT 5
24174: PUSH
24175: LD_INT 6
24177: PUSH
24178: LD_INT 7
24180: PUSH
24181: LD_INT 8
24183: PUSH
24184: LD_INT 9
24186: PUSH
24187: LD_INT 10
24189: PUSH
24190: LD_INT 11
24192: PUSH
24193: LD_INT 12
24195: PUSH
24196: LD_INT 13
24198: PUSH
24199: LD_INT 14
24201: PUSH
24202: LD_INT 15
24204: PUSH
24205: LD_INT 16
24207: PUSH
24208: LD_INT 17
24210: PUSH
24211: LD_INT 18
24213: PUSH
24214: LD_INT 19
24216: PUSH
24217: LD_INT 20
24219: PUSH
24220: LD_INT 21
24222: PUSH
24223: LD_INT 22
24225: PUSH
24226: LD_INT 23
24228: PUSH
24229: LD_INT 24
24231: PUSH
24232: LD_INT 25
24234: PUSH
24235: LD_INT 26
24237: PUSH
24238: LD_INT 27
24240: PUSH
24241: LD_INT 28
24243: PUSH
24244: LD_INT 29
24246: PUSH
24247: LD_INT 30
24249: PUSH
24250: LD_INT 31
24252: PUSH
24253: LD_INT 32
24255: PUSH
24256: LD_INT 33
24258: PUSH
24259: LD_INT 34
24261: PUSH
24262: LD_INT 35
24264: PUSH
24265: LD_INT 36
24267: PUSH
24268: EMPTY
24269: LIST
24270: LIST
24271: LIST
24272: LIST
24273: LIST
24274: LIST
24275: LIST
24276: LIST
24277: LIST
24278: LIST
24279: LIST
24280: LIST
24281: LIST
24282: LIST
24283: LIST
24284: LIST
24285: LIST
24286: LIST
24287: LIST
24288: LIST
24289: LIST
24290: LIST
24291: LIST
24292: LIST
24293: LIST
24294: LIST
24295: LIST
24296: LIST
24297: LIST
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: LIST
24303: LIST
24304: LIST
24305: PUSH
24306: LD_INT 101
24308: PUSH
24309: LD_INT 102
24311: PUSH
24312: LD_INT 103
24314: PUSH
24315: LD_INT 104
24317: PUSH
24318: LD_INT 105
24320: PUSH
24321: LD_INT 106
24323: PUSH
24324: LD_INT 107
24326: PUSH
24327: LD_INT 108
24329: PUSH
24330: LD_INT 109
24332: PUSH
24333: LD_INT 110
24335: PUSH
24336: LD_INT 111
24338: PUSH
24339: LD_INT 112
24341: PUSH
24342: LD_INT 113
24344: PUSH
24345: LD_INT 114
24347: PUSH
24348: LD_INT 115
24350: PUSH
24351: EMPTY
24352: LIST
24353: LIST
24354: LIST
24355: LIST
24356: LIST
24357: LIST
24358: LIST
24359: LIST
24360: LIST
24361: LIST
24362: LIST
24363: LIST
24364: LIST
24365: LIST
24366: LIST
24367: PUSH
24368: EMPTY
24369: LIST
24370: LIST
24371: ST_TO_ADDR
// if result then
24372: LD_VAR 0 1
24376: IFFALSE 24665
// begin normal :=  ;
24378: LD_ADDR_VAR 0 3
24382: PUSH
24383: LD_STRING 
24385: ST_TO_ADDR
// hardcore :=  ;
24386: LD_ADDR_VAR 0 4
24390: PUSH
24391: LD_STRING 
24393: ST_TO_ADDR
// for i = 1 to normalCounter do
24394: LD_ADDR_VAR 0 5
24398: PUSH
24399: DOUBLE
24400: LD_INT 1
24402: DEC
24403: ST_TO_ADDR
24404: LD_EXP 64
24408: PUSH
24409: FOR_TO
24410: IFFALSE 24511
// begin tmp := 0 ;
24412: LD_ADDR_VAR 0 2
24416: PUSH
24417: LD_STRING 0
24419: ST_TO_ADDR
// if result [ 1 ] then
24420: LD_VAR 0 1
24424: PUSH
24425: LD_INT 1
24427: ARRAY
24428: IFFALSE 24493
// if result [ 1 ] [ 1 ] = i then
24430: LD_VAR 0 1
24434: PUSH
24435: LD_INT 1
24437: ARRAY
24438: PUSH
24439: LD_INT 1
24441: ARRAY
24442: PUSH
24443: LD_VAR 0 5
24447: EQUAL
24448: IFFALSE 24493
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
24450: LD_ADDR_VAR 0 1
24454: PUSH
24455: LD_VAR 0 1
24459: PPUSH
24460: LD_INT 1
24462: PPUSH
24463: LD_VAR 0 1
24467: PUSH
24468: LD_INT 1
24470: ARRAY
24471: PPUSH
24472: LD_INT 1
24474: PPUSH
24475: CALL_OW 3
24479: PPUSH
24480: CALL_OW 1
24484: ST_TO_ADDR
// tmp := 1 ;
24485: LD_ADDR_VAR 0 2
24489: PUSH
24490: LD_STRING 1
24492: ST_TO_ADDR
// end ; normal := normal & tmp ;
24493: LD_ADDR_VAR 0 3
24497: PUSH
24498: LD_VAR 0 3
24502: PUSH
24503: LD_VAR 0 2
24507: STR
24508: ST_TO_ADDR
// end ;
24509: GO 24409
24511: POP
24512: POP
// for i = 1 to hardcoreCounter do
24513: LD_ADDR_VAR 0 5
24517: PUSH
24518: DOUBLE
24519: LD_INT 1
24521: DEC
24522: ST_TO_ADDR
24523: LD_EXP 65
24527: PUSH
24528: FOR_TO
24529: IFFALSE 24634
// begin tmp := 0 ;
24531: LD_ADDR_VAR 0 2
24535: PUSH
24536: LD_STRING 0
24538: ST_TO_ADDR
// if result [ 2 ] then
24539: LD_VAR 0 1
24543: PUSH
24544: LD_INT 2
24546: ARRAY
24547: IFFALSE 24616
// if result [ 2 ] [ 1 ] = 100 + i then
24549: LD_VAR 0 1
24553: PUSH
24554: LD_INT 2
24556: ARRAY
24557: PUSH
24558: LD_INT 1
24560: ARRAY
24561: PUSH
24562: LD_INT 100
24564: PUSH
24565: LD_VAR 0 5
24569: PLUS
24570: EQUAL
24571: IFFALSE 24616
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
24573: LD_ADDR_VAR 0 1
24577: PUSH
24578: LD_VAR 0 1
24582: PPUSH
24583: LD_INT 2
24585: PPUSH
24586: LD_VAR 0 1
24590: PUSH
24591: LD_INT 2
24593: ARRAY
24594: PPUSH
24595: LD_INT 1
24597: PPUSH
24598: CALL_OW 3
24602: PPUSH
24603: CALL_OW 1
24607: ST_TO_ADDR
// tmp := 1 ;
24608: LD_ADDR_VAR 0 2
24612: PUSH
24613: LD_STRING 1
24615: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
24616: LD_ADDR_VAR 0 4
24620: PUSH
24621: LD_VAR 0 4
24625: PUSH
24626: LD_VAR 0 2
24630: STR
24631: ST_TO_ADDR
// end ;
24632: GO 24528
24634: POP
24635: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
24636: LD_STRING getStreamItemsFromMission("
24638: PUSH
24639: LD_VAR 0 3
24643: STR
24644: PUSH
24645: LD_STRING ","
24647: STR
24648: PUSH
24649: LD_VAR 0 4
24653: STR
24654: PUSH
24655: LD_STRING ")
24657: STR
24658: PPUSH
24659: CALL_OW 559
// end else
24663: GO 24672
// ToLua ( getStreamItemsFromMission("","") ) ;
24665: LD_STRING getStreamItemsFromMission("","")
24667: PPUSH
24668: CALL_OW 559
// end ;
24672: LD_VAR 0 1
24676: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
24677: LD_EXP 63
24681: PUSH
24682: LD_EXP 68
24686: AND
24687: IFFALSE 24811
24689: GO 24691
24691: DISABLE
24692: LD_INT 0
24694: PPUSH
24695: PPUSH
// begin enable ;
24696: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
24697: LD_ADDR_VAR 0 2
24701: PUSH
24702: LD_INT 22
24704: PUSH
24705: LD_OWVAR 2
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: PUSH
24714: LD_INT 2
24716: PUSH
24717: LD_INT 34
24719: PUSH
24720: LD_INT 7
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PUSH
24727: LD_INT 34
24729: PUSH
24730: LD_INT 45
24732: PUSH
24733: EMPTY
24734: LIST
24735: LIST
24736: PUSH
24737: LD_INT 34
24739: PUSH
24740: LD_INT 28
24742: PUSH
24743: EMPTY
24744: LIST
24745: LIST
24746: PUSH
24747: LD_INT 34
24749: PUSH
24750: LD_INT 47
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: LIST
24761: LIST
24762: LIST
24763: PUSH
24764: EMPTY
24765: LIST
24766: LIST
24767: PPUSH
24768: CALL_OW 69
24772: ST_TO_ADDR
// if not tmp then
24773: LD_VAR 0 2
24777: NOT
24778: IFFALSE 24782
// exit ;
24780: GO 24811
// for i in tmp do
24782: LD_ADDR_VAR 0 1
24786: PUSH
24787: LD_VAR 0 2
24791: PUSH
24792: FOR_IN
24793: IFFALSE 24809
// begin SetLives ( i , 0 ) ;
24795: LD_VAR 0 1
24799: PPUSH
24800: LD_INT 0
24802: PPUSH
24803: CALL_OW 234
// end ;
24807: GO 24792
24809: POP
24810: POP
// end ;
24811: PPOPN 2
24813: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
24814: LD_EXP 63
24818: PUSH
24819: LD_EXP 69
24823: AND
24824: IFFALSE 24908
24826: GO 24828
24828: DISABLE
24829: LD_INT 0
24831: PPUSH
24832: PPUSH
// begin enable ;
24833: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
24834: LD_ADDR_VAR 0 2
24838: PUSH
24839: LD_INT 22
24841: PUSH
24842: LD_OWVAR 2
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: LD_INT 32
24853: PUSH
24854: LD_INT 3
24856: PUSH
24857: EMPTY
24858: LIST
24859: LIST
24860: PUSH
24861: EMPTY
24862: LIST
24863: LIST
24864: PPUSH
24865: CALL_OW 69
24869: ST_TO_ADDR
// if not tmp then
24870: LD_VAR 0 2
24874: NOT
24875: IFFALSE 24879
// exit ;
24877: GO 24908
// for i in tmp do
24879: LD_ADDR_VAR 0 1
24883: PUSH
24884: LD_VAR 0 2
24888: PUSH
24889: FOR_IN
24890: IFFALSE 24906
// begin SetLives ( i , 0 ) ;
24892: LD_VAR 0 1
24896: PPUSH
24897: LD_INT 0
24899: PPUSH
24900: CALL_OW 234
// end ;
24904: GO 24889
24906: POP
24907: POP
// end ;
24908: PPOPN 2
24910: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
24911: LD_EXP 63
24915: PUSH
24916: LD_EXP 66
24920: AND
24921: IFFALSE 25014
24923: GO 24925
24925: DISABLE
24926: LD_INT 0
24928: PPUSH
// begin enable ;
24929: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
24930: LD_ADDR_VAR 0 1
24934: PUSH
24935: LD_INT 22
24937: PUSH
24938: LD_OWVAR 2
24942: PUSH
24943: EMPTY
24944: LIST
24945: LIST
24946: PUSH
24947: LD_INT 2
24949: PUSH
24950: LD_INT 25
24952: PUSH
24953: LD_INT 5
24955: PUSH
24956: EMPTY
24957: LIST
24958: LIST
24959: PUSH
24960: LD_INT 25
24962: PUSH
24963: LD_INT 9
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 25
24972: PUSH
24973: LD_INT 8
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: EMPTY
24981: LIST
24982: LIST
24983: LIST
24984: LIST
24985: PUSH
24986: EMPTY
24987: LIST
24988: LIST
24989: PPUSH
24990: CALL_OW 69
24994: PUSH
24995: FOR_IN
24996: IFFALSE 25012
// begin SetClass ( i , 1 ) ;
24998: LD_VAR 0 1
25002: PPUSH
25003: LD_INT 1
25005: PPUSH
25006: CALL_OW 336
// end ;
25010: GO 24995
25012: POP
25013: POP
// end ;
25014: PPOPN 1
25016: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
25017: LD_EXP 63
25021: PUSH
25022: LD_EXP 67
25026: AND
25027: PUSH
25028: LD_OWVAR 65
25032: PUSH
25033: LD_INT 7
25035: LESS
25036: AND
25037: IFFALSE 25051
25039: GO 25041
25041: DISABLE
// begin enable ;
25042: ENABLE
// game_speed := 7 ;
25043: LD_ADDR_OWVAR 65
25047: PUSH
25048: LD_INT 7
25050: ST_TO_ADDR
// end ;
25051: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
25052: LD_EXP 63
25056: PUSH
25057: LD_EXP 70
25061: AND
25062: IFFALSE 25264
25064: GO 25066
25066: DISABLE
25067: LD_INT 0
25069: PPUSH
25070: PPUSH
25071: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
25072: LD_ADDR_VAR 0 3
25076: PUSH
25077: LD_INT 81
25079: PUSH
25080: LD_OWVAR 2
25084: PUSH
25085: EMPTY
25086: LIST
25087: LIST
25088: PUSH
25089: LD_INT 21
25091: PUSH
25092: LD_INT 1
25094: PUSH
25095: EMPTY
25096: LIST
25097: LIST
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PPUSH
25103: CALL_OW 69
25107: ST_TO_ADDR
// if not tmp then
25108: LD_VAR 0 3
25112: NOT
25113: IFFALSE 25117
// exit ;
25115: GO 25264
// if tmp > 5 then
25117: LD_VAR 0 3
25121: PUSH
25122: LD_INT 5
25124: GREATER
25125: IFFALSE 25137
// k := 5 else
25127: LD_ADDR_VAR 0 2
25131: PUSH
25132: LD_INT 5
25134: ST_TO_ADDR
25135: GO 25147
// k := tmp ;
25137: LD_ADDR_VAR 0 2
25141: PUSH
25142: LD_VAR 0 3
25146: ST_TO_ADDR
// for i := 1 to k do
25147: LD_ADDR_VAR 0 1
25151: PUSH
25152: DOUBLE
25153: LD_INT 1
25155: DEC
25156: ST_TO_ADDR
25157: LD_VAR 0 2
25161: PUSH
25162: FOR_TO
25163: IFFALSE 25262
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
25165: LD_VAR 0 3
25169: PUSH
25170: LD_VAR 0 1
25174: ARRAY
25175: PPUSH
25176: LD_VAR 0 1
25180: PUSH
25181: LD_INT 4
25183: MOD
25184: PUSH
25185: LD_INT 1
25187: PLUS
25188: PPUSH
25189: CALL_OW 259
25193: PUSH
25194: LD_INT 10
25196: LESS
25197: IFFALSE 25260
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
25199: LD_VAR 0 3
25203: PUSH
25204: LD_VAR 0 1
25208: ARRAY
25209: PPUSH
25210: LD_VAR 0 1
25214: PUSH
25215: LD_INT 4
25217: MOD
25218: PUSH
25219: LD_INT 1
25221: PLUS
25222: PPUSH
25223: LD_VAR 0 3
25227: PUSH
25228: LD_VAR 0 1
25232: ARRAY
25233: PPUSH
25234: LD_VAR 0 1
25238: PUSH
25239: LD_INT 4
25241: MOD
25242: PUSH
25243: LD_INT 1
25245: PLUS
25246: PPUSH
25247: CALL_OW 259
25251: PUSH
25252: LD_INT 1
25254: PLUS
25255: PPUSH
25256: CALL_OW 237
25260: GO 25162
25262: POP
25263: POP
// end ;
25264: PPOPN 3
25266: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
25267: LD_EXP 63
25271: PUSH
25272: LD_EXP 71
25276: AND
25277: IFFALSE 25297
25279: GO 25281
25281: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
25282: LD_INT 4
25284: PPUSH
25285: LD_OWVAR 2
25289: PPUSH
25290: LD_INT 0
25292: PPUSH
25293: CALL_OW 324
25297: END
// every 0 0$1 trigger StreamModeActive and sShovel do
25298: LD_EXP 63
25302: PUSH
25303: LD_EXP 100
25307: AND
25308: IFFALSE 25328
25310: GO 25312
25312: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
25313: LD_INT 19
25315: PPUSH
25316: LD_OWVAR 2
25320: PPUSH
25321: LD_INT 0
25323: PPUSH
25324: CALL_OW 324
25328: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
25329: LD_EXP 63
25333: PUSH
25334: LD_EXP 72
25338: AND
25339: IFFALSE 25441
25341: GO 25343
25343: DISABLE
25344: LD_INT 0
25346: PPUSH
25347: PPUSH
// begin enable ;
25348: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
25349: LD_ADDR_VAR 0 2
25353: PUSH
25354: LD_INT 22
25356: PUSH
25357: LD_OWVAR 2
25361: PUSH
25362: EMPTY
25363: LIST
25364: LIST
25365: PUSH
25366: LD_INT 2
25368: PUSH
25369: LD_INT 34
25371: PUSH
25372: LD_INT 11
25374: PUSH
25375: EMPTY
25376: LIST
25377: LIST
25378: PUSH
25379: LD_INT 34
25381: PUSH
25382: LD_INT 30
25384: PUSH
25385: EMPTY
25386: LIST
25387: LIST
25388: PUSH
25389: EMPTY
25390: LIST
25391: LIST
25392: LIST
25393: PUSH
25394: EMPTY
25395: LIST
25396: LIST
25397: PPUSH
25398: CALL_OW 69
25402: ST_TO_ADDR
// if not tmp then
25403: LD_VAR 0 2
25407: NOT
25408: IFFALSE 25412
// exit ;
25410: GO 25441
// for i in tmp do
25412: LD_ADDR_VAR 0 1
25416: PUSH
25417: LD_VAR 0 2
25421: PUSH
25422: FOR_IN
25423: IFFALSE 25439
// begin SetLives ( i , 0 ) ;
25425: LD_VAR 0 1
25429: PPUSH
25430: LD_INT 0
25432: PPUSH
25433: CALL_OW 234
// end ;
25437: GO 25422
25439: POP
25440: POP
// end ;
25441: PPOPN 2
25443: END
// every 0 0$1 trigger StreamModeActive and sBunker do
25444: LD_EXP 63
25448: PUSH
25449: LD_EXP 73
25453: AND
25454: IFFALSE 25474
25456: GO 25458
25458: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
25459: LD_INT 32
25461: PPUSH
25462: LD_OWVAR 2
25466: PPUSH
25467: LD_INT 0
25469: PPUSH
25470: CALL_OW 324
25474: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
25475: LD_EXP 63
25479: PUSH
25480: LD_EXP 74
25484: AND
25485: IFFALSE 25666
25487: GO 25489
25489: DISABLE
25490: LD_INT 0
25492: PPUSH
25493: PPUSH
25494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
25495: LD_ADDR_VAR 0 2
25499: PUSH
25500: LD_INT 22
25502: PUSH
25503: LD_OWVAR 2
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: PUSH
25512: LD_INT 33
25514: PUSH
25515: LD_INT 3
25517: PUSH
25518: EMPTY
25519: LIST
25520: LIST
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PPUSH
25526: CALL_OW 69
25530: ST_TO_ADDR
// if not tmp then
25531: LD_VAR 0 2
25535: NOT
25536: IFFALSE 25540
// exit ;
25538: GO 25666
// side := 0 ;
25540: LD_ADDR_VAR 0 3
25544: PUSH
25545: LD_INT 0
25547: ST_TO_ADDR
// for i := 1 to 8 do
25548: LD_ADDR_VAR 0 1
25552: PUSH
25553: DOUBLE
25554: LD_INT 1
25556: DEC
25557: ST_TO_ADDR
25558: LD_INT 8
25560: PUSH
25561: FOR_TO
25562: IFFALSE 25610
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
25564: LD_OWVAR 2
25568: PUSH
25569: LD_VAR 0 1
25573: NONEQUAL
25574: PUSH
25575: LD_OWVAR 2
25579: PPUSH
25580: LD_VAR 0 1
25584: PPUSH
25585: CALL_OW 81
25589: PUSH
25590: LD_INT 2
25592: EQUAL
25593: AND
25594: IFFALSE 25608
// begin side := i ;
25596: LD_ADDR_VAR 0 3
25600: PUSH
25601: LD_VAR 0 1
25605: ST_TO_ADDR
// break ;
25606: GO 25610
// end ;
25608: GO 25561
25610: POP
25611: POP
// if not side then
25612: LD_VAR 0 3
25616: NOT
25617: IFFALSE 25621
// exit ;
25619: GO 25666
// for i := 1 to tmp do
25621: LD_ADDR_VAR 0 1
25625: PUSH
25626: DOUBLE
25627: LD_INT 1
25629: DEC
25630: ST_TO_ADDR
25631: LD_VAR 0 2
25635: PUSH
25636: FOR_TO
25637: IFFALSE 25664
// if Prob ( 60 ) then
25639: LD_INT 60
25641: PPUSH
25642: CALL_OW 13
25646: IFFALSE 25662
// SetSide ( i , side ) ;
25648: LD_VAR 0 1
25652: PPUSH
25653: LD_VAR 0 3
25657: PPUSH
25658: CALL_OW 235
25662: GO 25636
25664: POP
25665: POP
// end ;
25666: PPOPN 3
25668: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
25669: LD_EXP 63
25673: PUSH
25674: LD_EXP 76
25678: AND
25679: IFFALSE 25798
25681: GO 25683
25683: DISABLE
25684: LD_INT 0
25686: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
25687: LD_ADDR_VAR 0 1
25691: PUSH
25692: LD_INT 22
25694: PUSH
25695: LD_OWVAR 2
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PUSH
25704: LD_INT 21
25706: PUSH
25707: LD_INT 1
25709: PUSH
25710: EMPTY
25711: LIST
25712: LIST
25713: PUSH
25714: LD_INT 3
25716: PUSH
25717: LD_INT 23
25719: PUSH
25720: LD_INT 0
25722: PUSH
25723: EMPTY
25724: LIST
25725: LIST
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: EMPTY
25732: LIST
25733: LIST
25734: LIST
25735: PPUSH
25736: CALL_OW 69
25740: PUSH
25741: FOR_IN
25742: IFFALSE 25796
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
25744: LD_VAR 0 1
25748: PPUSH
25749: CALL_OW 257
25753: PUSH
25754: LD_INT 1
25756: PUSH
25757: LD_INT 2
25759: PUSH
25760: LD_INT 3
25762: PUSH
25763: LD_INT 4
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: LIST
25770: LIST
25771: IN
25772: IFFALSE 25794
// SetClass ( un , rand ( 1 , 4 ) ) ;
25774: LD_VAR 0 1
25778: PPUSH
25779: LD_INT 1
25781: PPUSH
25782: LD_INT 4
25784: PPUSH
25785: CALL_OW 12
25789: PPUSH
25790: CALL_OW 336
25794: GO 25741
25796: POP
25797: POP
// end ;
25798: PPOPN 1
25800: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
25801: LD_EXP 63
25805: PUSH
25806: LD_EXP 75
25810: AND
25811: IFFALSE 25890
25813: GO 25815
25815: DISABLE
25816: LD_INT 0
25818: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
25819: LD_ADDR_VAR 0 1
25823: PUSH
25824: LD_INT 22
25826: PUSH
25827: LD_OWVAR 2
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: PUSH
25836: LD_INT 21
25838: PUSH
25839: LD_INT 3
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: PUSH
25846: EMPTY
25847: LIST
25848: LIST
25849: PPUSH
25850: CALL_OW 69
25854: ST_TO_ADDR
// if not tmp then
25855: LD_VAR 0 1
25859: NOT
25860: IFFALSE 25864
// exit ;
25862: GO 25890
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
25864: LD_VAR 0 1
25868: PUSH
25869: LD_INT 1
25871: PPUSH
25872: LD_VAR 0 1
25876: PPUSH
25877: CALL_OW 12
25881: ARRAY
25882: PPUSH
25883: LD_INT 100
25885: PPUSH
25886: CALL_OW 234
// end ;
25890: PPOPN 1
25892: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
25893: LD_EXP 63
25897: PUSH
25898: LD_EXP 77
25902: AND
25903: IFFALSE 26001
25905: GO 25907
25907: DISABLE
25908: LD_INT 0
25910: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
25911: LD_ADDR_VAR 0 1
25915: PUSH
25916: LD_INT 22
25918: PUSH
25919: LD_OWVAR 2
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: LD_INT 21
25930: PUSH
25931: LD_INT 1
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: EMPTY
25939: LIST
25940: LIST
25941: PPUSH
25942: CALL_OW 69
25946: ST_TO_ADDR
// if not tmp then
25947: LD_VAR 0 1
25951: NOT
25952: IFFALSE 25956
// exit ;
25954: GO 26001
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
25956: LD_VAR 0 1
25960: PUSH
25961: LD_INT 1
25963: PPUSH
25964: LD_VAR 0 1
25968: PPUSH
25969: CALL_OW 12
25973: ARRAY
25974: PPUSH
25975: LD_INT 1
25977: PPUSH
25978: LD_INT 4
25980: PPUSH
25981: CALL_OW 12
25985: PPUSH
25986: LD_INT 3000
25988: PPUSH
25989: LD_INT 9000
25991: PPUSH
25992: CALL_OW 12
25996: PPUSH
25997: CALL_OW 492
// end ;
26001: PPOPN 1
26003: END
// every 0 0$1 trigger StreamModeActive and sDepot do
26004: LD_EXP 63
26008: PUSH
26009: LD_EXP 78
26013: AND
26014: IFFALSE 26034
26016: GO 26018
26018: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
26019: LD_INT 1
26021: PPUSH
26022: LD_OWVAR 2
26026: PPUSH
26027: LD_INT 0
26029: PPUSH
26030: CALL_OW 324
26034: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
26035: LD_EXP 63
26039: PUSH
26040: LD_EXP 79
26044: AND
26045: IFFALSE 26128
26047: GO 26049
26049: DISABLE
26050: LD_INT 0
26052: PPUSH
26053: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
26054: LD_ADDR_VAR 0 2
26058: PUSH
26059: LD_INT 22
26061: PUSH
26062: LD_OWVAR 2
26066: PUSH
26067: EMPTY
26068: LIST
26069: LIST
26070: PUSH
26071: LD_INT 21
26073: PUSH
26074: LD_INT 3
26076: PUSH
26077: EMPTY
26078: LIST
26079: LIST
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PPUSH
26085: CALL_OW 69
26089: ST_TO_ADDR
// if not tmp then
26090: LD_VAR 0 2
26094: NOT
26095: IFFALSE 26099
// exit ;
26097: GO 26128
// for i in tmp do
26099: LD_ADDR_VAR 0 1
26103: PUSH
26104: LD_VAR 0 2
26108: PUSH
26109: FOR_IN
26110: IFFALSE 26126
// SetBLevel ( i , 10 ) ;
26112: LD_VAR 0 1
26116: PPUSH
26117: LD_INT 10
26119: PPUSH
26120: CALL_OW 241
26124: GO 26109
26126: POP
26127: POP
// end ;
26128: PPOPN 2
26130: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
26131: LD_EXP 63
26135: PUSH
26136: LD_EXP 80
26140: AND
26141: IFFALSE 26252
26143: GO 26145
26145: DISABLE
26146: LD_INT 0
26148: PPUSH
26149: PPUSH
26150: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
26151: LD_ADDR_VAR 0 3
26155: PUSH
26156: LD_INT 22
26158: PUSH
26159: LD_OWVAR 2
26163: PUSH
26164: EMPTY
26165: LIST
26166: LIST
26167: PUSH
26168: LD_INT 25
26170: PUSH
26171: LD_INT 1
26173: PUSH
26174: EMPTY
26175: LIST
26176: LIST
26177: PUSH
26178: EMPTY
26179: LIST
26180: LIST
26181: PPUSH
26182: CALL_OW 69
26186: ST_TO_ADDR
// if not tmp then
26187: LD_VAR 0 3
26191: NOT
26192: IFFALSE 26196
// exit ;
26194: GO 26252
// un := tmp [ rand ( 1 , tmp ) ] ;
26196: LD_ADDR_VAR 0 2
26200: PUSH
26201: LD_VAR 0 3
26205: PUSH
26206: LD_INT 1
26208: PPUSH
26209: LD_VAR 0 3
26213: PPUSH
26214: CALL_OW 12
26218: ARRAY
26219: ST_TO_ADDR
// if Crawls ( un ) then
26220: LD_VAR 0 2
26224: PPUSH
26225: CALL_OW 318
26229: IFFALSE 26240
// ComWalk ( un ) ;
26231: LD_VAR 0 2
26235: PPUSH
26236: CALL_OW 138
// SetClass ( un , class_sniper ) ;
26240: LD_VAR 0 2
26244: PPUSH
26245: LD_INT 5
26247: PPUSH
26248: CALL_OW 336
// end ;
26252: PPOPN 3
26254: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
26255: LD_EXP 63
26259: PUSH
26260: LD_EXP 81
26264: AND
26265: PUSH
26266: LD_OWVAR 67
26270: PUSH
26271: LD_INT 3
26273: LESS
26274: AND
26275: IFFALSE 26294
26277: GO 26279
26279: DISABLE
// Difficulty := Difficulty + 1 ;
26280: LD_ADDR_OWVAR 67
26284: PUSH
26285: LD_OWVAR 67
26289: PUSH
26290: LD_INT 1
26292: PLUS
26293: ST_TO_ADDR
26294: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
26295: LD_EXP 63
26299: PUSH
26300: LD_EXP 82
26304: AND
26305: IFFALSE 26408
26307: GO 26309
26309: DISABLE
26310: LD_INT 0
26312: PPUSH
// begin for i := 1 to 5 do
26313: LD_ADDR_VAR 0 1
26317: PUSH
26318: DOUBLE
26319: LD_INT 1
26321: DEC
26322: ST_TO_ADDR
26323: LD_INT 5
26325: PUSH
26326: FOR_TO
26327: IFFALSE 26406
// begin uc_nation := nation_nature ;
26329: LD_ADDR_OWVAR 21
26333: PUSH
26334: LD_INT 0
26336: ST_TO_ADDR
// uc_side := 0 ;
26337: LD_ADDR_OWVAR 20
26341: PUSH
26342: LD_INT 0
26344: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
26345: LD_ADDR_OWVAR 29
26349: PUSH
26350: LD_INT 12
26352: PUSH
26353: LD_INT 12
26355: PUSH
26356: EMPTY
26357: LIST
26358: LIST
26359: ST_TO_ADDR
// hc_agressivity := 20 ;
26360: LD_ADDR_OWVAR 35
26364: PUSH
26365: LD_INT 20
26367: ST_TO_ADDR
// hc_class := class_tiger ;
26368: LD_ADDR_OWVAR 28
26372: PUSH
26373: LD_INT 14
26375: ST_TO_ADDR
// hc_gallery :=  ;
26376: LD_ADDR_OWVAR 33
26380: PUSH
26381: LD_STRING 
26383: ST_TO_ADDR
// hc_name :=  ;
26384: LD_ADDR_OWVAR 26
26388: PUSH
26389: LD_STRING 
26391: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
26392: CALL_OW 44
26396: PPUSH
26397: LD_INT 0
26399: PPUSH
26400: CALL_OW 51
// end ;
26404: GO 26326
26406: POP
26407: POP
// end ;
26408: PPOPN 1
26410: END
// every 0 0$1 trigger StreamModeActive and sBomb do
26411: LD_EXP 63
26415: PUSH
26416: LD_EXP 83
26420: AND
26421: IFFALSE 26430
26423: GO 26425
26425: DISABLE
// StreamSibBomb ;
26426: CALL 26431 0 0
26430: END
// export function StreamSibBomb ; var i , x , y ; begin
26431: LD_INT 0
26433: PPUSH
26434: PPUSH
26435: PPUSH
26436: PPUSH
// result := false ;
26437: LD_ADDR_VAR 0 1
26441: PUSH
26442: LD_INT 0
26444: ST_TO_ADDR
// for i := 1 to 16 do
26445: LD_ADDR_VAR 0 2
26449: PUSH
26450: DOUBLE
26451: LD_INT 1
26453: DEC
26454: ST_TO_ADDR
26455: LD_INT 16
26457: PUSH
26458: FOR_TO
26459: IFFALSE 26658
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
26461: LD_ADDR_VAR 0 3
26465: PUSH
26466: LD_INT 10
26468: PUSH
26469: LD_INT 20
26471: PUSH
26472: LD_INT 30
26474: PUSH
26475: LD_INT 40
26477: PUSH
26478: LD_INT 50
26480: PUSH
26481: LD_INT 60
26483: PUSH
26484: LD_INT 70
26486: PUSH
26487: LD_INT 80
26489: PUSH
26490: LD_INT 90
26492: PUSH
26493: LD_INT 100
26495: PUSH
26496: LD_INT 110
26498: PUSH
26499: LD_INT 120
26501: PUSH
26502: LD_INT 130
26504: PUSH
26505: LD_INT 140
26507: PUSH
26508: LD_INT 150
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: LIST
26515: LIST
26516: LIST
26517: LIST
26518: LIST
26519: LIST
26520: LIST
26521: LIST
26522: LIST
26523: LIST
26524: LIST
26525: LIST
26526: LIST
26527: PUSH
26528: LD_INT 1
26530: PPUSH
26531: LD_INT 15
26533: PPUSH
26534: CALL_OW 12
26538: ARRAY
26539: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
26540: LD_ADDR_VAR 0 4
26544: PUSH
26545: LD_INT 10
26547: PUSH
26548: LD_INT 20
26550: PUSH
26551: LD_INT 30
26553: PUSH
26554: LD_INT 40
26556: PUSH
26557: LD_INT 50
26559: PUSH
26560: LD_INT 60
26562: PUSH
26563: LD_INT 70
26565: PUSH
26566: LD_INT 80
26568: PUSH
26569: LD_INT 90
26571: PUSH
26572: LD_INT 100
26574: PUSH
26575: LD_INT 110
26577: PUSH
26578: LD_INT 120
26580: PUSH
26581: LD_INT 130
26583: PUSH
26584: LD_INT 140
26586: PUSH
26587: LD_INT 150
26589: PUSH
26590: EMPTY
26591: LIST
26592: LIST
26593: LIST
26594: LIST
26595: LIST
26596: LIST
26597: LIST
26598: LIST
26599: LIST
26600: LIST
26601: LIST
26602: LIST
26603: LIST
26604: LIST
26605: LIST
26606: PUSH
26607: LD_INT 1
26609: PPUSH
26610: LD_INT 15
26612: PPUSH
26613: CALL_OW 12
26617: ARRAY
26618: ST_TO_ADDR
// if ValidHex ( x , y ) then
26619: LD_VAR 0 3
26623: PPUSH
26624: LD_VAR 0 4
26628: PPUSH
26629: CALL_OW 488
26633: IFFALSE 26656
// begin result := [ x , y ] ;
26635: LD_ADDR_VAR 0 1
26639: PUSH
26640: LD_VAR 0 3
26644: PUSH
26645: LD_VAR 0 4
26649: PUSH
26650: EMPTY
26651: LIST
26652: LIST
26653: ST_TO_ADDR
// break ;
26654: GO 26658
// end ; end ;
26656: GO 26458
26658: POP
26659: POP
// if result then
26660: LD_VAR 0 1
26664: IFFALSE 26724
// begin ToLua ( playSibBomb() ) ;
26666: LD_STRING playSibBomb()
26668: PPUSH
26669: CALL_OW 559
// wait ( 0 0$14 ) ;
26673: LD_INT 490
26675: PPUSH
26676: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
26680: LD_VAR 0 1
26684: PUSH
26685: LD_INT 1
26687: ARRAY
26688: PPUSH
26689: LD_VAR 0 1
26693: PUSH
26694: LD_INT 2
26696: ARRAY
26697: PPUSH
26698: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
26702: LD_VAR 0 1
26706: PUSH
26707: LD_INT 1
26709: ARRAY
26710: PPUSH
26711: LD_VAR 0 1
26715: PUSH
26716: LD_INT 2
26718: ARRAY
26719: PPUSH
26720: CALL_OW 429
// end ; end ;
26724: LD_VAR 0 1
26728: RET
// every 0 0$1 trigger StreamModeActive and sReset do
26729: LD_EXP 63
26733: PUSH
26734: LD_EXP 85
26738: AND
26739: IFFALSE 26751
26741: GO 26743
26743: DISABLE
// YouLost (  ) ;
26744: LD_STRING 
26746: PPUSH
26747: CALL_OW 104
26751: END
// every 0 0$1 trigger StreamModeActive and sFog do
26752: LD_EXP 63
26756: PUSH
26757: LD_EXP 84
26761: AND
26762: IFFALSE 26776
26764: GO 26766
26766: DISABLE
// FogOff ( your_side ) ;
26767: LD_OWVAR 2
26771: PPUSH
26772: CALL_OW 344
26776: END
// every 0 0$1 trigger StreamModeActive and sSun do
26777: LD_EXP 63
26781: PUSH
26782: LD_EXP 86
26786: AND
26787: IFFALSE 26815
26789: GO 26791
26791: DISABLE
// begin solar_recharge_percent := 0 ;
26792: LD_ADDR_OWVAR 79
26796: PUSH
26797: LD_INT 0
26799: ST_TO_ADDR
// wait ( 5 5$00 ) ;
26800: LD_INT 10500
26802: PPUSH
26803: CALL_OW 67
// solar_recharge_percent := 100 ;
26807: LD_ADDR_OWVAR 79
26811: PUSH
26812: LD_INT 100
26814: ST_TO_ADDR
// end ;
26815: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
26816: LD_EXP 63
26820: PUSH
26821: LD_EXP 87
26825: AND
26826: IFFALSE 27065
26828: GO 26830
26830: DISABLE
26831: LD_INT 0
26833: PPUSH
26834: PPUSH
26835: PPUSH
// begin tmp := [ ] ;
26836: LD_ADDR_VAR 0 3
26840: PUSH
26841: EMPTY
26842: ST_TO_ADDR
// for i := 1 to 6 do
26843: LD_ADDR_VAR 0 1
26847: PUSH
26848: DOUBLE
26849: LD_INT 1
26851: DEC
26852: ST_TO_ADDR
26853: LD_INT 6
26855: PUSH
26856: FOR_TO
26857: IFFALSE 26962
// begin uc_nation := nation_nature ;
26859: LD_ADDR_OWVAR 21
26863: PUSH
26864: LD_INT 0
26866: ST_TO_ADDR
// uc_side := 0 ;
26867: LD_ADDR_OWVAR 20
26871: PUSH
26872: LD_INT 0
26874: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
26875: LD_ADDR_OWVAR 29
26879: PUSH
26880: LD_INT 12
26882: PUSH
26883: LD_INT 12
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: ST_TO_ADDR
// hc_agressivity := 20 ;
26890: LD_ADDR_OWVAR 35
26894: PUSH
26895: LD_INT 20
26897: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
26898: LD_ADDR_OWVAR 28
26902: PUSH
26903: LD_INT 17
26905: ST_TO_ADDR
// hc_gallery :=  ;
26906: LD_ADDR_OWVAR 33
26910: PUSH
26911: LD_STRING 
26913: ST_TO_ADDR
// hc_name :=  ;
26914: LD_ADDR_OWVAR 26
26918: PUSH
26919: LD_STRING 
26921: ST_TO_ADDR
// un := CreateHuman ;
26922: LD_ADDR_VAR 0 2
26926: PUSH
26927: CALL_OW 44
26931: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
26932: LD_VAR 0 2
26936: PPUSH
26937: LD_INT 1
26939: PPUSH
26940: CALL_OW 51
// tmp := tmp ^ un ;
26944: LD_ADDR_VAR 0 3
26948: PUSH
26949: LD_VAR 0 3
26953: PUSH
26954: LD_VAR 0 2
26958: ADD
26959: ST_TO_ADDR
// end ;
26960: GO 26856
26962: POP
26963: POP
// repeat wait ( 0 0$1 ) ;
26964: LD_INT 35
26966: PPUSH
26967: CALL_OW 67
// for un in tmp do
26971: LD_ADDR_VAR 0 2
26975: PUSH
26976: LD_VAR 0 3
26980: PUSH
26981: FOR_IN
26982: IFFALSE 27056
// begin if IsDead ( un ) then
26984: LD_VAR 0 2
26988: PPUSH
26989: CALL_OW 301
26993: IFFALSE 27013
// begin tmp := tmp diff un ;
26995: LD_ADDR_VAR 0 3
26999: PUSH
27000: LD_VAR 0 3
27004: PUSH
27005: LD_VAR 0 2
27009: DIFF
27010: ST_TO_ADDR
// continue ;
27011: GO 26981
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
27013: LD_VAR 0 2
27017: PPUSH
27018: LD_INT 3
27020: PUSH
27021: LD_INT 22
27023: PUSH
27024: LD_INT 0
27026: PUSH
27027: EMPTY
27028: LIST
27029: LIST
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: PPUSH
27035: CALL_OW 69
27039: PPUSH
27040: LD_VAR 0 2
27044: PPUSH
27045: CALL_OW 74
27049: PPUSH
27050: CALL_OW 115
// end ;
27054: GO 26981
27056: POP
27057: POP
// until not tmp ;
27058: LD_VAR 0 3
27062: NOT
27063: IFFALSE 26964
// end ;
27065: PPOPN 3
27067: END
// every 0 0$1 trigger StreamModeActive and sTroll do
27068: LD_EXP 63
27072: PUSH
27073: LD_EXP 88
27077: AND
27078: IFFALSE 27132
27080: GO 27082
27082: DISABLE
// begin ToLua ( displayTroll(); ) ;
27083: LD_STRING displayTroll();
27085: PPUSH
27086: CALL_OW 559
// wait ( 3 3$00 ) ;
27090: LD_INT 6300
27092: PPUSH
27093: CALL_OW 67
// ToLua ( hideTroll(); ) ;
27097: LD_STRING hideTroll();
27099: PPUSH
27100: CALL_OW 559
// wait ( 1 1$00 ) ;
27104: LD_INT 2100
27106: PPUSH
27107: CALL_OW 67
// ToLua ( displayTroll(); ) ;
27111: LD_STRING displayTroll();
27113: PPUSH
27114: CALL_OW 559
// wait ( 1 1$00 ) ;
27118: LD_INT 2100
27120: PPUSH
27121: CALL_OW 67
// ToLua ( hideTroll(); ) ;
27125: LD_STRING hideTroll();
27127: PPUSH
27128: CALL_OW 559
// end ;
27132: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
27133: LD_EXP 63
27137: PUSH
27138: LD_EXP 89
27142: AND
27143: IFFALSE 27206
27145: GO 27147
27147: DISABLE
27148: LD_INT 0
27150: PPUSH
// begin p := 0 ;
27151: LD_ADDR_VAR 0 1
27155: PUSH
27156: LD_INT 0
27158: ST_TO_ADDR
// repeat game_speed := 1 ;
27159: LD_ADDR_OWVAR 65
27163: PUSH
27164: LD_INT 1
27166: ST_TO_ADDR
// wait ( 0 0$1 ) ;
27167: LD_INT 35
27169: PPUSH
27170: CALL_OW 67
// p := p + 1 ;
27174: LD_ADDR_VAR 0 1
27178: PUSH
27179: LD_VAR 0 1
27183: PUSH
27184: LD_INT 1
27186: PLUS
27187: ST_TO_ADDR
// until p >= 60 ;
27188: LD_VAR 0 1
27192: PUSH
27193: LD_INT 60
27195: GREATEREQUAL
27196: IFFALSE 27159
// game_speed := 4 ;
27198: LD_ADDR_OWVAR 65
27202: PUSH
27203: LD_INT 4
27205: ST_TO_ADDR
// end ;
27206: PPOPN 1
27208: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
27209: LD_EXP 63
27213: PUSH
27214: LD_EXP 90
27218: AND
27219: IFFALSE 27365
27221: GO 27223
27223: DISABLE
27224: LD_INT 0
27226: PPUSH
27227: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27228: LD_ADDR_VAR 0 1
27232: PUSH
27233: LD_INT 22
27235: PUSH
27236: LD_OWVAR 2
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: PUSH
27245: LD_INT 2
27247: PUSH
27248: LD_INT 30
27250: PUSH
27251: LD_INT 0
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PUSH
27258: LD_INT 30
27260: PUSH
27261: LD_INT 1
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: LIST
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PPUSH
27277: CALL_OW 69
27281: ST_TO_ADDR
// if not depot then
27282: LD_VAR 0 1
27286: NOT
27287: IFFALSE 27291
// exit ;
27289: GO 27365
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
27291: LD_ADDR_VAR 0 2
27295: PUSH
27296: LD_VAR 0 1
27300: PUSH
27301: LD_INT 1
27303: PPUSH
27304: LD_VAR 0 1
27308: PPUSH
27309: CALL_OW 12
27313: ARRAY
27314: PPUSH
27315: CALL_OW 274
27319: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
27320: LD_VAR 0 2
27324: PPUSH
27325: LD_INT 1
27327: PPUSH
27328: LD_INT 0
27330: PPUSH
27331: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
27335: LD_VAR 0 2
27339: PPUSH
27340: LD_INT 2
27342: PPUSH
27343: LD_INT 0
27345: PPUSH
27346: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
27350: LD_VAR 0 2
27354: PPUSH
27355: LD_INT 3
27357: PPUSH
27358: LD_INT 0
27360: PPUSH
27361: CALL_OW 277
// end ;
27365: PPOPN 2
27367: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
27368: LD_EXP 63
27372: PUSH
27373: LD_EXP 91
27377: AND
27378: IFFALSE 27475
27380: GO 27382
27382: DISABLE
27383: LD_INT 0
27385: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
27386: LD_ADDR_VAR 0 1
27390: PUSH
27391: LD_INT 22
27393: PUSH
27394: LD_OWVAR 2
27398: PUSH
27399: EMPTY
27400: LIST
27401: LIST
27402: PUSH
27403: LD_INT 21
27405: PUSH
27406: LD_INT 1
27408: PUSH
27409: EMPTY
27410: LIST
27411: LIST
27412: PUSH
27413: LD_INT 3
27415: PUSH
27416: LD_INT 23
27418: PUSH
27419: LD_INT 0
27421: PUSH
27422: EMPTY
27423: LIST
27424: LIST
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: LIST
27434: PPUSH
27435: CALL_OW 69
27439: ST_TO_ADDR
// if not tmp then
27440: LD_VAR 0 1
27444: NOT
27445: IFFALSE 27449
// exit ;
27447: GO 27475
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
27449: LD_VAR 0 1
27453: PUSH
27454: LD_INT 1
27456: PPUSH
27457: LD_VAR 0 1
27461: PPUSH
27462: CALL_OW 12
27466: ARRAY
27467: PPUSH
27468: LD_INT 200
27470: PPUSH
27471: CALL_OW 234
// end ;
27475: PPOPN 1
27477: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
27478: LD_EXP 63
27482: PUSH
27483: LD_EXP 92
27487: AND
27488: IFFALSE 27567
27490: GO 27492
27492: DISABLE
27493: LD_INT 0
27495: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
27496: LD_ADDR_VAR 0 1
27500: PUSH
27501: LD_INT 22
27503: PUSH
27504: LD_OWVAR 2
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: PUSH
27513: LD_INT 21
27515: PUSH
27516: LD_INT 2
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PUSH
27523: EMPTY
27524: LIST
27525: LIST
27526: PPUSH
27527: CALL_OW 69
27531: ST_TO_ADDR
// if not tmp then
27532: LD_VAR 0 1
27536: NOT
27537: IFFALSE 27541
// exit ;
27539: GO 27567
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
27541: LD_VAR 0 1
27545: PUSH
27546: LD_INT 1
27548: PPUSH
27549: LD_VAR 0 1
27553: PPUSH
27554: CALL_OW 12
27558: ARRAY
27559: PPUSH
27560: LD_INT 60
27562: PPUSH
27563: CALL_OW 234
// end ;
27567: PPOPN 1
27569: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
27570: LD_EXP 63
27574: PUSH
27575: LD_EXP 93
27579: AND
27580: IFFALSE 27679
27582: GO 27584
27584: DISABLE
27585: LD_INT 0
27587: PPUSH
27588: PPUSH
// begin enable ;
27589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
27590: LD_ADDR_VAR 0 1
27594: PUSH
27595: LD_INT 22
27597: PUSH
27598: LD_OWVAR 2
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: PUSH
27607: LD_INT 61
27609: PUSH
27610: EMPTY
27611: LIST
27612: PUSH
27613: LD_INT 33
27615: PUSH
27616: LD_INT 2
27618: PUSH
27619: EMPTY
27620: LIST
27621: LIST
27622: PUSH
27623: EMPTY
27624: LIST
27625: LIST
27626: LIST
27627: PPUSH
27628: CALL_OW 69
27632: ST_TO_ADDR
// if not tmp then
27633: LD_VAR 0 1
27637: NOT
27638: IFFALSE 27642
// exit ;
27640: GO 27679
// for i in tmp do
27642: LD_ADDR_VAR 0 2
27646: PUSH
27647: LD_VAR 0 1
27651: PUSH
27652: FOR_IN
27653: IFFALSE 27677
// if IsControledBy ( i ) then
27655: LD_VAR 0 2
27659: PPUSH
27660: CALL_OW 312
27664: IFFALSE 27675
// ComUnlink ( i ) ;
27666: LD_VAR 0 2
27670: PPUSH
27671: CALL_OW 136
27675: GO 27652
27677: POP
27678: POP
// end ;
27679: PPOPN 2
27681: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
27682: LD_EXP 63
27686: PUSH
27687: LD_EXP 94
27691: AND
27692: IFFALSE 27832
27694: GO 27696
27696: DISABLE
27697: LD_INT 0
27699: PPUSH
27700: PPUSH
// begin ToLua ( displayPowell(); ) ;
27701: LD_STRING displayPowell();
27703: PPUSH
27704: CALL_OW 559
// uc_side := 0 ;
27708: LD_ADDR_OWVAR 20
27712: PUSH
27713: LD_INT 0
27715: ST_TO_ADDR
// uc_nation := 2 ;
27716: LD_ADDR_OWVAR 21
27720: PUSH
27721: LD_INT 2
27723: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
27724: LD_ADDR_OWVAR 37
27728: PUSH
27729: LD_INT 14
27731: ST_TO_ADDR
// vc_engine := engine_siberite ;
27732: LD_ADDR_OWVAR 39
27736: PUSH
27737: LD_INT 3
27739: ST_TO_ADDR
// vc_control := control_apeman ;
27740: LD_ADDR_OWVAR 38
27744: PUSH
27745: LD_INT 5
27747: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
27748: LD_ADDR_OWVAR 40
27752: PUSH
27753: LD_INT 29
27755: ST_TO_ADDR
// un := CreateVehicle ;
27756: LD_ADDR_VAR 0 2
27760: PUSH
27761: CALL_OW 45
27765: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
27766: LD_VAR 0 2
27770: PPUSH
27771: LD_INT 1
27773: PPUSH
27774: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
27778: LD_INT 35
27780: PPUSH
27781: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
27785: LD_VAR 0 2
27789: PPUSH
27790: LD_INT 22
27792: PUSH
27793: LD_OWVAR 2
27797: PUSH
27798: EMPTY
27799: LIST
27800: LIST
27801: PPUSH
27802: CALL_OW 69
27806: PPUSH
27807: LD_VAR 0 2
27811: PPUSH
27812: CALL_OW 74
27816: PPUSH
27817: CALL_OW 115
// until IsDead ( un ) ;
27821: LD_VAR 0 2
27825: PPUSH
27826: CALL_OW 301
27830: IFFALSE 27778
// end ;
27832: PPOPN 2
27834: END
// every 0 0$1 trigger StreamModeActive and sStu do
27835: LD_EXP 63
27839: PUSH
27840: LD_EXP 102
27844: AND
27845: IFFALSE 27861
27847: GO 27849
27849: DISABLE
// begin ToLua ( displayStucuk(); ) ;
27850: LD_STRING displayStucuk();
27852: PPUSH
27853: CALL_OW 559
// ResetFog ;
27857: CALL_OW 335
// end ;
27861: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
27862: LD_EXP 63
27866: PUSH
27867: LD_EXP 95
27871: AND
27872: IFFALSE 28013
27874: GO 27876
27876: DISABLE
27877: LD_INT 0
27879: PPUSH
27880: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
27881: LD_ADDR_VAR 0 2
27885: PUSH
27886: LD_INT 22
27888: PUSH
27889: LD_OWVAR 2
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PUSH
27898: LD_INT 21
27900: PUSH
27901: LD_INT 1
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PPUSH
27912: CALL_OW 69
27916: ST_TO_ADDR
// if not tmp then
27917: LD_VAR 0 2
27921: NOT
27922: IFFALSE 27926
// exit ;
27924: GO 28013
// un := tmp [ rand ( 1 , tmp ) ] ;
27926: LD_ADDR_VAR 0 1
27930: PUSH
27931: LD_VAR 0 2
27935: PUSH
27936: LD_INT 1
27938: PPUSH
27939: LD_VAR 0 2
27943: PPUSH
27944: CALL_OW 12
27948: ARRAY
27949: ST_TO_ADDR
// SetSide ( un , 0 ) ;
27950: LD_VAR 0 1
27954: PPUSH
27955: LD_INT 0
27957: PPUSH
27958: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
27962: LD_VAR 0 1
27966: PPUSH
27967: LD_OWVAR 3
27971: PUSH
27972: LD_VAR 0 1
27976: DIFF
27977: PPUSH
27978: LD_VAR 0 1
27982: PPUSH
27983: CALL_OW 74
27987: PPUSH
27988: CALL_OW 115
// wait ( 0 0$20 ) ;
27992: LD_INT 700
27994: PPUSH
27995: CALL_OW 67
// SetSide ( un , your_side ) ;
27999: LD_VAR 0 1
28003: PPUSH
28004: LD_OWVAR 2
28008: PPUSH
28009: CALL_OW 235
// end ;
28013: PPOPN 2
28015: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
28016: LD_EXP 63
28020: PUSH
28021: LD_EXP 96
28025: AND
28026: IFFALSE 28132
28028: GO 28030
28030: DISABLE
28031: LD_INT 0
28033: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28034: LD_ADDR_VAR 0 1
28038: PUSH
28039: LD_INT 22
28041: PUSH
28042: LD_OWVAR 2
28046: PUSH
28047: EMPTY
28048: LIST
28049: LIST
28050: PUSH
28051: LD_INT 2
28053: PUSH
28054: LD_INT 30
28056: PUSH
28057: LD_INT 0
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: LD_INT 30
28066: PUSH
28067: LD_INT 1
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: LIST
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: PPUSH
28083: CALL_OW 69
28087: ST_TO_ADDR
// if not depot then
28088: LD_VAR 0 1
28092: NOT
28093: IFFALSE 28097
// exit ;
28095: GO 28132
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
28097: LD_VAR 0 1
28101: PUSH
28102: LD_INT 1
28104: ARRAY
28105: PPUSH
28106: CALL_OW 250
28110: PPUSH
28111: LD_VAR 0 1
28115: PUSH
28116: LD_INT 1
28118: ARRAY
28119: PPUSH
28120: CALL_OW 251
28124: PPUSH
28125: LD_INT 70
28127: PPUSH
28128: CALL_OW 495
// end ;
28132: PPOPN 1
28134: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
28135: LD_EXP 63
28139: PUSH
28140: LD_EXP 97
28144: AND
28145: IFFALSE 28356
28147: GO 28149
28149: DISABLE
28150: LD_INT 0
28152: PPUSH
28153: PPUSH
28154: PPUSH
28155: PPUSH
28156: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
28157: LD_ADDR_VAR 0 5
28161: PUSH
28162: LD_INT 22
28164: PUSH
28165: LD_OWVAR 2
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 21
28176: PUSH
28177: LD_INT 1
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: EMPTY
28185: LIST
28186: LIST
28187: PPUSH
28188: CALL_OW 69
28192: ST_TO_ADDR
// if not tmp then
28193: LD_VAR 0 5
28197: NOT
28198: IFFALSE 28202
// exit ;
28200: GO 28356
// for i in tmp do
28202: LD_ADDR_VAR 0 1
28206: PUSH
28207: LD_VAR 0 5
28211: PUSH
28212: FOR_IN
28213: IFFALSE 28354
// begin d := rand ( 0 , 5 ) ;
28215: LD_ADDR_VAR 0 4
28219: PUSH
28220: LD_INT 0
28222: PPUSH
28223: LD_INT 5
28225: PPUSH
28226: CALL_OW 12
28230: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
28231: LD_ADDR_VAR 0 2
28235: PUSH
28236: LD_VAR 0 1
28240: PPUSH
28241: CALL_OW 250
28245: PPUSH
28246: LD_VAR 0 4
28250: PPUSH
28251: LD_INT 3
28253: PPUSH
28254: LD_INT 12
28256: PPUSH
28257: CALL_OW 12
28261: PPUSH
28262: CALL_OW 272
28266: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
28267: LD_ADDR_VAR 0 3
28271: PUSH
28272: LD_VAR 0 1
28276: PPUSH
28277: CALL_OW 251
28281: PPUSH
28282: LD_VAR 0 4
28286: PPUSH
28287: LD_INT 3
28289: PPUSH
28290: LD_INT 12
28292: PPUSH
28293: CALL_OW 12
28297: PPUSH
28298: CALL_OW 273
28302: ST_TO_ADDR
// if ValidHex ( x , y ) then
28303: LD_VAR 0 2
28307: PPUSH
28308: LD_VAR 0 3
28312: PPUSH
28313: CALL_OW 488
28317: IFFALSE 28352
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
28319: LD_VAR 0 1
28323: PPUSH
28324: LD_VAR 0 2
28328: PPUSH
28329: LD_VAR 0 3
28333: PPUSH
28334: LD_INT 3
28336: PPUSH
28337: LD_INT 6
28339: PPUSH
28340: CALL_OW 12
28344: PPUSH
28345: LD_INT 1
28347: PPUSH
28348: CALL_OW 483
// end ;
28352: GO 28212
28354: POP
28355: POP
// end ;
28356: PPOPN 5
28358: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
28359: LD_EXP 63
28363: PUSH
28364: LD_EXP 98
28368: AND
28369: IFFALSE 28463
28371: GO 28373
28373: DISABLE
28374: LD_INT 0
28376: PPUSH
28377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
28378: LD_ADDR_VAR 0 2
28382: PUSH
28383: LD_INT 22
28385: PUSH
28386: LD_OWVAR 2
28390: PUSH
28391: EMPTY
28392: LIST
28393: LIST
28394: PUSH
28395: LD_INT 32
28397: PUSH
28398: LD_INT 1
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PUSH
28405: LD_INT 21
28407: PUSH
28408: LD_INT 2
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: EMPTY
28416: LIST
28417: LIST
28418: LIST
28419: PPUSH
28420: CALL_OW 69
28424: ST_TO_ADDR
// if not tmp then
28425: LD_VAR 0 2
28429: NOT
28430: IFFALSE 28434
// exit ;
28432: GO 28463
// for i in tmp do
28434: LD_ADDR_VAR 0 1
28438: PUSH
28439: LD_VAR 0 2
28443: PUSH
28444: FOR_IN
28445: IFFALSE 28461
// SetFuel ( i , 0 ) ;
28447: LD_VAR 0 1
28451: PPUSH
28452: LD_INT 0
28454: PPUSH
28455: CALL_OW 240
28459: GO 28444
28461: POP
28462: POP
// end ;
28463: PPOPN 2
28465: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
28466: LD_EXP 63
28470: PUSH
28471: LD_EXP 99
28475: AND
28476: IFFALSE 28542
28478: GO 28480
28480: DISABLE
28481: LD_INT 0
28483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
28484: LD_ADDR_VAR 0 1
28488: PUSH
28489: LD_INT 22
28491: PUSH
28492: LD_OWVAR 2
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PUSH
28501: LD_INT 30
28503: PUSH
28504: LD_INT 29
28506: PUSH
28507: EMPTY
28508: LIST
28509: LIST
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PPUSH
28515: CALL_OW 69
28519: ST_TO_ADDR
// if not tmp then
28520: LD_VAR 0 1
28524: NOT
28525: IFFALSE 28529
// exit ;
28527: GO 28542
// DestroyUnit ( tmp [ 1 ] ) ;
28529: LD_VAR 0 1
28533: PUSH
28534: LD_INT 1
28536: ARRAY
28537: PPUSH
28538: CALL_OW 65
// end ;
28542: PPOPN 1
28544: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
28545: LD_EXP 63
28549: PUSH
28550: LD_EXP 101
28554: AND
28555: IFFALSE 28684
28557: GO 28559
28559: DISABLE
28560: LD_INT 0
28562: PPUSH
// begin uc_side := 0 ;
28563: LD_ADDR_OWVAR 20
28567: PUSH
28568: LD_INT 0
28570: ST_TO_ADDR
// uc_nation := nation_arabian ;
28571: LD_ADDR_OWVAR 21
28575: PUSH
28576: LD_INT 2
28578: ST_TO_ADDR
// hc_gallery :=  ;
28579: LD_ADDR_OWVAR 33
28583: PUSH
28584: LD_STRING 
28586: ST_TO_ADDR
// hc_name :=  ;
28587: LD_ADDR_OWVAR 26
28591: PUSH
28592: LD_STRING 
28594: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
28595: LD_INT 1
28597: PPUSH
28598: LD_INT 11
28600: PPUSH
28601: LD_INT 10
28603: PPUSH
28604: CALL_OW 380
// un := CreateHuman ;
28608: LD_ADDR_VAR 0 1
28612: PUSH
28613: CALL_OW 44
28617: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
28618: LD_VAR 0 1
28622: PPUSH
28623: LD_INT 1
28625: PPUSH
28626: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
28630: LD_INT 35
28632: PPUSH
28633: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
28637: LD_VAR 0 1
28641: PPUSH
28642: LD_INT 22
28644: PUSH
28645: LD_OWVAR 2
28649: PUSH
28650: EMPTY
28651: LIST
28652: LIST
28653: PPUSH
28654: CALL_OW 69
28658: PPUSH
28659: LD_VAR 0 1
28663: PPUSH
28664: CALL_OW 74
28668: PPUSH
28669: CALL_OW 115
// until IsDead ( un ) ;
28673: LD_VAR 0 1
28677: PPUSH
28678: CALL_OW 301
28682: IFFALSE 28630
// end ;
28684: PPOPN 1
28686: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
28687: LD_EXP 63
28691: PUSH
28692: LD_EXP 103
28696: AND
28697: IFFALSE 28709
28699: GO 28701
28701: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
28702: LD_STRING earthquake(getX(game), 0, 32)
28704: PPUSH
28705: CALL_OW 559
28709: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
28710: LD_EXP 63
28714: PUSH
28715: LD_EXP 104
28719: AND
28720: IFFALSE 28811
28722: GO 28724
28724: DISABLE
28725: LD_INT 0
28727: PPUSH
// begin enable ;
28728: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
28729: LD_ADDR_VAR 0 1
28733: PUSH
28734: LD_INT 22
28736: PUSH
28737: LD_OWVAR 2
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: PUSH
28746: LD_INT 21
28748: PUSH
28749: LD_INT 2
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: PUSH
28756: LD_INT 33
28758: PUSH
28759: LD_INT 3
28761: PUSH
28762: EMPTY
28763: LIST
28764: LIST
28765: PUSH
28766: EMPTY
28767: LIST
28768: LIST
28769: LIST
28770: PPUSH
28771: CALL_OW 69
28775: ST_TO_ADDR
// if not tmp then
28776: LD_VAR 0 1
28780: NOT
28781: IFFALSE 28785
// exit ;
28783: GO 28811
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
28785: LD_VAR 0 1
28789: PUSH
28790: LD_INT 1
28792: PPUSH
28793: LD_VAR 0 1
28797: PPUSH
28798: CALL_OW 12
28802: ARRAY
28803: PPUSH
28804: LD_INT 1
28806: PPUSH
28807: CALL_OW 234
// end ;
28811: PPOPN 1
28813: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
28814: LD_EXP 63
28818: PUSH
28819: LD_EXP 105
28823: AND
28824: IFFALSE 28965
28826: GO 28828
28828: DISABLE
28829: LD_INT 0
28831: PPUSH
28832: PPUSH
28833: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28834: LD_ADDR_VAR 0 3
28838: PUSH
28839: LD_INT 22
28841: PUSH
28842: LD_OWVAR 2
28846: PUSH
28847: EMPTY
28848: LIST
28849: LIST
28850: PUSH
28851: LD_INT 25
28853: PUSH
28854: LD_INT 1
28856: PUSH
28857: EMPTY
28858: LIST
28859: LIST
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PPUSH
28865: CALL_OW 69
28869: ST_TO_ADDR
// if not tmp then
28870: LD_VAR 0 3
28874: NOT
28875: IFFALSE 28879
// exit ;
28877: GO 28965
// un := tmp [ rand ( 1 , tmp ) ] ;
28879: LD_ADDR_VAR 0 2
28883: PUSH
28884: LD_VAR 0 3
28888: PUSH
28889: LD_INT 1
28891: PPUSH
28892: LD_VAR 0 3
28896: PPUSH
28897: CALL_OW 12
28901: ARRAY
28902: ST_TO_ADDR
// if Crawls ( un ) then
28903: LD_VAR 0 2
28907: PPUSH
28908: CALL_OW 318
28912: IFFALSE 28923
// ComWalk ( un ) ;
28914: LD_VAR 0 2
28918: PPUSH
28919: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
28923: LD_VAR 0 2
28927: PPUSH
28928: LD_INT 9
28930: PPUSH
28931: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
28935: LD_INT 28
28937: PPUSH
28938: LD_OWVAR 2
28942: PPUSH
28943: LD_INT 2
28945: PPUSH
28946: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
28950: LD_INT 29
28952: PPUSH
28953: LD_OWVAR 2
28957: PPUSH
28958: LD_INT 2
28960: PPUSH
28961: CALL_OW 322
// end ;
28965: PPOPN 3
28967: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
28968: LD_EXP 63
28972: PUSH
28973: LD_EXP 106
28977: AND
28978: IFFALSE 29089
28980: GO 28982
28982: DISABLE
28983: LD_INT 0
28985: PPUSH
28986: PPUSH
28987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
28988: LD_ADDR_VAR 0 3
28992: PUSH
28993: LD_INT 22
28995: PUSH
28996: LD_OWVAR 2
29000: PUSH
29001: EMPTY
29002: LIST
29003: LIST
29004: PUSH
29005: LD_INT 25
29007: PUSH
29008: LD_INT 1
29010: PUSH
29011: EMPTY
29012: LIST
29013: LIST
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PPUSH
29019: CALL_OW 69
29023: ST_TO_ADDR
// if not tmp then
29024: LD_VAR 0 3
29028: NOT
29029: IFFALSE 29033
// exit ;
29031: GO 29089
// un := tmp [ rand ( 1 , tmp ) ] ;
29033: LD_ADDR_VAR 0 2
29037: PUSH
29038: LD_VAR 0 3
29042: PUSH
29043: LD_INT 1
29045: PPUSH
29046: LD_VAR 0 3
29050: PPUSH
29051: CALL_OW 12
29055: ARRAY
29056: ST_TO_ADDR
// if Crawls ( un ) then
29057: LD_VAR 0 2
29061: PPUSH
29062: CALL_OW 318
29066: IFFALSE 29077
// ComWalk ( un ) ;
29068: LD_VAR 0 2
29072: PPUSH
29073: CALL_OW 138
// SetClass ( un , class_mortar ) ;
29077: LD_VAR 0 2
29081: PPUSH
29082: LD_INT 8
29084: PPUSH
29085: CALL_OW 336
// end ;
29089: PPOPN 3
29091: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
29092: LD_EXP 63
29096: PUSH
29097: LD_EXP 107
29101: AND
29102: IFFALSE 29246
29104: GO 29106
29106: DISABLE
29107: LD_INT 0
29109: PPUSH
29110: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
29111: LD_ADDR_VAR 0 2
29115: PUSH
29116: LD_INT 22
29118: PUSH
29119: LD_OWVAR 2
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: LD_INT 21
29130: PUSH
29131: LD_INT 2
29133: PUSH
29134: EMPTY
29135: LIST
29136: LIST
29137: PUSH
29138: LD_INT 2
29140: PUSH
29141: LD_INT 34
29143: PUSH
29144: LD_INT 12
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 34
29153: PUSH
29154: LD_INT 51
29156: PUSH
29157: EMPTY
29158: LIST
29159: LIST
29160: PUSH
29161: LD_INT 34
29163: PUSH
29164: LD_INT 32
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PUSH
29171: EMPTY
29172: LIST
29173: LIST
29174: LIST
29175: LIST
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: LIST
29181: PPUSH
29182: CALL_OW 69
29186: ST_TO_ADDR
// if not tmp then
29187: LD_VAR 0 2
29191: NOT
29192: IFFALSE 29196
// exit ;
29194: GO 29246
// for i in tmp do
29196: LD_ADDR_VAR 0 1
29200: PUSH
29201: LD_VAR 0 2
29205: PUSH
29206: FOR_IN
29207: IFFALSE 29244
// if GetCargo ( i , mat_artifact ) = 0 then
29209: LD_VAR 0 1
29213: PPUSH
29214: LD_INT 4
29216: PPUSH
29217: CALL_OW 289
29221: PUSH
29222: LD_INT 0
29224: EQUAL
29225: IFFALSE 29242
// SetCargo ( i , mat_siberit , 100 ) ;
29227: LD_VAR 0 1
29231: PPUSH
29232: LD_INT 3
29234: PPUSH
29235: LD_INT 100
29237: PPUSH
29238: CALL_OW 290
29242: GO 29206
29244: POP
29245: POP
// end ;
29246: PPOPN 2
29248: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
29249: LD_EXP 63
29253: PUSH
29254: LD_EXP 108
29258: AND
29259: IFFALSE 29442
29261: GO 29263
29263: DISABLE
29264: LD_INT 0
29266: PPUSH
29267: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
29268: LD_ADDR_VAR 0 2
29272: PUSH
29273: LD_INT 22
29275: PUSH
29276: LD_OWVAR 2
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PPUSH
29285: CALL_OW 69
29289: ST_TO_ADDR
// if not tmp then
29290: LD_VAR 0 2
29294: NOT
29295: IFFALSE 29299
// exit ;
29297: GO 29442
// for i := 1 to 2 do
29299: LD_ADDR_VAR 0 1
29303: PUSH
29304: DOUBLE
29305: LD_INT 1
29307: DEC
29308: ST_TO_ADDR
29309: LD_INT 2
29311: PUSH
29312: FOR_TO
29313: IFFALSE 29440
// begin uc_side := your_side ;
29315: LD_ADDR_OWVAR 20
29319: PUSH
29320: LD_OWVAR 2
29324: ST_TO_ADDR
// uc_nation := nation_american ;
29325: LD_ADDR_OWVAR 21
29329: PUSH
29330: LD_INT 1
29332: ST_TO_ADDR
// vc_chassis := us_morphling ;
29333: LD_ADDR_OWVAR 37
29337: PUSH
29338: LD_INT 5
29340: ST_TO_ADDR
// vc_engine := engine_siberite ;
29341: LD_ADDR_OWVAR 39
29345: PUSH
29346: LD_INT 3
29348: ST_TO_ADDR
// vc_control := control_computer ;
29349: LD_ADDR_OWVAR 38
29353: PUSH
29354: LD_INT 3
29356: ST_TO_ADDR
// vc_weapon := us_double_laser ;
29357: LD_ADDR_OWVAR 40
29361: PUSH
29362: LD_INT 10
29364: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
29365: LD_VAR 0 2
29369: PUSH
29370: LD_INT 1
29372: ARRAY
29373: PPUSH
29374: CALL_OW 310
29378: NOT
29379: IFFALSE 29426
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
29381: CALL_OW 45
29385: PPUSH
29386: LD_VAR 0 2
29390: PUSH
29391: LD_INT 1
29393: ARRAY
29394: PPUSH
29395: CALL_OW 250
29399: PPUSH
29400: LD_VAR 0 2
29404: PUSH
29405: LD_INT 1
29407: ARRAY
29408: PPUSH
29409: CALL_OW 251
29413: PPUSH
29414: LD_INT 12
29416: PPUSH
29417: LD_INT 1
29419: PPUSH
29420: CALL_OW 50
29424: GO 29438
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
29426: CALL_OW 45
29430: PPUSH
29431: LD_INT 1
29433: PPUSH
29434: CALL_OW 51
// end ;
29438: GO 29312
29440: POP
29441: POP
// end ;
29442: PPOPN 2
29444: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
29445: LD_EXP 63
29449: PUSH
29450: LD_EXP 109
29454: AND
29455: IFFALSE 29677
29457: GO 29459
29459: DISABLE
29460: LD_INT 0
29462: PPUSH
29463: PPUSH
29464: PPUSH
29465: PPUSH
29466: PPUSH
29467: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
29468: LD_ADDR_VAR 0 6
29472: PUSH
29473: LD_INT 22
29475: PUSH
29476: LD_OWVAR 2
29480: PUSH
29481: EMPTY
29482: LIST
29483: LIST
29484: PUSH
29485: LD_INT 21
29487: PUSH
29488: LD_INT 1
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: PUSH
29495: LD_INT 3
29497: PUSH
29498: LD_INT 23
29500: PUSH
29501: LD_INT 0
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: LIST
29516: PPUSH
29517: CALL_OW 69
29521: ST_TO_ADDR
// if not tmp then
29522: LD_VAR 0 6
29526: NOT
29527: IFFALSE 29531
// exit ;
29529: GO 29677
// s1 := rand ( 1 , 4 ) ;
29531: LD_ADDR_VAR 0 2
29535: PUSH
29536: LD_INT 1
29538: PPUSH
29539: LD_INT 4
29541: PPUSH
29542: CALL_OW 12
29546: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
29547: LD_ADDR_VAR 0 4
29551: PUSH
29552: LD_VAR 0 6
29556: PUSH
29557: LD_INT 1
29559: ARRAY
29560: PPUSH
29561: LD_VAR 0 2
29565: PPUSH
29566: CALL_OW 259
29570: ST_TO_ADDR
// if s1 = 1 then
29571: LD_VAR 0 2
29575: PUSH
29576: LD_INT 1
29578: EQUAL
29579: IFFALSE 29599
// s2 := rand ( 2 , 4 ) else
29581: LD_ADDR_VAR 0 3
29585: PUSH
29586: LD_INT 2
29588: PPUSH
29589: LD_INT 4
29591: PPUSH
29592: CALL_OW 12
29596: ST_TO_ADDR
29597: GO 29607
// s2 := 1 ;
29599: LD_ADDR_VAR 0 3
29603: PUSH
29604: LD_INT 1
29606: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
29607: LD_ADDR_VAR 0 5
29611: PUSH
29612: LD_VAR 0 6
29616: PUSH
29617: LD_INT 1
29619: ARRAY
29620: PPUSH
29621: LD_VAR 0 3
29625: PPUSH
29626: CALL_OW 259
29630: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
29631: LD_VAR 0 6
29635: PUSH
29636: LD_INT 1
29638: ARRAY
29639: PPUSH
29640: LD_VAR 0 2
29644: PPUSH
29645: LD_VAR 0 5
29649: PPUSH
29650: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
29654: LD_VAR 0 6
29658: PUSH
29659: LD_INT 1
29661: ARRAY
29662: PPUSH
29663: LD_VAR 0 3
29667: PPUSH
29668: LD_VAR 0 4
29672: PPUSH
29673: CALL_OW 237
// end ;
29677: PPOPN 6
29679: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
29680: LD_EXP 63
29684: PUSH
29685: LD_EXP 110
29689: AND
29690: IFFALSE 29769
29692: GO 29694
29694: DISABLE
29695: LD_INT 0
29697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
29698: LD_ADDR_VAR 0 1
29702: PUSH
29703: LD_INT 22
29705: PUSH
29706: LD_OWVAR 2
29710: PUSH
29711: EMPTY
29712: LIST
29713: LIST
29714: PUSH
29715: LD_INT 30
29717: PUSH
29718: LD_INT 3
29720: PUSH
29721: EMPTY
29722: LIST
29723: LIST
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PPUSH
29729: CALL_OW 69
29733: ST_TO_ADDR
// if not tmp then
29734: LD_VAR 0 1
29738: NOT
29739: IFFALSE 29743
// exit ;
29741: GO 29769
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
29743: LD_VAR 0 1
29747: PUSH
29748: LD_INT 1
29750: PPUSH
29751: LD_VAR 0 1
29755: PPUSH
29756: CALL_OW 12
29760: ARRAY
29761: PPUSH
29762: LD_INT 1
29764: PPUSH
29765: CALL_OW 234
// end ;
29769: PPOPN 1
29771: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
29772: LD_EXP 63
29776: PUSH
29777: LD_EXP 111
29781: AND
29782: IFFALSE 29894
29784: GO 29786
29786: DISABLE
29787: LD_INT 0
29789: PPUSH
29790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
29791: LD_ADDR_VAR 0 2
29795: PUSH
29796: LD_INT 22
29798: PUSH
29799: LD_OWVAR 2
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 2
29810: PUSH
29811: LD_INT 30
29813: PUSH
29814: LD_INT 27
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 30
29823: PUSH
29824: LD_INT 26
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 30
29833: PUSH
29834: LD_INT 28
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: LIST
29845: LIST
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PPUSH
29851: CALL_OW 69
29855: ST_TO_ADDR
// if not tmp then
29856: LD_VAR 0 2
29860: NOT
29861: IFFALSE 29865
// exit ;
29863: GO 29894
// for i in tmp do
29865: LD_ADDR_VAR 0 1
29869: PUSH
29870: LD_VAR 0 2
29874: PUSH
29875: FOR_IN
29876: IFFALSE 29892
// SetLives ( i , 1 ) ;
29878: LD_VAR 0 1
29882: PPUSH
29883: LD_INT 1
29885: PPUSH
29886: CALL_OW 234
29890: GO 29875
29892: POP
29893: POP
// end ;
29894: PPOPN 2
29896: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
29897: LD_EXP 63
29901: PUSH
29902: LD_EXP 112
29906: AND
29907: IFFALSE 30181
29909: GO 29911
29911: DISABLE
29912: LD_INT 0
29914: PPUSH
29915: PPUSH
29916: PPUSH
// begin i := rand ( 1 , 7 ) ;
29917: LD_ADDR_VAR 0 1
29921: PUSH
29922: LD_INT 1
29924: PPUSH
29925: LD_INT 7
29927: PPUSH
29928: CALL_OW 12
29932: ST_TO_ADDR
// case i of 1 :
29933: LD_VAR 0 1
29937: PUSH
29938: LD_INT 1
29940: DOUBLE
29941: EQUAL
29942: IFTRUE 29946
29944: GO 29956
29946: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
29947: LD_STRING earthquake(getX(game), 0, 32)
29949: PPUSH
29950: CALL_OW 559
29954: GO 30181
29956: LD_INT 2
29958: DOUBLE
29959: EQUAL
29960: IFTRUE 29964
29962: GO 29978
29964: POP
// begin ToLua ( displayStucuk(); ) ;
29965: LD_STRING displayStucuk();
29967: PPUSH
29968: CALL_OW 559
// ResetFog ;
29972: CALL_OW 335
// end ; 3 :
29976: GO 30181
29978: LD_INT 3
29980: DOUBLE
29981: EQUAL
29982: IFTRUE 29986
29984: GO 30090
29986: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
29987: LD_ADDR_VAR 0 2
29991: PUSH
29992: LD_INT 22
29994: PUSH
29995: LD_OWVAR 2
29999: PUSH
30000: EMPTY
30001: LIST
30002: LIST
30003: PUSH
30004: LD_INT 25
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PPUSH
30018: CALL_OW 69
30022: ST_TO_ADDR
// if not tmp then
30023: LD_VAR 0 2
30027: NOT
30028: IFFALSE 30032
// exit ;
30030: GO 30181
// un := tmp [ rand ( 1 , tmp ) ] ;
30032: LD_ADDR_VAR 0 3
30036: PUSH
30037: LD_VAR 0 2
30041: PUSH
30042: LD_INT 1
30044: PPUSH
30045: LD_VAR 0 2
30049: PPUSH
30050: CALL_OW 12
30054: ARRAY
30055: ST_TO_ADDR
// if Crawls ( un ) then
30056: LD_VAR 0 3
30060: PPUSH
30061: CALL_OW 318
30065: IFFALSE 30076
// ComWalk ( un ) ;
30067: LD_VAR 0 3
30071: PPUSH
30072: CALL_OW 138
// SetClass ( un , class_mortar ) ;
30076: LD_VAR 0 3
30080: PPUSH
30081: LD_INT 8
30083: PPUSH
30084: CALL_OW 336
// end ; 4 :
30088: GO 30181
30090: LD_INT 4
30092: DOUBLE
30093: EQUAL
30094: IFTRUE 30098
30096: GO 30159
30098: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
30099: LD_ADDR_VAR 0 2
30103: PUSH
30104: LD_INT 22
30106: PUSH
30107: LD_OWVAR 2
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 30
30118: PUSH
30119: LD_INT 29
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PPUSH
30130: CALL_OW 69
30134: ST_TO_ADDR
// if not tmp then
30135: LD_VAR 0 2
30139: NOT
30140: IFFALSE 30144
// exit ;
30142: GO 30181
// DestroyUnit ( tmp [ 1 ] ) ;
30144: LD_VAR 0 2
30148: PUSH
30149: LD_INT 1
30151: ARRAY
30152: PPUSH
30153: CALL_OW 65
// end ; 5 .. 7 :
30157: GO 30181
30159: LD_INT 5
30161: DOUBLE
30162: GREATEREQUAL
30163: IFFALSE 30171
30165: LD_INT 7
30167: DOUBLE
30168: LESSEQUAL
30169: IFTRUE 30173
30171: GO 30180
30173: POP
// StreamSibBomb ; end ;
30174: CALL 26431 0 0
30178: GO 30181
30180: POP
// end ;
30181: PPOPN 3
30183: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
30184: LD_EXP 63
30188: PUSH
30189: LD_EXP 113
30193: AND
30194: IFFALSE 30350
30196: GO 30198
30198: DISABLE
30199: LD_INT 0
30201: PPUSH
30202: PPUSH
30203: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
30204: LD_ADDR_VAR 0 2
30208: PUSH
30209: LD_INT 81
30211: PUSH
30212: LD_OWVAR 2
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 2
30223: PUSH
30224: LD_INT 21
30226: PUSH
30227: LD_INT 1
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 21
30236: PUSH
30237: LD_INT 2
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: EMPTY
30245: LIST
30246: LIST
30247: LIST
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: PPUSH
30253: CALL_OW 69
30257: ST_TO_ADDR
// if not tmp then
30258: LD_VAR 0 2
30262: NOT
30263: IFFALSE 30267
// exit ;
30265: GO 30350
// p := 0 ;
30267: LD_ADDR_VAR 0 3
30271: PUSH
30272: LD_INT 0
30274: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30275: LD_INT 35
30277: PPUSH
30278: CALL_OW 67
// p := p + 1 ;
30282: LD_ADDR_VAR 0 3
30286: PUSH
30287: LD_VAR 0 3
30291: PUSH
30292: LD_INT 1
30294: PLUS
30295: ST_TO_ADDR
// for i in tmp do
30296: LD_ADDR_VAR 0 1
30300: PUSH
30301: LD_VAR 0 2
30305: PUSH
30306: FOR_IN
30307: IFFALSE 30338
// if GetLives ( i ) < 1000 then
30309: LD_VAR 0 1
30313: PPUSH
30314: CALL_OW 256
30318: PUSH
30319: LD_INT 1000
30321: LESS
30322: IFFALSE 30336
// SetLives ( i , 1000 ) ;
30324: LD_VAR 0 1
30328: PPUSH
30329: LD_INT 1000
30331: PPUSH
30332: CALL_OW 234
30336: GO 30306
30338: POP
30339: POP
// until p > 20 ;
30340: LD_VAR 0 3
30344: PUSH
30345: LD_INT 20
30347: GREATER
30348: IFFALSE 30275
// end ;
30350: PPOPN 3
30352: END
// every 0 0$1 trigger StreamModeActive and sTime do
30353: LD_EXP 63
30357: PUSH
30358: LD_EXP 114
30362: AND
30363: IFFALSE 30398
30365: GO 30367
30367: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
30368: LD_INT 28
30370: PPUSH
30371: LD_OWVAR 2
30375: PPUSH
30376: LD_INT 2
30378: PPUSH
30379: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
30383: LD_INT 30
30385: PPUSH
30386: LD_OWVAR 2
30390: PPUSH
30391: LD_INT 2
30393: PPUSH
30394: CALL_OW 322
// end ;
30398: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
30399: LD_EXP 63
30403: PUSH
30404: LD_EXP 115
30408: AND
30409: IFFALSE 30530
30411: GO 30413
30413: DISABLE
30414: LD_INT 0
30416: PPUSH
30417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
30418: LD_ADDR_VAR 0 2
30422: PUSH
30423: LD_INT 22
30425: PUSH
30426: LD_OWVAR 2
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 21
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 3
30447: PUSH
30448: LD_INT 23
30450: PUSH
30451: LD_INT 0
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: PUSH
30462: EMPTY
30463: LIST
30464: LIST
30465: LIST
30466: PPUSH
30467: CALL_OW 69
30471: ST_TO_ADDR
// if not tmp then
30472: LD_VAR 0 2
30476: NOT
30477: IFFALSE 30481
// exit ;
30479: GO 30530
// for i in tmp do
30481: LD_ADDR_VAR 0 1
30485: PUSH
30486: LD_VAR 0 2
30490: PUSH
30491: FOR_IN
30492: IFFALSE 30528
// begin if Crawls ( i ) then
30494: LD_VAR 0 1
30498: PPUSH
30499: CALL_OW 318
30503: IFFALSE 30514
// ComWalk ( i ) ;
30505: LD_VAR 0 1
30509: PPUSH
30510: CALL_OW 138
// SetClass ( i , 2 ) ;
30514: LD_VAR 0 1
30518: PPUSH
30519: LD_INT 2
30521: PPUSH
30522: CALL_OW 336
// end ;
30526: GO 30491
30528: POP
30529: POP
// end ;
30530: PPOPN 2
30532: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
30533: LD_EXP 63
30537: PUSH
30538: LD_EXP 116
30542: AND
30543: IFFALSE 30824
30545: GO 30547
30547: DISABLE
30548: LD_INT 0
30550: PPUSH
30551: PPUSH
30552: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
30553: LD_OWVAR 2
30557: PPUSH
30558: LD_INT 9
30560: PPUSH
30561: LD_INT 1
30563: PPUSH
30564: LD_INT 1
30566: PPUSH
30567: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
30571: LD_INT 9
30573: PPUSH
30574: LD_OWVAR 2
30578: PPUSH
30579: CALL_OW 343
// uc_side := 9 ;
30583: LD_ADDR_OWVAR 20
30587: PUSH
30588: LD_INT 9
30590: ST_TO_ADDR
// uc_nation := 2 ;
30591: LD_ADDR_OWVAR 21
30595: PUSH
30596: LD_INT 2
30598: ST_TO_ADDR
// hc_name := Dark Warrior ;
30599: LD_ADDR_OWVAR 26
30603: PUSH
30604: LD_STRING Dark Warrior
30606: ST_TO_ADDR
// hc_gallery :=  ;
30607: LD_ADDR_OWVAR 33
30611: PUSH
30612: LD_STRING 
30614: ST_TO_ADDR
// hc_noskilllimit := true ;
30615: LD_ADDR_OWVAR 76
30619: PUSH
30620: LD_INT 1
30622: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
30623: LD_ADDR_OWVAR 31
30627: PUSH
30628: LD_INT 30
30630: PUSH
30631: LD_INT 30
30633: PUSH
30634: LD_INT 30
30636: PUSH
30637: LD_INT 30
30639: PUSH
30640: EMPTY
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: ST_TO_ADDR
// un := CreateHuman ;
30646: LD_ADDR_VAR 0 3
30650: PUSH
30651: CALL_OW 44
30655: ST_TO_ADDR
// hc_noskilllimit := false ;
30656: LD_ADDR_OWVAR 76
30660: PUSH
30661: LD_INT 0
30663: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
30664: LD_VAR 0 3
30668: PPUSH
30669: LD_INT 1
30671: PPUSH
30672: CALL_OW 51
// p := 0 ;
30676: LD_ADDR_VAR 0 2
30680: PUSH
30681: LD_INT 0
30683: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30684: LD_INT 35
30686: PPUSH
30687: CALL_OW 67
// p := p + 1 ;
30691: LD_ADDR_VAR 0 2
30695: PUSH
30696: LD_VAR 0 2
30700: PUSH
30701: LD_INT 1
30703: PLUS
30704: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
30705: LD_VAR 0 3
30709: PPUSH
30710: CALL_OW 256
30714: PUSH
30715: LD_INT 1000
30717: LESS
30718: IFFALSE 30732
// SetLives ( un , 1000 ) ;
30720: LD_VAR 0 3
30724: PPUSH
30725: LD_INT 1000
30727: PPUSH
30728: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
30732: LD_VAR 0 3
30736: PPUSH
30737: LD_INT 81
30739: PUSH
30740: LD_OWVAR 2
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: LD_INT 91
30751: PUSH
30752: LD_VAR 0 3
30756: PUSH
30757: LD_INT 30
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: LIST
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PPUSH
30769: CALL_OW 69
30773: PPUSH
30774: LD_VAR 0 3
30778: PPUSH
30779: CALL_OW 74
30783: PPUSH
30784: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
30788: LD_VAR 0 2
30792: PUSH
30793: LD_INT 60
30795: GREATER
30796: PUSH
30797: LD_VAR 0 3
30801: PPUSH
30802: CALL_OW 301
30806: OR
30807: IFFALSE 30684
// if un then
30809: LD_VAR 0 3
30813: IFFALSE 30824
// RemoveUnit ( un ) ;
30815: LD_VAR 0 3
30819: PPUSH
30820: CALL_OW 64
// end ;
30824: PPOPN 3
30826: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
30827: LD_INT 0
30829: PPUSH
30830: PPUSH
30831: PPUSH
30832: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
30833: LD_ADDR_VAR 0 4
30837: PUSH
30838: LD_INT 22
30840: PUSH
30841: LD_OWVAR 2
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 2
30852: PUSH
30853: LD_INT 30
30855: PUSH
30856: LD_INT 0
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 30
30865: PUSH
30866: LD_INT 1
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: LIST
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PPUSH
30882: CALL_OW 69
30886: ST_TO_ADDR
// if not tmp then
30887: LD_VAR 0 4
30891: NOT
30892: IFFALSE 30896
// exit ;
30894: GO 30955
// for i in tmp do
30896: LD_ADDR_VAR 0 2
30900: PUSH
30901: LD_VAR 0 4
30905: PUSH
30906: FOR_IN
30907: IFFALSE 30953
// for j = 1 to 3 do
30909: LD_ADDR_VAR 0 3
30913: PUSH
30914: DOUBLE
30915: LD_INT 1
30917: DEC
30918: ST_TO_ADDR
30919: LD_INT 3
30921: PUSH
30922: FOR_TO
30923: IFFALSE 30949
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
30925: LD_VAR 0 2
30929: PPUSH
30930: CALL_OW 274
30934: PPUSH
30935: LD_VAR 0 3
30939: PPUSH
30940: LD_INT 99999
30942: PPUSH
30943: CALL_OW 277
30947: GO 30922
30949: POP
30950: POP
30951: GO 30906
30953: POP
30954: POP
// end ;
30955: LD_VAR 0 1
30959: RET
// export function hHackSetLevel10 ; var i , j ; begin
30960: LD_INT 0
30962: PPUSH
30963: PPUSH
30964: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
30965: LD_ADDR_VAR 0 2
30969: PUSH
30970: LD_INT 21
30972: PUSH
30973: LD_INT 1
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PPUSH
30980: CALL_OW 69
30984: PUSH
30985: FOR_IN
30986: IFFALSE 31038
// if IsSelected ( i ) then
30988: LD_VAR 0 2
30992: PPUSH
30993: CALL_OW 306
30997: IFFALSE 31036
// begin for j := 1 to 4 do
30999: LD_ADDR_VAR 0 3
31003: PUSH
31004: DOUBLE
31005: LD_INT 1
31007: DEC
31008: ST_TO_ADDR
31009: LD_INT 4
31011: PUSH
31012: FOR_TO
31013: IFFALSE 31034
// SetSkill ( i , j , 10 ) ;
31015: LD_VAR 0 2
31019: PPUSH
31020: LD_VAR 0 3
31024: PPUSH
31025: LD_INT 10
31027: PPUSH
31028: CALL_OW 237
31032: GO 31012
31034: POP
31035: POP
// end ;
31036: GO 30985
31038: POP
31039: POP
// end ;
31040: LD_VAR 0 1
31044: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
31045: LD_INT 0
31047: PPUSH
31048: PPUSH
31049: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
31050: LD_ADDR_VAR 0 2
31054: PUSH
31055: LD_INT 22
31057: PUSH
31058: LD_OWVAR 2
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 21
31069: PUSH
31070: LD_INT 1
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PPUSH
31081: CALL_OW 69
31085: PUSH
31086: FOR_IN
31087: IFFALSE 31128
// begin for j := 1 to 4 do
31089: LD_ADDR_VAR 0 3
31093: PUSH
31094: DOUBLE
31095: LD_INT 1
31097: DEC
31098: ST_TO_ADDR
31099: LD_INT 4
31101: PUSH
31102: FOR_TO
31103: IFFALSE 31124
// SetSkill ( i , j , 10 ) ;
31105: LD_VAR 0 2
31109: PPUSH
31110: LD_VAR 0 3
31114: PPUSH
31115: LD_INT 10
31117: PPUSH
31118: CALL_OW 237
31122: GO 31102
31124: POP
31125: POP
// end ;
31126: GO 31086
31128: POP
31129: POP
// end ;
31130: LD_VAR 0 1
31134: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
31135: LD_INT 0
31137: PPUSH
// uc_side := your_side ;
31138: LD_ADDR_OWVAR 20
31142: PUSH
31143: LD_OWVAR 2
31147: ST_TO_ADDR
// uc_nation := nation ;
31148: LD_ADDR_OWVAR 21
31152: PUSH
31153: LD_VAR 0 1
31157: ST_TO_ADDR
// InitHc ;
31158: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
31162: LD_INT 0
31164: PPUSH
31165: LD_VAR 0 2
31169: PPUSH
31170: LD_VAR 0 3
31174: PPUSH
31175: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
31179: CALL_OW 44
31183: PPUSH
31184: LD_INT 1
31186: PPUSH
31187: CALL_OW 51
// end ;
31191: LD_VAR 0 4
31195: RET
// export function hHackSpawnVehicle ; begin
31196: LD_INT 0
31198: PPUSH
// uc_side := your_side ;
31199: LD_ADDR_OWVAR 20
31203: PUSH
31204: LD_OWVAR 2
31208: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
31209: LD_ADDR_OWVAR 21
31213: PUSH
31214: LD_INT 1
31216: PPUSH
31217: LD_INT 3
31219: PPUSH
31220: CALL_OW 12
31224: ST_TO_ADDR
// InitVc ;
31225: CALL_OW 20
// case uc_nation of 1 :
31229: LD_OWVAR 21
31233: PUSH
31234: LD_INT 1
31236: DOUBLE
31237: EQUAL
31238: IFTRUE 31242
31240: GO 31386
31242: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
31243: LD_ADDR_OWVAR 37
31247: PUSH
31248: LD_INT 1
31250: PUSH
31251: LD_INT 2
31253: PUSH
31254: LD_INT 3
31256: PUSH
31257: LD_INT 4
31259: PUSH
31260: LD_INT 5
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 1
31272: PPUSH
31273: LD_INT 5
31275: PPUSH
31276: CALL_OW 12
31280: ARRAY
31281: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31282: LD_ADDR_OWVAR 39
31286: PUSH
31287: LD_INT 1
31289: PPUSH
31290: LD_INT 3
31292: PPUSH
31293: CALL_OW 12
31297: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
31298: LD_ADDR_OWVAR 38
31302: PUSH
31303: LD_INT 1
31305: PUSH
31306: LD_INT 2
31308: PUSH
31309: LD_INT 3
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: LIST
31316: PUSH
31317: LD_INT 1
31319: PPUSH
31320: LD_INT 3
31322: PPUSH
31323: CALL_OW 12
31327: ARRAY
31328: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
31329: LD_ADDR_OWVAR 40
31333: PUSH
31334: LD_INT 2
31336: PUSH
31337: LD_INT 4
31339: PUSH
31340: LD_INT 5
31342: PUSH
31343: LD_INT 3
31345: PUSH
31346: LD_INT 7
31348: PUSH
31349: LD_INT 8
31351: PUSH
31352: LD_INT 9
31354: PUSH
31355: LD_INT 10
31357: PUSH
31358: LD_INT 6
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: PUSH
31372: LD_INT 1
31374: PPUSH
31375: LD_INT 9
31377: PPUSH
31378: CALL_OW 12
31382: ARRAY
31383: ST_TO_ADDR
// end ; 2 :
31384: GO 31651
31386: LD_INT 2
31388: DOUBLE
31389: EQUAL
31390: IFTRUE 31394
31392: GO 31518
31394: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
31395: LD_ADDR_OWVAR 37
31399: PUSH
31400: LD_INT 11
31402: PUSH
31403: LD_INT 12
31405: PUSH
31406: LD_INT 13
31408: PUSH
31409: LD_INT 14
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PPUSH
31421: LD_INT 4
31423: PPUSH
31424: CALL_OW 12
31428: ARRAY
31429: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31430: LD_ADDR_OWVAR 39
31434: PUSH
31435: LD_INT 1
31437: PPUSH
31438: LD_INT 3
31440: PPUSH
31441: CALL_OW 12
31445: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
31446: LD_ADDR_OWVAR 38
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: LD_INT 2
31456: PUSH
31457: LD_INT 5
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 1
31467: PPUSH
31468: LD_INT 3
31470: PPUSH
31471: CALL_OW 12
31475: ARRAY
31476: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
31477: LD_ADDR_OWVAR 40
31481: PUSH
31482: LD_INT 24
31484: PUSH
31485: LD_INT 26
31487: PUSH
31488: LD_INT 27
31490: PUSH
31491: LD_INT 28
31493: PUSH
31494: LD_INT 29
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 1
31506: PPUSH
31507: LD_INT 5
31509: PPUSH
31510: CALL_OW 12
31514: ARRAY
31515: ST_TO_ADDR
// end ; 3 :
31516: GO 31651
31518: LD_INT 3
31520: DOUBLE
31521: EQUAL
31522: IFTRUE 31526
31524: GO 31650
31526: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
31527: LD_ADDR_OWVAR 37
31531: PUSH
31532: LD_INT 21
31534: PUSH
31535: LD_INT 23
31537: PUSH
31538: LD_INT 22
31540: PUSH
31541: LD_INT 24
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 1
31552: PPUSH
31553: LD_INT 4
31555: PPUSH
31556: CALL_OW 12
31560: ARRAY
31561: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
31562: LD_ADDR_OWVAR 39
31566: PUSH
31567: LD_INT 1
31569: PPUSH
31570: LD_INT 3
31572: PPUSH
31573: CALL_OW 12
31577: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
31578: LD_ADDR_OWVAR 38
31582: PUSH
31583: LD_INT 1
31585: PUSH
31586: LD_INT 3
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: PPUSH
31596: LD_INT 2
31598: PPUSH
31599: CALL_OW 12
31603: ARRAY
31604: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
31605: LD_ADDR_OWVAR 40
31609: PUSH
31610: LD_INT 42
31612: PUSH
31613: LD_INT 43
31615: PUSH
31616: LD_INT 44
31618: PUSH
31619: LD_INT 46
31621: PUSH
31622: LD_INT 48
31624: PUSH
31625: LD_INT 47
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 1
31638: PPUSH
31639: LD_INT 6
31641: PPUSH
31642: CALL_OW 12
31646: ARRAY
31647: ST_TO_ADDR
// end ; end ;
31648: GO 31651
31650: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
31651: CALL_OW 45
31655: PPUSH
31656: LD_INT 1
31658: PPUSH
31659: CALL_OW 51
// end ;
31663: LD_VAR 0 1
31667: RET
// export hInvincible ; every 1 do
31668: GO 31670
31670: DISABLE
// hInvincible := [ ] ;
31671: LD_ADDR_EXP 117
31675: PUSH
31676: EMPTY
31677: ST_TO_ADDR
31678: END
// every 10 do var i ;
31679: GO 31681
31681: DISABLE
31682: LD_INT 0
31684: PPUSH
// begin enable ;
31685: ENABLE
// if not hInvincible then
31686: LD_EXP 117
31690: NOT
31691: IFFALSE 31695
// exit ;
31693: GO 31739
// for i in hInvincible do
31695: LD_ADDR_VAR 0 1
31699: PUSH
31700: LD_EXP 117
31704: PUSH
31705: FOR_IN
31706: IFFALSE 31737
// if GetLives ( i ) < 1000 then
31708: LD_VAR 0 1
31712: PPUSH
31713: CALL_OW 256
31717: PUSH
31718: LD_INT 1000
31720: LESS
31721: IFFALSE 31735
// SetLives ( i , 1000 ) ;
31723: LD_VAR 0 1
31727: PPUSH
31728: LD_INT 1000
31730: PPUSH
31731: CALL_OW 234
31735: GO 31705
31737: POP
31738: POP
// end ;
31739: PPOPN 1
31741: END
// export function hHackInvincible ; var i ; begin
31742: LD_INT 0
31744: PPUSH
31745: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
31746: LD_ADDR_VAR 0 2
31750: PUSH
31751: LD_INT 2
31753: PUSH
31754: LD_INT 21
31756: PUSH
31757: LD_INT 1
31759: PUSH
31760: EMPTY
31761: LIST
31762: LIST
31763: PUSH
31764: LD_INT 21
31766: PUSH
31767: LD_INT 2
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: LIST
31778: PPUSH
31779: CALL_OW 69
31783: PUSH
31784: FOR_IN
31785: IFFALSE 31846
// if IsSelected ( i ) then
31787: LD_VAR 0 2
31791: PPUSH
31792: CALL_OW 306
31796: IFFALSE 31844
// begin if i in hInvincible then
31798: LD_VAR 0 2
31802: PUSH
31803: LD_EXP 117
31807: IN
31808: IFFALSE 31828
// hInvincible := hInvincible diff i else
31810: LD_ADDR_EXP 117
31814: PUSH
31815: LD_EXP 117
31819: PUSH
31820: LD_VAR 0 2
31824: DIFF
31825: ST_TO_ADDR
31826: GO 31844
// hInvincible := hInvincible union i ;
31828: LD_ADDR_EXP 117
31832: PUSH
31833: LD_EXP 117
31837: PUSH
31838: LD_VAR 0 2
31842: UNION
31843: ST_TO_ADDR
// end ;
31844: GO 31784
31846: POP
31847: POP
// end ;
31848: LD_VAR 0 1
31852: RET
// export function hHackInvisible ; var i , j ; begin
31853: LD_INT 0
31855: PPUSH
31856: PPUSH
31857: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
31858: LD_ADDR_VAR 0 2
31862: PUSH
31863: LD_INT 21
31865: PUSH
31866: LD_INT 1
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PPUSH
31873: CALL_OW 69
31877: PUSH
31878: FOR_IN
31879: IFFALSE 31903
// if IsSelected ( i ) then
31881: LD_VAR 0 2
31885: PPUSH
31886: CALL_OW 306
31890: IFFALSE 31901
// ComForceInvisible ( i ) ;
31892: LD_VAR 0 2
31896: PPUSH
31897: CALL_OW 496
31901: GO 31878
31903: POP
31904: POP
// end ;
31905: LD_VAR 0 1
31909: RET
// export function hHackChangeYourSide ; begin
31910: LD_INT 0
31912: PPUSH
// if your_side = 8 then
31913: LD_OWVAR 2
31917: PUSH
31918: LD_INT 8
31920: EQUAL
31921: IFFALSE 31933
// your_side := 0 else
31923: LD_ADDR_OWVAR 2
31927: PUSH
31928: LD_INT 0
31930: ST_TO_ADDR
31931: GO 31947
// your_side := your_side + 1 ;
31933: LD_ADDR_OWVAR 2
31937: PUSH
31938: LD_OWVAR 2
31942: PUSH
31943: LD_INT 1
31945: PLUS
31946: ST_TO_ADDR
// end ;
31947: LD_VAR 0 1
31951: RET
// export function hHackChangeUnitSide ; var i , j ; begin
31952: LD_INT 0
31954: PPUSH
31955: PPUSH
31956: PPUSH
// for i in all_units do
31957: LD_ADDR_VAR 0 2
31961: PUSH
31962: LD_OWVAR 3
31966: PUSH
31967: FOR_IN
31968: IFFALSE 32046
// if IsSelected ( i ) then
31970: LD_VAR 0 2
31974: PPUSH
31975: CALL_OW 306
31979: IFFALSE 32044
// begin j := GetSide ( i ) ;
31981: LD_ADDR_VAR 0 3
31985: PUSH
31986: LD_VAR 0 2
31990: PPUSH
31991: CALL_OW 255
31995: ST_TO_ADDR
// if j = 8 then
31996: LD_VAR 0 3
32000: PUSH
32001: LD_INT 8
32003: EQUAL
32004: IFFALSE 32016
// j := 0 else
32006: LD_ADDR_VAR 0 3
32010: PUSH
32011: LD_INT 0
32013: ST_TO_ADDR
32014: GO 32030
// j := j + 1 ;
32016: LD_ADDR_VAR 0 3
32020: PUSH
32021: LD_VAR 0 3
32025: PUSH
32026: LD_INT 1
32028: PLUS
32029: ST_TO_ADDR
// SetSide ( i , j ) ;
32030: LD_VAR 0 2
32034: PPUSH
32035: LD_VAR 0 3
32039: PPUSH
32040: CALL_OW 235
// end ;
32044: GO 31967
32046: POP
32047: POP
// end ;
32048: LD_VAR 0 1
32052: RET
// export function hHackFog ; begin
32053: LD_INT 0
32055: PPUSH
// FogOff ( true ) ;
32056: LD_INT 1
32058: PPUSH
32059: CALL_OW 344
// end ;
32063: LD_VAR 0 1
32067: RET
// export function hHackApeman ; begin
32068: LD_INT 0
32070: PPUSH
// uc_side := your_side ;
32071: LD_ADDR_OWVAR 20
32075: PUSH
32076: LD_OWVAR 2
32080: ST_TO_ADDR
// uc_nation := 0 ;
32081: LD_ADDR_OWVAR 21
32085: PUSH
32086: LD_INT 0
32088: ST_TO_ADDR
// hc_name :=  ;
32089: LD_ADDR_OWVAR 26
32093: PUSH
32094: LD_STRING 
32096: ST_TO_ADDR
// hc_gallery :=  ;
32097: LD_ADDR_OWVAR 33
32101: PUSH
32102: LD_STRING 
32104: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
32105: LD_ADDR_OWVAR 31
32109: PUSH
32110: LD_INT 0
32112: PUSH
32113: LD_INT 0
32115: PUSH
32116: LD_INT 0
32118: PUSH
32119: LD_INT 0
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: LIST
32126: LIST
32127: ST_TO_ADDR
// hc_class := class_apeman ;
32128: LD_ADDR_OWVAR 28
32132: PUSH
32133: LD_INT 12
32135: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
32136: CALL_OW 44
32140: PPUSH
32141: LD_INT 1
32143: PPUSH
32144: CALL_OW 51
// end ;
32148: LD_VAR 0 1
32152: RET
// export function hHackBoom ; begin
32153: LD_INT 0
32155: PPUSH
// uc_side := your_side ;
32156: LD_ADDR_OWVAR 20
32160: PUSH
32161: LD_OWVAR 2
32165: ST_TO_ADDR
// uc_nation := 1 ;
32166: LD_ADDR_OWVAR 21
32170: PUSH
32171: LD_INT 1
32173: ST_TO_ADDR
// vc_chassis := us_morphling ;
32174: LD_ADDR_OWVAR 37
32178: PUSH
32179: LD_INT 5
32181: ST_TO_ADDR
// vc_engine := engine_siberite ;
32182: LD_ADDR_OWVAR 39
32186: PUSH
32187: LD_INT 3
32189: ST_TO_ADDR
// vc_control := control_computer ;
32190: LD_ADDR_OWVAR 38
32194: PUSH
32195: LD_INT 3
32197: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
32198: LD_ADDR_OWVAR 40
32202: PUSH
32203: LD_INT 8
32205: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
32206: CALL_OW 45
32210: PPUSH
32211: LD_INT 1
32213: PPUSH
32214: CALL_OW 51
// end ;
32218: LD_VAR 0 1
32222: RET
