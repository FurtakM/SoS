// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 25 0 0
// PrepareNature ;
   8: CALL 636 0 0
// PrepareArabian ;
  12: CALL 1951 0 0
// PrepareAmerican ;
  16: CALL 4869 0 0
// Action ;
  20: CALL 9405 0 0
// end ;
  24: END
// export debug , prefix , gameStarted , farmerBaseReady , americanBaseSpoted , americanBaseCaptured , americanHasEscaped , deadCounter , workshopBuilded , retreatAllowed , allowConvoys , farmerCrates , farmerRequestedCrates , farmerCratesCounter , firstConvoyDestroyed , attackWave , omarCargoCounter , vehCounter , convoyCounter , eventAttack , ibrahimInDepot , ibrahimIsFree , maxConvoys ; function Init ; begin
  25: LD_INT 0
  27: PPUSH
// debug := false ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_INT 0
  35: ST_TO_ADDR
// prefix := 02_ ;
  36: LD_ADDR_EXP 2
  40: PUSH
  41: LD_STRING 02_
  43: ST_TO_ADDR
// eventAttack := 1 ;
  44: LD_ADDR_EXP 20
  48: PUSH
  49: LD_INT 1
  51: ST_TO_ADDR
// deadCounter := 0 ;
  52: LD_ADDR_EXP 8
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// gameStarted := false ;
  60: LD_ADDR_EXP 3
  64: PUSH
  65: LD_INT 0
  67: ST_TO_ADDR
// farmerBaseReady := false ;
  68: LD_ADDR_EXP 4
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// americanBaseSpoted := false ;
  76: LD_ADDR_EXP 5
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// americanBaseCaptured := false ;
  84: LD_ADDR_EXP 6
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// americanHasEscaped := false ;
  92: LD_ADDR_EXP 7
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// workshopBuilded := false ;
 100: LD_ADDR_EXP 9
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// retreatAllowed := false ;
 108: LD_ADDR_EXP 10
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// allowConvoys := false ;
 116: LD_ADDR_EXP 11
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// farmerCrates := 0 ;
 124: LD_ADDR_EXP 12
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// farmerRequestedCrates := 0 ;
 132: LD_ADDR_EXP 13
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// farmerCratesCounter := [ 30 30$00 , 25 25$00 , 22 22$00 ] [ Difficulty ] ;
 140: LD_ADDR_EXP 14
 144: PUSH
 145: LD_INT 63000
 147: PUSH
 148: LD_INT 52500
 150: PUSH
 151: LD_INT 46200
 153: PUSH
 154: EMPTY
 155: LIST
 156: LIST
 157: LIST
 158: PUSH
 159: LD_OWVAR 67
 163: ARRAY
 164: ST_TO_ADDR
// firstConvoyDestroyed := false ;
 165: LD_ADDR_EXP 15
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// attackWave := 1 ;
 173: LD_ADDR_EXP 16
 177: PUSH
 178: LD_INT 1
 180: ST_TO_ADDR
// omarCargoCounter := [ 6 , 9 , 12 ] [ Difficulty ] ;
 181: LD_ADDR_EXP 17
 185: PUSH
 186: LD_INT 6
 188: PUSH
 189: LD_INT 9
 191: PUSH
 192: LD_INT 12
 194: PUSH
 195: EMPTY
 196: LIST
 197: LIST
 198: LIST
 199: PUSH
 200: LD_OWVAR 67
 204: ARRAY
 205: ST_TO_ADDR
// vehCounter := 0 ;
 206: LD_ADDR_EXP 18
 210: PUSH
 211: LD_INT 0
 213: ST_TO_ADDR
// convoyCounter := 0 ;
 214: LD_ADDR_EXP 19
 218: PUSH
 219: LD_INT 0
 221: ST_TO_ADDR
// ibrahimInDepot := false ;
 222: LD_ADDR_EXP 21
 226: PUSH
 227: LD_INT 0
 229: ST_TO_ADDR
// ibrahimIsFree := false ;
 230: LD_ADDR_EXP 22
 234: PUSH
 235: LD_INT 0
 237: ST_TO_ADDR
// maxConvoys := [ 16 , 15 , 14 ] [ Difficulty ] ;
 238: LD_ADDR_EXP 23
 242: PUSH
 243: LD_INT 16
 245: PUSH
 246: LD_INT 15
 248: PUSH
 249: LD_INT 14
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: PUSH
 257: LD_OWVAR 67
 261: ARRAY
 262: ST_TO_ADDR
// end ; end_of_file
 263: LD_VAR 0 1
 267: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 268: LD_INT 0
 270: PPUSH
 271: PPUSH
// if exist_mode then
 272: LD_VAR 0 2
 276: IFFALSE 301
// unit := CreateCharacter ( prefix & ident ) else
 278: LD_ADDR_VAR 0 5
 282: PUSH
 283: LD_VAR 0 3
 287: PUSH
 288: LD_VAR 0 1
 292: STR
 293: PPUSH
 294: CALL_OW 34
 298: ST_TO_ADDR
 299: GO 316
// unit := NewCharacter ( ident ) ;
 301: LD_ADDR_VAR 0 5
 305: PUSH
 306: LD_VAR 0 1
 310: PPUSH
 311: CALL_OW 25
 315: ST_TO_ADDR
// result := unit ;
 316: LD_ADDR_VAR 0 4
 320: PUSH
 321: LD_VAR 0 5
 325: ST_TO_ADDR
// end ;
 326: LD_VAR 0 4
 330: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 331: LD_INT 0
 333: PPUSH
// uc_side := side ;
 334: LD_ADDR_OWVAR 20
 338: PUSH
 339: LD_VAR 0 1
 343: ST_TO_ADDR
// uc_nation := nation ;
 344: LD_ADDR_OWVAR 21
 348: PUSH
 349: LD_VAR 0 2
 353: ST_TO_ADDR
// vc_chassis := chassis ;
 354: LD_ADDR_OWVAR 37
 358: PUSH
 359: LD_VAR 0 3
 363: ST_TO_ADDR
// vc_engine := engine ;
 364: LD_ADDR_OWVAR 39
 368: PUSH
 369: LD_VAR 0 4
 373: ST_TO_ADDR
// vc_control := control ;
 374: LD_ADDR_OWVAR 38
 378: PUSH
 379: LD_VAR 0 5
 383: ST_TO_ADDR
// vc_weapon := weapon ;
 384: LD_ADDR_OWVAR 40
 388: PUSH
 389: LD_VAR 0 6
 393: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 394: LD_ADDR_OWVAR 41
 398: PUSH
 399: LD_VAR 0 7
 403: ST_TO_ADDR
// result := CreateVehicle ;
 404: LD_ADDR_VAR 0 8
 408: PUSH
 409: CALL_OW 45
 413: ST_TO_ADDR
// end ;
 414: LD_VAR 0 8
 418: RET
// export function SayX ( units , ident ) ; var i ; begin
 419: LD_INT 0
 421: PPUSH
 422: PPUSH
// result := false ;
 423: LD_ADDR_VAR 0 3
 427: PUSH
 428: LD_INT 0
 430: ST_TO_ADDR
// if not units then
 431: LD_VAR 0 1
 435: NOT
 436: IFFALSE 440
// exit ;
 438: GO 494
// for i in units do
 440: LD_ADDR_VAR 0 4
 444: PUSH
 445: LD_VAR 0 1
 449: PUSH
 450: FOR_IN
 451: IFFALSE 492
// if IsOk ( i ) then
 453: LD_VAR 0 4
 457: PPUSH
 458: CALL_OW 302
 462: IFFALSE 490
// begin Say ( i , ident ) ;
 464: LD_VAR 0 4
 468: PPUSH
 469: LD_VAR 0 2
 473: PPUSH
 474: CALL_OW 88
// result := i ;
 478: LD_ADDR_VAR 0 3
 482: PUSH
 483: LD_VAR 0 4
 487: ST_TO_ADDR
// break ;
 488: GO 492
// end ;
 490: GO 450
 492: POP
 493: POP
// end ;
 494: LD_VAR 0 3
 498: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 499: LD_INT 0
 501: PPUSH
 502: PPUSH
// InitUc ;
 503: CALL_OW 18
// InitHc ;
 507: CALL_OW 19
// uc_side := 0 ;
 511: LD_ADDR_OWVAR 20
 515: PUSH
 516: LD_INT 0
 518: ST_TO_ADDR
// uc_nation := 0 ;
 519: LD_ADDR_OWVAR 21
 523: PUSH
 524: LD_INT 0
 526: ST_TO_ADDR
// for i = 1 to amount do
 527: LD_ADDR_VAR 0 4
 531: PUSH
 532: DOUBLE
 533: LD_INT 1
 535: DEC
 536: ST_TO_ADDR
 537: LD_VAR 0 2
 541: PUSH
 542: FOR_TO
 543: IFFALSE 625
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 545: LD_ADDR_OWVAR 29
 549: PUSH
 550: LD_INT 9
 552: PPUSH
 553: LD_INT 12
 555: PPUSH
 556: CALL_OW 12
 560: PUSH
 561: LD_INT 9
 563: PPUSH
 564: LD_INT 12
 566: PPUSH
 567: CALL_OW 12
 571: PUSH
 572: EMPTY
 573: LIST
 574: LIST
 575: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 576: LD_ADDR_OWVAR 35
 580: PUSH
 581: LD_INT 1
 583: NEG
 584: PPUSH
 585: LD_INT 1
 587: PPUSH
 588: CALL_OW 12
 592: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 593: LD_INT 0
 595: PPUSH
 596: LD_INT 12
 598: PPUSH
 599: LD_INT 1
 601: PPUSH
 602: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 606: CALL_OW 44
 610: PPUSH
 611: LD_VAR 0 1
 615: PPUSH
 616: LD_INT 0
 618: PPUSH
 619: CALL_OW 49
// end ;
 623: GO 542
 625: POP
 626: POP
// InitHc ;
 627: CALL_OW 19
// end ;
 631: LD_VAR 0 3
 635: RET
// export function PrepareNature ; var i ; begin
 636: LD_INT 0
 638: PPUSH
 639: PPUSH
// SpawnApeman ( forest , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
 640: LD_INT 2
 642: PPUSH
 643: LD_INT 4
 645: PUSH
 646: LD_INT 4
 648: PUSH
 649: LD_INT 3
 651: PUSH
 652: EMPTY
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: LD_OWVAR 67
 661: ARRAY
 662: PPUSH
 663: CALL 499 0 2
// for i := 1 to 3 do
 667: LD_ADDR_VAR 0 2
 671: PUSH
 672: DOUBLE
 673: LD_INT 1
 675: DEC
 676: ST_TO_ADDR
 677: LD_INT 3
 679: PUSH
 680: FOR_TO
 681: IFFALSE 716
// begin hc_class := 21 ;
 683: LD_ADDR_OWVAR 28
 687: PUSH
 688: LD_INT 21
 690: ST_TO_ADDR
// hc_gallery :=  ;
 691: LD_ADDR_OWVAR 33
 695: PUSH
 696: LD_STRING 
 698: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 699: CALL_OW 44
 703: PPUSH
 704: LD_INT 2
 706: PPUSH
 707: LD_INT 0
 709: PPUSH
 710: CALL_OW 49
// end ;
 714: GO 680
 716: POP
 717: POP
// for i := 1 to 2 do
 718: LD_ADDR_VAR 0 2
 722: PUSH
 723: DOUBLE
 724: LD_INT 1
 726: DEC
 727: ST_TO_ADDR
 728: LD_INT 2
 730: PUSH
 731: FOR_TO
 732: IFFALSE 767
// begin hc_class := 18 ;
 734: LD_ADDR_OWVAR 28
 738: PUSH
 739: LD_INT 18
 741: ST_TO_ADDR
// hc_gallery :=  ;
 742: LD_ADDR_OWVAR 33
 746: PUSH
 747: LD_STRING 
 749: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 750: CALL_OW 44
 754: PPUSH
 755: LD_INT 2
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 49
// end ;
 765: GO 731
 767: POP
 768: POP
// for i := 1 to 2 do
 769: LD_ADDR_VAR 0 2
 773: PUSH
 774: DOUBLE
 775: LD_INT 1
 777: DEC
 778: ST_TO_ADDR
 779: LD_INT 2
 781: PUSH
 782: FOR_TO
 783: IFFALSE 818
// begin hc_class := 13 ;
 785: LD_ADDR_OWVAR 28
 789: PUSH
 790: LD_INT 13
 792: ST_TO_ADDR
// hc_gallery :=  ;
 793: LD_ADDR_OWVAR 33
 797: PUSH
 798: LD_STRING 
 800: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 801: CALL_OW 44
 805: PPUSH
 806: LD_INT 2
 808: PPUSH
 809: LD_INT 0
 811: PPUSH
 812: CALL_OW 49
// end ;
 816: GO 782
 818: POP
 819: POP
// end ;
 820: LD_VAR 0 1
 824: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 825: LD_INT 0
 827: PPUSH
 828: PPUSH
 829: PPUSH
// if not observer or not unit then
 830: LD_VAR 0 1
 834: NOT
 835: PUSH
 836: LD_VAR 0 2
 840: NOT
 841: OR
 842: IFFALSE 846
// exit ;
 844: GO 894
// if not See ( GetSide ( observer ) , unit ) then
 846: LD_VAR 0 1
 850: PPUSH
 851: CALL_OW 255
 855: PPUSH
 856: LD_VAR 0 2
 860: PPUSH
 861: CALL_OW 292
 865: NOT
 866: IFFALSE 870
// exit ;
 868: GO 894
// result := GetDistUnits ( observer , unit ) < 12 ;
 870: LD_ADDR_VAR 0 3
 874: PUSH
 875: LD_VAR 0 1
 879: PPUSH
 880: LD_VAR 0 2
 884: PPUSH
 885: CALL_OW 296
 889: PUSH
 890: LD_INT 12
 892: LESS
 893: ST_TO_ADDR
// end ;
 894: LD_VAR 0 3
 898: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 899: LD_INT 0
 901: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 902: LD_VAR 0 2
 906: PUSH
 907: LD_INT 1
 909: ARRAY
 910: PPUSH
 911: LD_VAR 0 2
 915: PUSH
 916: LD_INT 2
 918: ARRAY
 919: PPUSH
 920: CALL_OW 488
 924: PUSH
 925: LD_VAR 0 2
 929: PUSH
 930: LD_INT 1
 932: ARRAY
 933: PPUSH
 934: LD_VAR 0 2
 938: PUSH
 939: LD_INT 2
 941: ARRAY
 942: PPUSH
 943: CALL_OW 428
 947: PUSH
 948: LD_INT 0
 950: EQUAL
 951: AND
 952: IFFALSE 986
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 954: LD_VAR 0 1
 958: PPUSH
 959: LD_VAR 0 2
 963: PUSH
 964: LD_INT 1
 966: ARRAY
 967: PPUSH
 968: LD_VAR 0 2
 972: PUSH
 973: LD_INT 2
 975: ARRAY
 976: PPUSH
 977: LD_VAR 0 3
 981: PPUSH
 982: CALL_OW 48
// end ;
 986: LD_VAR 0 4
 990: RET
// export function Video ( mode ) ; begin
 991: LD_INT 0
 993: PPUSH
// ingame_video = mode ;
 994: LD_ADDR_OWVAR 52
 998: PUSH
 999: LD_VAR 0 1
1003: ST_TO_ADDR
// interface_hidden = mode ;
1004: LD_ADDR_OWVAR 54
1008: PUSH
1009: LD_VAR 0 1
1013: ST_TO_ADDR
// end ;
1014: LD_VAR 0 2
1018: RET
// export function ReverseArray ( array ) ; var i ; begin
1019: LD_INT 0
1021: PPUSH
1022: PPUSH
// if not array then
1023: LD_VAR 0 1
1027: NOT
1028: IFFALSE 1032
// exit ;
1030: GO 1090
// result := [ ] ;
1032: LD_ADDR_VAR 0 2
1036: PUSH
1037: EMPTY
1038: ST_TO_ADDR
// for i := 1 to array do
1039: LD_ADDR_VAR 0 3
1043: PUSH
1044: DOUBLE
1045: LD_INT 1
1047: DEC
1048: ST_TO_ADDR
1049: LD_VAR 0 1
1053: PUSH
1054: FOR_TO
1055: IFFALSE 1088
// result := Insert ( result , 1 , array [ i ] ) ;
1057: LD_ADDR_VAR 0 2
1061: PUSH
1062: LD_VAR 0 2
1066: PPUSH
1067: LD_INT 1
1069: PPUSH
1070: LD_VAR 0 1
1074: PUSH
1075: LD_VAR 0 3
1079: ARRAY
1080: PPUSH
1081: CALL_OW 2
1085: ST_TO_ADDR
1086: GO 1054
1088: POP
1089: POP
// end ;
1090: LD_VAR 0 2
1094: RET
// export function ComExit ( unit ) ; begin
1095: LD_INT 0
1097: PPUSH
// result := IsInUnit ( unit ) ;
1098: LD_ADDR_VAR 0 2
1102: PUSH
1103: LD_VAR 0 1
1107: PPUSH
1108: CALL_OW 310
1112: ST_TO_ADDR
// if not result then
1113: LD_VAR 0 2
1117: NOT
1118: IFFALSE 1122
// exit ;
1120: GO 1157
// if GetType ( result ) = unit_vehicle then
1122: LD_VAR 0 2
1126: PPUSH
1127: CALL_OW 247
1131: PUSH
1132: LD_INT 2
1134: EQUAL
1135: IFFALSE 1148
// ComExitVehicle ( unit ) else
1137: LD_VAR 0 1
1141: PPUSH
1142: CALL_OW 121
1146: GO 1157
// ComExitBuilding ( unit ) ;
1148: LD_VAR 0 1
1152: PPUSH
1153: CALL_OW 122
// end ;
1157: LD_VAR 0 2
1161: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1162: LD_INT 0
1164: PPUSH
1165: PPUSH
// if not side or not nation then
1166: LD_VAR 0 1
1170: NOT
1171: PUSH
1172: LD_VAR 0 2
1176: NOT
1177: OR
1178: IFFALSE 1182
// exit ;
1180: GO 1946
// case nation of nation_american :
1182: LD_VAR 0 2
1186: PUSH
1187: LD_INT 1
1189: DOUBLE
1190: EQUAL
1191: IFTRUE 1195
1193: GO 1409
1195: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1196: LD_ADDR_VAR 0 4
1200: PUSH
1201: LD_INT 35
1203: PUSH
1204: LD_INT 45
1206: PUSH
1207: LD_INT 46
1209: PUSH
1210: LD_INT 47
1212: PUSH
1213: LD_INT 82
1215: PUSH
1216: LD_INT 83
1218: PUSH
1219: LD_INT 84
1221: PUSH
1222: LD_INT 85
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: LD_INT 6
1236: PUSH
1237: LD_INT 15
1239: PUSH
1240: LD_INT 16
1242: PUSH
1243: LD_INT 7
1245: PUSH
1246: LD_INT 12
1248: PUSH
1249: LD_INT 13
1251: PUSH
1252: LD_INT 10
1254: PUSH
1255: LD_INT 14
1257: PUSH
1258: LD_INT 20
1260: PUSH
1261: LD_INT 21
1263: PUSH
1264: LD_INT 22
1266: PUSH
1267: LD_INT 25
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 27
1275: PUSH
1276: LD_INT 36
1278: PUSH
1279: LD_INT 69
1281: PUSH
1282: LD_INT 39
1284: PUSH
1285: LD_INT 34
1287: PUSH
1288: LD_INT 40
1290: PUSH
1291: LD_INT 48
1293: PUSH
1294: LD_INT 49
1296: PUSH
1297: LD_INT 50
1299: PUSH
1300: LD_INT 51
1302: PUSH
1303: LD_INT 52
1305: PUSH
1306: LD_INT 53
1308: PUSH
1309: LD_INT 54
1311: PUSH
1312: LD_INT 55
1314: PUSH
1315: LD_INT 56
1317: PUSH
1318: LD_INT 57
1320: PUSH
1321: LD_INT 58
1323: PUSH
1324: LD_INT 59
1326: PUSH
1327: LD_INT 60
1329: PUSH
1330: LD_INT 61
1332: PUSH
1333: LD_INT 62
1335: PUSH
1336: LD_INT 80
1338: PUSH
1339: LD_INT 82
1341: PUSH
1342: LD_INT 83
1344: PUSH
1345: LD_INT 84
1347: PUSH
1348: LD_INT 85
1350: PUSH
1351: LD_INT 86
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: LIST
1366: LIST
1367: LIST
1368: LIST
1369: LIST
1370: LIST
1371: LIST
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: LIST
1384: LIST
1385: LIST
1386: LIST
1387: LIST
1388: LIST
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: LIST
1396: LIST
1397: LIST
1398: LIST
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: ST_TO_ADDR
1407: GO 1870
1409: LD_INT 2
1411: DOUBLE
1412: EQUAL
1413: IFTRUE 1417
1415: GO 1639
1417: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1418: LD_ADDR_VAR 0 4
1422: PUSH
1423: LD_INT 35
1425: PUSH
1426: LD_INT 45
1428: PUSH
1429: LD_INT 46
1431: PUSH
1432: LD_INT 47
1434: PUSH
1435: LD_INT 82
1437: PUSH
1438: LD_INT 83
1440: PUSH
1441: LD_INT 84
1443: PUSH
1444: LD_INT 85
1446: PUSH
1447: LD_INT 87
1449: PUSH
1450: LD_INT 70
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 11
1458: PUSH
1459: LD_INT 3
1461: PUSH
1462: LD_INT 4
1464: PUSH
1465: LD_INT 5
1467: PUSH
1468: LD_INT 6
1470: PUSH
1471: LD_INT 15
1473: PUSH
1474: LD_INT 18
1476: PUSH
1477: LD_INT 7
1479: PUSH
1480: LD_INT 17
1482: PUSH
1483: LD_INT 8
1485: PUSH
1486: LD_INT 20
1488: PUSH
1489: LD_INT 21
1491: PUSH
1492: LD_INT 22
1494: PUSH
1495: LD_INT 72
1497: PUSH
1498: LD_INT 26
1500: PUSH
1501: LD_INT 69
1503: PUSH
1504: LD_INT 39
1506: PUSH
1507: LD_INT 40
1509: PUSH
1510: LD_INT 41
1512: PUSH
1513: LD_INT 42
1515: PUSH
1516: LD_INT 43
1518: PUSH
1519: LD_INT 48
1521: PUSH
1522: LD_INT 49
1524: PUSH
1525: LD_INT 50
1527: PUSH
1528: LD_INT 51
1530: PUSH
1531: LD_INT 52
1533: PUSH
1534: LD_INT 53
1536: PUSH
1537: LD_INT 54
1539: PUSH
1540: LD_INT 55
1542: PUSH
1543: LD_INT 56
1545: PUSH
1546: LD_INT 60
1548: PUSH
1549: LD_INT 61
1551: PUSH
1552: LD_INT 62
1554: PUSH
1555: LD_INT 66
1557: PUSH
1558: LD_INT 67
1560: PUSH
1561: LD_INT 68
1563: PUSH
1564: LD_INT 81
1566: PUSH
1567: LD_INT 82
1569: PUSH
1570: LD_INT 83
1572: PUSH
1573: LD_INT 84
1575: PUSH
1576: LD_INT 85
1578: PUSH
1579: LD_INT 87
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: LIST
1588: LIST
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: LIST
1594: LIST
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: LIST
1603: LIST
1604: LIST
1605: LIST
1606: LIST
1607: LIST
1608: LIST
1609: LIST
1610: LIST
1611: LIST
1612: LIST
1613: LIST
1614: LIST
1615: LIST
1616: LIST
1617: LIST
1618: LIST
1619: LIST
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: ST_TO_ADDR
1637: GO 1870
1639: LD_INT 3
1641: DOUBLE
1642: EQUAL
1643: IFTRUE 1647
1645: GO 1869
1647: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1648: LD_ADDR_VAR 0 4
1652: PUSH
1653: LD_INT 46
1655: PUSH
1656: LD_INT 47
1658: PUSH
1659: LD_INT 1
1661: PUSH
1662: LD_INT 2
1664: PUSH
1665: LD_INT 82
1667: PUSH
1668: LD_INT 83
1670: PUSH
1671: LD_INT 84
1673: PUSH
1674: LD_INT 85
1676: PUSH
1677: LD_INT 86
1679: PUSH
1680: LD_INT 11
1682: PUSH
1683: LD_INT 9
1685: PUSH
1686: LD_INT 20
1688: PUSH
1689: LD_INT 19
1691: PUSH
1692: LD_INT 21
1694: PUSH
1695: LD_INT 24
1697: PUSH
1698: LD_INT 22
1700: PUSH
1701: LD_INT 25
1703: PUSH
1704: LD_INT 28
1706: PUSH
1707: LD_INT 29
1709: PUSH
1710: LD_INT 30
1712: PUSH
1713: LD_INT 31
1715: PUSH
1716: LD_INT 37
1718: PUSH
1719: LD_INT 38
1721: PUSH
1722: LD_INT 32
1724: PUSH
1725: LD_INT 27
1727: PUSH
1728: LD_INT 33
1730: PUSH
1731: LD_INT 69
1733: PUSH
1734: LD_INT 39
1736: PUSH
1737: LD_INT 34
1739: PUSH
1740: LD_INT 40
1742: PUSH
1743: LD_INT 71
1745: PUSH
1746: LD_INT 23
1748: PUSH
1749: LD_INT 44
1751: PUSH
1752: LD_INT 48
1754: PUSH
1755: LD_INT 49
1757: PUSH
1758: LD_INT 50
1760: PUSH
1761: LD_INT 51
1763: PUSH
1764: LD_INT 52
1766: PUSH
1767: LD_INT 53
1769: PUSH
1770: LD_INT 54
1772: PUSH
1773: LD_INT 55
1775: PUSH
1776: LD_INT 56
1778: PUSH
1779: LD_INT 57
1781: PUSH
1782: LD_INT 58
1784: PUSH
1785: LD_INT 59
1787: PUSH
1788: LD_INT 63
1790: PUSH
1791: LD_INT 64
1793: PUSH
1794: LD_INT 65
1796: PUSH
1797: LD_INT 82
1799: PUSH
1800: LD_INT 83
1802: PUSH
1803: LD_INT 84
1805: PUSH
1806: LD_INT 85
1808: PUSH
1809: LD_INT 86
1811: PUSH
1812: EMPTY
1813: LIST
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: LIST
1837: LIST
1838: LIST
1839: LIST
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: ST_TO_ADDR
1867: GO 1870
1869: POP
// if state > - 1 and state < 3 then
1870: LD_VAR 0 3
1874: PUSH
1875: LD_INT 1
1877: NEG
1878: GREATER
1879: PUSH
1880: LD_VAR 0 3
1884: PUSH
1885: LD_INT 3
1887: LESS
1888: AND
1889: IFFALSE 1946
// for i in result do
1891: LD_ADDR_VAR 0 5
1895: PUSH
1896: LD_VAR 0 4
1900: PUSH
1901: FOR_IN
1902: IFFALSE 1944
// if GetTech ( i , side ) <> state then
1904: LD_VAR 0 5
1908: PPUSH
1909: LD_VAR 0 1
1913: PPUSH
1914: CALL_OW 321
1918: PUSH
1919: LD_VAR 0 3
1923: NONEQUAL
1924: IFFALSE 1942
// result := result diff i ;
1926: LD_ADDR_VAR 0 4
1930: PUSH
1931: LD_VAR 0 4
1935: PUSH
1936: LD_VAR 0 5
1940: DIFF
1941: ST_TO_ADDR
1942: GO 1901
1944: POP
1945: POP
// end ; end_of_file
1946: LD_VAR 0 4
1950: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer , Omar , Ibrahim ; export farmerSquad , omarSquad , heikeSquad , heikeSecondSquad ; export omarCargo ; export function PrepareArabian ; var i , un , tmp ; begin
1951: LD_INT 0
1953: PPUSH
1954: PPUSH
1955: PPUSH
1956: PPUSH
// uc_side := 5 ;
1957: LD_ADDR_OWVAR 20
1961: PUSH
1962: LD_INT 5
1964: ST_TO_ADDR
// uc_nation := 2 ;
1965: LD_ADDR_OWVAR 21
1969: PUSH
1970: LD_INT 2
1972: ST_TO_ADDR
// SetResourceType ( GetBase ( arDepot ) , mat_cans , 45 ) ;
1973: LD_INT 5
1975: PPUSH
1976: CALL_OW 274
1980: PPUSH
1981: LD_INT 1
1983: PPUSH
1984: LD_INT 45
1986: PPUSH
1987: CALL_OW 277
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
1991: LD_ADDR_EXP 32
1995: PUSH
1996: LD_STRING Farmer
1998: PPUSH
1999: LD_INT 0
2001: PPUSH
2002: LD_STRING 
2004: PPUSH
2005: CALL 268 0 3
2009: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2010: LD_ADDR_EXP 33
2014: PUSH
2015: LD_STRING Omar
2017: PPUSH
2018: LD_INT 0
2020: PPUSH
2021: LD_STRING 
2023: PPUSH
2024: CALL 268 0 3
2028: ST_TO_ADDR
// omarSquad := [ ] ;
2029: LD_ADDR_EXP 36
2033: PUSH
2034: EMPTY
2035: ST_TO_ADDR
// heikeSquad := [ ] ;
2036: LD_ADDR_EXP 37
2040: PUSH
2041: EMPTY
2042: ST_TO_ADDR
// heikeSecondSquad := [ ] ;
2043: LD_ADDR_EXP 38
2047: PUSH
2048: EMPTY
2049: ST_TO_ADDR
// omarCargo := [ ] ;
2050: LD_ADDR_EXP 39
2054: PUSH
2055: EMPTY
2056: ST_TO_ADDR
// for i := 1 to 5 do
2057: LD_ADDR_VAR 0 2
2061: PUSH
2062: DOUBLE
2063: LD_INT 1
2065: DEC
2066: ST_TO_ADDR
2067: LD_INT 5
2069: PUSH
2070: FOR_TO
2071: IFFALSE 2229
// begin PrepareHuman ( false , [ 1 , 1 , 2 , 1 , 1 ] [ i ] , 3 ) ;
2073: LD_INT 0
2075: PPUSH
2076: LD_INT 1
2078: PUSH
2079: LD_INT 1
2081: PUSH
2082: LD_INT 2
2084: PUSH
2085: LD_INT 1
2087: PUSH
2088: LD_INT 1
2090: PUSH
2091: EMPTY
2092: LIST
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_VAR 0 2
2102: ARRAY
2103: PPUSH
2104: LD_INT 3
2106: PPUSH
2107: CALL_OW 380
// un := CreateHuman ;
2111: LD_ADDR_VAR 0 3
2115: PUSH
2116: CALL_OW 44
2120: ST_TO_ADDR
// omarSquad := omarSquad union un ;
2121: LD_ADDR_EXP 36
2125: PUSH
2126: LD_EXP 36
2130: PUSH
2131: LD_VAR 0 3
2135: UNION
2136: ST_TO_ADDR
// PlaceUnitHex ( un , [ [ 87 , 30 ] , [ 91 , 32 ] , [ 82 , 15 ] , [ 79 , 14 ] , [ 82 , 13 ] ] [ i ] , false ) ;
2137: LD_VAR 0 3
2141: PPUSH
2142: LD_INT 87
2144: PUSH
2145: LD_INT 30
2147: PUSH
2148: EMPTY
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 91
2154: PUSH
2155: LD_INT 32
2157: PUSH
2158: EMPTY
2159: LIST
2160: LIST
2161: PUSH
2162: LD_INT 82
2164: PUSH
2165: LD_INT 15
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: PUSH
2172: LD_INT 79
2174: PUSH
2175: LD_INT 14
2177: PUSH
2178: EMPTY
2179: LIST
2180: LIST
2181: PUSH
2182: LD_INT 82
2184: PUSH
2185: LD_INT 13
2187: PUSH
2188: EMPTY
2189: LIST
2190: LIST
2191: PUSH
2192: EMPTY
2193: LIST
2194: LIST
2195: LIST
2196: LIST
2197: LIST
2198: PUSH
2199: LD_VAR 0 2
2203: ARRAY
2204: PPUSH
2205: LD_INT 0
2207: PPUSH
2208: CALL 899 0 3
// ComTurnXY ( un , 93 , 21 ) ;
2212: LD_VAR 0 3
2216: PPUSH
2217: LD_INT 93
2219: PPUSH
2220: LD_INT 21
2222: PPUSH
2223: CALL_OW 118
// end ;
2227: GO 2070
2229: POP
2230: POP
// uc_side := 2 ;
2231: LD_ADDR_OWVAR 20
2235: PUSH
2236: LD_INT 2
2238: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2239: LD_ADDR_EXP 24
2243: PUSH
2244: LD_STRING Heike
2246: PPUSH
2247: LD_EXP 1
2251: NOT
2252: PPUSH
2253: LD_EXP 2
2257: PPUSH
2258: CALL 268 0 3
2262: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2263: LD_ADDR_EXP 28
2267: PUSH
2268: LD_STRING Aviradze
2270: PPUSH
2271: LD_EXP 1
2275: NOT
2276: PPUSH
2277: LD_EXP 2
2281: PPUSH
2282: CALL 268 0 3
2286: ST_TO_ADDR
// tmp := [ ] ;
2287: LD_ADDR_VAR 0 4
2291: PUSH
2292: EMPTY
2293: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2294: LD_ADDR_EXP 25
2298: PUSH
2299: LD_STRING Givi
2301: PPUSH
2302: LD_EXP 1
2306: NOT
2307: PPUSH
2308: LD_EXP 2
2312: PPUSH
2313: CALL 268 0 3
2317: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2318: LD_ADDR_EXP 26
2322: PUSH
2323: LD_STRING Mike
2325: PPUSH
2326: LD_EXP 1
2330: NOT
2331: PPUSH
2332: LD_EXP 2
2336: PPUSH
2337: CALL 268 0 3
2341: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2342: LD_ADDR_EXP 27
2346: PUSH
2347: LD_STRING Kamil
2349: PPUSH
2350: LD_EXP 1
2354: NOT
2355: PPUSH
2356: LD_EXP 2
2360: PPUSH
2361: CALL 268 0 3
2365: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2366: LD_ADDR_EXP 29
2370: PUSH
2371: LD_STRING Kaia
2373: PPUSH
2374: LD_EXP 1
2378: NOT
2379: PPUSH
2380: LD_EXP 2
2384: PPUSH
2385: CALL 268 0 3
2389: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2390: LD_ADDR_EXP 30
2394: PUSH
2395: LD_STRING Sophia
2397: PPUSH
2398: LD_EXP 1
2402: NOT
2403: PPUSH
2404: LD_EXP 2
2408: PPUSH
2409: CALL 268 0 3
2413: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2414: LD_ADDR_EXP 31
2418: PUSH
2419: LD_STRING Markov
2421: PPUSH
2422: LD_EXP 1
2426: NOT
2427: PPUSH
2428: LD_EXP 2
2432: PPUSH
2433: CALL 268 0 3
2437: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 02_others ) ;
2438: LD_ADDR_EXP 38
2442: PUSH
2443: LD_STRING 02_others
2445: PPUSH
2446: CALL_OW 31
2450: ST_TO_ADDR
// tmp := [ Mike , Kamil , Kaia , Sophia , Markov , Givi ] ^ heikeSecondSquad diff 0 ;
2451: LD_ADDR_VAR 0 4
2455: PUSH
2456: LD_EXP 26
2460: PUSH
2461: LD_EXP 27
2465: PUSH
2466: LD_EXP 29
2470: PUSH
2471: LD_EXP 30
2475: PUSH
2476: LD_EXP 31
2480: PUSH
2481: LD_EXP 25
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: LIST
2490: LIST
2491: LIST
2492: LIST
2493: PUSH
2494: LD_EXP 38
2498: ADD
2499: PUSH
2500: LD_INT 0
2502: DIFF
2503: ST_TO_ADDR
// heikeSquad := tmp ;
2504: LD_ADDR_EXP 37
2508: PUSH
2509: LD_VAR 0 4
2513: ST_TO_ADDR
// uc_nation := 0 ;
2514: LD_ADDR_OWVAR 21
2518: PUSH
2519: LD_INT 0
2521: ST_TO_ADDR
// hc_class := class_apeman ;
2522: LD_ADDR_OWVAR 28
2526: PUSH
2527: LD_INT 12
2529: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
2530: LD_ADDR_OWVAR 31
2534: PUSH
2535: LD_INT 0
2537: PUSH
2538: LD_INT 0
2540: PUSH
2541: LD_INT 0
2543: PUSH
2544: LD_INT 0
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: ST_TO_ADDR
// hc_gallery :=  ;
2553: LD_ADDR_OWVAR 33
2557: PUSH
2558: LD_STRING 
2560: ST_TO_ADDR
// hc_name :=  ;
2561: LD_ADDR_OWVAR 26
2565: PUSH
2566: LD_STRING 
2568: ST_TO_ADDR
// tmp := tmp union CreateHuman ;
2569: LD_ADDR_VAR 0 4
2573: PUSH
2574: LD_VAR 0 4
2578: PUSH
2579: CALL_OW 44
2583: UNION
2584: ST_TO_ADDR
// PlaceUnitXY ( Heike , 92 , 17 , false ) ;
2585: LD_EXP 24
2589: PPUSH
2590: LD_INT 92
2592: PPUSH
2593: LD_INT 17
2595: PPUSH
2596: LD_INT 0
2598: PPUSH
2599: CALL_OW 48
// PlaceUnitXY ( Farmer , 95 , 19 , false ) ;
2603: LD_EXP 32
2607: PPUSH
2608: LD_INT 95
2610: PPUSH
2611: LD_INT 19
2613: PPUSH
2614: LD_INT 0
2616: PPUSH
2617: CALL_OW 48
// PlaceUnitXY ( Omar , 89 , 25 , false ) ;
2621: LD_EXP 33
2625: PPUSH
2626: LD_INT 89
2628: PPUSH
2629: LD_INT 25
2631: PPUSH
2632: LD_INT 0
2634: PPUSH
2635: CALL_OW 48
// PlaceUnitXY ( Aviradze , 92 , 27 , false ) ;
2639: LD_EXP 28
2643: PPUSH
2644: LD_INT 92
2646: PPUSH
2647: LD_INT 27
2649: PPUSH
2650: LD_INT 0
2652: PPUSH
2653: CALL_OW 48
// ComTurnUnit ( Omar , Aviradze ) ;
2657: LD_EXP 33
2661: PPUSH
2662: LD_EXP 28
2666: PPUSH
2667: CALL_OW 119
// ComTurnUnit ( Aviradze , Omar ) ;
2671: LD_EXP 28
2675: PPUSH
2676: LD_EXP 33
2680: PPUSH
2681: CALL_OW 119
// ComTurnUnit ( [ Heike , Farmer ] , Omar ) ;
2685: LD_EXP 24
2689: PUSH
2690: LD_EXP 32
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: PPUSH
2699: LD_EXP 33
2703: PPUSH
2704: CALL_OW 119
// if tmp then
2708: LD_VAR 0 4
2712: IFFALSE 2766
// for i in tmp do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: LD_VAR 0 4
2723: PUSH
2724: FOR_IN
2725: IFFALSE 2764
// begin PlaceUnitXYR ( i , 94 , 14 , 4 , false ) ;
2727: LD_VAR 0 2
2731: PPUSH
2732: LD_INT 94
2734: PPUSH
2735: LD_INT 14
2737: PPUSH
2738: LD_INT 4
2740: PPUSH
2741: LD_INT 0
2743: PPUSH
2744: CALL_OW 50
// ComTurnUnit ( i , Heike ) ;
2748: LD_VAR 0 2
2752: PPUSH
2753: LD_EXP 24
2757: PPUSH
2758: CALL_OW 119
// end ;
2762: GO 2724
2764: POP
2765: POP
// farmerSquad := [ ] ;
2766: LD_ADDR_EXP 35
2770: PUSH
2771: EMPTY
2772: ST_TO_ADDR
// uc_side := 5 ;
2773: LD_ADDR_OWVAR 20
2777: PUSH
2778: LD_INT 5
2780: ST_TO_ADDR
// uc_nation := 2 ;
2781: LD_ADDR_OWVAR 21
2785: PUSH
2786: LD_INT 2
2788: ST_TO_ADDR
// for i := 1 to 4 do
2789: LD_ADDR_VAR 0 2
2793: PUSH
2794: DOUBLE
2795: LD_INT 1
2797: DEC
2798: ST_TO_ADDR
2799: LD_INT 4
2801: PUSH
2802: FOR_TO
2803: IFFALSE 2881
// begin PrepareHuman ( false , 1 , 2 ) ;
2805: LD_INT 0
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_INT 2
2813: PPUSH
2814: CALL_OW 380
// un := CreateHuman ;
2818: LD_ADDR_VAR 0 3
2822: PUSH
2823: CALL_OW 44
2827: ST_TO_ADDR
// PlaceUnitXYR ( un , 102 , 27 , 4 , false ) ;
2828: LD_VAR 0 3
2832: PPUSH
2833: LD_INT 102
2835: PPUSH
2836: LD_INT 27
2838: PPUSH
2839: LD_INT 4
2841: PPUSH
2842: LD_INT 0
2844: PPUSH
2845: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2849: LD_ADDR_EXP 35
2853: PUSH
2854: LD_EXP 35
2858: PUSH
2859: LD_VAR 0 3
2863: UNION
2864: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2865: LD_VAR 0 3
2869: PPUSH
2870: LD_EXP 33
2874: PPUSH
2875: CALL_OW 119
// end ;
2879: GO 2802
2881: POP
2882: POP
// PrepareHuman ( false , 2 , 2 ) ;
2883: LD_INT 0
2885: PPUSH
2886: LD_INT 2
2888: PPUSH
2889: LD_INT 2
2891: PPUSH
2892: CALL_OW 380
// un := CreateHuman ;
2896: LD_ADDR_VAR 0 3
2900: PUSH
2901: CALL_OW 44
2905: ST_TO_ADDR
// PlaceUnitXYR ( un , 108 , 62 , 2 , false ) ;
2906: LD_VAR 0 3
2910: PPUSH
2911: LD_INT 108
2913: PPUSH
2914: LD_INT 62
2916: PPUSH
2917: LD_INT 2
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: CALL_OW 50
// farmerSquad := farmerSquad union un ;
2927: LD_ADDR_EXP 35
2931: PUSH
2932: LD_EXP 35
2936: PUSH
2937: LD_VAR 0 3
2941: UNION
2942: ST_TO_ADDR
// ComTurnUnit ( un , Omar ) ;
2943: LD_VAR 0 3
2947: PPUSH
2948: LD_EXP 33
2952: PPUSH
2953: CALL_OW 119
// PlaceSeeing ( 109 , 63 , 2 , - 15 ) ;
2957: LD_INT 109
2959: PPUSH
2960: LD_INT 63
2962: PPUSH
2963: LD_INT 2
2965: PPUSH
2966: LD_INT 15
2968: NEG
2969: PPUSH
2970: CALL_OW 330
// RemoveSeeing ( 109 , 63 , 2 ) ;
2974: LD_INT 109
2976: PPUSH
2977: LD_INT 63
2979: PPUSH
2980: LD_INT 2
2982: PPUSH
2983: CALL_OW 331
// end ;
2987: LD_VAR 0 1
2991: RET
// export function PrepareIbrahim ( x , y ) ; begin
2992: LD_INT 0
2994: PPUSH
// uc_side := 6 ;
2995: LD_ADDR_OWVAR 20
2999: PUSH
3000: LD_INT 6
3002: ST_TO_ADDR
// uc_nation := 3 ;
3003: LD_ADDR_OWVAR 21
3007: PUSH
3008: LD_INT 3
3010: ST_TO_ADDR
// Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3011: LD_ADDR_EXP 34
3015: PUSH
3016: LD_STRING IbrahimRu
3018: PPUSH
3019: LD_INT 0
3021: PPUSH
3022: LD_STRING 
3024: PPUSH
3025: CALL 268 0 3
3029: ST_TO_ADDR
// PlaceUnitXYR ( Ibrahim , x , y , 8 , true ) ;
3030: LD_EXP 34
3034: PPUSH
3035: LD_VAR 0 1
3039: PPUSH
3040: LD_VAR 0 2
3044: PPUSH
3045: LD_INT 8
3047: PPUSH
3048: LD_INT 1
3050: PPUSH
3051: CALL_OW 50
// end ;
3055: LD_VAR 0 3
3059: RET
// every 0 0$1 trigger UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do var i ;
3060: LD_EXP 33
3064: PUSH
3065: LD_EXP 36
3069: ADD
3070: PPUSH
3071: LD_INT 95
3073: PUSH
3074: LD_INT 3
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: PPUSH
3081: CALL_OW 72
3085: IFFALSE 3141
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
// begin enable ;
3093: ENABLE
// for i in UnitFilter ( Omar ^ omarSquad , [ f_inarea , northRoad ] ) do
3094: LD_ADDR_VAR 0 1
3098: PUSH
3099: LD_EXP 33
3103: PUSH
3104: LD_EXP 36
3108: ADD
3109: PPUSH
3110: LD_INT 95
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL_OW 72
3124: PUSH
3125: FOR_IN
3126: IFFALSE 3139
// RemoveUnit ( i ) ;
3128: LD_VAR 0 1
3132: PPUSH
3133: CALL_OW 64
3137: GO 3125
3139: POP
3140: POP
// end ;
3141: PPOPN 1
3143: END
// every 0 0$3 trigger gameStarted and IsInArea ( Farmer , farmerBase ) do var i , tmp , arm , bun ;
3144: LD_EXP 3
3148: PUSH
3149: LD_EXP 32
3153: PPUSH
3154: LD_INT 4
3156: PPUSH
3157: CALL_OW 308
3161: AND
3162: IFFALSE 3945
3164: GO 3166
3166: DISABLE
3167: LD_INT 0
3169: PPUSH
3170: PPUSH
3171: PPUSH
3172: PPUSH
// begin ComMoveXY ( Farmer , 110 , 60 ) ;
3173: LD_EXP 32
3177: PPUSH
3178: LD_INT 110
3180: PPUSH
3181: LD_INT 60
3183: PPUSH
3184: CALL_OW 111
// AddComTurnXY ( Farmer , 110 , 61 ) ;
3188: LD_EXP 32
3192: PPUSH
3193: LD_INT 110
3195: PPUSH
3196: LD_INT 61
3198: PPUSH
3199: CALL_OW 178
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3203: LD_ADDR_VAR 0 2
3207: PUSH
3208: LD_EXP 35
3212: PPUSH
3213: LD_INT 25
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL_OW 72
3227: ST_TO_ADDR
// if tmp then
3228: LD_VAR 0 2
3232: IFFALSE 3326
// begin for i := 1 to 2 do
3234: LD_ADDR_VAR 0 1
3238: PUSH
3239: DOUBLE
3240: LD_INT 1
3242: DEC
3243: ST_TO_ADDR
3244: LD_INT 2
3246: PUSH
3247: FOR_TO
3248: IFFALSE 3324
// begin ComEnterUnit ( tmp [ i ] , arDepot ) ;
3250: LD_VAR 0 2
3254: PUSH
3255: LD_VAR 0 1
3259: ARRAY
3260: PPUSH
3261: LD_INT 5
3263: PPUSH
3264: CALL_OW 120
// AddComChangeProfession ( tmp [ i ] , class_engineer ) ;
3268: LD_VAR 0 2
3272: PUSH
3273: LD_VAR 0 1
3277: ARRAY
3278: PPUSH
3279: LD_INT 2
3281: PPUSH
3282: CALL_OW 183
// AddComExitBuilding ( tmp [ i ] ) ;
3286: LD_VAR 0 2
3290: PUSH
3291: LD_VAR 0 1
3295: ARRAY
3296: PPUSH
3297: CALL_OW 182
// AddComMoveXY ( tmp [ i ] , 107 , 66 ) ;
3301: LD_VAR 0 2
3305: PUSH
3306: LD_VAR 0 1
3310: ARRAY
3311: PPUSH
3312: LD_INT 107
3314: PPUSH
3315: LD_INT 66
3317: PPUSH
3318: CALL_OW 171
// end ;
3322: GO 3247
3324: POP
3325: POP
// end ; tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3326: LD_ADDR_VAR 0 2
3330: PUSH
3331: LD_EXP 35
3335: PPUSH
3336: LD_INT 25
3338: PUSH
3339: LD_INT 2
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PPUSH
3346: CALL_OW 72
3350: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3351: LD_INT 35
3353: PPUSH
3354: CALL_OW 67
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3358: LD_ADDR_VAR 0 2
3362: PUSH
3363: LD_EXP 35
3367: PPUSH
3368: LD_INT 25
3370: PUSH
3371: LD_INT 2
3373: PUSH
3374: EMPTY
3375: LIST
3376: LIST
3377: PPUSH
3378: CALL_OW 72
3382: ST_TO_ADDR
// until tmp ;
3383: LD_VAR 0 2
3387: IFFALSE 3351
// ComBuild ( tmp , b_breastwork , 102 , 69 , 2 ) ;
3389: LD_VAR 0 2
3393: PPUSH
3394: LD_INT 31
3396: PPUSH
3397: LD_INT 102
3399: PPUSH
3400: LD_INT 69
3402: PPUSH
3403: LD_INT 2
3405: PPUSH
3406: CALL_OW 145
// repeat wait ( 0 0$1 ) ;
3410: LD_INT 35
3412: PPUSH
3413: CALL_OW 67
// until UnitFilter ( farmerSquad , [ [ f_not , [ f_hastask ] ] , [ f_class , 2 ] ] ) ;
3417: LD_EXP 35
3421: PPUSH
3422: LD_INT 3
3424: PUSH
3425: LD_INT 60
3427: PUSH
3428: EMPTY
3429: LIST
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: PUSH
3435: LD_INT 25
3437: PUSH
3438: LD_INT 2
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: PPUSH
3449: CALL_OW 72
3453: IFFALSE 3410
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3455: LD_ADDR_VAR 0 2
3459: PUSH
3460: LD_EXP 35
3464: PPUSH
3465: LD_INT 25
3467: PUSH
3468: LD_INT 2
3470: PUSH
3471: EMPTY
3472: LIST
3473: LIST
3474: PPUSH
3475: CALL_OW 72
3479: ST_TO_ADDR
// AddComBuild ( tmp , b_armoury , 116 , 70 , 5 ) ;
3480: LD_VAR 0 2
3484: PPUSH
3485: LD_INT 4
3487: PPUSH
3488: LD_INT 116
3490: PPUSH
3491: LD_INT 70
3493: PPUSH
3494: LD_INT 5
3496: PPUSH
3497: CALL_OW 205
// AddComBuild ( tmp , b_breastwork , 108 , 50 , 2 ) ;
3501: LD_VAR 0 2
3505: PPUSH
3506: LD_INT 31
3508: PPUSH
3509: LD_INT 108
3511: PPUSH
3512: LD_INT 50
3514: PPUSH
3515: LD_INT 2
3517: PPUSH
3518: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
3522: LD_INT 35
3524: PPUSH
3525: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) ;
3529: LD_INT 22
3531: PUSH
3532: LD_INT 5
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: PUSH
3539: LD_INT 30
3541: PUSH
3542: LD_INT 4
3544: PUSH
3545: EMPTY
3546: LIST
3547: LIST
3548: PUSH
3549: LD_INT 3
3551: PUSH
3552: LD_INT 57
3554: PUSH
3555: EMPTY
3556: LIST
3557: PUSH
3558: EMPTY
3559: LIST
3560: LIST
3561: PUSH
3562: EMPTY
3563: LIST
3564: LIST
3565: LIST
3566: PPUSH
3567: CALL_OW 69
3571: IFFALSE 3522
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] , [ f_not , [ f_constructed ] ] ] ) [ 1 ] ;
3573: LD_ADDR_VAR 0 3
3577: PUSH
3578: LD_INT 22
3580: PUSH
3581: LD_INT 5
3583: PUSH
3584: EMPTY
3585: LIST
3586: LIST
3587: PUSH
3588: LD_INT 30
3590: PUSH
3591: LD_INT 4
3593: PUSH
3594: EMPTY
3595: LIST
3596: LIST
3597: PUSH
3598: LD_INT 3
3600: PUSH
3601: LD_INT 57
3603: PUSH
3604: EMPTY
3605: LIST
3606: PUSH
3607: EMPTY
3608: LIST
3609: LIST
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: LIST
3615: PPUSH
3616: CALL_OW 69
3620: PUSH
3621: LD_INT 1
3623: ARRAY
3624: ST_TO_ADDR
// tmp := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ;
3625: LD_ADDR_VAR 0 2
3629: PUSH
3630: LD_EXP 35
3634: PPUSH
3635: LD_INT 25
3637: PUSH
3638: LD_INT 1
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PPUSH
3645: CALL_OW 72
3649: ST_TO_ADDR
// ComEnterUnit ( tmp , arm ) ;
3650: LD_VAR 0 2
3654: PPUSH
3655: LD_VAR 0 3
3659: PPUSH
3660: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
3664: LD_INT 35
3666: PPUSH
3667: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] , [ f_not , [ f_constructed ] ] ] ) >= 2 ;
3671: LD_INT 22
3673: PUSH
3674: LD_INT 5
3676: PUSH
3677: EMPTY
3678: LIST
3679: LIST
3680: PUSH
3681: LD_INT 30
3683: PUSH
3684: LD_INT 31
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: PUSH
3691: LD_INT 3
3693: PUSH
3694: LD_INT 57
3696: PUSH
3697: EMPTY
3698: LIST
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: EMPTY
3705: LIST
3706: LIST
3707: LIST
3708: PPUSH
3709: CALL_OW 69
3713: PUSH
3714: LD_INT 2
3716: GREATEREQUAL
3717: IFFALSE 3664
// tmp := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
3719: LD_ADDR_VAR 0 2
3723: PUSH
3724: LD_EXP 35
3728: PPUSH
3729: LD_INT 25
3731: PUSH
3732: LD_INT 2
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: PPUSH
3739: CALL_OW 72
3743: ST_TO_ADDR
// ComEnterUnit ( tmp [ 1 ] , arDepot ) ;
3744: LD_VAR 0 2
3748: PUSH
3749: LD_INT 1
3751: ARRAY
3752: PPUSH
3753: LD_INT 5
3755: PPUSH
3756: CALL_OW 120
// ComEnterUnit ( [ tmp [ 2 ] , tmp [ 3 ] ] , arm ) ;
3760: LD_VAR 0 2
3764: PUSH
3765: LD_INT 2
3767: ARRAY
3768: PUSH
3769: LD_VAR 0 2
3773: PUSH
3774: LD_INT 3
3776: ARRAY
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PPUSH
3782: LD_VAR 0 3
3786: PPUSH
3787: CALL_OW 120
// AddComChangeProfession ( [ tmp [ 2 ] , tmp [ 3 ] ] , class_soldier ) ;
3791: LD_VAR 0 2
3795: PUSH
3796: LD_INT 2
3798: ARRAY
3799: PUSH
3800: LD_VAR 0 2
3804: PUSH
3805: LD_INT 3
3807: ARRAY
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PPUSH
3813: LD_INT 1
3815: PPUSH
3816: CALL_OW 183
// AddComExitBuilding ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
3820: LD_VAR 0 2
3824: PUSH
3825: LD_INT 2
3827: ARRAY
3828: PUSH
3829: LD_VAR 0 2
3833: PUSH
3834: LD_INT 3
3836: ARRAY
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: PPUSH
3842: CALL_OW 182
// bun := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_breastwork ] ] ) ;
3846: LD_ADDR_VAR 0 4
3850: PUSH
3851: LD_INT 22
3853: PUSH
3854: LD_INT 5
3856: PUSH
3857: EMPTY
3858: LIST
3859: LIST
3860: PUSH
3861: LD_INT 30
3863: PUSH
3864: LD_INT 31
3866: PUSH
3867: EMPTY
3868: LIST
3869: LIST
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: PPUSH
3875: CALL_OW 69
3879: ST_TO_ADDR
// for i := 1 to 2 do
3880: LD_ADDR_VAR 0 1
3884: PUSH
3885: DOUBLE
3886: LD_INT 1
3888: DEC
3889: ST_TO_ADDR
3890: LD_INT 2
3892: PUSH
3893: FOR_TO
3894: IFFALSE 3928
// AddComEnterUnit ( tmp [ i + 1 ] , bun [ i ] ) ;
3896: LD_VAR 0 2
3900: PUSH
3901: LD_VAR 0 1
3905: PUSH
3906: LD_INT 1
3908: PLUS
3909: ARRAY
3910: PPUSH
3911: LD_VAR 0 4
3915: PUSH
3916: LD_VAR 0 1
3920: ARRAY
3921: PPUSH
3922: CALL_OW 180
3926: GO 3893
3928: POP
3929: POP
// wait ( 1 1$00 ) ;
3930: LD_INT 2100
3932: PPUSH
3933: CALL_OW 67
// farmerBaseReady := true ;
3937: LD_ADDR_EXP 4
3941: PUSH
3942: LD_INT 1
3944: ST_TO_ADDR
// end ;
3945: PPOPN 4
3947: END
// every 0 0$1 trigger farmerBaseReady and not retreatAllowed do var i , eng , sol , arm , damagedBuilding ;
3948: LD_EXP 4
3952: PUSH
3953: LD_EXP 10
3957: NOT
3958: AND
3959: IFFALSE 4454
3961: GO 3963
3963: DISABLE
3964: LD_INT 0
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
3970: PPUSH
// begin enable ;
3971: ENABLE
// sol := UnitFilter ( farmerSquad , [ f_class , 1 ] ) ^ Farmer ;
3972: LD_ADDR_VAR 0 3
3976: PUSH
3977: LD_EXP 35
3981: PPUSH
3982: LD_INT 25
3984: PUSH
3985: LD_INT 1
3987: PUSH
3988: EMPTY
3989: LIST
3990: LIST
3991: PPUSH
3992: CALL_OW 72
3996: PUSH
3997: LD_EXP 32
4001: ADD
4002: ST_TO_ADDR
// eng := UnitFilter ( farmerSquad , [ f_class , 2 ] ) ;
4003: LD_ADDR_VAR 0 2
4007: PUSH
4008: LD_EXP 35
4012: PPUSH
4013: LD_INT 25
4015: PUSH
4016: LD_INT 2
4018: PUSH
4019: EMPTY
4020: LIST
4021: LIST
4022: PPUSH
4023: CALL_OW 72
4027: ST_TO_ADDR
// damagedBuilding := FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
4028: LD_ADDR_VAR 0 5
4032: PUSH
4033: LD_INT 22
4035: PUSH
4036: LD_INT 5
4038: PUSH
4039: EMPTY
4040: LIST
4041: LIST
4042: PUSH
4043: LD_INT 21
4045: PUSH
4046: LD_INT 3
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PUSH
4053: LD_INT 3
4055: PUSH
4056: LD_INT 24
4058: PUSH
4059: LD_INT 1000
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: PUSH
4066: EMPTY
4067: LIST
4068: LIST
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: PPUSH
4075: CALL_OW 69
4079: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 5 ] , [ f_btype , b_armoury ] ] ) ;
4080: LD_ADDR_VAR 0 4
4084: PUSH
4085: LD_INT 22
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: PUSH
4095: LD_INT 30
4097: PUSH
4098: LD_INT 4
4100: PUSH
4101: EMPTY
4102: LIST
4103: LIST
4104: PUSH
4105: EMPTY
4106: LIST
4107: LIST
4108: PPUSH
4109: CALL_OW 69
4113: ST_TO_ADDR
// if IsOk ( arm [ 1 ] ) then
4114: LD_VAR 0 4
4118: PUSH
4119: LD_INT 1
4121: ARRAY
4122: PPUSH
4123: CALL_OW 302
4127: IFFALSE 4191
// for i in sol do
4129: LD_ADDR_VAR 0 1
4133: PUSH
4134: LD_VAR 0 3
4138: PUSH
4139: FOR_IN
4140: IFFALSE 4189
// if GetLives ( i ) < 999 and not IsInUnit ( i ) then
4142: LD_VAR 0 1
4146: PPUSH
4147: CALL_OW 256
4151: PUSH
4152: LD_INT 999
4154: LESS
4155: PUSH
4156: LD_VAR 0 1
4160: PPUSH
4161: CALL_OW 310
4165: NOT
4166: AND
4167: IFFALSE 4187
// ComEnterUnit ( i , arm [ 1 ] ) ;
4169: LD_VAR 0 1
4173: PPUSH
4174: LD_VAR 0 4
4178: PUSH
4179: LD_INT 1
4181: ARRAY
4182: PPUSH
4183: CALL_OW 120
4187: GO 4139
4189: POP
4190: POP
// if not eng and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
4191: LD_VAR 0 2
4195: NOT
4196: PUSH
4197: LD_INT 22
4199: PUSH
4200: LD_INT 1
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PUSH
4207: LD_INT 21
4209: PUSH
4210: LD_INT 1
4212: PUSH
4213: EMPTY
4214: LIST
4215: LIST
4216: PUSH
4217: EMPTY
4218: LIST
4219: LIST
4220: PPUSH
4221: CALL_OW 69
4225: NOT
4226: AND
4227: IFFALSE 4319
// begin uc_side := 5 ;
4229: LD_ADDR_OWVAR 20
4233: PUSH
4234: LD_INT 5
4236: ST_TO_ADDR
// uc_nation := 2 ;
4237: LD_ADDR_OWVAR 21
4241: PUSH
4242: LD_INT 2
4244: ST_TO_ADDR
// PrepareHuman ( false , 2 , 2 ) ;
4245: LD_INT 0
4247: PPUSH
4248: LD_INT 2
4250: PPUSH
4251: LD_INT 2
4253: PPUSH
4254: CALL_OW 380
// eng := CreateHuman ;
4258: LD_ADDR_VAR 0 2
4262: PUSH
4263: CALL_OW 44
4267: ST_TO_ADDR
// PlaceUnitXY ( eng , 102 , 8 , false ) ;
4268: LD_VAR 0 2
4272: PPUSH
4273: LD_INT 102
4275: PPUSH
4276: LD_INT 8
4278: PPUSH
4279: LD_INT 0
4281: PPUSH
4282: CALL_OW 48
// ComMoveXY ( eng , 110 , 60 ) ;
4286: LD_VAR 0 2
4290: PPUSH
4291: LD_INT 110
4293: PPUSH
4294: LD_INT 60
4296: PPUSH
4297: CALL_OW 111
// farmerSquad := farmerSquad union eng ;
4301: LD_ADDR_EXP 35
4305: PUSH
4306: LD_EXP 35
4310: PUSH
4311: LD_VAR 0 2
4315: UNION
4316: ST_TO_ADDR
// end else
4317: GO 4454
// begin for i in eng do
4319: LD_ADDR_VAR 0 1
4323: PUSH
4324: LD_VAR 0 2
4328: PUSH
4329: FOR_IN
4330: IFFALSE 4452
// begin if GetResourceArea ( collectFarmerArea , mat_cans ) then
4332: LD_INT 10
4334: PPUSH
4335: LD_INT 1
4337: PPUSH
4338: CALL_OW 287
4342: IFFALSE 4366
// begin if IsInUnit ( i ) then
4344: LD_VAR 0 1
4348: PPUSH
4349: CALL_OW 310
4353: IFFALSE 4364
// ComExitBuilding ( i ) ;
4355: LD_VAR 0 1
4359: PPUSH
4360: CALL_OW 122
// end else
4364: GO 4450
// begin if damagedBuilding then
4366: LD_VAR 0 5
4370: IFFALSE 4414
// begin if IsInUnit ( i ) then
4372: LD_VAR 0 1
4376: PPUSH
4377: CALL_OW 310
4381: IFFALSE 4394
// ComExitBuilding ( i ) else
4383: LD_VAR 0 1
4387: PPUSH
4388: CALL_OW 122
4392: GO 4412
// ComRepairBuilding ( i , damagedBuilding [ 1 ] ) ;
4394: LD_VAR 0 1
4398: PPUSH
4399: LD_VAR 0 5
4403: PUSH
4404: LD_INT 1
4406: ARRAY
4407: PPUSH
4408: CALL_OW 130
// end else
4412: GO 4450
// if not IsInUnit ( i ) and not HasTask ( i ) then
4414: LD_VAR 0 1
4418: PPUSH
4419: CALL_OW 310
4423: NOT
4424: PUSH
4425: LD_VAR 0 1
4429: PPUSH
4430: CALL_OW 314
4434: NOT
4435: AND
4436: IFFALSE 4450
// ComEnterUnit ( i , arDepot ) ;
4438: LD_VAR 0 1
4442: PPUSH
4443: LD_INT 5
4445: PPUSH
4446: CALL_OW 120
// end ; end ;
4450: GO 4329
4452: POP
4453: POP
// end ; end ;
4454: PPOPN 5
4456: END
// export function StartCargoEvacuation ; begin
4457: LD_INT 0
4459: PPUSH
// while GetResourceType ( GetBase ( arDepot ) , mat_cans ) > 0 and omarCargoCounter > 0 do
4460: LD_INT 5
4462: PPUSH
4463: CALL_OW 274
4467: PPUSH
4468: LD_INT 1
4470: PPUSH
4471: CALL_OW 275
4475: PUSH
4476: LD_INT 0
4478: GREATER
4479: PUSH
4480: LD_EXP 17
4484: PUSH
4485: LD_INT 0
4487: GREATER
4488: AND
4489: IFFALSE 4746
// begin wait ( 1 1$20 ) ;
4491: LD_INT 2800
4493: PPUSH
4494: CALL_OW 67
// omarCargo := PrepareCargo ;
4498: LD_ADDR_EXP 39
4502: PUSH
4503: CALL 4751 0 0
4507: ST_TO_ADDR
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4508: LD_EXP 39
4512: PPUSH
4513: LD_INT 107
4515: PPUSH
4516: LD_INT 59
4518: PPUSH
4519: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
4523: LD_INT 35
4525: PPUSH
4526: CALL_OW 67
// ComMoveXY ( omarCargo , 107 , 59 ) ;
4530: LD_EXP 39
4534: PPUSH
4535: LD_INT 107
4537: PPUSH
4538: LD_INT 59
4540: PPUSH
4541: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4545: LD_EXP 39
4549: PPUSH
4550: CALL_OW 302
4554: NOT
4555: PUSH
4556: LD_EXP 39
4560: PPUSH
4561: CALL_OW 301
4565: OR
4566: IFFALSE 4570
// continue ;
4568: GO 4523
// until IsAt ( omarCargo , 107 , 59 ) or GetDistUnits ( omarCargo , arDepot ) < 6 ;
4570: LD_EXP 39
4574: PPUSH
4575: LD_INT 107
4577: PPUSH
4578: LD_INT 59
4580: PPUSH
4581: CALL_OW 307
4585: PUSH
4586: LD_EXP 39
4590: PPUSH
4591: LD_INT 5
4593: PPUSH
4594: CALL_OW 296
4598: PUSH
4599: LD_INT 6
4601: LESS
4602: OR
4603: IFFALSE 4523
// wait ( 0 0$05 ) ;
4605: LD_INT 175
4607: PPUSH
4608: CALL_OW 67
// ComTransport ( omarCargo , arDepot , mat_cans ) ;
4612: LD_EXP 39
4616: PPUSH
4617: LD_INT 5
4619: PPUSH
4620: LD_INT 1
4622: PPUSH
4623: CALL_OW 151
// AddComMoveXY ( omarCargo , 103 , 9 ) ;
4627: LD_EXP 39
4631: PPUSH
4632: LD_INT 103
4634: PPUSH
4635: LD_INT 9
4637: PPUSH
4638: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4642: LD_INT 35
4644: PPUSH
4645: CALL_OW 67
// ComMoveXY ( omarCargo , 103 , 9 ) ;
4649: LD_EXP 39
4653: PPUSH
4654: LD_INT 103
4656: PPUSH
4657: LD_INT 9
4659: PPUSH
4660: CALL_OW 111
// if not IsOk ( omarCargo ) or IsDead ( omarCargo ) then
4664: LD_EXP 39
4668: PPUSH
4669: CALL_OW 302
4673: NOT
4674: PUSH
4675: LD_EXP 39
4679: PPUSH
4680: CALL_OW 301
4684: OR
4685: IFFALSE 4689
// continue ;
4687: GO 4642
// until IsInArea ( omarCargo , northRoad ) and GetCargo ( omarCargo , mat_cans ) > 0 ;
4689: LD_EXP 39
4693: PPUSH
4694: LD_INT 3
4696: PPUSH
4697: CALL_OW 308
4701: PUSH
4702: LD_EXP 39
4706: PPUSH
4707: LD_INT 1
4709: PPUSH
4710: CALL_OW 289
4714: PUSH
4715: LD_INT 0
4717: GREATER
4718: AND
4719: IFFALSE 4642
// RemoveUnit ( omarCargo ) ;
4721: LD_EXP 39
4725: PPUSH
4726: CALL_OW 64
// omarCargoCounter := omarCargoCounter - 1 ;
4730: LD_ADDR_EXP 17
4734: PUSH
4735: LD_EXP 17
4739: PUSH
4740: LD_INT 1
4742: MINUS
4743: ST_TO_ADDR
// end ;
4744: GO 4460
// end ;
4746: LD_VAR 0 1
4750: RET
// export function PrepareCargo ; var un , veh ; begin
4751: LD_INT 0
4753: PPUSH
4754: PPUSH
4755: PPUSH
// veh := PrepareTank ( 5 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 80 ) ;
4756: LD_ADDR_VAR 0 3
4760: PUSH
4761: LD_INT 5
4763: PPUSH
4764: LD_INT 2
4766: PPUSH
4767: LD_INT 13
4769: PPUSH
4770: LD_INT 1
4772: PPUSH
4773: LD_INT 1
4775: PPUSH
4776: LD_INT 32
4778: PPUSH
4779: LD_INT 80
4781: PPUSH
4782: CALL 331 0 7
4786: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4787: LD_VAR 0 3
4791: PPUSH
4792: LD_INT 4
4794: PPUSH
4795: CALL_OW 233
// PlaceUnitXY ( veh , 101 , 8 , false ) ;
4799: LD_VAR 0 3
4803: PPUSH
4804: LD_INT 101
4806: PPUSH
4807: LD_INT 8
4809: PPUSH
4810: LD_INT 0
4812: PPUSH
4813: CALL_OW 48
// PrepareHuman ( false , 3 , 2 ) ;
4817: LD_INT 0
4819: PPUSH
4820: LD_INT 3
4822: PPUSH
4823: LD_INT 2
4825: PPUSH
4826: CALL_OW 380
// un := CreateHuman ;
4830: LD_ADDR_VAR 0 2
4834: PUSH
4835: CALL_OW 44
4839: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4840: LD_VAR 0 2
4844: PPUSH
4845: LD_VAR 0 3
4849: PPUSH
4850: CALL_OW 52
// result := veh ;
4854: LD_ADDR_VAR 0 1
4858: PUSH
4859: LD_VAR 0 3
4863: ST_TO_ADDR
// end ; end_of_file
4864: LD_VAR 0 1
4868: RET
// export usForces , usCommander , americanBuildList , usAttackers ; export function PrepareAmerican ; var i , un ; begin
4869: LD_INT 0
4871: PPUSH
4872: PPUSH
4873: PPUSH
// usForces := [ ] ;
4874: LD_ADDR_EXP 40
4878: PUSH
4879: EMPTY
4880: ST_TO_ADDR
// americanBuildList := [ [ b_lab , 32 , 27 , 1 ] , [ b_armoury , 43 , 24 , 5 ] , [ b_solar_power , 29 , 21 , 0 ] ] ;
4881: LD_ADDR_EXP 42
4885: PUSH
4886: LD_INT 6
4888: PUSH
4889: LD_INT 32
4891: PUSH
4892: LD_INT 27
4894: PUSH
4895: LD_INT 1
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 4
4906: PUSH
4907: LD_INT 43
4909: PUSH
4910: LD_INT 24
4912: PUSH
4913: LD_INT 5
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: PUSH
4922: LD_INT 27
4924: PUSH
4925: LD_INT 29
4927: PUSH
4928: LD_INT 21
4930: PUSH
4931: LD_INT 0
4933: PUSH
4934: EMPTY
4935: LIST
4936: LIST
4937: LIST
4938: LIST
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: LIST
4944: ST_TO_ADDR
// SetResourceType ( GetBase ( usDepot ) , mat_cans , [ 150 , 120 , 100 ] [ Difficulty ] ) ;
4945: LD_INT 11
4947: PPUSH
4948: CALL_OW 274
4952: PPUSH
4953: LD_INT 1
4955: PPUSH
4956: LD_INT 150
4958: PUSH
4959: LD_INT 120
4961: PUSH
4962: LD_INT 100
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: LIST
4969: PUSH
4970: LD_OWVAR 67
4974: ARRAY
4975: PPUSH
4976: CALL_OW 277
// if Difficulty = 1 then
4980: LD_OWVAR 67
4984: PUSH
4985: LD_INT 1
4987: EQUAL
4988: IFFALSE 4997
// RemoveUnit ( hillBun ) ;
4990: LD_INT 14
4992: PPUSH
4993: CALL_OW 64
// uc_side := 1 ;
4997: LD_ADDR_OWVAR 20
5001: PUSH
5002: LD_INT 1
5004: ST_TO_ADDR
// uc_nation := 1 ;
5005: LD_ADDR_OWVAR 21
5009: PUSH
5010: LD_INT 1
5012: ST_TO_ADDR
// hc_gallery :=  ;
5013: LD_ADDR_OWVAR 33
5017: PUSH
5018: LD_STRING 
5020: ST_TO_ADDR
// hc_name :=  ;
5021: LD_ADDR_OWVAR 26
5025: PUSH
5026: LD_STRING 
5028: ST_TO_ADDR
// hc_importance := 0 ;
5029: LD_ADDR_OWVAR 32
5033: PUSH
5034: LD_INT 0
5036: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
5037: LD_INT 1
5039: PPUSH
5040: LD_INT 1
5042: PPUSH
5043: LD_INT 3
5045: PPUSH
5046: CALL_OW 380
// usCommander := CreateHuman ;
5050: LD_ADDR_EXP 41
5054: PUSH
5055: CALL_OW 44
5059: ST_TO_ADDR
// PlaceHumanInUnit ( usCommander , usDepot ) ;
5060: LD_EXP 41
5064: PPUSH
5065: LD_INT 11
5067: PPUSH
5068: CALL_OW 52
// if hillBun then
5072: LD_INT 14
5074: IFFALSE 5156
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5076: LD_INT 0
5078: PPUSH
5079: LD_INT 1
5081: PPUSH
5082: LD_INT 1
5084: PUSH
5085: LD_INT 2
5087: PUSH
5088: LD_INT 3
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: LIST
5095: PUSH
5096: LD_OWVAR 67
5100: ARRAY
5101: PPUSH
5102: CALL_OW 380
// un := CreateHuman ;
5106: LD_ADDR_VAR 0 3
5110: PUSH
5111: CALL_OW 44
5115: ST_TO_ADDR
// usForces := usForces union un ;
5116: LD_ADDR_EXP 40
5120: PUSH
5121: LD_EXP 40
5125: PUSH
5126: LD_VAR 0 3
5130: UNION
5131: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5132: LD_VAR 0 3
5136: PPUSH
5137: LD_INT 1
5139: PPUSH
5140: CALL_OW 233
// PlaceHumanInUnit ( un , hillBun ) ;
5144: LD_VAR 0 3
5148: PPUSH
5149: LD_INT 14
5151: PPUSH
5152: CALL_OW 52
// end ; for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
5156: LD_ADDR_VAR 0 2
5160: PUSH
5161: DOUBLE
5162: LD_INT 1
5164: DEC
5165: ST_TO_ADDR
5166: LD_INT 2
5168: PUSH
5169: LD_INT 3
5171: PUSH
5172: LD_INT 4
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: PUSH
5180: LD_OWVAR 67
5184: ARRAY
5185: PUSH
5186: FOR_TO
5187: IFFALSE 5329
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
5189: LD_INT 0
5191: PPUSH
5192: LD_INT 1
5194: PPUSH
5195: LD_INT 1
5197: PUSH
5198: LD_INT 2
5200: PUSH
5201: LD_INT 3
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: LIST
5208: PUSH
5209: LD_OWVAR 67
5213: ARRAY
5214: PPUSH
5215: CALL_OW 380
// un := CreateHuman ;
5219: LD_ADDR_VAR 0 3
5223: PUSH
5224: CALL_OW 44
5228: ST_TO_ADDR
// usForces := usForces union un ;
5229: LD_ADDR_EXP 40
5233: PUSH
5234: LD_EXP 40
5238: PUSH
5239: LD_VAR 0 3
5243: UNION
5244: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5245: LD_VAR 0 3
5249: PPUSH
5250: LD_INT 39
5252: PPUSH
5253: LD_INT 24
5255: PPUSH
5256: LD_INT 4
5258: PPUSH
5259: LD_INT 0
5261: PPUSH
5262: CALL_OW 50
// if i < 3 then
5266: LD_VAR 0 2
5270: PUSH
5271: LD_INT 3
5273: LESS
5274: IFFALSE 5327
// ComEnterUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_empty ] , [ f_btype , b_breastwork ] ] ) [ i ] ) ;
5276: LD_VAR 0 3
5280: PPUSH
5281: LD_INT 22
5283: PUSH
5284: LD_INT 1
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: LD_INT 58
5293: PUSH
5294: EMPTY
5295: LIST
5296: PUSH
5297: LD_INT 30
5299: PUSH
5300: LD_INT 31
5302: PUSH
5303: EMPTY
5304: LIST
5305: LIST
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 69
5316: PUSH
5317: LD_VAR 0 2
5321: ARRAY
5322: PPUSH
5323: CALL_OW 120
// end ;
5327: GO 5186
5329: POP
5330: POP
// for i := 1 to 2 do
5331: LD_ADDR_VAR 0 2
5335: PUSH
5336: DOUBLE
5337: LD_INT 1
5339: DEC
5340: ST_TO_ADDR
5341: LD_INT 2
5343: PUSH
5344: FOR_TO
5345: IFFALSE 5409
// begin PrepareHuman ( false , 2 , 2 ) ;
5347: LD_INT 0
5349: PPUSH
5350: LD_INT 2
5352: PPUSH
5353: LD_INT 2
5355: PPUSH
5356: CALL_OW 380
// un := CreateHuman ;
5360: LD_ADDR_VAR 0 3
5364: PUSH
5365: CALL_OW 44
5369: ST_TO_ADDR
// usForces := usForces union un ;
5370: LD_ADDR_EXP 40
5374: PUSH
5375: LD_EXP 40
5379: PUSH
5380: LD_VAR 0 3
5384: UNION
5385: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5386: LD_VAR 0 3
5390: PPUSH
5391: LD_INT 39
5393: PPUSH
5394: LD_INT 24
5396: PPUSH
5397: LD_INT 4
5399: PPUSH
5400: LD_INT 0
5402: PPUSH
5403: CALL_OW 50
// end ;
5407: GO 5344
5409: POP
5410: POP
// PrepareHuman ( false , 4 , 1 ) ;
5411: LD_INT 0
5413: PPUSH
5414: LD_INT 4
5416: PPUSH
5417: LD_INT 1
5419: PPUSH
5420: CALL_OW 380
// un := CreateHuman ;
5424: LD_ADDR_VAR 0 3
5428: PUSH
5429: CALL_OW 44
5433: ST_TO_ADDR
// usForces := usForces union un ;
5434: LD_ADDR_EXP 40
5438: PUSH
5439: LD_EXP 40
5443: PUSH
5444: LD_VAR 0 3
5448: UNION
5449: ST_TO_ADDR
// PlaceUnitXYR ( un , 39 , 24 , 4 , false ) ;
5450: LD_VAR 0 3
5454: PPUSH
5455: LD_INT 39
5457: PPUSH
5458: LD_INT 24
5460: PPUSH
5461: LD_INT 4
5463: PPUSH
5464: LD_INT 0
5466: PPUSH
5467: CALL_OW 50
// end ;
5471: LD_VAR 0 1
5475: RET
// every 0 0$1 trigger usForces and not americanBaseCaptured do var i , b , eng , sol , sci ;
5476: LD_EXP 40
5480: PUSH
5481: LD_EXP 6
5485: NOT
5486: AND
5487: IFFALSE 5918
5489: GO 5491
5491: DISABLE
5492: LD_INT 0
5494: PPUSH
5495: PPUSH
5496: PPUSH
5497: PPUSH
5498: PPUSH
// begin enable ;
5499: ENABLE
// eng := UnitFilter ( usForces , [ f_class , 2 ] ) ;
5500: LD_ADDR_VAR 0 3
5504: PUSH
5505: LD_EXP 40
5509: PPUSH
5510: LD_INT 25
5512: PUSH
5513: LD_INT 2
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL_OW 72
5524: ST_TO_ADDR
// sol := UnitFilter ( usForces , [ f_class , 1 ] ) ;
5525: LD_ADDR_VAR 0 4
5529: PUSH
5530: LD_EXP 40
5534: PPUSH
5535: LD_INT 25
5537: PUSH
5538: LD_INT 1
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PPUSH
5545: CALL_OW 72
5549: ST_TO_ADDR
// sci := UnitFilter ( usForces , [ f_class , 4 ] ) ;
5550: LD_ADDR_VAR 0 5
5554: PUSH
5555: LD_EXP 40
5559: PPUSH
5560: LD_INT 25
5562: PUSH
5563: LD_INT 4
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PPUSH
5570: CALL_OW 72
5574: ST_TO_ADDR
// if FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) = 1 then
5575: LD_INT 7
5577: PPUSH
5578: LD_INT 22
5580: PUSH
5581: LD_INT 2
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: PPUSH
5588: CALL_OW 70
5592: PUSH
5593: LD_INT 1
5595: EQUAL
5596: IFFALSE 5672
// for i in sol do
5598: LD_ADDR_VAR 0 1
5602: PUSH
5603: LD_VAR 0 4
5607: PUSH
5608: FOR_IN
5609: IFFALSE 5670
// if not IsInUnit ( i ) or not GetBType ( IsInUnit ( i ) ) = b_armoury then
5611: LD_VAR 0 1
5615: PPUSH
5616: CALL_OW 310
5620: NOT
5621: PUSH
5622: LD_VAR 0 1
5626: PPUSH
5627: CALL_OW 310
5631: PPUSH
5632: CALL_OW 266
5636: PUSH
5637: LD_INT 4
5639: EQUAL
5640: NOT
5641: OR
5642: IFFALSE 5668
// begin ComExitBuilding ( i ) ;
5644: LD_VAR 0 1
5648: PPUSH
5649: CALL_OW 122
// AddComAgressiveMove ( i , 37 , 23 ) ;
5653: LD_VAR 0 1
5657: PPUSH
5658: LD_INT 37
5660: PPUSH
5661: LD_INT 23
5663: PPUSH
5664: CALL_OW 174
// end ;
5668: GO 5608
5670: POP
5671: POP
// if eng then
5672: LD_VAR 0 3
5676: IFFALSE 5918
// begin b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_inarea , americanBaseArea ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5678: LD_ADDR_VAR 0 2
5682: PUSH
5683: LD_INT 22
5685: PUSH
5686: LD_INT 1
5688: PUSH
5689: EMPTY
5690: LIST
5691: LIST
5692: PUSH
5693: LD_INT 95
5695: PUSH
5696: LD_INT 7
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: PUSH
5703: LD_INT 21
5705: PUSH
5706: LD_INT 3
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 3
5715: PUSH
5716: LD_INT 24
5718: PUSH
5719: LD_INT 1000
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: PUSH
5730: EMPTY
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL_OW 69
5740: ST_TO_ADDR
// if b then
5741: LD_VAR 0 2
5745: IFFALSE 5776
// begin ComExitBuilding ( eng ) ;
5747: LD_VAR 0 3
5751: PPUSH
5752: CALL_OW 122
// AddComRepairBuilding ( eng , b [ 1 ] ) ;
5756: LD_VAR 0 3
5760: PPUSH
5761: LD_VAR 0 2
5765: PUSH
5766: LD_INT 1
5768: ARRAY
5769: PPUSH
5770: CALL_OW 190
// end else
5774: GO 5918
// begin for i in eng do
5776: LD_ADDR_VAR 0 1
5780: PUSH
5781: LD_VAR 0 3
5785: PUSH
5786: FOR_IN
5787: IFFALSE 5916
// if not HasTask ( i ) then
5789: LD_VAR 0 1
5793: PPUSH
5794: CALL_OW 314
5798: NOT
5799: IFFALSE 5914
// begin if americanBuildList then
5801: LD_EXP 42
5805: IFFALSE 5890
// begin if IsInUnit ( i ) then
5807: LD_VAR 0 1
5811: PPUSH
5812: CALL_OW 310
5816: IFFALSE 5827
// ComExitBuilding ( i ) ;
5818: LD_VAR 0 1
5822: PPUSH
5823: CALL_OW 122
// AddComBuild ( i , americanBuildList [ 1 ] [ 1 ] , americanBuildList [ 1 ] [ 2 ] , americanBuildList [ 1 ] [ 3 ] , americanBuildList [ 1 ] [ 4 ] ) ;
5827: LD_VAR 0 1
5831: PPUSH
5832: LD_EXP 42
5836: PUSH
5837: LD_INT 1
5839: ARRAY
5840: PUSH
5841: LD_INT 1
5843: ARRAY
5844: PPUSH
5845: LD_EXP 42
5849: PUSH
5850: LD_INT 1
5852: ARRAY
5853: PUSH
5854: LD_INT 2
5856: ARRAY
5857: PPUSH
5858: LD_EXP 42
5862: PUSH
5863: LD_INT 1
5865: ARRAY
5866: PUSH
5867: LD_INT 3
5869: ARRAY
5870: PPUSH
5871: LD_EXP 42
5875: PUSH
5876: LD_INT 1
5878: ARRAY
5879: PUSH
5880: LD_INT 4
5882: ARRAY
5883: PPUSH
5884: CALL_OW 205
// end else
5888: GO 5914
// if not IsInUnit ( i ) then
5890: LD_VAR 0 1
5894: PPUSH
5895: CALL_OW 310
5899: NOT
5900: IFFALSE 5914
// ComEnterUnit ( i , usDepot ) ;
5902: LD_VAR 0 1
5906: PPUSH
5907: LD_INT 11
5909: PPUSH
5910: CALL_OW 120
// end ;
5914: GO 5786
5916: POP
5917: POP
// end ; end ; end ;
5918: PPOPN 5
5920: END
// export function AmLabResearch ( lab ) ; var tech , i ; begin
5921: LD_INT 0
5923: PPUSH
5924: PPUSH
5925: PPUSH
// tech := [ tech_SolPow , tech_SolEng , tech_Tech1 , tech_BasicTools ] ;
5926: LD_ADDR_VAR 0 3
5930: PUSH
5931: LD_INT 35
5933: PUSH
5934: LD_INT 45
5936: PUSH
5937: LD_INT 48
5939: PUSH
5940: LD_EXP 51
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: ST_TO_ADDR
// for i in tech do
5951: LD_ADDR_VAR 0 4
5955: PUSH
5956: LD_VAR 0 3
5960: PUSH
5961: FOR_IN
5962: IFFALSE 5980
// AddComResearch ( lab , i ) ;
5964: LD_VAR 0 1
5968: PPUSH
5969: LD_VAR 0 4
5973: PPUSH
5974: CALL_OW 184
5978: GO 5961
5980: POP
5981: POP
// end ;
5982: LD_VAR 0 2
5986: RET
// every 6 6$00 + 2 2$00 trigger allowConvoys and convoyCounter <= maxConvoys do
5987: LD_EXP 11
5991: PUSH
5992: LD_EXP 19
5996: PUSH
5997: LD_EXP 23
6001: LESSEQUAL
6002: AND
6003: IFFALSE 6028
6005: GO 6007
6007: DISABLE
// begin enable ;
6008: ENABLE
// wait ( rand ( 0 0$1 , 0 0$59 ) ) ;
6009: LD_INT 35
6011: PPUSH
6012: LD_INT 2065
6014: PPUSH
6015: CALL_OW 12
6019: PPUSH
6020: CALL_OW 67
// SendConvoy ;
6024: CALL 6126 0 0
// end ;
6028: END
// every 0 0$1 trigger americanBaseCaptured and firstConvoyDestroyed do
6029: LD_EXP 6
6033: PUSH
6034: LD_EXP 15
6038: AND
6039: IFFALSE 6125
6041: GO 6043
6043: DISABLE
// begin if americanHasEscaped then
6044: LD_EXP 7
6048: IFFALSE 6059
// wait ( 3 3$20 ) else
6050: LD_INT 7000
6052: PPUSH
6053: CALL_OW 67
6057: GO 6066
// wait ( 6 6$40 ) ;
6059: LD_INT 14000
6061: PPUSH
6062: CALL_OW 67
// SendAttack ;
6066: CALL 6841 0 0
// repeat wait ( [ 6 6$40 , 5 5$40 , 4 4$40 ] [ Difficulty ] ) ;
6070: LD_INT 14000
6072: PUSH
6073: LD_INT 11900
6075: PUSH
6076: LD_INT 9800
6078: PUSH
6079: EMPTY
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: LD_OWVAR 67
6088: ARRAY
6089: PPUSH
6090: CALL_OW 67
// SendAttack ;
6094: CALL 6841 0 0
// until attackWave < [ 6 , 7 , 8 ] [ Difficulty ] ;
6098: LD_EXP 16
6102: PUSH
6103: LD_INT 6
6105: PUSH
6106: LD_INT 7
6108: PUSH
6109: LD_INT 8
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: PUSH
6117: LD_OWVAR 67
6121: ARRAY
6122: LESS
6123: IFFALSE 6070
// end ;
6125: END
// export function SendConvoy ; var un , veh , road , tmp , points , i , finalArea ; begin
6126: LD_INT 0
6128: PPUSH
6129: PPUSH
6130: PPUSH
6131: PPUSH
6132: PPUSH
6133: PPUSH
6134: PPUSH
6135: PPUSH
// road := rand ( 1 , 2 ) ;
6136: LD_ADDR_VAR 0 4
6140: PUSH
6141: LD_INT 1
6143: PPUSH
6144: LD_INT 2
6146: PPUSH
6147: CALL_OW 12
6151: ST_TO_ADDR
// finalArea := [ northRoad , westRoad ] [ road ] ;
6152: LD_ADDR_VAR 0 8
6156: PUSH
6157: LD_INT 3
6159: PUSH
6160: LD_INT 8
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: PUSH
6167: LD_VAR 0 4
6171: ARRAY
6172: ST_TO_ADDR
// tmp := [ [ 35 , 66 , 1 ] , [ 101 , 8 , 4 ] ] ;
6173: LD_ADDR_VAR 0 5
6177: PUSH
6178: LD_INT 35
6180: PUSH
6181: LD_INT 66
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 101
6194: PUSH
6195: LD_INT 8
6197: PUSH
6198: LD_INT 4
6200: PUSH
6201: EMPTY
6202: LIST
6203: LIST
6204: LIST
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: ST_TO_ADDR
// points := [ [ 34 , 67 ] , [ 38 , 62 ] , [ 43 , 54 ] , [ 57 , 57 ] , [ 77 , 71 ] , [ 86 , 60 ] , [ 89 , 35 ] , [ 93 , 17 ] , [ 97 , 10 ] , [ 103 , 9 ] ] ;
6210: LD_ADDR_VAR 0 6
6214: PUSH
6215: LD_INT 34
6217: PUSH
6218: LD_INT 67
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: LD_INT 38
6227: PUSH
6228: LD_INT 62
6230: PUSH
6231: EMPTY
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 43
6237: PUSH
6238: LD_INT 54
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 57
6247: PUSH
6248: LD_INT 57
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: PUSH
6255: LD_INT 77
6257: PUSH
6258: LD_INT 71
6260: PUSH
6261: EMPTY
6262: LIST
6263: LIST
6264: PUSH
6265: LD_INT 86
6267: PUSH
6268: LD_INT 60
6270: PUSH
6271: EMPTY
6272: LIST
6273: LIST
6274: PUSH
6275: LD_INT 89
6277: PUSH
6278: LD_INT 35
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: PUSH
6285: LD_INT 93
6287: PUSH
6288: LD_INT 17
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: PUSH
6295: LD_INT 97
6297: PUSH
6298: LD_INT 10
6300: PUSH
6301: EMPTY
6302: LIST
6303: LIST
6304: PUSH
6305: LD_INT 103
6307: PUSH
6308: LD_INT 9
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: LIST
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: ST_TO_ADDR
// if road = 2 then
6327: LD_VAR 0 4
6331: PUSH
6332: LD_INT 2
6334: EQUAL
6335: IFFALSE 6352
// points := ReverseArray ( points ) ;
6337: LD_ADDR_VAR 0 6
6341: PUSH
6342: LD_VAR 0 6
6346: PPUSH
6347: CALL 1019 0 1
6351: ST_TO_ADDR
// PrepareTank ( 4 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 80 ) ;
6352: LD_INT 4
6354: PPUSH
6355: LD_INT 1
6357: PPUSH
6358: LD_INT 2
6360: PPUSH
6361: LD_INT 1
6363: PPUSH
6364: LD_INT 1
6366: PPUSH
6367: LD_INT 12
6369: PPUSH
6370: LD_INT 80
6372: PPUSH
6373: CALL 331 0 7
// veh := CreateVehicle ;
6377: LD_ADDR_VAR 0 3
6381: PUSH
6382: CALL_OW 45
6386: ST_TO_ADDR
// SetDir ( veh , tmp [ road ] [ 3 ] ) ;
6387: LD_VAR 0 3
6391: PPUSH
6392: LD_VAR 0 5
6396: PUSH
6397: LD_VAR 0 4
6401: ARRAY
6402: PUSH
6403: LD_INT 3
6405: ARRAY
6406: PPUSH
6407: CALL_OW 233
// PlaceUnitXY ( veh , tmp [ road ] [ 1 ] , tmp [ road ] [ 2 ] , false ) ;
6411: LD_VAR 0 3
6415: PPUSH
6416: LD_VAR 0 5
6420: PUSH
6421: LD_VAR 0 4
6425: ARRAY
6426: PUSH
6427: LD_INT 1
6429: ARRAY
6430: PPUSH
6431: LD_VAR 0 5
6435: PUSH
6436: LD_VAR 0 4
6440: ARRAY
6441: PUSH
6442: LD_INT 2
6444: ARRAY
6445: PPUSH
6446: LD_INT 0
6448: PPUSH
6449: CALL_OW 48
// PrepareHuman ( false , 1 , Difficulty ) ;
6453: LD_INT 0
6455: PPUSH
6456: LD_INT 1
6458: PPUSH
6459: LD_OWVAR 67
6463: PPUSH
6464: CALL_OW 380
// un := CreateHuman ;
6468: LD_ADDR_VAR 0 2
6472: PUSH
6473: CALL_OW 44
6477: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
6478: LD_VAR 0 2
6482: PPUSH
6483: LD_VAR 0 3
6487: PPUSH
6488: CALL_OW 52
// if Prob ( 50 + tick mod 30 ) or convoyCounter < 3 then
6492: LD_INT 50
6494: PUSH
6495: LD_OWVAR 1
6499: PUSH
6500: LD_INT 30
6502: MOD
6503: PLUS
6504: PPUSH
6505: CALL_OW 13
6509: PUSH
6510: LD_EXP 19
6514: PUSH
6515: LD_INT 3
6517: LESS
6518: OR
6519: IFFALSE 6536
// SetCargo ( veh , mat_cans , 100 ) ;
6521: LD_VAR 0 3
6525: PPUSH
6526: LD_INT 1
6528: PPUSH
6529: LD_INT 100
6531: PPUSH
6532: CALL_OW 290
// for i := 2 to points do
6536: LD_ADDR_VAR 0 7
6540: PUSH
6541: DOUBLE
6542: LD_INT 2
6544: DEC
6545: ST_TO_ADDR
6546: LD_VAR 0 6
6550: PUSH
6551: FOR_TO
6552: IFFALSE 6595
// AddComMoveXY ( veh , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
6554: LD_VAR 0 3
6558: PPUSH
6559: LD_VAR 0 6
6563: PUSH
6564: LD_VAR 0 7
6568: ARRAY
6569: PUSH
6570: LD_INT 1
6572: ARRAY
6573: PPUSH
6574: LD_VAR 0 6
6578: PUSH
6579: LD_VAR 0 7
6583: ARRAY
6584: PUSH
6585: LD_INT 2
6587: ARRAY
6588: PPUSH
6589: CALL_OW 171
6593: GO 6551
6595: POP
6596: POP
// convoyCounter := convoyCounter + 1 ;
6597: LD_ADDR_EXP 19
6601: PUSH
6602: LD_EXP 19
6606: PUSH
6607: LD_INT 1
6609: PLUS
6610: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6611: LD_INT 35
6613: PPUSH
6614: CALL_OW 67
// if not HasTask ( veh ) then
6618: LD_VAR 0 3
6622: PPUSH
6623: CALL_OW 314
6627: NOT
6628: IFFALSE 6669
// ComMoveXY ( veh , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6630: LD_VAR 0 3
6634: PPUSH
6635: LD_VAR 0 6
6639: PUSH
6640: LD_VAR 0 6
6644: ARRAY
6645: PUSH
6646: LD_INT 1
6648: ARRAY
6649: PPUSH
6650: LD_VAR 0 6
6654: PUSH
6655: LD_VAR 0 6
6659: ARRAY
6660: PUSH
6661: LD_INT 2
6663: ARRAY
6664: PPUSH
6665: CALL_OW 111
// if not IsOk ( veh ) then
6669: LD_VAR 0 3
6673: PPUSH
6674: CALL_OW 302
6678: NOT
6679: IFFALSE 6720
// ComMoveXY ( un , points [ points ] [ 1 ] , points [ points ] [ 2 ] ) ;
6681: LD_VAR 0 2
6685: PPUSH
6686: LD_VAR 0 6
6690: PUSH
6691: LD_VAR 0 6
6695: ARRAY
6696: PUSH
6697: LD_INT 1
6699: ARRAY
6700: PPUSH
6701: LD_VAR 0 6
6705: PUSH
6706: LD_VAR 0 6
6710: ARRAY
6711: PUSH
6712: LD_INT 2
6714: ARRAY
6715: PPUSH
6716: CALL_OW 111
// until IsInArea ( veh , finalArea ) or IsInArea ( un , finalArea ) ;
6720: LD_VAR 0 3
6724: PPUSH
6725: LD_VAR 0 8
6729: PPUSH
6730: CALL_OW 308
6734: PUSH
6735: LD_VAR 0 2
6739: PPUSH
6740: LD_VAR 0 8
6744: PPUSH
6745: CALL_OW 308
6749: OR
6750: IFFALSE 6611
// if IsOk ( un ) and not IsOk ( veh ) and IsInArea ( un , finalArea ) then
6752: LD_VAR 0 2
6756: PPUSH
6757: CALL_OW 302
6761: PUSH
6762: LD_VAR 0 3
6766: PPUSH
6767: CALL_OW 302
6771: NOT
6772: AND
6773: PUSH
6774: LD_VAR 0 2
6778: PPUSH
6779: LD_VAR 0 8
6783: PPUSH
6784: CALL_OW 308
6788: AND
6789: IFFALSE 6800
// RemoveUnit ( un ) ;
6791: LD_VAR 0 2
6795: PPUSH
6796: CALL_OW 64
// if IsInArea ( veh , finalArea ) and IsOk ( veh ) then
6800: LD_VAR 0 3
6804: PPUSH
6805: LD_VAR 0 8
6809: PPUSH
6810: CALL_OW 308
6814: PUSH
6815: LD_VAR 0 3
6819: PPUSH
6820: CALL_OW 302
6824: AND
6825: IFFALSE 6836
// RemoveUnit ( veh ) ;
6827: LD_VAR 0 3
6831: PPUSH
6832: CALL_OW 64
// end ;
6836: LD_VAR 0 1
6840: RET
// export function SendAttack ; var un , veh , i ; begin
6841: LD_INT 0
6843: PPUSH
6844: PPUSH
6845: PPUSH
6846: PPUSH
// IncomingAttack ;
6847: CALL 14961 0 0
// wait ( rand ( 1 1$0 , 1 1$40 ) ) ;
6851: LD_INT 2100
6853: PPUSH
6854: LD_INT 3500
6856: PPUSH
6857: CALL_OW 12
6861: PPUSH
6862: CALL_OW 67
// for i := 1 to [ 3 , 3 , 4 ] [ Difficulty ] + attackWave div 3 do
6866: LD_ADDR_VAR 0 4
6870: PUSH
6871: DOUBLE
6872: LD_INT 1
6874: DEC
6875: ST_TO_ADDR
6876: LD_INT 3
6878: PUSH
6879: LD_INT 3
6881: PUSH
6882: LD_INT 4
6884: PUSH
6885: EMPTY
6886: LIST
6887: LIST
6888: LIST
6889: PUSH
6890: LD_OWVAR 67
6894: ARRAY
6895: PUSH
6896: LD_EXP 16
6900: PUSH
6901: LD_INT 3
6903: DIV
6904: PLUS
6905: PUSH
6906: FOR_TO
6907: IFFALSE 7019
// begin uc_side := 1 ;
6909: LD_ADDR_OWVAR 20
6913: PUSH
6914: LD_INT 1
6916: ST_TO_ADDR
// uc_nation := 1 ;
6917: LD_ADDR_OWVAR 21
6921: PUSH
6922: LD_INT 1
6924: ST_TO_ADDR
// PrepareHuman ( false , 1 , [ 2 , 3 , 4 ] [ Difficulty ] ) ;
6925: LD_INT 0
6927: PPUSH
6928: LD_INT 1
6930: PPUSH
6931: LD_INT 2
6933: PUSH
6934: LD_INT 3
6936: PUSH
6937: LD_INT 4
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: PUSH
6945: LD_OWVAR 67
6949: ARRAY
6950: PPUSH
6951: CALL_OW 380
// un := CreateHuman ;
6955: LD_ADDR_VAR 0 2
6959: PUSH
6960: CALL_OW 44
6964: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
6965: LD_VAR 0 2
6969: PPUSH
6970: LD_INT 37
6972: PPUSH
6973: LD_INT 70
6975: PPUSH
6976: LD_INT 3
6978: PPUSH
6979: LD_INT 0
6981: PPUSH
6982: CALL_OW 50
// usAttackers := usAttackers union un ;
6986: LD_ADDR_EXP 43
6990: PUSH
6991: LD_EXP 43
6995: PUSH
6996: LD_VAR 0 2
7000: UNION
7001: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7002: LD_VAR 0 2
7006: PPUSH
7007: LD_INT 40
7009: PPUSH
7010: LD_INT 65
7012: PPUSH
7013: CALL_OW 111
// end ;
7017: GO 6906
7019: POP
7020: POP
// uc_side := 1 ;
7021: LD_ADDR_OWVAR 20
7025: PUSH
7026: LD_INT 1
7028: ST_TO_ADDR
// uc_nation := 1 ;
7029: LD_ADDR_OWVAR 21
7033: PUSH
7034: LD_INT 1
7036: ST_TO_ADDR
// PrepareHuman ( false , 4 , 2 ) ;
7037: LD_INT 0
7039: PPUSH
7040: LD_INT 4
7042: PPUSH
7043: LD_INT 2
7045: PPUSH
7046: CALL_OW 380
// un := CreateHuman ;
7050: LD_ADDR_VAR 0 2
7054: PUSH
7055: CALL_OW 44
7059: ST_TO_ADDR
// PlaceUnitXYR ( un , 37 , 70 , 3 , false ) ;
7060: LD_VAR 0 2
7064: PPUSH
7065: LD_INT 37
7067: PPUSH
7068: LD_INT 70
7070: PPUSH
7071: LD_INT 3
7073: PPUSH
7074: LD_INT 0
7076: PPUSH
7077: CALL_OW 50
// usAttackers := usAttackers union un ;
7081: LD_ADDR_EXP 43
7085: PUSH
7086: LD_EXP 43
7090: PUSH
7091: LD_VAR 0 2
7095: UNION
7096: ST_TO_ADDR
// ComMoveXY ( un , 40 , 65 ) ;
7097: LD_VAR 0 2
7101: PPUSH
7102: LD_INT 40
7104: PPUSH
7105: LD_INT 65
7107: PPUSH
7108: CALL_OW 111
// if attackWave > 1 or Difficulty > 1 then
7112: LD_EXP 16
7116: PUSH
7117: LD_INT 1
7119: GREATER
7120: PUSH
7121: LD_OWVAR 67
7125: PUSH
7126: LD_INT 1
7128: GREATER
7129: OR
7130: IFFALSE 7333
// begin for i := 1 to Difficulty + attackWave div 4 do
7132: LD_ADDR_VAR 0 4
7136: PUSH
7137: DOUBLE
7138: LD_INT 1
7140: DEC
7141: ST_TO_ADDR
7142: LD_OWVAR 67
7146: PUSH
7147: LD_EXP 16
7151: PUSH
7152: LD_INT 4
7154: DIV
7155: PLUS
7156: PUSH
7157: FOR_TO
7158: IFFALSE 7331
// begin veh := PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , [ us_gatling_gun , us_light_gun , us_machine_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
7160: LD_ADDR_VAR 0 3
7164: PUSH
7165: LD_INT 1
7167: PPUSH
7168: LD_INT 1
7170: PPUSH
7171: LD_INT 2
7173: PPUSH
7174: LD_INT 2
7176: PPUSH
7177: LD_INT 1
7179: PPUSH
7180: LD_INT 4
7182: PUSH
7183: LD_INT 3
7185: PUSH
7186: LD_INT 2
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: LIST
7193: PUSH
7194: LD_INT 1
7196: PPUSH
7197: LD_INT 3
7199: PPUSH
7200: CALL_OW 12
7204: ARRAY
7205: PPUSH
7206: LD_INT 90
7208: PPUSH
7209: CALL 331 0 7
7213: ST_TO_ADDR
// PlaceUnitXY ( veh , 35 , 65 , false ) ;
7214: LD_VAR 0 3
7218: PPUSH
7219: LD_INT 35
7221: PPUSH
7222: LD_INT 65
7224: PPUSH
7225: LD_INT 0
7227: PPUSH
7228: CALL_OW 48
// PrepareHuman ( false , 3 , Difficulty + 1 ) ;
7232: LD_INT 0
7234: PPUSH
7235: LD_INT 3
7237: PPUSH
7238: LD_OWVAR 67
7242: PUSH
7243: LD_INT 1
7245: PLUS
7246: PPUSH
7247: CALL_OW 380
// un := CreateHuman ;
7251: LD_ADDR_VAR 0 2
7255: PUSH
7256: CALL_OW 44
7260: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
7261: LD_VAR 0 2
7265: PPUSH
7266: LD_VAR 0 3
7270: PPUSH
7271: CALL_OW 52
// usAttackers := usAttackers union un ;
7275: LD_ADDR_EXP 43
7279: PUSH
7280: LD_EXP 43
7284: PUSH
7285: LD_VAR 0 2
7289: UNION
7290: ST_TO_ADDR
// ComMoveXY ( veh , 39 , 60 ) ;
7291: LD_VAR 0 3
7295: PPUSH
7296: LD_INT 39
7298: PPUSH
7299: LD_INT 60
7301: PPUSH
7302: CALL_OW 111
// wait ( 0 0$2 ) ;
7306: LD_INT 70
7308: PPUSH
7309: CALL_OW 67
// usAttackers := usAttackers union veh ;
7313: LD_ADDR_EXP 43
7317: PUSH
7318: LD_EXP 43
7322: PUSH
7323: LD_VAR 0 3
7327: UNION
7328: ST_TO_ADDR
// end ;
7329: GO 7157
7331: POP
7332: POP
// end ; attackWave := attackWave + 1 ;
7333: LD_ADDR_EXP 16
7337: PUSH
7338: LD_EXP 16
7342: PUSH
7343: LD_INT 1
7345: PLUS
7346: ST_TO_ADDR
// RaiseSailEvent ( eventAttack ) ;
7347: LD_EXP 20
7351: PPUSH
7352: CALL_OW 427
// end ;
7356: LD_VAR 0 1
7360: RET
// export function AmericanAttack ; var i , j , tag , strategy , attackFormula , sol , sci , mech , tanks , veh ; begin
7361: LD_INT 0
7363: PPUSH
7364: PPUSH
7365: PPUSH
7366: PPUSH
7367: PPUSH
7368: PPUSH
7369: PPUSH
7370: PPUSH
7371: PPUSH
7372: PPUSH
7373: PPUSH
// if retreatAllowed then
7374: LD_EXP 10
7378: IFFALSE 7390
// strategy := 2 else
7380: LD_ADDR_VAR 0 5
7384: PUSH
7385: LD_INT 2
7387: ST_TO_ADDR
7388: GO 7406
// strategy := rand ( 0 , 2 ) ;
7390: LD_ADDR_VAR 0 5
7394: PUSH
7395: LD_INT 0
7397: PPUSH
7398: LD_INT 2
7400: PPUSH
7401: CALL_OW 12
7405: ST_TO_ADDR
// attackFormula := [ ] ;
7406: LD_ADDR_VAR 0 6
7410: PUSH
7411: EMPTY
7412: ST_TO_ADDR
// case strategy of 0 :
7413: LD_VAR 0 5
7417: PUSH
7418: LD_INT 0
7420: DOUBLE
7421: EQUAL
7422: IFTRUE 7426
7424: GO 7756
7426: POP
// begin if not FilterUnitsInArea ( southZone , [ [ f_side , 2 ] , [ f_btype , b_armoury ] ] ) then
7427: LD_INT 11
7429: PPUSH
7430: LD_INT 22
7432: PUSH
7433: LD_INT 2
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: PUSH
7440: LD_INT 30
7442: PUSH
7443: LD_INT 4
7445: PUSH
7446: EMPTY
7447: LIST
7448: LIST
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PPUSH
7454: CALL_OW 70
7458: NOT
7459: IFFALSE 7531
// attackFormula := [ [ [ 41 , 34 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7461: LD_ADDR_VAR 0 6
7465: PUSH
7466: LD_INT 41
7468: PUSH
7469: LD_INT 34
7471: PUSH
7472: EMPTY
7473: LIST
7474: LIST
7475: PUSH
7476: EMPTY
7477: LIST
7478: PUSH
7479: LD_INT 53
7481: PUSH
7482: LD_INT 62
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 37
7491: PUSH
7492: LD_INT 63
7494: PUSH
7495: EMPTY
7496: LIST
7497: LIST
7498: PUSH
7499: LD_INT 44
7501: PUSH
7502: LD_INT 45
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 37
7511: PUSH
7512: LD_INT 28
7514: PUSH
7515: EMPTY
7516: LIST
7517: LIST
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: LIST
7527: LIST
7528: ST_TO_ADDR
7529: GO 7754
// if not FilterUnitsInArea ( southForestZone , [ [ f_side , 2 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] ] ] ) then
7531: LD_INT 12
7533: PPUSH
7534: LD_INT 22
7536: PUSH
7537: LD_INT 2
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: PUSH
7544: LD_INT 2
7546: PUSH
7547: LD_INT 30
7549: PUSH
7550: LD_INT 4
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 30
7559: PUSH
7560: LD_INT 31
7562: PUSH
7563: EMPTY
7564: LIST
7565: LIST
7566: PUSH
7567: LD_INT 30
7569: PUSH
7570: LD_INT 32
7572: PUSH
7573: EMPTY
7574: LIST
7575: LIST
7576: PUSH
7577: EMPTY
7578: LIST
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: PPUSH
7587: CALL_OW 70
7591: NOT
7592: IFFALSE 7675
// attackFormula := [ [ [ 27 , 42 ] , [ 27 , 32 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] else
7594: LD_ADDR_VAR 0 6
7598: PUSH
7599: LD_INT 27
7601: PUSH
7602: LD_INT 42
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 27
7611: PUSH
7612: LD_INT 32
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: LD_INT 53
7625: PUSH
7626: LD_INT 62
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: LD_INT 37
7635: PUSH
7636: LD_INT 63
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: PUSH
7643: LD_INT 44
7645: PUSH
7646: LD_INT 45
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 37
7655: PUSH
7656: LD_INT 28
7658: PUSH
7659: EMPTY
7660: LIST
7661: LIST
7662: PUSH
7663: EMPTY
7664: LIST
7665: LIST
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: LIST
7671: LIST
7672: ST_TO_ADDR
7673: GO 7754
// attackFormula := [ [ [ 71 , 67 ] , [ 54 , 35 ] ] , [ 63 , 40 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ;
7675: LD_ADDR_VAR 0 6
7679: PUSH
7680: LD_INT 71
7682: PUSH
7683: LD_INT 67
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: PUSH
7690: LD_INT 54
7692: PUSH
7693: LD_INT 35
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 63
7706: PUSH
7707: LD_INT 40
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: PUSH
7714: LD_INT 37
7716: PUSH
7717: LD_INT 63
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PUSH
7724: LD_INT 44
7726: PUSH
7727: LD_INT 45
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PUSH
7734: LD_INT 37
7736: PUSH
7737: LD_INT 28
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: PUSH
7744: EMPTY
7745: LIST
7746: LIST
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: ST_TO_ADDR
// end ; 1 :
7754: GO 7959
7756: LD_INT 1
7758: DOUBLE
7759: EQUAL
7760: IFTRUE 7764
7762: GO 7868
7764: POP
// attackFormula := [ [ [ 71 , 67 ] , [ 82 , 23 ] , [ 53 , 7 ] , [ 43 , 10 ] ] , [ 53 , 62 ] , [ 37 , 63 ] , [ [ 44 , 45 ] , [ 37 , 28 ] ] ] ; 2 :
7765: LD_ADDR_VAR 0 6
7769: PUSH
7770: LD_INT 71
7772: PUSH
7773: LD_INT 67
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: PUSH
7780: LD_INT 82
7782: PUSH
7783: LD_INT 23
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 53
7792: PUSH
7793: LD_INT 7
7795: PUSH
7796: EMPTY
7797: LIST
7798: LIST
7799: PUSH
7800: LD_INT 43
7802: PUSH
7803: LD_INT 10
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: LD_INT 53
7818: PUSH
7819: LD_INT 62
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PUSH
7826: LD_INT 37
7828: PUSH
7829: LD_INT 63
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PUSH
7836: LD_INT 44
7838: PUSH
7839: LD_INT 45
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 37
7848: PUSH
7849: LD_INT 28
7851: PUSH
7852: EMPTY
7853: LIST
7854: LIST
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: LIST
7863: LIST
7864: LIST
7865: ST_TO_ADDR
7866: GO 7959
7868: LD_INT 2
7870: DOUBLE
7871: EQUAL
7872: IFTRUE 7876
7874: GO 7958
7876: POP
// attackFormula := [ [ [ 90 , 59 ] , [ 108 , 64 ] ] , [ 82 , 75 ] , [ 73 , 67 ] , [ [ 101 , 65 ] , [ 108 , 62 ] ] ] ; end ;
7877: LD_ADDR_VAR 0 6
7881: PUSH
7882: LD_INT 90
7884: PUSH
7885: LD_INT 59
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PUSH
7892: LD_INT 108
7894: PUSH
7895: LD_INT 64
7897: PUSH
7898: EMPTY
7899: LIST
7900: LIST
7901: PUSH
7902: EMPTY
7903: LIST
7904: LIST
7905: PUSH
7906: LD_INT 82
7908: PUSH
7909: LD_INT 75
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PUSH
7916: LD_INT 73
7918: PUSH
7919: LD_INT 67
7921: PUSH
7922: EMPTY
7923: LIST
7924: LIST
7925: PUSH
7926: LD_INT 101
7928: PUSH
7929: LD_INT 65
7931: PUSH
7932: EMPTY
7933: LIST
7934: LIST
7935: PUSH
7936: LD_INT 108
7938: PUSH
7939: LD_INT 62
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: PUSH
7946: EMPTY
7947: LIST
7948: LIST
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: LIST
7954: LIST
7955: ST_TO_ADDR
7956: GO 7959
7958: POP
// if not attackFormula then
7959: LD_VAR 0 6
7963: NOT
7964: IFFALSE 7968
// exit ;
7966: GO 9400
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
7968: LD_ADDR_VAR 0 7
7972: PUSH
7973: LD_EXP 43
7977: PPUSH
7978: LD_INT 25
7980: PUSH
7981: LD_INT 1
7983: PUSH
7984: EMPTY
7985: LIST
7986: LIST
7987: PPUSH
7988: CALL_OW 72
7992: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
7993: LD_ADDR_VAR 0 8
7997: PUSH
7998: LD_EXP 43
8002: PPUSH
8003: LD_INT 25
8005: PUSH
8006: LD_INT 4
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8018: LD_ADDR_VAR 0 9
8022: PUSH
8023: LD_EXP 43
8027: PPUSH
8028: LD_INT 25
8030: PUSH
8031: LD_INT 3
8033: PUSH
8034: EMPTY
8035: LIST
8036: LIST
8037: PPUSH
8038: CALL_OW 72
8042: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8043: LD_ADDR_VAR 0 10
8047: PUSH
8048: LD_EXP 43
8052: PPUSH
8053: LD_INT 21
8055: PUSH
8056: LD_INT 2
8058: PUSH
8059: EMPTY
8060: LIST
8061: LIST
8062: PPUSH
8063: CALL_OW 72
8067: ST_TO_ADDR
// if sci then
8068: LD_VAR 0 8
8072: IFFALSE 8109
// ComMoveXY ( sci , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8074: LD_VAR 0 8
8078: PPUSH
8079: LD_VAR 0 6
8083: PUSH
8084: LD_INT 2
8086: ARRAY
8087: PUSH
8088: LD_INT 1
8090: ARRAY
8091: PPUSH
8092: LD_VAR 0 6
8096: PUSH
8097: LD_INT 2
8099: ARRAY
8100: PUSH
8101: LD_INT 2
8103: ARRAY
8104: PPUSH
8105: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
8109: LD_INT 35
8111: PPUSH
8112: CALL_OW 67
// sol := UnitFilter ( usAttackers , [ f_class , 1 ] ) ;
8116: LD_ADDR_VAR 0 7
8120: PUSH
8121: LD_EXP 43
8125: PPUSH
8126: LD_INT 25
8128: PUSH
8129: LD_INT 1
8131: PUSH
8132: EMPTY
8133: LIST
8134: LIST
8135: PPUSH
8136: CALL_OW 72
8140: ST_TO_ADDR
// sci := UnitFilter ( usAttackers , [ f_class , 4 ] ) ;
8141: LD_ADDR_VAR 0 8
8145: PUSH
8146: LD_EXP 43
8150: PPUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 4
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PPUSH
8161: CALL_OW 72
8165: ST_TO_ADDR
// mech := UnitFilter ( usAttackers , [ f_class , 3 ] ) ;
8166: LD_ADDR_VAR 0 9
8170: PUSH
8171: LD_EXP 43
8175: PPUSH
8176: LD_INT 25
8178: PUSH
8179: LD_INT 3
8181: PUSH
8182: EMPTY
8183: LIST
8184: LIST
8185: PPUSH
8186: CALL_OW 72
8190: ST_TO_ADDR
// tanks := UnitFilter ( usAttackers , [ f_type , unit_vehicle ] ) ;
8191: LD_ADDR_VAR 0 10
8195: PUSH
8196: LD_EXP 43
8200: PPUSH
8201: LD_INT 21
8203: PUSH
8204: LD_INT 2
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 72
8215: ST_TO_ADDR
// if sol then
8216: LD_VAR 0 7
8220: IFFALSE 8615
// begin for i in sol do
8222: LD_ADDR_VAR 0 2
8226: PUSH
8227: LD_VAR 0 7
8231: PUSH
8232: FOR_IN
8233: IFFALSE 8613
// begin tag := GetTag ( i ) ;
8235: LD_ADDR_VAR 0 4
8239: PUSH
8240: LD_VAR 0 2
8244: PPUSH
8245: CALL_OW 110
8249: ST_TO_ADDR
// if not tag then
8250: LD_VAR 0 4
8254: NOT
8255: IFFALSE 8373
// begin if GetLives ( i ) = 1000 then
8257: LD_VAR 0 2
8261: PPUSH
8262: CALL_OW 256
8266: PUSH
8267: LD_INT 1000
8269: EQUAL
8270: IFFALSE 8286
// SetTag ( i , 1 ) else
8272: LD_VAR 0 2
8276: PPUSH
8277: LD_INT 1
8279: PPUSH
8280: CALL_OW 109
8284: GO 8371
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 6 then
8286: LD_VAR 0 2
8290: PPUSH
8291: LD_VAR 0 6
8295: PUSH
8296: LD_INT 2
8298: ARRAY
8299: PUSH
8300: LD_INT 1
8302: ARRAY
8303: PPUSH
8304: LD_VAR 0 6
8308: PUSH
8309: LD_INT 2
8311: ARRAY
8312: PUSH
8313: LD_INT 2
8315: ARRAY
8316: PPUSH
8317: CALL_OW 297
8321: PUSH
8322: LD_INT 6
8324: GREATER
8325: IFFALSE 8371
// begin ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8327: LD_VAR 0 2
8331: PPUSH
8332: LD_VAR 0 6
8336: PUSH
8337: LD_INT 2
8339: ARRAY
8340: PUSH
8341: LD_INT 1
8343: ARRAY
8344: PPUSH
8345: LD_VAR 0 6
8349: PUSH
8350: LD_INT 2
8352: ARRAY
8353: PUSH
8354: LD_INT 2
8356: ARRAY
8357: PPUSH
8358: CALL_OW 111
// AddComHold ( i ) ;
8362: LD_VAR 0 2
8366: PPUSH
8367: CALL_OW 200
// end ; end else
8371: GO 8611
// begin if GetLives ( i ) < 720 then
8373: LD_VAR 0 2
8377: PPUSH
8378: CALL_OW 256
8382: PUSH
8383: LD_INT 720
8385: LESS
8386: IFFALSE 8402
// SetTag ( i , 0 ) else
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 0
8395: PPUSH
8396: CALL_OW 109
8400: GO 8611
// if tag <= attackFormula [ 1 ] then
8402: LD_VAR 0 4
8406: PUSH
8407: LD_VAR 0 6
8411: PUSH
8412: LD_INT 1
8414: ARRAY
8415: LESSEQUAL
8416: IFFALSE 8577
// begin if GetDistUnitXY ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) > 6 then
8418: LD_VAR 0 2
8422: PPUSH
8423: LD_VAR 0 6
8427: PUSH
8428: LD_INT 1
8430: ARRAY
8431: PUSH
8432: LD_VAR 0 4
8436: ARRAY
8437: PUSH
8438: LD_INT 1
8440: ARRAY
8441: PPUSH
8442: LD_VAR 0 6
8446: PUSH
8447: LD_INT 1
8449: ARRAY
8450: PUSH
8451: LD_VAR 0 4
8455: ARRAY
8456: PUSH
8457: LD_INT 2
8459: ARRAY
8460: PPUSH
8461: CALL_OW 297
8465: PUSH
8466: LD_INT 6
8468: GREATER
8469: IFFALSE 8520
// ComAgressiveMove ( i , attackFormula [ 1 ] [ tag ] [ 1 ] , attackFormula [ 1 ] [ tag ] [ 2 ] ) else
8471: LD_VAR 0 2
8475: PPUSH
8476: LD_VAR 0 6
8480: PUSH
8481: LD_INT 1
8483: ARRAY
8484: PUSH
8485: LD_VAR 0 4
8489: ARRAY
8490: PUSH
8491: LD_INT 1
8493: ARRAY
8494: PPUSH
8495: LD_VAR 0 6
8499: PUSH
8500: LD_INT 1
8502: ARRAY
8503: PUSH
8504: LD_VAR 0 4
8508: ARRAY
8509: PUSH
8510: LD_INT 2
8512: ARRAY
8513: PPUSH
8514: CALL_OW 114
8518: GO 8575
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
8520: LD_INT 81
8522: PUSH
8523: LD_INT 1
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PUSH
8530: LD_INT 91
8532: PUSH
8533: LD_VAR 0 2
8537: PUSH
8538: LD_INT 10
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: LIST
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PPUSH
8550: CALL_OW 69
8554: NOT
8555: IFFALSE 8575
// SetTag ( i , tag + 1 ) ;
8557: LD_VAR 0 2
8561: PPUSH
8562: LD_VAR 0 4
8566: PUSH
8567: LD_INT 1
8569: PLUS
8570: PPUSH
8571: CALL_OW 109
// end else
8575: GO 8611
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
8577: LD_VAR 0 2
8581: PPUSH
8582: LD_INT 81
8584: PUSH
8585: LD_INT 1
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: PPUSH
8592: CALL_OW 69
8596: PPUSH
8597: LD_VAR 0 2
8601: PPUSH
8602: CALL_OW 74
8606: PPUSH
8607: CALL_OW 115
// end ; end ;
8611: GO 8232
8613: POP
8614: POP
// end ; if sci then
8615: LD_VAR 0 8
8619: IFFALSE 8778
// begin if not sol and not mech then
8621: LD_VAR 0 7
8625: NOT
8626: PUSH
8627: LD_VAR 0 9
8631: NOT
8632: AND
8633: IFFALSE 8685
// begin for i in sci do
8635: LD_ADDR_VAR 0 2
8639: PUSH
8640: LD_VAR 0 8
8644: PUSH
8645: FOR_IN
8646: IFFALSE 8681
// begin usForces := usForces union i ;
8648: LD_ADDR_EXP 40
8652: PUSH
8653: LD_EXP 40
8657: PUSH
8658: LD_VAR 0 2
8662: UNION
8663: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
8664: LD_VAR 0 2
8668: PPUSH
8669: LD_INT 34
8671: PPUSH
8672: LD_INT 68
8674: PPUSH
8675: CALL_OW 111
// end ;
8679: GO 8645
8681: POP
8682: POP
// end else
8683: GO 8778
// for i in sci do
8685: LD_ADDR_VAR 0 2
8689: PUSH
8690: LD_VAR 0 8
8694: PUSH
8695: FOR_IN
8696: IFFALSE 8776
// if GetDistUnitXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) > 8 then
8698: LD_VAR 0 2
8702: PPUSH
8703: LD_VAR 0 6
8707: PUSH
8708: LD_INT 2
8710: ARRAY
8711: PUSH
8712: LD_INT 1
8714: ARRAY
8715: PPUSH
8716: LD_VAR 0 6
8720: PUSH
8721: LD_INT 2
8723: ARRAY
8724: PUSH
8725: LD_INT 2
8727: ARRAY
8728: PPUSH
8729: CALL_OW 297
8733: PUSH
8734: LD_INT 8
8736: GREATER
8737: IFFALSE 8774
// ComMoveXY ( i , attackFormula [ 2 ] [ 1 ] , attackFormula [ 2 ] [ 2 ] ) ;
8739: LD_VAR 0 2
8743: PPUSH
8744: LD_VAR 0 6
8748: PUSH
8749: LD_INT 2
8751: ARRAY
8752: PUSH
8753: LD_INT 1
8755: ARRAY
8756: PPUSH
8757: LD_VAR 0 6
8761: PUSH
8762: LD_INT 2
8764: ARRAY
8765: PUSH
8766: LD_INT 2
8768: ARRAY
8769: PPUSH
8770: CALL_OW 111
8774: GO 8695
8776: POP
8777: POP
// end ; if tanks and mech then
8778: LD_VAR 0 10
8782: PUSH
8783: LD_VAR 0 9
8787: AND
8788: IFFALSE 9393
// begin for i in mech do
8790: LD_ADDR_VAR 0 2
8794: PUSH
8795: LD_VAR 0 9
8799: PUSH
8800: FOR_IN
8801: IFFALSE 9391
// begin tag := GetTag ( i ) ;
8803: LD_ADDR_VAR 0 4
8807: PUSH
8808: LD_VAR 0 2
8812: PPUSH
8813: CALL_OW 110
8817: ST_TO_ADDR
// veh := IsInUnit ( i ) ;
8818: LD_ADDR_VAR 0 11
8822: PUSH
8823: LD_VAR 0 2
8827: PPUSH
8828: CALL_OW 310
8832: ST_TO_ADDR
// if not tag then
8833: LD_VAR 0 4
8837: NOT
8838: IFFALSE 9151
// begin if veh then
8840: LD_VAR 0 11
8844: IFFALSE 8993
// begin if GetLives ( veh ) = 1000 and GetFuel ( veh ) > 60 then
8846: LD_VAR 0 11
8850: PPUSH
8851: CALL_OW 256
8855: PUSH
8856: LD_INT 1000
8858: EQUAL
8859: PUSH
8860: LD_VAR 0 11
8864: PPUSH
8865: CALL_OW 261
8869: PUSH
8870: LD_INT 60
8872: GREATER
8873: AND
8874: IFFALSE 8890
// SetTag ( i , 1 ) else
8876: LD_VAR 0 2
8880: PPUSH
8881: LD_INT 1
8883: PPUSH
8884: CALL_OW 109
8888: GO 8991
// if GetDistUnitXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) > 7 then
8890: LD_VAR 0 2
8894: PPUSH
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 3
8902: ARRAY
8903: PUSH
8904: LD_INT 1
8906: ARRAY
8907: PPUSH
8908: LD_VAR 0 6
8912: PUSH
8913: LD_INT 3
8915: ARRAY
8916: PUSH
8917: LD_INT 2
8919: ARRAY
8920: PPUSH
8921: CALL_OW 297
8925: PUSH
8926: LD_INT 7
8928: GREATER
8929: IFFALSE 8968
// ComMoveXY ( i , attackFormula [ 3 ] [ 1 ] , attackFormula [ 3 ] [ 2 ] ) else
8931: LD_VAR 0 2
8935: PPUSH
8936: LD_VAR 0 6
8940: PUSH
8941: LD_INT 3
8943: ARRAY
8944: PUSH
8945: LD_INT 1
8947: ARRAY
8948: PPUSH
8949: LD_VAR 0 6
8953: PUSH
8954: LD_INT 3
8956: ARRAY
8957: PUSH
8958: LD_INT 2
8960: ARRAY
8961: PPUSH
8962: CALL_OW 111
8966: GO 8991
// begin ComExitVehicle ( i ) ;
8968: LD_VAR 0 2
8972: PPUSH
8973: CALL_OW 121
// AddComRepairVehicle ( i , veh ) ;
8977: LD_VAR 0 2
8981: PPUSH
8982: LD_VAR 0 11
8986: PPUSH
8987: CALL_OW 189
// end ; end else
8991: GO 9149
// if GetLives ( i ) < 700 then
8993: LD_VAR 0 2
8997: PPUSH
8998: CALL_OW 256
9002: PUSH
9003: LD_INT 700
9005: LESS
9006: IFFALSE 9057
// begin usAttackers := usAttackers diff i ;
9008: LD_ADDR_EXP 43
9012: PUSH
9013: LD_EXP 43
9017: PUSH
9018: LD_VAR 0 2
9022: DIFF
9023: ST_TO_ADDR
// usForces := usForces union i ;
9024: LD_ADDR_EXP 40
9028: PUSH
9029: LD_EXP 40
9033: PUSH
9034: LD_VAR 0 2
9038: UNION
9039: ST_TO_ADDR
// ComMoveXY ( i , 34 , 68 ) ;
9040: LD_VAR 0 2
9044: PPUSH
9045: LD_INT 34
9047: PPUSH
9048: LD_INT 68
9050: PPUSH
9051: CALL_OW 111
// end else
9055: GO 9149
// if UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) and not HasTask ( i ) then
9057: LD_VAR 0 10
9061: PPUSH
9062: LD_INT 58
9064: PUSH
9065: EMPTY
9066: LIST
9067: PUSH
9068: LD_INT 24
9070: PUSH
9071: LD_INT 1000
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: PPUSH
9082: CALL_OW 72
9086: PUSH
9087: LD_VAR 0 2
9091: PPUSH
9092: CALL_OW 314
9096: NOT
9097: AND
9098: IFFALSE 9149
// ComEnterUnit ( i , NearestUnitToUnit ( UnitFilter ( tanks , [ [ f_empty ] , [ f_lives , 1000 ] ] ) , i ) ) ;
9100: LD_VAR 0 2
9104: PPUSH
9105: LD_VAR 0 10
9109: PPUSH
9110: LD_INT 58
9112: PUSH
9113: EMPTY
9114: LIST
9115: PUSH
9116: LD_INT 24
9118: PUSH
9119: LD_INT 1000
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PPUSH
9130: CALL_OW 72
9134: PPUSH
9135: LD_VAR 0 2
9139: PPUSH
9140: CALL_OW 74
9144: PPUSH
9145: CALL_OW 120
// end else
9149: GO 9389
// begin if GetLives ( veh ) < 620 then
9151: LD_VAR 0 11
9155: PPUSH
9156: CALL_OW 256
9160: PUSH
9161: LD_INT 620
9163: LESS
9164: IFFALSE 9180
// SetTag ( i , 0 ) else
9166: LD_VAR 0 2
9170: PPUSH
9171: LD_INT 0
9173: PPUSH
9174: CALL_OW 109
9178: GO 9389
// if tag <= attackFormula [ 4 ] then
9180: LD_VAR 0 4
9184: PUSH
9185: LD_VAR 0 6
9189: PUSH
9190: LD_INT 4
9192: ARRAY
9193: LESSEQUAL
9194: IFFALSE 9355
// begin if GetDistUnitXY ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) > 6 then
9196: LD_VAR 0 2
9200: PPUSH
9201: LD_VAR 0 6
9205: PUSH
9206: LD_INT 4
9208: ARRAY
9209: PUSH
9210: LD_VAR 0 4
9214: ARRAY
9215: PUSH
9216: LD_INT 1
9218: ARRAY
9219: PPUSH
9220: LD_VAR 0 6
9224: PUSH
9225: LD_INT 4
9227: ARRAY
9228: PUSH
9229: LD_VAR 0 4
9233: ARRAY
9234: PUSH
9235: LD_INT 2
9237: ARRAY
9238: PPUSH
9239: CALL_OW 297
9243: PUSH
9244: LD_INT 6
9246: GREATER
9247: IFFALSE 9298
// ComAgressiveMove ( i , attackFormula [ 4 ] [ tag ] [ 1 ] , attackFormula [ 4 ] [ tag ] [ 2 ] ) else
9249: LD_VAR 0 2
9253: PPUSH
9254: LD_VAR 0 6
9258: PUSH
9259: LD_INT 4
9261: ARRAY
9262: PUSH
9263: LD_VAR 0 4
9267: ARRAY
9268: PUSH
9269: LD_INT 1
9271: ARRAY
9272: PPUSH
9273: LD_VAR 0 6
9277: PUSH
9278: LD_INT 4
9280: ARRAY
9281: PUSH
9282: LD_VAR 0 4
9286: ARRAY
9287: PUSH
9288: LD_INT 2
9290: ARRAY
9291: PPUSH
9292: CALL_OW 114
9296: GO 9353
// if not FilterAllUnits ( [ [ f_enemy , 1 ] , [ f_dist , i , 10 ] ] ) then
9298: LD_INT 81
9300: PUSH
9301: LD_INT 1
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: PUSH
9308: LD_INT 91
9310: PUSH
9311: LD_VAR 0 2
9315: PUSH
9316: LD_INT 10
9318: PUSH
9319: EMPTY
9320: LIST
9321: LIST
9322: LIST
9323: PUSH
9324: EMPTY
9325: LIST
9326: LIST
9327: PPUSH
9328: CALL_OW 69
9332: NOT
9333: IFFALSE 9353
// SetTag ( i , tag + 1 ) ;
9335: LD_VAR 0 2
9339: PPUSH
9340: LD_VAR 0 4
9344: PUSH
9345: LD_INT 1
9347: PLUS
9348: PPUSH
9349: CALL_OW 109
// end else
9353: GO 9389
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
9355: LD_VAR 0 2
9359: PPUSH
9360: LD_INT 81
9362: PUSH
9363: LD_INT 1
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: PPUSH
9370: CALL_OW 69
9374: PPUSH
9375: LD_VAR 0 2
9379: PPUSH
9380: CALL_OW 74
9384: PPUSH
9385: CALL_OW 115
// end ; end ;
9389: GO 8800
9391: POP
9392: POP
// end ; until not usAttackers ;
9393: LD_EXP 43
9397: NOT
9398: IFFALSE 8109
// end ; end_of_file
9400: LD_VAR 0 1
9404: RET
// export function Action ; var hasAll , i , tmp ; begin
9405: LD_INT 0
9407: PPUSH
9408: PPUSH
9409: PPUSH
9410: PPUSH
// hasAll := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) >= 7 ;
9411: LD_ADDR_VAR 0 2
9415: PUSH
9416: LD_INT 22
9418: PUSH
9419: LD_INT 2
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: PUSH
9426: LD_INT 21
9428: PUSH
9429: LD_INT 1
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PUSH
9436: LD_INT 23
9438: PUSH
9439: LD_INT 2
9441: PUSH
9442: EMPTY
9443: LIST
9444: LIST
9445: PUSH
9446: EMPTY
9447: LIST
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: PUSH
9456: LD_INT 7
9458: GREATEREQUAL
9459: ST_TO_ADDR
// Video ( true ) ;
9460: LD_INT 1
9462: PPUSH
9463: CALL 991 0 1
// CenterNowOnUnits ( Heike ) ;
9467: LD_EXP 24
9471: PPUSH
9472: CALL_OW 87
// wait ( 0 0$2 ) ;
9476: LD_INT 70
9478: PPUSH
9479: CALL_OW 67
// Say ( Farmer , DF-1-start ) ;
9483: LD_EXP 32
9487: PPUSH
9488: LD_STRING DF-1-start
9490: PPUSH
9491: CALL_OW 88
// ComTurnUnit ( Heike , Farmer ) ;
9495: LD_EXP 24
9499: PPUSH
9500: LD_EXP 32
9504: PPUSH
9505: CALL_OW 119
// Say ( Heike , DH-1-start ) ;
9509: LD_EXP 24
9513: PPUSH
9514: LD_STRING DH-1-start
9516: PPUSH
9517: CALL_OW 88
// ComMoveXY ( Omar , 92 , 21 ) ;
9521: LD_EXP 33
9525: PPUSH
9526: LD_INT 92
9528: PPUSH
9529: LD_INT 21
9531: PPUSH
9532: CALL_OW 111
// ComMoveXY ( Aviradze , 94 , 23 ) ;
9536: LD_EXP 28
9540: PPUSH
9541: LD_INT 94
9543: PPUSH
9544: LD_INT 23
9546: PPUSH
9547: CALL_OW 111
// ComMoveXY ( omarSquad [ 1 ] , 90 , 23 ) ;
9551: LD_EXP 36
9555: PUSH
9556: LD_INT 1
9558: ARRAY
9559: PPUSH
9560: LD_INT 90
9562: PPUSH
9563: LD_INT 23
9565: PPUSH
9566: CALL_OW 111
// ComMoveXY ( omarSquad [ 2 ] , 93 , 25 ) ;
9570: LD_EXP 36
9574: PUSH
9575: LD_INT 2
9577: ARRAY
9578: PPUSH
9579: LD_INT 93
9581: PPUSH
9582: LD_INT 25
9584: PPUSH
9585: CALL_OW 111
// AddComTurnUnit ( omarSquad , Omar ) ;
9589: LD_EXP 36
9593: PPUSH
9594: LD_EXP 33
9598: PPUSH
9599: CALL_OW 179
// AddComTurnUnit ( [ Omar , Aviradze ] , Heike ) ;
9603: LD_EXP 33
9607: PUSH
9608: LD_EXP 28
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PPUSH
9617: LD_EXP 24
9621: PPUSH
9622: CALL_OW 179
// AddComTurnUnit ( Heike , Omar ) ;
9626: LD_EXP 24
9630: PPUSH
9631: LD_EXP 33
9635: PPUSH
9636: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9640: LD_INT 35
9642: PPUSH
9643: CALL_OW 67
// until IsAt ( Omar , 92 , 21 ) ;
9647: LD_EXP 33
9651: PPUSH
9652: LD_INT 92
9654: PPUSH
9655: LD_INT 21
9657: PPUSH
9658: CALL_OW 307
9662: IFFALSE 9640
// Say ( Omar , DO-1-start ) ;
9664: LD_EXP 33
9668: PPUSH
9669: LD_STRING DO-1-start
9671: PPUSH
9672: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
9676: LD_EXP 24
9680: PPUSH
9681: LD_STRING DH-2-start
9683: PPUSH
9684: CALL_OW 88
// if hasAll then
9688: LD_VAR 0 2
9692: IFFALSE 9820
// begin Say ( Omar , DO-2-start ) ;
9694: LD_EXP 33
9698: PPUSH
9699: LD_STRING DO-2-start
9701: PPUSH
9702: CALL_OW 88
// Say ( Omar , DO-3-start ) ;
9706: LD_EXP 33
9710: PPUSH
9711: LD_STRING DO-3-start
9713: PPUSH
9714: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
9718: LD_EXP 24
9722: PPUSH
9723: LD_STRING DH-3-start
9725: PPUSH
9726: CALL_OW 88
// Say ( Farmer , DF-2-start ) ;
9730: LD_EXP 32
9734: PPUSH
9735: LD_STRING DF-2-start
9737: PPUSH
9738: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9742: LD_EXP 33
9746: PPUSH
9747: LD_EXP 32
9751: PPUSH
9752: CALL_OW 119
// Say ( Omar , DO-4-start ) ;
9756: LD_EXP 33
9760: PPUSH
9761: LD_STRING DO-4-start
9763: PPUSH
9764: CALL_OW 88
// Say ( Farmer , DF-3-start ) ;
9768: LD_EXP 32
9772: PPUSH
9773: LD_STRING DF-3-start
9775: PPUSH
9776: CALL_OW 88
// Say ( Omar , DO-5-start ) ;
9780: LD_EXP 33
9784: PPUSH
9785: LD_STRING DO-5-start
9787: PPUSH
9788: CALL_OW 88
// Say ( Farmer , DF-4-start ) ;
9792: LD_EXP 32
9796: PPUSH
9797: LD_STRING DF-4-start
9799: PPUSH
9800: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
9804: LD_EXP 33
9808: PPUSH
9809: LD_EXP 24
9813: PPUSH
9814: CALL_OW 119
// end else
9818: GO 9920
// begin Say ( Omar , DO-2-start-a ) ;
9820: LD_EXP 33
9824: PPUSH
9825: LD_STRING DO-2-start-a
9827: PPUSH
9828: CALL_OW 88
// Say ( Omar , DO-3-start-a ) ;
9832: LD_EXP 33
9836: PPUSH
9837: LD_STRING DO-3-start-a
9839: PPUSH
9840: CALL_OW 88
// Say ( Heike , DH-3-start-a ) ;
9844: LD_EXP 24
9848: PPUSH
9849: LD_STRING DH-3-start-a
9851: PPUSH
9852: CALL_OW 88
// Say ( Farmer , DF-2-start-a ) ;
9856: LD_EXP 32
9860: PPUSH
9861: LD_STRING DF-2-start-a
9863: PPUSH
9864: CALL_OW 88
// ComTurnUnit ( Omar , Farmer ) ;
9868: LD_EXP 33
9872: PPUSH
9873: LD_EXP 32
9877: PPUSH
9878: CALL_OW 119
// Say ( Omar , DO-4-start-a ) ;
9882: LD_EXP 33
9886: PPUSH
9887: LD_STRING DO-4-start-a
9889: PPUSH
9890: CALL_OW 88
// Say ( Farmer , DF-3-start-a ) ;
9894: LD_EXP 32
9898: PPUSH
9899: LD_STRING DF-3-start-a
9901: PPUSH
9902: CALL_OW 88
// ComTurnUnit ( Omar , Heike ) ;
9906: LD_EXP 33
9910: PPUSH
9911: LD_EXP 24
9915: PPUSH
9916: CALL_OW 119
// end ; wait ( 0 0$0.3 ) ;
9920: LD_INT 10
9922: PPUSH
9923: CALL_OW 67
// Say ( Omar , DO-1-mission ) ;
9927: LD_EXP 33
9931: PPUSH
9932: LD_STRING DO-1-mission
9934: PPUSH
9935: CALL_OW 88
// Say ( Omar , DO-2-mission ) ;
9939: LD_EXP 33
9943: PPUSH
9944: LD_STRING DO-2-mission
9946: PPUSH
9947: CALL_OW 88
// if not hasAll then
9951: LD_VAR 0 2
9955: NOT
9956: IFFALSE 9970
// Say ( Omar , DO-3-mission ) ;
9958: LD_EXP 33
9962: PPUSH
9963: LD_STRING DO-3-mission
9965: PPUSH
9966: CALL_OW 88
// Say ( Omar , DO-4-mission ) ;
9970: LD_EXP 33
9974: PPUSH
9975: LD_STRING DO-4-mission
9977: PPUSH
9978: CALL_OW 88
// Say ( Heike , DH-1-mission ) ;
9982: LD_EXP 24
9986: PPUSH
9987: LD_STRING DH-1-mission
9989: PPUSH
9990: CALL_OW 88
// Say ( Farmer , DF-1-mission ) ;
9994: LD_EXP 32
9998: PPUSH
9999: LD_STRING DF-1-mission
10001: PPUSH
10002: CALL_OW 88
// Say ( Omar , DO-5-mission ) ;
10006: LD_EXP 33
10010: PPUSH
10011: LD_STRING DO-5-mission
10013: PPUSH
10014: CALL_OW 88
// if not hasAll then
10018: LD_VAR 0 2
10022: NOT
10023: IFFALSE 10158
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , nation_arabian ] ] ) ;
10025: LD_ADDR_VAR 0 4
10029: PUSH
10030: LD_INT 22
10032: PUSH
10033: LD_INT 2
10035: PUSH
10036: EMPTY
10037: LIST
10038: LIST
10039: PUSH
10040: LD_INT 21
10042: PUSH
10043: LD_INT 1
10045: PUSH
10046: EMPTY
10047: LIST
10048: LIST
10049: PUSH
10050: LD_INT 23
10052: PUSH
10053: LD_INT 2
10055: PUSH
10056: EMPTY
10057: LIST
10058: LIST
10059: PUSH
10060: EMPTY
10061: LIST
10062: LIST
10063: LIST
10064: PPUSH
10065: CALL_OW 69
10069: ST_TO_ADDR
// for i := 7 downto tmp do
10070: LD_ADDR_VAR 0 3
10074: PUSH
10075: DOUBLE
10076: LD_INT 7
10078: INC
10079: ST_TO_ADDR
10080: LD_VAR 0 4
10084: PUSH
10085: FOR_DOWNTO
10086: IFFALSE 10156
// begin if omarSquad < 3 then
10088: LD_EXP 36
10092: PUSH
10093: LD_INT 3
10095: LESS
10096: IFFALSE 10100
// break ;
10098: GO 10156
// SetSide ( omarSquad [ 3 ] , 2 ) ;
10100: LD_EXP 36
10104: PUSH
10105: LD_INT 3
10107: ARRAY
10108: PPUSH
10109: LD_INT 2
10111: PPUSH
10112: CALL_OW 235
// heikeSecondSquad := heikeSecondSquad union omarSquad [ 3 ] ;
10116: LD_ADDR_EXP 38
10120: PUSH
10121: LD_EXP 38
10125: PUSH
10126: LD_EXP 36
10130: PUSH
10131: LD_INT 3
10133: ARRAY
10134: UNION
10135: ST_TO_ADDR
// omarSquad := Delete ( omarSquad , 3 ) ;
10136: LD_ADDR_EXP 36
10140: PUSH
10141: LD_EXP 36
10145: PPUSH
10146: LD_INT 3
10148: PPUSH
10149: CALL_OW 3
10153: ST_TO_ADDR
// end ;
10154: GO 10085
10156: POP
10157: POP
// end ; ComMoveXY ( Omar ^ omarSquad , 103 , 9 ) ;
10158: LD_EXP 33
10162: PUSH
10163: LD_EXP 36
10167: ADD
10168: PPUSH
10169: LD_INT 103
10171: PPUSH
10172: LD_INT 9
10174: PPUSH
10175: CALL_OW 111
// if hasAll and IsOk ( Kaia ) then
10179: LD_VAR 0 2
10183: PUSH
10184: LD_EXP 29
10188: PPUSH
10189: CALL_OW 302
10193: AND
10194: IFFALSE 10255
// begin wait ( 0 0$3 ) ;
10196: LD_INT 105
10198: PPUSH
10199: CALL_OW 67
// ComTurnUnit ( Kaia , Farmer ) ;
10203: LD_EXP 29
10207: PPUSH
10208: LD_EXP 32
10212: PPUSH
10213: CALL_OW 119
// Say ( Kaia , DK-1-side ) ;
10217: LD_EXP 29
10221: PPUSH
10222: LD_STRING DK-1-side
10224: PPUSH
10225: CALL_OW 88
// ComTurnUnit ( Farmer , Kaia ) ;
10229: LD_EXP 32
10233: PPUSH
10234: LD_EXP 29
10238: PPUSH
10239: CALL_OW 119
// Say ( Farmer , DF-1-side ) ;
10243: LD_EXP 32
10247: PPUSH
10248: LD_STRING DF-1-side
10250: PPUSH
10251: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10255: LD_INT 22
10257: PUSH
10258: LD_INT 2
10260: PUSH
10261: EMPTY
10262: LIST
10263: LIST
10264: PPUSH
10265: CALL_OW 69
10269: PPUSH
10270: CALL_OW 139
// ComMoveXY ( Farmer ^ farmerSquad , 108 , 62 ) ;
10274: LD_EXP 32
10278: PUSH
10279: LD_EXP 35
10283: ADD
10284: PPUSH
10285: LD_INT 108
10287: PPUSH
10288: LD_INT 62
10290: PPUSH
10291: CALL_OW 111
// gameStarted := true ;
10295: LD_ADDR_EXP 3
10299: PUSH
10300: LD_INT 1
10302: ST_TO_ADDR
// wait ( 0 0$3 ) ;
10303: LD_INT 105
10305: PPUSH
10306: CALL_OW 67
// CenterOnUnits ( Heike ) ;
10310: LD_EXP 24
10314: PPUSH
10315: CALL_OW 85
// ComTurnUnit ( Heike , Aviradze ) ;
10319: LD_EXP 24
10323: PPUSH
10324: LD_EXP 28
10328: PPUSH
10329: CALL_OW 119
// ComTurnUnit ( FilterAllUnits ( [ f_side , 2 ] ) diff Heike , Heike ) ;
10333: LD_INT 22
10335: PUSH
10336: LD_INT 2
10338: PUSH
10339: EMPTY
10340: LIST
10341: LIST
10342: PPUSH
10343: CALL_OW 69
10347: PUSH
10348: LD_EXP 24
10352: DIFF
10353: PPUSH
10354: LD_EXP 24
10358: PPUSH
10359: CALL_OW 119
// Say ( Heike , DH-1-explore ) ;
10363: LD_EXP 24
10367: PPUSH
10368: LD_STRING DH-1-explore
10370: PPUSH
10371: CALL_OW 88
// if Givi then
10375: LD_EXP 25
10379: IFFALSE 10395
// Say ( Givi , DG-1-explore ) else
10381: LD_EXP 25
10385: PPUSH
10386: LD_STRING DG-1-explore
10388: PPUSH
10389: CALL_OW 88
10393: GO 10432
// if heikeSecondSquad then
10395: LD_EXP 38
10399: IFFALSE 10432
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10401: LD_EXP 38
10405: PPUSH
10406: LD_INT 26
10408: PUSH
10409: LD_INT 1
10411: PUSH
10412: EMPTY
10413: LIST
10414: LIST
10415: PPUSH
10416: CALL_OW 72
10420: PUSH
10421: LD_INT 1
10423: ARRAY
10424: PPUSH
10425: LD_STRING DArm-1-explore
10427: PPUSH
10428: CALL_OW 88
// Say ( Aviradze , DA-1-explore ) ;
10432: LD_EXP 28
10436: PPUSH
10437: LD_STRING DA-1-explore
10439: PPUSH
10440: CALL_OW 88
// if Sophia then
10444: LD_EXP 30
10448: IFFALSE 10526
// begin Say ( Sophia , DS-2-explore ) ;
10450: LD_EXP 30
10454: PPUSH
10455: LD_STRING DS-2-explore
10457: PPUSH
10458: CALL_OW 88
// Say ( Aviradze , DA-2-explore ) ;
10462: LD_EXP 28
10466: PPUSH
10467: LD_STRING DA-2-explore
10469: PPUSH
10470: CALL_OW 88
// ComTurnUnit ( Sophia , Aviradze ) ;
10474: LD_EXP 30
10478: PPUSH
10479: LD_EXP 28
10483: PPUSH
10484: CALL_OW 119
// ComTurnUnit ( Aviradze , Sophia ) ;
10488: LD_EXP 28
10492: PPUSH
10493: LD_EXP 30
10497: PPUSH
10498: CALL_OW 119
// Say ( Sophia , DS-3-explore ) ;
10502: LD_EXP 30
10506: PPUSH
10507: LD_STRING DS-3-explore
10509: PPUSH
10510: CALL_OW 88
// Say ( Aviradze , DA-3-explore ) ;
10514: LD_EXP 28
10518: PPUSH
10519: LD_STRING DA-3-explore
10521: PPUSH
10522: CALL_OW 88
// end ; if Mike then
10526: LD_EXP 26
10530: IFFALSE 10586
// begin Say ( Mike , DM-1-explore ) ;
10532: LD_EXP 26
10536: PPUSH
10537: LD_STRING DM-1-explore
10539: PPUSH
10540: CALL_OW 88
// Say ( Heike , DH-2-explore ) ;
10544: LD_EXP 24
10548: PPUSH
10549: LD_STRING DH-2-explore
10551: PPUSH
10552: CALL_OW 88
// Say ( Mike , DM-2-explore ) ;
10556: LD_EXP 26
10560: PPUSH
10561: LD_STRING DM-2-explore
10563: PPUSH
10564: CALL_OW 88
// if Kaia then
10568: LD_EXP 29
10572: IFFALSE 10586
// Say ( Kaia , DK-1-explore ) ;
10574: LD_EXP 29
10578: PPUSH
10579: LD_STRING DK-1-explore
10581: PPUSH
10582: CALL_OW 88
// end ; ComFree ( FilterAllUnits ( [ f_side , 2 ] ) ) ;
10586: LD_INT 22
10588: PUSH
10589: LD_INT 2
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: PPUSH
10596: CALL_OW 69
10600: PPUSH
10601: CALL_OW 139
// Video ( false ) ;
10605: LD_INT 0
10607: PPUSH
10608: CALL 991 0 1
// ChangeMissionObjectives ( BuildBase ) ;
10612: LD_STRING BuildBase
10614: PPUSH
10615: CALL_OW 337
// SaveForQuickRestart ;
10619: CALL_OW 22
// end ;
10623: LD_VAR 0 1
10627: RET
// every 0 0$1 trigger not americanBaseSpoted and not americanBaseCaptured and FilterUnitsInArea ( hillArea , [ f_side , 2 ] ) and not americanBaseCaptured do
10628: LD_EXP 5
10632: NOT
10633: PUSH
10634: LD_EXP 6
10638: NOT
10639: AND
10640: PUSH
10641: LD_INT 5
10643: PPUSH
10644: LD_INT 22
10646: PUSH
10647: LD_INT 2
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: PPUSH
10654: CALL_OW 70
10658: AND
10659: PUSH
10660: LD_EXP 6
10664: NOT
10665: AND
10666: IFFALSE 10751
10668: GO 10670
10670: DISABLE
// begin if Mike then
10671: LD_EXP 26
10675: IFFALSE 10691
// Say ( Mike , DM-1-scout ) else
10677: LD_EXP 26
10681: PPUSH
10682: LD_STRING DM-1-scout
10684: PPUSH
10685: CALL_OW 88
10689: GO 10722
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-1-explore ) ;
10691: LD_EXP 38
10695: PPUSH
10696: LD_INT 26
10698: PUSH
10699: LD_INT 1
10701: PUSH
10702: EMPTY
10703: LIST
10704: LIST
10705: PPUSH
10706: CALL_OW 72
10710: PUSH
10711: LD_INT 1
10713: ARRAY
10714: PPUSH
10715: LD_STRING DArm-1-explore
10717: PPUSH
10718: CALL_OW 88
// PlaceSeeing ( 54 , 35 , 2 , 1 ) ;
10722: LD_INT 54
10724: PPUSH
10725: LD_INT 35
10727: PPUSH
10728: LD_INT 2
10730: PPUSH
10731: LD_INT 1
10733: PPUSH
10734: CALL_OW 330
// RemoveSeeing ( 54 , 35 , 2 ) ;
10738: LD_INT 54
10740: PPUSH
10741: LD_INT 35
10743: PPUSH
10744: LD_INT 2
10746: PPUSH
10747: CALL_OW 331
// end ;
10751: END
// every 0 0$1 trigger FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) and not americanBaseCaptured do var randomMen , randomWomen , speakerOk ;
10752: LD_INT 6
10754: PPUSH
10755: LD_INT 22
10757: PUSH
10758: LD_INT 2
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 70
10769: PUSH
10770: LD_EXP 6
10774: NOT
10775: AND
10776: IFFALSE 11030
10778: GO 10780
10780: DISABLE
10781: LD_INT 0
10783: PPUSH
10784: PPUSH
10785: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
10786: LD_ADDR_VAR 0 1
10790: PUSH
10791: LD_EXP 38
10795: PPUSH
10796: LD_INT 26
10798: PUSH
10799: LD_INT 1
10801: PUSH
10802: EMPTY
10803: LIST
10804: LIST
10805: PPUSH
10806: CALL_OW 72
10810: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
10811: LD_ADDR_VAR 0 2
10815: PUSH
10816: LD_EXP 38
10820: PPUSH
10821: LD_INT 26
10823: PUSH
10824: LD_INT 2
10826: PUSH
10827: EMPTY
10828: LIST
10829: LIST
10830: PPUSH
10831: CALL_OW 72
10835: ST_TO_ADDR
// DialogueOn ;
10836: CALL_OW 6
// PlaceSeeing ( 36 , 22 , 2 , 8 ) ;
10840: LD_INT 36
10842: PPUSH
10843: LD_INT 22
10845: PPUSH
10846: LD_INT 2
10848: PPUSH
10849: LD_INT 8
10851: PPUSH
10852: CALL_OW 330
// dwait ( 0 0$1 ) ;
10856: LD_INT 35
10858: PPUSH
10859: CALL_OW 68
// speakerOk := false ;
10863: LD_ADDR_VAR 0 3
10867: PUSH
10868: LD_INT 0
10870: ST_TO_ADDR
// if Mike then
10871: LD_EXP 26
10875: IFFALSE 10897
// speakerOk := Say ( Mike , DM-1-spot ) else
10877: LD_ADDR_VAR 0 3
10881: PUSH
10882: LD_EXP 26
10886: PPUSH
10887: LD_STRING DM-1-spot
10889: PPUSH
10890: CALL_OW 88
10894: ST_TO_ADDR
10895: GO 10925
// if randomMen then
10897: LD_VAR 0 1
10901: IFFALSE 10925
// speakerOk := Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
10903: LD_ADDR_VAR 0 3
10907: PUSH
10908: LD_VAR 0 1
10912: PUSH
10913: LD_INT 1
10915: ARRAY
10916: PPUSH
10917: LD_STRING DArm-1-spot-a
10919: PPUSH
10920: CALL_OW 88
10924: ST_TO_ADDR
// if speakerOk then
10925: LD_VAR 0 3
10929: IFFALSE 10973
// begin if Givi then
10931: LD_EXP 25
10935: IFFALSE 10951
// Say ( Givi , DG-1-spot ) else
10937: LD_EXP 25
10941: PPUSH
10942: LD_STRING DG-1-spot
10944: PPUSH
10945: CALL_OW 88
10949: GO 10973
// if randomWomen then
10951: LD_VAR 0 2
10955: IFFALSE 10973
// Say ( randomWomen [ 1 ] , DArf-1-spot-a ) ;
10957: LD_VAR 0 2
10961: PUSH
10962: LD_INT 1
10964: ARRAY
10965: PPUSH
10966: LD_STRING DArf-1-spot-a
10968: PPUSH
10969: CALL_OW 88
// end ; if Mike then
10973: LD_EXP 26
10977: IFFALSE 10993
// Say ( Heike , DH-1-spot ) else
10979: LD_EXP 24
10983: PPUSH
10984: LD_STRING DH-1-spot
10986: PPUSH
10987: CALL_OW 88
10991: GO 11005
// Say ( Heike , DH-1-spot-a ) ;
10993: LD_EXP 24
10997: PPUSH
10998: LD_STRING DH-1-spot-a
11000: PPUSH
11001: CALL_OW 88
// RemoveSeeing ( 36 , 22 , 2 ) ;
11005: LD_INT 36
11007: PPUSH
11008: LD_INT 22
11010: PPUSH
11011: LD_INT 2
11013: PPUSH
11014: CALL_OW 331
// DialogueOff ;
11018: CALL_OW 7
// americanBaseSpoted := true ;
11022: LD_ADDR_EXP 5
11026: PUSH
11027: LD_INT 1
11029: ST_TO_ADDR
// end ;
11030: PPOPN 3
11032: END
// every 0 0$1 trigger not americanBaseSpoted and FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 1 ] ] ) and not americanBaseCaptured do var randomMen ;
11033: LD_EXP 5
11037: NOT
11038: PUSH
11039: LD_INT 22
11041: PUSH
11042: LD_INT 2
11044: PUSH
11045: EMPTY
11046: LIST
11047: LIST
11048: PUSH
11049: LD_INT 101
11051: PUSH
11052: LD_INT 1
11054: PUSH
11055: EMPTY
11056: LIST
11057: LIST
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PPUSH
11063: CALL_OW 69
11067: AND
11068: PUSH
11069: LD_EXP 6
11073: NOT
11074: AND
11075: IFFALSE 11161
11077: GO 11079
11079: DISABLE
11080: LD_INT 0
11082: PPUSH
// begin americanBaseSpoted := true ;
11083: LD_ADDR_EXP 5
11087: PUSH
11088: LD_INT 1
11090: ST_TO_ADDR
// randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
11091: LD_ADDR_VAR 0 1
11095: PUSH
11096: LD_EXP 38
11100: PPUSH
11101: LD_INT 26
11103: PUSH
11104: LD_INT 1
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PPUSH
11111: CALL_OW 72
11115: ST_TO_ADDR
// if not randomMen then
11116: LD_VAR 0 1
11120: NOT
11121: IFFALSE 11125
// exit ;
11123: GO 11161
// DialogueOn ;
11125: CALL_OW 6
// Say ( randomMen [ 1 ] , DArm-1-spot-a ) ;
11129: LD_VAR 0 1
11133: PUSH
11134: LD_INT 1
11136: ARRAY
11137: PPUSH
11138: LD_STRING DArm-1-spot-a
11140: PPUSH
11141: CALL_OW 88
// Say ( Heike , DH-1-spot-a ) ;
11145: LD_EXP 24
11149: PPUSH
11150: LD_STRING DH-1-spot-a
11152: PPUSH
11153: CALL_OW 88
// DialogueOff ;
11157: CALL_OW 7
// end ;
11161: PPOPN 1
11163: END
// every 0 0$1 trigger GetSide ( usDepot ) = 2 or FilterUnitsInArea ( americanBaseArea , [ [ f_side , 1 ] , [ f_not , [ f_ok ] ] , [ f_btype , b_breastwork ] ] ) or FilterUnitsInArea ( americanBaseArea , [ f_side , 2 ] ) > 1 or FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) do var i , p ;
11164: LD_INT 11
11166: PPUSH
11167: CALL_OW 255
11171: PUSH
11172: LD_INT 2
11174: EQUAL
11175: PUSH
11176: LD_INT 7
11178: PPUSH
11179: LD_INT 22
11181: PUSH
11182: LD_INT 1
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: PUSH
11189: LD_INT 3
11191: PUSH
11192: LD_INT 50
11194: PUSH
11195: EMPTY
11196: LIST
11197: PUSH
11198: EMPTY
11199: LIST
11200: LIST
11201: PUSH
11202: LD_INT 30
11204: PUSH
11205: LD_INT 31
11207: PUSH
11208: EMPTY
11209: LIST
11210: LIST
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: LIST
11216: PPUSH
11217: CALL_OW 70
11221: OR
11222: PUSH
11223: LD_INT 7
11225: PPUSH
11226: LD_INT 22
11228: PUSH
11229: LD_INT 2
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: PPUSH
11236: CALL_OW 70
11240: PUSH
11241: LD_INT 1
11243: GREATER
11244: OR
11245: PUSH
11246: LD_INT 6
11248: PPUSH
11249: LD_INT 22
11251: PUSH
11252: LD_INT 2
11254: PUSH
11255: EMPTY
11256: LIST
11257: LIST
11258: PPUSH
11259: CALL_OW 70
11263: OR
11264: IFFALSE 11800
11266: GO 11268
11268: DISABLE
11269: LD_INT 0
11271: PPUSH
11272: PPUSH
// begin americanBaseCaptured := true ;
11273: LD_ADDR_EXP 6
11277: PUSH
11278: LD_INT 1
11280: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11281: LD_INT 105
11283: PPUSH
11284: CALL_OW 67
// if IsOk ( usCommander ) then
11288: LD_EXP 41
11292: PPUSH
11293: CALL_OW 302
11297: IFFALSE 11360
// begin usForces := usForces union usCommander ;
11299: LD_ADDR_EXP 40
11303: PUSH
11304: LD_EXP 40
11308: PUSH
11309: LD_EXP 41
11313: UNION
11314: ST_TO_ADDR
// if FilterUnitsInArea ( upHillArea , [ f_side , 2 ] ) then
11315: LD_INT 6
11317: PPUSH
11318: LD_INT 22
11320: PUSH
11321: LD_INT 2
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: PPUSH
11328: CALL_OW 70
11332: IFFALSE 11348
// Say ( usCommander , DUsm-2-assault ) else
11334: LD_EXP 41
11338: PPUSH
11339: LD_STRING DUsm-2-assault
11341: PPUSH
11342: CALL_OW 88
11346: GO 11360
// Say ( usCommander , DUsm-1-assault ) ;
11348: LD_EXP 41
11352: PPUSH
11353: LD_STRING DUsm-1-assault
11355: PPUSH
11356: CALL_OW 88
// end ; for i in usForces do
11360: LD_ADDR_VAR 0 1
11364: PUSH
11365: LD_EXP 40
11369: PUSH
11370: FOR_IN
11371: IFFALSE 11410
// begin if IsInUnit ( i ) then
11373: LD_VAR 0 1
11377: PPUSH
11378: CALL_OW 310
11382: IFFALSE 11393
// ComExitBuilding ( i ) ;
11384: LD_VAR 0 1
11388: PPUSH
11389: CALL_OW 122
// AddComMoveXY ( i , 34 , 67 ) ;
11393: LD_VAR 0 1
11397: PPUSH
11398: LD_INT 34
11400: PPUSH
11401: LD_INT 67
11403: PPUSH
11404: CALL_OW 171
// end ;
11408: GO 11370
11410: POP
11411: POP
// Say ( Heike , DH-1-assault ) ;
11412: LD_EXP 24
11416: PPUSH
11417: LD_STRING DH-1-assault
11419: PPUSH
11420: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11424: LD_INT 35
11426: PPUSH
11427: CALL_OW 67
// ComMoveXY ( i , 34 , 67 ) ;
11431: LD_VAR 0 1
11435: PPUSH
11436: LD_INT 34
11438: PPUSH
11439: LD_INT 67
11441: PPUSH
11442: CALL_OW 111
// until not usForces ;
11446: LD_EXP 40
11450: NOT
11451: IFFALSE 11424
// music_nat := 2 ;
11453: LD_ADDR_OWVAR 71
11457: PUSH
11458: LD_INT 2
11460: ST_TO_ADDR
// music_class := music_victory ;
11461: LD_ADDR_OWVAR 72
11465: PUSH
11466: LD_INT 4
11468: ST_TO_ADDR
// if not americanHasEscaped then
11469: LD_EXP 7
11473: NOT
11474: IFFALSE 11488
// Say ( Heike , DH-2-assault ) ;
11476: LD_EXP 24
11480: PPUSH
11481: LD_STRING DH-2-assault
11483: PPUSH
11484: CALL_OW 88
// wait ( 0 0$2 ) ;
11488: LD_INT 70
11490: PPUSH
11491: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11495: LD_INT 35
11497: PPUSH
11498: CALL_OW 67
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_not , [ f_ok ] ] ] ) ;
11502: LD_INT 22
11504: PUSH
11505: LD_INT 2
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PUSH
11512: LD_INT 21
11514: PUSH
11515: LD_INT 1
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: PUSH
11522: LD_INT 3
11524: PUSH
11525: LD_INT 50
11527: PUSH
11528: EMPTY
11529: LIST
11530: PUSH
11531: EMPTY
11532: LIST
11533: LIST
11534: PUSH
11535: EMPTY
11536: LIST
11537: LIST
11538: LIST
11539: PPUSH
11540: CALL_OW 69
11544: NOT
11545: IFFALSE 11495
// Video ( true ) ;
11547: LD_INT 1
11549: PPUSH
11550: CALL 991 0 1
// if not GetSide ( usDepot ) = 2 then
11554: LD_INT 11
11556: PPUSH
11557: CALL_OW 255
11561: PUSH
11562: LD_INT 2
11564: EQUAL
11565: NOT
11566: IFFALSE 11578
// SetSide ( usDepot , 2 ) ;
11568: LD_INT 11
11570: PPUSH
11571: LD_INT 2
11573: PPUSH
11574: CALL_OW 235
// CenterOnXY ( 35 , 22 ) ;
11578: LD_INT 35
11580: PPUSH
11581: LD_INT 22
11583: PPUSH
11584: CALL_OW 84
// ComMoveXY ( Heike , 35 , 22 ) ;
11588: LD_EXP 24
11592: PPUSH
11593: LD_INT 35
11595: PPUSH
11596: LD_INT 22
11598: PPUSH
11599: CALL_OW 111
// AddComTurnXY ( Heike , 38 , 25 ) ;
11603: LD_EXP 24
11607: PPUSH
11608: LD_INT 38
11610: PPUSH
11611: LD_INT 25
11613: PPUSH
11614: CALL_OW 178
// ComMoveXY ( heikeSquad union heikeSecondSquad , 39 , 26 ) ;
11618: LD_EXP 37
11622: PUSH
11623: LD_EXP 38
11627: UNION
11628: PPUSH
11629: LD_INT 39
11631: PPUSH
11632: LD_INT 26
11634: PPUSH
11635: CALL_OW 111
// AddComTurnUnit ( heikeSquad union heikeSecondSquad , Heike ) ;
11639: LD_EXP 37
11643: PUSH
11644: LD_EXP 38
11648: UNION
11649: PPUSH
11650: LD_EXP 24
11654: PPUSH
11655: CALL_OW 179
// p := 0 ;
11659: LD_ADDR_VAR 0 2
11663: PUSH
11664: LD_INT 0
11666: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11667: LD_INT 35
11669: PPUSH
11670: CALL_OW 67
// p := p + 1 ;
11674: LD_ADDR_VAR 0 2
11678: PUSH
11679: LD_VAR 0 2
11683: PUSH
11684: LD_INT 1
11686: PLUS
11687: ST_TO_ADDR
// until not HasTask ( Heike ) or p > 10 ;
11688: LD_EXP 24
11692: PPUSH
11693: CALL_OW 314
11697: NOT
11698: PUSH
11699: LD_VAR 0 2
11703: PUSH
11704: LD_INT 10
11706: GREATER
11707: OR
11708: IFFALSE 11667
// Say ( Heike , DH-1-capture ) ;
11710: LD_EXP 24
11714: PPUSH
11715: LD_STRING DH-1-capture
11717: PPUSH
11718: CALL_OW 88
// if Markov then
11722: LD_EXP 31
11726: IFFALSE 11740
// Say ( Markov , DMar-1-capture ) ;
11728: LD_EXP 31
11732: PPUSH
11733: LD_STRING DMar-1-capture
11735: PPUSH
11736: CALL_OW 88
// if Sophia then
11740: LD_EXP 30
11744: IFFALSE 11770
// begin Say ( Heike , DH-2-capture ) ;
11746: LD_EXP 24
11750: PPUSH
11751: LD_STRING DH-2-capture
11753: PPUSH
11754: CALL_OW 88
// Say ( Sophia , DS-1-capture ) ;
11758: LD_EXP 30
11762: PPUSH
11763: LD_STRING DS-1-capture
11765: PPUSH
11766: CALL_OW 88
// end ; Video ( false ) ;
11770: LD_INT 0
11772: PPUSH
11773: CALL 991 0 1
// music_nat := music_auto ;
11777: LD_ADDR_OWVAR 71
11781: PUSH
11782: LD_INT 0
11784: ST_TO_ADDR
// music_class := music_auto ;
11785: LD_ADDR_OWVAR 72
11789: PUSH
11790: LD_INT 0
11792: ST_TO_ADDR
// ChangeMissionObjectives ( ConstructBase ) ;
11793: LD_STRING ConstructBase
11795: PPUSH
11796: CALL_OW 337
// end ;
11800: PPOPN 2
11802: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_workshop ] , [ f_not , [ f_constructed ] ] ] ) do
11803: LD_INT 22
11805: PUSH
11806: LD_INT 2
11808: PUSH
11809: EMPTY
11810: LIST
11811: LIST
11812: PUSH
11813: LD_INT 30
11815: PUSH
11816: LD_INT 2
11818: PUSH
11819: EMPTY
11820: LIST
11821: LIST
11822: PUSH
11823: LD_INT 3
11825: PUSH
11826: LD_INT 57
11828: PUSH
11829: EMPTY
11830: LIST
11831: PUSH
11832: EMPTY
11833: LIST
11834: LIST
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: LIST
11840: PPUSH
11841: CALL_OW 69
11845: IFFALSE 12088
11847: GO 11849
11849: DISABLE
// begin workshopBuilded := true ;
11850: LD_ADDR_EXP 9
11854: PUSH
11855: LD_INT 1
11857: ST_TO_ADDR
// if IsOk ( Markov ) then
11858: LD_EXP 31
11862: PPUSH
11863: CALL_OW 302
11867: IFFALSE 11926
// begin Say ( Heike , DH-1-shop-a ) ;
11869: LD_EXP 24
11873: PPUSH
11874: LD_STRING DH-1-shop-a
11876: PPUSH
11877: CALL_OW 88
// if not ( GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ) then
11881: LD_INT 47
11883: PPUSH
11884: LD_INT 2
11886: PPUSH
11887: CALL_OW 321
11891: PUSH
11892: LD_INT 2
11894: EQUAL
11895: PUSH
11896: LD_INT 45
11898: PPUSH
11899: LD_INT 2
11901: PPUSH
11902: CALL_OW 321
11906: PUSH
11907: LD_INT 2
11909: EQUAL
11910: AND
11911: NOT
11912: IFFALSE 11926
// Say ( Markov , DMar-1-shop-a ) ;
11914: LD_EXP 31
11918: PPUSH
11919: LD_STRING DMar-1-shop-a
11921: PPUSH
11922: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
11926: LD_INT 35
11928: PPUSH
11929: CALL_OW 67
// until GetTech ( tech_OilEng , 2 ) = state_researched and GetTech ( tech_SolEng , 2 ) = state_researched ;
11933: LD_INT 47
11935: PPUSH
11936: LD_INT 2
11938: PPUSH
11939: CALL_OW 321
11943: PUSH
11944: LD_INT 2
11946: EQUAL
11947: PUSH
11948: LD_INT 45
11950: PPUSH
11951: LD_INT 2
11953: PPUSH
11954: CALL_OW 321
11958: PUSH
11959: LD_INT 2
11961: EQUAL
11962: AND
11963: IFFALSE 11926
// DialogueOn ;
11965: CALL_OW 6
// Say ( Markov , DMar-1-shop ) ;
11969: LD_EXP 31
11973: PPUSH
11974: LD_STRING DMar-1-shop
11976: PPUSH
11977: CALL_OW 88
// Say ( Heike , DH-1-shop ) ;
11981: LD_EXP 24
11985: PPUSH
11986: LD_STRING DH-1-shop
11988: PPUSH
11989: CALL_OW 88
// Say ( Markov , DMar-2-shop ) ;
11993: LD_EXP 31
11997: PPUSH
11998: LD_STRING DMar-2-shop
12000: PPUSH
12001: CALL_OW 88
// Say ( Markov , DMar-3-shop ) ;
12005: LD_EXP 31
12009: PPUSH
12010: LD_STRING DMar-3-shop
12012: PPUSH
12013: CALL_OW 88
// Say ( Heike , DH-2-shop ) ;
12017: LD_EXP 24
12021: PPUSH
12022: LD_STRING DH-2-shop
12024: PPUSH
12025: CALL_OW 88
// Say ( Markov , DMar-4-shop ) ;
12029: LD_EXP 31
12033: PPUSH
12034: LD_STRING DMar-4-shop
12036: PPUSH
12037: CALL_OW 88
// Say ( Heike , DH-3-shop ) ;
12041: LD_EXP 24
12045: PPUSH
12046: LD_STRING DH-3-shop
12048: PPUSH
12049: CALL_OW 88
// Say ( Markov , DMar-5-shop ) ;
12053: LD_EXP 31
12057: PPUSH
12058: LD_STRING DMar-5-shop
12060: PPUSH
12061: CALL_OW 88
// Say ( Heike , DH-4-shop ) ;
12065: LD_EXP 24
12069: PPUSH
12070: LD_STRING DH-4-shop
12072: PPUSH
12073: CALL_OW 88
// DialogueOff ;
12077: CALL_OW 7
// ChangeMissionObjectives ( ConstructVeh ) ;
12081: LD_STRING ConstructVeh
12083: PPUSH
12084: CALL_OW 337
// end ;
12088: END
// every 0 0$1 trigger GetTechNation ( 2 , 2 , state_enabled ) = 0 do
12089: LD_INT 2
12091: PPUSH
12092: LD_INT 2
12094: PPUSH
12095: LD_INT 1
12097: PPUSH
12098: CALL 1162 0 3
12102: PUSH
12103: LD_INT 0
12105: EQUAL
12106: IFFALSE 12118
12108: GO 12110
12110: DISABLE
// ChangeMissionObjectives ( Techs ) ;
12111: LD_STRING Techs
12113: PPUSH
12114: CALL_OW 337
12118: END
// every 0 0$3 trigger IsOk ( Markov ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) do
12119: LD_EXP 31
12123: PPUSH
12124: CALL_OW 302
12128: PUSH
12129: LD_INT 22
12131: PUSH
12132: LD_INT 2
12134: PUSH
12135: EMPTY
12136: LIST
12137: LIST
12138: PUSH
12139: LD_INT 2
12141: PUSH
12142: LD_INT 34
12144: PUSH
12145: LD_INT 22
12147: PUSH
12148: EMPTY
12149: LIST
12150: LIST
12151: PUSH
12152: LD_INT 35
12154: PUSH
12155: LD_INT 22
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: LIST
12166: PUSH
12167: EMPTY
12168: LIST
12169: LIST
12170: PPUSH
12171: CALL_OW 69
12175: AND
12176: IFFALSE 12283
12178: GO 12180
12180: DISABLE
// begin DialogueOn ;
12181: CALL_OW 6
// CenterNowOnUnits ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_weapon , ar_multimissile_ballista ] , [ f_bweapon , ar_multimissile_ballista ] ] ] ) ) ;
12185: LD_INT 22
12187: PUSH
12188: LD_INT 2
12190: PUSH
12191: EMPTY
12192: LIST
12193: LIST
12194: PUSH
12195: LD_INT 2
12197: PUSH
12198: LD_INT 34
12200: PUSH
12201: LD_INT 22
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 35
12210: PUSH
12211: LD_INT 22
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: LIST
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PPUSH
12227: CALL_OW 69
12231: PPUSH
12232: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12236: LD_INT 10
12238: PPUSH
12239: CALL_OW 68
// Say ( Heike , DH-1-bal ) ;
12243: LD_EXP 24
12247: PPUSH
12248: LD_STRING DH-1-bal
12250: PPUSH
12251: CALL_OW 88
// Say ( Markov , DMar-1-bal ) ;
12255: LD_EXP 31
12259: PPUSH
12260: LD_STRING DMar-1-bal
12262: PPUSH
12263: CALL_OW 88
// Say ( Heike , DH-2-bal ) ;
12267: LD_EXP 24
12271: PPUSH
12272: LD_STRING DH-2-bal
12274: PPUSH
12275: CALL_OW 88
// DialogueOff ;
12279: CALL_OW 7
// end ;
12283: END
// every 0 0$1 trigger IsOk ( Aviradze ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_lab ] ] ) do
12284: LD_EXP 28
12288: PPUSH
12289: CALL_OW 302
12293: PUSH
12294: LD_INT 22
12296: PUSH
12297: LD_INT 2
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: PUSH
12304: LD_INT 30
12306: PUSH
12307: LD_INT 6
12309: PUSH
12310: EMPTY
12311: LIST
12312: LIST
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PPUSH
12318: CALL_OW 69
12322: AND
12323: IFFALSE 12384
12325: GO 12327
12327: DISABLE
// begin DialogueOn ;
12328: CALL_OW 6
// Say ( Aviradze , DA-1-lab ) ;
12332: LD_EXP 28
12336: PPUSH
12337: LD_STRING DA-1-lab
12339: PPUSH
12340: CALL_OW 88
// Say ( Heike , DH-1-lab ) ;
12344: LD_EXP 24
12348: PPUSH
12349: LD_STRING DH-1-lab
12351: PPUSH
12352: CALL_OW 88
// Say ( Aviradze , DA-2-lab ) ;
12356: LD_EXP 28
12360: PPUSH
12361: LD_STRING DA-2-lab
12363: PPUSH
12364: CALL_OW 88
// Say ( Heike , DH-2-lab ) ;
12368: LD_EXP 24
12372: PPUSH
12373: LD_STRING DH-2-lab
12375: PPUSH
12376: CALL_OW 88
// DialogueOff ;
12380: CALL_OW 7
// end ;
12384: END
// every 0 0$1 trigger IsOk ( Kaia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) do var ape ;
12385: LD_EXP 29
12389: PPUSH
12390: CALL_OW 302
12394: PUSH
12395: LD_INT 22
12397: PUSH
12398: LD_INT 2
12400: PUSH
12401: EMPTY
12402: LIST
12403: LIST
12404: PUSH
12405: LD_INT 25
12407: PUSH
12408: LD_INT 15
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: PPUSH
12419: CALL_OW 69
12423: AND
12424: IFFALSE 12604
12426: GO 12428
12428: DISABLE
12429: LD_INT 0
12431: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ;
12432: LD_ADDR_VAR 0 1
12436: PUSH
12437: LD_INT 22
12439: PUSH
12440: LD_INT 2
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PUSH
12447: LD_INT 25
12449: PUSH
12450: LD_INT 15
12452: PUSH
12453: EMPTY
12454: LIST
12455: LIST
12456: PUSH
12457: EMPTY
12458: LIST
12459: LIST
12460: PPUSH
12461: CALL_OW 69
12465: ST_TO_ADDR
// Video ( true ) ;
12466: LD_INT 1
12468: PPUSH
12469: CALL 991 0 1
// CenterNowOnUnits ( ape [ 1 ] ) ;
12473: LD_VAR 0 1
12477: PUSH
12478: LD_INT 1
12480: ARRAY
12481: PPUSH
12482: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12486: LD_VAR 0 1
12490: PUSH
12491: LD_INT 1
12493: ARRAY
12494: PPUSH
12495: CALL_OW 122
// AddComMoveXY ( ape [ 1 ] , 35 , 28 ) ;
12499: LD_VAR 0 1
12503: PUSH
12504: LD_INT 1
12506: ARRAY
12507: PPUSH
12508: LD_INT 35
12510: PPUSH
12511: LD_INT 28
12513: PPUSH
12514: CALL_OW 171
// AddComMoveXY ( ape [ 1 ] , 36 , 17 ) ;
12518: LD_VAR 0 1
12522: PUSH
12523: LD_INT 1
12525: ARRAY
12526: PPUSH
12527: LD_INT 36
12529: PPUSH
12530: LD_INT 17
12532: PPUSH
12533: CALL_OW 171
// Say ( Kaia , DK-1-apesol ) ;
12537: LD_EXP 29
12541: PPUSH
12542: LD_STRING DK-1-apesol
12544: PPUSH
12545: CALL_OW 88
// Say ( Aviradze , DA-1-apesol ) ;
12549: LD_EXP 28
12553: PPUSH
12554: LD_STRING DA-1-apesol
12556: PPUSH
12557: CALL_OW 88
// Say ( Kaia , DK-2-apesol ) ;
12561: LD_EXP 29
12565: PPUSH
12566: LD_STRING DK-2-apesol
12568: PPUSH
12569: CALL_OW 88
// Say ( Aviradze , DA-2-apesol ) ;
12573: LD_EXP 28
12577: PPUSH
12578: LD_STRING DA-2-apesol
12580: PPUSH
12581: CALL_OW 88
// Say ( Kaia , DK-3-apesol ) ;
12585: LD_EXP 29
12589: PPUSH
12590: LD_STRING DK-3-apesol
12592: PPUSH
12593: CALL_OW 88
// Video ( false ) ;
12597: LD_INT 0
12599: PPUSH
12600: CALL 991 0 1
// end ;
12604: PPOPN 1
12606: END
// every 0 0$1 trigger IsOk ( Sophia ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) do var ape ;
12607: LD_EXP 30
12611: PPUSH
12612: CALL_OW 302
12616: PUSH
12617: LD_INT 22
12619: PUSH
12620: LD_INT 2
12622: PUSH
12623: EMPTY
12624: LIST
12625: LIST
12626: PUSH
12627: LD_INT 25
12629: PUSH
12630: LD_INT 16
12632: PUSH
12633: EMPTY
12634: LIST
12635: LIST
12636: PUSH
12637: EMPTY
12638: LIST
12639: LIST
12640: PPUSH
12641: CALL_OW 69
12645: AND
12646: IFFALSE 12918
12648: GO 12650
12650: DISABLE
12651: LD_INT 0
12653: PPUSH
// begin ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_engineer ] ] ) ;
12654: LD_ADDR_VAR 0 1
12658: PUSH
12659: LD_INT 22
12661: PUSH
12662: LD_INT 2
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: PUSH
12669: LD_INT 25
12671: PUSH
12672: LD_INT 16
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: PUSH
12679: EMPTY
12680: LIST
12681: LIST
12682: PPUSH
12683: CALL_OW 69
12687: ST_TO_ADDR
// Video ( true ) ;
12688: LD_INT 1
12690: PPUSH
12691: CALL 991 0 1
// CreateCratesXY ( 5 , 35 , 22 , true ) ;
12695: LD_INT 5
12697: PPUSH
12698: LD_INT 35
12700: PPUSH
12701: LD_INT 22
12703: PPUSH
12704: LD_INT 1
12706: PPUSH
12707: CALL_OW 54
// ComTurnUnit ( Sophia , ape [ 1 ] ) ;
12711: LD_EXP 30
12715: PPUSH
12716: LD_VAR 0 1
12720: PUSH
12721: LD_INT 1
12723: ARRAY
12724: PPUSH
12725: CALL_OW 119
// CenterNowOnUnits ( ape [ 1 ] ) ;
12729: LD_VAR 0 1
12733: PUSH
12734: LD_INT 1
12736: ARRAY
12737: PPUSH
12738: CALL_OW 87
// ComExitBuilding ( ape [ 1 ] ) ;
12742: LD_VAR 0 1
12746: PUSH
12747: LD_INT 1
12749: ARRAY
12750: PPUSH
12751: CALL_OW 122
// wait ( 0 0$2 ) ;
12755: LD_INT 70
12757: PPUSH
12758: CALL_OW 67
// Say ( Sophia , DS-1-apeeng ) ;
12762: LD_EXP 30
12766: PPUSH
12767: LD_STRING DS-1-apeeng
12769: PPUSH
12770: CALL_OW 88
// if IsOk ( Kamil ) then
12774: LD_EXP 27
12778: PPUSH
12779: CALL_OW 302
12783: IFFALSE 12911
// begin Say ( Kamil , DKam-1-apeeng ) ;
12785: LD_EXP 27
12789: PPUSH
12790: LD_STRING DKam-1-apeeng
12792: PPUSH
12793: CALL_OW 88
// Say ( Sophia , DS-2-apeeng ) ;
12797: LD_EXP 30
12801: PPUSH
12802: LD_STRING DS-2-apeeng
12804: PPUSH
12805: CALL_OW 88
// Say ( Kamil , DKam-2-apeeng ) ;
12809: LD_EXP 27
12813: PPUSH
12814: LD_STRING DKam-2-apeeng
12816: PPUSH
12817: CALL_OW 88
// Say ( Sophia , DS-3-apeeng ) ;
12821: LD_EXP 30
12825: PPUSH
12826: LD_STRING DS-3-apeeng
12828: PPUSH
12829: CALL_OW 88
// if not IsOK ( Kaia ) then
12833: LD_EXP 29
12837: PPUSH
12838: CALL_OW 302
12842: NOT
12843: IFFALSE 12854
// begin Video ( false ) ;
12845: LD_INT 0
12847: PPUSH
12848: CALL 991 0 1
// exit ;
12852: GO 12918
// end ; Say ( Kaia , DK-1-apeeng ) ;
12854: LD_EXP 29
12858: PPUSH
12859: LD_STRING DK-1-apeeng
12861: PPUSH
12862: CALL_OW 88
// if not IsOk ( Givi ) then
12866: LD_EXP 25
12870: PPUSH
12871: CALL_OW 302
12875: NOT
12876: IFFALSE 12887
// begin Video ( false ) ;
12878: LD_INT 0
12880: PPUSH
12881: CALL 991 0 1
// exit ;
12885: GO 12918
// end ; Say ( Givi , DG-1-apeeng ) ;
12887: LD_EXP 25
12891: PPUSH
12892: LD_STRING DG-1-apeeng
12894: PPUSH
12895: CALL_OW 88
// Say ( Kaia , DK-2-apeeng ) ;
12899: LD_EXP 29
12903: PPUSH
12904: LD_STRING DK-2-apeeng
12906: PPUSH
12907: CALL_OW 88
// end ; Video ( false ) ;
12911: LD_INT 0
12913: PPUSH
12914: CALL 991 0 1
// end ;
12918: PPOPN 1
12920: END
// every 0 0$1 trigger farmerBaseReady do
12921: LD_EXP 4
12925: IFFALSE 13083
12927: GO 12929
12929: DISABLE
// begin DialogueOn ;
12930: CALL_OW 6
// CenterNowOnUnits ( Farmer ) ;
12934: LD_EXP 32
12938: PPUSH
12939: CALL_OW 87
// SayRadio ( Farmer , DF-1-distribution ) ;
12943: LD_EXP 32
12947: PPUSH
12948: LD_STRING DF-1-distribution
12950: PPUSH
12951: CALL_OW 94
// Say ( Heike , DH-2-distribution ) ;
12955: LD_EXP 24
12959: PPUSH
12960: LD_STRING DH-2-distribution
12962: PPUSH
12963: CALL_OW 88
// if IsOk ( Kaia ) then
12967: LD_EXP 29
12971: PPUSH
12972: CALL_OW 302
12976: IFFALSE 13037
// begin Say ( Kaia , DK-1-distribution ) ;
12978: LD_EXP 29
12982: PPUSH
12983: LD_STRING DK-1-distribution
12985: PPUSH
12986: CALL_OW 88
// Say ( Heike , DH-1-distribution ) ;
12990: LD_EXP 24
12994: PPUSH
12995: LD_STRING DH-1-distribution
12997: PPUSH
12998: CALL_OW 88
// if IsOk ( Givi ) then
13002: LD_EXP 25
13006: PPUSH
13007: CALL_OW 302
13011: IFFALSE 13037
// begin Say ( Givi , DG-1-distribution ) ;
13013: LD_EXP 25
13017: PPUSH
13018: LD_STRING DG-1-distribution
13020: PPUSH
13021: CALL_OW 88
// Say ( Heike , DH-3-distribution ) ;
13025: LD_EXP 24
13029: PPUSH
13030: LD_STRING DH-3-distribution
13032: PPUSH
13033: CALL_OW 88
// end ; end ; DialogueOff ;
13037: CALL_OW 7
// ChangeMissionObjectives ( Crates1 ) ;
13041: LD_STRING Crates1
13043: PPUSH
13044: CALL_OW 337
// farmerRequestedCrates := 300 ;
13048: LD_ADDR_EXP 13
13052: PUSH
13053: LD_INT 300
13055: ST_TO_ADDR
// Query ( FarmerCrates ) ;
13056: LD_STRING FarmerCrates
13058: PPUSH
13059: CALL_OW 97
// SetAreaMapShow ( collectFarmerArea , 1 ) ;
13063: LD_INT 10
13065: PPUSH
13066: LD_INT 1
13068: PPUSH
13069: CALL_OW 424
// CenterNowOnXY ( 108 , 61 ) ;
13073: LD_INT 108
13075: PPUSH
13076: LD_INT 61
13078: PPUSH
13079: CALL_OW 86
// end ;
13083: END
// every 0 0$1 trigger americanBaseCaptured and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ] ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_armoury ] ] ) do var eng ;
13084: LD_EXP 6
13088: PUSH
13089: LD_INT 22
13091: PUSH
13092: LD_INT 2
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: LD_INT 3
13101: PUSH
13102: LD_INT 57
13104: PUSH
13105: EMPTY
13106: LIST
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: PUSH
13112: LD_INT 2
13114: PUSH
13115: LD_INT 30
13117: PUSH
13118: LD_INT 6
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PUSH
13125: LD_INT 30
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: EMPTY
13136: LIST
13137: LIST
13138: LIST
13139: PUSH
13140: EMPTY
13141: LIST
13142: LIST
13143: LIST
13144: PPUSH
13145: CALL_OW 69
13149: AND
13150: PUSH
13151: LD_INT 22
13153: PUSH
13154: LD_INT 2
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: PUSH
13161: LD_INT 3
13163: PUSH
13164: LD_INT 57
13166: PUSH
13167: EMPTY
13168: LIST
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PUSH
13174: LD_INT 30
13176: PUSH
13177: LD_INT 4
13179: PUSH
13180: EMPTY
13181: LIST
13182: LIST
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: PPUSH
13189: CALL_OW 69
13193: AND
13194: IFFALSE 13358
13196: GO 13198
13198: DISABLE
13199: LD_INT 0
13201: PPUSH
// begin wait ( 0 0$10 ) ;
13202: LD_INT 350
13204: PPUSH
13205: CALL_OW 67
// eng := UnitFilter ( heikeSecondSquad , [ [ f_sex , sex_male ] , [ f_class , 2 ] ] ) ;
13209: LD_ADDR_VAR 0 1
13213: PUSH
13214: LD_EXP 38
13218: PPUSH
13219: LD_INT 26
13221: PUSH
13222: LD_INT 1
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: PUSH
13229: LD_INT 25
13231: PUSH
13232: LD_INT 2
13234: PUSH
13235: EMPTY
13236: LIST
13237: LIST
13238: PUSH
13239: EMPTY
13240: LIST
13241: LIST
13242: PPUSH
13243: CALL_OW 72
13247: ST_TO_ADDR
// Say ( Heike , DH-1-task ) ;
13248: LD_EXP 24
13252: PPUSH
13253: LD_STRING DH-1-task
13255: PPUSH
13256: CALL_OW 88
// if IsOk ( Sophia ) then
13260: LD_EXP 30
13264: PPUSH
13265: CALL_OW 302
13269: IFFALSE 13309
// begin Say ( Sophia , DS-1-task ) ;
13271: LD_EXP 30
13275: PPUSH
13276: LD_STRING DS-1-task
13278: PPUSH
13279: CALL_OW 88
// Say ( Sophia , DS-2-task ) ;
13283: LD_EXP 30
13287: PPUSH
13288: LD_STRING DS-2-task
13290: PPUSH
13291: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13295: LD_EXP 24
13299: PPUSH
13300: LD_STRING DH-2-task
13302: PPUSH
13303: CALL_OW 88
// end else
13307: GO 13343
// if eng then
13309: LD_VAR 0 1
13313: IFFALSE 13343
// begin Say ( eng [ 1 ] , DArm-1-task ) ;
13315: LD_VAR 0 1
13319: PUSH
13320: LD_INT 1
13322: ARRAY
13323: PPUSH
13324: LD_STRING DArm-1-task
13326: PPUSH
13327: CALL_OW 88
// Say ( Heike , DH-2-task ) ;
13331: LD_EXP 24
13335: PPUSH
13336: LD_STRING DH-2-task
13338: PPUSH
13339: CALL_OW 88
// end ; ChangeMissionObjectives ( BaseConstructed ) ;
13343: LD_STRING BaseConstructed
13345: PPUSH
13346: CALL_OW 337
// allowConvoys := true ;
13350: LD_ADDR_EXP 11
13354: PUSH
13355: LD_INT 1
13357: ST_TO_ADDR
// end ;
13358: PPOPN 1
13360: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) do var cargo , x , y ;
13361: LD_INT 22
13363: PUSH
13364: LD_INT 4
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: PUSH
13371: LD_INT 34
13373: PUSH
13374: LD_INT 12
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: EMPTY
13382: LIST
13383: LIST
13384: PPUSH
13385: CALL_OW 69
13389: IFFALSE 13557
13391: GO 13393
13393: DISABLE
13394: LD_INT 0
13396: PPUSH
13397: PPUSH
13398: PPUSH
// begin wait ( 0 0$2 ) ;
13399: LD_INT 70
13401: PPUSH
13402: CALL_OW 67
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) ;
13406: LD_ADDR_VAR 0 1
13410: PUSH
13411: LD_INT 22
13413: PUSH
13414: LD_INT 4
13416: PUSH
13417: EMPTY
13418: LIST
13419: LIST
13420: PUSH
13421: LD_INT 34
13423: PUSH
13424: LD_INT 12
13426: PUSH
13427: EMPTY
13428: LIST
13429: LIST
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: PPUSH
13435: CALL_OW 69
13439: ST_TO_ADDR
// x := GetX ( cargo [ 1 ] ) ;
13440: LD_ADDR_VAR 0 2
13444: PUSH
13445: LD_VAR 0 1
13449: PUSH
13450: LD_INT 1
13452: ARRAY
13453: PPUSH
13454: CALL_OW 250
13458: ST_TO_ADDR
// y := GetY ( cargo [ 1 ] ) ;
13459: LD_ADDR_VAR 0 3
13463: PUSH
13464: LD_VAR 0 1
13468: PUSH
13469: LD_INT 1
13471: ARRAY
13472: PPUSH
13473: CALL_OW 251
13477: ST_TO_ADDR
// DialogueOn ;
13478: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
13482: LD_VAR 0 2
13486: PPUSH
13487: LD_VAR 0 3
13491: PPUSH
13492: CALL_OW 86
// PlaceSeeing ( x , y , 2 , - 6 ) ;
13496: LD_VAR 0 2
13500: PPUSH
13501: LD_VAR 0 3
13505: PPUSH
13506: LD_INT 2
13508: PPUSH
13509: LD_INT 6
13511: NEG
13512: PPUSH
13513: CALL_OW 330
// dwait ( 0 0$0.3 ) ;
13517: LD_INT 10
13519: PPUSH
13520: CALL_OW 68
// Say ( Heike , DH-1-seecargo ) ;
13524: LD_EXP 24
13528: PPUSH
13529: LD_STRING DH-1-seecargo
13531: PPUSH
13532: CALL_OW 88
// RemoveSeeing ( x , y , 2 ) ;
13536: LD_VAR 0 2
13540: PPUSH
13541: LD_VAR 0 3
13545: PPUSH
13546: LD_INT 2
13548: PPUSH
13549: CALL_OW 331
// DialogueOff ;
13553: CALL_OW 7
// end ;
13557: PPOPN 3
13559: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 300 do
13560: LD_EXP 4
13564: PUSH
13565: LD_EXP 12
13569: PUSH
13570: LD_INT 300
13572: GREATEREQUAL
13573: AND
13574: IFFALSE 13646
13576: GO 13578
13578: DISABLE
// begin DialogueOn ;
13579: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-2 ) ;
13583: LD_EXP 32
13587: PPUSH
13588: LD_STRING DF-1-delivery-2
13590: PPUSH
13591: CALL_OW 94
// Say ( Heike , DH-1-delivery-2 ) ;
13595: LD_EXP 24
13599: PPUSH
13600: LD_STRING DH-1-delivery-2
13602: PPUSH
13603: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-2 ) ;
13607: LD_EXP 32
13611: PPUSH
13612: LD_STRING DF-2-delivery-2
13614: PPUSH
13615: CALL_OW 94
// DialogueOff ;
13619: CALL_OW 7
// ChangeMissionObjectives ( Crates2 ) ;
13623: LD_STRING Crates2
13625: PPUSH
13626: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13630: LD_ADDR_EXP 14
13634: PUSH
13635: LD_INT 63000
13637: ST_TO_ADDR
// farmerRequestedCrates := 600 ;
13638: LD_ADDR_EXP 13
13642: PUSH
13643: LD_INT 600
13645: ST_TO_ADDR
// end ;
13646: END
// every 0 0$1 trigger farmerBaseReady and farmerCrates >= 600 do
13647: LD_EXP 4
13651: PUSH
13652: LD_EXP 12
13656: PUSH
13657: LD_INT 600
13659: GREATEREQUAL
13660: AND
13661: IFFALSE 13827
13663: GO 13665
13665: DISABLE
// begin DialogueOn ;
13666: CALL_OW 6
// SayRadio ( Farmer , DF-1-delivery-3 ) ;
13670: LD_EXP 32
13674: PPUSH
13675: LD_STRING DF-1-delivery-3
13677: PPUSH
13678: CALL_OW 94
// Say ( Heike , DH-1-delivery-3 ) ;
13682: LD_EXP 24
13686: PPUSH
13687: LD_STRING DH-1-delivery-3
13689: PPUSH
13690: CALL_OW 88
// SayRadio ( Farmer , DF-2-delivery-3 ) ;
13694: LD_EXP 32
13698: PPUSH
13699: LD_STRING DF-2-delivery-3
13701: PPUSH
13702: CALL_OW 94
// if IsOk ( Kaia ) then
13706: LD_EXP 29
13710: PPUSH
13711: CALL_OW 302
13715: IFFALSE 13765
// begin Say ( Kaia , DK-1-delivery-3 ) ;
13717: LD_EXP 29
13721: PPUSH
13722: LD_STRING DK-1-delivery-3
13724: PPUSH
13725: CALL_OW 88
// Say ( Heike , DH-2-delivery-3 ) ;
13729: LD_EXP 24
13733: PPUSH
13734: LD_STRING DH-2-delivery-3
13736: PPUSH
13737: CALL_OW 88
// Say ( Givi , DG-1-delivery-3 ) ;
13741: LD_EXP 25
13745: PPUSH
13746: LD_STRING DG-1-delivery-3
13748: PPUSH
13749: CALL_OW 88
// Say ( Mike , DM-1-delivery-3 ) ;
13753: LD_EXP 26
13757: PPUSH
13758: LD_STRING DM-1-delivery-3
13760: PPUSH
13761: CALL_OW 88
// end ; DialogueOff ;
13765: CALL_OW 7
// if Difficulty = 2 then
13769: LD_OWVAR 67
13773: PUSH
13774: LD_INT 2
13776: EQUAL
13777: IFFALSE 13804
// begin ChangeMissionObjectives ( Crates3 ) ;
13779: LD_STRING Crates3
13781: PPUSH
13782: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13786: LD_ADDR_EXP 14
13790: PUSH
13791: LD_INT 63000
13793: ST_TO_ADDR
// farmerRequestedCrates := 900 ;
13794: LD_ADDR_EXP 13
13798: PUSH
13799: LD_INT 900
13801: ST_TO_ADDR
// end else
13802: GO 13827
// begin ChangeMissionObjectives ( Crates4 ) ;
13804: LD_STRING Crates4
13806: PPUSH
13807: CALL_OW 337
// farmerCratesCounter := 30 30$00 ;
13811: LD_ADDR_EXP 14
13815: PUSH
13816: LD_INT 63000
13818: ST_TO_ADDR
// farmerRequestedCrates := 1200 ;
13819: LD_ADDR_EXP 13
13823: PUSH
13824: LD_INT 1200
13826: ST_TO_ADDR
// end ; end ;
13827: END
// every 0 0$2 trigger farmerBaseReady and farmerCrates >= [ 600 , 900 , 1200 ] [ Difficulty ] and farmerRequestedCrates <= farmerCratesCounter do
13828: LD_EXP 4
13832: PUSH
13833: LD_EXP 12
13837: PUSH
13838: LD_INT 600
13840: PUSH
13841: LD_INT 900
13843: PUSH
13844: LD_INT 1200
13846: PUSH
13847: EMPTY
13848: LIST
13849: LIST
13850: LIST
13851: PUSH
13852: LD_OWVAR 67
13856: ARRAY
13857: GREATEREQUAL
13858: AND
13859: PUSH
13860: LD_EXP 13
13864: PUSH
13865: LD_EXP 14
13869: LESSEQUAL
13870: AND
13871: IFFALSE 13944
13873: GO 13875
13875: DISABLE
// begin retreatAllowed := true ;
13876: LD_ADDR_EXP 10
13880: PUSH
13881: LD_INT 1
13883: ST_TO_ADDR
// display_strings := [ ] ;
13884: LD_ADDR_OWVAR 47
13888: PUSH
13889: EMPTY
13890: ST_TO_ADDR
// DialogueOn ;
13891: CALL_OW 6
// Video ( true ) ;
13895: LD_INT 1
13897: PPUSH
13898: CALL 991 0 1
// SayRadio ( Omar , DO-radio-end ) ;
13902: LD_EXP 33
13906: PPUSH
13907: LD_STRING DO-radio-end
13909: PPUSH
13910: CALL_OW 94
// Say ( Heike , DH-1-radio-end ) ;
13914: LD_EXP 24
13918: PPUSH
13919: LD_STRING DH-1-radio-end
13921: PPUSH
13922: CALL_OW 88
// Video ( false ) ;
13926: LD_INT 0
13928: PPUSH
13929: CALL 991 0 1
// DialogueOff ;
13933: CALL_OW 7
// ChangeMissionObjectives ( Retreat ) ;
13937: LD_STRING Retreat
13939: PPUSH
13940: CALL_OW 337
// end ;
13944: END
// every 0 0$1 trigger retreatAllowed do
13945: LD_EXP 10
13949: IFFALSE 13968
13951: GO 13953
13953: DISABLE
// begin SetAreaMapShow ( collectFarmerArea , 0 ) ;
13954: LD_INT 10
13956: PPUSH
13957: LD_INT 0
13959: PPUSH
13960: CALL_OW 424
// StartCargoEvacuation ;
13964: CALL 4457 0 0
// end ;
13968: END
// every 0 0$1 trigger not retreatAllowed and IsDead ( arDepot ) do
13969: LD_EXP 10
13973: NOT
13974: PUSH
13975: LD_INT 5
13977: PPUSH
13978: CALL_OW 301
13982: AND
13983: IFFALSE 14007
13985: GO 13987
13987: DISABLE
// begin SayRadio ( Farmer , DF-1-failure ) ;
13988: LD_EXP 32
13992: PPUSH
13993: LD_STRING DF-1-failure
13995: PPUSH
13996: CALL_OW 94
// YouLost ( FarmerDepot ) ;
14000: LD_STRING FarmerDepot
14002: PPUSH
14003: CALL_OW 104
// end ;
14007: END
// every 0 0$1 trigger retreatAllowed and GetDistUnits ( Heike , Farmer ) < 6 do var i , max , tmp ;
14008: LD_EXP 10
14012: PUSH
14013: LD_EXP 24
14017: PPUSH
14018: LD_EXP 32
14022: PPUSH
14023: CALL_OW 296
14027: PUSH
14028: LD_INT 6
14030: LESS
14031: AND
14032: IFFALSE 14618
14034: GO 14036
14036: DISABLE
14037: LD_INT 0
14039: PPUSH
14040: PPUSH
14041: PPUSH
// begin allowConvoys := false ;
14042: LD_ADDR_EXP 11
14046: PUSH
14047: LD_INT 0
14049: ST_TO_ADDR
// Video ( true ) ;
14050: LD_INT 1
14052: PPUSH
14053: CALL 991 0 1
// ComTurnUnit ( Heike , Farmer ) ;
14057: LD_EXP 24
14061: PPUSH
14062: LD_EXP 32
14066: PPUSH
14067: CALL_OW 119
// ComTurnUnit ( Farmer , Heike ) ;
14071: LD_EXP 32
14075: PPUSH
14076: LD_EXP 24
14080: PPUSH
14081: CALL_OW 119
// CenterNowOnUnits ( Farmer ) ;
14085: LD_EXP 32
14089: PPUSH
14090: CALL_OW 87
// Say ( Heike , DH-1-end ) ;
14094: LD_EXP 24
14098: PPUSH
14099: LD_STRING DH-1-end
14101: PPUSH
14102: CALL_OW 88
// Say ( Farmer , DF-1-end ) ;
14106: LD_EXP 32
14110: PPUSH
14111: LD_STRING DF-1-end
14113: PPUSH
14114: CALL_OW 88
// Say ( Farmer , DF-2-end ) ;
14118: LD_EXP 32
14122: PPUSH
14123: LD_STRING DF-2-end
14125: PPUSH
14126: CALL_OW 88
// Say ( Heike , DH-2-end ) ;
14130: LD_EXP 24
14134: PPUSH
14135: LD_STRING DH-2-end
14137: PPUSH
14138: CALL_OW 88
// Say ( Farmer , DF-3-end ) ;
14142: LD_EXP 32
14146: PPUSH
14147: LD_STRING DF-3-end
14149: PPUSH
14150: CALL_OW 88
// Say ( Heike , DH-3-end ) ;
14154: LD_EXP 24
14158: PPUSH
14159: LD_STRING DH-3-end
14161: PPUSH
14162: CALL_OW 88
// Say ( Givi , DG-1-end ) ;
14166: LD_EXP 25
14170: PPUSH
14171: LD_STRING DG-1-end
14173: PPUSH
14174: CALL_OW 88
// Say ( Heike , DH-4-end ) ;
14178: LD_EXP 24
14182: PPUSH
14183: LD_STRING DH-4-end
14185: PPUSH
14186: CALL_OW 88
// Say ( Farmer , DF-4-end ) ;
14190: LD_EXP 32
14194: PPUSH
14195: LD_STRING DF-4-end
14197: PPUSH
14198: CALL_OW 88
// Say ( Heike , DH-5-end ) ;
14202: LD_EXP 24
14206: PPUSH
14207: LD_STRING DH-5-end
14209: PPUSH
14210: CALL_OW 88
// Say ( Farmer , DF-5-end ) ;
14214: LD_EXP 32
14218: PPUSH
14219: LD_STRING DF-5-end
14221: PPUSH
14222: CALL_OW 88
// Video ( false ) ;
14226: LD_INT 0
14228: PPUSH
14229: CALL 991 0 1
// max := [ 4 , 3 , 2 ] [ Difficulty ] ;
14233: LD_ADDR_VAR 0 2
14237: PUSH
14238: LD_INT 4
14240: PUSH
14241: LD_INT 3
14243: PUSH
14244: LD_INT 2
14246: PUSH
14247: EMPTY
14248: LIST
14249: LIST
14250: LIST
14251: PUSH
14252: LD_OWVAR 67
14256: ARRAY
14257: ST_TO_ADDR
// if farmerSquad < max then
14258: LD_EXP 35
14262: PUSH
14263: LD_VAR 0 2
14267: LESS
14268: IFFALSE 14280
// max := farmerSquad ;
14270: LD_ADDR_VAR 0 2
14274: PUSH
14275: LD_EXP 35
14279: ST_TO_ADDR
// for i := 1 to max do
14280: LD_ADDR_VAR 0 1
14284: PUSH
14285: DOUBLE
14286: LD_INT 1
14288: DEC
14289: ST_TO_ADDR
14290: LD_VAR 0 2
14294: PUSH
14295: FOR_TO
14296: IFFALSE 14334
// begin SetSide ( farmerSquad [ 1 ] , 2 ) ;
14298: LD_EXP 35
14302: PUSH
14303: LD_INT 1
14305: ARRAY
14306: PPUSH
14307: LD_INT 2
14309: PPUSH
14310: CALL_OW 235
// farmerSquad := Delete ( farmerSquad , 1 ) ;
14314: LD_ADDR_EXP 35
14318: PUSH
14319: LD_EXP 35
14323: PPUSH
14324: LD_INT 1
14326: PPUSH
14327: CALL_OW 3
14331: ST_TO_ADDR
// end ;
14332: GO 14295
14334: POP
14335: POP
// for i in Farmer ^ farmerSquad do
14336: LD_ADDR_VAR 0 1
14340: PUSH
14341: LD_EXP 32
14345: PUSH
14346: LD_EXP 35
14350: ADD
14351: PUSH
14352: FOR_IN
14353: IFFALSE 14392
// begin if IsInUnit ( i ) then
14355: LD_VAR 0 1
14359: PPUSH
14360: CALL_OW 310
14364: IFFALSE 14375
// ComExitBuilding ( i ) ;
14366: LD_VAR 0 1
14370: PPUSH
14371: CALL_OW 122
// AddComMoveXY ( i , 102 , 7 ) ;
14375: LD_VAR 0 1
14379: PPUSH
14380: LD_INT 102
14382: PPUSH
14383: LD_INT 7
14385: PPUSH
14386: CALL_OW 171
// end ;
14390: GO 14352
14392: POP
14393: POP
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_type , unit_building ] ] ) diff arDepot do
14394: LD_ADDR_VAR 0 1
14398: PUSH
14399: LD_INT 22
14401: PUSH
14402: LD_INT 5
14404: PUSH
14405: EMPTY
14406: LIST
14407: LIST
14408: PUSH
14409: LD_INT 21
14411: PUSH
14412: LD_INT 3
14414: PUSH
14415: EMPTY
14416: LIST
14417: LIST
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PPUSH
14423: CALL_OW 69
14427: PUSH
14428: LD_INT 5
14430: DIFF
14431: PUSH
14432: FOR_IN
14433: IFFALSE 14449
// SetSide ( i , 2 ) ;
14435: LD_VAR 0 1
14439: PPUSH
14440: LD_INT 2
14442: PPUSH
14443: CALL_OW 235
14447: GO 14432
14449: POP
14450: POP
// repeat wait ( 0 0$1 ) ;
14451: LD_INT 35
14453: PPUSH
14454: CALL_OW 67
// tmp := UnitFilter ( Farmer ^ farmerSquad , [ f_inarea , northRoad ] ) ;
14458: LD_ADDR_VAR 0 3
14462: PUSH
14463: LD_EXP 32
14467: PUSH
14468: LD_EXP 35
14472: ADD
14473: PPUSH
14474: LD_INT 95
14476: PUSH
14477: LD_INT 3
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: PPUSH
14484: CALL_OW 72
14488: ST_TO_ADDR
// if tmp then
14489: LD_VAR 0 3
14493: IFFALSE 14537
// for i in tmp do
14495: LD_ADDR_VAR 0 1
14499: PUSH
14500: LD_VAR 0 3
14504: PUSH
14505: FOR_IN
14506: IFFALSE 14535
// begin farmerSquad := farmerSquad diff i ;
14508: LD_ADDR_EXP 35
14512: PUSH
14513: LD_EXP 35
14517: PUSH
14518: LD_VAR 0 1
14522: DIFF
14523: ST_TO_ADDR
// RemoveUnit ( i ) ;
14524: LD_VAR 0 1
14528: PPUSH
14529: CALL_OW 64
// end ;
14533: GO 14505
14535: POP
14536: POP
// until farmerSquad = [ ] and not IsPlaced ( Farmer ) ;
14537: LD_EXP 35
14541: PUSH
14542: EMPTY
14543: EQUAL
14544: PUSH
14545: LD_EXP 32
14549: PPUSH
14550: CALL_OW 305
14554: NOT
14555: AND
14556: IFFALSE 14451
// wait ( 1 1$00 ) ;
14558: LD_INT 2100
14560: PPUSH
14561: CALL_OW 67
// SendAttack ;
14565: CALL 6841 0 0
// wait ( [ 5 5$00 , 4 4$30 , 4 4$00 ] [ Difficulty ] ) ;
14569: LD_INT 10500
14571: PUSH
14572: LD_INT 9450
14574: PUSH
14575: LD_INT 8400
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: LIST
14582: PUSH
14583: LD_OWVAR 67
14587: ARRAY
14588: PPUSH
14589: CALL_OW 67
// SendAttack ;
14593: CALL 6841 0 0
// if Difficulty > 2 then
14597: LD_OWVAR 67
14601: PUSH
14602: LD_INT 2
14604: GREATER
14605: IFFALSE 14618
// begin wait ( 4 4$00 ) ;
14607: LD_INT 8400
14609: PPUSH
14610: CALL_OW 67
// SendAttack ;
14614: CALL 6841 0 0
// end ; end ;
14618: PPOPN 3
14620: END
// every 0 0$2 trigger farmerCratesCounter <= 9 9$00 do
14621: LD_EXP 14
14625: PUSH
14626: LD_INT 18900
14628: LESSEQUAL
14629: IFFALSE 14678
14631: GO 14633
14633: DISABLE
// begin DialogueOn ;
14634: CALL_OW 6
// SayRadio ( Farmer , DF-1-distribution-a ) ;
14638: LD_EXP 32
14642: PPUSH
14643: LD_STRING DF-1-distribution-a
14645: PPUSH
14646: CALL_OW 94
// Say ( Heike , DH-1-distribution-a ) ;
14650: LD_EXP 24
14654: PPUSH
14655: LD_STRING DH-1-distribution-a
14657: PPUSH
14658: CALL_OW 88
// SayRadio ( Farmer , DF-2-distribution-a ) ;
14662: LD_EXP 32
14666: PPUSH
14667: LD_STRING DF-2-distribution-a
14669: PPUSH
14670: CALL_OW 94
// DialogueOff ;
14674: CALL_OW 7
// end ;
14678: END
// every 0 0$2 trigger farmerCratesCounter <= 0 0$00 do
14679: LD_EXP 14
14683: PUSH
14684: LD_INT 0
14686: LESSEQUAL
14687: IFFALSE 14719
14689: GO 14691
14691: DISABLE
// begin DialogueOn ;
14692: CALL_OW 6
// SayRadio ( Farmer , DF-3-distribution-a ) ;
14696: LD_EXP 32
14700: PPUSH
14701: LD_STRING DF-3-distribution-a
14703: PPUSH
14704: CALL_OW 94
// YouLost ( Distribution ) ;
14708: LD_STRING Distribution
14710: PPUSH
14711: CALL_OW 104
// DialogueOff ;
14715: CALL_OW 7
// end ;
14719: END
// every 0 0$1 trigger vehCounter >= 2 do
14720: LD_EXP 18
14724: PUSH
14725: LD_INT 2
14727: GREATEREQUAL
14728: IFFALSE 14740
14730: GO 14732
14732: DISABLE
// ChangeMissionObjectives ( VehConstructed ) ;
14733: LD_STRING VehConstructed
14735: PPUSH
14736: CALL_OW 337
14740: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , us_cargo_bay ] ] ) do
14741: LD_INT 22
14743: PUSH
14744: LD_INT 2
14746: PUSH
14747: EMPTY
14748: LIST
14749: LIST
14750: PUSH
14751: LD_INT 34
14753: PUSH
14754: LD_INT 12
14756: PUSH
14757: EMPTY
14758: LIST
14759: LIST
14760: PUSH
14761: EMPTY
14762: LIST
14763: LIST
14764: PPUSH
14765: CALL_OW 69
14769: IFFALSE 14829
14771: GO 14773
14773: DISABLE
// begin DialogueOn ;
14774: CALL_OW 6
// Say ( Heike , DH-1-truck ) ;
14778: LD_EXP 24
14782: PPUSH
14783: LD_STRING DH-1-truck
14785: PPUSH
14786: CALL_OW 88
// if IsOk ( Markov ) then
14790: LD_EXP 31
14794: PPUSH
14795: CALL_OW 302
14799: IFFALSE 14825
// begin Say ( Markov , DMar-1-truck ) ;
14801: LD_EXP 31
14805: PPUSH
14806: LD_STRING DMar-1-truck
14808: PPUSH
14809: CALL_OW 88
// Say ( Heike , DH-2-truck ) ;
14813: LD_EXP 24
14817: PPUSH
14818: LD_STRING DH-2-truck
14820: PPUSH
14821: CALL_OW 88
// end ; DialogueOff ;
14825: CALL_OW 7
// end ;
14829: END
// export function EmptyCargoDialog ; var randomMen , randomWomen ; begin
14830: LD_INT 0
14832: PPUSH
14833: PPUSH
14834: PPUSH
// if IsOk ( Givi ) then
14835: LD_EXP 25
14839: PPUSH
14840: CALL_OW 302
14844: IFFALSE 14860
// begin Say ( Givi , DG-1-nocargo ) ;
14846: LD_EXP 25
14850: PPUSH
14851: LD_STRING DG-1-nocargo
14853: PPUSH
14854: CALL_OW 88
// exit ;
14858: GO 14956
// end ; randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
14860: LD_ADDR_VAR 0 2
14864: PUSH
14865: LD_EXP 38
14869: PPUSH
14870: LD_INT 26
14872: PUSH
14873: LD_INT 1
14875: PUSH
14876: EMPTY
14877: LIST
14878: LIST
14879: PPUSH
14880: CALL_OW 72
14884: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
14885: LD_ADDR_VAR 0 3
14889: PUSH
14890: LD_EXP 38
14894: PPUSH
14895: LD_INT 26
14897: PUSH
14898: LD_INT 2
14900: PUSH
14901: EMPTY
14902: LIST
14903: LIST
14904: PPUSH
14905: CALL_OW 72
14909: ST_TO_ADDR
// if randomMen then
14910: LD_VAR 0 2
14914: IFFALSE 14934
// Say ( randomMen [ 1 ] , DArm-1-nocargo ) else
14916: LD_VAR 0 2
14920: PUSH
14921: LD_INT 1
14923: ARRAY
14924: PPUSH
14925: LD_STRING DArm-1-nocargo
14927: PPUSH
14928: CALL_OW 88
14932: GO 14956
// if randomWomen then
14934: LD_VAR 0 3
14938: IFFALSE 14956
// Say ( randomWomen [ 1 ] , DArf-1-nocargo ) ;
14940: LD_VAR 0 3
14944: PUSH
14945: LD_INT 1
14947: ARRAY
14948: PPUSH
14949: LD_STRING DArf-1-nocargo
14951: PPUSH
14952: CALL_OW 88
// end ;
14956: LD_VAR 0 1
14960: RET
// export function IncomingAttack ; begin
14961: LD_INT 0
14963: PPUSH
// if attackWave = 1 then
14964: LD_EXP 16
14968: PUSH
14969: LD_INT 1
14971: EQUAL
14972: IFFALSE 15043
// begin DialogueOn ;
14974: CALL_OW 6
// SayRadio ( Omar , DO-1-radio-1 ) ;
14978: LD_EXP 33
14982: PPUSH
14983: LD_STRING DO-1-radio-1
14985: PPUSH
14986: CALL_OW 94
// Say ( Heike , DH-1-radio-1- ) ;
14990: LD_EXP 24
14994: PPUSH
14995: LD_STRING DH-1-radio-1-
14997: PPUSH
14998: CALL_OW 88
// if IsOk ( Markov ) then
15002: LD_EXP 31
15006: PPUSH
15007: CALL_OW 302
15011: IFFALSE 15037
// begin Say ( Markov , DMar-1-radio-1 ) ;
15013: LD_EXP 31
15017: PPUSH
15018: LD_STRING DMar-1-radio-1
15020: PPUSH
15021: CALL_OW 88
// Say ( Heike , DH-2-radio-1 ) ;
15025: LD_EXP 24
15029: PPUSH
15030: LD_STRING DH-2-radio-1
15032: PPUSH
15033: CALL_OW 88
// end ; DialogueOff ;
15037: CALL_OW 7
// end else
15041: GO 15067
// begin SayRadio ( Omar , DO-1-radio-u ) ;
15043: LD_EXP 33
15047: PPUSH
15048: LD_STRING DO-1-radio-u
15050: PPUSH
15051: CALL_OW 94
// Say ( Heike , DH-1-radio-u ) ;
15055: LD_EXP 24
15059: PPUSH
15060: LD_STRING DH-1-radio-u
15062: PPUSH
15063: CALL_OW 88
// end ; end ;
15067: LD_VAR 0 1
15071: RET
// every 0 0$1 trigger UnitFilter ( usForces , [ f_inarea , westRoad ] ) do var i ;
15072: LD_EXP 40
15076: PPUSH
15077: LD_INT 95
15079: PUSH
15080: LD_INT 8
15082: PUSH
15083: EMPTY
15084: LIST
15085: LIST
15086: PPUSH
15087: CALL_OW 72
15091: IFFALSE 15194
15093: GO 15095
15095: DISABLE
15096: LD_INT 0
15098: PPUSH
// begin enable ;
15099: ENABLE
// for i in UnitFilter ( usForces , [ f_inarea , westRoad ] ) do
15100: LD_ADDR_VAR 0 1
15104: PUSH
15105: LD_EXP 40
15109: PPUSH
15110: LD_INT 95
15112: PUSH
15113: LD_INT 8
15115: PUSH
15116: EMPTY
15117: LIST
15118: LIST
15119: PPUSH
15120: CALL_OW 72
15124: PUSH
15125: FOR_IN
15126: IFFALSE 15155
// begin usForces := usForces diff i ;
15128: LD_ADDR_EXP 40
15132: PUSH
15133: LD_EXP 40
15137: PUSH
15138: LD_VAR 0 1
15142: DIFF
15143: ST_TO_ADDR
// RemoveUnit ( i ) ;
15144: LD_VAR 0 1
15148: PPUSH
15149: CALL_OW 64
// end ;
15153: GO 15125
15155: POP
15156: POP
// if not americanHasEscaped and attackWave = 1 then
15157: LD_EXP 7
15161: NOT
15162: PUSH
15163: LD_EXP 16
15167: PUSH
15168: LD_INT 1
15170: EQUAL
15171: AND
15172: IFFALSE 15194
// begin americanHasEscaped := true ;
15174: LD_ADDR_EXP 7
15178: PUSH
15179: LD_INT 1
15181: ST_TO_ADDR
// Say ( Heike , DH-2-assault-a ) ;
15182: LD_EXP 24
15186: PPUSH
15187: LD_STRING DH-2-assault-a
15189: PPUSH
15190: CALL_OW 88
// end ; end ;
15194: PPOPN 1
15196: END
// every 0 0$1 trigger FilterUnitsInArea ( farmerBase , [ f_side , 1 ] ) do
15197: LD_INT 4
15199: PPUSH
15200: LD_INT 22
15202: PUSH
15203: LD_INT 1
15205: PUSH
15206: EMPTY
15207: LIST
15208: LIST
15209: PPUSH
15210: CALL_OW 70
15214: IFFALSE 15231
15216: GO 15218
15218: DISABLE
// SayRadio ( Farmer , DF-1-attack ) ;
15219: LD_EXP 32
15223: PPUSH
15224: LD_STRING DF-1-attack
15226: PPUSH
15227: CALL_OW 94
15231: END
// every 0 0$1 trigger GetSide ( arDepot ) = 2 do
15232: LD_INT 5
15234: PPUSH
15235: CALL_OW 255
15239: PUSH
15240: LD_INT 2
15242: EQUAL
15243: IFFALSE 15255
15245: GO 15247
15247: DISABLE
// YouLost ( Attack ) ;
15248: LD_STRING Attack
15250: PPUSH
15251: CALL_OW 104
15255: END
// every 0 0$30 trigger not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) and not FilterAllUnits ( [ f_side , 4 ] ) and not retreatAllowed and farmerCrates > 160 and FilterUnitsInArea ( americanBaseArea , [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) do var randomMen , randomWomen , speaker , place ;
15256: LD_INT 22
15258: PUSH
15259: LD_INT 1
15261: PUSH
15262: EMPTY
15263: LIST
15264: LIST
15265: PUSH
15266: LD_INT 21
15268: PUSH
15269: LD_INT 1
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: PUSH
15276: EMPTY
15277: LIST
15278: LIST
15279: PPUSH
15280: CALL_OW 69
15284: NOT
15285: PUSH
15286: LD_INT 22
15288: PUSH
15289: LD_INT 4
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PPUSH
15296: CALL_OW 69
15300: NOT
15301: AND
15302: PUSH
15303: LD_EXP 10
15307: NOT
15308: AND
15309: PUSH
15310: LD_EXP 12
15314: PUSH
15315: LD_INT 160
15317: GREATER
15318: AND
15319: PUSH
15320: LD_INT 7
15322: PPUSH
15323: LD_INT 22
15325: PUSH
15326: LD_INT 2
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: PUSH
15333: LD_INT 21
15335: PUSH
15336: LD_INT 1
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PPUSH
15347: CALL_OW 70
15351: AND
15352: IFFALSE 16085
15354: GO 15356
15356: DISABLE
15357: LD_INT 0
15359: PPUSH
15360: PPUSH
15361: PPUSH
15362: PPUSH
// begin randomMen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) ;
15363: LD_ADDR_VAR 0 1
15367: PUSH
15368: LD_EXP 38
15372: PPUSH
15373: LD_INT 26
15375: PUSH
15376: LD_INT 1
15378: PUSH
15379: EMPTY
15380: LIST
15381: LIST
15382: PPUSH
15383: CALL_OW 72
15387: ST_TO_ADDR
// randomWomen := UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) ;
15388: LD_ADDR_VAR 0 2
15392: PUSH
15393: LD_EXP 38
15397: PPUSH
15398: LD_INT 26
15400: PUSH
15401: LD_INT 2
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PPUSH
15408: CALL_OW 72
15412: ST_TO_ADDR
// if IsOk ( Kaia ) then
15413: LD_EXP 29
15417: PPUSH
15418: CALL_OW 302
15422: IFFALSE 15443
// speaker := [ Kaia , DK ] else
15424: LD_ADDR_VAR 0 3
15428: PUSH
15429: LD_EXP 29
15433: PUSH
15434: LD_STRING DK
15436: PUSH
15437: EMPTY
15438: LIST
15439: LIST
15440: ST_TO_ADDR
15441: GO 15523
// if randomMen then
15443: LD_VAR 0 1
15447: IFFALSE 15482
// speaker := [ randomMen [ rand ( 1 , randomMen ) ] , DArm ] else
15449: LD_ADDR_VAR 0 3
15453: PUSH
15454: LD_VAR 0 1
15458: PUSH
15459: LD_INT 1
15461: PPUSH
15462: LD_VAR 0 1
15466: PPUSH
15467: CALL_OW 12
15471: ARRAY
15472: PUSH
15473: LD_STRING DArm
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: ST_TO_ADDR
15480: GO 15523
// if randomWomen then
15482: LD_VAR 0 2
15486: IFFALSE 15521
// speaker := [ randomWomen [ rand ( 1 , randomWomen ) ] , DArf ] else
15488: LD_ADDR_VAR 0 3
15492: PUSH
15493: LD_VAR 0 2
15497: PUSH
15498: LD_INT 1
15500: PPUSH
15501: LD_VAR 0 2
15505: PPUSH
15506: CALL_OW 12
15510: ARRAY
15511: PUSH
15512: LD_STRING DArf
15514: PUSH
15515: EMPTY
15516: LIST
15517: LIST
15518: ST_TO_ADDR
15519: GO 15523
// exit ;
15521: GO 16085
// if IsInUnit ( speaker [ 1 ] ) then
15523: LD_VAR 0 3
15527: PUSH
15528: LD_INT 1
15530: ARRAY
15531: PPUSH
15532: CALL_OW 310
15536: IFFALSE 15559
// place := IsInUnit ( speaker [ 1 ] ) else
15538: LD_ADDR_VAR 0 4
15542: PUSH
15543: LD_VAR 0 3
15547: PUSH
15548: LD_INT 1
15550: ARRAY
15551: PPUSH
15552: CALL_OW 310
15556: ST_TO_ADDR
15557: GO 15573
// place := speaker [ 1 ] ;
15559: LD_ADDR_VAR 0 4
15563: PUSH
15564: LD_VAR 0 3
15568: PUSH
15569: LD_INT 1
15571: ARRAY
15572: ST_TO_ADDR
// CenterNowOnUnits ( place ) ;
15573: LD_VAR 0 4
15577: PPUSH
15578: CALL_OW 87
// PrepareIbrahim ( GetX ( place ) , GetY ( place ) ) ;
15582: LD_VAR 0 4
15586: PPUSH
15587: CALL_OW 250
15591: PPUSH
15592: LD_VAR 0 4
15596: PPUSH
15597: CALL_OW 251
15601: PPUSH
15602: CALL 2992 0 2
// wait ( 0 0$2 ) ;
15606: LD_INT 70
15608: PPUSH
15609: CALL_OW 67
// if not IsPlaced ( Ibrahim ) then
15613: LD_EXP 34
15617: PPUSH
15618: CALL_OW 305
15622: NOT
15623: IFFALSE 15627
// exit ;
15625: GO 16085
// allowConvoys := false ;
15627: LD_ADDR_EXP 11
15631: PUSH
15632: LD_INT 0
15634: ST_TO_ADDR
// InGameOn ;
15635: CALL_OW 8
// wait ( 0 0$1 ) ;
15639: LD_INT 35
15641: PPUSH
15642: CALL_OW 67
// Say ( Ibrahim , DI-1-land ) ;
15646: LD_EXP 34
15650: PPUSH
15651: LD_STRING DI-1-land
15653: PPUSH
15654: CALL_OW 88
// if IsInUnit ( speaker [ 1 ] ) then
15658: LD_VAR 0 3
15662: PUSH
15663: LD_INT 1
15665: ARRAY
15666: PPUSH
15667: CALL_OW 310
15671: IFFALSE 15686
// ComExit ( speaker [ 1 ] ) ;
15673: LD_VAR 0 3
15677: PUSH
15678: LD_INT 1
15680: ARRAY
15681: PPUSH
15682: CALL 1095 0 1
// AddComMoveUnit ( speaker [ 1 ] , Ibrahim ) ;
15686: LD_VAR 0 3
15690: PUSH
15691: LD_INT 1
15693: ARRAY
15694: PPUSH
15695: LD_EXP 34
15699: PPUSH
15700: CALL_OW 172
// AddComTurnUnit ( speaker [ 1 ] , Ibrahim ) ;
15704: LD_VAR 0 3
15708: PUSH
15709: LD_INT 1
15711: ARRAY
15712: PPUSH
15713: LD_EXP 34
15717: PPUSH
15718: CALL_OW 179
// ComTurnUnit ( Ibrahim , speaker [ 1 ] ) ;
15722: LD_EXP 34
15726: PPUSH
15727: LD_VAR 0 3
15731: PUSH
15732: LD_INT 1
15734: ARRAY
15735: PPUSH
15736: CALL_OW 119
// wait ( 0 0$1 ) ;
15740: LD_INT 35
15742: PPUSH
15743: CALL_OW 67
// Say ( speaker [ 1 ] , speaker [ 2 ] & -1-land ) ;
15747: LD_VAR 0 3
15751: PUSH
15752: LD_INT 1
15754: ARRAY
15755: PPUSH
15756: LD_VAR 0 3
15760: PUSH
15761: LD_INT 2
15763: ARRAY
15764: PUSH
15765: LD_STRING -1-land
15767: STR
15768: PPUSH
15769: CALL_OW 88
// Say ( Ibrahim , DI-2-land ) ;
15773: LD_EXP 34
15777: PPUSH
15778: LD_STRING DI-2-land
15780: PPUSH
15781: CALL_OW 88
// Say ( speaker [ 1 ] , speaker [ 2 ] & -2-land ) ;
15785: LD_VAR 0 3
15789: PUSH
15790: LD_INT 1
15792: ARRAY
15793: PPUSH
15794: LD_VAR 0 3
15798: PUSH
15799: LD_INT 2
15801: ARRAY
15802: PUSH
15803: LD_STRING -2-land
15805: STR
15806: PPUSH
15807: CALL_OW 88
// if IsInUnit ( Heike ) then
15811: LD_EXP 24
15815: PPUSH
15816: CALL_OW 310
15820: IFFALSE 15831
// ComExitBuilding ( Heike ) ;
15822: LD_EXP 24
15826: PPUSH
15827: CALL_OW 122
// AddComMoveXY ( Heike , 34 , 21 ) ;
15831: LD_EXP 24
15835: PPUSH
15836: LD_INT 34
15838: PPUSH
15839: LD_INT 21
15841: PPUSH
15842: CALL_OW 171
// AddComTurnUnit ( Heike , speaker [ 1 ] ) ;
15846: LD_EXP 24
15850: PPUSH
15851: LD_VAR 0 3
15855: PUSH
15856: LD_INT 1
15858: ARRAY
15859: PPUSH
15860: CALL_OW 179
// ComMoveXY ( Ibrahim , 36 , 22 ) ;
15864: LD_EXP 34
15868: PPUSH
15869: LD_INT 36
15871: PPUSH
15872: LD_INT 22
15874: PPUSH
15875: CALL_OW 111
// ComMoveXY ( speaker [ 1 ] , 35 , 22 ) ;
15879: LD_VAR 0 3
15883: PUSH
15884: LD_INT 1
15886: ARRAY
15887: PPUSH
15888: LD_INT 35
15890: PPUSH
15891: LD_INT 22
15893: PPUSH
15894: CALL_OW 111
// AddComTurnUnit ( [ Ibrahim , speaker [ 1 ] ] , Heike ) ;
15898: LD_EXP 34
15902: PUSH
15903: LD_VAR 0 3
15907: PUSH
15908: LD_INT 1
15910: ARRAY
15911: PUSH
15912: EMPTY
15913: LIST
15914: LIST
15915: PPUSH
15916: LD_EXP 24
15920: PPUSH
15921: CALL_OW 179
// repeat wait ( 0 0$2 ) ;
15925: LD_INT 70
15927: PPUSH
15928: CALL_OW 67
// CenterOnUnits ( speaker [ 1 ] ) ;
15932: LD_VAR 0 3
15936: PUSH
15937: LD_INT 1
15939: ARRAY
15940: PPUSH
15941: CALL_OW 85
// until GetDistUnits ( speaker [ 1 ] , usDepot ) < 8 ;
15945: LD_VAR 0 3
15949: PUSH
15950: LD_INT 1
15952: ARRAY
15953: PPUSH
15954: LD_INT 11
15956: PPUSH
15957: CALL_OW 296
15961: PUSH
15962: LD_INT 8
15964: LESS
15965: IFFALSE 15925
// CenterOnUnits ( usDepot ) ;
15967: LD_INT 11
15969: PPUSH
15970: CALL_OW 85
// Say ( speaker [ 1 ] , speaker [ 2 ] & -3-land ) ;
15974: LD_VAR 0 3
15978: PUSH
15979: LD_INT 1
15981: ARRAY
15982: PPUSH
15983: LD_VAR 0 3
15987: PUSH
15988: LD_INT 2
15990: ARRAY
15991: PUSH
15992: LD_STRING -3-land
15994: STR
15995: PPUSH
15996: CALL_OW 88
// Say ( Heike , DH-1-land ) ;
16000: LD_EXP 24
16004: PPUSH
16005: LD_STRING DH-1-land
16007: PPUSH
16008: CALL_OW 88
// if UnitsInside ( usDepot ) = 6 then
16012: LD_INT 11
16014: PPUSH
16015: CALL_OW 313
16019: PUSH
16020: LD_INT 6
16022: EQUAL
16023: IFFALSE 16041
// ComExitBuilding ( UnitsInside ( usDepot ) [ 1 ] ) ;
16025: LD_INT 11
16027: PPUSH
16028: CALL_OW 313
16032: PUSH
16033: LD_INT 1
16035: ARRAY
16036: PPUSH
16037: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16041: LD_EXP 34
16045: PPUSH
16046: LD_INT 2
16048: PPUSH
16049: CALL_OW 235
// ComEnterUnit ( Ibrahim , usDepot ) ;
16053: LD_EXP 34
16057: PPUSH
16058: LD_INT 11
16060: PPUSH
16061: CALL_OW 120
// InGameOff ;
16065: CALL_OW 9
// ibrahimInDepot := true ;
16069: LD_ADDR_EXP 21
16073: PUSH
16074: LD_INT 1
16076: ST_TO_ADDR
// allowConvoys := true ;
16077: LD_ADDR_EXP 11
16081: PUSH
16082: LD_INT 1
16084: ST_TO_ADDR
// end ;
16085: PPOPN 4
16087: END
// export function IbrahimQuery ; begin
16088: LD_INT 0
16090: PPUSH
// case Query ( IbrahimQuery ) of 1 :
16091: LD_STRING IbrahimQuery
16093: PPUSH
16094: CALL_OW 97
16098: PUSH
16099: LD_INT 1
16101: DOUBLE
16102: EQUAL
16103: IFTRUE 16107
16105: GO 16416
16107: POP
// begin allowConvoys := false ;
16108: LD_ADDR_EXP 11
16112: PUSH
16113: LD_INT 0
16115: ST_TO_ADDR
// ibrahimInDepot := false ;
16116: LD_ADDR_EXP 21
16120: PUSH
16121: LD_INT 0
16123: ST_TO_ADDR
// InGameOn ;
16124: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
16128: LD_EXP 24
16132: PPUSH
16133: CALL_OW 87
// wait ( 0 0$1 ) ;
16137: LD_INT 35
16139: PPUSH
16140: CALL_OW 67
// Say ( Heike , DH-1-interrogation ) ;
16144: LD_EXP 24
16148: PPUSH
16149: LD_STRING DH-1-interrogation
16151: PPUSH
16152: CALL_OW 88
// Say ( Ibrahim , DI-1-interrogation ) ;
16156: LD_EXP 34
16160: PPUSH
16161: LD_STRING DI-1-interrogation
16163: PPUSH
16164: CALL_OW 88
// Say ( Heike , DH-2-interrogation ) ;
16168: LD_EXP 24
16172: PPUSH
16173: LD_STRING DH-2-interrogation
16175: PPUSH
16176: CALL_OW 88
// Say ( Ibrahim , DI-2-interrogation ) ;
16180: LD_EXP 34
16184: PPUSH
16185: LD_STRING DI-2-interrogation
16187: PPUSH
16188: CALL_OW 88
// Say ( Heike , DH-3-interrogation ) ;
16192: LD_EXP 24
16196: PPUSH
16197: LD_STRING DH-3-interrogation
16199: PPUSH
16200: CALL_OW 88
// Say ( Ibrahim , DI-3-interrogation ) ;
16204: LD_EXP 34
16208: PPUSH
16209: LD_STRING DI-3-interrogation
16211: PPUSH
16212: CALL_OW 88
// Say ( Heike , DH-4-interrogation ) ;
16216: LD_EXP 24
16220: PPUSH
16221: LD_STRING DH-4-interrogation
16223: PPUSH
16224: CALL_OW 88
// Say ( Ibrahim , DI-4-interrogation ) ;
16228: LD_EXP 34
16232: PPUSH
16233: LD_STRING DI-4-interrogation
16235: PPUSH
16236: CALL_OW 88
// Say ( Heike , DH-5-interrogation ) ;
16240: LD_EXP 24
16244: PPUSH
16245: LD_STRING DH-5-interrogation
16247: PPUSH
16248: CALL_OW 88
// Say ( Ibrahim , DI-5-interrogation ) ;
16252: LD_EXP 34
16256: PPUSH
16257: LD_STRING DI-5-interrogation
16259: PPUSH
16260: CALL_OW 88
// wait ( 0 0$1 ) ;
16264: LD_INT 35
16266: PPUSH
16267: CALL_OW 67
// case Query ( IbrahimDecisionQuery ) of 1 :
16271: LD_STRING IbrahimDecisionQuery
16273: PPUSH
16274: CALL_OW 97
16278: PUSH
16279: LD_INT 1
16281: DOUBLE
16282: EQUAL
16283: IFTRUE 16287
16285: GO 16311
16287: POP
// begin Say ( Ibrahim , DI-1-kill ) ;
16288: LD_EXP 34
16292: PPUSH
16293: LD_STRING DI-1-kill
16295: PPUSH
16296: CALL_OW 88
// KillUnit ( Ibrahim ) ;
16300: LD_EXP 34
16304: PPUSH
16305: CALL_OW 66
// end ; 2 :
16309: GO 16410
16311: LD_INT 2
16313: DOUBLE
16314: EQUAL
16315: IFTRUE 16319
16317: GO 16409
16319: POP
// begin SetSide ( Ibrahim , 6 ) ;
16320: LD_EXP 34
16324: PPUSH
16325: LD_INT 6
16327: PPUSH
16328: CALL_OW 235
// ComExitBuilding ( Ibrahim ) ;
16332: LD_EXP 34
16336: PPUSH
16337: CALL_OW 122
// AddComMoveXY ( Ibrahim , 32 , 5 ) ;
16341: LD_EXP 34
16345: PPUSH
16346: LD_INT 32
16348: PPUSH
16349: LD_INT 5
16351: PPUSH
16352: CALL_OW 171
// ComExitBuilding ( Heike ) ;
16356: LD_EXP 24
16360: PPUSH
16361: CALL_OW 122
// AddComMoveXY ( Heike , 36 , 21 ) ;
16365: LD_EXP 24
16369: PPUSH
16370: LD_INT 36
16372: PPUSH
16373: LD_INT 21
16375: PPUSH
16376: CALL_OW 171
// AddComWait ( Ibrahim , 1 1$20 ) ;
16380: LD_EXP 34
16384: PPUSH
16385: LD_INT 2800
16387: PPUSH
16388: CALL_OW 202
// AddComMoveXY ( Ibrahim , 38 , 28 ) ;
16392: LD_EXP 34
16396: PPUSH
16397: LD_INT 38
16399: PPUSH
16400: LD_INT 28
16402: PPUSH
16403: CALL_OW 171
// end ; end ;
16407: GO 16410
16409: POP
// InGameOff ;
16410: CALL_OW 9
// end ; 2 :
16414: GO 16430
16416: LD_INT 2
16418: DOUBLE
16419: EQUAL
16420: IFTRUE 16424
16422: GO 16429
16424: POP
// exit ; end ;
16425: GO 16453
16427: GO 16430
16429: POP
// allowConvoys := true ;
16430: LD_ADDR_EXP 11
16434: PUSH
16435: LD_INT 1
16437: ST_TO_ADDR
// wait ( 0 0$40 ) ;
16438: LD_INT 1400
16440: PPUSH
16441: CALL_OW 67
// ibrahimIsFree := true ;
16445: LD_ADDR_EXP 22
16449: PUSH
16450: LD_INT 1
16452: ST_TO_ADDR
// end ;
16453: LD_VAR 0 1
16457: RET
// every 0 0$10 trigger ibrahimIsFree and IsInArea ( Ibrahim , americanBaseArea ) and See ( 6 , Heike ) and not FilterAllUnits ( [ f_side , 4 ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do var changeClass , b ;
16458: LD_EXP 22
16462: PUSH
16463: LD_EXP 34
16467: PPUSH
16468: LD_INT 7
16470: PPUSH
16471: CALL_OW 308
16475: AND
16476: PUSH
16477: LD_INT 6
16479: PPUSH
16480: LD_EXP 24
16484: PPUSH
16485: CALL_OW 292
16489: AND
16490: PUSH
16491: LD_INT 22
16493: PUSH
16494: LD_INT 4
16496: PUSH
16497: EMPTY
16498: LIST
16499: LIST
16500: PPUSH
16501: CALL_OW 69
16505: NOT
16506: AND
16507: PUSH
16508: LD_INT 22
16510: PUSH
16511: LD_INT 1
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: PUSH
16518: LD_INT 21
16520: PUSH
16521: LD_INT 1
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: PUSH
16528: EMPTY
16529: LIST
16530: LIST
16531: PPUSH
16532: CALL_OW 69
16536: NOT
16537: AND
16538: IFFALSE 17106
16540: GO 16542
16542: DISABLE
16543: LD_INT 0
16545: PPUSH
16546: PPUSH
// begin allowConvoys := false ;
16547: LD_ADDR_EXP 11
16551: PUSH
16552: LD_INT 0
16554: ST_TO_ADDR
// InGameOn ;
16555: CALL_OW 8
// CenterNowOnUnits ( Ibrahim ) ;
16559: LD_EXP 34
16563: PPUSH
16564: CALL_OW 87
// ComTurnUnit ( Heike , Ibrahim ) ;
16568: LD_EXP 24
16572: PPUSH
16573: LD_EXP 34
16577: PPUSH
16578: CALL_OW 119
// ComTurnUnit ( Ibrahim , Heike ) ;
16582: LD_EXP 34
16586: PPUSH
16587: LD_EXP 24
16591: PPUSH
16592: CALL_OW 119
// Say ( Ibrahim , DI-1-free ) ;
16596: LD_EXP 34
16600: PPUSH
16601: LD_STRING DI-1-free
16603: PPUSH
16604: CALL_OW 88
// Say ( Heike , DH-1-free ) ;
16608: LD_EXP 24
16612: PPUSH
16613: LD_STRING DH-1-free
16615: PPUSH
16616: CALL_OW 88
// Say ( Ibrahim , DI-2-free ) ;
16620: LD_EXP 34
16624: PPUSH
16625: LD_STRING DI-2-free
16627: PPUSH
16628: CALL_OW 88
// changeClass := 0 ;
16632: LD_ADDR_VAR 0 1
16636: PUSH
16637: LD_INT 0
16639: ST_TO_ADDR
// case Query ( IbrahimJoinQuery ) of 1 :
16640: LD_STRING IbrahimJoinQuery
16642: PPUSH
16643: CALL_OW 97
16647: PUSH
16648: LD_INT 1
16650: DOUBLE
16651: EQUAL
16652: IFTRUE 16656
16654: GO 16667
16656: POP
// begin changeClass := 1 ;
16657: LD_ADDR_VAR 0 1
16661: PUSH
16662: LD_INT 1
16664: ST_TO_ADDR
// end ; 2 :
16665: GO 16875
16667: LD_INT 2
16669: DOUBLE
16670: EQUAL
16671: IFTRUE 16675
16673: GO 16795
16675: POP
// begin Say ( Heike , DH-1-decline ) ;
16676: LD_EXP 24
16680: PPUSH
16681: LD_STRING DH-1-decline
16683: PPUSH
16684: CALL_OW 88
// Say ( Ibrahim , DI-1-decline ) ;
16688: LD_EXP 34
16692: PPUSH
16693: LD_STRING DI-1-decline
16695: PPUSH
16696: CALL_OW 88
// InGameOff ;
16700: CALL_OW 9
// ComMoveXY ( Ibrahim , 30 , 1 ) ;
16704: LD_EXP 34
16708: PPUSH
16709: LD_INT 30
16711: PPUSH
16712: LD_INT 1
16714: PPUSH
16715: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
16719: LD_INT 35
16721: PPUSH
16722: CALL_OW 67
// until IsAt ( Ibrahim , 30 , 1 ) or not FilterAllUnits ( [ [ f_side , 2 ] , [ f_see , 6 ] ] ) ;
16726: LD_EXP 34
16730: PPUSH
16731: LD_INT 30
16733: PPUSH
16734: LD_INT 1
16736: PPUSH
16737: CALL_OW 307
16741: PUSH
16742: LD_INT 22
16744: PUSH
16745: LD_INT 2
16747: PUSH
16748: EMPTY
16749: LIST
16750: LIST
16751: PUSH
16752: LD_INT 101
16754: PUSH
16755: LD_INT 6
16757: PUSH
16758: EMPTY
16759: LIST
16760: LIST
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: PPUSH
16766: CALL_OW 69
16770: NOT
16771: OR
16772: IFFALSE 16719
// RemoveUnit ( Ibrahim ) ;
16774: LD_EXP 34
16778: PPUSH
16779: CALL_OW 64
// SaveVariable ( 1 , IbrahimHasEscaped ) ;
16783: LD_INT 1
16785: PPUSH
16786: LD_STRING IbrahimHasEscaped
16788: PPUSH
16789: CALL_OW 39
// end ; 3 :
16793: GO 16875
16795: LD_INT 3
16797: DOUBLE
16798: EQUAL
16799: IFTRUE 16803
16801: GO 16874
16803: POP
// begin Say ( Heike , DH-1-radio-hq ) ;
16804: LD_EXP 24
16808: PPUSH
16809: LD_STRING DH-1-radio-hq
16811: PPUSH
16812: CALL_OW 88
// SayRadio ( Omar , DO-1-radio-hq ) ;
16816: LD_EXP 33
16820: PPUSH
16821: LD_STRING DO-1-radio-hq
16823: PPUSH
16824: CALL_OW 94
// Say ( Heike , DH-2-radio-hq ) ;
16828: LD_EXP 24
16832: PPUSH
16833: LD_STRING DH-2-radio-hq
16835: PPUSH
16836: CALL_OW 88
// SayRadio ( Omar , DO-2-radio-hq ) ;
16840: LD_EXP 33
16844: PPUSH
16845: LD_STRING DO-2-radio-hq
16847: PPUSH
16848: CALL_OW 94
// Say ( Heike , DH-3-radio-hq ) ;
16852: LD_EXP 24
16856: PPUSH
16857: LD_STRING DH-3-radio-hq
16859: PPUSH
16860: CALL_OW 88
// changeClass := 1 ;
16864: LD_ADDR_VAR 0 1
16868: PUSH
16869: LD_INT 1
16871: ST_TO_ADDR
// end ; end ;
16872: GO 16875
16874: POP
// if changeClass then
16875: LD_VAR 0 1
16879: IFFALSE 17106
// begin Say ( Heike , DH-1-agree ) ;
16881: LD_EXP 24
16885: PPUSH
16886: LD_STRING DH-1-agree
16888: PPUSH
16889: CALL_OW 88
// if IsOk ( Givi ) then
16893: LD_EXP 25
16897: PPUSH
16898: CALL_OW 302
16902: IFFALSE 16940
// begin Say ( Givi , DG-1-agree ) ;
16904: LD_EXP 25
16908: PPUSH
16909: LD_STRING DG-1-agree
16911: PPUSH
16912: CALL_OW 88
// Say ( Heike , DH-2-agree ) ;
16916: LD_EXP 24
16920: PPUSH
16921: LD_STRING DH-2-agree
16923: PPUSH
16924: CALL_OW 88
// Say ( Givi , DG-2-agree ) ;
16928: LD_EXP 25
16932: PPUSH
16933: LD_STRING DG-2-agree
16935: PPUSH
16936: CALL_OW 88
// end ; if UnitsInside ( usDepot ) = 6 then
16940: LD_INT 11
16942: PPUSH
16943: CALL_OW 313
16947: PUSH
16948: LD_INT 6
16950: EQUAL
16951: IFFALSE 16969
// ComExitBuilding ( UnitsInside ( usDepot ) [ 1 ] ) ;
16953: LD_INT 11
16955: PPUSH
16956: CALL_OW 313
16960: PUSH
16961: LD_INT 1
16963: ARRAY
16964: PPUSH
16965: CALL_OW 122
// SetSide ( Ibrahim , 2 ) ;
16969: LD_EXP 34
16973: PPUSH
16974: LD_INT 2
16976: PPUSH
16977: CALL_OW 235
// ComEnterUnit ( Ibrahim , usDepot ) ;
16981: LD_EXP 34
16985: PPUSH
16986: LD_INT 11
16988: PPUSH
16989: CALL_OW 120
// InGameOff ;
16993: CALL_OW 9
// allowConvoys := true ;
16997: LD_ADDR_EXP 11
17001: PUSH
17002: LD_INT 1
17004: ST_TO_ADDR
// b := 0 ;
17005: LD_ADDR_VAR 0 2
17009: PUSH
17010: LD_INT 0
17012: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17013: LD_INT 35
17015: PPUSH
17016: CALL_OW 67
// b := IsInUnit ( Ibrahim ) ;
17020: LD_ADDR_VAR 0 2
17024: PUSH
17025: LD_EXP 34
17029: PPUSH
17030: CALL_OW 310
17034: ST_TO_ADDR
// until b and GetType ( b ) = unit_building ;
17035: LD_VAR 0 2
17039: PUSH
17040: LD_VAR 0 2
17044: PPUSH
17045: CALL_OW 247
17049: PUSH
17050: LD_INT 3
17052: EQUAL
17053: AND
17054: IFFALSE 17013
// RemoveUnit ( Ibrahim ) ;
17056: LD_EXP 34
17060: PPUSH
17061: CALL_OW 64
// uc_side := 2 ;
17065: LD_ADDR_OWVAR 20
17069: PUSH
17070: LD_INT 2
17072: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
17073: LD_ADDR_EXP 34
17077: PUSH
17078: LD_STRING Ibrahim
17080: PPUSH
17081: LD_INT 0
17083: PPUSH
17084: LD_STRING 
17086: PPUSH
17087: CALL 268 0 3
17091: ST_TO_ADDR
// PlaceHumanInUnit ( Ibrahim , b ) ;
17092: LD_EXP 34
17096: PPUSH
17097: LD_VAR 0 2
17101: PPUSH
17102: CALL_OW 52
// end ; end ;
17106: PPOPN 2
17108: END
// every 0 0$1 trigger retreatAllowed and omarCargoCounter < 1 do
17109: LD_EXP 10
17113: PUSH
17114: LD_EXP 17
17118: PUSH
17119: LD_INT 1
17121: LESS
17122: AND
17123: IFFALSE 17502
17125: GO 17127
17127: DISABLE
// begin DialogueOn ;
17128: CALL_OW 6
// Say ( Heike , DH-1-final ) ;
17132: LD_EXP 24
17136: PPUSH
17137: LD_STRING DH-1-final
17139: PPUSH
17140: CALL_OW 88
// if tick <= [ 68 68$00 , 65 65$00 , 63 63$00 ] [ Difficulty ] then
17144: LD_OWVAR 1
17148: PUSH
17149: LD_INT 142800
17151: PUSH
17152: LD_INT 136500
17154: PUSH
17155: LD_INT 132300
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: LIST
17162: PUSH
17163: LD_OWVAR 67
17167: ARRAY
17168: LESSEQUAL
17169: IFFALSE 17183
// AddMedal ( med1 , 1 ) else
17171: LD_STRING med1
17173: PPUSH
17174: LD_INT 1
17176: PPUSH
17177: CALL_OW 101
17181: GO 17194
// AddMedal ( med1 , - 1 ) ;
17183: LD_STRING med1
17185: PPUSH
17186: LD_INT 1
17188: NEG
17189: PPUSH
17190: CALL_OW 101
// if vehCounter >= 2 then
17194: LD_EXP 18
17198: PUSH
17199: LD_INT 2
17201: GREATEREQUAL
17202: IFFALSE 17216
// AddMedal ( med2 , 1 ) else
17204: LD_STRING med2
17206: PPUSH
17207: LD_INT 1
17209: PPUSH
17210: CALL_OW 101
17214: GO 17227
// AddMedal ( med2 , - 1 ) ;
17216: LD_STRING med2
17218: PPUSH
17219: LD_INT 1
17221: NEG
17222: PPUSH
17223: CALL_OW 101
// if deadCounter = 0 then
17227: LD_EXP 8
17231: PUSH
17232: LD_INT 0
17234: EQUAL
17235: IFFALSE 17249
// AddMedal ( med3 , 1 ) else
17237: LD_STRING med3
17239: PPUSH
17240: LD_INT 1
17242: PPUSH
17243: CALL_OW 101
17247: GO 17260
// AddMedal ( med3 , - 1 ) ;
17249: LD_STRING med3
17251: PPUSH
17252: LD_INT 1
17254: NEG
17255: PPUSH
17256: CALL_OW 101
// GiveMedals ( MAIN ) ;
17260: LD_STRING MAIN
17262: PPUSH
17263: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
17267: LD_INT 22
17269: PUSH
17270: LD_INT 2
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: PUSH
17277: LD_INT 23
17279: PUSH
17280: LD_INT 2
17282: PUSH
17283: EMPTY
17284: LIST
17285: LIST
17286: PUSH
17287: LD_INT 21
17289: PUSH
17290: LD_INT 1
17292: PUSH
17293: EMPTY
17294: LIST
17295: LIST
17296: PUSH
17297: EMPTY
17298: LIST
17299: LIST
17300: LIST
17301: PPUSH
17302: CALL_OW 69
17306: PPUSH
17307: CALL_OW 43
// SaveCharacters ( Heike , 03_Heike ) ;
17311: LD_EXP 24
17315: PPUSH
17316: LD_STRING 03_Heike
17318: PPUSH
17319: CALL_OW 38
// SaveCharacters ( Aviradze , 03_Aviradze ) ;
17323: LD_EXP 28
17327: PPUSH
17328: LD_STRING 03_Aviradze
17330: PPUSH
17331: CALL_OW 38
// if Givi then
17335: LD_EXP 25
17339: IFFALSE 17353
// SaveCharacters ( Givi , 03_Givi ) ;
17341: LD_EXP 25
17345: PPUSH
17346: LD_STRING 03_Givi
17348: PPUSH
17349: CALL_OW 38
// if Mike then
17353: LD_EXP 26
17357: IFFALSE 17371
// SaveCharacters ( Mike , 03_Mike ) ;
17359: LD_EXP 26
17363: PPUSH
17364: LD_STRING 03_Mike
17366: PPUSH
17367: CALL_OW 38
// if Kamil then
17371: LD_EXP 27
17375: IFFALSE 17389
// SaveCharacters ( Kamil , 03_Kamil ) ;
17377: LD_EXP 27
17381: PPUSH
17382: LD_STRING 03_Kamil
17384: PPUSH
17385: CALL_OW 38
// if Kaia then
17389: LD_EXP 29
17393: IFFALSE 17407
// SaveCharacters ( Kaia , 03_Kaia ) ;
17395: LD_EXP 29
17399: PPUSH
17400: LD_STRING 03_Kaia
17402: PPUSH
17403: CALL_OW 38
// if Sophia then
17407: LD_EXP 30
17411: IFFALSE 17425
// SaveCharacters ( Sophia , 03_Sophia ) ;
17413: LD_EXP 30
17417: PPUSH
17418: LD_STRING 03_Sophia
17420: PPUSH
17421: CALL_OW 38
// if Markov then
17425: LD_EXP 31
17429: IFFALSE 17443
// SaveCharacters ( Markov , 03_Markov ) ;
17431: LD_EXP 31
17435: PPUSH
17436: LD_STRING 03_Markov
17438: PPUSH
17439: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
17443: LD_EXP 34
17447: PUSH
17448: LD_EXP 34
17452: PPUSH
17453: CALL_OW 255
17457: PUSH
17458: LD_INT 2
17460: EQUAL
17461: AND
17462: IFFALSE 17476
// SaveCharacters ( Markov , 03_Ibrahim ) ;
17464: LD_EXP 31
17468: PPUSH
17469: LD_STRING 03_Ibrahim
17471: PPUSH
17472: CALL_OW 38
// if heikeSecondSquad then
17476: LD_EXP 38
17480: IFFALSE 17494
// SaveCharacters ( heikeSecondSquad , 03_others ) ;
17482: LD_EXP 38
17486: PPUSH
17487: LD_STRING 03_others
17489: PPUSH
17490: CALL_OW 38
// YouWin ;
17494: CALL_OW 103
// DialogueOff ;
17498: CALL_OW 7
// end ; end_of_file
17502: END
// on UnitDestroyed ( un ) do begin if un = Heike then
17503: LD_VAR 0 1
17507: PUSH
17508: LD_EXP 24
17512: EQUAL
17513: IFFALSE 17522
// YouLost ( Heike ) ;
17515: LD_STRING Heike
17517: PPUSH
17518: CALL_OW 104
// if un = Aviradze then
17522: LD_VAR 0 1
17526: PUSH
17527: LD_EXP 28
17531: EQUAL
17532: IFFALSE 17541
// YouLost ( Aviradze ) ;
17534: LD_STRING Aviradze
17536: PPUSH
17537: CALL_OW 104
// if un = usDepot and not retreatAllowed then
17541: LD_VAR 0 1
17545: PUSH
17546: LD_INT 11
17548: EQUAL
17549: PUSH
17550: LD_EXP 10
17554: NOT
17555: AND
17556: IFFALSE 17565
// YouLost ( Depot ) ;
17558: LD_STRING Depot
17560: PPUSH
17561: CALL_OW 104
// if un = arDepot then
17565: LD_VAR 0 1
17569: PUSH
17570: LD_INT 5
17572: EQUAL
17573: IFFALSE 17582
// YouLost ( FarmerDepot ) ;
17575: LD_STRING FarmerDepot
17577: PPUSH
17578: CALL_OW 104
// if un = Farmer then
17582: LD_VAR 0 1
17586: PUSH
17587: LD_EXP 32
17591: EQUAL
17592: IFFALSE 17601
// YouLost ( Farmer ) ;
17594: LD_STRING Farmer
17596: PPUSH
17597: CALL_OW 104
// if un in usForces then
17601: LD_VAR 0 1
17605: PUSH
17606: LD_EXP 40
17610: IN
17611: IFFALSE 17629
// usForces := usForces diff un ;
17613: LD_ADDR_EXP 40
17617: PUSH
17618: LD_EXP 40
17622: PUSH
17623: LD_VAR 0 1
17627: DIFF
17628: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) then
17629: LD_VAR 0 1
17633: PUSH
17634: LD_INT 22
17636: PUSH
17637: LD_INT 2
17639: PUSH
17640: EMPTY
17641: LIST
17642: LIST
17643: PUSH
17644: LD_INT 23
17646: PUSH
17647: LD_INT 2
17649: PUSH
17650: EMPTY
17651: LIST
17652: LIST
17653: PUSH
17654: LD_INT 21
17656: PUSH
17657: LD_INT 1
17659: PUSH
17660: EMPTY
17661: LIST
17662: LIST
17663: PUSH
17664: EMPTY
17665: LIST
17666: LIST
17667: LIST
17668: PPUSH
17669: CALL_OW 69
17673: IN
17674: IFFALSE 17690
// deadCounter := deadCounter + 1 ;
17676: LD_ADDR_EXP 8
17680: PUSH
17681: LD_EXP 8
17685: PUSH
17686: LD_INT 1
17688: PLUS
17689: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) and not firstConvoyDestroyed then
17690: LD_VAR 0 1
17694: PUSH
17695: LD_INT 22
17697: PUSH
17698: LD_INT 4
17700: PUSH
17701: EMPTY
17702: LIST
17703: LIST
17704: PUSH
17705: LD_INT 34
17707: PUSH
17708: LD_INT 12
17710: PUSH
17711: EMPTY
17712: LIST
17713: LIST
17714: PUSH
17715: EMPTY
17716: LIST
17717: LIST
17718: PPUSH
17719: CALL_OW 69
17723: IN
17724: PUSH
17725: LD_EXP 15
17729: NOT
17730: AND
17731: IFFALSE 17741
// firstConvoyDestroyed := true ;
17733: LD_ADDR_EXP 15
17737: PUSH
17738: LD_INT 1
17740: ST_TO_ADDR
// if un in usAttackers then
17741: LD_VAR 0 1
17745: PUSH
17746: LD_EXP 43
17750: IN
17751: IFFALSE 17769
// usAttackers := usAttackers diff un ;
17753: LD_ADDR_EXP 43
17757: PUSH
17758: LD_EXP 43
17762: PUSH
17763: LD_VAR 0 1
17767: DIFF
17768: ST_TO_ADDR
// end ;
17769: PPOPN 1
17771: END
// on LeaveBuilding ( building , unit ) do begin if unit = Ibrahim and ibrahimInDepot then
17772: LD_VAR 0 2
17776: PUSH
17777: LD_EXP 34
17781: EQUAL
17782: PUSH
17783: LD_EXP 21
17787: AND
17788: IFFALSE 17823
// begin Video ( true ) ;
17790: LD_INT 1
17792: PPUSH
17793: CALL 991 0 1
// ComEnterUnit ( Ibrahim , usDepot ) ;
17797: LD_EXP 34
17801: PPUSH
17802: LD_INT 11
17804: PPUSH
17805: CALL_OW 120
// wait ( 0 0$1 ) ;
17809: LD_INT 35
17811: PPUSH
17812: CALL_OW 67
// Video ( false ) ;
17816: LD_INT 0
17818: PPUSH
17819: CALL 991 0 1
// end ; end ;
17823: PPOPN 2
17825: END
// on EnterBuilding ( building , unit ) do begin if unit = Heike and building = usDepot and ibrahimInDepot then
17826: LD_VAR 0 2
17830: PUSH
17831: LD_EXP 24
17835: EQUAL
17836: PUSH
17837: LD_VAR 0 1
17841: PUSH
17842: LD_INT 11
17844: EQUAL
17845: AND
17846: PUSH
17847: LD_EXP 21
17851: AND
17852: IFFALSE 17858
// IbrahimQuery ;
17854: CALL 16088 0 0
// end ;
17858: PPOPN 2
17860: END
// on VehicleCaptured ( newId , oldId , oldSide , captureUnit ) do begin if oldId in usAttackers then
17861: LD_VAR 0 2
17865: PUSH
17866: LD_EXP 43
17870: IN
17871: IFFALSE 17889
// usAttackers := usAttackers diff oldId ;
17873: LD_ADDR_EXP 43
17877: PUSH
17878: LD_EXP 43
17882: PUSH
17883: LD_VAR 0 2
17887: DIFF
17888: ST_TO_ADDR
// if oldSide = 4 and not firstConvoyDestroyed then
17889: LD_VAR 0 3
17893: PUSH
17894: LD_INT 4
17896: EQUAL
17897: PUSH
17898: LD_EXP 15
17902: NOT
17903: AND
17904: IFFALSE 17914
// firstConvoyDestroyed := true ;
17906: LD_ADDR_EXP 15
17910: PUSH
17911: LD_INT 1
17913: ST_TO_ADDR
// if GetWeapon ( oldId ) = us_cargo_bay and GetCargo ( oldId , mat_cans ) = 0 then
17914: LD_VAR 0 2
17918: PPUSH
17919: CALL_OW 264
17923: PUSH
17924: LD_INT 12
17926: EQUAL
17927: PUSH
17928: LD_VAR 0 2
17932: PPUSH
17933: LD_INT 1
17935: PPUSH
17936: CALL_OW 289
17940: PUSH
17941: LD_INT 0
17943: EQUAL
17944: AND
17945: IFFALSE 17951
// EmptyCargoDialog ;
17947: CALL 14830 0 0
// end ;
17951: PPOPN 4
17953: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
17954: LD_VAR 0 1
17958: PUSH
17959: LD_INT 2
17961: EQUAL
17962: PUSH
17963: LD_VAR 0 2
17967: PUSH
17968: LD_INT 5
17970: EQUAL
17971: AND
17972: IFFALSE 17981
// YouLost ( Attack ) ;
17974: LD_STRING Attack
17976: PPUSH
17977: CALL_OW 104
// end ;
17981: PPOPN 2
17983: END
// on BuildingComplete ( b ) do begin if GetSide ( b ) = 1 then
17984: LD_VAR 0 1
17988: PPUSH
17989: CALL_OW 255
17993: PUSH
17994: LD_INT 1
17996: EQUAL
17997: IFFALSE 18131
// begin if GetBType ( b ) = b_lab then
17999: LD_VAR 0 1
18003: PPUSH
18004: CALL_OW 266
18008: PUSH
18009: LD_INT 6
18011: EQUAL
18012: IFFALSE 18052
// begin ComEnterUnit ( UnitFilter ( usForces , [ f_class , 4 ] ) , b ) ;
18014: LD_EXP 40
18018: PPUSH
18019: LD_INT 25
18021: PUSH
18022: LD_INT 4
18024: PUSH
18025: EMPTY
18026: LIST
18027: LIST
18028: PPUSH
18029: CALL_OW 72
18033: PPUSH
18034: LD_VAR 0 1
18038: PPUSH
18039: CALL_OW 120
// AmLabResearch ( b ) ;
18043: LD_VAR 0 1
18047: PPUSH
18048: CALL 5921 0 1
// end ; if GetBType ( b ) = b_armoury then
18052: LD_VAR 0 1
18056: PPUSH
18057: CALL_OW 266
18061: PUSH
18062: LD_INT 4
18064: EQUAL
18065: IFFALSE 18113
// ComEnterUnit ( UnitFilter ( usForces , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) , b ) ;
18067: LD_EXP 40
18071: PPUSH
18072: LD_INT 25
18074: PUSH
18075: LD_INT 1
18077: PUSH
18078: EMPTY
18079: LIST
18080: LIST
18081: PUSH
18082: LD_INT 3
18084: PUSH
18085: LD_INT 54
18087: PUSH
18088: EMPTY
18089: LIST
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: PUSH
18095: EMPTY
18096: LIST
18097: LIST
18098: PPUSH
18099: CALL_OW 72
18103: PPUSH
18104: LD_VAR 0 1
18108: PPUSH
18109: CALL_OW 120
// americanBuildList := Delete ( americanBuildList , 1 ) ;
18113: LD_ADDR_EXP 42
18117: PUSH
18118: LD_EXP 42
18122: PPUSH
18123: LD_INT 1
18125: PPUSH
18126: CALL_OW 3
18130: ST_TO_ADDR
// end ; end ;
18131: PPOPN 1
18133: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( veh ) = 2 then
18134: LD_VAR 0 1
18138: PPUSH
18139: CALL_OW 255
18143: PUSH
18144: LD_INT 2
18146: EQUAL
18147: IFFALSE 18163
// vehCounter := vehCounter + 1 ;
18149: LD_ADDR_EXP 18
18153: PUSH
18154: LD_EXP 18
18158: PUSH
18159: LD_INT 1
18161: PLUS
18162: ST_TO_ADDR
// end ;
18163: PPOPN 2
18165: END
// on SailEvent ( event ) do begin if event = eventAttack then
18166: LD_VAR 0 1
18170: PUSH
18171: LD_EXP 20
18175: EQUAL
18176: IFFALSE 18182
// AmericanAttack ;
18178: CALL 7361 0 0
// end ; end_of_file
18182: PPOPN 1
18184: END
// every 0 0$50 + 0 0$10 trigger tick <= [ 4 4$00 , 3 3$00 , 2 2$30 ] [ Difficulty ] do
18185: LD_OWVAR 1
18189: PUSH
18190: LD_INT 8400
18192: PUSH
18193: LD_INT 6300
18195: PUSH
18196: LD_INT 5250
18198: PUSH
18199: EMPTY
18200: LIST
18201: LIST
18202: LIST
18203: PUSH
18204: LD_OWVAR 67
18208: ARRAY
18209: LESSEQUAL
18210: IFFALSE 18237
18212: GO 18214
18214: DISABLE
// begin enable ;
18215: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18216: LD_INT 1
18218: PPUSH
18219: LD_INT 5
18221: PPUSH
18222: CALL_OW 12
18226: PPUSH
18227: LD_INT 9
18229: PPUSH
18230: LD_INT 1
18232: PPUSH
18233: CALL_OW 55
// end ;
18237: END
// every 1 1$40 + 0 0$20 trigger americanBaseCaptured and tick <= [ 26 26$00 , 23 23$00 , 20 20$00 ] [ Difficulty ] do
18238: LD_EXP 6
18242: PUSH
18243: LD_OWVAR 1
18247: PUSH
18248: LD_INT 54600
18250: PUSH
18251: LD_INT 48300
18253: PUSH
18254: LD_INT 42000
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: LIST
18261: PUSH
18262: LD_OWVAR 67
18266: ARRAY
18267: LESSEQUAL
18268: AND
18269: IFFALSE 18296
18271: GO 18273
18273: DISABLE
// begin enable ;
18274: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , cratesArea , true ) ;
18275: LD_INT 1
18277: PPUSH
18278: LD_INT 5
18280: PPUSH
18281: CALL_OW 12
18285: PPUSH
18286: LD_INT 9
18288: PPUSH
18289: LD_INT 1
18291: PPUSH
18292: CALL_OW 55
// end ; end_of_file
18296: END
// every 0 0$1 trigger not retreatAllowed and farmerBaseReady and farmerCrates <= farmerRequestedCrates do
18297: LD_EXP 10
18301: NOT
18302: PUSH
18303: LD_EXP 4
18307: AND
18308: PUSH
18309: LD_EXP 12
18313: PUSH
18314: LD_EXP 13
18318: LESSEQUAL
18319: AND
18320: IFFALSE 18410
18322: GO 18324
18324: DISABLE
// begin enable ;
18325: ENABLE
// display_strings := [ #X103-1 , farmerCrates , farmerRequestedCrates ] ;
18326: LD_ADDR_OWVAR 47
18330: PUSH
18331: LD_STRING #X103-1
18333: PUSH
18334: LD_EXP 12
18338: PUSH
18339: LD_EXP 13
18343: PUSH
18344: EMPTY
18345: LIST
18346: LIST
18347: LIST
18348: ST_TO_ADDR
// farmerCrates := GetResourceType ( GetBase ( arDepot ) , mat_cans ) ;
18349: LD_ADDR_EXP 12
18353: PUSH
18354: LD_INT 5
18356: PPUSH
18357: CALL_OW 274
18361: PPUSH
18362: LD_INT 1
18364: PPUSH
18365: CALL_OW 275
18369: ST_TO_ADDR
// if GetResourceArea ( collectFarmerArea , mat_cans ) = 0 then
18370: LD_INT 10
18372: PPUSH
18373: LD_INT 1
18375: PPUSH
18376: CALL_OW 287
18380: PUSH
18381: LD_INT 0
18383: EQUAL
18384: IFFALSE 18402
// farmerCratesCounter := farmerCratesCounter - 0 0$1 else
18386: LD_ADDR_EXP 14
18390: PUSH
18391: LD_EXP 14
18395: PUSH
18396: LD_INT 35
18398: MINUS
18399: ST_TO_ADDR
18400: GO 18410
// farmerCratesCounter := 30 30$00 ;
18402: LD_ADDR_EXP 14
18406: PUSH
18407: LD_INT 63000
18409: ST_TO_ADDR
// end ; end_of_file
18410: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
18411: GO 18413
18413: DISABLE
// begin ru_radar := 98 ;
18414: LD_ADDR_EXP 44
18418: PUSH
18419: LD_INT 98
18421: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
18422: LD_ADDR_EXP 45
18426: PUSH
18427: LD_INT 89
18429: ST_TO_ADDR
// us_hack := 99 ;
18430: LD_ADDR_EXP 46
18434: PUSH
18435: LD_INT 99
18437: ST_TO_ADDR
// us_artillery := 97 ;
18438: LD_ADDR_EXP 47
18442: PUSH
18443: LD_INT 97
18445: ST_TO_ADDR
// ar_bio_bomb := 91 ;
18446: LD_ADDR_EXP 48
18450: PUSH
18451: LD_INT 91
18453: ST_TO_ADDR
// tech_Artillery := 80 ;
18454: LD_ADDR_EXP 49
18458: PUSH
18459: LD_INT 80
18461: ST_TO_ADDR
// tech_RadMat := 81 ;
18462: LD_ADDR_EXP 50
18466: PUSH
18467: LD_INT 81
18469: ST_TO_ADDR
// tech_BasicTools := 82 ;
18470: LD_ADDR_EXP 51
18474: PUSH
18475: LD_INT 82
18477: ST_TO_ADDR
// tech_Cargo := 83 ;
18478: LD_ADDR_EXP 52
18482: PUSH
18483: LD_INT 83
18485: ST_TO_ADDR
// tech_Track := 84 ;
18486: LD_ADDR_EXP 53
18490: PUSH
18491: LD_INT 84
18493: ST_TO_ADDR
// tech_Crane := 85 ;
18494: LD_ADDR_EXP 54
18498: PUSH
18499: LD_INT 85
18501: ST_TO_ADDR
// tech_Bulldozer := 86 ;
18502: LD_ADDR_EXP 55
18506: PUSH
18507: LD_INT 86
18509: ST_TO_ADDR
// tech_Hovercraft := 87 ;
18510: LD_ADDR_EXP 56
18514: PUSH
18515: LD_INT 87
18517: ST_TO_ADDR
// end ;
18518: END
