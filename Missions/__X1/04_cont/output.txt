// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 17 0 0
// PrepareArabian ;
   8: CALL 1795 0 0
// Action ;
  12: CALL 2114 0 0
// end ;
  16: END
// export debug , prefix , baseConstructed , labConstructed , hiddenCameraAllowed , cameraCounter , camAreas ; function Init ; begin
  17: LD_INT 0
  19: PPUSH
// debug := true ;
  20: LD_ADDR_EXP 1
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// prefix := 03_ ;
  28: LD_ADDR_EXP 2
  32: PUSH
  33: LD_STRING 03_
  35: ST_TO_ADDR
// baseConstructed := false ;
  36: LD_ADDR_EXP 3
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// labConstructed := false ;
  44: LD_ADDR_EXP 4
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// hiddenCameraAllowed := false ;
  52: LD_ADDR_EXP 5
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// cameraCounter := 6 ;
  60: LD_ADDR_EXP 6
  64: PUSH
  65: LD_INT 6
  67: ST_TO_ADDR
// camAreas := [ camArea1 , camArea2 , camArea3 , camArea4 , camArea5 , camArea6 ] ;
  68: LD_ADDR_EXP 7
  72: PUSH
  73: LD_INT 3
  75: PUSH
  76: LD_INT 4
  78: PUSH
  79: LD_INT 5
  81: PUSH
  82: LD_INT 6
  84: PUSH
  85: LD_INT 7
  87: PUSH
  88: LD_INT 8
  90: PUSH
  91: EMPTY
  92: LIST
  93: LIST
  94: LIST
  95: LIST
  96: LIST
  97: LIST
  98: ST_TO_ADDR
// end ; end_of_file
  99: LD_VAR 0 1
 103: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 104: LD_INT 0
 106: PPUSH
 107: PPUSH
// if exist_mode then
 108: LD_VAR 0 2
 112: IFFALSE 137
// unit := CreateCharacter ( prefix & ident ) else
 114: LD_ADDR_VAR 0 5
 118: PUSH
 119: LD_VAR 0 3
 123: PUSH
 124: LD_VAR 0 1
 128: STR
 129: PPUSH
 130: CALL_OW 34
 134: ST_TO_ADDR
 135: GO 152
// unit := NewCharacter ( ident ) ;
 137: LD_ADDR_VAR 0 5
 141: PUSH
 142: LD_VAR 0 1
 146: PPUSH
 147: CALL_OW 25
 151: ST_TO_ADDR
// result := unit ;
 152: LD_ADDR_VAR 0 4
 156: PUSH
 157: LD_VAR 0 5
 161: ST_TO_ADDR
// end ;
 162: LD_VAR 0 4
 166: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 167: LD_INT 0
 169: PPUSH
// uc_side := side ;
 170: LD_ADDR_OWVAR 20
 174: PUSH
 175: LD_VAR 0 1
 179: ST_TO_ADDR
// uc_nation := nation ;
 180: LD_ADDR_OWVAR 21
 184: PUSH
 185: LD_VAR 0 2
 189: ST_TO_ADDR
// vc_chassis := chassis ;
 190: LD_ADDR_OWVAR 37
 194: PUSH
 195: LD_VAR 0 3
 199: ST_TO_ADDR
// vc_engine := engine ;
 200: LD_ADDR_OWVAR 39
 204: PUSH
 205: LD_VAR 0 4
 209: ST_TO_ADDR
// vc_control := control ;
 210: LD_ADDR_OWVAR 38
 214: PUSH
 215: LD_VAR 0 5
 219: ST_TO_ADDR
// vc_weapon := weapon ;
 220: LD_ADDR_OWVAR 40
 224: PUSH
 225: LD_VAR 0 6
 229: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 230: LD_ADDR_OWVAR 41
 234: PUSH
 235: LD_VAR 0 7
 239: ST_TO_ADDR
// result := CreateVehicle ;
 240: LD_ADDR_VAR 0 8
 244: PUSH
 245: CALL_OW 45
 249: ST_TO_ADDR
// end ;
 250: LD_VAR 0 8
 254: RET
// export function SayX ( units , ident ) ; var i ; begin
 255: LD_INT 0
 257: PPUSH
 258: PPUSH
// result := false ;
 259: LD_ADDR_VAR 0 3
 263: PUSH
 264: LD_INT 0
 266: ST_TO_ADDR
// if not units then
 267: LD_VAR 0 1
 271: NOT
 272: IFFALSE 276
// exit ;
 274: GO 330
// for i in units do
 276: LD_ADDR_VAR 0 4
 280: PUSH
 281: LD_VAR 0 1
 285: PUSH
 286: FOR_IN
 287: IFFALSE 328
// if IsOk ( i ) then
 289: LD_VAR 0 4
 293: PPUSH
 294: CALL_OW 302
 298: IFFALSE 326
// begin Say ( i , ident ) ;
 300: LD_VAR 0 4
 304: PPUSH
 305: LD_VAR 0 2
 309: PPUSH
 310: CALL_OW 88
// result := i ;
 314: LD_ADDR_VAR 0 3
 318: PUSH
 319: LD_VAR 0 4
 323: ST_TO_ADDR
// break ;
 324: GO 328
// end ;
 326: GO 286
 328: POP
 329: POP
// end ;
 330: LD_VAR 0 3
 334: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 335: LD_INT 0
 337: PPUSH
 338: PPUSH
// InitUc ;
 339: CALL_OW 18
// InitHc ;
 343: CALL_OW 19
// uc_side := 0 ;
 347: LD_ADDR_OWVAR 20
 351: PUSH
 352: LD_INT 0
 354: ST_TO_ADDR
// uc_nation := 0 ;
 355: LD_ADDR_OWVAR 21
 359: PUSH
 360: LD_INT 0
 362: ST_TO_ADDR
// for i = 1 to amount do
 363: LD_ADDR_VAR 0 4
 367: PUSH
 368: DOUBLE
 369: LD_INT 1
 371: DEC
 372: ST_TO_ADDR
 373: LD_VAR 0 2
 377: PUSH
 378: FOR_TO
 379: IFFALSE 461
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 381: LD_ADDR_OWVAR 29
 385: PUSH
 386: LD_INT 9
 388: PPUSH
 389: LD_INT 12
 391: PPUSH
 392: CALL_OW 12
 396: PUSH
 397: LD_INT 9
 399: PPUSH
 400: LD_INT 12
 402: PPUSH
 403: CALL_OW 12
 407: PUSH
 408: EMPTY
 409: LIST
 410: LIST
 411: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 412: LD_ADDR_OWVAR 35
 416: PUSH
 417: LD_INT 1
 419: NEG
 420: PPUSH
 421: LD_INT 1
 423: PPUSH
 424: CALL_OW 12
 428: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 429: LD_INT 0
 431: PPUSH
 432: LD_INT 12
 434: PPUSH
 435: LD_INT 1
 437: PPUSH
 438: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 442: CALL_OW 44
 446: PPUSH
 447: LD_VAR 0 1
 451: PPUSH
 452: LD_INT 0
 454: PPUSH
 455: CALL_OW 49
// end ;
 459: GO 378
 461: POP
 462: POP
// InitHc ;
 463: CALL_OW 19
// end ;
 467: LD_VAR 0 3
 471: RET
// export function PrepareNature ( forest ) ; var i ; begin
 472: LD_INT 0
 474: PPUSH
 475: PPUSH
// SpawnApeman ( forest , [ 6 , 5 , 4 ] [ Difficulty ] ) ;
 476: LD_VAR 0 1
 480: PPUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 5
 486: PUSH
 487: LD_INT 4
 489: PUSH
 490: EMPTY
 491: LIST
 492: LIST
 493: LIST
 494: PUSH
 495: LD_OWVAR 67
 499: ARRAY
 500: PPUSH
 501: CALL 335 0 2
// for i := 1 to 3 do
 505: LD_ADDR_VAR 0 3
 509: PUSH
 510: DOUBLE
 511: LD_INT 1
 513: DEC
 514: ST_TO_ADDR
 515: LD_INT 3
 517: PUSH
 518: FOR_TO
 519: IFFALSE 556
// begin hc_class := 21 ;
 521: LD_ADDR_OWVAR 28
 525: PUSH
 526: LD_INT 21
 528: ST_TO_ADDR
// hc_gallery :=  ;
 529: LD_ADDR_OWVAR 33
 533: PUSH
 534: LD_STRING 
 536: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 537: CALL_OW 44
 541: PPUSH
 542: LD_VAR 0 1
 546: PPUSH
 547: LD_INT 0
 549: PPUSH
 550: CALL_OW 49
// end ;
 554: GO 518
 556: POP
 557: POP
// for i := 1 to 2 do
 558: LD_ADDR_VAR 0 3
 562: PUSH
 563: DOUBLE
 564: LD_INT 1
 566: DEC
 567: ST_TO_ADDR
 568: LD_INT 2
 570: PUSH
 571: FOR_TO
 572: IFFALSE 609
// begin hc_class := 18 ;
 574: LD_ADDR_OWVAR 28
 578: PUSH
 579: LD_INT 18
 581: ST_TO_ADDR
// hc_gallery :=  ;
 582: LD_ADDR_OWVAR 33
 586: PUSH
 587: LD_STRING 
 589: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 590: CALL_OW 44
 594: PPUSH
 595: LD_VAR 0 1
 599: PPUSH
 600: LD_INT 0
 602: PPUSH
 603: CALL_OW 49
// end ;
 607: GO 571
 609: POP
 610: POP
// for i := 1 to 2 do
 611: LD_ADDR_VAR 0 3
 615: PUSH
 616: DOUBLE
 617: LD_INT 1
 619: DEC
 620: ST_TO_ADDR
 621: LD_INT 2
 623: PUSH
 624: FOR_TO
 625: IFFALSE 662
// begin hc_class := 13 ;
 627: LD_ADDR_OWVAR 28
 631: PUSH
 632: LD_INT 13
 634: ST_TO_ADDR
// hc_gallery :=  ;
 635: LD_ADDR_OWVAR 33
 639: PUSH
 640: LD_STRING 
 642: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 643: CALL_OW 44
 647: PPUSH
 648: LD_VAR 0 1
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 49
// end ;
 660: GO 624
 662: POP
 663: POP
// end ;
 664: LD_VAR 0 2
 668: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 669: LD_INT 0
 671: PPUSH
 672: PPUSH
 673: PPUSH
// if not observer or not unit then
 674: LD_VAR 0 1
 678: NOT
 679: PUSH
 680: LD_VAR 0 2
 684: NOT
 685: OR
 686: IFFALSE 690
// exit ;
 688: GO 738
// if not See ( GetSide ( observer ) , unit ) then
 690: LD_VAR 0 1
 694: PPUSH
 695: CALL_OW 255
 699: PPUSH
 700: LD_VAR 0 2
 704: PPUSH
 705: CALL_OW 292
 709: NOT
 710: IFFALSE 714
// exit ;
 712: GO 738
// result := GetDistUnits ( observer , unit ) < 12 ;
 714: LD_ADDR_VAR 0 3
 718: PUSH
 719: LD_VAR 0 1
 723: PPUSH
 724: LD_VAR 0 2
 728: PPUSH
 729: CALL_OW 296
 733: PUSH
 734: LD_INT 12
 736: LESS
 737: ST_TO_ADDR
// end ;
 738: LD_VAR 0 3
 742: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 743: LD_INT 0
 745: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 746: LD_VAR 0 2
 750: PUSH
 751: LD_INT 1
 753: ARRAY
 754: PPUSH
 755: LD_VAR 0 2
 759: PUSH
 760: LD_INT 2
 762: ARRAY
 763: PPUSH
 764: CALL_OW 488
 768: PUSH
 769: LD_VAR 0 2
 773: PUSH
 774: LD_INT 1
 776: ARRAY
 777: PPUSH
 778: LD_VAR 0 2
 782: PUSH
 783: LD_INT 2
 785: ARRAY
 786: PPUSH
 787: CALL_OW 428
 791: PUSH
 792: LD_INT 0
 794: EQUAL
 795: AND
 796: IFFALSE 830
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 798: LD_VAR 0 1
 802: PPUSH
 803: LD_VAR 0 2
 807: PUSH
 808: LD_INT 1
 810: ARRAY
 811: PPUSH
 812: LD_VAR 0 2
 816: PUSH
 817: LD_INT 2
 819: ARRAY
 820: PPUSH
 821: LD_VAR 0 3
 825: PPUSH
 826: CALL_OW 48
// end ;
 830: LD_VAR 0 4
 834: RET
// export function Video ( mode ) ; begin
 835: LD_INT 0
 837: PPUSH
// ingame_video = mode ;
 838: LD_ADDR_OWVAR 52
 842: PUSH
 843: LD_VAR 0 1
 847: ST_TO_ADDR
// interface_hidden = mode ;
 848: LD_ADDR_OWVAR 54
 852: PUSH
 853: LD_VAR 0 1
 857: ST_TO_ADDR
// end ;
 858: LD_VAR 0 2
 862: RET
// export function ReverseArray ( array ) ; var i ; begin
 863: LD_INT 0
 865: PPUSH
 866: PPUSH
// if not array then
 867: LD_VAR 0 1
 871: NOT
 872: IFFALSE 876
// exit ;
 874: GO 934
// result := [ ] ;
 876: LD_ADDR_VAR 0 2
 880: PUSH
 881: EMPTY
 882: ST_TO_ADDR
// for i := 1 to array do
 883: LD_ADDR_VAR 0 3
 887: PUSH
 888: DOUBLE
 889: LD_INT 1
 891: DEC
 892: ST_TO_ADDR
 893: LD_VAR 0 1
 897: PUSH
 898: FOR_TO
 899: IFFALSE 932
// result := Insert ( result , 1 , array [ i ] ) ;
 901: LD_ADDR_VAR 0 2
 905: PUSH
 906: LD_VAR 0 2
 910: PPUSH
 911: LD_INT 1
 913: PPUSH
 914: LD_VAR 0 1
 918: PUSH
 919: LD_VAR 0 3
 923: ARRAY
 924: PPUSH
 925: CALL_OW 2
 929: ST_TO_ADDR
 930: GO 898
 932: POP
 933: POP
// end ;
 934: LD_VAR 0 2
 938: RET
// export function ComExit ( unit ) ; begin
 939: LD_INT 0
 941: PPUSH
// result := IsInUnit ( unit ) ;
 942: LD_ADDR_VAR 0 2
 946: PUSH
 947: LD_VAR 0 1
 951: PPUSH
 952: CALL_OW 310
 956: ST_TO_ADDR
// if not result then
 957: LD_VAR 0 2
 961: NOT
 962: IFFALSE 966
// exit ;
 964: GO 1001
// if GetType ( result ) = unit_vehicle then
 966: LD_VAR 0 2
 970: PPUSH
 971: CALL_OW 247
 975: PUSH
 976: LD_INT 2
 978: EQUAL
 979: IFFALSE 992
// ComExitVehicle ( unit ) else
 981: LD_VAR 0 1
 985: PPUSH
 986: CALL_OW 121
 990: GO 1001
// ComExitBuilding ( unit ) ;
 992: LD_VAR 0 1
 996: PPUSH
 997: CALL_OW 122
// end ;
1001: LD_VAR 0 2
1005: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1006: LD_INT 0
1008: PPUSH
1009: PPUSH
// if not side or not nation then
1010: LD_VAR 0 1
1014: NOT
1015: PUSH
1016: LD_VAR 0 2
1020: NOT
1021: OR
1022: IFFALSE 1026
// exit ;
1024: GO 1790
// case nation of nation_american :
1026: LD_VAR 0 2
1030: PUSH
1031: LD_INT 1
1033: DOUBLE
1034: EQUAL
1035: IFTRUE 1039
1037: GO 1253
1039: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1040: LD_ADDR_VAR 0 4
1044: PUSH
1045: LD_INT 35
1047: PUSH
1048: LD_INT 45
1050: PUSH
1051: LD_INT 46
1053: PUSH
1054: LD_INT 47
1056: PUSH
1057: LD_INT 82
1059: PUSH
1060: LD_INT 83
1062: PUSH
1063: LD_INT 84
1065: PUSH
1066: LD_INT 85
1068: PUSH
1069: LD_INT 86
1071: PUSH
1072: LD_INT 1
1074: PUSH
1075: LD_INT 2
1077: PUSH
1078: LD_INT 6
1080: PUSH
1081: LD_INT 15
1083: PUSH
1084: LD_INT 16
1086: PUSH
1087: LD_INT 7
1089: PUSH
1090: LD_INT 12
1092: PUSH
1093: LD_INT 13
1095: PUSH
1096: LD_INT 10
1098: PUSH
1099: LD_INT 14
1101: PUSH
1102: LD_INT 20
1104: PUSH
1105: LD_INT 21
1107: PUSH
1108: LD_INT 22
1110: PUSH
1111: LD_INT 25
1113: PUSH
1114: LD_INT 32
1116: PUSH
1117: LD_INT 27
1119: PUSH
1120: LD_INT 36
1122: PUSH
1123: LD_INT 69
1125: PUSH
1126: LD_INT 39
1128: PUSH
1129: LD_INT 34
1131: PUSH
1132: LD_INT 40
1134: PUSH
1135: LD_INT 48
1137: PUSH
1138: LD_INT 49
1140: PUSH
1141: LD_INT 50
1143: PUSH
1144: LD_INT 51
1146: PUSH
1147: LD_INT 52
1149: PUSH
1150: LD_INT 53
1152: PUSH
1153: LD_INT 54
1155: PUSH
1156: LD_INT 55
1158: PUSH
1159: LD_INT 56
1161: PUSH
1162: LD_INT 57
1164: PUSH
1165: LD_INT 58
1167: PUSH
1168: LD_INT 59
1170: PUSH
1171: LD_INT 60
1173: PUSH
1174: LD_INT 61
1176: PUSH
1177: LD_INT 62
1179: PUSH
1180: LD_INT 80
1182: PUSH
1183: LD_INT 82
1185: PUSH
1186: LD_INT 83
1188: PUSH
1189: LD_INT 84
1191: PUSH
1192: LD_INT 85
1194: PUSH
1195: LD_INT 86
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: LIST
1248: LIST
1249: LIST
1250: ST_TO_ADDR
1251: GO 1714
1253: LD_INT 2
1255: DOUBLE
1256: EQUAL
1257: IFTRUE 1261
1259: GO 1483
1261: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1262: LD_ADDR_VAR 0 4
1266: PUSH
1267: LD_INT 35
1269: PUSH
1270: LD_INT 45
1272: PUSH
1273: LD_INT 46
1275: PUSH
1276: LD_INT 47
1278: PUSH
1279: LD_INT 82
1281: PUSH
1282: LD_INT 83
1284: PUSH
1285: LD_INT 84
1287: PUSH
1288: LD_INT 85
1290: PUSH
1291: LD_INT 87
1293: PUSH
1294: LD_INT 70
1296: PUSH
1297: LD_INT 1
1299: PUSH
1300: LD_INT 11
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: LD_INT 4
1308: PUSH
1309: LD_INT 5
1311: PUSH
1312: LD_INT 6
1314: PUSH
1315: LD_INT 15
1317: PUSH
1318: LD_INT 18
1320: PUSH
1321: LD_INT 7
1323: PUSH
1324: LD_INT 17
1326: PUSH
1327: LD_INT 8
1329: PUSH
1330: LD_INT 20
1332: PUSH
1333: LD_INT 21
1335: PUSH
1336: LD_INT 22
1338: PUSH
1339: LD_INT 72
1341: PUSH
1342: LD_INT 26
1344: PUSH
1345: LD_INT 69
1347: PUSH
1348: LD_INT 39
1350: PUSH
1351: LD_INT 40
1353: PUSH
1354: LD_INT 41
1356: PUSH
1357: LD_INT 42
1359: PUSH
1360: LD_INT 43
1362: PUSH
1363: LD_INT 48
1365: PUSH
1366: LD_INT 49
1368: PUSH
1369: LD_INT 50
1371: PUSH
1372: LD_INT 51
1374: PUSH
1375: LD_INT 52
1377: PUSH
1378: LD_INT 53
1380: PUSH
1381: LD_INT 54
1383: PUSH
1384: LD_INT 55
1386: PUSH
1387: LD_INT 56
1389: PUSH
1390: LD_INT 60
1392: PUSH
1393: LD_INT 61
1395: PUSH
1396: LD_INT 62
1398: PUSH
1399: LD_INT 66
1401: PUSH
1402: LD_INT 67
1404: PUSH
1405: LD_INT 68
1407: PUSH
1408: LD_INT 81
1410: PUSH
1411: LD_INT 82
1413: PUSH
1414: LD_INT 83
1416: PUSH
1417: LD_INT 84
1419: PUSH
1420: LD_INT 85
1422: PUSH
1423: LD_INT 87
1425: PUSH
1426: EMPTY
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: ST_TO_ADDR
1481: GO 1714
1483: LD_INT 3
1485: DOUBLE
1486: EQUAL
1487: IFTRUE 1491
1489: GO 1713
1491: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1492: LD_ADDR_VAR 0 4
1496: PUSH
1497: LD_INT 46
1499: PUSH
1500: LD_INT 47
1502: PUSH
1503: LD_INT 1
1505: PUSH
1506: LD_INT 2
1508: PUSH
1509: LD_INT 82
1511: PUSH
1512: LD_INT 83
1514: PUSH
1515: LD_INT 84
1517: PUSH
1518: LD_INT 85
1520: PUSH
1521: LD_INT 86
1523: PUSH
1524: LD_INT 11
1526: PUSH
1527: LD_INT 9
1529: PUSH
1530: LD_INT 20
1532: PUSH
1533: LD_INT 19
1535: PUSH
1536: LD_INT 21
1538: PUSH
1539: LD_INT 24
1541: PUSH
1542: LD_INT 22
1544: PUSH
1545: LD_INT 25
1547: PUSH
1548: LD_INT 28
1550: PUSH
1551: LD_INT 29
1553: PUSH
1554: LD_INT 30
1556: PUSH
1557: LD_INT 31
1559: PUSH
1560: LD_INT 37
1562: PUSH
1563: LD_INT 38
1565: PUSH
1566: LD_INT 32
1568: PUSH
1569: LD_INT 27
1571: PUSH
1572: LD_INT 33
1574: PUSH
1575: LD_INT 69
1577: PUSH
1578: LD_INT 39
1580: PUSH
1581: LD_INT 34
1583: PUSH
1584: LD_INT 40
1586: PUSH
1587: LD_INT 71
1589: PUSH
1590: LD_INT 23
1592: PUSH
1593: LD_INT 44
1595: PUSH
1596: LD_INT 48
1598: PUSH
1599: LD_INT 49
1601: PUSH
1602: LD_INT 50
1604: PUSH
1605: LD_INT 51
1607: PUSH
1608: LD_INT 52
1610: PUSH
1611: LD_INT 53
1613: PUSH
1614: LD_INT 54
1616: PUSH
1617: LD_INT 55
1619: PUSH
1620: LD_INT 56
1622: PUSH
1623: LD_INT 57
1625: PUSH
1626: LD_INT 58
1628: PUSH
1629: LD_INT 59
1631: PUSH
1632: LD_INT 63
1634: PUSH
1635: LD_INT 64
1637: PUSH
1638: LD_INT 65
1640: PUSH
1641: LD_INT 82
1643: PUSH
1644: LD_INT 83
1646: PUSH
1647: LD_INT 84
1649: PUSH
1650: LD_INT 85
1652: PUSH
1653: LD_INT 86
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: ST_TO_ADDR
1711: GO 1714
1713: POP
// if state > - 1 and state < 3 then
1714: LD_VAR 0 3
1718: PUSH
1719: LD_INT 1
1721: NEG
1722: GREATER
1723: PUSH
1724: LD_VAR 0 3
1728: PUSH
1729: LD_INT 3
1731: LESS
1732: AND
1733: IFFALSE 1790
// for i in result do
1735: LD_ADDR_VAR 0 5
1739: PUSH
1740: LD_VAR 0 4
1744: PUSH
1745: FOR_IN
1746: IFFALSE 1788
// if GetTech ( i , side ) <> state then
1748: LD_VAR 0 5
1752: PPUSH
1753: LD_VAR 0 1
1757: PPUSH
1758: CALL_OW 321
1762: PUSH
1763: LD_VAR 0 3
1767: NONEQUAL
1768: IFFALSE 1786
// result := result diff i ;
1770: LD_ADDR_VAR 0 4
1774: PUSH
1775: LD_VAR 0 4
1779: PUSH
1780: LD_VAR 0 5
1784: DIFF
1785: ST_TO_ADDR
1786: GO 1745
1788: POP
1789: POP
// end ; end_of_file
1790: LD_VAR 0 4
1794: RET
// export Heike , Givi , Mike , Kamil , Kaia , Sophia , Markov , Omar , Ibrahim , Shariff , Kurt , Aviradze , heikeSecondSquad ; export function PrepareArabian ; var i ; begin
1795: LD_INT 0
1797: PPUSH
1798: PPUSH
// uc_side := 2 ;
1799: LD_ADDR_OWVAR 20
1803: PUSH
1804: LD_INT 2
1806: ST_TO_ADDR
// uc_nation := 2 ;
1807: LD_ADDR_OWVAR 21
1811: PUSH
1812: LD_INT 2
1814: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
1815: LD_ADDR_EXP 8
1819: PUSH
1820: LD_STRING Heike
1822: PPUSH
1823: LD_EXP 1
1827: NOT
1828: PPUSH
1829: LD_EXP 2
1833: PPUSH
1834: CALL 104 0 3
1838: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
1839: LD_ADDR_EXP 16
1843: PUSH
1844: LD_STRING Ibrahim
1846: PPUSH
1847: LD_EXP 1
1851: NOT
1852: PPUSH
1853: LD_EXP 2
1857: PPUSH
1858: CALL 104 0 3
1862: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
1863: LD_ADDR_EXP 9
1867: PUSH
1868: LD_STRING Givi
1870: PPUSH
1871: LD_EXP 1
1875: NOT
1876: PPUSH
1877: LD_EXP 2
1881: PPUSH
1882: CALL 104 0 3
1886: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
1887: LD_ADDR_EXP 10
1891: PUSH
1892: LD_STRING Mike
1894: PPUSH
1895: LD_EXP 1
1899: NOT
1900: PPUSH
1901: LD_EXP 2
1905: PPUSH
1906: CALL 104 0 3
1910: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
1911: LD_ADDR_EXP 11
1915: PUSH
1916: LD_STRING Kamil
1918: PPUSH
1919: LD_EXP 1
1923: NOT
1924: PPUSH
1925: LD_EXP 2
1929: PPUSH
1930: CALL 104 0 3
1934: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
1935: LD_ADDR_EXP 12
1939: PUSH
1940: LD_STRING Kaia
1942: PPUSH
1943: LD_EXP 1
1947: NOT
1948: PPUSH
1949: LD_EXP 2
1953: PPUSH
1954: CALL 104 0 3
1958: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
1959: LD_ADDR_EXP 13
1963: PUSH
1964: LD_STRING Sophia
1966: PPUSH
1967: LD_EXP 1
1971: NOT
1972: PPUSH
1973: LD_EXP 2
1977: PPUSH
1978: CALL 104 0 3
1982: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
1983: LD_ADDR_EXP 14
1987: PUSH
1988: LD_STRING Markov
1990: PPUSH
1991: LD_EXP 1
1995: NOT
1996: PPUSH
1997: LD_EXP 2
2001: PPUSH
2002: CALL 104 0 3
2006: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2007: LD_ADDR_EXP 19
2011: PUSH
2012: LD_STRING Aviradze
2014: PPUSH
2015: LD_EXP 1
2019: NOT
2020: PPUSH
2021: LD_EXP 2
2025: PPUSH
2026: CALL 104 0 3
2030: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 03_others ) ;
2031: LD_ADDR_EXP 20
2035: PUSH
2036: LD_STRING 03_others
2038: PPUSH
2039: CALL_OW 31
2043: ST_TO_ADDR
// uc_side := 5 ;
2044: LD_ADDR_OWVAR 20
2048: PUSH
2049: LD_INT 5
2051: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2052: LD_ADDR_EXP 15
2056: PUSH
2057: LD_STRING Omar
2059: PPUSH
2060: LD_INT 0
2062: PPUSH
2063: LD_STRING 
2065: PPUSH
2066: CALL 104 0 3
2070: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , false ,  ) ;
2071: LD_ADDR_EXP 18
2075: PUSH
2076: LD_STRING Kurt
2078: PPUSH
2079: LD_INT 0
2081: PPUSH
2082: LD_STRING 
2084: PPUSH
2085: CALL 104 0 3
2089: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
2090: LD_ADDR_EXP 17
2094: PUSH
2095: LD_STRING Abdul
2097: PPUSH
2098: LD_INT 0
2100: PPUSH
2101: LD_STRING 
2103: PPUSH
2104: CALL 104 0 3
2108: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
2109: LD_VAR 0 1
2113: RET
// export function Action ; var i , un , veh , tmp ; begin
2114: LD_INT 0
2116: PPUSH
2117: PPUSH
2118: PPUSH
2119: PPUSH
2120: PPUSH
// InGameOn ;
2121: CALL_OW 8
// CenterNowOnXY ( 179 , 5 ) ;
2125: LD_INT 179
2127: PPUSH
2128: LD_INT 5
2130: PPUSH
2131: CALL_OW 86
// veh := PrepareTank ( 2 , 2 , ar_light_trike , engine_combustion , control_manual , ar_double_machine_gun , 33 ) ;
2135: LD_ADDR_VAR 0 4
2139: PUSH
2140: LD_INT 2
2142: PPUSH
2143: LD_INT 2
2145: PPUSH
2146: LD_INT 12
2148: PPUSH
2149: LD_INT 1
2151: PPUSH
2152: LD_INT 1
2154: PPUSH
2155: LD_INT 24
2157: PPUSH
2158: LD_INT 33
2160: PPUSH
2161: CALL 167 0 7
2165: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2166: LD_VAR 0 4
2170: PPUSH
2171: LD_INT 2
2173: PPUSH
2174: CALL_OW 233
// PlaceUnitXY ( veh , 178 , 2 , false ) ;
2178: LD_VAR 0 4
2182: PPUSH
2183: LD_INT 178
2185: PPUSH
2186: LD_INT 2
2188: PPUSH
2189: LD_INT 0
2191: PPUSH
2192: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
2196: LD_EXP 8
2200: PPUSH
2201: LD_VAR 0 4
2205: PPUSH
2206: CALL_OW 52
// if Kamil then
2210: LD_EXP 11
2214: IFFALSE 2249
// begin PlaceUnitXY ( Kamil , 207 , 37 , false ) ;
2216: LD_EXP 11
2220: PPUSH
2221: LD_INT 207
2223: PPUSH
2224: LD_INT 37
2226: PPUSH
2227: LD_INT 0
2229: PPUSH
2230: CALL_OW 48
// ComTurnXY ( Kamil , 211 , 38 ) ;
2234: LD_EXP 11
2238: PPUSH
2239: LD_INT 211
2241: PPUSH
2242: LD_INT 38
2244: PPUSH
2245: CALL_OW 118
// end ; if Sophia then
2249: LD_EXP 13
2253: IFFALSE 2288
// begin PlaceUnitXY ( Sophia , 209 , 40 , false ) ;
2255: LD_EXP 13
2259: PPUSH
2260: LD_INT 209
2262: PPUSH
2263: LD_INT 40
2265: PPUSH
2266: LD_INT 0
2268: PPUSH
2269: CALL_OW 48
// ComTurnXY ( Sophia , 211 , 38 ) ;
2273: LD_EXP 13
2277: PPUSH
2278: LD_INT 211
2280: PPUSH
2281: LD_INT 38
2283: PPUSH
2284: CALL_OW 118
// end ; if Givi then
2288: LD_EXP 9
2292: IFFALSE 2327
// begin PlaceUnitXY ( Givi , 201 , 34 , false ) ;
2294: LD_EXP 9
2298: PPUSH
2299: LD_INT 201
2301: PPUSH
2302: LD_INT 34
2304: PPUSH
2305: LD_INT 0
2307: PPUSH
2308: CALL_OW 48
// ComTurnXY ( Givi , 206 , 36 ) ;
2312: LD_EXP 9
2316: PPUSH
2317: LD_INT 206
2319: PPUSH
2320: LD_INT 36
2322: PPUSH
2323: CALL_OW 118
// end ; if Markov then
2327: LD_EXP 14
2331: IFFALSE 2418
// begin veh := PrepareTank ( 2 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_gatling_gun , 80 - 20 * Difficulty ) ;
2333: LD_ADDR_VAR 0 4
2337: PUSH
2338: LD_INT 2
2340: PPUSH
2341: LD_INT 2
2343: PPUSH
2344: LD_INT 13
2346: PPUSH
2347: LD_INT 1
2349: PPUSH
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 25
2355: PPUSH
2356: LD_INT 80
2358: PUSH
2359: LD_INT 20
2361: PUSH
2362: LD_OWVAR 67
2366: MUL
2367: MINUS
2368: PPUSH
2369: CALL 167 0 7
2373: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2374: LD_VAR 0 4
2378: PPUSH
2379: LD_INT 2
2381: PPUSH
2382: CALL_OW 233
// PlaceUnitXY ( veh , 197 , 35 , false ) ;
2386: LD_VAR 0 4
2390: PPUSH
2391: LD_INT 197
2393: PPUSH
2394: LD_INT 35
2396: PPUSH
2397: LD_INT 0
2399: PPUSH
2400: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
2404: LD_EXP 14
2408: PPUSH
2409: LD_VAR 0 4
2413: PPUSH
2414: CALL_OW 52
// end ; tmp := Kaia union heikeSecondSquad ;
2418: LD_ADDR_VAR 0 5
2422: PUSH
2423: LD_EXP 12
2427: PUSH
2428: LD_EXP 20
2432: UNION
2433: ST_TO_ADDR
// for i in tmp do
2434: LD_ADDR_VAR 0 2
2438: PUSH
2439: LD_VAR 0 5
2443: PUSH
2444: FOR_IN
2445: IFFALSE 2479
// begin PlaceUnitXYR ( i , 203 , 41 , 6 , false ) ;
2447: LD_VAR 0 2
2451: PPUSH
2452: LD_INT 203
2454: PPUSH
2455: LD_INT 41
2457: PPUSH
2458: LD_INT 6
2460: PPUSH
2461: LD_INT 0
2463: PPUSH
2464: CALL_OW 50
// ComHold ( i ) ;
2468: LD_VAR 0 2
2472: PPUSH
2473: CALL_OW 140
// end ;
2477: GO 2444
2479: POP
2480: POP
// if not FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 2 ] ] ) then
2481: LD_INT 22
2483: PUSH
2484: LD_INT 2
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: PUSH
2491: LD_INT 25
2493: PUSH
2494: LD_INT 2
2496: PUSH
2497: EMPTY
2498: LIST
2499: LIST
2500: PUSH
2501: EMPTY
2502: LIST
2503: LIST
2504: PPUSH
2505: CALL_OW 69
2509: NOT
2510: IFFALSE 2524
// SetClass ( Heike , 2 ) ;
2512: LD_EXP 8
2516: PPUSH
2517: LD_INT 2
2519: PPUSH
2520: CALL_OW 336
// ComMoveXY ( Heike , 183 , 12 ) ;
2524: LD_EXP 8
2528: PPUSH
2529: LD_INT 183
2531: PPUSH
2532: LD_INT 12
2534: PPUSH
2535: CALL_OW 111
// AddComMoveXY ( Heike , 188 , 20 ) ;
2539: LD_EXP 8
2543: PPUSH
2544: LD_INT 188
2546: PPUSH
2547: LD_INT 20
2549: PPUSH
2550: CALL_OW 171
// AddComMoveXY ( Heike , 191 , 25 ) ;
2554: LD_EXP 8
2558: PPUSH
2559: LD_INT 191
2561: PPUSH
2562: LD_INT 25
2564: PPUSH
2565: CALL_OW 171
// AddComMoveXY ( Heike , 203 , 29 ) ;
2569: LD_EXP 8
2573: PPUSH
2574: LD_INT 203
2576: PPUSH
2577: LD_INT 29
2579: PPUSH
2580: CALL_OW 171
// AddComExitVehicle ( Heike ) ;
2584: LD_EXP 8
2588: PPUSH
2589: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
2593: LD_INT 35
2595: PPUSH
2596: CALL_OW 67
// until not IsInUnit ( Heike ) ;
2600: LD_EXP 8
2604: PPUSH
2605: CALL_OW 310
2609: NOT
2610: IFFALSE 2593
// CenterOnUnits ( Heike ) ;
2612: LD_EXP 8
2616: PPUSH
2617: CALL_OW 85
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff [ Heike , Markov ] ;
2621: LD_ADDR_VAR 0 5
2625: PUSH
2626: LD_INT 22
2628: PUSH
2629: LD_INT 2
2631: PUSH
2632: EMPTY
2633: LIST
2634: LIST
2635: PUSH
2636: LD_INT 21
2638: PUSH
2639: LD_INT 1
2641: PUSH
2642: EMPTY
2643: LIST
2644: LIST
2645: PUSH
2646: EMPTY
2647: LIST
2648: LIST
2649: PPUSH
2650: CALL_OW 69
2654: PUSH
2655: LD_EXP 8
2659: PUSH
2660: LD_EXP 14
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: DIFF
2669: ST_TO_ADDR
// ComTurnUnit ( tmp , Heike ) ;
2670: LD_VAR 0 5
2674: PPUSH
2675: LD_EXP 8
2679: PPUSH
2680: CALL_OW 119
// if Givi then
2684: LD_EXP 9
2688: IFFALSE 2706
// ComTurnUnit ( Heike , Givi ) else
2690: LD_EXP 8
2694: PPUSH
2695: LD_EXP 9
2699: PPUSH
2700: CALL_OW 119
2704: GO 2724
// ComTurnUnit ( Heike , tmp [ 1 ] ) ;
2706: LD_EXP 8
2710: PPUSH
2711: LD_VAR 0 5
2715: PUSH
2716: LD_INT 1
2718: ARRAY
2719: PPUSH
2720: CALL_OW 119
// Say ( Heike , DH-Start-1 ) ;
2724: LD_EXP 8
2728: PPUSH
2729: LD_STRING DH-Start-1
2731: PPUSH
2732: CALL_OW 88
// if Givi then
2736: LD_EXP 9
2740: IFFALSE 2787
// begin Say ( Givi , DG-Start-2 ) ;
2742: LD_EXP 9
2746: PPUSH
2747: LD_STRING DG-Start-2
2749: PPUSH
2750: CALL_OW 88
// if not Mike then
2754: LD_EXP 10
2758: NOT
2759: IFFALSE 2785
// begin Say ( Givi , DG-Start-b-3 ) ;
2761: LD_EXP 9
2765: PPUSH
2766: LD_STRING DG-Start-b-3
2768: PPUSH
2769: CALL_OW 88
// Say ( Heike , DH-Start-b-4 ) ;
2773: LD_EXP 8
2777: PPUSH
2778: LD_STRING DH-Start-b-4
2780: PPUSH
2781: CALL_OW 88
// end ; end else
2785: GO 2852
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-Start-a-2 ) then
2787: LD_EXP 20
2791: PPUSH
2792: LD_INT 26
2794: PUSH
2795: LD_INT 1
2797: PUSH
2798: EMPTY
2799: LIST
2800: LIST
2801: PPUSH
2802: CALL_OW 72
2806: PUSH
2807: LD_INT 1
2809: ARRAY
2810: PPUSH
2811: LD_STRING DArm-Start-a-2
2813: PPUSH
2814: CALL_OW 88
2818: NOT
2819: IFFALSE 2852
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-Start-a-2 ) ;
2821: LD_EXP 20
2825: PPUSH
2826: LD_INT 26
2828: PUSH
2829: LD_INT 2
2831: PUSH
2832: EMPTY
2833: LIST
2834: LIST
2835: PPUSH
2836: CALL_OW 72
2840: PUSH
2841: LD_INT 1
2843: ARRAY
2844: PPUSH
2845: LD_STRING DArf-Start-a-2
2847: PPUSH
2848: CALL_OW 88
// ComTurnXY ( Heike , 211 , 38 ) ;
2852: LD_EXP 8
2856: PPUSH
2857: LD_INT 211
2859: PPUSH
2860: LD_INT 38
2862: PPUSH
2863: CALL_OW 118
// wait ( 0 0$1 ) ;
2867: LD_INT 35
2869: PPUSH
2870: CALL_OW 67
// Say ( Heike , DH-Start-3 ) ;
2874: LD_EXP 8
2878: PPUSH
2879: LD_STRING DH-Start-3
2881: PPUSH
2882: CALL_OW 88
// Say ( Heike , DH-Start-4 ) ;
2886: LD_EXP 8
2890: PPUSH
2891: LD_STRING DH-Start-4
2893: PPUSH
2894: CALL_OW 88
// InGameOff ;
2898: CALL_OW 9
// ChangeMissionObjectives ( Prepare ) ;
2902: LD_STRING Prepare
2904: PPUSH
2905: CALL_OW 337
// wait ( 0 0$10 ) ;
2909: LD_INT 350
2911: PPUSH
2912: CALL_OW 67
// if not Aviradze then
2916: LD_EXP 19
2920: NOT
2921: IFFALSE 2925
// exit ;
2923: GO 3117
// SetDir ( Aviradze , 4 ) ;
2925: LD_EXP 19
2929: PPUSH
2930: LD_INT 4
2932: PPUSH
2933: CALL_OW 233
// PlaceUnitXY ( Aviradze , 225 , 33 , false ) ;
2937: LD_EXP 19
2941: PPUSH
2942: LD_INT 225
2944: PPUSH
2945: LD_INT 33
2947: PPUSH
2948: LD_INT 0
2950: PPUSH
2951: CALL_OW 48
// for i := 1 to 2 do
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: DOUBLE
2961: LD_INT 1
2963: DEC
2964: ST_TO_ADDR
2965: LD_INT 2
2967: PUSH
2968: FOR_TO
2969: IFFALSE 3100
// begin uc_side := 2 ;
2971: LD_ADDR_OWVAR 20
2975: PUSH
2976: LD_INT 2
2978: ST_TO_ADDR
// uc_nation := 0 ;
2979: LD_ADDR_OWVAR 21
2983: PUSH
2984: LD_INT 0
2986: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
2987: LD_INT 0
2989: PPUSH
2990: LD_INT 12
2992: PPUSH
2993: LD_INT 1
2995: PPUSH
2996: CALL_OW 380
// hc_gallery :=  ;
3000: LD_ADDR_OWVAR 33
3004: PUSH
3005: LD_STRING 
3007: ST_TO_ADDR
// hc_name := [ Artudito , Textur ] [ i ] ;
3008: LD_ADDR_OWVAR 26
3012: PUSH
3013: LD_STRING Artudito
3015: PUSH
3016: LD_STRING Textur
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PUSH
3023: LD_VAR 0 2
3027: ARRAY
3028: ST_TO_ADDR
// un := CreateHuman ;
3029: LD_ADDR_VAR 0 3
3033: PUSH
3034: CALL_OW 44
3038: ST_TO_ADDR
// PlaceUnitXY ( un , [ 224 , 226 ] [ i ] , [ 31 , 35 ] [ i ] , false ) ;
3039: LD_VAR 0 3
3043: PPUSH
3044: LD_INT 224
3046: PUSH
3047: LD_INT 226
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: PUSH
3054: LD_VAR 0 2
3058: ARRAY
3059: PPUSH
3060: LD_INT 31
3062: PUSH
3063: LD_INT 35
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: PUSH
3070: LD_VAR 0 2
3074: ARRAY
3075: PPUSH
3076: LD_INT 0
3078: PPUSH
3079: CALL_OW 48
// ComMoveXY ( un , 215 , 36 ) ;
3083: LD_VAR 0 3
3087: PPUSH
3088: LD_INT 215
3090: PPUSH
3091: LD_INT 36
3093: PPUSH
3094: CALL_OW 111
// end ;
3098: GO 2968
3100: POP
3101: POP
// ComMoveXY ( Aviradze , 215 , 36 ) ;
3102: LD_EXP 19
3106: PPUSH
3107: LD_INT 215
3109: PPUSH
3110: LD_INT 36
3112: PPUSH
3113: CALL_OW 111
// end ;
3117: LD_VAR 0 1
3121: RET
// every 0 0$2 trigger baseConstructed do
3122: LD_EXP 3
3126: IFFALSE 3315
3128: GO 3130
3130: DISABLE
// begin DialogueOn ;
3131: CALL_OW 6
// Say ( Heike , DH-base-1 ) ;
3135: LD_EXP 8
3139: PPUSH
3140: LD_STRING DH-base-1
3142: PPUSH
3143: CALL_OW 88
// if Markov then
3147: LD_EXP 14
3151: IFFALSE 3203
// begin Say ( Markov , DMar-base-2 ) ;
3153: LD_EXP 14
3157: PPUSH
3158: LD_STRING DMar-base-2
3160: PPUSH
3161: CALL_OW 88
// Say ( Markov , DMar-base-3 ) ;
3165: LD_EXP 14
3169: PPUSH
3170: LD_STRING DMar-base-3
3172: PPUSH
3173: CALL_OW 88
// Say ( Heike , DH-base-4 ) ;
3177: LD_EXP 8
3181: PPUSH
3182: LD_STRING DH-base-4
3184: PPUSH
3185: CALL_OW 88
// Say ( Markov , DMar-base-5 ) ;
3189: LD_EXP 14
3193: PPUSH
3194: LD_STRING DMar-base-5
3196: PPUSH
3197: CALL_OW 88
// end else
3201: GO 3280
// begin if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-base-a-2 ) then
3203: LD_EXP 20
3207: PPUSH
3208: LD_INT 26
3210: PUSH
3211: LD_INT 1
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: PPUSH
3218: CALL_OW 72
3222: PUSH
3223: LD_INT 1
3225: ARRAY
3226: PPUSH
3227: LD_STRING DArm-base-a-2
3229: PPUSH
3230: CALL_OW 88
3234: NOT
3235: IFFALSE 3268
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-base-a-2 ) ;
3237: LD_EXP 20
3241: PPUSH
3242: LD_INT 26
3244: PUSH
3245: LD_INT 2
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: PPUSH
3252: CALL_OW 72
3256: PUSH
3257: LD_INT 1
3259: ARRAY
3260: PPUSH
3261: LD_STRING DArf-base-a-2
3263: PPUSH
3264: CALL_OW 88
// Say ( Heike , DH-base-a-3 ) ;
3268: LD_EXP 8
3272: PPUSH
3273: LD_STRING DH-base-a-3
3275: PPUSH
3276: CALL_OW 88
// end ; Say ( Aviradze , DA-base-6 ) ;
3280: LD_EXP 19
3284: PPUSH
3285: LD_STRING DA-base-6
3287: PPUSH
3288: CALL_OW 88
// Say ( Aviradze , DA-base-7 ) ;
3292: LD_EXP 19
3296: PPUSH
3297: LD_STRING DA-base-7
3299: PPUSH
3300: CALL_OW 88
// DialogueOff ;
3304: CALL_OW 7
// ChangeMissionObjectives ( Flamethrower ) ;
3308: LD_STRING Flamethrower
3310: PPUSH
3311: CALL_OW 337
// end ;
3315: END
// every 0 0$2 trigger labConstructed and IsOk ( Aviradze ) do
3316: LD_EXP 4
3320: PUSH
3321: LD_EXP 19
3325: PPUSH
3326: CALL_OW 302
3330: AND
3331: IFFALSE 3380
3333: GO 3335
3335: DISABLE
// begin DialogueOn ;
3336: CALL_OW 6
// Say ( Aviradze , DA-lab-1 ) ;
3340: LD_EXP 19
3344: PPUSH
3345: LD_STRING DA-lab-1
3347: PPUSH
3348: CALL_OW 88
// Say ( Aviradze , DA-lab-2 ) ;
3352: LD_EXP 19
3356: PPUSH
3357: LD_STRING DA-lab-2
3359: PPUSH
3360: CALL_OW 88
// Say ( Heike , DH-lab-3 ) ;
3364: LD_EXP 8
3368: PPUSH
3369: LD_STRING DH-lab-3
3371: PPUSH
3372: CALL_OW 88
// DialogueOff ;
3376: CALL_OW 7
// end ;
3380: END
// every 0 0$2 trigger GetTech ( tech_HidCam , 2 ) = state_researched do var i ;
3381: LD_INT 17
3383: PPUSH
3384: LD_INT 2
3386: PPUSH
3387: CALL_OW 321
3391: PUSH
3392: LD_INT 2
3394: EQUAL
3395: IFFALSE 3527
3397: GO 3399
3399: DISABLE
3400: LD_INT 0
3402: PPUSH
// begin DialogueOn ;
3403: CALL_OW 6
// Say ( Aviradze , DA-Cam-1 ) ;
3407: LD_EXP 19
3411: PPUSH
3412: LD_STRING DA-Cam-1
3414: PPUSH
3415: CALL_OW 88
// Say ( Aviradze , DA-Cam-2 ) ;
3419: LD_EXP 19
3423: PPUSH
3424: LD_STRING DA-Cam-2
3426: PPUSH
3427: CALL_OW 88
// Say ( Aviradze , DA-Cam-3 ) ;
3431: LD_EXP 19
3435: PPUSH
3436: LD_STRING DA-Cam-3
3438: PPUSH
3439: CALL_OW 88
// Say ( Heike , DH-Cam-4 ) ;
3443: LD_EXP 8
3447: PPUSH
3448: LD_STRING DH-Cam-4
3450: PPUSH
3451: CALL_OW 88
// Say ( Kaia , DK-Cam-5 ) ;
3455: LD_EXP 12
3459: PPUSH
3460: LD_STRING DK-Cam-5
3462: PPUSH
3463: CALL_OW 88
// Say ( Kaia , DK-Cam-6 ) ;
3467: LD_EXP 12
3471: PPUSH
3472: LD_STRING DK-Cam-6
3474: PPUSH
3475: CALL_OW 88
// DialogueOff ;
3479: CALL_OW 7
// Query ( Camera ) ;
3483: LD_STRING Camera
3485: PPUSH
3486: CALL_OW 97
// hiddenCameraAllowed := true ;
3490: LD_ADDR_EXP 5
3494: PUSH
3495: LD_INT 1
3497: ST_TO_ADDR
// for i in camAreas do
3498: LD_ADDR_VAR 0 1
3502: PUSH
3503: LD_EXP 7
3507: PUSH
3508: FOR_IN
3509: IFFALSE 3525
// SetAreaMapShow ( i , 1 ) ;
3511: LD_VAR 0 1
3515: PPUSH
3516: LD_INT 1
3518: PPUSH
3519: CALL_OW 424
3523: GO 3508
3525: POP
3526: POP
// end ;
3527: PPOPN 1
3529: END
// every 0 0$1 trigger cameraCounter = 0 and hiddenCameraAllowed do var i ;
3530: LD_EXP 6
3534: PUSH
3535: LD_INT 0
3537: EQUAL
3538: PUSH
3539: LD_EXP 5
3543: AND
3544: IFFALSE 3635
3546: GO 3548
3548: DISABLE
3549: LD_INT 0
3551: PPUSH
// begin stop_talking := true ;
3552: LD_ADDR_OWVAR 56
3556: PUSH
3557: LD_INT 1
3559: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) do
3560: LD_ADDR_VAR 0 1
3564: PUSH
3565: LD_INT 22
3567: PUSH
3568: LD_INT 2
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: PUSH
3575: LD_INT 21
3577: PUSH
3578: LD_INT 1
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: PUSH
3585: LD_INT 23
3587: PUSH
3588: LD_INT 2
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: PPUSH
3600: CALL_OW 69
3604: PUSH
3605: FOR_IN
3606: IFFALSE 3625
// AddExperience ( i , 2 , 450 ) ;
3608: LD_VAR 0 1
3612: PPUSH
3613: LD_INT 2
3615: PPUSH
3616: LD_INT 450
3618: PPUSH
3619: CALL_OW 492
3623: GO 3605
3625: POP
3626: POP
// stop_talking := false ;
3627: LD_ADDR_OWVAR 56
3631: PUSH
3632: LD_INT 0
3634: ST_TO_ADDR
// end ; end_of_file
3635: PPOPN 1
3637: END
// on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 2 then
3638: LD_VAR 0 1
3642: PPUSH
3643: CALL_OW 266
3647: PUSH
3648: LD_INT 0
3650: EQUAL
3651: PUSH
3652: LD_VAR 0 1
3656: PPUSH
3657: CALL_OW 255
3661: PUSH
3662: LD_INT 2
3664: EQUAL
3665: AND
3666: IFFALSE 3676
// baseConstructed := true ;
3668: LD_ADDR_EXP 3
3672: PUSH
3673: LD_INT 1
3675: ST_TO_ADDR
// if GetBType ( b ) = b_lab and GetSide ( b ) = 2 then
3676: LD_VAR 0 1
3680: PPUSH
3681: CALL_OW 266
3685: PUSH
3686: LD_INT 6
3688: EQUAL
3689: PUSH
3690: LD_VAR 0 1
3694: PPUSH
3695: CALL_OW 255
3699: PUSH
3700: LD_INT 2
3702: EQUAL
3703: AND
3704: IFFALSE 3714
// labConstructed := true ;
3706: LD_ADDR_EXP 4
3710: PUSH
3711: LD_INT 1
3713: ST_TO_ADDR
// end ;
3714: PPOPN 1
3716: END
// on HiddenCameraPlaced ( side , un , x , y ) do var i ;
3717: LD_INT 0
3719: PPUSH
// begin if not camAreas or not hiddenCameraAllowed then
3720: LD_EXP 7
3724: NOT
3725: PUSH
3726: LD_EXP 5
3730: NOT
3731: OR
3732: IFFALSE 3736
// exit ;
3734: GO 3818
// for i in camAreas do
3736: LD_ADDR_VAR 0 5
3740: PUSH
3741: LD_EXP 7
3745: PUSH
3746: FOR_IN
3747: IFFALSE 3816
// if InArea ( x , y , i ) then
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_VAR 0 4
3758: PPUSH
3759: LD_VAR 0 5
3763: PPUSH
3764: CALL_OW 309
3768: IFFALSE 3814
// begin SetAreaMapShow ( i , 0 ) ;
3770: LD_VAR 0 5
3774: PPUSH
3775: LD_INT 0
3777: PPUSH
3778: CALL_OW 424
// cameraCounter := cameraCounter - 1 ;
3782: LD_ADDR_EXP 6
3786: PUSH
3787: LD_EXP 6
3791: PUSH
3792: LD_INT 1
3794: MINUS
3795: ST_TO_ADDR
// camAreas := camAreas diff i ;
3796: LD_ADDR_EXP 7
3800: PUSH
3801: LD_EXP 7
3805: PUSH
3806: LD_VAR 0 5
3810: DIFF
3811: ST_TO_ADDR
// break ;
3812: GO 3816
// end ;
3814: GO 3746
3816: POP
3817: POP
// end ;
3818: PPOPN 5
3820: END
