// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 17 0 0
// PrepareArabian ;
   8: CALL 1787 0 0
// Action ;
  12: CALL 2196 0 0
// end ;
  16: END
// export debug , prefix , baseConstructed , labConstructed , hiddenCameraAllowed , camAreas ; function Init ; begin
  17: LD_INT 0
  19: PPUSH
// debug := true ;
  20: LD_ADDR_EXP 1
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// prefix := 03_ ;
  28: LD_ADDR_EXP 2
  32: PUSH
  33: LD_STRING 03_
  35: ST_TO_ADDR
// baseConstructed := false ;
  36: LD_ADDR_EXP 3
  40: PUSH
  41: LD_INT 0
  43: ST_TO_ADDR
// labConstructed := false ;
  44: LD_ADDR_EXP 4
  48: PUSH
  49: LD_INT 0
  51: ST_TO_ADDR
// hiddenCameraAllowed := false ;
  52: LD_ADDR_EXP 5
  56: PUSH
  57: LD_INT 0
  59: ST_TO_ADDR
// camAreas := [ camArea1 , camArea2 , camArea3 , camArea4 , camArea5 , camArea6 ] ;
  60: LD_ADDR_EXP 6
  64: PUSH
  65: LD_INT 3
  67: PUSH
  68: LD_INT 4
  70: PUSH
  71: LD_INT 5
  73: PUSH
  74: LD_INT 6
  76: PUSH
  77: LD_INT 7
  79: PUSH
  80: LD_INT 8
  82: PUSH
  83: EMPTY
  84: LIST
  85: LIST
  86: LIST
  87: LIST
  88: LIST
  89: LIST
  90: ST_TO_ADDR
// end ; end_of_file
  91: LD_VAR 0 1
  95: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
  96: LD_INT 0
  98: PPUSH
  99: PPUSH
// if exist_mode then
 100: LD_VAR 0 2
 104: IFFALSE 129
// unit := CreateCharacter ( prefix & ident ) else
 106: LD_ADDR_VAR 0 5
 110: PUSH
 111: LD_VAR 0 3
 115: PUSH
 116: LD_VAR 0 1
 120: STR
 121: PPUSH
 122: CALL_OW 34
 126: ST_TO_ADDR
 127: GO 144
// unit := NewCharacter ( ident ) ;
 129: LD_ADDR_VAR 0 5
 133: PUSH
 134: LD_VAR 0 1
 138: PPUSH
 139: CALL_OW 25
 143: ST_TO_ADDR
// result := unit ;
 144: LD_ADDR_VAR 0 4
 148: PUSH
 149: LD_VAR 0 5
 153: ST_TO_ADDR
// end ;
 154: LD_VAR 0 4
 158: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 159: LD_INT 0
 161: PPUSH
// uc_side := side ;
 162: LD_ADDR_OWVAR 20
 166: PUSH
 167: LD_VAR 0 1
 171: ST_TO_ADDR
// uc_nation := nation ;
 172: LD_ADDR_OWVAR 21
 176: PUSH
 177: LD_VAR 0 2
 181: ST_TO_ADDR
// vc_chassis := chassis ;
 182: LD_ADDR_OWVAR 37
 186: PUSH
 187: LD_VAR 0 3
 191: ST_TO_ADDR
// vc_engine := engine ;
 192: LD_ADDR_OWVAR 39
 196: PUSH
 197: LD_VAR 0 4
 201: ST_TO_ADDR
// vc_control := control ;
 202: LD_ADDR_OWVAR 38
 206: PUSH
 207: LD_VAR 0 5
 211: ST_TO_ADDR
// vc_weapon := weapon ;
 212: LD_ADDR_OWVAR 40
 216: PUSH
 217: LD_VAR 0 6
 221: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 222: LD_ADDR_OWVAR 41
 226: PUSH
 227: LD_VAR 0 7
 231: ST_TO_ADDR
// result := CreateVehicle ;
 232: LD_ADDR_VAR 0 8
 236: PUSH
 237: CALL_OW 45
 241: ST_TO_ADDR
// end ;
 242: LD_VAR 0 8
 246: RET
// export function SayX ( units , ident ) ; var i ; begin
 247: LD_INT 0
 249: PPUSH
 250: PPUSH
// result := false ;
 251: LD_ADDR_VAR 0 3
 255: PUSH
 256: LD_INT 0
 258: ST_TO_ADDR
// if not units then
 259: LD_VAR 0 1
 263: NOT
 264: IFFALSE 268
// exit ;
 266: GO 322
// for i in units do
 268: LD_ADDR_VAR 0 4
 272: PUSH
 273: LD_VAR 0 1
 277: PUSH
 278: FOR_IN
 279: IFFALSE 320
// if IsOk ( i ) then
 281: LD_VAR 0 4
 285: PPUSH
 286: CALL_OW 302
 290: IFFALSE 318
// begin Say ( i , ident ) ;
 292: LD_VAR 0 4
 296: PPUSH
 297: LD_VAR 0 2
 301: PPUSH
 302: CALL_OW 88
// result := i ;
 306: LD_ADDR_VAR 0 3
 310: PUSH
 311: LD_VAR 0 4
 315: ST_TO_ADDR
// break ;
 316: GO 320
// end ;
 318: GO 278
 320: POP
 321: POP
// end ;
 322: LD_VAR 0 3
 326: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 327: LD_INT 0
 329: PPUSH
 330: PPUSH
// InitUc ;
 331: CALL_OW 18
// InitHc ;
 335: CALL_OW 19
// uc_side := 0 ;
 339: LD_ADDR_OWVAR 20
 343: PUSH
 344: LD_INT 0
 346: ST_TO_ADDR
// uc_nation := 0 ;
 347: LD_ADDR_OWVAR 21
 351: PUSH
 352: LD_INT 0
 354: ST_TO_ADDR
// for i = 1 to amount do
 355: LD_ADDR_VAR 0 4
 359: PUSH
 360: DOUBLE
 361: LD_INT 1
 363: DEC
 364: ST_TO_ADDR
 365: LD_VAR 0 2
 369: PUSH
 370: FOR_TO
 371: IFFALSE 453
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 373: LD_ADDR_OWVAR 29
 377: PUSH
 378: LD_INT 9
 380: PPUSH
 381: LD_INT 12
 383: PPUSH
 384: CALL_OW 12
 388: PUSH
 389: LD_INT 9
 391: PPUSH
 392: LD_INT 12
 394: PPUSH
 395: CALL_OW 12
 399: PUSH
 400: EMPTY
 401: LIST
 402: LIST
 403: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 404: LD_ADDR_OWVAR 35
 408: PUSH
 409: LD_INT 1
 411: NEG
 412: PPUSH
 413: LD_INT 1
 415: PPUSH
 416: CALL_OW 12
 420: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 421: LD_INT 0
 423: PPUSH
 424: LD_INT 12
 426: PPUSH
 427: LD_INT 1
 429: PPUSH
 430: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 434: CALL_OW 44
 438: PPUSH
 439: LD_VAR 0 1
 443: PPUSH
 444: LD_INT 0
 446: PPUSH
 447: CALL_OW 49
// end ;
 451: GO 370
 453: POP
 454: POP
// InitHc ;
 455: CALL_OW 19
// end ;
 459: LD_VAR 0 3
 463: RET
// export function PrepareNature ( forest ) ; var i ; begin
 464: LD_INT 0
 466: PPUSH
 467: PPUSH
// SpawnApeman ( forest , [ 6 , 5 , 4 ] [ Difficulty ] ) ;
 468: LD_VAR 0 1
 472: PPUSH
 473: LD_INT 6
 475: PUSH
 476: LD_INT 5
 478: PUSH
 479: LD_INT 4
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: LIST
 486: PUSH
 487: LD_OWVAR 67
 491: ARRAY
 492: PPUSH
 493: CALL 327 0 2
// for i := 1 to 3 do
 497: LD_ADDR_VAR 0 3
 501: PUSH
 502: DOUBLE
 503: LD_INT 1
 505: DEC
 506: ST_TO_ADDR
 507: LD_INT 3
 509: PUSH
 510: FOR_TO
 511: IFFALSE 548
// begin hc_class := 21 ;
 513: LD_ADDR_OWVAR 28
 517: PUSH
 518: LD_INT 21
 520: ST_TO_ADDR
// hc_gallery :=  ;
 521: LD_ADDR_OWVAR 33
 525: PUSH
 526: LD_STRING 
 528: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 529: CALL_OW 44
 533: PPUSH
 534: LD_VAR 0 1
 538: PPUSH
 539: LD_INT 0
 541: PPUSH
 542: CALL_OW 49
// end ;
 546: GO 510
 548: POP
 549: POP
// for i := 1 to 2 do
 550: LD_ADDR_VAR 0 3
 554: PUSH
 555: DOUBLE
 556: LD_INT 1
 558: DEC
 559: ST_TO_ADDR
 560: LD_INT 2
 562: PUSH
 563: FOR_TO
 564: IFFALSE 601
// begin hc_class := 18 ;
 566: LD_ADDR_OWVAR 28
 570: PUSH
 571: LD_INT 18
 573: ST_TO_ADDR
// hc_gallery :=  ;
 574: LD_ADDR_OWVAR 33
 578: PUSH
 579: LD_STRING 
 581: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 582: CALL_OW 44
 586: PPUSH
 587: LD_VAR 0 1
 591: PPUSH
 592: LD_INT 0
 594: PPUSH
 595: CALL_OW 49
// end ;
 599: GO 563
 601: POP
 602: POP
// for i := 1 to 2 do
 603: LD_ADDR_VAR 0 3
 607: PUSH
 608: DOUBLE
 609: LD_INT 1
 611: DEC
 612: ST_TO_ADDR
 613: LD_INT 2
 615: PUSH
 616: FOR_TO
 617: IFFALSE 654
// begin hc_class := 13 ;
 619: LD_ADDR_OWVAR 28
 623: PUSH
 624: LD_INT 13
 626: ST_TO_ADDR
// hc_gallery :=  ;
 627: LD_ADDR_OWVAR 33
 631: PUSH
 632: LD_STRING 
 634: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 635: CALL_OW 44
 639: PPUSH
 640: LD_VAR 0 1
 644: PPUSH
 645: LD_INT 0
 647: PPUSH
 648: CALL_OW 49
// end ;
 652: GO 616
 654: POP
 655: POP
// end ;
 656: LD_VAR 0 2
 660: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 661: LD_INT 0
 663: PPUSH
 664: PPUSH
 665: PPUSH
// if not observer or not unit then
 666: LD_VAR 0 1
 670: NOT
 671: PUSH
 672: LD_VAR 0 2
 676: NOT
 677: OR
 678: IFFALSE 682
// exit ;
 680: GO 730
// if not See ( GetSide ( observer ) , unit ) then
 682: LD_VAR 0 1
 686: PPUSH
 687: CALL_OW 255
 691: PPUSH
 692: LD_VAR 0 2
 696: PPUSH
 697: CALL_OW 292
 701: NOT
 702: IFFALSE 706
// exit ;
 704: GO 730
// result := GetDistUnits ( observer , unit ) < 12 ;
 706: LD_ADDR_VAR 0 3
 710: PUSH
 711: LD_VAR 0 1
 715: PPUSH
 716: LD_VAR 0 2
 720: PPUSH
 721: CALL_OW 296
 725: PUSH
 726: LD_INT 12
 728: LESS
 729: ST_TO_ADDR
// end ;
 730: LD_VAR 0 3
 734: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 735: LD_INT 0
 737: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 738: LD_VAR 0 2
 742: PUSH
 743: LD_INT 1
 745: ARRAY
 746: PPUSH
 747: LD_VAR 0 2
 751: PUSH
 752: LD_INT 2
 754: ARRAY
 755: PPUSH
 756: CALL_OW 488
 760: PUSH
 761: LD_VAR 0 2
 765: PUSH
 766: LD_INT 1
 768: ARRAY
 769: PPUSH
 770: LD_VAR 0 2
 774: PUSH
 775: LD_INT 2
 777: ARRAY
 778: PPUSH
 779: CALL_OW 428
 783: PUSH
 784: LD_INT 0
 786: EQUAL
 787: AND
 788: IFFALSE 822
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 790: LD_VAR 0 1
 794: PPUSH
 795: LD_VAR 0 2
 799: PUSH
 800: LD_INT 1
 802: ARRAY
 803: PPUSH
 804: LD_VAR 0 2
 808: PUSH
 809: LD_INT 2
 811: ARRAY
 812: PPUSH
 813: LD_VAR 0 3
 817: PPUSH
 818: CALL_OW 48
// end ;
 822: LD_VAR 0 4
 826: RET
// export function Video ( mode ) ; begin
 827: LD_INT 0
 829: PPUSH
// ingame_video = mode ;
 830: LD_ADDR_OWVAR 52
 834: PUSH
 835: LD_VAR 0 1
 839: ST_TO_ADDR
// interface_hidden = mode ;
 840: LD_ADDR_OWVAR 54
 844: PUSH
 845: LD_VAR 0 1
 849: ST_TO_ADDR
// end ;
 850: LD_VAR 0 2
 854: RET
// export function ReverseArray ( array ) ; var i ; begin
 855: LD_INT 0
 857: PPUSH
 858: PPUSH
// if not array then
 859: LD_VAR 0 1
 863: NOT
 864: IFFALSE 868
// exit ;
 866: GO 926
// result := [ ] ;
 868: LD_ADDR_VAR 0 2
 872: PUSH
 873: EMPTY
 874: ST_TO_ADDR
// for i := 1 to array do
 875: LD_ADDR_VAR 0 3
 879: PUSH
 880: DOUBLE
 881: LD_INT 1
 883: DEC
 884: ST_TO_ADDR
 885: LD_VAR 0 1
 889: PUSH
 890: FOR_TO
 891: IFFALSE 924
// result := Insert ( result , 1 , array [ i ] ) ;
 893: LD_ADDR_VAR 0 2
 897: PUSH
 898: LD_VAR 0 2
 902: PPUSH
 903: LD_INT 1
 905: PPUSH
 906: LD_VAR 0 1
 910: PUSH
 911: LD_VAR 0 3
 915: ARRAY
 916: PPUSH
 917: CALL_OW 2
 921: ST_TO_ADDR
 922: GO 890
 924: POP
 925: POP
// end ;
 926: LD_VAR 0 2
 930: RET
// export function ComExit ( unit ) ; begin
 931: LD_INT 0
 933: PPUSH
// result := IsInUnit ( unit ) ;
 934: LD_ADDR_VAR 0 2
 938: PUSH
 939: LD_VAR 0 1
 943: PPUSH
 944: CALL_OW 310
 948: ST_TO_ADDR
// if not result then
 949: LD_VAR 0 2
 953: NOT
 954: IFFALSE 958
// exit ;
 956: GO 993
// if GetType ( result ) = unit_vehicle then
 958: LD_VAR 0 2
 962: PPUSH
 963: CALL_OW 247
 967: PUSH
 968: LD_INT 2
 970: EQUAL
 971: IFFALSE 984
// ComExitVehicle ( unit ) else
 973: LD_VAR 0 1
 977: PPUSH
 978: CALL_OW 121
 982: GO 993
// ComExitBuilding ( unit ) ;
 984: LD_VAR 0 1
 988: PPUSH
 989: CALL_OW 122
// end ;
 993: LD_VAR 0 2
 997: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
 998: LD_INT 0
1000: PPUSH
1001: PPUSH
// if not side or not nation then
1002: LD_VAR 0 1
1006: NOT
1007: PUSH
1008: LD_VAR 0 2
1012: NOT
1013: OR
1014: IFFALSE 1018
// exit ;
1016: GO 1782
// case nation of nation_american :
1018: LD_VAR 0 2
1022: PUSH
1023: LD_INT 1
1025: DOUBLE
1026: EQUAL
1027: IFTRUE 1031
1029: GO 1245
1031: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1032: LD_ADDR_VAR 0 4
1036: PUSH
1037: LD_INT 35
1039: PUSH
1040: LD_INT 45
1042: PUSH
1043: LD_INT 46
1045: PUSH
1046: LD_INT 47
1048: PUSH
1049: LD_INT 82
1051: PUSH
1052: LD_INT 83
1054: PUSH
1055: LD_INT 84
1057: PUSH
1058: LD_INT 85
1060: PUSH
1061: LD_INT 86
1063: PUSH
1064: LD_INT 1
1066: PUSH
1067: LD_INT 2
1069: PUSH
1070: LD_INT 6
1072: PUSH
1073: LD_INT 15
1075: PUSH
1076: LD_INT 16
1078: PUSH
1079: LD_INT 7
1081: PUSH
1082: LD_INT 12
1084: PUSH
1085: LD_INT 13
1087: PUSH
1088: LD_INT 10
1090: PUSH
1091: LD_INT 14
1093: PUSH
1094: LD_INT 20
1096: PUSH
1097: LD_INT 21
1099: PUSH
1100: LD_INT 22
1102: PUSH
1103: LD_INT 25
1105: PUSH
1106: LD_INT 32
1108: PUSH
1109: LD_INT 27
1111: PUSH
1112: LD_INT 36
1114: PUSH
1115: LD_INT 69
1117: PUSH
1118: LD_INT 39
1120: PUSH
1121: LD_INT 34
1123: PUSH
1124: LD_INT 40
1126: PUSH
1127: LD_INT 48
1129: PUSH
1130: LD_INT 49
1132: PUSH
1133: LD_INT 50
1135: PUSH
1136: LD_INT 51
1138: PUSH
1139: LD_INT 52
1141: PUSH
1142: LD_INT 53
1144: PUSH
1145: LD_INT 54
1147: PUSH
1148: LD_INT 55
1150: PUSH
1151: LD_INT 56
1153: PUSH
1154: LD_INT 57
1156: PUSH
1157: LD_INT 58
1159: PUSH
1160: LD_INT 59
1162: PUSH
1163: LD_INT 60
1165: PUSH
1166: LD_INT 61
1168: PUSH
1169: LD_INT 62
1171: PUSH
1172: LD_INT 80
1174: PUSH
1175: LD_INT 82
1177: PUSH
1178: LD_INT 83
1180: PUSH
1181: LD_INT 84
1183: PUSH
1184: LD_INT 85
1186: PUSH
1187: LD_INT 86
1189: PUSH
1190: EMPTY
1191: LIST
1192: LIST
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: ST_TO_ADDR
1243: GO 1706
1245: LD_INT 2
1247: DOUBLE
1248: EQUAL
1249: IFTRUE 1253
1251: GO 1475
1253: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1254: LD_ADDR_VAR 0 4
1258: PUSH
1259: LD_INT 35
1261: PUSH
1262: LD_INT 45
1264: PUSH
1265: LD_INT 46
1267: PUSH
1268: LD_INT 47
1270: PUSH
1271: LD_INT 82
1273: PUSH
1274: LD_INT 83
1276: PUSH
1277: LD_INT 84
1279: PUSH
1280: LD_INT 85
1282: PUSH
1283: LD_INT 87
1285: PUSH
1286: LD_INT 70
1288: PUSH
1289: LD_INT 1
1291: PUSH
1292: LD_INT 11
1294: PUSH
1295: LD_INT 3
1297: PUSH
1298: LD_INT 4
1300: PUSH
1301: LD_INT 5
1303: PUSH
1304: LD_INT 6
1306: PUSH
1307: LD_INT 15
1309: PUSH
1310: LD_INT 18
1312: PUSH
1313: LD_INT 7
1315: PUSH
1316: LD_INT 17
1318: PUSH
1319: LD_INT 8
1321: PUSH
1322: LD_INT 20
1324: PUSH
1325: LD_INT 21
1327: PUSH
1328: LD_INT 22
1330: PUSH
1331: LD_INT 72
1333: PUSH
1334: LD_INT 26
1336: PUSH
1337: LD_INT 69
1339: PUSH
1340: LD_INT 39
1342: PUSH
1343: LD_INT 40
1345: PUSH
1346: LD_INT 41
1348: PUSH
1349: LD_INT 42
1351: PUSH
1352: LD_INT 43
1354: PUSH
1355: LD_INT 48
1357: PUSH
1358: LD_INT 49
1360: PUSH
1361: LD_INT 50
1363: PUSH
1364: LD_INT 51
1366: PUSH
1367: LD_INT 52
1369: PUSH
1370: LD_INT 53
1372: PUSH
1373: LD_INT 54
1375: PUSH
1376: LD_INT 55
1378: PUSH
1379: LD_INT 56
1381: PUSH
1382: LD_INT 60
1384: PUSH
1385: LD_INT 61
1387: PUSH
1388: LD_INT 62
1390: PUSH
1391: LD_INT 66
1393: PUSH
1394: LD_INT 67
1396: PUSH
1397: LD_INT 68
1399: PUSH
1400: LD_INT 81
1402: PUSH
1403: LD_INT 82
1405: PUSH
1406: LD_INT 83
1408: PUSH
1409: LD_INT 84
1411: PUSH
1412: LD_INT 85
1414: PUSH
1415: LD_INT 87
1417: PUSH
1418: EMPTY
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: ST_TO_ADDR
1473: GO 1706
1475: LD_INT 3
1477: DOUBLE
1478: EQUAL
1479: IFTRUE 1483
1481: GO 1705
1483: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1484: LD_ADDR_VAR 0 4
1488: PUSH
1489: LD_INT 46
1491: PUSH
1492: LD_INT 47
1494: PUSH
1495: LD_INT 1
1497: PUSH
1498: LD_INT 2
1500: PUSH
1501: LD_INT 82
1503: PUSH
1504: LD_INT 83
1506: PUSH
1507: LD_INT 84
1509: PUSH
1510: LD_INT 85
1512: PUSH
1513: LD_INT 86
1515: PUSH
1516: LD_INT 11
1518: PUSH
1519: LD_INT 9
1521: PUSH
1522: LD_INT 20
1524: PUSH
1525: LD_INT 19
1527: PUSH
1528: LD_INT 21
1530: PUSH
1531: LD_INT 24
1533: PUSH
1534: LD_INT 22
1536: PUSH
1537: LD_INT 25
1539: PUSH
1540: LD_INT 28
1542: PUSH
1543: LD_INT 29
1545: PUSH
1546: LD_INT 30
1548: PUSH
1549: LD_INT 31
1551: PUSH
1552: LD_INT 37
1554: PUSH
1555: LD_INT 38
1557: PUSH
1558: LD_INT 32
1560: PUSH
1561: LD_INT 27
1563: PUSH
1564: LD_INT 33
1566: PUSH
1567: LD_INT 69
1569: PUSH
1570: LD_INT 39
1572: PUSH
1573: LD_INT 34
1575: PUSH
1576: LD_INT 40
1578: PUSH
1579: LD_INT 71
1581: PUSH
1582: LD_INT 23
1584: PUSH
1585: LD_INT 44
1587: PUSH
1588: LD_INT 48
1590: PUSH
1591: LD_INT 49
1593: PUSH
1594: LD_INT 50
1596: PUSH
1597: LD_INT 51
1599: PUSH
1600: LD_INT 52
1602: PUSH
1603: LD_INT 53
1605: PUSH
1606: LD_INT 54
1608: PUSH
1609: LD_INT 55
1611: PUSH
1612: LD_INT 56
1614: PUSH
1615: LD_INT 57
1617: PUSH
1618: LD_INT 58
1620: PUSH
1621: LD_INT 59
1623: PUSH
1624: LD_INT 63
1626: PUSH
1627: LD_INT 64
1629: PUSH
1630: LD_INT 65
1632: PUSH
1633: LD_INT 82
1635: PUSH
1636: LD_INT 83
1638: PUSH
1639: LD_INT 84
1641: PUSH
1642: LD_INT 85
1644: PUSH
1645: LD_INT 86
1647: PUSH
1648: EMPTY
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: ST_TO_ADDR
1703: GO 1706
1705: POP
// if state > - 1 and state < 3 then
1706: LD_VAR 0 3
1710: PUSH
1711: LD_INT 1
1713: NEG
1714: GREATER
1715: PUSH
1716: LD_VAR 0 3
1720: PUSH
1721: LD_INT 3
1723: LESS
1724: AND
1725: IFFALSE 1782
// for i in result do
1727: LD_ADDR_VAR 0 5
1731: PUSH
1732: LD_VAR 0 4
1736: PUSH
1737: FOR_IN
1738: IFFALSE 1780
// if GetTech ( i , side ) <> state then
1740: LD_VAR 0 5
1744: PPUSH
1745: LD_VAR 0 1
1749: PPUSH
1750: CALL_OW 321
1754: PUSH
1755: LD_VAR 0 3
1759: NONEQUAL
1760: IFFALSE 1778
// result := result diff i ;
1762: LD_ADDR_VAR 0 4
1766: PUSH
1767: LD_VAR 0 4
1771: PUSH
1772: LD_VAR 0 5
1776: DIFF
1777: ST_TO_ADDR
1778: GO 1737
1780: POP
1781: POP
// end ; end_of_file
1782: LD_VAR 0 4
1786: RET
// export Heike , Givi , Mike , Kamil , Kaia , Sophia , Markov , Omar , Ibrahim , Shariff , Kurt , Aviradze , heikeSecondSquad ; export function PrepareArabian ; var i ; begin
1787: LD_INT 0
1789: PPUSH
1790: PPUSH
// uc_side := 2 ;
1791: LD_ADDR_OWVAR 20
1795: PUSH
1796: LD_INT 2
1798: ST_TO_ADDR
// uc_nation := 2 ;
1799: LD_ADDR_OWVAR 21
1803: PUSH
1804: LD_INT 2
1806: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
1807: LD_ADDR_EXP 7
1811: PUSH
1812: LD_STRING Heike
1814: PPUSH
1815: LD_EXP 1
1819: NOT
1820: PPUSH
1821: LD_EXP 2
1825: PPUSH
1826: CALL 96 0 3
1830: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
1831: LD_ADDR_EXP 15
1835: PUSH
1836: LD_STRING Ibrahim
1838: PPUSH
1839: LD_EXP 1
1843: NOT
1844: PPUSH
1845: LD_EXP 2
1849: PPUSH
1850: CALL 96 0 3
1854: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
1855: LD_ADDR_EXP 8
1859: PUSH
1860: LD_STRING Givi
1862: PPUSH
1863: LD_EXP 1
1867: NOT
1868: PPUSH
1869: LD_EXP 2
1873: PPUSH
1874: CALL 96 0 3
1878: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
1879: LD_ADDR_EXP 10
1883: PUSH
1884: LD_STRING Kamil
1886: PPUSH
1887: LD_EXP 1
1891: NOT
1892: PPUSH
1893: LD_EXP 2
1897: PPUSH
1898: CALL 96 0 3
1902: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
1903: LD_ADDR_EXP 11
1907: PUSH
1908: LD_STRING Kaia
1910: PPUSH
1911: LD_EXP 1
1915: NOT
1916: PPUSH
1917: LD_EXP 2
1921: PPUSH
1922: CALL 96 0 3
1926: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
1927: LD_ADDR_EXP 12
1931: PUSH
1932: LD_STRING Sophia
1934: PPUSH
1935: LD_EXP 1
1939: NOT
1940: PPUSH
1941: LD_EXP 2
1945: PPUSH
1946: CALL 96 0 3
1950: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
1951: LD_ADDR_EXP 13
1955: PUSH
1956: LD_STRING Markov
1958: PPUSH
1959: LD_EXP 1
1963: NOT
1964: PPUSH
1965: LD_EXP 2
1969: PPUSH
1970: CALL 96 0 3
1974: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
1975: LD_ADDR_EXP 18
1979: PUSH
1980: LD_STRING Aviradze
1982: PPUSH
1983: LD_EXP 1
1987: NOT
1988: PPUSH
1989: LD_EXP 2
1993: PPUSH
1994: CALL 96 0 3
1998: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 03_others ) ;
1999: LD_ADDR_EXP 19
2003: PUSH
2004: LD_STRING 03_others
2006: PPUSH
2007: CALL_OW 31
2011: ST_TO_ADDR
// uc_side := 5 ;
2012: LD_ADDR_OWVAR 20
2016: PUSH
2017: LD_INT 5
2019: ST_TO_ADDR
// Omar := PrepareUnit ( Omar , false ,  ) ;
2020: LD_ADDR_EXP 14
2024: PUSH
2025: LD_STRING Omar
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: LD_STRING 
2033: PPUSH
2034: CALL 96 0 3
2038: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , false ,  ) ;
2039: LD_ADDR_EXP 17
2043: PUSH
2044: LD_STRING Kurt
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: LD_STRING 
2052: PPUSH
2053: CALL 96 0 3
2057: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2058: LD_ADDR_EXP 9
2062: PUSH
2063: LD_STRING Mike
2065: PPUSH
2066: LD_EXP 1
2070: NOT
2071: PPUSH
2072: LD_EXP 2
2076: PPUSH
2077: CALL 96 0 3
2081: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
2082: LD_ADDR_EXP 16
2086: PUSH
2087: LD_STRING Abdul
2089: PPUSH
2090: LD_INT 0
2092: PPUSH
2093: LD_STRING 
2095: PPUSH
2096: CALL 96 0 3
2100: ST_TO_ADDR
// if Mike then
2101: LD_EXP 9
2105: IFFALSE 2128
// PlaceUnitXYR ( Mike , 142 , 63 , 2 , false ) ;
2107: LD_EXP 9
2111: PPUSH
2112: LD_INT 142
2114: PPUSH
2115: LD_INT 63
2117: PPUSH
2118: LD_INT 2
2120: PPUSH
2121: LD_INT 0
2123: PPUSH
2124: CALL_OW 50
// PlaceUnitXYR ( Kurt , 142 , 63 , 3 , false ) ;
2128: LD_EXP 17
2132: PPUSH
2133: LD_INT 142
2135: PPUSH
2136: LD_INT 63
2138: PPUSH
2139: LD_INT 3
2141: PPUSH
2142: LD_INT 0
2144: PPUSH
2145: CALL_OW 50
// ComHold ( [ Kurt , Mike ] ) ;
2149: LD_EXP 17
2153: PUSH
2154: LD_EXP 9
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PPUSH
2163: CALL_OW 140
// end ; end_of_file
2167: LD_VAR 0 1
2171: RET
// export Kurin , Grishko , Popov , Burlak ; export function PrepareRussian ; begin
2172: LD_INT 0
2174: PPUSH
// uc_side := 6 ;
2175: LD_ADDR_OWVAR 20
2179: PUSH
2180: LD_INT 6
2182: ST_TO_ADDR
// uc_nation := 3 ;
2183: LD_ADDR_OWVAR 21
2187: PUSH
2188: LD_INT 3
2190: ST_TO_ADDR
// end ; end_of_file end_of_file
2191: LD_VAR 0 1
2195: RET
// export function Action ; var i , un , veh , tmp ; begin
2196: LD_INT 0
2198: PPUSH
2199: PPUSH
2200: PPUSH
2201: PPUSH
2202: PPUSH
// InGameOn ;
2203: CALL_OW 8
// CenterNowOnXY ( 179 , 5 ) ;
2207: LD_INT 179
2209: PPUSH
2210: LD_INT 5
2212: PPUSH
2213: CALL_OW 86
// veh := PrepareTank ( 2 , 2 , ar_light_trike , engine_combustion , control_manual , ar_double_machine_gun , 33 ) ;
2217: LD_ADDR_VAR 0 4
2221: PUSH
2222: LD_INT 2
2224: PPUSH
2225: LD_INT 2
2227: PPUSH
2228: LD_INT 12
2230: PPUSH
2231: LD_INT 1
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: LD_INT 24
2239: PPUSH
2240: LD_INT 33
2242: PPUSH
2243: CALL 159 0 7
2247: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2248: LD_VAR 0 4
2252: PPUSH
2253: LD_INT 2
2255: PPUSH
2256: CALL_OW 233
// PlaceUnitXY ( veh , 178 , 2 , false ) ;
2260: LD_VAR 0 4
2264: PPUSH
2265: LD_INT 178
2267: PPUSH
2268: LD_INT 2
2270: PPUSH
2271: LD_INT 0
2273: PPUSH
2274: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
2278: LD_EXP 7
2282: PPUSH
2283: LD_VAR 0 4
2287: PPUSH
2288: CALL_OW 52
// if Kamil then
2292: LD_EXP 10
2296: IFFALSE 2331
// begin PlaceUnitXY ( Kamil , 207 , 37 , false ) ;
2298: LD_EXP 10
2302: PPUSH
2303: LD_INT 207
2305: PPUSH
2306: LD_INT 37
2308: PPUSH
2309: LD_INT 0
2311: PPUSH
2312: CALL_OW 48
// ComTurnXY ( Kamil , 211 , 38 ) ;
2316: LD_EXP 10
2320: PPUSH
2321: LD_INT 211
2323: PPUSH
2324: LD_INT 38
2326: PPUSH
2327: CALL_OW 118
// end ; if Sophia then
2331: LD_EXP 12
2335: IFFALSE 2370
// begin PlaceUnitXY ( Sophia , 209 , 40 , false ) ;
2337: LD_EXP 12
2341: PPUSH
2342: LD_INT 209
2344: PPUSH
2345: LD_INT 40
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 48
// ComTurnXY ( Sophia , 211 , 38 ) ;
2355: LD_EXP 12
2359: PPUSH
2360: LD_INT 211
2362: PPUSH
2363: LD_INT 38
2365: PPUSH
2366: CALL_OW 118
// end ; if Givi then
2370: LD_EXP 8
2374: IFFALSE 2409
// begin PlaceUnitXY ( Givi , 201 , 34 , false ) ;
2376: LD_EXP 8
2380: PPUSH
2381: LD_INT 201
2383: PPUSH
2384: LD_INT 34
2386: PPUSH
2387: LD_INT 0
2389: PPUSH
2390: CALL_OW 48
// ComTurnXY ( Givi , 206 , 36 ) ;
2394: LD_EXP 8
2398: PPUSH
2399: LD_INT 206
2401: PPUSH
2402: LD_INT 36
2404: PPUSH
2405: CALL_OW 118
// end ; if Markov then
2409: LD_EXP 13
2413: IFFALSE 2500
// begin veh := PrepareTank ( 2 , 2 , ar_medium_trike , engine_combustion , control_manual , ar_gatling_gun , 80 - 20 * Difficulty ) ;
2415: LD_ADDR_VAR 0 4
2419: PUSH
2420: LD_INT 2
2422: PPUSH
2423: LD_INT 2
2425: PPUSH
2426: LD_INT 13
2428: PPUSH
2429: LD_INT 1
2431: PPUSH
2432: LD_INT 1
2434: PPUSH
2435: LD_INT 25
2437: PPUSH
2438: LD_INT 80
2440: PUSH
2441: LD_INT 20
2443: PUSH
2444: LD_OWVAR 67
2448: MUL
2449: MINUS
2450: PPUSH
2451: CALL 159 0 7
2455: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
2456: LD_VAR 0 4
2460: PPUSH
2461: LD_INT 2
2463: PPUSH
2464: CALL_OW 233
// PlaceUnitXY ( veh , 197 , 35 , false ) ;
2468: LD_VAR 0 4
2472: PPUSH
2473: LD_INT 197
2475: PPUSH
2476: LD_INT 35
2478: PPUSH
2479: LD_INT 0
2481: PPUSH
2482: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
2486: LD_EXP 13
2490: PPUSH
2491: LD_VAR 0 4
2495: PPUSH
2496: CALL_OW 52
// end ; tmp := Kaia union heikeSecondSquad ;
2500: LD_ADDR_VAR 0 5
2504: PUSH
2505: LD_EXP 11
2509: PUSH
2510: LD_EXP 19
2514: UNION
2515: ST_TO_ADDR
// for i in tmp do
2516: LD_ADDR_VAR 0 2
2520: PUSH
2521: LD_VAR 0 5
2525: PUSH
2526: FOR_IN
2527: IFFALSE 2561
// begin PlaceUnitXYR ( i , 203 , 41 , 6 , false ) ;
2529: LD_VAR 0 2
2533: PPUSH
2534: LD_INT 203
2536: PPUSH
2537: LD_INT 41
2539: PPUSH
2540: LD_INT 6
2542: PPUSH
2543: LD_INT 0
2545: PPUSH
2546: CALL_OW 50
// ComHold ( i ) ;
2550: LD_VAR 0 2
2554: PPUSH
2555: CALL_OW 140
// end ;
2559: GO 2526
2561: POP
2562: POP
// if not FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 2 ] ] ) then
2563: LD_INT 22
2565: PUSH
2566: LD_INT 2
2568: PUSH
2569: EMPTY
2570: LIST
2571: LIST
2572: PUSH
2573: LD_INT 25
2575: PUSH
2576: LD_INT 2
2578: PUSH
2579: EMPTY
2580: LIST
2581: LIST
2582: PUSH
2583: EMPTY
2584: LIST
2585: LIST
2586: PPUSH
2587: CALL_OW 69
2591: NOT
2592: IFFALSE 2606
// SetClass ( Heike , 2 ) ;
2594: LD_EXP 7
2598: PPUSH
2599: LD_INT 2
2601: PPUSH
2602: CALL_OW 336
// ComMoveXY ( Heike , 183 , 12 ) ;
2606: LD_EXP 7
2610: PPUSH
2611: LD_INT 183
2613: PPUSH
2614: LD_INT 12
2616: PPUSH
2617: CALL_OW 111
// AddComMoveXY ( Heike , 188 , 20 ) ;
2621: LD_EXP 7
2625: PPUSH
2626: LD_INT 188
2628: PPUSH
2629: LD_INT 20
2631: PPUSH
2632: CALL_OW 171
// AddComMoveXY ( Heike , 191 , 25 ) ;
2636: LD_EXP 7
2640: PPUSH
2641: LD_INT 191
2643: PPUSH
2644: LD_INT 25
2646: PPUSH
2647: CALL_OW 171
// AddComMoveXY ( Heike , 203 , 29 ) ;
2651: LD_EXP 7
2655: PPUSH
2656: LD_INT 203
2658: PPUSH
2659: LD_INT 29
2661: PPUSH
2662: CALL_OW 171
// AddComExitVehicle ( Heike ) ;
2666: LD_EXP 7
2670: PPUSH
2671: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
2675: LD_INT 35
2677: PPUSH
2678: CALL_OW 67
// until not IsInUnit ( Heike ) ;
2682: LD_EXP 7
2686: PPUSH
2687: CALL_OW 310
2691: NOT
2692: IFFALSE 2675
// CenterOnUnits ( Heike ) ;
2694: LD_EXP 7
2698: PPUSH
2699: CALL_OW 85
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff [ Heike , Markov ] ;
2703: LD_ADDR_VAR 0 5
2707: PUSH
2708: LD_INT 22
2710: PUSH
2711: LD_INT 2
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PUSH
2718: LD_INT 21
2720: PUSH
2721: LD_INT 1
2723: PUSH
2724: EMPTY
2725: LIST
2726: LIST
2727: PUSH
2728: EMPTY
2729: LIST
2730: LIST
2731: PPUSH
2732: CALL_OW 69
2736: PUSH
2737: LD_EXP 7
2741: PUSH
2742: LD_EXP 13
2746: PUSH
2747: EMPTY
2748: LIST
2749: LIST
2750: DIFF
2751: ST_TO_ADDR
// ComTurnUnit ( tmp , Heike ) ;
2752: LD_VAR 0 5
2756: PPUSH
2757: LD_EXP 7
2761: PPUSH
2762: CALL_OW 119
// if Givi then
2766: LD_EXP 8
2770: IFFALSE 2788
// ComTurnUnit ( Heike , Givi ) else
2772: LD_EXP 7
2776: PPUSH
2777: LD_EXP 8
2781: PPUSH
2782: CALL_OW 119
2786: GO 2806
// ComTurnUnit ( Heike , tmp [ 1 ] ) ;
2788: LD_EXP 7
2792: PPUSH
2793: LD_VAR 0 5
2797: PUSH
2798: LD_INT 1
2800: ARRAY
2801: PPUSH
2802: CALL_OW 119
// Say ( Heike , DH-Start-1 ) ;
2806: LD_EXP 7
2810: PPUSH
2811: LD_STRING DH-Start-1
2813: PPUSH
2814: CALL_OW 88
// if Givi then
2818: LD_EXP 8
2822: IFFALSE 2869
// begin Say ( Givi , DG-Start-2 ) ;
2824: LD_EXP 8
2828: PPUSH
2829: LD_STRING DG-Start-2
2831: PPUSH
2832: CALL_OW 88
// if not Mike then
2836: LD_EXP 9
2840: NOT
2841: IFFALSE 2867
// begin Say ( Givi , DG-Start-b-3 ) ;
2843: LD_EXP 8
2847: PPUSH
2848: LD_STRING DG-Start-b-3
2850: PPUSH
2851: CALL_OW 88
// Say ( Heike , DH-Start-b-4 ) ;
2855: LD_EXP 7
2859: PPUSH
2860: LD_STRING DH-Start-b-4
2862: PPUSH
2863: CALL_OW 88
// end ; end else
2867: GO 2934
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-Start-a-2 ) then
2869: LD_EXP 19
2873: PPUSH
2874: LD_INT 26
2876: PUSH
2877: LD_INT 1
2879: PUSH
2880: EMPTY
2881: LIST
2882: LIST
2883: PPUSH
2884: CALL_OW 72
2888: PUSH
2889: LD_INT 1
2891: ARRAY
2892: PPUSH
2893: LD_STRING DArm-Start-a-2
2895: PPUSH
2896: CALL_OW 88
2900: NOT
2901: IFFALSE 2934
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-Start-a-2 ) ;
2903: LD_EXP 19
2907: PPUSH
2908: LD_INT 26
2910: PUSH
2911: LD_INT 2
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PPUSH
2918: CALL_OW 72
2922: PUSH
2923: LD_INT 1
2925: ARRAY
2926: PPUSH
2927: LD_STRING DArf-Start-a-2
2929: PPUSH
2930: CALL_OW 88
// ComTurnXY ( Heike , 211 , 38 ) ;
2934: LD_EXP 7
2938: PPUSH
2939: LD_INT 211
2941: PPUSH
2942: LD_INT 38
2944: PPUSH
2945: CALL_OW 118
// wait ( 0 0$1 ) ;
2949: LD_INT 35
2951: PPUSH
2952: CALL_OW 67
// Say ( Heike , DH-Start-3 ) ;
2956: LD_EXP 7
2960: PPUSH
2961: LD_STRING DH-Start-3
2963: PPUSH
2964: CALL_OW 88
// Say ( Heike , DH-Start-4 ) ;
2968: LD_EXP 7
2972: PPUSH
2973: LD_STRING DH-Start-4
2975: PPUSH
2976: CALL_OW 88
// InGameOff ;
2980: CALL_OW 9
// ChangeMissionObjectives ( Prepare ) ;
2984: LD_STRING Prepare
2986: PPUSH
2987: CALL_OW 337
// wait ( 0 0$10 ) ;
2991: LD_INT 350
2993: PPUSH
2994: CALL_OW 67
// if not Aviradze then
2998: LD_EXP 18
3002: NOT
3003: IFFALSE 3007
// exit ;
3005: GO 3199
// SetDir ( Aviradze , 4 ) ;
3007: LD_EXP 18
3011: PPUSH
3012: LD_INT 4
3014: PPUSH
3015: CALL_OW 233
// PlaceUnitXY ( Aviradze , 225 , 33 , false ) ;
3019: LD_EXP 18
3023: PPUSH
3024: LD_INT 225
3026: PPUSH
3027: LD_INT 33
3029: PPUSH
3030: LD_INT 0
3032: PPUSH
3033: CALL_OW 48
// for i := 1 to 2 do
3037: LD_ADDR_VAR 0 2
3041: PUSH
3042: DOUBLE
3043: LD_INT 1
3045: DEC
3046: ST_TO_ADDR
3047: LD_INT 2
3049: PUSH
3050: FOR_TO
3051: IFFALSE 3182
// begin uc_side := 2 ;
3053: LD_ADDR_OWVAR 20
3057: PUSH
3058: LD_INT 2
3060: ST_TO_ADDR
// uc_nation := 0 ;
3061: LD_ADDR_OWVAR 21
3065: PUSH
3066: LD_INT 0
3068: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
3069: LD_INT 0
3071: PPUSH
3072: LD_INT 12
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: CALL_OW 380
// hc_gallery :=  ;
3082: LD_ADDR_OWVAR 33
3086: PUSH
3087: LD_STRING 
3089: ST_TO_ADDR
// hc_name := [ Artudito , Textur ] [ i ] ;
3090: LD_ADDR_OWVAR 26
3094: PUSH
3095: LD_STRING Artudito
3097: PUSH
3098: LD_STRING Textur
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: PUSH
3105: LD_VAR 0 2
3109: ARRAY
3110: ST_TO_ADDR
// un := CreateHuman ;
3111: LD_ADDR_VAR 0 3
3115: PUSH
3116: CALL_OW 44
3120: ST_TO_ADDR
// PlaceUnitXY ( un , [ 224 , 226 ] [ i ] , [ 31 , 35 ] [ i ] , false ) ;
3121: LD_VAR 0 3
3125: PPUSH
3126: LD_INT 224
3128: PUSH
3129: LD_INT 226
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: PUSH
3136: LD_VAR 0 2
3140: ARRAY
3141: PPUSH
3142: LD_INT 31
3144: PUSH
3145: LD_INT 35
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: PUSH
3152: LD_VAR 0 2
3156: ARRAY
3157: PPUSH
3158: LD_INT 0
3160: PPUSH
3161: CALL_OW 48
// ComMoveXY ( un , 215 , 36 ) ;
3165: LD_VAR 0 3
3169: PPUSH
3170: LD_INT 215
3172: PPUSH
3173: LD_INT 36
3175: PPUSH
3176: CALL_OW 111
// end ;
3180: GO 3050
3182: POP
3183: POP
// ComMoveXY ( Aviradze , 215 , 36 ) ;
3184: LD_EXP 18
3188: PPUSH
3189: LD_INT 215
3191: PPUSH
3192: LD_INT 36
3194: PPUSH
3195: CALL_OW 111
// end ;
3199: LD_VAR 0 1
3203: RET
// every 0 0$2 trigger baseConstructed do
3204: LD_EXP 3
3208: IFFALSE 4085
3210: GO 3212
3212: DISABLE
// begin DialogueOn ;
3213: CALL_OW 6
// Say ( Heike , DH-base-1 ) ;
3217: LD_EXP 7
3221: PPUSH
3222: LD_STRING DH-base-1
3224: PPUSH
3225: CALL_OW 88
// if Markov then
3229: LD_EXP 13
3233: IFFALSE 3285
// begin Say ( Markov , DMar-base-2 ) ;
3235: LD_EXP 13
3239: PPUSH
3240: LD_STRING DMar-base-2
3242: PPUSH
3243: CALL_OW 88
// Say ( Markov , DMar-base-3 ) ;
3247: LD_EXP 13
3251: PPUSH
3252: LD_STRING DMar-base-3
3254: PPUSH
3255: CALL_OW 88
// Say ( Heike , DH-base-4 ) ;
3259: LD_EXP 7
3263: PPUSH
3264: LD_STRING DH-base-4
3266: PPUSH
3267: CALL_OW 88
// Say ( Markov , DMar-base-5 ) ;
3271: LD_EXP 13
3275: PPUSH
3276: LD_STRING DMar-base-5
3278: PPUSH
3279: CALL_OW 88
// end else
3283: GO 3362
// begin if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-base-a-2 ) then
3285: LD_EXP 19
3289: PPUSH
3290: LD_INT 26
3292: PUSH
3293: LD_INT 1
3295: PUSH
3296: EMPTY
3297: LIST
3298: LIST
3299: PPUSH
3300: CALL_OW 72
3304: PUSH
3305: LD_INT 1
3307: ARRAY
3308: PPUSH
3309: LD_STRING DArm-base-a-2
3311: PPUSH
3312: CALL_OW 88
3316: NOT
3317: IFFALSE 3350
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-base-a-2 ) ;
3319: LD_EXP 19
3323: PPUSH
3324: LD_INT 26
3326: PUSH
3327: LD_INT 2
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PPUSH
3334: CALL_OW 72
3338: PUSH
3339: LD_INT 1
3341: ARRAY
3342: PPUSH
3343: LD_STRING DArf-base-a-2
3345: PPUSH
3346: CALL_OW 88
// Say ( Heike , DH-base-a-3 ) ;
3350: LD_EXP 7
3354: PPUSH
3355: LD_STRING DH-base-a-3
3357: PPUSH
3358: CALL_OW 88
// end ; Say ( Aviradze , DA-base-6 ) ;
3362: LD_EXP 18
3366: PPUSH
3367: LD_STRING DA-base-6
3369: PPUSH
3370: CALL_OW 88
// Say ( Aviradze , DA-base-7 ) ;
3374: LD_EXP 18
3378: PPUSH
3379: LD_STRING DA-base-7
3381: PPUSH
3382: CALL_OW 88
// DialogueOff ;
3386: CALL_OW 7
// ChangeMissionObjectives ( Flamethrower ) ;
3390: LD_STRING Flamethrower
3392: PPUSH
3393: CALL_OW 337
// wait ( 2 2$00 ) ;
3397: LD_INT 4200
3399: PPUSH
3400: CALL_OW 67
// ComMoveXY ( [ Kurt , Mike ] , 203 , 37 ) ;
3404: LD_EXP 17
3408: PUSH
3409: LD_EXP 9
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: PPUSH
3418: LD_INT 203
3420: PPUSH
3421: LD_INT 37
3423: PPUSH
3424: CALL_OW 111
// if not FilterAllUnits ( [ [ f_side , 2 ] , [ f_distxy , 203 , 37 , 10 ] ] ) then
3428: LD_INT 22
3430: PUSH
3431: LD_INT 2
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: PUSH
3438: LD_INT 92
3440: PUSH
3441: LD_INT 203
3443: PUSH
3444: LD_INT 37
3446: PUSH
3447: LD_INT 10
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: PUSH
3456: EMPTY
3457: LIST
3458: LIST
3459: PPUSH
3460: CALL_OW 69
3464: NOT
3465: IFFALSE 3505
// AddComMoveXY ( [ Kurt , Mike ] , GetX ( Heike ) , GetY ( Heike ) ) ;
3467: LD_EXP 17
3471: PUSH
3472: LD_EXP 9
3476: PUSH
3477: EMPTY
3478: LIST
3479: LIST
3480: PPUSH
3481: LD_EXP 7
3485: PPUSH
3486: CALL_OW 250
3490: PPUSH
3491: LD_EXP 7
3495: PPUSH
3496: CALL_OW 251
3500: PPUSH
3501: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
3505: LD_INT 35
3507: PPUSH
3508: CALL_OW 67
// until See ( 2 , Kurt ) or GetDistUnits ( Kurt , Heike ) < 8 ;
3512: LD_INT 2
3514: PPUSH
3515: LD_EXP 17
3519: PPUSH
3520: CALL_OW 292
3524: PUSH
3525: LD_EXP 17
3529: PPUSH
3530: LD_EXP 7
3534: PPUSH
3535: CALL_OW 296
3539: PUSH
3540: LD_INT 8
3542: LESS
3543: OR
3544: IFFALSE 3505
// InGameOn ;
3546: CALL_OW 8
// CenterNowOnUnits ( Kurt ) ;
3550: LD_EXP 17
3554: PPUSH
3555: CALL_OW 87
// if IsInUnit ( Heike ) then
3559: LD_EXP 7
3563: PPUSH
3564: CALL_OW 310
3568: IFFALSE 3579
// ComExitBuilding ( Heike ) ;
3570: LD_EXP 7
3574: PPUSH
3575: CALL_OW 122
// ComMoveUnit ( [ Kurt , Mike ] , Heike ) ;
3579: LD_EXP 17
3583: PUSH
3584: LD_EXP 9
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: PPUSH
3593: LD_EXP 7
3597: PPUSH
3598: CALL_OW 112
// AddComTurnUnit ( Heike , Kurt ) ;
3602: LD_EXP 7
3606: PPUSH
3607: LD_EXP 17
3611: PPUSH
3612: CALL_OW 179
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Kurt , 10 ] , [ f_type , unit_building ] ] ) then
3616: LD_INT 22
3618: PUSH
3619: LD_INT 2
3621: PUSH
3622: EMPTY
3623: LIST
3624: LIST
3625: PUSH
3626: LD_INT 91
3628: PUSH
3629: LD_EXP 17
3633: PUSH
3634: LD_INT 10
3636: PUSH
3637: EMPTY
3638: LIST
3639: LIST
3640: LIST
3641: PUSH
3642: LD_INT 21
3644: PUSH
3645: LD_INT 3
3647: PUSH
3648: EMPTY
3649: LIST
3650: LIST
3651: PUSH
3652: EMPTY
3653: LIST
3654: LIST
3655: LIST
3656: PPUSH
3657: CALL_OW 69
3661: IFFALSE 3687
// begin Say ( Kurt , DKs-scout-1 ) ;
3663: LD_EXP 17
3667: PPUSH
3668: LD_STRING DKs-scout-1
3670: PPUSH
3671: CALL_OW 88
// Say ( Heike , DH-scout-2 ) ;
3675: LD_EXP 7
3679: PPUSH
3680: LD_STRING DH-scout-2
3682: PPUSH
3683: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
3687: LD_INT 35
3689: PPUSH
3690: CALL_OW 67
// until GetDistUnits ( Heike , Kurt ) < 6 ;
3694: LD_EXP 7
3698: PPUSH
3699: LD_EXP 17
3703: PPUSH
3704: CALL_OW 296
3708: PUSH
3709: LD_INT 6
3711: LESS
3712: IFFALSE 3687
// ComTurnUnit ( [ Kurt , Mike ] , Heike ) ;
3714: LD_EXP 17
3718: PUSH
3719: LD_EXP 9
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: PPUSH
3728: LD_EXP 7
3732: PPUSH
3733: CALL_OW 119
// Say ( Kurt , DKs-scout-3 ) ;
3737: LD_EXP 17
3741: PPUSH
3742: LD_STRING DKs-scout-3
3744: PPUSH
3745: CALL_OW 88
// if Kaia then
3749: LD_EXP 11
3753: IFFALSE 3936
// begin if IsInUnit ( Kaia ) then
3755: LD_EXP 11
3759: PPUSH
3760: CALL_OW 310
3764: IFFALSE 3775
// ComExitBuilding ( Kaia ) ;
3766: LD_EXP 11
3770: PPUSH
3771: CALL_OW 122
// AddComMoveUnit ( Kaia , Kurt ) ;
3775: LD_EXP 11
3779: PPUSH
3780: LD_EXP 17
3784: PPUSH
3785: CALL_OW 172
// repeat wait ( 0 0$1 ) ;
3789: LD_INT 35
3791: PPUSH
3792: CALL_OW 67
// until GetDistUnits ( Kaia , Kurt ) < 6 ;
3796: LD_EXP 11
3800: PPUSH
3801: LD_EXP 17
3805: PPUSH
3806: CALL_OW 296
3810: PUSH
3811: LD_INT 6
3813: LESS
3814: IFFALSE 3789
// ComTurnUnit ( Kaia , Kurt ) ;
3816: LD_EXP 11
3820: PPUSH
3821: LD_EXP 17
3825: PPUSH
3826: CALL_OW 119
// Say ( Kaia , DK-scout-4 ) ;
3830: LD_EXP 11
3834: PPUSH
3835: LD_STRING DK-scout-4
3837: PPUSH
3838: CALL_OW 88
// ComTurnUnit ( Kurt , Kaia ) ;
3842: LD_EXP 17
3846: PPUSH
3847: LD_EXP 11
3851: PPUSH
3852: CALL_OW 119
// Say ( Kurt , DKs-scout-5 ) ;
3856: LD_EXP 17
3860: PPUSH
3861: LD_STRING DKs-scout-5
3863: PPUSH
3864: CALL_OW 88
// Say ( Kaia , DK-scout-6 ) ;
3868: LD_EXP 11
3872: PPUSH
3873: LD_STRING DK-scout-6
3875: PPUSH
3876: CALL_OW 88
// if Mike then
3880: LD_EXP 9
3884: IFFALSE 3936
// begin Say ( Mike , DM-scout-7 ) ;
3886: LD_EXP 9
3890: PPUSH
3891: LD_STRING DM-scout-7
3893: PPUSH
3894: CALL_OW 88
// ComTurnUnit ( Kaia , Mike ) ;
3898: LD_EXP 11
3902: PPUSH
3903: LD_EXP 9
3907: PPUSH
3908: CALL_OW 119
// Say ( Kaia , DK-scout-8 ) ;
3912: LD_EXP 11
3916: PPUSH
3917: LD_STRING DK-scout-8
3919: PPUSH
3920: CALL_OW 88
// Say ( Mike , DM-scout-9 ) ;
3924: LD_EXP 9
3928: PPUSH
3929: LD_STRING DM-scout-9
3931: PPUSH
3932: CALL_OW 88
// end ; end ; ShowArea ( scoutArea , 2 ) ;
3936: LD_INT 9
3938: PPUSH
3939: LD_INT 2
3941: PPUSH
3942: CALL_OW 334
// CenterOnXY ( 184 , 100 ) ;
3946: LD_INT 184
3948: PPUSH
3949: LD_INT 100
3951: PPUSH
3952: CALL_OW 84
// Say ( Kurt , DKs-scout-10 ) ;
3956: LD_EXP 17
3960: PPUSH
3961: LD_STRING DKs-scout-10
3963: PPUSH
3964: CALL_OW 88
// wait ( 0 0$1 ) ;
3968: LD_INT 35
3970: PPUSH
3971: CALL_OW 67
// ShowArea ( hillArea , 2 ) ;
3975: LD_INT 10
3977: PPUSH
3978: LD_INT 2
3980: PPUSH
3981: CALL_OW 334
// CenterOnXY ( 144 , 65 ) ;
3985: LD_INT 144
3987: PPUSH
3988: LD_INT 65
3990: PPUSH
3991: CALL_OW 84
// Say ( Kurt , DKs-scout-11 ) ;
3995: LD_EXP 17
3999: PPUSH
4000: LD_STRING DKs-scout-11
4002: PPUSH
4003: CALL_OW 88
// wait ( 0 0$1 ) ;
4007: LD_INT 35
4009: PPUSH
4010: CALL_OW 67
// CenterNowOnUnits ( Kurt ) ;
4014: LD_EXP 17
4018: PPUSH
4019: CALL_OW 87
// if Mike and not Givi then
4023: LD_EXP 9
4027: PUSH
4028: LD_EXP 8
4032: NOT
4033: AND
4034: IFFALSE 4060
// begin Say ( Mike , DM-scout-a-1 ) ;
4036: LD_EXP 9
4040: PPUSH
4041: LD_STRING DM-scout-a-1
4043: PPUSH
4044: CALL_OW 88
// Say ( Heike , DH-scout-a-2 ) ;
4048: LD_EXP 7
4052: PPUSH
4053: LD_STRING DH-scout-a-2
4055: PPUSH
4056: CALL_OW 88
// end ; SetSide ( [ Kurt , Mike ] , 2 ) ;
4060: LD_EXP 17
4064: PUSH
4065: LD_EXP 9
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: PPUSH
4074: LD_INT 2
4076: PPUSH
4077: CALL_OW 235
// InGameOff ;
4081: CALL_OW 9
// end ;
4085: END
// every 0 0$2 trigger labConstructed and IsOk ( Aviradze ) do
4086: LD_EXP 4
4090: PUSH
4091: LD_EXP 18
4095: PPUSH
4096: CALL_OW 302
4100: AND
4101: IFFALSE 4150
4103: GO 4105
4105: DISABLE
// begin DialogueOn ;
4106: CALL_OW 6
// Say ( Aviradze , DA-lab-1 ) ;
4110: LD_EXP 18
4114: PPUSH
4115: LD_STRING DA-lab-1
4117: PPUSH
4118: CALL_OW 88
// Say ( Aviradze , DA-lab-2 ) ;
4122: LD_EXP 18
4126: PPUSH
4127: LD_STRING DA-lab-2
4129: PPUSH
4130: CALL_OW 88
// Say ( Heike , DH-lab-3 ) ;
4134: LD_EXP 7
4138: PPUSH
4139: LD_STRING DH-lab-3
4141: PPUSH
4142: CALL_OW 88
// DialogueOff ;
4146: CALL_OW 7
// end ;
4150: END
// every 0 0$2 trigger GetTech ( tech_HidCam , 2 ) = state_researched do var i ;
4151: LD_INT 17
4153: PPUSH
4154: LD_INT 2
4156: PPUSH
4157: CALL_OW 321
4161: PUSH
4162: LD_INT 2
4164: EQUAL
4165: IFFALSE 4297
4167: GO 4169
4169: DISABLE
4170: LD_INT 0
4172: PPUSH
// begin DialogueOn ;
4173: CALL_OW 6
// Say ( Aviradze , DA-Cam-1 ) ;
4177: LD_EXP 18
4181: PPUSH
4182: LD_STRING DA-Cam-1
4184: PPUSH
4185: CALL_OW 88
// Say ( Aviradze , DA-Cam-2 ) ;
4189: LD_EXP 18
4193: PPUSH
4194: LD_STRING DA-Cam-2
4196: PPUSH
4197: CALL_OW 88
// Say ( Aviradze , DA-Cam-3 ) ;
4201: LD_EXP 18
4205: PPUSH
4206: LD_STRING DA-Cam-3
4208: PPUSH
4209: CALL_OW 88
// Say ( Heike , DH-Cam-4 ) ;
4213: LD_EXP 7
4217: PPUSH
4218: LD_STRING DH-Cam-4
4220: PPUSH
4221: CALL_OW 88
// Say ( Kaia , DK-Cam-5 ) ;
4225: LD_EXP 11
4229: PPUSH
4230: LD_STRING DK-Cam-5
4232: PPUSH
4233: CALL_OW 88
// Say ( Kaia , DK-Cam-6 ) ;
4237: LD_EXP 11
4241: PPUSH
4242: LD_STRING DK-Cam-6
4244: PPUSH
4245: CALL_OW 88
// DialogueOff ;
4249: CALL_OW 7
// Query ( Camera ) ;
4253: LD_STRING Camera
4255: PPUSH
4256: CALL_OW 97
// hiddenCameraAllowed := true ;
4260: LD_ADDR_EXP 5
4264: PUSH
4265: LD_INT 1
4267: ST_TO_ADDR
// for i in camAreas do
4268: LD_ADDR_VAR 0 1
4272: PUSH
4273: LD_EXP 6
4277: PUSH
4278: FOR_IN
4279: IFFALSE 4295
// SetAreaMapShow ( i , 1 ) ;
4281: LD_VAR 0 1
4285: PPUSH
4286: LD_INT 1
4288: PPUSH
4289: CALL_OW 424
4293: GO 4278
4295: POP
4296: POP
// end ;
4297: PPOPN 1
4299: END
// every 0 0$1 trigger not camAreas and hiddenCameraAllowed do var i ;
4300: LD_EXP 6
4304: NOT
4305: PUSH
4306: LD_EXP 5
4310: AND
4311: IFFALSE 4402
4313: GO 4315
4315: DISABLE
4316: LD_INT 0
4318: PPUSH
// begin stop_talking := true ;
4319: LD_ADDR_OWVAR 56
4323: PUSH
4324: LD_INT 1
4326: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) do
4327: LD_ADDR_VAR 0 1
4331: PUSH
4332: LD_INT 22
4334: PUSH
4335: LD_INT 2
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PUSH
4342: LD_INT 21
4344: PUSH
4345: LD_INT 1
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PUSH
4352: LD_INT 23
4354: PUSH
4355: LD_INT 2
4357: PUSH
4358: EMPTY
4359: LIST
4360: LIST
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: PPUSH
4367: CALL_OW 69
4371: PUSH
4372: FOR_IN
4373: IFFALSE 4392
// AddExperience ( i , 2 , 450 ) ;
4375: LD_VAR 0 1
4379: PPUSH
4380: LD_INT 2
4382: PPUSH
4383: LD_INT 450
4385: PPUSH
4386: CALL_OW 492
4390: GO 4372
4392: POP
4393: POP
// stop_talking := false ;
4394: LD_ADDR_OWVAR 56
4398: PUSH
4399: LD_INT 0
4401: ST_TO_ADDR
// end ; end_of_file
4402: PPOPN 1
4404: END
// on BuildingComplete ( b ) do begin if GetBType ( b ) = b_depot and GetSide ( b ) = 2 then
4405: LD_VAR 0 1
4409: PPUSH
4410: CALL_OW 266
4414: PUSH
4415: LD_INT 0
4417: EQUAL
4418: PUSH
4419: LD_VAR 0 1
4423: PPUSH
4424: CALL_OW 255
4428: PUSH
4429: LD_INT 2
4431: EQUAL
4432: AND
4433: IFFALSE 4443
// baseConstructed := true ;
4435: LD_ADDR_EXP 3
4439: PUSH
4440: LD_INT 1
4442: ST_TO_ADDR
// if GetBType ( b ) = b_lab and GetSide ( b ) = 2 then
4443: LD_VAR 0 1
4447: PPUSH
4448: CALL_OW 266
4452: PUSH
4453: LD_INT 6
4455: EQUAL
4456: PUSH
4457: LD_VAR 0 1
4461: PPUSH
4462: CALL_OW 255
4466: PUSH
4467: LD_INT 2
4469: EQUAL
4470: AND
4471: IFFALSE 4481
// labConstructed := true ;
4473: LD_ADDR_EXP 4
4477: PUSH
4478: LD_INT 1
4480: ST_TO_ADDR
// end ;
4481: PPOPN 1
4483: END
// on HiddenCameraPlaced ( side , un , x , y ) do var i ;
4484: LD_INT 0
4486: PPUSH
// begin if not camAreas or not hiddenCameraAllowed then
4487: LD_EXP 6
4491: NOT
4492: PUSH
4493: LD_EXP 5
4497: NOT
4498: OR
4499: IFFALSE 4503
// exit ;
4501: GO 4571
// for i in camAreas do
4503: LD_ADDR_VAR 0 5
4507: PUSH
4508: LD_EXP 6
4512: PUSH
4513: FOR_IN
4514: IFFALSE 4569
// if InArea ( x , y , i ) then
4516: LD_VAR 0 3
4520: PPUSH
4521: LD_VAR 0 4
4525: PPUSH
4526: LD_VAR 0 5
4530: PPUSH
4531: CALL_OW 309
4535: IFFALSE 4567
// begin SetAreaMapShow ( i , 0 ) ;
4537: LD_VAR 0 5
4541: PPUSH
4542: LD_INT 0
4544: PPUSH
4545: CALL_OW 424
// camAreas := camAreas diff i ;
4549: LD_ADDR_EXP 6
4553: PUSH
4554: LD_EXP 6
4558: PUSH
4559: LD_VAR 0 5
4563: DIFF
4564: ST_TO_ADDR
// break ;
4565: GO 4569
// end ;
4567: GO 4513
4569: POP
4570: POP
// end ;
4571: PPOPN 5
4573: END
