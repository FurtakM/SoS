// starting begin ResetFog ;
   0: CALL_OW 335
// music_nat := 4 ;
   4: LD_ADDR_OWVAR 71
   8: PUSH
   9: LD_INT 4
  11: ST_TO_ADDR
// music_class := 3 ;
  12: LD_ADDR_OWVAR 72
  16: PUSH
  17: LD_INT 3
  19: ST_TO_ADDR
// AnimateTrees ( true ) ;
  20: LD_INT 1
  22: PPUSH
  23: CALL_OW 573
// InitVariables ;
  27: CALL 40 0 0
// PrepareAmericanBase ;
  31: CALL 3034 0 0
// Action ;
  35: CALL 109 0 0
// end ;
  39: END
// export Heike , Omar , Abdul , Olaf , Kaia , Shahrzad , Mahtab ; export Kurt , Hans , Saliba , Shariff , Gensher ; export scientists , eonGuards , firstGroup ; export foundPoints , goWithHeike , baseSpotted , heikeNearbyEon , meetingActive ; function InitVariables ; begin
  40: LD_INT 0
  42: PPUSH
// foundPoints := 0 ;
  43: LD_ADDR_EXP 16
  47: PUSH
  48: LD_INT 0
  50: ST_TO_ADDR
// goWithHeike := false ;
  51: LD_ADDR_EXP 17
  55: PUSH
  56: LD_INT 0
  58: ST_TO_ADDR
// baseSpotted := false ;
  59: LD_ADDR_EXP 18
  63: PUSH
  64: LD_INT 0
  66: ST_TO_ADDR
// heikeNearbyEon := false ;
  67: LD_ADDR_EXP 19
  71: PUSH
  72: LD_INT 0
  74: ST_TO_ADDR
// meetingActive := true ;
  75: LD_ADDR_EXP 20
  79: PUSH
  80: LD_INT 1
  82: ST_TO_ADDR
// scientists := [ ] ;
  83: LD_ADDR_EXP 13
  87: PUSH
  88: EMPTY
  89: ST_TO_ADDR
// eonGuards := [ ] ;
  90: LD_ADDR_EXP 14
  94: PUSH
  95: EMPTY
  96: ST_TO_ADDR
// firstGroup := [ ] ;
  97: LD_ADDR_EXP 15
 101: PUSH
 102: EMPTY
 103: ST_TO_ADDR
// end ; end_of_file
 104: LD_VAR 0 1
 108: RET
// export function Action ; begin
 109: LD_INT 0
 111: PPUSH
// InGameOn ;
 112: CALL_OW 8
// wait ( 0 0$2 ) ;
 116: LD_INT 70
 118: PPUSH
 119: CALL_OW 67
// PrepareArabian ;
 123: CALL 3282 0 0
// PrepareKurtGroup ;
 127: CALL 2881 0 0
// PrepareSheikGroup ;
 131: CALL 2519 0 0
// PrepareHeikeGroup ;
 135: CALL 2431 0 0
// CenterNowOnXY ( 51 , 85 ) ;
 139: LD_INT 51
 141: PPUSH
 142: LD_INT 85
 144: PPUSH
 145: CALL_OW 86
// PlaceSeeing ( 1 , 1 , 5 , - 32763 ) ;
 149: LD_INT 1
 151: PPUSH
 152: LD_INT 1
 154: PPUSH
 155: LD_INT 5
 157: PPUSH
 158: LD_INT 32763
 160: NEG
 161: PPUSH
 162: CALL_OW 330
// RemoveSeeing ( 1 , 1 , 5 ) ;
 166: LD_INT 1
 168: PPUSH
 169: LD_INT 1
 171: PPUSH
 172: LD_INT 5
 174: PPUSH
 175: CALL_OW 331
// ComMoveXY ( [ Heike , Kaia ] , 53 , 88 ) ;
 179: LD_EXP 1
 183: PUSH
 184: LD_EXP 5
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: PPUSH
 193: LD_INT 53
 195: PPUSH
 196: LD_INT 88
 198: PPUSH
 199: CALL_OW 111
// wait ( 0 0$1 ) ;
 203: LD_INT 35
 205: PPUSH
 206: CALL_OW 67
// Say ( Kaia , DK-1 ) ;
 210: LD_EXP 5
 214: PPUSH
 215: LD_STRING DK-1
 217: PPUSH
 218: CALL_OW 88
// Say ( Heike , DH-1 ) ;
 222: LD_EXP 1
 226: PPUSH
 227: LD_STRING DH-1
 229: PPUSH
 230: CALL_OW 88
// wait ( 0 0$2 ) ;
 234: LD_INT 70
 236: PPUSH
 237: CALL_OW 67
// PrepareArabian ;
 241: CALL 3282 0 0
// InGameOff ;
 245: CALL_OW 9
// ChangeMissionObjectives ( O1 ) ;
 249: LD_STRING O1
 251: PPUSH
 252: CALL_OW 337
// goWithHeike := true ;
 256: LD_ADDR_EXP 17
 260: PUSH
 261: LD_INT 1
 263: ST_TO_ADDR
// SaveForQuickRestart ;
 264: CALL_OW 22
// end ;
 268: LD_VAR 0 1
 272: RET
// every 0 0$1 trigger GetAttitude ( 2 , 5 ) = att_enemy do var i ;
 273: LD_INT 2
 275: PPUSH
 276: LD_INT 5
 278: PPUSH
 279: CALL_OW 81
 283: PUSH
 284: LD_INT 2
 286: EQUAL
 287: IFFALSE 433
 289: GO 291
 291: DISABLE
 292: LD_INT 0
 294: PPUSH
// begin goWithHeike := false ;
 295: LD_ADDR_EXP 17
 299: PUSH
 300: LD_INT 0
 302: ST_TO_ADDR
// DialogueOn ;
 303: CALL_OW 6
// CenterNowOnUnits ( Heike ) ;
 307: LD_EXP 1
 311: PPUSH
 312: CALL_OW 87
// Say ( Kaia , DK-betray-1 ) ;
 316: LD_EXP 5
 320: PPUSH
 321: LD_STRING DK-betray-1
 323: PPUSH
 324: CALL_OW 88
// DialogueOff ;
 328: CALL_OW 7
// ComMoveXY ( Kaia , 90 , 46 ) ;
 332: LD_EXP 5
 336: PPUSH
 337: LD_INT 90
 339: PPUSH
 340: LD_INT 46
 342: PPUSH
 343: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
 347: LD_INT 35
 349: PPUSH
 350: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 5 ] , [ f_class , 1 ] ] ) diff Kaia do
 354: LD_ADDR_VAR 0 1
 358: PUSH
 359: LD_INT 22
 361: PUSH
 362: LD_INT 5
 364: PUSH
 365: EMPTY
 366: LIST
 367: LIST
 368: PUSH
 369: LD_INT 25
 371: PUSH
 372: LD_INT 1
 374: PUSH
 375: EMPTY
 376: LIST
 377: LIST
 378: PUSH
 379: EMPTY
 380: LIST
 381: LIST
 382: PPUSH
 383: CALL_OW 69
 387: PUSH
 388: LD_EXP 5
 392: DIFF
 393: PUSH
 394: FOR_IN
 395: IFFALSE 413
// ComAttackUnit ( i , Heike ) ;
 397: LD_VAR 0 1
 401: PPUSH
 402: LD_EXP 1
 406: PPUSH
 407: CALL_OW 115
 411: GO 394
 413: POP
 414: POP
// until IsDead ( Heike ) ;
 415: LD_EXP 1
 419: PPUSH
 420: CALL_OW 301
 424: IFFALSE 347
// YouLost ( Betray ) ;
 426: LD_STRING Betray
 428: PPUSH
 429: CALL_OW 104
// end ;
 433: PPOPN 1
 435: END
// every 0 0$1 trigger goWithHeike do
 436: LD_EXP 17
 440: IFFALSE 495
 442: GO 444
 444: DISABLE
// begin enable ;
 445: ENABLE
// if GetDistUnits ( Heike , Kaia ) > 3 then
 446: LD_EXP 1
 450: PPUSH
 451: LD_EXP 5
 455: PPUSH
 456: CALL_OW 296
 460: PUSH
 461: LD_INT 3
 463: GREATER
 464: IFFALSE 495
// ComMoveXY ( Kaia , GetX ( Heike ) , GetY ( Heike ) ) ;
 466: LD_EXP 5
 470: PPUSH
 471: LD_EXP 1
 475: PPUSH
 476: CALL_OW 250
 480: PPUSH
 481: LD_EXP 1
 485: PPUSH
 486: CALL_OW 251
 490: PPUSH
 491: CALL_OW 111
// end ;
 495: END
// every 0 0$2 trigger SeeXY ( 2 , 47 , 68 ) and not baseSpotted do
 496: LD_INT 2
 498: PPUSH
 499: LD_INT 47
 501: PPUSH
 502: LD_INT 68
 504: PPUSH
 505: CALL_OW 293
 509: PUSH
 510: LD_EXP 18
 514: NOT
 515: AND
 516: IFFALSE 560
 518: GO 520
 520: DISABLE
// begin Say ( Heike , DH-spot-1 ) ;
 521: LD_EXP 1
 525: PPUSH
 526: LD_STRING DH-spot-1
 528: PPUSH
 529: CALL_OW 88
// Say ( UnitsInside ( HexInfo ( 47 , 68 ) ) [ 1 ] , DR-spot-1 ) ;
 533: LD_INT 47
 535: PPUSH
 536: LD_INT 68
 538: PPUSH
 539: CALL_OW 428
 543: PPUSH
 544: CALL_OW 313
 548: PUSH
 549: LD_INT 1
 551: ARRAY
 552: PPUSH
 553: LD_STRING DR-spot-1
 555: PPUSH
 556: CALL_OW 88
// end ;
 560: END
// every 0 0$2 trigger SeeXY ( 2 , 93 , 89 ) and not baseSpotted do
 561: LD_INT 2
 563: PPUSH
 564: LD_INT 93
 566: PPUSH
 567: LD_INT 89
 569: PPUSH
 570: CALL_OW 293
 574: PUSH
 575: LD_EXP 18
 579: NOT
 580: AND
 581: IFFALSE 625
 583: GO 585
 585: DISABLE
// begin Say ( Heike , DH-spot-1 ) ;
 586: LD_EXP 1
 590: PPUSH
 591: LD_STRING DH-spot-1
 593: PPUSH
 594: CALL_OW 88
// Say ( UnitsInside ( HexInfo ( 93 , 89 ) ) [ 1 ] , DR-spot-2 ) ;
 598: LD_INT 93
 600: PPUSH
 601: LD_INT 89
 603: PPUSH
 604: CALL_OW 428
 608: PPUSH
 609: CALL_OW 313
 613: PUSH
 614: LD_INT 1
 616: ARRAY
 617: PPUSH
 618: LD_STRING DR-spot-2
 620: PPUSH
 621: CALL_OW 88
// end ;
 625: END
// every 0 0$3 trigger meetingActive and UnitFilter ( eonGuards , [ f_see , 2 ] ) do var tmp , i , points , dist , tdist ;
 626: LD_EXP 20
 630: PUSH
 631: LD_EXP 14
 635: PPUSH
 636: LD_INT 101
 638: PUSH
 639: LD_INT 2
 641: PUSH
 642: EMPTY
 643: LIST
 644: LIST
 645: PPUSH
 646: CALL_OW 72
 650: AND
 651: IFFALSE 975
 653: GO 655
 655: DISABLE
 656: LD_INT 0
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// begin enable ;
 663: ENABLE
// tmp := UnitFilter ( eonGuards , [ f_see , 2 ] ) ;
 664: LD_ADDR_VAR 0 1
 668: PUSH
 669: LD_EXP 14
 673: PPUSH
 674: LD_INT 101
 676: PUSH
 677: LD_INT 2
 679: PUSH
 680: EMPTY
 681: LIST
 682: LIST
 683: PPUSH
 684: CALL_OW 72
 688: ST_TO_ADDR
// if not tmp then
 689: LD_VAR 0 1
 693: NOT
 694: IFFALSE 698
// exit ;
 696: GO 975
// InGameOn ;
 698: CALL_OW 8
// ComTurnUnit ( [ Heike , Kaia ] , tmp [ 1 ] ) ;
 702: LD_EXP 1
 706: PUSH
 707: LD_EXP 5
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: PPUSH
 716: LD_VAR 0 1
 720: PUSH
 721: LD_INT 1
 723: ARRAY
 724: PPUSH
 725: CALL_OW 119
// ComTurnUnit ( tmp [ 1 ] , Heike ) ;
 729: LD_VAR 0 1
 733: PUSH
 734: LD_INT 1
 736: ARRAY
 737: PPUSH
 738: LD_EXP 1
 742: PPUSH
 743: CALL_OW 119
// Say ( tmp [ 1 ] , DG-meeting-1 ) ;
 747: LD_VAR 0 1
 751: PUSH
 752: LD_INT 1
 754: ARRAY
 755: PPUSH
 756: LD_STRING DG-meeting-1
 758: PPUSH
 759: CALL_OW 88
// points := [ [ 81 , 10 ] , [ 63 , 25 ] , [ 108 , 73 ] ] ;
 763: LD_ADDR_VAR 0 3
 767: PUSH
 768: LD_INT 81
 770: PUSH
 771: LD_INT 10
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: PUSH
 778: LD_INT 63
 780: PUSH
 781: LD_INT 25
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 108
 790: PUSH
 791: LD_INT 73
 793: PUSH
 794: EMPTY
 795: LIST
 796: LIST
 797: PUSH
 798: EMPTY
 799: LIST
 800: LIST
 801: LIST
 802: ST_TO_ADDR
// dist := [ 9999 , [ ] ] ;
 803: LD_ADDR_VAR 0 4
 807: PUSH
 808: LD_INT 9999
 810: PUSH
 811: EMPTY
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: ST_TO_ADDR
// for i := 1 to 3 do
 817: LD_ADDR_VAR 0 2
 821: PUSH
 822: DOUBLE
 823: LD_INT 1
 825: DEC
 826: ST_TO_ADDR
 827: LD_INT 3
 829: PUSH
 830: FOR_TO
 831: IFFALSE 915
// begin tdist := GetDistUnitXY ( Heike , points [ i ] [ 1 ] , points [ i ] [ 2 ] ) ;
 833: LD_ADDR_VAR 0 5
 837: PUSH
 838: LD_EXP 1
 842: PPUSH
 843: LD_VAR 0 3
 847: PUSH
 848: LD_VAR 0 2
 852: ARRAY
 853: PUSH
 854: LD_INT 1
 856: ARRAY
 857: PPUSH
 858: LD_VAR 0 3
 862: PUSH
 863: LD_VAR 0 2
 867: ARRAY
 868: PUSH
 869: LD_INT 2
 871: ARRAY
 872: PPUSH
 873: CALL_OW 297
 877: ST_TO_ADDR
// if dist [ 1 ] > tdist then
 878: LD_VAR 0 4
 882: PUSH
 883: LD_INT 1
 885: ARRAY
 886: PUSH
 887: LD_VAR 0 5
 891: GREATER
 892: IFFALSE 913
// dist := [ tdist , i ] ;
 894: LD_ADDR_VAR 0 4
 898: PUSH
 899: LD_VAR 0 5
 903: PUSH
 904: LD_VAR 0 2
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: ST_TO_ADDR
// end ;
 913: GO 830
 915: POP
 916: POP
// ComMoveXY ( Heike , points [ dist [ 2 ] ] [ 1 ] , points [ dist [ 2 ] ] [ 2 ] ) ;
 917: LD_EXP 1
 921: PPUSH
 922: LD_VAR 0 3
 926: PUSH
 927: LD_VAR 0 4
 931: PUSH
 932: LD_INT 2
 934: ARRAY
 935: ARRAY
 936: PUSH
 937: LD_INT 1
 939: ARRAY
 940: PPUSH
 941: LD_VAR 0 3
 945: PUSH
 946: LD_VAR 0 4
 950: PUSH
 951: LD_INT 2
 953: ARRAY
 954: ARRAY
 955: PUSH
 956: LD_INT 2
 958: ARRAY
 959: PPUSH
 960: CALL_OW 111
// wait ( 0 0$3 ) ;
 964: LD_INT 105
 966: PPUSH
 967: CALL_OW 67
// InGameOff ;
 971: CALL_OW 9
// end ;
 975: PPOPN 5
 977: END
// every 0 0$20 trigger GetDistUnits ( Heike , eon ) > 40 and IsIdle ( Heike ) do
 978: LD_EXP 1
 982: PPUSH
 983: LD_INT 14
 985: PPUSH
 986: CALL_OW 296
 990: PUSH
 991: LD_INT 40
 993: GREATER
 994: PUSH
 995: LD_EXP 1
 999: PPUSH
1000: CALL_OW 316
1004: AND
1005: IFFALSE 1022
1007: GO 1009
1009: DISABLE
// begin Say ( Kaia , DK-idle-1 ) ;
1010: LD_EXP 5
1014: PPUSH
1015: LD_STRING DK-idle-1
1017: PPUSH
1018: CALL_OW 88
// end ;
1022: END
// every 0 0$2 trigger SeeXY ( 2 , 59 , 47 ) do
1023: LD_INT 2
1025: PPUSH
1026: LD_INT 59
1028: PPUSH
1029: LD_INT 47
1031: PPUSH
1032: CALL_OW 293
1036: IFFALSE 1186
1038: GO 1040
1040: DISABLE
// begin PlaceSeeing ( 59 , 47 , 2 , - 10 ) ;
1041: LD_INT 59
1043: PPUSH
1044: LD_INT 47
1046: PPUSH
1047: LD_INT 2
1049: PPUSH
1050: LD_INT 10
1052: NEG
1053: PPUSH
1054: CALL_OW 330
// CenterNowOnXY ( 59 , 47 ) ;
1058: LD_INT 59
1060: PPUSH
1061: LD_INT 47
1063: PPUSH
1064: CALL_OW 86
// goWithHeike := false ;
1068: LD_ADDR_EXP 17
1072: PUSH
1073: LD_INT 0
1075: ST_TO_ADDR
// baseSpotted := true ;
1076: LD_ADDR_EXP 18
1080: PUSH
1081: LD_INT 1
1083: ST_TO_ADDR
// InGameOn ;
1084: CALL_OW 8
// ComMoveXY ( [ Heike , Kaia ] , 54 , 45 ) ;
1088: LD_EXP 1
1092: PUSH
1093: LD_EXP 5
1097: PUSH
1098: EMPTY
1099: LIST
1100: LIST
1101: PPUSH
1102: LD_INT 54
1104: PPUSH
1105: LD_INT 45
1107: PPUSH
1108: CALL_OW 111
// AddComTurnXY ( [ Heike , Kaia ] , 59 , 47 ) ;
1112: LD_EXP 1
1116: PUSH
1117: LD_EXP 5
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: PPUSH
1126: LD_INT 59
1128: PPUSH
1129: LD_INT 47
1131: PPUSH
1132: CALL_OW 178
// Say ( Heike , DH-base-1 ) ;
1136: LD_EXP 1
1140: PPUSH
1141: LD_STRING DH-base-1
1143: PPUSH
1144: CALL_OW 88
// Say ( Kaia , DK-base-1 ) ;
1148: LD_EXP 5
1152: PPUSH
1153: LD_STRING DK-base-1
1155: PPUSH
1156: CALL_OW 88
// InGameOff ;
1160: CALL_OW 9
// foundPoints := foundPoints + 1 ;
1164: LD_ADDR_EXP 16
1168: PUSH
1169: LD_EXP 16
1173: PUSH
1174: LD_INT 1
1176: PLUS
1177: ST_TO_ADDR
// goWithHeike := true ;
1178: LD_ADDR_EXP 17
1182: PUSH
1183: LD_INT 1
1185: ST_TO_ADDR
// end ;
1186: END
// every 0 0$2 trigger See ( 2 , Kurt ) do var i , tmp , tmp2 ;
1187: LD_INT 2
1189: PPUSH
1190: LD_EXP 8
1194: PPUSH
1195: CALL_OW 292
1199: IFFALSE 2428
1201: GO 1203
1203: DISABLE
1204: LD_INT 0
1206: PPUSH
1207: PPUSH
1208: PPUSH
// begin meetingActive := false ;
1209: LD_ADDR_EXP 20
1213: PUSH
1214: LD_INT 0
1216: ST_TO_ADDR
// goWithHeike := false ;
1217: LD_ADDR_EXP 17
1221: PUSH
1222: LD_INT 0
1224: ST_TO_ADDR
// tmp := AreaToList ( eonSpawn , 0 ) ;
1225: LD_ADDR_VAR 0 2
1229: PUSH
1230: LD_INT 6
1232: PPUSH
1233: LD_INT 0
1235: PPUSH
1236: CALL_OW 517
1240: ST_TO_ADDR
// for i := 1 to 4 do
1241: LD_ADDR_VAR 0 1
1245: PUSH
1246: DOUBLE
1247: LD_INT 1
1249: DEC
1250: ST_TO_ADDR
1251: LD_INT 4
1253: PUSH
1254: FOR_TO
1255: IFFALSE 1322
// begin ComMoveXY ( firstGroup [ i ] , tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) ;
1257: LD_EXP 15
1261: PUSH
1262: LD_VAR 0 1
1266: ARRAY
1267: PPUSH
1268: LD_VAR 0 2
1272: PUSH
1273: LD_INT 1
1275: ARRAY
1276: PUSH
1277: LD_VAR 0 1
1281: ARRAY
1282: PPUSH
1283: LD_VAR 0 2
1287: PUSH
1288: LD_INT 2
1290: ARRAY
1291: PUSH
1292: LD_VAR 0 1
1296: ARRAY
1297: PPUSH
1298: CALL_OW 111
// AddComTurnUnit ( firstGroup [ i ] , eon ) ;
1302: LD_EXP 15
1306: PUSH
1307: LD_VAR 0 1
1311: ARRAY
1312: PPUSH
1313: LD_INT 14
1315: PPUSH
1316: CALL_OW 179
// end ;
1320: GO 1254
1322: POP
1323: POP
// InGameOn ;
1324: CALL_OW 8
// ComMoveUnit ( Heike , Kurt ) ;
1328: LD_EXP 1
1332: PPUSH
1333: LD_EXP 8
1337: PPUSH
1338: CALL_OW 112
// ComMoveUnit ( Kaia , Heike ) ;
1342: LD_EXP 5
1346: PPUSH
1347: LD_EXP 1
1351: PPUSH
1352: CALL_OW 112
// repeat wait ( 0 0$0.3 ) ;
1356: LD_INT 10
1358: PPUSH
1359: CALL_OW 67
// ComMoveUnit ( Heike , Kurt ) ;
1363: LD_EXP 1
1367: PPUSH
1368: LD_EXP 8
1372: PPUSH
1373: CALL_OW 112
// ComMoveXY ( Kaia , ShiftX ( GetX ( Heike ) , 5 , 1 ) , ShiftY ( GetY ( Heike ) , 5 , 1 ) ) ;
1377: LD_EXP 5
1381: PPUSH
1382: LD_EXP 1
1386: PPUSH
1387: CALL_OW 250
1391: PPUSH
1392: LD_INT 5
1394: PPUSH
1395: LD_INT 1
1397: PPUSH
1398: CALL_OW 272
1402: PPUSH
1403: LD_EXP 1
1407: PPUSH
1408: CALL_OW 251
1412: PPUSH
1413: LD_INT 5
1415: PPUSH
1416: LD_INT 1
1418: PPUSH
1419: CALL_OW 273
1423: PPUSH
1424: CALL_OW 111
// until GetDistUnits ( Heike , Kurt ) < 5 and GetDistUnits ( Kaia , Kurt ) < 6 ;
1428: LD_EXP 1
1432: PPUSH
1433: LD_EXP 8
1437: PPUSH
1438: CALL_OW 296
1442: PUSH
1443: LD_INT 5
1445: LESS
1446: PUSH
1447: LD_EXP 5
1451: PPUSH
1452: LD_EXP 8
1456: PPUSH
1457: CALL_OW 296
1461: PUSH
1462: LD_INT 6
1464: LESS
1465: AND
1466: IFFALSE 1356
// ComTurnUnit ( [ Heike , Kaia ] , Kurt ) ;
1468: LD_EXP 1
1472: PUSH
1473: LD_EXP 5
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PPUSH
1482: LD_EXP 8
1486: PPUSH
1487: CALL_OW 119
// ComTurnUnit ( [ Kurt , Olaf , Hans ] , Heike ) ;
1491: LD_EXP 8
1495: PUSH
1496: LD_EXP 4
1500: PUSH
1501: LD_EXP 9
1505: PUSH
1506: EMPTY
1507: LIST
1508: LIST
1509: LIST
1510: PPUSH
1511: LD_EXP 1
1515: PPUSH
1516: CALL_OW 119
// wait ( 0 0$0.2 ) ;
1520: LD_INT 7
1522: PPUSH
1523: CALL_OW 67
// Say ( Kurt , DKu-Kurt-1 ) ;
1527: LD_EXP 8
1531: PPUSH
1532: LD_STRING DKu-Kurt-1
1534: PPUSH
1535: CALL_OW 88
// Say ( Kaia , DK-Kurt-1 ) ;
1539: LD_EXP 5
1543: PPUSH
1544: LD_STRING DK-Kurt-1
1546: PPUSH
1547: CALL_OW 88
// Say ( Kurt , DKu-Kurt-2 ) ;
1551: LD_EXP 8
1555: PPUSH
1556: LD_STRING DKu-Kurt-2
1558: PPUSH
1559: CALL_OW 88
// wait ( 0 0$0.2 ) ;
1563: LD_INT 7
1565: PPUSH
1566: CALL_OW 67
// Say ( Heike , DH-Kurt-1 ) ;
1570: LD_EXP 1
1574: PPUSH
1575: LD_STRING DH-Kurt-1
1577: PPUSH
1578: CALL_OW 88
// Say ( Kurt , DKu-Kurt-3 ) ;
1582: LD_EXP 8
1586: PPUSH
1587: LD_STRING DKu-Kurt-3
1589: PPUSH
1590: CALL_OW 88
// Say ( Kaia , DK-Kurt-3 ) ;
1594: LD_EXP 5
1598: PPUSH
1599: LD_STRING DK-Kurt-3
1601: PPUSH
1602: CALL_OW 88
// Say ( Hans , DHa-Kurt-3 ) ;
1606: LD_EXP 9
1610: PPUSH
1611: LD_STRING DHa-Kurt-3
1613: PPUSH
1614: CALL_OW 88
// Say ( Olaf , DO-Kurt-3 ) ;
1618: LD_EXP 4
1622: PPUSH
1623: LD_STRING DO-Kurt-3
1625: PPUSH
1626: CALL_OW 88
// tmp2 := [ Kurt , Olaf , Hans , Kaia , Heike ] ;
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: LD_EXP 8
1639: PUSH
1640: LD_EXP 4
1644: PUSH
1645: LD_EXP 9
1649: PUSH
1650: LD_EXP 5
1654: PUSH
1655: LD_EXP 1
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: ST_TO_ADDR
// for i = 1 to 5 do
1667: LD_ADDR_VAR 0 1
1671: PUSH
1672: DOUBLE
1673: LD_INT 1
1675: DEC
1676: ST_TO_ADDR
1677: LD_INT 5
1679: PUSH
1680: FOR_TO
1681: IFFALSE 1756
// begin ComMoveXY ( tmp2 [ i ] , tmp [ 1 ] [ i + 4 ] , tmp [ 2 ] [ i + 4 ] ) ;
1683: LD_VAR 0 3
1687: PUSH
1688: LD_VAR 0 1
1692: ARRAY
1693: PPUSH
1694: LD_VAR 0 2
1698: PUSH
1699: LD_INT 1
1701: ARRAY
1702: PUSH
1703: LD_VAR 0 1
1707: PUSH
1708: LD_INT 4
1710: PLUS
1711: ARRAY
1712: PPUSH
1713: LD_VAR 0 2
1717: PUSH
1718: LD_INT 2
1720: ARRAY
1721: PUSH
1722: LD_VAR 0 1
1726: PUSH
1727: LD_INT 4
1729: PLUS
1730: ARRAY
1731: PPUSH
1732: CALL_OW 111
// AddComTurnUnit ( tmp2 [ i ] , eon ) ;
1736: LD_VAR 0 3
1740: PUSH
1741: LD_VAR 0 1
1745: ARRAY
1746: PPUSH
1747: LD_INT 14
1749: PPUSH
1750: CALL_OW 179
// end ;
1754: GO 1680
1756: POP
1757: POP
// wait ( 0 0$2 ) ;
1758: LD_INT 70
1760: PPUSH
1761: CALL_OW 67
// CenterOnUnits ( eon ) ;
1765: LD_INT 14
1767: PPUSH
1768: CALL_OW 85
// PlaceSeeing ( 90 , 43 , 2 , - 21 ) ;
1772: LD_INT 90
1774: PPUSH
1775: LD_INT 43
1777: PPUSH
1778: LD_INT 2
1780: PPUSH
1781: LD_INT 21
1783: NEG
1784: PPUSH
1785: CALL_OW 330
// ComMoveXY ( Omar , 84 , 36 ) ;
1789: LD_EXP 2
1793: PPUSH
1794: LD_INT 84
1796: PPUSH
1797: LD_INT 36
1799: PPUSH
1800: CALL_OW 111
// AddComTurnUnit ( Omar , eon ) ;
1804: LD_EXP 2
1808: PPUSH
1809: LD_INT 14
1811: PPUSH
1812: CALL_OW 179
// ComMoveXY ( Shariff , 85 , 36 ) ;
1816: LD_EXP 11
1820: PPUSH
1821: LD_INT 85
1823: PPUSH
1824: LD_INT 36
1826: PPUSH
1827: CALL_OW 111
// AddComTurnUnit ( Shariff , eon ) ;
1831: LD_EXP 11
1835: PPUSH
1836: LD_INT 14
1838: PPUSH
1839: CALL_OW 179
// ComMoveXY ( Saliba , 86 , 36 ) ;
1843: LD_EXP 10
1847: PPUSH
1848: LD_INT 86
1850: PPUSH
1851: LD_INT 36
1853: PPUSH
1854: CALL_OW 111
// AddComTurnUnit ( Saliba , eon ) ;
1858: LD_EXP 10
1862: PPUSH
1863: LD_INT 14
1865: PPUSH
1866: CALL_OW 179
// ComMoveXY ( Mahtab , 87 , 36 ) ;
1870: LD_EXP 7
1874: PPUSH
1875: LD_INT 87
1877: PPUSH
1878: LD_INT 36
1880: PPUSH
1881: CALL_OW 111
// AddComTurnUnit ( Mahtab , eon ) ;
1885: LD_EXP 7
1889: PPUSH
1890: LD_INT 14
1892: PPUSH
1893: CALL_OW 179
// wait ( 0 0$3 ) ;
1897: LD_INT 105
1899: PPUSH
1900: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
1904: LD_INT 35
1906: PPUSH
1907: CALL_OW 67
// until IsInArea ( Heike , eonSpawn ) ;
1911: LD_EXP 1
1915: PPUSH
1916: LD_INT 6
1918: PPUSH
1919: CALL_OW 308
1923: IFFALSE 1904
// heikeNearbyEon := true ;
1925: LD_ADDR_EXP 19
1929: PUSH
1930: LD_INT 1
1932: ST_TO_ADDR
// ComMoveXY ( Shahrzad , 88 , 37 ) ;
1933: LD_EXP 6
1937: PPUSH
1938: LD_INT 88
1940: PPUSH
1941: LD_INT 37
1943: PPUSH
1944: CALL_OW 111
// AddComTurnUnit ( Shahrzad , scientists [ 1 ] ) ;
1948: LD_EXP 6
1952: PPUSH
1953: LD_EXP 13
1957: PUSH
1958: LD_INT 1
1960: ARRAY
1961: PPUSH
1962: CALL_OW 179
// ComMoveXY ( scientists [ 1 ] , 89 , 37 ) ;
1966: LD_EXP 13
1970: PUSH
1971: LD_INT 1
1973: ARRAY
1974: PPUSH
1975: LD_INT 89
1977: PPUSH
1978: LD_INT 37
1980: PPUSH
1981: CALL_OW 111
// ComMoveXY ( scientists [ 2 ] , 91 , 39 ) ;
1985: LD_EXP 13
1989: PUSH
1990: LD_INT 2
1992: ARRAY
1993: PPUSH
1994: LD_INT 91
1996: PPUSH
1997: LD_INT 39
1999: PPUSH
2000: CALL_OW 111
// AddComTurnUnit ( scientists , Shariff ) ;
2004: LD_EXP 13
2008: PPUSH
2009: LD_EXP 11
2013: PPUSH
2014: CALL_OW 179
// wait ( 0 0$1 ) ;
2018: LD_INT 35
2020: PPUSH
2021: CALL_OW 67
// Say ( scientists [ 1 ] , DS-eon-1 ) ;
2025: LD_EXP 13
2029: PUSH
2030: LD_INT 1
2032: ARRAY
2033: PPUSH
2034: LD_STRING DS-eon-1
2036: PPUSH
2037: CALL_OW 88
// Say ( Shahrzad , DSh-eon-1 ) ;
2041: LD_EXP 6
2045: PPUSH
2046: LD_STRING DSh-eon-1
2048: PPUSH
2049: CALL_OW 88
// ComMoveXY ( scientists [ 1 ] , 92 , 43 ) ;
2053: LD_EXP 13
2057: PUSH
2058: LD_INT 1
2060: ARRAY
2061: PPUSH
2062: LD_INT 92
2064: PPUSH
2065: LD_INT 43
2067: PPUSH
2068: CALL_OW 111
// AddComTurnUnit ( scientists [ 1 ] , eon ) ;
2072: LD_EXP 13
2076: PUSH
2077: LD_INT 1
2079: ARRAY
2080: PPUSH
2081: LD_INT 14
2083: PPUSH
2084: CALL_OW 179
// ComMoveXY ( scientists [ 2 ] , 93 , 41 ) ;
2088: LD_EXP 13
2092: PUSH
2093: LD_INT 2
2095: ARRAY
2096: PPUSH
2097: LD_INT 93
2099: PPUSH
2100: LD_INT 41
2102: PPUSH
2103: CALL_OW 111
// AddComTurnXY ( scientists [ 2 ] , 93 , 40 ) ;
2107: LD_EXP 13
2111: PUSH
2112: LD_INT 2
2114: ARRAY
2115: PPUSH
2116: LD_INT 93
2118: PPUSH
2119: LD_INT 40
2121: PPUSH
2122: CALL_OW 178
// ComMoveXY ( Shahrzad , 88 , 41 ) ;
2126: LD_EXP 6
2130: PPUSH
2131: LD_INT 88
2133: PPUSH
2134: LD_INT 41
2136: PPUSH
2137: CALL_OW 111
// AddComTurnXY ( Shahrzad , 87 , 41 ) ;
2141: LD_EXP 6
2145: PPUSH
2146: LD_INT 87
2148: PPUSH
2149: LD_INT 41
2151: PPUSH
2152: CALL_OW 178
// repeat wait ( 0 0$1 ) ;
2156: LD_INT 35
2158: PPUSH
2159: CALL_OW 67
// until IsAt ( Shahrzad , 88 , 41 ) ;
2163: LD_EXP 6
2167: PPUSH
2168: LD_INT 88
2170: PPUSH
2171: LD_INT 41
2173: PPUSH
2174: CALL_OW 307
2178: IFFALSE 2156
// wait ( 0 0$1 ) ;
2180: LD_INT 35
2182: PPUSH
2183: CALL_OW 67
// Say ( Shahrzad , DSh-eon-2 ) ;
2187: LD_EXP 6
2191: PPUSH
2192: LD_STRING DSh-eon-2
2194: PPUSH
2195: CALL_OW 88
// ComMoveXY ( Shariff , 87 , 40 ) ;
2199: LD_EXP 11
2203: PPUSH
2204: LD_INT 87
2206: PPUSH
2207: LD_INT 40
2209: PPUSH
2210: CALL_OW 111
// AddComTurnXY ( Shariff , 86 , 40 ) ;
2214: LD_EXP 11
2218: PPUSH
2219: LD_INT 86
2221: PPUSH
2222: LD_INT 40
2224: PPUSH
2225: CALL_OW 178
// repeat wait ( 0 0$1 ) ;
2229: LD_INT 35
2231: PPUSH
2232: CALL_OW 67
// until IsAt ( Shariff , 87 , 40 ) ;
2236: LD_EXP 11
2240: PPUSH
2241: LD_INT 87
2243: PPUSH
2244: LD_INT 40
2246: PPUSH
2247: CALL_OW 307
2251: IFFALSE 2229
// Say ( Shariff , DShar-eon-3 ) ;
2253: LD_EXP 11
2257: PPUSH
2258: LD_STRING DShar-eon-3
2260: PPUSH
2261: CALL_OW 88
// Say ( Shariff , DShar-eon-4 ) ;
2265: LD_EXP 11
2269: PPUSH
2270: LD_STRING DShar-eon-4
2272: PPUSH
2273: CALL_OW 88
// Say ( Kaia , DK-eon-4 ) ;
2277: LD_EXP 5
2281: PPUSH
2282: LD_STRING DK-eon-4
2284: PPUSH
2285: CALL_OW 88
// ComEnterUnit ( Kaia , eon ) ;
2289: LD_EXP 5
2293: PPUSH
2294: LD_INT 14
2296: PPUSH
2297: CALL_OW 120
// repeat wait ( 0 0$1 ) ;
2301: LD_INT 35
2303: PPUSH
2304: CALL_OW 67
// until not IsPlaced ( Kaia ) ;
2308: LD_EXP 5
2312: PPUSH
2313: CALL_OW 305
2317: NOT
2318: IFFALSE 2301
// Say ( Shariff , DShar-eon-5 ) ;
2320: LD_EXP 11
2324: PPUSH
2325: LD_STRING DShar-eon-5
2327: PPUSH
2328: CALL_OW 88
// ComMoveXY ( Heike , 91 , 44 ) ;
2332: LD_EXP 1
2336: PPUSH
2337: LD_INT 91
2339: PPUSH
2340: LD_INT 44
2342: PPUSH
2343: CALL_OW 111
// AddComTurnUnit ( Heike , eon ) ;
2347: LD_EXP 1
2351: PPUSH
2352: LD_INT 14
2354: PPUSH
2355: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
2359: LD_INT 35
2361: PPUSH
2362: CALL_OW 67
// until IsAt ( Heike , 91 , 44 ) ;
2366: LD_EXP 1
2370: PPUSH
2371: LD_INT 91
2373: PPUSH
2374: LD_INT 44
2376: PPUSH
2377: CALL_OW 307
2381: IFFALSE 2359
// Say ( Heike , DH-eon-5 ) ;
2383: LD_EXP 1
2387: PPUSH
2388: LD_STRING DH-eon-5
2390: PPUSH
2391: CALL_OW 88
// ComEnterUnit ( Heike , eon ) ;
2395: LD_EXP 1
2399: PPUSH
2400: LD_INT 14
2402: PPUSH
2403: CALL_OW 120
// wait ( 0 0$2 ) ;
2407: LD_INT 70
2409: PPUSH
2410: CALL_OW 67
// ChangeMap ( 1 , %_cont ) ;
2414: LD_INT 1
2416: PPUSH
2417: LD_STRING %_cont
2419: PPUSH
2420: CALL_OW 340
// InGameOff ;
2424: CALL_OW 9
// end ; end_of_file
2428: PPOPN 3
2430: END
// export function PrepareHeikeGroup ; begin
2431: LD_INT 0
2433: PPUSH
// uc_side := 2 ;
2434: LD_ADDR_OWVAR 20
2438: PUSH
2439: LD_INT 2
2441: ST_TO_ADDR
// uc_nation := 2 ;
2442: LD_ADDR_OWVAR 21
2446: PUSH
2447: LD_INT 2
2449: ST_TO_ADDR
// Heike := NewCharacter ( Heike ) ;
2450: LD_ADDR_EXP 1
2454: PUSH
2455: LD_STRING Heike
2457: PPUSH
2458: CALL_OW 25
2462: ST_TO_ADDR
// uc_side := 5 ;
2463: LD_ADDR_OWVAR 20
2467: PUSH
2468: LD_INT 5
2470: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
2471: LD_ADDR_EXP 5
2475: PUSH
2476: LD_STRING Kaia
2478: PPUSH
2479: CALL_OW 25
2483: ST_TO_ADDR
// PlaceUnitArea ( Heike , startArea , false ) ;
2484: LD_EXP 1
2488: PPUSH
2489: LD_INT 3
2491: PPUSH
2492: LD_INT 0
2494: PPUSH
2495: CALL_OW 49
// PlaceUnitArea ( Kaia , startArea , false ) ;
2499: LD_EXP 5
2503: PPUSH
2504: LD_INT 3
2506: PPUSH
2507: LD_INT 0
2509: PPUSH
2510: CALL_OW 49
// end ;
2514: LD_VAR 0 1
2518: RET
// export function PrepareSheikGroup ; var un , i ; begin
2519: LD_INT 0
2521: PPUSH
2522: PPUSH
2523: PPUSH
// uc_side := 5 ;
2524: LD_ADDR_OWVAR 20
2528: PUSH
2529: LD_INT 5
2531: ST_TO_ADDR
// uc_nation := 2 ;
2532: LD_ADDR_OWVAR 21
2536: PUSH
2537: LD_INT 2
2539: ST_TO_ADDR
// Saliba := NewCharacter ( Ali ) ;
2540: LD_ADDR_EXP 10
2544: PUSH
2545: LD_STRING Ali
2547: PPUSH
2548: CALL_OW 25
2552: ST_TO_ADDR
// Shariff := NewCharacter ( Abdul ) ;
2553: LD_ADDR_EXP 11
2557: PUSH
2558: LD_STRING Abdul
2560: PPUSH
2561: CALL_OW 25
2565: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
2566: LD_ADDR_EXP 2
2570: PUSH
2571: LD_STRING Omar
2573: PPUSH
2574: CALL_OW 25
2578: ST_TO_ADDR
// Mahtab := NewCharacter ( Mahtab ) ;
2579: LD_ADDR_EXP 7
2583: PUSH
2584: LD_STRING Mahtab
2586: PPUSH
2587: CALL_OW 25
2591: ST_TO_ADDR
// Shahrzad := NewCharacter ( Shahrzad ) ;
2592: LD_ADDR_EXP 6
2596: PUSH
2597: LD_STRING Shahrzad
2599: PPUSH
2600: CALL_OW 25
2604: ST_TO_ADDR
// PlaceUnitXY ( Saliba , 85 , 37 , false ) ;
2605: LD_EXP 10
2609: PPUSH
2610: LD_INT 85
2612: PPUSH
2613: LD_INT 37
2615: PPUSH
2616: LD_INT 0
2618: PPUSH
2619: CALL_OW 48
// PlaceUnitXY ( Shariff , 87 , 37 , false ) ;
2623: LD_EXP 11
2627: PPUSH
2628: LD_INT 87
2630: PPUSH
2631: LD_INT 37
2633: PPUSH
2634: LD_INT 0
2636: PPUSH
2637: CALL_OW 48
// PlaceUnitXY ( Omar , 85 , 35 , false ) ;
2641: LD_EXP 2
2645: PPUSH
2646: LD_INT 85
2648: PPUSH
2649: LD_INT 35
2651: PPUSH
2652: LD_INT 0
2654: PPUSH
2655: CALL_OW 48
// PlaceUnitXY ( Mahtab , 86 , 39 , false ) ;
2659: LD_EXP 7
2663: PPUSH
2664: LD_INT 86
2666: PPUSH
2667: LD_INT 39
2669: PPUSH
2670: LD_INT 0
2672: PPUSH
2673: CALL_OW 48
// PlaceUnitXY ( Shahrzad , 88 , 39 , false ) ;
2677: LD_EXP 6
2681: PPUSH
2682: LD_INT 88
2684: PPUSH
2685: LD_INT 39
2687: PPUSH
2688: LD_INT 0
2690: PPUSH
2691: CALL_OW 48
// ComTurnUnit ( Saliba , Shariff ) ;
2695: LD_EXP 10
2699: PPUSH
2700: LD_EXP 11
2704: PPUSH
2705: CALL_OW 119
// ComTurnUnit ( Shariff , Saliba ) ;
2709: LD_EXP 11
2713: PPUSH
2714: LD_EXP 10
2718: PPUSH
2719: CALL_OW 119
// ComTurnUnit ( Omar , Shariff ) ;
2723: LD_EXP 2
2727: PPUSH
2728: LD_EXP 11
2732: PPUSH
2733: CALL_OW 119
// ComTurnUnit ( [ Mahtab , Shahrzad ] , Shariff ) ;
2737: LD_EXP 7
2741: PUSH
2742: LD_EXP 6
2746: PUSH
2747: EMPTY
2748: LIST
2749: LIST
2750: PPUSH
2751: LD_EXP 11
2755: PPUSH
2756: CALL_OW 119
// for i := 1 to 2 do
2760: LD_ADDR_VAR 0 3
2764: PUSH
2765: DOUBLE
2766: LD_INT 1
2768: DEC
2769: ST_TO_ADDR
2770: LD_INT 2
2772: PUSH
2773: FOR_TO
2774: IFFALSE 2860
// begin PrepareHuman ( false , 4 , 6 ) ;
2776: LD_INT 0
2778: PPUSH
2779: LD_INT 4
2781: PPUSH
2782: LD_INT 6
2784: PPUSH
2785: CALL_OW 380
// un := CreateHuman ;
2789: LD_ADDR_VAR 0 2
2793: PUSH
2794: CALL_OW 44
2798: ST_TO_ADDR
// PlaceUnitXYR ( un , 90 , 44 , 3 , false ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 90
2806: PPUSH
2807: LD_INT 44
2809: PPUSH
2810: LD_INT 3
2812: PPUSH
2813: LD_INT 0
2815: PPUSH
2816: CALL_OW 50
// ComTurnXY ( un , 91 , 43 ) ;
2820: LD_VAR 0 2
2824: PPUSH
2825: LD_INT 91
2827: PPUSH
2828: LD_INT 43
2830: PPUSH
2831: CALL_OW 118
// scientists := Insert ( scientists , 1 , un ) ;
2835: LD_ADDR_EXP 13
2839: PUSH
2840: LD_EXP 13
2844: PPUSH
2845: LD_INT 1
2847: PPUSH
2848: LD_VAR 0 2
2852: PPUSH
2853: CALL_OW 2
2857: ST_TO_ADDR
// end ;
2858: GO 2773
2860: POP
2861: POP
// scientists := scientists diff 0 ;
2862: LD_ADDR_EXP 13
2866: PUSH
2867: LD_EXP 13
2871: PUSH
2872: LD_INT 0
2874: DIFF
2875: ST_TO_ADDR
// end ;
2876: LD_VAR 0 1
2880: RET
// export function PrepareKurtGroup ; var i ; begin
2881: LD_INT 0
2883: PPUSH
2884: PPUSH
// uc_side := 5 ;
2885: LD_ADDR_OWVAR 20
2889: PUSH
2890: LD_INT 5
2892: ST_TO_ADDR
// uc_nation := 2 ;
2893: LD_ADDR_OWVAR 21
2897: PUSH
2898: LD_INT 2
2900: ST_TO_ADDR
// Kurt := NewCharacter ( Kurt ) ;
2901: LD_ADDR_EXP 8
2905: PUSH
2906: LD_STRING Kurt
2908: PPUSH
2909: CALL_OW 25
2913: ST_TO_ADDR
// Olaf := NewCharacter ( Olaf ) ;
2914: LD_ADDR_EXP 4
2918: PUSH
2919: LD_STRING Olaf
2921: PPUSH
2922: CALL_OW 25
2926: ST_TO_ADDR
// Hans := NewCharacter ( Hans ) ;
2927: LD_ADDR_EXP 9
2931: PUSH
2932: LD_STRING Hans
2934: PPUSH
2935: CALL_OW 25
2939: ST_TO_ADDR
// for i in [ Kurt , Hans , Olaf ] do
2940: LD_ADDR_VAR 0 2
2944: PUSH
2945: LD_EXP 8
2949: PUSH
2950: LD_EXP 9
2954: PUSH
2955: LD_EXP 4
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: LIST
2964: PUSH
2965: FOR_IN
2966: IFFALSE 2985
// PlaceUnitArea ( i , kurtSpawnArea , false ) ;
2968: LD_VAR 0 2
2972: PPUSH
2973: LD_INT 10
2975: PPUSH
2976: LD_INT 0
2978: PPUSH
2979: CALL_OW 49
2983: GO 2965
2985: POP
2986: POP
// ComTurnUnit ( Kurt , Hans ) ;
2987: LD_EXP 8
2991: PPUSH
2992: LD_EXP 9
2996: PPUSH
2997: CALL_OW 119
// ComTurnUnit ( Olaf , Hans ) ;
3001: LD_EXP 4
3005: PPUSH
3006: LD_EXP 9
3010: PPUSH
3011: CALL_OW 119
// ComTurnUnit ( Hans , Olaf ) ;
3015: LD_EXP 9
3019: PPUSH
3020: LD_EXP 4
3024: PPUSH
3025: CALL_OW 119
// end ;
3029: LD_VAR 0 1
3033: RET
// export function PrepareAmericanBase ; var i , un , tmp ; begin
3034: LD_INT 0
3036: PPUSH
3037: PPUSH
3038: PPUSH
3039: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_building ] ) diff eon do
3040: LD_ADDR_VAR 0 2
3044: PUSH
3045: LD_INT 21
3047: PUSH
3048: LD_INT 3
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: PPUSH
3055: CALL_OW 69
3059: PUSH
3060: LD_INT 14
3062: DIFF
3063: PUSH
3064: FOR_IN
3065: IFFALSE 3145
// begin if GetBType ( i ) in [ b_lab , b_breastwork ] then
3067: LD_VAR 0 2
3071: PPUSH
3072: CALL_OW 266
3076: PUSH
3077: LD_INT 6
3079: PUSH
3080: LD_INT 31
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: IN
3087: IFFALSE 3111
// SetLives ( i , rand ( 500 , 600 ) ) else
3089: LD_VAR 0 2
3093: PPUSH
3094: LD_INT 500
3096: PPUSH
3097: LD_INT 600
3099: PPUSH
3100: CALL_OW 12
3104: PPUSH
3105: CALL_OW 234
3109: GO 3131
// SetLives ( i , rand ( 300 , 499 ) ) ;
3111: LD_VAR 0 2
3115: PPUSH
3116: LD_INT 300
3118: PPUSH
3119: LD_INT 499
3121: PPUSH
3122: CALL_OW 12
3126: PPUSH
3127: CALL_OW 234
// SetSide ( i , 5 ) ;
3131: LD_VAR 0 2
3135: PPUSH
3136: LD_INT 5
3138: PPUSH
3139: CALL_OW 235
// end ;
3143: GO 3064
3145: POP
3146: POP
// tmp := AreaToList ( spawnBaseCorpses , 0 ) ;
3147: LD_ADDR_VAR 0 4
3151: PUSH
3152: LD_INT 9
3154: PPUSH
3155: LD_INT 0
3157: PPUSH
3158: CALL_OW 517
3162: ST_TO_ADDR
// uc_side := 4 ;
3163: LD_ADDR_OWVAR 20
3167: PUSH
3168: LD_INT 4
3170: ST_TO_ADDR
// uc_nation := 1 ;
3171: LD_ADDR_OWVAR 21
3175: PUSH
3176: LD_INT 1
3178: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
3179: LD_ADDR_VAR 0 2
3183: PUSH
3184: DOUBLE
3185: LD_INT 1
3187: DEC
3188: ST_TO_ADDR
3189: LD_VAR 0 4
3193: PUSH
3194: LD_INT 1
3196: ARRAY
3197: PUSH
3198: FOR_TO
3199: IFFALSE 3275
// begin PrepareHuman ( false , [ 1 , 1 , 4 ] [ i mod 3 + 1 ] , 0 ) ;
3201: LD_INT 0
3203: PPUSH
3204: LD_INT 1
3206: PUSH
3207: LD_INT 1
3209: PUSH
3210: LD_INT 4
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: LIST
3217: PUSH
3218: LD_VAR 0 2
3222: PUSH
3223: LD_INT 3
3225: MOD
3226: PUSH
3227: LD_INT 1
3229: PLUS
3230: ARRAY
3231: PPUSH
3232: LD_INT 0
3234: PPUSH
3235: CALL_OW 380
// un := CreateHuman ;
3239: LD_ADDR_VAR 0 3
3243: PUSH
3244: CALL_OW 44
3248: ST_TO_ADDR
// PlaceUnitArea ( un , spawnBaseCorpses , false ) ;
3249: LD_VAR 0 3
3253: PPUSH
3254: LD_INT 9
3256: PPUSH
3257: LD_INT 0
3259: PPUSH
3260: CALL_OW 49
// KillUnit ( un ) ;
3264: LD_VAR 0 3
3268: PPUSH
3269: CALL_OW 66
// end ;
3273: GO 3198
3275: POP
3276: POP
// end ;
3277: LD_VAR 0 1
3281: RET
// export function PrepareArabian ; var i , j , b , tmp , area , un ; begin
3282: LD_INT 0
3284: PPUSH
3285: PPUSH
3286: PPUSH
3287: PPUSH
3288: PPUSH
3289: PPUSH
3290: PPUSH
// uc_side := 5 ;
3291: LD_ADDR_OWVAR 20
3295: PUSH
3296: LD_INT 5
3298: ST_TO_ADDR
// uc_nation := 2 ;
3299: LD_ADDR_OWVAR 21
3303: PUSH
3304: LD_INT 2
3306: ST_TO_ADDR
// area := [ spawnBaseArea1 , spawnBaseArea2 , spawnBaseArea3 , spawnBaseArea4 ] ;
3307: LD_ADDR_VAR 0 6
3311: PUSH
3312: LD_INT 2
3314: PUSH
3315: LD_INT 4
3317: PUSH
3318: LD_INT 5
3320: PUSH
3321: LD_INT 14
3323: PUSH
3324: EMPTY
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: ST_TO_ADDR
// InitHc ;
3330: CALL_OW 19
// for i in area do
3334: LD_ADDR_VAR 0 2
3338: PUSH
3339: LD_VAR 0 6
3343: PUSH
3344: FOR_IN
3345: IFFALSE 3509
// begin tmp := AreaToList ( i , 0 ) ;
3347: LD_ADDR_VAR 0 5
3351: PUSH
3352: LD_VAR 0 2
3356: PPUSH
3357: LD_INT 0
3359: PPUSH
3360: CALL_OW 517
3364: ST_TO_ADDR
// for j := 1 to tmp [ 1 ] do
3365: LD_ADDR_VAR 0 3
3369: PUSH
3370: DOUBLE
3371: LD_INT 1
3373: DEC
3374: ST_TO_ADDR
3375: LD_VAR 0 5
3379: PUSH
3380: LD_INT 1
3382: ARRAY
3383: PUSH
3384: FOR_TO
3385: IFFALSE 3505
// begin PrepareHuman ( false , 1 , 3 ) ;
3387: LD_INT 0
3389: PPUSH
3390: LD_INT 1
3392: PPUSH
3393: LD_INT 3
3395: PPUSH
3396: CALL_OW 380
// un := CreateHuman ;
3400: LD_ADDR_VAR 0 7
3404: PUSH
3405: CALL_OW 44
3409: ST_TO_ADDR
// if i = spawnBaseArea3 then
3410: LD_VAR 0 2
3414: PUSH
3415: LD_INT 5
3417: EQUAL
3418: IFFALSE 3436
// eonGuards := eonGuards ^ un ;
3420: LD_ADDR_EXP 14
3424: PUSH
3425: LD_EXP 14
3429: PUSH
3430: LD_VAR 0 7
3434: ADD
3435: ST_TO_ADDR
// PlaceUnitArea ( un , i , false ) ;
3436: LD_VAR 0 7
3440: PPUSH
3441: LD_VAR 0 2
3445: PPUSH
3446: LD_INT 0
3448: PPUSH
3449: CALL_OW 49
// ComHold ( un ) ;
3453: LD_VAR 0 7
3457: PPUSH
3458: CALL_OW 140
// if i = spawnBaseArea4 then
3462: LD_VAR 0 2
3466: PUSH
3467: LD_INT 14
3469: EQUAL
3470: IFFALSE 3503
// begin firstGroup := firstGroup ^ un ;
3472: LD_ADDR_EXP 15
3476: PUSH
3477: LD_EXP 15
3481: PUSH
3482: LD_VAR 0 7
3486: ADD
3487: ST_TO_ADDR
// ComTurnXY ( un , 108 , 47 ) ;
3488: LD_VAR 0 7
3492: PPUSH
3493: LD_INT 108
3495: PPUSH
3496: LD_INT 47
3498: PPUSH
3499: CALL_OW 118
// end ; end ;
3503: GO 3384
3505: POP
3506: POP
// end ;
3507: GO 3344
3509: POP
3510: POP
// for i := 1 to FilterAllUnits ( [ f_btype , b_breastwork ] ) do
3511: LD_ADDR_VAR 0 2
3515: PUSH
3516: DOUBLE
3517: LD_INT 1
3519: DEC
3520: ST_TO_ADDR
3521: LD_INT 30
3523: PUSH
3524: LD_INT 31
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: PPUSH
3531: CALL_OW 69
3535: PUSH
3536: FOR_TO
3537: IFFALSE 3631
// begin b := FilterAllUnits ( [ f_btype , b_breastwork ] ) [ i ] ;
3539: LD_ADDR_VAR 0 4
3543: PUSH
3544: LD_INT 30
3546: PUSH
3547: LD_INT 31
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: PPUSH
3554: CALL_OW 69
3558: PUSH
3559: LD_VAR 0 2
3563: ARRAY
3564: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 3 ) ;
3565: LD_INT 1
3567: PPUSH
3568: LD_INT 1
3570: PPUSH
3571: LD_INT 3
3573: PPUSH
3574: CALL_OW 380
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 7
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , ( GetDir ( b ) + 3 ) mod 6 ) ;
3588: LD_VAR 0 7
3592: PPUSH
3593: LD_VAR 0 4
3597: PPUSH
3598: CALL_OW 254
3602: PUSH
3603: LD_INT 3
3605: PLUS
3606: PUSH
3607: LD_INT 6
3609: MOD
3610: PPUSH
3611: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
3615: LD_VAR 0 7
3619: PPUSH
3620: LD_VAR 0 4
3624: PPUSH
3625: CALL_OW 52
// end ;
3629: GO 3536
3631: POP
3632: POP
// end ; end_of_file
3633: LD_VAR 0 1
3637: RET
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
3638: LD_VAR 0 1
3642: PUSH
3643: LD_INT 2
3645: EQUAL
3646: PUSH
3647: LD_VAR 0 2
3651: PUSH
3652: LD_INT 5
3654: EQUAL
3655: AND
3656: IFFALSE 3674
// SetAttitude ( 2 , 5 , att_enemy , true ) ;
3658: LD_INT 2
3660: PPUSH
3661: LD_INT 5
3663: PPUSH
3664: LD_INT 2
3666: PPUSH
3667: LD_INT 1
3669: PPUSH
3670: CALL_OW 80
// end ;
3674: PPOPN 2
3676: END
// every 0 0$1 trigger scientists do var i ;
3677: LD_EXP 13
3681: IFFALSE 3889
3683: GO 3685
3685: DISABLE
3686: LD_INT 0
3688: PPUSH
// begin repeat for i in scientists do
3689: LD_ADDR_VAR 0 1
3693: PUSH
3694: LD_EXP 13
3698: PUSH
3699: FOR_IN
3700: IFFALSE 3874
// begin wait ( 0 0$1 ) ;
3702: LD_INT 35
3704: PPUSH
3705: CALL_OW 67
// if not IsInArea ( i , [ eonArea , eonArea2 ] [ i mod 2 + 1 ] ) then
3709: LD_VAR 0 1
3713: PPUSH
3714: LD_INT 11
3716: PUSH
3717: LD_INT 13
3719: PUSH
3720: EMPTY
3721: LIST
3722: LIST
3723: PUSH
3724: LD_VAR 0 1
3728: PUSH
3729: LD_INT 2
3731: MOD
3732: PUSH
3733: LD_INT 1
3735: PLUS
3736: ARRAY
3737: PPUSH
3738: CALL_OW 308
3742: NOT
3743: IFFALSE 3778
// ComMoveToArea ( i , [ eonArea , eonArea2 ] [ i mod 2 + 1 ] ) ;
3745: LD_VAR 0 1
3749: PPUSH
3750: LD_INT 11
3752: PUSH
3753: LD_INT 13
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: PUSH
3760: LD_VAR 0 1
3764: PUSH
3765: LD_INT 2
3767: MOD
3768: PUSH
3769: LD_INT 1
3771: PLUS
3772: ARRAY
3773: PPUSH
3774: CALL_OW 113
// AddComTurnUnit ( i , eon ) ;
3778: LD_VAR 0 1
3782: PPUSH
3783: LD_INT 14
3785: PPUSH
3786: CALL_OW 179
// AddComWait ( i , 0 0$2 ) ;
3790: LD_VAR 0 1
3794: PPUSH
3795: LD_INT 70
3797: PPUSH
3798: CALL_OW 202
// if rand ( 0 , 1 ) then
3802: LD_INT 0
3804: PPUSH
3805: LD_INT 1
3807: PPUSH
3808: CALL_OW 12
3812: IFFALSE 3826
// AddComAnim ( i , 15 ) ;
3814: LD_VAR 0 1
3818: PPUSH
3819: LD_INT 15
3821: PPUSH
3822: CALL_OW 209
// AddComWait ( i , 0 0$1 ) ;
3826: LD_VAR 0 1
3830: PPUSH
3831: LD_INT 35
3833: PPUSH
3834: CALL_OW 202
// AddComMoveToArea ( i , tableArea ) ;
3838: LD_VAR 0 1
3842: PPUSH
3843: LD_INT 12
3845: PPUSH
3846: CALL_OW 173
// AddComTurnXY ( i , 93 , 40 ) ;
3850: LD_VAR 0 1
3854: PPUSH
3855: LD_INT 93
3857: PPUSH
3858: LD_INT 40
3860: PPUSH
3861: CALL_OW 178
// wait ( 0 0$1 ) ;
3865: LD_INT 35
3867: PPUSH
3868: CALL_OW 67
// end ;
3872: GO 3699
3874: POP
3875: POP
// wait ( 0 0$10 ) ;
3876: LD_INT 350
3878: PPUSH
3879: CALL_OW 67
// until heikeNearbyEon ;
3883: LD_EXP 19
3887: IFFALSE 3689
// end ; end_of_file
3889: PPOPN 1
3891: END
// export StreamModeActive , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote ; every 0 0$1 do
3892: GO 3894
3894: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
3895: LD_STRING initStreamRollete();
3897: PPUSH
3898: CALL_OW 559
// InitStreamMode ;
3902: CALL 3907 0 0
// end ;
3906: END
// function InitStreamMode ; begin
3907: LD_INT 0
3909: PPUSH
// streamModeActive := false ;
3910: LD_ADDR_EXP 21
3914: PUSH
3915: LD_INT 0
3917: ST_TO_ADDR
// sRocket := false ;
3918: LD_ADDR_EXP 24
3922: PUSH
3923: LD_INT 0
3925: ST_TO_ADDR
// sSpeed := false ;
3926: LD_ADDR_EXP 23
3930: PUSH
3931: LD_INT 0
3933: ST_TO_ADDR
// sEngine := false ;
3934: LD_ADDR_EXP 25
3938: PUSH
3939: LD_INT 0
3941: ST_TO_ADDR
// sSpec := false ;
3942: LD_ADDR_EXP 22
3946: PUSH
3947: LD_INT 0
3949: ST_TO_ADDR
// sLevel := false ;
3950: LD_ADDR_EXP 26
3954: PUSH
3955: LD_INT 0
3957: ST_TO_ADDR
// sArmoury := false ;
3958: LD_ADDR_EXP 27
3962: PUSH
3963: LD_INT 0
3965: ST_TO_ADDR
// sRadar := false ;
3966: LD_ADDR_EXP 28
3970: PUSH
3971: LD_INT 0
3973: ST_TO_ADDR
// sBunker := false ;
3974: LD_ADDR_EXP 29
3978: PUSH
3979: LD_INT 0
3981: ST_TO_ADDR
// sHack := false ;
3982: LD_ADDR_EXP 30
3986: PUSH
3987: LD_INT 0
3989: ST_TO_ADDR
// sFire := false ;
3990: LD_ADDR_EXP 31
3994: PUSH
3995: LD_INT 0
3997: ST_TO_ADDR
// sRefresh := false ;
3998: LD_ADDR_EXP 32
4002: PUSH
4003: LD_INT 0
4005: ST_TO_ADDR
// sExp := false ;
4006: LD_ADDR_EXP 33
4010: PUSH
4011: LD_INT 0
4013: ST_TO_ADDR
// sDepot := false ;
4014: LD_ADDR_EXP 34
4018: PUSH
4019: LD_INT 0
4021: ST_TO_ADDR
// sFlag := false ;
4022: LD_ADDR_EXP 35
4026: PUSH
4027: LD_INT 0
4029: ST_TO_ADDR
// sKamikadze := false ;
4030: LD_ADDR_EXP 43
4034: PUSH
4035: LD_INT 0
4037: ST_TO_ADDR
// sTroll := false ;
4038: LD_ADDR_EXP 44
4042: PUSH
4043: LD_INT 0
4045: ST_TO_ADDR
// sSlow := false ;
4046: LD_ADDR_EXP 45
4050: PUSH
4051: LD_INT 0
4053: ST_TO_ADDR
// sLack := false ;
4054: LD_ADDR_EXP 46
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// sTank := false ;
4062: LD_ADDR_EXP 48
4066: PUSH
4067: LD_INT 0
4069: ST_TO_ADDR
// sRemote := false ;
4070: LD_ADDR_EXP 49
4074: PUSH
4075: LD_INT 0
4077: ST_TO_ADDR
// sSold := false ;
4078: LD_ADDR_EXP 36
4082: PUSH
4083: LD_INT 0
4085: ST_TO_ADDR
// sDiff := false ;
4086: LD_ADDR_EXP 37
4090: PUSH
4091: LD_INT 0
4093: ST_TO_ADDR
// sFog := false ;
4094: LD_ADDR_EXP 40
4098: PUSH
4099: LD_INT 0
4101: ST_TO_ADDR
// sReset := false ;
4102: LD_ADDR_EXP 41
4106: PUSH
4107: LD_INT 0
4109: ST_TO_ADDR
// sSun := false ;
4110: LD_ADDR_EXP 42
4114: PUSH
4115: LD_INT 0
4117: ST_TO_ADDR
// sTiger := false ;
4118: LD_ADDR_EXP 38
4122: PUSH
4123: LD_INT 0
4125: ST_TO_ADDR
// sBomb := false ;
4126: LD_ADDR_EXP 39
4130: PUSH
4131: LD_INT 0
4133: ST_TO_ADDR
// sWound := false ;
4134: LD_ADDR_EXP 47
4138: PUSH
4139: LD_INT 0
4141: ST_TO_ADDR
// end ;
4142: LD_VAR 0 1
4146: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
4147: LD_VAR 0 2
4151: PUSH
4152: LD_INT 100
4154: EQUAL
4155: IFFALSE 4690
// begin if not StreamModeActive then
4157: LD_EXP 21
4161: NOT
4162: IFFALSE 4172
// StreamModeActive := true ;
4164: LD_ADDR_EXP 21
4168: PUSH
4169: LD_INT 1
4171: ST_TO_ADDR
// if p3 = 0 then
4172: LD_VAR 0 3
4176: PUSH
4177: LD_INT 0
4179: EQUAL
4180: IFFALSE 4186
// InitStreamMode ;
4182: CALL 3907 0 0
// if p3 = 1 then
4186: LD_VAR 0 3
4190: PUSH
4191: LD_INT 1
4193: EQUAL
4194: IFFALSE 4204
// sRocket := true ;
4196: LD_ADDR_EXP 24
4200: PUSH
4201: LD_INT 1
4203: ST_TO_ADDR
// if p3 = 2 then
4204: LD_VAR 0 3
4208: PUSH
4209: LD_INT 2
4211: EQUAL
4212: IFFALSE 4222
// sSpeed := true ;
4214: LD_ADDR_EXP 23
4218: PUSH
4219: LD_INT 1
4221: ST_TO_ADDR
// if p3 = 3 then
4222: LD_VAR 0 3
4226: PUSH
4227: LD_INT 3
4229: EQUAL
4230: IFFALSE 4240
// sEngine := true ;
4232: LD_ADDR_EXP 25
4236: PUSH
4237: LD_INT 1
4239: ST_TO_ADDR
// if p3 = 4 then
4240: LD_VAR 0 3
4244: PUSH
4245: LD_INT 4
4247: EQUAL
4248: IFFALSE 4258
// sSpec := true ;
4250: LD_ADDR_EXP 22
4254: PUSH
4255: LD_INT 1
4257: ST_TO_ADDR
// if p3 = 5 then
4258: LD_VAR 0 3
4262: PUSH
4263: LD_INT 5
4265: EQUAL
4266: IFFALSE 4276
// sLevel := true ;
4268: LD_ADDR_EXP 26
4272: PUSH
4273: LD_INT 1
4275: ST_TO_ADDR
// if p3 = 6 then
4276: LD_VAR 0 3
4280: PUSH
4281: LD_INT 6
4283: EQUAL
4284: IFFALSE 4294
// sArmoury := true ;
4286: LD_ADDR_EXP 27
4290: PUSH
4291: LD_INT 1
4293: ST_TO_ADDR
// if p3 = 7 then
4294: LD_VAR 0 3
4298: PUSH
4299: LD_INT 7
4301: EQUAL
4302: IFFALSE 4312
// sRadar := true ;
4304: LD_ADDR_EXP 28
4308: PUSH
4309: LD_INT 1
4311: ST_TO_ADDR
// if p3 = 8 then
4312: LD_VAR 0 3
4316: PUSH
4317: LD_INT 8
4319: EQUAL
4320: IFFALSE 4330
// sBunker := true ;
4322: LD_ADDR_EXP 29
4326: PUSH
4327: LD_INT 1
4329: ST_TO_ADDR
// if p3 = 9 then
4330: LD_VAR 0 3
4334: PUSH
4335: LD_INT 9
4337: EQUAL
4338: IFFALSE 4348
// sHack := true ;
4340: LD_ADDR_EXP 30
4344: PUSH
4345: LD_INT 1
4347: ST_TO_ADDR
// if p3 = 10 then
4348: LD_VAR 0 3
4352: PUSH
4353: LD_INT 10
4355: EQUAL
4356: IFFALSE 4366
// sFire := true ;
4358: LD_ADDR_EXP 31
4362: PUSH
4363: LD_INT 1
4365: ST_TO_ADDR
// if p3 = 11 then
4366: LD_VAR 0 3
4370: PUSH
4371: LD_INT 11
4373: EQUAL
4374: IFFALSE 4384
// sRefresh := true ;
4376: LD_ADDR_EXP 32
4380: PUSH
4381: LD_INT 1
4383: ST_TO_ADDR
// if p3 = 12 then
4384: LD_VAR 0 3
4388: PUSH
4389: LD_INT 12
4391: EQUAL
4392: IFFALSE 4402
// sExp := true ;
4394: LD_ADDR_EXP 33
4398: PUSH
4399: LD_INT 1
4401: ST_TO_ADDR
// if p3 = 13 then
4402: LD_VAR 0 3
4406: PUSH
4407: LD_INT 13
4409: EQUAL
4410: IFFALSE 4420
// sDepot := true ;
4412: LD_ADDR_EXP 34
4416: PUSH
4417: LD_INT 1
4419: ST_TO_ADDR
// if p3 = 14 then
4420: LD_VAR 0 3
4424: PUSH
4425: LD_INT 14
4427: EQUAL
4428: IFFALSE 4438
// sFlag := true ;
4430: LD_ADDR_EXP 35
4434: PUSH
4435: LD_INT 1
4437: ST_TO_ADDR
// if p3 = 15 then
4438: LD_VAR 0 3
4442: PUSH
4443: LD_INT 15
4445: EQUAL
4446: IFFALSE 4456
// sKamikadze := true ;
4448: LD_ADDR_EXP 43
4452: PUSH
4453: LD_INT 1
4455: ST_TO_ADDR
// if p3 = 16 then
4456: LD_VAR 0 3
4460: PUSH
4461: LD_INT 16
4463: EQUAL
4464: IFFALSE 4474
// sTroll := true ;
4466: LD_ADDR_EXP 44
4470: PUSH
4471: LD_INT 1
4473: ST_TO_ADDR
// if p3 = 17 then
4474: LD_VAR 0 3
4478: PUSH
4479: LD_INT 17
4481: EQUAL
4482: IFFALSE 4492
// sSlow := true ;
4484: LD_ADDR_EXP 45
4488: PUSH
4489: LD_INT 1
4491: ST_TO_ADDR
// if p3 = 18 then
4492: LD_VAR 0 3
4496: PUSH
4497: LD_INT 18
4499: EQUAL
4500: IFFALSE 4510
// sLack := true ;
4502: LD_ADDR_EXP 46
4506: PUSH
4507: LD_INT 1
4509: ST_TO_ADDR
// if p3 = 19 then
4510: LD_VAR 0 3
4514: PUSH
4515: LD_INT 19
4517: EQUAL
4518: IFFALSE 4528
// sTank := true ;
4520: LD_ADDR_EXP 48
4524: PUSH
4525: LD_INT 1
4527: ST_TO_ADDR
// if p3 = 20 then
4528: LD_VAR 0 3
4532: PUSH
4533: LD_INT 20
4535: EQUAL
4536: IFFALSE 4546
// sRemote := true ;
4538: LD_ADDR_EXP 49
4542: PUSH
4543: LD_INT 1
4545: ST_TO_ADDR
// if p3 = 101 then
4546: LD_VAR 0 3
4550: PUSH
4551: LD_INT 101
4553: EQUAL
4554: IFFALSE 4564
// sSold := true ;
4556: LD_ADDR_EXP 36
4560: PUSH
4561: LD_INT 1
4563: ST_TO_ADDR
// if p3 = 102 then
4564: LD_VAR 0 3
4568: PUSH
4569: LD_INT 102
4571: EQUAL
4572: IFFALSE 4582
// sDiff := true ;
4574: LD_ADDR_EXP 37
4578: PUSH
4579: LD_INT 1
4581: ST_TO_ADDR
// if p3 = 103 then
4582: LD_VAR 0 3
4586: PUSH
4587: LD_INT 103
4589: EQUAL
4590: IFFALSE 4600
// sFog := true ;
4592: LD_ADDR_EXP 40
4596: PUSH
4597: LD_INT 1
4599: ST_TO_ADDR
// if p3 = 104 then
4600: LD_VAR 0 3
4604: PUSH
4605: LD_INT 104
4607: EQUAL
4608: IFFALSE 4618
// sReset := true ;
4610: LD_ADDR_EXP 41
4614: PUSH
4615: LD_INT 1
4617: ST_TO_ADDR
// if p3 = 105 then
4618: LD_VAR 0 3
4622: PUSH
4623: LD_INT 105
4625: EQUAL
4626: IFFALSE 4636
// sSun := true ;
4628: LD_ADDR_EXP 42
4632: PUSH
4633: LD_INT 1
4635: ST_TO_ADDR
// if p3 = 106 then
4636: LD_VAR 0 3
4640: PUSH
4641: LD_INT 106
4643: EQUAL
4644: IFFALSE 4654
// sTiger := true ;
4646: LD_ADDR_EXP 38
4650: PUSH
4651: LD_INT 1
4653: ST_TO_ADDR
// if p3 = 107 then
4654: LD_VAR 0 3
4658: PUSH
4659: LD_INT 107
4661: EQUAL
4662: IFFALSE 4672
// sBomb := true ;
4664: LD_ADDR_EXP 39
4668: PUSH
4669: LD_INT 1
4671: ST_TO_ADDR
// if p3 = 108 then
4672: LD_VAR 0 3
4676: PUSH
4677: LD_INT 108
4679: EQUAL
4680: IFFALSE 4690
// sWound := true ;
4682: LD_ADDR_EXP 47
4686: PUSH
4687: LD_INT 1
4689: ST_TO_ADDR
// end ; end ;
4690: PPOPN 6
4692: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
4693: LD_EXP 21
4697: PUSH
4698: LD_EXP 24
4702: AND
4703: IFFALSE 4824
4705: GO 4707
4707: DISABLE
4708: LD_INT 0
4710: PPUSH
4711: PPUSH
// begin enable ;
4712: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
4713: LD_ADDR_VAR 0 2
4717: PUSH
4718: LD_INT 22
4720: PUSH
4721: LD_OWVAR 2
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 2
4732: PUSH
4733: LD_INT 34
4735: PUSH
4736: LD_INT 7
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: LD_INT 34
4745: PUSH
4746: LD_INT 45
4748: PUSH
4749: EMPTY
4750: LIST
4751: LIST
4752: PUSH
4753: LD_INT 34
4755: PUSH
4756: LD_INT 28
4758: PUSH
4759: EMPTY
4760: LIST
4761: LIST
4762: PUSH
4763: LD_INT 34
4765: PUSH
4766: LD_INT 47
4768: PUSH
4769: EMPTY
4770: LIST
4771: LIST
4772: PUSH
4773: EMPTY
4774: LIST
4775: LIST
4776: LIST
4777: LIST
4778: LIST
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PPUSH
4784: CALL_OW 69
4788: ST_TO_ADDR
// if not tmp then
4789: LD_VAR 0 2
4793: NOT
4794: IFFALSE 4798
// exit ;
4796: GO 4824
// for i in tmp do
4798: LD_ADDR_VAR 0 1
4802: PUSH
4803: LD_VAR 0 2
4807: PUSH
4808: FOR_IN
4809: IFFALSE 4822
// begin DestroyUnit ( i ) ;
4811: LD_VAR 0 1
4815: PPUSH
4816: CALL_OW 65
// end ;
4820: GO 4808
4822: POP
4823: POP
// end ;
4824: PPOPN 2
4826: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
4827: LD_EXP 21
4831: PUSH
4832: LD_EXP 25
4836: AND
4837: IFFALSE 4918
4839: GO 4841
4841: DISABLE
4842: LD_INT 0
4844: PPUSH
4845: PPUSH
// begin enable ;
4846: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
4847: LD_ADDR_VAR 0 2
4851: PUSH
4852: LD_INT 22
4854: PUSH
4855: LD_OWVAR 2
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: LD_INT 32
4866: PUSH
4867: LD_INT 3
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PPUSH
4878: CALL_OW 69
4882: ST_TO_ADDR
// if not tmp then
4883: LD_VAR 0 2
4887: NOT
4888: IFFALSE 4892
// exit ;
4890: GO 4918
// for i in tmp do
4892: LD_ADDR_VAR 0 1
4896: PUSH
4897: LD_VAR 0 2
4901: PUSH
4902: FOR_IN
4903: IFFALSE 4916
// begin DestroyUnit ( i ) ;
4905: LD_VAR 0 1
4909: PPUSH
4910: CALL_OW 65
// end ;
4914: GO 4902
4916: POP
4917: POP
// end ;
4918: PPOPN 2
4920: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
4921: LD_EXP 21
4925: PUSH
4926: LD_EXP 22
4930: AND
4931: IFFALSE 5024
4933: GO 4935
4935: DISABLE
4936: LD_INT 0
4938: PPUSH
// begin enable ;
4939: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
4940: LD_ADDR_VAR 0 1
4944: PUSH
4945: LD_INT 22
4947: PUSH
4948: LD_OWVAR 2
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PUSH
4957: LD_INT 2
4959: PUSH
4960: LD_INT 25
4962: PUSH
4963: LD_INT 5
4965: PUSH
4966: EMPTY
4967: LIST
4968: LIST
4969: PUSH
4970: LD_INT 25
4972: PUSH
4973: LD_INT 9
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: PUSH
4980: LD_INT 25
4982: PUSH
4983: LD_INT 8
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: PPUSH
5000: CALL_OW 69
5004: PUSH
5005: FOR_IN
5006: IFFALSE 5022
// begin SetClass ( i , 1 ) ;
5008: LD_VAR 0 1
5012: PPUSH
5013: LD_INT 1
5015: PPUSH
5016: CALL_OW 336
// end ;
5020: GO 5005
5022: POP
5023: POP
// end ;
5024: PPOPN 1
5026: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
5027: LD_EXP 21
5031: PUSH
5032: LD_EXP 23
5036: AND
5037: PUSH
5038: LD_OWVAR 65
5042: PUSH
5043: LD_INT 7
5045: LESS
5046: AND
5047: IFFALSE 5061
5049: GO 5051
5051: DISABLE
// begin enable ;
5052: ENABLE
// game_speed := 7 ;
5053: LD_ADDR_OWVAR 65
5057: PUSH
5058: LD_INT 7
5060: ST_TO_ADDR
// end ;
5061: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
5062: LD_EXP 21
5066: PUSH
5067: LD_EXP 26
5071: AND
5072: IFFALSE 5274
5074: GO 5076
5076: DISABLE
5077: LD_INT 0
5079: PPUSH
5080: PPUSH
5081: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
5082: LD_ADDR_VAR 0 3
5086: PUSH
5087: LD_INT 81
5089: PUSH
5090: LD_OWVAR 2
5094: PUSH
5095: EMPTY
5096: LIST
5097: LIST
5098: PUSH
5099: LD_INT 21
5101: PUSH
5102: LD_INT 1
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: PPUSH
5113: CALL_OW 69
5117: ST_TO_ADDR
// if not tmp then
5118: LD_VAR 0 3
5122: NOT
5123: IFFALSE 5127
// exit ;
5125: GO 5274
// if tmp > 5 then
5127: LD_VAR 0 3
5131: PUSH
5132: LD_INT 5
5134: GREATER
5135: IFFALSE 5147
// k := 5 else
5137: LD_ADDR_VAR 0 2
5141: PUSH
5142: LD_INT 5
5144: ST_TO_ADDR
5145: GO 5157
// k := tmp ;
5147: LD_ADDR_VAR 0 2
5151: PUSH
5152: LD_VAR 0 3
5156: ST_TO_ADDR
// for i := 1 to k do
5157: LD_ADDR_VAR 0 1
5161: PUSH
5162: DOUBLE
5163: LD_INT 1
5165: DEC
5166: ST_TO_ADDR
5167: LD_VAR 0 2
5171: PUSH
5172: FOR_TO
5173: IFFALSE 5272
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
5175: LD_VAR 0 3
5179: PUSH
5180: LD_VAR 0 1
5184: ARRAY
5185: PPUSH
5186: LD_VAR 0 1
5190: PUSH
5191: LD_INT 4
5193: MOD
5194: PUSH
5195: LD_INT 1
5197: PLUS
5198: PPUSH
5199: CALL_OW 259
5203: PUSH
5204: LD_INT 10
5206: LESS
5207: IFFALSE 5270
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
5209: LD_VAR 0 3
5213: PUSH
5214: LD_VAR 0 1
5218: ARRAY
5219: PPUSH
5220: LD_VAR 0 1
5224: PUSH
5225: LD_INT 4
5227: MOD
5228: PUSH
5229: LD_INT 1
5231: PLUS
5232: PPUSH
5233: LD_VAR 0 3
5237: PUSH
5238: LD_VAR 0 1
5242: ARRAY
5243: PPUSH
5244: LD_VAR 0 1
5248: PUSH
5249: LD_INT 4
5251: MOD
5252: PUSH
5253: LD_INT 1
5255: PLUS
5256: PPUSH
5257: CALL_OW 259
5261: PUSH
5262: LD_INT 1
5264: PLUS
5265: PPUSH
5266: CALL_OW 237
5270: GO 5172
5272: POP
5273: POP
// end ;
5274: PPOPN 3
5276: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
5277: LD_EXP 21
5281: PUSH
5282: LD_EXP 27
5286: AND
5287: IFFALSE 5307
5289: GO 5291
5291: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
5292: LD_INT 4
5294: PPUSH
5295: LD_OWVAR 2
5299: PPUSH
5300: LD_INT 0
5302: PPUSH
5303: CALL_OW 324
5307: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
5308: LD_EXP 21
5312: PUSH
5313: LD_EXP 28
5317: AND
5318: IFFALSE 5417
5320: GO 5322
5322: DISABLE
5323: LD_INT 0
5325: PPUSH
5326: PPUSH
// begin enable ;
5327: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
5328: LD_ADDR_VAR 0 2
5332: PUSH
5333: LD_INT 22
5335: PUSH
5336: LD_OWVAR 2
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PUSH
5345: LD_INT 2
5347: PUSH
5348: LD_INT 34
5350: PUSH
5351: LD_INT 11
5353: PUSH
5354: EMPTY
5355: LIST
5356: LIST
5357: PUSH
5358: LD_INT 34
5360: PUSH
5361: LD_INT 30
5363: PUSH
5364: EMPTY
5365: LIST
5366: LIST
5367: PUSH
5368: EMPTY
5369: LIST
5370: LIST
5371: LIST
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PPUSH
5377: CALL_OW 69
5381: ST_TO_ADDR
// if not tmp then
5382: LD_VAR 0 2
5386: NOT
5387: IFFALSE 5391
// exit ;
5389: GO 5417
// for i in tmp do
5391: LD_ADDR_VAR 0 1
5395: PUSH
5396: LD_VAR 0 2
5400: PUSH
5401: FOR_IN
5402: IFFALSE 5415
// begin DestroyUnit ( i ) ;
5404: LD_VAR 0 1
5408: PPUSH
5409: CALL_OW 65
// end ;
5413: GO 5401
5415: POP
5416: POP
// end ;
5417: PPOPN 2
5419: END
// every 0 0$1 trigger StreamModeActive and sBunker do
5420: LD_EXP 21
5424: PUSH
5425: LD_EXP 29
5429: AND
5430: IFFALSE 5450
5432: GO 5434
5434: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
5435: LD_INT 32
5437: PPUSH
5438: LD_OWVAR 2
5442: PPUSH
5443: LD_INT 0
5445: PPUSH
5446: CALL_OW 324
5450: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
5451: LD_EXP 21
5455: PUSH
5456: LD_EXP 30
5460: AND
5461: IFFALSE 5642
5463: GO 5465
5465: DISABLE
5466: LD_INT 0
5468: PPUSH
5469: PPUSH
5470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
5471: LD_ADDR_VAR 0 2
5475: PUSH
5476: LD_INT 22
5478: PUSH
5479: LD_OWVAR 2
5483: PUSH
5484: EMPTY
5485: LIST
5486: LIST
5487: PUSH
5488: LD_INT 33
5490: PUSH
5491: LD_INT 3
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 69
5506: ST_TO_ADDR
// if not tmp then
5507: LD_VAR 0 2
5511: NOT
5512: IFFALSE 5516
// exit ;
5514: GO 5642
// side := 0 ;
5516: LD_ADDR_VAR 0 3
5520: PUSH
5521: LD_INT 0
5523: ST_TO_ADDR
// for i := 1 to 8 do
5524: LD_ADDR_VAR 0 1
5528: PUSH
5529: DOUBLE
5530: LD_INT 1
5532: DEC
5533: ST_TO_ADDR
5534: LD_INT 8
5536: PUSH
5537: FOR_TO
5538: IFFALSE 5586
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
5540: LD_OWVAR 2
5544: PUSH
5545: LD_VAR 0 1
5549: NONEQUAL
5550: PUSH
5551: LD_OWVAR 2
5555: PPUSH
5556: LD_VAR 0 1
5560: PPUSH
5561: CALL_OW 81
5565: PUSH
5566: LD_INT 2
5568: EQUAL
5569: AND
5570: IFFALSE 5584
// begin side := i ;
5572: LD_ADDR_VAR 0 3
5576: PUSH
5577: LD_VAR 0 1
5581: ST_TO_ADDR
// break ;
5582: GO 5586
// end ;
5584: GO 5537
5586: POP
5587: POP
// if not side then
5588: LD_VAR 0 3
5592: NOT
5593: IFFALSE 5597
// exit ;
5595: GO 5642
// for i := 1 to tmp do
5597: LD_ADDR_VAR 0 1
5601: PUSH
5602: DOUBLE
5603: LD_INT 1
5605: DEC
5606: ST_TO_ADDR
5607: LD_VAR 0 2
5611: PUSH
5612: FOR_TO
5613: IFFALSE 5640
// if Prob ( 30 ) then
5615: LD_INT 30
5617: PPUSH
5618: CALL_OW 13
5622: IFFALSE 5638
// SetSide ( i , side ) ;
5624: LD_VAR 0 1
5628: PPUSH
5629: LD_VAR 0 3
5633: PPUSH
5634: CALL_OW 235
5638: GO 5612
5640: POP
5641: POP
// end ;
5642: PPOPN 3
5644: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
5645: LD_EXP 21
5649: PUSH
5650: LD_EXP 32
5654: AND
5655: IFFALSE 5774
5657: GO 5659
5659: DISABLE
5660: LD_INT 0
5662: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
5663: LD_ADDR_VAR 0 1
5667: PUSH
5668: LD_INT 22
5670: PUSH
5671: LD_OWVAR 2
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PUSH
5680: LD_INT 21
5682: PUSH
5683: LD_INT 1
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 3
5692: PUSH
5693: LD_INT 23
5695: PUSH
5696: LD_INT 0
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: PPUSH
5712: CALL_OW 69
5716: PUSH
5717: FOR_IN
5718: IFFALSE 5772
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
5720: LD_VAR 0 1
5724: PPUSH
5725: CALL_OW 257
5729: PUSH
5730: LD_INT 1
5732: PUSH
5733: LD_INT 2
5735: PUSH
5736: LD_INT 3
5738: PUSH
5739: LD_INT 4
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: IN
5748: IFFALSE 5770
// SetClass ( un , rand ( 1 , 4 ) ) ;
5750: LD_VAR 0 1
5754: PPUSH
5755: LD_INT 1
5757: PPUSH
5758: LD_INT 4
5760: PPUSH
5761: CALL_OW 12
5765: PPUSH
5766: CALL_OW 336
5770: GO 5717
5772: POP
5773: POP
// end ;
5774: PPOPN 1
5776: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
5777: LD_EXP 21
5781: PUSH
5782: LD_EXP 31
5786: AND
5787: IFFALSE 5866
5789: GO 5791
5791: DISABLE
5792: LD_INT 0
5794: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
5795: LD_ADDR_VAR 0 1
5799: PUSH
5800: LD_INT 22
5802: PUSH
5803: LD_OWVAR 2
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: PUSH
5812: LD_INT 21
5814: PUSH
5815: LD_INT 3
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: PUSH
5822: EMPTY
5823: LIST
5824: LIST
5825: PPUSH
5826: CALL_OW 69
5830: ST_TO_ADDR
// if not tmp then
5831: LD_VAR 0 1
5835: NOT
5836: IFFALSE 5840
// exit ;
5838: GO 5866
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
5840: LD_VAR 0 1
5844: PUSH
5845: LD_INT 1
5847: PPUSH
5848: LD_VAR 0 1
5852: PPUSH
5853: CALL_OW 12
5857: ARRAY
5858: PPUSH
5859: LD_INT 100
5861: PPUSH
5862: CALL_OW 234
// end ;
5866: PPOPN 1
5868: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
5869: LD_EXP 21
5873: PUSH
5874: LD_EXP 33
5878: AND
5879: IFFALSE 5977
5881: GO 5883
5883: DISABLE
5884: LD_INT 0
5886: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
5887: LD_ADDR_VAR 0 1
5891: PUSH
5892: LD_INT 22
5894: PUSH
5895: LD_OWVAR 2
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: PUSH
5904: LD_INT 21
5906: PUSH
5907: LD_INT 1
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PPUSH
5918: CALL_OW 69
5922: ST_TO_ADDR
// if not tmp then
5923: LD_VAR 0 1
5927: NOT
5928: IFFALSE 5932
// exit ;
5930: GO 5977
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
5932: LD_VAR 0 1
5936: PUSH
5937: LD_INT 1
5939: PPUSH
5940: LD_VAR 0 1
5944: PPUSH
5945: CALL_OW 12
5949: ARRAY
5950: PPUSH
5951: LD_INT 1
5953: PPUSH
5954: LD_INT 4
5956: PPUSH
5957: CALL_OW 12
5961: PPUSH
5962: LD_INT 3000
5964: PPUSH
5965: LD_INT 9000
5967: PPUSH
5968: CALL_OW 12
5972: PPUSH
5973: CALL_OW 492
// end ;
5977: PPOPN 1
5979: END
// every 0 0$1 trigger StreamModeActive and sDepot do
5980: LD_EXP 21
5984: PUSH
5985: LD_EXP 34
5989: AND
5990: IFFALSE 6010
5992: GO 5994
5994: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
5995: LD_INT 1
5997: PPUSH
5998: LD_OWVAR 2
6002: PPUSH
6003: LD_INT 0
6005: PPUSH
6006: CALL_OW 324
6010: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
6011: LD_EXP 21
6015: PUSH
6016: LD_EXP 35
6020: AND
6021: IFFALSE 6104
6023: GO 6025
6025: DISABLE
6026: LD_INT 0
6028: PPUSH
6029: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6030: LD_ADDR_VAR 0 2
6034: PUSH
6035: LD_INT 22
6037: PUSH
6038: LD_OWVAR 2
6042: PUSH
6043: EMPTY
6044: LIST
6045: LIST
6046: PUSH
6047: LD_INT 21
6049: PUSH
6050: LD_INT 3
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: PPUSH
6061: CALL_OW 69
6065: ST_TO_ADDR
// if not tmp then
6066: LD_VAR 0 2
6070: NOT
6071: IFFALSE 6075
// exit ;
6073: GO 6104
// for i in tmp do
6075: LD_ADDR_VAR 0 1
6079: PUSH
6080: LD_VAR 0 2
6084: PUSH
6085: FOR_IN
6086: IFFALSE 6102
// SetBLevel ( i , 10 ) ;
6088: LD_VAR 0 1
6092: PPUSH
6093: LD_INT 10
6095: PPUSH
6096: CALL_OW 241
6100: GO 6085
6102: POP
6103: POP
// end ;
6104: PPOPN 2
6106: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , tmp ;
6107: LD_EXP 21
6111: PUSH
6112: LD_EXP 36
6116: AND
6117: IFFALSE 6220
6119: GO 6121
6121: DISABLE
6122: LD_INT 0
6124: PPUSH
6125: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
6126: LD_ADDR_VAR 0 2
6130: PUSH
6131: LD_INT 22
6133: PUSH
6134: LD_OWVAR 2
6138: PUSH
6139: EMPTY
6140: LIST
6141: LIST
6142: PUSH
6143: LD_INT 25
6145: PUSH
6146: LD_INT 1
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: PPUSH
6157: CALL_OW 69
6161: ST_TO_ADDR
// if not tmp then
6162: LD_VAR 0 2
6166: NOT
6167: IFFALSE 6171
// exit ;
6169: GO 6220
// for i in tmp do
6171: LD_ADDR_VAR 0 1
6175: PUSH
6176: LD_VAR 0 2
6180: PUSH
6181: FOR_IN
6182: IFFALSE 6218
// begin if Crawls ( i ) then
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 318
6193: IFFALSE 6204
// ComWalk ( i ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: CALL_OW 138
// SetClass ( i , 4 ) ;
6204: LD_VAR 0 1
6208: PPUSH
6209: LD_INT 4
6211: PPUSH
6212: CALL_OW 336
// end ;
6216: GO 6181
6218: POP
6219: POP
// end ;
6220: PPOPN 2
6222: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
6223: LD_EXP 21
6227: PUSH
6228: LD_EXP 37
6232: AND
6233: PUSH
6234: LD_OWVAR 67
6238: PUSH
6239: LD_INT 3
6241: LESS
6242: AND
6243: IFFALSE 6262
6245: GO 6247
6247: DISABLE
// Difficulty := Difficulty + 1 ;
6248: LD_ADDR_OWVAR 67
6252: PUSH
6253: LD_OWVAR 67
6257: PUSH
6258: LD_INT 1
6260: PLUS
6261: ST_TO_ADDR
6262: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
6263: LD_EXP 21
6267: PUSH
6268: LD_EXP 38
6272: AND
6273: IFFALSE 6376
6275: GO 6277
6277: DISABLE
6278: LD_INT 0
6280: PPUSH
// begin for i := 1 to 5 do
6281: LD_ADDR_VAR 0 1
6285: PUSH
6286: DOUBLE
6287: LD_INT 1
6289: DEC
6290: ST_TO_ADDR
6291: LD_INT 5
6293: PUSH
6294: FOR_TO
6295: IFFALSE 6374
// begin uc_nation := nation_nature ;
6297: LD_ADDR_OWVAR 21
6301: PUSH
6302: LD_INT 0
6304: ST_TO_ADDR
// uc_side := 0 ;
6305: LD_ADDR_OWVAR 20
6309: PUSH
6310: LD_INT 0
6312: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
6313: LD_ADDR_OWVAR 29
6317: PUSH
6318: LD_INT 12
6320: PUSH
6321: LD_INT 12
6323: PUSH
6324: EMPTY
6325: LIST
6326: LIST
6327: ST_TO_ADDR
// hc_agressivity := 20 ;
6328: LD_ADDR_OWVAR 35
6332: PUSH
6333: LD_INT 20
6335: ST_TO_ADDR
// hc_class := class_tiger ;
6336: LD_ADDR_OWVAR 28
6340: PUSH
6341: LD_INT 14
6343: ST_TO_ADDR
// hc_gallery :=  ;
6344: LD_ADDR_OWVAR 33
6348: PUSH
6349: LD_STRING 
6351: ST_TO_ADDR
// hc_name :=  ;
6352: LD_ADDR_OWVAR 26
6356: PUSH
6357: LD_STRING 
6359: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
6360: CALL_OW 44
6364: PPUSH
6365: LD_INT 0
6367: PPUSH
6368: CALL_OW 51
// end ;
6372: GO 6294
6374: POP
6375: POP
// end ;
6376: PPOPN 1
6378: END
// every 0 0$1 trigger StreamModeActive and sBomb do var i , x , y , result ;
6379: LD_EXP 21
6383: PUSH
6384: LD_EXP 39
6388: AND
6389: IFFALSE 6563
6391: GO 6393
6393: DISABLE
6394: LD_INT 0
6396: PPUSH
6397: PPUSH
6398: PPUSH
6399: PPUSH
// begin result := false ;
6400: LD_ADDR_VAR 0 4
6404: PUSH
6405: LD_INT 0
6407: ST_TO_ADDR
// for i := 1 to 8 do
6408: LD_ADDR_VAR 0 1
6412: PUSH
6413: DOUBLE
6414: LD_INT 1
6416: DEC
6417: ST_TO_ADDR
6418: LD_INT 8
6420: PUSH
6421: FOR_TO
6422: IFFALSE 6533
// begin x := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
6424: LD_ADDR_VAR 0 2
6428: PUSH
6429: LD_INT 10
6431: PUSH
6432: LD_INT 50
6434: PUSH
6435: LD_INT 90
6437: PUSH
6438: LD_INT 140
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 1
6449: PPUSH
6450: LD_INT 4
6452: PPUSH
6453: CALL_OW 12
6457: ARRAY
6458: ST_TO_ADDR
// y := [ 10 , 50 , 90 , 140 ] [ rand ( 1 , 4 ) ] ;
6459: LD_ADDR_VAR 0 3
6463: PUSH
6464: LD_INT 10
6466: PUSH
6467: LD_INT 50
6469: PUSH
6470: LD_INT 90
6472: PUSH
6473: LD_INT 140
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: LD_INT 1
6484: PPUSH
6485: LD_INT 4
6487: PPUSH
6488: CALL_OW 12
6492: ARRAY
6493: ST_TO_ADDR
// if ValidHex ( x , y ) then
6494: LD_VAR 0 2
6498: PPUSH
6499: LD_VAR 0 3
6503: PPUSH
6504: CALL_OW 488
6508: IFFALSE 6531
// begin result := [ x , y ] ;
6510: LD_ADDR_VAR 0 4
6514: PUSH
6515: LD_VAR 0 2
6519: PUSH
6520: LD_VAR 0 3
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: ST_TO_ADDR
// break ;
6529: GO 6533
// end ; end ;
6531: GO 6421
6533: POP
6534: POP
// if result then
6535: LD_VAR 0 4
6539: IFFALSE 6563
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
6541: LD_VAR 0 4
6545: PUSH
6546: LD_INT 1
6548: ARRAY
6549: PPUSH
6550: LD_VAR 0 4
6554: PUSH
6555: LD_INT 2
6557: ARRAY
6558: PPUSH
6559: CALL_OW 429
// end ;
6563: PPOPN 4
6565: END
// every 0 0$1 trigger StreamModeActive and sReset do
6566: LD_EXP 21
6570: PUSH
6571: LD_EXP 41
6575: AND
6576: IFFALSE 6588
6578: GO 6580
6580: DISABLE
// YouLost (  ) ;
6581: LD_STRING 
6583: PPUSH
6584: CALL_OW 104
6588: END
// every 0 0$1 trigger StreamModeActive and sFog do
6589: LD_EXP 21
6593: PUSH
6594: LD_EXP 40
6598: AND
6599: IFFALSE 6613
6601: GO 6603
6603: DISABLE
// FogOff ( your_side ) ;
6604: LD_OWVAR 2
6608: PPUSH
6609: CALL_OW 344
6613: END
// every 0 0$1 trigger StreamModeActive and sSun do
6614: LD_EXP 21
6618: PUSH
6619: LD_EXP 42
6623: AND
6624: IFFALSE 6652
6626: GO 6628
6628: DISABLE
// begin solar_recharge_percent := 0 ;
6629: LD_ADDR_OWVAR 79
6633: PUSH
6634: LD_INT 0
6636: ST_TO_ADDR
// wait ( 5 5$00 ) ;
6637: LD_INT 10500
6639: PPUSH
6640: CALL_OW 67
// solar_recharge_percent := 100 ;
6644: LD_ADDR_OWVAR 79
6648: PUSH
6649: LD_INT 100
6651: ST_TO_ADDR
// end ;
6652: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un ;
6653: LD_EXP 21
6657: PUSH
6658: LD_EXP 43
6662: AND
6663: IFFALSE 6818
6665: GO 6667
6667: DISABLE
6668: LD_INT 0
6670: PPUSH
6671: PPUSH
// begin for i := 1 to 6 do
6672: LD_ADDR_VAR 0 1
6676: PUSH
6677: DOUBLE
6678: LD_INT 1
6680: DEC
6681: ST_TO_ADDR
6682: LD_INT 6
6684: PUSH
6685: FOR_TO
6686: IFFALSE 6816
// begin uc_nation := nation_nature ;
6688: LD_ADDR_OWVAR 21
6692: PUSH
6693: LD_INT 0
6695: ST_TO_ADDR
// uc_side := 0 ;
6696: LD_ADDR_OWVAR 20
6700: PUSH
6701: LD_INT 0
6703: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
6704: LD_ADDR_OWVAR 29
6708: PUSH
6709: LD_INT 12
6711: PUSH
6712: LD_INT 12
6714: PUSH
6715: EMPTY
6716: LIST
6717: LIST
6718: ST_TO_ADDR
// hc_agressivity := 20 ;
6719: LD_ADDR_OWVAR 35
6723: PUSH
6724: LD_INT 20
6726: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
6727: LD_ADDR_OWVAR 28
6731: PUSH
6732: LD_INT 17
6734: ST_TO_ADDR
// hc_gallery :=  ;
6735: LD_ADDR_OWVAR 33
6739: PUSH
6740: LD_STRING 
6742: ST_TO_ADDR
// hc_name :=  ;
6743: LD_ADDR_OWVAR 26
6747: PUSH
6748: LD_STRING 
6750: ST_TO_ADDR
// un := CreateHuman ;
6751: LD_ADDR_VAR 0 2
6755: PUSH
6756: CALL_OW 44
6760: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
6761: LD_VAR 0 2
6765: PPUSH
6766: LD_INT 1
6768: PPUSH
6769: CALL_OW 51
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
6773: LD_VAR 0 2
6777: PPUSH
6778: LD_INT 3
6780: PUSH
6781: LD_INT 22
6783: PUSH
6784: LD_INT 0
6786: PUSH
6787: EMPTY
6788: LIST
6789: LIST
6790: PUSH
6791: EMPTY
6792: LIST
6793: LIST
6794: PPUSH
6795: CALL_OW 69
6799: PPUSH
6800: LD_VAR 0 2
6804: PPUSH
6805: CALL_OW 74
6809: PPUSH
6810: CALL_OW 115
// end ;
6814: GO 6685
6816: POP
6817: POP
// end ;
6818: PPOPN 2
6820: END
// every 0 0$1 trigger StreamModeActive and sTroll do
6821: LD_EXP 21
6825: PUSH
6826: LD_EXP 44
6830: AND
6831: IFFALSE 6857
6833: GO 6835
6835: DISABLE
// begin ToLua ( displayTroll(); ) ;
6836: LD_STRING displayTroll();
6838: PPUSH
6839: CALL_OW 559
// wait ( 3 3$00 ) ;
6843: LD_INT 6300
6845: PPUSH
6846: CALL_OW 67
// ToLua ( hideTroll(); ) ;
6850: LD_STRING hideTroll();
6852: PPUSH
6853: CALL_OW 559
// end ;
6857: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
6858: LD_EXP 21
6862: PUSH
6863: LD_EXP 45
6867: AND
6868: IFFALSE 6931
6870: GO 6872
6872: DISABLE
6873: LD_INT 0
6875: PPUSH
// begin p := 0 ;
6876: LD_ADDR_VAR 0 1
6880: PUSH
6881: LD_INT 0
6883: ST_TO_ADDR
// repeat game_speed := 1 ;
6884: LD_ADDR_OWVAR 65
6888: PUSH
6889: LD_INT 1
6891: ST_TO_ADDR
// wait ( 0 0$1 ) ;
6892: LD_INT 35
6894: PPUSH
6895: CALL_OW 67
// p := p + 1 ;
6899: LD_ADDR_VAR 0 1
6903: PUSH
6904: LD_VAR 0 1
6908: PUSH
6909: LD_INT 1
6911: PLUS
6912: ST_TO_ADDR
// until p >= 60 ;
6913: LD_VAR 0 1
6917: PUSH
6918: LD_INT 60
6920: GREATEREQUAL
6921: IFFALSE 6884
// game_speed := 4 ;
6923: LD_ADDR_OWVAR 65
6927: PUSH
6928: LD_INT 4
6930: ST_TO_ADDR
// end ;
6931: PPOPN 1
6933: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
6934: LD_EXP 21
6938: PUSH
6939: LD_EXP 46
6943: AND
6944: IFFALSE 7090
6946: GO 6948
6948: DISABLE
6949: LD_INT 0
6951: PPUSH
6952: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
6953: LD_ADDR_VAR 0 1
6957: PUSH
6958: LD_INT 22
6960: PUSH
6961: LD_OWVAR 2
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 2
6972: PUSH
6973: LD_INT 30
6975: PUSH
6976: LD_INT 0
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 30
6985: PUSH
6986: LD_INT 1
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: LIST
6997: PUSH
6998: EMPTY
6999: LIST
7000: LIST
7001: PPUSH
7002: CALL_OW 69
7006: ST_TO_ADDR
// if not depot then
7007: LD_VAR 0 1
7011: NOT
7012: IFFALSE 7016
// exit ;
7014: GO 7090
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
7016: LD_ADDR_VAR 0 2
7020: PUSH
7021: LD_VAR 0 1
7025: PUSH
7026: LD_INT 1
7028: PPUSH
7029: LD_VAR 0 1
7033: PPUSH
7034: CALL_OW 12
7038: ARRAY
7039: PPUSH
7040: CALL_OW 274
7044: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
7045: LD_VAR 0 2
7049: PPUSH
7050: LD_INT 1
7052: PPUSH
7053: LD_INT 0
7055: PPUSH
7056: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
7060: LD_VAR 0 2
7064: PPUSH
7065: LD_INT 2
7067: PPUSH
7068: LD_INT 0
7070: PPUSH
7071: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
7075: LD_VAR 0 2
7079: PPUSH
7080: LD_INT 3
7082: PPUSH
7083: LD_INT 0
7085: PPUSH
7086: CALL_OW 277
// end ;
7090: PPOPN 2
7092: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
7093: LD_EXP 21
7097: PUSH
7098: LD_EXP 47
7102: AND
7103: IFFALSE 7200
7105: GO 7107
7107: DISABLE
7108: LD_INT 0
7110: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
7111: LD_ADDR_VAR 0 1
7115: PUSH
7116: LD_INT 22
7118: PUSH
7119: LD_OWVAR 2
7123: PUSH
7124: EMPTY
7125: LIST
7126: LIST
7127: PUSH
7128: LD_INT 21
7130: PUSH
7131: LD_INT 1
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: LD_INT 3
7140: PUSH
7141: LD_INT 23
7143: PUSH
7144: LD_INT 0
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: PUSH
7155: EMPTY
7156: LIST
7157: LIST
7158: LIST
7159: PPUSH
7160: CALL_OW 69
7164: ST_TO_ADDR
// if not tmp then
7165: LD_VAR 0 1
7169: NOT
7170: IFFALSE 7174
// exit ;
7172: GO 7200
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
7174: LD_VAR 0 1
7178: PUSH
7179: LD_INT 1
7181: PPUSH
7182: LD_VAR 0 1
7186: PPUSH
7187: CALL_OW 12
7191: ARRAY
7192: PPUSH
7193: LD_INT 200
7195: PPUSH
7196: CALL_OW 234
// end ;
7200: PPOPN 1
7202: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
7203: LD_EXP 21
7207: PUSH
7208: LD_EXP 48
7212: AND
7213: IFFALSE 7292
7215: GO 7217
7217: DISABLE
7218: LD_INT 0
7220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
7221: LD_ADDR_VAR 0 1
7225: PUSH
7226: LD_INT 22
7228: PUSH
7229: LD_OWVAR 2
7233: PUSH
7234: EMPTY
7235: LIST
7236: LIST
7237: PUSH
7238: LD_INT 21
7240: PUSH
7241: LD_INT 2
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: PPUSH
7252: CALL_OW 69
7256: ST_TO_ADDR
// if not tmp then
7257: LD_VAR 0 1
7261: NOT
7262: IFFALSE 7266
// exit ;
7264: GO 7292
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 10 ) ;
7266: LD_VAR 0 1
7270: PUSH
7271: LD_INT 1
7273: PPUSH
7274: LD_VAR 0 1
7278: PPUSH
7279: CALL_OW 12
7283: ARRAY
7284: PPUSH
7285: LD_INT 10
7287: PPUSH
7288: CALL_OW 234
// end ;
7292: PPOPN 1
7294: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
7295: LD_EXP 21
7299: PUSH
7300: LD_EXP 49
7304: AND
7305: IFFALSE 7404
7307: GO 7309
7309: DISABLE
7310: LD_INT 0
7312: PPUSH
7313: PPUSH
// begin enable ;
7314: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
7315: LD_ADDR_VAR 0 1
7319: PUSH
7320: LD_INT 22
7322: PUSH
7323: LD_OWVAR 2
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: PUSH
7332: LD_INT 61
7334: PUSH
7335: EMPTY
7336: LIST
7337: PUSH
7338: LD_INT 33
7340: PUSH
7341: LD_INT 2
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: PUSH
7348: EMPTY
7349: LIST
7350: LIST
7351: LIST
7352: PPUSH
7353: CALL_OW 69
7357: ST_TO_ADDR
// if not tmp then
7358: LD_VAR 0 1
7362: NOT
7363: IFFALSE 7367
// exit ;
7365: GO 7404
// for i in tmp do
7367: LD_ADDR_VAR 0 2
7371: PUSH
7372: LD_VAR 0 1
7376: PUSH
7377: FOR_IN
7378: IFFALSE 7402
// if IsControledBy ( i ) then
7380: LD_VAR 0 2
7384: PPUSH
7385: CALL_OW 312
7389: IFFALSE 7400
// ComUnlink ( i ) ;
7391: LD_VAR 0 2
7395: PPUSH
7396: CALL_OW 136
7400: GO 7377
7402: POP
7403: POP
// end ;
7404: PPOPN 2
7406: END
