// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 48 0 0
// InitTag ;
   8: CALL 72 0 0
// if debug then
  12: LD_EXP 1
  16: IFFALSE 25
// FogOff ( 2 ) ;
  18: LD_INT 2
  20: PPUSH
  21: CALL_OW 344
// PrepareNature ( forestArea , swampArea ) ;
  25: LD_INT 3
  27: PPUSH
  28: LD_INT 2
  30: PPUSH
  31: CALL 539 0 2
// PrepareArabian ;
  35: CALL 2651 0 0
// PrepareRussian ;
  39: CALL 3183 0 0
// Action ;
  43: CALL 3191 0 0
// end ;
  47: END
// export debug , prefix ; function Init ; begin
  48: LD_INT 0
  50: PPUSH
// debug := true ;
  51: LD_ADDR_EXP 1
  55: PUSH
  56: LD_INT 1
  58: ST_TO_ADDR
// prefix := 04_2_ ;
  59: LD_ADDR_EXP 2
  63: PUSH
  64: LD_STRING 04_2_
  66: ST_TO_ADDR
// end ;
  67: LD_VAR 0 1
  71: RET
// function InitTag ; begin
  72: LD_INT 0
  74: PPUSH
// end ;
  75: LD_VAR 0 1
  79: RET
// every 0 0$1 trigger debug do var i ;
  80: LD_EXP 1
  84: IFFALSE 168
  86: GO 88
  88: DISABLE
  89: LD_INT 0
  91: PPUSH
// begin enable ;
  92: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) do
  93: LD_ADDR_VAR 0 1
  97: PUSH
  98: LD_INT 22
 100: PUSH
 101: LD_INT 2
 103: PUSH
 104: EMPTY
 105: LIST
 106: LIST
 107: PUSH
 108: LD_INT 3
 110: PUSH
 111: LD_INT 21
 113: PUSH
 114: LD_INT 3
 116: PUSH
 117: EMPTY
 118: LIST
 119: LIST
 120: PUSH
 121: EMPTY
 122: LIST
 123: LIST
 124: PUSH
 125: EMPTY
 126: LIST
 127: LIST
 128: PPUSH
 129: CALL_OW 69
 133: PUSH
 134: FOR_IN
 135: IFFALSE 166
// if GetLives ( i ) < 1000 then
 137: LD_VAR 0 1
 141: PPUSH
 142: CALL_OW 256
 146: PUSH
 147: LD_INT 1000
 149: LESS
 150: IFFALSE 164
// SetLives ( i , 1000 ) ;
 152: LD_VAR 0 1
 156: PPUSH
 157: LD_INT 1000
 159: PPUSH
 160: CALL_OW 234
 164: GO 134
 166: POP
 167: POP
// end ; end_of_file
 168: PPOPN 1
 170: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 171: LD_INT 0
 173: PPUSH
 174: PPUSH
// if exist_mode then
 175: LD_VAR 0 2
 179: IFFALSE 204
// unit := CreateCharacter ( prefix & ident ) else
 181: LD_ADDR_VAR 0 5
 185: PUSH
 186: LD_VAR 0 3
 190: PUSH
 191: LD_VAR 0 1
 195: STR
 196: PPUSH
 197: CALL_OW 34
 201: ST_TO_ADDR
 202: GO 219
// unit := NewCharacter ( ident ) ;
 204: LD_ADDR_VAR 0 5
 208: PUSH
 209: LD_VAR 0 1
 213: PPUSH
 214: CALL_OW 25
 218: ST_TO_ADDR
// result := unit ;
 219: LD_ADDR_VAR 0 4
 223: PUSH
 224: LD_VAR 0 5
 228: ST_TO_ADDR
// end ;
 229: LD_VAR 0 4
 233: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 234: LD_INT 0
 236: PPUSH
// uc_side := side ;
 237: LD_ADDR_OWVAR 20
 241: PUSH
 242: LD_VAR 0 1
 246: ST_TO_ADDR
// uc_nation := nation ;
 247: LD_ADDR_OWVAR 21
 251: PUSH
 252: LD_VAR 0 2
 256: ST_TO_ADDR
// vc_chassis := chassis ;
 257: LD_ADDR_OWVAR 37
 261: PUSH
 262: LD_VAR 0 3
 266: ST_TO_ADDR
// vc_engine := engine ;
 267: LD_ADDR_OWVAR 39
 271: PUSH
 272: LD_VAR 0 4
 276: ST_TO_ADDR
// vc_control := control ;
 277: LD_ADDR_OWVAR 38
 281: PUSH
 282: LD_VAR 0 5
 286: ST_TO_ADDR
// vc_weapon := weapon ;
 287: LD_ADDR_OWVAR 40
 291: PUSH
 292: LD_VAR 0 6
 296: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 297: LD_ADDR_OWVAR 41
 301: PUSH
 302: LD_VAR 0 7
 306: ST_TO_ADDR
// result := CreateVehicle ;
 307: LD_ADDR_VAR 0 8
 311: PUSH
 312: CALL_OW 45
 316: ST_TO_ADDR
// end ;
 317: LD_VAR 0 8
 321: RET
// export function SayX ( units , ident ) ; var i ; begin
 322: LD_INT 0
 324: PPUSH
 325: PPUSH
// result := false ;
 326: LD_ADDR_VAR 0 3
 330: PUSH
 331: LD_INT 0
 333: ST_TO_ADDR
// if not units then
 334: LD_VAR 0 1
 338: NOT
 339: IFFALSE 343
// exit ;
 341: GO 397
// for i in units do
 343: LD_ADDR_VAR 0 4
 347: PUSH
 348: LD_VAR 0 1
 352: PUSH
 353: FOR_IN
 354: IFFALSE 395
// if IsOk ( i ) then
 356: LD_VAR 0 4
 360: PPUSH
 361: CALL_OW 302
 365: IFFALSE 393
// begin Say ( i , ident ) ;
 367: LD_VAR 0 4
 371: PPUSH
 372: LD_VAR 0 2
 376: PPUSH
 377: CALL_OW 88
// result := i ;
 381: LD_ADDR_VAR 0 3
 385: PUSH
 386: LD_VAR 0 4
 390: ST_TO_ADDR
// break ;
 391: GO 395
// end ;
 393: GO 353
 395: POP
 396: POP
// end ;
 397: LD_VAR 0 3
 401: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 402: LD_INT 0
 404: PPUSH
 405: PPUSH
// InitUc ;
 406: CALL_OW 18
// InitHc ;
 410: CALL_OW 19
// uc_side := 0 ;
 414: LD_ADDR_OWVAR 20
 418: PUSH
 419: LD_INT 0
 421: ST_TO_ADDR
// uc_nation := 0 ;
 422: LD_ADDR_OWVAR 21
 426: PUSH
 427: LD_INT 0
 429: ST_TO_ADDR
// for i = 1 to amount do
 430: LD_ADDR_VAR 0 4
 434: PUSH
 435: DOUBLE
 436: LD_INT 1
 438: DEC
 439: ST_TO_ADDR
 440: LD_VAR 0 2
 444: PUSH
 445: FOR_TO
 446: IFFALSE 528
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 448: LD_ADDR_OWVAR 29
 452: PUSH
 453: LD_INT 9
 455: PPUSH
 456: LD_INT 12
 458: PPUSH
 459: CALL_OW 12
 463: PUSH
 464: LD_INT 9
 466: PPUSH
 467: LD_INT 12
 469: PPUSH
 470: CALL_OW 12
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 479: LD_ADDR_OWVAR 35
 483: PUSH
 484: LD_INT 1
 486: NEG
 487: PPUSH
 488: LD_INT 1
 490: PPUSH
 491: CALL_OW 12
 495: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 496: LD_INT 0
 498: PPUSH
 499: LD_INT 12
 501: PPUSH
 502: LD_INT 1
 504: PPUSH
 505: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 509: CALL_OW 44
 513: PPUSH
 514: LD_VAR 0 1
 518: PPUSH
 519: LD_INT 0
 521: PPUSH
 522: CALL_OW 49
// end ;
 526: GO 445
 528: POP
 529: POP
// InitHc ;
 530: CALL_OW 19
// end ;
 534: LD_VAR 0 3
 538: RET
// export function PrepareNature ( forest , swamp ) ; var i ; begin
 539: LD_INT 0
 541: PPUSH
 542: PPUSH
// SpawnApeman ( forest , [ 5 , 4 , 4 ] [ Difficulty ] ) ;
 543: LD_VAR 0 1
 547: PPUSH
 548: LD_INT 5
 550: PUSH
 551: LD_INT 4
 553: PUSH
 554: LD_INT 4
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: LIST
 561: PUSH
 562: LD_OWVAR 67
 566: ARRAY
 567: PPUSH
 568: CALL 402 0 2
// for i := 1 to 3 do
 572: LD_ADDR_VAR 0 4
 576: PUSH
 577: DOUBLE
 578: LD_INT 1
 580: DEC
 581: ST_TO_ADDR
 582: LD_INT 3
 584: PUSH
 585: FOR_TO
 586: IFFALSE 623
// begin hc_class := 21 ;
 588: LD_ADDR_OWVAR 28
 592: PUSH
 593: LD_INT 21
 595: ST_TO_ADDR
// hc_gallery :=  ;
 596: LD_ADDR_OWVAR 33
 600: PUSH
 601: LD_STRING 
 603: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 604: CALL_OW 44
 608: PPUSH
 609: LD_VAR 0 1
 613: PPUSH
 614: LD_INT 0
 616: PPUSH
 617: CALL_OW 49
// end ;
 621: GO 585
 623: POP
 624: POP
// for i := 1 to 3 do
 625: LD_ADDR_VAR 0 4
 629: PUSH
 630: DOUBLE
 631: LD_INT 1
 633: DEC
 634: ST_TO_ADDR
 635: LD_INT 3
 637: PUSH
 638: FOR_TO
 639: IFFALSE 676
// begin hc_class := 18 ;
 641: LD_ADDR_OWVAR 28
 645: PUSH
 646: LD_INT 18
 648: ST_TO_ADDR
// hc_gallery :=  ;
 649: LD_ADDR_OWVAR 33
 653: PUSH
 654: LD_STRING 
 656: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 657: CALL_OW 44
 661: PPUSH
 662: LD_VAR 0 1
 666: PPUSH
 667: LD_INT 0
 669: PPUSH
 670: CALL_OW 49
// end ;
 674: GO 638
 676: POP
 677: POP
// for i := 1 to 3 do
 678: LD_ADDR_VAR 0 4
 682: PUSH
 683: DOUBLE
 684: LD_INT 1
 686: DEC
 687: ST_TO_ADDR
 688: LD_INT 3
 690: PUSH
 691: FOR_TO
 692: IFFALSE 729
// begin hc_class := 13 ;
 694: LD_ADDR_OWVAR 28
 698: PUSH
 699: LD_INT 13
 701: ST_TO_ADDR
// hc_gallery :=  ;
 702: LD_ADDR_OWVAR 33
 706: PUSH
 707: LD_STRING 
 709: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 710: CALL_OW 44
 714: PPUSH
 715: LD_VAR 0 1
 719: PPUSH
 720: LD_INT 0
 722: PPUSH
 723: CALL_OW 49
// end ;
 727: GO 691
 729: POP
 730: POP
// for i := 1 to 4 do
 731: LD_ADDR_VAR 0 4
 735: PUSH
 736: DOUBLE
 737: LD_INT 1
 739: DEC
 740: ST_TO_ADDR
 741: LD_INT 4
 743: PUSH
 744: FOR_TO
 745: IFFALSE 782
// begin hc_class := class_frog ;
 747: LD_ADDR_OWVAR 28
 751: PUSH
 752: LD_INT 19
 754: ST_TO_ADDR
// hc_gallery :=  ;
 755: LD_ADDR_OWVAR 33
 759: PUSH
 760: LD_STRING 
 762: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , swamp , false ) ;
 763: CALL_OW 44
 767: PPUSH
 768: LD_VAR 0 2
 772: PPUSH
 773: LD_INT 0
 775: PPUSH
 776: CALL_OW 49
// end ;
 780: GO 744
 782: POP
 783: POP
// end ;
 784: LD_VAR 0 3
 788: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 789: LD_INT 0
 791: PPUSH
 792: PPUSH
 793: PPUSH
// if not observer or not unit then
 794: LD_VAR 0 1
 798: NOT
 799: PUSH
 800: LD_VAR 0 2
 804: NOT
 805: OR
 806: IFFALSE 810
// exit ;
 808: GO 858
// if not See ( GetSide ( observer ) , unit ) then
 810: LD_VAR 0 1
 814: PPUSH
 815: CALL_OW 255
 819: PPUSH
 820: LD_VAR 0 2
 824: PPUSH
 825: CALL_OW 292
 829: NOT
 830: IFFALSE 834
// exit ;
 832: GO 858
// result := GetDistUnits ( observer , unit ) < 12 ;
 834: LD_ADDR_VAR 0 3
 838: PUSH
 839: LD_VAR 0 1
 843: PPUSH
 844: LD_VAR 0 2
 848: PPUSH
 849: CALL_OW 296
 853: PUSH
 854: LD_INT 12
 856: LESS
 857: ST_TO_ADDR
// end ;
 858: LD_VAR 0 3
 862: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 863: LD_INT 0
 865: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 866: LD_VAR 0 2
 870: PUSH
 871: LD_INT 1
 873: ARRAY
 874: PPUSH
 875: LD_VAR 0 2
 879: PUSH
 880: LD_INT 2
 882: ARRAY
 883: PPUSH
 884: CALL_OW 488
 888: PUSH
 889: LD_VAR 0 2
 893: PUSH
 894: LD_INT 1
 896: ARRAY
 897: PPUSH
 898: LD_VAR 0 2
 902: PUSH
 903: LD_INT 2
 905: ARRAY
 906: PPUSH
 907: CALL_OW 428
 911: PUSH
 912: LD_INT 0
 914: EQUAL
 915: AND
 916: IFFALSE 950
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 918: LD_VAR 0 1
 922: PPUSH
 923: LD_VAR 0 2
 927: PUSH
 928: LD_INT 1
 930: ARRAY
 931: PPUSH
 932: LD_VAR 0 2
 936: PUSH
 937: LD_INT 2
 939: ARRAY
 940: PPUSH
 941: LD_VAR 0 3
 945: PPUSH
 946: CALL_OW 48
// end ;
 950: LD_VAR 0 4
 954: RET
// export function Video ( mode ) ; begin
 955: LD_INT 0
 957: PPUSH
// ingame_video = mode ;
 958: LD_ADDR_OWVAR 52
 962: PUSH
 963: LD_VAR 0 1
 967: ST_TO_ADDR
// interface_hidden = mode ;
 968: LD_ADDR_OWVAR 54
 972: PUSH
 973: LD_VAR 0 1
 977: ST_TO_ADDR
// end ;
 978: LD_VAR 0 2
 982: RET
// export function ReverseArray ( array ) ; var i ; begin
 983: LD_INT 0
 985: PPUSH
 986: PPUSH
// if not array then
 987: LD_VAR 0 1
 991: NOT
 992: IFFALSE 996
// exit ;
 994: GO 1054
// result := [ ] ;
 996: LD_ADDR_VAR 0 2
1000: PUSH
1001: EMPTY
1002: ST_TO_ADDR
// for i := 1 to array do
1003: LD_ADDR_VAR 0 3
1007: PUSH
1008: DOUBLE
1009: LD_INT 1
1011: DEC
1012: ST_TO_ADDR
1013: LD_VAR 0 1
1017: PUSH
1018: FOR_TO
1019: IFFALSE 1052
// result := Insert ( result , 1 , array [ i ] ) ;
1021: LD_ADDR_VAR 0 2
1025: PUSH
1026: LD_VAR 0 2
1030: PPUSH
1031: LD_INT 1
1033: PPUSH
1034: LD_VAR 0 1
1038: PUSH
1039: LD_VAR 0 3
1043: ARRAY
1044: PPUSH
1045: CALL_OW 2
1049: ST_TO_ADDR
1050: GO 1018
1052: POP
1053: POP
// end ;
1054: LD_VAR 0 2
1058: RET
// export function ComExit ( unit ) ; begin
1059: LD_INT 0
1061: PPUSH
// result := IsInUnit ( unit ) ;
1062: LD_ADDR_VAR 0 2
1066: PUSH
1067: LD_VAR 0 1
1071: PPUSH
1072: CALL_OW 310
1076: ST_TO_ADDR
// if not result then
1077: LD_VAR 0 2
1081: NOT
1082: IFFALSE 1086
// exit ;
1084: GO 1121
// if GetType ( result ) = unit_vehicle then
1086: LD_VAR 0 2
1090: PPUSH
1091: CALL_OW 247
1095: PUSH
1096: LD_INT 2
1098: EQUAL
1099: IFFALSE 1112
// ComExitVehicle ( unit ) else
1101: LD_VAR 0 1
1105: PPUSH
1106: CALL_OW 121
1110: GO 1121
// ComExitBuilding ( unit ) ;
1112: LD_VAR 0 1
1116: PPUSH
1117: CALL_OW 122
// end ;
1121: LD_VAR 0 2
1125: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1126: LD_INT 0
1128: PPUSH
1129: PPUSH
// if not side or not nation then
1130: LD_VAR 0 1
1134: NOT
1135: PUSH
1136: LD_VAR 0 2
1140: NOT
1141: OR
1142: IFFALSE 1146
// exit ;
1144: GO 1910
// case nation of nation_american :
1146: LD_VAR 0 2
1150: PUSH
1151: LD_INT 1
1153: DOUBLE
1154: EQUAL
1155: IFTRUE 1159
1157: GO 1373
1159: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1160: LD_ADDR_VAR 0 4
1164: PUSH
1165: LD_INT 35
1167: PUSH
1168: LD_INT 45
1170: PUSH
1171: LD_INT 46
1173: PUSH
1174: LD_INT 47
1176: PUSH
1177: LD_INT 82
1179: PUSH
1180: LD_INT 83
1182: PUSH
1183: LD_INT 84
1185: PUSH
1186: LD_INT 85
1188: PUSH
1189: LD_INT 86
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 2
1197: PUSH
1198: LD_INT 6
1200: PUSH
1201: LD_INT 15
1203: PUSH
1204: LD_INT 16
1206: PUSH
1207: LD_INT 7
1209: PUSH
1210: LD_INT 12
1212: PUSH
1213: LD_INT 13
1215: PUSH
1216: LD_INT 10
1218: PUSH
1219: LD_INT 14
1221: PUSH
1222: LD_INT 20
1224: PUSH
1225: LD_INT 21
1227: PUSH
1228: LD_INT 22
1230: PUSH
1231: LD_INT 25
1233: PUSH
1234: LD_INT 32
1236: PUSH
1237: LD_INT 27
1239: PUSH
1240: LD_INT 36
1242: PUSH
1243: LD_INT 69
1245: PUSH
1246: LD_INT 39
1248: PUSH
1249: LD_INT 34
1251: PUSH
1252: LD_INT 40
1254: PUSH
1255: LD_INT 48
1257: PUSH
1258: LD_INT 49
1260: PUSH
1261: LD_INT 50
1263: PUSH
1264: LD_INT 51
1266: PUSH
1267: LD_INT 52
1269: PUSH
1270: LD_INT 53
1272: PUSH
1273: LD_INT 54
1275: PUSH
1276: LD_INT 55
1278: PUSH
1279: LD_INT 56
1281: PUSH
1282: LD_INT 57
1284: PUSH
1285: LD_INT 58
1287: PUSH
1288: LD_INT 59
1290: PUSH
1291: LD_INT 60
1293: PUSH
1294: LD_INT 61
1296: PUSH
1297: LD_INT 62
1299: PUSH
1300: LD_INT 80
1302: PUSH
1303: LD_INT 82
1305: PUSH
1306: LD_INT 83
1308: PUSH
1309: LD_INT 84
1311: PUSH
1312: LD_INT 85
1314: PUSH
1315: LD_INT 86
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: LIST
1329: LIST
1330: LIST
1331: LIST
1332: LIST
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: LIST
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: LIST
1361: LIST
1362: LIST
1363: LIST
1364: LIST
1365: LIST
1366: LIST
1367: LIST
1368: LIST
1369: LIST
1370: ST_TO_ADDR
1371: GO 1834
1373: LD_INT 2
1375: DOUBLE
1376: EQUAL
1377: IFTRUE 1381
1379: GO 1603
1381: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1382: LD_ADDR_VAR 0 4
1386: PUSH
1387: LD_INT 35
1389: PUSH
1390: LD_INT 45
1392: PUSH
1393: LD_INT 46
1395: PUSH
1396: LD_INT 47
1398: PUSH
1399: LD_INT 82
1401: PUSH
1402: LD_INT 83
1404: PUSH
1405: LD_INT 84
1407: PUSH
1408: LD_INT 85
1410: PUSH
1411: LD_INT 87
1413: PUSH
1414: LD_INT 70
1416: PUSH
1417: LD_INT 1
1419: PUSH
1420: LD_INT 11
1422: PUSH
1423: LD_INT 3
1425: PUSH
1426: LD_INT 4
1428: PUSH
1429: LD_INT 5
1431: PUSH
1432: LD_INT 6
1434: PUSH
1435: LD_INT 15
1437: PUSH
1438: LD_INT 18
1440: PUSH
1441: LD_INT 7
1443: PUSH
1444: LD_INT 17
1446: PUSH
1447: LD_INT 8
1449: PUSH
1450: LD_INT 20
1452: PUSH
1453: LD_INT 21
1455: PUSH
1456: LD_INT 22
1458: PUSH
1459: LD_INT 72
1461: PUSH
1462: LD_INT 26
1464: PUSH
1465: LD_INT 69
1467: PUSH
1468: LD_INT 39
1470: PUSH
1471: LD_INT 40
1473: PUSH
1474: LD_INT 41
1476: PUSH
1477: LD_INT 42
1479: PUSH
1480: LD_INT 43
1482: PUSH
1483: LD_INT 48
1485: PUSH
1486: LD_INT 49
1488: PUSH
1489: LD_INT 50
1491: PUSH
1492: LD_INT 51
1494: PUSH
1495: LD_INT 52
1497: PUSH
1498: LD_INT 53
1500: PUSH
1501: LD_INT 54
1503: PUSH
1504: LD_INT 55
1506: PUSH
1507: LD_INT 56
1509: PUSH
1510: LD_INT 60
1512: PUSH
1513: LD_INT 61
1515: PUSH
1516: LD_INT 62
1518: PUSH
1519: LD_INT 66
1521: PUSH
1522: LD_INT 67
1524: PUSH
1525: LD_INT 68
1527: PUSH
1528: LD_INT 81
1530: PUSH
1531: LD_INT 82
1533: PUSH
1534: LD_INT 83
1536: PUSH
1537: LD_INT 84
1539: PUSH
1540: LD_INT 85
1542: PUSH
1543: LD_INT 87
1545: PUSH
1546: EMPTY
1547: LIST
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: LIST
1553: LIST
1554: LIST
1555: LIST
1556: LIST
1557: LIST
1558: LIST
1559: LIST
1560: LIST
1561: LIST
1562: LIST
1563: LIST
1564: LIST
1565: LIST
1566: LIST
1567: LIST
1568: LIST
1569: LIST
1570: LIST
1571: LIST
1572: LIST
1573: LIST
1574: LIST
1575: LIST
1576: LIST
1577: LIST
1578: LIST
1579: LIST
1580: LIST
1581: LIST
1582: LIST
1583: LIST
1584: LIST
1585: LIST
1586: LIST
1587: LIST
1588: LIST
1589: LIST
1590: LIST
1591: LIST
1592: LIST
1593: LIST
1594: LIST
1595: LIST
1596: LIST
1597: LIST
1598: LIST
1599: LIST
1600: ST_TO_ADDR
1601: GO 1834
1603: LD_INT 3
1605: DOUBLE
1606: EQUAL
1607: IFTRUE 1611
1609: GO 1833
1611: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1612: LD_ADDR_VAR 0 4
1616: PUSH
1617: LD_INT 46
1619: PUSH
1620: LD_INT 47
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: LD_INT 2
1628: PUSH
1629: LD_INT 82
1631: PUSH
1632: LD_INT 83
1634: PUSH
1635: LD_INT 84
1637: PUSH
1638: LD_INT 85
1640: PUSH
1641: LD_INT 86
1643: PUSH
1644: LD_INT 11
1646: PUSH
1647: LD_INT 9
1649: PUSH
1650: LD_INT 20
1652: PUSH
1653: LD_INT 19
1655: PUSH
1656: LD_INT 21
1658: PUSH
1659: LD_INT 24
1661: PUSH
1662: LD_INT 22
1664: PUSH
1665: LD_INT 25
1667: PUSH
1668: LD_INT 28
1670: PUSH
1671: LD_INT 29
1673: PUSH
1674: LD_INT 30
1676: PUSH
1677: LD_INT 31
1679: PUSH
1680: LD_INT 37
1682: PUSH
1683: LD_INT 38
1685: PUSH
1686: LD_INT 32
1688: PUSH
1689: LD_INT 27
1691: PUSH
1692: LD_INT 33
1694: PUSH
1695: LD_INT 69
1697: PUSH
1698: LD_INT 39
1700: PUSH
1701: LD_INT 34
1703: PUSH
1704: LD_INT 40
1706: PUSH
1707: LD_INT 71
1709: PUSH
1710: LD_INT 23
1712: PUSH
1713: LD_INT 44
1715: PUSH
1716: LD_INT 48
1718: PUSH
1719: LD_INT 49
1721: PUSH
1722: LD_INT 50
1724: PUSH
1725: LD_INT 51
1727: PUSH
1728: LD_INT 52
1730: PUSH
1731: LD_INT 53
1733: PUSH
1734: LD_INT 54
1736: PUSH
1737: LD_INT 55
1739: PUSH
1740: LD_INT 56
1742: PUSH
1743: LD_INT 57
1745: PUSH
1746: LD_INT 58
1748: PUSH
1749: LD_INT 59
1751: PUSH
1752: LD_INT 63
1754: PUSH
1755: LD_INT 64
1757: PUSH
1758: LD_INT 65
1760: PUSH
1761: LD_INT 82
1763: PUSH
1764: LD_INT 83
1766: PUSH
1767: LD_INT 84
1769: PUSH
1770: LD_INT 85
1772: PUSH
1773: LD_INT 86
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: LIST
1780: LIST
1781: LIST
1782: LIST
1783: LIST
1784: LIST
1785: LIST
1786: LIST
1787: LIST
1788: LIST
1789: LIST
1790: LIST
1791: LIST
1792: LIST
1793: LIST
1794: LIST
1795: LIST
1796: LIST
1797: LIST
1798: LIST
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: LIST
1805: LIST
1806: LIST
1807: LIST
1808: LIST
1809: LIST
1810: LIST
1811: LIST
1812: LIST
1813: LIST
1814: LIST
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: LIST
1820: LIST
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: LIST
1829: LIST
1830: ST_TO_ADDR
1831: GO 1834
1833: POP
// if state > - 1 and state < 3 then
1834: LD_VAR 0 3
1838: PUSH
1839: LD_INT 1
1841: NEG
1842: GREATER
1843: PUSH
1844: LD_VAR 0 3
1848: PUSH
1849: LD_INT 3
1851: LESS
1852: AND
1853: IFFALSE 1910
// for i in result do
1855: LD_ADDR_VAR 0 5
1859: PUSH
1860: LD_VAR 0 4
1864: PUSH
1865: FOR_IN
1866: IFFALSE 1908
// if GetTech ( i , side ) <> state then
1868: LD_VAR 0 5
1872: PPUSH
1873: LD_VAR 0 1
1877: PPUSH
1878: CALL_OW 321
1882: PUSH
1883: LD_VAR 0 3
1887: NONEQUAL
1888: IFFALSE 1906
// result := result diff i ;
1890: LD_ADDR_VAR 0 4
1894: PUSH
1895: LD_VAR 0 4
1899: PUSH
1900: LD_VAR 0 5
1904: DIFF
1905: ST_TO_ADDR
1906: GO 1865
1908: POP
1909: POP
// end ;
1910: LD_VAR 0 4
1914: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
1915: LD_INT 0
1917: PPUSH
1918: PPUSH
1919: PPUSH
1920: PPUSH
// if not list then
1921: LD_VAR 0 3
1925: NOT
1926: IFFALSE 1930
// exit ;
1928: GO 2238
// result := [ ] ;
1930: LD_ADDR_VAR 0 5
1934: PUSH
1935: EMPTY
1936: ST_TO_ADDR
// for i in list do
1937: LD_ADDR_VAR 0 6
1941: PUSH
1942: LD_VAR 0 3
1946: PUSH
1947: FOR_IN
1948: IFFALSE 2150
// begin tmp := GetDistUnitXY ( i , x , y ) ;
1950: LD_ADDR_VAR 0 8
1954: PUSH
1955: LD_VAR 0 6
1959: PPUSH
1960: LD_VAR 0 1
1964: PPUSH
1965: LD_VAR 0 2
1969: PPUSH
1970: CALL_OW 297
1974: ST_TO_ADDR
// if not result then
1975: LD_VAR 0 5
1979: NOT
1980: IFFALSE 2006
// result := [ [ i , tmp ] ] else
1982: LD_ADDR_VAR 0 5
1986: PUSH
1987: LD_VAR 0 6
1991: PUSH
1992: LD_VAR 0 8
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: PUSH
2001: EMPTY
2002: LIST
2003: ST_TO_ADDR
2004: GO 2148
// begin if result [ result ] [ 2 ] < tmp then
2006: LD_VAR 0 5
2010: PUSH
2011: LD_VAR 0 5
2015: ARRAY
2016: PUSH
2017: LD_INT 2
2019: ARRAY
2020: PUSH
2021: LD_VAR 0 8
2025: LESS
2026: IFFALSE 2068
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
2028: LD_ADDR_VAR 0 5
2032: PUSH
2033: LD_VAR 0 5
2037: PPUSH
2038: LD_VAR 0 5
2042: PUSH
2043: LD_INT 1
2045: PLUS
2046: PPUSH
2047: LD_VAR 0 6
2051: PUSH
2052: LD_VAR 0 8
2056: PUSH
2057: EMPTY
2058: LIST
2059: LIST
2060: PPUSH
2061: CALL_OW 2
2065: ST_TO_ADDR
2066: GO 2148
// for j = 1 to result do
2068: LD_ADDR_VAR 0 7
2072: PUSH
2073: DOUBLE
2074: LD_INT 1
2076: DEC
2077: ST_TO_ADDR
2078: LD_VAR 0 5
2082: PUSH
2083: FOR_TO
2084: IFFALSE 2146
// begin if tmp < result [ j ] [ 2 ] then
2086: LD_VAR 0 8
2090: PUSH
2091: LD_VAR 0 5
2095: PUSH
2096: LD_VAR 0 7
2100: ARRAY
2101: PUSH
2102: LD_INT 2
2104: ARRAY
2105: LESS
2106: IFFALSE 2144
// begin result := Insert ( result , j , [ i , tmp ] ) ;
2108: LD_ADDR_VAR 0 5
2112: PUSH
2113: LD_VAR 0 5
2117: PPUSH
2118: LD_VAR 0 7
2122: PPUSH
2123: LD_VAR 0 6
2127: PUSH
2128: LD_VAR 0 8
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: PPUSH
2137: CALL_OW 2
2141: ST_TO_ADDR
// break ;
2142: GO 2146
// end ; end ;
2144: GO 2083
2146: POP
2147: POP
// end ; end ;
2148: GO 1947
2150: POP
2151: POP
// if result and not asc then
2152: LD_VAR 0 5
2156: PUSH
2157: LD_VAR 0 4
2161: NOT
2162: AND
2163: IFFALSE 2238
// begin tmp := result ;
2165: LD_ADDR_VAR 0 8
2169: PUSH
2170: LD_VAR 0 5
2174: ST_TO_ADDR
// for i = tmp downto 1 do
2175: LD_ADDR_VAR 0 6
2179: PUSH
2180: DOUBLE
2181: LD_VAR 0 8
2185: INC
2186: ST_TO_ADDR
2187: LD_INT 1
2189: PUSH
2190: FOR_DOWNTO
2191: IFFALSE 2236
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
2193: LD_ADDR_VAR 0 5
2197: PUSH
2198: LD_VAR 0 5
2202: PPUSH
2203: LD_VAR 0 8
2207: PUSH
2208: LD_VAR 0 6
2212: MINUS
2213: PUSH
2214: LD_INT 1
2216: PLUS
2217: PPUSH
2218: LD_VAR 0 8
2222: PUSH
2223: LD_VAR 0 6
2227: ARRAY
2228: PPUSH
2229: CALL_OW 1
2233: ST_TO_ADDR
2234: GO 2190
2236: POP
2237: POP
// end ; end ;
2238: LD_VAR 0 5
2242: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
2243: LD_INT 0
2245: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
2246: LD_ADDR_VAR 0 4
2250: PUSH
2251: LD_VAR 0 1
2255: PPUSH
2256: CALL_OW 250
2260: PPUSH
2261: LD_VAR 0 1
2265: PPUSH
2266: CALL_OW 251
2270: PPUSH
2271: LD_VAR 0 2
2275: PPUSH
2276: LD_VAR 0 3
2280: PPUSH
2281: CALL 1915 0 4
2285: ST_TO_ADDR
// end ;
2286: LD_VAR 0 4
2290: RET
// export function NearestEmptyBuilding ( unit , btype ) ; var side , tmp , i , places ; begin
2291: LD_INT 0
2293: PPUSH
2294: PPUSH
2295: PPUSH
2296: PPUSH
2297: PPUSH
// if not unit then
2298: LD_VAR 0 1
2302: NOT
2303: IFFALSE 2307
// exit ;
2305: GO 2509
// side := GetSide ( unit ) ;
2307: LD_ADDR_VAR 0 4
2311: PUSH
2312: LD_VAR 0 1
2316: PPUSH
2317: CALL_OW 255
2321: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
2322: LD_ADDR_VAR 0 5
2326: PUSH
2327: LD_INT 22
2329: PUSH
2330: LD_VAR 0 4
2334: PUSH
2335: EMPTY
2336: LIST
2337: LIST
2338: PUSH
2339: LD_INT 30
2341: PUSH
2342: LD_VAR 0 2
2346: PUSH
2347: EMPTY
2348: LIST
2349: LIST
2350: PUSH
2351: EMPTY
2352: LIST
2353: LIST
2354: PPUSH
2355: CALL_OW 69
2359: ST_TO_ADDR
// if not tmp then
2360: LD_VAR 0 5
2364: NOT
2365: IFFALSE 2369
// exit ;
2367: GO 2509
// tmp := SortByDistanceUnit ( unit , tmp , true ) ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 1
2378: PPUSH
2379: LD_VAR 0 5
2383: PPUSH
2384: LD_INT 1
2386: PPUSH
2387: CALL 2243 0 3
2391: ST_TO_ADDR
// places := 1 ;
2392: LD_ADDR_VAR 0 7
2396: PUSH
2397: LD_INT 1
2399: ST_TO_ADDR
// if btype in [ b_depot , b_warehouse , b_armoury , b_barracks , b_workshop , b_factory , b_lab , b_lab_half , b_lab_full ] then
2400: LD_VAR 0 2
2404: PUSH
2405: LD_INT 0
2407: PUSH
2408: LD_INT 1
2410: PUSH
2411: LD_INT 4
2413: PUSH
2414: LD_INT 5
2416: PUSH
2417: LD_INT 2
2419: PUSH
2420: LD_INT 3
2422: PUSH
2423: LD_INT 6
2425: PUSH
2426: LD_INT 7
2428: PUSH
2429: LD_INT 8
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: LIST
2436: LIST
2437: LIST
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: IN
2443: IFFALSE 2453
// places := 6 ;
2445: LD_ADDR_VAR 0 7
2449: PUSH
2450: LD_INT 6
2452: ST_TO_ADDR
// for i in tmp do
2453: LD_ADDR_VAR 0 6
2457: PUSH
2458: LD_VAR 0 5
2462: PUSH
2463: FOR_IN
2464: IFFALSE 2507
// begin if UnitsInside ( i ) - places <= 0 then
2466: LD_VAR 0 6
2470: PPUSH
2471: CALL_OW 313
2475: PUSH
2476: LD_VAR 0 7
2480: MINUS
2481: PUSH
2482: LD_INT 0
2484: LESSEQUAL
2485: IFFALSE 2491
// continue else
2487: GO 2463
2489: GO 2505
// begin result := i ;
2491: LD_ADDR_VAR 0 3
2495: PUSH
2496: LD_VAR 0 6
2500: ST_TO_ADDR
// exit ;
2501: POP
2502: POP
2503: GO 2509
// end ; end ;
2505: GO 2463
2507: POP
2508: POP
// end ;
2509: LD_VAR 0 3
2513: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
2514: LD_INT 0
2516: PPUSH
2517: PPUSH
2518: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
2519: LD_VAR 0 1
2523: NOT
2524: PUSH
2525: LD_VAR 0 2
2529: PUSH
2530: LD_INT 1
2532: PUSH
2533: LD_INT 2
2535: PUSH
2536: LD_INT 3
2538: PUSH
2539: LD_INT 4
2541: PUSH
2542: EMPTY
2543: LIST
2544: LIST
2545: LIST
2546: LIST
2547: IN
2548: NOT
2549: OR
2550: IFFALSE 2554
// exit ;
2552: GO 2646
// tmp := [ ] ;
2554: LD_ADDR_VAR 0 5
2558: PUSH
2559: EMPTY
2560: ST_TO_ADDR
// for i in units do
2561: LD_ADDR_VAR 0 4
2565: PUSH
2566: LD_VAR 0 1
2570: PUSH
2571: FOR_IN
2572: IFFALSE 2615
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
2574: LD_ADDR_VAR 0 5
2578: PUSH
2579: LD_VAR 0 5
2583: PPUSH
2584: LD_VAR 0 5
2588: PUSH
2589: LD_INT 1
2591: PLUS
2592: PPUSH
2593: LD_VAR 0 4
2597: PPUSH
2598: LD_VAR 0 2
2602: PPUSH
2603: CALL_OW 259
2607: PPUSH
2608: CALL_OW 2
2612: ST_TO_ADDR
2613: GO 2571
2615: POP
2616: POP
// if not tmp then
2617: LD_VAR 0 5
2621: NOT
2622: IFFALSE 2626
// exit ;
2624: GO 2646
// result := SortListByListDesc ( units , tmp ) ;
2626: LD_ADDR_VAR 0 3
2630: PUSH
2631: LD_VAR 0 1
2635: PPUSH
2636: LD_VAR 0 5
2640: PPUSH
2641: CALL_OW 77
2645: ST_TO_ADDR
// end ; end_of_file
2646: LD_VAR 0 3
2650: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Shariff , Kurt , Aviradze , heikeSecondSquad , heikeVehicles , heikeApes ; export function PrepareArabian ; var i ; begin
2651: LD_INT 0
2653: PPUSH
2654: PPUSH
// uc_side := 2 ;
2655: LD_ADDR_OWVAR 20
2659: PUSH
2660: LD_INT 2
2662: ST_TO_ADDR
// uc_nation := 2 ;
2663: LD_ADDR_OWVAR 21
2667: PUSH
2668: LD_INT 2
2670: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2671: LD_ADDR_EXP 3
2675: PUSH
2676: LD_STRING Heike
2678: PPUSH
2679: LD_EXP 1
2683: NOT
2684: PPUSH
2685: LD_EXP 2
2689: PPUSH
2690: CALL 171 0 3
2694: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
2695: LD_ADDR_EXP 6
2699: PUSH
2700: LD_STRING Ibrahim
2702: PPUSH
2703: LD_EXP 1
2707: NOT
2708: PPUSH
2709: LD_EXP 2
2713: PPUSH
2714: CALL 171 0 3
2718: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2719: LD_ADDR_EXP 4
2723: PUSH
2724: LD_STRING Givi
2726: PPUSH
2727: LD_EXP 1
2731: NOT
2732: PPUSH
2733: LD_EXP 2
2737: PPUSH
2738: CALL 171 0 3
2742: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2743: LD_ADDR_EXP 7
2747: PUSH
2748: LD_STRING Kamil
2750: PPUSH
2751: LD_EXP 1
2755: NOT
2756: PPUSH
2757: LD_EXP 2
2761: PPUSH
2762: CALL 171 0 3
2766: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2767: LD_ADDR_EXP 8
2771: PUSH
2772: LD_STRING Kaia
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_EXP 2
2785: PPUSH
2786: CALL 171 0 3
2790: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2791: LD_ADDR_EXP 9
2795: PUSH
2796: LD_STRING Sophia
2798: PPUSH
2799: LD_EXP 1
2803: NOT
2804: PPUSH
2805: LD_EXP 2
2809: PPUSH
2810: CALL 171 0 3
2814: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2815: LD_ADDR_EXP 10
2819: PUSH
2820: LD_STRING Markov
2822: PPUSH
2823: LD_EXP 1
2827: NOT
2828: PPUSH
2829: LD_EXP 2
2833: PPUSH
2834: CALL 171 0 3
2838: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2839: LD_ADDR_EXP 13
2843: PUSH
2844: LD_STRING Aviradze
2846: PPUSH
2847: LD_EXP 1
2851: NOT
2852: PPUSH
2853: LD_EXP 2
2857: PPUSH
2858: CALL 171 0 3
2862: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , ( not debug ) , prefix ) ;
2863: LD_ADDR_EXP 12
2867: PUSH
2868: LD_STRING Kurt
2870: PPUSH
2871: LD_EXP 1
2875: NOT
2876: PPUSH
2877: LD_EXP 2
2881: PPUSH
2882: CALL 171 0 3
2886: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2887: LD_ADDR_EXP 5
2891: PUSH
2892: LD_STRING Mike
2894: PPUSH
2895: LD_EXP 1
2899: NOT
2900: PPUSH
2901: LD_EXP 2
2905: PPUSH
2906: CALL 171 0 3
2910: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_2_others ) ;
2911: LD_ADDR_EXP 14
2915: PUSH
2916: LD_STRING 04_2_others
2918: PPUSH
2919: CALL_OW 31
2923: ST_TO_ADDR
// heikeApes := CreateCharacterSet ( 04_2_apes ) ;
2924: LD_ADDR_EXP 16
2928: PUSH
2929: LD_STRING 04_2_apes
2931: PPUSH
2932: CALL_OW 31
2936: ST_TO_ADDR
// heikeVehicles := [ [ ar_medium_trike , engine_combustion , control_manual , ar_gun , 2 , 1000 , [ 0 , 0 ] ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gatling_gun , 2 , 1000 , [ 0 , 0 ] ] , [ ar_medium_trike , engine_combustion , control_manual , ar_flame_thrower , 2 , 1000 , [ 0 , 0 ] ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun , 2 , 1000 , [ 0 , 0 ] ] , [ ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 2 , 1000 , [ 0 , [ 60 , 40 , 20 ] [ Difficulty ] ] ] ] ;
2937: LD_ADDR_EXP 15
2941: PUSH
2942: LD_INT 13
2944: PUSH
2945: LD_INT 1
2947: PUSH
2948: LD_INT 1
2950: PUSH
2951: LD_INT 27
2953: PUSH
2954: LD_INT 2
2956: PUSH
2957: LD_INT 1000
2959: PUSH
2960: LD_INT 0
2962: PUSH
2963: LD_INT 0
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: LIST
2974: LIST
2975: LIST
2976: LIST
2977: LIST
2978: PUSH
2979: LD_INT 13
2981: PUSH
2982: LD_INT 1
2984: PUSH
2985: LD_INT 1
2987: PUSH
2988: LD_INT 25
2990: PUSH
2991: LD_INT 2
2993: PUSH
2994: LD_INT 1000
2996: PUSH
2997: LD_INT 0
2999: PUSH
3000: LD_INT 0
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: PUSH
3007: EMPTY
3008: LIST
3009: LIST
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_INT 13
3018: PUSH
3019: LD_INT 1
3021: PUSH
3022: LD_INT 1
3024: PUSH
3025: LD_INT 26
3027: PUSH
3028: LD_INT 2
3030: PUSH
3031: LD_INT 1000
3033: PUSH
3034: LD_INT 0
3036: PUSH
3037: LD_INT 0
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: LIST
3052: PUSH
3053: LD_INT 13
3055: PUSH
3056: LD_INT 1
3058: PUSH
3059: LD_INT 1
3061: PUSH
3062: LD_INT 27
3064: PUSH
3065: LD_INT 2
3067: PUSH
3068: LD_INT 1000
3070: PUSH
3071: LD_INT 0
3073: PUSH
3074: LD_INT 0
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: PUSH
3090: LD_INT 13
3092: PUSH
3093: LD_INT 1
3095: PUSH
3096: LD_INT 1
3098: PUSH
3099: LD_INT 32
3101: PUSH
3102: LD_INT 2
3104: PUSH
3105: LD_INT 1000
3107: PUSH
3108: LD_INT 0
3110: PUSH
3111: LD_INT 60
3113: PUSH
3114: LD_INT 40
3116: PUSH
3117: LD_INT 20
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: PUSH
3125: LD_OWVAR 67
3129: ARRAY
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: ST_TO_ADDR
// uc_side := 5 ;
3151: LD_ADDR_OWVAR 20
3155: PUSH
3156: LD_INT 5
3158: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
3159: LD_ADDR_EXP 11
3163: PUSH
3164: LD_STRING Abdul
3166: PPUSH
3167: LD_INT 0
3169: PPUSH
3170: LD_STRING 
3172: PPUSH
3173: CALL 171 0 3
3177: ST_TO_ADDR
// end ; end_of_file
3178: LD_VAR 0 1
3182: RET
// export function PrepareRussian ; begin
3183: LD_INT 0
3185: PPUSH
// end ; end_of_file end_of_file
3186: LD_VAR 0 1
3190: RET
// export function Action ; var i , un , veh , tmp ; begin
3191: LD_INT 0
3193: PPUSH
3194: PPUSH
3195: PPUSH
3196: PPUSH
3197: PPUSH
// InGameOn ;
3198: CALL_OW 8
// music_nat := 2 ;
3202: LD_ADDR_OWVAR 71
3206: PUSH
3207: LD_INT 2
3209: ST_TO_ADDR
// music_class := 0 ;
3210: LD_ADDR_OWVAR 72
3214: PUSH
3215: LD_INT 0
3217: ST_TO_ADDR
// CenterNowOnXY ( 7 , 6 ) ;
3218: LD_INT 7
3220: PPUSH
3221: LD_INT 6
3223: PPUSH
3224: CALL_OW 86
// tmp := [ Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Kurt , Aviradze ] union heikeSecondSquad ;
3228: LD_ADDR_VAR 0 5
3232: PUSH
3233: LD_EXP 3
3237: PUSH
3238: LD_EXP 4
3242: PUSH
3243: LD_EXP 5
3247: PUSH
3248: LD_EXP 6
3252: PUSH
3253: LD_EXP 7
3257: PUSH
3258: LD_EXP 8
3262: PUSH
3263: LD_EXP 9
3267: PUSH
3268: LD_EXP 10
3272: PUSH
3273: LD_EXP 12
3277: PUSH
3278: LD_EXP 13
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: LIST
3291: LIST
3292: LIST
3293: LIST
3294: PUSH
3295: LD_EXP 14
3299: UNION
3300: ST_TO_ADDR
// tmp := tmp diff 0 ;
3301: LD_ADDR_VAR 0 5
3305: PUSH
3306: LD_VAR 0 5
3310: PUSH
3311: LD_INT 0
3313: DIFF
3314: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
3315: LD_ADDR_VAR 0 5
3319: PUSH
3320: LD_VAR 0 5
3324: PPUSH
3325: LD_INT 3
3327: PPUSH
3328: CALL 2514 0 2
3332: ST_TO_ADDR
// for i in heikeVehicles do
3333: LD_ADDR_VAR 0 2
3337: PUSH
3338: LD_EXP 15
3342: PUSH
3343: FOR_IN
3344: IFFALSE 3543
// begin PrepareTank ( 2 , i [ 5 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] , 34 ) ;
3346: LD_INT 2
3348: PPUSH
3349: LD_VAR 0 2
3353: PUSH
3354: LD_INT 5
3356: ARRAY
3357: PPUSH
3358: LD_VAR 0 2
3362: PUSH
3363: LD_INT 1
3365: ARRAY
3366: PPUSH
3367: LD_VAR 0 2
3371: PUSH
3372: LD_INT 2
3374: ARRAY
3375: PPUSH
3376: LD_VAR 0 2
3380: PUSH
3381: LD_INT 3
3383: ARRAY
3384: PPUSH
3385: LD_VAR 0 2
3389: PUSH
3390: LD_INT 4
3392: ARRAY
3393: PPUSH
3394: LD_INT 34
3396: PPUSH
3397: CALL 234 0 7
// veh := CreateVehicle ;
3401: LD_ADDR_VAR 0 4
3405: PUSH
3406: CALL_OW 45
3410: ST_TO_ADDR
// if i [ 4 ] in [ ru_cargo_bay , ar_cargo_bay , us_cargo_bay ] then
3411: LD_VAR 0 2
3415: PUSH
3416: LD_INT 4
3418: ARRAY
3419: PUSH
3420: LD_INT 51
3422: PUSH
3423: LD_INT 32
3425: PUSH
3426: LD_INT 12
3428: PUSH
3429: EMPTY
3430: LIST
3431: LIST
3432: LIST
3433: IN
3434: IFFALSE 3514
// begin if i [ 7 ] [ 1 ] then
3436: LD_VAR 0 2
3440: PUSH
3441: LD_INT 7
3443: ARRAY
3444: PUSH
3445: LD_INT 1
3447: ARRAY
3448: IFFALSE 3475
// AddCargo ( veh , mat_cans , i [ 7 ] [ 1 ] ) ;
3450: LD_VAR 0 4
3454: PPUSH
3455: LD_INT 1
3457: PPUSH
3458: LD_VAR 0 2
3462: PUSH
3463: LD_INT 7
3465: ARRAY
3466: PUSH
3467: LD_INT 1
3469: ARRAY
3470: PPUSH
3471: CALL_OW 291
// if i [ 7 ] [ 2 ] then
3475: LD_VAR 0 2
3479: PUSH
3480: LD_INT 7
3482: ARRAY
3483: PUSH
3484: LD_INT 2
3486: ARRAY
3487: IFFALSE 3514
// AddCargo ( veh , mat_oil , i [ 7 ] [ 2 ] ) ;
3489: LD_VAR 0 4
3493: PPUSH
3494: LD_INT 2
3496: PPUSH
3497: LD_VAR 0 2
3501: PUSH
3502: LD_INT 7
3504: ARRAY
3505: PUSH
3506: LD_INT 2
3508: ARRAY
3509: PPUSH
3510: CALL_OW 291
// end ; SetDir ( veh , 2 ) ;
3514: LD_VAR 0 4
3518: PPUSH
3519: LD_INT 2
3521: PPUSH
3522: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
3526: LD_VAR 0 4
3530: PPUSH
3531: LD_INT 4
3533: PPUSH
3534: LD_INT 0
3536: PPUSH
3537: CALL_OW 49
// end ;
3541: GO 3343
3543: POP
3544: POP
// if tmp then
3545: LD_VAR 0 5
3549: IFFALSE 3604
// for i in tmp union heikeApes do
3551: LD_ADDR_VAR 0 2
3555: PUSH
3556: LD_VAR 0 5
3560: PUSH
3561: LD_EXP 16
3565: UNION
3566: PUSH
3567: FOR_IN
3568: IFFALSE 3602
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
3570: LD_VAR 0 2
3574: PPUSH
3575: LD_INT 5
3577: PPUSH
3578: LD_INT 0
3580: PPUSH
3581: CALL_OW 49
// ComTurnXY ( i , 26 , 9 ) ;
3585: LD_VAR 0 2
3589: PPUSH
3590: LD_INT 26
3592: PPUSH
3593: LD_INT 9
3595: PPUSH
3596: CALL_OW 118
// end ;
3600: GO 3567
3602: POP
3603: POP
// DialogueOn ;
3604: CALL_OW 6
// DialogueOff ;
3608: CALL_OW 7
// InGameOff ;
3612: CALL_OW 9
// ChangeMissionObjectives ( Road ) ;
3616: LD_STRING Road
3618: PPUSH
3619: CALL_OW 337
// SaveForQuickRestart ;
3623: CALL_OW 22
// end ;
3627: LD_VAR 0 1
3631: RET
