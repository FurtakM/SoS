// Prepare Hero for use
// ident - ident from start.txt - 'JMM' for example
// exist_mode
//   - false if unit not exist in save
//   - true if unit already exist in save
// example: JMM := PrepareUnit('JMM', false);
Export Function PrepareUnit(ident, exist_mode, prefix);
var unit;
begin

if exist_mode then
   unit := CreateCharacter(prefix & ident)
else
   unit := NewCharacter(ident);

result := unit;
End;

// example: PrepareTank(1, 1, us_medium_wheeled, engine_combustion, control_manual, us_machine_gun, 80);
Export Function PrepareTank(side, nation, chassis, engine, control, weapon, fuel);
begin
uc_side := side;
uc_nation := nation;

vc_chassis := chassis;
vc_engine := engine;
vc_control := control;
vc_weapon := weapon;
vc_fuel_battery := fuel;

result := CreateVehicle;
End;


Export Function SayX(units, ident);
var i;
begin
result := false;

if not units then
   exit;

for i in units do
    if IsOk(i) then
       begin
       Say(i, ident);
       result := i;
       break;
       end;
End;

Export Function SpawnApeman(area, amount);
var i;
begin
InitUc;
InitHc;

uc_side := 0;
uc_nation := 0;

for i = 1 to amount do
    begin
    hc_attr := [rand(9, 12), rand(9, 12)];
    hc_agressivity := rand(-1, 1);
    PrepareHuman(false, class_apeman, 1);
    PlaceUnitArea(CreateHuman, area, false);
    end;

InitHc;
End;

Export Function PrepareNature(forest, swamp);
var i;
begin
// SpawnApeman(forest, [5, 4, 4][Difficulty]);

uc_side := 0;
uc_nation := 0;

for i := 1 to 3 do
    begin
    hc_class := 21;
    hc_gallery := '';
    PlaceUnitArea(CreateHuman, forest, false);
    end;

for i := 1 to 3 do
    begin
    hc_class := 18;
    hc_gallery := '';
    PlaceUnitArea(CreateHuman, forest, false);
    end;

for i := 1 to 3 do
    begin
    hc_class := 13;
    hc_gallery := '';
    PlaceUnitArea(CreateHuman, forest, false);
    end;

for i := 1 to 4 do
    begin
    hc_class := class_frog;
    hc_gallery := '';
    PlaceUnitArea(CreateHuman, swamp, false);
    end;
End;

Export Function SeeUnit(observer, unit);
var i, tmp;
begin
if not observer or not unit then
   exit;

if not See(GetSide(observer), unit) then
   exit;


result := GetDistUnits(observer, unit) < 12;
End;

Export Function PlaceUnitHex(un, hex, mode);
begin
if ValidHex(hex[1], hex[2]) and HexInfo(hex[1], hex[2]) = 0 then
   PlaceUnitXY(un, hex[1], hex[2], mode);
End;

Export function Video(mode);
begin
ingame_video = mode;
interface_hidden = mode;
End;

Export Function ReverseArray(array);
var i;
begin
// [1, 2, 3, 4] -> [4, 3, 2, 1]
if not array then
   exit;

result := [];

for i := 1 to array do
    result := Insert(result, 1, array[i]);
End;

Export Function ComExit(unit);
begin
result := IsInUnit(unit);

if not result then
   exit;

if GetType(result) = unit_vehicle then
   ComExitVehicle(unit)
else
   ComExitBuilding(unit);
End;

// Return's tech list by nation
// side
// nation
// state:
//       state_enabled 1
//       state_researched 2
//       state_disabled 0
//       all -1
Export Function GetTechNation(side, nation, state);
var i;
begin
if not side or not nation then
   exit;

case nation of
     nation_american: result := [35, 45, 46, 47, 82, 83, 84, 85, 86, 1, 2, 6, 15, 16, 7, 12, 13, 10, 14, 20, 21, 22, 25, 32, 27, 36, 69, 39, 34, 40, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 80, 82, 83, 84, 85, 86];
     nation_arabian: result := [35, 45, 46, 47, 82, 83, 84, 85, 87, 70, 1, 11, 3, 4, 5, 6, 15, 18, 7, 17, 8, 20, 21, 22, 72, 26, 69, 39, 40, 41, 42, 43, 48, 49, 50, 51, 52, 53, 54, 55, 56, 60, 61, 62, 66, 67, 68, 81, 82, 83, 84, 85, 87];
     nation_russian: result := [46, 47, 1, 2, 82, 83, 84, 85, 86, 11, 9, 20, 19, 21, 24, 22, 25, 28, 29, 30, 31, 37, 38, 32, 27, 33, 69, 39, 34, 40, 71, 23, 44, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 63, 64, 65, 82, 83, 84, 85, 86];
end;

if state > -1 and state < 3 then
   for i in result do
       if GetTech(i, side) <> state then
          result := result diff i;
End;

Export Function SortByDistanceXY(x, y, list, asc);
var i, j, tmp;
begin
if not list then
   exit;

result := [];

for i in list do
    begin
    tmp := GetDistUnitXY(i, x, y);

    if not result then
       result := [[i, tmp]]
     else
      begin
       if result[result][2] < tmp then
          result := Insert(result, result+1, [i, tmp])
       else
       for j = 1 to result do
           begin
           if tmp < result[j][2] then
              begin
              result := Insert(result, j, [i, tmp]);
              break;
              end;
           end;
      end;
    end;

if result and not asc then
   begin
   tmp := result;

   for i = tmp downto 1 do
       result := Replace(result, tmp - i + 1, tmp[i]);
   end;
End;

Export Function SortByDistanceUnit(unit, list, asc);
begin
result := SortByDistanceXY(GetX(unit), GetY(unit), list, asc);
End;

Export Function NearestEmptyBuilding(unit, btype);
var side, tmp, i, places;
begin
if not unit then
   exit;

side := GetSide(unit);
tmp := FilterAllUnits([[f_side, side], [f_btype, btype]]);

if not tmp then
   exit;

tmp := SortByDistanceUnit(unit, tmp, true);

places := 1;

if btype in [b_depot, b_warehouse, b_armoury, b_barracks, b_workshop, b_factory, b_lab, b_lab_half, b_lab_full] then
   places := 6;

for i in tmp do
    begin
    if UnitsInside(i) - places <= 0 then
       continue
    else
       begin
       result := i;
       exit;
       end;
    end;
End;

Export Function SortBySkill(units, class);
var i, tmp;
begin
if not units or not class in [1, 2, 3, 4] then
   exit;

tmp := [];

for i in units do
    tmp := Insert(tmp, tmp+1, GetSkill(i, class));

if not tmp then
   exit;

result := SortListByListDesc(units, tmp);
End;

Export Function RevealFogOnXY(x, y, side, range);
begin
PlaceSeeing(x, y, side, range);
RemoveSeeing(x, y, side);
End;

Export Function SayRandom(units, menDialog, womenDialog);
begin
if not units then
   exit;

if not Say(UnitFilter(units, [f_sex, sex_male]), menDialog) then
   Say(UnitFilter(units, [f_sex, sex_female])[1], womenDialog);
End;

Export Function SeeGroup(side, group);
var i;
begin
if not group then
   exit;

for i in group do
    if See(side, i) then
       begin
       result := true;
       exit;
       end;
End;

Export Function PlaceUnitInArea(unit, area, mode);
var i, tmp, hex;
begin
if not unit or not area then
   exit;

tmp := AreaToList(area, i);

for i = 1 to tmp[1] do
    begin
    hex := [tmp[1][i], tmp[2][i]];

    if HexInfo(hex[1], hex[2]) = 0 then
       begin
       PlaceUnitXY(unit, hex[1], hex[2], mode);
       result := IsPlaced(unit);
       exit;
       end;
    end;
End;