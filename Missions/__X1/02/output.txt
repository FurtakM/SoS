// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 581 0 0
// PrepareAmericans ;
  23: CALL 827 0 0
// PrepareArabian ;
  27: CALL 9505 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 190 0 0
// Action ;
  41: CALL 4410 0 0
// end ;
  45: END
// export debug , prefix , missionStart , aviradzeSpotted , deltaSpotted , sciSpotted , aviradzeQuestDone , sciCounterKill , usAlert , usActiveDefend , timeUntilFarmer , attackDeltaAllowed , trickyMove , usPatrol , trap ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := false ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// aviradzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 6
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 8
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// aviradzeQuestDone := false ;
  97: LD_ADDR_EXP 7
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// attackDeltaAllowed := false ;
 105: LD_ADDR_EXP 12
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// usAlert := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// usActiveDefend := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// usPatrol := [ ] ;
 129: LD_ADDR_EXP 14
 133: PUSH
 134: EMPTY
 135: ST_TO_ADDR
// timeUntilFarmer := [ 40 40$00 , 30 30$00 , 20 20$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 11
 140: PUSH
 141: LD_INT 84000
 143: PUSH
 144: LD_INT 63000
 146: PUSH
 147: LD_INT 42000
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// trickyMove := false ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// prefix := 01 ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 01
 176: ST_TO_ADDR
// trap := 0 ;
 177: LD_ADDR_EXP 15
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// end ;
 185: LD_VAR 0 1
 189: RET
// function DebugMode ; begin
 190: LD_INT 0
 192: PPUSH
// FogOff ( 1 ) ;
 193: LD_INT 1
 195: PPUSH
 196: CALL_OW 344
// Difficulty := 2 ;
 200: LD_ADDR_OWVAR 67
 204: PUSH
 205: LD_INT 2
 207: ST_TO_ADDR
// end ; end_of_file
 208: LD_VAR 0 1
 212: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 213: LD_INT 0
 215: PPUSH
 216: PPUSH
// if exist_mode then
 217: LD_VAR 0 2
 221: IFFALSE 246
// unit := CreateCharacter ( prefix & ident ) else
 223: LD_ADDR_VAR 0 5
 227: PUSH
 228: LD_VAR 0 3
 232: PUSH
 233: LD_VAR 0 1
 237: STR
 238: PPUSH
 239: CALL_OW 34
 243: ST_TO_ADDR
 244: GO 261
// unit := NewCharacter ( ident ) ;
 246: LD_ADDR_VAR 0 5
 250: PUSH
 251: LD_VAR 0 1
 255: PPUSH
 256: CALL_OW 25
 260: ST_TO_ADDR
// result := unit ;
 261: LD_ADDR_VAR 0 4
 265: PUSH
 266: LD_VAR 0 5
 270: ST_TO_ADDR
// end ;
 271: LD_VAR 0 4
 275: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 276: LD_INT 0
 278: PPUSH
// uc_side := side ;
 279: LD_ADDR_OWVAR 20
 283: PUSH
 284: LD_VAR 0 1
 288: ST_TO_ADDR
// uc_nation := nation ;
 289: LD_ADDR_OWVAR 21
 293: PUSH
 294: LD_VAR 0 2
 298: ST_TO_ADDR
// vc_chassis := chassis ;
 299: LD_ADDR_OWVAR 37
 303: PUSH
 304: LD_VAR 0 3
 308: ST_TO_ADDR
// vc_engine := engine ;
 309: LD_ADDR_OWVAR 39
 313: PUSH
 314: LD_VAR 0 4
 318: ST_TO_ADDR
// vc_control := control ;
 319: LD_ADDR_OWVAR 38
 323: PUSH
 324: LD_VAR 0 5
 328: ST_TO_ADDR
// vc_weapon := weapon ;
 329: LD_ADDR_OWVAR 40
 333: PUSH
 334: LD_VAR 0 6
 338: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 339: LD_ADDR_OWVAR 41
 343: PUSH
 344: LD_VAR 0 7
 348: ST_TO_ADDR
// result := CreateVehicle ;
 349: LD_ADDR_VAR 0 8
 353: PUSH
 354: CALL_OW 45
 358: ST_TO_ADDR
// end ;
 359: LD_VAR 0 8
 363: RET
// export function SayX ( units , ident ) ; var i ; begin
 364: LD_INT 0
 366: PPUSH
 367: PPUSH
// result := false ;
 368: LD_ADDR_VAR 0 3
 372: PUSH
 373: LD_INT 0
 375: ST_TO_ADDR
// if not units then
 376: LD_VAR 0 1
 380: NOT
 381: IFFALSE 385
// exit ;
 383: GO 439
// for i in units do
 385: LD_ADDR_VAR 0 4
 389: PUSH
 390: LD_VAR 0 1
 394: PUSH
 395: FOR_IN
 396: IFFALSE 437
// if IsOk ( i ) then
 398: LD_VAR 0 4
 402: PPUSH
 403: CALL_OW 302
 407: IFFALSE 435
// begin Say ( i , ident ) ;
 409: LD_VAR 0 4
 413: PPUSH
 414: LD_VAR 0 2
 418: PPUSH
 419: CALL_OW 88
// result := i ;
 423: LD_ADDR_VAR 0 3
 427: PUSH
 428: LD_VAR 0 4
 432: ST_TO_ADDR
// break ;
 433: GO 437
// end ;
 435: GO 395
 437: POP
 438: POP
// end ;
 439: LD_VAR 0 3
 443: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 444: LD_INT 0
 446: PPUSH
 447: PPUSH
// InitUc ;
 448: CALL_OW 18
// InitHc ;
 452: CALL_OW 19
// uc_side := 0 ;
 456: LD_ADDR_OWVAR 20
 460: PUSH
 461: LD_INT 0
 463: ST_TO_ADDR
// uc_nation := 0 ;
 464: LD_ADDR_OWVAR 21
 468: PUSH
 469: LD_INT 0
 471: ST_TO_ADDR
// for i = 1 to amount do
 472: LD_ADDR_VAR 0 4
 476: PUSH
 477: DOUBLE
 478: LD_INT 1
 480: DEC
 481: ST_TO_ADDR
 482: LD_VAR 0 2
 486: PUSH
 487: FOR_TO
 488: IFFALSE 570
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 490: LD_ADDR_OWVAR 29
 494: PUSH
 495: LD_INT 9
 497: PPUSH
 498: LD_INT 12
 500: PPUSH
 501: CALL_OW 12
 505: PUSH
 506: LD_INT 9
 508: PPUSH
 509: LD_INT 12
 511: PPUSH
 512: CALL_OW 12
 516: PUSH
 517: EMPTY
 518: LIST
 519: LIST
 520: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 521: LD_ADDR_OWVAR 35
 525: PUSH
 526: LD_INT 1
 528: NEG
 529: PPUSH
 530: LD_INT 1
 532: PPUSH
 533: CALL_OW 12
 537: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 538: LD_INT 0
 540: PPUSH
 541: LD_INT 12
 543: PPUSH
 544: LD_INT 1
 546: PPUSH
 547: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 551: CALL_OW 44
 555: PPUSH
 556: LD_VAR 0 1
 560: PPUSH
 561: LD_INT 0
 563: PPUSH
 564: CALL_OW 49
// end ;
 568: GO 487
 570: POP
 571: POP
// InitHc ;
 572: CALL_OW 19
// end ;
 576: LD_VAR 0 3
 580: RET
// export function PrepareNature ; var i ; begin
 581: LD_INT 0
 583: PPUSH
 584: PPUSH
// SpawnApeman ( forest , 9 ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 9
 590: PPUSH
 591: CALL 444 0 2
// for i := 1 to 4 do
 595: LD_ADDR_VAR 0 2
 599: PUSH
 600: DOUBLE
 601: LD_INT 1
 603: DEC
 604: ST_TO_ADDR
 605: LD_INT 4
 607: PUSH
 608: FOR_TO
 609: IFFALSE 644
// begin hc_class := 21 ;
 611: LD_ADDR_OWVAR 28
 615: PUSH
 616: LD_INT 21
 618: ST_TO_ADDR
// hc_gallery :=  ;
 619: LD_ADDR_OWVAR 33
 623: PUSH
 624: LD_STRING 
 626: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 627: CALL_OW 44
 631: PPUSH
 632: LD_INT 1
 634: PPUSH
 635: LD_INT 0
 637: PPUSH
 638: CALL_OW 49
// end ;
 642: GO 608
 644: POP
 645: POP
// for i := 1 to 2 do
 646: LD_ADDR_VAR 0 2
 650: PUSH
 651: DOUBLE
 652: LD_INT 1
 654: DEC
 655: ST_TO_ADDR
 656: LD_INT 2
 658: PUSH
 659: FOR_TO
 660: IFFALSE 695
// begin hc_class := 18 ;
 662: LD_ADDR_OWVAR 28
 666: PUSH
 667: LD_INT 18
 669: ST_TO_ADDR
// hc_gallery :=  ;
 670: LD_ADDR_OWVAR 33
 674: PUSH
 675: LD_STRING 
 677: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 678: CALL_OW 44
 682: PPUSH
 683: LD_INT 1
 685: PPUSH
 686: LD_INT 0
 688: PPUSH
 689: CALL_OW 49
// end ;
 693: GO 659
 695: POP
 696: POP
// for i := 1 to 3 do
 697: LD_ADDR_VAR 0 2
 701: PUSH
 702: DOUBLE
 703: LD_INT 1
 705: DEC
 706: ST_TO_ADDR
 707: LD_INT 3
 709: PUSH
 710: FOR_TO
 711: IFFALSE 746
// begin hc_class := 13 ;
 713: LD_ADDR_OWVAR 28
 717: PUSH
 718: LD_INT 13
 720: ST_TO_ADDR
// hc_gallery :=  ;
 721: LD_ADDR_OWVAR 33
 725: PUSH
 726: LD_STRING 
 728: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 729: CALL_OW 44
 733: PPUSH
 734: LD_INT 1
 736: PPUSH
 737: LD_INT 0
 739: PPUSH
 740: CALL_OW 49
// end ;
 744: GO 710
 746: POP
 747: POP
// end ;
 748: LD_VAR 0 1
 752: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 753: LD_INT 0
 755: PPUSH
 756: PPUSH
 757: PPUSH
// if not observer or not unit then
 758: LD_VAR 0 1
 762: NOT
 763: PUSH
 764: LD_VAR 0 2
 768: NOT
 769: OR
 770: IFFALSE 774
// exit ;
 772: GO 822
// if not See ( GetSide ( observer ) , unit ) then
 774: LD_VAR 0 1
 778: PPUSH
 779: CALL_OW 255
 783: PPUSH
 784: LD_VAR 0 2
 788: PPUSH
 789: CALL_OW 292
 793: NOT
 794: IFFALSE 798
// exit ;
 796: GO 822
// result := GetDistUnits ( observer , unit ) < 12 ;
 798: LD_ADDR_VAR 0 3
 802: PUSH
 803: LD_VAR 0 1
 807: PPUSH
 808: LD_VAR 0 2
 812: PPUSH
 813: CALL_OW 296
 817: PUSH
 818: LD_INT 12
 820: LESS
 821: ST_TO_ADDR
// end ; end_of_file
 822: LD_VAR 0 3
 826: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp , arm ; begin
 827: LD_INT 0
 829: PPUSH
 830: PPUSH
 831: PPUSH
 832: PPUSH
 833: PPUSH
 834: PPUSH
// usForces := [ ] ;
 835: LD_ADDR_EXP 18
 839: PUSH
 840: EMPTY
 841: ST_TO_ADDR
// usSci := [ ] ;
 842: LD_ADDR_EXP 19
 846: PUSH
 847: EMPTY
 848: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 849: LD_INT 1
 851: PPUSH
 852: LD_STRING Delta
 854: PPUSH
 855: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 859: LD_INT 1
 861: PPUSH
 862: CALL_OW 274
 866: PPUSH
 867: LD_INT 1
 869: PPUSH
 870: LD_INT 400
 872: PPUSH
 873: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 877: LD_INT 1
 879: PPUSH
 880: CALL_OW 274
 884: PPUSH
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 80
 890: PPUSH
 891: CALL_OW 277
// uc_side := 1 ;
 895: LD_ADDR_OWVAR 20
 899: PUSH
 900: LD_INT 1
 902: ST_TO_ADDR
// uc_nation := 1 ;
 903: LD_ADDR_OWVAR 21
 907: PUSH
 908: LD_INT 1
 910: ST_TO_ADDR
// InitHc ;
 911: CALL_OW 19
// hc_importance := 0 ;
 915: LD_ADDR_OWVAR 32
 919: PUSH
 920: LD_INT 0
 922: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 923: LD_ADDR_EXP 17
 927: PUSH
 928: LD_STRING Lynch
 930: PPUSH
 931: LD_INT 0
 933: PPUSH
 934: LD_STRING 
 936: PPUSH
 937: CALL 213 0 3
 941: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 942: LD_ADDR_EXP 16
 946: PUSH
 947: LD_STRING Gladstone
 949: PPUSH
 950: LD_INT 0
 952: PPUSH
 953: LD_STRING 
 955: PPUSH
 956: CALL 213 0 3
 960: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 961: LD_EXP 17
 965: PPUSH
 966: LD_INT 1
 968: PPUSH
 969: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 3
 980: PPUSH
 981: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
 985: LD_ADDR_VAR 0 2
 989: PUSH
 990: DOUBLE
 991: LD_INT 1
 993: DEC
 994: ST_TO_ADDR
 995: LD_INT 1
 997: PUSH
 998: LD_INT 2
1000: PUSH
1001: LD_INT 2
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: PUSH
1009: LD_OWVAR 67
1013: ARRAY
1014: PUSH
1015: FOR_TO
1016: IFFALSE 1062
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1018: LD_INT 0
1020: PPUSH
1021: LD_INT 2
1023: PPUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 2
1029: PUSH
1030: LD_INT 2
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: PUSH
1038: LD_OWVAR 67
1042: ARRAY
1043: PPUSH
1044: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
1048: CALL_OW 44
1052: PPUSH
1053: LD_INT 1
1055: PPUSH
1056: CALL_OW 52
// end ;
1060: GO 1015
1062: POP
1063: POP
// for i := 1 to 2 + Difficulty do
1064: LD_ADDR_VAR 0 2
1068: PUSH
1069: DOUBLE
1070: LD_INT 1
1072: DEC
1073: ST_TO_ADDR
1074: LD_INT 2
1076: PUSH
1077: LD_OWVAR 67
1081: PLUS
1082: PUSH
1083: FOR_TO
1084: IFFALSE 1169
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1086: LD_INT 0
1088: PPUSH
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 1
1094: PUSH
1095: LD_INT 2
1097: PUSH
1098: LD_INT 2
1100: PUSH
1101: EMPTY
1102: LIST
1103: LIST
1104: LIST
1105: PUSH
1106: LD_OWVAR 67
1110: ARRAY
1111: PPUSH
1112: CALL_OW 380
// un := CreateHuman ;
1116: LD_ADDR_VAR 0 3
1120: PUSH
1121: CALL_OW 44
1125: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
1126: LD_VAR 0 3
1130: PPUSH
1131: LD_INT 3
1133: PPUSH
1134: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
1138: LD_ADDR_EXP 19
1142: PUSH
1143: LD_EXP 19
1147: PPUSH
1148: LD_EXP 19
1152: PUSH
1153: LD_INT 1
1155: PLUS
1156: PPUSH
1157: LD_VAR 0 3
1161: PPUSH
1162: CALL_OW 1
1166: ST_TO_ADDR
// end ;
1167: GO 1083
1169: POP
1170: POP
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
1171: LD_ADDR_VAR 0 6
1175: PUSH
1176: LD_INT 22
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 30
1188: PUSH
1189: LD_INT 4
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: PUSH
1196: EMPTY
1197: LIST
1198: LIST
1199: PPUSH
1200: CALL_OW 69
1204: ST_TO_ADDR
// for i := 1 to 3 + Difficulty do
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: DOUBLE
1211: LD_INT 1
1213: DEC
1214: ST_TO_ADDR
1215: LD_INT 3
1217: PUSH
1218: LD_OWVAR 67
1222: PLUS
1223: PUSH
1224: FOR_TO
1225: IFFALSE 1303
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1227: LD_INT 0
1229: PPUSH
1230: LD_INT 1
1232: PPUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 2
1238: PUSH
1239: LD_INT 3
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: PUSH
1247: LD_OWVAR 67
1251: ARRAY
1252: PPUSH
1253: CALL_OW 380
// un := CreateHuman ;
1257: LD_ADDR_VAR 0 3
1261: PUSH
1262: CALL_OW 44
1266: ST_TO_ADDR
// usForces := usForces ^ un ;
1267: LD_ADDR_EXP 18
1271: PUSH
1272: LD_EXP 18
1276: PUSH
1277: LD_VAR 0 3
1281: ADD
1282: ST_TO_ADDR
// PlaceHumanInUnit ( un , arm [ 1 ] ) ;
1283: LD_VAR 0 3
1287: PPUSH
1288: LD_VAR 0 6
1292: PUSH
1293: LD_INT 1
1295: ARRAY
1296: PPUSH
1297: CALL_OW 52
// end ;
1301: GO 1224
1303: POP
1304: POP
// PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1305: LD_INT 1
1307: PPUSH
1308: LD_INT 1
1310: PPUSH
1311: LD_INT 1
1313: PPUSH
1314: LD_INT 2
1316: PPUSH
1317: LD_INT 1
1319: PPUSH
1320: LD_INT 2
1322: PPUSH
1323: LD_INT 100
1325: PPUSH
1326: CALL 276 0 7
// veh := CreateVehicle ;
1330: LD_ADDR_VAR 0 4
1334: PUSH
1335: CALL_OW 45
1339: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1340: LD_VAR 0 4
1344: PPUSH
1345: LD_INT 2
1347: PPUSH
1348: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 24 , false ) ;
1352: LD_VAR 0 4
1356: PPUSH
1357: LD_INT 43
1359: PPUSH
1360: LD_INT 24
1362: PPUSH
1363: LD_INT 0
1365: PPUSH
1366: CALL_OW 48
// end ;
1370: LD_VAR 0 1
1374: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
1382: PPUSH
// if not usSci then
1383: LD_EXP 19
1387: NOT
1388: IFFALSE 1392
// exit ;
1390: GO 1566
// xy := AreaToList ( tameArea , 0 ) ;
1392: LD_ADDR_VAR 0 6
1396: PUSH
1397: LD_INT 5
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 517
1407: ST_TO_ADDR
// for i in usSci do
1408: LD_ADDR_VAR 0 2
1412: PUSH
1413: LD_EXP 19
1417: PUSH
1418: FOR_IN
1419: IFFALSE 1564
// begin k := rand ( 1 , xy [ 1 ] ) ;
1421: LD_ADDR_VAR 0 4
1425: PUSH
1426: LD_INT 1
1428: PPUSH
1429: LD_VAR 0 6
1433: PUSH
1434: LD_INT 1
1436: ARRAY
1437: PPUSH
1438: CALL_OW 12
1442: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1443: LD_VAR 0 2
1447: PPUSH
1448: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1452: LD_VAR 0 2
1456: PPUSH
1457: LD_VAR 0 6
1461: PUSH
1462: LD_INT 1
1464: ARRAY
1465: PUSH
1466: LD_VAR 0 4
1470: ARRAY
1471: PPUSH
1472: LD_VAR 0 6
1476: PUSH
1477: LD_INT 2
1479: ARRAY
1480: PUSH
1481: LD_VAR 0 4
1485: ARRAY
1486: PPUSH
1487: CALL_OW 171
// for j := 1 to 2 do
1491: LD_ADDR_VAR 0 3
1495: PUSH
1496: DOUBLE
1497: LD_INT 1
1499: DEC
1500: ST_TO_ADDR
1501: LD_INT 2
1503: PUSH
1504: FOR_TO
1505: IFFALSE 1560
// begin tmp := Delete ( xy [ j ] , k ) ;
1507: LD_ADDR_VAR 0 5
1511: PUSH
1512: LD_VAR 0 6
1516: PUSH
1517: LD_VAR 0 3
1521: ARRAY
1522: PPUSH
1523: LD_VAR 0 4
1527: PPUSH
1528: CALL_OW 3
1532: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1533: LD_ADDR_VAR 0 6
1537: PUSH
1538: LD_VAR 0 6
1542: PPUSH
1543: LD_VAR 0 3
1547: PPUSH
1548: LD_VAR 0 5
1552: PPUSH
1553: CALL_OW 1
1557: ST_TO_ADDR
// end ;
1558: GO 1504
1560: POP
1561: POP
// end ;
1562: GO 1418
1564: POP
1565: POP
// end ;
1566: LD_VAR 0 1
1570: RET
// every 0 0$5 + 0 0$10 trigger usSci and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1571: LD_EXP 19
1575: PUSH
1576: LD_INT 22
1578: PUSH
1579: LD_INT 0
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: PUSH
1586: LD_INT 25
1588: PUSH
1589: LD_INT 12
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL_OW 69
1604: AND
1605: IFFALSE 2094
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
1614: PPUSH
1615: PPUSH
1616: PPUSH
// begin enable ;
1617: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1618: LD_EXP 19
1622: PPUSH
1623: LD_INT 2
1625: PUSH
1626: LD_INT 60
1628: PUSH
1629: EMPTY
1630: LIST
1631: PUSH
1632: LD_INT 54
1634: PUSH
1635: EMPTY
1636: LIST
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: CALL_OW 72
1647: IFFALSE 1651
// exit ;
1649: GO 2094
// for i in usSci do
1651: LD_ADDR_VAR 0 1
1655: PUSH
1656: LD_EXP 19
1660: PUSH
1661: FOR_IN
1662: IFFALSE 2092
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1664: LD_VAR 0 1
1668: PPUSH
1669: CALL_OW 314
1673: NOT
1674: PUSH
1675: LD_VAR 0 1
1679: PPUSH
1680: CALL_OW 256
1684: PUSH
1685: LD_INT 1000
1687: EQUAL
1688: AND
1689: IFFALSE 1896
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: LD_INT 22
1698: PUSH
1699: LD_INT 0
1701: PUSH
1702: EMPTY
1703: LIST
1704: LIST
1705: PUSH
1706: LD_INT 25
1708: PUSH
1709: LD_INT 12
1711: PUSH
1712: EMPTY
1713: LIST
1714: LIST
1715: PUSH
1716: EMPTY
1717: LIST
1718: LIST
1719: PPUSH
1720: CALL_OW 69
1724: PPUSH
1725: LD_VAR 0 1
1729: PPUSH
1730: CALL_OW 74
1734: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1735: LD_VAR 0 1
1739: PPUSH
1740: LD_VAR 0 5
1744: PPUSH
1745: CALL_OW 296
1749: PUSH
1750: LD_INT 10
1752: LESS
1753: IFFALSE 1786
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1755: LD_VAR 0 1
1759: PPUSH
1760: LD_VAR 0 5
1764: PPUSH
1765: CALL_OW 250
1769: PPUSH
1770: LD_VAR 0 5
1774: PPUSH
1775: CALL_OW 251
1779: PPUSH
1780: CALL_OW 131
1784: GO 1896
// begin d := rand ( 0 , 5 ) ;
1786: LD_ADDR_VAR 0 4
1790: PUSH
1791: LD_INT 0
1793: PPUSH
1794: LD_INT 5
1796: PPUSH
1797: CALL_OW 12
1801: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1802: LD_ADDR_VAR 0 2
1806: PUSH
1807: LD_VAR 0 1
1811: PPUSH
1812: CALL_OW 250
1816: PPUSH
1817: LD_VAR 0 4
1821: PPUSH
1822: LD_INT 3
1824: PPUSH
1825: CALL_OW 272
1829: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
1830: LD_ADDR_VAR 0 3
1834: PUSH
1835: LD_VAR 0 1
1839: PPUSH
1840: CALL_OW 251
1844: PPUSH
1845: LD_VAR 0 4
1849: PPUSH
1850: LD_INT 3
1852: PPUSH
1853: CALL_OW 273
1857: ST_TO_ADDR
// if not ValidHex ( x , y ) then
1858: LD_VAR 0 2
1862: PPUSH
1863: LD_VAR 0 3
1867: PPUSH
1868: CALL_OW 488
1872: NOT
1873: IFFALSE 1877
// continue ;
1875: GO 1661
// ComMoveXY ( i , x , y ) ;
1877: LD_VAR 0 1
1881: PPUSH
1882: LD_VAR 0 2
1886: PPUSH
1887: LD_VAR 0 3
1891: PPUSH
1892: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
1896: LD_VAR 0 1
1900: PPUSH
1901: CALL_OW 256
1905: PUSH
1906: LD_INT 900
1908: LESS
1909: PUSH
1910: LD_VAR 0 1
1914: PPUSH
1915: LD_INT 37
1917: PPUSH
1918: LD_INT 23
1920: PPUSH
1921: CALL_OW 297
1925: PUSH
1926: LD_INT 10
1928: GREATER
1929: AND
1930: IFFALSE 1980
// begin if IsOk ( Gladstone ) and IsInUnit ( Gladstone ) then
1932: LD_EXP 16
1936: PPUSH
1937: CALL_OW 302
1941: PUSH
1942: LD_EXP 16
1946: PPUSH
1947: CALL_OW 310
1951: AND
1952: IFFALSE 1963
// ComExitBuilding ( Gladstone ) ;
1954: LD_EXP 16
1958: PPUSH
1959: CALL_OW 122
// ComMoveXY ( i , 37 , 23 ) ;
1963: LD_VAR 0 1
1967: PPUSH
1968: LD_INT 37
1970: PPUSH
1971: LD_INT 23
1973: PPUSH
1974: CALL_OW 111
// end else
1978: GO 2090
// if GetLives ( i ) = 1000 then
1980: LD_VAR 0 1
1984: PPUSH
1985: CALL_OW 256
1989: PUSH
1990: LD_INT 1000
1992: EQUAL
1993: IFFALSE 2090
// begin if IsOk ( Gladstone ) then
1995: LD_EXP 16
1999: PPUSH
2000: CALL_OW 302
2004: IFFALSE 2018
// ComEnterUnit ( Gladstone , usLab ) ;
2006: LD_EXP 16
2010: PPUSH
2011: LD_INT 3
2013: PPUSH
2014: CALL_OW 120
// if SideShoot ( i ) = 2 then
2018: LD_VAR 0 1
2022: PPUSH
2023: CALL_OW 503
2027: PUSH
2028: LD_INT 2
2030: EQUAL
2031: IFFALSE 2078
// begin if not usAlert then
2033: LD_EXP 9
2037: NOT
2038: IFFALSE 2048
// usAlert := true ;
2040: LD_ADDR_EXP 9
2044: PUSH
2045: LD_INT 1
2047: ST_TO_ADDR
// AddComEnterUnit ( i , usLab ) ;
2048: LD_VAR 0 1
2052: PPUSH
2053: LD_INT 3
2055: PPUSH
2056: CALL_OW 180
// usSci := usSci diff i ;
2060: LD_ADDR_EXP 19
2064: PUSH
2065: LD_EXP 19
2069: PUSH
2070: LD_VAR 0 1
2074: DIFF
2075: ST_TO_ADDR
// end else
2076: GO 2090
// ComMoveToArea ( i , tameArea ) ;
2078: LD_VAR 0 1
2082: PPUSH
2083: LD_INT 5
2085: PPUSH
2086: CALL_OW 113
// end ; end ;
2090: GO 1661
2092: POP
2093: POP
// end ;
2094: PPOPN 5
2096: END
// every 0 0$1 trigger not usAlert and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 999 ] ] ] ) or FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) ) do
2097: LD_EXP 9
2101: NOT
2102: PUSH
2103: LD_INT 22
2105: PUSH
2106: LD_INT 1
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 21
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PUSH
2123: LD_INT 3
2125: PUSH
2126: LD_INT 57
2128: PUSH
2129: EMPTY
2130: LIST
2131: PUSH
2132: EMPTY
2133: LIST
2134: LIST
2135: PUSH
2136: LD_INT 3
2138: PUSH
2139: LD_INT 24
2141: PUSH
2142: LD_INT 999
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: EMPTY
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: PPUSH
2159: CALL_OW 69
2163: PUSH
2164: LD_INT 7
2166: PPUSH
2167: LD_INT 22
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: PPUSH
2177: CALL_OW 70
2181: OR
2182: AND
2183: IFFALSE 2196
2185: GO 2187
2187: DISABLE
// usAlert := true ;
2188: LD_ADDR_EXP 9
2192: PUSH
2193: LD_INT 1
2195: ST_TO_ADDR
2196: END
// every 0 0$1 trigger usAlert do var i , b , arm ;
2197: LD_EXP 9
2201: IFFALSE 2548
2203: GO 2205
2205: DISABLE
2206: LD_INT 0
2208: PPUSH
2209: PPUSH
2210: PPUSH
// begin usActiveDefend := true ;
2211: LD_ADDR_EXP 10
2215: PUSH
2216: LD_INT 1
2218: ST_TO_ADDR
// if not usForces then
2219: LD_EXP 18
2223: NOT
2224: IFFALSE 2228
// exit ;
2226: GO 2548
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
2228: LD_ADDR_VAR 0 3
2232: PUSH
2233: LD_INT 22
2235: PUSH
2236: LD_INT 1
2238: PUSH
2239: EMPTY
2240: LIST
2241: LIST
2242: PUSH
2243: LD_INT 30
2245: PUSH
2246: LD_INT 4
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PPUSH
2257: CALL_OW 69
2261: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
2262: LD_ADDR_VAR 0 2
2266: PUSH
2267: LD_INT 22
2269: PUSH
2270: LD_INT 1
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 30
2279: PUSH
2280: LD_INT 31
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: PPUSH
2291: CALL_OW 69
2295: ST_TO_ADDR
// ComExitBuilding ( Lynch ) ;
2296: LD_EXP 17
2300: PPUSH
2301: CALL_OW 122
// AddComEnterUnit ( Lynch , arm [ 1 ] ) ;
2305: LD_EXP 17
2309: PPUSH
2310: LD_VAR 0 3
2314: PUSH
2315: LD_INT 1
2317: ARRAY
2318: PPUSH
2319: CALL_OW 180
// if IsOk ( Gladstone ) then
2323: LD_EXP 16
2327: PPUSH
2328: CALL_OW 302
2332: IFFALSE 2373
// begin ComExitBuilding ( Gladstone ) ;
2334: LD_EXP 16
2338: PPUSH
2339: CALL_OW 122
// AddComEnterUnit ( Gladstone , arm [ 1 ] ) ;
2343: LD_EXP 16
2347: PPUSH
2348: LD_VAR 0 3
2352: PUSH
2353: LD_INT 1
2355: ARRAY
2356: PPUSH
2357: CALL_OW 180
// AddComChangeProfession ( Gladstone , class_soldier ) ;
2361: LD_EXP 16
2365: PPUSH
2366: LD_INT 1
2368: PPUSH
2369: CALL_OW 183
// end ; ComExitBuilding ( usForces [ 1 ] ) ;
2373: LD_EXP 18
2377: PUSH
2378: LD_INT 1
2380: ARRAY
2381: PPUSH
2382: CALL_OW 122
// AddComEnterUnit ( usForces [ 1 ] , b [ 1 ] ) ;
2386: LD_EXP 18
2390: PUSH
2391: LD_INT 1
2393: ARRAY
2394: PPUSH
2395: LD_VAR 0 2
2399: PUSH
2400: LD_INT 1
2402: ARRAY
2403: PPUSH
2404: CALL_OW 180
// ComExitBuilding ( usForces [ 2 ] ) ;
2408: LD_EXP 18
2412: PUSH
2413: LD_INT 2
2415: ARRAY
2416: PPUSH
2417: CALL_OW 122
// AddComEnterUnit ( usForces [ 2 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
2421: LD_EXP 18
2425: PUSH
2426: LD_INT 2
2428: ARRAY
2429: PPUSH
2430: LD_INT 22
2432: PUSH
2433: LD_INT 1
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 30
2442: PUSH
2443: LD_INT 32
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PPUSH
2454: CALL_OW 69
2458: PUSH
2459: LD_INT 1
2461: ARRAY
2462: PPUSH
2463: CALL_OW 180
// if b > 1 and usForces > 2 then
2467: LD_VAR 0 2
2471: PUSH
2472: LD_INT 1
2474: GREATER
2475: PUSH
2476: LD_EXP 18
2480: PUSH
2481: LD_INT 2
2483: GREATER
2484: AND
2485: IFFALSE 2548
// begin repeat wait ( 0 0$1 ) ;
2487: LD_INT 35
2489: PPUSH
2490: CALL_OW 67
// until BuildingStatus ( b [ 2 ] ) <> bs_build ;
2494: LD_VAR 0 2
2498: PUSH
2499: LD_INT 2
2501: ARRAY
2502: PPUSH
2503: CALL_OW 461
2507: PUSH
2508: LD_INT 1
2510: NONEQUAL
2511: IFFALSE 2487
// ComExitBuilding ( usForces [ 3 ] ) ;
2513: LD_EXP 18
2517: PUSH
2518: LD_INT 3
2520: ARRAY
2521: PPUSH
2522: CALL_OW 122
// AddComEnterUnit ( usForces [ 3 ] , b [ 2 ] ) ;
2526: LD_EXP 18
2530: PUSH
2531: LD_INT 3
2533: ARRAY
2534: PPUSH
2535: LD_VAR 0 2
2539: PUSH
2540: LD_INT 2
2542: ARRAY
2543: PPUSH
2544: CALL_OW 180
// end ; end ;
2548: PPOPN 3
2550: END
// every 0 0$1 trigger GetLives ( usLab ) < 999 and usAlert and usForces do var i ;
2551: LD_INT 3
2553: PPUSH
2554: CALL_OW 256
2558: PUSH
2559: LD_INT 999
2561: LESS
2562: PUSH
2563: LD_EXP 9
2567: AND
2568: PUSH
2569: LD_EXP 18
2573: AND
2574: IFFALSE 2745
2576: GO 2578
2578: DISABLE
2579: LD_INT 0
2581: PPUSH
// begin for i in usForces do
2582: LD_ADDR_VAR 0 1
2586: PUSH
2587: LD_EXP 18
2591: PUSH
2592: FOR_IN
2593: IFFALSE 2632
// begin if IsInUnit ( i ) then
2595: LD_VAR 0 1
2599: PPUSH
2600: CALL_OW 310
2604: IFFALSE 2615
// ComExitBuilding ( i ) ;
2606: LD_VAR 0 1
2610: PPUSH
2611: CALL_OW 122
// AddComAgressiveMove ( i , 31 , 8 ) ;
2615: LD_VAR 0 1
2619: PPUSH
2620: LD_INT 31
2622: PPUSH
2623: LD_INT 8
2625: PPUSH
2626: CALL_OW 174
// end ;
2630: GO 2592
2632: POP
2633: POP
// wait ( 0 0$8 ) ;
2634: LD_INT 280
2636: PPUSH
2637: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) then
2641: LD_INT 22
2643: PUSH
2644: LD_INT 2
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 91
2653: PUSH
2654: LD_INT 3
2656: PUSH
2657: LD_INT 14
2659: PUSH
2660: EMPTY
2661: LIST
2662: LIST
2663: LIST
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: PPUSH
2669: CALL_OW 69
2673: IFFALSE 2723
// ComAttackUnit ( usForces , FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) [ 1 ] ) else
2675: LD_EXP 18
2679: PPUSH
2680: LD_INT 22
2682: PUSH
2683: LD_INT 2
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: PUSH
2690: LD_INT 91
2692: PUSH
2693: LD_INT 3
2695: PUSH
2696: LD_INT 14
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 69
2712: PUSH
2713: LD_INT 1
2715: ARRAY
2716: PPUSH
2717: CALL_OW 115
2721: GO 2745
// begin wait ( 0 0$20 ) ;
2723: LD_INT 700
2725: PPUSH
2726: CALL_OW 67
// AddComMoveXY ( usForces , 39 , 19 ) ;
2730: LD_EXP 18
2734: PPUSH
2735: LD_INT 39
2737: PPUSH
2738: LD_INT 19
2740: PPUSH
2741: CALL_OW 171
// end ; end ;
2745: PPOPN 1
2747: END
// every 0 0$3 trigger ( GetDistUnits ( Heike , Delta ) < 10 or GetLives ( usLab ) < 999 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do var tmp , veh ;
2748: LD_EXP 20
2752: PPUSH
2753: LD_INT 1
2755: PPUSH
2756: CALL_OW 296
2760: PUSH
2761: LD_INT 10
2763: LESS
2764: PUSH
2765: LD_INT 3
2767: PPUSH
2768: CALL_OW 256
2772: PUSH
2773: LD_INT 999
2775: LESS
2776: OR
2777: PUSH
2778: LD_INT 22
2780: PUSH
2781: LD_INT 1
2783: PUSH
2784: EMPTY
2785: LIST
2786: LIST
2787: PUSH
2788: LD_INT 25
2790: PUSH
2791: LD_INT 2
2793: PUSH
2794: EMPTY
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: LIST
2801: PPUSH
2802: CALL_OW 69
2806: AND
2807: IFFALSE 2991
2809: GO 2811
2811: DISABLE
2812: LD_INT 0
2814: PPUSH
2815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
2816: LD_ADDR_VAR 0 1
2820: PUSH
2821: LD_INT 22
2823: PUSH
2824: LD_INT 1
2826: PUSH
2827: EMPTY
2828: LIST
2829: LIST
2830: PUSH
2831: LD_INT 25
2833: PUSH
2834: LD_INT 2
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: EMPTY
2842: LIST
2843: LIST
2844: PPUSH
2845: CALL_OW 69
2849: ST_TO_ADDR
// veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2850: LD_ADDR_VAR 0 2
2854: PUSH
2855: LD_INT 22
2857: PUSH
2858: LD_INT 1
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PUSH
2865: LD_INT 21
2867: PUSH
2868: LD_INT 2
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: PUSH
2875: LD_INT 58
2877: PUSH
2878: EMPTY
2879: LIST
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: PPUSH
2886: CALL_OW 69
2890: ST_TO_ADDR
// if not tmp then
2891: LD_VAR 0 1
2895: NOT
2896: IFFALSE 2900
// exit ;
2898: GO 2991
// ComExitBuilding ( tmp ) ;
2900: LD_VAR 0 1
2904: PPUSH
2905: CALL_OW 122
// AddComDismantle ( tmp , usLab ) ;
2909: LD_VAR 0 1
2913: PPUSH
2914: LD_INT 3
2916: PPUSH
2917: CALL_OW 227
// if veh and IsOk ( Gladstone ) then
2921: LD_VAR 0 2
2925: PUSH
2926: LD_EXP 16
2930: PPUSH
2931: CALL_OW 302
2935: AND
2936: IFFALSE 2991
// begin if IsInUnit ( Gladstone ) then
2938: LD_EXP 16
2942: PPUSH
2943: CALL_OW 310
2947: IFFALSE 2958
// ComExitBuilding ( Gladstone ) ;
2949: LD_EXP 16
2953: PPUSH
2954: CALL_OW 122
// AddComEnterUnit ( Gladstone , veh [ 1 ] ) ;
2958: LD_EXP 16
2962: PPUSH
2963: LD_VAR 0 2
2967: PUSH
2968: LD_INT 1
2970: ARRAY
2971: PPUSH
2972: CALL_OW 180
// AddComAgressiveMove ( Gladstone , 39 , 14 ) ;
2976: LD_EXP 16
2980: PPUSH
2981: LD_INT 39
2983: PPUSH
2984: LD_INT 14
2986: PPUSH
2987: CALL_OW 174
// end ; end ;
2991: PPOPN 2
2993: END
// every 0 0$1 trigger usAlert and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) diff ( usForces union usSci ) do var i , tmp ;
2994: LD_EXP 9
2998: PUSH
2999: LD_INT 22
3001: PUSH
3002: LD_INT 1
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: PUSH
3009: LD_INT 21
3011: PUSH
3012: LD_INT 1
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 3
3021: PUSH
3022: LD_INT 24
3024: PUSH
3025: LD_INT 600
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: PUSH
3032: EMPTY
3033: LIST
3034: LIST
3035: PUSH
3036: EMPTY
3037: LIST
3038: LIST
3039: LIST
3040: PPUSH
3041: CALL_OW 69
3045: PUSH
3046: LD_EXP 18
3050: PUSH
3051: LD_EXP 19
3055: UNION
3056: DIFF
3057: AND
3058: IFFALSE 3195
3060: GO 3062
3062: DISABLE
3063: LD_INT 0
3065: PPUSH
3066: PPUSH
// begin enable ;
3067: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) diff ( usForces union usSci ) ;
3068: LD_ADDR_VAR 0 2
3072: PUSH
3073: LD_INT 22
3075: PUSH
3076: LD_INT 1
3078: PUSH
3079: EMPTY
3080: LIST
3081: LIST
3082: PUSH
3083: LD_INT 21
3085: PUSH
3086: LD_INT 1
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PUSH
3093: LD_INT 3
3095: PUSH
3096: LD_INT 24
3098: PUSH
3099: LD_INT 600
3101: PUSH
3102: EMPTY
3103: LIST
3104: LIST
3105: PUSH
3106: EMPTY
3107: LIST
3108: LIST
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: LIST
3114: PPUSH
3115: CALL_OW 69
3119: PUSH
3120: LD_EXP 18
3124: PUSH
3125: LD_EXP 19
3129: UNION
3130: DIFF
3131: ST_TO_ADDR
// if not tmp then
3132: LD_VAR 0 2
3136: NOT
3137: IFFALSE 3141
// exit ;
3139: GO 3195
// for i in tmp do
3141: LD_ADDR_VAR 0 1
3145: PUSH
3146: LD_VAR 0 2
3150: PUSH
3151: FOR_IN
3152: IFFALSE 3193
// if IsInUnit ( i ) then
3154: LD_VAR 0 1
3158: PPUSH
3159: CALL_OW 310
3163: IFFALSE 3176
// ComExitBuilding ( i ) else
3165: LD_VAR 0 1
3169: PPUSH
3170: CALL_OW 122
3174: GO 3191
// ComMoveXY ( i , 48 , 74 ) ;
3176: LD_VAR 0 1
3180: PPUSH
3181: LD_INT 48
3183: PPUSH
3184: LD_INT 74
3186: PPUSH
3187: CALL_OW 111
3191: GO 3151
3193: POP
3194: POP
// end ;
3195: PPOPN 2
3197: END
// every 5 5$00 do var i , un , tmp ;
3198: GO 3200
3200: DISABLE
3201: LD_INT 0
3203: PPUSH
3204: PPUSH
3205: PPUSH
// begin tmp := [ ] ;
3206: LD_ADDR_VAR 0 3
3210: PUSH
3211: EMPTY
3212: ST_TO_ADDR
// uc_side := 1 ;
3213: LD_ADDR_OWVAR 20
3217: PUSH
3218: LD_INT 1
3220: ST_TO_ADDR
// uc_nation := 1 ;
3221: LD_ADDR_OWVAR 21
3225: PUSH
3226: LD_INT 1
3228: ST_TO_ADDR
// case Difficulty of 1 :
3229: LD_OWVAR 67
3233: PUSH
3234: LD_INT 1
3236: DOUBLE
3237: EQUAL
3238: IFTRUE 3242
3240: GO 3345
3242: POP
// begin wait ( 1 1$00 ) ;
3243: LD_INT 2100
3245: PPUSH
3246: CALL_OW 67
// for i := 1 to 2 do
3250: LD_ADDR_VAR 0 1
3254: PUSH
3255: DOUBLE
3256: LD_INT 1
3258: DEC
3259: ST_TO_ADDR
3260: LD_INT 2
3262: PUSH
3263: FOR_TO
3264: IFFALSE 3341
// begin PrepareHuman ( false , [ 1 , 4 ] [ i mod 2 + 1 ] , 1 ) ;
3266: LD_INT 0
3268: PPUSH
3269: LD_INT 1
3271: PUSH
3272: LD_INT 4
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: PUSH
3279: LD_VAR 0 1
3283: PUSH
3284: LD_INT 2
3286: MOD
3287: PUSH
3288: LD_INT 1
3290: PLUS
3291: ARRAY
3292: PPUSH
3293: LD_INT 1
3295: PPUSH
3296: CALL_OW 380
// un := CreateHuman ;
3300: LD_ADDR_VAR 0 2
3304: PUSH
3305: CALL_OW 44
3309: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3310: LD_ADDR_VAR 0 3
3314: PUSH
3315: LD_VAR 0 3
3319: PPUSH
3320: LD_VAR 0 3
3324: PUSH
3325: LD_INT 1
3327: PLUS
3328: PPUSH
3329: LD_VAR 0 2
3333: PPUSH
3334: CALL_OW 1
3338: ST_TO_ADDR
// end ;
3339: GO 3263
3341: POP
3342: POP
// end ; 2 :
3343: GO 3739
3345: LD_INT 2
3347: DOUBLE
3348: EQUAL
3349: IFTRUE 3353
3351: GO 3487
3353: POP
// begin wait ( 0 0$30 ) ;
3354: LD_INT 1050
3356: PPUSH
3357: CALL_OW 67
// for i := 1 to 2 do
3361: LD_ADDR_VAR 0 1
3365: PUSH
3366: DOUBLE
3367: LD_INT 1
3369: DEC
3370: ST_TO_ADDR
3371: LD_INT 2
3373: PUSH
3374: FOR_TO
3375: IFFALSE 3431
// begin PrepareHuman ( false , 1 , 2 ) ;
3377: LD_INT 0
3379: PPUSH
3380: LD_INT 1
3382: PPUSH
3383: LD_INT 2
3385: PPUSH
3386: CALL_OW 380
// un := CreateHuman ;
3390: LD_ADDR_VAR 0 2
3394: PUSH
3395: CALL_OW 44
3399: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3400: LD_ADDR_VAR 0 3
3404: PUSH
3405: LD_VAR 0 3
3409: PPUSH
3410: LD_VAR 0 3
3414: PUSH
3415: LD_INT 1
3417: PLUS
3418: PPUSH
3419: LD_VAR 0 2
3423: PPUSH
3424: CALL_OW 1
3428: ST_TO_ADDR
// end ;
3429: GO 3374
3431: POP
3432: POP
// PrepareHuman ( false , 4 , 2 ) ;
3433: LD_INT 0
3435: PPUSH
3436: LD_INT 4
3438: PPUSH
3439: LD_INT 2
3441: PPUSH
3442: CALL_OW 380
// un := CreateHuman ;
3446: LD_ADDR_VAR 0 2
3450: PUSH
3451: CALL_OW 44
3455: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3456: LD_ADDR_VAR 0 3
3460: PUSH
3461: LD_VAR 0 3
3465: PPUSH
3466: LD_VAR 0 3
3470: PUSH
3471: LD_INT 1
3473: PLUS
3474: PPUSH
3475: LD_VAR 0 2
3479: PPUSH
3480: CALL_OW 1
3484: ST_TO_ADDR
// end ; 3 :
3485: GO 3739
3487: LD_INT 3
3489: DOUBLE
3490: EQUAL
3491: IFTRUE 3495
3493: GO 3738
3495: POP
// begin for i := 1 to 2 do
3496: LD_ADDR_VAR 0 1
3500: PUSH
3501: DOUBLE
3502: LD_INT 1
3504: DEC
3505: ST_TO_ADDR
3506: LD_INT 2
3508: PUSH
3509: FOR_TO
3510: IFFALSE 3566
// begin PrepareHuman ( false , 1 , 2 ) ;
3512: LD_INT 0
3514: PPUSH
3515: LD_INT 1
3517: PPUSH
3518: LD_INT 2
3520: PPUSH
3521: CALL_OW 380
// un := CreateHuman ;
3525: LD_ADDR_VAR 0 2
3529: PUSH
3530: CALL_OW 44
3534: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3535: LD_ADDR_VAR 0 3
3539: PUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: LD_VAR 0 3
3549: PUSH
3550: LD_INT 1
3552: PLUS
3553: PPUSH
3554: LD_VAR 0 2
3558: PPUSH
3559: CALL_OW 1
3563: ST_TO_ADDR
// end ;
3564: GO 3509
3566: POP
3567: POP
// PrepareHuman ( false , 4 , 2 ) ;
3568: LD_INT 0
3570: PPUSH
3571: LD_INT 4
3573: PPUSH
3574: LD_INT 2
3576: PPUSH
3577: CALL_OW 380
// un := CreateHuman ;
3581: LD_ADDR_VAR 0 2
3585: PUSH
3586: CALL_OW 44
3590: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3591: LD_ADDR_VAR 0 3
3595: PUSH
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_VAR 0 3
3605: PUSH
3606: LD_INT 1
3608: PLUS
3609: PPUSH
3610: LD_VAR 0 2
3614: PPUSH
3615: CALL_OW 1
3619: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_machine_gun , 90 ) ;
3620: LD_INT 1
3622: PPUSH
3623: LD_INT 1
3625: PPUSH
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 2
3631: PPUSH
3632: LD_INT 1
3634: PPUSH
3635: LD_INT 2
3637: PPUSH
3638: LD_INT 90
3640: PPUSH
3641: CALL 276 0 7
// un := CreateVehicle ;
3645: LD_ADDR_VAR 0 2
3649: PUSH
3650: CALL_OW 45
3654: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3655: LD_ADDR_VAR 0 3
3659: PUSH
3660: LD_VAR 0 3
3664: PPUSH
3665: LD_VAR 0 3
3669: PUSH
3670: LD_INT 1
3672: PLUS
3673: PPUSH
3674: LD_VAR 0 2
3678: PPUSH
3679: CALL_OW 1
3683: ST_TO_ADDR
// PrepareHuman ( false , 1 , 2 ) ;
3684: LD_INT 0
3686: PPUSH
3687: LD_INT 1
3689: PPUSH
3690: LD_INT 2
3692: PPUSH
3693: CALL_OW 380
// un := CreateHuman ;
3697: LD_ADDR_VAR 0 2
3701: PUSH
3702: CALL_OW 44
3706: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3707: LD_ADDR_VAR 0 3
3711: PUSH
3712: LD_VAR 0 3
3716: PPUSH
3717: LD_VAR 0 3
3721: PUSH
3722: LD_INT 1
3724: PLUS
3725: PPUSH
3726: LD_VAR 0 2
3730: PPUSH
3731: CALL_OW 1
3735: ST_TO_ADDR
// end ; end ;
3736: GO 3739
3738: POP
// for i := 1 to tmp do
3739: LD_ADDR_VAR 0 1
3743: PUSH
3744: DOUBLE
3745: LD_INT 1
3747: DEC
3748: ST_TO_ADDR
3749: LD_VAR 0 3
3753: PUSH
3754: FOR_TO
3755: IFFALSE 3920
// begin SetDir ( tmp [ i ] , 1 ) ;
3757: LD_VAR 0 3
3761: PUSH
3762: LD_VAR 0 1
3766: ARRAY
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: CALL_OW 233
// if GetType ( tmp [ i ] ) = unit_human then
3775: LD_VAR 0 3
3779: PUSH
3780: LD_VAR 0 1
3784: ARRAY
3785: PPUSH
3786: CALL_OW 247
3790: PUSH
3791: LD_INT 1
3793: EQUAL
3794: IFFALSE 3822
// PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) else
3796: LD_VAR 0 3
3800: PUSH
3801: LD_VAR 0 1
3805: ARRAY
3806: PPUSH
3807: LD_INT 28
3809: PPUSH
3810: LD_INT 52
3812: PPUSH
3813: LD_INT 0
3815: PPUSH
3816: CALL_OW 48
3820: GO 3890
// begin PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) ;
3822: LD_VAR 0 3
3826: PUSH
3827: LD_VAR 0 1
3831: ARRAY
3832: PPUSH
3833: LD_INT 28
3835: PPUSH
3836: LD_INT 52
3838: PPUSH
3839: LD_INT 0
3841: PPUSH
3842: CALL_OW 48
// i := i + 1 ;
3846: LD_ADDR_VAR 0 1
3850: PUSH
3851: LD_VAR 0 1
3855: PUSH
3856: LD_INT 1
3858: PLUS
3859: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ i ] , tmp [ i - 1 ] ) ;
3860: LD_VAR 0 3
3864: PUSH
3865: LD_VAR 0 1
3869: ARRAY
3870: PPUSH
3871: LD_VAR 0 3
3875: PUSH
3876: LD_VAR 0 1
3880: PUSH
3881: LD_INT 1
3883: MINUS
3884: ARRAY
3885: PPUSH
3886: CALL_OW 52
// end ; ComMoveXY ( tmp [ i ] , 43 , 56 ) ;
3890: LD_VAR 0 3
3894: PUSH
3895: LD_VAR 0 1
3899: ARRAY
3900: PPUSH
3901: LD_INT 43
3903: PPUSH
3904: LD_INT 56
3906: PPUSH
3907: CALL_OW 111
// wait ( 0 0$2 ) ;
3911: LD_INT 70
3913: PPUSH
3914: CALL_OW 67
// end ;
3918: GO 3754
3920: POP
3921: POP
// wait ( 0 0$2 ) ;
3922: LD_INT 70
3924: PPUSH
3925: CALL_OW 67
// if not usAlert then
3929: LD_EXP 9
3933: NOT
3934: IFFALSE 4132
// begin AddComAgressiveMove ( tmp , 35 , 24 ) ;
3936: LD_VAR 0 3
3940: PPUSH
3941: LD_INT 35
3943: PPUSH
3944: LD_INT 24
3946: PPUSH
3947: CALL_OW 174
// usForces := usForces union UnitFilter ( tmp , [ f_class , 1 ] ) ;
3951: LD_ADDR_EXP 18
3955: PUSH
3956: LD_EXP 18
3960: PUSH
3961: LD_VAR 0 3
3965: PPUSH
3966: LD_INT 25
3968: PUSH
3969: LD_INT 1
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: PPUSH
3976: CALL_OW 72
3980: UNION
3981: ST_TO_ADDR
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
3982: LD_INT 22
3984: PUSH
3985: LD_INT 1
3987: PUSH
3988: EMPTY
3989: LIST
3990: LIST
3991: PUSH
3992: LD_INT 30
3994: PUSH
3995: LD_INT 4
3997: PUSH
3998: EMPTY
3999: LIST
4000: LIST
4001: PUSH
4002: EMPTY
4003: LIST
4004: LIST
4005: PPUSH
4006: CALL_OW 69
4010: PUSH
4011: LD_INT 1
4013: ARRAY
4014: PPUSH
4015: CALL_OW 313
4019: PUSH
4020: LD_INT 6
4022: LESS
4023: IFFALSE 4082
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
4025: LD_VAR 0 3
4029: PPUSH
4030: LD_INT 25
4032: PUSH
4033: LD_INT 1
4035: PUSH
4036: EMPTY
4037: LIST
4038: LIST
4039: PPUSH
4040: CALL_OW 72
4044: PPUSH
4045: LD_INT 22
4047: PUSH
4048: LD_INT 1
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: PUSH
4055: LD_INT 30
4057: PUSH
4058: LD_INT 4
4060: PUSH
4061: EMPTY
4062: LIST
4063: LIST
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: PPUSH
4069: CALL_OW 69
4073: PUSH
4074: LD_INT 1
4076: ARRAY
4077: PPUSH
4078: CALL_OW 180
// if UnitFilter ( tmp , [ f_class , 4 ] ) then
4082: LD_VAR 0 3
4086: PPUSH
4087: LD_INT 25
4089: PUSH
4090: LD_INT 4
4092: PUSH
4093: EMPTY
4094: LIST
4095: LIST
4096: PPUSH
4097: CALL_OW 72
4101: IFFALSE 4130
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 4 ] ) , usLab ) ;
4103: LD_VAR 0 3
4107: PPUSH
4108: LD_INT 25
4110: PUSH
4111: LD_INT 4
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: PPUSH
4118: CALL_OW 72
4122: PPUSH
4123: LD_INT 3
4125: PPUSH
4126: CALL_OW 180
// end else
4130: GO 4407
// begin tmp := tmp union FilterUnitsInArea ( retreatArea , [ f_side , 1 ] ) ;
4132: LD_ADDR_VAR 0 3
4136: PUSH
4137: LD_VAR 0 3
4141: PUSH
4142: LD_INT 6
4144: PPUSH
4145: LD_INT 22
4147: PUSH
4148: LD_INT 1
4150: PUSH
4151: EMPTY
4152: LIST
4153: LIST
4154: PPUSH
4155: CALL_OW 70
4159: UNION
4160: ST_TO_ADDR
// ComMoveXY ( tmp , 45 , 54 ) ;
4161: LD_VAR 0 3
4165: PPUSH
4166: LD_INT 45
4168: PPUSH
4169: LD_INT 54
4171: PPUSH
4172: CALL_OW 111
// wait ( 0 0$3 ) ;
4176: LD_INT 105
4178: PPUSH
4179: CALL_OW 67
// AddComAgressiveMove ( tmp diff UnitFilter ( tmp , [ f_class , 4 ] ) , 35 , 24 ) ;
4183: LD_VAR 0 3
4187: PUSH
4188: LD_VAR 0 3
4192: PPUSH
4193: LD_INT 25
4195: PUSH
4196: LD_INT 4
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: PPUSH
4203: CALL_OW 72
4207: DIFF
4208: PPUSH
4209: LD_INT 35
4211: PPUSH
4212: LD_INT 24
4214: PPUSH
4215: CALL_OW 174
// AddComMoveXY ( UnitFilter ( tmp , [ f_class , 4 ] ) , 42 , 49 ) ;
4219: LD_VAR 0 3
4223: PPUSH
4224: LD_INT 25
4226: PUSH
4227: LD_INT 4
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PPUSH
4234: CALL_OW 72
4238: PPUSH
4239: LD_INT 42
4241: PPUSH
4242: LD_INT 49
4244: PPUSH
4245: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4249: LD_INT 35
4251: PPUSH
4252: CALL_OW 67
// for i in tmp do
4256: LD_ADDR_VAR 0 1
4260: PUSH
4261: LD_VAR 0 3
4265: PUSH
4266: FOR_IN
4267: IFFALSE 4398
// if IsDead ( i ) then
4269: LD_VAR 0 1
4273: PPUSH
4274: CALL_OW 301
4278: IFFALSE 4298
// tmp := tmp diff i else
4280: LD_ADDR_VAR 0 3
4284: PUSH
4285: LD_VAR 0 3
4289: PUSH
4290: LD_VAR 0 1
4294: DIFF
4295: ST_TO_ADDR
4296: GO 4396
// if GetClass ( i ) = 1 then
4298: LD_VAR 0 1
4302: PPUSH
4303: CALL_OW 257
4307: PUSH
4308: LD_INT 1
4310: EQUAL
4311: IFFALSE 4396
// begin if GetLives ( i ) < 600 and GetDistUnitXY ( i , 42 , 49 ) > 6 then
4313: LD_VAR 0 1
4317: PPUSH
4318: CALL_OW 256
4322: PUSH
4323: LD_INT 600
4325: LESS
4326: PUSH
4327: LD_VAR 0 1
4331: PPUSH
4332: LD_INT 42
4334: PPUSH
4335: LD_INT 49
4337: PPUSH
4338: CALL_OW 297
4342: PUSH
4343: LD_INT 6
4345: GREATER
4346: AND
4347: IFFALSE 4366
// ComMoveXY ( i , 42 , 49 ) else
4349: LD_VAR 0 1
4353: PPUSH
4354: LD_INT 42
4356: PPUSH
4357: LD_INT 49
4359: PPUSH
4360: CALL_OW 111
4364: GO 4396
// if GetLives ( i ) = 1000 then
4366: LD_VAR 0 1
4370: PPUSH
4371: CALL_OW 256
4375: PUSH
4376: LD_INT 1000
4378: EQUAL
4379: IFFALSE 4396
// ComAgressiveMove ( i , 36 , 25 ) ;
4381: LD_VAR 0 1
4385: PPUSH
4386: LD_INT 36
4388: PPUSH
4389: LD_INT 25
4391: PPUSH
4392: CALL_OW 114
// end ;
4396: GO 4266
4398: POP
4399: POP
// until not tmp ;
4400: LD_VAR 0 3
4404: NOT
4405: IFFALSE 4249
// end ; end ; end_of_file
4407: PPOPN 3
4409: END
// export function Action ; var i , tmp ; begin
4410: LD_INT 0
4412: PPUSH
4413: PPUSH
4414: PPUSH
// InGameOn ;
4415: CALL_OW 8
// DoNotAttack ( 2 , usLab ) ;
4419: LD_INT 2
4421: PPUSH
4422: LD_INT 3
4424: PPUSH
4425: CALL_OW 471
// ComMoveXY ( Heike , 78 , 61 ) ;
4429: LD_EXP 20
4433: PPUSH
4434: LD_INT 78
4436: PPUSH
4437: LD_INT 61
4439: PPUSH
4440: CALL_OW 111
// if Mike then
4444: LD_EXP 22
4448: IFFALSE 4465
// ComMoveXY ( Mike , 80 , 66 ) ;
4450: LD_EXP 22
4454: PPUSH
4455: LD_INT 80
4457: PPUSH
4458: LD_INT 66
4460: PPUSH
4461: CALL_OW 111
// if Givi then
4465: LD_EXP 21
4469: IFFALSE 4486
// ComMoveXY ( Givi , 82 , 66 ) ;
4471: LD_EXP 21
4475: PPUSH
4476: LD_INT 82
4478: PPUSH
4479: LD_INT 66
4481: PPUSH
4482: CALL_OW 111
// if Kamil then
4486: LD_EXP 23
4490: IFFALSE 4507
// ComMoveXY ( Kamil , 82 , 67 ) ;
4492: LD_EXP 23
4496: PPUSH
4497: LD_INT 82
4499: PPUSH
4500: LD_INT 67
4502: PPUSH
4503: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
4507: LD_EXP 20
4511: PPUSH
4512: CALL_OW 87
// wait ( 0 0$2 ) ;
4516: LD_INT 70
4518: PPUSH
4519: CALL_OW 67
// if Givi and Mike then
4523: LD_EXP 21
4527: PUSH
4528: LD_EXP 22
4532: AND
4533: IFFALSE 4979
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4535: LD_EXP 21
4539: PUSH
4540: LD_EXP 22
4544: PUSH
4545: LD_EXP 23
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: LIST
4554: PPUSH
4555: LD_EXP 20
4559: PPUSH
4560: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
4564: LD_EXP 20
4568: PPUSH
4569: LD_EXP 21
4573: PPUSH
4574: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
4578: LD_EXP 21
4582: PPUSH
4583: LD_STRING DG-1-start
4585: PPUSH
4586: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
4590: LD_EXP 20
4594: PPUSH
4595: LD_STRING DH-1-start
4597: PPUSH
4598: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
4602: LD_EXP 22
4606: PPUSH
4607: LD_EXP 20
4611: PPUSH
4612: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
4616: LD_EXP 20
4620: PPUSH
4621: LD_EXP 22
4625: PPUSH
4626: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
4630: LD_EXP 22
4634: PPUSH
4635: LD_STRING DM-1-start
4637: PPUSH
4638: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
4642: LD_EXP 20
4646: PPUSH
4647: LD_STRING DH-2-start
4649: PPUSH
4650: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
4654: LD_EXP 22
4658: PPUSH
4659: LD_STRING DM-2-start
4661: PPUSH
4662: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
4666: LD_EXP 21
4670: PPUSH
4671: LD_STRING DG-2-start
4673: PPUSH
4674: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
4678: LD_EXP 22
4682: PPUSH
4683: LD_EXP 21
4687: PPUSH
4688: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
4692: LD_EXP 20
4696: PPUSH
4697: LD_EXP 22
4701: PPUSH
4702: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
4706: LD_EXP 22
4710: PPUSH
4711: LD_STRING DM-3-start
4713: PPUSH
4714: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
4718: LD_EXP 20
4722: PPUSH
4723: LD_STRING DH-3-start
4725: PPUSH
4726: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
4730: LD_EXP 20
4734: PUSH
4735: LD_EXP 22
4739: PUSH
4740: LD_EXP 21
4744: PUSH
4745: LD_EXP 23
4749: PUSH
4750: EMPTY
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: PPUSH
4756: LD_INT 84
4758: PPUSH
4759: LD_INT 51
4761: PPUSH
4762: CALL_OW 111
// wait ( 0 0$2 ) ;
4766: LD_INT 70
4768: PPUSH
4769: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
4773: LD_EXP 21
4777: PPUSH
4778: LD_STRING DG-3-start
4780: PPUSH
4781: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
4785: LD_EXP 20
4789: PUSH
4790: LD_EXP 22
4794: PUSH
4795: LD_EXP 21
4799: PUSH
4800: LD_EXP 23
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: LIST
4809: LIST
4810: PPUSH
4811: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
4815: LD_EXP 20
4819: PPUSH
4820: LD_EXP 21
4824: PPUSH
4825: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4829: LD_EXP 21
4833: PUSH
4834: LD_EXP 22
4838: PUSH
4839: LD_EXP 23
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: LIST
4848: PPUSH
4849: LD_EXP 20
4853: PPUSH
4854: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
4858: LD_EXP 20
4862: PPUSH
4863: LD_STRING DH-4-start
4865: PPUSH
4866: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
4870: LD_EXP 21
4874: PPUSH
4875: LD_STRING DG-4-start
4877: PPUSH
4878: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
4882: LD_EXP 20
4886: PPUSH
4887: LD_STRING DH-5-start
4889: PPUSH
4890: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
4894: LD_EXP 21
4898: PPUSH
4899: LD_STRING DG-5-start
4901: PPUSH
4902: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
4906: LD_EXP 20
4910: PPUSH
4911: LD_STRING DH-6-start
4913: PPUSH
4914: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
4918: LD_EXP 22
4922: PPUSH
4923: LD_STRING DM-6-start
4925: PPUSH
4926: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
4930: LD_EXP 20
4934: PUSH
4935: LD_EXP 21
4939: PUSH
4940: EMPTY
4941: LIST
4942: LIST
4943: PPUSH
4944: LD_EXP 22
4948: PPUSH
4949: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
4953: LD_EXP 21
4957: PPUSH
4958: LD_STRING DG-6-start
4960: PPUSH
4961: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
4965: LD_EXP 20
4969: PPUSH
4970: LD_STRING DH-7-start
4972: PPUSH
4973: CALL_OW 88
// end else
4977: GO 5701
// if not Mike and Givi then
4979: LD_EXP 22
4983: NOT
4984: PUSH
4985: LD_EXP 21
4989: AND
4990: IFFALSE 5335
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
4992: LD_EXP 21
4996: PUSH
4997: LD_EXP 23
5001: PUSH
5002: EMPTY
5003: LIST
5004: LIST
5005: PPUSH
5006: LD_EXP 20
5010: PPUSH
5011: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
5015: LD_EXP 20
5019: PPUSH
5020: LD_EXP 21
5024: PPUSH
5025: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
5029: LD_EXP 21
5033: PPUSH
5034: LD_STRING DG-1-start-c
5036: PPUSH
5037: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
5041: LD_EXP 20
5045: PPUSH
5046: LD_STRING DH-1-start-c
5048: PPUSH
5049: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
5053: LD_EXP 21
5057: PPUSH
5058: LD_STRING DG-2-start-c
5060: PPUSH
5061: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
5065: LD_EXP 20
5069: PPUSH
5070: LD_STRING DH-2-start-c
5072: PPUSH
5073: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
5077: LD_EXP 21
5081: PPUSH
5082: LD_STRING DG-3-start-c
5084: PPUSH
5085: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
5089: LD_EXP 20
5093: PPUSH
5094: LD_INT 83
5096: PPUSH
5097: LD_INT 56
5099: PPUSH
5100: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
5104: LD_EXP 21
5108: PPUSH
5109: LD_INT 83
5111: PPUSH
5112: LD_INT 59
5114: PPUSH
5115: CALL_OW 111
// if Kamil then
5119: LD_EXP 23
5123: IFFALSE 5140
// ComMoveXY ( Kamil , 80 , 58 ) ;
5125: LD_EXP 23
5129: PPUSH
5130: LD_INT 80
5132: PPUSH
5133: LD_INT 58
5135: PPUSH
5136: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
5140: LD_EXP 20
5144: PPUSH
5145: LD_EXP 21
5149: PPUSH
5150: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5154: LD_EXP 21
5158: PUSH
5159: LD_EXP 23
5163: PUSH
5164: EMPTY
5165: LIST
5166: LIST
5167: PPUSH
5168: LD_EXP 20
5172: PPUSH
5173: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
5177: LD_EXP 20
5181: PPUSH
5182: LD_STRING DH-3-start-c
5184: PPUSH
5185: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
5189: LD_EXP 21
5193: PPUSH
5194: LD_STRING DG-4-start-c
5196: PPUSH
5197: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
5201: LD_EXP 20
5205: PPUSH
5206: LD_STRING DH-5-start-c
5208: PPUSH
5209: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
5213: LD_EXP 21
5217: PPUSH
5218: LD_STRING DG-5-start-c
5220: PPUSH
5221: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
5225: LD_EXP 20
5229: PPUSH
5230: LD_STRING DH-6-start-c
5232: PPUSH
5233: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
5237: LD_EXP 21
5241: PPUSH
5242: LD_STRING DG-6-start-c
5244: PPUSH
5245: CALL_OW 88
// if Kamil then
5249: LD_EXP 23
5253: IFFALSE 5309
// begin ComTurnUnit ( Kamil , Heike ) ;
5255: LD_EXP 23
5259: PPUSH
5260: LD_EXP 20
5264: PPUSH
5265: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5269: LD_EXP 23
5273: PPUSH
5274: LD_STRING DKam-1-start-c
5276: PPUSH
5277: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
5281: LD_EXP 21
5285: PPUSH
5286: LD_EXP 23
5290: PPUSH
5291: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
5295: LD_EXP 21
5299: PPUSH
5300: LD_STRING DG-7-start-c
5302: PPUSH
5303: CALL_OW 88
// end else
5307: GO 5333
// begin Say ( Givi , DG-8-start-c ) ;
5309: LD_EXP 21
5313: PPUSH
5314: LD_STRING DG-8-start-c
5316: PPUSH
5317: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
5321: LD_EXP 20
5325: PPUSH
5326: LD_STRING DH-7-start-c
5328: PPUSH
5329: CALL_OW 88
// end ; end else
5333: GO 5701
// if not Givi and Mike then
5335: LD_EXP 21
5339: NOT
5340: PUSH
5341: LD_EXP 22
5345: AND
5346: IFFALSE 5605
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
5348: LD_EXP 22
5352: PUSH
5353: LD_EXP 23
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: PPUSH
5362: LD_EXP 20
5366: PPUSH
5367: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
5371: LD_EXP 20
5375: PPUSH
5376: LD_EXP 22
5380: PPUSH
5381: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
5385: LD_EXP 22
5389: PPUSH
5390: LD_STRING DM-1-start-b
5392: PPUSH
5393: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
5397: LD_EXP 20
5401: PPUSH
5402: LD_STRING DH-1-start-b
5404: PPUSH
5405: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
5409: LD_EXP 22
5413: PPUSH
5414: LD_STRING DM-2-start-b
5416: PPUSH
5417: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
5421: LD_EXP 20
5425: PPUSH
5426: LD_STRING DH-2-start-b
5428: PPUSH
5429: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
5433: LD_EXP 22
5437: PPUSH
5438: LD_STRING DM-3-start-b
5440: PPUSH
5441: CALL_OW 88
// if Kamil then
5445: LD_EXP 23
5449: IFFALSE 5466
// ComMoveXY ( Kamil , 80 , 58 ) ;
5451: LD_EXP 23
5455: PPUSH
5456: LD_INT 80
5458: PPUSH
5459: LD_INT 58
5461: PPUSH
5462: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
5466: LD_EXP 20
5470: PPUSH
5471: LD_INT 83
5473: PPUSH
5474: LD_INT 56
5476: PPUSH
5477: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
5481: LD_EXP 22
5485: PPUSH
5486: LD_INT 83
5488: PPUSH
5489: LD_INT 59
5491: PPUSH
5492: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
5496: LD_EXP 20
5500: PPUSH
5501: LD_EXP 22
5505: PPUSH
5506: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
5510: LD_EXP 23
5514: PUSH
5515: LD_EXP 22
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: PPUSH
5524: LD_EXP 20
5528: PPUSH
5529: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
5533: LD_EXP 20
5537: PPUSH
5538: LD_STRING DH-3-start-b
5540: PPUSH
5541: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
5545: LD_EXP 22
5549: PPUSH
5550: LD_STRING DM-4-start-b
5552: PPUSH
5553: CALL_OW 88
// if Kamil then
5557: LD_EXP 23
5561: IFFALSE 5591
// begin ComTurnUnit ( Kamil , Heike ) ;
5563: LD_EXP 23
5567: PPUSH
5568: LD_EXP 20
5572: PPUSH
5573: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5577: LD_EXP 23
5581: PPUSH
5582: LD_STRING DKam-1-start-c
5584: PPUSH
5585: CALL_OW 88
// end else
5589: GO 5603
// begin Say ( Mike , DM-5-start-b ) ;
5591: LD_EXP 22
5595: PPUSH
5596: LD_STRING DM-5-start-b
5598: PPUSH
5599: CALL_OW 88
// end ; end else
5603: GO 5701
// if Kamil then
5605: LD_EXP 23
5609: IFFALSE 5689
// begin AddComTurnUnit ( Heike , Kamil ) ;
5611: LD_EXP 20
5615: PPUSH
5616: LD_EXP 23
5620: PPUSH
5621: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
5625: LD_EXP 23
5629: PPUSH
5630: LD_EXP 20
5634: PPUSH
5635: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
5639: LD_EXP 20
5643: PPUSH
5644: LD_STRING DH-1-start-f
5646: PPUSH
5647: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
5651: LD_EXP 23
5655: PPUSH
5656: LD_STRING DKam-1-start-f
5658: PPUSH
5659: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
5663: LD_EXP 20
5667: PPUSH
5668: LD_STRING DH-2-start-f
5670: PPUSH
5671: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
5675: LD_EXP 23
5679: PPUSH
5680: LD_STRING DKam-2-start-f
5682: PPUSH
5683: CALL_OW 88
// end else
5687: GO 5701
// begin Say ( Heike , DH-1-start-d ) ;
5689: LD_EXP 20
5693: PPUSH
5694: LD_STRING DH-1-start-d
5696: PPUSH
5697: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
5701: LD_EXP 20
5705: PUSH
5706: LD_EXP 21
5710: PUSH
5711: LD_EXP 22
5715: PUSH
5716: LD_EXP 23
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: LIST
5725: LIST
5726: PPUSH
5727: CALL_OW 139
// InGameOff ;
5731: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
5735: LD_STRING OEast
5737: PPUSH
5738: CALL_OW 337
// wait ( 0 0$20 ) ;
5742: LD_INT 700
5744: PPUSH
5745: CALL_OW 67
// SendSciToForest ;
5749: CALL 1375 0 0
// if Difficulty = 1 then
5753: LD_OWVAR 67
5757: PUSH
5758: LD_INT 1
5760: EQUAL
5761: IFFALSE 5765
// exit ;
5763: GO 5882
// wait ( [ 5 5$00 , 2 2$30 ] [ Difficulty - 1 ] ) ;
5765: LD_INT 10500
5767: PUSH
5768: LD_INT 5250
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: PUSH
5775: LD_OWVAR 67
5779: PUSH
5780: LD_INT 1
5782: MINUS
5783: ARRAY
5784: PPUSH
5785: CALL_OW 67
// if usAlert then
5789: LD_EXP 9
5793: IFFALSE 5797
// exit ;
5795: GO 5882
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
5797: LD_ADDR_VAR 0 3
5801: PUSH
5802: LD_INT 22
5804: PUSH
5805: LD_INT 1
5807: PUSH
5808: EMPTY
5809: LIST
5810: LIST
5811: PUSH
5812: LD_INT 25
5814: PUSH
5815: LD_INT 2
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: PUSH
5822: EMPTY
5823: LIST
5824: LIST
5825: PPUSH
5826: CALL_OW 69
5830: ST_TO_ADDR
// if not tmp then
5831: LD_VAR 0 3
5835: NOT
5836: IFFALSE 5840
// exit ;
5838: GO 5882
// ComExitBuilding ( tmp ) ;
5840: LD_VAR 0 3
5844: PPUSH
5845: CALL_OW 122
// AddComBuild ( tmp , b_breastwork , 40 , 13 , 3 ) ;
5849: LD_VAR 0 3
5853: PPUSH
5854: LD_INT 31
5856: PPUSH
5857: LD_INT 40
5859: PPUSH
5860: LD_INT 13
5862: PPUSH
5863: LD_INT 3
5865: PPUSH
5866: CALL_OW 205
// AddComEnterUnit ( tmp , Delta ) ;
5870: LD_VAR 0 3
5874: PPUSH
5875: LD_INT 1
5877: PPUSH
5878: CALL_OW 180
// end ;
5882: LD_VAR 0 1
5886: RET
// every 0 0$1 trigger not aviradzeSpotted and See ( 2 , Aviradze ) do var i , pepAmount ;
5887: LD_EXP 4
5891: NOT
5892: PUSH
5893: LD_INT 2
5895: PPUSH
5896: LD_EXP 24
5900: PPUSH
5901: CALL_OW 292
5905: AND
5906: IFFALSE 6814
5908: GO 5910
5910: DISABLE
5911: LD_INT 0
5913: PPUSH
5914: PPUSH
// begin aviradzeSpotted := true ;
5915: LD_ADDR_EXP 4
5919: PUSH
5920: LD_INT 1
5922: ST_TO_ADDR
// pepAmount := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
5923: LD_ADDR_VAR 0 2
5927: PUSH
5928: LD_INT 22
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: PUSH
5938: LD_INT 21
5940: PUSH
5941: LD_INT 1
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: PUSH
5948: EMPTY
5949: LIST
5950: LIST
5951: PPUSH
5952: CALL_OW 69
5956: ST_TO_ADDR
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
5957: LD_EXP 20
5961: PPUSH
5962: LD_EXP 24
5966: PPUSH
5967: CALL_OW 250
5971: PPUSH
5972: LD_EXP 24
5976: PPUSH
5977: CALL_OW 251
5981: PPUSH
5982: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
5986: LD_INT 35
5988: PPUSH
5989: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 16 ;
5993: LD_EXP 20
5997: PPUSH
5998: LD_EXP 24
6002: PPUSH
6003: CALL_OW 296
6007: PUSH
6008: LD_INT 16
6010: LESS
6011: IFFALSE 5986
// InGameOn ;
6013: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6017: LD_INT 5
6019: PPUSH
6020: LD_INT 2
6022: PPUSH
6023: CALL_OW 343
// if pepAmount > 2 then
6027: LD_VAR 0 2
6031: PUSH
6032: LD_INT 2
6034: GREATER
6035: IFFALSE 6051
// Say ( Heike , DH-1-spot ) else
6037: LD_EXP 20
6041: PPUSH
6042: LD_STRING DH-1-spot
6044: PPUSH
6045: CALL_OW 88
6049: GO 6063
// Say ( Heike , DH-1-spot-d ) ;
6051: LD_EXP 20
6055: PPUSH
6056: LD_STRING DH-1-spot-d
6058: PPUSH
6059: CALL_OW 88
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6063: LD_EXP 20
6067: PPUSH
6068: LD_EXP 24
6072: PPUSH
6073: CALL_OW 250
6077: PPUSH
6078: LD_EXP 24
6082: PPUSH
6083: CALL_OW 251
6087: PPUSH
6088: CALL_OW 111
// for i in [ Kamil , Mike , Givi ] do
6092: LD_ADDR_VAR 0 1
6096: PUSH
6097: LD_EXP 23
6101: PUSH
6102: LD_EXP 22
6106: PUSH
6107: LD_EXP 21
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: LIST
6116: PUSH
6117: FOR_IN
6118: IFFALSE 6157
// if GetDistUnits ( i , Aviradze ) > 7 then
6120: LD_VAR 0 1
6124: PPUSH
6125: LD_EXP 24
6129: PPUSH
6130: CALL_OW 296
6134: PUSH
6135: LD_INT 7
6137: GREATER
6138: IFFALSE 6155
// ComMoveXY ( i , 102 , 40 ) ;
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 102
6147: PPUSH
6148: LD_INT 40
6150: PPUSH
6151: CALL_OW 111
6155: GO 6117
6157: POP
6158: POP
// repeat wait ( 0 0$1 ) ;
6159: LD_INT 35
6161: PPUSH
6162: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 6 ;
6166: LD_EXP 20
6170: PPUSH
6171: LD_EXP 24
6175: PPUSH
6176: CALL_OW 296
6180: PUSH
6181: LD_INT 6
6183: LESS
6184: IFFALSE 6159
// ComTurnUnit ( Heike , Aviradze ) ;
6186: LD_EXP 20
6190: PPUSH
6191: LD_EXP 24
6195: PPUSH
6196: CALL_OW 119
// ComTurnUnit ( [ Aviradze , Sophia , Kaia ] , Heike ) ;
6200: LD_EXP 24
6204: PUSH
6205: LD_EXP 26
6209: PUSH
6210: LD_EXP 25
6214: PUSH
6215: EMPTY
6216: LIST
6217: LIST
6218: LIST
6219: PPUSH
6220: LD_EXP 20
6224: PPUSH
6225: CALL_OW 119
// if pepAmount > 1 then
6229: LD_VAR 0 2
6233: PUSH
6234: LD_INT 1
6236: GREATER
6237: IFFALSE 6289
// begin wait ( 0 0$2 ) ;
6239: LD_INT 70
6241: PPUSH
6242: CALL_OW 67
// ComTurnUnit ( [ Kamil , Mike , Givi ] , Aviradze ) ;
6246: LD_EXP 23
6250: PUSH
6251: LD_EXP 22
6255: PUSH
6256: LD_EXP 21
6260: PUSH
6261: EMPTY
6262: LIST
6263: LIST
6264: LIST
6265: PPUSH
6266: LD_EXP 24
6270: PPUSH
6271: CALL_OW 119
// Say ( Heike , DH-2-spot ) ;
6275: LD_EXP 20
6279: PPUSH
6280: LD_STRING DH-2-spot
6282: PPUSH
6283: CALL_OW 88
// end else
6287: GO 6301
// Say ( Heike , DH-2-spot-d ) ;
6289: LD_EXP 20
6293: PPUSH
6294: LD_STRING DH-2-spot-d
6296: PPUSH
6297: CALL_OW 88
// Say ( Aviradze , DA-2-spot ) ;
6301: LD_EXP 24
6305: PPUSH
6306: LD_STRING DA-2-spot
6308: PPUSH
6309: CALL_OW 88
// Say ( Heike , DH-3-spot ) ;
6313: LD_EXP 20
6317: PPUSH
6318: LD_STRING DH-3-spot
6320: PPUSH
6321: CALL_OW 88
// ComMoveUnit ( Kaia , Heike ) ;
6325: LD_EXP 25
6329: PPUSH
6330: LD_EXP 20
6334: PPUSH
6335: CALL_OW 112
// ComTurnUNit ( Heike , Kaia ) ;
6339: LD_EXP 20
6343: PPUSH
6344: LD_EXP 25
6348: PPUSH
6349: CALL_OW 119
// wait ( 0 0$0.3 ) ;
6353: LD_INT 10
6355: PPUSH
6356: CALL_OW 67
// async ;
6360: ASYNC
// Say ( Kaia , DK-3-spot ) ;
6361: LD_EXP 25
6365: PPUSH
6366: LD_STRING DK-3-spot
6368: PPUSH
6369: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6373: LD_INT 35
6375: PPUSH
6376: CALL_OW 67
// until GetDistUnits ( Heike , Kaia ) < 4 ;
6380: LD_EXP 20
6384: PPUSH
6385: LD_EXP 25
6389: PPUSH
6390: CALL_OW 296
6394: PUSH
6395: LD_INT 4
6397: LESS
6398: IFFALSE 6373
// ComTurnUnit ( Kaia , Heike ) ;
6400: LD_EXP 25
6404: PPUSH
6405: LD_EXP 20
6409: PPUSH
6410: CALL_OW 119
// sync ;
6414: SYNC
// Say ( Heike , DH-4-spot ) ;
6415: LD_EXP 20
6419: PPUSH
6420: LD_STRING DH-4-spot
6422: PPUSH
6423: CALL_OW 88
// wait ( 0 0$0.3 ) ;
6427: LD_INT 10
6429: PPUSH
6430: CALL_OW 67
// ComTurnUnit ( Heike , Aviradze ) ;
6434: LD_EXP 20
6438: PPUSH
6439: LD_EXP 24
6443: PPUSH
6444: CALL_OW 119
// Say ( Aviradze , DA-4-spot ) ;
6448: LD_EXP 24
6452: PPUSH
6453: LD_STRING DA-4-spot
6455: PPUSH
6456: CALL_OW 88
// ComTurnUnit ( Kaia , Aviradze ) ;
6460: LD_EXP 25
6464: PPUSH
6465: LD_EXP 24
6469: PPUSH
6470: CALL_OW 119
// Say ( Kaia , DK-4-spot ) ;
6474: LD_EXP 25
6478: PPUSH
6479: LD_STRING DK-4-spot
6481: PPUSH
6482: CALL_OW 88
// ComTurnUnit ( Aviradze , Kaia ) ;
6486: LD_EXP 24
6490: PPUSH
6491: LD_EXP 25
6495: PPUSH
6496: CALL_OW 119
// Say ( Aviradze , DA-5-spot ) ;
6500: LD_EXP 24
6504: PPUSH
6505: LD_STRING DA-5-spot
6507: PPUSH
6508: CALL_OW 88
// Say ( Kaia , DK-5-spot ) ;
6512: LD_EXP 25
6516: PPUSH
6517: LD_STRING DK-5-spot
6519: PPUSH
6520: CALL_OW 88
// if pepAmount = 1 then
6524: LD_VAR 0 2
6528: PUSH
6529: LD_INT 1
6531: EQUAL
6532: IFFALSE 6546
// Say ( Heike , DH-5-spot-f ) ;
6534: LD_EXP 20
6538: PPUSH
6539: LD_STRING DH-5-spot-f
6541: PPUSH
6542: CALL_OW 88
// if pepAmount < 3 then
6546: LD_VAR 0 2
6550: PUSH
6551: LD_INT 3
6553: LESS
6554: IFFALSE 6570
// Say ( Aviradze , DA-6-spot-f ) else
6556: LD_EXP 24
6560: PPUSH
6561: LD_STRING DA-6-spot-f
6563: PPUSH
6564: CALL_OW 88
6568: GO 6606
// if pepAmount < 4 then
6570: LD_VAR 0 2
6574: PUSH
6575: LD_INT 4
6577: LESS
6578: IFFALSE 6594
// Say ( Aviradze , DA-6-spot-c ) else
6580: LD_EXP 24
6584: PPUSH
6585: LD_STRING DA-6-spot-c
6587: PPUSH
6588: CALL_OW 88
6592: GO 6606
// Say ( Aviradze , DA-6-spot ) ;
6594: LD_EXP 24
6598: PPUSH
6599: LD_STRING DA-6-spot
6601: PPUSH
6602: CALL_OW 88
// if Kamil then
6606: LD_EXP 23
6610: IFFALSE 6624
// Say ( Kamil , DKam-6-spot ) ;
6612: LD_EXP 23
6616: PPUSH
6617: LD_STRING DKam-6-spot
6619: PPUSH
6620: CALL_OW 88
// Say ( Kaia , DK-6-spot ) ;
6624: LD_EXP 25
6628: PPUSH
6629: LD_STRING DK-6-spot
6631: PPUSH
6632: CALL_OW 88
// ComTurnUnit ( Aviradze , Heike ) ;
6636: LD_EXP 24
6640: PPUSH
6641: LD_EXP 20
6645: PPUSH
6646: CALL_OW 119
// Say ( Aviradze , DA-7-spot ) ;
6650: LD_EXP 24
6654: PPUSH
6655: LD_STRING DA-7-spot
6657: PPUSH
6658: CALL_OW 88
// Say ( Heike , DH-7-spot ) ;
6662: LD_EXP 20
6666: PPUSH
6667: LD_STRING DH-7-spot
6669: PPUSH
6670: CALL_OW 88
// if sciCounterKill >= 3 then
6674: LD_EXP 8
6678: PUSH
6679: LD_INT 3
6681: GREATEREQUAL
6682: IFFALSE 6708
// begin Say ( Heike , DH-7-spot-a ) ;
6684: LD_EXP 20
6688: PPUSH
6689: LD_STRING DH-7-spot-a
6691: PPUSH
6692: CALL_OW 88
// Say ( Aviradze , DA-8-spot-a ) ;
6696: LD_EXP 24
6700: PPUSH
6701: LD_STRING DA-8-spot-a
6703: PPUSH
6704: CALL_OW 88
// end ; InGameOff ;
6708: CALL_OW 9
// if sciCounterKill < 3 then
6712: LD_EXP 8
6716: PUSH
6717: LD_INT 3
6719: LESS
6720: IFFALSE 6752
// begin SetSide ( Kaia , 2 ) ;
6722: LD_EXP 25
6726: PPUSH
6727: LD_INT 2
6729: PPUSH
6730: CALL_OW 235
// ComFree ( Kaia ) ;
6734: LD_EXP 25
6738: PPUSH
6739: CALL_OW 139
// ChangeMissionObjectives ( OSci ) ;
6743: LD_STRING OSci
6745: PPUSH
6746: CALL_OW 337
// end else
6750: GO 6814
// begin aviradzeQuestDone := true ;
6752: LD_ADDR_EXP 7
6756: PUSH
6757: LD_INT 1
6759: ST_TO_ADDR
// attackDeltaAllowed := true ;
6760: LD_ADDR_EXP 12
6764: PUSH
6765: LD_INT 1
6767: ST_TO_ADDR
// ChangeMissionObjectives ( ODelta2 ) ;
6768: LD_STRING ODelta2
6770: PPUSH
6771: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
6775: LD_ADDR_VAR 0 1
6779: PUSH
6780: LD_INT 22
6782: PUSH
6783: LD_INT 5
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL_OW 69
6794: PUSH
6795: FOR_IN
6796: IFFALSE 6812
// SetSide ( i , 2 ) ;
6798: LD_VAR 0 1
6802: PPUSH
6803: LD_INT 2
6805: PPUSH
6806: CALL_OW 235
6810: GO 6795
6812: POP
6813: POP
// end ; end ;
6814: PPOPN 2
6816: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and not aviradzeSpotted do
6817: LD_EXP 6
6821: NOT
6822: PUSH
6823: LD_EXP 19
6827: PPUSH
6828: LD_EXP 20
6832: PPUSH
6833: CALL_OW 74
6837: PPUSH
6838: LD_EXP 20
6842: PPUSH
6843: CALL_OW 296
6847: PUSH
6848: LD_INT 8
6850: LESS
6851: AND
6852: PUSH
6853: LD_INT 2
6855: PPUSH
6856: LD_EXP 19
6860: PPUSH
6861: LD_EXP 20
6865: PPUSH
6866: CALL_OW 74
6870: PPUSH
6871: CALL_OW 292
6875: AND
6876: PUSH
6877: LD_INT 22
6879: PUSH
6880: LD_INT 2
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: LD_INT 21
6889: PUSH
6890: LD_INT 1
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PPUSH
6901: CALL_OW 69
6905: PUSH
6906: LD_INT 1
6908: GREATER
6909: AND
6910: PUSH
6911: LD_EXP 4
6915: NOT
6916: AND
6917: IFFALSE 6961
6919: GO 6921
6921: DISABLE
// begin sciSpotted := true ;
6922: LD_ADDR_EXP 6
6926: PUSH
6927: LD_INT 1
6929: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
6930: LD_EXP 19
6934: PPUSH
6935: LD_EXP 20
6939: PPUSH
6940: CALL_OW 74
6944: PPUSH
6945: CALL_OW 87
// Say ( Heike , DH-1-sci ) ;
6949: LD_EXP 20
6953: PPUSH
6954: LD_STRING DH-1-sci
6956: PPUSH
6957: CALL_OW 88
// end ;
6961: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and aviradzeSpotted and not aviradzeQuestDone do
6962: LD_EXP 6
6966: NOT
6967: PUSH
6968: LD_EXP 19
6972: PPUSH
6973: LD_EXP 20
6977: PPUSH
6978: CALL_OW 74
6982: PPUSH
6983: LD_EXP 20
6987: PPUSH
6988: CALL_OW 296
6992: PUSH
6993: LD_INT 8
6995: LESS
6996: AND
6997: PUSH
6998: LD_INT 2
7000: PPUSH
7001: LD_EXP 19
7005: PPUSH
7006: LD_EXP 20
7010: PPUSH
7011: CALL_OW 74
7015: PPUSH
7016: CALL_OW 292
7020: AND
7021: PUSH
7022: LD_INT 22
7024: PUSH
7025: LD_INT 2
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: PUSH
7032: LD_INT 21
7034: PUSH
7035: LD_INT 1
7037: PUSH
7038: EMPTY
7039: LIST
7040: LIST
7041: PUSH
7042: EMPTY
7043: LIST
7044: LIST
7045: PPUSH
7046: CALL_OW 69
7050: PUSH
7051: LD_INT 1
7053: GREATER
7054: AND
7055: PUSH
7056: LD_EXP 4
7060: AND
7061: PUSH
7062: LD_EXP 7
7066: NOT
7067: AND
7068: IFFALSE 7130
7070: GO 7072
7072: DISABLE
// begin sciSpotted := true ;
7073: LD_ADDR_EXP 6
7077: PUSH
7078: LD_INT 1
7080: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7081: LD_EXP 19
7085: PPUSH
7086: LD_EXP 20
7090: PPUSH
7091: CALL_OW 74
7095: PPUSH
7096: CALL_OW 87
// Say ( Heike , DH-1-sci-a ) ;
7100: LD_EXP 20
7104: PPUSH
7105: LD_STRING DH-1-sci-a
7107: PPUSH
7108: CALL_OW 88
// if Mike then
7112: LD_EXP 22
7116: IFFALSE 7130
// Say ( Mike , DM-1-sci-a ) ;
7118: LD_EXP 22
7122: PPUSH
7123: LD_STRING DM-1-sci-a
7125: PPUSH
7126: CALL_OW 88
// end ;
7130: END
// every 0 0$1 trigger aviradzeSpotted and sciCounterKill >= 3 and not aviradzeQuestDone do
7131: LD_EXP 4
7135: PUSH
7136: LD_EXP 8
7140: PUSH
7141: LD_INT 3
7143: GREATEREQUAL
7144: AND
7145: PUSH
7146: LD_EXP 7
7150: NOT
7151: AND
7152: IFFALSE 7195
7154: GO 7156
7156: DISABLE
// begin aviradzeQuestDone := true ;
7157: LD_ADDR_EXP 7
7161: PUSH
7162: LD_INT 1
7164: ST_TO_ADDR
// Say ( Heike , DH-1-quest-done ) ;
7165: LD_EXP 20
7169: PPUSH
7170: LD_STRING DH-1-quest-done
7172: PPUSH
7173: CALL_OW 88
// if Givi then
7177: LD_EXP 21
7181: IFFALSE 7195
// Say ( Givi , DG-1-quest-done ) ;
7183: LD_EXP 21
7187: PPUSH
7188: LD_STRING DG-1-quest-done
7190: PPUSH
7191: CALL_OW 88
// end ;
7195: END
// every 0 0$1 trigger See ( 5 , Heike ) and GetDistUnits ( Heike , Aviradze ) < 6 and aviradzeQuestDone and not attackDeltaAllowed do var i ;
7196: LD_INT 5
7198: PPUSH
7199: LD_EXP 20
7203: PPUSH
7204: CALL_OW 292
7208: PUSH
7209: LD_EXP 20
7213: PPUSH
7214: LD_EXP 24
7218: PPUSH
7219: CALL_OW 296
7223: PUSH
7224: LD_INT 6
7226: LESS
7227: AND
7228: PUSH
7229: LD_EXP 7
7233: AND
7234: PUSH
7235: LD_EXP 12
7239: NOT
7240: AND
7241: IFFALSE 7379
7243: GO 7245
7245: DISABLE
7246: LD_INT 0
7248: PPUSH
// begin attackDeltaAllowed := true ;
7249: LD_ADDR_EXP 12
7253: PUSH
7254: LD_INT 1
7256: ST_TO_ADDR
// InGameOn ;
7257: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
7261: LD_EXP 20
7265: PPUSH
7266: CALL_OW 87
// wait ( 0 0$0.3 ) ;
7270: LD_INT 10
7272: PPUSH
7273: CALL_OW 67
// ComTurnUnit ( Aviradze , Heike ) ;
7277: LD_EXP 24
7281: PPUSH
7282: LD_EXP 20
7286: PPUSH
7287: CALL_OW 119
// ComTurnUnit ( Heike , Aviradze ) ;
7291: LD_EXP 20
7295: PPUSH
7296: LD_EXP 24
7300: PPUSH
7301: CALL_OW 119
// Say ( Heike , DH-1-return ) ;
7305: LD_EXP 20
7309: PPUSH
7310: LD_STRING DH-1-return
7312: PPUSH
7313: CALL_OW 88
// Say ( Aviradze , DA-1-return ) ;
7317: LD_EXP 24
7321: PPUSH
7322: LD_STRING DA-1-return
7324: PPUSH
7325: CALL_OW 88
// InGameOff ;
7329: CALL_OW 9
// ChangeMissionObjectives ( ODelta ) ;
7333: LD_STRING ODelta
7335: PPUSH
7336: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7340: LD_ADDR_VAR 0 1
7344: PUSH
7345: LD_INT 22
7347: PUSH
7348: LD_INT 5
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PPUSH
7355: CALL_OW 69
7359: PUSH
7360: FOR_IN
7361: IFFALSE 7377
// SetSide ( i , 2 ) ;
7363: LD_VAR 0 1
7367: PPUSH
7368: LD_INT 2
7370: PPUSH
7371: CALL_OW 235
7375: GO 7360
7377: POP
7378: POP
// end ;
7379: PPOPN 1
7381: END
// every 0 0$1 trigger attackDeltaAllowed and IsOk ( Markov ) and GetSide ( Delta ) = 1 and IsOk ( Lynch ) and not usAlert do var i , k , tmp ;
7382: LD_EXP 12
7386: PUSH
7387: LD_EXP 27
7391: PPUSH
7392: CALL_OW 302
7396: AND
7397: PUSH
7398: LD_INT 1
7400: PPUSH
7401: CALL_OW 255
7405: PUSH
7406: LD_INT 1
7408: EQUAL
7409: AND
7410: PUSH
7411: LD_EXP 17
7415: PPUSH
7416: CALL_OW 302
7420: AND
7421: PUSH
7422: LD_EXP 9
7426: NOT
7427: AND
7428: IFFALSE 8598
7430: GO 7432
7432: DISABLE
7433: LD_INT 0
7435: PPUSH
7436: PPUSH
7437: PPUSH
// begin trap := 0 ;
7438: LD_ADDR_EXP 15
7442: PUSH
7443: LD_INT 0
7445: ST_TO_ADDR
// wait ( 0 0$15 ) ;
7446: LD_INT 525
7448: PPUSH
7449: CALL_OW 67
// DialogueOn ;
7453: CALL_OW 6
// Say ( Markov , DMar-1-radio ) ;
7457: LD_EXP 27
7461: PPUSH
7462: LD_STRING DMar-1-radio
7464: PPUSH
7465: CALL_OW 88
// Say ( Heike , DH-1-radio ) ;
7469: LD_EXP 20
7473: PPUSH
7474: LD_STRING DH-1-radio
7476: PPUSH
7477: CALL_OW 88
// Say ( Markov , DMar-2-radio ) ;
7481: LD_EXP 27
7485: PPUSH
7486: LD_STRING DMar-2-radio
7488: PPUSH
7489: CALL_OW 88
// Say ( Heike , DH-2-radio ) ;
7493: LD_EXP 20
7497: PPUSH
7498: LD_STRING DH-2-radio
7500: PPUSH
7501: CALL_OW 88
// if IsOk ( Kamil ) or IsOk ( Sophia ) then
7505: LD_EXP 23
7509: PPUSH
7510: CALL_OW 302
7514: PUSH
7515: LD_EXP 26
7519: PPUSH
7520: CALL_OW 302
7524: OR
7525: IFFALSE 8598
// begin case Query ( Q1Trap ) of 1 :
7527: LD_STRING Q1Trap
7529: PPUSH
7530: CALL_OW 97
7534: PUSH
7535: LD_INT 1
7537: DOUBLE
7538: EQUAL
7539: IFTRUE 7543
7541: GO 7737
7543: POP
// begin if IsOk ( Kamil ) then
7544: LD_EXP 23
7548: PPUSH
7549: CALL_OW 302
7553: IFFALSE 7632
// begin Say ( Kamil , DKam-2-radio ) ;
7555: LD_EXP 23
7559: PPUSH
7560: LD_STRING DKam-2-radio
7562: PPUSH
7563: CALL_OW 88
// Say ( Kamil , DKam-3-radio ) ;
7567: LD_EXP 23
7571: PPUSH
7572: LD_STRING DKam-3-radio
7574: PPUSH
7575: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio ) ;
7579: LD_EXP 17
7583: PPUSH
7584: LD_STRING DDelta-3-radio
7586: PPUSH
7587: CALL_OW 94
// dwait ( 0 0$01 ) ;
7591: LD_INT 35
7593: PPUSH
7594: CALL_OW 68
// Say ( Heike , DH-3-radio ) ;
7598: LD_EXP 20
7602: PPUSH
7603: LD_STRING DH-3-radio
7605: PPUSH
7606: CALL_OW 88
// Say ( Kamil , DKam-4-radio ) ;
7610: LD_EXP 23
7614: PPUSH
7615: LD_STRING DKam-4-radio
7617: PPUSH
7618: CALL_OW 88
// trap := 1 ;
7622: LD_ADDR_EXP 15
7626: PUSH
7627: LD_INT 1
7629: ST_TO_ADDR
// end else
7630: GO 7731
// begin Say ( Sophia , DS-1-radio ) ;
7632: LD_EXP 26
7636: PPUSH
7637: LD_STRING DS-1-radio
7639: PPUSH
7640: CALL_OW 88
// Say ( Sophia , DS-2-radio ) ;
7644: LD_EXP 26
7648: PPUSH
7649: LD_STRING DS-2-radio
7651: PPUSH
7652: CALL_OW 88
// SayRadio ( Lynch , DDelta-2-radio-s ) ;
7656: LD_EXP 17
7660: PPUSH
7661: LD_STRING DDelta-2-radio-s
7663: PPUSH
7664: CALL_OW 94
// Say ( Sophia , DS-3-radio ) ;
7668: LD_EXP 26
7672: PPUSH
7673: LD_STRING DS-3-radio
7675: PPUSH
7676: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio-s ) ;
7680: LD_EXP 17
7684: PPUSH
7685: LD_STRING DDelta-3-radio-s
7687: PPUSH
7688: CALL_OW 94
// Say ( Sophia , DS-4-radio-s ) ;
7692: LD_EXP 26
7696: PPUSH
7697: LD_STRING DS-4-radio-s
7699: PPUSH
7700: CALL_OW 88
// dwait ( 0 0$01 ) ;
7704: LD_INT 35
7706: PPUSH
7707: CALL_OW 68
// Say ( Heike , DH-1-trap ) ;
7711: LD_EXP 20
7715: PPUSH
7716: LD_STRING DH-1-trap
7718: PPUSH
7719: CALL_OW 88
// trap := 0 ;
7723: LD_ADDR_EXP 15
7727: PUSH
7728: LD_INT 0
7730: ST_TO_ADDR
// end ; DialogueOff ;
7731: CALL_OW 7
// end ; 2 :
7735: GO 7755
7737: LD_INT 2
7739: DOUBLE
7740: EQUAL
7741: IFTRUE 7745
7743: GO 7754
7745: POP
// begin DialogueOff ;
7746: CALL_OW 7
// exit ;
7750: GO 8598
// end ; end ;
7752: GO 7755
7754: POP
// if trap = 1 then
7755: LD_EXP 15
7759: PUSH
7760: LD_INT 1
7762: EQUAL
7763: IFFALSE 8169
// begin tmp := [ ] ;
7765: LD_ADDR_VAR 0 3
7769: PUSH
7770: EMPTY
7771: ST_TO_ADDR
// k := 3 ;
7772: LD_ADDR_VAR 0 2
7776: PUSH
7777: LD_INT 3
7779: ST_TO_ADDR
// if usForces < 3 then
7780: LD_EXP 18
7784: PUSH
7785: LD_INT 3
7787: LESS
7788: IFFALSE 7800
// k := usForces ;
7790: LD_ADDR_VAR 0 2
7794: PUSH
7795: LD_EXP 18
7799: ST_TO_ADDR
// for i := 1 to k do
7800: LD_ADDR_VAR 0 1
7804: PUSH
7805: DOUBLE
7806: LD_INT 1
7808: DEC
7809: ST_TO_ADDR
7810: LD_VAR 0 2
7814: PUSH
7815: FOR_TO
7816: IFFALSE 7871
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
7818: LD_ADDR_VAR 0 3
7822: PUSH
7823: LD_VAR 0 3
7827: PPUSH
7828: LD_VAR 0 3
7832: PUSH
7833: LD_INT 1
7835: PLUS
7836: PPUSH
7837: LD_EXP 18
7841: PUSH
7842: LD_INT 1
7844: ARRAY
7845: PPUSH
7846: CALL_OW 1
7850: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
7851: LD_ADDR_EXP 18
7855: PUSH
7856: LD_EXP 18
7860: PPUSH
7861: LD_INT 1
7863: PPUSH
7864: CALL_OW 3
7868: ST_TO_ADDR
// end ;
7869: GO 7815
7871: POP
7872: POP
// usPatrol := tmp ;
7873: LD_ADDR_EXP 14
7877: PUSH
7878: LD_VAR 0 3
7882: ST_TO_ADDR
// for i in tmp do
7883: LD_ADDR_VAR 0 1
7887: PUSH
7888: LD_VAR 0 3
7892: PUSH
7893: FOR_IN
7894: IFFALSE 8024
// begin if IsInUnit ( i ) then
7896: LD_VAR 0 1
7900: PPUSH
7901: CALL_OW 310
7905: IFFALSE 7916
// ComExitBuilding ( i ) ;
7907: LD_VAR 0 1
7911: PPUSH
7912: CALL_OW 122
// AddComAgressiveMove ( i , 63 , 31 ) ;
7916: LD_VAR 0 1
7920: PPUSH
7921: LD_INT 63
7923: PPUSH
7924: LD_INT 31
7926: PPUSH
7927: CALL_OW 174
// AddComWait ( i , 0 0$2 ) ;
7931: LD_VAR 0 1
7935: PPUSH
7936: LD_INT 70
7938: PPUSH
7939: CALL_OW 202
// AddComAgressiveMove ( i , 103 , 43 ) ;
7943: LD_VAR 0 1
7947: PPUSH
7948: LD_INT 103
7950: PPUSH
7951: LD_INT 43
7953: PPUSH
7954: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
7958: LD_VAR 0 1
7962: PPUSH
7963: LD_INT 105
7965: PPUSH
7966: CALL_OW 202
// if Difficulty > 1 then
7970: LD_OWVAR 67
7974: PUSH
7975: LD_INT 1
7977: GREATER
7978: IFFALSE 7995
// AddComAgressiveMove ( i , 114 , 69 ) ;
7980: LD_VAR 0 1
7984: PPUSH
7985: LD_INT 114
7987: PPUSH
7988: LD_INT 69
7990: PPUSH
7991: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
7995: LD_VAR 0 1
7999: PPUSH
8000: LD_INT 105
8002: PPUSH
8003: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8007: LD_VAR 0 1
8011: PPUSH
8012: LD_INT 42
8014: PPUSH
8015: LD_INT 20
8017: PPUSH
8018: CALL_OW 174
// end ;
8022: GO 7893
8024: POP
8025: POP
// repeat wait ( 0 0$1 ) ;
8026: LD_INT 35
8028: PPUSH
8029: CALL_OW 67
// for i in tmp do
8033: LD_ADDR_VAR 0 1
8037: PUSH
8038: LD_VAR 0 3
8042: PUSH
8043: FOR_IN
8044: IFFALSE 8075
// if IsDead ( i ) then
8046: LD_VAR 0 1
8050: PPUSH
8051: CALL_OW 301
8055: IFFALSE 8073
// tmp := tmp diff i ;
8057: LD_ADDR_VAR 0 3
8061: PUSH
8062: LD_VAR 0 3
8066: PUSH
8067: LD_VAR 0 1
8071: DIFF
8072: ST_TO_ADDR
8073: GO 8043
8075: POP
8076: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8077: LD_VAR 0 3
8081: NOT
8082: PUSH
8083: LD_VAR 0 3
8087: PPUSH
8088: LD_INT 95
8090: PUSH
8091: LD_INT 7
8093: PUSH
8094: EMPTY
8095: LIST
8096: LIST
8097: PUSH
8098: LD_INT 3
8100: PUSH
8101: LD_INT 60
8103: PUSH
8104: EMPTY
8105: LIST
8106: PUSH
8107: EMPTY
8108: LIST
8109: LIST
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: PPUSH
8115: CALL_OW 72
8119: PUSH
8120: LD_VAR 0 3
8124: EQUAL
8125: OR
8126: IFFALSE 8026
// if tmp then
8128: LD_VAR 0 3
8132: IFFALSE 8159
// begin usPatrol := [ ] ;
8134: LD_ADDR_EXP 14
8138: PUSH
8139: EMPTY
8140: ST_TO_ADDR
// usForces := usForces union tmp ;
8141: LD_ADDR_EXP 18
8145: PUSH
8146: LD_EXP 18
8150: PUSH
8151: LD_VAR 0 3
8155: UNION
8156: ST_TO_ADDR
// end else
8157: GO 8167
// trickyMove := true ;
8159: LD_ADDR_EXP 13
8163: PUSH
8164: LD_INT 1
8166: ST_TO_ADDR
// end else
8167: GO 8598
// begin tmp := [ ] ;
8169: LD_ADDR_VAR 0 3
8173: PUSH
8174: EMPTY
8175: ST_TO_ADDR
// k := 4 ;
8176: LD_ADDR_VAR 0 2
8180: PUSH
8181: LD_INT 4
8183: ST_TO_ADDR
// if usForces < 4 then
8184: LD_EXP 18
8188: PUSH
8189: LD_INT 4
8191: LESS
8192: IFFALSE 8204
// k := usForces ;
8194: LD_ADDR_VAR 0 2
8198: PUSH
8199: LD_EXP 18
8203: ST_TO_ADDR
// for i := 1 to k do
8204: LD_ADDR_VAR 0 1
8208: PUSH
8209: DOUBLE
8210: LD_INT 1
8212: DEC
8213: ST_TO_ADDR
8214: LD_VAR 0 2
8218: PUSH
8219: FOR_TO
8220: IFFALSE 8275
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8222: LD_ADDR_VAR 0 3
8226: PUSH
8227: LD_VAR 0 3
8231: PPUSH
8232: LD_VAR 0 3
8236: PUSH
8237: LD_INT 1
8239: PLUS
8240: PPUSH
8241: LD_EXP 18
8245: PUSH
8246: LD_INT 1
8248: ARRAY
8249: PPUSH
8250: CALL_OW 1
8254: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8255: LD_ADDR_EXP 18
8259: PUSH
8260: LD_EXP 18
8264: PPUSH
8265: LD_INT 1
8267: PPUSH
8268: CALL_OW 3
8272: ST_TO_ADDR
// end ;
8273: GO 8219
8275: POP
8276: POP
// if Lynch then
8277: LD_EXP 17
8281: IFFALSE 8299
// tmp := tmp ^ Lynch ;
8283: LD_ADDR_VAR 0 3
8287: PUSH
8288: LD_VAR 0 3
8292: PUSH
8293: LD_EXP 17
8297: ADD
8298: ST_TO_ADDR
// usPatrol := tmp ;
8299: LD_ADDR_EXP 14
8303: PUSH
8304: LD_VAR 0 3
8308: ST_TO_ADDR
// for i in tmp do
8309: LD_ADDR_VAR 0 1
8313: PUSH
8314: LD_VAR 0 3
8318: PUSH
8319: FOR_IN
8320: IFFALSE 8413
// begin if IsInUnit ( i ) then
8322: LD_VAR 0 1
8326: PPUSH
8327: CALL_OW 310
8331: IFFALSE 8342
// ComExitBuilding ( i ) ;
8333: LD_VAR 0 1
8337: PPUSH
8338: CALL_OW 122
// AddComAgressiveMove ( i , 69 , 15 ) ;
8342: LD_VAR 0 1
8346: PPUSH
8347: LD_INT 69
8349: PPUSH
8350: LD_INT 15
8352: PPUSH
8353: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8357: LD_VAR 0 1
8361: PPUSH
8362: LD_INT 700
8364: PPUSH
8365: CALL_OW 202
// AddComAgressiveMove ( i , 55 , 43 ) ;
8369: LD_VAR 0 1
8373: PPUSH
8374: LD_INT 55
8376: PPUSH
8377: LD_INT 43
8379: PPUSH
8380: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8384: LD_VAR 0 1
8388: PPUSH
8389: LD_INT 700
8391: PPUSH
8392: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8396: LD_VAR 0 1
8400: PPUSH
8401: LD_INT 42
8403: PPUSH
8404: LD_INT 20
8406: PPUSH
8407: CALL_OW 174
// end ;
8411: GO 8319
8413: POP
8414: POP
// repeat wait ( 0 0$1 ) ;
8415: LD_INT 35
8417: PPUSH
8418: CALL_OW 67
// for i in tmp do
8422: LD_ADDR_VAR 0 1
8426: PUSH
8427: LD_VAR 0 3
8431: PUSH
8432: FOR_IN
8433: IFFALSE 8464
// if IsDead ( i ) then
8435: LD_VAR 0 1
8439: PPUSH
8440: CALL_OW 301
8444: IFFALSE 8462
// tmp := tmp diff i ;
8446: LD_ADDR_VAR 0 3
8450: PUSH
8451: LD_VAR 0 3
8455: PUSH
8456: LD_VAR 0 1
8460: DIFF
8461: ST_TO_ADDR
8462: GO 8432
8464: POP
8465: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8466: LD_VAR 0 3
8470: NOT
8471: PUSH
8472: LD_VAR 0 3
8476: PPUSH
8477: LD_INT 95
8479: PUSH
8480: LD_INT 7
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PUSH
8487: LD_INT 3
8489: PUSH
8490: LD_INT 60
8492: PUSH
8493: EMPTY
8494: LIST
8495: PUSH
8496: EMPTY
8497: LIST
8498: LIST
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: PPUSH
8504: CALL_OW 72
8508: PUSH
8509: LD_VAR 0 3
8513: EQUAL
8514: OR
8515: IFFALSE 8415
// if not tmp then
8517: LD_VAR 0 3
8521: NOT
8522: IFFALSE 8534
// trickyMove := true else
8524: LD_ADDR_EXP 13
8528: PUSH
8529: LD_INT 1
8531: ST_TO_ADDR
8532: GO 8541
// usPatrol := [ ] ;
8534: LD_ADDR_EXP 14
8538: PUSH
8539: EMPTY
8540: ST_TO_ADDR
// if tmp diff Lynch then
8541: LD_VAR 0 3
8545: PUSH
8546: LD_EXP 17
8550: DIFF
8551: IFFALSE 8575
// usForces := usForces union ( tmp diff Lynch ) ;
8553: LD_ADDR_EXP 18
8557: PUSH
8558: LD_EXP 18
8562: PUSH
8563: LD_VAR 0 3
8567: PUSH
8568: LD_EXP 17
8572: DIFF
8573: UNION
8574: ST_TO_ADDR
// if IsOk ( Lynch ) then
8575: LD_EXP 17
8579: PPUSH
8580: CALL_OW 302
8584: IFFALSE 8598
// ComEnterUnit ( Lynch , Delta ) ;
8586: LD_EXP 17
8590: PPUSH
8591: LD_INT 1
8593: PPUSH
8594: CALL_OW 120
// end ; end ; end ;
8598: PPOPN 3
8600: END
// every 0 0$1 trigger UnitFilter ( usPatrol , [ f_see , 2 ] ) do
8601: LD_EXP 14
8605: PPUSH
8606: LD_INT 101
8608: PUSH
8609: LD_INT 2
8611: PUSH
8612: EMPTY
8613: LIST
8614: LIST
8615: PPUSH
8616: CALL_OW 72
8620: IFFALSE 8753
8622: GO 8624
8624: DISABLE
// begin if not trap then
8625: LD_EXP 15
8629: NOT
8630: IFFALSE 8658
// begin Say ( Heike , DH-2-trap ) ;
8632: LD_EXP 20
8636: PPUSH
8637: LD_STRING DH-2-trap
8639: PPUSH
8640: CALL_OW 88
// Say ( Mike , DM-2-trap ) ;
8644: LD_EXP 22
8648: PPUSH
8649: LD_STRING DM-2-trap
8651: PPUSH
8652: CALL_OW 88
// end else
8656: GO 8670
// begin Say ( Heike , DH-1-trap-a ) ;
8658: LD_EXP 20
8662: PPUSH
8663: LD_STRING DH-1-trap-a
8665: PPUSH
8666: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
8670: LD_INT 35
8672: PPUSH
8673: CALL_OW 67
// until trickyMove ;
8677: LD_EXP 13
8681: IFFALSE 8670
// Say ( Heike , DH-3-trap ) ;
8683: LD_EXP 20
8687: PPUSH
8688: LD_STRING DH-3-trap
8690: PPUSH
8691: CALL_OW 88
// if IsOk ( Givi ) and IsOk ( Kaia ) then
8695: LD_EXP 21
8699: PPUSH
8700: CALL_OW 302
8704: PUSH
8705: LD_EXP 25
8709: PPUSH
8710: CALL_OW 302
8714: AND
8715: IFFALSE 8753
// begin Say ( Givi , DG-3-trap ) ;
8717: LD_EXP 21
8721: PPUSH
8722: LD_STRING DG-3-trap
8724: PPUSH
8725: CALL_OW 88
// Say ( Kaia , DK-3-trap ) ;
8729: LD_EXP 25
8733: PPUSH
8734: LD_STRING DK-3-trap
8736: PPUSH
8737: CALL_OW 88
// Say ( Givi , DG-4-trap ) ;
8741: LD_EXP 21
8745: PPUSH
8746: LD_STRING DG-4-trap
8748: PPUSH
8749: CALL_OW 88
// end ; end ;
8753: END
// every 0 0$1 trigger GetSide ( Delta ) = 2 do
8754: LD_INT 1
8756: PPUSH
8757: CALL_OW 255
8761: PUSH
8762: LD_INT 2
8764: EQUAL
8765: IFFALSE 8808
8767: GO 8769
8769: DISABLE
// begin if not IsOk ( Kaia ) then
8770: LD_EXP 25
8774: PPUSH
8775: CALL_OW 302
8779: NOT
8780: IFFALSE 8784
// exit ;
8782: GO 8808
// Say ( Kaia , DK-1-capture ) ;
8784: LD_EXP 25
8788: PPUSH
8789: LD_STRING DK-1-capture
8791: PPUSH
8792: CALL_OW 88
// Say ( Heike , DH-1-capture ) ;
8796: LD_EXP 20
8800: PPUSH
8801: LD_STRING DH-1-capture
8803: PPUSH
8804: CALL_OW 88
// end ;
8808: END
// every 0 0$1 trigger GetSide ( usLab ) = 2 do
8809: LD_INT 3
8811: PPUSH
8812: CALL_OW 255
8816: PUSH
8817: LD_INT 2
8819: EQUAL
8820: IFFALSE 8852
8822: GO 8824
8824: DISABLE
// begin DialogueOn ;
8825: CALL_OW 6
// Say ( Aviradze , DA-1-capture ) ;
8829: LD_EXP 24
8833: PPUSH
8834: LD_STRING DA-1-capture
8836: PPUSH
8837: CALL_OW 88
// DialogueOff ;
8841: CALL_OW 7
// ChangeMissionObjectives ( OTame ) ;
8845: LD_STRING OTame
8847: PPUSH
8848: CALL_OW 337
// end ;
8852: END
// every 0 0$1 trigger GetTech ( tech_ApeLang , 2 ) = state_researched do
8853: LD_INT 1
8855: PPUSH
8856: LD_INT 2
8858: PPUSH
8859: CALL_OW 321
8863: PUSH
8864: LD_INT 2
8866: EQUAL
8867: IFFALSE 8940
8869: GO 8871
8871: DISABLE
// begin DialogueOn ;
8872: CALL_OW 6
// Say ( Aviradze , DA-1-ape ) ;
8876: LD_EXP 24
8880: PPUSH
8881: LD_STRING DA-1-ape
8883: PPUSH
8884: CALL_OW 88
// Say ( Heike , DH-1-ape ) ;
8888: LD_EXP 20
8892: PPUSH
8893: LD_STRING DH-1-ape
8895: PPUSH
8896: CALL_OW 88
// Say ( Aviradze , DA-2-ape ) ;
8900: LD_EXP 24
8904: PPUSH
8905: LD_STRING DA-2-ape
8907: PPUSH
8908: CALL_OW 88
// Say ( Aviradze , DA-3-ape ) ;
8912: LD_EXP 24
8916: PPUSH
8917: LD_STRING DA-3-ape
8919: PPUSH
8920: CALL_OW 88
// Say ( Heike , DH-3-ape ) ;
8924: LD_EXP 20
8928: PPUSH
8929: LD_STRING DH-3-ape
8931: PPUSH
8932: CALL_OW 88
// DialogueOff ;
8936: CALL_OW 7
// end ;
8940: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) do var tmp ;
8941: LD_INT 22
8943: PUSH
8944: LD_INT 2
8946: PUSH
8947: EMPTY
8948: LIST
8949: LIST
8950: PUSH
8951: LD_INT 23
8953: PUSH
8954: LD_INT 0
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: EMPTY
8962: LIST
8963: LIST
8964: PPUSH
8965: CALL_OW 69
8969: IFFALSE 9445
8971: GO 8973
8973: DISABLE
8974: LD_INT 0
8976: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) [ 1 ] ;
8977: LD_ADDR_VAR 0 1
8981: PUSH
8982: LD_INT 22
8984: PUSH
8985: LD_INT 2
8987: PUSH
8988: EMPTY
8989: LIST
8990: LIST
8991: PUSH
8992: LD_INT 23
8994: PUSH
8995: LD_INT 0
8997: PUSH
8998: EMPTY
8999: LIST
9000: LIST
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: PPUSH
9006: CALL_OW 69
9010: PUSH
9011: LD_INT 1
9013: ARRAY
9014: ST_TO_ADDR
// InGameOn ;
9015: CALL_OW 8
// CenterNowOnUnits ( tmp ) ;
9019: LD_VAR 0 1
9023: PPUSH
9024: CALL_OW 87
// ComMoveUnit ( tmp , Aviradze ) ;
9028: LD_VAR 0 1
9032: PPUSH
9033: LD_EXP 24
9037: PPUSH
9038: CALL_OW 112
// ComTurnUnit ( Aviradze , tmp ) ;
9042: LD_EXP 24
9046: PPUSH
9047: LD_VAR 0 1
9051: PPUSH
9052: CALL_OW 119
// wait ( 0 0$1 ) ;
9056: LD_INT 35
9058: PPUSH
9059: CALL_OW 67
// Say ( Aviradze , DA-1-tame-a ) ;
9063: LD_EXP 24
9067: PPUSH
9068: LD_STRING DA-1-tame-a
9070: PPUSH
9071: CALL_OW 88
// if IsOk ( Mike ) then
9075: LD_EXP 22
9079: PPUSH
9080: CALL_OW 302
9084: IFFALSE 9122
// begin Say ( Mike , DM-1-tame-a ) ;
9086: LD_EXP 22
9090: PPUSH
9091: LD_STRING DM-1-tame-a
9093: PPUSH
9094: CALL_OW 88
// Say ( Sophia , DS-1-tame-a ) ;
9098: LD_EXP 26
9102: PPUSH
9103: LD_STRING DS-1-tame-a
9105: PPUSH
9106: CALL_OW 88
// Say ( Mike , DM-2-tame-a ) ;
9110: LD_EXP 22
9114: PPUSH
9115: LD_STRING DM-2-tame-a
9117: PPUSH
9118: CALL_OW 88
// end ; wait ( 0 0$3 ) ;
9122: LD_INT 105
9124: PPUSH
9125: CALL_OW 67
// PrepareFarmer ;
9129: CALL 10104 0 0
// CenterOnUnits ( Farmer ) ;
9133: LD_EXP 28
9137: PPUSH
9138: CALL_OW 85
// ComMoveXY ( Farmer , 105 , 59 ) ;
9142: LD_EXP 28
9146: PPUSH
9147: LD_INT 105
9149: PPUSH
9150: LD_INT 59
9152: PPUSH
9153: CALL_OW 111
// AddComHold ( Farmer ) ;
9157: LD_EXP 28
9161: PPUSH
9162: CALL_OW 200
// SayRadio ( Farmer , DF-1-end ) ;
9166: LD_EXP 28
9170: PPUSH
9171: LD_STRING DF-1-end
9173: PPUSH
9174: CALL_OW 94
// Say ( Aviradze , DA-1-end ) ;
9178: LD_EXP 24
9182: PPUSH
9183: LD_STRING DA-1-end
9185: PPUSH
9186: CALL_OW 88
// SayRadio ( Farmer , DF-2-end ) ;
9190: LD_EXP 28
9194: PPUSH
9195: LD_STRING DF-2-end
9197: PPUSH
9198: CALL_OW 94
// Say ( Aviradze , DA-2-end ) ;
9202: LD_EXP 24
9206: PPUSH
9207: LD_STRING DA-2-end
9209: PPUSH
9210: CALL_OW 88
// SayRadio ( Farmer , DF-3-end ) ;
9214: LD_EXP 28
9218: PPUSH
9219: LD_STRING DF-3-end
9221: PPUSH
9222: CALL_OW 94
// Say ( Heike , DH-3-end ) ;
9226: LD_EXP 20
9230: PPUSH
9231: LD_STRING DH-3-end
9233: PPUSH
9234: CALL_OW 88
// SayRadio ( Farmer , DF-4-end ) ;
9238: LD_EXP 28
9242: PPUSH
9243: LD_STRING DF-4-end
9245: PPUSH
9246: CALL_OW 94
// if tick <= [ 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] then
9250: LD_OWVAR 1
9254: PUSH
9255: LD_INT 42000
9257: PUSH
9258: LD_INT 31500
9260: PUSH
9261: LD_INT 21000
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: LIST
9268: PUSH
9269: LD_OWVAR 67
9273: ARRAY
9274: LESSEQUAL
9275: IFFALSE 9289
// AddMedal ( med1 , 1 ) else
9277: LD_STRING med1
9279: PPUSH
9280: LD_INT 1
9282: PPUSH
9283: CALL_OW 101
9287: GO 9300
// AddMedal ( med1 , - 1 ) ;
9289: LD_STRING med1
9291: PPUSH
9292: LD_INT 1
9294: NEG
9295: PPUSH
9296: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) = 0 then
9300: LD_INT 22
9302: PUSH
9303: LD_INT 1
9305: PUSH
9306: EMPTY
9307: LIST
9308: LIST
9309: PUSH
9310: LD_INT 25
9312: PUSH
9313: LD_INT 4
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: PUSH
9329: LD_INT 0
9331: EQUAL
9332: IFFALSE 9346
// AddMedal ( med2 , 1 ) else
9334: LD_STRING med2
9336: PPUSH
9337: LD_INT 1
9339: PPUSH
9340: CALL_OW 101
9344: GO 9357
// AddMedal ( med2 , - 1 ) ;
9346: LD_STRING med2
9348: PPUSH
9349: LD_INT 1
9351: NEG
9352: PPUSH
9353: CALL_OW 101
// if trickyMove then
9357: LD_EXP 13
9361: IFFALSE 9375
// AddMedal ( med3 , 1 ) else
9363: LD_STRING med3
9365: PPUSH
9366: LD_INT 1
9368: PPUSH
9369: CALL_OW 101
9373: GO 9386
// AddMedal ( med3 , - 1 ) ;
9375: LD_STRING med3
9377: PPUSH
9378: LD_INT 1
9380: NEG
9381: PPUSH
9382: CALL_OW 101
// GiveMedals ( MAIN ) ;
9386: LD_STRING MAIN
9388: PPUSH
9389: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ) ;
9393: LD_INT 22
9395: PUSH
9396: LD_INT 2
9398: PUSH
9399: EMPTY
9400: LIST
9401: LIST
9402: PUSH
9403: LD_INT 23
9405: PUSH
9406: LD_INT 2
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PUSH
9413: LD_INT 21
9415: PUSH
9416: LD_INT 1
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: LIST
9427: PPUSH
9428: CALL_OW 69
9432: PPUSH
9433: CALL_OW 43
// YouWin ;
9437: CALL_OW 103
// InGameOff ;
9441: CALL_OW 9
// end ;
9445: PPOPN 1
9447: END
// every 0 0$1 trigger tick > timeUntilFarmer and aviradzeSpotted do
9448: LD_OWVAR 1
9452: PUSH
9453: LD_EXP 11
9457: GREATER
9458: PUSH
9459: LD_EXP 4
9463: AND
9464: IFFALSE 9504
9466: GO 9468
9468: DISABLE
// begin InGameOn ;
9469: CALL_OW 8
// PrepareFarmer ;
9473: CALL 10104 0 0
// CenterNowOnUnits ( Farmer ) ;
9477: LD_EXP 28
9481: PPUSH
9482: CALL_OW 87
// wait ( 0 0$2 ) ;
9486: LD_INT 70
9488: PPUSH
9489: CALL_OW 67
// YouLost ( Farmer ) ;
9493: LD_STRING Farmer
9495: PPUSH
9496: CALL_OW 104
// InGameOff ;
9500: CALL_OW 9
// end ; end_of_file
9504: END
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer ; export function PrepareArabian ; var un , veh ; begin
9505: LD_INT 0
9507: PPUSH
9508: PPUSH
9509: PPUSH
// uc_side := 2 ;
9510: LD_ADDR_OWVAR 20
9514: PUSH
9515: LD_INT 2
9517: ST_TO_ADDR
// uc_nation := 2 ;
9518: LD_ADDR_OWVAR 21
9522: PUSH
9523: LD_INT 2
9525: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
9526: LD_ADDR_EXP 20
9530: PUSH
9531: LD_STRING Heike
9533: PPUSH
9534: LD_EXP 1
9538: NOT
9539: PPUSH
9540: LD_EXP 2
9544: PPUSH
9545: CALL 213 0 3
9549: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
9550: LD_EXP 20
9554: PPUSH
9555: LD_INT 83
9557: PPUSH
9558: LD_INT 72
9560: PPUSH
9561: LD_INT 0
9563: PPUSH
9564: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
9568: LD_ADDR_EXP 21
9572: PUSH
9573: LD_STRING Givi
9575: PPUSH
9576: LD_EXP 1
9580: NOT
9581: PPUSH
9582: LD_EXP 2
9586: PPUSH
9587: CALL 213 0 3
9591: ST_TO_ADDR
// if Givi then
9592: LD_EXP 21
9596: IFFALSE 9616
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
9598: LD_EXP 21
9602: PPUSH
9603: LD_INT 87
9605: PPUSH
9606: LD_INT 76
9608: PPUSH
9609: LD_INT 0
9611: PPUSH
9612: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
9616: LD_ADDR_EXP 22
9620: PUSH
9621: LD_STRING Mike
9623: PPUSH
9624: LD_EXP 1
9628: NOT
9629: PPUSH
9630: LD_EXP 2
9634: PPUSH
9635: CALL 213 0 3
9639: ST_TO_ADDR
// if Mike then
9640: LD_EXP 22
9644: IFFALSE 9664
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
9646: LD_EXP 22
9650: PPUSH
9651: LD_INT 84
9653: PPUSH
9654: LD_INT 76
9656: PPUSH
9657: LD_INT 0
9659: PPUSH
9660: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
9664: LD_ADDR_EXP 23
9668: PUSH
9669: LD_STRING Kamil
9671: PPUSH
9672: LD_EXP 1
9676: NOT
9677: PPUSH
9678: LD_EXP 2
9682: PPUSH
9683: CALL 213 0 3
9687: ST_TO_ADDR
// if Kamil then
9688: LD_EXP 23
9692: IFFALSE 9712
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
9694: LD_EXP 23
9698: PPUSH
9699: LD_INT 85
9701: PPUSH
9702: LD_INT 78
9704: PPUSH
9705: LD_INT 0
9707: PPUSH
9708: CALL_OW 48
// uc_side := 5 ;
9712: LD_ADDR_OWVAR 20
9716: PUSH
9717: LD_INT 5
9719: ST_TO_ADDR
// uc_nation := 2 ;
9720: LD_ADDR_OWVAR 21
9724: PUSH
9725: LD_INT 2
9727: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , false ,  ) ;
9728: LD_ADDR_EXP 24
9732: PUSH
9733: LD_STRING Aviradze
9735: PPUSH
9736: LD_INT 0
9738: PPUSH
9739: LD_STRING 
9741: PPUSH
9742: CALL 213 0 3
9746: ST_TO_ADDR
// PlaceUnitXY ( Aviradze , 106 , 38 , false ) ;
9747: LD_EXP 24
9751: PPUSH
9752: LD_INT 106
9754: PPUSH
9755: LD_INT 38
9757: PPUSH
9758: LD_INT 0
9760: PPUSH
9761: CALL_OW 48
// ComTurnXY ( Aviradze , 103 , 38 ) ;
9765: LD_EXP 24
9769: PPUSH
9770: LD_INT 103
9772: PPUSH
9773: LD_INT 38
9775: PPUSH
9776: CALL_OW 118
// Kaia := PrepareUnit ( Kaia , false ,  ) ;
9780: LD_ADDR_EXP 25
9784: PUSH
9785: LD_STRING Kaia
9787: PPUSH
9788: LD_INT 0
9790: PPUSH
9791: LD_STRING 
9793: PPUSH
9794: CALL 213 0 3
9798: ST_TO_ADDR
// PlaceUnitXY ( Kaia , 100 , 34 , false ) ;
9799: LD_EXP 25
9803: PPUSH
9804: LD_INT 100
9806: PPUSH
9807: LD_INT 34
9809: PPUSH
9810: LD_INT 0
9812: PPUSH
9813: CALL_OW 48
// ComTurnXY ( Kaia , 100 , 39 ) ;
9817: LD_EXP 25
9821: PPUSH
9822: LD_INT 100
9824: PPUSH
9825: LD_INT 39
9827: PPUSH
9828: CALL_OW 118
// Sophia := PrepareUnit ( Sophia , false ,  ) ;
9832: LD_ADDR_EXP 26
9836: PUSH
9837: LD_STRING Sophia
9839: PPUSH
9840: LD_INT 0
9842: PPUSH
9843: LD_STRING 
9845: PPUSH
9846: CALL 213 0 3
9850: ST_TO_ADDR
// PlaceUnitXY ( Sophia , 109 , 50 , false ) ;
9851: LD_EXP 26
9855: PPUSH
9856: LD_INT 109
9858: PPUSH
9859: LD_INT 50
9861: PPUSH
9862: LD_INT 0
9864: PPUSH
9865: CALL_OW 48
// ComTurnXY ( Sophia , 100 , 39 ) ;
9869: LD_EXP 26
9873: PPUSH
9874: LD_INT 100
9876: PPUSH
9877: LD_INT 39
9879: PPUSH
9880: CALL_OW 118
// Markov := PrepareUnit ( Markov , false ,  ) ;
9884: LD_ADDR_EXP 27
9888: PUSH
9889: LD_STRING Markov
9891: PPUSH
9892: LD_INT 0
9894: PPUSH
9895: LD_STRING 
9897: PPUSH
9898: CALL 213 0 3
9902: ST_TO_ADDR
// PrepareTank ( 5 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , [ 90 , 70 , 60 ] [ Difficulty ] ) ;
9903: LD_INT 5
9905: PPUSH
9906: LD_INT 3
9908: PPUSH
9909: LD_INT 21
9911: PPUSH
9912: LD_INT 1
9914: PPUSH
9915: LD_INT 1
9917: PPUSH
9918: LD_INT 42
9920: PPUSH
9921: LD_INT 90
9923: PUSH
9924: LD_INT 70
9926: PUSH
9927: LD_INT 60
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: LIST
9934: PUSH
9935: LD_OWVAR 67
9939: ARRAY
9940: PPUSH
9941: CALL 276 0 7
// veh := CreateVehicle ;
9945: LD_ADDR_VAR 0 3
9949: PUSH
9950: CALL_OW 45
9954: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
9955: LD_VAR 0 3
9959: PPUSH
9960: LD_INT 4
9962: PPUSH
9963: CALL_OW 233
// PlaceUnitXY ( veh , 109 , 38 , false ) ;
9967: LD_VAR 0 3
9971: PPUSH
9972: LD_INT 109
9974: PPUSH
9975: LD_INT 38
9977: PPUSH
9978: LD_INT 0
9980: PPUSH
9981: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
9985: LD_EXP 27
9989: PPUSH
9990: LD_VAR 0 3
9994: PPUSH
9995: CALL_OW 52
// ComTurnUnit ( Kaia , Aviradze ) ;
9999: LD_EXP 25
10003: PPUSH
10004: LD_EXP 24
10008: PPUSH
10009: CALL_OW 119
// ComTurnUnit ( Aviradze , Kaia ) ;
10013: LD_EXP 24
10017: PPUSH
10018: LD_EXP 25
10022: PPUSH
10023: CALL_OW 119
// if not Givi or not Mike then
10027: LD_EXP 21
10031: NOT
10032: PUSH
10033: LD_EXP 22
10037: NOT
10038: OR
10039: IFFALSE 10099
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10041: LD_INT 1
10043: PPUSH
10044: LD_INT 1
10046: PPUSH
10047: LD_INT 1
10049: PPUSH
10050: CALL_OW 380
// un := CreateHuman ;
10054: LD_ADDR_VAR 0 2
10058: PUSH
10059: CALL_OW 44
10063: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 40 , 3 , false ) ;
10064: LD_VAR 0 2
10068: PPUSH
10069: LD_INT 112
10071: PPUSH
10072: LD_INT 40
10074: PPUSH
10075: LD_INT 3
10077: PPUSH
10078: LD_INT 0
10080: PPUSH
10081: CALL_OW 50
// ComTurnUnit ( un , Aviradze ) ;
10085: LD_VAR 0 2
10089: PPUSH
10090: LD_EXP 24
10094: PPUSH
10095: CALL_OW 119
// end ; end ;
10099: LD_VAR 0 1
10103: RET
// export function PrepareFarmer ; var i ; begin
10104: LD_INT 0
10106: PPUSH
10107: PPUSH
// uc_side := 5 ;
10108: LD_ADDR_OWVAR 20
10112: PUSH
10113: LD_INT 5
10115: ST_TO_ADDR
// uc_nation := 2 ;
10116: LD_ADDR_OWVAR 21
10120: PUSH
10121: LD_INT 2
10123: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
10124: LD_ADDR_EXP 28
10128: PUSH
10129: LD_STRING Farmer
10131: PPUSH
10132: LD_INT 0
10134: PPUSH
10135: LD_STRING 
10137: PPUSH
10138: CALL 213 0 3
10142: ST_TO_ADDR
// PlaceUnitXY ( Farmer , 106 , 62 , false ) ;
10143: LD_EXP 28
10147: PPUSH
10148: LD_INT 106
10150: PPUSH
10151: LD_INT 62
10153: PPUSH
10154: LD_INT 0
10156: PPUSH
10157: CALL_OW 48
// for i := 1 to 2 do
10161: LD_ADDR_VAR 0 2
10165: PUSH
10166: DOUBLE
10167: LD_INT 1
10169: DEC
10170: ST_TO_ADDR
10171: LD_INT 2
10173: PUSH
10174: FOR_TO
10175: IFFALSE 10213
// begin PrepareHuman ( false , 1 , 1 ) ;
10177: LD_INT 0
10179: PPUSH
10180: LD_INT 1
10182: PPUSH
10183: LD_INT 1
10185: PPUSH
10186: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 105 , 64 , 2 , false ) ;
10190: CALL_OW 44
10194: PPUSH
10195: LD_INT 105
10197: PPUSH
10198: LD_INT 64
10200: PPUSH
10201: LD_INT 2
10203: PPUSH
10204: LD_INT 0
10206: PPUSH
10207: CALL_OW 50
// end ;
10211: GO 10174
10213: POP
10214: POP
// end ; end_of_file
10215: LD_VAR 0 1
10219: RET
// every 2 2$20 + 0 0$10 do
10220: GO 10222
10222: DISABLE
// begin enable ;
10223: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , forest , true ) ;
10224: LD_INT 1
10226: PPUSH
10227: LD_INT 5
10229: PPUSH
10230: CALL_OW 12
10234: PPUSH
10235: LD_INT 1
10237: PPUSH
10238: LD_INT 1
10240: PPUSH
10241: CALL_OW 55
// end ; end_of_file
10245: END
// on UnitDestroyed ( un ) do begin if un = Heike then
10246: LD_VAR 0 1
10250: PUSH
10251: LD_EXP 20
10255: EQUAL
10256: IFFALSE 10265
// YouLost ( Heike ) ;
10258: LD_STRING Heike
10260: PPUSH
10261: CALL_OW 104
// if un = Aviradze then
10265: LD_VAR 0 1
10269: PUSH
10270: LD_EXP 24
10274: EQUAL
10275: IFFALSE 10284
// YouLost ( Aviradze ) ;
10277: LD_STRING Aviradze
10279: PPUSH
10280: CALL_OW 104
// if un = usLab then
10284: LD_VAR 0 1
10288: PUSH
10289: LD_INT 3
10291: EQUAL
10292: IFFALSE 10301
// YouLost ( Lab ) ;
10294: LD_STRING Lab
10296: PPUSH
10297: CALL_OW 104
// end ;
10301: PPOPN 1
10303: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un in usSci and killerSide = 2 then
10304: LD_VAR 0 1
10308: PUSH
10309: LD_EXP 19
10313: IN
10314: PUSH
10315: LD_VAR 0 2
10319: PUSH
10320: LD_INT 2
10322: EQUAL
10323: AND
10324: IFFALSE 10340
// sciCounterKill := sciCounterKill + 1 ;
10326: LD_ADDR_EXP 8
10330: PUSH
10331: LD_EXP 8
10335: PUSH
10336: LD_INT 1
10338: PLUS
10339: ST_TO_ADDR
// end ;
10340: PPOPN 3
10342: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
10343: LD_VAR 0 1
10347: PUSH
10348: LD_INT 2
10350: EQUAL
10351: PUSH
10352: LD_VAR 0 2
10356: PUSH
10357: LD_INT 5
10359: EQUAL
10360: AND
10361: IFFALSE 10370
// YouLost ( FriendlyFire ) ;
10363: LD_STRING FriendlyFire
10365: PPUSH
10366: CALL_OW 104
// end ; end_of_file
10370: PPOPN 2
10372: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10373: GO 10375
10375: DISABLE
// begin ru_radar := 98 ;
10376: LD_ADDR_EXP 29
10380: PUSH
10381: LD_INT 98
10383: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10384: LD_ADDR_EXP 30
10388: PUSH
10389: LD_INT 89
10391: ST_TO_ADDR
// us_hack := 99 ;
10392: LD_ADDR_EXP 31
10396: PUSH
10397: LD_INT 99
10399: ST_TO_ADDR
// us_artillery := 97 ;
10400: LD_ADDR_EXP 32
10404: PUSH
10405: LD_INT 97
10407: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10408: LD_ADDR_EXP 33
10412: PUSH
10413: LD_INT 91
10415: ST_TO_ADDR
// end ; end_of_file end_of_file
10416: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
10417: GO 10419
10419: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
10420: LD_STRING initStreamRollete();
10422: PPUSH
10423: CALL_OW 559
// InitStreamMode ;
10427: CALL 10436 0 0
// DefineStreamItems ( ) ;
10431: CALL 10876 0 0
// end ;
10435: END
// function InitStreamMode ; begin
10436: LD_INT 0
10438: PPUSH
// streamModeActive := false ;
10439: LD_ADDR_EXP 34
10443: PUSH
10444: LD_INT 0
10446: ST_TO_ADDR
// normalCounter := 36 ;
10447: LD_ADDR_EXP 35
10451: PUSH
10452: LD_INT 36
10454: ST_TO_ADDR
// hardcoreCounter := 16 ;
10455: LD_ADDR_EXP 36
10459: PUSH
10460: LD_INT 16
10462: ST_TO_ADDR
// sRocket := false ;
10463: LD_ADDR_EXP 39
10467: PUSH
10468: LD_INT 0
10470: ST_TO_ADDR
// sSpeed := false ;
10471: LD_ADDR_EXP 38
10475: PUSH
10476: LD_INT 0
10478: ST_TO_ADDR
// sEngine := false ;
10479: LD_ADDR_EXP 40
10483: PUSH
10484: LD_INT 0
10486: ST_TO_ADDR
// sSpec := false ;
10487: LD_ADDR_EXP 37
10491: PUSH
10492: LD_INT 0
10494: ST_TO_ADDR
// sLevel := false ;
10495: LD_ADDR_EXP 41
10499: PUSH
10500: LD_INT 0
10502: ST_TO_ADDR
// sArmoury := false ;
10503: LD_ADDR_EXP 42
10507: PUSH
10508: LD_INT 0
10510: ST_TO_ADDR
// sRadar := false ;
10511: LD_ADDR_EXP 43
10515: PUSH
10516: LD_INT 0
10518: ST_TO_ADDR
// sBunker := false ;
10519: LD_ADDR_EXP 44
10523: PUSH
10524: LD_INT 0
10526: ST_TO_ADDR
// sHack := false ;
10527: LD_ADDR_EXP 45
10531: PUSH
10532: LD_INT 0
10534: ST_TO_ADDR
// sFire := false ;
10535: LD_ADDR_EXP 46
10539: PUSH
10540: LD_INT 0
10542: ST_TO_ADDR
// sRefresh := false ;
10543: LD_ADDR_EXP 47
10547: PUSH
10548: LD_INT 0
10550: ST_TO_ADDR
// sExp := false ;
10551: LD_ADDR_EXP 48
10555: PUSH
10556: LD_INT 0
10558: ST_TO_ADDR
// sDepot := false ;
10559: LD_ADDR_EXP 49
10563: PUSH
10564: LD_INT 0
10566: ST_TO_ADDR
// sFlag := false ;
10567: LD_ADDR_EXP 50
10571: PUSH
10572: LD_INT 0
10574: ST_TO_ADDR
// sKamikadze := false ;
10575: LD_ADDR_EXP 58
10579: PUSH
10580: LD_INT 0
10582: ST_TO_ADDR
// sTroll := false ;
10583: LD_ADDR_EXP 59
10587: PUSH
10588: LD_INT 0
10590: ST_TO_ADDR
// sSlow := false ;
10591: LD_ADDR_EXP 60
10595: PUSH
10596: LD_INT 0
10598: ST_TO_ADDR
// sLack := false ;
10599: LD_ADDR_EXP 61
10603: PUSH
10604: LD_INT 0
10606: ST_TO_ADDR
// sTank := false ;
10607: LD_ADDR_EXP 63
10611: PUSH
10612: LD_INT 0
10614: ST_TO_ADDR
// sRemote := false ;
10615: LD_ADDR_EXP 64
10619: PUSH
10620: LD_INT 0
10622: ST_TO_ADDR
// sPowell := false ;
10623: LD_ADDR_EXP 65
10627: PUSH
10628: LD_INT 0
10630: ST_TO_ADDR
// sTeleport := false ;
10631: LD_ADDR_EXP 68
10635: PUSH
10636: LD_INT 0
10638: ST_TO_ADDR
// sOilTower := false ;
10639: LD_ADDR_EXP 70
10643: PUSH
10644: LD_INT 0
10646: ST_TO_ADDR
// sShovel := false ;
10647: LD_ADDR_EXP 71
10651: PUSH
10652: LD_INT 0
10654: ST_TO_ADDR
// sSheik := false ;
10655: LD_ADDR_EXP 72
10659: PUSH
10660: LD_INT 0
10662: ST_TO_ADDR
// sEarthquake := false ;
10663: LD_ADDR_EXP 74
10667: PUSH
10668: LD_INT 0
10670: ST_TO_ADDR
// sAI := false ;
10671: LD_ADDR_EXP 75
10675: PUSH
10676: LD_INT 0
10678: ST_TO_ADDR
// sCargo := false ;
10679: LD_ADDR_EXP 78
10683: PUSH
10684: LD_INT 0
10686: ST_TO_ADDR
// sDLaser := false ;
10687: LD_ADDR_EXP 79
10691: PUSH
10692: LD_INT 0
10694: ST_TO_ADDR
// sExchange := false ;
10695: LD_ADDR_EXP 80
10699: PUSH
10700: LD_INT 0
10702: ST_TO_ADDR
// sFac := false ;
10703: LD_ADDR_EXP 81
10707: PUSH
10708: LD_INT 0
10710: ST_TO_ADDR
// sPower := false ;
10711: LD_ADDR_EXP 82
10715: PUSH
10716: LD_INT 0
10718: ST_TO_ADDR
// sRandom := false ;
10719: LD_ADDR_EXP 83
10723: PUSH
10724: LD_INT 0
10726: ST_TO_ADDR
// sShield := false ;
10727: LD_ADDR_EXP 84
10731: PUSH
10732: LD_INT 0
10734: ST_TO_ADDR
// sTime := false ;
10735: LD_ADDR_EXP 85
10739: PUSH
10740: LD_INT 0
10742: ST_TO_ADDR
// sTools := false ;
10743: LD_ADDR_EXP 86
10747: PUSH
10748: LD_INT 0
10750: ST_TO_ADDR
// sSold := false ;
10751: LD_ADDR_EXP 51
10755: PUSH
10756: LD_INT 0
10758: ST_TO_ADDR
// sDiff := false ;
10759: LD_ADDR_EXP 52
10763: PUSH
10764: LD_INT 0
10766: ST_TO_ADDR
// sFog := false ;
10767: LD_ADDR_EXP 55
10771: PUSH
10772: LD_INT 0
10774: ST_TO_ADDR
// sReset := false ;
10775: LD_ADDR_EXP 56
10779: PUSH
10780: LD_INT 0
10782: ST_TO_ADDR
// sSun := false ;
10783: LD_ADDR_EXP 57
10787: PUSH
10788: LD_INT 0
10790: ST_TO_ADDR
// sTiger := false ;
10791: LD_ADDR_EXP 53
10795: PUSH
10796: LD_INT 0
10798: ST_TO_ADDR
// sBomb := false ;
10799: LD_ADDR_EXP 54
10803: PUSH
10804: LD_INT 0
10806: ST_TO_ADDR
// sWound := false ;
10807: LD_ADDR_EXP 62
10811: PUSH
10812: LD_INT 0
10814: ST_TO_ADDR
// sBetray := false ;
10815: LD_ADDR_EXP 66
10819: PUSH
10820: LD_INT 0
10822: ST_TO_ADDR
// sContamin := false ;
10823: LD_ADDR_EXP 67
10827: PUSH
10828: LD_INT 0
10830: ST_TO_ADDR
// sOil := false ;
10831: LD_ADDR_EXP 69
10835: PUSH
10836: LD_INT 0
10838: ST_TO_ADDR
// sStu := false ;
10839: LD_ADDR_EXP 73
10843: PUSH
10844: LD_INT 0
10846: ST_TO_ADDR
// sBazooka := false ;
10847: LD_ADDR_EXP 76
10851: PUSH
10852: LD_INT 0
10854: ST_TO_ADDR
// sMortar := false ;
10855: LD_ADDR_EXP 77
10859: PUSH
10860: LD_INT 0
10862: ST_TO_ADDR
// sRanger := false ;
10863: LD_ADDR_EXP 87
10867: PUSH
10868: LD_INT 0
10870: ST_TO_ADDR
// end ;
10871: LD_VAR 0 1
10875: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
10876: LD_INT 0
10878: PPUSH
10879: PPUSH
10880: PPUSH
10881: PPUSH
10882: PPUSH
// result := [ ] ;
10883: LD_ADDR_VAR 0 1
10887: PUSH
10888: EMPTY
10889: ST_TO_ADDR
// if campaign_id = 1 then
10890: LD_OWVAR 69
10894: PUSH
10895: LD_INT 1
10897: EQUAL
10898: IFFALSE 13836
// begin case mission_number of 1 :
10900: LD_OWVAR 70
10904: PUSH
10905: LD_INT 1
10907: DOUBLE
10908: EQUAL
10909: IFTRUE 10913
10911: GO 10977
10913: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
10914: LD_ADDR_VAR 0 1
10918: PUSH
10919: LD_INT 2
10921: PUSH
10922: LD_INT 4
10924: PUSH
10925: LD_INT 11
10927: PUSH
10928: LD_INT 12
10930: PUSH
10931: LD_INT 15
10933: PUSH
10934: LD_INT 16
10936: PUSH
10937: LD_INT 22
10939: PUSH
10940: LD_INT 23
10942: PUSH
10943: LD_INT 26
10945: PUSH
10946: EMPTY
10947: LIST
10948: LIST
10949: LIST
10950: LIST
10951: LIST
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: PUSH
10957: LD_INT 101
10959: PUSH
10960: LD_INT 102
10962: PUSH
10963: LD_INT 106
10965: PUSH
10966: EMPTY
10967: LIST
10968: LIST
10969: LIST
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: ST_TO_ADDR
10975: GO 13834
10977: LD_INT 2
10979: DOUBLE
10980: EQUAL
10981: IFTRUE 10985
10983: GO 11057
10985: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
10986: LD_ADDR_VAR 0 1
10990: PUSH
10991: LD_INT 2
10993: PUSH
10994: LD_INT 4
10996: PUSH
10997: LD_INT 11
10999: PUSH
11000: LD_INT 12
11002: PUSH
11003: LD_INT 15
11005: PUSH
11006: LD_INT 16
11008: PUSH
11009: LD_INT 22
11011: PUSH
11012: LD_INT 23
11014: PUSH
11015: LD_INT 26
11017: PUSH
11018: EMPTY
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: LIST
11026: LIST
11027: LIST
11028: PUSH
11029: LD_INT 101
11031: PUSH
11032: LD_INT 102
11034: PUSH
11035: LD_INT 105
11037: PUSH
11038: LD_INT 106
11040: PUSH
11041: LD_INT 108
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: LIST
11048: LIST
11049: LIST
11050: PUSH
11051: EMPTY
11052: LIST
11053: LIST
11054: ST_TO_ADDR
11055: GO 13834
11057: LD_INT 3
11059: DOUBLE
11060: EQUAL
11061: IFTRUE 11065
11063: GO 11141
11065: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11066: LD_ADDR_VAR 0 1
11070: PUSH
11071: LD_INT 2
11073: PUSH
11074: LD_INT 4
11076: PUSH
11077: LD_INT 5
11079: PUSH
11080: LD_INT 11
11082: PUSH
11083: LD_INT 12
11085: PUSH
11086: LD_INT 15
11088: PUSH
11089: LD_INT 16
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_INT 26
11097: PUSH
11098: LD_INT 36
11100: PUSH
11101: EMPTY
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: LIST
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: PUSH
11113: LD_INT 101
11115: PUSH
11116: LD_INT 102
11118: PUSH
11119: LD_INT 105
11121: PUSH
11122: LD_INT 106
11124: PUSH
11125: LD_INT 108
11127: PUSH
11128: EMPTY
11129: LIST
11130: LIST
11131: LIST
11132: LIST
11133: LIST
11134: PUSH
11135: EMPTY
11136: LIST
11137: LIST
11138: ST_TO_ADDR
11139: GO 13834
11141: LD_INT 4
11143: DOUBLE
11144: EQUAL
11145: IFTRUE 11149
11147: GO 11233
11149: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11150: LD_ADDR_VAR 0 1
11154: PUSH
11155: LD_INT 2
11157: PUSH
11158: LD_INT 4
11160: PUSH
11161: LD_INT 5
11163: PUSH
11164: LD_INT 8
11166: PUSH
11167: LD_INT 11
11169: PUSH
11170: LD_INT 12
11172: PUSH
11173: LD_INT 15
11175: PUSH
11176: LD_INT 16
11178: PUSH
11179: LD_INT 22
11181: PUSH
11182: LD_INT 23
11184: PUSH
11185: LD_INT 26
11187: PUSH
11188: LD_INT 36
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: LIST
11195: LIST
11196: LIST
11197: LIST
11198: LIST
11199: LIST
11200: LIST
11201: LIST
11202: LIST
11203: LIST
11204: PUSH
11205: LD_INT 101
11207: PUSH
11208: LD_INT 102
11210: PUSH
11211: LD_INT 105
11213: PUSH
11214: LD_INT 106
11216: PUSH
11217: LD_INT 108
11219: PUSH
11220: EMPTY
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: PUSH
11227: EMPTY
11228: LIST
11229: LIST
11230: ST_TO_ADDR
11231: GO 13834
11233: LD_INT 5
11235: DOUBLE
11236: EQUAL
11237: IFTRUE 11241
11239: GO 11341
11241: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
11242: LD_ADDR_VAR 0 1
11246: PUSH
11247: LD_INT 2
11249: PUSH
11250: LD_INT 4
11252: PUSH
11253: LD_INT 5
11255: PUSH
11256: LD_INT 6
11258: PUSH
11259: LD_INT 8
11261: PUSH
11262: LD_INT 11
11264: PUSH
11265: LD_INT 12
11267: PUSH
11268: LD_INT 15
11270: PUSH
11271: LD_INT 16
11273: PUSH
11274: LD_INT 22
11276: PUSH
11277: LD_INT 23
11279: PUSH
11280: LD_INT 25
11282: PUSH
11283: LD_INT 26
11285: PUSH
11286: LD_INT 36
11288: PUSH
11289: EMPTY
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: PUSH
11305: LD_INT 101
11307: PUSH
11308: LD_INT 102
11310: PUSH
11311: LD_INT 105
11313: PUSH
11314: LD_INT 106
11316: PUSH
11317: LD_INT 108
11319: PUSH
11320: LD_INT 109
11322: PUSH
11323: LD_INT 112
11325: PUSH
11326: EMPTY
11327: LIST
11328: LIST
11329: LIST
11330: LIST
11331: LIST
11332: LIST
11333: LIST
11334: PUSH
11335: EMPTY
11336: LIST
11337: LIST
11338: ST_TO_ADDR
11339: GO 13834
11341: LD_INT 6
11343: DOUBLE
11344: EQUAL
11345: IFTRUE 11349
11347: GO 11469
11349: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
11350: LD_ADDR_VAR 0 1
11354: PUSH
11355: LD_INT 2
11357: PUSH
11358: LD_INT 4
11360: PUSH
11361: LD_INT 5
11363: PUSH
11364: LD_INT 6
11366: PUSH
11367: LD_INT 8
11369: PUSH
11370: LD_INT 11
11372: PUSH
11373: LD_INT 12
11375: PUSH
11376: LD_INT 15
11378: PUSH
11379: LD_INT 16
11381: PUSH
11382: LD_INT 20
11384: PUSH
11385: LD_INT 21
11387: PUSH
11388: LD_INT 22
11390: PUSH
11391: LD_INT 23
11393: PUSH
11394: LD_INT 25
11396: PUSH
11397: LD_INT 26
11399: PUSH
11400: LD_INT 30
11402: PUSH
11403: LD_INT 31
11405: PUSH
11406: LD_INT 32
11408: PUSH
11409: LD_INT 36
11411: PUSH
11412: EMPTY
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: PUSH
11433: LD_INT 101
11435: PUSH
11436: LD_INT 102
11438: PUSH
11439: LD_INT 105
11441: PUSH
11442: LD_INT 106
11444: PUSH
11445: LD_INT 108
11447: PUSH
11448: LD_INT 109
11450: PUSH
11451: LD_INT 112
11453: PUSH
11454: EMPTY
11455: LIST
11456: LIST
11457: LIST
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: PUSH
11463: EMPTY
11464: LIST
11465: LIST
11466: ST_TO_ADDR
11467: GO 13834
11469: LD_INT 7
11471: DOUBLE
11472: EQUAL
11473: IFTRUE 11477
11475: GO 11577
11477: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
11478: LD_ADDR_VAR 0 1
11482: PUSH
11483: LD_INT 2
11485: PUSH
11486: LD_INT 4
11488: PUSH
11489: LD_INT 5
11491: PUSH
11492: LD_INT 7
11494: PUSH
11495: LD_INT 11
11497: PUSH
11498: LD_INT 12
11500: PUSH
11501: LD_INT 15
11503: PUSH
11504: LD_INT 16
11506: PUSH
11507: LD_INT 20
11509: PUSH
11510: LD_INT 21
11512: PUSH
11513: LD_INT 22
11515: PUSH
11516: LD_INT 23
11518: PUSH
11519: LD_INT 25
11521: PUSH
11522: LD_INT 26
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: PUSH
11541: LD_INT 101
11543: PUSH
11544: LD_INT 102
11546: PUSH
11547: LD_INT 103
11549: PUSH
11550: LD_INT 105
11552: PUSH
11553: LD_INT 106
11555: PUSH
11556: LD_INT 108
11558: PUSH
11559: LD_INT 112
11561: PUSH
11562: EMPTY
11563: LIST
11564: LIST
11565: LIST
11566: LIST
11567: LIST
11568: LIST
11569: LIST
11570: PUSH
11571: EMPTY
11572: LIST
11573: LIST
11574: ST_TO_ADDR
11575: GO 13834
11577: LD_INT 8
11579: DOUBLE
11580: EQUAL
11581: IFTRUE 11585
11583: GO 11713
11585: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
11586: LD_ADDR_VAR 0 1
11590: PUSH
11591: LD_INT 2
11593: PUSH
11594: LD_INT 4
11596: PUSH
11597: LD_INT 5
11599: PUSH
11600: LD_INT 6
11602: PUSH
11603: LD_INT 7
11605: PUSH
11606: LD_INT 8
11608: PUSH
11609: LD_INT 11
11611: PUSH
11612: LD_INT 12
11614: PUSH
11615: LD_INT 15
11617: PUSH
11618: LD_INT 16
11620: PUSH
11621: LD_INT 20
11623: PUSH
11624: LD_INT 21
11626: PUSH
11627: LD_INT 22
11629: PUSH
11630: LD_INT 23
11632: PUSH
11633: LD_INT 25
11635: PUSH
11636: LD_INT 26
11638: PUSH
11639: LD_INT 30
11641: PUSH
11642: LD_INT 31
11644: PUSH
11645: LD_INT 32
11647: PUSH
11648: LD_INT 36
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: LIST
11657: LIST
11658: LIST
11659: LIST
11660: LIST
11661: LIST
11662: LIST
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: LIST
11672: PUSH
11673: LD_INT 101
11675: PUSH
11676: LD_INT 102
11678: PUSH
11679: LD_INT 103
11681: PUSH
11682: LD_INT 105
11684: PUSH
11685: LD_INT 106
11687: PUSH
11688: LD_INT 108
11690: PUSH
11691: LD_INT 109
11693: PUSH
11694: LD_INT 112
11696: PUSH
11697: EMPTY
11698: LIST
11699: LIST
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: ST_TO_ADDR
11711: GO 13834
11713: LD_INT 9
11715: DOUBLE
11716: EQUAL
11717: IFTRUE 11721
11719: GO 11857
11721: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
11722: LD_ADDR_VAR 0 1
11726: PUSH
11727: LD_INT 2
11729: PUSH
11730: LD_INT 4
11732: PUSH
11733: LD_INT 5
11735: PUSH
11736: LD_INT 6
11738: PUSH
11739: LD_INT 7
11741: PUSH
11742: LD_INT 8
11744: PUSH
11745: LD_INT 11
11747: PUSH
11748: LD_INT 12
11750: PUSH
11751: LD_INT 15
11753: PUSH
11754: LD_INT 16
11756: PUSH
11757: LD_INT 20
11759: PUSH
11760: LD_INT 21
11762: PUSH
11763: LD_INT 22
11765: PUSH
11766: LD_INT 23
11768: PUSH
11769: LD_INT 25
11771: PUSH
11772: LD_INT 26
11774: PUSH
11775: LD_INT 28
11777: PUSH
11778: LD_INT 30
11780: PUSH
11781: LD_INT 31
11783: PUSH
11784: LD_INT 32
11786: PUSH
11787: LD_INT 36
11789: PUSH
11790: EMPTY
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: LIST
11799: LIST
11800: LIST
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: PUSH
11813: LD_INT 101
11815: PUSH
11816: LD_INT 102
11818: PUSH
11819: LD_INT 103
11821: PUSH
11822: LD_INT 105
11824: PUSH
11825: LD_INT 106
11827: PUSH
11828: LD_INT 108
11830: PUSH
11831: LD_INT 109
11833: PUSH
11834: LD_INT 112
11836: PUSH
11837: LD_INT 114
11839: PUSH
11840: EMPTY
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: PUSH
11851: EMPTY
11852: LIST
11853: LIST
11854: ST_TO_ADDR
11855: GO 13834
11857: LD_INT 10
11859: DOUBLE
11860: EQUAL
11861: IFTRUE 11865
11863: GO 12049
11865: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
11866: LD_ADDR_VAR 0 1
11870: PUSH
11871: LD_INT 2
11873: PUSH
11874: LD_INT 4
11876: PUSH
11877: LD_INT 5
11879: PUSH
11880: LD_INT 6
11882: PUSH
11883: LD_INT 7
11885: PUSH
11886: LD_INT 8
11888: PUSH
11889: LD_INT 9
11891: PUSH
11892: LD_INT 10
11894: PUSH
11895: LD_INT 11
11897: PUSH
11898: LD_INT 12
11900: PUSH
11901: LD_INT 13
11903: PUSH
11904: LD_INT 14
11906: PUSH
11907: LD_INT 15
11909: PUSH
11910: LD_INT 16
11912: PUSH
11913: LD_INT 17
11915: PUSH
11916: LD_INT 18
11918: PUSH
11919: LD_INT 19
11921: PUSH
11922: LD_INT 20
11924: PUSH
11925: LD_INT 21
11927: PUSH
11928: LD_INT 22
11930: PUSH
11931: LD_INT 23
11933: PUSH
11934: LD_INT 24
11936: PUSH
11937: LD_INT 25
11939: PUSH
11940: LD_INT 26
11942: PUSH
11943: LD_INT 28
11945: PUSH
11946: LD_INT 30
11948: PUSH
11949: LD_INT 31
11951: PUSH
11952: LD_INT 32
11954: PUSH
11955: LD_INT 36
11957: PUSH
11958: EMPTY
11959: LIST
11960: LIST
11961: LIST
11962: LIST
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: LIST
11974: LIST
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: LIST
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: PUSH
11989: LD_INT 101
11991: PUSH
11992: LD_INT 102
11994: PUSH
11995: LD_INT 103
11997: PUSH
11998: LD_INT 104
12000: PUSH
12001: LD_INT 105
12003: PUSH
12004: LD_INT 106
12006: PUSH
12007: LD_INT 107
12009: PUSH
12010: LD_INT 108
12012: PUSH
12013: LD_INT 109
12015: PUSH
12016: LD_INT 110
12018: PUSH
12019: LD_INT 111
12021: PUSH
12022: LD_INT 112
12024: PUSH
12025: LD_INT 114
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: LIST
12032: LIST
12033: LIST
12034: LIST
12035: LIST
12036: LIST
12037: LIST
12038: LIST
12039: LIST
12040: LIST
12041: LIST
12042: PUSH
12043: EMPTY
12044: LIST
12045: LIST
12046: ST_TO_ADDR
12047: GO 13834
12049: LD_INT 11
12051: DOUBLE
12052: EQUAL
12053: IFTRUE 12057
12055: GO 12249
12057: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12058: LD_ADDR_VAR 0 1
12062: PUSH
12063: LD_INT 2
12065: PUSH
12066: LD_INT 3
12068: PUSH
12069: LD_INT 4
12071: PUSH
12072: LD_INT 5
12074: PUSH
12075: LD_INT 6
12077: PUSH
12078: LD_INT 7
12080: PUSH
12081: LD_INT 8
12083: PUSH
12084: LD_INT 9
12086: PUSH
12087: LD_INT 10
12089: PUSH
12090: LD_INT 11
12092: PUSH
12093: LD_INT 12
12095: PUSH
12096: LD_INT 13
12098: PUSH
12099: LD_INT 14
12101: PUSH
12102: LD_INT 15
12104: PUSH
12105: LD_INT 16
12107: PUSH
12108: LD_INT 17
12110: PUSH
12111: LD_INT 18
12113: PUSH
12114: LD_INT 19
12116: PUSH
12117: LD_INT 20
12119: PUSH
12120: LD_INT 21
12122: PUSH
12123: LD_INT 22
12125: PUSH
12126: LD_INT 23
12128: PUSH
12129: LD_INT 24
12131: PUSH
12132: LD_INT 25
12134: PUSH
12135: LD_INT 26
12137: PUSH
12138: LD_INT 28
12140: PUSH
12141: LD_INT 30
12143: PUSH
12144: LD_INT 31
12146: PUSH
12147: LD_INT 32
12149: PUSH
12150: LD_INT 34
12152: PUSH
12153: LD_INT 36
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: LIST
12164: LIST
12165: LIST
12166: LIST
12167: LIST
12168: LIST
12169: LIST
12170: LIST
12171: LIST
12172: LIST
12173: LIST
12174: LIST
12175: LIST
12176: LIST
12177: LIST
12178: LIST
12179: LIST
12180: LIST
12181: LIST
12182: LIST
12183: LIST
12184: LIST
12185: LIST
12186: LIST
12187: LIST
12188: PUSH
12189: LD_INT 101
12191: PUSH
12192: LD_INT 102
12194: PUSH
12195: LD_INT 103
12197: PUSH
12198: LD_INT 104
12200: PUSH
12201: LD_INT 105
12203: PUSH
12204: LD_INT 106
12206: PUSH
12207: LD_INT 107
12209: PUSH
12210: LD_INT 108
12212: PUSH
12213: LD_INT 109
12215: PUSH
12216: LD_INT 110
12218: PUSH
12219: LD_INT 111
12221: PUSH
12222: LD_INT 112
12224: PUSH
12225: LD_INT 114
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: LIST
12232: LIST
12233: LIST
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: LIST
12239: LIST
12240: LIST
12241: LIST
12242: PUSH
12243: EMPTY
12244: LIST
12245: LIST
12246: ST_TO_ADDR
12247: GO 13834
12249: LD_INT 12
12251: DOUBLE
12252: EQUAL
12253: IFTRUE 12257
12255: GO 12465
12257: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
12258: LD_ADDR_VAR 0 1
12262: PUSH
12263: LD_INT 1
12265: PUSH
12266: LD_INT 2
12268: PUSH
12269: LD_INT 3
12271: PUSH
12272: LD_INT 4
12274: PUSH
12275: LD_INT 5
12277: PUSH
12278: LD_INT 6
12280: PUSH
12281: LD_INT 7
12283: PUSH
12284: LD_INT 8
12286: PUSH
12287: LD_INT 9
12289: PUSH
12290: LD_INT 10
12292: PUSH
12293: LD_INT 11
12295: PUSH
12296: LD_INT 12
12298: PUSH
12299: LD_INT 13
12301: PUSH
12302: LD_INT 14
12304: PUSH
12305: LD_INT 15
12307: PUSH
12308: LD_INT 16
12310: PUSH
12311: LD_INT 17
12313: PUSH
12314: LD_INT 18
12316: PUSH
12317: LD_INT 19
12319: PUSH
12320: LD_INT 20
12322: PUSH
12323: LD_INT 21
12325: PUSH
12326: LD_INT 22
12328: PUSH
12329: LD_INT 23
12331: PUSH
12332: LD_INT 24
12334: PUSH
12335: LD_INT 25
12337: PUSH
12338: LD_INT 26
12340: PUSH
12341: LD_INT 27
12343: PUSH
12344: LD_INT 28
12346: PUSH
12347: LD_INT 30
12349: PUSH
12350: LD_INT 31
12352: PUSH
12353: LD_INT 32
12355: PUSH
12356: LD_INT 33
12358: PUSH
12359: LD_INT 34
12361: PUSH
12362: LD_INT 36
12364: PUSH
12365: EMPTY
12366: LIST
12367: LIST
12368: LIST
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: LIST
12377: LIST
12378: LIST
12379: LIST
12380: LIST
12381: LIST
12382: LIST
12383: LIST
12384: LIST
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: PUSH
12401: LD_INT 101
12403: PUSH
12404: LD_INT 102
12406: PUSH
12407: LD_INT 103
12409: PUSH
12410: LD_INT 104
12412: PUSH
12413: LD_INT 105
12415: PUSH
12416: LD_INT 106
12418: PUSH
12419: LD_INT 107
12421: PUSH
12422: LD_INT 108
12424: PUSH
12425: LD_INT 109
12427: PUSH
12428: LD_INT 110
12430: PUSH
12431: LD_INT 111
12433: PUSH
12434: LD_INT 112
12436: PUSH
12437: LD_INT 113
12439: PUSH
12440: LD_INT 114
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: LIST
12456: LIST
12457: LIST
12458: PUSH
12459: EMPTY
12460: LIST
12461: LIST
12462: ST_TO_ADDR
12463: GO 13834
12465: LD_INT 13
12467: DOUBLE
12468: EQUAL
12469: IFTRUE 12473
12471: GO 12669
12473: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
12474: LD_ADDR_VAR 0 1
12478: PUSH
12479: LD_INT 1
12481: PUSH
12482: LD_INT 2
12484: PUSH
12485: LD_INT 3
12487: PUSH
12488: LD_INT 4
12490: PUSH
12491: LD_INT 5
12493: PUSH
12494: LD_INT 8
12496: PUSH
12497: LD_INT 9
12499: PUSH
12500: LD_INT 10
12502: PUSH
12503: LD_INT 11
12505: PUSH
12506: LD_INT 12
12508: PUSH
12509: LD_INT 14
12511: PUSH
12512: LD_INT 15
12514: PUSH
12515: LD_INT 16
12517: PUSH
12518: LD_INT 17
12520: PUSH
12521: LD_INT 18
12523: PUSH
12524: LD_INT 19
12526: PUSH
12527: LD_INT 20
12529: PUSH
12530: LD_INT 21
12532: PUSH
12533: LD_INT 22
12535: PUSH
12536: LD_INT 23
12538: PUSH
12539: LD_INT 24
12541: PUSH
12542: LD_INT 25
12544: PUSH
12545: LD_INT 26
12547: PUSH
12548: LD_INT 27
12550: PUSH
12551: LD_INT 28
12553: PUSH
12554: LD_INT 30
12556: PUSH
12557: LD_INT 31
12559: PUSH
12560: LD_INT 32
12562: PUSH
12563: LD_INT 33
12565: PUSH
12566: LD_INT 34
12568: PUSH
12569: LD_INT 36
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: LIST
12576: LIST
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: LIST
12590: LIST
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: LIST
12597: LIST
12598: LIST
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 101
12607: PUSH
12608: LD_INT 102
12610: PUSH
12611: LD_INT 103
12613: PUSH
12614: LD_INT 104
12616: PUSH
12617: LD_INT 105
12619: PUSH
12620: LD_INT 106
12622: PUSH
12623: LD_INT 107
12625: PUSH
12626: LD_INT 108
12628: PUSH
12629: LD_INT 109
12631: PUSH
12632: LD_INT 110
12634: PUSH
12635: LD_INT 111
12637: PUSH
12638: LD_INT 112
12640: PUSH
12641: LD_INT 113
12643: PUSH
12644: LD_INT 114
12646: PUSH
12647: EMPTY
12648: LIST
12649: LIST
12650: LIST
12651: LIST
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: LIST
12660: LIST
12661: LIST
12662: PUSH
12663: EMPTY
12664: LIST
12665: LIST
12666: ST_TO_ADDR
12667: GO 13834
12669: LD_INT 14
12671: DOUBLE
12672: EQUAL
12673: IFTRUE 12677
12675: GO 12889
12677: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
12678: LD_ADDR_VAR 0 1
12682: PUSH
12683: LD_INT 1
12685: PUSH
12686: LD_INT 2
12688: PUSH
12689: LD_INT 3
12691: PUSH
12692: LD_INT 4
12694: PUSH
12695: LD_INT 5
12697: PUSH
12698: LD_INT 6
12700: PUSH
12701: LD_INT 7
12703: PUSH
12704: LD_INT 8
12706: PUSH
12707: LD_INT 9
12709: PUSH
12710: LD_INT 10
12712: PUSH
12713: LD_INT 11
12715: PUSH
12716: LD_INT 12
12718: PUSH
12719: LD_INT 13
12721: PUSH
12722: LD_INT 14
12724: PUSH
12725: LD_INT 15
12727: PUSH
12728: LD_INT 16
12730: PUSH
12731: LD_INT 17
12733: PUSH
12734: LD_INT 18
12736: PUSH
12737: LD_INT 19
12739: PUSH
12740: LD_INT 20
12742: PUSH
12743: LD_INT 21
12745: PUSH
12746: LD_INT 22
12748: PUSH
12749: LD_INT 23
12751: PUSH
12752: LD_INT 24
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 26
12760: PUSH
12761: LD_INT 27
12763: PUSH
12764: LD_INT 28
12766: PUSH
12767: LD_INT 29
12769: PUSH
12770: LD_INT 30
12772: PUSH
12773: LD_INT 31
12775: PUSH
12776: LD_INT 32
12778: PUSH
12779: LD_INT 33
12781: PUSH
12782: LD_INT 34
12784: PUSH
12785: LD_INT 36
12787: PUSH
12788: EMPTY
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: PUSH
12825: LD_INT 101
12827: PUSH
12828: LD_INT 102
12830: PUSH
12831: LD_INT 103
12833: PUSH
12834: LD_INT 104
12836: PUSH
12837: LD_INT 105
12839: PUSH
12840: LD_INT 106
12842: PUSH
12843: LD_INT 107
12845: PUSH
12846: LD_INT 108
12848: PUSH
12849: LD_INT 109
12851: PUSH
12852: LD_INT 110
12854: PUSH
12855: LD_INT 111
12857: PUSH
12858: LD_INT 112
12860: PUSH
12861: LD_INT 113
12863: PUSH
12864: LD_INT 114
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: LIST
12881: LIST
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: ST_TO_ADDR
12887: GO 13834
12889: LD_INT 15
12891: DOUBLE
12892: EQUAL
12893: IFTRUE 12897
12895: GO 13109
12897: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
12898: LD_ADDR_VAR 0 1
12902: PUSH
12903: LD_INT 1
12905: PUSH
12906: LD_INT 2
12908: PUSH
12909: LD_INT 3
12911: PUSH
12912: LD_INT 4
12914: PUSH
12915: LD_INT 5
12917: PUSH
12918: LD_INT 6
12920: PUSH
12921: LD_INT 7
12923: PUSH
12924: LD_INT 8
12926: PUSH
12927: LD_INT 9
12929: PUSH
12930: LD_INT 10
12932: PUSH
12933: LD_INT 11
12935: PUSH
12936: LD_INT 12
12938: PUSH
12939: LD_INT 13
12941: PUSH
12942: LD_INT 14
12944: PUSH
12945: LD_INT 15
12947: PUSH
12948: LD_INT 16
12950: PUSH
12951: LD_INT 17
12953: PUSH
12954: LD_INT 18
12956: PUSH
12957: LD_INT 19
12959: PUSH
12960: LD_INT 20
12962: PUSH
12963: LD_INT 21
12965: PUSH
12966: LD_INT 22
12968: PUSH
12969: LD_INT 23
12971: PUSH
12972: LD_INT 24
12974: PUSH
12975: LD_INT 25
12977: PUSH
12978: LD_INT 26
12980: PUSH
12981: LD_INT 27
12983: PUSH
12984: LD_INT 28
12986: PUSH
12987: LD_INT 29
12989: PUSH
12990: LD_INT 30
12992: PUSH
12993: LD_INT 31
12995: PUSH
12996: LD_INT 32
12998: PUSH
12999: LD_INT 33
13001: PUSH
13002: LD_INT 34
13004: PUSH
13005: LD_INT 36
13007: PUSH
13008: EMPTY
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: LIST
13024: LIST
13025: LIST
13026: LIST
13027: LIST
13028: LIST
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: LIST
13042: LIST
13043: LIST
13044: PUSH
13045: LD_INT 101
13047: PUSH
13048: LD_INT 102
13050: PUSH
13051: LD_INT 103
13053: PUSH
13054: LD_INT 104
13056: PUSH
13057: LD_INT 105
13059: PUSH
13060: LD_INT 106
13062: PUSH
13063: LD_INT 107
13065: PUSH
13066: LD_INT 108
13068: PUSH
13069: LD_INT 109
13071: PUSH
13072: LD_INT 110
13074: PUSH
13075: LD_INT 111
13077: PUSH
13078: LD_INT 112
13080: PUSH
13081: LD_INT 113
13083: PUSH
13084: LD_INT 114
13086: PUSH
13087: EMPTY
13088: LIST
13089: LIST
13090: LIST
13091: LIST
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: LIST
13100: LIST
13101: LIST
13102: PUSH
13103: EMPTY
13104: LIST
13105: LIST
13106: ST_TO_ADDR
13107: GO 13834
13109: LD_INT 16
13111: DOUBLE
13112: EQUAL
13113: IFTRUE 13117
13115: GO 13241
13117: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13118: LD_ADDR_VAR 0 1
13122: PUSH
13123: LD_INT 2
13125: PUSH
13126: LD_INT 4
13128: PUSH
13129: LD_INT 5
13131: PUSH
13132: LD_INT 7
13134: PUSH
13135: LD_INT 11
13137: PUSH
13138: LD_INT 12
13140: PUSH
13141: LD_INT 15
13143: PUSH
13144: LD_INT 16
13146: PUSH
13147: LD_INT 20
13149: PUSH
13150: LD_INT 21
13152: PUSH
13153: LD_INT 22
13155: PUSH
13156: LD_INT 23
13158: PUSH
13159: LD_INT 25
13161: PUSH
13162: LD_INT 26
13164: PUSH
13165: LD_INT 30
13167: PUSH
13168: LD_INT 31
13170: PUSH
13171: LD_INT 32
13173: PUSH
13174: LD_INT 33
13176: PUSH
13177: LD_INT 34
13179: PUSH
13180: EMPTY
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: LIST
13199: LIST
13200: PUSH
13201: LD_INT 101
13203: PUSH
13204: LD_INT 102
13206: PUSH
13207: LD_INT 103
13209: PUSH
13210: LD_INT 106
13212: PUSH
13213: LD_INT 108
13215: PUSH
13216: LD_INT 112
13218: PUSH
13219: LD_INT 113
13221: PUSH
13222: LD_INT 114
13224: PUSH
13225: EMPTY
13226: LIST
13227: LIST
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: PUSH
13235: EMPTY
13236: LIST
13237: LIST
13238: ST_TO_ADDR
13239: GO 13834
13241: LD_INT 17
13243: DOUBLE
13244: EQUAL
13245: IFTRUE 13249
13247: GO 13461
13249: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
13250: LD_ADDR_VAR 0 1
13254: PUSH
13255: LD_INT 1
13257: PUSH
13258: LD_INT 2
13260: PUSH
13261: LD_INT 3
13263: PUSH
13264: LD_INT 4
13266: PUSH
13267: LD_INT 5
13269: PUSH
13270: LD_INT 6
13272: PUSH
13273: LD_INT 7
13275: PUSH
13276: LD_INT 8
13278: PUSH
13279: LD_INT 9
13281: PUSH
13282: LD_INT 10
13284: PUSH
13285: LD_INT 11
13287: PUSH
13288: LD_INT 12
13290: PUSH
13291: LD_INT 13
13293: PUSH
13294: LD_INT 14
13296: PUSH
13297: LD_INT 15
13299: PUSH
13300: LD_INT 16
13302: PUSH
13303: LD_INT 17
13305: PUSH
13306: LD_INT 18
13308: PUSH
13309: LD_INT 19
13311: PUSH
13312: LD_INT 20
13314: PUSH
13315: LD_INT 21
13317: PUSH
13318: LD_INT 22
13320: PUSH
13321: LD_INT 23
13323: PUSH
13324: LD_INT 24
13326: PUSH
13327: LD_INT 25
13329: PUSH
13330: LD_INT 26
13332: PUSH
13333: LD_INT 27
13335: PUSH
13336: LD_INT 28
13338: PUSH
13339: LD_INT 29
13341: PUSH
13342: LD_INT 30
13344: PUSH
13345: LD_INT 31
13347: PUSH
13348: LD_INT 32
13350: PUSH
13351: LD_INT 33
13353: PUSH
13354: LD_INT 34
13356: PUSH
13357: LD_INT 36
13359: PUSH
13360: EMPTY
13361: LIST
13362: LIST
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: LIST
13394: LIST
13395: LIST
13396: PUSH
13397: LD_INT 101
13399: PUSH
13400: LD_INT 102
13402: PUSH
13403: LD_INT 103
13405: PUSH
13406: LD_INT 104
13408: PUSH
13409: LD_INT 105
13411: PUSH
13412: LD_INT 106
13414: PUSH
13415: LD_INT 107
13417: PUSH
13418: LD_INT 108
13420: PUSH
13421: LD_INT 109
13423: PUSH
13424: LD_INT 110
13426: PUSH
13427: LD_INT 111
13429: PUSH
13430: LD_INT 112
13432: PUSH
13433: LD_INT 113
13435: PUSH
13436: LD_INT 114
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: LIST
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: PUSH
13455: EMPTY
13456: LIST
13457: LIST
13458: ST_TO_ADDR
13459: GO 13834
13461: LD_INT 18
13463: DOUBLE
13464: EQUAL
13465: IFTRUE 13469
13467: GO 13605
13469: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
13470: LD_ADDR_VAR 0 1
13474: PUSH
13475: LD_INT 2
13477: PUSH
13478: LD_INT 4
13480: PUSH
13481: LD_INT 5
13483: PUSH
13484: LD_INT 7
13486: PUSH
13487: LD_INT 11
13489: PUSH
13490: LD_INT 12
13492: PUSH
13493: LD_INT 15
13495: PUSH
13496: LD_INT 16
13498: PUSH
13499: LD_INT 20
13501: PUSH
13502: LD_INT 21
13504: PUSH
13505: LD_INT 22
13507: PUSH
13508: LD_INT 23
13510: PUSH
13511: LD_INT 25
13513: PUSH
13514: LD_INT 26
13516: PUSH
13517: LD_INT 30
13519: PUSH
13520: LD_INT 31
13522: PUSH
13523: LD_INT 32
13525: PUSH
13526: LD_INT 33
13528: PUSH
13529: LD_INT 34
13531: PUSH
13532: LD_INT 35
13534: PUSH
13535: LD_INT 36
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: LIST
13542: LIST
13543: LIST
13544: LIST
13545: LIST
13546: LIST
13547: LIST
13548: LIST
13549: LIST
13550: LIST
13551: LIST
13552: LIST
13553: LIST
13554: LIST
13555: LIST
13556: LIST
13557: LIST
13558: LIST
13559: LIST
13560: PUSH
13561: LD_INT 101
13563: PUSH
13564: LD_INT 102
13566: PUSH
13567: LD_INT 103
13569: PUSH
13570: LD_INT 106
13572: PUSH
13573: LD_INT 108
13575: PUSH
13576: LD_INT 112
13578: PUSH
13579: LD_INT 113
13581: PUSH
13582: LD_INT 114
13584: PUSH
13585: LD_INT 115
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: ST_TO_ADDR
13603: GO 13834
13605: LD_INT 19
13607: DOUBLE
13608: EQUAL
13609: IFTRUE 13613
13611: GO 13833
13613: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
13614: LD_ADDR_VAR 0 1
13618: PUSH
13619: LD_INT 1
13621: PUSH
13622: LD_INT 2
13624: PUSH
13625: LD_INT 3
13627: PUSH
13628: LD_INT 4
13630: PUSH
13631: LD_INT 5
13633: PUSH
13634: LD_INT 6
13636: PUSH
13637: LD_INT 7
13639: PUSH
13640: LD_INT 8
13642: PUSH
13643: LD_INT 9
13645: PUSH
13646: LD_INT 10
13648: PUSH
13649: LD_INT 11
13651: PUSH
13652: LD_INT 12
13654: PUSH
13655: LD_INT 13
13657: PUSH
13658: LD_INT 14
13660: PUSH
13661: LD_INT 15
13663: PUSH
13664: LD_INT 16
13666: PUSH
13667: LD_INT 17
13669: PUSH
13670: LD_INT 18
13672: PUSH
13673: LD_INT 19
13675: PUSH
13676: LD_INT 20
13678: PUSH
13679: LD_INT 21
13681: PUSH
13682: LD_INT 22
13684: PUSH
13685: LD_INT 23
13687: PUSH
13688: LD_INT 24
13690: PUSH
13691: LD_INT 25
13693: PUSH
13694: LD_INT 26
13696: PUSH
13697: LD_INT 27
13699: PUSH
13700: LD_INT 28
13702: PUSH
13703: LD_INT 29
13705: PUSH
13706: LD_INT 30
13708: PUSH
13709: LD_INT 31
13711: PUSH
13712: LD_INT 32
13714: PUSH
13715: LD_INT 33
13717: PUSH
13718: LD_INT 34
13720: PUSH
13721: LD_INT 35
13723: PUSH
13724: LD_INT 36
13726: PUSH
13727: EMPTY
13728: LIST
13729: LIST
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: LIST
13735: LIST
13736: LIST
13737: LIST
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: LIST
13749: LIST
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: LIST
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: PUSH
13765: LD_INT 101
13767: PUSH
13768: LD_INT 102
13770: PUSH
13771: LD_INT 103
13773: PUSH
13774: LD_INT 104
13776: PUSH
13777: LD_INT 105
13779: PUSH
13780: LD_INT 106
13782: PUSH
13783: LD_INT 107
13785: PUSH
13786: LD_INT 108
13788: PUSH
13789: LD_INT 109
13791: PUSH
13792: LD_INT 110
13794: PUSH
13795: LD_INT 111
13797: PUSH
13798: LD_INT 112
13800: PUSH
13801: LD_INT 113
13803: PUSH
13804: LD_INT 114
13806: PUSH
13807: LD_INT 115
13809: PUSH
13810: EMPTY
13811: LIST
13812: LIST
13813: LIST
13814: LIST
13815: LIST
13816: LIST
13817: LIST
13818: LIST
13819: LIST
13820: LIST
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: PUSH
13827: EMPTY
13828: LIST
13829: LIST
13830: ST_TO_ADDR
13831: GO 13834
13833: POP
// end else
13834: GO 13871
// if campaign_id = 5 then
13836: LD_OWVAR 69
13840: PUSH
13841: LD_INT 5
13843: EQUAL
13844: IFFALSE 13871
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
13846: LD_ADDR_VAR 0 1
13850: PUSH
13851: LD_INT 1
13853: PUSH
13854: LD_INT 2
13856: PUSH
13857: EMPTY
13858: LIST
13859: LIST
13860: PUSH
13861: LD_INT 100
13863: PUSH
13864: EMPTY
13865: LIST
13866: PUSH
13867: EMPTY
13868: LIST
13869: LIST
13870: ST_TO_ADDR
// end ; if result then
13871: LD_VAR 0 1
13875: IFFALSE 14164
// begin normal :=  ;
13877: LD_ADDR_VAR 0 3
13881: PUSH
13882: LD_STRING 
13884: ST_TO_ADDR
// hardcore :=  ;
13885: LD_ADDR_VAR 0 4
13889: PUSH
13890: LD_STRING 
13892: ST_TO_ADDR
// for i = 1 to normalCounter do
13893: LD_ADDR_VAR 0 5
13897: PUSH
13898: DOUBLE
13899: LD_INT 1
13901: DEC
13902: ST_TO_ADDR
13903: LD_EXP 35
13907: PUSH
13908: FOR_TO
13909: IFFALSE 14010
// begin tmp := 0 ;
13911: LD_ADDR_VAR 0 2
13915: PUSH
13916: LD_STRING 0
13918: ST_TO_ADDR
// if result [ 1 ] then
13919: LD_VAR 0 1
13923: PUSH
13924: LD_INT 1
13926: ARRAY
13927: IFFALSE 13992
// if result [ 1 ] [ 1 ] = i then
13929: LD_VAR 0 1
13933: PUSH
13934: LD_INT 1
13936: ARRAY
13937: PUSH
13938: LD_INT 1
13940: ARRAY
13941: PUSH
13942: LD_VAR 0 5
13946: EQUAL
13947: IFFALSE 13992
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
13949: LD_ADDR_VAR 0 1
13953: PUSH
13954: LD_VAR 0 1
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: LD_VAR 0 1
13966: PUSH
13967: LD_INT 1
13969: ARRAY
13970: PPUSH
13971: LD_INT 1
13973: PPUSH
13974: CALL_OW 3
13978: PPUSH
13979: CALL_OW 1
13983: ST_TO_ADDR
// tmp := 1 ;
13984: LD_ADDR_VAR 0 2
13988: PUSH
13989: LD_STRING 1
13991: ST_TO_ADDR
// end ; normal := normal & tmp ;
13992: LD_ADDR_VAR 0 3
13996: PUSH
13997: LD_VAR 0 3
14001: PUSH
14002: LD_VAR 0 2
14006: STR
14007: ST_TO_ADDR
// end ;
14008: GO 13908
14010: POP
14011: POP
// for i = 1 to hardcoreCounter do
14012: LD_ADDR_VAR 0 5
14016: PUSH
14017: DOUBLE
14018: LD_INT 1
14020: DEC
14021: ST_TO_ADDR
14022: LD_EXP 36
14026: PUSH
14027: FOR_TO
14028: IFFALSE 14133
// begin tmp := 0 ;
14030: LD_ADDR_VAR 0 2
14034: PUSH
14035: LD_STRING 0
14037: ST_TO_ADDR
// if result [ 2 ] then
14038: LD_VAR 0 1
14042: PUSH
14043: LD_INT 2
14045: ARRAY
14046: IFFALSE 14115
// if result [ 2 ] [ 1 ] = 100 + i then
14048: LD_VAR 0 1
14052: PUSH
14053: LD_INT 2
14055: ARRAY
14056: PUSH
14057: LD_INT 1
14059: ARRAY
14060: PUSH
14061: LD_INT 100
14063: PUSH
14064: LD_VAR 0 5
14068: PLUS
14069: EQUAL
14070: IFFALSE 14115
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
14072: LD_ADDR_VAR 0 1
14076: PUSH
14077: LD_VAR 0 1
14081: PPUSH
14082: LD_INT 2
14084: PPUSH
14085: LD_VAR 0 1
14089: PUSH
14090: LD_INT 2
14092: ARRAY
14093: PPUSH
14094: LD_INT 1
14096: PPUSH
14097: CALL_OW 3
14101: PPUSH
14102: CALL_OW 1
14106: ST_TO_ADDR
// tmp := 1 ;
14107: LD_ADDR_VAR 0 2
14111: PUSH
14112: LD_STRING 1
14114: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
14115: LD_ADDR_VAR 0 4
14119: PUSH
14120: LD_VAR 0 4
14124: PUSH
14125: LD_VAR 0 2
14129: STR
14130: ST_TO_ADDR
// end ;
14131: GO 14027
14133: POP
14134: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
14135: LD_STRING getStreamItemsFromMission("
14137: PUSH
14138: LD_VAR 0 3
14142: STR
14143: PUSH
14144: LD_STRING ","
14146: STR
14147: PUSH
14148: LD_VAR 0 4
14152: STR
14153: PUSH
14154: LD_STRING ")
14156: STR
14157: PPUSH
14158: CALL_OW 559
// end else
14162: GO 14171
// ToLua ( getStreamItemsFromMission("","") ) ;
14164: LD_STRING getStreamItemsFromMission("","")
14166: PPUSH
14167: CALL_OW 559
// end ;
14171: LD_VAR 0 1
14175: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
14176: LD_VAR 0 2
14180: PUSH
14181: LD_INT 100
14183: EQUAL
14184: IFFALSE 15133
// begin if not StreamModeActive then
14186: LD_EXP 34
14190: NOT
14191: IFFALSE 14201
// StreamModeActive := true ;
14193: LD_ADDR_EXP 34
14197: PUSH
14198: LD_INT 1
14200: ST_TO_ADDR
// if p3 = 0 then
14201: LD_VAR 0 3
14205: PUSH
14206: LD_INT 0
14208: EQUAL
14209: IFFALSE 14215
// InitStreamMode ;
14211: CALL 10436 0 0
// if p3 = 1 then
14215: LD_VAR 0 3
14219: PUSH
14220: LD_INT 1
14222: EQUAL
14223: IFFALSE 14233
// sRocket := true ;
14225: LD_ADDR_EXP 39
14229: PUSH
14230: LD_INT 1
14232: ST_TO_ADDR
// if p3 = 2 then
14233: LD_VAR 0 3
14237: PUSH
14238: LD_INT 2
14240: EQUAL
14241: IFFALSE 14251
// sSpeed := true ;
14243: LD_ADDR_EXP 38
14247: PUSH
14248: LD_INT 1
14250: ST_TO_ADDR
// if p3 = 3 then
14251: LD_VAR 0 3
14255: PUSH
14256: LD_INT 3
14258: EQUAL
14259: IFFALSE 14269
// sEngine := true ;
14261: LD_ADDR_EXP 40
14265: PUSH
14266: LD_INT 1
14268: ST_TO_ADDR
// if p3 = 4 then
14269: LD_VAR 0 3
14273: PUSH
14274: LD_INT 4
14276: EQUAL
14277: IFFALSE 14287
// sSpec := true ;
14279: LD_ADDR_EXP 37
14283: PUSH
14284: LD_INT 1
14286: ST_TO_ADDR
// if p3 = 5 then
14287: LD_VAR 0 3
14291: PUSH
14292: LD_INT 5
14294: EQUAL
14295: IFFALSE 14305
// sLevel := true ;
14297: LD_ADDR_EXP 41
14301: PUSH
14302: LD_INT 1
14304: ST_TO_ADDR
// if p3 = 6 then
14305: LD_VAR 0 3
14309: PUSH
14310: LD_INT 6
14312: EQUAL
14313: IFFALSE 14323
// sArmoury := true ;
14315: LD_ADDR_EXP 42
14319: PUSH
14320: LD_INT 1
14322: ST_TO_ADDR
// if p3 = 7 then
14323: LD_VAR 0 3
14327: PUSH
14328: LD_INT 7
14330: EQUAL
14331: IFFALSE 14341
// sRadar := true ;
14333: LD_ADDR_EXP 43
14337: PUSH
14338: LD_INT 1
14340: ST_TO_ADDR
// if p3 = 8 then
14341: LD_VAR 0 3
14345: PUSH
14346: LD_INT 8
14348: EQUAL
14349: IFFALSE 14359
// sBunker := true ;
14351: LD_ADDR_EXP 44
14355: PUSH
14356: LD_INT 1
14358: ST_TO_ADDR
// if p3 = 9 then
14359: LD_VAR 0 3
14363: PUSH
14364: LD_INT 9
14366: EQUAL
14367: IFFALSE 14377
// sHack := true ;
14369: LD_ADDR_EXP 45
14373: PUSH
14374: LD_INT 1
14376: ST_TO_ADDR
// if p3 = 10 then
14377: LD_VAR 0 3
14381: PUSH
14382: LD_INT 10
14384: EQUAL
14385: IFFALSE 14395
// sFire := true ;
14387: LD_ADDR_EXP 46
14391: PUSH
14392: LD_INT 1
14394: ST_TO_ADDR
// if p3 = 11 then
14395: LD_VAR 0 3
14399: PUSH
14400: LD_INT 11
14402: EQUAL
14403: IFFALSE 14413
// sRefresh := true ;
14405: LD_ADDR_EXP 47
14409: PUSH
14410: LD_INT 1
14412: ST_TO_ADDR
// if p3 = 12 then
14413: LD_VAR 0 3
14417: PUSH
14418: LD_INT 12
14420: EQUAL
14421: IFFALSE 14431
// sExp := true ;
14423: LD_ADDR_EXP 48
14427: PUSH
14428: LD_INT 1
14430: ST_TO_ADDR
// if p3 = 13 then
14431: LD_VAR 0 3
14435: PUSH
14436: LD_INT 13
14438: EQUAL
14439: IFFALSE 14449
// sDepot := true ;
14441: LD_ADDR_EXP 49
14445: PUSH
14446: LD_INT 1
14448: ST_TO_ADDR
// if p3 = 14 then
14449: LD_VAR 0 3
14453: PUSH
14454: LD_INT 14
14456: EQUAL
14457: IFFALSE 14467
// sFlag := true ;
14459: LD_ADDR_EXP 50
14463: PUSH
14464: LD_INT 1
14466: ST_TO_ADDR
// if p3 = 15 then
14467: LD_VAR 0 3
14471: PUSH
14472: LD_INT 15
14474: EQUAL
14475: IFFALSE 14485
// sKamikadze := true ;
14477: LD_ADDR_EXP 58
14481: PUSH
14482: LD_INT 1
14484: ST_TO_ADDR
// if p3 = 16 then
14485: LD_VAR 0 3
14489: PUSH
14490: LD_INT 16
14492: EQUAL
14493: IFFALSE 14503
// sTroll := true ;
14495: LD_ADDR_EXP 59
14499: PUSH
14500: LD_INT 1
14502: ST_TO_ADDR
// if p3 = 17 then
14503: LD_VAR 0 3
14507: PUSH
14508: LD_INT 17
14510: EQUAL
14511: IFFALSE 14521
// sSlow := true ;
14513: LD_ADDR_EXP 60
14517: PUSH
14518: LD_INT 1
14520: ST_TO_ADDR
// if p3 = 18 then
14521: LD_VAR 0 3
14525: PUSH
14526: LD_INT 18
14528: EQUAL
14529: IFFALSE 14539
// sLack := true ;
14531: LD_ADDR_EXP 61
14535: PUSH
14536: LD_INT 1
14538: ST_TO_ADDR
// if p3 = 19 then
14539: LD_VAR 0 3
14543: PUSH
14544: LD_INT 19
14546: EQUAL
14547: IFFALSE 14557
// sTank := true ;
14549: LD_ADDR_EXP 63
14553: PUSH
14554: LD_INT 1
14556: ST_TO_ADDR
// if p3 = 20 then
14557: LD_VAR 0 3
14561: PUSH
14562: LD_INT 20
14564: EQUAL
14565: IFFALSE 14575
// sRemote := true ;
14567: LD_ADDR_EXP 64
14571: PUSH
14572: LD_INT 1
14574: ST_TO_ADDR
// if p3 = 21 then
14575: LD_VAR 0 3
14579: PUSH
14580: LD_INT 21
14582: EQUAL
14583: IFFALSE 14593
// sPowell := true ;
14585: LD_ADDR_EXP 65
14589: PUSH
14590: LD_INT 1
14592: ST_TO_ADDR
// if p3 = 22 then
14593: LD_VAR 0 3
14597: PUSH
14598: LD_INT 22
14600: EQUAL
14601: IFFALSE 14611
// sTeleport := true ;
14603: LD_ADDR_EXP 68
14607: PUSH
14608: LD_INT 1
14610: ST_TO_ADDR
// if p3 = 23 then
14611: LD_VAR 0 3
14615: PUSH
14616: LD_INT 23
14618: EQUAL
14619: IFFALSE 14629
// sOilTower := true ;
14621: LD_ADDR_EXP 70
14625: PUSH
14626: LD_INT 1
14628: ST_TO_ADDR
// if p3 = 24 then
14629: LD_VAR 0 3
14633: PUSH
14634: LD_INT 24
14636: EQUAL
14637: IFFALSE 14647
// sShovel := true ;
14639: LD_ADDR_EXP 71
14643: PUSH
14644: LD_INT 1
14646: ST_TO_ADDR
// if p3 = 25 then
14647: LD_VAR 0 3
14651: PUSH
14652: LD_INT 25
14654: EQUAL
14655: IFFALSE 14665
// sSheik := true ;
14657: LD_ADDR_EXP 72
14661: PUSH
14662: LD_INT 1
14664: ST_TO_ADDR
// if p3 = 26 then
14665: LD_VAR 0 3
14669: PUSH
14670: LD_INT 26
14672: EQUAL
14673: IFFALSE 14683
// sEarthquake := true ;
14675: LD_ADDR_EXP 74
14679: PUSH
14680: LD_INT 1
14682: ST_TO_ADDR
// if p3 = 27 then
14683: LD_VAR 0 3
14687: PUSH
14688: LD_INT 27
14690: EQUAL
14691: IFFALSE 14701
// sAI := true ;
14693: LD_ADDR_EXP 75
14697: PUSH
14698: LD_INT 1
14700: ST_TO_ADDR
// if p3 = 28 then
14701: LD_VAR 0 3
14705: PUSH
14706: LD_INT 28
14708: EQUAL
14709: IFFALSE 14719
// sCargo := true ;
14711: LD_ADDR_EXP 78
14715: PUSH
14716: LD_INT 1
14718: ST_TO_ADDR
// if p3 = 29 then
14719: LD_VAR 0 3
14723: PUSH
14724: LD_INT 29
14726: EQUAL
14727: IFFALSE 14737
// sDLaser := true ;
14729: LD_ADDR_EXP 79
14733: PUSH
14734: LD_INT 1
14736: ST_TO_ADDR
// if p3 = 30 then
14737: LD_VAR 0 3
14741: PUSH
14742: LD_INT 30
14744: EQUAL
14745: IFFALSE 14755
// sExchange := true ;
14747: LD_ADDR_EXP 80
14751: PUSH
14752: LD_INT 1
14754: ST_TO_ADDR
// if p3 = 31 then
14755: LD_VAR 0 3
14759: PUSH
14760: LD_INT 31
14762: EQUAL
14763: IFFALSE 14773
// sFac := true ;
14765: LD_ADDR_EXP 81
14769: PUSH
14770: LD_INT 1
14772: ST_TO_ADDR
// if p3 = 32 then
14773: LD_VAR 0 3
14777: PUSH
14778: LD_INT 32
14780: EQUAL
14781: IFFALSE 14791
// sPower := true ;
14783: LD_ADDR_EXP 82
14787: PUSH
14788: LD_INT 1
14790: ST_TO_ADDR
// if p3 = 33 then
14791: LD_VAR 0 3
14795: PUSH
14796: LD_INT 33
14798: EQUAL
14799: IFFALSE 14809
// sRandom := true ;
14801: LD_ADDR_EXP 83
14805: PUSH
14806: LD_INT 1
14808: ST_TO_ADDR
// if p3 = 34 then
14809: LD_VAR 0 3
14813: PUSH
14814: LD_INT 34
14816: EQUAL
14817: IFFALSE 14827
// sShield := true ;
14819: LD_ADDR_EXP 84
14823: PUSH
14824: LD_INT 1
14826: ST_TO_ADDR
// if p3 = 35 then
14827: LD_VAR 0 3
14831: PUSH
14832: LD_INT 35
14834: EQUAL
14835: IFFALSE 14845
// sTime := true ;
14837: LD_ADDR_EXP 85
14841: PUSH
14842: LD_INT 1
14844: ST_TO_ADDR
// if p3 = 36 then
14845: LD_VAR 0 3
14849: PUSH
14850: LD_INT 36
14852: EQUAL
14853: IFFALSE 14863
// sTools := true ;
14855: LD_ADDR_EXP 86
14859: PUSH
14860: LD_INT 1
14862: ST_TO_ADDR
// if p3 = 101 then
14863: LD_VAR 0 3
14867: PUSH
14868: LD_INT 101
14870: EQUAL
14871: IFFALSE 14881
// sSold := true ;
14873: LD_ADDR_EXP 51
14877: PUSH
14878: LD_INT 1
14880: ST_TO_ADDR
// if p3 = 102 then
14881: LD_VAR 0 3
14885: PUSH
14886: LD_INT 102
14888: EQUAL
14889: IFFALSE 14899
// sDiff := true ;
14891: LD_ADDR_EXP 52
14895: PUSH
14896: LD_INT 1
14898: ST_TO_ADDR
// if p3 = 103 then
14899: LD_VAR 0 3
14903: PUSH
14904: LD_INT 103
14906: EQUAL
14907: IFFALSE 14917
// sFog := true ;
14909: LD_ADDR_EXP 55
14913: PUSH
14914: LD_INT 1
14916: ST_TO_ADDR
// if p3 = 104 then
14917: LD_VAR 0 3
14921: PUSH
14922: LD_INT 104
14924: EQUAL
14925: IFFALSE 14935
// sReset := true ;
14927: LD_ADDR_EXP 56
14931: PUSH
14932: LD_INT 1
14934: ST_TO_ADDR
// if p3 = 105 then
14935: LD_VAR 0 3
14939: PUSH
14940: LD_INT 105
14942: EQUAL
14943: IFFALSE 14953
// sSun := true ;
14945: LD_ADDR_EXP 57
14949: PUSH
14950: LD_INT 1
14952: ST_TO_ADDR
// if p3 = 106 then
14953: LD_VAR 0 3
14957: PUSH
14958: LD_INT 106
14960: EQUAL
14961: IFFALSE 14971
// sTiger := true ;
14963: LD_ADDR_EXP 53
14967: PUSH
14968: LD_INT 1
14970: ST_TO_ADDR
// if p3 = 107 then
14971: LD_VAR 0 3
14975: PUSH
14976: LD_INT 107
14978: EQUAL
14979: IFFALSE 14989
// sBomb := true ;
14981: LD_ADDR_EXP 54
14985: PUSH
14986: LD_INT 1
14988: ST_TO_ADDR
// if p3 = 108 then
14989: LD_VAR 0 3
14993: PUSH
14994: LD_INT 108
14996: EQUAL
14997: IFFALSE 15007
// sWound := true ;
14999: LD_ADDR_EXP 62
15003: PUSH
15004: LD_INT 1
15006: ST_TO_ADDR
// if p3 = 109 then
15007: LD_VAR 0 3
15011: PUSH
15012: LD_INT 109
15014: EQUAL
15015: IFFALSE 15025
// sBetray := true ;
15017: LD_ADDR_EXP 66
15021: PUSH
15022: LD_INT 1
15024: ST_TO_ADDR
// if p3 = 110 then
15025: LD_VAR 0 3
15029: PUSH
15030: LD_INT 110
15032: EQUAL
15033: IFFALSE 15043
// sContamin := true ;
15035: LD_ADDR_EXP 67
15039: PUSH
15040: LD_INT 1
15042: ST_TO_ADDR
// if p3 = 111 then
15043: LD_VAR 0 3
15047: PUSH
15048: LD_INT 111
15050: EQUAL
15051: IFFALSE 15061
// sOil := true ;
15053: LD_ADDR_EXP 69
15057: PUSH
15058: LD_INT 1
15060: ST_TO_ADDR
// if p3 = 112 then
15061: LD_VAR 0 3
15065: PUSH
15066: LD_INT 112
15068: EQUAL
15069: IFFALSE 15079
// sStu := true ;
15071: LD_ADDR_EXP 73
15075: PUSH
15076: LD_INT 1
15078: ST_TO_ADDR
// if p3 = 113 then
15079: LD_VAR 0 3
15083: PUSH
15084: LD_INT 113
15086: EQUAL
15087: IFFALSE 15097
// sBazooka := true ;
15089: LD_ADDR_EXP 76
15093: PUSH
15094: LD_INT 1
15096: ST_TO_ADDR
// if p3 = 114 then
15097: LD_VAR 0 3
15101: PUSH
15102: LD_INT 114
15104: EQUAL
15105: IFFALSE 15115
// sMortar := true ;
15107: LD_ADDR_EXP 77
15111: PUSH
15112: LD_INT 1
15114: ST_TO_ADDR
// if p3 = 115 then
15115: LD_VAR 0 3
15119: PUSH
15120: LD_INT 115
15122: EQUAL
15123: IFFALSE 15133
// sRanger := true ;
15125: LD_ADDR_EXP 87
15129: PUSH
15130: LD_INT 1
15132: ST_TO_ADDR
// end ; end ;
15133: PPOPN 6
15135: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
15136: LD_EXP 34
15140: PUSH
15141: LD_EXP 39
15145: AND
15146: IFFALSE 15270
15148: GO 15150
15150: DISABLE
15151: LD_INT 0
15153: PPUSH
15154: PPUSH
// begin enable ;
15155: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
15156: LD_ADDR_VAR 0 2
15160: PUSH
15161: LD_INT 22
15163: PUSH
15164: LD_OWVAR 2
15168: PUSH
15169: EMPTY
15170: LIST
15171: LIST
15172: PUSH
15173: LD_INT 2
15175: PUSH
15176: LD_INT 34
15178: PUSH
15179: LD_INT 7
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: PUSH
15186: LD_INT 34
15188: PUSH
15189: LD_INT 45
15191: PUSH
15192: EMPTY
15193: LIST
15194: LIST
15195: PUSH
15196: LD_INT 34
15198: PUSH
15199: LD_INT 28
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PUSH
15206: LD_INT 34
15208: PUSH
15209: LD_INT 47
15211: PUSH
15212: EMPTY
15213: LIST
15214: LIST
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: PUSH
15223: EMPTY
15224: LIST
15225: LIST
15226: PPUSH
15227: CALL_OW 69
15231: ST_TO_ADDR
// if not tmp then
15232: LD_VAR 0 2
15236: NOT
15237: IFFALSE 15241
// exit ;
15239: GO 15270
// for i in tmp do
15241: LD_ADDR_VAR 0 1
15245: PUSH
15246: LD_VAR 0 2
15250: PUSH
15251: FOR_IN
15252: IFFALSE 15268
// begin SetLives ( i , 0 ) ;
15254: LD_VAR 0 1
15258: PPUSH
15259: LD_INT 0
15261: PPUSH
15262: CALL_OW 234
// end ;
15266: GO 15251
15268: POP
15269: POP
// end ;
15270: PPOPN 2
15272: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
15273: LD_EXP 34
15277: PUSH
15278: LD_EXP 40
15282: AND
15283: IFFALSE 15367
15285: GO 15287
15287: DISABLE
15288: LD_INT 0
15290: PPUSH
15291: PPUSH
// begin enable ;
15292: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
15293: LD_ADDR_VAR 0 2
15297: PUSH
15298: LD_INT 22
15300: PUSH
15301: LD_OWVAR 2
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: PUSH
15310: LD_INT 32
15312: PUSH
15313: LD_INT 3
15315: PUSH
15316: EMPTY
15317: LIST
15318: LIST
15319: PUSH
15320: EMPTY
15321: LIST
15322: LIST
15323: PPUSH
15324: CALL_OW 69
15328: ST_TO_ADDR
// if not tmp then
15329: LD_VAR 0 2
15333: NOT
15334: IFFALSE 15338
// exit ;
15336: GO 15367
// for i in tmp do
15338: LD_ADDR_VAR 0 1
15342: PUSH
15343: LD_VAR 0 2
15347: PUSH
15348: FOR_IN
15349: IFFALSE 15365
// begin SetLives ( i , 0 ) ;
15351: LD_VAR 0 1
15355: PPUSH
15356: LD_INT 0
15358: PPUSH
15359: CALL_OW 234
// end ;
15363: GO 15348
15365: POP
15366: POP
// end ;
15367: PPOPN 2
15369: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
15370: LD_EXP 34
15374: PUSH
15375: LD_EXP 37
15379: AND
15380: IFFALSE 15473
15382: GO 15384
15384: DISABLE
15385: LD_INT 0
15387: PPUSH
// begin enable ;
15388: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
15389: LD_ADDR_VAR 0 1
15393: PUSH
15394: LD_INT 22
15396: PUSH
15397: LD_OWVAR 2
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: PUSH
15406: LD_INT 2
15408: PUSH
15409: LD_INT 25
15411: PUSH
15412: LD_INT 5
15414: PUSH
15415: EMPTY
15416: LIST
15417: LIST
15418: PUSH
15419: LD_INT 25
15421: PUSH
15422: LD_INT 9
15424: PUSH
15425: EMPTY
15426: LIST
15427: LIST
15428: PUSH
15429: LD_INT 25
15431: PUSH
15432: LD_INT 8
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: PUSH
15439: EMPTY
15440: LIST
15441: LIST
15442: LIST
15443: LIST
15444: PUSH
15445: EMPTY
15446: LIST
15447: LIST
15448: PPUSH
15449: CALL_OW 69
15453: PUSH
15454: FOR_IN
15455: IFFALSE 15471
// begin SetClass ( i , 1 ) ;
15457: LD_VAR 0 1
15461: PPUSH
15462: LD_INT 1
15464: PPUSH
15465: CALL_OW 336
// end ;
15469: GO 15454
15471: POP
15472: POP
// end ;
15473: PPOPN 1
15475: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
15476: LD_EXP 34
15480: PUSH
15481: LD_EXP 38
15485: AND
15486: PUSH
15487: LD_OWVAR 65
15491: PUSH
15492: LD_INT 7
15494: LESS
15495: AND
15496: IFFALSE 15510
15498: GO 15500
15500: DISABLE
// begin enable ;
15501: ENABLE
// game_speed := 7 ;
15502: LD_ADDR_OWVAR 65
15506: PUSH
15507: LD_INT 7
15509: ST_TO_ADDR
// end ;
15510: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
15511: LD_EXP 34
15515: PUSH
15516: LD_EXP 41
15520: AND
15521: IFFALSE 15723
15523: GO 15525
15525: DISABLE
15526: LD_INT 0
15528: PPUSH
15529: PPUSH
15530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
15531: LD_ADDR_VAR 0 3
15535: PUSH
15536: LD_INT 81
15538: PUSH
15539: LD_OWVAR 2
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PUSH
15548: LD_INT 21
15550: PUSH
15551: LD_INT 1
15553: PUSH
15554: EMPTY
15555: LIST
15556: LIST
15557: PUSH
15558: EMPTY
15559: LIST
15560: LIST
15561: PPUSH
15562: CALL_OW 69
15566: ST_TO_ADDR
// if not tmp then
15567: LD_VAR 0 3
15571: NOT
15572: IFFALSE 15576
// exit ;
15574: GO 15723
// if tmp > 5 then
15576: LD_VAR 0 3
15580: PUSH
15581: LD_INT 5
15583: GREATER
15584: IFFALSE 15596
// k := 5 else
15586: LD_ADDR_VAR 0 2
15590: PUSH
15591: LD_INT 5
15593: ST_TO_ADDR
15594: GO 15606
// k := tmp ;
15596: LD_ADDR_VAR 0 2
15600: PUSH
15601: LD_VAR 0 3
15605: ST_TO_ADDR
// for i := 1 to k do
15606: LD_ADDR_VAR 0 1
15610: PUSH
15611: DOUBLE
15612: LD_INT 1
15614: DEC
15615: ST_TO_ADDR
15616: LD_VAR 0 2
15620: PUSH
15621: FOR_TO
15622: IFFALSE 15721
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
15624: LD_VAR 0 3
15628: PUSH
15629: LD_VAR 0 1
15633: ARRAY
15634: PPUSH
15635: LD_VAR 0 1
15639: PUSH
15640: LD_INT 4
15642: MOD
15643: PUSH
15644: LD_INT 1
15646: PLUS
15647: PPUSH
15648: CALL_OW 259
15652: PUSH
15653: LD_INT 10
15655: LESS
15656: IFFALSE 15719
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
15658: LD_VAR 0 3
15662: PUSH
15663: LD_VAR 0 1
15667: ARRAY
15668: PPUSH
15669: LD_VAR 0 1
15673: PUSH
15674: LD_INT 4
15676: MOD
15677: PUSH
15678: LD_INT 1
15680: PLUS
15681: PPUSH
15682: LD_VAR 0 3
15686: PUSH
15687: LD_VAR 0 1
15691: ARRAY
15692: PPUSH
15693: LD_VAR 0 1
15697: PUSH
15698: LD_INT 4
15700: MOD
15701: PUSH
15702: LD_INT 1
15704: PLUS
15705: PPUSH
15706: CALL_OW 259
15710: PUSH
15711: LD_INT 1
15713: PLUS
15714: PPUSH
15715: CALL_OW 237
15719: GO 15621
15721: POP
15722: POP
// end ;
15723: PPOPN 3
15725: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
15726: LD_EXP 34
15730: PUSH
15731: LD_EXP 42
15735: AND
15736: IFFALSE 15756
15738: GO 15740
15740: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
15741: LD_INT 4
15743: PPUSH
15744: LD_OWVAR 2
15748: PPUSH
15749: LD_INT 0
15751: PPUSH
15752: CALL_OW 324
15756: END
// every 0 0$1 trigger StreamModeActive and sShovel do
15757: LD_EXP 34
15761: PUSH
15762: LD_EXP 71
15766: AND
15767: IFFALSE 15787
15769: GO 15771
15771: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
15772: LD_INT 19
15774: PPUSH
15775: LD_OWVAR 2
15779: PPUSH
15780: LD_INT 0
15782: PPUSH
15783: CALL_OW 324
15787: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
15788: LD_EXP 34
15792: PUSH
15793: LD_EXP 43
15797: AND
15798: IFFALSE 15900
15800: GO 15802
15802: DISABLE
15803: LD_INT 0
15805: PPUSH
15806: PPUSH
// begin enable ;
15807: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
15808: LD_ADDR_VAR 0 2
15812: PUSH
15813: LD_INT 22
15815: PUSH
15816: LD_OWVAR 2
15820: PUSH
15821: EMPTY
15822: LIST
15823: LIST
15824: PUSH
15825: LD_INT 2
15827: PUSH
15828: LD_INT 34
15830: PUSH
15831: LD_INT 11
15833: PUSH
15834: EMPTY
15835: LIST
15836: LIST
15837: PUSH
15838: LD_INT 34
15840: PUSH
15841: LD_INT 30
15843: PUSH
15844: EMPTY
15845: LIST
15846: LIST
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: LIST
15852: PUSH
15853: EMPTY
15854: LIST
15855: LIST
15856: PPUSH
15857: CALL_OW 69
15861: ST_TO_ADDR
// if not tmp then
15862: LD_VAR 0 2
15866: NOT
15867: IFFALSE 15871
// exit ;
15869: GO 15900
// for i in tmp do
15871: LD_ADDR_VAR 0 1
15875: PUSH
15876: LD_VAR 0 2
15880: PUSH
15881: FOR_IN
15882: IFFALSE 15898
// begin SetLives ( i , 0 ) ;
15884: LD_VAR 0 1
15888: PPUSH
15889: LD_INT 0
15891: PPUSH
15892: CALL_OW 234
// end ;
15896: GO 15881
15898: POP
15899: POP
// end ;
15900: PPOPN 2
15902: END
// every 0 0$1 trigger StreamModeActive and sBunker do
15903: LD_EXP 34
15907: PUSH
15908: LD_EXP 44
15912: AND
15913: IFFALSE 15933
15915: GO 15917
15917: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
15918: LD_INT 32
15920: PPUSH
15921: LD_OWVAR 2
15925: PPUSH
15926: LD_INT 0
15928: PPUSH
15929: CALL_OW 324
15933: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
15934: LD_EXP 34
15938: PUSH
15939: LD_EXP 45
15943: AND
15944: IFFALSE 16125
15946: GO 15948
15948: DISABLE
15949: LD_INT 0
15951: PPUSH
15952: PPUSH
15953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
15954: LD_ADDR_VAR 0 2
15958: PUSH
15959: LD_INT 22
15961: PUSH
15962: LD_OWVAR 2
15966: PUSH
15967: EMPTY
15968: LIST
15969: LIST
15970: PUSH
15971: LD_INT 33
15973: PUSH
15974: LD_INT 3
15976: PUSH
15977: EMPTY
15978: LIST
15979: LIST
15980: PUSH
15981: EMPTY
15982: LIST
15983: LIST
15984: PPUSH
15985: CALL_OW 69
15989: ST_TO_ADDR
// if not tmp then
15990: LD_VAR 0 2
15994: NOT
15995: IFFALSE 15999
// exit ;
15997: GO 16125
// side := 0 ;
15999: LD_ADDR_VAR 0 3
16003: PUSH
16004: LD_INT 0
16006: ST_TO_ADDR
// for i := 1 to 8 do
16007: LD_ADDR_VAR 0 1
16011: PUSH
16012: DOUBLE
16013: LD_INT 1
16015: DEC
16016: ST_TO_ADDR
16017: LD_INT 8
16019: PUSH
16020: FOR_TO
16021: IFFALSE 16069
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
16023: LD_OWVAR 2
16027: PUSH
16028: LD_VAR 0 1
16032: NONEQUAL
16033: PUSH
16034: LD_OWVAR 2
16038: PPUSH
16039: LD_VAR 0 1
16043: PPUSH
16044: CALL_OW 81
16048: PUSH
16049: LD_INT 2
16051: EQUAL
16052: AND
16053: IFFALSE 16067
// begin side := i ;
16055: LD_ADDR_VAR 0 3
16059: PUSH
16060: LD_VAR 0 1
16064: ST_TO_ADDR
// break ;
16065: GO 16069
// end ;
16067: GO 16020
16069: POP
16070: POP
// if not side then
16071: LD_VAR 0 3
16075: NOT
16076: IFFALSE 16080
// exit ;
16078: GO 16125
// for i := 1 to tmp do
16080: LD_ADDR_VAR 0 1
16084: PUSH
16085: DOUBLE
16086: LD_INT 1
16088: DEC
16089: ST_TO_ADDR
16090: LD_VAR 0 2
16094: PUSH
16095: FOR_TO
16096: IFFALSE 16123
// if Prob ( 60 ) then
16098: LD_INT 60
16100: PPUSH
16101: CALL_OW 13
16105: IFFALSE 16121
// SetSide ( i , side ) ;
16107: LD_VAR 0 1
16111: PPUSH
16112: LD_VAR 0 3
16116: PPUSH
16117: CALL_OW 235
16121: GO 16095
16123: POP
16124: POP
// end ;
16125: PPOPN 3
16127: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
16128: LD_EXP 34
16132: PUSH
16133: LD_EXP 47
16137: AND
16138: IFFALSE 16257
16140: GO 16142
16142: DISABLE
16143: LD_INT 0
16145: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
16146: LD_ADDR_VAR 0 1
16150: PUSH
16151: LD_INT 22
16153: PUSH
16154: LD_OWVAR 2
16158: PUSH
16159: EMPTY
16160: LIST
16161: LIST
16162: PUSH
16163: LD_INT 21
16165: PUSH
16166: LD_INT 1
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: PUSH
16173: LD_INT 3
16175: PUSH
16176: LD_INT 23
16178: PUSH
16179: LD_INT 0
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: PUSH
16186: EMPTY
16187: LIST
16188: LIST
16189: PUSH
16190: EMPTY
16191: LIST
16192: LIST
16193: LIST
16194: PPUSH
16195: CALL_OW 69
16199: PUSH
16200: FOR_IN
16201: IFFALSE 16255
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
16203: LD_VAR 0 1
16207: PPUSH
16208: CALL_OW 257
16212: PUSH
16213: LD_INT 1
16215: PUSH
16216: LD_INT 2
16218: PUSH
16219: LD_INT 3
16221: PUSH
16222: LD_INT 4
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: LIST
16229: LIST
16230: IN
16231: IFFALSE 16253
// SetClass ( un , rand ( 1 , 4 ) ) ;
16233: LD_VAR 0 1
16237: PPUSH
16238: LD_INT 1
16240: PPUSH
16241: LD_INT 4
16243: PPUSH
16244: CALL_OW 12
16248: PPUSH
16249: CALL_OW 336
16253: GO 16200
16255: POP
16256: POP
// end ;
16257: PPOPN 1
16259: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
16260: LD_EXP 34
16264: PUSH
16265: LD_EXP 46
16269: AND
16270: IFFALSE 16349
16272: GO 16274
16274: DISABLE
16275: LD_INT 0
16277: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
16278: LD_ADDR_VAR 0 1
16282: PUSH
16283: LD_INT 22
16285: PUSH
16286: LD_OWVAR 2
16290: PUSH
16291: EMPTY
16292: LIST
16293: LIST
16294: PUSH
16295: LD_INT 21
16297: PUSH
16298: LD_INT 3
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: PPUSH
16309: CALL_OW 69
16313: ST_TO_ADDR
// if not tmp then
16314: LD_VAR 0 1
16318: NOT
16319: IFFALSE 16323
// exit ;
16321: GO 16349
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
16323: LD_VAR 0 1
16327: PUSH
16328: LD_INT 1
16330: PPUSH
16331: LD_VAR 0 1
16335: PPUSH
16336: CALL_OW 12
16340: ARRAY
16341: PPUSH
16342: LD_INT 100
16344: PPUSH
16345: CALL_OW 234
// end ;
16349: PPOPN 1
16351: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
16352: LD_EXP 34
16356: PUSH
16357: LD_EXP 48
16361: AND
16362: IFFALSE 16460
16364: GO 16366
16366: DISABLE
16367: LD_INT 0
16369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16370: LD_ADDR_VAR 0 1
16374: PUSH
16375: LD_INT 22
16377: PUSH
16378: LD_OWVAR 2
16382: PUSH
16383: EMPTY
16384: LIST
16385: LIST
16386: PUSH
16387: LD_INT 21
16389: PUSH
16390: LD_INT 1
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PUSH
16397: EMPTY
16398: LIST
16399: LIST
16400: PPUSH
16401: CALL_OW 69
16405: ST_TO_ADDR
// if not tmp then
16406: LD_VAR 0 1
16410: NOT
16411: IFFALSE 16415
// exit ;
16413: GO 16460
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
16415: LD_VAR 0 1
16419: PUSH
16420: LD_INT 1
16422: PPUSH
16423: LD_VAR 0 1
16427: PPUSH
16428: CALL_OW 12
16432: ARRAY
16433: PPUSH
16434: LD_INT 1
16436: PPUSH
16437: LD_INT 4
16439: PPUSH
16440: CALL_OW 12
16444: PPUSH
16445: LD_INT 3000
16447: PPUSH
16448: LD_INT 9000
16450: PPUSH
16451: CALL_OW 12
16455: PPUSH
16456: CALL_OW 492
// end ;
16460: PPOPN 1
16462: END
// every 0 0$1 trigger StreamModeActive and sDepot do
16463: LD_EXP 34
16467: PUSH
16468: LD_EXP 49
16472: AND
16473: IFFALSE 16493
16475: GO 16477
16477: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
16478: LD_INT 1
16480: PPUSH
16481: LD_OWVAR 2
16485: PPUSH
16486: LD_INT 0
16488: PPUSH
16489: CALL_OW 324
16493: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
16494: LD_EXP 34
16498: PUSH
16499: LD_EXP 50
16503: AND
16504: IFFALSE 16587
16506: GO 16508
16508: DISABLE
16509: LD_INT 0
16511: PPUSH
16512: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
16513: LD_ADDR_VAR 0 2
16517: PUSH
16518: LD_INT 22
16520: PUSH
16521: LD_OWVAR 2
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: PUSH
16530: LD_INT 21
16532: PUSH
16533: LD_INT 3
16535: PUSH
16536: EMPTY
16537: LIST
16538: LIST
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PPUSH
16544: CALL_OW 69
16548: ST_TO_ADDR
// if not tmp then
16549: LD_VAR 0 2
16553: NOT
16554: IFFALSE 16558
// exit ;
16556: GO 16587
// for i in tmp do
16558: LD_ADDR_VAR 0 1
16562: PUSH
16563: LD_VAR 0 2
16567: PUSH
16568: FOR_IN
16569: IFFALSE 16585
// SetBLevel ( i , 10 ) ;
16571: LD_VAR 0 1
16575: PPUSH
16576: LD_INT 10
16578: PPUSH
16579: CALL_OW 241
16583: GO 16568
16585: POP
16586: POP
// end ;
16587: PPOPN 2
16589: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
16590: LD_EXP 34
16594: PUSH
16595: LD_EXP 51
16599: AND
16600: IFFALSE 16711
16602: GO 16604
16604: DISABLE
16605: LD_INT 0
16607: PPUSH
16608: PPUSH
16609: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16610: LD_ADDR_VAR 0 3
16614: PUSH
16615: LD_INT 22
16617: PUSH
16618: LD_OWVAR 2
16622: PUSH
16623: EMPTY
16624: LIST
16625: LIST
16626: PUSH
16627: LD_INT 25
16629: PUSH
16630: LD_INT 1
16632: PUSH
16633: EMPTY
16634: LIST
16635: LIST
16636: PUSH
16637: EMPTY
16638: LIST
16639: LIST
16640: PPUSH
16641: CALL_OW 69
16645: ST_TO_ADDR
// if not tmp then
16646: LD_VAR 0 3
16650: NOT
16651: IFFALSE 16655
// exit ;
16653: GO 16711
// un := tmp [ rand ( 1 , tmp ) ] ;
16655: LD_ADDR_VAR 0 2
16659: PUSH
16660: LD_VAR 0 3
16664: PUSH
16665: LD_INT 1
16667: PPUSH
16668: LD_VAR 0 3
16672: PPUSH
16673: CALL_OW 12
16677: ARRAY
16678: ST_TO_ADDR
// if Crawls ( un ) then
16679: LD_VAR 0 2
16683: PPUSH
16684: CALL_OW 318
16688: IFFALSE 16699
// ComWalk ( un ) ;
16690: LD_VAR 0 2
16694: PPUSH
16695: CALL_OW 138
// SetClass ( un , class_sniper ) ;
16699: LD_VAR 0 2
16703: PPUSH
16704: LD_INT 5
16706: PPUSH
16707: CALL_OW 336
// end ;
16711: PPOPN 3
16713: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
16714: LD_EXP 34
16718: PUSH
16719: LD_EXP 52
16723: AND
16724: PUSH
16725: LD_OWVAR 67
16729: PUSH
16730: LD_INT 3
16732: LESS
16733: AND
16734: IFFALSE 16753
16736: GO 16738
16738: DISABLE
// Difficulty := Difficulty + 1 ;
16739: LD_ADDR_OWVAR 67
16743: PUSH
16744: LD_OWVAR 67
16748: PUSH
16749: LD_INT 1
16751: PLUS
16752: ST_TO_ADDR
16753: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
16754: LD_EXP 34
16758: PUSH
16759: LD_EXP 53
16763: AND
16764: IFFALSE 16867
16766: GO 16768
16768: DISABLE
16769: LD_INT 0
16771: PPUSH
// begin for i := 1 to 5 do
16772: LD_ADDR_VAR 0 1
16776: PUSH
16777: DOUBLE
16778: LD_INT 1
16780: DEC
16781: ST_TO_ADDR
16782: LD_INT 5
16784: PUSH
16785: FOR_TO
16786: IFFALSE 16865
// begin uc_nation := nation_nature ;
16788: LD_ADDR_OWVAR 21
16792: PUSH
16793: LD_INT 0
16795: ST_TO_ADDR
// uc_side := 0 ;
16796: LD_ADDR_OWVAR 20
16800: PUSH
16801: LD_INT 0
16803: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
16804: LD_ADDR_OWVAR 29
16808: PUSH
16809: LD_INT 12
16811: PUSH
16812: LD_INT 12
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: ST_TO_ADDR
// hc_agressivity := 20 ;
16819: LD_ADDR_OWVAR 35
16823: PUSH
16824: LD_INT 20
16826: ST_TO_ADDR
// hc_class := class_tiger ;
16827: LD_ADDR_OWVAR 28
16831: PUSH
16832: LD_INT 14
16834: ST_TO_ADDR
// hc_gallery :=  ;
16835: LD_ADDR_OWVAR 33
16839: PUSH
16840: LD_STRING 
16842: ST_TO_ADDR
// hc_name :=  ;
16843: LD_ADDR_OWVAR 26
16847: PUSH
16848: LD_STRING 
16850: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
16851: CALL_OW 44
16855: PPUSH
16856: LD_INT 0
16858: PPUSH
16859: CALL_OW 51
// end ;
16863: GO 16785
16865: POP
16866: POP
// end ;
16867: PPOPN 1
16869: END
// every 0 0$1 trigger StreamModeActive and sBomb do
16870: LD_EXP 34
16874: PUSH
16875: LD_EXP 54
16879: AND
16880: IFFALSE 16889
16882: GO 16884
16884: DISABLE
// StreamSibBomb ;
16885: CALL 16890 0 0
16889: END
// export function StreamSibBomb ; var i , x , y ; begin
16890: LD_INT 0
16892: PPUSH
16893: PPUSH
16894: PPUSH
16895: PPUSH
// result := false ;
16896: LD_ADDR_VAR 0 1
16900: PUSH
16901: LD_INT 0
16903: ST_TO_ADDR
// for i := 1 to 16 do
16904: LD_ADDR_VAR 0 2
16908: PUSH
16909: DOUBLE
16910: LD_INT 1
16912: DEC
16913: ST_TO_ADDR
16914: LD_INT 16
16916: PUSH
16917: FOR_TO
16918: IFFALSE 17117
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
16920: LD_ADDR_VAR 0 3
16924: PUSH
16925: LD_INT 10
16927: PUSH
16928: LD_INT 20
16930: PUSH
16931: LD_INT 30
16933: PUSH
16934: LD_INT 40
16936: PUSH
16937: LD_INT 50
16939: PUSH
16940: LD_INT 60
16942: PUSH
16943: LD_INT 70
16945: PUSH
16946: LD_INT 80
16948: PUSH
16949: LD_INT 90
16951: PUSH
16952: LD_INT 100
16954: PUSH
16955: LD_INT 110
16957: PUSH
16958: LD_INT 120
16960: PUSH
16961: LD_INT 130
16963: PUSH
16964: LD_INT 140
16966: PUSH
16967: LD_INT 150
16969: PUSH
16970: EMPTY
16971: LIST
16972: LIST
16973: LIST
16974: LIST
16975: LIST
16976: LIST
16977: LIST
16978: LIST
16979: LIST
16980: LIST
16981: LIST
16982: LIST
16983: LIST
16984: LIST
16985: LIST
16986: PUSH
16987: LD_INT 1
16989: PPUSH
16990: LD_INT 15
16992: PPUSH
16993: CALL_OW 12
16997: ARRAY
16998: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
16999: LD_ADDR_VAR 0 4
17003: PUSH
17004: LD_INT 10
17006: PUSH
17007: LD_INT 20
17009: PUSH
17010: LD_INT 30
17012: PUSH
17013: LD_INT 40
17015: PUSH
17016: LD_INT 50
17018: PUSH
17019: LD_INT 60
17021: PUSH
17022: LD_INT 70
17024: PUSH
17025: LD_INT 80
17027: PUSH
17028: LD_INT 90
17030: PUSH
17031: LD_INT 100
17033: PUSH
17034: LD_INT 110
17036: PUSH
17037: LD_INT 120
17039: PUSH
17040: LD_INT 130
17042: PUSH
17043: LD_INT 140
17045: PUSH
17046: LD_INT 150
17048: PUSH
17049: EMPTY
17050: LIST
17051: LIST
17052: LIST
17053: LIST
17054: LIST
17055: LIST
17056: LIST
17057: LIST
17058: LIST
17059: LIST
17060: LIST
17061: LIST
17062: LIST
17063: LIST
17064: LIST
17065: PUSH
17066: LD_INT 1
17068: PPUSH
17069: LD_INT 15
17071: PPUSH
17072: CALL_OW 12
17076: ARRAY
17077: ST_TO_ADDR
// if ValidHex ( x , y ) then
17078: LD_VAR 0 3
17082: PPUSH
17083: LD_VAR 0 4
17087: PPUSH
17088: CALL_OW 488
17092: IFFALSE 17115
// begin result := [ x , y ] ;
17094: LD_ADDR_VAR 0 1
17098: PUSH
17099: LD_VAR 0 3
17103: PUSH
17104: LD_VAR 0 4
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: ST_TO_ADDR
// break ;
17113: GO 17117
// end ; end ;
17115: GO 16917
17117: POP
17118: POP
// if result then
17119: LD_VAR 0 1
17123: IFFALSE 17183
// begin ToLua ( playSibBomb() ) ;
17125: LD_STRING playSibBomb()
17127: PPUSH
17128: CALL_OW 559
// wait ( 0 0$14 ) ;
17132: LD_INT 490
17134: PPUSH
17135: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
17139: LD_VAR 0 1
17143: PUSH
17144: LD_INT 1
17146: ARRAY
17147: PPUSH
17148: LD_VAR 0 1
17152: PUSH
17153: LD_INT 2
17155: ARRAY
17156: PPUSH
17157: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
17161: LD_VAR 0 1
17165: PUSH
17166: LD_INT 1
17168: ARRAY
17169: PPUSH
17170: LD_VAR 0 1
17174: PUSH
17175: LD_INT 2
17177: ARRAY
17178: PPUSH
17179: CALL_OW 429
// end ; end ;
17183: LD_VAR 0 1
17187: RET
// every 0 0$1 trigger StreamModeActive and sReset do
17188: LD_EXP 34
17192: PUSH
17193: LD_EXP 56
17197: AND
17198: IFFALSE 17210
17200: GO 17202
17202: DISABLE
// YouLost (  ) ;
17203: LD_STRING 
17205: PPUSH
17206: CALL_OW 104
17210: END
// every 0 0$1 trigger StreamModeActive and sFog do
17211: LD_EXP 34
17215: PUSH
17216: LD_EXP 55
17220: AND
17221: IFFALSE 17235
17223: GO 17225
17225: DISABLE
// FogOff ( your_side ) ;
17226: LD_OWVAR 2
17230: PPUSH
17231: CALL_OW 344
17235: END
// every 0 0$1 trigger StreamModeActive and sSun do
17236: LD_EXP 34
17240: PUSH
17241: LD_EXP 57
17245: AND
17246: IFFALSE 17274
17248: GO 17250
17250: DISABLE
// begin solar_recharge_percent := 0 ;
17251: LD_ADDR_OWVAR 79
17255: PUSH
17256: LD_INT 0
17258: ST_TO_ADDR
// wait ( 5 5$00 ) ;
17259: LD_INT 10500
17261: PPUSH
17262: CALL_OW 67
// solar_recharge_percent := 100 ;
17266: LD_ADDR_OWVAR 79
17270: PUSH
17271: LD_INT 100
17273: ST_TO_ADDR
// end ;
17274: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
17275: LD_EXP 34
17279: PUSH
17280: LD_EXP 58
17284: AND
17285: IFFALSE 17524
17287: GO 17289
17289: DISABLE
17290: LD_INT 0
17292: PPUSH
17293: PPUSH
17294: PPUSH
// begin tmp := [ ] ;
17295: LD_ADDR_VAR 0 3
17299: PUSH
17300: EMPTY
17301: ST_TO_ADDR
// for i := 1 to 6 do
17302: LD_ADDR_VAR 0 1
17306: PUSH
17307: DOUBLE
17308: LD_INT 1
17310: DEC
17311: ST_TO_ADDR
17312: LD_INT 6
17314: PUSH
17315: FOR_TO
17316: IFFALSE 17421
// begin uc_nation := nation_nature ;
17318: LD_ADDR_OWVAR 21
17322: PUSH
17323: LD_INT 0
17325: ST_TO_ADDR
// uc_side := 0 ;
17326: LD_ADDR_OWVAR 20
17330: PUSH
17331: LD_INT 0
17333: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17334: LD_ADDR_OWVAR 29
17338: PUSH
17339: LD_INT 12
17341: PUSH
17342: LD_INT 12
17344: PUSH
17345: EMPTY
17346: LIST
17347: LIST
17348: ST_TO_ADDR
// hc_agressivity := 20 ;
17349: LD_ADDR_OWVAR 35
17353: PUSH
17354: LD_INT 20
17356: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
17357: LD_ADDR_OWVAR 28
17361: PUSH
17362: LD_INT 17
17364: ST_TO_ADDR
// hc_gallery :=  ;
17365: LD_ADDR_OWVAR 33
17369: PUSH
17370: LD_STRING 
17372: ST_TO_ADDR
// hc_name :=  ;
17373: LD_ADDR_OWVAR 26
17377: PUSH
17378: LD_STRING 
17380: ST_TO_ADDR
// un := CreateHuman ;
17381: LD_ADDR_VAR 0 2
17385: PUSH
17386: CALL_OW 44
17390: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
17391: LD_VAR 0 2
17395: PPUSH
17396: LD_INT 1
17398: PPUSH
17399: CALL_OW 51
// tmp := tmp ^ un ;
17403: LD_ADDR_VAR 0 3
17407: PUSH
17408: LD_VAR 0 3
17412: PUSH
17413: LD_VAR 0 2
17417: ADD
17418: ST_TO_ADDR
// end ;
17419: GO 17315
17421: POP
17422: POP
// repeat wait ( 0 0$1 ) ;
17423: LD_INT 35
17425: PPUSH
17426: CALL_OW 67
// for un in tmp do
17430: LD_ADDR_VAR 0 2
17434: PUSH
17435: LD_VAR 0 3
17439: PUSH
17440: FOR_IN
17441: IFFALSE 17515
// begin if IsDead ( un ) then
17443: LD_VAR 0 2
17447: PPUSH
17448: CALL_OW 301
17452: IFFALSE 17472
// begin tmp := tmp diff un ;
17454: LD_ADDR_VAR 0 3
17458: PUSH
17459: LD_VAR 0 3
17463: PUSH
17464: LD_VAR 0 2
17468: DIFF
17469: ST_TO_ADDR
// continue ;
17470: GO 17440
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
17472: LD_VAR 0 2
17476: PPUSH
17477: LD_INT 3
17479: PUSH
17480: LD_INT 22
17482: PUSH
17483: LD_INT 0
17485: PUSH
17486: EMPTY
17487: LIST
17488: LIST
17489: PUSH
17490: EMPTY
17491: LIST
17492: LIST
17493: PPUSH
17494: CALL_OW 69
17498: PPUSH
17499: LD_VAR 0 2
17503: PPUSH
17504: CALL_OW 74
17508: PPUSH
17509: CALL_OW 115
// end ;
17513: GO 17440
17515: POP
17516: POP
// until not tmp ;
17517: LD_VAR 0 3
17521: NOT
17522: IFFALSE 17423
// end ;
17524: PPOPN 3
17526: END
// every 0 0$1 trigger StreamModeActive and sTroll do
17527: LD_EXP 34
17531: PUSH
17532: LD_EXP 59
17536: AND
17537: IFFALSE 17591
17539: GO 17541
17541: DISABLE
// begin ToLua ( displayTroll(); ) ;
17542: LD_STRING displayTroll();
17544: PPUSH
17545: CALL_OW 559
// wait ( 3 3$00 ) ;
17549: LD_INT 6300
17551: PPUSH
17552: CALL_OW 67
// ToLua ( hideTroll(); ) ;
17556: LD_STRING hideTroll();
17558: PPUSH
17559: CALL_OW 559
// wait ( 1 1$00 ) ;
17563: LD_INT 2100
17565: PPUSH
17566: CALL_OW 67
// ToLua ( displayTroll(); ) ;
17570: LD_STRING displayTroll();
17572: PPUSH
17573: CALL_OW 559
// wait ( 1 1$00 ) ;
17577: LD_INT 2100
17579: PPUSH
17580: CALL_OW 67
// ToLua ( hideTroll(); ) ;
17584: LD_STRING hideTroll();
17586: PPUSH
17587: CALL_OW 559
// end ;
17591: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
17592: LD_EXP 34
17596: PUSH
17597: LD_EXP 60
17601: AND
17602: IFFALSE 17665
17604: GO 17606
17606: DISABLE
17607: LD_INT 0
17609: PPUSH
// begin p := 0 ;
17610: LD_ADDR_VAR 0 1
17614: PUSH
17615: LD_INT 0
17617: ST_TO_ADDR
// repeat game_speed := 1 ;
17618: LD_ADDR_OWVAR 65
17622: PUSH
17623: LD_INT 1
17625: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17626: LD_INT 35
17628: PPUSH
17629: CALL_OW 67
// p := p + 1 ;
17633: LD_ADDR_VAR 0 1
17637: PUSH
17638: LD_VAR 0 1
17642: PUSH
17643: LD_INT 1
17645: PLUS
17646: ST_TO_ADDR
// until p >= 60 ;
17647: LD_VAR 0 1
17651: PUSH
17652: LD_INT 60
17654: GREATEREQUAL
17655: IFFALSE 17618
// game_speed := 4 ;
17657: LD_ADDR_OWVAR 65
17661: PUSH
17662: LD_INT 4
17664: ST_TO_ADDR
// end ;
17665: PPOPN 1
17667: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
17668: LD_EXP 34
17672: PUSH
17673: LD_EXP 61
17677: AND
17678: IFFALSE 17824
17680: GO 17682
17682: DISABLE
17683: LD_INT 0
17685: PPUSH
17686: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
17687: LD_ADDR_VAR 0 1
17691: PUSH
17692: LD_INT 22
17694: PUSH
17695: LD_OWVAR 2
17699: PUSH
17700: EMPTY
17701: LIST
17702: LIST
17703: PUSH
17704: LD_INT 2
17706: PUSH
17707: LD_INT 30
17709: PUSH
17710: LD_INT 0
17712: PUSH
17713: EMPTY
17714: LIST
17715: LIST
17716: PUSH
17717: LD_INT 30
17719: PUSH
17720: LD_INT 1
17722: PUSH
17723: EMPTY
17724: LIST
17725: LIST
17726: PUSH
17727: EMPTY
17728: LIST
17729: LIST
17730: LIST
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: PPUSH
17736: CALL_OW 69
17740: ST_TO_ADDR
// if not depot then
17741: LD_VAR 0 1
17745: NOT
17746: IFFALSE 17750
// exit ;
17748: GO 17824
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
17750: LD_ADDR_VAR 0 2
17754: PUSH
17755: LD_VAR 0 1
17759: PUSH
17760: LD_INT 1
17762: PPUSH
17763: LD_VAR 0 1
17767: PPUSH
17768: CALL_OW 12
17772: ARRAY
17773: PPUSH
17774: CALL_OW 274
17778: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
17779: LD_VAR 0 2
17783: PPUSH
17784: LD_INT 1
17786: PPUSH
17787: LD_INT 0
17789: PPUSH
17790: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
17794: LD_VAR 0 2
17798: PPUSH
17799: LD_INT 2
17801: PPUSH
17802: LD_INT 0
17804: PPUSH
17805: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
17809: LD_VAR 0 2
17813: PPUSH
17814: LD_INT 3
17816: PPUSH
17817: LD_INT 0
17819: PPUSH
17820: CALL_OW 277
// end ;
17824: PPOPN 2
17826: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
17827: LD_EXP 34
17831: PUSH
17832: LD_EXP 62
17836: AND
17837: IFFALSE 17934
17839: GO 17841
17841: DISABLE
17842: LD_INT 0
17844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
17845: LD_ADDR_VAR 0 1
17849: PUSH
17850: LD_INT 22
17852: PUSH
17853: LD_OWVAR 2
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: PUSH
17862: LD_INT 21
17864: PUSH
17865: LD_INT 1
17867: PUSH
17868: EMPTY
17869: LIST
17870: LIST
17871: PUSH
17872: LD_INT 3
17874: PUSH
17875: LD_INT 23
17877: PUSH
17878: LD_INT 0
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: LIST
17893: PPUSH
17894: CALL_OW 69
17898: ST_TO_ADDR
// if not tmp then
17899: LD_VAR 0 1
17903: NOT
17904: IFFALSE 17908
// exit ;
17906: GO 17934
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
17908: LD_VAR 0 1
17912: PUSH
17913: LD_INT 1
17915: PPUSH
17916: LD_VAR 0 1
17920: PPUSH
17921: CALL_OW 12
17925: ARRAY
17926: PPUSH
17927: LD_INT 200
17929: PPUSH
17930: CALL_OW 234
// end ;
17934: PPOPN 1
17936: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
17937: LD_EXP 34
17941: PUSH
17942: LD_EXP 63
17946: AND
17947: IFFALSE 18026
17949: GO 17951
17951: DISABLE
17952: LD_INT 0
17954: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
17955: LD_ADDR_VAR 0 1
17959: PUSH
17960: LD_INT 22
17962: PUSH
17963: LD_OWVAR 2
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: PUSH
17972: LD_INT 21
17974: PUSH
17975: LD_INT 2
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: PUSH
17982: EMPTY
17983: LIST
17984: LIST
17985: PPUSH
17986: CALL_OW 69
17990: ST_TO_ADDR
// if not tmp then
17991: LD_VAR 0 1
17995: NOT
17996: IFFALSE 18000
// exit ;
17998: GO 18026
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
18000: LD_VAR 0 1
18004: PUSH
18005: LD_INT 1
18007: PPUSH
18008: LD_VAR 0 1
18012: PPUSH
18013: CALL_OW 12
18017: ARRAY
18018: PPUSH
18019: LD_INT 60
18021: PPUSH
18022: CALL_OW 234
// end ;
18026: PPOPN 1
18028: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
18029: LD_EXP 34
18033: PUSH
18034: LD_EXP 64
18038: AND
18039: IFFALSE 18138
18041: GO 18043
18043: DISABLE
18044: LD_INT 0
18046: PPUSH
18047: PPUSH
// begin enable ;
18048: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
18049: LD_ADDR_VAR 0 1
18053: PUSH
18054: LD_INT 22
18056: PUSH
18057: LD_OWVAR 2
18061: PUSH
18062: EMPTY
18063: LIST
18064: LIST
18065: PUSH
18066: LD_INT 61
18068: PUSH
18069: EMPTY
18070: LIST
18071: PUSH
18072: LD_INT 33
18074: PUSH
18075: LD_INT 2
18077: PUSH
18078: EMPTY
18079: LIST
18080: LIST
18081: PUSH
18082: EMPTY
18083: LIST
18084: LIST
18085: LIST
18086: PPUSH
18087: CALL_OW 69
18091: ST_TO_ADDR
// if not tmp then
18092: LD_VAR 0 1
18096: NOT
18097: IFFALSE 18101
// exit ;
18099: GO 18138
// for i in tmp do
18101: LD_ADDR_VAR 0 2
18105: PUSH
18106: LD_VAR 0 1
18110: PUSH
18111: FOR_IN
18112: IFFALSE 18136
// if IsControledBy ( i ) then
18114: LD_VAR 0 2
18118: PPUSH
18119: CALL_OW 312
18123: IFFALSE 18134
// ComUnlink ( i ) ;
18125: LD_VAR 0 2
18129: PPUSH
18130: CALL_OW 136
18134: GO 18111
18136: POP
18137: POP
// end ;
18138: PPOPN 2
18140: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
18141: LD_EXP 34
18145: PUSH
18146: LD_EXP 65
18150: AND
18151: IFFALSE 18291
18153: GO 18155
18155: DISABLE
18156: LD_INT 0
18158: PPUSH
18159: PPUSH
// begin ToLua ( displayPowell(); ) ;
18160: LD_STRING displayPowell();
18162: PPUSH
18163: CALL_OW 559
// uc_side := 0 ;
18167: LD_ADDR_OWVAR 20
18171: PUSH
18172: LD_INT 0
18174: ST_TO_ADDR
// uc_nation := 2 ;
18175: LD_ADDR_OWVAR 21
18179: PUSH
18180: LD_INT 2
18182: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
18183: LD_ADDR_OWVAR 37
18187: PUSH
18188: LD_INT 14
18190: ST_TO_ADDR
// vc_engine := engine_siberite ;
18191: LD_ADDR_OWVAR 39
18195: PUSH
18196: LD_INT 3
18198: ST_TO_ADDR
// vc_control := control_apeman ;
18199: LD_ADDR_OWVAR 38
18203: PUSH
18204: LD_INT 5
18206: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
18207: LD_ADDR_OWVAR 40
18211: PUSH
18212: LD_INT 29
18214: ST_TO_ADDR
// un := CreateVehicle ;
18215: LD_ADDR_VAR 0 2
18219: PUSH
18220: CALL_OW 45
18224: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18225: LD_VAR 0 2
18229: PPUSH
18230: LD_INT 1
18232: PPUSH
18233: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18237: LD_INT 35
18239: PPUSH
18240: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18244: LD_VAR 0 2
18248: PPUSH
18249: LD_INT 22
18251: PUSH
18252: LD_OWVAR 2
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: PPUSH
18261: CALL_OW 69
18265: PPUSH
18266: LD_VAR 0 2
18270: PPUSH
18271: CALL_OW 74
18275: PPUSH
18276: CALL_OW 115
// until IsDead ( un ) ;
18280: LD_VAR 0 2
18284: PPUSH
18285: CALL_OW 301
18289: IFFALSE 18237
// end ;
18291: PPOPN 2
18293: END
// every 0 0$1 trigger StreamModeActive and sStu do
18294: LD_EXP 34
18298: PUSH
18299: LD_EXP 73
18303: AND
18304: IFFALSE 18320
18306: GO 18308
18308: DISABLE
// begin ToLua ( displayStucuk(); ) ;
18309: LD_STRING displayStucuk();
18311: PPUSH
18312: CALL_OW 559
// ResetFog ;
18316: CALL_OW 335
// end ;
18320: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
18321: LD_EXP 34
18325: PUSH
18326: LD_EXP 66
18330: AND
18331: IFFALSE 18472
18333: GO 18335
18335: DISABLE
18336: LD_INT 0
18338: PPUSH
18339: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18340: LD_ADDR_VAR 0 2
18344: PUSH
18345: LD_INT 22
18347: PUSH
18348: LD_OWVAR 2
18352: PUSH
18353: EMPTY
18354: LIST
18355: LIST
18356: PUSH
18357: LD_INT 21
18359: PUSH
18360: LD_INT 1
18362: PUSH
18363: EMPTY
18364: LIST
18365: LIST
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: PPUSH
18371: CALL_OW 69
18375: ST_TO_ADDR
// if not tmp then
18376: LD_VAR 0 2
18380: NOT
18381: IFFALSE 18385
// exit ;
18383: GO 18472
// un := tmp [ rand ( 1 , tmp ) ] ;
18385: LD_ADDR_VAR 0 1
18389: PUSH
18390: LD_VAR 0 2
18394: PUSH
18395: LD_INT 1
18397: PPUSH
18398: LD_VAR 0 2
18402: PPUSH
18403: CALL_OW 12
18407: ARRAY
18408: ST_TO_ADDR
// SetSide ( un , 0 ) ;
18409: LD_VAR 0 1
18413: PPUSH
18414: LD_INT 0
18416: PPUSH
18417: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
18421: LD_VAR 0 1
18425: PPUSH
18426: LD_OWVAR 3
18430: PUSH
18431: LD_VAR 0 1
18435: DIFF
18436: PPUSH
18437: LD_VAR 0 1
18441: PPUSH
18442: CALL_OW 74
18446: PPUSH
18447: CALL_OW 115
// wait ( 0 0$20 ) ;
18451: LD_INT 700
18453: PPUSH
18454: CALL_OW 67
// SetSide ( un , your_side ) ;
18458: LD_VAR 0 1
18462: PPUSH
18463: LD_OWVAR 2
18467: PPUSH
18468: CALL_OW 235
// end ;
18472: PPOPN 2
18474: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
18475: LD_EXP 34
18479: PUSH
18480: LD_EXP 67
18484: AND
18485: IFFALSE 18591
18487: GO 18489
18489: DISABLE
18490: LD_INT 0
18492: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18493: LD_ADDR_VAR 0 1
18497: PUSH
18498: LD_INT 22
18500: PUSH
18501: LD_OWVAR 2
18505: PUSH
18506: EMPTY
18507: LIST
18508: LIST
18509: PUSH
18510: LD_INT 2
18512: PUSH
18513: LD_INT 30
18515: PUSH
18516: LD_INT 0
18518: PUSH
18519: EMPTY
18520: LIST
18521: LIST
18522: PUSH
18523: LD_INT 30
18525: PUSH
18526: LD_INT 1
18528: PUSH
18529: EMPTY
18530: LIST
18531: LIST
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: LIST
18537: PUSH
18538: EMPTY
18539: LIST
18540: LIST
18541: PPUSH
18542: CALL_OW 69
18546: ST_TO_ADDR
// if not depot then
18547: LD_VAR 0 1
18551: NOT
18552: IFFALSE 18556
// exit ;
18554: GO 18591
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
18556: LD_VAR 0 1
18560: PUSH
18561: LD_INT 1
18563: ARRAY
18564: PPUSH
18565: CALL_OW 250
18569: PPUSH
18570: LD_VAR 0 1
18574: PUSH
18575: LD_INT 1
18577: ARRAY
18578: PPUSH
18579: CALL_OW 251
18583: PPUSH
18584: LD_INT 70
18586: PPUSH
18587: CALL_OW 495
// end ;
18591: PPOPN 1
18593: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
18594: LD_EXP 34
18598: PUSH
18599: LD_EXP 68
18603: AND
18604: IFFALSE 18815
18606: GO 18608
18608: DISABLE
18609: LD_INT 0
18611: PPUSH
18612: PPUSH
18613: PPUSH
18614: PPUSH
18615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18616: LD_ADDR_VAR 0 5
18620: PUSH
18621: LD_INT 22
18623: PUSH
18624: LD_OWVAR 2
18628: PUSH
18629: EMPTY
18630: LIST
18631: LIST
18632: PUSH
18633: LD_INT 21
18635: PUSH
18636: LD_INT 1
18638: PUSH
18639: EMPTY
18640: LIST
18641: LIST
18642: PUSH
18643: EMPTY
18644: LIST
18645: LIST
18646: PPUSH
18647: CALL_OW 69
18651: ST_TO_ADDR
// if not tmp then
18652: LD_VAR 0 5
18656: NOT
18657: IFFALSE 18661
// exit ;
18659: GO 18815
// for i in tmp do
18661: LD_ADDR_VAR 0 1
18665: PUSH
18666: LD_VAR 0 5
18670: PUSH
18671: FOR_IN
18672: IFFALSE 18813
// begin d := rand ( 0 , 5 ) ;
18674: LD_ADDR_VAR 0 4
18678: PUSH
18679: LD_INT 0
18681: PPUSH
18682: LD_INT 5
18684: PPUSH
18685: CALL_OW 12
18689: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
18690: LD_ADDR_VAR 0 2
18694: PUSH
18695: LD_VAR 0 1
18699: PPUSH
18700: CALL_OW 250
18704: PPUSH
18705: LD_VAR 0 4
18709: PPUSH
18710: LD_INT 3
18712: PPUSH
18713: LD_INT 12
18715: PPUSH
18716: CALL_OW 12
18720: PPUSH
18721: CALL_OW 272
18725: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
18726: LD_ADDR_VAR 0 3
18730: PUSH
18731: LD_VAR 0 1
18735: PPUSH
18736: CALL_OW 251
18740: PPUSH
18741: LD_VAR 0 4
18745: PPUSH
18746: LD_INT 3
18748: PPUSH
18749: LD_INT 12
18751: PPUSH
18752: CALL_OW 12
18756: PPUSH
18757: CALL_OW 273
18761: ST_TO_ADDR
// if ValidHex ( x , y ) then
18762: LD_VAR 0 2
18766: PPUSH
18767: LD_VAR 0 3
18771: PPUSH
18772: CALL_OW 488
18776: IFFALSE 18811
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
18778: LD_VAR 0 1
18782: PPUSH
18783: LD_VAR 0 2
18787: PPUSH
18788: LD_VAR 0 3
18792: PPUSH
18793: LD_INT 3
18795: PPUSH
18796: LD_INT 6
18798: PPUSH
18799: CALL_OW 12
18803: PPUSH
18804: LD_INT 1
18806: PPUSH
18807: CALL_OW 483
// end ;
18811: GO 18671
18813: POP
18814: POP
// end ;
18815: PPOPN 5
18817: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
18818: LD_EXP 34
18822: PUSH
18823: LD_EXP 69
18827: AND
18828: IFFALSE 18922
18830: GO 18832
18832: DISABLE
18833: LD_INT 0
18835: PPUSH
18836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
18837: LD_ADDR_VAR 0 2
18841: PUSH
18842: LD_INT 22
18844: PUSH
18845: LD_OWVAR 2
18849: PUSH
18850: EMPTY
18851: LIST
18852: LIST
18853: PUSH
18854: LD_INT 32
18856: PUSH
18857: LD_INT 1
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: PUSH
18864: LD_INT 21
18866: PUSH
18867: LD_INT 2
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: PUSH
18874: EMPTY
18875: LIST
18876: LIST
18877: LIST
18878: PPUSH
18879: CALL_OW 69
18883: ST_TO_ADDR
// if not tmp then
18884: LD_VAR 0 2
18888: NOT
18889: IFFALSE 18893
// exit ;
18891: GO 18922
// for i in tmp do
18893: LD_ADDR_VAR 0 1
18897: PUSH
18898: LD_VAR 0 2
18902: PUSH
18903: FOR_IN
18904: IFFALSE 18920
// SetFuel ( i , 0 ) ;
18906: LD_VAR 0 1
18910: PPUSH
18911: LD_INT 0
18913: PPUSH
18914: CALL_OW 240
18918: GO 18903
18920: POP
18921: POP
// end ;
18922: PPOPN 2
18924: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
18925: LD_EXP 34
18929: PUSH
18930: LD_EXP 70
18934: AND
18935: IFFALSE 19001
18937: GO 18939
18939: DISABLE
18940: LD_INT 0
18942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
18943: LD_ADDR_VAR 0 1
18947: PUSH
18948: LD_INT 22
18950: PUSH
18951: LD_OWVAR 2
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: PUSH
18960: LD_INT 30
18962: PUSH
18963: LD_INT 29
18965: PUSH
18966: EMPTY
18967: LIST
18968: LIST
18969: PUSH
18970: EMPTY
18971: LIST
18972: LIST
18973: PPUSH
18974: CALL_OW 69
18978: ST_TO_ADDR
// if not tmp then
18979: LD_VAR 0 1
18983: NOT
18984: IFFALSE 18988
// exit ;
18986: GO 19001
// DestroyUnit ( tmp [ 1 ] ) ;
18988: LD_VAR 0 1
18992: PUSH
18993: LD_INT 1
18995: ARRAY
18996: PPUSH
18997: CALL_OW 65
// end ;
19001: PPOPN 1
19003: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
19004: LD_EXP 34
19008: PUSH
19009: LD_EXP 72
19013: AND
19014: IFFALSE 19143
19016: GO 19018
19018: DISABLE
19019: LD_INT 0
19021: PPUSH
// begin uc_side := 0 ;
19022: LD_ADDR_OWVAR 20
19026: PUSH
19027: LD_INT 0
19029: ST_TO_ADDR
// uc_nation := nation_arabian ;
19030: LD_ADDR_OWVAR 21
19034: PUSH
19035: LD_INT 2
19037: ST_TO_ADDR
// hc_gallery :=  ;
19038: LD_ADDR_OWVAR 33
19042: PUSH
19043: LD_STRING 
19045: ST_TO_ADDR
// hc_name :=  ;
19046: LD_ADDR_OWVAR 26
19050: PUSH
19051: LD_STRING 
19053: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
19054: LD_INT 1
19056: PPUSH
19057: LD_INT 11
19059: PPUSH
19060: LD_INT 10
19062: PPUSH
19063: CALL_OW 380
// un := CreateHuman ;
19067: LD_ADDR_VAR 0 1
19071: PUSH
19072: CALL_OW 44
19076: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19077: LD_VAR 0 1
19081: PPUSH
19082: LD_INT 1
19084: PPUSH
19085: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19089: LD_INT 35
19091: PPUSH
19092: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19096: LD_VAR 0 1
19100: PPUSH
19101: LD_INT 22
19103: PUSH
19104: LD_OWVAR 2
19108: PUSH
19109: EMPTY
19110: LIST
19111: LIST
19112: PPUSH
19113: CALL_OW 69
19117: PPUSH
19118: LD_VAR 0 1
19122: PPUSH
19123: CALL_OW 74
19127: PPUSH
19128: CALL_OW 115
// until IsDead ( un ) ;
19132: LD_VAR 0 1
19136: PPUSH
19137: CALL_OW 301
19141: IFFALSE 19089
// end ;
19143: PPOPN 1
19145: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
19146: LD_EXP 34
19150: PUSH
19151: LD_EXP 74
19155: AND
19156: IFFALSE 19168
19158: GO 19160
19160: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
19161: LD_STRING earthquake(getX(game), 0, 32)
19163: PPUSH
19164: CALL_OW 559
19168: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
19169: LD_EXP 34
19173: PUSH
19174: LD_EXP 75
19178: AND
19179: IFFALSE 19270
19181: GO 19183
19183: DISABLE
19184: LD_INT 0
19186: PPUSH
// begin enable ;
19187: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
19188: LD_ADDR_VAR 0 1
19192: PUSH
19193: LD_INT 22
19195: PUSH
19196: LD_OWVAR 2
19200: PUSH
19201: EMPTY
19202: LIST
19203: LIST
19204: PUSH
19205: LD_INT 21
19207: PUSH
19208: LD_INT 2
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: PUSH
19215: LD_INT 33
19217: PUSH
19218: LD_INT 3
19220: PUSH
19221: EMPTY
19222: LIST
19223: LIST
19224: PUSH
19225: EMPTY
19226: LIST
19227: LIST
19228: LIST
19229: PPUSH
19230: CALL_OW 69
19234: ST_TO_ADDR
// if not tmp then
19235: LD_VAR 0 1
19239: NOT
19240: IFFALSE 19244
// exit ;
19242: GO 19270
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19244: LD_VAR 0 1
19248: PUSH
19249: LD_INT 1
19251: PPUSH
19252: LD_VAR 0 1
19256: PPUSH
19257: CALL_OW 12
19261: ARRAY
19262: PPUSH
19263: LD_INT 1
19265: PPUSH
19266: CALL_OW 234
// end ;
19270: PPOPN 1
19272: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
19273: LD_EXP 34
19277: PUSH
19278: LD_EXP 76
19282: AND
19283: IFFALSE 19424
19285: GO 19287
19287: DISABLE
19288: LD_INT 0
19290: PPUSH
19291: PPUSH
19292: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19293: LD_ADDR_VAR 0 3
19297: PUSH
19298: LD_INT 22
19300: PUSH
19301: LD_OWVAR 2
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: PUSH
19310: LD_INT 25
19312: PUSH
19313: LD_INT 1
19315: PUSH
19316: EMPTY
19317: LIST
19318: LIST
19319: PUSH
19320: EMPTY
19321: LIST
19322: LIST
19323: PPUSH
19324: CALL_OW 69
19328: ST_TO_ADDR
// if not tmp then
19329: LD_VAR 0 3
19333: NOT
19334: IFFALSE 19338
// exit ;
19336: GO 19424
// un := tmp [ rand ( 1 , tmp ) ] ;
19338: LD_ADDR_VAR 0 2
19342: PUSH
19343: LD_VAR 0 3
19347: PUSH
19348: LD_INT 1
19350: PPUSH
19351: LD_VAR 0 3
19355: PPUSH
19356: CALL_OW 12
19360: ARRAY
19361: ST_TO_ADDR
// if Crawls ( un ) then
19362: LD_VAR 0 2
19366: PPUSH
19367: CALL_OW 318
19371: IFFALSE 19382
// ComWalk ( un ) ;
19373: LD_VAR 0 2
19377: PPUSH
19378: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
19382: LD_VAR 0 2
19386: PPUSH
19387: LD_INT 9
19389: PPUSH
19390: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
19394: LD_INT 28
19396: PPUSH
19397: LD_OWVAR 2
19401: PPUSH
19402: LD_INT 2
19404: PPUSH
19405: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
19409: LD_INT 29
19411: PPUSH
19412: LD_OWVAR 2
19416: PPUSH
19417: LD_INT 2
19419: PPUSH
19420: CALL_OW 322
// end ;
19424: PPOPN 3
19426: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
19427: LD_EXP 34
19431: PUSH
19432: LD_EXP 77
19436: AND
19437: IFFALSE 19548
19439: GO 19441
19441: DISABLE
19442: LD_INT 0
19444: PPUSH
19445: PPUSH
19446: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19447: LD_ADDR_VAR 0 3
19451: PUSH
19452: LD_INT 22
19454: PUSH
19455: LD_OWVAR 2
19459: PUSH
19460: EMPTY
19461: LIST
19462: LIST
19463: PUSH
19464: LD_INT 25
19466: PUSH
19467: LD_INT 1
19469: PUSH
19470: EMPTY
19471: LIST
19472: LIST
19473: PUSH
19474: EMPTY
19475: LIST
19476: LIST
19477: PPUSH
19478: CALL_OW 69
19482: ST_TO_ADDR
// if not tmp then
19483: LD_VAR 0 3
19487: NOT
19488: IFFALSE 19492
// exit ;
19490: GO 19548
// un := tmp [ rand ( 1 , tmp ) ] ;
19492: LD_ADDR_VAR 0 2
19496: PUSH
19497: LD_VAR 0 3
19501: PUSH
19502: LD_INT 1
19504: PPUSH
19505: LD_VAR 0 3
19509: PPUSH
19510: CALL_OW 12
19514: ARRAY
19515: ST_TO_ADDR
// if Crawls ( un ) then
19516: LD_VAR 0 2
19520: PPUSH
19521: CALL_OW 318
19525: IFFALSE 19536
// ComWalk ( un ) ;
19527: LD_VAR 0 2
19531: PPUSH
19532: CALL_OW 138
// SetClass ( un , class_mortar ) ;
19536: LD_VAR 0 2
19540: PPUSH
19541: LD_INT 8
19543: PPUSH
19544: CALL_OW 336
// end ;
19548: PPOPN 3
19550: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
19551: LD_EXP 34
19555: PUSH
19556: LD_EXP 78
19560: AND
19561: IFFALSE 19705
19563: GO 19565
19565: DISABLE
19566: LD_INT 0
19568: PPUSH
19569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
19570: LD_ADDR_VAR 0 2
19574: PUSH
19575: LD_INT 22
19577: PUSH
19578: LD_OWVAR 2
19582: PUSH
19583: EMPTY
19584: LIST
19585: LIST
19586: PUSH
19587: LD_INT 21
19589: PUSH
19590: LD_INT 2
19592: PUSH
19593: EMPTY
19594: LIST
19595: LIST
19596: PUSH
19597: LD_INT 2
19599: PUSH
19600: LD_INT 34
19602: PUSH
19603: LD_INT 12
19605: PUSH
19606: EMPTY
19607: LIST
19608: LIST
19609: PUSH
19610: LD_INT 34
19612: PUSH
19613: LD_INT 51
19615: PUSH
19616: EMPTY
19617: LIST
19618: LIST
19619: PUSH
19620: LD_INT 34
19622: PUSH
19623: LD_INT 32
19625: PUSH
19626: EMPTY
19627: LIST
19628: LIST
19629: PUSH
19630: EMPTY
19631: LIST
19632: LIST
19633: LIST
19634: LIST
19635: PUSH
19636: EMPTY
19637: LIST
19638: LIST
19639: LIST
19640: PPUSH
19641: CALL_OW 69
19645: ST_TO_ADDR
// if not tmp then
19646: LD_VAR 0 2
19650: NOT
19651: IFFALSE 19655
// exit ;
19653: GO 19705
// for i in tmp do
19655: LD_ADDR_VAR 0 1
19659: PUSH
19660: LD_VAR 0 2
19664: PUSH
19665: FOR_IN
19666: IFFALSE 19703
// if GetCargo ( i , mat_artifact ) = 0 then
19668: LD_VAR 0 1
19672: PPUSH
19673: LD_INT 4
19675: PPUSH
19676: CALL_OW 289
19680: PUSH
19681: LD_INT 0
19683: EQUAL
19684: IFFALSE 19701
// SetCargo ( i , mat_siberit , 100 ) ;
19686: LD_VAR 0 1
19690: PPUSH
19691: LD_INT 3
19693: PPUSH
19694: LD_INT 100
19696: PPUSH
19697: CALL_OW 290
19701: GO 19665
19703: POP
19704: POP
// end ;
19705: PPOPN 2
19707: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
19708: LD_EXP 34
19712: PUSH
19713: LD_EXP 79
19717: AND
19718: IFFALSE 19871
19720: GO 19722
19722: DISABLE
19723: LD_INT 0
19725: PPUSH
19726: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
19727: LD_ADDR_VAR 0 2
19731: PUSH
19732: LD_INT 22
19734: PUSH
19735: LD_OWVAR 2
19739: PUSH
19740: EMPTY
19741: LIST
19742: LIST
19743: PPUSH
19744: CALL_OW 69
19748: ST_TO_ADDR
// if not tmp then
19749: LD_VAR 0 2
19753: NOT
19754: IFFALSE 19758
// exit ;
19756: GO 19871
// for i := 1 to 2 do
19758: LD_ADDR_VAR 0 1
19762: PUSH
19763: DOUBLE
19764: LD_INT 1
19766: DEC
19767: ST_TO_ADDR
19768: LD_INT 2
19770: PUSH
19771: FOR_TO
19772: IFFALSE 19869
// begin uc_side := your_side ;
19774: LD_ADDR_OWVAR 20
19778: PUSH
19779: LD_OWVAR 2
19783: ST_TO_ADDR
// uc_nation := nation_american ;
19784: LD_ADDR_OWVAR 21
19788: PUSH
19789: LD_INT 1
19791: ST_TO_ADDR
// vc_chassis := us_morphling ;
19792: LD_ADDR_OWVAR 37
19796: PUSH
19797: LD_INT 5
19799: ST_TO_ADDR
// vc_engine := engine_siberite ;
19800: LD_ADDR_OWVAR 39
19804: PUSH
19805: LD_INT 3
19807: ST_TO_ADDR
// vc_control := control_computer ;
19808: LD_ADDR_OWVAR 38
19812: PUSH
19813: LD_INT 3
19815: ST_TO_ADDR
// vc_weapon := us_double_laser ;
19816: LD_ADDR_OWVAR 40
19820: PUSH
19821: LD_INT 10
19823: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
19824: CALL_OW 45
19828: PPUSH
19829: LD_VAR 0 2
19833: PUSH
19834: LD_INT 1
19836: ARRAY
19837: PPUSH
19838: CALL_OW 250
19842: PPUSH
19843: LD_VAR 0 2
19847: PUSH
19848: LD_INT 1
19850: ARRAY
19851: PPUSH
19852: CALL_OW 251
19856: PPUSH
19857: LD_INT 12
19859: PPUSH
19860: LD_INT 1
19862: PPUSH
19863: CALL_OW 50
// end ;
19867: GO 19771
19869: POP
19870: POP
// end ;
19871: PPOPN 2
19873: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
19874: LD_EXP 34
19878: PUSH
19879: LD_EXP 80
19883: AND
19884: IFFALSE 20106
19886: GO 19888
19888: DISABLE
19889: LD_INT 0
19891: PPUSH
19892: PPUSH
19893: PPUSH
19894: PPUSH
19895: PPUSH
19896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19897: LD_ADDR_VAR 0 6
19901: PUSH
19902: LD_INT 22
19904: PUSH
19905: LD_OWVAR 2
19909: PUSH
19910: EMPTY
19911: LIST
19912: LIST
19913: PUSH
19914: LD_INT 21
19916: PUSH
19917: LD_INT 1
19919: PUSH
19920: EMPTY
19921: LIST
19922: LIST
19923: PUSH
19924: LD_INT 3
19926: PUSH
19927: LD_INT 23
19929: PUSH
19930: LD_INT 0
19932: PUSH
19933: EMPTY
19934: LIST
19935: LIST
19936: PUSH
19937: EMPTY
19938: LIST
19939: LIST
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: PPUSH
19946: CALL_OW 69
19950: ST_TO_ADDR
// if not tmp then
19951: LD_VAR 0 6
19955: NOT
19956: IFFALSE 19960
// exit ;
19958: GO 20106
// s1 := rand ( 1 , 4 ) ;
19960: LD_ADDR_VAR 0 2
19964: PUSH
19965: LD_INT 1
19967: PPUSH
19968: LD_INT 4
19970: PPUSH
19971: CALL_OW 12
19975: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
19976: LD_ADDR_VAR 0 4
19980: PUSH
19981: LD_VAR 0 6
19985: PUSH
19986: LD_INT 1
19988: ARRAY
19989: PPUSH
19990: LD_VAR 0 2
19994: PPUSH
19995: CALL_OW 259
19999: ST_TO_ADDR
// if s1 = 1 then
20000: LD_VAR 0 2
20004: PUSH
20005: LD_INT 1
20007: EQUAL
20008: IFFALSE 20028
// s2 := rand ( 2 , 4 ) else
20010: LD_ADDR_VAR 0 3
20014: PUSH
20015: LD_INT 2
20017: PPUSH
20018: LD_INT 4
20020: PPUSH
20021: CALL_OW 12
20025: ST_TO_ADDR
20026: GO 20036
// s2 := 1 ;
20028: LD_ADDR_VAR 0 3
20032: PUSH
20033: LD_INT 1
20035: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
20036: LD_ADDR_VAR 0 5
20040: PUSH
20041: LD_VAR 0 6
20045: PUSH
20046: LD_INT 1
20048: ARRAY
20049: PPUSH
20050: LD_VAR 0 3
20054: PPUSH
20055: CALL_OW 259
20059: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
20060: LD_VAR 0 6
20064: PUSH
20065: LD_INT 1
20067: ARRAY
20068: PPUSH
20069: LD_VAR 0 2
20073: PPUSH
20074: LD_VAR 0 5
20078: PPUSH
20079: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
20083: LD_VAR 0 6
20087: PUSH
20088: LD_INT 1
20090: ARRAY
20091: PPUSH
20092: LD_VAR 0 3
20096: PPUSH
20097: LD_VAR 0 4
20101: PPUSH
20102: CALL_OW 237
// end ;
20106: PPOPN 6
20108: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
20109: LD_EXP 34
20113: PUSH
20114: LD_EXP 81
20118: AND
20119: IFFALSE 20198
20121: GO 20123
20123: DISABLE
20124: LD_INT 0
20126: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
20127: LD_ADDR_VAR 0 1
20131: PUSH
20132: LD_INT 22
20134: PUSH
20135: LD_OWVAR 2
20139: PUSH
20140: EMPTY
20141: LIST
20142: LIST
20143: PUSH
20144: LD_INT 30
20146: PUSH
20147: LD_INT 3
20149: PUSH
20150: EMPTY
20151: LIST
20152: LIST
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PPUSH
20158: CALL_OW 69
20162: ST_TO_ADDR
// if not tmp then
20163: LD_VAR 0 1
20167: NOT
20168: IFFALSE 20172
// exit ;
20170: GO 20198
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20172: LD_VAR 0 1
20176: PUSH
20177: LD_INT 1
20179: PPUSH
20180: LD_VAR 0 1
20184: PPUSH
20185: CALL_OW 12
20189: ARRAY
20190: PPUSH
20191: LD_INT 1
20193: PPUSH
20194: CALL_OW 234
// end ;
20198: PPOPN 1
20200: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
20201: LD_EXP 34
20205: PUSH
20206: LD_EXP 82
20210: AND
20211: IFFALSE 20323
20213: GO 20215
20215: DISABLE
20216: LD_INT 0
20218: PPUSH
20219: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
20220: LD_ADDR_VAR 0 2
20224: PUSH
20225: LD_INT 22
20227: PUSH
20228: LD_OWVAR 2
20232: PUSH
20233: EMPTY
20234: LIST
20235: LIST
20236: PUSH
20237: LD_INT 2
20239: PUSH
20240: LD_INT 30
20242: PUSH
20243: LD_INT 27
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: PUSH
20250: LD_INT 30
20252: PUSH
20253: LD_INT 26
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: PUSH
20260: LD_INT 30
20262: PUSH
20263: LD_INT 28
20265: PUSH
20266: EMPTY
20267: LIST
20268: LIST
20269: PUSH
20270: EMPTY
20271: LIST
20272: LIST
20273: LIST
20274: LIST
20275: PUSH
20276: EMPTY
20277: LIST
20278: LIST
20279: PPUSH
20280: CALL_OW 69
20284: ST_TO_ADDR
// if not tmp then
20285: LD_VAR 0 2
20289: NOT
20290: IFFALSE 20294
// exit ;
20292: GO 20323
// for i in tmp do
20294: LD_ADDR_VAR 0 1
20298: PUSH
20299: LD_VAR 0 2
20303: PUSH
20304: FOR_IN
20305: IFFALSE 20321
// SetLives ( i , 1 ) ;
20307: LD_VAR 0 1
20311: PPUSH
20312: LD_INT 1
20314: PPUSH
20315: CALL_OW 234
20319: GO 20304
20321: POP
20322: POP
// end ;
20323: PPOPN 2
20325: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
20326: LD_EXP 34
20330: PUSH
20331: LD_EXP 83
20335: AND
20336: IFFALSE 20610
20338: GO 20340
20340: DISABLE
20341: LD_INT 0
20343: PPUSH
20344: PPUSH
20345: PPUSH
// begin i := rand ( 1 , 7 ) ;
20346: LD_ADDR_VAR 0 1
20350: PUSH
20351: LD_INT 1
20353: PPUSH
20354: LD_INT 7
20356: PPUSH
20357: CALL_OW 12
20361: ST_TO_ADDR
// case i of 1 :
20362: LD_VAR 0 1
20366: PUSH
20367: LD_INT 1
20369: DOUBLE
20370: EQUAL
20371: IFTRUE 20375
20373: GO 20385
20375: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
20376: LD_STRING earthquake(getX(game), 0, 32)
20378: PPUSH
20379: CALL_OW 559
20383: GO 20610
20385: LD_INT 2
20387: DOUBLE
20388: EQUAL
20389: IFTRUE 20393
20391: GO 20407
20393: POP
// begin ToLua ( displayStucuk(); ) ;
20394: LD_STRING displayStucuk();
20396: PPUSH
20397: CALL_OW 559
// ResetFog ;
20401: CALL_OW 335
// end ; 3 :
20405: GO 20610
20407: LD_INT 3
20409: DOUBLE
20410: EQUAL
20411: IFTRUE 20415
20413: GO 20519
20415: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20416: LD_ADDR_VAR 0 2
20420: PUSH
20421: LD_INT 22
20423: PUSH
20424: LD_OWVAR 2
20428: PUSH
20429: EMPTY
20430: LIST
20431: LIST
20432: PUSH
20433: LD_INT 25
20435: PUSH
20436: LD_INT 1
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: PUSH
20443: EMPTY
20444: LIST
20445: LIST
20446: PPUSH
20447: CALL_OW 69
20451: ST_TO_ADDR
// if not tmp then
20452: LD_VAR 0 2
20456: NOT
20457: IFFALSE 20461
// exit ;
20459: GO 20610
// un := tmp [ rand ( 1 , tmp ) ] ;
20461: LD_ADDR_VAR 0 3
20465: PUSH
20466: LD_VAR 0 2
20470: PUSH
20471: LD_INT 1
20473: PPUSH
20474: LD_VAR 0 2
20478: PPUSH
20479: CALL_OW 12
20483: ARRAY
20484: ST_TO_ADDR
// if Crawls ( un ) then
20485: LD_VAR 0 3
20489: PPUSH
20490: CALL_OW 318
20494: IFFALSE 20505
// ComWalk ( un ) ;
20496: LD_VAR 0 3
20500: PPUSH
20501: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20505: LD_VAR 0 3
20509: PPUSH
20510: LD_INT 8
20512: PPUSH
20513: CALL_OW 336
// end ; 4 :
20517: GO 20610
20519: LD_INT 4
20521: DOUBLE
20522: EQUAL
20523: IFTRUE 20527
20525: GO 20588
20527: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20528: LD_ADDR_VAR 0 2
20532: PUSH
20533: LD_INT 22
20535: PUSH
20536: LD_OWVAR 2
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: PUSH
20545: LD_INT 30
20547: PUSH
20548: LD_INT 29
20550: PUSH
20551: EMPTY
20552: LIST
20553: LIST
20554: PUSH
20555: EMPTY
20556: LIST
20557: LIST
20558: PPUSH
20559: CALL_OW 69
20563: ST_TO_ADDR
// if not tmp then
20564: LD_VAR 0 2
20568: NOT
20569: IFFALSE 20573
// exit ;
20571: GO 20610
// DestroyUnit ( tmp [ 1 ] ) ;
20573: LD_VAR 0 2
20577: PUSH
20578: LD_INT 1
20580: ARRAY
20581: PPUSH
20582: CALL_OW 65
// end ; 5 .. 7 :
20586: GO 20610
20588: LD_INT 5
20590: DOUBLE
20591: GREATEREQUAL
20592: IFFALSE 20600
20594: LD_INT 7
20596: DOUBLE
20597: LESSEQUAL
20598: IFTRUE 20602
20600: GO 20609
20602: POP
// StreamSibBomb ; end ;
20603: CALL 16890 0 0
20607: GO 20610
20609: POP
// end ;
20610: PPOPN 3
20612: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
20613: LD_EXP 34
20617: PUSH
20618: LD_EXP 84
20622: AND
20623: IFFALSE 20779
20625: GO 20627
20627: DISABLE
20628: LD_INT 0
20630: PPUSH
20631: PPUSH
20632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
20633: LD_ADDR_VAR 0 2
20637: PUSH
20638: LD_INT 81
20640: PUSH
20641: LD_OWVAR 2
20645: PUSH
20646: EMPTY
20647: LIST
20648: LIST
20649: PUSH
20650: LD_INT 2
20652: PUSH
20653: LD_INT 21
20655: PUSH
20656: LD_INT 1
20658: PUSH
20659: EMPTY
20660: LIST
20661: LIST
20662: PUSH
20663: LD_INT 21
20665: PUSH
20666: LD_INT 2
20668: PUSH
20669: EMPTY
20670: LIST
20671: LIST
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: LIST
20677: PUSH
20678: EMPTY
20679: LIST
20680: LIST
20681: PPUSH
20682: CALL_OW 69
20686: ST_TO_ADDR
// if not tmp then
20687: LD_VAR 0 2
20691: NOT
20692: IFFALSE 20696
// exit ;
20694: GO 20779
// p := 0 ;
20696: LD_ADDR_VAR 0 3
20700: PUSH
20701: LD_INT 0
20703: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20704: LD_INT 35
20706: PPUSH
20707: CALL_OW 67
// p := p + 1 ;
20711: LD_ADDR_VAR 0 3
20715: PUSH
20716: LD_VAR 0 3
20720: PUSH
20721: LD_INT 1
20723: PLUS
20724: ST_TO_ADDR
// for i in tmp do
20725: LD_ADDR_VAR 0 1
20729: PUSH
20730: LD_VAR 0 2
20734: PUSH
20735: FOR_IN
20736: IFFALSE 20767
// if GetLives ( i ) < 1000 then
20738: LD_VAR 0 1
20742: PPUSH
20743: CALL_OW 256
20747: PUSH
20748: LD_INT 1000
20750: LESS
20751: IFFALSE 20765
// SetLives ( i , 1000 ) ;
20753: LD_VAR 0 1
20757: PPUSH
20758: LD_INT 1000
20760: PPUSH
20761: CALL_OW 234
20765: GO 20735
20767: POP
20768: POP
// until p > 20 ;
20769: LD_VAR 0 3
20773: PUSH
20774: LD_INT 20
20776: GREATER
20777: IFFALSE 20704
// end ;
20779: PPOPN 3
20781: END
// every 0 0$1 trigger StreamModeActive and sTime do
20782: LD_EXP 34
20786: PUSH
20787: LD_EXP 85
20791: AND
20792: IFFALSE 20827
20794: GO 20796
20796: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
20797: LD_INT 28
20799: PPUSH
20800: LD_OWVAR 2
20804: PPUSH
20805: LD_INT 2
20807: PPUSH
20808: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
20812: LD_INT 30
20814: PPUSH
20815: LD_OWVAR 2
20819: PPUSH
20820: LD_INT 2
20822: PPUSH
20823: CALL_OW 322
// end ;
20827: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
20828: LD_EXP 34
20832: PUSH
20833: LD_EXP 86
20837: AND
20838: IFFALSE 20959
20840: GO 20842
20842: DISABLE
20843: LD_INT 0
20845: PPUSH
20846: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20847: LD_ADDR_VAR 0 2
20851: PUSH
20852: LD_INT 22
20854: PUSH
20855: LD_OWVAR 2
20859: PUSH
20860: EMPTY
20861: LIST
20862: LIST
20863: PUSH
20864: LD_INT 21
20866: PUSH
20867: LD_INT 1
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: PUSH
20874: LD_INT 3
20876: PUSH
20877: LD_INT 23
20879: PUSH
20880: LD_INT 0
20882: PUSH
20883: EMPTY
20884: LIST
20885: LIST
20886: PUSH
20887: EMPTY
20888: LIST
20889: LIST
20890: PUSH
20891: EMPTY
20892: LIST
20893: LIST
20894: LIST
20895: PPUSH
20896: CALL_OW 69
20900: ST_TO_ADDR
// if not tmp then
20901: LD_VAR 0 2
20905: NOT
20906: IFFALSE 20910
// exit ;
20908: GO 20959
// for i in tmp do
20910: LD_ADDR_VAR 0 1
20914: PUSH
20915: LD_VAR 0 2
20919: PUSH
20920: FOR_IN
20921: IFFALSE 20957
// begin if Crawls ( i ) then
20923: LD_VAR 0 1
20927: PPUSH
20928: CALL_OW 318
20932: IFFALSE 20943
// ComWalk ( i ) ;
20934: LD_VAR 0 1
20938: PPUSH
20939: CALL_OW 138
// SetClass ( i , 2 ) ;
20943: LD_VAR 0 1
20947: PPUSH
20948: LD_INT 2
20950: PPUSH
20951: CALL_OW 336
// end ;
20955: GO 20920
20957: POP
20958: POP
// end ;
20959: PPOPN 2
20961: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
20962: LD_EXP 34
20966: PUSH
20967: LD_EXP 87
20971: AND
20972: IFFALSE 21253
20974: GO 20976
20976: DISABLE
20977: LD_INT 0
20979: PPUSH
20980: PPUSH
20981: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
20982: LD_OWVAR 2
20986: PPUSH
20987: LD_INT 9
20989: PPUSH
20990: LD_INT 1
20992: PPUSH
20993: LD_INT 1
20995: PPUSH
20996: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
21000: LD_INT 9
21002: PPUSH
21003: LD_OWVAR 2
21007: PPUSH
21008: CALL_OW 343
// uc_side := 9 ;
21012: LD_ADDR_OWVAR 20
21016: PUSH
21017: LD_INT 9
21019: ST_TO_ADDR
// uc_nation := 2 ;
21020: LD_ADDR_OWVAR 21
21024: PUSH
21025: LD_INT 2
21027: ST_TO_ADDR
// hc_name := Dark Warrior ;
21028: LD_ADDR_OWVAR 26
21032: PUSH
21033: LD_STRING Dark Warrior
21035: ST_TO_ADDR
// hc_gallery :=  ;
21036: LD_ADDR_OWVAR 33
21040: PUSH
21041: LD_STRING 
21043: ST_TO_ADDR
// hc_noskilllimit := true ;
21044: LD_ADDR_OWVAR 76
21048: PUSH
21049: LD_INT 1
21051: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
21052: LD_ADDR_OWVAR 31
21056: PUSH
21057: LD_INT 30
21059: PUSH
21060: LD_INT 30
21062: PUSH
21063: LD_INT 30
21065: PUSH
21066: LD_INT 30
21068: PUSH
21069: EMPTY
21070: LIST
21071: LIST
21072: LIST
21073: LIST
21074: ST_TO_ADDR
// un := CreateHuman ;
21075: LD_ADDR_VAR 0 3
21079: PUSH
21080: CALL_OW 44
21084: ST_TO_ADDR
// hc_noskilllimit := false ;
21085: LD_ADDR_OWVAR 76
21089: PUSH
21090: LD_INT 0
21092: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21093: LD_VAR 0 3
21097: PPUSH
21098: LD_INT 1
21100: PPUSH
21101: CALL_OW 51
// p := 0 ;
21105: LD_ADDR_VAR 0 2
21109: PUSH
21110: LD_INT 0
21112: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21113: LD_INT 35
21115: PPUSH
21116: CALL_OW 67
// p := p + 1 ;
21120: LD_ADDR_VAR 0 2
21124: PUSH
21125: LD_VAR 0 2
21129: PUSH
21130: LD_INT 1
21132: PLUS
21133: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
21134: LD_VAR 0 3
21138: PPUSH
21139: CALL_OW 256
21143: PUSH
21144: LD_INT 1000
21146: LESS
21147: IFFALSE 21161
// SetLives ( un , 1000 ) ;
21149: LD_VAR 0 3
21153: PPUSH
21154: LD_INT 1000
21156: PPUSH
21157: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
21161: LD_VAR 0 3
21165: PPUSH
21166: LD_INT 81
21168: PUSH
21169: LD_OWVAR 2
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: PUSH
21178: LD_INT 91
21180: PUSH
21181: LD_VAR 0 3
21185: PUSH
21186: LD_INT 30
21188: PUSH
21189: EMPTY
21190: LIST
21191: LIST
21192: LIST
21193: PUSH
21194: EMPTY
21195: LIST
21196: LIST
21197: PPUSH
21198: CALL_OW 69
21202: PPUSH
21203: LD_VAR 0 3
21207: PPUSH
21208: CALL_OW 74
21212: PPUSH
21213: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
21217: LD_VAR 0 2
21221: PUSH
21222: LD_INT 60
21224: GREATER
21225: PUSH
21226: LD_VAR 0 3
21230: PPUSH
21231: CALL_OW 301
21235: OR
21236: IFFALSE 21113
// if un then
21238: LD_VAR 0 3
21242: IFFALSE 21253
// RemoveUnit ( un ) ;
21244: LD_VAR 0 3
21248: PPUSH
21249: CALL_OW 64
// end ; end_of_file
21253: PPOPN 3
21255: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
21256: LD_INT 0
21258: PPUSH
21259: PPUSH
21260: PPUSH
21261: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
21262: LD_VAR 0 1
21266: PPUSH
21267: CALL_OW 264
21271: PUSH
21272: LD_EXP 33
21276: EQUAL
21277: IFFALSE 21349
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
21279: LD_INT 68
21281: PPUSH
21282: LD_VAR 0 1
21286: PPUSH
21287: CALL_OW 255
21291: PPUSH
21292: CALL_OW 321
21296: PUSH
21297: LD_INT 2
21299: EQUAL
21300: IFFALSE 21312
// eff := 70 else
21302: LD_ADDR_VAR 0 4
21306: PUSH
21307: LD_INT 70
21309: ST_TO_ADDR
21310: GO 21320
// eff := 30 ;
21312: LD_ADDR_VAR 0 4
21316: PUSH
21317: LD_INT 30
21319: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
21320: LD_VAR 0 1
21324: PPUSH
21325: CALL_OW 250
21329: PPUSH
21330: LD_VAR 0 1
21334: PPUSH
21335: CALL_OW 251
21339: PPUSH
21340: LD_VAR 0 4
21344: PPUSH
21345: CALL_OW 495
// end ; end ;
21349: LD_VAR 0 2
21353: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
21354: LD_INT 0
21356: PPUSH
// end ;
21357: LD_VAR 0 4
21361: RET
// export function SOS_Command ( cmd ) ; begin
21362: LD_INT 0
21364: PPUSH
// end ;
21365: LD_VAR 0 2
21369: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
21370: LD_VAR 0 1
21374: PUSH
21375: LD_INT 255
21377: EQUAL
21378: PUSH
21379: LD_VAR 0 2
21383: PPUSH
21384: CALL_OW 264
21388: PUSH
21389: LD_INT 14
21391: PUSH
21392: LD_INT 53
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: IN
21399: AND
21400: PUSH
21401: LD_VAR 0 4
21405: PPUSH
21406: LD_VAR 0 5
21410: PPUSH
21411: CALL_OW 488
21415: AND
21416: IFFALSE 21440
// CutTreeXYR ( unit , x , y , 12 ) ;
21418: LD_VAR 0 2
21422: PPUSH
21423: LD_VAR 0 4
21427: PPUSH
21428: LD_VAR 0 5
21432: PPUSH
21433: LD_INT 12
21435: PPUSH
21436: CALL 21443 0 4
// end ;
21440: PPOPN 5
21442: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
21443: LD_INT 0
21445: PPUSH
21446: PPUSH
21447: PPUSH
21448: PPUSH
21449: PPUSH
21450: PPUSH
21451: PPUSH
21452: PPUSH
21453: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
21454: LD_VAR 0 1
21458: NOT
21459: PUSH
21460: LD_VAR 0 2
21464: PPUSH
21465: LD_VAR 0 3
21469: PPUSH
21470: CALL_OW 488
21474: NOT
21475: OR
21476: PUSH
21477: LD_VAR 0 4
21481: NOT
21482: OR
21483: IFFALSE 21487
// exit ;
21485: GO 21827
// list := [ ] ;
21487: LD_ADDR_VAR 0 13
21491: PUSH
21492: EMPTY
21493: ST_TO_ADDR
// if x - r < 0 then
21494: LD_VAR 0 2
21498: PUSH
21499: LD_VAR 0 4
21503: MINUS
21504: PUSH
21505: LD_INT 0
21507: LESS
21508: IFFALSE 21520
// min_x := 0 else
21510: LD_ADDR_VAR 0 7
21514: PUSH
21515: LD_INT 0
21517: ST_TO_ADDR
21518: GO 21536
// min_x := x - r ;
21520: LD_ADDR_VAR 0 7
21524: PUSH
21525: LD_VAR 0 2
21529: PUSH
21530: LD_VAR 0 4
21534: MINUS
21535: ST_TO_ADDR
// if y - r < 0 then
21536: LD_VAR 0 3
21540: PUSH
21541: LD_VAR 0 4
21545: MINUS
21546: PUSH
21547: LD_INT 0
21549: LESS
21550: IFFALSE 21562
// min_y := 0 else
21552: LD_ADDR_VAR 0 8
21556: PUSH
21557: LD_INT 0
21559: ST_TO_ADDR
21560: GO 21578
// min_y := y - r ;
21562: LD_ADDR_VAR 0 8
21566: PUSH
21567: LD_VAR 0 3
21571: PUSH
21572: LD_VAR 0 4
21576: MINUS
21577: ST_TO_ADDR
// max_x := x + r ;
21578: LD_ADDR_VAR 0 9
21582: PUSH
21583: LD_VAR 0 2
21587: PUSH
21588: LD_VAR 0 4
21592: PLUS
21593: ST_TO_ADDR
// max_y := y + r ;
21594: LD_ADDR_VAR 0 10
21598: PUSH
21599: LD_VAR 0 3
21603: PUSH
21604: LD_VAR 0 4
21608: PLUS
21609: ST_TO_ADDR
// for _x = min_x to max_x do
21610: LD_ADDR_VAR 0 11
21614: PUSH
21615: DOUBLE
21616: LD_VAR 0 7
21620: DEC
21621: ST_TO_ADDR
21622: LD_VAR 0 9
21626: PUSH
21627: FOR_TO
21628: IFFALSE 21745
// for _y = min_y to max_y do
21630: LD_ADDR_VAR 0 12
21634: PUSH
21635: DOUBLE
21636: LD_VAR 0 8
21640: DEC
21641: ST_TO_ADDR
21642: LD_VAR 0 10
21646: PUSH
21647: FOR_TO
21648: IFFALSE 21741
// begin if not ValidHex ( _x , _y ) then
21650: LD_VAR 0 11
21654: PPUSH
21655: LD_VAR 0 12
21659: PPUSH
21660: CALL_OW 488
21664: NOT
21665: IFFALSE 21669
// continue ;
21667: GO 21647
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
21669: LD_VAR 0 11
21673: PPUSH
21674: LD_VAR 0 12
21678: PPUSH
21679: CALL_OW 351
21683: PUSH
21684: LD_VAR 0 11
21688: PPUSH
21689: LD_VAR 0 12
21693: PPUSH
21694: CALL_OW 554
21698: AND
21699: IFFALSE 21739
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
21701: LD_ADDR_VAR 0 13
21705: PUSH
21706: LD_VAR 0 13
21710: PPUSH
21711: LD_VAR 0 13
21715: PUSH
21716: LD_INT 1
21718: PLUS
21719: PPUSH
21720: LD_VAR 0 11
21724: PUSH
21725: LD_VAR 0 12
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: PPUSH
21734: CALL_OW 2
21738: ST_TO_ADDR
// end ;
21739: GO 21647
21741: POP
21742: POP
21743: GO 21627
21745: POP
21746: POP
// if not list then
21747: LD_VAR 0 13
21751: NOT
21752: IFFALSE 21756
// exit ;
21754: GO 21827
// for i in list do
21756: LD_ADDR_VAR 0 6
21760: PUSH
21761: LD_VAR 0 13
21765: PUSH
21766: FOR_IN
21767: IFFALSE 21825
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
21769: LD_VAR 0 1
21773: PPUSH
21774: LD_STRING M
21776: PUSH
21777: LD_VAR 0 6
21781: PUSH
21782: LD_INT 1
21784: ARRAY
21785: PUSH
21786: LD_VAR 0 6
21790: PUSH
21791: LD_INT 2
21793: ARRAY
21794: PUSH
21795: LD_INT 0
21797: PUSH
21798: LD_INT 0
21800: PUSH
21801: LD_INT 0
21803: PUSH
21804: LD_INT 0
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: LIST
21812: LIST
21813: LIST
21814: LIST
21815: PUSH
21816: EMPTY
21817: LIST
21818: PPUSH
21819: CALL_OW 447
21823: GO 21766
21825: POP
21826: POP
// end ;
21827: LD_VAR 0 5
21831: RET
