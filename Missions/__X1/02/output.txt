// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 589 0 0
// PrepareAmericans ;
  23: CALL 835 0 0
// PrepareArabian ;
  27: CALL 9907 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 198 0 0
// Action ;
  41: CALL 4431 0 0
// end ;
  45: END
// export debug , prefix , missionStart , aviradzeSpotted , deltaSpotted , sciSpotted , aviradzeQuestDone , sciCounterKill , usAlert , usActiveDefend , timeUntilFarmer , attackDeltaAllowed , trickyMove , usPatrol , trap , lostCounter ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := false ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// aviradzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 6
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 8
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// aviradzeQuestDone := false ;
  97: LD_ADDR_EXP 7
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// attackDeltaAllowed := false ;
 105: LD_ADDR_EXP 12
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// usAlert := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// usActiveDefend := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// usPatrol := [ ] ;
 129: LD_ADDR_EXP 14
 133: PUSH
 134: EMPTY
 135: ST_TO_ADDR
// timeUntilFarmer := [ 40 40$00 , 30 30$00 , 20 20$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 11
 140: PUSH
 141: LD_INT 84000
 143: PUSH
 144: LD_INT 63000
 146: PUSH
 147: LD_INT 42000
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// trickyMove := false ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// prefix := 01_ ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 01_
 176: ST_TO_ADDR
// trap := 0 ;
 177: LD_ADDR_EXP 15
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// lostCounter := false ;
 185: LD_ADDR_EXP 16
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// end ;
 193: LD_VAR 0 1
 197: RET
// function DebugMode ; begin
 198: LD_INT 0
 200: PPUSH
// FogOff ( 1 ) ;
 201: LD_INT 1
 203: PPUSH
 204: CALL_OW 344
// Difficulty := 2 ;
 208: LD_ADDR_OWVAR 67
 212: PUSH
 213: LD_INT 2
 215: ST_TO_ADDR
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
// if exist_mode then
 225: LD_VAR 0 2
 229: IFFALSE 254
// unit := CreateCharacter ( prefix & ident ) else
 231: LD_ADDR_VAR 0 5
 235: PUSH
 236: LD_VAR 0 3
 240: PUSH
 241: LD_VAR 0 1
 245: STR
 246: PPUSH
 247: CALL_OW 34
 251: ST_TO_ADDR
 252: GO 269
// unit := NewCharacter ( ident ) ;
 254: LD_ADDR_VAR 0 5
 258: PUSH
 259: LD_VAR 0 1
 263: PPUSH
 264: CALL_OW 25
 268: ST_TO_ADDR
// result := unit ;
 269: LD_ADDR_VAR 0 4
 273: PUSH
 274: LD_VAR 0 5
 278: ST_TO_ADDR
// end ;
 279: LD_VAR 0 4
 283: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 284: LD_INT 0
 286: PPUSH
// uc_side := side ;
 287: LD_ADDR_OWVAR 20
 291: PUSH
 292: LD_VAR 0 1
 296: ST_TO_ADDR
// uc_nation := nation ;
 297: LD_ADDR_OWVAR 21
 301: PUSH
 302: LD_VAR 0 2
 306: ST_TO_ADDR
// vc_chassis := chassis ;
 307: LD_ADDR_OWVAR 37
 311: PUSH
 312: LD_VAR 0 3
 316: ST_TO_ADDR
// vc_engine := engine ;
 317: LD_ADDR_OWVAR 39
 321: PUSH
 322: LD_VAR 0 4
 326: ST_TO_ADDR
// vc_control := control ;
 327: LD_ADDR_OWVAR 38
 331: PUSH
 332: LD_VAR 0 5
 336: ST_TO_ADDR
// vc_weapon := weapon ;
 337: LD_ADDR_OWVAR 40
 341: PUSH
 342: LD_VAR 0 6
 346: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 347: LD_ADDR_OWVAR 41
 351: PUSH
 352: LD_VAR 0 7
 356: ST_TO_ADDR
// result := CreateVehicle ;
 357: LD_ADDR_VAR 0 8
 361: PUSH
 362: CALL_OW 45
 366: ST_TO_ADDR
// end ;
 367: LD_VAR 0 8
 371: RET
// export function SayX ( units , ident ) ; var i ; begin
 372: LD_INT 0
 374: PPUSH
 375: PPUSH
// result := false ;
 376: LD_ADDR_VAR 0 3
 380: PUSH
 381: LD_INT 0
 383: ST_TO_ADDR
// if not units then
 384: LD_VAR 0 1
 388: NOT
 389: IFFALSE 393
// exit ;
 391: GO 447
// for i in units do
 393: LD_ADDR_VAR 0 4
 397: PUSH
 398: LD_VAR 0 1
 402: PUSH
 403: FOR_IN
 404: IFFALSE 445
// if IsOk ( i ) then
 406: LD_VAR 0 4
 410: PPUSH
 411: CALL_OW 302
 415: IFFALSE 443
// begin Say ( i , ident ) ;
 417: LD_VAR 0 4
 421: PPUSH
 422: LD_VAR 0 2
 426: PPUSH
 427: CALL_OW 88
// result := i ;
 431: LD_ADDR_VAR 0 3
 435: PUSH
 436: LD_VAR 0 4
 440: ST_TO_ADDR
// break ;
 441: GO 445
// end ;
 443: GO 403
 445: POP
 446: POP
// end ;
 447: LD_VAR 0 3
 451: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 452: LD_INT 0
 454: PPUSH
 455: PPUSH
// InitUc ;
 456: CALL_OW 18
// InitHc ;
 460: CALL_OW 19
// uc_side := 0 ;
 464: LD_ADDR_OWVAR 20
 468: PUSH
 469: LD_INT 0
 471: ST_TO_ADDR
// uc_nation := 0 ;
 472: LD_ADDR_OWVAR 21
 476: PUSH
 477: LD_INT 0
 479: ST_TO_ADDR
// for i = 1 to amount do
 480: LD_ADDR_VAR 0 4
 484: PUSH
 485: DOUBLE
 486: LD_INT 1
 488: DEC
 489: ST_TO_ADDR
 490: LD_VAR 0 2
 494: PUSH
 495: FOR_TO
 496: IFFALSE 578
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 498: LD_ADDR_OWVAR 29
 502: PUSH
 503: LD_INT 9
 505: PPUSH
 506: LD_INT 12
 508: PPUSH
 509: CALL_OW 12
 513: PUSH
 514: LD_INT 9
 516: PPUSH
 517: LD_INT 12
 519: PPUSH
 520: CALL_OW 12
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 529: LD_ADDR_OWVAR 35
 533: PUSH
 534: LD_INT 1
 536: NEG
 537: PPUSH
 538: LD_INT 1
 540: PPUSH
 541: CALL_OW 12
 545: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 546: LD_INT 0
 548: PPUSH
 549: LD_INT 12
 551: PPUSH
 552: LD_INT 1
 554: PPUSH
 555: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 559: CALL_OW 44
 563: PPUSH
 564: LD_VAR 0 1
 568: PPUSH
 569: LD_INT 0
 571: PPUSH
 572: CALL_OW 49
// end ;
 576: GO 495
 578: POP
 579: POP
// InitHc ;
 580: CALL_OW 19
// end ;
 584: LD_VAR 0 3
 588: RET
// export function PrepareNature ; var i ; begin
 589: LD_INT 0
 591: PPUSH
 592: PPUSH
// SpawnApeman ( forest , 9 ) ;
 593: LD_INT 1
 595: PPUSH
 596: LD_INT 9
 598: PPUSH
 599: CALL 452 0 2
// for i := 1 to 4 do
 603: LD_ADDR_VAR 0 2
 607: PUSH
 608: DOUBLE
 609: LD_INT 1
 611: DEC
 612: ST_TO_ADDR
 613: LD_INT 4
 615: PUSH
 616: FOR_TO
 617: IFFALSE 652
// begin hc_class := 21 ;
 619: LD_ADDR_OWVAR 28
 623: PUSH
 624: LD_INT 21
 626: ST_TO_ADDR
// hc_gallery :=  ;
 627: LD_ADDR_OWVAR 33
 631: PUSH
 632: LD_STRING 
 634: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 635: CALL_OW 44
 639: PPUSH
 640: LD_INT 1
 642: PPUSH
 643: LD_INT 0
 645: PPUSH
 646: CALL_OW 49
// end ;
 650: GO 616
 652: POP
 653: POP
// for i := 1 to 2 do
 654: LD_ADDR_VAR 0 2
 658: PUSH
 659: DOUBLE
 660: LD_INT 1
 662: DEC
 663: ST_TO_ADDR
 664: LD_INT 2
 666: PUSH
 667: FOR_TO
 668: IFFALSE 703
// begin hc_class := 18 ;
 670: LD_ADDR_OWVAR 28
 674: PUSH
 675: LD_INT 18
 677: ST_TO_ADDR
// hc_gallery :=  ;
 678: LD_ADDR_OWVAR 33
 682: PUSH
 683: LD_STRING 
 685: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 686: CALL_OW 44
 690: PPUSH
 691: LD_INT 1
 693: PPUSH
 694: LD_INT 0
 696: PPUSH
 697: CALL_OW 49
// end ;
 701: GO 667
 703: POP
 704: POP
// for i := 1 to 3 do
 705: LD_ADDR_VAR 0 2
 709: PUSH
 710: DOUBLE
 711: LD_INT 1
 713: DEC
 714: ST_TO_ADDR
 715: LD_INT 3
 717: PUSH
 718: FOR_TO
 719: IFFALSE 754
// begin hc_class := 13 ;
 721: LD_ADDR_OWVAR 28
 725: PUSH
 726: LD_INT 13
 728: ST_TO_ADDR
// hc_gallery :=  ;
 729: LD_ADDR_OWVAR 33
 733: PUSH
 734: LD_STRING 
 736: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 737: CALL_OW 44
 741: PPUSH
 742: LD_INT 1
 744: PPUSH
 745: LD_INT 0
 747: PPUSH
 748: CALL_OW 49
// end ;
 752: GO 718
 754: POP
 755: POP
// end ;
 756: LD_VAR 0 1
 760: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 761: LD_INT 0
 763: PPUSH
 764: PPUSH
 765: PPUSH
// if not observer or not unit then
 766: LD_VAR 0 1
 770: NOT
 771: PUSH
 772: LD_VAR 0 2
 776: NOT
 777: OR
 778: IFFALSE 782
// exit ;
 780: GO 830
// if not See ( GetSide ( observer ) , unit ) then
 782: LD_VAR 0 1
 786: PPUSH
 787: CALL_OW 255
 791: PPUSH
 792: LD_VAR 0 2
 796: PPUSH
 797: CALL_OW 292
 801: NOT
 802: IFFALSE 806
// exit ;
 804: GO 830
// result := GetDistUnits ( observer , unit ) < 12 ;
 806: LD_ADDR_VAR 0 3
 810: PUSH
 811: LD_VAR 0 1
 815: PPUSH
 816: LD_VAR 0 2
 820: PPUSH
 821: CALL_OW 296
 825: PUSH
 826: LD_INT 12
 828: LESS
 829: ST_TO_ADDR
// end ; end_of_file
 830: LD_VAR 0 3
 834: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp , arm ; begin
 835: LD_INT 0
 837: PPUSH
 838: PPUSH
 839: PPUSH
 840: PPUSH
 841: PPUSH
 842: PPUSH
// usForces := [ ] ;
 843: LD_ADDR_EXP 19
 847: PUSH
 848: EMPTY
 849: ST_TO_ADDR
// usSci := [ ] ;
 850: LD_ADDR_EXP 20
 854: PUSH
 855: EMPTY
 856: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 857: LD_INT 1
 859: PPUSH
 860: LD_STRING Delta
 862: PPUSH
 863: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 867: LD_INT 1
 869: PPUSH
 870: CALL_OW 274
 874: PPUSH
 875: LD_INT 1
 877: PPUSH
 878: LD_INT 400
 880: PPUSH
 881: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 885: LD_INT 1
 887: PPUSH
 888: CALL_OW 274
 892: PPUSH
 893: LD_INT 2
 895: PPUSH
 896: LD_INT 80
 898: PPUSH
 899: CALL_OW 277
// uc_side := 1 ;
 903: LD_ADDR_OWVAR 20
 907: PUSH
 908: LD_INT 1
 910: ST_TO_ADDR
// uc_nation := 1 ;
 911: LD_ADDR_OWVAR 21
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
// InitHc ;
 919: CALL_OW 19
// hc_importance := 0 ;
 923: LD_ADDR_OWVAR 32
 927: PUSH
 928: LD_INT 0
 930: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 931: LD_ADDR_EXP 18
 935: PUSH
 936: LD_STRING Lynch
 938: PPUSH
 939: LD_INT 0
 941: PPUSH
 942: LD_STRING 
 944: PPUSH
 945: CALL 221 0 3
 949: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 950: LD_ADDR_EXP 17
 954: PUSH
 955: LD_STRING Gladstone
 957: PPUSH
 958: LD_INT 0
 960: PPUSH
 961: LD_STRING 
 963: PPUSH
 964: CALL 221 0 3
 968: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 969: LD_EXP 18
 973: PPUSH
 974: LD_INT 1
 976: PPUSH
 977: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 981: LD_EXP 17
 985: PPUSH
 986: LD_INT 3
 988: PPUSH
 989: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
 993: LD_ADDR_VAR 0 2
 997: PUSH
 998: DOUBLE
 999: LD_INT 1
1001: DEC
1002: ST_TO_ADDR
1003: LD_INT 1
1005: PUSH
1006: LD_INT 2
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: PUSH
1017: LD_OWVAR 67
1021: ARRAY
1022: PUSH
1023: FOR_TO
1024: IFFALSE 1070
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1026: LD_INT 0
1028: PPUSH
1029: LD_INT 2
1031: PPUSH
1032: LD_INT 1
1034: PUSH
1035: LD_INT 2
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: PUSH
1046: LD_OWVAR 67
1050: ARRAY
1051: PPUSH
1052: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
1056: CALL_OW 44
1060: PPUSH
1061: LD_INT 1
1063: PPUSH
1064: CALL_OW 52
// end ;
1068: GO 1023
1070: POP
1071: POP
// for i := 1 to 2 + Difficulty do
1072: LD_ADDR_VAR 0 2
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: LD_OWVAR 67
1089: PLUS
1090: PUSH
1091: FOR_TO
1092: IFFALSE 1177
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1094: LD_INT 0
1096: PPUSH
1097: LD_INT 4
1099: PPUSH
1100: LD_INT 1
1102: PUSH
1103: LD_INT 2
1105: PUSH
1106: LD_INT 2
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: PUSH
1114: LD_OWVAR 67
1118: ARRAY
1119: PPUSH
1120: CALL_OW 380
// un := CreateHuman ;
1124: LD_ADDR_VAR 0 3
1128: PUSH
1129: CALL_OW 44
1133: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
1134: LD_VAR 0 3
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
1146: LD_ADDR_EXP 20
1150: PUSH
1151: LD_EXP 20
1155: PPUSH
1156: LD_EXP 20
1160: PUSH
1161: LD_INT 1
1163: PLUS
1164: PPUSH
1165: LD_VAR 0 3
1169: PPUSH
1170: CALL_OW 1
1174: ST_TO_ADDR
// end ;
1175: GO 1091
1177: POP
1178: POP
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
1179: LD_ADDR_VAR 0 6
1183: PUSH
1184: LD_INT 22
1186: PUSH
1187: LD_INT 1
1189: PUSH
1190: EMPTY
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 30
1196: PUSH
1197: LD_INT 4
1199: PUSH
1200: EMPTY
1201: LIST
1202: LIST
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PPUSH
1208: CALL_OW 69
1212: ST_TO_ADDR
// for i := 1 to 3 + Difficulty do
1213: LD_ADDR_VAR 0 2
1217: PUSH
1218: DOUBLE
1219: LD_INT 1
1221: DEC
1222: ST_TO_ADDR
1223: LD_INT 3
1225: PUSH
1226: LD_OWVAR 67
1230: PLUS
1231: PUSH
1232: FOR_TO
1233: IFFALSE 1311
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1235: LD_INT 0
1237: PPUSH
1238: LD_INT 1
1240: PPUSH
1241: LD_INT 1
1243: PUSH
1244: LD_INT 2
1246: PUSH
1247: LD_INT 3
1249: PUSH
1250: EMPTY
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_OWVAR 67
1259: ARRAY
1260: PPUSH
1261: CALL_OW 380
// un := CreateHuman ;
1265: LD_ADDR_VAR 0 3
1269: PUSH
1270: CALL_OW 44
1274: ST_TO_ADDR
// usForces := usForces ^ un ;
1275: LD_ADDR_EXP 19
1279: PUSH
1280: LD_EXP 19
1284: PUSH
1285: LD_VAR 0 3
1289: ADD
1290: ST_TO_ADDR
// PlaceHumanInUnit ( un , arm [ 1 ] ) ;
1291: LD_VAR 0 3
1295: PPUSH
1296: LD_VAR 0 6
1300: PUSH
1301: LD_INT 1
1303: ARRAY
1304: PPUSH
1305: CALL_OW 52
// end ;
1309: GO 1232
1311: POP
1312: POP
// PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1313: LD_INT 1
1315: PPUSH
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 1
1321: PPUSH
1322: LD_INT 2
1324: PPUSH
1325: LD_INT 1
1327: PPUSH
1328: LD_INT 2
1330: PPUSH
1331: LD_INT 100
1333: PPUSH
1334: CALL 284 0 7
// veh := CreateVehicle ;
1338: LD_ADDR_VAR 0 4
1342: PUSH
1343: CALL_OW 45
1347: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1348: LD_VAR 0 4
1352: PPUSH
1353: LD_INT 2
1355: PPUSH
1356: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 24 , false ) ;
1360: LD_VAR 0 4
1364: PPUSH
1365: LD_INT 43
1367: PPUSH
1368: LD_INT 24
1370: PPUSH
1371: LD_INT 0
1373: PPUSH
1374: CALL_OW 48
// end ;
1378: LD_VAR 0 1
1382: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1383: LD_INT 0
1385: PPUSH
1386: PPUSH
1387: PPUSH
1388: PPUSH
1389: PPUSH
1390: PPUSH
// if not usSci then
1391: LD_EXP 20
1395: NOT
1396: IFFALSE 1400
// exit ;
1398: GO 1574
// xy := AreaToList ( tameArea , 0 ) ;
1400: LD_ADDR_VAR 0 6
1404: PUSH
1405: LD_INT 5
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL_OW 517
1415: ST_TO_ADDR
// for i in usSci do
1416: LD_ADDR_VAR 0 2
1420: PUSH
1421: LD_EXP 20
1425: PUSH
1426: FOR_IN
1427: IFFALSE 1572
// begin k := rand ( 1 , xy [ 1 ] ) ;
1429: LD_ADDR_VAR 0 4
1433: PUSH
1434: LD_INT 1
1436: PPUSH
1437: LD_VAR 0 6
1441: PUSH
1442: LD_INT 1
1444: ARRAY
1445: PPUSH
1446: CALL_OW 12
1450: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1451: LD_VAR 0 2
1455: PPUSH
1456: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1460: LD_VAR 0 2
1464: PPUSH
1465: LD_VAR 0 6
1469: PUSH
1470: LD_INT 1
1472: ARRAY
1473: PUSH
1474: LD_VAR 0 4
1478: ARRAY
1479: PPUSH
1480: LD_VAR 0 6
1484: PUSH
1485: LD_INT 2
1487: ARRAY
1488: PUSH
1489: LD_VAR 0 4
1493: ARRAY
1494: PPUSH
1495: CALL_OW 171
// for j := 1 to 2 do
1499: LD_ADDR_VAR 0 3
1503: PUSH
1504: DOUBLE
1505: LD_INT 1
1507: DEC
1508: ST_TO_ADDR
1509: LD_INT 2
1511: PUSH
1512: FOR_TO
1513: IFFALSE 1568
// begin tmp := Delete ( xy [ j ] , k ) ;
1515: LD_ADDR_VAR 0 5
1519: PUSH
1520: LD_VAR 0 6
1524: PUSH
1525: LD_VAR 0 3
1529: ARRAY
1530: PPUSH
1531: LD_VAR 0 4
1535: PPUSH
1536: CALL_OW 3
1540: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1541: LD_ADDR_VAR 0 6
1545: PUSH
1546: LD_VAR 0 6
1550: PPUSH
1551: LD_VAR 0 3
1555: PPUSH
1556: LD_VAR 0 5
1560: PPUSH
1561: CALL_OW 1
1565: ST_TO_ADDR
// end ;
1566: GO 1512
1568: POP
1569: POP
// end ;
1570: GO 1426
1572: POP
1573: POP
// end ;
1574: LD_VAR 0 1
1578: RET
// every 0 0$5 + 0 0$10 trigger usSci and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1579: LD_EXP 20
1583: PUSH
1584: LD_INT 22
1586: PUSH
1587: LD_INT 0
1589: PUSH
1590: EMPTY
1591: LIST
1592: LIST
1593: PUSH
1594: LD_INT 25
1596: PUSH
1597: LD_INT 12
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: PPUSH
1608: CALL_OW 69
1612: AND
1613: IFFALSE 2102
1615: GO 1617
1617: DISABLE
1618: LD_INT 0
1620: PPUSH
1621: PPUSH
1622: PPUSH
1623: PPUSH
1624: PPUSH
// begin enable ;
1625: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1626: LD_EXP 20
1630: PPUSH
1631: LD_INT 2
1633: PUSH
1634: LD_INT 60
1636: PUSH
1637: EMPTY
1638: LIST
1639: PUSH
1640: LD_INT 54
1642: PUSH
1643: EMPTY
1644: LIST
1645: PUSH
1646: EMPTY
1647: LIST
1648: LIST
1649: LIST
1650: PPUSH
1651: CALL_OW 72
1655: IFFALSE 1659
// exit ;
1657: GO 2102
// for i in usSci do
1659: LD_ADDR_VAR 0 1
1663: PUSH
1664: LD_EXP 20
1668: PUSH
1669: FOR_IN
1670: IFFALSE 2100
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1672: LD_VAR 0 1
1676: PPUSH
1677: CALL_OW 314
1681: NOT
1682: PUSH
1683: LD_VAR 0 1
1687: PPUSH
1688: CALL_OW 256
1692: PUSH
1693: LD_INT 1000
1695: EQUAL
1696: AND
1697: IFFALSE 1904
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1699: LD_ADDR_VAR 0 5
1703: PUSH
1704: LD_INT 22
1706: PUSH
1707: LD_INT 0
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: PUSH
1714: LD_INT 25
1716: PUSH
1717: LD_INT 12
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: PPUSH
1728: CALL_OW 69
1732: PPUSH
1733: LD_VAR 0 1
1737: PPUSH
1738: CALL_OW 74
1742: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1743: LD_VAR 0 1
1747: PPUSH
1748: LD_VAR 0 5
1752: PPUSH
1753: CALL_OW 296
1757: PUSH
1758: LD_INT 10
1760: LESS
1761: IFFALSE 1794
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1763: LD_VAR 0 1
1767: PPUSH
1768: LD_VAR 0 5
1772: PPUSH
1773: CALL_OW 250
1777: PPUSH
1778: LD_VAR 0 5
1782: PPUSH
1783: CALL_OW 251
1787: PPUSH
1788: CALL_OW 131
1792: GO 1904
// begin d := rand ( 0 , 5 ) ;
1794: LD_ADDR_VAR 0 4
1798: PUSH
1799: LD_INT 0
1801: PPUSH
1802: LD_INT 5
1804: PPUSH
1805: CALL_OW 12
1809: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1810: LD_ADDR_VAR 0 2
1814: PUSH
1815: LD_VAR 0 1
1819: PPUSH
1820: CALL_OW 250
1824: PPUSH
1825: LD_VAR 0 4
1829: PPUSH
1830: LD_INT 3
1832: PPUSH
1833: CALL_OW 272
1837: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
1838: LD_ADDR_VAR 0 3
1842: PUSH
1843: LD_VAR 0 1
1847: PPUSH
1848: CALL_OW 251
1852: PPUSH
1853: LD_VAR 0 4
1857: PPUSH
1858: LD_INT 3
1860: PPUSH
1861: CALL_OW 273
1865: ST_TO_ADDR
// if not ValidHex ( x , y ) then
1866: LD_VAR 0 2
1870: PPUSH
1871: LD_VAR 0 3
1875: PPUSH
1876: CALL_OW 488
1880: NOT
1881: IFFALSE 1885
// continue ;
1883: GO 1669
// ComMoveXY ( i , x , y ) ;
1885: LD_VAR 0 1
1889: PPUSH
1890: LD_VAR 0 2
1894: PPUSH
1895: LD_VAR 0 3
1899: PPUSH
1900: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
1904: LD_VAR 0 1
1908: PPUSH
1909: CALL_OW 256
1913: PUSH
1914: LD_INT 900
1916: LESS
1917: PUSH
1918: LD_VAR 0 1
1922: PPUSH
1923: LD_INT 37
1925: PPUSH
1926: LD_INT 23
1928: PPUSH
1929: CALL_OW 297
1933: PUSH
1934: LD_INT 10
1936: GREATER
1937: AND
1938: IFFALSE 1988
// begin if IsOk ( Gladstone ) and IsInUnit ( Gladstone ) then
1940: LD_EXP 17
1944: PPUSH
1945: CALL_OW 302
1949: PUSH
1950: LD_EXP 17
1954: PPUSH
1955: CALL_OW 310
1959: AND
1960: IFFALSE 1971
// ComExitBuilding ( Gladstone ) ;
1962: LD_EXP 17
1966: PPUSH
1967: CALL_OW 122
// ComMoveXY ( i , 37 , 23 ) ;
1971: LD_VAR 0 1
1975: PPUSH
1976: LD_INT 37
1978: PPUSH
1979: LD_INT 23
1981: PPUSH
1982: CALL_OW 111
// end else
1986: GO 2098
// if GetLives ( i ) = 1000 then
1988: LD_VAR 0 1
1992: PPUSH
1993: CALL_OW 256
1997: PUSH
1998: LD_INT 1000
2000: EQUAL
2001: IFFALSE 2098
// begin if IsOk ( Gladstone ) then
2003: LD_EXP 17
2007: PPUSH
2008: CALL_OW 302
2012: IFFALSE 2026
// ComEnterUnit ( Gladstone , usLab ) ;
2014: LD_EXP 17
2018: PPUSH
2019: LD_INT 3
2021: PPUSH
2022: CALL_OW 120
// if SideShoot ( i ) = 2 then
2026: LD_VAR 0 1
2030: PPUSH
2031: CALL_OW 503
2035: PUSH
2036: LD_INT 2
2038: EQUAL
2039: IFFALSE 2086
// begin if not usAlert then
2041: LD_EXP 9
2045: NOT
2046: IFFALSE 2056
// usAlert := true ;
2048: LD_ADDR_EXP 9
2052: PUSH
2053: LD_INT 1
2055: ST_TO_ADDR
// AddComEnterUnit ( i , usLab ) ;
2056: LD_VAR 0 1
2060: PPUSH
2061: LD_INT 3
2063: PPUSH
2064: CALL_OW 180
// usSci := usSci diff i ;
2068: LD_ADDR_EXP 20
2072: PUSH
2073: LD_EXP 20
2077: PUSH
2078: LD_VAR 0 1
2082: DIFF
2083: ST_TO_ADDR
// end else
2084: GO 2098
// ComMoveToArea ( i , tameArea ) ;
2086: LD_VAR 0 1
2090: PPUSH
2091: LD_INT 5
2093: PPUSH
2094: CALL_OW 113
// end ; end ;
2098: GO 1669
2100: POP
2101: POP
// end ;
2102: PPOPN 5
2104: END
// every 0 0$1 trigger not usAlert and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 999 ] ] ] ) or FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) ) do
2105: LD_EXP 9
2109: NOT
2110: PUSH
2111: LD_INT 22
2113: PUSH
2114: LD_INT 1
2116: PUSH
2117: EMPTY
2118: LIST
2119: LIST
2120: PUSH
2121: LD_INT 21
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: PUSH
2131: LD_INT 3
2133: PUSH
2134: LD_INT 57
2136: PUSH
2137: EMPTY
2138: LIST
2139: PUSH
2140: EMPTY
2141: LIST
2142: LIST
2143: PUSH
2144: LD_INT 3
2146: PUSH
2147: LD_INT 24
2149: PUSH
2150: LD_INT 999
2152: PUSH
2153: EMPTY
2154: LIST
2155: LIST
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: EMPTY
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL_OW 69
2171: PUSH
2172: LD_INT 7
2174: PPUSH
2175: LD_INT 22
2177: PUSH
2178: LD_INT 2
2180: PUSH
2181: EMPTY
2182: LIST
2183: LIST
2184: PPUSH
2185: CALL_OW 70
2189: OR
2190: AND
2191: IFFALSE 2204
2193: GO 2195
2195: DISABLE
// usAlert := true ;
2196: LD_ADDR_EXP 9
2200: PUSH
2201: LD_INT 1
2203: ST_TO_ADDR
2204: END
// every 0 0$1 trigger usAlert do var i , b , arm ;
2205: LD_EXP 9
2209: IFFALSE 2556
2211: GO 2213
2213: DISABLE
2214: LD_INT 0
2216: PPUSH
2217: PPUSH
2218: PPUSH
// begin usActiveDefend := true ;
2219: LD_ADDR_EXP 10
2223: PUSH
2224: LD_INT 1
2226: ST_TO_ADDR
// if not usForces then
2227: LD_EXP 19
2231: NOT
2232: IFFALSE 2236
// exit ;
2234: GO 2556
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
2236: LD_ADDR_VAR 0 3
2240: PUSH
2241: LD_INT 22
2243: PUSH
2244: LD_INT 1
2246: PUSH
2247: EMPTY
2248: LIST
2249: LIST
2250: PUSH
2251: LD_INT 30
2253: PUSH
2254: LD_INT 4
2256: PUSH
2257: EMPTY
2258: LIST
2259: LIST
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PPUSH
2265: CALL_OW 69
2269: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: LD_INT 22
2277: PUSH
2278: LD_INT 1
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: PUSH
2285: LD_INT 30
2287: PUSH
2288: LD_INT 31
2290: PUSH
2291: EMPTY
2292: LIST
2293: LIST
2294: PUSH
2295: EMPTY
2296: LIST
2297: LIST
2298: PPUSH
2299: CALL_OW 69
2303: ST_TO_ADDR
// ComExitBuilding ( Lynch ) ;
2304: LD_EXP 18
2308: PPUSH
2309: CALL_OW 122
// AddComEnterUnit ( Lynch , arm [ 1 ] ) ;
2313: LD_EXP 18
2317: PPUSH
2318: LD_VAR 0 3
2322: PUSH
2323: LD_INT 1
2325: ARRAY
2326: PPUSH
2327: CALL_OW 180
// if IsOk ( Gladstone ) then
2331: LD_EXP 17
2335: PPUSH
2336: CALL_OW 302
2340: IFFALSE 2381
// begin ComExitBuilding ( Gladstone ) ;
2342: LD_EXP 17
2346: PPUSH
2347: CALL_OW 122
// AddComEnterUnit ( Gladstone , arm [ 1 ] ) ;
2351: LD_EXP 17
2355: PPUSH
2356: LD_VAR 0 3
2360: PUSH
2361: LD_INT 1
2363: ARRAY
2364: PPUSH
2365: CALL_OW 180
// AddComChangeProfession ( Gladstone , class_soldier ) ;
2369: LD_EXP 17
2373: PPUSH
2374: LD_INT 1
2376: PPUSH
2377: CALL_OW 183
// end ; ComExitBuilding ( usForces [ 1 ] ) ;
2381: LD_EXP 19
2385: PUSH
2386: LD_INT 1
2388: ARRAY
2389: PPUSH
2390: CALL_OW 122
// AddComEnterUnit ( usForces [ 1 ] , b [ 1 ] ) ;
2394: LD_EXP 19
2398: PUSH
2399: LD_INT 1
2401: ARRAY
2402: PPUSH
2403: LD_VAR 0 2
2407: PUSH
2408: LD_INT 1
2410: ARRAY
2411: PPUSH
2412: CALL_OW 180
// ComExitBuilding ( usForces [ 2 ] ) ;
2416: LD_EXP 19
2420: PUSH
2421: LD_INT 2
2423: ARRAY
2424: PPUSH
2425: CALL_OW 122
// AddComEnterUnit ( usForces [ 2 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
2429: LD_EXP 19
2433: PUSH
2434: LD_INT 2
2436: ARRAY
2437: PPUSH
2438: LD_INT 22
2440: PUSH
2441: LD_INT 1
2443: PUSH
2444: EMPTY
2445: LIST
2446: LIST
2447: PUSH
2448: LD_INT 30
2450: PUSH
2451: LD_INT 32
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: PPUSH
2462: CALL_OW 69
2466: PUSH
2467: LD_INT 1
2469: ARRAY
2470: PPUSH
2471: CALL_OW 180
// if b > 1 and usForces > 2 then
2475: LD_VAR 0 2
2479: PUSH
2480: LD_INT 1
2482: GREATER
2483: PUSH
2484: LD_EXP 19
2488: PUSH
2489: LD_INT 2
2491: GREATER
2492: AND
2493: IFFALSE 2556
// begin repeat wait ( 0 0$1 ) ;
2495: LD_INT 35
2497: PPUSH
2498: CALL_OW 67
// until BuildingStatus ( b [ 2 ] ) <> bs_build ;
2502: LD_VAR 0 2
2506: PUSH
2507: LD_INT 2
2509: ARRAY
2510: PPUSH
2511: CALL_OW 461
2515: PUSH
2516: LD_INT 1
2518: NONEQUAL
2519: IFFALSE 2495
// ComExitBuilding ( usForces [ 3 ] ) ;
2521: LD_EXP 19
2525: PUSH
2526: LD_INT 3
2528: ARRAY
2529: PPUSH
2530: CALL_OW 122
// AddComEnterUnit ( usForces [ 3 ] , b [ 2 ] ) ;
2534: LD_EXP 19
2538: PUSH
2539: LD_INT 3
2541: ARRAY
2542: PPUSH
2543: LD_VAR 0 2
2547: PUSH
2548: LD_INT 2
2550: ARRAY
2551: PPUSH
2552: CALL_OW 180
// end ; end ;
2556: PPOPN 3
2558: END
// every 0 0$1 trigger GetLives ( usLab ) < 999 and usAlert and usForces do var i ;
2559: LD_INT 3
2561: PPUSH
2562: CALL_OW 256
2566: PUSH
2567: LD_INT 999
2569: LESS
2570: PUSH
2571: LD_EXP 9
2575: AND
2576: PUSH
2577: LD_EXP 19
2581: AND
2582: IFFALSE 2753
2584: GO 2586
2586: DISABLE
2587: LD_INT 0
2589: PPUSH
// begin for i in usForces do
2590: LD_ADDR_VAR 0 1
2594: PUSH
2595: LD_EXP 19
2599: PUSH
2600: FOR_IN
2601: IFFALSE 2640
// begin if IsInUnit ( i ) then
2603: LD_VAR 0 1
2607: PPUSH
2608: CALL_OW 310
2612: IFFALSE 2623
// ComExitBuilding ( i ) ;
2614: LD_VAR 0 1
2618: PPUSH
2619: CALL_OW 122
// AddComAgressiveMove ( i , 31 , 8 ) ;
2623: LD_VAR 0 1
2627: PPUSH
2628: LD_INT 31
2630: PPUSH
2631: LD_INT 8
2633: PPUSH
2634: CALL_OW 174
// end ;
2638: GO 2600
2640: POP
2641: POP
// wait ( 0 0$8 ) ;
2642: LD_INT 280
2644: PPUSH
2645: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) then
2649: LD_INT 22
2651: PUSH
2652: LD_INT 2
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: PUSH
2659: LD_INT 91
2661: PUSH
2662: LD_INT 3
2664: PUSH
2665: LD_INT 14
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PPUSH
2677: CALL_OW 69
2681: IFFALSE 2731
// ComAttackUnit ( usForces , FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) [ 1 ] ) else
2683: LD_EXP 19
2687: PPUSH
2688: LD_INT 22
2690: PUSH
2691: LD_INT 2
2693: PUSH
2694: EMPTY
2695: LIST
2696: LIST
2697: PUSH
2698: LD_INT 91
2700: PUSH
2701: LD_INT 3
2703: PUSH
2704: LD_INT 14
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: LIST
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: PPUSH
2716: CALL_OW 69
2720: PUSH
2721: LD_INT 1
2723: ARRAY
2724: PPUSH
2725: CALL_OW 115
2729: GO 2753
// begin wait ( 0 0$20 ) ;
2731: LD_INT 700
2733: PPUSH
2734: CALL_OW 67
// AddComMoveXY ( usForces , 39 , 19 ) ;
2738: LD_EXP 19
2742: PPUSH
2743: LD_INT 39
2745: PPUSH
2746: LD_INT 19
2748: PPUSH
2749: CALL_OW 171
// end ; end ;
2753: PPOPN 1
2755: END
// every 0 0$3 trigger ( GetDistUnits ( Heike , Delta ) < 10 or GetLives ( usLab ) < 999 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do var tmp , veh ;
2756: LD_EXP 21
2760: PPUSH
2761: LD_INT 1
2763: PPUSH
2764: CALL_OW 296
2768: PUSH
2769: LD_INT 10
2771: LESS
2772: PUSH
2773: LD_INT 3
2775: PPUSH
2776: CALL_OW 256
2780: PUSH
2781: LD_INT 999
2783: LESS
2784: OR
2785: PUSH
2786: LD_INT 22
2788: PUSH
2789: LD_INT 1
2791: PUSH
2792: EMPTY
2793: LIST
2794: LIST
2795: PUSH
2796: LD_INT 25
2798: PUSH
2799: LD_INT 2
2801: PUSH
2802: EMPTY
2803: LIST
2804: LIST
2805: PUSH
2806: EMPTY
2807: LIST
2808: LIST
2809: PPUSH
2810: CALL_OW 69
2814: AND
2815: IFFALSE 2999
2817: GO 2819
2819: DISABLE
2820: LD_INT 0
2822: PPUSH
2823: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
2824: LD_ADDR_VAR 0 1
2828: PUSH
2829: LD_INT 22
2831: PUSH
2832: LD_INT 1
2834: PUSH
2835: EMPTY
2836: LIST
2837: LIST
2838: PUSH
2839: LD_INT 25
2841: PUSH
2842: LD_INT 2
2844: PUSH
2845: EMPTY
2846: LIST
2847: LIST
2848: PUSH
2849: EMPTY
2850: LIST
2851: LIST
2852: PPUSH
2853: CALL_OW 69
2857: ST_TO_ADDR
// veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2858: LD_ADDR_VAR 0 2
2862: PUSH
2863: LD_INT 22
2865: PUSH
2866: LD_INT 1
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: PUSH
2873: LD_INT 21
2875: PUSH
2876: LD_INT 2
2878: PUSH
2879: EMPTY
2880: LIST
2881: LIST
2882: PUSH
2883: LD_INT 58
2885: PUSH
2886: EMPTY
2887: LIST
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: LIST
2893: PPUSH
2894: CALL_OW 69
2898: ST_TO_ADDR
// if not tmp then
2899: LD_VAR 0 1
2903: NOT
2904: IFFALSE 2908
// exit ;
2906: GO 2999
// ComExitBuilding ( tmp ) ;
2908: LD_VAR 0 1
2912: PPUSH
2913: CALL_OW 122
// AddComDismantle ( tmp , usLab ) ;
2917: LD_VAR 0 1
2921: PPUSH
2922: LD_INT 3
2924: PPUSH
2925: CALL_OW 227
// if veh and IsOk ( Gladstone ) then
2929: LD_VAR 0 2
2933: PUSH
2934: LD_EXP 17
2938: PPUSH
2939: CALL_OW 302
2943: AND
2944: IFFALSE 2999
// begin if IsInUnit ( Gladstone ) then
2946: LD_EXP 17
2950: PPUSH
2951: CALL_OW 310
2955: IFFALSE 2966
// ComExitBuilding ( Gladstone ) ;
2957: LD_EXP 17
2961: PPUSH
2962: CALL_OW 122
// AddComEnterUnit ( Gladstone , veh [ 1 ] ) ;
2966: LD_EXP 17
2970: PPUSH
2971: LD_VAR 0 2
2975: PUSH
2976: LD_INT 1
2978: ARRAY
2979: PPUSH
2980: CALL_OW 180
// AddComAgressiveMove ( Gladstone , 39 , 14 ) ;
2984: LD_EXP 17
2988: PPUSH
2989: LD_INT 39
2991: PPUSH
2992: LD_INT 14
2994: PPUSH
2995: CALL_OW 174
// end ; end ;
2999: PPOPN 2
3001: END
// every 0 0$1 trigger usAlert and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) diff ( usForces union usSci ) do var i , tmp ;
3002: LD_EXP 9
3006: PUSH
3007: LD_INT 22
3009: PUSH
3010: LD_INT 1
3012: PUSH
3013: EMPTY
3014: LIST
3015: LIST
3016: PUSH
3017: LD_INT 21
3019: PUSH
3020: LD_INT 1
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 3
3029: PUSH
3030: LD_INT 24
3032: PUSH
3033: LD_INT 600
3035: PUSH
3036: EMPTY
3037: LIST
3038: LIST
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: LIST
3048: PPUSH
3049: CALL_OW 69
3053: PUSH
3054: LD_EXP 19
3058: PUSH
3059: LD_EXP 20
3063: UNION
3064: DIFF
3065: AND
3066: IFFALSE 3203
3068: GO 3070
3070: DISABLE
3071: LD_INT 0
3073: PPUSH
3074: PPUSH
// begin enable ;
3075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) diff ( usForces union usSci ) ;
3076: LD_ADDR_VAR 0 2
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 1
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 21
3093: PUSH
3094: LD_INT 1
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 3
3103: PUSH
3104: LD_INT 24
3106: PUSH
3107: LD_INT 600
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: PUSH
3118: EMPTY
3119: LIST
3120: LIST
3121: LIST
3122: PPUSH
3123: CALL_OW 69
3127: PUSH
3128: LD_EXP 19
3132: PUSH
3133: LD_EXP 20
3137: UNION
3138: DIFF
3139: ST_TO_ADDR
// if not tmp then
3140: LD_VAR 0 2
3144: NOT
3145: IFFALSE 3149
// exit ;
3147: GO 3203
// for i in tmp do
3149: LD_ADDR_VAR 0 1
3153: PUSH
3154: LD_VAR 0 2
3158: PUSH
3159: FOR_IN
3160: IFFALSE 3201
// if IsInUnit ( i ) then
3162: LD_VAR 0 1
3166: PPUSH
3167: CALL_OW 310
3171: IFFALSE 3184
// ComExitBuilding ( i ) else
3173: LD_VAR 0 1
3177: PPUSH
3178: CALL_OW 122
3182: GO 3199
// ComMoveXY ( i , 48 , 74 ) ;
3184: LD_VAR 0 1
3188: PPUSH
3189: LD_INT 48
3191: PPUSH
3192: LD_INT 74
3194: PPUSH
3195: CALL_OW 111
3199: GO 3159
3201: POP
3202: POP
// end ;
3203: PPOPN 2
3205: END
// every 5 5$00 do var i , un , tmp ;
3206: GO 3208
3208: DISABLE
3209: LD_INT 0
3211: PPUSH
3212: PPUSH
3213: PPUSH
// begin tmp := [ ] ;
3214: LD_ADDR_VAR 0 3
3218: PUSH
3219: EMPTY
3220: ST_TO_ADDR
// uc_side := 1 ;
3221: LD_ADDR_OWVAR 20
3225: PUSH
3226: LD_INT 1
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// case Difficulty of 1 :
3237: LD_OWVAR 67
3241: PUSH
3242: LD_INT 1
3244: DOUBLE
3245: EQUAL
3246: IFTRUE 3250
3248: GO 3353
3250: POP
// begin wait ( 1 1$00 ) ;
3251: LD_INT 2100
3253: PPUSH
3254: CALL_OW 67
// for i := 1 to 2 do
3258: LD_ADDR_VAR 0 1
3262: PUSH
3263: DOUBLE
3264: LD_INT 1
3266: DEC
3267: ST_TO_ADDR
3268: LD_INT 2
3270: PUSH
3271: FOR_TO
3272: IFFALSE 3349
// begin PrepareHuman ( false , [ 1 , 4 ] [ i mod 2 + 1 ] , 1 ) ;
3274: LD_INT 0
3276: PPUSH
3277: LD_INT 1
3279: PUSH
3280: LD_INT 4
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: PUSH
3287: LD_VAR 0 1
3291: PUSH
3292: LD_INT 2
3294: MOD
3295: PUSH
3296: LD_INT 1
3298: PLUS
3299: ARRAY
3300: PPUSH
3301: LD_INT 1
3303: PPUSH
3304: CALL_OW 380
// un := CreateHuman ;
3308: LD_ADDR_VAR 0 2
3312: PUSH
3313: CALL_OW 44
3317: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3318: LD_ADDR_VAR 0 3
3322: PUSH
3323: LD_VAR 0 3
3327: PPUSH
3328: LD_VAR 0 3
3332: PUSH
3333: LD_INT 1
3335: PLUS
3336: PPUSH
3337: LD_VAR 0 2
3341: PPUSH
3342: CALL_OW 1
3346: ST_TO_ADDR
// end ;
3347: GO 3271
3349: POP
3350: POP
// end ; 2 :
3351: GO 3747
3353: LD_INT 2
3355: DOUBLE
3356: EQUAL
3357: IFTRUE 3361
3359: GO 3495
3361: POP
// begin wait ( 0 0$30 ) ;
3362: LD_INT 1050
3364: PPUSH
3365: CALL_OW 67
// for i := 1 to 2 do
3369: LD_ADDR_VAR 0 1
3373: PUSH
3374: DOUBLE
3375: LD_INT 1
3377: DEC
3378: ST_TO_ADDR
3379: LD_INT 2
3381: PUSH
3382: FOR_TO
3383: IFFALSE 3439
// begin PrepareHuman ( false , 1 , 2 ) ;
3385: LD_INT 0
3387: PPUSH
3388: LD_INT 1
3390: PPUSH
3391: LD_INT 2
3393: PPUSH
3394: CALL_OW 380
// un := CreateHuman ;
3398: LD_ADDR_VAR 0 2
3402: PUSH
3403: CALL_OW 44
3407: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3408: LD_ADDR_VAR 0 3
3412: PUSH
3413: LD_VAR 0 3
3417: PPUSH
3418: LD_VAR 0 3
3422: PUSH
3423: LD_INT 1
3425: PLUS
3426: PPUSH
3427: LD_VAR 0 2
3431: PPUSH
3432: CALL_OW 1
3436: ST_TO_ADDR
// end ;
3437: GO 3382
3439: POP
3440: POP
// PrepareHuman ( false , 4 , 2 ) ;
3441: LD_INT 0
3443: PPUSH
3444: LD_INT 4
3446: PPUSH
3447: LD_INT 2
3449: PPUSH
3450: CALL_OW 380
// un := CreateHuman ;
3454: LD_ADDR_VAR 0 2
3458: PUSH
3459: CALL_OW 44
3463: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3464: LD_ADDR_VAR 0 3
3468: PUSH
3469: LD_VAR 0 3
3473: PPUSH
3474: LD_VAR 0 3
3478: PUSH
3479: LD_INT 1
3481: PLUS
3482: PPUSH
3483: LD_VAR 0 2
3487: PPUSH
3488: CALL_OW 1
3492: ST_TO_ADDR
// end ; 3 :
3493: GO 3747
3495: LD_INT 3
3497: DOUBLE
3498: EQUAL
3499: IFTRUE 3503
3501: GO 3746
3503: POP
// begin for i := 1 to 2 do
3504: LD_ADDR_VAR 0 1
3508: PUSH
3509: DOUBLE
3510: LD_INT 1
3512: DEC
3513: ST_TO_ADDR
3514: LD_INT 2
3516: PUSH
3517: FOR_TO
3518: IFFALSE 3574
// begin PrepareHuman ( false , 1 , 2 ) ;
3520: LD_INT 0
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: LD_INT 2
3528: PPUSH
3529: CALL_OW 380
// un := CreateHuman ;
3533: LD_ADDR_VAR 0 2
3537: PUSH
3538: CALL_OW 44
3542: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3543: LD_ADDR_VAR 0 3
3547: PUSH
3548: LD_VAR 0 3
3552: PPUSH
3553: LD_VAR 0 3
3557: PUSH
3558: LD_INT 1
3560: PLUS
3561: PPUSH
3562: LD_VAR 0 2
3566: PPUSH
3567: CALL_OW 1
3571: ST_TO_ADDR
// end ;
3572: GO 3517
3574: POP
3575: POP
// PrepareHuman ( false , 4 , 2 ) ;
3576: LD_INT 0
3578: PPUSH
3579: LD_INT 4
3581: PPUSH
3582: LD_INT 2
3584: PPUSH
3585: CALL_OW 380
// un := CreateHuman ;
3589: LD_ADDR_VAR 0 2
3593: PUSH
3594: CALL_OW 44
3598: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3599: LD_ADDR_VAR 0 3
3603: PUSH
3604: LD_VAR 0 3
3608: PPUSH
3609: LD_VAR 0 3
3613: PUSH
3614: LD_INT 1
3616: PLUS
3617: PPUSH
3618: LD_VAR 0 2
3622: PPUSH
3623: CALL_OW 1
3627: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_machine_gun , 90 ) ;
3628: LD_INT 1
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: LD_INT 2
3636: PPUSH
3637: LD_INT 2
3639: PPUSH
3640: LD_INT 1
3642: PPUSH
3643: LD_INT 2
3645: PPUSH
3646: LD_INT 90
3648: PPUSH
3649: CALL 284 0 7
// un := CreateVehicle ;
3653: LD_ADDR_VAR 0 2
3657: PUSH
3658: CALL_OW 45
3662: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3663: LD_ADDR_VAR 0 3
3667: PUSH
3668: LD_VAR 0 3
3672: PPUSH
3673: LD_VAR 0 3
3677: PUSH
3678: LD_INT 1
3680: PLUS
3681: PPUSH
3682: LD_VAR 0 2
3686: PPUSH
3687: CALL_OW 1
3691: ST_TO_ADDR
// PrepareHuman ( false , 1 , 2 ) ;
3692: LD_INT 0
3694: PPUSH
3695: LD_INT 1
3697: PPUSH
3698: LD_INT 2
3700: PPUSH
3701: CALL_OW 380
// un := CreateHuman ;
3705: LD_ADDR_VAR 0 2
3709: PUSH
3710: CALL_OW 44
3714: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3715: LD_ADDR_VAR 0 3
3719: PUSH
3720: LD_VAR 0 3
3724: PPUSH
3725: LD_VAR 0 3
3729: PUSH
3730: LD_INT 1
3732: PLUS
3733: PPUSH
3734: LD_VAR 0 2
3738: PPUSH
3739: CALL_OW 1
3743: ST_TO_ADDR
// end ; end ;
3744: GO 3747
3746: POP
// for i := 1 to tmp do
3747: LD_ADDR_VAR 0 1
3751: PUSH
3752: DOUBLE
3753: LD_INT 1
3755: DEC
3756: ST_TO_ADDR
3757: LD_VAR 0 3
3761: PUSH
3762: FOR_TO
3763: IFFALSE 3928
// begin SetDir ( tmp [ i ] , 1 ) ;
3765: LD_VAR 0 3
3769: PUSH
3770: LD_VAR 0 1
3774: ARRAY
3775: PPUSH
3776: LD_INT 1
3778: PPUSH
3779: CALL_OW 233
// if GetType ( tmp [ i ] ) = unit_human then
3783: LD_VAR 0 3
3787: PUSH
3788: LD_VAR 0 1
3792: ARRAY
3793: PPUSH
3794: CALL_OW 247
3798: PUSH
3799: LD_INT 1
3801: EQUAL
3802: IFFALSE 3830
// PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) else
3804: LD_VAR 0 3
3808: PUSH
3809: LD_VAR 0 1
3813: ARRAY
3814: PPUSH
3815: LD_INT 28
3817: PPUSH
3818: LD_INT 52
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 48
3828: GO 3898
// begin PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) ;
3830: LD_VAR 0 3
3834: PUSH
3835: LD_VAR 0 1
3839: ARRAY
3840: PPUSH
3841: LD_INT 28
3843: PPUSH
3844: LD_INT 52
3846: PPUSH
3847: LD_INT 0
3849: PPUSH
3850: CALL_OW 48
// i := i + 1 ;
3854: LD_ADDR_VAR 0 1
3858: PUSH
3859: LD_VAR 0 1
3863: PUSH
3864: LD_INT 1
3866: PLUS
3867: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ i ] , tmp [ i - 1 ] ) ;
3868: LD_VAR 0 3
3872: PUSH
3873: LD_VAR 0 1
3877: ARRAY
3878: PPUSH
3879: LD_VAR 0 3
3883: PUSH
3884: LD_VAR 0 1
3888: PUSH
3889: LD_INT 1
3891: MINUS
3892: ARRAY
3893: PPUSH
3894: CALL_OW 52
// end ; ComMoveXY ( tmp [ i ] , 43 , 56 ) ;
3898: LD_VAR 0 3
3902: PUSH
3903: LD_VAR 0 1
3907: ARRAY
3908: PPUSH
3909: LD_INT 43
3911: PPUSH
3912: LD_INT 56
3914: PPUSH
3915: CALL_OW 111
// wait ( 0 0$2 ) ;
3919: LD_INT 70
3921: PPUSH
3922: CALL_OW 67
// end ;
3926: GO 3762
3928: POP
3929: POP
// wait ( 0 0$2 ) ;
3930: LD_INT 70
3932: PPUSH
3933: CALL_OW 67
// if not FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) then
3937: LD_INT 7
3939: PPUSH
3940: LD_INT 22
3942: PUSH
3943: LD_INT 2
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PPUSH
3950: CALL_OW 70
3954: NOT
3955: IFFALSE 4153
// begin AddComAgressiveMove ( tmp , 35 , 24 ) ;
3957: LD_VAR 0 3
3961: PPUSH
3962: LD_INT 35
3964: PPUSH
3965: LD_INT 24
3967: PPUSH
3968: CALL_OW 174
// usForces := usForces union UnitFilter ( tmp , [ f_class , 1 ] ) ;
3972: LD_ADDR_EXP 19
3976: PUSH
3977: LD_EXP 19
3981: PUSH
3982: LD_VAR 0 3
3986: PPUSH
3987: LD_INT 25
3989: PUSH
3990: LD_INT 1
3992: PUSH
3993: EMPTY
3994: LIST
3995: LIST
3996: PPUSH
3997: CALL_OW 72
4001: UNION
4002: ST_TO_ADDR
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
4003: LD_INT 22
4005: PUSH
4006: LD_INT 1
4008: PUSH
4009: EMPTY
4010: LIST
4011: LIST
4012: PUSH
4013: LD_INT 30
4015: PUSH
4016: LD_INT 4
4018: PUSH
4019: EMPTY
4020: LIST
4021: LIST
4022: PUSH
4023: EMPTY
4024: LIST
4025: LIST
4026: PPUSH
4027: CALL_OW 69
4031: PUSH
4032: LD_INT 1
4034: ARRAY
4035: PPUSH
4036: CALL_OW 313
4040: PUSH
4041: LD_INT 6
4043: LESS
4044: IFFALSE 4103
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
4046: LD_VAR 0 3
4050: PPUSH
4051: LD_INT 25
4053: PUSH
4054: LD_INT 1
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: PPUSH
4061: CALL_OW 72
4065: PPUSH
4066: LD_INT 22
4068: PUSH
4069: LD_INT 1
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: PUSH
4076: LD_INT 30
4078: PUSH
4079: LD_INT 4
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PPUSH
4090: CALL_OW 69
4094: PUSH
4095: LD_INT 1
4097: ARRAY
4098: PPUSH
4099: CALL_OW 180
// if UnitFilter ( tmp , [ f_class , 4 ] ) then
4103: LD_VAR 0 3
4107: PPUSH
4108: LD_INT 25
4110: PUSH
4111: LD_INT 4
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: PPUSH
4118: CALL_OW 72
4122: IFFALSE 4151
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 4 ] ) , usLab ) ;
4124: LD_VAR 0 3
4128: PPUSH
4129: LD_INT 25
4131: PUSH
4132: LD_INT 4
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: CALL_OW 72
4143: PPUSH
4144: LD_INT 3
4146: PPUSH
4147: CALL_OW 180
// end else
4151: GO 4428
// begin tmp := tmp union FilterUnitsInArea ( retreatArea , [ f_side , 1 ] ) ;
4153: LD_ADDR_VAR 0 3
4157: PUSH
4158: LD_VAR 0 3
4162: PUSH
4163: LD_INT 6
4165: PPUSH
4166: LD_INT 22
4168: PUSH
4169: LD_INT 1
4171: PUSH
4172: EMPTY
4173: LIST
4174: LIST
4175: PPUSH
4176: CALL_OW 70
4180: UNION
4181: ST_TO_ADDR
// ComMoveXY ( tmp , 45 , 54 ) ;
4182: LD_VAR 0 3
4186: PPUSH
4187: LD_INT 45
4189: PPUSH
4190: LD_INT 54
4192: PPUSH
4193: CALL_OW 111
// wait ( 0 0$3 ) ;
4197: LD_INT 105
4199: PPUSH
4200: CALL_OW 67
// AddComAgressiveMove ( tmp diff UnitFilter ( tmp , [ f_class , 4 ] ) , 35 , 24 ) ;
4204: LD_VAR 0 3
4208: PUSH
4209: LD_VAR 0 3
4213: PPUSH
4214: LD_INT 25
4216: PUSH
4217: LD_INT 4
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PPUSH
4224: CALL_OW 72
4228: DIFF
4229: PPUSH
4230: LD_INT 35
4232: PPUSH
4233: LD_INT 24
4235: PPUSH
4236: CALL_OW 174
// AddComMoveXY ( UnitFilter ( tmp , [ f_class , 4 ] ) , 42 , 49 ) ;
4240: LD_VAR 0 3
4244: PPUSH
4245: LD_INT 25
4247: PUSH
4248: LD_INT 4
4250: PUSH
4251: EMPTY
4252: LIST
4253: LIST
4254: PPUSH
4255: CALL_OW 72
4259: PPUSH
4260: LD_INT 42
4262: PPUSH
4263: LD_INT 49
4265: PPUSH
4266: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4270: LD_INT 35
4272: PPUSH
4273: CALL_OW 67
// for i in tmp do
4277: LD_ADDR_VAR 0 1
4281: PUSH
4282: LD_VAR 0 3
4286: PUSH
4287: FOR_IN
4288: IFFALSE 4419
// if IsDead ( i ) then
4290: LD_VAR 0 1
4294: PPUSH
4295: CALL_OW 301
4299: IFFALSE 4319
// tmp := tmp diff i else
4301: LD_ADDR_VAR 0 3
4305: PUSH
4306: LD_VAR 0 3
4310: PUSH
4311: LD_VAR 0 1
4315: DIFF
4316: ST_TO_ADDR
4317: GO 4417
// if GetClass ( i ) = 1 then
4319: LD_VAR 0 1
4323: PPUSH
4324: CALL_OW 257
4328: PUSH
4329: LD_INT 1
4331: EQUAL
4332: IFFALSE 4417
// begin if GetLives ( i ) < 600 and GetDistUnitXY ( i , 42 , 49 ) > 6 then
4334: LD_VAR 0 1
4338: PPUSH
4339: CALL_OW 256
4343: PUSH
4344: LD_INT 600
4346: LESS
4347: PUSH
4348: LD_VAR 0 1
4352: PPUSH
4353: LD_INT 42
4355: PPUSH
4356: LD_INT 49
4358: PPUSH
4359: CALL_OW 297
4363: PUSH
4364: LD_INT 6
4366: GREATER
4367: AND
4368: IFFALSE 4387
// ComMoveXY ( i , 42 , 49 ) else
4370: LD_VAR 0 1
4374: PPUSH
4375: LD_INT 42
4377: PPUSH
4378: LD_INT 49
4380: PPUSH
4381: CALL_OW 111
4385: GO 4417
// if GetLives ( i ) = 1000 then
4387: LD_VAR 0 1
4391: PPUSH
4392: CALL_OW 256
4396: PUSH
4397: LD_INT 1000
4399: EQUAL
4400: IFFALSE 4417
// ComAgressiveMove ( i , 36 , 25 ) ;
4402: LD_VAR 0 1
4406: PPUSH
4407: LD_INT 36
4409: PPUSH
4410: LD_INT 25
4412: PPUSH
4413: CALL_OW 114
// end ;
4417: GO 4287
4419: POP
4420: POP
// until not tmp ;
4421: LD_VAR 0 3
4425: NOT
4426: IFFALSE 4270
// end ; end ; end_of_file
4428: PPOPN 3
4430: END
// export function Action ; var i , tmp ; begin
4431: LD_INT 0
4433: PPUSH
4434: PPUSH
4435: PPUSH
// InGameOn ;
4436: CALL_OW 8
// DoNotAttack ( 2 , usLab ) ;
4440: LD_INT 2
4442: PPUSH
4443: LD_INT 3
4445: PPUSH
4446: CALL_OW 471
// ComMoveXY ( Heike , 78 , 61 ) ;
4450: LD_EXP 21
4454: PPUSH
4455: LD_INT 78
4457: PPUSH
4458: LD_INT 61
4460: PPUSH
4461: CALL_OW 111
// if Mike then
4465: LD_EXP 23
4469: IFFALSE 4486
// ComMoveXY ( Mike , 80 , 66 ) ;
4471: LD_EXP 23
4475: PPUSH
4476: LD_INT 80
4478: PPUSH
4479: LD_INT 66
4481: PPUSH
4482: CALL_OW 111
// if Givi then
4486: LD_EXP 22
4490: IFFALSE 4507
// ComMoveXY ( Givi , 82 , 66 ) ;
4492: LD_EXP 22
4496: PPUSH
4497: LD_INT 82
4499: PPUSH
4500: LD_INT 66
4502: PPUSH
4503: CALL_OW 111
// if Kamil then
4507: LD_EXP 24
4511: IFFALSE 4528
// ComMoveXY ( Kamil , 82 , 67 ) ;
4513: LD_EXP 24
4517: PPUSH
4518: LD_INT 82
4520: PPUSH
4521: LD_INT 67
4523: PPUSH
4524: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
4528: LD_EXP 21
4532: PPUSH
4533: CALL_OW 87
// wait ( 0 0$2 ) ;
4537: LD_INT 70
4539: PPUSH
4540: CALL_OW 67
// if Givi and Mike then
4544: LD_EXP 22
4548: PUSH
4549: LD_EXP 23
4553: AND
4554: IFFALSE 5000
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4556: LD_EXP 22
4560: PUSH
4561: LD_EXP 23
4565: PUSH
4566: LD_EXP 24
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: PPUSH
4576: LD_EXP 21
4580: PPUSH
4581: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
4585: LD_EXP 21
4589: PPUSH
4590: LD_EXP 22
4594: PPUSH
4595: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
4599: LD_EXP 22
4603: PPUSH
4604: LD_STRING DG-1-start
4606: PPUSH
4607: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
4611: LD_EXP 21
4615: PPUSH
4616: LD_STRING DH-1-start
4618: PPUSH
4619: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
4623: LD_EXP 23
4627: PPUSH
4628: LD_EXP 21
4632: PPUSH
4633: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
4637: LD_EXP 21
4641: PPUSH
4642: LD_EXP 23
4646: PPUSH
4647: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
4651: LD_EXP 23
4655: PPUSH
4656: LD_STRING DM-1-start
4658: PPUSH
4659: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
4663: LD_EXP 21
4667: PPUSH
4668: LD_STRING DH-2-start
4670: PPUSH
4671: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
4675: LD_EXP 23
4679: PPUSH
4680: LD_STRING DM-2-start
4682: PPUSH
4683: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
4687: LD_EXP 22
4691: PPUSH
4692: LD_STRING DG-2-start
4694: PPUSH
4695: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
4699: LD_EXP 23
4703: PPUSH
4704: LD_EXP 22
4708: PPUSH
4709: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
4713: LD_EXP 21
4717: PPUSH
4718: LD_EXP 23
4722: PPUSH
4723: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
4727: LD_EXP 23
4731: PPUSH
4732: LD_STRING DM-3-start
4734: PPUSH
4735: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
4739: LD_EXP 21
4743: PPUSH
4744: LD_STRING DH-3-start
4746: PPUSH
4747: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
4751: LD_EXP 21
4755: PUSH
4756: LD_EXP 23
4760: PUSH
4761: LD_EXP 22
4765: PUSH
4766: LD_EXP 24
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: LIST
4775: LIST
4776: PPUSH
4777: LD_INT 84
4779: PPUSH
4780: LD_INT 51
4782: PPUSH
4783: CALL_OW 111
// wait ( 0 0$2 ) ;
4787: LD_INT 70
4789: PPUSH
4790: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
4794: LD_EXP 22
4798: PPUSH
4799: LD_STRING DG-3-start
4801: PPUSH
4802: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
4806: LD_EXP 21
4810: PUSH
4811: LD_EXP 23
4815: PUSH
4816: LD_EXP 22
4820: PUSH
4821: LD_EXP 24
4825: PUSH
4826: EMPTY
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
4836: LD_EXP 21
4840: PPUSH
4841: LD_EXP 22
4845: PPUSH
4846: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4850: LD_EXP 22
4854: PUSH
4855: LD_EXP 23
4859: PUSH
4860: LD_EXP 24
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: LIST
4869: PPUSH
4870: LD_EXP 21
4874: PPUSH
4875: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
4879: LD_EXP 21
4883: PPUSH
4884: LD_STRING DH-4-start
4886: PPUSH
4887: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
4891: LD_EXP 22
4895: PPUSH
4896: LD_STRING DG-4-start
4898: PPUSH
4899: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
4903: LD_EXP 21
4907: PPUSH
4908: LD_STRING DH-5-start
4910: PPUSH
4911: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
4915: LD_EXP 22
4919: PPUSH
4920: LD_STRING DG-5-start
4922: PPUSH
4923: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
4927: LD_EXP 21
4931: PPUSH
4932: LD_STRING DH-6-start
4934: PPUSH
4935: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
4939: LD_EXP 23
4943: PPUSH
4944: LD_STRING DM-6-start
4946: PPUSH
4947: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
4951: LD_EXP 21
4955: PUSH
4956: LD_EXP 22
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PPUSH
4965: LD_EXP 23
4969: PPUSH
4970: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
4974: LD_EXP 22
4978: PPUSH
4979: LD_STRING DG-6-start
4981: PPUSH
4982: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
4986: LD_EXP 21
4990: PPUSH
4991: LD_STRING DH-7-start
4993: PPUSH
4994: CALL_OW 88
// end else
4998: GO 5722
// if not Mike and Givi then
5000: LD_EXP 23
5004: NOT
5005: PUSH
5006: LD_EXP 22
5010: AND
5011: IFFALSE 5356
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5013: LD_EXP 22
5017: PUSH
5018: LD_EXP 24
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PPUSH
5027: LD_EXP 21
5031: PPUSH
5032: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
5036: LD_EXP 21
5040: PPUSH
5041: LD_EXP 22
5045: PPUSH
5046: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
5050: LD_EXP 22
5054: PPUSH
5055: LD_STRING DG-1-start-c
5057: PPUSH
5058: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
5062: LD_EXP 21
5066: PPUSH
5067: LD_STRING DH-1-start-c
5069: PPUSH
5070: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
5074: LD_EXP 22
5078: PPUSH
5079: LD_STRING DG-2-start-c
5081: PPUSH
5082: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
5086: LD_EXP 21
5090: PPUSH
5091: LD_STRING DH-2-start-c
5093: PPUSH
5094: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
5098: LD_EXP 22
5102: PPUSH
5103: LD_STRING DG-3-start-c
5105: PPUSH
5106: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
5110: LD_EXP 21
5114: PPUSH
5115: LD_INT 83
5117: PPUSH
5118: LD_INT 56
5120: PPUSH
5121: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
5125: LD_EXP 22
5129: PPUSH
5130: LD_INT 83
5132: PPUSH
5133: LD_INT 59
5135: PPUSH
5136: CALL_OW 111
// if Kamil then
5140: LD_EXP 24
5144: IFFALSE 5161
// ComMoveXY ( Kamil , 80 , 58 ) ;
5146: LD_EXP 24
5150: PPUSH
5151: LD_INT 80
5153: PPUSH
5154: LD_INT 58
5156: PPUSH
5157: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
5161: LD_EXP 21
5165: PPUSH
5166: LD_EXP 22
5170: PPUSH
5171: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5175: LD_EXP 22
5179: PUSH
5180: LD_EXP 24
5184: PUSH
5185: EMPTY
5186: LIST
5187: LIST
5188: PPUSH
5189: LD_EXP 21
5193: PPUSH
5194: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
5198: LD_EXP 21
5202: PPUSH
5203: LD_STRING DH-3-start-c
5205: PPUSH
5206: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
5210: LD_EXP 22
5214: PPUSH
5215: LD_STRING DG-4-start-c
5217: PPUSH
5218: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
5222: LD_EXP 21
5226: PPUSH
5227: LD_STRING DH-5-start-c
5229: PPUSH
5230: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
5234: LD_EXP 22
5238: PPUSH
5239: LD_STRING DG-5-start-c
5241: PPUSH
5242: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
5246: LD_EXP 21
5250: PPUSH
5251: LD_STRING DH-6-start-c
5253: PPUSH
5254: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
5258: LD_EXP 22
5262: PPUSH
5263: LD_STRING DG-6-start-c
5265: PPUSH
5266: CALL_OW 88
// if Kamil then
5270: LD_EXP 24
5274: IFFALSE 5330
// begin ComTurnUnit ( Kamil , Heike ) ;
5276: LD_EXP 24
5280: PPUSH
5281: LD_EXP 21
5285: PPUSH
5286: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5290: LD_EXP 24
5294: PPUSH
5295: LD_STRING DKam-1-start-c
5297: PPUSH
5298: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
5302: LD_EXP 22
5306: PPUSH
5307: LD_EXP 24
5311: PPUSH
5312: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
5316: LD_EXP 22
5320: PPUSH
5321: LD_STRING DG-7-start-c
5323: PPUSH
5324: CALL_OW 88
// end else
5328: GO 5354
// begin Say ( Givi , DG-8-start-c ) ;
5330: LD_EXP 22
5334: PPUSH
5335: LD_STRING DG-8-start-c
5337: PPUSH
5338: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
5342: LD_EXP 21
5346: PPUSH
5347: LD_STRING DH-7-start-c
5349: PPUSH
5350: CALL_OW 88
// end ; end else
5354: GO 5722
// if not Givi and Mike then
5356: LD_EXP 22
5360: NOT
5361: PUSH
5362: LD_EXP 23
5366: AND
5367: IFFALSE 5626
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
5369: LD_EXP 23
5373: PUSH
5374: LD_EXP 24
5378: PUSH
5379: EMPTY
5380: LIST
5381: LIST
5382: PPUSH
5383: LD_EXP 21
5387: PPUSH
5388: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
5392: LD_EXP 21
5396: PPUSH
5397: LD_EXP 23
5401: PPUSH
5402: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
5406: LD_EXP 23
5410: PPUSH
5411: LD_STRING DM-1-start-b
5413: PPUSH
5414: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
5418: LD_EXP 21
5422: PPUSH
5423: LD_STRING DH-1-start-b
5425: PPUSH
5426: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
5430: LD_EXP 23
5434: PPUSH
5435: LD_STRING DM-2-start-b
5437: PPUSH
5438: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
5442: LD_EXP 21
5446: PPUSH
5447: LD_STRING DH-2-start-b
5449: PPUSH
5450: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
5454: LD_EXP 23
5458: PPUSH
5459: LD_STRING DM-3-start-b
5461: PPUSH
5462: CALL_OW 88
// if Kamil then
5466: LD_EXP 24
5470: IFFALSE 5487
// ComMoveXY ( Kamil , 80 , 58 ) ;
5472: LD_EXP 24
5476: PPUSH
5477: LD_INT 80
5479: PPUSH
5480: LD_INT 58
5482: PPUSH
5483: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
5487: LD_EXP 21
5491: PPUSH
5492: LD_INT 83
5494: PPUSH
5495: LD_INT 56
5497: PPUSH
5498: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
5502: LD_EXP 23
5506: PPUSH
5507: LD_INT 83
5509: PPUSH
5510: LD_INT 59
5512: PPUSH
5513: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
5517: LD_EXP 21
5521: PPUSH
5522: LD_EXP 23
5526: PPUSH
5527: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
5531: LD_EXP 24
5535: PUSH
5536: LD_EXP 23
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PPUSH
5545: LD_EXP 21
5549: PPUSH
5550: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
5554: LD_EXP 21
5558: PPUSH
5559: LD_STRING DH-3-start-b
5561: PPUSH
5562: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
5566: LD_EXP 23
5570: PPUSH
5571: LD_STRING DM-4-start-b
5573: PPUSH
5574: CALL_OW 88
// if Kamil then
5578: LD_EXP 24
5582: IFFALSE 5612
// begin ComTurnUnit ( Kamil , Heike ) ;
5584: LD_EXP 24
5588: PPUSH
5589: LD_EXP 21
5593: PPUSH
5594: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5598: LD_EXP 24
5602: PPUSH
5603: LD_STRING DKam-1-start-c
5605: PPUSH
5606: CALL_OW 88
// end else
5610: GO 5624
// begin Say ( Mike , DM-5-start-b ) ;
5612: LD_EXP 23
5616: PPUSH
5617: LD_STRING DM-5-start-b
5619: PPUSH
5620: CALL_OW 88
// end ; end else
5624: GO 5722
// if Kamil then
5626: LD_EXP 24
5630: IFFALSE 5710
// begin AddComTurnUnit ( Heike , Kamil ) ;
5632: LD_EXP 21
5636: PPUSH
5637: LD_EXP 24
5641: PPUSH
5642: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
5646: LD_EXP 24
5650: PPUSH
5651: LD_EXP 21
5655: PPUSH
5656: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
5660: LD_EXP 21
5664: PPUSH
5665: LD_STRING DH-1-start-f
5667: PPUSH
5668: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
5672: LD_EXP 24
5676: PPUSH
5677: LD_STRING DKam-1-start-f
5679: PPUSH
5680: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
5684: LD_EXP 21
5688: PPUSH
5689: LD_STRING DH-2-start-f
5691: PPUSH
5692: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
5696: LD_EXP 24
5700: PPUSH
5701: LD_STRING DKam-2-start-f
5703: PPUSH
5704: CALL_OW 88
// end else
5708: GO 5722
// begin Say ( Heike , DH-1-start-d ) ;
5710: LD_EXP 21
5714: PPUSH
5715: LD_STRING DH-1-start-d
5717: PPUSH
5718: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
5722: LD_EXP 21
5726: PUSH
5727: LD_EXP 22
5731: PUSH
5732: LD_EXP 23
5736: PUSH
5737: LD_EXP 24
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PPUSH
5748: CALL_OW 139
// InGameOff ;
5752: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
5756: LD_STRING OEast
5758: PPUSH
5759: CALL_OW 337
// wait ( 0 0$20 ) ;
5763: LD_INT 700
5765: PPUSH
5766: CALL_OW 67
// SendSciToForest ;
5770: CALL 1383 0 0
// if Difficulty = 1 then
5774: LD_OWVAR 67
5778: PUSH
5779: LD_INT 1
5781: EQUAL
5782: IFFALSE 5786
// exit ;
5784: GO 5903
// wait ( [ 5 5$00 , 2 2$30 ] [ Difficulty - 1 ] ) ;
5786: LD_INT 10500
5788: PUSH
5789: LD_INT 5250
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PUSH
5796: LD_OWVAR 67
5800: PUSH
5801: LD_INT 1
5803: MINUS
5804: ARRAY
5805: PPUSH
5806: CALL_OW 67
// if usAlert then
5810: LD_EXP 9
5814: IFFALSE 5818
// exit ;
5816: GO 5903
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
5818: LD_ADDR_VAR 0 3
5822: PUSH
5823: LD_INT 22
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 25
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PPUSH
5847: CALL_OW 69
5851: ST_TO_ADDR
// if not tmp then
5852: LD_VAR 0 3
5856: NOT
5857: IFFALSE 5861
// exit ;
5859: GO 5903
// ComExitBuilding ( tmp ) ;
5861: LD_VAR 0 3
5865: PPUSH
5866: CALL_OW 122
// AddComBuild ( tmp , b_breastwork , 40 , 13 , 3 ) ;
5870: LD_VAR 0 3
5874: PPUSH
5875: LD_INT 31
5877: PPUSH
5878: LD_INT 40
5880: PPUSH
5881: LD_INT 13
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: CALL_OW 205
// AddComEnterUnit ( tmp , Delta ) ;
5891: LD_VAR 0 3
5895: PPUSH
5896: LD_INT 1
5898: PPUSH
5899: CALL_OW 180
// end ;
5903: LD_VAR 0 1
5907: RET
// every 3 3$00 do
5908: GO 5910
5910: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
5911: LD_INT 1
5913: PPUSH
5914: LD_INT 570
5916: PPUSH
5917: LD_INT 350
5919: PPUSH
5920: CALL_OW 550
// wait ( 2 2$40 ) ;
5924: LD_INT 5600
5926: PPUSH
5927: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
5931: LD_INT 0
5933: PPUSH
5934: LD_INT 570
5936: PPUSH
5937: LD_INT 350
5939: PPUSH
5940: CALL_OW 550
// end ;
5944: END
// every 0 0$1 trigger not aviradzeSpotted and See ( 2 , Aviradze ) do var i , pepAmount ;
5945: LD_EXP 4
5949: NOT
5950: PUSH
5951: LD_INT 2
5953: PPUSH
5954: LD_EXP 25
5958: PPUSH
5959: CALL_OW 292
5963: AND
5964: IFFALSE 6872
5966: GO 5968
5968: DISABLE
5969: LD_INT 0
5971: PPUSH
5972: PPUSH
// begin aviradzeSpotted := true ;
5973: LD_ADDR_EXP 4
5977: PUSH
5978: LD_INT 1
5980: ST_TO_ADDR
// pepAmount := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
5981: LD_ADDR_VAR 0 2
5985: PUSH
5986: LD_INT 22
5988: PUSH
5989: LD_INT 2
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: PUSH
5996: LD_INT 21
5998: PUSH
5999: LD_INT 1
6001: PUSH
6002: EMPTY
6003: LIST
6004: LIST
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: ST_TO_ADDR
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6015: LD_EXP 21
6019: PPUSH
6020: LD_EXP 25
6024: PPUSH
6025: CALL_OW 250
6029: PPUSH
6030: LD_EXP 25
6034: PPUSH
6035: CALL_OW 251
6039: PPUSH
6040: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6044: LD_INT 35
6046: PPUSH
6047: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 16 ;
6051: LD_EXP 21
6055: PPUSH
6056: LD_EXP 25
6060: PPUSH
6061: CALL_OW 296
6065: PUSH
6066: LD_INT 16
6068: LESS
6069: IFFALSE 6044
// InGameOn ;
6071: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6075: LD_INT 5
6077: PPUSH
6078: LD_INT 2
6080: PPUSH
6081: CALL_OW 343
// if pepAmount > 2 then
6085: LD_VAR 0 2
6089: PUSH
6090: LD_INT 2
6092: GREATER
6093: IFFALSE 6109
// Say ( Heike , DH-1-spot ) else
6095: LD_EXP 21
6099: PPUSH
6100: LD_STRING DH-1-spot
6102: PPUSH
6103: CALL_OW 88
6107: GO 6121
// Say ( Heike , DH-1-spot-d ) ;
6109: LD_EXP 21
6113: PPUSH
6114: LD_STRING DH-1-spot-d
6116: PPUSH
6117: CALL_OW 88
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6121: LD_EXP 21
6125: PPUSH
6126: LD_EXP 25
6130: PPUSH
6131: CALL_OW 250
6135: PPUSH
6136: LD_EXP 25
6140: PPUSH
6141: CALL_OW 251
6145: PPUSH
6146: CALL_OW 111
// for i in [ Kamil , Mike , Givi ] do
6150: LD_ADDR_VAR 0 1
6154: PUSH
6155: LD_EXP 24
6159: PUSH
6160: LD_EXP 23
6164: PUSH
6165: LD_EXP 22
6169: PUSH
6170: EMPTY
6171: LIST
6172: LIST
6173: LIST
6174: PUSH
6175: FOR_IN
6176: IFFALSE 6215
// if GetDistUnits ( i , Aviradze ) > 7 then
6178: LD_VAR 0 1
6182: PPUSH
6183: LD_EXP 25
6187: PPUSH
6188: CALL_OW 296
6192: PUSH
6193: LD_INT 7
6195: GREATER
6196: IFFALSE 6213
// ComMoveXY ( i , 102 , 40 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 102
6205: PPUSH
6206: LD_INT 40
6208: PPUSH
6209: CALL_OW 111
6213: GO 6175
6215: POP
6216: POP
// repeat wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 6 ;
6224: LD_EXP 21
6228: PPUSH
6229: LD_EXP 25
6233: PPUSH
6234: CALL_OW 296
6238: PUSH
6239: LD_INT 6
6241: LESS
6242: IFFALSE 6217
// ComTurnUnit ( Heike , Aviradze ) ;
6244: LD_EXP 21
6248: PPUSH
6249: LD_EXP 25
6253: PPUSH
6254: CALL_OW 119
// ComTurnUnit ( [ Aviradze , Sophia , Kaia ] , Heike ) ;
6258: LD_EXP 25
6262: PUSH
6263: LD_EXP 27
6267: PUSH
6268: LD_EXP 26
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: LIST
6277: PPUSH
6278: LD_EXP 21
6282: PPUSH
6283: CALL_OW 119
// if pepAmount > 1 then
6287: LD_VAR 0 2
6291: PUSH
6292: LD_INT 1
6294: GREATER
6295: IFFALSE 6347
// begin wait ( 0 0$2 ) ;
6297: LD_INT 70
6299: PPUSH
6300: CALL_OW 67
// ComTurnUnit ( [ Kamil , Mike , Givi ] , Aviradze ) ;
6304: LD_EXP 24
6308: PUSH
6309: LD_EXP 23
6313: PUSH
6314: LD_EXP 22
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: PPUSH
6324: LD_EXP 25
6328: PPUSH
6329: CALL_OW 119
// Say ( Heike , DH-2-spot ) ;
6333: LD_EXP 21
6337: PPUSH
6338: LD_STRING DH-2-spot
6340: PPUSH
6341: CALL_OW 88
// end else
6345: GO 6359
// Say ( Heike , DH-2-spot-d ) ;
6347: LD_EXP 21
6351: PPUSH
6352: LD_STRING DH-2-spot-d
6354: PPUSH
6355: CALL_OW 88
// Say ( Aviradze , DA-2-spot ) ;
6359: LD_EXP 25
6363: PPUSH
6364: LD_STRING DA-2-spot
6366: PPUSH
6367: CALL_OW 88
// Say ( Heike , DH-3-spot ) ;
6371: LD_EXP 21
6375: PPUSH
6376: LD_STRING DH-3-spot
6378: PPUSH
6379: CALL_OW 88
// ComMoveUnit ( Kaia , Heike ) ;
6383: LD_EXP 26
6387: PPUSH
6388: LD_EXP 21
6392: PPUSH
6393: CALL_OW 112
// ComTurnUNit ( Heike , Kaia ) ;
6397: LD_EXP 21
6401: PPUSH
6402: LD_EXP 26
6406: PPUSH
6407: CALL_OW 119
// wait ( 0 0$0.3 ) ;
6411: LD_INT 10
6413: PPUSH
6414: CALL_OW 67
// async ;
6418: ASYNC
// Say ( Kaia , DK-3-spot ) ;
6419: LD_EXP 26
6423: PPUSH
6424: LD_STRING DK-3-spot
6426: PPUSH
6427: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6431: LD_INT 35
6433: PPUSH
6434: CALL_OW 67
// until GetDistUnits ( Heike , Kaia ) < 4 ;
6438: LD_EXP 21
6442: PPUSH
6443: LD_EXP 26
6447: PPUSH
6448: CALL_OW 296
6452: PUSH
6453: LD_INT 4
6455: LESS
6456: IFFALSE 6431
// ComTurnUnit ( Kaia , Heike ) ;
6458: LD_EXP 26
6462: PPUSH
6463: LD_EXP 21
6467: PPUSH
6468: CALL_OW 119
// sync ;
6472: SYNC
// Say ( Heike , DH-4-spot ) ;
6473: LD_EXP 21
6477: PPUSH
6478: LD_STRING DH-4-spot
6480: PPUSH
6481: CALL_OW 88
// wait ( 0 0$0.3 ) ;
6485: LD_INT 10
6487: PPUSH
6488: CALL_OW 67
// ComTurnUnit ( Heike , Aviradze ) ;
6492: LD_EXP 21
6496: PPUSH
6497: LD_EXP 25
6501: PPUSH
6502: CALL_OW 119
// Say ( Aviradze , DA-4-spot ) ;
6506: LD_EXP 25
6510: PPUSH
6511: LD_STRING DA-4-spot
6513: PPUSH
6514: CALL_OW 88
// ComTurnUnit ( Kaia , Aviradze ) ;
6518: LD_EXP 26
6522: PPUSH
6523: LD_EXP 25
6527: PPUSH
6528: CALL_OW 119
// Say ( Kaia , DK-4-spot ) ;
6532: LD_EXP 26
6536: PPUSH
6537: LD_STRING DK-4-spot
6539: PPUSH
6540: CALL_OW 88
// ComTurnUnit ( Aviradze , Kaia ) ;
6544: LD_EXP 25
6548: PPUSH
6549: LD_EXP 26
6553: PPUSH
6554: CALL_OW 119
// Say ( Aviradze , DA-5-spot ) ;
6558: LD_EXP 25
6562: PPUSH
6563: LD_STRING DA-5-spot
6565: PPUSH
6566: CALL_OW 88
// Say ( Kaia , DK-5-spot ) ;
6570: LD_EXP 26
6574: PPUSH
6575: LD_STRING DK-5-spot
6577: PPUSH
6578: CALL_OW 88
// if pepAmount = 1 then
6582: LD_VAR 0 2
6586: PUSH
6587: LD_INT 1
6589: EQUAL
6590: IFFALSE 6604
// Say ( Heike , DH-5-spot-f ) ;
6592: LD_EXP 21
6596: PPUSH
6597: LD_STRING DH-5-spot-f
6599: PPUSH
6600: CALL_OW 88
// if pepAmount < 3 then
6604: LD_VAR 0 2
6608: PUSH
6609: LD_INT 3
6611: LESS
6612: IFFALSE 6628
// Say ( Aviradze , DA-6-spot-f ) else
6614: LD_EXP 25
6618: PPUSH
6619: LD_STRING DA-6-spot-f
6621: PPUSH
6622: CALL_OW 88
6626: GO 6664
// if pepAmount < 4 then
6628: LD_VAR 0 2
6632: PUSH
6633: LD_INT 4
6635: LESS
6636: IFFALSE 6652
// Say ( Aviradze , DA-6-spot-c ) else
6638: LD_EXP 25
6642: PPUSH
6643: LD_STRING DA-6-spot-c
6645: PPUSH
6646: CALL_OW 88
6650: GO 6664
// Say ( Aviradze , DA-6-spot ) ;
6652: LD_EXP 25
6656: PPUSH
6657: LD_STRING DA-6-spot
6659: PPUSH
6660: CALL_OW 88
// if Kamil then
6664: LD_EXP 24
6668: IFFALSE 6682
// Say ( Kamil , DKam-6-spot ) ;
6670: LD_EXP 24
6674: PPUSH
6675: LD_STRING DKam-6-spot
6677: PPUSH
6678: CALL_OW 88
// Say ( Kaia , DK-6-spot ) ;
6682: LD_EXP 26
6686: PPUSH
6687: LD_STRING DK-6-spot
6689: PPUSH
6690: CALL_OW 88
// ComTurnUnit ( Aviradze , Heike ) ;
6694: LD_EXP 25
6698: PPUSH
6699: LD_EXP 21
6703: PPUSH
6704: CALL_OW 119
// Say ( Aviradze , DA-7-spot ) ;
6708: LD_EXP 25
6712: PPUSH
6713: LD_STRING DA-7-spot
6715: PPUSH
6716: CALL_OW 88
// Say ( Heike , DH-7-spot ) ;
6720: LD_EXP 21
6724: PPUSH
6725: LD_STRING DH-7-spot
6727: PPUSH
6728: CALL_OW 88
// if sciCounterKill >= 3 then
6732: LD_EXP 8
6736: PUSH
6737: LD_INT 3
6739: GREATEREQUAL
6740: IFFALSE 6766
// begin Say ( Heike , DH-7-spot-a ) ;
6742: LD_EXP 21
6746: PPUSH
6747: LD_STRING DH-7-spot-a
6749: PPUSH
6750: CALL_OW 88
// Say ( Aviradze , DA-8-spot-a ) ;
6754: LD_EXP 25
6758: PPUSH
6759: LD_STRING DA-8-spot-a
6761: PPUSH
6762: CALL_OW 88
// end ; InGameOff ;
6766: CALL_OW 9
// if sciCounterKill < 3 then
6770: LD_EXP 8
6774: PUSH
6775: LD_INT 3
6777: LESS
6778: IFFALSE 6810
// begin SetSide ( Kaia , 2 ) ;
6780: LD_EXP 26
6784: PPUSH
6785: LD_INT 2
6787: PPUSH
6788: CALL_OW 235
// ComFree ( Kaia ) ;
6792: LD_EXP 26
6796: PPUSH
6797: CALL_OW 139
// ChangeMissionObjectives ( OSci ) ;
6801: LD_STRING OSci
6803: PPUSH
6804: CALL_OW 337
// end else
6808: GO 6872
// begin aviradzeQuestDone := true ;
6810: LD_ADDR_EXP 7
6814: PUSH
6815: LD_INT 1
6817: ST_TO_ADDR
// attackDeltaAllowed := true ;
6818: LD_ADDR_EXP 12
6822: PUSH
6823: LD_INT 1
6825: ST_TO_ADDR
// ChangeMissionObjectives ( ODelta2 ) ;
6826: LD_STRING ODelta2
6828: PPUSH
6829: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
6833: LD_ADDR_VAR 0 1
6837: PUSH
6838: LD_INT 22
6840: PUSH
6841: LD_INT 5
6843: PUSH
6844: EMPTY
6845: LIST
6846: LIST
6847: PPUSH
6848: CALL_OW 69
6852: PUSH
6853: FOR_IN
6854: IFFALSE 6870
// SetSide ( i , 2 ) ;
6856: LD_VAR 0 1
6860: PPUSH
6861: LD_INT 2
6863: PPUSH
6864: CALL_OW 235
6868: GO 6853
6870: POP
6871: POP
// end ; end ;
6872: PPOPN 2
6874: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and not aviradzeSpotted do
6875: LD_EXP 6
6879: NOT
6880: PUSH
6881: LD_EXP 20
6885: PPUSH
6886: LD_EXP 21
6890: PPUSH
6891: CALL_OW 74
6895: PPUSH
6896: LD_EXP 21
6900: PPUSH
6901: CALL_OW 296
6905: PUSH
6906: LD_INT 8
6908: LESS
6909: AND
6910: PUSH
6911: LD_INT 2
6913: PPUSH
6914: LD_EXP 20
6918: PPUSH
6919: LD_EXP 21
6923: PPUSH
6924: CALL_OW 74
6928: PPUSH
6929: CALL_OW 292
6933: AND
6934: PUSH
6935: LD_INT 22
6937: PUSH
6938: LD_INT 2
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PUSH
6945: LD_INT 21
6947: PUSH
6948: LD_INT 1
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: PPUSH
6959: CALL_OW 69
6963: PUSH
6964: LD_INT 1
6966: GREATER
6967: AND
6968: PUSH
6969: LD_EXP 4
6973: NOT
6974: AND
6975: IFFALSE 7019
6977: GO 6979
6979: DISABLE
// begin sciSpotted := true ;
6980: LD_ADDR_EXP 6
6984: PUSH
6985: LD_INT 1
6987: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
6988: LD_EXP 20
6992: PPUSH
6993: LD_EXP 21
6997: PPUSH
6998: CALL_OW 74
7002: PPUSH
7003: CALL_OW 87
// Say ( Heike , DH-1-sci ) ;
7007: LD_EXP 21
7011: PPUSH
7012: LD_STRING DH-1-sci
7014: PPUSH
7015: CALL_OW 88
// end ;
7019: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and aviradzeSpotted and not aviradzeQuestDone do
7020: LD_EXP 6
7024: NOT
7025: PUSH
7026: LD_EXP 20
7030: PPUSH
7031: LD_EXP 21
7035: PPUSH
7036: CALL_OW 74
7040: PPUSH
7041: LD_EXP 21
7045: PPUSH
7046: CALL_OW 296
7050: PUSH
7051: LD_INT 8
7053: LESS
7054: AND
7055: PUSH
7056: LD_INT 2
7058: PPUSH
7059: LD_EXP 20
7063: PPUSH
7064: LD_EXP 21
7068: PPUSH
7069: CALL_OW 74
7073: PPUSH
7074: CALL_OW 292
7078: AND
7079: PUSH
7080: LD_INT 22
7082: PUSH
7083: LD_INT 2
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 21
7092: PUSH
7093: LD_INT 1
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: PUSH
7109: LD_INT 1
7111: GREATER
7112: AND
7113: PUSH
7114: LD_EXP 4
7118: AND
7119: PUSH
7120: LD_EXP 7
7124: NOT
7125: AND
7126: IFFALSE 7188
7128: GO 7130
7130: DISABLE
// begin sciSpotted := true ;
7131: LD_ADDR_EXP 6
7135: PUSH
7136: LD_INT 1
7138: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7139: LD_EXP 20
7143: PPUSH
7144: LD_EXP 21
7148: PPUSH
7149: CALL_OW 74
7153: PPUSH
7154: CALL_OW 87
// Say ( Heike , DH-1-sci-a ) ;
7158: LD_EXP 21
7162: PPUSH
7163: LD_STRING DH-1-sci-a
7165: PPUSH
7166: CALL_OW 88
// if Mike then
7170: LD_EXP 23
7174: IFFALSE 7188
// Say ( Mike , DM-1-sci-a ) ;
7176: LD_EXP 23
7180: PPUSH
7181: LD_STRING DM-1-sci-a
7183: PPUSH
7184: CALL_OW 88
// end ;
7188: END
// every 0 0$1 trigger aviradzeSpotted and sciCounterKill >= 3 and not aviradzeQuestDone do
7189: LD_EXP 4
7193: PUSH
7194: LD_EXP 8
7198: PUSH
7199: LD_INT 3
7201: GREATEREQUAL
7202: AND
7203: PUSH
7204: LD_EXP 7
7208: NOT
7209: AND
7210: IFFALSE 7253
7212: GO 7214
7214: DISABLE
// begin aviradzeQuestDone := true ;
7215: LD_ADDR_EXP 7
7219: PUSH
7220: LD_INT 1
7222: ST_TO_ADDR
// Say ( Heike , DH-1-quest-done ) ;
7223: LD_EXP 21
7227: PPUSH
7228: LD_STRING DH-1-quest-done
7230: PPUSH
7231: CALL_OW 88
// if Givi then
7235: LD_EXP 22
7239: IFFALSE 7253
// Say ( Givi , DG-1-quest-done ) ;
7241: LD_EXP 22
7245: PPUSH
7246: LD_STRING DG-1-quest-done
7248: PPUSH
7249: CALL_OW 88
// end ;
7253: END
// every 0 0$1 trigger See ( 5 , Heike ) and GetDistUnits ( Heike , Aviradze ) < 6 and aviradzeQuestDone and not attackDeltaAllowed do var i ;
7254: LD_INT 5
7256: PPUSH
7257: LD_EXP 21
7261: PPUSH
7262: CALL_OW 292
7266: PUSH
7267: LD_EXP 21
7271: PPUSH
7272: LD_EXP 25
7276: PPUSH
7277: CALL_OW 296
7281: PUSH
7282: LD_INT 6
7284: LESS
7285: AND
7286: PUSH
7287: LD_EXP 7
7291: AND
7292: PUSH
7293: LD_EXP 12
7297: NOT
7298: AND
7299: IFFALSE 7437
7301: GO 7303
7303: DISABLE
7304: LD_INT 0
7306: PPUSH
// begin attackDeltaAllowed := true ;
7307: LD_ADDR_EXP 12
7311: PUSH
7312: LD_INT 1
7314: ST_TO_ADDR
// InGameOn ;
7315: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
7319: LD_EXP 21
7323: PPUSH
7324: CALL_OW 87
// wait ( 0 0$0.3 ) ;
7328: LD_INT 10
7330: PPUSH
7331: CALL_OW 67
// ComTurnUnit ( Aviradze , Heike ) ;
7335: LD_EXP 25
7339: PPUSH
7340: LD_EXP 21
7344: PPUSH
7345: CALL_OW 119
// ComTurnUnit ( Heike , Aviradze ) ;
7349: LD_EXP 21
7353: PPUSH
7354: LD_EXP 25
7358: PPUSH
7359: CALL_OW 119
// Say ( Heike , DH-1-return ) ;
7363: LD_EXP 21
7367: PPUSH
7368: LD_STRING DH-1-return
7370: PPUSH
7371: CALL_OW 88
// Say ( Aviradze , DA-1-return ) ;
7375: LD_EXP 25
7379: PPUSH
7380: LD_STRING DA-1-return
7382: PPUSH
7383: CALL_OW 88
// InGameOff ;
7387: CALL_OW 9
// ChangeMissionObjectives ( ODelta ) ;
7391: LD_STRING ODelta
7393: PPUSH
7394: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7398: LD_ADDR_VAR 0 1
7402: PUSH
7403: LD_INT 22
7405: PUSH
7406: LD_INT 5
7408: PUSH
7409: EMPTY
7410: LIST
7411: LIST
7412: PPUSH
7413: CALL_OW 69
7417: PUSH
7418: FOR_IN
7419: IFFALSE 7435
// SetSide ( i , 2 ) ;
7421: LD_VAR 0 1
7425: PPUSH
7426: LD_INT 2
7428: PPUSH
7429: CALL_OW 235
7433: GO 7418
7435: POP
7436: POP
// end ;
7437: PPOPN 1
7439: END
// every 0 0$1 trigger attackDeltaAllowed and IsOk ( Markov ) and GetSide ( Delta ) = 1 and IsOk ( Lynch ) and not usAlert do var i , k , tmp ;
7440: LD_EXP 12
7444: PUSH
7445: LD_EXP 28
7449: PPUSH
7450: CALL_OW 302
7454: AND
7455: PUSH
7456: LD_INT 1
7458: PPUSH
7459: CALL_OW 255
7463: PUSH
7464: LD_INT 1
7466: EQUAL
7467: AND
7468: PUSH
7469: LD_EXP 18
7473: PPUSH
7474: CALL_OW 302
7478: AND
7479: PUSH
7480: LD_EXP 9
7484: NOT
7485: AND
7486: IFFALSE 8656
7488: GO 7490
7490: DISABLE
7491: LD_INT 0
7493: PPUSH
7494: PPUSH
7495: PPUSH
// begin trap := 0 ;
7496: LD_ADDR_EXP 15
7500: PUSH
7501: LD_INT 0
7503: ST_TO_ADDR
// wait ( 0 0$15 ) ;
7504: LD_INT 525
7506: PPUSH
7507: CALL_OW 67
// DialogueOn ;
7511: CALL_OW 6
// Say ( Markov , DMar-1-radio ) ;
7515: LD_EXP 28
7519: PPUSH
7520: LD_STRING DMar-1-radio
7522: PPUSH
7523: CALL_OW 88
// Say ( Heike , DH-1-radio ) ;
7527: LD_EXP 21
7531: PPUSH
7532: LD_STRING DH-1-radio
7534: PPUSH
7535: CALL_OW 88
// Say ( Markov , DMar-2-radio ) ;
7539: LD_EXP 28
7543: PPUSH
7544: LD_STRING DMar-2-radio
7546: PPUSH
7547: CALL_OW 88
// Say ( Heike , DH-2-radio ) ;
7551: LD_EXP 21
7555: PPUSH
7556: LD_STRING DH-2-radio
7558: PPUSH
7559: CALL_OW 88
// if IsOk ( Kamil ) or IsOk ( Sophia ) then
7563: LD_EXP 24
7567: PPUSH
7568: CALL_OW 302
7572: PUSH
7573: LD_EXP 27
7577: PPUSH
7578: CALL_OW 302
7582: OR
7583: IFFALSE 8656
// begin case Query ( Q1Trap ) of 1 :
7585: LD_STRING Q1Trap
7587: PPUSH
7588: CALL_OW 97
7592: PUSH
7593: LD_INT 1
7595: DOUBLE
7596: EQUAL
7597: IFTRUE 7601
7599: GO 7795
7601: POP
// begin if IsOk ( Kamil ) then
7602: LD_EXP 24
7606: PPUSH
7607: CALL_OW 302
7611: IFFALSE 7690
// begin Say ( Kamil , DKam-2-radio ) ;
7613: LD_EXP 24
7617: PPUSH
7618: LD_STRING DKam-2-radio
7620: PPUSH
7621: CALL_OW 88
// Say ( Kamil , DKam-3-radio ) ;
7625: LD_EXP 24
7629: PPUSH
7630: LD_STRING DKam-3-radio
7632: PPUSH
7633: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio ) ;
7637: LD_EXP 18
7641: PPUSH
7642: LD_STRING DDelta-3-radio
7644: PPUSH
7645: CALL_OW 94
// dwait ( 0 0$01 ) ;
7649: LD_INT 35
7651: PPUSH
7652: CALL_OW 68
// Say ( Heike , DH-3-radio ) ;
7656: LD_EXP 21
7660: PPUSH
7661: LD_STRING DH-3-radio
7663: PPUSH
7664: CALL_OW 88
// Say ( Kamil , DKam-4-radio ) ;
7668: LD_EXP 24
7672: PPUSH
7673: LD_STRING DKam-4-radio
7675: PPUSH
7676: CALL_OW 88
// trap := 1 ;
7680: LD_ADDR_EXP 15
7684: PUSH
7685: LD_INT 1
7687: ST_TO_ADDR
// end else
7688: GO 7789
// begin Say ( Sophia , DS-1-radio ) ;
7690: LD_EXP 27
7694: PPUSH
7695: LD_STRING DS-1-radio
7697: PPUSH
7698: CALL_OW 88
// Say ( Sophia , DS-2-radio ) ;
7702: LD_EXP 27
7706: PPUSH
7707: LD_STRING DS-2-radio
7709: PPUSH
7710: CALL_OW 88
// SayRadio ( Lynch , DDelta-2-radio-s ) ;
7714: LD_EXP 18
7718: PPUSH
7719: LD_STRING DDelta-2-radio-s
7721: PPUSH
7722: CALL_OW 94
// Say ( Sophia , DS-3-radio ) ;
7726: LD_EXP 27
7730: PPUSH
7731: LD_STRING DS-3-radio
7733: PPUSH
7734: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio-s ) ;
7738: LD_EXP 18
7742: PPUSH
7743: LD_STRING DDelta-3-radio-s
7745: PPUSH
7746: CALL_OW 94
// Say ( Sophia , DS-4-radio-s ) ;
7750: LD_EXP 27
7754: PPUSH
7755: LD_STRING DS-4-radio-s
7757: PPUSH
7758: CALL_OW 88
// dwait ( 0 0$01 ) ;
7762: LD_INT 35
7764: PPUSH
7765: CALL_OW 68
// Say ( Heike , DH-1-trap ) ;
7769: LD_EXP 21
7773: PPUSH
7774: LD_STRING DH-1-trap
7776: PPUSH
7777: CALL_OW 88
// trap := 0 ;
7781: LD_ADDR_EXP 15
7785: PUSH
7786: LD_INT 0
7788: ST_TO_ADDR
// end ; DialogueOff ;
7789: CALL_OW 7
// end ; 2 :
7793: GO 7813
7795: LD_INT 2
7797: DOUBLE
7798: EQUAL
7799: IFTRUE 7803
7801: GO 7812
7803: POP
// begin DialogueOff ;
7804: CALL_OW 7
// exit ;
7808: GO 8656
// end ; end ;
7810: GO 7813
7812: POP
// if trap = 1 then
7813: LD_EXP 15
7817: PUSH
7818: LD_INT 1
7820: EQUAL
7821: IFFALSE 8227
// begin tmp := [ ] ;
7823: LD_ADDR_VAR 0 3
7827: PUSH
7828: EMPTY
7829: ST_TO_ADDR
// k := 3 ;
7830: LD_ADDR_VAR 0 2
7834: PUSH
7835: LD_INT 3
7837: ST_TO_ADDR
// if usForces < 3 then
7838: LD_EXP 19
7842: PUSH
7843: LD_INT 3
7845: LESS
7846: IFFALSE 7858
// k := usForces ;
7848: LD_ADDR_VAR 0 2
7852: PUSH
7853: LD_EXP 19
7857: ST_TO_ADDR
// for i := 1 to k do
7858: LD_ADDR_VAR 0 1
7862: PUSH
7863: DOUBLE
7864: LD_INT 1
7866: DEC
7867: ST_TO_ADDR
7868: LD_VAR 0 2
7872: PUSH
7873: FOR_TO
7874: IFFALSE 7929
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
7876: LD_ADDR_VAR 0 3
7880: PUSH
7881: LD_VAR 0 3
7885: PPUSH
7886: LD_VAR 0 3
7890: PUSH
7891: LD_INT 1
7893: PLUS
7894: PPUSH
7895: LD_EXP 19
7899: PUSH
7900: LD_INT 1
7902: ARRAY
7903: PPUSH
7904: CALL_OW 1
7908: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
7909: LD_ADDR_EXP 19
7913: PUSH
7914: LD_EXP 19
7918: PPUSH
7919: LD_INT 1
7921: PPUSH
7922: CALL_OW 3
7926: ST_TO_ADDR
// end ;
7927: GO 7873
7929: POP
7930: POP
// usPatrol := tmp ;
7931: LD_ADDR_EXP 14
7935: PUSH
7936: LD_VAR 0 3
7940: ST_TO_ADDR
// for i in tmp do
7941: LD_ADDR_VAR 0 1
7945: PUSH
7946: LD_VAR 0 3
7950: PUSH
7951: FOR_IN
7952: IFFALSE 8082
// begin if IsInUnit ( i ) then
7954: LD_VAR 0 1
7958: PPUSH
7959: CALL_OW 310
7963: IFFALSE 7974
// ComExitBuilding ( i ) ;
7965: LD_VAR 0 1
7969: PPUSH
7970: CALL_OW 122
// AddComAgressiveMove ( i , 63 , 31 ) ;
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 63
7981: PPUSH
7982: LD_INT 31
7984: PPUSH
7985: CALL_OW 174
// AddComWait ( i , 0 0$2 ) ;
7989: LD_VAR 0 1
7993: PPUSH
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 202
// AddComAgressiveMove ( i , 103 , 43 ) ;
8001: LD_VAR 0 1
8005: PPUSH
8006: LD_INT 103
8008: PPUSH
8009: LD_INT 43
8011: PPUSH
8012: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8016: LD_VAR 0 1
8020: PPUSH
8021: LD_INT 105
8023: PPUSH
8024: CALL_OW 202
// if Difficulty > 1 then
8028: LD_OWVAR 67
8032: PUSH
8033: LD_INT 1
8035: GREATER
8036: IFFALSE 8053
// AddComAgressiveMove ( i , 114 , 69 ) ;
8038: LD_VAR 0 1
8042: PPUSH
8043: LD_INT 114
8045: PPUSH
8046: LD_INT 69
8048: PPUSH
8049: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8053: LD_VAR 0 1
8057: PPUSH
8058: LD_INT 105
8060: PPUSH
8061: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8065: LD_VAR 0 1
8069: PPUSH
8070: LD_INT 42
8072: PPUSH
8073: LD_INT 20
8075: PPUSH
8076: CALL_OW 174
// end ;
8080: GO 7951
8082: POP
8083: POP
// repeat wait ( 0 0$1 ) ;
8084: LD_INT 35
8086: PPUSH
8087: CALL_OW 67
// for i in tmp do
8091: LD_ADDR_VAR 0 1
8095: PUSH
8096: LD_VAR 0 3
8100: PUSH
8101: FOR_IN
8102: IFFALSE 8133
// if IsDead ( i ) then
8104: LD_VAR 0 1
8108: PPUSH
8109: CALL_OW 301
8113: IFFALSE 8131
// tmp := tmp diff i ;
8115: LD_ADDR_VAR 0 3
8119: PUSH
8120: LD_VAR 0 3
8124: PUSH
8125: LD_VAR 0 1
8129: DIFF
8130: ST_TO_ADDR
8131: GO 8101
8133: POP
8134: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8135: LD_VAR 0 3
8139: NOT
8140: PUSH
8141: LD_VAR 0 3
8145: PPUSH
8146: LD_INT 95
8148: PUSH
8149: LD_INT 7
8151: PUSH
8152: EMPTY
8153: LIST
8154: LIST
8155: PUSH
8156: LD_INT 3
8158: PUSH
8159: LD_INT 60
8161: PUSH
8162: EMPTY
8163: LIST
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PPUSH
8173: CALL_OW 72
8177: PUSH
8178: LD_VAR 0 3
8182: EQUAL
8183: OR
8184: IFFALSE 8084
// if tmp then
8186: LD_VAR 0 3
8190: IFFALSE 8217
// begin usPatrol := [ ] ;
8192: LD_ADDR_EXP 14
8196: PUSH
8197: EMPTY
8198: ST_TO_ADDR
// usForces := usForces union tmp ;
8199: LD_ADDR_EXP 19
8203: PUSH
8204: LD_EXP 19
8208: PUSH
8209: LD_VAR 0 3
8213: UNION
8214: ST_TO_ADDR
// end else
8215: GO 8225
// trickyMove := true ;
8217: LD_ADDR_EXP 13
8221: PUSH
8222: LD_INT 1
8224: ST_TO_ADDR
// end else
8225: GO 8656
// begin tmp := [ ] ;
8227: LD_ADDR_VAR 0 3
8231: PUSH
8232: EMPTY
8233: ST_TO_ADDR
// k := 4 ;
8234: LD_ADDR_VAR 0 2
8238: PUSH
8239: LD_INT 4
8241: ST_TO_ADDR
// if usForces < 4 then
8242: LD_EXP 19
8246: PUSH
8247: LD_INT 4
8249: LESS
8250: IFFALSE 8262
// k := usForces ;
8252: LD_ADDR_VAR 0 2
8256: PUSH
8257: LD_EXP 19
8261: ST_TO_ADDR
// for i := 1 to k do
8262: LD_ADDR_VAR 0 1
8266: PUSH
8267: DOUBLE
8268: LD_INT 1
8270: DEC
8271: ST_TO_ADDR
8272: LD_VAR 0 2
8276: PUSH
8277: FOR_TO
8278: IFFALSE 8333
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8280: LD_ADDR_VAR 0 3
8284: PUSH
8285: LD_VAR 0 3
8289: PPUSH
8290: LD_VAR 0 3
8294: PUSH
8295: LD_INT 1
8297: PLUS
8298: PPUSH
8299: LD_EXP 19
8303: PUSH
8304: LD_INT 1
8306: ARRAY
8307: PPUSH
8308: CALL_OW 1
8312: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8313: LD_ADDR_EXP 19
8317: PUSH
8318: LD_EXP 19
8322: PPUSH
8323: LD_INT 1
8325: PPUSH
8326: CALL_OW 3
8330: ST_TO_ADDR
// end ;
8331: GO 8277
8333: POP
8334: POP
// if Lynch then
8335: LD_EXP 18
8339: IFFALSE 8357
// tmp := tmp ^ Lynch ;
8341: LD_ADDR_VAR 0 3
8345: PUSH
8346: LD_VAR 0 3
8350: PUSH
8351: LD_EXP 18
8355: ADD
8356: ST_TO_ADDR
// usPatrol := tmp ;
8357: LD_ADDR_EXP 14
8361: PUSH
8362: LD_VAR 0 3
8366: ST_TO_ADDR
// for i in tmp do
8367: LD_ADDR_VAR 0 1
8371: PUSH
8372: LD_VAR 0 3
8376: PUSH
8377: FOR_IN
8378: IFFALSE 8471
// begin if IsInUnit ( i ) then
8380: LD_VAR 0 1
8384: PPUSH
8385: CALL_OW 310
8389: IFFALSE 8400
// ComExitBuilding ( i ) ;
8391: LD_VAR 0 1
8395: PPUSH
8396: CALL_OW 122
// AddComAgressiveMove ( i , 69 , 15 ) ;
8400: LD_VAR 0 1
8404: PPUSH
8405: LD_INT 69
8407: PPUSH
8408: LD_INT 15
8410: PPUSH
8411: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8415: LD_VAR 0 1
8419: PPUSH
8420: LD_INT 700
8422: PPUSH
8423: CALL_OW 202
// AddComAgressiveMove ( i , 55 , 43 ) ;
8427: LD_VAR 0 1
8431: PPUSH
8432: LD_INT 55
8434: PPUSH
8435: LD_INT 43
8437: PPUSH
8438: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8442: LD_VAR 0 1
8446: PPUSH
8447: LD_INT 700
8449: PPUSH
8450: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8454: LD_VAR 0 1
8458: PPUSH
8459: LD_INT 42
8461: PPUSH
8462: LD_INT 20
8464: PPUSH
8465: CALL_OW 174
// end ;
8469: GO 8377
8471: POP
8472: POP
// repeat wait ( 0 0$1 ) ;
8473: LD_INT 35
8475: PPUSH
8476: CALL_OW 67
// for i in tmp do
8480: LD_ADDR_VAR 0 1
8484: PUSH
8485: LD_VAR 0 3
8489: PUSH
8490: FOR_IN
8491: IFFALSE 8522
// if IsDead ( i ) then
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 301
8502: IFFALSE 8520
// tmp := tmp diff i ;
8504: LD_ADDR_VAR 0 3
8508: PUSH
8509: LD_VAR 0 3
8513: PUSH
8514: LD_VAR 0 1
8518: DIFF
8519: ST_TO_ADDR
8520: GO 8490
8522: POP
8523: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8524: LD_VAR 0 3
8528: NOT
8529: PUSH
8530: LD_VAR 0 3
8534: PPUSH
8535: LD_INT 95
8537: PUSH
8538: LD_INT 7
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: PUSH
8545: LD_INT 3
8547: PUSH
8548: LD_INT 60
8550: PUSH
8551: EMPTY
8552: LIST
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PPUSH
8562: CALL_OW 72
8566: PUSH
8567: LD_VAR 0 3
8571: EQUAL
8572: OR
8573: IFFALSE 8473
// if not tmp then
8575: LD_VAR 0 3
8579: NOT
8580: IFFALSE 8592
// trickyMove := true else
8582: LD_ADDR_EXP 13
8586: PUSH
8587: LD_INT 1
8589: ST_TO_ADDR
8590: GO 8599
// usPatrol := [ ] ;
8592: LD_ADDR_EXP 14
8596: PUSH
8597: EMPTY
8598: ST_TO_ADDR
// if tmp diff Lynch then
8599: LD_VAR 0 3
8603: PUSH
8604: LD_EXP 18
8608: DIFF
8609: IFFALSE 8633
// usForces := usForces union ( tmp diff Lynch ) ;
8611: LD_ADDR_EXP 19
8615: PUSH
8616: LD_EXP 19
8620: PUSH
8621: LD_VAR 0 3
8625: PUSH
8626: LD_EXP 18
8630: DIFF
8631: UNION
8632: ST_TO_ADDR
// if IsOk ( Lynch ) then
8633: LD_EXP 18
8637: PPUSH
8638: CALL_OW 302
8642: IFFALSE 8656
// ComEnterUnit ( Lynch , Delta ) ;
8644: LD_EXP 18
8648: PPUSH
8649: LD_INT 1
8651: PPUSH
8652: CALL_OW 120
// end ; end ; end ;
8656: PPOPN 3
8658: END
// every 0 0$1 trigger UnitFilter ( usPatrol , [ f_see , 2 ] ) do
8659: LD_EXP 14
8663: PPUSH
8664: LD_INT 101
8666: PUSH
8667: LD_INT 2
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PPUSH
8674: CALL_OW 72
8678: IFFALSE 8811
8680: GO 8682
8682: DISABLE
// begin if not trap then
8683: LD_EXP 15
8687: NOT
8688: IFFALSE 8716
// begin Say ( Heike , DH-2-trap ) ;
8690: LD_EXP 21
8694: PPUSH
8695: LD_STRING DH-2-trap
8697: PPUSH
8698: CALL_OW 88
// Say ( Mike , DM-2-trap ) ;
8702: LD_EXP 23
8706: PPUSH
8707: LD_STRING DM-2-trap
8709: PPUSH
8710: CALL_OW 88
// end else
8714: GO 8728
// begin Say ( Heike , DH-1-trap-a ) ;
8716: LD_EXP 21
8720: PPUSH
8721: LD_STRING DH-1-trap-a
8723: PPUSH
8724: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
8728: LD_INT 35
8730: PPUSH
8731: CALL_OW 67
// until trickyMove ;
8735: LD_EXP 13
8739: IFFALSE 8728
// Say ( Heike , DH-3-trap ) ;
8741: LD_EXP 21
8745: PPUSH
8746: LD_STRING DH-3-trap
8748: PPUSH
8749: CALL_OW 88
// if IsOk ( Givi ) and IsOk ( Kaia ) then
8753: LD_EXP 22
8757: PPUSH
8758: CALL_OW 302
8762: PUSH
8763: LD_EXP 26
8767: PPUSH
8768: CALL_OW 302
8772: AND
8773: IFFALSE 8811
// begin Say ( Givi , DG-3-trap ) ;
8775: LD_EXP 22
8779: PPUSH
8780: LD_STRING DG-3-trap
8782: PPUSH
8783: CALL_OW 88
// Say ( Kaia , DK-3-trap ) ;
8787: LD_EXP 26
8791: PPUSH
8792: LD_STRING DK-3-trap
8794: PPUSH
8795: CALL_OW 88
// Say ( Givi , DG-4-trap ) ;
8799: LD_EXP 22
8803: PPUSH
8804: LD_STRING DG-4-trap
8806: PPUSH
8807: CALL_OW 88
// end ; end ;
8811: END
// every 0 0$1 trigger GetSide ( Delta ) = 2 do
8812: LD_INT 1
8814: PPUSH
8815: CALL_OW 255
8819: PUSH
8820: LD_INT 2
8822: EQUAL
8823: IFFALSE 8866
8825: GO 8827
8827: DISABLE
// begin if not IsOk ( Kaia ) then
8828: LD_EXP 26
8832: PPUSH
8833: CALL_OW 302
8837: NOT
8838: IFFALSE 8842
// exit ;
8840: GO 8866
// Say ( Kaia , DK-1-capture ) ;
8842: LD_EXP 26
8846: PPUSH
8847: LD_STRING DK-1-capture
8849: PPUSH
8850: CALL_OW 88
// Say ( Heike , DH-1-capture ) ;
8854: LD_EXP 21
8858: PPUSH
8859: LD_STRING DH-1-capture
8861: PPUSH
8862: CALL_OW 88
// end ;
8866: END
// every 0 0$1 trigger GetSide ( usLab ) = 2 do
8867: LD_INT 3
8869: PPUSH
8870: CALL_OW 255
8874: PUSH
8875: LD_INT 2
8877: EQUAL
8878: IFFALSE 8910
8880: GO 8882
8882: DISABLE
// begin DialogueOn ;
8883: CALL_OW 6
// Say ( Aviradze , DA-1-capture ) ;
8887: LD_EXP 25
8891: PPUSH
8892: LD_STRING DA-1-capture
8894: PPUSH
8895: CALL_OW 88
// DialogueOff ;
8899: CALL_OW 7
// ChangeMissionObjectives ( OTame ) ;
8903: LD_STRING OTame
8905: PPUSH
8906: CALL_OW 337
// end ;
8910: END
// every 0 0$1 trigger GetTech ( tech_ApeLang , 2 ) = state_researched do
8911: LD_INT 1
8913: PPUSH
8914: LD_INT 2
8916: PPUSH
8917: CALL_OW 321
8921: PUSH
8922: LD_INT 2
8924: EQUAL
8925: IFFALSE 8998
8927: GO 8929
8929: DISABLE
// begin DialogueOn ;
8930: CALL_OW 6
// Say ( Aviradze , DA-1-ape ) ;
8934: LD_EXP 25
8938: PPUSH
8939: LD_STRING DA-1-ape
8941: PPUSH
8942: CALL_OW 88
// Say ( Heike , DH-1-ape ) ;
8946: LD_EXP 21
8950: PPUSH
8951: LD_STRING DH-1-ape
8953: PPUSH
8954: CALL_OW 88
// Say ( Aviradze , DA-2-ape ) ;
8958: LD_EXP 25
8962: PPUSH
8963: LD_STRING DA-2-ape
8965: PPUSH
8966: CALL_OW 88
// Say ( Aviradze , DA-3-ape ) ;
8970: LD_EXP 25
8974: PPUSH
8975: LD_STRING DA-3-ape
8977: PPUSH
8978: CALL_OW 88
// Say ( Heike , DH-3-ape ) ;
8982: LD_EXP 21
8986: PPUSH
8987: LD_STRING DH-3-ape
8989: PPUSH
8990: CALL_OW 88
// DialogueOff ;
8994: CALL_OW 7
// end ;
8998: END
// every 0 0$5 trigger lostCounter >= [ 3 , 2 , 2 ] [ Difficulty ] do
8999: LD_EXP 16
9003: PUSH
9004: LD_INT 3
9006: PUSH
9007: LD_INT 2
9009: PUSH
9010: LD_INT 2
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: LIST
9017: PUSH
9018: LD_OWVAR 67
9022: ARRAY
9023: GREATEREQUAL
9024: IFFALSE 9068
9026: GO 9028
9028: DISABLE
// begin DialogueOn ;
9029: CALL_OW 6
// Say ( Aviradze , DA-1-failure ) ;
9033: LD_EXP 25
9037: PPUSH
9038: LD_STRING DA-1-failure
9040: PPUSH
9041: CALL_OW 88
// Say ( Aviradze , DA-2-failure ) ;
9045: LD_EXP 25
9049: PPUSH
9050: LD_STRING DA-2-failure
9052: PPUSH
9053: CALL_OW 88
// YouLost ( Failure ) ;
9057: LD_STRING Failure
9059: PPUSH
9060: CALL_OW 104
// DialogueOff ;
9064: CALL_OW 7
// end ;
9068: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) do var tmp ;
9069: LD_INT 22
9071: PUSH
9072: LD_INT 2
9074: PUSH
9075: EMPTY
9076: LIST
9077: LIST
9078: PUSH
9079: LD_INT 23
9081: PUSH
9082: LD_INT 0
9084: PUSH
9085: EMPTY
9086: LIST
9087: LIST
9088: PUSH
9089: EMPTY
9090: LIST
9091: LIST
9092: PPUSH
9093: CALL_OW 69
9097: IFFALSE 9847
9099: GO 9101
9101: DISABLE
9102: LD_INT 0
9104: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) [ 1 ] ;
9105: LD_ADDR_VAR 0 1
9109: PUSH
9110: LD_INT 22
9112: PUSH
9113: LD_INT 2
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 23
9122: PUSH
9123: LD_INT 0
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PPUSH
9134: CALL_OW 69
9138: PUSH
9139: LD_INT 1
9141: ARRAY
9142: ST_TO_ADDR
// InGameOn ;
9143: CALL_OW 8
// CenterNowOnUnits ( tmp ) ;
9147: LD_VAR 0 1
9151: PPUSH
9152: CALL_OW 87
// ComMoveUnit ( tmp , Aviradze ) ;
9156: LD_VAR 0 1
9160: PPUSH
9161: LD_EXP 25
9165: PPUSH
9166: CALL_OW 112
// ComTurnUnit ( Aviradze , tmp ) ;
9170: LD_EXP 25
9174: PPUSH
9175: LD_VAR 0 1
9179: PPUSH
9180: CALL_OW 119
// wait ( 0 0$1 ) ;
9184: LD_INT 35
9186: PPUSH
9187: CALL_OW 67
// Say ( Aviradze , DA-1-tame-a ) ;
9191: LD_EXP 25
9195: PPUSH
9196: LD_STRING DA-1-tame-a
9198: PPUSH
9199: CALL_OW 88
// if IsOk ( Mike ) then
9203: LD_EXP 23
9207: PPUSH
9208: CALL_OW 302
9212: IFFALSE 9250
// begin Say ( Mike , DM-1-tame-a ) ;
9214: LD_EXP 23
9218: PPUSH
9219: LD_STRING DM-1-tame-a
9221: PPUSH
9222: CALL_OW 88
// Say ( Sophia , DS-1-tame-a ) ;
9226: LD_EXP 27
9230: PPUSH
9231: LD_STRING DS-1-tame-a
9233: PPUSH
9234: CALL_OW 88
// Say ( Mike , DM-2-tame-a ) ;
9238: LD_EXP 23
9242: PPUSH
9243: LD_STRING DM-2-tame-a
9245: PPUSH
9246: CALL_OW 88
// end ; wait ( 0 0$3 ) ;
9250: LD_INT 105
9252: PPUSH
9253: CALL_OW 67
// PrepareFarmer ;
9257: CALL 10506 0 0
// CenterOnUnits ( Farmer ) ;
9261: LD_EXP 29
9265: PPUSH
9266: CALL_OW 85
// ComMoveXY ( Farmer , 105 , 59 ) ;
9270: LD_EXP 29
9274: PPUSH
9275: LD_INT 105
9277: PPUSH
9278: LD_INT 59
9280: PPUSH
9281: CALL_OW 111
// AddComHold ( Farmer ) ;
9285: LD_EXP 29
9289: PPUSH
9290: CALL_OW 200
// SayRadio ( Farmer , DF-1-end ) ;
9294: LD_EXP 29
9298: PPUSH
9299: LD_STRING DF-1-end
9301: PPUSH
9302: CALL_OW 94
// Say ( Aviradze , DA-1-end ) ;
9306: LD_EXP 25
9310: PPUSH
9311: LD_STRING DA-1-end
9313: PPUSH
9314: CALL_OW 88
// SayRadio ( Farmer , DF-2-end ) ;
9318: LD_EXP 29
9322: PPUSH
9323: LD_STRING DF-2-end
9325: PPUSH
9326: CALL_OW 94
// Say ( Aviradze , DA-2-end ) ;
9330: LD_EXP 25
9334: PPUSH
9335: LD_STRING DA-2-end
9337: PPUSH
9338: CALL_OW 88
// SayRadio ( Farmer , DF-3-end ) ;
9342: LD_EXP 29
9346: PPUSH
9347: LD_STRING DF-3-end
9349: PPUSH
9350: CALL_OW 94
// Say ( Heike , DH-3-end ) ;
9354: LD_EXP 21
9358: PPUSH
9359: LD_STRING DH-3-end
9361: PPUSH
9362: CALL_OW 88
// SayRadio ( Farmer , DF-4-end ) ;
9366: LD_EXP 29
9370: PPUSH
9371: LD_STRING DF-4-end
9373: PPUSH
9374: CALL_OW 94
// if tick <= [ 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] then
9378: LD_OWVAR 1
9382: PUSH
9383: LD_INT 42000
9385: PUSH
9386: LD_INT 31500
9388: PUSH
9389: LD_INT 21000
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: LIST
9396: PUSH
9397: LD_OWVAR 67
9401: ARRAY
9402: LESSEQUAL
9403: IFFALSE 9417
// AddMedal ( med1 , 1 ) else
9405: LD_STRING med1
9407: PPUSH
9408: LD_INT 1
9410: PPUSH
9411: CALL_OW 101
9415: GO 9428
// AddMedal ( med1 , - 1 ) ;
9417: LD_STRING med1
9419: PPUSH
9420: LD_INT 1
9422: NEG
9423: PPUSH
9424: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) = 0 then
9428: LD_INT 22
9430: PUSH
9431: LD_INT 1
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: PUSH
9438: LD_INT 25
9440: PUSH
9441: LD_INT 4
9443: PUSH
9444: EMPTY
9445: LIST
9446: LIST
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PPUSH
9452: CALL_OW 69
9456: PUSH
9457: LD_INT 0
9459: EQUAL
9460: IFFALSE 9474
// AddMedal ( med2 , 1 ) else
9462: LD_STRING med2
9464: PPUSH
9465: LD_INT 1
9467: PPUSH
9468: CALL_OW 101
9472: GO 9485
// AddMedal ( med2 , - 1 ) ;
9474: LD_STRING med2
9476: PPUSH
9477: LD_INT 1
9479: NEG
9480: PPUSH
9481: CALL_OW 101
// if trickyMove then
9485: LD_EXP 13
9489: IFFALSE 9503
// AddMedal ( med3 , 1 ) else
9491: LD_STRING med3
9493: PPUSH
9494: LD_INT 1
9496: PPUSH
9497: CALL_OW 101
9501: GO 9514
// AddMedal ( med3 , - 1 ) ;
9503: LD_STRING med3
9505: PPUSH
9506: LD_INT 1
9508: NEG
9509: PPUSH
9510: CALL_OW 101
// GiveMedals ( MAIN ) ;
9514: LD_STRING MAIN
9516: PPUSH
9517: CALL_OW 102
// SaveCharacters ( tmp , 02_ape ) ;
9521: LD_VAR 0 1
9525: PPUSH
9526: LD_STRING 02_ape
9528: PPUSH
9529: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ;
9533: LD_ADDR_VAR 0 1
9537: PUSH
9538: LD_INT 22
9540: PUSH
9541: LD_INT 2
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: PUSH
9548: LD_INT 23
9550: PUSH
9551: LD_INT 2
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 21
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: PUSH
9568: EMPTY
9569: LIST
9570: LIST
9571: LIST
9572: PPUSH
9573: CALL_OW 69
9577: ST_TO_ADDR
// RewardPeople ( tmp ) ;
9578: LD_VAR 0 1
9582: PPUSH
9583: CALL_OW 43
// SaveCharacters ( Heike , 02_Heike ) ;
9587: LD_EXP 21
9591: PPUSH
9592: LD_STRING 02_Heike
9594: PPUSH
9595: CALL_OW 38
// SaveCharacters ( Aviradze , 02_Aviradze ) ;
9599: LD_EXP 25
9603: PPUSH
9604: LD_STRING 02_Aviradze
9606: PPUSH
9607: CALL_OW 38
// if Givi then
9611: LD_EXP 22
9615: IFFALSE 9629
// SaveCharacters ( Givi , 02_Givi ) ;
9617: LD_EXP 22
9621: PPUSH
9622: LD_STRING 02_Givi
9624: PPUSH
9625: CALL_OW 38
// if Mike then
9629: LD_EXP 23
9633: IFFALSE 9647
// SaveCharacters ( Mike , 02_Mike ) ;
9635: LD_EXP 23
9639: PPUSH
9640: LD_STRING 02_Mike
9642: PPUSH
9643: CALL_OW 38
// if Kamil then
9647: LD_EXP 24
9651: IFFALSE 9665
// SaveCharacters ( Kamil , 02_Kamil ) ;
9653: LD_EXP 24
9657: PPUSH
9658: LD_STRING 02_Kamil
9660: PPUSH
9661: CALL_OW 38
// if Kaia then
9665: LD_EXP 26
9669: IFFALSE 9683
// SaveCharacters ( Kaia , 02_Kaia ) ;
9671: LD_EXP 26
9675: PPUSH
9676: LD_STRING 02_Kaia
9678: PPUSH
9679: CALL_OW 38
// if Sophia then
9683: LD_EXP 27
9687: IFFALSE 9701
// SaveCharacters ( Sophia , 02_Sophia ) ;
9689: LD_EXP 27
9693: PPUSH
9694: LD_STRING 02_Sophia
9696: PPUSH
9697: CALL_OW 38
// if Markov then
9701: LD_EXP 28
9705: IFFALSE 9719
// SaveCharacters ( Markov , 02_Markov ) ;
9707: LD_EXP 28
9711: PPUSH
9712: LD_STRING 02_Markov
9714: PPUSH
9715: CALL_OW 38
// if tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] then
9719: LD_VAR 0 1
9723: PUSH
9724: LD_EXP 21
9728: PUSH
9729: LD_EXP 25
9733: PUSH
9734: LD_EXP 22
9738: PUSH
9739: LD_EXP 23
9743: PUSH
9744: LD_EXP 24
9748: PUSH
9749: LD_EXP 27
9753: PUSH
9754: LD_EXP 26
9758: PUSH
9759: LD_EXP 28
9763: PUSH
9764: EMPTY
9765: LIST
9766: LIST
9767: LIST
9768: LIST
9769: LIST
9770: LIST
9771: LIST
9772: LIST
9773: DIFF
9774: IFFALSE 9839
// SaveCharacters ( tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] , 02_others ) ;
9776: LD_VAR 0 1
9780: PUSH
9781: LD_EXP 21
9785: PUSH
9786: LD_EXP 25
9790: PUSH
9791: LD_EXP 22
9795: PUSH
9796: LD_EXP 23
9800: PUSH
9801: LD_EXP 24
9805: PUSH
9806: LD_EXP 27
9810: PUSH
9811: LD_EXP 26
9815: PUSH
9816: LD_EXP 28
9820: PUSH
9821: EMPTY
9822: LIST
9823: LIST
9824: LIST
9825: LIST
9826: LIST
9827: LIST
9828: LIST
9829: LIST
9830: DIFF
9831: PPUSH
9832: LD_STRING 02_others
9834: PPUSH
9835: CALL_OW 38
// YouWin ;
9839: CALL_OW 103
// InGameOff ;
9843: CALL_OW 9
// end ;
9847: PPOPN 1
9849: END
// every 0 0$1 trigger tick > timeUntilFarmer and aviradzeSpotted do
9850: LD_OWVAR 1
9854: PUSH
9855: LD_EXP 11
9859: GREATER
9860: PUSH
9861: LD_EXP 4
9865: AND
9866: IFFALSE 9906
9868: GO 9870
9870: DISABLE
// begin InGameOn ;
9871: CALL_OW 8
// PrepareFarmer ;
9875: CALL 10506 0 0
// CenterNowOnUnits ( Farmer ) ;
9879: LD_EXP 29
9883: PPUSH
9884: CALL_OW 87
// wait ( 0 0$2 ) ;
9888: LD_INT 70
9890: PPUSH
9891: CALL_OW 67
// YouLost ( Farmer ) ;
9895: LD_STRING Farmer
9897: PPUSH
9898: CALL_OW 104
// InGameOff ;
9902: CALL_OW 9
// end ; end_of_file
9906: END
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer ; export function PrepareArabian ; var un , veh ; begin
9907: LD_INT 0
9909: PPUSH
9910: PPUSH
9911: PPUSH
// uc_side := 2 ;
9912: LD_ADDR_OWVAR 20
9916: PUSH
9917: LD_INT 2
9919: ST_TO_ADDR
// uc_nation := 2 ;
9920: LD_ADDR_OWVAR 21
9924: PUSH
9925: LD_INT 2
9927: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
9928: LD_ADDR_EXP 21
9932: PUSH
9933: LD_STRING Heike
9935: PPUSH
9936: LD_EXP 1
9940: NOT
9941: PPUSH
9942: LD_EXP 2
9946: PPUSH
9947: CALL 221 0 3
9951: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
9952: LD_EXP 21
9956: PPUSH
9957: LD_INT 83
9959: PPUSH
9960: LD_INT 72
9962: PPUSH
9963: LD_INT 0
9965: PPUSH
9966: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
9970: LD_ADDR_EXP 22
9974: PUSH
9975: LD_STRING Givi
9977: PPUSH
9978: LD_EXP 1
9982: NOT
9983: PPUSH
9984: LD_EXP 2
9988: PPUSH
9989: CALL 221 0 3
9993: ST_TO_ADDR
// if Givi then
9994: LD_EXP 22
9998: IFFALSE 10018
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
10000: LD_EXP 22
10004: PPUSH
10005: LD_INT 87
10007: PPUSH
10008: LD_INT 76
10010: PPUSH
10011: LD_INT 0
10013: PPUSH
10014: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
10018: LD_ADDR_EXP 23
10022: PUSH
10023: LD_STRING Mike
10025: PPUSH
10026: LD_EXP 1
10030: NOT
10031: PPUSH
10032: LD_EXP 2
10036: PPUSH
10037: CALL 221 0 3
10041: ST_TO_ADDR
// if Mike then
10042: LD_EXP 23
10046: IFFALSE 10066
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
10048: LD_EXP 23
10052: PPUSH
10053: LD_INT 84
10055: PPUSH
10056: LD_INT 76
10058: PPUSH
10059: LD_INT 0
10061: PPUSH
10062: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
10066: LD_ADDR_EXP 24
10070: PUSH
10071: LD_STRING Kamil
10073: PPUSH
10074: LD_EXP 1
10078: NOT
10079: PPUSH
10080: LD_EXP 2
10084: PPUSH
10085: CALL 221 0 3
10089: ST_TO_ADDR
// if Kamil then
10090: LD_EXP 24
10094: IFFALSE 10114
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
10096: LD_EXP 24
10100: PPUSH
10101: LD_INT 85
10103: PPUSH
10104: LD_INT 78
10106: PPUSH
10107: LD_INT 0
10109: PPUSH
10110: CALL_OW 48
// uc_side := 5 ;
10114: LD_ADDR_OWVAR 20
10118: PUSH
10119: LD_INT 5
10121: ST_TO_ADDR
// uc_nation := 2 ;
10122: LD_ADDR_OWVAR 21
10126: PUSH
10127: LD_INT 2
10129: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , false ,  ) ;
10130: LD_ADDR_EXP 25
10134: PUSH
10135: LD_STRING Aviradze
10137: PPUSH
10138: LD_INT 0
10140: PPUSH
10141: LD_STRING 
10143: PPUSH
10144: CALL 221 0 3
10148: ST_TO_ADDR
// PlaceUnitXY ( Aviradze , 106 , 38 , false ) ;
10149: LD_EXP 25
10153: PPUSH
10154: LD_INT 106
10156: PPUSH
10157: LD_INT 38
10159: PPUSH
10160: LD_INT 0
10162: PPUSH
10163: CALL_OW 48
// ComTurnXY ( Aviradze , 103 , 38 ) ;
10167: LD_EXP 25
10171: PPUSH
10172: LD_INT 103
10174: PPUSH
10175: LD_INT 38
10177: PPUSH
10178: CALL_OW 118
// Kaia := PrepareUnit ( Kaia , false ,  ) ;
10182: LD_ADDR_EXP 26
10186: PUSH
10187: LD_STRING Kaia
10189: PPUSH
10190: LD_INT 0
10192: PPUSH
10193: LD_STRING 
10195: PPUSH
10196: CALL 221 0 3
10200: ST_TO_ADDR
// PlaceUnitXY ( Kaia , 100 , 34 , false ) ;
10201: LD_EXP 26
10205: PPUSH
10206: LD_INT 100
10208: PPUSH
10209: LD_INT 34
10211: PPUSH
10212: LD_INT 0
10214: PPUSH
10215: CALL_OW 48
// ComTurnXY ( Kaia , 100 , 39 ) ;
10219: LD_EXP 26
10223: PPUSH
10224: LD_INT 100
10226: PPUSH
10227: LD_INT 39
10229: PPUSH
10230: CALL_OW 118
// Sophia := PrepareUnit ( Sophia , false ,  ) ;
10234: LD_ADDR_EXP 27
10238: PUSH
10239: LD_STRING Sophia
10241: PPUSH
10242: LD_INT 0
10244: PPUSH
10245: LD_STRING 
10247: PPUSH
10248: CALL 221 0 3
10252: ST_TO_ADDR
// PlaceUnitXY ( Sophia , 109 , 50 , false ) ;
10253: LD_EXP 27
10257: PPUSH
10258: LD_INT 109
10260: PPUSH
10261: LD_INT 50
10263: PPUSH
10264: LD_INT 0
10266: PPUSH
10267: CALL_OW 48
// ComTurnXY ( Sophia , 100 , 39 ) ;
10271: LD_EXP 27
10275: PPUSH
10276: LD_INT 100
10278: PPUSH
10279: LD_INT 39
10281: PPUSH
10282: CALL_OW 118
// Markov := PrepareUnit ( Markov , false ,  ) ;
10286: LD_ADDR_EXP 28
10290: PUSH
10291: LD_STRING Markov
10293: PPUSH
10294: LD_INT 0
10296: PPUSH
10297: LD_STRING 
10299: PPUSH
10300: CALL 221 0 3
10304: ST_TO_ADDR
// PrepareTank ( 5 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , [ 90 , 70 , 60 ] [ Difficulty ] ) ;
10305: LD_INT 5
10307: PPUSH
10308: LD_INT 3
10310: PPUSH
10311: LD_INT 21
10313: PPUSH
10314: LD_INT 1
10316: PPUSH
10317: LD_INT 1
10319: PPUSH
10320: LD_INT 42
10322: PPUSH
10323: LD_INT 90
10325: PUSH
10326: LD_INT 70
10328: PUSH
10329: LD_INT 60
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: LD_OWVAR 67
10341: ARRAY
10342: PPUSH
10343: CALL 284 0 7
// veh := CreateVehicle ;
10347: LD_ADDR_VAR 0 3
10351: PUSH
10352: CALL_OW 45
10356: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10357: LD_VAR 0 3
10361: PPUSH
10362: LD_INT 4
10364: PPUSH
10365: CALL_OW 233
// PlaceUnitXY ( veh , 109 , 38 , false ) ;
10369: LD_VAR 0 3
10373: PPUSH
10374: LD_INT 109
10376: PPUSH
10377: LD_INT 38
10379: PPUSH
10380: LD_INT 0
10382: PPUSH
10383: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
10387: LD_EXP 28
10391: PPUSH
10392: LD_VAR 0 3
10396: PPUSH
10397: CALL_OW 52
// ComTurnUnit ( Kaia , Aviradze ) ;
10401: LD_EXP 26
10405: PPUSH
10406: LD_EXP 25
10410: PPUSH
10411: CALL_OW 119
// ComTurnUnit ( Aviradze , Kaia ) ;
10415: LD_EXP 25
10419: PPUSH
10420: LD_EXP 26
10424: PPUSH
10425: CALL_OW 119
// if not Givi or not Mike then
10429: LD_EXP 22
10433: NOT
10434: PUSH
10435: LD_EXP 23
10439: NOT
10440: OR
10441: IFFALSE 10501
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10443: LD_INT 1
10445: PPUSH
10446: LD_INT 1
10448: PPUSH
10449: LD_INT 1
10451: PPUSH
10452: CALL_OW 380
// un := CreateHuman ;
10456: LD_ADDR_VAR 0 2
10460: PUSH
10461: CALL_OW 44
10465: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 40 , 3 , false ) ;
10466: LD_VAR 0 2
10470: PPUSH
10471: LD_INT 112
10473: PPUSH
10474: LD_INT 40
10476: PPUSH
10477: LD_INT 3
10479: PPUSH
10480: LD_INT 0
10482: PPUSH
10483: CALL_OW 50
// ComTurnUnit ( un , Aviradze ) ;
10487: LD_VAR 0 2
10491: PPUSH
10492: LD_EXP 25
10496: PPUSH
10497: CALL_OW 119
// end ; end ;
10501: LD_VAR 0 1
10505: RET
// export function PrepareFarmer ; var i ; begin
10506: LD_INT 0
10508: PPUSH
10509: PPUSH
// uc_side := 5 ;
10510: LD_ADDR_OWVAR 20
10514: PUSH
10515: LD_INT 5
10517: ST_TO_ADDR
// uc_nation := 2 ;
10518: LD_ADDR_OWVAR 21
10522: PUSH
10523: LD_INT 2
10525: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
10526: LD_ADDR_EXP 29
10530: PUSH
10531: LD_STRING Farmer
10533: PPUSH
10534: LD_INT 0
10536: PPUSH
10537: LD_STRING 
10539: PPUSH
10540: CALL 221 0 3
10544: ST_TO_ADDR
// PlaceUnitXY ( Farmer , 106 , 62 , false ) ;
10545: LD_EXP 29
10549: PPUSH
10550: LD_INT 106
10552: PPUSH
10553: LD_INT 62
10555: PPUSH
10556: LD_INT 0
10558: PPUSH
10559: CALL_OW 48
// for i := 1 to 2 do
10563: LD_ADDR_VAR 0 2
10567: PUSH
10568: DOUBLE
10569: LD_INT 1
10571: DEC
10572: ST_TO_ADDR
10573: LD_INT 2
10575: PUSH
10576: FOR_TO
10577: IFFALSE 10615
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10579: LD_INT 1
10581: PPUSH
10582: LD_INT 1
10584: PPUSH
10585: LD_INT 1
10587: PPUSH
10588: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 105 , 64 , 2 , false ) ;
10592: CALL_OW 44
10596: PPUSH
10597: LD_INT 105
10599: PPUSH
10600: LD_INT 64
10602: PPUSH
10603: LD_INT 2
10605: PPUSH
10606: LD_INT 0
10608: PPUSH
10609: CALL_OW 50
// end ;
10613: GO 10576
10615: POP
10616: POP
// end ; end_of_file
10617: LD_VAR 0 1
10621: RET
// every 2 2$20 + 0 0$10 do
10622: GO 10624
10624: DISABLE
// begin enable ;
10625: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , forest , true ) ;
10626: LD_INT 1
10628: PPUSH
10629: LD_INT 5
10631: PPUSH
10632: CALL_OW 12
10636: PPUSH
10637: LD_INT 1
10639: PPUSH
10640: LD_INT 1
10642: PPUSH
10643: CALL_OW 55
// end ; end_of_file
10647: END
// on UnitDestroyed ( un ) do begin if un = Heike then
10648: LD_VAR 0 1
10652: PUSH
10653: LD_EXP 21
10657: EQUAL
10658: IFFALSE 10667
// YouLost ( Heike ) ;
10660: LD_STRING Heike
10662: PPUSH
10663: CALL_OW 104
// if un = Aviradze then
10667: LD_VAR 0 1
10671: PUSH
10672: LD_EXP 25
10676: EQUAL
10677: IFFALSE 10686
// YouLost ( Aviradze ) ;
10679: LD_STRING Aviradze
10681: PPUSH
10682: CALL_OW 104
// if un = usLab then
10686: LD_VAR 0 1
10690: PUSH
10691: LD_INT 3
10693: EQUAL
10694: IFFALSE 10703
// YouLost ( Lab ) ;
10696: LD_STRING Lab
10698: PPUSH
10699: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) diff [ Heike , Aviradze ] and aviradzeSpotted then
10703: LD_VAR 0 1
10707: PUSH
10708: LD_INT 22
10710: PUSH
10711: LD_INT 2
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PUSH
10718: LD_INT 21
10720: PUSH
10721: LD_INT 1
10723: PUSH
10724: EMPTY
10725: LIST
10726: LIST
10727: PUSH
10728: LD_INT 23
10730: PUSH
10731: LD_INT 2
10733: PUSH
10734: EMPTY
10735: LIST
10736: LIST
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: LIST
10742: PPUSH
10743: CALL_OW 69
10747: PUSH
10748: LD_EXP 21
10752: PUSH
10753: LD_EXP 25
10757: PUSH
10758: EMPTY
10759: LIST
10760: LIST
10761: DIFF
10762: IN
10763: PUSH
10764: LD_EXP 4
10768: AND
10769: IFFALSE 10785
// lostCounter := lostCounter + 1 ;
10771: LD_ADDR_EXP 16
10775: PUSH
10776: LD_EXP 16
10780: PUSH
10781: LD_INT 1
10783: PLUS
10784: ST_TO_ADDR
// end ;
10785: PPOPN 1
10787: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un in usSci and killerSide = 2 then
10788: LD_VAR 0 1
10792: PUSH
10793: LD_EXP 20
10797: IN
10798: PUSH
10799: LD_VAR 0 2
10803: PUSH
10804: LD_INT 2
10806: EQUAL
10807: AND
10808: IFFALSE 10824
// sciCounterKill := sciCounterKill + 1 ;
10810: LD_ADDR_EXP 8
10814: PUSH
10815: LD_EXP 8
10819: PUSH
10820: LD_INT 1
10822: PLUS
10823: ST_TO_ADDR
// end ;
10824: PPOPN 3
10826: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
10827: LD_VAR 0 1
10831: PUSH
10832: LD_INT 2
10834: EQUAL
10835: PUSH
10836: LD_VAR 0 2
10840: PUSH
10841: LD_INT 5
10843: EQUAL
10844: AND
10845: IFFALSE 10854
// YouLost ( FriendlyFire ) ;
10847: LD_STRING FriendlyFire
10849: PPUSH
10850: CALL_OW 104
// end ; end_of_file
10854: PPOPN 2
10856: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
10857: GO 10859
10859: DISABLE
// begin ru_radar := 98 ;
10860: LD_ADDR_EXP 30
10864: PUSH
10865: LD_INT 98
10867: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10868: LD_ADDR_EXP 31
10872: PUSH
10873: LD_INT 89
10875: ST_TO_ADDR
// us_hack := 99 ;
10876: LD_ADDR_EXP 32
10880: PUSH
10881: LD_INT 99
10883: ST_TO_ADDR
// us_artillery := 97 ;
10884: LD_ADDR_EXP 33
10888: PUSH
10889: LD_INT 97
10891: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10892: LD_ADDR_EXP 34
10896: PUSH
10897: LD_INT 91
10899: ST_TO_ADDR
// tech_Artillery := 80 ;
10900: LD_ADDR_EXP 35
10904: PUSH
10905: LD_INT 80
10907: ST_TO_ADDR
// tech_RadMat := 81 ;
10908: LD_ADDR_EXP 36
10912: PUSH
10913: LD_INT 81
10915: ST_TO_ADDR
// tech_BasicTools := 82 ;
10916: LD_ADDR_EXP 37
10920: PUSH
10921: LD_INT 82
10923: ST_TO_ADDR
// tech_Cargo := 83 ;
10924: LD_ADDR_EXP 38
10928: PUSH
10929: LD_INT 83
10931: ST_TO_ADDR
// tech_Track := 84 ;
10932: LD_ADDR_EXP 39
10936: PUSH
10937: LD_INT 84
10939: ST_TO_ADDR
// tech_Crane := 85 ;
10940: LD_ADDR_EXP 40
10944: PUSH
10945: LD_INT 85
10947: ST_TO_ADDR
// tech_Bulldozer := 86 ;
10948: LD_ADDR_EXP 41
10952: PUSH
10953: LD_INT 86
10955: ST_TO_ADDR
// tech_Hovercraft := 87 ;
10956: LD_ADDR_EXP 42
10960: PUSH
10961: LD_INT 87
10963: ST_TO_ADDR
// end ; end_of_file end_of_file
10964: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
10965: GO 10967
10967: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
10968: LD_STRING initStreamRollete();
10970: PPUSH
10971: CALL_OW 559
// InitStreamMode ;
10975: CALL 10984 0 0
// DefineStreamItems ( ) ;
10979: CALL 11424 0 0
// end ;
10983: END
// function InitStreamMode ; begin
10984: LD_INT 0
10986: PPUSH
// streamModeActive := false ;
10987: LD_ADDR_EXP 43
10991: PUSH
10992: LD_INT 0
10994: ST_TO_ADDR
// normalCounter := 36 ;
10995: LD_ADDR_EXP 44
10999: PUSH
11000: LD_INT 36
11002: ST_TO_ADDR
// hardcoreCounter := 16 ;
11003: LD_ADDR_EXP 45
11007: PUSH
11008: LD_INT 16
11010: ST_TO_ADDR
// sRocket := false ;
11011: LD_ADDR_EXP 48
11015: PUSH
11016: LD_INT 0
11018: ST_TO_ADDR
// sSpeed := false ;
11019: LD_ADDR_EXP 47
11023: PUSH
11024: LD_INT 0
11026: ST_TO_ADDR
// sEngine := false ;
11027: LD_ADDR_EXP 49
11031: PUSH
11032: LD_INT 0
11034: ST_TO_ADDR
// sSpec := false ;
11035: LD_ADDR_EXP 46
11039: PUSH
11040: LD_INT 0
11042: ST_TO_ADDR
// sLevel := false ;
11043: LD_ADDR_EXP 50
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// sArmoury := false ;
11051: LD_ADDR_EXP 51
11055: PUSH
11056: LD_INT 0
11058: ST_TO_ADDR
// sRadar := false ;
11059: LD_ADDR_EXP 52
11063: PUSH
11064: LD_INT 0
11066: ST_TO_ADDR
// sBunker := false ;
11067: LD_ADDR_EXP 53
11071: PUSH
11072: LD_INT 0
11074: ST_TO_ADDR
// sHack := false ;
11075: LD_ADDR_EXP 54
11079: PUSH
11080: LD_INT 0
11082: ST_TO_ADDR
// sFire := false ;
11083: LD_ADDR_EXP 55
11087: PUSH
11088: LD_INT 0
11090: ST_TO_ADDR
// sRefresh := false ;
11091: LD_ADDR_EXP 56
11095: PUSH
11096: LD_INT 0
11098: ST_TO_ADDR
// sExp := false ;
11099: LD_ADDR_EXP 57
11103: PUSH
11104: LD_INT 0
11106: ST_TO_ADDR
// sDepot := false ;
11107: LD_ADDR_EXP 58
11111: PUSH
11112: LD_INT 0
11114: ST_TO_ADDR
// sFlag := false ;
11115: LD_ADDR_EXP 59
11119: PUSH
11120: LD_INT 0
11122: ST_TO_ADDR
// sKamikadze := false ;
11123: LD_ADDR_EXP 67
11127: PUSH
11128: LD_INT 0
11130: ST_TO_ADDR
// sTroll := false ;
11131: LD_ADDR_EXP 68
11135: PUSH
11136: LD_INT 0
11138: ST_TO_ADDR
// sSlow := false ;
11139: LD_ADDR_EXP 69
11143: PUSH
11144: LD_INT 0
11146: ST_TO_ADDR
// sLack := false ;
11147: LD_ADDR_EXP 70
11151: PUSH
11152: LD_INT 0
11154: ST_TO_ADDR
// sTank := false ;
11155: LD_ADDR_EXP 72
11159: PUSH
11160: LD_INT 0
11162: ST_TO_ADDR
// sRemote := false ;
11163: LD_ADDR_EXP 73
11167: PUSH
11168: LD_INT 0
11170: ST_TO_ADDR
// sPowell := false ;
11171: LD_ADDR_EXP 74
11175: PUSH
11176: LD_INT 0
11178: ST_TO_ADDR
// sTeleport := false ;
11179: LD_ADDR_EXP 77
11183: PUSH
11184: LD_INT 0
11186: ST_TO_ADDR
// sOilTower := false ;
11187: LD_ADDR_EXP 79
11191: PUSH
11192: LD_INT 0
11194: ST_TO_ADDR
// sShovel := false ;
11195: LD_ADDR_EXP 80
11199: PUSH
11200: LD_INT 0
11202: ST_TO_ADDR
// sSheik := false ;
11203: LD_ADDR_EXP 81
11207: PUSH
11208: LD_INT 0
11210: ST_TO_ADDR
// sEarthquake := false ;
11211: LD_ADDR_EXP 83
11215: PUSH
11216: LD_INT 0
11218: ST_TO_ADDR
// sAI := false ;
11219: LD_ADDR_EXP 84
11223: PUSH
11224: LD_INT 0
11226: ST_TO_ADDR
// sCargo := false ;
11227: LD_ADDR_EXP 87
11231: PUSH
11232: LD_INT 0
11234: ST_TO_ADDR
// sDLaser := false ;
11235: LD_ADDR_EXP 88
11239: PUSH
11240: LD_INT 0
11242: ST_TO_ADDR
// sExchange := false ;
11243: LD_ADDR_EXP 89
11247: PUSH
11248: LD_INT 0
11250: ST_TO_ADDR
// sFac := false ;
11251: LD_ADDR_EXP 90
11255: PUSH
11256: LD_INT 0
11258: ST_TO_ADDR
// sPower := false ;
11259: LD_ADDR_EXP 91
11263: PUSH
11264: LD_INT 0
11266: ST_TO_ADDR
// sRandom := false ;
11267: LD_ADDR_EXP 92
11271: PUSH
11272: LD_INT 0
11274: ST_TO_ADDR
// sShield := false ;
11275: LD_ADDR_EXP 93
11279: PUSH
11280: LD_INT 0
11282: ST_TO_ADDR
// sTime := false ;
11283: LD_ADDR_EXP 94
11287: PUSH
11288: LD_INT 0
11290: ST_TO_ADDR
// sTools := false ;
11291: LD_ADDR_EXP 95
11295: PUSH
11296: LD_INT 0
11298: ST_TO_ADDR
// sSold := false ;
11299: LD_ADDR_EXP 60
11303: PUSH
11304: LD_INT 0
11306: ST_TO_ADDR
// sDiff := false ;
11307: LD_ADDR_EXP 61
11311: PUSH
11312: LD_INT 0
11314: ST_TO_ADDR
// sFog := false ;
11315: LD_ADDR_EXP 64
11319: PUSH
11320: LD_INT 0
11322: ST_TO_ADDR
// sReset := false ;
11323: LD_ADDR_EXP 65
11327: PUSH
11328: LD_INT 0
11330: ST_TO_ADDR
// sSun := false ;
11331: LD_ADDR_EXP 66
11335: PUSH
11336: LD_INT 0
11338: ST_TO_ADDR
// sTiger := false ;
11339: LD_ADDR_EXP 62
11343: PUSH
11344: LD_INT 0
11346: ST_TO_ADDR
// sBomb := false ;
11347: LD_ADDR_EXP 63
11351: PUSH
11352: LD_INT 0
11354: ST_TO_ADDR
// sWound := false ;
11355: LD_ADDR_EXP 71
11359: PUSH
11360: LD_INT 0
11362: ST_TO_ADDR
// sBetray := false ;
11363: LD_ADDR_EXP 75
11367: PUSH
11368: LD_INT 0
11370: ST_TO_ADDR
// sContamin := false ;
11371: LD_ADDR_EXP 76
11375: PUSH
11376: LD_INT 0
11378: ST_TO_ADDR
// sOil := false ;
11379: LD_ADDR_EXP 78
11383: PUSH
11384: LD_INT 0
11386: ST_TO_ADDR
// sStu := false ;
11387: LD_ADDR_EXP 82
11391: PUSH
11392: LD_INT 0
11394: ST_TO_ADDR
// sBazooka := false ;
11395: LD_ADDR_EXP 85
11399: PUSH
11400: LD_INT 0
11402: ST_TO_ADDR
// sMortar := false ;
11403: LD_ADDR_EXP 86
11407: PUSH
11408: LD_INT 0
11410: ST_TO_ADDR
// sRanger := false ;
11411: LD_ADDR_EXP 96
11415: PUSH
11416: LD_INT 0
11418: ST_TO_ADDR
// end ;
11419: LD_VAR 0 1
11423: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11424: LD_INT 0
11426: PPUSH
11427: PPUSH
11428: PPUSH
11429: PPUSH
11430: PPUSH
// result := [ ] ;
11431: LD_ADDR_VAR 0 1
11435: PUSH
11436: EMPTY
11437: ST_TO_ADDR
// if campaign_id = 1 then
11438: LD_OWVAR 69
11442: PUSH
11443: LD_INT 1
11445: EQUAL
11446: IFFALSE 14384
// begin case mission_number of 1 :
11448: LD_OWVAR 70
11452: PUSH
11453: LD_INT 1
11455: DOUBLE
11456: EQUAL
11457: IFTRUE 11461
11459: GO 11525
11461: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11462: LD_ADDR_VAR 0 1
11466: PUSH
11467: LD_INT 2
11469: PUSH
11470: LD_INT 4
11472: PUSH
11473: LD_INT 11
11475: PUSH
11476: LD_INT 12
11478: PUSH
11479: LD_INT 15
11481: PUSH
11482: LD_INT 16
11484: PUSH
11485: LD_INT 22
11487: PUSH
11488: LD_INT 23
11490: PUSH
11491: LD_INT 26
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: PUSH
11505: LD_INT 101
11507: PUSH
11508: LD_INT 102
11510: PUSH
11511: LD_INT 106
11513: PUSH
11514: EMPTY
11515: LIST
11516: LIST
11517: LIST
11518: PUSH
11519: EMPTY
11520: LIST
11521: LIST
11522: ST_TO_ADDR
11523: GO 14382
11525: LD_INT 2
11527: DOUBLE
11528: EQUAL
11529: IFTRUE 11533
11531: GO 11605
11533: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11534: LD_ADDR_VAR 0 1
11538: PUSH
11539: LD_INT 2
11541: PUSH
11542: LD_INT 4
11544: PUSH
11545: LD_INT 11
11547: PUSH
11548: LD_INT 12
11550: PUSH
11551: LD_INT 15
11553: PUSH
11554: LD_INT 16
11556: PUSH
11557: LD_INT 22
11559: PUSH
11560: LD_INT 23
11562: PUSH
11563: LD_INT 26
11565: PUSH
11566: EMPTY
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: LIST
11572: LIST
11573: LIST
11574: LIST
11575: LIST
11576: PUSH
11577: LD_INT 101
11579: PUSH
11580: LD_INT 102
11582: PUSH
11583: LD_INT 105
11585: PUSH
11586: LD_INT 106
11588: PUSH
11589: LD_INT 108
11591: PUSH
11592: EMPTY
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: LIST
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: ST_TO_ADDR
11603: GO 14382
11605: LD_INT 3
11607: DOUBLE
11608: EQUAL
11609: IFTRUE 11613
11611: GO 11689
11613: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11614: LD_ADDR_VAR 0 1
11618: PUSH
11619: LD_INT 2
11621: PUSH
11622: LD_INT 4
11624: PUSH
11625: LD_INT 5
11627: PUSH
11628: LD_INT 11
11630: PUSH
11631: LD_INT 12
11633: PUSH
11634: LD_INT 15
11636: PUSH
11637: LD_INT 16
11639: PUSH
11640: LD_INT 22
11642: PUSH
11643: LD_INT 26
11645: PUSH
11646: LD_INT 36
11648: PUSH
11649: EMPTY
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: LIST
11657: LIST
11658: LIST
11659: LIST
11660: PUSH
11661: LD_INT 101
11663: PUSH
11664: LD_INT 102
11666: PUSH
11667: LD_INT 105
11669: PUSH
11670: LD_INT 106
11672: PUSH
11673: LD_INT 108
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: ST_TO_ADDR
11687: GO 14382
11689: LD_INT 4
11691: DOUBLE
11692: EQUAL
11693: IFTRUE 11697
11695: GO 11781
11697: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11698: LD_ADDR_VAR 0 1
11702: PUSH
11703: LD_INT 2
11705: PUSH
11706: LD_INT 4
11708: PUSH
11709: LD_INT 5
11711: PUSH
11712: LD_INT 8
11714: PUSH
11715: LD_INT 11
11717: PUSH
11718: LD_INT 12
11720: PUSH
11721: LD_INT 15
11723: PUSH
11724: LD_INT 16
11726: PUSH
11727: LD_INT 22
11729: PUSH
11730: LD_INT 23
11732: PUSH
11733: LD_INT 26
11735: PUSH
11736: LD_INT 36
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: PUSH
11753: LD_INT 101
11755: PUSH
11756: LD_INT 102
11758: PUSH
11759: LD_INT 105
11761: PUSH
11762: LD_INT 106
11764: PUSH
11765: LD_INT 108
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: EMPTY
11776: LIST
11777: LIST
11778: ST_TO_ADDR
11779: GO 14382
11781: LD_INT 5
11783: DOUBLE
11784: EQUAL
11785: IFTRUE 11789
11787: GO 11889
11789: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
11790: LD_ADDR_VAR 0 1
11794: PUSH
11795: LD_INT 2
11797: PUSH
11798: LD_INT 4
11800: PUSH
11801: LD_INT 5
11803: PUSH
11804: LD_INT 6
11806: PUSH
11807: LD_INT 8
11809: PUSH
11810: LD_INT 11
11812: PUSH
11813: LD_INT 12
11815: PUSH
11816: LD_INT 15
11818: PUSH
11819: LD_INT 16
11821: PUSH
11822: LD_INT 22
11824: PUSH
11825: LD_INT 23
11827: PUSH
11828: LD_INT 25
11830: PUSH
11831: LD_INT 26
11833: PUSH
11834: LD_INT 36
11836: PUSH
11837: EMPTY
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: PUSH
11853: LD_INT 101
11855: PUSH
11856: LD_INT 102
11858: PUSH
11859: LD_INT 105
11861: PUSH
11862: LD_INT 106
11864: PUSH
11865: LD_INT 108
11867: PUSH
11868: LD_INT 109
11870: PUSH
11871: LD_INT 112
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: ST_TO_ADDR
11887: GO 14382
11889: LD_INT 6
11891: DOUBLE
11892: EQUAL
11893: IFTRUE 11897
11895: GO 12017
11897: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
11898: LD_ADDR_VAR 0 1
11902: PUSH
11903: LD_INT 2
11905: PUSH
11906: LD_INT 4
11908: PUSH
11909: LD_INT 5
11911: PUSH
11912: LD_INT 6
11914: PUSH
11915: LD_INT 8
11917: PUSH
11918: LD_INT 11
11920: PUSH
11921: LD_INT 12
11923: PUSH
11924: LD_INT 15
11926: PUSH
11927: LD_INT 16
11929: PUSH
11930: LD_INT 20
11932: PUSH
11933: LD_INT 21
11935: PUSH
11936: LD_INT 22
11938: PUSH
11939: LD_INT 23
11941: PUSH
11942: LD_INT 25
11944: PUSH
11945: LD_INT 26
11947: PUSH
11948: LD_INT 30
11950: PUSH
11951: LD_INT 31
11953: PUSH
11954: LD_INT 32
11956: PUSH
11957: LD_INT 36
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: LIST
11974: LIST
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: PUSH
11981: LD_INT 101
11983: PUSH
11984: LD_INT 102
11986: PUSH
11987: LD_INT 105
11989: PUSH
11990: LD_INT 106
11992: PUSH
11993: LD_INT 108
11995: PUSH
11996: LD_INT 109
11998: PUSH
11999: LD_INT 112
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: ST_TO_ADDR
12015: GO 14382
12017: LD_INT 7
12019: DOUBLE
12020: EQUAL
12021: IFTRUE 12025
12023: GO 12125
12025: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12026: LD_ADDR_VAR 0 1
12030: PUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 4
12036: PUSH
12037: LD_INT 5
12039: PUSH
12040: LD_INT 7
12042: PUSH
12043: LD_INT 11
12045: PUSH
12046: LD_INT 12
12048: PUSH
12049: LD_INT 15
12051: PUSH
12052: LD_INT 16
12054: PUSH
12055: LD_INT 20
12057: PUSH
12058: LD_INT 21
12060: PUSH
12061: LD_INT 22
12063: PUSH
12064: LD_INT 23
12066: PUSH
12067: LD_INT 25
12069: PUSH
12070: LD_INT 26
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: LIST
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: PUSH
12089: LD_INT 101
12091: PUSH
12092: LD_INT 102
12094: PUSH
12095: LD_INT 103
12097: PUSH
12098: LD_INT 105
12100: PUSH
12101: LD_INT 106
12103: PUSH
12104: LD_INT 108
12106: PUSH
12107: LD_INT 112
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: LIST
12114: LIST
12115: LIST
12116: LIST
12117: LIST
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: ST_TO_ADDR
12123: GO 14382
12125: LD_INT 8
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12261
12133: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12134: LD_ADDR_VAR 0 1
12138: PUSH
12139: LD_INT 2
12141: PUSH
12142: LD_INT 4
12144: PUSH
12145: LD_INT 5
12147: PUSH
12148: LD_INT 6
12150: PUSH
12151: LD_INT 7
12153: PUSH
12154: LD_INT 8
12156: PUSH
12157: LD_INT 11
12159: PUSH
12160: LD_INT 12
12162: PUSH
12163: LD_INT 15
12165: PUSH
12166: LD_INT 16
12168: PUSH
12169: LD_INT 20
12171: PUSH
12172: LD_INT 21
12174: PUSH
12175: LD_INT 22
12177: PUSH
12178: LD_INT 23
12180: PUSH
12181: LD_INT 25
12183: PUSH
12184: LD_INT 26
12186: PUSH
12187: LD_INT 30
12189: PUSH
12190: LD_INT 31
12192: PUSH
12193: LD_INT 32
12195: PUSH
12196: LD_INT 36
12198: PUSH
12199: EMPTY
12200: LIST
12201: LIST
12202: LIST
12203: LIST
12204: LIST
12205: LIST
12206: LIST
12207: LIST
12208: LIST
12209: LIST
12210: LIST
12211: LIST
12212: LIST
12213: LIST
12214: LIST
12215: LIST
12216: LIST
12217: LIST
12218: LIST
12219: LIST
12220: PUSH
12221: LD_INT 101
12223: PUSH
12224: LD_INT 102
12226: PUSH
12227: LD_INT 103
12229: PUSH
12230: LD_INT 105
12232: PUSH
12233: LD_INT 106
12235: PUSH
12236: LD_INT 108
12238: PUSH
12239: LD_INT 109
12241: PUSH
12242: LD_INT 112
12244: PUSH
12245: EMPTY
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: PUSH
12255: EMPTY
12256: LIST
12257: LIST
12258: ST_TO_ADDR
12259: GO 14382
12261: LD_INT 9
12263: DOUBLE
12264: EQUAL
12265: IFTRUE 12269
12267: GO 12405
12269: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12270: LD_ADDR_VAR 0 1
12274: PUSH
12275: LD_INT 2
12277: PUSH
12278: LD_INT 4
12280: PUSH
12281: LD_INT 5
12283: PUSH
12284: LD_INT 6
12286: PUSH
12287: LD_INT 7
12289: PUSH
12290: LD_INT 8
12292: PUSH
12293: LD_INT 11
12295: PUSH
12296: LD_INT 12
12298: PUSH
12299: LD_INT 15
12301: PUSH
12302: LD_INT 16
12304: PUSH
12305: LD_INT 20
12307: PUSH
12308: LD_INT 21
12310: PUSH
12311: LD_INT 22
12313: PUSH
12314: LD_INT 23
12316: PUSH
12317: LD_INT 25
12319: PUSH
12320: LD_INT 26
12322: PUSH
12323: LD_INT 28
12325: PUSH
12326: LD_INT 30
12328: PUSH
12329: LD_INT 31
12331: PUSH
12332: LD_INT 32
12334: PUSH
12335: LD_INT 36
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: LIST
12342: LIST
12343: LIST
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: LIST
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: PUSH
12361: LD_INT 101
12363: PUSH
12364: LD_INT 102
12366: PUSH
12367: LD_INT 103
12369: PUSH
12370: LD_INT 105
12372: PUSH
12373: LD_INT 106
12375: PUSH
12376: LD_INT 108
12378: PUSH
12379: LD_INT 109
12381: PUSH
12382: LD_INT 112
12384: PUSH
12385: LD_INT 114
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: PUSH
12399: EMPTY
12400: LIST
12401: LIST
12402: ST_TO_ADDR
12403: GO 14382
12405: LD_INT 10
12407: DOUBLE
12408: EQUAL
12409: IFTRUE 12413
12411: GO 12597
12413: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12414: LD_ADDR_VAR 0 1
12418: PUSH
12419: LD_INT 2
12421: PUSH
12422: LD_INT 4
12424: PUSH
12425: LD_INT 5
12427: PUSH
12428: LD_INT 6
12430: PUSH
12431: LD_INT 7
12433: PUSH
12434: LD_INT 8
12436: PUSH
12437: LD_INT 9
12439: PUSH
12440: LD_INT 10
12442: PUSH
12443: LD_INT 11
12445: PUSH
12446: LD_INT 12
12448: PUSH
12449: LD_INT 13
12451: PUSH
12452: LD_INT 14
12454: PUSH
12455: LD_INT 15
12457: PUSH
12458: LD_INT 16
12460: PUSH
12461: LD_INT 17
12463: PUSH
12464: LD_INT 18
12466: PUSH
12467: LD_INT 19
12469: PUSH
12470: LD_INT 20
12472: PUSH
12473: LD_INT 21
12475: PUSH
12476: LD_INT 22
12478: PUSH
12479: LD_INT 23
12481: PUSH
12482: LD_INT 24
12484: PUSH
12485: LD_INT 25
12487: PUSH
12488: LD_INT 26
12490: PUSH
12491: LD_INT 28
12493: PUSH
12494: LD_INT 30
12496: PUSH
12497: LD_INT 31
12499: PUSH
12500: LD_INT 32
12502: PUSH
12503: LD_INT 36
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: LIST
12510: LIST
12511: LIST
12512: LIST
12513: LIST
12514: LIST
12515: LIST
12516: LIST
12517: LIST
12518: LIST
12519: LIST
12520: LIST
12521: LIST
12522: LIST
12523: LIST
12524: LIST
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: LIST
12530: LIST
12531: LIST
12532: LIST
12533: LIST
12534: LIST
12535: LIST
12536: PUSH
12537: LD_INT 101
12539: PUSH
12540: LD_INT 102
12542: PUSH
12543: LD_INT 103
12545: PUSH
12546: LD_INT 104
12548: PUSH
12549: LD_INT 105
12551: PUSH
12552: LD_INT 106
12554: PUSH
12555: LD_INT 107
12557: PUSH
12558: LD_INT 108
12560: PUSH
12561: LD_INT 109
12563: PUSH
12564: LD_INT 110
12566: PUSH
12567: LD_INT 111
12569: PUSH
12570: LD_INT 112
12572: PUSH
12573: LD_INT 114
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: LIST
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: ST_TO_ADDR
12595: GO 14382
12597: LD_INT 11
12599: DOUBLE
12600: EQUAL
12601: IFTRUE 12605
12603: GO 12797
12605: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12606: LD_ADDR_VAR 0 1
12610: PUSH
12611: LD_INT 2
12613: PUSH
12614: LD_INT 3
12616: PUSH
12617: LD_INT 4
12619: PUSH
12620: LD_INT 5
12622: PUSH
12623: LD_INT 6
12625: PUSH
12626: LD_INT 7
12628: PUSH
12629: LD_INT 8
12631: PUSH
12632: LD_INT 9
12634: PUSH
12635: LD_INT 10
12637: PUSH
12638: LD_INT 11
12640: PUSH
12641: LD_INT 12
12643: PUSH
12644: LD_INT 13
12646: PUSH
12647: LD_INT 14
12649: PUSH
12650: LD_INT 15
12652: PUSH
12653: LD_INT 16
12655: PUSH
12656: LD_INT 17
12658: PUSH
12659: LD_INT 18
12661: PUSH
12662: LD_INT 19
12664: PUSH
12665: LD_INT 20
12667: PUSH
12668: LD_INT 21
12670: PUSH
12671: LD_INT 22
12673: PUSH
12674: LD_INT 23
12676: PUSH
12677: LD_INT 24
12679: PUSH
12680: LD_INT 25
12682: PUSH
12683: LD_INT 26
12685: PUSH
12686: LD_INT 28
12688: PUSH
12689: LD_INT 30
12691: PUSH
12692: LD_INT 31
12694: PUSH
12695: LD_INT 32
12697: PUSH
12698: LD_INT 34
12700: PUSH
12701: LD_INT 36
12703: PUSH
12704: EMPTY
12705: LIST
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: LIST
12711: LIST
12712: LIST
12713: LIST
12714: LIST
12715: LIST
12716: LIST
12717: LIST
12718: LIST
12719: LIST
12720: LIST
12721: LIST
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: LIST
12729: LIST
12730: LIST
12731: LIST
12732: LIST
12733: LIST
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 101
12739: PUSH
12740: LD_INT 102
12742: PUSH
12743: LD_INT 103
12745: PUSH
12746: LD_INT 104
12748: PUSH
12749: LD_INT 105
12751: PUSH
12752: LD_INT 106
12754: PUSH
12755: LD_INT 107
12757: PUSH
12758: LD_INT 108
12760: PUSH
12761: LD_INT 109
12763: PUSH
12764: LD_INT 110
12766: PUSH
12767: LD_INT 111
12769: PUSH
12770: LD_INT 112
12772: PUSH
12773: LD_INT 114
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: LIST
12780: LIST
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: LIST
12789: LIST
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: ST_TO_ADDR
12795: GO 14382
12797: LD_INT 12
12799: DOUBLE
12800: EQUAL
12801: IFTRUE 12805
12803: GO 13013
12805: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
12806: LD_ADDR_VAR 0 1
12810: PUSH
12811: LD_INT 1
12813: PUSH
12814: LD_INT 2
12816: PUSH
12817: LD_INT 3
12819: PUSH
12820: LD_INT 4
12822: PUSH
12823: LD_INT 5
12825: PUSH
12826: LD_INT 6
12828: PUSH
12829: LD_INT 7
12831: PUSH
12832: LD_INT 8
12834: PUSH
12835: LD_INT 9
12837: PUSH
12838: LD_INT 10
12840: PUSH
12841: LD_INT 11
12843: PUSH
12844: LD_INT 12
12846: PUSH
12847: LD_INT 13
12849: PUSH
12850: LD_INT 14
12852: PUSH
12853: LD_INT 15
12855: PUSH
12856: LD_INT 16
12858: PUSH
12859: LD_INT 17
12861: PUSH
12862: LD_INT 18
12864: PUSH
12865: LD_INT 19
12867: PUSH
12868: LD_INT 20
12870: PUSH
12871: LD_INT 21
12873: PUSH
12874: LD_INT 22
12876: PUSH
12877: LD_INT 23
12879: PUSH
12880: LD_INT 24
12882: PUSH
12883: LD_INT 25
12885: PUSH
12886: LD_INT 26
12888: PUSH
12889: LD_INT 27
12891: PUSH
12892: LD_INT 28
12894: PUSH
12895: LD_INT 30
12897: PUSH
12898: LD_INT 31
12900: PUSH
12901: LD_INT 32
12903: PUSH
12904: LD_INT 33
12906: PUSH
12907: LD_INT 34
12909: PUSH
12910: LD_INT 36
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: LIST
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: LIST
12929: LIST
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: LIST
12936: LIST
12937: LIST
12938: LIST
12939: LIST
12940: LIST
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: LIST
12947: LIST
12948: PUSH
12949: LD_INT 101
12951: PUSH
12952: LD_INT 102
12954: PUSH
12955: LD_INT 103
12957: PUSH
12958: LD_INT 104
12960: PUSH
12961: LD_INT 105
12963: PUSH
12964: LD_INT 106
12966: PUSH
12967: LD_INT 107
12969: PUSH
12970: LD_INT 108
12972: PUSH
12973: LD_INT 109
12975: PUSH
12976: LD_INT 110
12978: PUSH
12979: LD_INT 111
12981: PUSH
12982: LD_INT 112
12984: PUSH
12985: LD_INT 113
12987: PUSH
12988: LD_INT 114
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: LIST
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: ST_TO_ADDR
13011: GO 14382
13013: LD_INT 13
13015: DOUBLE
13016: EQUAL
13017: IFTRUE 13021
13019: GO 13217
13021: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13022: LD_ADDR_VAR 0 1
13026: PUSH
13027: LD_INT 1
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 3
13035: PUSH
13036: LD_INT 4
13038: PUSH
13039: LD_INT 5
13041: PUSH
13042: LD_INT 8
13044: PUSH
13045: LD_INT 9
13047: PUSH
13048: LD_INT 10
13050: PUSH
13051: LD_INT 11
13053: PUSH
13054: LD_INT 12
13056: PUSH
13057: LD_INT 14
13059: PUSH
13060: LD_INT 15
13062: PUSH
13063: LD_INT 16
13065: PUSH
13066: LD_INT 17
13068: PUSH
13069: LD_INT 18
13071: PUSH
13072: LD_INT 19
13074: PUSH
13075: LD_INT 20
13077: PUSH
13078: LD_INT 21
13080: PUSH
13081: LD_INT 22
13083: PUSH
13084: LD_INT 23
13086: PUSH
13087: LD_INT 24
13089: PUSH
13090: LD_INT 25
13092: PUSH
13093: LD_INT 26
13095: PUSH
13096: LD_INT 27
13098: PUSH
13099: LD_INT 28
13101: PUSH
13102: LD_INT 30
13104: PUSH
13105: LD_INT 31
13107: PUSH
13108: LD_INT 32
13110: PUSH
13111: LD_INT 33
13113: PUSH
13114: LD_INT 34
13116: PUSH
13117: LD_INT 36
13119: PUSH
13120: EMPTY
13121: LIST
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: LIST
13152: PUSH
13153: LD_INT 101
13155: PUSH
13156: LD_INT 102
13158: PUSH
13159: LD_INT 103
13161: PUSH
13162: LD_INT 104
13164: PUSH
13165: LD_INT 105
13167: PUSH
13168: LD_INT 106
13170: PUSH
13171: LD_INT 107
13173: PUSH
13174: LD_INT 108
13176: PUSH
13177: LD_INT 109
13179: PUSH
13180: LD_INT 110
13182: PUSH
13183: LD_INT 111
13185: PUSH
13186: LD_INT 112
13188: PUSH
13189: LD_INT 113
13191: PUSH
13192: LD_INT 114
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: LIST
13208: LIST
13209: LIST
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: ST_TO_ADDR
13215: GO 14382
13217: LD_INT 14
13219: DOUBLE
13220: EQUAL
13221: IFTRUE 13225
13223: GO 13437
13225: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13226: LD_ADDR_VAR 0 1
13230: PUSH
13231: LD_INT 1
13233: PUSH
13234: LD_INT 2
13236: PUSH
13237: LD_INT 3
13239: PUSH
13240: LD_INT 4
13242: PUSH
13243: LD_INT 5
13245: PUSH
13246: LD_INT 6
13248: PUSH
13249: LD_INT 7
13251: PUSH
13252: LD_INT 8
13254: PUSH
13255: LD_INT 9
13257: PUSH
13258: LD_INT 10
13260: PUSH
13261: LD_INT 11
13263: PUSH
13264: LD_INT 12
13266: PUSH
13267: LD_INT 13
13269: PUSH
13270: LD_INT 14
13272: PUSH
13273: LD_INT 15
13275: PUSH
13276: LD_INT 16
13278: PUSH
13279: LD_INT 17
13281: PUSH
13282: LD_INT 18
13284: PUSH
13285: LD_INT 19
13287: PUSH
13288: LD_INT 20
13290: PUSH
13291: LD_INT 21
13293: PUSH
13294: LD_INT 22
13296: PUSH
13297: LD_INT 23
13299: PUSH
13300: LD_INT 24
13302: PUSH
13303: LD_INT 25
13305: PUSH
13306: LD_INT 26
13308: PUSH
13309: LD_INT 27
13311: PUSH
13312: LD_INT 28
13314: PUSH
13315: LD_INT 29
13317: PUSH
13318: LD_INT 30
13320: PUSH
13321: LD_INT 31
13323: PUSH
13324: LD_INT 32
13326: PUSH
13327: LD_INT 33
13329: PUSH
13330: LD_INT 34
13332: PUSH
13333: LD_INT 36
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: LIST
13344: LIST
13345: LIST
13346: LIST
13347: LIST
13348: LIST
13349: LIST
13350: LIST
13351: LIST
13352: LIST
13353: LIST
13354: LIST
13355: LIST
13356: LIST
13357: LIST
13358: LIST
13359: LIST
13360: LIST
13361: LIST
13362: LIST
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: PUSH
13373: LD_INT 101
13375: PUSH
13376: LD_INT 102
13378: PUSH
13379: LD_INT 103
13381: PUSH
13382: LD_INT 104
13384: PUSH
13385: LD_INT 105
13387: PUSH
13388: LD_INT 106
13390: PUSH
13391: LD_INT 107
13393: PUSH
13394: LD_INT 108
13396: PUSH
13397: LD_INT 109
13399: PUSH
13400: LD_INT 110
13402: PUSH
13403: LD_INT 111
13405: PUSH
13406: LD_INT 112
13408: PUSH
13409: LD_INT 113
13411: PUSH
13412: LD_INT 114
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: LIST
13428: LIST
13429: LIST
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: ST_TO_ADDR
13435: GO 14382
13437: LD_INT 15
13439: DOUBLE
13440: EQUAL
13441: IFTRUE 13445
13443: GO 13657
13445: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13446: LD_ADDR_VAR 0 1
13450: PUSH
13451: LD_INT 1
13453: PUSH
13454: LD_INT 2
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: LD_INT 4
13462: PUSH
13463: LD_INT 5
13465: PUSH
13466: LD_INT 6
13468: PUSH
13469: LD_INT 7
13471: PUSH
13472: LD_INT 8
13474: PUSH
13475: LD_INT 9
13477: PUSH
13478: LD_INT 10
13480: PUSH
13481: LD_INT 11
13483: PUSH
13484: LD_INT 12
13486: PUSH
13487: LD_INT 13
13489: PUSH
13490: LD_INT 14
13492: PUSH
13493: LD_INT 15
13495: PUSH
13496: LD_INT 16
13498: PUSH
13499: LD_INT 17
13501: PUSH
13502: LD_INT 18
13504: PUSH
13505: LD_INT 19
13507: PUSH
13508: LD_INT 20
13510: PUSH
13511: LD_INT 21
13513: PUSH
13514: LD_INT 22
13516: PUSH
13517: LD_INT 23
13519: PUSH
13520: LD_INT 24
13522: PUSH
13523: LD_INT 25
13525: PUSH
13526: LD_INT 26
13528: PUSH
13529: LD_INT 27
13531: PUSH
13532: LD_INT 28
13534: PUSH
13535: LD_INT 29
13537: PUSH
13538: LD_INT 30
13540: PUSH
13541: LD_INT 31
13543: PUSH
13544: LD_INT 32
13546: PUSH
13547: LD_INT 33
13549: PUSH
13550: LD_INT 34
13552: PUSH
13553: LD_INT 36
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: LIST
13560: LIST
13561: LIST
13562: LIST
13563: LIST
13564: LIST
13565: LIST
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: LIST
13571: LIST
13572: LIST
13573: LIST
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: PUSH
13593: LD_INT 101
13595: PUSH
13596: LD_INT 102
13598: PUSH
13599: LD_INT 103
13601: PUSH
13602: LD_INT 104
13604: PUSH
13605: LD_INT 105
13607: PUSH
13608: LD_INT 106
13610: PUSH
13611: LD_INT 107
13613: PUSH
13614: LD_INT 108
13616: PUSH
13617: LD_INT 109
13619: PUSH
13620: LD_INT 110
13622: PUSH
13623: LD_INT 111
13625: PUSH
13626: LD_INT 112
13628: PUSH
13629: LD_INT 113
13631: PUSH
13632: LD_INT 114
13634: PUSH
13635: EMPTY
13636: LIST
13637: LIST
13638: LIST
13639: LIST
13640: LIST
13641: LIST
13642: LIST
13643: LIST
13644: LIST
13645: LIST
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: ST_TO_ADDR
13655: GO 14382
13657: LD_INT 16
13659: DOUBLE
13660: EQUAL
13661: IFTRUE 13665
13663: GO 13789
13665: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13666: LD_ADDR_VAR 0 1
13670: PUSH
13671: LD_INT 2
13673: PUSH
13674: LD_INT 4
13676: PUSH
13677: LD_INT 5
13679: PUSH
13680: LD_INT 7
13682: PUSH
13683: LD_INT 11
13685: PUSH
13686: LD_INT 12
13688: PUSH
13689: LD_INT 15
13691: PUSH
13692: LD_INT 16
13694: PUSH
13695: LD_INT 20
13697: PUSH
13698: LD_INT 21
13700: PUSH
13701: LD_INT 22
13703: PUSH
13704: LD_INT 23
13706: PUSH
13707: LD_INT 25
13709: PUSH
13710: LD_INT 26
13712: PUSH
13713: LD_INT 30
13715: PUSH
13716: LD_INT 31
13718: PUSH
13719: LD_INT 32
13721: PUSH
13722: LD_INT 33
13724: PUSH
13725: LD_INT 34
13727: PUSH
13728: EMPTY
13729: LIST
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: LIST
13735: LIST
13736: LIST
13737: LIST
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: PUSH
13749: LD_INT 101
13751: PUSH
13752: LD_INT 102
13754: PUSH
13755: LD_INT 103
13757: PUSH
13758: LD_INT 106
13760: PUSH
13761: LD_INT 108
13763: PUSH
13764: LD_INT 112
13766: PUSH
13767: LD_INT 113
13769: PUSH
13770: LD_INT 114
13772: PUSH
13773: EMPTY
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: LIST
13779: LIST
13780: LIST
13781: LIST
13782: PUSH
13783: EMPTY
13784: LIST
13785: LIST
13786: ST_TO_ADDR
13787: GO 14382
13789: LD_INT 17
13791: DOUBLE
13792: EQUAL
13793: IFTRUE 13797
13795: GO 14009
13797: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
13798: LD_ADDR_VAR 0 1
13802: PUSH
13803: LD_INT 1
13805: PUSH
13806: LD_INT 2
13808: PUSH
13809: LD_INT 3
13811: PUSH
13812: LD_INT 4
13814: PUSH
13815: LD_INT 5
13817: PUSH
13818: LD_INT 6
13820: PUSH
13821: LD_INT 7
13823: PUSH
13824: LD_INT 8
13826: PUSH
13827: LD_INT 9
13829: PUSH
13830: LD_INT 10
13832: PUSH
13833: LD_INT 11
13835: PUSH
13836: LD_INT 12
13838: PUSH
13839: LD_INT 13
13841: PUSH
13842: LD_INT 14
13844: PUSH
13845: LD_INT 15
13847: PUSH
13848: LD_INT 16
13850: PUSH
13851: LD_INT 17
13853: PUSH
13854: LD_INT 18
13856: PUSH
13857: LD_INT 19
13859: PUSH
13860: LD_INT 20
13862: PUSH
13863: LD_INT 21
13865: PUSH
13866: LD_INT 22
13868: PUSH
13869: LD_INT 23
13871: PUSH
13872: LD_INT 24
13874: PUSH
13875: LD_INT 25
13877: PUSH
13878: LD_INT 26
13880: PUSH
13881: LD_INT 27
13883: PUSH
13884: LD_INT 28
13886: PUSH
13887: LD_INT 29
13889: PUSH
13890: LD_INT 30
13892: PUSH
13893: LD_INT 31
13895: PUSH
13896: LD_INT 32
13898: PUSH
13899: LD_INT 33
13901: PUSH
13902: LD_INT 34
13904: PUSH
13905: LD_INT 36
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: PUSH
13945: LD_INT 101
13947: PUSH
13948: LD_INT 102
13950: PUSH
13951: LD_INT 103
13953: PUSH
13954: LD_INT 104
13956: PUSH
13957: LD_INT 105
13959: PUSH
13960: LD_INT 106
13962: PUSH
13963: LD_INT 107
13965: PUSH
13966: LD_INT 108
13968: PUSH
13969: LD_INT 109
13971: PUSH
13972: LD_INT 110
13974: PUSH
13975: LD_INT 111
13977: PUSH
13978: LD_INT 112
13980: PUSH
13981: LD_INT 113
13983: PUSH
13984: LD_INT 114
13986: PUSH
13987: EMPTY
13988: LIST
13989: LIST
13990: LIST
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: LIST
14001: LIST
14002: PUSH
14003: EMPTY
14004: LIST
14005: LIST
14006: ST_TO_ADDR
14007: GO 14382
14009: LD_INT 18
14011: DOUBLE
14012: EQUAL
14013: IFTRUE 14017
14015: GO 14153
14017: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14018: LD_ADDR_VAR 0 1
14022: PUSH
14023: LD_INT 2
14025: PUSH
14026: LD_INT 4
14028: PUSH
14029: LD_INT 5
14031: PUSH
14032: LD_INT 7
14034: PUSH
14035: LD_INT 11
14037: PUSH
14038: LD_INT 12
14040: PUSH
14041: LD_INT 15
14043: PUSH
14044: LD_INT 16
14046: PUSH
14047: LD_INT 20
14049: PUSH
14050: LD_INT 21
14052: PUSH
14053: LD_INT 22
14055: PUSH
14056: LD_INT 23
14058: PUSH
14059: LD_INT 25
14061: PUSH
14062: LD_INT 26
14064: PUSH
14065: LD_INT 30
14067: PUSH
14068: LD_INT 31
14070: PUSH
14071: LD_INT 32
14073: PUSH
14074: LD_INT 33
14076: PUSH
14077: LD_INT 34
14079: PUSH
14080: LD_INT 35
14082: PUSH
14083: LD_INT 36
14085: PUSH
14086: EMPTY
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: PUSH
14109: LD_INT 101
14111: PUSH
14112: LD_INT 102
14114: PUSH
14115: LD_INT 103
14117: PUSH
14118: LD_INT 106
14120: PUSH
14121: LD_INT 108
14123: PUSH
14124: LD_INT 112
14126: PUSH
14127: LD_INT 113
14129: PUSH
14130: LD_INT 114
14132: PUSH
14133: LD_INT 115
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: ST_TO_ADDR
14151: GO 14382
14153: LD_INT 19
14155: DOUBLE
14156: EQUAL
14157: IFTRUE 14161
14159: GO 14381
14161: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14162: LD_ADDR_VAR 0 1
14166: PUSH
14167: LD_INT 1
14169: PUSH
14170: LD_INT 2
14172: PUSH
14173: LD_INT 3
14175: PUSH
14176: LD_INT 4
14178: PUSH
14179: LD_INT 5
14181: PUSH
14182: LD_INT 6
14184: PUSH
14185: LD_INT 7
14187: PUSH
14188: LD_INT 8
14190: PUSH
14191: LD_INT 9
14193: PUSH
14194: LD_INT 10
14196: PUSH
14197: LD_INT 11
14199: PUSH
14200: LD_INT 12
14202: PUSH
14203: LD_INT 13
14205: PUSH
14206: LD_INT 14
14208: PUSH
14209: LD_INT 15
14211: PUSH
14212: LD_INT 16
14214: PUSH
14215: LD_INT 17
14217: PUSH
14218: LD_INT 18
14220: PUSH
14221: LD_INT 19
14223: PUSH
14224: LD_INT 20
14226: PUSH
14227: LD_INT 21
14229: PUSH
14230: LD_INT 22
14232: PUSH
14233: LD_INT 23
14235: PUSH
14236: LD_INT 24
14238: PUSH
14239: LD_INT 25
14241: PUSH
14242: LD_INT 26
14244: PUSH
14245: LD_INT 27
14247: PUSH
14248: LD_INT 28
14250: PUSH
14251: LD_INT 29
14253: PUSH
14254: LD_INT 30
14256: PUSH
14257: LD_INT 31
14259: PUSH
14260: LD_INT 32
14262: PUSH
14263: LD_INT 33
14265: PUSH
14266: LD_INT 34
14268: PUSH
14269: LD_INT 35
14271: PUSH
14272: LD_INT 36
14274: PUSH
14275: EMPTY
14276: LIST
14277: LIST
14278: LIST
14279: LIST
14280: LIST
14281: LIST
14282: LIST
14283: LIST
14284: LIST
14285: LIST
14286: LIST
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: LIST
14308: LIST
14309: LIST
14310: LIST
14311: LIST
14312: PUSH
14313: LD_INT 101
14315: PUSH
14316: LD_INT 102
14318: PUSH
14319: LD_INT 103
14321: PUSH
14322: LD_INT 104
14324: PUSH
14325: LD_INT 105
14327: PUSH
14328: LD_INT 106
14330: PUSH
14331: LD_INT 107
14333: PUSH
14334: LD_INT 108
14336: PUSH
14337: LD_INT 109
14339: PUSH
14340: LD_INT 110
14342: PUSH
14343: LD_INT 111
14345: PUSH
14346: LD_INT 112
14348: PUSH
14349: LD_INT 113
14351: PUSH
14352: LD_INT 114
14354: PUSH
14355: LD_INT 115
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: ST_TO_ADDR
14379: GO 14382
14381: POP
// end else
14382: GO 14601
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
14384: LD_ADDR_VAR 0 1
14388: PUSH
14389: LD_INT 1
14391: PUSH
14392: LD_INT 2
14394: PUSH
14395: LD_INT 3
14397: PUSH
14398: LD_INT 4
14400: PUSH
14401: LD_INT 5
14403: PUSH
14404: LD_INT 6
14406: PUSH
14407: LD_INT 7
14409: PUSH
14410: LD_INT 8
14412: PUSH
14413: LD_INT 9
14415: PUSH
14416: LD_INT 10
14418: PUSH
14419: LD_INT 11
14421: PUSH
14422: LD_INT 12
14424: PUSH
14425: LD_INT 13
14427: PUSH
14428: LD_INT 14
14430: PUSH
14431: LD_INT 15
14433: PUSH
14434: LD_INT 16
14436: PUSH
14437: LD_INT 17
14439: PUSH
14440: LD_INT 18
14442: PUSH
14443: LD_INT 19
14445: PUSH
14446: LD_INT 20
14448: PUSH
14449: LD_INT 21
14451: PUSH
14452: LD_INT 22
14454: PUSH
14455: LD_INT 23
14457: PUSH
14458: LD_INT 24
14460: PUSH
14461: LD_INT 25
14463: PUSH
14464: LD_INT 26
14466: PUSH
14467: LD_INT 27
14469: PUSH
14470: LD_INT 28
14472: PUSH
14473: LD_INT 29
14475: PUSH
14476: LD_INT 30
14478: PUSH
14479: LD_INT 31
14481: PUSH
14482: LD_INT 32
14484: PUSH
14485: LD_INT 33
14487: PUSH
14488: LD_INT 34
14490: PUSH
14491: LD_INT 35
14493: PUSH
14494: LD_INT 36
14496: PUSH
14497: EMPTY
14498: LIST
14499: LIST
14500: LIST
14501: LIST
14502: LIST
14503: LIST
14504: LIST
14505: LIST
14506: LIST
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: PUSH
14535: LD_INT 101
14537: PUSH
14538: LD_INT 102
14540: PUSH
14541: LD_INT 103
14543: PUSH
14544: LD_INT 104
14546: PUSH
14547: LD_INT 105
14549: PUSH
14550: LD_INT 106
14552: PUSH
14553: LD_INT 107
14555: PUSH
14556: LD_INT 108
14558: PUSH
14559: LD_INT 109
14561: PUSH
14562: LD_INT 110
14564: PUSH
14565: LD_INT 111
14567: PUSH
14568: LD_INT 112
14570: PUSH
14571: LD_INT 113
14573: PUSH
14574: LD_INT 114
14576: PUSH
14577: LD_INT 115
14579: PUSH
14580: EMPTY
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: PUSH
14597: EMPTY
14598: LIST
14599: LIST
14600: ST_TO_ADDR
// if result then
14601: LD_VAR 0 1
14605: IFFALSE 14894
// begin normal :=  ;
14607: LD_ADDR_VAR 0 3
14611: PUSH
14612: LD_STRING 
14614: ST_TO_ADDR
// hardcore :=  ;
14615: LD_ADDR_VAR 0 4
14619: PUSH
14620: LD_STRING 
14622: ST_TO_ADDR
// for i = 1 to normalCounter do
14623: LD_ADDR_VAR 0 5
14627: PUSH
14628: DOUBLE
14629: LD_INT 1
14631: DEC
14632: ST_TO_ADDR
14633: LD_EXP 44
14637: PUSH
14638: FOR_TO
14639: IFFALSE 14740
// begin tmp := 0 ;
14641: LD_ADDR_VAR 0 2
14645: PUSH
14646: LD_STRING 0
14648: ST_TO_ADDR
// if result [ 1 ] then
14649: LD_VAR 0 1
14653: PUSH
14654: LD_INT 1
14656: ARRAY
14657: IFFALSE 14722
// if result [ 1 ] [ 1 ] = i then
14659: LD_VAR 0 1
14663: PUSH
14664: LD_INT 1
14666: ARRAY
14667: PUSH
14668: LD_INT 1
14670: ARRAY
14671: PUSH
14672: LD_VAR 0 5
14676: EQUAL
14677: IFFALSE 14722
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
14679: LD_ADDR_VAR 0 1
14683: PUSH
14684: LD_VAR 0 1
14688: PPUSH
14689: LD_INT 1
14691: PPUSH
14692: LD_VAR 0 1
14696: PUSH
14697: LD_INT 1
14699: ARRAY
14700: PPUSH
14701: LD_INT 1
14703: PPUSH
14704: CALL_OW 3
14708: PPUSH
14709: CALL_OW 1
14713: ST_TO_ADDR
// tmp := 1 ;
14714: LD_ADDR_VAR 0 2
14718: PUSH
14719: LD_STRING 1
14721: ST_TO_ADDR
// end ; normal := normal & tmp ;
14722: LD_ADDR_VAR 0 3
14726: PUSH
14727: LD_VAR 0 3
14731: PUSH
14732: LD_VAR 0 2
14736: STR
14737: ST_TO_ADDR
// end ;
14738: GO 14638
14740: POP
14741: POP
// for i = 1 to hardcoreCounter do
14742: LD_ADDR_VAR 0 5
14746: PUSH
14747: DOUBLE
14748: LD_INT 1
14750: DEC
14751: ST_TO_ADDR
14752: LD_EXP 45
14756: PUSH
14757: FOR_TO
14758: IFFALSE 14863
// begin tmp := 0 ;
14760: LD_ADDR_VAR 0 2
14764: PUSH
14765: LD_STRING 0
14767: ST_TO_ADDR
// if result [ 2 ] then
14768: LD_VAR 0 1
14772: PUSH
14773: LD_INT 2
14775: ARRAY
14776: IFFALSE 14845
// if result [ 2 ] [ 1 ] = 100 + i then
14778: LD_VAR 0 1
14782: PUSH
14783: LD_INT 2
14785: ARRAY
14786: PUSH
14787: LD_INT 1
14789: ARRAY
14790: PUSH
14791: LD_INT 100
14793: PUSH
14794: LD_VAR 0 5
14798: PLUS
14799: EQUAL
14800: IFFALSE 14845
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
14802: LD_ADDR_VAR 0 1
14806: PUSH
14807: LD_VAR 0 1
14811: PPUSH
14812: LD_INT 2
14814: PPUSH
14815: LD_VAR 0 1
14819: PUSH
14820: LD_INT 2
14822: ARRAY
14823: PPUSH
14824: LD_INT 1
14826: PPUSH
14827: CALL_OW 3
14831: PPUSH
14832: CALL_OW 1
14836: ST_TO_ADDR
// tmp := 1 ;
14837: LD_ADDR_VAR 0 2
14841: PUSH
14842: LD_STRING 1
14844: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
14845: LD_ADDR_VAR 0 4
14849: PUSH
14850: LD_VAR 0 4
14854: PUSH
14855: LD_VAR 0 2
14859: STR
14860: ST_TO_ADDR
// end ;
14861: GO 14757
14863: POP
14864: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
14865: LD_STRING getStreamItemsFromMission("
14867: PUSH
14868: LD_VAR 0 3
14872: STR
14873: PUSH
14874: LD_STRING ","
14876: STR
14877: PUSH
14878: LD_VAR 0 4
14882: STR
14883: PUSH
14884: LD_STRING ")
14886: STR
14887: PPUSH
14888: CALL_OW 559
// end else
14892: GO 14901
// ToLua ( getStreamItemsFromMission("","") ) ;
14894: LD_STRING getStreamItemsFromMission("","")
14896: PPUSH
14897: CALL_OW 559
// end ;
14901: LD_VAR 0 1
14905: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
14906: LD_VAR 0 2
14910: PUSH
14911: LD_INT 100
14913: EQUAL
14914: IFFALSE 15863
// begin if not StreamModeActive then
14916: LD_EXP 43
14920: NOT
14921: IFFALSE 14931
// StreamModeActive := true ;
14923: LD_ADDR_EXP 43
14927: PUSH
14928: LD_INT 1
14930: ST_TO_ADDR
// if p3 = 0 then
14931: LD_VAR 0 3
14935: PUSH
14936: LD_INT 0
14938: EQUAL
14939: IFFALSE 14945
// InitStreamMode ;
14941: CALL 10984 0 0
// if p3 = 1 then
14945: LD_VAR 0 3
14949: PUSH
14950: LD_INT 1
14952: EQUAL
14953: IFFALSE 14963
// sRocket := true ;
14955: LD_ADDR_EXP 48
14959: PUSH
14960: LD_INT 1
14962: ST_TO_ADDR
// if p3 = 2 then
14963: LD_VAR 0 3
14967: PUSH
14968: LD_INT 2
14970: EQUAL
14971: IFFALSE 14981
// sSpeed := true ;
14973: LD_ADDR_EXP 47
14977: PUSH
14978: LD_INT 1
14980: ST_TO_ADDR
// if p3 = 3 then
14981: LD_VAR 0 3
14985: PUSH
14986: LD_INT 3
14988: EQUAL
14989: IFFALSE 14999
// sEngine := true ;
14991: LD_ADDR_EXP 49
14995: PUSH
14996: LD_INT 1
14998: ST_TO_ADDR
// if p3 = 4 then
14999: LD_VAR 0 3
15003: PUSH
15004: LD_INT 4
15006: EQUAL
15007: IFFALSE 15017
// sSpec := true ;
15009: LD_ADDR_EXP 46
15013: PUSH
15014: LD_INT 1
15016: ST_TO_ADDR
// if p3 = 5 then
15017: LD_VAR 0 3
15021: PUSH
15022: LD_INT 5
15024: EQUAL
15025: IFFALSE 15035
// sLevel := true ;
15027: LD_ADDR_EXP 50
15031: PUSH
15032: LD_INT 1
15034: ST_TO_ADDR
// if p3 = 6 then
15035: LD_VAR 0 3
15039: PUSH
15040: LD_INT 6
15042: EQUAL
15043: IFFALSE 15053
// sArmoury := true ;
15045: LD_ADDR_EXP 51
15049: PUSH
15050: LD_INT 1
15052: ST_TO_ADDR
// if p3 = 7 then
15053: LD_VAR 0 3
15057: PUSH
15058: LD_INT 7
15060: EQUAL
15061: IFFALSE 15071
// sRadar := true ;
15063: LD_ADDR_EXP 52
15067: PUSH
15068: LD_INT 1
15070: ST_TO_ADDR
// if p3 = 8 then
15071: LD_VAR 0 3
15075: PUSH
15076: LD_INT 8
15078: EQUAL
15079: IFFALSE 15089
// sBunker := true ;
15081: LD_ADDR_EXP 53
15085: PUSH
15086: LD_INT 1
15088: ST_TO_ADDR
// if p3 = 9 then
15089: LD_VAR 0 3
15093: PUSH
15094: LD_INT 9
15096: EQUAL
15097: IFFALSE 15107
// sHack := true ;
15099: LD_ADDR_EXP 54
15103: PUSH
15104: LD_INT 1
15106: ST_TO_ADDR
// if p3 = 10 then
15107: LD_VAR 0 3
15111: PUSH
15112: LD_INT 10
15114: EQUAL
15115: IFFALSE 15125
// sFire := true ;
15117: LD_ADDR_EXP 55
15121: PUSH
15122: LD_INT 1
15124: ST_TO_ADDR
// if p3 = 11 then
15125: LD_VAR 0 3
15129: PUSH
15130: LD_INT 11
15132: EQUAL
15133: IFFALSE 15143
// sRefresh := true ;
15135: LD_ADDR_EXP 56
15139: PUSH
15140: LD_INT 1
15142: ST_TO_ADDR
// if p3 = 12 then
15143: LD_VAR 0 3
15147: PUSH
15148: LD_INT 12
15150: EQUAL
15151: IFFALSE 15161
// sExp := true ;
15153: LD_ADDR_EXP 57
15157: PUSH
15158: LD_INT 1
15160: ST_TO_ADDR
// if p3 = 13 then
15161: LD_VAR 0 3
15165: PUSH
15166: LD_INT 13
15168: EQUAL
15169: IFFALSE 15179
// sDepot := true ;
15171: LD_ADDR_EXP 58
15175: PUSH
15176: LD_INT 1
15178: ST_TO_ADDR
// if p3 = 14 then
15179: LD_VAR 0 3
15183: PUSH
15184: LD_INT 14
15186: EQUAL
15187: IFFALSE 15197
// sFlag := true ;
15189: LD_ADDR_EXP 59
15193: PUSH
15194: LD_INT 1
15196: ST_TO_ADDR
// if p3 = 15 then
15197: LD_VAR 0 3
15201: PUSH
15202: LD_INT 15
15204: EQUAL
15205: IFFALSE 15215
// sKamikadze := true ;
15207: LD_ADDR_EXP 67
15211: PUSH
15212: LD_INT 1
15214: ST_TO_ADDR
// if p3 = 16 then
15215: LD_VAR 0 3
15219: PUSH
15220: LD_INT 16
15222: EQUAL
15223: IFFALSE 15233
// sTroll := true ;
15225: LD_ADDR_EXP 68
15229: PUSH
15230: LD_INT 1
15232: ST_TO_ADDR
// if p3 = 17 then
15233: LD_VAR 0 3
15237: PUSH
15238: LD_INT 17
15240: EQUAL
15241: IFFALSE 15251
// sSlow := true ;
15243: LD_ADDR_EXP 69
15247: PUSH
15248: LD_INT 1
15250: ST_TO_ADDR
// if p3 = 18 then
15251: LD_VAR 0 3
15255: PUSH
15256: LD_INT 18
15258: EQUAL
15259: IFFALSE 15269
// sLack := true ;
15261: LD_ADDR_EXP 70
15265: PUSH
15266: LD_INT 1
15268: ST_TO_ADDR
// if p3 = 19 then
15269: LD_VAR 0 3
15273: PUSH
15274: LD_INT 19
15276: EQUAL
15277: IFFALSE 15287
// sTank := true ;
15279: LD_ADDR_EXP 72
15283: PUSH
15284: LD_INT 1
15286: ST_TO_ADDR
// if p3 = 20 then
15287: LD_VAR 0 3
15291: PUSH
15292: LD_INT 20
15294: EQUAL
15295: IFFALSE 15305
// sRemote := true ;
15297: LD_ADDR_EXP 73
15301: PUSH
15302: LD_INT 1
15304: ST_TO_ADDR
// if p3 = 21 then
15305: LD_VAR 0 3
15309: PUSH
15310: LD_INT 21
15312: EQUAL
15313: IFFALSE 15323
// sPowell := true ;
15315: LD_ADDR_EXP 74
15319: PUSH
15320: LD_INT 1
15322: ST_TO_ADDR
// if p3 = 22 then
15323: LD_VAR 0 3
15327: PUSH
15328: LD_INT 22
15330: EQUAL
15331: IFFALSE 15341
// sTeleport := true ;
15333: LD_ADDR_EXP 77
15337: PUSH
15338: LD_INT 1
15340: ST_TO_ADDR
// if p3 = 23 then
15341: LD_VAR 0 3
15345: PUSH
15346: LD_INT 23
15348: EQUAL
15349: IFFALSE 15359
// sOilTower := true ;
15351: LD_ADDR_EXP 79
15355: PUSH
15356: LD_INT 1
15358: ST_TO_ADDR
// if p3 = 24 then
15359: LD_VAR 0 3
15363: PUSH
15364: LD_INT 24
15366: EQUAL
15367: IFFALSE 15377
// sShovel := true ;
15369: LD_ADDR_EXP 80
15373: PUSH
15374: LD_INT 1
15376: ST_TO_ADDR
// if p3 = 25 then
15377: LD_VAR 0 3
15381: PUSH
15382: LD_INT 25
15384: EQUAL
15385: IFFALSE 15395
// sSheik := true ;
15387: LD_ADDR_EXP 81
15391: PUSH
15392: LD_INT 1
15394: ST_TO_ADDR
// if p3 = 26 then
15395: LD_VAR 0 3
15399: PUSH
15400: LD_INT 26
15402: EQUAL
15403: IFFALSE 15413
// sEarthquake := true ;
15405: LD_ADDR_EXP 83
15409: PUSH
15410: LD_INT 1
15412: ST_TO_ADDR
// if p3 = 27 then
15413: LD_VAR 0 3
15417: PUSH
15418: LD_INT 27
15420: EQUAL
15421: IFFALSE 15431
// sAI := true ;
15423: LD_ADDR_EXP 84
15427: PUSH
15428: LD_INT 1
15430: ST_TO_ADDR
// if p3 = 28 then
15431: LD_VAR 0 3
15435: PUSH
15436: LD_INT 28
15438: EQUAL
15439: IFFALSE 15449
// sCargo := true ;
15441: LD_ADDR_EXP 87
15445: PUSH
15446: LD_INT 1
15448: ST_TO_ADDR
// if p3 = 29 then
15449: LD_VAR 0 3
15453: PUSH
15454: LD_INT 29
15456: EQUAL
15457: IFFALSE 15467
// sDLaser := true ;
15459: LD_ADDR_EXP 88
15463: PUSH
15464: LD_INT 1
15466: ST_TO_ADDR
// if p3 = 30 then
15467: LD_VAR 0 3
15471: PUSH
15472: LD_INT 30
15474: EQUAL
15475: IFFALSE 15485
// sExchange := true ;
15477: LD_ADDR_EXP 89
15481: PUSH
15482: LD_INT 1
15484: ST_TO_ADDR
// if p3 = 31 then
15485: LD_VAR 0 3
15489: PUSH
15490: LD_INT 31
15492: EQUAL
15493: IFFALSE 15503
// sFac := true ;
15495: LD_ADDR_EXP 90
15499: PUSH
15500: LD_INT 1
15502: ST_TO_ADDR
// if p3 = 32 then
15503: LD_VAR 0 3
15507: PUSH
15508: LD_INT 32
15510: EQUAL
15511: IFFALSE 15521
// sPower := true ;
15513: LD_ADDR_EXP 91
15517: PUSH
15518: LD_INT 1
15520: ST_TO_ADDR
// if p3 = 33 then
15521: LD_VAR 0 3
15525: PUSH
15526: LD_INT 33
15528: EQUAL
15529: IFFALSE 15539
// sRandom := true ;
15531: LD_ADDR_EXP 92
15535: PUSH
15536: LD_INT 1
15538: ST_TO_ADDR
// if p3 = 34 then
15539: LD_VAR 0 3
15543: PUSH
15544: LD_INT 34
15546: EQUAL
15547: IFFALSE 15557
// sShield := true ;
15549: LD_ADDR_EXP 93
15553: PUSH
15554: LD_INT 1
15556: ST_TO_ADDR
// if p3 = 35 then
15557: LD_VAR 0 3
15561: PUSH
15562: LD_INT 35
15564: EQUAL
15565: IFFALSE 15575
// sTime := true ;
15567: LD_ADDR_EXP 94
15571: PUSH
15572: LD_INT 1
15574: ST_TO_ADDR
// if p3 = 36 then
15575: LD_VAR 0 3
15579: PUSH
15580: LD_INT 36
15582: EQUAL
15583: IFFALSE 15593
// sTools := true ;
15585: LD_ADDR_EXP 95
15589: PUSH
15590: LD_INT 1
15592: ST_TO_ADDR
// if p3 = 101 then
15593: LD_VAR 0 3
15597: PUSH
15598: LD_INT 101
15600: EQUAL
15601: IFFALSE 15611
// sSold := true ;
15603: LD_ADDR_EXP 60
15607: PUSH
15608: LD_INT 1
15610: ST_TO_ADDR
// if p3 = 102 then
15611: LD_VAR 0 3
15615: PUSH
15616: LD_INT 102
15618: EQUAL
15619: IFFALSE 15629
// sDiff := true ;
15621: LD_ADDR_EXP 61
15625: PUSH
15626: LD_INT 1
15628: ST_TO_ADDR
// if p3 = 103 then
15629: LD_VAR 0 3
15633: PUSH
15634: LD_INT 103
15636: EQUAL
15637: IFFALSE 15647
// sFog := true ;
15639: LD_ADDR_EXP 64
15643: PUSH
15644: LD_INT 1
15646: ST_TO_ADDR
// if p3 = 104 then
15647: LD_VAR 0 3
15651: PUSH
15652: LD_INT 104
15654: EQUAL
15655: IFFALSE 15665
// sReset := true ;
15657: LD_ADDR_EXP 65
15661: PUSH
15662: LD_INT 1
15664: ST_TO_ADDR
// if p3 = 105 then
15665: LD_VAR 0 3
15669: PUSH
15670: LD_INT 105
15672: EQUAL
15673: IFFALSE 15683
// sSun := true ;
15675: LD_ADDR_EXP 66
15679: PUSH
15680: LD_INT 1
15682: ST_TO_ADDR
// if p3 = 106 then
15683: LD_VAR 0 3
15687: PUSH
15688: LD_INT 106
15690: EQUAL
15691: IFFALSE 15701
// sTiger := true ;
15693: LD_ADDR_EXP 62
15697: PUSH
15698: LD_INT 1
15700: ST_TO_ADDR
// if p3 = 107 then
15701: LD_VAR 0 3
15705: PUSH
15706: LD_INT 107
15708: EQUAL
15709: IFFALSE 15719
// sBomb := true ;
15711: LD_ADDR_EXP 63
15715: PUSH
15716: LD_INT 1
15718: ST_TO_ADDR
// if p3 = 108 then
15719: LD_VAR 0 3
15723: PUSH
15724: LD_INT 108
15726: EQUAL
15727: IFFALSE 15737
// sWound := true ;
15729: LD_ADDR_EXP 71
15733: PUSH
15734: LD_INT 1
15736: ST_TO_ADDR
// if p3 = 109 then
15737: LD_VAR 0 3
15741: PUSH
15742: LD_INT 109
15744: EQUAL
15745: IFFALSE 15755
// sBetray := true ;
15747: LD_ADDR_EXP 75
15751: PUSH
15752: LD_INT 1
15754: ST_TO_ADDR
// if p3 = 110 then
15755: LD_VAR 0 3
15759: PUSH
15760: LD_INT 110
15762: EQUAL
15763: IFFALSE 15773
// sContamin := true ;
15765: LD_ADDR_EXP 76
15769: PUSH
15770: LD_INT 1
15772: ST_TO_ADDR
// if p3 = 111 then
15773: LD_VAR 0 3
15777: PUSH
15778: LD_INT 111
15780: EQUAL
15781: IFFALSE 15791
// sOil := true ;
15783: LD_ADDR_EXP 78
15787: PUSH
15788: LD_INT 1
15790: ST_TO_ADDR
// if p3 = 112 then
15791: LD_VAR 0 3
15795: PUSH
15796: LD_INT 112
15798: EQUAL
15799: IFFALSE 15809
// sStu := true ;
15801: LD_ADDR_EXP 82
15805: PUSH
15806: LD_INT 1
15808: ST_TO_ADDR
// if p3 = 113 then
15809: LD_VAR 0 3
15813: PUSH
15814: LD_INT 113
15816: EQUAL
15817: IFFALSE 15827
// sBazooka := true ;
15819: LD_ADDR_EXP 85
15823: PUSH
15824: LD_INT 1
15826: ST_TO_ADDR
// if p3 = 114 then
15827: LD_VAR 0 3
15831: PUSH
15832: LD_INT 114
15834: EQUAL
15835: IFFALSE 15845
// sMortar := true ;
15837: LD_ADDR_EXP 86
15841: PUSH
15842: LD_INT 1
15844: ST_TO_ADDR
// if p3 = 115 then
15845: LD_VAR 0 3
15849: PUSH
15850: LD_INT 115
15852: EQUAL
15853: IFFALSE 15863
// sRanger := true ;
15855: LD_ADDR_EXP 96
15859: PUSH
15860: LD_INT 1
15862: ST_TO_ADDR
// end ; end ;
15863: PPOPN 6
15865: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
15866: LD_EXP 43
15870: PUSH
15871: LD_EXP 48
15875: AND
15876: IFFALSE 16000
15878: GO 15880
15880: DISABLE
15881: LD_INT 0
15883: PPUSH
15884: PPUSH
// begin enable ;
15885: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
15886: LD_ADDR_VAR 0 2
15890: PUSH
15891: LD_INT 22
15893: PUSH
15894: LD_OWVAR 2
15898: PUSH
15899: EMPTY
15900: LIST
15901: LIST
15902: PUSH
15903: LD_INT 2
15905: PUSH
15906: LD_INT 34
15908: PUSH
15909: LD_INT 7
15911: PUSH
15912: EMPTY
15913: LIST
15914: LIST
15915: PUSH
15916: LD_INT 34
15918: PUSH
15919: LD_INT 45
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PUSH
15926: LD_INT 34
15928: PUSH
15929: LD_INT 28
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: PUSH
15936: LD_INT 34
15938: PUSH
15939: LD_INT 47
15941: PUSH
15942: EMPTY
15943: LIST
15944: LIST
15945: PUSH
15946: EMPTY
15947: LIST
15948: LIST
15949: LIST
15950: LIST
15951: LIST
15952: PUSH
15953: EMPTY
15954: LIST
15955: LIST
15956: PPUSH
15957: CALL_OW 69
15961: ST_TO_ADDR
// if not tmp then
15962: LD_VAR 0 2
15966: NOT
15967: IFFALSE 15971
// exit ;
15969: GO 16000
// for i in tmp do
15971: LD_ADDR_VAR 0 1
15975: PUSH
15976: LD_VAR 0 2
15980: PUSH
15981: FOR_IN
15982: IFFALSE 15998
// begin SetLives ( i , 0 ) ;
15984: LD_VAR 0 1
15988: PPUSH
15989: LD_INT 0
15991: PPUSH
15992: CALL_OW 234
// end ;
15996: GO 15981
15998: POP
15999: POP
// end ;
16000: PPOPN 2
16002: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
16003: LD_EXP 43
16007: PUSH
16008: LD_EXP 49
16012: AND
16013: IFFALSE 16097
16015: GO 16017
16017: DISABLE
16018: LD_INT 0
16020: PPUSH
16021: PPUSH
// begin enable ;
16022: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
16023: LD_ADDR_VAR 0 2
16027: PUSH
16028: LD_INT 22
16030: PUSH
16031: LD_OWVAR 2
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: PUSH
16040: LD_INT 32
16042: PUSH
16043: LD_INT 3
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: PUSH
16050: EMPTY
16051: LIST
16052: LIST
16053: PPUSH
16054: CALL_OW 69
16058: ST_TO_ADDR
// if not tmp then
16059: LD_VAR 0 2
16063: NOT
16064: IFFALSE 16068
// exit ;
16066: GO 16097
// for i in tmp do
16068: LD_ADDR_VAR 0 1
16072: PUSH
16073: LD_VAR 0 2
16077: PUSH
16078: FOR_IN
16079: IFFALSE 16095
// begin SetLives ( i , 0 ) ;
16081: LD_VAR 0 1
16085: PPUSH
16086: LD_INT 0
16088: PPUSH
16089: CALL_OW 234
// end ;
16093: GO 16078
16095: POP
16096: POP
// end ;
16097: PPOPN 2
16099: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
16100: LD_EXP 43
16104: PUSH
16105: LD_EXP 46
16109: AND
16110: IFFALSE 16203
16112: GO 16114
16114: DISABLE
16115: LD_INT 0
16117: PPUSH
// begin enable ;
16118: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
16119: LD_ADDR_VAR 0 1
16123: PUSH
16124: LD_INT 22
16126: PUSH
16127: LD_OWVAR 2
16131: PUSH
16132: EMPTY
16133: LIST
16134: LIST
16135: PUSH
16136: LD_INT 2
16138: PUSH
16139: LD_INT 25
16141: PUSH
16142: LD_INT 5
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: LD_INT 25
16151: PUSH
16152: LD_INT 9
16154: PUSH
16155: EMPTY
16156: LIST
16157: LIST
16158: PUSH
16159: LD_INT 25
16161: PUSH
16162: LD_INT 8
16164: PUSH
16165: EMPTY
16166: LIST
16167: LIST
16168: PUSH
16169: EMPTY
16170: LIST
16171: LIST
16172: LIST
16173: LIST
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: PPUSH
16179: CALL_OW 69
16183: PUSH
16184: FOR_IN
16185: IFFALSE 16201
// begin SetClass ( i , 1 ) ;
16187: LD_VAR 0 1
16191: PPUSH
16192: LD_INT 1
16194: PPUSH
16195: CALL_OW 336
// end ;
16199: GO 16184
16201: POP
16202: POP
// end ;
16203: PPOPN 1
16205: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16206: LD_EXP 43
16210: PUSH
16211: LD_EXP 47
16215: AND
16216: PUSH
16217: LD_OWVAR 65
16221: PUSH
16222: LD_INT 7
16224: LESS
16225: AND
16226: IFFALSE 16240
16228: GO 16230
16230: DISABLE
// begin enable ;
16231: ENABLE
// game_speed := 7 ;
16232: LD_ADDR_OWVAR 65
16236: PUSH
16237: LD_INT 7
16239: ST_TO_ADDR
// end ;
16240: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16241: LD_EXP 43
16245: PUSH
16246: LD_EXP 50
16250: AND
16251: IFFALSE 16453
16253: GO 16255
16255: DISABLE
16256: LD_INT 0
16258: PPUSH
16259: PPUSH
16260: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16261: LD_ADDR_VAR 0 3
16265: PUSH
16266: LD_INT 81
16268: PUSH
16269: LD_OWVAR 2
16273: PUSH
16274: EMPTY
16275: LIST
16276: LIST
16277: PUSH
16278: LD_INT 21
16280: PUSH
16281: LD_INT 1
16283: PUSH
16284: EMPTY
16285: LIST
16286: LIST
16287: PUSH
16288: EMPTY
16289: LIST
16290: LIST
16291: PPUSH
16292: CALL_OW 69
16296: ST_TO_ADDR
// if not tmp then
16297: LD_VAR 0 3
16301: NOT
16302: IFFALSE 16306
// exit ;
16304: GO 16453
// if tmp > 5 then
16306: LD_VAR 0 3
16310: PUSH
16311: LD_INT 5
16313: GREATER
16314: IFFALSE 16326
// k := 5 else
16316: LD_ADDR_VAR 0 2
16320: PUSH
16321: LD_INT 5
16323: ST_TO_ADDR
16324: GO 16336
// k := tmp ;
16326: LD_ADDR_VAR 0 2
16330: PUSH
16331: LD_VAR 0 3
16335: ST_TO_ADDR
// for i := 1 to k do
16336: LD_ADDR_VAR 0 1
16340: PUSH
16341: DOUBLE
16342: LD_INT 1
16344: DEC
16345: ST_TO_ADDR
16346: LD_VAR 0 2
16350: PUSH
16351: FOR_TO
16352: IFFALSE 16451
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
16354: LD_VAR 0 3
16358: PUSH
16359: LD_VAR 0 1
16363: ARRAY
16364: PPUSH
16365: LD_VAR 0 1
16369: PUSH
16370: LD_INT 4
16372: MOD
16373: PUSH
16374: LD_INT 1
16376: PLUS
16377: PPUSH
16378: CALL_OW 259
16382: PUSH
16383: LD_INT 10
16385: LESS
16386: IFFALSE 16449
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
16388: LD_VAR 0 3
16392: PUSH
16393: LD_VAR 0 1
16397: ARRAY
16398: PPUSH
16399: LD_VAR 0 1
16403: PUSH
16404: LD_INT 4
16406: MOD
16407: PUSH
16408: LD_INT 1
16410: PLUS
16411: PPUSH
16412: LD_VAR 0 3
16416: PUSH
16417: LD_VAR 0 1
16421: ARRAY
16422: PPUSH
16423: LD_VAR 0 1
16427: PUSH
16428: LD_INT 4
16430: MOD
16431: PUSH
16432: LD_INT 1
16434: PLUS
16435: PPUSH
16436: CALL_OW 259
16440: PUSH
16441: LD_INT 1
16443: PLUS
16444: PPUSH
16445: CALL_OW 237
16449: GO 16351
16451: POP
16452: POP
// end ;
16453: PPOPN 3
16455: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16456: LD_EXP 43
16460: PUSH
16461: LD_EXP 51
16465: AND
16466: IFFALSE 16486
16468: GO 16470
16470: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16471: LD_INT 4
16473: PPUSH
16474: LD_OWVAR 2
16478: PPUSH
16479: LD_INT 0
16481: PPUSH
16482: CALL_OW 324
16486: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16487: LD_EXP 43
16491: PUSH
16492: LD_EXP 80
16496: AND
16497: IFFALSE 16517
16499: GO 16501
16501: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16502: LD_INT 19
16504: PPUSH
16505: LD_OWVAR 2
16509: PPUSH
16510: LD_INT 0
16512: PPUSH
16513: CALL_OW 324
16517: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16518: LD_EXP 43
16522: PUSH
16523: LD_EXP 52
16527: AND
16528: IFFALSE 16630
16530: GO 16532
16532: DISABLE
16533: LD_INT 0
16535: PPUSH
16536: PPUSH
// begin enable ;
16537: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16538: LD_ADDR_VAR 0 2
16542: PUSH
16543: LD_INT 22
16545: PUSH
16546: LD_OWVAR 2
16550: PUSH
16551: EMPTY
16552: LIST
16553: LIST
16554: PUSH
16555: LD_INT 2
16557: PUSH
16558: LD_INT 34
16560: PUSH
16561: LD_INT 11
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PUSH
16568: LD_INT 34
16570: PUSH
16571: LD_INT 30
16573: PUSH
16574: EMPTY
16575: LIST
16576: LIST
16577: PUSH
16578: EMPTY
16579: LIST
16580: LIST
16581: LIST
16582: PUSH
16583: EMPTY
16584: LIST
16585: LIST
16586: PPUSH
16587: CALL_OW 69
16591: ST_TO_ADDR
// if not tmp then
16592: LD_VAR 0 2
16596: NOT
16597: IFFALSE 16601
// exit ;
16599: GO 16630
// for i in tmp do
16601: LD_ADDR_VAR 0 1
16605: PUSH
16606: LD_VAR 0 2
16610: PUSH
16611: FOR_IN
16612: IFFALSE 16628
// begin SetLives ( i , 0 ) ;
16614: LD_VAR 0 1
16618: PPUSH
16619: LD_INT 0
16621: PPUSH
16622: CALL_OW 234
// end ;
16626: GO 16611
16628: POP
16629: POP
// end ;
16630: PPOPN 2
16632: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16633: LD_EXP 43
16637: PUSH
16638: LD_EXP 53
16642: AND
16643: IFFALSE 16663
16645: GO 16647
16647: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16648: LD_INT 32
16650: PPUSH
16651: LD_OWVAR 2
16655: PPUSH
16656: LD_INT 0
16658: PPUSH
16659: CALL_OW 324
16663: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16664: LD_EXP 43
16668: PUSH
16669: LD_EXP 54
16673: AND
16674: IFFALSE 16855
16676: GO 16678
16678: DISABLE
16679: LD_INT 0
16681: PPUSH
16682: PPUSH
16683: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
16684: LD_ADDR_VAR 0 2
16688: PUSH
16689: LD_INT 22
16691: PUSH
16692: LD_OWVAR 2
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: PUSH
16701: LD_INT 33
16703: PUSH
16704: LD_INT 3
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: PUSH
16711: EMPTY
16712: LIST
16713: LIST
16714: PPUSH
16715: CALL_OW 69
16719: ST_TO_ADDR
// if not tmp then
16720: LD_VAR 0 2
16724: NOT
16725: IFFALSE 16729
// exit ;
16727: GO 16855
// side := 0 ;
16729: LD_ADDR_VAR 0 3
16733: PUSH
16734: LD_INT 0
16736: ST_TO_ADDR
// for i := 1 to 8 do
16737: LD_ADDR_VAR 0 1
16741: PUSH
16742: DOUBLE
16743: LD_INT 1
16745: DEC
16746: ST_TO_ADDR
16747: LD_INT 8
16749: PUSH
16750: FOR_TO
16751: IFFALSE 16799
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
16753: LD_OWVAR 2
16757: PUSH
16758: LD_VAR 0 1
16762: NONEQUAL
16763: PUSH
16764: LD_OWVAR 2
16768: PPUSH
16769: LD_VAR 0 1
16773: PPUSH
16774: CALL_OW 81
16778: PUSH
16779: LD_INT 2
16781: EQUAL
16782: AND
16783: IFFALSE 16797
// begin side := i ;
16785: LD_ADDR_VAR 0 3
16789: PUSH
16790: LD_VAR 0 1
16794: ST_TO_ADDR
// break ;
16795: GO 16799
// end ;
16797: GO 16750
16799: POP
16800: POP
// if not side then
16801: LD_VAR 0 3
16805: NOT
16806: IFFALSE 16810
// exit ;
16808: GO 16855
// for i := 1 to tmp do
16810: LD_ADDR_VAR 0 1
16814: PUSH
16815: DOUBLE
16816: LD_INT 1
16818: DEC
16819: ST_TO_ADDR
16820: LD_VAR 0 2
16824: PUSH
16825: FOR_TO
16826: IFFALSE 16853
// if Prob ( 60 ) then
16828: LD_INT 60
16830: PPUSH
16831: CALL_OW 13
16835: IFFALSE 16851
// SetSide ( i , side ) ;
16837: LD_VAR 0 1
16841: PPUSH
16842: LD_VAR 0 3
16846: PPUSH
16847: CALL_OW 235
16851: GO 16825
16853: POP
16854: POP
// end ;
16855: PPOPN 3
16857: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
16858: LD_EXP 43
16862: PUSH
16863: LD_EXP 56
16867: AND
16868: IFFALSE 16987
16870: GO 16872
16872: DISABLE
16873: LD_INT 0
16875: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
16876: LD_ADDR_VAR 0 1
16880: PUSH
16881: LD_INT 22
16883: PUSH
16884: LD_OWVAR 2
16888: PUSH
16889: EMPTY
16890: LIST
16891: LIST
16892: PUSH
16893: LD_INT 21
16895: PUSH
16896: LD_INT 1
16898: PUSH
16899: EMPTY
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 3
16905: PUSH
16906: LD_INT 23
16908: PUSH
16909: LD_INT 0
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: LIST
16924: PPUSH
16925: CALL_OW 69
16929: PUSH
16930: FOR_IN
16931: IFFALSE 16985
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
16933: LD_VAR 0 1
16937: PPUSH
16938: CALL_OW 257
16942: PUSH
16943: LD_INT 1
16945: PUSH
16946: LD_INT 2
16948: PUSH
16949: LD_INT 3
16951: PUSH
16952: LD_INT 4
16954: PUSH
16955: EMPTY
16956: LIST
16957: LIST
16958: LIST
16959: LIST
16960: IN
16961: IFFALSE 16983
// SetClass ( un , rand ( 1 , 4 ) ) ;
16963: LD_VAR 0 1
16967: PPUSH
16968: LD_INT 1
16970: PPUSH
16971: LD_INT 4
16973: PPUSH
16974: CALL_OW 12
16978: PPUSH
16979: CALL_OW 336
16983: GO 16930
16985: POP
16986: POP
// end ;
16987: PPOPN 1
16989: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
16990: LD_EXP 43
16994: PUSH
16995: LD_EXP 55
16999: AND
17000: IFFALSE 17079
17002: GO 17004
17004: DISABLE
17005: LD_INT 0
17007: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17008: LD_ADDR_VAR 0 1
17012: PUSH
17013: LD_INT 22
17015: PUSH
17016: LD_OWVAR 2
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: PUSH
17025: LD_INT 21
17027: PUSH
17028: LD_INT 3
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PUSH
17035: EMPTY
17036: LIST
17037: LIST
17038: PPUSH
17039: CALL_OW 69
17043: ST_TO_ADDR
// if not tmp then
17044: LD_VAR 0 1
17048: NOT
17049: IFFALSE 17053
// exit ;
17051: GO 17079
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
17053: LD_VAR 0 1
17057: PUSH
17058: LD_INT 1
17060: PPUSH
17061: LD_VAR 0 1
17065: PPUSH
17066: CALL_OW 12
17070: ARRAY
17071: PPUSH
17072: LD_INT 100
17074: PPUSH
17075: CALL_OW 234
// end ;
17079: PPOPN 1
17081: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
17082: LD_EXP 43
17086: PUSH
17087: LD_EXP 57
17091: AND
17092: IFFALSE 17190
17094: GO 17096
17096: DISABLE
17097: LD_INT 0
17099: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17100: LD_ADDR_VAR 0 1
17104: PUSH
17105: LD_INT 22
17107: PUSH
17108: LD_OWVAR 2
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: PUSH
17117: LD_INT 21
17119: PUSH
17120: LD_INT 1
17122: PUSH
17123: EMPTY
17124: LIST
17125: LIST
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PPUSH
17131: CALL_OW 69
17135: ST_TO_ADDR
// if not tmp then
17136: LD_VAR 0 1
17140: NOT
17141: IFFALSE 17145
// exit ;
17143: GO 17190
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
17145: LD_VAR 0 1
17149: PUSH
17150: LD_INT 1
17152: PPUSH
17153: LD_VAR 0 1
17157: PPUSH
17158: CALL_OW 12
17162: ARRAY
17163: PPUSH
17164: LD_INT 1
17166: PPUSH
17167: LD_INT 4
17169: PPUSH
17170: CALL_OW 12
17174: PPUSH
17175: LD_INT 3000
17177: PPUSH
17178: LD_INT 9000
17180: PPUSH
17181: CALL_OW 12
17185: PPUSH
17186: CALL_OW 492
// end ;
17190: PPOPN 1
17192: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17193: LD_EXP 43
17197: PUSH
17198: LD_EXP 58
17202: AND
17203: IFFALSE 17223
17205: GO 17207
17207: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17208: LD_INT 1
17210: PPUSH
17211: LD_OWVAR 2
17215: PPUSH
17216: LD_INT 0
17218: PPUSH
17219: CALL_OW 324
17223: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17224: LD_EXP 43
17228: PUSH
17229: LD_EXP 59
17233: AND
17234: IFFALSE 17317
17236: GO 17238
17238: DISABLE
17239: LD_INT 0
17241: PPUSH
17242: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17243: LD_ADDR_VAR 0 2
17247: PUSH
17248: LD_INT 22
17250: PUSH
17251: LD_OWVAR 2
17255: PUSH
17256: EMPTY
17257: LIST
17258: LIST
17259: PUSH
17260: LD_INT 21
17262: PUSH
17263: LD_INT 3
17265: PUSH
17266: EMPTY
17267: LIST
17268: LIST
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: PPUSH
17274: CALL_OW 69
17278: ST_TO_ADDR
// if not tmp then
17279: LD_VAR 0 2
17283: NOT
17284: IFFALSE 17288
// exit ;
17286: GO 17317
// for i in tmp do
17288: LD_ADDR_VAR 0 1
17292: PUSH
17293: LD_VAR 0 2
17297: PUSH
17298: FOR_IN
17299: IFFALSE 17315
// SetBLevel ( i , 10 ) ;
17301: LD_VAR 0 1
17305: PPUSH
17306: LD_INT 10
17308: PPUSH
17309: CALL_OW 241
17313: GO 17298
17315: POP
17316: POP
// end ;
17317: PPOPN 2
17319: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17320: LD_EXP 43
17324: PUSH
17325: LD_EXP 60
17329: AND
17330: IFFALSE 17441
17332: GO 17334
17334: DISABLE
17335: LD_INT 0
17337: PPUSH
17338: PPUSH
17339: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17340: LD_ADDR_VAR 0 3
17344: PUSH
17345: LD_INT 22
17347: PUSH
17348: LD_OWVAR 2
17352: PUSH
17353: EMPTY
17354: LIST
17355: LIST
17356: PUSH
17357: LD_INT 25
17359: PUSH
17360: LD_INT 1
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: PPUSH
17371: CALL_OW 69
17375: ST_TO_ADDR
// if not tmp then
17376: LD_VAR 0 3
17380: NOT
17381: IFFALSE 17385
// exit ;
17383: GO 17441
// un := tmp [ rand ( 1 , tmp ) ] ;
17385: LD_ADDR_VAR 0 2
17389: PUSH
17390: LD_VAR 0 3
17394: PUSH
17395: LD_INT 1
17397: PPUSH
17398: LD_VAR 0 3
17402: PPUSH
17403: CALL_OW 12
17407: ARRAY
17408: ST_TO_ADDR
// if Crawls ( un ) then
17409: LD_VAR 0 2
17413: PPUSH
17414: CALL_OW 318
17418: IFFALSE 17429
// ComWalk ( un ) ;
17420: LD_VAR 0 2
17424: PPUSH
17425: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17429: LD_VAR 0 2
17433: PPUSH
17434: LD_INT 5
17436: PPUSH
17437: CALL_OW 336
// end ;
17441: PPOPN 3
17443: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17444: LD_EXP 43
17448: PUSH
17449: LD_EXP 61
17453: AND
17454: PUSH
17455: LD_OWVAR 67
17459: PUSH
17460: LD_INT 3
17462: LESS
17463: AND
17464: IFFALSE 17483
17466: GO 17468
17468: DISABLE
// Difficulty := Difficulty + 1 ;
17469: LD_ADDR_OWVAR 67
17473: PUSH
17474: LD_OWVAR 67
17478: PUSH
17479: LD_INT 1
17481: PLUS
17482: ST_TO_ADDR
17483: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17484: LD_EXP 43
17488: PUSH
17489: LD_EXP 62
17493: AND
17494: IFFALSE 17597
17496: GO 17498
17498: DISABLE
17499: LD_INT 0
17501: PPUSH
// begin for i := 1 to 5 do
17502: LD_ADDR_VAR 0 1
17506: PUSH
17507: DOUBLE
17508: LD_INT 1
17510: DEC
17511: ST_TO_ADDR
17512: LD_INT 5
17514: PUSH
17515: FOR_TO
17516: IFFALSE 17595
// begin uc_nation := nation_nature ;
17518: LD_ADDR_OWVAR 21
17522: PUSH
17523: LD_INT 0
17525: ST_TO_ADDR
// uc_side := 0 ;
17526: LD_ADDR_OWVAR 20
17530: PUSH
17531: LD_INT 0
17533: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17534: LD_ADDR_OWVAR 29
17538: PUSH
17539: LD_INT 12
17541: PUSH
17542: LD_INT 12
17544: PUSH
17545: EMPTY
17546: LIST
17547: LIST
17548: ST_TO_ADDR
// hc_agressivity := 20 ;
17549: LD_ADDR_OWVAR 35
17553: PUSH
17554: LD_INT 20
17556: ST_TO_ADDR
// hc_class := class_tiger ;
17557: LD_ADDR_OWVAR 28
17561: PUSH
17562: LD_INT 14
17564: ST_TO_ADDR
// hc_gallery :=  ;
17565: LD_ADDR_OWVAR 33
17569: PUSH
17570: LD_STRING 
17572: ST_TO_ADDR
// hc_name :=  ;
17573: LD_ADDR_OWVAR 26
17577: PUSH
17578: LD_STRING 
17580: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17581: CALL_OW 44
17585: PPUSH
17586: LD_INT 0
17588: PPUSH
17589: CALL_OW 51
// end ;
17593: GO 17515
17595: POP
17596: POP
// end ;
17597: PPOPN 1
17599: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17600: LD_EXP 43
17604: PUSH
17605: LD_EXP 63
17609: AND
17610: IFFALSE 17619
17612: GO 17614
17614: DISABLE
// StreamSibBomb ;
17615: CALL 17620 0 0
17619: END
// export function StreamSibBomb ; var i , x , y ; begin
17620: LD_INT 0
17622: PPUSH
17623: PPUSH
17624: PPUSH
17625: PPUSH
// result := false ;
17626: LD_ADDR_VAR 0 1
17630: PUSH
17631: LD_INT 0
17633: ST_TO_ADDR
// for i := 1 to 16 do
17634: LD_ADDR_VAR 0 2
17638: PUSH
17639: DOUBLE
17640: LD_INT 1
17642: DEC
17643: ST_TO_ADDR
17644: LD_INT 16
17646: PUSH
17647: FOR_TO
17648: IFFALSE 17847
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17650: LD_ADDR_VAR 0 3
17654: PUSH
17655: LD_INT 10
17657: PUSH
17658: LD_INT 20
17660: PUSH
17661: LD_INT 30
17663: PUSH
17664: LD_INT 40
17666: PUSH
17667: LD_INT 50
17669: PUSH
17670: LD_INT 60
17672: PUSH
17673: LD_INT 70
17675: PUSH
17676: LD_INT 80
17678: PUSH
17679: LD_INT 90
17681: PUSH
17682: LD_INT 100
17684: PUSH
17685: LD_INT 110
17687: PUSH
17688: LD_INT 120
17690: PUSH
17691: LD_INT 130
17693: PUSH
17694: LD_INT 140
17696: PUSH
17697: LD_INT 150
17699: PUSH
17700: EMPTY
17701: LIST
17702: LIST
17703: LIST
17704: LIST
17705: LIST
17706: LIST
17707: LIST
17708: LIST
17709: LIST
17710: LIST
17711: LIST
17712: LIST
17713: LIST
17714: LIST
17715: LIST
17716: PUSH
17717: LD_INT 1
17719: PPUSH
17720: LD_INT 15
17722: PPUSH
17723: CALL_OW 12
17727: ARRAY
17728: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17729: LD_ADDR_VAR 0 4
17733: PUSH
17734: LD_INT 10
17736: PUSH
17737: LD_INT 20
17739: PUSH
17740: LD_INT 30
17742: PUSH
17743: LD_INT 40
17745: PUSH
17746: LD_INT 50
17748: PUSH
17749: LD_INT 60
17751: PUSH
17752: LD_INT 70
17754: PUSH
17755: LD_INT 80
17757: PUSH
17758: LD_INT 90
17760: PUSH
17761: LD_INT 100
17763: PUSH
17764: LD_INT 110
17766: PUSH
17767: LD_INT 120
17769: PUSH
17770: LD_INT 130
17772: PUSH
17773: LD_INT 140
17775: PUSH
17776: LD_INT 150
17778: PUSH
17779: EMPTY
17780: LIST
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: PUSH
17796: LD_INT 1
17798: PPUSH
17799: LD_INT 15
17801: PPUSH
17802: CALL_OW 12
17806: ARRAY
17807: ST_TO_ADDR
// if ValidHex ( x , y ) then
17808: LD_VAR 0 3
17812: PPUSH
17813: LD_VAR 0 4
17817: PPUSH
17818: CALL_OW 488
17822: IFFALSE 17845
// begin result := [ x , y ] ;
17824: LD_ADDR_VAR 0 1
17828: PUSH
17829: LD_VAR 0 3
17833: PUSH
17834: LD_VAR 0 4
17838: PUSH
17839: EMPTY
17840: LIST
17841: LIST
17842: ST_TO_ADDR
// break ;
17843: GO 17847
// end ; end ;
17845: GO 17647
17847: POP
17848: POP
// if result then
17849: LD_VAR 0 1
17853: IFFALSE 17913
// begin ToLua ( playSibBomb() ) ;
17855: LD_STRING playSibBomb()
17857: PPUSH
17858: CALL_OW 559
// wait ( 0 0$14 ) ;
17862: LD_INT 490
17864: PPUSH
17865: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
17869: LD_VAR 0 1
17873: PUSH
17874: LD_INT 1
17876: ARRAY
17877: PPUSH
17878: LD_VAR 0 1
17882: PUSH
17883: LD_INT 2
17885: ARRAY
17886: PPUSH
17887: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
17891: LD_VAR 0 1
17895: PUSH
17896: LD_INT 1
17898: ARRAY
17899: PPUSH
17900: LD_VAR 0 1
17904: PUSH
17905: LD_INT 2
17907: ARRAY
17908: PPUSH
17909: CALL_OW 429
// end ; end ;
17913: LD_VAR 0 1
17917: RET
// every 0 0$1 trigger StreamModeActive and sReset do
17918: LD_EXP 43
17922: PUSH
17923: LD_EXP 65
17927: AND
17928: IFFALSE 17940
17930: GO 17932
17932: DISABLE
// YouLost (  ) ;
17933: LD_STRING 
17935: PPUSH
17936: CALL_OW 104
17940: END
// every 0 0$1 trigger StreamModeActive and sFog do
17941: LD_EXP 43
17945: PUSH
17946: LD_EXP 64
17950: AND
17951: IFFALSE 17965
17953: GO 17955
17955: DISABLE
// FogOff ( your_side ) ;
17956: LD_OWVAR 2
17960: PPUSH
17961: CALL_OW 344
17965: END
// every 0 0$1 trigger StreamModeActive and sSun do
17966: LD_EXP 43
17970: PUSH
17971: LD_EXP 66
17975: AND
17976: IFFALSE 18004
17978: GO 17980
17980: DISABLE
// begin solar_recharge_percent := 0 ;
17981: LD_ADDR_OWVAR 79
17985: PUSH
17986: LD_INT 0
17988: ST_TO_ADDR
// wait ( 5 5$00 ) ;
17989: LD_INT 10500
17991: PPUSH
17992: CALL_OW 67
// solar_recharge_percent := 100 ;
17996: LD_ADDR_OWVAR 79
18000: PUSH
18001: LD_INT 100
18003: ST_TO_ADDR
// end ;
18004: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
18005: LD_EXP 43
18009: PUSH
18010: LD_EXP 67
18014: AND
18015: IFFALSE 18254
18017: GO 18019
18019: DISABLE
18020: LD_INT 0
18022: PPUSH
18023: PPUSH
18024: PPUSH
// begin tmp := [ ] ;
18025: LD_ADDR_VAR 0 3
18029: PUSH
18030: EMPTY
18031: ST_TO_ADDR
// for i := 1 to 6 do
18032: LD_ADDR_VAR 0 1
18036: PUSH
18037: DOUBLE
18038: LD_INT 1
18040: DEC
18041: ST_TO_ADDR
18042: LD_INT 6
18044: PUSH
18045: FOR_TO
18046: IFFALSE 18151
// begin uc_nation := nation_nature ;
18048: LD_ADDR_OWVAR 21
18052: PUSH
18053: LD_INT 0
18055: ST_TO_ADDR
// uc_side := 0 ;
18056: LD_ADDR_OWVAR 20
18060: PUSH
18061: LD_INT 0
18063: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18064: LD_ADDR_OWVAR 29
18068: PUSH
18069: LD_INT 12
18071: PUSH
18072: LD_INT 12
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: ST_TO_ADDR
// hc_agressivity := 20 ;
18079: LD_ADDR_OWVAR 35
18083: PUSH
18084: LD_INT 20
18086: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
18087: LD_ADDR_OWVAR 28
18091: PUSH
18092: LD_INT 17
18094: ST_TO_ADDR
// hc_gallery :=  ;
18095: LD_ADDR_OWVAR 33
18099: PUSH
18100: LD_STRING 
18102: ST_TO_ADDR
// hc_name :=  ;
18103: LD_ADDR_OWVAR 26
18107: PUSH
18108: LD_STRING 
18110: ST_TO_ADDR
// un := CreateHuman ;
18111: LD_ADDR_VAR 0 2
18115: PUSH
18116: CALL_OW 44
18120: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
18121: LD_VAR 0 2
18125: PPUSH
18126: LD_INT 1
18128: PPUSH
18129: CALL_OW 51
// tmp := tmp ^ un ;
18133: LD_ADDR_VAR 0 3
18137: PUSH
18138: LD_VAR 0 3
18142: PUSH
18143: LD_VAR 0 2
18147: ADD
18148: ST_TO_ADDR
// end ;
18149: GO 18045
18151: POP
18152: POP
// repeat wait ( 0 0$1 ) ;
18153: LD_INT 35
18155: PPUSH
18156: CALL_OW 67
// for un in tmp do
18160: LD_ADDR_VAR 0 2
18164: PUSH
18165: LD_VAR 0 3
18169: PUSH
18170: FOR_IN
18171: IFFALSE 18245
// begin if IsDead ( un ) then
18173: LD_VAR 0 2
18177: PPUSH
18178: CALL_OW 301
18182: IFFALSE 18202
// begin tmp := tmp diff un ;
18184: LD_ADDR_VAR 0 3
18188: PUSH
18189: LD_VAR 0 3
18193: PUSH
18194: LD_VAR 0 2
18198: DIFF
18199: ST_TO_ADDR
// continue ;
18200: GO 18170
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18202: LD_VAR 0 2
18206: PPUSH
18207: LD_INT 3
18209: PUSH
18210: LD_INT 22
18212: PUSH
18213: LD_INT 0
18215: PUSH
18216: EMPTY
18217: LIST
18218: LIST
18219: PUSH
18220: EMPTY
18221: LIST
18222: LIST
18223: PPUSH
18224: CALL_OW 69
18228: PPUSH
18229: LD_VAR 0 2
18233: PPUSH
18234: CALL_OW 74
18238: PPUSH
18239: CALL_OW 115
// end ;
18243: GO 18170
18245: POP
18246: POP
// until not tmp ;
18247: LD_VAR 0 3
18251: NOT
18252: IFFALSE 18153
// end ;
18254: PPOPN 3
18256: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18257: LD_EXP 43
18261: PUSH
18262: LD_EXP 68
18266: AND
18267: IFFALSE 18321
18269: GO 18271
18271: DISABLE
// begin ToLua ( displayTroll(); ) ;
18272: LD_STRING displayTroll();
18274: PPUSH
18275: CALL_OW 559
// wait ( 3 3$00 ) ;
18279: LD_INT 6300
18281: PPUSH
18282: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18286: LD_STRING hideTroll();
18288: PPUSH
18289: CALL_OW 559
// wait ( 1 1$00 ) ;
18293: LD_INT 2100
18295: PPUSH
18296: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18300: LD_STRING displayTroll();
18302: PPUSH
18303: CALL_OW 559
// wait ( 1 1$00 ) ;
18307: LD_INT 2100
18309: PPUSH
18310: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18314: LD_STRING hideTroll();
18316: PPUSH
18317: CALL_OW 559
// end ;
18321: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18322: LD_EXP 43
18326: PUSH
18327: LD_EXP 69
18331: AND
18332: IFFALSE 18395
18334: GO 18336
18336: DISABLE
18337: LD_INT 0
18339: PPUSH
// begin p := 0 ;
18340: LD_ADDR_VAR 0 1
18344: PUSH
18345: LD_INT 0
18347: ST_TO_ADDR
// repeat game_speed := 1 ;
18348: LD_ADDR_OWVAR 65
18352: PUSH
18353: LD_INT 1
18355: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18356: LD_INT 35
18358: PPUSH
18359: CALL_OW 67
// p := p + 1 ;
18363: LD_ADDR_VAR 0 1
18367: PUSH
18368: LD_VAR 0 1
18372: PUSH
18373: LD_INT 1
18375: PLUS
18376: ST_TO_ADDR
// until p >= 60 ;
18377: LD_VAR 0 1
18381: PUSH
18382: LD_INT 60
18384: GREATEREQUAL
18385: IFFALSE 18348
// game_speed := 4 ;
18387: LD_ADDR_OWVAR 65
18391: PUSH
18392: LD_INT 4
18394: ST_TO_ADDR
// end ;
18395: PPOPN 1
18397: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
18398: LD_EXP 43
18402: PUSH
18403: LD_EXP 70
18407: AND
18408: IFFALSE 18554
18410: GO 18412
18412: DISABLE
18413: LD_INT 0
18415: PPUSH
18416: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18417: LD_ADDR_VAR 0 1
18421: PUSH
18422: LD_INT 22
18424: PUSH
18425: LD_OWVAR 2
18429: PUSH
18430: EMPTY
18431: LIST
18432: LIST
18433: PUSH
18434: LD_INT 2
18436: PUSH
18437: LD_INT 30
18439: PUSH
18440: LD_INT 0
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 30
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: LIST
18461: PUSH
18462: EMPTY
18463: LIST
18464: LIST
18465: PPUSH
18466: CALL_OW 69
18470: ST_TO_ADDR
// if not depot then
18471: LD_VAR 0 1
18475: NOT
18476: IFFALSE 18480
// exit ;
18478: GO 18554
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18480: LD_ADDR_VAR 0 2
18484: PUSH
18485: LD_VAR 0 1
18489: PUSH
18490: LD_INT 1
18492: PPUSH
18493: LD_VAR 0 1
18497: PPUSH
18498: CALL_OW 12
18502: ARRAY
18503: PPUSH
18504: CALL_OW 274
18508: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18509: LD_VAR 0 2
18513: PPUSH
18514: LD_INT 1
18516: PPUSH
18517: LD_INT 0
18519: PPUSH
18520: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18524: LD_VAR 0 2
18528: PPUSH
18529: LD_INT 2
18531: PPUSH
18532: LD_INT 0
18534: PPUSH
18535: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18539: LD_VAR 0 2
18543: PPUSH
18544: LD_INT 3
18546: PPUSH
18547: LD_INT 0
18549: PPUSH
18550: CALL_OW 277
// end ;
18554: PPOPN 2
18556: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18557: LD_EXP 43
18561: PUSH
18562: LD_EXP 71
18566: AND
18567: IFFALSE 18664
18569: GO 18571
18571: DISABLE
18572: LD_INT 0
18574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18575: LD_ADDR_VAR 0 1
18579: PUSH
18580: LD_INT 22
18582: PUSH
18583: LD_OWVAR 2
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PUSH
18592: LD_INT 21
18594: PUSH
18595: LD_INT 1
18597: PUSH
18598: EMPTY
18599: LIST
18600: LIST
18601: PUSH
18602: LD_INT 3
18604: PUSH
18605: LD_INT 23
18607: PUSH
18608: LD_INT 0
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PUSH
18615: EMPTY
18616: LIST
18617: LIST
18618: PUSH
18619: EMPTY
18620: LIST
18621: LIST
18622: LIST
18623: PPUSH
18624: CALL_OW 69
18628: ST_TO_ADDR
// if not tmp then
18629: LD_VAR 0 1
18633: NOT
18634: IFFALSE 18638
// exit ;
18636: GO 18664
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18638: LD_VAR 0 1
18642: PUSH
18643: LD_INT 1
18645: PPUSH
18646: LD_VAR 0 1
18650: PPUSH
18651: CALL_OW 12
18655: ARRAY
18656: PPUSH
18657: LD_INT 200
18659: PPUSH
18660: CALL_OW 234
// end ;
18664: PPOPN 1
18666: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
18667: LD_EXP 43
18671: PUSH
18672: LD_EXP 72
18676: AND
18677: IFFALSE 18756
18679: GO 18681
18681: DISABLE
18682: LD_INT 0
18684: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
18685: LD_ADDR_VAR 0 1
18689: PUSH
18690: LD_INT 22
18692: PUSH
18693: LD_OWVAR 2
18697: PUSH
18698: EMPTY
18699: LIST
18700: LIST
18701: PUSH
18702: LD_INT 21
18704: PUSH
18705: LD_INT 2
18707: PUSH
18708: EMPTY
18709: LIST
18710: LIST
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: PPUSH
18716: CALL_OW 69
18720: ST_TO_ADDR
// if not tmp then
18721: LD_VAR 0 1
18725: NOT
18726: IFFALSE 18730
// exit ;
18728: GO 18756
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
18730: LD_VAR 0 1
18734: PUSH
18735: LD_INT 1
18737: PPUSH
18738: LD_VAR 0 1
18742: PPUSH
18743: CALL_OW 12
18747: ARRAY
18748: PPUSH
18749: LD_INT 60
18751: PPUSH
18752: CALL_OW 234
// end ;
18756: PPOPN 1
18758: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
18759: LD_EXP 43
18763: PUSH
18764: LD_EXP 73
18768: AND
18769: IFFALSE 18868
18771: GO 18773
18773: DISABLE
18774: LD_INT 0
18776: PPUSH
18777: PPUSH
// begin enable ;
18778: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
18779: LD_ADDR_VAR 0 1
18783: PUSH
18784: LD_INT 22
18786: PUSH
18787: LD_OWVAR 2
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: PUSH
18796: LD_INT 61
18798: PUSH
18799: EMPTY
18800: LIST
18801: PUSH
18802: LD_INT 33
18804: PUSH
18805: LD_INT 2
18807: PUSH
18808: EMPTY
18809: LIST
18810: LIST
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: LIST
18816: PPUSH
18817: CALL_OW 69
18821: ST_TO_ADDR
// if not tmp then
18822: LD_VAR 0 1
18826: NOT
18827: IFFALSE 18831
// exit ;
18829: GO 18868
// for i in tmp do
18831: LD_ADDR_VAR 0 2
18835: PUSH
18836: LD_VAR 0 1
18840: PUSH
18841: FOR_IN
18842: IFFALSE 18866
// if IsControledBy ( i ) then
18844: LD_VAR 0 2
18848: PPUSH
18849: CALL_OW 312
18853: IFFALSE 18864
// ComUnlink ( i ) ;
18855: LD_VAR 0 2
18859: PPUSH
18860: CALL_OW 136
18864: GO 18841
18866: POP
18867: POP
// end ;
18868: PPOPN 2
18870: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
18871: LD_EXP 43
18875: PUSH
18876: LD_EXP 74
18880: AND
18881: IFFALSE 19021
18883: GO 18885
18885: DISABLE
18886: LD_INT 0
18888: PPUSH
18889: PPUSH
// begin ToLua ( displayPowell(); ) ;
18890: LD_STRING displayPowell();
18892: PPUSH
18893: CALL_OW 559
// uc_side := 0 ;
18897: LD_ADDR_OWVAR 20
18901: PUSH
18902: LD_INT 0
18904: ST_TO_ADDR
// uc_nation := 2 ;
18905: LD_ADDR_OWVAR 21
18909: PUSH
18910: LD_INT 2
18912: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
18913: LD_ADDR_OWVAR 37
18917: PUSH
18918: LD_INT 14
18920: ST_TO_ADDR
// vc_engine := engine_siberite ;
18921: LD_ADDR_OWVAR 39
18925: PUSH
18926: LD_INT 3
18928: ST_TO_ADDR
// vc_control := control_apeman ;
18929: LD_ADDR_OWVAR 38
18933: PUSH
18934: LD_INT 5
18936: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
18937: LD_ADDR_OWVAR 40
18941: PUSH
18942: LD_INT 29
18944: ST_TO_ADDR
// un := CreateVehicle ;
18945: LD_ADDR_VAR 0 2
18949: PUSH
18950: CALL_OW 45
18954: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18955: LD_VAR 0 2
18959: PPUSH
18960: LD_INT 1
18962: PPUSH
18963: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18967: LD_INT 35
18969: PPUSH
18970: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18974: LD_VAR 0 2
18978: PPUSH
18979: LD_INT 22
18981: PUSH
18982: LD_OWVAR 2
18986: PUSH
18987: EMPTY
18988: LIST
18989: LIST
18990: PPUSH
18991: CALL_OW 69
18995: PPUSH
18996: LD_VAR 0 2
19000: PPUSH
19001: CALL_OW 74
19005: PPUSH
19006: CALL_OW 115
// until IsDead ( un ) ;
19010: LD_VAR 0 2
19014: PPUSH
19015: CALL_OW 301
19019: IFFALSE 18967
// end ;
19021: PPOPN 2
19023: END
// every 0 0$1 trigger StreamModeActive and sStu do
19024: LD_EXP 43
19028: PUSH
19029: LD_EXP 82
19033: AND
19034: IFFALSE 19050
19036: GO 19038
19038: DISABLE
// begin ToLua ( displayStucuk(); ) ;
19039: LD_STRING displayStucuk();
19041: PPUSH
19042: CALL_OW 559
// ResetFog ;
19046: CALL_OW 335
// end ;
19050: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
19051: LD_EXP 43
19055: PUSH
19056: LD_EXP 75
19060: AND
19061: IFFALSE 19202
19063: GO 19065
19065: DISABLE
19066: LD_INT 0
19068: PPUSH
19069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19070: LD_ADDR_VAR 0 2
19074: PUSH
19075: LD_INT 22
19077: PUSH
19078: LD_OWVAR 2
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: PUSH
19087: LD_INT 21
19089: PUSH
19090: LD_INT 1
19092: PUSH
19093: EMPTY
19094: LIST
19095: LIST
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: PPUSH
19101: CALL_OW 69
19105: ST_TO_ADDR
// if not tmp then
19106: LD_VAR 0 2
19110: NOT
19111: IFFALSE 19115
// exit ;
19113: GO 19202
// un := tmp [ rand ( 1 , tmp ) ] ;
19115: LD_ADDR_VAR 0 1
19119: PUSH
19120: LD_VAR 0 2
19124: PUSH
19125: LD_INT 1
19127: PPUSH
19128: LD_VAR 0 2
19132: PPUSH
19133: CALL_OW 12
19137: ARRAY
19138: ST_TO_ADDR
// SetSide ( un , 0 ) ;
19139: LD_VAR 0 1
19143: PPUSH
19144: LD_INT 0
19146: PPUSH
19147: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
19151: LD_VAR 0 1
19155: PPUSH
19156: LD_OWVAR 3
19160: PUSH
19161: LD_VAR 0 1
19165: DIFF
19166: PPUSH
19167: LD_VAR 0 1
19171: PPUSH
19172: CALL_OW 74
19176: PPUSH
19177: CALL_OW 115
// wait ( 0 0$20 ) ;
19181: LD_INT 700
19183: PPUSH
19184: CALL_OW 67
// SetSide ( un , your_side ) ;
19188: LD_VAR 0 1
19192: PPUSH
19193: LD_OWVAR 2
19197: PPUSH
19198: CALL_OW 235
// end ;
19202: PPOPN 2
19204: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19205: LD_EXP 43
19209: PUSH
19210: LD_EXP 76
19214: AND
19215: IFFALSE 19321
19217: GO 19219
19219: DISABLE
19220: LD_INT 0
19222: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19223: LD_ADDR_VAR 0 1
19227: PUSH
19228: LD_INT 22
19230: PUSH
19231: LD_OWVAR 2
19235: PUSH
19236: EMPTY
19237: LIST
19238: LIST
19239: PUSH
19240: LD_INT 2
19242: PUSH
19243: LD_INT 30
19245: PUSH
19246: LD_INT 0
19248: PUSH
19249: EMPTY
19250: LIST
19251: LIST
19252: PUSH
19253: LD_INT 30
19255: PUSH
19256: LD_INT 1
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: PUSH
19263: EMPTY
19264: LIST
19265: LIST
19266: LIST
19267: PUSH
19268: EMPTY
19269: LIST
19270: LIST
19271: PPUSH
19272: CALL_OW 69
19276: ST_TO_ADDR
// if not depot then
19277: LD_VAR 0 1
19281: NOT
19282: IFFALSE 19286
// exit ;
19284: GO 19321
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19286: LD_VAR 0 1
19290: PUSH
19291: LD_INT 1
19293: ARRAY
19294: PPUSH
19295: CALL_OW 250
19299: PPUSH
19300: LD_VAR 0 1
19304: PUSH
19305: LD_INT 1
19307: ARRAY
19308: PPUSH
19309: CALL_OW 251
19313: PPUSH
19314: LD_INT 70
19316: PPUSH
19317: CALL_OW 495
// end ;
19321: PPOPN 1
19323: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19324: LD_EXP 43
19328: PUSH
19329: LD_EXP 77
19333: AND
19334: IFFALSE 19545
19336: GO 19338
19338: DISABLE
19339: LD_INT 0
19341: PPUSH
19342: PPUSH
19343: PPUSH
19344: PPUSH
19345: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19346: LD_ADDR_VAR 0 5
19350: PUSH
19351: LD_INT 22
19353: PUSH
19354: LD_OWVAR 2
19358: PUSH
19359: EMPTY
19360: LIST
19361: LIST
19362: PUSH
19363: LD_INT 21
19365: PUSH
19366: LD_INT 1
19368: PUSH
19369: EMPTY
19370: LIST
19371: LIST
19372: PUSH
19373: EMPTY
19374: LIST
19375: LIST
19376: PPUSH
19377: CALL_OW 69
19381: ST_TO_ADDR
// if not tmp then
19382: LD_VAR 0 5
19386: NOT
19387: IFFALSE 19391
// exit ;
19389: GO 19545
// for i in tmp do
19391: LD_ADDR_VAR 0 1
19395: PUSH
19396: LD_VAR 0 5
19400: PUSH
19401: FOR_IN
19402: IFFALSE 19543
// begin d := rand ( 0 , 5 ) ;
19404: LD_ADDR_VAR 0 4
19408: PUSH
19409: LD_INT 0
19411: PPUSH
19412: LD_INT 5
19414: PPUSH
19415: CALL_OW 12
19419: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19420: LD_ADDR_VAR 0 2
19424: PUSH
19425: LD_VAR 0 1
19429: PPUSH
19430: CALL_OW 250
19434: PPUSH
19435: LD_VAR 0 4
19439: PPUSH
19440: LD_INT 3
19442: PPUSH
19443: LD_INT 12
19445: PPUSH
19446: CALL_OW 12
19450: PPUSH
19451: CALL_OW 272
19455: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19456: LD_ADDR_VAR 0 3
19460: PUSH
19461: LD_VAR 0 1
19465: PPUSH
19466: CALL_OW 251
19470: PPUSH
19471: LD_VAR 0 4
19475: PPUSH
19476: LD_INT 3
19478: PPUSH
19479: LD_INT 12
19481: PPUSH
19482: CALL_OW 12
19486: PPUSH
19487: CALL_OW 273
19491: ST_TO_ADDR
// if ValidHex ( x , y ) then
19492: LD_VAR 0 2
19496: PPUSH
19497: LD_VAR 0 3
19501: PPUSH
19502: CALL_OW 488
19506: IFFALSE 19541
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19508: LD_VAR 0 1
19512: PPUSH
19513: LD_VAR 0 2
19517: PPUSH
19518: LD_VAR 0 3
19522: PPUSH
19523: LD_INT 3
19525: PPUSH
19526: LD_INT 6
19528: PPUSH
19529: CALL_OW 12
19533: PPUSH
19534: LD_INT 1
19536: PPUSH
19537: CALL_OW 483
// end ;
19541: GO 19401
19543: POP
19544: POP
// end ;
19545: PPOPN 5
19547: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19548: LD_EXP 43
19552: PUSH
19553: LD_EXP 78
19557: AND
19558: IFFALSE 19652
19560: GO 19562
19562: DISABLE
19563: LD_INT 0
19565: PPUSH
19566: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19567: LD_ADDR_VAR 0 2
19571: PUSH
19572: LD_INT 22
19574: PUSH
19575: LD_OWVAR 2
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: PUSH
19584: LD_INT 32
19586: PUSH
19587: LD_INT 1
19589: PUSH
19590: EMPTY
19591: LIST
19592: LIST
19593: PUSH
19594: LD_INT 21
19596: PUSH
19597: LD_INT 2
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: LIST
19608: PPUSH
19609: CALL_OW 69
19613: ST_TO_ADDR
// if not tmp then
19614: LD_VAR 0 2
19618: NOT
19619: IFFALSE 19623
// exit ;
19621: GO 19652
// for i in tmp do
19623: LD_ADDR_VAR 0 1
19627: PUSH
19628: LD_VAR 0 2
19632: PUSH
19633: FOR_IN
19634: IFFALSE 19650
// SetFuel ( i , 0 ) ;
19636: LD_VAR 0 1
19640: PPUSH
19641: LD_INT 0
19643: PPUSH
19644: CALL_OW 240
19648: GO 19633
19650: POP
19651: POP
// end ;
19652: PPOPN 2
19654: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19655: LD_EXP 43
19659: PUSH
19660: LD_EXP 79
19664: AND
19665: IFFALSE 19731
19667: GO 19669
19669: DISABLE
19670: LD_INT 0
19672: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19673: LD_ADDR_VAR 0 1
19677: PUSH
19678: LD_INT 22
19680: PUSH
19681: LD_OWVAR 2
19685: PUSH
19686: EMPTY
19687: LIST
19688: LIST
19689: PUSH
19690: LD_INT 30
19692: PUSH
19693: LD_INT 29
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PUSH
19700: EMPTY
19701: LIST
19702: LIST
19703: PPUSH
19704: CALL_OW 69
19708: ST_TO_ADDR
// if not tmp then
19709: LD_VAR 0 1
19713: NOT
19714: IFFALSE 19718
// exit ;
19716: GO 19731
// DestroyUnit ( tmp [ 1 ] ) ;
19718: LD_VAR 0 1
19722: PUSH
19723: LD_INT 1
19725: ARRAY
19726: PPUSH
19727: CALL_OW 65
// end ;
19731: PPOPN 1
19733: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
19734: LD_EXP 43
19738: PUSH
19739: LD_EXP 81
19743: AND
19744: IFFALSE 19873
19746: GO 19748
19748: DISABLE
19749: LD_INT 0
19751: PPUSH
// begin uc_side := 0 ;
19752: LD_ADDR_OWVAR 20
19756: PUSH
19757: LD_INT 0
19759: ST_TO_ADDR
// uc_nation := nation_arabian ;
19760: LD_ADDR_OWVAR 21
19764: PUSH
19765: LD_INT 2
19767: ST_TO_ADDR
// hc_gallery :=  ;
19768: LD_ADDR_OWVAR 33
19772: PUSH
19773: LD_STRING 
19775: ST_TO_ADDR
// hc_name :=  ;
19776: LD_ADDR_OWVAR 26
19780: PUSH
19781: LD_STRING 
19783: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
19784: LD_INT 1
19786: PPUSH
19787: LD_INT 11
19789: PPUSH
19790: LD_INT 10
19792: PPUSH
19793: CALL_OW 380
// un := CreateHuman ;
19797: LD_ADDR_VAR 0 1
19801: PUSH
19802: CALL_OW 44
19806: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19807: LD_VAR 0 1
19811: PPUSH
19812: LD_INT 1
19814: PPUSH
19815: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19819: LD_INT 35
19821: PPUSH
19822: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19826: LD_VAR 0 1
19830: PPUSH
19831: LD_INT 22
19833: PUSH
19834: LD_OWVAR 2
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: PPUSH
19843: CALL_OW 69
19847: PPUSH
19848: LD_VAR 0 1
19852: PPUSH
19853: CALL_OW 74
19857: PPUSH
19858: CALL_OW 115
// until IsDead ( un ) ;
19862: LD_VAR 0 1
19866: PPUSH
19867: CALL_OW 301
19871: IFFALSE 19819
// end ;
19873: PPOPN 1
19875: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
19876: LD_EXP 43
19880: PUSH
19881: LD_EXP 83
19885: AND
19886: IFFALSE 19898
19888: GO 19890
19890: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
19891: LD_STRING earthquake(getX(game), 0, 32)
19893: PPUSH
19894: CALL_OW 559
19898: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
19899: LD_EXP 43
19903: PUSH
19904: LD_EXP 84
19908: AND
19909: IFFALSE 20000
19911: GO 19913
19913: DISABLE
19914: LD_INT 0
19916: PPUSH
// begin enable ;
19917: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
19918: LD_ADDR_VAR 0 1
19922: PUSH
19923: LD_INT 22
19925: PUSH
19926: LD_OWVAR 2
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: PUSH
19935: LD_INT 21
19937: PUSH
19938: LD_INT 2
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: PUSH
19945: LD_INT 33
19947: PUSH
19948: LD_INT 3
19950: PUSH
19951: EMPTY
19952: LIST
19953: LIST
19954: PUSH
19955: EMPTY
19956: LIST
19957: LIST
19958: LIST
19959: PPUSH
19960: CALL_OW 69
19964: ST_TO_ADDR
// if not tmp then
19965: LD_VAR 0 1
19969: NOT
19970: IFFALSE 19974
// exit ;
19972: GO 20000
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19974: LD_VAR 0 1
19978: PUSH
19979: LD_INT 1
19981: PPUSH
19982: LD_VAR 0 1
19986: PPUSH
19987: CALL_OW 12
19991: ARRAY
19992: PPUSH
19993: LD_INT 1
19995: PPUSH
19996: CALL_OW 234
// end ;
20000: PPOPN 1
20002: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
20003: LD_EXP 43
20007: PUSH
20008: LD_EXP 85
20012: AND
20013: IFFALSE 20154
20015: GO 20017
20017: DISABLE
20018: LD_INT 0
20020: PPUSH
20021: PPUSH
20022: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20023: LD_ADDR_VAR 0 3
20027: PUSH
20028: LD_INT 22
20030: PUSH
20031: LD_OWVAR 2
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: PUSH
20040: LD_INT 25
20042: PUSH
20043: LD_INT 1
20045: PUSH
20046: EMPTY
20047: LIST
20048: LIST
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: PPUSH
20054: CALL_OW 69
20058: ST_TO_ADDR
// if not tmp then
20059: LD_VAR 0 3
20063: NOT
20064: IFFALSE 20068
// exit ;
20066: GO 20154
// un := tmp [ rand ( 1 , tmp ) ] ;
20068: LD_ADDR_VAR 0 2
20072: PUSH
20073: LD_VAR 0 3
20077: PUSH
20078: LD_INT 1
20080: PPUSH
20081: LD_VAR 0 3
20085: PPUSH
20086: CALL_OW 12
20090: ARRAY
20091: ST_TO_ADDR
// if Crawls ( un ) then
20092: LD_VAR 0 2
20096: PPUSH
20097: CALL_OW 318
20101: IFFALSE 20112
// ComWalk ( un ) ;
20103: LD_VAR 0 2
20107: PPUSH
20108: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
20112: LD_VAR 0 2
20116: PPUSH
20117: LD_INT 9
20119: PPUSH
20120: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
20124: LD_INT 28
20126: PPUSH
20127: LD_OWVAR 2
20131: PPUSH
20132: LD_INT 2
20134: PPUSH
20135: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
20139: LD_INT 29
20141: PPUSH
20142: LD_OWVAR 2
20146: PPUSH
20147: LD_INT 2
20149: PPUSH
20150: CALL_OW 322
// end ;
20154: PPOPN 3
20156: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
20157: LD_EXP 43
20161: PUSH
20162: LD_EXP 86
20166: AND
20167: IFFALSE 20278
20169: GO 20171
20171: DISABLE
20172: LD_INT 0
20174: PPUSH
20175: PPUSH
20176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20177: LD_ADDR_VAR 0 3
20181: PUSH
20182: LD_INT 22
20184: PUSH
20185: LD_OWVAR 2
20189: PUSH
20190: EMPTY
20191: LIST
20192: LIST
20193: PUSH
20194: LD_INT 25
20196: PUSH
20197: LD_INT 1
20199: PUSH
20200: EMPTY
20201: LIST
20202: LIST
20203: PUSH
20204: EMPTY
20205: LIST
20206: LIST
20207: PPUSH
20208: CALL_OW 69
20212: ST_TO_ADDR
// if not tmp then
20213: LD_VAR 0 3
20217: NOT
20218: IFFALSE 20222
// exit ;
20220: GO 20278
// un := tmp [ rand ( 1 , tmp ) ] ;
20222: LD_ADDR_VAR 0 2
20226: PUSH
20227: LD_VAR 0 3
20231: PUSH
20232: LD_INT 1
20234: PPUSH
20235: LD_VAR 0 3
20239: PPUSH
20240: CALL_OW 12
20244: ARRAY
20245: ST_TO_ADDR
// if Crawls ( un ) then
20246: LD_VAR 0 2
20250: PPUSH
20251: CALL_OW 318
20255: IFFALSE 20266
// ComWalk ( un ) ;
20257: LD_VAR 0 2
20261: PPUSH
20262: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20266: LD_VAR 0 2
20270: PPUSH
20271: LD_INT 8
20273: PPUSH
20274: CALL_OW 336
// end ;
20278: PPOPN 3
20280: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20281: LD_EXP 43
20285: PUSH
20286: LD_EXP 87
20290: AND
20291: IFFALSE 20435
20293: GO 20295
20295: DISABLE
20296: LD_INT 0
20298: PPUSH
20299: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20300: LD_ADDR_VAR 0 2
20304: PUSH
20305: LD_INT 22
20307: PUSH
20308: LD_OWVAR 2
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: PUSH
20317: LD_INT 21
20319: PUSH
20320: LD_INT 2
20322: PUSH
20323: EMPTY
20324: LIST
20325: LIST
20326: PUSH
20327: LD_INT 2
20329: PUSH
20330: LD_INT 34
20332: PUSH
20333: LD_INT 12
20335: PUSH
20336: EMPTY
20337: LIST
20338: LIST
20339: PUSH
20340: LD_INT 34
20342: PUSH
20343: LD_INT 51
20345: PUSH
20346: EMPTY
20347: LIST
20348: LIST
20349: PUSH
20350: LD_INT 34
20352: PUSH
20353: LD_INT 32
20355: PUSH
20356: EMPTY
20357: LIST
20358: LIST
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: LIST
20364: LIST
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: LIST
20370: PPUSH
20371: CALL_OW 69
20375: ST_TO_ADDR
// if not tmp then
20376: LD_VAR 0 2
20380: NOT
20381: IFFALSE 20385
// exit ;
20383: GO 20435
// for i in tmp do
20385: LD_ADDR_VAR 0 1
20389: PUSH
20390: LD_VAR 0 2
20394: PUSH
20395: FOR_IN
20396: IFFALSE 20433
// if GetCargo ( i , mat_artifact ) = 0 then
20398: LD_VAR 0 1
20402: PPUSH
20403: LD_INT 4
20405: PPUSH
20406: CALL_OW 289
20410: PUSH
20411: LD_INT 0
20413: EQUAL
20414: IFFALSE 20431
// SetCargo ( i , mat_siberit , 100 ) ;
20416: LD_VAR 0 1
20420: PPUSH
20421: LD_INT 3
20423: PPUSH
20424: LD_INT 100
20426: PPUSH
20427: CALL_OW 290
20431: GO 20395
20433: POP
20434: POP
// end ;
20435: PPOPN 2
20437: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20438: LD_EXP 43
20442: PUSH
20443: LD_EXP 88
20447: AND
20448: IFFALSE 20601
20450: GO 20452
20452: DISABLE
20453: LD_INT 0
20455: PPUSH
20456: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20457: LD_ADDR_VAR 0 2
20461: PUSH
20462: LD_INT 22
20464: PUSH
20465: LD_OWVAR 2
20469: PUSH
20470: EMPTY
20471: LIST
20472: LIST
20473: PPUSH
20474: CALL_OW 69
20478: ST_TO_ADDR
// if not tmp then
20479: LD_VAR 0 2
20483: NOT
20484: IFFALSE 20488
// exit ;
20486: GO 20601
// for i := 1 to 2 do
20488: LD_ADDR_VAR 0 1
20492: PUSH
20493: DOUBLE
20494: LD_INT 1
20496: DEC
20497: ST_TO_ADDR
20498: LD_INT 2
20500: PUSH
20501: FOR_TO
20502: IFFALSE 20599
// begin uc_side := your_side ;
20504: LD_ADDR_OWVAR 20
20508: PUSH
20509: LD_OWVAR 2
20513: ST_TO_ADDR
// uc_nation := nation_american ;
20514: LD_ADDR_OWVAR 21
20518: PUSH
20519: LD_INT 1
20521: ST_TO_ADDR
// vc_chassis := us_morphling ;
20522: LD_ADDR_OWVAR 37
20526: PUSH
20527: LD_INT 5
20529: ST_TO_ADDR
// vc_engine := engine_siberite ;
20530: LD_ADDR_OWVAR 39
20534: PUSH
20535: LD_INT 3
20537: ST_TO_ADDR
// vc_control := control_computer ;
20538: LD_ADDR_OWVAR 38
20542: PUSH
20543: LD_INT 3
20545: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20546: LD_ADDR_OWVAR 40
20550: PUSH
20551: LD_INT 10
20553: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
20554: CALL_OW 45
20558: PPUSH
20559: LD_VAR 0 2
20563: PUSH
20564: LD_INT 1
20566: ARRAY
20567: PPUSH
20568: CALL_OW 250
20572: PPUSH
20573: LD_VAR 0 2
20577: PUSH
20578: LD_INT 1
20580: ARRAY
20581: PPUSH
20582: CALL_OW 251
20586: PPUSH
20587: LD_INT 12
20589: PPUSH
20590: LD_INT 1
20592: PPUSH
20593: CALL_OW 50
// end ;
20597: GO 20501
20599: POP
20600: POP
// end ;
20601: PPOPN 2
20603: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20604: LD_EXP 43
20608: PUSH
20609: LD_EXP 89
20613: AND
20614: IFFALSE 20836
20616: GO 20618
20618: DISABLE
20619: LD_INT 0
20621: PPUSH
20622: PPUSH
20623: PPUSH
20624: PPUSH
20625: PPUSH
20626: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20627: LD_ADDR_VAR 0 6
20631: PUSH
20632: LD_INT 22
20634: PUSH
20635: LD_OWVAR 2
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: PUSH
20644: LD_INT 21
20646: PUSH
20647: LD_INT 1
20649: PUSH
20650: EMPTY
20651: LIST
20652: LIST
20653: PUSH
20654: LD_INT 3
20656: PUSH
20657: LD_INT 23
20659: PUSH
20660: LD_INT 0
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: PUSH
20667: EMPTY
20668: LIST
20669: LIST
20670: PUSH
20671: EMPTY
20672: LIST
20673: LIST
20674: LIST
20675: PPUSH
20676: CALL_OW 69
20680: ST_TO_ADDR
// if not tmp then
20681: LD_VAR 0 6
20685: NOT
20686: IFFALSE 20690
// exit ;
20688: GO 20836
// s1 := rand ( 1 , 4 ) ;
20690: LD_ADDR_VAR 0 2
20694: PUSH
20695: LD_INT 1
20697: PPUSH
20698: LD_INT 4
20700: PPUSH
20701: CALL_OW 12
20705: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
20706: LD_ADDR_VAR 0 4
20710: PUSH
20711: LD_VAR 0 6
20715: PUSH
20716: LD_INT 1
20718: ARRAY
20719: PPUSH
20720: LD_VAR 0 2
20724: PPUSH
20725: CALL_OW 259
20729: ST_TO_ADDR
// if s1 = 1 then
20730: LD_VAR 0 2
20734: PUSH
20735: LD_INT 1
20737: EQUAL
20738: IFFALSE 20758
// s2 := rand ( 2 , 4 ) else
20740: LD_ADDR_VAR 0 3
20744: PUSH
20745: LD_INT 2
20747: PPUSH
20748: LD_INT 4
20750: PPUSH
20751: CALL_OW 12
20755: ST_TO_ADDR
20756: GO 20766
// s2 := 1 ;
20758: LD_ADDR_VAR 0 3
20762: PUSH
20763: LD_INT 1
20765: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
20766: LD_ADDR_VAR 0 5
20770: PUSH
20771: LD_VAR 0 6
20775: PUSH
20776: LD_INT 1
20778: ARRAY
20779: PPUSH
20780: LD_VAR 0 3
20784: PPUSH
20785: CALL_OW 259
20789: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
20790: LD_VAR 0 6
20794: PUSH
20795: LD_INT 1
20797: ARRAY
20798: PPUSH
20799: LD_VAR 0 2
20803: PPUSH
20804: LD_VAR 0 5
20808: PPUSH
20809: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
20813: LD_VAR 0 6
20817: PUSH
20818: LD_INT 1
20820: ARRAY
20821: PPUSH
20822: LD_VAR 0 3
20826: PPUSH
20827: LD_VAR 0 4
20831: PPUSH
20832: CALL_OW 237
// end ;
20836: PPOPN 6
20838: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
20839: LD_EXP 43
20843: PUSH
20844: LD_EXP 90
20848: AND
20849: IFFALSE 20928
20851: GO 20853
20853: DISABLE
20854: LD_INT 0
20856: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
20857: LD_ADDR_VAR 0 1
20861: PUSH
20862: LD_INT 22
20864: PUSH
20865: LD_OWVAR 2
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: PUSH
20874: LD_INT 30
20876: PUSH
20877: LD_INT 3
20879: PUSH
20880: EMPTY
20881: LIST
20882: LIST
20883: PUSH
20884: EMPTY
20885: LIST
20886: LIST
20887: PPUSH
20888: CALL_OW 69
20892: ST_TO_ADDR
// if not tmp then
20893: LD_VAR 0 1
20897: NOT
20898: IFFALSE 20902
// exit ;
20900: GO 20928
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20902: LD_VAR 0 1
20906: PUSH
20907: LD_INT 1
20909: PPUSH
20910: LD_VAR 0 1
20914: PPUSH
20915: CALL_OW 12
20919: ARRAY
20920: PPUSH
20921: LD_INT 1
20923: PPUSH
20924: CALL_OW 234
// end ;
20928: PPOPN 1
20930: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
20931: LD_EXP 43
20935: PUSH
20936: LD_EXP 91
20940: AND
20941: IFFALSE 21053
20943: GO 20945
20945: DISABLE
20946: LD_INT 0
20948: PPUSH
20949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
20950: LD_ADDR_VAR 0 2
20954: PUSH
20955: LD_INT 22
20957: PUSH
20958: LD_OWVAR 2
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: PUSH
20967: LD_INT 2
20969: PUSH
20970: LD_INT 30
20972: PUSH
20973: LD_INT 27
20975: PUSH
20976: EMPTY
20977: LIST
20978: LIST
20979: PUSH
20980: LD_INT 30
20982: PUSH
20983: LD_INT 26
20985: PUSH
20986: EMPTY
20987: LIST
20988: LIST
20989: PUSH
20990: LD_INT 30
20992: PUSH
20993: LD_INT 28
20995: PUSH
20996: EMPTY
20997: LIST
20998: LIST
20999: PUSH
21000: EMPTY
21001: LIST
21002: LIST
21003: LIST
21004: LIST
21005: PUSH
21006: EMPTY
21007: LIST
21008: LIST
21009: PPUSH
21010: CALL_OW 69
21014: ST_TO_ADDR
// if not tmp then
21015: LD_VAR 0 2
21019: NOT
21020: IFFALSE 21024
// exit ;
21022: GO 21053
// for i in tmp do
21024: LD_ADDR_VAR 0 1
21028: PUSH
21029: LD_VAR 0 2
21033: PUSH
21034: FOR_IN
21035: IFFALSE 21051
// SetLives ( i , 1 ) ;
21037: LD_VAR 0 1
21041: PPUSH
21042: LD_INT 1
21044: PPUSH
21045: CALL_OW 234
21049: GO 21034
21051: POP
21052: POP
// end ;
21053: PPOPN 2
21055: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
21056: LD_EXP 43
21060: PUSH
21061: LD_EXP 92
21065: AND
21066: IFFALSE 21340
21068: GO 21070
21070: DISABLE
21071: LD_INT 0
21073: PPUSH
21074: PPUSH
21075: PPUSH
// begin i := rand ( 1 , 7 ) ;
21076: LD_ADDR_VAR 0 1
21080: PUSH
21081: LD_INT 1
21083: PPUSH
21084: LD_INT 7
21086: PPUSH
21087: CALL_OW 12
21091: ST_TO_ADDR
// case i of 1 :
21092: LD_VAR 0 1
21096: PUSH
21097: LD_INT 1
21099: DOUBLE
21100: EQUAL
21101: IFTRUE 21105
21103: GO 21115
21105: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
21106: LD_STRING earthquake(getX(game), 0, 32)
21108: PPUSH
21109: CALL_OW 559
21113: GO 21340
21115: LD_INT 2
21117: DOUBLE
21118: EQUAL
21119: IFTRUE 21123
21121: GO 21137
21123: POP
// begin ToLua ( displayStucuk(); ) ;
21124: LD_STRING displayStucuk();
21126: PPUSH
21127: CALL_OW 559
// ResetFog ;
21131: CALL_OW 335
// end ; 3 :
21135: GO 21340
21137: LD_INT 3
21139: DOUBLE
21140: EQUAL
21141: IFTRUE 21145
21143: GO 21249
21145: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21146: LD_ADDR_VAR 0 2
21150: PUSH
21151: LD_INT 22
21153: PUSH
21154: LD_OWVAR 2
21158: PUSH
21159: EMPTY
21160: LIST
21161: LIST
21162: PUSH
21163: LD_INT 25
21165: PUSH
21166: LD_INT 1
21168: PUSH
21169: EMPTY
21170: LIST
21171: LIST
21172: PUSH
21173: EMPTY
21174: LIST
21175: LIST
21176: PPUSH
21177: CALL_OW 69
21181: ST_TO_ADDR
// if not tmp then
21182: LD_VAR 0 2
21186: NOT
21187: IFFALSE 21191
// exit ;
21189: GO 21340
// un := tmp [ rand ( 1 , tmp ) ] ;
21191: LD_ADDR_VAR 0 3
21195: PUSH
21196: LD_VAR 0 2
21200: PUSH
21201: LD_INT 1
21203: PPUSH
21204: LD_VAR 0 2
21208: PPUSH
21209: CALL_OW 12
21213: ARRAY
21214: ST_TO_ADDR
// if Crawls ( un ) then
21215: LD_VAR 0 3
21219: PPUSH
21220: CALL_OW 318
21224: IFFALSE 21235
// ComWalk ( un ) ;
21226: LD_VAR 0 3
21230: PPUSH
21231: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21235: LD_VAR 0 3
21239: PPUSH
21240: LD_INT 8
21242: PPUSH
21243: CALL_OW 336
// end ; 4 :
21247: GO 21340
21249: LD_INT 4
21251: DOUBLE
21252: EQUAL
21253: IFTRUE 21257
21255: GO 21318
21257: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21258: LD_ADDR_VAR 0 2
21262: PUSH
21263: LD_INT 22
21265: PUSH
21266: LD_OWVAR 2
21270: PUSH
21271: EMPTY
21272: LIST
21273: LIST
21274: PUSH
21275: LD_INT 30
21277: PUSH
21278: LD_INT 29
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: PPUSH
21289: CALL_OW 69
21293: ST_TO_ADDR
// if not tmp then
21294: LD_VAR 0 2
21298: NOT
21299: IFFALSE 21303
// exit ;
21301: GO 21340
// DestroyUnit ( tmp [ 1 ] ) ;
21303: LD_VAR 0 2
21307: PUSH
21308: LD_INT 1
21310: ARRAY
21311: PPUSH
21312: CALL_OW 65
// end ; 5 .. 7 :
21316: GO 21340
21318: LD_INT 5
21320: DOUBLE
21321: GREATEREQUAL
21322: IFFALSE 21330
21324: LD_INT 7
21326: DOUBLE
21327: LESSEQUAL
21328: IFTRUE 21332
21330: GO 21339
21332: POP
// StreamSibBomb ; end ;
21333: CALL 17620 0 0
21337: GO 21340
21339: POP
// end ;
21340: PPOPN 3
21342: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
21343: LD_EXP 43
21347: PUSH
21348: LD_EXP 93
21352: AND
21353: IFFALSE 21509
21355: GO 21357
21357: DISABLE
21358: LD_INT 0
21360: PPUSH
21361: PPUSH
21362: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
21363: LD_ADDR_VAR 0 2
21367: PUSH
21368: LD_INT 81
21370: PUSH
21371: LD_OWVAR 2
21375: PUSH
21376: EMPTY
21377: LIST
21378: LIST
21379: PUSH
21380: LD_INT 2
21382: PUSH
21383: LD_INT 21
21385: PUSH
21386: LD_INT 1
21388: PUSH
21389: EMPTY
21390: LIST
21391: LIST
21392: PUSH
21393: LD_INT 21
21395: PUSH
21396: LD_INT 2
21398: PUSH
21399: EMPTY
21400: LIST
21401: LIST
21402: PUSH
21403: EMPTY
21404: LIST
21405: LIST
21406: LIST
21407: PUSH
21408: EMPTY
21409: LIST
21410: LIST
21411: PPUSH
21412: CALL_OW 69
21416: ST_TO_ADDR
// if not tmp then
21417: LD_VAR 0 2
21421: NOT
21422: IFFALSE 21426
// exit ;
21424: GO 21509
// p := 0 ;
21426: LD_ADDR_VAR 0 3
21430: PUSH
21431: LD_INT 0
21433: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21434: LD_INT 35
21436: PPUSH
21437: CALL_OW 67
// p := p + 1 ;
21441: LD_ADDR_VAR 0 3
21445: PUSH
21446: LD_VAR 0 3
21450: PUSH
21451: LD_INT 1
21453: PLUS
21454: ST_TO_ADDR
// for i in tmp do
21455: LD_ADDR_VAR 0 1
21459: PUSH
21460: LD_VAR 0 2
21464: PUSH
21465: FOR_IN
21466: IFFALSE 21497
// if GetLives ( i ) < 1000 then
21468: LD_VAR 0 1
21472: PPUSH
21473: CALL_OW 256
21477: PUSH
21478: LD_INT 1000
21480: LESS
21481: IFFALSE 21495
// SetLives ( i , 1000 ) ;
21483: LD_VAR 0 1
21487: PPUSH
21488: LD_INT 1000
21490: PPUSH
21491: CALL_OW 234
21495: GO 21465
21497: POP
21498: POP
// until p > 20 ;
21499: LD_VAR 0 3
21503: PUSH
21504: LD_INT 20
21506: GREATER
21507: IFFALSE 21434
// end ;
21509: PPOPN 3
21511: END
// every 0 0$1 trigger StreamModeActive and sTime do
21512: LD_EXP 43
21516: PUSH
21517: LD_EXP 94
21521: AND
21522: IFFALSE 21557
21524: GO 21526
21526: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21527: LD_INT 28
21529: PPUSH
21530: LD_OWVAR 2
21534: PPUSH
21535: LD_INT 2
21537: PPUSH
21538: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21542: LD_INT 30
21544: PPUSH
21545: LD_OWVAR 2
21549: PPUSH
21550: LD_INT 2
21552: PPUSH
21553: CALL_OW 322
// end ;
21557: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21558: LD_EXP 43
21562: PUSH
21563: LD_EXP 95
21567: AND
21568: IFFALSE 21689
21570: GO 21572
21572: DISABLE
21573: LD_INT 0
21575: PPUSH
21576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21577: LD_ADDR_VAR 0 2
21581: PUSH
21582: LD_INT 22
21584: PUSH
21585: LD_OWVAR 2
21589: PUSH
21590: EMPTY
21591: LIST
21592: LIST
21593: PUSH
21594: LD_INT 21
21596: PUSH
21597: LD_INT 1
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PUSH
21604: LD_INT 3
21606: PUSH
21607: LD_INT 23
21609: PUSH
21610: LD_INT 0
21612: PUSH
21613: EMPTY
21614: LIST
21615: LIST
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: LIST
21625: PPUSH
21626: CALL_OW 69
21630: ST_TO_ADDR
// if not tmp then
21631: LD_VAR 0 2
21635: NOT
21636: IFFALSE 21640
// exit ;
21638: GO 21689
// for i in tmp do
21640: LD_ADDR_VAR 0 1
21644: PUSH
21645: LD_VAR 0 2
21649: PUSH
21650: FOR_IN
21651: IFFALSE 21687
// begin if Crawls ( i ) then
21653: LD_VAR 0 1
21657: PPUSH
21658: CALL_OW 318
21662: IFFALSE 21673
// ComWalk ( i ) ;
21664: LD_VAR 0 1
21668: PPUSH
21669: CALL_OW 138
// SetClass ( i , 2 ) ;
21673: LD_VAR 0 1
21677: PPUSH
21678: LD_INT 2
21680: PPUSH
21681: CALL_OW 336
// end ;
21685: GO 21650
21687: POP
21688: POP
// end ;
21689: PPOPN 2
21691: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
21692: LD_EXP 43
21696: PUSH
21697: LD_EXP 96
21701: AND
21702: IFFALSE 21983
21704: GO 21706
21706: DISABLE
21707: LD_INT 0
21709: PPUSH
21710: PPUSH
21711: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
21712: LD_OWVAR 2
21716: PPUSH
21717: LD_INT 9
21719: PPUSH
21720: LD_INT 1
21722: PPUSH
21723: LD_INT 1
21725: PPUSH
21726: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
21730: LD_INT 9
21732: PPUSH
21733: LD_OWVAR 2
21737: PPUSH
21738: CALL_OW 343
// uc_side := 9 ;
21742: LD_ADDR_OWVAR 20
21746: PUSH
21747: LD_INT 9
21749: ST_TO_ADDR
// uc_nation := 2 ;
21750: LD_ADDR_OWVAR 21
21754: PUSH
21755: LD_INT 2
21757: ST_TO_ADDR
// hc_name := Dark Warrior ;
21758: LD_ADDR_OWVAR 26
21762: PUSH
21763: LD_STRING Dark Warrior
21765: ST_TO_ADDR
// hc_gallery :=  ;
21766: LD_ADDR_OWVAR 33
21770: PUSH
21771: LD_STRING 
21773: ST_TO_ADDR
// hc_noskilllimit := true ;
21774: LD_ADDR_OWVAR 76
21778: PUSH
21779: LD_INT 1
21781: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
21782: LD_ADDR_OWVAR 31
21786: PUSH
21787: LD_INT 30
21789: PUSH
21790: LD_INT 30
21792: PUSH
21793: LD_INT 30
21795: PUSH
21796: LD_INT 30
21798: PUSH
21799: EMPTY
21800: LIST
21801: LIST
21802: LIST
21803: LIST
21804: ST_TO_ADDR
// un := CreateHuman ;
21805: LD_ADDR_VAR 0 3
21809: PUSH
21810: CALL_OW 44
21814: ST_TO_ADDR
// hc_noskilllimit := false ;
21815: LD_ADDR_OWVAR 76
21819: PUSH
21820: LD_INT 0
21822: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21823: LD_VAR 0 3
21827: PPUSH
21828: LD_INT 1
21830: PPUSH
21831: CALL_OW 51
// p := 0 ;
21835: LD_ADDR_VAR 0 2
21839: PUSH
21840: LD_INT 0
21842: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21843: LD_INT 35
21845: PPUSH
21846: CALL_OW 67
// p := p + 1 ;
21850: LD_ADDR_VAR 0 2
21854: PUSH
21855: LD_VAR 0 2
21859: PUSH
21860: LD_INT 1
21862: PLUS
21863: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
21864: LD_VAR 0 3
21868: PPUSH
21869: CALL_OW 256
21873: PUSH
21874: LD_INT 1000
21876: LESS
21877: IFFALSE 21891
// SetLives ( un , 1000 ) ;
21879: LD_VAR 0 3
21883: PPUSH
21884: LD_INT 1000
21886: PPUSH
21887: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
21891: LD_VAR 0 3
21895: PPUSH
21896: LD_INT 81
21898: PUSH
21899: LD_OWVAR 2
21903: PUSH
21904: EMPTY
21905: LIST
21906: LIST
21907: PUSH
21908: LD_INT 91
21910: PUSH
21911: LD_VAR 0 3
21915: PUSH
21916: LD_INT 30
21918: PUSH
21919: EMPTY
21920: LIST
21921: LIST
21922: LIST
21923: PUSH
21924: EMPTY
21925: LIST
21926: LIST
21927: PPUSH
21928: CALL_OW 69
21932: PPUSH
21933: LD_VAR 0 3
21937: PPUSH
21938: CALL_OW 74
21942: PPUSH
21943: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
21947: LD_VAR 0 2
21951: PUSH
21952: LD_INT 60
21954: GREATER
21955: PUSH
21956: LD_VAR 0 3
21960: PPUSH
21961: CALL_OW 301
21965: OR
21966: IFFALSE 21843
// if un then
21968: LD_VAR 0 3
21972: IFFALSE 21983
// RemoveUnit ( un ) ;
21974: LD_VAR 0 3
21978: PPUSH
21979: CALL_OW 64
// end ; end_of_file
21983: PPOPN 3
21985: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
21986: LD_INT 0
21988: PPUSH
21989: PPUSH
21990: PPUSH
21991: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
21992: LD_VAR 0 1
21996: PPUSH
21997: CALL_OW 264
22001: PUSH
22002: LD_EXP 34
22006: EQUAL
22007: IFFALSE 22079
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
22009: LD_INT 68
22011: PPUSH
22012: LD_VAR 0 1
22016: PPUSH
22017: CALL_OW 255
22021: PPUSH
22022: CALL_OW 321
22026: PUSH
22027: LD_INT 2
22029: EQUAL
22030: IFFALSE 22042
// eff := 70 else
22032: LD_ADDR_VAR 0 4
22036: PUSH
22037: LD_INT 70
22039: ST_TO_ADDR
22040: GO 22050
// eff := 30 ;
22042: LD_ADDR_VAR 0 4
22046: PUSH
22047: LD_INT 30
22049: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
22050: LD_VAR 0 1
22054: PPUSH
22055: CALL_OW 250
22059: PPUSH
22060: LD_VAR 0 1
22064: PPUSH
22065: CALL_OW 251
22069: PPUSH
22070: LD_VAR 0 4
22074: PPUSH
22075: CALL_OW 495
// end ; end ;
22079: LD_VAR 0 2
22083: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
22084: LD_INT 0
22086: PPUSH
// end ;
22087: LD_VAR 0 4
22091: RET
// export function SOS_Command ( cmd ) ; begin
22092: LD_INT 0
22094: PPUSH
// end ;
22095: LD_VAR 0 2
22099: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
22100: LD_VAR 0 1
22104: PUSH
22105: LD_INT 255
22107: EQUAL
22108: PUSH
22109: LD_VAR 0 2
22113: PPUSH
22114: CALL_OW 264
22118: PUSH
22119: LD_INT 14
22121: PUSH
22122: LD_INT 53
22124: PUSH
22125: EMPTY
22126: LIST
22127: LIST
22128: IN
22129: AND
22130: PUSH
22131: LD_VAR 0 4
22135: PPUSH
22136: LD_VAR 0 5
22140: PPUSH
22141: CALL_OW 488
22145: AND
22146: IFFALSE 22170
// CutTreeXYR ( unit , x , y , 12 ) ;
22148: LD_VAR 0 2
22152: PPUSH
22153: LD_VAR 0 4
22157: PPUSH
22158: LD_VAR 0 5
22162: PPUSH
22163: LD_INT 12
22165: PPUSH
22166: CALL 22173 0 4
// end ;
22170: PPOPN 5
22172: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22173: LD_INT 0
22175: PPUSH
22176: PPUSH
22177: PPUSH
22178: PPUSH
22179: PPUSH
22180: PPUSH
22181: PPUSH
22182: PPUSH
22183: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22184: LD_VAR 0 1
22188: NOT
22189: PUSH
22190: LD_VAR 0 2
22194: PPUSH
22195: LD_VAR 0 3
22199: PPUSH
22200: CALL_OW 488
22204: NOT
22205: OR
22206: PUSH
22207: LD_VAR 0 4
22211: NOT
22212: OR
22213: IFFALSE 22217
// exit ;
22215: GO 22557
// list := [ ] ;
22217: LD_ADDR_VAR 0 13
22221: PUSH
22222: EMPTY
22223: ST_TO_ADDR
// if x - r < 0 then
22224: LD_VAR 0 2
22228: PUSH
22229: LD_VAR 0 4
22233: MINUS
22234: PUSH
22235: LD_INT 0
22237: LESS
22238: IFFALSE 22250
// min_x := 0 else
22240: LD_ADDR_VAR 0 7
22244: PUSH
22245: LD_INT 0
22247: ST_TO_ADDR
22248: GO 22266
// min_x := x - r ;
22250: LD_ADDR_VAR 0 7
22254: PUSH
22255: LD_VAR 0 2
22259: PUSH
22260: LD_VAR 0 4
22264: MINUS
22265: ST_TO_ADDR
// if y - r < 0 then
22266: LD_VAR 0 3
22270: PUSH
22271: LD_VAR 0 4
22275: MINUS
22276: PUSH
22277: LD_INT 0
22279: LESS
22280: IFFALSE 22292
// min_y := 0 else
22282: LD_ADDR_VAR 0 8
22286: PUSH
22287: LD_INT 0
22289: ST_TO_ADDR
22290: GO 22308
// min_y := y - r ;
22292: LD_ADDR_VAR 0 8
22296: PUSH
22297: LD_VAR 0 3
22301: PUSH
22302: LD_VAR 0 4
22306: MINUS
22307: ST_TO_ADDR
// max_x := x + r ;
22308: LD_ADDR_VAR 0 9
22312: PUSH
22313: LD_VAR 0 2
22317: PUSH
22318: LD_VAR 0 4
22322: PLUS
22323: ST_TO_ADDR
// max_y := y + r ;
22324: LD_ADDR_VAR 0 10
22328: PUSH
22329: LD_VAR 0 3
22333: PUSH
22334: LD_VAR 0 4
22338: PLUS
22339: ST_TO_ADDR
// for _x = min_x to max_x do
22340: LD_ADDR_VAR 0 11
22344: PUSH
22345: DOUBLE
22346: LD_VAR 0 7
22350: DEC
22351: ST_TO_ADDR
22352: LD_VAR 0 9
22356: PUSH
22357: FOR_TO
22358: IFFALSE 22475
// for _y = min_y to max_y do
22360: LD_ADDR_VAR 0 12
22364: PUSH
22365: DOUBLE
22366: LD_VAR 0 8
22370: DEC
22371: ST_TO_ADDR
22372: LD_VAR 0 10
22376: PUSH
22377: FOR_TO
22378: IFFALSE 22471
// begin if not ValidHex ( _x , _y ) then
22380: LD_VAR 0 11
22384: PPUSH
22385: LD_VAR 0 12
22389: PPUSH
22390: CALL_OW 488
22394: NOT
22395: IFFALSE 22399
// continue ;
22397: GO 22377
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22399: LD_VAR 0 11
22403: PPUSH
22404: LD_VAR 0 12
22408: PPUSH
22409: CALL_OW 351
22413: PUSH
22414: LD_VAR 0 11
22418: PPUSH
22419: LD_VAR 0 12
22423: PPUSH
22424: CALL_OW 554
22428: AND
22429: IFFALSE 22469
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22431: LD_ADDR_VAR 0 13
22435: PUSH
22436: LD_VAR 0 13
22440: PPUSH
22441: LD_VAR 0 13
22445: PUSH
22446: LD_INT 1
22448: PLUS
22449: PPUSH
22450: LD_VAR 0 11
22454: PUSH
22455: LD_VAR 0 12
22459: PUSH
22460: EMPTY
22461: LIST
22462: LIST
22463: PPUSH
22464: CALL_OW 2
22468: ST_TO_ADDR
// end ;
22469: GO 22377
22471: POP
22472: POP
22473: GO 22357
22475: POP
22476: POP
// if not list then
22477: LD_VAR 0 13
22481: NOT
22482: IFFALSE 22486
// exit ;
22484: GO 22557
// for i in list do
22486: LD_ADDR_VAR 0 6
22490: PUSH
22491: LD_VAR 0 13
22495: PUSH
22496: FOR_IN
22497: IFFALSE 22555
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22499: LD_VAR 0 1
22503: PPUSH
22504: LD_STRING M
22506: PUSH
22507: LD_VAR 0 6
22511: PUSH
22512: LD_INT 1
22514: ARRAY
22515: PUSH
22516: LD_VAR 0 6
22520: PUSH
22521: LD_INT 2
22523: ARRAY
22524: PUSH
22525: LD_INT 0
22527: PUSH
22528: LD_INT 0
22530: PUSH
22531: LD_INT 0
22533: PUSH
22534: LD_INT 0
22536: PUSH
22537: EMPTY
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: LIST
22543: LIST
22544: LIST
22545: PUSH
22546: EMPTY
22547: LIST
22548: PPUSH
22549: CALL_OW 447
22553: GO 22496
22555: POP
22556: POP
// end ;
22557: LD_VAR 0 5
22561: RET
