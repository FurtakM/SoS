// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 509 0 0
// PrepareAmericans ;
  23: CALL 681 0 0
// PrepareArabian ;
  27: CALL 2960 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 118 0 0
// Action ;
  41: CALL 1624 0 0
// end ;
  45: END
// export debug , prefix , missionStart , arivadzeSpotted , deltaSpotted , sciSpotted , sciCounterKill , usAlert ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := true ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 1
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// arivadzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 6
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 7
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// usAlert := false ;
  97: LD_ADDR_EXP 8
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// prefix := 01 ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_STRING 01
 112: ST_TO_ADDR
// end ;
 113: LD_VAR 0 1
 117: RET
// function DebugMode ; begin
 118: LD_INT 0
 120: PPUSH
// FogOff ( 1 ) ;
 121: LD_INT 1
 123: PPUSH
 124: CALL_OW 344
// Difficulty := 2 ;
 128: LD_ADDR_OWVAR 67
 132: PUSH
 133: LD_INT 2
 135: ST_TO_ADDR
// end ; end_of_file
 136: LD_VAR 0 1
 140: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 141: LD_INT 0
 143: PPUSH
 144: PPUSH
// if exist_mode then
 145: LD_VAR 0 2
 149: IFFALSE 174
// unit := CreateCharacter ( prefix & ident ) else
 151: LD_ADDR_VAR 0 5
 155: PUSH
 156: LD_VAR 0 3
 160: PUSH
 161: LD_VAR 0 1
 165: STR
 166: PPUSH
 167: CALL_OW 34
 171: ST_TO_ADDR
 172: GO 189
// unit := NewCharacter ( ident ) ;
 174: LD_ADDR_VAR 0 5
 178: PUSH
 179: LD_VAR 0 1
 183: PPUSH
 184: CALL_OW 25
 188: ST_TO_ADDR
// result := unit ;
 189: LD_ADDR_VAR 0 4
 193: PUSH
 194: LD_VAR 0 5
 198: ST_TO_ADDR
// end ;
 199: LD_VAR 0 4
 203: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 204: LD_INT 0
 206: PPUSH
// uc_side := side ;
 207: LD_ADDR_OWVAR 20
 211: PUSH
 212: LD_VAR 0 1
 216: ST_TO_ADDR
// uc_nation := nation ;
 217: LD_ADDR_OWVAR 21
 221: PUSH
 222: LD_VAR 0 2
 226: ST_TO_ADDR
// vc_chassis := chassis ;
 227: LD_ADDR_OWVAR 37
 231: PUSH
 232: LD_VAR 0 3
 236: ST_TO_ADDR
// vc_engine := engine ;
 237: LD_ADDR_OWVAR 39
 241: PUSH
 242: LD_VAR 0 4
 246: ST_TO_ADDR
// vc_control := control ;
 247: LD_ADDR_OWVAR 38
 251: PUSH
 252: LD_VAR 0 5
 256: ST_TO_ADDR
// vc_weapon := weapon ;
 257: LD_ADDR_OWVAR 40
 261: PUSH
 262: LD_VAR 0 6
 266: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 267: LD_ADDR_OWVAR 41
 271: PUSH
 272: LD_VAR 0 7
 276: ST_TO_ADDR
// result := CreateVehicle ;
 277: LD_ADDR_VAR 0 8
 281: PUSH
 282: CALL_OW 45
 286: ST_TO_ADDR
// end ;
 287: LD_VAR 0 8
 291: RET
// export function SayX ( units , ident ) ; var i ; begin
 292: LD_INT 0
 294: PPUSH
 295: PPUSH
// result := false ;
 296: LD_ADDR_VAR 0 3
 300: PUSH
 301: LD_INT 0
 303: ST_TO_ADDR
// if not units then
 304: LD_VAR 0 1
 308: NOT
 309: IFFALSE 313
// exit ;
 311: GO 367
// for i in units do
 313: LD_ADDR_VAR 0 4
 317: PUSH
 318: LD_VAR 0 1
 322: PUSH
 323: FOR_IN
 324: IFFALSE 365
// if IsOk ( i ) then
 326: LD_VAR 0 4
 330: PPUSH
 331: CALL_OW 302
 335: IFFALSE 363
// begin Say ( i , ident ) ;
 337: LD_VAR 0 4
 341: PPUSH
 342: LD_VAR 0 2
 346: PPUSH
 347: CALL_OW 88
// result := i ;
 351: LD_ADDR_VAR 0 3
 355: PUSH
 356: LD_VAR 0 4
 360: ST_TO_ADDR
// break ;
 361: GO 365
// end ;
 363: GO 323
 365: POP
 366: POP
// end ;
 367: LD_VAR 0 3
 371: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 372: LD_INT 0
 374: PPUSH
 375: PPUSH
// InitUc ;
 376: CALL_OW 18
// InitHc ;
 380: CALL_OW 19
// uc_side := 0 ;
 384: LD_ADDR_OWVAR 20
 388: PUSH
 389: LD_INT 0
 391: ST_TO_ADDR
// uc_nation := 0 ;
 392: LD_ADDR_OWVAR 21
 396: PUSH
 397: LD_INT 0
 399: ST_TO_ADDR
// for i = 1 to amount do
 400: LD_ADDR_VAR 0 4
 404: PUSH
 405: DOUBLE
 406: LD_INT 1
 408: DEC
 409: ST_TO_ADDR
 410: LD_VAR 0 2
 414: PUSH
 415: FOR_TO
 416: IFFALSE 498
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 418: LD_ADDR_OWVAR 29
 422: PUSH
 423: LD_INT 9
 425: PPUSH
 426: LD_INT 12
 428: PPUSH
 429: CALL_OW 12
 433: PUSH
 434: LD_INT 9
 436: PPUSH
 437: LD_INT 12
 439: PPUSH
 440: CALL_OW 12
 444: PUSH
 445: EMPTY
 446: LIST
 447: LIST
 448: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 449: LD_ADDR_OWVAR 35
 453: PUSH
 454: LD_INT 5
 456: NEG
 457: PPUSH
 458: LD_INT 5
 460: PPUSH
 461: CALL_OW 12
 465: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 466: LD_INT 0
 468: PPUSH
 469: LD_INT 12
 471: PPUSH
 472: LD_INT 1
 474: PPUSH
 475: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 479: CALL_OW 44
 483: PPUSH
 484: LD_VAR 0 1
 488: PPUSH
 489: LD_INT 0
 491: PPUSH
 492: CALL_OW 49
// end ;
 496: GO 415
 498: POP
 499: POP
// InitHc ;
 500: CALL_OW 19
// end ;
 504: LD_VAR 0 3
 508: RET
// export function PrepareNature ; var i ; begin
 509: LD_INT 0
 511: PPUSH
 512: PPUSH
// SpawnApeman ( forest , 9 ) ;
 513: LD_INT 1
 515: PPUSH
 516: LD_INT 9
 518: PPUSH
 519: CALL 372 0 2
// for i := 1 to 4 do
 523: LD_ADDR_VAR 0 2
 527: PUSH
 528: DOUBLE
 529: LD_INT 1
 531: DEC
 532: ST_TO_ADDR
 533: LD_INT 4
 535: PUSH
 536: FOR_TO
 537: IFFALSE 572
// begin hc_class := 21 ;
 539: LD_ADDR_OWVAR 28
 543: PUSH
 544: LD_INT 21
 546: ST_TO_ADDR
// hc_gallery :=  ;
 547: LD_ADDR_OWVAR 33
 551: PUSH
 552: LD_STRING 
 554: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 555: CALL_OW 44
 559: PPUSH
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 0
 565: PPUSH
 566: CALL_OW 49
// end ;
 570: GO 536
 572: POP
 573: POP
// for i := 1 to 2 do
 574: LD_ADDR_VAR 0 2
 578: PUSH
 579: DOUBLE
 580: LD_INT 1
 582: DEC
 583: ST_TO_ADDR
 584: LD_INT 2
 586: PUSH
 587: FOR_TO
 588: IFFALSE 623
// begin hc_class := 18 ;
 590: LD_ADDR_OWVAR 28
 594: PUSH
 595: LD_INT 18
 597: ST_TO_ADDR
// hc_gallery :=  ;
 598: LD_ADDR_OWVAR 33
 602: PUSH
 603: LD_STRING 
 605: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 606: CALL_OW 44
 610: PPUSH
 611: LD_INT 1
 613: PPUSH
 614: LD_INT 0
 616: PPUSH
 617: CALL_OW 49
// end ;
 621: GO 587
 623: POP
 624: POP
// for i := 1 to 3 do
 625: LD_ADDR_VAR 0 2
 629: PUSH
 630: DOUBLE
 631: LD_INT 1
 633: DEC
 634: ST_TO_ADDR
 635: LD_INT 3
 637: PUSH
 638: FOR_TO
 639: IFFALSE 674
// begin hc_class := 13 ;
 641: LD_ADDR_OWVAR 28
 645: PUSH
 646: LD_INT 13
 648: ST_TO_ADDR
// hc_gallery :=  ;
 649: LD_ADDR_OWVAR 33
 653: PUSH
 654: LD_STRING 
 656: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 657: CALL_OW 44
 661: PPUSH
 662: LD_INT 1
 664: PPUSH
 665: LD_INT 0
 667: PPUSH
 668: CALL_OW 49
// end ;
 672: GO 638
 674: POP
 675: POP
// end ; end_of_file
 676: LD_VAR 0 1
 680: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp ; begin
 681: LD_INT 0
 683: PPUSH
 684: PPUSH
 685: PPUSH
 686: PPUSH
 687: PPUSH
// usForces := [ ] ;
 688: LD_ADDR_EXP 11
 692: PUSH
 693: EMPTY
 694: ST_TO_ADDR
// usSci := [ ] ;
 695: LD_ADDR_EXP 12
 699: PUSH
 700: EMPTY
 701: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 702: LD_INT 1
 704: PPUSH
 705: LD_STRING Delta
 707: PPUSH
 708: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 712: LD_INT 1
 714: PPUSH
 715: CALL_OW 274
 719: PPUSH
 720: LD_INT 1
 722: PPUSH
 723: LD_INT 400
 725: PPUSH
 726: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 730: LD_INT 1
 732: PPUSH
 733: CALL_OW 274
 737: PPUSH
 738: LD_INT 2
 740: PPUSH
 741: LD_INT 80
 743: PPUSH
 744: CALL_OW 277
// uc_side := 1 ;
 748: LD_ADDR_OWVAR 20
 752: PUSH
 753: LD_INT 1
 755: ST_TO_ADDR
// uc_nation := 1 ;
 756: LD_ADDR_OWVAR 21
 760: PUSH
 761: LD_INT 1
 763: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 764: LD_ADDR_EXP 10
 768: PUSH
 769: LD_STRING Lynch
 771: PPUSH
 772: LD_INT 0
 774: PPUSH
 775: LD_STRING 
 777: PPUSH
 778: CALL 141 0 3
 782: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 783: LD_ADDR_EXP 9
 787: PUSH
 788: LD_STRING Gladstone
 790: PPUSH
 791: LD_INT 0
 793: PPUSH
 794: LD_STRING 
 796: PPUSH
 797: CALL 141 0 3
 801: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 802: LD_EXP 10
 806: PPUSH
 807: LD_INT 1
 809: PPUSH
 810: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 814: LD_EXP 9
 818: PPUSH
 819: LD_INT 3
 821: PPUSH
 822: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
 826: LD_ADDR_VAR 0 2
 830: PUSH
 831: DOUBLE
 832: LD_INT 1
 834: DEC
 835: ST_TO_ADDR
 836: LD_INT 1
 838: PUSH
 839: LD_INT 2
 841: PUSH
 842: LD_INT 2
 844: PUSH
 845: EMPTY
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_OWVAR 67
 854: ARRAY
 855: PUSH
 856: FOR_TO
 857: IFFALSE 903
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
 859: LD_INT 0
 861: PPUSH
 862: LD_INT 2
 864: PPUSH
 865: LD_INT 1
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 2
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_OWVAR 67
 883: ARRAY
 884: PPUSH
 885: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
 889: CALL_OW 44
 893: PPUSH
 894: LD_INT 1
 896: PPUSH
 897: CALL_OW 52
// end ;
 901: GO 856
 903: POP
 904: POP
// for i := 1 to 2 + Difficulty do
 905: LD_ADDR_VAR 0 2
 909: PUSH
 910: DOUBLE
 911: LD_INT 1
 913: DEC
 914: ST_TO_ADDR
 915: LD_INT 2
 917: PUSH
 918: LD_OWVAR 67
 922: PLUS
 923: PUSH
 924: FOR_TO
 925: IFFALSE 1010
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
 927: LD_INT 0
 929: PPUSH
 930: LD_INT 4
 932: PPUSH
 933: LD_INT 1
 935: PUSH
 936: LD_INT 2
 938: PUSH
 939: LD_INT 2
 941: PUSH
 942: EMPTY
 943: LIST
 944: LIST
 945: LIST
 946: PUSH
 947: LD_OWVAR 67
 951: ARRAY
 952: PPUSH
 953: CALL_OW 380
// un := CreateHuman ;
 957: LD_ADDR_VAR 0 3
 961: PUSH
 962: CALL_OW 44
 966: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
 967: LD_VAR 0 3
 971: PPUSH
 972: LD_INT 3
 974: PPUSH
 975: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
 979: LD_ADDR_EXP 12
 983: PUSH
 984: LD_EXP 12
 988: PPUSH
 989: LD_EXP 12
 993: PUSH
 994: LD_INT 1
 996: PLUS
 997: PPUSH
 998: LD_VAR 0 3
1002: PPUSH
1003: CALL_OW 1
1007: ST_TO_ADDR
// end ;
1008: GO 924
1010: POP
1011: POP
// end ;
1012: LD_VAR 0 1
1016: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1017: LD_INT 0
1019: PPUSH
1020: PPUSH
1021: PPUSH
1022: PPUSH
1023: PPUSH
1024: PPUSH
// if not usSci then
1025: LD_EXP 12
1029: NOT
1030: IFFALSE 1034
// exit ;
1032: GO 1208
// xy := AreaToList ( tameArea , 0 ) ;
1034: LD_ADDR_VAR 0 6
1038: PUSH
1039: LD_INT 5
1041: PPUSH
1042: LD_INT 0
1044: PPUSH
1045: CALL_OW 517
1049: ST_TO_ADDR
// for i in usSci do
1050: LD_ADDR_VAR 0 2
1054: PUSH
1055: LD_EXP 12
1059: PUSH
1060: FOR_IN
1061: IFFALSE 1206
// begin k := rand ( 1 , xy [ 1 ] ) ;
1063: LD_ADDR_VAR 0 4
1067: PUSH
1068: LD_INT 1
1070: PPUSH
1071: LD_VAR 0 6
1075: PUSH
1076: LD_INT 1
1078: ARRAY
1079: PPUSH
1080: CALL_OW 12
1084: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1085: LD_VAR 0 2
1089: PPUSH
1090: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1094: LD_VAR 0 2
1098: PPUSH
1099: LD_VAR 0 6
1103: PUSH
1104: LD_INT 1
1106: ARRAY
1107: PUSH
1108: LD_VAR 0 4
1112: ARRAY
1113: PPUSH
1114: LD_VAR 0 6
1118: PUSH
1119: LD_INT 2
1121: ARRAY
1122: PUSH
1123: LD_VAR 0 4
1127: ARRAY
1128: PPUSH
1129: CALL_OW 171
// for j := 1 to 2 do
1133: LD_ADDR_VAR 0 3
1137: PUSH
1138: DOUBLE
1139: LD_INT 1
1141: DEC
1142: ST_TO_ADDR
1143: LD_INT 2
1145: PUSH
1146: FOR_TO
1147: IFFALSE 1202
// begin tmp := Delete ( xy [ j ] , k ) ;
1149: LD_ADDR_VAR 0 5
1153: PUSH
1154: LD_VAR 0 6
1158: PUSH
1159: LD_VAR 0 3
1163: ARRAY
1164: PPUSH
1165: LD_VAR 0 4
1169: PPUSH
1170: CALL_OW 3
1174: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1175: LD_ADDR_VAR 0 6
1179: PUSH
1180: LD_VAR 0 6
1184: PPUSH
1185: LD_VAR 0 3
1189: PPUSH
1190: LD_VAR 0 5
1194: PPUSH
1195: CALL_OW 1
1199: ST_TO_ADDR
// end ;
1200: GO 1146
1202: POP
1203: POP
// end ;
1204: GO 1060
1206: POP
1207: POP
// end ;
1208: LD_VAR 0 1
1212: RET
// every 0 0$5 + 0 0$10 trigger usSci and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1213: LD_EXP 12
1217: PUSH
1218: LD_INT 22
1220: PUSH
1221: LD_INT 0
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: PUSH
1228: LD_INT 25
1230: PUSH
1231: LD_INT 12
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: PUSH
1238: EMPTY
1239: LIST
1240: LIST
1241: PPUSH
1242: CALL_OW 69
1246: AND
1247: IFFALSE 1621
1249: GO 1251
1251: DISABLE
1252: LD_INT 0
1254: PPUSH
1255: PPUSH
1256: PPUSH
1257: PPUSH
1258: PPUSH
// begin enable ;
1259: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1260: LD_EXP 12
1264: PPUSH
1265: LD_INT 2
1267: PUSH
1268: LD_INT 60
1270: PUSH
1271: EMPTY
1272: LIST
1273: PUSH
1274: LD_INT 54
1276: PUSH
1277: EMPTY
1278: LIST
1279: PUSH
1280: EMPTY
1281: LIST
1282: LIST
1283: LIST
1284: PPUSH
1285: CALL_OW 72
1289: IFFALSE 1293
// exit ;
1291: GO 1621
// for i in usSci do
1293: LD_ADDR_VAR 0 1
1297: PUSH
1298: LD_EXP 12
1302: PUSH
1303: FOR_IN
1304: IFFALSE 1619
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1306: LD_VAR 0 1
1310: PPUSH
1311: CALL_OW 314
1315: NOT
1316: PUSH
1317: LD_VAR 0 1
1321: PPUSH
1322: CALL_OW 256
1326: PUSH
1327: LD_INT 1000
1329: EQUAL
1330: AND
1331: IFFALSE 1538
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1333: LD_ADDR_VAR 0 5
1337: PUSH
1338: LD_INT 22
1340: PUSH
1341: LD_INT 0
1343: PUSH
1344: EMPTY
1345: LIST
1346: LIST
1347: PUSH
1348: LD_INT 25
1350: PUSH
1351: LD_INT 12
1353: PUSH
1354: EMPTY
1355: LIST
1356: LIST
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PPUSH
1362: CALL_OW 69
1366: PPUSH
1367: LD_VAR 0 1
1371: PPUSH
1372: CALL_OW 74
1376: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1377: LD_VAR 0 1
1381: PPUSH
1382: LD_VAR 0 5
1386: PPUSH
1387: CALL_OW 296
1391: PUSH
1392: LD_INT 10
1394: LESS
1395: IFFALSE 1428
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1397: LD_VAR 0 1
1401: PPUSH
1402: LD_VAR 0 5
1406: PPUSH
1407: CALL_OW 250
1411: PPUSH
1412: LD_VAR 0 5
1416: PPUSH
1417: CALL_OW 251
1421: PPUSH
1422: CALL_OW 131
1426: GO 1538
// begin d := rand ( 0 , 5 ) ;
1428: LD_ADDR_VAR 0 4
1432: PUSH
1433: LD_INT 0
1435: PPUSH
1436: LD_INT 5
1438: PPUSH
1439: CALL_OW 12
1443: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1444: LD_ADDR_VAR 0 2
1448: PUSH
1449: LD_VAR 0 1
1453: PPUSH
1454: CALL_OW 250
1458: PPUSH
1459: LD_VAR 0 4
1463: PPUSH
1464: LD_INT 3
1466: PPUSH
1467: CALL_OW 272
1471: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
1472: LD_ADDR_VAR 0 3
1476: PUSH
1477: LD_VAR 0 1
1481: PPUSH
1482: CALL_OW 251
1486: PPUSH
1487: LD_VAR 0 4
1491: PPUSH
1492: LD_INT 3
1494: PPUSH
1495: CALL_OW 273
1499: ST_TO_ADDR
// if not ValidHex ( x , y ) then
1500: LD_VAR 0 2
1504: PPUSH
1505: LD_VAR 0 3
1509: PPUSH
1510: CALL_OW 488
1514: NOT
1515: IFFALSE 1519
// continue ;
1517: GO 1303
// ComMoveXY ( i , x , y ) ;
1519: LD_VAR 0 1
1523: PPUSH
1524: LD_VAR 0 2
1528: PPUSH
1529: LD_VAR 0 3
1533: PPUSH
1534: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
1538: LD_VAR 0 1
1542: PPUSH
1543: CALL_OW 256
1547: PUSH
1548: LD_INT 900
1550: LESS
1551: PUSH
1552: LD_VAR 0 1
1556: PPUSH
1557: LD_INT 37
1559: PPUSH
1560: LD_INT 23
1562: PPUSH
1563: CALL_OW 297
1567: PUSH
1568: LD_INT 10
1570: GREATER
1571: AND
1572: IFFALSE 1617
// begin ComMoveXY ( i , 37 , 23 ) ;
1574: LD_VAR 0 1
1578: PPUSH
1579: LD_INT 37
1581: PPUSH
1582: LD_INT 23
1584: PPUSH
1585: CALL_OW 111
// AddComEnterUnit ( i , usLab ) ;
1589: LD_VAR 0 1
1593: PPUSH
1594: LD_INT 3
1596: PPUSH
1597: CALL_OW 180
// usSci := usSci diff i ;
1601: LD_ADDR_EXP 12
1605: PUSH
1606: LD_EXP 12
1610: PUSH
1611: LD_VAR 0 1
1615: DIFF
1616: ST_TO_ADDR
// end ; end ;
1617: GO 1303
1619: POP
1620: POP
// end ; end_of_file
1621: PPOPN 5
1623: END
// export function Action ; begin
1624: LD_INT 0
1626: PPUSH
// InGameOn ;
1627: CALL_OW 8
// ComMoveXY ( Heike , 78 , 61 ) ;
1631: LD_EXP 13
1635: PPUSH
1636: LD_INT 78
1638: PPUSH
1639: LD_INT 61
1641: PPUSH
1642: CALL_OW 111
// if Mike then
1646: LD_EXP 15
1650: IFFALSE 1667
// ComMoveXY ( Mike , 80 , 66 ) ;
1652: LD_EXP 15
1656: PPUSH
1657: LD_INT 80
1659: PPUSH
1660: LD_INT 66
1662: PPUSH
1663: CALL_OW 111
// if Givi then
1667: LD_EXP 14
1671: IFFALSE 1688
// ComMoveXY ( Givi , 82 , 66 ) ;
1673: LD_EXP 14
1677: PPUSH
1678: LD_INT 82
1680: PPUSH
1681: LD_INT 66
1683: PPUSH
1684: CALL_OW 111
// if Kamil then
1688: LD_EXP 16
1692: IFFALSE 1709
// ComMoveXY ( Kamil , 82 , 69 ) ;
1694: LD_EXP 16
1698: PPUSH
1699: LD_INT 82
1701: PPUSH
1702: LD_INT 69
1704: PPUSH
1705: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
1709: LD_EXP 13
1713: PPUSH
1714: CALL_OW 87
// wait ( 0 0$2 ) ;
1718: LD_INT 70
1720: PPUSH
1721: CALL_OW 67
// if Givi and Mike then
1725: LD_EXP 14
1729: PUSH
1730: LD_EXP 15
1734: AND
1735: IFFALSE 2181
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
1737: LD_EXP 14
1741: PUSH
1742: LD_EXP 15
1746: PUSH
1747: LD_EXP 16
1751: PUSH
1752: EMPTY
1753: LIST
1754: LIST
1755: LIST
1756: PPUSH
1757: LD_EXP 13
1761: PPUSH
1762: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
1766: LD_EXP 13
1770: PPUSH
1771: LD_EXP 14
1775: PPUSH
1776: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
1780: LD_EXP 14
1784: PPUSH
1785: LD_STRING DG-1-start
1787: PPUSH
1788: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
1792: LD_EXP 13
1796: PPUSH
1797: LD_STRING DH-1-start
1799: PPUSH
1800: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
1804: LD_EXP 15
1808: PPUSH
1809: LD_EXP 13
1813: PPUSH
1814: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
1818: LD_EXP 13
1822: PPUSH
1823: LD_EXP 15
1827: PPUSH
1828: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
1832: LD_EXP 15
1836: PPUSH
1837: LD_STRING DM-1-start
1839: PPUSH
1840: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
1844: LD_EXP 13
1848: PPUSH
1849: LD_STRING DH-2-start
1851: PPUSH
1852: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
1856: LD_EXP 15
1860: PPUSH
1861: LD_STRING DM-2-start
1863: PPUSH
1864: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
1868: LD_EXP 14
1872: PPUSH
1873: LD_STRING DG-2-start
1875: PPUSH
1876: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
1880: LD_EXP 15
1884: PPUSH
1885: LD_EXP 14
1889: PPUSH
1890: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
1894: LD_EXP 13
1898: PPUSH
1899: LD_EXP 15
1903: PPUSH
1904: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
1908: LD_EXP 15
1912: PPUSH
1913: LD_STRING DM-3-start
1915: PPUSH
1916: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
1920: LD_EXP 13
1924: PPUSH
1925: LD_STRING DH-3-start
1927: PPUSH
1928: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
1932: LD_EXP 13
1936: PUSH
1937: LD_EXP 15
1941: PUSH
1942: LD_EXP 14
1946: PUSH
1947: LD_EXP 16
1951: PUSH
1952: EMPTY
1953: LIST
1954: LIST
1955: LIST
1956: LIST
1957: PPUSH
1958: LD_INT 84
1960: PPUSH
1961: LD_INT 51
1963: PPUSH
1964: CALL_OW 111
// wait ( 0 0$2 ) ;
1968: LD_INT 70
1970: PPUSH
1971: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
1975: LD_EXP 14
1979: PPUSH
1980: LD_STRING DG-3-start
1982: PPUSH
1983: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
1987: LD_EXP 13
1991: PUSH
1992: LD_EXP 15
1996: PUSH
1997: LD_EXP 14
2001: PUSH
2002: LD_EXP 16
2006: PUSH
2007: EMPTY
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: PPUSH
2013: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
2017: LD_EXP 13
2021: PPUSH
2022: LD_EXP 14
2026: PPUSH
2027: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
2031: LD_EXP 14
2035: PUSH
2036: LD_EXP 15
2040: PUSH
2041: LD_EXP 16
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: LIST
2050: PPUSH
2051: LD_EXP 13
2055: PPUSH
2056: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
2060: LD_EXP 13
2064: PPUSH
2065: LD_STRING DH-4-start
2067: PPUSH
2068: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
2072: LD_EXP 14
2076: PPUSH
2077: LD_STRING DG-4-start
2079: PPUSH
2080: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
2084: LD_EXP 13
2088: PPUSH
2089: LD_STRING DH-5-start
2091: PPUSH
2092: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
2096: LD_EXP 14
2100: PPUSH
2101: LD_STRING DG-5-start
2103: PPUSH
2104: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
2108: LD_EXP 13
2112: PPUSH
2113: LD_STRING DH-6-start
2115: PPUSH
2116: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
2120: LD_EXP 15
2124: PPUSH
2125: LD_STRING DM-6-start
2127: PPUSH
2128: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
2132: LD_EXP 13
2136: PUSH
2137: LD_EXP 14
2141: PUSH
2142: EMPTY
2143: LIST
2144: LIST
2145: PPUSH
2146: LD_EXP 15
2150: PPUSH
2151: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
2155: LD_EXP 14
2159: PPUSH
2160: LD_STRING DG-6-start
2162: PPUSH
2163: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
2167: LD_EXP 13
2171: PPUSH
2172: LD_STRING DH-7-start
2174: PPUSH
2175: CALL_OW 88
// end else
2179: GO 2903
// if not Mike and Givi then
2181: LD_EXP 15
2185: NOT
2186: PUSH
2187: LD_EXP 14
2191: AND
2192: IFFALSE 2537
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
2194: LD_EXP 14
2198: PUSH
2199: LD_EXP 16
2203: PUSH
2204: EMPTY
2205: LIST
2206: LIST
2207: PPUSH
2208: LD_EXP 13
2212: PPUSH
2213: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
2217: LD_EXP 13
2221: PPUSH
2222: LD_EXP 14
2226: PPUSH
2227: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
2231: LD_EXP 14
2235: PPUSH
2236: LD_STRING DG-1-start-c
2238: PPUSH
2239: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
2243: LD_EXP 13
2247: PPUSH
2248: LD_STRING DH-1-start-c
2250: PPUSH
2251: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
2255: LD_EXP 14
2259: PPUSH
2260: LD_STRING DG-2-start-c
2262: PPUSH
2263: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
2267: LD_EXP 13
2271: PPUSH
2272: LD_STRING DH-2-start-c
2274: PPUSH
2275: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
2279: LD_EXP 14
2283: PPUSH
2284: LD_STRING DG-3-start-c
2286: PPUSH
2287: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
2291: LD_EXP 13
2295: PPUSH
2296: LD_INT 83
2298: PPUSH
2299: LD_INT 56
2301: PPUSH
2302: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
2306: LD_EXP 14
2310: PPUSH
2311: LD_INT 83
2313: PPUSH
2314: LD_INT 59
2316: PPUSH
2317: CALL_OW 111
// if Kamil then
2321: LD_EXP 16
2325: IFFALSE 2342
// ComMoveXY ( Kamil , 80 , 58 ) ;
2327: LD_EXP 16
2331: PPUSH
2332: LD_INT 80
2334: PPUSH
2335: LD_INT 58
2337: PPUSH
2338: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
2342: LD_EXP 13
2346: PPUSH
2347: LD_EXP 14
2351: PPUSH
2352: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
2356: LD_EXP 14
2360: PUSH
2361: LD_EXP 16
2365: PUSH
2366: EMPTY
2367: LIST
2368: LIST
2369: PPUSH
2370: LD_EXP 13
2374: PPUSH
2375: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
2379: LD_EXP 13
2383: PPUSH
2384: LD_STRING DH-3-start-c
2386: PPUSH
2387: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
2391: LD_EXP 14
2395: PPUSH
2396: LD_STRING DG-4-start-c
2398: PPUSH
2399: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
2403: LD_EXP 13
2407: PPUSH
2408: LD_STRING DH-5-start-c
2410: PPUSH
2411: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
2415: LD_EXP 14
2419: PPUSH
2420: LD_STRING DG-5-start-c
2422: PPUSH
2423: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
2427: LD_EXP 13
2431: PPUSH
2432: LD_STRING DH-6-start-c
2434: PPUSH
2435: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
2439: LD_EXP 14
2443: PPUSH
2444: LD_STRING DG-6-start-c
2446: PPUSH
2447: CALL_OW 88
// if Kamil then
2451: LD_EXP 16
2455: IFFALSE 2511
// begin ComTurnUnit ( Kamil , Heike ) ;
2457: LD_EXP 16
2461: PPUSH
2462: LD_EXP 13
2466: PPUSH
2467: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
2471: LD_EXP 16
2475: PPUSH
2476: LD_STRING DKam-1-start-c
2478: PPUSH
2479: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
2483: LD_EXP 14
2487: PPUSH
2488: LD_EXP 16
2492: PPUSH
2493: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
2497: LD_EXP 14
2501: PPUSH
2502: LD_STRING DG-7-start-c
2504: PPUSH
2505: CALL_OW 88
// end else
2509: GO 2535
// begin Say ( Givi , DG-8-start-c ) ;
2511: LD_EXP 14
2515: PPUSH
2516: LD_STRING DG-8-start-c
2518: PPUSH
2519: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
2523: LD_EXP 13
2527: PPUSH
2528: LD_STRING DH-7-start-c
2530: PPUSH
2531: CALL_OW 88
// end ; end else
2535: GO 2903
// if not Givi and Mike then
2537: LD_EXP 14
2541: NOT
2542: PUSH
2543: LD_EXP 15
2547: AND
2548: IFFALSE 2807
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
2550: LD_EXP 15
2554: PUSH
2555: LD_EXP 16
2559: PUSH
2560: EMPTY
2561: LIST
2562: LIST
2563: PPUSH
2564: LD_EXP 13
2568: PPUSH
2569: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
2573: LD_EXP 13
2577: PPUSH
2578: LD_EXP 15
2582: PPUSH
2583: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
2587: LD_EXP 15
2591: PPUSH
2592: LD_STRING DM-1-start-b
2594: PPUSH
2595: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
2599: LD_EXP 13
2603: PPUSH
2604: LD_STRING DH-1-start-b
2606: PPUSH
2607: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
2611: LD_EXP 15
2615: PPUSH
2616: LD_STRING DM-2-start-b
2618: PPUSH
2619: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
2623: LD_EXP 13
2627: PPUSH
2628: LD_STRING DH-2-start-b
2630: PPUSH
2631: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
2635: LD_EXP 15
2639: PPUSH
2640: LD_STRING DM-3-start-b
2642: PPUSH
2643: CALL_OW 88
// if Kamil then
2647: LD_EXP 16
2651: IFFALSE 2668
// ComMoveXY ( Kamil , 80 , 58 ) ;
2653: LD_EXP 16
2657: PPUSH
2658: LD_INT 80
2660: PPUSH
2661: LD_INT 58
2663: PPUSH
2664: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
2668: LD_EXP 13
2672: PPUSH
2673: LD_INT 83
2675: PPUSH
2676: LD_INT 56
2678: PPUSH
2679: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
2683: LD_EXP 15
2687: PPUSH
2688: LD_INT 83
2690: PPUSH
2691: LD_INT 59
2693: PPUSH
2694: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
2698: LD_EXP 13
2702: PPUSH
2703: LD_EXP 15
2707: PPUSH
2708: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
2712: LD_EXP 16
2716: PUSH
2717: LD_EXP 15
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PPUSH
2726: LD_EXP 13
2730: PPUSH
2731: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
2735: LD_EXP 13
2739: PPUSH
2740: LD_STRING DH-3-start-b
2742: PPUSH
2743: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
2747: LD_EXP 15
2751: PPUSH
2752: LD_STRING DM-4-start-b
2754: PPUSH
2755: CALL_OW 88
// if Kamil then
2759: LD_EXP 16
2763: IFFALSE 2793
// begin ComTurnUnit ( Kamil , Heike ) ;
2765: LD_EXP 16
2769: PPUSH
2770: LD_EXP 13
2774: PPUSH
2775: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
2779: LD_EXP 16
2783: PPUSH
2784: LD_STRING DKam-1-start-c
2786: PPUSH
2787: CALL_OW 88
// end else
2791: GO 2805
// begin Say ( Mike , DM-5-start-b ) ;
2793: LD_EXP 15
2797: PPUSH
2798: LD_STRING DM-5-start-b
2800: PPUSH
2801: CALL_OW 88
// end ; end else
2805: GO 2903
// if Kamil then
2807: LD_EXP 16
2811: IFFALSE 2891
// begin AddComTurnUnit ( Heike , Kamil ) ;
2813: LD_EXP 13
2817: PPUSH
2818: LD_EXP 16
2822: PPUSH
2823: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
2827: LD_EXP 16
2831: PPUSH
2832: LD_EXP 13
2836: PPUSH
2837: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
2841: LD_EXP 13
2845: PPUSH
2846: LD_STRING DH-1-start-f
2848: PPUSH
2849: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
2853: LD_EXP 16
2857: PPUSH
2858: LD_STRING DKam-1-start-f
2860: PPUSH
2861: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
2865: LD_EXP 13
2869: PPUSH
2870: LD_STRING DH-2-start-f
2872: PPUSH
2873: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
2877: LD_EXP 16
2881: PPUSH
2882: LD_STRING DKam-2-start-f
2884: PPUSH
2885: CALL_OW 88
// end else
2889: GO 2903
// begin Say ( Heike , DH-1-start-d ) ;
2891: LD_EXP 13
2895: PPUSH
2896: LD_STRING DH-1-start-d
2898: PPUSH
2899: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
2903: LD_EXP 13
2907: PUSH
2908: LD_EXP 14
2912: PUSH
2913: LD_EXP 15
2917: PUSH
2918: LD_EXP 16
2922: PUSH
2923: EMPTY
2924: LIST
2925: LIST
2926: LIST
2927: LIST
2928: PPUSH
2929: CALL_OW 139
// InGameOff ;
2933: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
2937: LD_STRING OEast
2939: PPUSH
2940: CALL_OW 337
// wait ( 0 0$20 ) ;
2944: LD_INT 700
2946: PPUSH
2947: CALL_OW 67
// SendSciToForest ;
2951: CALL 1017 0 0
// end ; end_of_file
2955: LD_VAR 0 1
2959: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia ; export function PrepareArabian ; begin
2960: LD_INT 0
2962: PPUSH
// uc_side := 2 ;
2963: LD_ADDR_OWVAR 20
2967: PUSH
2968: LD_INT 2
2970: ST_TO_ADDR
// uc_nation := 2 ;
2971: LD_ADDR_OWVAR 21
2975: PUSH
2976: LD_INT 2
2978: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2979: LD_ADDR_EXP 13
2983: PUSH
2984: LD_STRING Heike
2986: PPUSH
2987: LD_EXP 1
2991: NOT
2992: PPUSH
2993: LD_EXP 2
2997: PPUSH
2998: CALL 141 0 3
3002: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
3003: LD_EXP 13
3007: PPUSH
3008: LD_INT 83
3010: PPUSH
3011: LD_INT 72
3013: PPUSH
3014: LD_INT 0
3016: PPUSH
3017: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
3021: LD_ADDR_EXP 14
3025: PUSH
3026: LD_STRING Givi
3028: PPUSH
3029: LD_EXP 1
3033: NOT
3034: PPUSH
3035: LD_EXP 2
3039: PPUSH
3040: CALL 141 0 3
3044: ST_TO_ADDR
// if Givi then
3045: LD_EXP 14
3049: IFFALSE 3069
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
3051: LD_EXP 14
3055: PPUSH
3056: LD_INT 87
3058: PPUSH
3059: LD_INT 76
3061: PPUSH
3062: LD_INT 0
3064: PPUSH
3065: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
3069: LD_ADDR_EXP 15
3073: PUSH
3074: LD_STRING Mike
3076: PPUSH
3077: LD_EXP 1
3081: NOT
3082: PPUSH
3083: LD_EXP 2
3087: PPUSH
3088: CALL 141 0 3
3092: ST_TO_ADDR
// if Mike then
3093: LD_EXP 15
3097: IFFALSE 3117
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
3099: LD_EXP 15
3103: PPUSH
3104: LD_INT 84
3106: PPUSH
3107: LD_INT 76
3109: PPUSH
3110: LD_INT 0
3112: PPUSH
3113: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
3117: LD_ADDR_EXP 16
3121: PUSH
3122: LD_STRING Kamil
3124: PPUSH
3125: LD_EXP 1
3129: NOT
3130: PPUSH
3131: LD_EXP 2
3135: PPUSH
3136: CALL 141 0 3
3140: ST_TO_ADDR
// if Kamil then
3141: LD_EXP 16
3145: IFFALSE 3165
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
3147: LD_EXP 16
3151: PPUSH
3152: LD_INT 85
3154: PPUSH
3155: LD_INT 78
3157: PPUSH
3158: LD_INT 0
3160: PPUSH
3161: CALL_OW 48
// end ; end_of_file end_of_file
3165: LD_VAR 0 1
3169: RET
// on UnitDestroyed ( un ) do begin if un = Heike then
3170: LD_VAR 0 1
3174: PUSH
3175: LD_EXP 13
3179: EQUAL
3180: IFFALSE 3189
// YouLost ( Heike ) ;
3182: LD_STRING Heike
3184: PPUSH
3185: CALL_OW 104
// end ;
3189: PPOPN 1
3191: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 1 then
3192: LD_VAR 0 1
3196: PUSH
3197: LD_INT 2
3199: EQUAL
3200: PUSH
3201: LD_VAR 0 2
3205: PUSH
3206: LD_INT 1
3208: EQUAL
3209: AND
3210: IFFALSE 3220
// usAlert := true ;
3212: LD_ADDR_EXP 8
3216: PUSH
3217: LD_INT 1
3219: ST_TO_ADDR
// end ; end_of_file
3220: PPOPN 2
3222: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
3223: GO 3225
3225: DISABLE
// begin ru_radar := 98 ;
3226: LD_ADDR_EXP 19
3230: PUSH
3231: LD_INT 98
3233: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
3234: LD_ADDR_EXP 20
3238: PUSH
3239: LD_INT 89
3241: ST_TO_ADDR
// us_hack := 99 ;
3242: LD_ADDR_EXP 21
3246: PUSH
3247: LD_INT 99
3249: ST_TO_ADDR
// us_artillery := 97 ;
3250: LD_ADDR_EXP 22
3254: PUSH
3255: LD_INT 97
3257: ST_TO_ADDR
// ar_bio_bomb := 91 ;
3258: LD_ADDR_EXP 23
3262: PUSH
3263: LD_INT 91
3265: ST_TO_ADDR
// end ; end_of_file end_of_file
3266: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
3267: GO 3269
3269: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
3270: LD_STRING initStreamRollete();
3272: PPUSH
3273: CALL_OW 559
// InitStreamMode ;
3277: CALL 3286 0 0
// DefineStreamItems ( ) ;
3281: CALL 3726 0 0
// end ;
3285: END
// function InitStreamMode ; begin
3286: LD_INT 0
3288: PPUSH
// streamModeActive := false ;
3289: LD_ADDR_EXP 24
3293: PUSH
3294: LD_INT 0
3296: ST_TO_ADDR
// normalCounter := 36 ;
3297: LD_ADDR_EXP 25
3301: PUSH
3302: LD_INT 36
3304: ST_TO_ADDR
// hardcoreCounter := 16 ;
3305: LD_ADDR_EXP 26
3309: PUSH
3310: LD_INT 16
3312: ST_TO_ADDR
// sRocket := false ;
3313: LD_ADDR_EXP 29
3317: PUSH
3318: LD_INT 0
3320: ST_TO_ADDR
// sSpeed := false ;
3321: LD_ADDR_EXP 28
3325: PUSH
3326: LD_INT 0
3328: ST_TO_ADDR
// sEngine := false ;
3329: LD_ADDR_EXP 30
3333: PUSH
3334: LD_INT 0
3336: ST_TO_ADDR
// sSpec := false ;
3337: LD_ADDR_EXP 27
3341: PUSH
3342: LD_INT 0
3344: ST_TO_ADDR
// sLevel := false ;
3345: LD_ADDR_EXP 31
3349: PUSH
3350: LD_INT 0
3352: ST_TO_ADDR
// sArmoury := false ;
3353: LD_ADDR_EXP 32
3357: PUSH
3358: LD_INT 0
3360: ST_TO_ADDR
// sRadar := false ;
3361: LD_ADDR_EXP 33
3365: PUSH
3366: LD_INT 0
3368: ST_TO_ADDR
// sBunker := false ;
3369: LD_ADDR_EXP 34
3373: PUSH
3374: LD_INT 0
3376: ST_TO_ADDR
// sHack := false ;
3377: LD_ADDR_EXP 35
3381: PUSH
3382: LD_INT 0
3384: ST_TO_ADDR
// sFire := false ;
3385: LD_ADDR_EXP 36
3389: PUSH
3390: LD_INT 0
3392: ST_TO_ADDR
// sRefresh := false ;
3393: LD_ADDR_EXP 37
3397: PUSH
3398: LD_INT 0
3400: ST_TO_ADDR
// sExp := false ;
3401: LD_ADDR_EXP 38
3405: PUSH
3406: LD_INT 0
3408: ST_TO_ADDR
// sDepot := false ;
3409: LD_ADDR_EXP 39
3413: PUSH
3414: LD_INT 0
3416: ST_TO_ADDR
// sFlag := false ;
3417: LD_ADDR_EXP 40
3421: PUSH
3422: LD_INT 0
3424: ST_TO_ADDR
// sKamikadze := false ;
3425: LD_ADDR_EXP 48
3429: PUSH
3430: LD_INT 0
3432: ST_TO_ADDR
// sTroll := false ;
3433: LD_ADDR_EXP 49
3437: PUSH
3438: LD_INT 0
3440: ST_TO_ADDR
// sSlow := false ;
3441: LD_ADDR_EXP 50
3445: PUSH
3446: LD_INT 0
3448: ST_TO_ADDR
// sLack := false ;
3449: LD_ADDR_EXP 51
3453: PUSH
3454: LD_INT 0
3456: ST_TO_ADDR
// sTank := false ;
3457: LD_ADDR_EXP 53
3461: PUSH
3462: LD_INT 0
3464: ST_TO_ADDR
// sRemote := false ;
3465: LD_ADDR_EXP 54
3469: PUSH
3470: LD_INT 0
3472: ST_TO_ADDR
// sPowell := false ;
3473: LD_ADDR_EXP 55
3477: PUSH
3478: LD_INT 0
3480: ST_TO_ADDR
// sTeleport := false ;
3481: LD_ADDR_EXP 58
3485: PUSH
3486: LD_INT 0
3488: ST_TO_ADDR
// sOilTower := false ;
3489: LD_ADDR_EXP 60
3493: PUSH
3494: LD_INT 0
3496: ST_TO_ADDR
// sShovel := false ;
3497: LD_ADDR_EXP 61
3501: PUSH
3502: LD_INT 0
3504: ST_TO_ADDR
// sSheik := false ;
3505: LD_ADDR_EXP 62
3509: PUSH
3510: LD_INT 0
3512: ST_TO_ADDR
// sEarthquake := false ;
3513: LD_ADDR_EXP 64
3517: PUSH
3518: LD_INT 0
3520: ST_TO_ADDR
// sAI := false ;
3521: LD_ADDR_EXP 65
3525: PUSH
3526: LD_INT 0
3528: ST_TO_ADDR
// sCargo := false ;
3529: LD_ADDR_EXP 68
3533: PUSH
3534: LD_INT 0
3536: ST_TO_ADDR
// sDLaser := false ;
3537: LD_ADDR_EXP 69
3541: PUSH
3542: LD_INT 0
3544: ST_TO_ADDR
// sExchange := false ;
3545: LD_ADDR_EXP 70
3549: PUSH
3550: LD_INT 0
3552: ST_TO_ADDR
// sFac := false ;
3553: LD_ADDR_EXP 71
3557: PUSH
3558: LD_INT 0
3560: ST_TO_ADDR
// sPower := false ;
3561: LD_ADDR_EXP 72
3565: PUSH
3566: LD_INT 0
3568: ST_TO_ADDR
// sRandom := false ;
3569: LD_ADDR_EXP 73
3573: PUSH
3574: LD_INT 0
3576: ST_TO_ADDR
// sShield := false ;
3577: LD_ADDR_EXP 74
3581: PUSH
3582: LD_INT 0
3584: ST_TO_ADDR
// sTime := false ;
3585: LD_ADDR_EXP 75
3589: PUSH
3590: LD_INT 0
3592: ST_TO_ADDR
// sTools := false ;
3593: LD_ADDR_EXP 76
3597: PUSH
3598: LD_INT 0
3600: ST_TO_ADDR
// sSold := false ;
3601: LD_ADDR_EXP 41
3605: PUSH
3606: LD_INT 0
3608: ST_TO_ADDR
// sDiff := false ;
3609: LD_ADDR_EXP 42
3613: PUSH
3614: LD_INT 0
3616: ST_TO_ADDR
// sFog := false ;
3617: LD_ADDR_EXP 45
3621: PUSH
3622: LD_INT 0
3624: ST_TO_ADDR
// sReset := false ;
3625: LD_ADDR_EXP 46
3629: PUSH
3630: LD_INT 0
3632: ST_TO_ADDR
// sSun := false ;
3633: LD_ADDR_EXP 47
3637: PUSH
3638: LD_INT 0
3640: ST_TO_ADDR
// sTiger := false ;
3641: LD_ADDR_EXP 43
3645: PUSH
3646: LD_INT 0
3648: ST_TO_ADDR
// sBomb := false ;
3649: LD_ADDR_EXP 44
3653: PUSH
3654: LD_INT 0
3656: ST_TO_ADDR
// sWound := false ;
3657: LD_ADDR_EXP 52
3661: PUSH
3662: LD_INT 0
3664: ST_TO_ADDR
// sBetray := false ;
3665: LD_ADDR_EXP 56
3669: PUSH
3670: LD_INT 0
3672: ST_TO_ADDR
// sContamin := false ;
3673: LD_ADDR_EXP 57
3677: PUSH
3678: LD_INT 0
3680: ST_TO_ADDR
// sOil := false ;
3681: LD_ADDR_EXP 59
3685: PUSH
3686: LD_INT 0
3688: ST_TO_ADDR
// sStu := false ;
3689: LD_ADDR_EXP 63
3693: PUSH
3694: LD_INT 0
3696: ST_TO_ADDR
// sBazooka := false ;
3697: LD_ADDR_EXP 66
3701: PUSH
3702: LD_INT 0
3704: ST_TO_ADDR
// sMortar := false ;
3705: LD_ADDR_EXP 67
3709: PUSH
3710: LD_INT 0
3712: ST_TO_ADDR
// sRanger := false ;
3713: LD_ADDR_EXP 77
3717: PUSH
3718: LD_INT 0
3720: ST_TO_ADDR
// end ;
3721: LD_VAR 0 1
3725: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
3726: LD_INT 0
3728: PPUSH
3729: PPUSH
3730: PPUSH
3731: PPUSH
3732: PPUSH
// result := [ ] ;
3733: LD_ADDR_VAR 0 1
3737: PUSH
3738: EMPTY
3739: ST_TO_ADDR
// if campaign_id = 1 then
3740: LD_OWVAR 69
3744: PUSH
3745: LD_INT 1
3747: EQUAL
3748: IFFALSE 6686
// begin case mission_number of 1 :
3750: LD_OWVAR 70
3754: PUSH
3755: LD_INT 1
3757: DOUBLE
3758: EQUAL
3759: IFTRUE 3763
3761: GO 3827
3763: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
3764: LD_ADDR_VAR 0 1
3768: PUSH
3769: LD_INT 2
3771: PUSH
3772: LD_INT 4
3774: PUSH
3775: LD_INT 11
3777: PUSH
3778: LD_INT 12
3780: PUSH
3781: LD_INT 15
3783: PUSH
3784: LD_INT 16
3786: PUSH
3787: LD_INT 22
3789: PUSH
3790: LD_INT 23
3792: PUSH
3793: LD_INT 26
3795: PUSH
3796: EMPTY
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: LIST
3806: PUSH
3807: LD_INT 101
3809: PUSH
3810: LD_INT 102
3812: PUSH
3813: LD_INT 106
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: LIST
3820: PUSH
3821: EMPTY
3822: LIST
3823: LIST
3824: ST_TO_ADDR
3825: GO 6684
3827: LD_INT 2
3829: DOUBLE
3830: EQUAL
3831: IFTRUE 3835
3833: GO 3907
3835: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
3836: LD_ADDR_VAR 0 1
3840: PUSH
3841: LD_INT 2
3843: PUSH
3844: LD_INT 4
3846: PUSH
3847: LD_INT 11
3849: PUSH
3850: LD_INT 12
3852: PUSH
3853: LD_INT 15
3855: PUSH
3856: LD_INT 16
3858: PUSH
3859: LD_INT 22
3861: PUSH
3862: LD_INT 23
3864: PUSH
3865: LD_INT 26
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: LIST
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: PUSH
3879: LD_INT 101
3881: PUSH
3882: LD_INT 102
3884: PUSH
3885: LD_INT 105
3887: PUSH
3888: LD_INT 106
3890: PUSH
3891: LD_INT 108
3893: PUSH
3894: EMPTY
3895: LIST
3896: LIST
3897: LIST
3898: LIST
3899: LIST
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: ST_TO_ADDR
3905: GO 6684
3907: LD_INT 3
3909: DOUBLE
3910: EQUAL
3911: IFTRUE 3915
3913: GO 3991
3915: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
3916: LD_ADDR_VAR 0 1
3920: PUSH
3921: LD_INT 2
3923: PUSH
3924: LD_INT 4
3926: PUSH
3927: LD_INT 5
3929: PUSH
3930: LD_INT 11
3932: PUSH
3933: LD_INT 12
3935: PUSH
3936: LD_INT 15
3938: PUSH
3939: LD_INT 16
3941: PUSH
3942: LD_INT 22
3944: PUSH
3945: LD_INT 26
3947: PUSH
3948: LD_INT 36
3950: PUSH
3951: EMPTY
3952: LIST
3953: LIST
3954: LIST
3955: LIST
3956: LIST
3957: LIST
3958: LIST
3959: LIST
3960: LIST
3961: LIST
3962: PUSH
3963: LD_INT 101
3965: PUSH
3966: LD_INT 102
3968: PUSH
3969: LD_INT 105
3971: PUSH
3972: LD_INT 106
3974: PUSH
3975: LD_INT 108
3977: PUSH
3978: EMPTY
3979: LIST
3980: LIST
3981: LIST
3982: LIST
3983: LIST
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: ST_TO_ADDR
3989: GO 6684
3991: LD_INT 4
3993: DOUBLE
3994: EQUAL
3995: IFTRUE 3999
3997: GO 4083
3999: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
4000: LD_ADDR_VAR 0 1
4004: PUSH
4005: LD_INT 2
4007: PUSH
4008: LD_INT 4
4010: PUSH
4011: LD_INT 5
4013: PUSH
4014: LD_INT 8
4016: PUSH
4017: LD_INT 11
4019: PUSH
4020: LD_INT 12
4022: PUSH
4023: LD_INT 15
4025: PUSH
4026: LD_INT 16
4028: PUSH
4029: LD_INT 22
4031: PUSH
4032: LD_INT 23
4034: PUSH
4035: LD_INT 26
4037: PUSH
4038: LD_INT 36
4040: PUSH
4041: EMPTY
4042: LIST
4043: LIST
4044: LIST
4045: LIST
4046: LIST
4047: LIST
4048: LIST
4049: LIST
4050: LIST
4051: LIST
4052: LIST
4053: LIST
4054: PUSH
4055: LD_INT 101
4057: PUSH
4058: LD_INT 102
4060: PUSH
4061: LD_INT 105
4063: PUSH
4064: LD_INT 106
4066: PUSH
4067: LD_INT 108
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: LIST
4076: PUSH
4077: EMPTY
4078: LIST
4079: LIST
4080: ST_TO_ADDR
4081: GO 6684
4083: LD_INT 5
4085: DOUBLE
4086: EQUAL
4087: IFTRUE 4091
4089: GO 4191
4091: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
4092: LD_ADDR_VAR 0 1
4096: PUSH
4097: LD_INT 2
4099: PUSH
4100: LD_INT 4
4102: PUSH
4103: LD_INT 5
4105: PUSH
4106: LD_INT 6
4108: PUSH
4109: LD_INT 8
4111: PUSH
4112: LD_INT 11
4114: PUSH
4115: LD_INT 12
4117: PUSH
4118: LD_INT 15
4120: PUSH
4121: LD_INT 16
4123: PUSH
4124: LD_INT 22
4126: PUSH
4127: LD_INT 23
4129: PUSH
4130: LD_INT 25
4132: PUSH
4133: LD_INT 26
4135: PUSH
4136: LD_INT 36
4138: PUSH
4139: EMPTY
4140: LIST
4141: LIST
4142: LIST
4143: LIST
4144: LIST
4145: LIST
4146: LIST
4147: LIST
4148: LIST
4149: LIST
4150: LIST
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: LD_INT 101
4157: PUSH
4158: LD_INT 102
4160: PUSH
4161: LD_INT 105
4163: PUSH
4164: LD_INT 106
4166: PUSH
4167: LD_INT 108
4169: PUSH
4170: LD_INT 109
4172: PUSH
4173: LD_INT 112
4175: PUSH
4176: EMPTY
4177: LIST
4178: LIST
4179: LIST
4180: LIST
4181: LIST
4182: LIST
4183: LIST
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: ST_TO_ADDR
4189: GO 6684
4191: LD_INT 6
4193: DOUBLE
4194: EQUAL
4195: IFTRUE 4199
4197: GO 4319
4199: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
4200: LD_ADDR_VAR 0 1
4204: PUSH
4205: LD_INT 2
4207: PUSH
4208: LD_INT 4
4210: PUSH
4211: LD_INT 5
4213: PUSH
4214: LD_INT 6
4216: PUSH
4217: LD_INT 8
4219: PUSH
4220: LD_INT 11
4222: PUSH
4223: LD_INT 12
4225: PUSH
4226: LD_INT 15
4228: PUSH
4229: LD_INT 16
4231: PUSH
4232: LD_INT 20
4234: PUSH
4235: LD_INT 21
4237: PUSH
4238: LD_INT 22
4240: PUSH
4241: LD_INT 23
4243: PUSH
4244: LD_INT 25
4246: PUSH
4247: LD_INT 26
4249: PUSH
4250: LD_INT 30
4252: PUSH
4253: LD_INT 31
4255: PUSH
4256: LD_INT 32
4258: PUSH
4259: LD_INT 36
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: LIST
4272: LIST
4273: LIST
4274: LIST
4275: LIST
4276: LIST
4277: LIST
4278: LIST
4279: LIST
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 101
4285: PUSH
4286: LD_INT 102
4288: PUSH
4289: LD_INT 105
4291: PUSH
4292: LD_INT 106
4294: PUSH
4295: LD_INT 108
4297: PUSH
4298: LD_INT 109
4300: PUSH
4301: LD_INT 112
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: LIST
4308: LIST
4309: LIST
4310: LIST
4311: LIST
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: ST_TO_ADDR
4317: GO 6684
4319: LD_INT 7
4321: DOUBLE
4322: EQUAL
4323: IFTRUE 4327
4325: GO 4427
4327: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
4328: LD_ADDR_VAR 0 1
4332: PUSH
4333: LD_INT 2
4335: PUSH
4336: LD_INT 4
4338: PUSH
4339: LD_INT 5
4341: PUSH
4342: LD_INT 7
4344: PUSH
4345: LD_INT 11
4347: PUSH
4348: LD_INT 12
4350: PUSH
4351: LD_INT 15
4353: PUSH
4354: LD_INT 16
4356: PUSH
4357: LD_INT 20
4359: PUSH
4360: LD_INT 21
4362: PUSH
4363: LD_INT 22
4365: PUSH
4366: LD_INT 23
4368: PUSH
4369: LD_INT 25
4371: PUSH
4372: LD_INT 26
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: LIST
4379: LIST
4380: LIST
4381: LIST
4382: LIST
4383: LIST
4384: LIST
4385: LIST
4386: LIST
4387: LIST
4388: LIST
4389: LIST
4390: PUSH
4391: LD_INT 101
4393: PUSH
4394: LD_INT 102
4396: PUSH
4397: LD_INT 103
4399: PUSH
4400: LD_INT 105
4402: PUSH
4403: LD_INT 106
4405: PUSH
4406: LD_INT 108
4408: PUSH
4409: LD_INT 112
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: LIST
4416: LIST
4417: LIST
4418: LIST
4419: LIST
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: ST_TO_ADDR
4425: GO 6684
4427: LD_INT 8
4429: DOUBLE
4430: EQUAL
4431: IFTRUE 4435
4433: GO 4563
4435: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
4436: LD_ADDR_VAR 0 1
4440: PUSH
4441: LD_INT 2
4443: PUSH
4444: LD_INT 4
4446: PUSH
4447: LD_INT 5
4449: PUSH
4450: LD_INT 6
4452: PUSH
4453: LD_INT 7
4455: PUSH
4456: LD_INT 8
4458: PUSH
4459: LD_INT 11
4461: PUSH
4462: LD_INT 12
4464: PUSH
4465: LD_INT 15
4467: PUSH
4468: LD_INT 16
4470: PUSH
4471: LD_INT 20
4473: PUSH
4474: LD_INT 21
4476: PUSH
4477: LD_INT 22
4479: PUSH
4480: LD_INT 23
4482: PUSH
4483: LD_INT 25
4485: PUSH
4486: LD_INT 26
4488: PUSH
4489: LD_INT 30
4491: PUSH
4492: LD_INT 31
4494: PUSH
4495: LD_INT 32
4497: PUSH
4498: LD_INT 36
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: LIST
4505: LIST
4506: LIST
4507: LIST
4508: LIST
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 101
4525: PUSH
4526: LD_INT 102
4528: PUSH
4529: LD_INT 103
4531: PUSH
4532: LD_INT 105
4534: PUSH
4535: LD_INT 106
4537: PUSH
4538: LD_INT 108
4540: PUSH
4541: LD_INT 109
4543: PUSH
4544: LD_INT 112
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: LIST
4553: LIST
4554: LIST
4555: LIST
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: ST_TO_ADDR
4561: GO 6684
4563: LD_INT 9
4565: DOUBLE
4566: EQUAL
4567: IFTRUE 4571
4569: GO 4707
4571: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
4572: LD_ADDR_VAR 0 1
4576: PUSH
4577: LD_INT 2
4579: PUSH
4580: LD_INT 4
4582: PUSH
4583: LD_INT 5
4585: PUSH
4586: LD_INT 6
4588: PUSH
4589: LD_INT 7
4591: PUSH
4592: LD_INT 8
4594: PUSH
4595: LD_INT 11
4597: PUSH
4598: LD_INT 12
4600: PUSH
4601: LD_INT 15
4603: PUSH
4604: LD_INT 16
4606: PUSH
4607: LD_INT 20
4609: PUSH
4610: LD_INT 21
4612: PUSH
4613: LD_INT 22
4615: PUSH
4616: LD_INT 23
4618: PUSH
4619: LD_INT 25
4621: PUSH
4622: LD_INT 26
4624: PUSH
4625: LD_INT 28
4627: PUSH
4628: LD_INT 30
4630: PUSH
4631: LD_INT 31
4633: PUSH
4634: LD_INT 32
4636: PUSH
4637: LD_INT 36
4639: PUSH
4640: EMPTY
4641: LIST
4642: LIST
4643: LIST
4644: LIST
4645: LIST
4646: LIST
4647: LIST
4648: LIST
4649: LIST
4650: LIST
4651: LIST
4652: LIST
4653: LIST
4654: LIST
4655: LIST
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 101
4665: PUSH
4666: LD_INT 102
4668: PUSH
4669: LD_INT 103
4671: PUSH
4672: LD_INT 105
4674: PUSH
4675: LD_INT 106
4677: PUSH
4678: LD_INT 108
4680: PUSH
4681: LD_INT 109
4683: PUSH
4684: LD_INT 112
4686: PUSH
4687: LD_INT 114
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: LIST
4694: LIST
4695: LIST
4696: LIST
4697: LIST
4698: LIST
4699: LIST
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: ST_TO_ADDR
4705: GO 6684
4707: LD_INT 10
4709: DOUBLE
4710: EQUAL
4711: IFTRUE 4715
4713: GO 4899
4715: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
4716: LD_ADDR_VAR 0 1
4720: PUSH
4721: LD_INT 2
4723: PUSH
4724: LD_INT 4
4726: PUSH
4727: LD_INT 5
4729: PUSH
4730: LD_INT 6
4732: PUSH
4733: LD_INT 7
4735: PUSH
4736: LD_INT 8
4738: PUSH
4739: LD_INT 9
4741: PUSH
4742: LD_INT 10
4744: PUSH
4745: LD_INT 11
4747: PUSH
4748: LD_INT 12
4750: PUSH
4751: LD_INT 13
4753: PUSH
4754: LD_INT 14
4756: PUSH
4757: LD_INT 15
4759: PUSH
4760: LD_INT 16
4762: PUSH
4763: LD_INT 17
4765: PUSH
4766: LD_INT 18
4768: PUSH
4769: LD_INT 19
4771: PUSH
4772: LD_INT 20
4774: PUSH
4775: LD_INT 21
4777: PUSH
4778: LD_INT 22
4780: PUSH
4781: LD_INT 23
4783: PUSH
4784: LD_INT 24
4786: PUSH
4787: LD_INT 25
4789: PUSH
4790: LD_INT 26
4792: PUSH
4793: LD_INT 28
4795: PUSH
4796: LD_INT 30
4798: PUSH
4799: LD_INT 31
4801: PUSH
4802: LD_INT 32
4804: PUSH
4805: LD_INT 36
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: LIST
4812: LIST
4813: LIST
4814: LIST
4815: LIST
4816: LIST
4817: LIST
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: LIST
4834: LIST
4835: LIST
4836: LIST
4837: LIST
4838: PUSH
4839: LD_INT 101
4841: PUSH
4842: LD_INT 102
4844: PUSH
4845: LD_INT 103
4847: PUSH
4848: LD_INT 104
4850: PUSH
4851: LD_INT 105
4853: PUSH
4854: LD_INT 106
4856: PUSH
4857: LD_INT 107
4859: PUSH
4860: LD_INT 108
4862: PUSH
4863: LD_INT 109
4865: PUSH
4866: LD_INT 110
4868: PUSH
4869: LD_INT 111
4871: PUSH
4872: LD_INT 112
4874: PUSH
4875: LD_INT 114
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: LIST
4890: LIST
4891: LIST
4892: PUSH
4893: EMPTY
4894: LIST
4895: LIST
4896: ST_TO_ADDR
4897: GO 6684
4899: LD_INT 11
4901: DOUBLE
4902: EQUAL
4903: IFTRUE 4907
4905: GO 5099
4907: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
4908: LD_ADDR_VAR 0 1
4912: PUSH
4913: LD_INT 2
4915: PUSH
4916: LD_INT 3
4918: PUSH
4919: LD_INT 4
4921: PUSH
4922: LD_INT 5
4924: PUSH
4925: LD_INT 6
4927: PUSH
4928: LD_INT 7
4930: PUSH
4931: LD_INT 8
4933: PUSH
4934: LD_INT 9
4936: PUSH
4937: LD_INT 10
4939: PUSH
4940: LD_INT 11
4942: PUSH
4943: LD_INT 12
4945: PUSH
4946: LD_INT 13
4948: PUSH
4949: LD_INT 14
4951: PUSH
4952: LD_INT 15
4954: PUSH
4955: LD_INT 16
4957: PUSH
4958: LD_INT 17
4960: PUSH
4961: LD_INT 18
4963: PUSH
4964: LD_INT 19
4966: PUSH
4967: LD_INT 20
4969: PUSH
4970: LD_INT 21
4972: PUSH
4973: LD_INT 22
4975: PUSH
4976: LD_INT 23
4978: PUSH
4979: LD_INT 24
4981: PUSH
4982: LD_INT 25
4984: PUSH
4985: LD_INT 26
4987: PUSH
4988: LD_INT 28
4990: PUSH
4991: LD_INT 30
4993: PUSH
4994: LD_INT 31
4996: PUSH
4997: LD_INT 32
4999: PUSH
5000: LD_INT 34
5002: PUSH
5003: LD_INT 36
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: LIST
5023: LIST
5024: LIST
5025: LIST
5026: LIST
5027: LIST
5028: LIST
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: LIST
5037: LIST
5038: PUSH
5039: LD_INT 101
5041: PUSH
5042: LD_INT 102
5044: PUSH
5045: LD_INT 103
5047: PUSH
5048: LD_INT 104
5050: PUSH
5051: LD_INT 105
5053: PUSH
5054: LD_INT 106
5056: PUSH
5057: LD_INT 107
5059: PUSH
5060: LD_INT 108
5062: PUSH
5063: LD_INT 109
5065: PUSH
5066: LD_INT 110
5068: PUSH
5069: LD_INT 111
5071: PUSH
5072: LD_INT 112
5074: PUSH
5075: LD_INT 114
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: LIST
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: LIST
5090: LIST
5091: LIST
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: ST_TO_ADDR
5097: GO 6684
5099: LD_INT 12
5101: DOUBLE
5102: EQUAL
5103: IFTRUE 5107
5105: GO 5315
5107: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
5108: LD_ADDR_VAR 0 1
5112: PUSH
5113: LD_INT 1
5115: PUSH
5116: LD_INT 2
5118: PUSH
5119: LD_INT 3
5121: PUSH
5122: LD_INT 4
5124: PUSH
5125: LD_INT 5
5127: PUSH
5128: LD_INT 6
5130: PUSH
5131: LD_INT 7
5133: PUSH
5134: LD_INT 8
5136: PUSH
5137: LD_INT 9
5139: PUSH
5140: LD_INT 10
5142: PUSH
5143: LD_INT 11
5145: PUSH
5146: LD_INT 12
5148: PUSH
5149: LD_INT 13
5151: PUSH
5152: LD_INT 14
5154: PUSH
5155: LD_INT 15
5157: PUSH
5158: LD_INT 16
5160: PUSH
5161: LD_INT 17
5163: PUSH
5164: LD_INT 18
5166: PUSH
5167: LD_INT 19
5169: PUSH
5170: LD_INT 20
5172: PUSH
5173: LD_INT 21
5175: PUSH
5176: LD_INT 22
5178: PUSH
5179: LD_INT 23
5181: PUSH
5182: LD_INT 24
5184: PUSH
5185: LD_INT 25
5187: PUSH
5188: LD_INT 26
5190: PUSH
5191: LD_INT 27
5193: PUSH
5194: LD_INT 28
5196: PUSH
5197: LD_INT 30
5199: PUSH
5200: LD_INT 31
5202: PUSH
5203: LD_INT 32
5205: PUSH
5206: LD_INT 33
5208: PUSH
5209: LD_INT 34
5211: PUSH
5212: LD_INT 36
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: LIST
5221: LIST
5222: LIST
5223: LIST
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: LIST
5249: LIST
5250: PUSH
5251: LD_INT 101
5253: PUSH
5254: LD_INT 102
5256: PUSH
5257: LD_INT 103
5259: PUSH
5260: LD_INT 104
5262: PUSH
5263: LD_INT 105
5265: PUSH
5266: LD_INT 106
5268: PUSH
5269: LD_INT 107
5271: PUSH
5272: LD_INT 108
5274: PUSH
5275: LD_INT 109
5277: PUSH
5278: LD_INT 110
5280: PUSH
5281: LD_INT 111
5283: PUSH
5284: LD_INT 112
5286: PUSH
5287: LD_INT 113
5289: PUSH
5290: LD_INT 114
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: LIST
5300: LIST
5301: LIST
5302: LIST
5303: LIST
5304: LIST
5305: LIST
5306: LIST
5307: LIST
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: ST_TO_ADDR
5313: GO 6684
5315: LD_INT 13
5317: DOUBLE
5318: EQUAL
5319: IFTRUE 5323
5321: GO 5519
5323: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
5324: LD_ADDR_VAR 0 1
5328: PUSH
5329: LD_INT 1
5331: PUSH
5332: LD_INT 2
5334: PUSH
5335: LD_INT 3
5337: PUSH
5338: LD_INT 4
5340: PUSH
5341: LD_INT 5
5343: PUSH
5344: LD_INT 8
5346: PUSH
5347: LD_INT 9
5349: PUSH
5350: LD_INT 10
5352: PUSH
5353: LD_INT 11
5355: PUSH
5356: LD_INT 12
5358: PUSH
5359: LD_INT 14
5361: PUSH
5362: LD_INT 15
5364: PUSH
5365: LD_INT 16
5367: PUSH
5368: LD_INT 17
5370: PUSH
5371: LD_INT 18
5373: PUSH
5374: LD_INT 19
5376: PUSH
5377: LD_INT 20
5379: PUSH
5380: LD_INT 21
5382: PUSH
5383: LD_INT 22
5385: PUSH
5386: LD_INT 23
5388: PUSH
5389: LD_INT 24
5391: PUSH
5392: LD_INT 25
5394: PUSH
5395: LD_INT 26
5397: PUSH
5398: LD_INT 27
5400: PUSH
5401: LD_INT 28
5403: PUSH
5404: LD_INT 30
5406: PUSH
5407: LD_INT 31
5409: PUSH
5410: LD_INT 32
5412: PUSH
5413: LD_INT 33
5415: PUSH
5416: LD_INT 34
5418: PUSH
5419: LD_INT 36
5421: PUSH
5422: EMPTY
5423: LIST
5424: LIST
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: LIST
5430: LIST
5431: LIST
5432: LIST
5433: LIST
5434: LIST
5435: LIST
5436: LIST
5437: LIST
5438: LIST
5439: LIST
5440: LIST
5441: LIST
5442: LIST
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: PUSH
5455: LD_INT 101
5457: PUSH
5458: LD_INT 102
5460: PUSH
5461: LD_INT 103
5463: PUSH
5464: LD_INT 104
5466: PUSH
5467: LD_INT 105
5469: PUSH
5470: LD_INT 106
5472: PUSH
5473: LD_INT 107
5475: PUSH
5476: LD_INT 108
5478: PUSH
5479: LD_INT 109
5481: PUSH
5482: LD_INT 110
5484: PUSH
5485: LD_INT 111
5487: PUSH
5488: LD_INT 112
5490: PUSH
5491: LD_INT 113
5493: PUSH
5494: LD_INT 114
5496: PUSH
5497: EMPTY
5498: LIST
5499: LIST
5500: LIST
5501: LIST
5502: LIST
5503: LIST
5504: LIST
5505: LIST
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: ST_TO_ADDR
5517: GO 6684
5519: LD_INT 14
5521: DOUBLE
5522: EQUAL
5523: IFTRUE 5527
5525: GO 5739
5527: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
5528: LD_ADDR_VAR 0 1
5532: PUSH
5533: LD_INT 1
5535: PUSH
5536: LD_INT 2
5538: PUSH
5539: LD_INT 3
5541: PUSH
5542: LD_INT 4
5544: PUSH
5545: LD_INT 5
5547: PUSH
5548: LD_INT 6
5550: PUSH
5551: LD_INT 7
5553: PUSH
5554: LD_INT 8
5556: PUSH
5557: LD_INT 9
5559: PUSH
5560: LD_INT 10
5562: PUSH
5563: LD_INT 11
5565: PUSH
5566: LD_INT 12
5568: PUSH
5569: LD_INT 13
5571: PUSH
5572: LD_INT 14
5574: PUSH
5575: LD_INT 15
5577: PUSH
5578: LD_INT 16
5580: PUSH
5581: LD_INT 17
5583: PUSH
5584: LD_INT 18
5586: PUSH
5587: LD_INT 19
5589: PUSH
5590: LD_INT 20
5592: PUSH
5593: LD_INT 21
5595: PUSH
5596: LD_INT 22
5598: PUSH
5599: LD_INT 23
5601: PUSH
5602: LD_INT 24
5604: PUSH
5605: LD_INT 25
5607: PUSH
5608: LD_INT 26
5610: PUSH
5611: LD_INT 27
5613: PUSH
5614: LD_INT 28
5616: PUSH
5617: LD_INT 29
5619: PUSH
5620: LD_INT 30
5622: PUSH
5623: LD_INT 31
5625: PUSH
5626: LD_INT 32
5628: PUSH
5629: LD_INT 33
5631: PUSH
5632: LD_INT 34
5634: PUSH
5635: LD_INT 36
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: LIST
5644: LIST
5645: LIST
5646: LIST
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: LIST
5661: LIST
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 101
5677: PUSH
5678: LD_INT 102
5680: PUSH
5681: LD_INT 103
5683: PUSH
5684: LD_INT 104
5686: PUSH
5687: LD_INT 105
5689: PUSH
5690: LD_INT 106
5692: PUSH
5693: LD_INT 107
5695: PUSH
5696: LD_INT 108
5698: PUSH
5699: LD_INT 109
5701: PUSH
5702: LD_INT 110
5704: PUSH
5705: LD_INT 111
5707: PUSH
5708: LD_INT 112
5710: PUSH
5711: LD_INT 113
5713: PUSH
5714: LD_INT 114
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: LIST
5721: LIST
5722: LIST
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: LIST
5729: LIST
5730: LIST
5731: LIST
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: ST_TO_ADDR
5737: GO 6684
5739: LD_INT 15
5741: DOUBLE
5742: EQUAL
5743: IFTRUE 5747
5745: GO 5959
5747: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
5748: LD_ADDR_VAR 0 1
5752: PUSH
5753: LD_INT 1
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 3
5761: PUSH
5762: LD_INT 4
5764: PUSH
5765: LD_INT 5
5767: PUSH
5768: LD_INT 6
5770: PUSH
5771: LD_INT 7
5773: PUSH
5774: LD_INT 8
5776: PUSH
5777: LD_INT 9
5779: PUSH
5780: LD_INT 10
5782: PUSH
5783: LD_INT 11
5785: PUSH
5786: LD_INT 12
5788: PUSH
5789: LD_INT 13
5791: PUSH
5792: LD_INT 14
5794: PUSH
5795: LD_INT 15
5797: PUSH
5798: LD_INT 16
5800: PUSH
5801: LD_INT 17
5803: PUSH
5804: LD_INT 18
5806: PUSH
5807: LD_INT 19
5809: PUSH
5810: LD_INT 20
5812: PUSH
5813: LD_INT 21
5815: PUSH
5816: LD_INT 22
5818: PUSH
5819: LD_INT 23
5821: PUSH
5822: LD_INT 24
5824: PUSH
5825: LD_INT 25
5827: PUSH
5828: LD_INT 26
5830: PUSH
5831: LD_INT 27
5833: PUSH
5834: LD_INT 28
5836: PUSH
5837: LD_INT 29
5839: PUSH
5840: LD_INT 30
5842: PUSH
5843: LD_INT 31
5845: PUSH
5846: LD_INT 32
5848: PUSH
5849: LD_INT 33
5851: PUSH
5852: LD_INT 34
5854: PUSH
5855: LD_INT 36
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: LIST
5864: LIST
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: LIST
5876: LIST
5877: LIST
5878: LIST
5879: LIST
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: LIST
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 101
5897: PUSH
5898: LD_INT 102
5900: PUSH
5901: LD_INT 103
5903: PUSH
5904: LD_INT 104
5906: PUSH
5907: LD_INT 105
5909: PUSH
5910: LD_INT 106
5912: PUSH
5913: LD_INT 107
5915: PUSH
5916: LD_INT 108
5918: PUSH
5919: LD_INT 109
5921: PUSH
5922: LD_INT 110
5924: PUSH
5925: LD_INT 111
5927: PUSH
5928: LD_INT 112
5930: PUSH
5931: LD_INT 113
5933: PUSH
5934: LD_INT 114
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: LIST
5944: LIST
5945: LIST
5946: LIST
5947: LIST
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: ST_TO_ADDR
5957: GO 6684
5959: LD_INT 16
5961: DOUBLE
5962: EQUAL
5963: IFTRUE 5967
5965: GO 6091
5967: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
5968: LD_ADDR_VAR 0 1
5972: PUSH
5973: LD_INT 2
5975: PUSH
5976: LD_INT 4
5978: PUSH
5979: LD_INT 5
5981: PUSH
5982: LD_INT 7
5984: PUSH
5985: LD_INT 11
5987: PUSH
5988: LD_INT 12
5990: PUSH
5991: LD_INT 15
5993: PUSH
5994: LD_INT 16
5996: PUSH
5997: LD_INT 20
5999: PUSH
6000: LD_INT 21
6002: PUSH
6003: LD_INT 22
6005: PUSH
6006: LD_INT 23
6008: PUSH
6009: LD_INT 25
6011: PUSH
6012: LD_INT 26
6014: PUSH
6015: LD_INT 30
6017: PUSH
6018: LD_INT 31
6020: PUSH
6021: LD_INT 32
6023: PUSH
6024: LD_INT 33
6026: PUSH
6027: LD_INT 34
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: LIST
6048: LIST
6049: LIST
6050: PUSH
6051: LD_INT 101
6053: PUSH
6054: LD_INT 102
6056: PUSH
6057: LD_INT 103
6059: PUSH
6060: LD_INT 106
6062: PUSH
6063: LD_INT 108
6065: PUSH
6066: LD_INT 112
6068: PUSH
6069: LD_INT 113
6071: PUSH
6072: LD_INT 114
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: LIST
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: ST_TO_ADDR
6089: GO 6684
6091: LD_INT 17
6093: DOUBLE
6094: EQUAL
6095: IFTRUE 6099
6097: GO 6311
6099: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
6100: LD_ADDR_VAR 0 1
6104: PUSH
6105: LD_INT 1
6107: PUSH
6108: LD_INT 2
6110: PUSH
6111: LD_INT 3
6113: PUSH
6114: LD_INT 4
6116: PUSH
6117: LD_INT 5
6119: PUSH
6120: LD_INT 6
6122: PUSH
6123: LD_INT 7
6125: PUSH
6126: LD_INT 8
6128: PUSH
6129: LD_INT 9
6131: PUSH
6132: LD_INT 10
6134: PUSH
6135: LD_INT 11
6137: PUSH
6138: LD_INT 12
6140: PUSH
6141: LD_INT 13
6143: PUSH
6144: LD_INT 14
6146: PUSH
6147: LD_INT 15
6149: PUSH
6150: LD_INT 16
6152: PUSH
6153: LD_INT 17
6155: PUSH
6156: LD_INT 18
6158: PUSH
6159: LD_INT 19
6161: PUSH
6162: LD_INT 20
6164: PUSH
6165: LD_INT 21
6167: PUSH
6168: LD_INT 22
6170: PUSH
6171: LD_INT 23
6173: PUSH
6174: LD_INT 24
6176: PUSH
6177: LD_INT 25
6179: PUSH
6180: LD_INT 26
6182: PUSH
6183: LD_INT 27
6185: PUSH
6186: LD_INT 28
6188: PUSH
6189: LD_INT 29
6191: PUSH
6192: LD_INT 30
6194: PUSH
6195: LD_INT 31
6197: PUSH
6198: LD_INT 32
6200: PUSH
6201: LD_INT 33
6203: PUSH
6204: LD_INT 34
6206: PUSH
6207: LD_INT 36
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: LIST
6220: LIST
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: LIST
6227: LIST
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: LIST
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: LIST
6245: LIST
6246: PUSH
6247: LD_INT 101
6249: PUSH
6250: LD_INT 102
6252: PUSH
6253: LD_INT 103
6255: PUSH
6256: LD_INT 104
6258: PUSH
6259: LD_INT 105
6261: PUSH
6262: LD_INT 106
6264: PUSH
6265: LD_INT 107
6267: PUSH
6268: LD_INT 108
6270: PUSH
6271: LD_INT 109
6273: PUSH
6274: LD_INT 110
6276: PUSH
6277: LD_INT 111
6279: PUSH
6280: LD_INT 112
6282: PUSH
6283: LD_INT 113
6285: PUSH
6286: LD_INT 114
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: LIST
6297: LIST
6298: LIST
6299: LIST
6300: LIST
6301: LIST
6302: LIST
6303: LIST
6304: PUSH
6305: EMPTY
6306: LIST
6307: LIST
6308: ST_TO_ADDR
6309: GO 6684
6311: LD_INT 18
6313: DOUBLE
6314: EQUAL
6315: IFTRUE 6319
6317: GO 6455
6319: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
6320: LD_ADDR_VAR 0 1
6324: PUSH
6325: LD_INT 2
6327: PUSH
6328: LD_INT 4
6330: PUSH
6331: LD_INT 5
6333: PUSH
6334: LD_INT 7
6336: PUSH
6337: LD_INT 11
6339: PUSH
6340: LD_INT 12
6342: PUSH
6343: LD_INT 15
6345: PUSH
6346: LD_INT 16
6348: PUSH
6349: LD_INT 20
6351: PUSH
6352: LD_INT 21
6354: PUSH
6355: LD_INT 22
6357: PUSH
6358: LD_INT 23
6360: PUSH
6361: LD_INT 25
6363: PUSH
6364: LD_INT 26
6366: PUSH
6367: LD_INT 30
6369: PUSH
6370: LD_INT 31
6372: PUSH
6373: LD_INT 32
6375: PUSH
6376: LD_INT 33
6378: PUSH
6379: LD_INT 34
6381: PUSH
6382: LD_INT 35
6384: PUSH
6385: LD_INT 36
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: LIST
6392: LIST
6393: LIST
6394: LIST
6395: LIST
6396: LIST
6397: LIST
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: LIST
6406: LIST
6407: LIST
6408: LIST
6409: LIST
6410: PUSH
6411: LD_INT 101
6413: PUSH
6414: LD_INT 102
6416: PUSH
6417: LD_INT 103
6419: PUSH
6420: LD_INT 106
6422: PUSH
6423: LD_INT 108
6425: PUSH
6426: LD_INT 112
6428: PUSH
6429: LD_INT 113
6431: PUSH
6432: LD_INT 114
6434: PUSH
6435: LD_INT 115
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: LIST
6446: LIST
6447: LIST
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: ST_TO_ADDR
6453: GO 6684
6455: LD_INT 19
6457: DOUBLE
6458: EQUAL
6459: IFTRUE 6463
6461: GO 6683
6463: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
6464: LD_ADDR_VAR 0 1
6468: PUSH
6469: LD_INT 1
6471: PUSH
6472: LD_INT 2
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 4
6480: PUSH
6481: LD_INT 5
6483: PUSH
6484: LD_INT 6
6486: PUSH
6487: LD_INT 7
6489: PUSH
6490: LD_INT 8
6492: PUSH
6493: LD_INT 9
6495: PUSH
6496: LD_INT 10
6498: PUSH
6499: LD_INT 11
6501: PUSH
6502: LD_INT 12
6504: PUSH
6505: LD_INT 13
6507: PUSH
6508: LD_INT 14
6510: PUSH
6511: LD_INT 15
6513: PUSH
6514: LD_INT 16
6516: PUSH
6517: LD_INT 17
6519: PUSH
6520: LD_INT 18
6522: PUSH
6523: LD_INT 19
6525: PUSH
6526: LD_INT 20
6528: PUSH
6529: LD_INT 21
6531: PUSH
6532: LD_INT 22
6534: PUSH
6535: LD_INT 23
6537: PUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 25
6543: PUSH
6544: LD_INT 26
6546: PUSH
6547: LD_INT 27
6549: PUSH
6550: LD_INT 28
6552: PUSH
6553: LD_INT 29
6555: PUSH
6556: LD_INT 30
6558: PUSH
6559: LD_INT 31
6561: PUSH
6562: LD_INT 32
6564: PUSH
6565: LD_INT 33
6567: PUSH
6568: LD_INT 34
6570: PUSH
6571: LD_INT 35
6573: PUSH
6574: LD_INT 36
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: LIST
6581: LIST
6582: LIST
6583: LIST
6584: LIST
6585: LIST
6586: LIST
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: LIST
6592: LIST
6593: LIST
6594: LIST
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: LIST
6606: LIST
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: LIST
6612: LIST
6613: LIST
6614: PUSH
6615: LD_INT 101
6617: PUSH
6618: LD_INT 102
6620: PUSH
6621: LD_INT 103
6623: PUSH
6624: LD_INT 104
6626: PUSH
6627: LD_INT 105
6629: PUSH
6630: LD_INT 106
6632: PUSH
6633: LD_INT 107
6635: PUSH
6636: LD_INT 108
6638: PUSH
6639: LD_INT 109
6641: PUSH
6642: LD_INT 110
6644: PUSH
6645: LD_INT 111
6647: PUSH
6648: LD_INT 112
6650: PUSH
6651: LD_INT 113
6653: PUSH
6654: LD_INT 114
6656: PUSH
6657: LD_INT 115
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: LIST
6664: LIST
6665: LIST
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: ST_TO_ADDR
6681: GO 6684
6683: POP
// end else
6684: GO 6721
// if campaign_id = 5 then
6686: LD_OWVAR 69
6690: PUSH
6691: LD_INT 5
6693: EQUAL
6694: IFFALSE 6721
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
6696: LD_ADDR_VAR 0 1
6700: PUSH
6701: LD_INT 1
6703: PUSH
6704: LD_INT 2
6706: PUSH
6707: EMPTY
6708: LIST
6709: LIST
6710: PUSH
6711: LD_INT 100
6713: PUSH
6714: EMPTY
6715: LIST
6716: PUSH
6717: EMPTY
6718: LIST
6719: LIST
6720: ST_TO_ADDR
// end ; if result then
6721: LD_VAR 0 1
6725: IFFALSE 7014
// begin normal :=  ;
6727: LD_ADDR_VAR 0 3
6731: PUSH
6732: LD_STRING 
6734: ST_TO_ADDR
// hardcore :=  ;
6735: LD_ADDR_VAR 0 4
6739: PUSH
6740: LD_STRING 
6742: ST_TO_ADDR
// for i = 1 to normalCounter do
6743: LD_ADDR_VAR 0 5
6747: PUSH
6748: DOUBLE
6749: LD_INT 1
6751: DEC
6752: ST_TO_ADDR
6753: LD_EXP 25
6757: PUSH
6758: FOR_TO
6759: IFFALSE 6860
// begin tmp := 0 ;
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_STRING 0
6768: ST_TO_ADDR
// if result [ 1 ] then
6769: LD_VAR 0 1
6773: PUSH
6774: LD_INT 1
6776: ARRAY
6777: IFFALSE 6842
// if result [ 1 ] [ 1 ] = i then
6779: LD_VAR 0 1
6783: PUSH
6784: LD_INT 1
6786: ARRAY
6787: PUSH
6788: LD_INT 1
6790: ARRAY
6791: PUSH
6792: LD_VAR 0 5
6796: EQUAL
6797: IFFALSE 6842
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
6799: LD_ADDR_VAR 0 1
6803: PUSH
6804: LD_VAR 0 1
6808: PPUSH
6809: LD_INT 1
6811: PPUSH
6812: LD_VAR 0 1
6816: PUSH
6817: LD_INT 1
6819: ARRAY
6820: PPUSH
6821: LD_INT 1
6823: PPUSH
6824: CALL_OW 3
6828: PPUSH
6829: CALL_OW 1
6833: ST_TO_ADDR
// tmp := 1 ;
6834: LD_ADDR_VAR 0 2
6838: PUSH
6839: LD_STRING 1
6841: ST_TO_ADDR
// end ; normal := normal & tmp ;
6842: LD_ADDR_VAR 0 3
6846: PUSH
6847: LD_VAR 0 3
6851: PUSH
6852: LD_VAR 0 2
6856: STR
6857: ST_TO_ADDR
// end ;
6858: GO 6758
6860: POP
6861: POP
// for i = 1 to hardcoreCounter do
6862: LD_ADDR_VAR 0 5
6866: PUSH
6867: DOUBLE
6868: LD_INT 1
6870: DEC
6871: ST_TO_ADDR
6872: LD_EXP 26
6876: PUSH
6877: FOR_TO
6878: IFFALSE 6983
// begin tmp := 0 ;
6880: LD_ADDR_VAR 0 2
6884: PUSH
6885: LD_STRING 0
6887: ST_TO_ADDR
// if result [ 2 ] then
6888: LD_VAR 0 1
6892: PUSH
6893: LD_INT 2
6895: ARRAY
6896: IFFALSE 6965
// if result [ 2 ] [ 1 ] = 100 + i then
6898: LD_VAR 0 1
6902: PUSH
6903: LD_INT 2
6905: ARRAY
6906: PUSH
6907: LD_INT 1
6909: ARRAY
6910: PUSH
6911: LD_INT 100
6913: PUSH
6914: LD_VAR 0 5
6918: PLUS
6919: EQUAL
6920: IFFALSE 6965
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
6922: LD_ADDR_VAR 0 1
6926: PUSH
6927: LD_VAR 0 1
6931: PPUSH
6932: LD_INT 2
6934: PPUSH
6935: LD_VAR 0 1
6939: PUSH
6940: LD_INT 2
6942: ARRAY
6943: PPUSH
6944: LD_INT 1
6946: PPUSH
6947: CALL_OW 3
6951: PPUSH
6952: CALL_OW 1
6956: ST_TO_ADDR
// tmp := 1 ;
6957: LD_ADDR_VAR 0 2
6961: PUSH
6962: LD_STRING 1
6964: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
6965: LD_ADDR_VAR 0 4
6969: PUSH
6970: LD_VAR 0 4
6974: PUSH
6975: LD_VAR 0 2
6979: STR
6980: ST_TO_ADDR
// end ;
6981: GO 6877
6983: POP
6984: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
6985: LD_STRING getStreamItemsFromMission("
6987: PUSH
6988: LD_VAR 0 3
6992: STR
6993: PUSH
6994: LD_STRING ","
6996: STR
6997: PUSH
6998: LD_VAR 0 4
7002: STR
7003: PUSH
7004: LD_STRING ")
7006: STR
7007: PPUSH
7008: CALL_OW 559
// end else
7012: GO 7021
// ToLua ( getStreamItemsFromMission("","") ) ;
7014: LD_STRING getStreamItemsFromMission("","")
7016: PPUSH
7017: CALL_OW 559
// end ;
7021: LD_VAR 0 1
7025: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
7026: LD_VAR 0 2
7030: PUSH
7031: LD_INT 100
7033: EQUAL
7034: IFFALSE 7983
// begin if not StreamModeActive then
7036: LD_EXP 24
7040: NOT
7041: IFFALSE 7051
// StreamModeActive := true ;
7043: LD_ADDR_EXP 24
7047: PUSH
7048: LD_INT 1
7050: ST_TO_ADDR
// if p3 = 0 then
7051: LD_VAR 0 3
7055: PUSH
7056: LD_INT 0
7058: EQUAL
7059: IFFALSE 7065
// InitStreamMode ;
7061: CALL 3286 0 0
// if p3 = 1 then
7065: LD_VAR 0 3
7069: PUSH
7070: LD_INT 1
7072: EQUAL
7073: IFFALSE 7083
// sRocket := true ;
7075: LD_ADDR_EXP 29
7079: PUSH
7080: LD_INT 1
7082: ST_TO_ADDR
// if p3 = 2 then
7083: LD_VAR 0 3
7087: PUSH
7088: LD_INT 2
7090: EQUAL
7091: IFFALSE 7101
// sSpeed := true ;
7093: LD_ADDR_EXP 28
7097: PUSH
7098: LD_INT 1
7100: ST_TO_ADDR
// if p3 = 3 then
7101: LD_VAR 0 3
7105: PUSH
7106: LD_INT 3
7108: EQUAL
7109: IFFALSE 7119
// sEngine := true ;
7111: LD_ADDR_EXP 30
7115: PUSH
7116: LD_INT 1
7118: ST_TO_ADDR
// if p3 = 4 then
7119: LD_VAR 0 3
7123: PUSH
7124: LD_INT 4
7126: EQUAL
7127: IFFALSE 7137
// sSpec := true ;
7129: LD_ADDR_EXP 27
7133: PUSH
7134: LD_INT 1
7136: ST_TO_ADDR
// if p3 = 5 then
7137: LD_VAR 0 3
7141: PUSH
7142: LD_INT 5
7144: EQUAL
7145: IFFALSE 7155
// sLevel := true ;
7147: LD_ADDR_EXP 31
7151: PUSH
7152: LD_INT 1
7154: ST_TO_ADDR
// if p3 = 6 then
7155: LD_VAR 0 3
7159: PUSH
7160: LD_INT 6
7162: EQUAL
7163: IFFALSE 7173
// sArmoury := true ;
7165: LD_ADDR_EXP 32
7169: PUSH
7170: LD_INT 1
7172: ST_TO_ADDR
// if p3 = 7 then
7173: LD_VAR 0 3
7177: PUSH
7178: LD_INT 7
7180: EQUAL
7181: IFFALSE 7191
// sRadar := true ;
7183: LD_ADDR_EXP 33
7187: PUSH
7188: LD_INT 1
7190: ST_TO_ADDR
// if p3 = 8 then
7191: LD_VAR 0 3
7195: PUSH
7196: LD_INT 8
7198: EQUAL
7199: IFFALSE 7209
// sBunker := true ;
7201: LD_ADDR_EXP 34
7205: PUSH
7206: LD_INT 1
7208: ST_TO_ADDR
// if p3 = 9 then
7209: LD_VAR 0 3
7213: PUSH
7214: LD_INT 9
7216: EQUAL
7217: IFFALSE 7227
// sHack := true ;
7219: LD_ADDR_EXP 35
7223: PUSH
7224: LD_INT 1
7226: ST_TO_ADDR
// if p3 = 10 then
7227: LD_VAR 0 3
7231: PUSH
7232: LD_INT 10
7234: EQUAL
7235: IFFALSE 7245
// sFire := true ;
7237: LD_ADDR_EXP 36
7241: PUSH
7242: LD_INT 1
7244: ST_TO_ADDR
// if p3 = 11 then
7245: LD_VAR 0 3
7249: PUSH
7250: LD_INT 11
7252: EQUAL
7253: IFFALSE 7263
// sRefresh := true ;
7255: LD_ADDR_EXP 37
7259: PUSH
7260: LD_INT 1
7262: ST_TO_ADDR
// if p3 = 12 then
7263: LD_VAR 0 3
7267: PUSH
7268: LD_INT 12
7270: EQUAL
7271: IFFALSE 7281
// sExp := true ;
7273: LD_ADDR_EXP 38
7277: PUSH
7278: LD_INT 1
7280: ST_TO_ADDR
// if p3 = 13 then
7281: LD_VAR 0 3
7285: PUSH
7286: LD_INT 13
7288: EQUAL
7289: IFFALSE 7299
// sDepot := true ;
7291: LD_ADDR_EXP 39
7295: PUSH
7296: LD_INT 1
7298: ST_TO_ADDR
// if p3 = 14 then
7299: LD_VAR 0 3
7303: PUSH
7304: LD_INT 14
7306: EQUAL
7307: IFFALSE 7317
// sFlag := true ;
7309: LD_ADDR_EXP 40
7313: PUSH
7314: LD_INT 1
7316: ST_TO_ADDR
// if p3 = 15 then
7317: LD_VAR 0 3
7321: PUSH
7322: LD_INT 15
7324: EQUAL
7325: IFFALSE 7335
// sKamikadze := true ;
7327: LD_ADDR_EXP 48
7331: PUSH
7332: LD_INT 1
7334: ST_TO_ADDR
// if p3 = 16 then
7335: LD_VAR 0 3
7339: PUSH
7340: LD_INT 16
7342: EQUAL
7343: IFFALSE 7353
// sTroll := true ;
7345: LD_ADDR_EXP 49
7349: PUSH
7350: LD_INT 1
7352: ST_TO_ADDR
// if p3 = 17 then
7353: LD_VAR 0 3
7357: PUSH
7358: LD_INT 17
7360: EQUAL
7361: IFFALSE 7371
// sSlow := true ;
7363: LD_ADDR_EXP 50
7367: PUSH
7368: LD_INT 1
7370: ST_TO_ADDR
// if p3 = 18 then
7371: LD_VAR 0 3
7375: PUSH
7376: LD_INT 18
7378: EQUAL
7379: IFFALSE 7389
// sLack := true ;
7381: LD_ADDR_EXP 51
7385: PUSH
7386: LD_INT 1
7388: ST_TO_ADDR
// if p3 = 19 then
7389: LD_VAR 0 3
7393: PUSH
7394: LD_INT 19
7396: EQUAL
7397: IFFALSE 7407
// sTank := true ;
7399: LD_ADDR_EXP 53
7403: PUSH
7404: LD_INT 1
7406: ST_TO_ADDR
// if p3 = 20 then
7407: LD_VAR 0 3
7411: PUSH
7412: LD_INT 20
7414: EQUAL
7415: IFFALSE 7425
// sRemote := true ;
7417: LD_ADDR_EXP 54
7421: PUSH
7422: LD_INT 1
7424: ST_TO_ADDR
// if p3 = 21 then
7425: LD_VAR 0 3
7429: PUSH
7430: LD_INT 21
7432: EQUAL
7433: IFFALSE 7443
// sPowell := true ;
7435: LD_ADDR_EXP 55
7439: PUSH
7440: LD_INT 1
7442: ST_TO_ADDR
// if p3 = 22 then
7443: LD_VAR 0 3
7447: PUSH
7448: LD_INT 22
7450: EQUAL
7451: IFFALSE 7461
// sTeleport := true ;
7453: LD_ADDR_EXP 58
7457: PUSH
7458: LD_INT 1
7460: ST_TO_ADDR
// if p3 = 23 then
7461: LD_VAR 0 3
7465: PUSH
7466: LD_INT 23
7468: EQUAL
7469: IFFALSE 7479
// sOilTower := true ;
7471: LD_ADDR_EXP 60
7475: PUSH
7476: LD_INT 1
7478: ST_TO_ADDR
// if p3 = 24 then
7479: LD_VAR 0 3
7483: PUSH
7484: LD_INT 24
7486: EQUAL
7487: IFFALSE 7497
// sShovel := true ;
7489: LD_ADDR_EXP 61
7493: PUSH
7494: LD_INT 1
7496: ST_TO_ADDR
// if p3 = 25 then
7497: LD_VAR 0 3
7501: PUSH
7502: LD_INT 25
7504: EQUAL
7505: IFFALSE 7515
// sSheik := true ;
7507: LD_ADDR_EXP 62
7511: PUSH
7512: LD_INT 1
7514: ST_TO_ADDR
// if p3 = 26 then
7515: LD_VAR 0 3
7519: PUSH
7520: LD_INT 26
7522: EQUAL
7523: IFFALSE 7533
// sEarthquake := true ;
7525: LD_ADDR_EXP 64
7529: PUSH
7530: LD_INT 1
7532: ST_TO_ADDR
// if p3 = 27 then
7533: LD_VAR 0 3
7537: PUSH
7538: LD_INT 27
7540: EQUAL
7541: IFFALSE 7551
// sAI := true ;
7543: LD_ADDR_EXP 65
7547: PUSH
7548: LD_INT 1
7550: ST_TO_ADDR
// if p3 = 28 then
7551: LD_VAR 0 3
7555: PUSH
7556: LD_INT 28
7558: EQUAL
7559: IFFALSE 7569
// sCargo := true ;
7561: LD_ADDR_EXP 68
7565: PUSH
7566: LD_INT 1
7568: ST_TO_ADDR
// if p3 = 29 then
7569: LD_VAR 0 3
7573: PUSH
7574: LD_INT 29
7576: EQUAL
7577: IFFALSE 7587
// sDLaser := true ;
7579: LD_ADDR_EXP 69
7583: PUSH
7584: LD_INT 1
7586: ST_TO_ADDR
// if p3 = 30 then
7587: LD_VAR 0 3
7591: PUSH
7592: LD_INT 30
7594: EQUAL
7595: IFFALSE 7605
// sExchange := true ;
7597: LD_ADDR_EXP 70
7601: PUSH
7602: LD_INT 1
7604: ST_TO_ADDR
// if p3 = 31 then
7605: LD_VAR 0 3
7609: PUSH
7610: LD_INT 31
7612: EQUAL
7613: IFFALSE 7623
// sFac := true ;
7615: LD_ADDR_EXP 71
7619: PUSH
7620: LD_INT 1
7622: ST_TO_ADDR
// if p3 = 32 then
7623: LD_VAR 0 3
7627: PUSH
7628: LD_INT 32
7630: EQUAL
7631: IFFALSE 7641
// sPower := true ;
7633: LD_ADDR_EXP 72
7637: PUSH
7638: LD_INT 1
7640: ST_TO_ADDR
// if p3 = 33 then
7641: LD_VAR 0 3
7645: PUSH
7646: LD_INT 33
7648: EQUAL
7649: IFFALSE 7659
// sRandom := true ;
7651: LD_ADDR_EXP 73
7655: PUSH
7656: LD_INT 1
7658: ST_TO_ADDR
// if p3 = 34 then
7659: LD_VAR 0 3
7663: PUSH
7664: LD_INT 34
7666: EQUAL
7667: IFFALSE 7677
// sShield := true ;
7669: LD_ADDR_EXP 74
7673: PUSH
7674: LD_INT 1
7676: ST_TO_ADDR
// if p3 = 35 then
7677: LD_VAR 0 3
7681: PUSH
7682: LD_INT 35
7684: EQUAL
7685: IFFALSE 7695
// sTime := true ;
7687: LD_ADDR_EXP 75
7691: PUSH
7692: LD_INT 1
7694: ST_TO_ADDR
// if p3 = 36 then
7695: LD_VAR 0 3
7699: PUSH
7700: LD_INT 36
7702: EQUAL
7703: IFFALSE 7713
// sTools := true ;
7705: LD_ADDR_EXP 76
7709: PUSH
7710: LD_INT 1
7712: ST_TO_ADDR
// if p3 = 101 then
7713: LD_VAR 0 3
7717: PUSH
7718: LD_INT 101
7720: EQUAL
7721: IFFALSE 7731
// sSold := true ;
7723: LD_ADDR_EXP 41
7727: PUSH
7728: LD_INT 1
7730: ST_TO_ADDR
// if p3 = 102 then
7731: LD_VAR 0 3
7735: PUSH
7736: LD_INT 102
7738: EQUAL
7739: IFFALSE 7749
// sDiff := true ;
7741: LD_ADDR_EXP 42
7745: PUSH
7746: LD_INT 1
7748: ST_TO_ADDR
// if p3 = 103 then
7749: LD_VAR 0 3
7753: PUSH
7754: LD_INT 103
7756: EQUAL
7757: IFFALSE 7767
// sFog := true ;
7759: LD_ADDR_EXP 45
7763: PUSH
7764: LD_INT 1
7766: ST_TO_ADDR
// if p3 = 104 then
7767: LD_VAR 0 3
7771: PUSH
7772: LD_INT 104
7774: EQUAL
7775: IFFALSE 7785
// sReset := true ;
7777: LD_ADDR_EXP 46
7781: PUSH
7782: LD_INT 1
7784: ST_TO_ADDR
// if p3 = 105 then
7785: LD_VAR 0 3
7789: PUSH
7790: LD_INT 105
7792: EQUAL
7793: IFFALSE 7803
// sSun := true ;
7795: LD_ADDR_EXP 47
7799: PUSH
7800: LD_INT 1
7802: ST_TO_ADDR
// if p3 = 106 then
7803: LD_VAR 0 3
7807: PUSH
7808: LD_INT 106
7810: EQUAL
7811: IFFALSE 7821
// sTiger := true ;
7813: LD_ADDR_EXP 43
7817: PUSH
7818: LD_INT 1
7820: ST_TO_ADDR
// if p3 = 107 then
7821: LD_VAR 0 3
7825: PUSH
7826: LD_INT 107
7828: EQUAL
7829: IFFALSE 7839
// sBomb := true ;
7831: LD_ADDR_EXP 44
7835: PUSH
7836: LD_INT 1
7838: ST_TO_ADDR
// if p3 = 108 then
7839: LD_VAR 0 3
7843: PUSH
7844: LD_INT 108
7846: EQUAL
7847: IFFALSE 7857
// sWound := true ;
7849: LD_ADDR_EXP 52
7853: PUSH
7854: LD_INT 1
7856: ST_TO_ADDR
// if p3 = 109 then
7857: LD_VAR 0 3
7861: PUSH
7862: LD_INT 109
7864: EQUAL
7865: IFFALSE 7875
// sBetray := true ;
7867: LD_ADDR_EXP 56
7871: PUSH
7872: LD_INT 1
7874: ST_TO_ADDR
// if p3 = 110 then
7875: LD_VAR 0 3
7879: PUSH
7880: LD_INT 110
7882: EQUAL
7883: IFFALSE 7893
// sContamin := true ;
7885: LD_ADDR_EXP 57
7889: PUSH
7890: LD_INT 1
7892: ST_TO_ADDR
// if p3 = 111 then
7893: LD_VAR 0 3
7897: PUSH
7898: LD_INT 111
7900: EQUAL
7901: IFFALSE 7911
// sOil := true ;
7903: LD_ADDR_EXP 59
7907: PUSH
7908: LD_INT 1
7910: ST_TO_ADDR
// if p3 = 112 then
7911: LD_VAR 0 3
7915: PUSH
7916: LD_INT 112
7918: EQUAL
7919: IFFALSE 7929
// sStu := true ;
7921: LD_ADDR_EXP 63
7925: PUSH
7926: LD_INT 1
7928: ST_TO_ADDR
// if p3 = 113 then
7929: LD_VAR 0 3
7933: PUSH
7934: LD_INT 113
7936: EQUAL
7937: IFFALSE 7947
// sBazooka := true ;
7939: LD_ADDR_EXP 66
7943: PUSH
7944: LD_INT 1
7946: ST_TO_ADDR
// if p3 = 114 then
7947: LD_VAR 0 3
7951: PUSH
7952: LD_INT 114
7954: EQUAL
7955: IFFALSE 7965
// sMortar := true ;
7957: LD_ADDR_EXP 67
7961: PUSH
7962: LD_INT 1
7964: ST_TO_ADDR
// if p3 = 115 then
7965: LD_VAR 0 3
7969: PUSH
7970: LD_INT 115
7972: EQUAL
7973: IFFALSE 7983
// sRanger := true ;
7975: LD_ADDR_EXP 77
7979: PUSH
7980: LD_INT 1
7982: ST_TO_ADDR
// end ; end ;
7983: PPOPN 6
7985: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
7986: LD_EXP 24
7990: PUSH
7991: LD_EXP 29
7995: AND
7996: IFFALSE 8120
7998: GO 8000
8000: DISABLE
8001: LD_INT 0
8003: PPUSH
8004: PPUSH
// begin enable ;
8005: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
8006: LD_ADDR_VAR 0 2
8010: PUSH
8011: LD_INT 22
8013: PUSH
8014: LD_OWVAR 2
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: PUSH
8023: LD_INT 2
8025: PUSH
8026: LD_INT 34
8028: PUSH
8029: LD_INT 7
8031: PUSH
8032: EMPTY
8033: LIST
8034: LIST
8035: PUSH
8036: LD_INT 34
8038: PUSH
8039: LD_INT 45
8041: PUSH
8042: EMPTY
8043: LIST
8044: LIST
8045: PUSH
8046: LD_INT 34
8048: PUSH
8049: LD_INT 28
8051: PUSH
8052: EMPTY
8053: LIST
8054: LIST
8055: PUSH
8056: LD_INT 34
8058: PUSH
8059: LD_INT 47
8061: PUSH
8062: EMPTY
8063: LIST
8064: LIST
8065: PUSH
8066: EMPTY
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: PUSH
8073: EMPTY
8074: LIST
8075: LIST
8076: PPUSH
8077: CALL_OW 69
8081: ST_TO_ADDR
// if not tmp then
8082: LD_VAR 0 2
8086: NOT
8087: IFFALSE 8091
// exit ;
8089: GO 8120
// for i in tmp do
8091: LD_ADDR_VAR 0 1
8095: PUSH
8096: LD_VAR 0 2
8100: PUSH
8101: FOR_IN
8102: IFFALSE 8118
// begin SetLives ( i , 0 ) ;
8104: LD_VAR 0 1
8108: PPUSH
8109: LD_INT 0
8111: PPUSH
8112: CALL_OW 234
// end ;
8116: GO 8101
8118: POP
8119: POP
// end ;
8120: PPOPN 2
8122: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
8123: LD_EXP 24
8127: PUSH
8128: LD_EXP 30
8132: AND
8133: IFFALSE 8217
8135: GO 8137
8137: DISABLE
8138: LD_INT 0
8140: PPUSH
8141: PPUSH
// begin enable ;
8142: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
8143: LD_ADDR_VAR 0 2
8147: PUSH
8148: LD_INT 22
8150: PUSH
8151: LD_OWVAR 2
8155: PUSH
8156: EMPTY
8157: LIST
8158: LIST
8159: PUSH
8160: LD_INT 32
8162: PUSH
8163: LD_INT 3
8165: PUSH
8166: EMPTY
8167: LIST
8168: LIST
8169: PUSH
8170: EMPTY
8171: LIST
8172: LIST
8173: PPUSH
8174: CALL_OW 69
8178: ST_TO_ADDR
// if not tmp then
8179: LD_VAR 0 2
8183: NOT
8184: IFFALSE 8188
// exit ;
8186: GO 8217
// for i in tmp do
8188: LD_ADDR_VAR 0 1
8192: PUSH
8193: LD_VAR 0 2
8197: PUSH
8198: FOR_IN
8199: IFFALSE 8215
// begin SetLives ( i , 0 ) ;
8201: LD_VAR 0 1
8205: PPUSH
8206: LD_INT 0
8208: PPUSH
8209: CALL_OW 234
// end ;
8213: GO 8198
8215: POP
8216: POP
// end ;
8217: PPOPN 2
8219: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
8220: LD_EXP 24
8224: PUSH
8225: LD_EXP 27
8229: AND
8230: IFFALSE 8323
8232: GO 8234
8234: DISABLE
8235: LD_INT 0
8237: PPUSH
// begin enable ;
8238: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
8239: LD_ADDR_VAR 0 1
8243: PUSH
8244: LD_INT 22
8246: PUSH
8247: LD_OWVAR 2
8251: PUSH
8252: EMPTY
8253: LIST
8254: LIST
8255: PUSH
8256: LD_INT 2
8258: PUSH
8259: LD_INT 25
8261: PUSH
8262: LD_INT 5
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: PUSH
8269: LD_INT 25
8271: PUSH
8272: LD_INT 9
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PUSH
8279: LD_INT 25
8281: PUSH
8282: LD_INT 8
8284: PUSH
8285: EMPTY
8286: LIST
8287: LIST
8288: PUSH
8289: EMPTY
8290: LIST
8291: LIST
8292: LIST
8293: LIST
8294: PUSH
8295: EMPTY
8296: LIST
8297: LIST
8298: PPUSH
8299: CALL_OW 69
8303: PUSH
8304: FOR_IN
8305: IFFALSE 8321
// begin SetClass ( i , 1 ) ;
8307: LD_VAR 0 1
8311: PPUSH
8312: LD_INT 1
8314: PPUSH
8315: CALL_OW 336
// end ;
8319: GO 8304
8321: POP
8322: POP
// end ;
8323: PPOPN 1
8325: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
8326: LD_EXP 24
8330: PUSH
8331: LD_EXP 28
8335: AND
8336: PUSH
8337: LD_OWVAR 65
8341: PUSH
8342: LD_INT 7
8344: LESS
8345: AND
8346: IFFALSE 8360
8348: GO 8350
8350: DISABLE
// begin enable ;
8351: ENABLE
// game_speed := 7 ;
8352: LD_ADDR_OWVAR 65
8356: PUSH
8357: LD_INT 7
8359: ST_TO_ADDR
// end ;
8360: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
8361: LD_EXP 24
8365: PUSH
8366: LD_EXP 31
8370: AND
8371: IFFALSE 8573
8373: GO 8375
8375: DISABLE
8376: LD_INT 0
8378: PPUSH
8379: PPUSH
8380: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
8381: LD_ADDR_VAR 0 3
8385: PUSH
8386: LD_INT 81
8388: PUSH
8389: LD_OWVAR 2
8393: PUSH
8394: EMPTY
8395: LIST
8396: LIST
8397: PUSH
8398: LD_INT 21
8400: PUSH
8401: LD_INT 1
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PUSH
8408: EMPTY
8409: LIST
8410: LIST
8411: PPUSH
8412: CALL_OW 69
8416: ST_TO_ADDR
// if not tmp then
8417: LD_VAR 0 3
8421: NOT
8422: IFFALSE 8426
// exit ;
8424: GO 8573
// if tmp > 5 then
8426: LD_VAR 0 3
8430: PUSH
8431: LD_INT 5
8433: GREATER
8434: IFFALSE 8446
// k := 5 else
8436: LD_ADDR_VAR 0 2
8440: PUSH
8441: LD_INT 5
8443: ST_TO_ADDR
8444: GO 8456
// k := tmp ;
8446: LD_ADDR_VAR 0 2
8450: PUSH
8451: LD_VAR 0 3
8455: ST_TO_ADDR
// for i := 1 to k do
8456: LD_ADDR_VAR 0 1
8460: PUSH
8461: DOUBLE
8462: LD_INT 1
8464: DEC
8465: ST_TO_ADDR
8466: LD_VAR 0 2
8470: PUSH
8471: FOR_TO
8472: IFFALSE 8571
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
8474: LD_VAR 0 3
8478: PUSH
8479: LD_VAR 0 1
8483: ARRAY
8484: PPUSH
8485: LD_VAR 0 1
8489: PUSH
8490: LD_INT 4
8492: MOD
8493: PUSH
8494: LD_INT 1
8496: PLUS
8497: PPUSH
8498: CALL_OW 259
8502: PUSH
8503: LD_INT 10
8505: LESS
8506: IFFALSE 8569
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
8508: LD_VAR 0 3
8512: PUSH
8513: LD_VAR 0 1
8517: ARRAY
8518: PPUSH
8519: LD_VAR 0 1
8523: PUSH
8524: LD_INT 4
8526: MOD
8527: PUSH
8528: LD_INT 1
8530: PLUS
8531: PPUSH
8532: LD_VAR 0 3
8536: PUSH
8537: LD_VAR 0 1
8541: ARRAY
8542: PPUSH
8543: LD_VAR 0 1
8547: PUSH
8548: LD_INT 4
8550: MOD
8551: PUSH
8552: LD_INT 1
8554: PLUS
8555: PPUSH
8556: CALL_OW 259
8560: PUSH
8561: LD_INT 1
8563: PLUS
8564: PPUSH
8565: CALL_OW 237
8569: GO 8471
8571: POP
8572: POP
// end ;
8573: PPOPN 3
8575: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
8576: LD_EXP 24
8580: PUSH
8581: LD_EXP 32
8585: AND
8586: IFFALSE 8606
8588: GO 8590
8590: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
8591: LD_INT 4
8593: PPUSH
8594: LD_OWVAR 2
8598: PPUSH
8599: LD_INT 0
8601: PPUSH
8602: CALL_OW 324
8606: END
// every 0 0$1 trigger StreamModeActive and sShovel do
8607: LD_EXP 24
8611: PUSH
8612: LD_EXP 61
8616: AND
8617: IFFALSE 8637
8619: GO 8621
8621: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
8622: LD_INT 19
8624: PPUSH
8625: LD_OWVAR 2
8629: PPUSH
8630: LD_INT 0
8632: PPUSH
8633: CALL_OW 324
8637: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
8638: LD_EXP 24
8642: PUSH
8643: LD_EXP 33
8647: AND
8648: IFFALSE 8750
8650: GO 8652
8652: DISABLE
8653: LD_INT 0
8655: PPUSH
8656: PPUSH
// begin enable ;
8657: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
8658: LD_ADDR_VAR 0 2
8662: PUSH
8663: LD_INT 22
8665: PUSH
8666: LD_OWVAR 2
8670: PUSH
8671: EMPTY
8672: LIST
8673: LIST
8674: PUSH
8675: LD_INT 2
8677: PUSH
8678: LD_INT 34
8680: PUSH
8681: LD_INT 11
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: PUSH
8688: LD_INT 34
8690: PUSH
8691: LD_INT 30
8693: PUSH
8694: EMPTY
8695: LIST
8696: LIST
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: LIST
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PPUSH
8707: CALL_OW 69
8711: ST_TO_ADDR
// if not tmp then
8712: LD_VAR 0 2
8716: NOT
8717: IFFALSE 8721
// exit ;
8719: GO 8750
// for i in tmp do
8721: LD_ADDR_VAR 0 1
8725: PUSH
8726: LD_VAR 0 2
8730: PUSH
8731: FOR_IN
8732: IFFALSE 8748
// begin SetLives ( i , 0 ) ;
8734: LD_VAR 0 1
8738: PPUSH
8739: LD_INT 0
8741: PPUSH
8742: CALL_OW 234
// end ;
8746: GO 8731
8748: POP
8749: POP
// end ;
8750: PPOPN 2
8752: END
// every 0 0$1 trigger StreamModeActive and sBunker do
8753: LD_EXP 24
8757: PUSH
8758: LD_EXP 34
8762: AND
8763: IFFALSE 8783
8765: GO 8767
8767: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
8768: LD_INT 32
8770: PPUSH
8771: LD_OWVAR 2
8775: PPUSH
8776: LD_INT 0
8778: PPUSH
8779: CALL_OW 324
8783: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
8784: LD_EXP 24
8788: PUSH
8789: LD_EXP 35
8793: AND
8794: IFFALSE 8975
8796: GO 8798
8798: DISABLE
8799: LD_INT 0
8801: PPUSH
8802: PPUSH
8803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
8804: LD_ADDR_VAR 0 2
8808: PUSH
8809: LD_INT 22
8811: PUSH
8812: LD_OWVAR 2
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: LD_INT 33
8823: PUSH
8824: LD_INT 3
8826: PUSH
8827: EMPTY
8828: LIST
8829: LIST
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: PPUSH
8835: CALL_OW 69
8839: ST_TO_ADDR
// if not tmp then
8840: LD_VAR 0 2
8844: NOT
8845: IFFALSE 8849
// exit ;
8847: GO 8975
// side := 0 ;
8849: LD_ADDR_VAR 0 3
8853: PUSH
8854: LD_INT 0
8856: ST_TO_ADDR
// for i := 1 to 8 do
8857: LD_ADDR_VAR 0 1
8861: PUSH
8862: DOUBLE
8863: LD_INT 1
8865: DEC
8866: ST_TO_ADDR
8867: LD_INT 8
8869: PUSH
8870: FOR_TO
8871: IFFALSE 8919
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
8873: LD_OWVAR 2
8877: PUSH
8878: LD_VAR 0 1
8882: NONEQUAL
8883: PUSH
8884: LD_OWVAR 2
8888: PPUSH
8889: LD_VAR 0 1
8893: PPUSH
8894: CALL_OW 81
8898: PUSH
8899: LD_INT 2
8901: EQUAL
8902: AND
8903: IFFALSE 8917
// begin side := i ;
8905: LD_ADDR_VAR 0 3
8909: PUSH
8910: LD_VAR 0 1
8914: ST_TO_ADDR
// break ;
8915: GO 8919
// end ;
8917: GO 8870
8919: POP
8920: POP
// if not side then
8921: LD_VAR 0 3
8925: NOT
8926: IFFALSE 8930
// exit ;
8928: GO 8975
// for i := 1 to tmp do
8930: LD_ADDR_VAR 0 1
8934: PUSH
8935: DOUBLE
8936: LD_INT 1
8938: DEC
8939: ST_TO_ADDR
8940: LD_VAR 0 2
8944: PUSH
8945: FOR_TO
8946: IFFALSE 8973
// if Prob ( 60 ) then
8948: LD_INT 60
8950: PPUSH
8951: CALL_OW 13
8955: IFFALSE 8971
// SetSide ( i , side ) ;
8957: LD_VAR 0 1
8961: PPUSH
8962: LD_VAR 0 3
8966: PPUSH
8967: CALL_OW 235
8971: GO 8945
8973: POP
8974: POP
// end ;
8975: PPOPN 3
8977: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
8978: LD_EXP 24
8982: PUSH
8983: LD_EXP 37
8987: AND
8988: IFFALSE 9107
8990: GO 8992
8992: DISABLE
8993: LD_INT 0
8995: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
8996: LD_ADDR_VAR 0 1
9000: PUSH
9001: LD_INT 22
9003: PUSH
9004: LD_OWVAR 2
9008: PUSH
9009: EMPTY
9010: LIST
9011: LIST
9012: PUSH
9013: LD_INT 21
9015: PUSH
9016: LD_INT 1
9018: PUSH
9019: EMPTY
9020: LIST
9021: LIST
9022: PUSH
9023: LD_INT 3
9025: PUSH
9026: LD_INT 23
9028: PUSH
9029: LD_INT 0
9031: PUSH
9032: EMPTY
9033: LIST
9034: LIST
9035: PUSH
9036: EMPTY
9037: LIST
9038: LIST
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: LIST
9044: PPUSH
9045: CALL_OW 69
9049: PUSH
9050: FOR_IN
9051: IFFALSE 9105
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
9053: LD_VAR 0 1
9057: PPUSH
9058: CALL_OW 257
9062: PUSH
9063: LD_INT 1
9065: PUSH
9066: LD_INT 2
9068: PUSH
9069: LD_INT 3
9071: PUSH
9072: LD_INT 4
9074: PUSH
9075: EMPTY
9076: LIST
9077: LIST
9078: LIST
9079: LIST
9080: IN
9081: IFFALSE 9103
// SetClass ( un , rand ( 1 , 4 ) ) ;
9083: LD_VAR 0 1
9087: PPUSH
9088: LD_INT 1
9090: PPUSH
9091: LD_INT 4
9093: PPUSH
9094: CALL_OW 12
9098: PPUSH
9099: CALL_OW 336
9103: GO 9050
9105: POP
9106: POP
// end ;
9107: PPOPN 1
9109: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
9110: LD_EXP 24
9114: PUSH
9115: LD_EXP 36
9119: AND
9120: IFFALSE 9199
9122: GO 9124
9124: DISABLE
9125: LD_INT 0
9127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9128: LD_ADDR_VAR 0 1
9132: PUSH
9133: LD_INT 22
9135: PUSH
9136: LD_OWVAR 2
9140: PUSH
9141: EMPTY
9142: LIST
9143: LIST
9144: PUSH
9145: LD_INT 21
9147: PUSH
9148: LD_INT 3
9150: PUSH
9151: EMPTY
9152: LIST
9153: LIST
9154: PUSH
9155: EMPTY
9156: LIST
9157: LIST
9158: PPUSH
9159: CALL_OW 69
9163: ST_TO_ADDR
// if not tmp then
9164: LD_VAR 0 1
9168: NOT
9169: IFFALSE 9173
// exit ;
9171: GO 9199
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
9173: LD_VAR 0 1
9177: PUSH
9178: LD_INT 1
9180: PPUSH
9181: LD_VAR 0 1
9185: PPUSH
9186: CALL_OW 12
9190: ARRAY
9191: PPUSH
9192: LD_INT 100
9194: PPUSH
9195: CALL_OW 234
// end ;
9199: PPOPN 1
9201: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
9202: LD_EXP 24
9206: PUSH
9207: LD_EXP 38
9211: AND
9212: IFFALSE 9310
9214: GO 9216
9216: DISABLE
9217: LD_INT 0
9219: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
9220: LD_ADDR_VAR 0 1
9224: PUSH
9225: LD_INT 22
9227: PUSH
9228: LD_OWVAR 2
9232: PUSH
9233: EMPTY
9234: LIST
9235: LIST
9236: PUSH
9237: LD_INT 21
9239: PUSH
9240: LD_INT 1
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: PPUSH
9251: CALL_OW 69
9255: ST_TO_ADDR
// if not tmp then
9256: LD_VAR 0 1
9260: NOT
9261: IFFALSE 9265
// exit ;
9263: GO 9310
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
9265: LD_VAR 0 1
9269: PUSH
9270: LD_INT 1
9272: PPUSH
9273: LD_VAR 0 1
9277: PPUSH
9278: CALL_OW 12
9282: ARRAY
9283: PPUSH
9284: LD_INT 1
9286: PPUSH
9287: LD_INT 4
9289: PPUSH
9290: CALL_OW 12
9294: PPUSH
9295: LD_INT 3000
9297: PPUSH
9298: LD_INT 9000
9300: PPUSH
9301: CALL_OW 12
9305: PPUSH
9306: CALL_OW 492
// end ;
9310: PPOPN 1
9312: END
// every 0 0$1 trigger StreamModeActive and sDepot do
9313: LD_EXP 24
9317: PUSH
9318: LD_EXP 39
9322: AND
9323: IFFALSE 9343
9325: GO 9327
9327: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
9328: LD_INT 1
9330: PPUSH
9331: LD_OWVAR 2
9335: PPUSH
9336: LD_INT 0
9338: PPUSH
9339: CALL_OW 324
9343: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
9344: LD_EXP 24
9348: PUSH
9349: LD_EXP 40
9353: AND
9354: IFFALSE 9437
9356: GO 9358
9358: DISABLE
9359: LD_INT 0
9361: PPUSH
9362: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
9363: LD_ADDR_VAR 0 2
9367: PUSH
9368: LD_INT 22
9370: PUSH
9371: LD_OWVAR 2
9375: PUSH
9376: EMPTY
9377: LIST
9378: LIST
9379: PUSH
9380: LD_INT 21
9382: PUSH
9383: LD_INT 3
9385: PUSH
9386: EMPTY
9387: LIST
9388: LIST
9389: PUSH
9390: EMPTY
9391: LIST
9392: LIST
9393: PPUSH
9394: CALL_OW 69
9398: ST_TO_ADDR
// if not tmp then
9399: LD_VAR 0 2
9403: NOT
9404: IFFALSE 9408
// exit ;
9406: GO 9437
// for i in tmp do
9408: LD_ADDR_VAR 0 1
9412: PUSH
9413: LD_VAR 0 2
9417: PUSH
9418: FOR_IN
9419: IFFALSE 9435
// SetBLevel ( i , 10 ) ;
9421: LD_VAR 0 1
9425: PPUSH
9426: LD_INT 10
9428: PPUSH
9429: CALL_OW 241
9433: GO 9418
9435: POP
9436: POP
// end ;
9437: PPOPN 2
9439: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
9440: LD_EXP 24
9444: PUSH
9445: LD_EXP 41
9449: AND
9450: IFFALSE 9561
9452: GO 9454
9454: DISABLE
9455: LD_INT 0
9457: PPUSH
9458: PPUSH
9459: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9460: LD_ADDR_VAR 0 3
9464: PUSH
9465: LD_INT 22
9467: PUSH
9468: LD_OWVAR 2
9472: PUSH
9473: EMPTY
9474: LIST
9475: LIST
9476: PUSH
9477: LD_INT 25
9479: PUSH
9480: LD_INT 1
9482: PUSH
9483: EMPTY
9484: LIST
9485: LIST
9486: PUSH
9487: EMPTY
9488: LIST
9489: LIST
9490: PPUSH
9491: CALL_OW 69
9495: ST_TO_ADDR
// if not tmp then
9496: LD_VAR 0 3
9500: NOT
9501: IFFALSE 9505
// exit ;
9503: GO 9561
// un := tmp [ rand ( 1 , tmp ) ] ;
9505: LD_ADDR_VAR 0 2
9509: PUSH
9510: LD_VAR 0 3
9514: PUSH
9515: LD_INT 1
9517: PPUSH
9518: LD_VAR 0 3
9522: PPUSH
9523: CALL_OW 12
9527: ARRAY
9528: ST_TO_ADDR
// if Crawls ( un ) then
9529: LD_VAR 0 2
9533: PPUSH
9534: CALL_OW 318
9538: IFFALSE 9549
// ComWalk ( un ) ;
9540: LD_VAR 0 2
9544: PPUSH
9545: CALL_OW 138
// SetClass ( un , class_sniper ) ;
9549: LD_VAR 0 2
9553: PPUSH
9554: LD_INT 5
9556: PPUSH
9557: CALL_OW 336
// end ;
9561: PPOPN 3
9563: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
9564: LD_EXP 24
9568: PUSH
9569: LD_EXP 42
9573: AND
9574: PUSH
9575: LD_OWVAR 67
9579: PUSH
9580: LD_INT 3
9582: LESS
9583: AND
9584: IFFALSE 9603
9586: GO 9588
9588: DISABLE
// Difficulty := Difficulty + 1 ;
9589: LD_ADDR_OWVAR 67
9593: PUSH
9594: LD_OWVAR 67
9598: PUSH
9599: LD_INT 1
9601: PLUS
9602: ST_TO_ADDR
9603: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
9604: LD_EXP 24
9608: PUSH
9609: LD_EXP 43
9613: AND
9614: IFFALSE 9717
9616: GO 9618
9618: DISABLE
9619: LD_INT 0
9621: PPUSH
// begin for i := 1 to 5 do
9622: LD_ADDR_VAR 0 1
9626: PUSH
9627: DOUBLE
9628: LD_INT 1
9630: DEC
9631: ST_TO_ADDR
9632: LD_INT 5
9634: PUSH
9635: FOR_TO
9636: IFFALSE 9715
// begin uc_nation := nation_nature ;
9638: LD_ADDR_OWVAR 21
9642: PUSH
9643: LD_INT 0
9645: ST_TO_ADDR
// uc_side := 0 ;
9646: LD_ADDR_OWVAR 20
9650: PUSH
9651: LD_INT 0
9653: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
9654: LD_ADDR_OWVAR 29
9658: PUSH
9659: LD_INT 12
9661: PUSH
9662: LD_INT 12
9664: PUSH
9665: EMPTY
9666: LIST
9667: LIST
9668: ST_TO_ADDR
// hc_agressivity := 20 ;
9669: LD_ADDR_OWVAR 35
9673: PUSH
9674: LD_INT 20
9676: ST_TO_ADDR
// hc_class := class_tiger ;
9677: LD_ADDR_OWVAR 28
9681: PUSH
9682: LD_INT 14
9684: ST_TO_ADDR
// hc_gallery :=  ;
9685: LD_ADDR_OWVAR 33
9689: PUSH
9690: LD_STRING 
9692: ST_TO_ADDR
// hc_name :=  ;
9693: LD_ADDR_OWVAR 26
9697: PUSH
9698: LD_STRING 
9700: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
9701: CALL_OW 44
9705: PPUSH
9706: LD_INT 0
9708: PPUSH
9709: CALL_OW 51
// end ;
9713: GO 9635
9715: POP
9716: POP
// end ;
9717: PPOPN 1
9719: END
// every 0 0$1 trigger StreamModeActive and sBomb do
9720: LD_EXP 24
9724: PUSH
9725: LD_EXP 44
9729: AND
9730: IFFALSE 9739
9732: GO 9734
9734: DISABLE
// StreamSibBomb ;
9735: CALL 9740 0 0
9739: END
// export function StreamSibBomb ; var i , x , y ; begin
9740: LD_INT 0
9742: PPUSH
9743: PPUSH
9744: PPUSH
9745: PPUSH
// result := false ;
9746: LD_ADDR_VAR 0 1
9750: PUSH
9751: LD_INT 0
9753: ST_TO_ADDR
// for i := 1 to 16 do
9754: LD_ADDR_VAR 0 2
9758: PUSH
9759: DOUBLE
9760: LD_INT 1
9762: DEC
9763: ST_TO_ADDR
9764: LD_INT 16
9766: PUSH
9767: FOR_TO
9768: IFFALSE 9967
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
9770: LD_ADDR_VAR 0 3
9774: PUSH
9775: LD_INT 10
9777: PUSH
9778: LD_INT 20
9780: PUSH
9781: LD_INT 30
9783: PUSH
9784: LD_INT 40
9786: PUSH
9787: LD_INT 50
9789: PUSH
9790: LD_INT 60
9792: PUSH
9793: LD_INT 70
9795: PUSH
9796: LD_INT 80
9798: PUSH
9799: LD_INT 90
9801: PUSH
9802: LD_INT 100
9804: PUSH
9805: LD_INT 110
9807: PUSH
9808: LD_INT 120
9810: PUSH
9811: LD_INT 130
9813: PUSH
9814: LD_INT 140
9816: PUSH
9817: LD_INT 150
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: LIST
9826: LIST
9827: LIST
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: LIST
9835: LIST
9836: PUSH
9837: LD_INT 1
9839: PPUSH
9840: LD_INT 15
9842: PPUSH
9843: CALL_OW 12
9847: ARRAY
9848: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
9849: LD_ADDR_VAR 0 4
9853: PUSH
9854: LD_INT 10
9856: PUSH
9857: LD_INT 20
9859: PUSH
9860: LD_INT 30
9862: PUSH
9863: LD_INT 40
9865: PUSH
9866: LD_INT 50
9868: PUSH
9869: LD_INT 60
9871: PUSH
9872: LD_INT 70
9874: PUSH
9875: LD_INT 80
9877: PUSH
9878: LD_INT 90
9880: PUSH
9881: LD_INT 100
9883: PUSH
9884: LD_INT 110
9886: PUSH
9887: LD_INT 120
9889: PUSH
9890: LD_INT 130
9892: PUSH
9893: LD_INT 140
9895: PUSH
9896: LD_INT 150
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: LIST
9903: LIST
9904: LIST
9905: LIST
9906: LIST
9907: LIST
9908: LIST
9909: LIST
9910: LIST
9911: LIST
9912: LIST
9913: LIST
9914: LIST
9915: PUSH
9916: LD_INT 1
9918: PPUSH
9919: LD_INT 15
9921: PPUSH
9922: CALL_OW 12
9926: ARRAY
9927: ST_TO_ADDR
// if ValidHex ( x , y ) then
9928: LD_VAR 0 3
9932: PPUSH
9933: LD_VAR 0 4
9937: PPUSH
9938: CALL_OW 488
9942: IFFALSE 9965
// begin result := [ x , y ] ;
9944: LD_ADDR_VAR 0 1
9948: PUSH
9949: LD_VAR 0 3
9953: PUSH
9954: LD_VAR 0 4
9958: PUSH
9959: EMPTY
9960: LIST
9961: LIST
9962: ST_TO_ADDR
// break ;
9963: GO 9967
// end ; end ;
9965: GO 9767
9967: POP
9968: POP
// if result then
9969: LD_VAR 0 1
9973: IFFALSE 10033
// begin ToLua ( playSibBomb() ) ;
9975: LD_STRING playSibBomb()
9977: PPUSH
9978: CALL_OW 559
// wait ( 0 0$14 ) ;
9982: LD_INT 490
9984: PPUSH
9985: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
9989: LD_VAR 0 1
9993: PUSH
9994: LD_INT 1
9996: ARRAY
9997: PPUSH
9998: LD_VAR 0 1
10002: PUSH
10003: LD_INT 2
10005: ARRAY
10006: PPUSH
10007: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
10011: LD_VAR 0 1
10015: PUSH
10016: LD_INT 1
10018: ARRAY
10019: PPUSH
10020: LD_VAR 0 1
10024: PUSH
10025: LD_INT 2
10027: ARRAY
10028: PPUSH
10029: CALL_OW 429
// end ; end ;
10033: LD_VAR 0 1
10037: RET
// every 0 0$1 trigger StreamModeActive and sReset do
10038: LD_EXP 24
10042: PUSH
10043: LD_EXP 46
10047: AND
10048: IFFALSE 10060
10050: GO 10052
10052: DISABLE
// YouLost (  ) ;
10053: LD_STRING 
10055: PPUSH
10056: CALL_OW 104
10060: END
// every 0 0$1 trigger StreamModeActive and sFog do
10061: LD_EXP 24
10065: PUSH
10066: LD_EXP 45
10070: AND
10071: IFFALSE 10085
10073: GO 10075
10075: DISABLE
// FogOff ( your_side ) ;
10076: LD_OWVAR 2
10080: PPUSH
10081: CALL_OW 344
10085: END
// every 0 0$1 trigger StreamModeActive and sSun do
10086: LD_EXP 24
10090: PUSH
10091: LD_EXP 47
10095: AND
10096: IFFALSE 10124
10098: GO 10100
10100: DISABLE
// begin solar_recharge_percent := 0 ;
10101: LD_ADDR_OWVAR 79
10105: PUSH
10106: LD_INT 0
10108: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10109: LD_INT 10500
10111: PPUSH
10112: CALL_OW 67
// solar_recharge_percent := 100 ;
10116: LD_ADDR_OWVAR 79
10120: PUSH
10121: LD_INT 100
10123: ST_TO_ADDR
// end ;
10124: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
10125: LD_EXP 24
10129: PUSH
10130: LD_EXP 48
10134: AND
10135: IFFALSE 10374
10137: GO 10139
10139: DISABLE
10140: LD_INT 0
10142: PPUSH
10143: PPUSH
10144: PPUSH
// begin tmp := [ ] ;
10145: LD_ADDR_VAR 0 3
10149: PUSH
10150: EMPTY
10151: ST_TO_ADDR
// for i := 1 to 6 do
10152: LD_ADDR_VAR 0 1
10156: PUSH
10157: DOUBLE
10158: LD_INT 1
10160: DEC
10161: ST_TO_ADDR
10162: LD_INT 6
10164: PUSH
10165: FOR_TO
10166: IFFALSE 10271
// begin uc_nation := nation_nature ;
10168: LD_ADDR_OWVAR 21
10172: PUSH
10173: LD_INT 0
10175: ST_TO_ADDR
// uc_side := 0 ;
10176: LD_ADDR_OWVAR 20
10180: PUSH
10181: LD_INT 0
10183: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
10184: LD_ADDR_OWVAR 29
10188: PUSH
10189: LD_INT 12
10191: PUSH
10192: LD_INT 12
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: ST_TO_ADDR
// hc_agressivity := 20 ;
10199: LD_ADDR_OWVAR 35
10203: PUSH
10204: LD_INT 20
10206: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
10207: LD_ADDR_OWVAR 28
10211: PUSH
10212: LD_INT 17
10214: ST_TO_ADDR
// hc_gallery :=  ;
10215: LD_ADDR_OWVAR 33
10219: PUSH
10220: LD_STRING 
10222: ST_TO_ADDR
// hc_name :=  ;
10223: LD_ADDR_OWVAR 26
10227: PUSH
10228: LD_STRING 
10230: ST_TO_ADDR
// un := CreateHuman ;
10231: LD_ADDR_VAR 0 2
10235: PUSH
10236: CALL_OW 44
10240: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
10241: LD_VAR 0 2
10245: PPUSH
10246: LD_INT 1
10248: PPUSH
10249: CALL_OW 51
// tmp := tmp ^ un ;
10253: LD_ADDR_VAR 0 3
10257: PUSH
10258: LD_VAR 0 3
10262: PUSH
10263: LD_VAR 0 2
10267: ADD
10268: ST_TO_ADDR
// end ;
10269: GO 10165
10271: POP
10272: POP
// repeat wait ( 0 0$1 ) ;
10273: LD_INT 35
10275: PPUSH
10276: CALL_OW 67
// for un in tmp do
10280: LD_ADDR_VAR 0 2
10284: PUSH
10285: LD_VAR 0 3
10289: PUSH
10290: FOR_IN
10291: IFFALSE 10365
// begin if IsDead ( un ) then
10293: LD_VAR 0 2
10297: PPUSH
10298: CALL_OW 301
10302: IFFALSE 10322
// begin tmp := tmp diff un ;
10304: LD_ADDR_VAR 0 3
10308: PUSH
10309: LD_VAR 0 3
10313: PUSH
10314: LD_VAR 0 2
10318: DIFF
10319: ST_TO_ADDR
// continue ;
10320: GO 10290
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
10322: LD_VAR 0 2
10326: PPUSH
10327: LD_INT 3
10329: PUSH
10330: LD_INT 22
10332: PUSH
10333: LD_INT 0
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: PPUSH
10344: CALL_OW 69
10348: PPUSH
10349: LD_VAR 0 2
10353: PPUSH
10354: CALL_OW 74
10358: PPUSH
10359: CALL_OW 115
// end ;
10363: GO 10290
10365: POP
10366: POP
// until not tmp ;
10367: LD_VAR 0 3
10371: NOT
10372: IFFALSE 10273
// end ;
10374: PPOPN 3
10376: END
// every 0 0$1 trigger StreamModeActive and sTroll do
10377: LD_EXP 24
10381: PUSH
10382: LD_EXP 49
10386: AND
10387: IFFALSE 10441
10389: GO 10391
10391: DISABLE
// begin ToLua ( displayTroll(); ) ;
10392: LD_STRING displayTroll();
10394: PPUSH
10395: CALL_OW 559
// wait ( 3 3$00 ) ;
10399: LD_INT 6300
10401: PPUSH
10402: CALL_OW 67
// ToLua ( hideTroll(); ) ;
10406: LD_STRING hideTroll();
10408: PPUSH
10409: CALL_OW 559
// wait ( 1 1$00 ) ;
10413: LD_INT 2100
10415: PPUSH
10416: CALL_OW 67
// ToLua ( displayTroll(); ) ;
10420: LD_STRING displayTroll();
10422: PPUSH
10423: CALL_OW 559
// wait ( 1 1$00 ) ;
10427: LD_INT 2100
10429: PPUSH
10430: CALL_OW 67
// ToLua ( hideTroll(); ) ;
10434: LD_STRING hideTroll();
10436: PPUSH
10437: CALL_OW 559
// end ;
10441: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
10442: LD_EXP 24
10446: PUSH
10447: LD_EXP 50
10451: AND
10452: IFFALSE 10515
10454: GO 10456
10456: DISABLE
10457: LD_INT 0
10459: PPUSH
// begin p := 0 ;
10460: LD_ADDR_VAR 0 1
10464: PUSH
10465: LD_INT 0
10467: ST_TO_ADDR
// repeat game_speed := 1 ;
10468: LD_ADDR_OWVAR 65
10472: PUSH
10473: LD_INT 1
10475: ST_TO_ADDR
// wait ( 0 0$1 ) ;
10476: LD_INT 35
10478: PPUSH
10479: CALL_OW 67
// p := p + 1 ;
10483: LD_ADDR_VAR 0 1
10487: PUSH
10488: LD_VAR 0 1
10492: PUSH
10493: LD_INT 1
10495: PLUS
10496: ST_TO_ADDR
// until p >= 60 ;
10497: LD_VAR 0 1
10501: PUSH
10502: LD_INT 60
10504: GREATEREQUAL
10505: IFFALSE 10468
// game_speed := 4 ;
10507: LD_ADDR_OWVAR 65
10511: PUSH
10512: LD_INT 4
10514: ST_TO_ADDR
// end ;
10515: PPOPN 1
10517: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
10518: LD_EXP 24
10522: PUSH
10523: LD_EXP 51
10527: AND
10528: IFFALSE 10674
10530: GO 10532
10532: DISABLE
10533: LD_INT 0
10535: PPUSH
10536: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
10537: LD_ADDR_VAR 0 1
10541: PUSH
10542: LD_INT 22
10544: PUSH
10545: LD_OWVAR 2
10549: PUSH
10550: EMPTY
10551: LIST
10552: LIST
10553: PUSH
10554: LD_INT 2
10556: PUSH
10557: LD_INT 30
10559: PUSH
10560: LD_INT 0
10562: PUSH
10563: EMPTY
10564: LIST
10565: LIST
10566: PUSH
10567: LD_INT 30
10569: PUSH
10570: LD_INT 1
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PUSH
10577: EMPTY
10578: LIST
10579: LIST
10580: LIST
10581: PUSH
10582: EMPTY
10583: LIST
10584: LIST
10585: PPUSH
10586: CALL_OW 69
10590: ST_TO_ADDR
// if not depot then
10591: LD_VAR 0 1
10595: NOT
10596: IFFALSE 10600
// exit ;
10598: GO 10674
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
10600: LD_ADDR_VAR 0 2
10604: PUSH
10605: LD_VAR 0 1
10609: PUSH
10610: LD_INT 1
10612: PPUSH
10613: LD_VAR 0 1
10617: PPUSH
10618: CALL_OW 12
10622: ARRAY
10623: PPUSH
10624: CALL_OW 274
10628: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
10629: LD_VAR 0 2
10633: PPUSH
10634: LD_INT 1
10636: PPUSH
10637: LD_INT 0
10639: PPUSH
10640: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
10644: LD_VAR 0 2
10648: PPUSH
10649: LD_INT 2
10651: PPUSH
10652: LD_INT 0
10654: PPUSH
10655: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
10659: LD_VAR 0 2
10663: PPUSH
10664: LD_INT 3
10666: PPUSH
10667: LD_INT 0
10669: PPUSH
10670: CALL_OW 277
// end ;
10674: PPOPN 2
10676: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
10677: LD_EXP 24
10681: PUSH
10682: LD_EXP 52
10686: AND
10687: IFFALSE 10784
10689: GO 10691
10691: DISABLE
10692: LD_INT 0
10694: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
10695: LD_ADDR_VAR 0 1
10699: PUSH
10700: LD_INT 22
10702: PUSH
10703: LD_OWVAR 2
10707: PUSH
10708: EMPTY
10709: LIST
10710: LIST
10711: PUSH
10712: LD_INT 21
10714: PUSH
10715: LD_INT 1
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: LD_INT 3
10724: PUSH
10725: LD_INT 23
10727: PUSH
10728: LD_INT 0
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: EMPTY
10736: LIST
10737: LIST
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: LIST
10743: PPUSH
10744: CALL_OW 69
10748: ST_TO_ADDR
// if not tmp then
10749: LD_VAR 0 1
10753: NOT
10754: IFFALSE 10758
// exit ;
10756: GO 10784
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
10758: LD_VAR 0 1
10762: PUSH
10763: LD_INT 1
10765: PPUSH
10766: LD_VAR 0 1
10770: PPUSH
10771: CALL_OW 12
10775: ARRAY
10776: PPUSH
10777: LD_INT 200
10779: PPUSH
10780: CALL_OW 234
// end ;
10784: PPOPN 1
10786: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
10787: LD_EXP 24
10791: PUSH
10792: LD_EXP 53
10796: AND
10797: IFFALSE 10876
10799: GO 10801
10801: DISABLE
10802: LD_INT 0
10804: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
10805: LD_ADDR_VAR 0 1
10809: PUSH
10810: LD_INT 22
10812: PUSH
10813: LD_OWVAR 2
10817: PUSH
10818: EMPTY
10819: LIST
10820: LIST
10821: PUSH
10822: LD_INT 21
10824: PUSH
10825: LD_INT 2
10827: PUSH
10828: EMPTY
10829: LIST
10830: LIST
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: PPUSH
10836: CALL_OW 69
10840: ST_TO_ADDR
// if not tmp then
10841: LD_VAR 0 1
10845: NOT
10846: IFFALSE 10850
// exit ;
10848: GO 10876
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
10850: LD_VAR 0 1
10854: PUSH
10855: LD_INT 1
10857: PPUSH
10858: LD_VAR 0 1
10862: PPUSH
10863: CALL_OW 12
10867: ARRAY
10868: PPUSH
10869: LD_INT 60
10871: PPUSH
10872: CALL_OW 234
// end ;
10876: PPOPN 1
10878: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
10879: LD_EXP 24
10883: PUSH
10884: LD_EXP 54
10888: AND
10889: IFFALSE 10988
10891: GO 10893
10893: DISABLE
10894: LD_INT 0
10896: PPUSH
10897: PPUSH
// begin enable ;
10898: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
10899: LD_ADDR_VAR 0 1
10903: PUSH
10904: LD_INT 22
10906: PUSH
10907: LD_OWVAR 2
10911: PUSH
10912: EMPTY
10913: LIST
10914: LIST
10915: PUSH
10916: LD_INT 61
10918: PUSH
10919: EMPTY
10920: LIST
10921: PUSH
10922: LD_INT 33
10924: PUSH
10925: LD_INT 2
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: LIST
10936: PPUSH
10937: CALL_OW 69
10941: ST_TO_ADDR
// if not tmp then
10942: LD_VAR 0 1
10946: NOT
10947: IFFALSE 10951
// exit ;
10949: GO 10988
// for i in tmp do
10951: LD_ADDR_VAR 0 2
10955: PUSH
10956: LD_VAR 0 1
10960: PUSH
10961: FOR_IN
10962: IFFALSE 10986
// if IsControledBy ( i ) then
10964: LD_VAR 0 2
10968: PPUSH
10969: CALL_OW 312
10973: IFFALSE 10984
// ComUnlink ( i ) ;
10975: LD_VAR 0 2
10979: PPUSH
10980: CALL_OW 136
10984: GO 10961
10986: POP
10987: POP
// end ;
10988: PPOPN 2
10990: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
10991: LD_EXP 24
10995: PUSH
10996: LD_EXP 55
11000: AND
11001: IFFALSE 11141
11003: GO 11005
11005: DISABLE
11006: LD_INT 0
11008: PPUSH
11009: PPUSH
// begin ToLua ( displayPowell(); ) ;
11010: LD_STRING displayPowell();
11012: PPUSH
11013: CALL_OW 559
// uc_side := 0 ;
11017: LD_ADDR_OWVAR 20
11021: PUSH
11022: LD_INT 0
11024: ST_TO_ADDR
// uc_nation := 2 ;
11025: LD_ADDR_OWVAR 21
11029: PUSH
11030: LD_INT 2
11032: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
11033: LD_ADDR_OWVAR 37
11037: PUSH
11038: LD_INT 14
11040: ST_TO_ADDR
// vc_engine := engine_siberite ;
11041: LD_ADDR_OWVAR 39
11045: PUSH
11046: LD_INT 3
11048: ST_TO_ADDR
// vc_control := control_apeman ;
11049: LD_ADDR_OWVAR 38
11053: PUSH
11054: LD_INT 5
11056: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
11057: LD_ADDR_OWVAR 40
11061: PUSH
11062: LD_INT 29
11064: ST_TO_ADDR
// un := CreateVehicle ;
11065: LD_ADDR_VAR 0 2
11069: PUSH
11070: CALL_OW 45
11074: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11075: LD_VAR 0 2
11079: PPUSH
11080: LD_INT 1
11082: PPUSH
11083: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
11087: LD_INT 35
11089: PPUSH
11090: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
11094: LD_VAR 0 2
11098: PPUSH
11099: LD_INT 22
11101: PUSH
11102: LD_OWVAR 2
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: PPUSH
11111: CALL_OW 69
11115: PPUSH
11116: LD_VAR 0 2
11120: PPUSH
11121: CALL_OW 74
11125: PPUSH
11126: CALL_OW 115
// until IsDead ( un ) ;
11130: LD_VAR 0 2
11134: PPUSH
11135: CALL_OW 301
11139: IFFALSE 11087
// end ;
11141: PPOPN 2
11143: END
// every 0 0$1 trigger StreamModeActive and sStu do
11144: LD_EXP 24
11148: PUSH
11149: LD_EXP 63
11153: AND
11154: IFFALSE 11170
11156: GO 11158
11158: DISABLE
// begin ToLua ( displayStucuk(); ) ;
11159: LD_STRING displayStucuk();
11161: PPUSH
11162: CALL_OW 559
// ResetFog ;
11166: CALL_OW 335
// end ;
11170: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
11171: LD_EXP 24
11175: PUSH
11176: LD_EXP 56
11180: AND
11181: IFFALSE 11322
11183: GO 11185
11185: DISABLE
11186: LD_INT 0
11188: PPUSH
11189: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
11190: LD_ADDR_VAR 0 2
11194: PUSH
11195: LD_INT 22
11197: PUSH
11198: LD_OWVAR 2
11202: PUSH
11203: EMPTY
11204: LIST
11205: LIST
11206: PUSH
11207: LD_INT 21
11209: PUSH
11210: LD_INT 1
11212: PUSH
11213: EMPTY
11214: LIST
11215: LIST
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PPUSH
11221: CALL_OW 69
11225: ST_TO_ADDR
// if not tmp then
11226: LD_VAR 0 2
11230: NOT
11231: IFFALSE 11235
// exit ;
11233: GO 11322
// un := tmp [ rand ( 1 , tmp ) ] ;
11235: LD_ADDR_VAR 0 1
11239: PUSH
11240: LD_VAR 0 2
11244: PUSH
11245: LD_INT 1
11247: PPUSH
11248: LD_VAR 0 2
11252: PPUSH
11253: CALL_OW 12
11257: ARRAY
11258: ST_TO_ADDR
// SetSide ( un , 0 ) ;
11259: LD_VAR 0 1
11263: PPUSH
11264: LD_INT 0
11266: PPUSH
11267: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
11271: LD_VAR 0 1
11275: PPUSH
11276: LD_OWVAR 3
11280: PUSH
11281: LD_VAR 0 1
11285: DIFF
11286: PPUSH
11287: LD_VAR 0 1
11291: PPUSH
11292: CALL_OW 74
11296: PPUSH
11297: CALL_OW 115
// wait ( 0 0$20 ) ;
11301: LD_INT 700
11303: PPUSH
11304: CALL_OW 67
// SetSide ( un , your_side ) ;
11308: LD_VAR 0 1
11312: PPUSH
11313: LD_OWVAR 2
11317: PPUSH
11318: CALL_OW 235
// end ;
11322: PPOPN 2
11324: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
11325: LD_EXP 24
11329: PUSH
11330: LD_EXP 57
11334: AND
11335: IFFALSE 11441
11337: GO 11339
11339: DISABLE
11340: LD_INT 0
11342: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
11343: LD_ADDR_VAR 0 1
11347: PUSH
11348: LD_INT 22
11350: PUSH
11351: LD_OWVAR 2
11355: PUSH
11356: EMPTY
11357: LIST
11358: LIST
11359: PUSH
11360: LD_INT 2
11362: PUSH
11363: LD_INT 30
11365: PUSH
11366: LD_INT 0
11368: PUSH
11369: EMPTY
11370: LIST
11371: LIST
11372: PUSH
11373: LD_INT 30
11375: PUSH
11376: LD_INT 1
11378: PUSH
11379: EMPTY
11380: LIST
11381: LIST
11382: PUSH
11383: EMPTY
11384: LIST
11385: LIST
11386: LIST
11387: PUSH
11388: EMPTY
11389: LIST
11390: LIST
11391: PPUSH
11392: CALL_OW 69
11396: ST_TO_ADDR
// if not depot then
11397: LD_VAR 0 1
11401: NOT
11402: IFFALSE 11406
// exit ;
11404: GO 11441
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
11406: LD_VAR 0 1
11410: PUSH
11411: LD_INT 1
11413: ARRAY
11414: PPUSH
11415: CALL_OW 250
11419: PPUSH
11420: LD_VAR 0 1
11424: PUSH
11425: LD_INT 1
11427: ARRAY
11428: PPUSH
11429: CALL_OW 251
11433: PPUSH
11434: LD_INT 70
11436: PPUSH
11437: CALL_OW 495
// end ;
11441: PPOPN 1
11443: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
11444: LD_EXP 24
11448: PUSH
11449: LD_EXP 58
11453: AND
11454: IFFALSE 11665
11456: GO 11458
11458: DISABLE
11459: LD_INT 0
11461: PPUSH
11462: PPUSH
11463: PPUSH
11464: PPUSH
11465: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
11466: LD_ADDR_VAR 0 5
11470: PUSH
11471: LD_INT 22
11473: PUSH
11474: LD_OWVAR 2
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: LD_INT 21
11485: PUSH
11486: LD_INT 1
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: PPUSH
11497: CALL_OW 69
11501: ST_TO_ADDR
// if not tmp then
11502: LD_VAR 0 5
11506: NOT
11507: IFFALSE 11511
// exit ;
11509: GO 11665
// for i in tmp do
11511: LD_ADDR_VAR 0 1
11515: PUSH
11516: LD_VAR 0 5
11520: PUSH
11521: FOR_IN
11522: IFFALSE 11663
// begin d := rand ( 0 , 5 ) ;
11524: LD_ADDR_VAR 0 4
11528: PUSH
11529: LD_INT 0
11531: PPUSH
11532: LD_INT 5
11534: PPUSH
11535: CALL_OW 12
11539: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
11540: LD_ADDR_VAR 0 2
11544: PUSH
11545: LD_VAR 0 1
11549: PPUSH
11550: CALL_OW 250
11554: PPUSH
11555: LD_VAR 0 4
11559: PPUSH
11560: LD_INT 3
11562: PPUSH
11563: LD_INT 12
11565: PPUSH
11566: CALL_OW 12
11570: PPUSH
11571: CALL_OW 272
11575: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
11576: LD_ADDR_VAR 0 3
11580: PUSH
11581: LD_VAR 0 1
11585: PPUSH
11586: CALL_OW 251
11590: PPUSH
11591: LD_VAR 0 4
11595: PPUSH
11596: LD_INT 3
11598: PPUSH
11599: LD_INT 12
11601: PPUSH
11602: CALL_OW 12
11606: PPUSH
11607: CALL_OW 273
11611: ST_TO_ADDR
// if ValidHex ( x , y ) then
11612: LD_VAR 0 2
11616: PPUSH
11617: LD_VAR 0 3
11621: PPUSH
11622: CALL_OW 488
11626: IFFALSE 11661
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
11628: LD_VAR 0 1
11632: PPUSH
11633: LD_VAR 0 2
11637: PPUSH
11638: LD_VAR 0 3
11642: PPUSH
11643: LD_INT 3
11645: PPUSH
11646: LD_INT 6
11648: PPUSH
11649: CALL_OW 12
11653: PPUSH
11654: LD_INT 1
11656: PPUSH
11657: CALL_OW 483
// end ;
11661: GO 11521
11663: POP
11664: POP
// end ;
11665: PPOPN 5
11667: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
11668: LD_EXP 24
11672: PUSH
11673: LD_EXP 59
11677: AND
11678: IFFALSE 11772
11680: GO 11682
11682: DISABLE
11683: LD_INT 0
11685: PPUSH
11686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
11687: LD_ADDR_VAR 0 2
11691: PUSH
11692: LD_INT 22
11694: PUSH
11695: LD_OWVAR 2
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: PUSH
11704: LD_INT 32
11706: PUSH
11707: LD_INT 1
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: PUSH
11714: LD_INT 21
11716: PUSH
11717: LD_INT 2
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: PUSH
11724: EMPTY
11725: LIST
11726: LIST
11727: LIST
11728: PPUSH
11729: CALL_OW 69
11733: ST_TO_ADDR
// if not tmp then
11734: LD_VAR 0 2
11738: NOT
11739: IFFALSE 11743
// exit ;
11741: GO 11772
// for i in tmp do
11743: LD_ADDR_VAR 0 1
11747: PUSH
11748: LD_VAR 0 2
11752: PUSH
11753: FOR_IN
11754: IFFALSE 11770
// SetFuel ( i , 0 ) ;
11756: LD_VAR 0 1
11760: PPUSH
11761: LD_INT 0
11763: PPUSH
11764: CALL_OW 240
11768: GO 11753
11770: POP
11771: POP
// end ;
11772: PPOPN 2
11774: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
11775: LD_EXP 24
11779: PUSH
11780: LD_EXP 60
11784: AND
11785: IFFALSE 11851
11787: GO 11789
11789: DISABLE
11790: LD_INT 0
11792: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
11793: LD_ADDR_VAR 0 1
11797: PUSH
11798: LD_INT 22
11800: PUSH
11801: LD_OWVAR 2
11805: PUSH
11806: EMPTY
11807: LIST
11808: LIST
11809: PUSH
11810: LD_INT 30
11812: PUSH
11813: LD_INT 29
11815: PUSH
11816: EMPTY
11817: LIST
11818: LIST
11819: PUSH
11820: EMPTY
11821: LIST
11822: LIST
11823: PPUSH
11824: CALL_OW 69
11828: ST_TO_ADDR
// if not tmp then
11829: LD_VAR 0 1
11833: NOT
11834: IFFALSE 11838
// exit ;
11836: GO 11851
// DestroyUnit ( tmp [ 1 ] ) ;
11838: LD_VAR 0 1
11842: PUSH
11843: LD_INT 1
11845: ARRAY
11846: PPUSH
11847: CALL_OW 65
// end ;
11851: PPOPN 1
11853: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
11854: LD_EXP 24
11858: PUSH
11859: LD_EXP 62
11863: AND
11864: IFFALSE 11993
11866: GO 11868
11868: DISABLE
11869: LD_INT 0
11871: PPUSH
// begin uc_side := 0 ;
11872: LD_ADDR_OWVAR 20
11876: PUSH
11877: LD_INT 0
11879: ST_TO_ADDR
// uc_nation := nation_arabian ;
11880: LD_ADDR_OWVAR 21
11884: PUSH
11885: LD_INT 2
11887: ST_TO_ADDR
// hc_gallery :=  ;
11888: LD_ADDR_OWVAR 33
11892: PUSH
11893: LD_STRING 
11895: ST_TO_ADDR
// hc_name :=  ;
11896: LD_ADDR_OWVAR 26
11900: PUSH
11901: LD_STRING 
11903: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
11904: LD_INT 1
11906: PPUSH
11907: LD_INT 11
11909: PPUSH
11910: LD_INT 10
11912: PPUSH
11913: CALL_OW 380
// un := CreateHuman ;
11917: LD_ADDR_VAR 0 1
11921: PUSH
11922: CALL_OW 44
11926: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11927: LD_VAR 0 1
11931: PPUSH
11932: LD_INT 1
11934: PPUSH
11935: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
11939: LD_INT 35
11941: PPUSH
11942: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
11946: LD_VAR 0 1
11950: PPUSH
11951: LD_INT 22
11953: PUSH
11954: LD_OWVAR 2
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: PPUSH
11963: CALL_OW 69
11967: PPUSH
11968: LD_VAR 0 1
11972: PPUSH
11973: CALL_OW 74
11977: PPUSH
11978: CALL_OW 115
// until IsDead ( un ) ;
11982: LD_VAR 0 1
11986: PPUSH
11987: CALL_OW 301
11991: IFFALSE 11939
// end ;
11993: PPOPN 1
11995: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
11996: LD_EXP 24
12000: PUSH
12001: LD_EXP 64
12005: AND
12006: IFFALSE 12018
12008: GO 12010
12010: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
12011: LD_STRING earthquake(getX(game), 0, 32)
12013: PPUSH
12014: CALL_OW 559
12018: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
12019: LD_EXP 24
12023: PUSH
12024: LD_EXP 65
12028: AND
12029: IFFALSE 12120
12031: GO 12033
12033: DISABLE
12034: LD_INT 0
12036: PPUSH
// begin enable ;
12037: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
12038: LD_ADDR_VAR 0 1
12042: PUSH
12043: LD_INT 22
12045: PUSH
12046: LD_OWVAR 2
12050: PUSH
12051: EMPTY
12052: LIST
12053: LIST
12054: PUSH
12055: LD_INT 21
12057: PUSH
12058: LD_INT 2
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: PUSH
12065: LD_INT 33
12067: PUSH
12068: LD_INT 3
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: EMPTY
12076: LIST
12077: LIST
12078: LIST
12079: PPUSH
12080: CALL_OW 69
12084: ST_TO_ADDR
// if not tmp then
12085: LD_VAR 0 1
12089: NOT
12090: IFFALSE 12094
// exit ;
12092: GO 12120
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
12094: LD_VAR 0 1
12098: PUSH
12099: LD_INT 1
12101: PPUSH
12102: LD_VAR 0 1
12106: PPUSH
12107: CALL_OW 12
12111: ARRAY
12112: PPUSH
12113: LD_INT 1
12115: PPUSH
12116: CALL_OW 234
// end ;
12120: PPOPN 1
12122: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
12123: LD_EXP 24
12127: PUSH
12128: LD_EXP 66
12132: AND
12133: IFFALSE 12274
12135: GO 12137
12137: DISABLE
12138: LD_INT 0
12140: PPUSH
12141: PPUSH
12142: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12143: LD_ADDR_VAR 0 3
12147: PUSH
12148: LD_INT 22
12150: PUSH
12151: LD_OWVAR 2
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: PUSH
12160: LD_INT 25
12162: PUSH
12163: LD_INT 1
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: PPUSH
12174: CALL_OW 69
12178: ST_TO_ADDR
// if not tmp then
12179: LD_VAR 0 3
12183: NOT
12184: IFFALSE 12188
// exit ;
12186: GO 12274
// un := tmp [ rand ( 1 , tmp ) ] ;
12188: LD_ADDR_VAR 0 2
12192: PUSH
12193: LD_VAR 0 3
12197: PUSH
12198: LD_INT 1
12200: PPUSH
12201: LD_VAR 0 3
12205: PPUSH
12206: CALL_OW 12
12210: ARRAY
12211: ST_TO_ADDR
// if Crawls ( un ) then
12212: LD_VAR 0 2
12216: PPUSH
12217: CALL_OW 318
12221: IFFALSE 12232
// ComWalk ( un ) ;
12223: LD_VAR 0 2
12227: PPUSH
12228: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
12232: LD_VAR 0 2
12236: PPUSH
12237: LD_INT 9
12239: PPUSH
12240: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
12244: LD_INT 28
12246: PPUSH
12247: LD_OWVAR 2
12251: PPUSH
12252: LD_INT 2
12254: PPUSH
12255: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
12259: LD_INT 29
12261: PPUSH
12262: LD_OWVAR 2
12266: PPUSH
12267: LD_INT 2
12269: PPUSH
12270: CALL_OW 322
// end ;
12274: PPOPN 3
12276: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
12277: LD_EXP 24
12281: PUSH
12282: LD_EXP 67
12286: AND
12287: IFFALSE 12398
12289: GO 12291
12291: DISABLE
12292: LD_INT 0
12294: PPUSH
12295: PPUSH
12296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
12297: LD_ADDR_VAR 0 3
12301: PUSH
12302: LD_INT 22
12304: PUSH
12305: LD_OWVAR 2
12309: PUSH
12310: EMPTY
12311: LIST
12312: LIST
12313: PUSH
12314: LD_INT 25
12316: PUSH
12317: LD_INT 1
12319: PUSH
12320: EMPTY
12321: LIST
12322: LIST
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PPUSH
12328: CALL_OW 69
12332: ST_TO_ADDR
// if not tmp then
12333: LD_VAR 0 3
12337: NOT
12338: IFFALSE 12342
// exit ;
12340: GO 12398
// un := tmp [ rand ( 1 , tmp ) ] ;
12342: LD_ADDR_VAR 0 2
12346: PUSH
12347: LD_VAR 0 3
12351: PUSH
12352: LD_INT 1
12354: PPUSH
12355: LD_VAR 0 3
12359: PPUSH
12360: CALL_OW 12
12364: ARRAY
12365: ST_TO_ADDR
// if Crawls ( un ) then
12366: LD_VAR 0 2
12370: PPUSH
12371: CALL_OW 318
12375: IFFALSE 12386
// ComWalk ( un ) ;
12377: LD_VAR 0 2
12381: PPUSH
12382: CALL_OW 138
// SetClass ( un , class_mortar ) ;
12386: LD_VAR 0 2
12390: PPUSH
12391: LD_INT 8
12393: PPUSH
12394: CALL_OW 336
// end ;
12398: PPOPN 3
12400: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
12401: LD_EXP 24
12405: PUSH
12406: LD_EXP 68
12410: AND
12411: IFFALSE 12555
12413: GO 12415
12415: DISABLE
12416: LD_INT 0
12418: PPUSH
12419: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
12420: LD_ADDR_VAR 0 2
12424: PUSH
12425: LD_INT 22
12427: PUSH
12428: LD_OWVAR 2
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: PUSH
12437: LD_INT 21
12439: PUSH
12440: LD_INT 2
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PUSH
12447: LD_INT 2
12449: PUSH
12450: LD_INT 34
12452: PUSH
12453: LD_INT 12
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 34
12462: PUSH
12463: LD_INT 51
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: LD_INT 34
12472: PUSH
12473: LD_INT 32
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: EMPTY
12481: LIST
12482: LIST
12483: LIST
12484: LIST
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: LIST
12490: PPUSH
12491: CALL_OW 69
12495: ST_TO_ADDR
// if not tmp then
12496: LD_VAR 0 2
12500: NOT
12501: IFFALSE 12505
// exit ;
12503: GO 12555
// for i in tmp do
12505: LD_ADDR_VAR 0 1
12509: PUSH
12510: LD_VAR 0 2
12514: PUSH
12515: FOR_IN
12516: IFFALSE 12553
// if GetCargo ( i , mat_artifact ) = 0 then
12518: LD_VAR 0 1
12522: PPUSH
12523: LD_INT 4
12525: PPUSH
12526: CALL_OW 289
12530: PUSH
12531: LD_INT 0
12533: EQUAL
12534: IFFALSE 12551
// SetCargo ( i , mat_siberit , 100 ) ;
12536: LD_VAR 0 1
12540: PPUSH
12541: LD_INT 3
12543: PPUSH
12544: LD_INT 100
12546: PPUSH
12547: CALL_OW 290
12551: GO 12515
12553: POP
12554: POP
// end ;
12555: PPOPN 2
12557: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
12558: LD_EXP 24
12562: PUSH
12563: LD_EXP 69
12567: AND
12568: IFFALSE 12721
12570: GO 12572
12572: DISABLE
12573: LD_INT 0
12575: PPUSH
12576: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
12577: LD_ADDR_VAR 0 2
12581: PUSH
12582: LD_INT 22
12584: PUSH
12585: LD_OWVAR 2
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: PPUSH
12594: CALL_OW 69
12598: ST_TO_ADDR
// if not tmp then
12599: LD_VAR 0 2
12603: NOT
12604: IFFALSE 12608
// exit ;
12606: GO 12721
// for i := 1 to 2 do
12608: LD_ADDR_VAR 0 1
12612: PUSH
12613: DOUBLE
12614: LD_INT 1
12616: DEC
12617: ST_TO_ADDR
12618: LD_INT 2
12620: PUSH
12621: FOR_TO
12622: IFFALSE 12719
// begin uc_side := your_side ;
12624: LD_ADDR_OWVAR 20
12628: PUSH
12629: LD_OWVAR 2
12633: ST_TO_ADDR
// uc_nation := nation_american ;
12634: LD_ADDR_OWVAR 21
12638: PUSH
12639: LD_INT 1
12641: ST_TO_ADDR
// vc_chassis := us_morphling ;
12642: LD_ADDR_OWVAR 37
12646: PUSH
12647: LD_INT 5
12649: ST_TO_ADDR
// vc_engine := engine_siberite ;
12650: LD_ADDR_OWVAR 39
12654: PUSH
12655: LD_INT 3
12657: ST_TO_ADDR
// vc_control := control_computer ;
12658: LD_ADDR_OWVAR 38
12662: PUSH
12663: LD_INT 3
12665: ST_TO_ADDR
// vc_weapon := us_double_laser ;
12666: LD_ADDR_OWVAR 40
12670: PUSH
12671: LD_INT 10
12673: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
12674: CALL_OW 45
12678: PPUSH
12679: LD_VAR 0 2
12683: PUSH
12684: LD_INT 1
12686: ARRAY
12687: PPUSH
12688: CALL_OW 250
12692: PPUSH
12693: LD_VAR 0 2
12697: PUSH
12698: LD_INT 1
12700: ARRAY
12701: PPUSH
12702: CALL_OW 251
12706: PPUSH
12707: LD_INT 12
12709: PPUSH
12710: LD_INT 1
12712: PPUSH
12713: CALL_OW 50
// end ;
12717: GO 12621
12719: POP
12720: POP
// end ;
12721: PPOPN 2
12723: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
12724: LD_EXP 24
12728: PUSH
12729: LD_EXP 70
12733: AND
12734: IFFALSE 12956
12736: GO 12738
12738: DISABLE
12739: LD_INT 0
12741: PPUSH
12742: PPUSH
12743: PPUSH
12744: PPUSH
12745: PPUSH
12746: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
12747: LD_ADDR_VAR 0 6
12751: PUSH
12752: LD_INT 22
12754: PUSH
12755: LD_OWVAR 2
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: LD_INT 21
12766: PUSH
12767: LD_INT 1
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PUSH
12774: LD_INT 3
12776: PUSH
12777: LD_INT 23
12779: PUSH
12780: LD_INT 0
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: LIST
12795: PPUSH
12796: CALL_OW 69
12800: ST_TO_ADDR
// if not tmp then
12801: LD_VAR 0 6
12805: NOT
12806: IFFALSE 12810
// exit ;
12808: GO 12956
// s1 := rand ( 1 , 4 ) ;
12810: LD_ADDR_VAR 0 2
12814: PUSH
12815: LD_INT 1
12817: PPUSH
12818: LD_INT 4
12820: PPUSH
12821: CALL_OW 12
12825: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
12826: LD_ADDR_VAR 0 4
12830: PUSH
12831: LD_VAR 0 6
12835: PUSH
12836: LD_INT 1
12838: ARRAY
12839: PPUSH
12840: LD_VAR 0 2
12844: PPUSH
12845: CALL_OW 259
12849: ST_TO_ADDR
// if s1 = 1 then
12850: LD_VAR 0 2
12854: PUSH
12855: LD_INT 1
12857: EQUAL
12858: IFFALSE 12878
// s2 := rand ( 2 , 4 ) else
12860: LD_ADDR_VAR 0 3
12864: PUSH
12865: LD_INT 2
12867: PPUSH
12868: LD_INT 4
12870: PPUSH
12871: CALL_OW 12
12875: ST_TO_ADDR
12876: GO 12886
// s2 := 1 ;
12878: LD_ADDR_VAR 0 3
12882: PUSH
12883: LD_INT 1
12885: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
12886: LD_ADDR_VAR 0 5
12890: PUSH
12891: LD_VAR 0 6
12895: PUSH
12896: LD_INT 1
12898: ARRAY
12899: PPUSH
12900: LD_VAR 0 3
12904: PPUSH
12905: CALL_OW 259
12909: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
12910: LD_VAR 0 6
12914: PUSH
12915: LD_INT 1
12917: ARRAY
12918: PPUSH
12919: LD_VAR 0 2
12923: PPUSH
12924: LD_VAR 0 5
12928: PPUSH
12929: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
12933: LD_VAR 0 6
12937: PUSH
12938: LD_INT 1
12940: ARRAY
12941: PPUSH
12942: LD_VAR 0 3
12946: PPUSH
12947: LD_VAR 0 4
12951: PPUSH
12952: CALL_OW 237
// end ;
12956: PPOPN 6
12958: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
12959: LD_EXP 24
12963: PUSH
12964: LD_EXP 71
12968: AND
12969: IFFALSE 13048
12971: GO 12973
12973: DISABLE
12974: LD_INT 0
12976: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
12977: LD_ADDR_VAR 0 1
12981: PUSH
12982: LD_INT 22
12984: PUSH
12985: LD_OWVAR 2
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: LD_INT 30
12996: PUSH
12997: LD_INT 3
12999: PUSH
13000: EMPTY
13001: LIST
13002: LIST
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: PPUSH
13008: CALL_OW 69
13012: ST_TO_ADDR
// if not tmp then
13013: LD_VAR 0 1
13017: NOT
13018: IFFALSE 13022
// exit ;
13020: GO 13048
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
13022: LD_VAR 0 1
13026: PUSH
13027: LD_INT 1
13029: PPUSH
13030: LD_VAR 0 1
13034: PPUSH
13035: CALL_OW 12
13039: ARRAY
13040: PPUSH
13041: LD_INT 1
13043: PPUSH
13044: CALL_OW 234
// end ;
13048: PPOPN 1
13050: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
13051: LD_EXP 24
13055: PUSH
13056: LD_EXP 72
13060: AND
13061: IFFALSE 13173
13063: GO 13065
13065: DISABLE
13066: LD_INT 0
13068: PPUSH
13069: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
13070: LD_ADDR_VAR 0 2
13074: PUSH
13075: LD_INT 22
13077: PUSH
13078: LD_OWVAR 2
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: PUSH
13087: LD_INT 2
13089: PUSH
13090: LD_INT 30
13092: PUSH
13093: LD_INT 27
13095: PUSH
13096: EMPTY
13097: LIST
13098: LIST
13099: PUSH
13100: LD_INT 30
13102: PUSH
13103: LD_INT 26
13105: PUSH
13106: EMPTY
13107: LIST
13108: LIST
13109: PUSH
13110: LD_INT 30
13112: PUSH
13113: LD_INT 28
13115: PUSH
13116: EMPTY
13117: LIST
13118: LIST
13119: PUSH
13120: EMPTY
13121: LIST
13122: LIST
13123: LIST
13124: LIST
13125: PUSH
13126: EMPTY
13127: LIST
13128: LIST
13129: PPUSH
13130: CALL_OW 69
13134: ST_TO_ADDR
// if not tmp then
13135: LD_VAR 0 2
13139: NOT
13140: IFFALSE 13144
// exit ;
13142: GO 13173
// for i in tmp do
13144: LD_ADDR_VAR 0 1
13148: PUSH
13149: LD_VAR 0 2
13153: PUSH
13154: FOR_IN
13155: IFFALSE 13171
// SetLives ( i , 1 ) ;
13157: LD_VAR 0 1
13161: PPUSH
13162: LD_INT 1
13164: PPUSH
13165: CALL_OW 234
13169: GO 13154
13171: POP
13172: POP
// end ;
13173: PPOPN 2
13175: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
13176: LD_EXP 24
13180: PUSH
13181: LD_EXP 73
13185: AND
13186: IFFALSE 13460
13188: GO 13190
13190: DISABLE
13191: LD_INT 0
13193: PPUSH
13194: PPUSH
13195: PPUSH
// begin i := rand ( 1 , 7 ) ;
13196: LD_ADDR_VAR 0 1
13200: PUSH
13201: LD_INT 1
13203: PPUSH
13204: LD_INT 7
13206: PPUSH
13207: CALL_OW 12
13211: ST_TO_ADDR
// case i of 1 :
13212: LD_VAR 0 1
13216: PUSH
13217: LD_INT 1
13219: DOUBLE
13220: EQUAL
13221: IFTRUE 13225
13223: GO 13235
13225: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
13226: LD_STRING earthquake(getX(game), 0, 32)
13228: PPUSH
13229: CALL_OW 559
13233: GO 13460
13235: LD_INT 2
13237: DOUBLE
13238: EQUAL
13239: IFTRUE 13243
13241: GO 13257
13243: POP
// begin ToLua ( displayStucuk(); ) ;
13244: LD_STRING displayStucuk();
13246: PPUSH
13247: CALL_OW 559
// ResetFog ;
13251: CALL_OW 335
// end ; 3 :
13255: GO 13460
13257: LD_INT 3
13259: DOUBLE
13260: EQUAL
13261: IFTRUE 13265
13263: GO 13369
13265: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
13266: LD_ADDR_VAR 0 2
13270: PUSH
13271: LD_INT 22
13273: PUSH
13274: LD_OWVAR 2
13278: PUSH
13279: EMPTY
13280: LIST
13281: LIST
13282: PUSH
13283: LD_INT 25
13285: PUSH
13286: LD_INT 1
13288: PUSH
13289: EMPTY
13290: LIST
13291: LIST
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PPUSH
13297: CALL_OW 69
13301: ST_TO_ADDR
// if not tmp then
13302: LD_VAR 0 2
13306: NOT
13307: IFFALSE 13311
// exit ;
13309: GO 13460
// un := tmp [ rand ( 1 , tmp ) ] ;
13311: LD_ADDR_VAR 0 3
13315: PUSH
13316: LD_VAR 0 2
13320: PUSH
13321: LD_INT 1
13323: PPUSH
13324: LD_VAR 0 2
13328: PPUSH
13329: CALL_OW 12
13333: ARRAY
13334: ST_TO_ADDR
// if Crawls ( un ) then
13335: LD_VAR 0 3
13339: PPUSH
13340: CALL_OW 318
13344: IFFALSE 13355
// ComWalk ( un ) ;
13346: LD_VAR 0 3
13350: PPUSH
13351: CALL_OW 138
// SetClass ( un , class_mortar ) ;
13355: LD_VAR 0 3
13359: PPUSH
13360: LD_INT 8
13362: PPUSH
13363: CALL_OW 336
// end ; 4 :
13367: GO 13460
13369: LD_INT 4
13371: DOUBLE
13372: EQUAL
13373: IFTRUE 13377
13375: GO 13438
13377: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
13378: LD_ADDR_VAR 0 2
13382: PUSH
13383: LD_INT 22
13385: PUSH
13386: LD_OWVAR 2
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PUSH
13395: LD_INT 30
13397: PUSH
13398: LD_INT 29
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: PUSH
13405: EMPTY
13406: LIST
13407: LIST
13408: PPUSH
13409: CALL_OW 69
13413: ST_TO_ADDR
// if not tmp then
13414: LD_VAR 0 2
13418: NOT
13419: IFFALSE 13423
// exit ;
13421: GO 13460
// DestroyUnit ( tmp [ 1 ] ) ;
13423: LD_VAR 0 2
13427: PUSH
13428: LD_INT 1
13430: ARRAY
13431: PPUSH
13432: CALL_OW 65
// end ; 5 .. 7 :
13436: GO 13460
13438: LD_INT 5
13440: DOUBLE
13441: GREATEREQUAL
13442: IFFALSE 13450
13444: LD_INT 7
13446: DOUBLE
13447: LESSEQUAL
13448: IFTRUE 13452
13450: GO 13459
13452: POP
// StreamSibBomb ; end ;
13453: CALL 9740 0 0
13457: GO 13460
13459: POP
// end ;
13460: PPOPN 3
13462: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
13463: LD_EXP 24
13467: PUSH
13468: LD_EXP 74
13472: AND
13473: IFFALSE 13629
13475: GO 13477
13477: DISABLE
13478: LD_INT 0
13480: PPUSH
13481: PPUSH
13482: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
13483: LD_ADDR_VAR 0 2
13487: PUSH
13488: LD_INT 81
13490: PUSH
13491: LD_OWVAR 2
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PUSH
13500: LD_INT 2
13502: PUSH
13503: LD_INT 21
13505: PUSH
13506: LD_INT 1
13508: PUSH
13509: EMPTY
13510: LIST
13511: LIST
13512: PUSH
13513: LD_INT 21
13515: PUSH
13516: LD_INT 2
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PUSH
13523: EMPTY
13524: LIST
13525: LIST
13526: LIST
13527: PUSH
13528: EMPTY
13529: LIST
13530: LIST
13531: PPUSH
13532: CALL_OW 69
13536: ST_TO_ADDR
// if not tmp then
13537: LD_VAR 0 2
13541: NOT
13542: IFFALSE 13546
// exit ;
13544: GO 13629
// p := 0 ;
13546: LD_ADDR_VAR 0 3
13550: PUSH
13551: LD_INT 0
13553: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13554: LD_INT 35
13556: PPUSH
13557: CALL_OW 67
// p := p + 1 ;
13561: LD_ADDR_VAR 0 3
13565: PUSH
13566: LD_VAR 0 3
13570: PUSH
13571: LD_INT 1
13573: PLUS
13574: ST_TO_ADDR
// for i in tmp do
13575: LD_ADDR_VAR 0 1
13579: PUSH
13580: LD_VAR 0 2
13584: PUSH
13585: FOR_IN
13586: IFFALSE 13617
// if GetLives ( i ) < 1000 then
13588: LD_VAR 0 1
13592: PPUSH
13593: CALL_OW 256
13597: PUSH
13598: LD_INT 1000
13600: LESS
13601: IFFALSE 13615
// SetLives ( i , 1000 ) ;
13603: LD_VAR 0 1
13607: PPUSH
13608: LD_INT 1000
13610: PPUSH
13611: CALL_OW 234
13615: GO 13585
13617: POP
13618: POP
// until p > 20 ;
13619: LD_VAR 0 3
13623: PUSH
13624: LD_INT 20
13626: GREATER
13627: IFFALSE 13554
// end ;
13629: PPOPN 3
13631: END
// every 0 0$1 trigger StreamModeActive and sTime do
13632: LD_EXP 24
13636: PUSH
13637: LD_EXP 75
13641: AND
13642: IFFALSE 13677
13644: GO 13646
13646: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
13647: LD_INT 28
13649: PPUSH
13650: LD_OWVAR 2
13654: PPUSH
13655: LD_INT 2
13657: PPUSH
13658: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
13662: LD_INT 30
13664: PPUSH
13665: LD_OWVAR 2
13669: PPUSH
13670: LD_INT 2
13672: PPUSH
13673: CALL_OW 322
// end ;
13677: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
13678: LD_EXP 24
13682: PUSH
13683: LD_EXP 76
13687: AND
13688: IFFALSE 13809
13690: GO 13692
13692: DISABLE
13693: LD_INT 0
13695: PPUSH
13696: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
13697: LD_ADDR_VAR 0 2
13701: PUSH
13702: LD_INT 22
13704: PUSH
13705: LD_OWVAR 2
13709: PUSH
13710: EMPTY
13711: LIST
13712: LIST
13713: PUSH
13714: LD_INT 21
13716: PUSH
13717: LD_INT 1
13719: PUSH
13720: EMPTY
13721: LIST
13722: LIST
13723: PUSH
13724: LD_INT 3
13726: PUSH
13727: LD_INT 23
13729: PUSH
13730: LD_INT 0
13732: PUSH
13733: EMPTY
13734: LIST
13735: LIST
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: PUSH
13741: EMPTY
13742: LIST
13743: LIST
13744: LIST
13745: PPUSH
13746: CALL_OW 69
13750: ST_TO_ADDR
// if not tmp then
13751: LD_VAR 0 2
13755: NOT
13756: IFFALSE 13760
// exit ;
13758: GO 13809
// for i in tmp do
13760: LD_ADDR_VAR 0 1
13764: PUSH
13765: LD_VAR 0 2
13769: PUSH
13770: FOR_IN
13771: IFFALSE 13807
// begin if Crawls ( i ) then
13773: LD_VAR 0 1
13777: PPUSH
13778: CALL_OW 318
13782: IFFALSE 13793
// ComWalk ( i ) ;
13784: LD_VAR 0 1
13788: PPUSH
13789: CALL_OW 138
// SetClass ( i , 2 ) ;
13793: LD_VAR 0 1
13797: PPUSH
13798: LD_INT 2
13800: PPUSH
13801: CALL_OW 336
// end ;
13805: GO 13770
13807: POP
13808: POP
// end ;
13809: PPOPN 2
13811: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
13812: LD_EXP 24
13816: PUSH
13817: LD_EXP 77
13821: AND
13822: IFFALSE 14103
13824: GO 13826
13826: DISABLE
13827: LD_INT 0
13829: PPUSH
13830: PPUSH
13831: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
13832: LD_OWVAR 2
13836: PPUSH
13837: LD_INT 9
13839: PPUSH
13840: LD_INT 1
13842: PPUSH
13843: LD_INT 1
13845: PPUSH
13846: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
13850: LD_INT 9
13852: PPUSH
13853: LD_OWVAR 2
13857: PPUSH
13858: CALL_OW 343
// uc_side := 9 ;
13862: LD_ADDR_OWVAR 20
13866: PUSH
13867: LD_INT 9
13869: ST_TO_ADDR
// uc_nation := 2 ;
13870: LD_ADDR_OWVAR 21
13874: PUSH
13875: LD_INT 2
13877: ST_TO_ADDR
// hc_name := Dark Warrior ;
13878: LD_ADDR_OWVAR 26
13882: PUSH
13883: LD_STRING Dark Warrior
13885: ST_TO_ADDR
// hc_gallery :=  ;
13886: LD_ADDR_OWVAR 33
13890: PUSH
13891: LD_STRING 
13893: ST_TO_ADDR
// hc_noskilllimit := true ;
13894: LD_ADDR_OWVAR 76
13898: PUSH
13899: LD_INT 1
13901: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
13902: LD_ADDR_OWVAR 31
13906: PUSH
13907: LD_INT 30
13909: PUSH
13910: LD_INT 30
13912: PUSH
13913: LD_INT 30
13915: PUSH
13916: LD_INT 30
13918: PUSH
13919: EMPTY
13920: LIST
13921: LIST
13922: LIST
13923: LIST
13924: ST_TO_ADDR
// un := CreateHuman ;
13925: LD_ADDR_VAR 0 3
13929: PUSH
13930: CALL_OW 44
13934: ST_TO_ADDR
// hc_noskilllimit := false ;
13935: LD_ADDR_OWVAR 76
13939: PUSH
13940: LD_INT 0
13942: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
13943: LD_VAR 0 3
13947: PPUSH
13948: LD_INT 1
13950: PPUSH
13951: CALL_OW 51
// p := 0 ;
13955: LD_ADDR_VAR 0 2
13959: PUSH
13960: LD_INT 0
13962: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13963: LD_INT 35
13965: PPUSH
13966: CALL_OW 67
// p := p + 1 ;
13970: LD_ADDR_VAR 0 2
13974: PUSH
13975: LD_VAR 0 2
13979: PUSH
13980: LD_INT 1
13982: PLUS
13983: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
13984: LD_VAR 0 3
13988: PPUSH
13989: CALL_OW 256
13993: PUSH
13994: LD_INT 1000
13996: LESS
13997: IFFALSE 14011
// SetLives ( un , 1000 ) ;
13999: LD_VAR 0 3
14003: PPUSH
14004: LD_INT 1000
14006: PPUSH
14007: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
14011: LD_VAR 0 3
14015: PPUSH
14016: LD_INT 81
14018: PUSH
14019: LD_OWVAR 2
14023: PUSH
14024: EMPTY
14025: LIST
14026: LIST
14027: PUSH
14028: LD_INT 91
14030: PUSH
14031: LD_VAR 0 3
14035: PUSH
14036: LD_INT 30
14038: PUSH
14039: EMPTY
14040: LIST
14041: LIST
14042: LIST
14043: PUSH
14044: EMPTY
14045: LIST
14046: LIST
14047: PPUSH
14048: CALL_OW 69
14052: PPUSH
14053: LD_VAR 0 3
14057: PPUSH
14058: CALL_OW 74
14062: PPUSH
14063: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
14067: LD_VAR 0 2
14071: PUSH
14072: LD_INT 60
14074: GREATER
14075: PUSH
14076: LD_VAR 0 3
14080: PPUSH
14081: CALL_OW 301
14085: OR
14086: IFFALSE 13963
// if un then
14088: LD_VAR 0 3
14092: IFFALSE 14103
// RemoveUnit ( un ) ;
14094: LD_VAR 0 3
14098: PPUSH
14099: CALL_OW 64
// end ; end_of_file
14103: PPOPN 3
14105: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
14106: LD_INT 0
14108: PPUSH
14109: PPUSH
14110: PPUSH
14111: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
14112: LD_VAR 0 1
14116: PPUSH
14117: CALL_OW 264
14121: PUSH
14122: LD_EXP 23
14126: EQUAL
14127: IFFALSE 14199
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
14129: LD_INT 68
14131: PPUSH
14132: LD_VAR 0 1
14136: PPUSH
14137: CALL_OW 255
14141: PPUSH
14142: CALL_OW 321
14146: PUSH
14147: LD_INT 2
14149: EQUAL
14150: IFFALSE 14162
// eff := 70 else
14152: LD_ADDR_VAR 0 4
14156: PUSH
14157: LD_INT 70
14159: ST_TO_ADDR
14160: GO 14170
// eff := 30 ;
14162: LD_ADDR_VAR 0 4
14166: PUSH
14167: LD_INT 30
14169: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 250
14179: PPUSH
14180: LD_VAR 0 1
14184: PPUSH
14185: CALL_OW 251
14189: PPUSH
14190: LD_VAR 0 4
14194: PPUSH
14195: CALL_OW 495
// end ; end ;
14199: LD_VAR 0 2
14203: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
14204: LD_INT 0
14206: PPUSH
// end ;
14207: LD_VAR 0 4
14211: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
14212: LD_INT 0
14214: PPUSH
14215: PPUSH
14216: PPUSH
14217: PPUSH
14218: PPUSH
14219: PPUSH
// if cmd = 124 then
14220: LD_VAR 0 1
14224: PUSH
14225: LD_INT 124
14227: EQUAL
14228: IFFALSE 14434
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
14230: LD_ADDR_VAR 0 5
14234: PUSH
14235: LD_INT 2
14237: PUSH
14238: LD_INT 34
14240: PUSH
14241: LD_INT 53
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PUSH
14248: LD_INT 34
14250: PUSH
14251: LD_INT 14
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: PUSH
14258: EMPTY
14259: LIST
14260: LIST
14261: LIST
14262: PPUSH
14263: CALL_OW 69
14267: ST_TO_ADDR
// if not tmp then
14268: LD_VAR 0 5
14272: NOT
14273: IFFALSE 14277
// exit ;
14275: GO 14434
// for i in tmp do
14277: LD_ADDR_VAR 0 3
14281: PUSH
14282: LD_VAR 0 5
14286: PUSH
14287: FOR_IN
14288: IFFALSE 14432
// begin taskList := GetTaskList ( i ) ;
14290: LD_ADDR_VAR 0 6
14294: PUSH
14295: LD_VAR 0 3
14299: PPUSH
14300: CALL_OW 437
14304: ST_TO_ADDR
// if not taskList then
14305: LD_VAR 0 6
14309: NOT
14310: IFFALSE 14314
// continue ;
14312: GO 14287
// for j = 1 to taskList do
14314: LD_ADDR_VAR 0 4
14318: PUSH
14319: DOUBLE
14320: LD_INT 1
14322: DEC
14323: ST_TO_ADDR
14324: LD_VAR 0 6
14328: PUSH
14329: FOR_TO
14330: IFFALSE 14428
// if taskList [ j ] [ 1 ] = | then
14332: LD_VAR 0 6
14336: PUSH
14337: LD_VAR 0 4
14341: ARRAY
14342: PUSH
14343: LD_INT 1
14345: ARRAY
14346: PUSH
14347: LD_STRING |
14349: EQUAL
14350: IFFALSE 14426
// begin _taskList := Delete ( taskList , 1 ) ;
14352: LD_ADDR_VAR 0 7
14356: PUSH
14357: LD_VAR 0 6
14361: PPUSH
14362: LD_INT 1
14364: PPUSH
14365: CALL_OW 3
14369: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
14370: LD_VAR 0 3
14374: PPUSH
14375: LD_VAR 0 7
14379: PPUSH
14380: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
14384: LD_VAR 0 3
14388: PPUSH
14389: LD_VAR 0 6
14393: PUSH
14394: LD_VAR 0 4
14398: ARRAY
14399: PUSH
14400: LD_INT 2
14402: ARRAY
14403: PPUSH
14404: LD_VAR 0 6
14408: PUSH
14409: LD_VAR 0 4
14413: ARRAY
14414: PUSH
14415: LD_INT 3
14417: ARRAY
14418: PPUSH
14419: LD_INT 8
14421: PPUSH
14422: CALL 14439 0 4
// end ;
14426: GO 14329
14428: POP
14429: POP
// end ;
14430: GO 14287
14432: POP
14433: POP
// end ; end ;
14434: LD_VAR 0 2
14438: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
14439: LD_INT 0
14441: PPUSH
14442: PPUSH
14443: PPUSH
14444: PPUSH
14445: PPUSH
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
14450: LD_VAR 0 1
14454: NOT
14455: PUSH
14456: LD_VAR 0 2
14460: PPUSH
14461: LD_VAR 0 3
14465: PPUSH
14466: CALL_OW 488
14470: NOT
14471: OR
14472: PUSH
14473: LD_VAR 0 4
14477: NOT
14478: OR
14479: IFFALSE 14483
// exit ;
14481: GO 14823
// list := [ ] ;
14483: LD_ADDR_VAR 0 13
14487: PUSH
14488: EMPTY
14489: ST_TO_ADDR
// if x - r < 0 then
14490: LD_VAR 0 2
14494: PUSH
14495: LD_VAR 0 4
14499: MINUS
14500: PUSH
14501: LD_INT 0
14503: LESS
14504: IFFALSE 14516
// min_x := 0 else
14506: LD_ADDR_VAR 0 7
14510: PUSH
14511: LD_INT 0
14513: ST_TO_ADDR
14514: GO 14532
// min_x := x - r ;
14516: LD_ADDR_VAR 0 7
14520: PUSH
14521: LD_VAR 0 2
14525: PUSH
14526: LD_VAR 0 4
14530: MINUS
14531: ST_TO_ADDR
// if y - r < 0 then
14532: LD_VAR 0 3
14536: PUSH
14537: LD_VAR 0 4
14541: MINUS
14542: PUSH
14543: LD_INT 0
14545: LESS
14546: IFFALSE 14558
// min_y := 0 else
14548: LD_ADDR_VAR 0 8
14552: PUSH
14553: LD_INT 0
14555: ST_TO_ADDR
14556: GO 14574
// min_y := y - r ;
14558: LD_ADDR_VAR 0 8
14562: PUSH
14563: LD_VAR 0 3
14567: PUSH
14568: LD_VAR 0 4
14572: MINUS
14573: ST_TO_ADDR
// max_x := x + r ;
14574: LD_ADDR_VAR 0 9
14578: PUSH
14579: LD_VAR 0 2
14583: PUSH
14584: LD_VAR 0 4
14588: PLUS
14589: ST_TO_ADDR
// max_y := y + r ;
14590: LD_ADDR_VAR 0 10
14594: PUSH
14595: LD_VAR 0 3
14599: PUSH
14600: LD_VAR 0 4
14604: PLUS
14605: ST_TO_ADDR
// for _x = min_x to max_x do
14606: LD_ADDR_VAR 0 11
14610: PUSH
14611: DOUBLE
14612: LD_VAR 0 7
14616: DEC
14617: ST_TO_ADDR
14618: LD_VAR 0 9
14622: PUSH
14623: FOR_TO
14624: IFFALSE 14741
// for _y = min_y to max_y do
14626: LD_ADDR_VAR 0 12
14630: PUSH
14631: DOUBLE
14632: LD_VAR 0 8
14636: DEC
14637: ST_TO_ADDR
14638: LD_VAR 0 10
14642: PUSH
14643: FOR_TO
14644: IFFALSE 14737
// begin if not ValidHex ( _x , _y ) then
14646: LD_VAR 0 11
14650: PPUSH
14651: LD_VAR 0 12
14655: PPUSH
14656: CALL_OW 488
14660: NOT
14661: IFFALSE 14665
// continue ;
14663: GO 14643
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
14665: LD_VAR 0 11
14669: PPUSH
14670: LD_VAR 0 12
14674: PPUSH
14675: CALL_OW 351
14679: PUSH
14680: LD_VAR 0 11
14684: PPUSH
14685: LD_VAR 0 12
14689: PPUSH
14690: CALL_OW 554
14694: AND
14695: IFFALSE 14735
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
14697: LD_ADDR_VAR 0 13
14701: PUSH
14702: LD_VAR 0 13
14706: PPUSH
14707: LD_VAR 0 13
14711: PUSH
14712: LD_INT 1
14714: PLUS
14715: PPUSH
14716: LD_VAR 0 11
14720: PUSH
14721: LD_VAR 0 12
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: PPUSH
14730: CALL_OW 2
14734: ST_TO_ADDR
// end ;
14735: GO 14643
14737: POP
14738: POP
14739: GO 14623
14741: POP
14742: POP
// if not list then
14743: LD_VAR 0 13
14747: NOT
14748: IFFALSE 14752
// exit ;
14750: GO 14823
// for i in list do
14752: LD_ADDR_VAR 0 6
14756: PUSH
14757: LD_VAR 0 13
14761: PUSH
14762: FOR_IN
14763: IFFALSE 14821
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
14765: LD_VAR 0 1
14769: PPUSH
14770: LD_STRING M
14772: PUSH
14773: LD_VAR 0 6
14777: PUSH
14778: LD_INT 1
14780: ARRAY
14781: PUSH
14782: LD_VAR 0 6
14786: PUSH
14787: LD_INT 2
14789: ARRAY
14790: PUSH
14791: LD_INT 0
14793: PUSH
14794: LD_INT 0
14796: PUSH
14797: LD_INT 0
14799: PUSH
14800: LD_INT 0
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: PUSH
14812: EMPTY
14813: LIST
14814: PPUSH
14815: CALL_OW 447
14819: GO 14762
14821: POP
14822: POP
// end ;
14823: LD_VAR 0 5
14827: RET
