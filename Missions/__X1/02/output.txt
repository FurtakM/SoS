// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 581 0 0
// PrepareAmericans ;
  23: CALL 827 0 0
// PrepareArabian ;
  27: CALL 9829 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 190 0 0
// Action ;
  41: CALL 4423 0 0
// end ;
  45: END
// export debug , prefix , missionStart , aviradzeSpotted , deltaSpotted , sciSpotted , aviradzeQuestDone , sciCounterKill , usAlert , usActiveDefend , timeUntilFarmer , attackDeltaAllowed , trickyMove , usPatrol , trap ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := 1 ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 1
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// aviradzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 6
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 8
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// aviradzeQuestDone := false ;
  97: LD_ADDR_EXP 7
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// attackDeltaAllowed := false ;
 105: LD_ADDR_EXP 12
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// usAlert := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// usActiveDefend := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// usPatrol := [ ] ;
 129: LD_ADDR_EXP 14
 133: PUSH
 134: EMPTY
 135: ST_TO_ADDR
// timeUntilFarmer := [ 40 40$00 , 30 30$00 , 20 20$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 11
 140: PUSH
 141: LD_INT 84000
 143: PUSH
 144: LD_INT 63000
 146: PUSH
 147: LD_INT 42000
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// trickyMove := false ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// prefix := 01_ ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 01_
 176: ST_TO_ADDR
// trap := 0 ;
 177: LD_ADDR_EXP 15
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// end ;
 185: LD_VAR 0 1
 189: RET
// function DebugMode ; begin
 190: LD_INT 0
 192: PPUSH
// FogOff ( 1 ) ;
 193: LD_INT 1
 195: PPUSH
 196: CALL_OW 344
// Difficulty := 2 ;
 200: LD_ADDR_OWVAR 67
 204: PUSH
 205: LD_INT 2
 207: ST_TO_ADDR
// end ; end_of_file
 208: LD_VAR 0 1
 212: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 213: LD_INT 0
 215: PPUSH
 216: PPUSH
// if exist_mode then
 217: LD_VAR 0 2
 221: IFFALSE 246
// unit := CreateCharacter ( prefix & ident ) else
 223: LD_ADDR_VAR 0 5
 227: PUSH
 228: LD_VAR 0 3
 232: PUSH
 233: LD_VAR 0 1
 237: STR
 238: PPUSH
 239: CALL_OW 34
 243: ST_TO_ADDR
 244: GO 261
// unit := NewCharacter ( ident ) ;
 246: LD_ADDR_VAR 0 5
 250: PUSH
 251: LD_VAR 0 1
 255: PPUSH
 256: CALL_OW 25
 260: ST_TO_ADDR
// result := unit ;
 261: LD_ADDR_VAR 0 4
 265: PUSH
 266: LD_VAR 0 5
 270: ST_TO_ADDR
// end ;
 271: LD_VAR 0 4
 275: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 276: LD_INT 0
 278: PPUSH
// uc_side := side ;
 279: LD_ADDR_OWVAR 20
 283: PUSH
 284: LD_VAR 0 1
 288: ST_TO_ADDR
// uc_nation := nation ;
 289: LD_ADDR_OWVAR 21
 293: PUSH
 294: LD_VAR 0 2
 298: ST_TO_ADDR
// vc_chassis := chassis ;
 299: LD_ADDR_OWVAR 37
 303: PUSH
 304: LD_VAR 0 3
 308: ST_TO_ADDR
// vc_engine := engine ;
 309: LD_ADDR_OWVAR 39
 313: PUSH
 314: LD_VAR 0 4
 318: ST_TO_ADDR
// vc_control := control ;
 319: LD_ADDR_OWVAR 38
 323: PUSH
 324: LD_VAR 0 5
 328: ST_TO_ADDR
// vc_weapon := weapon ;
 329: LD_ADDR_OWVAR 40
 333: PUSH
 334: LD_VAR 0 6
 338: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 339: LD_ADDR_OWVAR 41
 343: PUSH
 344: LD_VAR 0 7
 348: ST_TO_ADDR
// result := CreateVehicle ;
 349: LD_ADDR_VAR 0 8
 353: PUSH
 354: CALL_OW 45
 358: ST_TO_ADDR
// end ;
 359: LD_VAR 0 8
 363: RET
// export function SayX ( units , ident ) ; var i ; begin
 364: LD_INT 0
 366: PPUSH
 367: PPUSH
// result := false ;
 368: LD_ADDR_VAR 0 3
 372: PUSH
 373: LD_INT 0
 375: ST_TO_ADDR
// if not units then
 376: LD_VAR 0 1
 380: NOT
 381: IFFALSE 385
// exit ;
 383: GO 439
// for i in units do
 385: LD_ADDR_VAR 0 4
 389: PUSH
 390: LD_VAR 0 1
 394: PUSH
 395: FOR_IN
 396: IFFALSE 437
// if IsOk ( i ) then
 398: LD_VAR 0 4
 402: PPUSH
 403: CALL_OW 302
 407: IFFALSE 435
// begin Say ( i , ident ) ;
 409: LD_VAR 0 4
 413: PPUSH
 414: LD_VAR 0 2
 418: PPUSH
 419: CALL_OW 88
// result := i ;
 423: LD_ADDR_VAR 0 3
 427: PUSH
 428: LD_VAR 0 4
 432: ST_TO_ADDR
// break ;
 433: GO 437
// end ;
 435: GO 395
 437: POP
 438: POP
// end ;
 439: LD_VAR 0 3
 443: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 444: LD_INT 0
 446: PPUSH
 447: PPUSH
// InitUc ;
 448: CALL_OW 18
// InitHc ;
 452: CALL_OW 19
// uc_side := 0 ;
 456: LD_ADDR_OWVAR 20
 460: PUSH
 461: LD_INT 0
 463: ST_TO_ADDR
// uc_nation := 0 ;
 464: LD_ADDR_OWVAR 21
 468: PUSH
 469: LD_INT 0
 471: ST_TO_ADDR
// for i = 1 to amount do
 472: LD_ADDR_VAR 0 4
 476: PUSH
 477: DOUBLE
 478: LD_INT 1
 480: DEC
 481: ST_TO_ADDR
 482: LD_VAR 0 2
 486: PUSH
 487: FOR_TO
 488: IFFALSE 570
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 490: LD_ADDR_OWVAR 29
 494: PUSH
 495: LD_INT 9
 497: PPUSH
 498: LD_INT 12
 500: PPUSH
 501: CALL_OW 12
 505: PUSH
 506: LD_INT 9
 508: PPUSH
 509: LD_INT 12
 511: PPUSH
 512: CALL_OW 12
 516: PUSH
 517: EMPTY
 518: LIST
 519: LIST
 520: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 521: LD_ADDR_OWVAR 35
 525: PUSH
 526: LD_INT 1
 528: NEG
 529: PPUSH
 530: LD_INT 1
 532: PPUSH
 533: CALL_OW 12
 537: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 538: LD_INT 0
 540: PPUSH
 541: LD_INT 12
 543: PPUSH
 544: LD_INT 1
 546: PPUSH
 547: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 551: CALL_OW 44
 555: PPUSH
 556: LD_VAR 0 1
 560: PPUSH
 561: LD_INT 0
 563: PPUSH
 564: CALL_OW 49
// end ;
 568: GO 487
 570: POP
 571: POP
// InitHc ;
 572: CALL_OW 19
// end ;
 576: LD_VAR 0 3
 580: RET
// export function PrepareNature ; var i ; begin
 581: LD_INT 0
 583: PPUSH
 584: PPUSH
// SpawnApeman ( forest , 9 ) ;
 585: LD_INT 1
 587: PPUSH
 588: LD_INT 9
 590: PPUSH
 591: CALL 444 0 2
// for i := 1 to 4 do
 595: LD_ADDR_VAR 0 2
 599: PUSH
 600: DOUBLE
 601: LD_INT 1
 603: DEC
 604: ST_TO_ADDR
 605: LD_INT 4
 607: PUSH
 608: FOR_TO
 609: IFFALSE 644
// begin hc_class := 21 ;
 611: LD_ADDR_OWVAR 28
 615: PUSH
 616: LD_INT 21
 618: ST_TO_ADDR
// hc_gallery :=  ;
 619: LD_ADDR_OWVAR 33
 623: PUSH
 624: LD_STRING 
 626: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 627: CALL_OW 44
 631: PPUSH
 632: LD_INT 1
 634: PPUSH
 635: LD_INT 0
 637: PPUSH
 638: CALL_OW 49
// end ;
 642: GO 608
 644: POP
 645: POP
// for i := 1 to 2 do
 646: LD_ADDR_VAR 0 2
 650: PUSH
 651: DOUBLE
 652: LD_INT 1
 654: DEC
 655: ST_TO_ADDR
 656: LD_INT 2
 658: PUSH
 659: FOR_TO
 660: IFFALSE 695
// begin hc_class := 18 ;
 662: LD_ADDR_OWVAR 28
 666: PUSH
 667: LD_INT 18
 669: ST_TO_ADDR
// hc_gallery :=  ;
 670: LD_ADDR_OWVAR 33
 674: PUSH
 675: LD_STRING 
 677: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 678: CALL_OW 44
 682: PPUSH
 683: LD_INT 1
 685: PPUSH
 686: LD_INT 0
 688: PPUSH
 689: CALL_OW 49
// end ;
 693: GO 659
 695: POP
 696: POP
// for i := 1 to 3 do
 697: LD_ADDR_VAR 0 2
 701: PUSH
 702: DOUBLE
 703: LD_INT 1
 705: DEC
 706: ST_TO_ADDR
 707: LD_INT 3
 709: PUSH
 710: FOR_TO
 711: IFFALSE 746
// begin hc_class := 13 ;
 713: LD_ADDR_OWVAR 28
 717: PUSH
 718: LD_INT 13
 720: ST_TO_ADDR
// hc_gallery :=  ;
 721: LD_ADDR_OWVAR 33
 725: PUSH
 726: LD_STRING 
 728: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 729: CALL_OW 44
 733: PPUSH
 734: LD_INT 1
 736: PPUSH
 737: LD_INT 0
 739: PPUSH
 740: CALL_OW 49
// end ;
 744: GO 710
 746: POP
 747: POP
// end ;
 748: LD_VAR 0 1
 752: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 753: LD_INT 0
 755: PPUSH
 756: PPUSH
 757: PPUSH
// if not observer or not unit then
 758: LD_VAR 0 1
 762: NOT
 763: PUSH
 764: LD_VAR 0 2
 768: NOT
 769: OR
 770: IFFALSE 774
// exit ;
 772: GO 822
// if not See ( GetSide ( observer ) , unit ) then
 774: LD_VAR 0 1
 778: PPUSH
 779: CALL_OW 255
 783: PPUSH
 784: LD_VAR 0 2
 788: PPUSH
 789: CALL_OW 292
 793: NOT
 794: IFFALSE 798
// exit ;
 796: GO 822
// result := GetDistUnits ( observer , unit ) < 12 ;
 798: LD_ADDR_VAR 0 3
 802: PUSH
 803: LD_VAR 0 1
 807: PPUSH
 808: LD_VAR 0 2
 812: PPUSH
 813: CALL_OW 296
 817: PUSH
 818: LD_INT 12
 820: LESS
 821: ST_TO_ADDR
// end ; end_of_file
 822: LD_VAR 0 3
 826: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp , arm ; begin
 827: LD_INT 0
 829: PPUSH
 830: PPUSH
 831: PPUSH
 832: PPUSH
 833: PPUSH
 834: PPUSH
// usForces := [ ] ;
 835: LD_ADDR_EXP 18
 839: PUSH
 840: EMPTY
 841: ST_TO_ADDR
// usSci := [ ] ;
 842: LD_ADDR_EXP 19
 846: PUSH
 847: EMPTY
 848: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 849: LD_INT 1
 851: PPUSH
 852: LD_STRING Delta
 854: PPUSH
 855: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 859: LD_INT 1
 861: PPUSH
 862: CALL_OW 274
 866: PPUSH
 867: LD_INT 1
 869: PPUSH
 870: LD_INT 400
 872: PPUSH
 873: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 877: LD_INT 1
 879: PPUSH
 880: CALL_OW 274
 884: PPUSH
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 80
 890: PPUSH
 891: CALL_OW 277
// uc_side := 1 ;
 895: LD_ADDR_OWVAR 20
 899: PUSH
 900: LD_INT 1
 902: ST_TO_ADDR
// uc_nation := 1 ;
 903: LD_ADDR_OWVAR 21
 907: PUSH
 908: LD_INT 1
 910: ST_TO_ADDR
// InitHc ;
 911: CALL_OW 19
// hc_importance := 0 ;
 915: LD_ADDR_OWVAR 32
 919: PUSH
 920: LD_INT 0
 922: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 923: LD_ADDR_EXP 17
 927: PUSH
 928: LD_STRING Lynch
 930: PPUSH
 931: LD_INT 0
 933: PPUSH
 934: LD_STRING 
 936: PPUSH
 937: CALL 213 0 3
 941: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 942: LD_ADDR_EXP 16
 946: PUSH
 947: LD_STRING Gladstone
 949: PPUSH
 950: LD_INT 0
 952: PPUSH
 953: LD_STRING 
 955: PPUSH
 956: CALL 213 0 3
 960: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 961: LD_EXP 17
 965: PPUSH
 966: LD_INT 1
 968: PPUSH
 969: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 3
 980: PPUSH
 981: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
 985: LD_ADDR_VAR 0 2
 989: PUSH
 990: DOUBLE
 991: LD_INT 1
 993: DEC
 994: ST_TO_ADDR
 995: LD_INT 1
 997: PUSH
 998: LD_INT 2
1000: PUSH
1001: LD_INT 2
1003: PUSH
1004: EMPTY
1005: LIST
1006: LIST
1007: LIST
1008: PUSH
1009: LD_OWVAR 67
1013: ARRAY
1014: PUSH
1015: FOR_TO
1016: IFFALSE 1062
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1018: LD_INT 0
1020: PPUSH
1021: LD_INT 2
1023: PPUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 2
1029: PUSH
1030: LD_INT 2
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: PUSH
1038: LD_OWVAR 67
1042: ARRAY
1043: PPUSH
1044: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
1048: CALL_OW 44
1052: PPUSH
1053: LD_INT 1
1055: PPUSH
1056: CALL_OW 52
// end ;
1060: GO 1015
1062: POP
1063: POP
// for i := 1 to 2 + Difficulty do
1064: LD_ADDR_VAR 0 2
1068: PUSH
1069: DOUBLE
1070: LD_INT 1
1072: DEC
1073: ST_TO_ADDR
1074: LD_INT 2
1076: PUSH
1077: LD_OWVAR 67
1081: PLUS
1082: PUSH
1083: FOR_TO
1084: IFFALSE 1169
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1086: LD_INT 0
1088: PPUSH
1089: LD_INT 4
1091: PPUSH
1092: LD_INT 1
1094: PUSH
1095: LD_INT 2
1097: PUSH
1098: LD_INT 2
1100: PUSH
1101: EMPTY
1102: LIST
1103: LIST
1104: LIST
1105: PUSH
1106: LD_OWVAR 67
1110: ARRAY
1111: PPUSH
1112: CALL_OW 380
// un := CreateHuman ;
1116: LD_ADDR_VAR 0 3
1120: PUSH
1121: CALL_OW 44
1125: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
1126: LD_VAR 0 3
1130: PPUSH
1131: LD_INT 3
1133: PPUSH
1134: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
1138: LD_ADDR_EXP 19
1142: PUSH
1143: LD_EXP 19
1147: PPUSH
1148: LD_EXP 19
1152: PUSH
1153: LD_INT 1
1155: PLUS
1156: PPUSH
1157: LD_VAR 0 3
1161: PPUSH
1162: CALL_OW 1
1166: ST_TO_ADDR
// end ;
1167: GO 1083
1169: POP
1170: POP
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
1171: LD_ADDR_VAR 0 6
1175: PUSH
1176: LD_INT 22
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 30
1188: PUSH
1189: LD_INT 4
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: PUSH
1196: EMPTY
1197: LIST
1198: LIST
1199: PPUSH
1200: CALL_OW 69
1204: ST_TO_ADDR
// for i := 1 to 3 + Difficulty do
1205: LD_ADDR_VAR 0 2
1209: PUSH
1210: DOUBLE
1211: LD_INT 1
1213: DEC
1214: ST_TO_ADDR
1215: LD_INT 3
1217: PUSH
1218: LD_OWVAR 67
1222: PLUS
1223: PUSH
1224: FOR_TO
1225: IFFALSE 1303
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1227: LD_INT 0
1229: PPUSH
1230: LD_INT 1
1232: PPUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 2
1238: PUSH
1239: LD_INT 3
1241: PUSH
1242: EMPTY
1243: LIST
1244: LIST
1245: LIST
1246: PUSH
1247: LD_OWVAR 67
1251: ARRAY
1252: PPUSH
1253: CALL_OW 380
// un := CreateHuman ;
1257: LD_ADDR_VAR 0 3
1261: PUSH
1262: CALL_OW 44
1266: ST_TO_ADDR
// usForces := usForces ^ un ;
1267: LD_ADDR_EXP 18
1271: PUSH
1272: LD_EXP 18
1276: PUSH
1277: LD_VAR 0 3
1281: ADD
1282: ST_TO_ADDR
// PlaceHumanInUnit ( un , arm [ 1 ] ) ;
1283: LD_VAR 0 3
1287: PPUSH
1288: LD_VAR 0 6
1292: PUSH
1293: LD_INT 1
1295: ARRAY
1296: PPUSH
1297: CALL_OW 52
// end ;
1301: GO 1224
1303: POP
1304: POP
// PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1305: LD_INT 1
1307: PPUSH
1308: LD_INT 1
1310: PPUSH
1311: LD_INT 1
1313: PPUSH
1314: LD_INT 2
1316: PPUSH
1317: LD_INT 1
1319: PPUSH
1320: LD_INT 2
1322: PPUSH
1323: LD_INT 100
1325: PPUSH
1326: CALL 276 0 7
// veh := CreateVehicle ;
1330: LD_ADDR_VAR 0 4
1334: PUSH
1335: CALL_OW 45
1339: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1340: LD_VAR 0 4
1344: PPUSH
1345: LD_INT 2
1347: PPUSH
1348: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 24 , false ) ;
1352: LD_VAR 0 4
1356: PPUSH
1357: LD_INT 43
1359: PPUSH
1360: LD_INT 24
1362: PPUSH
1363: LD_INT 0
1365: PPUSH
1366: CALL_OW 48
// end ;
1370: LD_VAR 0 1
1374: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
1382: PPUSH
// if not usSci then
1383: LD_EXP 19
1387: NOT
1388: IFFALSE 1392
// exit ;
1390: GO 1566
// xy := AreaToList ( tameArea , 0 ) ;
1392: LD_ADDR_VAR 0 6
1396: PUSH
1397: LD_INT 5
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 517
1407: ST_TO_ADDR
// for i in usSci do
1408: LD_ADDR_VAR 0 2
1412: PUSH
1413: LD_EXP 19
1417: PUSH
1418: FOR_IN
1419: IFFALSE 1564
// begin k := rand ( 1 , xy [ 1 ] ) ;
1421: LD_ADDR_VAR 0 4
1425: PUSH
1426: LD_INT 1
1428: PPUSH
1429: LD_VAR 0 6
1433: PUSH
1434: LD_INT 1
1436: ARRAY
1437: PPUSH
1438: CALL_OW 12
1442: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1443: LD_VAR 0 2
1447: PPUSH
1448: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1452: LD_VAR 0 2
1456: PPUSH
1457: LD_VAR 0 6
1461: PUSH
1462: LD_INT 1
1464: ARRAY
1465: PUSH
1466: LD_VAR 0 4
1470: ARRAY
1471: PPUSH
1472: LD_VAR 0 6
1476: PUSH
1477: LD_INT 2
1479: ARRAY
1480: PUSH
1481: LD_VAR 0 4
1485: ARRAY
1486: PPUSH
1487: CALL_OW 171
// for j := 1 to 2 do
1491: LD_ADDR_VAR 0 3
1495: PUSH
1496: DOUBLE
1497: LD_INT 1
1499: DEC
1500: ST_TO_ADDR
1501: LD_INT 2
1503: PUSH
1504: FOR_TO
1505: IFFALSE 1560
// begin tmp := Delete ( xy [ j ] , k ) ;
1507: LD_ADDR_VAR 0 5
1511: PUSH
1512: LD_VAR 0 6
1516: PUSH
1517: LD_VAR 0 3
1521: ARRAY
1522: PPUSH
1523: LD_VAR 0 4
1527: PPUSH
1528: CALL_OW 3
1532: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1533: LD_ADDR_VAR 0 6
1537: PUSH
1538: LD_VAR 0 6
1542: PPUSH
1543: LD_VAR 0 3
1547: PPUSH
1548: LD_VAR 0 5
1552: PPUSH
1553: CALL_OW 1
1557: ST_TO_ADDR
// end ;
1558: GO 1504
1560: POP
1561: POP
// end ;
1562: GO 1418
1564: POP
1565: POP
// end ;
1566: LD_VAR 0 1
1570: RET
// every 0 0$5 + 0 0$10 trigger usSci and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1571: LD_EXP 19
1575: PUSH
1576: LD_INT 22
1578: PUSH
1579: LD_INT 0
1581: PUSH
1582: EMPTY
1583: LIST
1584: LIST
1585: PUSH
1586: LD_INT 25
1588: PUSH
1589: LD_INT 12
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PPUSH
1600: CALL_OW 69
1604: AND
1605: IFFALSE 2094
1607: GO 1609
1609: DISABLE
1610: LD_INT 0
1612: PPUSH
1613: PPUSH
1614: PPUSH
1615: PPUSH
1616: PPUSH
// begin enable ;
1617: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1618: LD_EXP 19
1622: PPUSH
1623: LD_INT 2
1625: PUSH
1626: LD_INT 60
1628: PUSH
1629: EMPTY
1630: LIST
1631: PUSH
1632: LD_INT 54
1634: PUSH
1635: EMPTY
1636: LIST
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PPUSH
1643: CALL_OW 72
1647: IFFALSE 1651
// exit ;
1649: GO 2094
// for i in usSci do
1651: LD_ADDR_VAR 0 1
1655: PUSH
1656: LD_EXP 19
1660: PUSH
1661: FOR_IN
1662: IFFALSE 2092
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1664: LD_VAR 0 1
1668: PPUSH
1669: CALL_OW 314
1673: NOT
1674: PUSH
1675: LD_VAR 0 1
1679: PPUSH
1680: CALL_OW 256
1684: PUSH
1685: LD_INT 1000
1687: EQUAL
1688: AND
1689: IFFALSE 1896
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1691: LD_ADDR_VAR 0 5
1695: PUSH
1696: LD_INT 22
1698: PUSH
1699: LD_INT 0
1701: PUSH
1702: EMPTY
1703: LIST
1704: LIST
1705: PUSH
1706: LD_INT 25
1708: PUSH
1709: LD_INT 12
1711: PUSH
1712: EMPTY
1713: LIST
1714: LIST
1715: PUSH
1716: EMPTY
1717: LIST
1718: LIST
1719: PPUSH
1720: CALL_OW 69
1724: PPUSH
1725: LD_VAR 0 1
1729: PPUSH
1730: CALL_OW 74
1734: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1735: LD_VAR 0 1
1739: PPUSH
1740: LD_VAR 0 5
1744: PPUSH
1745: CALL_OW 296
1749: PUSH
1750: LD_INT 10
1752: LESS
1753: IFFALSE 1786
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1755: LD_VAR 0 1
1759: PPUSH
1760: LD_VAR 0 5
1764: PPUSH
1765: CALL_OW 250
1769: PPUSH
1770: LD_VAR 0 5
1774: PPUSH
1775: CALL_OW 251
1779: PPUSH
1780: CALL_OW 131
1784: GO 1896
// begin d := rand ( 0 , 5 ) ;
1786: LD_ADDR_VAR 0 4
1790: PUSH
1791: LD_INT 0
1793: PPUSH
1794: LD_INT 5
1796: PPUSH
1797: CALL_OW 12
1801: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1802: LD_ADDR_VAR 0 2
1806: PUSH
1807: LD_VAR 0 1
1811: PPUSH
1812: CALL_OW 250
1816: PPUSH
1817: LD_VAR 0 4
1821: PPUSH
1822: LD_INT 3
1824: PPUSH
1825: CALL_OW 272
1829: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
1830: LD_ADDR_VAR 0 3
1834: PUSH
1835: LD_VAR 0 1
1839: PPUSH
1840: CALL_OW 251
1844: PPUSH
1845: LD_VAR 0 4
1849: PPUSH
1850: LD_INT 3
1852: PPUSH
1853: CALL_OW 273
1857: ST_TO_ADDR
// if not ValidHex ( x , y ) then
1858: LD_VAR 0 2
1862: PPUSH
1863: LD_VAR 0 3
1867: PPUSH
1868: CALL_OW 488
1872: NOT
1873: IFFALSE 1877
// continue ;
1875: GO 1661
// ComMoveXY ( i , x , y ) ;
1877: LD_VAR 0 1
1881: PPUSH
1882: LD_VAR 0 2
1886: PPUSH
1887: LD_VAR 0 3
1891: PPUSH
1892: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
1896: LD_VAR 0 1
1900: PPUSH
1901: CALL_OW 256
1905: PUSH
1906: LD_INT 900
1908: LESS
1909: PUSH
1910: LD_VAR 0 1
1914: PPUSH
1915: LD_INT 37
1917: PPUSH
1918: LD_INT 23
1920: PPUSH
1921: CALL_OW 297
1925: PUSH
1926: LD_INT 10
1928: GREATER
1929: AND
1930: IFFALSE 1980
// begin if IsOk ( Gladstone ) and IsInUnit ( Gladstone ) then
1932: LD_EXP 16
1936: PPUSH
1937: CALL_OW 302
1941: PUSH
1942: LD_EXP 16
1946: PPUSH
1947: CALL_OW 310
1951: AND
1952: IFFALSE 1963
// ComExitBuilding ( Gladstone ) ;
1954: LD_EXP 16
1958: PPUSH
1959: CALL_OW 122
// ComMoveXY ( i , 37 , 23 ) ;
1963: LD_VAR 0 1
1967: PPUSH
1968: LD_INT 37
1970: PPUSH
1971: LD_INT 23
1973: PPUSH
1974: CALL_OW 111
// end else
1978: GO 2090
// if GetLives ( i ) = 1000 then
1980: LD_VAR 0 1
1984: PPUSH
1985: CALL_OW 256
1989: PUSH
1990: LD_INT 1000
1992: EQUAL
1993: IFFALSE 2090
// begin if IsOk ( Gladstone ) then
1995: LD_EXP 16
1999: PPUSH
2000: CALL_OW 302
2004: IFFALSE 2018
// ComEnterUnit ( Gladstone , usLab ) ;
2006: LD_EXP 16
2010: PPUSH
2011: LD_INT 3
2013: PPUSH
2014: CALL_OW 120
// if SideShoot ( i ) = 2 then
2018: LD_VAR 0 1
2022: PPUSH
2023: CALL_OW 503
2027: PUSH
2028: LD_INT 2
2030: EQUAL
2031: IFFALSE 2078
// begin if not usAlert then
2033: LD_EXP 9
2037: NOT
2038: IFFALSE 2048
// usAlert := true ;
2040: LD_ADDR_EXP 9
2044: PUSH
2045: LD_INT 1
2047: ST_TO_ADDR
// AddComEnterUnit ( i , usLab ) ;
2048: LD_VAR 0 1
2052: PPUSH
2053: LD_INT 3
2055: PPUSH
2056: CALL_OW 180
// usSci := usSci diff i ;
2060: LD_ADDR_EXP 19
2064: PUSH
2065: LD_EXP 19
2069: PUSH
2070: LD_VAR 0 1
2074: DIFF
2075: ST_TO_ADDR
// end else
2076: GO 2090
// ComMoveToArea ( i , tameArea ) ;
2078: LD_VAR 0 1
2082: PPUSH
2083: LD_INT 5
2085: PPUSH
2086: CALL_OW 113
// end ; end ;
2090: GO 1661
2092: POP
2093: POP
// end ;
2094: PPOPN 5
2096: END
// every 0 0$1 trigger not usAlert and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 999 ] ] ] ) or FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) ) do
2097: LD_EXP 9
2101: NOT
2102: PUSH
2103: LD_INT 22
2105: PUSH
2106: LD_INT 1
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 21
2115: PUSH
2116: LD_INT 3
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PUSH
2123: LD_INT 3
2125: PUSH
2126: LD_INT 57
2128: PUSH
2129: EMPTY
2130: LIST
2131: PUSH
2132: EMPTY
2133: LIST
2134: LIST
2135: PUSH
2136: LD_INT 3
2138: PUSH
2139: LD_INT 24
2141: PUSH
2142: LD_INT 999
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: EMPTY
2154: LIST
2155: LIST
2156: LIST
2157: LIST
2158: PPUSH
2159: CALL_OW 69
2163: PUSH
2164: LD_INT 7
2166: PPUSH
2167: LD_INT 22
2169: PUSH
2170: LD_INT 2
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: PPUSH
2177: CALL_OW 70
2181: OR
2182: AND
2183: IFFALSE 2196
2185: GO 2187
2187: DISABLE
// usAlert := true ;
2188: LD_ADDR_EXP 9
2192: PUSH
2193: LD_INT 1
2195: ST_TO_ADDR
2196: END
// every 0 0$1 trigger usAlert do var i , b , arm ;
2197: LD_EXP 9
2201: IFFALSE 2548
2203: GO 2205
2205: DISABLE
2206: LD_INT 0
2208: PPUSH
2209: PPUSH
2210: PPUSH
// begin usActiveDefend := true ;
2211: LD_ADDR_EXP 10
2215: PUSH
2216: LD_INT 1
2218: ST_TO_ADDR
// if not usForces then
2219: LD_EXP 18
2223: NOT
2224: IFFALSE 2228
// exit ;
2226: GO 2548
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
2228: LD_ADDR_VAR 0 3
2232: PUSH
2233: LD_INT 22
2235: PUSH
2236: LD_INT 1
2238: PUSH
2239: EMPTY
2240: LIST
2241: LIST
2242: PUSH
2243: LD_INT 30
2245: PUSH
2246: LD_INT 4
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: PUSH
2253: EMPTY
2254: LIST
2255: LIST
2256: PPUSH
2257: CALL_OW 69
2261: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
2262: LD_ADDR_VAR 0 2
2266: PUSH
2267: LD_INT 22
2269: PUSH
2270: LD_INT 1
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: PUSH
2277: LD_INT 30
2279: PUSH
2280: LD_INT 31
2282: PUSH
2283: EMPTY
2284: LIST
2285: LIST
2286: PUSH
2287: EMPTY
2288: LIST
2289: LIST
2290: PPUSH
2291: CALL_OW 69
2295: ST_TO_ADDR
// ComExitBuilding ( Lynch ) ;
2296: LD_EXP 17
2300: PPUSH
2301: CALL_OW 122
// AddComEnterUnit ( Lynch , arm [ 1 ] ) ;
2305: LD_EXP 17
2309: PPUSH
2310: LD_VAR 0 3
2314: PUSH
2315: LD_INT 1
2317: ARRAY
2318: PPUSH
2319: CALL_OW 180
// if IsOk ( Gladstone ) then
2323: LD_EXP 16
2327: PPUSH
2328: CALL_OW 302
2332: IFFALSE 2373
// begin ComExitBuilding ( Gladstone ) ;
2334: LD_EXP 16
2338: PPUSH
2339: CALL_OW 122
// AddComEnterUnit ( Gladstone , arm [ 1 ] ) ;
2343: LD_EXP 16
2347: PPUSH
2348: LD_VAR 0 3
2352: PUSH
2353: LD_INT 1
2355: ARRAY
2356: PPUSH
2357: CALL_OW 180
// AddComChangeProfession ( Gladstone , class_soldier ) ;
2361: LD_EXP 16
2365: PPUSH
2366: LD_INT 1
2368: PPUSH
2369: CALL_OW 183
// end ; ComExitBuilding ( usForces [ 1 ] ) ;
2373: LD_EXP 18
2377: PUSH
2378: LD_INT 1
2380: ARRAY
2381: PPUSH
2382: CALL_OW 122
// AddComEnterUnit ( usForces [ 1 ] , b [ 1 ] ) ;
2386: LD_EXP 18
2390: PUSH
2391: LD_INT 1
2393: ARRAY
2394: PPUSH
2395: LD_VAR 0 2
2399: PUSH
2400: LD_INT 1
2402: ARRAY
2403: PPUSH
2404: CALL_OW 180
// ComExitBuilding ( usForces [ 2 ] ) ;
2408: LD_EXP 18
2412: PUSH
2413: LD_INT 2
2415: ARRAY
2416: PPUSH
2417: CALL_OW 122
// AddComEnterUnit ( usForces [ 2 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
2421: LD_EXP 18
2425: PUSH
2426: LD_INT 2
2428: ARRAY
2429: PPUSH
2430: LD_INT 22
2432: PUSH
2433: LD_INT 1
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 30
2442: PUSH
2443: LD_INT 32
2445: PUSH
2446: EMPTY
2447: LIST
2448: LIST
2449: PUSH
2450: EMPTY
2451: LIST
2452: LIST
2453: PPUSH
2454: CALL_OW 69
2458: PUSH
2459: LD_INT 1
2461: ARRAY
2462: PPUSH
2463: CALL_OW 180
// if b > 1 and usForces > 2 then
2467: LD_VAR 0 2
2471: PUSH
2472: LD_INT 1
2474: GREATER
2475: PUSH
2476: LD_EXP 18
2480: PUSH
2481: LD_INT 2
2483: GREATER
2484: AND
2485: IFFALSE 2548
// begin repeat wait ( 0 0$1 ) ;
2487: LD_INT 35
2489: PPUSH
2490: CALL_OW 67
// until BuildingStatus ( b [ 2 ] ) <> bs_build ;
2494: LD_VAR 0 2
2498: PUSH
2499: LD_INT 2
2501: ARRAY
2502: PPUSH
2503: CALL_OW 461
2507: PUSH
2508: LD_INT 1
2510: NONEQUAL
2511: IFFALSE 2487
// ComExitBuilding ( usForces [ 3 ] ) ;
2513: LD_EXP 18
2517: PUSH
2518: LD_INT 3
2520: ARRAY
2521: PPUSH
2522: CALL_OW 122
// AddComEnterUnit ( usForces [ 3 ] , b [ 2 ] ) ;
2526: LD_EXP 18
2530: PUSH
2531: LD_INT 3
2533: ARRAY
2534: PPUSH
2535: LD_VAR 0 2
2539: PUSH
2540: LD_INT 2
2542: ARRAY
2543: PPUSH
2544: CALL_OW 180
// end ; end ;
2548: PPOPN 3
2550: END
// every 0 0$1 trigger GetLives ( usLab ) < 999 and usAlert and usForces do var i ;
2551: LD_INT 3
2553: PPUSH
2554: CALL_OW 256
2558: PUSH
2559: LD_INT 999
2561: LESS
2562: PUSH
2563: LD_EXP 9
2567: AND
2568: PUSH
2569: LD_EXP 18
2573: AND
2574: IFFALSE 2745
2576: GO 2578
2578: DISABLE
2579: LD_INT 0
2581: PPUSH
// begin for i in usForces do
2582: LD_ADDR_VAR 0 1
2586: PUSH
2587: LD_EXP 18
2591: PUSH
2592: FOR_IN
2593: IFFALSE 2632
// begin if IsInUnit ( i ) then
2595: LD_VAR 0 1
2599: PPUSH
2600: CALL_OW 310
2604: IFFALSE 2615
// ComExitBuilding ( i ) ;
2606: LD_VAR 0 1
2610: PPUSH
2611: CALL_OW 122
// AddComAgressiveMove ( i , 31 , 8 ) ;
2615: LD_VAR 0 1
2619: PPUSH
2620: LD_INT 31
2622: PPUSH
2623: LD_INT 8
2625: PPUSH
2626: CALL_OW 174
// end ;
2630: GO 2592
2632: POP
2633: POP
// wait ( 0 0$8 ) ;
2634: LD_INT 280
2636: PPUSH
2637: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) then
2641: LD_INT 22
2643: PUSH
2644: LD_INT 2
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 91
2653: PUSH
2654: LD_INT 3
2656: PUSH
2657: LD_INT 14
2659: PUSH
2660: EMPTY
2661: LIST
2662: LIST
2663: LIST
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: PPUSH
2669: CALL_OW 69
2673: IFFALSE 2723
// ComAttackUnit ( usForces , FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) [ 1 ] ) else
2675: LD_EXP 18
2679: PPUSH
2680: LD_INT 22
2682: PUSH
2683: LD_INT 2
2685: PUSH
2686: EMPTY
2687: LIST
2688: LIST
2689: PUSH
2690: LD_INT 91
2692: PUSH
2693: LD_INT 3
2695: PUSH
2696: LD_INT 14
2698: PUSH
2699: EMPTY
2700: LIST
2701: LIST
2702: LIST
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: PPUSH
2708: CALL_OW 69
2712: PUSH
2713: LD_INT 1
2715: ARRAY
2716: PPUSH
2717: CALL_OW 115
2721: GO 2745
// begin wait ( 0 0$20 ) ;
2723: LD_INT 700
2725: PPUSH
2726: CALL_OW 67
// AddComMoveXY ( usForces , 39 , 19 ) ;
2730: LD_EXP 18
2734: PPUSH
2735: LD_INT 39
2737: PPUSH
2738: LD_INT 19
2740: PPUSH
2741: CALL_OW 171
// end ; end ;
2745: PPOPN 1
2747: END
// every 0 0$3 trigger ( GetDistUnits ( Heike , Delta ) < 10 or GetLives ( usLab ) < 999 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do var tmp , veh ;
2748: LD_EXP 20
2752: PPUSH
2753: LD_INT 1
2755: PPUSH
2756: CALL_OW 296
2760: PUSH
2761: LD_INT 10
2763: LESS
2764: PUSH
2765: LD_INT 3
2767: PPUSH
2768: CALL_OW 256
2772: PUSH
2773: LD_INT 999
2775: LESS
2776: OR
2777: PUSH
2778: LD_INT 22
2780: PUSH
2781: LD_INT 1
2783: PUSH
2784: EMPTY
2785: LIST
2786: LIST
2787: PUSH
2788: LD_INT 25
2790: PUSH
2791: LD_INT 2
2793: PUSH
2794: EMPTY
2795: LIST
2796: LIST
2797: PUSH
2798: EMPTY
2799: LIST
2800: LIST
2801: PPUSH
2802: CALL_OW 69
2806: AND
2807: IFFALSE 2991
2809: GO 2811
2811: DISABLE
2812: LD_INT 0
2814: PPUSH
2815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
2816: LD_ADDR_VAR 0 1
2820: PUSH
2821: LD_INT 22
2823: PUSH
2824: LD_INT 1
2826: PUSH
2827: EMPTY
2828: LIST
2829: LIST
2830: PUSH
2831: LD_INT 25
2833: PUSH
2834: LD_INT 2
2836: PUSH
2837: EMPTY
2838: LIST
2839: LIST
2840: PUSH
2841: EMPTY
2842: LIST
2843: LIST
2844: PPUSH
2845: CALL_OW 69
2849: ST_TO_ADDR
// veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2850: LD_ADDR_VAR 0 2
2854: PUSH
2855: LD_INT 22
2857: PUSH
2858: LD_INT 1
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PUSH
2865: LD_INT 21
2867: PUSH
2868: LD_INT 2
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: PUSH
2875: LD_INT 58
2877: PUSH
2878: EMPTY
2879: LIST
2880: PUSH
2881: EMPTY
2882: LIST
2883: LIST
2884: LIST
2885: PPUSH
2886: CALL_OW 69
2890: ST_TO_ADDR
// if not tmp then
2891: LD_VAR 0 1
2895: NOT
2896: IFFALSE 2900
// exit ;
2898: GO 2991
// ComExitBuilding ( tmp ) ;
2900: LD_VAR 0 1
2904: PPUSH
2905: CALL_OW 122
// AddComDismantle ( tmp , usLab ) ;
2909: LD_VAR 0 1
2913: PPUSH
2914: LD_INT 3
2916: PPUSH
2917: CALL_OW 227
// if veh and IsOk ( Gladstone ) then
2921: LD_VAR 0 2
2925: PUSH
2926: LD_EXP 16
2930: PPUSH
2931: CALL_OW 302
2935: AND
2936: IFFALSE 2991
// begin if IsInUnit ( Gladstone ) then
2938: LD_EXP 16
2942: PPUSH
2943: CALL_OW 310
2947: IFFALSE 2958
// ComExitBuilding ( Gladstone ) ;
2949: LD_EXP 16
2953: PPUSH
2954: CALL_OW 122
// AddComEnterUnit ( Gladstone , veh [ 1 ] ) ;
2958: LD_EXP 16
2962: PPUSH
2963: LD_VAR 0 2
2967: PUSH
2968: LD_INT 1
2970: ARRAY
2971: PPUSH
2972: CALL_OW 180
// AddComAgressiveMove ( Gladstone , 39 , 14 ) ;
2976: LD_EXP 16
2980: PPUSH
2981: LD_INT 39
2983: PPUSH
2984: LD_INT 14
2986: PPUSH
2987: CALL_OW 174
// end ; end ;
2991: PPOPN 2
2993: END
// every 0 0$1 trigger usAlert and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) diff ( usForces union usSci ) do var i , tmp ;
2994: LD_EXP 9
2998: PUSH
2999: LD_INT 22
3001: PUSH
3002: LD_INT 1
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: PUSH
3009: LD_INT 21
3011: PUSH
3012: LD_INT 1
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 3
3021: PUSH
3022: LD_INT 24
3024: PUSH
3025: LD_INT 600
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: PUSH
3032: EMPTY
3033: LIST
3034: LIST
3035: PUSH
3036: EMPTY
3037: LIST
3038: LIST
3039: LIST
3040: PPUSH
3041: CALL_OW 69
3045: PUSH
3046: LD_EXP 18
3050: PUSH
3051: LD_EXP 19
3055: UNION
3056: DIFF
3057: AND
3058: IFFALSE 3195
3060: GO 3062
3062: DISABLE
3063: LD_INT 0
3065: PPUSH
3066: PPUSH
// begin enable ;
3067: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) diff ( usForces union usSci ) ;
3068: LD_ADDR_VAR 0 2
3072: PUSH
3073: LD_INT 22
3075: PUSH
3076: LD_INT 1
3078: PUSH
3079: EMPTY
3080: LIST
3081: LIST
3082: PUSH
3083: LD_INT 21
3085: PUSH
3086: LD_INT 1
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PUSH
3093: LD_INT 3
3095: PUSH
3096: LD_INT 24
3098: PUSH
3099: LD_INT 600
3101: PUSH
3102: EMPTY
3103: LIST
3104: LIST
3105: PUSH
3106: EMPTY
3107: LIST
3108: LIST
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: LIST
3114: PPUSH
3115: CALL_OW 69
3119: PUSH
3120: LD_EXP 18
3124: PUSH
3125: LD_EXP 19
3129: UNION
3130: DIFF
3131: ST_TO_ADDR
// if not tmp then
3132: LD_VAR 0 2
3136: NOT
3137: IFFALSE 3141
// exit ;
3139: GO 3195
// for i in tmp do
3141: LD_ADDR_VAR 0 1
3145: PUSH
3146: LD_VAR 0 2
3150: PUSH
3151: FOR_IN
3152: IFFALSE 3193
// if IsInUnit ( i ) then
3154: LD_VAR 0 1
3158: PPUSH
3159: CALL_OW 310
3163: IFFALSE 3176
// ComExitBuilding ( i ) else
3165: LD_VAR 0 1
3169: PPUSH
3170: CALL_OW 122
3174: GO 3191
// ComMoveXY ( i , 48 , 74 ) ;
3176: LD_VAR 0 1
3180: PPUSH
3181: LD_INT 48
3183: PPUSH
3184: LD_INT 74
3186: PPUSH
3187: CALL_OW 111
3191: GO 3151
3193: POP
3194: POP
// end ;
3195: PPOPN 2
3197: END
// every 5 5$00 do var i , un , tmp ;
3198: GO 3200
3200: DISABLE
3201: LD_INT 0
3203: PPUSH
3204: PPUSH
3205: PPUSH
// begin tmp := [ ] ;
3206: LD_ADDR_VAR 0 3
3210: PUSH
3211: EMPTY
3212: ST_TO_ADDR
// uc_side := 1 ;
3213: LD_ADDR_OWVAR 20
3217: PUSH
3218: LD_INT 1
3220: ST_TO_ADDR
// uc_nation := 1 ;
3221: LD_ADDR_OWVAR 21
3225: PUSH
3226: LD_INT 1
3228: ST_TO_ADDR
// case Difficulty of 1 :
3229: LD_OWVAR 67
3233: PUSH
3234: LD_INT 1
3236: DOUBLE
3237: EQUAL
3238: IFTRUE 3242
3240: GO 3345
3242: POP
// begin wait ( 1 1$00 ) ;
3243: LD_INT 2100
3245: PPUSH
3246: CALL_OW 67
// for i := 1 to 2 do
3250: LD_ADDR_VAR 0 1
3254: PUSH
3255: DOUBLE
3256: LD_INT 1
3258: DEC
3259: ST_TO_ADDR
3260: LD_INT 2
3262: PUSH
3263: FOR_TO
3264: IFFALSE 3341
// begin PrepareHuman ( false , [ 1 , 4 ] [ i mod 2 + 1 ] , 1 ) ;
3266: LD_INT 0
3268: PPUSH
3269: LD_INT 1
3271: PUSH
3272: LD_INT 4
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: PUSH
3279: LD_VAR 0 1
3283: PUSH
3284: LD_INT 2
3286: MOD
3287: PUSH
3288: LD_INT 1
3290: PLUS
3291: ARRAY
3292: PPUSH
3293: LD_INT 1
3295: PPUSH
3296: CALL_OW 380
// un := CreateHuman ;
3300: LD_ADDR_VAR 0 2
3304: PUSH
3305: CALL_OW 44
3309: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3310: LD_ADDR_VAR 0 3
3314: PUSH
3315: LD_VAR 0 3
3319: PPUSH
3320: LD_VAR 0 3
3324: PUSH
3325: LD_INT 1
3327: PLUS
3328: PPUSH
3329: LD_VAR 0 2
3333: PPUSH
3334: CALL_OW 1
3338: ST_TO_ADDR
// end ;
3339: GO 3263
3341: POP
3342: POP
// end ; 2 :
3343: GO 3739
3345: LD_INT 2
3347: DOUBLE
3348: EQUAL
3349: IFTRUE 3353
3351: GO 3487
3353: POP
// begin wait ( 0 0$30 ) ;
3354: LD_INT 1050
3356: PPUSH
3357: CALL_OW 67
// for i := 1 to 2 do
3361: LD_ADDR_VAR 0 1
3365: PUSH
3366: DOUBLE
3367: LD_INT 1
3369: DEC
3370: ST_TO_ADDR
3371: LD_INT 2
3373: PUSH
3374: FOR_TO
3375: IFFALSE 3431
// begin PrepareHuman ( false , 1 , 2 ) ;
3377: LD_INT 0
3379: PPUSH
3380: LD_INT 1
3382: PPUSH
3383: LD_INT 2
3385: PPUSH
3386: CALL_OW 380
// un := CreateHuman ;
3390: LD_ADDR_VAR 0 2
3394: PUSH
3395: CALL_OW 44
3399: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3400: LD_ADDR_VAR 0 3
3404: PUSH
3405: LD_VAR 0 3
3409: PPUSH
3410: LD_VAR 0 3
3414: PUSH
3415: LD_INT 1
3417: PLUS
3418: PPUSH
3419: LD_VAR 0 2
3423: PPUSH
3424: CALL_OW 1
3428: ST_TO_ADDR
// end ;
3429: GO 3374
3431: POP
3432: POP
// PrepareHuman ( false , 4 , 2 ) ;
3433: LD_INT 0
3435: PPUSH
3436: LD_INT 4
3438: PPUSH
3439: LD_INT 2
3441: PPUSH
3442: CALL_OW 380
// un := CreateHuman ;
3446: LD_ADDR_VAR 0 2
3450: PUSH
3451: CALL_OW 44
3455: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3456: LD_ADDR_VAR 0 3
3460: PUSH
3461: LD_VAR 0 3
3465: PPUSH
3466: LD_VAR 0 3
3470: PUSH
3471: LD_INT 1
3473: PLUS
3474: PPUSH
3475: LD_VAR 0 2
3479: PPUSH
3480: CALL_OW 1
3484: ST_TO_ADDR
// end ; 3 :
3485: GO 3739
3487: LD_INT 3
3489: DOUBLE
3490: EQUAL
3491: IFTRUE 3495
3493: GO 3738
3495: POP
// begin for i := 1 to 2 do
3496: LD_ADDR_VAR 0 1
3500: PUSH
3501: DOUBLE
3502: LD_INT 1
3504: DEC
3505: ST_TO_ADDR
3506: LD_INT 2
3508: PUSH
3509: FOR_TO
3510: IFFALSE 3566
// begin PrepareHuman ( false , 1 , 2 ) ;
3512: LD_INT 0
3514: PPUSH
3515: LD_INT 1
3517: PPUSH
3518: LD_INT 2
3520: PPUSH
3521: CALL_OW 380
// un := CreateHuman ;
3525: LD_ADDR_VAR 0 2
3529: PUSH
3530: CALL_OW 44
3534: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3535: LD_ADDR_VAR 0 3
3539: PUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: LD_VAR 0 3
3549: PUSH
3550: LD_INT 1
3552: PLUS
3553: PPUSH
3554: LD_VAR 0 2
3558: PPUSH
3559: CALL_OW 1
3563: ST_TO_ADDR
// end ;
3564: GO 3509
3566: POP
3567: POP
// PrepareHuman ( false , 4 , 2 ) ;
3568: LD_INT 0
3570: PPUSH
3571: LD_INT 4
3573: PPUSH
3574: LD_INT 2
3576: PPUSH
3577: CALL_OW 380
// un := CreateHuman ;
3581: LD_ADDR_VAR 0 2
3585: PUSH
3586: CALL_OW 44
3590: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3591: LD_ADDR_VAR 0 3
3595: PUSH
3596: LD_VAR 0 3
3600: PPUSH
3601: LD_VAR 0 3
3605: PUSH
3606: LD_INT 1
3608: PLUS
3609: PPUSH
3610: LD_VAR 0 2
3614: PPUSH
3615: CALL_OW 1
3619: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_machine_gun , 90 ) ;
3620: LD_INT 1
3622: PPUSH
3623: LD_INT 1
3625: PPUSH
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 2
3631: PPUSH
3632: LD_INT 1
3634: PPUSH
3635: LD_INT 2
3637: PPUSH
3638: LD_INT 90
3640: PPUSH
3641: CALL 276 0 7
// un := CreateVehicle ;
3645: LD_ADDR_VAR 0 2
3649: PUSH
3650: CALL_OW 45
3654: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3655: LD_ADDR_VAR 0 3
3659: PUSH
3660: LD_VAR 0 3
3664: PPUSH
3665: LD_VAR 0 3
3669: PUSH
3670: LD_INT 1
3672: PLUS
3673: PPUSH
3674: LD_VAR 0 2
3678: PPUSH
3679: CALL_OW 1
3683: ST_TO_ADDR
// PrepareHuman ( false , 1 , 2 ) ;
3684: LD_INT 0
3686: PPUSH
3687: LD_INT 1
3689: PPUSH
3690: LD_INT 2
3692: PPUSH
3693: CALL_OW 380
// un := CreateHuman ;
3697: LD_ADDR_VAR 0 2
3701: PUSH
3702: CALL_OW 44
3706: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3707: LD_ADDR_VAR 0 3
3711: PUSH
3712: LD_VAR 0 3
3716: PPUSH
3717: LD_VAR 0 3
3721: PUSH
3722: LD_INT 1
3724: PLUS
3725: PPUSH
3726: LD_VAR 0 2
3730: PPUSH
3731: CALL_OW 1
3735: ST_TO_ADDR
// end ; end ;
3736: GO 3739
3738: POP
// for i := 1 to tmp do
3739: LD_ADDR_VAR 0 1
3743: PUSH
3744: DOUBLE
3745: LD_INT 1
3747: DEC
3748: ST_TO_ADDR
3749: LD_VAR 0 3
3753: PUSH
3754: FOR_TO
3755: IFFALSE 3920
// begin SetDir ( tmp [ i ] , 1 ) ;
3757: LD_VAR 0 3
3761: PUSH
3762: LD_VAR 0 1
3766: ARRAY
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: CALL_OW 233
// if GetType ( tmp [ i ] ) = unit_human then
3775: LD_VAR 0 3
3779: PUSH
3780: LD_VAR 0 1
3784: ARRAY
3785: PPUSH
3786: CALL_OW 247
3790: PUSH
3791: LD_INT 1
3793: EQUAL
3794: IFFALSE 3822
// PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) else
3796: LD_VAR 0 3
3800: PUSH
3801: LD_VAR 0 1
3805: ARRAY
3806: PPUSH
3807: LD_INT 28
3809: PPUSH
3810: LD_INT 52
3812: PPUSH
3813: LD_INT 0
3815: PPUSH
3816: CALL_OW 48
3820: GO 3890
// begin PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) ;
3822: LD_VAR 0 3
3826: PUSH
3827: LD_VAR 0 1
3831: ARRAY
3832: PPUSH
3833: LD_INT 28
3835: PPUSH
3836: LD_INT 52
3838: PPUSH
3839: LD_INT 0
3841: PPUSH
3842: CALL_OW 48
// i := i + 1 ;
3846: LD_ADDR_VAR 0 1
3850: PUSH
3851: LD_VAR 0 1
3855: PUSH
3856: LD_INT 1
3858: PLUS
3859: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ i ] , tmp [ i - 1 ] ) ;
3860: LD_VAR 0 3
3864: PUSH
3865: LD_VAR 0 1
3869: ARRAY
3870: PPUSH
3871: LD_VAR 0 3
3875: PUSH
3876: LD_VAR 0 1
3880: PUSH
3881: LD_INT 1
3883: MINUS
3884: ARRAY
3885: PPUSH
3886: CALL_OW 52
// end ; ComMoveXY ( tmp [ i ] , 43 , 56 ) ;
3890: LD_VAR 0 3
3894: PUSH
3895: LD_VAR 0 1
3899: ARRAY
3900: PPUSH
3901: LD_INT 43
3903: PPUSH
3904: LD_INT 56
3906: PPUSH
3907: CALL_OW 111
// wait ( 0 0$2 ) ;
3911: LD_INT 70
3913: PPUSH
3914: CALL_OW 67
// end ;
3918: GO 3754
3920: POP
3921: POP
// wait ( 0 0$2 ) ;
3922: LD_INT 70
3924: PPUSH
3925: CALL_OW 67
// if not FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) then
3929: LD_INT 7
3931: PPUSH
3932: LD_INT 22
3934: PUSH
3935: LD_INT 2
3937: PUSH
3938: EMPTY
3939: LIST
3940: LIST
3941: PPUSH
3942: CALL_OW 70
3946: NOT
3947: IFFALSE 4145
// begin AddComAgressiveMove ( tmp , 35 , 24 ) ;
3949: LD_VAR 0 3
3953: PPUSH
3954: LD_INT 35
3956: PPUSH
3957: LD_INT 24
3959: PPUSH
3960: CALL_OW 174
// usForces := usForces union UnitFilter ( tmp , [ f_class , 1 ] ) ;
3964: LD_ADDR_EXP 18
3968: PUSH
3969: LD_EXP 18
3973: PUSH
3974: LD_VAR 0 3
3978: PPUSH
3979: LD_INT 25
3981: PUSH
3982: LD_INT 1
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: PPUSH
3989: CALL_OW 72
3993: UNION
3994: ST_TO_ADDR
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
3995: LD_INT 22
3997: PUSH
3998: LD_INT 1
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: PUSH
4005: LD_INT 30
4007: PUSH
4008: LD_INT 4
4010: PUSH
4011: EMPTY
4012: LIST
4013: LIST
4014: PUSH
4015: EMPTY
4016: LIST
4017: LIST
4018: PPUSH
4019: CALL_OW 69
4023: PUSH
4024: LD_INT 1
4026: ARRAY
4027: PPUSH
4028: CALL_OW 313
4032: PUSH
4033: LD_INT 6
4035: LESS
4036: IFFALSE 4095
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
4038: LD_VAR 0 3
4042: PPUSH
4043: LD_INT 25
4045: PUSH
4046: LD_INT 1
4048: PUSH
4049: EMPTY
4050: LIST
4051: LIST
4052: PPUSH
4053: CALL_OW 72
4057: PPUSH
4058: LD_INT 22
4060: PUSH
4061: LD_INT 1
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: PUSH
4068: LD_INT 30
4070: PUSH
4071: LD_INT 4
4073: PUSH
4074: EMPTY
4075: LIST
4076: LIST
4077: PUSH
4078: EMPTY
4079: LIST
4080: LIST
4081: PPUSH
4082: CALL_OW 69
4086: PUSH
4087: LD_INT 1
4089: ARRAY
4090: PPUSH
4091: CALL_OW 180
// if UnitFilter ( tmp , [ f_class , 4 ] ) then
4095: LD_VAR 0 3
4099: PPUSH
4100: LD_INT 25
4102: PUSH
4103: LD_INT 4
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PPUSH
4110: CALL_OW 72
4114: IFFALSE 4143
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 4 ] ) , usLab ) ;
4116: LD_VAR 0 3
4120: PPUSH
4121: LD_INT 25
4123: PUSH
4124: LD_INT 4
4126: PUSH
4127: EMPTY
4128: LIST
4129: LIST
4130: PPUSH
4131: CALL_OW 72
4135: PPUSH
4136: LD_INT 3
4138: PPUSH
4139: CALL_OW 180
// end else
4143: GO 4420
// begin tmp := tmp union FilterUnitsInArea ( retreatArea , [ f_side , 1 ] ) ;
4145: LD_ADDR_VAR 0 3
4149: PUSH
4150: LD_VAR 0 3
4154: PUSH
4155: LD_INT 6
4157: PPUSH
4158: LD_INT 22
4160: PUSH
4161: LD_INT 1
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PPUSH
4168: CALL_OW 70
4172: UNION
4173: ST_TO_ADDR
// ComMoveXY ( tmp , 45 , 54 ) ;
4174: LD_VAR 0 3
4178: PPUSH
4179: LD_INT 45
4181: PPUSH
4182: LD_INT 54
4184: PPUSH
4185: CALL_OW 111
// wait ( 0 0$3 ) ;
4189: LD_INT 105
4191: PPUSH
4192: CALL_OW 67
// AddComAgressiveMove ( tmp diff UnitFilter ( tmp , [ f_class , 4 ] ) , 35 , 24 ) ;
4196: LD_VAR 0 3
4200: PUSH
4201: LD_VAR 0 3
4205: PPUSH
4206: LD_INT 25
4208: PUSH
4209: LD_INT 4
4211: PUSH
4212: EMPTY
4213: LIST
4214: LIST
4215: PPUSH
4216: CALL_OW 72
4220: DIFF
4221: PPUSH
4222: LD_INT 35
4224: PPUSH
4225: LD_INT 24
4227: PPUSH
4228: CALL_OW 174
// AddComMoveXY ( UnitFilter ( tmp , [ f_class , 4 ] ) , 42 , 49 ) ;
4232: LD_VAR 0 3
4236: PPUSH
4237: LD_INT 25
4239: PUSH
4240: LD_INT 4
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: PPUSH
4247: CALL_OW 72
4251: PPUSH
4252: LD_INT 42
4254: PPUSH
4255: LD_INT 49
4257: PPUSH
4258: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4262: LD_INT 35
4264: PPUSH
4265: CALL_OW 67
// for i in tmp do
4269: LD_ADDR_VAR 0 1
4273: PUSH
4274: LD_VAR 0 3
4278: PUSH
4279: FOR_IN
4280: IFFALSE 4411
// if IsDead ( i ) then
4282: LD_VAR 0 1
4286: PPUSH
4287: CALL_OW 301
4291: IFFALSE 4311
// tmp := tmp diff i else
4293: LD_ADDR_VAR 0 3
4297: PUSH
4298: LD_VAR 0 3
4302: PUSH
4303: LD_VAR 0 1
4307: DIFF
4308: ST_TO_ADDR
4309: GO 4409
// if GetClass ( i ) = 1 then
4311: LD_VAR 0 1
4315: PPUSH
4316: CALL_OW 257
4320: PUSH
4321: LD_INT 1
4323: EQUAL
4324: IFFALSE 4409
// begin if GetLives ( i ) < 600 and GetDistUnitXY ( i , 42 , 49 ) > 6 then
4326: LD_VAR 0 1
4330: PPUSH
4331: CALL_OW 256
4335: PUSH
4336: LD_INT 600
4338: LESS
4339: PUSH
4340: LD_VAR 0 1
4344: PPUSH
4345: LD_INT 42
4347: PPUSH
4348: LD_INT 49
4350: PPUSH
4351: CALL_OW 297
4355: PUSH
4356: LD_INT 6
4358: GREATER
4359: AND
4360: IFFALSE 4379
// ComMoveXY ( i , 42 , 49 ) else
4362: LD_VAR 0 1
4366: PPUSH
4367: LD_INT 42
4369: PPUSH
4370: LD_INT 49
4372: PPUSH
4373: CALL_OW 111
4377: GO 4409
// if GetLives ( i ) = 1000 then
4379: LD_VAR 0 1
4383: PPUSH
4384: CALL_OW 256
4388: PUSH
4389: LD_INT 1000
4391: EQUAL
4392: IFFALSE 4409
// ComAgressiveMove ( i , 36 , 25 ) ;
4394: LD_VAR 0 1
4398: PPUSH
4399: LD_INT 36
4401: PPUSH
4402: LD_INT 25
4404: PPUSH
4405: CALL_OW 114
// end ;
4409: GO 4279
4411: POP
4412: POP
// until not tmp ;
4413: LD_VAR 0 3
4417: NOT
4418: IFFALSE 4262
// end ; end ; end_of_file
4420: PPOPN 3
4422: END
// export function Action ; var i , tmp ; begin
4423: LD_INT 0
4425: PPUSH
4426: PPUSH
4427: PPUSH
// InGameOn ;
4428: CALL_OW 8
// DoNotAttack ( 2 , usLab ) ;
4432: LD_INT 2
4434: PPUSH
4435: LD_INT 3
4437: PPUSH
4438: CALL_OW 471
// ComMoveXY ( Heike , 78 , 61 ) ;
4442: LD_EXP 20
4446: PPUSH
4447: LD_INT 78
4449: PPUSH
4450: LD_INT 61
4452: PPUSH
4453: CALL_OW 111
// if Mike then
4457: LD_EXP 22
4461: IFFALSE 4478
// ComMoveXY ( Mike , 80 , 66 ) ;
4463: LD_EXP 22
4467: PPUSH
4468: LD_INT 80
4470: PPUSH
4471: LD_INT 66
4473: PPUSH
4474: CALL_OW 111
// if Givi then
4478: LD_EXP 21
4482: IFFALSE 4499
// ComMoveXY ( Givi , 82 , 66 ) ;
4484: LD_EXP 21
4488: PPUSH
4489: LD_INT 82
4491: PPUSH
4492: LD_INT 66
4494: PPUSH
4495: CALL_OW 111
// if Kamil then
4499: LD_EXP 23
4503: IFFALSE 4520
// ComMoveXY ( Kamil , 82 , 67 ) ;
4505: LD_EXP 23
4509: PPUSH
4510: LD_INT 82
4512: PPUSH
4513: LD_INT 67
4515: PPUSH
4516: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
4520: LD_EXP 20
4524: PPUSH
4525: CALL_OW 87
// wait ( 0 0$2 ) ;
4529: LD_INT 70
4531: PPUSH
4532: CALL_OW 67
// if Givi and Mike then
4536: LD_EXP 21
4540: PUSH
4541: LD_EXP 22
4545: AND
4546: IFFALSE 4992
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4548: LD_EXP 21
4552: PUSH
4553: LD_EXP 22
4557: PUSH
4558: LD_EXP 23
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: LIST
4567: PPUSH
4568: LD_EXP 20
4572: PPUSH
4573: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
4577: LD_EXP 20
4581: PPUSH
4582: LD_EXP 21
4586: PPUSH
4587: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
4591: LD_EXP 21
4595: PPUSH
4596: LD_STRING DG-1-start
4598: PPUSH
4599: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
4603: LD_EXP 20
4607: PPUSH
4608: LD_STRING DH-1-start
4610: PPUSH
4611: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
4615: LD_EXP 22
4619: PPUSH
4620: LD_EXP 20
4624: PPUSH
4625: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
4629: LD_EXP 20
4633: PPUSH
4634: LD_EXP 22
4638: PPUSH
4639: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
4643: LD_EXP 22
4647: PPUSH
4648: LD_STRING DM-1-start
4650: PPUSH
4651: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
4655: LD_EXP 20
4659: PPUSH
4660: LD_STRING DH-2-start
4662: PPUSH
4663: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
4667: LD_EXP 22
4671: PPUSH
4672: LD_STRING DM-2-start
4674: PPUSH
4675: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
4679: LD_EXP 21
4683: PPUSH
4684: LD_STRING DG-2-start
4686: PPUSH
4687: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
4691: LD_EXP 22
4695: PPUSH
4696: LD_EXP 21
4700: PPUSH
4701: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
4705: LD_EXP 20
4709: PPUSH
4710: LD_EXP 22
4714: PPUSH
4715: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
4719: LD_EXP 22
4723: PPUSH
4724: LD_STRING DM-3-start
4726: PPUSH
4727: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
4731: LD_EXP 20
4735: PPUSH
4736: LD_STRING DH-3-start
4738: PPUSH
4739: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
4743: LD_EXP 20
4747: PUSH
4748: LD_EXP 22
4752: PUSH
4753: LD_EXP 21
4757: PUSH
4758: LD_EXP 23
4762: PUSH
4763: EMPTY
4764: LIST
4765: LIST
4766: LIST
4767: LIST
4768: PPUSH
4769: LD_INT 84
4771: PPUSH
4772: LD_INT 51
4774: PPUSH
4775: CALL_OW 111
// wait ( 0 0$2 ) ;
4779: LD_INT 70
4781: PPUSH
4782: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
4786: LD_EXP 21
4790: PPUSH
4791: LD_STRING DG-3-start
4793: PPUSH
4794: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
4798: LD_EXP 20
4802: PUSH
4803: LD_EXP 22
4807: PUSH
4808: LD_EXP 21
4812: PUSH
4813: LD_EXP 23
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: PPUSH
4824: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
4828: LD_EXP 20
4832: PPUSH
4833: LD_EXP 21
4837: PPUSH
4838: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4842: LD_EXP 21
4846: PUSH
4847: LD_EXP 22
4851: PUSH
4852: LD_EXP 23
4856: PUSH
4857: EMPTY
4858: LIST
4859: LIST
4860: LIST
4861: PPUSH
4862: LD_EXP 20
4866: PPUSH
4867: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
4871: LD_EXP 20
4875: PPUSH
4876: LD_STRING DH-4-start
4878: PPUSH
4879: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
4883: LD_EXP 21
4887: PPUSH
4888: LD_STRING DG-4-start
4890: PPUSH
4891: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
4895: LD_EXP 20
4899: PPUSH
4900: LD_STRING DH-5-start
4902: PPUSH
4903: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
4907: LD_EXP 21
4911: PPUSH
4912: LD_STRING DG-5-start
4914: PPUSH
4915: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
4919: LD_EXP 20
4923: PPUSH
4924: LD_STRING DH-6-start
4926: PPUSH
4927: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
4931: LD_EXP 22
4935: PPUSH
4936: LD_STRING DM-6-start
4938: PPUSH
4939: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
4943: LD_EXP 20
4947: PUSH
4948: LD_EXP 21
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PPUSH
4957: LD_EXP 22
4961: PPUSH
4962: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
4966: LD_EXP 21
4970: PPUSH
4971: LD_STRING DG-6-start
4973: PPUSH
4974: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
4978: LD_EXP 20
4982: PPUSH
4983: LD_STRING DH-7-start
4985: PPUSH
4986: CALL_OW 88
// end else
4990: GO 5714
// if not Mike and Givi then
4992: LD_EXP 22
4996: NOT
4997: PUSH
4998: LD_EXP 21
5002: AND
5003: IFFALSE 5348
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5005: LD_EXP 21
5009: PUSH
5010: LD_EXP 23
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PPUSH
5019: LD_EXP 20
5023: PPUSH
5024: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
5028: LD_EXP 20
5032: PPUSH
5033: LD_EXP 21
5037: PPUSH
5038: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
5042: LD_EXP 21
5046: PPUSH
5047: LD_STRING DG-1-start-c
5049: PPUSH
5050: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
5054: LD_EXP 20
5058: PPUSH
5059: LD_STRING DH-1-start-c
5061: PPUSH
5062: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
5066: LD_EXP 21
5070: PPUSH
5071: LD_STRING DG-2-start-c
5073: PPUSH
5074: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
5078: LD_EXP 20
5082: PPUSH
5083: LD_STRING DH-2-start-c
5085: PPUSH
5086: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
5090: LD_EXP 21
5094: PPUSH
5095: LD_STRING DG-3-start-c
5097: PPUSH
5098: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
5102: LD_EXP 20
5106: PPUSH
5107: LD_INT 83
5109: PPUSH
5110: LD_INT 56
5112: PPUSH
5113: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
5117: LD_EXP 21
5121: PPUSH
5122: LD_INT 83
5124: PPUSH
5125: LD_INT 59
5127: PPUSH
5128: CALL_OW 111
// if Kamil then
5132: LD_EXP 23
5136: IFFALSE 5153
// ComMoveXY ( Kamil , 80 , 58 ) ;
5138: LD_EXP 23
5142: PPUSH
5143: LD_INT 80
5145: PPUSH
5146: LD_INT 58
5148: PPUSH
5149: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
5153: LD_EXP 20
5157: PPUSH
5158: LD_EXP 21
5162: PPUSH
5163: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5167: LD_EXP 21
5171: PUSH
5172: LD_EXP 23
5176: PUSH
5177: EMPTY
5178: LIST
5179: LIST
5180: PPUSH
5181: LD_EXP 20
5185: PPUSH
5186: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
5190: LD_EXP 20
5194: PPUSH
5195: LD_STRING DH-3-start-c
5197: PPUSH
5198: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
5202: LD_EXP 21
5206: PPUSH
5207: LD_STRING DG-4-start-c
5209: PPUSH
5210: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
5214: LD_EXP 20
5218: PPUSH
5219: LD_STRING DH-5-start-c
5221: PPUSH
5222: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
5226: LD_EXP 21
5230: PPUSH
5231: LD_STRING DG-5-start-c
5233: PPUSH
5234: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
5238: LD_EXP 20
5242: PPUSH
5243: LD_STRING DH-6-start-c
5245: PPUSH
5246: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
5250: LD_EXP 21
5254: PPUSH
5255: LD_STRING DG-6-start-c
5257: PPUSH
5258: CALL_OW 88
// if Kamil then
5262: LD_EXP 23
5266: IFFALSE 5322
// begin ComTurnUnit ( Kamil , Heike ) ;
5268: LD_EXP 23
5272: PPUSH
5273: LD_EXP 20
5277: PPUSH
5278: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5282: LD_EXP 23
5286: PPUSH
5287: LD_STRING DKam-1-start-c
5289: PPUSH
5290: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
5294: LD_EXP 21
5298: PPUSH
5299: LD_EXP 23
5303: PPUSH
5304: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
5308: LD_EXP 21
5312: PPUSH
5313: LD_STRING DG-7-start-c
5315: PPUSH
5316: CALL_OW 88
// end else
5320: GO 5346
// begin Say ( Givi , DG-8-start-c ) ;
5322: LD_EXP 21
5326: PPUSH
5327: LD_STRING DG-8-start-c
5329: PPUSH
5330: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
5334: LD_EXP 20
5338: PPUSH
5339: LD_STRING DH-7-start-c
5341: PPUSH
5342: CALL_OW 88
// end ; end else
5346: GO 5714
// if not Givi and Mike then
5348: LD_EXP 21
5352: NOT
5353: PUSH
5354: LD_EXP 22
5358: AND
5359: IFFALSE 5618
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
5361: LD_EXP 22
5365: PUSH
5366: LD_EXP 23
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PPUSH
5375: LD_EXP 20
5379: PPUSH
5380: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
5384: LD_EXP 20
5388: PPUSH
5389: LD_EXP 22
5393: PPUSH
5394: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
5398: LD_EXP 22
5402: PPUSH
5403: LD_STRING DM-1-start-b
5405: PPUSH
5406: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
5410: LD_EXP 20
5414: PPUSH
5415: LD_STRING DH-1-start-b
5417: PPUSH
5418: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
5422: LD_EXP 22
5426: PPUSH
5427: LD_STRING DM-2-start-b
5429: PPUSH
5430: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
5434: LD_EXP 20
5438: PPUSH
5439: LD_STRING DH-2-start-b
5441: PPUSH
5442: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
5446: LD_EXP 22
5450: PPUSH
5451: LD_STRING DM-3-start-b
5453: PPUSH
5454: CALL_OW 88
// if Kamil then
5458: LD_EXP 23
5462: IFFALSE 5479
// ComMoveXY ( Kamil , 80 , 58 ) ;
5464: LD_EXP 23
5468: PPUSH
5469: LD_INT 80
5471: PPUSH
5472: LD_INT 58
5474: PPUSH
5475: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
5479: LD_EXP 20
5483: PPUSH
5484: LD_INT 83
5486: PPUSH
5487: LD_INT 56
5489: PPUSH
5490: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
5494: LD_EXP 22
5498: PPUSH
5499: LD_INT 83
5501: PPUSH
5502: LD_INT 59
5504: PPUSH
5505: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
5509: LD_EXP 20
5513: PPUSH
5514: LD_EXP 22
5518: PPUSH
5519: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
5523: LD_EXP 23
5527: PUSH
5528: LD_EXP 22
5532: PUSH
5533: EMPTY
5534: LIST
5535: LIST
5536: PPUSH
5537: LD_EXP 20
5541: PPUSH
5542: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
5546: LD_EXP 20
5550: PPUSH
5551: LD_STRING DH-3-start-b
5553: PPUSH
5554: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
5558: LD_EXP 22
5562: PPUSH
5563: LD_STRING DM-4-start-b
5565: PPUSH
5566: CALL_OW 88
// if Kamil then
5570: LD_EXP 23
5574: IFFALSE 5604
// begin ComTurnUnit ( Kamil , Heike ) ;
5576: LD_EXP 23
5580: PPUSH
5581: LD_EXP 20
5585: PPUSH
5586: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5590: LD_EXP 23
5594: PPUSH
5595: LD_STRING DKam-1-start-c
5597: PPUSH
5598: CALL_OW 88
// end else
5602: GO 5616
// begin Say ( Mike , DM-5-start-b ) ;
5604: LD_EXP 22
5608: PPUSH
5609: LD_STRING DM-5-start-b
5611: PPUSH
5612: CALL_OW 88
// end ; end else
5616: GO 5714
// if Kamil then
5618: LD_EXP 23
5622: IFFALSE 5702
// begin AddComTurnUnit ( Heike , Kamil ) ;
5624: LD_EXP 20
5628: PPUSH
5629: LD_EXP 23
5633: PPUSH
5634: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
5638: LD_EXP 23
5642: PPUSH
5643: LD_EXP 20
5647: PPUSH
5648: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
5652: LD_EXP 20
5656: PPUSH
5657: LD_STRING DH-1-start-f
5659: PPUSH
5660: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
5664: LD_EXP 23
5668: PPUSH
5669: LD_STRING DKam-1-start-f
5671: PPUSH
5672: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
5676: LD_EXP 20
5680: PPUSH
5681: LD_STRING DH-2-start-f
5683: PPUSH
5684: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
5688: LD_EXP 23
5692: PPUSH
5693: LD_STRING DKam-2-start-f
5695: PPUSH
5696: CALL_OW 88
// end else
5700: GO 5714
// begin Say ( Heike , DH-1-start-d ) ;
5702: LD_EXP 20
5706: PPUSH
5707: LD_STRING DH-1-start-d
5709: PPUSH
5710: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
5714: LD_EXP 20
5718: PUSH
5719: LD_EXP 21
5723: PUSH
5724: LD_EXP 22
5728: PUSH
5729: LD_EXP 23
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: LIST
5738: LIST
5739: PPUSH
5740: CALL_OW 139
// InGameOff ;
5744: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
5748: LD_STRING OEast
5750: PPUSH
5751: CALL_OW 337
// wait ( 0 0$20 ) ;
5755: LD_INT 700
5757: PPUSH
5758: CALL_OW 67
// SendSciToForest ;
5762: CALL 1375 0 0
// if Difficulty = 1 then
5766: LD_OWVAR 67
5770: PUSH
5771: LD_INT 1
5773: EQUAL
5774: IFFALSE 5778
// exit ;
5776: GO 5895
// wait ( [ 5 5$00 , 2 2$30 ] [ Difficulty - 1 ] ) ;
5778: LD_INT 10500
5780: PUSH
5781: LD_INT 5250
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: LD_OWVAR 67
5792: PUSH
5793: LD_INT 1
5795: MINUS
5796: ARRAY
5797: PPUSH
5798: CALL_OW 67
// if usAlert then
5802: LD_EXP 9
5806: IFFALSE 5810
// exit ;
5808: GO 5895
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
5810: LD_ADDR_VAR 0 3
5814: PUSH
5815: LD_INT 22
5817: PUSH
5818: LD_INT 1
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: PUSH
5825: LD_INT 25
5827: PUSH
5828: LD_INT 2
5830: PUSH
5831: EMPTY
5832: LIST
5833: LIST
5834: PUSH
5835: EMPTY
5836: LIST
5837: LIST
5838: PPUSH
5839: CALL_OW 69
5843: ST_TO_ADDR
// if not tmp then
5844: LD_VAR 0 3
5848: NOT
5849: IFFALSE 5853
// exit ;
5851: GO 5895
// ComExitBuilding ( tmp ) ;
5853: LD_VAR 0 3
5857: PPUSH
5858: CALL_OW 122
// AddComBuild ( tmp , b_breastwork , 40 , 13 , 3 ) ;
5862: LD_VAR 0 3
5866: PPUSH
5867: LD_INT 31
5869: PPUSH
5870: LD_INT 40
5872: PPUSH
5873: LD_INT 13
5875: PPUSH
5876: LD_INT 3
5878: PPUSH
5879: CALL_OW 205
// AddComEnterUnit ( tmp , Delta ) ;
5883: LD_VAR 0 3
5887: PPUSH
5888: LD_INT 1
5890: PPUSH
5891: CALL_OW 180
// end ;
5895: LD_VAR 0 1
5899: RET
// every 3 3$00 do
5900: GO 5902
5902: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
5903: LD_INT 1
5905: PPUSH
5906: LD_INT 570
5908: PPUSH
5909: LD_INT 350
5911: PPUSH
5912: CALL_OW 550
// wait ( 2 2$40 ) ;
5916: LD_INT 5600
5918: PPUSH
5919: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
5923: LD_INT 0
5925: PPUSH
5926: LD_INT 570
5928: PPUSH
5929: LD_INT 350
5931: PPUSH
5932: CALL_OW 550
// end ;
5936: END
// every 0 0$1 trigger not aviradzeSpotted and See ( 2 , Aviradze ) do var i , pepAmount ;
5937: LD_EXP 4
5941: NOT
5942: PUSH
5943: LD_INT 2
5945: PPUSH
5946: LD_EXP 24
5950: PPUSH
5951: CALL_OW 292
5955: AND
5956: IFFALSE 6864
5958: GO 5960
5960: DISABLE
5961: LD_INT 0
5963: PPUSH
5964: PPUSH
// begin aviradzeSpotted := true ;
5965: LD_ADDR_EXP 4
5969: PUSH
5970: LD_INT 1
5972: ST_TO_ADDR
// pepAmount := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
5973: LD_ADDR_VAR 0 2
5977: PUSH
5978: LD_INT 22
5980: PUSH
5981: LD_INT 2
5983: PUSH
5984: EMPTY
5985: LIST
5986: LIST
5987: PUSH
5988: LD_INT 21
5990: PUSH
5991: LD_INT 1
5993: PUSH
5994: EMPTY
5995: LIST
5996: LIST
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: PPUSH
6002: CALL_OW 69
6006: ST_TO_ADDR
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6007: LD_EXP 20
6011: PPUSH
6012: LD_EXP 24
6016: PPUSH
6017: CALL_OW 250
6021: PPUSH
6022: LD_EXP 24
6026: PPUSH
6027: CALL_OW 251
6031: PPUSH
6032: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6036: LD_INT 35
6038: PPUSH
6039: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 16 ;
6043: LD_EXP 20
6047: PPUSH
6048: LD_EXP 24
6052: PPUSH
6053: CALL_OW 296
6057: PUSH
6058: LD_INT 16
6060: LESS
6061: IFFALSE 6036
// InGameOn ;
6063: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6067: LD_INT 5
6069: PPUSH
6070: LD_INT 2
6072: PPUSH
6073: CALL_OW 343
// if pepAmount > 2 then
6077: LD_VAR 0 2
6081: PUSH
6082: LD_INT 2
6084: GREATER
6085: IFFALSE 6101
// Say ( Heike , DH-1-spot ) else
6087: LD_EXP 20
6091: PPUSH
6092: LD_STRING DH-1-spot
6094: PPUSH
6095: CALL_OW 88
6099: GO 6113
// Say ( Heike , DH-1-spot-d ) ;
6101: LD_EXP 20
6105: PPUSH
6106: LD_STRING DH-1-spot-d
6108: PPUSH
6109: CALL_OW 88
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6113: LD_EXP 20
6117: PPUSH
6118: LD_EXP 24
6122: PPUSH
6123: CALL_OW 250
6127: PPUSH
6128: LD_EXP 24
6132: PPUSH
6133: CALL_OW 251
6137: PPUSH
6138: CALL_OW 111
// for i in [ Kamil , Mike , Givi ] do
6142: LD_ADDR_VAR 0 1
6146: PUSH
6147: LD_EXP 23
6151: PUSH
6152: LD_EXP 22
6156: PUSH
6157: LD_EXP 21
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: LIST
6166: PUSH
6167: FOR_IN
6168: IFFALSE 6207
// if GetDistUnits ( i , Aviradze ) > 7 then
6170: LD_VAR 0 1
6174: PPUSH
6175: LD_EXP 24
6179: PPUSH
6180: CALL_OW 296
6184: PUSH
6185: LD_INT 7
6187: GREATER
6188: IFFALSE 6205
// ComMoveXY ( i , 102 , 40 ) ;
6190: LD_VAR 0 1
6194: PPUSH
6195: LD_INT 102
6197: PPUSH
6198: LD_INT 40
6200: PPUSH
6201: CALL_OW 111
6205: GO 6167
6207: POP
6208: POP
// repeat wait ( 0 0$1 ) ;
6209: LD_INT 35
6211: PPUSH
6212: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 6 ;
6216: LD_EXP 20
6220: PPUSH
6221: LD_EXP 24
6225: PPUSH
6226: CALL_OW 296
6230: PUSH
6231: LD_INT 6
6233: LESS
6234: IFFALSE 6209
// ComTurnUnit ( Heike , Aviradze ) ;
6236: LD_EXP 20
6240: PPUSH
6241: LD_EXP 24
6245: PPUSH
6246: CALL_OW 119
// ComTurnUnit ( [ Aviradze , Sophia , Kaia ] , Heike ) ;
6250: LD_EXP 24
6254: PUSH
6255: LD_EXP 26
6259: PUSH
6260: LD_EXP 25
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: PPUSH
6270: LD_EXP 20
6274: PPUSH
6275: CALL_OW 119
// if pepAmount > 1 then
6279: LD_VAR 0 2
6283: PUSH
6284: LD_INT 1
6286: GREATER
6287: IFFALSE 6339
// begin wait ( 0 0$2 ) ;
6289: LD_INT 70
6291: PPUSH
6292: CALL_OW 67
// ComTurnUnit ( [ Kamil , Mike , Givi ] , Aviradze ) ;
6296: LD_EXP 23
6300: PUSH
6301: LD_EXP 22
6305: PUSH
6306: LD_EXP 21
6310: PUSH
6311: EMPTY
6312: LIST
6313: LIST
6314: LIST
6315: PPUSH
6316: LD_EXP 24
6320: PPUSH
6321: CALL_OW 119
// Say ( Heike , DH-2-spot ) ;
6325: LD_EXP 20
6329: PPUSH
6330: LD_STRING DH-2-spot
6332: PPUSH
6333: CALL_OW 88
// end else
6337: GO 6351
// Say ( Heike , DH-2-spot-d ) ;
6339: LD_EXP 20
6343: PPUSH
6344: LD_STRING DH-2-spot-d
6346: PPUSH
6347: CALL_OW 88
// Say ( Aviradze , DA-2-spot ) ;
6351: LD_EXP 24
6355: PPUSH
6356: LD_STRING DA-2-spot
6358: PPUSH
6359: CALL_OW 88
// Say ( Heike , DH-3-spot ) ;
6363: LD_EXP 20
6367: PPUSH
6368: LD_STRING DH-3-spot
6370: PPUSH
6371: CALL_OW 88
// ComMoveUnit ( Kaia , Heike ) ;
6375: LD_EXP 25
6379: PPUSH
6380: LD_EXP 20
6384: PPUSH
6385: CALL_OW 112
// ComTurnUNit ( Heike , Kaia ) ;
6389: LD_EXP 20
6393: PPUSH
6394: LD_EXP 25
6398: PPUSH
6399: CALL_OW 119
// wait ( 0 0$0.3 ) ;
6403: LD_INT 10
6405: PPUSH
6406: CALL_OW 67
// async ;
6410: ASYNC
// Say ( Kaia , DK-3-spot ) ;
6411: LD_EXP 25
6415: PPUSH
6416: LD_STRING DK-3-spot
6418: PPUSH
6419: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6423: LD_INT 35
6425: PPUSH
6426: CALL_OW 67
// until GetDistUnits ( Heike , Kaia ) < 4 ;
6430: LD_EXP 20
6434: PPUSH
6435: LD_EXP 25
6439: PPUSH
6440: CALL_OW 296
6444: PUSH
6445: LD_INT 4
6447: LESS
6448: IFFALSE 6423
// ComTurnUnit ( Kaia , Heike ) ;
6450: LD_EXP 25
6454: PPUSH
6455: LD_EXP 20
6459: PPUSH
6460: CALL_OW 119
// sync ;
6464: SYNC
// Say ( Heike , DH-4-spot ) ;
6465: LD_EXP 20
6469: PPUSH
6470: LD_STRING DH-4-spot
6472: PPUSH
6473: CALL_OW 88
// wait ( 0 0$0.3 ) ;
6477: LD_INT 10
6479: PPUSH
6480: CALL_OW 67
// ComTurnUnit ( Heike , Aviradze ) ;
6484: LD_EXP 20
6488: PPUSH
6489: LD_EXP 24
6493: PPUSH
6494: CALL_OW 119
// Say ( Aviradze , DA-4-spot ) ;
6498: LD_EXP 24
6502: PPUSH
6503: LD_STRING DA-4-spot
6505: PPUSH
6506: CALL_OW 88
// ComTurnUnit ( Kaia , Aviradze ) ;
6510: LD_EXP 25
6514: PPUSH
6515: LD_EXP 24
6519: PPUSH
6520: CALL_OW 119
// Say ( Kaia , DK-4-spot ) ;
6524: LD_EXP 25
6528: PPUSH
6529: LD_STRING DK-4-spot
6531: PPUSH
6532: CALL_OW 88
// ComTurnUnit ( Aviradze , Kaia ) ;
6536: LD_EXP 24
6540: PPUSH
6541: LD_EXP 25
6545: PPUSH
6546: CALL_OW 119
// Say ( Aviradze , DA-5-spot ) ;
6550: LD_EXP 24
6554: PPUSH
6555: LD_STRING DA-5-spot
6557: PPUSH
6558: CALL_OW 88
// Say ( Kaia , DK-5-spot ) ;
6562: LD_EXP 25
6566: PPUSH
6567: LD_STRING DK-5-spot
6569: PPUSH
6570: CALL_OW 88
// if pepAmount = 1 then
6574: LD_VAR 0 2
6578: PUSH
6579: LD_INT 1
6581: EQUAL
6582: IFFALSE 6596
// Say ( Heike , DH-5-spot-f ) ;
6584: LD_EXP 20
6588: PPUSH
6589: LD_STRING DH-5-spot-f
6591: PPUSH
6592: CALL_OW 88
// if pepAmount < 3 then
6596: LD_VAR 0 2
6600: PUSH
6601: LD_INT 3
6603: LESS
6604: IFFALSE 6620
// Say ( Aviradze , DA-6-spot-f ) else
6606: LD_EXP 24
6610: PPUSH
6611: LD_STRING DA-6-spot-f
6613: PPUSH
6614: CALL_OW 88
6618: GO 6656
// if pepAmount < 4 then
6620: LD_VAR 0 2
6624: PUSH
6625: LD_INT 4
6627: LESS
6628: IFFALSE 6644
// Say ( Aviradze , DA-6-spot-c ) else
6630: LD_EXP 24
6634: PPUSH
6635: LD_STRING DA-6-spot-c
6637: PPUSH
6638: CALL_OW 88
6642: GO 6656
// Say ( Aviradze , DA-6-spot ) ;
6644: LD_EXP 24
6648: PPUSH
6649: LD_STRING DA-6-spot
6651: PPUSH
6652: CALL_OW 88
// if Kamil then
6656: LD_EXP 23
6660: IFFALSE 6674
// Say ( Kamil , DKam-6-spot ) ;
6662: LD_EXP 23
6666: PPUSH
6667: LD_STRING DKam-6-spot
6669: PPUSH
6670: CALL_OW 88
// Say ( Kaia , DK-6-spot ) ;
6674: LD_EXP 25
6678: PPUSH
6679: LD_STRING DK-6-spot
6681: PPUSH
6682: CALL_OW 88
// ComTurnUnit ( Aviradze , Heike ) ;
6686: LD_EXP 24
6690: PPUSH
6691: LD_EXP 20
6695: PPUSH
6696: CALL_OW 119
// Say ( Aviradze , DA-7-spot ) ;
6700: LD_EXP 24
6704: PPUSH
6705: LD_STRING DA-7-spot
6707: PPUSH
6708: CALL_OW 88
// Say ( Heike , DH-7-spot ) ;
6712: LD_EXP 20
6716: PPUSH
6717: LD_STRING DH-7-spot
6719: PPUSH
6720: CALL_OW 88
// if sciCounterKill >= 3 then
6724: LD_EXP 8
6728: PUSH
6729: LD_INT 3
6731: GREATEREQUAL
6732: IFFALSE 6758
// begin Say ( Heike , DH-7-spot-a ) ;
6734: LD_EXP 20
6738: PPUSH
6739: LD_STRING DH-7-spot-a
6741: PPUSH
6742: CALL_OW 88
// Say ( Aviradze , DA-8-spot-a ) ;
6746: LD_EXP 24
6750: PPUSH
6751: LD_STRING DA-8-spot-a
6753: PPUSH
6754: CALL_OW 88
// end ; InGameOff ;
6758: CALL_OW 9
// if sciCounterKill < 3 then
6762: LD_EXP 8
6766: PUSH
6767: LD_INT 3
6769: LESS
6770: IFFALSE 6802
// begin SetSide ( Kaia , 2 ) ;
6772: LD_EXP 25
6776: PPUSH
6777: LD_INT 2
6779: PPUSH
6780: CALL_OW 235
// ComFree ( Kaia ) ;
6784: LD_EXP 25
6788: PPUSH
6789: CALL_OW 139
// ChangeMissionObjectives ( OSci ) ;
6793: LD_STRING OSci
6795: PPUSH
6796: CALL_OW 337
// end else
6800: GO 6864
// begin aviradzeQuestDone := true ;
6802: LD_ADDR_EXP 7
6806: PUSH
6807: LD_INT 1
6809: ST_TO_ADDR
// attackDeltaAllowed := true ;
6810: LD_ADDR_EXP 12
6814: PUSH
6815: LD_INT 1
6817: ST_TO_ADDR
// ChangeMissionObjectives ( ODelta2 ) ;
6818: LD_STRING ODelta2
6820: PPUSH
6821: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
6825: LD_ADDR_VAR 0 1
6829: PUSH
6830: LD_INT 22
6832: PUSH
6833: LD_INT 5
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 69
6844: PUSH
6845: FOR_IN
6846: IFFALSE 6862
// SetSide ( i , 2 ) ;
6848: LD_VAR 0 1
6852: PPUSH
6853: LD_INT 2
6855: PPUSH
6856: CALL_OW 235
6860: GO 6845
6862: POP
6863: POP
// end ; end ;
6864: PPOPN 2
6866: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and not aviradzeSpotted do
6867: LD_EXP 6
6871: NOT
6872: PUSH
6873: LD_EXP 19
6877: PPUSH
6878: LD_EXP 20
6882: PPUSH
6883: CALL_OW 74
6887: PPUSH
6888: LD_EXP 20
6892: PPUSH
6893: CALL_OW 296
6897: PUSH
6898: LD_INT 8
6900: LESS
6901: AND
6902: PUSH
6903: LD_INT 2
6905: PPUSH
6906: LD_EXP 19
6910: PPUSH
6911: LD_EXP 20
6915: PPUSH
6916: CALL_OW 74
6920: PPUSH
6921: CALL_OW 292
6925: AND
6926: PUSH
6927: LD_INT 22
6929: PUSH
6930: LD_INT 2
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: PUSH
6937: LD_INT 21
6939: PUSH
6940: LD_INT 1
6942: PUSH
6943: EMPTY
6944: LIST
6945: LIST
6946: PUSH
6947: EMPTY
6948: LIST
6949: LIST
6950: PPUSH
6951: CALL_OW 69
6955: PUSH
6956: LD_INT 1
6958: GREATER
6959: AND
6960: PUSH
6961: LD_EXP 4
6965: NOT
6966: AND
6967: IFFALSE 7011
6969: GO 6971
6971: DISABLE
// begin sciSpotted := true ;
6972: LD_ADDR_EXP 6
6976: PUSH
6977: LD_INT 1
6979: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
6980: LD_EXP 19
6984: PPUSH
6985: LD_EXP 20
6989: PPUSH
6990: CALL_OW 74
6994: PPUSH
6995: CALL_OW 87
// Say ( Heike , DH-1-sci ) ;
6999: LD_EXP 20
7003: PPUSH
7004: LD_STRING DH-1-sci
7006: PPUSH
7007: CALL_OW 88
// end ;
7011: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and aviradzeSpotted and not aviradzeQuestDone do
7012: LD_EXP 6
7016: NOT
7017: PUSH
7018: LD_EXP 19
7022: PPUSH
7023: LD_EXP 20
7027: PPUSH
7028: CALL_OW 74
7032: PPUSH
7033: LD_EXP 20
7037: PPUSH
7038: CALL_OW 296
7042: PUSH
7043: LD_INT 8
7045: LESS
7046: AND
7047: PUSH
7048: LD_INT 2
7050: PPUSH
7051: LD_EXP 19
7055: PPUSH
7056: LD_EXP 20
7060: PPUSH
7061: CALL_OW 74
7065: PPUSH
7066: CALL_OW 292
7070: AND
7071: PUSH
7072: LD_INT 22
7074: PUSH
7075: LD_INT 2
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: LD_INT 21
7084: PUSH
7085: LD_INT 1
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PPUSH
7096: CALL_OW 69
7100: PUSH
7101: LD_INT 1
7103: GREATER
7104: AND
7105: PUSH
7106: LD_EXP 4
7110: AND
7111: PUSH
7112: LD_EXP 7
7116: NOT
7117: AND
7118: IFFALSE 7180
7120: GO 7122
7122: DISABLE
// begin sciSpotted := true ;
7123: LD_ADDR_EXP 6
7127: PUSH
7128: LD_INT 1
7130: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7131: LD_EXP 19
7135: PPUSH
7136: LD_EXP 20
7140: PPUSH
7141: CALL_OW 74
7145: PPUSH
7146: CALL_OW 87
// Say ( Heike , DH-1-sci-a ) ;
7150: LD_EXP 20
7154: PPUSH
7155: LD_STRING DH-1-sci-a
7157: PPUSH
7158: CALL_OW 88
// if Mike then
7162: LD_EXP 22
7166: IFFALSE 7180
// Say ( Mike , DM-1-sci-a ) ;
7168: LD_EXP 22
7172: PPUSH
7173: LD_STRING DM-1-sci-a
7175: PPUSH
7176: CALL_OW 88
// end ;
7180: END
// every 0 0$1 trigger aviradzeSpotted and sciCounterKill >= 3 and not aviradzeQuestDone do
7181: LD_EXP 4
7185: PUSH
7186: LD_EXP 8
7190: PUSH
7191: LD_INT 3
7193: GREATEREQUAL
7194: AND
7195: PUSH
7196: LD_EXP 7
7200: NOT
7201: AND
7202: IFFALSE 7245
7204: GO 7206
7206: DISABLE
// begin aviradzeQuestDone := true ;
7207: LD_ADDR_EXP 7
7211: PUSH
7212: LD_INT 1
7214: ST_TO_ADDR
// Say ( Heike , DH-1-quest-done ) ;
7215: LD_EXP 20
7219: PPUSH
7220: LD_STRING DH-1-quest-done
7222: PPUSH
7223: CALL_OW 88
// if Givi then
7227: LD_EXP 21
7231: IFFALSE 7245
// Say ( Givi , DG-1-quest-done ) ;
7233: LD_EXP 21
7237: PPUSH
7238: LD_STRING DG-1-quest-done
7240: PPUSH
7241: CALL_OW 88
// end ;
7245: END
// every 0 0$1 trigger See ( 5 , Heike ) and GetDistUnits ( Heike , Aviradze ) < 6 and aviradzeQuestDone and not attackDeltaAllowed do var i ;
7246: LD_INT 5
7248: PPUSH
7249: LD_EXP 20
7253: PPUSH
7254: CALL_OW 292
7258: PUSH
7259: LD_EXP 20
7263: PPUSH
7264: LD_EXP 24
7268: PPUSH
7269: CALL_OW 296
7273: PUSH
7274: LD_INT 6
7276: LESS
7277: AND
7278: PUSH
7279: LD_EXP 7
7283: AND
7284: PUSH
7285: LD_EXP 12
7289: NOT
7290: AND
7291: IFFALSE 7429
7293: GO 7295
7295: DISABLE
7296: LD_INT 0
7298: PPUSH
// begin attackDeltaAllowed := true ;
7299: LD_ADDR_EXP 12
7303: PUSH
7304: LD_INT 1
7306: ST_TO_ADDR
// InGameOn ;
7307: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
7311: LD_EXP 20
7315: PPUSH
7316: CALL_OW 87
// wait ( 0 0$0.3 ) ;
7320: LD_INT 10
7322: PPUSH
7323: CALL_OW 67
// ComTurnUnit ( Aviradze , Heike ) ;
7327: LD_EXP 24
7331: PPUSH
7332: LD_EXP 20
7336: PPUSH
7337: CALL_OW 119
// ComTurnUnit ( Heike , Aviradze ) ;
7341: LD_EXP 20
7345: PPUSH
7346: LD_EXP 24
7350: PPUSH
7351: CALL_OW 119
// Say ( Heike , DH-1-return ) ;
7355: LD_EXP 20
7359: PPUSH
7360: LD_STRING DH-1-return
7362: PPUSH
7363: CALL_OW 88
// Say ( Aviradze , DA-1-return ) ;
7367: LD_EXP 24
7371: PPUSH
7372: LD_STRING DA-1-return
7374: PPUSH
7375: CALL_OW 88
// InGameOff ;
7379: CALL_OW 9
// ChangeMissionObjectives ( ODelta ) ;
7383: LD_STRING ODelta
7385: PPUSH
7386: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7390: LD_ADDR_VAR 0 1
7394: PUSH
7395: LD_INT 22
7397: PUSH
7398: LD_INT 5
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PPUSH
7405: CALL_OW 69
7409: PUSH
7410: FOR_IN
7411: IFFALSE 7427
// SetSide ( i , 2 ) ;
7413: LD_VAR 0 1
7417: PPUSH
7418: LD_INT 2
7420: PPUSH
7421: CALL_OW 235
7425: GO 7410
7427: POP
7428: POP
// end ;
7429: PPOPN 1
7431: END
// every 0 0$1 trigger attackDeltaAllowed and IsOk ( Markov ) and GetSide ( Delta ) = 1 and IsOk ( Lynch ) and not usAlert do var i , k , tmp ;
7432: LD_EXP 12
7436: PUSH
7437: LD_EXP 27
7441: PPUSH
7442: CALL_OW 302
7446: AND
7447: PUSH
7448: LD_INT 1
7450: PPUSH
7451: CALL_OW 255
7455: PUSH
7456: LD_INT 1
7458: EQUAL
7459: AND
7460: PUSH
7461: LD_EXP 17
7465: PPUSH
7466: CALL_OW 302
7470: AND
7471: PUSH
7472: LD_EXP 9
7476: NOT
7477: AND
7478: IFFALSE 8648
7480: GO 7482
7482: DISABLE
7483: LD_INT 0
7485: PPUSH
7486: PPUSH
7487: PPUSH
// begin trap := 0 ;
7488: LD_ADDR_EXP 15
7492: PUSH
7493: LD_INT 0
7495: ST_TO_ADDR
// wait ( 0 0$15 ) ;
7496: LD_INT 525
7498: PPUSH
7499: CALL_OW 67
// DialogueOn ;
7503: CALL_OW 6
// Say ( Markov , DMar-1-radio ) ;
7507: LD_EXP 27
7511: PPUSH
7512: LD_STRING DMar-1-radio
7514: PPUSH
7515: CALL_OW 88
// Say ( Heike , DH-1-radio ) ;
7519: LD_EXP 20
7523: PPUSH
7524: LD_STRING DH-1-radio
7526: PPUSH
7527: CALL_OW 88
// Say ( Markov , DMar-2-radio ) ;
7531: LD_EXP 27
7535: PPUSH
7536: LD_STRING DMar-2-radio
7538: PPUSH
7539: CALL_OW 88
// Say ( Heike , DH-2-radio ) ;
7543: LD_EXP 20
7547: PPUSH
7548: LD_STRING DH-2-radio
7550: PPUSH
7551: CALL_OW 88
// if IsOk ( Kamil ) or IsOk ( Sophia ) then
7555: LD_EXP 23
7559: PPUSH
7560: CALL_OW 302
7564: PUSH
7565: LD_EXP 26
7569: PPUSH
7570: CALL_OW 302
7574: OR
7575: IFFALSE 8648
// begin case Query ( Q1Trap ) of 1 :
7577: LD_STRING Q1Trap
7579: PPUSH
7580: CALL_OW 97
7584: PUSH
7585: LD_INT 1
7587: DOUBLE
7588: EQUAL
7589: IFTRUE 7593
7591: GO 7787
7593: POP
// begin if IsOk ( Kamil ) then
7594: LD_EXP 23
7598: PPUSH
7599: CALL_OW 302
7603: IFFALSE 7682
// begin Say ( Kamil , DKam-2-radio ) ;
7605: LD_EXP 23
7609: PPUSH
7610: LD_STRING DKam-2-radio
7612: PPUSH
7613: CALL_OW 88
// Say ( Kamil , DKam-3-radio ) ;
7617: LD_EXP 23
7621: PPUSH
7622: LD_STRING DKam-3-radio
7624: PPUSH
7625: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio ) ;
7629: LD_EXP 17
7633: PPUSH
7634: LD_STRING DDelta-3-radio
7636: PPUSH
7637: CALL_OW 94
// dwait ( 0 0$01 ) ;
7641: LD_INT 35
7643: PPUSH
7644: CALL_OW 68
// Say ( Heike , DH-3-radio ) ;
7648: LD_EXP 20
7652: PPUSH
7653: LD_STRING DH-3-radio
7655: PPUSH
7656: CALL_OW 88
// Say ( Kamil , DKam-4-radio ) ;
7660: LD_EXP 23
7664: PPUSH
7665: LD_STRING DKam-4-radio
7667: PPUSH
7668: CALL_OW 88
// trap := 1 ;
7672: LD_ADDR_EXP 15
7676: PUSH
7677: LD_INT 1
7679: ST_TO_ADDR
// end else
7680: GO 7781
// begin Say ( Sophia , DS-1-radio ) ;
7682: LD_EXP 26
7686: PPUSH
7687: LD_STRING DS-1-radio
7689: PPUSH
7690: CALL_OW 88
// Say ( Sophia , DS-2-radio ) ;
7694: LD_EXP 26
7698: PPUSH
7699: LD_STRING DS-2-radio
7701: PPUSH
7702: CALL_OW 88
// SayRadio ( Lynch , DDelta-2-radio-s ) ;
7706: LD_EXP 17
7710: PPUSH
7711: LD_STRING DDelta-2-radio-s
7713: PPUSH
7714: CALL_OW 94
// Say ( Sophia , DS-3-radio ) ;
7718: LD_EXP 26
7722: PPUSH
7723: LD_STRING DS-3-radio
7725: PPUSH
7726: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio-s ) ;
7730: LD_EXP 17
7734: PPUSH
7735: LD_STRING DDelta-3-radio-s
7737: PPUSH
7738: CALL_OW 94
// Say ( Sophia , DS-4-radio-s ) ;
7742: LD_EXP 26
7746: PPUSH
7747: LD_STRING DS-4-radio-s
7749: PPUSH
7750: CALL_OW 88
// dwait ( 0 0$01 ) ;
7754: LD_INT 35
7756: PPUSH
7757: CALL_OW 68
// Say ( Heike , DH-1-trap ) ;
7761: LD_EXP 20
7765: PPUSH
7766: LD_STRING DH-1-trap
7768: PPUSH
7769: CALL_OW 88
// trap := 0 ;
7773: LD_ADDR_EXP 15
7777: PUSH
7778: LD_INT 0
7780: ST_TO_ADDR
// end ; DialogueOff ;
7781: CALL_OW 7
// end ; 2 :
7785: GO 7805
7787: LD_INT 2
7789: DOUBLE
7790: EQUAL
7791: IFTRUE 7795
7793: GO 7804
7795: POP
// begin DialogueOff ;
7796: CALL_OW 7
// exit ;
7800: GO 8648
// end ; end ;
7802: GO 7805
7804: POP
// if trap = 1 then
7805: LD_EXP 15
7809: PUSH
7810: LD_INT 1
7812: EQUAL
7813: IFFALSE 8219
// begin tmp := [ ] ;
7815: LD_ADDR_VAR 0 3
7819: PUSH
7820: EMPTY
7821: ST_TO_ADDR
// k := 3 ;
7822: LD_ADDR_VAR 0 2
7826: PUSH
7827: LD_INT 3
7829: ST_TO_ADDR
// if usForces < 3 then
7830: LD_EXP 18
7834: PUSH
7835: LD_INT 3
7837: LESS
7838: IFFALSE 7850
// k := usForces ;
7840: LD_ADDR_VAR 0 2
7844: PUSH
7845: LD_EXP 18
7849: ST_TO_ADDR
// for i := 1 to k do
7850: LD_ADDR_VAR 0 1
7854: PUSH
7855: DOUBLE
7856: LD_INT 1
7858: DEC
7859: ST_TO_ADDR
7860: LD_VAR 0 2
7864: PUSH
7865: FOR_TO
7866: IFFALSE 7921
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
7868: LD_ADDR_VAR 0 3
7872: PUSH
7873: LD_VAR 0 3
7877: PPUSH
7878: LD_VAR 0 3
7882: PUSH
7883: LD_INT 1
7885: PLUS
7886: PPUSH
7887: LD_EXP 18
7891: PUSH
7892: LD_INT 1
7894: ARRAY
7895: PPUSH
7896: CALL_OW 1
7900: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
7901: LD_ADDR_EXP 18
7905: PUSH
7906: LD_EXP 18
7910: PPUSH
7911: LD_INT 1
7913: PPUSH
7914: CALL_OW 3
7918: ST_TO_ADDR
// end ;
7919: GO 7865
7921: POP
7922: POP
// usPatrol := tmp ;
7923: LD_ADDR_EXP 14
7927: PUSH
7928: LD_VAR 0 3
7932: ST_TO_ADDR
// for i in tmp do
7933: LD_ADDR_VAR 0 1
7937: PUSH
7938: LD_VAR 0 3
7942: PUSH
7943: FOR_IN
7944: IFFALSE 8074
// begin if IsInUnit ( i ) then
7946: LD_VAR 0 1
7950: PPUSH
7951: CALL_OW 310
7955: IFFALSE 7966
// ComExitBuilding ( i ) ;
7957: LD_VAR 0 1
7961: PPUSH
7962: CALL_OW 122
// AddComAgressiveMove ( i , 63 , 31 ) ;
7966: LD_VAR 0 1
7970: PPUSH
7971: LD_INT 63
7973: PPUSH
7974: LD_INT 31
7976: PPUSH
7977: CALL_OW 174
// AddComWait ( i , 0 0$2 ) ;
7981: LD_VAR 0 1
7985: PPUSH
7986: LD_INT 70
7988: PPUSH
7989: CALL_OW 202
// AddComAgressiveMove ( i , 103 , 43 ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_INT 103
8000: PPUSH
8001: LD_INT 43
8003: PPUSH
8004: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8008: LD_VAR 0 1
8012: PPUSH
8013: LD_INT 105
8015: PPUSH
8016: CALL_OW 202
// if Difficulty > 1 then
8020: LD_OWVAR 67
8024: PUSH
8025: LD_INT 1
8027: GREATER
8028: IFFALSE 8045
// AddComAgressiveMove ( i , 114 , 69 ) ;
8030: LD_VAR 0 1
8034: PPUSH
8035: LD_INT 114
8037: PPUSH
8038: LD_INT 69
8040: PPUSH
8041: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8045: LD_VAR 0 1
8049: PPUSH
8050: LD_INT 105
8052: PPUSH
8053: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8057: LD_VAR 0 1
8061: PPUSH
8062: LD_INT 42
8064: PPUSH
8065: LD_INT 20
8067: PPUSH
8068: CALL_OW 174
// end ;
8072: GO 7943
8074: POP
8075: POP
// repeat wait ( 0 0$1 ) ;
8076: LD_INT 35
8078: PPUSH
8079: CALL_OW 67
// for i in tmp do
8083: LD_ADDR_VAR 0 1
8087: PUSH
8088: LD_VAR 0 3
8092: PUSH
8093: FOR_IN
8094: IFFALSE 8125
// if IsDead ( i ) then
8096: LD_VAR 0 1
8100: PPUSH
8101: CALL_OW 301
8105: IFFALSE 8123
// tmp := tmp diff i ;
8107: LD_ADDR_VAR 0 3
8111: PUSH
8112: LD_VAR 0 3
8116: PUSH
8117: LD_VAR 0 1
8121: DIFF
8122: ST_TO_ADDR
8123: GO 8093
8125: POP
8126: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8127: LD_VAR 0 3
8131: NOT
8132: PUSH
8133: LD_VAR 0 3
8137: PPUSH
8138: LD_INT 95
8140: PUSH
8141: LD_INT 7
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: LD_INT 3
8150: PUSH
8151: LD_INT 60
8153: PUSH
8154: EMPTY
8155: LIST
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PPUSH
8165: CALL_OW 72
8169: PUSH
8170: LD_VAR 0 3
8174: EQUAL
8175: OR
8176: IFFALSE 8076
// if tmp then
8178: LD_VAR 0 3
8182: IFFALSE 8209
// begin usPatrol := [ ] ;
8184: LD_ADDR_EXP 14
8188: PUSH
8189: EMPTY
8190: ST_TO_ADDR
// usForces := usForces union tmp ;
8191: LD_ADDR_EXP 18
8195: PUSH
8196: LD_EXP 18
8200: PUSH
8201: LD_VAR 0 3
8205: UNION
8206: ST_TO_ADDR
// end else
8207: GO 8217
// trickyMove := true ;
8209: LD_ADDR_EXP 13
8213: PUSH
8214: LD_INT 1
8216: ST_TO_ADDR
// end else
8217: GO 8648
// begin tmp := [ ] ;
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: EMPTY
8225: ST_TO_ADDR
// k := 4 ;
8226: LD_ADDR_VAR 0 2
8230: PUSH
8231: LD_INT 4
8233: ST_TO_ADDR
// if usForces < 4 then
8234: LD_EXP 18
8238: PUSH
8239: LD_INT 4
8241: LESS
8242: IFFALSE 8254
// k := usForces ;
8244: LD_ADDR_VAR 0 2
8248: PUSH
8249: LD_EXP 18
8253: ST_TO_ADDR
// for i := 1 to k do
8254: LD_ADDR_VAR 0 1
8258: PUSH
8259: DOUBLE
8260: LD_INT 1
8262: DEC
8263: ST_TO_ADDR
8264: LD_VAR 0 2
8268: PUSH
8269: FOR_TO
8270: IFFALSE 8325
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8272: LD_ADDR_VAR 0 3
8276: PUSH
8277: LD_VAR 0 3
8281: PPUSH
8282: LD_VAR 0 3
8286: PUSH
8287: LD_INT 1
8289: PLUS
8290: PPUSH
8291: LD_EXP 18
8295: PUSH
8296: LD_INT 1
8298: ARRAY
8299: PPUSH
8300: CALL_OW 1
8304: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8305: LD_ADDR_EXP 18
8309: PUSH
8310: LD_EXP 18
8314: PPUSH
8315: LD_INT 1
8317: PPUSH
8318: CALL_OW 3
8322: ST_TO_ADDR
// end ;
8323: GO 8269
8325: POP
8326: POP
// if Lynch then
8327: LD_EXP 17
8331: IFFALSE 8349
// tmp := tmp ^ Lynch ;
8333: LD_ADDR_VAR 0 3
8337: PUSH
8338: LD_VAR 0 3
8342: PUSH
8343: LD_EXP 17
8347: ADD
8348: ST_TO_ADDR
// usPatrol := tmp ;
8349: LD_ADDR_EXP 14
8353: PUSH
8354: LD_VAR 0 3
8358: ST_TO_ADDR
// for i in tmp do
8359: LD_ADDR_VAR 0 1
8363: PUSH
8364: LD_VAR 0 3
8368: PUSH
8369: FOR_IN
8370: IFFALSE 8463
// begin if IsInUnit ( i ) then
8372: LD_VAR 0 1
8376: PPUSH
8377: CALL_OW 310
8381: IFFALSE 8392
// ComExitBuilding ( i ) ;
8383: LD_VAR 0 1
8387: PPUSH
8388: CALL_OW 122
// AddComAgressiveMove ( i , 69 , 15 ) ;
8392: LD_VAR 0 1
8396: PPUSH
8397: LD_INT 69
8399: PPUSH
8400: LD_INT 15
8402: PPUSH
8403: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8407: LD_VAR 0 1
8411: PPUSH
8412: LD_INT 700
8414: PPUSH
8415: CALL_OW 202
// AddComAgressiveMove ( i , 55 , 43 ) ;
8419: LD_VAR 0 1
8423: PPUSH
8424: LD_INT 55
8426: PPUSH
8427: LD_INT 43
8429: PPUSH
8430: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8434: LD_VAR 0 1
8438: PPUSH
8439: LD_INT 700
8441: PPUSH
8442: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8446: LD_VAR 0 1
8450: PPUSH
8451: LD_INT 42
8453: PPUSH
8454: LD_INT 20
8456: PPUSH
8457: CALL_OW 174
// end ;
8461: GO 8369
8463: POP
8464: POP
// repeat wait ( 0 0$1 ) ;
8465: LD_INT 35
8467: PPUSH
8468: CALL_OW 67
// for i in tmp do
8472: LD_ADDR_VAR 0 1
8476: PUSH
8477: LD_VAR 0 3
8481: PUSH
8482: FOR_IN
8483: IFFALSE 8514
// if IsDead ( i ) then
8485: LD_VAR 0 1
8489: PPUSH
8490: CALL_OW 301
8494: IFFALSE 8512
// tmp := tmp diff i ;
8496: LD_ADDR_VAR 0 3
8500: PUSH
8501: LD_VAR 0 3
8505: PUSH
8506: LD_VAR 0 1
8510: DIFF
8511: ST_TO_ADDR
8512: GO 8482
8514: POP
8515: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8516: LD_VAR 0 3
8520: NOT
8521: PUSH
8522: LD_VAR 0 3
8526: PPUSH
8527: LD_INT 95
8529: PUSH
8530: LD_INT 7
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: PUSH
8537: LD_INT 3
8539: PUSH
8540: LD_INT 60
8542: PUSH
8543: EMPTY
8544: LIST
8545: PUSH
8546: EMPTY
8547: LIST
8548: LIST
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 72
8558: PUSH
8559: LD_VAR 0 3
8563: EQUAL
8564: OR
8565: IFFALSE 8465
// if not tmp then
8567: LD_VAR 0 3
8571: NOT
8572: IFFALSE 8584
// trickyMove := true else
8574: LD_ADDR_EXP 13
8578: PUSH
8579: LD_INT 1
8581: ST_TO_ADDR
8582: GO 8591
// usPatrol := [ ] ;
8584: LD_ADDR_EXP 14
8588: PUSH
8589: EMPTY
8590: ST_TO_ADDR
// if tmp diff Lynch then
8591: LD_VAR 0 3
8595: PUSH
8596: LD_EXP 17
8600: DIFF
8601: IFFALSE 8625
// usForces := usForces union ( tmp diff Lynch ) ;
8603: LD_ADDR_EXP 18
8607: PUSH
8608: LD_EXP 18
8612: PUSH
8613: LD_VAR 0 3
8617: PUSH
8618: LD_EXP 17
8622: DIFF
8623: UNION
8624: ST_TO_ADDR
// if IsOk ( Lynch ) then
8625: LD_EXP 17
8629: PPUSH
8630: CALL_OW 302
8634: IFFALSE 8648
// ComEnterUnit ( Lynch , Delta ) ;
8636: LD_EXP 17
8640: PPUSH
8641: LD_INT 1
8643: PPUSH
8644: CALL_OW 120
// end ; end ; end ;
8648: PPOPN 3
8650: END
// every 0 0$1 trigger UnitFilter ( usPatrol , [ f_see , 2 ] ) do
8651: LD_EXP 14
8655: PPUSH
8656: LD_INT 101
8658: PUSH
8659: LD_INT 2
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PPUSH
8666: CALL_OW 72
8670: IFFALSE 8803
8672: GO 8674
8674: DISABLE
// begin if not trap then
8675: LD_EXP 15
8679: NOT
8680: IFFALSE 8708
// begin Say ( Heike , DH-2-trap ) ;
8682: LD_EXP 20
8686: PPUSH
8687: LD_STRING DH-2-trap
8689: PPUSH
8690: CALL_OW 88
// Say ( Mike , DM-2-trap ) ;
8694: LD_EXP 22
8698: PPUSH
8699: LD_STRING DM-2-trap
8701: PPUSH
8702: CALL_OW 88
// end else
8706: GO 8720
// begin Say ( Heike , DH-1-trap-a ) ;
8708: LD_EXP 20
8712: PPUSH
8713: LD_STRING DH-1-trap-a
8715: PPUSH
8716: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
8720: LD_INT 35
8722: PPUSH
8723: CALL_OW 67
// until trickyMove ;
8727: LD_EXP 13
8731: IFFALSE 8720
// Say ( Heike , DH-3-trap ) ;
8733: LD_EXP 20
8737: PPUSH
8738: LD_STRING DH-3-trap
8740: PPUSH
8741: CALL_OW 88
// if IsOk ( Givi ) and IsOk ( Kaia ) then
8745: LD_EXP 21
8749: PPUSH
8750: CALL_OW 302
8754: PUSH
8755: LD_EXP 25
8759: PPUSH
8760: CALL_OW 302
8764: AND
8765: IFFALSE 8803
// begin Say ( Givi , DG-3-trap ) ;
8767: LD_EXP 21
8771: PPUSH
8772: LD_STRING DG-3-trap
8774: PPUSH
8775: CALL_OW 88
// Say ( Kaia , DK-3-trap ) ;
8779: LD_EXP 25
8783: PPUSH
8784: LD_STRING DK-3-trap
8786: PPUSH
8787: CALL_OW 88
// Say ( Givi , DG-4-trap ) ;
8791: LD_EXP 21
8795: PPUSH
8796: LD_STRING DG-4-trap
8798: PPUSH
8799: CALL_OW 88
// end ; end ;
8803: END
// every 0 0$1 trigger GetSide ( Delta ) = 2 do
8804: LD_INT 1
8806: PPUSH
8807: CALL_OW 255
8811: PUSH
8812: LD_INT 2
8814: EQUAL
8815: IFFALSE 8858
8817: GO 8819
8819: DISABLE
// begin if not IsOk ( Kaia ) then
8820: LD_EXP 25
8824: PPUSH
8825: CALL_OW 302
8829: NOT
8830: IFFALSE 8834
// exit ;
8832: GO 8858
// Say ( Kaia , DK-1-capture ) ;
8834: LD_EXP 25
8838: PPUSH
8839: LD_STRING DK-1-capture
8841: PPUSH
8842: CALL_OW 88
// Say ( Heike , DH-1-capture ) ;
8846: LD_EXP 20
8850: PPUSH
8851: LD_STRING DH-1-capture
8853: PPUSH
8854: CALL_OW 88
// end ;
8858: END
// every 0 0$1 trigger GetSide ( usLab ) = 2 do
8859: LD_INT 3
8861: PPUSH
8862: CALL_OW 255
8866: PUSH
8867: LD_INT 2
8869: EQUAL
8870: IFFALSE 8902
8872: GO 8874
8874: DISABLE
// begin DialogueOn ;
8875: CALL_OW 6
// Say ( Aviradze , DA-1-capture ) ;
8879: LD_EXP 24
8883: PPUSH
8884: LD_STRING DA-1-capture
8886: PPUSH
8887: CALL_OW 88
// DialogueOff ;
8891: CALL_OW 7
// ChangeMissionObjectives ( OTame ) ;
8895: LD_STRING OTame
8897: PPUSH
8898: CALL_OW 337
// end ;
8902: END
// every 0 0$1 trigger GetTech ( tech_ApeLang , 2 ) = state_researched do
8903: LD_INT 1
8905: PPUSH
8906: LD_INT 2
8908: PPUSH
8909: CALL_OW 321
8913: PUSH
8914: LD_INT 2
8916: EQUAL
8917: IFFALSE 8990
8919: GO 8921
8921: DISABLE
// begin DialogueOn ;
8922: CALL_OW 6
// Say ( Aviradze , DA-1-ape ) ;
8926: LD_EXP 24
8930: PPUSH
8931: LD_STRING DA-1-ape
8933: PPUSH
8934: CALL_OW 88
// Say ( Heike , DH-1-ape ) ;
8938: LD_EXP 20
8942: PPUSH
8943: LD_STRING DH-1-ape
8945: PPUSH
8946: CALL_OW 88
// Say ( Aviradze , DA-2-ape ) ;
8950: LD_EXP 24
8954: PPUSH
8955: LD_STRING DA-2-ape
8957: PPUSH
8958: CALL_OW 88
// Say ( Aviradze , DA-3-ape ) ;
8962: LD_EXP 24
8966: PPUSH
8967: LD_STRING DA-3-ape
8969: PPUSH
8970: CALL_OW 88
// Say ( Heike , DH-3-ape ) ;
8974: LD_EXP 20
8978: PPUSH
8979: LD_STRING DH-3-ape
8981: PPUSH
8982: CALL_OW 88
// DialogueOff ;
8986: CALL_OW 7
// end ;
8990: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) do var tmp ;
8991: LD_INT 22
8993: PUSH
8994: LD_INT 2
8996: PUSH
8997: EMPTY
8998: LIST
8999: LIST
9000: PUSH
9001: LD_INT 23
9003: PUSH
9004: LD_INT 0
9006: PUSH
9007: EMPTY
9008: LIST
9009: LIST
9010: PUSH
9011: EMPTY
9012: LIST
9013: LIST
9014: PPUSH
9015: CALL_OW 69
9019: IFFALSE 9769
9021: GO 9023
9023: DISABLE
9024: LD_INT 0
9026: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) [ 1 ] ;
9027: LD_ADDR_VAR 0 1
9031: PUSH
9032: LD_INT 22
9034: PUSH
9035: LD_INT 2
9037: PUSH
9038: EMPTY
9039: LIST
9040: LIST
9041: PUSH
9042: LD_INT 23
9044: PUSH
9045: LD_INT 0
9047: PUSH
9048: EMPTY
9049: LIST
9050: LIST
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: PPUSH
9056: CALL_OW 69
9060: PUSH
9061: LD_INT 1
9063: ARRAY
9064: ST_TO_ADDR
// InGameOn ;
9065: CALL_OW 8
// CenterNowOnUnits ( tmp ) ;
9069: LD_VAR 0 1
9073: PPUSH
9074: CALL_OW 87
// ComMoveUnit ( tmp , Aviradze ) ;
9078: LD_VAR 0 1
9082: PPUSH
9083: LD_EXP 24
9087: PPUSH
9088: CALL_OW 112
// ComTurnUnit ( Aviradze , tmp ) ;
9092: LD_EXP 24
9096: PPUSH
9097: LD_VAR 0 1
9101: PPUSH
9102: CALL_OW 119
// wait ( 0 0$1 ) ;
9106: LD_INT 35
9108: PPUSH
9109: CALL_OW 67
// Say ( Aviradze , DA-1-tame-a ) ;
9113: LD_EXP 24
9117: PPUSH
9118: LD_STRING DA-1-tame-a
9120: PPUSH
9121: CALL_OW 88
// if IsOk ( Mike ) then
9125: LD_EXP 22
9129: PPUSH
9130: CALL_OW 302
9134: IFFALSE 9172
// begin Say ( Mike , DM-1-tame-a ) ;
9136: LD_EXP 22
9140: PPUSH
9141: LD_STRING DM-1-tame-a
9143: PPUSH
9144: CALL_OW 88
// Say ( Sophia , DS-1-tame-a ) ;
9148: LD_EXP 26
9152: PPUSH
9153: LD_STRING DS-1-tame-a
9155: PPUSH
9156: CALL_OW 88
// Say ( Mike , DM-2-tame-a ) ;
9160: LD_EXP 22
9164: PPUSH
9165: LD_STRING DM-2-tame-a
9167: PPUSH
9168: CALL_OW 88
// end ; wait ( 0 0$3 ) ;
9172: LD_INT 105
9174: PPUSH
9175: CALL_OW 67
// PrepareFarmer ;
9179: CALL 10428 0 0
// CenterOnUnits ( Farmer ) ;
9183: LD_EXP 28
9187: PPUSH
9188: CALL_OW 85
// ComMoveXY ( Farmer , 105 , 59 ) ;
9192: LD_EXP 28
9196: PPUSH
9197: LD_INT 105
9199: PPUSH
9200: LD_INT 59
9202: PPUSH
9203: CALL_OW 111
// AddComHold ( Farmer ) ;
9207: LD_EXP 28
9211: PPUSH
9212: CALL_OW 200
// SayRadio ( Farmer , DF-1-end ) ;
9216: LD_EXP 28
9220: PPUSH
9221: LD_STRING DF-1-end
9223: PPUSH
9224: CALL_OW 94
// Say ( Aviradze , DA-1-end ) ;
9228: LD_EXP 24
9232: PPUSH
9233: LD_STRING DA-1-end
9235: PPUSH
9236: CALL_OW 88
// SayRadio ( Farmer , DF-2-end ) ;
9240: LD_EXP 28
9244: PPUSH
9245: LD_STRING DF-2-end
9247: PPUSH
9248: CALL_OW 94
// Say ( Aviradze , DA-2-end ) ;
9252: LD_EXP 24
9256: PPUSH
9257: LD_STRING DA-2-end
9259: PPUSH
9260: CALL_OW 88
// SayRadio ( Farmer , DF-3-end ) ;
9264: LD_EXP 28
9268: PPUSH
9269: LD_STRING DF-3-end
9271: PPUSH
9272: CALL_OW 94
// Say ( Heike , DH-3-end ) ;
9276: LD_EXP 20
9280: PPUSH
9281: LD_STRING DH-3-end
9283: PPUSH
9284: CALL_OW 88
// SayRadio ( Farmer , DF-4-end ) ;
9288: LD_EXP 28
9292: PPUSH
9293: LD_STRING DF-4-end
9295: PPUSH
9296: CALL_OW 94
// if tick <= [ 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] then
9300: LD_OWVAR 1
9304: PUSH
9305: LD_INT 42000
9307: PUSH
9308: LD_INT 31500
9310: PUSH
9311: LD_INT 21000
9313: PUSH
9314: EMPTY
9315: LIST
9316: LIST
9317: LIST
9318: PUSH
9319: LD_OWVAR 67
9323: ARRAY
9324: LESSEQUAL
9325: IFFALSE 9339
// AddMedal ( med1 , 1 ) else
9327: LD_STRING med1
9329: PPUSH
9330: LD_INT 1
9332: PPUSH
9333: CALL_OW 101
9337: GO 9350
// AddMedal ( med1 , - 1 ) ;
9339: LD_STRING med1
9341: PPUSH
9342: LD_INT 1
9344: NEG
9345: PPUSH
9346: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) = 0 then
9350: LD_INT 22
9352: PUSH
9353: LD_INT 1
9355: PUSH
9356: EMPTY
9357: LIST
9358: LIST
9359: PUSH
9360: LD_INT 25
9362: PUSH
9363: LD_INT 4
9365: PUSH
9366: EMPTY
9367: LIST
9368: LIST
9369: PUSH
9370: EMPTY
9371: LIST
9372: LIST
9373: PPUSH
9374: CALL_OW 69
9378: PUSH
9379: LD_INT 0
9381: EQUAL
9382: IFFALSE 9396
// AddMedal ( med2 , 1 ) else
9384: LD_STRING med2
9386: PPUSH
9387: LD_INT 1
9389: PPUSH
9390: CALL_OW 101
9394: GO 9407
// AddMedal ( med2 , - 1 ) ;
9396: LD_STRING med2
9398: PPUSH
9399: LD_INT 1
9401: NEG
9402: PPUSH
9403: CALL_OW 101
// if trickyMove then
9407: LD_EXP 13
9411: IFFALSE 9425
// AddMedal ( med3 , 1 ) else
9413: LD_STRING med3
9415: PPUSH
9416: LD_INT 1
9418: PPUSH
9419: CALL_OW 101
9423: GO 9436
// AddMedal ( med3 , - 1 ) ;
9425: LD_STRING med3
9427: PPUSH
9428: LD_INT 1
9430: NEG
9431: PPUSH
9432: CALL_OW 101
// GiveMedals ( MAIN ) ;
9436: LD_STRING MAIN
9438: PPUSH
9439: CALL_OW 102
// SaveCharacters ( tmp , 02_ape ) ;
9443: LD_VAR 0 1
9447: PPUSH
9448: LD_STRING 02_ape
9450: PPUSH
9451: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ;
9455: LD_ADDR_VAR 0 1
9459: PUSH
9460: LD_INT 22
9462: PUSH
9463: LD_INT 2
9465: PUSH
9466: EMPTY
9467: LIST
9468: LIST
9469: PUSH
9470: LD_INT 23
9472: PUSH
9473: LD_INT 2
9475: PUSH
9476: EMPTY
9477: LIST
9478: LIST
9479: PUSH
9480: LD_INT 21
9482: PUSH
9483: LD_INT 1
9485: PUSH
9486: EMPTY
9487: LIST
9488: LIST
9489: PUSH
9490: EMPTY
9491: LIST
9492: LIST
9493: LIST
9494: PPUSH
9495: CALL_OW 69
9499: ST_TO_ADDR
// RewardPeople ( tmp ) ;
9500: LD_VAR 0 1
9504: PPUSH
9505: CALL_OW 43
// SaveCharacters ( Heike , 02_Heike ) ;
9509: LD_EXP 20
9513: PPUSH
9514: LD_STRING 02_Heike
9516: PPUSH
9517: CALL_OW 38
// SaveCharacters ( Aviradze , 02_Aviradze ) ;
9521: LD_EXP 24
9525: PPUSH
9526: LD_STRING 02_Aviradze
9528: PPUSH
9529: CALL_OW 38
// if Givi then
9533: LD_EXP 21
9537: IFFALSE 9551
// SaveCharacters ( Givi , 02_Givi ) ;
9539: LD_EXP 21
9543: PPUSH
9544: LD_STRING 02_Givi
9546: PPUSH
9547: CALL_OW 38
// if Mike then
9551: LD_EXP 22
9555: IFFALSE 9569
// SaveCharacters ( Mike , 02_Mike ) ;
9557: LD_EXP 22
9561: PPUSH
9562: LD_STRING 02_Mike
9564: PPUSH
9565: CALL_OW 38
// if Kamil then
9569: LD_EXP 23
9573: IFFALSE 9587
// SaveCharacters ( Kamil , 02_Kamil ) ;
9575: LD_EXP 23
9579: PPUSH
9580: LD_STRING 02_Kamil
9582: PPUSH
9583: CALL_OW 38
// if Kaia then
9587: LD_EXP 25
9591: IFFALSE 9605
// SaveCharacters ( Kaia , 02_Kaia ) ;
9593: LD_EXP 25
9597: PPUSH
9598: LD_STRING 02_Kaia
9600: PPUSH
9601: CALL_OW 38
// if Sophia then
9605: LD_EXP 26
9609: IFFALSE 9623
// SaveCharacters ( Sophia , 02_Sophia ) ;
9611: LD_EXP 26
9615: PPUSH
9616: LD_STRING 02_Sophia
9618: PPUSH
9619: CALL_OW 38
// if Markov then
9623: LD_EXP 27
9627: IFFALSE 9641
// SaveCharacters ( Markov , 02_Markov ) ;
9629: LD_EXP 27
9633: PPUSH
9634: LD_STRING 02_Markov
9636: PPUSH
9637: CALL_OW 38
// if tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] then
9641: LD_VAR 0 1
9645: PUSH
9646: LD_EXP 20
9650: PUSH
9651: LD_EXP 24
9655: PUSH
9656: LD_EXP 21
9660: PUSH
9661: LD_EXP 22
9665: PUSH
9666: LD_EXP 23
9670: PUSH
9671: LD_EXP 26
9675: PUSH
9676: LD_EXP 25
9680: PUSH
9681: LD_EXP 27
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: LIST
9690: LIST
9691: LIST
9692: LIST
9693: LIST
9694: LIST
9695: DIFF
9696: IFFALSE 9761
// SaveCharacters ( tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] , 02_others ) ;
9698: LD_VAR 0 1
9702: PUSH
9703: LD_EXP 20
9707: PUSH
9708: LD_EXP 24
9712: PUSH
9713: LD_EXP 21
9717: PUSH
9718: LD_EXP 22
9722: PUSH
9723: LD_EXP 23
9727: PUSH
9728: LD_EXP 26
9732: PUSH
9733: LD_EXP 25
9737: PUSH
9738: LD_EXP 27
9742: PUSH
9743: EMPTY
9744: LIST
9745: LIST
9746: LIST
9747: LIST
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: DIFF
9753: PPUSH
9754: LD_STRING 02_others
9756: PPUSH
9757: CALL_OW 38
// YouWin ;
9761: CALL_OW 103
// InGameOff ;
9765: CALL_OW 9
// end ;
9769: PPOPN 1
9771: END
// every 0 0$1 trigger tick > timeUntilFarmer and aviradzeSpotted do
9772: LD_OWVAR 1
9776: PUSH
9777: LD_EXP 11
9781: GREATER
9782: PUSH
9783: LD_EXP 4
9787: AND
9788: IFFALSE 9828
9790: GO 9792
9792: DISABLE
// begin InGameOn ;
9793: CALL_OW 8
// PrepareFarmer ;
9797: CALL 10428 0 0
// CenterNowOnUnits ( Farmer ) ;
9801: LD_EXP 28
9805: PPUSH
9806: CALL_OW 87
// wait ( 0 0$2 ) ;
9810: LD_INT 70
9812: PPUSH
9813: CALL_OW 67
// YouLost ( Farmer ) ;
9817: LD_STRING Farmer
9819: PPUSH
9820: CALL_OW 104
// InGameOff ;
9824: CALL_OW 9
// end ; end_of_file
9828: END
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer ; export function PrepareArabian ; var un , veh ; begin
9829: LD_INT 0
9831: PPUSH
9832: PPUSH
9833: PPUSH
// uc_side := 2 ;
9834: LD_ADDR_OWVAR 20
9838: PUSH
9839: LD_INT 2
9841: ST_TO_ADDR
// uc_nation := 2 ;
9842: LD_ADDR_OWVAR 21
9846: PUSH
9847: LD_INT 2
9849: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
9850: LD_ADDR_EXP 20
9854: PUSH
9855: LD_STRING Heike
9857: PPUSH
9858: LD_EXP 1
9862: NOT
9863: PPUSH
9864: LD_EXP 2
9868: PPUSH
9869: CALL 213 0 3
9873: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
9874: LD_EXP 20
9878: PPUSH
9879: LD_INT 83
9881: PPUSH
9882: LD_INT 72
9884: PPUSH
9885: LD_INT 0
9887: PPUSH
9888: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
9892: LD_ADDR_EXP 21
9896: PUSH
9897: LD_STRING Givi
9899: PPUSH
9900: LD_EXP 1
9904: NOT
9905: PPUSH
9906: LD_EXP 2
9910: PPUSH
9911: CALL 213 0 3
9915: ST_TO_ADDR
// if Givi then
9916: LD_EXP 21
9920: IFFALSE 9940
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
9922: LD_EXP 21
9926: PPUSH
9927: LD_INT 87
9929: PPUSH
9930: LD_INT 76
9932: PPUSH
9933: LD_INT 0
9935: PPUSH
9936: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
9940: LD_ADDR_EXP 22
9944: PUSH
9945: LD_STRING Mike
9947: PPUSH
9948: LD_EXP 1
9952: NOT
9953: PPUSH
9954: LD_EXP 2
9958: PPUSH
9959: CALL 213 0 3
9963: ST_TO_ADDR
// if Mike then
9964: LD_EXP 22
9968: IFFALSE 9988
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
9970: LD_EXP 22
9974: PPUSH
9975: LD_INT 84
9977: PPUSH
9978: LD_INT 76
9980: PPUSH
9981: LD_INT 0
9983: PPUSH
9984: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
9988: LD_ADDR_EXP 23
9992: PUSH
9993: LD_STRING Kamil
9995: PPUSH
9996: LD_EXP 1
10000: NOT
10001: PPUSH
10002: LD_EXP 2
10006: PPUSH
10007: CALL 213 0 3
10011: ST_TO_ADDR
// if Kamil then
10012: LD_EXP 23
10016: IFFALSE 10036
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
10018: LD_EXP 23
10022: PPUSH
10023: LD_INT 85
10025: PPUSH
10026: LD_INT 78
10028: PPUSH
10029: LD_INT 0
10031: PPUSH
10032: CALL_OW 48
// uc_side := 5 ;
10036: LD_ADDR_OWVAR 20
10040: PUSH
10041: LD_INT 5
10043: ST_TO_ADDR
// uc_nation := 2 ;
10044: LD_ADDR_OWVAR 21
10048: PUSH
10049: LD_INT 2
10051: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , false ,  ) ;
10052: LD_ADDR_EXP 24
10056: PUSH
10057: LD_STRING Aviradze
10059: PPUSH
10060: LD_INT 0
10062: PPUSH
10063: LD_STRING 
10065: PPUSH
10066: CALL 213 0 3
10070: ST_TO_ADDR
// PlaceUnitXY ( Aviradze , 106 , 38 , false ) ;
10071: LD_EXP 24
10075: PPUSH
10076: LD_INT 106
10078: PPUSH
10079: LD_INT 38
10081: PPUSH
10082: LD_INT 0
10084: PPUSH
10085: CALL_OW 48
// ComTurnXY ( Aviradze , 103 , 38 ) ;
10089: LD_EXP 24
10093: PPUSH
10094: LD_INT 103
10096: PPUSH
10097: LD_INT 38
10099: PPUSH
10100: CALL_OW 118
// Kaia := PrepareUnit ( Kaia , false ,  ) ;
10104: LD_ADDR_EXP 25
10108: PUSH
10109: LD_STRING Kaia
10111: PPUSH
10112: LD_INT 0
10114: PPUSH
10115: LD_STRING 
10117: PPUSH
10118: CALL 213 0 3
10122: ST_TO_ADDR
// PlaceUnitXY ( Kaia , 100 , 34 , false ) ;
10123: LD_EXP 25
10127: PPUSH
10128: LD_INT 100
10130: PPUSH
10131: LD_INT 34
10133: PPUSH
10134: LD_INT 0
10136: PPUSH
10137: CALL_OW 48
// ComTurnXY ( Kaia , 100 , 39 ) ;
10141: LD_EXP 25
10145: PPUSH
10146: LD_INT 100
10148: PPUSH
10149: LD_INT 39
10151: PPUSH
10152: CALL_OW 118
// Sophia := PrepareUnit ( Sophia , false ,  ) ;
10156: LD_ADDR_EXP 26
10160: PUSH
10161: LD_STRING Sophia
10163: PPUSH
10164: LD_INT 0
10166: PPUSH
10167: LD_STRING 
10169: PPUSH
10170: CALL 213 0 3
10174: ST_TO_ADDR
// PlaceUnitXY ( Sophia , 109 , 50 , false ) ;
10175: LD_EXP 26
10179: PPUSH
10180: LD_INT 109
10182: PPUSH
10183: LD_INT 50
10185: PPUSH
10186: LD_INT 0
10188: PPUSH
10189: CALL_OW 48
// ComTurnXY ( Sophia , 100 , 39 ) ;
10193: LD_EXP 26
10197: PPUSH
10198: LD_INT 100
10200: PPUSH
10201: LD_INT 39
10203: PPUSH
10204: CALL_OW 118
// Markov := PrepareUnit ( Markov , false ,  ) ;
10208: LD_ADDR_EXP 27
10212: PUSH
10213: LD_STRING Markov
10215: PPUSH
10216: LD_INT 0
10218: PPUSH
10219: LD_STRING 
10221: PPUSH
10222: CALL 213 0 3
10226: ST_TO_ADDR
// PrepareTank ( 5 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , [ 90 , 70 , 60 ] [ Difficulty ] ) ;
10227: LD_INT 5
10229: PPUSH
10230: LD_INT 3
10232: PPUSH
10233: LD_INT 21
10235: PPUSH
10236: LD_INT 1
10238: PPUSH
10239: LD_INT 1
10241: PPUSH
10242: LD_INT 42
10244: PPUSH
10245: LD_INT 90
10247: PUSH
10248: LD_INT 70
10250: PUSH
10251: LD_INT 60
10253: PUSH
10254: EMPTY
10255: LIST
10256: LIST
10257: LIST
10258: PUSH
10259: LD_OWVAR 67
10263: ARRAY
10264: PPUSH
10265: CALL 276 0 7
// veh := CreateVehicle ;
10269: LD_ADDR_VAR 0 3
10273: PUSH
10274: CALL_OW 45
10278: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10279: LD_VAR 0 3
10283: PPUSH
10284: LD_INT 4
10286: PPUSH
10287: CALL_OW 233
// PlaceUnitXY ( veh , 109 , 38 , false ) ;
10291: LD_VAR 0 3
10295: PPUSH
10296: LD_INT 109
10298: PPUSH
10299: LD_INT 38
10301: PPUSH
10302: LD_INT 0
10304: PPUSH
10305: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
10309: LD_EXP 27
10313: PPUSH
10314: LD_VAR 0 3
10318: PPUSH
10319: CALL_OW 52
// ComTurnUnit ( Kaia , Aviradze ) ;
10323: LD_EXP 25
10327: PPUSH
10328: LD_EXP 24
10332: PPUSH
10333: CALL_OW 119
// ComTurnUnit ( Aviradze , Kaia ) ;
10337: LD_EXP 24
10341: PPUSH
10342: LD_EXP 25
10346: PPUSH
10347: CALL_OW 119
// if not Givi or not Mike then
10351: LD_EXP 21
10355: NOT
10356: PUSH
10357: LD_EXP 22
10361: NOT
10362: OR
10363: IFFALSE 10423
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10365: LD_INT 1
10367: PPUSH
10368: LD_INT 1
10370: PPUSH
10371: LD_INT 1
10373: PPUSH
10374: CALL_OW 380
// un := CreateHuman ;
10378: LD_ADDR_VAR 0 2
10382: PUSH
10383: CALL_OW 44
10387: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 40 , 3 , false ) ;
10388: LD_VAR 0 2
10392: PPUSH
10393: LD_INT 112
10395: PPUSH
10396: LD_INT 40
10398: PPUSH
10399: LD_INT 3
10401: PPUSH
10402: LD_INT 0
10404: PPUSH
10405: CALL_OW 50
// ComTurnUnit ( un , Aviradze ) ;
10409: LD_VAR 0 2
10413: PPUSH
10414: LD_EXP 24
10418: PPUSH
10419: CALL_OW 119
// end ; end ;
10423: LD_VAR 0 1
10427: RET
// export function PrepareFarmer ; var i ; begin
10428: LD_INT 0
10430: PPUSH
10431: PPUSH
// uc_side := 5 ;
10432: LD_ADDR_OWVAR 20
10436: PUSH
10437: LD_INT 5
10439: ST_TO_ADDR
// uc_nation := 2 ;
10440: LD_ADDR_OWVAR 21
10444: PUSH
10445: LD_INT 2
10447: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
10448: LD_ADDR_EXP 28
10452: PUSH
10453: LD_STRING Farmer
10455: PPUSH
10456: LD_INT 0
10458: PPUSH
10459: LD_STRING 
10461: PPUSH
10462: CALL 213 0 3
10466: ST_TO_ADDR
// PlaceUnitXY ( Farmer , 106 , 62 , false ) ;
10467: LD_EXP 28
10471: PPUSH
10472: LD_INT 106
10474: PPUSH
10475: LD_INT 62
10477: PPUSH
10478: LD_INT 0
10480: PPUSH
10481: CALL_OW 48
// for i := 1 to 2 do
10485: LD_ADDR_VAR 0 2
10489: PUSH
10490: DOUBLE
10491: LD_INT 1
10493: DEC
10494: ST_TO_ADDR
10495: LD_INT 2
10497: PUSH
10498: FOR_TO
10499: IFFALSE 10537
// begin PrepareHuman ( false , 1 , 1 ) ;
10501: LD_INT 0
10503: PPUSH
10504: LD_INT 1
10506: PPUSH
10507: LD_INT 1
10509: PPUSH
10510: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 105 , 64 , 2 , false ) ;
10514: CALL_OW 44
10518: PPUSH
10519: LD_INT 105
10521: PPUSH
10522: LD_INT 64
10524: PPUSH
10525: LD_INT 2
10527: PPUSH
10528: LD_INT 0
10530: PPUSH
10531: CALL_OW 50
// end ;
10535: GO 10498
10537: POP
10538: POP
// end ; end_of_file
10539: LD_VAR 0 1
10543: RET
// every 2 2$20 + 0 0$10 do
10544: GO 10546
10546: DISABLE
// begin enable ;
10547: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , forest , true ) ;
10548: LD_INT 1
10550: PPUSH
10551: LD_INT 5
10553: PPUSH
10554: CALL_OW 12
10558: PPUSH
10559: LD_INT 1
10561: PPUSH
10562: LD_INT 1
10564: PPUSH
10565: CALL_OW 55
// end ; end_of_file
10569: END
// on UnitDestroyed ( un ) do begin if un = Heike then
10570: LD_VAR 0 1
10574: PUSH
10575: LD_EXP 20
10579: EQUAL
10580: IFFALSE 10589
// YouLost ( Heike ) ;
10582: LD_STRING Heike
10584: PPUSH
10585: CALL_OW 104
// if un = Aviradze then
10589: LD_VAR 0 1
10593: PUSH
10594: LD_EXP 24
10598: EQUAL
10599: IFFALSE 10608
// YouLost ( Aviradze ) ;
10601: LD_STRING Aviradze
10603: PPUSH
10604: CALL_OW 104
// if un = usLab then
10608: LD_VAR 0 1
10612: PUSH
10613: LD_INT 3
10615: EQUAL
10616: IFFALSE 10625
// YouLost ( Lab ) ;
10618: LD_STRING Lab
10620: PPUSH
10621: CALL_OW 104
// end ;
10625: PPOPN 1
10627: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un in usSci and killerSide = 2 then
10628: LD_VAR 0 1
10632: PUSH
10633: LD_EXP 19
10637: IN
10638: PUSH
10639: LD_VAR 0 2
10643: PUSH
10644: LD_INT 2
10646: EQUAL
10647: AND
10648: IFFALSE 10664
// sciCounterKill := sciCounterKill + 1 ;
10650: LD_ADDR_EXP 8
10654: PUSH
10655: LD_EXP 8
10659: PUSH
10660: LD_INT 1
10662: PLUS
10663: ST_TO_ADDR
// end ;
10664: PPOPN 3
10666: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
10667: LD_VAR 0 1
10671: PUSH
10672: LD_INT 2
10674: EQUAL
10675: PUSH
10676: LD_VAR 0 2
10680: PUSH
10681: LD_INT 5
10683: EQUAL
10684: AND
10685: IFFALSE 10694
// YouLost ( FriendlyFire ) ;
10687: LD_STRING FriendlyFire
10689: PPUSH
10690: CALL_OW 104
// end ; end_of_file
10694: PPOPN 2
10696: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10697: GO 10699
10699: DISABLE
// begin ru_radar := 98 ;
10700: LD_ADDR_EXP 29
10704: PUSH
10705: LD_INT 98
10707: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10708: LD_ADDR_EXP 30
10712: PUSH
10713: LD_INT 89
10715: ST_TO_ADDR
// us_hack := 99 ;
10716: LD_ADDR_EXP 31
10720: PUSH
10721: LD_INT 99
10723: ST_TO_ADDR
// us_artillery := 97 ;
10724: LD_ADDR_EXP 32
10728: PUSH
10729: LD_INT 97
10731: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10732: LD_ADDR_EXP 33
10736: PUSH
10737: LD_INT 91
10739: ST_TO_ADDR
// end ; end_of_file end_of_file
10740: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
10741: GO 10743
10743: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
10744: LD_STRING initStreamRollete();
10746: PPUSH
10747: CALL_OW 559
// InitStreamMode ;
10751: CALL 10760 0 0
// DefineStreamItems ( ) ;
10755: CALL 11200 0 0
// end ;
10759: END
// function InitStreamMode ; begin
10760: LD_INT 0
10762: PPUSH
// streamModeActive := false ;
10763: LD_ADDR_EXP 34
10767: PUSH
10768: LD_INT 0
10770: ST_TO_ADDR
// normalCounter := 36 ;
10771: LD_ADDR_EXP 35
10775: PUSH
10776: LD_INT 36
10778: ST_TO_ADDR
// hardcoreCounter := 16 ;
10779: LD_ADDR_EXP 36
10783: PUSH
10784: LD_INT 16
10786: ST_TO_ADDR
// sRocket := false ;
10787: LD_ADDR_EXP 39
10791: PUSH
10792: LD_INT 0
10794: ST_TO_ADDR
// sSpeed := false ;
10795: LD_ADDR_EXP 38
10799: PUSH
10800: LD_INT 0
10802: ST_TO_ADDR
// sEngine := false ;
10803: LD_ADDR_EXP 40
10807: PUSH
10808: LD_INT 0
10810: ST_TO_ADDR
// sSpec := false ;
10811: LD_ADDR_EXP 37
10815: PUSH
10816: LD_INT 0
10818: ST_TO_ADDR
// sLevel := false ;
10819: LD_ADDR_EXP 41
10823: PUSH
10824: LD_INT 0
10826: ST_TO_ADDR
// sArmoury := false ;
10827: LD_ADDR_EXP 42
10831: PUSH
10832: LD_INT 0
10834: ST_TO_ADDR
// sRadar := false ;
10835: LD_ADDR_EXP 43
10839: PUSH
10840: LD_INT 0
10842: ST_TO_ADDR
// sBunker := false ;
10843: LD_ADDR_EXP 44
10847: PUSH
10848: LD_INT 0
10850: ST_TO_ADDR
// sHack := false ;
10851: LD_ADDR_EXP 45
10855: PUSH
10856: LD_INT 0
10858: ST_TO_ADDR
// sFire := false ;
10859: LD_ADDR_EXP 46
10863: PUSH
10864: LD_INT 0
10866: ST_TO_ADDR
// sRefresh := false ;
10867: LD_ADDR_EXP 47
10871: PUSH
10872: LD_INT 0
10874: ST_TO_ADDR
// sExp := false ;
10875: LD_ADDR_EXP 48
10879: PUSH
10880: LD_INT 0
10882: ST_TO_ADDR
// sDepot := false ;
10883: LD_ADDR_EXP 49
10887: PUSH
10888: LD_INT 0
10890: ST_TO_ADDR
// sFlag := false ;
10891: LD_ADDR_EXP 50
10895: PUSH
10896: LD_INT 0
10898: ST_TO_ADDR
// sKamikadze := false ;
10899: LD_ADDR_EXP 58
10903: PUSH
10904: LD_INT 0
10906: ST_TO_ADDR
// sTroll := false ;
10907: LD_ADDR_EXP 59
10911: PUSH
10912: LD_INT 0
10914: ST_TO_ADDR
// sSlow := false ;
10915: LD_ADDR_EXP 60
10919: PUSH
10920: LD_INT 0
10922: ST_TO_ADDR
// sLack := false ;
10923: LD_ADDR_EXP 61
10927: PUSH
10928: LD_INT 0
10930: ST_TO_ADDR
// sTank := false ;
10931: LD_ADDR_EXP 63
10935: PUSH
10936: LD_INT 0
10938: ST_TO_ADDR
// sRemote := false ;
10939: LD_ADDR_EXP 64
10943: PUSH
10944: LD_INT 0
10946: ST_TO_ADDR
// sPowell := false ;
10947: LD_ADDR_EXP 65
10951: PUSH
10952: LD_INT 0
10954: ST_TO_ADDR
// sTeleport := false ;
10955: LD_ADDR_EXP 68
10959: PUSH
10960: LD_INT 0
10962: ST_TO_ADDR
// sOilTower := false ;
10963: LD_ADDR_EXP 70
10967: PUSH
10968: LD_INT 0
10970: ST_TO_ADDR
// sShovel := false ;
10971: LD_ADDR_EXP 71
10975: PUSH
10976: LD_INT 0
10978: ST_TO_ADDR
// sSheik := false ;
10979: LD_ADDR_EXP 72
10983: PUSH
10984: LD_INT 0
10986: ST_TO_ADDR
// sEarthquake := false ;
10987: LD_ADDR_EXP 74
10991: PUSH
10992: LD_INT 0
10994: ST_TO_ADDR
// sAI := false ;
10995: LD_ADDR_EXP 75
10999: PUSH
11000: LD_INT 0
11002: ST_TO_ADDR
// sCargo := false ;
11003: LD_ADDR_EXP 78
11007: PUSH
11008: LD_INT 0
11010: ST_TO_ADDR
// sDLaser := false ;
11011: LD_ADDR_EXP 79
11015: PUSH
11016: LD_INT 0
11018: ST_TO_ADDR
// sExchange := false ;
11019: LD_ADDR_EXP 80
11023: PUSH
11024: LD_INT 0
11026: ST_TO_ADDR
// sFac := false ;
11027: LD_ADDR_EXP 81
11031: PUSH
11032: LD_INT 0
11034: ST_TO_ADDR
// sPower := false ;
11035: LD_ADDR_EXP 82
11039: PUSH
11040: LD_INT 0
11042: ST_TO_ADDR
// sRandom := false ;
11043: LD_ADDR_EXP 83
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// sShield := false ;
11051: LD_ADDR_EXP 84
11055: PUSH
11056: LD_INT 0
11058: ST_TO_ADDR
// sTime := false ;
11059: LD_ADDR_EXP 85
11063: PUSH
11064: LD_INT 0
11066: ST_TO_ADDR
// sTools := false ;
11067: LD_ADDR_EXP 86
11071: PUSH
11072: LD_INT 0
11074: ST_TO_ADDR
// sSold := false ;
11075: LD_ADDR_EXP 51
11079: PUSH
11080: LD_INT 0
11082: ST_TO_ADDR
// sDiff := false ;
11083: LD_ADDR_EXP 52
11087: PUSH
11088: LD_INT 0
11090: ST_TO_ADDR
// sFog := false ;
11091: LD_ADDR_EXP 55
11095: PUSH
11096: LD_INT 0
11098: ST_TO_ADDR
// sReset := false ;
11099: LD_ADDR_EXP 56
11103: PUSH
11104: LD_INT 0
11106: ST_TO_ADDR
// sSun := false ;
11107: LD_ADDR_EXP 57
11111: PUSH
11112: LD_INT 0
11114: ST_TO_ADDR
// sTiger := false ;
11115: LD_ADDR_EXP 53
11119: PUSH
11120: LD_INT 0
11122: ST_TO_ADDR
// sBomb := false ;
11123: LD_ADDR_EXP 54
11127: PUSH
11128: LD_INT 0
11130: ST_TO_ADDR
// sWound := false ;
11131: LD_ADDR_EXP 62
11135: PUSH
11136: LD_INT 0
11138: ST_TO_ADDR
// sBetray := false ;
11139: LD_ADDR_EXP 66
11143: PUSH
11144: LD_INT 0
11146: ST_TO_ADDR
// sContamin := false ;
11147: LD_ADDR_EXP 67
11151: PUSH
11152: LD_INT 0
11154: ST_TO_ADDR
// sOil := false ;
11155: LD_ADDR_EXP 69
11159: PUSH
11160: LD_INT 0
11162: ST_TO_ADDR
// sStu := false ;
11163: LD_ADDR_EXP 73
11167: PUSH
11168: LD_INT 0
11170: ST_TO_ADDR
// sBazooka := false ;
11171: LD_ADDR_EXP 76
11175: PUSH
11176: LD_INT 0
11178: ST_TO_ADDR
// sMortar := false ;
11179: LD_ADDR_EXP 77
11183: PUSH
11184: LD_INT 0
11186: ST_TO_ADDR
// sRanger := false ;
11187: LD_ADDR_EXP 87
11191: PUSH
11192: LD_INT 0
11194: ST_TO_ADDR
// end ;
11195: LD_VAR 0 1
11199: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11200: LD_INT 0
11202: PPUSH
11203: PPUSH
11204: PPUSH
11205: PPUSH
11206: PPUSH
// result := [ ] ;
11207: LD_ADDR_VAR 0 1
11211: PUSH
11212: EMPTY
11213: ST_TO_ADDR
// if campaign_id = 1 then
11214: LD_OWVAR 69
11218: PUSH
11219: LD_INT 1
11221: EQUAL
11222: IFFALSE 14160
// begin case mission_number of 1 :
11224: LD_OWVAR 70
11228: PUSH
11229: LD_INT 1
11231: DOUBLE
11232: EQUAL
11233: IFTRUE 11237
11235: GO 11301
11237: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11238: LD_ADDR_VAR 0 1
11242: PUSH
11243: LD_INT 2
11245: PUSH
11246: LD_INT 4
11248: PUSH
11249: LD_INT 11
11251: PUSH
11252: LD_INT 12
11254: PUSH
11255: LD_INT 15
11257: PUSH
11258: LD_INT 16
11260: PUSH
11261: LD_INT 22
11263: PUSH
11264: LD_INT 23
11266: PUSH
11267: LD_INT 26
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: PUSH
11281: LD_INT 101
11283: PUSH
11284: LD_INT 102
11286: PUSH
11287: LD_INT 106
11289: PUSH
11290: EMPTY
11291: LIST
11292: LIST
11293: LIST
11294: PUSH
11295: EMPTY
11296: LIST
11297: LIST
11298: ST_TO_ADDR
11299: GO 14158
11301: LD_INT 2
11303: DOUBLE
11304: EQUAL
11305: IFTRUE 11309
11307: GO 11381
11309: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11310: LD_ADDR_VAR 0 1
11314: PUSH
11315: LD_INT 2
11317: PUSH
11318: LD_INT 4
11320: PUSH
11321: LD_INT 11
11323: PUSH
11324: LD_INT 12
11326: PUSH
11327: LD_INT 15
11329: PUSH
11330: LD_INT 16
11332: PUSH
11333: LD_INT 22
11335: PUSH
11336: LD_INT 23
11338: PUSH
11339: LD_INT 26
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: LIST
11346: LIST
11347: LIST
11348: LIST
11349: LIST
11350: LIST
11351: LIST
11352: PUSH
11353: LD_INT 101
11355: PUSH
11356: LD_INT 102
11358: PUSH
11359: LD_INT 105
11361: PUSH
11362: LD_INT 106
11364: PUSH
11365: LD_INT 108
11367: PUSH
11368: EMPTY
11369: LIST
11370: LIST
11371: LIST
11372: LIST
11373: LIST
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: ST_TO_ADDR
11379: GO 14158
11381: LD_INT 3
11383: DOUBLE
11384: EQUAL
11385: IFTRUE 11389
11387: GO 11465
11389: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11390: LD_ADDR_VAR 0 1
11394: PUSH
11395: LD_INT 2
11397: PUSH
11398: LD_INT 4
11400: PUSH
11401: LD_INT 5
11403: PUSH
11404: LD_INT 11
11406: PUSH
11407: LD_INT 12
11409: PUSH
11410: LD_INT 15
11412: PUSH
11413: LD_INT 16
11415: PUSH
11416: LD_INT 22
11418: PUSH
11419: LD_INT 26
11421: PUSH
11422: LD_INT 36
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: LIST
11433: LIST
11434: LIST
11435: LIST
11436: PUSH
11437: LD_INT 101
11439: PUSH
11440: LD_INT 102
11442: PUSH
11443: LD_INT 105
11445: PUSH
11446: LD_INT 106
11448: PUSH
11449: LD_INT 108
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: LIST
11456: LIST
11457: LIST
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: ST_TO_ADDR
11463: GO 14158
11465: LD_INT 4
11467: DOUBLE
11468: EQUAL
11469: IFTRUE 11473
11471: GO 11557
11473: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11474: LD_ADDR_VAR 0 1
11478: PUSH
11479: LD_INT 2
11481: PUSH
11482: LD_INT 4
11484: PUSH
11485: LD_INT 5
11487: PUSH
11488: LD_INT 8
11490: PUSH
11491: LD_INT 11
11493: PUSH
11494: LD_INT 12
11496: PUSH
11497: LD_INT 15
11499: PUSH
11500: LD_INT 16
11502: PUSH
11503: LD_INT 22
11505: PUSH
11506: LD_INT 23
11508: PUSH
11509: LD_INT 26
11511: PUSH
11512: LD_INT 36
11514: PUSH
11515: EMPTY
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 101
11531: PUSH
11532: LD_INT 102
11534: PUSH
11535: LD_INT 105
11537: PUSH
11538: LD_INT 106
11540: PUSH
11541: LD_INT 108
11543: PUSH
11544: EMPTY
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: PUSH
11551: EMPTY
11552: LIST
11553: LIST
11554: ST_TO_ADDR
11555: GO 14158
11557: LD_INT 5
11559: DOUBLE
11560: EQUAL
11561: IFTRUE 11565
11563: GO 11665
11565: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
11566: LD_ADDR_VAR 0 1
11570: PUSH
11571: LD_INT 2
11573: PUSH
11574: LD_INT 4
11576: PUSH
11577: LD_INT 5
11579: PUSH
11580: LD_INT 6
11582: PUSH
11583: LD_INT 8
11585: PUSH
11586: LD_INT 11
11588: PUSH
11589: LD_INT 12
11591: PUSH
11592: LD_INT 15
11594: PUSH
11595: LD_INT 16
11597: PUSH
11598: LD_INT 22
11600: PUSH
11601: LD_INT 23
11603: PUSH
11604: LD_INT 25
11606: PUSH
11607: LD_INT 26
11609: PUSH
11610: LD_INT 36
11612: PUSH
11613: EMPTY
11614: LIST
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: PUSH
11629: LD_INT 101
11631: PUSH
11632: LD_INT 102
11634: PUSH
11635: LD_INT 105
11637: PUSH
11638: LD_INT 106
11640: PUSH
11641: LD_INT 108
11643: PUSH
11644: LD_INT 109
11646: PUSH
11647: LD_INT 112
11649: PUSH
11650: EMPTY
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: LIST
11657: LIST
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: ST_TO_ADDR
11663: GO 14158
11665: LD_INT 6
11667: DOUBLE
11668: EQUAL
11669: IFTRUE 11673
11671: GO 11793
11673: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
11674: LD_ADDR_VAR 0 1
11678: PUSH
11679: LD_INT 2
11681: PUSH
11682: LD_INT 4
11684: PUSH
11685: LD_INT 5
11687: PUSH
11688: LD_INT 6
11690: PUSH
11691: LD_INT 8
11693: PUSH
11694: LD_INT 11
11696: PUSH
11697: LD_INT 12
11699: PUSH
11700: LD_INT 15
11702: PUSH
11703: LD_INT 16
11705: PUSH
11706: LD_INT 20
11708: PUSH
11709: LD_INT 21
11711: PUSH
11712: LD_INT 22
11714: PUSH
11715: LD_INT 23
11717: PUSH
11718: LD_INT 25
11720: PUSH
11721: LD_INT 26
11723: PUSH
11724: LD_INT 30
11726: PUSH
11727: LD_INT 31
11729: PUSH
11730: LD_INT 32
11732: PUSH
11733: LD_INT 36
11735: PUSH
11736: EMPTY
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: PUSH
11757: LD_INT 101
11759: PUSH
11760: LD_INT 102
11762: PUSH
11763: LD_INT 105
11765: PUSH
11766: LD_INT 106
11768: PUSH
11769: LD_INT 108
11771: PUSH
11772: LD_INT 109
11774: PUSH
11775: LD_INT 112
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: PUSH
11787: EMPTY
11788: LIST
11789: LIST
11790: ST_TO_ADDR
11791: GO 14158
11793: LD_INT 7
11795: DOUBLE
11796: EQUAL
11797: IFTRUE 11801
11799: GO 11901
11801: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
11802: LD_ADDR_VAR 0 1
11806: PUSH
11807: LD_INT 2
11809: PUSH
11810: LD_INT 4
11812: PUSH
11813: LD_INT 5
11815: PUSH
11816: LD_INT 7
11818: PUSH
11819: LD_INT 11
11821: PUSH
11822: LD_INT 12
11824: PUSH
11825: LD_INT 15
11827: PUSH
11828: LD_INT 16
11830: PUSH
11831: LD_INT 20
11833: PUSH
11834: LD_INT 21
11836: PUSH
11837: LD_INT 22
11839: PUSH
11840: LD_INT 23
11842: PUSH
11843: LD_INT 25
11845: PUSH
11846: LD_INT 26
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: PUSH
11865: LD_INT 101
11867: PUSH
11868: LD_INT 102
11870: PUSH
11871: LD_INT 103
11873: PUSH
11874: LD_INT 105
11876: PUSH
11877: LD_INT 106
11879: PUSH
11880: LD_INT 108
11882: PUSH
11883: LD_INT 112
11885: PUSH
11886: EMPTY
11887: LIST
11888: LIST
11889: LIST
11890: LIST
11891: LIST
11892: LIST
11893: LIST
11894: PUSH
11895: EMPTY
11896: LIST
11897: LIST
11898: ST_TO_ADDR
11899: GO 14158
11901: LD_INT 8
11903: DOUBLE
11904: EQUAL
11905: IFTRUE 11909
11907: GO 12037
11909: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
11910: LD_ADDR_VAR 0 1
11914: PUSH
11915: LD_INT 2
11917: PUSH
11918: LD_INT 4
11920: PUSH
11921: LD_INT 5
11923: PUSH
11924: LD_INT 6
11926: PUSH
11927: LD_INT 7
11929: PUSH
11930: LD_INT 8
11932: PUSH
11933: LD_INT 11
11935: PUSH
11936: LD_INT 12
11938: PUSH
11939: LD_INT 15
11941: PUSH
11942: LD_INT 16
11944: PUSH
11945: LD_INT 20
11947: PUSH
11948: LD_INT 21
11950: PUSH
11951: LD_INT 22
11953: PUSH
11954: LD_INT 23
11956: PUSH
11957: LD_INT 25
11959: PUSH
11960: LD_INT 26
11962: PUSH
11963: LD_INT 30
11965: PUSH
11966: LD_INT 31
11968: PUSH
11969: LD_INT 32
11971: PUSH
11972: LD_INT 36
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: LIST
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: LIST
11992: LIST
11993: LIST
11994: LIST
11995: LIST
11996: PUSH
11997: LD_INT 101
11999: PUSH
12000: LD_INT 102
12002: PUSH
12003: LD_INT 103
12005: PUSH
12006: LD_INT 105
12008: PUSH
12009: LD_INT 106
12011: PUSH
12012: LD_INT 108
12014: PUSH
12015: LD_INT 109
12017: PUSH
12018: LD_INT 112
12020: PUSH
12021: EMPTY
12022: LIST
12023: LIST
12024: LIST
12025: LIST
12026: LIST
12027: LIST
12028: LIST
12029: LIST
12030: PUSH
12031: EMPTY
12032: LIST
12033: LIST
12034: ST_TO_ADDR
12035: GO 14158
12037: LD_INT 9
12039: DOUBLE
12040: EQUAL
12041: IFTRUE 12045
12043: GO 12181
12045: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12046: LD_ADDR_VAR 0 1
12050: PUSH
12051: LD_INT 2
12053: PUSH
12054: LD_INT 4
12056: PUSH
12057: LD_INT 5
12059: PUSH
12060: LD_INT 6
12062: PUSH
12063: LD_INT 7
12065: PUSH
12066: LD_INT 8
12068: PUSH
12069: LD_INT 11
12071: PUSH
12072: LD_INT 12
12074: PUSH
12075: LD_INT 15
12077: PUSH
12078: LD_INT 16
12080: PUSH
12081: LD_INT 20
12083: PUSH
12084: LD_INT 21
12086: PUSH
12087: LD_INT 22
12089: PUSH
12090: LD_INT 23
12092: PUSH
12093: LD_INT 25
12095: PUSH
12096: LD_INT 26
12098: PUSH
12099: LD_INT 28
12101: PUSH
12102: LD_INT 30
12104: PUSH
12105: LD_INT 31
12107: PUSH
12108: LD_INT 32
12110: PUSH
12111: LD_INT 36
12113: PUSH
12114: EMPTY
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: LIST
12121: LIST
12122: LIST
12123: LIST
12124: LIST
12125: LIST
12126: LIST
12127: LIST
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: LIST
12134: LIST
12135: LIST
12136: PUSH
12137: LD_INT 101
12139: PUSH
12140: LD_INT 102
12142: PUSH
12143: LD_INT 103
12145: PUSH
12146: LD_INT 105
12148: PUSH
12149: LD_INT 106
12151: PUSH
12152: LD_INT 108
12154: PUSH
12155: LD_INT 109
12157: PUSH
12158: LD_INT 112
12160: PUSH
12161: LD_INT 114
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: LIST
12168: LIST
12169: LIST
12170: LIST
12171: LIST
12172: LIST
12173: LIST
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: ST_TO_ADDR
12179: GO 14158
12181: LD_INT 10
12183: DOUBLE
12184: EQUAL
12185: IFTRUE 12189
12187: GO 12373
12189: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12190: LD_ADDR_VAR 0 1
12194: PUSH
12195: LD_INT 2
12197: PUSH
12198: LD_INT 4
12200: PUSH
12201: LD_INT 5
12203: PUSH
12204: LD_INT 6
12206: PUSH
12207: LD_INT 7
12209: PUSH
12210: LD_INT 8
12212: PUSH
12213: LD_INT 9
12215: PUSH
12216: LD_INT 10
12218: PUSH
12219: LD_INT 11
12221: PUSH
12222: LD_INT 12
12224: PUSH
12225: LD_INT 13
12227: PUSH
12228: LD_INT 14
12230: PUSH
12231: LD_INT 15
12233: PUSH
12234: LD_INT 16
12236: PUSH
12237: LD_INT 17
12239: PUSH
12240: LD_INT 18
12242: PUSH
12243: LD_INT 19
12245: PUSH
12246: LD_INT 20
12248: PUSH
12249: LD_INT 21
12251: PUSH
12252: LD_INT 22
12254: PUSH
12255: LD_INT 23
12257: PUSH
12258: LD_INT 24
12260: PUSH
12261: LD_INT 25
12263: PUSH
12264: LD_INT 26
12266: PUSH
12267: LD_INT 28
12269: PUSH
12270: LD_INT 30
12272: PUSH
12273: LD_INT 31
12275: PUSH
12276: LD_INT 32
12278: PUSH
12279: LD_INT 36
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: LIST
12286: LIST
12287: LIST
12288: LIST
12289: LIST
12290: LIST
12291: LIST
12292: LIST
12293: LIST
12294: LIST
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: LIST
12310: LIST
12311: LIST
12312: PUSH
12313: LD_INT 101
12315: PUSH
12316: LD_INT 102
12318: PUSH
12319: LD_INT 103
12321: PUSH
12322: LD_INT 104
12324: PUSH
12325: LD_INT 105
12327: PUSH
12328: LD_INT 106
12330: PUSH
12331: LD_INT 107
12333: PUSH
12334: LD_INT 108
12336: PUSH
12337: LD_INT 109
12339: PUSH
12340: LD_INT 110
12342: PUSH
12343: LD_INT 111
12345: PUSH
12346: LD_INT 112
12348: PUSH
12349: LD_INT 114
12351: PUSH
12352: EMPTY
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: LIST
12363: LIST
12364: LIST
12365: LIST
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: ST_TO_ADDR
12371: GO 14158
12373: LD_INT 11
12375: DOUBLE
12376: EQUAL
12377: IFTRUE 12381
12379: GO 12573
12381: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12382: LD_ADDR_VAR 0 1
12386: PUSH
12387: LD_INT 2
12389: PUSH
12390: LD_INT 3
12392: PUSH
12393: LD_INT 4
12395: PUSH
12396: LD_INT 5
12398: PUSH
12399: LD_INT 6
12401: PUSH
12402: LD_INT 7
12404: PUSH
12405: LD_INT 8
12407: PUSH
12408: LD_INT 9
12410: PUSH
12411: LD_INT 10
12413: PUSH
12414: LD_INT 11
12416: PUSH
12417: LD_INT 12
12419: PUSH
12420: LD_INT 13
12422: PUSH
12423: LD_INT 14
12425: PUSH
12426: LD_INT 15
12428: PUSH
12429: LD_INT 16
12431: PUSH
12432: LD_INT 17
12434: PUSH
12435: LD_INT 18
12437: PUSH
12438: LD_INT 19
12440: PUSH
12441: LD_INT 20
12443: PUSH
12444: LD_INT 21
12446: PUSH
12447: LD_INT 22
12449: PUSH
12450: LD_INT 23
12452: PUSH
12453: LD_INT 24
12455: PUSH
12456: LD_INT 25
12458: PUSH
12459: LD_INT 26
12461: PUSH
12462: LD_INT 28
12464: PUSH
12465: LD_INT 30
12467: PUSH
12468: LD_INT 31
12470: PUSH
12471: LD_INT 32
12473: PUSH
12474: LD_INT 34
12476: PUSH
12477: LD_INT 36
12479: PUSH
12480: EMPTY
12481: LIST
12482: LIST
12483: LIST
12484: LIST
12485: LIST
12486: LIST
12487: LIST
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: LIST
12511: LIST
12512: PUSH
12513: LD_INT 101
12515: PUSH
12516: LD_INT 102
12518: PUSH
12519: LD_INT 103
12521: PUSH
12522: LD_INT 104
12524: PUSH
12525: LD_INT 105
12527: PUSH
12528: LD_INT 106
12530: PUSH
12531: LD_INT 107
12533: PUSH
12534: LD_INT 108
12536: PUSH
12537: LD_INT 109
12539: PUSH
12540: LD_INT 110
12542: PUSH
12543: LD_INT 111
12545: PUSH
12546: LD_INT 112
12548: PUSH
12549: LD_INT 114
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: LIST
12556: LIST
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: LIST
12570: ST_TO_ADDR
12571: GO 14158
12573: LD_INT 12
12575: DOUBLE
12576: EQUAL
12577: IFTRUE 12581
12579: GO 12789
12581: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
12582: LD_ADDR_VAR 0 1
12586: PUSH
12587: LD_INT 1
12589: PUSH
12590: LD_INT 2
12592: PUSH
12593: LD_INT 3
12595: PUSH
12596: LD_INT 4
12598: PUSH
12599: LD_INT 5
12601: PUSH
12602: LD_INT 6
12604: PUSH
12605: LD_INT 7
12607: PUSH
12608: LD_INT 8
12610: PUSH
12611: LD_INT 9
12613: PUSH
12614: LD_INT 10
12616: PUSH
12617: LD_INT 11
12619: PUSH
12620: LD_INT 12
12622: PUSH
12623: LD_INT 13
12625: PUSH
12626: LD_INT 14
12628: PUSH
12629: LD_INT 15
12631: PUSH
12632: LD_INT 16
12634: PUSH
12635: LD_INT 17
12637: PUSH
12638: LD_INT 18
12640: PUSH
12641: LD_INT 19
12643: PUSH
12644: LD_INT 20
12646: PUSH
12647: LD_INT 21
12649: PUSH
12650: LD_INT 22
12652: PUSH
12653: LD_INT 23
12655: PUSH
12656: LD_INT 24
12658: PUSH
12659: LD_INT 25
12661: PUSH
12662: LD_INT 26
12664: PUSH
12665: LD_INT 27
12667: PUSH
12668: LD_INT 28
12670: PUSH
12671: LD_INT 30
12673: PUSH
12674: LD_INT 31
12676: PUSH
12677: LD_INT 32
12679: PUSH
12680: LD_INT 33
12682: PUSH
12683: LD_INT 34
12685: PUSH
12686: LD_INT 36
12688: PUSH
12689: EMPTY
12690: LIST
12691: LIST
12692: LIST
12693: LIST
12694: LIST
12695: LIST
12696: LIST
12697: LIST
12698: LIST
12699: LIST
12700: LIST
12701: LIST
12702: LIST
12703: LIST
12704: LIST
12705: LIST
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: LIST
12711: LIST
12712: LIST
12713: LIST
12714: LIST
12715: LIST
12716: LIST
12717: LIST
12718: LIST
12719: LIST
12720: LIST
12721: LIST
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 101
12727: PUSH
12728: LD_INT 102
12730: PUSH
12731: LD_INT 103
12733: PUSH
12734: LD_INT 104
12736: PUSH
12737: LD_INT 105
12739: PUSH
12740: LD_INT 106
12742: PUSH
12743: LD_INT 107
12745: PUSH
12746: LD_INT 108
12748: PUSH
12749: LD_INT 109
12751: PUSH
12752: LD_INT 110
12754: PUSH
12755: LD_INT 111
12757: PUSH
12758: LD_INT 112
12760: PUSH
12761: LD_INT 113
12763: PUSH
12764: LD_INT 114
12766: PUSH
12767: EMPTY
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: LIST
12780: LIST
12781: LIST
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: ST_TO_ADDR
12787: GO 14158
12789: LD_INT 13
12791: DOUBLE
12792: EQUAL
12793: IFTRUE 12797
12795: GO 12993
12797: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
12798: LD_ADDR_VAR 0 1
12802: PUSH
12803: LD_INT 1
12805: PUSH
12806: LD_INT 2
12808: PUSH
12809: LD_INT 3
12811: PUSH
12812: LD_INT 4
12814: PUSH
12815: LD_INT 5
12817: PUSH
12818: LD_INT 8
12820: PUSH
12821: LD_INT 9
12823: PUSH
12824: LD_INT 10
12826: PUSH
12827: LD_INT 11
12829: PUSH
12830: LD_INT 12
12832: PUSH
12833: LD_INT 14
12835: PUSH
12836: LD_INT 15
12838: PUSH
12839: LD_INT 16
12841: PUSH
12842: LD_INT 17
12844: PUSH
12845: LD_INT 18
12847: PUSH
12848: LD_INT 19
12850: PUSH
12851: LD_INT 20
12853: PUSH
12854: LD_INT 21
12856: PUSH
12857: LD_INT 22
12859: PUSH
12860: LD_INT 23
12862: PUSH
12863: LD_INT 24
12865: PUSH
12866: LD_INT 25
12868: PUSH
12869: LD_INT 26
12871: PUSH
12872: LD_INT 27
12874: PUSH
12875: LD_INT 28
12877: PUSH
12878: LD_INT 30
12880: PUSH
12881: LD_INT 31
12883: PUSH
12884: LD_INT 32
12886: PUSH
12887: LD_INT 33
12889: PUSH
12890: LD_INT 34
12892: PUSH
12893: LD_INT 36
12895: PUSH
12896: EMPTY
12897: LIST
12898: LIST
12899: LIST
12900: LIST
12901: LIST
12902: LIST
12903: LIST
12904: LIST
12905: LIST
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: LIST
12916: LIST
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: LD_INT 101
12931: PUSH
12932: LD_INT 102
12934: PUSH
12935: LD_INT 103
12937: PUSH
12938: LD_INT 104
12940: PUSH
12941: LD_INT 105
12943: PUSH
12944: LD_INT 106
12946: PUSH
12947: LD_INT 107
12949: PUSH
12950: LD_INT 108
12952: PUSH
12953: LD_INT 109
12955: PUSH
12956: LD_INT 110
12958: PUSH
12959: LD_INT 111
12961: PUSH
12962: LD_INT 112
12964: PUSH
12965: LD_INT 113
12967: PUSH
12968: LD_INT 114
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: LIST
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: LIST
12982: LIST
12983: LIST
12984: LIST
12985: LIST
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: ST_TO_ADDR
12991: GO 14158
12993: LD_INT 14
12995: DOUBLE
12996: EQUAL
12997: IFTRUE 13001
12999: GO 13213
13001: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13002: LD_ADDR_VAR 0 1
13006: PUSH
13007: LD_INT 1
13009: PUSH
13010: LD_INT 2
13012: PUSH
13013: LD_INT 3
13015: PUSH
13016: LD_INT 4
13018: PUSH
13019: LD_INT 5
13021: PUSH
13022: LD_INT 6
13024: PUSH
13025: LD_INT 7
13027: PUSH
13028: LD_INT 8
13030: PUSH
13031: LD_INT 9
13033: PUSH
13034: LD_INT 10
13036: PUSH
13037: LD_INT 11
13039: PUSH
13040: LD_INT 12
13042: PUSH
13043: LD_INT 13
13045: PUSH
13046: LD_INT 14
13048: PUSH
13049: LD_INT 15
13051: PUSH
13052: LD_INT 16
13054: PUSH
13055: LD_INT 17
13057: PUSH
13058: LD_INT 18
13060: PUSH
13061: LD_INT 19
13063: PUSH
13064: LD_INT 20
13066: PUSH
13067: LD_INT 21
13069: PUSH
13070: LD_INT 22
13072: PUSH
13073: LD_INT 23
13075: PUSH
13076: LD_INT 24
13078: PUSH
13079: LD_INT 25
13081: PUSH
13082: LD_INT 26
13084: PUSH
13085: LD_INT 27
13087: PUSH
13088: LD_INT 28
13090: PUSH
13091: LD_INT 29
13093: PUSH
13094: LD_INT 30
13096: PUSH
13097: LD_INT 31
13099: PUSH
13100: LD_INT 32
13102: PUSH
13103: LD_INT 33
13105: PUSH
13106: LD_INT 34
13108: PUSH
13109: LD_INT 36
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: PUSH
13149: LD_INT 101
13151: PUSH
13152: LD_INT 102
13154: PUSH
13155: LD_INT 103
13157: PUSH
13158: LD_INT 104
13160: PUSH
13161: LD_INT 105
13163: PUSH
13164: LD_INT 106
13166: PUSH
13167: LD_INT 107
13169: PUSH
13170: LD_INT 108
13172: PUSH
13173: LD_INT 109
13175: PUSH
13176: LD_INT 110
13178: PUSH
13179: LD_INT 111
13181: PUSH
13182: LD_INT 112
13184: PUSH
13185: LD_INT 113
13187: PUSH
13188: LD_INT 114
13190: PUSH
13191: EMPTY
13192: LIST
13193: LIST
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: LIST
13206: PUSH
13207: EMPTY
13208: LIST
13209: LIST
13210: ST_TO_ADDR
13211: GO 14158
13213: LD_INT 15
13215: DOUBLE
13216: EQUAL
13217: IFTRUE 13221
13219: GO 13433
13221: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13222: LD_ADDR_VAR 0 1
13226: PUSH
13227: LD_INT 1
13229: PUSH
13230: LD_INT 2
13232: PUSH
13233: LD_INT 3
13235: PUSH
13236: LD_INT 4
13238: PUSH
13239: LD_INT 5
13241: PUSH
13242: LD_INT 6
13244: PUSH
13245: LD_INT 7
13247: PUSH
13248: LD_INT 8
13250: PUSH
13251: LD_INT 9
13253: PUSH
13254: LD_INT 10
13256: PUSH
13257: LD_INT 11
13259: PUSH
13260: LD_INT 12
13262: PUSH
13263: LD_INT 13
13265: PUSH
13266: LD_INT 14
13268: PUSH
13269: LD_INT 15
13271: PUSH
13272: LD_INT 16
13274: PUSH
13275: LD_INT 17
13277: PUSH
13278: LD_INT 18
13280: PUSH
13281: LD_INT 19
13283: PUSH
13284: LD_INT 20
13286: PUSH
13287: LD_INT 21
13289: PUSH
13290: LD_INT 22
13292: PUSH
13293: LD_INT 23
13295: PUSH
13296: LD_INT 24
13298: PUSH
13299: LD_INT 25
13301: PUSH
13302: LD_INT 26
13304: PUSH
13305: LD_INT 27
13307: PUSH
13308: LD_INT 28
13310: PUSH
13311: LD_INT 29
13313: PUSH
13314: LD_INT 30
13316: PUSH
13317: LD_INT 31
13319: PUSH
13320: LD_INT 32
13322: PUSH
13323: LD_INT 33
13325: PUSH
13326: LD_INT 34
13328: PUSH
13329: LD_INT 36
13331: PUSH
13332: EMPTY
13333: LIST
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: LIST
13344: LIST
13345: LIST
13346: LIST
13347: LIST
13348: LIST
13349: LIST
13350: LIST
13351: LIST
13352: LIST
13353: LIST
13354: LIST
13355: LIST
13356: LIST
13357: LIST
13358: LIST
13359: LIST
13360: LIST
13361: LIST
13362: LIST
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: PUSH
13369: LD_INT 101
13371: PUSH
13372: LD_INT 102
13374: PUSH
13375: LD_INT 103
13377: PUSH
13378: LD_INT 104
13380: PUSH
13381: LD_INT 105
13383: PUSH
13384: LD_INT 106
13386: PUSH
13387: LD_INT 107
13389: PUSH
13390: LD_INT 108
13392: PUSH
13393: LD_INT 109
13395: PUSH
13396: LD_INT 110
13398: PUSH
13399: LD_INT 111
13401: PUSH
13402: LD_INT 112
13404: PUSH
13405: LD_INT 113
13407: PUSH
13408: LD_INT 114
13410: PUSH
13411: EMPTY
13412: LIST
13413: LIST
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: PUSH
13427: EMPTY
13428: LIST
13429: LIST
13430: ST_TO_ADDR
13431: GO 14158
13433: LD_INT 16
13435: DOUBLE
13436: EQUAL
13437: IFTRUE 13441
13439: GO 13565
13441: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13442: LD_ADDR_VAR 0 1
13446: PUSH
13447: LD_INT 2
13449: PUSH
13450: LD_INT 4
13452: PUSH
13453: LD_INT 5
13455: PUSH
13456: LD_INT 7
13458: PUSH
13459: LD_INT 11
13461: PUSH
13462: LD_INT 12
13464: PUSH
13465: LD_INT 15
13467: PUSH
13468: LD_INT 16
13470: PUSH
13471: LD_INT 20
13473: PUSH
13474: LD_INT 21
13476: PUSH
13477: LD_INT 22
13479: PUSH
13480: LD_INT 23
13482: PUSH
13483: LD_INT 25
13485: PUSH
13486: LD_INT 26
13488: PUSH
13489: LD_INT 30
13491: PUSH
13492: LD_INT 31
13494: PUSH
13495: LD_INT 32
13497: PUSH
13498: LD_INT 33
13500: PUSH
13501: LD_INT 34
13503: PUSH
13504: EMPTY
13505: LIST
13506: LIST
13507: LIST
13508: LIST
13509: LIST
13510: LIST
13511: LIST
13512: LIST
13513: LIST
13514: LIST
13515: LIST
13516: LIST
13517: LIST
13518: LIST
13519: LIST
13520: LIST
13521: LIST
13522: LIST
13523: LIST
13524: PUSH
13525: LD_INT 101
13527: PUSH
13528: LD_INT 102
13530: PUSH
13531: LD_INT 103
13533: PUSH
13534: LD_INT 106
13536: PUSH
13537: LD_INT 108
13539: PUSH
13540: LD_INT 112
13542: PUSH
13543: LD_INT 113
13545: PUSH
13546: LD_INT 114
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: LIST
13553: LIST
13554: LIST
13555: LIST
13556: LIST
13557: LIST
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: ST_TO_ADDR
13563: GO 14158
13565: LD_INT 17
13567: DOUBLE
13568: EQUAL
13569: IFTRUE 13573
13571: GO 13785
13573: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
13574: LD_ADDR_VAR 0 1
13578: PUSH
13579: LD_INT 1
13581: PUSH
13582: LD_INT 2
13584: PUSH
13585: LD_INT 3
13587: PUSH
13588: LD_INT 4
13590: PUSH
13591: LD_INT 5
13593: PUSH
13594: LD_INT 6
13596: PUSH
13597: LD_INT 7
13599: PUSH
13600: LD_INT 8
13602: PUSH
13603: LD_INT 9
13605: PUSH
13606: LD_INT 10
13608: PUSH
13609: LD_INT 11
13611: PUSH
13612: LD_INT 12
13614: PUSH
13615: LD_INT 13
13617: PUSH
13618: LD_INT 14
13620: PUSH
13621: LD_INT 15
13623: PUSH
13624: LD_INT 16
13626: PUSH
13627: LD_INT 17
13629: PUSH
13630: LD_INT 18
13632: PUSH
13633: LD_INT 19
13635: PUSH
13636: LD_INT 20
13638: PUSH
13639: LD_INT 21
13641: PUSH
13642: LD_INT 22
13644: PUSH
13645: LD_INT 23
13647: PUSH
13648: LD_INT 24
13650: PUSH
13651: LD_INT 25
13653: PUSH
13654: LD_INT 26
13656: PUSH
13657: LD_INT 27
13659: PUSH
13660: LD_INT 28
13662: PUSH
13663: LD_INT 29
13665: PUSH
13666: LD_INT 30
13668: PUSH
13669: LD_INT 31
13671: PUSH
13672: LD_INT 32
13674: PUSH
13675: LD_INT 33
13677: PUSH
13678: LD_INT 34
13680: PUSH
13681: LD_INT 36
13683: PUSH
13684: EMPTY
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: LIST
13707: LIST
13708: LIST
13709: LIST
13710: LIST
13711: LIST
13712: LIST
13713: LIST
13714: LIST
13715: LIST
13716: LIST
13717: LIST
13718: LIST
13719: LIST
13720: PUSH
13721: LD_INT 101
13723: PUSH
13724: LD_INT 102
13726: PUSH
13727: LD_INT 103
13729: PUSH
13730: LD_INT 104
13732: PUSH
13733: LD_INT 105
13735: PUSH
13736: LD_INT 106
13738: PUSH
13739: LD_INT 107
13741: PUSH
13742: LD_INT 108
13744: PUSH
13745: LD_INT 109
13747: PUSH
13748: LD_INT 110
13750: PUSH
13751: LD_INT 111
13753: PUSH
13754: LD_INT 112
13756: PUSH
13757: LD_INT 113
13759: PUSH
13760: LD_INT 114
13762: PUSH
13763: EMPTY
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: LIST
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: ST_TO_ADDR
13783: GO 14158
13785: LD_INT 18
13787: DOUBLE
13788: EQUAL
13789: IFTRUE 13793
13791: GO 13929
13793: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
13794: LD_ADDR_VAR 0 1
13798: PUSH
13799: LD_INT 2
13801: PUSH
13802: LD_INT 4
13804: PUSH
13805: LD_INT 5
13807: PUSH
13808: LD_INT 7
13810: PUSH
13811: LD_INT 11
13813: PUSH
13814: LD_INT 12
13816: PUSH
13817: LD_INT 15
13819: PUSH
13820: LD_INT 16
13822: PUSH
13823: LD_INT 20
13825: PUSH
13826: LD_INT 21
13828: PUSH
13829: LD_INT 22
13831: PUSH
13832: LD_INT 23
13834: PUSH
13835: LD_INT 25
13837: PUSH
13838: LD_INT 26
13840: PUSH
13841: LD_INT 30
13843: PUSH
13844: LD_INT 31
13846: PUSH
13847: LD_INT 32
13849: PUSH
13850: LD_INT 33
13852: PUSH
13853: LD_INT 34
13855: PUSH
13856: LD_INT 35
13858: PUSH
13859: LD_INT 36
13861: PUSH
13862: EMPTY
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: LIST
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: PUSH
13885: LD_INT 101
13887: PUSH
13888: LD_INT 102
13890: PUSH
13891: LD_INT 103
13893: PUSH
13894: LD_INT 106
13896: PUSH
13897: LD_INT 108
13899: PUSH
13900: LD_INT 112
13902: PUSH
13903: LD_INT 113
13905: PUSH
13906: LD_INT 114
13908: PUSH
13909: LD_INT 115
13911: PUSH
13912: EMPTY
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: LIST
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: ST_TO_ADDR
13927: GO 14158
13929: LD_INT 19
13931: DOUBLE
13932: EQUAL
13933: IFTRUE 13937
13935: GO 14157
13937: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
13938: LD_ADDR_VAR 0 1
13942: PUSH
13943: LD_INT 1
13945: PUSH
13946: LD_INT 2
13948: PUSH
13949: LD_INT 3
13951: PUSH
13952: LD_INT 4
13954: PUSH
13955: LD_INT 5
13957: PUSH
13958: LD_INT 6
13960: PUSH
13961: LD_INT 7
13963: PUSH
13964: LD_INT 8
13966: PUSH
13967: LD_INT 9
13969: PUSH
13970: LD_INT 10
13972: PUSH
13973: LD_INT 11
13975: PUSH
13976: LD_INT 12
13978: PUSH
13979: LD_INT 13
13981: PUSH
13982: LD_INT 14
13984: PUSH
13985: LD_INT 15
13987: PUSH
13988: LD_INT 16
13990: PUSH
13991: LD_INT 17
13993: PUSH
13994: LD_INT 18
13996: PUSH
13997: LD_INT 19
13999: PUSH
14000: LD_INT 20
14002: PUSH
14003: LD_INT 21
14005: PUSH
14006: LD_INT 22
14008: PUSH
14009: LD_INT 23
14011: PUSH
14012: LD_INT 24
14014: PUSH
14015: LD_INT 25
14017: PUSH
14018: LD_INT 26
14020: PUSH
14021: LD_INT 27
14023: PUSH
14024: LD_INT 28
14026: PUSH
14027: LD_INT 29
14029: PUSH
14030: LD_INT 30
14032: PUSH
14033: LD_INT 31
14035: PUSH
14036: LD_INT 32
14038: PUSH
14039: LD_INT 33
14041: PUSH
14042: LD_INT 34
14044: PUSH
14045: LD_INT 35
14047: PUSH
14048: LD_INT 36
14050: PUSH
14051: EMPTY
14052: LIST
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: LIST
14058: LIST
14059: LIST
14060: LIST
14061: LIST
14062: LIST
14063: LIST
14064: LIST
14065: LIST
14066: LIST
14067: LIST
14068: LIST
14069: LIST
14070: LIST
14071: LIST
14072: LIST
14073: LIST
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: LIST
14085: LIST
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 101
14091: PUSH
14092: LD_INT 102
14094: PUSH
14095: LD_INT 103
14097: PUSH
14098: LD_INT 104
14100: PUSH
14101: LD_INT 105
14103: PUSH
14104: LD_INT 106
14106: PUSH
14107: LD_INT 107
14109: PUSH
14110: LD_INT 108
14112: PUSH
14113: LD_INT 109
14115: PUSH
14116: LD_INT 110
14118: PUSH
14119: LD_INT 111
14121: PUSH
14122: LD_INT 112
14124: PUSH
14125: LD_INT 113
14127: PUSH
14128: LD_INT 114
14130: PUSH
14131: LD_INT 115
14133: PUSH
14134: EMPTY
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: ST_TO_ADDR
14155: GO 14158
14157: POP
// end else
14158: GO 14195
// if campaign_id = 5 then
14160: LD_OWVAR 69
14164: PUSH
14165: LD_INT 5
14167: EQUAL
14168: IFFALSE 14195
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
14170: LD_ADDR_VAR 0 1
14174: PUSH
14175: LD_INT 1
14177: PUSH
14178: LD_INT 2
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: PUSH
14185: LD_INT 100
14187: PUSH
14188: EMPTY
14189: LIST
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: ST_TO_ADDR
// end ; if result then
14195: LD_VAR 0 1
14199: IFFALSE 14488
// begin normal :=  ;
14201: LD_ADDR_VAR 0 3
14205: PUSH
14206: LD_STRING 
14208: ST_TO_ADDR
// hardcore :=  ;
14209: LD_ADDR_VAR 0 4
14213: PUSH
14214: LD_STRING 
14216: ST_TO_ADDR
// for i = 1 to normalCounter do
14217: LD_ADDR_VAR 0 5
14221: PUSH
14222: DOUBLE
14223: LD_INT 1
14225: DEC
14226: ST_TO_ADDR
14227: LD_EXP 35
14231: PUSH
14232: FOR_TO
14233: IFFALSE 14334
// begin tmp := 0 ;
14235: LD_ADDR_VAR 0 2
14239: PUSH
14240: LD_STRING 0
14242: ST_TO_ADDR
// if result [ 1 ] then
14243: LD_VAR 0 1
14247: PUSH
14248: LD_INT 1
14250: ARRAY
14251: IFFALSE 14316
// if result [ 1 ] [ 1 ] = i then
14253: LD_VAR 0 1
14257: PUSH
14258: LD_INT 1
14260: ARRAY
14261: PUSH
14262: LD_INT 1
14264: ARRAY
14265: PUSH
14266: LD_VAR 0 5
14270: EQUAL
14271: IFFALSE 14316
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
14273: LD_ADDR_VAR 0 1
14277: PUSH
14278: LD_VAR 0 1
14282: PPUSH
14283: LD_INT 1
14285: PPUSH
14286: LD_VAR 0 1
14290: PUSH
14291: LD_INT 1
14293: ARRAY
14294: PPUSH
14295: LD_INT 1
14297: PPUSH
14298: CALL_OW 3
14302: PPUSH
14303: CALL_OW 1
14307: ST_TO_ADDR
// tmp := 1 ;
14308: LD_ADDR_VAR 0 2
14312: PUSH
14313: LD_STRING 1
14315: ST_TO_ADDR
// end ; normal := normal & tmp ;
14316: LD_ADDR_VAR 0 3
14320: PUSH
14321: LD_VAR 0 3
14325: PUSH
14326: LD_VAR 0 2
14330: STR
14331: ST_TO_ADDR
// end ;
14332: GO 14232
14334: POP
14335: POP
// for i = 1 to hardcoreCounter do
14336: LD_ADDR_VAR 0 5
14340: PUSH
14341: DOUBLE
14342: LD_INT 1
14344: DEC
14345: ST_TO_ADDR
14346: LD_EXP 36
14350: PUSH
14351: FOR_TO
14352: IFFALSE 14457
// begin tmp := 0 ;
14354: LD_ADDR_VAR 0 2
14358: PUSH
14359: LD_STRING 0
14361: ST_TO_ADDR
// if result [ 2 ] then
14362: LD_VAR 0 1
14366: PUSH
14367: LD_INT 2
14369: ARRAY
14370: IFFALSE 14439
// if result [ 2 ] [ 1 ] = 100 + i then
14372: LD_VAR 0 1
14376: PUSH
14377: LD_INT 2
14379: ARRAY
14380: PUSH
14381: LD_INT 1
14383: ARRAY
14384: PUSH
14385: LD_INT 100
14387: PUSH
14388: LD_VAR 0 5
14392: PLUS
14393: EQUAL
14394: IFFALSE 14439
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
14396: LD_ADDR_VAR 0 1
14400: PUSH
14401: LD_VAR 0 1
14405: PPUSH
14406: LD_INT 2
14408: PPUSH
14409: LD_VAR 0 1
14413: PUSH
14414: LD_INT 2
14416: ARRAY
14417: PPUSH
14418: LD_INT 1
14420: PPUSH
14421: CALL_OW 3
14425: PPUSH
14426: CALL_OW 1
14430: ST_TO_ADDR
// tmp := 1 ;
14431: LD_ADDR_VAR 0 2
14435: PUSH
14436: LD_STRING 1
14438: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
14439: LD_ADDR_VAR 0 4
14443: PUSH
14444: LD_VAR 0 4
14448: PUSH
14449: LD_VAR 0 2
14453: STR
14454: ST_TO_ADDR
// end ;
14455: GO 14351
14457: POP
14458: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
14459: LD_STRING getStreamItemsFromMission("
14461: PUSH
14462: LD_VAR 0 3
14466: STR
14467: PUSH
14468: LD_STRING ","
14470: STR
14471: PUSH
14472: LD_VAR 0 4
14476: STR
14477: PUSH
14478: LD_STRING ")
14480: STR
14481: PPUSH
14482: CALL_OW 559
// end else
14486: GO 14495
// ToLua ( getStreamItemsFromMission("","") ) ;
14488: LD_STRING getStreamItemsFromMission("","")
14490: PPUSH
14491: CALL_OW 559
// end ;
14495: LD_VAR 0 1
14499: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
14500: LD_VAR 0 2
14504: PUSH
14505: LD_INT 100
14507: EQUAL
14508: IFFALSE 15457
// begin if not StreamModeActive then
14510: LD_EXP 34
14514: NOT
14515: IFFALSE 14525
// StreamModeActive := true ;
14517: LD_ADDR_EXP 34
14521: PUSH
14522: LD_INT 1
14524: ST_TO_ADDR
// if p3 = 0 then
14525: LD_VAR 0 3
14529: PUSH
14530: LD_INT 0
14532: EQUAL
14533: IFFALSE 14539
// InitStreamMode ;
14535: CALL 10760 0 0
// if p3 = 1 then
14539: LD_VAR 0 3
14543: PUSH
14544: LD_INT 1
14546: EQUAL
14547: IFFALSE 14557
// sRocket := true ;
14549: LD_ADDR_EXP 39
14553: PUSH
14554: LD_INT 1
14556: ST_TO_ADDR
// if p3 = 2 then
14557: LD_VAR 0 3
14561: PUSH
14562: LD_INT 2
14564: EQUAL
14565: IFFALSE 14575
// sSpeed := true ;
14567: LD_ADDR_EXP 38
14571: PUSH
14572: LD_INT 1
14574: ST_TO_ADDR
// if p3 = 3 then
14575: LD_VAR 0 3
14579: PUSH
14580: LD_INT 3
14582: EQUAL
14583: IFFALSE 14593
// sEngine := true ;
14585: LD_ADDR_EXP 40
14589: PUSH
14590: LD_INT 1
14592: ST_TO_ADDR
// if p3 = 4 then
14593: LD_VAR 0 3
14597: PUSH
14598: LD_INT 4
14600: EQUAL
14601: IFFALSE 14611
// sSpec := true ;
14603: LD_ADDR_EXP 37
14607: PUSH
14608: LD_INT 1
14610: ST_TO_ADDR
// if p3 = 5 then
14611: LD_VAR 0 3
14615: PUSH
14616: LD_INT 5
14618: EQUAL
14619: IFFALSE 14629
// sLevel := true ;
14621: LD_ADDR_EXP 41
14625: PUSH
14626: LD_INT 1
14628: ST_TO_ADDR
// if p3 = 6 then
14629: LD_VAR 0 3
14633: PUSH
14634: LD_INT 6
14636: EQUAL
14637: IFFALSE 14647
// sArmoury := true ;
14639: LD_ADDR_EXP 42
14643: PUSH
14644: LD_INT 1
14646: ST_TO_ADDR
// if p3 = 7 then
14647: LD_VAR 0 3
14651: PUSH
14652: LD_INT 7
14654: EQUAL
14655: IFFALSE 14665
// sRadar := true ;
14657: LD_ADDR_EXP 43
14661: PUSH
14662: LD_INT 1
14664: ST_TO_ADDR
// if p3 = 8 then
14665: LD_VAR 0 3
14669: PUSH
14670: LD_INT 8
14672: EQUAL
14673: IFFALSE 14683
// sBunker := true ;
14675: LD_ADDR_EXP 44
14679: PUSH
14680: LD_INT 1
14682: ST_TO_ADDR
// if p3 = 9 then
14683: LD_VAR 0 3
14687: PUSH
14688: LD_INT 9
14690: EQUAL
14691: IFFALSE 14701
// sHack := true ;
14693: LD_ADDR_EXP 45
14697: PUSH
14698: LD_INT 1
14700: ST_TO_ADDR
// if p3 = 10 then
14701: LD_VAR 0 3
14705: PUSH
14706: LD_INT 10
14708: EQUAL
14709: IFFALSE 14719
// sFire := true ;
14711: LD_ADDR_EXP 46
14715: PUSH
14716: LD_INT 1
14718: ST_TO_ADDR
// if p3 = 11 then
14719: LD_VAR 0 3
14723: PUSH
14724: LD_INT 11
14726: EQUAL
14727: IFFALSE 14737
// sRefresh := true ;
14729: LD_ADDR_EXP 47
14733: PUSH
14734: LD_INT 1
14736: ST_TO_ADDR
// if p3 = 12 then
14737: LD_VAR 0 3
14741: PUSH
14742: LD_INT 12
14744: EQUAL
14745: IFFALSE 14755
// sExp := true ;
14747: LD_ADDR_EXP 48
14751: PUSH
14752: LD_INT 1
14754: ST_TO_ADDR
// if p3 = 13 then
14755: LD_VAR 0 3
14759: PUSH
14760: LD_INT 13
14762: EQUAL
14763: IFFALSE 14773
// sDepot := true ;
14765: LD_ADDR_EXP 49
14769: PUSH
14770: LD_INT 1
14772: ST_TO_ADDR
// if p3 = 14 then
14773: LD_VAR 0 3
14777: PUSH
14778: LD_INT 14
14780: EQUAL
14781: IFFALSE 14791
// sFlag := true ;
14783: LD_ADDR_EXP 50
14787: PUSH
14788: LD_INT 1
14790: ST_TO_ADDR
// if p3 = 15 then
14791: LD_VAR 0 3
14795: PUSH
14796: LD_INT 15
14798: EQUAL
14799: IFFALSE 14809
// sKamikadze := true ;
14801: LD_ADDR_EXP 58
14805: PUSH
14806: LD_INT 1
14808: ST_TO_ADDR
// if p3 = 16 then
14809: LD_VAR 0 3
14813: PUSH
14814: LD_INT 16
14816: EQUAL
14817: IFFALSE 14827
// sTroll := true ;
14819: LD_ADDR_EXP 59
14823: PUSH
14824: LD_INT 1
14826: ST_TO_ADDR
// if p3 = 17 then
14827: LD_VAR 0 3
14831: PUSH
14832: LD_INT 17
14834: EQUAL
14835: IFFALSE 14845
// sSlow := true ;
14837: LD_ADDR_EXP 60
14841: PUSH
14842: LD_INT 1
14844: ST_TO_ADDR
// if p3 = 18 then
14845: LD_VAR 0 3
14849: PUSH
14850: LD_INT 18
14852: EQUAL
14853: IFFALSE 14863
// sLack := true ;
14855: LD_ADDR_EXP 61
14859: PUSH
14860: LD_INT 1
14862: ST_TO_ADDR
// if p3 = 19 then
14863: LD_VAR 0 3
14867: PUSH
14868: LD_INT 19
14870: EQUAL
14871: IFFALSE 14881
// sTank := true ;
14873: LD_ADDR_EXP 63
14877: PUSH
14878: LD_INT 1
14880: ST_TO_ADDR
// if p3 = 20 then
14881: LD_VAR 0 3
14885: PUSH
14886: LD_INT 20
14888: EQUAL
14889: IFFALSE 14899
// sRemote := true ;
14891: LD_ADDR_EXP 64
14895: PUSH
14896: LD_INT 1
14898: ST_TO_ADDR
// if p3 = 21 then
14899: LD_VAR 0 3
14903: PUSH
14904: LD_INT 21
14906: EQUAL
14907: IFFALSE 14917
// sPowell := true ;
14909: LD_ADDR_EXP 65
14913: PUSH
14914: LD_INT 1
14916: ST_TO_ADDR
// if p3 = 22 then
14917: LD_VAR 0 3
14921: PUSH
14922: LD_INT 22
14924: EQUAL
14925: IFFALSE 14935
// sTeleport := true ;
14927: LD_ADDR_EXP 68
14931: PUSH
14932: LD_INT 1
14934: ST_TO_ADDR
// if p3 = 23 then
14935: LD_VAR 0 3
14939: PUSH
14940: LD_INT 23
14942: EQUAL
14943: IFFALSE 14953
// sOilTower := true ;
14945: LD_ADDR_EXP 70
14949: PUSH
14950: LD_INT 1
14952: ST_TO_ADDR
// if p3 = 24 then
14953: LD_VAR 0 3
14957: PUSH
14958: LD_INT 24
14960: EQUAL
14961: IFFALSE 14971
// sShovel := true ;
14963: LD_ADDR_EXP 71
14967: PUSH
14968: LD_INT 1
14970: ST_TO_ADDR
// if p3 = 25 then
14971: LD_VAR 0 3
14975: PUSH
14976: LD_INT 25
14978: EQUAL
14979: IFFALSE 14989
// sSheik := true ;
14981: LD_ADDR_EXP 72
14985: PUSH
14986: LD_INT 1
14988: ST_TO_ADDR
// if p3 = 26 then
14989: LD_VAR 0 3
14993: PUSH
14994: LD_INT 26
14996: EQUAL
14997: IFFALSE 15007
// sEarthquake := true ;
14999: LD_ADDR_EXP 74
15003: PUSH
15004: LD_INT 1
15006: ST_TO_ADDR
// if p3 = 27 then
15007: LD_VAR 0 3
15011: PUSH
15012: LD_INT 27
15014: EQUAL
15015: IFFALSE 15025
// sAI := true ;
15017: LD_ADDR_EXP 75
15021: PUSH
15022: LD_INT 1
15024: ST_TO_ADDR
// if p3 = 28 then
15025: LD_VAR 0 3
15029: PUSH
15030: LD_INT 28
15032: EQUAL
15033: IFFALSE 15043
// sCargo := true ;
15035: LD_ADDR_EXP 78
15039: PUSH
15040: LD_INT 1
15042: ST_TO_ADDR
// if p3 = 29 then
15043: LD_VAR 0 3
15047: PUSH
15048: LD_INT 29
15050: EQUAL
15051: IFFALSE 15061
// sDLaser := true ;
15053: LD_ADDR_EXP 79
15057: PUSH
15058: LD_INT 1
15060: ST_TO_ADDR
// if p3 = 30 then
15061: LD_VAR 0 3
15065: PUSH
15066: LD_INT 30
15068: EQUAL
15069: IFFALSE 15079
// sExchange := true ;
15071: LD_ADDR_EXP 80
15075: PUSH
15076: LD_INT 1
15078: ST_TO_ADDR
// if p3 = 31 then
15079: LD_VAR 0 3
15083: PUSH
15084: LD_INT 31
15086: EQUAL
15087: IFFALSE 15097
// sFac := true ;
15089: LD_ADDR_EXP 81
15093: PUSH
15094: LD_INT 1
15096: ST_TO_ADDR
// if p3 = 32 then
15097: LD_VAR 0 3
15101: PUSH
15102: LD_INT 32
15104: EQUAL
15105: IFFALSE 15115
// sPower := true ;
15107: LD_ADDR_EXP 82
15111: PUSH
15112: LD_INT 1
15114: ST_TO_ADDR
// if p3 = 33 then
15115: LD_VAR 0 3
15119: PUSH
15120: LD_INT 33
15122: EQUAL
15123: IFFALSE 15133
// sRandom := true ;
15125: LD_ADDR_EXP 83
15129: PUSH
15130: LD_INT 1
15132: ST_TO_ADDR
// if p3 = 34 then
15133: LD_VAR 0 3
15137: PUSH
15138: LD_INT 34
15140: EQUAL
15141: IFFALSE 15151
// sShield := true ;
15143: LD_ADDR_EXP 84
15147: PUSH
15148: LD_INT 1
15150: ST_TO_ADDR
// if p3 = 35 then
15151: LD_VAR 0 3
15155: PUSH
15156: LD_INT 35
15158: EQUAL
15159: IFFALSE 15169
// sTime := true ;
15161: LD_ADDR_EXP 85
15165: PUSH
15166: LD_INT 1
15168: ST_TO_ADDR
// if p3 = 36 then
15169: LD_VAR 0 3
15173: PUSH
15174: LD_INT 36
15176: EQUAL
15177: IFFALSE 15187
// sTools := true ;
15179: LD_ADDR_EXP 86
15183: PUSH
15184: LD_INT 1
15186: ST_TO_ADDR
// if p3 = 101 then
15187: LD_VAR 0 3
15191: PUSH
15192: LD_INT 101
15194: EQUAL
15195: IFFALSE 15205
// sSold := true ;
15197: LD_ADDR_EXP 51
15201: PUSH
15202: LD_INT 1
15204: ST_TO_ADDR
// if p3 = 102 then
15205: LD_VAR 0 3
15209: PUSH
15210: LD_INT 102
15212: EQUAL
15213: IFFALSE 15223
// sDiff := true ;
15215: LD_ADDR_EXP 52
15219: PUSH
15220: LD_INT 1
15222: ST_TO_ADDR
// if p3 = 103 then
15223: LD_VAR 0 3
15227: PUSH
15228: LD_INT 103
15230: EQUAL
15231: IFFALSE 15241
// sFog := true ;
15233: LD_ADDR_EXP 55
15237: PUSH
15238: LD_INT 1
15240: ST_TO_ADDR
// if p3 = 104 then
15241: LD_VAR 0 3
15245: PUSH
15246: LD_INT 104
15248: EQUAL
15249: IFFALSE 15259
// sReset := true ;
15251: LD_ADDR_EXP 56
15255: PUSH
15256: LD_INT 1
15258: ST_TO_ADDR
// if p3 = 105 then
15259: LD_VAR 0 3
15263: PUSH
15264: LD_INT 105
15266: EQUAL
15267: IFFALSE 15277
// sSun := true ;
15269: LD_ADDR_EXP 57
15273: PUSH
15274: LD_INT 1
15276: ST_TO_ADDR
// if p3 = 106 then
15277: LD_VAR 0 3
15281: PUSH
15282: LD_INT 106
15284: EQUAL
15285: IFFALSE 15295
// sTiger := true ;
15287: LD_ADDR_EXP 53
15291: PUSH
15292: LD_INT 1
15294: ST_TO_ADDR
// if p3 = 107 then
15295: LD_VAR 0 3
15299: PUSH
15300: LD_INT 107
15302: EQUAL
15303: IFFALSE 15313
// sBomb := true ;
15305: LD_ADDR_EXP 54
15309: PUSH
15310: LD_INT 1
15312: ST_TO_ADDR
// if p3 = 108 then
15313: LD_VAR 0 3
15317: PUSH
15318: LD_INT 108
15320: EQUAL
15321: IFFALSE 15331
// sWound := true ;
15323: LD_ADDR_EXP 62
15327: PUSH
15328: LD_INT 1
15330: ST_TO_ADDR
// if p3 = 109 then
15331: LD_VAR 0 3
15335: PUSH
15336: LD_INT 109
15338: EQUAL
15339: IFFALSE 15349
// sBetray := true ;
15341: LD_ADDR_EXP 66
15345: PUSH
15346: LD_INT 1
15348: ST_TO_ADDR
// if p3 = 110 then
15349: LD_VAR 0 3
15353: PUSH
15354: LD_INT 110
15356: EQUAL
15357: IFFALSE 15367
// sContamin := true ;
15359: LD_ADDR_EXP 67
15363: PUSH
15364: LD_INT 1
15366: ST_TO_ADDR
// if p3 = 111 then
15367: LD_VAR 0 3
15371: PUSH
15372: LD_INT 111
15374: EQUAL
15375: IFFALSE 15385
// sOil := true ;
15377: LD_ADDR_EXP 69
15381: PUSH
15382: LD_INT 1
15384: ST_TO_ADDR
// if p3 = 112 then
15385: LD_VAR 0 3
15389: PUSH
15390: LD_INT 112
15392: EQUAL
15393: IFFALSE 15403
// sStu := true ;
15395: LD_ADDR_EXP 73
15399: PUSH
15400: LD_INT 1
15402: ST_TO_ADDR
// if p3 = 113 then
15403: LD_VAR 0 3
15407: PUSH
15408: LD_INT 113
15410: EQUAL
15411: IFFALSE 15421
// sBazooka := true ;
15413: LD_ADDR_EXP 76
15417: PUSH
15418: LD_INT 1
15420: ST_TO_ADDR
// if p3 = 114 then
15421: LD_VAR 0 3
15425: PUSH
15426: LD_INT 114
15428: EQUAL
15429: IFFALSE 15439
// sMortar := true ;
15431: LD_ADDR_EXP 77
15435: PUSH
15436: LD_INT 1
15438: ST_TO_ADDR
// if p3 = 115 then
15439: LD_VAR 0 3
15443: PUSH
15444: LD_INT 115
15446: EQUAL
15447: IFFALSE 15457
// sRanger := true ;
15449: LD_ADDR_EXP 87
15453: PUSH
15454: LD_INT 1
15456: ST_TO_ADDR
// end ; end ;
15457: PPOPN 6
15459: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
15460: LD_EXP 34
15464: PUSH
15465: LD_EXP 39
15469: AND
15470: IFFALSE 15594
15472: GO 15474
15474: DISABLE
15475: LD_INT 0
15477: PPUSH
15478: PPUSH
// begin enable ;
15479: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
15480: LD_ADDR_VAR 0 2
15484: PUSH
15485: LD_INT 22
15487: PUSH
15488: LD_OWVAR 2
15492: PUSH
15493: EMPTY
15494: LIST
15495: LIST
15496: PUSH
15497: LD_INT 2
15499: PUSH
15500: LD_INT 34
15502: PUSH
15503: LD_INT 7
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 34
15512: PUSH
15513: LD_INT 45
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 34
15522: PUSH
15523: LD_INT 28
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: LD_INT 34
15532: PUSH
15533: LD_INT 47
15535: PUSH
15536: EMPTY
15537: LIST
15538: LIST
15539: PUSH
15540: EMPTY
15541: LIST
15542: LIST
15543: LIST
15544: LIST
15545: LIST
15546: PUSH
15547: EMPTY
15548: LIST
15549: LIST
15550: PPUSH
15551: CALL_OW 69
15555: ST_TO_ADDR
// if not tmp then
15556: LD_VAR 0 2
15560: NOT
15561: IFFALSE 15565
// exit ;
15563: GO 15594
// for i in tmp do
15565: LD_ADDR_VAR 0 1
15569: PUSH
15570: LD_VAR 0 2
15574: PUSH
15575: FOR_IN
15576: IFFALSE 15592
// begin SetLives ( i , 0 ) ;
15578: LD_VAR 0 1
15582: PPUSH
15583: LD_INT 0
15585: PPUSH
15586: CALL_OW 234
// end ;
15590: GO 15575
15592: POP
15593: POP
// end ;
15594: PPOPN 2
15596: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
15597: LD_EXP 34
15601: PUSH
15602: LD_EXP 40
15606: AND
15607: IFFALSE 15691
15609: GO 15611
15611: DISABLE
15612: LD_INT 0
15614: PPUSH
15615: PPUSH
// begin enable ;
15616: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
15617: LD_ADDR_VAR 0 2
15621: PUSH
15622: LD_INT 22
15624: PUSH
15625: LD_OWVAR 2
15629: PUSH
15630: EMPTY
15631: LIST
15632: LIST
15633: PUSH
15634: LD_INT 32
15636: PUSH
15637: LD_INT 3
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: PUSH
15644: EMPTY
15645: LIST
15646: LIST
15647: PPUSH
15648: CALL_OW 69
15652: ST_TO_ADDR
// if not tmp then
15653: LD_VAR 0 2
15657: NOT
15658: IFFALSE 15662
// exit ;
15660: GO 15691
// for i in tmp do
15662: LD_ADDR_VAR 0 1
15666: PUSH
15667: LD_VAR 0 2
15671: PUSH
15672: FOR_IN
15673: IFFALSE 15689
// begin SetLives ( i , 0 ) ;
15675: LD_VAR 0 1
15679: PPUSH
15680: LD_INT 0
15682: PPUSH
15683: CALL_OW 234
// end ;
15687: GO 15672
15689: POP
15690: POP
// end ;
15691: PPOPN 2
15693: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
15694: LD_EXP 34
15698: PUSH
15699: LD_EXP 37
15703: AND
15704: IFFALSE 15797
15706: GO 15708
15708: DISABLE
15709: LD_INT 0
15711: PPUSH
// begin enable ;
15712: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
15713: LD_ADDR_VAR 0 1
15717: PUSH
15718: LD_INT 22
15720: PUSH
15721: LD_OWVAR 2
15725: PUSH
15726: EMPTY
15727: LIST
15728: LIST
15729: PUSH
15730: LD_INT 2
15732: PUSH
15733: LD_INT 25
15735: PUSH
15736: LD_INT 5
15738: PUSH
15739: EMPTY
15740: LIST
15741: LIST
15742: PUSH
15743: LD_INT 25
15745: PUSH
15746: LD_INT 9
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PUSH
15753: LD_INT 25
15755: PUSH
15756: LD_INT 8
15758: PUSH
15759: EMPTY
15760: LIST
15761: LIST
15762: PUSH
15763: EMPTY
15764: LIST
15765: LIST
15766: LIST
15767: LIST
15768: PUSH
15769: EMPTY
15770: LIST
15771: LIST
15772: PPUSH
15773: CALL_OW 69
15777: PUSH
15778: FOR_IN
15779: IFFALSE 15795
// begin SetClass ( i , 1 ) ;
15781: LD_VAR 0 1
15785: PPUSH
15786: LD_INT 1
15788: PPUSH
15789: CALL_OW 336
// end ;
15793: GO 15778
15795: POP
15796: POP
// end ;
15797: PPOPN 1
15799: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
15800: LD_EXP 34
15804: PUSH
15805: LD_EXP 38
15809: AND
15810: PUSH
15811: LD_OWVAR 65
15815: PUSH
15816: LD_INT 7
15818: LESS
15819: AND
15820: IFFALSE 15834
15822: GO 15824
15824: DISABLE
// begin enable ;
15825: ENABLE
// game_speed := 7 ;
15826: LD_ADDR_OWVAR 65
15830: PUSH
15831: LD_INT 7
15833: ST_TO_ADDR
// end ;
15834: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
15835: LD_EXP 34
15839: PUSH
15840: LD_EXP 41
15844: AND
15845: IFFALSE 16047
15847: GO 15849
15849: DISABLE
15850: LD_INT 0
15852: PPUSH
15853: PPUSH
15854: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
15855: LD_ADDR_VAR 0 3
15859: PUSH
15860: LD_INT 81
15862: PUSH
15863: LD_OWVAR 2
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: PUSH
15872: LD_INT 21
15874: PUSH
15875: LD_INT 1
15877: PUSH
15878: EMPTY
15879: LIST
15880: LIST
15881: PUSH
15882: EMPTY
15883: LIST
15884: LIST
15885: PPUSH
15886: CALL_OW 69
15890: ST_TO_ADDR
// if not tmp then
15891: LD_VAR 0 3
15895: NOT
15896: IFFALSE 15900
// exit ;
15898: GO 16047
// if tmp > 5 then
15900: LD_VAR 0 3
15904: PUSH
15905: LD_INT 5
15907: GREATER
15908: IFFALSE 15920
// k := 5 else
15910: LD_ADDR_VAR 0 2
15914: PUSH
15915: LD_INT 5
15917: ST_TO_ADDR
15918: GO 15930
// k := tmp ;
15920: LD_ADDR_VAR 0 2
15924: PUSH
15925: LD_VAR 0 3
15929: ST_TO_ADDR
// for i := 1 to k do
15930: LD_ADDR_VAR 0 1
15934: PUSH
15935: DOUBLE
15936: LD_INT 1
15938: DEC
15939: ST_TO_ADDR
15940: LD_VAR 0 2
15944: PUSH
15945: FOR_TO
15946: IFFALSE 16045
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
15948: LD_VAR 0 3
15952: PUSH
15953: LD_VAR 0 1
15957: ARRAY
15958: PPUSH
15959: LD_VAR 0 1
15963: PUSH
15964: LD_INT 4
15966: MOD
15967: PUSH
15968: LD_INT 1
15970: PLUS
15971: PPUSH
15972: CALL_OW 259
15976: PUSH
15977: LD_INT 10
15979: LESS
15980: IFFALSE 16043
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
15982: LD_VAR 0 3
15986: PUSH
15987: LD_VAR 0 1
15991: ARRAY
15992: PPUSH
15993: LD_VAR 0 1
15997: PUSH
15998: LD_INT 4
16000: MOD
16001: PUSH
16002: LD_INT 1
16004: PLUS
16005: PPUSH
16006: LD_VAR 0 3
16010: PUSH
16011: LD_VAR 0 1
16015: ARRAY
16016: PPUSH
16017: LD_VAR 0 1
16021: PUSH
16022: LD_INT 4
16024: MOD
16025: PUSH
16026: LD_INT 1
16028: PLUS
16029: PPUSH
16030: CALL_OW 259
16034: PUSH
16035: LD_INT 1
16037: PLUS
16038: PPUSH
16039: CALL_OW 237
16043: GO 15945
16045: POP
16046: POP
// end ;
16047: PPOPN 3
16049: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16050: LD_EXP 34
16054: PUSH
16055: LD_EXP 42
16059: AND
16060: IFFALSE 16080
16062: GO 16064
16064: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16065: LD_INT 4
16067: PPUSH
16068: LD_OWVAR 2
16072: PPUSH
16073: LD_INT 0
16075: PPUSH
16076: CALL_OW 324
16080: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16081: LD_EXP 34
16085: PUSH
16086: LD_EXP 71
16090: AND
16091: IFFALSE 16111
16093: GO 16095
16095: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16096: LD_INT 19
16098: PPUSH
16099: LD_OWVAR 2
16103: PPUSH
16104: LD_INT 0
16106: PPUSH
16107: CALL_OW 324
16111: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16112: LD_EXP 34
16116: PUSH
16117: LD_EXP 43
16121: AND
16122: IFFALSE 16224
16124: GO 16126
16126: DISABLE
16127: LD_INT 0
16129: PPUSH
16130: PPUSH
// begin enable ;
16131: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16132: LD_ADDR_VAR 0 2
16136: PUSH
16137: LD_INT 22
16139: PUSH
16140: LD_OWVAR 2
16144: PUSH
16145: EMPTY
16146: LIST
16147: LIST
16148: PUSH
16149: LD_INT 2
16151: PUSH
16152: LD_INT 34
16154: PUSH
16155: LD_INT 11
16157: PUSH
16158: EMPTY
16159: LIST
16160: LIST
16161: PUSH
16162: LD_INT 34
16164: PUSH
16165: LD_INT 30
16167: PUSH
16168: EMPTY
16169: LIST
16170: LIST
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: LIST
16176: PUSH
16177: EMPTY
16178: LIST
16179: LIST
16180: PPUSH
16181: CALL_OW 69
16185: ST_TO_ADDR
// if not tmp then
16186: LD_VAR 0 2
16190: NOT
16191: IFFALSE 16195
// exit ;
16193: GO 16224
// for i in tmp do
16195: LD_ADDR_VAR 0 1
16199: PUSH
16200: LD_VAR 0 2
16204: PUSH
16205: FOR_IN
16206: IFFALSE 16222
// begin SetLives ( i , 0 ) ;
16208: LD_VAR 0 1
16212: PPUSH
16213: LD_INT 0
16215: PPUSH
16216: CALL_OW 234
// end ;
16220: GO 16205
16222: POP
16223: POP
// end ;
16224: PPOPN 2
16226: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16227: LD_EXP 34
16231: PUSH
16232: LD_EXP 44
16236: AND
16237: IFFALSE 16257
16239: GO 16241
16241: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16242: LD_INT 32
16244: PPUSH
16245: LD_OWVAR 2
16249: PPUSH
16250: LD_INT 0
16252: PPUSH
16253: CALL_OW 324
16257: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16258: LD_EXP 34
16262: PUSH
16263: LD_EXP 45
16267: AND
16268: IFFALSE 16449
16270: GO 16272
16272: DISABLE
16273: LD_INT 0
16275: PPUSH
16276: PPUSH
16277: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
16278: LD_ADDR_VAR 0 2
16282: PUSH
16283: LD_INT 22
16285: PUSH
16286: LD_OWVAR 2
16290: PUSH
16291: EMPTY
16292: LIST
16293: LIST
16294: PUSH
16295: LD_INT 33
16297: PUSH
16298: LD_INT 3
16300: PUSH
16301: EMPTY
16302: LIST
16303: LIST
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: PPUSH
16309: CALL_OW 69
16313: ST_TO_ADDR
// if not tmp then
16314: LD_VAR 0 2
16318: NOT
16319: IFFALSE 16323
// exit ;
16321: GO 16449
// side := 0 ;
16323: LD_ADDR_VAR 0 3
16327: PUSH
16328: LD_INT 0
16330: ST_TO_ADDR
// for i := 1 to 8 do
16331: LD_ADDR_VAR 0 1
16335: PUSH
16336: DOUBLE
16337: LD_INT 1
16339: DEC
16340: ST_TO_ADDR
16341: LD_INT 8
16343: PUSH
16344: FOR_TO
16345: IFFALSE 16393
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
16347: LD_OWVAR 2
16351: PUSH
16352: LD_VAR 0 1
16356: NONEQUAL
16357: PUSH
16358: LD_OWVAR 2
16362: PPUSH
16363: LD_VAR 0 1
16367: PPUSH
16368: CALL_OW 81
16372: PUSH
16373: LD_INT 2
16375: EQUAL
16376: AND
16377: IFFALSE 16391
// begin side := i ;
16379: LD_ADDR_VAR 0 3
16383: PUSH
16384: LD_VAR 0 1
16388: ST_TO_ADDR
// break ;
16389: GO 16393
// end ;
16391: GO 16344
16393: POP
16394: POP
// if not side then
16395: LD_VAR 0 3
16399: NOT
16400: IFFALSE 16404
// exit ;
16402: GO 16449
// for i := 1 to tmp do
16404: LD_ADDR_VAR 0 1
16408: PUSH
16409: DOUBLE
16410: LD_INT 1
16412: DEC
16413: ST_TO_ADDR
16414: LD_VAR 0 2
16418: PUSH
16419: FOR_TO
16420: IFFALSE 16447
// if Prob ( 60 ) then
16422: LD_INT 60
16424: PPUSH
16425: CALL_OW 13
16429: IFFALSE 16445
// SetSide ( i , side ) ;
16431: LD_VAR 0 1
16435: PPUSH
16436: LD_VAR 0 3
16440: PPUSH
16441: CALL_OW 235
16445: GO 16419
16447: POP
16448: POP
// end ;
16449: PPOPN 3
16451: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
16452: LD_EXP 34
16456: PUSH
16457: LD_EXP 47
16461: AND
16462: IFFALSE 16581
16464: GO 16466
16466: DISABLE
16467: LD_INT 0
16469: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
16470: LD_ADDR_VAR 0 1
16474: PUSH
16475: LD_INT 22
16477: PUSH
16478: LD_OWVAR 2
16482: PUSH
16483: EMPTY
16484: LIST
16485: LIST
16486: PUSH
16487: LD_INT 21
16489: PUSH
16490: LD_INT 1
16492: PUSH
16493: EMPTY
16494: LIST
16495: LIST
16496: PUSH
16497: LD_INT 3
16499: PUSH
16500: LD_INT 23
16502: PUSH
16503: LD_INT 0
16505: PUSH
16506: EMPTY
16507: LIST
16508: LIST
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: LIST
16518: PPUSH
16519: CALL_OW 69
16523: PUSH
16524: FOR_IN
16525: IFFALSE 16579
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
16527: LD_VAR 0 1
16531: PPUSH
16532: CALL_OW 257
16536: PUSH
16537: LD_INT 1
16539: PUSH
16540: LD_INT 2
16542: PUSH
16543: LD_INT 3
16545: PUSH
16546: LD_INT 4
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: LIST
16553: LIST
16554: IN
16555: IFFALSE 16577
// SetClass ( un , rand ( 1 , 4 ) ) ;
16557: LD_VAR 0 1
16561: PPUSH
16562: LD_INT 1
16564: PPUSH
16565: LD_INT 4
16567: PPUSH
16568: CALL_OW 12
16572: PPUSH
16573: CALL_OW 336
16577: GO 16524
16579: POP
16580: POP
// end ;
16581: PPOPN 1
16583: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
16584: LD_EXP 34
16588: PUSH
16589: LD_EXP 46
16593: AND
16594: IFFALSE 16673
16596: GO 16598
16598: DISABLE
16599: LD_INT 0
16601: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
16602: LD_ADDR_VAR 0 1
16606: PUSH
16607: LD_INT 22
16609: PUSH
16610: LD_OWVAR 2
16614: PUSH
16615: EMPTY
16616: LIST
16617: LIST
16618: PUSH
16619: LD_INT 21
16621: PUSH
16622: LD_INT 3
16624: PUSH
16625: EMPTY
16626: LIST
16627: LIST
16628: PUSH
16629: EMPTY
16630: LIST
16631: LIST
16632: PPUSH
16633: CALL_OW 69
16637: ST_TO_ADDR
// if not tmp then
16638: LD_VAR 0 1
16642: NOT
16643: IFFALSE 16647
// exit ;
16645: GO 16673
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
16647: LD_VAR 0 1
16651: PUSH
16652: LD_INT 1
16654: PPUSH
16655: LD_VAR 0 1
16659: PPUSH
16660: CALL_OW 12
16664: ARRAY
16665: PPUSH
16666: LD_INT 100
16668: PPUSH
16669: CALL_OW 234
// end ;
16673: PPOPN 1
16675: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
16676: LD_EXP 34
16680: PUSH
16681: LD_EXP 48
16685: AND
16686: IFFALSE 16784
16688: GO 16690
16690: DISABLE
16691: LD_INT 0
16693: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16694: LD_ADDR_VAR 0 1
16698: PUSH
16699: LD_INT 22
16701: PUSH
16702: LD_OWVAR 2
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: PUSH
16711: LD_INT 21
16713: PUSH
16714: LD_INT 1
16716: PUSH
16717: EMPTY
16718: LIST
16719: LIST
16720: PUSH
16721: EMPTY
16722: LIST
16723: LIST
16724: PPUSH
16725: CALL_OW 69
16729: ST_TO_ADDR
// if not tmp then
16730: LD_VAR 0 1
16734: NOT
16735: IFFALSE 16739
// exit ;
16737: GO 16784
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
16739: LD_VAR 0 1
16743: PUSH
16744: LD_INT 1
16746: PPUSH
16747: LD_VAR 0 1
16751: PPUSH
16752: CALL_OW 12
16756: ARRAY
16757: PPUSH
16758: LD_INT 1
16760: PPUSH
16761: LD_INT 4
16763: PPUSH
16764: CALL_OW 12
16768: PPUSH
16769: LD_INT 3000
16771: PPUSH
16772: LD_INT 9000
16774: PPUSH
16775: CALL_OW 12
16779: PPUSH
16780: CALL_OW 492
// end ;
16784: PPOPN 1
16786: END
// every 0 0$1 trigger StreamModeActive and sDepot do
16787: LD_EXP 34
16791: PUSH
16792: LD_EXP 49
16796: AND
16797: IFFALSE 16817
16799: GO 16801
16801: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
16802: LD_INT 1
16804: PPUSH
16805: LD_OWVAR 2
16809: PPUSH
16810: LD_INT 0
16812: PPUSH
16813: CALL_OW 324
16817: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
16818: LD_EXP 34
16822: PUSH
16823: LD_EXP 50
16827: AND
16828: IFFALSE 16911
16830: GO 16832
16832: DISABLE
16833: LD_INT 0
16835: PPUSH
16836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
16837: LD_ADDR_VAR 0 2
16841: PUSH
16842: LD_INT 22
16844: PUSH
16845: LD_OWVAR 2
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: PUSH
16854: LD_INT 21
16856: PUSH
16857: LD_INT 3
16859: PUSH
16860: EMPTY
16861: LIST
16862: LIST
16863: PUSH
16864: EMPTY
16865: LIST
16866: LIST
16867: PPUSH
16868: CALL_OW 69
16872: ST_TO_ADDR
// if not tmp then
16873: LD_VAR 0 2
16877: NOT
16878: IFFALSE 16882
// exit ;
16880: GO 16911
// for i in tmp do
16882: LD_ADDR_VAR 0 1
16886: PUSH
16887: LD_VAR 0 2
16891: PUSH
16892: FOR_IN
16893: IFFALSE 16909
// SetBLevel ( i , 10 ) ;
16895: LD_VAR 0 1
16899: PPUSH
16900: LD_INT 10
16902: PPUSH
16903: CALL_OW 241
16907: GO 16892
16909: POP
16910: POP
// end ;
16911: PPOPN 2
16913: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
16914: LD_EXP 34
16918: PUSH
16919: LD_EXP 51
16923: AND
16924: IFFALSE 17035
16926: GO 16928
16928: DISABLE
16929: LD_INT 0
16931: PPUSH
16932: PPUSH
16933: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
16934: LD_ADDR_VAR 0 3
16938: PUSH
16939: LD_INT 22
16941: PUSH
16942: LD_OWVAR 2
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PUSH
16951: LD_INT 25
16953: PUSH
16954: LD_INT 1
16956: PUSH
16957: EMPTY
16958: LIST
16959: LIST
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: PPUSH
16965: CALL_OW 69
16969: ST_TO_ADDR
// if not tmp then
16970: LD_VAR 0 3
16974: NOT
16975: IFFALSE 16979
// exit ;
16977: GO 17035
// un := tmp [ rand ( 1 , tmp ) ] ;
16979: LD_ADDR_VAR 0 2
16983: PUSH
16984: LD_VAR 0 3
16988: PUSH
16989: LD_INT 1
16991: PPUSH
16992: LD_VAR 0 3
16996: PPUSH
16997: CALL_OW 12
17001: ARRAY
17002: ST_TO_ADDR
// if Crawls ( un ) then
17003: LD_VAR 0 2
17007: PPUSH
17008: CALL_OW 318
17012: IFFALSE 17023
// ComWalk ( un ) ;
17014: LD_VAR 0 2
17018: PPUSH
17019: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17023: LD_VAR 0 2
17027: PPUSH
17028: LD_INT 5
17030: PPUSH
17031: CALL_OW 336
// end ;
17035: PPOPN 3
17037: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17038: LD_EXP 34
17042: PUSH
17043: LD_EXP 52
17047: AND
17048: PUSH
17049: LD_OWVAR 67
17053: PUSH
17054: LD_INT 3
17056: LESS
17057: AND
17058: IFFALSE 17077
17060: GO 17062
17062: DISABLE
// Difficulty := Difficulty + 1 ;
17063: LD_ADDR_OWVAR 67
17067: PUSH
17068: LD_OWVAR 67
17072: PUSH
17073: LD_INT 1
17075: PLUS
17076: ST_TO_ADDR
17077: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17078: LD_EXP 34
17082: PUSH
17083: LD_EXP 53
17087: AND
17088: IFFALSE 17191
17090: GO 17092
17092: DISABLE
17093: LD_INT 0
17095: PPUSH
// begin for i := 1 to 5 do
17096: LD_ADDR_VAR 0 1
17100: PUSH
17101: DOUBLE
17102: LD_INT 1
17104: DEC
17105: ST_TO_ADDR
17106: LD_INT 5
17108: PUSH
17109: FOR_TO
17110: IFFALSE 17189
// begin uc_nation := nation_nature ;
17112: LD_ADDR_OWVAR 21
17116: PUSH
17117: LD_INT 0
17119: ST_TO_ADDR
// uc_side := 0 ;
17120: LD_ADDR_OWVAR 20
17124: PUSH
17125: LD_INT 0
17127: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17128: LD_ADDR_OWVAR 29
17132: PUSH
17133: LD_INT 12
17135: PUSH
17136: LD_INT 12
17138: PUSH
17139: EMPTY
17140: LIST
17141: LIST
17142: ST_TO_ADDR
// hc_agressivity := 20 ;
17143: LD_ADDR_OWVAR 35
17147: PUSH
17148: LD_INT 20
17150: ST_TO_ADDR
// hc_class := class_tiger ;
17151: LD_ADDR_OWVAR 28
17155: PUSH
17156: LD_INT 14
17158: ST_TO_ADDR
// hc_gallery :=  ;
17159: LD_ADDR_OWVAR 33
17163: PUSH
17164: LD_STRING 
17166: ST_TO_ADDR
// hc_name :=  ;
17167: LD_ADDR_OWVAR 26
17171: PUSH
17172: LD_STRING 
17174: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17175: CALL_OW 44
17179: PPUSH
17180: LD_INT 0
17182: PPUSH
17183: CALL_OW 51
// end ;
17187: GO 17109
17189: POP
17190: POP
// end ;
17191: PPOPN 1
17193: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17194: LD_EXP 34
17198: PUSH
17199: LD_EXP 54
17203: AND
17204: IFFALSE 17213
17206: GO 17208
17208: DISABLE
// StreamSibBomb ;
17209: CALL 17214 0 0
17213: END
// export function StreamSibBomb ; var i , x , y ; begin
17214: LD_INT 0
17216: PPUSH
17217: PPUSH
17218: PPUSH
17219: PPUSH
// result := false ;
17220: LD_ADDR_VAR 0 1
17224: PUSH
17225: LD_INT 0
17227: ST_TO_ADDR
// for i := 1 to 16 do
17228: LD_ADDR_VAR 0 2
17232: PUSH
17233: DOUBLE
17234: LD_INT 1
17236: DEC
17237: ST_TO_ADDR
17238: LD_INT 16
17240: PUSH
17241: FOR_TO
17242: IFFALSE 17441
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17244: LD_ADDR_VAR 0 3
17248: PUSH
17249: LD_INT 10
17251: PUSH
17252: LD_INT 20
17254: PUSH
17255: LD_INT 30
17257: PUSH
17258: LD_INT 40
17260: PUSH
17261: LD_INT 50
17263: PUSH
17264: LD_INT 60
17266: PUSH
17267: LD_INT 70
17269: PUSH
17270: LD_INT 80
17272: PUSH
17273: LD_INT 90
17275: PUSH
17276: LD_INT 100
17278: PUSH
17279: LD_INT 110
17281: PUSH
17282: LD_INT 120
17284: PUSH
17285: LD_INT 130
17287: PUSH
17288: LD_INT 140
17290: PUSH
17291: LD_INT 150
17293: PUSH
17294: EMPTY
17295: LIST
17296: LIST
17297: LIST
17298: LIST
17299: LIST
17300: LIST
17301: LIST
17302: LIST
17303: LIST
17304: LIST
17305: LIST
17306: LIST
17307: LIST
17308: LIST
17309: LIST
17310: PUSH
17311: LD_INT 1
17313: PPUSH
17314: LD_INT 15
17316: PPUSH
17317: CALL_OW 12
17321: ARRAY
17322: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17323: LD_ADDR_VAR 0 4
17327: PUSH
17328: LD_INT 10
17330: PUSH
17331: LD_INT 20
17333: PUSH
17334: LD_INT 30
17336: PUSH
17337: LD_INT 40
17339: PUSH
17340: LD_INT 50
17342: PUSH
17343: LD_INT 60
17345: PUSH
17346: LD_INT 70
17348: PUSH
17349: LD_INT 80
17351: PUSH
17352: LD_INT 90
17354: PUSH
17355: LD_INT 100
17357: PUSH
17358: LD_INT 110
17360: PUSH
17361: LD_INT 120
17363: PUSH
17364: LD_INT 130
17366: PUSH
17367: LD_INT 140
17369: PUSH
17370: LD_INT 150
17372: PUSH
17373: EMPTY
17374: LIST
17375: LIST
17376: LIST
17377: LIST
17378: LIST
17379: LIST
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: LIST
17385: LIST
17386: LIST
17387: LIST
17388: LIST
17389: PUSH
17390: LD_INT 1
17392: PPUSH
17393: LD_INT 15
17395: PPUSH
17396: CALL_OW 12
17400: ARRAY
17401: ST_TO_ADDR
// if ValidHex ( x , y ) then
17402: LD_VAR 0 3
17406: PPUSH
17407: LD_VAR 0 4
17411: PPUSH
17412: CALL_OW 488
17416: IFFALSE 17439
// begin result := [ x , y ] ;
17418: LD_ADDR_VAR 0 1
17422: PUSH
17423: LD_VAR 0 3
17427: PUSH
17428: LD_VAR 0 4
17432: PUSH
17433: EMPTY
17434: LIST
17435: LIST
17436: ST_TO_ADDR
// break ;
17437: GO 17441
// end ; end ;
17439: GO 17241
17441: POP
17442: POP
// if result then
17443: LD_VAR 0 1
17447: IFFALSE 17507
// begin ToLua ( playSibBomb() ) ;
17449: LD_STRING playSibBomb()
17451: PPUSH
17452: CALL_OW 559
// wait ( 0 0$14 ) ;
17456: LD_INT 490
17458: PPUSH
17459: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
17463: LD_VAR 0 1
17467: PUSH
17468: LD_INT 1
17470: ARRAY
17471: PPUSH
17472: LD_VAR 0 1
17476: PUSH
17477: LD_INT 2
17479: ARRAY
17480: PPUSH
17481: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
17485: LD_VAR 0 1
17489: PUSH
17490: LD_INT 1
17492: ARRAY
17493: PPUSH
17494: LD_VAR 0 1
17498: PUSH
17499: LD_INT 2
17501: ARRAY
17502: PPUSH
17503: CALL_OW 429
// end ; end ;
17507: LD_VAR 0 1
17511: RET
// every 0 0$1 trigger StreamModeActive and sReset do
17512: LD_EXP 34
17516: PUSH
17517: LD_EXP 56
17521: AND
17522: IFFALSE 17534
17524: GO 17526
17526: DISABLE
// YouLost (  ) ;
17527: LD_STRING 
17529: PPUSH
17530: CALL_OW 104
17534: END
// every 0 0$1 trigger StreamModeActive and sFog do
17535: LD_EXP 34
17539: PUSH
17540: LD_EXP 55
17544: AND
17545: IFFALSE 17559
17547: GO 17549
17549: DISABLE
// FogOff ( your_side ) ;
17550: LD_OWVAR 2
17554: PPUSH
17555: CALL_OW 344
17559: END
// every 0 0$1 trigger StreamModeActive and sSun do
17560: LD_EXP 34
17564: PUSH
17565: LD_EXP 57
17569: AND
17570: IFFALSE 17598
17572: GO 17574
17574: DISABLE
// begin solar_recharge_percent := 0 ;
17575: LD_ADDR_OWVAR 79
17579: PUSH
17580: LD_INT 0
17582: ST_TO_ADDR
// wait ( 5 5$00 ) ;
17583: LD_INT 10500
17585: PPUSH
17586: CALL_OW 67
// solar_recharge_percent := 100 ;
17590: LD_ADDR_OWVAR 79
17594: PUSH
17595: LD_INT 100
17597: ST_TO_ADDR
// end ;
17598: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
17599: LD_EXP 34
17603: PUSH
17604: LD_EXP 58
17608: AND
17609: IFFALSE 17848
17611: GO 17613
17613: DISABLE
17614: LD_INT 0
17616: PPUSH
17617: PPUSH
17618: PPUSH
// begin tmp := [ ] ;
17619: LD_ADDR_VAR 0 3
17623: PUSH
17624: EMPTY
17625: ST_TO_ADDR
// for i := 1 to 6 do
17626: LD_ADDR_VAR 0 1
17630: PUSH
17631: DOUBLE
17632: LD_INT 1
17634: DEC
17635: ST_TO_ADDR
17636: LD_INT 6
17638: PUSH
17639: FOR_TO
17640: IFFALSE 17745
// begin uc_nation := nation_nature ;
17642: LD_ADDR_OWVAR 21
17646: PUSH
17647: LD_INT 0
17649: ST_TO_ADDR
// uc_side := 0 ;
17650: LD_ADDR_OWVAR 20
17654: PUSH
17655: LD_INT 0
17657: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17658: LD_ADDR_OWVAR 29
17662: PUSH
17663: LD_INT 12
17665: PUSH
17666: LD_INT 12
17668: PUSH
17669: EMPTY
17670: LIST
17671: LIST
17672: ST_TO_ADDR
// hc_agressivity := 20 ;
17673: LD_ADDR_OWVAR 35
17677: PUSH
17678: LD_INT 20
17680: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
17681: LD_ADDR_OWVAR 28
17685: PUSH
17686: LD_INT 17
17688: ST_TO_ADDR
// hc_gallery :=  ;
17689: LD_ADDR_OWVAR 33
17693: PUSH
17694: LD_STRING 
17696: ST_TO_ADDR
// hc_name :=  ;
17697: LD_ADDR_OWVAR 26
17701: PUSH
17702: LD_STRING 
17704: ST_TO_ADDR
// un := CreateHuman ;
17705: LD_ADDR_VAR 0 2
17709: PUSH
17710: CALL_OW 44
17714: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
17715: LD_VAR 0 2
17719: PPUSH
17720: LD_INT 1
17722: PPUSH
17723: CALL_OW 51
// tmp := tmp ^ un ;
17727: LD_ADDR_VAR 0 3
17731: PUSH
17732: LD_VAR 0 3
17736: PUSH
17737: LD_VAR 0 2
17741: ADD
17742: ST_TO_ADDR
// end ;
17743: GO 17639
17745: POP
17746: POP
// repeat wait ( 0 0$1 ) ;
17747: LD_INT 35
17749: PPUSH
17750: CALL_OW 67
// for un in tmp do
17754: LD_ADDR_VAR 0 2
17758: PUSH
17759: LD_VAR 0 3
17763: PUSH
17764: FOR_IN
17765: IFFALSE 17839
// begin if IsDead ( un ) then
17767: LD_VAR 0 2
17771: PPUSH
17772: CALL_OW 301
17776: IFFALSE 17796
// begin tmp := tmp diff un ;
17778: LD_ADDR_VAR 0 3
17782: PUSH
17783: LD_VAR 0 3
17787: PUSH
17788: LD_VAR 0 2
17792: DIFF
17793: ST_TO_ADDR
// continue ;
17794: GO 17764
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
17796: LD_VAR 0 2
17800: PPUSH
17801: LD_INT 3
17803: PUSH
17804: LD_INT 22
17806: PUSH
17807: LD_INT 0
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: PUSH
17814: EMPTY
17815: LIST
17816: LIST
17817: PPUSH
17818: CALL_OW 69
17822: PPUSH
17823: LD_VAR 0 2
17827: PPUSH
17828: CALL_OW 74
17832: PPUSH
17833: CALL_OW 115
// end ;
17837: GO 17764
17839: POP
17840: POP
// until not tmp ;
17841: LD_VAR 0 3
17845: NOT
17846: IFFALSE 17747
// end ;
17848: PPOPN 3
17850: END
// every 0 0$1 trigger StreamModeActive and sTroll do
17851: LD_EXP 34
17855: PUSH
17856: LD_EXP 59
17860: AND
17861: IFFALSE 17915
17863: GO 17865
17865: DISABLE
// begin ToLua ( displayTroll(); ) ;
17866: LD_STRING displayTroll();
17868: PPUSH
17869: CALL_OW 559
// wait ( 3 3$00 ) ;
17873: LD_INT 6300
17875: PPUSH
17876: CALL_OW 67
// ToLua ( hideTroll(); ) ;
17880: LD_STRING hideTroll();
17882: PPUSH
17883: CALL_OW 559
// wait ( 1 1$00 ) ;
17887: LD_INT 2100
17889: PPUSH
17890: CALL_OW 67
// ToLua ( displayTroll(); ) ;
17894: LD_STRING displayTroll();
17896: PPUSH
17897: CALL_OW 559
// wait ( 1 1$00 ) ;
17901: LD_INT 2100
17903: PPUSH
17904: CALL_OW 67
// ToLua ( hideTroll(); ) ;
17908: LD_STRING hideTroll();
17910: PPUSH
17911: CALL_OW 559
// end ;
17915: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
17916: LD_EXP 34
17920: PUSH
17921: LD_EXP 60
17925: AND
17926: IFFALSE 17989
17928: GO 17930
17930: DISABLE
17931: LD_INT 0
17933: PPUSH
// begin p := 0 ;
17934: LD_ADDR_VAR 0 1
17938: PUSH
17939: LD_INT 0
17941: ST_TO_ADDR
// repeat game_speed := 1 ;
17942: LD_ADDR_OWVAR 65
17946: PUSH
17947: LD_INT 1
17949: ST_TO_ADDR
// wait ( 0 0$1 ) ;
17950: LD_INT 35
17952: PPUSH
17953: CALL_OW 67
// p := p + 1 ;
17957: LD_ADDR_VAR 0 1
17961: PUSH
17962: LD_VAR 0 1
17966: PUSH
17967: LD_INT 1
17969: PLUS
17970: ST_TO_ADDR
// until p >= 60 ;
17971: LD_VAR 0 1
17975: PUSH
17976: LD_INT 60
17978: GREATEREQUAL
17979: IFFALSE 17942
// game_speed := 4 ;
17981: LD_ADDR_OWVAR 65
17985: PUSH
17986: LD_INT 4
17988: ST_TO_ADDR
// end ;
17989: PPOPN 1
17991: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
17992: LD_EXP 34
17996: PUSH
17997: LD_EXP 61
18001: AND
18002: IFFALSE 18148
18004: GO 18006
18006: DISABLE
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18011: LD_ADDR_VAR 0 1
18015: PUSH
18016: LD_INT 22
18018: PUSH
18019: LD_OWVAR 2
18023: PUSH
18024: EMPTY
18025: LIST
18026: LIST
18027: PUSH
18028: LD_INT 2
18030: PUSH
18031: LD_INT 30
18033: PUSH
18034: LD_INT 0
18036: PUSH
18037: EMPTY
18038: LIST
18039: LIST
18040: PUSH
18041: LD_INT 30
18043: PUSH
18044: LD_INT 1
18046: PUSH
18047: EMPTY
18048: LIST
18049: LIST
18050: PUSH
18051: EMPTY
18052: LIST
18053: LIST
18054: LIST
18055: PUSH
18056: EMPTY
18057: LIST
18058: LIST
18059: PPUSH
18060: CALL_OW 69
18064: ST_TO_ADDR
// if not depot then
18065: LD_VAR 0 1
18069: NOT
18070: IFFALSE 18074
// exit ;
18072: GO 18148
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18074: LD_ADDR_VAR 0 2
18078: PUSH
18079: LD_VAR 0 1
18083: PUSH
18084: LD_INT 1
18086: PPUSH
18087: LD_VAR 0 1
18091: PPUSH
18092: CALL_OW 12
18096: ARRAY
18097: PPUSH
18098: CALL_OW 274
18102: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18103: LD_VAR 0 2
18107: PPUSH
18108: LD_INT 1
18110: PPUSH
18111: LD_INT 0
18113: PPUSH
18114: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18118: LD_VAR 0 2
18122: PPUSH
18123: LD_INT 2
18125: PPUSH
18126: LD_INT 0
18128: PPUSH
18129: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18133: LD_VAR 0 2
18137: PPUSH
18138: LD_INT 3
18140: PPUSH
18141: LD_INT 0
18143: PPUSH
18144: CALL_OW 277
// end ;
18148: PPOPN 2
18150: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18151: LD_EXP 34
18155: PUSH
18156: LD_EXP 62
18160: AND
18161: IFFALSE 18258
18163: GO 18165
18165: DISABLE
18166: LD_INT 0
18168: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18169: LD_ADDR_VAR 0 1
18173: PUSH
18174: LD_INT 22
18176: PUSH
18177: LD_OWVAR 2
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: PUSH
18186: LD_INT 21
18188: PUSH
18189: LD_INT 1
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: PUSH
18196: LD_INT 3
18198: PUSH
18199: LD_INT 23
18201: PUSH
18202: LD_INT 0
18204: PUSH
18205: EMPTY
18206: LIST
18207: LIST
18208: PUSH
18209: EMPTY
18210: LIST
18211: LIST
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: PPUSH
18218: CALL_OW 69
18222: ST_TO_ADDR
// if not tmp then
18223: LD_VAR 0 1
18227: NOT
18228: IFFALSE 18232
// exit ;
18230: GO 18258
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18232: LD_VAR 0 1
18236: PUSH
18237: LD_INT 1
18239: PPUSH
18240: LD_VAR 0 1
18244: PPUSH
18245: CALL_OW 12
18249: ARRAY
18250: PPUSH
18251: LD_INT 200
18253: PPUSH
18254: CALL_OW 234
// end ;
18258: PPOPN 1
18260: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
18261: LD_EXP 34
18265: PUSH
18266: LD_EXP 63
18270: AND
18271: IFFALSE 18350
18273: GO 18275
18275: DISABLE
18276: LD_INT 0
18278: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
18279: LD_ADDR_VAR 0 1
18283: PUSH
18284: LD_INT 22
18286: PUSH
18287: LD_OWVAR 2
18291: PUSH
18292: EMPTY
18293: LIST
18294: LIST
18295: PUSH
18296: LD_INT 21
18298: PUSH
18299: LD_INT 2
18301: PUSH
18302: EMPTY
18303: LIST
18304: LIST
18305: PUSH
18306: EMPTY
18307: LIST
18308: LIST
18309: PPUSH
18310: CALL_OW 69
18314: ST_TO_ADDR
// if not tmp then
18315: LD_VAR 0 1
18319: NOT
18320: IFFALSE 18324
// exit ;
18322: GO 18350
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
18324: LD_VAR 0 1
18328: PUSH
18329: LD_INT 1
18331: PPUSH
18332: LD_VAR 0 1
18336: PPUSH
18337: CALL_OW 12
18341: ARRAY
18342: PPUSH
18343: LD_INT 60
18345: PPUSH
18346: CALL_OW 234
// end ;
18350: PPOPN 1
18352: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
18353: LD_EXP 34
18357: PUSH
18358: LD_EXP 64
18362: AND
18363: IFFALSE 18462
18365: GO 18367
18367: DISABLE
18368: LD_INT 0
18370: PPUSH
18371: PPUSH
// begin enable ;
18372: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
18373: LD_ADDR_VAR 0 1
18377: PUSH
18378: LD_INT 22
18380: PUSH
18381: LD_OWVAR 2
18385: PUSH
18386: EMPTY
18387: LIST
18388: LIST
18389: PUSH
18390: LD_INT 61
18392: PUSH
18393: EMPTY
18394: LIST
18395: PUSH
18396: LD_INT 33
18398: PUSH
18399: LD_INT 2
18401: PUSH
18402: EMPTY
18403: LIST
18404: LIST
18405: PUSH
18406: EMPTY
18407: LIST
18408: LIST
18409: LIST
18410: PPUSH
18411: CALL_OW 69
18415: ST_TO_ADDR
// if not tmp then
18416: LD_VAR 0 1
18420: NOT
18421: IFFALSE 18425
// exit ;
18423: GO 18462
// for i in tmp do
18425: LD_ADDR_VAR 0 2
18429: PUSH
18430: LD_VAR 0 1
18434: PUSH
18435: FOR_IN
18436: IFFALSE 18460
// if IsControledBy ( i ) then
18438: LD_VAR 0 2
18442: PPUSH
18443: CALL_OW 312
18447: IFFALSE 18458
// ComUnlink ( i ) ;
18449: LD_VAR 0 2
18453: PPUSH
18454: CALL_OW 136
18458: GO 18435
18460: POP
18461: POP
// end ;
18462: PPOPN 2
18464: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
18465: LD_EXP 34
18469: PUSH
18470: LD_EXP 65
18474: AND
18475: IFFALSE 18615
18477: GO 18479
18479: DISABLE
18480: LD_INT 0
18482: PPUSH
18483: PPUSH
// begin ToLua ( displayPowell(); ) ;
18484: LD_STRING displayPowell();
18486: PPUSH
18487: CALL_OW 559
// uc_side := 0 ;
18491: LD_ADDR_OWVAR 20
18495: PUSH
18496: LD_INT 0
18498: ST_TO_ADDR
// uc_nation := 2 ;
18499: LD_ADDR_OWVAR 21
18503: PUSH
18504: LD_INT 2
18506: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
18507: LD_ADDR_OWVAR 37
18511: PUSH
18512: LD_INT 14
18514: ST_TO_ADDR
// vc_engine := engine_siberite ;
18515: LD_ADDR_OWVAR 39
18519: PUSH
18520: LD_INT 3
18522: ST_TO_ADDR
// vc_control := control_apeman ;
18523: LD_ADDR_OWVAR 38
18527: PUSH
18528: LD_INT 5
18530: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
18531: LD_ADDR_OWVAR 40
18535: PUSH
18536: LD_INT 29
18538: ST_TO_ADDR
// un := CreateVehicle ;
18539: LD_ADDR_VAR 0 2
18543: PUSH
18544: CALL_OW 45
18548: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18549: LD_VAR 0 2
18553: PPUSH
18554: LD_INT 1
18556: PPUSH
18557: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18561: LD_INT 35
18563: PPUSH
18564: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18568: LD_VAR 0 2
18572: PPUSH
18573: LD_INT 22
18575: PUSH
18576: LD_OWVAR 2
18580: PUSH
18581: EMPTY
18582: LIST
18583: LIST
18584: PPUSH
18585: CALL_OW 69
18589: PPUSH
18590: LD_VAR 0 2
18594: PPUSH
18595: CALL_OW 74
18599: PPUSH
18600: CALL_OW 115
// until IsDead ( un ) ;
18604: LD_VAR 0 2
18608: PPUSH
18609: CALL_OW 301
18613: IFFALSE 18561
// end ;
18615: PPOPN 2
18617: END
// every 0 0$1 trigger StreamModeActive and sStu do
18618: LD_EXP 34
18622: PUSH
18623: LD_EXP 73
18627: AND
18628: IFFALSE 18644
18630: GO 18632
18632: DISABLE
// begin ToLua ( displayStucuk(); ) ;
18633: LD_STRING displayStucuk();
18635: PPUSH
18636: CALL_OW 559
// ResetFog ;
18640: CALL_OW 335
// end ;
18644: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
18645: LD_EXP 34
18649: PUSH
18650: LD_EXP 66
18654: AND
18655: IFFALSE 18796
18657: GO 18659
18659: DISABLE
18660: LD_INT 0
18662: PPUSH
18663: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18664: LD_ADDR_VAR 0 2
18668: PUSH
18669: LD_INT 22
18671: PUSH
18672: LD_OWVAR 2
18676: PUSH
18677: EMPTY
18678: LIST
18679: LIST
18680: PUSH
18681: LD_INT 21
18683: PUSH
18684: LD_INT 1
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: PPUSH
18695: CALL_OW 69
18699: ST_TO_ADDR
// if not tmp then
18700: LD_VAR 0 2
18704: NOT
18705: IFFALSE 18709
// exit ;
18707: GO 18796
// un := tmp [ rand ( 1 , tmp ) ] ;
18709: LD_ADDR_VAR 0 1
18713: PUSH
18714: LD_VAR 0 2
18718: PUSH
18719: LD_INT 1
18721: PPUSH
18722: LD_VAR 0 2
18726: PPUSH
18727: CALL_OW 12
18731: ARRAY
18732: ST_TO_ADDR
// SetSide ( un , 0 ) ;
18733: LD_VAR 0 1
18737: PPUSH
18738: LD_INT 0
18740: PPUSH
18741: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
18745: LD_VAR 0 1
18749: PPUSH
18750: LD_OWVAR 3
18754: PUSH
18755: LD_VAR 0 1
18759: DIFF
18760: PPUSH
18761: LD_VAR 0 1
18765: PPUSH
18766: CALL_OW 74
18770: PPUSH
18771: CALL_OW 115
// wait ( 0 0$20 ) ;
18775: LD_INT 700
18777: PPUSH
18778: CALL_OW 67
// SetSide ( un , your_side ) ;
18782: LD_VAR 0 1
18786: PPUSH
18787: LD_OWVAR 2
18791: PPUSH
18792: CALL_OW 235
// end ;
18796: PPOPN 2
18798: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
18799: LD_EXP 34
18803: PUSH
18804: LD_EXP 67
18808: AND
18809: IFFALSE 18915
18811: GO 18813
18813: DISABLE
18814: LD_INT 0
18816: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18817: LD_ADDR_VAR 0 1
18821: PUSH
18822: LD_INT 22
18824: PUSH
18825: LD_OWVAR 2
18829: PUSH
18830: EMPTY
18831: LIST
18832: LIST
18833: PUSH
18834: LD_INT 2
18836: PUSH
18837: LD_INT 30
18839: PUSH
18840: LD_INT 0
18842: PUSH
18843: EMPTY
18844: LIST
18845: LIST
18846: PUSH
18847: LD_INT 30
18849: PUSH
18850: LD_INT 1
18852: PUSH
18853: EMPTY
18854: LIST
18855: LIST
18856: PUSH
18857: EMPTY
18858: LIST
18859: LIST
18860: LIST
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PPUSH
18866: CALL_OW 69
18870: ST_TO_ADDR
// if not depot then
18871: LD_VAR 0 1
18875: NOT
18876: IFFALSE 18880
// exit ;
18878: GO 18915
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
18880: LD_VAR 0 1
18884: PUSH
18885: LD_INT 1
18887: ARRAY
18888: PPUSH
18889: CALL_OW 250
18893: PPUSH
18894: LD_VAR 0 1
18898: PUSH
18899: LD_INT 1
18901: ARRAY
18902: PPUSH
18903: CALL_OW 251
18907: PPUSH
18908: LD_INT 70
18910: PPUSH
18911: CALL_OW 495
// end ;
18915: PPOPN 1
18917: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
18918: LD_EXP 34
18922: PUSH
18923: LD_EXP 68
18927: AND
18928: IFFALSE 19139
18930: GO 18932
18932: DISABLE
18933: LD_INT 0
18935: PPUSH
18936: PPUSH
18937: PPUSH
18938: PPUSH
18939: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18940: LD_ADDR_VAR 0 5
18944: PUSH
18945: LD_INT 22
18947: PUSH
18948: LD_OWVAR 2
18952: PUSH
18953: EMPTY
18954: LIST
18955: LIST
18956: PUSH
18957: LD_INT 21
18959: PUSH
18960: LD_INT 1
18962: PUSH
18963: EMPTY
18964: LIST
18965: LIST
18966: PUSH
18967: EMPTY
18968: LIST
18969: LIST
18970: PPUSH
18971: CALL_OW 69
18975: ST_TO_ADDR
// if not tmp then
18976: LD_VAR 0 5
18980: NOT
18981: IFFALSE 18985
// exit ;
18983: GO 19139
// for i in tmp do
18985: LD_ADDR_VAR 0 1
18989: PUSH
18990: LD_VAR 0 5
18994: PUSH
18995: FOR_IN
18996: IFFALSE 19137
// begin d := rand ( 0 , 5 ) ;
18998: LD_ADDR_VAR 0 4
19002: PUSH
19003: LD_INT 0
19005: PPUSH
19006: LD_INT 5
19008: PPUSH
19009: CALL_OW 12
19013: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19014: LD_ADDR_VAR 0 2
19018: PUSH
19019: LD_VAR 0 1
19023: PPUSH
19024: CALL_OW 250
19028: PPUSH
19029: LD_VAR 0 4
19033: PPUSH
19034: LD_INT 3
19036: PPUSH
19037: LD_INT 12
19039: PPUSH
19040: CALL_OW 12
19044: PPUSH
19045: CALL_OW 272
19049: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19050: LD_ADDR_VAR 0 3
19054: PUSH
19055: LD_VAR 0 1
19059: PPUSH
19060: CALL_OW 251
19064: PPUSH
19065: LD_VAR 0 4
19069: PPUSH
19070: LD_INT 3
19072: PPUSH
19073: LD_INT 12
19075: PPUSH
19076: CALL_OW 12
19080: PPUSH
19081: CALL_OW 273
19085: ST_TO_ADDR
// if ValidHex ( x , y ) then
19086: LD_VAR 0 2
19090: PPUSH
19091: LD_VAR 0 3
19095: PPUSH
19096: CALL_OW 488
19100: IFFALSE 19135
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19102: LD_VAR 0 1
19106: PPUSH
19107: LD_VAR 0 2
19111: PPUSH
19112: LD_VAR 0 3
19116: PPUSH
19117: LD_INT 3
19119: PPUSH
19120: LD_INT 6
19122: PPUSH
19123: CALL_OW 12
19127: PPUSH
19128: LD_INT 1
19130: PPUSH
19131: CALL_OW 483
// end ;
19135: GO 18995
19137: POP
19138: POP
// end ;
19139: PPOPN 5
19141: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19142: LD_EXP 34
19146: PUSH
19147: LD_EXP 69
19151: AND
19152: IFFALSE 19246
19154: GO 19156
19156: DISABLE
19157: LD_INT 0
19159: PPUSH
19160: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19161: LD_ADDR_VAR 0 2
19165: PUSH
19166: LD_INT 22
19168: PUSH
19169: LD_OWVAR 2
19173: PUSH
19174: EMPTY
19175: LIST
19176: LIST
19177: PUSH
19178: LD_INT 32
19180: PUSH
19181: LD_INT 1
19183: PUSH
19184: EMPTY
19185: LIST
19186: LIST
19187: PUSH
19188: LD_INT 21
19190: PUSH
19191: LD_INT 2
19193: PUSH
19194: EMPTY
19195: LIST
19196: LIST
19197: PUSH
19198: EMPTY
19199: LIST
19200: LIST
19201: LIST
19202: PPUSH
19203: CALL_OW 69
19207: ST_TO_ADDR
// if not tmp then
19208: LD_VAR 0 2
19212: NOT
19213: IFFALSE 19217
// exit ;
19215: GO 19246
// for i in tmp do
19217: LD_ADDR_VAR 0 1
19221: PUSH
19222: LD_VAR 0 2
19226: PUSH
19227: FOR_IN
19228: IFFALSE 19244
// SetFuel ( i , 0 ) ;
19230: LD_VAR 0 1
19234: PPUSH
19235: LD_INT 0
19237: PPUSH
19238: CALL_OW 240
19242: GO 19227
19244: POP
19245: POP
// end ;
19246: PPOPN 2
19248: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19249: LD_EXP 34
19253: PUSH
19254: LD_EXP 70
19258: AND
19259: IFFALSE 19325
19261: GO 19263
19263: DISABLE
19264: LD_INT 0
19266: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19267: LD_ADDR_VAR 0 1
19271: PUSH
19272: LD_INT 22
19274: PUSH
19275: LD_OWVAR 2
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PUSH
19284: LD_INT 30
19286: PUSH
19287: LD_INT 29
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: PUSH
19294: EMPTY
19295: LIST
19296: LIST
19297: PPUSH
19298: CALL_OW 69
19302: ST_TO_ADDR
// if not tmp then
19303: LD_VAR 0 1
19307: NOT
19308: IFFALSE 19312
// exit ;
19310: GO 19325
// DestroyUnit ( tmp [ 1 ] ) ;
19312: LD_VAR 0 1
19316: PUSH
19317: LD_INT 1
19319: ARRAY
19320: PPUSH
19321: CALL_OW 65
// end ;
19325: PPOPN 1
19327: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
19328: LD_EXP 34
19332: PUSH
19333: LD_EXP 72
19337: AND
19338: IFFALSE 19467
19340: GO 19342
19342: DISABLE
19343: LD_INT 0
19345: PPUSH
// begin uc_side := 0 ;
19346: LD_ADDR_OWVAR 20
19350: PUSH
19351: LD_INT 0
19353: ST_TO_ADDR
// uc_nation := nation_arabian ;
19354: LD_ADDR_OWVAR 21
19358: PUSH
19359: LD_INT 2
19361: ST_TO_ADDR
// hc_gallery :=  ;
19362: LD_ADDR_OWVAR 33
19366: PUSH
19367: LD_STRING 
19369: ST_TO_ADDR
// hc_name :=  ;
19370: LD_ADDR_OWVAR 26
19374: PUSH
19375: LD_STRING 
19377: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
19378: LD_INT 1
19380: PPUSH
19381: LD_INT 11
19383: PPUSH
19384: LD_INT 10
19386: PPUSH
19387: CALL_OW 380
// un := CreateHuman ;
19391: LD_ADDR_VAR 0 1
19395: PUSH
19396: CALL_OW 44
19400: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19401: LD_VAR 0 1
19405: PPUSH
19406: LD_INT 1
19408: PPUSH
19409: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19413: LD_INT 35
19415: PPUSH
19416: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19420: LD_VAR 0 1
19424: PPUSH
19425: LD_INT 22
19427: PUSH
19428: LD_OWVAR 2
19432: PUSH
19433: EMPTY
19434: LIST
19435: LIST
19436: PPUSH
19437: CALL_OW 69
19441: PPUSH
19442: LD_VAR 0 1
19446: PPUSH
19447: CALL_OW 74
19451: PPUSH
19452: CALL_OW 115
// until IsDead ( un ) ;
19456: LD_VAR 0 1
19460: PPUSH
19461: CALL_OW 301
19465: IFFALSE 19413
// end ;
19467: PPOPN 1
19469: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
19470: LD_EXP 34
19474: PUSH
19475: LD_EXP 74
19479: AND
19480: IFFALSE 19492
19482: GO 19484
19484: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
19485: LD_STRING earthquake(getX(game), 0, 32)
19487: PPUSH
19488: CALL_OW 559
19492: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
19493: LD_EXP 34
19497: PUSH
19498: LD_EXP 75
19502: AND
19503: IFFALSE 19594
19505: GO 19507
19507: DISABLE
19508: LD_INT 0
19510: PPUSH
// begin enable ;
19511: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
19512: LD_ADDR_VAR 0 1
19516: PUSH
19517: LD_INT 22
19519: PUSH
19520: LD_OWVAR 2
19524: PUSH
19525: EMPTY
19526: LIST
19527: LIST
19528: PUSH
19529: LD_INT 21
19531: PUSH
19532: LD_INT 2
19534: PUSH
19535: EMPTY
19536: LIST
19537: LIST
19538: PUSH
19539: LD_INT 33
19541: PUSH
19542: LD_INT 3
19544: PUSH
19545: EMPTY
19546: LIST
19547: LIST
19548: PUSH
19549: EMPTY
19550: LIST
19551: LIST
19552: LIST
19553: PPUSH
19554: CALL_OW 69
19558: ST_TO_ADDR
// if not tmp then
19559: LD_VAR 0 1
19563: NOT
19564: IFFALSE 19568
// exit ;
19566: GO 19594
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19568: LD_VAR 0 1
19572: PUSH
19573: LD_INT 1
19575: PPUSH
19576: LD_VAR 0 1
19580: PPUSH
19581: CALL_OW 12
19585: ARRAY
19586: PPUSH
19587: LD_INT 1
19589: PPUSH
19590: CALL_OW 234
// end ;
19594: PPOPN 1
19596: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
19597: LD_EXP 34
19601: PUSH
19602: LD_EXP 76
19606: AND
19607: IFFALSE 19748
19609: GO 19611
19611: DISABLE
19612: LD_INT 0
19614: PPUSH
19615: PPUSH
19616: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19617: LD_ADDR_VAR 0 3
19621: PUSH
19622: LD_INT 22
19624: PUSH
19625: LD_OWVAR 2
19629: PUSH
19630: EMPTY
19631: LIST
19632: LIST
19633: PUSH
19634: LD_INT 25
19636: PUSH
19637: LD_INT 1
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PPUSH
19648: CALL_OW 69
19652: ST_TO_ADDR
// if not tmp then
19653: LD_VAR 0 3
19657: NOT
19658: IFFALSE 19662
// exit ;
19660: GO 19748
// un := tmp [ rand ( 1 , tmp ) ] ;
19662: LD_ADDR_VAR 0 2
19666: PUSH
19667: LD_VAR 0 3
19671: PUSH
19672: LD_INT 1
19674: PPUSH
19675: LD_VAR 0 3
19679: PPUSH
19680: CALL_OW 12
19684: ARRAY
19685: ST_TO_ADDR
// if Crawls ( un ) then
19686: LD_VAR 0 2
19690: PPUSH
19691: CALL_OW 318
19695: IFFALSE 19706
// ComWalk ( un ) ;
19697: LD_VAR 0 2
19701: PPUSH
19702: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
19706: LD_VAR 0 2
19710: PPUSH
19711: LD_INT 9
19713: PPUSH
19714: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
19718: LD_INT 28
19720: PPUSH
19721: LD_OWVAR 2
19725: PPUSH
19726: LD_INT 2
19728: PPUSH
19729: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
19733: LD_INT 29
19735: PPUSH
19736: LD_OWVAR 2
19740: PPUSH
19741: LD_INT 2
19743: PPUSH
19744: CALL_OW 322
// end ;
19748: PPOPN 3
19750: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
19751: LD_EXP 34
19755: PUSH
19756: LD_EXP 77
19760: AND
19761: IFFALSE 19872
19763: GO 19765
19765: DISABLE
19766: LD_INT 0
19768: PPUSH
19769: PPUSH
19770: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19771: LD_ADDR_VAR 0 3
19775: PUSH
19776: LD_INT 22
19778: PUSH
19779: LD_OWVAR 2
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: PUSH
19788: LD_INT 25
19790: PUSH
19791: LD_INT 1
19793: PUSH
19794: EMPTY
19795: LIST
19796: LIST
19797: PUSH
19798: EMPTY
19799: LIST
19800: LIST
19801: PPUSH
19802: CALL_OW 69
19806: ST_TO_ADDR
// if not tmp then
19807: LD_VAR 0 3
19811: NOT
19812: IFFALSE 19816
// exit ;
19814: GO 19872
// un := tmp [ rand ( 1 , tmp ) ] ;
19816: LD_ADDR_VAR 0 2
19820: PUSH
19821: LD_VAR 0 3
19825: PUSH
19826: LD_INT 1
19828: PPUSH
19829: LD_VAR 0 3
19833: PPUSH
19834: CALL_OW 12
19838: ARRAY
19839: ST_TO_ADDR
// if Crawls ( un ) then
19840: LD_VAR 0 2
19844: PPUSH
19845: CALL_OW 318
19849: IFFALSE 19860
// ComWalk ( un ) ;
19851: LD_VAR 0 2
19855: PPUSH
19856: CALL_OW 138
// SetClass ( un , class_mortar ) ;
19860: LD_VAR 0 2
19864: PPUSH
19865: LD_INT 8
19867: PPUSH
19868: CALL_OW 336
// end ;
19872: PPOPN 3
19874: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
19875: LD_EXP 34
19879: PUSH
19880: LD_EXP 78
19884: AND
19885: IFFALSE 20029
19887: GO 19889
19889: DISABLE
19890: LD_INT 0
19892: PPUSH
19893: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
19894: LD_ADDR_VAR 0 2
19898: PUSH
19899: LD_INT 22
19901: PUSH
19902: LD_OWVAR 2
19906: PUSH
19907: EMPTY
19908: LIST
19909: LIST
19910: PUSH
19911: LD_INT 21
19913: PUSH
19914: LD_INT 2
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: PUSH
19921: LD_INT 2
19923: PUSH
19924: LD_INT 34
19926: PUSH
19927: LD_INT 12
19929: PUSH
19930: EMPTY
19931: LIST
19932: LIST
19933: PUSH
19934: LD_INT 34
19936: PUSH
19937: LD_INT 51
19939: PUSH
19940: EMPTY
19941: LIST
19942: LIST
19943: PUSH
19944: LD_INT 34
19946: PUSH
19947: LD_INT 32
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: PUSH
19954: EMPTY
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: PUSH
19960: EMPTY
19961: LIST
19962: LIST
19963: LIST
19964: PPUSH
19965: CALL_OW 69
19969: ST_TO_ADDR
// if not tmp then
19970: LD_VAR 0 2
19974: NOT
19975: IFFALSE 19979
// exit ;
19977: GO 20029
// for i in tmp do
19979: LD_ADDR_VAR 0 1
19983: PUSH
19984: LD_VAR 0 2
19988: PUSH
19989: FOR_IN
19990: IFFALSE 20027
// if GetCargo ( i , mat_artifact ) = 0 then
19992: LD_VAR 0 1
19996: PPUSH
19997: LD_INT 4
19999: PPUSH
20000: CALL_OW 289
20004: PUSH
20005: LD_INT 0
20007: EQUAL
20008: IFFALSE 20025
// SetCargo ( i , mat_siberit , 100 ) ;
20010: LD_VAR 0 1
20014: PPUSH
20015: LD_INT 3
20017: PPUSH
20018: LD_INT 100
20020: PPUSH
20021: CALL_OW 290
20025: GO 19989
20027: POP
20028: POP
// end ;
20029: PPOPN 2
20031: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20032: LD_EXP 34
20036: PUSH
20037: LD_EXP 79
20041: AND
20042: IFFALSE 20195
20044: GO 20046
20046: DISABLE
20047: LD_INT 0
20049: PPUSH
20050: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20051: LD_ADDR_VAR 0 2
20055: PUSH
20056: LD_INT 22
20058: PUSH
20059: LD_OWVAR 2
20063: PUSH
20064: EMPTY
20065: LIST
20066: LIST
20067: PPUSH
20068: CALL_OW 69
20072: ST_TO_ADDR
// if not tmp then
20073: LD_VAR 0 2
20077: NOT
20078: IFFALSE 20082
// exit ;
20080: GO 20195
// for i := 1 to 2 do
20082: LD_ADDR_VAR 0 1
20086: PUSH
20087: DOUBLE
20088: LD_INT 1
20090: DEC
20091: ST_TO_ADDR
20092: LD_INT 2
20094: PUSH
20095: FOR_TO
20096: IFFALSE 20193
// begin uc_side := your_side ;
20098: LD_ADDR_OWVAR 20
20102: PUSH
20103: LD_OWVAR 2
20107: ST_TO_ADDR
// uc_nation := nation_american ;
20108: LD_ADDR_OWVAR 21
20112: PUSH
20113: LD_INT 1
20115: ST_TO_ADDR
// vc_chassis := us_morphling ;
20116: LD_ADDR_OWVAR 37
20120: PUSH
20121: LD_INT 5
20123: ST_TO_ADDR
// vc_engine := engine_siberite ;
20124: LD_ADDR_OWVAR 39
20128: PUSH
20129: LD_INT 3
20131: ST_TO_ADDR
// vc_control := control_computer ;
20132: LD_ADDR_OWVAR 38
20136: PUSH
20137: LD_INT 3
20139: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20140: LD_ADDR_OWVAR 40
20144: PUSH
20145: LD_INT 10
20147: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
20148: CALL_OW 45
20152: PPUSH
20153: LD_VAR 0 2
20157: PUSH
20158: LD_INT 1
20160: ARRAY
20161: PPUSH
20162: CALL_OW 250
20166: PPUSH
20167: LD_VAR 0 2
20171: PUSH
20172: LD_INT 1
20174: ARRAY
20175: PPUSH
20176: CALL_OW 251
20180: PPUSH
20181: LD_INT 12
20183: PPUSH
20184: LD_INT 1
20186: PPUSH
20187: CALL_OW 50
// end ;
20191: GO 20095
20193: POP
20194: POP
// end ;
20195: PPOPN 2
20197: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20198: LD_EXP 34
20202: PUSH
20203: LD_EXP 80
20207: AND
20208: IFFALSE 20430
20210: GO 20212
20212: DISABLE
20213: LD_INT 0
20215: PPUSH
20216: PPUSH
20217: PPUSH
20218: PPUSH
20219: PPUSH
20220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20221: LD_ADDR_VAR 0 6
20225: PUSH
20226: LD_INT 22
20228: PUSH
20229: LD_OWVAR 2
20233: PUSH
20234: EMPTY
20235: LIST
20236: LIST
20237: PUSH
20238: LD_INT 21
20240: PUSH
20241: LD_INT 1
20243: PUSH
20244: EMPTY
20245: LIST
20246: LIST
20247: PUSH
20248: LD_INT 3
20250: PUSH
20251: LD_INT 23
20253: PUSH
20254: LD_INT 0
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: PUSH
20265: EMPTY
20266: LIST
20267: LIST
20268: LIST
20269: PPUSH
20270: CALL_OW 69
20274: ST_TO_ADDR
// if not tmp then
20275: LD_VAR 0 6
20279: NOT
20280: IFFALSE 20284
// exit ;
20282: GO 20430
// s1 := rand ( 1 , 4 ) ;
20284: LD_ADDR_VAR 0 2
20288: PUSH
20289: LD_INT 1
20291: PPUSH
20292: LD_INT 4
20294: PPUSH
20295: CALL_OW 12
20299: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
20300: LD_ADDR_VAR 0 4
20304: PUSH
20305: LD_VAR 0 6
20309: PUSH
20310: LD_INT 1
20312: ARRAY
20313: PPUSH
20314: LD_VAR 0 2
20318: PPUSH
20319: CALL_OW 259
20323: ST_TO_ADDR
// if s1 = 1 then
20324: LD_VAR 0 2
20328: PUSH
20329: LD_INT 1
20331: EQUAL
20332: IFFALSE 20352
// s2 := rand ( 2 , 4 ) else
20334: LD_ADDR_VAR 0 3
20338: PUSH
20339: LD_INT 2
20341: PPUSH
20342: LD_INT 4
20344: PPUSH
20345: CALL_OW 12
20349: ST_TO_ADDR
20350: GO 20360
// s2 := 1 ;
20352: LD_ADDR_VAR 0 3
20356: PUSH
20357: LD_INT 1
20359: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
20360: LD_ADDR_VAR 0 5
20364: PUSH
20365: LD_VAR 0 6
20369: PUSH
20370: LD_INT 1
20372: ARRAY
20373: PPUSH
20374: LD_VAR 0 3
20378: PPUSH
20379: CALL_OW 259
20383: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
20384: LD_VAR 0 6
20388: PUSH
20389: LD_INT 1
20391: ARRAY
20392: PPUSH
20393: LD_VAR 0 2
20397: PPUSH
20398: LD_VAR 0 5
20402: PPUSH
20403: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
20407: LD_VAR 0 6
20411: PUSH
20412: LD_INT 1
20414: ARRAY
20415: PPUSH
20416: LD_VAR 0 3
20420: PPUSH
20421: LD_VAR 0 4
20425: PPUSH
20426: CALL_OW 237
// end ;
20430: PPOPN 6
20432: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
20433: LD_EXP 34
20437: PUSH
20438: LD_EXP 81
20442: AND
20443: IFFALSE 20522
20445: GO 20447
20447: DISABLE
20448: LD_INT 0
20450: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
20451: LD_ADDR_VAR 0 1
20455: PUSH
20456: LD_INT 22
20458: PUSH
20459: LD_OWVAR 2
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: PUSH
20468: LD_INT 30
20470: PUSH
20471: LD_INT 3
20473: PUSH
20474: EMPTY
20475: LIST
20476: LIST
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: PPUSH
20482: CALL_OW 69
20486: ST_TO_ADDR
// if not tmp then
20487: LD_VAR 0 1
20491: NOT
20492: IFFALSE 20496
// exit ;
20494: GO 20522
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20496: LD_VAR 0 1
20500: PUSH
20501: LD_INT 1
20503: PPUSH
20504: LD_VAR 0 1
20508: PPUSH
20509: CALL_OW 12
20513: ARRAY
20514: PPUSH
20515: LD_INT 1
20517: PPUSH
20518: CALL_OW 234
// end ;
20522: PPOPN 1
20524: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
20525: LD_EXP 34
20529: PUSH
20530: LD_EXP 82
20534: AND
20535: IFFALSE 20647
20537: GO 20539
20539: DISABLE
20540: LD_INT 0
20542: PPUSH
20543: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
20544: LD_ADDR_VAR 0 2
20548: PUSH
20549: LD_INT 22
20551: PUSH
20552: LD_OWVAR 2
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: PUSH
20561: LD_INT 2
20563: PUSH
20564: LD_INT 30
20566: PUSH
20567: LD_INT 27
20569: PUSH
20570: EMPTY
20571: LIST
20572: LIST
20573: PUSH
20574: LD_INT 30
20576: PUSH
20577: LD_INT 26
20579: PUSH
20580: EMPTY
20581: LIST
20582: LIST
20583: PUSH
20584: LD_INT 30
20586: PUSH
20587: LD_INT 28
20589: PUSH
20590: EMPTY
20591: LIST
20592: LIST
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: LIST
20598: LIST
20599: PUSH
20600: EMPTY
20601: LIST
20602: LIST
20603: PPUSH
20604: CALL_OW 69
20608: ST_TO_ADDR
// if not tmp then
20609: LD_VAR 0 2
20613: NOT
20614: IFFALSE 20618
// exit ;
20616: GO 20647
// for i in tmp do
20618: LD_ADDR_VAR 0 1
20622: PUSH
20623: LD_VAR 0 2
20627: PUSH
20628: FOR_IN
20629: IFFALSE 20645
// SetLives ( i , 1 ) ;
20631: LD_VAR 0 1
20635: PPUSH
20636: LD_INT 1
20638: PPUSH
20639: CALL_OW 234
20643: GO 20628
20645: POP
20646: POP
// end ;
20647: PPOPN 2
20649: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
20650: LD_EXP 34
20654: PUSH
20655: LD_EXP 83
20659: AND
20660: IFFALSE 20934
20662: GO 20664
20664: DISABLE
20665: LD_INT 0
20667: PPUSH
20668: PPUSH
20669: PPUSH
// begin i := rand ( 1 , 7 ) ;
20670: LD_ADDR_VAR 0 1
20674: PUSH
20675: LD_INT 1
20677: PPUSH
20678: LD_INT 7
20680: PPUSH
20681: CALL_OW 12
20685: ST_TO_ADDR
// case i of 1 :
20686: LD_VAR 0 1
20690: PUSH
20691: LD_INT 1
20693: DOUBLE
20694: EQUAL
20695: IFTRUE 20699
20697: GO 20709
20699: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
20700: LD_STRING earthquake(getX(game), 0, 32)
20702: PPUSH
20703: CALL_OW 559
20707: GO 20934
20709: LD_INT 2
20711: DOUBLE
20712: EQUAL
20713: IFTRUE 20717
20715: GO 20731
20717: POP
// begin ToLua ( displayStucuk(); ) ;
20718: LD_STRING displayStucuk();
20720: PPUSH
20721: CALL_OW 559
// ResetFog ;
20725: CALL_OW 335
// end ; 3 :
20729: GO 20934
20731: LD_INT 3
20733: DOUBLE
20734: EQUAL
20735: IFTRUE 20739
20737: GO 20843
20739: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20740: LD_ADDR_VAR 0 2
20744: PUSH
20745: LD_INT 22
20747: PUSH
20748: LD_OWVAR 2
20752: PUSH
20753: EMPTY
20754: LIST
20755: LIST
20756: PUSH
20757: LD_INT 25
20759: PUSH
20760: LD_INT 1
20762: PUSH
20763: EMPTY
20764: LIST
20765: LIST
20766: PUSH
20767: EMPTY
20768: LIST
20769: LIST
20770: PPUSH
20771: CALL_OW 69
20775: ST_TO_ADDR
// if not tmp then
20776: LD_VAR 0 2
20780: NOT
20781: IFFALSE 20785
// exit ;
20783: GO 20934
// un := tmp [ rand ( 1 , tmp ) ] ;
20785: LD_ADDR_VAR 0 3
20789: PUSH
20790: LD_VAR 0 2
20794: PUSH
20795: LD_INT 1
20797: PPUSH
20798: LD_VAR 0 2
20802: PPUSH
20803: CALL_OW 12
20807: ARRAY
20808: ST_TO_ADDR
// if Crawls ( un ) then
20809: LD_VAR 0 3
20813: PPUSH
20814: CALL_OW 318
20818: IFFALSE 20829
// ComWalk ( un ) ;
20820: LD_VAR 0 3
20824: PPUSH
20825: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20829: LD_VAR 0 3
20833: PPUSH
20834: LD_INT 8
20836: PPUSH
20837: CALL_OW 336
// end ; 4 :
20841: GO 20934
20843: LD_INT 4
20845: DOUBLE
20846: EQUAL
20847: IFTRUE 20851
20849: GO 20912
20851: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20852: LD_ADDR_VAR 0 2
20856: PUSH
20857: LD_INT 22
20859: PUSH
20860: LD_OWVAR 2
20864: PUSH
20865: EMPTY
20866: LIST
20867: LIST
20868: PUSH
20869: LD_INT 30
20871: PUSH
20872: LD_INT 29
20874: PUSH
20875: EMPTY
20876: LIST
20877: LIST
20878: PUSH
20879: EMPTY
20880: LIST
20881: LIST
20882: PPUSH
20883: CALL_OW 69
20887: ST_TO_ADDR
// if not tmp then
20888: LD_VAR 0 2
20892: NOT
20893: IFFALSE 20897
// exit ;
20895: GO 20934
// DestroyUnit ( tmp [ 1 ] ) ;
20897: LD_VAR 0 2
20901: PUSH
20902: LD_INT 1
20904: ARRAY
20905: PPUSH
20906: CALL_OW 65
// end ; 5 .. 7 :
20910: GO 20934
20912: LD_INT 5
20914: DOUBLE
20915: GREATEREQUAL
20916: IFFALSE 20924
20918: LD_INT 7
20920: DOUBLE
20921: LESSEQUAL
20922: IFTRUE 20926
20924: GO 20933
20926: POP
// StreamSibBomb ; end ;
20927: CALL 17214 0 0
20931: GO 20934
20933: POP
// end ;
20934: PPOPN 3
20936: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
20937: LD_EXP 34
20941: PUSH
20942: LD_EXP 84
20946: AND
20947: IFFALSE 21103
20949: GO 20951
20951: DISABLE
20952: LD_INT 0
20954: PPUSH
20955: PPUSH
20956: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
20957: LD_ADDR_VAR 0 2
20961: PUSH
20962: LD_INT 81
20964: PUSH
20965: LD_OWVAR 2
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: PUSH
20974: LD_INT 2
20976: PUSH
20977: LD_INT 21
20979: PUSH
20980: LD_INT 1
20982: PUSH
20983: EMPTY
20984: LIST
20985: LIST
20986: PUSH
20987: LD_INT 21
20989: PUSH
20990: LD_INT 2
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PUSH
20997: EMPTY
20998: LIST
20999: LIST
21000: LIST
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: PPUSH
21006: CALL_OW 69
21010: ST_TO_ADDR
// if not tmp then
21011: LD_VAR 0 2
21015: NOT
21016: IFFALSE 21020
// exit ;
21018: GO 21103
// p := 0 ;
21020: LD_ADDR_VAR 0 3
21024: PUSH
21025: LD_INT 0
21027: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21028: LD_INT 35
21030: PPUSH
21031: CALL_OW 67
// p := p + 1 ;
21035: LD_ADDR_VAR 0 3
21039: PUSH
21040: LD_VAR 0 3
21044: PUSH
21045: LD_INT 1
21047: PLUS
21048: ST_TO_ADDR
// for i in tmp do
21049: LD_ADDR_VAR 0 1
21053: PUSH
21054: LD_VAR 0 2
21058: PUSH
21059: FOR_IN
21060: IFFALSE 21091
// if GetLives ( i ) < 1000 then
21062: LD_VAR 0 1
21066: PPUSH
21067: CALL_OW 256
21071: PUSH
21072: LD_INT 1000
21074: LESS
21075: IFFALSE 21089
// SetLives ( i , 1000 ) ;
21077: LD_VAR 0 1
21081: PPUSH
21082: LD_INT 1000
21084: PPUSH
21085: CALL_OW 234
21089: GO 21059
21091: POP
21092: POP
// until p > 20 ;
21093: LD_VAR 0 3
21097: PUSH
21098: LD_INT 20
21100: GREATER
21101: IFFALSE 21028
// end ;
21103: PPOPN 3
21105: END
// every 0 0$1 trigger StreamModeActive and sTime do
21106: LD_EXP 34
21110: PUSH
21111: LD_EXP 85
21115: AND
21116: IFFALSE 21151
21118: GO 21120
21120: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21121: LD_INT 28
21123: PPUSH
21124: LD_OWVAR 2
21128: PPUSH
21129: LD_INT 2
21131: PPUSH
21132: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21136: LD_INT 30
21138: PPUSH
21139: LD_OWVAR 2
21143: PPUSH
21144: LD_INT 2
21146: PPUSH
21147: CALL_OW 322
// end ;
21151: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21152: LD_EXP 34
21156: PUSH
21157: LD_EXP 86
21161: AND
21162: IFFALSE 21283
21164: GO 21166
21166: DISABLE
21167: LD_INT 0
21169: PPUSH
21170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21171: LD_ADDR_VAR 0 2
21175: PUSH
21176: LD_INT 22
21178: PUSH
21179: LD_OWVAR 2
21183: PUSH
21184: EMPTY
21185: LIST
21186: LIST
21187: PUSH
21188: LD_INT 21
21190: PUSH
21191: LD_INT 1
21193: PUSH
21194: EMPTY
21195: LIST
21196: LIST
21197: PUSH
21198: LD_INT 3
21200: PUSH
21201: LD_INT 23
21203: PUSH
21204: LD_INT 0
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: LIST
21219: PPUSH
21220: CALL_OW 69
21224: ST_TO_ADDR
// if not tmp then
21225: LD_VAR 0 2
21229: NOT
21230: IFFALSE 21234
// exit ;
21232: GO 21283
// for i in tmp do
21234: LD_ADDR_VAR 0 1
21238: PUSH
21239: LD_VAR 0 2
21243: PUSH
21244: FOR_IN
21245: IFFALSE 21281
// begin if Crawls ( i ) then
21247: LD_VAR 0 1
21251: PPUSH
21252: CALL_OW 318
21256: IFFALSE 21267
// ComWalk ( i ) ;
21258: LD_VAR 0 1
21262: PPUSH
21263: CALL_OW 138
// SetClass ( i , 2 ) ;
21267: LD_VAR 0 1
21271: PPUSH
21272: LD_INT 2
21274: PPUSH
21275: CALL_OW 336
// end ;
21279: GO 21244
21281: POP
21282: POP
// end ;
21283: PPOPN 2
21285: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
21286: LD_EXP 34
21290: PUSH
21291: LD_EXP 87
21295: AND
21296: IFFALSE 21577
21298: GO 21300
21300: DISABLE
21301: LD_INT 0
21303: PPUSH
21304: PPUSH
21305: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
21306: LD_OWVAR 2
21310: PPUSH
21311: LD_INT 9
21313: PPUSH
21314: LD_INT 1
21316: PPUSH
21317: LD_INT 1
21319: PPUSH
21320: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
21324: LD_INT 9
21326: PPUSH
21327: LD_OWVAR 2
21331: PPUSH
21332: CALL_OW 343
// uc_side := 9 ;
21336: LD_ADDR_OWVAR 20
21340: PUSH
21341: LD_INT 9
21343: ST_TO_ADDR
// uc_nation := 2 ;
21344: LD_ADDR_OWVAR 21
21348: PUSH
21349: LD_INT 2
21351: ST_TO_ADDR
// hc_name := Dark Warrior ;
21352: LD_ADDR_OWVAR 26
21356: PUSH
21357: LD_STRING Dark Warrior
21359: ST_TO_ADDR
// hc_gallery :=  ;
21360: LD_ADDR_OWVAR 33
21364: PUSH
21365: LD_STRING 
21367: ST_TO_ADDR
// hc_noskilllimit := true ;
21368: LD_ADDR_OWVAR 76
21372: PUSH
21373: LD_INT 1
21375: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
21376: LD_ADDR_OWVAR 31
21380: PUSH
21381: LD_INT 30
21383: PUSH
21384: LD_INT 30
21386: PUSH
21387: LD_INT 30
21389: PUSH
21390: LD_INT 30
21392: PUSH
21393: EMPTY
21394: LIST
21395: LIST
21396: LIST
21397: LIST
21398: ST_TO_ADDR
// un := CreateHuman ;
21399: LD_ADDR_VAR 0 3
21403: PUSH
21404: CALL_OW 44
21408: ST_TO_ADDR
// hc_noskilllimit := false ;
21409: LD_ADDR_OWVAR 76
21413: PUSH
21414: LD_INT 0
21416: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21417: LD_VAR 0 3
21421: PPUSH
21422: LD_INT 1
21424: PPUSH
21425: CALL_OW 51
// p := 0 ;
21429: LD_ADDR_VAR 0 2
21433: PUSH
21434: LD_INT 0
21436: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21437: LD_INT 35
21439: PPUSH
21440: CALL_OW 67
// p := p + 1 ;
21444: LD_ADDR_VAR 0 2
21448: PUSH
21449: LD_VAR 0 2
21453: PUSH
21454: LD_INT 1
21456: PLUS
21457: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
21458: LD_VAR 0 3
21462: PPUSH
21463: CALL_OW 256
21467: PUSH
21468: LD_INT 1000
21470: LESS
21471: IFFALSE 21485
// SetLives ( un , 1000 ) ;
21473: LD_VAR 0 3
21477: PPUSH
21478: LD_INT 1000
21480: PPUSH
21481: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
21485: LD_VAR 0 3
21489: PPUSH
21490: LD_INT 81
21492: PUSH
21493: LD_OWVAR 2
21497: PUSH
21498: EMPTY
21499: LIST
21500: LIST
21501: PUSH
21502: LD_INT 91
21504: PUSH
21505: LD_VAR 0 3
21509: PUSH
21510: LD_INT 30
21512: PUSH
21513: EMPTY
21514: LIST
21515: LIST
21516: LIST
21517: PUSH
21518: EMPTY
21519: LIST
21520: LIST
21521: PPUSH
21522: CALL_OW 69
21526: PPUSH
21527: LD_VAR 0 3
21531: PPUSH
21532: CALL_OW 74
21536: PPUSH
21537: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
21541: LD_VAR 0 2
21545: PUSH
21546: LD_INT 60
21548: GREATER
21549: PUSH
21550: LD_VAR 0 3
21554: PPUSH
21555: CALL_OW 301
21559: OR
21560: IFFALSE 21437
// if un then
21562: LD_VAR 0 3
21566: IFFALSE 21577
// RemoveUnit ( un ) ;
21568: LD_VAR 0 3
21572: PPUSH
21573: CALL_OW 64
// end ; end_of_file
21577: PPOPN 3
21579: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
21580: LD_INT 0
21582: PPUSH
21583: PPUSH
21584: PPUSH
21585: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
21586: LD_VAR 0 1
21590: PPUSH
21591: CALL_OW 264
21595: PUSH
21596: LD_EXP 33
21600: EQUAL
21601: IFFALSE 21673
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
21603: LD_INT 68
21605: PPUSH
21606: LD_VAR 0 1
21610: PPUSH
21611: CALL_OW 255
21615: PPUSH
21616: CALL_OW 321
21620: PUSH
21621: LD_INT 2
21623: EQUAL
21624: IFFALSE 21636
// eff := 70 else
21626: LD_ADDR_VAR 0 4
21630: PUSH
21631: LD_INT 70
21633: ST_TO_ADDR
21634: GO 21644
// eff := 30 ;
21636: LD_ADDR_VAR 0 4
21640: PUSH
21641: LD_INT 30
21643: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
21644: LD_VAR 0 1
21648: PPUSH
21649: CALL_OW 250
21653: PPUSH
21654: LD_VAR 0 1
21658: PPUSH
21659: CALL_OW 251
21663: PPUSH
21664: LD_VAR 0 4
21668: PPUSH
21669: CALL_OW 495
// end ; end ;
21673: LD_VAR 0 2
21677: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
21678: LD_INT 0
21680: PPUSH
// end ;
21681: LD_VAR 0 4
21685: RET
// export function SOS_Command ( cmd ) ; begin
21686: LD_INT 0
21688: PPUSH
// end ;
21689: LD_VAR 0 2
21693: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
21694: LD_VAR 0 1
21698: PUSH
21699: LD_INT 255
21701: EQUAL
21702: PUSH
21703: LD_VAR 0 2
21707: PPUSH
21708: CALL_OW 264
21712: PUSH
21713: LD_INT 14
21715: PUSH
21716: LD_INT 53
21718: PUSH
21719: EMPTY
21720: LIST
21721: LIST
21722: IN
21723: AND
21724: PUSH
21725: LD_VAR 0 4
21729: PPUSH
21730: LD_VAR 0 5
21734: PPUSH
21735: CALL_OW 488
21739: AND
21740: IFFALSE 21764
// CutTreeXYR ( unit , x , y , 12 ) ;
21742: LD_VAR 0 2
21746: PPUSH
21747: LD_VAR 0 4
21751: PPUSH
21752: LD_VAR 0 5
21756: PPUSH
21757: LD_INT 12
21759: PPUSH
21760: CALL 21767 0 4
// end ;
21764: PPOPN 5
21766: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
21767: LD_INT 0
21769: PPUSH
21770: PPUSH
21771: PPUSH
21772: PPUSH
21773: PPUSH
21774: PPUSH
21775: PPUSH
21776: PPUSH
21777: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
21778: LD_VAR 0 1
21782: NOT
21783: PUSH
21784: LD_VAR 0 2
21788: PPUSH
21789: LD_VAR 0 3
21793: PPUSH
21794: CALL_OW 488
21798: NOT
21799: OR
21800: PUSH
21801: LD_VAR 0 4
21805: NOT
21806: OR
21807: IFFALSE 21811
// exit ;
21809: GO 22151
// list := [ ] ;
21811: LD_ADDR_VAR 0 13
21815: PUSH
21816: EMPTY
21817: ST_TO_ADDR
// if x - r < 0 then
21818: LD_VAR 0 2
21822: PUSH
21823: LD_VAR 0 4
21827: MINUS
21828: PUSH
21829: LD_INT 0
21831: LESS
21832: IFFALSE 21844
// min_x := 0 else
21834: LD_ADDR_VAR 0 7
21838: PUSH
21839: LD_INT 0
21841: ST_TO_ADDR
21842: GO 21860
// min_x := x - r ;
21844: LD_ADDR_VAR 0 7
21848: PUSH
21849: LD_VAR 0 2
21853: PUSH
21854: LD_VAR 0 4
21858: MINUS
21859: ST_TO_ADDR
// if y - r < 0 then
21860: LD_VAR 0 3
21864: PUSH
21865: LD_VAR 0 4
21869: MINUS
21870: PUSH
21871: LD_INT 0
21873: LESS
21874: IFFALSE 21886
// min_y := 0 else
21876: LD_ADDR_VAR 0 8
21880: PUSH
21881: LD_INT 0
21883: ST_TO_ADDR
21884: GO 21902
// min_y := y - r ;
21886: LD_ADDR_VAR 0 8
21890: PUSH
21891: LD_VAR 0 3
21895: PUSH
21896: LD_VAR 0 4
21900: MINUS
21901: ST_TO_ADDR
// max_x := x + r ;
21902: LD_ADDR_VAR 0 9
21906: PUSH
21907: LD_VAR 0 2
21911: PUSH
21912: LD_VAR 0 4
21916: PLUS
21917: ST_TO_ADDR
// max_y := y + r ;
21918: LD_ADDR_VAR 0 10
21922: PUSH
21923: LD_VAR 0 3
21927: PUSH
21928: LD_VAR 0 4
21932: PLUS
21933: ST_TO_ADDR
// for _x = min_x to max_x do
21934: LD_ADDR_VAR 0 11
21938: PUSH
21939: DOUBLE
21940: LD_VAR 0 7
21944: DEC
21945: ST_TO_ADDR
21946: LD_VAR 0 9
21950: PUSH
21951: FOR_TO
21952: IFFALSE 22069
// for _y = min_y to max_y do
21954: LD_ADDR_VAR 0 12
21958: PUSH
21959: DOUBLE
21960: LD_VAR 0 8
21964: DEC
21965: ST_TO_ADDR
21966: LD_VAR 0 10
21970: PUSH
21971: FOR_TO
21972: IFFALSE 22065
// begin if not ValidHex ( _x , _y ) then
21974: LD_VAR 0 11
21978: PPUSH
21979: LD_VAR 0 12
21983: PPUSH
21984: CALL_OW 488
21988: NOT
21989: IFFALSE 21993
// continue ;
21991: GO 21971
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
21993: LD_VAR 0 11
21997: PPUSH
21998: LD_VAR 0 12
22002: PPUSH
22003: CALL_OW 351
22007: PUSH
22008: LD_VAR 0 11
22012: PPUSH
22013: LD_VAR 0 12
22017: PPUSH
22018: CALL_OW 554
22022: AND
22023: IFFALSE 22063
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22025: LD_ADDR_VAR 0 13
22029: PUSH
22030: LD_VAR 0 13
22034: PPUSH
22035: LD_VAR 0 13
22039: PUSH
22040: LD_INT 1
22042: PLUS
22043: PPUSH
22044: LD_VAR 0 11
22048: PUSH
22049: LD_VAR 0 12
22053: PUSH
22054: EMPTY
22055: LIST
22056: LIST
22057: PPUSH
22058: CALL_OW 2
22062: ST_TO_ADDR
// end ;
22063: GO 21971
22065: POP
22066: POP
22067: GO 21951
22069: POP
22070: POP
// if not list then
22071: LD_VAR 0 13
22075: NOT
22076: IFFALSE 22080
// exit ;
22078: GO 22151
// for i in list do
22080: LD_ADDR_VAR 0 6
22084: PUSH
22085: LD_VAR 0 13
22089: PUSH
22090: FOR_IN
22091: IFFALSE 22149
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22093: LD_VAR 0 1
22097: PPUSH
22098: LD_STRING M
22100: PUSH
22101: LD_VAR 0 6
22105: PUSH
22106: LD_INT 1
22108: ARRAY
22109: PUSH
22110: LD_VAR 0 6
22114: PUSH
22115: LD_INT 2
22117: ARRAY
22118: PUSH
22119: LD_INT 0
22121: PUSH
22122: LD_INT 0
22124: PUSH
22125: LD_INT 0
22127: PUSH
22128: LD_INT 0
22130: PUSH
22131: EMPTY
22132: LIST
22133: LIST
22134: LIST
22135: LIST
22136: LIST
22137: LIST
22138: LIST
22139: PUSH
22140: EMPTY
22141: LIST
22142: PPUSH
22143: CALL_OW 447
22147: GO 22090
22149: POP
22150: POP
// end ;
22151: LD_VAR 0 5
22155: RET
