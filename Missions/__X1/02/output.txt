// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 589 0 0
// PrepareAmericans ;
  23: CALL 835 0 0
// PrepareArabian ;
  27: CALL 9907 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 198 0 0
// Action ;
  41: CALL 4431 0 0
// end ;
  45: END
// export debug , prefix , missionStart , aviradzeSpotted , deltaSpotted , sciSpotted , aviradzeQuestDone , sciCounterKill , usAlert , usActiveDefend , timeUntilFarmer , attackDeltaAllowed , trickyMove , usPatrol , trap , lostCounter ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := false ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// aviradzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 6
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 8
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// aviradzeQuestDone := false ;
  97: LD_ADDR_EXP 7
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// attackDeltaAllowed := false ;
 105: LD_ADDR_EXP 12
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// usAlert := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// usActiveDefend := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// usPatrol := [ ] ;
 129: LD_ADDR_EXP 14
 133: PUSH
 134: EMPTY
 135: ST_TO_ADDR
// timeUntilFarmer := [ 40 40$00 , 30 30$00 , 20 20$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 11
 140: PUSH
 141: LD_INT 84000
 143: PUSH
 144: LD_INT 63000
 146: PUSH
 147: LD_INT 42000
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// trickyMove := false ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// prefix := 01_ ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 01_
 176: ST_TO_ADDR
// trap := 0 ;
 177: LD_ADDR_EXP 15
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// lostCounter := false ;
 185: LD_ADDR_EXP 16
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// end ;
 193: LD_VAR 0 1
 197: RET
// function DebugMode ; begin
 198: LD_INT 0
 200: PPUSH
// FogOff ( 1 ) ;
 201: LD_INT 1
 203: PPUSH
 204: CALL_OW 344
// Difficulty := 2 ;
 208: LD_ADDR_OWVAR 67
 212: PUSH
 213: LD_INT 2
 215: ST_TO_ADDR
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
// if exist_mode then
 225: LD_VAR 0 2
 229: IFFALSE 254
// unit := CreateCharacter ( prefix & ident ) else
 231: LD_ADDR_VAR 0 5
 235: PUSH
 236: LD_VAR 0 3
 240: PUSH
 241: LD_VAR 0 1
 245: STR
 246: PPUSH
 247: CALL_OW 34
 251: ST_TO_ADDR
 252: GO 269
// unit := NewCharacter ( ident ) ;
 254: LD_ADDR_VAR 0 5
 258: PUSH
 259: LD_VAR 0 1
 263: PPUSH
 264: CALL_OW 25
 268: ST_TO_ADDR
// result := unit ;
 269: LD_ADDR_VAR 0 4
 273: PUSH
 274: LD_VAR 0 5
 278: ST_TO_ADDR
// end ;
 279: LD_VAR 0 4
 283: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 284: LD_INT 0
 286: PPUSH
// uc_side := side ;
 287: LD_ADDR_OWVAR 20
 291: PUSH
 292: LD_VAR 0 1
 296: ST_TO_ADDR
// uc_nation := nation ;
 297: LD_ADDR_OWVAR 21
 301: PUSH
 302: LD_VAR 0 2
 306: ST_TO_ADDR
// vc_chassis := chassis ;
 307: LD_ADDR_OWVAR 37
 311: PUSH
 312: LD_VAR 0 3
 316: ST_TO_ADDR
// vc_engine := engine ;
 317: LD_ADDR_OWVAR 39
 321: PUSH
 322: LD_VAR 0 4
 326: ST_TO_ADDR
// vc_control := control ;
 327: LD_ADDR_OWVAR 38
 331: PUSH
 332: LD_VAR 0 5
 336: ST_TO_ADDR
// vc_weapon := weapon ;
 337: LD_ADDR_OWVAR 40
 341: PUSH
 342: LD_VAR 0 6
 346: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 347: LD_ADDR_OWVAR 41
 351: PUSH
 352: LD_VAR 0 7
 356: ST_TO_ADDR
// result := CreateVehicle ;
 357: LD_ADDR_VAR 0 8
 361: PUSH
 362: CALL_OW 45
 366: ST_TO_ADDR
// end ;
 367: LD_VAR 0 8
 371: RET
// export function SayX ( units , ident ) ; var i ; begin
 372: LD_INT 0
 374: PPUSH
 375: PPUSH
// result := false ;
 376: LD_ADDR_VAR 0 3
 380: PUSH
 381: LD_INT 0
 383: ST_TO_ADDR
// if not units then
 384: LD_VAR 0 1
 388: NOT
 389: IFFALSE 393
// exit ;
 391: GO 447
// for i in units do
 393: LD_ADDR_VAR 0 4
 397: PUSH
 398: LD_VAR 0 1
 402: PUSH
 403: FOR_IN
 404: IFFALSE 445
// if IsOk ( i ) then
 406: LD_VAR 0 4
 410: PPUSH
 411: CALL_OW 302
 415: IFFALSE 443
// begin Say ( i , ident ) ;
 417: LD_VAR 0 4
 421: PPUSH
 422: LD_VAR 0 2
 426: PPUSH
 427: CALL_OW 88
// result := i ;
 431: LD_ADDR_VAR 0 3
 435: PUSH
 436: LD_VAR 0 4
 440: ST_TO_ADDR
// break ;
 441: GO 445
// end ;
 443: GO 403
 445: POP
 446: POP
// end ;
 447: LD_VAR 0 3
 451: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 452: LD_INT 0
 454: PPUSH
 455: PPUSH
// InitUc ;
 456: CALL_OW 18
// InitHc ;
 460: CALL_OW 19
// uc_side := 0 ;
 464: LD_ADDR_OWVAR 20
 468: PUSH
 469: LD_INT 0
 471: ST_TO_ADDR
// uc_nation := 0 ;
 472: LD_ADDR_OWVAR 21
 476: PUSH
 477: LD_INT 0
 479: ST_TO_ADDR
// for i = 1 to amount do
 480: LD_ADDR_VAR 0 4
 484: PUSH
 485: DOUBLE
 486: LD_INT 1
 488: DEC
 489: ST_TO_ADDR
 490: LD_VAR 0 2
 494: PUSH
 495: FOR_TO
 496: IFFALSE 578
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 498: LD_ADDR_OWVAR 29
 502: PUSH
 503: LD_INT 9
 505: PPUSH
 506: LD_INT 12
 508: PPUSH
 509: CALL_OW 12
 513: PUSH
 514: LD_INT 9
 516: PPUSH
 517: LD_INT 12
 519: PPUSH
 520: CALL_OW 12
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 529: LD_ADDR_OWVAR 35
 533: PUSH
 534: LD_INT 1
 536: NEG
 537: PPUSH
 538: LD_INT 1
 540: PPUSH
 541: CALL_OW 12
 545: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 546: LD_INT 0
 548: PPUSH
 549: LD_INT 12
 551: PPUSH
 552: LD_INT 1
 554: PPUSH
 555: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 559: CALL_OW 44
 563: PPUSH
 564: LD_VAR 0 1
 568: PPUSH
 569: LD_INT 0
 571: PPUSH
 572: CALL_OW 49
// end ;
 576: GO 495
 578: POP
 579: POP
// InitHc ;
 580: CALL_OW 19
// end ;
 584: LD_VAR 0 3
 588: RET
// export function PrepareNature ; var i ; begin
 589: LD_INT 0
 591: PPUSH
 592: PPUSH
// SpawnApeman ( forest , 9 ) ;
 593: LD_INT 1
 595: PPUSH
 596: LD_INT 9
 598: PPUSH
 599: CALL 452 0 2
// for i := 1 to 4 do
 603: LD_ADDR_VAR 0 2
 607: PUSH
 608: DOUBLE
 609: LD_INT 1
 611: DEC
 612: ST_TO_ADDR
 613: LD_INT 4
 615: PUSH
 616: FOR_TO
 617: IFFALSE 652
// begin hc_class := 21 ;
 619: LD_ADDR_OWVAR 28
 623: PUSH
 624: LD_INT 21
 626: ST_TO_ADDR
// hc_gallery :=  ;
 627: LD_ADDR_OWVAR 33
 631: PUSH
 632: LD_STRING 
 634: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 635: CALL_OW 44
 639: PPUSH
 640: LD_INT 1
 642: PPUSH
 643: LD_INT 0
 645: PPUSH
 646: CALL_OW 49
// end ;
 650: GO 616
 652: POP
 653: POP
// for i := 1 to 2 do
 654: LD_ADDR_VAR 0 2
 658: PUSH
 659: DOUBLE
 660: LD_INT 1
 662: DEC
 663: ST_TO_ADDR
 664: LD_INT 2
 666: PUSH
 667: FOR_TO
 668: IFFALSE 703
// begin hc_class := 18 ;
 670: LD_ADDR_OWVAR 28
 674: PUSH
 675: LD_INT 18
 677: ST_TO_ADDR
// hc_gallery :=  ;
 678: LD_ADDR_OWVAR 33
 682: PUSH
 683: LD_STRING 
 685: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 686: CALL_OW 44
 690: PPUSH
 691: LD_INT 1
 693: PPUSH
 694: LD_INT 0
 696: PPUSH
 697: CALL_OW 49
// end ;
 701: GO 667
 703: POP
 704: POP
// for i := 1 to 3 do
 705: LD_ADDR_VAR 0 2
 709: PUSH
 710: DOUBLE
 711: LD_INT 1
 713: DEC
 714: ST_TO_ADDR
 715: LD_INT 3
 717: PUSH
 718: FOR_TO
 719: IFFALSE 754
// begin hc_class := 13 ;
 721: LD_ADDR_OWVAR 28
 725: PUSH
 726: LD_INT 13
 728: ST_TO_ADDR
// hc_gallery :=  ;
 729: LD_ADDR_OWVAR 33
 733: PUSH
 734: LD_STRING 
 736: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 737: CALL_OW 44
 741: PPUSH
 742: LD_INT 1
 744: PPUSH
 745: LD_INT 0
 747: PPUSH
 748: CALL_OW 49
// end ;
 752: GO 718
 754: POP
 755: POP
// end ;
 756: LD_VAR 0 1
 760: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 761: LD_INT 0
 763: PPUSH
 764: PPUSH
 765: PPUSH
// if not observer or not unit then
 766: LD_VAR 0 1
 770: NOT
 771: PUSH
 772: LD_VAR 0 2
 776: NOT
 777: OR
 778: IFFALSE 782
// exit ;
 780: GO 830
// if not See ( GetSide ( observer ) , unit ) then
 782: LD_VAR 0 1
 786: PPUSH
 787: CALL_OW 255
 791: PPUSH
 792: LD_VAR 0 2
 796: PPUSH
 797: CALL_OW 292
 801: NOT
 802: IFFALSE 806
// exit ;
 804: GO 830
// result := GetDistUnits ( observer , unit ) < 12 ;
 806: LD_ADDR_VAR 0 3
 810: PUSH
 811: LD_VAR 0 1
 815: PPUSH
 816: LD_VAR 0 2
 820: PPUSH
 821: CALL_OW 296
 825: PUSH
 826: LD_INT 12
 828: LESS
 829: ST_TO_ADDR
// end ; end_of_file
 830: LD_VAR 0 3
 834: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp , arm ; begin
 835: LD_INT 0
 837: PPUSH
 838: PPUSH
 839: PPUSH
 840: PPUSH
 841: PPUSH
 842: PPUSH
// usForces := [ ] ;
 843: LD_ADDR_EXP 19
 847: PUSH
 848: EMPTY
 849: ST_TO_ADDR
// usSci := [ ] ;
 850: LD_ADDR_EXP 20
 854: PUSH
 855: EMPTY
 856: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 857: LD_INT 1
 859: PPUSH
 860: LD_STRING Delta
 862: PPUSH
 863: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 867: LD_INT 1
 869: PPUSH
 870: CALL_OW 274
 874: PPUSH
 875: LD_INT 1
 877: PPUSH
 878: LD_INT 400
 880: PPUSH
 881: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 885: LD_INT 1
 887: PPUSH
 888: CALL_OW 274
 892: PPUSH
 893: LD_INT 2
 895: PPUSH
 896: LD_INT 80
 898: PPUSH
 899: CALL_OW 277
// uc_side := 1 ;
 903: LD_ADDR_OWVAR 20
 907: PUSH
 908: LD_INT 1
 910: ST_TO_ADDR
// uc_nation := 1 ;
 911: LD_ADDR_OWVAR 21
 915: PUSH
 916: LD_INT 1
 918: ST_TO_ADDR
// InitHc ;
 919: CALL_OW 19
// hc_importance := 0 ;
 923: LD_ADDR_OWVAR 32
 927: PUSH
 928: LD_INT 0
 930: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 931: LD_ADDR_EXP 18
 935: PUSH
 936: LD_STRING Lynch
 938: PPUSH
 939: LD_INT 0
 941: PPUSH
 942: LD_STRING 
 944: PPUSH
 945: CALL 221 0 3
 949: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 950: LD_ADDR_EXP 17
 954: PUSH
 955: LD_STRING Gladstone
 957: PPUSH
 958: LD_INT 0
 960: PPUSH
 961: LD_STRING 
 963: PPUSH
 964: CALL 221 0 3
 968: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 969: LD_EXP 18
 973: PPUSH
 974: LD_INT 1
 976: PPUSH
 977: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 981: LD_EXP 17
 985: PPUSH
 986: LD_INT 3
 988: PPUSH
 989: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
 993: LD_ADDR_VAR 0 2
 997: PUSH
 998: DOUBLE
 999: LD_INT 1
1001: DEC
1002: ST_TO_ADDR
1003: LD_INT 1
1005: PUSH
1006: LD_INT 2
1008: PUSH
1009: LD_INT 2
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: PUSH
1017: LD_OWVAR 67
1021: ARRAY
1022: PUSH
1023: FOR_TO
1024: IFFALSE 1070
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1026: LD_INT 0
1028: PPUSH
1029: LD_INT 2
1031: PPUSH
1032: LD_INT 1
1034: PUSH
1035: LD_INT 2
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: PUSH
1046: LD_OWVAR 67
1050: ARRAY
1051: PPUSH
1052: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
1056: CALL_OW 44
1060: PPUSH
1061: LD_INT 1
1063: PPUSH
1064: CALL_OW 52
// end ;
1068: GO 1023
1070: POP
1071: POP
// for i := 1 to 2 + Difficulty do
1072: LD_ADDR_VAR 0 2
1076: PUSH
1077: DOUBLE
1078: LD_INT 1
1080: DEC
1081: ST_TO_ADDR
1082: LD_INT 2
1084: PUSH
1085: LD_OWVAR 67
1089: PLUS
1090: PUSH
1091: FOR_TO
1092: IFFALSE 1177
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1094: LD_INT 0
1096: PPUSH
1097: LD_INT 4
1099: PPUSH
1100: LD_INT 1
1102: PUSH
1103: LD_INT 2
1105: PUSH
1106: LD_INT 2
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: PUSH
1114: LD_OWVAR 67
1118: ARRAY
1119: PPUSH
1120: CALL_OW 380
// un := CreateHuman ;
1124: LD_ADDR_VAR 0 3
1128: PUSH
1129: CALL_OW 44
1133: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
1134: LD_VAR 0 3
1138: PPUSH
1139: LD_INT 3
1141: PPUSH
1142: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
1146: LD_ADDR_EXP 20
1150: PUSH
1151: LD_EXP 20
1155: PPUSH
1156: LD_EXP 20
1160: PUSH
1161: LD_INT 1
1163: PLUS
1164: PPUSH
1165: LD_VAR 0 3
1169: PPUSH
1170: CALL_OW 1
1174: ST_TO_ADDR
// end ;
1175: GO 1091
1177: POP
1178: POP
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
1179: LD_ADDR_VAR 0 6
1183: PUSH
1184: LD_INT 22
1186: PUSH
1187: LD_INT 1
1189: PUSH
1190: EMPTY
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 30
1196: PUSH
1197: LD_INT 4
1199: PUSH
1200: EMPTY
1201: LIST
1202: LIST
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PPUSH
1208: CALL_OW 69
1212: ST_TO_ADDR
// for i := 1 to 3 + Difficulty do
1213: LD_ADDR_VAR 0 2
1217: PUSH
1218: DOUBLE
1219: LD_INT 1
1221: DEC
1222: ST_TO_ADDR
1223: LD_INT 3
1225: PUSH
1226: LD_OWVAR 67
1230: PLUS
1231: PUSH
1232: FOR_TO
1233: IFFALSE 1311
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1235: LD_INT 0
1237: PPUSH
1238: LD_INT 1
1240: PPUSH
1241: LD_INT 1
1243: PUSH
1244: LD_INT 2
1246: PUSH
1247: LD_INT 3
1249: PUSH
1250: EMPTY
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_OWVAR 67
1259: ARRAY
1260: PPUSH
1261: CALL_OW 380
// un := CreateHuman ;
1265: LD_ADDR_VAR 0 3
1269: PUSH
1270: CALL_OW 44
1274: ST_TO_ADDR
// usForces := usForces ^ un ;
1275: LD_ADDR_EXP 19
1279: PUSH
1280: LD_EXP 19
1284: PUSH
1285: LD_VAR 0 3
1289: ADD
1290: ST_TO_ADDR
// PlaceHumanInUnit ( un , arm [ 1 ] ) ;
1291: LD_VAR 0 3
1295: PPUSH
1296: LD_VAR 0 6
1300: PUSH
1301: LD_INT 1
1303: ARRAY
1304: PPUSH
1305: CALL_OW 52
// end ;
1309: GO 1232
1311: POP
1312: POP
// PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1313: LD_INT 1
1315: PPUSH
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 1
1321: PPUSH
1322: LD_INT 2
1324: PPUSH
1325: LD_INT 1
1327: PPUSH
1328: LD_INT 2
1330: PPUSH
1331: LD_INT 100
1333: PPUSH
1334: CALL 284 0 7
// veh := CreateVehicle ;
1338: LD_ADDR_VAR 0 4
1342: PUSH
1343: CALL_OW 45
1347: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1348: LD_VAR 0 4
1352: PPUSH
1353: LD_INT 2
1355: PPUSH
1356: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 24 , false ) ;
1360: LD_VAR 0 4
1364: PPUSH
1365: LD_INT 43
1367: PPUSH
1368: LD_INT 24
1370: PPUSH
1371: LD_INT 0
1373: PPUSH
1374: CALL_OW 48
// end ;
1378: LD_VAR 0 1
1382: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1383: LD_INT 0
1385: PPUSH
1386: PPUSH
1387: PPUSH
1388: PPUSH
1389: PPUSH
1390: PPUSH
// if not usSci then
1391: LD_EXP 20
1395: NOT
1396: IFFALSE 1400
// exit ;
1398: GO 1574
// xy := AreaToList ( tameArea , 0 ) ;
1400: LD_ADDR_VAR 0 6
1404: PUSH
1405: LD_INT 5
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL_OW 517
1415: ST_TO_ADDR
// for i in usSci do
1416: LD_ADDR_VAR 0 2
1420: PUSH
1421: LD_EXP 20
1425: PUSH
1426: FOR_IN
1427: IFFALSE 1572
// begin k := rand ( 1 , xy [ 1 ] ) ;
1429: LD_ADDR_VAR 0 4
1433: PUSH
1434: LD_INT 1
1436: PPUSH
1437: LD_VAR 0 6
1441: PUSH
1442: LD_INT 1
1444: ARRAY
1445: PPUSH
1446: CALL_OW 12
1450: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1451: LD_VAR 0 2
1455: PPUSH
1456: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1460: LD_VAR 0 2
1464: PPUSH
1465: LD_VAR 0 6
1469: PUSH
1470: LD_INT 1
1472: ARRAY
1473: PUSH
1474: LD_VAR 0 4
1478: ARRAY
1479: PPUSH
1480: LD_VAR 0 6
1484: PUSH
1485: LD_INT 2
1487: ARRAY
1488: PUSH
1489: LD_VAR 0 4
1493: ARRAY
1494: PPUSH
1495: CALL_OW 171
// for j := 1 to 2 do
1499: LD_ADDR_VAR 0 3
1503: PUSH
1504: DOUBLE
1505: LD_INT 1
1507: DEC
1508: ST_TO_ADDR
1509: LD_INT 2
1511: PUSH
1512: FOR_TO
1513: IFFALSE 1568
// begin tmp := Delete ( xy [ j ] , k ) ;
1515: LD_ADDR_VAR 0 5
1519: PUSH
1520: LD_VAR 0 6
1524: PUSH
1525: LD_VAR 0 3
1529: ARRAY
1530: PPUSH
1531: LD_VAR 0 4
1535: PPUSH
1536: CALL_OW 3
1540: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1541: LD_ADDR_VAR 0 6
1545: PUSH
1546: LD_VAR 0 6
1550: PPUSH
1551: LD_VAR 0 3
1555: PPUSH
1556: LD_VAR 0 5
1560: PPUSH
1561: CALL_OW 1
1565: ST_TO_ADDR
// end ;
1566: GO 1512
1568: POP
1569: POP
// end ;
1570: GO 1426
1572: POP
1573: POP
// end ;
1574: LD_VAR 0 1
1578: RET
// every 0 0$5 + 0 0$10 trigger usSci and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1579: LD_EXP 20
1583: PUSH
1584: LD_INT 22
1586: PUSH
1587: LD_INT 0
1589: PUSH
1590: EMPTY
1591: LIST
1592: LIST
1593: PUSH
1594: LD_INT 25
1596: PUSH
1597: LD_INT 12
1599: PUSH
1600: EMPTY
1601: LIST
1602: LIST
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: PPUSH
1608: CALL_OW 69
1612: AND
1613: IFFALSE 2102
1615: GO 1617
1617: DISABLE
1618: LD_INT 0
1620: PPUSH
1621: PPUSH
1622: PPUSH
1623: PPUSH
1624: PPUSH
// begin enable ;
1625: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1626: LD_EXP 20
1630: PPUSH
1631: LD_INT 2
1633: PUSH
1634: LD_INT 60
1636: PUSH
1637: EMPTY
1638: LIST
1639: PUSH
1640: LD_INT 54
1642: PUSH
1643: EMPTY
1644: LIST
1645: PUSH
1646: EMPTY
1647: LIST
1648: LIST
1649: LIST
1650: PPUSH
1651: CALL_OW 72
1655: IFFALSE 1659
// exit ;
1657: GO 2102
// for i in usSci do
1659: LD_ADDR_VAR 0 1
1663: PUSH
1664: LD_EXP 20
1668: PUSH
1669: FOR_IN
1670: IFFALSE 2100
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1672: LD_VAR 0 1
1676: PPUSH
1677: CALL_OW 314
1681: NOT
1682: PUSH
1683: LD_VAR 0 1
1687: PPUSH
1688: CALL_OW 256
1692: PUSH
1693: LD_INT 1000
1695: EQUAL
1696: AND
1697: IFFALSE 1904
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1699: LD_ADDR_VAR 0 5
1703: PUSH
1704: LD_INT 22
1706: PUSH
1707: LD_INT 0
1709: PUSH
1710: EMPTY
1711: LIST
1712: LIST
1713: PUSH
1714: LD_INT 25
1716: PUSH
1717: LD_INT 12
1719: PUSH
1720: EMPTY
1721: LIST
1722: LIST
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: PPUSH
1728: CALL_OW 69
1732: PPUSH
1733: LD_VAR 0 1
1737: PPUSH
1738: CALL_OW 74
1742: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1743: LD_VAR 0 1
1747: PPUSH
1748: LD_VAR 0 5
1752: PPUSH
1753: CALL_OW 296
1757: PUSH
1758: LD_INT 10
1760: LESS
1761: IFFALSE 1794
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1763: LD_VAR 0 1
1767: PPUSH
1768: LD_VAR 0 5
1772: PPUSH
1773: CALL_OW 250
1777: PPUSH
1778: LD_VAR 0 5
1782: PPUSH
1783: CALL_OW 251
1787: PPUSH
1788: CALL_OW 131
1792: GO 1904
// begin d := rand ( 0 , 5 ) ;
1794: LD_ADDR_VAR 0 4
1798: PUSH
1799: LD_INT 0
1801: PPUSH
1802: LD_INT 5
1804: PPUSH
1805: CALL_OW 12
1809: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1810: LD_ADDR_VAR 0 2
1814: PUSH
1815: LD_VAR 0 1
1819: PPUSH
1820: CALL_OW 250
1824: PPUSH
1825: LD_VAR 0 4
1829: PPUSH
1830: LD_INT 3
1832: PPUSH
1833: CALL_OW 272
1837: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
1838: LD_ADDR_VAR 0 3
1842: PUSH
1843: LD_VAR 0 1
1847: PPUSH
1848: CALL_OW 251
1852: PPUSH
1853: LD_VAR 0 4
1857: PPUSH
1858: LD_INT 3
1860: PPUSH
1861: CALL_OW 273
1865: ST_TO_ADDR
// if not ValidHex ( x , y ) then
1866: LD_VAR 0 2
1870: PPUSH
1871: LD_VAR 0 3
1875: PPUSH
1876: CALL_OW 488
1880: NOT
1881: IFFALSE 1885
// continue ;
1883: GO 1669
// ComMoveXY ( i , x , y ) ;
1885: LD_VAR 0 1
1889: PPUSH
1890: LD_VAR 0 2
1894: PPUSH
1895: LD_VAR 0 3
1899: PPUSH
1900: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
1904: LD_VAR 0 1
1908: PPUSH
1909: CALL_OW 256
1913: PUSH
1914: LD_INT 900
1916: LESS
1917: PUSH
1918: LD_VAR 0 1
1922: PPUSH
1923: LD_INT 37
1925: PPUSH
1926: LD_INT 23
1928: PPUSH
1929: CALL_OW 297
1933: PUSH
1934: LD_INT 10
1936: GREATER
1937: AND
1938: IFFALSE 1988
// begin if IsOk ( Gladstone ) and IsInUnit ( Gladstone ) then
1940: LD_EXP 17
1944: PPUSH
1945: CALL_OW 302
1949: PUSH
1950: LD_EXP 17
1954: PPUSH
1955: CALL_OW 310
1959: AND
1960: IFFALSE 1971
// ComExitBuilding ( Gladstone ) ;
1962: LD_EXP 17
1966: PPUSH
1967: CALL_OW 122
// ComMoveXY ( i , 37 , 23 ) ;
1971: LD_VAR 0 1
1975: PPUSH
1976: LD_INT 37
1978: PPUSH
1979: LD_INT 23
1981: PPUSH
1982: CALL_OW 111
// end else
1986: GO 2098
// if GetLives ( i ) = 1000 then
1988: LD_VAR 0 1
1992: PPUSH
1993: CALL_OW 256
1997: PUSH
1998: LD_INT 1000
2000: EQUAL
2001: IFFALSE 2098
// begin if IsOk ( Gladstone ) then
2003: LD_EXP 17
2007: PPUSH
2008: CALL_OW 302
2012: IFFALSE 2026
// ComEnterUnit ( Gladstone , usLab ) ;
2014: LD_EXP 17
2018: PPUSH
2019: LD_INT 3
2021: PPUSH
2022: CALL_OW 120
// if SideShoot ( i ) = 2 then
2026: LD_VAR 0 1
2030: PPUSH
2031: CALL_OW 503
2035: PUSH
2036: LD_INT 2
2038: EQUAL
2039: IFFALSE 2086
// begin if not usAlert then
2041: LD_EXP 9
2045: NOT
2046: IFFALSE 2056
// usAlert := true ;
2048: LD_ADDR_EXP 9
2052: PUSH
2053: LD_INT 1
2055: ST_TO_ADDR
// AddComEnterUnit ( i , usLab ) ;
2056: LD_VAR 0 1
2060: PPUSH
2061: LD_INT 3
2063: PPUSH
2064: CALL_OW 180
// usSci := usSci diff i ;
2068: LD_ADDR_EXP 20
2072: PUSH
2073: LD_EXP 20
2077: PUSH
2078: LD_VAR 0 1
2082: DIFF
2083: ST_TO_ADDR
// end else
2084: GO 2098
// ComMoveToArea ( i , tameArea ) ;
2086: LD_VAR 0 1
2090: PPUSH
2091: LD_INT 5
2093: PPUSH
2094: CALL_OW 113
// end ; end ;
2098: GO 1669
2100: POP
2101: POP
// end ;
2102: PPOPN 5
2104: END
// every 0 0$1 trigger not usAlert and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 999 ] ] ] ) or FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) ) do
2105: LD_EXP 9
2109: NOT
2110: PUSH
2111: LD_INT 22
2113: PUSH
2114: LD_INT 1
2116: PUSH
2117: EMPTY
2118: LIST
2119: LIST
2120: PUSH
2121: LD_INT 21
2123: PUSH
2124: LD_INT 3
2126: PUSH
2127: EMPTY
2128: LIST
2129: LIST
2130: PUSH
2131: LD_INT 3
2133: PUSH
2134: LD_INT 57
2136: PUSH
2137: EMPTY
2138: LIST
2139: PUSH
2140: EMPTY
2141: LIST
2142: LIST
2143: PUSH
2144: LD_INT 3
2146: PUSH
2147: LD_INT 24
2149: PUSH
2150: LD_INT 999
2152: PUSH
2153: EMPTY
2154: LIST
2155: LIST
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PUSH
2161: EMPTY
2162: LIST
2163: LIST
2164: LIST
2165: LIST
2166: PPUSH
2167: CALL_OW 69
2171: PUSH
2172: LD_INT 7
2174: PPUSH
2175: LD_INT 22
2177: PUSH
2178: LD_INT 2
2180: PUSH
2181: EMPTY
2182: LIST
2183: LIST
2184: PPUSH
2185: CALL_OW 70
2189: OR
2190: AND
2191: IFFALSE 2204
2193: GO 2195
2195: DISABLE
// usAlert := true ;
2196: LD_ADDR_EXP 9
2200: PUSH
2201: LD_INT 1
2203: ST_TO_ADDR
2204: END
// every 0 0$1 trigger usAlert do var i , b , arm ;
2205: LD_EXP 9
2209: IFFALSE 2556
2211: GO 2213
2213: DISABLE
2214: LD_INT 0
2216: PPUSH
2217: PPUSH
2218: PPUSH
// begin usActiveDefend := true ;
2219: LD_ADDR_EXP 10
2223: PUSH
2224: LD_INT 1
2226: ST_TO_ADDR
// if not usForces then
2227: LD_EXP 19
2231: NOT
2232: IFFALSE 2236
// exit ;
2234: GO 2556
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
2236: LD_ADDR_VAR 0 3
2240: PUSH
2241: LD_INT 22
2243: PUSH
2244: LD_INT 1
2246: PUSH
2247: EMPTY
2248: LIST
2249: LIST
2250: PUSH
2251: LD_INT 30
2253: PUSH
2254: LD_INT 4
2256: PUSH
2257: EMPTY
2258: LIST
2259: LIST
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PPUSH
2265: CALL_OW 69
2269: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: LD_INT 22
2277: PUSH
2278: LD_INT 1
2280: PUSH
2281: EMPTY
2282: LIST
2283: LIST
2284: PUSH
2285: LD_INT 30
2287: PUSH
2288: LD_INT 31
2290: PUSH
2291: EMPTY
2292: LIST
2293: LIST
2294: PUSH
2295: EMPTY
2296: LIST
2297: LIST
2298: PPUSH
2299: CALL_OW 69
2303: ST_TO_ADDR
// ComExitBuilding ( Lynch ) ;
2304: LD_EXP 18
2308: PPUSH
2309: CALL_OW 122
// AddComEnterUnit ( Lynch , arm [ 1 ] ) ;
2313: LD_EXP 18
2317: PPUSH
2318: LD_VAR 0 3
2322: PUSH
2323: LD_INT 1
2325: ARRAY
2326: PPUSH
2327: CALL_OW 180
// if IsOk ( Gladstone ) then
2331: LD_EXP 17
2335: PPUSH
2336: CALL_OW 302
2340: IFFALSE 2381
// begin ComExitBuilding ( Gladstone ) ;
2342: LD_EXP 17
2346: PPUSH
2347: CALL_OW 122
// AddComEnterUnit ( Gladstone , arm [ 1 ] ) ;
2351: LD_EXP 17
2355: PPUSH
2356: LD_VAR 0 3
2360: PUSH
2361: LD_INT 1
2363: ARRAY
2364: PPUSH
2365: CALL_OW 180
// AddComChangeProfession ( Gladstone , class_soldier ) ;
2369: LD_EXP 17
2373: PPUSH
2374: LD_INT 1
2376: PPUSH
2377: CALL_OW 183
// end ; ComExitBuilding ( usForces [ 1 ] ) ;
2381: LD_EXP 19
2385: PUSH
2386: LD_INT 1
2388: ARRAY
2389: PPUSH
2390: CALL_OW 122
// AddComEnterUnit ( usForces [ 1 ] , b [ 1 ] ) ;
2394: LD_EXP 19
2398: PUSH
2399: LD_INT 1
2401: ARRAY
2402: PPUSH
2403: LD_VAR 0 2
2407: PUSH
2408: LD_INT 1
2410: ARRAY
2411: PPUSH
2412: CALL_OW 180
// ComExitBuilding ( usForces [ 2 ] ) ;
2416: LD_EXP 19
2420: PUSH
2421: LD_INT 2
2423: ARRAY
2424: PPUSH
2425: CALL_OW 122
// AddComEnterUnit ( usForces [ 2 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
2429: LD_EXP 19
2433: PUSH
2434: LD_INT 2
2436: ARRAY
2437: PPUSH
2438: LD_INT 22
2440: PUSH
2441: LD_INT 1
2443: PUSH
2444: EMPTY
2445: LIST
2446: LIST
2447: PUSH
2448: LD_INT 30
2450: PUSH
2451: LD_INT 32
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: PUSH
2458: EMPTY
2459: LIST
2460: LIST
2461: PPUSH
2462: CALL_OW 69
2466: PUSH
2467: LD_INT 1
2469: ARRAY
2470: PPUSH
2471: CALL_OW 180
// if b > 1 and usForces > 2 then
2475: LD_VAR 0 2
2479: PUSH
2480: LD_INT 1
2482: GREATER
2483: PUSH
2484: LD_EXP 19
2488: PUSH
2489: LD_INT 2
2491: GREATER
2492: AND
2493: IFFALSE 2556
// begin repeat wait ( 0 0$1 ) ;
2495: LD_INT 35
2497: PPUSH
2498: CALL_OW 67
// until BuildingStatus ( b [ 2 ] ) <> bs_build ;
2502: LD_VAR 0 2
2506: PUSH
2507: LD_INT 2
2509: ARRAY
2510: PPUSH
2511: CALL_OW 461
2515: PUSH
2516: LD_INT 1
2518: NONEQUAL
2519: IFFALSE 2495
// ComExitBuilding ( usForces [ 3 ] ) ;
2521: LD_EXP 19
2525: PUSH
2526: LD_INT 3
2528: ARRAY
2529: PPUSH
2530: CALL_OW 122
// AddComEnterUnit ( usForces [ 3 ] , b [ 2 ] ) ;
2534: LD_EXP 19
2538: PUSH
2539: LD_INT 3
2541: ARRAY
2542: PPUSH
2543: LD_VAR 0 2
2547: PUSH
2548: LD_INT 2
2550: ARRAY
2551: PPUSH
2552: CALL_OW 180
// end ; end ;
2556: PPOPN 3
2558: END
// every 0 0$1 trigger GetLives ( usLab ) < 999 and usAlert and usForces do var i ;
2559: LD_INT 3
2561: PPUSH
2562: CALL_OW 256
2566: PUSH
2567: LD_INT 999
2569: LESS
2570: PUSH
2571: LD_EXP 9
2575: AND
2576: PUSH
2577: LD_EXP 19
2581: AND
2582: IFFALSE 2753
2584: GO 2586
2586: DISABLE
2587: LD_INT 0
2589: PPUSH
// begin for i in usForces do
2590: LD_ADDR_VAR 0 1
2594: PUSH
2595: LD_EXP 19
2599: PUSH
2600: FOR_IN
2601: IFFALSE 2640
// begin if IsInUnit ( i ) then
2603: LD_VAR 0 1
2607: PPUSH
2608: CALL_OW 310
2612: IFFALSE 2623
// ComExitBuilding ( i ) ;
2614: LD_VAR 0 1
2618: PPUSH
2619: CALL_OW 122
// AddComAgressiveMove ( i , 31 , 8 ) ;
2623: LD_VAR 0 1
2627: PPUSH
2628: LD_INT 31
2630: PPUSH
2631: LD_INT 8
2633: PPUSH
2634: CALL_OW 174
// end ;
2638: GO 2600
2640: POP
2641: POP
// wait ( 0 0$8 ) ;
2642: LD_INT 280
2644: PPUSH
2645: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) then
2649: LD_INT 22
2651: PUSH
2652: LD_INT 2
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: PUSH
2659: LD_INT 91
2661: PUSH
2662: LD_INT 3
2664: PUSH
2665: LD_INT 14
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PPUSH
2677: CALL_OW 69
2681: IFFALSE 2731
// ComAttackUnit ( usForces , FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) [ 1 ] ) else
2683: LD_EXP 19
2687: PPUSH
2688: LD_INT 22
2690: PUSH
2691: LD_INT 2
2693: PUSH
2694: EMPTY
2695: LIST
2696: LIST
2697: PUSH
2698: LD_INT 91
2700: PUSH
2701: LD_INT 3
2703: PUSH
2704: LD_INT 14
2706: PUSH
2707: EMPTY
2708: LIST
2709: LIST
2710: LIST
2711: PUSH
2712: EMPTY
2713: LIST
2714: LIST
2715: PPUSH
2716: CALL_OW 69
2720: PUSH
2721: LD_INT 1
2723: ARRAY
2724: PPUSH
2725: CALL_OW 115
2729: GO 2753
// begin wait ( 0 0$20 ) ;
2731: LD_INT 700
2733: PPUSH
2734: CALL_OW 67
// AddComMoveXY ( usForces , 39 , 19 ) ;
2738: LD_EXP 19
2742: PPUSH
2743: LD_INT 39
2745: PPUSH
2746: LD_INT 19
2748: PPUSH
2749: CALL_OW 171
// end ; end ;
2753: PPOPN 1
2755: END
// every 0 0$3 trigger ( GetDistUnits ( Heike , Delta ) < 10 or GetLives ( usLab ) < 999 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do var tmp , veh ;
2756: LD_EXP 21
2760: PPUSH
2761: LD_INT 1
2763: PPUSH
2764: CALL_OW 296
2768: PUSH
2769: LD_INT 10
2771: LESS
2772: PUSH
2773: LD_INT 3
2775: PPUSH
2776: CALL_OW 256
2780: PUSH
2781: LD_INT 999
2783: LESS
2784: OR
2785: PUSH
2786: LD_INT 22
2788: PUSH
2789: LD_INT 1
2791: PUSH
2792: EMPTY
2793: LIST
2794: LIST
2795: PUSH
2796: LD_INT 25
2798: PUSH
2799: LD_INT 2
2801: PUSH
2802: EMPTY
2803: LIST
2804: LIST
2805: PUSH
2806: EMPTY
2807: LIST
2808: LIST
2809: PPUSH
2810: CALL_OW 69
2814: AND
2815: IFFALSE 2999
2817: GO 2819
2819: DISABLE
2820: LD_INT 0
2822: PPUSH
2823: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
2824: LD_ADDR_VAR 0 1
2828: PUSH
2829: LD_INT 22
2831: PUSH
2832: LD_INT 1
2834: PUSH
2835: EMPTY
2836: LIST
2837: LIST
2838: PUSH
2839: LD_INT 25
2841: PUSH
2842: LD_INT 2
2844: PUSH
2845: EMPTY
2846: LIST
2847: LIST
2848: PUSH
2849: EMPTY
2850: LIST
2851: LIST
2852: PPUSH
2853: CALL_OW 69
2857: ST_TO_ADDR
// veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2858: LD_ADDR_VAR 0 2
2862: PUSH
2863: LD_INT 22
2865: PUSH
2866: LD_INT 1
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: PUSH
2873: LD_INT 21
2875: PUSH
2876: LD_INT 2
2878: PUSH
2879: EMPTY
2880: LIST
2881: LIST
2882: PUSH
2883: LD_INT 58
2885: PUSH
2886: EMPTY
2887: LIST
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: LIST
2893: PPUSH
2894: CALL_OW 69
2898: ST_TO_ADDR
// if not tmp then
2899: LD_VAR 0 1
2903: NOT
2904: IFFALSE 2908
// exit ;
2906: GO 2999
// ComExitBuilding ( tmp ) ;
2908: LD_VAR 0 1
2912: PPUSH
2913: CALL_OW 122
// AddComDismantle ( tmp , usLab ) ;
2917: LD_VAR 0 1
2921: PPUSH
2922: LD_INT 3
2924: PPUSH
2925: CALL_OW 227
// if veh and IsOk ( Gladstone ) then
2929: LD_VAR 0 2
2933: PUSH
2934: LD_EXP 17
2938: PPUSH
2939: CALL_OW 302
2943: AND
2944: IFFALSE 2999
// begin if IsInUnit ( Gladstone ) then
2946: LD_EXP 17
2950: PPUSH
2951: CALL_OW 310
2955: IFFALSE 2966
// ComExitBuilding ( Gladstone ) ;
2957: LD_EXP 17
2961: PPUSH
2962: CALL_OW 122
// AddComEnterUnit ( Gladstone , veh [ 1 ] ) ;
2966: LD_EXP 17
2970: PPUSH
2971: LD_VAR 0 2
2975: PUSH
2976: LD_INT 1
2978: ARRAY
2979: PPUSH
2980: CALL_OW 180
// AddComAgressiveMove ( Gladstone , 39 , 14 ) ;
2984: LD_EXP 17
2988: PPUSH
2989: LD_INT 39
2991: PPUSH
2992: LD_INT 14
2994: PPUSH
2995: CALL_OW 174
// end ; end ;
2999: PPOPN 2
3001: END
// every 0 0$1 trigger usAlert and FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) diff ( usForces union usSci ) do var i , tmp ;
3002: LD_EXP 9
3006: PUSH
3007: LD_INT 22
3009: PUSH
3010: LD_INT 1
3012: PUSH
3013: EMPTY
3014: LIST
3015: LIST
3016: PUSH
3017: LD_INT 21
3019: PUSH
3020: LD_INT 1
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 3
3029: PUSH
3030: LD_INT 24
3032: PUSH
3033: LD_INT 600
3035: PUSH
3036: EMPTY
3037: LIST
3038: LIST
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: LIST
3048: PPUSH
3049: CALL_OW 69
3053: PUSH
3054: LD_EXP 19
3058: PUSH
3059: LD_EXP 20
3063: UNION
3064: DIFF
3065: AND
3066: IFFALSE 3203
3068: GO 3070
3070: DISABLE
3071: LD_INT 0
3073: PPUSH
3074: PPUSH
// begin enable ;
3075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) diff ( usForces union usSci ) ;
3076: LD_ADDR_VAR 0 2
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 1
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 21
3093: PUSH
3094: LD_INT 1
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 3
3103: PUSH
3104: LD_INT 24
3106: PUSH
3107: LD_INT 600
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: PUSH
3118: EMPTY
3119: LIST
3120: LIST
3121: LIST
3122: PPUSH
3123: CALL_OW 69
3127: PUSH
3128: LD_EXP 19
3132: PUSH
3133: LD_EXP 20
3137: UNION
3138: DIFF
3139: ST_TO_ADDR
// if not tmp then
3140: LD_VAR 0 2
3144: NOT
3145: IFFALSE 3149
// exit ;
3147: GO 3203
// for i in tmp do
3149: LD_ADDR_VAR 0 1
3153: PUSH
3154: LD_VAR 0 2
3158: PUSH
3159: FOR_IN
3160: IFFALSE 3201
// if IsInUnit ( i ) then
3162: LD_VAR 0 1
3166: PPUSH
3167: CALL_OW 310
3171: IFFALSE 3184
// ComExitBuilding ( i ) else
3173: LD_VAR 0 1
3177: PPUSH
3178: CALL_OW 122
3182: GO 3199
// ComMoveXY ( i , 48 , 74 ) ;
3184: LD_VAR 0 1
3188: PPUSH
3189: LD_INT 48
3191: PPUSH
3192: LD_INT 74
3194: PPUSH
3195: CALL_OW 111
3199: GO 3159
3201: POP
3202: POP
// end ;
3203: PPOPN 2
3205: END
// every 5 5$00 do var i , un , tmp ;
3206: GO 3208
3208: DISABLE
3209: LD_INT 0
3211: PPUSH
3212: PPUSH
3213: PPUSH
// begin tmp := [ ] ;
3214: LD_ADDR_VAR 0 3
3218: PUSH
3219: EMPTY
3220: ST_TO_ADDR
// uc_side := 1 ;
3221: LD_ADDR_OWVAR 20
3225: PUSH
3226: LD_INT 1
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// case Difficulty of 1 :
3237: LD_OWVAR 67
3241: PUSH
3242: LD_INT 1
3244: DOUBLE
3245: EQUAL
3246: IFTRUE 3250
3248: GO 3353
3250: POP
// begin wait ( 1 1$00 ) ;
3251: LD_INT 2100
3253: PPUSH
3254: CALL_OW 67
// for i := 1 to 2 do
3258: LD_ADDR_VAR 0 1
3262: PUSH
3263: DOUBLE
3264: LD_INT 1
3266: DEC
3267: ST_TO_ADDR
3268: LD_INT 2
3270: PUSH
3271: FOR_TO
3272: IFFALSE 3349
// begin PrepareHuman ( false , [ 1 , 4 ] [ i mod 2 + 1 ] , 1 ) ;
3274: LD_INT 0
3276: PPUSH
3277: LD_INT 1
3279: PUSH
3280: LD_INT 4
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: PUSH
3287: LD_VAR 0 1
3291: PUSH
3292: LD_INT 2
3294: MOD
3295: PUSH
3296: LD_INT 1
3298: PLUS
3299: ARRAY
3300: PPUSH
3301: LD_INT 1
3303: PPUSH
3304: CALL_OW 380
// un := CreateHuman ;
3308: LD_ADDR_VAR 0 2
3312: PUSH
3313: CALL_OW 44
3317: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3318: LD_ADDR_VAR 0 3
3322: PUSH
3323: LD_VAR 0 3
3327: PPUSH
3328: LD_VAR 0 3
3332: PUSH
3333: LD_INT 1
3335: PLUS
3336: PPUSH
3337: LD_VAR 0 2
3341: PPUSH
3342: CALL_OW 1
3346: ST_TO_ADDR
// end ;
3347: GO 3271
3349: POP
3350: POP
// end ; 2 :
3351: GO 3747
3353: LD_INT 2
3355: DOUBLE
3356: EQUAL
3357: IFTRUE 3361
3359: GO 3495
3361: POP
// begin wait ( 0 0$30 ) ;
3362: LD_INT 1050
3364: PPUSH
3365: CALL_OW 67
// for i := 1 to 2 do
3369: LD_ADDR_VAR 0 1
3373: PUSH
3374: DOUBLE
3375: LD_INT 1
3377: DEC
3378: ST_TO_ADDR
3379: LD_INT 2
3381: PUSH
3382: FOR_TO
3383: IFFALSE 3439
// begin PrepareHuman ( false , 1 , 2 ) ;
3385: LD_INT 0
3387: PPUSH
3388: LD_INT 1
3390: PPUSH
3391: LD_INT 2
3393: PPUSH
3394: CALL_OW 380
// un := CreateHuman ;
3398: LD_ADDR_VAR 0 2
3402: PUSH
3403: CALL_OW 44
3407: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3408: LD_ADDR_VAR 0 3
3412: PUSH
3413: LD_VAR 0 3
3417: PPUSH
3418: LD_VAR 0 3
3422: PUSH
3423: LD_INT 1
3425: PLUS
3426: PPUSH
3427: LD_VAR 0 2
3431: PPUSH
3432: CALL_OW 1
3436: ST_TO_ADDR
// end ;
3437: GO 3382
3439: POP
3440: POP
// PrepareHuman ( false , 4 , 2 ) ;
3441: LD_INT 0
3443: PPUSH
3444: LD_INT 4
3446: PPUSH
3447: LD_INT 2
3449: PPUSH
3450: CALL_OW 380
// un := CreateHuman ;
3454: LD_ADDR_VAR 0 2
3458: PUSH
3459: CALL_OW 44
3463: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3464: LD_ADDR_VAR 0 3
3468: PUSH
3469: LD_VAR 0 3
3473: PPUSH
3474: LD_VAR 0 3
3478: PUSH
3479: LD_INT 1
3481: PLUS
3482: PPUSH
3483: LD_VAR 0 2
3487: PPUSH
3488: CALL_OW 1
3492: ST_TO_ADDR
// end ; 3 :
3493: GO 3747
3495: LD_INT 3
3497: DOUBLE
3498: EQUAL
3499: IFTRUE 3503
3501: GO 3746
3503: POP
// begin for i := 1 to 2 do
3504: LD_ADDR_VAR 0 1
3508: PUSH
3509: DOUBLE
3510: LD_INT 1
3512: DEC
3513: ST_TO_ADDR
3514: LD_INT 2
3516: PUSH
3517: FOR_TO
3518: IFFALSE 3574
// begin PrepareHuman ( false , 1 , 2 ) ;
3520: LD_INT 0
3522: PPUSH
3523: LD_INT 1
3525: PPUSH
3526: LD_INT 2
3528: PPUSH
3529: CALL_OW 380
// un := CreateHuman ;
3533: LD_ADDR_VAR 0 2
3537: PUSH
3538: CALL_OW 44
3542: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3543: LD_ADDR_VAR 0 3
3547: PUSH
3548: LD_VAR 0 3
3552: PPUSH
3553: LD_VAR 0 3
3557: PUSH
3558: LD_INT 1
3560: PLUS
3561: PPUSH
3562: LD_VAR 0 2
3566: PPUSH
3567: CALL_OW 1
3571: ST_TO_ADDR
// end ;
3572: GO 3517
3574: POP
3575: POP
// PrepareHuman ( false , 4 , 2 ) ;
3576: LD_INT 0
3578: PPUSH
3579: LD_INT 4
3581: PPUSH
3582: LD_INT 2
3584: PPUSH
3585: CALL_OW 380
// un := CreateHuman ;
3589: LD_ADDR_VAR 0 2
3593: PUSH
3594: CALL_OW 44
3598: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3599: LD_ADDR_VAR 0 3
3603: PUSH
3604: LD_VAR 0 3
3608: PPUSH
3609: LD_VAR 0 3
3613: PUSH
3614: LD_INT 1
3616: PLUS
3617: PPUSH
3618: LD_VAR 0 2
3622: PPUSH
3623: CALL_OW 1
3627: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_machine_gun , 90 ) ;
3628: LD_INT 1
3630: PPUSH
3631: LD_INT 1
3633: PPUSH
3634: LD_INT 2
3636: PPUSH
3637: LD_INT 2
3639: PPUSH
3640: LD_INT 1
3642: PPUSH
3643: LD_INT 2
3645: PPUSH
3646: LD_INT 90
3648: PPUSH
3649: CALL 284 0 7
// un := CreateVehicle ;
3653: LD_ADDR_VAR 0 2
3657: PUSH
3658: CALL_OW 45
3662: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3663: LD_ADDR_VAR 0 3
3667: PUSH
3668: LD_VAR 0 3
3672: PPUSH
3673: LD_VAR 0 3
3677: PUSH
3678: LD_INT 1
3680: PLUS
3681: PPUSH
3682: LD_VAR 0 2
3686: PPUSH
3687: CALL_OW 1
3691: ST_TO_ADDR
// PrepareHuman ( false , 1 , 2 ) ;
3692: LD_INT 0
3694: PPUSH
3695: LD_INT 1
3697: PPUSH
3698: LD_INT 2
3700: PPUSH
3701: CALL_OW 380
// un := CreateHuman ;
3705: LD_ADDR_VAR 0 2
3709: PUSH
3710: CALL_OW 44
3714: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3715: LD_ADDR_VAR 0 3
3719: PUSH
3720: LD_VAR 0 3
3724: PPUSH
3725: LD_VAR 0 3
3729: PUSH
3730: LD_INT 1
3732: PLUS
3733: PPUSH
3734: LD_VAR 0 2
3738: PPUSH
3739: CALL_OW 1
3743: ST_TO_ADDR
// end ; end ;
3744: GO 3747
3746: POP
// for i := 1 to tmp do
3747: LD_ADDR_VAR 0 1
3751: PUSH
3752: DOUBLE
3753: LD_INT 1
3755: DEC
3756: ST_TO_ADDR
3757: LD_VAR 0 3
3761: PUSH
3762: FOR_TO
3763: IFFALSE 3928
// begin SetDir ( tmp [ i ] , 1 ) ;
3765: LD_VAR 0 3
3769: PUSH
3770: LD_VAR 0 1
3774: ARRAY
3775: PPUSH
3776: LD_INT 1
3778: PPUSH
3779: CALL_OW 233
// if GetType ( tmp [ i ] ) = unit_human then
3783: LD_VAR 0 3
3787: PUSH
3788: LD_VAR 0 1
3792: ARRAY
3793: PPUSH
3794: CALL_OW 247
3798: PUSH
3799: LD_INT 1
3801: EQUAL
3802: IFFALSE 3830
// PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) else
3804: LD_VAR 0 3
3808: PUSH
3809: LD_VAR 0 1
3813: ARRAY
3814: PPUSH
3815: LD_INT 28
3817: PPUSH
3818: LD_INT 52
3820: PPUSH
3821: LD_INT 0
3823: PPUSH
3824: CALL_OW 48
3828: GO 3898
// begin PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) ;
3830: LD_VAR 0 3
3834: PUSH
3835: LD_VAR 0 1
3839: ARRAY
3840: PPUSH
3841: LD_INT 28
3843: PPUSH
3844: LD_INT 52
3846: PPUSH
3847: LD_INT 0
3849: PPUSH
3850: CALL_OW 48
// i := i + 1 ;
3854: LD_ADDR_VAR 0 1
3858: PUSH
3859: LD_VAR 0 1
3863: PUSH
3864: LD_INT 1
3866: PLUS
3867: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ i ] , tmp [ i - 1 ] ) ;
3868: LD_VAR 0 3
3872: PUSH
3873: LD_VAR 0 1
3877: ARRAY
3878: PPUSH
3879: LD_VAR 0 3
3883: PUSH
3884: LD_VAR 0 1
3888: PUSH
3889: LD_INT 1
3891: MINUS
3892: ARRAY
3893: PPUSH
3894: CALL_OW 52
// end ; ComMoveXY ( tmp [ i ] , 43 , 56 ) ;
3898: LD_VAR 0 3
3902: PUSH
3903: LD_VAR 0 1
3907: ARRAY
3908: PPUSH
3909: LD_INT 43
3911: PPUSH
3912: LD_INT 56
3914: PPUSH
3915: CALL_OW 111
// wait ( 0 0$2 ) ;
3919: LD_INT 70
3921: PPUSH
3922: CALL_OW 67
// end ;
3926: GO 3762
3928: POP
3929: POP
// wait ( 0 0$2 ) ;
3930: LD_INT 70
3932: PPUSH
3933: CALL_OW 67
// if not FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) then
3937: LD_INT 7
3939: PPUSH
3940: LD_INT 22
3942: PUSH
3943: LD_INT 2
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PPUSH
3950: CALL_OW 70
3954: NOT
3955: IFFALSE 4153
// begin AddComAgressiveMove ( tmp , 35 , 24 ) ;
3957: LD_VAR 0 3
3961: PPUSH
3962: LD_INT 35
3964: PPUSH
3965: LD_INT 24
3967: PPUSH
3968: CALL_OW 174
// usForces := usForces union UnitFilter ( tmp , [ f_class , 1 ] ) ;
3972: LD_ADDR_EXP 19
3976: PUSH
3977: LD_EXP 19
3981: PUSH
3982: LD_VAR 0 3
3986: PPUSH
3987: LD_INT 25
3989: PUSH
3990: LD_INT 1
3992: PUSH
3993: EMPTY
3994: LIST
3995: LIST
3996: PPUSH
3997: CALL_OW 72
4001: UNION
4002: ST_TO_ADDR
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
4003: LD_INT 22
4005: PUSH
4006: LD_INT 1
4008: PUSH
4009: EMPTY
4010: LIST
4011: LIST
4012: PUSH
4013: LD_INT 30
4015: PUSH
4016: LD_INT 4
4018: PUSH
4019: EMPTY
4020: LIST
4021: LIST
4022: PUSH
4023: EMPTY
4024: LIST
4025: LIST
4026: PPUSH
4027: CALL_OW 69
4031: PUSH
4032: LD_INT 1
4034: ARRAY
4035: PPUSH
4036: CALL_OW 313
4040: PUSH
4041: LD_INT 6
4043: LESS
4044: IFFALSE 4103
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
4046: LD_VAR 0 3
4050: PPUSH
4051: LD_INT 25
4053: PUSH
4054: LD_INT 1
4056: PUSH
4057: EMPTY
4058: LIST
4059: LIST
4060: PPUSH
4061: CALL_OW 72
4065: PPUSH
4066: LD_INT 22
4068: PUSH
4069: LD_INT 1
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: PUSH
4076: LD_INT 30
4078: PUSH
4079: LD_INT 4
4081: PUSH
4082: EMPTY
4083: LIST
4084: LIST
4085: PUSH
4086: EMPTY
4087: LIST
4088: LIST
4089: PPUSH
4090: CALL_OW 69
4094: PUSH
4095: LD_INT 1
4097: ARRAY
4098: PPUSH
4099: CALL_OW 180
// if UnitFilter ( tmp , [ f_class , 4 ] ) then
4103: LD_VAR 0 3
4107: PPUSH
4108: LD_INT 25
4110: PUSH
4111: LD_INT 4
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: PPUSH
4118: CALL_OW 72
4122: IFFALSE 4151
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 4 ] ) , usLab ) ;
4124: LD_VAR 0 3
4128: PPUSH
4129: LD_INT 25
4131: PUSH
4132: LD_INT 4
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: CALL_OW 72
4143: PPUSH
4144: LD_INT 3
4146: PPUSH
4147: CALL_OW 180
// end else
4151: GO 4428
// begin tmp := tmp union FilterUnitsInArea ( retreatArea , [ f_side , 1 ] ) ;
4153: LD_ADDR_VAR 0 3
4157: PUSH
4158: LD_VAR 0 3
4162: PUSH
4163: LD_INT 6
4165: PPUSH
4166: LD_INT 22
4168: PUSH
4169: LD_INT 1
4171: PUSH
4172: EMPTY
4173: LIST
4174: LIST
4175: PPUSH
4176: CALL_OW 70
4180: UNION
4181: ST_TO_ADDR
// ComMoveXY ( tmp , 45 , 54 ) ;
4182: LD_VAR 0 3
4186: PPUSH
4187: LD_INT 45
4189: PPUSH
4190: LD_INT 54
4192: PPUSH
4193: CALL_OW 111
// wait ( 0 0$3 ) ;
4197: LD_INT 105
4199: PPUSH
4200: CALL_OW 67
// AddComAgressiveMove ( tmp diff UnitFilter ( tmp , [ f_class , 4 ] ) , 35 , 24 ) ;
4204: LD_VAR 0 3
4208: PUSH
4209: LD_VAR 0 3
4213: PPUSH
4214: LD_INT 25
4216: PUSH
4217: LD_INT 4
4219: PUSH
4220: EMPTY
4221: LIST
4222: LIST
4223: PPUSH
4224: CALL_OW 72
4228: DIFF
4229: PPUSH
4230: LD_INT 35
4232: PPUSH
4233: LD_INT 24
4235: PPUSH
4236: CALL_OW 174
// AddComMoveXY ( UnitFilter ( tmp , [ f_class , 4 ] ) , 42 , 49 ) ;
4240: LD_VAR 0 3
4244: PPUSH
4245: LD_INT 25
4247: PUSH
4248: LD_INT 4
4250: PUSH
4251: EMPTY
4252: LIST
4253: LIST
4254: PPUSH
4255: CALL_OW 72
4259: PPUSH
4260: LD_INT 42
4262: PPUSH
4263: LD_INT 49
4265: PPUSH
4266: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4270: LD_INT 35
4272: PPUSH
4273: CALL_OW 67
// for i in tmp do
4277: LD_ADDR_VAR 0 1
4281: PUSH
4282: LD_VAR 0 3
4286: PUSH
4287: FOR_IN
4288: IFFALSE 4419
// if IsDead ( i ) then
4290: LD_VAR 0 1
4294: PPUSH
4295: CALL_OW 301
4299: IFFALSE 4319
// tmp := tmp diff i else
4301: LD_ADDR_VAR 0 3
4305: PUSH
4306: LD_VAR 0 3
4310: PUSH
4311: LD_VAR 0 1
4315: DIFF
4316: ST_TO_ADDR
4317: GO 4417
// if GetClass ( i ) = 1 then
4319: LD_VAR 0 1
4323: PPUSH
4324: CALL_OW 257
4328: PUSH
4329: LD_INT 1
4331: EQUAL
4332: IFFALSE 4417
// begin if GetLives ( i ) < 600 and GetDistUnitXY ( i , 42 , 49 ) > 6 then
4334: LD_VAR 0 1
4338: PPUSH
4339: CALL_OW 256
4343: PUSH
4344: LD_INT 600
4346: LESS
4347: PUSH
4348: LD_VAR 0 1
4352: PPUSH
4353: LD_INT 42
4355: PPUSH
4356: LD_INT 49
4358: PPUSH
4359: CALL_OW 297
4363: PUSH
4364: LD_INT 6
4366: GREATER
4367: AND
4368: IFFALSE 4387
// ComMoveXY ( i , 42 , 49 ) else
4370: LD_VAR 0 1
4374: PPUSH
4375: LD_INT 42
4377: PPUSH
4378: LD_INT 49
4380: PPUSH
4381: CALL_OW 111
4385: GO 4417
// if GetLives ( i ) = 1000 then
4387: LD_VAR 0 1
4391: PPUSH
4392: CALL_OW 256
4396: PUSH
4397: LD_INT 1000
4399: EQUAL
4400: IFFALSE 4417
// ComAgressiveMove ( i , 36 , 25 ) ;
4402: LD_VAR 0 1
4406: PPUSH
4407: LD_INT 36
4409: PPUSH
4410: LD_INT 25
4412: PPUSH
4413: CALL_OW 114
// end ;
4417: GO 4287
4419: POP
4420: POP
// until not tmp ;
4421: LD_VAR 0 3
4425: NOT
4426: IFFALSE 4270
// end ; end ; end_of_file
4428: PPOPN 3
4430: END
// export function Action ; var i , tmp ; begin
4431: LD_INT 0
4433: PPUSH
4434: PPUSH
4435: PPUSH
// InGameOn ;
4436: CALL_OW 8
// DoNotAttack ( 2 , usLab ) ;
4440: LD_INT 2
4442: PPUSH
4443: LD_INT 3
4445: PPUSH
4446: CALL_OW 471
// ComMoveXY ( Heike , 78 , 61 ) ;
4450: LD_EXP 21
4454: PPUSH
4455: LD_INT 78
4457: PPUSH
4458: LD_INT 61
4460: PPUSH
4461: CALL_OW 111
// if Mike then
4465: LD_EXP 23
4469: IFFALSE 4486
// ComMoveXY ( Mike , 80 , 66 ) ;
4471: LD_EXP 23
4475: PPUSH
4476: LD_INT 80
4478: PPUSH
4479: LD_INT 66
4481: PPUSH
4482: CALL_OW 111
// if Givi then
4486: LD_EXP 22
4490: IFFALSE 4507
// ComMoveXY ( Givi , 82 , 66 ) ;
4492: LD_EXP 22
4496: PPUSH
4497: LD_INT 82
4499: PPUSH
4500: LD_INT 66
4502: PPUSH
4503: CALL_OW 111
// if Kamil then
4507: LD_EXP 24
4511: IFFALSE 4528
// ComMoveXY ( Kamil , 82 , 67 ) ;
4513: LD_EXP 24
4517: PPUSH
4518: LD_INT 82
4520: PPUSH
4521: LD_INT 67
4523: PPUSH
4524: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
4528: LD_EXP 21
4532: PPUSH
4533: CALL_OW 87
// wait ( 0 0$2 ) ;
4537: LD_INT 70
4539: PPUSH
4540: CALL_OW 67
// if Givi and Mike then
4544: LD_EXP 22
4548: PUSH
4549: LD_EXP 23
4553: AND
4554: IFFALSE 5000
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4556: LD_EXP 22
4560: PUSH
4561: LD_EXP 23
4565: PUSH
4566: LD_EXP 24
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: PPUSH
4576: LD_EXP 21
4580: PPUSH
4581: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
4585: LD_EXP 21
4589: PPUSH
4590: LD_EXP 22
4594: PPUSH
4595: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
4599: LD_EXP 22
4603: PPUSH
4604: LD_STRING DG-1-start
4606: PPUSH
4607: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
4611: LD_EXP 21
4615: PPUSH
4616: LD_STRING DH-1-start
4618: PPUSH
4619: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
4623: LD_EXP 23
4627: PPUSH
4628: LD_EXP 21
4632: PPUSH
4633: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
4637: LD_EXP 21
4641: PPUSH
4642: LD_EXP 23
4646: PPUSH
4647: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
4651: LD_EXP 23
4655: PPUSH
4656: LD_STRING DM-1-start
4658: PPUSH
4659: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
4663: LD_EXP 21
4667: PPUSH
4668: LD_STRING DH-2-start
4670: PPUSH
4671: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
4675: LD_EXP 23
4679: PPUSH
4680: LD_STRING DM-2-start
4682: PPUSH
4683: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
4687: LD_EXP 22
4691: PPUSH
4692: LD_STRING DG-2-start
4694: PPUSH
4695: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
4699: LD_EXP 23
4703: PPUSH
4704: LD_EXP 22
4708: PPUSH
4709: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
4713: LD_EXP 21
4717: PPUSH
4718: LD_EXP 23
4722: PPUSH
4723: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
4727: LD_EXP 23
4731: PPUSH
4732: LD_STRING DM-3-start
4734: PPUSH
4735: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
4739: LD_EXP 21
4743: PPUSH
4744: LD_STRING DH-3-start
4746: PPUSH
4747: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
4751: LD_EXP 21
4755: PUSH
4756: LD_EXP 23
4760: PUSH
4761: LD_EXP 22
4765: PUSH
4766: LD_EXP 24
4770: PUSH
4771: EMPTY
4772: LIST
4773: LIST
4774: LIST
4775: LIST
4776: PPUSH
4777: LD_INT 84
4779: PPUSH
4780: LD_INT 51
4782: PPUSH
4783: CALL_OW 111
// wait ( 0 0$2 ) ;
4787: LD_INT 70
4789: PPUSH
4790: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
4794: LD_EXP 22
4798: PPUSH
4799: LD_STRING DG-3-start
4801: PPUSH
4802: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
4806: LD_EXP 21
4810: PUSH
4811: LD_EXP 23
4815: PUSH
4816: LD_EXP 22
4820: PUSH
4821: LD_EXP 24
4825: PUSH
4826: EMPTY
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
4836: LD_EXP 21
4840: PPUSH
4841: LD_EXP 22
4845: PPUSH
4846: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4850: LD_EXP 22
4854: PUSH
4855: LD_EXP 23
4859: PUSH
4860: LD_EXP 24
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: LIST
4869: PPUSH
4870: LD_EXP 21
4874: PPUSH
4875: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
4879: LD_EXP 21
4883: PPUSH
4884: LD_STRING DH-4-start
4886: PPUSH
4887: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
4891: LD_EXP 22
4895: PPUSH
4896: LD_STRING DG-4-start
4898: PPUSH
4899: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
4903: LD_EXP 21
4907: PPUSH
4908: LD_STRING DH-5-start
4910: PPUSH
4911: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
4915: LD_EXP 22
4919: PPUSH
4920: LD_STRING DG-5-start
4922: PPUSH
4923: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
4927: LD_EXP 21
4931: PPUSH
4932: LD_STRING DH-6-start
4934: PPUSH
4935: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
4939: LD_EXP 23
4943: PPUSH
4944: LD_STRING DM-6-start
4946: PPUSH
4947: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
4951: LD_EXP 21
4955: PUSH
4956: LD_EXP 22
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PPUSH
4965: LD_EXP 23
4969: PPUSH
4970: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
4974: LD_EXP 22
4978: PPUSH
4979: LD_STRING DG-6-start
4981: PPUSH
4982: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
4986: LD_EXP 21
4990: PPUSH
4991: LD_STRING DH-7-start
4993: PPUSH
4994: CALL_OW 88
// end else
4998: GO 5722
// if not Mike and Givi then
5000: LD_EXP 23
5004: NOT
5005: PUSH
5006: LD_EXP 22
5010: AND
5011: IFFALSE 5356
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5013: LD_EXP 22
5017: PUSH
5018: LD_EXP 24
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PPUSH
5027: LD_EXP 21
5031: PPUSH
5032: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
5036: LD_EXP 21
5040: PPUSH
5041: LD_EXP 22
5045: PPUSH
5046: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
5050: LD_EXP 22
5054: PPUSH
5055: LD_STRING DG-1-start-c
5057: PPUSH
5058: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
5062: LD_EXP 21
5066: PPUSH
5067: LD_STRING DH-1-start-c
5069: PPUSH
5070: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
5074: LD_EXP 22
5078: PPUSH
5079: LD_STRING DG-2-start-c
5081: PPUSH
5082: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
5086: LD_EXP 21
5090: PPUSH
5091: LD_STRING DH-2-start-c
5093: PPUSH
5094: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
5098: LD_EXP 22
5102: PPUSH
5103: LD_STRING DG-3-start-c
5105: PPUSH
5106: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
5110: LD_EXP 21
5114: PPUSH
5115: LD_INT 83
5117: PPUSH
5118: LD_INT 56
5120: PPUSH
5121: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
5125: LD_EXP 22
5129: PPUSH
5130: LD_INT 83
5132: PPUSH
5133: LD_INT 59
5135: PPUSH
5136: CALL_OW 111
// if Kamil then
5140: LD_EXP 24
5144: IFFALSE 5161
// ComMoveXY ( Kamil , 80 , 58 ) ;
5146: LD_EXP 24
5150: PPUSH
5151: LD_INT 80
5153: PPUSH
5154: LD_INT 58
5156: PPUSH
5157: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
5161: LD_EXP 21
5165: PPUSH
5166: LD_EXP 22
5170: PPUSH
5171: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5175: LD_EXP 22
5179: PUSH
5180: LD_EXP 24
5184: PUSH
5185: EMPTY
5186: LIST
5187: LIST
5188: PPUSH
5189: LD_EXP 21
5193: PPUSH
5194: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
5198: LD_EXP 21
5202: PPUSH
5203: LD_STRING DH-3-start-c
5205: PPUSH
5206: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
5210: LD_EXP 22
5214: PPUSH
5215: LD_STRING DG-4-start-c
5217: PPUSH
5218: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
5222: LD_EXP 21
5226: PPUSH
5227: LD_STRING DH-5-start-c
5229: PPUSH
5230: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
5234: LD_EXP 22
5238: PPUSH
5239: LD_STRING DG-5-start-c
5241: PPUSH
5242: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
5246: LD_EXP 21
5250: PPUSH
5251: LD_STRING DH-6-start-c
5253: PPUSH
5254: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
5258: LD_EXP 22
5262: PPUSH
5263: LD_STRING DG-6-start-c
5265: PPUSH
5266: CALL_OW 88
// if Kamil then
5270: LD_EXP 24
5274: IFFALSE 5330
// begin ComTurnUnit ( Kamil , Heike ) ;
5276: LD_EXP 24
5280: PPUSH
5281: LD_EXP 21
5285: PPUSH
5286: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5290: LD_EXP 24
5294: PPUSH
5295: LD_STRING DKam-1-start-c
5297: PPUSH
5298: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
5302: LD_EXP 22
5306: PPUSH
5307: LD_EXP 24
5311: PPUSH
5312: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
5316: LD_EXP 22
5320: PPUSH
5321: LD_STRING DG-7-start-c
5323: PPUSH
5324: CALL_OW 88
// end else
5328: GO 5354
// begin Say ( Givi , DG-8-start-c ) ;
5330: LD_EXP 22
5334: PPUSH
5335: LD_STRING DG-8-start-c
5337: PPUSH
5338: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
5342: LD_EXP 21
5346: PPUSH
5347: LD_STRING DH-7-start-c
5349: PPUSH
5350: CALL_OW 88
// end ; end else
5354: GO 5722
// if not Givi and Mike then
5356: LD_EXP 22
5360: NOT
5361: PUSH
5362: LD_EXP 23
5366: AND
5367: IFFALSE 5626
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
5369: LD_EXP 23
5373: PUSH
5374: LD_EXP 24
5378: PUSH
5379: EMPTY
5380: LIST
5381: LIST
5382: PPUSH
5383: LD_EXP 21
5387: PPUSH
5388: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
5392: LD_EXP 21
5396: PPUSH
5397: LD_EXP 23
5401: PPUSH
5402: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
5406: LD_EXP 23
5410: PPUSH
5411: LD_STRING DM-1-start-b
5413: PPUSH
5414: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
5418: LD_EXP 21
5422: PPUSH
5423: LD_STRING DH-1-start-b
5425: PPUSH
5426: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
5430: LD_EXP 23
5434: PPUSH
5435: LD_STRING DM-2-start-b
5437: PPUSH
5438: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
5442: LD_EXP 21
5446: PPUSH
5447: LD_STRING DH-2-start-b
5449: PPUSH
5450: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
5454: LD_EXP 23
5458: PPUSH
5459: LD_STRING DM-3-start-b
5461: PPUSH
5462: CALL_OW 88
// if Kamil then
5466: LD_EXP 24
5470: IFFALSE 5487
// ComMoveXY ( Kamil , 80 , 58 ) ;
5472: LD_EXP 24
5476: PPUSH
5477: LD_INT 80
5479: PPUSH
5480: LD_INT 58
5482: PPUSH
5483: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
5487: LD_EXP 21
5491: PPUSH
5492: LD_INT 83
5494: PPUSH
5495: LD_INT 56
5497: PPUSH
5498: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
5502: LD_EXP 23
5506: PPUSH
5507: LD_INT 83
5509: PPUSH
5510: LD_INT 59
5512: PPUSH
5513: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
5517: LD_EXP 21
5521: PPUSH
5522: LD_EXP 23
5526: PPUSH
5527: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
5531: LD_EXP 24
5535: PUSH
5536: LD_EXP 23
5540: PUSH
5541: EMPTY
5542: LIST
5543: LIST
5544: PPUSH
5545: LD_EXP 21
5549: PPUSH
5550: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
5554: LD_EXP 21
5558: PPUSH
5559: LD_STRING DH-3-start-b
5561: PPUSH
5562: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
5566: LD_EXP 23
5570: PPUSH
5571: LD_STRING DM-4-start-b
5573: PPUSH
5574: CALL_OW 88
// if Kamil then
5578: LD_EXP 24
5582: IFFALSE 5612
// begin ComTurnUnit ( Kamil , Heike ) ;
5584: LD_EXP 24
5588: PPUSH
5589: LD_EXP 21
5593: PPUSH
5594: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5598: LD_EXP 24
5602: PPUSH
5603: LD_STRING DKam-1-start-c
5605: PPUSH
5606: CALL_OW 88
// end else
5610: GO 5624
// begin Say ( Mike , DM-5-start-b ) ;
5612: LD_EXP 23
5616: PPUSH
5617: LD_STRING DM-5-start-b
5619: PPUSH
5620: CALL_OW 88
// end ; end else
5624: GO 5722
// if Kamil then
5626: LD_EXP 24
5630: IFFALSE 5710
// begin AddComTurnUnit ( Heike , Kamil ) ;
5632: LD_EXP 21
5636: PPUSH
5637: LD_EXP 24
5641: PPUSH
5642: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
5646: LD_EXP 24
5650: PPUSH
5651: LD_EXP 21
5655: PPUSH
5656: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
5660: LD_EXP 21
5664: PPUSH
5665: LD_STRING DH-1-start-f
5667: PPUSH
5668: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
5672: LD_EXP 24
5676: PPUSH
5677: LD_STRING DKam-1-start-f
5679: PPUSH
5680: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
5684: LD_EXP 21
5688: PPUSH
5689: LD_STRING DH-2-start-f
5691: PPUSH
5692: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
5696: LD_EXP 24
5700: PPUSH
5701: LD_STRING DKam-2-start-f
5703: PPUSH
5704: CALL_OW 88
// end else
5708: GO 5722
// begin Say ( Heike , DH-1-start-d ) ;
5710: LD_EXP 21
5714: PPUSH
5715: LD_STRING DH-1-start-d
5717: PPUSH
5718: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
5722: LD_EXP 21
5726: PUSH
5727: LD_EXP 22
5731: PUSH
5732: LD_EXP 23
5736: PUSH
5737: LD_EXP 24
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PPUSH
5748: CALL_OW 139
// InGameOff ;
5752: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
5756: LD_STRING OEast
5758: PPUSH
5759: CALL_OW 337
// wait ( 0 0$20 ) ;
5763: LD_INT 700
5765: PPUSH
5766: CALL_OW 67
// SendSciToForest ;
5770: CALL 1383 0 0
// if Difficulty = 1 then
5774: LD_OWVAR 67
5778: PUSH
5779: LD_INT 1
5781: EQUAL
5782: IFFALSE 5786
// exit ;
5784: GO 5903
// wait ( [ 5 5$00 , 2 2$30 ] [ Difficulty - 1 ] ) ;
5786: LD_INT 10500
5788: PUSH
5789: LD_INT 5250
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: PUSH
5796: LD_OWVAR 67
5800: PUSH
5801: LD_INT 1
5803: MINUS
5804: ARRAY
5805: PPUSH
5806: CALL_OW 67
// if usAlert then
5810: LD_EXP 9
5814: IFFALSE 5818
// exit ;
5816: GO 5903
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
5818: LD_ADDR_VAR 0 3
5822: PUSH
5823: LD_INT 22
5825: PUSH
5826: LD_INT 1
5828: PUSH
5829: EMPTY
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 25
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: EMPTY
5840: LIST
5841: LIST
5842: PUSH
5843: EMPTY
5844: LIST
5845: LIST
5846: PPUSH
5847: CALL_OW 69
5851: ST_TO_ADDR
// if not tmp then
5852: LD_VAR 0 3
5856: NOT
5857: IFFALSE 5861
// exit ;
5859: GO 5903
// ComExitBuilding ( tmp ) ;
5861: LD_VAR 0 3
5865: PPUSH
5866: CALL_OW 122
// AddComBuild ( tmp , b_breastwork , 40 , 13 , 3 ) ;
5870: LD_VAR 0 3
5874: PPUSH
5875: LD_INT 31
5877: PPUSH
5878: LD_INT 40
5880: PPUSH
5881: LD_INT 13
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: CALL_OW 205
// AddComEnterUnit ( tmp , Delta ) ;
5891: LD_VAR 0 3
5895: PPUSH
5896: LD_INT 1
5898: PPUSH
5899: CALL_OW 180
// end ;
5903: LD_VAR 0 1
5907: RET
// every 3 3$00 do
5908: GO 5910
5910: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
5911: LD_INT 1
5913: PPUSH
5914: LD_INT 570
5916: PPUSH
5917: LD_INT 350
5919: PPUSH
5920: CALL_OW 550
// wait ( 2 2$40 ) ;
5924: LD_INT 5600
5926: PPUSH
5927: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
5931: LD_INT 0
5933: PPUSH
5934: LD_INT 570
5936: PPUSH
5937: LD_INT 350
5939: PPUSH
5940: CALL_OW 550
// end ;
5944: END
// every 0 0$1 trigger not aviradzeSpotted and See ( 2 , Aviradze ) do var i , pepAmount ;
5945: LD_EXP 4
5949: NOT
5950: PUSH
5951: LD_INT 2
5953: PPUSH
5954: LD_EXP 25
5958: PPUSH
5959: CALL_OW 292
5963: AND
5964: IFFALSE 6872
5966: GO 5968
5968: DISABLE
5969: LD_INT 0
5971: PPUSH
5972: PPUSH
// begin aviradzeSpotted := true ;
5973: LD_ADDR_EXP 4
5977: PUSH
5978: LD_INT 1
5980: ST_TO_ADDR
// pepAmount := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
5981: LD_ADDR_VAR 0 2
5985: PUSH
5986: LD_INT 22
5988: PUSH
5989: LD_INT 2
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: PUSH
5996: LD_INT 21
5998: PUSH
5999: LD_INT 1
6001: PUSH
6002: EMPTY
6003: LIST
6004: LIST
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PPUSH
6010: CALL_OW 69
6014: ST_TO_ADDR
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6015: LD_EXP 21
6019: PPUSH
6020: LD_EXP 25
6024: PPUSH
6025: CALL_OW 250
6029: PPUSH
6030: LD_EXP 25
6034: PPUSH
6035: CALL_OW 251
6039: PPUSH
6040: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6044: LD_INT 35
6046: PPUSH
6047: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 16 ;
6051: LD_EXP 21
6055: PPUSH
6056: LD_EXP 25
6060: PPUSH
6061: CALL_OW 296
6065: PUSH
6066: LD_INT 16
6068: LESS
6069: IFFALSE 6044
// InGameOn ;
6071: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6075: LD_INT 5
6077: PPUSH
6078: LD_INT 2
6080: PPUSH
6081: CALL_OW 343
// if pepAmount > 2 then
6085: LD_VAR 0 2
6089: PUSH
6090: LD_INT 2
6092: GREATER
6093: IFFALSE 6109
// Say ( Heike , DH-1-spot ) else
6095: LD_EXP 21
6099: PPUSH
6100: LD_STRING DH-1-spot
6102: PPUSH
6103: CALL_OW 88
6107: GO 6121
// Say ( Heike , DH-1-spot-d ) ;
6109: LD_EXP 21
6113: PPUSH
6114: LD_STRING DH-1-spot-d
6116: PPUSH
6117: CALL_OW 88
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6121: LD_EXP 21
6125: PPUSH
6126: LD_EXP 25
6130: PPUSH
6131: CALL_OW 250
6135: PPUSH
6136: LD_EXP 25
6140: PPUSH
6141: CALL_OW 251
6145: PPUSH
6146: CALL_OW 111
// for i in [ Kamil , Mike , Givi ] do
6150: LD_ADDR_VAR 0 1
6154: PUSH
6155: LD_EXP 24
6159: PUSH
6160: LD_EXP 23
6164: PUSH
6165: LD_EXP 22
6169: PUSH
6170: EMPTY
6171: LIST
6172: LIST
6173: LIST
6174: PUSH
6175: FOR_IN
6176: IFFALSE 6215
// if GetDistUnits ( i , Aviradze ) > 7 then
6178: LD_VAR 0 1
6182: PPUSH
6183: LD_EXP 25
6187: PPUSH
6188: CALL_OW 296
6192: PUSH
6193: LD_INT 7
6195: GREATER
6196: IFFALSE 6213
// ComMoveXY ( i , 102 , 40 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 102
6205: PPUSH
6206: LD_INT 40
6208: PPUSH
6209: CALL_OW 111
6213: GO 6175
6215: POP
6216: POP
// repeat wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 6 ;
6224: LD_EXP 21
6228: PPUSH
6229: LD_EXP 25
6233: PPUSH
6234: CALL_OW 296
6238: PUSH
6239: LD_INT 6
6241: LESS
6242: IFFALSE 6217
// ComTurnUnit ( Heike , Aviradze ) ;
6244: LD_EXP 21
6248: PPUSH
6249: LD_EXP 25
6253: PPUSH
6254: CALL_OW 119
// ComTurnUnit ( [ Aviradze , Sophia , Kaia ] , Heike ) ;
6258: LD_EXP 25
6262: PUSH
6263: LD_EXP 27
6267: PUSH
6268: LD_EXP 26
6272: PUSH
6273: EMPTY
6274: LIST
6275: LIST
6276: LIST
6277: PPUSH
6278: LD_EXP 21
6282: PPUSH
6283: CALL_OW 119
// if pepAmount > 1 then
6287: LD_VAR 0 2
6291: PUSH
6292: LD_INT 1
6294: GREATER
6295: IFFALSE 6347
// begin wait ( 0 0$2 ) ;
6297: LD_INT 70
6299: PPUSH
6300: CALL_OW 67
// ComTurnUnit ( [ Kamil , Mike , Givi ] , Aviradze ) ;
6304: LD_EXP 24
6308: PUSH
6309: LD_EXP 23
6313: PUSH
6314: LD_EXP 22
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: PPUSH
6324: LD_EXP 25
6328: PPUSH
6329: CALL_OW 119
// Say ( Heike , DH-2-spot ) ;
6333: LD_EXP 21
6337: PPUSH
6338: LD_STRING DH-2-spot
6340: PPUSH
6341: CALL_OW 88
// end else
6345: GO 6359
// Say ( Heike , DH-2-spot-d ) ;
6347: LD_EXP 21
6351: PPUSH
6352: LD_STRING DH-2-spot-d
6354: PPUSH
6355: CALL_OW 88
// Say ( Aviradze , DA-2-spot ) ;
6359: LD_EXP 25
6363: PPUSH
6364: LD_STRING DA-2-spot
6366: PPUSH
6367: CALL_OW 88
// Say ( Heike , DH-3-spot ) ;
6371: LD_EXP 21
6375: PPUSH
6376: LD_STRING DH-3-spot
6378: PPUSH
6379: CALL_OW 88
// ComMoveUnit ( Kaia , Heike ) ;
6383: LD_EXP 26
6387: PPUSH
6388: LD_EXP 21
6392: PPUSH
6393: CALL_OW 112
// ComTurnUNit ( Heike , Kaia ) ;
6397: LD_EXP 21
6401: PPUSH
6402: LD_EXP 26
6406: PPUSH
6407: CALL_OW 119
// wait ( 0 0$0.3 ) ;
6411: LD_INT 10
6413: PPUSH
6414: CALL_OW 67
// async ;
6418: ASYNC
// Say ( Kaia , DK-3-spot ) ;
6419: LD_EXP 26
6423: PPUSH
6424: LD_STRING DK-3-spot
6426: PPUSH
6427: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6431: LD_INT 35
6433: PPUSH
6434: CALL_OW 67
// until GetDistUnits ( Heike , Kaia ) < 4 ;
6438: LD_EXP 21
6442: PPUSH
6443: LD_EXP 26
6447: PPUSH
6448: CALL_OW 296
6452: PUSH
6453: LD_INT 4
6455: LESS
6456: IFFALSE 6431
// ComTurnUnit ( Kaia , Heike ) ;
6458: LD_EXP 26
6462: PPUSH
6463: LD_EXP 21
6467: PPUSH
6468: CALL_OW 119
// sync ;
6472: SYNC
// Say ( Heike , DH-4-spot ) ;
6473: LD_EXP 21
6477: PPUSH
6478: LD_STRING DH-4-spot
6480: PPUSH
6481: CALL_OW 88
// wait ( 0 0$0.3 ) ;
6485: LD_INT 10
6487: PPUSH
6488: CALL_OW 67
// ComTurnUnit ( Heike , Aviradze ) ;
6492: LD_EXP 21
6496: PPUSH
6497: LD_EXP 25
6501: PPUSH
6502: CALL_OW 119
// Say ( Aviradze , DA-4-spot ) ;
6506: LD_EXP 25
6510: PPUSH
6511: LD_STRING DA-4-spot
6513: PPUSH
6514: CALL_OW 88
// ComTurnUnit ( Kaia , Aviradze ) ;
6518: LD_EXP 26
6522: PPUSH
6523: LD_EXP 25
6527: PPUSH
6528: CALL_OW 119
// Say ( Kaia , DK-4-spot ) ;
6532: LD_EXP 26
6536: PPUSH
6537: LD_STRING DK-4-spot
6539: PPUSH
6540: CALL_OW 88
// ComTurnUnit ( Aviradze , Kaia ) ;
6544: LD_EXP 25
6548: PPUSH
6549: LD_EXP 26
6553: PPUSH
6554: CALL_OW 119
// Say ( Aviradze , DA-5-spot ) ;
6558: LD_EXP 25
6562: PPUSH
6563: LD_STRING DA-5-spot
6565: PPUSH
6566: CALL_OW 88
// Say ( Kaia , DK-5-spot ) ;
6570: LD_EXP 26
6574: PPUSH
6575: LD_STRING DK-5-spot
6577: PPUSH
6578: CALL_OW 88
// if pepAmount = 1 then
6582: LD_VAR 0 2
6586: PUSH
6587: LD_INT 1
6589: EQUAL
6590: IFFALSE 6604
// Say ( Heike , DH-5-spot-f ) ;
6592: LD_EXP 21
6596: PPUSH
6597: LD_STRING DH-5-spot-f
6599: PPUSH
6600: CALL_OW 88
// if pepAmount < 3 then
6604: LD_VAR 0 2
6608: PUSH
6609: LD_INT 3
6611: LESS
6612: IFFALSE 6628
// Say ( Aviradze , DA-6-spot-f ) else
6614: LD_EXP 25
6618: PPUSH
6619: LD_STRING DA-6-spot-f
6621: PPUSH
6622: CALL_OW 88
6626: GO 6664
// if pepAmount < 4 then
6628: LD_VAR 0 2
6632: PUSH
6633: LD_INT 4
6635: LESS
6636: IFFALSE 6652
// Say ( Aviradze , DA-6-spot-c ) else
6638: LD_EXP 25
6642: PPUSH
6643: LD_STRING DA-6-spot-c
6645: PPUSH
6646: CALL_OW 88
6650: GO 6664
// Say ( Aviradze , DA-6-spot ) ;
6652: LD_EXP 25
6656: PPUSH
6657: LD_STRING DA-6-spot
6659: PPUSH
6660: CALL_OW 88
// if Kamil then
6664: LD_EXP 24
6668: IFFALSE 6682
// Say ( Kamil , DKam-6-spot ) ;
6670: LD_EXP 24
6674: PPUSH
6675: LD_STRING DKam-6-spot
6677: PPUSH
6678: CALL_OW 88
// Say ( Kaia , DK-6-spot ) ;
6682: LD_EXP 26
6686: PPUSH
6687: LD_STRING DK-6-spot
6689: PPUSH
6690: CALL_OW 88
// ComTurnUnit ( Aviradze , Heike ) ;
6694: LD_EXP 25
6698: PPUSH
6699: LD_EXP 21
6703: PPUSH
6704: CALL_OW 119
// Say ( Aviradze , DA-7-spot ) ;
6708: LD_EXP 25
6712: PPUSH
6713: LD_STRING DA-7-spot
6715: PPUSH
6716: CALL_OW 88
// Say ( Heike , DH-7-spot ) ;
6720: LD_EXP 21
6724: PPUSH
6725: LD_STRING DH-7-spot
6727: PPUSH
6728: CALL_OW 88
// if sciCounterKill >= 3 then
6732: LD_EXP 8
6736: PUSH
6737: LD_INT 3
6739: GREATEREQUAL
6740: IFFALSE 6766
// begin Say ( Heike , DH-7-spot-a ) ;
6742: LD_EXP 21
6746: PPUSH
6747: LD_STRING DH-7-spot-a
6749: PPUSH
6750: CALL_OW 88
// Say ( Aviradze , DA-8-spot-a ) ;
6754: LD_EXP 25
6758: PPUSH
6759: LD_STRING DA-8-spot-a
6761: PPUSH
6762: CALL_OW 88
// end ; InGameOff ;
6766: CALL_OW 9
// if sciCounterKill < 3 then
6770: LD_EXP 8
6774: PUSH
6775: LD_INT 3
6777: LESS
6778: IFFALSE 6810
// begin SetSide ( Kaia , 2 ) ;
6780: LD_EXP 26
6784: PPUSH
6785: LD_INT 2
6787: PPUSH
6788: CALL_OW 235
// ComFree ( Kaia ) ;
6792: LD_EXP 26
6796: PPUSH
6797: CALL_OW 139
// ChangeMissionObjectives ( OSci ) ;
6801: LD_STRING OSci
6803: PPUSH
6804: CALL_OW 337
// end else
6808: GO 6872
// begin aviradzeQuestDone := true ;
6810: LD_ADDR_EXP 7
6814: PUSH
6815: LD_INT 1
6817: ST_TO_ADDR
// attackDeltaAllowed := true ;
6818: LD_ADDR_EXP 12
6822: PUSH
6823: LD_INT 1
6825: ST_TO_ADDR
// ChangeMissionObjectives ( ODelta2 ) ;
6826: LD_STRING ODelta2
6828: PPUSH
6829: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
6833: LD_ADDR_VAR 0 1
6837: PUSH
6838: LD_INT 22
6840: PUSH
6841: LD_INT 5
6843: PUSH
6844: EMPTY
6845: LIST
6846: LIST
6847: PPUSH
6848: CALL_OW 69
6852: PUSH
6853: FOR_IN
6854: IFFALSE 6870
// SetSide ( i , 2 ) ;
6856: LD_VAR 0 1
6860: PPUSH
6861: LD_INT 2
6863: PPUSH
6864: CALL_OW 235
6868: GO 6853
6870: POP
6871: POP
// end ; end ;
6872: PPOPN 2
6874: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and not aviradzeSpotted do
6875: LD_EXP 6
6879: NOT
6880: PUSH
6881: LD_EXP 20
6885: PPUSH
6886: LD_EXP 21
6890: PPUSH
6891: CALL_OW 74
6895: PPUSH
6896: LD_EXP 21
6900: PPUSH
6901: CALL_OW 296
6905: PUSH
6906: LD_INT 8
6908: LESS
6909: AND
6910: PUSH
6911: LD_INT 2
6913: PPUSH
6914: LD_EXP 20
6918: PPUSH
6919: LD_EXP 21
6923: PPUSH
6924: CALL_OW 74
6928: PPUSH
6929: CALL_OW 292
6933: AND
6934: PUSH
6935: LD_INT 22
6937: PUSH
6938: LD_INT 2
6940: PUSH
6941: EMPTY
6942: LIST
6943: LIST
6944: PUSH
6945: LD_INT 21
6947: PUSH
6948: LD_INT 1
6950: PUSH
6951: EMPTY
6952: LIST
6953: LIST
6954: PUSH
6955: EMPTY
6956: LIST
6957: LIST
6958: PPUSH
6959: CALL_OW 69
6963: PUSH
6964: LD_INT 1
6966: GREATER
6967: AND
6968: PUSH
6969: LD_EXP 4
6973: NOT
6974: AND
6975: IFFALSE 7019
6977: GO 6979
6979: DISABLE
// begin sciSpotted := true ;
6980: LD_ADDR_EXP 6
6984: PUSH
6985: LD_INT 1
6987: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
6988: LD_EXP 20
6992: PPUSH
6993: LD_EXP 21
6997: PPUSH
6998: CALL_OW 74
7002: PPUSH
7003: CALL_OW 87
// Say ( Heike , DH-1-sci ) ;
7007: LD_EXP 21
7011: PPUSH
7012: LD_STRING DH-1-sci
7014: PPUSH
7015: CALL_OW 88
// end ;
7019: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and aviradzeSpotted and not aviradzeQuestDone do
7020: LD_EXP 6
7024: NOT
7025: PUSH
7026: LD_EXP 20
7030: PPUSH
7031: LD_EXP 21
7035: PPUSH
7036: CALL_OW 74
7040: PPUSH
7041: LD_EXP 21
7045: PPUSH
7046: CALL_OW 296
7050: PUSH
7051: LD_INT 8
7053: LESS
7054: AND
7055: PUSH
7056: LD_INT 2
7058: PPUSH
7059: LD_EXP 20
7063: PPUSH
7064: LD_EXP 21
7068: PPUSH
7069: CALL_OW 74
7073: PPUSH
7074: CALL_OW 292
7078: AND
7079: PUSH
7080: LD_INT 22
7082: PUSH
7083: LD_INT 2
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: LD_INT 21
7092: PUSH
7093: LD_INT 1
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: EMPTY
7101: LIST
7102: LIST
7103: PPUSH
7104: CALL_OW 69
7108: PUSH
7109: LD_INT 1
7111: GREATER
7112: AND
7113: PUSH
7114: LD_EXP 4
7118: AND
7119: PUSH
7120: LD_EXP 7
7124: NOT
7125: AND
7126: IFFALSE 7188
7128: GO 7130
7130: DISABLE
// begin sciSpotted := true ;
7131: LD_ADDR_EXP 6
7135: PUSH
7136: LD_INT 1
7138: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7139: LD_EXP 20
7143: PPUSH
7144: LD_EXP 21
7148: PPUSH
7149: CALL_OW 74
7153: PPUSH
7154: CALL_OW 87
// Say ( Heike , DH-1-sci-a ) ;
7158: LD_EXP 21
7162: PPUSH
7163: LD_STRING DH-1-sci-a
7165: PPUSH
7166: CALL_OW 88
// if Mike then
7170: LD_EXP 23
7174: IFFALSE 7188
// Say ( Mike , DM-1-sci-a ) ;
7176: LD_EXP 23
7180: PPUSH
7181: LD_STRING DM-1-sci-a
7183: PPUSH
7184: CALL_OW 88
// end ;
7188: END
// every 0 0$1 trigger aviradzeSpotted and sciCounterKill >= 3 and not aviradzeQuestDone do
7189: LD_EXP 4
7193: PUSH
7194: LD_EXP 8
7198: PUSH
7199: LD_INT 3
7201: GREATEREQUAL
7202: AND
7203: PUSH
7204: LD_EXP 7
7208: NOT
7209: AND
7210: IFFALSE 7253
7212: GO 7214
7214: DISABLE
// begin aviradzeQuestDone := true ;
7215: LD_ADDR_EXP 7
7219: PUSH
7220: LD_INT 1
7222: ST_TO_ADDR
// Say ( Heike , DH-1-quest-done ) ;
7223: LD_EXP 21
7227: PPUSH
7228: LD_STRING DH-1-quest-done
7230: PPUSH
7231: CALL_OW 88
// if Givi then
7235: LD_EXP 22
7239: IFFALSE 7253
// Say ( Givi , DG-1-quest-done ) ;
7241: LD_EXP 22
7245: PPUSH
7246: LD_STRING DG-1-quest-done
7248: PPUSH
7249: CALL_OW 88
// end ;
7253: END
// every 0 0$1 trigger See ( 5 , Heike ) and GetDistUnits ( Heike , Aviradze ) < 6 and aviradzeQuestDone and not attackDeltaAllowed do var i ;
7254: LD_INT 5
7256: PPUSH
7257: LD_EXP 21
7261: PPUSH
7262: CALL_OW 292
7266: PUSH
7267: LD_EXP 21
7271: PPUSH
7272: LD_EXP 25
7276: PPUSH
7277: CALL_OW 296
7281: PUSH
7282: LD_INT 6
7284: LESS
7285: AND
7286: PUSH
7287: LD_EXP 7
7291: AND
7292: PUSH
7293: LD_EXP 12
7297: NOT
7298: AND
7299: IFFALSE 7437
7301: GO 7303
7303: DISABLE
7304: LD_INT 0
7306: PPUSH
// begin attackDeltaAllowed := true ;
7307: LD_ADDR_EXP 12
7311: PUSH
7312: LD_INT 1
7314: ST_TO_ADDR
// InGameOn ;
7315: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
7319: LD_EXP 21
7323: PPUSH
7324: CALL_OW 87
// wait ( 0 0$0.3 ) ;
7328: LD_INT 10
7330: PPUSH
7331: CALL_OW 67
// ComTurnUnit ( Aviradze , Heike ) ;
7335: LD_EXP 25
7339: PPUSH
7340: LD_EXP 21
7344: PPUSH
7345: CALL_OW 119
// ComTurnUnit ( Heike , Aviradze ) ;
7349: LD_EXP 21
7353: PPUSH
7354: LD_EXP 25
7358: PPUSH
7359: CALL_OW 119
// Say ( Heike , DH-1-return ) ;
7363: LD_EXP 21
7367: PPUSH
7368: LD_STRING DH-1-return
7370: PPUSH
7371: CALL_OW 88
// Say ( Aviradze , DA-1-return ) ;
7375: LD_EXP 25
7379: PPUSH
7380: LD_STRING DA-1-return
7382: PPUSH
7383: CALL_OW 88
// InGameOff ;
7387: CALL_OW 9
// ChangeMissionObjectives ( ODelta ) ;
7391: LD_STRING ODelta
7393: PPUSH
7394: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7398: LD_ADDR_VAR 0 1
7402: PUSH
7403: LD_INT 22
7405: PUSH
7406: LD_INT 5
7408: PUSH
7409: EMPTY
7410: LIST
7411: LIST
7412: PPUSH
7413: CALL_OW 69
7417: PUSH
7418: FOR_IN
7419: IFFALSE 7435
// SetSide ( i , 2 ) ;
7421: LD_VAR 0 1
7425: PPUSH
7426: LD_INT 2
7428: PPUSH
7429: CALL_OW 235
7433: GO 7418
7435: POP
7436: POP
// end ;
7437: PPOPN 1
7439: END
// every 0 0$1 trigger attackDeltaAllowed and IsOk ( Markov ) and GetSide ( Delta ) = 1 and IsOk ( Lynch ) and not usAlert do var i , k , tmp ;
7440: LD_EXP 12
7444: PUSH
7445: LD_EXP 28
7449: PPUSH
7450: CALL_OW 302
7454: AND
7455: PUSH
7456: LD_INT 1
7458: PPUSH
7459: CALL_OW 255
7463: PUSH
7464: LD_INT 1
7466: EQUAL
7467: AND
7468: PUSH
7469: LD_EXP 18
7473: PPUSH
7474: CALL_OW 302
7478: AND
7479: PUSH
7480: LD_EXP 9
7484: NOT
7485: AND
7486: IFFALSE 8656
7488: GO 7490
7490: DISABLE
7491: LD_INT 0
7493: PPUSH
7494: PPUSH
7495: PPUSH
// begin trap := 0 ;
7496: LD_ADDR_EXP 15
7500: PUSH
7501: LD_INT 0
7503: ST_TO_ADDR
// wait ( 0 0$15 ) ;
7504: LD_INT 525
7506: PPUSH
7507: CALL_OW 67
// DialogueOn ;
7511: CALL_OW 6
// Say ( Markov , DMar-1-radio ) ;
7515: LD_EXP 28
7519: PPUSH
7520: LD_STRING DMar-1-radio
7522: PPUSH
7523: CALL_OW 88
// Say ( Heike , DH-1-radio ) ;
7527: LD_EXP 21
7531: PPUSH
7532: LD_STRING DH-1-radio
7534: PPUSH
7535: CALL_OW 88
// Say ( Markov , DMar-2-radio ) ;
7539: LD_EXP 28
7543: PPUSH
7544: LD_STRING DMar-2-radio
7546: PPUSH
7547: CALL_OW 88
// Say ( Heike , DH-2-radio ) ;
7551: LD_EXP 21
7555: PPUSH
7556: LD_STRING DH-2-radio
7558: PPUSH
7559: CALL_OW 88
// if IsOk ( Kamil ) or IsOk ( Sophia ) then
7563: LD_EXP 24
7567: PPUSH
7568: CALL_OW 302
7572: PUSH
7573: LD_EXP 27
7577: PPUSH
7578: CALL_OW 302
7582: OR
7583: IFFALSE 8656
// begin case Query ( Q1Trap ) of 1 :
7585: LD_STRING Q1Trap
7587: PPUSH
7588: CALL_OW 97
7592: PUSH
7593: LD_INT 1
7595: DOUBLE
7596: EQUAL
7597: IFTRUE 7601
7599: GO 7795
7601: POP
// begin if IsOk ( Kamil ) then
7602: LD_EXP 24
7606: PPUSH
7607: CALL_OW 302
7611: IFFALSE 7690
// begin Say ( Kamil , DKam-2-radio ) ;
7613: LD_EXP 24
7617: PPUSH
7618: LD_STRING DKam-2-radio
7620: PPUSH
7621: CALL_OW 88
// Say ( Kamil , DKam-3-radio ) ;
7625: LD_EXP 24
7629: PPUSH
7630: LD_STRING DKam-3-radio
7632: PPUSH
7633: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio ) ;
7637: LD_EXP 18
7641: PPUSH
7642: LD_STRING DDelta-3-radio
7644: PPUSH
7645: CALL_OW 94
// dwait ( 0 0$01 ) ;
7649: LD_INT 35
7651: PPUSH
7652: CALL_OW 68
// Say ( Heike , DH-3-radio ) ;
7656: LD_EXP 21
7660: PPUSH
7661: LD_STRING DH-3-radio
7663: PPUSH
7664: CALL_OW 88
// Say ( Kamil , DKam-4-radio ) ;
7668: LD_EXP 24
7672: PPUSH
7673: LD_STRING DKam-4-radio
7675: PPUSH
7676: CALL_OW 88
// trap := 1 ;
7680: LD_ADDR_EXP 15
7684: PUSH
7685: LD_INT 1
7687: ST_TO_ADDR
// end else
7688: GO 7789
// begin Say ( Sophia , DS-1-radio ) ;
7690: LD_EXP 27
7694: PPUSH
7695: LD_STRING DS-1-radio
7697: PPUSH
7698: CALL_OW 88
// Say ( Sophia , DS-2-radio ) ;
7702: LD_EXP 27
7706: PPUSH
7707: LD_STRING DS-2-radio
7709: PPUSH
7710: CALL_OW 88
// SayRadio ( Lynch , DDelta-2-radio-s ) ;
7714: LD_EXP 18
7718: PPUSH
7719: LD_STRING DDelta-2-radio-s
7721: PPUSH
7722: CALL_OW 94
// Say ( Sophia , DS-3-radio ) ;
7726: LD_EXP 27
7730: PPUSH
7731: LD_STRING DS-3-radio
7733: PPUSH
7734: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio-s ) ;
7738: LD_EXP 18
7742: PPUSH
7743: LD_STRING DDelta-3-radio-s
7745: PPUSH
7746: CALL_OW 94
// Say ( Sophia , DS-4-radio-s ) ;
7750: LD_EXP 27
7754: PPUSH
7755: LD_STRING DS-4-radio-s
7757: PPUSH
7758: CALL_OW 88
// dwait ( 0 0$01 ) ;
7762: LD_INT 35
7764: PPUSH
7765: CALL_OW 68
// Say ( Heike , DH-1-trap ) ;
7769: LD_EXP 21
7773: PPUSH
7774: LD_STRING DH-1-trap
7776: PPUSH
7777: CALL_OW 88
// trap := 0 ;
7781: LD_ADDR_EXP 15
7785: PUSH
7786: LD_INT 0
7788: ST_TO_ADDR
// end ; DialogueOff ;
7789: CALL_OW 7
// end ; 2 :
7793: GO 7813
7795: LD_INT 2
7797: DOUBLE
7798: EQUAL
7799: IFTRUE 7803
7801: GO 7812
7803: POP
// begin DialogueOff ;
7804: CALL_OW 7
// exit ;
7808: GO 8656
// end ; end ;
7810: GO 7813
7812: POP
// if trap = 1 then
7813: LD_EXP 15
7817: PUSH
7818: LD_INT 1
7820: EQUAL
7821: IFFALSE 8227
// begin tmp := [ ] ;
7823: LD_ADDR_VAR 0 3
7827: PUSH
7828: EMPTY
7829: ST_TO_ADDR
// k := 3 ;
7830: LD_ADDR_VAR 0 2
7834: PUSH
7835: LD_INT 3
7837: ST_TO_ADDR
// if usForces < 3 then
7838: LD_EXP 19
7842: PUSH
7843: LD_INT 3
7845: LESS
7846: IFFALSE 7858
// k := usForces ;
7848: LD_ADDR_VAR 0 2
7852: PUSH
7853: LD_EXP 19
7857: ST_TO_ADDR
// for i := 1 to k do
7858: LD_ADDR_VAR 0 1
7862: PUSH
7863: DOUBLE
7864: LD_INT 1
7866: DEC
7867: ST_TO_ADDR
7868: LD_VAR 0 2
7872: PUSH
7873: FOR_TO
7874: IFFALSE 7929
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
7876: LD_ADDR_VAR 0 3
7880: PUSH
7881: LD_VAR 0 3
7885: PPUSH
7886: LD_VAR 0 3
7890: PUSH
7891: LD_INT 1
7893: PLUS
7894: PPUSH
7895: LD_EXP 19
7899: PUSH
7900: LD_INT 1
7902: ARRAY
7903: PPUSH
7904: CALL_OW 1
7908: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
7909: LD_ADDR_EXP 19
7913: PUSH
7914: LD_EXP 19
7918: PPUSH
7919: LD_INT 1
7921: PPUSH
7922: CALL_OW 3
7926: ST_TO_ADDR
// end ;
7927: GO 7873
7929: POP
7930: POP
// usPatrol := tmp ;
7931: LD_ADDR_EXP 14
7935: PUSH
7936: LD_VAR 0 3
7940: ST_TO_ADDR
// for i in tmp do
7941: LD_ADDR_VAR 0 1
7945: PUSH
7946: LD_VAR 0 3
7950: PUSH
7951: FOR_IN
7952: IFFALSE 8082
// begin if IsInUnit ( i ) then
7954: LD_VAR 0 1
7958: PPUSH
7959: CALL_OW 310
7963: IFFALSE 7974
// ComExitBuilding ( i ) ;
7965: LD_VAR 0 1
7969: PPUSH
7970: CALL_OW 122
// AddComAgressiveMove ( i , 63 , 31 ) ;
7974: LD_VAR 0 1
7978: PPUSH
7979: LD_INT 63
7981: PPUSH
7982: LD_INT 31
7984: PPUSH
7985: CALL_OW 174
// AddComWait ( i , 0 0$2 ) ;
7989: LD_VAR 0 1
7993: PPUSH
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 202
// AddComAgressiveMove ( i , 103 , 43 ) ;
8001: LD_VAR 0 1
8005: PPUSH
8006: LD_INT 103
8008: PPUSH
8009: LD_INT 43
8011: PPUSH
8012: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8016: LD_VAR 0 1
8020: PPUSH
8021: LD_INT 105
8023: PPUSH
8024: CALL_OW 202
// if Difficulty > 1 then
8028: LD_OWVAR 67
8032: PUSH
8033: LD_INT 1
8035: GREATER
8036: IFFALSE 8053
// AddComAgressiveMove ( i , 114 , 69 ) ;
8038: LD_VAR 0 1
8042: PPUSH
8043: LD_INT 114
8045: PPUSH
8046: LD_INT 69
8048: PPUSH
8049: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8053: LD_VAR 0 1
8057: PPUSH
8058: LD_INT 105
8060: PPUSH
8061: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8065: LD_VAR 0 1
8069: PPUSH
8070: LD_INT 42
8072: PPUSH
8073: LD_INT 20
8075: PPUSH
8076: CALL_OW 174
// end ;
8080: GO 7951
8082: POP
8083: POP
// repeat wait ( 0 0$1 ) ;
8084: LD_INT 35
8086: PPUSH
8087: CALL_OW 67
// for i in tmp do
8091: LD_ADDR_VAR 0 1
8095: PUSH
8096: LD_VAR 0 3
8100: PUSH
8101: FOR_IN
8102: IFFALSE 8133
// if IsDead ( i ) then
8104: LD_VAR 0 1
8108: PPUSH
8109: CALL_OW 301
8113: IFFALSE 8131
// tmp := tmp diff i ;
8115: LD_ADDR_VAR 0 3
8119: PUSH
8120: LD_VAR 0 3
8124: PUSH
8125: LD_VAR 0 1
8129: DIFF
8130: ST_TO_ADDR
8131: GO 8101
8133: POP
8134: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8135: LD_VAR 0 3
8139: NOT
8140: PUSH
8141: LD_VAR 0 3
8145: PPUSH
8146: LD_INT 95
8148: PUSH
8149: LD_INT 7
8151: PUSH
8152: EMPTY
8153: LIST
8154: LIST
8155: PUSH
8156: LD_INT 3
8158: PUSH
8159: LD_INT 60
8161: PUSH
8162: EMPTY
8163: LIST
8164: PUSH
8165: EMPTY
8166: LIST
8167: LIST
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PPUSH
8173: CALL_OW 72
8177: PUSH
8178: LD_VAR 0 3
8182: EQUAL
8183: OR
8184: IFFALSE 8084
// if tmp then
8186: LD_VAR 0 3
8190: IFFALSE 8217
// begin usPatrol := [ ] ;
8192: LD_ADDR_EXP 14
8196: PUSH
8197: EMPTY
8198: ST_TO_ADDR
// usForces := usForces union tmp ;
8199: LD_ADDR_EXP 19
8203: PUSH
8204: LD_EXP 19
8208: PUSH
8209: LD_VAR 0 3
8213: UNION
8214: ST_TO_ADDR
// end else
8215: GO 8225
// trickyMove := true ;
8217: LD_ADDR_EXP 13
8221: PUSH
8222: LD_INT 1
8224: ST_TO_ADDR
// end else
8225: GO 8656
// begin tmp := [ ] ;
8227: LD_ADDR_VAR 0 3
8231: PUSH
8232: EMPTY
8233: ST_TO_ADDR
// k := 4 ;
8234: LD_ADDR_VAR 0 2
8238: PUSH
8239: LD_INT 4
8241: ST_TO_ADDR
// if usForces < 4 then
8242: LD_EXP 19
8246: PUSH
8247: LD_INT 4
8249: LESS
8250: IFFALSE 8262
// k := usForces ;
8252: LD_ADDR_VAR 0 2
8256: PUSH
8257: LD_EXP 19
8261: ST_TO_ADDR
// for i := 1 to k do
8262: LD_ADDR_VAR 0 1
8266: PUSH
8267: DOUBLE
8268: LD_INT 1
8270: DEC
8271: ST_TO_ADDR
8272: LD_VAR 0 2
8276: PUSH
8277: FOR_TO
8278: IFFALSE 8333
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8280: LD_ADDR_VAR 0 3
8284: PUSH
8285: LD_VAR 0 3
8289: PPUSH
8290: LD_VAR 0 3
8294: PUSH
8295: LD_INT 1
8297: PLUS
8298: PPUSH
8299: LD_EXP 19
8303: PUSH
8304: LD_INT 1
8306: ARRAY
8307: PPUSH
8308: CALL_OW 1
8312: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8313: LD_ADDR_EXP 19
8317: PUSH
8318: LD_EXP 19
8322: PPUSH
8323: LD_INT 1
8325: PPUSH
8326: CALL_OW 3
8330: ST_TO_ADDR
// end ;
8331: GO 8277
8333: POP
8334: POP
// if Lynch then
8335: LD_EXP 18
8339: IFFALSE 8357
// tmp := tmp ^ Lynch ;
8341: LD_ADDR_VAR 0 3
8345: PUSH
8346: LD_VAR 0 3
8350: PUSH
8351: LD_EXP 18
8355: ADD
8356: ST_TO_ADDR
// usPatrol := tmp ;
8357: LD_ADDR_EXP 14
8361: PUSH
8362: LD_VAR 0 3
8366: ST_TO_ADDR
// for i in tmp do
8367: LD_ADDR_VAR 0 1
8371: PUSH
8372: LD_VAR 0 3
8376: PUSH
8377: FOR_IN
8378: IFFALSE 8471
// begin if IsInUnit ( i ) then
8380: LD_VAR 0 1
8384: PPUSH
8385: CALL_OW 310
8389: IFFALSE 8400
// ComExitBuilding ( i ) ;
8391: LD_VAR 0 1
8395: PPUSH
8396: CALL_OW 122
// AddComAgressiveMove ( i , 69 , 15 ) ;
8400: LD_VAR 0 1
8404: PPUSH
8405: LD_INT 69
8407: PPUSH
8408: LD_INT 15
8410: PPUSH
8411: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8415: LD_VAR 0 1
8419: PPUSH
8420: LD_INT 700
8422: PPUSH
8423: CALL_OW 202
// AddComAgressiveMove ( i , 55 , 43 ) ;
8427: LD_VAR 0 1
8431: PPUSH
8432: LD_INT 55
8434: PPUSH
8435: LD_INT 43
8437: PPUSH
8438: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8442: LD_VAR 0 1
8446: PPUSH
8447: LD_INT 700
8449: PPUSH
8450: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8454: LD_VAR 0 1
8458: PPUSH
8459: LD_INT 42
8461: PPUSH
8462: LD_INT 20
8464: PPUSH
8465: CALL_OW 174
// end ;
8469: GO 8377
8471: POP
8472: POP
// repeat wait ( 0 0$1 ) ;
8473: LD_INT 35
8475: PPUSH
8476: CALL_OW 67
// for i in tmp do
8480: LD_ADDR_VAR 0 1
8484: PUSH
8485: LD_VAR 0 3
8489: PUSH
8490: FOR_IN
8491: IFFALSE 8522
// if IsDead ( i ) then
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 301
8502: IFFALSE 8520
// tmp := tmp diff i ;
8504: LD_ADDR_VAR 0 3
8508: PUSH
8509: LD_VAR 0 3
8513: PUSH
8514: LD_VAR 0 1
8518: DIFF
8519: ST_TO_ADDR
8520: GO 8490
8522: POP
8523: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8524: LD_VAR 0 3
8528: NOT
8529: PUSH
8530: LD_VAR 0 3
8534: PPUSH
8535: LD_INT 95
8537: PUSH
8538: LD_INT 7
8540: PUSH
8541: EMPTY
8542: LIST
8543: LIST
8544: PUSH
8545: LD_INT 3
8547: PUSH
8548: LD_INT 60
8550: PUSH
8551: EMPTY
8552: LIST
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: PUSH
8558: EMPTY
8559: LIST
8560: LIST
8561: PPUSH
8562: CALL_OW 72
8566: PUSH
8567: LD_VAR 0 3
8571: EQUAL
8572: OR
8573: IFFALSE 8473
// if not tmp then
8575: LD_VAR 0 3
8579: NOT
8580: IFFALSE 8592
// trickyMove := true else
8582: LD_ADDR_EXP 13
8586: PUSH
8587: LD_INT 1
8589: ST_TO_ADDR
8590: GO 8599
// usPatrol := [ ] ;
8592: LD_ADDR_EXP 14
8596: PUSH
8597: EMPTY
8598: ST_TO_ADDR
// if tmp diff Lynch then
8599: LD_VAR 0 3
8603: PUSH
8604: LD_EXP 18
8608: DIFF
8609: IFFALSE 8633
// usForces := usForces union ( tmp diff Lynch ) ;
8611: LD_ADDR_EXP 19
8615: PUSH
8616: LD_EXP 19
8620: PUSH
8621: LD_VAR 0 3
8625: PUSH
8626: LD_EXP 18
8630: DIFF
8631: UNION
8632: ST_TO_ADDR
// if IsOk ( Lynch ) then
8633: LD_EXP 18
8637: PPUSH
8638: CALL_OW 302
8642: IFFALSE 8656
// ComEnterUnit ( Lynch , Delta ) ;
8644: LD_EXP 18
8648: PPUSH
8649: LD_INT 1
8651: PPUSH
8652: CALL_OW 120
// end ; end ; end ;
8656: PPOPN 3
8658: END
// every 0 0$1 trigger UnitFilter ( usPatrol , [ f_see , 2 ] ) do
8659: LD_EXP 14
8663: PPUSH
8664: LD_INT 101
8666: PUSH
8667: LD_INT 2
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PPUSH
8674: CALL_OW 72
8678: IFFALSE 8811
8680: GO 8682
8682: DISABLE
// begin if not trap then
8683: LD_EXP 15
8687: NOT
8688: IFFALSE 8716
// begin Say ( Heike , DH-2-trap ) ;
8690: LD_EXP 21
8694: PPUSH
8695: LD_STRING DH-2-trap
8697: PPUSH
8698: CALL_OW 88
// Say ( Mike , DM-2-trap ) ;
8702: LD_EXP 23
8706: PPUSH
8707: LD_STRING DM-2-trap
8709: PPUSH
8710: CALL_OW 88
// end else
8714: GO 8728
// begin Say ( Heike , DH-1-trap-a ) ;
8716: LD_EXP 21
8720: PPUSH
8721: LD_STRING DH-1-trap-a
8723: PPUSH
8724: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
8728: LD_INT 35
8730: PPUSH
8731: CALL_OW 67
// until trickyMove ;
8735: LD_EXP 13
8739: IFFALSE 8728
// Say ( Heike , DH-3-trap ) ;
8741: LD_EXP 21
8745: PPUSH
8746: LD_STRING DH-3-trap
8748: PPUSH
8749: CALL_OW 88
// if IsOk ( Givi ) and IsOk ( Kaia ) then
8753: LD_EXP 22
8757: PPUSH
8758: CALL_OW 302
8762: PUSH
8763: LD_EXP 26
8767: PPUSH
8768: CALL_OW 302
8772: AND
8773: IFFALSE 8811
// begin Say ( Givi , DG-3-trap ) ;
8775: LD_EXP 22
8779: PPUSH
8780: LD_STRING DG-3-trap
8782: PPUSH
8783: CALL_OW 88
// Say ( Kaia , DK-3-trap ) ;
8787: LD_EXP 26
8791: PPUSH
8792: LD_STRING DK-3-trap
8794: PPUSH
8795: CALL_OW 88
// Say ( Givi , DG-4-trap ) ;
8799: LD_EXP 22
8803: PPUSH
8804: LD_STRING DG-4-trap
8806: PPUSH
8807: CALL_OW 88
// end ; end ;
8811: END
// every 0 0$1 trigger GetSide ( Delta ) = 2 do
8812: LD_INT 1
8814: PPUSH
8815: CALL_OW 255
8819: PUSH
8820: LD_INT 2
8822: EQUAL
8823: IFFALSE 8866
8825: GO 8827
8827: DISABLE
// begin if not IsOk ( Kaia ) then
8828: LD_EXP 26
8832: PPUSH
8833: CALL_OW 302
8837: NOT
8838: IFFALSE 8842
// exit ;
8840: GO 8866
// Say ( Kaia , DK-1-capture ) ;
8842: LD_EXP 26
8846: PPUSH
8847: LD_STRING DK-1-capture
8849: PPUSH
8850: CALL_OW 88
// Say ( Heike , DH-1-capture ) ;
8854: LD_EXP 21
8858: PPUSH
8859: LD_STRING DH-1-capture
8861: PPUSH
8862: CALL_OW 88
// end ;
8866: END
// every 0 0$1 trigger GetSide ( usLab ) = 2 do
8867: LD_INT 3
8869: PPUSH
8870: CALL_OW 255
8874: PUSH
8875: LD_INT 2
8877: EQUAL
8878: IFFALSE 8910
8880: GO 8882
8882: DISABLE
// begin DialogueOn ;
8883: CALL_OW 6
// Say ( Aviradze , DA-1-capture ) ;
8887: LD_EXP 25
8891: PPUSH
8892: LD_STRING DA-1-capture
8894: PPUSH
8895: CALL_OW 88
// DialogueOff ;
8899: CALL_OW 7
// ChangeMissionObjectives ( OTame ) ;
8903: LD_STRING OTame
8905: PPUSH
8906: CALL_OW 337
// end ;
8910: END
// every 0 0$1 trigger GetTech ( tech_ApeLang , 2 ) = state_researched do
8911: LD_INT 1
8913: PPUSH
8914: LD_INT 2
8916: PPUSH
8917: CALL_OW 321
8921: PUSH
8922: LD_INT 2
8924: EQUAL
8925: IFFALSE 8998
8927: GO 8929
8929: DISABLE
// begin DialogueOn ;
8930: CALL_OW 6
// Say ( Aviradze , DA-1-ape ) ;
8934: LD_EXP 25
8938: PPUSH
8939: LD_STRING DA-1-ape
8941: PPUSH
8942: CALL_OW 88
// Say ( Heike , DH-1-ape ) ;
8946: LD_EXP 21
8950: PPUSH
8951: LD_STRING DH-1-ape
8953: PPUSH
8954: CALL_OW 88
// Say ( Aviradze , DA-2-ape ) ;
8958: LD_EXP 25
8962: PPUSH
8963: LD_STRING DA-2-ape
8965: PPUSH
8966: CALL_OW 88
// Say ( Aviradze , DA-3-ape ) ;
8970: LD_EXP 25
8974: PPUSH
8975: LD_STRING DA-3-ape
8977: PPUSH
8978: CALL_OW 88
// Say ( Heike , DH-3-ape ) ;
8982: LD_EXP 21
8986: PPUSH
8987: LD_STRING DH-3-ape
8989: PPUSH
8990: CALL_OW 88
// DialogueOff ;
8994: CALL_OW 7
// end ;
8998: END
// every 0 0$5 trigger lostCounter >= [ 3 , 2 , 2 ] [ Difficulty ] do
8999: LD_EXP 16
9003: PUSH
9004: LD_INT 3
9006: PUSH
9007: LD_INT 2
9009: PUSH
9010: LD_INT 2
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: LIST
9017: PUSH
9018: LD_OWVAR 67
9022: ARRAY
9023: GREATEREQUAL
9024: IFFALSE 9068
9026: GO 9028
9028: DISABLE
// begin DialogueOn ;
9029: CALL_OW 6
// Say ( Aviradze , DA-1-failure ) ;
9033: LD_EXP 25
9037: PPUSH
9038: LD_STRING DA-1-failure
9040: PPUSH
9041: CALL_OW 88
// Say ( Aviradze , DA-2-failure ) ;
9045: LD_EXP 25
9049: PPUSH
9050: LD_STRING DA-2-failure
9052: PPUSH
9053: CALL_OW 88
// YouLost ( Failure ) ;
9057: LD_STRING Failure
9059: PPUSH
9060: CALL_OW 104
// DialogueOff ;
9064: CALL_OW 7
// end ;
9068: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) do var tmp ;
9069: LD_INT 22
9071: PUSH
9072: LD_INT 2
9074: PUSH
9075: EMPTY
9076: LIST
9077: LIST
9078: PUSH
9079: LD_INT 23
9081: PUSH
9082: LD_INT 0
9084: PUSH
9085: EMPTY
9086: LIST
9087: LIST
9088: PUSH
9089: EMPTY
9090: LIST
9091: LIST
9092: PPUSH
9093: CALL_OW 69
9097: IFFALSE 9847
9099: GO 9101
9101: DISABLE
9102: LD_INT 0
9104: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) [ 1 ] ;
9105: LD_ADDR_VAR 0 1
9109: PUSH
9110: LD_INT 22
9112: PUSH
9113: LD_INT 2
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: PUSH
9120: LD_INT 23
9122: PUSH
9123: LD_INT 0
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PPUSH
9134: CALL_OW 69
9138: PUSH
9139: LD_INT 1
9141: ARRAY
9142: ST_TO_ADDR
// InGameOn ;
9143: CALL_OW 8
// CenterNowOnUnits ( tmp ) ;
9147: LD_VAR 0 1
9151: PPUSH
9152: CALL_OW 87
// ComMoveUnit ( tmp , Aviradze ) ;
9156: LD_VAR 0 1
9160: PPUSH
9161: LD_EXP 25
9165: PPUSH
9166: CALL_OW 112
// ComTurnUnit ( Aviradze , tmp ) ;
9170: LD_EXP 25
9174: PPUSH
9175: LD_VAR 0 1
9179: PPUSH
9180: CALL_OW 119
// wait ( 0 0$1 ) ;
9184: LD_INT 35
9186: PPUSH
9187: CALL_OW 67
// Say ( Aviradze , DA-1-tame-a ) ;
9191: LD_EXP 25
9195: PPUSH
9196: LD_STRING DA-1-tame-a
9198: PPUSH
9199: CALL_OW 88
// if IsOk ( Mike ) then
9203: LD_EXP 23
9207: PPUSH
9208: CALL_OW 302
9212: IFFALSE 9250
// begin Say ( Mike , DM-1-tame-a ) ;
9214: LD_EXP 23
9218: PPUSH
9219: LD_STRING DM-1-tame-a
9221: PPUSH
9222: CALL_OW 88
// Say ( Sophia , DS-1-tame-a ) ;
9226: LD_EXP 27
9230: PPUSH
9231: LD_STRING DS-1-tame-a
9233: PPUSH
9234: CALL_OW 88
// Say ( Mike , DM-2-tame-a ) ;
9238: LD_EXP 23
9242: PPUSH
9243: LD_STRING DM-2-tame-a
9245: PPUSH
9246: CALL_OW 88
// end ; wait ( 0 0$3 ) ;
9250: LD_INT 105
9252: PPUSH
9253: CALL_OW 67
// PrepareFarmer ;
9257: CALL 10506 0 0
// CenterOnUnits ( Farmer ) ;
9261: LD_EXP 29
9265: PPUSH
9266: CALL_OW 85
// ComMoveXY ( Farmer , 105 , 59 ) ;
9270: LD_EXP 29
9274: PPUSH
9275: LD_INT 105
9277: PPUSH
9278: LD_INT 59
9280: PPUSH
9281: CALL_OW 111
// AddComHold ( Farmer ) ;
9285: LD_EXP 29
9289: PPUSH
9290: CALL_OW 200
// SayRadio ( Farmer , DF-1-end ) ;
9294: LD_EXP 29
9298: PPUSH
9299: LD_STRING DF-1-end
9301: PPUSH
9302: CALL_OW 94
// Say ( Aviradze , DA-1-end ) ;
9306: LD_EXP 25
9310: PPUSH
9311: LD_STRING DA-1-end
9313: PPUSH
9314: CALL_OW 88
// SayRadio ( Farmer , DF-2-end ) ;
9318: LD_EXP 29
9322: PPUSH
9323: LD_STRING DF-2-end
9325: PPUSH
9326: CALL_OW 94
// Say ( Aviradze , DA-2-end ) ;
9330: LD_EXP 25
9334: PPUSH
9335: LD_STRING DA-2-end
9337: PPUSH
9338: CALL_OW 88
// SayRadio ( Farmer , DF-3-end ) ;
9342: LD_EXP 29
9346: PPUSH
9347: LD_STRING DF-3-end
9349: PPUSH
9350: CALL_OW 94
// Say ( Heike , DH-3-end ) ;
9354: LD_EXP 21
9358: PPUSH
9359: LD_STRING DH-3-end
9361: PPUSH
9362: CALL_OW 88
// SayRadio ( Farmer , DF-4-end ) ;
9366: LD_EXP 29
9370: PPUSH
9371: LD_STRING DF-4-end
9373: PPUSH
9374: CALL_OW 94
// if tick <= [ 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] then
9378: LD_OWVAR 1
9382: PUSH
9383: LD_INT 42000
9385: PUSH
9386: LD_INT 31500
9388: PUSH
9389: LD_INT 21000
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: LIST
9396: PUSH
9397: LD_OWVAR 67
9401: ARRAY
9402: LESSEQUAL
9403: IFFALSE 9417
// AddMedal ( med1 , 1 ) else
9405: LD_STRING med1
9407: PPUSH
9408: LD_INT 1
9410: PPUSH
9411: CALL_OW 101
9415: GO 9428
// AddMedal ( med1 , - 1 ) ;
9417: LD_STRING med1
9419: PPUSH
9420: LD_INT 1
9422: NEG
9423: PPUSH
9424: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) = 0 then
9428: LD_INT 22
9430: PUSH
9431: LD_INT 1
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: PUSH
9438: LD_INT 25
9440: PUSH
9441: LD_INT 4
9443: PUSH
9444: EMPTY
9445: LIST
9446: LIST
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PPUSH
9452: CALL_OW 69
9456: PUSH
9457: LD_INT 0
9459: EQUAL
9460: IFFALSE 9474
// AddMedal ( med2 , 1 ) else
9462: LD_STRING med2
9464: PPUSH
9465: LD_INT 1
9467: PPUSH
9468: CALL_OW 101
9472: GO 9485
// AddMedal ( med2 , - 1 ) ;
9474: LD_STRING med2
9476: PPUSH
9477: LD_INT 1
9479: NEG
9480: PPUSH
9481: CALL_OW 101
// if trickyMove then
9485: LD_EXP 13
9489: IFFALSE 9503
// AddMedal ( med3 , 1 ) else
9491: LD_STRING med3
9493: PPUSH
9494: LD_INT 1
9496: PPUSH
9497: CALL_OW 101
9501: GO 9514
// AddMedal ( med3 , - 1 ) ;
9503: LD_STRING med3
9505: PPUSH
9506: LD_INT 1
9508: NEG
9509: PPUSH
9510: CALL_OW 101
// GiveMedals ( MAIN ) ;
9514: LD_STRING MAIN
9516: PPUSH
9517: CALL_OW 102
// SaveCharacters ( tmp , 02_ape ) ;
9521: LD_VAR 0 1
9525: PPUSH
9526: LD_STRING 02_ape
9528: PPUSH
9529: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ;
9533: LD_ADDR_VAR 0 1
9537: PUSH
9538: LD_INT 22
9540: PUSH
9541: LD_INT 2
9543: PUSH
9544: EMPTY
9545: LIST
9546: LIST
9547: PUSH
9548: LD_INT 23
9550: PUSH
9551: LD_INT 2
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 21
9560: PUSH
9561: LD_INT 1
9563: PUSH
9564: EMPTY
9565: LIST
9566: LIST
9567: PUSH
9568: EMPTY
9569: LIST
9570: LIST
9571: LIST
9572: PPUSH
9573: CALL_OW 69
9577: ST_TO_ADDR
// RewardPeople ( tmp ) ;
9578: LD_VAR 0 1
9582: PPUSH
9583: CALL_OW 43
// SaveCharacters ( Heike , 02_Heike ) ;
9587: LD_EXP 21
9591: PPUSH
9592: LD_STRING 02_Heike
9594: PPUSH
9595: CALL_OW 38
// SaveCharacters ( Aviradze , 02_Aviradze ) ;
9599: LD_EXP 25
9603: PPUSH
9604: LD_STRING 02_Aviradze
9606: PPUSH
9607: CALL_OW 38
// if Givi then
9611: LD_EXP 22
9615: IFFALSE 9629
// SaveCharacters ( Givi , 02_Givi ) ;
9617: LD_EXP 22
9621: PPUSH
9622: LD_STRING 02_Givi
9624: PPUSH
9625: CALL_OW 38
// if Mike then
9629: LD_EXP 23
9633: IFFALSE 9647
// SaveCharacters ( Mike , 02_Mike ) ;
9635: LD_EXP 23
9639: PPUSH
9640: LD_STRING 02_Mike
9642: PPUSH
9643: CALL_OW 38
// if Kamil then
9647: LD_EXP 24
9651: IFFALSE 9665
// SaveCharacters ( Kamil , 02_Kamil ) ;
9653: LD_EXP 24
9657: PPUSH
9658: LD_STRING 02_Kamil
9660: PPUSH
9661: CALL_OW 38
// if Kaia then
9665: LD_EXP 26
9669: IFFALSE 9683
// SaveCharacters ( Kaia , 02_Kaia ) ;
9671: LD_EXP 26
9675: PPUSH
9676: LD_STRING 02_Kaia
9678: PPUSH
9679: CALL_OW 38
// if Sophia then
9683: LD_EXP 27
9687: IFFALSE 9701
// SaveCharacters ( Sophia , 02_Sophia ) ;
9689: LD_EXP 27
9693: PPUSH
9694: LD_STRING 02_Sophia
9696: PPUSH
9697: CALL_OW 38
// if Markov then
9701: LD_EXP 28
9705: IFFALSE 9719
// SaveCharacters ( Markov , 02_Markov ) ;
9707: LD_EXP 28
9711: PPUSH
9712: LD_STRING 02_Markov
9714: PPUSH
9715: CALL_OW 38
// if tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] then
9719: LD_VAR 0 1
9723: PUSH
9724: LD_EXP 21
9728: PUSH
9729: LD_EXP 25
9733: PUSH
9734: LD_EXP 22
9738: PUSH
9739: LD_EXP 23
9743: PUSH
9744: LD_EXP 24
9748: PUSH
9749: LD_EXP 27
9753: PUSH
9754: LD_EXP 26
9758: PUSH
9759: LD_EXP 28
9763: PUSH
9764: EMPTY
9765: LIST
9766: LIST
9767: LIST
9768: LIST
9769: LIST
9770: LIST
9771: LIST
9772: LIST
9773: DIFF
9774: IFFALSE 9839
// SaveCharacters ( tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] , 02_others ) ;
9776: LD_VAR 0 1
9780: PUSH
9781: LD_EXP 21
9785: PUSH
9786: LD_EXP 25
9790: PUSH
9791: LD_EXP 22
9795: PUSH
9796: LD_EXP 23
9800: PUSH
9801: LD_EXP 24
9805: PUSH
9806: LD_EXP 27
9810: PUSH
9811: LD_EXP 26
9815: PUSH
9816: LD_EXP 28
9820: PUSH
9821: EMPTY
9822: LIST
9823: LIST
9824: LIST
9825: LIST
9826: LIST
9827: LIST
9828: LIST
9829: LIST
9830: DIFF
9831: PPUSH
9832: LD_STRING 02_others
9834: PPUSH
9835: CALL_OW 38
// YouWin ;
9839: CALL_OW 103
// InGameOff ;
9843: CALL_OW 9
// end ;
9847: PPOPN 1
9849: END
// every 0 0$1 trigger tick > timeUntilFarmer and aviradzeSpotted do
9850: LD_OWVAR 1
9854: PUSH
9855: LD_EXP 11
9859: GREATER
9860: PUSH
9861: LD_EXP 4
9865: AND
9866: IFFALSE 9906
9868: GO 9870
9870: DISABLE
// begin InGameOn ;
9871: CALL_OW 8
// PrepareFarmer ;
9875: CALL 10506 0 0
// CenterNowOnUnits ( Farmer ) ;
9879: LD_EXP 29
9883: PPUSH
9884: CALL_OW 87
// wait ( 0 0$2 ) ;
9888: LD_INT 70
9890: PPUSH
9891: CALL_OW 67
// YouLost ( Farmer ) ;
9895: LD_STRING Farmer
9897: PPUSH
9898: CALL_OW 104
// InGameOff ;
9902: CALL_OW 9
// end ; end_of_file
9906: END
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer ; export function PrepareArabian ; var un , veh ; begin
9907: LD_INT 0
9909: PPUSH
9910: PPUSH
9911: PPUSH
// uc_side := 2 ;
9912: LD_ADDR_OWVAR 20
9916: PUSH
9917: LD_INT 2
9919: ST_TO_ADDR
// uc_nation := 2 ;
9920: LD_ADDR_OWVAR 21
9924: PUSH
9925: LD_INT 2
9927: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
9928: LD_ADDR_EXP 21
9932: PUSH
9933: LD_STRING Heike
9935: PPUSH
9936: LD_EXP 1
9940: NOT
9941: PPUSH
9942: LD_EXP 2
9946: PPUSH
9947: CALL 221 0 3
9951: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
9952: LD_EXP 21
9956: PPUSH
9957: LD_INT 83
9959: PPUSH
9960: LD_INT 72
9962: PPUSH
9963: LD_INT 0
9965: PPUSH
9966: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
9970: LD_ADDR_EXP 22
9974: PUSH
9975: LD_STRING Givi
9977: PPUSH
9978: LD_EXP 1
9982: NOT
9983: PPUSH
9984: LD_EXP 2
9988: PPUSH
9989: CALL 221 0 3
9993: ST_TO_ADDR
// if Givi then
9994: LD_EXP 22
9998: IFFALSE 10018
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
10000: LD_EXP 22
10004: PPUSH
10005: LD_INT 87
10007: PPUSH
10008: LD_INT 76
10010: PPUSH
10011: LD_INT 0
10013: PPUSH
10014: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
10018: LD_ADDR_EXP 23
10022: PUSH
10023: LD_STRING Mike
10025: PPUSH
10026: LD_EXP 1
10030: NOT
10031: PPUSH
10032: LD_EXP 2
10036: PPUSH
10037: CALL 221 0 3
10041: ST_TO_ADDR
// if Mike then
10042: LD_EXP 23
10046: IFFALSE 10066
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
10048: LD_EXP 23
10052: PPUSH
10053: LD_INT 84
10055: PPUSH
10056: LD_INT 76
10058: PPUSH
10059: LD_INT 0
10061: PPUSH
10062: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
10066: LD_ADDR_EXP 24
10070: PUSH
10071: LD_STRING Kamil
10073: PPUSH
10074: LD_EXP 1
10078: NOT
10079: PPUSH
10080: LD_EXP 2
10084: PPUSH
10085: CALL 221 0 3
10089: ST_TO_ADDR
// if Kamil then
10090: LD_EXP 24
10094: IFFALSE 10114
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
10096: LD_EXP 24
10100: PPUSH
10101: LD_INT 85
10103: PPUSH
10104: LD_INT 78
10106: PPUSH
10107: LD_INT 0
10109: PPUSH
10110: CALL_OW 48
// uc_side := 5 ;
10114: LD_ADDR_OWVAR 20
10118: PUSH
10119: LD_INT 5
10121: ST_TO_ADDR
// uc_nation := 2 ;
10122: LD_ADDR_OWVAR 21
10126: PUSH
10127: LD_INT 2
10129: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , false ,  ) ;
10130: LD_ADDR_EXP 25
10134: PUSH
10135: LD_STRING Aviradze
10137: PPUSH
10138: LD_INT 0
10140: PPUSH
10141: LD_STRING 
10143: PPUSH
10144: CALL 221 0 3
10148: ST_TO_ADDR
// PlaceUnitXY ( Aviradze , 106 , 38 , false ) ;
10149: LD_EXP 25
10153: PPUSH
10154: LD_INT 106
10156: PPUSH
10157: LD_INT 38
10159: PPUSH
10160: LD_INT 0
10162: PPUSH
10163: CALL_OW 48
// ComTurnXY ( Aviradze , 103 , 38 ) ;
10167: LD_EXP 25
10171: PPUSH
10172: LD_INT 103
10174: PPUSH
10175: LD_INT 38
10177: PPUSH
10178: CALL_OW 118
// Kaia := PrepareUnit ( Kaia , false ,  ) ;
10182: LD_ADDR_EXP 26
10186: PUSH
10187: LD_STRING Kaia
10189: PPUSH
10190: LD_INT 0
10192: PPUSH
10193: LD_STRING 
10195: PPUSH
10196: CALL 221 0 3
10200: ST_TO_ADDR
// PlaceUnitXY ( Kaia , 100 , 34 , false ) ;
10201: LD_EXP 26
10205: PPUSH
10206: LD_INT 100
10208: PPUSH
10209: LD_INT 34
10211: PPUSH
10212: LD_INT 0
10214: PPUSH
10215: CALL_OW 48
// ComTurnXY ( Kaia , 100 , 39 ) ;
10219: LD_EXP 26
10223: PPUSH
10224: LD_INT 100
10226: PPUSH
10227: LD_INT 39
10229: PPUSH
10230: CALL_OW 118
// Sophia := PrepareUnit ( Sophia , false ,  ) ;
10234: LD_ADDR_EXP 27
10238: PUSH
10239: LD_STRING Sophia
10241: PPUSH
10242: LD_INT 0
10244: PPUSH
10245: LD_STRING 
10247: PPUSH
10248: CALL 221 0 3
10252: ST_TO_ADDR
// PlaceUnitXY ( Sophia , 109 , 50 , false ) ;
10253: LD_EXP 27
10257: PPUSH
10258: LD_INT 109
10260: PPUSH
10261: LD_INT 50
10263: PPUSH
10264: LD_INT 0
10266: PPUSH
10267: CALL_OW 48
// ComTurnXY ( Sophia , 100 , 39 ) ;
10271: LD_EXP 27
10275: PPUSH
10276: LD_INT 100
10278: PPUSH
10279: LD_INT 39
10281: PPUSH
10282: CALL_OW 118
// Markov := PrepareUnit ( Markov , false ,  ) ;
10286: LD_ADDR_EXP 28
10290: PUSH
10291: LD_STRING Markov
10293: PPUSH
10294: LD_INT 0
10296: PPUSH
10297: LD_STRING 
10299: PPUSH
10300: CALL 221 0 3
10304: ST_TO_ADDR
// PrepareTank ( 5 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , [ 90 , 70 , 60 ] [ Difficulty ] ) ;
10305: LD_INT 5
10307: PPUSH
10308: LD_INT 3
10310: PPUSH
10311: LD_INT 21
10313: PPUSH
10314: LD_INT 1
10316: PPUSH
10317: LD_INT 1
10319: PPUSH
10320: LD_INT 42
10322: PPUSH
10323: LD_INT 90
10325: PUSH
10326: LD_INT 70
10328: PUSH
10329: LD_INT 60
10331: PUSH
10332: EMPTY
10333: LIST
10334: LIST
10335: LIST
10336: PUSH
10337: LD_OWVAR 67
10341: ARRAY
10342: PPUSH
10343: CALL 284 0 7
// veh := CreateVehicle ;
10347: LD_ADDR_VAR 0 3
10351: PUSH
10352: CALL_OW 45
10356: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10357: LD_VAR 0 3
10361: PPUSH
10362: LD_INT 4
10364: PPUSH
10365: CALL_OW 233
// PlaceUnitXY ( veh , 109 , 38 , false ) ;
10369: LD_VAR 0 3
10373: PPUSH
10374: LD_INT 109
10376: PPUSH
10377: LD_INT 38
10379: PPUSH
10380: LD_INT 0
10382: PPUSH
10383: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
10387: LD_EXP 28
10391: PPUSH
10392: LD_VAR 0 3
10396: PPUSH
10397: CALL_OW 52
// ComTurnUnit ( Kaia , Aviradze ) ;
10401: LD_EXP 26
10405: PPUSH
10406: LD_EXP 25
10410: PPUSH
10411: CALL_OW 119
// ComTurnUnit ( Aviradze , Kaia ) ;
10415: LD_EXP 25
10419: PPUSH
10420: LD_EXP 26
10424: PPUSH
10425: CALL_OW 119
// if not Givi or not Mike then
10429: LD_EXP 22
10433: NOT
10434: PUSH
10435: LD_EXP 23
10439: NOT
10440: OR
10441: IFFALSE 10501
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10443: LD_INT 1
10445: PPUSH
10446: LD_INT 1
10448: PPUSH
10449: LD_INT 1
10451: PPUSH
10452: CALL_OW 380
// un := CreateHuman ;
10456: LD_ADDR_VAR 0 2
10460: PUSH
10461: CALL_OW 44
10465: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 40 , 3 , false ) ;
10466: LD_VAR 0 2
10470: PPUSH
10471: LD_INT 112
10473: PPUSH
10474: LD_INT 40
10476: PPUSH
10477: LD_INT 3
10479: PPUSH
10480: LD_INT 0
10482: PPUSH
10483: CALL_OW 50
// ComTurnUnit ( un , Aviradze ) ;
10487: LD_VAR 0 2
10491: PPUSH
10492: LD_EXP 25
10496: PPUSH
10497: CALL_OW 119
// end ; end ;
10501: LD_VAR 0 1
10505: RET
// export function PrepareFarmer ; var i ; begin
10506: LD_INT 0
10508: PPUSH
10509: PPUSH
// uc_side := 5 ;
10510: LD_ADDR_OWVAR 20
10514: PUSH
10515: LD_INT 5
10517: ST_TO_ADDR
// uc_nation := 2 ;
10518: LD_ADDR_OWVAR 21
10522: PUSH
10523: LD_INT 2
10525: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
10526: LD_ADDR_EXP 29
10530: PUSH
10531: LD_STRING Farmer
10533: PPUSH
10534: LD_INT 0
10536: PPUSH
10537: LD_STRING 
10539: PPUSH
10540: CALL 221 0 3
10544: ST_TO_ADDR
// PlaceUnitXY ( Farmer , 106 , 62 , false ) ;
10545: LD_EXP 29
10549: PPUSH
10550: LD_INT 106
10552: PPUSH
10553: LD_INT 62
10555: PPUSH
10556: LD_INT 0
10558: PPUSH
10559: CALL_OW 48
// for i := 1 to 2 do
10563: LD_ADDR_VAR 0 2
10567: PUSH
10568: DOUBLE
10569: LD_INT 1
10571: DEC
10572: ST_TO_ADDR
10573: LD_INT 2
10575: PUSH
10576: FOR_TO
10577: IFFALSE 10615
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10579: LD_INT 1
10581: PPUSH
10582: LD_INT 1
10584: PPUSH
10585: LD_INT 1
10587: PPUSH
10588: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 105 , 64 , 2 , false ) ;
10592: CALL_OW 44
10596: PPUSH
10597: LD_INT 105
10599: PPUSH
10600: LD_INT 64
10602: PPUSH
10603: LD_INT 2
10605: PPUSH
10606: LD_INT 0
10608: PPUSH
10609: CALL_OW 50
// end ;
10613: GO 10576
10615: POP
10616: POP
// end ; end_of_file
10617: LD_VAR 0 1
10621: RET
// every 2 2$20 + 0 0$10 do
10622: GO 10624
10624: DISABLE
// begin enable ;
10625: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , forest , true ) ;
10626: LD_INT 1
10628: PPUSH
10629: LD_INT 5
10631: PPUSH
10632: CALL_OW 12
10636: PPUSH
10637: LD_INT 1
10639: PPUSH
10640: LD_INT 1
10642: PPUSH
10643: CALL_OW 55
// end ; end_of_file
10647: END
// on UnitDestroyed ( un ) do begin if un = Heike then
10648: LD_VAR 0 1
10652: PUSH
10653: LD_EXP 21
10657: EQUAL
10658: IFFALSE 10667
// YouLost ( Heike ) ;
10660: LD_STRING Heike
10662: PPUSH
10663: CALL_OW 104
// if un = Aviradze then
10667: LD_VAR 0 1
10671: PUSH
10672: LD_EXP 25
10676: EQUAL
10677: IFFALSE 10686
// YouLost ( Aviradze ) ;
10679: LD_STRING Aviradze
10681: PPUSH
10682: CALL_OW 104
// if un = usLab then
10686: LD_VAR 0 1
10690: PUSH
10691: LD_INT 3
10693: EQUAL
10694: IFFALSE 10703
// YouLost ( Lab ) ;
10696: LD_STRING Lab
10698: PPUSH
10699: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) diff [ Heike , Aviradze ] and aviradzeSpotted then
10703: LD_VAR 0 1
10707: PUSH
10708: LD_INT 22
10710: PUSH
10711: LD_INT 2
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PUSH
10718: LD_INT 21
10720: PUSH
10721: LD_INT 1
10723: PUSH
10724: EMPTY
10725: LIST
10726: LIST
10727: PUSH
10728: LD_INT 23
10730: PUSH
10731: LD_INT 2
10733: PUSH
10734: EMPTY
10735: LIST
10736: LIST
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: LIST
10742: PPUSH
10743: CALL_OW 69
10747: PUSH
10748: LD_EXP 21
10752: PUSH
10753: LD_EXP 25
10757: PUSH
10758: EMPTY
10759: LIST
10760: LIST
10761: DIFF
10762: IN
10763: PUSH
10764: LD_EXP 4
10768: AND
10769: IFFALSE 10785
// lostCounter := lostCounter + 1 ;
10771: LD_ADDR_EXP 16
10775: PUSH
10776: LD_EXP 16
10780: PUSH
10781: LD_INT 1
10783: PLUS
10784: ST_TO_ADDR
// end ;
10785: PPOPN 1
10787: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un in usSci and killerSide = 2 then
10788: LD_VAR 0 1
10792: PUSH
10793: LD_EXP 20
10797: IN
10798: PUSH
10799: LD_VAR 0 2
10803: PUSH
10804: LD_INT 2
10806: EQUAL
10807: AND
10808: IFFALSE 10824
// sciCounterKill := sciCounterKill + 1 ;
10810: LD_ADDR_EXP 8
10814: PUSH
10815: LD_EXP 8
10819: PUSH
10820: LD_INT 1
10822: PLUS
10823: ST_TO_ADDR
// end ;
10824: PPOPN 3
10826: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
10827: LD_VAR 0 1
10831: PUSH
10832: LD_INT 2
10834: EQUAL
10835: PUSH
10836: LD_VAR 0 2
10840: PUSH
10841: LD_INT 5
10843: EQUAL
10844: AND
10845: IFFALSE 10854
// YouLost ( FriendlyFire ) ;
10847: LD_STRING FriendlyFire
10849: PPUSH
10850: CALL_OW 104
// end ; end_of_file
10854: PPOPN 2
10856: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
10857: GO 10859
10859: DISABLE
// begin ru_radar := 98 ;
10860: LD_ADDR_EXP 30
10864: PUSH
10865: LD_INT 98
10867: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10868: LD_ADDR_EXP 31
10872: PUSH
10873: LD_INT 89
10875: ST_TO_ADDR
// us_hack := 99 ;
10876: LD_ADDR_EXP 32
10880: PUSH
10881: LD_INT 99
10883: ST_TO_ADDR
// us_artillery := 97 ;
10884: LD_ADDR_EXP 33
10888: PUSH
10889: LD_INT 97
10891: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10892: LD_ADDR_EXP 34
10896: PUSH
10897: LD_INT 91
10899: ST_TO_ADDR
// tech_Artillery := 80 ;
10900: LD_ADDR_EXP 35
10904: PUSH
10905: LD_INT 80
10907: ST_TO_ADDR
// tech_RadMat := 81 ;
10908: LD_ADDR_EXP 36
10912: PUSH
10913: LD_INT 81
10915: ST_TO_ADDR
// tech_BasicTools := 82 ;
10916: LD_ADDR_EXP 37
10920: PUSH
10921: LD_INT 82
10923: ST_TO_ADDR
// tech_Cargo := 83 ;
10924: LD_ADDR_EXP 38
10928: PUSH
10929: LD_INT 83
10931: ST_TO_ADDR
// tech_Track := 84 ;
10932: LD_ADDR_EXP 39
10936: PUSH
10937: LD_INT 84
10939: ST_TO_ADDR
// tech_Crane := 85 ;
10940: LD_ADDR_EXP 40
10944: PUSH
10945: LD_INT 85
10947: ST_TO_ADDR
// tech_Bulldozer := 86 ;
10948: LD_ADDR_EXP 41
10952: PUSH
10953: LD_INT 86
10955: ST_TO_ADDR
// tech_Hovercraft := 87 ;
10956: LD_ADDR_EXP 42
10960: PUSH
10961: LD_INT 87
10963: ST_TO_ADDR
// end ; end_of_file end_of_file
10964: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
10965: GO 10967
10967: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
10968: LD_STRING initStreamRollete();
10970: PPUSH
10971: CALL_OW 559
// InitStreamMode ;
10975: CALL 10984 0 0
// DefineStreamItems ( ) ;
10979: CALL 11424 0 0
// end ;
10983: END
// function InitStreamMode ; begin
10984: LD_INT 0
10986: PPUSH
// streamModeActive := false ;
10987: LD_ADDR_EXP 43
10991: PUSH
10992: LD_INT 0
10994: ST_TO_ADDR
// normalCounter := 36 ;
10995: LD_ADDR_EXP 44
10999: PUSH
11000: LD_INT 36
11002: ST_TO_ADDR
// hardcoreCounter := 16 ;
11003: LD_ADDR_EXP 45
11007: PUSH
11008: LD_INT 16
11010: ST_TO_ADDR
// sRocket := false ;
11011: LD_ADDR_EXP 48
11015: PUSH
11016: LD_INT 0
11018: ST_TO_ADDR
// sSpeed := false ;
11019: LD_ADDR_EXP 47
11023: PUSH
11024: LD_INT 0
11026: ST_TO_ADDR
// sEngine := false ;
11027: LD_ADDR_EXP 49
11031: PUSH
11032: LD_INT 0
11034: ST_TO_ADDR
// sSpec := false ;
11035: LD_ADDR_EXP 46
11039: PUSH
11040: LD_INT 0
11042: ST_TO_ADDR
// sLevel := false ;
11043: LD_ADDR_EXP 50
11047: PUSH
11048: LD_INT 0
11050: ST_TO_ADDR
// sArmoury := false ;
11051: LD_ADDR_EXP 51
11055: PUSH
11056: LD_INT 0
11058: ST_TO_ADDR
// sRadar := false ;
11059: LD_ADDR_EXP 52
11063: PUSH
11064: LD_INT 0
11066: ST_TO_ADDR
// sBunker := false ;
11067: LD_ADDR_EXP 53
11071: PUSH
11072: LD_INT 0
11074: ST_TO_ADDR
// sHack := false ;
11075: LD_ADDR_EXP 54
11079: PUSH
11080: LD_INT 0
11082: ST_TO_ADDR
// sFire := false ;
11083: LD_ADDR_EXP 55
11087: PUSH
11088: LD_INT 0
11090: ST_TO_ADDR
// sRefresh := false ;
11091: LD_ADDR_EXP 56
11095: PUSH
11096: LD_INT 0
11098: ST_TO_ADDR
// sExp := false ;
11099: LD_ADDR_EXP 57
11103: PUSH
11104: LD_INT 0
11106: ST_TO_ADDR
// sDepot := false ;
11107: LD_ADDR_EXP 58
11111: PUSH
11112: LD_INT 0
11114: ST_TO_ADDR
// sFlag := false ;
11115: LD_ADDR_EXP 59
11119: PUSH
11120: LD_INT 0
11122: ST_TO_ADDR
// sKamikadze := false ;
11123: LD_ADDR_EXP 67
11127: PUSH
11128: LD_INT 0
11130: ST_TO_ADDR
// sTroll := false ;
11131: LD_ADDR_EXP 68
11135: PUSH
11136: LD_INT 0
11138: ST_TO_ADDR
// sSlow := false ;
11139: LD_ADDR_EXP 69
11143: PUSH
11144: LD_INT 0
11146: ST_TO_ADDR
// sLack := false ;
11147: LD_ADDR_EXP 70
11151: PUSH
11152: LD_INT 0
11154: ST_TO_ADDR
// sTank := false ;
11155: LD_ADDR_EXP 72
11159: PUSH
11160: LD_INT 0
11162: ST_TO_ADDR
// sRemote := false ;
11163: LD_ADDR_EXP 73
11167: PUSH
11168: LD_INT 0
11170: ST_TO_ADDR
// sPowell := false ;
11171: LD_ADDR_EXP 74
11175: PUSH
11176: LD_INT 0
11178: ST_TO_ADDR
// sTeleport := false ;
11179: LD_ADDR_EXP 77
11183: PUSH
11184: LD_INT 0
11186: ST_TO_ADDR
// sOilTower := false ;
11187: LD_ADDR_EXP 79
11191: PUSH
11192: LD_INT 0
11194: ST_TO_ADDR
// sShovel := false ;
11195: LD_ADDR_EXP 80
11199: PUSH
11200: LD_INT 0
11202: ST_TO_ADDR
// sSheik := false ;
11203: LD_ADDR_EXP 81
11207: PUSH
11208: LD_INT 0
11210: ST_TO_ADDR
// sEarthquake := false ;
11211: LD_ADDR_EXP 83
11215: PUSH
11216: LD_INT 0
11218: ST_TO_ADDR
// sAI := false ;
11219: LD_ADDR_EXP 84
11223: PUSH
11224: LD_INT 0
11226: ST_TO_ADDR
// sCargo := false ;
11227: LD_ADDR_EXP 87
11231: PUSH
11232: LD_INT 0
11234: ST_TO_ADDR
// sDLaser := false ;
11235: LD_ADDR_EXP 88
11239: PUSH
11240: LD_INT 0
11242: ST_TO_ADDR
// sExchange := false ;
11243: LD_ADDR_EXP 89
11247: PUSH
11248: LD_INT 0
11250: ST_TO_ADDR
// sFac := false ;
11251: LD_ADDR_EXP 90
11255: PUSH
11256: LD_INT 0
11258: ST_TO_ADDR
// sPower := false ;
11259: LD_ADDR_EXP 91
11263: PUSH
11264: LD_INT 0
11266: ST_TO_ADDR
// sRandom := false ;
11267: LD_ADDR_EXP 92
11271: PUSH
11272: LD_INT 0
11274: ST_TO_ADDR
// sShield := false ;
11275: LD_ADDR_EXP 93
11279: PUSH
11280: LD_INT 0
11282: ST_TO_ADDR
// sTime := false ;
11283: LD_ADDR_EXP 94
11287: PUSH
11288: LD_INT 0
11290: ST_TO_ADDR
// sTools := false ;
11291: LD_ADDR_EXP 95
11295: PUSH
11296: LD_INT 0
11298: ST_TO_ADDR
// sSold := false ;
11299: LD_ADDR_EXP 60
11303: PUSH
11304: LD_INT 0
11306: ST_TO_ADDR
// sDiff := false ;
11307: LD_ADDR_EXP 61
11311: PUSH
11312: LD_INT 0
11314: ST_TO_ADDR
// sFog := false ;
11315: LD_ADDR_EXP 64
11319: PUSH
11320: LD_INT 0
11322: ST_TO_ADDR
// sReset := false ;
11323: LD_ADDR_EXP 65
11327: PUSH
11328: LD_INT 0
11330: ST_TO_ADDR
// sSun := false ;
11331: LD_ADDR_EXP 66
11335: PUSH
11336: LD_INT 0
11338: ST_TO_ADDR
// sTiger := false ;
11339: LD_ADDR_EXP 62
11343: PUSH
11344: LD_INT 0
11346: ST_TO_ADDR
// sBomb := false ;
11347: LD_ADDR_EXP 63
11351: PUSH
11352: LD_INT 0
11354: ST_TO_ADDR
// sWound := false ;
11355: LD_ADDR_EXP 71
11359: PUSH
11360: LD_INT 0
11362: ST_TO_ADDR
// sBetray := false ;
11363: LD_ADDR_EXP 75
11367: PUSH
11368: LD_INT 0
11370: ST_TO_ADDR
// sContamin := false ;
11371: LD_ADDR_EXP 76
11375: PUSH
11376: LD_INT 0
11378: ST_TO_ADDR
// sOil := false ;
11379: LD_ADDR_EXP 78
11383: PUSH
11384: LD_INT 0
11386: ST_TO_ADDR
// sStu := false ;
11387: LD_ADDR_EXP 82
11391: PUSH
11392: LD_INT 0
11394: ST_TO_ADDR
// sBazooka := false ;
11395: LD_ADDR_EXP 85
11399: PUSH
11400: LD_INT 0
11402: ST_TO_ADDR
// sMortar := false ;
11403: LD_ADDR_EXP 86
11407: PUSH
11408: LD_INT 0
11410: ST_TO_ADDR
// sRanger := false ;
11411: LD_ADDR_EXP 96
11415: PUSH
11416: LD_INT 0
11418: ST_TO_ADDR
// end ;
11419: LD_VAR 0 1
11423: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11424: LD_INT 0
11426: PPUSH
11427: PPUSH
11428: PPUSH
11429: PPUSH
11430: PPUSH
// result := [ ] ;
11431: LD_ADDR_VAR 0 1
11435: PUSH
11436: EMPTY
11437: ST_TO_ADDR
// if campaign_id = 1 then
11438: LD_OWVAR 69
11442: PUSH
11443: LD_INT 1
11445: EQUAL
11446: IFFALSE 14384
// begin case mission_number of 1 :
11448: LD_OWVAR 70
11452: PUSH
11453: LD_INT 1
11455: DOUBLE
11456: EQUAL
11457: IFTRUE 11461
11459: GO 11525
11461: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11462: LD_ADDR_VAR 0 1
11466: PUSH
11467: LD_INT 2
11469: PUSH
11470: LD_INT 4
11472: PUSH
11473: LD_INT 11
11475: PUSH
11476: LD_INT 12
11478: PUSH
11479: LD_INT 15
11481: PUSH
11482: LD_INT 16
11484: PUSH
11485: LD_INT 22
11487: PUSH
11488: LD_INT 23
11490: PUSH
11491: LD_INT 26
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: PUSH
11505: LD_INT 101
11507: PUSH
11508: LD_INT 102
11510: PUSH
11511: LD_INT 106
11513: PUSH
11514: EMPTY
11515: LIST
11516: LIST
11517: LIST
11518: PUSH
11519: EMPTY
11520: LIST
11521: LIST
11522: ST_TO_ADDR
11523: GO 14382
11525: LD_INT 2
11527: DOUBLE
11528: EQUAL
11529: IFTRUE 11533
11531: GO 11605
11533: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11534: LD_ADDR_VAR 0 1
11538: PUSH
11539: LD_INT 2
11541: PUSH
11542: LD_INT 4
11544: PUSH
11545: LD_INT 11
11547: PUSH
11548: LD_INT 12
11550: PUSH
11551: LD_INT 15
11553: PUSH
11554: LD_INT 16
11556: PUSH
11557: LD_INT 22
11559: PUSH
11560: LD_INT 23
11562: PUSH
11563: LD_INT 26
11565: PUSH
11566: EMPTY
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: LIST
11572: LIST
11573: LIST
11574: LIST
11575: LIST
11576: PUSH
11577: LD_INT 101
11579: PUSH
11580: LD_INT 102
11582: PUSH
11583: LD_INT 105
11585: PUSH
11586: LD_INT 106
11588: PUSH
11589: LD_INT 108
11591: PUSH
11592: EMPTY
11593: LIST
11594: LIST
11595: LIST
11596: LIST
11597: LIST
11598: PUSH
11599: EMPTY
11600: LIST
11601: LIST
11602: ST_TO_ADDR
11603: GO 14382
11605: LD_INT 3
11607: DOUBLE
11608: EQUAL
11609: IFTRUE 11613
11611: GO 11689
11613: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11614: LD_ADDR_VAR 0 1
11618: PUSH
11619: LD_INT 2
11621: PUSH
11622: LD_INT 4
11624: PUSH
11625: LD_INT 5
11627: PUSH
11628: LD_INT 11
11630: PUSH
11631: LD_INT 12
11633: PUSH
11634: LD_INT 15
11636: PUSH
11637: LD_INT 16
11639: PUSH
11640: LD_INT 22
11642: PUSH
11643: LD_INT 26
11645: PUSH
11646: LD_INT 36
11648: PUSH
11649: EMPTY
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: LIST
11657: LIST
11658: LIST
11659: LIST
11660: PUSH
11661: LD_INT 101
11663: PUSH
11664: LD_INT 102
11666: PUSH
11667: LD_INT 105
11669: PUSH
11670: LD_INT 106
11672: PUSH
11673: LD_INT 108
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: ST_TO_ADDR
11687: GO 14382
11689: LD_INT 4
11691: DOUBLE
11692: EQUAL
11693: IFTRUE 11697
11695: GO 11781
11697: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11698: LD_ADDR_VAR 0 1
11702: PUSH
11703: LD_INT 2
11705: PUSH
11706: LD_INT 4
11708: PUSH
11709: LD_INT 5
11711: PUSH
11712: LD_INT 8
11714: PUSH
11715: LD_INT 11
11717: PUSH
11718: LD_INT 12
11720: PUSH
11721: LD_INT 15
11723: PUSH
11724: LD_INT 16
11726: PUSH
11727: LD_INT 22
11729: PUSH
11730: LD_INT 23
11732: PUSH
11733: LD_INT 26
11735: PUSH
11736: LD_INT 36
11738: PUSH
11739: EMPTY
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: PUSH
11753: LD_INT 101
11755: PUSH
11756: LD_INT 102
11758: PUSH
11759: LD_INT 105
11761: PUSH
11762: LD_INT 106
11764: PUSH
11765: LD_INT 108
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: PUSH
11775: EMPTY
11776: LIST
11777: LIST
11778: ST_TO_ADDR
11779: GO 14382
11781: LD_INT 5
11783: DOUBLE
11784: EQUAL
11785: IFTRUE 11789
11787: GO 11889
11789: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
11790: LD_ADDR_VAR 0 1
11794: PUSH
11795: LD_INT 2
11797: PUSH
11798: LD_INT 4
11800: PUSH
11801: LD_INT 5
11803: PUSH
11804: LD_INT 6
11806: PUSH
11807: LD_INT 8
11809: PUSH
11810: LD_INT 11
11812: PUSH
11813: LD_INT 12
11815: PUSH
11816: LD_INT 15
11818: PUSH
11819: LD_INT 16
11821: PUSH
11822: LD_INT 22
11824: PUSH
11825: LD_INT 23
11827: PUSH
11828: LD_INT 25
11830: PUSH
11831: LD_INT 26
11833: PUSH
11834: LD_INT 36
11836: PUSH
11837: EMPTY
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: PUSH
11853: LD_INT 101
11855: PUSH
11856: LD_INT 102
11858: PUSH
11859: LD_INT 105
11861: PUSH
11862: LD_INT 106
11864: PUSH
11865: LD_INT 108
11867: PUSH
11868: LD_INT 109
11870: PUSH
11871: LD_INT 112
11873: PUSH
11874: EMPTY
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: ST_TO_ADDR
11887: GO 14382
11889: LD_INT 6
11891: DOUBLE
11892: EQUAL
11893: IFTRUE 11897
11895: GO 12017
11897: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
11898: LD_ADDR_VAR 0 1
11902: PUSH
11903: LD_INT 2
11905: PUSH
11906: LD_INT 4
11908: PUSH
11909: LD_INT 5
11911: PUSH
11912: LD_INT 6
11914: PUSH
11915: LD_INT 8
11917: PUSH
11918: LD_INT 11
11920: PUSH
11921: LD_INT 12
11923: PUSH
11924: LD_INT 15
11926: PUSH
11927: LD_INT 16
11929: PUSH
11930: LD_INT 20
11932: PUSH
11933: LD_INT 21
11935: PUSH
11936: LD_INT 22
11938: PUSH
11939: LD_INT 23
11941: PUSH
11942: LD_INT 25
11944: PUSH
11945: LD_INT 26
11947: PUSH
11948: LD_INT 30
11950: PUSH
11951: LD_INT 31
11953: PUSH
11954: LD_INT 32
11956: PUSH
11957: LD_INT 36
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: LIST
11964: LIST
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: LIST
11974: LIST
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: PUSH
11981: LD_INT 101
11983: PUSH
11984: LD_INT 102
11986: PUSH
11987: LD_INT 105
11989: PUSH
11990: LD_INT 106
11992: PUSH
11993: LD_INT 108
11995: PUSH
11996: LD_INT 109
11998: PUSH
11999: LD_INT 112
12001: PUSH
12002: EMPTY
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: ST_TO_ADDR
12015: GO 14382
12017: LD_INT 7
12019: DOUBLE
12020: EQUAL
12021: IFTRUE 12025
12023: GO 12125
12025: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12026: LD_ADDR_VAR 0 1
12030: PUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 4
12036: PUSH
12037: LD_INT 5
12039: PUSH
12040: LD_INT 7
12042: PUSH
12043: LD_INT 11
12045: PUSH
12046: LD_INT 12
12048: PUSH
12049: LD_INT 15
12051: PUSH
12052: LD_INT 16
12054: PUSH
12055: LD_INT 20
12057: PUSH
12058: LD_INT 21
12060: PUSH
12061: LD_INT 22
12063: PUSH
12064: LD_INT 23
12066: PUSH
12067: LD_INT 25
12069: PUSH
12070: LD_INT 26
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: LIST
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: PUSH
12089: LD_INT 101
12091: PUSH
12092: LD_INT 102
12094: PUSH
12095: LD_INT 103
12097: PUSH
12098: LD_INT 105
12100: PUSH
12101: LD_INT 106
12103: PUSH
12104: LD_INT 108
12106: PUSH
12107: LD_INT 112
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: LIST
12114: LIST
12115: LIST
12116: LIST
12117: LIST
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: ST_TO_ADDR
12123: GO 14382
12125: LD_INT 8
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12261
12133: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12134: LD_ADDR_VAR 0 1
12138: PUSH
12139: LD_INT 2
12141: PUSH
12142: LD_INT 4
12144: PUSH
12145: LD_INT 5
12147: PUSH
12148: LD_INT 6
12150: PUSH
12151: LD_INT 7
12153: PUSH
12154: LD_INT 8
12156: PUSH
12157: LD_INT 11
12159: PUSH
12160: LD_INT 12
12162: PUSH
12163: LD_INT 15
12165: PUSH
12166: LD_INT 16
12168: PUSH
12169: LD_INT 20
12171: PUSH
12172: LD_INT 21
12174: PUSH
12175: LD_INT 22
12177: PUSH
12178: LD_INT 23
12180: PUSH
12181: LD_INT 25
12183: PUSH
12184: LD_INT 26
12186: PUSH
12187: LD_INT 30
12189: PUSH
12190: LD_INT 31
12192: PUSH
12193: LD_INT 32
12195: PUSH
12196: LD_INT 36
12198: PUSH
12199: EMPTY
12200: LIST
12201: LIST
12202: LIST
12203: LIST
12204: LIST
12205: LIST
12206: LIST
12207: LIST
12208: LIST
12209: LIST
12210: LIST
12211: LIST
12212: LIST
12213: LIST
12214: LIST
12215: LIST
12216: LIST
12217: LIST
12218: LIST
12219: LIST
12220: PUSH
12221: LD_INT 101
12223: PUSH
12224: LD_INT 102
12226: PUSH
12227: LD_INT 103
12229: PUSH
12230: LD_INT 105
12232: PUSH
12233: LD_INT 106
12235: PUSH
12236: LD_INT 108
12238: PUSH
12239: LD_INT 109
12241: PUSH
12242: LD_INT 112
12244: PUSH
12245: EMPTY
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: PUSH
12255: EMPTY
12256: LIST
12257: LIST
12258: ST_TO_ADDR
12259: GO 14382
12261: LD_INT 9
12263: DOUBLE
12264: EQUAL
12265: IFTRUE 12269
12267: GO 12405
12269: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12270: LD_ADDR_VAR 0 1
12274: PUSH
12275: LD_INT 2
12277: PUSH
12278: LD_INT 4
12280: PUSH
12281: LD_INT 5
12283: PUSH
12284: LD_INT 6
12286: PUSH
12287: LD_INT 7
12289: PUSH
12290: LD_INT 8
12292: PUSH
12293: LD_INT 11
12295: PUSH
12296: LD_INT 12
12298: PUSH
12299: LD_INT 15
12301: PUSH
12302: LD_INT 16
12304: PUSH
12305: LD_INT 20
12307: PUSH
12308: LD_INT 21
12310: PUSH
12311: LD_INT 22
12313: PUSH
12314: LD_INT 23
12316: PUSH
12317: LD_INT 25
12319: PUSH
12320: LD_INT 26
12322: PUSH
12323: LD_INT 28
12325: PUSH
12326: LD_INT 30
12328: PUSH
12329: LD_INT 31
12331: PUSH
12332: LD_INT 32
12334: PUSH
12335: LD_INT 36
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: LIST
12342: LIST
12343: LIST
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: LIST
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: PUSH
12361: LD_INT 101
12363: PUSH
12364: LD_INT 102
12366: PUSH
12367: LD_INT 103
12369: PUSH
12370: LD_INT 105
12372: PUSH
12373: LD_INT 106
12375: PUSH
12376: LD_INT 108
12378: PUSH
12379: LD_INT 109
12381: PUSH
12382: LD_INT 112
12384: PUSH
12385: LD_INT 114
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: PUSH
12399: EMPTY
12400: LIST
12401: LIST
12402: ST_TO_ADDR
12403: GO 14382
12405: LD_INT 10
12407: DOUBLE
12408: EQUAL
12409: IFTRUE 12413
12411: GO 12597
12413: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12414: LD_ADDR_VAR 0 1
12418: PUSH
12419: LD_INT 2
12421: PUSH
12422: LD_INT 4
12424: PUSH
12425: LD_INT 5
12427: PUSH
12428: LD_INT 6
12430: PUSH
12431: LD_INT 7
12433: PUSH
12434: LD_INT 8
12436: PUSH
12437: LD_INT 9
12439: PUSH
12440: LD_INT 10
12442: PUSH
12443: LD_INT 11
12445: PUSH
12446: LD_INT 12
12448: PUSH
12449: LD_INT 13
12451: PUSH
12452: LD_INT 14
12454: PUSH
12455: LD_INT 15
12457: PUSH
12458: LD_INT 16
12460: PUSH
12461: LD_INT 17
12463: PUSH
12464: LD_INT 18
12466: PUSH
12467: LD_INT 19
12469: PUSH
12470: LD_INT 20
12472: PUSH
12473: LD_INT 21
12475: PUSH
12476: LD_INT 22
12478: PUSH
12479: LD_INT 23
12481: PUSH
12482: LD_INT 24
12484: PUSH
12485: LD_INT 25
12487: PUSH
12488: LD_INT 26
12490: PUSH
12491: LD_INT 28
12493: PUSH
12494: LD_INT 30
12496: PUSH
12497: LD_INT 31
12499: PUSH
12500: LD_INT 32
12502: PUSH
12503: LD_INT 36
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: LIST
12510: LIST
12511: LIST
12512: LIST
12513: LIST
12514: LIST
12515: LIST
12516: LIST
12517: LIST
12518: LIST
12519: LIST
12520: LIST
12521: LIST
12522: LIST
12523: LIST
12524: LIST
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: LIST
12530: LIST
12531: LIST
12532: LIST
12533: LIST
12534: LIST
12535: LIST
12536: PUSH
12537: LD_INT 101
12539: PUSH
12540: LD_INT 102
12542: PUSH
12543: LD_INT 103
12545: PUSH
12546: LD_INT 104
12548: PUSH
12549: LD_INT 105
12551: PUSH
12552: LD_INT 106
12554: PUSH
12555: LD_INT 107
12557: PUSH
12558: LD_INT 108
12560: PUSH
12561: LD_INT 109
12563: PUSH
12564: LD_INT 110
12566: PUSH
12567: LD_INT 111
12569: PUSH
12570: LD_INT 112
12572: PUSH
12573: LD_INT 114
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: LIST
12590: PUSH
12591: EMPTY
12592: LIST
12593: LIST
12594: ST_TO_ADDR
12595: GO 14382
12597: LD_INT 11
12599: DOUBLE
12600: EQUAL
12601: IFTRUE 12605
12603: GO 12797
12605: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12606: LD_ADDR_VAR 0 1
12610: PUSH
12611: LD_INT 2
12613: PUSH
12614: LD_INT 3
12616: PUSH
12617: LD_INT 4
12619: PUSH
12620: LD_INT 5
12622: PUSH
12623: LD_INT 6
12625: PUSH
12626: LD_INT 7
12628: PUSH
12629: LD_INT 8
12631: PUSH
12632: LD_INT 9
12634: PUSH
12635: LD_INT 10
12637: PUSH
12638: LD_INT 11
12640: PUSH
12641: LD_INT 12
12643: PUSH
12644: LD_INT 13
12646: PUSH
12647: LD_INT 14
12649: PUSH
12650: LD_INT 15
12652: PUSH
12653: LD_INT 16
12655: PUSH
12656: LD_INT 17
12658: PUSH
12659: LD_INT 18
12661: PUSH
12662: LD_INT 19
12664: PUSH
12665: LD_INT 20
12667: PUSH
12668: LD_INT 21
12670: PUSH
12671: LD_INT 22
12673: PUSH
12674: LD_INT 23
12676: PUSH
12677: LD_INT 24
12679: PUSH
12680: LD_INT 25
12682: PUSH
12683: LD_INT 26
12685: PUSH
12686: LD_INT 28
12688: PUSH
12689: LD_INT 30
12691: PUSH
12692: LD_INT 31
12694: PUSH
12695: LD_INT 32
12697: PUSH
12698: LD_INT 34
12700: PUSH
12701: LD_INT 36
12703: PUSH
12704: EMPTY
12705: LIST
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: LIST
12711: LIST
12712: LIST
12713: LIST
12714: LIST
12715: LIST
12716: LIST
12717: LIST
12718: LIST
12719: LIST
12720: LIST
12721: LIST
12722: LIST
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: LIST
12729: LIST
12730: LIST
12731: LIST
12732: LIST
12733: LIST
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 101
12739: PUSH
12740: LD_INT 102
12742: PUSH
12743: LD_INT 103
12745: PUSH
12746: LD_INT 104
12748: PUSH
12749: LD_INT 105
12751: PUSH
12752: LD_INT 106
12754: PUSH
12755: LD_INT 107
12757: PUSH
12758: LD_INT 108
12760: PUSH
12761: LD_INT 109
12763: PUSH
12764: LD_INT 110
12766: PUSH
12767: LD_INT 111
12769: PUSH
12770: LD_INT 112
12772: PUSH
12773: LD_INT 114
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: LIST
12780: LIST
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: LIST
12789: LIST
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: ST_TO_ADDR
12795: GO 14382
12797: LD_INT 12
12799: DOUBLE
12800: EQUAL
12801: IFTRUE 12805
12803: GO 13013
12805: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
12806: LD_ADDR_VAR 0 1
12810: PUSH
12811: LD_INT 1
12813: PUSH
12814: LD_INT 2
12816: PUSH
12817: LD_INT 3
12819: PUSH
12820: LD_INT 4
12822: PUSH
12823: LD_INT 5
12825: PUSH
12826: LD_INT 6
12828: PUSH
12829: LD_INT 7
12831: PUSH
12832: LD_INT 8
12834: PUSH
12835: LD_INT 9
12837: PUSH
12838: LD_INT 10
12840: PUSH
12841: LD_INT 11
12843: PUSH
12844: LD_INT 12
12846: PUSH
12847: LD_INT 13
12849: PUSH
12850: LD_INT 14
12852: PUSH
12853: LD_INT 15
12855: PUSH
12856: LD_INT 16
12858: PUSH
12859: LD_INT 17
12861: PUSH
12862: LD_INT 18
12864: PUSH
12865: LD_INT 19
12867: PUSH
12868: LD_INT 20
12870: PUSH
12871: LD_INT 21
12873: PUSH
12874: LD_INT 22
12876: PUSH
12877: LD_INT 23
12879: PUSH
12880: LD_INT 24
12882: PUSH
12883: LD_INT 25
12885: PUSH
12886: LD_INT 26
12888: PUSH
12889: LD_INT 27
12891: PUSH
12892: LD_INT 28
12894: PUSH
12895: LD_INT 30
12897: PUSH
12898: LD_INT 31
12900: PUSH
12901: LD_INT 32
12903: PUSH
12904: LD_INT 33
12906: PUSH
12907: LD_INT 34
12909: PUSH
12910: LD_INT 36
12912: PUSH
12913: EMPTY
12914: LIST
12915: LIST
12916: LIST
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: LIST
12929: LIST
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: LIST
12936: LIST
12937: LIST
12938: LIST
12939: LIST
12940: LIST
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: LIST
12947: LIST
12948: PUSH
12949: LD_INT 101
12951: PUSH
12952: LD_INT 102
12954: PUSH
12955: LD_INT 103
12957: PUSH
12958: LD_INT 104
12960: PUSH
12961: LD_INT 105
12963: PUSH
12964: LD_INT 106
12966: PUSH
12967: LD_INT 107
12969: PUSH
12970: LD_INT 108
12972: PUSH
12973: LD_INT 109
12975: PUSH
12976: LD_INT 110
12978: PUSH
12979: LD_INT 111
12981: PUSH
12982: LD_INT 112
12984: PUSH
12985: LD_INT 113
12987: PUSH
12988: LD_INT 114
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: LIST
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: PUSH
13007: EMPTY
13008: LIST
13009: LIST
13010: ST_TO_ADDR
13011: GO 14382
13013: LD_INT 13
13015: DOUBLE
13016: EQUAL
13017: IFTRUE 13021
13019: GO 13217
13021: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13022: LD_ADDR_VAR 0 1
13026: PUSH
13027: LD_INT 1
13029: PUSH
13030: LD_INT 2
13032: PUSH
13033: LD_INT 3
13035: PUSH
13036: LD_INT 4
13038: PUSH
13039: LD_INT 5
13041: PUSH
13042: LD_INT 8
13044: PUSH
13045: LD_INT 9
13047: PUSH
13048: LD_INT 10
13050: PUSH
13051: LD_INT 11
13053: PUSH
13054: LD_INT 12
13056: PUSH
13057: LD_INT 14
13059: PUSH
13060: LD_INT 15
13062: PUSH
13063: LD_INT 16
13065: PUSH
13066: LD_INT 17
13068: PUSH
13069: LD_INT 18
13071: PUSH
13072: LD_INT 19
13074: PUSH
13075: LD_INT 20
13077: PUSH
13078: LD_INT 21
13080: PUSH
13081: LD_INT 22
13083: PUSH
13084: LD_INT 23
13086: PUSH
13087: LD_INT 24
13089: PUSH
13090: LD_INT 25
13092: PUSH
13093: LD_INT 26
13095: PUSH
13096: LD_INT 27
13098: PUSH
13099: LD_INT 28
13101: PUSH
13102: LD_INT 30
13104: PUSH
13105: LD_INT 31
13107: PUSH
13108: LD_INT 32
13110: PUSH
13111: LD_INT 33
13113: PUSH
13114: LD_INT 34
13116: PUSH
13117: LD_INT 36
13119: PUSH
13120: EMPTY
13121: LIST
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: LIST
13127: LIST
13128: LIST
13129: LIST
13130: LIST
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: LIST
13136: LIST
13137: LIST
13138: LIST
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: LIST
13152: PUSH
13153: LD_INT 101
13155: PUSH
13156: LD_INT 102
13158: PUSH
13159: LD_INT 103
13161: PUSH
13162: LD_INT 104
13164: PUSH
13165: LD_INT 105
13167: PUSH
13168: LD_INT 106
13170: PUSH
13171: LD_INT 107
13173: PUSH
13174: LD_INT 108
13176: PUSH
13177: LD_INT 109
13179: PUSH
13180: LD_INT 110
13182: PUSH
13183: LD_INT 111
13185: PUSH
13186: LD_INT 112
13188: PUSH
13189: LD_INT 113
13191: PUSH
13192: LD_INT 114
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: LIST
13208: LIST
13209: LIST
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: ST_TO_ADDR
13215: GO 14382
13217: LD_INT 14
13219: DOUBLE
13220: EQUAL
13221: IFTRUE 13225
13223: GO 13437
13225: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13226: LD_ADDR_VAR 0 1
13230: PUSH
13231: LD_INT 1
13233: PUSH
13234: LD_INT 2
13236: PUSH
13237: LD_INT 3
13239: PUSH
13240: LD_INT 4
13242: PUSH
13243: LD_INT 5
13245: PUSH
13246: LD_INT 6
13248: PUSH
13249: LD_INT 7
13251: PUSH
13252: LD_INT 8
13254: PUSH
13255: LD_INT 9
13257: PUSH
13258: LD_INT 10
13260: PUSH
13261: LD_INT 11
13263: PUSH
13264: LD_INT 12
13266: PUSH
13267: LD_INT 13
13269: PUSH
13270: LD_INT 14
13272: PUSH
13273: LD_INT 15
13275: PUSH
13276: LD_INT 16
13278: PUSH
13279: LD_INT 17
13281: PUSH
13282: LD_INT 18
13284: PUSH
13285: LD_INT 19
13287: PUSH
13288: LD_INT 20
13290: PUSH
13291: LD_INT 21
13293: PUSH
13294: LD_INT 22
13296: PUSH
13297: LD_INT 23
13299: PUSH
13300: LD_INT 24
13302: PUSH
13303: LD_INT 25
13305: PUSH
13306: LD_INT 26
13308: PUSH
13309: LD_INT 27
13311: PUSH
13312: LD_INT 28
13314: PUSH
13315: LD_INT 29
13317: PUSH
13318: LD_INT 30
13320: PUSH
13321: LD_INT 31
13323: PUSH
13324: LD_INT 32
13326: PUSH
13327: LD_INT 33
13329: PUSH
13330: LD_INT 34
13332: PUSH
13333: LD_INT 36
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: LIST
13342: LIST
13343: LIST
13344: LIST
13345: LIST
13346: LIST
13347: LIST
13348: LIST
13349: LIST
13350: LIST
13351: LIST
13352: LIST
13353: LIST
13354: LIST
13355: LIST
13356: LIST
13357: LIST
13358: LIST
13359: LIST
13360: LIST
13361: LIST
13362: LIST
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: PUSH
13373: LD_INT 101
13375: PUSH
13376: LD_INT 102
13378: PUSH
13379: LD_INT 103
13381: PUSH
13382: LD_INT 104
13384: PUSH
13385: LD_INT 105
13387: PUSH
13388: LD_INT 106
13390: PUSH
13391: LD_INT 107
13393: PUSH
13394: LD_INT 108
13396: PUSH
13397: LD_INT 109
13399: PUSH
13400: LD_INT 110
13402: PUSH
13403: LD_INT 111
13405: PUSH
13406: LD_INT 112
13408: PUSH
13409: LD_INT 113
13411: PUSH
13412: LD_INT 114
13414: PUSH
13415: EMPTY
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: LIST
13428: LIST
13429: LIST
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: ST_TO_ADDR
13435: GO 14382
13437: LD_INT 15
13439: DOUBLE
13440: EQUAL
13441: IFTRUE 13445
13443: GO 13657
13445: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13446: LD_ADDR_VAR 0 1
13450: PUSH
13451: LD_INT 1
13453: PUSH
13454: LD_INT 2
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: LD_INT 4
13462: PUSH
13463: LD_INT 5
13465: PUSH
13466: LD_INT 6
13468: PUSH
13469: LD_INT 7
13471: PUSH
13472: LD_INT 8
13474: PUSH
13475: LD_INT 9
13477: PUSH
13478: LD_INT 10
13480: PUSH
13481: LD_INT 11
13483: PUSH
13484: LD_INT 12
13486: PUSH
13487: LD_INT 13
13489: PUSH
13490: LD_INT 14
13492: PUSH
13493: LD_INT 15
13495: PUSH
13496: LD_INT 16
13498: PUSH
13499: LD_INT 17
13501: PUSH
13502: LD_INT 18
13504: PUSH
13505: LD_INT 19
13507: PUSH
13508: LD_INT 20
13510: PUSH
13511: LD_INT 21
13513: PUSH
13514: LD_INT 22
13516: PUSH
13517: LD_INT 23
13519: PUSH
13520: LD_INT 24
13522: PUSH
13523: LD_INT 25
13525: PUSH
13526: LD_INT 26
13528: PUSH
13529: LD_INT 27
13531: PUSH
13532: LD_INT 28
13534: PUSH
13535: LD_INT 29
13537: PUSH
13538: LD_INT 30
13540: PUSH
13541: LD_INT 31
13543: PUSH
13544: LD_INT 32
13546: PUSH
13547: LD_INT 33
13549: PUSH
13550: LD_INT 34
13552: PUSH
13553: LD_INT 36
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: LIST
13560: LIST
13561: LIST
13562: LIST
13563: LIST
13564: LIST
13565: LIST
13566: LIST
13567: LIST
13568: LIST
13569: LIST
13570: LIST
13571: LIST
13572: LIST
13573: LIST
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: PUSH
13593: LD_INT 101
13595: PUSH
13596: LD_INT 102
13598: PUSH
13599: LD_INT 103
13601: PUSH
13602: LD_INT 104
13604: PUSH
13605: LD_INT 105
13607: PUSH
13608: LD_INT 106
13610: PUSH
13611: LD_INT 107
13613: PUSH
13614: LD_INT 108
13616: PUSH
13617: LD_INT 109
13619: PUSH
13620: LD_INT 110
13622: PUSH
13623: LD_INT 111
13625: PUSH
13626: LD_INT 112
13628: PUSH
13629: LD_INT 113
13631: PUSH
13632: LD_INT 114
13634: PUSH
13635: EMPTY
13636: LIST
13637: LIST
13638: LIST
13639: LIST
13640: LIST
13641: LIST
13642: LIST
13643: LIST
13644: LIST
13645: LIST
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: ST_TO_ADDR
13655: GO 14382
13657: LD_INT 16
13659: DOUBLE
13660: EQUAL
13661: IFTRUE 13665
13663: GO 13789
13665: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13666: LD_ADDR_VAR 0 1
13670: PUSH
13671: LD_INT 2
13673: PUSH
13674: LD_INT 4
13676: PUSH
13677: LD_INT 5
13679: PUSH
13680: LD_INT 7
13682: PUSH
13683: LD_INT 11
13685: PUSH
13686: LD_INT 12
13688: PUSH
13689: LD_INT 15
13691: PUSH
13692: LD_INT 16
13694: PUSH
13695: LD_INT 20
13697: PUSH
13698: LD_INT 21
13700: PUSH
13701: LD_INT 22
13703: PUSH
13704: LD_INT 23
13706: PUSH
13707: LD_INT 25
13709: PUSH
13710: LD_INT 26
13712: PUSH
13713: LD_INT 30
13715: PUSH
13716: LD_INT 31
13718: PUSH
13719: LD_INT 32
13721: PUSH
13722: LD_INT 33
13724: PUSH
13725: LD_INT 34
13727: PUSH
13728: EMPTY
13729: LIST
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: LIST
13735: LIST
13736: LIST
13737: LIST
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: PUSH
13749: LD_INT 101
13751: PUSH
13752: LD_INT 102
13754: PUSH
13755: LD_INT 103
13757: PUSH
13758: LD_INT 106
13760: PUSH
13761: LD_INT 108
13763: PUSH
13764: LD_INT 112
13766: PUSH
13767: LD_INT 113
13769: PUSH
13770: LD_INT 114
13772: PUSH
13773: EMPTY
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: LIST
13779: LIST
13780: LIST
13781: LIST
13782: PUSH
13783: EMPTY
13784: LIST
13785: LIST
13786: ST_TO_ADDR
13787: GO 14382
13789: LD_INT 17
13791: DOUBLE
13792: EQUAL
13793: IFTRUE 13797
13795: GO 14009
13797: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
13798: LD_ADDR_VAR 0 1
13802: PUSH
13803: LD_INT 1
13805: PUSH
13806: LD_INT 2
13808: PUSH
13809: LD_INT 3
13811: PUSH
13812: LD_INT 4
13814: PUSH
13815: LD_INT 5
13817: PUSH
13818: LD_INT 6
13820: PUSH
13821: LD_INT 7
13823: PUSH
13824: LD_INT 8
13826: PUSH
13827: LD_INT 9
13829: PUSH
13830: LD_INT 10
13832: PUSH
13833: LD_INT 11
13835: PUSH
13836: LD_INT 12
13838: PUSH
13839: LD_INT 13
13841: PUSH
13842: LD_INT 14
13844: PUSH
13845: LD_INT 15
13847: PUSH
13848: LD_INT 16
13850: PUSH
13851: LD_INT 17
13853: PUSH
13854: LD_INT 18
13856: PUSH
13857: LD_INT 19
13859: PUSH
13860: LD_INT 20
13862: PUSH
13863: LD_INT 21
13865: PUSH
13866: LD_INT 22
13868: PUSH
13869: LD_INT 23
13871: PUSH
13872: LD_INT 24
13874: PUSH
13875: LD_INT 25
13877: PUSH
13878: LD_INT 26
13880: PUSH
13881: LD_INT 27
13883: PUSH
13884: LD_INT 28
13886: PUSH
13887: LD_INT 29
13889: PUSH
13890: LD_INT 30
13892: PUSH
13893: LD_INT 31
13895: PUSH
13896: LD_INT 32
13898: PUSH
13899: LD_INT 33
13901: PUSH
13902: LD_INT 34
13904: PUSH
13905: LD_INT 36
13907: PUSH
13908: EMPTY
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: PUSH
13945: LD_INT 101
13947: PUSH
13948: LD_INT 102
13950: PUSH
13951: LD_INT 103
13953: PUSH
13954: LD_INT 104
13956: PUSH
13957: LD_INT 105
13959: PUSH
13960: LD_INT 106
13962: PUSH
13963: LD_INT 107
13965: PUSH
13966: LD_INT 108
13968: PUSH
13969: LD_INT 109
13971: PUSH
13972: LD_INT 110
13974: PUSH
13975: LD_INT 111
13977: PUSH
13978: LD_INT 112
13980: PUSH
13981: LD_INT 113
13983: PUSH
13984: LD_INT 114
13986: PUSH
13987: EMPTY
13988: LIST
13989: LIST
13990: LIST
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: LIST
14001: LIST
14002: PUSH
14003: EMPTY
14004: LIST
14005: LIST
14006: ST_TO_ADDR
14007: GO 14382
14009: LD_INT 18
14011: DOUBLE
14012: EQUAL
14013: IFTRUE 14017
14015: GO 14153
14017: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14018: LD_ADDR_VAR 0 1
14022: PUSH
14023: LD_INT 2
14025: PUSH
14026: LD_INT 4
14028: PUSH
14029: LD_INT 5
14031: PUSH
14032: LD_INT 7
14034: PUSH
14035: LD_INT 11
14037: PUSH
14038: LD_INT 12
14040: PUSH
14041: LD_INT 15
14043: PUSH
14044: LD_INT 16
14046: PUSH
14047: LD_INT 20
14049: PUSH
14050: LD_INT 21
14052: PUSH
14053: LD_INT 22
14055: PUSH
14056: LD_INT 23
14058: PUSH
14059: LD_INT 25
14061: PUSH
14062: LD_INT 26
14064: PUSH
14065: LD_INT 30
14067: PUSH
14068: LD_INT 31
14070: PUSH
14071: LD_INT 32
14073: PUSH
14074: LD_INT 33
14076: PUSH
14077: LD_INT 34
14079: PUSH
14080: LD_INT 35
14082: PUSH
14083: LD_INT 36
14085: PUSH
14086: EMPTY
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: PUSH
14109: LD_INT 101
14111: PUSH
14112: LD_INT 102
14114: PUSH
14115: LD_INT 103
14117: PUSH
14118: LD_INT 106
14120: PUSH
14121: LD_INT 108
14123: PUSH
14124: LD_INT 112
14126: PUSH
14127: LD_INT 113
14129: PUSH
14130: LD_INT 114
14132: PUSH
14133: LD_INT 115
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: ST_TO_ADDR
14151: GO 14382
14153: LD_INT 19
14155: DOUBLE
14156: EQUAL
14157: IFTRUE 14161
14159: GO 14381
14161: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14162: LD_ADDR_VAR 0 1
14166: PUSH
14167: LD_INT 1
14169: PUSH
14170: LD_INT 2
14172: PUSH
14173: LD_INT 3
14175: PUSH
14176: LD_INT 4
14178: PUSH
14179: LD_INT 5
14181: PUSH
14182: LD_INT 6
14184: PUSH
14185: LD_INT 7
14187: PUSH
14188: LD_INT 8
14190: PUSH
14191: LD_INT 9
14193: PUSH
14194: LD_INT 10
14196: PUSH
14197: LD_INT 11
14199: PUSH
14200: LD_INT 12
14202: PUSH
14203: LD_INT 13
14205: PUSH
14206: LD_INT 14
14208: PUSH
14209: LD_INT 15
14211: PUSH
14212: LD_INT 16
14214: PUSH
14215: LD_INT 17
14217: PUSH
14218: LD_INT 18
14220: PUSH
14221: LD_INT 19
14223: PUSH
14224: LD_INT 20
14226: PUSH
14227: LD_INT 21
14229: PUSH
14230: LD_INT 22
14232: PUSH
14233: LD_INT 23
14235: PUSH
14236: LD_INT 24
14238: PUSH
14239: LD_INT 25
14241: PUSH
14242: LD_INT 26
14244: PUSH
14245: LD_INT 27
14247: PUSH
14248: LD_INT 28
14250: PUSH
14251: LD_INT 29
14253: PUSH
14254: LD_INT 30
14256: PUSH
14257: LD_INT 31
14259: PUSH
14260: LD_INT 32
14262: PUSH
14263: LD_INT 33
14265: PUSH
14266: LD_INT 34
14268: PUSH
14269: LD_INT 35
14271: PUSH
14272: LD_INT 36
14274: PUSH
14275: EMPTY
14276: LIST
14277: LIST
14278: LIST
14279: LIST
14280: LIST
14281: LIST
14282: LIST
14283: LIST
14284: LIST
14285: LIST
14286: LIST
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: LIST
14308: LIST
14309: LIST
14310: LIST
14311: LIST
14312: PUSH
14313: LD_INT 101
14315: PUSH
14316: LD_INT 102
14318: PUSH
14319: LD_INT 103
14321: PUSH
14322: LD_INT 104
14324: PUSH
14325: LD_INT 105
14327: PUSH
14328: LD_INT 106
14330: PUSH
14331: LD_INT 107
14333: PUSH
14334: LD_INT 108
14336: PUSH
14337: LD_INT 109
14339: PUSH
14340: LD_INT 110
14342: PUSH
14343: LD_INT 111
14345: PUSH
14346: LD_INT 112
14348: PUSH
14349: LD_INT 113
14351: PUSH
14352: LD_INT 114
14354: PUSH
14355: LD_INT 115
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: ST_TO_ADDR
14379: GO 14382
14381: POP
// end else
14382: GO 14419
// if campaign_id = 5 then
14384: LD_OWVAR 69
14388: PUSH
14389: LD_INT 5
14391: EQUAL
14392: IFFALSE 14419
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
14394: LD_ADDR_VAR 0 1
14398: PUSH
14399: LD_INT 1
14401: PUSH
14402: LD_INT 2
14404: PUSH
14405: EMPTY
14406: LIST
14407: LIST
14408: PUSH
14409: LD_INT 100
14411: PUSH
14412: EMPTY
14413: LIST
14414: PUSH
14415: EMPTY
14416: LIST
14417: LIST
14418: ST_TO_ADDR
// end ; if result then
14419: LD_VAR 0 1
14423: IFFALSE 14712
// begin normal :=  ;
14425: LD_ADDR_VAR 0 3
14429: PUSH
14430: LD_STRING 
14432: ST_TO_ADDR
// hardcore :=  ;
14433: LD_ADDR_VAR 0 4
14437: PUSH
14438: LD_STRING 
14440: ST_TO_ADDR
// for i = 1 to normalCounter do
14441: LD_ADDR_VAR 0 5
14445: PUSH
14446: DOUBLE
14447: LD_INT 1
14449: DEC
14450: ST_TO_ADDR
14451: LD_EXP 44
14455: PUSH
14456: FOR_TO
14457: IFFALSE 14558
// begin tmp := 0 ;
14459: LD_ADDR_VAR 0 2
14463: PUSH
14464: LD_STRING 0
14466: ST_TO_ADDR
// if result [ 1 ] then
14467: LD_VAR 0 1
14471: PUSH
14472: LD_INT 1
14474: ARRAY
14475: IFFALSE 14540
// if result [ 1 ] [ 1 ] = i then
14477: LD_VAR 0 1
14481: PUSH
14482: LD_INT 1
14484: ARRAY
14485: PUSH
14486: LD_INT 1
14488: ARRAY
14489: PUSH
14490: LD_VAR 0 5
14494: EQUAL
14495: IFFALSE 14540
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
14497: LD_ADDR_VAR 0 1
14501: PUSH
14502: LD_VAR 0 1
14506: PPUSH
14507: LD_INT 1
14509: PPUSH
14510: LD_VAR 0 1
14514: PUSH
14515: LD_INT 1
14517: ARRAY
14518: PPUSH
14519: LD_INT 1
14521: PPUSH
14522: CALL_OW 3
14526: PPUSH
14527: CALL_OW 1
14531: ST_TO_ADDR
// tmp := 1 ;
14532: LD_ADDR_VAR 0 2
14536: PUSH
14537: LD_STRING 1
14539: ST_TO_ADDR
// end ; normal := normal & tmp ;
14540: LD_ADDR_VAR 0 3
14544: PUSH
14545: LD_VAR 0 3
14549: PUSH
14550: LD_VAR 0 2
14554: STR
14555: ST_TO_ADDR
// end ;
14556: GO 14456
14558: POP
14559: POP
// for i = 1 to hardcoreCounter do
14560: LD_ADDR_VAR 0 5
14564: PUSH
14565: DOUBLE
14566: LD_INT 1
14568: DEC
14569: ST_TO_ADDR
14570: LD_EXP 45
14574: PUSH
14575: FOR_TO
14576: IFFALSE 14681
// begin tmp := 0 ;
14578: LD_ADDR_VAR 0 2
14582: PUSH
14583: LD_STRING 0
14585: ST_TO_ADDR
// if result [ 2 ] then
14586: LD_VAR 0 1
14590: PUSH
14591: LD_INT 2
14593: ARRAY
14594: IFFALSE 14663
// if result [ 2 ] [ 1 ] = 100 + i then
14596: LD_VAR 0 1
14600: PUSH
14601: LD_INT 2
14603: ARRAY
14604: PUSH
14605: LD_INT 1
14607: ARRAY
14608: PUSH
14609: LD_INT 100
14611: PUSH
14612: LD_VAR 0 5
14616: PLUS
14617: EQUAL
14618: IFFALSE 14663
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
14620: LD_ADDR_VAR 0 1
14624: PUSH
14625: LD_VAR 0 1
14629: PPUSH
14630: LD_INT 2
14632: PPUSH
14633: LD_VAR 0 1
14637: PUSH
14638: LD_INT 2
14640: ARRAY
14641: PPUSH
14642: LD_INT 1
14644: PPUSH
14645: CALL_OW 3
14649: PPUSH
14650: CALL_OW 1
14654: ST_TO_ADDR
// tmp := 1 ;
14655: LD_ADDR_VAR 0 2
14659: PUSH
14660: LD_STRING 1
14662: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
14663: LD_ADDR_VAR 0 4
14667: PUSH
14668: LD_VAR 0 4
14672: PUSH
14673: LD_VAR 0 2
14677: STR
14678: ST_TO_ADDR
// end ;
14679: GO 14575
14681: POP
14682: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
14683: LD_STRING getStreamItemsFromMission("
14685: PUSH
14686: LD_VAR 0 3
14690: STR
14691: PUSH
14692: LD_STRING ","
14694: STR
14695: PUSH
14696: LD_VAR 0 4
14700: STR
14701: PUSH
14702: LD_STRING ")
14704: STR
14705: PPUSH
14706: CALL_OW 559
// end else
14710: GO 14719
// ToLua ( getStreamItemsFromMission("","") ) ;
14712: LD_STRING getStreamItemsFromMission("","")
14714: PPUSH
14715: CALL_OW 559
// end ;
14719: LD_VAR 0 1
14723: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
14724: LD_VAR 0 2
14728: PUSH
14729: LD_INT 100
14731: EQUAL
14732: IFFALSE 15681
// begin if not StreamModeActive then
14734: LD_EXP 43
14738: NOT
14739: IFFALSE 14749
// StreamModeActive := true ;
14741: LD_ADDR_EXP 43
14745: PUSH
14746: LD_INT 1
14748: ST_TO_ADDR
// if p3 = 0 then
14749: LD_VAR 0 3
14753: PUSH
14754: LD_INT 0
14756: EQUAL
14757: IFFALSE 14763
// InitStreamMode ;
14759: CALL 10984 0 0
// if p3 = 1 then
14763: LD_VAR 0 3
14767: PUSH
14768: LD_INT 1
14770: EQUAL
14771: IFFALSE 14781
// sRocket := true ;
14773: LD_ADDR_EXP 48
14777: PUSH
14778: LD_INT 1
14780: ST_TO_ADDR
// if p3 = 2 then
14781: LD_VAR 0 3
14785: PUSH
14786: LD_INT 2
14788: EQUAL
14789: IFFALSE 14799
// sSpeed := true ;
14791: LD_ADDR_EXP 47
14795: PUSH
14796: LD_INT 1
14798: ST_TO_ADDR
// if p3 = 3 then
14799: LD_VAR 0 3
14803: PUSH
14804: LD_INT 3
14806: EQUAL
14807: IFFALSE 14817
// sEngine := true ;
14809: LD_ADDR_EXP 49
14813: PUSH
14814: LD_INT 1
14816: ST_TO_ADDR
// if p3 = 4 then
14817: LD_VAR 0 3
14821: PUSH
14822: LD_INT 4
14824: EQUAL
14825: IFFALSE 14835
// sSpec := true ;
14827: LD_ADDR_EXP 46
14831: PUSH
14832: LD_INT 1
14834: ST_TO_ADDR
// if p3 = 5 then
14835: LD_VAR 0 3
14839: PUSH
14840: LD_INT 5
14842: EQUAL
14843: IFFALSE 14853
// sLevel := true ;
14845: LD_ADDR_EXP 50
14849: PUSH
14850: LD_INT 1
14852: ST_TO_ADDR
// if p3 = 6 then
14853: LD_VAR 0 3
14857: PUSH
14858: LD_INT 6
14860: EQUAL
14861: IFFALSE 14871
// sArmoury := true ;
14863: LD_ADDR_EXP 51
14867: PUSH
14868: LD_INT 1
14870: ST_TO_ADDR
// if p3 = 7 then
14871: LD_VAR 0 3
14875: PUSH
14876: LD_INT 7
14878: EQUAL
14879: IFFALSE 14889
// sRadar := true ;
14881: LD_ADDR_EXP 52
14885: PUSH
14886: LD_INT 1
14888: ST_TO_ADDR
// if p3 = 8 then
14889: LD_VAR 0 3
14893: PUSH
14894: LD_INT 8
14896: EQUAL
14897: IFFALSE 14907
// sBunker := true ;
14899: LD_ADDR_EXP 53
14903: PUSH
14904: LD_INT 1
14906: ST_TO_ADDR
// if p3 = 9 then
14907: LD_VAR 0 3
14911: PUSH
14912: LD_INT 9
14914: EQUAL
14915: IFFALSE 14925
// sHack := true ;
14917: LD_ADDR_EXP 54
14921: PUSH
14922: LD_INT 1
14924: ST_TO_ADDR
// if p3 = 10 then
14925: LD_VAR 0 3
14929: PUSH
14930: LD_INT 10
14932: EQUAL
14933: IFFALSE 14943
// sFire := true ;
14935: LD_ADDR_EXP 55
14939: PUSH
14940: LD_INT 1
14942: ST_TO_ADDR
// if p3 = 11 then
14943: LD_VAR 0 3
14947: PUSH
14948: LD_INT 11
14950: EQUAL
14951: IFFALSE 14961
// sRefresh := true ;
14953: LD_ADDR_EXP 56
14957: PUSH
14958: LD_INT 1
14960: ST_TO_ADDR
// if p3 = 12 then
14961: LD_VAR 0 3
14965: PUSH
14966: LD_INT 12
14968: EQUAL
14969: IFFALSE 14979
// sExp := true ;
14971: LD_ADDR_EXP 57
14975: PUSH
14976: LD_INT 1
14978: ST_TO_ADDR
// if p3 = 13 then
14979: LD_VAR 0 3
14983: PUSH
14984: LD_INT 13
14986: EQUAL
14987: IFFALSE 14997
// sDepot := true ;
14989: LD_ADDR_EXP 58
14993: PUSH
14994: LD_INT 1
14996: ST_TO_ADDR
// if p3 = 14 then
14997: LD_VAR 0 3
15001: PUSH
15002: LD_INT 14
15004: EQUAL
15005: IFFALSE 15015
// sFlag := true ;
15007: LD_ADDR_EXP 59
15011: PUSH
15012: LD_INT 1
15014: ST_TO_ADDR
// if p3 = 15 then
15015: LD_VAR 0 3
15019: PUSH
15020: LD_INT 15
15022: EQUAL
15023: IFFALSE 15033
// sKamikadze := true ;
15025: LD_ADDR_EXP 67
15029: PUSH
15030: LD_INT 1
15032: ST_TO_ADDR
// if p3 = 16 then
15033: LD_VAR 0 3
15037: PUSH
15038: LD_INT 16
15040: EQUAL
15041: IFFALSE 15051
// sTroll := true ;
15043: LD_ADDR_EXP 68
15047: PUSH
15048: LD_INT 1
15050: ST_TO_ADDR
// if p3 = 17 then
15051: LD_VAR 0 3
15055: PUSH
15056: LD_INT 17
15058: EQUAL
15059: IFFALSE 15069
// sSlow := true ;
15061: LD_ADDR_EXP 69
15065: PUSH
15066: LD_INT 1
15068: ST_TO_ADDR
// if p3 = 18 then
15069: LD_VAR 0 3
15073: PUSH
15074: LD_INT 18
15076: EQUAL
15077: IFFALSE 15087
// sLack := true ;
15079: LD_ADDR_EXP 70
15083: PUSH
15084: LD_INT 1
15086: ST_TO_ADDR
// if p3 = 19 then
15087: LD_VAR 0 3
15091: PUSH
15092: LD_INT 19
15094: EQUAL
15095: IFFALSE 15105
// sTank := true ;
15097: LD_ADDR_EXP 72
15101: PUSH
15102: LD_INT 1
15104: ST_TO_ADDR
// if p3 = 20 then
15105: LD_VAR 0 3
15109: PUSH
15110: LD_INT 20
15112: EQUAL
15113: IFFALSE 15123
// sRemote := true ;
15115: LD_ADDR_EXP 73
15119: PUSH
15120: LD_INT 1
15122: ST_TO_ADDR
// if p3 = 21 then
15123: LD_VAR 0 3
15127: PUSH
15128: LD_INT 21
15130: EQUAL
15131: IFFALSE 15141
// sPowell := true ;
15133: LD_ADDR_EXP 74
15137: PUSH
15138: LD_INT 1
15140: ST_TO_ADDR
// if p3 = 22 then
15141: LD_VAR 0 3
15145: PUSH
15146: LD_INT 22
15148: EQUAL
15149: IFFALSE 15159
// sTeleport := true ;
15151: LD_ADDR_EXP 77
15155: PUSH
15156: LD_INT 1
15158: ST_TO_ADDR
// if p3 = 23 then
15159: LD_VAR 0 3
15163: PUSH
15164: LD_INT 23
15166: EQUAL
15167: IFFALSE 15177
// sOilTower := true ;
15169: LD_ADDR_EXP 79
15173: PUSH
15174: LD_INT 1
15176: ST_TO_ADDR
// if p3 = 24 then
15177: LD_VAR 0 3
15181: PUSH
15182: LD_INT 24
15184: EQUAL
15185: IFFALSE 15195
// sShovel := true ;
15187: LD_ADDR_EXP 80
15191: PUSH
15192: LD_INT 1
15194: ST_TO_ADDR
// if p3 = 25 then
15195: LD_VAR 0 3
15199: PUSH
15200: LD_INT 25
15202: EQUAL
15203: IFFALSE 15213
// sSheik := true ;
15205: LD_ADDR_EXP 81
15209: PUSH
15210: LD_INT 1
15212: ST_TO_ADDR
// if p3 = 26 then
15213: LD_VAR 0 3
15217: PUSH
15218: LD_INT 26
15220: EQUAL
15221: IFFALSE 15231
// sEarthquake := true ;
15223: LD_ADDR_EXP 83
15227: PUSH
15228: LD_INT 1
15230: ST_TO_ADDR
// if p3 = 27 then
15231: LD_VAR 0 3
15235: PUSH
15236: LD_INT 27
15238: EQUAL
15239: IFFALSE 15249
// sAI := true ;
15241: LD_ADDR_EXP 84
15245: PUSH
15246: LD_INT 1
15248: ST_TO_ADDR
// if p3 = 28 then
15249: LD_VAR 0 3
15253: PUSH
15254: LD_INT 28
15256: EQUAL
15257: IFFALSE 15267
// sCargo := true ;
15259: LD_ADDR_EXP 87
15263: PUSH
15264: LD_INT 1
15266: ST_TO_ADDR
// if p3 = 29 then
15267: LD_VAR 0 3
15271: PUSH
15272: LD_INT 29
15274: EQUAL
15275: IFFALSE 15285
// sDLaser := true ;
15277: LD_ADDR_EXP 88
15281: PUSH
15282: LD_INT 1
15284: ST_TO_ADDR
// if p3 = 30 then
15285: LD_VAR 0 3
15289: PUSH
15290: LD_INT 30
15292: EQUAL
15293: IFFALSE 15303
// sExchange := true ;
15295: LD_ADDR_EXP 89
15299: PUSH
15300: LD_INT 1
15302: ST_TO_ADDR
// if p3 = 31 then
15303: LD_VAR 0 3
15307: PUSH
15308: LD_INT 31
15310: EQUAL
15311: IFFALSE 15321
// sFac := true ;
15313: LD_ADDR_EXP 90
15317: PUSH
15318: LD_INT 1
15320: ST_TO_ADDR
// if p3 = 32 then
15321: LD_VAR 0 3
15325: PUSH
15326: LD_INT 32
15328: EQUAL
15329: IFFALSE 15339
// sPower := true ;
15331: LD_ADDR_EXP 91
15335: PUSH
15336: LD_INT 1
15338: ST_TO_ADDR
// if p3 = 33 then
15339: LD_VAR 0 3
15343: PUSH
15344: LD_INT 33
15346: EQUAL
15347: IFFALSE 15357
// sRandom := true ;
15349: LD_ADDR_EXP 92
15353: PUSH
15354: LD_INT 1
15356: ST_TO_ADDR
// if p3 = 34 then
15357: LD_VAR 0 3
15361: PUSH
15362: LD_INT 34
15364: EQUAL
15365: IFFALSE 15375
// sShield := true ;
15367: LD_ADDR_EXP 93
15371: PUSH
15372: LD_INT 1
15374: ST_TO_ADDR
// if p3 = 35 then
15375: LD_VAR 0 3
15379: PUSH
15380: LD_INT 35
15382: EQUAL
15383: IFFALSE 15393
// sTime := true ;
15385: LD_ADDR_EXP 94
15389: PUSH
15390: LD_INT 1
15392: ST_TO_ADDR
// if p3 = 36 then
15393: LD_VAR 0 3
15397: PUSH
15398: LD_INT 36
15400: EQUAL
15401: IFFALSE 15411
// sTools := true ;
15403: LD_ADDR_EXP 95
15407: PUSH
15408: LD_INT 1
15410: ST_TO_ADDR
// if p3 = 101 then
15411: LD_VAR 0 3
15415: PUSH
15416: LD_INT 101
15418: EQUAL
15419: IFFALSE 15429
// sSold := true ;
15421: LD_ADDR_EXP 60
15425: PUSH
15426: LD_INT 1
15428: ST_TO_ADDR
// if p3 = 102 then
15429: LD_VAR 0 3
15433: PUSH
15434: LD_INT 102
15436: EQUAL
15437: IFFALSE 15447
// sDiff := true ;
15439: LD_ADDR_EXP 61
15443: PUSH
15444: LD_INT 1
15446: ST_TO_ADDR
// if p3 = 103 then
15447: LD_VAR 0 3
15451: PUSH
15452: LD_INT 103
15454: EQUAL
15455: IFFALSE 15465
// sFog := true ;
15457: LD_ADDR_EXP 64
15461: PUSH
15462: LD_INT 1
15464: ST_TO_ADDR
// if p3 = 104 then
15465: LD_VAR 0 3
15469: PUSH
15470: LD_INT 104
15472: EQUAL
15473: IFFALSE 15483
// sReset := true ;
15475: LD_ADDR_EXP 65
15479: PUSH
15480: LD_INT 1
15482: ST_TO_ADDR
// if p3 = 105 then
15483: LD_VAR 0 3
15487: PUSH
15488: LD_INT 105
15490: EQUAL
15491: IFFALSE 15501
// sSun := true ;
15493: LD_ADDR_EXP 66
15497: PUSH
15498: LD_INT 1
15500: ST_TO_ADDR
// if p3 = 106 then
15501: LD_VAR 0 3
15505: PUSH
15506: LD_INT 106
15508: EQUAL
15509: IFFALSE 15519
// sTiger := true ;
15511: LD_ADDR_EXP 62
15515: PUSH
15516: LD_INT 1
15518: ST_TO_ADDR
// if p3 = 107 then
15519: LD_VAR 0 3
15523: PUSH
15524: LD_INT 107
15526: EQUAL
15527: IFFALSE 15537
// sBomb := true ;
15529: LD_ADDR_EXP 63
15533: PUSH
15534: LD_INT 1
15536: ST_TO_ADDR
// if p3 = 108 then
15537: LD_VAR 0 3
15541: PUSH
15542: LD_INT 108
15544: EQUAL
15545: IFFALSE 15555
// sWound := true ;
15547: LD_ADDR_EXP 71
15551: PUSH
15552: LD_INT 1
15554: ST_TO_ADDR
// if p3 = 109 then
15555: LD_VAR 0 3
15559: PUSH
15560: LD_INT 109
15562: EQUAL
15563: IFFALSE 15573
// sBetray := true ;
15565: LD_ADDR_EXP 75
15569: PUSH
15570: LD_INT 1
15572: ST_TO_ADDR
// if p3 = 110 then
15573: LD_VAR 0 3
15577: PUSH
15578: LD_INT 110
15580: EQUAL
15581: IFFALSE 15591
// sContamin := true ;
15583: LD_ADDR_EXP 76
15587: PUSH
15588: LD_INT 1
15590: ST_TO_ADDR
// if p3 = 111 then
15591: LD_VAR 0 3
15595: PUSH
15596: LD_INT 111
15598: EQUAL
15599: IFFALSE 15609
// sOil := true ;
15601: LD_ADDR_EXP 78
15605: PUSH
15606: LD_INT 1
15608: ST_TO_ADDR
// if p3 = 112 then
15609: LD_VAR 0 3
15613: PUSH
15614: LD_INT 112
15616: EQUAL
15617: IFFALSE 15627
// sStu := true ;
15619: LD_ADDR_EXP 82
15623: PUSH
15624: LD_INT 1
15626: ST_TO_ADDR
// if p3 = 113 then
15627: LD_VAR 0 3
15631: PUSH
15632: LD_INT 113
15634: EQUAL
15635: IFFALSE 15645
// sBazooka := true ;
15637: LD_ADDR_EXP 85
15641: PUSH
15642: LD_INT 1
15644: ST_TO_ADDR
// if p3 = 114 then
15645: LD_VAR 0 3
15649: PUSH
15650: LD_INT 114
15652: EQUAL
15653: IFFALSE 15663
// sMortar := true ;
15655: LD_ADDR_EXP 86
15659: PUSH
15660: LD_INT 1
15662: ST_TO_ADDR
// if p3 = 115 then
15663: LD_VAR 0 3
15667: PUSH
15668: LD_INT 115
15670: EQUAL
15671: IFFALSE 15681
// sRanger := true ;
15673: LD_ADDR_EXP 96
15677: PUSH
15678: LD_INT 1
15680: ST_TO_ADDR
// end ; end ;
15681: PPOPN 6
15683: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
15684: LD_EXP 43
15688: PUSH
15689: LD_EXP 48
15693: AND
15694: IFFALSE 15818
15696: GO 15698
15698: DISABLE
15699: LD_INT 0
15701: PPUSH
15702: PPUSH
// begin enable ;
15703: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
15704: LD_ADDR_VAR 0 2
15708: PUSH
15709: LD_INT 22
15711: PUSH
15712: LD_OWVAR 2
15716: PUSH
15717: EMPTY
15718: LIST
15719: LIST
15720: PUSH
15721: LD_INT 2
15723: PUSH
15724: LD_INT 34
15726: PUSH
15727: LD_INT 7
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: PUSH
15734: LD_INT 34
15736: PUSH
15737: LD_INT 45
15739: PUSH
15740: EMPTY
15741: LIST
15742: LIST
15743: PUSH
15744: LD_INT 34
15746: PUSH
15747: LD_INT 28
15749: PUSH
15750: EMPTY
15751: LIST
15752: LIST
15753: PUSH
15754: LD_INT 34
15756: PUSH
15757: LD_INT 47
15759: PUSH
15760: EMPTY
15761: LIST
15762: LIST
15763: PUSH
15764: EMPTY
15765: LIST
15766: LIST
15767: LIST
15768: LIST
15769: LIST
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: PPUSH
15775: CALL_OW 69
15779: ST_TO_ADDR
// if not tmp then
15780: LD_VAR 0 2
15784: NOT
15785: IFFALSE 15789
// exit ;
15787: GO 15818
// for i in tmp do
15789: LD_ADDR_VAR 0 1
15793: PUSH
15794: LD_VAR 0 2
15798: PUSH
15799: FOR_IN
15800: IFFALSE 15816
// begin SetLives ( i , 0 ) ;
15802: LD_VAR 0 1
15806: PPUSH
15807: LD_INT 0
15809: PPUSH
15810: CALL_OW 234
// end ;
15814: GO 15799
15816: POP
15817: POP
// end ;
15818: PPOPN 2
15820: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
15821: LD_EXP 43
15825: PUSH
15826: LD_EXP 49
15830: AND
15831: IFFALSE 15915
15833: GO 15835
15835: DISABLE
15836: LD_INT 0
15838: PPUSH
15839: PPUSH
// begin enable ;
15840: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
15841: LD_ADDR_VAR 0 2
15845: PUSH
15846: LD_INT 22
15848: PUSH
15849: LD_OWVAR 2
15853: PUSH
15854: EMPTY
15855: LIST
15856: LIST
15857: PUSH
15858: LD_INT 32
15860: PUSH
15861: LD_INT 3
15863: PUSH
15864: EMPTY
15865: LIST
15866: LIST
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: PPUSH
15872: CALL_OW 69
15876: ST_TO_ADDR
// if not tmp then
15877: LD_VAR 0 2
15881: NOT
15882: IFFALSE 15886
// exit ;
15884: GO 15915
// for i in tmp do
15886: LD_ADDR_VAR 0 1
15890: PUSH
15891: LD_VAR 0 2
15895: PUSH
15896: FOR_IN
15897: IFFALSE 15913
// begin SetLives ( i , 0 ) ;
15899: LD_VAR 0 1
15903: PPUSH
15904: LD_INT 0
15906: PPUSH
15907: CALL_OW 234
// end ;
15911: GO 15896
15913: POP
15914: POP
// end ;
15915: PPOPN 2
15917: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
15918: LD_EXP 43
15922: PUSH
15923: LD_EXP 46
15927: AND
15928: IFFALSE 16021
15930: GO 15932
15932: DISABLE
15933: LD_INT 0
15935: PPUSH
// begin enable ;
15936: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
15937: LD_ADDR_VAR 0 1
15941: PUSH
15942: LD_INT 22
15944: PUSH
15945: LD_OWVAR 2
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: PUSH
15954: LD_INT 2
15956: PUSH
15957: LD_INT 25
15959: PUSH
15960: LD_INT 5
15962: PUSH
15963: EMPTY
15964: LIST
15965: LIST
15966: PUSH
15967: LD_INT 25
15969: PUSH
15970: LD_INT 9
15972: PUSH
15973: EMPTY
15974: LIST
15975: LIST
15976: PUSH
15977: LD_INT 25
15979: PUSH
15980: LD_INT 8
15982: PUSH
15983: EMPTY
15984: LIST
15985: LIST
15986: PUSH
15987: EMPTY
15988: LIST
15989: LIST
15990: LIST
15991: LIST
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: PPUSH
15997: CALL_OW 69
16001: PUSH
16002: FOR_IN
16003: IFFALSE 16019
// begin SetClass ( i , 1 ) ;
16005: LD_VAR 0 1
16009: PPUSH
16010: LD_INT 1
16012: PPUSH
16013: CALL_OW 336
// end ;
16017: GO 16002
16019: POP
16020: POP
// end ;
16021: PPOPN 1
16023: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16024: LD_EXP 43
16028: PUSH
16029: LD_EXP 47
16033: AND
16034: PUSH
16035: LD_OWVAR 65
16039: PUSH
16040: LD_INT 7
16042: LESS
16043: AND
16044: IFFALSE 16058
16046: GO 16048
16048: DISABLE
// begin enable ;
16049: ENABLE
// game_speed := 7 ;
16050: LD_ADDR_OWVAR 65
16054: PUSH
16055: LD_INT 7
16057: ST_TO_ADDR
// end ;
16058: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16059: LD_EXP 43
16063: PUSH
16064: LD_EXP 50
16068: AND
16069: IFFALSE 16271
16071: GO 16073
16073: DISABLE
16074: LD_INT 0
16076: PPUSH
16077: PPUSH
16078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16079: LD_ADDR_VAR 0 3
16083: PUSH
16084: LD_INT 81
16086: PUSH
16087: LD_OWVAR 2
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PUSH
16096: LD_INT 21
16098: PUSH
16099: LD_INT 1
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: PUSH
16106: EMPTY
16107: LIST
16108: LIST
16109: PPUSH
16110: CALL_OW 69
16114: ST_TO_ADDR
// if not tmp then
16115: LD_VAR 0 3
16119: NOT
16120: IFFALSE 16124
// exit ;
16122: GO 16271
// if tmp > 5 then
16124: LD_VAR 0 3
16128: PUSH
16129: LD_INT 5
16131: GREATER
16132: IFFALSE 16144
// k := 5 else
16134: LD_ADDR_VAR 0 2
16138: PUSH
16139: LD_INT 5
16141: ST_TO_ADDR
16142: GO 16154
// k := tmp ;
16144: LD_ADDR_VAR 0 2
16148: PUSH
16149: LD_VAR 0 3
16153: ST_TO_ADDR
// for i := 1 to k do
16154: LD_ADDR_VAR 0 1
16158: PUSH
16159: DOUBLE
16160: LD_INT 1
16162: DEC
16163: ST_TO_ADDR
16164: LD_VAR 0 2
16168: PUSH
16169: FOR_TO
16170: IFFALSE 16269
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
16172: LD_VAR 0 3
16176: PUSH
16177: LD_VAR 0 1
16181: ARRAY
16182: PPUSH
16183: LD_VAR 0 1
16187: PUSH
16188: LD_INT 4
16190: MOD
16191: PUSH
16192: LD_INT 1
16194: PLUS
16195: PPUSH
16196: CALL_OW 259
16200: PUSH
16201: LD_INT 10
16203: LESS
16204: IFFALSE 16267
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
16206: LD_VAR 0 3
16210: PUSH
16211: LD_VAR 0 1
16215: ARRAY
16216: PPUSH
16217: LD_VAR 0 1
16221: PUSH
16222: LD_INT 4
16224: MOD
16225: PUSH
16226: LD_INT 1
16228: PLUS
16229: PPUSH
16230: LD_VAR 0 3
16234: PUSH
16235: LD_VAR 0 1
16239: ARRAY
16240: PPUSH
16241: LD_VAR 0 1
16245: PUSH
16246: LD_INT 4
16248: MOD
16249: PUSH
16250: LD_INT 1
16252: PLUS
16253: PPUSH
16254: CALL_OW 259
16258: PUSH
16259: LD_INT 1
16261: PLUS
16262: PPUSH
16263: CALL_OW 237
16267: GO 16169
16269: POP
16270: POP
// end ;
16271: PPOPN 3
16273: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16274: LD_EXP 43
16278: PUSH
16279: LD_EXP 51
16283: AND
16284: IFFALSE 16304
16286: GO 16288
16288: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16289: LD_INT 4
16291: PPUSH
16292: LD_OWVAR 2
16296: PPUSH
16297: LD_INT 0
16299: PPUSH
16300: CALL_OW 324
16304: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16305: LD_EXP 43
16309: PUSH
16310: LD_EXP 80
16314: AND
16315: IFFALSE 16335
16317: GO 16319
16319: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16320: LD_INT 19
16322: PPUSH
16323: LD_OWVAR 2
16327: PPUSH
16328: LD_INT 0
16330: PPUSH
16331: CALL_OW 324
16335: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16336: LD_EXP 43
16340: PUSH
16341: LD_EXP 52
16345: AND
16346: IFFALSE 16448
16348: GO 16350
16350: DISABLE
16351: LD_INT 0
16353: PPUSH
16354: PPUSH
// begin enable ;
16355: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16356: LD_ADDR_VAR 0 2
16360: PUSH
16361: LD_INT 22
16363: PUSH
16364: LD_OWVAR 2
16368: PUSH
16369: EMPTY
16370: LIST
16371: LIST
16372: PUSH
16373: LD_INT 2
16375: PUSH
16376: LD_INT 34
16378: PUSH
16379: LD_INT 11
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 34
16388: PUSH
16389: LD_INT 30
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: EMPTY
16397: LIST
16398: LIST
16399: LIST
16400: PUSH
16401: EMPTY
16402: LIST
16403: LIST
16404: PPUSH
16405: CALL_OW 69
16409: ST_TO_ADDR
// if not tmp then
16410: LD_VAR 0 2
16414: NOT
16415: IFFALSE 16419
// exit ;
16417: GO 16448
// for i in tmp do
16419: LD_ADDR_VAR 0 1
16423: PUSH
16424: LD_VAR 0 2
16428: PUSH
16429: FOR_IN
16430: IFFALSE 16446
// begin SetLives ( i , 0 ) ;
16432: LD_VAR 0 1
16436: PPUSH
16437: LD_INT 0
16439: PPUSH
16440: CALL_OW 234
// end ;
16444: GO 16429
16446: POP
16447: POP
// end ;
16448: PPOPN 2
16450: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16451: LD_EXP 43
16455: PUSH
16456: LD_EXP 53
16460: AND
16461: IFFALSE 16481
16463: GO 16465
16465: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16466: LD_INT 32
16468: PPUSH
16469: LD_OWVAR 2
16473: PPUSH
16474: LD_INT 0
16476: PPUSH
16477: CALL_OW 324
16481: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16482: LD_EXP 43
16486: PUSH
16487: LD_EXP 54
16491: AND
16492: IFFALSE 16673
16494: GO 16496
16496: DISABLE
16497: LD_INT 0
16499: PPUSH
16500: PPUSH
16501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
16502: LD_ADDR_VAR 0 2
16506: PUSH
16507: LD_INT 22
16509: PUSH
16510: LD_OWVAR 2
16514: PUSH
16515: EMPTY
16516: LIST
16517: LIST
16518: PUSH
16519: LD_INT 33
16521: PUSH
16522: LD_INT 3
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: PPUSH
16533: CALL_OW 69
16537: ST_TO_ADDR
// if not tmp then
16538: LD_VAR 0 2
16542: NOT
16543: IFFALSE 16547
// exit ;
16545: GO 16673
// side := 0 ;
16547: LD_ADDR_VAR 0 3
16551: PUSH
16552: LD_INT 0
16554: ST_TO_ADDR
// for i := 1 to 8 do
16555: LD_ADDR_VAR 0 1
16559: PUSH
16560: DOUBLE
16561: LD_INT 1
16563: DEC
16564: ST_TO_ADDR
16565: LD_INT 8
16567: PUSH
16568: FOR_TO
16569: IFFALSE 16617
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
16571: LD_OWVAR 2
16575: PUSH
16576: LD_VAR 0 1
16580: NONEQUAL
16581: PUSH
16582: LD_OWVAR 2
16586: PPUSH
16587: LD_VAR 0 1
16591: PPUSH
16592: CALL_OW 81
16596: PUSH
16597: LD_INT 2
16599: EQUAL
16600: AND
16601: IFFALSE 16615
// begin side := i ;
16603: LD_ADDR_VAR 0 3
16607: PUSH
16608: LD_VAR 0 1
16612: ST_TO_ADDR
// break ;
16613: GO 16617
// end ;
16615: GO 16568
16617: POP
16618: POP
// if not side then
16619: LD_VAR 0 3
16623: NOT
16624: IFFALSE 16628
// exit ;
16626: GO 16673
// for i := 1 to tmp do
16628: LD_ADDR_VAR 0 1
16632: PUSH
16633: DOUBLE
16634: LD_INT 1
16636: DEC
16637: ST_TO_ADDR
16638: LD_VAR 0 2
16642: PUSH
16643: FOR_TO
16644: IFFALSE 16671
// if Prob ( 60 ) then
16646: LD_INT 60
16648: PPUSH
16649: CALL_OW 13
16653: IFFALSE 16669
// SetSide ( i , side ) ;
16655: LD_VAR 0 1
16659: PPUSH
16660: LD_VAR 0 3
16664: PPUSH
16665: CALL_OW 235
16669: GO 16643
16671: POP
16672: POP
// end ;
16673: PPOPN 3
16675: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
16676: LD_EXP 43
16680: PUSH
16681: LD_EXP 56
16685: AND
16686: IFFALSE 16805
16688: GO 16690
16690: DISABLE
16691: LD_INT 0
16693: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
16694: LD_ADDR_VAR 0 1
16698: PUSH
16699: LD_INT 22
16701: PUSH
16702: LD_OWVAR 2
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: PUSH
16711: LD_INT 21
16713: PUSH
16714: LD_INT 1
16716: PUSH
16717: EMPTY
16718: LIST
16719: LIST
16720: PUSH
16721: LD_INT 3
16723: PUSH
16724: LD_INT 23
16726: PUSH
16727: LD_INT 0
16729: PUSH
16730: EMPTY
16731: LIST
16732: LIST
16733: PUSH
16734: EMPTY
16735: LIST
16736: LIST
16737: PUSH
16738: EMPTY
16739: LIST
16740: LIST
16741: LIST
16742: PPUSH
16743: CALL_OW 69
16747: PUSH
16748: FOR_IN
16749: IFFALSE 16803
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
16751: LD_VAR 0 1
16755: PPUSH
16756: CALL_OW 257
16760: PUSH
16761: LD_INT 1
16763: PUSH
16764: LD_INT 2
16766: PUSH
16767: LD_INT 3
16769: PUSH
16770: LD_INT 4
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: LIST
16777: LIST
16778: IN
16779: IFFALSE 16801
// SetClass ( un , rand ( 1 , 4 ) ) ;
16781: LD_VAR 0 1
16785: PPUSH
16786: LD_INT 1
16788: PPUSH
16789: LD_INT 4
16791: PPUSH
16792: CALL_OW 12
16796: PPUSH
16797: CALL_OW 336
16801: GO 16748
16803: POP
16804: POP
// end ;
16805: PPOPN 1
16807: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
16808: LD_EXP 43
16812: PUSH
16813: LD_EXP 55
16817: AND
16818: IFFALSE 16897
16820: GO 16822
16822: DISABLE
16823: LD_INT 0
16825: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
16826: LD_ADDR_VAR 0 1
16830: PUSH
16831: LD_INT 22
16833: PUSH
16834: LD_OWVAR 2
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PUSH
16843: LD_INT 21
16845: PUSH
16846: LD_INT 3
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PPUSH
16857: CALL_OW 69
16861: ST_TO_ADDR
// if not tmp then
16862: LD_VAR 0 1
16866: NOT
16867: IFFALSE 16871
// exit ;
16869: GO 16897
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
16871: LD_VAR 0 1
16875: PUSH
16876: LD_INT 1
16878: PPUSH
16879: LD_VAR 0 1
16883: PPUSH
16884: CALL_OW 12
16888: ARRAY
16889: PPUSH
16890: LD_INT 100
16892: PPUSH
16893: CALL_OW 234
// end ;
16897: PPOPN 1
16899: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
16900: LD_EXP 43
16904: PUSH
16905: LD_EXP 57
16909: AND
16910: IFFALSE 17008
16912: GO 16914
16914: DISABLE
16915: LD_INT 0
16917: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16918: LD_ADDR_VAR 0 1
16922: PUSH
16923: LD_INT 22
16925: PUSH
16926: LD_OWVAR 2
16930: PUSH
16931: EMPTY
16932: LIST
16933: LIST
16934: PUSH
16935: LD_INT 21
16937: PUSH
16938: LD_INT 1
16940: PUSH
16941: EMPTY
16942: LIST
16943: LIST
16944: PUSH
16945: EMPTY
16946: LIST
16947: LIST
16948: PPUSH
16949: CALL_OW 69
16953: ST_TO_ADDR
// if not tmp then
16954: LD_VAR 0 1
16958: NOT
16959: IFFALSE 16963
// exit ;
16961: GO 17008
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
16963: LD_VAR 0 1
16967: PUSH
16968: LD_INT 1
16970: PPUSH
16971: LD_VAR 0 1
16975: PPUSH
16976: CALL_OW 12
16980: ARRAY
16981: PPUSH
16982: LD_INT 1
16984: PPUSH
16985: LD_INT 4
16987: PPUSH
16988: CALL_OW 12
16992: PPUSH
16993: LD_INT 3000
16995: PPUSH
16996: LD_INT 9000
16998: PPUSH
16999: CALL_OW 12
17003: PPUSH
17004: CALL_OW 492
// end ;
17008: PPOPN 1
17010: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17011: LD_EXP 43
17015: PUSH
17016: LD_EXP 58
17020: AND
17021: IFFALSE 17041
17023: GO 17025
17025: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17026: LD_INT 1
17028: PPUSH
17029: LD_OWVAR 2
17033: PPUSH
17034: LD_INT 0
17036: PPUSH
17037: CALL_OW 324
17041: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17042: LD_EXP 43
17046: PUSH
17047: LD_EXP 59
17051: AND
17052: IFFALSE 17135
17054: GO 17056
17056: DISABLE
17057: LD_INT 0
17059: PPUSH
17060: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17061: LD_ADDR_VAR 0 2
17065: PUSH
17066: LD_INT 22
17068: PUSH
17069: LD_OWVAR 2
17073: PUSH
17074: EMPTY
17075: LIST
17076: LIST
17077: PUSH
17078: LD_INT 21
17080: PUSH
17081: LD_INT 3
17083: PUSH
17084: EMPTY
17085: LIST
17086: LIST
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: PPUSH
17092: CALL_OW 69
17096: ST_TO_ADDR
// if not tmp then
17097: LD_VAR 0 2
17101: NOT
17102: IFFALSE 17106
// exit ;
17104: GO 17135
// for i in tmp do
17106: LD_ADDR_VAR 0 1
17110: PUSH
17111: LD_VAR 0 2
17115: PUSH
17116: FOR_IN
17117: IFFALSE 17133
// SetBLevel ( i , 10 ) ;
17119: LD_VAR 0 1
17123: PPUSH
17124: LD_INT 10
17126: PPUSH
17127: CALL_OW 241
17131: GO 17116
17133: POP
17134: POP
// end ;
17135: PPOPN 2
17137: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17138: LD_EXP 43
17142: PUSH
17143: LD_EXP 60
17147: AND
17148: IFFALSE 17259
17150: GO 17152
17152: DISABLE
17153: LD_INT 0
17155: PPUSH
17156: PPUSH
17157: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17158: LD_ADDR_VAR 0 3
17162: PUSH
17163: LD_INT 22
17165: PUSH
17166: LD_OWVAR 2
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PUSH
17175: LD_INT 25
17177: PUSH
17178: LD_INT 1
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: PUSH
17185: EMPTY
17186: LIST
17187: LIST
17188: PPUSH
17189: CALL_OW 69
17193: ST_TO_ADDR
// if not tmp then
17194: LD_VAR 0 3
17198: NOT
17199: IFFALSE 17203
// exit ;
17201: GO 17259
// un := tmp [ rand ( 1 , tmp ) ] ;
17203: LD_ADDR_VAR 0 2
17207: PUSH
17208: LD_VAR 0 3
17212: PUSH
17213: LD_INT 1
17215: PPUSH
17216: LD_VAR 0 3
17220: PPUSH
17221: CALL_OW 12
17225: ARRAY
17226: ST_TO_ADDR
// if Crawls ( un ) then
17227: LD_VAR 0 2
17231: PPUSH
17232: CALL_OW 318
17236: IFFALSE 17247
// ComWalk ( un ) ;
17238: LD_VAR 0 2
17242: PPUSH
17243: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17247: LD_VAR 0 2
17251: PPUSH
17252: LD_INT 5
17254: PPUSH
17255: CALL_OW 336
// end ;
17259: PPOPN 3
17261: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17262: LD_EXP 43
17266: PUSH
17267: LD_EXP 61
17271: AND
17272: PUSH
17273: LD_OWVAR 67
17277: PUSH
17278: LD_INT 3
17280: LESS
17281: AND
17282: IFFALSE 17301
17284: GO 17286
17286: DISABLE
// Difficulty := Difficulty + 1 ;
17287: LD_ADDR_OWVAR 67
17291: PUSH
17292: LD_OWVAR 67
17296: PUSH
17297: LD_INT 1
17299: PLUS
17300: ST_TO_ADDR
17301: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17302: LD_EXP 43
17306: PUSH
17307: LD_EXP 62
17311: AND
17312: IFFALSE 17415
17314: GO 17316
17316: DISABLE
17317: LD_INT 0
17319: PPUSH
// begin for i := 1 to 5 do
17320: LD_ADDR_VAR 0 1
17324: PUSH
17325: DOUBLE
17326: LD_INT 1
17328: DEC
17329: ST_TO_ADDR
17330: LD_INT 5
17332: PUSH
17333: FOR_TO
17334: IFFALSE 17413
// begin uc_nation := nation_nature ;
17336: LD_ADDR_OWVAR 21
17340: PUSH
17341: LD_INT 0
17343: ST_TO_ADDR
// uc_side := 0 ;
17344: LD_ADDR_OWVAR 20
17348: PUSH
17349: LD_INT 0
17351: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17352: LD_ADDR_OWVAR 29
17356: PUSH
17357: LD_INT 12
17359: PUSH
17360: LD_INT 12
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: ST_TO_ADDR
// hc_agressivity := 20 ;
17367: LD_ADDR_OWVAR 35
17371: PUSH
17372: LD_INT 20
17374: ST_TO_ADDR
// hc_class := class_tiger ;
17375: LD_ADDR_OWVAR 28
17379: PUSH
17380: LD_INT 14
17382: ST_TO_ADDR
// hc_gallery :=  ;
17383: LD_ADDR_OWVAR 33
17387: PUSH
17388: LD_STRING 
17390: ST_TO_ADDR
// hc_name :=  ;
17391: LD_ADDR_OWVAR 26
17395: PUSH
17396: LD_STRING 
17398: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17399: CALL_OW 44
17403: PPUSH
17404: LD_INT 0
17406: PPUSH
17407: CALL_OW 51
// end ;
17411: GO 17333
17413: POP
17414: POP
// end ;
17415: PPOPN 1
17417: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17418: LD_EXP 43
17422: PUSH
17423: LD_EXP 63
17427: AND
17428: IFFALSE 17437
17430: GO 17432
17432: DISABLE
// StreamSibBomb ;
17433: CALL 17438 0 0
17437: END
// export function StreamSibBomb ; var i , x , y ; begin
17438: LD_INT 0
17440: PPUSH
17441: PPUSH
17442: PPUSH
17443: PPUSH
// result := false ;
17444: LD_ADDR_VAR 0 1
17448: PUSH
17449: LD_INT 0
17451: ST_TO_ADDR
// for i := 1 to 16 do
17452: LD_ADDR_VAR 0 2
17456: PUSH
17457: DOUBLE
17458: LD_INT 1
17460: DEC
17461: ST_TO_ADDR
17462: LD_INT 16
17464: PUSH
17465: FOR_TO
17466: IFFALSE 17665
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17468: LD_ADDR_VAR 0 3
17472: PUSH
17473: LD_INT 10
17475: PUSH
17476: LD_INT 20
17478: PUSH
17479: LD_INT 30
17481: PUSH
17482: LD_INT 40
17484: PUSH
17485: LD_INT 50
17487: PUSH
17488: LD_INT 60
17490: PUSH
17491: LD_INT 70
17493: PUSH
17494: LD_INT 80
17496: PUSH
17497: LD_INT 90
17499: PUSH
17500: LD_INT 100
17502: PUSH
17503: LD_INT 110
17505: PUSH
17506: LD_INT 120
17508: PUSH
17509: LD_INT 130
17511: PUSH
17512: LD_INT 140
17514: PUSH
17515: LD_INT 150
17517: PUSH
17518: EMPTY
17519: LIST
17520: LIST
17521: LIST
17522: LIST
17523: LIST
17524: LIST
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: LIST
17530: LIST
17531: LIST
17532: LIST
17533: LIST
17534: PUSH
17535: LD_INT 1
17537: PPUSH
17538: LD_INT 15
17540: PPUSH
17541: CALL_OW 12
17545: ARRAY
17546: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17547: LD_ADDR_VAR 0 4
17551: PUSH
17552: LD_INT 10
17554: PUSH
17555: LD_INT 20
17557: PUSH
17558: LD_INT 30
17560: PUSH
17561: LD_INT 40
17563: PUSH
17564: LD_INT 50
17566: PUSH
17567: LD_INT 60
17569: PUSH
17570: LD_INT 70
17572: PUSH
17573: LD_INT 80
17575: PUSH
17576: LD_INT 90
17578: PUSH
17579: LD_INT 100
17581: PUSH
17582: LD_INT 110
17584: PUSH
17585: LD_INT 120
17587: PUSH
17588: LD_INT 130
17590: PUSH
17591: LD_INT 140
17593: PUSH
17594: LD_INT 150
17596: PUSH
17597: EMPTY
17598: LIST
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: LIST
17607: LIST
17608: LIST
17609: LIST
17610: LIST
17611: LIST
17612: LIST
17613: PUSH
17614: LD_INT 1
17616: PPUSH
17617: LD_INT 15
17619: PPUSH
17620: CALL_OW 12
17624: ARRAY
17625: ST_TO_ADDR
// if ValidHex ( x , y ) then
17626: LD_VAR 0 3
17630: PPUSH
17631: LD_VAR 0 4
17635: PPUSH
17636: CALL_OW 488
17640: IFFALSE 17663
// begin result := [ x , y ] ;
17642: LD_ADDR_VAR 0 1
17646: PUSH
17647: LD_VAR 0 3
17651: PUSH
17652: LD_VAR 0 4
17656: PUSH
17657: EMPTY
17658: LIST
17659: LIST
17660: ST_TO_ADDR
// break ;
17661: GO 17665
// end ; end ;
17663: GO 17465
17665: POP
17666: POP
// if result then
17667: LD_VAR 0 1
17671: IFFALSE 17731
// begin ToLua ( playSibBomb() ) ;
17673: LD_STRING playSibBomb()
17675: PPUSH
17676: CALL_OW 559
// wait ( 0 0$14 ) ;
17680: LD_INT 490
17682: PPUSH
17683: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
17687: LD_VAR 0 1
17691: PUSH
17692: LD_INT 1
17694: ARRAY
17695: PPUSH
17696: LD_VAR 0 1
17700: PUSH
17701: LD_INT 2
17703: ARRAY
17704: PPUSH
17705: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
17709: LD_VAR 0 1
17713: PUSH
17714: LD_INT 1
17716: ARRAY
17717: PPUSH
17718: LD_VAR 0 1
17722: PUSH
17723: LD_INT 2
17725: ARRAY
17726: PPUSH
17727: CALL_OW 429
// end ; end ;
17731: LD_VAR 0 1
17735: RET
// every 0 0$1 trigger StreamModeActive and sReset do
17736: LD_EXP 43
17740: PUSH
17741: LD_EXP 65
17745: AND
17746: IFFALSE 17758
17748: GO 17750
17750: DISABLE
// YouLost (  ) ;
17751: LD_STRING 
17753: PPUSH
17754: CALL_OW 104
17758: END
// every 0 0$1 trigger StreamModeActive and sFog do
17759: LD_EXP 43
17763: PUSH
17764: LD_EXP 64
17768: AND
17769: IFFALSE 17783
17771: GO 17773
17773: DISABLE
// FogOff ( your_side ) ;
17774: LD_OWVAR 2
17778: PPUSH
17779: CALL_OW 344
17783: END
// every 0 0$1 trigger StreamModeActive and sSun do
17784: LD_EXP 43
17788: PUSH
17789: LD_EXP 66
17793: AND
17794: IFFALSE 17822
17796: GO 17798
17798: DISABLE
// begin solar_recharge_percent := 0 ;
17799: LD_ADDR_OWVAR 79
17803: PUSH
17804: LD_INT 0
17806: ST_TO_ADDR
// wait ( 5 5$00 ) ;
17807: LD_INT 10500
17809: PPUSH
17810: CALL_OW 67
// solar_recharge_percent := 100 ;
17814: LD_ADDR_OWVAR 79
17818: PUSH
17819: LD_INT 100
17821: ST_TO_ADDR
// end ;
17822: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
17823: LD_EXP 43
17827: PUSH
17828: LD_EXP 67
17832: AND
17833: IFFALSE 18072
17835: GO 17837
17837: DISABLE
17838: LD_INT 0
17840: PPUSH
17841: PPUSH
17842: PPUSH
// begin tmp := [ ] ;
17843: LD_ADDR_VAR 0 3
17847: PUSH
17848: EMPTY
17849: ST_TO_ADDR
// for i := 1 to 6 do
17850: LD_ADDR_VAR 0 1
17854: PUSH
17855: DOUBLE
17856: LD_INT 1
17858: DEC
17859: ST_TO_ADDR
17860: LD_INT 6
17862: PUSH
17863: FOR_TO
17864: IFFALSE 17969
// begin uc_nation := nation_nature ;
17866: LD_ADDR_OWVAR 21
17870: PUSH
17871: LD_INT 0
17873: ST_TO_ADDR
// uc_side := 0 ;
17874: LD_ADDR_OWVAR 20
17878: PUSH
17879: LD_INT 0
17881: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17882: LD_ADDR_OWVAR 29
17886: PUSH
17887: LD_INT 12
17889: PUSH
17890: LD_INT 12
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: ST_TO_ADDR
// hc_agressivity := 20 ;
17897: LD_ADDR_OWVAR 35
17901: PUSH
17902: LD_INT 20
17904: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
17905: LD_ADDR_OWVAR 28
17909: PUSH
17910: LD_INT 17
17912: ST_TO_ADDR
// hc_gallery :=  ;
17913: LD_ADDR_OWVAR 33
17917: PUSH
17918: LD_STRING 
17920: ST_TO_ADDR
// hc_name :=  ;
17921: LD_ADDR_OWVAR 26
17925: PUSH
17926: LD_STRING 
17928: ST_TO_ADDR
// un := CreateHuman ;
17929: LD_ADDR_VAR 0 2
17933: PUSH
17934: CALL_OW 44
17938: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
17939: LD_VAR 0 2
17943: PPUSH
17944: LD_INT 1
17946: PPUSH
17947: CALL_OW 51
// tmp := tmp ^ un ;
17951: LD_ADDR_VAR 0 3
17955: PUSH
17956: LD_VAR 0 3
17960: PUSH
17961: LD_VAR 0 2
17965: ADD
17966: ST_TO_ADDR
// end ;
17967: GO 17863
17969: POP
17970: POP
// repeat wait ( 0 0$1 ) ;
17971: LD_INT 35
17973: PPUSH
17974: CALL_OW 67
// for un in tmp do
17978: LD_ADDR_VAR 0 2
17982: PUSH
17983: LD_VAR 0 3
17987: PUSH
17988: FOR_IN
17989: IFFALSE 18063
// begin if IsDead ( un ) then
17991: LD_VAR 0 2
17995: PPUSH
17996: CALL_OW 301
18000: IFFALSE 18020
// begin tmp := tmp diff un ;
18002: LD_ADDR_VAR 0 3
18006: PUSH
18007: LD_VAR 0 3
18011: PUSH
18012: LD_VAR 0 2
18016: DIFF
18017: ST_TO_ADDR
// continue ;
18018: GO 17988
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18020: LD_VAR 0 2
18024: PPUSH
18025: LD_INT 3
18027: PUSH
18028: LD_INT 22
18030: PUSH
18031: LD_INT 0
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: PUSH
18038: EMPTY
18039: LIST
18040: LIST
18041: PPUSH
18042: CALL_OW 69
18046: PPUSH
18047: LD_VAR 0 2
18051: PPUSH
18052: CALL_OW 74
18056: PPUSH
18057: CALL_OW 115
// end ;
18061: GO 17988
18063: POP
18064: POP
// until not tmp ;
18065: LD_VAR 0 3
18069: NOT
18070: IFFALSE 17971
// end ;
18072: PPOPN 3
18074: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18075: LD_EXP 43
18079: PUSH
18080: LD_EXP 68
18084: AND
18085: IFFALSE 18139
18087: GO 18089
18089: DISABLE
// begin ToLua ( displayTroll(); ) ;
18090: LD_STRING displayTroll();
18092: PPUSH
18093: CALL_OW 559
// wait ( 3 3$00 ) ;
18097: LD_INT 6300
18099: PPUSH
18100: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18104: LD_STRING hideTroll();
18106: PPUSH
18107: CALL_OW 559
// wait ( 1 1$00 ) ;
18111: LD_INT 2100
18113: PPUSH
18114: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18118: LD_STRING displayTroll();
18120: PPUSH
18121: CALL_OW 559
// wait ( 1 1$00 ) ;
18125: LD_INT 2100
18127: PPUSH
18128: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18132: LD_STRING hideTroll();
18134: PPUSH
18135: CALL_OW 559
// end ;
18139: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18140: LD_EXP 43
18144: PUSH
18145: LD_EXP 69
18149: AND
18150: IFFALSE 18213
18152: GO 18154
18154: DISABLE
18155: LD_INT 0
18157: PPUSH
// begin p := 0 ;
18158: LD_ADDR_VAR 0 1
18162: PUSH
18163: LD_INT 0
18165: ST_TO_ADDR
// repeat game_speed := 1 ;
18166: LD_ADDR_OWVAR 65
18170: PUSH
18171: LD_INT 1
18173: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18174: LD_INT 35
18176: PPUSH
18177: CALL_OW 67
// p := p + 1 ;
18181: LD_ADDR_VAR 0 1
18185: PUSH
18186: LD_VAR 0 1
18190: PUSH
18191: LD_INT 1
18193: PLUS
18194: ST_TO_ADDR
// until p >= 60 ;
18195: LD_VAR 0 1
18199: PUSH
18200: LD_INT 60
18202: GREATEREQUAL
18203: IFFALSE 18166
// game_speed := 4 ;
18205: LD_ADDR_OWVAR 65
18209: PUSH
18210: LD_INT 4
18212: ST_TO_ADDR
// end ;
18213: PPOPN 1
18215: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
18216: LD_EXP 43
18220: PUSH
18221: LD_EXP 70
18225: AND
18226: IFFALSE 18372
18228: GO 18230
18230: DISABLE
18231: LD_INT 0
18233: PPUSH
18234: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18235: LD_ADDR_VAR 0 1
18239: PUSH
18240: LD_INT 22
18242: PUSH
18243: LD_OWVAR 2
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: PUSH
18252: LD_INT 2
18254: PUSH
18255: LD_INT 30
18257: PUSH
18258: LD_INT 0
18260: PUSH
18261: EMPTY
18262: LIST
18263: LIST
18264: PUSH
18265: LD_INT 30
18267: PUSH
18268: LD_INT 1
18270: PUSH
18271: EMPTY
18272: LIST
18273: LIST
18274: PUSH
18275: EMPTY
18276: LIST
18277: LIST
18278: LIST
18279: PUSH
18280: EMPTY
18281: LIST
18282: LIST
18283: PPUSH
18284: CALL_OW 69
18288: ST_TO_ADDR
// if not depot then
18289: LD_VAR 0 1
18293: NOT
18294: IFFALSE 18298
// exit ;
18296: GO 18372
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18298: LD_ADDR_VAR 0 2
18302: PUSH
18303: LD_VAR 0 1
18307: PUSH
18308: LD_INT 1
18310: PPUSH
18311: LD_VAR 0 1
18315: PPUSH
18316: CALL_OW 12
18320: ARRAY
18321: PPUSH
18322: CALL_OW 274
18326: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18327: LD_VAR 0 2
18331: PPUSH
18332: LD_INT 1
18334: PPUSH
18335: LD_INT 0
18337: PPUSH
18338: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18342: LD_VAR 0 2
18346: PPUSH
18347: LD_INT 2
18349: PPUSH
18350: LD_INT 0
18352: PPUSH
18353: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18357: LD_VAR 0 2
18361: PPUSH
18362: LD_INT 3
18364: PPUSH
18365: LD_INT 0
18367: PPUSH
18368: CALL_OW 277
// end ;
18372: PPOPN 2
18374: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18375: LD_EXP 43
18379: PUSH
18380: LD_EXP 71
18384: AND
18385: IFFALSE 18482
18387: GO 18389
18389: DISABLE
18390: LD_INT 0
18392: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18393: LD_ADDR_VAR 0 1
18397: PUSH
18398: LD_INT 22
18400: PUSH
18401: LD_OWVAR 2
18405: PUSH
18406: EMPTY
18407: LIST
18408: LIST
18409: PUSH
18410: LD_INT 21
18412: PUSH
18413: LD_INT 1
18415: PUSH
18416: EMPTY
18417: LIST
18418: LIST
18419: PUSH
18420: LD_INT 3
18422: PUSH
18423: LD_INT 23
18425: PUSH
18426: LD_INT 0
18428: PUSH
18429: EMPTY
18430: LIST
18431: LIST
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: EMPTY
18438: LIST
18439: LIST
18440: LIST
18441: PPUSH
18442: CALL_OW 69
18446: ST_TO_ADDR
// if not tmp then
18447: LD_VAR 0 1
18451: NOT
18452: IFFALSE 18456
// exit ;
18454: GO 18482
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18456: LD_VAR 0 1
18460: PUSH
18461: LD_INT 1
18463: PPUSH
18464: LD_VAR 0 1
18468: PPUSH
18469: CALL_OW 12
18473: ARRAY
18474: PPUSH
18475: LD_INT 200
18477: PPUSH
18478: CALL_OW 234
// end ;
18482: PPOPN 1
18484: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
18485: LD_EXP 43
18489: PUSH
18490: LD_EXP 72
18494: AND
18495: IFFALSE 18574
18497: GO 18499
18499: DISABLE
18500: LD_INT 0
18502: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
18503: LD_ADDR_VAR 0 1
18507: PUSH
18508: LD_INT 22
18510: PUSH
18511: LD_OWVAR 2
18515: PUSH
18516: EMPTY
18517: LIST
18518: LIST
18519: PUSH
18520: LD_INT 21
18522: PUSH
18523: LD_INT 2
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PPUSH
18534: CALL_OW 69
18538: ST_TO_ADDR
// if not tmp then
18539: LD_VAR 0 1
18543: NOT
18544: IFFALSE 18548
// exit ;
18546: GO 18574
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
18548: LD_VAR 0 1
18552: PUSH
18553: LD_INT 1
18555: PPUSH
18556: LD_VAR 0 1
18560: PPUSH
18561: CALL_OW 12
18565: ARRAY
18566: PPUSH
18567: LD_INT 60
18569: PPUSH
18570: CALL_OW 234
// end ;
18574: PPOPN 1
18576: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
18577: LD_EXP 43
18581: PUSH
18582: LD_EXP 73
18586: AND
18587: IFFALSE 18686
18589: GO 18591
18591: DISABLE
18592: LD_INT 0
18594: PPUSH
18595: PPUSH
// begin enable ;
18596: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
18597: LD_ADDR_VAR 0 1
18601: PUSH
18602: LD_INT 22
18604: PUSH
18605: LD_OWVAR 2
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: PUSH
18614: LD_INT 61
18616: PUSH
18617: EMPTY
18618: LIST
18619: PUSH
18620: LD_INT 33
18622: PUSH
18623: LD_INT 2
18625: PUSH
18626: EMPTY
18627: LIST
18628: LIST
18629: PUSH
18630: EMPTY
18631: LIST
18632: LIST
18633: LIST
18634: PPUSH
18635: CALL_OW 69
18639: ST_TO_ADDR
// if not tmp then
18640: LD_VAR 0 1
18644: NOT
18645: IFFALSE 18649
// exit ;
18647: GO 18686
// for i in tmp do
18649: LD_ADDR_VAR 0 2
18653: PUSH
18654: LD_VAR 0 1
18658: PUSH
18659: FOR_IN
18660: IFFALSE 18684
// if IsControledBy ( i ) then
18662: LD_VAR 0 2
18666: PPUSH
18667: CALL_OW 312
18671: IFFALSE 18682
// ComUnlink ( i ) ;
18673: LD_VAR 0 2
18677: PPUSH
18678: CALL_OW 136
18682: GO 18659
18684: POP
18685: POP
// end ;
18686: PPOPN 2
18688: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
18689: LD_EXP 43
18693: PUSH
18694: LD_EXP 74
18698: AND
18699: IFFALSE 18839
18701: GO 18703
18703: DISABLE
18704: LD_INT 0
18706: PPUSH
18707: PPUSH
// begin ToLua ( displayPowell(); ) ;
18708: LD_STRING displayPowell();
18710: PPUSH
18711: CALL_OW 559
// uc_side := 0 ;
18715: LD_ADDR_OWVAR 20
18719: PUSH
18720: LD_INT 0
18722: ST_TO_ADDR
// uc_nation := 2 ;
18723: LD_ADDR_OWVAR 21
18727: PUSH
18728: LD_INT 2
18730: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
18731: LD_ADDR_OWVAR 37
18735: PUSH
18736: LD_INT 14
18738: ST_TO_ADDR
// vc_engine := engine_siberite ;
18739: LD_ADDR_OWVAR 39
18743: PUSH
18744: LD_INT 3
18746: ST_TO_ADDR
// vc_control := control_apeman ;
18747: LD_ADDR_OWVAR 38
18751: PUSH
18752: LD_INT 5
18754: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
18755: LD_ADDR_OWVAR 40
18759: PUSH
18760: LD_INT 29
18762: ST_TO_ADDR
// un := CreateVehicle ;
18763: LD_ADDR_VAR 0 2
18767: PUSH
18768: CALL_OW 45
18772: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18773: LD_VAR 0 2
18777: PPUSH
18778: LD_INT 1
18780: PPUSH
18781: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18785: LD_INT 35
18787: PPUSH
18788: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18792: LD_VAR 0 2
18796: PPUSH
18797: LD_INT 22
18799: PUSH
18800: LD_OWVAR 2
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PPUSH
18809: CALL_OW 69
18813: PPUSH
18814: LD_VAR 0 2
18818: PPUSH
18819: CALL_OW 74
18823: PPUSH
18824: CALL_OW 115
// until IsDead ( un ) ;
18828: LD_VAR 0 2
18832: PPUSH
18833: CALL_OW 301
18837: IFFALSE 18785
// end ;
18839: PPOPN 2
18841: END
// every 0 0$1 trigger StreamModeActive and sStu do
18842: LD_EXP 43
18846: PUSH
18847: LD_EXP 82
18851: AND
18852: IFFALSE 18868
18854: GO 18856
18856: DISABLE
// begin ToLua ( displayStucuk(); ) ;
18857: LD_STRING displayStucuk();
18859: PPUSH
18860: CALL_OW 559
// ResetFog ;
18864: CALL_OW 335
// end ;
18868: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
18869: LD_EXP 43
18873: PUSH
18874: LD_EXP 75
18878: AND
18879: IFFALSE 19020
18881: GO 18883
18883: DISABLE
18884: LD_INT 0
18886: PPUSH
18887: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18888: LD_ADDR_VAR 0 2
18892: PUSH
18893: LD_INT 22
18895: PUSH
18896: LD_OWVAR 2
18900: PUSH
18901: EMPTY
18902: LIST
18903: LIST
18904: PUSH
18905: LD_INT 21
18907: PUSH
18908: LD_INT 1
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: PUSH
18915: EMPTY
18916: LIST
18917: LIST
18918: PPUSH
18919: CALL_OW 69
18923: ST_TO_ADDR
// if not tmp then
18924: LD_VAR 0 2
18928: NOT
18929: IFFALSE 18933
// exit ;
18931: GO 19020
// un := tmp [ rand ( 1 , tmp ) ] ;
18933: LD_ADDR_VAR 0 1
18937: PUSH
18938: LD_VAR 0 2
18942: PUSH
18943: LD_INT 1
18945: PPUSH
18946: LD_VAR 0 2
18950: PPUSH
18951: CALL_OW 12
18955: ARRAY
18956: ST_TO_ADDR
// SetSide ( un , 0 ) ;
18957: LD_VAR 0 1
18961: PPUSH
18962: LD_INT 0
18964: PPUSH
18965: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
18969: LD_VAR 0 1
18973: PPUSH
18974: LD_OWVAR 3
18978: PUSH
18979: LD_VAR 0 1
18983: DIFF
18984: PPUSH
18985: LD_VAR 0 1
18989: PPUSH
18990: CALL_OW 74
18994: PPUSH
18995: CALL_OW 115
// wait ( 0 0$20 ) ;
18999: LD_INT 700
19001: PPUSH
19002: CALL_OW 67
// SetSide ( un , your_side ) ;
19006: LD_VAR 0 1
19010: PPUSH
19011: LD_OWVAR 2
19015: PPUSH
19016: CALL_OW 235
// end ;
19020: PPOPN 2
19022: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19023: LD_EXP 43
19027: PUSH
19028: LD_EXP 76
19032: AND
19033: IFFALSE 19139
19035: GO 19037
19037: DISABLE
19038: LD_INT 0
19040: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19041: LD_ADDR_VAR 0 1
19045: PUSH
19046: LD_INT 22
19048: PUSH
19049: LD_OWVAR 2
19053: PUSH
19054: EMPTY
19055: LIST
19056: LIST
19057: PUSH
19058: LD_INT 2
19060: PUSH
19061: LD_INT 30
19063: PUSH
19064: LD_INT 0
19066: PUSH
19067: EMPTY
19068: LIST
19069: LIST
19070: PUSH
19071: LD_INT 30
19073: PUSH
19074: LD_INT 1
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: PUSH
19081: EMPTY
19082: LIST
19083: LIST
19084: LIST
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: PPUSH
19090: CALL_OW 69
19094: ST_TO_ADDR
// if not depot then
19095: LD_VAR 0 1
19099: NOT
19100: IFFALSE 19104
// exit ;
19102: GO 19139
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19104: LD_VAR 0 1
19108: PUSH
19109: LD_INT 1
19111: ARRAY
19112: PPUSH
19113: CALL_OW 250
19117: PPUSH
19118: LD_VAR 0 1
19122: PUSH
19123: LD_INT 1
19125: ARRAY
19126: PPUSH
19127: CALL_OW 251
19131: PPUSH
19132: LD_INT 70
19134: PPUSH
19135: CALL_OW 495
// end ;
19139: PPOPN 1
19141: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19142: LD_EXP 43
19146: PUSH
19147: LD_EXP 77
19151: AND
19152: IFFALSE 19363
19154: GO 19156
19156: DISABLE
19157: LD_INT 0
19159: PPUSH
19160: PPUSH
19161: PPUSH
19162: PPUSH
19163: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19164: LD_ADDR_VAR 0 5
19168: PUSH
19169: LD_INT 22
19171: PUSH
19172: LD_OWVAR 2
19176: PUSH
19177: EMPTY
19178: LIST
19179: LIST
19180: PUSH
19181: LD_INT 21
19183: PUSH
19184: LD_INT 1
19186: PUSH
19187: EMPTY
19188: LIST
19189: LIST
19190: PUSH
19191: EMPTY
19192: LIST
19193: LIST
19194: PPUSH
19195: CALL_OW 69
19199: ST_TO_ADDR
// if not tmp then
19200: LD_VAR 0 5
19204: NOT
19205: IFFALSE 19209
// exit ;
19207: GO 19363
// for i in tmp do
19209: LD_ADDR_VAR 0 1
19213: PUSH
19214: LD_VAR 0 5
19218: PUSH
19219: FOR_IN
19220: IFFALSE 19361
// begin d := rand ( 0 , 5 ) ;
19222: LD_ADDR_VAR 0 4
19226: PUSH
19227: LD_INT 0
19229: PPUSH
19230: LD_INT 5
19232: PPUSH
19233: CALL_OW 12
19237: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19238: LD_ADDR_VAR 0 2
19242: PUSH
19243: LD_VAR 0 1
19247: PPUSH
19248: CALL_OW 250
19252: PPUSH
19253: LD_VAR 0 4
19257: PPUSH
19258: LD_INT 3
19260: PPUSH
19261: LD_INT 12
19263: PPUSH
19264: CALL_OW 12
19268: PPUSH
19269: CALL_OW 272
19273: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19274: LD_ADDR_VAR 0 3
19278: PUSH
19279: LD_VAR 0 1
19283: PPUSH
19284: CALL_OW 251
19288: PPUSH
19289: LD_VAR 0 4
19293: PPUSH
19294: LD_INT 3
19296: PPUSH
19297: LD_INT 12
19299: PPUSH
19300: CALL_OW 12
19304: PPUSH
19305: CALL_OW 273
19309: ST_TO_ADDR
// if ValidHex ( x , y ) then
19310: LD_VAR 0 2
19314: PPUSH
19315: LD_VAR 0 3
19319: PPUSH
19320: CALL_OW 488
19324: IFFALSE 19359
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19326: LD_VAR 0 1
19330: PPUSH
19331: LD_VAR 0 2
19335: PPUSH
19336: LD_VAR 0 3
19340: PPUSH
19341: LD_INT 3
19343: PPUSH
19344: LD_INT 6
19346: PPUSH
19347: CALL_OW 12
19351: PPUSH
19352: LD_INT 1
19354: PPUSH
19355: CALL_OW 483
// end ;
19359: GO 19219
19361: POP
19362: POP
// end ;
19363: PPOPN 5
19365: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19366: LD_EXP 43
19370: PUSH
19371: LD_EXP 78
19375: AND
19376: IFFALSE 19470
19378: GO 19380
19380: DISABLE
19381: LD_INT 0
19383: PPUSH
19384: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19385: LD_ADDR_VAR 0 2
19389: PUSH
19390: LD_INT 22
19392: PUSH
19393: LD_OWVAR 2
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: PUSH
19402: LD_INT 32
19404: PUSH
19405: LD_INT 1
19407: PUSH
19408: EMPTY
19409: LIST
19410: LIST
19411: PUSH
19412: LD_INT 21
19414: PUSH
19415: LD_INT 2
19417: PUSH
19418: EMPTY
19419: LIST
19420: LIST
19421: PUSH
19422: EMPTY
19423: LIST
19424: LIST
19425: LIST
19426: PPUSH
19427: CALL_OW 69
19431: ST_TO_ADDR
// if not tmp then
19432: LD_VAR 0 2
19436: NOT
19437: IFFALSE 19441
// exit ;
19439: GO 19470
// for i in tmp do
19441: LD_ADDR_VAR 0 1
19445: PUSH
19446: LD_VAR 0 2
19450: PUSH
19451: FOR_IN
19452: IFFALSE 19468
// SetFuel ( i , 0 ) ;
19454: LD_VAR 0 1
19458: PPUSH
19459: LD_INT 0
19461: PPUSH
19462: CALL_OW 240
19466: GO 19451
19468: POP
19469: POP
// end ;
19470: PPOPN 2
19472: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19473: LD_EXP 43
19477: PUSH
19478: LD_EXP 79
19482: AND
19483: IFFALSE 19549
19485: GO 19487
19487: DISABLE
19488: LD_INT 0
19490: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19491: LD_ADDR_VAR 0 1
19495: PUSH
19496: LD_INT 22
19498: PUSH
19499: LD_OWVAR 2
19503: PUSH
19504: EMPTY
19505: LIST
19506: LIST
19507: PUSH
19508: LD_INT 30
19510: PUSH
19511: LD_INT 29
19513: PUSH
19514: EMPTY
19515: LIST
19516: LIST
19517: PUSH
19518: EMPTY
19519: LIST
19520: LIST
19521: PPUSH
19522: CALL_OW 69
19526: ST_TO_ADDR
// if not tmp then
19527: LD_VAR 0 1
19531: NOT
19532: IFFALSE 19536
// exit ;
19534: GO 19549
// DestroyUnit ( tmp [ 1 ] ) ;
19536: LD_VAR 0 1
19540: PUSH
19541: LD_INT 1
19543: ARRAY
19544: PPUSH
19545: CALL_OW 65
// end ;
19549: PPOPN 1
19551: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
19552: LD_EXP 43
19556: PUSH
19557: LD_EXP 81
19561: AND
19562: IFFALSE 19691
19564: GO 19566
19566: DISABLE
19567: LD_INT 0
19569: PPUSH
// begin uc_side := 0 ;
19570: LD_ADDR_OWVAR 20
19574: PUSH
19575: LD_INT 0
19577: ST_TO_ADDR
// uc_nation := nation_arabian ;
19578: LD_ADDR_OWVAR 21
19582: PUSH
19583: LD_INT 2
19585: ST_TO_ADDR
// hc_gallery :=  ;
19586: LD_ADDR_OWVAR 33
19590: PUSH
19591: LD_STRING 
19593: ST_TO_ADDR
// hc_name :=  ;
19594: LD_ADDR_OWVAR 26
19598: PUSH
19599: LD_STRING 
19601: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
19602: LD_INT 1
19604: PPUSH
19605: LD_INT 11
19607: PPUSH
19608: LD_INT 10
19610: PPUSH
19611: CALL_OW 380
// un := CreateHuman ;
19615: LD_ADDR_VAR 0 1
19619: PUSH
19620: CALL_OW 44
19624: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19625: LD_VAR 0 1
19629: PPUSH
19630: LD_INT 1
19632: PPUSH
19633: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19637: LD_INT 35
19639: PPUSH
19640: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19644: LD_VAR 0 1
19648: PPUSH
19649: LD_INT 22
19651: PUSH
19652: LD_OWVAR 2
19656: PUSH
19657: EMPTY
19658: LIST
19659: LIST
19660: PPUSH
19661: CALL_OW 69
19665: PPUSH
19666: LD_VAR 0 1
19670: PPUSH
19671: CALL_OW 74
19675: PPUSH
19676: CALL_OW 115
// until IsDead ( un ) ;
19680: LD_VAR 0 1
19684: PPUSH
19685: CALL_OW 301
19689: IFFALSE 19637
// end ;
19691: PPOPN 1
19693: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
19694: LD_EXP 43
19698: PUSH
19699: LD_EXP 83
19703: AND
19704: IFFALSE 19716
19706: GO 19708
19708: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
19709: LD_STRING earthquake(getX(game), 0, 32)
19711: PPUSH
19712: CALL_OW 559
19716: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
19717: LD_EXP 43
19721: PUSH
19722: LD_EXP 84
19726: AND
19727: IFFALSE 19818
19729: GO 19731
19731: DISABLE
19732: LD_INT 0
19734: PPUSH
// begin enable ;
19735: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
19736: LD_ADDR_VAR 0 1
19740: PUSH
19741: LD_INT 22
19743: PUSH
19744: LD_OWVAR 2
19748: PUSH
19749: EMPTY
19750: LIST
19751: LIST
19752: PUSH
19753: LD_INT 21
19755: PUSH
19756: LD_INT 2
19758: PUSH
19759: EMPTY
19760: LIST
19761: LIST
19762: PUSH
19763: LD_INT 33
19765: PUSH
19766: LD_INT 3
19768: PUSH
19769: EMPTY
19770: LIST
19771: LIST
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: PPUSH
19778: CALL_OW 69
19782: ST_TO_ADDR
// if not tmp then
19783: LD_VAR 0 1
19787: NOT
19788: IFFALSE 19792
// exit ;
19790: GO 19818
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19792: LD_VAR 0 1
19796: PUSH
19797: LD_INT 1
19799: PPUSH
19800: LD_VAR 0 1
19804: PPUSH
19805: CALL_OW 12
19809: ARRAY
19810: PPUSH
19811: LD_INT 1
19813: PPUSH
19814: CALL_OW 234
// end ;
19818: PPOPN 1
19820: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
19821: LD_EXP 43
19825: PUSH
19826: LD_EXP 85
19830: AND
19831: IFFALSE 19972
19833: GO 19835
19835: DISABLE
19836: LD_INT 0
19838: PPUSH
19839: PPUSH
19840: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19841: LD_ADDR_VAR 0 3
19845: PUSH
19846: LD_INT 22
19848: PUSH
19849: LD_OWVAR 2
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: PUSH
19858: LD_INT 25
19860: PUSH
19861: LD_INT 1
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: PUSH
19868: EMPTY
19869: LIST
19870: LIST
19871: PPUSH
19872: CALL_OW 69
19876: ST_TO_ADDR
// if not tmp then
19877: LD_VAR 0 3
19881: NOT
19882: IFFALSE 19886
// exit ;
19884: GO 19972
// un := tmp [ rand ( 1 , tmp ) ] ;
19886: LD_ADDR_VAR 0 2
19890: PUSH
19891: LD_VAR 0 3
19895: PUSH
19896: LD_INT 1
19898: PPUSH
19899: LD_VAR 0 3
19903: PPUSH
19904: CALL_OW 12
19908: ARRAY
19909: ST_TO_ADDR
// if Crawls ( un ) then
19910: LD_VAR 0 2
19914: PPUSH
19915: CALL_OW 318
19919: IFFALSE 19930
// ComWalk ( un ) ;
19921: LD_VAR 0 2
19925: PPUSH
19926: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
19930: LD_VAR 0 2
19934: PPUSH
19935: LD_INT 9
19937: PPUSH
19938: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
19942: LD_INT 28
19944: PPUSH
19945: LD_OWVAR 2
19949: PPUSH
19950: LD_INT 2
19952: PPUSH
19953: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
19957: LD_INT 29
19959: PPUSH
19960: LD_OWVAR 2
19964: PPUSH
19965: LD_INT 2
19967: PPUSH
19968: CALL_OW 322
// end ;
19972: PPOPN 3
19974: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
19975: LD_EXP 43
19979: PUSH
19980: LD_EXP 86
19984: AND
19985: IFFALSE 20096
19987: GO 19989
19989: DISABLE
19990: LD_INT 0
19992: PPUSH
19993: PPUSH
19994: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19995: LD_ADDR_VAR 0 3
19999: PUSH
20000: LD_INT 22
20002: PUSH
20003: LD_OWVAR 2
20007: PUSH
20008: EMPTY
20009: LIST
20010: LIST
20011: PUSH
20012: LD_INT 25
20014: PUSH
20015: LD_INT 1
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: PPUSH
20026: CALL_OW 69
20030: ST_TO_ADDR
// if not tmp then
20031: LD_VAR 0 3
20035: NOT
20036: IFFALSE 20040
// exit ;
20038: GO 20096
// un := tmp [ rand ( 1 , tmp ) ] ;
20040: LD_ADDR_VAR 0 2
20044: PUSH
20045: LD_VAR 0 3
20049: PUSH
20050: LD_INT 1
20052: PPUSH
20053: LD_VAR 0 3
20057: PPUSH
20058: CALL_OW 12
20062: ARRAY
20063: ST_TO_ADDR
// if Crawls ( un ) then
20064: LD_VAR 0 2
20068: PPUSH
20069: CALL_OW 318
20073: IFFALSE 20084
// ComWalk ( un ) ;
20075: LD_VAR 0 2
20079: PPUSH
20080: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20084: LD_VAR 0 2
20088: PPUSH
20089: LD_INT 8
20091: PPUSH
20092: CALL_OW 336
// end ;
20096: PPOPN 3
20098: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20099: LD_EXP 43
20103: PUSH
20104: LD_EXP 87
20108: AND
20109: IFFALSE 20253
20111: GO 20113
20113: DISABLE
20114: LD_INT 0
20116: PPUSH
20117: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20118: LD_ADDR_VAR 0 2
20122: PUSH
20123: LD_INT 22
20125: PUSH
20126: LD_OWVAR 2
20130: PUSH
20131: EMPTY
20132: LIST
20133: LIST
20134: PUSH
20135: LD_INT 21
20137: PUSH
20138: LD_INT 2
20140: PUSH
20141: EMPTY
20142: LIST
20143: LIST
20144: PUSH
20145: LD_INT 2
20147: PUSH
20148: LD_INT 34
20150: PUSH
20151: LD_INT 12
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 34
20160: PUSH
20161: LD_INT 51
20163: PUSH
20164: EMPTY
20165: LIST
20166: LIST
20167: PUSH
20168: LD_INT 34
20170: PUSH
20171: LD_INT 32
20173: PUSH
20174: EMPTY
20175: LIST
20176: LIST
20177: PUSH
20178: EMPTY
20179: LIST
20180: LIST
20181: LIST
20182: LIST
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: LIST
20188: PPUSH
20189: CALL_OW 69
20193: ST_TO_ADDR
// if not tmp then
20194: LD_VAR 0 2
20198: NOT
20199: IFFALSE 20203
// exit ;
20201: GO 20253
// for i in tmp do
20203: LD_ADDR_VAR 0 1
20207: PUSH
20208: LD_VAR 0 2
20212: PUSH
20213: FOR_IN
20214: IFFALSE 20251
// if GetCargo ( i , mat_artifact ) = 0 then
20216: LD_VAR 0 1
20220: PPUSH
20221: LD_INT 4
20223: PPUSH
20224: CALL_OW 289
20228: PUSH
20229: LD_INT 0
20231: EQUAL
20232: IFFALSE 20249
// SetCargo ( i , mat_siberit , 100 ) ;
20234: LD_VAR 0 1
20238: PPUSH
20239: LD_INT 3
20241: PPUSH
20242: LD_INT 100
20244: PPUSH
20245: CALL_OW 290
20249: GO 20213
20251: POP
20252: POP
// end ;
20253: PPOPN 2
20255: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20256: LD_EXP 43
20260: PUSH
20261: LD_EXP 88
20265: AND
20266: IFFALSE 20419
20268: GO 20270
20270: DISABLE
20271: LD_INT 0
20273: PPUSH
20274: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20275: LD_ADDR_VAR 0 2
20279: PUSH
20280: LD_INT 22
20282: PUSH
20283: LD_OWVAR 2
20287: PUSH
20288: EMPTY
20289: LIST
20290: LIST
20291: PPUSH
20292: CALL_OW 69
20296: ST_TO_ADDR
// if not tmp then
20297: LD_VAR 0 2
20301: NOT
20302: IFFALSE 20306
// exit ;
20304: GO 20419
// for i := 1 to 2 do
20306: LD_ADDR_VAR 0 1
20310: PUSH
20311: DOUBLE
20312: LD_INT 1
20314: DEC
20315: ST_TO_ADDR
20316: LD_INT 2
20318: PUSH
20319: FOR_TO
20320: IFFALSE 20417
// begin uc_side := your_side ;
20322: LD_ADDR_OWVAR 20
20326: PUSH
20327: LD_OWVAR 2
20331: ST_TO_ADDR
// uc_nation := nation_american ;
20332: LD_ADDR_OWVAR 21
20336: PUSH
20337: LD_INT 1
20339: ST_TO_ADDR
// vc_chassis := us_morphling ;
20340: LD_ADDR_OWVAR 37
20344: PUSH
20345: LD_INT 5
20347: ST_TO_ADDR
// vc_engine := engine_siberite ;
20348: LD_ADDR_OWVAR 39
20352: PUSH
20353: LD_INT 3
20355: ST_TO_ADDR
// vc_control := control_computer ;
20356: LD_ADDR_OWVAR 38
20360: PUSH
20361: LD_INT 3
20363: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20364: LD_ADDR_OWVAR 40
20368: PUSH
20369: LD_INT 10
20371: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
20372: CALL_OW 45
20376: PPUSH
20377: LD_VAR 0 2
20381: PUSH
20382: LD_INT 1
20384: ARRAY
20385: PPUSH
20386: CALL_OW 250
20390: PPUSH
20391: LD_VAR 0 2
20395: PUSH
20396: LD_INT 1
20398: ARRAY
20399: PPUSH
20400: CALL_OW 251
20404: PPUSH
20405: LD_INT 12
20407: PPUSH
20408: LD_INT 1
20410: PPUSH
20411: CALL_OW 50
// end ;
20415: GO 20319
20417: POP
20418: POP
// end ;
20419: PPOPN 2
20421: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20422: LD_EXP 43
20426: PUSH
20427: LD_EXP 89
20431: AND
20432: IFFALSE 20654
20434: GO 20436
20436: DISABLE
20437: LD_INT 0
20439: PPUSH
20440: PPUSH
20441: PPUSH
20442: PPUSH
20443: PPUSH
20444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20445: LD_ADDR_VAR 0 6
20449: PUSH
20450: LD_INT 22
20452: PUSH
20453: LD_OWVAR 2
20457: PUSH
20458: EMPTY
20459: LIST
20460: LIST
20461: PUSH
20462: LD_INT 21
20464: PUSH
20465: LD_INT 1
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: PUSH
20472: LD_INT 3
20474: PUSH
20475: LD_INT 23
20477: PUSH
20478: LD_INT 0
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: PUSH
20485: EMPTY
20486: LIST
20487: LIST
20488: PUSH
20489: EMPTY
20490: LIST
20491: LIST
20492: LIST
20493: PPUSH
20494: CALL_OW 69
20498: ST_TO_ADDR
// if not tmp then
20499: LD_VAR 0 6
20503: NOT
20504: IFFALSE 20508
// exit ;
20506: GO 20654
// s1 := rand ( 1 , 4 ) ;
20508: LD_ADDR_VAR 0 2
20512: PUSH
20513: LD_INT 1
20515: PPUSH
20516: LD_INT 4
20518: PPUSH
20519: CALL_OW 12
20523: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
20524: LD_ADDR_VAR 0 4
20528: PUSH
20529: LD_VAR 0 6
20533: PUSH
20534: LD_INT 1
20536: ARRAY
20537: PPUSH
20538: LD_VAR 0 2
20542: PPUSH
20543: CALL_OW 259
20547: ST_TO_ADDR
// if s1 = 1 then
20548: LD_VAR 0 2
20552: PUSH
20553: LD_INT 1
20555: EQUAL
20556: IFFALSE 20576
// s2 := rand ( 2 , 4 ) else
20558: LD_ADDR_VAR 0 3
20562: PUSH
20563: LD_INT 2
20565: PPUSH
20566: LD_INT 4
20568: PPUSH
20569: CALL_OW 12
20573: ST_TO_ADDR
20574: GO 20584
// s2 := 1 ;
20576: LD_ADDR_VAR 0 3
20580: PUSH
20581: LD_INT 1
20583: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
20584: LD_ADDR_VAR 0 5
20588: PUSH
20589: LD_VAR 0 6
20593: PUSH
20594: LD_INT 1
20596: ARRAY
20597: PPUSH
20598: LD_VAR 0 3
20602: PPUSH
20603: CALL_OW 259
20607: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
20608: LD_VAR 0 6
20612: PUSH
20613: LD_INT 1
20615: ARRAY
20616: PPUSH
20617: LD_VAR 0 2
20621: PPUSH
20622: LD_VAR 0 5
20626: PPUSH
20627: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
20631: LD_VAR 0 6
20635: PUSH
20636: LD_INT 1
20638: ARRAY
20639: PPUSH
20640: LD_VAR 0 3
20644: PPUSH
20645: LD_VAR 0 4
20649: PPUSH
20650: CALL_OW 237
// end ;
20654: PPOPN 6
20656: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
20657: LD_EXP 43
20661: PUSH
20662: LD_EXP 90
20666: AND
20667: IFFALSE 20746
20669: GO 20671
20671: DISABLE
20672: LD_INT 0
20674: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
20675: LD_ADDR_VAR 0 1
20679: PUSH
20680: LD_INT 22
20682: PUSH
20683: LD_OWVAR 2
20687: PUSH
20688: EMPTY
20689: LIST
20690: LIST
20691: PUSH
20692: LD_INT 30
20694: PUSH
20695: LD_INT 3
20697: PUSH
20698: EMPTY
20699: LIST
20700: LIST
20701: PUSH
20702: EMPTY
20703: LIST
20704: LIST
20705: PPUSH
20706: CALL_OW 69
20710: ST_TO_ADDR
// if not tmp then
20711: LD_VAR 0 1
20715: NOT
20716: IFFALSE 20720
// exit ;
20718: GO 20746
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20720: LD_VAR 0 1
20724: PUSH
20725: LD_INT 1
20727: PPUSH
20728: LD_VAR 0 1
20732: PPUSH
20733: CALL_OW 12
20737: ARRAY
20738: PPUSH
20739: LD_INT 1
20741: PPUSH
20742: CALL_OW 234
// end ;
20746: PPOPN 1
20748: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
20749: LD_EXP 43
20753: PUSH
20754: LD_EXP 91
20758: AND
20759: IFFALSE 20871
20761: GO 20763
20763: DISABLE
20764: LD_INT 0
20766: PPUSH
20767: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
20768: LD_ADDR_VAR 0 2
20772: PUSH
20773: LD_INT 22
20775: PUSH
20776: LD_OWVAR 2
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: PUSH
20785: LD_INT 2
20787: PUSH
20788: LD_INT 30
20790: PUSH
20791: LD_INT 27
20793: PUSH
20794: EMPTY
20795: LIST
20796: LIST
20797: PUSH
20798: LD_INT 30
20800: PUSH
20801: LD_INT 26
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: PUSH
20808: LD_INT 30
20810: PUSH
20811: LD_INT 28
20813: PUSH
20814: EMPTY
20815: LIST
20816: LIST
20817: PUSH
20818: EMPTY
20819: LIST
20820: LIST
20821: LIST
20822: LIST
20823: PUSH
20824: EMPTY
20825: LIST
20826: LIST
20827: PPUSH
20828: CALL_OW 69
20832: ST_TO_ADDR
// if not tmp then
20833: LD_VAR 0 2
20837: NOT
20838: IFFALSE 20842
// exit ;
20840: GO 20871
// for i in tmp do
20842: LD_ADDR_VAR 0 1
20846: PUSH
20847: LD_VAR 0 2
20851: PUSH
20852: FOR_IN
20853: IFFALSE 20869
// SetLives ( i , 1 ) ;
20855: LD_VAR 0 1
20859: PPUSH
20860: LD_INT 1
20862: PPUSH
20863: CALL_OW 234
20867: GO 20852
20869: POP
20870: POP
// end ;
20871: PPOPN 2
20873: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
20874: LD_EXP 43
20878: PUSH
20879: LD_EXP 92
20883: AND
20884: IFFALSE 21158
20886: GO 20888
20888: DISABLE
20889: LD_INT 0
20891: PPUSH
20892: PPUSH
20893: PPUSH
// begin i := rand ( 1 , 7 ) ;
20894: LD_ADDR_VAR 0 1
20898: PUSH
20899: LD_INT 1
20901: PPUSH
20902: LD_INT 7
20904: PPUSH
20905: CALL_OW 12
20909: ST_TO_ADDR
// case i of 1 :
20910: LD_VAR 0 1
20914: PUSH
20915: LD_INT 1
20917: DOUBLE
20918: EQUAL
20919: IFTRUE 20923
20921: GO 20933
20923: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
20924: LD_STRING earthquake(getX(game), 0, 32)
20926: PPUSH
20927: CALL_OW 559
20931: GO 21158
20933: LD_INT 2
20935: DOUBLE
20936: EQUAL
20937: IFTRUE 20941
20939: GO 20955
20941: POP
// begin ToLua ( displayStucuk(); ) ;
20942: LD_STRING displayStucuk();
20944: PPUSH
20945: CALL_OW 559
// ResetFog ;
20949: CALL_OW 335
// end ; 3 :
20953: GO 21158
20955: LD_INT 3
20957: DOUBLE
20958: EQUAL
20959: IFTRUE 20963
20961: GO 21067
20963: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20964: LD_ADDR_VAR 0 2
20968: PUSH
20969: LD_INT 22
20971: PUSH
20972: LD_OWVAR 2
20976: PUSH
20977: EMPTY
20978: LIST
20979: LIST
20980: PUSH
20981: LD_INT 25
20983: PUSH
20984: LD_INT 1
20986: PUSH
20987: EMPTY
20988: LIST
20989: LIST
20990: PUSH
20991: EMPTY
20992: LIST
20993: LIST
20994: PPUSH
20995: CALL_OW 69
20999: ST_TO_ADDR
// if not tmp then
21000: LD_VAR 0 2
21004: NOT
21005: IFFALSE 21009
// exit ;
21007: GO 21158
// un := tmp [ rand ( 1 , tmp ) ] ;
21009: LD_ADDR_VAR 0 3
21013: PUSH
21014: LD_VAR 0 2
21018: PUSH
21019: LD_INT 1
21021: PPUSH
21022: LD_VAR 0 2
21026: PPUSH
21027: CALL_OW 12
21031: ARRAY
21032: ST_TO_ADDR
// if Crawls ( un ) then
21033: LD_VAR 0 3
21037: PPUSH
21038: CALL_OW 318
21042: IFFALSE 21053
// ComWalk ( un ) ;
21044: LD_VAR 0 3
21048: PPUSH
21049: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21053: LD_VAR 0 3
21057: PPUSH
21058: LD_INT 8
21060: PPUSH
21061: CALL_OW 336
// end ; 4 :
21065: GO 21158
21067: LD_INT 4
21069: DOUBLE
21070: EQUAL
21071: IFTRUE 21075
21073: GO 21136
21075: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21076: LD_ADDR_VAR 0 2
21080: PUSH
21081: LD_INT 22
21083: PUSH
21084: LD_OWVAR 2
21088: PUSH
21089: EMPTY
21090: LIST
21091: LIST
21092: PUSH
21093: LD_INT 30
21095: PUSH
21096: LD_INT 29
21098: PUSH
21099: EMPTY
21100: LIST
21101: LIST
21102: PUSH
21103: EMPTY
21104: LIST
21105: LIST
21106: PPUSH
21107: CALL_OW 69
21111: ST_TO_ADDR
// if not tmp then
21112: LD_VAR 0 2
21116: NOT
21117: IFFALSE 21121
// exit ;
21119: GO 21158
// DestroyUnit ( tmp [ 1 ] ) ;
21121: LD_VAR 0 2
21125: PUSH
21126: LD_INT 1
21128: ARRAY
21129: PPUSH
21130: CALL_OW 65
// end ; 5 .. 7 :
21134: GO 21158
21136: LD_INT 5
21138: DOUBLE
21139: GREATEREQUAL
21140: IFFALSE 21148
21142: LD_INT 7
21144: DOUBLE
21145: LESSEQUAL
21146: IFTRUE 21150
21148: GO 21157
21150: POP
// StreamSibBomb ; end ;
21151: CALL 17438 0 0
21155: GO 21158
21157: POP
// end ;
21158: PPOPN 3
21160: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
21161: LD_EXP 43
21165: PUSH
21166: LD_EXP 93
21170: AND
21171: IFFALSE 21327
21173: GO 21175
21175: DISABLE
21176: LD_INT 0
21178: PPUSH
21179: PPUSH
21180: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
21181: LD_ADDR_VAR 0 2
21185: PUSH
21186: LD_INT 81
21188: PUSH
21189: LD_OWVAR 2
21193: PUSH
21194: EMPTY
21195: LIST
21196: LIST
21197: PUSH
21198: LD_INT 2
21200: PUSH
21201: LD_INT 21
21203: PUSH
21204: LD_INT 1
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: LD_INT 21
21213: PUSH
21214: LD_INT 2
21216: PUSH
21217: EMPTY
21218: LIST
21219: LIST
21220: PUSH
21221: EMPTY
21222: LIST
21223: LIST
21224: LIST
21225: PUSH
21226: EMPTY
21227: LIST
21228: LIST
21229: PPUSH
21230: CALL_OW 69
21234: ST_TO_ADDR
// if not tmp then
21235: LD_VAR 0 2
21239: NOT
21240: IFFALSE 21244
// exit ;
21242: GO 21327
// p := 0 ;
21244: LD_ADDR_VAR 0 3
21248: PUSH
21249: LD_INT 0
21251: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21252: LD_INT 35
21254: PPUSH
21255: CALL_OW 67
// p := p + 1 ;
21259: LD_ADDR_VAR 0 3
21263: PUSH
21264: LD_VAR 0 3
21268: PUSH
21269: LD_INT 1
21271: PLUS
21272: ST_TO_ADDR
// for i in tmp do
21273: LD_ADDR_VAR 0 1
21277: PUSH
21278: LD_VAR 0 2
21282: PUSH
21283: FOR_IN
21284: IFFALSE 21315
// if GetLives ( i ) < 1000 then
21286: LD_VAR 0 1
21290: PPUSH
21291: CALL_OW 256
21295: PUSH
21296: LD_INT 1000
21298: LESS
21299: IFFALSE 21313
// SetLives ( i , 1000 ) ;
21301: LD_VAR 0 1
21305: PPUSH
21306: LD_INT 1000
21308: PPUSH
21309: CALL_OW 234
21313: GO 21283
21315: POP
21316: POP
// until p > 20 ;
21317: LD_VAR 0 3
21321: PUSH
21322: LD_INT 20
21324: GREATER
21325: IFFALSE 21252
// end ;
21327: PPOPN 3
21329: END
// every 0 0$1 trigger StreamModeActive and sTime do
21330: LD_EXP 43
21334: PUSH
21335: LD_EXP 94
21339: AND
21340: IFFALSE 21375
21342: GO 21344
21344: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21345: LD_INT 28
21347: PPUSH
21348: LD_OWVAR 2
21352: PPUSH
21353: LD_INT 2
21355: PPUSH
21356: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21360: LD_INT 30
21362: PPUSH
21363: LD_OWVAR 2
21367: PPUSH
21368: LD_INT 2
21370: PPUSH
21371: CALL_OW 322
// end ;
21375: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21376: LD_EXP 43
21380: PUSH
21381: LD_EXP 95
21385: AND
21386: IFFALSE 21507
21388: GO 21390
21390: DISABLE
21391: LD_INT 0
21393: PPUSH
21394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21395: LD_ADDR_VAR 0 2
21399: PUSH
21400: LD_INT 22
21402: PUSH
21403: LD_OWVAR 2
21407: PUSH
21408: EMPTY
21409: LIST
21410: LIST
21411: PUSH
21412: LD_INT 21
21414: PUSH
21415: LD_INT 1
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: PUSH
21422: LD_INT 3
21424: PUSH
21425: LD_INT 23
21427: PUSH
21428: LD_INT 0
21430: PUSH
21431: EMPTY
21432: LIST
21433: LIST
21434: PUSH
21435: EMPTY
21436: LIST
21437: LIST
21438: PUSH
21439: EMPTY
21440: LIST
21441: LIST
21442: LIST
21443: PPUSH
21444: CALL_OW 69
21448: ST_TO_ADDR
// if not tmp then
21449: LD_VAR 0 2
21453: NOT
21454: IFFALSE 21458
// exit ;
21456: GO 21507
// for i in tmp do
21458: LD_ADDR_VAR 0 1
21462: PUSH
21463: LD_VAR 0 2
21467: PUSH
21468: FOR_IN
21469: IFFALSE 21505
// begin if Crawls ( i ) then
21471: LD_VAR 0 1
21475: PPUSH
21476: CALL_OW 318
21480: IFFALSE 21491
// ComWalk ( i ) ;
21482: LD_VAR 0 1
21486: PPUSH
21487: CALL_OW 138
// SetClass ( i , 2 ) ;
21491: LD_VAR 0 1
21495: PPUSH
21496: LD_INT 2
21498: PPUSH
21499: CALL_OW 336
// end ;
21503: GO 21468
21505: POP
21506: POP
// end ;
21507: PPOPN 2
21509: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
21510: LD_EXP 43
21514: PUSH
21515: LD_EXP 96
21519: AND
21520: IFFALSE 21801
21522: GO 21524
21524: DISABLE
21525: LD_INT 0
21527: PPUSH
21528: PPUSH
21529: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
21530: LD_OWVAR 2
21534: PPUSH
21535: LD_INT 9
21537: PPUSH
21538: LD_INT 1
21540: PPUSH
21541: LD_INT 1
21543: PPUSH
21544: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
21548: LD_INT 9
21550: PPUSH
21551: LD_OWVAR 2
21555: PPUSH
21556: CALL_OW 343
// uc_side := 9 ;
21560: LD_ADDR_OWVAR 20
21564: PUSH
21565: LD_INT 9
21567: ST_TO_ADDR
// uc_nation := 2 ;
21568: LD_ADDR_OWVAR 21
21572: PUSH
21573: LD_INT 2
21575: ST_TO_ADDR
// hc_name := Dark Warrior ;
21576: LD_ADDR_OWVAR 26
21580: PUSH
21581: LD_STRING Dark Warrior
21583: ST_TO_ADDR
// hc_gallery :=  ;
21584: LD_ADDR_OWVAR 33
21588: PUSH
21589: LD_STRING 
21591: ST_TO_ADDR
// hc_noskilllimit := true ;
21592: LD_ADDR_OWVAR 76
21596: PUSH
21597: LD_INT 1
21599: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
21600: LD_ADDR_OWVAR 31
21604: PUSH
21605: LD_INT 30
21607: PUSH
21608: LD_INT 30
21610: PUSH
21611: LD_INT 30
21613: PUSH
21614: LD_INT 30
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: LIST
21621: LIST
21622: ST_TO_ADDR
// un := CreateHuman ;
21623: LD_ADDR_VAR 0 3
21627: PUSH
21628: CALL_OW 44
21632: ST_TO_ADDR
// hc_noskilllimit := false ;
21633: LD_ADDR_OWVAR 76
21637: PUSH
21638: LD_INT 0
21640: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21641: LD_VAR 0 3
21645: PPUSH
21646: LD_INT 1
21648: PPUSH
21649: CALL_OW 51
// p := 0 ;
21653: LD_ADDR_VAR 0 2
21657: PUSH
21658: LD_INT 0
21660: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21661: LD_INT 35
21663: PPUSH
21664: CALL_OW 67
// p := p + 1 ;
21668: LD_ADDR_VAR 0 2
21672: PUSH
21673: LD_VAR 0 2
21677: PUSH
21678: LD_INT 1
21680: PLUS
21681: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
21682: LD_VAR 0 3
21686: PPUSH
21687: CALL_OW 256
21691: PUSH
21692: LD_INT 1000
21694: LESS
21695: IFFALSE 21709
// SetLives ( un , 1000 ) ;
21697: LD_VAR 0 3
21701: PPUSH
21702: LD_INT 1000
21704: PPUSH
21705: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
21709: LD_VAR 0 3
21713: PPUSH
21714: LD_INT 81
21716: PUSH
21717: LD_OWVAR 2
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: PUSH
21726: LD_INT 91
21728: PUSH
21729: LD_VAR 0 3
21733: PUSH
21734: LD_INT 30
21736: PUSH
21737: EMPTY
21738: LIST
21739: LIST
21740: LIST
21741: PUSH
21742: EMPTY
21743: LIST
21744: LIST
21745: PPUSH
21746: CALL_OW 69
21750: PPUSH
21751: LD_VAR 0 3
21755: PPUSH
21756: CALL_OW 74
21760: PPUSH
21761: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
21765: LD_VAR 0 2
21769: PUSH
21770: LD_INT 60
21772: GREATER
21773: PUSH
21774: LD_VAR 0 3
21778: PPUSH
21779: CALL_OW 301
21783: OR
21784: IFFALSE 21661
// if un then
21786: LD_VAR 0 3
21790: IFFALSE 21801
// RemoveUnit ( un ) ;
21792: LD_VAR 0 3
21796: PPUSH
21797: CALL_OW 64
// end ; end_of_file
21801: PPOPN 3
21803: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
21804: LD_INT 0
21806: PPUSH
21807: PPUSH
21808: PPUSH
21809: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
21810: LD_VAR 0 1
21814: PPUSH
21815: CALL_OW 264
21819: PUSH
21820: LD_EXP 34
21824: EQUAL
21825: IFFALSE 21897
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
21827: LD_INT 68
21829: PPUSH
21830: LD_VAR 0 1
21834: PPUSH
21835: CALL_OW 255
21839: PPUSH
21840: CALL_OW 321
21844: PUSH
21845: LD_INT 2
21847: EQUAL
21848: IFFALSE 21860
// eff := 70 else
21850: LD_ADDR_VAR 0 4
21854: PUSH
21855: LD_INT 70
21857: ST_TO_ADDR
21858: GO 21868
// eff := 30 ;
21860: LD_ADDR_VAR 0 4
21864: PUSH
21865: LD_INT 30
21867: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
21868: LD_VAR 0 1
21872: PPUSH
21873: CALL_OW 250
21877: PPUSH
21878: LD_VAR 0 1
21882: PPUSH
21883: CALL_OW 251
21887: PPUSH
21888: LD_VAR 0 4
21892: PPUSH
21893: CALL_OW 495
// end ; end ;
21897: LD_VAR 0 2
21901: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
21902: LD_INT 0
21904: PPUSH
// end ;
21905: LD_VAR 0 4
21909: RET
// export function SOS_Command ( cmd ) ; begin
21910: LD_INT 0
21912: PPUSH
// end ;
21913: LD_VAR 0 2
21917: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
21918: LD_VAR 0 1
21922: PUSH
21923: LD_INT 255
21925: EQUAL
21926: PUSH
21927: LD_VAR 0 2
21931: PPUSH
21932: CALL_OW 264
21936: PUSH
21937: LD_INT 14
21939: PUSH
21940: LD_INT 53
21942: PUSH
21943: EMPTY
21944: LIST
21945: LIST
21946: IN
21947: AND
21948: PUSH
21949: LD_VAR 0 4
21953: PPUSH
21954: LD_VAR 0 5
21958: PPUSH
21959: CALL_OW 488
21963: AND
21964: IFFALSE 21988
// CutTreeXYR ( unit , x , y , 12 ) ;
21966: LD_VAR 0 2
21970: PPUSH
21971: LD_VAR 0 4
21975: PPUSH
21976: LD_VAR 0 5
21980: PPUSH
21981: LD_INT 12
21983: PPUSH
21984: CALL 21991 0 4
// end ;
21988: PPOPN 5
21990: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
21991: LD_INT 0
21993: PPUSH
21994: PPUSH
21995: PPUSH
21996: PPUSH
21997: PPUSH
21998: PPUSH
21999: PPUSH
22000: PPUSH
22001: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22002: LD_VAR 0 1
22006: NOT
22007: PUSH
22008: LD_VAR 0 2
22012: PPUSH
22013: LD_VAR 0 3
22017: PPUSH
22018: CALL_OW 488
22022: NOT
22023: OR
22024: PUSH
22025: LD_VAR 0 4
22029: NOT
22030: OR
22031: IFFALSE 22035
// exit ;
22033: GO 22375
// list := [ ] ;
22035: LD_ADDR_VAR 0 13
22039: PUSH
22040: EMPTY
22041: ST_TO_ADDR
// if x - r < 0 then
22042: LD_VAR 0 2
22046: PUSH
22047: LD_VAR 0 4
22051: MINUS
22052: PUSH
22053: LD_INT 0
22055: LESS
22056: IFFALSE 22068
// min_x := 0 else
22058: LD_ADDR_VAR 0 7
22062: PUSH
22063: LD_INT 0
22065: ST_TO_ADDR
22066: GO 22084
// min_x := x - r ;
22068: LD_ADDR_VAR 0 7
22072: PUSH
22073: LD_VAR 0 2
22077: PUSH
22078: LD_VAR 0 4
22082: MINUS
22083: ST_TO_ADDR
// if y - r < 0 then
22084: LD_VAR 0 3
22088: PUSH
22089: LD_VAR 0 4
22093: MINUS
22094: PUSH
22095: LD_INT 0
22097: LESS
22098: IFFALSE 22110
// min_y := 0 else
22100: LD_ADDR_VAR 0 8
22104: PUSH
22105: LD_INT 0
22107: ST_TO_ADDR
22108: GO 22126
// min_y := y - r ;
22110: LD_ADDR_VAR 0 8
22114: PUSH
22115: LD_VAR 0 3
22119: PUSH
22120: LD_VAR 0 4
22124: MINUS
22125: ST_TO_ADDR
// max_x := x + r ;
22126: LD_ADDR_VAR 0 9
22130: PUSH
22131: LD_VAR 0 2
22135: PUSH
22136: LD_VAR 0 4
22140: PLUS
22141: ST_TO_ADDR
// max_y := y + r ;
22142: LD_ADDR_VAR 0 10
22146: PUSH
22147: LD_VAR 0 3
22151: PUSH
22152: LD_VAR 0 4
22156: PLUS
22157: ST_TO_ADDR
// for _x = min_x to max_x do
22158: LD_ADDR_VAR 0 11
22162: PUSH
22163: DOUBLE
22164: LD_VAR 0 7
22168: DEC
22169: ST_TO_ADDR
22170: LD_VAR 0 9
22174: PUSH
22175: FOR_TO
22176: IFFALSE 22293
// for _y = min_y to max_y do
22178: LD_ADDR_VAR 0 12
22182: PUSH
22183: DOUBLE
22184: LD_VAR 0 8
22188: DEC
22189: ST_TO_ADDR
22190: LD_VAR 0 10
22194: PUSH
22195: FOR_TO
22196: IFFALSE 22289
// begin if not ValidHex ( _x , _y ) then
22198: LD_VAR 0 11
22202: PPUSH
22203: LD_VAR 0 12
22207: PPUSH
22208: CALL_OW 488
22212: NOT
22213: IFFALSE 22217
// continue ;
22215: GO 22195
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22217: LD_VAR 0 11
22221: PPUSH
22222: LD_VAR 0 12
22226: PPUSH
22227: CALL_OW 351
22231: PUSH
22232: LD_VAR 0 11
22236: PPUSH
22237: LD_VAR 0 12
22241: PPUSH
22242: CALL_OW 554
22246: AND
22247: IFFALSE 22287
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22249: LD_ADDR_VAR 0 13
22253: PUSH
22254: LD_VAR 0 13
22258: PPUSH
22259: LD_VAR 0 13
22263: PUSH
22264: LD_INT 1
22266: PLUS
22267: PPUSH
22268: LD_VAR 0 11
22272: PUSH
22273: LD_VAR 0 12
22277: PUSH
22278: EMPTY
22279: LIST
22280: LIST
22281: PPUSH
22282: CALL_OW 2
22286: ST_TO_ADDR
// end ;
22287: GO 22195
22289: POP
22290: POP
22291: GO 22175
22293: POP
22294: POP
// if not list then
22295: LD_VAR 0 13
22299: NOT
22300: IFFALSE 22304
// exit ;
22302: GO 22375
// for i in list do
22304: LD_ADDR_VAR 0 6
22308: PUSH
22309: LD_VAR 0 13
22313: PUSH
22314: FOR_IN
22315: IFFALSE 22373
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22317: LD_VAR 0 1
22321: PPUSH
22322: LD_STRING M
22324: PUSH
22325: LD_VAR 0 6
22329: PUSH
22330: LD_INT 1
22332: ARRAY
22333: PUSH
22334: LD_VAR 0 6
22338: PUSH
22339: LD_INT 2
22341: ARRAY
22342: PUSH
22343: LD_INT 0
22345: PUSH
22346: LD_INT 0
22348: PUSH
22349: LD_INT 0
22351: PUSH
22352: LD_INT 0
22354: PUSH
22355: EMPTY
22356: LIST
22357: LIST
22358: LIST
22359: LIST
22360: LIST
22361: LIST
22362: LIST
22363: PUSH
22364: EMPTY
22365: LIST
22366: PPUSH
22367: CALL_OW 447
22371: GO 22314
22373: POP
22374: POP
// end ;
22375: LD_VAR 0 5
22379: RET
