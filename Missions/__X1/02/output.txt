// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 596 0 0
// PrepareAmericans ;
  23: CALL 893 0 0
// PrepareArabian ;
  27: CALL 11081 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 214 0 0
// Action ;
  41: CALL 4703 0 0
// end ;
  45: END
// export debug , prefix , missionStart , aviradzeSpotted , deltaSpotted , spottedBeforeRadio , sciSpotted , aviradzeQuestDone , sciCounterKill , usAlert , usActiveDefend , gladstoneEscaped , timeUntilFarmer , attackDeltaAllowed , trickyMove , usPatrol , trap , lostCounter ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := false ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// aviradzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 7
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 9
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// aviradzeQuestDone := false ;
  97: LD_ADDR_EXP 8
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// attackDeltaAllowed := false ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// usAlert := false ;
 113: LD_ADDR_EXP 10
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// usActiveDefend := false ;
 121: LD_ADDR_EXP 11
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// usPatrol := [ ] ;
 129: LD_ADDR_EXP 16
 133: PUSH
 134: EMPTY
 135: ST_TO_ADDR
// timeUntilFarmer := [ 40 40$00 , 30 30$00 , 20 20$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 13
 140: PUSH
 141: LD_INT 84000
 143: PUSH
 144: LD_INT 63000
 146: PUSH
 147: LD_INT 42000
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// trickyMove := false ;
 161: LD_ADDR_EXP 15
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// gladstoneEscaped := false ;
 169: LD_ADDR_EXP 12
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// prefix := 01_ ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 01_
 184: ST_TO_ADDR
// trap := 0 ;
 185: LD_ADDR_EXP 17
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// lostCounter := false ;
 193: LD_ADDR_EXP 18
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// spottedBeforeRadio := false ;
 201: LD_ADDR_EXP 6
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// end ;
 209: LD_VAR 0 1
 213: RET
// function DebugMode ; begin
 214: LD_INT 0
 216: PPUSH
// FogOff ( 1 ) ;
 217: LD_INT 1
 219: PPUSH
 220: CALL_OW 344
// Difficulty := 2 ;
 224: LD_ADDR_OWVAR 67
 228: PUSH
 229: LD_INT 2
 231: ST_TO_ADDR
// end ; end_of_file
 232: LD_VAR 0 1
 236: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 237: LD_INT 0
 239: PPUSH
 240: PPUSH
// if exist_mode then
 241: LD_VAR 0 2
 245: IFFALSE 270
// unit := CreateCharacter ( prefix & ident ) else
 247: LD_ADDR_VAR 0 5
 251: PUSH
 252: LD_VAR 0 3
 256: PUSH
 257: LD_VAR 0 1
 261: STR
 262: PPUSH
 263: CALL_OW 34
 267: ST_TO_ADDR
 268: GO 285
// unit := NewCharacter ( ident ) ;
 270: LD_ADDR_VAR 0 5
 274: PUSH
 275: LD_VAR 0 1
 279: PPUSH
 280: CALL_OW 25
 284: ST_TO_ADDR
// result := unit ;
 285: LD_ADDR_VAR 0 4
 289: PUSH
 290: LD_VAR 0 5
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 4
 299: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 300: LD_INT 0
 302: PPUSH
// uc_side := side ;
 303: LD_ADDR_OWVAR 20
 307: PUSH
 308: LD_VAR 0 1
 312: ST_TO_ADDR
// uc_nation := nation ;
 313: LD_ADDR_OWVAR 21
 317: PUSH
 318: LD_VAR 0 2
 322: ST_TO_ADDR
// vc_chassis := chassis ;
 323: LD_ADDR_OWVAR 37
 327: PUSH
 328: LD_VAR 0 3
 332: ST_TO_ADDR
// vc_engine := engine ;
 333: LD_ADDR_OWVAR 39
 337: PUSH
 338: LD_VAR 0 4
 342: ST_TO_ADDR
// vc_control := control ;
 343: LD_ADDR_OWVAR 38
 347: PUSH
 348: LD_VAR 0 5
 352: ST_TO_ADDR
// vc_weapon := weapon ;
 353: LD_ADDR_OWVAR 40
 357: PUSH
 358: LD_VAR 0 6
 362: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 363: LD_ADDR_OWVAR 41
 367: PUSH
 368: LD_VAR 0 7
 372: ST_TO_ADDR
// result := CreateVehicle ;
 373: LD_ADDR_VAR 0 8
 377: PUSH
 378: CALL_OW 45
 382: ST_TO_ADDR
// end ;
 383: LD_VAR 0 8
 387: RET
// export function SayX ( units , ident ) ; var i ; begin
 388: LD_INT 0
 390: PPUSH
 391: PPUSH
// result := false ;
 392: LD_ADDR_VAR 0 3
 396: PUSH
 397: LD_INT 0
 399: ST_TO_ADDR
// if not units then
 400: LD_VAR 0 1
 404: NOT
 405: IFFALSE 409
// exit ;
 407: GO 463
// for i in units do
 409: LD_ADDR_VAR 0 4
 413: PUSH
 414: LD_VAR 0 1
 418: PUSH
 419: FOR_IN
 420: IFFALSE 461
// if IsOk ( i ) then
 422: LD_VAR 0 4
 426: PPUSH
 427: CALL_OW 302
 431: IFFALSE 459
// begin Say ( i , ident ) ;
 433: LD_VAR 0 4
 437: PPUSH
 438: LD_VAR 0 2
 442: PPUSH
 443: CALL_OW 88
// result := i ;
 447: LD_ADDR_VAR 0 3
 451: PUSH
 452: LD_VAR 0 4
 456: ST_TO_ADDR
// break ;
 457: GO 461
// end ;
 459: GO 419
 461: POP
 462: POP
// end ;
 463: LD_VAR 0 3
 467: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 468: LD_INT 0
 470: PPUSH
 471: PPUSH
// InitUc ;
 472: CALL_OW 18
// InitHc ;
 476: CALL_OW 19
// uc_side := 0 ;
 480: LD_ADDR_OWVAR 20
 484: PUSH
 485: LD_INT 0
 487: ST_TO_ADDR
// uc_nation := 0 ;
 488: LD_ADDR_OWVAR 21
 492: PUSH
 493: LD_INT 0
 495: ST_TO_ADDR
// for i = 1 to amount do
 496: LD_ADDR_VAR 0 4
 500: PUSH
 501: DOUBLE
 502: LD_INT 1
 504: DEC
 505: ST_TO_ADDR
 506: LD_VAR 0 2
 510: PUSH
 511: FOR_TO
 512: IFFALSE 585
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 514: LD_ADDR_OWVAR 29
 518: PUSH
 519: LD_INT 9
 521: PPUSH
 522: LD_INT 12
 524: PPUSH
 525: CALL_OW 12
 529: PUSH
 530: LD_INT 9
 532: PPUSH
 533: LD_INT 12
 535: PPUSH
 536: CALL_OW 12
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: ST_TO_ADDR
// hc_agressivity := 0 ;
 545: LD_ADDR_OWVAR 35
 549: PUSH
 550: LD_INT 0
 552: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 553: LD_INT 0
 555: PPUSH
 556: LD_INT 12
 558: PPUSH
 559: LD_INT 1
 561: PPUSH
 562: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 566: CALL_OW 44
 570: PPUSH
 571: LD_VAR 0 1
 575: PPUSH
 576: LD_INT 0
 578: PPUSH
 579: CALL_OW 49
// end ;
 583: GO 511
 585: POP
 586: POP
// InitHc ;
 587: CALL_OW 19
// end ;
 591: LD_VAR 0 3
 595: RET
// export function PrepareNature ; var i ; begin
 596: LD_INT 0
 598: PPUSH
 599: PPUSH
// SpawnApeman ( forest , 9 ) ;
 600: LD_INT 1
 602: PPUSH
 603: LD_INT 9
 605: PPUSH
 606: CALL 468 0 2
// for i := 1 to 4 do
 610: LD_ADDR_VAR 0 2
 614: PUSH
 615: DOUBLE
 616: LD_INT 1
 618: DEC
 619: ST_TO_ADDR
 620: LD_INT 4
 622: PUSH
 623: FOR_TO
 624: IFFALSE 659
// begin hc_class := 21 ;
 626: LD_ADDR_OWVAR 28
 630: PUSH
 631: LD_INT 21
 633: ST_TO_ADDR
// hc_gallery :=  ;
 634: LD_ADDR_OWVAR 33
 638: PUSH
 639: LD_STRING 
 641: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 642: CALL_OW 44
 646: PPUSH
 647: LD_INT 1
 649: PPUSH
 650: LD_INT 0
 652: PPUSH
 653: CALL_OW 49
// end ;
 657: GO 623
 659: POP
 660: POP
// for i := 1 to 2 do
 661: LD_ADDR_VAR 0 2
 665: PUSH
 666: DOUBLE
 667: LD_INT 1
 669: DEC
 670: ST_TO_ADDR
 671: LD_INT 2
 673: PUSH
 674: FOR_TO
 675: IFFALSE 710
// begin hc_class := 18 ;
 677: LD_ADDR_OWVAR 28
 681: PUSH
 682: LD_INT 18
 684: ST_TO_ADDR
// hc_gallery :=  ;
 685: LD_ADDR_OWVAR 33
 689: PUSH
 690: LD_STRING 
 692: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 693: CALL_OW 44
 697: PPUSH
 698: LD_INT 1
 700: PPUSH
 701: LD_INT 0
 703: PPUSH
 704: CALL_OW 49
// end ;
 708: GO 674
 710: POP
 711: POP
// for i := 1 to 3 do
 712: LD_ADDR_VAR 0 2
 716: PUSH
 717: DOUBLE
 718: LD_INT 1
 720: DEC
 721: ST_TO_ADDR
 722: LD_INT 3
 724: PUSH
 725: FOR_TO
 726: IFFALSE 761
// begin hc_class := 13 ;
 728: LD_ADDR_OWVAR 28
 732: PUSH
 733: LD_INT 13
 735: ST_TO_ADDR
// hc_gallery :=  ;
 736: LD_ADDR_OWVAR 33
 740: PUSH
 741: LD_STRING 
 743: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 744: CALL_OW 44
 748: PPUSH
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL_OW 49
// end ;
 759: GO 725
 761: POP
 762: POP
// for i := 1 to 4 do
 763: LD_ADDR_VAR 0 2
 767: PUSH
 768: DOUBLE
 769: LD_INT 1
 771: DEC
 772: ST_TO_ADDR
 773: LD_INT 4
 775: PUSH
 776: FOR_TO
 777: IFFALSE 812
// begin hc_class := class_frog ;
 779: LD_ADDR_OWVAR 28
 783: PUSH
 784: LD_INT 19
 786: ST_TO_ADDR
// hc_gallery :=  ;
 787: LD_ADDR_OWVAR 33
 791: PUSH
 792: LD_STRING 
 794: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , swampArea , false ) ;
 795: CALL_OW 44
 799: PPUSH
 800: LD_INT 8
 802: PPUSH
 803: LD_INT 0
 805: PPUSH
 806: CALL_OW 49
// end ;
 810: GO 776
 812: POP
 813: POP
// end ;
 814: LD_VAR 0 1
 818: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 819: LD_INT 0
 821: PPUSH
 822: PPUSH
 823: PPUSH
// if not observer or not unit then
 824: LD_VAR 0 1
 828: NOT
 829: PUSH
 830: LD_VAR 0 2
 834: NOT
 835: OR
 836: IFFALSE 840
// exit ;
 838: GO 888
// if not See ( GetSide ( observer ) , unit ) then
 840: LD_VAR 0 1
 844: PPUSH
 845: CALL_OW 255
 849: PPUSH
 850: LD_VAR 0 2
 854: PPUSH
 855: CALL_OW 292
 859: NOT
 860: IFFALSE 864
// exit ;
 862: GO 888
// result := GetDistUnits ( observer , unit ) < 12 ;
 864: LD_ADDR_VAR 0 3
 868: PUSH
 869: LD_VAR 0 1
 873: PPUSH
 874: LD_VAR 0 2
 878: PPUSH
 879: CALL_OW 296
 883: PUSH
 884: LD_INT 12
 886: LESS
 887: ST_TO_ADDR
// end ; end_of_file
 888: LD_VAR 0 3
 892: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp , arm ; begin
 893: LD_INT 0
 895: PPUSH
 896: PPUSH
 897: PPUSH
 898: PPUSH
 899: PPUSH
 900: PPUSH
// usForces := [ ] ;
 901: LD_ADDR_EXP 21
 905: PUSH
 906: EMPTY
 907: ST_TO_ADDR
// usSci := [ ] ;
 908: LD_ADDR_EXP 22
 912: PUSH
 913: EMPTY
 914: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 915: LD_INT 1
 917: PPUSH
 918: LD_STRING Delta
 920: PPUSH
 921: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 925: LD_INT 1
 927: PPUSH
 928: CALL_OW 274
 932: PPUSH
 933: LD_INT 1
 935: PPUSH
 936: LD_INT 400
 938: PPUSH
 939: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 943: LD_INT 1
 945: PPUSH
 946: CALL_OW 274
 950: PPUSH
 951: LD_INT 2
 953: PPUSH
 954: LD_INT 80
 956: PPUSH
 957: CALL_OW 277
// uc_side := 1 ;
 961: LD_ADDR_OWVAR 20
 965: PUSH
 966: LD_INT 1
 968: ST_TO_ADDR
// uc_nation := 1 ;
 969: LD_ADDR_OWVAR 21
 973: PUSH
 974: LD_INT 1
 976: ST_TO_ADDR
// InitHc ;
 977: CALL_OW 19
// hc_importance := 0 ;
 981: LD_ADDR_OWVAR 32
 985: PUSH
 986: LD_INT 0
 988: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 989: LD_ADDR_EXP 20
 993: PUSH
 994: LD_STRING Lynch
 996: PPUSH
 997: LD_INT 0
 999: PPUSH
1000: LD_STRING 
1002: PPUSH
1003: CALL 237 0 3
1007: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
1008: LD_ADDR_EXP 19
1012: PUSH
1013: LD_STRING Gladstone
1015: PPUSH
1016: LD_INT 0
1018: PPUSH
1019: LD_STRING 
1021: PPUSH
1022: CALL 237 0 3
1026: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
1027: LD_EXP 20
1031: PPUSH
1032: LD_INT 1
1034: PPUSH
1035: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
1039: LD_EXP 19
1043: PPUSH
1044: LD_INT 3
1046: PPUSH
1047: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: DOUBLE
1057: LD_INT 1
1059: DEC
1060: ST_TO_ADDR
1061: LD_INT 1
1063: PUSH
1064: LD_INT 2
1066: PUSH
1067: LD_INT 2
1069: PUSH
1070: EMPTY
1071: LIST
1072: LIST
1073: LIST
1074: PUSH
1075: LD_OWVAR 67
1079: ARRAY
1080: PUSH
1081: FOR_TO
1082: IFFALSE 1128
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1084: LD_INT 0
1086: PPUSH
1087: LD_INT 2
1089: PPUSH
1090: LD_INT 1
1092: PUSH
1093: LD_INT 2
1095: PUSH
1096: LD_INT 2
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: PUSH
1104: LD_OWVAR 67
1108: ARRAY
1109: PPUSH
1110: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
1114: CALL_OW 44
1118: PPUSH
1119: LD_INT 1
1121: PPUSH
1122: CALL_OW 52
// end ;
1126: GO 1081
1128: POP
1129: POP
// for i := 1 to 7 - Difficulty do
1130: LD_ADDR_VAR 0 2
1134: PUSH
1135: DOUBLE
1136: LD_INT 1
1138: DEC
1139: ST_TO_ADDR
1140: LD_INT 7
1142: PUSH
1143: LD_OWVAR 67
1147: MINUS
1148: PUSH
1149: FOR_TO
1150: IFFALSE 1235
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1152: LD_INT 0
1154: PPUSH
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 1
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: LD_INT 2
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: LD_OWVAR 67
1176: ARRAY
1177: PPUSH
1178: CALL_OW 380
// un := CreateHuman ;
1182: LD_ADDR_VAR 0 3
1186: PUSH
1187: CALL_OW 44
1191: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
1192: LD_VAR 0 3
1196: PPUSH
1197: LD_INT 3
1199: PPUSH
1200: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
1204: LD_ADDR_EXP 22
1208: PUSH
1209: LD_EXP 22
1213: PPUSH
1214: LD_EXP 22
1218: PUSH
1219: LD_INT 1
1221: PLUS
1222: PPUSH
1223: LD_VAR 0 3
1227: PPUSH
1228: CALL_OW 1
1232: ST_TO_ADDR
// end ;
1233: GO 1149
1235: POP
1236: POP
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
1237: LD_ADDR_VAR 0 6
1241: PUSH
1242: LD_INT 22
1244: PUSH
1245: LD_INT 1
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 30
1254: PUSH
1255: LD_INT 4
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL_OW 69
1270: ST_TO_ADDR
// for i := 1 to 3 + Difficulty do
1271: LD_ADDR_VAR 0 2
1275: PUSH
1276: DOUBLE
1277: LD_INT 1
1279: DEC
1280: ST_TO_ADDR
1281: LD_INT 3
1283: PUSH
1284: LD_OWVAR 67
1288: PLUS
1289: PUSH
1290: FOR_TO
1291: IFFALSE 1369
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1293: LD_INT 0
1295: PPUSH
1296: LD_INT 1
1298: PPUSH
1299: LD_INT 1
1301: PUSH
1302: LD_INT 2
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: EMPTY
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: LD_OWVAR 67
1317: ARRAY
1318: PPUSH
1319: CALL_OW 380
// un := CreateHuman ;
1323: LD_ADDR_VAR 0 3
1327: PUSH
1328: CALL_OW 44
1332: ST_TO_ADDR
// usForces := usForces ^ un ;
1333: LD_ADDR_EXP 21
1337: PUSH
1338: LD_EXP 21
1342: PUSH
1343: LD_VAR 0 3
1347: ADD
1348: ST_TO_ADDR
// PlaceHumanInUnit ( un , arm [ 1 ] ) ;
1349: LD_VAR 0 3
1353: PPUSH
1354: LD_VAR 0 6
1358: PUSH
1359: LD_INT 1
1361: ARRAY
1362: PPUSH
1363: CALL_OW 52
// end ;
1367: GO 1290
1369: POP
1370: POP
// if Difficulty > 1 then
1371: LD_OWVAR 67
1375: PUSH
1376: LD_INT 1
1378: GREATER
1379: IFFALSE 1472
// begin for i := 1 to 3 do
1381: LD_ADDR_VAR 0 2
1385: PUSH
1386: DOUBLE
1387: LD_INT 1
1389: DEC
1390: ST_TO_ADDR
1391: LD_INT 3
1393: PUSH
1394: FOR_TO
1395: IFFALSE 1470
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1397: LD_INT 0
1399: PPUSH
1400: LD_INT 1
1402: PPUSH
1403: LD_INT 1
1405: PUSH
1406: LD_INT 2
1408: PUSH
1409: LD_INT 3
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: LIST
1416: PUSH
1417: LD_OWVAR 67
1421: ARRAY
1422: PPUSH
1423: CALL_OW 380
// un := CreateHuman ;
1427: LD_ADDR_VAR 0 3
1431: PUSH
1432: CALL_OW 44
1436: ST_TO_ADDR
// usForces := usForces ^ un ;
1437: LD_ADDR_EXP 21
1441: PUSH
1442: LD_EXP 21
1446: PUSH
1447: LD_VAR 0 3
1451: ADD
1452: ST_TO_ADDR
// PlaceUnitArea ( un , usAdditionalDefenceArea , false ) ;
1453: LD_VAR 0 3
1457: PPUSH
1458: LD_INT 9
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// end ;
1468: GO 1394
1470: POP
1471: POP
// end ; PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1472: LD_INT 1
1474: PPUSH
1475: LD_INT 1
1477: PPUSH
1478: LD_INT 1
1480: PPUSH
1481: LD_INT 2
1483: PPUSH
1484: LD_INT 1
1486: PPUSH
1487: LD_INT 2
1489: PPUSH
1490: LD_INT 100
1492: PPUSH
1493: CALL 300 0 7
// veh := CreateVehicle ;
1497: LD_ADDR_VAR 0 4
1501: PUSH
1502: CALL_OW 45
1506: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1507: LD_VAR 0 4
1511: PPUSH
1512: LD_INT 2
1514: PPUSH
1515: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 24 , false ) ;
1519: LD_VAR 0 4
1523: PPUSH
1524: LD_INT 43
1526: PPUSH
1527: LD_INT 24
1529: PPUSH
1530: LD_INT 0
1532: PPUSH
1533: CALL_OW 48
// end ;
1537: LD_VAR 0 1
1541: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1542: LD_INT 0
1544: PPUSH
1545: PPUSH
1546: PPUSH
1547: PPUSH
1548: PPUSH
1549: PPUSH
// if not usSci then
1550: LD_EXP 22
1554: NOT
1555: IFFALSE 1559
// exit ;
1557: GO 1733
// xy := AreaToList ( tameArea , 0 ) ;
1559: LD_ADDR_VAR 0 6
1563: PUSH
1564: LD_INT 5
1566: PPUSH
1567: LD_INT 0
1569: PPUSH
1570: CALL_OW 517
1574: ST_TO_ADDR
// for i in usSci do
1575: LD_ADDR_VAR 0 2
1579: PUSH
1580: LD_EXP 22
1584: PUSH
1585: FOR_IN
1586: IFFALSE 1731
// begin k := rand ( 1 , xy [ 1 ] ) ;
1588: LD_ADDR_VAR 0 4
1592: PUSH
1593: LD_INT 1
1595: PPUSH
1596: LD_VAR 0 6
1600: PUSH
1601: LD_INT 1
1603: ARRAY
1604: PPUSH
1605: CALL_OW 12
1609: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1610: LD_VAR 0 2
1614: PPUSH
1615: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1619: LD_VAR 0 2
1623: PPUSH
1624: LD_VAR 0 6
1628: PUSH
1629: LD_INT 1
1631: ARRAY
1632: PUSH
1633: LD_VAR 0 4
1637: ARRAY
1638: PPUSH
1639: LD_VAR 0 6
1643: PUSH
1644: LD_INT 2
1646: ARRAY
1647: PUSH
1648: LD_VAR 0 4
1652: ARRAY
1653: PPUSH
1654: CALL_OW 171
// for j := 1 to 2 do
1658: LD_ADDR_VAR 0 3
1662: PUSH
1663: DOUBLE
1664: LD_INT 1
1666: DEC
1667: ST_TO_ADDR
1668: LD_INT 2
1670: PUSH
1671: FOR_TO
1672: IFFALSE 1727
// begin tmp := Delete ( xy [ j ] , k ) ;
1674: LD_ADDR_VAR 0 5
1678: PUSH
1679: LD_VAR 0 6
1683: PUSH
1684: LD_VAR 0 3
1688: ARRAY
1689: PPUSH
1690: LD_VAR 0 4
1694: PPUSH
1695: CALL_OW 3
1699: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1700: LD_ADDR_VAR 0 6
1704: PUSH
1705: LD_VAR 0 6
1709: PPUSH
1710: LD_VAR 0 3
1714: PPUSH
1715: LD_VAR 0 5
1719: PPUSH
1720: CALL_OW 1
1724: ST_TO_ADDR
// end ;
1725: GO 1671
1727: POP
1728: POP
// end ;
1729: GO 1585
1731: POP
1732: POP
// end ;
1733: LD_VAR 0 1
1737: RET
// every 0 0$5 + 0 0$10 trigger aviradzeSpotted and usSci and not usAlert and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1738: LD_EXP 4
1742: PUSH
1743: LD_EXP 22
1747: AND
1748: PUSH
1749: LD_EXP 10
1753: NOT
1754: AND
1755: PUSH
1756: LD_INT 22
1758: PUSH
1759: LD_INT 0
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: PUSH
1766: LD_INT 25
1768: PUSH
1769: LD_INT 12
1771: PUSH
1772: EMPTY
1773: LIST
1774: LIST
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: PPUSH
1780: CALL_OW 69
1784: AND
1785: IFFALSE 2277
1787: GO 1789
1789: DISABLE
1790: LD_INT 0
1792: PPUSH
1793: PPUSH
1794: PPUSH
1795: PPUSH
1796: PPUSH
// begin enable ;
1797: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1798: LD_EXP 22
1802: PPUSH
1803: LD_INT 2
1805: PUSH
1806: LD_INT 60
1808: PUSH
1809: EMPTY
1810: LIST
1811: PUSH
1812: LD_INT 54
1814: PUSH
1815: EMPTY
1816: LIST
1817: PUSH
1818: EMPTY
1819: LIST
1820: LIST
1821: LIST
1822: PPUSH
1823: CALL_OW 72
1827: IFFALSE 1831
// exit ;
1829: GO 2277
// for i in usSci do
1831: LD_ADDR_VAR 0 1
1835: PUSH
1836: LD_EXP 22
1840: PUSH
1841: FOR_IN
1842: IFFALSE 2275
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1844: LD_VAR 0 1
1848: PPUSH
1849: CALL_OW 314
1853: NOT
1854: PUSH
1855: LD_VAR 0 1
1859: PPUSH
1860: CALL_OW 256
1864: PUSH
1865: LD_INT 1000
1867: EQUAL
1868: AND
1869: IFFALSE 2076
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1871: LD_ADDR_VAR 0 5
1875: PUSH
1876: LD_INT 22
1878: PUSH
1879: LD_INT 0
1881: PUSH
1882: EMPTY
1883: LIST
1884: LIST
1885: PUSH
1886: LD_INT 25
1888: PUSH
1889: LD_INT 12
1891: PUSH
1892: EMPTY
1893: LIST
1894: LIST
1895: PUSH
1896: EMPTY
1897: LIST
1898: LIST
1899: PPUSH
1900: CALL_OW 69
1904: PPUSH
1905: LD_VAR 0 1
1909: PPUSH
1910: CALL_OW 74
1914: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1915: LD_VAR 0 1
1919: PPUSH
1920: LD_VAR 0 5
1924: PPUSH
1925: CALL_OW 296
1929: PUSH
1930: LD_INT 10
1932: LESS
1933: IFFALSE 1966
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1935: LD_VAR 0 1
1939: PPUSH
1940: LD_VAR 0 5
1944: PPUSH
1945: CALL_OW 250
1949: PPUSH
1950: LD_VAR 0 5
1954: PPUSH
1955: CALL_OW 251
1959: PPUSH
1960: CALL_OW 131
1964: GO 2076
// begin d := rand ( 0 , 5 ) ;
1966: LD_ADDR_VAR 0 4
1970: PUSH
1971: LD_INT 0
1973: PPUSH
1974: LD_INT 5
1976: PPUSH
1977: CALL_OW 12
1981: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1982: LD_ADDR_VAR 0 2
1986: PUSH
1987: LD_VAR 0 1
1991: PPUSH
1992: CALL_OW 250
1996: PPUSH
1997: LD_VAR 0 4
2001: PPUSH
2002: LD_INT 3
2004: PPUSH
2005: CALL_OW 272
2009: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
2010: LD_ADDR_VAR 0 3
2014: PUSH
2015: LD_VAR 0 1
2019: PPUSH
2020: CALL_OW 251
2024: PPUSH
2025: LD_VAR 0 4
2029: PPUSH
2030: LD_INT 3
2032: PPUSH
2033: CALL_OW 273
2037: ST_TO_ADDR
// if not ValidHex ( x , y ) then
2038: LD_VAR 0 2
2042: PPUSH
2043: LD_VAR 0 3
2047: PPUSH
2048: CALL_OW 488
2052: NOT
2053: IFFALSE 2057
// continue ;
2055: GO 1841
// ComMoveXY ( i , x , y ) ;
2057: LD_VAR 0 1
2061: PPUSH
2062: LD_VAR 0 2
2066: PPUSH
2067: LD_VAR 0 3
2071: PPUSH
2072: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
2076: LD_VAR 0 1
2080: PPUSH
2081: CALL_OW 256
2085: PUSH
2086: LD_INT 900
2088: LESS
2089: PUSH
2090: LD_VAR 0 1
2094: PPUSH
2095: LD_INT 37
2097: PPUSH
2098: LD_INT 23
2100: PPUSH
2101: CALL_OW 297
2105: PUSH
2106: LD_INT 10
2108: GREATER
2109: AND
2110: IFFALSE 2186
// begin if IsOk ( Gladstone ) and IsInUnit ( Gladstone ) then
2112: LD_EXP 19
2116: PPUSH
2117: CALL_OW 302
2121: PUSH
2122: LD_EXP 19
2126: PPUSH
2127: CALL_OW 310
2131: AND
2132: IFFALSE 2143
// ComExitBuilding ( Gladstone ) ;
2134: LD_EXP 19
2138: PPUSH
2139: CALL_OW 122
// AddComHeal ( Gladstone , i ) ;
2143: LD_EXP 19
2147: PPUSH
2148: LD_VAR 0 1
2152: PPUSH
2153: CALL_OW 188
// AddComEnterUnit ( Gladstone , usLab ) ;
2157: LD_EXP 19
2161: PPUSH
2162: LD_INT 3
2164: PPUSH
2165: CALL_OW 180
// ComMoveXY ( i , 37 , 23 ) ;
2169: LD_VAR 0 1
2173: PPUSH
2174: LD_INT 37
2176: PPUSH
2177: LD_INT 23
2179: PPUSH
2180: CALL_OW 111
// end else
2184: GO 2273
// if GetLives ( i ) = 1000 then
2186: LD_VAR 0 1
2190: PPUSH
2191: CALL_OW 256
2195: PUSH
2196: LD_INT 1000
2198: EQUAL
2199: IFFALSE 2273
// begin if SideShoot ( i ) = 2 then
2201: LD_VAR 0 1
2205: PPUSH
2206: CALL_OW 503
2210: PUSH
2211: LD_INT 2
2213: EQUAL
2214: IFFALSE 2261
// begin if not usAlert then
2216: LD_EXP 10
2220: NOT
2221: IFFALSE 2231
// usAlert := true ;
2223: LD_ADDR_EXP 10
2227: PUSH
2228: LD_INT 1
2230: ST_TO_ADDR
// AddComEnterUnit ( i , usLab ) ;
2231: LD_VAR 0 1
2235: PPUSH
2236: LD_INT 3
2238: PPUSH
2239: CALL_OW 180
// usSci := usSci diff i ;
2243: LD_ADDR_EXP 22
2247: PUSH
2248: LD_EXP 22
2252: PUSH
2253: LD_VAR 0 1
2257: DIFF
2258: ST_TO_ADDR
// end else
2259: GO 2273
// ComMoveToArea ( i , tameArea ) ;
2261: LD_VAR 0 1
2265: PPUSH
2266: LD_INT 5
2268: PPUSH
2269: CALL_OW 113
// end ; end ;
2273: GO 1841
2275: POP
2276: POP
// end ;
2277: PPOPN 5
2279: END
// every 0 0$1 trigger not usAlert and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 999 ] ] ] ) or FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) ) do
2280: LD_EXP 10
2284: NOT
2285: PUSH
2286: LD_INT 22
2288: PUSH
2289: LD_INT 1
2291: PUSH
2292: EMPTY
2293: LIST
2294: LIST
2295: PUSH
2296: LD_INT 21
2298: PUSH
2299: LD_INT 3
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: LD_INT 3
2308: PUSH
2309: LD_INT 57
2311: PUSH
2312: EMPTY
2313: LIST
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PUSH
2319: LD_INT 3
2321: PUSH
2322: LD_INT 24
2324: PUSH
2325: LD_INT 999
2327: PUSH
2328: EMPTY
2329: LIST
2330: LIST
2331: PUSH
2332: EMPTY
2333: LIST
2334: LIST
2335: PUSH
2336: EMPTY
2337: LIST
2338: LIST
2339: LIST
2340: LIST
2341: PPUSH
2342: CALL_OW 69
2346: PUSH
2347: LD_INT 7
2349: PPUSH
2350: LD_INT 22
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: PPUSH
2360: CALL_OW 70
2364: OR
2365: AND
2366: IFFALSE 2379
2368: GO 2370
2370: DISABLE
// usAlert := true ;
2371: LD_ADDR_EXP 10
2375: PUSH
2376: LD_INT 1
2378: ST_TO_ADDR
2379: END
// every 0 0$1 trigger usAlert do var i , b , arm ;
2380: LD_EXP 10
2384: IFFALSE 2731
2386: GO 2388
2388: DISABLE
2389: LD_INT 0
2391: PPUSH
2392: PPUSH
2393: PPUSH
// begin usActiveDefend := true ;
2394: LD_ADDR_EXP 11
2398: PUSH
2399: LD_INT 1
2401: ST_TO_ADDR
// if not usForces then
2402: LD_EXP 21
2406: NOT
2407: IFFALSE 2411
// exit ;
2409: GO 2731
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
2411: LD_ADDR_VAR 0 3
2415: PUSH
2416: LD_INT 22
2418: PUSH
2419: LD_INT 1
2421: PUSH
2422: EMPTY
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 30
2428: PUSH
2429: LD_INT 4
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PPUSH
2440: CALL_OW 69
2444: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_INT 22
2452: PUSH
2453: LD_INT 1
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: PUSH
2460: LD_INT 30
2462: PUSH
2463: LD_INT 31
2465: PUSH
2466: EMPTY
2467: LIST
2468: LIST
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: PPUSH
2474: CALL_OW 69
2478: ST_TO_ADDR
// ComExitBuilding ( Lynch ) ;
2479: LD_EXP 20
2483: PPUSH
2484: CALL_OW 122
// AddComEnterUnit ( Lynch , arm [ 1 ] ) ;
2488: LD_EXP 20
2492: PPUSH
2493: LD_VAR 0 3
2497: PUSH
2498: LD_INT 1
2500: ARRAY
2501: PPUSH
2502: CALL_OW 180
// if IsOk ( Gladstone ) then
2506: LD_EXP 19
2510: PPUSH
2511: CALL_OW 302
2515: IFFALSE 2556
// begin ComExitBuilding ( Gladstone ) ;
2517: LD_EXP 19
2521: PPUSH
2522: CALL_OW 122
// AddComEnterUnit ( Gladstone , arm [ 1 ] ) ;
2526: LD_EXP 19
2530: PPUSH
2531: LD_VAR 0 3
2535: PUSH
2536: LD_INT 1
2538: ARRAY
2539: PPUSH
2540: CALL_OW 180
// AddComChangeProfession ( Gladstone , class_soldier ) ;
2544: LD_EXP 19
2548: PPUSH
2549: LD_INT 1
2551: PPUSH
2552: CALL_OW 183
// end ; ComExitBuilding ( usForces [ 1 ] ) ;
2556: LD_EXP 21
2560: PUSH
2561: LD_INT 1
2563: ARRAY
2564: PPUSH
2565: CALL_OW 122
// AddComEnterUnit ( usForces [ 1 ] , b [ 1 ] ) ;
2569: LD_EXP 21
2573: PUSH
2574: LD_INT 1
2576: ARRAY
2577: PPUSH
2578: LD_VAR 0 2
2582: PUSH
2583: LD_INT 1
2585: ARRAY
2586: PPUSH
2587: CALL_OW 180
// ComExitBuilding ( usForces [ 2 ] ) ;
2591: LD_EXP 21
2595: PUSH
2596: LD_INT 2
2598: ARRAY
2599: PPUSH
2600: CALL_OW 122
// AddComEnterUnit ( usForces [ 2 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
2604: LD_EXP 21
2608: PUSH
2609: LD_INT 2
2611: ARRAY
2612: PPUSH
2613: LD_INT 22
2615: PUSH
2616: LD_INT 1
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: PUSH
2623: LD_INT 30
2625: PUSH
2626: LD_INT 32
2628: PUSH
2629: EMPTY
2630: LIST
2631: LIST
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: PPUSH
2637: CALL_OW 69
2641: PUSH
2642: LD_INT 1
2644: ARRAY
2645: PPUSH
2646: CALL_OW 180
// if b > 1 and usForces > 2 then
2650: LD_VAR 0 2
2654: PUSH
2655: LD_INT 1
2657: GREATER
2658: PUSH
2659: LD_EXP 21
2663: PUSH
2664: LD_INT 2
2666: GREATER
2667: AND
2668: IFFALSE 2731
// begin repeat wait ( 0 0$1 ) ;
2670: LD_INT 35
2672: PPUSH
2673: CALL_OW 67
// until BuildingStatus ( b [ 2 ] ) <> bs_build ;
2677: LD_VAR 0 2
2681: PUSH
2682: LD_INT 2
2684: ARRAY
2685: PPUSH
2686: CALL_OW 461
2690: PUSH
2691: LD_INT 1
2693: NONEQUAL
2694: IFFALSE 2670
// ComExitBuilding ( usForces [ 3 ] ) ;
2696: LD_EXP 21
2700: PUSH
2701: LD_INT 3
2703: ARRAY
2704: PPUSH
2705: CALL_OW 122
// AddComEnterUnit ( usForces [ 3 ] , b [ 2 ] ) ;
2709: LD_EXP 21
2713: PUSH
2714: LD_INT 3
2716: ARRAY
2717: PPUSH
2718: LD_VAR 0 2
2722: PUSH
2723: LD_INT 2
2725: ARRAY
2726: PPUSH
2727: CALL_OW 180
// end ; end ;
2731: PPOPN 3
2733: END
// every 0 0$1 trigger GetLives ( usLab ) < 999 and usAlert and usForces do var i ;
2734: LD_INT 3
2736: PPUSH
2737: CALL_OW 256
2741: PUSH
2742: LD_INT 999
2744: LESS
2745: PUSH
2746: LD_EXP 10
2750: AND
2751: PUSH
2752: LD_EXP 21
2756: AND
2757: IFFALSE 2928
2759: GO 2761
2761: DISABLE
2762: LD_INT 0
2764: PPUSH
// begin for i in usForces do
2765: LD_ADDR_VAR 0 1
2769: PUSH
2770: LD_EXP 21
2774: PUSH
2775: FOR_IN
2776: IFFALSE 2815
// begin if IsInUnit ( i ) then
2778: LD_VAR 0 1
2782: PPUSH
2783: CALL_OW 310
2787: IFFALSE 2798
// ComExitBuilding ( i ) ;
2789: LD_VAR 0 1
2793: PPUSH
2794: CALL_OW 122
// AddComAgressiveMove ( i , 31 , 8 ) ;
2798: LD_VAR 0 1
2802: PPUSH
2803: LD_INT 31
2805: PPUSH
2806: LD_INT 8
2808: PPUSH
2809: CALL_OW 174
// end ;
2813: GO 2775
2815: POP
2816: POP
// wait ( 0 0$8 ) ;
2817: LD_INT 280
2819: PPUSH
2820: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) then
2824: LD_INT 22
2826: PUSH
2827: LD_INT 2
2829: PUSH
2830: EMPTY
2831: LIST
2832: LIST
2833: PUSH
2834: LD_INT 91
2836: PUSH
2837: LD_INT 3
2839: PUSH
2840: LD_INT 14
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: LIST
2847: PUSH
2848: EMPTY
2849: LIST
2850: LIST
2851: PPUSH
2852: CALL_OW 69
2856: IFFALSE 2906
// ComAttackUnit ( usForces , FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) [ 1 ] ) else
2858: LD_EXP 21
2862: PPUSH
2863: LD_INT 22
2865: PUSH
2866: LD_INT 2
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: PUSH
2873: LD_INT 91
2875: PUSH
2876: LD_INT 3
2878: PUSH
2879: LD_INT 14
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: LIST
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: PPUSH
2891: CALL_OW 69
2895: PUSH
2896: LD_INT 1
2898: ARRAY
2899: PPUSH
2900: CALL_OW 115
2904: GO 2928
// begin wait ( 0 0$20 ) ;
2906: LD_INT 700
2908: PPUSH
2909: CALL_OW 67
// AddComMoveXY ( usForces , 39 , 19 ) ;
2913: LD_EXP 21
2917: PPUSH
2918: LD_INT 39
2920: PPUSH
2921: LD_INT 19
2923: PPUSH
2924: CALL_OW 171
// end ; end ;
2928: PPOPN 1
2930: END
// every 0 0$3 trigger ( GetDistUnits ( Heike , Delta ) < 10 or GetLives ( usLab ) < 999 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do var tmp , veh ;
2931: LD_EXP 23
2935: PPUSH
2936: LD_INT 1
2938: PPUSH
2939: CALL_OW 296
2943: PUSH
2944: LD_INT 10
2946: LESS
2947: PUSH
2948: LD_INT 3
2950: PPUSH
2951: CALL_OW 256
2955: PUSH
2956: LD_INT 999
2958: LESS
2959: OR
2960: PUSH
2961: LD_INT 22
2963: PUSH
2964: LD_INT 1
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: LD_INT 25
2973: PUSH
2974: LD_INT 2
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: PPUSH
2985: CALL_OW 69
2989: AND
2990: IFFALSE 3104
2992: GO 2994
2994: DISABLE
2995: LD_INT 0
2997: PPUSH
2998: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
2999: LD_ADDR_VAR 0 1
3003: PUSH
3004: LD_INT 22
3006: PUSH
3007: LD_INT 1
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: PUSH
3014: LD_INT 25
3016: PUSH
3017: LD_INT 2
3019: PUSH
3020: EMPTY
3021: LIST
3022: LIST
3023: PUSH
3024: EMPTY
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL_OW 69
3032: ST_TO_ADDR
// veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
3033: LD_ADDR_VAR 0 2
3037: PUSH
3038: LD_INT 22
3040: PUSH
3041: LD_INT 1
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PUSH
3048: LD_INT 21
3050: PUSH
3051: LD_INT 2
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: PUSH
3058: LD_INT 58
3060: PUSH
3061: EMPTY
3062: LIST
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: PPUSH
3069: CALL_OW 69
3073: ST_TO_ADDR
// if not tmp then
3074: LD_VAR 0 1
3078: NOT
3079: IFFALSE 3083
// exit ;
3081: GO 3104
// ComExitBuilding ( tmp ) ;
3083: LD_VAR 0 1
3087: PPUSH
3088: CALL_OW 122
// AddComDismantle ( tmp , usLab ) ;
3092: LD_VAR 0 1
3096: PPUSH
3097: LD_INT 3
3099: PPUSH
3100: CALL_OW 227
// end ;
3104: PPOPN 2
3106: END
// every 0 0$1 trigger usAlert and FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) do var i , tmp ;
3107: LD_EXP 10
3111: PUSH
3112: LD_INT 7
3114: PPUSH
3115: LD_INT 22
3117: PUSH
3118: LD_INT 1
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: PUSH
3125: LD_INT 21
3127: PUSH
3128: LD_INT 1
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: PUSH
3135: LD_INT 3
3137: PUSH
3138: LD_INT 24
3140: PUSH
3141: LD_INT 600
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: PUSH
3152: EMPTY
3153: LIST
3154: LIST
3155: LIST
3156: PPUSH
3157: CALL_OW 70
3161: AND
3162: IFFALSE 3290
3164: GO 3166
3166: DISABLE
3167: LD_INT 0
3169: PPUSH
3170: PPUSH
// begin enable ;
3171: ENABLE
// tmp := FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) ;
3172: LD_ADDR_VAR 0 2
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 22
3182: PUSH
3183: LD_INT 1
3185: PUSH
3186: EMPTY
3187: LIST
3188: LIST
3189: PUSH
3190: LD_INT 21
3192: PUSH
3193: LD_INT 1
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: LD_INT 3
3202: PUSH
3203: LD_INT 24
3205: PUSH
3206: LD_INT 600
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: PPUSH
3222: CALL_OW 70
3226: ST_TO_ADDR
// if not tmp then
3227: LD_VAR 0 2
3231: NOT
3232: IFFALSE 3236
// exit ;
3234: GO 3290
// for i in tmp do
3236: LD_ADDR_VAR 0 1
3240: PUSH
3241: LD_VAR 0 2
3245: PUSH
3246: FOR_IN
3247: IFFALSE 3288
// if IsInUnit ( i ) then
3249: LD_VAR 0 1
3253: PPUSH
3254: CALL_OW 310
3258: IFFALSE 3271
// ComExitBuilding ( i ) else
3260: LD_VAR 0 1
3264: PPUSH
3265: CALL_OW 122
3269: GO 3286
// ComMoveXY ( i , 48 , 74 ) ;
3271: LD_VAR 0 1
3275: PPUSH
3276: LD_INT 48
3278: PPUSH
3279: LD_INT 74
3281: PPUSH
3282: CALL_OW 111
3286: GO 3246
3288: POP
3289: POP
// end ;
3290: PPOPN 2
3292: END
// every 6 6$00 do var i , un , tmp ;
3293: GO 3295
3295: DISABLE
3296: LD_INT 0
3298: PPUSH
3299: PPUSH
3300: PPUSH
// begin tmp := [ ] ;
3301: LD_ADDR_VAR 0 3
3305: PUSH
3306: EMPTY
3307: ST_TO_ADDR
// uc_side := 1 ;
3308: LD_ADDR_OWVAR 20
3312: PUSH
3313: LD_INT 1
3315: ST_TO_ADDR
// uc_nation := 1 ;
3316: LD_ADDR_OWVAR 21
3320: PUSH
3321: LD_INT 1
3323: ST_TO_ADDR
// case Difficulty of 1 :
3324: LD_OWVAR 67
3328: PUSH
3329: LD_INT 1
3331: DOUBLE
3332: EQUAL
3333: IFTRUE 3337
3335: GO 3440
3337: POP
// begin wait ( 1 1$00 ) ;
3338: LD_INT 2100
3340: PPUSH
3341: CALL_OW 67
// for i := 1 to 2 do
3345: LD_ADDR_VAR 0 1
3349: PUSH
3350: DOUBLE
3351: LD_INT 1
3353: DEC
3354: ST_TO_ADDR
3355: LD_INT 2
3357: PUSH
3358: FOR_TO
3359: IFFALSE 3436
// begin PrepareHuman ( false , [ 1 , 4 ] [ i mod 2 + 1 ] , 1 ) ;
3361: LD_INT 0
3363: PPUSH
3364: LD_INT 1
3366: PUSH
3367: LD_INT 4
3369: PUSH
3370: EMPTY
3371: LIST
3372: LIST
3373: PUSH
3374: LD_VAR 0 1
3378: PUSH
3379: LD_INT 2
3381: MOD
3382: PUSH
3383: LD_INT 1
3385: PLUS
3386: ARRAY
3387: PPUSH
3388: LD_INT 1
3390: PPUSH
3391: CALL_OW 380
// un := CreateHuman ;
3395: LD_ADDR_VAR 0 2
3399: PUSH
3400: CALL_OW 44
3404: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3405: LD_ADDR_VAR 0 3
3409: PUSH
3410: LD_VAR 0 3
3414: PPUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 1
3422: PLUS
3423: PPUSH
3424: LD_VAR 0 2
3428: PPUSH
3429: CALL_OW 1
3433: ST_TO_ADDR
// end ;
3434: GO 3358
3436: POP
3437: POP
// end ; 2 :
3438: GO 3834
3440: LD_INT 2
3442: DOUBLE
3443: EQUAL
3444: IFTRUE 3448
3446: GO 3582
3448: POP
// begin wait ( 0 0$30 ) ;
3449: LD_INT 1050
3451: PPUSH
3452: CALL_OW 67
// for i := 1 to 2 do
3456: LD_ADDR_VAR 0 1
3460: PUSH
3461: DOUBLE
3462: LD_INT 1
3464: DEC
3465: ST_TO_ADDR
3466: LD_INT 2
3468: PUSH
3469: FOR_TO
3470: IFFALSE 3526
// begin PrepareHuman ( false , 1 , 2 ) ;
3472: LD_INT 0
3474: PPUSH
3475: LD_INT 1
3477: PPUSH
3478: LD_INT 2
3480: PPUSH
3481: CALL_OW 380
// un := CreateHuman ;
3485: LD_ADDR_VAR 0 2
3489: PUSH
3490: CALL_OW 44
3494: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3495: LD_ADDR_VAR 0 3
3499: PUSH
3500: LD_VAR 0 3
3504: PPUSH
3505: LD_VAR 0 3
3509: PUSH
3510: LD_INT 1
3512: PLUS
3513: PPUSH
3514: LD_VAR 0 2
3518: PPUSH
3519: CALL_OW 1
3523: ST_TO_ADDR
// end ;
3524: GO 3469
3526: POP
3527: POP
// PrepareHuman ( false , 4 , 2 ) ;
3528: LD_INT 0
3530: PPUSH
3531: LD_INT 4
3533: PPUSH
3534: LD_INT 2
3536: PPUSH
3537: CALL_OW 380
// un := CreateHuman ;
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: CALL_OW 44
3550: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3551: LD_ADDR_VAR 0 3
3555: PUSH
3556: LD_VAR 0 3
3560: PPUSH
3561: LD_VAR 0 3
3565: PUSH
3566: LD_INT 1
3568: PLUS
3569: PPUSH
3570: LD_VAR 0 2
3574: PPUSH
3575: CALL_OW 1
3579: ST_TO_ADDR
// end ; 3 :
3580: GO 3834
3582: LD_INT 3
3584: DOUBLE
3585: EQUAL
3586: IFTRUE 3590
3588: GO 3833
3590: POP
// begin for i := 1 to 2 do
3591: LD_ADDR_VAR 0 1
3595: PUSH
3596: DOUBLE
3597: LD_INT 1
3599: DEC
3600: ST_TO_ADDR
3601: LD_INT 2
3603: PUSH
3604: FOR_TO
3605: IFFALSE 3661
// begin PrepareHuman ( false , 1 , 2 ) ;
3607: LD_INT 0
3609: PPUSH
3610: LD_INT 1
3612: PPUSH
3613: LD_INT 2
3615: PPUSH
3616: CALL_OW 380
// un := CreateHuman ;
3620: LD_ADDR_VAR 0 2
3624: PUSH
3625: CALL_OW 44
3629: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3630: LD_ADDR_VAR 0 3
3634: PUSH
3635: LD_VAR 0 3
3639: PPUSH
3640: LD_VAR 0 3
3644: PUSH
3645: LD_INT 1
3647: PLUS
3648: PPUSH
3649: LD_VAR 0 2
3653: PPUSH
3654: CALL_OW 1
3658: ST_TO_ADDR
// end ;
3659: GO 3604
3661: POP
3662: POP
// PrepareHuman ( false , 4 , 2 ) ;
3663: LD_INT 0
3665: PPUSH
3666: LD_INT 4
3668: PPUSH
3669: LD_INT 2
3671: PPUSH
3672: CALL_OW 380
// un := CreateHuman ;
3676: LD_ADDR_VAR 0 2
3680: PUSH
3681: CALL_OW 44
3685: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3686: LD_ADDR_VAR 0 3
3690: PUSH
3691: LD_VAR 0 3
3695: PPUSH
3696: LD_VAR 0 3
3700: PUSH
3701: LD_INT 1
3703: PLUS
3704: PPUSH
3705: LD_VAR 0 2
3709: PPUSH
3710: CALL_OW 1
3714: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_machine_gun , 90 ) ;
3715: LD_INT 1
3717: PPUSH
3718: LD_INT 1
3720: PPUSH
3721: LD_INT 2
3723: PPUSH
3724: LD_INT 2
3726: PPUSH
3727: LD_INT 1
3729: PPUSH
3730: LD_INT 2
3732: PPUSH
3733: LD_INT 90
3735: PPUSH
3736: CALL 300 0 7
// un := CreateVehicle ;
3740: LD_ADDR_VAR 0 2
3744: PUSH
3745: CALL_OW 45
3749: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3750: LD_ADDR_VAR 0 3
3754: PUSH
3755: LD_VAR 0 3
3759: PPUSH
3760: LD_VAR 0 3
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 2
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// PrepareHuman ( false , 1 , 2 ) ;
3779: LD_INT 0
3781: PPUSH
3782: LD_INT 1
3784: PPUSH
3785: LD_INT 2
3787: PPUSH
3788: CALL_OW 380
// un := CreateHuman ;
3792: LD_ADDR_VAR 0 2
3796: PUSH
3797: CALL_OW 44
3801: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: LD_VAR 0 3
3811: PPUSH
3812: LD_VAR 0 3
3816: PUSH
3817: LD_INT 1
3819: PLUS
3820: PPUSH
3821: LD_VAR 0 2
3825: PPUSH
3826: CALL_OW 1
3830: ST_TO_ADDR
// end ; end ;
3831: GO 3834
3833: POP
// for i := 1 to tmp do
3834: LD_ADDR_VAR 0 1
3838: PUSH
3839: DOUBLE
3840: LD_INT 1
3842: DEC
3843: ST_TO_ADDR
3844: LD_VAR 0 3
3848: PUSH
3849: FOR_TO
3850: IFFALSE 4015
// begin SetDir ( tmp [ i ] , 1 ) ;
3852: LD_VAR 0 3
3856: PUSH
3857: LD_VAR 0 1
3861: ARRAY
3862: PPUSH
3863: LD_INT 1
3865: PPUSH
3866: CALL_OW 233
// if GetType ( tmp [ i ] ) = unit_human then
3870: LD_VAR 0 3
3874: PUSH
3875: LD_VAR 0 1
3879: ARRAY
3880: PPUSH
3881: CALL_OW 247
3885: PUSH
3886: LD_INT 1
3888: EQUAL
3889: IFFALSE 3917
// PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) else
3891: LD_VAR 0 3
3895: PUSH
3896: LD_VAR 0 1
3900: ARRAY
3901: PPUSH
3902: LD_INT 28
3904: PPUSH
3905: LD_INT 52
3907: PPUSH
3908: LD_INT 0
3910: PPUSH
3911: CALL_OW 48
3915: GO 3985
// begin PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) ;
3917: LD_VAR 0 3
3921: PUSH
3922: LD_VAR 0 1
3926: ARRAY
3927: PPUSH
3928: LD_INT 28
3930: PPUSH
3931: LD_INT 52
3933: PPUSH
3934: LD_INT 0
3936: PPUSH
3937: CALL_OW 48
// i := i + 1 ;
3941: LD_ADDR_VAR 0 1
3945: PUSH
3946: LD_VAR 0 1
3950: PUSH
3951: LD_INT 1
3953: PLUS
3954: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ i ] , tmp [ i - 1 ] ) ;
3955: LD_VAR 0 3
3959: PUSH
3960: LD_VAR 0 1
3964: ARRAY
3965: PPUSH
3966: LD_VAR 0 3
3970: PUSH
3971: LD_VAR 0 1
3975: PUSH
3976: LD_INT 1
3978: MINUS
3979: ARRAY
3980: PPUSH
3981: CALL_OW 52
// end ; ComMoveXY ( tmp [ i ] , 43 , 56 ) ;
3985: LD_VAR 0 3
3989: PUSH
3990: LD_VAR 0 1
3994: ARRAY
3995: PPUSH
3996: LD_INT 43
3998: PPUSH
3999: LD_INT 56
4001: PPUSH
4002: CALL_OW 111
// wait ( 0 0$2 ) ;
4006: LD_INT 70
4008: PPUSH
4009: CALL_OW 67
// end ;
4013: GO 3849
4015: POP
4016: POP
// wait ( 0 0$2 ) ;
4017: LD_INT 70
4019: PPUSH
4020: CALL_OW 67
// if not FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) then
4024: LD_INT 7
4026: PPUSH
4027: LD_INT 22
4029: PUSH
4030: LD_INT 2
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: PPUSH
4037: CALL_OW 70
4041: NOT
4042: IFFALSE 4240
// begin AddComAgressiveMove ( tmp , 35 , 24 ) ;
4044: LD_VAR 0 3
4048: PPUSH
4049: LD_INT 35
4051: PPUSH
4052: LD_INT 24
4054: PPUSH
4055: CALL_OW 174
// usForces := usForces union UnitFilter ( tmp , [ f_class , 1 ] ) ;
4059: LD_ADDR_EXP 21
4063: PUSH
4064: LD_EXP 21
4068: PUSH
4069: LD_VAR 0 3
4073: PPUSH
4074: LD_INT 25
4076: PUSH
4077: LD_INT 1
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PPUSH
4084: CALL_OW 72
4088: UNION
4089: ST_TO_ADDR
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
4090: LD_INT 22
4092: PUSH
4093: LD_INT 1
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 30
4102: PUSH
4103: LD_INT 4
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 69
4118: PUSH
4119: LD_INT 1
4121: ARRAY
4122: PPUSH
4123: CALL_OW 313
4127: PUSH
4128: LD_INT 6
4130: LESS
4131: IFFALSE 4190
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
4133: LD_VAR 0 3
4137: PPUSH
4138: LD_INT 25
4140: PUSH
4141: LD_INT 1
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PPUSH
4148: CALL_OW 72
4152: PPUSH
4153: LD_INT 22
4155: PUSH
4156: LD_INT 1
4158: PUSH
4159: EMPTY
4160: LIST
4161: LIST
4162: PUSH
4163: LD_INT 30
4165: PUSH
4166: LD_INT 4
4168: PUSH
4169: EMPTY
4170: LIST
4171: LIST
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PPUSH
4177: CALL_OW 69
4181: PUSH
4182: LD_INT 1
4184: ARRAY
4185: PPUSH
4186: CALL_OW 180
// if UnitFilter ( tmp , [ f_class , 4 ] ) then
4190: LD_VAR 0 3
4194: PPUSH
4195: LD_INT 25
4197: PUSH
4198: LD_INT 4
4200: PUSH
4201: EMPTY
4202: LIST
4203: LIST
4204: PPUSH
4205: CALL_OW 72
4209: IFFALSE 4238
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 4 ] ) , usLab ) ;
4211: LD_VAR 0 3
4215: PPUSH
4216: LD_INT 25
4218: PUSH
4219: LD_INT 4
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: PPUSH
4226: CALL_OW 72
4230: PPUSH
4231: LD_INT 3
4233: PPUSH
4234: CALL_OW 180
// end else
4238: GO 4515
// begin tmp := tmp union FilterUnitsInArea ( retreatArea , [ f_side , 1 ] ) ;
4240: LD_ADDR_VAR 0 3
4244: PUSH
4245: LD_VAR 0 3
4249: PUSH
4250: LD_INT 6
4252: PPUSH
4253: LD_INT 22
4255: PUSH
4256: LD_INT 1
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: PPUSH
4263: CALL_OW 70
4267: UNION
4268: ST_TO_ADDR
// ComMoveXY ( tmp , 45 , 54 ) ;
4269: LD_VAR 0 3
4273: PPUSH
4274: LD_INT 45
4276: PPUSH
4277: LD_INT 54
4279: PPUSH
4280: CALL_OW 111
// wait ( 0 0$3 ) ;
4284: LD_INT 105
4286: PPUSH
4287: CALL_OW 67
// AddComAgressiveMove ( tmp diff UnitFilter ( tmp , [ f_class , 4 ] ) , 35 , 24 ) ;
4291: LD_VAR 0 3
4295: PUSH
4296: LD_VAR 0 3
4300: PPUSH
4301: LD_INT 25
4303: PUSH
4304: LD_INT 4
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: PPUSH
4311: CALL_OW 72
4315: DIFF
4316: PPUSH
4317: LD_INT 35
4319: PPUSH
4320: LD_INT 24
4322: PPUSH
4323: CALL_OW 174
// AddComMoveXY ( UnitFilter ( tmp , [ f_class , 4 ] ) , 42 , 49 ) ;
4327: LD_VAR 0 3
4331: PPUSH
4332: LD_INT 25
4334: PUSH
4335: LD_INT 4
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PPUSH
4342: CALL_OW 72
4346: PPUSH
4347: LD_INT 42
4349: PPUSH
4350: LD_INT 49
4352: PPUSH
4353: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4357: LD_INT 35
4359: PPUSH
4360: CALL_OW 67
// for i in tmp do
4364: LD_ADDR_VAR 0 1
4368: PUSH
4369: LD_VAR 0 3
4373: PUSH
4374: FOR_IN
4375: IFFALSE 4506
// if IsDead ( i ) then
4377: LD_VAR 0 1
4381: PPUSH
4382: CALL_OW 301
4386: IFFALSE 4406
// tmp := tmp diff i else
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: LD_VAR 0 3
4397: PUSH
4398: LD_VAR 0 1
4402: DIFF
4403: ST_TO_ADDR
4404: GO 4504
// if GetClass ( i ) = 1 then
4406: LD_VAR 0 1
4410: PPUSH
4411: CALL_OW 257
4415: PUSH
4416: LD_INT 1
4418: EQUAL
4419: IFFALSE 4504
// begin if GetLives ( i ) < 600 and GetDistUnitXY ( i , 42 , 49 ) > 6 then
4421: LD_VAR 0 1
4425: PPUSH
4426: CALL_OW 256
4430: PUSH
4431: LD_INT 600
4433: LESS
4434: PUSH
4435: LD_VAR 0 1
4439: PPUSH
4440: LD_INT 42
4442: PPUSH
4443: LD_INT 49
4445: PPUSH
4446: CALL_OW 297
4450: PUSH
4451: LD_INT 6
4453: GREATER
4454: AND
4455: IFFALSE 4474
// ComMoveXY ( i , 42 , 49 ) else
4457: LD_VAR 0 1
4461: PPUSH
4462: LD_INT 42
4464: PPUSH
4465: LD_INT 49
4467: PPUSH
4468: CALL_OW 111
4472: GO 4504
// if GetLives ( i ) = 1000 then
4474: LD_VAR 0 1
4478: PPUSH
4479: CALL_OW 256
4483: PUSH
4484: LD_INT 1000
4486: EQUAL
4487: IFFALSE 4504
// ComAgressiveMove ( i , 36 , 25 ) ;
4489: LD_VAR 0 1
4493: PPUSH
4494: LD_INT 36
4496: PPUSH
4497: LD_INT 25
4499: PPUSH
4500: CALL_OW 114
// end ;
4504: GO 4374
4506: POP
4507: POP
// until not tmp ;
4508: LD_VAR 0 3
4512: NOT
4513: IFFALSE 4357
// end ; end ;
4515: PPOPN 3
4517: END
// every 0 0$1 trigger FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) and not attackDeltaAllowed do var i , un , veh ;
4518: LD_INT 7
4520: PPUSH
4521: LD_INT 22
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PPUSH
4531: CALL_OW 70
4535: PUSH
4536: LD_EXP 14
4540: NOT
4541: AND
4542: IFFALSE 4700
4544: GO 4546
4546: DISABLE
4547: LD_INT 0
4549: PPUSH
4550: PPUSH
4551: PPUSH
// begin for i := 1 to 2 do
4552: LD_ADDR_VAR 0 1
4556: PUSH
4557: DOUBLE
4558: LD_INT 1
4560: DEC
4561: ST_TO_ADDR
4562: LD_INT 2
4564: PUSH
4565: FOR_TO
4566: IFFALSE 4698
// begin wait ( 0 0$3 ) ;
4568: LD_INT 105
4570: PPUSH
4571: CALL_OW 67
// uc_side := 1 ;
4575: LD_ADDR_OWVAR 20
4579: PUSH
4580: LD_INT 1
4582: ST_TO_ADDR
// uc_nation := 1 ;
4583: LD_ADDR_OWVAR 21
4587: PUSH
4588: LD_INT 1
4590: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 90 ) ;
4591: LD_INT 1
4593: PPUSH
4594: LD_INT 1
4596: PPUSH
4597: LD_INT 2
4599: PPUSH
4600: LD_INT 1
4602: PPUSH
4603: LD_INT 1
4605: PPUSH
4606: LD_INT 4
4608: PPUSH
4609: LD_INT 90
4611: PPUSH
4612: CALL 300 0 7
// veh := CreateVehicle ;
4616: LD_ADDR_VAR 0 3
4620: PUSH
4621: CALL_OW 45
4625: ST_TO_ADDR
// PlaceUnitXY ( veh , 29 , 52 , false ) ;
4626: LD_VAR 0 3
4630: PPUSH
4631: LD_INT 29
4633: PPUSH
4634: LD_INT 52
4636: PPUSH
4637: LD_INT 0
4639: PPUSH
4640: CALL_OW 48
// PrepareHuman ( false , 3 , 3 ) ;
4644: LD_INT 0
4646: PPUSH
4647: LD_INT 3
4649: PPUSH
4650: LD_INT 3
4652: PPUSH
4653: CALL_OW 380
// un := CreateHuman ;
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: CALL_OW 44
4666: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4667: LD_VAR 0 2
4671: PPUSH
4672: LD_VAR 0 3
4676: PPUSH
4677: CALL_OW 52
// ComAgressiveMove ( veh , 36 , 25 ) ;
4681: LD_VAR 0 3
4685: PPUSH
4686: LD_INT 36
4688: PPUSH
4689: LD_INT 25
4691: PPUSH
4692: CALL_OW 114
// end ;
4696: GO 4565
4698: POP
4699: POP
// end ; end_of_file
4700: PPOPN 3
4702: END
// export function Action ; var i , tmp ; begin
4703: LD_INT 0
4705: PPUSH
4706: PPUSH
4707: PPUSH
// InGameOn ;
4708: CALL_OW 8
// DoNotAttack ( 2 , usLab ) ;
4712: LD_INT 2
4714: PPUSH
4715: LD_INT 3
4717: PPUSH
4718: CALL_OW 471
// ComMoveXY ( Heike , 78 , 61 ) ;
4722: LD_EXP 23
4726: PPUSH
4727: LD_INT 78
4729: PPUSH
4730: LD_INT 61
4732: PPUSH
4733: CALL_OW 111
// if Mike then
4737: LD_EXP 25
4741: IFFALSE 4758
// ComMoveXY ( Mike , 80 , 66 ) ;
4743: LD_EXP 25
4747: PPUSH
4748: LD_INT 80
4750: PPUSH
4751: LD_INT 66
4753: PPUSH
4754: CALL_OW 111
// if Givi then
4758: LD_EXP 24
4762: IFFALSE 4779
// ComMoveXY ( Givi , 82 , 66 ) ;
4764: LD_EXP 24
4768: PPUSH
4769: LD_INT 82
4771: PPUSH
4772: LD_INT 66
4774: PPUSH
4775: CALL_OW 111
// if Kamil then
4779: LD_EXP 26
4783: IFFALSE 4800
// ComMoveXY ( Kamil , 82 , 67 ) ;
4785: LD_EXP 26
4789: PPUSH
4790: LD_INT 82
4792: PPUSH
4793: LD_INT 67
4795: PPUSH
4796: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
4800: LD_EXP 23
4804: PPUSH
4805: CALL_OW 87
// wait ( 0 0$2 ) ;
4809: LD_INT 70
4811: PPUSH
4812: CALL_OW 67
// if Givi and Mike then
4816: LD_EXP 24
4820: PUSH
4821: LD_EXP 25
4825: AND
4826: IFFALSE 5272
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4828: LD_EXP 24
4832: PUSH
4833: LD_EXP 25
4837: PUSH
4838: LD_EXP 26
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: LD_EXP 23
4852: PPUSH
4853: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
4857: LD_EXP 23
4861: PPUSH
4862: LD_EXP 24
4866: PPUSH
4867: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
4871: LD_EXP 24
4875: PPUSH
4876: LD_STRING DG-1-start
4878: PPUSH
4879: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
4883: LD_EXP 23
4887: PPUSH
4888: LD_STRING DH-1-start
4890: PPUSH
4891: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
4895: LD_EXP 25
4899: PPUSH
4900: LD_EXP 23
4904: PPUSH
4905: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
4909: LD_EXP 23
4913: PPUSH
4914: LD_EXP 25
4918: PPUSH
4919: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
4923: LD_EXP 25
4927: PPUSH
4928: LD_STRING DM-1-start
4930: PPUSH
4931: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
4935: LD_EXP 23
4939: PPUSH
4940: LD_STRING DH-2-start
4942: PPUSH
4943: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
4947: LD_EXP 25
4951: PPUSH
4952: LD_STRING DM-2-start
4954: PPUSH
4955: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
4959: LD_EXP 24
4963: PPUSH
4964: LD_STRING DG-2-start
4966: PPUSH
4967: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
4971: LD_EXP 25
4975: PPUSH
4976: LD_EXP 24
4980: PPUSH
4981: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
4985: LD_EXP 23
4989: PPUSH
4990: LD_EXP 25
4994: PPUSH
4995: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
4999: LD_EXP 25
5003: PPUSH
5004: LD_STRING DM-3-start
5006: PPUSH
5007: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
5011: LD_EXP 23
5015: PPUSH
5016: LD_STRING DH-3-start
5018: PPUSH
5019: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
5023: LD_EXP 23
5027: PUSH
5028: LD_EXP 25
5032: PUSH
5033: LD_EXP 24
5037: PUSH
5038: LD_EXP 26
5042: PUSH
5043: EMPTY
5044: LIST
5045: LIST
5046: LIST
5047: LIST
5048: PPUSH
5049: LD_INT 84
5051: PPUSH
5052: LD_INT 51
5054: PPUSH
5055: CALL_OW 111
// wait ( 0 0$2 ) ;
5059: LD_INT 70
5061: PPUSH
5062: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
5066: LD_EXP 24
5070: PPUSH
5071: LD_STRING DG-3-start
5073: PPUSH
5074: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
5078: LD_EXP 23
5082: PUSH
5083: LD_EXP 25
5087: PUSH
5088: LD_EXP 24
5092: PUSH
5093: LD_EXP 26
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: PPUSH
5104: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
5108: LD_EXP 23
5112: PPUSH
5113: LD_EXP 24
5117: PPUSH
5118: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
5122: LD_EXP 24
5126: PUSH
5127: LD_EXP 25
5131: PUSH
5132: LD_EXP 26
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: LIST
5141: PPUSH
5142: LD_EXP 23
5146: PPUSH
5147: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
5151: LD_EXP 23
5155: PPUSH
5156: LD_STRING DH-4-start
5158: PPUSH
5159: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
5163: LD_EXP 24
5167: PPUSH
5168: LD_STRING DG-4-start
5170: PPUSH
5171: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
5175: LD_EXP 23
5179: PPUSH
5180: LD_STRING DH-5-start
5182: PPUSH
5183: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
5187: LD_EXP 24
5191: PPUSH
5192: LD_STRING DG-5-start
5194: PPUSH
5195: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
5199: LD_EXP 23
5203: PPUSH
5204: LD_STRING DH-6-start
5206: PPUSH
5207: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
5211: LD_EXP 25
5215: PPUSH
5216: LD_STRING DM-6-start
5218: PPUSH
5219: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
5223: LD_EXP 23
5227: PUSH
5228: LD_EXP 24
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: LD_EXP 25
5241: PPUSH
5242: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
5246: LD_EXP 24
5250: PPUSH
5251: LD_STRING DG-6-start
5253: PPUSH
5254: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
5258: LD_EXP 23
5262: PPUSH
5263: LD_STRING DH-7-start
5265: PPUSH
5266: CALL_OW 88
// end else
5270: GO 5994
// if not Mike and Givi then
5272: LD_EXP 25
5276: NOT
5277: PUSH
5278: LD_EXP 24
5282: AND
5283: IFFALSE 5628
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5285: LD_EXP 24
5289: PUSH
5290: LD_EXP 26
5294: PUSH
5295: EMPTY
5296: LIST
5297: LIST
5298: PPUSH
5299: LD_EXP 23
5303: PPUSH
5304: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
5308: LD_EXP 23
5312: PPUSH
5313: LD_EXP 24
5317: PPUSH
5318: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
5322: LD_EXP 24
5326: PPUSH
5327: LD_STRING DG-1-start-c
5329: PPUSH
5330: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
5334: LD_EXP 23
5338: PPUSH
5339: LD_STRING DH-1-start-c
5341: PPUSH
5342: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
5346: LD_EXP 24
5350: PPUSH
5351: LD_STRING DG-2-start-c
5353: PPUSH
5354: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
5358: LD_EXP 23
5362: PPUSH
5363: LD_STRING DH-2-start-c
5365: PPUSH
5366: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
5370: LD_EXP 24
5374: PPUSH
5375: LD_STRING DG-3-start-c
5377: PPUSH
5378: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
5382: LD_EXP 23
5386: PPUSH
5387: LD_INT 83
5389: PPUSH
5390: LD_INT 56
5392: PPUSH
5393: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
5397: LD_EXP 24
5401: PPUSH
5402: LD_INT 83
5404: PPUSH
5405: LD_INT 59
5407: PPUSH
5408: CALL_OW 111
// if Kamil then
5412: LD_EXP 26
5416: IFFALSE 5433
// ComMoveXY ( Kamil , 80 , 58 ) ;
5418: LD_EXP 26
5422: PPUSH
5423: LD_INT 80
5425: PPUSH
5426: LD_INT 58
5428: PPUSH
5429: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
5433: LD_EXP 23
5437: PPUSH
5438: LD_EXP 24
5442: PPUSH
5443: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5447: LD_EXP 24
5451: PUSH
5452: LD_EXP 26
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: PPUSH
5461: LD_EXP 23
5465: PPUSH
5466: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
5470: LD_EXP 23
5474: PPUSH
5475: LD_STRING DH-3-start-c
5477: PPUSH
5478: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
5482: LD_EXP 24
5486: PPUSH
5487: LD_STRING DG-4-start-c
5489: PPUSH
5490: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
5494: LD_EXP 23
5498: PPUSH
5499: LD_STRING DH-5-start-c
5501: PPUSH
5502: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
5506: LD_EXP 24
5510: PPUSH
5511: LD_STRING DG-5-start-c
5513: PPUSH
5514: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
5518: LD_EXP 23
5522: PPUSH
5523: LD_STRING DH-6-start-c
5525: PPUSH
5526: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
5530: LD_EXP 24
5534: PPUSH
5535: LD_STRING DG-6-start-c
5537: PPUSH
5538: CALL_OW 88
// if Kamil then
5542: LD_EXP 26
5546: IFFALSE 5602
// begin ComTurnUnit ( Kamil , Heike ) ;
5548: LD_EXP 26
5552: PPUSH
5553: LD_EXP 23
5557: PPUSH
5558: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5562: LD_EXP 26
5566: PPUSH
5567: LD_STRING DKam-1-start-c
5569: PPUSH
5570: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
5574: LD_EXP 24
5578: PPUSH
5579: LD_EXP 26
5583: PPUSH
5584: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
5588: LD_EXP 24
5592: PPUSH
5593: LD_STRING DG-7-start-c
5595: PPUSH
5596: CALL_OW 88
// end else
5600: GO 5626
// begin Say ( Givi , DG-8-start-c ) ;
5602: LD_EXP 24
5606: PPUSH
5607: LD_STRING DG-8-start-c
5609: PPUSH
5610: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
5614: LD_EXP 23
5618: PPUSH
5619: LD_STRING DH-7-start-c
5621: PPUSH
5622: CALL_OW 88
// end ; end else
5626: GO 5994
// if not Givi and Mike then
5628: LD_EXP 24
5632: NOT
5633: PUSH
5634: LD_EXP 25
5638: AND
5639: IFFALSE 5898
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
5641: LD_EXP 25
5645: PUSH
5646: LD_EXP 26
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: PPUSH
5655: LD_EXP 23
5659: PPUSH
5660: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
5664: LD_EXP 23
5668: PPUSH
5669: LD_EXP 25
5673: PPUSH
5674: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
5678: LD_EXP 25
5682: PPUSH
5683: LD_STRING DM-1-start-b
5685: PPUSH
5686: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
5690: LD_EXP 23
5694: PPUSH
5695: LD_STRING DH-1-start-b
5697: PPUSH
5698: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
5702: LD_EXP 25
5706: PPUSH
5707: LD_STRING DM-2-start-b
5709: PPUSH
5710: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
5714: LD_EXP 23
5718: PPUSH
5719: LD_STRING DH-2-start-b
5721: PPUSH
5722: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
5726: LD_EXP 25
5730: PPUSH
5731: LD_STRING DM-3-start-b
5733: PPUSH
5734: CALL_OW 88
// if Kamil then
5738: LD_EXP 26
5742: IFFALSE 5759
// ComMoveXY ( Kamil , 80 , 58 ) ;
5744: LD_EXP 26
5748: PPUSH
5749: LD_INT 80
5751: PPUSH
5752: LD_INT 58
5754: PPUSH
5755: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
5759: LD_EXP 23
5763: PPUSH
5764: LD_INT 83
5766: PPUSH
5767: LD_INT 56
5769: PPUSH
5770: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
5774: LD_EXP 25
5778: PPUSH
5779: LD_INT 83
5781: PPUSH
5782: LD_INT 59
5784: PPUSH
5785: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
5789: LD_EXP 23
5793: PPUSH
5794: LD_EXP 25
5798: PPUSH
5799: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
5803: LD_EXP 26
5807: PUSH
5808: LD_EXP 25
5812: PUSH
5813: EMPTY
5814: LIST
5815: LIST
5816: PPUSH
5817: LD_EXP 23
5821: PPUSH
5822: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
5826: LD_EXP 23
5830: PPUSH
5831: LD_STRING DH-3-start-b
5833: PPUSH
5834: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
5838: LD_EXP 25
5842: PPUSH
5843: LD_STRING DM-4-start-b
5845: PPUSH
5846: CALL_OW 88
// if Kamil then
5850: LD_EXP 26
5854: IFFALSE 5884
// begin ComTurnUnit ( Kamil , Heike ) ;
5856: LD_EXP 26
5860: PPUSH
5861: LD_EXP 23
5865: PPUSH
5866: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5870: LD_EXP 26
5874: PPUSH
5875: LD_STRING DKam-1-start-c
5877: PPUSH
5878: CALL_OW 88
// end else
5882: GO 5896
// begin Say ( Mike , DM-5-start-b ) ;
5884: LD_EXP 25
5888: PPUSH
5889: LD_STRING DM-5-start-b
5891: PPUSH
5892: CALL_OW 88
// end ; end else
5896: GO 5994
// if Kamil then
5898: LD_EXP 26
5902: IFFALSE 5982
// begin AddComTurnUnit ( Heike , Kamil ) ;
5904: LD_EXP 23
5908: PPUSH
5909: LD_EXP 26
5913: PPUSH
5914: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
5918: LD_EXP 26
5922: PPUSH
5923: LD_EXP 23
5927: PPUSH
5928: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
5932: LD_EXP 23
5936: PPUSH
5937: LD_STRING DH-1-start-f
5939: PPUSH
5940: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
5944: LD_EXP 26
5948: PPUSH
5949: LD_STRING DKam-1-start-f
5951: PPUSH
5952: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
5956: LD_EXP 23
5960: PPUSH
5961: LD_STRING DH-2-start-f
5963: PPUSH
5964: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
5968: LD_EXP 26
5972: PPUSH
5973: LD_STRING DKam-2-start-f
5975: PPUSH
5976: CALL_OW 88
// end else
5980: GO 5994
// begin Say ( Heike , DH-1-start-d ) ;
5982: LD_EXP 23
5986: PPUSH
5987: LD_STRING DH-1-start-d
5989: PPUSH
5990: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
5994: LD_EXP 23
5998: PUSH
5999: LD_EXP 24
6003: PUSH
6004: LD_EXP 25
6008: PUSH
6009: LD_EXP 26
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: PPUSH
6020: CALL_OW 139
// InGameOff ;
6024: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
6028: LD_STRING OEast
6030: PPUSH
6031: CALL_OW 337
// SaveForQuickRestart ;
6035: CALL_OW 22
// wait ( 0 0$20 ) ;
6039: LD_INT 700
6041: PPUSH
6042: CALL_OW 67
// SendSciToForest ;
6046: CALL 1542 0 0
// if Difficulty = 1 then
6050: LD_OWVAR 67
6054: PUSH
6055: LD_INT 1
6057: EQUAL
6058: IFFALSE 6062
// exit ;
6060: GO 6179
// wait ( [ 5 5$00 , 2 2$30 ] [ Difficulty - 1 ] ) ;
6062: LD_INT 10500
6064: PUSH
6065: LD_INT 5250
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: PUSH
6072: LD_OWVAR 67
6076: PUSH
6077: LD_INT 1
6079: MINUS
6080: ARRAY
6081: PPUSH
6082: CALL_OW 67
// if usAlert then
6086: LD_EXP 10
6090: IFFALSE 6094
// exit ;
6092: GO 6179
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
6094: LD_ADDR_VAR 0 3
6098: PUSH
6099: LD_INT 22
6101: PUSH
6102: LD_INT 1
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 25
6111: PUSH
6112: LD_INT 2
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: PPUSH
6123: CALL_OW 69
6127: ST_TO_ADDR
// if not tmp then
6128: LD_VAR 0 3
6132: NOT
6133: IFFALSE 6137
// exit ;
6135: GO 6179
// ComExitBuilding ( tmp ) ;
6137: LD_VAR 0 3
6141: PPUSH
6142: CALL_OW 122
// AddComBuild ( tmp , b_breastwork , 40 , 13 , 3 ) ;
6146: LD_VAR 0 3
6150: PPUSH
6151: LD_INT 31
6153: PPUSH
6154: LD_INT 40
6156: PPUSH
6157: LD_INT 13
6159: PPUSH
6160: LD_INT 3
6162: PPUSH
6163: CALL_OW 205
// AddComEnterUnit ( tmp , Delta ) ;
6167: LD_VAR 0 3
6171: PPUSH
6172: LD_INT 1
6174: PPUSH
6175: CALL_OW 180
// end ;
6179: LD_VAR 0 1
6183: RET
// every 3 3$00 do
6184: GO 6186
6186: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
6187: LD_INT 1
6189: PPUSH
6190: LD_INT 570
6192: PPUSH
6193: LD_INT 350
6195: PPUSH
6196: CALL_OW 550
// wait ( 2 2$40 ) ;
6200: LD_INT 5600
6202: PPUSH
6203: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
6207: LD_INT 0
6209: PPUSH
6210: LD_INT 570
6212: PPUSH
6213: LD_INT 350
6215: PPUSH
6216: CALL_OW 550
// end ;
6220: END
// every 0 0$1 trigger not aviradzeSpotted and See ( 2 , Aviradze ) do var i , pepAmount ;
6221: LD_EXP 4
6225: NOT
6226: PUSH
6227: LD_INT 2
6229: PPUSH
6230: LD_EXP 27
6234: PPUSH
6235: CALL_OW 292
6239: AND
6240: IFFALSE 7146
6242: GO 6244
6244: DISABLE
6245: LD_INT 0
6247: PPUSH
6248: PPUSH
// begin aviradzeSpotted := true ;
6249: LD_ADDR_EXP 4
6253: PUSH
6254: LD_INT 1
6256: ST_TO_ADDR
// pepAmount := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
6257: LD_ADDR_VAR 0 2
6261: PUSH
6262: LD_INT 22
6264: PUSH
6265: LD_INT 2
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: PUSH
6272: LD_INT 21
6274: PUSH
6275: LD_INT 1
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PPUSH
6286: CALL_OW 69
6290: ST_TO_ADDR
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6291: LD_EXP 23
6295: PPUSH
6296: LD_EXP 27
6300: PPUSH
6301: CALL_OW 250
6305: PPUSH
6306: LD_EXP 27
6310: PPUSH
6311: CALL_OW 251
6315: PPUSH
6316: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6320: LD_INT 35
6322: PPUSH
6323: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 16 ;
6327: LD_EXP 23
6331: PPUSH
6332: LD_EXP 27
6336: PPUSH
6337: CALL_OW 296
6341: PUSH
6342: LD_INT 16
6344: LESS
6345: IFFALSE 6320
// InGameOn ;
6347: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6351: LD_INT 5
6353: PPUSH
6354: LD_INT 2
6356: PPUSH
6357: CALL_OW 343
// if pepAmount > 2 then
6361: LD_VAR 0 2
6365: PUSH
6366: LD_INT 2
6368: GREATER
6369: IFFALSE 6385
// Say ( Heike , DH-1-spot ) else
6371: LD_EXP 23
6375: PPUSH
6376: LD_STRING DH-1-spot
6378: PPUSH
6379: CALL_OW 88
6383: GO 6397
// Say ( Heike , DH-1-spot-d ) ;
6385: LD_EXP 23
6389: PPUSH
6390: LD_STRING DH-1-spot-d
6392: PPUSH
6393: CALL_OW 88
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6397: LD_EXP 23
6401: PPUSH
6402: LD_EXP 27
6406: PPUSH
6407: CALL_OW 250
6411: PPUSH
6412: LD_EXP 27
6416: PPUSH
6417: CALL_OW 251
6421: PPUSH
6422: CALL_OW 111
// for i in [ Kamil , Mike , Givi ] do
6426: LD_ADDR_VAR 0 1
6430: PUSH
6431: LD_EXP 26
6435: PUSH
6436: LD_EXP 25
6440: PUSH
6441: LD_EXP 24
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: LIST
6450: PUSH
6451: FOR_IN
6452: IFFALSE 6491
// if GetDistUnits ( i , Aviradze ) > 7 then
6454: LD_VAR 0 1
6458: PPUSH
6459: LD_EXP 27
6463: PPUSH
6464: CALL_OW 296
6468: PUSH
6469: LD_INT 7
6471: GREATER
6472: IFFALSE 6489
// ComMoveXY ( i , 102 , 40 ) ;
6474: LD_VAR 0 1
6478: PPUSH
6479: LD_INT 102
6481: PPUSH
6482: LD_INT 40
6484: PPUSH
6485: CALL_OW 111
6489: GO 6451
6491: POP
6492: POP
// repeat wait ( 0 0$1 ) ;
6493: LD_INT 35
6495: PPUSH
6496: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 6 ;
6500: LD_EXP 23
6504: PPUSH
6505: LD_EXP 27
6509: PPUSH
6510: CALL_OW 296
6514: PUSH
6515: LD_INT 6
6517: LESS
6518: IFFALSE 6493
// ComTurnUnit ( Heike , Aviradze ) ;
6520: LD_EXP 23
6524: PPUSH
6525: LD_EXP 27
6529: PPUSH
6530: CALL_OW 119
// ComTurnUnit ( [ Aviradze , Sophia , Kaia ] , Heike ) ;
6534: LD_EXP 27
6538: PUSH
6539: LD_EXP 29
6543: PUSH
6544: LD_EXP 28
6548: PUSH
6549: EMPTY
6550: LIST
6551: LIST
6552: LIST
6553: PPUSH
6554: LD_EXP 23
6558: PPUSH
6559: CALL_OW 119
// if pepAmount > 1 then
6563: LD_VAR 0 2
6567: PUSH
6568: LD_INT 1
6570: GREATER
6571: IFFALSE 6623
// begin wait ( 0 0$2 ) ;
6573: LD_INT 70
6575: PPUSH
6576: CALL_OW 67
// ComTurnUnit ( [ Kamil , Mike , Givi ] , Aviradze ) ;
6580: LD_EXP 26
6584: PUSH
6585: LD_EXP 25
6589: PUSH
6590: LD_EXP 24
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: LIST
6599: PPUSH
6600: LD_EXP 27
6604: PPUSH
6605: CALL_OW 119
// Say ( Heike , DH-2-spot ) ;
6609: LD_EXP 23
6613: PPUSH
6614: LD_STRING DH-2-spot
6616: PPUSH
6617: CALL_OW 88
// end else
6621: GO 6635
// Say ( Heike , DH-2-spot-d ) ;
6623: LD_EXP 23
6627: PPUSH
6628: LD_STRING DH-2-spot-d
6630: PPUSH
6631: CALL_OW 88
// Say ( Aviradze , DA-2-spot ) ;
6635: LD_EXP 27
6639: PPUSH
6640: LD_STRING DA-2-spot
6642: PPUSH
6643: CALL_OW 88
// Say ( Heike , DH-3-spot ) ;
6647: LD_EXP 23
6651: PPUSH
6652: LD_STRING DH-3-spot
6654: PPUSH
6655: CALL_OW 88
// ComMoveUnit ( Kaia , Heike ) ;
6659: LD_EXP 28
6663: PPUSH
6664: LD_EXP 23
6668: PPUSH
6669: CALL_OW 112
// ComTurnUnit ( Heike , Kaia ) ;
6673: LD_EXP 23
6677: PPUSH
6678: LD_EXP 28
6682: PPUSH
6683: CALL_OW 119
// wait ( 0 0$0.3 ) ;
6687: LD_INT 10
6689: PPUSH
6690: CALL_OW 67
// Say ( Kaia , DK-3-spot ) ;
6694: LD_EXP 28
6698: PPUSH
6699: LD_STRING DK-3-spot
6701: PPUSH
6702: CALL_OW 88
// ComTurnUnit ( Kaia , Heike ) ;
6706: LD_EXP 28
6710: PPUSH
6711: LD_EXP 23
6715: PPUSH
6716: CALL_OW 119
// Say ( Heike , DH-4-spot ) ;
6720: LD_EXP 23
6724: PPUSH
6725: LD_STRING DH-4-spot
6727: PPUSH
6728: CALL_OW 88
// wait ( 0 0$0.3 ) ;
6732: LD_INT 10
6734: PPUSH
6735: CALL_OW 67
// ComTurnUnit ( Heike , Aviradze ) ;
6739: LD_EXP 23
6743: PPUSH
6744: LD_EXP 27
6748: PPUSH
6749: CALL_OW 119
// Say ( Aviradze , DA-4-spot ) ;
6753: LD_EXP 27
6757: PPUSH
6758: LD_STRING DA-4-spot
6760: PPUSH
6761: CALL_OW 88
// ComTurnUnit ( Kaia , Aviradze ) ;
6765: LD_EXP 28
6769: PPUSH
6770: LD_EXP 27
6774: PPUSH
6775: CALL_OW 119
// Say ( Kaia , DK-4-spot ) ;
6779: LD_EXP 28
6783: PPUSH
6784: LD_STRING DK-4-spot
6786: PPUSH
6787: CALL_OW 88
// ComTurnUnit ( Aviradze , Kaia ) ;
6791: LD_EXP 27
6795: PPUSH
6796: LD_EXP 28
6800: PPUSH
6801: CALL_OW 119
// Say ( Aviradze , DA-5-spot ) ;
6805: LD_EXP 27
6809: PPUSH
6810: LD_STRING DA-5-spot
6812: PPUSH
6813: CALL_OW 88
// Say ( Kaia , DK-5-spot ) ;
6817: LD_EXP 28
6821: PPUSH
6822: LD_STRING DK-5-spot
6824: PPUSH
6825: CALL_OW 88
// if pepAmount = 1 then
6829: LD_VAR 0 2
6833: PUSH
6834: LD_INT 1
6836: EQUAL
6837: IFFALSE 6851
// Say ( Heike , DH-5-spot-f ) ;
6839: LD_EXP 23
6843: PPUSH
6844: LD_STRING DH-5-spot-f
6846: PPUSH
6847: CALL_OW 88
// if pepAmount < 3 then
6851: LD_VAR 0 2
6855: PUSH
6856: LD_INT 3
6858: LESS
6859: IFFALSE 6875
// Say ( Aviradze , DA-6-spot-f ) else
6861: LD_EXP 27
6865: PPUSH
6866: LD_STRING DA-6-spot-f
6868: PPUSH
6869: CALL_OW 88
6873: GO 6911
// if pepAmount < 4 then
6875: LD_VAR 0 2
6879: PUSH
6880: LD_INT 4
6882: LESS
6883: IFFALSE 6899
// Say ( Aviradze , DA-6-spot-c ) else
6885: LD_EXP 27
6889: PPUSH
6890: LD_STRING DA-6-spot-c
6892: PPUSH
6893: CALL_OW 88
6897: GO 6911
// Say ( Aviradze , DA-6-spot ) ;
6899: LD_EXP 27
6903: PPUSH
6904: LD_STRING DA-6-spot
6906: PPUSH
6907: CALL_OW 88
// if Kamil then
6911: LD_EXP 26
6915: IFFALSE 6929
// Say ( Kamil , DKam-6-spot ) ;
6917: LD_EXP 26
6921: PPUSH
6922: LD_STRING DKam-6-spot
6924: PPUSH
6925: CALL_OW 88
// Say ( Kaia , DK-6-spot ) ;
6929: LD_EXP 28
6933: PPUSH
6934: LD_STRING DK-6-spot
6936: PPUSH
6937: CALL_OW 88
// ComTurnUnit ( Aviradze , Heike ) ;
6941: LD_EXP 27
6945: PPUSH
6946: LD_EXP 23
6950: PPUSH
6951: CALL_OW 119
// Say ( Aviradze , DA-7-spot ) ;
6955: LD_EXP 27
6959: PPUSH
6960: LD_STRING DA-7-spot
6962: PPUSH
6963: CALL_OW 88
// Say ( Heike , DH-7-spot ) ;
6967: LD_EXP 23
6971: PPUSH
6972: LD_STRING DH-7-spot
6974: PPUSH
6975: CALL_OW 88
// if sciCounterKill >= 3 then
6979: LD_EXP 9
6983: PUSH
6984: LD_INT 3
6986: GREATEREQUAL
6987: IFFALSE 7013
// begin Say ( Heike , DH-7-spot-a ) ;
6989: LD_EXP 23
6993: PPUSH
6994: LD_STRING DH-7-spot-a
6996: PPUSH
6997: CALL_OW 88
// Say ( Aviradze , DA-8-spot-a ) ;
7001: LD_EXP 27
7005: PPUSH
7006: LD_STRING DA-8-spot-a
7008: PPUSH
7009: CALL_OW 88
// end ; InGameOff ;
7013: CALL_OW 9
// if sciCounterKill < 3 then
7017: LD_EXP 9
7021: PUSH
7022: LD_INT 3
7024: LESS
7025: IFFALSE 7084
// begin SetSide ( Kaia , 2 ) ;
7027: LD_EXP 28
7031: PPUSH
7032: LD_INT 2
7034: PPUSH
7035: CALL_OW 235
// ComFree ( Kaia ) ;
7039: LD_EXP 28
7043: PPUSH
7044: CALL_OW 139
// if Kamil then
7048: LD_EXP 26
7052: IFFALSE 7075
// begin ComHold ( Kamil ) ;
7054: LD_EXP 26
7058: PPUSH
7059: CALL_OW 140
// SetSide ( Kamil , 5 ) ;
7063: LD_EXP 26
7067: PPUSH
7068: LD_INT 5
7070: PPUSH
7071: CALL_OW 235
// end ; ChangeMissionObjectives ( OSci ) ;
7075: LD_STRING OSci
7077: PPUSH
7078: CALL_OW 337
// end else
7082: GO 7146
// begin aviradzeQuestDone := true ;
7084: LD_ADDR_EXP 8
7088: PUSH
7089: LD_INT 1
7091: ST_TO_ADDR
// attackDeltaAllowed := true ;
7092: LD_ADDR_EXP 14
7096: PUSH
7097: LD_INT 1
7099: ST_TO_ADDR
// ChangeMissionObjectives ( ODelta2 ) ;
7100: LD_STRING ODelta2
7102: PPUSH
7103: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7107: LD_ADDR_VAR 0 1
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 5
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PPUSH
7122: CALL_OW 69
7126: PUSH
7127: FOR_IN
7128: IFFALSE 7144
// SetSide ( i , 2 ) ;
7130: LD_VAR 0 1
7134: PPUSH
7135: LD_INT 2
7137: PPUSH
7138: CALL_OW 235
7142: GO 7127
7144: POP
7145: POP
// end ; end ;
7146: PPOPN 2
7148: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and not aviradzeSpotted do
7149: LD_EXP 7
7153: NOT
7154: PUSH
7155: LD_EXP 22
7159: PPUSH
7160: LD_EXP 23
7164: PPUSH
7165: CALL_OW 74
7169: PPUSH
7170: LD_EXP 23
7174: PPUSH
7175: CALL_OW 296
7179: PUSH
7180: LD_INT 8
7182: LESS
7183: AND
7184: PUSH
7185: LD_INT 2
7187: PPUSH
7188: LD_EXP 22
7192: PPUSH
7193: LD_EXP 23
7197: PPUSH
7198: CALL_OW 74
7202: PPUSH
7203: CALL_OW 292
7207: AND
7208: PUSH
7209: LD_INT 22
7211: PUSH
7212: LD_INT 2
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 21
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: PPUSH
7233: CALL_OW 69
7237: PUSH
7238: LD_INT 1
7240: GREATER
7241: AND
7242: PUSH
7243: LD_EXP 4
7247: NOT
7248: AND
7249: IFFALSE 7293
7251: GO 7253
7253: DISABLE
// begin sciSpotted := true ;
7254: LD_ADDR_EXP 7
7258: PUSH
7259: LD_INT 1
7261: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7262: LD_EXP 22
7266: PPUSH
7267: LD_EXP 23
7271: PPUSH
7272: CALL_OW 74
7276: PPUSH
7277: CALL_OW 87
// Say ( Heike , DH-1-sci ) ;
7281: LD_EXP 23
7285: PPUSH
7286: LD_STRING DH-1-sci
7288: PPUSH
7289: CALL_OW 88
// end ;
7293: END
// every 0 0$1 trigger aviradzeSpotted and not sciSpotted and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and aviradzeSpotted and not aviradzeQuestDone do var un ;
7294: LD_EXP 4
7298: PUSH
7299: LD_EXP 7
7303: NOT
7304: AND
7305: PUSH
7306: LD_INT 2
7308: PPUSH
7309: LD_EXP 22
7313: PPUSH
7314: LD_EXP 23
7318: PPUSH
7319: CALL_OW 74
7323: PPUSH
7324: CALL_OW 292
7328: AND
7329: PUSH
7330: LD_INT 22
7332: PUSH
7333: LD_INT 2
7335: PUSH
7336: EMPTY
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 21
7342: PUSH
7343: LD_INT 1
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PPUSH
7354: CALL_OW 69
7358: PUSH
7359: LD_INT 1
7361: GREATER
7362: AND
7363: PUSH
7364: LD_EXP 4
7368: AND
7369: PUSH
7370: LD_EXP 8
7374: NOT
7375: AND
7376: IFFALSE 7517
7378: GO 7380
7380: DISABLE
7381: LD_INT 0
7383: PPUSH
// begin sciSpotted := true ;
7384: LD_ADDR_EXP 7
7388: PUSH
7389: LD_INT 1
7391: ST_TO_ADDR
// un := NearestUnitToUnit ( usSci , Heike ) ;
7392: LD_ADDR_VAR 0 1
7396: PUSH
7397: LD_EXP 22
7401: PPUSH
7402: LD_EXP 23
7406: PPUSH
7407: CALL_OW 74
7411: ST_TO_ADDR
// DialogueOn ;
7412: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 2 , - 3 ) ;
7416: LD_VAR 0 1
7420: PPUSH
7421: CALL_OW 250
7425: PPUSH
7426: LD_VAR 0 1
7430: PPUSH
7431: CALL_OW 251
7435: PPUSH
7436: LD_INT 2
7438: PPUSH
7439: LD_INT 3
7441: NEG
7442: PPUSH
7443: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7447: LD_VAR 0 1
7451: PPUSH
7452: CALL_OW 87
// Say ( Heike , DH-1-sci-a ) ;
7456: LD_EXP 23
7460: PPUSH
7461: LD_STRING DH-1-sci-a
7463: PPUSH
7464: CALL_OW 88
// if Mike then
7468: LD_EXP 25
7472: IFFALSE 7486
// Say ( Mike , DM-1-sci-a ) ;
7474: LD_EXP 25
7478: PPUSH
7479: LD_STRING DM-1-sci-a
7481: PPUSH
7482: CALL_OW 88
// RemoveSeeing ( GetX ( un ) , GetY ( un ) , 2 ) ;
7486: LD_VAR 0 1
7490: PPUSH
7491: CALL_OW 250
7495: PPUSH
7496: LD_VAR 0 1
7500: PPUSH
7501: CALL_OW 251
7505: PPUSH
7506: LD_INT 2
7508: PPUSH
7509: CALL_OW 331
// DialogueOff ;
7513: CALL_OW 7
// end ;
7517: PPOPN 1
7519: END
// every 0 0$1 trigger usAlert and ( GetLives ( Gladstone ) < 1000 or GetLives ( usLab ) < 999 ) do var veh ;
7520: LD_EXP 10
7524: PUSH
7525: LD_EXP 19
7529: PPUSH
7530: CALL_OW 256
7534: PUSH
7535: LD_INT 1000
7537: LESS
7538: PUSH
7539: LD_INT 3
7541: PPUSH
7542: CALL_OW 256
7546: PUSH
7547: LD_INT 999
7549: LESS
7550: OR
7551: AND
7552: IFFALSE 7808
7554: GO 7556
7556: DISABLE
7557: LD_INT 0
7559: PPUSH
// begin veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
7560: LD_ADDR_VAR 0 1
7564: PUSH
7565: LD_INT 22
7567: PUSH
7568: LD_INT 1
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 21
7577: PUSH
7578: LD_INT 2
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 58
7587: PUSH
7588: EMPTY
7589: LIST
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: LIST
7595: PPUSH
7596: CALL_OW 69
7600: ST_TO_ADDR
// if veh and IsOk ( Gladstone ) then
7601: LD_VAR 0 1
7605: PUSH
7606: LD_EXP 19
7610: PPUSH
7611: CALL_OW 302
7615: AND
7616: IFFALSE 7658
// begin if IsInUnit ( Gladstone ) then
7618: LD_EXP 19
7622: PPUSH
7623: CALL_OW 310
7627: IFFALSE 7638
// ComExitBuilding ( Gladstone ) ;
7629: LD_EXP 19
7633: PPUSH
7634: CALL_OW 122
// AddComEnterUnit ( Gladstone , veh [ 1 ] ) ;
7638: LD_EXP 19
7642: PPUSH
7643: LD_VAR 0 1
7647: PUSH
7648: LD_INT 1
7650: ARRAY
7651: PPUSH
7652: CALL_OW 180
// end else
7656: GO 7678
// if IsInUnit ( Gladstone ) then
7658: LD_EXP 19
7662: PPUSH
7663: CALL_OW 310
7667: IFFALSE 7678
// ComExitBuilding ( Gladstone ) ;
7669: LD_EXP 19
7673: PPUSH
7674: CALL_OW 122
// AddComMoveXY ( Gladstone , 27 , 51 ) ;
7678: LD_EXP 19
7682: PPUSH
7683: LD_INT 27
7685: PPUSH
7686: LD_INT 51
7688: PPUSH
7689: CALL_OW 171
// Say ( Gladstone , D8-Glad-2 ) ;
7693: LD_EXP 19
7697: PPUSH
7698: LD_STRING D8-Glad-2
7700: PPUSH
7701: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
7705: LD_INT 35
7707: PPUSH
7708: CALL_OW 67
// until IsAt ( Gladstone , 27 , 51 ) or IsAt ( IsInUnit ( Gladstone ) , 27 , 51 ) or IsDead ( Gladstone ) ;
7712: LD_EXP 19
7716: PPUSH
7717: LD_INT 27
7719: PPUSH
7720: LD_INT 51
7722: PPUSH
7723: CALL_OW 307
7727: PUSH
7728: LD_EXP 19
7732: PPUSH
7733: CALL_OW 310
7737: PPUSH
7738: LD_INT 27
7740: PPUSH
7741: LD_INT 51
7743: PPUSH
7744: CALL_OW 307
7748: OR
7749: PUSH
7750: LD_EXP 19
7754: PPUSH
7755: CALL_OW 301
7759: OR
7760: IFFALSE 7705
// if IsDead ( Gladstone ) then
7762: LD_EXP 19
7766: PPUSH
7767: CALL_OW 301
7771: IFFALSE 7775
// exit ;
7773: GO 7808
// RemoveUnit ( HexInfo ( 27 , 51 ) ) ;
7775: LD_INT 27
7777: PPUSH
7778: LD_INT 51
7780: PPUSH
7781: CALL_OW 428
7785: PPUSH
7786: CALL_OW 64
// gladstoneEscaped := true ;
7790: LD_ADDR_EXP 12
7794: PUSH
7795: LD_INT 1
7797: ST_TO_ADDR
// SaveVariable ( true , 02_GladstoneEscaped ) ;
7798: LD_INT 1
7800: PPUSH
7801: LD_STRING 02_GladstoneEscaped
7803: PPUSH
7804: CALL_OW 39
// end ;
7808: PPOPN 1
7810: END
// every 0 0$1 trigger aviradzeSpotted and ( sciCounterKill >= 3 or not usSci ) and not aviradzeQuestDone do
7811: LD_EXP 4
7815: PUSH
7816: LD_EXP 9
7820: PUSH
7821: LD_INT 3
7823: GREATEREQUAL
7824: PUSH
7825: LD_EXP 22
7829: NOT
7830: OR
7831: AND
7832: PUSH
7833: LD_EXP 8
7837: NOT
7838: AND
7839: IFFALSE 7882
7841: GO 7843
7843: DISABLE
// begin aviradzeQuestDone := true ;
7844: LD_ADDR_EXP 8
7848: PUSH
7849: LD_INT 1
7851: ST_TO_ADDR
// Say ( Heike , DH-1-quest-done ) ;
7852: LD_EXP 23
7856: PPUSH
7857: LD_STRING DH-1-quest-done
7859: PPUSH
7860: CALL_OW 88
// if Givi then
7864: LD_EXP 24
7868: IFFALSE 7882
// Say ( Givi , DG-1-quest-done ) ;
7870: LD_EXP 24
7874: PPUSH
7875: LD_STRING DG-1-quest-done
7877: PPUSH
7878: CALL_OW 88
// end ;
7882: END
// every 0 0$1 trigger See ( 5 , Heike ) and GetDistUnits ( Heike , Aviradze ) < 6 and aviradzeQuestDone and not attackDeltaAllowed do var i ;
7883: LD_INT 5
7885: PPUSH
7886: LD_EXP 23
7890: PPUSH
7891: CALL_OW 292
7895: PUSH
7896: LD_EXP 23
7900: PPUSH
7901: LD_EXP 27
7905: PPUSH
7906: CALL_OW 296
7910: PUSH
7911: LD_INT 6
7913: LESS
7914: AND
7915: PUSH
7916: LD_EXP 8
7920: AND
7921: PUSH
7922: LD_EXP 14
7926: NOT
7927: AND
7928: IFFALSE 8066
7930: GO 7932
7932: DISABLE
7933: LD_INT 0
7935: PPUSH
// begin attackDeltaAllowed := true ;
7936: LD_ADDR_EXP 14
7940: PUSH
7941: LD_INT 1
7943: ST_TO_ADDR
// InGameOn ;
7944: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
7948: LD_EXP 23
7952: PPUSH
7953: CALL_OW 87
// wait ( 0 0$0.3 ) ;
7957: LD_INT 10
7959: PPUSH
7960: CALL_OW 67
// ComTurnUnit ( Aviradze , Heike ) ;
7964: LD_EXP 27
7968: PPUSH
7969: LD_EXP 23
7973: PPUSH
7974: CALL_OW 119
// ComTurnUnit ( Heike , Aviradze ) ;
7978: LD_EXP 23
7982: PPUSH
7983: LD_EXP 27
7987: PPUSH
7988: CALL_OW 119
// Say ( Heike , DH-1-return ) ;
7992: LD_EXP 23
7996: PPUSH
7997: LD_STRING DH-1-return
7999: PPUSH
8000: CALL_OW 88
// Say ( Aviradze , DA-1-return ) ;
8004: LD_EXP 27
8008: PPUSH
8009: LD_STRING DA-1-return
8011: PPUSH
8012: CALL_OW 88
// InGameOff ;
8016: CALL_OW 9
// ChangeMissionObjectives ( ODelta ) ;
8020: LD_STRING ODelta
8022: PPUSH
8023: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
8027: LD_ADDR_VAR 0 1
8031: PUSH
8032: LD_INT 22
8034: PUSH
8035: LD_INT 5
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PPUSH
8042: CALL_OW 69
8046: PUSH
8047: FOR_IN
8048: IFFALSE 8064
// SetSide ( i , 2 ) ;
8050: LD_VAR 0 1
8054: PPUSH
8055: LD_INT 2
8057: PPUSH
8058: CALL_OW 235
8062: GO 8047
8064: POP
8065: POP
// end ;
8066: PPOPN 1
8068: END
// every 0 0$1 trigger usAlert and not attackDeltaAllowed do
8069: LD_EXP 10
8073: PUSH
8074: LD_EXP 14
8078: NOT
8079: AND
8080: IFFALSE 8093
8082: GO 8084
8084: DISABLE
// spottedBeforeRadio := true ;
8085: LD_ADDR_EXP 6
8089: PUSH
8090: LD_INT 1
8092: ST_TO_ADDR
8093: END
// every 0 0$1 trigger attackDeltaAllowed and IsOk ( Markov ) and GetSide ( Delta ) = 1 and IsOk ( Lynch ) and not usAlert do var i , k , tmp ;
8094: LD_EXP 14
8098: PUSH
8099: LD_EXP 30
8103: PPUSH
8104: CALL_OW 302
8108: AND
8109: PUSH
8110: LD_INT 1
8112: PPUSH
8113: CALL_OW 255
8117: PUSH
8118: LD_INT 1
8120: EQUAL
8121: AND
8122: PUSH
8123: LD_EXP 20
8127: PPUSH
8128: CALL_OW 302
8132: AND
8133: PUSH
8134: LD_EXP 10
8138: NOT
8139: AND
8140: IFFALSE 9356
8142: GO 8144
8144: DISABLE
8145: LD_INT 0
8147: PPUSH
8148: PPUSH
8149: PPUSH
// begin trap := 0 ;
8150: LD_ADDR_EXP 17
8154: PUSH
8155: LD_INT 0
8157: ST_TO_ADDR
// wait ( 0 0$12 ) ;
8158: LD_INT 420
8160: PPUSH
8161: CALL_OW 67
// DialogueOn ;
8165: CALL_OW 6
// Say ( Markov , DMar-1-radio ) ;
8169: LD_EXP 30
8173: PPUSH
8174: LD_STRING DMar-1-radio
8176: PPUSH
8177: CALL_OW 88
// Say ( Heike , DH-1-radio ) ;
8181: LD_EXP 23
8185: PPUSH
8186: LD_STRING DH-1-radio
8188: PPUSH
8189: CALL_OW 88
// Say ( Markov , DMar-2-radio ) ;
8193: LD_EXP 30
8197: PPUSH
8198: LD_STRING DMar-2-radio
8200: PPUSH
8201: CALL_OW 88
// Say ( Heike , DH-2-radio ) ;
8205: LD_EXP 23
8209: PPUSH
8210: LD_STRING DH-2-radio
8212: PPUSH
8213: CALL_OW 88
// if IsOk ( Kamil ) or IsOk ( Sophia ) then
8217: LD_EXP 26
8221: PPUSH
8222: CALL_OW 302
8226: PUSH
8227: LD_EXP 29
8231: PPUSH
8232: CALL_OW 302
8236: OR
8237: IFFALSE 9356
// begin case Query ( Q1Trap ) of 1 :
8239: LD_STRING Q1Trap
8241: PPUSH
8242: CALL_OW 97
8246: PUSH
8247: LD_INT 1
8249: DOUBLE
8250: EQUAL
8251: IFTRUE 8255
8253: GO 8449
8255: POP
// begin if IsOk ( Kamil ) then
8256: LD_EXP 26
8260: PPUSH
8261: CALL_OW 302
8265: IFFALSE 8344
// begin Say ( Kamil , DKam-2-radio ) ;
8267: LD_EXP 26
8271: PPUSH
8272: LD_STRING DKam-2-radio
8274: PPUSH
8275: CALL_OW 88
// Say ( Kamil , DKam-3-radio ) ;
8279: LD_EXP 26
8283: PPUSH
8284: LD_STRING DKam-3-radio
8286: PPUSH
8287: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio ) ;
8291: LD_EXP 20
8295: PPUSH
8296: LD_STRING DDelta-3-radio
8298: PPUSH
8299: CALL_OW 94
// dwait ( 0 0$01 ) ;
8303: LD_INT 35
8305: PPUSH
8306: CALL_OW 68
// Say ( Heike , DH-3-radio ) ;
8310: LD_EXP 23
8314: PPUSH
8315: LD_STRING DH-3-radio
8317: PPUSH
8318: CALL_OW 88
// Say ( Kamil , DKam-4-radio ) ;
8322: LD_EXP 26
8326: PPUSH
8327: LD_STRING DKam-4-radio
8329: PPUSH
8330: CALL_OW 88
// trap := 1 ;
8334: LD_ADDR_EXP 17
8338: PUSH
8339: LD_INT 1
8341: ST_TO_ADDR
// end else
8342: GO 8443
// begin Say ( Sophia , DS-1-radio ) ;
8344: LD_EXP 29
8348: PPUSH
8349: LD_STRING DS-1-radio
8351: PPUSH
8352: CALL_OW 88
// Say ( Sophia , DS-2-radio ) ;
8356: LD_EXP 29
8360: PPUSH
8361: LD_STRING DS-2-radio
8363: PPUSH
8364: CALL_OW 88
// SayRadio ( Lynch , DDelta-2-radio-s ) ;
8368: LD_EXP 20
8372: PPUSH
8373: LD_STRING DDelta-2-radio-s
8375: PPUSH
8376: CALL_OW 94
// Say ( Sophia , DS-3-radio ) ;
8380: LD_EXP 29
8384: PPUSH
8385: LD_STRING DS-3-radio
8387: PPUSH
8388: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio-s ) ;
8392: LD_EXP 20
8396: PPUSH
8397: LD_STRING DDelta-3-radio-s
8399: PPUSH
8400: CALL_OW 94
// Say ( Sophia , DS-4-radio-s ) ;
8404: LD_EXP 29
8408: PPUSH
8409: LD_STRING DS-4-radio-s
8411: PPUSH
8412: CALL_OW 88
// dwait ( 0 0$01 ) ;
8416: LD_INT 35
8418: PPUSH
8419: CALL_OW 68
// Say ( Heike , DH-1-trap ) ;
8423: LD_EXP 23
8427: PPUSH
8428: LD_STRING DH-1-trap
8430: PPUSH
8431: CALL_OW 88
// trap := 0 ;
8435: LD_ADDR_EXP 17
8439: PUSH
8440: LD_INT 0
8442: ST_TO_ADDR
// end ; DialogueOff ;
8443: CALL_OW 7
// end ; 2 :
8447: GO 8467
8449: LD_INT 2
8451: DOUBLE
8452: EQUAL
8453: IFTRUE 8457
8455: GO 8466
8457: POP
// begin DialogueOff ;
8458: CALL_OW 7
// exit ;
8462: GO 9356
// end ; end ;
8464: GO 8467
8466: POP
// if trap = 1 then
8467: LD_EXP 17
8471: PUSH
8472: LD_INT 1
8474: EQUAL
8475: IFFALSE 8927
// begin PlaceSeeing ( 64 , 32 , 2 , 8 ) ;
8477: LD_INT 64
8479: PPUSH
8480: LD_INT 32
8482: PPUSH
8483: LD_INT 2
8485: PPUSH
8486: LD_INT 8
8488: PPUSH
8489: CALL_OW 330
// CenterOnXY ( 64 , 32 ) ;
8493: LD_INT 64
8495: PPUSH
8496: LD_INT 32
8498: PPUSH
8499: CALL_OW 84
// tmp := [ ] ;
8503: LD_ADDR_VAR 0 3
8507: PUSH
8508: EMPTY
8509: ST_TO_ADDR
// k := 3 ;
8510: LD_ADDR_VAR 0 2
8514: PUSH
8515: LD_INT 3
8517: ST_TO_ADDR
// if usForces < 3 then
8518: LD_EXP 21
8522: PUSH
8523: LD_INT 3
8525: LESS
8526: IFFALSE 8538
// k := usForces ;
8528: LD_ADDR_VAR 0 2
8532: PUSH
8533: LD_EXP 21
8537: ST_TO_ADDR
// for i := 1 to k do
8538: LD_ADDR_VAR 0 1
8542: PUSH
8543: DOUBLE
8544: LD_INT 1
8546: DEC
8547: ST_TO_ADDR
8548: LD_VAR 0 2
8552: PUSH
8553: FOR_TO
8554: IFFALSE 8609
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8556: LD_ADDR_VAR 0 3
8560: PUSH
8561: LD_VAR 0 3
8565: PPUSH
8566: LD_VAR 0 3
8570: PUSH
8571: LD_INT 1
8573: PLUS
8574: PPUSH
8575: LD_EXP 21
8579: PUSH
8580: LD_INT 1
8582: ARRAY
8583: PPUSH
8584: CALL_OW 1
8588: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8589: LD_ADDR_EXP 21
8593: PUSH
8594: LD_EXP 21
8598: PPUSH
8599: LD_INT 1
8601: PPUSH
8602: CALL_OW 3
8606: ST_TO_ADDR
// end ;
8607: GO 8553
8609: POP
8610: POP
// usPatrol := tmp ;
8611: LD_ADDR_EXP 16
8615: PUSH
8616: LD_VAR 0 3
8620: ST_TO_ADDR
// for i in tmp do
8621: LD_ADDR_VAR 0 1
8625: PUSH
8626: LD_VAR 0 3
8630: PUSH
8631: FOR_IN
8632: IFFALSE 8762
// begin if IsInUnit ( i ) then
8634: LD_VAR 0 1
8638: PPUSH
8639: CALL_OW 310
8643: IFFALSE 8654
// ComExitBuilding ( i ) ;
8645: LD_VAR 0 1
8649: PPUSH
8650: CALL_OW 122
// AddComAgressiveMove ( i , 63 , 31 ) ;
8654: LD_VAR 0 1
8658: PPUSH
8659: LD_INT 63
8661: PPUSH
8662: LD_INT 31
8664: PPUSH
8665: CALL_OW 174
// AddComWait ( i , 0 0$2 ) ;
8669: LD_VAR 0 1
8673: PPUSH
8674: LD_INT 70
8676: PPUSH
8677: CALL_OW 202
// AddComAgressiveMove ( i , 103 , 43 ) ;
8681: LD_VAR 0 1
8685: PPUSH
8686: LD_INT 103
8688: PPUSH
8689: LD_INT 43
8691: PPUSH
8692: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8696: LD_VAR 0 1
8700: PPUSH
8701: LD_INT 105
8703: PPUSH
8704: CALL_OW 202
// if Difficulty > 1 then
8708: LD_OWVAR 67
8712: PUSH
8713: LD_INT 1
8715: GREATER
8716: IFFALSE 8733
// AddComAgressiveMove ( i , 114 , 69 ) ;
8718: LD_VAR 0 1
8722: PPUSH
8723: LD_INT 114
8725: PPUSH
8726: LD_INT 69
8728: PPUSH
8729: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8733: LD_VAR 0 1
8737: PPUSH
8738: LD_INT 105
8740: PPUSH
8741: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8745: LD_VAR 0 1
8749: PPUSH
8750: LD_INT 42
8752: PPUSH
8753: LD_INT 20
8755: PPUSH
8756: CALL_OW 174
// end ;
8760: GO 8631
8762: POP
8763: POP
// wait ( 0 0$8 ) ;
8764: LD_INT 280
8766: PPUSH
8767: CALL_OW 67
// RemoveSeeing ( 64 , 32 , 2 ) ;
8771: LD_INT 64
8773: PPUSH
8774: LD_INT 32
8776: PPUSH
8777: LD_INT 2
8779: PPUSH
8780: CALL_OW 331
// repeat wait ( 0 0$1 ) ;
8784: LD_INT 35
8786: PPUSH
8787: CALL_OW 67
// for i in tmp do
8791: LD_ADDR_VAR 0 1
8795: PUSH
8796: LD_VAR 0 3
8800: PUSH
8801: FOR_IN
8802: IFFALSE 8833
// if IsDead ( i ) then
8804: LD_VAR 0 1
8808: PPUSH
8809: CALL_OW 301
8813: IFFALSE 8831
// tmp := tmp diff i ;
8815: LD_ADDR_VAR 0 3
8819: PUSH
8820: LD_VAR 0 3
8824: PUSH
8825: LD_VAR 0 1
8829: DIFF
8830: ST_TO_ADDR
8831: GO 8801
8833: POP
8834: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8835: LD_VAR 0 3
8839: NOT
8840: PUSH
8841: LD_VAR 0 3
8845: PPUSH
8846: LD_INT 95
8848: PUSH
8849: LD_INT 7
8851: PUSH
8852: EMPTY
8853: LIST
8854: LIST
8855: PUSH
8856: LD_INT 3
8858: PUSH
8859: LD_INT 60
8861: PUSH
8862: EMPTY
8863: LIST
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 72
8877: PUSH
8878: LD_VAR 0 3
8882: EQUAL
8883: OR
8884: IFFALSE 8784
// if tmp then
8886: LD_VAR 0 3
8890: IFFALSE 8917
// begin usPatrol := [ ] ;
8892: LD_ADDR_EXP 16
8896: PUSH
8897: EMPTY
8898: ST_TO_ADDR
// usForces := usForces union tmp ;
8899: LD_ADDR_EXP 21
8903: PUSH
8904: LD_EXP 21
8908: PUSH
8909: LD_VAR 0 3
8913: UNION
8914: ST_TO_ADDR
// end else
8915: GO 8925
// trickyMove := true ;
8917: LD_ADDR_EXP 15
8921: PUSH
8922: LD_INT 1
8924: ST_TO_ADDR
// end else
8925: GO 9356
// begin tmp := [ ] ;
8927: LD_ADDR_VAR 0 3
8931: PUSH
8932: EMPTY
8933: ST_TO_ADDR
// k := 4 ;
8934: LD_ADDR_VAR 0 2
8938: PUSH
8939: LD_INT 4
8941: ST_TO_ADDR
// if usForces < 4 then
8942: LD_EXP 21
8946: PUSH
8947: LD_INT 4
8949: LESS
8950: IFFALSE 8962
// k := usForces ;
8952: LD_ADDR_VAR 0 2
8956: PUSH
8957: LD_EXP 21
8961: ST_TO_ADDR
// for i := 1 to k do
8962: LD_ADDR_VAR 0 1
8966: PUSH
8967: DOUBLE
8968: LD_INT 1
8970: DEC
8971: ST_TO_ADDR
8972: LD_VAR 0 2
8976: PUSH
8977: FOR_TO
8978: IFFALSE 9033
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8980: LD_ADDR_VAR 0 3
8984: PUSH
8985: LD_VAR 0 3
8989: PPUSH
8990: LD_VAR 0 3
8994: PUSH
8995: LD_INT 1
8997: PLUS
8998: PPUSH
8999: LD_EXP 21
9003: PUSH
9004: LD_INT 1
9006: ARRAY
9007: PPUSH
9008: CALL_OW 1
9012: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
9013: LD_ADDR_EXP 21
9017: PUSH
9018: LD_EXP 21
9022: PPUSH
9023: LD_INT 1
9025: PPUSH
9026: CALL_OW 3
9030: ST_TO_ADDR
// end ;
9031: GO 8977
9033: POP
9034: POP
// if Lynch then
9035: LD_EXP 20
9039: IFFALSE 9057
// tmp := tmp ^ Lynch ;
9041: LD_ADDR_VAR 0 3
9045: PUSH
9046: LD_VAR 0 3
9050: PUSH
9051: LD_EXP 20
9055: ADD
9056: ST_TO_ADDR
// usPatrol := tmp ;
9057: LD_ADDR_EXP 16
9061: PUSH
9062: LD_VAR 0 3
9066: ST_TO_ADDR
// for i in tmp do
9067: LD_ADDR_VAR 0 1
9071: PUSH
9072: LD_VAR 0 3
9076: PUSH
9077: FOR_IN
9078: IFFALSE 9171
// begin if IsInUnit ( i ) then
9080: LD_VAR 0 1
9084: PPUSH
9085: CALL_OW 310
9089: IFFALSE 9100
// ComExitBuilding ( i ) ;
9091: LD_VAR 0 1
9095: PPUSH
9096: CALL_OW 122
// AddComAgressiveMove ( i , 69 , 15 ) ;
9100: LD_VAR 0 1
9104: PPUSH
9105: LD_INT 69
9107: PPUSH
9108: LD_INT 15
9110: PPUSH
9111: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
9115: LD_VAR 0 1
9119: PPUSH
9120: LD_INT 700
9122: PPUSH
9123: CALL_OW 202
// AddComAgressiveMove ( i , 55 , 43 ) ;
9127: LD_VAR 0 1
9131: PPUSH
9132: LD_INT 55
9134: PPUSH
9135: LD_INT 43
9137: PPUSH
9138: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
9142: LD_VAR 0 1
9146: PPUSH
9147: LD_INT 700
9149: PPUSH
9150: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
9154: LD_VAR 0 1
9158: PPUSH
9159: LD_INT 42
9161: PPUSH
9162: LD_INT 20
9164: PPUSH
9165: CALL_OW 174
// end ;
9169: GO 9077
9171: POP
9172: POP
// repeat wait ( 0 0$1 ) ;
9173: LD_INT 35
9175: PPUSH
9176: CALL_OW 67
// for i in tmp do
9180: LD_ADDR_VAR 0 1
9184: PUSH
9185: LD_VAR 0 3
9189: PUSH
9190: FOR_IN
9191: IFFALSE 9222
// if IsDead ( i ) then
9193: LD_VAR 0 1
9197: PPUSH
9198: CALL_OW 301
9202: IFFALSE 9220
// tmp := tmp diff i ;
9204: LD_ADDR_VAR 0 3
9208: PUSH
9209: LD_VAR 0 3
9213: PUSH
9214: LD_VAR 0 1
9218: DIFF
9219: ST_TO_ADDR
9220: GO 9190
9222: POP
9223: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
9224: LD_VAR 0 3
9228: NOT
9229: PUSH
9230: LD_VAR 0 3
9234: PPUSH
9235: LD_INT 95
9237: PUSH
9238: LD_INT 7
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PUSH
9245: LD_INT 3
9247: PUSH
9248: LD_INT 60
9250: PUSH
9251: EMPTY
9252: LIST
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: EMPTY
9259: LIST
9260: LIST
9261: PPUSH
9262: CALL_OW 72
9266: PUSH
9267: LD_VAR 0 3
9271: EQUAL
9272: OR
9273: IFFALSE 9173
// if not tmp then
9275: LD_VAR 0 3
9279: NOT
9280: IFFALSE 9292
// trickyMove := true else
9282: LD_ADDR_EXP 15
9286: PUSH
9287: LD_INT 1
9289: ST_TO_ADDR
9290: GO 9299
// usPatrol := [ ] ;
9292: LD_ADDR_EXP 16
9296: PUSH
9297: EMPTY
9298: ST_TO_ADDR
// if tmp diff Lynch then
9299: LD_VAR 0 3
9303: PUSH
9304: LD_EXP 20
9308: DIFF
9309: IFFALSE 9333
// usForces := usForces union ( tmp diff Lynch ) ;
9311: LD_ADDR_EXP 21
9315: PUSH
9316: LD_EXP 21
9320: PUSH
9321: LD_VAR 0 3
9325: PUSH
9326: LD_EXP 20
9330: DIFF
9331: UNION
9332: ST_TO_ADDR
// if IsOk ( Lynch ) then
9333: LD_EXP 20
9337: PPUSH
9338: CALL_OW 302
9342: IFFALSE 9356
// ComEnterUnit ( Lynch , Delta ) ;
9344: LD_EXP 20
9348: PPUSH
9349: LD_INT 1
9351: PPUSH
9352: CALL_OW 120
// end ; end ; end ;
9356: PPOPN 3
9358: END
// every 0 0$1 trigger trickyMove do
9359: LD_EXP 15
9363: IFFALSE 9375
9365: GO 9367
9367: DISABLE
// SetAchievement ( ACH_TRAP ) ;
9368: LD_STRING ACH_TRAP
9370: PPUSH
9371: CALL_OW 543
9375: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ) do
9376: LD_INT 22
9378: PUSH
9379: LD_INT 2
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: PUSH
9386: LD_INT 23
9388: PUSH
9389: LD_INT 1
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: PUSH
9396: LD_INT 21
9398: PUSH
9399: LD_INT 2
9401: PUSH
9402: EMPTY
9403: LIST
9404: LIST
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: LIST
9410: PPUSH
9411: CALL_OW 69
9415: IFFALSE 9427
9417: GO 9419
9419: DISABLE
// SetAchievement ( ACH_SCRAP ) ;
9420: LD_STRING ACH_SCRAP
9422: PPUSH
9423: CALL_OW 543
9427: END
// every 0 0$1 trigger UnitFilter ( usPatrol , [ f_see , 2 ] ) do
9428: LD_EXP 16
9432: PPUSH
9433: LD_INT 101
9435: PUSH
9436: LD_INT 2
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: PPUSH
9443: CALL_OW 72
9447: IFFALSE 9580
9449: GO 9451
9451: DISABLE
// begin if not trap then
9452: LD_EXP 17
9456: NOT
9457: IFFALSE 9485
// begin Say ( Heike , DH-2-trap ) ;
9459: LD_EXP 23
9463: PPUSH
9464: LD_STRING DH-2-trap
9466: PPUSH
9467: CALL_OW 88
// Say ( Mike , DM-2-trap ) ;
9471: LD_EXP 25
9475: PPUSH
9476: LD_STRING DM-2-trap
9478: PPUSH
9479: CALL_OW 88
// end else
9483: GO 9497
// begin Say ( Heike , DH-1-trap-a ) ;
9485: LD_EXP 23
9489: PPUSH
9490: LD_STRING DH-1-trap-a
9492: PPUSH
9493: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
9497: LD_INT 35
9499: PPUSH
9500: CALL_OW 67
// until trickyMove ;
9504: LD_EXP 15
9508: IFFALSE 9497
// Say ( Heike , DH-3-trap ) ;
9510: LD_EXP 23
9514: PPUSH
9515: LD_STRING DH-3-trap
9517: PPUSH
9518: CALL_OW 88
// if IsOk ( Givi ) and IsOk ( Kaia ) then
9522: LD_EXP 24
9526: PPUSH
9527: CALL_OW 302
9531: PUSH
9532: LD_EXP 28
9536: PPUSH
9537: CALL_OW 302
9541: AND
9542: IFFALSE 9580
// begin Say ( Givi , DG-3-trap ) ;
9544: LD_EXP 24
9548: PPUSH
9549: LD_STRING DG-3-trap
9551: PPUSH
9552: CALL_OW 88
// Say ( Kaia , DK-3-trap ) ;
9556: LD_EXP 28
9560: PPUSH
9561: LD_STRING DK-3-trap
9563: PPUSH
9564: CALL_OW 88
// Say ( Givi , DG-4-trap ) ;
9568: LD_EXP 24
9572: PPUSH
9573: LD_STRING DG-4-trap
9575: PPUSH
9576: CALL_OW 88
// end ; end ;
9580: END
// every 0 0$1 trigger GetSide ( Delta ) = 2 and attackDeltaAllowed do var i , tmp ;
9581: LD_INT 1
9583: PPUSH
9584: CALL_OW 255
9588: PUSH
9589: LD_INT 2
9591: EQUAL
9592: PUSH
9593: LD_EXP 14
9597: AND
9598: IFFALSE 9757
9600: GO 9602
9602: DISABLE
9603: LD_INT 0
9605: PPUSH
9606: PPUSH
// begin if not IsOk ( Kaia ) then
9607: LD_EXP 28
9611: PPUSH
9612: CALL_OW 302
9616: NOT
9617: IFFALSE 9621
// exit ;
9619: GO 9757
// if tick < 5 5$00 then
9621: LD_OWVAR 1
9625: PUSH
9626: LD_INT 10500
9628: LESS
9629: IFFALSE 9638
// SetAchievement ( ACH_DELTA ) ;
9631: LD_STRING ACH_DELTA
9633: PPUSH
9634: CALL_OW 543
// Say ( Kaia , DK-1-capture ) ;
9638: LD_EXP 28
9642: PPUSH
9643: LD_STRING DK-1-capture
9645: PPUSH
9646: CALL_OW 88
// Say ( Heike , DH-1-capture ) ;
9650: LD_EXP 23
9654: PPUSH
9655: LD_STRING DH-1-capture
9657: PPUSH
9658: CALL_OW 88
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
9662: LD_ADDR_VAR 0 2
9666: PUSH
9667: LD_INT 22
9669: PUSH
9670: LD_INT 1
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PUSH
9677: LD_INT 25
9679: PUSH
9680: LD_INT 1
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: CALL_OW 69
9695: ST_TO_ADDR
// if not tmp then
9696: LD_VAR 0 2
9700: NOT
9701: IFFALSE 9705
// exit ;
9703: GO 9757
// for i in tmp do
9705: LD_ADDR_VAR 0 1
9709: PUSH
9710: LD_VAR 0 2
9714: PUSH
9715: FOR_IN
9716: IFFALSE 9755
// begin if IsInUnit ( i ) then
9718: LD_VAR 0 1
9722: PPUSH
9723: CALL_OW 310
9727: IFFALSE 9738
// ComExitBuilding ( i ) ;
9729: LD_VAR 0 1
9733: PPUSH
9734: CALL_OW 122
// AddComAgressiveMove ( i , 38 , 23 ) ;
9738: LD_VAR 0 1
9742: PPUSH
9743: LD_INT 38
9745: PPUSH
9746: LD_INT 23
9748: PPUSH
9749: CALL_OW 174
// end ;
9753: GO 9715
9755: POP
9756: POP
// end ;
9757: PPOPN 2
9759: END
// every 0 0$1 trigger GetSide ( usLab ) = 2 and attackDeltaAllowed do
9760: LD_INT 3
9762: PPUSH
9763: CALL_OW 255
9767: PUSH
9768: LD_INT 2
9770: EQUAL
9771: PUSH
9772: LD_EXP 14
9776: AND
9777: IFFALSE 9809
9779: GO 9781
9781: DISABLE
// begin DialogueOn ;
9782: CALL_OW 6
// Say ( Aviradze , DA-1-capture ) ;
9786: LD_EXP 27
9790: PPUSH
9791: LD_STRING DA-1-capture
9793: PPUSH
9794: CALL_OW 88
// DialogueOff ;
9798: CALL_OW 7
// ChangeMissionObjectives ( OTame ) ;
9802: LD_STRING OTame
9804: PPUSH
9805: CALL_OW 337
// end ;
9809: END
// every 0 0$1 trigger GetTech ( tech_ApeLang , 2 ) = state_researched and attackDeltaAllowed do
9810: LD_INT 1
9812: PPUSH
9813: LD_INT 2
9815: PPUSH
9816: CALL_OW 321
9820: PUSH
9821: LD_INT 2
9823: EQUAL
9824: PUSH
9825: LD_EXP 14
9829: AND
9830: IFFALSE 9977
9832: GO 9834
9834: DISABLE
// begin DialogueOn ;
9835: CALL_OW 6
// Say ( Aviradze , DA-1-ape ) ;
9839: LD_EXP 27
9843: PPUSH
9844: LD_STRING DA-1-ape
9846: PPUSH
9847: CALL_OW 88
// Say ( Heike , DH-1-ape ) ;
9851: LD_EXP 23
9855: PPUSH
9856: LD_STRING DH-1-ape
9858: PPUSH
9859: CALL_OW 88
// Say ( Aviradze , DA-2-ape ) ;
9863: LD_EXP 27
9867: PPUSH
9868: LD_STRING DA-2-ape
9870: PPUSH
9871: CALL_OW 88
// Say ( Aviradze , DA-3-ape ) ;
9875: LD_EXP 27
9879: PPUSH
9880: LD_STRING DA-3-ape
9882: PPUSH
9883: CALL_OW 88
// Say ( Heike , DH-3-ape ) ;
9887: LD_EXP 23
9891: PPUSH
9892: LD_STRING DH-3-ape
9894: PPUSH
9895: CALL_OW 88
// DialogueOff ;
9899: CALL_OW 7
// if FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) then
9903: LD_INT 22
9905: PUSH
9906: LD_INT 0
9908: PUSH
9909: EMPTY
9910: LIST
9911: LIST
9912: PUSH
9913: LD_INT 25
9915: PUSH
9916: LD_INT 12
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: PPUSH
9927: CALL_OW 69
9931: IFFALSE 9943
// SpawnApeman ( forest , 2 ) ;
9933: LD_INT 1
9935: PPUSH
9936: LD_INT 2
9938: PPUSH
9939: CALL 468 0 2
// repeat wait ( 0 0$1 ) ;
9943: LD_INT 35
9945: PPUSH
9946: CALL_OW 67
// until FilterAllUnits ( [ f_class , class_apeman ] ) = 0 ;
9950: LD_INT 25
9952: PUSH
9953: LD_INT 12
9955: PUSH
9956: EMPTY
9957: LIST
9958: LIST
9959: PPUSH
9960: CALL_OW 69
9964: PUSH
9965: LD_INT 0
9967: EQUAL
9968: IFFALSE 9943
// YouLost ( Ape ) ;
9970: LD_STRING Ape
9972: PPUSH
9973: CALL_OW 104
// end ;
9977: END
// every 0 0$5 trigger lostCounter >= [ 3 , 2 , 2 ] [ Difficulty ] do
9978: LD_EXP 18
9982: PUSH
9983: LD_INT 3
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: LD_INT 2
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: LIST
9996: PUSH
9997: LD_OWVAR 67
10001: ARRAY
10002: GREATEREQUAL
10003: IFFALSE 10047
10005: GO 10007
10007: DISABLE
// begin DialogueOn ;
10008: CALL_OW 6
// Say ( Aviradze , DA-1-failure ) ;
10012: LD_EXP 27
10016: PPUSH
10017: LD_STRING DA-1-failure
10019: PPUSH
10020: CALL_OW 88
// Say ( Aviradze , DA-2-failure ) ;
10024: LD_EXP 27
10028: PPUSH
10029: LD_STRING DA-2-failure
10031: PPUSH
10032: CALL_OW 88
// YouLost ( Failure ) ;
10036: LD_STRING Failure
10038: PPUSH
10039: CALL_OW 104
// DialogueOff ;
10043: CALL_OW 7
// end ;
10047: END
// every 0 0$1 trigger GetLives ( Kaia ) < 3 do
10048: LD_EXP 28
10052: PPUSH
10053: CALL_OW 256
10057: PUSH
10058: LD_INT 3
10060: LESS
10061: IFFALSE 10194
10063: GO 10065
10065: DISABLE
// begin DialogueOn ;
10066: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
10070: LD_EXP 28
10074: PPUSH
10075: CALL_OW 87
// ForceSay ( Kaia , DK-Kaiaout-1 ) ;
10079: LD_EXP 28
10083: PPUSH
10084: LD_STRING DK-Kaiaout-1
10086: PPUSH
10087: CALL_OW 91
// Say ( Heike , DH-Kaiaout-2 ) ;
10091: LD_EXP 23
10095: PPUSH
10096: LD_STRING DH-Kaiaout-2
10098: PPUSH
10099: CALL_OW 88
// Say ( Givi , DG-Kaiaout-3 ) ;
10103: LD_EXP 24
10107: PPUSH
10108: LD_STRING DG-Kaiaout-3
10110: PPUSH
10111: CALL_OW 88
// Say ( Heike , DH-Kaiaout-4 ) ;
10115: LD_EXP 23
10119: PPUSH
10120: LD_STRING DH-Kaiaout-4
10122: PPUSH
10123: CALL_OW 88
// if Givi then
10127: LD_EXP 24
10131: IFFALSE 10181
// begin Say ( Givi , DG-Kaiaout-5 ) ;
10133: LD_EXP 24
10137: PPUSH
10138: LD_STRING DG-Kaiaout-5
10140: PPUSH
10141: CALL_OW 88
// Say ( Heike , DH-Kaiaout-6 ) ;
10145: LD_EXP 23
10149: PPUSH
10150: LD_STRING DH-Kaiaout-6
10152: PPUSH
10153: CALL_OW 88
// Say ( Givi , DG-Kaiaout-7 ) ;
10157: LD_EXP 24
10161: PPUSH
10162: LD_STRING DG-Kaiaout-7
10164: PPUSH
10165: CALL_OW 88
// Say ( Heike , DH-Kaiaout-8 ) ;
10169: LD_EXP 23
10173: PPUSH
10174: LD_STRING DH-Kaiaout-8
10176: PPUSH
10177: CALL_OW 88
// end ; DialogueOff ;
10181: CALL_OW 7
// KillUnit ( Kaia ) ;
10185: LD_EXP 28
10189: PPUSH
10190: CALL_OW 66
// end ;
10194: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) and IsOk ( Aviradze ) and GetSide ( Aviradze ) = 2 do var tmp ;
10195: LD_INT 22
10197: PUSH
10198: LD_INT 2
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PUSH
10205: LD_INT 23
10207: PUSH
10208: LD_INT 0
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 69
10223: PUSH
10224: LD_EXP 27
10228: PPUSH
10229: CALL_OW 302
10233: AND
10234: PUSH
10235: LD_EXP 27
10239: PPUSH
10240: CALL_OW 255
10244: PUSH
10245: LD_INT 2
10247: EQUAL
10248: AND
10249: IFFALSE 11021
10251: GO 10253
10253: DISABLE
10254: LD_INT 0
10256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
10257: LD_ADDR_VAR 0 1
10261: PUSH
10262: LD_INT 22
10264: PUSH
10265: LD_INT 2
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PUSH
10272: LD_INT 23
10274: PUSH
10275: LD_INT 0
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: PPUSH
10286: CALL_OW 69
10290: ST_TO_ADDR
// InGameOn ;
10291: CALL_OW 8
// CenterNowOnUnits ( tmp ) ;
10295: LD_VAR 0 1
10299: PPUSH
10300: CALL_OW 87
// ComMoveUnit ( tmp , Aviradze ) ;
10304: LD_VAR 0 1
10308: PPUSH
10309: LD_EXP 27
10313: PPUSH
10314: CALL_OW 112
// ComTurnUnit ( Aviradze , tmp ) ;
10318: LD_EXP 27
10322: PPUSH
10323: LD_VAR 0 1
10327: PPUSH
10328: CALL_OW 119
// wait ( 0 0$1 ) ;
10332: LD_INT 35
10334: PPUSH
10335: CALL_OW 67
// Say ( Aviradze , DA-1-tame-a ) ;
10339: LD_EXP 27
10343: PPUSH
10344: LD_STRING DA-1-tame-a
10346: PPUSH
10347: CALL_OW 88
// if IsOk ( Mike ) then
10351: LD_EXP 25
10355: PPUSH
10356: CALL_OW 302
10360: IFFALSE 10398
// begin Say ( Mike , DM-1-tame-a ) ;
10362: LD_EXP 25
10366: PPUSH
10367: LD_STRING DM-1-tame-a
10369: PPUSH
10370: CALL_OW 88
// Say ( Sophia , DS-1-tame-a ) ;
10374: LD_EXP 29
10378: PPUSH
10379: LD_STRING DS-1-tame-a
10381: PPUSH
10382: CALL_OW 88
// Say ( Mike , DM-2-tame-a ) ;
10386: LD_EXP 25
10390: PPUSH
10391: LD_STRING DM-2-tame-a
10393: PPUSH
10394: CALL_OW 88
// end ; wait ( 0 0$3 ) ;
10398: LD_INT 105
10400: PPUSH
10401: CALL_OW 67
// PrepareFarmer ;
10405: CALL 11696 0 0
// CenterOnUnits ( Farmer ) ;
10409: LD_EXP 31
10413: PPUSH
10414: CALL_OW 85
// ComMoveXY ( Farmer , 105 , 59 ) ;
10418: LD_EXP 31
10422: PPUSH
10423: LD_INT 105
10425: PPUSH
10426: LD_INT 59
10428: PPUSH
10429: CALL_OW 111
// AddComHold ( Farmer ) ;
10433: LD_EXP 31
10437: PPUSH
10438: CALL_OW 200
// SayRadio ( Farmer , DF-1-end ) ;
10442: LD_EXP 31
10446: PPUSH
10447: LD_STRING DF-1-end
10449: PPUSH
10450: CALL_OW 94
// Say ( Aviradze , DA-1-end ) ;
10454: LD_EXP 27
10458: PPUSH
10459: LD_STRING DA-1-end
10461: PPUSH
10462: CALL_OW 88
// SayRadio ( Farmer , DF-2-end ) ;
10466: LD_EXP 31
10470: PPUSH
10471: LD_STRING DF-2-end
10473: PPUSH
10474: CALL_OW 94
// Say ( Aviradze , DA-2-end ) ;
10478: LD_EXP 27
10482: PPUSH
10483: LD_STRING DA-2-end
10485: PPUSH
10486: CALL_OW 88
// SayRadio ( Farmer , DF-3-end ) ;
10490: LD_EXP 31
10494: PPUSH
10495: LD_STRING DF-3-end
10497: PPUSH
10498: CALL_OW 94
// Say ( Heike , DH-3-end ) ;
10502: LD_EXP 23
10506: PPUSH
10507: LD_STRING DH-3-end
10509: PPUSH
10510: CALL_OW 88
// SayRadio ( Farmer , DF-4-end ) ;
10514: LD_EXP 31
10518: PPUSH
10519: LD_STRING DF-4-end
10521: PPUSH
10522: CALL_OW 94
// if tick <= [ 25 25$00 , 24 24$00 , 23 23$00 ] [ Difficulty ] then
10526: LD_OWVAR 1
10530: PUSH
10531: LD_INT 52500
10533: PUSH
10534: LD_INT 50400
10536: PUSH
10537: LD_INT 48300
10539: PUSH
10540: EMPTY
10541: LIST
10542: LIST
10543: LIST
10544: PUSH
10545: LD_OWVAR 67
10549: ARRAY
10550: LESSEQUAL
10551: IFFALSE 10565
// AddMedal ( med1 , 1 ) else
10553: LD_STRING med1
10555: PPUSH
10556: LD_INT 1
10558: PPUSH
10559: CALL_OW 101
10563: GO 10576
// AddMedal ( med1 , - 1 ) ;
10565: LD_STRING med1
10567: PPUSH
10568: LD_INT 1
10570: NEG
10571: PPUSH
10572: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) = 0 and not gladstoneEscaped then
10576: LD_INT 22
10578: PUSH
10579: LD_INT 1
10581: PUSH
10582: EMPTY
10583: LIST
10584: LIST
10585: PUSH
10586: LD_INT 25
10588: PUSH
10589: LD_INT 4
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: PUSH
10596: EMPTY
10597: LIST
10598: LIST
10599: PPUSH
10600: CALL_OW 69
10604: PUSH
10605: LD_INT 0
10607: EQUAL
10608: PUSH
10609: LD_EXP 12
10613: NOT
10614: AND
10615: IFFALSE 10629
// AddMedal ( med2 , 1 ) else
10617: LD_STRING med2
10619: PPUSH
10620: LD_INT 1
10622: PPUSH
10623: CALL_OW 101
10627: GO 10640
// AddMedal ( med2 , - 1 ) ;
10629: LD_STRING med2
10631: PPUSH
10632: LD_INT 1
10634: NEG
10635: PPUSH
10636: CALL_OW 101
// if trickyMove then
10640: LD_EXP 15
10644: IFFALSE 10658
// AddMedal ( med3 , 1 ) else
10646: LD_STRING med3
10648: PPUSH
10649: LD_INT 1
10651: PPUSH
10652: CALL_OW 101
10656: GO 10688
// if spottedBeforeRadio then
10658: LD_EXP 6
10662: IFFALSE 10677
// AddMedal ( med3 , - 2 ) else
10664: LD_STRING med3
10666: PPUSH
10667: LD_INT 2
10669: NEG
10670: PPUSH
10671: CALL_OW 101
10675: GO 10688
// AddMedal ( med3 , - 1 ) ;
10677: LD_STRING med3
10679: PPUSH
10680: LD_INT 1
10682: NEG
10683: PPUSH
10684: CALL_OW 101
// GiveMedals ( MAIN ) ;
10688: LD_STRING MAIN
10690: PPUSH
10691: CALL_OW 102
// SaveCharacters ( tmp , 02_ape ) ;
10695: LD_VAR 0 1
10699: PPUSH
10700: LD_STRING 02_ape
10702: PPUSH
10703: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ;
10707: LD_ADDR_VAR 0 1
10711: PUSH
10712: LD_INT 22
10714: PUSH
10715: LD_INT 2
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: LD_INT 23
10724: PUSH
10725: LD_INT 2
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 21
10734: PUSH
10735: LD_INT 1
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: LIST
10746: PPUSH
10747: CALL_OW 69
10751: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10752: LD_VAR 0 1
10756: PPUSH
10757: CALL_OW 43
// SaveCharacters ( Heike , 02_Heike ) ;
10761: LD_EXP 23
10765: PPUSH
10766: LD_STRING 02_Heike
10768: PPUSH
10769: CALL_OW 38
// SaveCharacters ( Aviradze , 02_Aviradze ) ;
10773: LD_EXP 27
10777: PPUSH
10778: LD_STRING 02_Aviradze
10780: PPUSH
10781: CALL_OW 38
// if Givi then
10785: LD_EXP 24
10789: IFFALSE 10803
// SaveCharacters ( Givi , 02_Givi ) ;
10791: LD_EXP 24
10795: PPUSH
10796: LD_STRING 02_Givi
10798: PPUSH
10799: CALL_OW 38
// if Mike then
10803: LD_EXP 25
10807: IFFALSE 10821
// SaveCharacters ( Mike , 02_Mike ) ;
10809: LD_EXP 25
10813: PPUSH
10814: LD_STRING 02_Mike
10816: PPUSH
10817: CALL_OW 38
// if Kamil then
10821: LD_EXP 26
10825: IFFALSE 10839
// SaveCharacters ( Kamil , 02_Kamil ) ;
10827: LD_EXP 26
10831: PPUSH
10832: LD_STRING 02_Kamil
10834: PPUSH
10835: CALL_OW 38
// if Kaia then
10839: LD_EXP 28
10843: IFFALSE 10857
// SaveCharacters ( Kaia , 02_Kaia ) ;
10845: LD_EXP 28
10849: PPUSH
10850: LD_STRING 02_Kaia
10852: PPUSH
10853: CALL_OW 38
// if Sophia then
10857: LD_EXP 29
10861: IFFALSE 10875
// SaveCharacters ( Sophia , 02_Sophia ) ;
10863: LD_EXP 29
10867: PPUSH
10868: LD_STRING 02_Sophia
10870: PPUSH
10871: CALL_OW 38
// if Markov then
10875: LD_EXP 30
10879: IFFALSE 10893
// SaveCharacters ( Markov , 02_Markov ) ;
10881: LD_EXP 30
10885: PPUSH
10886: LD_STRING 02_Markov
10888: PPUSH
10889: CALL_OW 38
// if tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] then
10893: LD_VAR 0 1
10897: PUSH
10898: LD_EXP 23
10902: PUSH
10903: LD_EXP 27
10907: PUSH
10908: LD_EXP 24
10912: PUSH
10913: LD_EXP 25
10917: PUSH
10918: LD_EXP 26
10922: PUSH
10923: LD_EXP 29
10927: PUSH
10928: LD_EXP 28
10932: PUSH
10933: LD_EXP 30
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: LIST
10945: LIST
10946: LIST
10947: DIFF
10948: IFFALSE 11013
// SaveCharacters ( tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] , 02_others ) ;
10950: LD_VAR 0 1
10954: PUSH
10955: LD_EXP 23
10959: PUSH
10960: LD_EXP 27
10964: PUSH
10965: LD_EXP 24
10969: PUSH
10970: LD_EXP 25
10974: PUSH
10975: LD_EXP 26
10979: PUSH
10980: LD_EXP 29
10984: PUSH
10985: LD_EXP 28
10989: PUSH
10990: LD_EXP 30
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: LIST
10999: LIST
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: DIFF
11005: PPUSH
11006: LD_STRING 02_others
11008: PPUSH
11009: CALL_OW 38
// YouWin ;
11013: CALL_OW 103
// InGameOff ;
11017: CALL_OW 9
// end ;
11021: PPOPN 1
11023: END
// every 0 0$1 trigger tick > timeUntilFarmer and aviradzeSpotted do
11024: LD_OWVAR 1
11028: PUSH
11029: LD_EXP 13
11033: GREATER
11034: PUSH
11035: LD_EXP 4
11039: AND
11040: IFFALSE 11080
11042: GO 11044
11044: DISABLE
// begin InGameOn ;
11045: CALL_OW 8
// PrepareFarmer ;
11049: CALL 11696 0 0
// CenterNowOnUnits ( Farmer ) ;
11053: LD_EXP 31
11057: PPUSH
11058: CALL_OW 87
// wait ( 0 0$2 ) ;
11062: LD_INT 70
11064: PPUSH
11065: CALL_OW 67
// YouLost ( Farmer ) ;
11069: LD_STRING Farmer
11071: PPUSH
11072: CALL_OW 104
// InGameOff ;
11076: CALL_OW 9
// end ; end_of_file
11080: END
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer ; export function PrepareArabian ; var un , veh ; begin
11081: LD_INT 0
11083: PPUSH
11084: PPUSH
11085: PPUSH
// uc_side := 2 ;
11086: LD_ADDR_OWVAR 20
11090: PUSH
11091: LD_INT 2
11093: ST_TO_ADDR
// uc_nation := 2 ;
11094: LD_ADDR_OWVAR 21
11098: PUSH
11099: LD_INT 2
11101: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
11102: LD_ADDR_EXP 23
11106: PUSH
11107: LD_STRING Heike
11109: PPUSH
11110: LD_EXP 1
11114: NOT
11115: PPUSH
11116: LD_EXP 2
11120: PPUSH
11121: CALL 237 0 3
11125: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
11126: LD_EXP 23
11130: PPUSH
11131: LD_INT 83
11133: PPUSH
11134: LD_INT 72
11136: PPUSH
11137: LD_INT 0
11139: PPUSH
11140: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
11144: LD_ADDR_EXP 24
11148: PUSH
11149: LD_STRING Givi
11151: PPUSH
11152: LD_EXP 1
11156: NOT
11157: PPUSH
11158: LD_EXP 2
11162: PPUSH
11163: CALL 237 0 3
11167: ST_TO_ADDR
// if Givi then
11168: LD_EXP 24
11172: IFFALSE 11192
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
11174: LD_EXP 24
11178: PPUSH
11179: LD_INT 87
11181: PPUSH
11182: LD_INT 76
11184: PPUSH
11185: LD_INT 0
11187: PPUSH
11188: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
11192: LD_ADDR_EXP 25
11196: PUSH
11197: LD_STRING Mike
11199: PPUSH
11200: LD_EXP 1
11204: NOT
11205: PPUSH
11206: LD_EXP 2
11210: PPUSH
11211: CALL 237 0 3
11215: ST_TO_ADDR
// if Mike then
11216: LD_EXP 25
11220: IFFALSE 11240
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
11222: LD_EXP 25
11226: PPUSH
11227: LD_INT 84
11229: PPUSH
11230: LD_INT 76
11232: PPUSH
11233: LD_INT 0
11235: PPUSH
11236: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
11240: LD_ADDR_EXP 26
11244: PUSH
11245: LD_STRING Kamil
11247: PPUSH
11248: LD_EXP 1
11252: NOT
11253: PPUSH
11254: LD_EXP 2
11258: PPUSH
11259: CALL 237 0 3
11263: ST_TO_ADDR
// if Kamil then
11264: LD_EXP 26
11268: IFFALSE 11288
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
11270: LD_EXP 26
11274: PPUSH
11275: LD_INT 85
11277: PPUSH
11278: LD_INT 78
11280: PPUSH
11281: LD_INT 0
11283: PPUSH
11284: CALL_OW 48
// uc_side := 5 ;
11288: LD_ADDR_OWVAR 20
11292: PUSH
11293: LD_INT 5
11295: ST_TO_ADDR
// uc_nation := 2 ;
11296: LD_ADDR_OWVAR 21
11300: PUSH
11301: LD_INT 2
11303: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , false ,  ) ;
11304: LD_ADDR_EXP 27
11308: PUSH
11309: LD_STRING Aviradze
11311: PPUSH
11312: LD_INT 0
11314: PPUSH
11315: LD_STRING 
11317: PPUSH
11318: CALL 237 0 3
11322: ST_TO_ADDR
// PlaceUnitXY ( Aviradze , 106 , 38 , false ) ;
11323: LD_EXP 27
11327: PPUSH
11328: LD_INT 106
11330: PPUSH
11331: LD_INT 38
11333: PPUSH
11334: LD_INT 0
11336: PPUSH
11337: CALL_OW 48
// ComTurnXY ( Aviradze , 103 , 38 ) ;
11341: LD_EXP 27
11345: PPUSH
11346: LD_INT 103
11348: PPUSH
11349: LD_INT 38
11351: PPUSH
11352: CALL_OW 118
// Kaia := PrepareUnit ( Kaia , false ,  ) ;
11356: LD_ADDR_EXP 28
11360: PUSH
11361: LD_STRING Kaia
11363: PPUSH
11364: LD_INT 0
11366: PPUSH
11367: LD_STRING 
11369: PPUSH
11370: CALL 237 0 3
11374: ST_TO_ADDR
// PlaceUnitXY ( Kaia , 100 , 34 , false ) ;
11375: LD_EXP 28
11379: PPUSH
11380: LD_INT 100
11382: PPUSH
11383: LD_INT 34
11385: PPUSH
11386: LD_INT 0
11388: PPUSH
11389: CALL_OW 48
// ComTurnXY ( Kaia , 100 , 39 ) ;
11393: LD_EXP 28
11397: PPUSH
11398: LD_INT 100
11400: PPUSH
11401: LD_INT 39
11403: PPUSH
11404: CALL_OW 118
// Sophia := PrepareUnit ( Sophia , false ,  ) ;
11408: LD_ADDR_EXP 29
11412: PUSH
11413: LD_STRING Sophia
11415: PPUSH
11416: LD_INT 0
11418: PPUSH
11419: LD_STRING 
11421: PPUSH
11422: CALL 237 0 3
11426: ST_TO_ADDR
// PlaceUnitXY ( Sophia , 109 , 50 , false ) ;
11427: LD_EXP 29
11431: PPUSH
11432: LD_INT 109
11434: PPUSH
11435: LD_INT 50
11437: PPUSH
11438: LD_INT 0
11440: PPUSH
11441: CALL_OW 48
// ComTurnXY ( Sophia , 100 , 39 ) ;
11445: LD_EXP 29
11449: PPUSH
11450: LD_INT 100
11452: PPUSH
11453: LD_INT 39
11455: PPUSH
11456: CALL_OW 118
// Markov := PrepareUnit ( Markov , false ,  ) ;
11460: LD_ADDR_EXP 30
11464: PUSH
11465: LD_STRING Markov
11467: PPUSH
11468: LD_INT 0
11470: PPUSH
11471: LD_STRING 
11473: PPUSH
11474: CALL 237 0 3
11478: ST_TO_ADDR
// PrepareTank ( 5 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , [ 90 , 70 , 60 ] [ Difficulty ] ) ;
11479: LD_INT 5
11481: PPUSH
11482: LD_INT 3
11484: PPUSH
11485: LD_INT 21
11487: PPUSH
11488: LD_INT 1
11490: PPUSH
11491: LD_INT 1
11493: PPUSH
11494: LD_INT 42
11496: PPUSH
11497: LD_INT 90
11499: PUSH
11500: LD_INT 70
11502: PUSH
11503: LD_INT 60
11505: PUSH
11506: EMPTY
11507: LIST
11508: LIST
11509: LIST
11510: PUSH
11511: LD_OWVAR 67
11515: ARRAY
11516: PPUSH
11517: CALL 300 0 7
// veh := CreateVehicle ;
11521: LD_ADDR_VAR 0 3
11525: PUSH
11526: CALL_OW 45
11530: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
11531: LD_VAR 0 3
11535: PPUSH
11536: LD_INT 4
11538: PPUSH
11539: CALL_OW 233
// PlaceUnitXY ( veh , 109 , 38 , false ) ;
11543: LD_VAR 0 3
11547: PPUSH
11548: LD_INT 109
11550: PPUSH
11551: LD_INT 38
11553: PPUSH
11554: LD_INT 0
11556: PPUSH
11557: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
11561: LD_EXP 30
11565: PPUSH
11566: LD_VAR 0 3
11570: PPUSH
11571: CALL_OW 52
// ComTurnUnit ( Kaia , Aviradze ) ;
11575: LD_EXP 28
11579: PPUSH
11580: LD_EXP 27
11584: PPUSH
11585: CALL_OW 119
// ComTurnUnit ( Aviradze , Kaia ) ;
11589: LD_EXP 27
11593: PPUSH
11594: LD_EXP 28
11598: PPUSH
11599: CALL_OW 119
// if not Givi or not Mike then
11603: LD_EXP 24
11607: NOT
11608: PUSH
11609: LD_EXP 25
11613: NOT
11614: OR
11615: IFFALSE 11691
// begin uc_nation := 2 ;
11617: LD_ADDR_OWVAR 21
11621: PUSH
11622: LD_INT 2
11624: ST_TO_ADDR
// uc_side := 5 ;
11625: LD_ADDR_OWVAR 20
11629: PUSH
11630: LD_INT 5
11632: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 1 ) ;
11633: LD_INT 1
11635: PPUSH
11636: LD_INT 1
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: CALL_OW 380
// un := CreateHuman ;
11646: LD_ADDR_VAR 0 2
11650: PUSH
11651: CALL_OW 44
11655: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 40 , 3 , false ) ;
11656: LD_VAR 0 2
11660: PPUSH
11661: LD_INT 112
11663: PPUSH
11664: LD_INT 40
11666: PPUSH
11667: LD_INT 3
11669: PPUSH
11670: LD_INT 0
11672: PPUSH
11673: CALL_OW 50
// ComTurnUnit ( un , Aviradze ) ;
11677: LD_VAR 0 2
11681: PPUSH
11682: LD_EXP 27
11686: PPUSH
11687: CALL_OW 119
// end ; end ;
11691: LD_VAR 0 1
11695: RET
// export function PrepareFarmer ; var i ; begin
11696: LD_INT 0
11698: PPUSH
11699: PPUSH
// uc_side := 5 ;
11700: LD_ADDR_OWVAR 20
11704: PUSH
11705: LD_INT 5
11707: ST_TO_ADDR
// uc_nation := 2 ;
11708: LD_ADDR_OWVAR 21
11712: PUSH
11713: LD_INT 2
11715: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
11716: LD_ADDR_EXP 31
11720: PUSH
11721: LD_STRING Farmer
11723: PPUSH
11724: LD_INT 0
11726: PPUSH
11727: LD_STRING 
11729: PPUSH
11730: CALL 237 0 3
11734: ST_TO_ADDR
// PlaceUnitXY ( Farmer , 106 , 62 , false ) ;
11735: LD_EXP 31
11739: PPUSH
11740: LD_INT 106
11742: PPUSH
11743: LD_INT 62
11745: PPUSH
11746: LD_INT 0
11748: PPUSH
11749: CALL_OW 48
// for i := 1 to 5 do
11753: LD_ADDR_VAR 0 2
11757: PUSH
11758: DOUBLE
11759: LD_INT 1
11761: DEC
11762: ST_TO_ADDR
11763: LD_INT 5
11765: PUSH
11766: FOR_TO
11767: IFFALSE 11805
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
11769: LD_INT 1
11771: PPUSH
11772: LD_INT 1
11774: PPUSH
11775: LD_INT 1
11777: PPUSH
11778: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 105 , 64 , 3 , false ) ;
11782: CALL_OW 44
11786: PPUSH
11787: LD_INT 105
11789: PPUSH
11790: LD_INT 64
11792: PPUSH
11793: LD_INT 3
11795: PPUSH
11796: LD_INT 0
11798: PPUSH
11799: CALL_OW 50
// end ;
11803: GO 11766
11805: POP
11806: POP
// end ; end_of_file
11807: LD_VAR 0 1
11811: RET
// every 2 2$20 + 0 0$10 do
11812: GO 11814
11814: DISABLE
// begin enable ;
11815: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , forest , true ) ;
11816: LD_INT 1
11818: PPUSH
11819: LD_INT 5
11821: PPUSH
11822: CALL_OW 12
11826: PPUSH
11827: LD_INT 1
11829: PPUSH
11830: LD_INT 1
11832: PPUSH
11833: CALL_OW 55
// if tick > 6 6$00 then
11837: LD_OWVAR 1
11841: PUSH
11842: LD_INT 12600
11844: GREATER
11845: IFFALSE 11848
// disable ;
11847: DISABLE
// end ; end_of_file
11848: END
// on UnitDestroyed ( un ) do begin if un = Heike then
11849: LD_VAR 0 1
11853: PUSH
11854: LD_EXP 23
11858: EQUAL
11859: IFFALSE 11868
// YouLost ( Heike ) ;
11861: LD_STRING Heike
11863: PPUSH
11864: CALL_OW 104
// if un = Aviradze then
11868: LD_VAR 0 1
11872: PUSH
11873: LD_EXP 27
11877: EQUAL
11878: IFFALSE 11887
// YouLost ( Aviradze ) ;
11880: LD_STRING Aviradze
11882: PPUSH
11883: CALL_OW 104
// if un = usLab then
11887: LD_VAR 0 1
11891: PUSH
11892: LD_INT 3
11894: EQUAL
11895: IFFALSE 11904
// YouLost ( Lab ) ;
11897: LD_STRING Lab
11899: PPUSH
11900: CALL_OW 104
// if ( un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) diff [ Heike , Aviradze ] ) and aviradzeSpotted then
11904: LD_VAR 0 1
11908: PUSH
11909: LD_INT 22
11911: PUSH
11912: LD_INT 2
11914: PUSH
11915: EMPTY
11916: LIST
11917: LIST
11918: PUSH
11919: LD_INT 21
11921: PUSH
11922: LD_INT 1
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PUSH
11929: LD_INT 23
11931: PUSH
11932: LD_INT 2
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: LIST
11943: PPUSH
11944: CALL_OW 69
11948: PUSH
11949: LD_EXP 23
11953: PUSH
11954: LD_EXP 27
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: DIFF
11963: IN
11964: PUSH
11965: LD_EXP 4
11969: AND
11970: IFFALSE 11986
// lostCounter := lostCounter + 1 ;
11972: LD_ADDR_EXP 18
11976: PUSH
11977: LD_EXP 18
11981: PUSH
11982: LD_INT 1
11984: PLUS
11985: ST_TO_ADDR
// end ;
11986: PPOPN 1
11988: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_nation , 2 ] , [ f_class , 2 ] ] ) = 0 do
11989: LD_INT 23
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: LD_INT 25
12001: PUSH
12002: LD_INT 2
12004: PUSH
12005: EMPTY
12006: LIST
12007: LIST
12008: PUSH
12009: EMPTY
12010: LIST
12011: LIST
12012: PPUSH
12013: CALL_OW 69
12017: PUSH
12018: LD_INT 0
12020: EQUAL
12021: IFFALSE 12033
12023: GO 12025
12025: DISABLE
// YouLost ( Eng ) ;
12026: LD_STRING Eng
12028: PPUSH
12029: CALL_OW 104
12033: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un in usSci and killerSide = 2 then
12034: LD_VAR 0 1
12038: PUSH
12039: LD_EXP 22
12043: IN
12044: PUSH
12045: LD_VAR 0 2
12049: PUSH
12050: LD_INT 2
12052: EQUAL
12053: AND
12054: IFFALSE 12086
// begin usSci := usSci diff un ;
12056: LD_ADDR_EXP 22
12060: PUSH
12061: LD_EXP 22
12065: PUSH
12066: LD_VAR 0 1
12070: DIFF
12071: ST_TO_ADDR
// sciCounterKill := sciCounterKill + 1 ;
12072: LD_ADDR_EXP 9
12076: PUSH
12077: LD_EXP 9
12081: PUSH
12082: LD_INT 1
12084: PLUS
12085: ST_TO_ADDR
// end ; end ;
12086: PPOPN 3
12088: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
12089: LD_VAR 0 1
12093: PUSH
12094: LD_INT 2
12096: EQUAL
12097: PUSH
12098: LD_VAR 0 2
12102: PUSH
12103: LD_INT 5
12105: EQUAL
12106: AND
12107: IFFALSE 12116
// YouLost ( FriendlyFire ) ;
12109: LD_STRING FriendlyFire
12111: PPUSH
12112: CALL_OW 104
// end ; end_of_file
12116: PPOPN 2
12118: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
12119: GO 12121
12121: DISABLE
// begin ru_radar := 98 ;
12122: LD_ADDR_EXP 32
12126: PUSH
12127: LD_INT 98
12129: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
12130: LD_ADDR_EXP 33
12134: PUSH
12135: LD_INT 89
12137: ST_TO_ADDR
// us_hack := 99 ;
12138: LD_ADDR_EXP 34
12142: PUSH
12143: LD_INT 99
12145: ST_TO_ADDR
// us_artillery := 97 ;
12146: LD_ADDR_EXP 35
12150: PUSH
12151: LD_INT 97
12153: ST_TO_ADDR
// ar_bio_bomb := 91 ;
12154: LD_ADDR_EXP 36
12158: PUSH
12159: LD_INT 91
12161: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
12162: LD_ADDR_EXP 37
12166: PUSH
12167: LD_INT 92
12169: ST_TO_ADDR
// tech_Artillery := 80 ;
12170: LD_ADDR_EXP 38
12174: PUSH
12175: LD_INT 80
12177: ST_TO_ADDR
// tech_RadMat := 81 ;
12178: LD_ADDR_EXP 39
12182: PUSH
12183: LD_INT 81
12185: ST_TO_ADDR
// tech_BasicTools := 82 ;
12186: LD_ADDR_EXP 40
12190: PUSH
12191: LD_INT 82
12193: ST_TO_ADDR
// tech_Cargo := 83 ;
12194: LD_ADDR_EXP 41
12198: PUSH
12199: LD_INT 83
12201: ST_TO_ADDR
// tech_Track := 84 ;
12202: LD_ADDR_EXP 42
12206: PUSH
12207: LD_INT 84
12209: ST_TO_ADDR
// tech_Crane := 85 ;
12210: LD_ADDR_EXP 43
12214: PUSH
12215: LD_INT 85
12217: ST_TO_ADDR
// tech_Bulldozer := 86 ;
12218: LD_ADDR_EXP 44
12222: PUSH
12223: LD_INT 86
12225: ST_TO_ADDR
// tech_Hovercraft := 87 ;
12226: LD_ADDR_EXP 45
12230: PUSH
12231: LD_INT 87
12233: ST_TO_ADDR
// end ; end_of_file end_of_file
12234: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
12235: GO 12237
12237: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
12238: LD_STRING initStreamRollete();
12240: PPUSH
12241: CALL_OW 559
// InitStreamMode ;
12245: CALL 12254 0 0
// DefineStreamItems ( ) ;
12249: CALL 12694 0 0
// end ;
12253: END
// function InitStreamMode ; begin
12254: LD_INT 0
12256: PPUSH
// streamModeActive := false ;
12257: LD_ADDR_EXP 46
12261: PUSH
12262: LD_INT 0
12264: ST_TO_ADDR
// normalCounter := 36 ;
12265: LD_ADDR_EXP 47
12269: PUSH
12270: LD_INT 36
12272: ST_TO_ADDR
// hardcoreCounter := 16 ;
12273: LD_ADDR_EXP 48
12277: PUSH
12278: LD_INT 16
12280: ST_TO_ADDR
// sRocket := false ;
12281: LD_ADDR_EXP 51
12285: PUSH
12286: LD_INT 0
12288: ST_TO_ADDR
// sSpeed := false ;
12289: LD_ADDR_EXP 50
12293: PUSH
12294: LD_INT 0
12296: ST_TO_ADDR
// sEngine := false ;
12297: LD_ADDR_EXP 52
12301: PUSH
12302: LD_INT 0
12304: ST_TO_ADDR
// sSpec := false ;
12305: LD_ADDR_EXP 49
12309: PUSH
12310: LD_INT 0
12312: ST_TO_ADDR
// sLevel := false ;
12313: LD_ADDR_EXP 53
12317: PUSH
12318: LD_INT 0
12320: ST_TO_ADDR
// sArmoury := false ;
12321: LD_ADDR_EXP 54
12325: PUSH
12326: LD_INT 0
12328: ST_TO_ADDR
// sRadar := false ;
12329: LD_ADDR_EXP 55
12333: PUSH
12334: LD_INT 0
12336: ST_TO_ADDR
// sBunker := false ;
12337: LD_ADDR_EXP 56
12341: PUSH
12342: LD_INT 0
12344: ST_TO_ADDR
// sHack := false ;
12345: LD_ADDR_EXP 57
12349: PUSH
12350: LD_INT 0
12352: ST_TO_ADDR
// sFire := false ;
12353: LD_ADDR_EXP 58
12357: PUSH
12358: LD_INT 0
12360: ST_TO_ADDR
// sRefresh := false ;
12361: LD_ADDR_EXP 59
12365: PUSH
12366: LD_INT 0
12368: ST_TO_ADDR
// sExp := false ;
12369: LD_ADDR_EXP 60
12373: PUSH
12374: LD_INT 0
12376: ST_TO_ADDR
// sDepot := false ;
12377: LD_ADDR_EXP 61
12381: PUSH
12382: LD_INT 0
12384: ST_TO_ADDR
// sFlag := false ;
12385: LD_ADDR_EXP 62
12389: PUSH
12390: LD_INT 0
12392: ST_TO_ADDR
// sKamikadze := false ;
12393: LD_ADDR_EXP 70
12397: PUSH
12398: LD_INT 0
12400: ST_TO_ADDR
// sTroll := false ;
12401: LD_ADDR_EXP 71
12405: PUSH
12406: LD_INT 0
12408: ST_TO_ADDR
// sSlow := false ;
12409: LD_ADDR_EXP 72
12413: PUSH
12414: LD_INT 0
12416: ST_TO_ADDR
// sLack := false ;
12417: LD_ADDR_EXP 73
12421: PUSH
12422: LD_INT 0
12424: ST_TO_ADDR
// sTank := false ;
12425: LD_ADDR_EXP 75
12429: PUSH
12430: LD_INT 0
12432: ST_TO_ADDR
// sRemote := false ;
12433: LD_ADDR_EXP 76
12437: PUSH
12438: LD_INT 0
12440: ST_TO_ADDR
// sPowell := false ;
12441: LD_ADDR_EXP 77
12445: PUSH
12446: LD_INT 0
12448: ST_TO_ADDR
// sTeleport := false ;
12449: LD_ADDR_EXP 80
12453: PUSH
12454: LD_INT 0
12456: ST_TO_ADDR
// sOilTower := false ;
12457: LD_ADDR_EXP 82
12461: PUSH
12462: LD_INT 0
12464: ST_TO_ADDR
// sShovel := false ;
12465: LD_ADDR_EXP 83
12469: PUSH
12470: LD_INT 0
12472: ST_TO_ADDR
// sSheik := false ;
12473: LD_ADDR_EXP 84
12477: PUSH
12478: LD_INT 0
12480: ST_TO_ADDR
// sEarthquake := false ;
12481: LD_ADDR_EXP 86
12485: PUSH
12486: LD_INT 0
12488: ST_TO_ADDR
// sAI := false ;
12489: LD_ADDR_EXP 87
12493: PUSH
12494: LD_INT 0
12496: ST_TO_ADDR
// sCargo := false ;
12497: LD_ADDR_EXP 90
12501: PUSH
12502: LD_INT 0
12504: ST_TO_ADDR
// sDLaser := false ;
12505: LD_ADDR_EXP 91
12509: PUSH
12510: LD_INT 0
12512: ST_TO_ADDR
// sExchange := false ;
12513: LD_ADDR_EXP 92
12517: PUSH
12518: LD_INT 0
12520: ST_TO_ADDR
// sFac := false ;
12521: LD_ADDR_EXP 93
12525: PUSH
12526: LD_INT 0
12528: ST_TO_ADDR
// sPower := false ;
12529: LD_ADDR_EXP 94
12533: PUSH
12534: LD_INT 0
12536: ST_TO_ADDR
// sRandom := false ;
12537: LD_ADDR_EXP 95
12541: PUSH
12542: LD_INT 0
12544: ST_TO_ADDR
// sShield := false ;
12545: LD_ADDR_EXP 96
12549: PUSH
12550: LD_INT 0
12552: ST_TO_ADDR
// sTime := false ;
12553: LD_ADDR_EXP 97
12557: PUSH
12558: LD_INT 0
12560: ST_TO_ADDR
// sTools := false ;
12561: LD_ADDR_EXP 98
12565: PUSH
12566: LD_INT 0
12568: ST_TO_ADDR
// sSold := false ;
12569: LD_ADDR_EXP 63
12573: PUSH
12574: LD_INT 0
12576: ST_TO_ADDR
// sDiff := false ;
12577: LD_ADDR_EXP 64
12581: PUSH
12582: LD_INT 0
12584: ST_TO_ADDR
// sFog := false ;
12585: LD_ADDR_EXP 67
12589: PUSH
12590: LD_INT 0
12592: ST_TO_ADDR
// sReset := false ;
12593: LD_ADDR_EXP 68
12597: PUSH
12598: LD_INT 0
12600: ST_TO_ADDR
// sSun := false ;
12601: LD_ADDR_EXP 69
12605: PUSH
12606: LD_INT 0
12608: ST_TO_ADDR
// sTiger := false ;
12609: LD_ADDR_EXP 65
12613: PUSH
12614: LD_INT 0
12616: ST_TO_ADDR
// sBomb := false ;
12617: LD_ADDR_EXP 66
12621: PUSH
12622: LD_INT 0
12624: ST_TO_ADDR
// sWound := false ;
12625: LD_ADDR_EXP 74
12629: PUSH
12630: LD_INT 0
12632: ST_TO_ADDR
// sBetray := false ;
12633: LD_ADDR_EXP 78
12637: PUSH
12638: LD_INT 0
12640: ST_TO_ADDR
// sContamin := false ;
12641: LD_ADDR_EXP 79
12645: PUSH
12646: LD_INT 0
12648: ST_TO_ADDR
// sOil := false ;
12649: LD_ADDR_EXP 81
12653: PUSH
12654: LD_INT 0
12656: ST_TO_ADDR
// sStu := false ;
12657: LD_ADDR_EXP 85
12661: PUSH
12662: LD_INT 0
12664: ST_TO_ADDR
// sBazooka := false ;
12665: LD_ADDR_EXP 88
12669: PUSH
12670: LD_INT 0
12672: ST_TO_ADDR
// sMortar := false ;
12673: LD_ADDR_EXP 89
12677: PUSH
12678: LD_INT 0
12680: ST_TO_ADDR
// sRanger := false ;
12681: LD_ADDR_EXP 99
12685: PUSH
12686: LD_INT 0
12688: ST_TO_ADDR
// end ;
12689: LD_VAR 0 1
12693: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
12694: LD_INT 0
12696: PPUSH
12697: PPUSH
12698: PPUSH
12699: PPUSH
12700: PPUSH
// result := [ ] ;
12701: LD_ADDR_VAR 0 1
12705: PUSH
12706: EMPTY
12707: ST_TO_ADDR
// if campaign_id = 1 then
12708: LD_OWVAR 69
12712: PUSH
12713: LD_INT 1
12715: EQUAL
12716: IFFALSE 15654
// begin case mission_number of 1 :
12718: LD_OWVAR 70
12722: PUSH
12723: LD_INT 1
12725: DOUBLE
12726: EQUAL
12727: IFTRUE 12731
12729: GO 12795
12731: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
12732: LD_ADDR_VAR 0 1
12736: PUSH
12737: LD_INT 2
12739: PUSH
12740: LD_INT 4
12742: PUSH
12743: LD_INT 11
12745: PUSH
12746: LD_INT 12
12748: PUSH
12749: LD_INT 15
12751: PUSH
12752: LD_INT 16
12754: PUSH
12755: LD_INT 22
12757: PUSH
12758: LD_INT 23
12760: PUSH
12761: LD_INT 26
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: PUSH
12775: LD_INT 101
12777: PUSH
12778: LD_INT 102
12780: PUSH
12781: LD_INT 106
12783: PUSH
12784: EMPTY
12785: LIST
12786: LIST
12787: LIST
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: ST_TO_ADDR
12793: GO 15652
12795: LD_INT 2
12797: DOUBLE
12798: EQUAL
12799: IFTRUE 12803
12801: GO 12875
12803: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
12804: LD_ADDR_VAR 0 1
12808: PUSH
12809: LD_INT 2
12811: PUSH
12812: LD_INT 4
12814: PUSH
12815: LD_INT 11
12817: PUSH
12818: LD_INT 12
12820: PUSH
12821: LD_INT 15
12823: PUSH
12824: LD_INT 16
12826: PUSH
12827: LD_INT 22
12829: PUSH
12830: LD_INT 23
12832: PUSH
12833: LD_INT 26
12835: PUSH
12836: EMPTY
12837: LIST
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: LIST
12844: LIST
12845: LIST
12846: PUSH
12847: LD_INT 101
12849: PUSH
12850: LD_INT 102
12852: PUSH
12853: LD_INT 105
12855: PUSH
12856: LD_INT 106
12858: PUSH
12859: LD_INT 108
12861: PUSH
12862: EMPTY
12863: LIST
12864: LIST
12865: LIST
12866: LIST
12867: LIST
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: ST_TO_ADDR
12873: GO 15652
12875: LD_INT 3
12877: DOUBLE
12878: EQUAL
12879: IFTRUE 12883
12881: GO 12959
12883: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
12884: LD_ADDR_VAR 0 1
12888: PUSH
12889: LD_INT 2
12891: PUSH
12892: LD_INT 4
12894: PUSH
12895: LD_INT 5
12897: PUSH
12898: LD_INT 11
12900: PUSH
12901: LD_INT 12
12903: PUSH
12904: LD_INT 15
12906: PUSH
12907: LD_INT 16
12909: PUSH
12910: LD_INT 22
12912: PUSH
12913: LD_INT 26
12915: PUSH
12916: LD_INT 36
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: LIST
12929: LIST
12930: PUSH
12931: LD_INT 101
12933: PUSH
12934: LD_INT 102
12936: PUSH
12937: LD_INT 105
12939: PUSH
12940: LD_INT 106
12942: PUSH
12943: LD_INT 108
12945: PUSH
12946: EMPTY
12947: LIST
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: ST_TO_ADDR
12957: GO 15652
12959: LD_INT 4
12961: DOUBLE
12962: EQUAL
12963: IFTRUE 12967
12965: GO 13051
12967: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
12968: LD_ADDR_VAR 0 1
12972: PUSH
12973: LD_INT 2
12975: PUSH
12976: LD_INT 4
12978: PUSH
12979: LD_INT 5
12981: PUSH
12982: LD_INT 8
12984: PUSH
12985: LD_INT 11
12987: PUSH
12988: LD_INT 12
12990: PUSH
12991: LD_INT 15
12993: PUSH
12994: LD_INT 16
12996: PUSH
12997: LD_INT 22
12999: PUSH
13000: LD_INT 23
13002: PUSH
13003: LD_INT 26
13005: PUSH
13006: LD_INT 36
13008: PUSH
13009: EMPTY
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: PUSH
13023: LD_INT 101
13025: PUSH
13026: LD_INT 102
13028: PUSH
13029: LD_INT 105
13031: PUSH
13032: LD_INT 106
13034: PUSH
13035: LD_INT 108
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: LIST
13043: LIST
13044: PUSH
13045: EMPTY
13046: LIST
13047: LIST
13048: ST_TO_ADDR
13049: GO 15652
13051: LD_INT 5
13053: DOUBLE
13054: EQUAL
13055: IFTRUE 13059
13057: GO 13159
13059: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
13060: LD_ADDR_VAR 0 1
13064: PUSH
13065: LD_INT 2
13067: PUSH
13068: LD_INT 4
13070: PUSH
13071: LD_INT 5
13073: PUSH
13074: LD_INT 6
13076: PUSH
13077: LD_INT 8
13079: PUSH
13080: LD_INT 11
13082: PUSH
13083: LD_INT 12
13085: PUSH
13086: LD_INT 15
13088: PUSH
13089: LD_INT 16
13091: PUSH
13092: LD_INT 22
13094: PUSH
13095: LD_INT 23
13097: PUSH
13098: LD_INT 25
13100: PUSH
13101: LD_INT 26
13103: PUSH
13104: LD_INT 36
13106: PUSH
13107: EMPTY
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: PUSH
13123: LD_INT 101
13125: PUSH
13126: LD_INT 102
13128: PUSH
13129: LD_INT 105
13131: PUSH
13132: LD_INT 106
13134: PUSH
13135: LD_INT 108
13137: PUSH
13138: LD_INT 109
13140: PUSH
13141: LD_INT 112
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: LIST
13152: PUSH
13153: EMPTY
13154: LIST
13155: LIST
13156: ST_TO_ADDR
13157: GO 15652
13159: LD_INT 6
13161: DOUBLE
13162: EQUAL
13163: IFTRUE 13167
13165: GO 13287
13167: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
13168: LD_ADDR_VAR 0 1
13172: PUSH
13173: LD_INT 2
13175: PUSH
13176: LD_INT 4
13178: PUSH
13179: LD_INT 5
13181: PUSH
13182: LD_INT 6
13184: PUSH
13185: LD_INT 8
13187: PUSH
13188: LD_INT 11
13190: PUSH
13191: LD_INT 12
13193: PUSH
13194: LD_INT 15
13196: PUSH
13197: LD_INT 16
13199: PUSH
13200: LD_INT 20
13202: PUSH
13203: LD_INT 21
13205: PUSH
13206: LD_INT 22
13208: PUSH
13209: LD_INT 23
13211: PUSH
13212: LD_INT 25
13214: PUSH
13215: LD_INT 26
13217: PUSH
13218: LD_INT 30
13220: PUSH
13221: LD_INT 31
13223: PUSH
13224: LD_INT 32
13226: PUSH
13227: LD_INT 36
13229: PUSH
13230: EMPTY
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: LIST
13244: LIST
13245: LIST
13246: LIST
13247: LIST
13248: LIST
13249: LIST
13250: PUSH
13251: LD_INT 101
13253: PUSH
13254: LD_INT 102
13256: PUSH
13257: LD_INT 105
13259: PUSH
13260: LD_INT 106
13262: PUSH
13263: LD_INT 108
13265: PUSH
13266: LD_INT 109
13268: PUSH
13269: LD_INT 112
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: PUSH
13281: EMPTY
13282: LIST
13283: LIST
13284: ST_TO_ADDR
13285: GO 15652
13287: LD_INT 7
13289: DOUBLE
13290: EQUAL
13291: IFTRUE 13295
13293: GO 13395
13295: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
13296: LD_ADDR_VAR 0 1
13300: PUSH
13301: LD_INT 2
13303: PUSH
13304: LD_INT 4
13306: PUSH
13307: LD_INT 5
13309: PUSH
13310: LD_INT 7
13312: PUSH
13313: LD_INT 11
13315: PUSH
13316: LD_INT 12
13318: PUSH
13319: LD_INT 15
13321: PUSH
13322: LD_INT 16
13324: PUSH
13325: LD_INT 20
13327: PUSH
13328: LD_INT 21
13330: PUSH
13331: LD_INT 22
13333: PUSH
13334: LD_INT 23
13336: PUSH
13337: LD_INT 25
13339: PUSH
13340: LD_INT 26
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: LIST
13347: LIST
13348: LIST
13349: LIST
13350: LIST
13351: LIST
13352: LIST
13353: LIST
13354: LIST
13355: LIST
13356: LIST
13357: LIST
13358: PUSH
13359: LD_INT 101
13361: PUSH
13362: LD_INT 102
13364: PUSH
13365: LD_INT 103
13367: PUSH
13368: LD_INT 105
13370: PUSH
13371: LD_INT 106
13373: PUSH
13374: LD_INT 108
13376: PUSH
13377: LD_INT 112
13379: PUSH
13380: EMPTY
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: PUSH
13389: EMPTY
13390: LIST
13391: LIST
13392: ST_TO_ADDR
13393: GO 15652
13395: LD_INT 8
13397: DOUBLE
13398: EQUAL
13399: IFTRUE 13403
13401: GO 13531
13403: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
13404: LD_ADDR_VAR 0 1
13408: PUSH
13409: LD_INT 2
13411: PUSH
13412: LD_INT 4
13414: PUSH
13415: LD_INT 5
13417: PUSH
13418: LD_INT 6
13420: PUSH
13421: LD_INT 7
13423: PUSH
13424: LD_INT 8
13426: PUSH
13427: LD_INT 11
13429: PUSH
13430: LD_INT 12
13432: PUSH
13433: LD_INT 15
13435: PUSH
13436: LD_INT 16
13438: PUSH
13439: LD_INT 20
13441: PUSH
13442: LD_INT 21
13444: PUSH
13445: LD_INT 22
13447: PUSH
13448: LD_INT 23
13450: PUSH
13451: LD_INT 25
13453: PUSH
13454: LD_INT 26
13456: PUSH
13457: LD_INT 30
13459: PUSH
13460: LD_INT 31
13462: PUSH
13463: LD_INT 32
13465: PUSH
13466: LD_INT 36
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: LIST
13473: LIST
13474: LIST
13475: LIST
13476: LIST
13477: LIST
13478: LIST
13479: LIST
13480: LIST
13481: LIST
13482: LIST
13483: LIST
13484: LIST
13485: LIST
13486: LIST
13487: LIST
13488: LIST
13489: LIST
13490: PUSH
13491: LD_INT 101
13493: PUSH
13494: LD_INT 102
13496: PUSH
13497: LD_INT 103
13499: PUSH
13500: LD_INT 105
13502: PUSH
13503: LD_INT 106
13505: PUSH
13506: LD_INT 108
13508: PUSH
13509: LD_INT 109
13511: PUSH
13512: LD_INT 112
13514: PUSH
13515: EMPTY
13516: LIST
13517: LIST
13518: LIST
13519: LIST
13520: LIST
13521: LIST
13522: LIST
13523: LIST
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: ST_TO_ADDR
13529: GO 15652
13531: LD_INT 9
13533: DOUBLE
13534: EQUAL
13535: IFTRUE 13539
13537: GO 13675
13539: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
13540: LD_ADDR_VAR 0 1
13544: PUSH
13545: LD_INT 2
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: LD_INT 5
13553: PUSH
13554: LD_INT 6
13556: PUSH
13557: LD_INT 7
13559: PUSH
13560: LD_INT 8
13562: PUSH
13563: LD_INT 11
13565: PUSH
13566: LD_INT 12
13568: PUSH
13569: LD_INT 15
13571: PUSH
13572: LD_INT 16
13574: PUSH
13575: LD_INT 20
13577: PUSH
13578: LD_INT 21
13580: PUSH
13581: LD_INT 22
13583: PUSH
13584: LD_INT 23
13586: PUSH
13587: LD_INT 25
13589: PUSH
13590: LD_INT 26
13592: PUSH
13593: LD_INT 28
13595: PUSH
13596: LD_INT 30
13598: PUSH
13599: LD_INT 31
13601: PUSH
13602: LD_INT 32
13604: PUSH
13605: LD_INT 36
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: LIST
13625: LIST
13626: LIST
13627: LIST
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 101
13633: PUSH
13634: LD_INT 102
13636: PUSH
13637: LD_INT 103
13639: PUSH
13640: LD_INT 105
13642: PUSH
13643: LD_INT 106
13645: PUSH
13646: LD_INT 108
13648: PUSH
13649: LD_INT 109
13651: PUSH
13652: LD_INT 112
13654: PUSH
13655: LD_INT 114
13657: PUSH
13658: EMPTY
13659: LIST
13660: LIST
13661: LIST
13662: LIST
13663: LIST
13664: LIST
13665: LIST
13666: LIST
13667: LIST
13668: PUSH
13669: EMPTY
13670: LIST
13671: LIST
13672: ST_TO_ADDR
13673: GO 15652
13675: LD_INT 10
13677: DOUBLE
13678: EQUAL
13679: IFTRUE 13683
13681: GO 13867
13683: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
13684: LD_ADDR_VAR 0 1
13688: PUSH
13689: LD_INT 2
13691: PUSH
13692: LD_INT 4
13694: PUSH
13695: LD_INT 5
13697: PUSH
13698: LD_INT 6
13700: PUSH
13701: LD_INT 7
13703: PUSH
13704: LD_INT 8
13706: PUSH
13707: LD_INT 9
13709: PUSH
13710: LD_INT 10
13712: PUSH
13713: LD_INT 11
13715: PUSH
13716: LD_INT 12
13718: PUSH
13719: LD_INT 13
13721: PUSH
13722: LD_INT 14
13724: PUSH
13725: LD_INT 15
13727: PUSH
13728: LD_INT 16
13730: PUSH
13731: LD_INT 17
13733: PUSH
13734: LD_INT 18
13736: PUSH
13737: LD_INT 19
13739: PUSH
13740: LD_INT 20
13742: PUSH
13743: LD_INT 21
13745: PUSH
13746: LD_INT 22
13748: PUSH
13749: LD_INT 23
13751: PUSH
13752: LD_INT 24
13754: PUSH
13755: LD_INT 25
13757: PUSH
13758: LD_INT 26
13760: PUSH
13761: LD_INT 28
13763: PUSH
13764: LD_INT 30
13766: PUSH
13767: LD_INT 31
13769: PUSH
13770: LD_INT 32
13772: PUSH
13773: LD_INT 36
13775: PUSH
13776: EMPTY
13777: LIST
13778: LIST
13779: LIST
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: LIST
13785: LIST
13786: LIST
13787: LIST
13788: LIST
13789: LIST
13790: LIST
13791: LIST
13792: LIST
13793: LIST
13794: LIST
13795: LIST
13796: LIST
13797: LIST
13798: LIST
13799: LIST
13800: LIST
13801: LIST
13802: LIST
13803: LIST
13804: LIST
13805: LIST
13806: PUSH
13807: LD_INT 101
13809: PUSH
13810: LD_INT 102
13812: PUSH
13813: LD_INT 103
13815: PUSH
13816: LD_INT 104
13818: PUSH
13819: LD_INT 105
13821: PUSH
13822: LD_INT 106
13824: PUSH
13825: LD_INT 107
13827: PUSH
13828: LD_INT 108
13830: PUSH
13831: LD_INT 109
13833: PUSH
13834: LD_INT 110
13836: PUSH
13837: LD_INT 111
13839: PUSH
13840: LD_INT 112
13842: PUSH
13843: LD_INT 114
13845: PUSH
13846: EMPTY
13847: LIST
13848: LIST
13849: LIST
13850: LIST
13851: LIST
13852: LIST
13853: LIST
13854: LIST
13855: LIST
13856: LIST
13857: LIST
13858: LIST
13859: LIST
13860: PUSH
13861: EMPTY
13862: LIST
13863: LIST
13864: ST_TO_ADDR
13865: GO 15652
13867: LD_INT 11
13869: DOUBLE
13870: EQUAL
13871: IFTRUE 13875
13873: GO 14067
13875: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
13876: LD_ADDR_VAR 0 1
13880: PUSH
13881: LD_INT 2
13883: PUSH
13884: LD_INT 3
13886: PUSH
13887: LD_INT 4
13889: PUSH
13890: LD_INT 5
13892: PUSH
13893: LD_INT 6
13895: PUSH
13896: LD_INT 7
13898: PUSH
13899: LD_INT 8
13901: PUSH
13902: LD_INT 9
13904: PUSH
13905: LD_INT 10
13907: PUSH
13908: LD_INT 11
13910: PUSH
13911: LD_INT 12
13913: PUSH
13914: LD_INT 13
13916: PUSH
13917: LD_INT 14
13919: PUSH
13920: LD_INT 15
13922: PUSH
13923: LD_INT 16
13925: PUSH
13926: LD_INT 17
13928: PUSH
13929: LD_INT 18
13931: PUSH
13932: LD_INT 19
13934: PUSH
13935: LD_INT 20
13937: PUSH
13938: LD_INT 21
13940: PUSH
13941: LD_INT 22
13943: PUSH
13944: LD_INT 23
13946: PUSH
13947: LD_INT 24
13949: PUSH
13950: LD_INT 25
13952: PUSH
13953: LD_INT 26
13955: PUSH
13956: LD_INT 28
13958: PUSH
13959: LD_INT 30
13961: PUSH
13962: LD_INT 31
13964: PUSH
13965: LD_INT 32
13967: PUSH
13968: LD_INT 34
13970: PUSH
13971: LD_INT 36
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: LIST
13983: LIST
13984: LIST
13985: LIST
13986: LIST
13987: LIST
13988: LIST
13989: LIST
13990: LIST
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: LIST
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: LIST
14006: PUSH
14007: LD_INT 101
14009: PUSH
14010: LD_INT 102
14012: PUSH
14013: LD_INT 103
14015: PUSH
14016: LD_INT 104
14018: PUSH
14019: LD_INT 105
14021: PUSH
14022: LD_INT 106
14024: PUSH
14025: LD_INT 107
14027: PUSH
14028: LD_INT 108
14030: PUSH
14031: LD_INT 109
14033: PUSH
14034: LD_INT 110
14036: PUSH
14037: LD_INT 111
14039: PUSH
14040: LD_INT 112
14042: PUSH
14043: LD_INT 114
14045: PUSH
14046: EMPTY
14047: LIST
14048: LIST
14049: LIST
14050: LIST
14051: LIST
14052: LIST
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: LIST
14058: LIST
14059: LIST
14060: PUSH
14061: EMPTY
14062: LIST
14063: LIST
14064: ST_TO_ADDR
14065: GO 15652
14067: LD_INT 12
14069: DOUBLE
14070: EQUAL
14071: IFTRUE 14075
14073: GO 14283
14075: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
14076: LD_ADDR_VAR 0 1
14080: PUSH
14081: LD_INT 1
14083: PUSH
14084: LD_INT 2
14086: PUSH
14087: LD_INT 3
14089: PUSH
14090: LD_INT 4
14092: PUSH
14093: LD_INT 5
14095: PUSH
14096: LD_INT 6
14098: PUSH
14099: LD_INT 7
14101: PUSH
14102: LD_INT 8
14104: PUSH
14105: LD_INT 9
14107: PUSH
14108: LD_INT 10
14110: PUSH
14111: LD_INT 11
14113: PUSH
14114: LD_INT 12
14116: PUSH
14117: LD_INT 13
14119: PUSH
14120: LD_INT 14
14122: PUSH
14123: LD_INT 15
14125: PUSH
14126: LD_INT 16
14128: PUSH
14129: LD_INT 17
14131: PUSH
14132: LD_INT 18
14134: PUSH
14135: LD_INT 19
14137: PUSH
14138: LD_INT 20
14140: PUSH
14141: LD_INT 21
14143: PUSH
14144: LD_INT 22
14146: PUSH
14147: LD_INT 23
14149: PUSH
14150: LD_INT 24
14152: PUSH
14153: LD_INT 25
14155: PUSH
14156: LD_INT 26
14158: PUSH
14159: LD_INT 27
14161: PUSH
14162: LD_INT 28
14164: PUSH
14165: LD_INT 30
14167: PUSH
14168: LD_INT 31
14170: PUSH
14171: LD_INT 32
14173: PUSH
14174: LD_INT 33
14176: PUSH
14177: LD_INT 34
14179: PUSH
14180: LD_INT 36
14182: PUSH
14183: EMPTY
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: LIST
14189: LIST
14190: LIST
14191: LIST
14192: LIST
14193: LIST
14194: LIST
14195: LIST
14196: LIST
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: PUSH
14219: LD_INT 101
14221: PUSH
14222: LD_INT 102
14224: PUSH
14225: LD_INT 103
14227: PUSH
14228: LD_INT 104
14230: PUSH
14231: LD_INT 105
14233: PUSH
14234: LD_INT 106
14236: PUSH
14237: LD_INT 107
14239: PUSH
14240: LD_INT 108
14242: PUSH
14243: LD_INT 109
14245: PUSH
14246: LD_INT 110
14248: PUSH
14249: LD_INT 111
14251: PUSH
14252: LD_INT 112
14254: PUSH
14255: LD_INT 113
14257: PUSH
14258: LD_INT 114
14260: PUSH
14261: EMPTY
14262: LIST
14263: LIST
14264: LIST
14265: LIST
14266: LIST
14267: LIST
14268: LIST
14269: LIST
14270: LIST
14271: LIST
14272: LIST
14273: LIST
14274: LIST
14275: LIST
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: ST_TO_ADDR
14281: GO 15652
14283: LD_INT 13
14285: DOUBLE
14286: EQUAL
14287: IFTRUE 14291
14289: GO 14487
14291: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
14292: LD_ADDR_VAR 0 1
14296: PUSH
14297: LD_INT 1
14299: PUSH
14300: LD_INT 2
14302: PUSH
14303: LD_INT 3
14305: PUSH
14306: LD_INT 4
14308: PUSH
14309: LD_INT 5
14311: PUSH
14312: LD_INT 8
14314: PUSH
14315: LD_INT 9
14317: PUSH
14318: LD_INT 10
14320: PUSH
14321: LD_INT 11
14323: PUSH
14324: LD_INT 12
14326: PUSH
14327: LD_INT 14
14329: PUSH
14330: LD_INT 15
14332: PUSH
14333: LD_INT 16
14335: PUSH
14336: LD_INT 17
14338: PUSH
14339: LD_INT 18
14341: PUSH
14342: LD_INT 19
14344: PUSH
14345: LD_INT 20
14347: PUSH
14348: LD_INT 21
14350: PUSH
14351: LD_INT 22
14353: PUSH
14354: LD_INT 23
14356: PUSH
14357: LD_INT 24
14359: PUSH
14360: LD_INT 25
14362: PUSH
14363: LD_INT 26
14365: PUSH
14366: LD_INT 27
14368: PUSH
14369: LD_INT 28
14371: PUSH
14372: LD_INT 30
14374: PUSH
14375: LD_INT 31
14377: PUSH
14378: LD_INT 32
14380: PUSH
14381: LD_INT 33
14383: PUSH
14384: LD_INT 34
14386: PUSH
14387: LD_INT 36
14389: PUSH
14390: EMPTY
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: LIST
14420: LIST
14421: LIST
14422: PUSH
14423: LD_INT 101
14425: PUSH
14426: LD_INT 102
14428: PUSH
14429: LD_INT 103
14431: PUSH
14432: LD_INT 104
14434: PUSH
14435: LD_INT 105
14437: PUSH
14438: LD_INT 106
14440: PUSH
14441: LD_INT 107
14443: PUSH
14444: LD_INT 108
14446: PUSH
14447: LD_INT 109
14449: PUSH
14450: LD_INT 110
14452: PUSH
14453: LD_INT 111
14455: PUSH
14456: LD_INT 112
14458: PUSH
14459: LD_INT 113
14461: PUSH
14462: LD_INT 114
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: LIST
14469: LIST
14470: LIST
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: LIST
14476: LIST
14477: LIST
14478: LIST
14479: LIST
14480: PUSH
14481: EMPTY
14482: LIST
14483: LIST
14484: ST_TO_ADDR
14485: GO 15652
14487: LD_INT 14
14489: DOUBLE
14490: EQUAL
14491: IFTRUE 14495
14493: GO 14707
14495: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
14496: LD_ADDR_VAR 0 1
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: LD_INT 2
14506: PUSH
14507: LD_INT 3
14509: PUSH
14510: LD_INT 4
14512: PUSH
14513: LD_INT 5
14515: PUSH
14516: LD_INT 6
14518: PUSH
14519: LD_INT 7
14521: PUSH
14522: LD_INT 8
14524: PUSH
14525: LD_INT 9
14527: PUSH
14528: LD_INT 10
14530: PUSH
14531: LD_INT 11
14533: PUSH
14534: LD_INT 12
14536: PUSH
14537: LD_INT 13
14539: PUSH
14540: LD_INT 14
14542: PUSH
14543: LD_INT 15
14545: PUSH
14546: LD_INT 16
14548: PUSH
14549: LD_INT 17
14551: PUSH
14552: LD_INT 18
14554: PUSH
14555: LD_INT 19
14557: PUSH
14558: LD_INT 20
14560: PUSH
14561: LD_INT 21
14563: PUSH
14564: LD_INT 22
14566: PUSH
14567: LD_INT 23
14569: PUSH
14570: LD_INT 24
14572: PUSH
14573: LD_INT 25
14575: PUSH
14576: LD_INT 26
14578: PUSH
14579: LD_INT 27
14581: PUSH
14582: LD_INT 28
14584: PUSH
14585: LD_INT 29
14587: PUSH
14588: LD_INT 30
14590: PUSH
14591: LD_INT 31
14593: PUSH
14594: LD_INT 32
14596: PUSH
14597: LD_INT 33
14599: PUSH
14600: LD_INT 34
14602: PUSH
14603: LD_INT 36
14605: PUSH
14606: EMPTY
14607: LIST
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: LIST
14617: LIST
14618: LIST
14619: LIST
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: LIST
14628: LIST
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: LIST
14636: LIST
14637: LIST
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: PUSH
14643: LD_INT 101
14645: PUSH
14646: LD_INT 102
14648: PUSH
14649: LD_INT 103
14651: PUSH
14652: LD_INT 104
14654: PUSH
14655: LD_INT 105
14657: PUSH
14658: LD_INT 106
14660: PUSH
14661: LD_INT 107
14663: PUSH
14664: LD_INT 108
14666: PUSH
14667: LD_INT 109
14669: PUSH
14670: LD_INT 110
14672: PUSH
14673: LD_INT 111
14675: PUSH
14676: LD_INT 112
14678: PUSH
14679: LD_INT 113
14681: PUSH
14682: LD_INT 114
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: LIST
14693: LIST
14694: LIST
14695: LIST
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: PUSH
14701: EMPTY
14702: LIST
14703: LIST
14704: ST_TO_ADDR
14705: GO 15652
14707: LD_INT 15
14709: DOUBLE
14710: EQUAL
14711: IFTRUE 14715
14713: GO 14927
14715: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
14716: LD_ADDR_VAR 0 1
14720: PUSH
14721: LD_INT 1
14723: PUSH
14724: LD_INT 2
14726: PUSH
14727: LD_INT 3
14729: PUSH
14730: LD_INT 4
14732: PUSH
14733: LD_INT 5
14735: PUSH
14736: LD_INT 6
14738: PUSH
14739: LD_INT 7
14741: PUSH
14742: LD_INT 8
14744: PUSH
14745: LD_INT 9
14747: PUSH
14748: LD_INT 10
14750: PUSH
14751: LD_INT 11
14753: PUSH
14754: LD_INT 12
14756: PUSH
14757: LD_INT 13
14759: PUSH
14760: LD_INT 14
14762: PUSH
14763: LD_INT 15
14765: PUSH
14766: LD_INT 16
14768: PUSH
14769: LD_INT 17
14771: PUSH
14772: LD_INT 18
14774: PUSH
14775: LD_INT 19
14777: PUSH
14778: LD_INT 20
14780: PUSH
14781: LD_INT 21
14783: PUSH
14784: LD_INT 22
14786: PUSH
14787: LD_INT 23
14789: PUSH
14790: LD_INT 24
14792: PUSH
14793: LD_INT 25
14795: PUSH
14796: LD_INT 26
14798: PUSH
14799: LD_INT 27
14801: PUSH
14802: LD_INT 28
14804: PUSH
14805: LD_INT 29
14807: PUSH
14808: LD_INT 30
14810: PUSH
14811: LD_INT 31
14813: PUSH
14814: LD_INT 32
14816: PUSH
14817: LD_INT 33
14819: PUSH
14820: LD_INT 34
14822: PUSH
14823: LD_INT 36
14825: PUSH
14826: EMPTY
14827: LIST
14828: LIST
14829: LIST
14830: LIST
14831: LIST
14832: LIST
14833: LIST
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: LIST
14855: LIST
14856: LIST
14857: LIST
14858: LIST
14859: LIST
14860: LIST
14861: LIST
14862: PUSH
14863: LD_INT 101
14865: PUSH
14866: LD_INT 102
14868: PUSH
14869: LD_INT 103
14871: PUSH
14872: LD_INT 104
14874: PUSH
14875: LD_INT 105
14877: PUSH
14878: LD_INT 106
14880: PUSH
14881: LD_INT 107
14883: PUSH
14884: LD_INT 108
14886: PUSH
14887: LD_INT 109
14889: PUSH
14890: LD_INT 110
14892: PUSH
14893: LD_INT 111
14895: PUSH
14896: LD_INT 112
14898: PUSH
14899: LD_INT 113
14901: PUSH
14902: LD_INT 114
14904: PUSH
14905: EMPTY
14906: LIST
14907: LIST
14908: LIST
14909: LIST
14910: LIST
14911: LIST
14912: LIST
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: PUSH
14921: EMPTY
14922: LIST
14923: LIST
14924: ST_TO_ADDR
14925: GO 15652
14927: LD_INT 16
14929: DOUBLE
14930: EQUAL
14931: IFTRUE 14935
14933: GO 15059
14935: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
14936: LD_ADDR_VAR 0 1
14940: PUSH
14941: LD_INT 2
14943: PUSH
14944: LD_INT 4
14946: PUSH
14947: LD_INT 5
14949: PUSH
14950: LD_INT 7
14952: PUSH
14953: LD_INT 11
14955: PUSH
14956: LD_INT 12
14958: PUSH
14959: LD_INT 15
14961: PUSH
14962: LD_INT 16
14964: PUSH
14965: LD_INT 20
14967: PUSH
14968: LD_INT 21
14970: PUSH
14971: LD_INT 22
14973: PUSH
14974: LD_INT 23
14976: PUSH
14977: LD_INT 25
14979: PUSH
14980: LD_INT 26
14982: PUSH
14983: LD_INT 30
14985: PUSH
14986: LD_INT 31
14988: PUSH
14989: LD_INT 32
14991: PUSH
14992: LD_INT 33
14994: PUSH
14995: LD_INT 34
14997: PUSH
14998: EMPTY
14999: LIST
15000: LIST
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: LIST
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: PUSH
15019: LD_INT 101
15021: PUSH
15022: LD_INT 102
15024: PUSH
15025: LD_INT 103
15027: PUSH
15028: LD_INT 106
15030: PUSH
15031: LD_INT 108
15033: PUSH
15034: LD_INT 112
15036: PUSH
15037: LD_INT 113
15039: PUSH
15040: LD_INT 114
15042: PUSH
15043: EMPTY
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: PUSH
15053: EMPTY
15054: LIST
15055: LIST
15056: ST_TO_ADDR
15057: GO 15652
15059: LD_INT 17
15061: DOUBLE
15062: EQUAL
15063: IFTRUE 15067
15065: GO 15279
15067: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
15068: LD_ADDR_VAR 0 1
15072: PUSH
15073: LD_INT 1
15075: PUSH
15076: LD_INT 2
15078: PUSH
15079: LD_INT 3
15081: PUSH
15082: LD_INT 4
15084: PUSH
15085: LD_INT 5
15087: PUSH
15088: LD_INT 6
15090: PUSH
15091: LD_INT 7
15093: PUSH
15094: LD_INT 8
15096: PUSH
15097: LD_INT 9
15099: PUSH
15100: LD_INT 10
15102: PUSH
15103: LD_INT 11
15105: PUSH
15106: LD_INT 12
15108: PUSH
15109: LD_INT 13
15111: PUSH
15112: LD_INT 14
15114: PUSH
15115: LD_INT 15
15117: PUSH
15118: LD_INT 16
15120: PUSH
15121: LD_INT 17
15123: PUSH
15124: LD_INT 18
15126: PUSH
15127: LD_INT 19
15129: PUSH
15130: LD_INT 20
15132: PUSH
15133: LD_INT 21
15135: PUSH
15136: LD_INT 22
15138: PUSH
15139: LD_INT 23
15141: PUSH
15142: LD_INT 24
15144: PUSH
15145: LD_INT 25
15147: PUSH
15148: LD_INT 26
15150: PUSH
15151: LD_INT 27
15153: PUSH
15154: LD_INT 28
15156: PUSH
15157: LD_INT 29
15159: PUSH
15160: LD_INT 30
15162: PUSH
15163: LD_INT 31
15165: PUSH
15166: LD_INT 32
15168: PUSH
15169: LD_INT 33
15171: PUSH
15172: LD_INT 34
15174: PUSH
15175: LD_INT 36
15177: PUSH
15178: EMPTY
15179: LIST
15180: LIST
15181: LIST
15182: LIST
15183: LIST
15184: LIST
15185: LIST
15186: LIST
15187: LIST
15188: LIST
15189: LIST
15190: LIST
15191: LIST
15192: LIST
15193: LIST
15194: LIST
15195: LIST
15196: LIST
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: LIST
15204: LIST
15205: LIST
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: PUSH
15215: LD_INT 101
15217: PUSH
15218: LD_INT 102
15220: PUSH
15221: LD_INT 103
15223: PUSH
15224: LD_INT 104
15226: PUSH
15227: LD_INT 105
15229: PUSH
15230: LD_INT 106
15232: PUSH
15233: LD_INT 107
15235: PUSH
15236: LD_INT 108
15238: PUSH
15239: LD_INT 109
15241: PUSH
15242: LD_INT 110
15244: PUSH
15245: LD_INT 111
15247: PUSH
15248: LD_INT 112
15250: PUSH
15251: LD_INT 113
15253: PUSH
15254: LD_INT 114
15256: PUSH
15257: EMPTY
15258: LIST
15259: LIST
15260: LIST
15261: LIST
15262: LIST
15263: LIST
15264: LIST
15265: LIST
15266: LIST
15267: LIST
15268: LIST
15269: LIST
15270: LIST
15271: LIST
15272: PUSH
15273: EMPTY
15274: LIST
15275: LIST
15276: ST_TO_ADDR
15277: GO 15652
15279: LD_INT 18
15281: DOUBLE
15282: EQUAL
15283: IFTRUE 15287
15285: GO 15423
15287: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
15288: LD_ADDR_VAR 0 1
15292: PUSH
15293: LD_INT 2
15295: PUSH
15296: LD_INT 4
15298: PUSH
15299: LD_INT 5
15301: PUSH
15302: LD_INT 7
15304: PUSH
15305: LD_INT 11
15307: PUSH
15308: LD_INT 12
15310: PUSH
15311: LD_INT 15
15313: PUSH
15314: LD_INT 16
15316: PUSH
15317: LD_INT 20
15319: PUSH
15320: LD_INT 21
15322: PUSH
15323: LD_INT 22
15325: PUSH
15326: LD_INT 23
15328: PUSH
15329: LD_INT 25
15331: PUSH
15332: LD_INT 26
15334: PUSH
15335: LD_INT 30
15337: PUSH
15338: LD_INT 31
15340: PUSH
15341: LD_INT 32
15343: PUSH
15344: LD_INT 33
15346: PUSH
15347: LD_INT 34
15349: PUSH
15350: LD_INT 35
15352: PUSH
15353: LD_INT 36
15355: PUSH
15356: EMPTY
15357: LIST
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: LIST
15365: LIST
15366: LIST
15367: LIST
15368: LIST
15369: LIST
15370: LIST
15371: LIST
15372: LIST
15373: LIST
15374: LIST
15375: LIST
15376: LIST
15377: LIST
15378: PUSH
15379: LD_INT 101
15381: PUSH
15382: LD_INT 102
15384: PUSH
15385: LD_INT 103
15387: PUSH
15388: LD_INT 106
15390: PUSH
15391: LD_INT 108
15393: PUSH
15394: LD_INT 112
15396: PUSH
15397: LD_INT 113
15399: PUSH
15400: LD_INT 114
15402: PUSH
15403: LD_INT 115
15405: PUSH
15406: EMPTY
15407: LIST
15408: LIST
15409: LIST
15410: LIST
15411: LIST
15412: LIST
15413: LIST
15414: LIST
15415: LIST
15416: PUSH
15417: EMPTY
15418: LIST
15419: LIST
15420: ST_TO_ADDR
15421: GO 15652
15423: LD_INT 19
15425: DOUBLE
15426: EQUAL
15427: IFTRUE 15431
15429: GO 15651
15431: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
15432: LD_ADDR_VAR 0 1
15436: PUSH
15437: LD_INT 1
15439: PUSH
15440: LD_INT 2
15442: PUSH
15443: LD_INT 3
15445: PUSH
15446: LD_INT 4
15448: PUSH
15449: LD_INT 5
15451: PUSH
15452: LD_INT 6
15454: PUSH
15455: LD_INT 7
15457: PUSH
15458: LD_INT 8
15460: PUSH
15461: LD_INT 9
15463: PUSH
15464: LD_INT 10
15466: PUSH
15467: LD_INT 11
15469: PUSH
15470: LD_INT 12
15472: PUSH
15473: LD_INT 13
15475: PUSH
15476: LD_INT 14
15478: PUSH
15479: LD_INT 15
15481: PUSH
15482: LD_INT 16
15484: PUSH
15485: LD_INT 17
15487: PUSH
15488: LD_INT 18
15490: PUSH
15491: LD_INT 19
15493: PUSH
15494: LD_INT 20
15496: PUSH
15497: LD_INT 21
15499: PUSH
15500: LD_INT 22
15502: PUSH
15503: LD_INT 23
15505: PUSH
15506: LD_INT 24
15508: PUSH
15509: LD_INT 25
15511: PUSH
15512: LD_INT 26
15514: PUSH
15515: LD_INT 27
15517: PUSH
15518: LD_INT 28
15520: PUSH
15521: LD_INT 29
15523: PUSH
15524: LD_INT 30
15526: PUSH
15527: LD_INT 31
15529: PUSH
15530: LD_INT 32
15532: PUSH
15533: LD_INT 33
15535: PUSH
15536: LD_INT 34
15538: PUSH
15539: LD_INT 35
15541: PUSH
15542: LD_INT 36
15544: PUSH
15545: EMPTY
15546: LIST
15547: LIST
15548: LIST
15549: LIST
15550: LIST
15551: LIST
15552: LIST
15553: LIST
15554: LIST
15555: LIST
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: LIST
15561: LIST
15562: LIST
15563: LIST
15564: LIST
15565: LIST
15566: LIST
15567: LIST
15568: LIST
15569: LIST
15570: LIST
15571: LIST
15572: LIST
15573: LIST
15574: LIST
15575: LIST
15576: LIST
15577: LIST
15578: LIST
15579: LIST
15580: LIST
15581: LIST
15582: PUSH
15583: LD_INT 101
15585: PUSH
15586: LD_INT 102
15588: PUSH
15589: LD_INT 103
15591: PUSH
15592: LD_INT 104
15594: PUSH
15595: LD_INT 105
15597: PUSH
15598: LD_INT 106
15600: PUSH
15601: LD_INT 107
15603: PUSH
15604: LD_INT 108
15606: PUSH
15607: LD_INT 109
15609: PUSH
15610: LD_INT 110
15612: PUSH
15613: LD_INT 111
15615: PUSH
15616: LD_INT 112
15618: PUSH
15619: LD_INT 113
15621: PUSH
15622: LD_INT 114
15624: PUSH
15625: LD_INT 115
15627: PUSH
15628: EMPTY
15629: LIST
15630: LIST
15631: LIST
15632: LIST
15633: LIST
15634: LIST
15635: LIST
15636: LIST
15637: LIST
15638: LIST
15639: LIST
15640: LIST
15641: LIST
15642: LIST
15643: LIST
15644: PUSH
15645: EMPTY
15646: LIST
15647: LIST
15648: ST_TO_ADDR
15649: GO 15652
15651: POP
// end else
15652: GO 15871
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
15654: LD_ADDR_VAR 0 1
15658: PUSH
15659: LD_INT 1
15661: PUSH
15662: LD_INT 2
15664: PUSH
15665: LD_INT 3
15667: PUSH
15668: LD_INT 4
15670: PUSH
15671: LD_INT 5
15673: PUSH
15674: LD_INT 6
15676: PUSH
15677: LD_INT 7
15679: PUSH
15680: LD_INT 8
15682: PUSH
15683: LD_INT 9
15685: PUSH
15686: LD_INT 10
15688: PUSH
15689: LD_INT 11
15691: PUSH
15692: LD_INT 12
15694: PUSH
15695: LD_INT 13
15697: PUSH
15698: LD_INT 14
15700: PUSH
15701: LD_INT 15
15703: PUSH
15704: LD_INT 16
15706: PUSH
15707: LD_INT 17
15709: PUSH
15710: LD_INT 18
15712: PUSH
15713: LD_INT 19
15715: PUSH
15716: LD_INT 20
15718: PUSH
15719: LD_INT 21
15721: PUSH
15722: LD_INT 22
15724: PUSH
15725: LD_INT 23
15727: PUSH
15728: LD_INT 24
15730: PUSH
15731: LD_INT 25
15733: PUSH
15734: LD_INT 26
15736: PUSH
15737: LD_INT 27
15739: PUSH
15740: LD_INT 28
15742: PUSH
15743: LD_INT 29
15745: PUSH
15746: LD_INT 30
15748: PUSH
15749: LD_INT 31
15751: PUSH
15752: LD_INT 32
15754: PUSH
15755: LD_INT 33
15757: PUSH
15758: LD_INT 34
15760: PUSH
15761: LD_INT 35
15763: PUSH
15764: LD_INT 36
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: LIST
15774: LIST
15775: LIST
15776: LIST
15777: LIST
15778: LIST
15779: LIST
15780: LIST
15781: LIST
15782: LIST
15783: LIST
15784: LIST
15785: LIST
15786: LIST
15787: LIST
15788: LIST
15789: LIST
15790: LIST
15791: LIST
15792: LIST
15793: LIST
15794: LIST
15795: LIST
15796: LIST
15797: LIST
15798: LIST
15799: LIST
15800: LIST
15801: LIST
15802: LIST
15803: LIST
15804: PUSH
15805: LD_INT 101
15807: PUSH
15808: LD_INT 102
15810: PUSH
15811: LD_INT 103
15813: PUSH
15814: LD_INT 104
15816: PUSH
15817: LD_INT 105
15819: PUSH
15820: LD_INT 106
15822: PUSH
15823: LD_INT 107
15825: PUSH
15826: LD_INT 108
15828: PUSH
15829: LD_INT 109
15831: PUSH
15832: LD_INT 110
15834: PUSH
15835: LD_INT 111
15837: PUSH
15838: LD_INT 112
15840: PUSH
15841: LD_INT 113
15843: PUSH
15844: LD_INT 114
15846: PUSH
15847: LD_INT 115
15849: PUSH
15850: EMPTY
15851: LIST
15852: LIST
15853: LIST
15854: LIST
15855: LIST
15856: LIST
15857: LIST
15858: LIST
15859: LIST
15860: LIST
15861: LIST
15862: LIST
15863: LIST
15864: LIST
15865: LIST
15866: PUSH
15867: EMPTY
15868: LIST
15869: LIST
15870: ST_TO_ADDR
// if result then
15871: LD_VAR 0 1
15875: IFFALSE 16164
// begin normal :=  ;
15877: LD_ADDR_VAR 0 3
15881: PUSH
15882: LD_STRING 
15884: ST_TO_ADDR
// hardcore :=  ;
15885: LD_ADDR_VAR 0 4
15889: PUSH
15890: LD_STRING 
15892: ST_TO_ADDR
// for i = 1 to normalCounter do
15893: LD_ADDR_VAR 0 5
15897: PUSH
15898: DOUBLE
15899: LD_INT 1
15901: DEC
15902: ST_TO_ADDR
15903: LD_EXP 47
15907: PUSH
15908: FOR_TO
15909: IFFALSE 16010
// begin tmp := 0 ;
15911: LD_ADDR_VAR 0 2
15915: PUSH
15916: LD_STRING 0
15918: ST_TO_ADDR
// if result [ 1 ] then
15919: LD_VAR 0 1
15923: PUSH
15924: LD_INT 1
15926: ARRAY
15927: IFFALSE 15992
// if result [ 1 ] [ 1 ] = i then
15929: LD_VAR 0 1
15933: PUSH
15934: LD_INT 1
15936: ARRAY
15937: PUSH
15938: LD_INT 1
15940: ARRAY
15941: PUSH
15942: LD_VAR 0 5
15946: EQUAL
15947: IFFALSE 15992
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
15949: LD_ADDR_VAR 0 1
15953: PUSH
15954: LD_VAR 0 1
15958: PPUSH
15959: LD_INT 1
15961: PPUSH
15962: LD_VAR 0 1
15966: PUSH
15967: LD_INT 1
15969: ARRAY
15970: PPUSH
15971: LD_INT 1
15973: PPUSH
15974: CALL_OW 3
15978: PPUSH
15979: CALL_OW 1
15983: ST_TO_ADDR
// tmp := 1 ;
15984: LD_ADDR_VAR 0 2
15988: PUSH
15989: LD_STRING 1
15991: ST_TO_ADDR
// end ; normal := normal & tmp ;
15992: LD_ADDR_VAR 0 3
15996: PUSH
15997: LD_VAR 0 3
16001: PUSH
16002: LD_VAR 0 2
16006: STR
16007: ST_TO_ADDR
// end ;
16008: GO 15908
16010: POP
16011: POP
// for i = 1 to hardcoreCounter do
16012: LD_ADDR_VAR 0 5
16016: PUSH
16017: DOUBLE
16018: LD_INT 1
16020: DEC
16021: ST_TO_ADDR
16022: LD_EXP 48
16026: PUSH
16027: FOR_TO
16028: IFFALSE 16133
// begin tmp := 0 ;
16030: LD_ADDR_VAR 0 2
16034: PUSH
16035: LD_STRING 0
16037: ST_TO_ADDR
// if result [ 2 ] then
16038: LD_VAR 0 1
16042: PUSH
16043: LD_INT 2
16045: ARRAY
16046: IFFALSE 16115
// if result [ 2 ] [ 1 ] = 100 + i then
16048: LD_VAR 0 1
16052: PUSH
16053: LD_INT 2
16055: ARRAY
16056: PUSH
16057: LD_INT 1
16059: ARRAY
16060: PUSH
16061: LD_INT 100
16063: PUSH
16064: LD_VAR 0 5
16068: PLUS
16069: EQUAL
16070: IFFALSE 16115
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
16072: LD_ADDR_VAR 0 1
16076: PUSH
16077: LD_VAR 0 1
16081: PPUSH
16082: LD_INT 2
16084: PPUSH
16085: LD_VAR 0 1
16089: PUSH
16090: LD_INT 2
16092: ARRAY
16093: PPUSH
16094: LD_INT 1
16096: PPUSH
16097: CALL_OW 3
16101: PPUSH
16102: CALL_OW 1
16106: ST_TO_ADDR
// tmp := 1 ;
16107: LD_ADDR_VAR 0 2
16111: PUSH
16112: LD_STRING 1
16114: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
16115: LD_ADDR_VAR 0 4
16119: PUSH
16120: LD_VAR 0 4
16124: PUSH
16125: LD_VAR 0 2
16129: STR
16130: ST_TO_ADDR
// end ;
16131: GO 16027
16133: POP
16134: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
16135: LD_STRING getStreamItemsFromMission("
16137: PUSH
16138: LD_VAR 0 3
16142: STR
16143: PUSH
16144: LD_STRING ","
16146: STR
16147: PUSH
16148: LD_VAR 0 4
16152: STR
16153: PUSH
16154: LD_STRING ")
16156: STR
16157: PPUSH
16158: CALL_OW 559
// end else
16162: GO 16171
// ToLua ( getStreamItemsFromMission("","") ) ;
16164: LD_STRING getStreamItemsFromMission("","")
16166: PPUSH
16167: CALL_OW 559
// end ;
16171: LD_VAR 0 1
16175: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
16176: LD_VAR 0 2
16180: PUSH
16181: LD_INT 100
16183: EQUAL
16184: IFFALSE 17133
// begin if not StreamModeActive then
16186: LD_EXP 46
16190: NOT
16191: IFFALSE 16201
// StreamModeActive := true ;
16193: LD_ADDR_EXP 46
16197: PUSH
16198: LD_INT 1
16200: ST_TO_ADDR
// if p3 = 0 then
16201: LD_VAR 0 3
16205: PUSH
16206: LD_INT 0
16208: EQUAL
16209: IFFALSE 16215
// InitStreamMode ;
16211: CALL 12254 0 0
// if p3 = 1 then
16215: LD_VAR 0 3
16219: PUSH
16220: LD_INT 1
16222: EQUAL
16223: IFFALSE 16233
// sRocket := true ;
16225: LD_ADDR_EXP 51
16229: PUSH
16230: LD_INT 1
16232: ST_TO_ADDR
// if p3 = 2 then
16233: LD_VAR 0 3
16237: PUSH
16238: LD_INT 2
16240: EQUAL
16241: IFFALSE 16251
// sSpeed := true ;
16243: LD_ADDR_EXP 50
16247: PUSH
16248: LD_INT 1
16250: ST_TO_ADDR
// if p3 = 3 then
16251: LD_VAR 0 3
16255: PUSH
16256: LD_INT 3
16258: EQUAL
16259: IFFALSE 16269
// sEngine := true ;
16261: LD_ADDR_EXP 52
16265: PUSH
16266: LD_INT 1
16268: ST_TO_ADDR
// if p3 = 4 then
16269: LD_VAR 0 3
16273: PUSH
16274: LD_INT 4
16276: EQUAL
16277: IFFALSE 16287
// sSpec := true ;
16279: LD_ADDR_EXP 49
16283: PUSH
16284: LD_INT 1
16286: ST_TO_ADDR
// if p3 = 5 then
16287: LD_VAR 0 3
16291: PUSH
16292: LD_INT 5
16294: EQUAL
16295: IFFALSE 16305
// sLevel := true ;
16297: LD_ADDR_EXP 53
16301: PUSH
16302: LD_INT 1
16304: ST_TO_ADDR
// if p3 = 6 then
16305: LD_VAR 0 3
16309: PUSH
16310: LD_INT 6
16312: EQUAL
16313: IFFALSE 16323
// sArmoury := true ;
16315: LD_ADDR_EXP 54
16319: PUSH
16320: LD_INT 1
16322: ST_TO_ADDR
// if p3 = 7 then
16323: LD_VAR 0 3
16327: PUSH
16328: LD_INT 7
16330: EQUAL
16331: IFFALSE 16341
// sRadar := true ;
16333: LD_ADDR_EXP 55
16337: PUSH
16338: LD_INT 1
16340: ST_TO_ADDR
// if p3 = 8 then
16341: LD_VAR 0 3
16345: PUSH
16346: LD_INT 8
16348: EQUAL
16349: IFFALSE 16359
// sBunker := true ;
16351: LD_ADDR_EXP 56
16355: PUSH
16356: LD_INT 1
16358: ST_TO_ADDR
// if p3 = 9 then
16359: LD_VAR 0 3
16363: PUSH
16364: LD_INT 9
16366: EQUAL
16367: IFFALSE 16377
// sHack := true ;
16369: LD_ADDR_EXP 57
16373: PUSH
16374: LD_INT 1
16376: ST_TO_ADDR
// if p3 = 10 then
16377: LD_VAR 0 3
16381: PUSH
16382: LD_INT 10
16384: EQUAL
16385: IFFALSE 16395
// sFire := true ;
16387: LD_ADDR_EXP 58
16391: PUSH
16392: LD_INT 1
16394: ST_TO_ADDR
// if p3 = 11 then
16395: LD_VAR 0 3
16399: PUSH
16400: LD_INT 11
16402: EQUAL
16403: IFFALSE 16413
// sRefresh := true ;
16405: LD_ADDR_EXP 59
16409: PUSH
16410: LD_INT 1
16412: ST_TO_ADDR
// if p3 = 12 then
16413: LD_VAR 0 3
16417: PUSH
16418: LD_INT 12
16420: EQUAL
16421: IFFALSE 16431
// sExp := true ;
16423: LD_ADDR_EXP 60
16427: PUSH
16428: LD_INT 1
16430: ST_TO_ADDR
// if p3 = 13 then
16431: LD_VAR 0 3
16435: PUSH
16436: LD_INT 13
16438: EQUAL
16439: IFFALSE 16449
// sDepot := true ;
16441: LD_ADDR_EXP 61
16445: PUSH
16446: LD_INT 1
16448: ST_TO_ADDR
// if p3 = 14 then
16449: LD_VAR 0 3
16453: PUSH
16454: LD_INT 14
16456: EQUAL
16457: IFFALSE 16467
// sFlag := true ;
16459: LD_ADDR_EXP 62
16463: PUSH
16464: LD_INT 1
16466: ST_TO_ADDR
// if p3 = 15 then
16467: LD_VAR 0 3
16471: PUSH
16472: LD_INT 15
16474: EQUAL
16475: IFFALSE 16485
// sKamikadze := true ;
16477: LD_ADDR_EXP 70
16481: PUSH
16482: LD_INT 1
16484: ST_TO_ADDR
// if p3 = 16 then
16485: LD_VAR 0 3
16489: PUSH
16490: LD_INT 16
16492: EQUAL
16493: IFFALSE 16503
// sTroll := true ;
16495: LD_ADDR_EXP 71
16499: PUSH
16500: LD_INT 1
16502: ST_TO_ADDR
// if p3 = 17 then
16503: LD_VAR 0 3
16507: PUSH
16508: LD_INT 17
16510: EQUAL
16511: IFFALSE 16521
// sSlow := true ;
16513: LD_ADDR_EXP 72
16517: PUSH
16518: LD_INT 1
16520: ST_TO_ADDR
// if p3 = 18 then
16521: LD_VAR 0 3
16525: PUSH
16526: LD_INT 18
16528: EQUAL
16529: IFFALSE 16539
// sLack := true ;
16531: LD_ADDR_EXP 73
16535: PUSH
16536: LD_INT 1
16538: ST_TO_ADDR
// if p3 = 19 then
16539: LD_VAR 0 3
16543: PUSH
16544: LD_INT 19
16546: EQUAL
16547: IFFALSE 16557
// sTank := true ;
16549: LD_ADDR_EXP 75
16553: PUSH
16554: LD_INT 1
16556: ST_TO_ADDR
// if p3 = 20 then
16557: LD_VAR 0 3
16561: PUSH
16562: LD_INT 20
16564: EQUAL
16565: IFFALSE 16575
// sRemote := true ;
16567: LD_ADDR_EXP 76
16571: PUSH
16572: LD_INT 1
16574: ST_TO_ADDR
// if p3 = 21 then
16575: LD_VAR 0 3
16579: PUSH
16580: LD_INT 21
16582: EQUAL
16583: IFFALSE 16593
// sPowell := true ;
16585: LD_ADDR_EXP 77
16589: PUSH
16590: LD_INT 1
16592: ST_TO_ADDR
// if p3 = 22 then
16593: LD_VAR 0 3
16597: PUSH
16598: LD_INT 22
16600: EQUAL
16601: IFFALSE 16611
// sTeleport := true ;
16603: LD_ADDR_EXP 80
16607: PUSH
16608: LD_INT 1
16610: ST_TO_ADDR
// if p3 = 23 then
16611: LD_VAR 0 3
16615: PUSH
16616: LD_INT 23
16618: EQUAL
16619: IFFALSE 16629
// sOilTower := true ;
16621: LD_ADDR_EXP 82
16625: PUSH
16626: LD_INT 1
16628: ST_TO_ADDR
// if p3 = 24 then
16629: LD_VAR 0 3
16633: PUSH
16634: LD_INT 24
16636: EQUAL
16637: IFFALSE 16647
// sShovel := true ;
16639: LD_ADDR_EXP 83
16643: PUSH
16644: LD_INT 1
16646: ST_TO_ADDR
// if p3 = 25 then
16647: LD_VAR 0 3
16651: PUSH
16652: LD_INT 25
16654: EQUAL
16655: IFFALSE 16665
// sSheik := true ;
16657: LD_ADDR_EXP 84
16661: PUSH
16662: LD_INT 1
16664: ST_TO_ADDR
// if p3 = 26 then
16665: LD_VAR 0 3
16669: PUSH
16670: LD_INT 26
16672: EQUAL
16673: IFFALSE 16683
// sEarthquake := true ;
16675: LD_ADDR_EXP 86
16679: PUSH
16680: LD_INT 1
16682: ST_TO_ADDR
// if p3 = 27 then
16683: LD_VAR 0 3
16687: PUSH
16688: LD_INT 27
16690: EQUAL
16691: IFFALSE 16701
// sAI := true ;
16693: LD_ADDR_EXP 87
16697: PUSH
16698: LD_INT 1
16700: ST_TO_ADDR
// if p3 = 28 then
16701: LD_VAR 0 3
16705: PUSH
16706: LD_INT 28
16708: EQUAL
16709: IFFALSE 16719
// sCargo := true ;
16711: LD_ADDR_EXP 90
16715: PUSH
16716: LD_INT 1
16718: ST_TO_ADDR
// if p3 = 29 then
16719: LD_VAR 0 3
16723: PUSH
16724: LD_INT 29
16726: EQUAL
16727: IFFALSE 16737
// sDLaser := true ;
16729: LD_ADDR_EXP 91
16733: PUSH
16734: LD_INT 1
16736: ST_TO_ADDR
// if p3 = 30 then
16737: LD_VAR 0 3
16741: PUSH
16742: LD_INT 30
16744: EQUAL
16745: IFFALSE 16755
// sExchange := true ;
16747: LD_ADDR_EXP 92
16751: PUSH
16752: LD_INT 1
16754: ST_TO_ADDR
// if p3 = 31 then
16755: LD_VAR 0 3
16759: PUSH
16760: LD_INT 31
16762: EQUAL
16763: IFFALSE 16773
// sFac := true ;
16765: LD_ADDR_EXP 93
16769: PUSH
16770: LD_INT 1
16772: ST_TO_ADDR
// if p3 = 32 then
16773: LD_VAR 0 3
16777: PUSH
16778: LD_INT 32
16780: EQUAL
16781: IFFALSE 16791
// sPower := true ;
16783: LD_ADDR_EXP 94
16787: PUSH
16788: LD_INT 1
16790: ST_TO_ADDR
// if p3 = 33 then
16791: LD_VAR 0 3
16795: PUSH
16796: LD_INT 33
16798: EQUAL
16799: IFFALSE 16809
// sRandom := true ;
16801: LD_ADDR_EXP 95
16805: PUSH
16806: LD_INT 1
16808: ST_TO_ADDR
// if p3 = 34 then
16809: LD_VAR 0 3
16813: PUSH
16814: LD_INT 34
16816: EQUAL
16817: IFFALSE 16827
// sShield := true ;
16819: LD_ADDR_EXP 96
16823: PUSH
16824: LD_INT 1
16826: ST_TO_ADDR
// if p3 = 35 then
16827: LD_VAR 0 3
16831: PUSH
16832: LD_INT 35
16834: EQUAL
16835: IFFALSE 16845
// sTime := true ;
16837: LD_ADDR_EXP 97
16841: PUSH
16842: LD_INT 1
16844: ST_TO_ADDR
// if p3 = 36 then
16845: LD_VAR 0 3
16849: PUSH
16850: LD_INT 36
16852: EQUAL
16853: IFFALSE 16863
// sTools := true ;
16855: LD_ADDR_EXP 98
16859: PUSH
16860: LD_INT 1
16862: ST_TO_ADDR
// if p3 = 101 then
16863: LD_VAR 0 3
16867: PUSH
16868: LD_INT 101
16870: EQUAL
16871: IFFALSE 16881
// sSold := true ;
16873: LD_ADDR_EXP 63
16877: PUSH
16878: LD_INT 1
16880: ST_TO_ADDR
// if p3 = 102 then
16881: LD_VAR 0 3
16885: PUSH
16886: LD_INT 102
16888: EQUAL
16889: IFFALSE 16899
// sDiff := true ;
16891: LD_ADDR_EXP 64
16895: PUSH
16896: LD_INT 1
16898: ST_TO_ADDR
// if p3 = 103 then
16899: LD_VAR 0 3
16903: PUSH
16904: LD_INT 103
16906: EQUAL
16907: IFFALSE 16917
// sFog := true ;
16909: LD_ADDR_EXP 67
16913: PUSH
16914: LD_INT 1
16916: ST_TO_ADDR
// if p3 = 104 then
16917: LD_VAR 0 3
16921: PUSH
16922: LD_INT 104
16924: EQUAL
16925: IFFALSE 16935
// sReset := true ;
16927: LD_ADDR_EXP 68
16931: PUSH
16932: LD_INT 1
16934: ST_TO_ADDR
// if p3 = 105 then
16935: LD_VAR 0 3
16939: PUSH
16940: LD_INT 105
16942: EQUAL
16943: IFFALSE 16953
// sSun := true ;
16945: LD_ADDR_EXP 69
16949: PUSH
16950: LD_INT 1
16952: ST_TO_ADDR
// if p3 = 106 then
16953: LD_VAR 0 3
16957: PUSH
16958: LD_INT 106
16960: EQUAL
16961: IFFALSE 16971
// sTiger := true ;
16963: LD_ADDR_EXP 65
16967: PUSH
16968: LD_INT 1
16970: ST_TO_ADDR
// if p3 = 107 then
16971: LD_VAR 0 3
16975: PUSH
16976: LD_INT 107
16978: EQUAL
16979: IFFALSE 16989
// sBomb := true ;
16981: LD_ADDR_EXP 66
16985: PUSH
16986: LD_INT 1
16988: ST_TO_ADDR
// if p3 = 108 then
16989: LD_VAR 0 3
16993: PUSH
16994: LD_INT 108
16996: EQUAL
16997: IFFALSE 17007
// sWound := true ;
16999: LD_ADDR_EXP 74
17003: PUSH
17004: LD_INT 1
17006: ST_TO_ADDR
// if p3 = 109 then
17007: LD_VAR 0 3
17011: PUSH
17012: LD_INT 109
17014: EQUAL
17015: IFFALSE 17025
// sBetray := true ;
17017: LD_ADDR_EXP 78
17021: PUSH
17022: LD_INT 1
17024: ST_TO_ADDR
// if p3 = 110 then
17025: LD_VAR 0 3
17029: PUSH
17030: LD_INT 110
17032: EQUAL
17033: IFFALSE 17043
// sContamin := true ;
17035: LD_ADDR_EXP 79
17039: PUSH
17040: LD_INT 1
17042: ST_TO_ADDR
// if p3 = 111 then
17043: LD_VAR 0 3
17047: PUSH
17048: LD_INT 111
17050: EQUAL
17051: IFFALSE 17061
// sOil := true ;
17053: LD_ADDR_EXP 81
17057: PUSH
17058: LD_INT 1
17060: ST_TO_ADDR
// if p3 = 112 then
17061: LD_VAR 0 3
17065: PUSH
17066: LD_INT 112
17068: EQUAL
17069: IFFALSE 17079
// sStu := true ;
17071: LD_ADDR_EXP 85
17075: PUSH
17076: LD_INT 1
17078: ST_TO_ADDR
// if p3 = 113 then
17079: LD_VAR 0 3
17083: PUSH
17084: LD_INT 113
17086: EQUAL
17087: IFFALSE 17097
// sBazooka := true ;
17089: LD_ADDR_EXP 88
17093: PUSH
17094: LD_INT 1
17096: ST_TO_ADDR
// if p3 = 114 then
17097: LD_VAR 0 3
17101: PUSH
17102: LD_INT 114
17104: EQUAL
17105: IFFALSE 17115
// sMortar := true ;
17107: LD_ADDR_EXP 89
17111: PUSH
17112: LD_INT 1
17114: ST_TO_ADDR
// if p3 = 115 then
17115: LD_VAR 0 3
17119: PUSH
17120: LD_INT 115
17122: EQUAL
17123: IFFALSE 17133
// sRanger := true ;
17125: LD_ADDR_EXP 99
17129: PUSH
17130: LD_INT 1
17132: ST_TO_ADDR
// end ; end ;
17133: PPOPN 6
17135: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
17136: LD_EXP 46
17140: PUSH
17141: LD_EXP 51
17145: AND
17146: IFFALSE 17270
17148: GO 17150
17150: DISABLE
17151: LD_INT 0
17153: PPUSH
17154: PPUSH
// begin enable ;
17155: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
17156: LD_ADDR_VAR 0 2
17160: PUSH
17161: LD_INT 22
17163: PUSH
17164: LD_OWVAR 2
17168: PUSH
17169: EMPTY
17170: LIST
17171: LIST
17172: PUSH
17173: LD_INT 2
17175: PUSH
17176: LD_INT 34
17178: PUSH
17179: LD_INT 7
17181: PUSH
17182: EMPTY
17183: LIST
17184: LIST
17185: PUSH
17186: LD_INT 34
17188: PUSH
17189: LD_INT 45
17191: PUSH
17192: EMPTY
17193: LIST
17194: LIST
17195: PUSH
17196: LD_INT 34
17198: PUSH
17199: LD_INT 28
17201: PUSH
17202: EMPTY
17203: LIST
17204: LIST
17205: PUSH
17206: LD_INT 34
17208: PUSH
17209: LD_INT 47
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: PUSH
17216: EMPTY
17217: LIST
17218: LIST
17219: LIST
17220: LIST
17221: LIST
17222: PUSH
17223: EMPTY
17224: LIST
17225: LIST
17226: PPUSH
17227: CALL_OW 69
17231: ST_TO_ADDR
// if not tmp then
17232: LD_VAR 0 2
17236: NOT
17237: IFFALSE 17241
// exit ;
17239: GO 17270
// for i in tmp do
17241: LD_ADDR_VAR 0 1
17245: PUSH
17246: LD_VAR 0 2
17250: PUSH
17251: FOR_IN
17252: IFFALSE 17268
// begin SetLives ( i , 0 ) ;
17254: LD_VAR 0 1
17258: PPUSH
17259: LD_INT 0
17261: PPUSH
17262: CALL_OW 234
// end ;
17266: GO 17251
17268: POP
17269: POP
// end ;
17270: PPOPN 2
17272: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
17273: LD_EXP 46
17277: PUSH
17278: LD_EXP 52
17282: AND
17283: IFFALSE 17367
17285: GO 17287
17287: DISABLE
17288: LD_INT 0
17290: PPUSH
17291: PPUSH
// begin enable ;
17292: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
17293: LD_ADDR_VAR 0 2
17297: PUSH
17298: LD_INT 22
17300: PUSH
17301: LD_OWVAR 2
17305: PUSH
17306: EMPTY
17307: LIST
17308: LIST
17309: PUSH
17310: LD_INT 32
17312: PUSH
17313: LD_INT 3
17315: PUSH
17316: EMPTY
17317: LIST
17318: LIST
17319: PUSH
17320: EMPTY
17321: LIST
17322: LIST
17323: PPUSH
17324: CALL_OW 69
17328: ST_TO_ADDR
// if not tmp then
17329: LD_VAR 0 2
17333: NOT
17334: IFFALSE 17338
// exit ;
17336: GO 17367
// for i in tmp do
17338: LD_ADDR_VAR 0 1
17342: PUSH
17343: LD_VAR 0 2
17347: PUSH
17348: FOR_IN
17349: IFFALSE 17365
// begin SetLives ( i , 0 ) ;
17351: LD_VAR 0 1
17355: PPUSH
17356: LD_INT 0
17358: PPUSH
17359: CALL_OW 234
// end ;
17363: GO 17348
17365: POP
17366: POP
// end ;
17367: PPOPN 2
17369: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
17370: LD_EXP 46
17374: PUSH
17375: LD_EXP 49
17379: AND
17380: IFFALSE 17473
17382: GO 17384
17384: DISABLE
17385: LD_INT 0
17387: PPUSH
// begin enable ;
17388: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
17389: LD_ADDR_VAR 0 1
17393: PUSH
17394: LD_INT 22
17396: PUSH
17397: LD_OWVAR 2
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: PUSH
17406: LD_INT 2
17408: PUSH
17409: LD_INT 25
17411: PUSH
17412: LD_INT 5
17414: PUSH
17415: EMPTY
17416: LIST
17417: LIST
17418: PUSH
17419: LD_INT 25
17421: PUSH
17422: LD_INT 9
17424: PUSH
17425: EMPTY
17426: LIST
17427: LIST
17428: PUSH
17429: LD_INT 25
17431: PUSH
17432: LD_INT 8
17434: PUSH
17435: EMPTY
17436: LIST
17437: LIST
17438: PUSH
17439: EMPTY
17440: LIST
17441: LIST
17442: LIST
17443: LIST
17444: PUSH
17445: EMPTY
17446: LIST
17447: LIST
17448: PPUSH
17449: CALL_OW 69
17453: PUSH
17454: FOR_IN
17455: IFFALSE 17471
// begin SetClass ( i , 1 ) ;
17457: LD_VAR 0 1
17461: PPUSH
17462: LD_INT 1
17464: PPUSH
17465: CALL_OW 336
// end ;
17469: GO 17454
17471: POP
17472: POP
// end ;
17473: PPOPN 1
17475: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
17476: LD_EXP 46
17480: PUSH
17481: LD_EXP 50
17485: AND
17486: PUSH
17487: LD_OWVAR 65
17491: PUSH
17492: LD_INT 7
17494: LESS
17495: AND
17496: IFFALSE 17510
17498: GO 17500
17500: DISABLE
// begin enable ;
17501: ENABLE
// game_speed := 7 ;
17502: LD_ADDR_OWVAR 65
17506: PUSH
17507: LD_INT 7
17509: ST_TO_ADDR
// end ;
17510: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
17511: LD_EXP 46
17515: PUSH
17516: LD_EXP 53
17520: AND
17521: IFFALSE 17723
17523: GO 17525
17525: DISABLE
17526: LD_INT 0
17528: PPUSH
17529: PPUSH
17530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
17531: LD_ADDR_VAR 0 3
17535: PUSH
17536: LD_INT 81
17538: PUSH
17539: LD_OWVAR 2
17543: PUSH
17544: EMPTY
17545: LIST
17546: LIST
17547: PUSH
17548: LD_INT 21
17550: PUSH
17551: LD_INT 1
17553: PUSH
17554: EMPTY
17555: LIST
17556: LIST
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: PPUSH
17562: CALL_OW 69
17566: ST_TO_ADDR
// if not tmp then
17567: LD_VAR 0 3
17571: NOT
17572: IFFALSE 17576
// exit ;
17574: GO 17723
// if tmp > 5 then
17576: LD_VAR 0 3
17580: PUSH
17581: LD_INT 5
17583: GREATER
17584: IFFALSE 17596
// k := 5 else
17586: LD_ADDR_VAR 0 2
17590: PUSH
17591: LD_INT 5
17593: ST_TO_ADDR
17594: GO 17606
// k := tmp ;
17596: LD_ADDR_VAR 0 2
17600: PUSH
17601: LD_VAR 0 3
17605: ST_TO_ADDR
// for i := 1 to k do
17606: LD_ADDR_VAR 0 1
17610: PUSH
17611: DOUBLE
17612: LD_INT 1
17614: DEC
17615: ST_TO_ADDR
17616: LD_VAR 0 2
17620: PUSH
17621: FOR_TO
17622: IFFALSE 17721
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
17624: LD_VAR 0 3
17628: PUSH
17629: LD_VAR 0 1
17633: ARRAY
17634: PPUSH
17635: LD_VAR 0 1
17639: PUSH
17640: LD_INT 4
17642: MOD
17643: PUSH
17644: LD_INT 1
17646: PLUS
17647: PPUSH
17648: CALL_OW 259
17652: PUSH
17653: LD_INT 10
17655: LESS
17656: IFFALSE 17719
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
17658: LD_VAR 0 3
17662: PUSH
17663: LD_VAR 0 1
17667: ARRAY
17668: PPUSH
17669: LD_VAR 0 1
17673: PUSH
17674: LD_INT 4
17676: MOD
17677: PUSH
17678: LD_INT 1
17680: PLUS
17681: PPUSH
17682: LD_VAR 0 3
17686: PUSH
17687: LD_VAR 0 1
17691: ARRAY
17692: PPUSH
17693: LD_VAR 0 1
17697: PUSH
17698: LD_INT 4
17700: MOD
17701: PUSH
17702: LD_INT 1
17704: PLUS
17705: PPUSH
17706: CALL_OW 259
17710: PUSH
17711: LD_INT 1
17713: PLUS
17714: PPUSH
17715: CALL_OW 237
17719: GO 17621
17721: POP
17722: POP
// end ;
17723: PPOPN 3
17725: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
17726: LD_EXP 46
17730: PUSH
17731: LD_EXP 54
17735: AND
17736: IFFALSE 17756
17738: GO 17740
17740: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
17741: LD_INT 4
17743: PPUSH
17744: LD_OWVAR 2
17748: PPUSH
17749: LD_INT 0
17751: PPUSH
17752: CALL_OW 324
17756: END
// every 0 0$1 trigger StreamModeActive and sShovel do
17757: LD_EXP 46
17761: PUSH
17762: LD_EXP 83
17766: AND
17767: IFFALSE 17787
17769: GO 17771
17771: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
17772: LD_INT 19
17774: PPUSH
17775: LD_OWVAR 2
17779: PPUSH
17780: LD_INT 0
17782: PPUSH
17783: CALL_OW 324
17787: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
17788: LD_EXP 46
17792: PUSH
17793: LD_EXP 55
17797: AND
17798: IFFALSE 17900
17800: GO 17802
17802: DISABLE
17803: LD_INT 0
17805: PPUSH
17806: PPUSH
// begin enable ;
17807: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
17808: LD_ADDR_VAR 0 2
17812: PUSH
17813: LD_INT 22
17815: PUSH
17816: LD_OWVAR 2
17820: PUSH
17821: EMPTY
17822: LIST
17823: LIST
17824: PUSH
17825: LD_INT 2
17827: PUSH
17828: LD_INT 34
17830: PUSH
17831: LD_INT 11
17833: PUSH
17834: EMPTY
17835: LIST
17836: LIST
17837: PUSH
17838: LD_INT 34
17840: PUSH
17841: LD_INT 30
17843: PUSH
17844: EMPTY
17845: LIST
17846: LIST
17847: PUSH
17848: EMPTY
17849: LIST
17850: LIST
17851: LIST
17852: PUSH
17853: EMPTY
17854: LIST
17855: LIST
17856: PPUSH
17857: CALL_OW 69
17861: ST_TO_ADDR
// if not tmp then
17862: LD_VAR 0 2
17866: NOT
17867: IFFALSE 17871
// exit ;
17869: GO 17900
// for i in tmp do
17871: LD_ADDR_VAR 0 1
17875: PUSH
17876: LD_VAR 0 2
17880: PUSH
17881: FOR_IN
17882: IFFALSE 17898
// begin SetLives ( i , 0 ) ;
17884: LD_VAR 0 1
17888: PPUSH
17889: LD_INT 0
17891: PPUSH
17892: CALL_OW 234
// end ;
17896: GO 17881
17898: POP
17899: POP
// end ;
17900: PPOPN 2
17902: END
// every 0 0$1 trigger StreamModeActive and sBunker do
17903: LD_EXP 46
17907: PUSH
17908: LD_EXP 56
17912: AND
17913: IFFALSE 17933
17915: GO 17917
17917: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
17918: LD_INT 32
17920: PPUSH
17921: LD_OWVAR 2
17925: PPUSH
17926: LD_INT 0
17928: PPUSH
17929: CALL_OW 324
17933: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
17934: LD_EXP 46
17938: PUSH
17939: LD_EXP 57
17943: AND
17944: IFFALSE 18125
17946: GO 17948
17948: DISABLE
17949: LD_INT 0
17951: PPUSH
17952: PPUSH
17953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
17954: LD_ADDR_VAR 0 2
17958: PUSH
17959: LD_INT 22
17961: PUSH
17962: LD_OWVAR 2
17966: PUSH
17967: EMPTY
17968: LIST
17969: LIST
17970: PUSH
17971: LD_INT 33
17973: PUSH
17974: LD_INT 3
17976: PUSH
17977: EMPTY
17978: LIST
17979: LIST
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PPUSH
17985: CALL_OW 69
17989: ST_TO_ADDR
// if not tmp then
17990: LD_VAR 0 2
17994: NOT
17995: IFFALSE 17999
// exit ;
17997: GO 18125
// side := 0 ;
17999: LD_ADDR_VAR 0 3
18003: PUSH
18004: LD_INT 0
18006: ST_TO_ADDR
// for i := 1 to 8 do
18007: LD_ADDR_VAR 0 1
18011: PUSH
18012: DOUBLE
18013: LD_INT 1
18015: DEC
18016: ST_TO_ADDR
18017: LD_INT 8
18019: PUSH
18020: FOR_TO
18021: IFFALSE 18069
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
18023: LD_OWVAR 2
18027: PUSH
18028: LD_VAR 0 1
18032: NONEQUAL
18033: PUSH
18034: LD_OWVAR 2
18038: PPUSH
18039: LD_VAR 0 1
18043: PPUSH
18044: CALL_OW 81
18048: PUSH
18049: LD_INT 2
18051: EQUAL
18052: AND
18053: IFFALSE 18067
// begin side := i ;
18055: LD_ADDR_VAR 0 3
18059: PUSH
18060: LD_VAR 0 1
18064: ST_TO_ADDR
// break ;
18065: GO 18069
// end ;
18067: GO 18020
18069: POP
18070: POP
// if not side then
18071: LD_VAR 0 3
18075: NOT
18076: IFFALSE 18080
// exit ;
18078: GO 18125
// for i := 1 to tmp do
18080: LD_ADDR_VAR 0 1
18084: PUSH
18085: DOUBLE
18086: LD_INT 1
18088: DEC
18089: ST_TO_ADDR
18090: LD_VAR 0 2
18094: PUSH
18095: FOR_TO
18096: IFFALSE 18123
// if Prob ( 60 ) then
18098: LD_INT 60
18100: PPUSH
18101: CALL_OW 13
18105: IFFALSE 18121
// SetSide ( i , side ) ;
18107: LD_VAR 0 1
18111: PPUSH
18112: LD_VAR 0 3
18116: PPUSH
18117: CALL_OW 235
18121: GO 18095
18123: POP
18124: POP
// end ;
18125: PPOPN 3
18127: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
18128: LD_EXP 46
18132: PUSH
18133: LD_EXP 59
18137: AND
18138: IFFALSE 18257
18140: GO 18142
18142: DISABLE
18143: LD_INT 0
18145: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
18146: LD_ADDR_VAR 0 1
18150: PUSH
18151: LD_INT 22
18153: PUSH
18154: LD_OWVAR 2
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: PUSH
18163: LD_INT 21
18165: PUSH
18166: LD_INT 1
18168: PUSH
18169: EMPTY
18170: LIST
18171: LIST
18172: PUSH
18173: LD_INT 3
18175: PUSH
18176: LD_INT 23
18178: PUSH
18179: LD_INT 0
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: PUSH
18186: EMPTY
18187: LIST
18188: LIST
18189: PUSH
18190: EMPTY
18191: LIST
18192: LIST
18193: LIST
18194: PPUSH
18195: CALL_OW 69
18199: PUSH
18200: FOR_IN
18201: IFFALSE 18255
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
18203: LD_VAR 0 1
18207: PPUSH
18208: CALL_OW 257
18212: PUSH
18213: LD_INT 1
18215: PUSH
18216: LD_INT 2
18218: PUSH
18219: LD_INT 3
18221: PUSH
18222: LD_INT 4
18224: PUSH
18225: EMPTY
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: IN
18231: IFFALSE 18253
// SetClass ( un , rand ( 1 , 4 ) ) ;
18233: LD_VAR 0 1
18237: PPUSH
18238: LD_INT 1
18240: PPUSH
18241: LD_INT 4
18243: PPUSH
18244: CALL_OW 12
18248: PPUSH
18249: CALL_OW 336
18253: GO 18200
18255: POP
18256: POP
// end ;
18257: PPOPN 1
18259: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
18260: LD_EXP 46
18264: PUSH
18265: LD_EXP 58
18269: AND
18270: IFFALSE 18349
18272: GO 18274
18274: DISABLE
18275: LD_INT 0
18277: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18278: LD_ADDR_VAR 0 1
18282: PUSH
18283: LD_INT 22
18285: PUSH
18286: LD_OWVAR 2
18290: PUSH
18291: EMPTY
18292: LIST
18293: LIST
18294: PUSH
18295: LD_INT 21
18297: PUSH
18298: LD_INT 3
18300: PUSH
18301: EMPTY
18302: LIST
18303: LIST
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: PPUSH
18309: CALL_OW 69
18313: ST_TO_ADDR
// if not tmp then
18314: LD_VAR 0 1
18318: NOT
18319: IFFALSE 18323
// exit ;
18321: GO 18349
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
18323: LD_VAR 0 1
18327: PUSH
18328: LD_INT 1
18330: PPUSH
18331: LD_VAR 0 1
18335: PPUSH
18336: CALL_OW 12
18340: ARRAY
18341: PPUSH
18342: LD_INT 100
18344: PPUSH
18345: CALL_OW 234
// end ;
18349: PPOPN 1
18351: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
18352: LD_EXP 46
18356: PUSH
18357: LD_EXP 60
18361: AND
18362: IFFALSE 18460
18364: GO 18366
18366: DISABLE
18367: LD_INT 0
18369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18370: LD_ADDR_VAR 0 1
18374: PUSH
18375: LD_INT 22
18377: PUSH
18378: LD_OWVAR 2
18382: PUSH
18383: EMPTY
18384: LIST
18385: LIST
18386: PUSH
18387: LD_INT 21
18389: PUSH
18390: LD_INT 1
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PUSH
18397: EMPTY
18398: LIST
18399: LIST
18400: PPUSH
18401: CALL_OW 69
18405: ST_TO_ADDR
// if not tmp then
18406: LD_VAR 0 1
18410: NOT
18411: IFFALSE 18415
// exit ;
18413: GO 18460
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
18415: LD_VAR 0 1
18419: PUSH
18420: LD_INT 1
18422: PPUSH
18423: LD_VAR 0 1
18427: PPUSH
18428: CALL_OW 12
18432: ARRAY
18433: PPUSH
18434: LD_INT 1
18436: PPUSH
18437: LD_INT 4
18439: PPUSH
18440: CALL_OW 12
18444: PPUSH
18445: LD_INT 3000
18447: PPUSH
18448: LD_INT 9000
18450: PPUSH
18451: CALL_OW 12
18455: PPUSH
18456: CALL_OW 492
// end ;
18460: PPOPN 1
18462: END
// every 0 0$1 trigger StreamModeActive and sDepot do
18463: LD_EXP 46
18467: PUSH
18468: LD_EXP 61
18472: AND
18473: IFFALSE 18493
18475: GO 18477
18477: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
18478: LD_INT 1
18480: PPUSH
18481: LD_OWVAR 2
18485: PPUSH
18486: LD_INT 0
18488: PPUSH
18489: CALL_OW 324
18493: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
18494: LD_EXP 46
18498: PUSH
18499: LD_EXP 62
18503: AND
18504: IFFALSE 18587
18506: GO 18508
18508: DISABLE
18509: LD_INT 0
18511: PPUSH
18512: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18513: LD_ADDR_VAR 0 2
18517: PUSH
18518: LD_INT 22
18520: PUSH
18521: LD_OWVAR 2
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: PUSH
18530: LD_INT 21
18532: PUSH
18533: LD_INT 3
18535: PUSH
18536: EMPTY
18537: LIST
18538: LIST
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: PPUSH
18544: CALL_OW 69
18548: ST_TO_ADDR
// if not tmp then
18549: LD_VAR 0 2
18553: NOT
18554: IFFALSE 18558
// exit ;
18556: GO 18587
// for i in tmp do
18558: LD_ADDR_VAR 0 1
18562: PUSH
18563: LD_VAR 0 2
18567: PUSH
18568: FOR_IN
18569: IFFALSE 18585
// SetBLevel ( i , 10 ) ;
18571: LD_VAR 0 1
18575: PPUSH
18576: LD_INT 10
18578: PPUSH
18579: CALL_OW 241
18583: GO 18568
18585: POP
18586: POP
// end ;
18587: PPOPN 2
18589: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
18590: LD_EXP 46
18594: PUSH
18595: LD_EXP 63
18599: AND
18600: IFFALSE 18711
18602: GO 18604
18604: DISABLE
18605: LD_INT 0
18607: PPUSH
18608: PPUSH
18609: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18610: LD_ADDR_VAR 0 3
18614: PUSH
18615: LD_INT 22
18617: PUSH
18618: LD_OWVAR 2
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: PUSH
18627: LD_INT 25
18629: PUSH
18630: LD_INT 1
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: PUSH
18637: EMPTY
18638: LIST
18639: LIST
18640: PPUSH
18641: CALL_OW 69
18645: ST_TO_ADDR
// if not tmp then
18646: LD_VAR 0 3
18650: NOT
18651: IFFALSE 18655
// exit ;
18653: GO 18711
// un := tmp [ rand ( 1 , tmp ) ] ;
18655: LD_ADDR_VAR 0 2
18659: PUSH
18660: LD_VAR 0 3
18664: PUSH
18665: LD_INT 1
18667: PPUSH
18668: LD_VAR 0 3
18672: PPUSH
18673: CALL_OW 12
18677: ARRAY
18678: ST_TO_ADDR
// if Crawls ( un ) then
18679: LD_VAR 0 2
18683: PPUSH
18684: CALL_OW 318
18688: IFFALSE 18699
// ComWalk ( un ) ;
18690: LD_VAR 0 2
18694: PPUSH
18695: CALL_OW 138
// SetClass ( un , class_sniper ) ;
18699: LD_VAR 0 2
18703: PPUSH
18704: LD_INT 5
18706: PPUSH
18707: CALL_OW 336
// end ;
18711: PPOPN 3
18713: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
18714: LD_EXP 46
18718: PUSH
18719: LD_EXP 64
18723: AND
18724: PUSH
18725: LD_OWVAR 67
18729: PUSH
18730: LD_INT 3
18732: LESS
18733: AND
18734: IFFALSE 18753
18736: GO 18738
18738: DISABLE
// Difficulty := Difficulty + 1 ;
18739: LD_ADDR_OWVAR 67
18743: PUSH
18744: LD_OWVAR 67
18748: PUSH
18749: LD_INT 1
18751: PLUS
18752: ST_TO_ADDR
18753: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
18754: LD_EXP 46
18758: PUSH
18759: LD_EXP 65
18763: AND
18764: IFFALSE 18867
18766: GO 18768
18768: DISABLE
18769: LD_INT 0
18771: PPUSH
// begin for i := 1 to 5 do
18772: LD_ADDR_VAR 0 1
18776: PUSH
18777: DOUBLE
18778: LD_INT 1
18780: DEC
18781: ST_TO_ADDR
18782: LD_INT 5
18784: PUSH
18785: FOR_TO
18786: IFFALSE 18865
// begin uc_nation := nation_nature ;
18788: LD_ADDR_OWVAR 21
18792: PUSH
18793: LD_INT 0
18795: ST_TO_ADDR
// uc_side := 0 ;
18796: LD_ADDR_OWVAR 20
18800: PUSH
18801: LD_INT 0
18803: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18804: LD_ADDR_OWVAR 29
18808: PUSH
18809: LD_INT 12
18811: PUSH
18812: LD_INT 12
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: ST_TO_ADDR
// hc_agressivity := 20 ;
18819: LD_ADDR_OWVAR 35
18823: PUSH
18824: LD_INT 20
18826: ST_TO_ADDR
// hc_class := class_tiger ;
18827: LD_ADDR_OWVAR 28
18831: PUSH
18832: LD_INT 14
18834: ST_TO_ADDR
// hc_gallery :=  ;
18835: LD_ADDR_OWVAR 33
18839: PUSH
18840: LD_STRING 
18842: ST_TO_ADDR
// hc_name :=  ;
18843: LD_ADDR_OWVAR 26
18847: PUSH
18848: LD_STRING 
18850: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
18851: CALL_OW 44
18855: PPUSH
18856: LD_INT 0
18858: PPUSH
18859: CALL_OW 51
// end ;
18863: GO 18785
18865: POP
18866: POP
// end ;
18867: PPOPN 1
18869: END
// every 0 0$1 trigger StreamModeActive and sBomb do
18870: LD_EXP 46
18874: PUSH
18875: LD_EXP 66
18879: AND
18880: IFFALSE 18889
18882: GO 18884
18884: DISABLE
// StreamSibBomb ;
18885: CALL 18890 0 0
18889: END
// export function StreamSibBomb ; var i , x , y ; begin
18890: LD_INT 0
18892: PPUSH
18893: PPUSH
18894: PPUSH
18895: PPUSH
// result := false ;
18896: LD_ADDR_VAR 0 1
18900: PUSH
18901: LD_INT 0
18903: ST_TO_ADDR
// for i := 1 to 16 do
18904: LD_ADDR_VAR 0 2
18908: PUSH
18909: DOUBLE
18910: LD_INT 1
18912: DEC
18913: ST_TO_ADDR
18914: LD_INT 16
18916: PUSH
18917: FOR_TO
18918: IFFALSE 19117
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18920: LD_ADDR_VAR 0 3
18924: PUSH
18925: LD_INT 10
18927: PUSH
18928: LD_INT 20
18930: PUSH
18931: LD_INT 30
18933: PUSH
18934: LD_INT 40
18936: PUSH
18937: LD_INT 50
18939: PUSH
18940: LD_INT 60
18942: PUSH
18943: LD_INT 70
18945: PUSH
18946: LD_INT 80
18948: PUSH
18949: LD_INT 90
18951: PUSH
18952: LD_INT 100
18954: PUSH
18955: LD_INT 110
18957: PUSH
18958: LD_INT 120
18960: PUSH
18961: LD_INT 130
18963: PUSH
18964: LD_INT 140
18966: PUSH
18967: LD_INT 150
18969: PUSH
18970: EMPTY
18971: LIST
18972: LIST
18973: LIST
18974: LIST
18975: LIST
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: LIST
18981: LIST
18982: LIST
18983: LIST
18984: LIST
18985: LIST
18986: PUSH
18987: LD_INT 1
18989: PPUSH
18990: LD_INT 15
18992: PPUSH
18993: CALL_OW 12
18997: ARRAY
18998: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18999: LD_ADDR_VAR 0 4
19003: PUSH
19004: LD_INT 10
19006: PUSH
19007: LD_INT 20
19009: PUSH
19010: LD_INT 30
19012: PUSH
19013: LD_INT 40
19015: PUSH
19016: LD_INT 50
19018: PUSH
19019: LD_INT 60
19021: PUSH
19022: LD_INT 70
19024: PUSH
19025: LD_INT 80
19027: PUSH
19028: LD_INT 90
19030: PUSH
19031: LD_INT 100
19033: PUSH
19034: LD_INT 110
19036: PUSH
19037: LD_INT 120
19039: PUSH
19040: LD_INT 130
19042: PUSH
19043: LD_INT 140
19045: PUSH
19046: LD_INT 150
19048: PUSH
19049: EMPTY
19050: LIST
19051: LIST
19052: LIST
19053: LIST
19054: LIST
19055: LIST
19056: LIST
19057: LIST
19058: LIST
19059: LIST
19060: LIST
19061: LIST
19062: LIST
19063: LIST
19064: LIST
19065: PUSH
19066: LD_INT 1
19068: PPUSH
19069: LD_INT 15
19071: PPUSH
19072: CALL_OW 12
19076: ARRAY
19077: ST_TO_ADDR
// if ValidHex ( x , y ) then
19078: LD_VAR 0 3
19082: PPUSH
19083: LD_VAR 0 4
19087: PPUSH
19088: CALL_OW 488
19092: IFFALSE 19115
// begin result := [ x , y ] ;
19094: LD_ADDR_VAR 0 1
19098: PUSH
19099: LD_VAR 0 3
19103: PUSH
19104: LD_VAR 0 4
19108: PUSH
19109: EMPTY
19110: LIST
19111: LIST
19112: ST_TO_ADDR
// break ;
19113: GO 19117
// end ; end ;
19115: GO 18917
19117: POP
19118: POP
// if result then
19119: LD_VAR 0 1
19123: IFFALSE 19183
// begin ToLua ( playSibBomb() ) ;
19125: LD_STRING playSibBomb()
19127: PPUSH
19128: CALL_OW 559
// wait ( 0 0$14 ) ;
19132: LD_INT 490
19134: PPUSH
19135: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
19139: LD_VAR 0 1
19143: PUSH
19144: LD_INT 1
19146: ARRAY
19147: PPUSH
19148: LD_VAR 0 1
19152: PUSH
19153: LD_INT 2
19155: ARRAY
19156: PPUSH
19157: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
19161: LD_VAR 0 1
19165: PUSH
19166: LD_INT 1
19168: ARRAY
19169: PPUSH
19170: LD_VAR 0 1
19174: PUSH
19175: LD_INT 2
19177: ARRAY
19178: PPUSH
19179: CALL_OW 429
// end ; end ;
19183: LD_VAR 0 1
19187: RET
// every 0 0$1 trigger StreamModeActive and sReset do
19188: LD_EXP 46
19192: PUSH
19193: LD_EXP 68
19197: AND
19198: IFFALSE 19210
19200: GO 19202
19202: DISABLE
// YouLost (  ) ;
19203: LD_STRING 
19205: PPUSH
19206: CALL_OW 104
19210: END
// every 0 0$1 trigger StreamModeActive and sFog do
19211: LD_EXP 46
19215: PUSH
19216: LD_EXP 67
19220: AND
19221: IFFALSE 19235
19223: GO 19225
19225: DISABLE
// FogOff ( your_side ) ;
19226: LD_OWVAR 2
19230: PPUSH
19231: CALL_OW 344
19235: END
// every 0 0$1 trigger StreamModeActive and sSun do
19236: LD_EXP 46
19240: PUSH
19241: LD_EXP 69
19245: AND
19246: IFFALSE 19274
19248: GO 19250
19250: DISABLE
// begin solar_recharge_percent := 0 ;
19251: LD_ADDR_OWVAR 79
19255: PUSH
19256: LD_INT 0
19258: ST_TO_ADDR
// wait ( 5 5$00 ) ;
19259: LD_INT 10500
19261: PPUSH
19262: CALL_OW 67
// solar_recharge_percent := 100 ;
19266: LD_ADDR_OWVAR 79
19270: PUSH
19271: LD_INT 100
19273: ST_TO_ADDR
// end ;
19274: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
19275: LD_EXP 46
19279: PUSH
19280: LD_EXP 70
19284: AND
19285: IFFALSE 19524
19287: GO 19289
19289: DISABLE
19290: LD_INT 0
19292: PPUSH
19293: PPUSH
19294: PPUSH
// begin tmp := [ ] ;
19295: LD_ADDR_VAR 0 3
19299: PUSH
19300: EMPTY
19301: ST_TO_ADDR
// for i := 1 to 6 do
19302: LD_ADDR_VAR 0 1
19306: PUSH
19307: DOUBLE
19308: LD_INT 1
19310: DEC
19311: ST_TO_ADDR
19312: LD_INT 6
19314: PUSH
19315: FOR_TO
19316: IFFALSE 19421
// begin uc_nation := nation_nature ;
19318: LD_ADDR_OWVAR 21
19322: PUSH
19323: LD_INT 0
19325: ST_TO_ADDR
// uc_side := 0 ;
19326: LD_ADDR_OWVAR 20
19330: PUSH
19331: LD_INT 0
19333: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
19334: LD_ADDR_OWVAR 29
19338: PUSH
19339: LD_INT 12
19341: PUSH
19342: LD_INT 12
19344: PUSH
19345: EMPTY
19346: LIST
19347: LIST
19348: ST_TO_ADDR
// hc_agressivity := 20 ;
19349: LD_ADDR_OWVAR 35
19353: PUSH
19354: LD_INT 20
19356: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
19357: LD_ADDR_OWVAR 28
19361: PUSH
19362: LD_INT 17
19364: ST_TO_ADDR
// hc_gallery :=  ;
19365: LD_ADDR_OWVAR 33
19369: PUSH
19370: LD_STRING 
19372: ST_TO_ADDR
// hc_name :=  ;
19373: LD_ADDR_OWVAR 26
19377: PUSH
19378: LD_STRING 
19380: ST_TO_ADDR
// un := CreateHuman ;
19381: LD_ADDR_VAR 0 2
19385: PUSH
19386: CALL_OW 44
19390: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
19391: LD_VAR 0 2
19395: PPUSH
19396: LD_INT 1
19398: PPUSH
19399: CALL_OW 51
// tmp := tmp ^ un ;
19403: LD_ADDR_VAR 0 3
19407: PUSH
19408: LD_VAR 0 3
19412: PUSH
19413: LD_VAR 0 2
19417: ADD
19418: ST_TO_ADDR
// end ;
19419: GO 19315
19421: POP
19422: POP
// repeat wait ( 0 0$1 ) ;
19423: LD_INT 35
19425: PPUSH
19426: CALL_OW 67
// for un in tmp do
19430: LD_ADDR_VAR 0 2
19434: PUSH
19435: LD_VAR 0 3
19439: PUSH
19440: FOR_IN
19441: IFFALSE 19515
// begin if IsDead ( un ) then
19443: LD_VAR 0 2
19447: PPUSH
19448: CALL_OW 301
19452: IFFALSE 19472
// begin tmp := tmp diff un ;
19454: LD_ADDR_VAR 0 3
19458: PUSH
19459: LD_VAR 0 3
19463: PUSH
19464: LD_VAR 0 2
19468: DIFF
19469: ST_TO_ADDR
// continue ;
19470: GO 19440
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
19472: LD_VAR 0 2
19476: PPUSH
19477: LD_INT 3
19479: PUSH
19480: LD_INT 22
19482: PUSH
19483: LD_INT 0
19485: PUSH
19486: EMPTY
19487: LIST
19488: LIST
19489: PUSH
19490: EMPTY
19491: LIST
19492: LIST
19493: PPUSH
19494: CALL_OW 69
19498: PPUSH
19499: LD_VAR 0 2
19503: PPUSH
19504: CALL_OW 74
19508: PPUSH
19509: CALL_OW 115
// end ;
19513: GO 19440
19515: POP
19516: POP
// until not tmp ;
19517: LD_VAR 0 3
19521: NOT
19522: IFFALSE 19423
// end ;
19524: PPOPN 3
19526: END
// every 0 0$1 trigger StreamModeActive and sTroll do
19527: LD_EXP 46
19531: PUSH
19532: LD_EXP 71
19536: AND
19537: IFFALSE 19591
19539: GO 19541
19541: DISABLE
// begin ToLua ( displayTroll(); ) ;
19542: LD_STRING displayTroll();
19544: PPUSH
19545: CALL_OW 559
// wait ( 3 3$00 ) ;
19549: LD_INT 6300
19551: PPUSH
19552: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19556: LD_STRING hideTroll();
19558: PPUSH
19559: CALL_OW 559
// wait ( 1 1$00 ) ;
19563: LD_INT 2100
19565: PPUSH
19566: CALL_OW 67
// ToLua ( displayTroll(); ) ;
19570: LD_STRING displayTroll();
19572: PPUSH
19573: CALL_OW 559
// wait ( 1 1$00 ) ;
19577: LD_INT 2100
19579: PPUSH
19580: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19584: LD_STRING hideTroll();
19586: PPUSH
19587: CALL_OW 559
// end ;
19591: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
19592: LD_EXP 46
19596: PUSH
19597: LD_EXP 72
19601: AND
19602: IFFALSE 19665
19604: GO 19606
19606: DISABLE
19607: LD_INT 0
19609: PPUSH
// begin p := 0 ;
19610: LD_ADDR_VAR 0 1
19614: PUSH
19615: LD_INT 0
19617: ST_TO_ADDR
// repeat game_speed := 1 ;
19618: LD_ADDR_OWVAR 65
19622: PUSH
19623: LD_INT 1
19625: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19626: LD_INT 35
19628: PPUSH
19629: CALL_OW 67
// p := p + 1 ;
19633: LD_ADDR_VAR 0 1
19637: PUSH
19638: LD_VAR 0 1
19642: PUSH
19643: LD_INT 1
19645: PLUS
19646: ST_TO_ADDR
// until p >= 60 ;
19647: LD_VAR 0 1
19651: PUSH
19652: LD_INT 60
19654: GREATEREQUAL
19655: IFFALSE 19618
// game_speed := 4 ;
19657: LD_ADDR_OWVAR 65
19661: PUSH
19662: LD_INT 4
19664: ST_TO_ADDR
// end ;
19665: PPOPN 1
19667: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
19668: LD_EXP 46
19672: PUSH
19673: LD_EXP 73
19677: AND
19678: IFFALSE 19824
19680: GO 19682
19682: DISABLE
19683: LD_INT 0
19685: PPUSH
19686: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19687: LD_ADDR_VAR 0 1
19691: PUSH
19692: LD_INT 22
19694: PUSH
19695: LD_OWVAR 2
19699: PUSH
19700: EMPTY
19701: LIST
19702: LIST
19703: PUSH
19704: LD_INT 2
19706: PUSH
19707: LD_INT 30
19709: PUSH
19710: LD_INT 0
19712: PUSH
19713: EMPTY
19714: LIST
19715: LIST
19716: PUSH
19717: LD_INT 30
19719: PUSH
19720: LD_INT 1
19722: PUSH
19723: EMPTY
19724: LIST
19725: LIST
19726: PUSH
19727: EMPTY
19728: LIST
19729: LIST
19730: LIST
19731: PUSH
19732: EMPTY
19733: LIST
19734: LIST
19735: PPUSH
19736: CALL_OW 69
19740: ST_TO_ADDR
// if not depot then
19741: LD_VAR 0 1
19745: NOT
19746: IFFALSE 19750
// exit ;
19748: GO 19824
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
19750: LD_ADDR_VAR 0 2
19754: PUSH
19755: LD_VAR 0 1
19759: PUSH
19760: LD_INT 1
19762: PPUSH
19763: LD_VAR 0 1
19767: PPUSH
19768: CALL_OW 12
19772: ARRAY
19773: PPUSH
19774: CALL_OW 274
19778: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
19779: LD_VAR 0 2
19783: PPUSH
19784: LD_INT 1
19786: PPUSH
19787: LD_INT 0
19789: PPUSH
19790: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
19794: LD_VAR 0 2
19798: PPUSH
19799: LD_INT 2
19801: PPUSH
19802: LD_INT 0
19804: PPUSH
19805: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
19809: LD_VAR 0 2
19813: PPUSH
19814: LD_INT 3
19816: PPUSH
19817: LD_INT 0
19819: PPUSH
19820: CALL_OW 277
// end ;
19824: PPOPN 2
19826: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
19827: LD_EXP 46
19831: PUSH
19832: LD_EXP 74
19836: AND
19837: IFFALSE 19934
19839: GO 19841
19841: DISABLE
19842: LD_INT 0
19844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19845: LD_ADDR_VAR 0 1
19849: PUSH
19850: LD_INT 22
19852: PUSH
19853: LD_OWVAR 2
19857: PUSH
19858: EMPTY
19859: LIST
19860: LIST
19861: PUSH
19862: LD_INT 21
19864: PUSH
19865: LD_INT 1
19867: PUSH
19868: EMPTY
19869: LIST
19870: LIST
19871: PUSH
19872: LD_INT 3
19874: PUSH
19875: LD_INT 23
19877: PUSH
19878: LD_INT 0
19880: PUSH
19881: EMPTY
19882: LIST
19883: LIST
19884: PUSH
19885: EMPTY
19886: LIST
19887: LIST
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: LIST
19893: PPUSH
19894: CALL_OW 69
19898: ST_TO_ADDR
// if not tmp then
19899: LD_VAR 0 1
19903: NOT
19904: IFFALSE 19908
// exit ;
19906: GO 19934
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
19908: LD_VAR 0 1
19912: PUSH
19913: LD_INT 1
19915: PPUSH
19916: LD_VAR 0 1
19920: PPUSH
19921: CALL_OW 12
19925: ARRAY
19926: PPUSH
19927: LD_INT 200
19929: PPUSH
19930: CALL_OW 234
// end ;
19934: PPOPN 1
19936: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
19937: LD_EXP 46
19941: PUSH
19942: LD_EXP 75
19946: AND
19947: IFFALSE 20026
19949: GO 19951
19951: DISABLE
19952: LD_INT 0
19954: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
19955: LD_ADDR_VAR 0 1
19959: PUSH
19960: LD_INT 22
19962: PUSH
19963: LD_OWVAR 2
19967: PUSH
19968: EMPTY
19969: LIST
19970: LIST
19971: PUSH
19972: LD_INT 21
19974: PUSH
19975: LD_INT 2
19977: PUSH
19978: EMPTY
19979: LIST
19980: LIST
19981: PUSH
19982: EMPTY
19983: LIST
19984: LIST
19985: PPUSH
19986: CALL_OW 69
19990: ST_TO_ADDR
// if not tmp then
19991: LD_VAR 0 1
19995: NOT
19996: IFFALSE 20000
// exit ;
19998: GO 20026
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
20000: LD_VAR 0 1
20004: PUSH
20005: LD_INT 1
20007: PPUSH
20008: LD_VAR 0 1
20012: PPUSH
20013: CALL_OW 12
20017: ARRAY
20018: PPUSH
20019: LD_INT 60
20021: PPUSH
20022: CALL_OW 234
// end ;
20026: PPOPN 1
20028: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
20029: LD_EXP 46
20033: PUSH
20034: LD_EXP 76
20038: AND
20039: IFFALSE 20138
20041: GO 20043
20043: DISABLE
20044: LD_INT 0
20046: PPUSH
20047: PPUSH
// begin enable ;
20048: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
20049: LD_ADDR_VAR 0 1
20053: PUSH
20054: LD_INT 22
20056: PUSH
20057: LD_OWVAR 2
20061: PUSH
20062: EMPTY
20063: LIST
20064: LIST
20065: PUSH
20066: LD_INT 61
20068: PUSH
20069: EMPTY
20070: LIST
20071: PUSH
20072: LD_INT 33
20074: PUSH
20075: LD_INT 2
20077: PUSH
20078: EMPTY
20079: LIST
20080: LIST
20081: PUSH
20082: EMPTY
20083: LIST
20084: LIST
20085: LIST
20086: PPUSH
20087: CALL_OW 69
20091: ST_TO_ADDR
// if not tmp then
20092: LD_VAR 0 1
20096: NOT
20097: IFFALSE 20101
// exit ;
20099: GO 20138
// for i in tmp do
20101: LD_ADDR_VAR 0 2
20105: PUSH
20106: LD_VAR 0 1
20110: PUSH
20111: FOR_IN
20112: IFFALSE 20136
// if IsControledBy ( i ) then
20114: LD_VAR 0 2
20118: PPUSH
20119: CALL_OW 312
20123: IFFALSE 20134
// ComUnlink ( i ) ;
20125: LD_VAR 0 2
20129: PPUSH
20130: CALL_OW 136
20134: GO 20111
20136: POP
20137: POP
// end ;
20138: PPOPN 2
20140: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
20141: LD_EXP 46
20145: PUSH
20146: LD_EXP 77
20150: AND
20151: IFFALSE 20291
20153: GO 20155
20155: DISABLE
20156: LD_INT 0
20158: PPUSH
20159: PPUSH
// begin ToLua ( displayPowell(); ) ;
20160: LD_STRING displayPowell();
20162: PPUSH
20163: CALL_OW 559
// uc_side := 0 ;
20167: LD_ADDR_OWVAR 20
20171: PUSH
20172: LD_INT 0
20174: ST_TO_ADDR
// uc_nation := 2 ;
20175: LD_ADDR_OWVAR 21
20179: PUSH
20180: LD_INT 2
20182: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
20183: LD_ADDR_OWVAR 37
20187: PUSH
20188: LD_INT 14
20190: ST_TO_ADDR
// vc_engine := engine_siberite ;
20191: LD_ADDR_OWVAR 39
20195: PUSH
20196: LD_INT 3
20198: ST_TO_ADDR
// vc_control := control_apeman ;
20199: LD_ADDR_OWVAR 38
20203: PUSH
20204: LD_INT 5
20206: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
20207: LD_ADDR_OWVAR 40
20211: PUSH
20212: LD_INT 29
20214: ST_TO_ADDR
// un := CreateVehicle ;
20215: LD_ADDR_VAR 0 2
20219: PUSH
20220: CALL_OW 45
20224: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20225: LD_VAR 0 2
20229: PPUSH
20230: LD_INT 1
20232: PPUSH
20233: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20237: LD_INT 35
20239: PPUSH
20240: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20244: LD_VAR 0 2
20248: PPUSH
20249: LD_INT 22
20251: PUSH
20252: LD_OWVAR 2
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: PPUSH
20261: CALL_OW 69
20265: PPUSH
20266: LD_VAR 0 2
20270: PPUSH
20271: CALL_OW 74
20275: PPUSH
20276: CALL_OW 115
// until IsDead ( un ) ;
20280: LD_VAR 0 2
20284: PPUSH
20285: CALL_OW 301
20289: IFFALSE 20237
// end ;
20291: PPOPN 2
20293: END
// every 0 0$1 trigger StreamModeActive and sStu do
20294: LD_EXP 46
20298: PUSH
20299: LD_EXP 85
20303: AND
20304: IFFALSE 20320
20306: GO 20308
20308: DISABLE
// begin ToLua ( displayStucuk(); ) ;
20309: LD_STRING displayStucuk();
20311: PPUSH
20312: CALL_OW 559
// ResetFog ;
20316: CALL_OW 335
// end ;
20320: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
20321: LD_EXP 46
20325: PUSH
20326: LD_EXP 78
20330: AND
20331: IFFALSE 20472
20333: GO 20335
20335: DISABLE
20336: LD_INT 0
20338: PPUSH
20339: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20340: LD_ADDR_VAR 0 2
20344: PUSH
20345: LD_INT 22
20347: PUSH
20348: LD_OWVAR 2
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: PUSH
20357: LD_INT 21
20359: PUSH
20360: LD_INT 1
20362: PUSH
20363: EMPTY
20364: LIST
20365: LIST
20366: PUSH
20367: EMPTY
20368: LIST
20369: LIST
20370: PPUSH
20371: CALL_OW 69
20375: ST_TO_ADDR
// if not tmp then
20376: LD_VAR 0 2
20380: NOT
20381: IFFALSE 20385
// exit ;
20383: GO 20472
// un := tmp [ rand ( 1 , tmp ) ] ;
20385: LD_ADDR_VAR 0 1
20389: PUSH
20390: LD_VAR 0 2
20394: PUSH
20395: LD_INT 1
20397: PPUSH
20398: LD_VAR 0 2
20402: PPUSH
20403: CALL_OW 12
20407: ARRAY
20408: ST_TO_ADDR
// SetSide ( un , 0 ) ;
20409: LD_VAR 0 1
20413: PPUSH
20414: LD_INT 0
20416: PPUSH
20417: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
20421: LD_VAR 0 1
20425: PPUSH
20426: LD_OWVAR 3
20430: PUSH
20431: LD_VAR 0 1
20435: DIFF
20436: PPUSH
20437: LD_VAR 0 1
20441: PPUSH
20442: CALL_OW 74
20446: PPUSH
20447: CALL_OW 115
// wait ( 0 0$20 ) ;
20451: LD_INT 700
20453: PPUSH
20454: CALL_OW 67
// SetSide ( un , your_side ) ;
20458: LD_VAR 0 1
20462: PPUSH
20463: LD_OWVAR 2
20467: PPUSH
20468: CALL_OW 235
// end ;
20472: PPOPN 2
20474: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
20475: LD_EXP 46
20479: PUSH
20480: LD_EXP 79
20484: AND
20485: IFFALSE 20591
20487: GO 20489
20489: DISABLE
20490: LD_INT 0
20492: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
20493: LD_ADDR_VAR 0 1
20497: PUSH
20498: LD_INT 22
20500: PUSH
20501: LD_OWVAR 2
20505: PUSH
20506: EMPTY
20507: LIST
20508: LIST
20509: PUSH
20510: LD_INT 2
20512: PUSH
20513: LD_INT 30
20515: PUSH
20516: LD_INT 0
20518: PUSH
20519: EMPTY
20520: LIST
20521: LIST
20522: PUSH
20523: LD_INT 30
20525: PUSH
20526: LD_INT 1
20528: PUSH
20529: EMPTY
20530: LIST
20531: LIST
20532: PUSH
20533: EMPTY
20534: LIST
20535: LIST
20536: LIST
20537: PUSH
20538: EMPTY
20539: LIST
20540: LIST
20541: PPUSH
20542: CALL_OW 69
20546: ST_TO_ADDR
// if not depot then
20547: LD_VAR 0 1
20551: NOT
20552: IFFALSE 20556
// exit ;
20554: GO 20591
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
20556: LD_VAR 0 1
20560: PUSH
20561: LD_INT 1
20563: ARRAY
20564: PPUSH
20565: CALL_OW 250
20569: PPUSH
20570: LD_VAR 0 1
20574: PUSH
20575: LD_INT 1
20577: ARRAY
20578: PPUSH
20579: CALL_OW 251
20583: PPUSH
20584: LD_INT 70
20586: PPUSH
20587: CALL_OW 495
// end ;
20591: PPOPN 1
20593: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
20594: LD_EXP 46
20598: PUSH
20599: LD_EXP 80
20603: AND
20604: IFFALSE 20815
20606: GO 20608
20608: DISABLE
20609: LD_INT 0
20611: PPUSH
20612: PPUSH
20613: PPUSH
20614: PPUSH
20615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20616: LD_ADDR_VAR 0 5
20620: PUSH
20621: LD_INT 22
20623: PUSH
20624: LD_OWVAR 2
20628: PUSH
20629: EMPTY
20630: LIST
20631: LIST
20632: PUSH
20633: LD_INT 21
20635: PUSH
20636: LD_INT 1
20638: PUSH
20639: EMPTY
20640: LIST
20641: LIST
20642: PUSH
20643: EMPTY
20644: LIST
20645: LIST
20646: PPUSH
20647: CALL_OW 69
20651: ST_TO_ADDR
// if not tmp then
20652: LD_VAR 0 5
20656: NOT
20657: IFFALSE 20661
// exit ;
20659: GO 20815
// for i in tmp do
20661: LD_ADDR_VAR 0 1
20665: PUSH
20666: LD_VAR 0 5
20670: PUSH
20671: FOR_IN
20672: IFFALSE 20813
// begin d := rand ( 0 , 5 ) ;
20674: LD_ADDR_VAR 0 4
20678: PUSH
20679: LD_INT 0
20681: PPUSH
20682: LD_INT 5
20684: PPUSH
20685: CALL_OW 12
20689: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
20690: LD_ADDR_VAR 0 2
20694: PUSH
20695: LD_VAR 0 1
20699: PPUSH
20700: CALL_OW 250
20704: PPUSH
20705: LD_VAR 0 4
20709: PPUSH
20710: LD_INT 3
20712: PPUSH
20713: LD_INT 12
20715: PPUSH
20716: CALL_OW 12
20720: PPUSH
20721: CALL_OW 272
20725: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
20726: LD_ADDR_VAR 0 3
20730: PUSH
20731: LD_VAR 0 1
20735: PPUSH
20736: CALL_OW 251
20740: PPUSH
20741: LD_VAR 0 4
20745: PPUSH
20746: LD_INT 3
20748: PPUSH
20749: LD_INT 12
20751: PPUSH
20752: CALL_OW 12
20756: PPUSH
20757: CALL_OW 273
20761: ST_TO_ADDR
// if ValidHex ( x , y ) then
20762: LD_VAR 0 2
20766: PPUSH
20767: LD_VAR 0 3
20771: PPUSH
20772: CALL_OW 488
20776: IFFALSE 20811
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
20778: LD_VAR 0 1
20782: PPUSH
20783: LD_VAR 0 2
20787: PPUSH
20788: LD_VAR 0 3
20792: PPUSH
20793: LD_INT 3
20795: PPUSH
20796: LD_INT 6
20798: PPUSH
20799: CALL_OW 12
20803: PPUSH
20804: LD_INT 1
20806: PPUSH
20807: CALL_OW 483
// end ;
20811: GO 20671
20813: POP
20814: POP
// end ;
20815: PPOPN 5
20817: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
20818: LD_EXP 46
20822: PUSH
20823: LD_EXP 81
20827: AND
20828: IFFALSE 20922
20830: GO 20832
20832: DISABLE
20833: LD_INT 0
20835: PPUSH
20836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
20837: LD_ADDR_VAR 0 2
20841: PUSH
20842: LD_INT 22
20844: PUSH
20845: LD_OWVAR 2
20849: PUSH
20850: EMPTY
20851: LIST
20852: LIST
20853: PUSH
20854: LD_INT 32
20856: PUSH
20857: LD_INT 1
20859: PUSH
20860: EMPTY
20861: LIST
20862: LIST
20863: PUSH
20864: LD_INT 21
20866: PUSH
20867: LD_INT 2
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: PUSH
20874: EMPTY
20875: LIST
20876: LIST
20877: LIST
20878: PPUSH
20879: CALL_OW 69
20883: ST_TO_ADDR
// if not tmp then
20884: LD_VAR 0 2
20888: NOT
20889: IFFALSE 20893
// exit ;
20891: GO 20922
// for i in tmp do
20893: LD_ADDR_VAR 0 1
20897: PUSH
20898: LD_VAR 0 2
20902: PUSH
20903: FOR_IN
20904: IFFALSE 20920
// SetFuel ( i , 0 ) ;
20906: LD_VAR 0 1
20910: PPUSH
20911: LD_INT 0
20913: PPUSH
20914: CALL_OW 240
20918: GO 20903
20920: POP
20921: POP
// end ;
20922: PPOPN 2
20924: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
20925: LD_EXP 46
20929: PUSH
20930: LD_EXP 82
20934: AND
20935: IFFALSE 21001
20937: GO 20939
20939: DISABLE
20940: LD_INT 0
20942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20943: LD_ADDR_VAR 0 1
20947: PUSH
20948: LD_INT 22
20950: PUSH
20951: LD_OWVAR 2
20955: PUSH
20956: EMPTY
20957: LIST
20958: LIST
20959: PUSH
20960: LD_INT 30
20962: PUSH
20963: LD_INT 29
20965: PUSH
20966: EMPTY
20967: LIST
20968: LIST
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: PPUSH
20974: CALL_OW 69
20978: ST_TO_ADDR
// if not tmp then
20979: LD_VAR 0 1
20983: NOT
20984: IFFALSE 20988
// exit ;
20986: GO 21001
// DestroyUnit ( tmp [ 1 ] ) ;
20988: LD_VAR 0 1
20992: PUSH
20993: LD_INT 1
20995: ARRAY
20996: PPUSH
20997: CALL_OW 65
// end ;
21001: PPOPN 1
21003: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
21004: LD_EXP 46
21008: PUSH
21009: LD_EXP 84
21013: AND
21014: IFFALSE 21143
21016: GO 21018
21018: DISABLE
21019: LD_INT 0
21021: PPUSH
// begin uc_side := 0 ;
21022: LD_ADDR_OWVAR 20
21026: PUSH
21027: LD_INT 0
21029: ST_TO_ADDR
// uc_nation := nation_arabian ;
21030: LD_ADDR_OWVAR 21
21034: PUSH
21035: LD_INT 2
21037: ST_TO_ADDR
// hc_gallery :=  ;
21038: LD_ADDR_OWVAR 33
21042: PUSH
21043: LD_STRING 
21045: ST_TO_ADDR
// hc_name :=  ;
21046: LD_ADDR_OWVAR 26
21050: PUSH
21051: LD_STRING 
21053: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
21054: LD_INT 1
21056: PPUSH
21057: LD_INT 11
21059: PPUSH
21060: LD_INT 10
21062: PPUSH
21063: CALL_OW 380
// un := CreateHuman ;
21067: LD_ADDR_VAR 0 1
21071: PUSH
21072: CALL_OW 44
21076: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21077: LD_VAR 0 1
21081: PPUSH
21082: LD_INT 1
21084: PPUSH
21085: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
21089: LD_INT 35
21091: PPUSH
21092: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
21096: LD_VAR 0 1
21100: PPUSH
21101: LD_INT 22
21103: PUSH
21104: LD_OWVAR 2
21108: PUSH
21109: EMPTY
21110: LIST
21111: LIST
21112: PPUSH
21113: CALL_OW 69
21117: PPUSH
21118: LD_VAR 0 1
21122: PPUSH
21123: CALL_OW 74
21127: PPUSH
21128: CALL_OW 115
// until IsDead ( un ) ;
21132: LD_VAR 0 1
21136: PPUSH
21137: CALL_OW 301
21141: IFFALSE 21089
// end ;
21143: PPOPN 1
21145: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
21146: LD_EXP 46
21150: PUSH
21151: LD_EXP 86
21155: AND
21156: IFFALSE 21168
21158: GO 21160
21160: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
21161: LD_STRING earthquake(getX(game), 0, 32)
21163: PPUSH
21164: CALL_OW 559
21168: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
21169: LD_EXP 46
21173: PUSH
21174: LD_EXP 87
21178: AND
21179: IFFALSE 21270
21181: GO 21183
21183: DISABLE
21184: LD_INT 0
21186: PPUSH
// begin enable ;
21187: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
21188: LD_ADDR_VAR 0 1
21192: PUSH
21193: LD_INT 22
21195: PUSH
21196: LD_OWVAR 2
21200: PUSH
21201: EMPTY
21202: LIST
21203: LIST
21204: PUSH
21205: LD_INT 21
21207: PUSH
21208: LD_INT 2
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: PUSH
21215: LD_INT 33
21217: PUSH
21218: LD_INT 3
21220: PUSH
21221: EMPTY
21222: LIST
21223: LIST
21224: PUSH
21225: EMPTY
21226: LIST
21227: LIST
21228: LIST
21229: PPUSH
21230: CALL_OW 69
21234: ST_TO_ADDR
// if not tmp then
21235: LD_VAR 0 1
21239: NOT
21240: IFFALSE 21244
// exit ;
21242: GO 21270
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21244: LD_VAR 0 1
21248: PUSH
21249: LD_INT 1
21251: PPUSH
21252: LD_VAR 0 1
21256: PPUSH
21257: CALL_OW 12
21261: ARRAY
21262: PPUSH
21263: LD_INT 1
21265: PPUSH
21266: CALL_OW 234
// end ;
21270: PPOPN 1
21272: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
21273: LD_EXP 46
21277: PUSH
21278: LD_EXP 88
21282: AND
21283: IFFALSE 21424
21285: GO 21287
21287: DISABLE
21288: LD_INT 0
21290: PPUSH
21291: PPUSH
21292: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21293: LD_ADDR_VAR 0 3
21297: PUSH
21298: LD_INT 22
21300: PUSH
21301: LD_OWVAR 2
21305: PUSH
21306: EMPTY
21307: LIST
21308: LIST
21309: PUSH
21310: LD_INT 25
21312: PUSH
21313: LD_INT 1
21315: PUSH
21316: EMPTY
21317: LIST
21318: LIST
21319: PUSH
21320: EMPTY
21321: LIST
21322: LIST
21323: PPUSH
21324: CALL_OW 69
21328: ST_TO_ADDR
// if not tmp then
21329: LD_VAR 0 3
21333: NOT
21334: IFFALSE 21338
// exit ;
21336: GO 21424
// un := tmp [ rand ( 1 , tmp ) ] ;
21338: LD_ADDR_VAR 0 2
21342: PUSH
21343: LD_VAR 0 3
21347: PUSH
21348: LD_INT 1
21350: PPUSH
21351: LD_VAR 0 3
21355: PPUSH
21356: CALL_OW 12
21360: ARRAY
21361: ST_TO_ADDR
// if Crawls ( un ) then
21362: LD_VAR 0 2
21366: PPUSH
21367: CALL_OW 318
21371: IFFALSE 21382
// ComWalk ( un ) ;
21373: LD_VAR 0 2
21377: PPUSH
21378: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
21382: LD_VAR 0 2
21386: PPUSH
21387: LD_INT 9
21389: PPUSH
21390: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
21394: LD_INT 28
21396: PPUSH
21397: LD_OWVAR 2
21401: PPUSH
21402: LD_INT 2
21404: PPUSH
21405: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
21409: LD_INT 29
21411: PPUSH
21412: LD_OWVAR 2
21416: PPUSH
21417: LD_INT 2
21419: PPUSH
21420: CALL_OW 322
// end ;
21424: PPOPN 3
21426: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
21427: LD_EXP 46
21431: PUSH
21432: LD_EXP 89
21436: AND
21437: IFFALSE 21548
21439: GO 21441
21441: DISABLE
21442: LD_INT 0
21444: PPUSH
21445: PPUSH
21446: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21447: LD_ADDR_VAR 0 3
21451: PUSH
21452: LD_INT 22
21454: PUSH
21455: LD_OWVAR 2
21459: PUSH
21460: EMPTY
21461: LIST
21462: LIST
21463: PUSH
21464: LD_INT 25
21466: PUSH
21467: LD_INT 1
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: PUSH
21474: EMPTY
21475: LIST
21476: LIST
21477: PPUSH
21478: CALL_OW 69
21482: ST_TO_ADDR
// if not tmp then
21483: LD_VAR 0 3
21487: NOT
21488: IFFALSE 21492
// exit ;
21490: GO 21548
// un := tmp [ rand ( 1 , tmp ) ] ;
21492: LD_ADDR_VAR 0 2
21496: PUSH
21497: LD_VAR 0 3
21501: PUSH
21502: LD_INT 1
21504: PPUSH
21505: LD_VAR 0 3
21509: PPUSH
21510: CALL_OW 12
21514: ARRAY
21515: ST_TO_ADDR
// if Crawls ( un ) then
21516: LD_VAR 0 2
21520: PPUSH
21521: CALL_OW 318
21525: IFFALSE 21536
// ComWalk ( un ) ;
21527: LD_VAR 0 2
21531: PPUSH
21532: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21536: LD_VAR 0 2
21540: PPUSH
21541: LD_INT 8
21543: PPUSH
21544: CALL_OW 336
// end ;
21548: PPOPN 3
21550: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
21551: LD_EXP 46
21555: PUSH
21556: LD_EXP 90
21560: AND
21561: IFFALSE 21705
21563: GO 21565
21565: DISABLE
21566: LD_INT 0
21568: PPUSH
21569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
21570: LD_ADDR_VAR 0 2
21574: PUSH
21575: LD_INT 22
21577: PUSH
21578: LD_OWVAR 2
21582: PUSH
21583: EMPTY
21584: LIST
21585: LIST
21586: PUSH
21587: LD_INT 21
21589: PUSH
21590: LD_INT 2
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: PUSH
21597: LD_INT 2
21599: PUSH
21600: LD_INT 34
21602: PUSH
21603: LD_INT 12
21605: PUSH
21606: EMPTY
21607: LIST
21608: LIST
21609: PUSH
21610: LD_INT 34
21612: PUSH
21613: LD_INT 51
21615: PUSH
21616: EMPTY
21617: LIST
21618: LIST
21619: PUSH
21620: LD_INT 34
21622: PUSH
21623: LD_INT 32
21625: PUSH
21626: EMPTY
21627: LIST
21628: LIST
21629: PUSH
21630: EMPTY
21631: LIST
21632: LIST
21633: LIST
21634: LIST
21635: PUSH
21636: EMPTY
21637: LIST
21638: LIST
21639: LIST
21640: PPUSH
21641: CALL_OW 69
21645: ST_TO_ADDR
// if not tmp then
21646: LD_VAR 0 2
21650: NOT
21651: IFFALSE 21655
// exit ;
21653: GO 21705
// for i in tmp do
21655: LD_ADDR_VAR 0 1
21659: PUSH
21660: LD_VAR 0 2
21664: PUSH
21665: FOR_IN
21666: IFFALSE 21703
// if GetCargo ( i , mat_artifact ) = 0 then
21668: LD_VAR 0 1
21672: PPUSH
21673: LD_INT 4
21675: PPUSH
21676: CALL_OW 289
21680: PUSH
21681: LD_INT 0
21683: EQUAL
21684: IFFALSE 21701
// SetCargo ( i , mat_siberit , 100 ) ;
21686: LD_VAR 0 1
21690: PPUSH
21691: LD_INT 3
21693: PPUSH
21694: LD_INT 100
21696: PPUSH
21697: CALL_OW 290
21701: GO 21665
21703: POP
21704: POP
// end ;
21705: PPOPN 2
21707: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
21708: LD_EXP 46
21712: PUSH
21713: LD_EXP 91
21717: AND
21718: IFFALSE 21901
21720: GO 21722
21722: DISABLE
21723: LD_INT 0
21725: PPUSH
21726: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
21727: LD_ADDR_VAR 0 2
21731: PUSH
21732: LD_INT 22
21734: PUSH
21735: LD_OWVAR 2
21739: PUSH
21740: EMPTY
21741: LIST
21742: LIST
21743: PPUSH
21744: CALL_OW 69
21748: ST_TO_ADDR
// if not tmp then
21749: LD_VAR 0 2
21753: NOT
21754: IFFALSE 21758
// exit ;
21756: GO 21901
// for i := 1 to 2 do
21758: LD_ADDR_VAR 0 1
21762: PUSH
21763: DOUBLE
21764: LD_INT 1
21766: DEC
21767: ST_TO_ADDR
21768: LD_INT 2
21770: PUSH
21771: FOR_TO
21772: IFFALSE 21899
// begin uc_side := your_side ;
21774: LD_ADDR_OWVAR 20
21778: PUSH
21779: LD_OWVAR 2
21783: ST_TO_ADDR
// uc_nation := nation_american ;
21784: LD_ADDR_OWVAR 21
21788: PUSH
21789: LD_INT 1
21791: ST_TO_ADDR
// vc_chassis := us_morphling ;
21792: LD_ADDR_OWVAR 37
21796: PUSH
21797: LD_INT 5
21799: ST_TO_ADDR
// vc_engine := engine_siberite ;
21800: LD_ADDR_OWVAR 39
21804: PUSH
21805: LD_INT 3
21807: ST_TO_ADDR
// vc_control := control_computer ;
21808: LD_ADDR_OWVAR 38
21812: PUSH
21813: LD_INT 3
21815: ST_TO_ADDR
// vc_weapon := us_double_laser ;
21816: LD_ADDR_OWVAR 40
21820: PUSH
21821: LD_INT 10
21823: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
21824: LD_VAR 0 2
21828: PUSH
21829: LD_INT 1
21831: ARRAY
21832: PPUSH
21833: CALL_OW 310
21837: NOT
21838: IFFALSE 21885
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
21840: CALL_OW 45
21844: PPUSH
21845: LD_VAR 0 2
21849: PUSH
21850: LD_INT 1
21852: ARRAY
21853: PPUSH
21854: CALL_OW 250
21858: PPUSH
21859: LD_VAR 0 2
21863: PUSH
21864: LD_INT 1
21866: ARRAY
21867: PPUSH
21868: CALL_OW 251
21872: PPUSH
21873: LD_INT 12
21875: PPUSH
21876: LD_INT 1
21878: PPUSH
21879: CALL_OW 50
21883: GO 21897
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
21885: CALL_OW 45
21889: PPUSH
21890: LD_INT 1
21892: PPUSH
21893: CALL_OW 51
// end ;
21897: GO 21771
21899: POP
21900: POP
// end ;
21901: PPOPN 2
21903: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
21904: LD_EXP 46
21908: PUSH
21909: LD_EXP 92
21913: AND
21914: IFFALSE 22136
21916: GO 21918
21918: DISABLE
21919: LD_INT 0
21921: PPUSH
21922: PPUSH
21923: PPUSH
21924: PPUSH
21925: PPUSH
21926: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21927: LD_ADDR_VAR 0 6
21931: PUSH
21932: LD_INT 22
21934: PUSH
21935: LD_OWVAR 2
21939: PUSH
21940: EMPTY
21941: LIST
21942: LIST
21943: PUSH
21944: LD_INT 21
21946: PUSH
21947: LD_INT 1
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: PUSH
21954: LD_INT 3
21956: PUSH
21957: LD_INT 23
21959: PUSH
21960: LD_INT 0
21962: PUSH
21963: EMPTY
21964: LIST
21965: LIST
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: PUSH
21971: EMPTY
21972: LIST
21973: LIST
21974: LIST
21975: PPUSH
21976: CALL_OW 69
21980: ST_TO_ADDR
// if not tmp then
21981: LD_VAR 0 6
21985: NOT
21986: IFFALSE 21990
// exit ;
21988: GO 22136
// s1 := rand ( 1 , 4 ) ;
21990: LD_ADDR_VAR 0 2
21994: PUSH
21995: LD_INT 1
21997: PPUSH
21998: LD_INT 4
22000: PPUSH
22001: CALL_OW 12
22005: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
22006: LD_ADDR_VAR 0 4
22010: PUSH
22011: LD_VAR 0 6
22015: PUSH
22016: LD_INT 1
22018: ARRAY
22019: PPUSH
22020: LD_VAR 0 2
22024: PPUSH
22025: CALL_OW 259
22029: ST_TO_ADDR
// if s1 = 1 then
22030: LD_VAR 0 2
22034: PUSH
22035: LD_INT 1
22037: EQUAL
22038: IFFALSE 22058
// s2 := rand ( 2 , 4 ) else
22040: LD_ADDR_VAR 0 3
22044: PUSH
22045: LD_INT 2
22047: PPUSH
22048: LD_INT 4
22050: PPUSH
22051: CALL_OW 12
22055: ST_TO_ADDR
22056: GO 22066
// s2 := 1 ;
22058: LD_ADDR_VAR 0 3
22062: PUSH
22063: LD_INT 1
22065: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
22066: LD_ADDR_VAR 0 5
22070: PUSH
22071: LD_VAR 0 6
22075: PUSH
22076: LD_INT 1
22078: ARRAY
22079: PPUSH
22080: LD_VAR 0 3
22084: PPUSH
22085: CALL_OW 259
22089: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
22090: LD_VAR 0 6
22094: PUSH
22095: LD_INT 1
22097: ARRAY
22098: PPUSH
22099: LD_VAR 0 2
22103: PPUSH
22104: LD_VAR 0 5
22108: PPUSH
22109: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
22113: LD_VAR 0 6
22117: PUSH
22118: LD_INT 1
22120: ARRAY
22121: PPUSH
22122: LD_VAR 0 3
22126: PPUSH
22127: LD_VAR 0 4
22131: PPUSH
22132: CALL_OW 237
// end ;
22136: PPOPN 6
22138: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
22139: LD_EXP 46
22143: PUSH
22144: LD_EXP 93
22148: AND
22149: IFFALSE 22228
22151: GO 22153
22153: DISABLE
22154: LD_INT 0
22156: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
22157: LD_ADDR_VAR 0 1
22161: PUSH
22162: LD_INT 22
22164: PUSH
22165: LD_OWVAR 2
22169: PUSH
22170: EMPTY
22171: LIST
22172: LIST
22173: PUSH
22174: LD_INT 30
22176: PUSH
22177: LD_INT 3
22179: PUSH
22180: EMPTY
22181: LIST
22182: LIST
22183: PUSH
22184: EMPTY
22185: LIST
22186: LIST
22187: PPUSH
22188: CALL_OW 69
22192: ST_TO_ADDR
// if not tmp then
22193: LD_VAR 0 1
22197: NOT
22198: IFFALSE 22202
// exit ;
22200: GO 22228
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
22202: LD_VAR 0 1
22206: PUSH
22207: LD_INT 1
22209: PPUSH
22210: LD_VAR 0 1
22214: PPUSH
22215: CALL_OW 12
22219: ARRAY
22220: PPUSH
22221: LD_INT 1
22223: PPUSH
22224: CALL_OW 234
// end ;
22228: PPOPN 1
22230: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
22231: LD_EXP 46
22235: PUSH
22236: LD_EXP 94
22240: AND
22241: IFFALSE 22353
22243: GO 22245
22245: DISABLE
22246: LD_INT 0
22248: PPUSH
22249: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
22250: LD_ADDR_VAR 0 2
22254: PUSH
22255: LD_INT 22
22257: PUSH
22258: LD_OWVAR 2
22262: PUSH
22263: EMPTY
22264: LIST
22265: LIST
22266: PUSH
22267: LD_INT 2
22269: PUSH
22270: LD_INT 30
22272: PUSH
22273: LD_INT 27
22275: PUSH
22276: EMPTY
22277: LIST
22278: LIST
22279: PUSH
22280: LD_INT 30
22282: PUSH
22283: LD_INT 26
22285: PUSH
22286: EMPTY
22287: LIST
22288: LIST
22289: PUSH
22290: LD_INT 30
22292: PUSH
22293: LD_INT 28
22295: PUSH
22296: EMPTY
22297: LIST
22298: LIST
22299: PUSH
22300: EMPTY
22301: LIST
22302: LIST
22303: LIST
22304: LIST
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: PPUSH
22310: CALL_OW 69
22314: ST_TO_ADDR
// if not tmp then
22315: LD_VAR 0 2
22319: NOT
22320: IFFALSE 22324
// exit ;
22322: GO 22353
// for i in tmp do
22324: LD_ADDR_VAR 0 1
22328: PUSH
22329: LD_VAR 0 2
22333: PUSH
22334: FOR_IN
22335: IFFALSE 22351
// SetLives ( i , 1 ) ;
22337: LD_VAR 0 1
22341: PPUSH
22342: LD_INT 1
22344: PPUSH
22345: CALL_OW 234
22349: GO 22334
22351: POP
22352: POP
// end ;
22353: PPOPN 2
22355: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
22356: LD_EXP 46
22360: PUSH
22361: LD_EXP 95
22365: AND
22366: IFFALSE 22640
22368: GO 22370
22370: DISABLE
22371: LD_INT 0
22373: PPUSH
22374: PPUSH
22375: PPUSH
// begin i := rand ( 1 , 7 ) ;
22376: LD_ADDR_VAR 0 1
22380: PUSH
22381: LD_INT 1
22383: PPUSH
22384: LD_INT 7
22386: PPUSH
22387: CALL_OW 12
22391: ST_TO_ADDR
// case i of 1 :
22392: LD_VAR 0 1
22396: PUSH
22397: LD_INT 1
22399: DOUBLE
22400: EQUAL
22401: IFTRUE 22405
22403: GO 22415
22405: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
22406: LD_STRING earthquake(getX(game), 0, 32)
22408: PPUSH
22409: CALL_OW 559
22413: GO 22640
22415: LD_INT 2
22417: DOUBLE
22418: EQUAL
22419: IFTRUE 22423
22421: GO 22437
22423: POP
// begin ToLua ( displayStucuk(); ) ;
22424: LD_STRING displayStucuk();
22426: PPUSH
22427: CALL_OW 559
// ResetFog ;
22431: CALL_OW 335
// end ; 3 :
22435: GO 22640
22437: LD_INT 3
22439: DOUBLE
22440: EQUAL
22441: IFTRUE 22445
22443: GO 22549
22445: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
22446: LD_ADDR_VAR 0 2
22450: PUSH
22451: LD_INT 22
22453: PUSH
22454: LD_OWVAR 2
22458: PUSH
22459: EMPTY
22460: LIST
22461: LIST
22462: PUSH
22463: LD_INT 25
22465: PUSH
22466: LD_INT 1
22468: PUSH
22469: EMPTY
22470: LIST
22471: LIST
22472: PUSH
22473: EMPTY
22474: LIST
22475: LIST
22476: PPUSH
22477: CALL_OW 69
22481: ST_TO_ADDR
// if not tmp then
22482: LD_VAR 0 2
22486: NOT
22487: IFFALSE 22491
// exit ;
22489: GO 22640
// un := tmp [ rand ( 1 , tmp ) ] ;
22491: LD_ADDR_VAR 0 3
22495: PUSH
22496: LD_VAR 0 2
22500: PUSH
22501: LD_INT 1
22503: PPUSH
22504: LD_VAR 0 2
22508: PPUSH
22509: CALL_OW 12
22513: ARRAY
22514: ST_TO_ADDR
// if Crawls ( un ) then
22515: LD_VAR 0 3
22519: PPUSH
22520: CALL_OW 318
22524: IFFALSE 22535
// ComWalk ( un ) ;
22526: LD_VAR 0 3
22530: PPUSH
22531: CALL_OW 138
// SetClass ( un , class_mortar ) ;
22535: LD_VAR 0 3
22539: PPUSH
22540: LD_INT 8
22542: PPUSH
22543: CALL_OW 336
// end ; 4 :
22547: GO 22640
22549: LD_INT 4
22551: DOUBLE
22552: EQUAL
22553: IFTRUE 22557
22555: GO 22618
22557: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
22558: LD_ADDR_VAR 0 2
22562: PUSH
22563: LD_INT 22
22565: PUSH
22566: LD_OWVAR 2
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: PUSH
22575: LD_INT 30
22577: PUSH
22578: LD_INT 29
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PPUSH
22589: CALL_OW 69
22593: ST_TO_ADDR
// if not tmp then
22594: LD_VAR 0 2
22598: NOT
22599: IFFALSE 22603
// exit ;
22601: GO 22640
// DestroyUnit ( tmp [ 1 ] ) ;
22603: LD_VAR 0 2
22607: PUSH
22608: LD_INT 1
22610: ARRAY
22611: PPUSH
22612: CALL_OW 65
// end ; 5 .. 7 :
22616: GO 22640
22618: LD_INT 5
22620: DOUBLE
22621: GREATEREQUAL
22622: IFFALSE 22630
22624: LD_INT 7
22626: DOUBLE
22627: LESSEQUAL
22628: IFTRUE 22632
22630: GO 22639
22632: POP
// StreamSibBomb ; end ;
22633: CALL 18890 0 0
22637: GO 22640
22639: POP
// end ;
22640: PPOPN 3
22642: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
22643: LD_EXP 46
22647: PUSH
22648: LD_EXP 96
22652: AND
22653: IFFALSE 22809
22655: GO 22657
22657: DISABLE
22658: LD_INT 0
22660: PPUSH
22661: PPUSH
22662: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
22663: LD_ADDR_VAR 0 2
22667: PUSH
22668: LD_INT 81
22670: PUSH
22671: LD_OWVAR 2
22675: PUSH
22676: EMPTY
22677: LIST
22678: LIST
22679: PUSH
22680: LD_INT 2
22682: PUSH
22683: LD_INT 21
22685: PUSH
22686: LD_INT 1
22688: PUSH
22689: EMPTY
22690: LIST
22691: LIST
22692: PUSH
22693: LD_INT 21
22695: PUSH
22696: LD_INT 2
22698: PUSH
22699: EMPTY
22700: LIST
22701: LIST
22702: PUSH
22703: EMPTY
22704: LIST
22705: LIST
22706: LIST
22707: PUSH
22708: EMPTY
22709: LIST
22710: LIST
22711: PPUSH
22712: CALL_OW 69
22716: ST_TO_ADDR
// if not tmp then
22717: LD_VAR 0 2
22721: NOT
22722: IFFALSE 22726
// exit ;
22724: GO 22809
// p := 0 ;
22726: LD_ADDR_VAR 0 3
22730: PUSH
22731: LD_INT 0
22733: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22734: LD_INT 35
22736: PPUSH
22737: CALL_OW 67
// p := p + 1 ;
22741: LD_ADDR_VAR 0 3
22745: PUSH
22746: LD_VAR 0 3
22750: PUSH
22751: LD_INT 1
22753: PLUS
22754: ST_TO_ADDR
// for i in tmp do
22755: LD_ADDR_VAR 0 1
22759: PUSH
22760: LD_VAR 0 2
22764: PUSH
22765: FOR_IN
22766: IFFALSE 22797
// if GetLives ( i ) < 1000 then
22768: LD_VAR 0 1
22772: PPUSH
22773: CALL_OW 256
22777: PUSH
22778: LD_INT 1000
22780: LESS
22781: IFFALSE 22795
// SetLives ( i , 1000 ) ;
22783: LD_VAR 0 1
22787: PPUSH
22788: LD_INT 1000
22790: PPUSH
22791: CALL_OW 234
22795: GO 22765
22797: POP
22798: POP
// until p > 20 ;
22799: LD_VAR 0 3
22803: PUSH
22804: LD_INT 20
22806: GREATER
22807: IFFALSE 22734
// end ;
22809: PPOPN 3
22811: END
// every 0 0$1 trigger StreamModeActive and sTime do
22812: LD_EXP 46
22816: PUSH
22817: LD_EXP 97
22821: AND
22822: IFFALSE 22857
22824: GO 22826
22826: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
22827: LD_INT 28
22829: PPUSH
22830: LD_OWVAR 2
22834: PPUSH
22835: LD_INT 2
22837: PPUSH
22838: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
22842: LD_INT 30
22844: PPUSH
22845: LD_OWVAR 2
22849: PPUSH
22850: LD_INT 2
22852: PPUSH
22853: CALL_OW 322
// end ;
22857: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
22858: LD_EXP 46
22862: PUSH
22863: LD_EXP 98
22867: AND
22868: IFFALSE 22989
22870: GO 22872
22872: DISABLE
22873: LD_INT 0
22875: PPUSH
22876: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22877: LD_ADDR_VAR 0 2
22881: PUSH
22882: LD_INT 22
22884: PUSH
22885: LD_OWVAR 2
22889: PUSH
22890: EMPTY
22891: LIST
22892: LIST
22893: PUSH
22894: LD_INT 21
22896: PUSH
22897: LD_INT 1
22899: PUSH
22900: EMPTY
22901: LIST
22902: LIST
22903: PUSH
22904: LD_INT 3
22906: PUSH
22907: LD_INT 23
22909: PUSH
22910: LD_INT 0
22912: PUSH
22913: EMPTY
22914: LIST
22915: LIST
22916: PUSH
22917: EMPTY
22918: LIST
22919: LIST
22920: PUSH
22921: EMPTY
22922: LIST
22923: LIST
22924: LIST
22925: PPUSH
22926: CALL_OW 69
22930: ST_TO_ADDR
// if not tmp then
22931: LD_VAR 0 2
22935: NOT
22936: IFFALSE 22940
// exit ;
22938: GO 22989
// for i in tmp do
22940: LD_ADDR_VAR 0 1
22944: PUSH
22945: LD_VAR 0 2
22949: PUSH
22950: FOR_IN
22951: IFFALSE 22987
// begin if Crawls ( i ) then
22953: LD_VAR 0 1
22957: PPUSH
22958: CALL_OW 318
22962: IFFALSE 22973
// ComWalk ( i ) ;
22964: LD_VAR 0 1
22968: PPUSH
22969: CALL_OW 138
// SetClass ( i , 2 ) ;
22973: LD_VAR 0 1
22977: PPUSH
22978: LD_INT 2
22980: PPUSH
22981: CALL_OW 336
// end ;
22985: GO 22950
22987: POP
22988: POP
// end ;
22989: PPOPN 2
22991: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
22992: LD_EXP 46
22996: PUSH
22997: LD_EXP 99
23001: AND
23002: IFFALSE 23283
23004: GO 23006
23006: DISABLE
23007: LD_INT 0
23009: PPUSH
23010: PPUSH
23011: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
23012: LD_OWVAR 2
23016: PPUSH
23017: LD_INT 9
23019: PPUSH
23020: LD_INT 1
23022: PPUSH
23023: LD_INT 1
23025: PPUSH
23026: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
23030: LD_INT 9
23032: PPUSH
23033: LD_OWVAR 2
23037: PPUSH
23038: CALL_OW 343
// uc_side := 9 ;
23042: LD_ADDR_OWVAR 20
23046: PUSH
23047: LD_INT 9
23049: ST_TO_ADDR
// uc_nation := 2 ;
23050: LD_ADDR_OWVAR 21
23054: PUSH
23055: LD_INT 2
23057: ST_TO_ADDR
// hc_name := Dark Warrior ;
23058: LD_ADDR_OWVAR 26
23062: PUSH
23063: LD_STRING Dark Warrior
23065: ST_TO_ADDR
// hc_gallery :=  ;
23066: LD_ADDR_OWVAR 33
23070: PUSH
23071: LD_STRING 
23073: ST_TO_ADDR
// hc_noskilllimit := true ;
23074: LD_ADDR_OWVAR 76
23078: PUSH
23079: LD_INT 1
23081: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
23082: LD_ADDR_OWVAR 31
23086: PUSH
23087: LD_INT 30
23089: PUSH
23090: LD_INT 30
23092: PUSH
23093: LD_INT 30
23095: PUSH
23096: LD_INT 30
23098: PUSH
23099: EMPTY
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: ST_TO_ADDR
// un := CreateHuman ;
23105: LD_ADDR_VAR 0 3
23109: PUSH
23110: CALL_OW 44
23114: ST_TO_ADDR
// hc_noskilllimit := false ;
23115: LD_ADDR_OWVAR 76
23119: PUSH
23120: LD_INT 0
23122: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23123: LD_VAR 0 3
23127: PPUSH
23128: LD_INT 1
23130: PPUSH
23131: CALL_OW 51
// p := 0 ;
23135: LD_ADDR_VAR 0 2
23139: PUSH
23140: LD_INT 0
23142: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23143: LD_INT 35
23145: PPUSH
23146: CALL_OW 67
// p := p + 1 ;
23150: LD_ADDR_VAR 0 2
23154: PUSH
23155: LD_VAR 0 2
23159: PUSH
23160: LD_INT 1
23162: PLUS
23163: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
23164: LD_VAR 0 3
23168: PPUSH
23169: CALL_OW 256
23173: PUSH
23174: LD_INT 1000
23176: LESS
23177: IFFALSE 23191
// SetLives ( un , 1000 ) ;
23179: LD_VAR 0 3
23183: PPUSH
23184: LD_INT 1000
23186: PPUSH
23187: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
23191: LD_VAR 0 3
23195: PPUSH
23196: LD_INT 81
23198: PUSH
23199: LD_OWVAR 2
23203: PUSH
23204: EMPTY
23205: LIST
23206: LIST
23207: PUSH
23208: LD_INT 91
23210: PUSH
23211: LD_VAR 0 3
23215: PUSH
23216: LD_INT 30
23218: PUSH
23219: EMPTY
23220: LIST
23221: LIST
23222: LIST
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: PPUSH
23228: CALL_OW 69
23232: PPUSH
23233: LD_VAR 0 3
23237: PPUSH
23238: CALL_OW 74
23242: PPUSH
23243: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
23247: LD_VAR 0 2
23251: PUSH
23252: LD_INT 60
23254: GREATER
23255: PUSH
23256: LD_VAR 0 3
23260: PPUSH
23261: CALL_OW 301
23265: OR
23266: IFFALSE 23143
// if un then
23268: LD_VAR 0 3
23272: IFFALSE 23283
// RemoveUnit ( un ) ;
23274: LD_VAR 0 3
23278: PPUSH
23279: CALL_OW 64
// end ; end_of_file
23283: PPOPN 3
23285: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
23286: LD_INT 0
23288: PPUSH
23289: PPUSH
23290: PPUSH
23291: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
23292: LD_VAR 0 1
23296: PPUSH
23297: CALL_OW 264
23301: PUSH
23302: LD_EXP 36
23306: EQUAL
23307: IFFALSE 23379
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
23309: LD_INT 68
23311: PPUSH
23312: LD_VAR 0 1
23316: PPUSH
23317: CALL_OW 255
23321: PPUSH
23322: CALL_OW 321
23326: PUSH
23327: LD_INT 2
23329: EQUAL
23330: IFFALSE 23342
// eff := 70 else
23332: LD_ADDR_VAR 0 4
23336: PUSH
23337: LD_INT 70
23339: ST_TO_ADDR
23340: GO 23350
// eff := 30 ;
23342: LD_ADDR_VAR 0 4
23346: PUSH
23347: LD_INT 30
23349: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
23350: LD_VAR 0 1
23354: PPUSH
23355: CALL_OW 250
23359: PPUSH
23360: LD_VAR 0 1
23364: PPUSH
23365: CALL_OW 251
23369: PPUSH
23370: LD_VAR 0 4
23374: PPUSH
23375: CALL_OW 495
// end ; end ;
23379: LD_VAR 0 2
23383: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
23384: LD_INT 0
23386: PPUSH
// end ;
23387: LD_VAR 0 4
23391: RET
// export function SOS_Command ( cmd ) ; begin
23392: LD_INT 0
23394: PPUSH
// end ;
23395: LD_VAR 0 2
23399: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
23400: LD_VAR 0 1
23404: PUSH
23405: LD_INT 255
23407: EQUAL
23408: PUSH
23409: LD_VAR 0 2
23413: PPUSH
23414: CALL_OW 264
23418: PUSH
23419: LD_INT 14
23421: PUSH
23422: LD_INT 53
23424: PUSH
23425: EMPTY
23426: LIST
23427: LIST
23428: IN
23429: AND
23430: PUSH
23431: LD_VAR 0 4
23435: PPUSH
23436: LD_VAR 0 5
23440: PPUSH
23441: CALL_OW 488
23445: AND
23446: IFFALSE 23470
// CutTreeXYR ( unit , x , y , 12 ) ;
23448: LD_VAR 0 2
23452: PPUSH
23453: LD_VAR 0 4
23457: PPUSH
23458: LD_VAR 0 5
23462: PPUSH
23463: LD_INT 12
23465: PPUSH
23466: CALL 23473 0 4
// end ;
23470: PPOPN 5
23472: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
23473: LD_INT 0
23475: PPUSH
23476: PPUSH
23477: PPUSH
23478: PPUSH
23479: PPUSH
23480: PPUSH
23481: PPUSH
23482: PPUSH
23483: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
23484: LD_VAR 0 1
23488: NOT
23489: PUSH
23490: LD_VAR 0 2
23494: PPUSH
23495: LD_VAR 0 3
23499: PPUSH
23500: CALL_OW 488
23504: NOT
23505: OR
23506: PUSH
23507: LD_VAR 0 4
23511: NOT
23512: OR
23513: IFFALSE 23517
// exit ;
23515: GO 23857
// list := [ ] ;
23517: LD_ADDR_VAR 0 13
23521: PUSH
23522: EMPTY
23523: ST_TO_ADDR
// if x - r < 0 then
23524: LD_VAR 0 2
23528: PUSH
23529: LD_VAR 0 4
23533: MINUS
23534: PUSH
23535: LD_INT 0
23537: LESS
23538: IFFALSE 23550
// min_x := 0 else
23540: LD_ADDR_VAR 0 7
23544: PUSH
23545: LD_INT 0
23547: ST_TO_ADDR
23548: GO 23566
// min_x := x - r ;
23550: LD_ADDR_VAR 0 7
23554: PUSH
23555: LD_VAR 0 2
23559: PUSH
23560: LD_VAR 0 4
23564: MINUS
23565: ST_TO_ADDR
// if y - r < 0 then
23566: LD_VAR 0 3
23570: PUSH
23571: LD_VAR 0 4
23575: MINUS
23576: PUSH
23577: LD_INT 0
23579: LESS
23580: IFFALSE 23592
// min_y := 0 else
23582: LD_ADDR_VAR 0 8
23586: PUSH
23587: LD_INT 0
23589: ST_TO_ADDR
23590: GO 23608
// min_y := y - r ;
23592: LD_ADDR_VAR 0 8
23596: PUSH
23597: LD_VAR 0 3
23601: PUSH
23602: LD_VAR 0 4
23606: MINUS
23607: ST_TO_ADDR
// max_x := x + r ;
23608: LD_ADDR_VAR 0 9
23612: PUSH
23613: LD_VAR 0 2
23617: PUSH
23618: LD_VAR 0 4
23622: PLUS
23623: ST_TO_ADDR
// max_y := y + r ;
23624: LD_ADDR_VAR 0 10
23628: PUSH
23629: LD_VAR 0 3
23633: PUSH
23634: LD_VAR 0 4
23638: PLUS
23639: ST_TO_ADDR
// for _x = min_x to max_x do
23640: LD_ADDR_VAR 0 11
23644: PUSH
23645: DOUBLE
23646: LD_VAR 0 7
23650: DEC
23651: ST_TO_ADDR
23652: LD_VAR 0 9
23656: PUSH
23657: FOR_TO
23658: IFFALSE 23775
// for _y = min_y to max_y do
23660: LD_ADDR_VAR 0 12
23664: PUSH
23665: DOUBLE
23666: LD_VAR 0 8
23670: DEC
23671: ST_TO_ADDR
23672: LD_VAR 0 10
23676: PUSH
23677: FOR_TO
23678: IFFALSE 23771
// begin if not ValidHex ( _x , _y ) then
23680: LD_VAR 0 11
23684: PPUSH
23685: LD_VAR 0 12
23689: PPUSH
23690: CALL_OW 488
23694: NOT
23695: IFFALSE 23699
// continue ;
23697: GO 23677
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
23699: LD_VAR 0 11
23703: PPUSH
23704: LD_VAR 0 12
23708: PPUSH
23709: CALL_OW 351
23713: PUSH
23714: LD_VAR 0 11
23718: PPUSH
23719: LD_VAR 0 12
23723: PPUSH
23724: CALL_OW 554
23728: AND
23729: IFFALSE 23769
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
23731: LD_ADDR_VAR 0 13
23735: PUSH
23736: LD_VAR 0 13
23740: PPUSH
23741: LD_VAR 0 13
23745: PUSH
23746: LD_INT 1
23748: PLUS
23749: PPUSH
23750: LD_VAR 0 11
23754: PUSH
23755: LD_VAR 0 12
23759: PUSH
23760: EMPTY
23761: LIST
23762: LIST
23763: PPUSH
23764: CALL_OW 2
23768: ST_TO_ADDR
// end ;
23769: GO 23677
23771: POP
23772: POP
23773: GO 23657
23775: POP
23776: POP
// if not list then
23777: LD_VAR 0 13
23781: NOT
23782: IFFALSE 23786
// exit ;
23784: GO 23857
// for i in list do
23786: LD_ADDR_VAR 0 6
23790: PUSH
23791: LD_VAR 0 13
23795: PUSH
23796: FOR_IN
23797: IFFALSE 23855
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
23799: LD_VAR 0 1
23803: PPUSH
23804: LD_STRING M
23806: PUSH
23807: LD_VAR 0 6
23811: PUSH
23812: LD_INT 1
23814: ARRAY
23815: PUSH
23816: LD_VAR 0 6
23820: PUSH
23821: LD_INT 2
23823: ARRAY
23824: PUSH
23825: LD_INT 0
23827: PUSH
23828: LD_INT 0
23830: PUSH
23831: LD_INT 0
23833: PUSH
23834: LD_INT 0
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: LIST
23841: LIST
23842: LIST
23843: LIST
23844: LIST
23845: PUSH
23846: EMPTY
23847: LIST
23848: PPUSH
23849: CALL_OW 447
23853: GO 23796
23855: POP
23856: POP
// end ;
23857: LD_VAR 0 5
23861: RET
