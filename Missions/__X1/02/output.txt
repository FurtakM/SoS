// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 596 0 0
// PrepareAmericans ;
  23: CALL 893 0 0
// PrepareArabian ;
  27: CALL 11081 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 214 0 0
// Action ;
  41: CALL 4703 0 0
// end ;
  45: END
// export debug , prefix , missionStart , aviradzeSpotted , deltaSpotted , spottedBeforeRadio , sciSpotted , aviradzeQuestDone , sciCounterKill , usAlert , usActiveDefend , gladstoneEscaped , timeUntilFarmer , attackDeltaAllowed , trickyMove , usPatrol , trap , lostCounter ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := false ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// aviradzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 7
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 9
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// aviradzeQuestDone := false ;
  97: LD_ADDR_EXP 8
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// attackDeltaAllowed := false ;
 105: LD_ADDR_EXP 14
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// usAlert := false ;
 113: LD_ADDR_EXP 10
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// usActiveDefend := false ;
 121: LD_ADDR_EXP 11
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// usPatrol := [ ] ;
 129: LD_ADDR_EXP 16
 133: PUSH
 134: EMPTY
 135: ST_TO_ADDR
// timeUntilFarmer := [ 40 40$00 , 30 30$00 , 20 20$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 13
 140: PUSH
 141: LD_INT 84000
 143: PUSH
 144: LD_INT 63000
 146: PUSH
 147: LD_INT 42000
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// trickyMove := false ;
 161: LD_ADDR_EXP 15
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// gladstoneEscaped := false ;
 169: LD_ADDR_EXP 12
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// prefix := 01_ ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 01_
 184: ST_TO_ADDR
// trap := 0 ;
 185: LD_ADDR_EXP 17
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// lostCounter := false ;
 193: LD_ADDR_EXP 18
 197: PUSH
 198: LD_INT 0
 200: ST_TO_ADDR
// spottedBeforeRadio := false ;
 201: LD_ADDR_EXP 6
 205: PUSH
 206: LD_INT 0
 208: ST_TO_ADDR
// end ;
 209: LD_VAR 0 1
 213: RET
// function DebugMode ; begin
 214: LD_INT 0
 216: PPUSH
// FogOff ( 1 ) ;
 217: LD_INT 1
 219: PPUSH
 220: CALL_OW 344
// Difficulty := 2 ;
 224: LD_ADDR_OWVAR 67
 228: PUSH
 229: LD_INT 2
 231: ST_TO_ADDR
// end ; end_of_file
 232: LD_VAR 0 1
 236: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 237: LD_INT 0
 239: PPUSH
 240: PPUSH
// if exist_mode then
 241: LD_VAR 0 2
 245: IFFALSE 270
// unit := CreateCharacter ( prefix & ident ) else
 247: LD_ADDR_VAR 0 5
 251: PUSH
 252: LD_VAR 0 3
 256: PUSH
 257: LD_VAR 0 1
 261: STR
 262: PPUSH
 263: CALL_OW 34
 267: ST_TO_ADDR
 268: GO 285
// unit := NewCharacter ( ident ) ;
 270: LD_ADDR_VAR 0 5
 274: PUSH
 275: LD_VAR 0 1
 279: PPUSH
 280: CALL_OW 25
 284: ST_TO_ADDR
// result := unit ;
 285: LD_ADDR_VAR 0 4
 289: PUSH
 290: LD_VAR 0 5
 294: ST_TO_ADDR
// end ;
 295: LD_VAR 0 4
 299: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 300: LD_INT 0
 302: PPUSH
// uc_side := side ;
 303: LD_ADDR_OWVAR 20
 307: PUSH
 308: LD_VAR 0 1
 312: ST_TO_ADDR
// uc_nation := nation ;
 313: LD_ADDR_OWVAR 21
 317: PUSH
 318: LD_VAR 0 2
 322: ST_TO_ADDR
// vc_chassis := chassis ;
 323: LD_ADDR_OWVAR 37
 327: PUSH
 328: LD_VAR 0 3
 332: ST_TO_ADDR
// vc_engine := engine ;
 333: LD_ADDR_OWVAR 39
 337: PUSH
 338: LD_VAR 0 4
 342: ST_TO_ADDR
// vc_control := control ;
 343: LD_ADDR_OWVAR 38
 347: PUSH
 348: LD_VAR 0 5
 352: ST_TO_ADDR
// vc_weapon := weapon ;
 353: LD_ADDR_OWVAR 40
 357: PUSH
 358: LD_VAR 0 6
 362: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 363: LD_ADDR_OWVAR 41
 367: PUSH
 368: LD_VAR 0 7
 372: ST_TO_ADDR
// result := CreateVehicle ;
 373: LD_ADDR_VAR 0 8
 377: PUSH
 378: CALL_OW 45
 382: ST_TO_ADDR
// end ;
 383: LD_VAR 0 8
 387: RET
// export function SayX ( units , ident ) ; var i ; begin
 388: LD_INT 0
 390: PPUSH
 391: PPUSH
// result := false ;
 392: LD_ADDR_VAR 0 3
 396: PUSH
 397: LD_INT 0
 399: ST_TO_ADDR
// if not units then
 400: LD_VAR 0 1
 404: NOT
 405: IFFALSE 409
// exit ;
 407: GO 463
// for i in units do
 409: LD_ADDR_VAR 0 4
 413: PUSH
 414: LD_VAR 0 1
 418: PUSH
 419: FOR_IN
 420: IFFALSE 461
// if IsOk ( i ) then
 422: LD_VAR 0 4
 426: PPUSH
 427: CALL_OW 302
 431: IFFALSE 459
// begin Say ( i , ident ) ;
 433: LD_VAR 0 4
 437: PPUSH
 438: LD_VAR 0 2
 442: PPUSH
 443: CALL_OW 88
// result := i ;
 447: LD_ADDR_VAR 0 3
 451: PUSH
 452: LD_VAR 0 4
 456: ST_TO_ADDR
// break ;
 457: GO 461
// end ;
 459: GO 419
 461: POP
 462: POP
// end ;
 463: LD_VAR 0 3
 467: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 468: LD_INT 0
 470: PPUSH
 471: PPUSH
// InitUc ;
 472: CALL_OW 18
// InitHc ;
 476: CALL_OW 19
// uc_side := 0 ;
 480: LD_ADDR_OWVAR 20
 484: PUSH
 485: LD_INT 0
 487: ST_TO_ADDR
// uc_nation := 0 ;
 488: LD_ADDR_OWVAR 21
 492: PUSH
 493: LD_INT 0
 495: ST_TO_ADDR
// for i = 1 to amount do
 496: LD_ADDR_VAR 0 4
 500: PUSH
 501: DOUBLE
 502: LD_INT 1
 504: DEC
 505: ST_TO_ADDR
 506: LD_VAR 0 2
 510: PUSH
 511: FOR_TO
 512: IFFALSE 585
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 514: LD_ADDR_OWVAR 29
 518: PUSH
 519: LD_INT 9
 521: PPUSH
 522: LD_INT 12
 524: PPUSH
 525: CALL_OW 12
 529: PUSH
 530: LD_INT 9
 532: PPUSH
 533: LD_INT 12
 535: PPUSH
 536: CALL_OW 12
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: ST_TO_ADDR
// hc_agressivity := 0 ;
 545: LD_ADDR_OWVAR 35
 549: PUSH
 550: LD_INT 0
 552: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 553: LD_INT 0
 555: PPUSH
 556: LD_INT 12
 558: PPUSH
 559: LD_INT 1
 561: PPUSH
 562: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 566: CALL_OW 44
 570: PPUSH
 571: LD_VAR 0 1
 575: PPUSH
 576: LD_INT 0
 578: PPUSH
 579: CALL_OW 49
// end ;
 583: GO 511
 585: POP
 586: POP
// InitHc ;
 587: CALL_OW 19
// end ;
 591: LD_VAR 0 3
 595: RET
// export function PrepareNature ; var i ; begin
 596: LD_INT 0
 598: PPUSH
 599: PPUSH
// SpawnApeman ( forest , 9 ) ;
 600: LD_INT 1
 602: PPUSH
 603: LD_INT 9
 605: PPUSH
 606: CALL 468 0 2
// for i := 1 to 4 do
 610: LD_ADDR_VAR 0 2
 614: PUSH
 615: DOUBLE
 616: LD_INT 1
 618: DEC
 619: ST_TO_ADDR
 620: LD_INT 4
 622: PUSH
 623: FOR_TO
 624: IFFALSE 659
// begin hc_class := 21 ;
 626: LD_ADDR_OWVAR 28
 630: PUSH
 631: LD_INT 21
 633: ST_TO_ADDR
// hc_gallery :=  ;
 634: LD_ADDR_OWVAR 33
 638: PUSH
 639: LD_STRING 
 641: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 642: CALL_OW 44
 646: PPUSH
 647: LD_INT 1
 649: PPUSH
 650: LD_INT 0
 652: PPUSH
 653: CALL_OW 49
// end ;
 657: GO 623
 659: POP
 660: POP
// for i := 1 to 2 do
 661: LD_ADDR_VAR 0 2
 665: PUSH
 666: DOUBLE
 667: LD_INT 1
 669: DEC
 670: ST_TO_ADDR
 671: LD_INT 2
 673: PUSH
 674: FOR_TO
 675: IFFALSE 710
// begin hc_class := 18 ;
 677: LD_ADDR_OWVAR 28
 681: PUSH
 682: LD_INT 18
 684: ST_TO_ADDR
// hc_gallery :=  ;
 685: LD_ADDR_OWVAR 33
 689: PUSH
 690: LD_STRING 
 692: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 693: CALL_OW 44
 697: PPUSH
 698: LD_INT 1
 700: PPUSH
 701: LD_INT 0
 703: PPUSH
 704: CALL_OW 49
// end ;
 708: GO 674
 710: POP
 711: POP
// for i := 1 to 3 do
 712: LD_ADDR_VAR 0 2
 716: PUSH
 717: DOUBLE
 718: LD_INT 1
 720: DEC
 721: ST_TO_ADDR
 722: LD_INT 3
 724: PUSH
 725: FOR_TO
 726: IFFALSE 761
// begin hc_class := 13 ;
 728: LD_ADDR_OWVAR 28
 732: PUSH
 733: LD_INT 13
 735: ST_TO_ADDR
// hc_gallery :=  ;
 736: LD_ADDR_OWVAR 33
 740: PUSH
 741: LD_STRING 
 743: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 744: CALL_OW 44
 748: PPUSH
 749: LD_INT 1
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL_OW 49
// end ;
 759: GO 725
 761: POP
 762: POP
// for i := 1 to 4 do
 763: LD_ADDR_VAR 0 2
 767: PUSH
 768: DOUBLE
 769: LD_INT 1
 771: DEC
 772: ST_TO_ADDR
 773: LD_INT 4
 775: PUSH
 776: FOR_TO
 777: IFFALSE 812
// begin hc_class := class_frog ;
 779: LD_ADDR_OWVAR 28
 783: PUSH
 784: LD_INT 19
 786: ST_TO_ADDR
// hc_gallery :=  ;
 787: LD_ADDR_OWVAR 33
 791: PUSH
 792: LD_STRING 
 794: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , swampArea , false ) ;
 795: CALL_OW 44
 799: PPUSH
 800: LD_INT 8
 802: PPUSH
 803: LD_INT 0
 805: PPUSH
 806: CALL_OW 49
// end ;
 810: GO 776
 812: POP
 813: POP
// end ;
 814: LD_VAR 0 1
 818: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 819: LD_INT 0
 821: PPUSH
 822: PPUSH
 823: PPUSH
// if not observer or not unit then
 824: LD_VAR 0 1
 828: NOT
 829: PUSH
 830: LD_VAR 0 2
 834: NOT
 835: OR
 836: IFFALSE 840
// exit ;
 838: GO 888
// if not See ( GetSide ( observer ) , unit ) then
 840: LD_VAR 0 1
 844: PPUSH
 845: CALL_OW 255
 849: PPUSH
 850: LD_VAR 0 2
 854: PPUSH
 855: CALL_OW 292
 859: NOT
 860: IFFALSE 864
// exit ;
 862: GO 888
// result := GetDistUnits ( observer , unit ) < 12 ;
 864: LD_ADDR_VAR 0 3
 868: PUSH
 869: LD_VAR 0 1
 873: PPUSH
 874: LD_VAR 0 2
 878: PPUSH
 879: CALL_OW 296
 883: PUSH
 884: LD_INT 12
 886: LESS
 887: ST_TO_ADDR
// end ; end_of_file
 888: LD_VAR 0 3
 892: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp , arm ; begin
 893: LD_INT 0
 895: PPUSH
 896: PPUSH
 897: PPUSH
 898: PPUSH
 899: PPUSH
 900: PPUSH
// usForces := [ ] ;
 901: LD_ADDR_EXP 21
 905: PUSH
 906: EMPTY
 907: ST_TO_ADDR
// usSci := [ ] ;
 908: LD_ADDR_EXP 22
 912: PUSH
 913: EMPTY
 914: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 915: LD_INT 1
 917: PPUSH
 918: LD_STRING Delta
 920: PPUSH
 921: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 925: LD_INT 1
 927: PPUSH
 928: CALL_OW 274
 932: PPUSH
 933: LD_INT 1
 935: PPUSH
 936: LD_INT 400
 938: PPUSH
 939: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 943: LD_INT 1
 945: PPUSH
 946: CALL_OW 274
 950: PPUSH
 951: LD_INT 2
 953: PPUSH
 954: LD_INT 80
 956: PPUSH
 957: CALL_OW 277
// uc_side := 1 ;
 961: LD_ADDR_OWVAR 20
 965: PUSH
 966: LD_INT 1
 968: ST_TO_ADDR
// uc_nation := 1 ;
 969: LD_ADDR_OWVAR 21
 973: PUSH
 974: LD_INT 1
 976: ST_TO_ADDR
// InitHc ;
 977: CALL_OW 19
// hc_importance := 0 ;
 981: LD_ADDR_OWVAR 32
 985: PUSH
 986: LD_INT 0
 988: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 989: LD_ADDR_EXP 20
 993: PUSH
 994: LD_STRING Lynch
 996: PPUSH
 997: LD_INT 0
 999: PPUSH
1000: LD_STRING 
1002: PPUSH
1003: CALL 237 0 3
1007: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
1008: LD_ADDR_EXP 19
1012: PUSH
1013: LD_STRING Gladstone
1015: PPUSH
1016: LD_INT 0
1018: PPUSH
1019: LD_STRING 
1021: PPUSH
1022: CALL 237 0 3
1026: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
1027: LD_EXP 20
1031: PPUSH
1032: LD_INT 1
1034: PPUSH
1035: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
1039: LD_EXP 19
1043: PPUSH
1044: LD_INT 3
1046: PPUSH
1047: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
1051: LD_ADDR_VAR 0 2
1055: PUSH
1056: DOUBLE
1057: LD_INT 1
1059: DEC
1060: ST_TO_ADDR
1061: LD_INT 1
1063: PUSH
1064: LD_INT 2
1066: PUSH
1067: LD_INT 2
1069: PUSH
1070: EMPTY
1071: LIST
1072: LIST
1073: LIST
1074: PUSH
1075: LD_OWVAR 67
1079: ARRAY
1080: PUSH
1081: FOR_TO
1082: IFFALSE 1128
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1084: LD_INT 0
1086: PPUSH
1087: LD_INT 2
1089: PPUSH
1090: LD_INT 1
1092: PUSH
1093: LD_INT 2
1095: PUSH
1096: LD_INT 2
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: PUSH
1104: LD_OWVAR 67
1108: ARRAY
1109: PPUSH
1110: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
1114: CALL_OW 44
1118: PPUSH
1119: LD_INT 1
1121: PPUSH
1122: CALL_OW 52
// end ;
1126: GO 1081
1128: POP
1129: POP
// for i := 1 to 7 - Difficulty do
1130: LD_ADDR_VAR 0 2
1134: PUSH
1135: DOUBLE
1136: LD_INT 1
1138: DEC
1139: ST_TO_ADDR
1140: LD_INT 7
1142: PUSH
1143: LD_OWVAR 67
1147: MINUS
1148: PUSH
1149: FOR_TO
1150: IFFALSE 1235
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1152: LD_INT 0
1154: PPUSH
1155: LD_INT 4
1157: PPUSH
1158: LD_INT 1
1160: PUSH
1161: LD_INT 2
1163: PUSH
1164: LD_INT 2
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: LD_OWVAR 67
1176: ARRAY
1177: PPUSH
1178: CALL_OW 380
// un := CreateHuman ;
1182: LD_ADDR_VAR 0 3
1186: PUSH
1187: CALL_OW 44
1191: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
1192: LD_VAR 0 3
1196: PPUSH
1197: LD_INT 3
1199: PPUSH
1200: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
1204: LD_ADDR_EXP 22
1208: PUSH
1209: LD_EXP 22
1213: PPUSH
1214: LD_EXP 22
1218: PUSH
1219: LD_INT 1
1221: PLUS
1222: PPUSH
1223: LD_VAR 0 3
1227: PPUSH
1228: CALL_OW 1
1232: ST_TO_ADDR
// end ;
1233: GO 1149
1235: POP
1236: POP
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
1237: LD_ADDR_VAR 0 6
1241: PUSH
1242: LD_INT 22
1244: PUSH
1245: LD_INT 1
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 30
1254: PUSH
1255: LD_INT 4
1257: PUSH
1258: EMPTY
1259: LIST
1260: LIST
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL_OW 69
1270: ST_TO_ADDR
// for i := 1 to 3 + Difficulty do
1271: LD_ADDR_VAR 0 2
1275: PUSH
1276: DOUBLE
1277: LD_INT 1
1279: DEC
1280: ST_TO_ADDR
1281: LD_INT 3
1283: PUSH
1284: LD_OWVAR 67
1288: PLUS
1289: PUSH
1290: FOR_TO
1291: IFFALSE 1369
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1293: LD_INT 0
1295: PPUSH
1296: LD_INT 1
1298: PPUSH
1299: LD_INT 1
1301: PUSH
1302: LD_INT 2
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: EMPTY
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: LD_OWVAR 67
1317: ARRAY
1318: PPUSH
1319: CALL_OW 380
// un := CreateHuman ;
1323: LD_ADDR_VAR 0 3
1327: PUSH
1328: CALL_OW 44
1332: ST_TO_ADDR
// usForces := usForces ^ un ;
1333: LD_ADDR_EXP 21
1337: PUSH
1338: LD_EXP 21
1342: PUSH
1343: LD_VAR 0 3
1347: ADD
1348: ST_TO_ADDR
// PlaceHumanInUnit ( un , arm [ 1 ] ) ;
1349: LD_VAR 0 3
1353: PPUSH
1354: LD_VAR 0 6
1358: PUSH
1359: LD_INT 1
1361: ARRAY
1362: PPUSH
1363: CALL_OW 52
// end ;
1367: GO 1290
1369: POP
1370: POP
// if Difficulty > 1 then
1371: LD_OWVAR 67
1375: PUSH
1376: LD_INT 1
1378: GREATER
1379: IFFALSE 1472
// begin for i := 1 to 3 do
1381: LD_ADDR_VAR 0 2
1385: PUSH
1386: DOUBLE
1387: LD_INT 1
1389: DEC
1390: ST_TO_ADDR
1391: LD_INT 3
1393: PUSH
1394: FOR_TO
1395: IFFALSE 1470
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1397: LD_INT 0
1399: PPUSH
1400: LD_INT 1
1402: PPUSH
1403: LD_INT 1
1405: PUSH
1406: LD_INT 2
1408: PUSH
1409: LD_INT 3
1411: PUSH
1412: EMPTY
1413: LIST
1414: LIST
1415: LIST
1416: PUSH
1417: LD_OWVAR 67
1421: ARRAY
1422: PPUSH
1423: CALL_OW 380
// un := CreateHuman ;
1427: LD_ADDR_VAR 0 3
1431: PUSH
1432: CALL_OW 44
1436: ST_TO_ADDR
// usForces := usForces ^ un ;
1437: LD_ADDR_EXP 21
1441: PUSH
1442: LD_EXP 21
1446: PUSH
1447: LD_VAR 0 3
1451: ADD
1452: ST_TO_ADDR
// PlaceUnitArea ( un , usAdditionalDefenceArea , false ) ;
1453: LD_VAR 0 3
1457: PPUSH
1458: LD_INT 9
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// end ;
1468: GO 1394
1470: POP
1471: POP
// end ; PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1472: LD_INT 1
1474: PPUSH
1475: LD_INT 1
1477: PPUSH
1478: LD_INT 1
1480: PPUSH
1481: LD_INT 2
1483: PPUSH
1484: LD_INT 1
1486: PPUSH
1487: LD_INT 2
1489: PPUSH
1490: LD_INT 100
1492: PPUSH
1493: CALL 300 0 7
// veh := CreateVehicle ;
1497: LD_ADDR_VAR 0 4
1501: PUSH
1502: CALL_OW 45
1506: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1507: LD_VAR 0 4
1511: PPUSH
1512: LD_INT 2
1514: PPUSH
1515: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 24 , false ) ;
1519: LD_VAR 0 4
1523: PPUSH
1524: LD_INT 43
1526: PPUSH
1527: LD_INT 24
1529: PPUSH
1530: LD_INT 0
1532: PPUSH
1533: CALL_OW 48
// end ;
1537: LD_VAR 0 1
1541: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1542: LD_INT 0
1544: PPUSH
1545: PPUSH
1546: PPUSH
1547: PPUSH
1548: PPUSH
1549: PPUSH
// if not usSci then
1550: LD_EXP 22
1554: NOT
1555: IFFALSE 1559
// exit ;
1557: GO 1733
// xy := AreaToList ( tameArea , 0 ) ;
1559: LD_ADDR_VAR 0 6
1563: PUSH
1564: LD_INT 5
1566: PPUSH
1567: LD_INT 0
1569: PPUSH
1570: CALL_OW 517
1574: ST_TO_ADDR
// for i in usSci do
1575: LD_ADDR_VAR 0 2
1579: PUSH
1580: LD_EXP 22
1584: PUSH
1585: FOR_IN
1586: IFFALSE 1731
// begin k := rand ( 1 , xy [ 1 ] ) ;
1588: LD_ADDR_VAR 0 4
1592: PUSH
1593: LD_INT 1
1595: PPUSH
1596: LD_VAR 0 6
1600: PUSH
1601: LD_INT 1
1603: ARRAY
1604: PPUSH
1605: CALL_OW 12
1609: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1610: LD_VAR 0 2
1614: PPUSH
1615: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1619: LD_VAR 0 2
1623: PPUSH
1624: LD_VAR 0 6
1628: PUSH
1629: LD_INT 1
1631: ARRAY
1632: PUSH
1633: LD_VAR 0 4
1637: ARRAY
1638: PPUSH
1639: LD_VAR 0 6
1643: PUSH
1644: LD_INT 2
1646: ARRAY
1647: PUSH
1648: LD_VAR 0 4
1652: ARRAY
1653: PPUSH
1654: CALL_OW 171
// for j := 1 to 2 do
1658: LD_ADDR_VAR 0 3
1662: PUSH
1663: DOUBLE
1664: LD_INT 1
1666: DEC
1667: ST_TO_ADDR
1668: LD_INT 2
1670: PUSH
1671: FOR_TO
1672: IFFALSE 1727
// begin tmp := Delete ( xy [ j ] , k ) ;
1674: LD_ADDR_VAR 0 5
1678: PUSH
1679: LD_VAR 0 6
1683: PUSH
1684: LD_VAR 0 3
1688: ARRAY
1689: PPUSH
1690: LD_VAR 0 4
1694: PPUSH
1695: CALL_OW 3
1699: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1700: LD_ADDR_VAR 0 6
1704: PUSH
1705: LD_VAR 0 6
1709: PPUSH
1710: LD_VAR 0 3
1714: PPUSH
1715: LD_VAR 0 5
1719: PPUSH
1720: CALL_OW 1
1724: ST_TO_ADDR
// end ;
1725: GO 1671
1727: POP
1728: POP
// end ;
1729: GO 1585
1731: POP
1732: POP
// end ;
1733: LD_VAR 0 1
1737: RET
// every 0 0$5 + 0 0$10 trigger aviradzeSpotted and usSci and not usAlert and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1738: LD_EXP 4
1742: PUSH
1743: LD_EXP 22
1747: AND
1748: PUSH
1749: LD_EXP 10
1753: NOT
1754: AND
1755: PUSH
1756: LD_INT 22
1758: PUSH
1759: LD_INT 0
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: PUSH
1766: LD_INT 25
1768: PUSH
1769: LD_INT 12
1771: PUSH
1772: EMPTY
1773: LIST
1774: LIST
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: PPUSH
1780: CALL_OW 69
1784: AND
1785: IFFALSE 2277
1787: GO 1789
1789: DISABLE
1790: LD_INT 0
1792: PPUSH
1793: PPUSH
1794: PPUSH
1795: PPUSH
1796: PPUSH
// begin enable ;
1797: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1798: LD_EXP 22
1802: PPUSH
1803: LD_INT 2
1805: PUSH
1806: LD_INT 60
1808: PUSH
1809: EMPTY
1810: LIST
1811: PUSH
1812: LD_INT 54
1814: PUSH
1815: EMPTY
1816: LIST
1817: PUSH
1818: EMPTY
1819: LIST
1820: LIST
1821: LIST
1822: PPUSH
1823: CALL_OW 72
1827: IFFALSE 1831
// exit ;
1829: GO 2277
// for i in usSci do
1831: LD_ADDR_VAR 0 1
1835: PUSH
1836: LD_EXP 22
1840: PUSH
1841: FOR_IN
1842: IFFALSE 2275
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1844: LD_VAR 0 1
1848: PPUSH
1849: CALL_OW 314
1853: NOT
1854: PUSH
1855: LD_VAR 0 1
1859: PPUSH
1860: CALL_OW 256
1864: PUSH
1865: LD_INT 1000
1867: EQUAL
1868: AND
1869: IFFALSE 2076
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1871: LD_ADDR_VAR 0 5
1875: PUSH
1876: LD_INT 22
1878: PUSH
1879: LD_INT 0
1881: PUSH
1882: EMPTY
1883: LIST
1884: LIST
1885: PUSH
1886: LD_INT 25
1888: PUSH
1889: LD_INT 12
1891: PUSH
1892: EMPTY
1893: LIST
1894: LIST
1895: PUSH
1896: EMPTY
1897: LIST
1898: LIST
1899: PPUSH
1900: CALL_OW 69
1904: PPUSH
1905: LD_VAR 0 1
1909: PPUSH
1910: CALL_OW 74
1914: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1915: LD_VAR 0 1
1919: PPUSH
1920: LD_VAR 0 5
1924: PPUSH
1925: CALL_OW 296
1929: PUSH
1930: LD_INT 10
1932: LESS
1933: IFFALSE 1966
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1935: LD_VAR 0 1
1939: PPUSH
1940: LD_VAR 0 5
1944: PPUSH
1945: CALL_OW 250
1949: PPUSH
1950: LD_VAR 0 5
1954: PPUSH
1955: CALL_OW 251
1959: PPUSH
1960: CALL_OW 131
1964: GO 2076
// begin d := rand ( 0 , 5 ) ;
1966: LD_ADDR_VAR 0 4
1970: PUSH
1971: LD_INT 0
1973: PPUSH
1974: LD_INT 5
1976: PPUSH
1977: CALL_OW 12
1981: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1982: LD_ADDR_VAR 0 2
1986: PUSH
1987: LD_VAR 0 1
1991: PPUSH
1992: CALL_OW 250
1996: PPUSH
1997: LD_VAR 0 4
2001: PPUSH
2002: LD_INT 3
2004: PPUSH
2005: CALL_OW 272
2009: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
2010: LD_ADDR_VAR 0 3
2014: PUSH
2015: LD_VAR 0 1
2019: PPUSH
2020: CALL_OW 251
2024: PPUSH
2025: LD_VAR 0 4
2029: PPUSH
2030: LD_INT 3
2032: PPUSH
2033: CALL_OW 273
2037: ST_TO_ADDR
// if not ValidHex ( x , y ) then
2038: LD_VAR 0 2
2042: PPUSH
2043: LD_VAR 0 3
2047: PPUSH
2048: CALL_OW 488
2052: NOT
2053: IFFALSE 2057
// continue ;
2055: GO 1841
// ComMoveXY ( i , x , y ) ;
2057: LD_VAR 0 1
2061: PPUSH
2062: LD_VAR 0 2
2066: PPUSH
2067: LD_VAR 0 3
2071: PPUSH
2072: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
2076: LD_VAR 0 1
2080: PPUSH
2081: CALL_OW 256
2085: PUSH
2086: LD_INT 900
2088: LESS
2089: PUSH
2090: LD_VAR 0 1
2094: PPUSH
2095: LD_INT 37
2097: PPUSH
2098: LD_INT 23
2100: PPUSH
2101: CALL_OW 297
2105: PUSH
2106: LD_INT 10
2108: GREATER
2109: AND
2110: IFFALSE 2186
// begin if IsOk ( Gladstone ) and IsInUnit ( Gladstone ) then
2112: LD_EXP 19
2116: PPUSH
2117: CALL_OW 302
2121: PUSH
2122: LD_EXP 19
2126: PPUSH
2127: CALL_OW 310
2131: AND
2132: IFFALSE 2143
// ComExitBuilding ( Gladstone ) ;
2134: LD_EXP 19
2138: PPUSH
2139: CALL_OW 122
// AddComHeal ( Gladstone , i ) ;
2143: LD_EXP 19
2147: PPUSH
2148: LD_VAR 0 1
2152: PPUSH
2153: CALL_OW 188
// AddComEnterUnit ( Gladstone , usLab ) ;
2157: LD_EXP 19
2161: PPUSH
2162: LD_INT 3
2164: PPUSH
2165: CALL_OW 180
// ComMoveXY ( i , 37 , 23 ) ;
2169: LD_VAR 0 1
2173: PPUSH
2174: LD_INT 37
2176: PPUSH
2177: LD_INT 23
2179: PPUSH
2180: CALL_OW 111
// end else
2184: GO 2273
// if GetLives ( i ) = 1000 then
2186: LD_VAR 0 1
2190: PPUSH
2191: CALL_OW 256
2195: PUSH
2196: LD_INT 1000
2198: EQUAL
2199: IFFALSE 2273
// begin if SideShoot ( i ) = 2 then
2201: LD_VAR 0 1
2205: PPUSH
2206: CALL_OW 503
2210: PUSH
2211: LD_INT 2
2213: EQUAL
2214: IFFALSE 2261
// begin if not usAlert then
2216: LD_EXP 10
2220: NOT
2221: IFFALSE 2231
// usAlert := true ;
2223: LD_ADDR_EXP 10
2227: PUSH
2228: LD_INT 1
2230: ST_TO_ADDR
// AddComEnterUnit ( i , usLab ) ;
2231: LD_VAR 0 1
2235: PPUSH
2236: LD_INT 3
2238: PPUSH
2239: CALL_OW 180
// usSci := usSci diff i ;
2243: LD_ADDR_EXP 22
2247: PUSH
2248: LD_EXP 22
2252: PUSH
2253: LD_VAR 0 1
2257: DIFF
2258: ST_TO_ADDR
// end else
2259: GO 2273
// ComMoveToArea ( i , tameArea ) ;
2261: LD_VAR 0 1
2265: PPUSH
2266: LD_INT 5
2268: PPUSH
2269: CALL_OW 113
// end ; end ;
2273: GO 1841
2275: POP
2276: POP
// end ;
2277: PPOPN 5
2279: END
// every 0 0$1 trigger not usAlert and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 999 ] ] ] ) or FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) ) do
2280: LD_EXP 10
2284: NOT
2285: PUSH
2286: LD_INT 22
2288: PUSH
2289: LD_INT 1
2291: PUSH
2292: EMPTY
2293: LIST
2294: LIST
2295: PUSH
2296: LD_INT 21
2298: PUSH
2299: LD_INT 3
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PUSH
2306: LD_INT 3
2308: PUSH
2309: LD_INT 57
2311: PUSH
2312: EMPTY
2313: LIST
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PUSH
2319: LD_INT 3
2321: PUSH
2322: LD_INT 24
2324: PUSH
2325: LD_INT 999
2327: PUSH
2328: EMPTY
2329: LIST
2330: LIST
2331: PUSH
2332: EMPTY
2333: LIST
2334: LIST
2335: PUSH
2336: EMPTY
2337: LIST
2338: LIST
2339: LIST
2340: LIST
2341: PPUSH
2342: CALL_OW 69
2346: PUSH
2347: LD_INT 7
2349: PPUSH
2350: LD_INT 22
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: PPUSH
2360: CALL_OW 70
2364: OR
2365: AND
2366: IFFALSE 2379
2368: GO 2370
2370: DISABLE
// usAlert := true ;
2371: LD_ADDR_EXP 10
2375: PUSH
2376: LD_INT 1
2378: ST_TO_ADDR
2379: END
// every 0 0$1 trigger usAlert do var i , b , arm ;
2380: LD_EXP 10
2384: IFFALSE 2731
2386: GO 2388
2388: DISABLE
2389: LD_INT 0
2391: PPUSH
2392: PPUSH
2393: PPUSH
// begin usActiveDefend := true ;
2394: LD_ADDR_EXP 11
2398: PUSH
2399: LD_INT 1
2401: ST_TO_ADDR
// if not usForces then
2402: LD_EXP 21
2406: NOT
2407: IFFALSE 2411
// exit ;
2409: GO 2731
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
2411: LD_ADDR_VAR 0 3
2415: PUSH
2416: LD_INT 22
2418: PUSH
2419: LD_INT 1
2421: PUSH
2422: EMPTY
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 30
2428: PUSH
2429: LD_INT 4
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PUSH
2436: EMPTY
2437: LIST
2438: LIST
2439: PPUSH
2440: CALL_OW 69
2444: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_INT 22
2452: PUSH
2453: LD_INT 1
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: PUSH
2460: LD_INT 30
2462: PUSH
2463: LD_INT 31
2465: PUSH
2466: EMPTY
2467: LIST
2468: LIST
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: PPUSH
2474: CALL_OW 69
2478: ST_TO_ADDR
// ComExitBuilding ( Lynch ) ;
2479: LD_EXP 20
2483: PPUSH
2484: CALL_OW 122
// AddComEnterUnit ( Lynch , arm [ 1 ] ) ;
2488: LD_EXP 20
2492: PPUSH
2493: LD_VAR 0 3
2497: PUSH
2498: LD_INT 1
2500: ARRAY
2501: PPUSH
2502: CALL_OW 180
// if IsOk ( Gladstone ) then
2506: LD_EXP 19
2510: PPUSH
2511: CALL_OW 302
2515: IFFALSE 2556
// begin ComExitBuilding ( Gladstone ) ;
2517: LD_EXP 19
2521: PPUSH
2522: CALL_OW 122
// AddComEnterUnit ( Gladstone , arm [ 1 ] ) ;
2526: LD_EXP 19
2530: PPUSH
2531: LD_VAR 0 3
2535: PUSH
2536: LD_INT 1
2538: ARRAY
2539: PPUSH
2540: CALL_OW 180
// AddComChangeProfession ( Gladstone , class_soldier ) ;
2544: LD_EXP 19
2548: PPUSH
2549: LD_INT 1
2551: PPUSH
2552: CALL_OW 183
// end ; ComExitBuilding ( usForces [ 1 ] ) ;
2556: LD_EXP 21
2560: PUSH
2561: LD_INT 1
2563: ARRAY
2564: PPUSH
2565: CALL_OW 122
// AddComEnterUnit ( usForces [ 1 ] , b [ 1 ] ) ;
2569: LD_EXP 21
2573: PUSH
2574: LD_INT 1
2576: ARRAY
2577: PPUSH
2578: LD_VAR 0 2
2582: PUSH
2583: LD_INT 1
2585: ARRAY
2586: PPUSH
2587: CALL_OW 180
// ComExitBuilding ( usForces [ 2 ] ) ;
2591: LD_EXP 21
2595: PUSH
2596: LD_INT 2
2598: ARRAY
2599: PPUSH
2600: CALL_OW 122
// AddComEnterUnit ( usForces [ 2 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
2604: LD_EXP 21
2608: PUSH
2609: LD_INT 2
2611: ARRAY
2612: PPUSH
2613: LD_INT 22
2615: PUSH
2616: LD_INT 1
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: PUSH
2623: LD_INT 30
2625: PUSH
2626: LD_INT 32
2628: PUSH
2629: EMPTY
2630: LIST
2631: LIST
2632: PUSH
2633: EMPTY
2634: LIST
2635: LIST
2636: PPUSH
2637: CALL_OW 69
2641: PUSH
2642: LD_INT 1
2644: ARRAY
2645: PPUSH
2646: CALL_OW 180
// if b > 1 and usForces > 2 then
2650: LD_VAR 0 2
2654: PUSH
2655: LD_INT 1
2657: GREATER
2658: PUSH
2659: LD_EXP 21
2663: PUSH
2664: LD_INT 2
2666: GREATER
2667: AND
2668: IFFALSE 2731
// begin repeat wait ( 0 0$1 ) ;
2670: LD_INT 35
2672: PPUSH
2673: CALL_OW 67
// until BuildingStatus ( b [ 2 ] ) <> bs_build ;
2677: LD_VAR 0 2
2681: PUSH
2682: LD_INT 2
2684: ARRAY
2685: PPUSH
2686: CALL_OW 461
2690: PUSH
2691: LD_INT 1
2693: NONEQUAL
2694: IFFALSE 2670
// ComExitBuilding ( usForces [ 3 ] ) ;
2696: LD_EXP 21
2700: PUSH
2701: LD_INT 3
2703: ARRAY
2704: PPUSH
2705: CALL_OW 122
// AddComEnterUnit ( usForces [ 3 ] , b [ 2 ] ) ;
2709: LD_EXP 21
2713: PUSH
2714: LD_INT 3
2716: ARRAY
2717: PPUSH
2718: LD_VAR 0 2
2722: PUSH
2723: LD_INT 2
2725: ARRAY
2726: PPUSH
2727: CALL_OW 180
// end ; end ;
2731: PPOPN 3
2733: END
// every 0 0$1 trigger GetLives ( usLab ) < 999 and usAlert and usForces do var i ;
2734: LD_INT 3
2736: PPUSH
2737: CALL_OW 256
2741: PUSH
2742: LD_INT 999
2744: LESS
2745: PUSH
2746: LD_EXP 10
2750: AND
2751: PUSH
2752: LD_EXP 21
2756: AND
2757: IFFALSE 2928
2759: GO 2761
2761: DISABLE
2762: LD_INT 0
2764: PPUSH
// begin for i in usForces do
2765: LD_ADDR_VAR 0 1
2769: PUSH
2770: LD_EXP 21
2774: PUSH
2775: FOR_IN
2776: IFFALSE 2815
// begin if IsInUnit ( i ) then
2778: LD_VAR 0 1
2782: PPUSH
2783: CALL_OW 310
2787: IFFALSE 2798
// ComExitBuilding ( i ) ;
2789: LD_VAR 0 1
2793: PPUSH
2794: CALL_OW 122
// AddComAgressiveMove ( i , 31 , 8 ) ;
2798: LD_VAR 0 1
2802: PPUSH
2803: LD_INT 31
2805: PPUSH
2806: LD_INT 8
2808: PPUSH
2809: CALL_OW 174
// end ;
2813: GO 2775
2815: POP
2816: POP
// wait ( 0 0$8 ) ;
2817: LD_INT 280
2819: PPUSH
2820: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) then
2824: LD_INT 22
2826: PUSH
2827: LD_INT 2
2829: PUSH
2830: EMPTY
2831: LIST
2832: LIST
2833: PUSH
2834: LD_INT 91
2836: PUSH
2837: LD_INT 3
2839: PUSH
2840: LD_INT 14
2842: PUSH
2843: EMPTY
2844: LIST
2845: LIST
2846: LIST
2847: PUSH
2848: EMPTY
2849: LIST
2850: LIST
2851: PPUSH
2852: CALL_OW 69
2856: IFFALSE 2906
// ComAttackUnit ( usForces , FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) [ 1 ] ) else
2858: LD_EXP 21
2862: PPUSH
2863: LD_INT 22
2865: PUSH
2866: LD_INT 2
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: PUSH
2873: LD_INT 91
2875: PUSH
2876: LD_INT 3
2878: PUSH
2879: LD_INT 14
2881: PUSH
2882: EMPTY
2883: LIST
2884: LIST
2885: LIST
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: PPUSH
2891: CALL_OW 69
2895: PUSH
2896: LD_INT 1
2898: ARRAY
2899: PPUSH
2900: CALL_OW 115
2904: GO 2928
// begin wait ( 0 0$20 ) ;
2906: LD_INT 700
2908: PPUSH
2909: CALL_OW 67
// AddComMoveXY ( usForces , 39 , 19 ) ;
2913: LD_EXP 21
2917: PPUSH
2918: LD_INT 39
2920: PPUSH
2921: LD_INT 19
2923: PPUSH
2924: CALL_OW 171
// end ; end ;
2928: PPOPN 1
2930: END
// every 0 0$3 trigger ( GetDistUnits ( Heike , Delta ) < 10 or GetLives ( usLab ) < 999 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do var tmp , veh ;
2931: LD_EXP 23
2935: PPUSH
2936: LD_INT 1
2938: PPUSH
2939: CALL_OW 296
2943: PUSH
2944: LD_INT 10
2946: LESS
2947: PUSH
2948: LD_INT 3
2950: PPUSH
2951: CALL_OW 256
2955: PUSH
2956: LD_INT 999
2958: LESS
2959: OR
2960: PUSH
2961: LD_INT 22
2963: PUSH
2964: LD_INT 1
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: PUSH
2971: LD_INT 25
2973: PUSH
2974: LD_INT 2
2976: PUSH
2977: EMPTY
2978: LIST
2979: LIST
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: PPUSH
2985: CALL_OW 69
2989: AND
2990: IFFALSE 3104
2992: GO 2994
2994: DISABLE
2995: LD_INT 0
2997: PPUSH
2998: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
2999: LD_ADDR_VAR 0 1
3003: PUSH
3004: LD_INT 22
3006: PUSH
3007: LD_INT 1
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: PUSH
3014: LD_INT 25
3016: PUSH
3017: LD_INT 2
3019: PUSH
3020: EMPTY
3021: LIST
3022: LIST
3023: PUSH
3024: EMPTY
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL_OW 69
3032: ST_TO_ADDR
// veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
3033: LD_ADDR_VAR 0 2
3037: PUSH
3038: LD_INT 22
3040: PUSH
3041: LD_INT 1
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PUSH
3048: LD_INT 21
3050: PUSH
3051: LD_INT 2
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: PUSH
3058: LD_INT 58
3060: PUSH
3061: EMPTY
3062: LIST
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: PPUSH
3069: CALL_OW 69
3073: ST_TO_ADDR
// if not tmp then
3074: LD_VAR 0 1
3078: NOT
3079: IFFALSE 3083
// exit ;
3081: GO 3104
// ComExitBuilding ( tmp ) ;
3083: LD_VAR 0 1
3087: PPUSH
3088: CALL_OW 122
// AddComDismantle ( tmp , usLab ) ;
3092: LD_VAR 0 1
3096: PPUSH
3097: LD_INT 3
3099: PPUSH
3100: CALL_OW 227
// end ;
3104: PPOPN 2
3106: END
// every 0 0$1 trigger usAlert and FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) do var i , tmp ;
3107: LD_EXP 10
3111: PUSH
3112: LD_INT 7
3114: PPUSH
3115: LD_INT 22
3117: PUSH
3118: LD_INT 1
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: PUSH
3125: LD_INT 21
3127: PUSH
3128: LD_INT 1
3130: PUSH
3131: EMPTY
3132: LIST
3133: LIST
3134: PUSH
3135: LD_INT 3
3137: PUSH
3138: LD_INT 24
3140: PUSH
3141: LD_INT 600
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: PUSH
3152: EMPTY
3153: LIST
3154: LIST
3155: LIST
3156: PPUSH
3157: CALL_OW 70
3161: AND
3162: IFFALSE 3290
3164: GO 3166
3166: DISABLE
3167: LD_INT 0
3169: PPUSH
3170: PPUSH
// begin enable ;
3171: ENABLE
// tmp := FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) ;
3172: LD_ADDR_VAR 0 2
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 22
3182: PUSH
3183: LD_INT 1
3185: PUSH
3186: EMPTY
3187: LIST
3188: LIST
3189: PUSH
3190: LD_INT 21
3192: PUSH
3193: LD_INT 1
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: PUSH
3200: LD_INT 3
3202: PUSH
3203: LD_INT 24
3205: PUSH
3206: LD_INT 600
3208: PUSH
3209: EMPTY
3210: LIST
3211: LIST
3212: PUSH
3213: EMPTY
3214: LIST
3215: LIST
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: PPUSH
3222: CALL_OW 70
3226: ST_TO_ADDR
// if not tmp then
3227: LD_VAR 0 2
3231: NOT
3232: IFFALSE 3236
// exit ;
3234: GO 3290
// for i in tmp do
3236: LD_ADDR_VAR 0 1
3240: PUSH
3241: LD_VAR 0 2
3245: PUSH
3246: FOR_IN
3247: IFFALSE 3288
// if IsInUnit ( i ) then
3249: LD_VAR 0 1
3253: PPUSH
3254: CALL_OW 310
3258: IFFALSE 3271
// ComExitBuilding ( i ) else
3260: LD_VAR 0 1
3264: PPUSH
3265: CALL_OW 122
3269: GO 3286
// ComMoveXY ( i , 48 , 74 ) ;
3271: LD_VAR 0 1
3275: PPUSH
3276: LD_INT 48
3278: PPUSH
3279: LD_INT 74
3281: PPUSH
3282: CALL_OW 111
3286: GO 3246
3288: POP
3289: POP
// end ;
3290: PPOPN 2
3292: END
// every 6 6$00 do var i , un , tmp ;
3293: GO 3295
3295: DISABLE
3296: LD_INT 0
3298: PPUSH
3299: PPUSH
3300: PPUSH
// begin tmp := [ ] ;
3301: LD_ADDR_VAR 0 3
3305: PUSH
3306: EMPTY
3307: ST_TO_ADDR
// uc_side := 1 ;
3308: LD_ADDR_OWVAR 20
3312: PUSH
3313: LD_INT 1
3315: ST_TO_ADDR
// uc_nation := 1 ;
3316: LD_ADDR_OWVAR 21
3320: PUSH
3321: LD_INT 1
3323: ST_TO_ADDR
// case Difficulty of 1 :
3324: LD_OWVAR 67
3328: PUSH
3329: LD_INT 1
3331: DOUBLE
3332: EQUAL
3333: IFTRUE 3337
3335: GO 3440
3337: POP
// begin wait ( 1 1$00 ) ;
3338: LD_INT 2100
3340: PPUSH
3341: CALL_OW 67
// for i := 1 to 2 do
3345: LD_ADDR_VAR 0 1
3349: PUSH
3350: DOUBLE
3351: LD_INT 1
3353: DEC
3354: ST_TO_ADDR
3355: LD_INT 2
3357: PUSH
3358: FOR_TO
3359: IFFALSE 3436
// begin PrepareHuman ( false , [ 1 , 4 ] [ i mod 2 + 1 ] , 1 ) ;
3361: LD_INT 0
3363: PPUSH
3364: LD_INT 1
3366: PUSH
3367: LD_INT 4
3369: PUSH
3370: EMPTY
3371: LIST
3372: LIST
3373: PUSH
3374: LD_VAR 0 1
3378: PUSH
3379: LD_INT 2
3381: MOD
3382: PUSH
3383: LD_INT 1
3385: PLUS
3386: ARRAY
3387: PPUSH
3388: LD_INT 1
3390: PPUSH
3391: CALL_OW 380
// un := CreateHuman ;
3395: LD_ADDR_VAR 0 2
3399: PUSH
3400: CALL_OW 44
3404: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3405: LD_ADDR_VAR 0 3
3409: PUSH
3410: LD_VAR 0 3
3414: PPUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 1
3422: PLUS
3423: PPUSH
3424: LD_VAR 0 2
3428: PPUSH
3429: CALL_OW 1
3433: ST_TO_ADDR
// end ;
3434: GO 3358
3436: POP
3437: POP
// end ; 2 :
3438: GO 3834
3440: LD_INT 2
3442: DOUBLE
3443: EQUAL
3444: IFTRUE 3448
3446: GO 3582
3448: POP
// begin wait ( 0 0$30 ) ;
3449: LD_INT 1050
3451: PPUSH
3452: CALL_OW 67
// for i := 1 to 2 do
3456: LD_ADDR_VAR 0 1
3460: PUSH
3461: DOUBLE
3462: LD_INT 1
3464: DEC
3465: ST_TO_ADDR
3466: LD_INT 2
3468: PUSH
3469: FOR_TO
3470: IFFALSE 3526
// begin PrepareHuman ( false , 1 , 2 ) ;
3472: LD_INT 0
3474: PPUSH
3475: LD_INT 1
3477: PPUSH
3478: LD_INT 2
3480: PPUSH
3481: CALL_OW 380
// un := CreateHuman ;
3485: LD_ADDR_VAR 0 2
3489: PUSH
3490: CALL_OW 44
3494: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3495: LD_ADDR_VAR 0 3
3499: PUSH
3500: LD_VAR 0 3
3504: PPUSH
3505: LD_VAR 0 3
3509: PUSH
3510: LD_INT 1
3512: PLUS
3513: PPUSH
3514: LD_VAR 0 2
3518: PPUSH
3519: CALL_OW 1
3523: ST_TO_ADDR
// end ;
3524: GO 3469
3526: POP
3527: POP
// PrepareHuman ( false , 4 , 2 ) ;
3528: LD_INT 0
3530: PPUSH
3531: LD_INT 4
3533: PPUSH
3534: LD_INT 2
3536: PPUSH
3537: CALL_OW 380
// un := CreateHuman ;
3541: LD_ADDR_VAR 0 2
3545: PUSH
3546: CALL_OW 44
3550: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3551: LD_ADDR_VAR 0 3
3555: PUSH
3556: LD_VAR 0 3
3560: PPUSH
3561: LD_VAR 0 3
3565: PUSH
3566: LD_INT 1
3568: PLUS
3569: PPUSH
3570: LD_VAR 0 2
3574: PPUSH
3575: CALL_OW 1
3579: ST_TO_ADDR
// end ; 3 :
3580: GO 3834
3582: LD_INT 3
3584: DOUBLE
3585: EQUAL
3586: IFTRUE 3590
3588: GO 3833
3590: POP
// begin for i := 1 to 2 do
3591: LD_ADDR_VAR 0 1
3595: PUSH
3596: DOUBLE
3597: LD_INT 1
3599: DEC
3600: ST_TO_ADDR
3601: LD_INT 2
3603: PUSH
3604: FOR_TO
3605: IFFALSE 3661
// begin PrepareHuman ( false , 1 , 2 ) ;
3607: LD_INT 0
3609: PPUSH
3610: LD_INT 1
3612: PPUSH
3613: LD_INT 2
3615: PPUSH
3616: CALL_OW 380
// un := CreateHuman ;
3620: LD_ADDR_VAR 0 2
3624: PUSH
3625: CALL_OW 44
3629: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3630: LD_ADDR_VAR 0 3
3634: PUSH
3635: LD_VAR 0 3
3639: PPUSH
3640: LD_VAR 0 3
3644: PUSH
3645: LD_INT 1
3647: PLUS
3648: PPUSH
3649: LD_VAR 0 2
3653: PPUSH
3654: CALL_OW 1
3658: ST_TO_ADDR
// end ;
3659: GO 3604
3661: POP
3662: POP
// PrepareHuman ( false , 4 , 2 ) ;
3663: LD_INT 0
3665: PPUSH
3666: LD_INT 4
3668: PPUSH
3669: LD_INT 2
3671: PPUSH
3672: CALL_OW 380
// un := CreateHuman ;
3676: LD_ADDR_VAR 0 2
3680: PUSH
3681: CALL_OW 44
3685: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3686: LD_ADDR_VAR 0 3
3690: PUSH
3691: LD_VAR 0 3
3695: PPUSH
3696: LD_VAR 0 3
3700: PUSH
3701: LD_INT 1
3703: PLUS
3704: PPUSH
3705: LD_VAR 0 2
3709: PPUSH
3710: CALL_OW 1
3714: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_machine_gun , 90 ) ;
3715: LD_INT 1
3717: PPUSH
3718: LD_INT 1
3720: PPUSH
3721: LD_INT 2
3723: PPUSH
3724: LD_INT 2
3726: PPUSH
3727: LD_INT 1
3729: PPUSH
3730: LD_INT 2
3732: PPUSH
3733: LD_INT 90
3735: PPUSH
3736: CALL 300 0 7
// un := CreateVehicle ;
3740: LD_ADDR_VAR 0 2
3744: PUSH
3745: CALL_OW 45
3749: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3750: LD_ADDR_VAR 0 3
3754: PUSH
3755: LD_VAR 0 3
3759: PPUSH
3760: LD_VAR 0 3
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 2
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// PrepareHuman ( false , 1 , 2 ) ;
3779: LD_INT 0
3781: PPUSH
3782: LD_INT 1
3784: PPUSH
3785: LD_INT 2
3787: PPUSH
3788: CALL_OW 380
// un := CreateHuman ;
3792: LD_ADDR_VAR 0 2
3796: PUSH
3797: CALL_OW 44
3801: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3802: LD_ADDR_VAR 0 3
3806: PUSH
3807: LD_VAR 0 3
3811: PPUSH
3812: LD_VAR 0 3
3816: PUSH
3817: LD_INT 1
3819: PLUS
3820: PPUSH
3821: LD_VAR 0 2
3825: PPUSH
3826: CALL_OW 1
3830: ST_TO_ADDR
// end ; end ;
3831: GO 3834
3833: POP
// for i := 1 to tmp do
3834: LD_ADDR_VAR 0 1
3838: PUSH
3839: DOUBLE
3840: LD_INT 1
3842: DEC
3843: ST_TO_ADDR
3844: LD_VAR 0 3
3848: PUSH
3849: FOR_TO
3850: IFFALSE 4015
// begin SetDir ( tmp [ i ] , 1 ) ;
3852: LD_VAR 0 3
3856: PUSH
3857: LD_VAR 0 1
3861: ARRAY
3862: PPUSH
3863: LD_INT 1
3865: PPUSH
3866: CALL_OW 233
// if GetType ( tmp [ i ] ) = unit_human then
3870: LD_VAR 0 3
3874: PUSH
3875: LD_VAR 0 1
3879: ARRAY
3880: PPUSH
3881: CALL_OW 247
3885: PUSH
3886: LD_INT 1
3888: EQUAL
3889: IFFALSE 3917
// PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) else
3891: LD_VAR 0 3
3895: PUSH
3896: LD_VAR 0 1
3900: ARRAY
3901: PPUSH
3902: LD_INT 28
3904: PPUSH
3905: LD_INT 52
3907: PPUSH
3908: LD_INT 0
3910: PPUSH
3911: CALL_OW 48
3915: GO 3985
// begin PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) ;
3917: LD_VAR 0 3
3921: PUSH
3922: LD_VAR 0 1
3926: ARRAY
3927: PPUSH
3928: LD_INT 28
3930: PPUSH
3931: LD_INT 52
3933: PPUSH
3934: LD_INT 0
3936: PPUSH
3937: CALL_OW 48
// i := i + 1 ;
3941: LD_ADDR_VAR 0 1
3945: PUSH
3946: LD_VAR 0 1
3950: PUSH
3951: LD_INT 1
3953: PLUS
3954: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ i ] , tmp [ i - 1 ] ) ;
3955: LD_VAR 0 3
3959: PUSH
3960: LD_VAR 0 1
3964: ARRAY
3965: PPUSH
3966: LD_VAR 0 3
3970: PUSH
3971: LD_VAR 0 1
3975: PUSH
3976: LD_INT 1
3978: MINUS
3979: ARRAY
3980: PPUSH
3981: CALL_OW 52
// end ; ComMoveXY ( tmp [ i ] , 43 , 56 ) ;
3985: LD_VAR 0 3
3989: PUSH
3990: LD_VAR 0 1
3994: ARRAY
3995: PPUSH
3996: LD_INT 43
3998: PPUSH
3999: LD_INT 56
4001: PPUSH
4002: CALL_OW 111
// wait ( 0 0$2 ) ;
4006: LD_INT 70
4008: PPUSH
4009: CALL_OW 67
// end ;
4013: GO 3849
4015: POP
4016: POP
// wait ( 0 0$2 ) ;
4017: LD_INT 70
4019: PPUSH
4020: CALL_OW 67
// if not FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) then
4024: LD_INT 7
4026: PPUSH
4027: LD_INT 22
4029: PUSH
4030: LD_INT 2
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: PPUSH
4037: CALL_OW 70
4041: NOT
4042: IFFALSE 4240
// begin AddComAgressiveMove ( tmp , 35 , 24 ) ;
4044: LD_VAR 0 3
4048: PPUSH
4049: LD_INT 35
4051: PPUSH
4052: LD_INT 24
4054: PPUSH
4055: CALL_OW 174
// usForces := usForces union UnitFilter ( tmp , [ f_class , 1 ] ) ;
4059: LD_ADDR_EXP 21
4063: PUSH
4064: LD_EXP 21
4068: PUSH
4069: LD_VAR 0 3
4073: PPUSH
4074: LD_INT 25
4076: PUSH
4077: LD_INT 1
4079: PUSH
4080: EMPTY
4081: LIST
4082: LIST
4083: PPUSH
4084: CALL_OW 72
4088: UNION
4089: ST_TO_ADDR
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
4090: LD_INT 22
4092: PUSH
4093: LD_INT 1
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 30
4102: PUSH
4103: LD_INT 4
4105: PUSH
4106: EMPTY
4107: LIST
4108: LIST
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: PPUSH
4114: CALL_OW 69
4118: PUSH
4119: LD_INT 1
4121: ARRAY
4122: PPUSH
4123: CALL_OW 313
4127: PUSH
4128: LD_INT 6
4130: LESS
4131: IFFALSE 4190
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
4133: LD_VAR 0 3
4137: PPUSH
4138: LD_INT 25
4140: PUSH
4141: LD_INT 1
4143: PUSH
4144: EMPTY
4145: LIST
4146: LIST
4147: PPUSH
4148: CALL_OW 72
4152: PPUSH
4153: LD_INT 22
4155: PUSH
4156: LD_INT 1
4158: PUSH
4159: EMPTY
4160: LIST
4161: LIST
4162: PUSH
4163: LD_INT 30
4165: PUSH
4166: LD_INT 4
4168: PUSH
4169: EMPTY
4170: LIST
4171: LIST
4172: PUSH
4173: EMPTY
4174: LIST
4175: LIST
4176: PPUSH
4177: CALL_OW 69
4181: PUSH
4182: LD_INT 1
4184: ARRAY
4185: PPUSH
4186: CALL_OW 180
// if UnitFilter ( tmp , [ f_class , 4 ] ) then
4190: LD_VAR 0 3
4194: PPUSH
4195: LD_INT 25
4197: PUSH
4198: LD_INT 4
4200: PUSH
4201: EMPTY
4202: LIST
4203: LIST
4204: PPUSH
4205: CALL_OW 72
4209: IFFALSE 4238
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 4 ] ) , usLab ) ;
4211: LD_VAR 0 3
4215: PPUSH
4216: LD_INT 25
4218: PUSH
4219: LD_INT 4
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: PPUSH
4226: CALL_OW 72
4230: PPUSH
4231: LD_INT 3
4233: PPUSH
4234: CALL_OW 180
// end else
4238: GO 4515
// begin tmp := tmp union FilterUnitsInArea ( retreatArea , [ f_side , 1 ] ) ;
4240: LD_ADDR_VAR 0 3
4244: PUSH
4245: LD_VAR 0 3
4249: PUSH
4250: LD_INT 6
4252: PPUSH
4253: LD_INT 22
4255: PUSH
4256: LD_INT 1
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: PPUSH
4263: CALL_OW 70
4267: UNION
4268: ST_TO_ADDR
// ComMoveXY ( tmp , 45 , 54 ) ;
4269: LD_VAR 0 3
4273: PPUSH
4274: LD_INT 45
4276: PPUSH
4277: LD_INT 54
4279: PPUSH
4280: CALL_OW 111
// wait ( 0 0$3 ) ;
4284: LD_INT 105
4286: PPUSH
4287: CALL_OW 67
// AddComAgressiveMove ( tmp diff UnitFilter ( tmp , [ f_class , 4 ] ) , 35 , 24 ) ;
4291: LD_VAR 0 3
4295: PUSH
4296: LD_VAR 0 3
4300: PPUSH
4301: LD_INT 25
4303: PUSH
4304: LD_INT 4
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: PPUSH
4311: CALL_OW 72
4315: DIFF
4316: PPUSH
4317: LD_INT 35
4319: PPUSH
4320: LD_INT 24
4322: PPUSH
4323: CALL_OW 174
// AddComMoveXY ( UnitFilter ( tmp , [ f_class , 4 ] ) , 42 , 49 ) ;
4327: LD_VAR 0 3
4331: PPUSH
4332: LD_INT 25
4334: PUSH
4335: LD_INT 4
4337: PUSH
4338: EMPTY
4339: LIST
4340: LIST
4341: PPUSH
4342: CALL_OW 72
4346: PPUSH
4347: LD_INT 42
4349: PPUSH
4350: LD_INT 49
4352: PPUSH
4353: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4357: LD_INT 35
4359: PPUSH
4360: CALL_OW 67
// for i in tmp do
4364: LD_ADDR_VAR 0 1
4368: PUSH
4369: LD_VAR 0 3
4373: PUSH
4374: FOR_IN
4375: IFFALSE 4506
// if IsDead ( i ) then
4377: LD_VAR 0 1
4381: PPUSH
4382: CALL_OW 301
4386: IFFALSE 4406
// tmp := tmp diff i else
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: LD_VAR 0 3
4397: PUSH
4398: LD_VAR 0 1
4402: DIFF
4403: ST_TO_ADDR
4404: GO 4504
// if GetClass ( i ) = 1 then
4406: LD_VAR 0 1
4410: PPUSH
4411: CALL_OW 257
4415: PUSH
4416: LD_INT 1
4418: EQUAL
4419: IFFALSE 4504
// begin if GetLives ( i ) < 600 and GetDistUnitXY ( i , 42 , 49 ) > 6 then
4421: LD_VAR 0 1
4425: PPUSH
4426: CALL_OW 256
4430: PUSH
4431: LD_INT 600
4433: LESS
4434: PUSH
4435: LD_VAR 0 1
4439: PPUSH
4440: LD_INT 42
4442: PPUSH
4443: LD_INT 49
4445: PPUSH
4446: CALL_OW 297
4450: PUSH
4451: LD_INT 6
4453: GREATER
4454: AND
4455: IFFALSE 4474
// ComMoveXY ( i , 42 , 49 ) else
4457: LD_VAR 0 1
4461: PPUSH
4462: LD_INT 42
4464: PPUSH
4465: LD_INT 49
4467: PPUSH
4468: CALL_OW 111
4472: GO 4504
// if GetLives ( i ) = 1000 then
4474: LD_VAR 0 1
4478: PPUSH
4479: CALL_OW 256
4483: PUSH
4484: LD_INT 1000
4486: EQUAL
4487: IFFALSE 4504
// ComAgressiveMove ( i , 36 , 25 ) ;
4489: LD_VAR 0 1
4493: PPUSH
4494: LD_INT 36
4496: PPUSH
4497: LD_INT 25
4499: PPUSH
4500: CALL_OW 114
// end ;
4504: GO 4374
4506: POP
4507: POP
// until not tmp ;
4508: LD_VAR 0 3
4512: NOT
4513: IFFALSE 4357
// end ; end ;
4515: PPOPN 3
4517: END
// every 0 0$1 trigger FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) and not attackDeltaAllowed do var i , un , veh ;
4518: LD_INT 7
4520: PPUSH
4521: LD_INT 22
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PPUSH
4531: CALL_OW 70
4535: PUSH
4536: LD_EXP 14
4540: NOT
4541: AND
4542: IFFALSE 4700
4544: GO 4546
4546: DISABLE
4547: LD_INT 0
4549: PPUSH
4550: PPUSH
4551: PPUSH
// begin for i := 1 to 2 do
4552: LD_ADDR_VAR 0 1
4556: PUSH
4557: DOUBLE
4558: LD_INT 1
4560: DEC
4561: ST_TO_ADDR
4562: LD_INT 2
4564: PUSH
4565: FOR_TO
4566: IFFALSE 4698
// begin wait ( 0 0$3 ) ;
4568: LD_INT 105
4570: PPUSH
4571: CALL_OW 67
// uc_side := 1 ;
4575: LD_ADDR_OWVAR 20
4579: PUSH
4580: LD_INT 1
4582: ST_TO_ADDR
// uc_nation := 1 ;
4583: LD_ADDR_OWVAR 21
4587: PUSH
4588: LD_INT 1
4590: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 90 ) ;
4591: LD_INT 1
4593: PPUSH
4594: LD_INT 1
4596: PPUSH
4597: LD_INT 2
4599: PPUSH
4600: LD_INT 1
4602: PPUSH
4603: LD_INT 1
4605: PPUSH
4606: LD_INT 4
4608: PPUSH
4609: LD_INT 90
4611: PPUSH
4612: CALL 300 0 7
// veh := CreateVehicle ;
4616: LD_ADDR_VAR 0 3
4620: PUSH
4621: CALL_OW 45
4625: ST_TO_ADDR
// PlaceUnitXY ( veh , 29 , 52 , false ) ;
4626: LD_VAR 0 3
4630: PPUSH
4631: LD_INT 29
4633: PPUSH
4634: LD_INT 52
4636: PPUSH
4637: LD_INT 0
4639: PPUSH
4640: CALL_OW 48
// PrepareHuman ( false , 3 , 3 ) ;
4644: LD_INT 0
4646: PPUSH
4647: LD_INT 3
4649: PPUSH
4650: LD_INT 3
4652: PPUSH
4653: CALL_OW 380
// un := CreateHuman ;
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: CALL_OW 44
4666: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4667: LD_VAR 0 2
4671: PPUSH
4672: LD_VAR 0 3
4676: PPUSH
4677: CALL_OW 52
// ComAgressiveMove ( veh , 36 , 25 ) ;
4681: LD_VAR 0 3
4685: PPUSH
4686: LD_INT 36
4688: PPUSH
4689: LD_INT 25
4691: PPUSH
4692: CALL_OW 114
// end ;
4696: GO 4565
4698: POP
4699: POP
// end ; end_of_file
4700: PPOPN 3
4702: END
// export function Action ; var i , tmp ; begin
4703: LD_INT 0
4705: PPUSH
4706: PPUSH
4707: PPUSH
// InGameOn ;
4708: CALL_OW 8
// DoNotAttack ( 2 , usLab ) ;
4712: LD_INT 2
4714: PPUSH
4715: LD_INT 3
4717: PPUSH
4718: CALL_OW 471
// ComMoveXY ( Heike , 78 , 61 ) ;
4722: LD_EXP 23
4726: PPUSH
4727: LD_INT 78
4729: PPUSH
4730: LD_INT 61
4732: PPUSH
4733: CALL_OW 111
// if Mike then
4737: LD_EXP 25
4741: IFFALSE 4758
// ComMoveXY ( Mike , 80 , 66 ) ;
4743: LD_EXP 25
4747: PPUSH
4748: LD_INT 80
4750: PPUSH
4751: LD_INT 66
4753: PPUSH
4754: CALL_OW 111
// if Givi then
4758: LD_EXP 24
4762: IFFALSE 4779
// ComMoveXY ( Givi , 82 , 66 ) ;
4764: LD_EXP 24
4768: PPUSH
4769: LD_INT 82
4771: PPUSH
4772: LD_INT 66
4774: PPUSH
4775: CALL_OW 111
// if Kamil then
4779: LD_EXP 26
4783: IFFALSE 4800
// ComMoveXY ( Kamil , 82 , 67 ) ;
4785: LD_EXP 26
4789: PPUSH
4790: LD_INT 82
4792: PPUSH
4793: LD_INT 67
4795: PPUSH
4796: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
4800: LD_EXP 23
4804: PPUSH
4805: CALL_OW 87
// wait ( 0 0$2 ) ;
4809: LD_INT 70
4811: PPUSH
4812: CALL_OW 67
// if Givi and Mike then
4816: LD_EXP 24
4820: PUSH
4821: LD_EXP 25
4825: AND
4826: IFFALSE 5272
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4828: LD_EXP 24
4832: PUSH
4833: LD_EXP 25
4837: PUSH
4838: LD_EXP 26
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: LD_EXP 23
4852: PPUSH
4853: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
4857: LD_EXP 23
4861: PPUSH
4862: LD_EXP 24
4866: PPUSH
4867: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
4871: LD_EXP 24
4875: PPUSH
4876: LD_STRING DG-1-start
4878: PPUSH
4879: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
4883: LD_EXP 23
4887: PPUSH
4888: LD_STRING DH-1-start
4890: PPUSH
4891: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
4895: LD_EXP 25
4899: PPUSH
4900: LD_EXP 23
4904: PPUSH
4905: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
4909: LD_EXP 23
4913: PPUSH
4914: LD_EXP 25
4918: PPUSH
4919: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
4923: LD_EXP 25
4927: PPUSH
4928: LD_STRING DM-1-start
4930: PPUSH
4931: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
4935: LD_EXP 23
4939: PPUSH
4940: LD_STRING DH-2-start
4942: PPUSH
4943: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
4947: LD_EXP 25
4951: PPUSH
4952: LD_STRING DM-2-start
4954: PPUSH
4955: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
4959: LD_EXP 24
4963: PPUSH
4964: LD_STRING DG-2-start
4966: PPUSH
4967: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
4971: LD_EXP 25
4975: PPUSH
4976: LD_EXP 24
4980: PPUSH
4981: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
4985: LD_EXP 23
4989: PPUSH
4990: LD_EXP 25
4994: PPUSH
4995: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
4999: LD_EXP 25
5003: PPUSH
5004: LD_STRING DM-3-start
5006: PPUSH
5007: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
5011: LD_EXP 23
5015: PPUSH
5016: LD_STRING DH-3-start
5018: PPUSH
5019: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
5023: LD_EXP 23
5027: PUSH
5028: LD_EXP 25
5032: PUSH
5033: LD_EXP 24
5037: PUSH
5038: LD_EXP 26
5042: PUSH
5043: EMPTY
5044: LIST
5045: LIST
5046: LIST
5047: LIST
5048: PPUSH
5049: LD_INT 84
5051: PPUSH
5052: LD_INT 51
5054: PPUSH
5055: CALL_OW 111
// wait ( 0 0$2 ) ;
5059: LD_INT 70
5061: PPUSH
5062: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
5066: LD_EXP 24
5070: PPUSH
5071: LD_STRING DG-3-start
5073: PPUSH
5074: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
5078: LD_EXP 23
5082: PUSH
5083: LD_EXP 25
5087: PUSH
5088: LD_EXP 24
5092: PUSH
5093: LD_EXP 26
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: LIST
5103: PPUSH
5104: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
5108: LD_EXP 23
5112: PPUSH
5113: LD_EXP 24
5117: PPUSH
5118: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
5122: LD_EXP 24
5126: PUSH
5127: LD_EXP 25
5131: PUSH
5132: LD_EXP 26
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: LIST
5141: PPUSH
5142: LD_EXP 23
5146: PPUSH
5147: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
5151: LD_EXP 23
5155: PPUSH
5156: LD_STRING DH-4-start
5158: PPUSH
5159: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
5163: LD_EXP 24
5167: PPUSH
5168: LD_STRING DG-4-start
5170: PPUSH
5171: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
5175: LD_EXP 23
5179: PPUSH
5180: LD_STRING DH-5-start
5182: PPUSH
5183: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
5187: LD_EXP 24
5191: PPUSH
5192: LD_STRING DG-5-start
5194: PPUSH
5195: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
5199: LD_EXP 23
5203: PPUSH
5204: LD_STRING DH-6-start
5206: PPUSH
5207: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
5211: LD_EXP 25
5215: PPUSH
5216: LD_STRING DM-6-start
5218: PPUSH
5219: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
5223: LD_EXP 23
5227: PUSH
5228: LD_EXP 24
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: LD_EXP 25
5241: PPUSH
5242: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
5246: LD_EXP 24
5250: PPUSH
5251: LD_STRING DG-6-start
5253: PPUSH
5254: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
5258: LD_EXP 23
5262: PPUSH
5263: LD_STRING DH-7-start
5265: PPUSH
5266: CALL_OW 88
// end else
5270: GO 5994
// if not Mike and Givi then
5272: LD_EXP 25
5276: NOT
5277: PUSH
5278: LD_EXP 24
5282: AND
5283: IFFALSE 5628
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5285: LD_EXP 24
5289: PUSH
5290: LD_EXP 26
5294: PUSH
5295: EMPTY
5296: LIST
5297: LIST
5298: PPUSH
5299: LD_EXP 23
5303: PPUSH
5304: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
5308: LD_EXP 23
5312: PPUSH
5313: LD_EXP 24
5317: PPUSH
5318: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
5322: LD_EXP 24
5326: PPUSH
5327: LD_STRING DG-1-start-c
5329: PPUSH
5330: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
5334: LD_EXP 23
5338: PPUSH
5339: LD_STRING DH-1-start-c
5341: PPUSH
5342: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
5346: LD_EXP 24
5350: PPUSH
5351: LD_STRING DG-2-start-c
5353: PPUSH
5354: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
5358: LD_EXP 23
5362: PPUSH
5363: LD_STRING DH-2-start-c
5365: PPUSH
5366: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
5370: LD_EXP 24
5374: PPUSH
5375: LD_STRING DG-3-start-c
5377: PPUSH
5378: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
5382: LD_EXP 23
5386: PPUSH
5387: LD_INT 83
5389: PPUSH
5390: LD_INT 56
5392: PPUSH
5393: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
5397: LD_EXP 24
5401: PPUSH
5402: LD_INT 83
5404: PPUSH
5405: LD_INT 59
5407: PPUSH
5408: CALL_OW 111
// if Kamil then
5412: LD_EXP 26
5416: IFFALSE 5433
// ComMoveXY ( Kamil , 80 , 58 ) ;
5418: LD_EXP 26
5422: PPUSH
5423: LD_INT 80
5425: PPUSH
5426: LD_INT 58
5428: PPUSH
5429: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
5433: LD_EXP 23
5437: PPUSH
5438: LD_EXP 24
5442: PPUSH
5443: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5447: LD_EXP 24
5451: PUSH
5452: LD_EXP 26
5456: PUSH
5457: EMPTY
5458: LIST
5459: LIST
5460: PPUSH
5461: LD_EXP 23
5465: PPUSH
5466: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
5470: LD_EXP 23
5474: PPUSH
5475: LD_STRING DH-3-start-c
5477: PPUSH
5478: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
5482: LD_EXP 24
5486: PPUSH
5487: LD_STRING DG-4-start-c
5489: PPUSH
5490: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
5494: LD_EXP 23
5498: PPUSH
5499: LD_STRING DH-5-start-c
5501: PPUSH
5502: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
5506: LD_EXP 24
5510: PPUSH
5511: LD_STRING DG-5-start-c
5513: PPUSH
5514: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
5518: LD_EXP 23
5522: PPUSH
5523: LD_STRING DH-6-start-c
5525: PPUSH
5526: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
5530: LD_EXP 24
5534: PPUSH
5535: LD_STRING DG-6-start-c
5537: PPUSH
5538: CALL_OW 88
// if Kamil then
5542: LD_EXP 26
5546: IFFALSE 5602
// begin ComTurnUnit ( Kamil , Heike ) ;
5548: LD_EXP 26
5552: PPUSH
5553: LD_EXP 23
5557: PPUSH
5558: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5562: LD_EXP 26
5566: PPUSH
5567: LD_STRING DKam-1-start-c
5569: PPUSH
5570: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
5574: LD_EXP 24
5578: PPUSH
5579: LD_EXP 26
5583: PPUSH
5584: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
5588: LD_EXP 24
5592: PPUSH
5593: LD_STRING DG-7-start-c
5595: PPUSH
5596: CALL_OW 88
// end else
5600: GO 5626
// begin Say ( Givi , DG-8-start-c ) ;
5602: LD_EXP 24
5606: PPUSH
5607: LD_STRING DG-8-start-c
5609: PPUSH
5610: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
5614: LD_EXP 23
5618: PPUSH
5619: LD_STRING DH-7-start-c
5621: PPUSH
5622: CALL_OW 88
// end ; end else
5626: GO 5994
// if not Givi and Mike then
5628: LD_EXP 24
5632: NOT
5633: PUSH
5634: LD_EXP 25
5638: AND
5639: IFFALSE 5898
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
5641: LD_EXP 25
5645: PUSH
5646: LD_EXP 26
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: PPUSH
5655: LD_EXP 23
5659: PPUSH
5660: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
5664: LD_EXP 23
5668: PPUSH
5669: LD_EXP 25
5673: PPUSH
5674: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
5678: LD_EXP 25
5682: PPUSH
5683: LD_STRING DM-1-start-b
5685: PPUSH
5686: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
5690: LD_EXP 23
5694: PPUSH
5695: LD_STRING DH-1-start-b
5697: PPUSH
5698: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
5702: LD_EXP 25
5706: PPUSH
5707: LD_STRING DM-2-start-b
5709: PPUSH
5710: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
5714: LD_EXP 23
5718: PPUSH
5719: LD_STRING DH-2-start-b
5721: PPUSH
5722: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
5726: LD_EXP 25
5730: PPUSH
5731: LD_STRING DM-3-start-b
5733: PPUSH
5734: CALL_OW 88
// if Kamil then
5738: LD_EXP 26
5742: IFFALSE 5759
// ComMoveXY ( Kamil , 80 , 58 ) ;
5744: LD_EXP 26
5748: PPUSH
5749: LD_INT 80
5751: PPUSH
5752: LD_INT 58
5754: PPUSH
5755: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
5759: LD_EXP 23
5763: PPUSH
5764: LD_INT 83
5766: PPUSH
5767: LD_INT 56
5769: PPUSH
5770: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
5774: LD_EXP 25
5778: PPUSH
5779: LD_INT 83
5781: PPUSH
5782: LD_INT 59
5784: PPUSH
5785: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
5789: LD_EXP 23
5793: PPUSH
5794: LD_EXP 25
5798: PPUSH
5799: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
5803: LD_EXP 26
5807: PUSH
5808: LD_EXP 25
5812: PUSH
5813: EMPTY
5814: LIST
5815: LIST
5816: PPUSH
5817: LD_EXP 23
5821: PPUSH
5822: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
5826: LD_EXP 23
5830: PPUSH
5831: LD_STRING DH-3-start-b
5833: PPUSH
5834: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
5838: LD_EXP 25
5842: PPUSH
5843: LD_STRING DM-4-start-b
5845: PPUSH
5846: CALL_OW 88
// if Kamil then
5850: LD_EXP 26
5854: IFFALSE 5884
// begin ComTurnUnit ( Kamil , Heike ) ;
5856: LD_EXP 26
5860: PPUSH
5861: LD_EXP 23
5865: PPUSH
5866: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5870: LD_EXP 26
5874: PPUSH
5875: LD_STRING DKam-1-start-c
5877: PPUSH
5878: CALL_OW 88
// end else
5882: GO 5896
// begin Say ( Mike , DM-5-start-b ) ;
5884: LD_EXP 25
5888: PPUSH
5889: LD_STRING DM-5-start-b
5891: PPUSH
5892: CALL_OW 88
// end ; end else
5896: GO 5994
// if Kamil then
5898: LD_EXP 26
5902: IFFALSE 5982
// begin AddComTurnUnit ( Heike , Kamil ) ;
5904: LD_EXP 23
5908: PPUSH
5909: LD_EXP 26
5913: PPUSH
5914: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
5918: LD_EXP 26
5922: PPUSH
5923: LD_EXP 23
5927: PPUSH
5928: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
5932: LD_EXP 23
5936: PPUSH
5937: LD_STRING DH-1-start-f
5939: PPUSH
5940: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
5944: LD_EXP 26
5948: PPUSH
5949: LD_STRING DKam-1-start-f
5951: PPUSH
5952: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
5956: LD_EXP 23
5960: PPUSH
5961: LD_STRING DH-2-start-f
5963: PPUSH
5964: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
5968: LD_EXP 26
5972: PPUSH
5973: LD_STRING DKam-2-start-f
5975: PPUSH
5976: CALL_OW 88
// end else
5980: GO 5994
// begin Say ( Heike , DH-1-start-d ) ;
5982: LD_EXP 23
5986: PPUSH
5987: LD_STRING DH-1-start-d
5989: PPUSH
5990: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
5994: LD_EXP 23
5998: PUSH
5999: LD_EXP 24
6003: PUSH
6004: LD_EXP 25
6008: PUSH
6009: LD_EXP 26
6013: PUSH
6014: EMPTY
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: PPUSH
6020: CALL_OW 139
// InGameOff ;
6024: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
6028: LD_STRING OEast
6030: PPUSH
6031: CALL_OW 337
// SaveForQuickRestart ;
6035: CALL_OW 22
// wait ( 0 0$20 ) ;
6039: LD_INT 700
6041: PPUSH
6042: CALL_OW 67
// SendSciToForest ;
6046: CALL 1542 0 0
// if Difficulty = 1 then
6050: LD_OWVAR 67
6054: PUSH
6055: LD_INT 1
6057: EQUAL
6058: IFFALSE 6062
// exit ;
6060: GO 6179
// wait ( [ 5 5$00 , 2 2$30 ] [ Difficulty - 1 ] ) ;
6062: LD_INT 10500
6064: PUSH
6065: LD_INT 5250
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: PUSH
6072: LD_OWVAR 67
6076: PUSH
6077: LD_INT 1
6079: MINUS
6080: ARRAY
6081: PPUSH
6082: CALL_OW 67
// if usAlert then
6086: LD_EXP 10
6090: IFFALSE 6094
// exit ;
6092: GO 6179
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
6094: LD_ADDR_VAR 0 3
6098: PUSH
6099: LD_INT 22
6101: PUSH
6102: LD_INT 1
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: PUSH
6109: LD_INT 25
6111: PUSH
6112: LD_INT 2
6114: PUSH
6115: EMPTY
6116: LIST
6117: LIST
6118: PUSH
6119: EMPTY
6120: LIST
6121: LIST
6122: PPUSH
6123: CALL_OW 69
6127: ST_TO_ADDR
// if not tmp then
6128: LD_VAR 0 3
6132: NOT
6133: IFFALSE 6137
// exit ;
6135: GO 6179
// ComExitBuilding ( tmp ) ;
6137: LD_VAR 0 3
6141: PPUSH
6142: CALL_OW 122
// AddComBuild ( tmp , b_breastwork , 40 , 13 , 3 ) ;
6146: LD_VAR 0 3
6150: PPUSH
6151: LD_INT 31
6153: PPUSH
6154: LD_INT 40
6156: PPUSH
6157: LD_INT 13
6159: PPUSH
6160: LD_INT 3
6162: PPUSH
6163: CALL_OW 205
// AddComEnterUnit ( tmp , Delta ) ;
6167: LD_VAR 0 3
6171: PPUSH
6172: LD_INT 1
6174: PPUSH
6175: CALL_OW 180
// end ;
6179: LD_VAR 0 1
6183: RET
// every 3 3$00 do
6184: GO 6186
6186: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
6187: LD_INT 1
6189: PPUSH
6190: LD_INT 570
6192: PPUSH
6193: LD_INT 350
6195: PPUSH
6196: CALL_OW 550
// wait ( 2 2$40 ) ;
6200: LD_INT 5600
6202: PPUSH
6203: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
6207: LD_INT 0
6209: PPUSH
6210: LD_INT 570
6212: PPUSH
6213: LD_INT 350
6215: PPUSH
6216: CALL_OW 550
// end ;
6220: END
// every 0 0$1 trigger not aviradzeSpotted and See ( 2 , Aviradze ) do var i , pepAmount ;
6221: LD_EXP 4
6225: NOT
6226: PUSH
6227: LD_INT 2
6229: PPUSH
6230: LD_EXP 27
6234: PPUSH
6235: CALL_OW 292
6239: AND
6240: IFFALSE 7146
6242: GO 6244
6244: DISABLE
6245: LD_INT 0
6247: PPUSH
6248: PPUSH
// begin aviradzeSpotted := true ;
6249: LD_ADDR_EXP 4
6253: PUSH
6254: LD_INT 1
6256: ST_TO_ADDR
// pepAmount := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
6257: LD_ADDR_VAR 0 2
6261: PUSH
6262: LD_INT 22
6264: PUSH
6265: LD_INT 2
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: PUSH
6272: LD_INT 21
6274: PUSH
6275: LD_INT 1
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PPUSH
6286: CALL_OW 69
6290: ST_TO_ADDR
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6291: LD_EXP 23
6295: PPUSH
6296: LD_EXP 27
6300: PPUSH
6301: CALL_OW 250
6305: PPUSH
6306: LD_EXP 27
6310: PPUSH
6311: CALL_OW 251
6315: PPUSH
6316: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6320: LD_INT 35
6322: PPUSH
6323: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 16 ;
6327: LD_EXP 23
6331: PPUSH
6332: LD_EXP 27
6336: PPUSH
6337: CALL_OW 296
6341: PUSH
6342: LD_INT 16
6344: LESS
6345: IFFALSE 6320
// InGameOn ;
6347: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6351: LD_INT 5
6353: PPUSH
6354: LD_INT 2
6356: PPUSH
6357: CALL_OW 343
// if pepAmount > 2 then
6361: LD_VAR 0 2
6365: PUSH
6366: LD_INT 2
6368: GREATER
6369: IFFALSE 6385
// Say ( Heike , DH-1-spot ) else
6371: LD_EXP 23
6375: PPUSH
6376: LD_STRING DH-1-spot
6378: PPUSH
6379: CALL_OW 88
6383: GO 6397
// Say ( Heike , DH-1-spot-d ) ;
6385: LD_EXP 23
6389: PPUSH
6390: LD_STRING DH-1-spot-d
6392: PPUSH
6393: CALL_OW 88
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6397: LD_EXP 23
6401: PPUSH
6402: LD_EXP 27
6406: PPUSH
6407: CALL_OW 250
6411: PPUSH
6412: LD_EXP 27
6416: PPUSH
6417: CALL_OW 251
6421: PPUSH
6422: CALL_OW 111
// for i in [ Kamil , Mike , Givi ] do
6426: LD_ADDR_VAR 0 1
6430: PUSH
6431: LD_EXP 26
6435: PUSH
6436: LD_EXP 25
6440: PUSH
6441: LD_EXP 24
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: LIST
6450: PUSH
6451: FOR_IN
6452: IFFALSE 6491
// if GetDistUnits ( i , Aviradze ) > 7 then
6454: LD_VAR 0 1
6458: PPUSH
6459: LD_EXP 27
6463: PPUSH
6464: CALL_OW 296
6468: PUSH
6469: LD_INT 7
6471: GREATER
6472: IFFALSE 6489
// ComMoveXY ( i , 102 , 40 ) ;
6474: LD_VAR 0 1
6478: PPUSH
6479: LD_INT 102
6481: PPUSH
6482: LD_INT 40
6484: PPUSH
6485: CALL_OW 111
6489: GO 6451
6491: POP
6492: POP
// repeat wait ( 0 0$1 ) ;
6493: LD_INT 35
6495: PPUSH
6496: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 6 ;
6500: LD_EXP 23
6504: PPUSH
6505: LD_EXP 27
6509: PPUSH
6510: CALL_OW 296
6514: PUSH
6515: LD_INT 6
6517: LESS
6518: IFFALSE 6493
// ComTurnUnit ( Heike , Aviradze ) ;
6520: LD_EXP 23
6524: PPUSH
6525: LD_EXP 27
6529: PPUSH
6530: CALL_OW 119
// ComTurnUnit ( [ Aviradze , Sophia , Kaia ] , Heike ) ;
6534: LD_EXP 27
6538: PUSH
6539: LD_EXP 29
6543: PUSH
6544: LD_EXP 28
6548: PUSH
6549: EMPTY
6550: LIST
6551: LIST
6552: LIST
6553: PPUSH
6554: LD_EXP 23
6558: PPUSH
6559: CALL_OW 119
// if pepAmount > 1 then
6563: LD_VAR 0 2
6567: PUSH
6568: LD_INT 1
6570: GREATER
6571: IFFALSE 6623
// begin wait ( 0 0$2 ) ;
6573: LD_INT 70
6575: PPUSH
6576: CALL_OW 67
// ComTurnUnit ( [ Kamil , Mike , Givi ] , Aviradze ) ;
6580: LD_EXP 26
6584: PUSH
6585: LD_EXP 25
6589: PUSH
6590: LD_EXP 24
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: LIST
6599: PPUSH
6600: LD_EXP 27
6604: PPUSH
6605: CALL_OW 119
// Say ( Heike , DH-2-spot ) ;
6609: LD_EXP 23
6613: PPUSH
6614: LD_STRING DH-2-spot
6616: PPUSH
6617: CALL_OW 88
// end else
6621: GO 6635
// Say ( Heike , DH-2-spot-d ) ;
6623: LD_EXP 23
6627: PPUSH
6628: LD_STRING DH-2-spot-d
6630: PPUSH
6631: CALL_OW 88
// Say ( Aviradze , DA-2-spot ) ;
6635: LD_EXP 27
6639: PPUSH
6640: LD_STRING DA-2-spot
6642: PPUSH
6643: CALL_OW 88
// Say ( Heike , DH-3-spot ) ;
6647: LD_EXP 23
6651: PPUSH
6652: LD_STRING DH-3-spot
6654: PPUSH
6655: CALL_OW 88
// ComMoveUnit ( Kaia , Heike ) ;
6659: LD_EXP 28
6663: PPUSH
6664: LD_EXP 23
6668: PPUSH
6669: CALL_OW 112
// ComTurnUnit ( Heike , Kaia ) ;
6673: LD_EXP 23
6677: PPUSH
6678: LD_EXP 28
6682: PPUSH
6683: CALL_OW 119
// wait ( 0 0$0.3 ) ;
6687: LD_INT 10
6689: PPUSH
6690: CALL_OW 67
// Say ( Kaia , DK-3-spot ) ;
6694: LD_EXP 28
6698: PPUSH
6699: LD_STRING DK-3-spot
6701: PPUSH
6702: CALL_OW 88
// ComTurnUnit ( Kaia , Heike ) ;
6706: LD_EXP 28
6710: PPUSH
6711: LD_EXP 23
6715: PPUSH
6716: CALL_OW 119
// Say ( Heike , DH-4-spot ) ;
6720: LD_EXP 23
6724: PPUSH
6725: LD_STRING DH-4-spot
6727: PPUSH
6728: CALL_OW 88
// wait ( 0 0$0.3 ) ;
6732: LD_INT 10
6734: PPUSH
6735: CALL_OW 67
// ComTurnUnit ( Heike , Aviradze ) ;
6739: LD_EXP 23
6743: PPUSH
6744: LD_EXP 27
6748: PPUSH
6749: CALL_OW 119
// Say ( Aviradze , DA-4-spot ) ;
6753: LD_EXP 27
6757: PPUSH
6758: LD_STRING DA-4-spot
6760: PPUSH
6761: CALL_OW 88
// ComTurnUnit ( Kaia , Aviradze ) ;
6765: LD_EXP 28
6769: PPUSH
6770: LD_EXP 27
6774: PPUSH
6775: CALL_OW 119
// Say ( Kaia , DK-4-spot ) ;
6779: LD_EXP 28
6783: PPUSH
6784: LD_STRING DK-4-spot
6786: PPUSH
6787: CALL_OW 88
// ComTurnUnit ( Aviradze , Kaia ) ;
6791: LD_EXP 27
6795: PPUSH
6796: LD_EXP 28
6800: PPUSH
6801: CALL_OW 119
// Say ( Aviradze , DA-5-spot ) ;
6805: LD_EXP 27
6809: PPUSH
6810: LD_STRING DA-5-spot
6812: PPUSH
6813: CALL_OW 88
// Say ( Kaia , DK-5-spot ) ;
6817: LD_EXP 28
6821: PPUSH
6822: LD_STRING DK-5-spot
6824: PPUSH
6825: CALL_OW 88
// if pepAmount = 1 then
6829: LD_VAR 0 2
6833: PUSH
6834: LD_INT 1
6836: EQUAL
6837: IFFALSE 6851
// Say ( Heike , DH-5-spot-f ) ;
6839: LD_EXP 23
6843: PPUSH
6844: LD_STRING DH-5-spot-f
6846: PPUSH
6847: CALL_OW 88
// if pepAmount < 3 then
6851: LD_VAR 0 2
6855: PUSH
6856: LD_INT 3
6858: LESS
6859: IFFALSE 6875
// Say ( Aviradze , DA-6-spot-f ) else
6861: LD_EXP 27
6865: PPUSH
6866: LD_STRING DA-6-spot-f
6868: PPUSH
6869: CALL_OW 88
6873: GO 6911
// if pepAmount < 4 then
6875: LD_VAR 0 2
6879: PUSH
6880: LD_INT 4
6882: LESS
6883: IFFALSE 6899
// Say ( Aviradze , DA-6-spot-c ) else
6885: LD_EXP 27
6889: PPUSH
6890: LD_STRING DA-6-spot-c
6892: PPUSH
6893: CALL_OW 88
6897: GO 6911
// Say ( Aviradze , DA-6-spot ) ;
6899: LD_EXP 27
6903: PPUSH
6904: LD_STRING DA-6-spot
6906: PPUSH
6907: CALL_OW 88
// if Kamil then
6911: LD_EXP 26
6915: IFFALSE 6929
// Say ( Kamil , DKam-6-spot ) ;
6917: LD_EXP 26
6921: PPUSH
6922: LD_STRING DKam-6-spot
6924: PPUSH
6925: CALL_OW 88
// Say ( Kaia , DK-6-spot ) ;
6929: LD_EXP 28
6933: PPUSH
6934: LD_STRING DK-6-spot
6936: PPUSH
6937: CALL_OW 88
// ComTurnUnit ( Aviradze , Heike ) ;
6941: LD_EXP 27
6945: PPUSH
6946: LD_EXP 23
6950: PPUSH
6951: CALL_OW 119
// Say ( Aviradze , DA-7-spot ) ;
6955: LD_EXP 27
6959: PPUSH
6960: LD_STRING DA-7-spot
6962: PPUSH
6963: CALL_OW 88
// Say ( Heike , DH-7-spot ) ;
6967: LD_EXP 23
6971: PPUSH
6972: LD_STRING DH-7-spot
6974: PPUSH
6975: CALL_OW 88
// if sciCounterKill >= 3 then
6979: LD_EXP 9
6983: PUSH
6984: LD_INT 3
6986: GREATEREQUAL
6987: IFFALSE 7013
// begin Say ( Heike , DH-7-spot-a ) ;
6989: LD_EXP 23
6993: PPUSH
6994: LD_STRING DH-7-spot-a
6996: PPUSH
6997: CALL_OW 88
// Say ( Aviradze , DA-8-spot-a ) ;
7001: LD_EXP 27
7005: PPUSH
7006: LD_STRING DA-8-spot-a
7008: PPUSH
7009: CALL_OW 88
// end ; InGameOff ;
7013: CALL_OW 9
// if sciCounterKill < 3 then
7017: LD_EXP 9
7021: PUSH
7022: LD_INT 3
7024: LESS
7025: IFFALSE 7084
// begin SetSide ( Kaia , 2 ) ;
7027: LD_EXP 28
7031: PPUSH
7032: LD_INT 2
7034: PPUSH
7035: CALL_OW 235
// ComFree ( Kaia ) ;
7039: LD_EXP 28
7043: PPUSH
7044: CALL_OW 139
// if Kamil then
7048: LD_EXP 26
7052: IFFALSE 7075
// begin ComHold ( Kamil ) ;
7054: LD_EXP 26
7058: PPUSH
7059: CALL_OW 140
// SetSide ( Kamil , 5 ) ;
7063: LD_EXP 26
7067: PPUSH
7068: LD_INT 5
7070: PPUSH
7071: CALL_OW 235
// end ; ChangeMissionObjectives ( OSci ) ;
7075: LD_STRING OSci
7077: PPUSH
7078: CALL_OW 337
// end else
7082: GO 7146
// begin aviradzeQuestDone := true ;
7084: LD_ADDR_EXP 8
7088: PUSH
7089: LD_INT 1
7091: ST_TO_ADDR
// attackDeltaAllowed := true ;
7092: LD_ADDR_EXP 14
7096: PUSH
7097: LD_INT 1
7099: ST_TO_ADDR
// ChangeMissionObjectives ( ODelta2 ) ;
7100: LD_STRING ODelta2
7102: PPUSH
7103: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7107: LD_ADDR_VAR 0 1
7111: PUSH
7112: LD_INT 22
7114: PUSH
7115: LD_INT 5
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: PPUSH
7122: CALL_OW 69
7126: PUSH
7127: FOR_IN
7128: IFFALSE 7144
// SetSide ( i , 2 ) ;
7130: LD_VAR 0 1
7134: PPUSH
7135: LD_INT 2
7137: PPUSH
7138: CALL_OW 235
7142: GO 7127
7144: POP
7145: POP
// end ; end ;
7146: PPOPN 2
7148: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and not aviradzeSpotted do
7149: LD_EXP 7
7153: NOT
7154: PUSH
7155: LD_EXP 22
7159: PPUSH
7160: LD_EXP 23
7164: PPUSH
7165: CALL_OW 74
7169: PPUSH
7170: LD_EXP 23
7174: PPUSH
7175: CALL_OW 296
7179: PUSH
7180: LD_INT 8
7182: LESS
7183: AND
7184: PUSH
7185: LD_INT 2
7187: PPUSH
7188: LD_EXP 22
7192: PPUSH
7193: LD_EXP 23
7197: PPUSH
7198: CALL_OW 74
7202: PPUSH
7203: CALL_OW 292
7207: AND
7208: PUSH
7209: LD_INT 22
7211: PUSH
7212: LD_INT 2
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: PUSH
7219: LD_INT 21
7221: PUSH
7222: LD_INT 1
7224: PUSH
7225: EMPTY
7226: LIST
7227: LIST
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: PPUSH
7233: CALL_OW 69
7237: PUSH
7238: LD_INT 1
7240: GREATER
7241: AND
7242: PUSH
7243: LD_EXP 4
7247: NOT
7248: AND
7249: IFFALSE 7293
7251: GO 7253
7253: DISABLE
// begin sciSpotted := true ;
7254: LD_ADDR_EXP 7
7258: PUSH
7259: LD_INT 1
7261: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7262: LD_EXP 22
7266: PPUSH
7267: LD_EXP 23
7271: PPUSH
7272: CALL_OW 74
7276: PPUSH
7277: CALL_OW 87
// Say ( Heike , DH-1-sci ) ;
7281: LD_EXP 23
7285: PPUSH
7286: LD_STRING DH-1-sci
7288: PPUSH
7289: CALL_OW 88
// end ;
7293: END
// every 0 0$1 trigger aviradzeSpotted and not sciSpotted and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and aviradzeSpotted and not aviradzeQuestDone do var un ;
7294: LD_EXP 4
7298: PUSH
7299: LD_EXP 7
7303: NOT
7304: AND
7305: PUSH
7306: LD_INT 2
7308: PPUSH
7309: LD_EXP 22
7313: PPUSH
7314: LD_EXP 23
7318: PPUSH
7319: CALL_OW 74
7323: PPUSH
7324: CALL_OW 292
7328: AND
7329: PUSH
7330: LD_INT 22
7332: PUSH
7333: LD_INT 2
7335: PUSH
7336: EMPTY
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 21
7342: PUSH
7343: LD_INT 1
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PPUSH
7354: CALL_OW 69
7358: PUSH
7359: LD_INT 1
7361: GREATER
7362: AND
7363: PUSH
7364: LD_EXP 4
7368: AND
7369: PUSH
7370: LD_EXP 8
7374: NOT
7375: AND
7376: IFFALSE 7517
7378: GO 7380
7380: DISABLE
7381: LD_INT 0
7383: PPUSH
// begin sciSpotted := true ;
7384: LD_ADDR_EXP 7
7388: PUSH
7389: LD_INT 1
7391: ST_TO_ADDR
// un := NearestUnitToUnit ( usSci , Heike ) ;
7392: LD_ADDR_VAR 0 1
7396: PUSH
7397: LD_EXP 22
7401: PPUSH
7402: LD_EXP 23
7406: PPUSH
7407: CALL_OW 74
7411: ST_TO_ADDR
// DialogueOn ;
7412: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 2 , - 3 ) ;
7416: LD_VAR 0 1
7420: PPUSH
7421: CALL_OW 250
7425: PPUSH
7426: LD_VAR 0 1
7430: PPUSH
7431: CALL_OW 251
7435: PPUSH
7436: LD_INT 2
7438: PPUSH
7439: LD_INT 3
7441: NEG
7442: PPUSH
7443: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7447: LD_VAR 0 1
7451: PPUSH
7452: CALL_OW 87
// Say ( Heike , DH-1-sci-a ) ;
7456: LD_EXP 23
7460: PPUSH
7461: LD_STRING DH-1-sci-a
7463: PPUSH
7464: CALL_OW 88
// if Mike then
7468: LD_EXP 25
7472: IFFALSE 7486
// Say ( Mike , DM-1-sci-a ) ;
7474: LD_EXP 25
7478: PPUSH
7479: LD_STRING DM-1-sci-a
7481: PPUSH
7482: CALL_OW 88
// RemoveSeeing ( GetX ( un ) , GetY ( un ) , 2 ) ;
7486: LD_VAR 0 1
7490: PPUSH
7491: CALL_OW 250
7495: PPUSH
7496: LD_VAR 0 1
7500: PPUSH
7501: CALL_OW 251
7505: PPUSH
7506: LD_INT 2
7508: PPUSH
7509: CALL_OW 331
// DialogueOff ;
7513: CALL_OW 7
// end ;
7517: PPOPN 1
7519: END
// every 0 0$1 trigger usAlert and ( GetLives ( Gladstone ) < 1000 or GetLives ( usLab ) < 999 ) do var veh ;
7520: LD_EXP 10
7524: PUSH
7525: LD_EXP 19
7529: PPUSH
7530: CALL_OW 256
7534: PUSH
7535: LD_INT 1000
7537: LESS
7538: PUSH
7539: LD_INT 3
7541: PPUSH
7542: CALL_OW 256
7546: PUSH
7547: LD_INT 999
7549: LESS
7550: OR
7551: AND
7552: IFFALSE 7808
7554: GO 7556
7556: DISABLE
7557: LD_INT 0
7559: PPUSH
// begin veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
7560: LD_ADDR_VAR 0 1
7564: PUSH
7565: LD_INT 22
7567: PUSH
7568: LD_INT 1
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 21
7577: PUSH
7578: LD_INT 2
7580: PUSH
7581: EMPTY
7582: LIST
7583: LIST
7584: PUSH
7585: LD_INT 58
7587: PUSH
7588: EMPTY
7589: LIST
7590: PUSH
7591: EMPTY
7592: LIST
7593: LIST
7594: LIST
7595: PPUSH
7596: CALL_OW 69
7600: ST_TO_ADDR
// if veh and IsOk ( Gladstone ) then
7601: LD_VAR 0 1
7605: PUSH
7606: LD_EXP 19
7610: PPUSH
7611: CALL_OW 302
7615: AND
7616: IFFALSE 7658
// begin if IsInUnit ( Gladstone ) then
7618: LD_EXP 19
7622: PPUSH
7623: CALL_OW 310
7627: IFFALSE 7638
// ComExitBuilding ( Gladstone ) ;
7629: LD_EXP 19
7633: PPUSH
7634: CALL_OW 122
// AddComEnterUnit ( Gladstone , veh [ 1 ] ) ;
7638: LD_EXP 19
7642: PPUSH
7643: LD_VAR 0 1
7647: PUSH
7648: LD_INT 1
7650: ARRAY
7651: PPUSH
7652: CALL_OW 180
// end else
7656: GO 7678
// if IsInUnit ( Gladstone ) then
7658: LD_EXP 19
7662: PPUSH
7663: CALL_OW 310
7667: IFFALSE 7678
// ComExitBuilding ( Gladstone ) ;
7669: LD_EXP 19
7673: PPUSH
7674: CALL_OW 122
// AddComMoveXY ( Gladstone , 27 , 51 ) ;
7678: LD_EXP 19
7682: PPUSH
7683: LD_INT 27
7685: PPUSH
7686: LD_INT 51
7688: PPUSH
7689: CALL_OW 171
// Say ( Gladstone , D8-Glad-2 ) ;
7693: LD_EXP 19
7697: PPUSH
7698: LD_STRING D8-Glad-2
7700: PPUSH
7701: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
7705: LD_INT 35
7707: PPUSH
7708: CALL_OW 67
// until IsAt ( Gladstone , 27 , 51 ) or IsAt ( IsInUnit ( Gladstone ) , 27 , 51 ) or IsDead ( Gladstone ) ;
7712: LD_EXP 19
7716: PPUSH
7717: LD_INT 27
7719: PPUSH
7720: LD_INT 51
7722: PPUSH
7723: CALL_OW 307
7727: PUSH
7728: LD_EXP 19
7732: PPUSH
7733: CALL_OW 310
7737: PPUSH
7738: LD_INT 27
7740: PPUSH
7741: LD_INT 51
7743: PPUSH
7744: CALL_OW 307
7748: OR
7749: PUSH
7750: LD_EXP 19
7754: PPUSH
7755: CALL_OW 301
7759: OR
7760: IFFALSE 7705
// if IsDead ( Gladstone ) then
7762: LD_EXP 19
7766: PPUSH
7767: CALL_OW 301
7771: IFFALSE 7775
// exit ;
7773: GO 7808
// RemoveUnit ( HexInfo ( 27 , 51 ) ) ;
7775: LD_INT 27
7777: PPUSH
7778: LD_INT 51
7780: PPUSH
7781: CALL_OW 428
7785: PPUSH
7786: CALL_OW 64
// gladstoneEscaped := true ;
7790: LD_ADDR_EXP 12
7794: PUSH
7795: LD_INT 1
7797: ST_TO_ADDR
// SaveVariable ( true , 02_GladstoneEscaped ) ;
7798: LD_INT 1
7800: PPUSH
7801: LD_STRING 02_GladstoneEscaped
7803: PPUSH
7804: CALL_OW 39
// end ;
7808: PPOPN 1
7810: END
// every 0 0$1 trigger aviradzeSpotted and ( sciCounterKill >= 3 or not usSci ) and not aviradzeQuestDone do
7811: LD_EXP 4
7815: PUSH
7816: LD_EXP 9
7820: PUSH
7821: LD_INT 3
7823: GREATEREQUAL
7824: PUSH
7825: LD_EXP 22
7829: NOT
7830: OR
7831: AND
7832: PUSH
7833: LD_EXP 8
7837: NOT
7838: AND
7839: IFFALSE 7882
7841: GO 7843
7843: DISABLE
// begin aviradzeQuestDone := true ;
7844: LD_ADDR_EXP 8
7848: PUSH
7849: LD_INT 1
7851: ST_TO_ADDR
// Say ( Heike , DH-1-quest-done ) ;
7852: LD_EXP 23
7856: PPUSH
7857: LD_STRING DH-1-quest-done
7859: PPUSH
7860: CALL_OW 88
// if Givi then
7864: LD_EXP 24
7868: IFFALSE 7882
// Say ( Givi , DG-1-quest-done ) ;
7870: LD_EXP 24
7874: PPUSH
7875: LD_STRING DG-1-quest-done
7877: PPUSH
7878: CALL_OW 88
// end ;
7882: END
// every 0 0$1 trigger See ( 5 , Heike ) and GetDistUnits ( Heike , Aviradze ) < 6 and aviradzeQuestDone and not attackDeltaAllowed do var i ;
7883: LD_INT 5
7885: PPUSH
7886: LD_EXP 23
7890: PPUSH
7891: CALL_OW 292
7895: PUSH
7896: LD_EXP 23
7900: PPUSH
7901: LD_EXP 27
7905: PPUSH
7906: CALL_OW 296
7910: PUSH
7911: LD_INT 6
7913: LESS
7914: AND
7915: PUSH
7916: LD_EXP 8
7920: AND
7921: PUSH
7922: LD_EXP 14
7926: NOT
7927: AND
7928: IFFALSE 8066
7930: GO 7932
7932: DISABLE
7933: LD_INT 0
7935: PPUSH
// begin attackDeltaAllowed := true ;
7936: LD_ADDR_EXP 14
7940: PUSH
7941: LD_INT 1
7943: ST_TO_ADDR
// InGameOn ;
7944: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
7948: LD_EXP 23
7952: PPUSH
7953: CALL_OW 87
// wait ( 0 0$0.3 ) ;
7957: LD_INT 10
7959: PPUSH
7960: CALL_OW 67
// ComTurnUnit ( Aviradze , Heike ) ;
7964: LD_EXP 27
7968: PPUSH
7969: LD_EXP 23
7973: PPUSH
7974: CALL_OW 119
// ComTurnUnit ( Heike , Aviradze ) ;
7978: LD_EXP 23
7982: PPUSH
7983: LD_EXP 27
7987: PPUSH
7988: CALL_OW 119
// Say ( Heike , DH-1-return ) ;
7992: LD_EXP 23
7996: PPUSH
7997: LD_STRING DH-1-return
7999: PPUSH
8000: CALL_OW 88
// Say ( Aviradze , DA-1-return ) ;
8004: LD_EXP 27
8008: PPUSH
8009: LD_STRING DA-1-return
8011: PPUSH
8012: CALL_OW 88
// InGameOff ;
8016: CALL_OW 9
// ChangeMissionObjectives ( ODelta ) ;
8020: LD_STRING ODelta
8022: PPUSH
8023: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
8027: LD_ADDR_VAR 0 1
8031: PUSH
8032: LD_INT 22
8034: PUSH
8035: LD_INT 5
8037: PUSH
8038: EMPTY
8039: LIST
8040: LIST
8041: PPUSH
8042: CALL_OW 69
8046: PUSH
8047: FOR_IN
8048: IFFALSE 8064
// SetSide ( i , 2 ) ;
8050: LD_VAR 0 1
8054: PPUSH
8055: LD_INT 2
8057: PPUSH
8058: CALL_OW 235
8062: GO 8047
8064: POP
8065: POP
// end ;
8066: PPOPN 1
8068: END
// every 0 0$1 trigger usAlert and not attackDeltaAllowed do
8069: LD_EXP 10
8073: PUSH
8074: LD_EXP 14
8078: NOT
8079: AND
8080: IFFALSE 8093
8082: GO 8084
8084: DISABLE
// spottedBeforeRadio := true ;
8085: LD_ADDR_EXP 6
8089: PUSH
8090: LD_INT 1
8092: ST_TO_ADDR
8093: END
// every 0 0$1 trigger attackDeltaAllowed and IsOk ( Markov ) and GetSide ( Delta ) = 1 and IsOk ( Lynch ) and not usAlert do var i , k , tmp ;
8094: LD_EXP 14
8098: PUSH
8099: LD_EXP 30
8103: PPUSH
8104: CALL_OW 302
8108: AND
8109: PUSH
8110: LD_INT 1
8112: PPUSH
8113: CALL_OW 255
8117: PUSH
8118: LD_INT 1
8120: EQUAL
8121: AND
8122: PUSH
8123: LD_EXP 20
8127: PPUSH
8128: CALL_OW 302
8132: AND
8133: PUSH
8134: LD_EXP 10
8138: NOT
8139: AND
8140: IFFALSE 9356
8142: GO 8144
8144: DISABLE
8145: LD_INT 0
8147: PPUSH
8148: PPUSH
8149: PPUSH
// begin trap := 0 ;
8150: LD_ADDR_EXP 17
8154: PUSH
8155: LD_INT 0
8157: ST_TO_ADDR
// wait ( 0 0$12 ) ;
8158: LD_INT 420
8160: PPUSH
8161: CALL_OW 67
// DialogueOn ;
8165: CALL_OW 6
// Say ( Markov , DMar-1-radio ) ;
8169: LD_EXP 30
8173: PPUSH
8174: LD_STRING DMar-1-radio
8176: PPUSH
8177: CALL_OW 88
// Say ( Heike , DH-1-radio ) ;
8181: LD_EXP 23
8185: PPUSH
8186: LD_STRING DH-1-radio
8188: PPUSH
8189: CALL_OW 88
// Say ( Markov , DMar-2-radio ) ;
8193: LD_EXP 30
8197: PPUSH
8198: LD_STRING DMar-2-radio
8200: PPUSH
8201: CALL_OW 88
// Say ( Heike , DH-2-radio ) ;
8205: LD_EXP 23
8209: PPUSH
8210: LD_STRING DH-2-radio
8212: PPUSH
8213: CALL_OW 88
// if IsOk ( Kamil ) or IsOk ( Sophia ) then
8217: LD_EXP 26
8221: PPUSH
8222: CALL_OW 302
8226: PUSH
8227: LD_EXP 29
8231: PPUSH
8232: CALL_OW 302
8236: OR
8237: IFFALSE 9356
// begin case Query ( Q1Trap ) of 1 :
8239: LD_STRING Q1Trap
8241: PPUSH
8242: CALL_OW 97
8246: PUSH
8247: LD_INT 1
8249: DOUBLE
8250: EQUAL
8251: IFTRUE 8255
8253: GO 8449
8255: POP
// begin if IsOk ( Kamil ) then
8256: LD_EXP 26
8260: PPUSH
8261: CALL_OW 302
8265: IFFALSE 8344
// begin Say ( Kamil , DKam-2-radio ) ;
8267: LD_EXP 26
8271: PPUSH
8272: LD_STRING DKam-2-radio
8274: PPUSH
8275: CALL_OW 88
// Say ( Kamil , DKam-3-radio ) ;
8279: LD_EXP 26
8283: PPUSH
8284: LD_STRING DKam-3-radio
8286: PPUSH
8287: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio ) ;
8291: LD_EXP 20
8295: PPUSH
8296: LD_STRING DDelta-3-radio
8298: PPUSH
8299: CALL_OW 94
// dwait ( 0 0$01 ) ;
8303: LD_INT 35
8305: PPUSH
8306: CALL_OW 68
// Say ( Heike , DH-3-radio ) ;
8310: LD_EXP 23
8314: PPUSH
8315: LD_STRING DH-3-radio
8317: PPUSH
8318: CALL_OW 88
// Say ( Kamil , DKam-4-radio ) ;
8322: LD_EXP 26
8326: PPUSH
8327: LD_STRING DKam-4-radio
8329: PPUSH
8330: CALL_OW 88
// trap := 1 ;
8334: LD_ADDR_EXP 17
8338: PUSH
8339: LD_INT 1
8341: ST_TO_ADDR
// end else
8342: GO 8443
// begin Say ( Sophia , DS-1-radio ) ;
8344: LD_EXP 29
8348: PPUSH
8349: LD_STRING DS-1-radio
8351: PPUSH
8352: CALL_OW 88
// Say ( Sophia , DS-2-radio ) ;
8356: LD_EXP 29
8360: PPUSH
8361: LD_STRING DS-2-radio
8363: PPUSH
8364: CALL_OW 88
// SayRadio ( Lynch , DDelta-2-radio-s ) ;
8368: LD_EXP 20
8372: PPUSH
8373: LD_STRING DDelta-2-radio-s
8375: PPUSH
8376: CALL_OW 94
// Say ( Sophia , DS-3-radio ) ;
8380: LD_EXP 29
8384: PPUSH
8385: LD_STRING DS-3-radio
8387: PPUSH
8388: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio-s ) ;
8392: LD_EXP 20
8396: PPUSH
8397: LD_STRING DDelta-3-radio-s
8399: PPUSH
8400: CALL_OW 94
// Say ( Sophia , DS-4-radio-s ) ;
8404: LD_EXP 29
8408: PPUSH
8409: LD_STRING DS-4-radio-s
8411: PPUSH
8412: CALL_OW 88
// dwait ( 0 0$01 ) ;
8416: LD_INT 35
8418: PPUSH
8419: CALL_OW 68
// Say ( Heike , DH-1-trap ) ;
8423: LD_EXP 23
8427: PPUSH
8428: LD_STRING DH-1-trap
8430: PPUSH
8431: CALL_OW 88
// trap := 0 ;
8435: LD_ADDR_EXP 17
8439: PUSH
8440: LD_INT 0
8442: ST_TO_ADDR
// end ; DialogueOff ;
8443: CALL_OW 7
// end ; 2 :
8447: GO 8467
8449: LD_INT 2
8451: DOUBLE
8452: EQUAL
8453: IFTRUE 8457
8455: GO 8466
8457: POP
// begin DialogueOff ;
8458: CALL_OW 7
// exit ;
8462: GO 9356
// end ; end ;
8464: GO 8467
8466: POP
// if trap = 1 then
8467: LD_EXP 17
8471: PUSH
8472: LD_INT 1
8474: EQUAL
8475: IFFALSE 8927
// begin PlaceSeeing ( 64 , 32 , 2 , 8 ) ;
8477: LD_INT 64
8479: PPUSH
8480: LD_INT 32
8482: PPUSH
8483: LD_INT 2
8485: PPUSH
8486: LD_INT 8
8488: PPUSH
8489: CALL_OW 330
// CenterOnXY ( 64 , 32 ) ;
8493: LD_INT 64
8495: PPUSH
8496: LD_INT 32
8498: PPUSH
8499: CALL_OW 84
// tmp := [ ] ;
8503: LD_ADDR_VAR 0 3
8507: PUSH
8508: EMPTY
8509: ST_TO_ADDR
// k := 3 ;
8510: LD_ADDR_VAR 0 2
8514: PUSH
8515: LD_INT 3
8517: ST_TO_ADDR
// if usForces < 3 then
8518: LD_EXP 21
8522: PUSH
8523: LD_INT 3
8525: LESS
8526: IFFALSE 8538
// k := usForces ;
8528: LD_ADDR_VAR 0 2
8532: PUSH
8533: LD_EXP 21
8537: ST_TO_ADDR
// for i := 1 to k do
8538: LD_ADDR_VAR 0 1
8542: PUSH
8543: DOUBLE
8544: LD_INT 1
8546: DEC
8547: ST_TO_ADDR
8548: LD_VAR 0 2
8552: PUSH
8553: FOR_TO
8554: IFFALSE 8609
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8556: LD_ADDR_VAR 0 3
8560: PUSH
8561: LD_VAR 0 3
8565: PPUSH
8566: LD_VAR 0 3
8570: PUSH
8571: LD_INT 1
8573: PLUS
8574: PPUSH
8575: LD_EXP 21
8579: PUSH
8580: LD_INT 1
8582: ARRAY
8583: PPUSH
8584: CALL_OW 1
8588: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8589: LD_ADDR_EXP 21
8593: PUSH
8594: LD_EXP 21
8598: PPUSH
8599: LD_INT 1
8601: PPUSH
8602: CALL_OW 3
8606: ST_TO_ADDR
// end ;
8607: GO 8553
8609: POP
8610: POP
// usPatrol := tmp ;
8611: LD_ADDR_EXP 16
8615: PUSH
8616: LD_VAR 0 3
8620: ST_TO_ADDR
// for i in tmp do
8621: LD_ADDR_VAR 0 1
8625: PUSH
8626: LD_VAR 0 3
8630: PUSH
8631: FOR_IN
8632: IFFALSE 8762
// begin if IsInUnit ( i ) then
8634: LD_VAR 0 1
8638: PPUSH
8639: CALL_OW 310
8643: IFFALSE 8654
// ComExitBuilding ( i ) ;
8645: LD_VAR 0 1
8649: PPUSH
8650: CALL_OW 122
// AddComAgressiveMove ( i , 63 , 31 ) ;
8654: LD_VAR 0 1
8658: PPUSH
8659: LD_INT 63
8661: PPUSH
8662: LD_INT 31
8664: PPUSH
8665: CALL_OW 174
// AddComWait ( i , 0 0$2 ) ;
8669: LD_VAR 0 1
8673: PPUSH
8674: LD_INT 70
8676: PPUSH
8677: CALL_OW 202
// AddComAgressiveMove ( i , 103 , 43 ) ;
8681: LD_VAR 0 1
8685: PPUSH
8686: LD_INT 103
8688: PPUSH
8689: LD_INT 43
8691: PPUSH
8692: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8696: LD_VAR 0 1
8700: PPUSH
8701: LD_INT 105
8703: PPUSH
8704: CALL_OW 202
// if Difficulty > 1 then
8708: LD_OWVAR 67
8712: PUSH
8713: LD_INT 1
8715: GREATER
8716: IFFALSE 8733
// AddComAgressiveMove ( i , 114 , 69 ) ;
8718: LD_VAR 0 1
8722: PPUSH
8723: LD_INT 114
8725: PPUSH
8726: LD_INT 69
8728: PPUSH
8729: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8733: LD_VAR 0 1
8737: PPUSH
8738: LD_INT 105
8740: PPUSH
8741: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8745: LD_VAR 0 1
8749: PPUSH
8750: LD_INT 42
8752: PPUSH
8753: LD_INT 20
8755: PPUSH
8756: CALL_OW 174
// end ;
8760: GO 8631
8762: POP
8763: POP
// wait ( 0 0$8 ) ;
8764: LD_INT 280
8766: PPUSH
8767: CALL_OW 67
// RemoveSeeing ( 64 , 32 , 2 ) ;
8771: LD_INT 64
8773: PPUSH
8774: LD_INT 32
8776: PPUSH
8777: LD_INT 2
8779: PPUSH
8780: CALL_OW 331
// repeat wait ( 0 0$1 ) ;
8784: LD_INT 35
8786: PPUSH
8787: CALL_OW 67
// for i in tmp do
8791: LD_ADDR_VAR 0 1
8795: PUSH
8796: LD_VAR 0 3
8800: PUSH
8801: FOR_IN
8802: IFFALSE 8833
// if IsDead ( i ) then
8804: LD_VAR 0 1
8808: PPUSH
8809: CALL_OW 301
8813: IFFALSE 8831
// tmp := tmp diff i ;
8815: LD_ADDR_VAR 0 3
8819: PUSH
8820: LD_VAR 0 3
8824: PUSH
8825: LD_VAR 0 1
8829: DIFF
8830: ST_TO_ADDR
8831: GO 8801
8833: POP
8834: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8835: LD_VAR 0 3
8839: NOT
8840: PUSH
8841: LD_VAR 0 3
8845: PPUSH
8846: LD_INT 95
8848: PUSH
8849: LD_INT 7
8851: PUSH
8852: EMPTY
8853: LIST
8854: LIST
8855: PUSH
8856: LD_INT 3
8858: PUSH
8859: LD_INT 60
8861: PUSH
8862: EMPTY
8863: LIST
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 72
8877: PUSH
8878: LD_VAR 0 3
8882: EQUAL
8883: OR
8884: IFFALSE 8784
// if tmp then
8886: LD_VAR 0 3
8890: IFFALSE 8917
// begin usPatrol := [ ] ;
8892: LD_ADDR_EXP 16
8896: PUSH
8897: EMPTY
8898: ST_TO_ADDR
// usForces := usForces union tmp ;
8899: LD_ADDR_EXP 21
8903: PUSH
8904: LD_EXP 21
8908: PUSH
8909: LD_VAR 0 3
8913: UNION
8914: ST_TO_ADDR
// end else
8915: GO 8925
// trickyMove := true ;
8917: LD_ADDR_EXP 15
8921: PUSH
8922: LD_INT 1
8924: ST_TO_ADDR
// end else
8925: GO 9356
// begin tmp := [ ] ;
8927: LD_ADDR_VAR 0 3
8931: PUSH
8932: EMPTY
8933: ST_TO_ADDR
// k := 4 ;
8934: LD_ADDR_VAR 0 2
8938: PUSH
8939: LD_INT 4
8941: ST_TO_ADDR
// if usForces < 4 then
8942: LD_EXP 21
8946: PUSH
8947: LD_INT 4
8949: LESS
8950: IFFALSE 8962
// k := usForces ;
8952: LD_ADDR_VAR 0 2
8956: PUSH
8957: LD_EXP 21
8961: ST_TO_ADDR
// for i := 1 to k do
8962: LD_ADDR_VAR 0 1
8966: PUSH
8967: DOUBLE
8968: LD_INT 1
8970: DEC
8971: ST_TO_ADDR
8972: LD_VAR 0 2
8976: PUSH
8977: FOR_TO
8978: IFFALSE 9033
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8980: LD_ADDR_VAR 0 3
8984: PUSH
8985: LD_VAR 0 3
8989: PPUSH
8990: LD_VAR 0 3
8994: PUSH
8995: LD_INT 1
8997: PLUS
8998: PPUSH
8999: LD_EXP 21
9003: PUSH
9004: LD_INT 1
9006: ARRAY
9007: PPUSH
9008: CALL_OW 1
9012: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
9013: LD_ADDR_EXP 21
9017: PUSH
9018: LD_EXP 21
9022: PPUSH
9023: LD_INT 1
9025: PPUSH
9026: CALL_OW 3
9030: ST_TO_ADDR
// end ;
9031: GO 8977
9033: POP
9034: POP
// if Lynch then
9035: LD_EXP 20
9039: IFFALSE 9057
// tmp := tmp ^ Lynch ;
9041: LD_ADDR_VAR 0 3
9045: PUSH
9046: LD_VAR 0 3
9050: PUSH
9051: LD_EXP 20
9055: ADD
9056: ST_TO_ADDR
// usPatrol := tmp ;
9057: LD_ADDR_EXP 16
9061: PUSH
9062: LD_VAR 0 3
9066: ST_TO_ADDR
// for i in tmp do
9067: LD_ADDR_VAR 0 1
9071: PUSH
9072: LD_VAR 0 3
9076: PUSH
9077: FOR_IN
9078: IFFALSE 9171
// begin if IsInUnit ( i ) then
9080: LD_VAR 0 1
9084: PPUSH
9085: CALL_OW 310
9089: IFFALSE 9100
// ComExitBuilding ( i ) ;
9091: LD_VAR 0 1
9095: PPUSH
9096: CALL_OW 122
// AddComAgressiveMove ( i , 69 , 15 ) ;
9100: LD_VAR 0 1
9104: PPUSH
9105: LD_INT 69
9107: PPUSH
9108: LD_INT 15
9110: PPUSH
9111: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
9115: LD_VAR 0 1
9119: PPUSH
9120: LD_INT 700
9122: PPUSH
9123: CALL_OW 202
// AddComAgressiveMove ( i , 55 , 43 ) ;
9127: LD_VAR 0 1
9131: PPUSH
9132: LD_INT 55
9134: PPUSH
9135: LD_INT 43
9137: PPUSH
9138: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
9142: LD_VAR 0 1
9146: PPUSH
9147: LD_INT 700
9149: PPUSH
9150: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
9154: LD_VAR 0 1
9158: PPUSH
9159: LD_INT 42
9161: PPUSH
9162: LD_INT 20
9164: PPUSH
9165: CALL_OW 174
// end ;
9169: GO 9077
9171: POP
9172: POP
// repeat wait ( 0 0$1 ) ;
9173: LD_INT 35
9175: PPUSH
9176: CALL_OW 67
// for i in tmp do
9180: LD_ADDR_VAR 0 1
9184: PUSH
9185: LD_VAR 0 3
9189: PUSH
9190: FOR_IN
9191: IFFALSE 9222
// if IsDead ( i ) then
9193: LD_VAR 0 1
9197: PPUSH
9198: CALL_OW 301
9202: IFFALSE 9220
// tmp := tmp diff i ;
9204: LD_ADDR_VAR 0 3
9208: PUSH
9209: LD_VAR 0 3
9213: PUSH
9214: LD_VAR 0 1
9218: DIFF
9219: ST_TO_ADDR
9220: GO 9190
9222: POP
9223: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
9224: LD_VAR 0 3
9228: NOT
9229: PUSH
9230: LD_VAR 0 3
9234: PPUSH
9235: LD_INT 95
9237: PUSH
9238: LD_INT 7
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PUSH
9245: LD_INT 3
9247: PUSH
9248: LD_INT 60
9250: PUSH
9251: EMPTY
9252: LIST
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: EMPTY
9259: LIST
9260: LIST
9261: PPUSH
9262: CALL_OW 72
9266: PUSH
9267: LD_VAR 0 3
9271: EQUAL
9272: OR
9273: IFFALSE 9173
// if not tmp then
9275: LD_VAR 0 3
9279: NOT
9280: IFFALSE 9292
// trickyMove := true else
9282: LD_ADDR_EXP 15
9286: PUSH
9287: LD_INT 1
9289: ST_TO_ADDR
9290: GO 9299
// usPatrol := [ ] ;
9292: LD_ADDR_EXP 16
9296: PUSH
9297: EMPTY
9298: ST_TO_ADDR
// if tmp diff Lynch then
9299: LD_VAR 0 3
9303: PUSH
9304: LD_EXP 20
9308: DIFF
9309: IFFALSE 9333
// usForces := usForces union ( tmp diff Lynch ) ;
9311: LD_ADDR_EXP 21
9315: PUSH
9316: LD_EXP 21
9320: PUSH
9321: LD_VAR 0 3
9325: PUSH
9326: LD_EXP 20
9330: DIFF
9331: UNION
9332: ST_TO_ADDR
// if IsOk ( Lynch ) then
9333: LD_EXP 20
9337: PPUSH
9338: CALL_OW 302
9342: IFFALSE 9356
// ComEnterUnit ( Lynch , Delta ) ;
9344: LD_EXP 20
9348: PPUSH
9349: LD_INT 1
9351: PPUSH
9352: CALL_OW 120
// end ; end ; end ;
9356: PPOPN 3
9358: END
// every 0 0$1 trigger trickyMove do
9359: LD_EXP 15
9363: IFFALSE 9375
9365: GO 9367
9367: DISABLE
// SetAchievement ( ACH_TRAP ) ;
9368: LD_STRING ACH_TRAP
9370: PPUSH
9371: CALL_OW 543
9375: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ) do
9376: LD_INT 22
9378: PUSH
9379: LD_INT 2
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: PUSH
9386: LD_INT 23
9388: PUSH
9389: LD_INT 1
9391: PUSH
9392: EMPTY
9393: LIST
9394: LIST
9395: PUSH
9396: LD_INT 21
9398: PUSH
9399: LD_INT 2
9401: PUSH
9402: EMPTY
9403: LIST
9404: LIST
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: LIST
9410: PPUSH
9411: CALL_OW 69
9415: IFFALSE 9427
9417: GO 9419
9419: DISABLE
// SetAchievement ( ACH_SCRAP ) ;
9420: LD_STRING ACH_SCRAP
9422: PPUSH
9423: CALL_OW 543
9427: END
// every 0 0$1 trigger UnitFilter ( usPatrol , [ f_see , 2 ] ) do
9428: LD_EXP 16
9432: PPUSH
9433: LD_INT 101
9435: PUSH
9436: LD_INT 2
9438: PUSH
9439: EMPTY
9440: LIST
9441: LIST
9442: PPUSH
9443: CALL_OW 72
9447: IFFALSE 9580
9449: GO 9451
9451: DISABLE
// begin if not trap then
9452: LD_EXP 17
9456: NOT
9457: IFFALSE 9485
// begin Say ( Heike , DH-2-trap ) ;
9459: LD_EXP 23
9463: PPUSH
9464: LD_STRING DH-2-trap
9466: PPUSH
9467: CALL_OW 88
// Say ( Mike , DM-2-trap ) ;
9471: LD_EXP 25
9475: PPUSH
9476: LD_STRING DM-2-trap
9478: PPUSH
9479: CALL_OW 88
// end else
9483: GO 9497
// begin Say ( Heike , DH-1-trap-a ) ;
9485: LD_EXP 23
9489: PPUSH
9490: LD_STRING DH-1-trap-a
9492: PPUSH
9493: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
9497: LD_INT 35
9499: PPUSH
9500: CALL_OW 67
// until trickyMove ;
9504: LD_EXP 15
9508: IFFALSE 9497
// Say ( Heike , DH-3-trap ) ;
9510: LD_EXP 23
9514: PPUSH
9515: LD_STRING DH-3-trap
9517: PPUSH
9518: CALL_OW 88
// if IsOk ( Givi ) and IsOk ( Kaia ) then
9522: LD_EXP 24
9526: PPUSH
9527: CALL_OW 302
9531: PUSH
9532: LD_EXP 28
9536: PPUSH
9537: CALL_OW 302
9541: AND
9542: IFFALSE 9580
// begin Say ( Givi , DG-3-trap ) ;
9544: LD_EXP 24
9548: PPUSH
9549: LD_STRING DG-3-trap
9551: PPUSH
9552: CALL_OW 88
// Say ( Kaia , DK-3-trap ) ;
9556: LD_EXP 28
9560: PPUSH
9561: LD_STRING DK-3-trap
9563: PPUSH
9564: CALL_OW 88
// Say ( Givi , DG-4-trap ) ;
9568: LD_EXP 24
9572: PPUSH
9573: LD_STRING DG-4-trap
9575: PPUSH
9576: CALL_OW 88
// end ; end ;
9580: END
// every 0 0$1 trigger GetSide ( Delta ) = 2 and attackDeltaAllowed do var i , tmp ;
9581: LD_INT 1
9583: PPUSH
9584: CALL_OW 255
9588: PUSH
9589: LD_INT 2
9591: EQUAL
9592: PUSH
9593: LD_EXP 14
9597: AND
9598: IFFALSE 9757
9600: GO 9602
9602: DISABLE
9603: LD_INT 0
9605: PPUSH
9606: PPUSH
// begin if not IsOk ( Kaia ) then
9607: LD_EXP 28
9611: PPUSH
9612: CALL_OW 302
9616: NOT
9617: IFFALSE 9621
// exit ;
9619: GO 9757
// if tick < 5 5$00 then
9621: LD_OWVAR 1
9625: PUSH
9626: LD_INT 10500
9628: LESS
9629: IFFALSE 9638
// SetAchievement ( ACH_DELTA ) ;
9631: LD_STRING ACH_DELTA
9633: PPUSH
9634: CALL_OW 543
// Say ( Kaia , DK-1-capture ) ;
9638: LD_EXP 28
9642: PPUSH
9643: LD_STRING DK-1-capture
9645: PPUSH
9646: CALL_OW 88
// Say ( Heike , DH-1-capture ) ;
9650: LD_EXP 23
9654: PPUSH
9655: LD_STRING DH-1-capture
9657: PPUSH
9658: CALL_OW 88
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
9662: LD_ADDR_VAR 0 2
9666: PUSH
9667: LD_INT 22
9669: PUSH
9670: LD_INT 1
9672: PUSH
9673: EMPTY
9674: LIST
9675: LIST
9676: PUSH
9677: LD_INT 25
9679: PUSH
9680: LD_INT 1
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: CALL_OW 69
9695: ST_TO_ADDR
// if not tmp then
9696: LD_VAR 0 2
9700: NOT
9701: IFFALSE 9705
// exit ;
9703: GO 9757
// for i in tmp do
9705: LD_ADDR_VAR 0 1
9709: PUSH
9710: LD_VAR 0 2
9714: PUSH
9715: FOR_IN
9716: IFFALSE 9755
// begin if IsInUnit ( i ) then
9718: LD_VAR 0 1
9722: PPUSH
9723: CALL_OW 310
9727: IFFALSE 9738
// ComExitBuilding ( i ) ;
9729: LD_VAR 0 1
9733: PPUSH
9734: CALL_OW 122
// AddComAgressiveMove ( i , 38 , 23 ) ;
9738: LD_VAR 0 1
9742: PPUSH
9743: LD_INT 38
9745: PPUSH
9746: LD_INT 23
9748: PPUSH
9749: CALL_OW 174
// end ;
9753: GO 9715
9755: POP
9756: POP
// end ;
9757: PPOPN 2
9759: END
// every 0 0$1 trigger GetSide ( usLab ) = 2 and attackDeltaAllowed do
9760: LD_INT 3
9762: PPUSH
9763: CALL_OW 255
9767: PUSH
9768: LD_INT 2
9770: EQUAL
9771: PUSH
9772: LD_EXP 14
9776: AND
9777: IFFALSE 9809
9779: GO 9781
9781: DISABLE
// begin DialogueOn ;
9782: CALL_OW 6
// Say ( Aviradze , DA-1-capture ) ;
9786: LD_EXP 27
9790: PPUSH
9791: LD_STRING DA-1-capture
9793: PPUSH
9794: CALL_OW 88
// DialogueOff ;
9798: CALL_OW 7
// ChangeMissionObjectives ( OTame ) ;
9802: LD_STRING OTame
9804: PPUSH
9805: CALL_OW 337
// end ;
9809: END
// every 0 0$1 trigger GetTech ( tech_ApeLang , 2 ) = state_researched and attackDeltaAllowed do
9810: LD_INT 1
9812: PPUSH
9813: LD_INT 2
9815: PPUSH
9816: CALL_OW 321
9820: PUSH
9821: LD_INT 2
9823: EQUAL
9824: PUSH
9825: LD_EXP 14
9829: AND
9830: IFFALSE 9977
9832: GO 9834
9834: DISABLE
// begin DialogueOn ;
9835: CALL_OW 6
// Say ( Aviradze , DA-1-ape ) ;
9839: LD_EXP 27
9843: PPUSH
9844: LD_STRING DA-1-ape
9846: PPUSH
9847: CALL_OW 88
// Say ( Heike , DH-1-ape ) ;
9851: LD_EXP 23
9855: PPUSH
9856: LD_STRING DH-1-ape
9858: PPUSH
9859: CALL_OW 88
// Say ( Aviradze , DA-2-ape ) ;
9863: LD_EXP 27
9867: PPUSH
9868: LD_STRING DA-2-ape
9870: PPUSH
9871: CALL_OW 88
// Say ( Aviradze , DA-3-ape ) ;
9875: LD_EXP 27
9879: PPUSH
9880: LD_STRING DA-3-ape
9882: PPUSH
9883: CALL_OW 88
// Say ( Heike , DH-3-ape ) ;
9887: LD_EXP 23
9891: PPUSH
9892: LD_STRING DH-3-ape
9894: PPUSH
9895: CALL_OW 88
// DialogueOff ;
9899: CALL_OW 7
// if FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) then
9903: LD_INT 22
9905: PUSH
9906: LD_INT 0
9908: PUSH
9909: EMPTY
9910: LIST
9911: LIST
9912: PUSH
9913: LD_INT 25
9915: PUSH
9916: LD_INT 12
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: PPUSH
9927: CALL_OW 69
9931: IFFALSE 9943
// SpawnApeman ( forest , 2 ) ;
9933: LD_INT 1
9935: PPUSH
9936: LD_INT 2
9938: PPUSH
9939: CALL 468 0 2
// repeat wait ( 0 0$1 ) ;
9943: LD_INT 35
9945: PPUSH
9946: CALL_OW 67
// until FilterAllUnits ( [ f_class , class_apeman ] ) = 0 ;
9950: LD_INT 25
9952: PUSH
9953: LD_INT 12
9955: PUSH
9956: EMPTY
9957: LIST
9958: LIST
9959: PPUSH
9960: CALL_OW 69
9964: PUSH
9965: LD_INT 0
9967: EQUAL
9968: IFFALSE 9943
// YouLost ( Ape ) ;
9970: LD_STRING Ape
9972: PPUSH
9973: CALL_OW 104
// end ;
9977: END
// every 0 0$5 trigger lostCounter >= [ 3 , 2 , 2 ] [ Difficulty ] do
9978: LD_EXP 18
9982: PUSH
9983: LD_INT 3
9985: PUSH
9986: LD_INT 2
9988: PUSH
9989: LD_INT 2
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: LIST
9996: PUSH
9997: LD_OWVAR 67
10001: ARRAY
10002: GREATEREQUAL
10003: IFFALSE 10047
10005: GO 10007
10007: DISABLE
// begin DialogueOn ;
10008: CALL_OW 6
// Say ( Aviradze , DA-1-failure ) ;
10012: LD_EXP 27
10016: PPUSH
10017: LD_STRING DA-1-failure
10019: PPUSH
10020: CALL_OW 88
// Say ( Aviradze , DA-2-failure ) ;
10024: LD_EXP 27
10028: PPUSH
10029: LD_STRING DA-2-failure
10031: PPUSH
10032: CALL_OW 88
// YouLost ( Failure ) ;
10036: LD_STRING Failure
10038: PPUSH
10039: CALL_OW 104
// DialogueOff ;
10043: CALL_OW 7
// end ;
10047: END
// every 0 0$1 trigger GetLives ( Kaia ) < 3 do
10048: LD_EXP 28
10052: PPUSH
10053: CALL_OW 256
10057: PUSH
10058: LD_INT 3
10060: LESS
10061: IFFALSE 10194
10063: GO 10065
10065: DISABLE
// begin DialogueOn ;
10066: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
10070: LD_EXP 28
10074: PPUSH
10075: CALL_OW 87
// ForceSay ( Kaia , DK-Kaiaout-1 ) ;
10079: LD_EXP 28
10083: PPUSH
10084: LD_STRING DK-Kaiaout-1
10086: PPUSH
10087: CALL_OW 91
// Say ( Heike , DH-Kaiaout-2 ) ;
10091: LD_EXP 23
10095: PPUSH
10096: LD_STRING DH-Kaiaout-2
10098: PPUSH
10099: CALL_OW 88
// Say ( Givi , DG-Kaiaout-3 ) ;
10103: LD_EXP 24
10107: PPUSH
10108: LD_STRING DG-Kaiaout-3
10110: PPUSH
10111: CALL_OW 88
// Say ( Heike , DH-Kaiaout-4 ) ;
10115: LD_EXP 23
10119: PPUSH
10120: LD_STRING DH-Kaiaout-4
10122: PPUSH
10123: CALL_OW 88
// if Givi then
10127: LD_EXP 24
10131: IFFALSE 10181
// begin Say ( Givi , DG-Kaiaout-5 ) ;
10133: LD_EXP 24
10137: PPUSH
10138: LD_STRING DG-Kaiaout-5
10140: PPUSH
10141: CALL_OW 88
// Say ( Heike , DH-Kaiaout-6 ) ;
10145: LD_EXP 23
10149: PPUSH
10150: LD_STRING DH-Kaiaout-6
10152: PPUSH
10153: CALL_OW 88
// Say ( Givi , DG-Kaiaout-7 ) ;
10157: LD_EXP 24
10161: PPUSH
10162: LD_STRING DG-Kaiaout-7
10164: PPUSH
10165: CALL_OW 88
// Say ( Heike , DH-Kaiaout-8 ) ;
10169: LD_EXP 23
10173: PPUSH
10174: LD_STRING DH-Kaiaout-8
10176: PPUSH
10177: CALL_OW 88
// end ; DialogueOff ;
10181: CALL_OW 7
// KillUnit ( Kaia ) ;
10185: LD_EXP 28
10189: PPUSH
10190: CALL_OW 66
// end ;
10194: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) and IsOk ( Aviradze ) and GetSide ( Aviradze ) = 2 do var tmp ;
10195: LD_INT 22
10197: PUSH
10198: LD_INT 2
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: PUSH
10205: LD_INT 23
10207: PUSH
10208: LD_INT 0
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: PPUSH
10219: CALL_OW 69
10223: PUSH
10224: LD_EXP 27
10228: PPUSH
10229: CALL_OW 302
10233: AND
10234: PUSH
10235: LD_EXP 27
10239: PPUSH
10240: CALL_OW 255
10244: PUSH
10245: LD_INT 2
10247: EQUAL
10248: AND
10249: IFFALSE 11021
10251: GO 10253
10253: DISABLE
10254: LD_INT 0
10256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
10257: LD_ADDR_VAR 0 1
10261: PUSH
10262: LD_INT 22
10264: PUSH
10265: LD_INT 2
10267: PUSH
10268: EMPTY
10269: LIST
10270: LIST
10271: PUSH
10272: LD_INT 23
10274: PUSH
10275: LD_INT 0
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: EMPTY
10283: LIST
10284: LIST
10285: PPUSH
10286: CALL_OW 69
10290: ST_TO_ADDR
// InGameOn ;
10291: CALL_OW 8
// CenterNowOnUnits ( tmp ) ;
10295: LD_VAR 0 1
10299: PPUSH
10300: CALL_OW 87
// ComMoveUnit ( tmp , Aviradze ) ;
10304: LD_VAR 0 1
10308: PPUSH
10309: LD_EXP 27
10313: PPUSH
10314: CALL_OW 112
// ComTurnUnit ( Aviradze , tmp ) ;
10318: LD_EXP 27
10322: PPUSH
10323: LD_VAR 0 1
10327: PPUSH
10328: CALL_OW 119
// wait ( 0 0$1 ) ;
10332: LD_INT 35
10334: PPUSH
10335: CALL_OW 67
// Say ( Aviradze , DA-1-tame-a ) ;
10339: LD_EXP 27
10343: PPUSH
10344: LD_STRING DA-1-tame-a
10346: PPUSH
10347: CALL_OW 88
// if IsOk ( Mike ) then
10351: LD_EXP 25
10355: PPUSH
10356: CALL_OW 302
10360: IFFALSE 10398
// begin Say ( Mike , DM-1-tame-a ) ;
10362: LD_EXP 25
10366: PPUSH
10367: LD_STRING DM-1-tame-a
10369: PPUSH
10370: CALL_OW 88
// Say ( Sophia , DS-1-tame-a ) ;
10374: LD_EXP 29
10378: PPUSH
10379: LD_STRING DS-1-tame-a
10381: PPUSH
10382: CALL_OW 88
// Say ( Mike , DM-2-tame-a ) ;
10386: LD_EXP 25
10390: PPUSH
10391: LD_STRING DM-2-tame-a
10393: PPUSH
10394: CALL_OW 88
// end ; wait ( 0 0$3 ) ;
10398: LD_INT 105
10400: PPUSH
10401: CALL_OW 67
// PrepareFarmer ;
10405: CALL 11696 0 0
// CenterOnUnits ( Farmer ) ;
10409: LD_EXP 31
10413: PPUSH
10414: CALL_OW 85
// ComMoveXY ( Farmer , 105 , 59 ) ;
10418: LD_EXP 31
10422: PPUSH
10423: LD_INT 105
10425: PPUSH
10426: LD_INT 59
10428: PPUSH
10429: CALL_OW 111
// AddComHold ( Farmer ) ;
10433: LD_EXP 31
10437: PPUSH
10438: CALL_OW 200
// SayRadio ( Farmer , DF-1-end ) ;
10442: LD_EXP 31
10446: PPUSH
10447: LD_STRING DF-1-end
10449: PPUSH
10450: CALL_OW 94
// Say ( Aviradze , DA-1-end ) ;
10454: LD_EXP 27
10458: PPUSH
10459: LD_STRING DA-1-end
10461: PPUSH
10462: CALL_OW 88
// SayRadio ( Farmer , DF-2-end ) ;
10466: LD_EXP 31
10470: PPUSH
10471: LD_STRING DF-2-end
10473: PPUSH
10474: CALL_OW 94
// Say ( Aviradze , DA-2-end ) ;
10478: LD_EXP 27
10482: PPUSH
10483: LD_STRING DA-2-end
10485: PPUSH
10486: CALL_OW 88
// SayRadio ( Farmer , DF-3-end ) ;
10490: LD_EXP 31
10494: PPUSH
10495: LD_STRING DF-3-end
10497: PPUSH
10498: CALL_OW 94
// Say ( Heike , DH-3-end ) ;
10502: LD_EXP 23
10506: PPUSH
10507: LD_STRING DH-3-end
10509: PPUSH
10510: CALL_OW 88
// SayRadio ( Farmer , DF-4-end ) ;
10514: LD_EXP 31
10518: PPUSH
10519: LD_STRING DF-4-end
10521: PPUSH
10522: CALL_OW 94
// if tick <= [ 25 25$00 , 24 24$00 , 23 23$00 ] [ Difficulty ] then
10526: LD_OWVAR 1
10530: PUSH
10531: LD_INT 52500
10533: PUSH
10534: LD_INT 50400
10536: PUSH
10537: LD_INT 48300
10539: PUSH
10540: EMPTY
10541: LIST
10542: LIST
10543: LIST
10544: PUSH
10545: LD_OWVAR 67
10549: ARRAY
10550: LESSEQUAL
10551: IFFALSE 10565
// AddMedal ( med1 , 1 ) else
10553: LD_STRING med1
10555: PPUSH
10556: LD_INT 1
10558: PPUSH
10559: CALL_OW 101
10563: GO 10576
// AddMedal ( med1 , - 1 ) ;
10565: LD_STRING med1
10567: PPUSH
10568: LD_INT 1
10570: NEG
10571: PPUSH
10572: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) = 0 and not gladstoneEscaped then
10576: LD_INT 22
10578: PUSH
10579: LD_INT 1
10581: PUSH
10582: EMPTY
10583: LIST
10584: LIST
10585: PUSH
10586: LD_INT 25
10588: PUSH
10589: LD_INT 4
10591: PUSH
10592: EMPTY
10593: LIST
10594: LIST
10595: PUSH
10596: EMPTY
10597: LIST
10598: LIST
10599: PPUSH
10600: CALL_OW 69
10604: PUSH
10605: LD_INT 0
10607: EQUAL
10608: PUSH
10609: LD_EXP 12
10613: NOT
10614: AND
10615: IFFALSE 10629
// AddMedal ( med2 , 1 ) else
10617: LD_STRING med2
10619: PPUSH
10620: LD_INT 1
10622: PPUSH
10623: CALL_OW 101
10627: GO 10640
// AddMedal ( med2 , - 1 ) ;
10629: LD_STRING med2
10631: PPUSH
10632: LD_INT 1
10634: NEG
10635: PPUSH
10636: CALL_OW 101
// if trickyMove then
10640: LD_EXP 15
10644: IFFALSE 10658
// AddMedal ( med3 , 1 ) else
10646: LD_STRING med3
10648: PPUSH
10649: LD_INT 1
10651: PPUSH
10652: CALL_OW 101
10656: GO 10688
// if spottedBeforeRadio then
10658: LD_EXP 6
10662: IFFALSE 10677
// AddMedal ( med3 , - 2 ) else
10664: LD_STRING med3
10666: PPUSH
10667: LD_INT 2
10669: NEG
10670: PPUSH
10671: CALL_OW 101
10675: GO 10688
// AddMedal ( med3 , - 1 ) ;
10677: LD_STRING med3
10679: PPUSH
10680: LD_INT 1
10682: NEG
10683: PPUSH
10684: CALL_OW 101
// GiveMedals ( MAIN ) ;
10688: LD_STRING MAIN
10690: PPUSH
10691: CALL_OW 102
// SaveCharacters ( tmp , 02_ape ) ;
10695: LD_VAR 0 1
10699: PPUSH
10700: LD_STRING 02_ape
10702: PPUSH
10703: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ;
10707: LD_ADDR_VAR 0 1
10711: PUSH
10712: LD_INT 22
10714: PUSH
10715: LD_INT 2
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PUSH
10722: LD_INT 23
10724: PUSH
10725: LD_INT 2
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 21
10734: PUSH
10735: LD_INT 1
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: LIST
10746: PPUSH
10747: CALL_OW 69
10751: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10752: LD_VAR 0 1
10756: PPUSH
10757: CALL_OW 43
// SaveCharacters ( Heike , 02_Heike ) ;
10761: LD_EXP 23
10765: PPUSH
10766: LD_STRING 02_Heike
10768: PPUSH
10769: CALL_OW 38
// SaveCharacters ( Aviradze , 02_Aviradze ) ;
10773: LD_EXP 27
10777: PPUSH
10778: LD_STRING 02_Aviradze
10780: PPUSH
10781: CALL_OW 38
// if Givi then
10785: LD_EXP 24
10789: IFFALSE 10803
// SaveCharacters ( Givi , 02_Givi ) ;
10791: LD_EXP 24
10795: PPUSH
10796: LD_STRING 02_Givi
10798: PPUSH
10799: CALL_OW 38
// if Mike then
10803: LD_EXP 25
10807: IFFALSE 10821
// SaveCharacters ( Mike , 02_Mike ) ;
10809: LD_EXP 25
10813: PPUSH
10814: LD_STRING 02_Mike
10816: PPUSH
10817: CALL_OW 38
// if Kamil then
10821: LD_EXP 26
10825: IFFALSE 10839
// SaveCharacters ( Kamil , 02_Kamil ) ;
10827: LD_EXP 26
10831: PPUSH
10832: LD_STRING 02_Kamil
10834: PPUSH
10835: CALL_OW 38
// if Kaia then
10839: LD_EXP 28
10843: IFFALSE 10857
// SaveCharacters ( Kaia , 02_Kaia ) ;
10845: LD_EXP 28
10849: PPUSH
10850: LD_STRING 02_Kaia
10852: PPUSH
10853: CALL_OW 38
// if Sophia then
10857: LD_EXP 29
10861: IFFALSE 10875
// SaveCharacters ( Sophia , 02_Sophia ) ;
10863: LD_EXP 29
10867: PPUSH
10868: LD_STRING 02_Sophia
10870: PPUSH
10871: CALL_OW 38
// if Markov then
10875: LD_EXP 30
10879: IFFALSE 10893
// SaveCharacters ( Markov , 02_Markov ) ;
10881: LD_EXP 30
10885: PPUSH
10886: LD_STRING 02_Markov
10888: PPUSH
10889: CALL_OW 38
// if tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] then
10893: LD_VAR 0 1
10897: PUSH
10898: LD_EXP 23
10902: PUSH
10903: LD_EXP 27
10907: PUSH
10908: LD_EXP 24
10912: PUSH
10913: LD_EXP 25
10917: PUSH
10918: LD_EXP 26
10922: PUSH
10923: LD_EXP 29
10927: PUSH
10928: LD_EXP 28
10932: PUSH
10933: LD_EXP 30
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: LIST
10945: LIST
10946: LIST
10947: DIFF
10948: IFFALSE 11013
// SaveCharacters ( tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] , 02_others ) ;
10950: LD_VAR 0 1
10954: PUSH
10955: LD_EXP 23
10959: PUSH
10960: LD_EXP 27
10964: PUSH
10965: LD_EXP 24
10969: PUSH
10970: LD_EXP 25
10974: PUSH
10975: LD_EXP 26
10979: PUSH
10980: LD_EXP 29
10984: PUSH
10985: LD_EXP 28
10989: PUSH
10990: LD_EXP 30
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: LIST
10999: LIST
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: DIFF
11005: PPUSH
11006: LD_STRING 02_others
11008: PPUSH
11009: CALL_OW 38
// YouWin ;
11013: CALL_OW 103
// InGameOff ;
11017: CALL_OW 9
// end ;
11021: PPOPN 1
11023: END
// every 0 0$1 trigger tick > timeUntilFarmer and aviradzeSpotted do
11024: LD_OWVAR 1
11028: PUSH
11029: LD_EXP 13
11033: GREATER
11034: PUSH
11035: LD_EXP 4
11039: AND
11040: IFFALSE 11080
11042: GO 11044
11044: DISABLE
// begin InGameOn ;
11045: CALL_OW 8
// PrepareFarmer ;
11049: CALL 11696 0 0
// CenterNowOnUnits ( Farmer ) ;
11053: LD_EXP 31
11057: PPUSH
11058: CALL_OW 87
// wait ( 0 0$2 ) ;
11062: LD_INT 70
11064: PPUSH
11065: CALL_OW 67
// YouLost ( Farmer ) ;
11069: LD_STRING Farmer
11071: PPUSH
11072: CALL_OW 104
// InGameOff ;
11076: CALL_OW 9
// end ; end_of_file
11080: END
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer ; export function PrepareArabian ; var un , veh ; begin
11081: LD_INT 0
11083: PPUSH
11084: PPUSH
11085: PPUSH
// uc_side := 2 ;
11086: LD_ADDR_OWVAR 20
11090: PUSH
11091: LD_INT 2
11093: ST_TO_ADDR
// uc_nation := 2 ;
11094: LD_ADDR_OWVAR 21
11098: PUSH
11099: LD_INT 2
11101: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
11102: LD_ADDR_EXP 23
11106: PUSH
11107: LD_STRING Heike
11109: PPUSH
11110: LD_EXP 1
11114: NOT
11115: PPUSH
11116: LD_EXP 2
11120: PPUSH
11121: CALL 237 0 3
11125: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
11126: LD_EXP 23
11130: PPUSH
11131: LD_INT 83
11133: PPUSH
11134: LD_INT 72
11136: PPUSH
11137: LD_INT 0
11139: PPUSH
11140: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
11144: LD_ADDR_EXP 24
11148: PUSH
11149: LD_STRING Givi
11151: PPUSH
11152: LD_EXP 1
11156: NOT
11157: PPUSH
11158: LD_EXP 2
11162: PPUSH
11163: CALL 237 0 3
11167: ST_TO_ADDR
// if Givi then
11168: LD_EXP 24
11172: IFFALSE 11192
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
11174: LD_EXP 24
11178: PPUSH
11179: LD_INT 87
11181: PPUSH
11182: LD_INT 76
11184: PPUSH
11185: LD_INT 0
11187: PPUSH
11188: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
11192: LD_ADDR_EXP 25
11196: PUSH
11197: LD_STRING Mike
11199: PPUSH
11200: LD_EXP 1
11204: NOT
11205: PPUSH
11206: LD_EXP 2
11210: PPUSH
11211: CALL 237 0 3
11215: ST_TO_ADDR
// if Mike then
11216: LD_EXP 25
11220: IFFALSE 11240
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
11222: LD_EXP 25
11226: PPUSH
11227: LD_INT 84
11229: PPUSH
11230: LD_INT 76
11232: PPUSH
11233: LD_INT 0
11235: PPUSH
11236: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
11240: LD_ADDR_EXP 26
11244: PUSH
11245: LD_STRING Kamil
11247: PPUSH
11248: LD_EXP 1
11252: NOT
11253: PPUSH
11254: LD_EXP 2
11258: PPUSH
11259: CALL 237 0 3
11263: ST_TO_ADDR
// if Kamil then
11264: LD_EXP 26
11268: IFFALSE 11288
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
11270: LD_EXP 26
11274: PPUSH
11275: LD_INT 85
11277: PPUSH
11278: LD_INT 78
11280: PPUSH
11281: LD_INT 0
11283: PPUSH
11284: CALL_OW 48
// uc_side := 5 ;
11288: LD_ADDR_OWVAR 20
11292: PUSH
11293: LD_INT 5
11295: ST_TO_ADDR
// uc_nation := 2 ;
11296: LD_ADDR_OWVAR 21
11300: PUSH
11301: LD_INT 2
11303: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , false ,  ) ;
11304: LD_ADDR_EXP 27
11308: PUSH
11309: LD_STRING Aviradze
11311: PPUSH
11312: LD_INT 0
11314: PPUSH
11315: LD_STRING 
11317: PPUSH
11318: CALL 237 0 3
11322: ST_TO_ADDR
// PlaceUnitXY ( Aviradze , 106 , 38 , false ) ;
11323: LD_EXP 27
11327: PPUSH
11328: LD_INT 106
11330: PPUSH
11331: LD_INT 38
11333: PPUSH
11334: LD_INT 0
11336: PPUSH
11337: CALL_OW 48
// ComTurnXY ( Aviradze , 103 , 38 ) ;
11341: LD_EXP 27
11345: PPUSH
11346: LD_INT 103
11348: PPUSH
11349: LD_INT 38
11351: PPUSH
11352: CALL_OW 118
// Kaia := PrepareUnit ( Kaia , false ,  ) ;
11356: LD_ADDR_EXP 28
11360: PUSH
11361: LD_STRING Kaia
11363: PPUSH
11364: LD_INT 0
11366: PPUSH
11367: LD_STRING 
11369: PPUSH
11370: CALL 237 0 3
11374: ST_TO_ADDR
// PlaceUnitXY ( Kaia , 100 , 34 , false ) ;
11375: LD_EXP 28
11379: PPUSH
11380: LD_INT 100
11382: PPUSH
11383: LD_INT 34
11385: PPUSH
11386: LD_INT 0
11388: PPUSH
11389: CALL_OW 48
// ComTurnXY ( Kaia , 100 , 39 ) ;
11393: LD_EXP 28
11397: PPUSH
11398: LD_INT 100
11400: PPUSH
11401: LD_INT 39
11403: PPUSH
11404: CALL_OW 118
// Sophia := PrepareUnit ( Sophia , false ,  ) ;
11408: LD_ADDR_EXP 29
11412: PUSH
11413: LD_STRING Sophia
11415: PPUSH
11416: LD_INT 0
11418: PPUSH
11419: LD_STRING 
11421: PPUSH
11422: CALL 237 0 3
11426: ST_TO_ADDR
// PlaceUnitXY ( Sophia , 109 , 50 , false ) ;
11427: LD_EXP 29
11431: PPUSH
11432: LD_INT 109
11434: PPUSH
11435: LD_INT 50
11437: PPUSH
11438: LD_INT 0
11440: PPUSH
11441: CALL_OW 48
// ComTurnXY ( Sophia , 100 , 39 ) ;
11445: LD_EXP 29
11449: PPUSH
11450: LD_INT 100
11452: PPUSH
11453: LD_INT 39
11455: PPUSH
11456: CALL_OW 118
// Markov := PrepareUnit ( Markov , false ,  ) ;
11460: LD_ADDR_EXP 30
11464: PUSH
11465: LD_STRING Markov
11467: PPUSH
11468: LD_INT 0
11470: PPUSH
11471: LD_STRING 
11473: PPUSH
11474: CALL 237 0 3
11478: ST_TO_ADDR
// PrepareTank ( 5 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , [ 90 , 70 , 60 ] [ Difficulty ] ) ;
11479: LD_INT 5
11481: PPUSH
11482: LD_INT 3
11484: PPUSH
11485: LD_INT 21
11487: PPUSH
11488: LD_INT 1
11490: PPUSH
11491: LD_INT 1
11493: PPUSH
11494: LD_INT 42
11496: PPUSH
11497: LD_INT 90
11499: PUSH
11500: LD_INT 70
11502: PUSH
11503: LD_INT 60
11505: PUSH
11506: EMPTY
11507: LIST
11508: LIST
11509: LIST
11510: PUSH
11511: LD_OWVAR 67
11515: ARRAY
11516: PPUSH
11517: CALL 300 0 7
// veh := CreateVehicle ;
11521: LD_ADDR_VAR 0 3
11525: PUSH
11526: CALL_OW 45
11530: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
11531: LD_VAR 0 3
11535: PPUSH
11536: LD_INT 4
11538: PPUSH
11539: CALL_OW 233
// PlaceUnitXY ( veh , 109 , 38 , false ) ;
11543: LD_VAR 0 3
11547: PPUSH
11548: LD_INT 109
11550: PPUSH
11551: LD_INT 38
11553: PPUSH
11554: LD_INT 0
11556: PPUSH
11557: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
11561: LD_EXP 30
11565: PPUSH
11566: LD_VAR 0 3
11570: PPUSH
11571: CALL_OW 52
// ComTurnUnit ( Kaia , Aviradze ) ;
11575: LD_EXP 28
11579: PPUSH
11580: LD_EXP 27
11584: PPUSH
11585: CALL_OW 119
// ComTurnUnit ( Aviradze , Kaia ) ;
11589: LD_EXP 27
11593: PPUSH
11594: LD_EXP 28
11598: PPUSH
11599: CALL_OW 119
// if not Givi or not Mike then
11603: LD_EXP 24
11607: NOT
11608: PUSH
11609: LD_EXP 25
11613: NOT
11614: OR
11615: IFFALSE 11691
// begin uc_nation := 2 ;
11617: LD_ADDR_OWVAR 21
11621: PUSH
11622: LD_INT 2
11624: ST_TO_ADDR
// uc_side := 5 ;
11625: LD_ADDR_OWVAR 20
11629: PUSH
11630: LD_INT 5
11632: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 1 ) ;
11633: LD_INT 1
11635: PPUSH
11636: LD_INT 1
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: CALL_OW 380
// un := CreateHuman ;
11646: LD_ADDR_VAR 0 2
11650: PUSH
11651: CALL_OW 44
11655: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 40 , 3 , false ) ;
11656: LD_VAR 0 2
11660: PPUSH
11661: LD_INT 112
11663: PPUSH
11664: LD_INT 40
11666: PPUSH
11667: LD_INT 3
11669: PPUSH
11670: LD_INT 0
11672: PPUSH
11673: CALL_OW 50
// ComTurnUnit ( un , Aviradze ) ;
11677: LD_VAR 0 2
11681: PPUSH
11682: LD_EXP 27
11686: PPUSH
11687: CALL_OW 119
// end ; end ;
11691: LD_VAR 0 1
11695: RET
// export function PrepareFarmer ; var i ; begin
11696: LD_INT 0
11698: PPUSH
11699: PPUSH
// uc_side := 5 ;
11700: LD_ADDR_OWVAR 20
11704: PUSH
11705: LD_INT 5
11707: ST_TO_ADDR
// uc_nation := 2 ;
11708: LD_ADDR_OWVAR 21
11712: PUSH
11713: LD_INT 2
11715: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
11716: LD_ADDR_EXP 31
11720: PUSH
11721: LD_STRING Farmer
11723: PPUSH
11724: LD_INT 0
11726: PPUSH
11727: LD_STRING 
11729: PPUSH
11730: CALL 237 0 3
11734: ST_TO_ADDR
// PlaceUnitXY ( Farmer , 106 , 62 , false ) ;
11735: LD_EXP 31
11739: PPUSH
11740: LD_INT 106
11742: PPUSH
11743: LD_INT 62
11745: PPUSH
11746: LD_INT 0
11748: PPUSH
11749: CALL_OW 48
// for i := 1 to 5 do
11753: LD_ADDR_VAR 0 2
11757: PUSH
11758: DOUBLE
11759: LD_INT 1
11761: DEC
11762: ST_TO_ADDR
11763: LD_INT 5
11765: PUSH
11766: FOR_TO
11767: IFFALSE 11805
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
11769: LD_INT 1
11771: PPUSH
11772: LD_INT 1
11774: PPUSH
11775: LD_INT 1
11777: PPUSH
11778: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 105 , 64 , 3 , false ) ;
11782: CALL_OW 44
11786: PPUSH
11787: LD_INT 105
11789: PPUSH
11790: LD_INT 64
11792: PPUSH
11793: LD_INT 3
11795: PPUSH
11796: LD_INT 0
11798: PPUSH
11799: CALL_OW 50
// end ;
11803: GO 11766
11805: POP
11806: POP
// end ; end_of_file
11807: LD_VAR 0 1
11811: RET
// every 2 2$20 + 0 0$10 do
11812: GO 11814
11814: DISABLE
// begin enable ;
11815: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , forest , true ) ;
11816: LD_INT 1
11818: PPUSH
11819: LD_INT 5
11821: PPUSH
11822: CALL_OW 12
11826: PPUSH
11827: LD_INT 1
11829: PPUSH
11830: LD_INT 1
11832: PPUSH
11833: CALL_OW 55
// if tick > 6 6$00 then
11837: LD_OWVAR 1
11841: PUSH
11842: LD_INT 12600
11844: GREATER
11845: IFFALSE 11848
// disable ;
11847: DISABLE
// end ; end_of_file
11848: END
// on UnitDestroyed ( un ) do begin if un = Heike then
11849: LD_VAR 0 1
11853: PUSH
11854: LD_EXP 23
11858: EQUAL
11859: IFFALSE 11868
// YouLost ( Heike ) ;
11861: LD_STRING Heike
11863: PPUSH
11864: CALL_OW 104
// if un = Aviradze then
11868: LD_VAR 0 1
11872: PUSH
11873: LD_EXP 27
11877: EQUAL
11878: IFFALSE 11887
// YouLost ( Aviradze ) ;
11880: LD_STRING Aviradze
11882: PPUSH
11883: CALL_OW 104
// if un = usLab then
11887: LD_VAR 0 1
11891: PUSH
11892: LD_INT 3
11894: EQUAL
11895: IFFALSE 11904
// YouLost ( Lab ) ;
11897: LD_STRING Lab
11899: PPUSH
11900: CALL_OW 104
// if ( un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) diff [ Heike , Aviradze ] ) and aviradzeSpotted then
11904: LD_VAR 0 1
11908: PUSH
11909: LD_INT 22
11911: PUSH
11912: LD_INT 2
11914: PUSH
11915: EMPTY
11916: LIST
11917: LIST
11918: PUSH
11919: LD_INT 21
11921: PUSH
11922: LD_INT 1
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PUSH
11929: LD_INT 23
11931: PUSH
11932: LD_INT 2
11934: PUSH
11935: EMPTY
11936: LIST
11937: LIST
11938: PUSH
11939: EMPTY
11940: LIST
11941: LIST
11942: LIST
11943: PPUSH
11944: CALL_OW 69
11948: PUSH
11949: LD_EXP 23
11953: PUSH
11954: LD_EXP 27
11958: PUSH
11959: EMPTY
11960: LIST
11961: LIST
11962: DIFF
11963: IN
11964: PUSH
11965: LD_EXP 4
11969: AND
11970: IFFALSE 11986
// lostCounter := lostCounter + 1 ;
11972: LD_ADDR_EXP 18
11976: PUSH
11977: LD_EXP 18
11981: PUSH
11982: LD_INT 1
11984: PLUS
11985: ST_TO_ADDR
// end ;
11986: PPOPN 1
11988: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_nation , 2 ] , [ f_class , 2 ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) = 0 do
11989: LD_INT 23
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: PUSH
11999: LD_INT 25
12001: PUSH
12002: LD_INT 2
12004: PUSH
12005: EMPTY
12006: LIST
12007: LIST
12008: PUSH
12009: EMPTY
12010: LIST
12011: LIST
12012: PPUSH
12013: CALL_OW 69
12017: PUSH
12018: LD_INT 0
12020: EQUAL
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_INT 2
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: LD_INT 21
12034: PUSH
12035: LD_INT 3
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: PPUSH
12046: CALL_OW 69
12050: PUSH
12051: LD_INT 0
12053: EQUAL
12054: AND
12055: IFFALSE 12067
12057: GO 12059
12059: DISABLE
// YouLost ( Eng ) ;
12060: LD_STRING Eng
12062: PPUSH
12063: CALL_OW 104
12067: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un in usSci and killerSide = 2 then
12068: LD_VAR 0 1
12072: PUSH
12073: LD_EXP 22
12077: IN
12078: PUSH
12079: LD_VAR 0 2
12083: PUSH
12084: LD_INT 2
12086: EQUAL
12087: AND
12088: IFFALSE 12120
// begin usSci := usSci diff un ;
12090: LD_ADDR_EXP 22
12094: PUSH
12095: LD_EXP 22
12099: PUSH
12100: LD_VAR 0 1
12104: DIFF
12105: ST_TO_ADDR
// sciCounterKill := sciCounterKill + 1 ;
12106: LD_ADDR_EXP 9
12110: PUSH
12111: LD_EXP 9
12115: PUSH
12116: LD_INT 1
12118: PLUS
12119: ST_TO_ADDR
// end ; end ;
12120: PPOPN 3
12122: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
12123: LD_VAR 0 1
12127: PUSH
12128: LD_INT 2
12130: EQUAL
12131: PUSH
12132: LD_VAR 0 2
12136: PUSH
12137: LD_INT 5
12139: EQUAL
12140: AND
12141: IFFALSE 12150
// YouLost ( FriendlyFire ) ;
12143: LD_STRING FriendlyFire
12145: PPUSH
12146: CALL_OW 104
// end ; end_of_file
12150: PPOPN 2
12152: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
12153: GO 12155
12155: DISABLE
// begin ru_radar := 98 ;
12156: LD_ADDR_EXP 32
12160: PUSH
12161: LD_INT 98
12163: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
12164: LD_ADDR_EXP 33
12168: PUSH
12169: LD_INT 89
12171: ST_TO_ADDR
// us_hack := 99 ;
12172: LD_ADDR_EXP 34
12176: PUSH
12177: LD_INT 99
12179: ST_TO_ADDR
// us_artillery := 97 ;
12180: LD_ADDR_EXP 35
12184: PUSH
12185: LD_INT 97
12187: ST_TO_ADDR
// ar_bio_bomb := 91 ;
12188: LD_ADDR_EXP 36
12192: PUSH
12193: LD_INT 91
12195: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
12196: LD_ADDR_EXP 37
12200: PUSH
12201: LD_INT 92
12203: ST_TO_ADDR
// tech_Artillery := 80 ;
12204: LD_ADDR_EXP 38
12208: PUSH
12209: LD_INT 80
12211: ST_TO_ADDR
// tech_RadMat := 81 ;
12212: LD_ADDR_EXP 39
12216: PUSH
12217: LD_INT 81
12219: ST_TO_ADDR
// tech_BasicTools := 82 ;
12220: LD_ADDR_EXP 40
12224: PUSH
12225: LD_INT 82
12227: ST_TO_ADDR
// tech_Cargo := 83 ;
12228: LD_ADDR_EXP 41
12232: PUSH
12233: LD_INT 83
12235: ST_TO_ADDR
// tech_Track := 84 ;
12236: LD_ADDR_EXP 42
12240: PUSH
12241: LD_INT 84
12243: ST_TO_ADDR
// tech_Crane := 85 ;
12244: LD_ADDR_EXP 43
12248: PUSH
12249: LD_INT 85
12251: ST_TO_ADDR
// tech_Bulldozer := 86 ;
12252: LD_ADDR_EXP 44
12256: PUSH
12257: LD_INT 86
12259: ST_TO_ADDR
// tech_Hovercraft := 87 ;
12260: LD_ADDR_EXP 45
12264: PUSH
12265: LD_INT 87
12267: ST_TO_ADDR
// end ; end_of_file end_of_file
12268: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
12269: GO 12271
12271: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
12272: LD_STRING initStreamRollete();
12274: PPUSH
12275: CALL_OW 559
// InitStreamMode ;
12279: CALL 12288 0 0
// DefineStreamItems ( ) ;
12283: CALL 12728 0 0
// end ;
12287: END
// function InitStreamMode ; begin
12288: LD_INT 0
12290: PPUSH
// streamModeActive := false ;
12291: LD_ADDR_EXP 46
12295: PUSH
12296: LD_INT 0
12298: ST_TO_ADDR
// normalCounter := 36 ;
12299: LD_ADDR_EXP 47
12303: PUSH
12304: LD_INT 36
12306: ST_TO_ADDR
// hardcoreCounter := 16 ;
12307: LD_ADDR_EXP 48
12311: PUSH
12312: LD_INT 16
12314: ST_TO_ADDR
// sRocket := false ;
12315: LD_ADDR_EXP 51
12319: PUSH
12320: LD_INT 0
12322: ST_TO_ADDR
// sSpeed := false ;
12323: LD_ADDR_EXP 50
12327: PUSH
12328: LD_INT 0
12330: ST_TO_ADDR
// sEngine := false ;
12331: LD_ADDR_EXP 52
12335: PUSH
12336: LD_INT 0
12338: ST_TO_ADDR
// sSpec := false ;
12339: LD_ADDR_EXP 49
12343: PUSH
12344: LD_INT 0
12346: ST_TO_ADDR
// sLevel := false ;
12347: LD_ADDR_EXP 53
12351: PUSH
12352: LD_INT 0
12354: ST_TO_ADDR
// sArmoury := false ;
12355: LD_ADDR_EXP 54
12359: PUSH
12360: LD_INT 0
12362: ST_TO_ADDR
// sRadar := false ;
12363: LD_ADDR_EXP 55
12367: PUSH
12368: LD_INT 0
12370: ST_TO_ADDR
// sBunker := false ;
12371: LD_ADDR_EXP 56
12375: PUSH
12376: LD_INT 0
12378: ST_TO_ADDR
// sHack := false ;
12379: LD_ADDR_EXP 57
12383: PUSH
12384: LD_INT 0
12386: ST_TO_ADDR
// sFire := false ;
12387: LD_ADDR_EXP 58
12391: PUSH
12392: LD_INT 0
12394: ST_TO_ADDR
// sRefresh := false ;
12395: LD_ADDR_EXP 59
12399: PUSH
12400: LD_INT 0
12402: ST_TO_ADDR
// sExp := false ;
12403: LD_ADDR_EXP 60
12407: PUSH
12408: LD_INT 0
12410: ST_TO_ADDR
// sDepot := false ;
12411: LD_ADDR_EXP 61
12415: PUSH
12416: LD_INT 0
12418: ST_TO_ADDR
// sFlag := false ;
12419: LD_ADDR_EXP 62
12423: PUSH
12424: LD_INT 0
12426: ST_TO_ADDR
// sKamikadze := false ;
12427: LD_ADDR_EXP 70
12431: PUSH
12432: LD_INT 0
12434: ST_TO_ADDR
// sTroll := false ;
12435: LD_ADDR_EXP 71
12439: PUSH
12440: LD_INT 0
12442: ST_TO_ADDR
// sSlow := false ;
12443: LD_ADDR_EXP 72
12447: PUSH
12448: LD_INT 0
12450: ST_TO_ADDR
// sLack := false ;
12451: LD_ADDR_EXP 73
12455: PUSH
12456: LD_INT 0
12458: ST_TO_ADDR
// sTank := false ;
12459: LD_ADDR_EXP 75
12463: PUSH
12464: LD_INT 0
12466: ST_TO_ADDR
// sRemote := false ;
12467: LD_ADDR_EXP 76
12471: PUSH
12472: LD_INT 0
12474: ST_TO_ADDR
// sPowell := false ;
12475: LD_ADDR_EXP 77
12479: PUSH
12480: LD_INT 0
12482: ST_TO_ADDR
// sTeleport := false ;
12483: LD_ADDR_EXP 80
12487: PUSH
12488: LD_INT 0
12490: ST_TO_ADDR
// sOilTower := false ;
12491: LD_ADDR_EXP 82
12495: PUSH
12496: LD_INT 0
12498: ST_TO_ADDR
// sShovel := false ;
12499: LD_ADDR_EXP 83
12503: PUSH
12504: LD_INT 0
12506: ST_TO_ADDR
// sSheik := false ;
12507: LD_ADDR_EXP 84
12511: PUSH
12512: LD_INT 0
12514: ST_TO_ADDR
// sEarthquake := false ;
12515: LD_ADDR_EXP 86
12519: PUSH
12520: LD_INT 0
12522: ST_TO_ADDR
// sAI := false ;
12523: LD_ADDR_EXP 87
12527: PUSH
12528: LD_INT 0
12530: ST_TO_ADDR
// sCargo := false ;
12531: LD_ADDR_EXP 90
12535: PUSH
12536: LD_INT 0
12538: ST_TO_ADDR
// sDLaser := false ;
12539: LD_ADDR_EXP 91
12543: PUSH
12544: LD_INT 0
12546: ST_TO_ADDR
// sExchange := false ;
12547: LD_ADDR_EXP 92
12551: PUSH
12552: LD_INT 0
12554: ST_TO_ADDR
// sFac := false ;
12555: LD_ADDR_EXP 93
12559: PUSH
12560: LD_INT 0
12562: ST_TO_ADDR
// sPower := false ;
12563: LD_ADDR_EXP 94
12567: PUSH
12568: LD_INT 0
12570: ST_TO_ADDR
// sRandom := false ;
12571: LD_ADDR_EXP 95
12575: PUSH
12576: LD_INT 0
12578: ST_TO_ADDR
// sShield := false ;
12579: LD_ADDR_EXP 96
12583: PUSH
12584: LD_INT 0
12586: ST_TO_ADDR
// sTime := false ;
12587: LD_ADDR_EXP 97
12591: PUSH
12592: LD_INT 0
12594: ST_TO_ADDR
// sTools := false ;
12595: LD_ADDR_EXP 98
12599: PUSH
12600: LD_INT 0
12602: ST_TO_ADDR
// sSold := false ;
12603: LD_ADDR_EXP 63
12607: PUSH
12608: LD_INT 0
12610: ST_TO_ADDR
// sDiff := false ;
12611: LD_ADDR_EXP 64
12615: PUSH
12616: LD_INT 0
12618: ST_TO_ADDR
// sFog := false ;
12619: LD_ADDR_EXP 67
12623: PUSH
12624: LD_INT 0
12626: ST_TO_ADDR
// sReset := false ;
12627: LD_ADDR_EXP 68
12631: PUSH
12632: LD_INT 0
12634: ST_TO_ADDR
// sSun := false ;
12635: LD_ADDR_EXP 69
12639: PUSH
12640: LD_INT 0
12642: ST_TO_ADDR
// sTiger := false ;
12643: LD_ADDR_EXP 65
12647: PUSH
12648: LD_INT 0
12650: ST_TO_ADDR
// sBomb := false ;
12651: LD_ADDR_EXP 66
12655: PUSH
12656: LD_INT 0
12658: ST_TO_ADDR
// sWound := false ;
12659: LD_ADDR_EXP 74
12663: PUSH
12664: LD_INT 0
12666: ST_TO_ADDR
// sBetray := false ;
12667: LD_ADDR_EXP 78
12671: PUSH
12672: LD_INT 0
12674: ST_TO_ADDR
// sContamin := false ;
12675: LD_ADDR_EXP 79
12679: PUSH
12680: LD_INT 0
12682: ST_TO_ADDR
// sOil := false ;
12683: LD_ADDR_EXP 81
12687: PUSH
12688: LD_INT 0
12690: ST_TO_ADDR
// sStu := false ;
12691: LD_ADDR_EXP 85
12695: PUSH
12696: LD_INT 0
12698: ST_TO_ADDR
// sBazooka := false ;
12699: LD_ADDR_EXP 88
12703: PUSH
12704: LD_INT 0
12706: ST_TO_ADDR
// sMortar := false ;
12707: LD_ADDR_EXP 89
12711: PUSH
12712: LD_INT 0
12714: ST_TO_ADDR
// sRanger := false ;
12715: LD_ADDR_EXP 99
12719: PUSH
12720: LD_INT 0
12722: ST_TO_ADDR
// end ;
12723: LD_VAR 0 1
12727: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
12728: LD_INT 0
12730: PPUSH
12731: PPUSH
12732: PPUSH
12733: PPUSH
12734: PPUSH
// result := [ ] ;
12735: LD_ADDR_VAR 0 1
12739: PUSH
12740: EMPTY
12741: ST_TO_ADDR
// if campaign_id = 1 then
12742: LD_OWVAR 69
12746: PUSH
12747: LD_INT 1
12749: EQUAL
12750: IFFALSE 15688
// begin case mission_number of 1 :
12752: LD_OWVAR 70
12756: PUSH
12757: LD_INT 1
12759: DOUBLE
12760: EQUAL
12761: IFTRUE 12765
12763: GO 12829
12765: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
12766: LD_ADDR_VAR 0 1
12770: PUSH
12771: LD_INT 2
12773: PUSH
12774: LD_INT 4
12776: PUSH
12777: LD_INT 11
12779: PUSH
12780: LD_INT 12
12782: PUSH
12783: LD_INT 15
12785: PUSH
12786: LD_INT 16
12788: PUSH
12789: LD_INT 22
12791: PUSH
12792: LD_INT 23
12794: PUSH
12795: LD_INT 26
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: PUSH
12809: LD_INT 101
12811: PUSH
12812: LD_INT 102
12814: PUSH
12815: LD_INT 106
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: LIST
12822: PUSH
12823: EMPTY
12824: LIST
12825: LIST
12826: ST_TO_ADDR
12827: GO 15686
12829: LD_INT 2
12831: DOUBLE
12832: EQUAL
12833: IFTRUE 12837
12835: GO 12909
12837: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
12838: LD_ADDR_VAR 0 1
12842: PUSH
12843: LD_INT 2
12845: PUSH
12846: LD_INT 4
12848: PUSH
12849: LD_INT 11
12851: PUSH
12852: LD_INT 12
12854: PUSH
12855: LD_INT 15
12857: PUSH
12858: LD_INT 16
12860: PUSH
12861: LD_INT 22
12863: PUSH
12864: LD_INT 23
12866: PUSH
12867: LD_INT 26
12869: PUSH
12870: EMPTY
12871: LIST
12872: LIST
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: LIST
12880: PUSH
12881: LD_INT 101
12883: PUSH
12884: LD_INT 102
12886: PUSH
12887: LD_INT 105
12889: PUSH
12890: LD_INT 106
12892: PUSH
12893: LD_INT 108
12895: PUSH
12896: EMPTY
12897: LIST
12898: LIST
12899: LIST
12900: LIST
12901: LIST
12902: PUSH
12903: EMPTY
12904: LIST
12905: LIST
12906: ST_TO_ADDR
12907: GO 15686
12909: LD_INT 3
12911: DOUBLE
12912: EQUAL
12913: IFTRUE 12917
12915: GO 12993
12917: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
12918: LD_ADDR_VAR 0 1
12922: PUSH
12923: LD_INT 2
12925: PUSH
12926: LD_INT 4
12928: PUSH
12929: LD_INT 5
12931: PUSH
12932: LD_INT 11
12934: PUSH
12935: LD_INT 12
12937: PUSH
12938: LD_INT 15
12940: PUSH
12941: LD_INT 16
12943: PUSH
12944: LD_INT 22
12946: PUSH
12947: LD_INT 26
12949: PUSH
12950: LD_INT 36
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: LIST
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: PUSH
12965: LD_INT 101
12967: PUSH
12968: LD_INT 102
12970: PUSH
12971: LD_INT 105
12973: PUSH
12974: LD_INT 106
12976: PUSH
12977: LD_INT 108
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: LIST
12984: LIST
12985: LIST
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: ST_TO_ADDR
12991: GO 15686
12993: LD_INT 4
12995: DOUBLE
12996: EQUAL
12997: IFTRUE 13001
12999: GO 13085
13001: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
13002: LD_ADDR_VAR 0 1
13006: PUSH
13007: LD_INT 2
13009: PUSH
13010: LD_INT 4
13012: PUSH
13013: LD_INT 5
13015: PUSH
13016: LD_INT 8
13018: PUSH
13019: LD_INT 11
13021: PUSH
13022: LD_INT 12
13024: PUSH
13025: LD_INT 15
13027: PUSH
13028: LD_INT 16
13030: PUSH
13031: LD_INT 22
13033: PUSH
13034: LD_INT 23
13036: PUSH
13037: LD_INT 26
13039: PUSH
13040: LD_INT 36
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: LIST
13056: PUSH
13057: LD_INT 101
13059: PUSH
13060: LD_INT 102
13062: PUSH
13063: LD_INT 105
13065: PUSH
13066: LD_INT 106
13068: PUSH
13069: LD_INT 108
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: LIST
13076: LIST
13077: LIST
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: ST_TO_ADDR
13083: GO 15686
13085: LD_INT 5
13087: DOUBLE
13088: EQUAL
13089: IFTRUE 13093
13091: GO 13193
13093: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
13094: LD_ADDR_VAR 0 1
13098: PUSH
13099: LD_INT 2
13101: PUSH
13102: LD_INT 4
13104: PUSH
13105: LD_INT 5
13107: PUSH
13108: LD_INT 6
13110: PUSH
13111: LD_INT 8
13113: PUSH
13114: LD_INT 11
13116: PUSH
13117: LD_INT 12
13119: PUSH
13120: LD_INT 15
13122: PUSH
13123: LD_INT 16
13125: PUSH
13126: LD_INT 22
13128: PUSH
13129: LD_INT 23
13131: PUSH
13132: LD_INT 25
13134: PUSH
13135: LD_INT 26
13137: PUSH
13138: LD_INT 36
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: LIST
13152: LIST
13153: LIST
13154: LIST
13155: LIST
13156: PUSH
13157: LD_INT 101
13159: PUSH
13160: LD_INT 102
13162: PUSH
13163: LD_INT 105
13165: PUSH
13166: LD_INT 106
13168: PUSH
13169: LD_INT 108
13171: PUSH
13172: LD_INT 109
13174: PUSH
13175: LD_INT 112
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: ST_TO_ADDR
13191: GO 15686
13193: LD_INT 6
13195: DOUBLE
13196: EQUAL
13197: IFTRUE 13201
13199: GO 13321
13201: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
13202: LD_ADDR_VAR 0 1
13206: PUSH
13207: LD_INT 2
13209: PUSH
13210: LD_INT 4
13212: PUSH
13213: LD_INT 5
13215: PUSH
13216: LD_INT 6
13218: PUSH
13219: LD_INT 8
13221: PUSH
13222: LD_INT 11
13224: PUSH
13225: LD_INT 12
13227: PUSH
13228: LD_INT 15
13230: PUSH
13231: LD_INT 16
13233: PUSH
13234: LD_INT 20
13236: PUSH
13237: LD_INT 21
13239: PUSH
13240: LD_INT 22
13242: PUSH
13243: LD_INT 23
13245: PUSH
13246: LD_INT 25
13248: PUSH
13249: LD_INT 26
13251: PUSH
13252: LD_INT 30
13254: PUSH
13255: LD_INT 31
13257: PUSH
13258: LD_INT 32
13260: PUSH
13261: LD_INT 36
13263: PUSH
13264: EMPTY
13265: LIST
13266: LIST
13267: LIST
13268: LIST
13269: LIST
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: LIST
13282: LIST
13283: LIST
13284: PUSH
13285: LD_INT 101
13287: PUSH
13288: LD_INT 102
13290: PUSH
13291: LD_INT 105
13293: PUSH
13294: LD_INT 106
13296: PUSH
13297: LD_INT 108
13299: PUSH
13300: LD_INT 109
13302: PUSH
13303: LD_INT 112
13305: PUSH
13306: EMPTY
13307: LIST
13308: LIST
13309: LIST
13310: LIST
13311: LIST
13312: LIST
13313: LIST
13314: PUSH
13315: EMPTY
13316: LIST
13317: LIST
13318: ST_TO_ADDR
13319: GO 15686
13321: LD_INT 7
13323: DOUBLE
13324: EQUAL
13325: IFTRUE 13329
13327: GO 13429
13329: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
13330: LD_ADDR_VAR 0 1
13334: PUSH
13335: LD_INT 2
13337: PUSH
13338: LD_INT 4
13340: PUSH
13341: LD_INT 5
13343: PUSH
13344: LD_INT 7
13346: PUSH
13347: LD_INT 11
13349: PUSH
13350: LD_INT 12
13352: PUSH
13353: LD_INT 15
13355: PUSH
13356: LD_INT 16
13358: PUSH
13359: LD_INT 20
13361: PUSH
13362: LD_INT 21
13364: PUSH
13365: LD_INT 22
13367: PUSH
13368: LD_INT 23
13370: PUSH
13371: LD_INT 25
13373: PUSH
13374: LD_INT 26
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: PUSH
13393: LD_INT 101
13395: PUSH
13396: LD_INT 102
13398: PUSH
13399: LD_INT 103
13401: PUSH
13402: LD_INT 105
13404: PUSH
13405: LD_INT 106
13407: PUSH
13408: LD_INT 108
13410: PUSH
13411: LD_INT 112
13413: PUSH
13414: EMPTY
13415: LIST
13416: LIST
13417: LIST
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: PUSH
13423: EMPTY
13424: LIST
13425: LIST
13426: ST_TO_ADDR
13427: GO 15686
13429: LD_INT 8
13431: DOUBLE
13432: EQUAL
13433: IFTRUE 13437
13435: GO 13565
13437: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
13438: LD_ADDR_VAR 0 1
13442: PUSH
13443: LD_INT 2
13445: PUSH
13446: LD_INT 4
13448: PUSH
13449: LD_INT 5
13451: PUSH
13452: LD_INT 6
13454: PUSH
13455: LD_INT 7
13457: PUSH
13458: LD_INT 8
13460: PUSH
13461: LD_INT 11
13463: PUSH
13464: LD_INT 12
13466: PUSH
13467: LD_INT 15
13469: PUSH
13470: LD_INT 16
13472: PUSH
13473: LD_INT 20
13475: PUSH
13476: LD_INT 21
13478: PUSH
13479: LD_INT 22
13481: PUSH
13482: LD_INT 23
13484: PUSH
13485: LD_INT 25
13487: PUSH
13488: LD_INT 26
13490: PUSH
13491: LD_INT 30
13493: PUSH
13494: LD_INT 31
13496: PUSH
13497: LD_INT 32
13499: PUSH
13500: LD_INT 36
13502: PUSH
13503: EMPTY
13504: LIST
13505: LIST
13506: LIST
13507: LIST
13508: LIST
13509: LIST
13510: LIST
13511: LIST
13512: LIST
13513: LIST
13514: LIST
13515: LIST
13516: LIST
13517: LIST
13518: LIST
13519: LIST
13520: LIST
13521: LIST
13522: LIST
13523: LIST
13524: PUSH
13525: LD_INT 101
13527: PUSH
13528: LD_INT 102
13530: PUSH
13531: LD_INT 103
13533: PUSH
13534: LD_INT 105
13536: PUSH
13537: LD_INT 106
13539: PUSH
13540: LD_INT 108
13542: PUSH
13543: LD_INT 109
13545: PUSH
13546: LD_INT 112
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: LIST
13553: LIST
13554: LIST
13555: LIST
13556: LIST
13557: LIST
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: ST_TO_ADDR
13563: GO 15686
13565: LD_INT 9
13567: DOUBLE
13568: EQUAL
13569: IFTRUE 13573
13571: GO 13709
13573: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
13574: LD_ADDR_VAR 0 1
13578: PUSH
13579: LD_INT 2
13581: PUSH
13582: LD_INT 4
13584: PUSH
13585: LD_INT 5
13587: PUSH
13588: LD_INT 6
13590: PUSH
13591: LD_INT 7
13593: PUSH
13594: LD_INT 8
13596: PUSH
13597: LD_INT 11
13599: PUSH
13600: LD_INT 12
13602: PUSH
13603: LD_INT 15
13605: PUSH
13606: LD_INT 16
13608: PUSH
13609: LD_INT 20
13611: PUSH
13612: LD_INT 21
13614: PUSH
13615: LD_INT 22
13617: PUSH
13618: LD_INT 23
13620: PUSH
13621: LD_INT 25
13623: PUSH
13624: LD_INT 26
13626: PUSH
13627: LD_INT 28
13629: PUSH
13630: LD_INT 30
13632: PUSH
13633: LD_INT 31
13635: PUSH
13636: LD_INT 32
13638: PUSH
13639: LD_INT 36
13641: PUSH
13642: EMPTY
13643: LIST
13644: LIST
13645: LIST
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: LIST
13651: LIST
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: LIST
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: LIST
13662: LIST
13663: LIST
13664: PUSH
13665: LD_INT 101
13667: PUSH
13668: LD_INT 102
13670: PUSH
13671: LD_INT 103
13673: PUSH
13674: LD_INT 105
13676: PUSH
13677: LD_INT 106
13679: PUSH
13680: LD_INT 108
13682: PUSH
13683: LD_INT 109
13685: PUSH
13686: LD_INT 112
13688: PUSH
13689: LD_INT 114
13691: PUSH
13692: EMPTY
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: PUSH
13703: EMPTY
13704: LIST
13705: LIST
13706: ST_TO_ADDR
13707: GO 15686
13709: LD_INT 10
13711: DOUBLE
13712: EQUAL
13713: IFTRUE 13717
13715: GO 13901
13717: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
13718: LD_ADDR_VAR 0 1
13722: PUSH
13723: LD_INT 2
13725: PUSH
13726: LD_INT 4
13728: PUSH
13729: LD_INT 5
13731: PUSH
13732: LD_INT 6
13734: PUSH
13735: LD_INT 7
13737: PUSH
13738: LD_INT 8
13740: PUSH
13741: LD_INT 9
13743: PUSH
13744: LD_INT 10
13746: PUSH
13747: LD_INT 11
13749: PUSH
13750: LD_INT 12
13752: PUSH
13753: LD_INT 13
13755: PUSH
13756: LD_INT 14
13758: PUSH
13759: LD_INT 15
13761: PUSH
13762: LD_INT 16
13764: PUSH
13765: LD_INT 17
13767: PUSH
13768: LD_INT 18
13770: PUSH
13771: LD_INT 19
13773: PUSH
13774: LD_INT 20
13776: PUSH
13777: LD_INT 21
13779: PUSH
13780: LD_INT 22
13782: PUSH
13783: LD_INT 23
13785: PUSH
13786: LD_INT 24
13788: PUSH
13789: LD_INT 25
13791: PUSH
13792: LD_INT 26
13794: PUSH
13795: LD_INT 28
13797: PUSH
13798: LD_INT 30
13800: PUSH
13801: LD_INT 31
13803: PUSH
13804: LD_INT 32
13806: PUSH
13807: LD_INT 36
13809: PUSH
13810: EMPTY
13811: LIST
13812: LIST
13813: LIST
13814: LIST
13815: LIST
13816: LIST
13817: LIST
13818: LIST
13819: LIST
13820: LIST
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: LIST
13829: LIST
13830: LIST
13831: LIST
13832: LIST
13833: LIST
13834: LIST
13835: LIST
13836: LIST
13837: LIST
13838: LIST
13839: LIST
13840: PUSH
13841: LD_INT 101
13843: PUSH
13844: LD_INT 102
13846: PUSH
13847: LD_INT 103
13849: PUSH
13850: LD_INT 104
13852: PUSH
13853: LD_INT 105
13855: PUSH
13856: LD_INT 106
13858: PUSH
13859: LD_INT 107
13861: PUSH
13862: LD_INT 108
13864: PUSH
13865: LD_INT 109
13867: PUSH
13868: LD_INT 110
13870: PUSH
13871: LD_INT 111
13873: PUSH
13874: LD_INT 112
13876: PUSH
13877: LD_INT 114
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: LIST
13893: LIST
13894: PUSH
13895: EMPTY
13896: LIST
13897: LIST
13898: ST_TO_ADDR
13899: GO 15686
13901: LD_INT 11
13903: DOUBLE
13904: EQUAL
13905: IFTRUE 13909
13907: GO 14101
13909: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
13910: LD_ADDR_VAR 0 1
13914: PUSH
13915: LD_INT 2
13917: PUSH
13918: LD_INT 3
13920: PUSH
13921: LD_INT 4
13923: PUSH
13924: LD_INT 5
13926: PUSH
13927: LD_INT 6
13929: PUSH
13930: LD_INT 7
13932: PUSH
13933: LD_INT 8
13935: PUSH
13936: LD_INT 9
13938: PUSH
13939: LD_INT 10
13941: PUSH
13942: LD_INT 11
13944: PUSH
13945: LD_INT 12
13947: PUSH
13948: LD_INT 13
13950: PUSH
13951: LD_INT 14
13953: PUSH
13954: LD_INT 15
13956: PUSH
13957: LD_INT 16
13959: PUSH
13960: LD_INT 17
13962: PUSH
13963: LD_INT 18
13965: PUSH
13966: LD_INT 19
13968: PUSH
13969: LD_INT 20
13971: PUSH
13972: LD_INT 21
13974: PUSH
13975: LD_INT 22
13977: PUSH
13978: LD_INT 23
13980: PUSH
13981: LD_INT 24
13983: PUSH
13984: LD_INT 25
13986: PUSH
13987: LD_INT 26
13989: PUSH
13990: LD_INT 28
13992: PUSH
13993: LD_INT 30
13995: PUSH
13996: LD_INT 31
13998: PUSH
13999: LD_INT 32
14001: PUSH
14002: LD_INT 34
14004: PUSH
14005: LD_INT 36
14007: PUSH
14008: EMPTY
14009: LIST
14010: LIST
14011: LIST
14012: LIST
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: LIST
14022: LIST
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: LIST
14036: LIST
14037: LIST
14038: LIST
14039: LIST
14040: PUSH
14041: LD_INT 101
14043: PUSH
14044: LD_INT 102
14046: PUSH
14047: LD_INT 103
14049: PUSH
14050: LD_INT 104
14052: PUSH
14053: LD_INT 105
14055: PUSH
14056: LD_INT 106
14058: PUSH
14059: LD_INT 107
14061: PUSH
14062: LD_INT 108
14064: PUSH
14065: LD_INT 109
14067: PUSH
14068: LD_INT 110
14070: PUSH
14071: LD_INT 111
14073: PUSH
14074: LD_INT 112
14076: PUSH
14077: LD_INT 114
14079: PUSH
14080: EMPTY
14081: LIST
14082: LIST
14083: LIST
14084: LIST
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: ST_TO_ADDR
14099: GO 15686
14101: LD_INT 12
14103: DOUBLE
14104: EQUAL
14105: IFTRUE 14109
14107: GO 14317
14109: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
14110: LD_ADDR_VAR 0 1
14114: PUSH
14115: LD_INT 1
14117: PUSH
14118: LD_INT 2
14120: PUSH
14121: LD_INT 3
14123: PUSH
14124: LD_INT 4
14126: PUSH
14127: LD_INT 5
14129: PUSH
14130: LD_INT 6
14132: PUSH
14133: LD_INT 7
14135: PUSH
14136: LD_INT 8
14138: PUSH
14139: LD_INT 9
14141: PUSH
14142: LD_INT 10
14144: PUSH
14145: LD_INT 11
14147: PUSH
14148: LD_INT 12
14150: PUSH
14151: LD_INT 13
14153: PUSH
14154: LD_INT 14
14156: PUSH
14157: LD_INT 15
14159: PUSH
14160: LD_INT 16
14162: PUSH
14163: LD_INT 17
14165: PUSH
14166: LD_INT 18
14168: PUSH
14169: LD_INT 19
14171: PUSH
14172: LD_INT 20
14174: PUSH
14175: LD_INT 21
14177: PUSH
14178: LD_INT 22
14180: PUSH
14181: LD_INT 23
14183: PUSH
14184: LD_INT 24
14186: PUSH
14187: LD_INT 25
14189: PUSH
14190: LD_INT 26
14192: PUSH
14193: LD_INT 27
14195: PUSH
14196: LD_INT 28
14198: PUSH
14199: LD_INT 30
14201: PUSH
14202: LD_INT 31
14204: PUSH
14205: LD_INT 32
14207: PUSH
14208: LD_INT 33
14210: PUSH
14211: LD_INT 34
14213: PUSH
14214: LD_INT 36
14216: PUSH
14217: EMPTY
14218: LIST
14219: LIST
14220: LIST
14221: LIST
14222: LIST
14223: LIST
14224: LIST
14225: LIST
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: LIST
14240: LIST
14241: LIST
14242: LIST
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: LIST
14250: LIST
14251: LIST
14252: PUSH
14253: LD_INT 101
14255: PUSH
14256: LD_INT 102
14258: PUSH
14259: LD_INT 103
14261: PUSH
14262: LD_INT 104
14264: PUSH
14265: LD_INT 105
14267: PUSH
14268: LD_INT 106
14270: PUSH
14271: LD_INT 107
14273: PUSH
14274: LD_INT 108
14276: PUSH
14277: LD_INT 109
14279: PUSH
14280: LD_INT 110
14282: PUSH
14283: LD_INT 111
14285: PUSH
14286: LD_INT 112
14288: PUSH
14289: LD_INT 113
14291: PUSH
14292: LD_INT 114
14294: PUSH
14295: EMPTY
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: LIST
14308: LIST
14309: LIST
14310: PUSH
14311: EMPTY
14312: LIST
14313: LIST
14314: ST_TO_ADDR
14315: GO 15686
14317: LD_INT 13
14319: DOUBLE
14320: EQUAL
14321: IFTRUE 14325
14323: GO 14521
14325: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
14326: LD_ADDR_VAR 0 1
14330: PUSH
14331: LD_INT 1
14333: PUSH
14334: LD_INT 2
14336: PUSH
14337: LD_INT 3
14339: PUSH
14340: LD_INT 4
14342: PUSH
14343: LD_INT 5
14345: PUSH
14346: LD_INT 8
14348: PUSH
14349: LD_INT 9
14351: PUSH
14352: LD_INT 10
14354: PUSH
14355: LD_INT 11
14357: PUSH
14358: LD_INT 12
14360: PUSH
14361: LD_INT 14
14363: PUSH
14364: LD_INT 15
14366: PUSH
14367: LD_INT 16
14369: PUSH
14370: LD_INT 17
14372: PUSH
14373: LD_INT 18
14375: PUSH
14376: LD_INT 19
14378: PUSH
14379: LD_INT 20
14381: PUSH
14382: LD_INT 21
14384: PUSH
14385: LD_INT 22
14387: PUSH
14388: LD_INT 23
14390: PUSH
14391: LD_INT 24
14393: PUSH
14394: LD_INT 25
14396: PUSH
14397: LD_INT 26
14399: PUSH
14400: LD_INT 27
14402: PUSH
14403: LD_INT 28
14405: PUSH
14406: LD_INT 30
14408: PUSH
14409: LD_INT 31
14411: PUSH
14412: LD_INT 32
14414: PUSH
14415: LD_INT 33
14417: PUSH
14418: LD_INT 34
14420: PUSH
14421: LD_INT 36
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: LIST
14428: LIST
14429: LIST
14430: LIST
14431: LIST
14432: LIST
14433: LIST
14434: LIST
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: LIST
14440: LIST
14441: LIST
14442: LIST
14443: LIST
14444: LIST
14445: LIST
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: LIST
14451: LIST
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: PUSH
14457: LD_INT 101
14459: PUSH
14460: LD_INT 102
14462: PUSH
14463: LD_INT 103
14465: PUSH
14466: LD_INT 104
14468: PUSH
14469: LD_INT 105
14471: PUSH
14472: LD_INT 106
14474: PUSH
14475: LD_INT 107
14477: PUSH
14478: LD_INT 108
14480: PUSH
14481: LD_INT 109
14483: PUSH
14484: LD_INT 110
14486: PUSH
14487: LD_INT 111
14489: PUSH
14490: LD_INT 112
14492: PUSH
14493: LD_INT 113
14495: PUSH
14496: LD_INT 114
14498: PUSH
14499: EMPTY
14500: LIST
14501: LIST
14502: LIST
14503: LIST
14504: LIST
14505: LIST
14506: LIST
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: PUSH
14515: EMPTY
14516: LIST
14517: LIST
14518: ST_TO_ADDR
14519: GO 15686
14521: LD_INT 14
14523: DOUBLE
14524: EQUAL
14525: IFTRUE 14529
14527: GO 14741
14529: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
14530: LD_ADDR_VAR 0 1
14534: PUSH
14535: LD_INT 1
14537: PUSH
14538: LD_INT 2
14540: PUSH
14541: LD_INT 3
14543: PUSH
14544: LD_INT 4
14546: PUSH
14547: LD_INT 5
14549: PUSH
14550: LD_INT 6
14552: PUSH
14553: LD_INT 7
14555: PUSH
14556: LD_INT 8
14558: PUSH
14559: LD_INT 9
14561: PUSH
14562: LD_INT 10
14564: PUSH
14565: LD_INT 11
14567: PUSH
14568: LD_INT 12
14570: PUSH
14571: LD_INT 13
14573: PUSH
14574: LD_INT 14
14576: PUSH
14577: LD_INT 15
14579: PUSH
14580: LD_INT 16
14582: PUSH
14583: LD_INT 17
14585: PUSH
14586: LD_INT 18
14588: PUSH
14589: LD_INT 19
14591: PUSH
14592: LD_INT 20
14594: PUSH
14595: LD_INT 21
14597: PUSH
14598: LD_INT 22
14600: PUSH
14601: LD_INT 23
14603: PUSH
14604: LD_INT 24
14606: PUSH
14607: LD_INT 25
14609: PUSH
14610: LD_INT 26
14612: PUSH
14613: LD_INT 27
14615: PUSH
14616: LD_INT 28
14618: PUSH
14619: LD_INT 29
14621: PUSH
14622: LD_INT 30
14624: PUSH
14625: LD_INT 31
14627: PUSH
14628: LD_INT 32
14630: PUSH
14631: LD_INT 33
14633: PUSH
14634: LD_INT 34
14636: PUSH
14637: LD_INT 36
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: LIST
14644: LIST
14645: LIST
14646: LIST
14647: LIST
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: LIST
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: LIST
14662: LIST
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 101
14679: PUSH
14680: LD_INT 102
14682: PUSH
14683: LD_INT 103
14685: PUSH
14686: LD_INT 104
14688: PUSH
14689: LD_INT 105
14691: PUSH
14692: LD_INT 106
14694: PUSH
14695: LD_INT 107
14697: PUSH
14698: LD_INT 108
14700: PUSH
14701: LD_INT 109
14703: PUSH
14704: LD_INT 110
14706: PUSH
14707: LD_INT 111
14709: PUSH
14710: LD_INT 112
14712: PUSH
14713: LD_INT 113
14715: PUSH
14716: LD_INT 114
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: LIST
14723: LIST
14724: LIST
14725: LIST
14726: LIST
14727: LIST
14728: LIST
14729: LIST
14730: LIST
14731: LIST
14732: LIST
14733: LIST
14734: PUSH
14735: EMPTY
14736: LIST
14737: LIST
14738: ST_TO_ADDR
14739: GO 15686
14741: LD_INT 15
14743: DOUBLE
14744: EQUAL
14745: IFTRUE 14749
14747: GO 14961
14749: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
14750: LD_ADDR_VAR 0 1
14754: PUSH
14755: LD_INT 1
14757: PUSH
14758: LD_INT 2
14760: PUSH
14761: LD_INT 3
14763: PUSH
14764: LD_INT 4
14766: PUSH
14767: LD_INT 5
14769: PUSH
14770: LD_INT 6
14772: PUSH
14773: LD_INT 7
14775: PUSH
14776: LD_INT 8
14778: PUSH
14779: LD_INT 9
14781: PUSH
14782: LD_INT 10
14784: PUSH
14785: LD_INT 11
14787: PUSH
14788: LD_INT 12
14790: PUSH
14791: LD_INT 13
14793: PUSH
14794: LD_INT 14
14796: PUSH
14797: LD_INT 15
14799: PUSH
14800: LD_INT 16
14802: PUSH
14803: LD_INT 17
14805: PUSH
14806: LD_INT 18
14808: PUSH
14809: LD_INT 19
14811: PUSH
14812: LD_INT 20
14814: PUSH
14815: LD_INT 21
14817: PUSH
14818: LD_INT 22
14820: PUSH
14821: LD_INT 23
14823: PUSH
14824: LD_INT 24
14826: PUSH
14827: LD_INT 25
14829: PUSH
14830: LD_INT 26
14832: PUSH
14833: LD_INT 27
14835: PUSH
14836: LD_INT 28
14838: PUSH
14839: LD_INT 29
14841: PUSH
14842: LD_INT 30
14844: PUSH
14845: LD_INT 31
14847: PUSH
14848: LD_INT 32
14850: PUSH
14851: LD_INT 33
14853: PUSH
14854: LD_INT 34
14856: PUSH
14857: LD_INT 36
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: LIST
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: LIST
14869: LIST
14870: LIST
14871: LIST
14872: LIST
14873: LIST
14874: LIST
14875: LIST
14876: LIST
14877: LIST
14878: LIST
14879: LIST
14880: LIST
14881: LIST
14882: LIST
14883: LIST
14884: LIST
14885: LIST
14886: LIST
14887: LIST
14888: LIST
14889: LIST
14890: LIST
14891: LIST
14892: LIST
14893: LIST
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 101
14899: PUSH
14900: LD_INT 102
14902: PUSH
14903: LD_INT 103
14905: PUSH
14906: LD_INT 104
14908: PUSH
14909: LD_INT 105
14911: PUSH
14912: LD_INT 106
14914: PUSH
14915: LD_INT 107
14917: PUSH
14918: LD_INT 108
14920: PUSH
14921: LD_INT 109
14923: PUSH
14924: LD_INT 110
14926: PUSH
14927: LD_INT 111
14929: PUSH
14930: LD_INT 112
14932: PUSH
14933: LD_INT 113
14935: PUSH
14936: LD_INT 114
14938: PUSH
14939: EMPTY
14940: LIST
14941: LIST
14942: LIST
14943: LIST
14944: LIST
14945: LIST
14946: LIST
14947: LIST
14948: LIST
14949: LIST
14950: LIST
14951: LIST
14952: LIST
14953: LIST
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: ST_TO_ADDR
14959: GO 15686
14961: LD_INT 16
14963: DOUBLE
14964: EQUAL
14965: IFTRUE 14969
14967: GO 15093
14969: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
14970: LD_ADDR_VAR 0 1
14974: PUSH
14975: LD_INT 2
14977: PUSH
14978: LD_INT 4
14980: PUSH
14981: LD_INT 5
14983: PUSH
14984: LD_INT 7
14986: PUSH
14987: LD_INT 11
14989: PUSH
14990: LD_INT 12
14992: PUSH
14993: LD_INT 15
14995: PUSH
14996: LD_INT 16
14998: PUSH
14999: LD_INT 20
15001: PUSH
15002: LD_INT 21
15004: PUSH
15005: LD_INT 22
15007: PUSH
15008: LD_INT 23
15010: PUSH
15011: LD_INT 25
15013: PUSH
15014: LD_INT 26
15016: PUSH
15017: LD_INT 30
15019: PUSH
15020: LD_INT 31
15022: PUSH
15023: LD_INT 32
15025: PUSH
15026: LD_INT 33
15028: PUSH
15029: LD_INT 34
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: PUSH
15053: LD_INT 101
15055: PUSH
15056: LD_INT 102
15058: PUSH
15059: LD_INT 103
15061: PUSH
15062: LD_INT 106
15064: PUSH
15065: LD_INT 108
15067: PUSH
15068: LD_INT 112
15070: PUSH
15071: LD_INT 113
15073: PUSH
15074: LD_INT 114
15076: PUSH
15077: EMPTY
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: LIST
15084: LIST
15085: LIST
15086: PUSH
15087: EMPTY
15088: LIST
15089: LIST
15090: ST_TO_ADDR
15091: GO 15686
15093: LD_INT 17
15095: DOUBLE
15096: EQUAL
15097: IFTRUE 15101
15099: GO 15313
15101: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
15102: LD_ADDR_VAR 0 1
15106: PUSH
15107: LD_INT 1
15109: PUSH
15110: LD_INT 2
15112: PUSH
15113: LD_INT 3
15115: PUSH
15116: LD_INT 4
15118: PUSH
15119: LD_INT 5
15121: PUSH
15122: LD_INT 6
15124: PUSH
15125: LD_INT 7
15127: PUSH
15128: LD_INT 8
15130: PUSH
15131: LD_INT 9
15133: PUSH
15134: LD_INT 10
15136: PUSH
15137: LD_INT 11
15139: PUSH
15140: LD_INT 12
15142: PUSH
15143: LD_INT 13
15145: PUSH
15146: LD_INT 14
15148: PUSH
15149: LD_INT 15
15151: PUSH
15152: LD_INT 16
15154: PUSH
15155: LD_INT 17
15157: PUSH
15158: LD_INT 18
15160: PUSH
15161: LD_INT 19
15163: PUSH
15164: LD_INT 20
15166: PUSH
15167: LD_INT 21
15169: PUSH
15170: LD_INT 22
15172: PUSH
15173: LD_INT 23
15175: PUSH
15176: LD_INT 24
15178: PUSH
15179: LD_INT 25
15181: PUSH
15182: LD_INT 26
15184: PUSH
15185: LD_INT 27
15187: PUSH
15188: LD_INT 28
15190: PUSH
15191: LD_INT 29
15193: PUSH
15194: LD_INT 30
15196: PUSH
15197: LD_INT 31
15199: PUSH
15200: LD_INT 32
15202: PUSH
15203: LD_INT 33
15205: PUSH
15206: LD_INT 34
15208: PUSH
15209: LD_INT 36
15211: PUSH
15212: EMPTY
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: LIST
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: PUSH
15249: LD_INT 101
15251: PUSH
15252: LD_INT 102
15254: PUSH
15255: LD_INT 103
15257: PUSH
15258: LD_INT 104
15260: PUSH
15261: LD_INT 105
15263: PUSH
15264: LD_INT 106
15266: PUSH
15267: LD_INT 107
15269: PUSH
15270: LD_INT 108
15272: PUSH
15273: LD_INT 109
15275: PUSH
15276: LD_INT 110
15278: PUSH
15279: LD_INT 111
15281: PUSH
15282: LD_INT 112
15284: PUSH
15285: LD_INT 113
15287: PUSH
15288: LD_INT 114
15290: PUSH
15291: EMPTY
15292: LIST
15293: LIST
15294: LIST
15295: LIST
15296: LIST
15297: LIST
15298: LIST
15299: LIST
15300: LIST
15301: LIST
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: PUSH
15307: EMPTY
15308: LIST
15309: LIST
15310: ST_TO_ADDR
15311: GO 15686
15313: LD_INT 18
15315: DOUBLE
15316: EQUAL
15317: IFTRUE 15321
15319: GO 15457
15321: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: LD_INT 2
15329: PUSH
15330: LD_INT 4
15332: PUSH
15333: LD_INT 5
15335: PUSH
15336: LD_INT 7
15338: PUSH
15339: LD_INT 11
15341: PUSH
15342: LD_INT 12
15344: PUSH
15345: LD_INT 15
15347: PUSH
15348: LD_INT 16
15350: PUSH
15351: LD_INT 20
15353: PUSH
15354: LD_INT 21
15356: PUSH
15357: LD_INT 22
15359: PUSH
15360: LD_INT 23
15362: PUSH
15363: LD_INT 25
15365: PUSH
15366: LD_INT 26
15368: PUSH
15369: LD_INT 30
15371: PUSH
15372: LD_INT 31
15374: PUSH
15375: LD_INT 32
15377: PUSH
15378: LD_INT 33
15380: PUSH
15381: LD_INT 34
15383: PUSH
15384: LD_INT 35
15386: PUSH
15387: LD_INT 36
15389: PUSH
15390: EMPTY
15391: LIST
15392: LIST
15393: LIST
15394: LIST
15395: LIST
15396: LIST
15397: LIST
15398: LIST
15399: LIST
15400: LIST
15401: LIST
15402: LIST
15403: LIST
15404: LIST
15405: LIST
15406: LIST
15407: LIST
15408: LIST
15409: LIST
15410: LIST
15411: LIST
15412: PUSH
15413: LD_INT 101
15415: PUSH
15416: LD_INT 102
15418: PUSH
15419: LD_INT 103
15421: PUSH
15422: LD_INT 106
15424: PUSH
15425: LD_INT 108
15427: PUSH
15428: LD_INT 112
15430: PUSH
15431: LD_INT 113
15433: PUSH
15434: LD_INT 114
15436: PUSH
15437: LD_INT 115
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: LIST
15444: LIST
15445: LIST
15446: LIST
15447: LIST
15448: LIST
15449: LIST
15450: PUSH
15451: EMPTY
15452: LIST
15453: LIST
15454: ST_TO_ADDR
15455: GO 15686
15457: LD_INT 19
15459: DOUBLE
15460: EQUAL
15461: IFTRUE 15465
15463: GO 15685
15465: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
15466: LD_ADDR_VAR 0 1
15470: PUSH
15471: LD_INT 1
15473: PUSH
15474: LD_INT 2
15476: PUSH
15477: LD_INT 3
15479: PUSH
15480: LD_INT 4
15482: PUSH
15483: LD_INT 5
15485: PUSH
15486: LD_INT 6
15488: PUSH
15489: LD_INT 7
15491: PUSH
15492: LD_INT 8
15494: PUSH
15495: LD_INT 9
15497: PUSH
15498: LD_INT 10
15500: PUSH
15501: LD_INT 11
15503: PUSH
15504: LD_INT 12
15506: PUSH
15507: LD_INT 13
15509: PUSH
15510: LD_INT 14
15512: PUSH
15513: LD_INT 15
15515: PUSH
15516: LD_INT 16
15518: PUSH
15519: LD_INT 17
15521: PUSH
15522: LD_INT 18
15524: PUSH
15525: LD_INT 19
15527: PUSH
15528: LD_INT 20
15530: PUSH
15531: LD_INT 21
15533: PUSH
15534: LD_INT 22
15536: PUSH
15537: LD_INT 23
15539: PUSH
15540: LD_INT 24
15542: PUSH
15543: LD_INT 25
15545: PUSH
15546: LD_INT 26
15548: PUSH
15549: LD_INT 27
15551: PUSH
15552: LD_INT 28
15554: PUSH
15555: LD_INT 29
15557: PUSH
15558: LD_INT 30
15560: PUSH
15561: LD_INT 31
15563: PUSH
15564: LD_INT 32
15566: PUSH
15567: LD_INT 33
15569: PUSH
15570: LD_INT 34
15572: PUSH
15573: LD_INT 35
15575: PUSH
15576: LD_INT 36
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: LIST
15596: LIST
15597: LIST
15598: LIST
15599: LIST
15600: LIST
15601: LIST
15602: LIST
15603: LIST
15604: LIST
15605: LIST
15606: LIST
15607: LIST
15608: LIST
15609: LIST
15610: LIST
15611: LIST
15612: LIST
15613: LIST
15614: LIST
15615: LIST
15616: PUSH
15617: LD_INT 101
15619: PUSH
15620: LD_INT 102
15622: PUSH
15623: LD_INT 103
15625: PUSH
15626: LD_INT 104
15628: PUSH
15629: LD_INT 105
15631: PUSH
15632: LD_INT 106
15634: PUSH
15635: LD_INT 107
15637: PUSH
15638: LD_INT 108
15640: PUSH
15641: LD_INT 109
15643: PUSH
15644: LD_INT 110
15646: PUSH
15647: LD_INT 111
15649: PUSH
15650: LD_INT 112
15652: PUSH
15653: LD_INT 113
15655: PUSH
15656: LD_INT 114
15658: PUSH
15659: LD_INT 115
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: LIST
15666: LIST
15667: LIST
15668: LIST
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: LIST
15677: LIST
15678: PUSH
15679: EMPTY
15680: LIST
15681: LIST
15682: ST_TO_ADDR
15683: GO 15686
15685: POP
// end else
15686: GO 15905
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
15688: LD_ADDR_VAR 0 1
15692: PUSH
15693: LD_INT 1
15695: PUSH
15696: LD_INT 2
15698: PUSH
15699: LD_INT 3
15701: PUSH
15702: LD_INT 4
15704: PUSH
15705: LD_INT 5
15707: PUSH
15708: LD_INT 6
15710: PUSH
15711: LD_INT 7
15713: PUSH
15714: LD_INT 8
15716: PUSH
15717: LD_INT 9
15719: PUSH
15720: LD_INT 10
15722: PUSH
15723: LD_INT 11
15725: PUSH
15726: LD_INT 12
15728: PUSH
15729: LD_INT 13
15731: PUSH
15732: LD_INT 14
15734: PUSH
15735: LD_INT 15
15737: PUSH
15738: LD_INT 16
15740: PUSH
15741: LD_INT 17
15743: PUSH
15744: LD_INT 18
15746: PUSH
15747: LD_INT 19
15749: PUSH
15750: LD_INT 20
15752: PUSH
15753: LD_INT 21
15755: PUSH
15756: LD_INT 22
15758: PUSH
15759: LD_INT 23
15761: PUSH
15762: LD_INT 24
15764: PUSH
15765: LD_INT 25
15767: PUSH
15768: LD_INT 26
15770: PUSH
15771: LD_INT 27
15773: PUSH
15774: LD_INT 28
15776: PUSH
15777: LD_INT 29
15779: PUSH
15780: LD_INT 30
15782: PUSH
15783: LD_INT 31
15785: PUSH
15786: LD_INT 32
15788: PUSH
15789: LD_INT 33
15791: PUSH
15792: LD_INT 34
15794: PUSH
15795: LD_INT 35
15797: PUSH
15798: LD_INT 36
15800: PUSH
15801: EMPTY
15802: LIST
15803: LIST
15804: LIST
15805: LIST
15806: LIST
15807: LIST
15808: LIST
15809: LIST
15810: LIST
15811: LIST
15812: LIST
15813: LIST
15814: LIST
15815: LIST
15816: LIST
15817: LIST
15818: LIST
15819: LIST
15820: LIST
15821: LIST
15822: LIST
15823: LIST
15824: LIST
15825: LIST
15826: LIST
15827: LIST
15828: LIST
15829: LIST
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: LIST
15835: LIST
15836: LIST
15837: LIST
15838: PUSH
15839: LD_INT 101
15841: PUSH
15842: LD_INT 102
15844: PUSH
15845: LD_INT 103
15847: PUSH
15848: LD_INT 104
15850: PUSH
15851: LD_INT 105
15853: PUSH
15854: LD_INT 106
15856: PUSH
15857: LD_INT 107
15859: PUSH
15860: LD_INT 108
15862: PUSH
15863: LD_INT 109
15865: PUSH
15866: LD_INT 110
15868: PUSH
15869: LD_INT 111
15871: PUSH
15872: LD_INT 112
15874: PUSH
15875: LD_INT 113
15877: PUSH
15878: LD_INT 114
15880: PUSH
15881: LD_INT 115
15883: PUSH
15884: EMPTY
15885: LIST
15886: LIST
15887: LIST
15888: LIST
15889: LIST
15890: LIST
15891: LIST
15892: LIST
15893: LIST
15894: LIST
15895: LIST
15896: LIST
15897: LIST
15898: LIST
15899: LIST
15900: PUSH
15901: EMPTY
15902: LIST
15903: LIST
15904: ST_TO_ADDR
// if result then
15905: LD_VAR 0 1
15909: IFFALSE 16198
// begin normal :=  ;
15911: LD_ADDR_VAR 0 3
15915: PUSH
15916: LD_STRING 
15918: ST_TO_ADDR
// hardcore :=  ;
15919: LD_ADDR_VAR 0 4
15923: PUSH
15924: LD_STRING 
15926: ST_TO_ADDR
// for i = 1 to normalCounter do
15927: LD_ADDR_VAR 0 5
15931: PUSH
15932: DOUBLE
15933: LD_INT 1
15935: DEC
15936: ST_TO_ADDR
15937: LD_EXP 47
15941: PUSH
15942: FOR_TO
15943: IFFALSE 16044
// begin tmp := 0 ;
15945: LD_ADDR_VAR 0 2
15949: PUSH
15950: LD_STRING 0
15952: ST_TO_ADDR
// if result [ 1 ] then
15953: LD_VAR 0 1
15957: PUSH
15958: LD_INT 1
15960: ARRAY
15961: IFFALSE 16026
// if result [ 1 ] [ 1 ] = i then
15963: LD_VAR 0 1
15967: PUSH
15968: LD_INT 1
15970: ARRAY
15971: PUSH
15972: LD_INT 1
15974: ARRAY
15975: PUSH
15976: LD_VAR 0 5
15980: EQUAL
15981: IFFALSE 16026
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
15983: LD_ADDR_VAR 0 1
15987: PUSH
15988: LD_VAR 0 1
15992: PPUSH
15993: LD_INT 1
15995: PPUSH
15996: LD_VAR 0 1
16000: PUSH
16001: LD_INT 1
16003: ARRAY
16004: PPUSH
16005: LD_INT 1
16007: PPUSH
16008: CALL_OW 3
16012: PPUSH
16013: CALL_OW 1
16017: ST_TO_ADDR
// tmp := 1 ;
16018: LD_ADDR_VAR 0 2
16022: PUSH
16023: LD_STRING 1
16025: ST_TO_ADDR
// end ; normal := normal & tmp ;
16026: LD_ADDR_VAR 0 3
16030: PUSH
16031: LD_VAR 0 3
16035: PUSH
16036: LD_VAR 0 2
16040: STR
16041: ST_TO_ADDR
// end ;
16042: GO 15942
16044: POP
16045: POP
// for i = 1 to hardcoreCounter do
16046: LD_ADDR_VAR 0 5
16050: PUSH
16051: DOUBLE
16052: LD_INT 1
16054: DEC
16055: ST_TO_ADDR
16056: LD_EXP 48
16060: PUSH
16061: FOR_TO
16062: IFFALSE 16167
// begin tmp := 0 ;
16064: LD_ADDR_VAR 0 2
16068: PUSH
16069: LD_STRING 0
16071: ST_TO_ADDR
// if result [ 2 ] then
16072: LD_VAR 0 1
16076: PUSH
16077: LD_INT 2
16079: ARRAY
16080: IFFALSE 16149
// if result [ 2 ] [ 1 ] = 100 + i then
16082: LD_VAR 0 1
16086: PUSH
16087: LD_INT 2
16089: ARRAY
16090: PUSH
16091: LD_INT 1
16093: ARRAY
16094: PUSH
16095: LD_INT 100
16097: PUSH
16098: LD_VAR 0 5
16102: PLUS
16103: EQUAL
16104: IFFALSE 16149
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
16106: LD_ADDR_VAR 0 1
16110: PUSH
16111: LD_VAR 0 1
16115: PPUSH
16116: LD_INT 2
16118: PPUSH
16119: LD_VAR 0 1
16123: PUSH
16124: LD_INT 2
16126: ARRAY
16127: PPUSH
16128: LD_INT 1
16130: PPUSH
16131: CALL_OW 3
16135: PPUSH
16136: CALL_OW 1
16140: ST_TO_ADDR
// tmp := 1 ;
16141: LD_ADDR_VAR 0 2
16145: PUSH
16146: LD_STRING 1
16148: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
16149: LD_ADDR_VAR 0 4
16153: PUSH
16154: LD_VAR 0 4
16158: PUSH
16159: LD_VAR 0 2
16163: STR
16164: ST_TO_ADDR
// end ;
16165: GO 16061
16167: POP
16168: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
16169: LD_STRING getStreamItemsFromMission("
16171: PUSH
16172: LD_VAR 0 3
16176: STR
16177: PUSH
16178: LD_STRING ","
16180: STR
16181: PUSH
16182: LD_VAR 0 4
16186: STR
16187: PUSH
16188: LD_STRING ")
16190: STR
16191: PPUSH
16192: CALL_OW 559
// end else
16196: GO 16205
// ToLua ( getStreamItemsFromMission("","") ) ;
16198: LD_STRING getStreamItemsFromMission("","")
16200: PPUSH
16201: CALL_OW 559
// end ;
16205: LD_VAR 0 1
16209: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
16210: LD_VAR 0 2
16214: PUSH
16215: LD_INT 100
16217: EQUAL
16218: IFFALSE 17167
// begin if not StreamModeActive then
16220: LD_EXP 46
16224: NOT
16225: IFFALSE 16235
// StreamModeActive := true ;
16227: LD_ADDR_EXP 46
16231: PUSH
16232: LD_INT 1
16234: ST_TO_ADDR
// if p3 = 0 then
16235: LD_VAR 0 3
16239: PUSH
16240: LD_INT 0
16242: EQUAL
16243: IFFALSE 16249
// InitStreamMode ;
16245: CALL 12288 0 0
// if p3 = 1 then
16249: LD_VAR 0 3
16253: PUSH
16254: LD_INT 1
16256: EQUAL
16257: IFFALSE 16267
// sRocket := true ;
16259: LD_ADDR_EXP 51
16263: PUSH
16264: LD_INT 1
16266: ST_TO_ADDR
// if p3 = 2 then
16267: LD_VAR 0 3
16271: PUSH
16272: LD_INT 2
16274: EQUAL
16275: IFFALSE 16285
// sSpeed := true ;
16277: LD_ADDR_EXP 50
16281: PUSH
16282: LD_INT 1
16284: ST_TO_ADDR
// if p3 = 3 then
16285: LD_VAR 0 3
16289: PUSH
16290: LD_INT 3
16292: EQUAL
16293: IFFALSE 16303
// sEngine := true ;
16295: LD_ADDR_EXP 52
16299: PUSH
16300: LD_INT 1
16302: ST_TO_ADDR
// if p3 = 4 then
16303: LD_VAR 0 3
16307: PUSH
16308: LD_INT 4
16310: EQUAL
16311: IFFALSE 16321
// sSpec := true ;
16313: LD_ADDR_EXP 49
16317: PUSH
16318: LD_INT 1
16320: ST_TO_ADDR
// if p3 = 5 then
16321: LD_VAR 0 3
16325: PUSH
16326: LD_INT 5
16328: EQUAL
16329: IFFALSE 16339
// sLevel := true ;
16331: LD_ADDR_EXP 53
16335: PUSH
16336: LD_INT 1
16338: ST_TO_ADDR
// if p3 = 6 then
16339: LD_VAR 0 3
16343: PUSH
16344: LD_INT 6
16346: EQUAL
16347: IFFALSE 16357
// sArmoury := true ;
16349: LD_ADDR_EXP 54
16353: PUSH
16354: LD_INT 1
16356: ST_TO_ADDR
// if p3 = 7 then
16357: LD_VAR 0 3
16361: PUSH
16362: LD_INT 7
16364: EQUAL
16365: IFFALSE 16375
// sRadar := true ;
16367: LD_ADDR_EXP 55
16371: PUSH
16372: LD_INT 1
16374: ST_TO_ADDR
// if p3 = 8 then
16375: LD_VAR 0 3
16379: PUSH
16380: LD_INT 8
16382: EQUAL
16383: IFFALSE 16393
// sBunker := true ;
16385: LD_ADDR_EXP 56
16389: PUSH
16390: LD_INT 1
16392: ST_TO_ADDR
// if p3 = 9 then
16393: LD_VAR 0 3
16397: PUSH
16398: LD_INT 9
16400: EQUAL
16401: IFFALSE 16411
// sHack := true ;
16403: LD_ADDR_EXP 57
16407: PUSH
16408: LD_INT 1
16410: ST_TO_ADDR
// if p3 = 10 then
16411: LD_VAR 0 3
16415: PUSH
16416: LD_INT 10
16418: EQUAL
16419: IFFALSE 16429
// sFire := true ;
16421: LD_ADDR_EXP 58
16425: PUSH
16426: LD_INT 1
16428: ST_TO_ADDR
// if p3 = 11 then
16429: LD_VAR 0 3
16433: PUSH
16434: LD_INT 11
16436: EQUAL
16437: IFFALSE 16447
// sRefresh := true ;
16439: LD_ADDR_EXP 59
16443: PUSH
16444: LD_INT 1
16446: ST_TO_ADDR
// if p3 = 12 then
16447: LD_VAR 0 3
16451: PUSH
16452: LD_INT 12
16454: EQUAL
16455: IFFALSE 16465
// sExp := true ;
16457: LD_ADDR_EXP 60
16461: PUSH
16462: LD_INT 1
16464: ST_TO_ADDR
// if p3 = 13 then
16465: LD_VAR 0 3
16469: PUSH
16470: LD_INT 13
16472: EQUAL
16473: IFFALSE 16483
// sDepot := true ;
16475: LD_ADDR_EXP 61
16479: PUSH
16480: LD_INT 1
16482: ST_TO_ADDR
// if p3 = 14 then
16483: LD_VAR 0 3
16487: PUSH
16488: LD_INT 14
16490: EQUAL
16491: IFFALSE 16501
// sFlag := true ;
16493: LD_ADDR_EXP 62
16497: PUSH
16498: LD_INT 1
16500: ST_TO_ADDR
// if p3 = 15 then
16501: LD_VAR 0 3
16505: PUSH
16506: LD_INT 15
16508: EQUAL
16509: IFFALSE 16519
// sKamikadze := true ;
16511: LD_ADDR_EXP 70
16515: PUSH
16516: LD_INT 1
16518: ST_TO_ADDR
// if p3 = 16 then
16519: LD_VAR 0 3
16523: PUSH
16524: LD_INT 16
16526: EQUAL
16527: IFFALSE 16537
// sTroll := true ;
16529: LD_ADDR_EXP 71
16533: PUSH
16534: LD_INT 1
16536: ST_TO_ADDR
// if p3 = 17 then
16537: LD_VAR 0 3
16541: PUSH
16542: LD_INT 17
16544: EQUAL
16545: IFFALSE 16555
// sSlow := true ;
16547: LD_ADDR_EXP 72
16551: PUSH
16552: LD_INT 1
16554: ST_TO_ADDR
// if p3 = 18 then
16555: LD_VAR 0 3
16559: PUSH
16560: LD_INT 18
16562: EQUAL
16563: IFFALSE 16573
// sLack := true ;
16565: LD_ADDR_EXP 73
16569: PUSH
16570: LD_INT 1
16572: ST_TO_ADDR
// if p3 = 19 then
16573: LD_VAR 0 3
16577: PUSH
16578: LD_INT 19
16580: EQUAL
16581: IFFALSE 16591
// sTank := true ;
16583: LD_ADDR_EXP 75
16587: PUSH
16588: LD_INT 1
16590: ST_TO_ADDR
// if p3 = 20 then
16591: LD_VAR 0 3
16595: PUSH
16596: LD_INT 20
16598: EQUAL
16599: IFFALSE 16609
// sRemote := true ;
16601: LD_ADDR_EXP 76
16605: PUSH
16606: LD_INT 1
16608: ST_TO_ADDR
// if p3 = 21 then
16609: LD_VAR 0 3
16613: PUSH
16614: LD_INT 21
16616: EQUAL
16617: IFFALSE 16627
// sPowell := true ;
16619: LD_ADDR_EXP 77
16623: PUSH
16624: LD_INT 1
16626: ST_TO_ADDR
// if p3 = 22 then
16627: LD_VAR 0 3
16631: PUSH
16632: LD_INT 22
16634: EQUAL
16635: IFFALSE 16645
// sTeleport := true ;
16637: LD_ADDR_EXP 80
16641: PUSH
16642: LD_INT 1
16644: ST_TO_ADDR
// if p3 = 23 then
16645: LD_VAR 0 3
16649: PUSH
16650: LD_INT 23
16652: EQUAL
16653: IFFALSE 16663
// sOilTower := true ;
16655: LD_ADDR_EXP 82
16659: PUSH
16660: LD_INT 1
16662: ST_TO_ADDR
// if p3 = 24 then
16663: LD_VAR 0 3
16667: PUSH
16668: LD_INT 24
16670: EQUAL
16671: IFFALSE 16681
// sShovel := true ;
16673: LD_ADDR_EXP 83
16677: PUSH
16678: LD_INT 1
16680: ST_TO_ADDR
// if p3 = 25 then
16681: LD_VAR 0 3
16685: PUSH
16686: LD_INT 25
16688: EQUAL
16689: IFFALSE 16699
// sSheik := true ;
16691: LD_ADDR_EXP 84
16695: PUSH
16696: LD_INT 1
16698: ST_TO_ADDR
// if p3 = 26 then
16699: LD_VAR 0 3
16703: PUSH
16704: LD_INT 26
16706: EQUAL
16707: IFFALSE 16717
// sEarthquake := true ;
16709: LD_ADDR_EXP 86
16713: PUSH
16714: LD_INT 1
16716: ST_TO_ADDR
// if p3 = 27 then
16717: LD_VAR 0 3
16721: PUSH
16722: LD_INT 27
16724: EQUAL
16725: IFFALSE 16735
// sAI := true ;
16727: LD_ADDR_EXP 87
16731: PUSH
16732: LD_INT 1
16734: ST_TO_ADDR
// if p3 = 28 then
16735: LD_VAR 0 3
16739: PUSH
16740: LD_INT 28
16742: EQUAL
16743: IFFALSE 16753
// sCargo := true ;
16745: LD_ADDR_EXP 90
16749: PUSH
16750: LD_INT 1
16752: ST_TO_ADDR
// if p3 = 29 then
16753: LD_VAR 0 3
16757: PUSH
16758: LD_INT 29
16760: EQUAL
16761: IFFALSE 16771
// sDLaser := true ;
16763: LD_ADDR_EXP 91
16767: PUSH
16768: LD_INT 1
16770: ST_TO_ADDR
// if p3 = 30 then
16771: LD_VAR 0 3
16775: PUSH
16776: LD_INT 30
16778: EQUAL
16779: IFFALSE 16789
// sExchange := true ;
16781: LD_ADDR_EXP 92
16785: PUSH
16786: LD_INT 1
16788: ST_TO_ADDR
// if p3 = 31 then
16789: LD_VAR 0 3
16793: PUSH
16794: LD_INT 31
16796: EQUAL
16797: IFFALSE 16807
// sFac := true ;
16799: LD_ADDR_EXP 93
16803: PUSH
16804: LD_INT 1
16806: ST_TO_ADDR
// if p3 = 32 then
16807: LD_VAR 0 3
16811: PUSH
16812: LD_INT 32
16814: EQUAL
16815: IFFALSE 16825
// sPower := true ;
16817: LD_ADDR_EXP 94
16821: PUSH
16822: LD_INT 1
16824: ST_TO_ADDR
// if p3 = 33 then
16825: LD_VAR 0 3
16829: PUSH
16830: LD_INT 33
16832: EQUAL
16833: IFFALSE 16843
// sRandom := true ;
16835: LD_ADDR_EXP 95
16839: PUSH
16840: LD_INT 1
16842: ST_TO_ADDR
// if p3 = 34 then
16843: LD_VAR 0 3
16847: PUSH
16848: LD_INT 34
16850: EQUAL
16851: IFFALSE 16861
// sShield := true ;
16853: LD_ADDR_EXP 96
16857: PUSH
16858: LD_INT 1
16860: ST_TO_ADDR
// if p3 = 35 then
16861: LD_VAR 0 3
16865: PUSH
16866: LD_INT 35
16868: EQUAL
16869: IFFALSE 16879
// sTime := true ;
16871: LD_ADDR_EXP 97
16875: PUSH
16876: LD_INT 1
16878: ST_TO_ADDR
// if p3 = 36 then
16879: LD_VAR 0 3
16883: PUSH
16884: LD_INT 36
16886: EQUAL
16887: IFFALSE 16897
// sTools := true ;
16889: LD_ADDR_EXP 98
16893: PUSH
16894: LD_INT 1
16896: ST_TO_ADDR
// if p3 = 101 then
16897: LD_VAR 0 3
16901: PUSH
16902: LD_INT 101
16904: EQUAL
16905: IFFALSE 16915
// sSold := true ;
16907: LD_ADDR_EXP 63
16911: PUSH
16912: LD_INT 1
16914: ST_TO_ADDR
// if p3 = 102 then
16915: LD_VAR 0 3
16919: PUSH
16920: LD_INT 102
16922: EQUAL
16923: IFFALSE 16933
// sDiff := true ;
16925: LD_ADDR_EXP 64
16929: PUSH
16930: LD_INT 1
16932: ST_TO_ADDR
// if p3 = 103 then
16933: LD_VAR 0 3
16937: PUSH
16938: LD_INT 103
16940: EQUAL
16941: IFFALSE 16951
// sFog := true ;
16943: LD_ADDR_EXP 67
16947: PUSH
16948: LD_INT 1
16950: ST_TO_ADDR
// if p3 = 104 then
16951: LD_VAR 0 3
16955: PUSH
16956: LD_INT 104
16958: EQUAL
16959: IFFALSE 16969
// sReset := true ;
16961: LD_ADDR_EXP 68
16965: PUSH
16966: LD_INT 1
16968: ST_TO_ADDR
// if p3 = 105 then
16969: LD_VAR 0 3
16973: PUSH
16974: LD_INT 105
16976: EQUAL
16977: IFFALSE 16987
// sSun := true ;
16979: LD_ADDR_EXP 69
16983: PUSH
16984: LD_INT 1
16986: ST_TO_ADDR
// if p3 = 106 then
16987: LD_VAR 0 3
16991: PUSH
16992: LD_INT 106
16994: EQUAL
16995: IFFALSE 17005
// sTiger := true ;
16997: LD_ADDR_EXP 65
17001: PUSH
17002: LD_INT 1
17004: ST_TO_ADDR
// if p3 = 107 then
17005: LD_VAR 0 3
17009: PUSH
17010: LD_INT 107
17012: EQUAL
17013: IFFALSE 17023
// sBomb := true ;
17015: LD_ADDR_EXP 66
17019: PUSH
17020: LD_INT 1
17022: ST_TO_ADDR
// if p3 = 108 then
17023: LD_VAR 0 3
17027: PUSH
17028: LD_INT 108
17030: EQUAL
17031: IFFALSE 17041
// sWound := true ;
17033: LD_ADDR_EXP 74
17037: PUSH
17038: LD_INT 1
17040: ST_TO_ADDR
// if p3 = 109 then
17041: LD_VAR 0 3
17045: PUSH
17046: LD_INT 109
17048: EQUAL
17049: IFFALSE 17059
// sBetray := true ;
17051: LD_ADDR_EXP 78
17055: PUSH
17056: LD_INT 1
17058: ST_TO_ADDR
// if p3 = 110 then
17059: LD_VAR 0 3
17063: PUSH
17064: LD_INT 110
17066: EQUAL
17067: IFFALSE 17077
// sContamin := true ;
17069: LD_ADDR_EXP 79
17073: PUSH
17074: LD_INT 1
17076: ST_TO_ADDR
// if p3 = 111 then
17077: LD_VAR 0 3
17081: PUSH
17082: LD_INT 111
17084: EQUAL
17085: IFFALSE 17095
// sOil := true ;
17087: LD_ADDR_EXP 81
17091: PUSH
17092: LD_INT 1
17094: ST_TO_ADDR
// if p3 = 112 then
17095: LD_VAR 0 3
17099: PUSH
17100: LD_INT 112
17102: EQUAL
17103: IFFALSE 17113
// sStu := true ;
17105: LD_ADDR_EXP 85
17109: PUSH
17110: LD_INT 1
17112: ST_TO_ADDR
// if p3 = 113 then
17113: LD_VAR 0 3
17117: PUSH
17118: LD_INT 113
17120: EQUAL
17121: IFFALSE 17131
// sBazooka := true ;
17123: LD_ADDR_EXP 88
17127: PUSH
17128: LD_INT 1
17130: ST_TO_ADDR
// if p3 = 114 then
17131: LD_VAR 0 3
17135: PUSH
17136: LD_INT 114
17138: EQUAL
17139: IFFALSE 17149
// sMortar := true ;
17141: LD_ADDR_EXP 89
17145: PUSH
17146: LD_INT 1
17148: ST_TO_ADDR
// if p3 = 115 then
17149: LD_VAR 0 3
17153: PUSH
17154: LD_INT 115
17156: EQUAL
17157: IFFALSE 17167
// sRanger := true ;
17159: LD_ADDR_EXP 99
17163: PUSH
17164: LD_INT 1
17166: ST_TO_ADDR
// end ; end ;
17167: PPOPN 6
17169: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
17170: LD_EXP 46
17174: PUSH
17175: LD_EXP 51
17179: AND
17180: IFFALSE 17304
17182: GO 17184
17184: DISABLE
17185: LD_INT 0
17187: PPUSH
17188: PPUSH
// begin enable ;
17189: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
17190: LD_ADDR_VAR 0 2
17194: PUSH
17195: LD_INT 22
17197: PUSH
17198: LD_OWVAR 2
17202: PUSH
17203: EMPTY
17204: LIST
17205: LIST
17206: PUSH
17207: LD_INT 2
17209: PUSH
17210: LD_INT 34
17212: PUSH
17213: LD_INT 7
17215: PUSH
17216: EMPTY
17217: LIST
17218: LIST
17219: PUSH
17220: LD_INT 34
17222: PUSH
17223: LD_INT 45
17225: PUSH
17226: EMPTY
17227: LIST
17228: LIST
17229: PUSH
17230: LD_INT 34
17232: PUSH
17233: LD_INT 28
17235: PUSH
17236: EMPTY
17237: LIST
17238: LIST
17239: PUSH
17240: LD_INT 34
17242: PUSH
17243: LD_INT 47
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: PUSH
17250: EMPTY
17251: LIST
17252: LIST
17253: LIST
17254: LIST
17255: LIST
17256: PUSH
17257: EMPTY
17258: LIST
17259: LIST
17260: PPUSH
17261: CALL_OW 69
17265: ST_TO_ADDR
// if not tmp then
17266: LD_VAR 0 2
17270: NOT
17271: IFFALSE 17275
// exit ;
17273: GO 17304
// for i in tmp do
17275: LD_ADDR_VAR 0 1
17279: PUSH
17280: LD_VAR 0 2
17284: PUSH
17285: FOR_IN
17286: IFFALSE 17302
// begin SetLives ( i , 0 ) ;
17288: LD_VAR 0 1
17292: PPUSH
17293: LD_INT 0
17295: PPUSH
17296: CALL_OW 234
// end ;
17300: GO 17285
17302: POP
17303: POP
// end ;
17304: PPOPN 2
17306: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
17307: LD_EXP 46
17311: PUSH
17312: LD_EXP 52
17316: AND
17317: IFFALSE 17401
17319: GO 17321
17321: DISABLE
17322: LD_INT 0
17324: PPUSH
17325: PPUSH
// begin enable ;
17326: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
17327: LD_ADDR_VAR 0 2
17331: PUSH
17332: LD_INT 22
17334: PUSH
17335: LD_OWVAR 2
17339: PUSH
17340: EMPTY
17341: LIST
17342: LIST
17343: PUSH
17344: LD_INT 32
17346: PUSH
17347: LD_INT 3
17349: PUSH
17350: EMPTY
17351: LIST
17352: LIST
17353: PUSH
17354: EMPTY
17355: LIST
17356: LIST
17357: PPUSH
17358: CALL_OW 69
17362: ST_TO_ADDR
// if not tmp then
17363: LD_VAR 0 2
17367: NOT
17368: IFFALSE 17372
// exit ;
17370: GO 17401
// for i in tmp do
17372: LD_ADDR_VAR 0 1
17376: PUSH
17377: LD_VAR 0 2
17381: PUSH
17382: FOR_IN
17383: IFFALSE 17399
// begin SetLives ( i , 0 ) ;
17385: LD_VAR 0 1
17389: PPUSH
17390: LD_INT 0
17392: PPUSH
17393: CALL_OW 234
// end ;
17397: GO 17382
17399: POP
17400: POP
// end ;
17401: PPOPN 2
17403: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
17404: LD_EXP 46
17408: PUSH
17409: LD_EXP 49
17413: AND
17414: IFFALSE 17507
17416: GO 17418
17418: DISABLE
17419: LD_INT 0
17421: PPUSH
// begin enable ;
17422: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
17423: LD_ADDR_VAR 0 1
17427: PUSH
17428: LD_INT 22
17430: PUSH
17431: LD_OWVAR 2
17435: PUSH
17436: EMPTY
17437: LIST
17438: LIST
17439: PUSH
17440: LD_INT 2
17442: PUSH
17443: LD_INT 25
17445: PUSH
17446: LD_INT 5
17448: PUSH
17449: EMPTY
17450: LIST
17451: LIST
17452: PUSH
17453: LD_INT 25
17455: PUSH
17456: LD_INT 9
17458: PUSH
17459: EMPTY
17460: LIST
17461: LIST
17462: PUSH
17463: LD_INT 25
17465: PUSH
17466: LD_INT 8
17468: PUSH
17469: EMPTY
17470: LIST
17471: LIST
17472: PUSH
17473: EMPTY
17474: LIST
17475: LIST
17476: LIST
17477: LIST
17478: PUSH
17479: EMPTY
17480: LIST
17481: LIST
17482: PPUSH
17483: CALL_OW 69
17487: PUSH
17488: FOR_IN
17489: IFFALSE 17505
// begin SetClass ( i , 1 ) ;
17491: LD_VAR 0 1
17495: PPUSH
17496: LD_INT 1
17498: PPUSH
17499: CALL_OW 336
// end ;
17503: GO 17488
17505: POP
17506: POP
// end ;
17507: PPOPN 1
17509: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
17510: LD_EXP 46
17514: PUSH
17515: LD_EXP 50
17519: AND
17520: PUSH
17521: LD_OWVAR 65
17525: PUSH
17526: LD_INT 7
17528: LESS
17529: AND
17530: IFFALSE 17544
17532: GO 17534
17534: DISABLE
// begin enable ;
17535: ENABLE
// game_speed := 7 ;
17536: LD_ADDR_OWVAR 65
17540: PUSH
17541: LD_INT 7
17543: ST_TO_ADDR
// end ;
17544: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
17545: LD_EXP 46
17549: PUSH
17550: LD_EXP 53
17554: AND
17555: IFFALSE 17757
17557: GO 17559
17559: DISABLE
17560: LD_INT 0
17562: PPUSH
17563: PPUSH
17564: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
17565: LD_ADDR_VAR 0 3
17569: PUSH
17570: LD_INT 81
17572: PUSH
17573: LD_OWVAR 2
17577: PUSH
17578: EMPTY
17579: LIST
17580: LIST
17581: PUSH
17582: LD_INT 21
17584: PUSH
17585: LD_INT 1
17587: PUSH
17588: EMPTY
17589: LIST
17590: LIST
17591: PUSH
17592: EMPTY
17593: LIST
17594: LIST
17595: PPUSH
17596: CALL_OW 69
17600: ST_TO_ADDR
// if not tmp then
17601: LD_VAR 0 3
17605: NOT
17606: IFFALSE 17610
// exit ;
17608: GO 17757
// if tmp > 5 then
17610: LD_VAR 0 3
17614: PUSH
17615: LD_INT 5
17617: GREATER
17618: IFFALSE 17630
// k := 5 else
17620: LD_ADDR_VAR 0 2
17624: PUSH
17625: LD_INT 5
17627: ST_TO_ADDR
17628: GO 17640
// k := tmp ;
17630: LD_ADDR_VAR 0 2
17634: PUSH
17635: LD_VAR 0 3
17639: ST_TO_ADDR
// for i := 1 to k do
17640: LD_ADDR_VAR 0 1
17644: PUSH
17645: DOUBLE
17646: LD_INT 1
17648: DEC
17649: ST_TO_ADDR
17650: LD_VAR 0 2
17654: PUSH
17655: FOR_TO
17656: IFFALSE 17755
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
17658: LD_VAR 0 3
17662: PUSH
17663: LD_VAR 0 1
17667: ARRAY
17668: PPUSH
17669: LD_VAR 0 1
17673: PUSH
17674: LD_INT 4
17676: MOD
17677: PUSH
17678: LD_INT 1
17680: PLUS
17681: PPUSH
17682: CALL_OW 259
17686: PUSH
17687: LD_INT 10
17689: LESS
17690: IFFALSE 17753
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
17692: LD_VAR 0 3
17696: PUSH
17697: LD_VAR 0 1
17701: ARRAY
17702: PPUSH
17703: LD_VAR 0 1
17707: PUSH
17708: LD_INT 4
17710: MOD
17711: PUSH
17712: LD_INT 1
17714: PLUS
17715: PPUSH
17716: LD_VAR 0 3
17720: PUSH
17721: LD_VAR 0 1
17725: ARRAY
17726: PPUSH
17727: LD_VAR 0 1
17731: PUSH
17732: LD_INT 4
17734: MOD
17735: PUSH
17736: LD_INT 1
17738: PLUS
17739: PPUSH
17740: CALL_OW 259
17744: PUSH
17745: LD_INT 1
17747: PLUS
17748: PPUSH
17749: CALL_OW 237
17753: GO 17655
17755: POP
17756: POP
// end ;
17757: PPOPN 3
17759: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
17760: LD_EXP 46
17764: PUSH
17765: LD_EXP 54
17769: AND
17770: IFFALSE 17790
17772: GO 17774
17774: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
17775: LD_INT 4
17777: PPUSH
17778: LD_OWVAR 2
17782: PPUSH
17783: LD_INT 0
17785: PPUSH
17786: CALL_OW 324
17790: END
// every 0 0$1 trigger StreamModeActive and sShovel do
17791: LD_EXP 46
17795: PUSH
17796: LD_EXP 83
17800: AND
17801: IFFALSE 17821
17803: GO 17805
17805: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
17806: LD_INT 19
17808: PPUSH
17809: LD_OWVAR 2
17813: PPUSH
17814: LD_INT 0
17816: PPUSH
17817: CALL_OW 324
17821: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
17822: LD_EXP 46
17826: PUSH
17827: LD_EXP 55
17831: AND
17832: IFFALSE 17934
17834: GO 17836
17836: DISABLE
17837: LD_INT 0
17839: PPUSH
17840: PPUSH
// begin enable ;
17841: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
17842: LD_ADDR_VAR 0 2
17846: PUSH
17847: LD_INT 22
17849: PUSH
17850: LD_OWVAR 2
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: PUSH
17859: LD_INT 2
17861: PUSH
17862: LD_INT 34
17864: PUSH
17865: LD_INT 11
17867: PUSH
17868: EMPTY
17869: LIST
17870: LIST
17871: PUSH
17872: LD_INT 34
17874: PUSH
17875: LD_INT 30
17877: PUSH
17878: EMPTY
17879: LIST
17880: LIST
17881: PUSH
17882: EMPTY
17883: LIST
17884: LIST
17885: LIST
17886: PUSH
17887: EMPTY
17888: LIST
17889: LIST
17890: PPUSH
17891: CALL_OW 69
17895: ST_TO_ADDR
// if not tmp then
17896: LD_VAR 0 2
17900: NOT
17901: IFFALSE 17905
// exit ;
17903: GO 17934
// for i in tmp do
17905: LD_ADDR_VAR 0 1
17909: PUSH
17910: LD_VAR 0 2
17914: PUSH
17915: FOR_IN
17916: IFFALSE 17932
// begin SetLives ( i , 0 ) ;
17918: LD_VAR 0 1
17922: PPUSH
17923: LD_INT 0
17925: PPUSH
17926: CALL_OW 234
// end ;
17930: GO 17915
17932: POP
17933: POP
// end ;
17934: PPOPN 2
17936: END
// every 0 0$1 trigger StreamModeActive and sBunker do
17937: LD_EXP 46
17941: PUSH
17942: LD_EXP 56
17946: AND
17947: IFFALSE 17967
17949: GO 17951
17951: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
17952: LD_INT 32
17954: PPUSH
17955: LD_OWVAR 2
17959: PPUSH
17960: LD_INT 0
17962: PPUSH
17963: CALL_OW 324
17967: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
17968: LD_EXP 46
17972: PUSH
17973: LD_EXP 57
17977: AND
17978: IFFALSE 18159
17980: GO 17982
17982: DISABLE
17983: LD_INT 0
17985: PPUSH
17986: PPUSH
17987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
17988: LD_ADDR_VAR 0 2
17992: PUSH
17993: LD_INT 22
17995: PUSH
17996: LD_OWVAR 2
18000: PUSH
18001: EMPTY
18002: LIST
18003: LIST
18004: PUSH
18005: LD_INT 33
18007: PUSH
18008: LD_INT 3
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PPUSH
18019: CALL_OW 69
18023: ST_TO_ADDR
// if not tmp then
18024: LD_VAR 0 2
18028: NOT
18029: IFFALSE 18033
// exit ;
18031: GO 18159
// side := 0 ;
18033: LD_ADDR_VAR 0 3
18037: PUSH
18038: LD_INT 0
18040: ST_TO_ADDR
// for i := 1 to 8 do
18041: LD_ADDR_VAR 0 1
18045: PUSH
18046: DOUBLE
18047: LD_INT 1
18049: DEC
18050: ST_TO_ADDR
18051: LD_INT 8
18053: PUSH
18054: FOR_TO
18055: IFFALSE 18103
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
18057: LD_OWVAR 2
18061: PUSH
18062: LD_VAR 0 1
18066: NONEQUAL
18067: PUSH
18068: LD_OWVAR 2
18072: PPUSH
18073: LD_VAR 0 1
18077: PPUSH
18078: CALL_OW 81
18082: PUSH
18083: LD_INT 2
18085: EQUAL
18086: AND
18087: IFFALSE 18101
// begin side := i ;
18089: LD_ADDR_VAR 0 3
18093: PUSH
18094: LD_VAR 0 1
18098: ST_TO_ADDR
// break ;
18099: GO 18103
// end ;
18101: GO 18054
18103: POP
18104: POP
// if not side then
18105: LD_VAR 0 3
18109: NOT
18110: IFFALSE 18114
// exit ;
18112: GO 18159
// for i := 1 to tmp do
18114: LD_ADDR_VAR 0 1
18118: PUSH
18119: DOUBLE
18120: LD_INT 1
18122: DEC
18123: ST_TO_ADDR
18124: LD_VAR 0 2
18128: PUSH
18129: FOR_TO
18130: IFFALSE 18157
// if Prob ( 60 ) then
18132: LD_INT 60
18134: PPUSH
18135: CALL_OW 13
18139: IFFALSE 18155
// SetSide ( i , side ) ;
18141: LD_VAR 0 1
18145: PPUSH
18146: LD_VAR 0 3
18150: PPUSH
18151: CALL_OW 235
18155: GO 18129
18157: POP
18158: POP
// end ;
18159: PPOPN 3
18161: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
18162: LD_EXP 46
18166: PUSH
18167: LD_EXP 59
18171: AND
18172: IFFALSE 18291
18174: GO 18176
18176: DISABLE
18177: LD_INT 0
18179: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
18180: LD_ADDR_VAR 0 1
18184: PUSH
18185: LD_INT 22
18187: PUSH
18188: LD_OWVAR 2
18192: PUSH
18193: EMPTY
18194: LIST
18195: LIST
18196: PUSH
18197: LD_INT 21
18199: PUSH
18200: LD_INT 1
18202: PUSH
18203: EMPTY
18204: LIST
18205: LIST
18206: PUSH
18207: LD_INT 3
18209: PUSH
18210: LD_INT 23
18212: PUSH
18213: LD_INT 0
18215: PUSH
18216: EMPTY
18217: LIST
18218: LIST
18219: PUSH
18220: EMPTY
18221: LIST
18222: LIST
18223: PUSH
18224: EMPTY
18225: LIST
18226: LIST
18227: LIST
18228: PPUSH
18229: CALL_OW 69
18233: PUSH
18234: FOR_IN
18235: IFFALSE 18289
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
18237: LD_VAR 0 1
18241: PPUSH
18242: CALL_OW 257
18246: PUSH
18247: LD_INT 1
18249: PUSH
18250: LD_INT 2
18252: PUSH
18253: LD_INT 3
18255: PUSH
18256: LD_INT 4
18258: PUSH
18259: EMPTY
18260: LIST
18261: LIST
18262: LIST
18263: LIST
18264: IN
18265: IFFALSE 18287
// SetClass ( un , rand ( 1 , 4 ) ) ;
18267: LD_VAR 0 1
18271: PPUSH
18272: LD_INT 1
18274: PPUSH
18275: LD_INT 4
18277: PPUSH
18278: CALL_OW 12
18282: PPUSH
18283: CALL_OW 336
18287: GO 18234
18289: POP
18290: POP
// end ;
18291: PPOPN 1
18293: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
18294: LD_EXP 46
18298: PUSH
18299: LD_EXP 58
18303: AND
18304: IFFALSE 18383
18306: GO 18308
18308: DISABLE
18309: LD_INT 0
18311: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18312: LD_ADDR_VAR 0 1
18316: PUSH
18317: LD_INT 22
18319: PUSH
18320: LD_OWVAR 2
18324: PUSH
18325: EMPTY
18326: LIST
18327: LIST
18328: PUSH
18329: LD_INT 21
18331: PUSH
18332: LD_INT 3
18334: PUSH
18335: EMPTY
18336: LIST
18337: LIST
18338: PUSH
18339: EMPTY
18340: LIST
18341: LIST
18342: PPUSH
18343: CALL_OW 69
18347: ST_TO_ADDR
// if not tmp then
18348: LD_VAR 0 1
18352: NOT
18353: IFFALSE 18357
// exit ;
18355: GO 18383
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
18357: LD_VAR 0 1
18361: PUSH
18362: LD_INT 1
18364: PPUSH
18365: LD_VAR 0 1
18369: PPUSH
18370: CALL_OW 12
18374: ARRAY
18375: PPUSH
18376: LD_INT 100
18378: PPUSH
18379: CALL_OW 234
// end ;
18383: PPOPN 1
18385: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
18386: LD_EXP 46
18390: PUSH
18391: LD_EXP 60
18395: AND
18396: IFFALSE 18494
18398: GO 18400
18400: DISABLE
18401: LD_INT 0
18403: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18404: LD_ADDR_VAR 0 1
18408: PUSH
18409: LD_INT 22
18411: PUSH
18412: LD_OWVAR 2
18416: PUSH
18417: EMPTY
18418: LIST
18419: LIST
18420: PUSH
18421: LD_INT 21
18423: PUSH
18424: LD_INT 1
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: PUSH
18431: EMPTY
18432: LIST
18433: LIST
18434: PPUSH
18435: CALL_OW 69
18439: ST_TO_ADDR
// if not tmp then
18440: LD_VAR 0 1
18444: NOT
18445: IFFALSE 18449
// exit ;
18447: GO 18494
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
18449: LD_VAR 0 1
18453: PUSH
18454: LD_INT 1
18456: PPUSH
18457: LD_VAR 0 1
18461: PPUSH
18462: CALL_OW 12
18466: ARRAY
18467: PPUSH
18468: LD_INT 1
18470: PPUSH
18471: LD_INT 4
18473: PPUSH
18474: CALL_OW 12
18478: PPUSH
18479: LD_INT 3000
18481: PPUSH
18482: LD_INT 9000
18484: PPUSH
18485: CALL_OW 12
18489: PPUSH
18490: CALL_OW 492
// end ;
18494: PPOPN 1
18496: END
// every 0 0$1 trigger StreamModeActive and sDepot do
18497: LD_EXP 46
18501: PUSH
18502: LD_EXP 61
18506: AND
18507: IFFALSE 18527
18509: GO 18511
18511: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
18512: LD_INT 1
18514: PPUSH
18515: LD_OWVAR 2
18519: PPUSH
18520: LD_INT 0
18522: PPUSH
18523: CALL_OW 324
18527: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
18528: LD_EXP 46
18532: PUSH
18533: LD_EXP 62
18537: AND
18538: IFFALSE 18621
18540: GO 18542
18542: DISABLE
18543: LD_INT 0
18545: PPUSH
18546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
18547: LD_ADDR_VAR 0 2
18551: PUSH
18552: LD_INT 22
18554: PUSH
18555: LD_OWVAR 2
18559: PUSH
18560: EMPTY
18561: LIST
18562: LIST
18563: PUSH
18564: LD_INT 21
18566: PUSH
18567: LD_INT 3
18569: PUSH
18570: EMPTY
18571: LIST
18572: LIST
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PPUSH
18578: CALL_OW 69
18582: ST_TO_ADDR
// if not tmp then
18583: LD_VAR 0 2
18587: NOT
18588: IFFALSE 18592
// exit ;
18590: GO 18621
// for i in tmp do
18592: LD_ADDR_VAR 0 1
18596: PUSH
18597: LD_VAR 0 2
18601: PUSH
18602: FOR_IN
18603: IFFALSE 18619
// SetBLevel ( i , 10 ) ;
18605: LD_VAR 0 1
18609: PPUSH
18610: LD_INT 10
18612: PPUSH
18613: CALL_OW 241
18617: GO 18602
18619: POP
18620: POP
// end ;
18621: PPOPN 2
18623: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
18624: LD_EXP 46
18628: PUSH
18629: LD_EXP 63
18633: AND
18634: IFFALSE 18745
18636: GO 18638
18638: DISABLE
18639: LD_INT 0
18641: PPUSH
18642: PPUSH
18643: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
18644: LD_ADDR_VAR 0 3
18648: PUSH
18649: LD_INT 22
18651: PUSH
18652: LD_OWVAR 2
18656: PUSH
18657: EMPTY
18658: LIST
18659: LIST
18660: PUSH
18661: LD_INT 25
18663: PUSH
18664: LD_INT 1
18666: PUSH
18667: EMPTY
18668: LIST
18669: LIST
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: PPUSH
18675: CALL_OW 69
18679: ST_TO_ADDR
// if not tmp then
18680: LD_VAR 0 3
18684: NOT
18685: IFFALSE 18689
// exit ;
18687: GO 18745
// un := tmp [ rand ( 1 , tmp ) ] ;
18689: LD_ADDR_VAR 0 2
18693: PUSH
18694: LD_VAR 0 3
18698: PUSH
18699: LD_INT 1
18701: PPUSH
18702: LD_VAR 0 3
18706: PPUSH
18707: CALL_OW 12
18711: ARRAY
18712: ST_TO_ADDR
// if Crawls ( un ) then
18713: LD_VAR 0 2
18717: PPUSH
18718: CALL_OW 318
18722: IFFALSE 18733
// ComWalk ( un ) ;
18724: LD_VAR 0 2
18728: PPUSH
18729: CALL_OW 138
// SetClass ( un , class_sniper ) ;
18733: LD_VAR 0 2
18737: PPUSH
18738: LD_INT 5
18740: PPUSH
18741: CALL_OW 336
// end ;
18745: PPOPN 3
18747: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
18748: LD_EXP 46
18752: PUSH
18753: LD_EXP 64
18757: AND
18758: PUSH
18759: LD_OWVAR 67
18763: PUSH
18764: LD_INT 3
18766: LESS
18767: AND
18768: IFFALSE 18787
18770: GO 18772
18772: DISABLE
// Difficulty := Difficulty + 1 ;
18773: LD_ADDR_OWVAR 67
18777: PUSH
18778: LD_OWVAR 67
18782: PUSH
18783: LD_INT 1
18785: PLUS
18786: ST_TO_ADDR
18787: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
18788: LD_EXP 46
18792: PUSH
18793: LD_EXP 65
18797: AND
18798: IFFALSE 18901
18800: GO 18802
18802: DISABLE
18803: LD_INT 0
18805: PPUSH
// begin for i := 1 to 5 do
18806: LD_ADDR_VAR 0 1
18810: PUSH
18811: DOUBLE
18812: LD_INT 1
18814: DEC
18815: ST_TO_ADDR
18816: LD_INT 5
18818: PUSH
18819: FOR_TO
18820: IFFALSE 18899
// begin uc_nation := nation_nature ;
18822: LD_ADDR_OWVAR 21
18826: PUSH
18827: LD_INT 0
18829: ST_TO_ADDR
// uc_side := 0 ;
18830: LD_ADDR_OWVAR 20
18834: PUSH
18835: LD_INT 0
18837: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18838: LD_ADDR_OWVAR 29
18842: PUSH
18843: LD_INT 12
18845: PUSH
18846: LD_INT 12
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: ST_TO_ADDR
// hc_agressivity := 20 ;
18853: LD_ADDR_OWVAR 35
18857: PUSH
18858: LD_INT 20
18860: ST_TO_ADDR
// hc_class := class_tiger ;
18861: LD_ADDR_OWVAR 28
18865: PUSH
18866: LD_INT 14
18868: ST_TO_ADDR
// hc_gallery :=  ;
18869: LD_ADDR_OWVAR 33
18873: PUSH
18874: LD_STRING 
18876: ST_TO_ADDR
// hc_name :=  ;
18877: LD_ADDR_OWVAR 26
18881: PUSH
18882: LD_STRING 
18884: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
18885: CALL_OW 44
18889: PPUSH
18890: LD_INT 0
18892: PPUSH
18893: CALL_OW 51
// end ;
18897: GO 18819
18899: POP
18900: POP
// end ;
18901: PPOPN 1
18903: END
// every 0 0$1 trigger StreamModeActive and sBomb do
18904: LD_EXP 46
18908: PUSH
18909: LD_EXP 66
18913: AND
18914: IFFALSE 18923
18916: GO 18918
18918: DISABLE
// StreamSibBomb ;
18919: CALL 18924 0 0
18923: END
// export function StreamSibBomb ; var i , x , y ; begin
18924: LD_INT 0
18926: PPUSH
18927: PPUSH
18928: PPUSH
18929: PPUSH
// result := false ;
18930: LD_ADDR_VAR 0 1
18934: PUSH
18935: LD_INT 0
18937: ST_TO_ADDR
// for i := 1 to 16 do
18938: LD_ADDR_VAR 0 2
18942: PUSH
18943: DOUBLE
18944: LD_INT 1
18946: DEC
18947: ST_TO_ADDR
18948: LD_INT 16
18950: PUSH
18951: FOR_TO
18952: IFFALSE 19151
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18954: LD_ADDR_VAR 0 3
18958: PUSH
18959: LD_INT 10
18961: PUSH
18962: LD_INT 20
18964: PUSH
18965: LD_INT 30
18967: PUSH
18968: LD_INT 40
18970: PUSH
18971: LD_INT 50
18973: PUSH
18974: LD_INT 60
18976: PUSH
18977: LD_INT 70
18979: PUSH
18980: LD_INT 80
18982: PUSH
18983: LD_INT 90
18985: PUSH
18986: LD_INT 100
18988: PUSH
18989: LD_INT 110
18991: PUSH
18992: LD_INT 120
18994: PUSH
18995: LD_INT 130
18997: PUSH
18998: LD_INT 140
19000: PUSH
19001: LD_INT 150
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: LIST
19008: LIST
19009: LIST
19010: LIST
19011: LIST
19012: LIST
19013: LIST
19014: LIST
19015: LIST
19016: LIST
19017: LIST
19018: LIST
19019: LIST
19020: PUSH
19021: LD_INT 1
19023: PPUSH
19024: LD_INT 15
19026: PPUSH
19027: CALL_OW 12
19031: ARRAY
19032: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
19033: LD_ADDR_VAR 0 4
19037: PUSH
19038: LD_INT 10
19040: PUSH
19041: LD_INT 20
19043: PUSH
19044: LD_INT 30
19046: PUSH
19047: LD_INT 40
19049: PUSH
19050: LD_INT 50
19052: PUSH
19053: LD_INT 60
19055: PUSH
19056: LD_INT 70
19058: PUSH
19059: LD_INT 80
19061: PUSH
19062: LD_INT 90
19064: PUSH
19065: LD_INT 100
19067: PUSH
19068: LD_INT 110
19070: PUSH
19071: LD_INT 120
19073: PUSH
19074: LD_INT 130
19076: PUSH
19077: LD_INT 140
19079: PUSH
19080: LD_INT 150
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: LIST
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: LIST
19092: LIST
19093: LIST
19094: LIST
19095: LIST
19096: LIST
19097: LIST
19098: LIST
19099: PUSH
19100: LD_INT 1
19102: PPUSH
19103: LD_INT 15
19105: PPUSH
19106: CALL_OW 12
19110: ARRAY
19111: ST_TO_ADDR
// if ValidHex ( x , y ) then
19112: LD_VAR 0 3
19116: PPUSH
19117: LD_VAR 0 4
19121: PPUSH
19122: CALL_OW 488
19126: IFFALSE 19149
// begin result := [ x , y ] ;
19128: LD_ADDR_VAR 0 1
19132: PUSH
19133: LD_VAR 0 3
19137: PUSH
19138: LD_VAR 0 4
19142: PUSH
19143: EMPTY
19144: LIST
19145: LIST
19146: ST_TO_ADDR
// break ;
19147: GO 19151
// end ; end ;
19149: GO 18951
19151: POP
19152: POP
// if result then
19153: LD_VAR 0 1
19157: IFFALSE 19217
// begin ToLua ( playSibBomb() ) ;
19159: LD_STRING playSibBomb()
19161: PPUSH
19162: CALL_OW 559
// wait ( 0 0$14 ) ;
19166: LD_INT 490
19168: PPUSH
19169: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
19173: LD_VAR 0 1
19177: PUSH
19178: LD_INT 1
19180: ARRAY
19181: PPUSH
19182: LD_VAR 0 1
19186: PUSH
19187: LD_INT 2
19189: ARRAY
19190: PPUSH
19191: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
19195: LD_VAR 0 1
19199: PUSH
19200: LD_INT 1
19202: ARRAY
19203: PPUSH
19204: LD_VAR 0 1
19208: PUSH
19209: LD_INT 2
19211: ARRAY
19212: PPUSH
19213: CALL_OW 429
// end ; end ;
19217: LD_VAR 0 1
19221: RET
// every 0 0$1 trigger StreamModeActive and sReset do
19222: LD_EXP 46
19226: PUSH
19227: LD_EXP 68
19231: AND
19232: IFFALSE 19244
19234: GO 19236
19236: DISABLE
// YouLost (  ) ;
19237: LD_STRING 
19239: PPUSH
19240: CALL_OW 104
19244: END
// every 0 0$1 trigger StreamModeActive and sFog do
19245: LD_EXP 46
19249: PUSH
19250: LD_EXP 67
19254: AND
19255: IFFALSE 19269
19257: GO 19259
19259: DISABLE
// FogOff ( your_side ) ;
19260: LD_OWVAR 2
19264: PPUSH
19265: CALL_OW 344
19269: END
// every 0 0$1 trigger StreamModeActive and sSun do
19270: LD_EXP 46
19274: PUSH
19275: LD_EXP 69
19279: AND
19280: IFFALSE 19308
19282: GO 19284
19284: DISABLE
// begin solar_recharge_percent := 0 ;
19285: LD_ADDR_OWVAR 79
19289: PUSH
19290: LD_INT 0
19292: ST_TO_ADDR
// wait ( 5 5$00 ) ;
19293: LD_INT 10500
19295: PPUSH
19296: CALL_OW 67
// solar_recharge_percent := 100 ;
19300: LD_ADDR_OWVAR 79
19304: PUSH
19305: LD_INT 100
19307: ST_TO_ADDR
// end ;
19308: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
19309: LD_EXP 46
19313: PUSH
19314: LD_EXP 70
19318: AND
19319: IFFALSE 19558
19321: GO 19323
19323: DISABLE
19324: LD_INT 0
19326: PPUSH
19327: PPUSH
19328: PPUSH
// begin tmp := [ ] ;
19329: LD_ADDR_VAR 0 3
19333: PUSH
19334: EMPTY
19335: ST_TO_ADDR
// for i := 1 to 6 do
19336: LD_ADDR_VAR 0 1
19340: PUSH
19341: DOUBLE
19342: LD_INT 1
19344: DEC
19345: ST_TO_ADDR
19346: LD_INT 6
19348: PUSH
19349: FOR_TO
19350: IFFALSE 19455
// begin uc_nation := nation_nature ;
19352: LD_ADDR_OWVAR 21
19356: PUSH
19357: LD_INT 0
19359: ST_TO_ADDR
// uc_side := 0 ;
19360: LD_ADDR_OWVAR 20
19364: PUSH
19365: LD_INT 0
19367: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
19368: LD_ADDR_OWVAR 29
19372: PUSH
19373: LD_INT 12
19375: PUSH
19376: LD_INT 12
19378: PUSH
19379: EMPTY
19380: LIST
19381: LIST
19382: ST_TO_ADDR
// hc_agressivity := 20 ;
19383: LD_ADDR_OWVAR 35
19387: PUSH
19388: LD_INT 20
19390: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
19391: LD_ADDR_OWVAR 28
19395: PUSH
19396: LD_INT 17
19398: ST_TO_ADDR
// hc_gallery :=  ;
19399: LD_ADDR_OWVAR 33
19403: PUSH
19404: LD_STRING 
19406: ST_TO_ADDR
// hc_name :=  ;
19407: LD_ADDR_OWVAR 26
19411: PUSH
19412: LD_STRING 
19414: ST_TO_ADDR
// un := CreateHuman ;
19415: LD_ADDR_VAR 0 2
19419: PUSH
19420: CALL_OW 44
19424: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
19425: LD_VAR 0 2
19429: PPUSH
19430: LD_INT 1
19432: PPUSH
19433: CALL_OW 51
// tmp := tmp ^ un ;
19437: LD_ADDR_VAR 0 3
19441: PUSH
19442: LD_VAR 0 3
19446: PUSH
19447: LD_VAR 0 2
19451: ADD
19452: ST_TO_ADDR
// end ;
19453: GO 19349
19455: POP
19456: POP
// repeat wait ( 0 0$1 ) ;
19457: LD_INT 35
19459: PPUSH
19460: CALL_OW 67
// for un in tmp do
19464: LD_ADDR_VAR 0 2
19468: PUSH
19469: LD_VAR 0 3
19473: PUSH
19474: FOR_IN
19475: IFFALSE 19549
// begin if IsDead ( un ) then
19477: LD_VAR 0 2
19481: PPUSH
19482: CALL_OW 301
19486: IFFALSE 19506
// begin tmp := tmp diff un ;
19488: LD_ADDR_VAR 0 3
19492: PUSH
19493: LD_VAR 0 3
19497: PUSH
19498: LD_VAR 0 2
19502: DIFF
19503: ST_TO_ADDR
// continue ;
19504: GO 19474
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
19506: LD_VAR 0 2
19510: PPUSH
19511: LD_INT 3
19513: PUSH
19514: LD_INT 22
19516: PUSH
19517: LD_INT 0
19519: PUSH
19520: EMPTY
19521: LIST
19522: LIST
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: PPUSH
19528: CALL_OW 69
19532: PPUSH
19533: LD_VAR 0 2
19537: PPUSH
19538: CALL_OW 74
19542: PPUSH
19543: CALL_OW 115
// end ;
19547: GO 19474
19549: POP
19550: POP
// until not tmp ;
19551: LD_VAR 0 3
19555: NOT
19556: IFFALSE 19457
// end ;
19558: PPOPN 3
19560: END
// every 0 0$1 trigger StreamModeActive and sTroll do
19561: LD_EXP 46
19565: PUSH
19566: LD_EXP 71
19570: AND
19571: IFFALSE 19625
19573: GO 19575
19575: DISABLE
// begin ToLua ( displayTroll(); ) ;
19576: LD_STRING displayTroll();
19578: PPUSH
19579: CALL_OW 559
// wait ( 3 3$00 ) ;
19583: LD_INT 6300
19585: PPUSH
19586: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19590: LD_STRING hideTroll();
19592: PPUSH
19593: CALL_OW 559
// wait ( 1 1$00 ) ;
19597: LD_INT 2100
19599: PPUSH
19600: CALL_OW 67
// ToLua ( displayTroll(); ) ;
19604: LD_STRING displayTroll();
19606: PPUSH
19607: CALL_OW 559
// wait ( 1 1$00 ) ;
19611: LD_INT 2100
19613: PPUSH
19614: CALL_OW 67
// ToLua ( hideTroll(); ) ;
19618: LD_STRING hideTroll();
19620: PPUSH
19621: CALL_OW 559
// end ;
19625: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
19626: LD_EXP 46
19630: PUSH
19631: LD_EXP 72
19635: AND
19636: IFFALSE 19699
19638: GO 19640
19640: DISABLE
19641: LD_INT 0
19643: PPUSH
// begin p := 0 ;
19644: LD_ADDR_VAR 0 1
19648: PUSH
19649: LD_INT 0
19651: ST_TO_ADDR
// repeat game_speed := 1 ;
19652: LD_ADDR_OWVAR 65
19656: PUSH
19657: LD_INT 1
19659: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19660: LD_INT 35
19662: PPUSH
19663: CALL_OW 67
// p := p + 1 ;
19667: LD_ADDR_VAR 0 1
19671: PUSH
19672: LD_VAR 0 1
19676: PUSH
19677: LD_INT 1
19679: PLUS
19680: ST_TO_ADDR
// until p >= 60 ;
19681: LD_VAR 0 1
19685: PUSH
19686: LD_INT 60
19688: GREATEREQUAL
19689: IFFALSE 19652
// game_speed := 4 ;
19691: LD_ADDR_OWVAR 65
19695: PUSH
19696: LD_INT 4
19698: ST_TO_ADDR
// end ;
19699: PPOPN 1
19701: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
19702: LD_EXP 46
19706: PUSH
19707: LD_EXP 73
19711: AND
19712: IFFALSE 19858
19714: GO 19716
19716: DISABLE
19717: LD_INT 0
19719: PPUSH
19720: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19721: LD_ADDR_VAR 0 1
19725: PUSH
19726: LD_INT 22
19728: PUSH
19729: LD_OWVAR 2
19733: PUSH
19734: EMPTY
19735: LIST
19736: LIST
19737: PUSH
19738: LD_INT 2
19740: PUSH
19741: LD_INT 30
19743: PUSH
19744: LD_INT 0
19746: PUSH
19747: EMPTY
19748: LIST
19749: LIST
19750: PUSH
19751: LD_INT 30
19753: PUSH
19754: LD_INT 1
19756: PUSH
19757: EMPTY
19758: LIST
19759: LIST
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: LIST
19765: PUSH
19766: EMPTY
19767: LIST
19768: LIST
19769: PPUSH
19770: CALL_OW 69
19774: ST_TO_ADDR
// if not depot then
19775: LD_VAR 0 1
19779: NOT
19780: IFFALSE 19784
// exit ;
19782: GO 19858
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
19784: LD_ADDR_VAR 0 2
19788: PUSH
19789: LD_VAR 0 1
19793: PUSH
19794: LD_INT 1
19796: PPUSH
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 12
19806: ARRAY
19807: PPUSH
19808: CALL_OW 274
19812: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
19813: LD_VAR 0 2
19817: PPUSH
19818: LD_INT 1
19820: PPUSH
19821: LD_INT 0
19823: PPUSH
19824: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
19828: LD_VAR 0 2
19832: PPUSH
19833: LD_INT 2
19835: PPUSH
19836: LD_INT 0
19838: PPUSH
19839: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
19843: LD_VAR 0 2
19847: PPUSH
19848: LD_INT 3
19850: PPUSH
19851: LD_INT 0
19853: PPUSH
19854: CALL_OW 277
// end ;
19858: PPOPN 2
19860: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
19861: LD_EXP 46
19865: PUSH
19866: LD_EXP 74
19870: AND
19871: IFFALSE 19968
19873: GO 19875
19875: DISABLE
19876: LD_INT 0
19878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19879: LD_ADDR_VAR 0 1
19883: PUSH
19884: LD_INT 22
19886: PUSH
19887: LD_OWVAR 2
19891: PUSH
19892: EMPTY
19893: LIST
19894: LIST
19895: PUSH
19896: LD_INT 21
19898: PUSH
19899: LD_INT 1
19901: PUSH
19902: EMPTY
19903: LIST
19904: LIST
19905: PUSH
19906: LD_INT 3
19908: PUSH
19909: LD_INT 23
19911: PUSH
19912: LD_INT 0
19914: PUSH
19915: EMPTY
19916: LIST
19917: LIST
19918: PUSH
19919: EMPTY
19920: LIST
19921: LIST
19922: PUSH
19923: EMPTY
19924: LIST
19925: LIST
19926: LIST
19927: PPUSH
19928: CALL_OW 69
19932: ST_TO_ADDR
// if not tmp then
19933: LD_VAR 0 1
19937: NOT
19938: IFFALSE 19942
// exit ;
19940: GO 19968
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
19942: LD_VAR 0 1
19946: PUSH
19947: LD_INT 1
19949: PPUSH
19950: LD_VAR 0 1
19954: PPUSH
19955: CALL_OW 12
19959: ARRAY
19960: PPUSH
19961: LD_INT 200
19963: PPUSH
19964: CALL_OW 234
// end ;
19968: PPOPN 1
19970: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
19971: LD_EXP 46
19975: PUSH
19976: LD_EXP 75
19980: AND
19981: IFFALSE 20060
19983: GO 19985
19985: DISABLE
19986: LD_INT 0
19988: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
19989: LD_ADDR_VAR 0 1
19993: PUSH
19994: LD_INT 22
19996: PUSH
19997: LD_OWVAR 2
20001: PUSH
20002: EMPTY
20003: LIST
20004: LIST
20005: PUSH
20006: LD_INT 21
20008: PUSH
20009: LD_INT 2
20011: PUSH
20012: EMPTY
20013: LIST
20014: LIST
20015: PUSH
20016: EMPTY
20017: LIST
20018: LIST
20019: PPUSH
20020: CALL_OW 69
20024: ST_TO_ADDR
// if not tmp then
20025: LD_VAR 0 1
20029: NOT
20030: IFFALSE 20034
// exit ;
20032: GO 20060
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
20034: LD_VAR 0 1
20038: PUSH
20039: LD_INT 1
20041: PPUSH
20042: LD_VAR 0 1
20046: PPUSH
20047: CALL_OW 12
20051: ARRAY
20052: PPUSH
20053: LD_INT 60
20055: PPUSH
20056: CALL_OW 234
// end ;
20060: PPOPN 1
20062: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
20063: LD_EXP 46
20067: PUSH
20068: LD_EXP 76
20072: AND
20073: IFFALSE 20172
20075: GO 20077
20077: DISABLE
20078: LD_INT 0
20080: PPUSH
20081: PPUSH
// begin enable ;
20082: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
20083: LD_ADDR_VAR 0 1
20087: PUSH
20088: LD_INT 22
20090: PUSH
20091: LD_OWVAR 2
20095: PUSH
20096: EMPTY
20097: LIST
20098: LIST
20099: PUSH
20100: LD_INT 61
20102: PUSH
20103: EMPTY
20104: LIST
20105: PUSH
20106: LD_INT 33
20108: PUSH
20109: LD_INT 2
20111: PUSH
20112: EMPTY
20113: LIST
20114: LIST
20115: PUSH
20116: EMPTY
20117: LIST
20118: LIST
20119: LIST
20120: PPUSH
20121: CALL_OW 69
20125: ST_TO_ADDR
// if not tmp then
20126: LD_VAR 0 1
20130: NOT
20131: IFFALSE 20135
// exit ;
20133: GO 20172
// for i in tmp do
20135: LD_ADDR_VAR 0 2
20139: PUSH
20140: LD_VAR 0 1
20144: PUSH
20145: FOR_IN
20146: IFFALSE 20170
// if IsControledBy ( i ) then
20148: LD_VAR 0 2
20152: PPUSH
20153: CALL_OW 312
20157: IFFALSE 20168
// ComUnlink ( i ) ;
20159: LD_VAR 0 2
20163: PPUSH
20164: CALL_OW 136
20168: GO 20145
20170: POP
20171: POP
// end ;
20172: PPOPN 2
20174: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
20175: LD_EXP 46
20179: PUSH
20180: LD_EXP 77
20184: AND
20185: IFFALSE 20325
20187: GO 20189
20189: DISABLE
20190: LD_INT 0
20192: PPUSH
20193: PPUSH
// begin ToLua ( displayPowell(); ) ;
20194: LD_STRING displayPowell();
20196: PPUSH
20197: CALL_OW 559
// uc_side := 0 ;
20201: LD_ADDR_OWVAR 20
20205: PUSH
20206: LD_INT 0
20208: ST_TO_ADDR
// uc_nation := 2 ;
20209: LD_ADDR_OWVAR 21
20213: PUSH
20214: LD_INT 2
20216: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
20217: LD_ADDR_OWVAR 37
20221: PUSH
20222: LD_INT 14
20224: ST_TO_ADDR
// vc_engine := engine_siberite ;
20225: LD_ADDR_OWVAR 39
20229: PUSH
20230: LD_INT 3
20232: ST_TO_ADDR
// vc_control := control_apeman ;
20233: LD_ADDR_OWVAR 38
20237: PUSH
20238: LD_INT 5
20240: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
20241: LD_ADDR_OWVAR 40
20245: PUSH
20246: LD_INT 29
20248: ST_TO_ADDR
// un := CreateVehicle ;
20249: LD_ADDR_VAR 0 2
20253: PUSH
20254: CALL_OW 45
20258: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20259: LD_VAR 0 2
20263: PPUSH
20264: LD_INT 1
20266: PPUSH
20267: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20271: LD_INT 35
20273: PPUSH
20274: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20278: LD_VAR 0 2
20282: PPUSH
20283: LD_INT 22
20285: PUSH
20286: LD_OWVAR 2
20290: PUSH
20291: EMPTY
20292: LIST
20293: LIST
20294: PPUSH
20295: CALL_OW 69
20299: PPUSH
20300: LD_VAR 0 2
20304: PPUSH
20305: CALL_OW 74
20309: PPUSH
20310: CALL_OW 115
// until IsDead ( un ) ;
20314: LD_VAR 0 2
20318: PPUSH
20319: CALL_OW 301
20323: IFFALSE 20271
// end ;
20325: PPOPN 2
20327: END
// every 0 0$1 trigger StreamModeActive and sStu do
20328: LD_EXP 46
20332: PUSH
20333: LD_EXP 85
20337: AND
20338: IFFALSE 20354
20340: GO 20342
20342: DISABLE
// begin ToLua ( displayStucuk(); ) ;
20343: LD_STRING displayStucuk();
20345: PPUSH
20346: CALL_OW 559
// ResetFog ;
20350: CALL_OW 335
// end ;
20354: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
20355: LD_EXP 46
20359: PUSH
20360: LD_EXP 78
20364: AND
20365: IFFALSE 20506
20367: GO 20369
20369: DISABLE
20370: LD_INT 0
20372: PPUSH
20373: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20374: LD_ADDR_VAR 0 2
20378: PUSH
20379: LD_INT 22
20381: PUSH
20382: LD_OWVAR 2
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: PUSH
20391: LD_INT 21
20393: PUSH
20394: LD_INT 1
20396: PUSH
20397: EMPTY
20398: LIST
20399: LIST
20400: PUSH
20401: EMPTY
20402: LIST
20403: LIST
20404: PPUSH
20405: CALL_OW 69
20409: ST_TO_ADDR
// if not tmp then
20410: LD_VAR 0 2
20414: NOT
20415: IFFALSE 20419
// exit ;
20417: GO 20506
// un := tmp [ rand ( 1 , tmp ) ] ;
20419: LD_ADDR_VAR 0 1
20423: PUSH
20424: LD_VAR 0 2
20428: PUSH
20429: LD_INT 1
20431: PPUSH
20432: LD_VAR 0 2
20436: PPUSH
20437: CALL_OW 12
20441: ARRAY
20442: ST_TO_ADDR
// SetSide ( un , 0 ) ;
20443: LD_VAR 0 1
20447: PPUSH
20448: LD_INT 0
20450: PPUSH
20451: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
20455: LD_VAR 0 1
20459: PPUSH
20460: LD_OWVAR 3
20464: PUSH
20465: LD_VAR 0 1
20469: DIFF
20470: PPUSH
20471: LD_VAR 0 1
20475: PPUSH
20476: CALL_OW 74
20480: PPUSH
20481: CALL_OW 115
// wait ( 0 0$20 ) ;
20485: LD_INT 700
20487: PPUSH
20488: CALL_OW 67
// SetSide ( un , your_side ) ;
20492: LD_VAR 0 1
20496: PPUSH
20497: LD_OWVAR 2
20501: PPUSH
20502: CALL_OW 235
// end ;
20506: PPOPN 2
20508: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
20509: LD_EXP 46
20513: PUSH
20514: LD_EXP 79
20518: AND
20519: IFFALSE 20625
20521: GO 20523
20523: DISABLE
20524: LD_INT 0
20526: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
20527: LD_ADDR_VAR 0 1
20531: PUSH
20532: LD_INT 22
20534: PUSH
20535: LD_OWVAR 2
20539: PUSH
20540: EMPTY
20541: LIST
20542: LIST
20543: PUSH
20544: LD_INT 2
20546: PUSH
20547: LD_INT 30
20549: PUSH
20550: LD_INT 0
20552: PUSH
20553: EMPTY
20554: LIST
20555: LIST
20556: PUSH
20557: LD_INT 30
20559: PUSH
20560: LD_INT 1
20562: PUSH
20563: EMPTY
20564: LIST
20565: LIST
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: LIST
20571: PUSH
20572: EMPTY
20573: LIST
20574: LIST
20575: PPUSH
20576: CALL_OW 69
20580: ST_TO_ADDR
// if not depot then
20581: LD_VAR 0 1
20585: NOT
20586: IFFALSE 20590
// exit ;
20588: GO 20625
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
20590: LD_VAR 0 1
20594: PUSH
20595: LD_INT 1
20597: ARRAY
20598: PPUSH
20599: CALL_OW 250
20603: PPUSH
20604: LD_VAR 0 1
20608: PUSH
20609: LD_INT 1
20611: ARRAY
20612: PPUSH
20613: CALL_OW 251
20617: PPUSH
20618: LD_INT 70
20620: PPUSH
20621: CALL_OW 495
// end ;
20625: PPOPN 1
20627: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
20628: LD_EXP 46
20632: PUSH
20633: LD_EXP 80
20637: AND
20638: IFFALSE 20849
20640: GO 20642
20642: DISABLE
20643: LD_INT 0
20645: PPUSH
20646: PPUSH
20647: PPUSH
20648: PPUSH
20649: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20650: LD_ADDR_VAR 0 5
20654: PUSH
20655: LD_INT 22
20657: PUSH
20658: LD_OWVAR 2
20662: PUSH
20663: EMPTY
20664: LIST
20665: LIST
20666: PUSH
20667: LD_INT 21
20669: PUSH
20670: LD_INT 1
20672: PUSH
20673: EMPTY
20674: LIST
20675: LIST
20676: PUSH
20677: EMPTY
20678: LIST
20679: LIST
20680: PPUSH
20681: CALL_OW 69
20685: ST_TO_ADDR
// if not tmp then
20686: LD_VAR 0 5
20690: NOT
20691: IFFALSE 20695
// exit ;
20693: GO 20849
// for i in tmp do
20695: LD_ADDR_VAR 0 1
20699: PUSH
20700: LD_VAR 0 5
20704: PUSH
20705: FOR_IN
20706: IFFALSE 20847
// begin d := rand ( 0 , 5 ) ;
20708: LD_ADDR_VAR 0 4
20712: PUSH
20713: LD_INT 0
20715: PPUSH
20716: LD_INT 5
20718: PPUSH
20719: CALL_OW 12
20723: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
20724: LD_ADDR_VAR 0 2
20728: PUSH
20729: LD_VAR 0 1
20733: PPUSH
20734: CALL_OW 250
20738: PPUSH
20739: LD_VAR 0 4
20743: PPUSH
20744: LD_INT 3
20746: PPUSH
20747: LD_INT 12
20749: PPUSH
20750: CALL_OW 12
20754: PPUSH
20755: CALL_OW 272
20759: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
20760: LD_ADDR_VAR 0 3
20764: PUSH
20765: LD_VAR 0 1
20769: PPUSH
20770: CALL_OW 251
20774: PPUSH
20775: LD_VAR 0 4
20779: PPUSH
20780: LD_INT 3
20782: PPUSH
20783: LD_INT 12
20785: PPUSH
20786: CALL_OW 12
20790: PPUSH
20791: CALL_OW 273
20795: ST_TO_ADDR
// if ValidHex ( x , y ) then
20796: LD_VAR 0 2
20800: PPUSH
20801: LD_VAR 0 3
20805: PPUSH
20806: CALL_OW 488
20810: IFFALSE 20845
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
20812: LD_VAR 0 1
20816: PPUSH
20817: LD_VAR 0 2
20821: PPUSH
20822: LD_VAR 0 3
20826: PPUSH
20827: LD_INT 3
20829: PPUSH
20830: LD_INT 6
20832: PPUSH
20833: CALL_OW 12
20837: PPUSH
20838: LD_INT 1
20840: PPUSH
20841: CALL_OW 483
// end ;
20845: GO 20705
20847: POP
20848: POP
// end ;
20849: PPOPN 5
20851: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
20852: LD_EXP 46
20856: PUSH
20857: LD_EXP 81
20861: AND
20862: IFFALSE 20956
20864: GO 20866
20866: DISABLE
20867: LD_INT 0
20869: PPUSH
20870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
20871: LD_ADDR_VAR 0 2
20875: PUSH
20876: LD_INT 22
20878: PUSH
20879: LD_OWVAR 2
20883: PUSH
20884: EMPTY
20885: LIST
20886: LIST
20887: PUSH
20888: LD_INT 32
20890: PUSH
20891: LD_INT 1
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: PUSH
20898: LD_INT 21
20900: PUSH
20901: LD_INT 2
20903: PUSH
20904: EMPTY
20905: LIST
20906: LIST
20907: PUSH
20908: EMPTY
20909: LIST
20910: LIST
20911: LIST
20912: PPUSH
20913: CALL_OW 69
20917: ST_TO_ADDR
// if not tmp then
20918: LD_VAR 0 2
20922: NOT
20923: IFFALSE 20927
// exit ;
20925: GO 20956
// for i in tmp do
20927: LD_ADDR_VAR 0 1
20931: PUSH
20932: LD_VAR 0 2
20936: PUSH
20937: FOR_IN
20938: IFFALSE 20954
// SetFuel ( i , 0 ) ;
20940: LD_VAR 0 1
20944: PPUSH
20945: LD_INT 0
20947: PPUSH
20948: CALL_OW 240
20952: GO 20937
20954: POP
20955: POP
// end ;
20956: PPOPN 2
20958: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
20959: LD_EXP 46
20963: PUSH
20964: LD_EXP 82
20968: AND
20969: IFFALSE 21035
20971: GO 20973
20973: DISABLE
20974: LD_INT 0
20976: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20977: LD_ADDR_VAR 0 1
20981: PUSH
20982: LD_INT 22
20984: PUSH
20985: LD_OWVAR 2
20989: PUSH
20990: EMPTY
20991: LIST
20992: LIST
20993: PUSH
20994: LD_INT 30
20996: PUSH
20997: LD_INT 29
20999: PUSH
21000: EMPTY
21001: LIST
21002: LIST
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: PPUSH
21008: CALL_OW 69
21012: ST_TO_ADDR
// if not tmp then
21013: LD_VAR 0 1
21017: NOT
21018: IFFALSE 21022
// exit ;
21020: GO 21035
// DestroyUnit ( tmp [ 1 ] ) ;
21022: LD_VAR 0 1
21026: PUSH
21027: LD_INT 1
21029: ARRAY
21030: PPUSH
21031: CALL_OW 65
// end ;
21035: PPOPN 1
21037: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
21038: LD_EXP 46
21042: PUSH
21043: LD_EXP 84
21047: AND
21048: IFFALSE 21177
21050: GO 21052
21052: DISABLE
21053: LD_INT 0
21055: PPUSH
// begin uc_side := 0 ;
21056: LD_ADDR_OWVAR 20
21060: PUSH
21061: LD_INT 0
21063: ST_TO_ADDR
// uc_nation := nation_arabian ;
21064: LD_ADDR_OWVAR 21
21068: PUSH
21069: LD_INT 2
21071: ST_TO_ADDR
// hc_gallery :=  ;
21072: LD_ADDR_OWVAR 33
21076: PUSH
21077: LD_STRING 
21079: ST_TO_ADDR
// hc_name :=  ;
21080: LD_ADDR_OWVAR 26
21084: PUSH
21085: LD_STRING 
21087: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
21088: LD_INT 1
21090: PPUSH
21091: LD_INT 11
21093: PPUSH
21094: LD_INT 10
21096: PPUSH
21097: CALL_OW 380
// un := CreateHuman ;
21101: LD_ADDR_VAR 0 1
21105: PUSH
21106: CALL_OW 44
21110: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21111: LD_VAR 0 1
21115: PPUSH
21116: LD_INT 1
21118: PPUSH
21119: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
21123: LD_INT 35
21125: PPUSH
21126: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
21130: LD_VAR 0 1
21134: PPUSH
21135: LD_INT 22
21137: PUSH
21138: LD_OWVAR 2
21142: PUSH
21143: EMPTY
21144: LIST
21145: LIST
21146: PPUSH
21147: CALL_OW 69
21151: PPUSH
21152: LD_VAR 0 1
21156: PPUSH
21157: CALL_OW 74
21161: PPUSH
21162: CALL_OW 115
// until IsDead ( un ) ;
21166: LD_VAR 0 1
21170: PPUSH
21171: CALL_OW 301
21175: IFFALSE 21123
// end ;
21177: PPOPN 1
21179: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
21180: LD_EXP 46
21184: PUSH
21185: LD_EXP 86
21189: AND
21190: IFFALSE 21202
21192: GO 21194
21194: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
21195: LD_STRING earthquake(getX(game), 0, 32)
21197: PPUSH
21198: CALL_OW 559
21202: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
21203: LD_EXP 46
21207: PUSH
21208: LD_EXP 87
21212: AND
21213: IFFALSE 21304
21215: GO 21217
21217: DISABLE
21218: LD_INT 0
21220: PPUSH
// begin enable ;
21221: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
21222: LD_ADDR_VAR 0 1
21226: PUSH
21227: LD_INT 22
21229: PUSH
21230: LD_OWVAR 2
21234: PUSH
21235: EMPTY
21236: LIST
21237: LIST
21238: PUSH
21239: LD_INT 21
21241: PUSH
21242: LD_INT 2
21244: PUSH
21245: EMPTY
21246: LIST
21247: LIST
21248: PUSH
21249: LD_INT 33
21251: PUSH
21252: LD_INT 3
21254: PUSH
21255: EMPTY
21256: LIST
21257: LIST
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: LIST
21263: PPUSH
21264: CALL_OW 69
21268: ST_TO_ADDR
// if not tmp then
21269: LD_VAR 0 1
21273: NOT
21274: IFFALSE 21278
// exit ;
21276: GO 21304
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21278: LD_VAR 0 1
21282: PUSH
21283: LD_INT 1
21285: PPUSH
21286: LD_VAR 0 1
21290: PPUSH
21291: CALL_OW 12
21295: ARRAY
21296: PPUSH
21297: LD_INT 1
21299: PPUSH
21300: CALL_OW 234
// end ;
21304: PPOPN 1
21306: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
21307: LD_EXP 46
21311: PUSH
21312: LD_EXP 88
21316: AND
21317: IFFALSE 21458
21319: GO 21321
21321: DISABLE
21322: LD_INT 0
21324: PPUSH
21325: PPUSH
21326: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21327: LD_ADDR_VAR 0 3
21331: PUSH
21332: LD_INT 22
21334: PUSH
21335: LD_OWVAR 2
21339: PUSH
21340: EMPTY
21341: LIST
21342: LIST
21343: PUSH
21344: LD_INT 25
21346: PUSH
21347: LD_INT 1
21349: PUSH
21350: EMPTY
21351: LIST
21352: LIST
21353: PUSH
21354: EMPTY
21355: LIST
21356: LIST
21357: PPUSH
21358: CALL_OW 69
21362: ST_TO_ADDR
// if not tmp then
21363: LD_VAR 0 3
21367: NOT
21368: IFFALSE 21372
// exit ;
21370: GO 21458
// un := tmp [ rand ( 1 , tmp ) ] ;
21372: LD_ADDR_VAR 0 2
21376: PUSH
21377: LD_VAR 0 3
21381: PUSH
21382: LD_INT 1
21384: PPUSH
21385: LD_VAR 0 3
21389: PPUSH
21390: CALL_OW 12
21394: ARRAY
21395: ST_TO_ADDR
// if Crawls ( un ) then
21396: LD_VAR 0 2
21400: PPUSH
21401: CALL_OW 318
21405: IFFALSE 21416
// ComWalk ( un ) ;
21407: LD_VAR 0 2
21411: PPUSH
21412: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
21416: LD_VAR 0 2
21420: PPUSH
21421: LD_INT 9
21423: PPUSH
21424: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
21428: LD_INT 28
21430: PPUSH
21431: LD_OWVAR 2
21435: PPUSH
21436: LD_INT 2
21438: PPUSH
21439: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
21443: LD_INT 29
21445: PPUSH
21446: LD_OWVAR 2
21450: PPUSH
21451: LD_INT 2
21453: PPUSH
21454: CALL_OW 322
// end ;
21458: PPOPN 3
21460: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
21461: LD_EXP 46
21465: PUSH
21466: LD_EXP 89
21470: AND
21471: IFFALSE 21582
21473: GO 21475
21475: DISABLE
21476: LD_INT 0
21478: PPUSH
21479: PPUSH
21480: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21481: LD_ADDR_VAR 0 3
21485: PUSH
21486: LD_INT 22
21488: PUSH
21489: LD_OWVAR 2
21493: PUSH
21494: EMPTY
21495: LIST
21496: LIST
21497: PUSH
21498: LD_INT 25
21500: PUSH
21501: LD_INT 1
21503: PUSH
21504: EMPTY
21505: LIST
21506: LIST
21507: PUSH
21508: EMPTY
21509: LIST
21510: LIST
21511: PPUSH
21512: CALL_OW 69
21516: ST_TO_ADDR
// if not tmp then
21517: LD_VAR 0 3
21521: NOT
21522: IFFALSE 21526
// exit ;
21524: GO 21582
// un := tmp [ rand ( 1 , tmp ) ] ;
21526: LD_ADDR_VAR 0 2
21530: PUSH
21531: LD_VAR 0 3
21535: PUSH
21536: LD_INT 1
21538: PPUSH
21539: LD_VAR 0 3
21543: PPUSH
21544: CALL_OW 12
21548: ARRAY
21549: ST_TO_ADDR
// if Crawls ( un ) then
21550: LD_VAR 0 2
21554: PPUSH
21555: CALL_OW 318
21559: IFFALSE 21570
// ComWalk ( un ) ;
21561: LD_VAR 0 2
21565: PPUSH
21566: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21570: LD_VAR 0 2
21574: PPUSH
21575: LD_INT 8
21577: PPUSH
21578: CALL_OW 336
// end ;
21582: PPOPN 3
21584: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
21585: LD_EXP 46
21589: PUSH
21590: LD_EXP 90
21594: AND
21595: IFFALSE 21739
21597: GO 21599
21599: DISABLE
21600: LD_INT 0
21602: PPUSH
21603: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
21604: LD_ADDR_VAR 0 2
21608: PUSH
21609: LD_INT 22
21611: PUSH
21612: LD_OWVAR 2
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: PUSH
21621: LD_INT 21
21623: PUSH
21624: LD_INT 2
21626: PUSH
21627: EMPTY
21628: LIST
21629: LIST
21630: PUSH
21631: LD_INT 2
21633: PUSH
21634: LD_INT 34
21636: PUSH
21637: LD_INT 12
21639: PUSH
21640: EMPTY
21641: LIST
21642: LIST
21643: PUSH
21644: LD_INT 34
21646: PUSH
21647: LD_INT 51
21649: PUSH
21650: EMPTY
21651: LIST
21652: LIST
21653: PUSH
21654: LD_INT 34
21656: PUSH
21657: LD_INT 32
21659: PUSH
21660: EMPTY
21661: LIST
21662: LIST
21663: PUSH
21664: EMPTY
21665: LIST
21666: LIST
21667: LIST
21668: LIST
21669: PUSH
21670: EMPTY
21671: LIST
21672: LIST
21673: LIST
21674: PPUSH
21675: CALL_OW 69
21679: ST_TO_ADDR
// if not tmp then
21680: LD_VAR 0 2
21684: NOT
21685: IFFALSE 21689
// exit ;
21687: GO 21739
// for i in tmp do
21689: LD_ADDR_VAR 0 1
21693: PUSH
21694: LD_VAR 0 2
21698: PUSH
21699: FOR_IN
21700: IFFALSE 21737
// if GetCargo ( i , mat_artifact ) = 0 then
21702: LD_VAR 0 1
21706: PPUSH
21707: LD_INT 4
21709: PPUSH
21710: CALL_OW 289
21714: PUSH
21715: LD_INT 0
21717: EQUAL
21718: IFFALSE 21735
// SetCargo ( i , mat_siberit , 100 ) ;
21720: LD_VAR 0 1
21724: PPUSH
21725: LD_INT 3
21727: PPUSH
21728: LD_INT 100
21730: PPUSH
21731: CALL_OW 290
21735: GO 21699
21737: POP
21738: POP
// end ;
21739: PPOPN 2
21741: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
21742: LD_EXP 46
21746: PUSH
21747: LD_EXP 91
21751: AND
21752: IFFALSE 21935
21754: GO 21756
21756: DISABLE
21757: LD_INT 0
21759: PPUSH
21760: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
21761: LD_ADDR_VAR 0 2
21765: PUSH
21766: LD_INT 22
21768: PUSH
21769: LD_OWVAR 2
21773: PUSH
21774: EMPTY
21775: LIST
21776: LIST
21777: PPUSH
21778: CALL_OW 69
21782: ST_TO_ADDR
// if not tmp then
21783: LD_VAR 0 2
21787: NOT
21788: IFFALSE 21792
// exit ;
21790: GO 21935
// for i := 1 to 2 do
21792: LD_ADDR_VAR 0 1
21796: PUSH
21797: DOUBLE
21798: LD_INT 1
21800: DEC
21801: ST_TO_ADDR
21802: LD_INT 2
21804: PUSH
21805: FOR_TO
21806: IFFALSE 21933
// begin uc_side := your_side ;
21808: LD_ADDR_OWVAR 20
21812: PUSH
21813: LD_OWVAR 2
21817: ST_TO_ADDR
// uc_nation := nation_american ;
21818: LD_ADDR_OWVAR 21
21822: PUSH
21823: LD_INT 1
21825: ST_TO_ADDR
// vc_chassis := us_morphling ;
21826: LD_ADDR_OWVAR 37
21830: PUSH
21831: LD_INT 5
21833: ST_TO_ADDR
// vc_engine := engine_siberite ;
21834: LD_ADDR_OWVAR 39
21838: PUSH
21839: LD_INT 3
21841: ST_TO_ADDR
// vc_control := control_computer ;
21842: LD_ADDR_OWVAR 38
21846: PUSH
21847: LD_INT 3
21849: ST_TO_ADDR
// vc_weapon := us_double_laser ;
21850: LD_ADDR_OWVAR 40
21854: PUSH
21855: LD_INT 10
21857: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
21858: LD_VAR 0 2
21862: PUSH
21863: LD_INT 1
21865: ARRAY
21866: PPUSH
21867: CALL_OW 310
21871: NOT
21872: IFFALSE 21919
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
21874: CALL_OW 45
21878: PPUSH
21879: LD_VAR 0 2
21883: PUSH
21884: LD_INT 1
21886: ARRAY
21887: PPUSH
21888: CALL_OW 250
21892: PPUSH
21893: LD_VAR 0 2
21897: PUSH
21898: LD_INT 1
21900: ARRAY
21901: PPUSH
21902: CALL_OW 251
21906: PPUSH
21907: LD_INT 12
21909: PPUSH
21910: LD_INT 1
21912: PPUSH
21913: CALL_OW 50
21917: GO 21931
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
21919: CALL_OW 45
21923: PPUSH
21924: LD_INT 1
21926: PPUSH
21927: CALL_OW 51
// end ;
21931: GO 21805
21933: POP
21934: POP
// end ;
21935: PPOPN 2
21937: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
21938: LD_EXP 46
21942: PUSH
21943: LD_EXP 92
21947: AND
21948: IFFALSE 22170
21950: GO 21952
21952: DISABLE
21953: LD_INT 0
21955: PPUSH
21956: PPUSH
21957: PPUSH
21958: PPUSH
21959: PPUSH
21960: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21961: LD_ADDR_VAR 0 6
21965: PUSH
21966: LD_INT 22
21968: PUSH
21969: LD_OWVAR 2
21973: PUSH
21974: EMPTY
21975: LIST
21976: LIST
21977: PUSH
21978: LD_INT 21
21980: PUSH
21981: LD_INT 1
21983: PUSH
21984: EMPTY
21985: LIST
21986: LIST
21987: PUSH
21988: LD_INT 3
21990: PUSH
21991: LD_INT 23
21993: PUSH
21994: LD_INT 0
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: EMPTY
22002: LIST
22003: LIST
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: LIST
22009: PPUSH
22010: CALL_OW 69
22014: ST_TO_ADDR
// if not tmp then
22015: LD_VAR 0 6
22019: NOT
22020: IFFALSE 22024
// exit ;
22022: GO 22170
// s1 := rand ( 1 , 4 ) ;
22024: LD_ADDR_VAR 0 2
22028: PUSH
22029: LD_INT 1
22031: PPUSH
22032: LD_INT 4
22034: PPUSH
22035: CALL_OW 12
22039: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
22040: LD_ADDR_VAR 0 4
22044: PUSH
22045: LD_VAR 0 6
22049: PUSH
22050: LD_INT 1
22052: ARRAY
22053: PPUSH
22054: LD_VAR 0 2
22058: PPUSH
22059: CALL_OW 259
22063: ST_TO_ADDR
// if s1 = 1 then
22064: LD_VAR 0 2
22068: PUSH
22069: LD_INT 1
22071: EQUAL
22072: IFFALSE 22092
// s2 := rand ( 2 , 4 ) else
22074: LD_ADDR_VAR 0 3
22078: PUSH
22079: LD_INT 2
22081: PPUSH
22082: LD_INT 4
22084: PPUSH
22085: CALL_OW 12
22089: ST_TO_ADDR
22090: GO 22100
// s2 := 1 ;
22092: LD_ADDR_VAR 0 3
22096: PUSH
22097: LD_INT 1
22099: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
22100: LD_ADDR_VAR 0 5
22104: PUSH
22105: LD_VAR 0 6
22109: PUSH
22110: LD_INT 1
22112: ARRAY
22113: PPUSH
22114: LD_VAR 0 3
22118: PPUSH
22119: CALL_OW 259
22123: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
22124: LD_VAR 0 6
22128: PUSH
22129: LD_INT 1
22131: ARRAY
22132: PPUSH
22133: LD_VAR 0 2
22137: PPUSH
22138: LD_VAR 0 5
22142: PPUSH
22143: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
22147: LD_VAR 0 6
22151: PUSH
22152: LD_INT 1
22154: ARRAY
22155: PPUSH
22156: LD_VAR 0 3
22160: PPUSH
22161: LD_VAR 0 4
22165: PPUSH
22166: CALL_OW 237
// end ;
22170: PPOPN 6
22172: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
22173: LD_EXP 46
22177: PUSH
22178: LD_EXP 93
22182: AND
22183: IFFALSE 22262
22185: GO 22187
22187: DISABLE
22188: LD_INT 0
22190: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
22191: LD_ADDR_VAR 0 1
22195: PUSH
22196: LD_INT 22
22198: PUSH
22199: LD_OWVAR 2
22203: PUSH
22204: EMPTY
22205: LIST
22206: LIST
22207: PUSH
22208: LD_INT 30
22210: PUSH
22211: LD_INT 3
22213: PUSH
22214: EMPTY
22215: LIST
22216: LIST
22217: PUSH
22218: EMPTY
22219: LIST
22220: LIST
22221: PPUSH
22222: CALL_OW 69
22226: ST_TO_ADDR
// if not tmp then
22227: LD_VAR 0 1
22231: NOT
22232: IFFALSE 22236
// exit ;
22234: GO 22262
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
22236: LD_VAR 0 1
22240: PUSH
22241: LD_INT 1
22243: PPUSH
22244: LD_VAR 0 1
22248: PPUSH
22249: CALL_OW 12
22253: ARRAY
22254: PPUSH
22255: LD_INT 1
22257: PPUSH
22258: CALL_OW 234
// end ;
22262: PPOPN 1
22264: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
22265: LD_EXP 46
22269: PUSH
22270: LD_EXP 94
22274: AND
22275: IFFALSE 22387
22277: GO 22279
22279: DISABLE
22280: LD_INT 0
22282: PPUSH
22283: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
22284: LD_ADDR_VAR 0 2
22288: PUSH
22289: LD_INT 22
22291: PUSH
22292: LD_OWVAR 2
22296: PUSH
22297: EMPTY
22298: LIST
22299: LIST
22300: PUSH
22301: LD_INT 2
22303: PUSH
22304: LD_INT 30
22306: PUSH
22307: LD_INT 27
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PUSH
22314: LD_INT 30
22316: PUSH
22317: LD_INT 26
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: PUSH
22324: LD_INT 30
22326: PUSH
22327: LD_INT 28
22329: PUSH
22330: EMPTY
22331: LIST
22332: LIST
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: LIST
22338: LIST
22339: PUSH
22340: EMPTY
22341: LIST
22342: LIST
22343: PPUSH
22344: CALL_OW 69
22348: ST_TO_ADDR
// if not tmp then
22349: LD_VAR 0 2
22353: NOT
22354: IFFALSE 22358
// exit ;
22356: GO 22387
// for i in tmp do
22358: LD_ADDR_VAR 0 1
22362: PUSH
22363: LD_VAR 0 2
22367: PUSH
22368: FOR_IN
22369: IFFALSE 22385
// SetLives ( i , 1 ) ;
22371: LD_VAR 0 1
22375: PPUSH
22376: LD_INT 1
22378: PPUSH
22379: CALL_OW 234
22383: GO 22368
22385: POP
22386: POP
// end ;
22387: PPOPN 2
22389: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
22390: LD_EXP 46
22394: PUSH
22395: LD_EXP 95
22399: AND
22400: IFFALSE 22674
22402: GO 22404
22404: DISABLE
22405: LD_INT 0
22407: PPUSH
22408: PPUSH
22409: PPUSH
// begin i := rand ( 1 , 7 ) ;
22410: LD_ADDR_VAR 0 1
22414: PUSH
22415: LD_INT 1
22417: PPUSH
22418: LD_INT 7
22420: PPUSH
22421: CALL_OW 12
22425: ST_TO_ADDR
// case i of 1 :
22426: LD_VAR 0 1
22430: PUSH
22431: LD_INT 1
22433: DOUBLE
22434: EQUAL
22435: IFTRUE 22439
22437: GO 22449
22439: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
22440: LD_STRING earthquake(getX(game), 0, 32)
22442: PPUSH
22443: CALL_OW 559
22447: GO 22674
22449: LD_INT 2
22451: DOUBLE
22452: EQUAL
22453: IFTRUE 22457
22455: GO 22471
22457: POP
// begin ToLua ( displayStucuk(); ) ;
22458: LD_STRING displayStucuk();
22460: PPUSH
22461: CALL_OW 559
// ResetFog ;
22465: CALL_OW 335
// end ; 3 :
22469: GO 22674
22471: LD_INT 3
22473: DOUBLE
22474: EQUAL
22475: IFTRUE 22479
22477: GO 22583
22479: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
22480: LD_ADDR_VAR 0 2
22484: PUSH
22485: LD_INT 22
22487: PUSH
22488: LD_OWVAR 2
22492: PUSH
22493: EMPTY
22494: LIST
22495: LIST
22496: PUSH
22497: LD_INT 25
22499: PUSH
22500: LD_INT 1
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: PPUSH
22511: CALL_OW 69
22515: ST_TO_ADDR
// if not tmp then
22516: LD_VAR 0 2
22520: NOT
22521: IFFALSE 22525
// exit ;
22523: GO 22674
// un := tmp [ rand ( 1 , tmp ) ] ;
22525: LD_ADDR_VAR 0 3
22529: PUSH
22530: LD_VAR 0 2
22534: PUSH
22535: LD_INT 1
22537: PPUSH
22538: LD_VAR 0 2
22542: PPUSH
22543: CALL_OW 12
22547: ARRAY
22548: ST_TO_ADDR
// if Crawls ( un ) then
22549: LD_VAR 0 3
22553: PPUSH
22554: CALL_OW 318
22558: IFFALSE 22569
// ComWalk ( un ) ;
22560: LD_VAR 0 3
22564: PPUSH
22565: CALL_OW 138
// SetClass ( un , class_mortar ) ;
22569: LD_VAR 0 3
22573: PPUSH
22574: LD_INT 8
22576: PPUSH
22577: CALL_OW 336
// end ; 4 :
22581: GO 22674
22583: LD_INT 4
22585: DOUBLE
22586: EQUAL
22587: IFTRUE 22591
22589: GO 22652
22591: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
22592: LD_ADDR_VAR 0 2
22596: PUSH
22597: LD_INT 22
22599: PUSH
22600: LD_OWVAR 2
22604: PUSH
22605: EMPTY
22606: LIST
22607: LIST
22608: PUSH
22609: LD_INT 30
22611: PUSH
22612: LD_INT 29
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: PUSH
22619: EMPTY
22620: LIST
22621: LIST
22622: PPUSH
22623: CALL_OW 69
22627: ST_TO_ADDR
// if not tmp then
22628: LD_VAR 0 2
22632: NOT
22633: IFFALSE 22637
// exit ;
22635: GO 22674
// DestroyUnit ( tmp [ 1 ] ) ;
22637: LD_VAR 0 2
22641: PUSH
22642: LD_INT 1
22644: ARRAY
22645: PPUSH
22646: CALL_OW 65
// end ; 5 .. 7 :
22650: GO 22674
22652: LD_INT 5
22654: DOUBLE
22655: GREATEREQUAL
22656: IFFALSE 22664
22658: LD_INT 7
22660: DOUBLE
22661: LESSEQUAL
22662: IFTRUE 22666
22664: GO 22673
22666: POP
// StreamSibBomb ; end ;
22667: CALL 18924 0 0
22671: GO 22674
22673: POP
// end ;
22674: PPOPN 3
22676: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
22677: LD_EXP 46
22681: PUSH
22682: LD_EXP 96
22686: AND
22687: IFFALSE 22843
22689: GO 22691
22691: DISABLE
22692: LD_INT 0
22694: PPUSH
22695: PPUSH
22696: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
22697: LD_ADDR_VAR 0 2
22701: PUSH
22702: LD_INT 81
22704: PUSH
22705: LD_OWVAR 2
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: PUSH
22714: LD_INT 2
22716: PUSH
22717: LD_INT 21
22719: PUSH
22720: LD_INT 1
22722: PUSH
22723: EMPTY
22724: LIST
22725: LIST
22726: PUSH
22727: LD_INT 21
22729: PUSH
22730: LD_INT 2
22732: PUSH
22733: EMPTY
22734: LIST
22735: LIST
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: LIST
22741: PUSH
22742: EMPTY
22743: LIST
22744: LIST
22745: PPUSH
22746: CALL_OW 69
22750: ST_TO_ADDR
// if not tmp then
22751: LD_VAR 0 2
22755: NOT
22756: IFFALSE 22760
// exit ;
22758: GO 22843
// p := 0 ;
22760: LD_ADDR_VAR 0 3
22764: PUSH
22765: LD_INT 0
22767: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22768: LD_INT 35
22770: PPUSH
22771: CALL_OW 67
// p := p + 1 ;
22775: LD_ADDR_VAR 0 3
22779: PUSH
22780: LD_VAR 0 3
22784: PUSH
22785: LD_INT 1
22787: PLUS
22788: ST_TO_ADDR
// for i in tmp do
22789: LD_ADDR_VAR 0 1
22793: PUSH
22794: LD_VAR 0 2
22798: PUSH
22799: FOR_IN
22800: IFFALSE 22831
// if GetLives ( i ) < 1000 then
22802: LD_VAR 0 1
22806: PPUSH
22807: CALL_OW 256
22811: PUSH
22812: LD_INT 1000
22814: LESS
22815: IFFALSE 22829
// SetLives ( i , 1000 ) ;
22817: LD_VAR 0 1
22821: PPUSH
22822: LD_INT 1000
22824: PPUSH
22825: CALL_OW 234
22829: GO 22799
22831: POP
22832: POP
// until p > 20 ;
22833: LD_VAR 0 3
22837: PUSH
22838: LD_INT 20
22840: GREATER
22841: IFFALSE 22768
// end ;
22843: PPOPN 3
22845: END
// every 0 0$1 trigger StreamModeActive and sTime do
22846: LD_EXP 46
22850: PUSH
22851: LD_EXP 97
22855: AND
22856: IFFALSE 22891
22858: GO 22860
22860: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
22861: LD_INT 28
22863: PPUSH
22864: LD_OWVAR 2
22868: PPUSH
22869: LD_INT 2
22871: PPUSH
22872: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
22876: LD_INT 30
22878: PPUSH
22879: LD_OWVAR 2
22883: PPUSH
22884: LD_INT 2
22886: PPUSH
22887: CALL_OW 322
// end ;
22891: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
22892: LD_EXP 46
22896: PUSH
22897: LD_EXP 98
22901: AND
22902: IFFALSE 23023
22904: GO 22906
22906: DISABLE
22907: LD_INT 0
22909: PPUSH
22910: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22911: LD_ADDR_VAR 0 2
22915: PUSH
22916: LD_INT 22
22918: PUSH
22919: LD_OWVAR 2
22923: PUSH
22924: EMPTY
22925: LIST
22926: LIST
22927: PUSH
22928: LD_INT 21
22930: PUSH
22931: LD_INT 1
22933: PUSH
22934: EMPTY
22935: LIST
22936: LIST
22937: PUSH
22938: LD_INT 3
22940: PUSH
22941: LD_INT 23
22943: PUSH
22944: LD_INT 0
22946: PUSH
22947: EMPTY
22948: LIST
22949: LIST
22950: PUSH
22951: EMPTY
22952: LIST
22953: LIST
22954: PUSH
22955: EMPTY
22956: LIST
22957: LIST
22958: LIST
22959: PPUSH
22960: CALL_OW 69
22964: ST_TO_ADDR
// if not tmp then
22965: LD_VAR 0 2
22969: NOT
22970: IFFALSE 22974
// exit ;
22972: GO 23023
// for i in tmp do
22974: LD_ADDR_VAR 0 1
22978: PUSH
22979: LD_VAR 0 2
22983: PUSH
22984: FOR_IN
22985: IFFALSE 23021
// begin if Crawls ( i ) then
22987: LD_VAR 0 1
22991: PPUSH
22992: CALL_OW 318
22996: IFFALSE 23007
// ComWalk ( i ) ;
22998: LD_VAR 0 1
23002: PPUSH
23003: CALL_OW 138
// SetClass ( i , 2 ) ;
23007: LD_VAR 0 1
23011: PPUSH
23012: LD_INT 2
23014: PPUSH
23015: CALL_OW 336
// end ;
23019: GO 22984
23021: POP
23022: POP
// end ;
23023: PPOPN 2
23025: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
23026: LD_EXP 46
23030: PUSH
23031: LD_EXP 99
23035: AND
23036: IFFALSE 23317
23038: GO 23040
23040: DISABLE
23041: LD_INT 0
23043: PPUSH
23044: PPUSH
23045: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
23046: LD_OWVAR 2
23050: PPUSH
23051: LD_INT 9
23053: PPUSH
23054: LD_INT 1
23056: PPUSH
23057: LD_INT 1
23059: PPUSH
23060: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
23064: LD_INT 9
23066: PPUSH
23067: LD_OWVAR 2
23071: PPUSH
23072: CALL_OW 343
// uc_side := 9 ;
23076: LD_ADDR_OWVAR 20
23080: PUSH
23081: LD_INT 9
23083: ST_TO_ADDR
// uc_nation := 2 ;
23084: LD_ADDR_OWVAR 21
23088: PUSH
23089: LD_INT 2
23091: ST_TO_ADDR
// hc_name := Dark Warrior ;
23092: LD_ADDR_OWVAR 26
23096: PUSH
23097: LD_STRING Dark Warrior
23099: ST_TO_ADDR
// hc_gallery :=  ;
23100: LD_ADDR_OWVAR 33
23104: PUSH
23105: LD_STRING 
23107: ST_TO_ADDR
// hc_noskilllimit := true ;
23108: LD_ADDR_OWVAR 76
23112: PUSH
23113: LD_INT 1
23115: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
23116: LD_ADDR_OWVAR 31
23120: PUSH
23121: LD_INT 30
23123: PUSH
23124: LD_INT 30
23126: PUSH
23127: LD_INT 30
23129: PUSH
23130: LD_INT 30
23132: PUSH
23133: EMPTY
23134: LIST
23135: LIST
23136: LIST
23137: LIST
23138: ST_TO_ADDR
// un := CreateHuman ;
23139: LD_ADDR_VAR 0 3
23143: PUSH
23144: CALL_OW 44
23148: ST_TO_ADDR
// hc_noskilllimit := false ;
23149: LD_ADDR_OWVAR 76
23153: PUSH
23154: LD_INT 0
23156: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
23157: LD_VAR 0 3
23161: PPUSH
23162: LD_INT 1
23164: PPUSH
23165: CALL_OW 51
// p := 0 ;
23169: LD_ADDR_VAR 0 2
23173: PUSH
23174: LD_INT 0
23176: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23177: LD_INT 35
23179: PPUSH
23180: CALL_OW 67
// p := p + 1 ;
23184: LD_ADDR_VAR 0 2
23188: PUSH
23189: LD_VAR 0 2
23193: PUSH
23194: LD_INT 1
23196: PLUS
23197: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
23198: LD_VAR 0 3
23202: PPUSH
23203: CALL_OW 256
23207: PUSH
23208: LD_INT 1000
23210: LESS
23211: IFFALSE 23225
// SetLives ( un , 1000 ) ;
23213: LD_VAR 0 3
23217: PPUSH
23218: LD_INT 1000
23220: PPUSH
23221: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
23225: LD_VAR 0 3
23229: PPUSH
23230: LD_INT 81
23232: PUSH
23233: LD_OWVAR 2
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: PUSH
23242: LD_INT 91
23244: PUSH
23245: LD_VAR 0 3
23249: PUSH
23250: LD_INT 30
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: LIST
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: PPUSH
23262: CALL_OW 69
23266: PPUSH
23267: LD_VAR 0 3
23271: PPUSH
23272: CALL_OW 74
23276: PPUSH
23277: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
23281: LD_VAR 0 2
23285: PUSH
23286: LD_INT 60
23288: GREATER
23289: PUSH
23290: LD_VAR 0 3
23294: PPUSH
23295: CALL_OW 301
23299: OR
23300: IFFALSE 23177
// if un then
23302: LD_VAR 0 3
23306: IFFALSE 23317
// RemoveUnit ( un ) ;
23308: LD_VAR 0 3
23312: PPUSH
23313: CALL_OW 64
// end ; end_of_file
23317: PPOPN 3
23319: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
23320: LD_INT 0
23322: PPUSH
23323: PPUSH
23324: PPUSH
23325: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
23326: LD_VAR 0 1
23330: PPUSH
23331: CALL_OW 264
23335: PUSH
23336: LD_EXP 36
23340: EQUAL
23341: IFFALSE 23413
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
23343: LD_INT 68
23345: PPUSH
23346: LD_VAR 0 1
23350: PPUSH
23351: CALL_OW 255
23355: PPUSH
23356: CALL_OW 321
23360: PUSH
23361: LD_INT 2
23363: EQUAL
23364: IFFALSE 23376
// eff := 70 else
23366: LD_ADDR_VAR 0 4
23370: PUSH
23371: LD_INT 70
23373: ST_TO_ADDR
23374: GO 23384
// eff := 30 ;
23376: LD_ADDR_VAR 0 4
23380: PUSH
23381: LD_INT 30
23383: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
23384: LD_VAR 0 1
23388: PPUSH
23389: CALL_OW 250
23393: PPUSH
23394: LD_VAR 0 1
23398: PPUSH
23399: CALL_OW 251
23403: PPUSH
23404: LD_VAR 0 4
23408: PPUSH
23409: CALL_OW 495
// end ; end ;
23413: LD_VAR 0 2
23417: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
23418: LD_INT 0
23420: PPUSH
// end ;
23421: LD_VAR 0 4
23425: RET
// export function SOS_Command ( cmd ) ; begin
23426: LD_INT 0
23428: PPUSH
// end ;
23429: LD_VAR 0 2
23433: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
23434: LD_VAR 0 1
23438: PUSH
23439: LD_INT 255
23441: EQUAL
23442: PUSH
23443: LD_VAR 0 2
23447: PPUSH
23448: CALL_OW 264
23452: PUSH
23453: LD_INT 14
23455: PUSH
23456: LD_INT 53
23458: PUSH
23459: EMPTY
23460: LIST
23461: LIST
23462: IN
23463: AND
23464: PUSH
23465: LD_VAR 0 4
23469: PPUSH
23470: LD_VAR 0 5
23474: PPUSH
23475: CALL_OW 488
23479: AND
23480: IFFALSE 23504
// CutTreeXYR ( unit , x , y , 12 ) ;
23482: LD_VAR 0 2
23486: PPUSH
23487: LD_VAR 0 4
23491: PPUSH
23492: LD_VAR 0 5
23496: PPUSH
23497: LD_INT 12
23499: PPUSH
23500: CALL 23507 0 4
// end ;
23504: PPOPN 5
23506: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
23507: LD_INT 0
23509: PPUSH
23510: PPUSH
23511: PPUSH
23512: PPUSH
23513: PPUSH
23514: PPUSH
23515: PPUSH
23516: PPUSH
23517: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
23518: LD_VAR 0 1
23522: NOT
23523: PUSH
23524: LD_VAR 0 2
23528: PPUSH
23529: LD_VAR 0 3
23533: PPUSH
23534: CALL_OW 488
23538: NOT
23539: OR
23540: PUSH
23541: LD_VAR 0 4
23545: NOT
23546: OR
23547: IFFALSE 23551
// exit ;
23549: GO 23891
// list := [ ] ;
23551: LD_ADDR_VAR 0 13
23555: PUSH
23556: EMPTY
23557: ST_TO_ADDR
// if x - r < 0 then
23558: LD_VAR 0 2
23562: PUSH
23563: LD_VAR 0 4
23567: MINUS
23568: PUSH
23569: LD_INT 0
23571: LESS
23572: IFFALSE 23584
// min_x := 0 else
23574: LD_ADDR_VAR 0 7
23578: PUSH
23579: LD_INT 0
23581: ST_TO_ADDR
23582: GO 23600
// min_x := x - r ;
23584: LD_ADDR_VAR 0 7
23588: PUSH
23589: LD_VAR 0 2
23593: PUSH
23594: LD_VAR 0 4
23598: MINUS
23599: ST_TO_ADDR
// if y - r < 0 then
23600: LD_VAR 0 3
23604: PUSH
23605: LD_VAR 0 4
23609: MINUS
23610: PUSH
23611: LD_INT 0
23613: LESS
23614: IFFALSE 23626
// min_y := 0 else
23616: LD_ADDR_VAR 0 8
23620: PUSH
23621: LD_INT 0
23623: ST_TO_ADDR
23624: GO 23642
// min_y := y - r ;
23626: LD_ADDR_VAR 0 8
23630: PUSH
23631: LD_VAR 0 3
23635: PUSH
23636: LD_VAR 0 4
23640: MINUS
23641: ST_TO_ADDR
// max_x := x + r ;
23642: LD_ADDR_VAR 0 9
23646: PUSH
23647: LD_VAR 0 2
23651: PUSH
23652: LD_VAR 0 4
23656: PLUS
23657: ST_TO_ADDR
// max_y := y + r ;
23658: LD_ADDR_VAR 0 10
23662: PUSH
23663: LD_VAR 0 3
23667: PUSH
23668: LD_VAR 0 4
23672: PLUS
23673: ST_TO_ADDR
// for _x = min_x to max_x do
23674: LD_ADDR_VAR 0 11
23678: PUSH
23679: DOUBLE
23680: LD_VAR 0 7
23684: DEC
23685: ST_TO_ADDR
23686: LD_VAR 0 9
23690: PUSH
23691: FOR_TO
23692: IFFALSE 23809
// for _y = min_y to max_y do
23694: LD_ADDR_VAR 0 12
23698: PUSH
23699: DOUBLE
23700: LD_VAR 0 8
23704: DEC
23705: ST_TO_ADDR
23706: LD_VAR 0 10
23710: PUSH
23711: FOR_TO
23712: IFFALSE 23805
// begin if not ValidHex ( _x , _y ) then
23714: LD_VAR 0 11
23718: PPUSH
23719: LD_VAR 0 12
23723: PPUSH
23724: CALL_OW 488
23728: NOT
23729: IFFALSE 23733
// continue ;
23731: GO 23711
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
23733: LD_VAR 0 11
23737: PPUSH
23738: LD_VAR 0 12
23742: PPUSH
23743: CALL_OW 351
23747: PUSH
23748: LD_VAR 0 11
23752: PPUSH
23753: LD_VAR 0 12
23757: PPUSH
23758: CALL_OW 554
23762: AND
23763: IFFALSE 23803
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
23765: LD_ADDR_VAR 0 13
23769: PUSH
23770: LD_VAR 0 13
23774: PPUSH
23775: LD_VAR 0 13
23779: PUSH
23780: LD_INT 1
23782: PLUS
23783: PPUSH
23784: LD_VAR 0 11
23788: PUSH
23789: LD_VAR 0 12
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: PPUSH
23798: CALL_OW 2
23802: ST_TO_ADDR
// end ;
23803: GO 23711
23805: POP
23806: POP
23807: GO 23691
23809: POP
23810: POP
// if not list then
23811: LD_VAR 0 13
23815: NOT
23816: IFFALSE 23820
// exit ;
23818: GO 23891
// for i in list do
23820: LD_ADDR_VAR 0 6
23824: PUSH
23825: LD_VAR 0 13
23829: PUSH
23830: FOR_IN
23831: IFFALSE 23889
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
23833: LD_VAR 0 1
23837: PPUSH
23838: LD_STRING M
23840: PUSH
23841: LD_VAR 0 6
23845: PUSH
23846: LD_INT 1
23848: ARRAY
23849: PUSH
23850: LD_VAR 0 6
23854: PUSH
23855: LD_INT 2
23857: ARRAY
23858: PUSH
23859: LD_INT 0
23861: PUSH
23862: LD_INT 0
23864: PUSH
23865: LD_INT 0
23867: PUSH
23868: LD_INT 0
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: LIST
23878: LIST
23879: PUSH
23880: EMPTY
23881: LIST
23882: PPUSH
23883: CALL_OW 447
23887: GO 23830
23889: POP
23890: POP
// end ;
23891: LD_VAR 0 5
23895: RET
