// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 580 0 0
// PrepareAmericans ;
  23: CALL 826 0 0
// PrepareArabian ;
  27: CALL 10127 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 198 0 0
// Action ;
  41: CALL 4599 0 0
// end ;
  45: END
// export debug , prefix , missionStart , aviradzeSpotted , deltaSpotted , sciSpotted , aviradzeQuestDone , sciCounterKill , usAlert , usActiveDefend , timeUntilFarmer , attackDeltaAllowed , trickyMove , usPatrol , trap , lostCounter ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := false ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// aviradzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 6
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 8
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// aviradzeQuestDone := false ;
  97: LD_ADDR_EXP 7
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// attackDeltaAllowed := false ;
 105: LD_ADDR_EXP 12
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// usAlert := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// usActiveDefend := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// usPatrol := [ ] ;
 129: LD_ADDR_EXP 14
 133: PUSH
 134: EMPTY
 135: ST_TO_ADDR
// timeUntilFarmer := [ 40 40$00 , 30 30$00 , 20 20$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 11
 140: PUSH
 141: LD_INT 84000
 143: PUSH
 144: LD_INT 63000
 146: PUSH
 147: LD_INT 42000
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// trickyMove := false ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// prefix := 01_ ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 01_
 176: ST_TO_ADDR
// trap := 0 ;
 177: LD_ADDR_EXP 15
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// lostCounter := false ;
 185: LD_ADDR_EXP 16
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// end ;
 193: LD_VAR 0 1
 197: RET
// function DebugMode ; begin
 198: LD_INT 0
 200: PPUSH
// FogOff ( 1 ) ;
 201: LD_INT 1
 203: PPUSH
 204: CALL_OW 344
// Difficulty := 2 ;
 208: LD_ADDR_OWVAR 67
 212: PUSH
 213: LD_INT 2
 215: ST_TO_ADDR
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
// if exist_mode then
 225: LD_VAR 0 2
 229: IFFALSE 254
// unit := CreateCharacter ( prefix & ident ) else
 231: LD_ADDR_VAR 0 5
 235: PUSH
 236: LD_VAR 0 3
 240: PUSH
 241: LD_VAR 0 1
 245: STR
 246: PPUSH
 247: CALL_OW 34
 251: ST_TO_ADDR
 252: GO 269
// unit := NewCharacter ( ident ) ;
 254: LD_ADDR_VAR 0 5
 258: PUSH
 259: LD_VAR 0 1
 263: PPUSH
 264: CALL_OW 25
 268: ST_TO_ADDR
// result := unit ;
 269: LD_ADDR_VAR 0 4
 273: PUSH
 274: LD_VAR 0 5
 278: ST_TO_ADDR
// end ;
 279: LD_VAR 0 4
 283: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 284: LD_INT 0
 286: PPUSH
// uc_side := side ;
 287: LD_ADDR_OWVAR 20
 291: PUSH
 292: LD_VAR 0 1
 296: ST_TO_ADDR
// uc_nation := nation ;
 297: LD_ADDR_OWVAR 21
 301: PUSH
 302: LD_VAR 0 2
 306: ST_TO_ADDR
// vc_chassis := chassis ;
 307: LD_ADDR_OWVAR 37
 311: PUSH
 312: LD_VAR 0 3
 316: ST_TO_ADDR
// vc_engine := engine ;
 317: LD_ADDR_OWVAR 39
 321: PUSH
 322: LD_VAR 0 4
 326: ST_TO_ADDR
// vc_control := control ;
 327: LD_ADDR_OWVAR 38
 331: PUSH
 332: LD_VAR 0 5
 336: ST_TO_ADDR
// vc_weapon := weapon ;
 337: LD_ADDR_OWVAR 40
 341: PUSH
 342: LD_VAR 0 6
 346: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 347: LD_ADDR_OWVAR 41
 351: PUSH
 352: LD_VAR 0 7
 356: ST_TO_ADDR
// result := CreateVehicle ;
 357: LD_ADDR_VAR 0 8
 361: PUSH
 362: CALL_OW 45
 366: ST_TO_ADDR
// end ;
 367: LD_VAR 0 8
 371: RET
// export function SayX ( units , ident ) ; var i ; begin
 372: LD_INT 0
 374: PPUSH
 375: PPUSH
// result := false ;
 376: LD_ADDR_VAR 0 3
 380: PUSH
 381: LD_INT 0
 383: ST_TO_ADDR
// if not units then
 384: LD_VAR 0 1
 388: NOT
 389: IFFALSE 393
// exit ;
 391: GO 447
// for i in units do
 393: LD_ADDR_VAR 0 4
 397: PUSH
 398: LD_VAR 0 1
 402: PUSH
 403: FOR_IN
 404: IFFALSE 445
// if IsOk ( i ) then
 406: LD_VAR 0 4
 410: PPUSH
 411: CALL_OW 302
 415: IFFALSE 443
// begin Say ( i , ident ) ;
 417: LD_VAR 0 4
 421: PPUSH
 422: LD_VAR 0 2
 426: PPUSH
 427: CALL_OW 88
// result := i ;
 431: LD_ADDR_VAR 0 3
 435: PUSH
 436: LD_VAR 0 4
 440: ST_TO_ADDR
// break ;
 441: GO 445
// end ;
 443: GO 403
 445: POP
 446: POP
// end ;
 447: LD_VAR 0 3
 451: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 452: LD_INT 0
 454: PPUSH
 455: PPUSH
// InitUc ;
 456: CALL_OW 18
// InitHc ;
 460: CALL_OW 19
// uc_side := 0 ;
 464: LD_ADDR_OWVAR 20
 468: PUSH
 469: LD_INT 0
 471: ST_TO_ADDR
// uc_nation := 0 ;
 472: LD_ADDR_OWVAR 21
 476: PUSH
 477: LD_INT 0
 479: ST_TO_ADDR
// for i = 1 to amount do
 480: LD_ADDR_VAR 0 4
 484: PUSH
 485: DOUBLE
 486: LD_INT 1
 488: DEC
 489: ST_TO_ADDR
 490: LD_VAR 0 2
 494: PUSH
 495: FOR_TO
 496: IFFALSE 569
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 498: LD_ADDR_OWVAR 29
 502: PUSH
 503: LD_INT 9
 505: PPUSH
 506: LD_INT 12
 508: PPUSH
 509: CALL_OW 12
 513: PUSH
 514: LD_INT 9
 516: PPUSH
 517: LD_INT 12
 519: PPUSH
 520: CALL_OW 12
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: ST_TO_ADDR
// hc_agressivity := 0 ;
 529: LD_ADDR_OWVAR 35
 533: PUSH
 534: LD_INT 0
 536: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 537: LD_INT 0
 539: PPUSH
 540: LD_INT 12
 542: PPUSH
 543: LD_INT 1
 545: PPUSH
 546: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 550: CALL_OW 44
 554: PPUSH
 555: LD_VAR 0 1
 559: PPUSH
 560: LD_INT 0
 562: PPUSH
 563: CALL_OW 49
// end ;
 567: GO 495
 569: POP
 570: POP
// InitHc ;
 571: CALL_OW 19
// end ;
 575: LD_VAR 0 3
 579: RET
// export function PrepareNature ; var i ; begin
 580: LD_INT 0
 582: PPUSH
 583: PPUSH
// SpawnApeman ( forest , 9 ) ;
 584: LD_INT 1
 586: PPUSH
 587: LD_INT 9
 589: PPUSH
 590: CALL 452 0 2
// for i := 1 to 4 do
 594: LD_ADDR_VAR 0 2
 598: PUSH
 599: DOUBLE
 600: LD_INT 1
 602: DEC
 603: ST_TO_ADDR
 604: LD_INT 4
 606: PUSH
 607: FOR_TO
 608: IFFALSE 643
// begin hc_class := 21 ;
 610: LD_ADDR_OWVAR 28
 614: PUSH
 615: LD_INT 21
 617: ST_TO_ADDR
// hc_gallery :=  ;
 618: LD_ADDR_OWVAR 33
 622: PUSH
 623: LD_STRING 
 625: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 626: CALL_OW 44
 630: PPUSH
 631: LD_INT 1
 633: PPUSH
 634: LD_INT 0
 636: PPUSH
 637: CALL_OW 49
// end ;
 641: GO 607
 643: POP
 644: POP
// for i := 1 to 2 do
 645: LD_ADDR_VAR 0 2
 649: PUSH
 650: DOUBLE
 651: LD_INT 1
 653: DEC
 654: ST_TO_ADDR
 655: LD_INT 2
 657: PUSH
 658: FOR_TO
 659: IFFALSE 694
// begin hc_class := 18 ;
 661: LD_ADDR_OWVAR 28
 665: PUSH
 666: LD_INT 18
 668: ST_TO_ADDR
// hc_gallery :=  ;
 669: LD_ADDR_OWVAR 33
 673: PUSH
 674: LD_STRING 
 676: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 677: CALL_OW 44
 681: PPUSH
 682: LD_INT 1
 684: PPUSH
 685: LD_INT 0
 687: PPUSH
 688: CALL_OW 49
// end ;
 692: GO 658
 694: POP
 695: POP
// for i := 1 to 3 do
 696: LD_ADDR_VAR 0 2
 700: PUSH
 701: DOUBLE
 702: LD_INT 1
 704: DEC
 705: ST_TO_ADDR
 706: LD_INT 3
 708: PUSH
 709: FOR_TO
 710: IFFALSE 745
// begin hc_class := 13 ;
 712: LD_ADDR_OWVAR 28
 716: PUSH
 717: LD_INT 13
 719: ST_TO_ADDR
// hc_gallery :=  ;
 720: LD_ADDR_OWVAR 33
 724: PUSH
 725: LD_STRING 
 727: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 728: CALL_OW 44
 732: PPUSH
 733: LD_INT 1
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 49
// end ;
 743: GO 709
 745: POP
 746: POP
// end ;
 747: LD_VAR 0 1
 751: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 752: LD_INT 0
 754: PPUSH
 755: PPUSH
 756: PPUSH
// if not observer or not unit then
 757: LD_VAR 0 1
 761: NOT
 762: PUSH
 763: LD_VAR 0 2
 767: NOT
 768: OR
 769: IFFALSE 773
// exit ;
 771: GO 821
// if not See ( GetSide ( observer ) , unit ) then
 773: LD_VAR 0 1
 777: PPUSH
 778: CALL_OW 255
 782: PPUSH
 783: LD_VAR 0 2
 787: PPUSH
 788: CALL_OW 292
 792: NOT
 793: IFFALSE 797
// exit ;
 795: GO 821
// result := GetDistUnits ( observer , unit ) < 12 ;
 797: LD_ADDR_VAR 0 3
 801: PUSH
 802: LD_VAR 0 1
 806: PPUSH
 807: LD_VAR 0 2
 811: PPUSH
 812: CALL_OW 296
 816: PUSH
 817: LD_INT 12
 819: LESS
 820: ST_TO_ADDR
// end ; end_of_file
 821: LD_VAR 0 3
 825: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp , arm ; begin
 826: LD_INT 0
 828: PPUSH
 829: PPUSH
 830: PPUSH
 831: PPUSH
 832: PPUSH
 833: PPUSH
// usForces := [ ] ;
 834: LD_ADDR_EXP 19
 838: PUSH
 839: EMPTY
 840: ST_TO_ADDR
// usSci := [ ] ;
 841: LD_ADDR_EXP 20
 845: PUSH
 846: EMPTY
 847: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 848: LD_INT 1
 850: PPUSH
 851: LD_STRING Delta
 853: PPUSH
 854: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 858: LD_INT 1
 860: PPUSH
 861: CALL_OW 274
 865: PPUSH
 866: LD_INT 1
 868: PPUSH
 869: LD_INT 400
 871: PPUSH
 872: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 876: LD_INT 1
 878: PPUSH
 879: CALL_OW 274
 883: PPUSH
 884: LD_INT 2
 886: PPUSH
 887: LD_INT 80
 889: PPUSH
 890: CALL_OW 277
// uc_side := 1 ;
 894: LD_ADDR_OWVAR 20
 898: PUSH
 899: LD_INT 1
 901: ST_TO_ADDR
// uc_nation := 1 ;
 902: LD_ADDR_OWVAR 21
 906: PUSH
 907: LD_INT 1
 909: ST_TO_ADDR
// InitHc ;
 910: CALL_OW 19
// hc_importance := 0 ;
 914: LD_ADDR_OWVAR 32
 918: PUSH
 919: LD_INT 0
 921: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 922: LD_ADDR_EXP 18
 926: PUSH
 927: LD_STRING Lynch
 929: PPUSH
 930: LD_INT 0
 932: PPUSH
 933: LD_STRING 
 935: PPUSH
 936: CALL 221 0 3
 940: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Gladstone
 948: PPUSH
 949: LD_INT 0
 951: PPUSH
 952: LD_STRING 
 954: PPUSH
 955: CALL 221 0 3
 959: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 960: LD_EXP 18
 964: PPUSH
 965: LD_INT 1
 967: PPUSH
 968: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 972: LD_EXP 17
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
 984: LD_ADDR_VAR 0 2
 988: PUSH
 989: DOUBLE
 990: LD_INT 1
 992: DEC
 993: ST_TO_ADDR
 994: LD_INT 1
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: LD_INT 2
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: PUSH
1008: LD_OWVAR 67
1012: ARRAY
1013: PUSH
1014: FOR_TO
1015: IFFALSE 1061
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1017: LD_INT 0
1019: PPUSH
1020: LD_INT 2
1022: PPUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 2
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_OWVAR 67
1041: ARRAY
1042: PPUSH
1043: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
1047: CALL_OW 44
1051: PPUSH
1052: LD_INT 1
1054: PPUSH
1055: CALL_OW 52
// end ;
1059: GO 1014
1061: POP
1062: POP
// for i := 1 to 2 + Difficulty do
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: DOUBLE
1069: LD_INT 1
1071: DEC
1072: ST_TO_ADDR
1073: LD_INT 2
1075: PUSH
1076: LD_OWVAR 67
1080: PLUS
1081: PUSH
1082: FOR_TO
1083: IFFALSE 1168
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1085: LD_INT 0
1087: PPUSH
1088: LD_INT 4
1090: PPUSH
1091: LD_INT 1
1093: PUSH
1094: LD_INT 2
1096: PUSH
1097: LD_INT 2
1099: PUSH
1100: EMPTY
1101: LIST
1102: LIST
1103: LIST
1104: PUSH
1105: LD_OWVAR 67
1109: ARRAY
1110: PPUSH
1111: CALL_OW 380
// un := CreateHuman ;
1115: LD_ADDR_VAR 0 3
1119: PUSH
1120: CALL_OW 44
1124: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
1125: LD_VAR 0 3
1129: PPUSH
1130: LD_INT 3
1132: PPUSH
1133: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
1137: LD_ADDR_EXP 20
1141: PUSH
1142: LD_EXP 20
1146: PPUSH
1147: LD_EXP 20
1151: PUSH
1152: LD_INT 1
1154: PLUS
1155: PPUSH
1156: LD_VAR 0 3
1160: PPUSH
1161: CALL_OW 1
1165: ST_TO_ADDR
// end ;
1166: GO 1082
1168: POP
1169: POP
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
1170: LD_ADDR_VAR 0 6
1174: PUSH
1175: LD_INT 22
1177: PUSH
1178: LD_INT 1
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 30
1187: PUSH
1188: LD_INT 4
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: PPUSH
1199: CALL_OW 69
1203: ST_TO_ADDR
// for i := 1 to 3 + Difficulty do
1204: LD_ADDR_VAR 0 2
1208: PUSH
1209: DOUBLE
1210: LD_INT 1
1212: DEC
1213: ST_TO_ADDR
1214: LD_INT 3
1216: PUSH
1217: LD_OWVAR 67
1221: PLUS
1222: PUSH
1223: FOR_TO
1224: IFFALSE 1302
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1226: LD_INT 0
1228: PPUSH
1229: LD_INT 1
1231: PPUSH
1232: LD_INT 1
1234: PUSH
1235: LD_INT 2
1237: PUSH
1238: LD_INT 3
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: LIST
1245: PUSH
1246: LD_OWVAR 67
1250: ARRAY
1251: PPUSH
1252: CALL_OW 380
// un := CreateHuman ;
1256: LD_ADDR_VAR 0 3
1260: PUSH
1261: CALL_OW 44
1265: ST_TO_ADDR
// usForces := usForces ^ un ;
1266: LD_ADDR_EXP 19
1270: PUSH
1271: LD_EXP 19
1275: PUSH
1276: LD_VAR 0 3
1280: ADD
1281: ST_TO_ADDR
// PlaceHumanInUnit ( un , arm [ 1 ] ) ;
1282: LD_VAR 0 3
1286: PPUSH
1287: LD_VAR 0 6
1291: PUSH
1292: LD_INT 1
1294: ARRAY
1295: PPUSH
1296: CALL_OW 52
// end ;
1300: GO 1223
1302: POP
1303: POP
// PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1304: LD_INT 1
1306: PPUSH
1307: LD_INT 1
1309: PPUSH
1310: LD_INT 1
1312: PPUSH
1313: LD_INT 2
1315: PPUSH
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 2
1321: PPUSH
1322: LD_INT 100
1324: PPUSH
1325: CALL 284 0 7
// veh := CreateVehicle ;
1329: LD_ADDR_VAR 0 4
1333: PUSH
1334: CALL_OW 45
1338: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1339: LD_VAR 0 4
1343: PPUSH
1344: LD_INT 2
1346: PPUSH
1347: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 24 , false ) ;
1351: LD_VAR 0 4
1355: PPUSH
1356: LD_INT 43
1358: PPUSH
1359: LD_INT 24
1361: PPUSH
1362: LD_INT 0
1364: PPUSH
1365: CALL_OW 48
// end ;
1369: LD_VAR 0 1
1373: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1374: LD_INT 0
1376: PPUSH
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// if not usSci then
1382: LD_EXP 20
1386: NOT
1387: IFFALSE 1391
// exit ;
1389: GO 1565
// xy := AreaToList ( tameArea , 0 ) ;
1391: LD_ADDR_VAR 0 6
1395: PUSH
1396: LD_INT 5
1398: PPUSH
1399: LD_INT 0
1401: PPUSH
1402: CALL_OW 517
1406: ST_TO_ADDR
// for i in usSci do
1407: LD_ADDR_VAR 0 2
1411: PUSH
1412: LD_EXP 20
1416: PUSH
1417: FOR_IN
1418: IFFALSE 1563
// begin k := rand ( 1 , xy [ 1 ] ) ;
1420: LD_ADDR_VAR 0 4
1424: PUSH
1425: LD_INT 1
1427: PPUSH
1428: LD_VAR 0 6
1432: PUSH
1433: LD_INT 1
1435: ARRAY
1436: PPUSH
1437: CALL_OW 12
1441: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1442: LD_VAR 0 2
1446: PPUSH
1447: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1451: LD_VAR 0 2
1455: PPUSH
1456: LD_VAR 0 6
1460: PUSH
1461: LD_INT 1
1463: ARRAY
1464: PUSH
1465: LD_VAR 0 4
1469: ARRAY
1470: PPUSH
1471: LD_VAR 0 6
1475: PUSH
1476: LD_INT 2
1478: ARRAY
1479: PUSH
1480: LD_VAR 0 4
1484: ARRAY
1485: PPUSH
1486: CALL_OW 171
// for j := 1 to 2 do
1490: LD_ADDR_VAR 0 3
1494: PUSH
1495: DOUBLE
1496: LD_INT 1
1498: DEC
1499: ST_TO_ADDR
1500: LD_INT 2
1502: PUSH
1503: FOR_TO
1504: IFFALSE 1559
// begin tmp := Delete ( xy [ j ] , k ) ;
1506: LD_ADDR_VAR 0 5
1510: PUSH
1511: LD_VAR 0 6
1515: PUSH
1516: LD_VAR 0 3
1520: ARRAY
1521: PPUSH
1522: LD_VAR 0 4
1526: PPUSH
1527: CALL_OW 3
1531: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1532: LD_ADDR_VAR 0 6
1536: PUSH
1537: LD_VAR 0 6
1541: PPUSH
1542: LD_VAR 0 3
1546: PPUSH
1547: LD_VAR 0 5
1551: PPUSH
1552: CALL_OW 1
1556: ST_TO_ADDR
// end ;
1557: GO 1503
1559: POP
1560: POP
// end ;
1561: GO 1417
1563: POP
1564: POP
// end ;
1565: LD_VAR 0 1
1569: RET
// every 0 0$5 + 0 0$10 trigger usSci and not usAlert and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1570: LD_EXP 20
1574: PUSH
1575: LD_EXP 9
1579: NOT
1580: AND
1581: PUSH
1582: LD_INT 22
1584: PUSH
1585: LD_INT 0
1587: PUSH
1588: EMPTY
1589: LIST
1590: LIST
1591: PUSH
1592: LD_INT 25
1594: PUSH
1595: LD_INT 12
1597: PUSH
1598: EMPTY
1599: LIST
1600: LIST
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: PPUSH
1606: CALL_OW 69
1610: AND
1611: IFFALSE 2103
1613: GO 1615
1615: DISABLE
1616: LD_INT 0
1618: PPUSH
1619: PPUSH
1620: PPUSH
1621: PPUSH
1622: PPUSH
// begin enable ;
1623: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1624: LD_EXP 20
1628: PPUSH
1629: LD_INT 2
1631: PUSH
1632: LD_INT 60
1634: PUSH
1635: EMPTY
1636: LIST
1637: PUSH
1638: LD_INT 54
1640: PUSH
1641: EMPTY
1642: LIST
1643: PUSH
1644: EMPTY
1645: LIST
1646: LIST
1647: LIST
1648: PPUSH
1649: CALL_OW 72
1653: IFFALSE 1657
// exit ;
1655: GO 2103
// for i in usSci do
1657: LD_ADDR_VAR 0 1
1661: PUSH
1662: LD_EXP 20
1666: PUSH
1667: FOR_IN
1668: IFFALSE 2101
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1670: LD_VAR 0 1
1674: PPUSH
1675: CALL_OW 314
1679: NOT
1680: PUSH
1681: LD_VAR 0 1
1685: PPUSH
1686: CALL_OW 256
1690: PUSH
1691: LD_INT 1000
1693: EQUAL
1694: AND
1695: IFFALSE 1902
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1697: LD_ADDR_VAR 0 5
1701: PUSH
1702: LD_INT 22
1704: PUSH
1705: LD_INT 0
1707: PUSH
1708: EMPTY
1709: LIST
1710: LIST
1711: PUSH
1712: LD_INT 25
1714: PUSH
1715: LD_INT 12
1717: PUSH
1718: EMPTY
1719: LIST
1720: LIST
1721: PUSH
1722: EMPTY
1723: LIST
1724: LIST
1725: PPUSH
1726: CALL_OW 69
1730: PPUSH
1731: LD_VAR 0 1
1735: PPUSH
1736: CALL_OW 74
1740: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1741: LD_VAR 0 1
1745: PPUSH
1746: LD_VAR 0 5
1750: PPUSH
1751: CALL_OW 296
1755: PUSH
1756: LD_INT 10
1758: LESS
1759: IFFALSE 1792
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1761: LD_VAR 0 1
1765: PPUSH
1766: LD_VAR 0 5
1770: PPUSH
1771: CALL_OW 250
1775: PPUSH
1776: LD_VAR 0 5
1780: PPUSH
1781: CALL_OW 251
1785: PPUSH
1786: CALL_OW 131
1790: GO 1902
// begin d := rand ( 0 , 5 ) ;
1792: LD_ADDR_VAR 0 4
1796: PUSH
1797: LD_INT 0
1799: PPUSH
1800: LD_INT 5
1802: PPUSH
1803: CALL_OW 12
1807: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1808: LD_ADDR_VAR 0 2
1812: PUSH
1813: LD_VAR 0 1
1817: PPUSH
1818: CALL_OW 250
1822: PPUSH
1823: LD_VAR 0 4
1827: PPUSH
1828: LD_INT 3
1830: PPUSH
1831: CALL_OW 272
1835: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: LD_VAR 0 1
1845: PPUSH
1846: CALL_OW 251
1850: PPUSH
1851: LD_VAR 0 4
1855: PPUSH
1856: LD_INT 3
1858: PPUSH
1859: CALL_OW 273
1863: ST_TO_ADDR
// if not ValidHex ( x , y ) then
1864: LD_VAR 0 2
1868: PPUSH
1869: LD_VAR 0 3
1873: PPUSH
1874: CALL_OW 488
1878: NOT
1879: IFFALSE 1883
// continue ;
1881: GO 1667
// ComMoveXY ( i , x , y ) ;
1883: LD_VAR 0 1
1887: PPUSH
1888: LD_VAR 0 2
1892: PPUSH
1893: LD_VAR 0 3
1897: PPUSH
1898: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
1902: LD_VAR 0 1
1906: PPUSH
1907: CALL_OW 256
1911: PUSH
1912: LD_INT 900
1914: LESS
1915: PUSH
1916: LD_VAR 0 1
1920: PPUSH
1921: LD_INT 37
1923: PPUSH
1924: LD_INT 23
1926: PPUSH
1927: CALL_OW 297
1931: PUSH
1932: LD_INT 10
1934: GREATER
1935: AND
1936: IFFALSE 2012
// begin if IsOk ( Gladstone ) and IsInUnit ( Gladstone ) then
1938: LD_EXP 17
1942: PPUSH
1943: CALL_OW 302
1947: PUSH
1948: LD_EXP 17
1952: PPUSH
1953: CALL_OW 310
1957: AND
1958: IFFALSE 1969
// ComExitBuilding ( Gladstone ) ;
1960: LD_EXP 17
1964: PPUSH
1965: CALL_OW 122
// AddComHeal ( Gladstone , i ) ;
1969: LD_EXP 17
1973: PPUSH
1974: LD_VAR 0 1
1978: PPUSH
1979: CALL_OW 188
// AddComEnterUnit ( Gladstone , usLab ) ;
1983: LD_EXP 17
1987: PPUSH
1988: LD_INT 3
1990: PPUSH
1991: CALL_OW 180
// ComMoveXY ( i , 37 , 23 ) ;
1995: LD_VAR 0 1
1999: PPUSH
2000: LD_INT 37
2002: PPUSH
2003: LD_INT 23
2005: PPUSH
2006: CALL_OW 111
// end else
2010: GO 2099
// if GetLives ( i ) = 1000 then
2012: LD_VAR 0 1
2016: PPUSH
2017: CALL_OW 256
2021: PUSH
2022: LD_INT 1000
2024: EQUAL
2025: IFFALSE 2099
// begin if SideShoot ( i ) = 2 then
2027: LD_VAR 0 1
2031: PPUSH
2032: CALL_OW 503
2036: PUSH
2037: LD_INT 2
2039: EQUAL
2040: IFFALSE 2087
// begin if not usAlert then
2042: LD_EXP 9
2046: NOT
2047: IFFALSE 2057
// usAlert := true ;
2049: LD_ADDR_EXP 9
2053: PUSH
2054: LD_INT 1
2056: ST_TO_ADDR
// AddComEnterUnit ( i , usLab ) ;
2057: LD_VAR 0 1
2061: PPUSH
2062: LD_INT 3
2064: PPUSH
2065: CALL_OW 180
// usSci := usSci diff i ;
2069: LD_ADDR_EXP 20
2073: PUSH
2074: LD_EXP 20
2078: PUSH
2079: LD_VAR 0 1
2083: DIFF
2084: ST_TO_ADDR
// end else
2085: GO 2099
// ComMoveToArea ( i , tameArea ) ;
2087: LD_VAR 0 1
2091: PPUSH
2092: LD_INT 5
2094: PPUSH
2095: CALL_OW 113
// end ; end ;
2099: GO 1667
2101: POP
2102: POP
// end ;
2103: PPOPN 5
2105: END
// every 0 0$1 trigger not usAlert and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 999 ] ] ] ) or FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) ) do
2106: LD_EXP 9
2110: NOT
2111: PUSH
2112: LD_INT 22
2114: PUSH
2115: LD_INT 1
2117: PUSH
2118: EMPTY
2119: LIST
2120: LIST
2121: PUSH
2122: LD_INT 21
2124: PUSH
2125: LD_INT 3
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: PUSH
2132: LD_INT 3
2134: PUSH
2135: LD_INT 57
2137: PUSH
2138: EMPTY
2139: LIST
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: PUSH
2145: LD_INT 3
2147: PUSH
2148: LD_INT 24
2150: PUSH
2151: LD_INT 999
2153: PUSH
2154: EMPTY
2155: LIST
2156: LIST
2157: PUSH
2158: EMPTY
2159: LIST
2160: LIST
2161: PUSH
2162: EMPTY
2163: LIST
2164: LIST
2165: LIST
2166: LIST
2167: PPUSH
2168: CALL_OW 69
2172: PUSH
2173: LD_INT 7
2175: PPUSH
2176: LD_INT 22
2178: PUSH
2179: LD_INT 2
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: PPUSH
2186: CALL_OW 70
2190: OR
2191: AND
2192: IFFALSE 2205
2194: GO 2196
2196: DISABLE
// usAlert := true ;
2197: LD_ADDR_EXP 9
2201: PUSH
2202: LD_INT 1
2204: ST_TO_ADDR
2205: END
// every 0 0$1 trigger usAlert do var i , b , arm ;
2206: LD_EXP 9
2210: IFFALSE 2557
2212: GO 2214
2214: DISABLE
2215: LD_INT 0
2217: PPUSH
2218: PPUSH
2219: PPUSH
// begin usActiveDefend := true ;
2220: LD_ADDR_EXP 10
2224: PUSH
2225: LD_INT 1
2227: ST_TO_ADDR
// if not usForces then
2228: LD_EXP 19
2232: NOT
2233: IFFALSE 2237
// exit ;
2235: GO 2557
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
2237: LD_ADDR_VAR 0 3
2241: PUSH
2242: LD_INT 22
2244: PUSH
2245: LD_INT 1
2247: PUSH
2248: EMPTY
2249: LIST
2250: LIST
2251: PUSH
2252: LD_INT 30
2254: PUSH
2255: LD_INT 4
2257: PUSH
2258: EMPTY
2259: LIST
2260: LIST
2261: PUSH
2262: EMPTY
2263: LIST
2264: LIST
2265: PPUSH
2266: CALL_OW 69
2270: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
2271: LD_ADDR_VAR 0 2
2275: PUSH
2276: LD_INT 22
2278: PUSH
2279: LD_INT 1
2281: PUSH
2282: EMPTY
2283: LIST
2284: LIST
2285: PUSH
2286: LD_INT 30
2288: PUSH
2289: LD_INT 31
2291: PUSH
2292: EMPTY
2293: LIST
2294: LIST
2295: PUSH
2296: EMPTY
2297: LIST
2298: LIST
2299: PPUSH
2300: CALL_OW 69
2304: ST_TO_ADDR
// ComExitBuilding ( Lynch ) ;
2305: LD_EXP 18
2309: PPUSH
2310: CALL_OW 122
// AddComEnterUnit ( Lynch , arm [ 1 ] ) ;
2314: LD_EXP 18
2318: PPUSH
2319: LD_VAR 0 3
2323: PUSH
2324: LD_INT 1
2326: ARRAY
2327: PPUSH
2328: CALL_OW 180
// if IsOk ( Gladstone ) then
2332: LD_EXP 17
2336: PPUSH
2337: CALL_OW 302
2341: IFFALSE 2382
// begin ComExitBuilding ( Gladstone ) ;
2343: LD_EXP 17
2347: PPUSH
2348: CALL_OW 122
// AddComEnterUnit ( Gladstone , arm [ 1 ] ) ;
2352: LD_EXP 17
2356: PPUSH
2357: LD_VAR 0 3
2361: PUSH
2362: LD_INT 1
2364: ARRAY
2365: PPUSH
2366: CALL_OW 180
// AddComChangeProfession ( Gladstone , class_soldier ) ;
2370: LD_EXP 17
2374: PPUSH
2375: LD_INT 1
2377: PPUSH
2378: CALL_OW 183
// end ; ComExitBuilding ( usForces [ 1 ] ) ;
2382: LD_EXP 19
2386: PUSH
2387: LD_INT 1
2389: ARRAY
2390: PPUSH
2391: CALL_OW 122
// AddComEnterUnit ( usForces [ 1 ] , b [ 1 ] ) ;
2395: LD_EXP 19
2399: PUSH
2400: LD_INT 1
2402: ARRAY
2403: PPUSH
2404: LD_VAR 0 2
2408: PUSH
2409: LD_INT 1
2411: ARRAY
2412: PPUSH
2413: CALL_OW 180
// ComExitBuilding ( usForces [ 2 ] ) ;
2417: LD_EXP 19
2421: PUSH
2422: LD_INT 2
2424: ARRAY
2425: PPUSH
2426: CALL_OW 122
// AddComEnterUnit ( usForces [ 2 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
2430: LD_EXP 19
2434: PUSH
2435: LD_INT 2
2437: ARRAY
2438: PPUSH
2439: LD_INT 22
2441: PUSH
2442: LD_INT 1
2444: PUSH
2445: EMPTY
2446: LIST
2447: LIST
2448: PUSH
2449: LD_INT 30
2451: PUSH
2452: LD_INT 32
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PPUSH
2463: CALL_OW 69
2467: PUSH
2468: LD_INT 1
2470: ARRAY
2471: PPUSH
2472: CALL_OW 180
// if b > 1 and usForces > 2 then
2476: LD_VAR 0 2
2480: PUSH
2481: LD_INT 1
2483: GREATER
2484: PUSH
2485: LD_EXP 19
2489: PUSH
2490: LD_INT 2
2492: GREATER
2493: AND
2494: IFFALSE 2557
// begin repeat wait ( 0 0$1 ) ;
2496: LD_INT 35
2498: PPUSH
2499: CALL_OW 67
// until BuildingStatus ( b [ 2 ] ) <> bs_build ;
2503: LD_VAR 0 2
2507: PUSH
2508: LD_INT 2
2510: ARRAY
2511: PPUSH
2512: CALL_OW 461
2516: PUSH
2517: LD_INT 1
2519: NONEQUAL
2520: IFFALSE 2496
// ComExitBuilding ( usForces [ 3 ] ) ;
2522: LD_EXP 19
2526: PUSH
2527: LD_INT 3
2529: ARRAY
2530: PPUSH
2531: CALL_OW 122
// AddComEnterUnit ( usForces [ 3 ] , b [ 2 ] ) ;
2535: LD_EXP 19
2539: PUSH
2540: LD_INT 3
2542: ARRAY
2543: PPUSH
2544: LD_VAR 0 2
2548: PUSH
2549: LD_INT 2
2551: ARRAY
2552: PPUSH
2553: CALL_OW 180
// end ; end ;
2557: PPOPN 3
2559: END
// every 0 0$1 trigger GetLives ( usLab ) < 999 and usAlert and usForces do var i ;
2560: LD_INT 3
2562: PPUSH
2563: CALL_OW 256
2567: PUSH
2568: LD_INT 999
2570: LESS
2571: PUSH
2572: LD_EXP 9
2576: AND
2577: PUSH
2578: LD_EXP 19
2582: AND
2583: IFFALSE 2754
2585: GO 2587
2587: DISABLE
2588: LD_INT 0
2590: PPUSH
// begin for i in usForces do
2591: LD_ADDR_VAR 0 1
2595: PUSH
2596: LD_EXP 19
2600: PUSH
2601: FOR_IN
2602: IFFALSE 2641
// begin if IsInUnit ( i ) then
2604: LD_VAR 0 1
2608: PPUSH
2609: CALL_OW 310
2613: IFFALSE 2624
// ComExitBuilding ( i ) ;
2615: LD_VAR 0 1
2619: PPUSH
2620: CALL_OW 122
// AddComAgressiveMove ( i , 31 , 8 ) ;
2624: LD_VAR 0 1
2628: PPUSH
2629: LD_INT 31
2631: PPUSH
2632: LD_INT 8
2634: PPUSH
2635: CALL_OW 174
// end ;
2639: GO 2601
2641: POP
2642: POP
// wait ( 0 0$8 ) ;
2643: LD_INT 280
2645: PPUSH
2646: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) then
2650: LD_INT 22
2652: PUSH
2653: LD_INT 2
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: PUSH
2660: LD_INT 91
2662: PUSH
2663: LD_INT 3
2665: PUSH
2666: LD_INT 14
2668: PUSH
2669: EMPTY
2670: LIST
2671: LIST
2672: LIST
2673: PUSH
2674: EMPTY
2675: LIST
2676: LIST
2677: PPUSH
2678: CALL_OW 69
2682: IFFALSE 2732
// ComAttackUnit ( usForces , FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) [ 1 ] ) else
2684: LD_EXP 19
2688: PPUSH
2689: LD_INT 22
2691: PUSH
2692: LD_INT 2
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: PUSH
2699: LD_INT 91
2701: PUSH
2702: LD_INT 3
2704: PUSH
2705: LD_INT 14
2707: PUSH
2708: EMPTY
2709: LIST
2710: LIST
2711: LIST
2712: PUSH
2713: EMPTY
2714: LIST
2715: LIST
2716: PPUSH
2717: CALL_OW 69
2721: PUSH
2722: LD_INT 1
2724: ARRAY
2725: PPUSH
2726: CALL_OW 115
2730: GO 2754
// begin wait ( 0 0$20 ) ;
2732: LD_INT 700
2734: PPUSH
2735: CALL_OW 67
// AddComMoveXY ( usForces , 39 , 19 ) ;
2739: LD_EXP 19
2743: PPUSH
2744: LD_INT 39
2746: PPUSH
2747: LD_INT 19
2749: PPUSH
2750: CALL_OW 171
// end ; end ;
2754: PPOPN 1
2756: END
// every 0 0$3 trigger ( GetDistUnits ( Heike , Delta ) < 10 or GetLives ( usLab ) < 999 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do var tmp , veh ;
2757: LD_EXP 21
2761: PPUSH
2762: LD_INT 1
2764: PPUSH
2765: CALL_OW 296
2769: PUSH
2770: LD_INT 10
2772: LESS
2773: PUSH
2774: LD_INT 3
2776: PPUSH
2777: CALL_OW 256
2781: PUSH
2782: LD_INT 999
2784: LESS
2785: OR
2786: PUSH
2787: LD_INT 22
2789: PUSH
2790: LD_INT 1
2792: PUSH
2793: EMPTY
2794: LIST
2795: LIST
2796: PUSH
2797: LD_INT 25
2799: PUSH
2800: LD_INT 2
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: EMPTY
2808: LIST
2809: LIST
2810: PPUSH
2811: CALL_OW 69
2815: AND
2816: IFFALSE 3000
2818: GO 2820
2820: DISABLE
2821: LD_INT 0
2823: PPUSH
2824: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
2825: LD_ADDR_VAR 0 1
2829: PUSH
2830: LD_INT 22
2832: PUSH
2833: LD_INT 1
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: PUSH
2840: LD_INT 25
2842: PUSH
2843: LD_INT 2
2845: PUSH
2846: EMPTY
2847: LIST
2848: LIST
2849: PUSH
2850: EMPTY
2851: LIST
2852: LIST
2853: PPUSH
2854: CALL_OW 69
2858: ST_TO_ADDR
// veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2859: LD_ADDR_VAR 0 2
2863: PUSH
2864: LD_INT 22
2866: PUSH
2867: LD_INT 1
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: PUSH
2874: LD_INT 21
2876: PUSH
2877: LD_INT 2
2879: PUSH
2880: EMPTY
2881: LIST
2882: LIST
2883: PUSH
2884: LD_INT 58
2886: PUSH
2887: EMPTY
2888: LIST
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: CALL_OW 69
2899: ST_TO_ADDR
// if not tmp then
2900: LD_VAR 0 1
2904: NOT
2905: IFFALSE 2909
// exit ;
2907: GO 3000
// ComExitBuilding ( tmp ) ;
2909: LD_VAR 0 1
2913: PPUSH
2914: CALL_OW 122
// AddComDismantle ( tmp , usLab ) ;
2918: LD_VAR 0 1
2922: PPUSH
2923: LD_INT 3
2925: PPUSH
2926: CALL_OW 227
// if veh and IsOk ( Gladstone ) then
2930: LD_VAR 0 2
2934: PUSH
2935: LD_EXP 17
2939: PPUSH
2940: CALL_OW 302
2944: AND
2945: IFFALSE 3000
// begin if IsInUnit ( Gladstone ) then
2947: LD_EXP 17
2951: PPUSH
2952: CALL_OW 310
2956: IFFALSE 2967
// ComExitBuilding ( Gladstone ) ;
2958: LD_EXP 17
2962: PPUSH
2963: CALL_OW 122
// AddComEnterUnit ( Gladstone , veh [ 1 ] ) ;
2967: LD_EXP 17
2971: PPUSH
2972: LD_VAR 0 2
2976: PUSH
2977: LD_INT 1
2979: ARRAY
2980: PPUSH
2981: CALL_OW 180
// AddComAgressiveMove ( Gladstone , 39 , 14 ) ;
2985: LD_EXP 17
2989: PPUSH
2990: LD_INT 39
2992: PPUSH
2993: LD_INT 14
2995: PPUSH
2996: CALL_OW 174
// end ; end ;
3000: PPOPN 2
3002: END
// every 0 0$1 trigger usAlert and FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) do var i , tmp ;
3003: LD_EXP 9
3007: PUSH
3008: LD_INT 7
3010: PPUSH
3011: LD_INT 22
3013: PUSH
3014: LD_INT 1
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: PUSH
3021: LD_INT 21
3023: PUSH
3024: LD_INT 1
3026: PUSH
3027: EMPTY
3028: LIST
3029: LIST
3030: PUSH
3031: LD_INT 3
3033: PUSH
3034: LD_INT 24
3036: PUSH
3037: LD_INT 600
3039: PUSH
3040: EMPTY
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: LIST
3052: PPUSH
3053: CALL_OW 70
3057: AND
3058: IFFALSE 3186
3060: GO 3062
3062: DISABLE
3063: LD_INT 0
3065: PPUSH
3066: PPUSH
// begin enable ;
3067: ENABLE
// tmp := FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) ;
3068: LD_ADDR_VAR 0 2
3072: PUSH
3073: LD_INT 7
3075: PPUSH
3076: LD_INT 22
3078: PUSH
3079: LD_INT 1
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: PUSH
3086: LD_INT 21
3088: PUSH
3089: LD_INT 1
3091: PUSH
3092: EMPTY
3093: LIST
3094: LIST
3095: PUSH
3096: LD_INT 3
3098: PUSH
3099: LD_INT 24
3101: PUSH
3102: LD_INT 600
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: PUSH
3109: EMPTY
3110: LIST
3111: LIST
3112: PUSH
3113: EMPTY
3114: LIST
3115: LIST
3116: LIST
3117: PPUSH
3118: CALL_OW 70
3122: ST_TO_ADDR
// if not tmp then
3123: LD_VAR 0 2
3127: NOT
3128: IFFALSE 3132
// exit ;
3130: GO 3186
// for i in tmp do
3132: LD_ADDR_VAR 0 1
3136: PUSH
3137: LD_VAR 0 2
3141: PUSH
3142: FOR_IN
3143: IFFALSE 3184
// if IsInUnit ( i ) then
3145: LD_VAR 0 1
3149: PPUSH
3150: CALL_OW 310
3154: IFFALSE 3167
// ComExitBuilding ( i ) else
3156: LD_VAR 0 1
3160: PPUSH
3161: CALL_OW 122
3165: GO 3182
// ComMoveXY ( i , 48 , 74 ) ;
3167: LD_VAR 0 1
3171: PPUSH
3172: LD_INT 48
3174: PPUSH
3175: LD_INT 74
3177: PPUSH
3178: CALL_OW 111
3182: GO 3142
3184: POP
3185: POP
// end ;
3186: PPOPN 2
3188: END
// every 5 5$00 do var i , un , tmp ;
3189: GO 3191
3191: DISABLE
3192: LD_INT 0
3194: PPUSH
3195: PPUSH
3196: PPUSH
// begin tmp := [ ] ;
3197: LD_ADDR_VAR 0 3
3201: PUSH
3202: EMPTY
3203: ST_TO_ADDR
// uc_side := 1 ;
3204: LD_ADDR_OWVAR 20
3208: PUSH
3209: LD_INT 1
3211: ST_TO_ADDR
// uc_nation := 1 ;
3212: LD_ADDR_OWVAR 21
3216: PUSH
3217: LD_INT 1
3219: ST_TO_ADDR
// case Difficulty of 1 :
3220: LD_OWVAR 67
3224: PUSH
3225: LD_INT 1
3227: DOUBLE
3228: EQUAL
3229: IFTRUE 3233
3231: GO 3336
3233: POP
// begin wait ( 1 1$00 ) ;
3234: LD_INT 2100
3236: PPUSH
3237: CALL_OW 67
// for i := 1 to 2 do
3241: LD_ADDR_VAR 0 1
3245: PUSH
3246: DOUBLE
3247: LD_INT 1
3249: DEC
3250: ST_TO_ADDR
3251: LD_INT 2
3253: PUSH
3254: FOR_TO
3255: IFFALSE 3332
// begin PrepareHuman ( false , [ 1 , 4 ] [ i mod 2 + 1 ] , 1 ) ;
3257: LD_INT 0
3259: PPUSH
3260: LD_INT 1
3262: PUSH
3263: LD_INT 4
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PUSH
3270: LD_VAR 0 1
3274: PUSH
3275: LD_INT 2
3277: MOD
3278: PUSH
3279: LD_INT 1
3281: PLUS
3282: ARRAY
3283: PPUSH
3284: LD_INT 1
3286: PPUSH
3287: CALL_OW 380
// un := CreateHuman ;
3291: LD_ADDR_VAR 0 2
3295: PUSH
3296: CALL_OW 44
3300: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3301: LD_ADDR_VAR 0 3
3305: PUSH
3306: LD_VAR 0 3
3310: PPUSH
3311: LD_VAR 0 3
3315: PUSH
3316: LD_INT 1
3318: PLUS
3319: PPUSH
3320: LD_VAR 0 2
3324: PPUSH
3325: CALL_OW 1
3329: ST_TO_ADDR
// end ;
3330: GO 3254
3332: POP
3333: POP
// end ; 2 :
3334: GO 3730
3336: LD_INT 2
3338: DOUBLE
3339: EQUAL
3340: IFTRUE 3344
3342: GO 3478
3344: POP
// begin wait ( 0 0$30 ) ;
3345: LD_INT 1050
3347: PPUSH
3348: CALL_OW 67
// for i := 1 to 2 do
3352: LD_ADDR_VAR 0 1
3356: PUSH
3357: DOUBLE
3358: LD_INT 1
3360: DEC
3361: ST_TO_ADDR
3362: LD_INT 2
3364: PUSH
3365: FOR_TO
3366: IFFALSE 3422
// begin PrepareHuman ( false , 1 , 2 ) ;
3368: LD_INT 0
3370: PPUSH
3371: LD_INT 1
3373: PPUSH
3374: LD_INT 2
3376: PPUSH
3377: CALL_OW 380
// un := CreateHuman ;
3381: LD_ADDR_VAR 0 2
3385: PUSH
3386: CALL_OW 44
3390: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_VAR 0 3
3400: PPUSH
3401: LD_VAR 0 3
3405: PUSH
3406: LD_INT 1
3408: PLUS
3409: PPUSH
3410: LD_VAR 0 2
3414: PPUSH
3415: CALL_OW 1
3419: ST_TO_ADDR
// end ;
3420: GO 3365
3422: POP
3423: POP
// PrepareHuman ( false , 4 , 2 ) ;
3424: LD_INT 0
3426: PPUSH
3427: LD_INT 4
3429: PPUSH
3430: LD_INT 2
3432: PPUSH
3433: CALL_OW 380
// un := CreateHuman ;
3437: LD_ADDR_VAR 0 2
3441: PUSH
3442: CALL_OW 44
3446: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3447: LD_ADDR_VAR 0 3
3451: PUSH
3452: LD_VAR 0 3
3456: PPUSH
3457: LD_VAR 0 3
3461: PUSH
3462: LD_INT 1
3464: PLUS
3465: PPUSH
3466: LD_VAR 0 2
3470: PPUSH
3471: CALL_OW 1
3475: ST_TO_ADDR
// end ; 3 :
3476: GO 3730
3478: LD_INT 3
3480: DOUBLE
3481: EQUAL
3482: IFTRUE 3486
3484: GO 3729
3486: POP
// begin for i := 1 to 2 do
3487: LD_ADDR_VAR 0 1
3491: PUSH
3492: DOUBLE
3493: LD_INT 1
3495: DEC
3496: ST_TO_ADDR
3497: LD_INT 2
3499: PUSH
3500: FOR_TO
3501: IFFALSE 3557
// begin PrepareHuman ( false , 1 , 2 ) ;
3503: LD_INT 0
3505: PPUSH
3506: LD_INT 1
3508: PPUSH
3509: LD_INT 2
3511: PPUSH
3512: CALL_OW 380
// un := CreateHuman ;
3516: LD_ADDR_VAR 0 2
3520: PUSH
3521: CALL_OW 44
3525: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3526: LD_ADDR_VAR 0 3
3530: PUSH
3531: LD_VAR 0 3
3535: PPUSH
3536: LD_VAR 0 3
3540: PUSH
3541: LD_INT 1
3543: PLUS
3544: PPUSH
3545: LD_VAR 0 2
3549: PPUSH
3550: CALL_OW 1
3554: ST_TO_ADDR
// end ;
3555: GO 3500
3557: POP
3558: POP
// PrepareHuman ( false , 4 , 2 ) ;
3559: LD_INT 0
3561: PPUSH
3562: LD_INT 4
3564: PPUSH
3565: LD_INT 2
3567: PPUSH
3568: CALL_OW 380
// un := CreateHuman ;
3572: LD_ADDR_VAR 0 2
3576: PUSH
3577: CALL_OW 44
3581: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3582: LD_ADDR_VAR 0 3
3586: PUSH
3587: LD_VAR 0 3
3591: PPUSH
3592: LD_VAR 0 3
3596: PUSH
3597: LD_INT 1
3599: PLUS
3600: PPUSH
3601: LD_VAR 0 2
3605: PPUSH
3606: CALL_OW 1
3610: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_machine_gun , 90 ) ;
3611: LD_INT 1
3613: PPUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 2
3619: PPUSH
3620: LD_INT 2
3622: PPUSH
3623: LD_INT 1
3625: PPUSH
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 90
3631: PPUSH
3632: CALL 284 0 7
// un := CreateVehicle ;
3636: LD_ADDR_VAR 0 2
3640: PUSH
3641: CALL_OW 45
3645: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3646: LD_ADDR_VAR 0 3
3650: PUSH
3651: LD_VAR 0 3
3655: PPUSH
3656: LD_VAR 0 3
3660: PUSH
3661: LD_INT 1
3663: PLUS
3664: PPUSH
3665: LD_VAR 0 2
3669: PPUSH
3670: CALL_OW 1
3674: ST_TO_ADDR
// PrepareHuman ( false , 1 , 2 ) ;
3675: LD_INT 0
3677: PPUSH
3678: LD_INT 1
3680: PPUSH
3681: LD_INT 2
3683: PPUSH
3684: CALL_OW 380
// un := CreateHuman ;
3688: LD_ADDR_VAR 0 2
3692: PUSH
3693: CALL_OW 44
3697: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3698: LD_ADDR_VAR 0 3
3702: PUSH
3703: LD_VAR 0 3
3707: PPUSH
3708: LD_VAR 0 3
3712: PUSH
3713: LD_INT 1
3715: PLUS
3716: PPUSH
3717: LD_VAR 0 2
3721: PPUSH
3722: CALL_OW 1
3726: ST_TO_ADDR
// end ; end ;
3727: GO 3730
3729: POP
// for i := 1 to tmp do
3730: LD_ADDR_VAR 0 1
3734: PUSH
3735: DOUBLE
3736: LD_INT 1
3738: DEC
3739: ST_TO_ADDR
3740: LD_VAR 0 3
3744: PUSH
3745: FOR_TO
3746: IFFALSE 3911
// begin SetDir ( tmp [ i ] , 1 ) ;
3748: LD_VAR 0 3
3752: PUSH
3753: LD_VAR 0 1
3757: ARRAY
3758: PPUSH
3759: LD_INT 1
3761: PPUSH
3762: CALL_OW 233
// if GetType ( tmp [ i ] ) = unit_human then
3766: LD_VAR 0 3
3770: PUSH
3771: LD_VAR 0 1
3775: ARRAY
3776: PPUSH
3777: CALL_OW 247
3781: PUSH
3782: LD_INT 1
3784: EQUAL
3785: IFFALSE 3813
// PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) else
3787: LD_VAR 0 3
3791: PUSH
3792: LD_VAR 0 1
3796: ARRAY
3797: PPUSH
3798: LD_INT 28
3800: PPUSH
3801: LD_INT 52
3803: PPUSH
3804: LD_INT 0
3806: PPUSH
3807: CALL_OW 48
3811: GO 3881
// begin PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) ;
3813: LD_VAR 0 3
3817: PUSH
3818: LD_VAR 0 1
3822: ARRAY
3823: PPUSH
3824: LD_INT 28
3826: PPUSH
3827: LD_INT 52
3829: PPUSH
3830: LD_INT 0
3832: PPUSH
3833: CALL_OW 48
// i := i + 1 ;
3837: LD_ADDR_VAR 0 1
3841: PUSH
3842: LD_VAR 0 1
3846: PUSH
3847: LD_INT 1
3849: PLUS
3850: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ i ] , tmp [ i - 1 ] ) ;
3851: LD_VAR 0 3
3855: PUSH
3856: LD_VAR 0 1
3860: ARRAY
3861: PPUSH
3862: LD_VAR 0 3
3866: PUSH
3867: LD_VAR 0 1
3871: PUSH
3872: LD_INT 1
3874: MINUS
3875: ARRAY
3876: PPUSH
3877: CALL_OW 52
// end ; ComMoveXY ( tmp [ i ] , 43 , 56 ) ;
3881: LD_VAR 0 3
3885: PUSH
3886: LD_VAR 0 1
3890: ARRAY
3891: PPUSH
3892: LD_INT 43
3894: PPUSH
3895: LD_INT 56
3897: PPUSH
3898: CALL_OW 111
// wait ( 0 0$2 ) ;
3902: LD_INT 70
3904: PPUSH
3905: CALL_OW 67
// end ;
3909: GO 3745
3911: POP
3912: POP
// wait ( 0 0$2 ) ;
3913: LD_INT 70
3915: PPUSH
3916: CALL_OW 67
// if not FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) then
3920: LD_INT 7
3922: PPUSH
3923: LD_INT 22
3925: PUSH
3926: LD_INT 2
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: PPUSH
3933: CALL_OW 70
3937: NOT
3938: IFFALSE 4136
// begin AddComAgressiveMove ( tmp , 35 , 24 ) ;
3940: LD_VAR 0 3
3944: PPUSH
3945: LD_INT 35
3947: PPUSH
3948: LD_INT 24
3950: PPUSH
3951: CALL_OW 174
// usForces := usForces union UnitFilter ( tmp , [ f_class , 1 ] ) ;
3955: LD_ADDR_EXP 19
3959: PUSH
3960: LD_EXP 19
3964: PUSH
3965: LD_VAR 0 3
3969: PPUSH
3970: LD_INT 25
3972: PUSH
3973: LD_INT 1
3975: PUSH
3976: EMPTY
3977: LIST
3978: LIST
3979: PPUSH
3980: CALL_OW 72
3984: UNION
3985: ST_TO_ADDR
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
3986: LD_INT 22
3988: PUSH
3989: LD_INT 1
3991: PUSH
3992: EMPTY
3993: LIST
3994: LIST
3995: PUSH
3996: LD_INT 30
3998: PUSH
3999: LD_INT 4
4001: PUSH
4002: EMPTY
4003: LIST
4004: LIST
4005: PUSH
4006: EMPTY
4007: LIST
4008: LIST
4009: PPUSH
4010: CALL_OW 69
4014: PUSH
4015: LD_INT 1
4017: ARRAY
4018: PPUSH
4019: CALL_OW 313
4023: PUSH
4024: LD_INT 6
4026: LESS
4027: IFFALSE 4086
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
4029: LD_VAR 0 3
4033: PPUSH
4034: LD_INT 25
4036: PUSH
4037: LD_INT 1
4039: PUSH
4040: EMPTY
4041: LIST
4042: LIST
4043: PPUSH
4044: CALL_OW 72
4048: PPUSH
4049: LD_INT 22
4051: PUSH
4052: LD_INT 1
4054: PUSH
4055: EMPTY
4056: LIST
4057: LIST
4058: PUSH
4059: LD_INT 30
4061: PUSH
4062: LD_INT 4
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: PUSH
4069: EMPTY
4070: LIST
4071: LIST
4072: PPUSH
4073: CALL_OW 69
4077: PUSH
4078: LD_INT 1
4080: ARRAY
4081: PPUSH
4082: CALL_OW 180
// if UnitFilter ( tmp , [ f_class , 4 ] ) then
4086: LD_VAR 0 3
4090: PPUSH
4091: LD_INT 25
4093: PUSH
4094: LD_INT 4
4096: PUSH
4097: EMPTY
4098: LIST
4099: LIST
4100: PPUSH
4101: CALL_OW 72
4105: IFFALSE 4134
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 4 ] ) , usLab ) ;
4107: LD_VAR 0 3
4111: PPUSH
4112: LD_INT 25
4114: PUSH
4115: LD_INT 4
4117: PUSH
4118: EMPTY
4119: LIST
4120: LIST
4121: PPUSH
4122: CALL_OW 72
4126: PPUSH
4127: LD_INT 3
4129: PPUSH
4130: CALL_OW 180
// end else
4134: GO 4411
// begin tmp := tmp union FilterUnitsInArea ( retreatArea , [ f_side , 1 ] ) ;
4136: LD_ADDR_VAR 0 3
4140: PUSH
4141: LD_VAR 0 3
4145: PUSH
4146: LD_INT 6
4148: PPUSH
4149: LD_INT 22
4151: PUSH
4152: LD_INT 1
4154: PUSH
4155: EMPTY
4156: LIST
4157: LIST
4158: PPUSH
4159: CALL_OW 70
4163: UNION
4164: ST_TO_ADDR
// ComMoveXY ( tmp , 45 , 54 ) ;
4165: LD_VAR 0 3
4169: PPUSH
4170: LD_INT 45
4172: PPUSH
4173: LD_INT 54
4175: PPUSH
4176: CALL_OW 111
// wait ( 0 0$3 ) ;
4180: LD_INT 105
4182: PPUSH
4183: CALL_OW 67
// AddComAgressiveMove ( tmp diff UnitFilter ( tmp , [ f_class , 4 ] ) , 35 , 24 ) ;
4187: LD_VAR 0 3
4191: PUSH
4192: LD_VAR 0 3
4196: PPUSH
4197: LD_INT 25
4199: PUSH
4200: LD_INT 4
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PPUSH
4207: CALL_OW 72
4211: DIFF
4212: PPUSH
4213: LD_INT 35
4215: PPUSH
4216: LD_INT 24
4218: PPUSH
4219: CALL_OW 174
// AddComMoveXY ( UnitFilter ( tmp , [ f_class , 4 ] ) , 42 , 49 ) ;
4223: LD_VAR 0 3
4227: PPUSH
4228: LD_INT 25
4230: PUSH
4231: LD_INT 4
4233: PUSH
4234: EMPTY
4235: LIST
4236: LIST
4237: PPUSH
4238: CALL_OW 72
4242: PPUSH
4243: LD_INT 42
4245: PPUSH
4246: LD_INT 49
4248: PPUSH
4249: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4253: LD_INT 35
4255: PPUSH
4256: CALL_OW 67
// for i in tmp do
4260: LD_ADDR_VAR 0 1
4264: PUSH
4265: LD_VAR 0 3
4269: PUSH
4270: FOR_IN
4271: IFFALSE 4402
// if IsDead ( i ) then
4273: LD_VAR 0 1
4277: PPUSH
4278: CALL_OW 301
4282: IFFALSE 4302
// tmp := tmp diff i else
4284: LD_ADDR_VAR 0 3
4288: PUSH
4289: LD_VAR 0 3
4293: PUSH
4294: LD_VAR 0 1
4298: DIFF
4299: ST_TO_ADDR
4300: GO 4400
// if GetClass ( i ) = 1 then
4302: LD_VAR 0 1
4306: PPUSH
4307: CALL_OW 257
4311: PUSH
4312: LD_INT 1
4314: EQUAL
4315: IFFALSE 4400
// begin if GetLives ( i ) < 600 and GetDistUnitXY ( i , 42 , 49 ) > 6 then
4317: LD_VAR 0 1
4321: PPUSH
4322: CALL_OW 256
4326: PUSH
4327: LD_INT 600
4329: LESS
4330: PUSH
4331: LD_VAR 0 1
4335: PPUSH
4336: LD_INT 42
4338: PPUSH
4339: LD_INT 49
4341: PPUSH
4342: CALL_OW 297
4346: PUSH
4347: LD_INT 6
4349: GREATER
4350: AND
4351: IFFALSE 4370
// ComMoveXY ( i , 42 , 49 ) else
4353: LD_VAR 0 1
4357: PPUSH
4358: LD_INT 42
4360: PPUSH
4361: LD_INT 49
4363: PPUSH
4364: CALL_OW 111
4368: GO 4400
// if GetLives ( i ) = 1000 then
4370: LD_VAR 0 1
4374: PPUSH
4375: CALL_OW 256
4379: PUSH
4380: LD_INT 1000
4382: EQUAL
4383: IFFALSE 4400
// ComAgressiveMove ( i , 36 , 25 ) ;
4385: LD_VAR 0 1
4389: PPUSH
4390: LD_INT 36
4392: PPUSH
4393: LD_INT 25
4395: PPUSH
4396: CALL_OW 114
// end ;
4400: GO 4270
4402: POP
4403: POP
// until not tmp ;
4404: LD_VAR 0 3
4408: NOT
4409: IFFALSE 4253
// end ; end ;
4411: PPOPN 3
4413: END
// every 0 0$1 trigger FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) and not attackDeltaAllowed do var i , un , veh ;
4414: LD_INT 7
4416: PPUSH
4417: LD_INT 22
4419: PUSH
4420: LD_INT 2
4422: PUSH
4423: EMPTY
4424: LIST
4425: LIST
4426: PPUSH
4427: CALL_OW 70
4431: PUSH
4432: LD_EXP 12
4436: NOT
4437: AND
4438: IFFALSE 4596
4440: GO 4442
4442: DISABLE
4443: LD_INT 0
4445: PPUSH
4446: PPUSH
4447: PPUSH
// begin for i := 1 to 2 do
4448: LD_ADDR_VAR 0 1
4452: PUSH
4453: DOUBLE
4454: LD_INT 1
4456: DEC
4457: ST_TO_ADDR
4458: LD_INT 2
4460: PUSH
4461: FOR_TO
4462: IFFALSE 4594
// begin wait ( 0 0$3 ) ;
4464: LD_INT 105
4466: PPUSH
4467: CALL_OW 67
// uc_side := 1 ;
4471: LD_ADDR_OWVAR 20
4475: PUSH
4476: LD_INT 1
4478: ST_TO_ADDR
// uc_nation := 1 ;
4479: LD_ADDR_OWVAR 21
4483: PUSH
4484: LD_INT 1
4486: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 90 ) ;
4487: LD_INT 1
4489: PPUSH
4490: LD_INT 1
4492: PPUSH
4493: LD_INT 2
4495: PPUSH
4496: LD_INT 1
4498: PPUSH
4499: LD_INT 1
4501: PPUSH
4502: LD_INT 4
4504: PPUSH
4505: LD_INT 90
4507: PPUSH
4508: CALL 284 0 7
// veh := CreateVehicle ;
4512: LD_ADDR_VAR 0 3
4516: PUSH
4517: CALL_OW 45
4521: ST_TO_ADDR
// PlaceUnitXY ( veh , 29 , 52 , false ) ;
4522: LD_VAR 0 3
4526: PPUSH
4527: LD_INT 29
4529: PPUSH
4530: LD_INT 52
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 48
// PrepareHuman ( false , 3 , 3 ) ;
4540: LD_INT 0
4542: PPUSH
4543: LD_INT 3
4545: PPUSH
4546: LD_INT 3
4548: PPUSH
4549: CALL_OW 380
// un := CreateHuman ;
4553: LD_ADDR_VAR 0 2
4557: PUSH
4558: CALL_OW 44
4562: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4563: LD_VAR 0 2
4567: PPUSH
4568: LD_VAR 0 3
4572: PPUSH
4573: CALL_OW 52
// ComAgressiveMove ( veh , 36 , 25 ) ;
4577: LD_VAR 0 3
4581: PPUSH
4582: LD_INT 36
4584: PPUSH
4585: LD_INT 25
4587: PPUSH
4588: CALL_OW 114
// end ;
4592: GO 4461
4594: POP
4595: POP
// end ; end_of_file
4596: PPOPN 3
4598: END
// export function Action ; var i , tmp ; begin
4599: LD_INT 0
4601: PPUSH
4602: PPUSH
4603: PPUSH
// InGameOn ;
4604: CALL_OW 8
// DoNotAttack ( 2 , usLab ) ;
4608: LD_INT 2
4610: PPUSH
4611: LD_INT 3
4613: PPUSH
4614: CALL_OW 471
// ComMoveXY ( Heike , 78 , 61 ) ;
4618: LD_EXP 21
4622: PPUSH
4623: LD_INT 78
4625: PPUSH
4626: LD_INT 61
4628: PPUSH
4629: CALL_OW 111
// if Mike then
4633: LD_EXP 23
4637: IFFALSE 4654
// ComMoveXY ( Mike , 80 , 66 ) ;
4639: LD_EXP 23
4643: PPUSH
4644: LD_INT 80
4646: PPUSH
4647: LD_INT 66
4649: PPUSH
4650: CALL_OW 111
// if Givi then
4654: LD_EXP 22
4658: IFFALSE 4675
// ComMoveXY ( Givi , 82 , 66 ) ;
4660: LD_EXP 22
4664: PPUSH
4665: LD_INT 82
4667: PPUSH
4668: LD_INT 66
4670: PPUSH
4671: CALL_OW 111
// if Kamil then
4675: LD_EXP 24
4679: IFFALSE 4696
// ComMoveXY ( Kamil , 82 , 67 ) ;
4681: LD_EXP 24
4685: PPUSH
4686: LD_INT 82
4688: PPUSH
4689: LD_INT 67
4691: PPUSH
4692: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
4696: LD_EXP 21
4700: PPUSH
4701: CALL_OW 87
// wait ( 0 0$2 ) ;
4705: LD_INT 70
4707: PPUSH
4708: CALL_OW 67
// if Givi and Mike then
4712: LD_EXP 22
4716: PUSH
4717: LD_EXP 23
4721: AND
4722: IFFALSE 5168
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4724: LD_EXP 22
4728: PUSH
4729: LD_EXP 23
4733: PUSH
4734: LD_EXP 24
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: LIST
4743: PPUSH
4744: LD_EXP 21
4748: PPUSH
4749: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
4753: LD_EXP 21
4757: PPUSH
4758: LD_EXP 22
4762: PPUSH
4763: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
4767: LD_EXP 22
4771: PPUSH
4772: LD_STRING DG-1-start
4774: PPUSH
4775: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
4779: LD_EXP 21
4783: PPUSH
4784: LD_STRING DH-1-start
4786: PPUSH
4787: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
4791: LD_EXP 23
4795: PPUSH
4796: LD_EXP 21
4800: PPUSH
4801: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
4805: LD_EXP 21
4809: PPUSH
4810: LD_EXP 23
4814: PPUSH
4815: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
4819: LD_EXP 23
4823: PPUSH
4824: LD_STRING DM-1-start
4826: PPUSH
4827: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
4831: LD_EXP 21
4835: PPUSH
4836: LD_STRING DH-2-start
4838: PPUSH
4839: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
4843: LD_EXP 23
4847: PPUSH
4848: LD_STRING DM-2-start
4850: PPUSH
4851: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
4855: LD_EXP 22
4859: PPUSH
4860: LD_STRING DG-2-start
4862: PPUSH
4863: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
4867: LD_EXP 23
4871: PPUSH
4872: LD_EXP 22
4876: PPUSH
4877: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
4881: LD_EXP 21
4885: PPUSH
4886: LD_EXP 23
4890: PPUSH
4891: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
4895: LD_EXP 23
4899: PPUSH
4900: LD_STRING DM-3-start
4902: PPUSH
4903: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
4907: LD_EXP 21
4911: PPUSH
4912: LD_STRING DH-3-start
4914: PPUSH
4915: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
4919: LD_EXP 21
4923: PUSH
4924: LD_EXP 23
4928: PUSH
4929: LD_EXP 22
4933: PUSH
4934: LD_EXP 24
4938: PUSH
4939: EMPTY
4940: LIST
4941: LIST
4942: LIST
4943: LIST
4944: PPUSH
4945: LD_INT 84
4947: PPUSH
4948: LD_INT 51
4950: PPUSH
4951: CALL_OW 111
// wait ( 0 0$2 ) ;
4955: LD_INT 70
4957: PPUSH
4958: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
4962: LD_EXP 22
4966: PPUSH
4967: LD_STRING DG-3-start
4969: PPUSH
4970: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
4974: LD_EXP 21
4978: PUSH
4979: LD_EXP 23
4983: PUSH
4984: LD_EXP 22
4988: PUSH
4989: LD_EXP 24
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: PPUSH
5000: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
5004: LD_EXP 21
5008: PPUSH
5009: LD_EXP 22
5013: PPUSH
5014: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
5018: LD_EXP 22
5022: PUSH
5023: LD_EXP 23
5027: PUSH
5028: LD_EXP 24
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: LIST
5037: PPUSH
5038: LD_EXP 21
5042: PPUSH
5043: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
5047: LD_EXP 21
5051: PPUSH
5052: LD_STRING DH-4-start
5054: PPUSH
5055: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
5059: LD_EXP 22
5063: PPUSH
5064: LD_STRING DG-4-start
5066: PPUSH
5067: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
5071: LD_EXP 21
5075: PPUSH
5076: LD_STRING DH-5-start
5078: PPUSH
5079: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
5083: LD_EXP 22
5087: PPUSH
5088: LD_STRING DG-5-start
5090: PPUSH
5091: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
5095: LD_EXP 21
5099: PPUSH
5100: LD_STRING DH-6-start
5102: PPUSH
5103: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
5107: LD_EXP 23
5111: PPUSH
5112: LD_STRING DM-6-start
5114: PPUSH
5115: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
5119: LD_EXP 21
5123: PUSH
5124: LD_EXP 22
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: PPUSH
5133: LD_EXP 23
5137: PPUSH
5138: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
5142: LD_EXP 22
5146: PPUSH
5147: LD_STRING DG-6-start
5149: PPUSH
5150: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
5154: LD_EXP 21
5158: PPUSH
5159: LD_STRING DH-7-start
5161: PPUSH
5162: CALL_OW 88
// end else
5166: GO 5890
// if not Mike and Givi then
5168: LD_EXP 23
5172: NOT
5173: PUSH
5174: LD_EXP 22
5178: AND
5179: IFFALSE 5524
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5181: LD_EXP 22
5185: PUSH
5186: LD_EXP 24
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: PPUSH
5195: LD_EXP 21
5199: PPUSH
5200: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
5204: LD_EXP 21
5208: PPUSH
5209: LD_EXP 22
5213: PPUSH
5214: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
5218: LD_EXP 22
5222: PPUSH
5223: LD_STRING DG-1-start-c
5225: PPUSH
5226: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
5230: LD_EXP 21
5234: PPUSH
5235: LD_STRING DH-1-start-c
5237: PPUSH
5238: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
5242: LD_EXP 22
5246: PPUSH
5247: LD_STRING DG-2-start-c
5249: PPUSH
5250: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
5254: LD_EXP 21
5258: PPUSH
5259: LD_STRING DH-2-start-c
5261: PPUSH
5262: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
5266: LD_EXP 22
5270: PPUSH
5271: LD_STRING DG-3-start-c
5273: PPUSH
5274: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
5278: LD_EXP 21
5282: PPUSH
5283: LD_INT 83
5285: PPUSH
5286: LD_INT 56
5288: PPUSH
5289: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
5293: LD_EXP 22
5297: PPUSH
5298: LD_INT 83
5300: PPUSH
5301: LD_INT 59
5303: PPUSH
5304: CALL_OW 111
// if Kamil then
5308: LD_EXP 24
5312: IFFALSE 5329
// ComMoveXY ( Kamil , 80 , 58 ) ;
5314: LD_EXP 24
5318: PPUSH
5319: LD_INT 80
5321: PPUSH
5322: LD_INT 58
5324: PPUSH
5325: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
5329: LD_EXP 21
5333: PPUSH
5334: LD_EXP 22
5338: PPUSH
5339: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5343: LD_EXP 22
5347: PUSH
5348: LD_EXP 24
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: PPUSH
5357: LD_EXP 21
5361: PPUSH
5362: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
5366: LD_EXP 21
5370: PPUSH
5371: LD_STRING DH-3-start-c
5373: PPUSH
5374: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
5378: LD_EXP 22
5382: PPUSH
5383: LD_STRING DG-4-start-c
5385: PPUSH
5386: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
5390: LD_EXP 21
5394: PPUSH
5395: LD_STRING DH-5-start-c
5397: PPUSH
5398: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
5402: LD_EXP 22
5406: PPUSH
5407: LD_STRING DG-5-start-c
5409: PPUSH
5410: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
5414: LD_EXP 21
5418: PPUSH
5419: LD_STRING DH-6-start-c
5421: PPUSH
5422: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
5426: LD_EXP 22
5430: PPUSH
5431: LD_STRING DG-6-start-c
5433: PPUSH
5434: CALL_OW 88
// if Kamil then
5438: LD_EXP 24
5442: IFFALSE 5498
// begin ComTurnUnit ( Kamil , Heike ) ;
5444: LD_EXP 24
5448: PPUSH
5449: LD_EXP 21
5453: PPUSH
5454: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5458: LD_EXP 24
5462: PPUSH
5463: LD_STRING DKam-1-start-c
5465: PPUSH
5466: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
5470: LD_EXP 22
5474: PPUSH
5475: LD_EXP 24
5479: PPUSH
5480: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
5484: LD_EXP 22
5488: PPUSH
5489: LD_STRING DG-7-start-c
5491: PPUSH
5492: CALL_OW 88
// end else
5496: GO 5522
// begin Say ( Givi , DG-8-start-c ) ;
5498: LD_EXP 22
5502: PPUSH
5503: LD_STRING DG-8-start-c
5505: PPUSH
5506: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
5510: LD_EXP 21
5514: PPUSH
5515: LD_STRING DH-7-start-c
5517: PPUSH
5518: CALL_OW 88
// end ; end else
5522: GO 5890
// if not Givi and Mike then
5524: LD_EXP 22
5528: NOT
5529: PUSH
5530: LD_EXP 23
5534: AND
5535: IFFALSE 5794
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
5537: LD_EXP 23
5541: PUSH
5542: LD_EXP 24
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: PPUSH
5551: LD_EXP 21
5555: PPUSH
5556: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
5560: LD_EXP 21
5564: PPUSH
5565: LD_EXP 23
5569: PPUSH
5570: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
5574: LD_EXP 23
5578: PPUSH
5579: LD_STRING DM-1-start-b
5581: PPUSH
5582: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
5586: LD_EXP 21
5590: PPUSH
5591: LD_STRING DH-1-start-b
5593: PPUSH
5594: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
5598: LD_EXP 23
5602: PPUSH
5603: LD_STRING DM-2-start-b
5605: PPUSH
5606: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
5610: LD_EXP 21
5614: PPUSH
5615: LD_STRING DH-2-start-b
5617: PPUSH
5618: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
5622: LD_EXP 23
5626: PPUSH
5627: LD_STRING DM-3-start-b
5629: PPUSH
5630: CALL_OW 88
// if Kamil then
5634: LD_EXP 24
5638: IFFALSE 5655
// ComMoveXY ( Kamil , 80 , 58 ) ;
5640: LD_EXP 24
5644: PPUSH
5645: LD_INT 80
5647: PPUSH
5648: LD_INT 58
5650: PPUSH
5651: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
5655: LD_EXP 21
5659: PPUSH
5660: LD_INT 83
5662: PPUSH
5663: LD_INT 56
5665: PPUSH
5666: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
5670: LD_EXP 23
5674: PPUSH
5675: LD_INT 83
5677: PPUSH
5678: LD_INT 59
5680: PPUSH
5681: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
5685: LD_EXP 21
5689: PPUSH
5690: LD_EXP 23
5694: PPUSH
5695: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
5699: LD_EXP 24
5703: PUSH
5704: LD_EXP 23
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: PPUSH
5713: LD_EXP 21
5717: PPUSH
5718: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
5722: LD_EXP 21
5726: PPUSH
5727: LD_STRING DH-3-start-b
5729: PPUSH
5730: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
5734: LD_EXP 23
5738: PPUSH
5739: LD_STRING DM-4-start-b
5741: PPUSH
5742: CALL_OW 88
// if Kamil then
5746: LD_EXP 24
5750: IFFALSE 5780
// begin ComTurnUnit ( Kamil , Heike ) ;
5752: LD_EXP 24
5756: PPUSH
5757: LD_EXP 21
5761: PPUSH
5762: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5766: LD_EXP 24
5770: PPUSH
5771: LD_STRING DKam-1-start-c
5773: PPUSH
5774: CALL_OW 88
// end else
5778: GO 5792
// begin Say ( Mike , DM-5-start-b ) ;
5780: LD_EXP 23
5784: PPUSH
5785: LD_STRING DM-5-start-b
5787: PPUSH
5788: CALL_OW 88
// end ; end else
5792: GO 5890
// if Kamil then
5794: LD_EXP 24
5798: IFFALSE 5878
// begin AddComTurnUnit ( Heike , Kamil ) ;
5800: LD_EXP 21
5804: PPUSH
5805: LD_EXP 24
5809: PPUSH
5810: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
5814: LD_EXP 24
5818: PPUSH
5819: LD_EXP 21
5823: PPUSH
5824: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
5828: LD_EXP 21
5832: PPUSH
5833: LD_STRING DH-1-start-f
5835: PPUSH
5836: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
5840: LD_EXP 24
5844: PPUSH
5845: LD_STRING DKam-1-start-f
5847: PPUSH
5848: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
5852: LD_EXP 21
5856: PPUSH
5857: LD_STRING DH-2-start-f
5859: PPUSH
5860: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
5864: LD_EXP 24
5868: PPUSH
5869: LD_STRING DKam-2-start-f
5871: PPUSH
5872: CALL_OW 88
// end else
5876: GO 5890
// begin Say ( Heike , DH-1-start-d ) ;
5878: LD_EXP 21
5882: PPUSH
5883: LD_STRING DH-1-start-d
5885: PPUSH
5886: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
5890: LD_EXP 21
5894: PUSH
5895: LD_EXP 22
5899: PUSH
5900: LD_EXP 23
5904: PUSH
5905: LD_EXP 24
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: LIST
5914: LIST
5915: PPUSH
5916: CALL_OW 139
// InGameOff ;
5920: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
5924: LD_STRING OEast
5926: PPUSH
5927: CALL_OW 337
// SaveForQuickRestart ;
5931: CALL_OW 22
// wait ( 0 0$20 ) ;
5935: LD_INT 700
5937: PPUSH
5938: CALL_OW 67
// SendSciToForest ;
5942: CALL 1374 0 0
// if Difficulty = 1 then
5946: LD_OWVAR 67
5950: PUSH
5951: LD_INT 1
5953: EQUAL
5954: IFFALSE 5958
// exit ;
5956: GO 6075
// wait ( [ 5 5$00 , 2 2$30 ] [ Difficulty - 1 ] ) ;
5958: LD_INT 10500
5960: PUSH
5961: LD_INT 5250
5963: PUSH
5964: EMPTY
5965: LIST
5966: LIST
5967: PUSH
5968: LD_OWVAR 67
5972: PUSH
5973: LD_INT 1
5975: MINUS
5976: ARRAY
5977: PPUSH
5978: CALL_OW 67
// if usAlert then
5982: LD_EXP 9
5986: IFFALSE 5990
// exit ;
5988: GO 6075
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
5990: LD_ADDR_VAR 0 3
5994: PUSH
5995: LD_INT 22
5997: PUSH
5998: LD_INT 1
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: LD_INT 25
6007: PUSH
6008: LD_INT 2
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PPUSH
6019: CALL_OW 69
6023: ST_TO_ADDR
// if not tmp then
6024: LD_VAR 0 3
6028: NOT
6029: IFFALSE 6033
// exit ;
6031: GO 6075
// ComExitBuilding ( tmp ) ;
6033: LD_VAR 0 3
6037: PPUSH
6038: CALL_OW 122
// AddComBuild ( tmp , b_breastwork , 40 , 13 , 3 ) ;
6042: LD_VAR 0 3
6046: PPUSH
6047: LD_INT 31
6049: PPUSH
6050: LD_INT 40
6052: PPUSH
6053: LD_INT 13
6055: PPUSH
6056: LD_INT 3
6058: PPUSH
6059: CALL_OW 205
// AddComEnterUnit ( tmp , Delta ) ;
6063: LD_VAR 0 3
6067: PPUSH
6068: LD_INT 1
6070: PPUSH
6071: CALL_OW 180
// end ;
6075: LD_VAR 0 1
6079: RET
// every 3 3$00 do
6080: GO 6082
6082: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
6083: LD_INT 1
6085: PPUSH
6086: LD_INT 570
6088: PPUSH
6089: LD_INT 350
6091: PPUSH
6092: CALL_OW 550
// wait ( 2 2$40 ) ;
6096: LD_INT 5600
6098: PPUSH
6099: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
6103: LD_INT 0
6105: PPUSH
6106: LD_INT 570
6108: PPUSH
6109: LD_INT 350
6111: PPUSH
6112: CALL_OW 550
// end ;
6116: END
// every 0 0$1 trigger not aviradzeSpotted and See ( 2 , Aviradze ) do var i , pepAmount ;
6117: LD_EXP 4
6121: NOT
6122: PUSH
6123: LD_INT 2
6125: PPUSH
6126: LD_EXP 25
6130: PPUSH
6131: CALL_OW 292
6135: AND
6136: IFFALSE 7071
6138: GO 6140
6140: DISABLE
6141: LD_INT 0
6143: PPUSH
6144: PPUSH
// begin aviradzeSpotted := true ;
6145: LD_ADDR_EXP 4
6149: PUSH
6150: LD_INT 1
6152: ST_TO_ADDR
// pepAmount := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
6153: LD_ADDR_VAR 0 2
6157: PUSH
6158: LD_INT 22
6160: PUSH
6161: LD_INT 2
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: PUSH
6168: LD_INT 21
6170: PUSH
6171: LD_INT 1
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PPUSH
6182: CALL_OW 69
6186: ST_TO_ADDR
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6187: LD_EXP 21
6191: PPUSH
6192: LD_EXP 25
6196: PPUSH
6197: CALL_OW 250
6201: PPUSH
6202: LD_EXP 25
6206: PPUSH
6207: CALL_OW 251
6211: PPUSH
6212: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6216: LD_INT 35
6218: PPUSH
6219: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 16 ;
6223: LD_EXP 21
6227: PPUSH
6228: LD_EXP 25
6232: PPUSH
6233: CALL_OW 296
6237: PUSH
6238: LD_INT 16
6240: LESS
6241: IFFALSE 6216
// InGameOn ;
6243: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6247: LD_INT 5
6249: PPUSH
6250: LD_INT 2
6252: PPUSH
6253: CALL_OW 343
// if pepAmount > 2 then
6257: LD_VAR 0 2
6261: PUSH
6262: LD_INT 2
6264: GREATER
6265: IFFALSE 6281
// Say ( Heike , DH-1-spot ) else
6267: LD_EXP 21
6271: PPUSH
6272: LD_STRING DH-1-spot
6274: PPUSH
6275: CALL_OW 88
6279: GO 6293
// Say ( Heike , DH-1-spot-d ) ;
6281: LD_EXP 21
6285: PPUSH
6286: LD_STRING DH-1-spot-d
6288: PPUSH
6289: CALL_OW 88
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6293: LD_EXP 21
6297: PPUSH
6298: LD_EXP 25
6302: PPUSH
6303: CALL_OW 250
6307: PPUSH
6308: LD_EXP 25
6312: PPUSH
6313: CALL_OW 251
6317: PPUSH
6318: CALL_OW 111
// for i in [ Kamil , Mike , Givi ] do
6322: LD_ADDR_VAR 0 1
6326: PUSH
6327: LD_EXP 24
6331: PUSH
6332: LD_EXP 23
6336: PUSH
6337: LD_EXP 22
6341: PUSH
6342: EMPTY
6343: LIST
6344: LIST
6345: LIST
6346: PUSH
6347: FOR_IN
6348: IFFALSE 6387
// if GetDistUnits ( i , Aviradze ) > 7 then
6350: LD_VAR 0 1
6354: PPUSH
6355: LD_EXP 25
6359: PPUSH
6360: CALL_OW 296
6364: PUSH
6365: LD_INT 7
6367: GREATER
6368: IFFALSE 6385
// ComMoveXY ( i , 102 , 40 ) ;
6370: LD_VAR 0 1
6374: PPUSH
6375: LD_INT 102
6377: PPUSH
6378: LD_INT 40
6380: PPUSH
6381: CALL_OW 111
6385: GO 6347
6387: POP
6388: POP
// repeat wait ( 0 0$1 ) ;
6389: LD_INT 35
6391: PPUSH
6392: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 6 ;
6396: LD_EXP 21
6400: PPUSH
6401: LD_EXP 25
6405: PPUSH
6406: CALL_OW 296
6410: PUSH
6411: LD_INT 6
6413: LESS
6414: IFFALSE 6389
// ComTurnUnit ( Heike , Aviradze ) ;
6416: LD_EXP 21
6420: PPUSH
6421: LD_EXP 25
6425: PPUSH
6426: CALL_OW 119
// ComTurnUnit ( [ Aviradze , Sophia , Kaia ] , Heike ) ;
6430: LD_EXP 25
6434: PUSH
6435: LD_EXP 27
6439: PUSH
6440: LD_EXP 26
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: LIST
6449: PPUSH
6450: LD_EXP 21
6454: PPUSH
6455: CALL_OW 119
// if pepAmount > 1 then
6459: LD_VAR 0 2
6463: PUSH
6464: LD_INT 1
6466: GREATER
6467: IFFALSE 6519
// begin wait ( 0 0$2 ) ;
6469: LD_INT 70
6471: PPUSH
6472: CALL_OW 67
// ComTurnUnit ( [ Kamil , Mike , Givi ] , Aviradze ) ;
6476: LD_EXP 24
6480: PUSH
6481: LD_EXP 23
6485: PUSH
6486: LD_EXP 22
6490: PUSH
6491: EMPTY
6492: LIST
6493: LIST
6494: LIST
6495: PPUSH
6496: LD_EXP 25
6500: PPUSH
6501: CALL_OW 119
// Say ( Heike , DH-2-spot ) ;
6505: LD_EXP 21
6509: PPUSH
6510: LD_STRING DH-2-spot
6512: PPUSH
6513: CALL_OW 88
// end else
6517: GO 6531
// Say ( Heike , DH-2-spot-d ) ;
6519: LD_EXP 21
6523: PPUSH
6524: LD_STRING DH-2-spot-d
6526: PPUSH
6527: CALL_OW 88
// Say ( Aviradze , DA-2-spot ) ;
6531: LD_EXP 25
6535: PPUSH
6536: LD_STRING DA-2-spot
6538: PPUSH
6539: CALL_OW 88
// Say ( Heike , DH-3-spot ) ;
6543: LD_EXP 21
6547: PPUSH
6548: LD_STRING DH-3-spot
6550: PPUSH
6551: CALL_OW 88
// ComMoveUnit ( Kaia , Heike ) ;
6555: LD_EXP 26
6559: PPUSH
6560: LD_EXP 21
6564: PPUSH
6565: CALL_OW 112
// ComTurnUNit ( Heike , Kaia ) ;
6569: LD_EXP 21
6573: PPUSH
6574: LD_EXP 26
6578: PPUSH
6579: CALL_OW 119
// wait ( 0 0$0.3 ) ;
6583: LD_INT 10
6585: PPUSH
6586: CALL_OW 67
// async ;
6590: ASYNC
// Say ( Kaia , DK-3-spot ) ;
6591: LD_EXP 26
6595: PPUSH
6596: LD_STRING DK-3-spot
6598: PPUSH
6599: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6603: LD_INT 35
6605: PPUSH
6606: CALL_OW 67
// until GetDistUnits ( Heike , Kaia ) < 4 ;
6610: LD_EXP 21
6614: PPUSH
6615: LD_EXP 26
6619: PPUSH
6620: CALL_OW 296
6624: PUSH
6625: LD_INT 4
6627: LESS
6628: IFFALSE 6603
// ComTurnUnit ( Kaia , Heike ) ;
6630: LD_EXP 26
6634: PPUSH
6635: LD_EXP 21
6639: PPUSH
6640: CALL_OW 119
// sync ;
6644: SYNC
// Say ( Heike , DH-4-spot ) ;
6645: LD_EXP 21
6649: PPUSH
6650: LD_STRING DH-4-spot
6652: PPUSH
6653: CALL_OW 88
// wait ( 0 0$0.3 ) ;
6657: LD_INT 10
6659: PPUSH
6660: CALL_OW 67
// ComTurnUnit ( Heike , Aviradze ) ;
6664: LD_EXP 21
6668: PPUSH
6669: LD_EXP 25
6673: PPUSH
6674: CALL_OW 119
// Say ( Aviradze , DA-4-spot ) ;
6678: LD_EXP 25
6682: PPUSH
6683: LD_STRING DA-4-spot
6685: PPUSH
6686: CALL_OW 88
// ComTurnUnit ( Kaia , Aviradze ) ;
6690: LD_EXP 26
6694: PPUSH
6695: LD_EXP 25
6699: PPUSH
6700: CALL_OW 119
// Say ( Kaia , DK-4-spot ) ;
6704: LD_EXP 26
6708: PPUSH
6709: LD_STRING DK-4-spot
6711: PPUSH
6712: CALL_OW 88
// ComTurnUnit ( Aviradze , Kaia ) ;
6716: LD_EXP 25
6720: PPUSH
6721: LD_EXP 26
6725: PPUSH
6726: CALL_OW 119
// Say ( Aviradze , DA-5-spot ) ;
6730: LD_EXP 25
6734: PPUSH
6735: LD_STRING DA-5-spot
6737: PPUSH
6738: CALL_OW 88
// Say ( Kaia , DK-5-spot ) ;
6742: LD_EXP 26
6746: PPUSH
6747: LD_STRING DK-5-spot
6749: PPUSH
6750: CALL_OW 88
// if pepAmount = 1 then
6754: LD_VAR 0 2
6758: PUSH
6759: LD_INT 1
6761: EQUAL
6762: IFFALSE 6776
// Say ( Heike , DH-5-spot-f ) ;
6764: LD_EXP 21
6768: PPUSH
6769: LD_STRING DH-5-spot-f
6771: PPUSH
6772: CALL_OW 88
// if pepAmount < 3 then
6776: LD_VAR 0 2
6780: PUSH
6781: LD_INT 3
6783: LESS
6784: IFFALSE 6800
// Say ( Aviradze , DA-6-spot-f ) else
6786: LD_EXP 25
6790: PPUSH
6791: LD_STRING DA-6-spot-f
6793: PPUSH
6794: CALL_OW 88
6798: GO 6836
// if pepAmount < 4 then
6800: LD_VAR 0 2
6804: PUSH
6805: LD_INT 4
6807: LESS
6808: IFFALSE 6824
// Say ( Aviradze , DA-6-spot-c ) else
6810: LD_EXP 25
6814: PPUSH
6815: LD_STRING DA-6-spot-c
6817: PPUSH
6818: CALL_OW 88
6822: GO 6836
// Say ( Aviradze , DA-6-spot ) ;
6824: LD_EXP 25
6828: PPUSH
6829: LD_STRING DA-6-spot
6831: PPUSH
6832: CALL_OW 88
// if Kamil then
6836: LD_EXP 24
6840: IFFALSE 6854
// Say ( Kamil , DKam-6-spot ) ;
6842: LD_EXP 24
6846: PPUSH
6847: LD_STRING DKam-6-spot
6849: PPUSH
6850: CALL_OW 88
// Say ( Kaia , DK-6-spot ) ;
6854: LD_EXP 26
6858: PPUSH
6859: LD_STRING DK-6-spot
6861: PPUSH
6862: CALL_OW 88
// ComTurnUnit ( Aviradze , Heike ) ;
6866: LD_EXP 25
6870: PPUSH
6871: LD_EXP 21
6875: PPUSH
6876: CALL_OW 119
// Say ( Aviradze , DA-7-spot ) ;
6880: LD_EXP 25
6884: PPUSH
6885: LD_STRING DA-7-spot
6887: PPUSH
6888: CALL_OW 88
// Say ( Heike , DH-7-spot ) ;
6892: LD_EXP 21
6896: PPUSH
6897: LD_STRING DH-7-spot
6899: PPUSH
6900: CALL_OW 88
// if sciCounterKill >= 3 then
6904: LD_EXP 8
6908: PUSH
6909: LD_INT 3
6911: GREATEREQUAL
6912: IFFALSE 6938
// begin Say ( Heike , DH-7-spot-a ) ;
6914: LD_EXP 21
6918: PPUSH
6919: LD_STRING DH-7-spot-a
6921: PPUSH
6922: CALL_OW 88
// Say ( Aviradze , DA-8-spot-a ) ;
6926: LD_EXP 25
6930: PPUSH
6931: LD_STRING DA-8-spot-a
6933: PPUSH
6934: CALL_OW 88
// end ; InGameOff ;
6938: CALL_OW 9
// if sciCounterKill < 3 then
6942: LD_EXP 8
6946: PUSH
6947: LD_INT 3
6949: LESS
6950: IFFALSE 7009
// begin SetSide ( Kaia , 2 ) ;
6952: LD_EXP 26
6956: PPUSH
6957: LD_INT 2
6959: PPUSH
6960: CALL_OW 235
// ComFree ( Kaia ) ;
6964: LD_EXP 26
6968: PPUSH
6969: CALL_OW 139
// if Kamil then
6973: LD_EXP 24
6977: IFFALSE 7000
// begin ComHold ( Kamil ) ;
6979: LD_EXP 24
6983: PPUSH
6984: CALL_OW 140
// SetSide ( Kamil , 5 ) ;
6988: LD_EXP 24
6992: PPUSH
6993: LD_INT 5
6995: PPUSH
6996: CALL_OW 235
// end ; ChangeMissionObjectives ( OSci ) ;
7000: LD_STRING OSci
7002: PPUSH
7003: CALL_OW 337
// end else
7007: GO 7071
// begin aviradzeQuestDone := true ;
7009: LD_ADDR_EXP 7
7013: PUSH
7014: LD_INT 1
7016: ST_TO_ADDR
// attackDeltaAllowed := true ;
7017: LD_ADDR_EXP 12
7021: PUSH
7022: LD_INT 1
7024: ST_TO_ADDR
// ChangeMissionObjectives ( ODelta2 ) ;
7025: LD_STRING ODelta2
7027: PPUSH
7028: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7032: LD_ADDR_VAR 0 1
7036: PUSH
7037: LD_INT 22
7039: PUSH
7040: LD_INT 5
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: CALL_OW 69
7051: PUSH
7052: FOR_IN
7053: IFFALSE 7069
// SetSide ( i , 2 ) ;
7055: LD_VAR 0 1
7059: PPUSH
7060: LD_INT 2
7062: PPUSH
7063: CALL_OW 235
7067: GO 7052
7069: POP
7070: POP
// end ; end ;
7071: PPOPN 2
7073: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and not aviradzeSpotted do
7074: LD_EXP 6
7078: NOT
7079: PUSH
7080: LD_EXP 20
7084: PPUSH
7085: LD_EXP 21
7089: PPUSH
7090: CALL_OW 74
7094: PPUSH
7095: LD_EXP 21
7099: PPUSH
7100: CALL_OW 296
7104: PUSH
7105: LD_INT 8
7107: LESS
7108: AND
7109: PUSH
7110: LD_INT 2
7112: PPUSH
7113: LD_EXP 20
7117: PPUSH
7118: LD_EXP 21
7122: PPUSH
7123: CALL_OW 74
7127: PPUSH
7128: CALL_OW 292
7132: AND
7133: PUSH
7134: LD_INT 22
7136: PUSH
7137: LD_INT 2
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: LD_INT 21
7146: PUSH
7147: LD_INT 1
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PPUSH
7158: CALL_OW 69
7162: PUSH
7163: LD_INT 1
7165: GREATER
7166: AND
7167: PUSH
7168: LD_EXP 4
7172: NOT
7173: AND
7174: IFFALSE 7218
7176: GO 7178
7178: DISABLE
// begin sciSpotted := true ;
7179: LD_ADDR_EXP 6
7183: PUSH
7184: LD_INT 1
7186: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7187: LD_EXP 20
7191: PPUSH
7192: LD_EXP 21
7196: PPUSH
7197: CALL_OW 74
7201: PPUSH
7202: CALL_OW 87
// Say ( Heike , DH-1-sci ) ;
7206: LD_EXP 21
7210: PPUSH
7211: LD_STRING DH-1-sci
7213: PPUSH
7214: CALL_OW 88
// end ;
7218: END
// every 0 0$1 trigger not sciSpotted and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and aviradzeSpotted and not aviradzeQuestDone do
7219: LD_EXP 6
7223: NOT
7224: PUSH
7225: LD_INT 2
7227: PPUSH
7228: LD_EXP 20
7232: PPUSH
7233: LD_EXP 21
7237: PPUSH
7238: CALL_OW 74
7242: PPUSH
7243: CALL_OW 292
7247: AND
7248: PUSH
7249: LD_INT 22
7251: PUSH
7252: LD_INT 2
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: PUSH
7259: LD_INT 21
7261: PUSH
7262: LD_INT 1
7264: PUSH
7265: EMPTY
7266: LIST
7267: LIST
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PPUSH
7273: CALL_OW 69
7277: PUSH
7278: LD_INT 1
7280: GREATER
7281: AND
7282: PUSH
7283: LD_EXP 4
7287: AND
7288: PUSH
7289: LD_EXP 7
7293: NOT
7294: AND
7295: IFFALSE 7357
7297: GO 7299
7299: DISABLE
// begin sciSpotted := true ;
7300: LD_ADDR_EXP 6
7304: PUSH
7305: LD_INT 1
7307: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7308: LD_EXP 20
7312: PPUSH
7313: LD_EXP 21
7317: PPUSH
7318: CALL_OW 74
7322: PPUSH
7323: CALL_OW 87
// Say ( Heike , DH-1-sci-a ) ;
7327: LD_EXP 21
7331: PPUSH
7332: LD_STRING DH-1-sci-a
7334: PPUSH
7335: CALL_OW 88
// if Mike then
7339: LD_EXP 23
7343: IFFALSE 7357
// Say ( Mike , DM-1-sci-a ) ;
7345: LD_EXP 23
7349: PPUSH
7350: LD_STRING DM-1-sci-a
7352: PPUSH
7353: CALL_OW 88
// end ;
7357: END
// every 0 0$1 trigger aviradzeSpotted and ( sciCounterKill >= 3 or not usSci ) and not aviradzeQuestDone do
7358: LD_EXP 4
7362: PUSH
7363: LD_EXP 8
7367: PUSH
7368: LD_INT 3
7370: GREATEREQUAL
7371: PUSH
7372: LD_EXP 20
7376: NOT
7377: OR
7378: AND
7379: PUSH
7380: LD_EXP 7
7384: NOT
7385: AND
7386: IFFALSE 7429
7388: GO 7390
7390: DISABLE
// begin aviradzeQuestDone := true ;
7391: LD_ADDR_EXP 7
7395: PUSH
7396: LD_INT 1
7398: ST_TO_ADDR
// Say ( Heike , DH-1-quest-done ) ;
7399: LD_EXP 21
7403: PPUSH
7404: LD_STRING DH-1-quest-done
7406: PPUSH
7407: CALL_OW 88
// if Givi then
7411: LD_EXP 22
7415: IFFALSE 7429
// Say ( Givi , DG-1-quest-done ) ;
7417: LD_EXP 22
7421: PPUSH
7422: LD_STRING DG-1-quest-done
7424: PPUSH
7425: CALL_OW 88
// end ;
7429: END
// every 0 0$1 trigger See ( 5 , Heike ) and GetDistUnits ( Heike , Aviradze ) < 6 and aviradzeQuestDone and not attackDeltaAllowed do var i ;
7430: LD_INT 5
7432: PPUSH
7433: LD_EXP 21
7437: PPUSH
7438: CALL_OW 292
7442: PUSH
7443: LD_EXP 21
7447: PPUSH
7448: LD_EXP 25
7452: PPUSH
7453: CALL_OW 296
7457: PUSH
7458: LD_INT 6
7460: LESS
7461: AND
7462: PUSH
7463: LD_EXP 7
7467: AND
7468: PUSH
7469: LD_EXP 12
7473: NOT
7474: AND
7475: IFFALSE 7613
7477: GO 7479
7479: DISABLE
7480: LD_INT 0
7482: PPUSH
// begin attackDeltaAllowed := true ;
7483: LD_ADDR_EXP 12
7487: PUSH
7488: LD_INT 1
7490: ST_TO_ADDR
// InGameOn ;
7491: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
7495: LD_EXP 21
7499: PPUSH
7500: CALL_OW 87
// wait ( 0 0$0.3 ) ;
7504: LD_INT 10
7506: PPUSH
7507: CALL_OW 67
// ComTurnUnit ( Aviradze , Heike ) ;
7511: LD_EXP 25
7515: PPUSH
7516: LD_EXP 21
7520: PPUSH
7521: CALL_OW 119
// ComTurnUnit ( Heike , Aviradze ) ;
7525: LD_EXP 21
7529: PPUSH
7530: LD_EXP 25
7534: PPUSH
7535: CALL_OW 119
// Say ( Heike , DH-1-return ) ;
7539: LD_EXP 21
7543: PPUSH
7544: LD_STRING DH-1-return
7546: PPUSH
7547: CALL_OW 88
// Say ( Aviradze , DA-1-return ) ;
7551: LD_EXP 25
7555: PPUSH
7556: LD_STRING DA-1-return
7558: PPUSH
7559: CALL_OW 88
// InGameOff ;
7563: CALL_OW 9
// ChangeMissionObjectives ( ODelta ) ;
7567: LD_STRING ODelta
7569: PPUSH
7570: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7574: LD_ADDR_VAR 0 1
7578: PUSH
7579: LD_INT 22
7581: PUSH
7582: LD_INT 5
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PPUSH
7589: CALL_OW 69
7593: PUSH
7594: FOR_IN
7595: IFFALSE 7611
// SetSide ( i , 2 ) ;
7597: LD_VAR 0 1
7601: PPUSH
7602: LD_INT 2
7604: PPUSH
7605: CALL_OW 235
7609: GO 7594
7611: POP
7612: POP
// end ;
7613: PPOPN 1
7615: END
// every 0 0$1 trigger attackDeltaAllowed and IsOk ( Markov ) and GetSide ( Delta ) = 1 and IsOk ( Lynch ) and not usAlert do var i , k , tmp ;
7616: LD_EXP 12
7620: PUSH
7621: LD_EXP 28
7625: PPUSH
7626: CALL_OW 302
7630: AND
7631: PUSH
7632: LD_INT 1
7634: PPUSH
7635: CALL_OW 255
7639: PUSH
7640: LD_INT 1
7642: EQUAL
7643: AND
7644: PUSH
7645: LD_EXP 18
7649: PPUSH
7650: CALL_OW 302
7654: AND
7655: PUSH
7656: LD_EXP 9
7660: NOT
7661: AND
7662: IFFALSE 8832
7664: GO 7666
7666: DISABLE
7667: LD_INT 0
7669: PPUSH
7670: PPUSH
7671: PPUSH
// begin trap := 0 ;
7672: LD_ADDR_EXP 15
7676: PUSH
7677: LD_INT 0
7679: ST_TO_ADDR
// wait ( 0 0$15 ) ;
7680: LD_INT 525
7682: PPUSH
7683: CALL_OW 67
// DialogueOn ;
7687: CALL_OW 6
// Say ( Markov , DMar-1-radio ) ;
7691: LD_EXP 28
7695: PPUSH
7696: LD_STRING DMar-1-radio
7698: PPUSH
7699: CALL_OW 88
// Say ( Heike , DH-1-radio ) ;
7703: LD_EXP 21
7707: PPUSH
7708: LD_STRING DH-1-radio
7710: PPUSH
7711: CALL_OW 88
// Say ( Markov , DMar-2-radio ) ;
7715: LD_EXP 28
7719: PPUSH
7720: LD_STRING DMar-2-radio
7722: PPUSH
7723: CALL_OW 88
// Say ( Heike , DH-2-radio ) ;
7727: LD_EXP 21
7731: PPUSH
7732: LD_STRING DH-2-radio
7734: PPUSH
7735: CALL_OW 88
// if IsOk ( Kamil ) or IsOk ( Sophia ) then
7739: LD_EXP 24
7743: PPUSH
7744: CALL_OW 302
7748: PUSH
7749: LD_EXP 27
7753: PPUSH
7754: CALL_OW 302
7758: OR
7759: IFFALSE 8832
// begin case Query ( Q1Trap ) of 1 :
7761: LD_STRING Q1Trap
7763: PPUSH
7764: CALL_OW 97
7768: PUSH
7769: LD_INT 1
7771: DOUBLE
7772: EQUAL
7773: IFTRUE 7777
7775: GO 7971
7777: POP
// begin if IsOk ( Kamil ) then
7778: LD_EXP 24
7782: PPUSH
7783: CALL_OW 302
7787: IFFALSE 7866
// begin Say ( Kamil , DKam-2-radio ) ;
7789: LD_EXP 24
7793: PPUSH
7794: LD_STRING DKam-2-radio
7796: PPUSH
7797: CALL_OW 88
// Say ( Kamil , DKam-3-radio ) ;
7801: LD_EXP 24
7805: PPUSH
7806: LD_STRING DKam-3-radio
7808: PPUSH
7809: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio ) ;
7813: LD_EXP 18
7817: PPUSH
7818: LD_STRING DDelta-3-radio
7820: PPUSH
7821: CALL_OW 94
// dwait ( 0 0$01 ) ;
7825: LD_INT 35
7827: PPUSH
7828: CALL_OW 68
// Say ( Heike , DH-3-radio ) ;
7832: LD_EXP 21
7836: PPUSH
7837: LD_STRING DH-3-radio
7839: PPUSH
7840: CALL_OW 88
// Say ( Kamil , DKam-4-radio ) ;
7844: LD_EXP 24
7848: PPUSH
7849: LD_STRING DKam-4-radio
7851: PPUSH
7852: CALL_OW 88
// trap := 1 ;
7856: LD_ADDR_EXP 15
7860: PUSH
7861: LD_INT 1
7863: ST_TO_ADDR
// end else
7864: GO 7965
// begin Say ( Sophia , DS-1-radio ) ;
7866: LD_EXP 27
7870: PPUSH
7871: LD_STRING DS-1-radio
7873: PPUSH
7874: CALL_OW 88
// Say ( Sophia , DS-2-radio ) ;
7878: LD_EXP 27
7882: PPUSH
7883: LD_STRING DS-2-radio
7885: PPUSH
7886: CALL_OW 88
// SayRadio ( Lynch , DDelta-2-radio-s ) ;
7890: LD_EXP 18
7894: PPUSH
7895: LD_STRING DDelta-2-radio-s
7897: PPUSH
7898: CALL_OW 94
// Say ( Sophia , DS-3-radio ) ;
7902: LD_EXP 27
7906: PPUSH
7907: LD_STRING DS-3-radio
7909: PPUSH
7910: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio-s ) ;
7914: LD_EXP 18
7918: PPUSH
7919: LD_STRING DDelta-3-radio-s
7921: PPUSH
7922: CALL_OW 94
// Say ( Sophia , DS-4-radio-s ) ;
7926: LD_EXP 27
7930: PPUSH
7931: LD_STRING DS-4-radio-s
7933: PPUSH
7934: CALL_OW 88
// dwait ( 0 0$01 ) ;
7938: LD_INT 35
7940: PPUSH
7941: CALL_OW 68
// Say ( Heike , DH-1-trap ) ;
7945: LD_EXP 21
7949: PPUSH
7950: LD_STRING DH-1-trap
7952: PPUSH
7953: CALL_OW 88
// trap := 0 ;
7957: LD_ADDR_EXP 15
7961: PUSH
7962: LD_INT 0
7964: ST_TO_ADDR
// end ; DialogueOff ;
7965: CALL_OW 7
// end ; 2 :
7969: GO 7989
7971: LD_INT 2
7973: DOUBLE
7974: EQUAL
7975: IFTRUE 7979
7977: GO 7988
7979: POP
// begin DialogueOff ;
7980: CALL_OW 7
// exit ;
7984: GO 8832
// end ; end ;
7986: GO 7989
7988: POP
// if trap = 1 then
7989: LD_EXP 15
7993: PUSH
7994: LD_INT 1
7996: EQUAL
7997: IFFALSE 8403
// begin tmp := [ ] ;
7999: LD_ADDR_VAR 0 3
8003: PUSH
8004: EMPTY
8005: ST_TO_ADDR
// k := 3 ;
8006: LD_ADDR_VAR 0 2
8010: PUSH
8011: LD_INT 3
8013: ST_TO_ADDR
// if usForces < 3 then
8014: LD_EXP 19
8018: PUSH
8019: LD_INT 3
8021: LESS
8022: IFFALSE 8034
// k := usForces ;
8024: LD_ADDR_VAR 0 2
8028: PUSH
8029: LD_EXP 19
8033: ST_TO_ADDR
// for i := 1 to k do
8034: LD_ADDR_VAR 0 1
8038: PUSH
8039: DOUBLE
8040: LD_INT 1
8042: DEC
8043: ST_TO_ADDR
8044: LD_VAR 0 2
8048: PUSH
8049: FOR_TO
8050: IFFALSE 8105
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8052: LD_ADDR_VAR 0 3
8056: PUSH
8057: LD_VAR 0 3
8061: PPUSH
8062: LD_VAR 0 3
8066: PUSH
8067: LD_INT 1
8069: PLUS
8070: PPUSH
8071: LD_EXP 19
8075: PUSH
8076: LD_INT 1
8078: ARRAY
8079: PPUSH
8080: CALL_OW 1
8084: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8085: LD_ADDR_EXP 19
8089: PUSH
8090: LD_EXP 19
8094: PPUSH
8095: LD_INT 1
8097: PPUSH
8098: CALL_OW 3
8102: ST_TO_ADDR
// end ;
8103: GO 8049
8105: POP
8106: POP
// usPatrol := tmp ;
8107: LD_ADDR_EXP 14
8111: PUSH
8112: LD_VAR 0 3
8116: ST_TO_ADDR
// for i in tmp do
8117: LD_ADDR_VAR 0 1
8121: PUSH
8122: LD_VAR 0 3
8126: PUSH
8127: FOR_IN
8128: IFFALSE 8258
// begin if IsInUnit ( i ) then
8130: LD_VAR 0 1
8134: PPUSH
8135: CALL_OW 310
8139: IFFALSE 8150
// ComExitBuilding ( i ) ;
8141: LD_VAR 0 1
8145: PPUSH
8146: CALL_OW 122
// AddComAgressiveMove ( i , 63 , 31 ) ;
8150: LD_VAR 0 1
8154: PPUSH
8155: LD_INT 63
8157: PPUSH
8158: LD_INT 31
8160: PPUSH
8161: CALL_OW 174
// AddComWait ( i , 0 0$2 ) ;
8165: LD_VAR 0 1
8169: PPUSH
8170: LD_INT 70
8172: PPUSH
8173: CALL_OW 202
// AddComAgressiveMove ( i , 103 , 43 ) ;
8177: LD_VAR 0 1
8181: PPUSH
8182: LD_INT 103
8184: PPUSH
8185: LD_INT 43
8187: PPUSH
8188: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8192: LD_VAR 0 1
8196: PPUSH
8197: LD_INT 105
8199: PPUSH
8200: CALL_OW 202
// if Difficulty > 1 then
8204: LD_OWVAR 67
8208: PUSH
8209: LD_INT 1
8211: GREATER
8212: IFFALSE 8229
// AddComAgressiveMove ( i , 114 , 69 ) ;
8214: LD_VAR 0 1
8218: PPUSH
8219: LD_INT 114
8221: PPUSH
8222: LD_INT 69
8224: PPUSH
8225: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8229: LD_VAR 0 1
8233: PPUSH
8234: LD_INT 105
8236: PPUSH
8237: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8241: LD_VAR 0 1
8245: PPUSH
8246: LD_INT 42
8248: PPUSH
8249: LD_INT 20
8251: PPUSH
8252: CALL_OW 174
// end ;
8256: GO 8127
8258: POP
8259: POP
// repeat wait ( 0 0$1 ) ;
8260: LD_INT 35
8262: PPUSH
8263: CALL_OW 67
// for i in tmp do
8267: LD_ADDR_VAR 0 1
8271: PUSH
8272: LD_VAR 0 3
8276: PUSH
8277: FOR_IN
8278: IFFALSE 8309
// if IsDead ( i ) then
8280: LD_VAR 0 1
8284: PPUSH
8285: CALL_OW 301
8289: IFFALSE 8307
// tmp := tmp diff i ;
8291: LD_ADDR_VAR 0 3
8295: PUSH
8296: LD_VAR 0 3
8300: PUSH
8301: LD_VAR 0 1
8305: DIFF
8306: ST_TO_ADDR
8307: GO 8277
8309: POP
8310: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8311: LD_VAR 0 3
8315: NOT
8316: PUSH
8317: LD_VAR 0 3
8321: PPUSH
8322: LD_INT 95
8324: PUSH
8325: LD_INT 7
8327: PUSH
8328: EMPTY
8329: LIST
8330: LIST
8331: PUSH
8332: LD_INT 3
8334: PUSH
8335: LD_INT 60
8337: PUSH
8338: EMPTY
8339: LIST
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PUSH
8345: EMPTY
8346: LIST
8347: LIST
8348: PPUSH
8349: CALL_OW 72
8353: PUSH
8354: LD_VAR 0 3
8358: EQUAL
8359: OR
8360: IFFALSE 8260
// if tmp then
8362: LD_VAR 0 3
8366: IFFALSE 8393
// begin usPatrol := [ ] ;
8368: LD_ADDR_EXP 14
8372: PUSH
8373: EMPTY
8374: ST_TO_ADDR
// usForces := usForces union tmp ;
8375: LD_ADDR_EXP 19
8379: PUSH
8380: LD_EXP 19
8384: PUSH
8385: LD_VAR 0 3
8389: UNION
8390: ST_TO_ADDR
// end else
8391: GO 8401
// trickyMove := true ;
8393: LD_ADDR_EXP 13
8397: PUSH
8398: LD_INT 1
8400: ST_TO_ADDR
// end else
8401: GO 8832
// begin tmp := [ ] ;
8403: LD_ADDR_VAR 0 3
8407: PUSH
8408: EMPTY
8409: ST_TO_ADDR
// k := 4 ;
8410: LD_ADDR_VAR 0 2
8414: PUSH
8415: LD_INT 4
8417: ST_TO_ADDR
// if usForces < 4 then
8418: LD_EXP 19
8422: PUSH
8423: LD_INT 4
8425: LESS
8426: IFFALSE 8438
// k := usForces ;
8428: LD_ADDR_VAR 0 2
8432: PUSH
8433: LD_EXP 19
8437: ST_TO_ADDR
// for i := 1 to k do
8438: LD_ADDR_VAR 0 1
8442: PUSH
8443: DOUBLE
8444: LD_INT 1
8446: DEC
8447: ST_TO_ADDR
8448: LD_VAR 0 2
8452: PUSH
8453: FOR_TO
8454: IFFALSE 8509
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8456: LD_ADDR_VAR 0 3
8460: PUSH
8461: LD_VAR 0 3
8465: PPUSH
8466: LD_VAR 0 3
8470: PUSH
8471: LD_INT 1
8473: PLUS
8474: PPUSH
8475: LD_EXP 19
8479: PUSH
8480: LD_INT 1
8482: ARRAY
8483: PPUSH
8484: CALL_OW 1
8488: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8489: LD_ADDR_EXP 19
8493: PUSH
8494: LD_EXP 19
8498: PPUSH
8499: LD_INT 1
8501: PPUSH
8502: CALL_OW 3
8506: ST_TO_ADDR
// end ;
8507: GO 8453
8509: POP
8510: POP
// if Lynch then
8511: LD_EXP 18
8515: IFFALSE 8533
// tmp := tmp ^ Lynch ;
8517: LD_ADDR_VAR 0 3
8521: PUSH
8522: LD_VAR 0 3
8526: PUSH
8527: LD_EXP 18
8531: ADD
8532: ST_TO_ADDR
// usPatrol := tmp ;
8533: LD_ADDR_EXP 14
8537: PUSH
8538: LD_VAR 0 3
8542: ST_TO_ADDR
// for i in tmp do
8543: LD_ADDR_VAR 0 1
8547: PUSH
8548: LD_VAR 0 3
8552: PUSH
8553: FOR_IN
8554: IFFALSE 8647
// begin if IsInUnit ( i ) then
8556: LD_VAR 0 1
8560: PPUSH
8561: CALL_OW 310
8565: IFFALSE 8576
// ComExitBuilding ( i ) ;
8567: LD_VAR 0 1
8571: PPUSH
8572: CALL_OW 122
// AddComAgressiveMove ( i , 69 , 15 ) ;
8576: LD_VAR 0 1
8580: PPUSH
8581: LD_INT 69
8583: PPUSH
8584: LD_INT 15
8586: PPUSH
8587: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8591: LD_VAR 0 1
8595: PPUSH
8596: LD_INT 700
8598: PPUSH
8599: CALL_OW 202
// AddComAgressiveMove ( i , 55 , 43 ) ;
8603: LD_VAR 0 1
8607: PPUSH
8608: LD_INT 55
8610: PPUSH
8611: LD_INT 43
8613: PPUSH
8614: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8618: LD_VAR 0 1
8622: PPUSH
8623: LD_INT 700
8625: PPUSH
8626: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8630: LD_VAR 0 1
8634: PPUSH
8635: LD_INT 42
8637: PPUSH
8638: LD_INT 20
8640: PPUSH
8641: CALL_OW 174
// end ;
8645: GO 8553
8647: POP
8648: POP
// repeat wait ( 0 0$1 ) ;
8649: LD_INT 35
8651: PPUSH
8652: CALL_OW 67
// for i in tmp do
8656: LD_ADDR_VAR 0 1
8660: PUSH
8661: LD_VAR 0 3
8665: PUSH
8666: FOR_IN
8667: IFFALSE 8698
// if IsDead ( i ) then
8669: LD_VAR 0 1
8673: PPUSH
8674: CALL_OW 301
8678: IFFALSE 8696
// tmp := tmp diff i ;
8680: LD_ADDR_VAR 0 3
8684: PUSH
8685: LD_VAR 0 3
8689: PUSH
8690: LD_VAR 0 1
8694: DIFF
8695: ST_TO_ADDR
8696: GO 8666
8698: POP
8699: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8700: LD_VAR 0 3
8704: NOT
8705: PUSH
8706: LD_VAR 0 3
8710: PPUSH
8711: LD_INT 95
8713: PUSH
8714: LD_INT 7
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: PUSH
8721: LD_INT 3
8723: PUSH
8724: LD_INT 60
8726: PUSH
8727: EMPTY
8728: LIST
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PPUSH
8738: CALL_OW 72
8742: PUSH
8743: LD_VAR 0 3
8747: EQUAL
8748: OR
8749: IFFALSE 8649
// if not tmp then
8751: LD_VAR 0 3
8755: NOT
8756: IFFALSE 8768
// trickyMove := true else
8758: LD_ADDR_EXP 13
8762: PUSH
8763: LD_INT 1
8765: ST_TO_ADDR
8766: GO 8775
// usPatrol := [ ] ;
8768: LD_ADDR_EXP 14
8772: PUSH
8773: EMPTY
8774: ST_TO_ADDR
// if tmp diff Lynch then
8775: LD_VAR 0 3
8779: PUSH
8780: LD_EXP 18
8784: DIFF
8785: IFFALSE 8809
// usForces := usForces union ( tmp diff Lynch ) ;
8787: LD_ADDR_EXP 19
8791: PUSH
8792: LD_EXP 19
8796: PUSH
8797: LD_VAR 0 3
8801: PUSH
8802: LD_EXP 18
8806: DIFF
8807: UNION
8808: ST_TO_ADDR
// if IsOk ( Lynch ) then
8809: LD_EXP 18
8813: PPUSH
8814: CALL_OW 302
8818: IFFALSE 8832
// ComEnterUnit ( Lynch , Delta ) ;
8820: LD_EXP 18
8824: PPUSH
8825: LD_INT 1
8827: PPUSH
8828: CALL_OW 120
// end ; end ; end ;
8832: PPOPN 3
8834: END
// every 0 0$1 trigger UnitFilter ( usPatrol , [ f_see , 2 ] ) do
8835: LD_EXP 14
8839: PPUSH
8840: LD_INT 101
8842: PUSH
8843: LD_INT 2
8845: PUSH
8846: EMPTY
8847: LIST
8848: LIST
8849: PPUSH
8850: CALL_OW 72
8854: IFFALSE 8987
8856: GO 8858
8858: DISABLE
// begin if not trap then
8859: LD_EXP 15
8863: NOT
8864: IFFALSE 8892
// begin Say ( Heike , DH-2-trap ) ;
8866: LD_EXP 21
8870: PPUSH
8871: LD_STRING DH-2-trap
8873: PPUSH
8874: CALL_OW 88
// Say ( Mike , DM-2-trap ) ;
8878: LD_EXP 23
8882: PPUSH
8883: LD_STRING DM-2-trap
8885: PPUSH
8886: CALL_OW 88
// end else
8890: GO 8904
// begin Say ( Heike , DH-1-trap-a ) ;
8892: LD_EXP 21
8896: PPUSH
8897: LD_STRING DH-1-trap-a
8899: PPUSH
8900: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
8904: LD_INT 35
8906: PPUSH
8907: CALL_OW 67
// until trickyMove ;
8911: LD_EXP 13
8915: IFFALSE 8904
// Say ( Heike , DH-3-trap ) ;
8917: LD_EXP 21
8921: PPUSH
8922: LD_STRING DH-3-trap
8924: PPUSH
8925: CALL_OW 88
// if IsOk ( Givi ) and IsOk ( Kaia ) then
8929: LD_EXP 22
8933: PPUSH
8934: CALL_OW 302
8938: PUSH
8939: LD_EXP 26
8943: PPUSH
8944: CALL_OW 302
8948: AND
8949: IFFALSE 8987
// begin Say ( Givi , DG-3-trap ) ;
8951: LD_EXP 22
8955: PPUSH
8956: LD_STRING DG-3-trap
8958: PPUSH
8959: CALL_OW 88
// Say ( Kaia , DK-3-trap ) ;
8963: LD_EXP 26
8967: PPUSH
8968: LD_STRING DK-3-trap
8970: PPUSH
8971: CALL_OW 88
// Say ( Givi , DG-4-trap ) ;
8975: LD_EXP 22
8979: PPUSH
8980: LD_STRING DG-4-trap
8982: PPUSH
8983: CALL_OW 88
// end ; end ;
8987: END
// every 0 0$1 trigger GetSide ( Delta ) = 2 and attackDeltaAllowed do
8988: LD_INT 1
8990: PPUSH
8991: CALL_OW 255
8995: PUSH
8996: LD_INT 2
8998: EQUAL
8999: PUSH
9000: LD_EXP 12
9004: AND
9005: IFFALSE 9048
9007: GO 9009
9009: DISABLE
// begin if not IsOk ( Kaia ) then
9010: LD_EXP 26
9014: PPUSH
9015: CALL_OW 302
9019: NOT
9020: IFFALSE 9024
// exit ;
9022: GO 9048
// Say ( Kaia , DK-1-capture ) ;
9024: LD_EXP 26
9028: PPUSH
9029: LD_STRING DK-1-capture
9031: PPUSH
9032: CALL_OW 88
// Say ( Heike , DH-1-capture ) ;
9036: LD_EXP 21
9040: PPUSH
9041: LD_STRING DH-1-capture
9043: PPUSH
9044: CALL_OW 88
// end ;
9048: END
// every 0 0$1 trigger GetSide ( usLab ) = 2 and attackDeltaAllowed do
9049: LD_INT 3
9051: PPUSH
9052: CALL_OW 255
9056: PUSH
9057: LD_INT 2
9059: EQUAL
9060: PUSH
9061: LD_EXP 12
9065: AND
9066: IFFALSE 9098
9068: GO 9070
9070: DISABLE
// begin DialogueOn ;
9071: CALL_OW 6
// Say ( Aviradze , DA-1-capture ) ;
9075: LD_EXP 25
9079: PPUSH
9080: LD_STRING DA-1-capture
9082: PPUSH
9083: CALL_OW 88
// DialogueOff ;
9087: CALL_OW 7
// ChangeMissionObjectives ( OTame ) ;
9091: LD_STRING OTame
9093: PPUSH
9094: CALL_OW 337
// end ;
9098: END
// every 0 0$1 trigger GetTech ( tech_ApeLang , 2 ) = state_researched and attackDeltaAllowed do
9099: LD_INT 1
9101: PPUSH
9102: LD_INT 2
9104: PPUSH
9105: CALL_OW 321
9109: PUSH
9110: LD_INT 2
9112: EQUAL
9113: PUSH
9114: LD_EXP 12
9118: AND
9119: IFFALSE 9192
9121: GO 9123
9123: DISABLE
// begin DialogueOn ;
9124: CALL_OW 6
// Say ( Aviradze , DA-1-ape ) ;
9128: LD_EXP 25
9132: PPUSH
9133: LD_STRING DA-1-ape
9135: PPUSH
9136: CALL_OW 88
// Say ( Heike , DH-1-ape ) ;
9140: LD_EXP 21
9144: PPUSH
9145: LD_STRING DH-1-ape
9147: PPUSH
9148: CALL_OW 88
// Say ( Aviradze , DA-2-ape ) ;
9152: LD_EXP 25
9156: PPUSH
9157: LD_STRING DA-2-ape
9159: PPUSH
9160: CALL_OW 88
// Say ( Aviradze , DA-3-ape ) ;
9164: LD_EXP 25
9168: PPUSH
9169: LD_STRING DA-3-ape
9171: PPUSH
9172: CALL_OW 88
// Say ( Heike , DH-3-ape ) ;
9176: LD_EXP 21
9180: PPUSH
9181: LD_STRING DH-3-ape
9183: PPUSH
9184: CALL_OW 88
// DialogueOff ;
9188: CALL_OW 7
// end ;
9192: END
// every 0 0$5 trigger lostCounter >= [ 3 , 2 , 2 ] [ Difficulty ] do
9193: LD_EXP 16
9197: PUSH
9198: LD_INT 3
9200: PUSH
9201: LD_INT 2
9203: PUSH
9204: LD_INT 2
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: LIST
9211: PUSH
9212: LD_OWVAR 67
9216: ARRAY
9217: GREATEREQUAL
9218: IFFALSE 9262
9220: GO 9222
9222: DISABLE
// begin DialogueOn ;
9223: CALL_OW 6
// Say ( Aviradze , DA-1-failure ) ;
9227: LD_EXP 25
9231: PPUSH
9232: LD_STRING DA-1-failure
9234: PPUSH
9235: CALL_OW 88
// Say ( Aviradze , DA-2-failure ) ;
9239: LD_EXP 25
9243: PPUSH
9244: LD_STRING DA-2-failure
9246: PPUSH
9247: CALL_OW 88
// YouLost ( Failure ) ;
9251: LD_STRING Failure
9253: PPUSH
9254: CALL_OW 104
// DialogueOff ;
9258: CALL_OW 7
// end ;
9262: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) and IsOk ( Aviradze ) and GetSide ( Aviradze ) = 2 do var tmp ;
9263: LD_INT 22
9265: PUSH
9266: LD_INT 2
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: PUSH
9273: LD_INT 23
9275: PUSH
9276: LD_INT 0
9278: PUSH
9279: EMPTY
9280: LIST
9281: LIST
9282: PUSH
9283: EMPTY
9284: LIST
9285: LIST
9286: PPUSH
9287: CALL_OW 69
9291: PUSH
9292: LD_EXP 25
9296: PPUSH
9297: CALL_OW 302
9301: AND
9302: PUSH
9303: LD_EXP 25
9307: PPUSH
9308: CALL_OW 255
9312: PUSH
9313: LD_INT 2
9315: EQUAL
9316: AND
9317: IFFALSE 10067
9319: GO 9321
9321: DISABLE
9322: LD_INT 0
9324: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) [ 1 ] ;
9325: LD_ADDR_VAR 0 1
9329: PUSH
9330: LD_INT 22
9332: PUSH
9333: LD_INT 2
9335: PUSH
9336: EMPTY
9337: LIST
9338: LIST
9339: PUSH
9340: LD_INT 23
9342: PUSH
9343: LD_INT 0
9345: PUSH
9346: EMPTY
9347: LIST
9348: LIST
9349: PUSH
9350: EMPTY
9351: LIST
9352: LIST
9353: PPUSH
9354: CALL_OW 69
9358: PUSH
9359: LD_INT 1
9361: ARRAY
9362: ST_TO_ADDR
// InGameOn ;
9363: CALL_OW 8
// CenterNowOnUnits ( tmp ) ;
9367: LD_VAR 0 1
9371: PPUSH
9372: CALL_OW 87
// ComMoveUnit ( tmp , Aviradze ) ;
9376: LD_VAR 0 1
9380: PPUSH
9381: LD_EXP 25
9385: PPUSH
9386: CALL_OW 112
// ComTurnUnit ( Aviradze , tmp ) ;
9390: LD_EXP 25
9394: PPUSH
9395: LD_VAR 0 1
9399: PPUSH
9400: CALL_OW 119
// wait ( 0 0$1 ) ;
9404: LD_INT 35
9406: PPUSH
9407: CALL_OW 67
// Say ( Aviradze , DA-1-tame-a ) ;
9411: LD_EXP 25
9415: PPUSH
9416: LD_STRING DA-1-tame-a
9418: PPUSH
9419: CALL_OW 88
// if IsOk ( Mike ) then
9423: LD_EXP 23
9427: PPUSH
9428: CALL_OW 302
9432: IFFALSE 9470
// begin Say ( Mike , DM-1-tame-a ) ;
9434: LD_EXP 23
9438: PPUSH
9439: LD_STRING DM-1-tame-a
9441: PPUSH
9442: CALL_OW 88
// Say ( Sophia , DS-1-tame-a ) ;
9446: LD_EXP 27
9450: PPUSH
9451: LD_STRING DS-1-tame-a
9453: PPUSH
9454: CALL_OW 88
// Say ( Mike , DM-2-tame-a ) ;
9458: LD_EXP 23
9462: PPUSH
9463: LD_STRING DM-2-tame-a
9465: PPUSH
9466: CALL_OW 88
// end ; wait ( 0 0$3 ) ;
9470: LD_INT 105
9472: PPUSH
9473: CALL_OW 67
// PrepareFarmer ;
9477: CALL 10726 0 0
// CenterOnUnits ( Farmer ) ;
9481: LD_EXP 29
9485: PPUSH
9486: CALL_OW 85
// ComMoveXY ( Farmer , 105 , 59 ) ;
9490: LD_EXP 29
9494: PPUSH
9495: LD_INT 105
9497: PPUSH
9498: LD_INT 59
9500: PPUSH
9501: CALL_OW 111
// AddComHold ( Farmer ) ;
9505: LD_EXP 29
9509: PPUSH
9510: CALL_OW 200
// SayRadio ( Farmer , DF-1-end ) ;
9514: LD_EXP 29
9518: PPUSH
9519: LD_STRING DF-1-end
9521: PPUSH
9522: CALL_OW 94
// Say ( Aviradze , DA-1-end ) ;
9526: LD_EXP 25
9530: PPUSH
9531: LD_STRING DA-1-end
9533: PPUSH
9534: CALL_OW 88
// SayRadio ( Farmer , DF-2-end ) ;
9538: LD_EXP 29
9542: PPUSH
9543: LD_STRING DF-2-end
9545: PPUSH
9546: CALL_OW 94
// Say ( Aviradze , DA-2-end ) ;
9550: LD_EXP 25
9554: PPUSH
9555: LD_STRING DA-2-end
9557: PPUSH
9558: CALL_OW 88
// SayRadio ( Farmer , DF-3-end ) ;
9562: LD_EXP 29
9566: PPUSH
9567: LD_STRING DF-3-end
9569: PPUSH
9570: CALL_OW 94
// Say ( Heike , DH-3-end ) ;
9574: LD_EXP 21
9578: PPUSH
9579: LD_STRING DH-3-end
9581: PPUSH
9582: CALL_OW 88
// SayRadio ( Farmer , DF-4-end ) ;
9586: LD_EXP 29
9590: PPUSH
9591: LD_STRING DF-4-end
9593: PPUSH
9594: CALL_OW 94
// if tick <= [ 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] then
9598: LD_OWVAR 1
9602: PUSH
9603: LD_INT 42000
9605: PUSH
9606: LD_INT 31500
9608: PUSH
9609: LD_INT 21000
9611: PUSH
9612: EMPTY
9613: LIST
9614: LIST
9615: LIST
9616: PUSH
9617: LD_OWVAR 67
9621: ARRAY
9622: LESSEQUAL
9623: IFFALSE 9637
// AddMedal ( med1 , 1 ) else
9625: LD_STRING med1
9627: PPUSH
9628: LD_INT 1
9630: PPUSH
9631: CALL_OW 101
9635: GO 9648
// AddMedal ( med1 , - 1 ) ;
9637: LD_STRING med1
9639: PPUSH
9640: LD_INT 1
9642: NEG
9643: PPUSH
9644: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) = 0 then
9648: LD_INT 22
9650: PUSH
9651: LD_INT 1
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PUSH
9658: LD_INT 25
9660: PUSH
9661: LD_INT 4
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: PPUSH
9672: CALL_OW 69
9676: PUSH
9677: LD_INT 0
9679: EQUAL
9680: IFFALSE 9694
// AddMedal ( med2 , 1 ) else
9682: LD_STRING med2
9684: PPUSH
9685: LD_INT 1
9687: PPUSH
9688: CALL_OW 101
9692: GO 9705
// AddMedal ( med2 , - 1 ) ;
9694: LD_STRING med2
9696: PPUSH
9697: LD_INT 1
9699: NEG
9700: PPUSH
9701: CALL_OW 101
// if trickyMove then
9705: LD_EXP 13
9709: IFFALSE 9723
// AddMedal ( med3 , 1 ) else
9711: LD_STRING med3
9713: PPUSH
9714: LD_INT 1
9716: PPUSH
9717: CALL_OW 101
9721: GO 9734
// AddMedal ( med3 , - 1 ) ;
9723: LD_STRING med3
9725: PPUSH
9726: LD_INT 1
9728: NEG
9729: PPUSH
9730: CALL_OW 101
// GiveMedals ( MAIN ) ;
9734: LD_STRING MAIN
9736: PPUSH
9737: CALL_OW 102
// SaveCharacters ( tmp , 02_ape ) ;
9741: LD_VAR 0 1
9745: PPUSH
9746: LD_STRING 02_ape
9748: PPUSH
9749: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ;
9753: LD_ADDR_VAR 0 1
9757: PUSH
9758: LD_INT 22
9760: PUSH
9761: LD_INT 2
9763: PUSH
9764: EMPTY
9765: LIST
9766: LIST
9767: PUSH
9768: LD_INT 23
9770: PUSH
9771: LD_INT 2
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PUSH
9778: LD_INT 21
9780: PUSH
9781: LD_INT 1
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PUSH
9788: EMPTY
9789: LIST
9790: LIST
9791: LIST
9792: PPUSH
9793: CALL_OW 69
9797: ST_TO_ADDR
// RewardPeople ( tmp ) ;
9798: LD_VAR 0 1
9802: PPUSH
9803: CALL_OW 43
// SaveCharacters ( Heike , 02_Heike ) ;
9807: LD_EXP 21
9811: PPUSH
9812: LD_STRING 02_Heike
9814: PPUSH
9815: CALL_OW 38
// SaveCharacters ( Aviradze , 02_Aviradze ) ;
9819: LD_EXP 25
9823: PPUSH
9824: LD_STRING 02_Aviradze
9826: PPUSH
9827: CALL_OW 38
// if Givi then
9831: LD_EXP 22
9835: IFFALSE 9849
// SaveCharacters ( Givi , 02_Givi ) ;
9837: LD_EXP 22
9841: PPUSH
9842: LD_STRING 02_Givi
9844: PPUSH
9845: CALL_OW 38
// if Mike then
9849: LD_EXP 23
9853: IFFALSE 9867
// SaveCharacters ( Mike , 02_Mike ) ;
9855: LD_EXP 23
9859: PPUSH
9860: LD_STRING 02_Mike
9862: PPUSH
9863: CALL_OW 38
// if Kamil then
9867: LD_EXP 24
9871: IFFALSE 9885
// SaveCharacters ( Kamil , 02_Kamil ) ;
9873: LD_EXP 24
9877: PPUSH
9878: LD_STRING 02_Kamil
9880: PPUSH
9881: CALL_OW 38
// if Kaia then
9885: LD_EXP 26
9889: IFFALSE 9903
// SaveCharacters ( Kaia , 02_Kaia ) ;
9891: LD_EXP 26
9895: PPUSH
9896: LD_STRING 02_Kaia
9898: PPUSH
9899: CALL_OW 38
// if Sophia then
9903: LD_EXP 27
9907: IFFALSE 9921
// SaveCharacters ( Sophia , 02_Sophia ) ;
9909: LD_EXP 27
9913: PPUSH
9914: LD_STRING 02_Sophia
9916: PPUSH
9917: CALL_OW 38
// if Markov then
9921: LD_EXP 28
9925: IFFALSE 9939
// SaveCharacters ( Markov , 02_Markov ) ;
9927: LD_EXP 28
9931: PPUSH
9932: LD_STRING 02_Markov
9934: PPUSH
9935: CALL_OW 38
// if tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] then
9939: LD_VAR 0 1
9943: PUSH
9944: LD_EXP 21
9948: PUSH
9949: LD_EXP 25
9953: PUSH
9954: LD_EXP 22
9958: PUSH
9959: LD_EXP 23
9963: PUSH
9964: LD_EXP 24
9968: PUSH
9969: LD_EXP 27
9973: PUSH
9974: LD_EXP 26
9978: PUSH
9979: LD_EXP 28
9983: PUSH
9984: EMPTY
9985: LIST
9986: LIST
9987: LIST
9988: LIST
9989: LIST
9990: LIST
9991: LIST
9992: LIST
9993: DIFF
9994: IFFALSE 10059
// SaveCharacters ( tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] , 02_others ) ;
9996: LD_VAR 0 1
10000: PUSH
10001: LD_EXP 21
10005: PUSH
10006: LD_EXP 25
10010: PUSH
10011: LD_EXP 22
10015: PUSH
10016: LD_EXP 23
10020: PUSH
10021: LD_EXP 24
10025: PUSH
10026: LD_EXP 27
10030: PUSH
10031: LD_EXP 26
10035: PUSH
10036: LD_EXP 28
10040: PUSH
10041: EMPTY
10042: LIST
10043: LIST
10044: LIST
10045: LIST
10046: LIST
10047: LIST
10048: LIST
10049: LIST
10050: DIFF
10051: PPUSH
10052: LD_STRING 02_others
10054: PPUSH
10055: CALL_OW 38
// YouWin ;
10059: CALL_OW 103
// InGameOff ;
10063: CALL_OW 9
// end ;
10067: PPOPN 1
10069: END
// every 0 0$1 trigger tick > timeUntilFarmer and aviradzeSpotted do
10070: LD_OWVAR 1
10074: PUSH
10075: LD_EXP 11
10079: GREATER
10080: PUSH
10081: LD_EXP 4
10085: AND
10086: IFFALSE 10126
10088: GO 10090
10090: DISABLE
// begin InGameOn ;
10091: CALL_OW 8
// PrepareFarmer ;
10095: CALL 10726 0 0
// CenterNowOnUnits ( Farmer ) ;
10099: LD_EXP 29
10103: PPUSH
10104: CALL_OW 87
// wait ( 0 0$2 ) ;
10108: LD_INT 70
10110: PPUSH
10111: CALL_OW 67
// YouLost ( Farmer ) ;
10115: LD_STRING Farmer
10117: PPUSH
10118: CALL_OW 104
// InGameOff ;
10122: CALL_OW 9
// end ; end_of_file
10126: END
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer ; export function PrepareArabian ; var un , veh ; begin
10127: LD_INT 0
10129: PPUSH
10130: PPUSH
10131: PPUSH
// uc_side := 2 ;
10132: LD_ADDR_OWVAR 20
10136: PUSH
10137: LD_INT 2
10139: ST_TO_ADDR
// uc_nation := 2 ;
10140: LD_ADDR_OWVAR 21
10144: PUSH
10145: LD_INT 2
10147: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
10148: LD_ADDR_EXP 21
10152: PUSH
10153: LD_STRING Heike
10155: PPUSH
10156: LD_EXP 1
10160: NOT
10161: PPUSH
10162: LD_EXP 2
10166: PPUSH
10167: CALL 221 0 3
10171: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
10172: LD_EXP 21
10176: PPUSH
10177: LD_INT 83
10179: PPUSH
10180: LD_INT 72
10182: PPUSH
10183: LD_INT 0
10185: PPUSH
10186: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
10190: LD_ADDR_EXP 22
10194: PUSH
10195: LD_STRING Givi
10197: PPUSH
10198: LD_EXP 1
10202: NOT
10203: PPUSH
10204: LD_EXP 2
10208: PPUSH
10209: CALL 221 0 3
10213: ST_TO_ADDR
// if Givi then
10214: LD_EXP 22
10218: IFFALSE 10238
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
10220: LD_EXP 22
10224: PPUSH
10225: LD_INT 87
10227: PPUSH
10228: LD_INT 76
10230: PPUSH
10231: LD_INT 0
10233: PPUSH
10234: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
10238: LD_ADDR_EXP 23
10242: PUSH
10243: LD_STRING Mike
10245: PPUSH
10246: LD_EXP 1
10250: NOT
10251: PPUSH
10252: LD_EXP 2
10256: PPUSH
10257: CALL 221 0 3
10261: ST_TO_ADDR
// if Mike then
10262: LD_EXP 23
10266: IFFALSE 10286
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
10268: LD_EXP 23
10272: PPUSH
10273: LD_INT 84
10275: PPUSH
10276: LD_INT 76
10278: PPUSH
10279: LD_INT 0
10281: PPUSH
10282: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
10286: LD_ADDR_EXP 24
10290: PUSH
10291: LD_STRING Kamil
10293: PPUSH
10294: LD_EXP 1
10298: NOT
10299: PPUSH
10300: LD_EXP 2
10304: PPUSH
10305: CALL 221 0 3
10309: ST_TO_ADDR
// if Kamil then
10310: LD_EXP 24
10314: IFFALSE 10334
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
10316: LD_EXP 24
10320: PPUSH
10321: LD_INT 85
10323: PPUSH
10324: LD_INT 78
10326: PPUSH
10327: LD_INT 0
10329: PPUSH
10330: CALL_OW 48
// uc_side := 5 ;
10334: LD_ADDR_OWVAR 20
10338: PUSH
10339: LD_INT 5
10341: ST_TO_ADDR
// uc_nation := 2 ;
10342: LD_ADDR_OWVAR 21
10346: PUSH
10347: LD_INT 2
10349: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , false ,  ) ;
10350: LD_ADDR_EXP 25
10354: PUSH
10355: LD_STRING Aviradze
10357: PPUSH
10358: LD_INT 0
10360: PPUSH
10361: LD_STRING 
10363: PPUSH
10364: CALL 221 0 3
10368: ST_TO_ADDR
// PlaceUnitXY ( Aviradze , 106 , 38 , false ) ;
10369: LD_EXP 25
10373: PPUSH
10374: LD_INT 106
10376: PPUSH
10377: LD_INT 38
10379: PPUSH
10380: LD_INT 0
10382: PPUSH
10383: CALL_OW 48
// ComTurnXY ( Aviradze , 103 , 38 ) ;
10387: LD_EXP 25
10391: PPUSH
10392: LD_INT 103
10394: PPUSH
10395: LD_INT 38
10397: PPUSH
10398: CALL_OW 118
// Kaia := PrepareUnit ( Kaia , false ,  ) ;
10402: LD_ADDR_EXP 26
10406: PUSH
10407: LD_STRING Kaia
10409: PPUSH
10410: LD_INT 0
10412: PPUSH
10413: LD_STRING 
10415: PPUSH
10416: CALL 221 0 3
10420: ST_TO_ADDR
// PlaceUnitXY ( Kaia , 100 , 34 , false ) ;
10421: LD_EXP 26
10425: PPUSH
10426: LD_INT 100
10428: PPUSH
10429: LD_INT 34
10431: PPUSH
10432: LD_INT 0
10434: PPUSH
10435: CALL_OW 48
// ComTurnXY ( Kaia , 100 , 39 ) ;
10439: LD_EXP 26
10443: PPUSH
10444: LD_INT 100
10446: PPUSH
10447: LD_INT 39
10449: PPUSH
10450: CALL_OW 118
// Sophia := PrepareUnit ( Sophia , false ,  ) ;
10454: LD_ADDR_EXP 27
10458: PUSH
10459: LD_STRING Sophia
10461: PPUSH
10462: LD_INT 0
10464: PPUSH
10465: LD_STRING 
10467: PPUSH
10468: CALL 221 0 3
10472: ST_TO_ADDR
// PlaceUnitXY ( Sophia , 109 , 50 , false ) ;
10473: LD_EXP 27
10477: PPUSH
10478: LD_INT 109
10480: PPUSH
10481: LD_INT 50
10483: PPUSH
10484: LD_INT 0
10486: PPUSH
10487: CALL_OW 48
// ComTurnXY ( Sophia , 100 , 39 ) ;
10491: LD_EXP 27
10495: PPUSH
10496: LD_INT 100
10498: PPUSH
10499: LD_INT 39
10501: PPUSH
10502: CALL_OW 118
// Markov := PrepareUnit ( Markov , false ,  ) ;
10506: LD_ADDR_EXP 28
10510: PUSH
10511: LD_STRING Markov
10513: PPUSH
10514: LD_INT 0
10516: PPUSH
10517: LD_STRING 
10519: PPUSH
10520: CALL 221 0 3
10524: ST_TO_ADDR
// PrepareTank ( 5 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , [ 90 , 70 , 60 ] [ Difficulty ] ) ;
10525: LD_INT 5
10527: PPUSH
10528: LD_INT 3
10530: PPUSH
10531: LD_INT 21
10533: PPUSH
10534: LD_INT 1
10536: PPUSH
10537: LD_INT 1
10539: PPUSH
10540: LD_INT 42
10542: PPUSH
10543: LD_INT 90
10545: PUSH
10546: LD_INT 70
10548: PUSH
10549: LD_INT 60
10551: PUSH
10552: EMPTY
10553: LIST
10554: LIST
10555: LIST
10556: PUSH
10557: LD_OWVAR 67
10561: ARRAY
10562: PPUSH
10563: CALL 284 0 7
// veh := CreateVehicle ;
10567: LD_ADDR_VAR 0 3
10571: PUSH
10572: CALL_OW 45
10576: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10577: LD_VAR 0 3
10581: PPUSH
10582: LD_INT 4
10584: PPUSH
10585: CALL_OW 233
// PlaceUnitXY ( veh , 109 , 38 , false ) ;
10589: LD_VAR 0 3
10593: PPUSH
10594: LD_INT 109
10596: PPUSH
10597: LD_INT 38
10599: PPUSH
10600: LD_INT 0
10602: PPUSH
10603: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
10607: LD_EXP 28
10611: PPUSH
10612: LD_VAR 0 3
10616: PPUSH
10617: CALL_OW 52
// ComTurnUnit ( Kaia , Aviradze ) ;
10621: LD_EXP 26
10625: PPUSH
10626: LD_EXP 25
10630: PPUSH
10631: CALL_OW 119
// ComTurnUnit ( Aviradze , Kaia ) ;
10635: LD_EXP 25
10639: PPUSH
10640: LD_EXP 26
10644: PPUSH
10645: CALL_OW 119
// if not Givi or not Mike then
10649: LD_EXP 22
10653: NOT
10654: PUSH
10655: LD_EXP 23
10659: NOT
10660: OR
10661: IFFALSE 10721
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10663: LD_INT 1
10665: PPUSH
10666: LD_INT 1
10668: PPUSH
10669: LD_INT 1
10671: PPUSH
10672: CALL_OW 380
// un := CreateHuman ;
10676: LD_ADDR_VAR 0 2
10680: PUSH
10681: CALL_OW 44
10685: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 40 , 3 , false ) ;
10686: LD_VAR 0 2
10690: PPUSH
10691: LD_INT 112
10693: PPUSH
10694: LD_INT 40
10696: PPUSH
10697: LD_INT 3
10699: PPUSH
10700: LD_INT 0
10702: PPUSH
10703: CALL_OW 50
// ComTurnUnit ( un , Aviradze ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: LD_EXP 25
10716: PPUSH
10717: CALL_OW 119
// end ; end ;
10721: LD_VAR 0 1
10725: RET
// export function PrepareFarmer ; var i ; begin
10726: LD_INT 0
10728: PPUSH
10729: PPUSH
// uc_side := 5 ;
10730: LD_ADDR_OWVAR 20
10734: PUSH
10735: LD_INT 5
10737: ST_TO_ADDR
// uc_nation := 2 ;
10738: LD_ADDR_OWVAR 21
10742: PUSH
10743: LD_INT 2
10745: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
10746: LD_ADDR_EXP 29
10750: PUSH
10751: LD_STRING Farmer
10753: PPUSH
10754: LD_INT 0
10756: PPUSH
10757: LD_STRING 
10759: PPUSH
10760: CALL 221 0 3
10764: ST_TO_ADDR
// PlaceUnitXY ( Farmer , 106 , 62 , false ) ;
10765: LD_EXP 29
10769: PPUSH
10770: LD_INT 106
10772: PPUSH
10773: LD_INT 62
10775: PPUSH
10776: LD_INT 0
10778: PPUSH
10779: CALL_OW 48
// for i := 1 to 2 do
10783: LD_ADDR_VAR 0 2
10787: PUSH
10788: DOUBLE
10789: LD_INT 1
10791: DEC
10792: ST_TO_ADDR
10793: LD_INT 2
10795: PUSH
10796: FOR_TO
10797: IFFALSE 10835
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10799: LD_INT 1
10801: PPUSH
10802: LD_INT 1
10804: PPUSH
10805: LD_INT 1
10807: PPUSH
10808: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 105 , 64 , 2 , false ) ;
10812: CALL_OW 44
10816: PPUSH
10817: LD_INT 105
10819: PPUSH
10820: LD_INT 64
10822: PPUSH
10823: LD_INT 2
10825: PPUSH
10826: LD_INT 0
10828: PPUSH
10829: CALL_OW 50
// end ;
10833: GO 10796
10835: POP
10836: POP
// end ; end_of_file
10837: LD_VAR 0 1
10841: RET
// every 2 2$20 + 0 0$10 do
10842: GO 10844
10844: DISABLE
// begin enable ;
10845: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , forest , true ) ;
10846: LD_INT 1
10848: PPUSH
10849: LD_INT 5
10851: PPUSH
10852: CALL_OW 12
10856: PPUSH
10857: LD_INT 1
10859: PPUSH
10860: LD_INT 1
10862: PPUSH
10863: CALL_OW 55
// end ; end_of_file
10867: END
// on UnitDestroyed ( un ) do begin if un = Heike then
10868: LD_VAR 0 1
10872: PUSH
10873: LD_EXP 21
10877: EQUAL
10878: IFFALSE 10887
// YouLost ( Heike ) ;
10880: LD_STRING Heike
10882: PPUSH
10883: CALL_OW 104
// if un = Aviradze then
10887: LD_VAR 0 1
10891: PUSH
10892: LD_EXP 25
10896: EQUAL
10897: IFFALSE 10906
// YouLost ( Aviradze ) ;
10899: LD_STRING Aviradze
10901: PPUSH
10902: CALL_OW 104
// if un = usLab then
10906: LD_VAR 0 1
10910: PUSH
10911: LD_INT 3
10913: EQUAL
10914: IFFALSE 10923
// YouLost ( Lab ) ;
10916: LD_STRING Lab
10918: PPUSH
10919: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) diff [ Heike , Aviradze ] and aviradzeSpotted then
10923: LD_VAR 0 1
10927: PUSH
10928: LD_INT 22
10930: PUSH
10931: LD_INT 2
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PUSH
10938: LD_INT 21
10940: PUSH
10941: LD_INT 1
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: PUSH
10948: LD_INT 23
10950: PUSH
10951: LD_INT 2
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: EMPTY
10959: LIST
10960: LIST
10961: LIST
10962: PPUSH
10963: CALL_OW 69
10967: PUSH
10968: LD_EXP 21
10972: PUSH
10973: LD_EXP 25
10977: PUSH
10978: EMPTY
10979: LIST
10980: LIST
10981: DIFF
10982: IN
10983: PUSH
10984: LD_EXP 4
10988: AND
10989: IFFALSE 11005
// lostCounter := lostCounter + 1 ;
10991: LD_ADDR_EXP 16
10995: PUSH
10996: LD_EXP 16
11000: PUSH
11001: LD_INT 1
11003: PLUS
11004: ST_TO_ADDR
// end ;
11005: PPOPN 1
11007: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un in usSci and killerSide = 2 then
11008: LD_VAR 0 1
11012: PUSH
11013: LD_EXP 20
11017: IN
11018: PUSH
11019: LD_VAR 0 2
11023: PUSH
11024: LD_INT 2
11026: EQUAL
11027: AND
11028: IFFALSE 11060
// begin usSci := usSci diff un ;
11030: LD_ADDR_EXP 20
11034: PUSH
11035: LD_EXP 20
11039: PUSH
11040: LD_VAR 0 1
11044: DIFF
11045: ST_TO_ADDR
// sciCounterKill := sciCounterKill + 1 ;
11046: LD_ADDR_EXP 8
11050: PUSH
11051: LD_EXP 8
11055: PUSH
11056: LD_INT 1
11058: PLUS
11059: ST_TO_ADDR
// end ; end ;
11060: PPOPN 3
11062: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
11063: LD_VAR 0 1
11067: PUSH
11068: LD_INT 2
11070: EQUAL
11071: PUSH
11072: LD_VAR 0 2
11076: PUSH
11077: LD_INT 5
11079: EQUAL
11080: AND
11081: IFFALSE 11090
// YouLost ( FriendlyFire ) ;
11083: LD_STRING FriendlyFire
11085: PPUSH
11086: CALL_OW 104
// end ; end_of_file
11090: PPOPN 2
11092: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
11093: GO 11095
11095: DISABLE
// begin ru_radar := 98 ;
11096: LD_ADDR_EXP 30
11100: PUSH
11101: LD_INT 98
11103: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11104: LD_ADDR_EXP 31
11108: PUSH
11109: LD_INT 89
11111: ST_TO_ADDR
// us_hack := 99 ;
11112: LD_ADDR_EXP 32
11116: PUSH
11117: LD_INT 99
11119: ST_TO_ADDR
// us_artillery := 97 ;
11120: LD_ADDR_EXP 33
11124: PUSH
11125: LD_INT 97
11127: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11128: LD_ADDR_EXP 34
11132: PUSH
11133: LD_INT 91
11135: ST_TO_ADDR
// tech_Artillery := 80 ;
11136: LD_ADDR_EXP 35
11140: PUSH
11141: LD_INT 80
11143: ST_TO_ADDR
// tech_RadMat := 81 ;
11144: LD_ADDR_EXP 36
11148: PUSH
11149: LD_INT 81
11151: ST_TO_ADDR
// tech_BasicTools := 82 ;
11152: LD_ADDR_EXP 37
11156: PUSH
11157: LD_INT 82
11159: ST_TO_ADDR
// tech_Cargo := 83 ;
11160: LD_ADDR_EXP 38
11164: PUSH
11165: LD_INT 83
11167: ST_TO_ADDR
// tech_Track := 84 ;
11168: LD_ADDR_EXP 39
11172: PUSH
11173: LD_INT 84
11175: ST_TO_ADDR
// tech_Crane := 85 ;
11176: LD_ADDR_EXP 40
11180: PUSH
11181: LD_INT 85
11183: ST_TO_ADDR
// tech_Bulldozer := 86 ;
11184: LD_ADDR_EXP 41
11188: PUSH
11189: LD_INT 86
11191: ST_TO_ADDR
// tech_Hovercraft := 87 ;
11192: LD_ADDR_EXP 42
11196: PUSH
11197: LD_INT 87
11199: ST_TO_ADDR
// end ; end_of_file end_of_file
11200: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
11201: GO 11203
11203: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11204: LD_STRING initStreamRollete();
11206: PPUSH
11207: CALL_OW 559
// InitStreamMode ;
11211: CALL 11220 0 0
// DefineStreamItems ( ) ;
11215: CALL 11660 0 0
// end ;
11219: END
// function InitStreamMode ; begin
11220: LD_INT 0
11222: PPUSH
// streamModeActive := false ;
11223: LD_ADDR_EXP 43
11227: PUSH
11228: LD_INT 0
11230: ST_TO_ADDR
// normalCounter := 36 ;
11231: LD_ADDR_EXP 44
11235: PUSH
11236: LD_INT 36
11238: ST_TO_ADDR
// hardcoreCounter := 16 ;
11239: LD_ADDR_EXP 45
11243: PUSH
11244: LD_INT 16
11246: ST_TO_ADDR
// sRocket := false ;
11247: LD_ADDR_EXP 48
11251: PUSH
11252: LD_INT 0
11254: ST_TO_ADDR
// sSpeed := false ;
11255: LD_ADDR_EXP 47
11259: PUSH
11260: LD_INT 0
11262: ST_TO_ADDR
// sEngine := false ;
11263: LD_ADDR_EXP 49
11267: PUSH
11268: LD_INT 0
11270: ST_TO_ADDR
// sSpec := false ;
11271: LD_ADDR_EXP 46
11275: PUSH
11276: LD_INT 0
11278: ST_TO_ADDR
// sLevel := false ;
11279: LD_ADDR_EXP 50
11283: PUSH
11284: LD_INT 0
11286: ST_TO_ADDR
// sArmoury := false ;
11287: LD_ADDR_EXP 51
11291: PUSH
11292: LD_INT 0
11294: ST_TO_ADDR
// sRadar := false ;
11295: LD_ADDR_EXP 52
11299: PUSH
11300: LD_INT 0
11302: ST_TO_ADDR
// sBunker := false ;
11303: LD_ADDR_EXP 53
11307: PUSH
11308: LD_INT 0
11310: ST_TO_ADDR
// sHack := false ;
11311: LD_ADDR_EXP 54
11315: PUSH
11316: LD_INT 0
11318: ST_TO_ADDR
// sFire := false ;
11319: LD_ADDR_EXP 55
11323: PUSH
11324: LD_INT 0
11326: ST_TO_ADDR
// sRefresh := false ;
11327: LD_ADDR_EXP 56
11331: PUSH
11332: LD_INT 0
11334: ST_TO_ADDR
// sExp := false ;
11335: LD_ADDR_EXP 57
11339: PUSH
11340: LD_INT 0
11342: ST_TO_ADDR
// sDepot := false ;
11343: LD_ADDR_EXP 58
11347: PUSH
11348: LD_INT 0
11350: ST_TO_ADDR
// sFlag := false ;
11351: LD_ADDR_EXP 59
11355: PUSH
11356: LD_INT 0
11358: ST_TO_ADDR
// sKamikadze := false ;
11359: LD_ADDR_EXP 67
11363: PUSH
11364: LD_INT 0
11366: ST_TO_ADDR
// sTroll := false ;
11367: LD_ADDR_EXP 68
11371: PUSH
11372: LD_INT 0
11374: ST_TO_ADDR
// sSlow := false ;
11375: LD_ADDR_EXP 69
11379: PUSH
11380: LD_INT 0
11382: ST_TO_ADDR
// sLack := false ;
11383: LD_ADDR_EXP 70
11387: PUSH
11388: LD_INT 0
11390: ST_TO_ADDR
// sTank := false ;
11391: LD_ADDR_EXP 72
11395: PUSH
11396: LD_INT 0
11398: ST_TO_ADDR
// sRemote := false ;
11399: LD_ADDR_EXP 73
11403: PUSH
11404: LD_INT 0
11406: ST_TO_ADDR
// sPowell := false ;
11407: LD_ADDR_EXP 74
11411: PUSH
11412: LD_INT 0
11414: ST_TO_ADDR
// sTeleport := false ;
11415: LD_ADDR_EXP 77
11419: PUSH
11420: LD_INT 0
11422: ST_TO_ADDR
// sOilTower := false ;
11423: LD_ADDR_EXP 79
11427: PUSH
11428: LD_INT 0
11430: ST_TO_ADDR
// sShovel := false ;
11431: LD_ADDR_EXP 80
11435: PUSH
11436: LD_INT 0
11438: ST_TO_ADDR
// sSheik := false ;
11439: LD_ADDR_EXP 81
11443: PUSH
11444: LD_INT 0
11446: ST_TO_ADDR
// sEarthquake := false ;
11447: LD_ADDR_EXP 83
11451: PUSH
11452: LD_INT 0
11454: ST_TO_ADDR
// sAI := false ;
11455: LD_ADDR_EXP 84
11459: PUSH
11460: LD_INT 0
11462: ST_TO_ADDR
// sCargo := false ;
11463: LD_ADDR_EXP 87
11467: PUSH
11468: LD_INT 0
11470: ST_TO_ADDR
// sDLaser := false ;
11471: LD_ADDR_EXP 88
11475: PUSH
11476: LD_INT 0
11478: ST_TO_ADDR
// sExchange := false ;
11479: LD_ADDR_EXP 89
11483: PUSH
11484: LD_INT 0
11486: ST_TO_ADDR
// sFac := false ;
11487: LD_ADDR_EXP 90
11491: PUSH
11492: LD_INT 0
11494: ST_TO_ADDR
// sPower := false ;
11495: LD_ADDR_EXP 91
11499: PUSH
11500: LD_INT 0
11502: ST_TO_ADDR
// sRandom := false ;
11503: LD_ADDR_EXP 92
11507: PUSH
11508: LD_INT 0
11510: ST_TO_ADDR
// sShield := false ;
11511: LD_ADDR_EXP 93
11515: PUSH
11516: LD_INT 0
11518: ST_TO_ADDR
// sTime := false ;
11519: LD_ADDR_EXP 94
11523: PUSH
11524: LD_INT 0
11526: ST_TO_ADDR
// sTools := false ;
11527: LD_ADDR_EXP 95
11531: PUSH
11532: LD_INT 0
11534: ST_TO_ADDR
// sSold := false ;
11535: LD_ADDR_EXP 60
11539: PUSH
11540: LD_INT 0
11542: ST_TO_ADDR
// sDiff := false ;
11543: LD_ADDR_EXP 61
11547: PUSH
11548: LD_INT 0
11550: ST_TO_ADDR
// sFog := false ;
11551: LD_ADDR_EXP 64
11555: PUSH
11556: LD_INT 0
11558: ST_TO_ADDR
// sReset := false ;
11559: LD_ADDR_EXP 65
11563: PUSH
11564: LD_INT 0
11566: ST_TO_ADDR
// sSun := false ;
11567: LD_ADDR_EXP 66
11571: PUSH
11572: LD_INT 0
11574: ST_TO_ADDR
// sTiger := false ;
11575: LD_ADDR_EXP 62
11579: PUSH
11580: LD_INT 0
11582: ST_TO_ADDR
// sBomb := false ;
11583: LD_ADDR_EXP 63
11587: PUSH
11588: LD_INT 0
11590: ST_TO_ADDR
// sWound := false ;
11591: LD_ADDR_EXP 71
11595: PUSH
11596: LD_INT 0
11598: ST_TO_ADDR
// sBetray := false ;
11599: LD_ADDR_EXP 75
11603: PUSH
11604: LD_INT 0
11606: ST_TO_ADDR
// sContamin := false ;
11607: LD_ADDR_EXP 76
11611: PUSH
11612: LD_INT 0
11614: ST_TO_ADDR
// sOil := false ;
11615: LD_ADDR_EXP 78
11619: PUSH
11620: LD_INT 0
11622: ST_TO_ADDR
// sStu := false ;
11623: LD_ADDR_EXP 82
11627: PUSH
11628: LD_INT 0
11630: ST_TO_ADDR
// sBazooka := false ;
11631: LD_ADDR_EXP 85
11635: PUSH
11636: LD_INT 0
11638: ST_TO_ADDR
// sMortar := false ;
11639: LD_ADDR_EXP 86
11643: PUSH
11644: LD_INT 0
11646: ST_TO_ADDR
// sRanger := false ;
11647: LD_ADDR_EXP 96
11651: PUSH
11652: LD_INT 0
11654: ST_TO_ADDR
// end ;
11655: LD_VAR 0 1
11659: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11660: LD_INT 0
11662: PPUSH
11663: PPUSH
11664: PPUSH
11665: PPUSH
11666: PPUSH
// result := [ ] ;
11667: LD_ADDR_VAR 0 1
11671: PUSH
11672: EMPTY
11673: ST_TO_ADDR
// if campaign_id = 1 then
11674: LD_OWVAR 69
11678: PUSH
11679: LD_INT 1
11681: EQUAL
11682: IFFALSE 14620
// begin case mission_number of 1 :
11684: LD_OWVAR 70
11688: PUSH
11689: LD_INT 1
11691: DOUBLE
11692: EQUAL
11693: IFTRUE 11697
11695: GO 11761
11697: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11698: LD_ADDR_VAR 0 1
11702: PUSH
11703: LD_INT 2
11705: PUSH
11706: LD_INT 4
11708: PUSH
11709: LD_INT 11
11711: PUSH
11712: LD_INT 12
11714: PUSH
11715: LD_INT 15
11717: PUSH
11718: LD_INT 16
11720: PUSH
11721: LD_INT 22
11723: PUSH
11724: LD_INT 23
11726: PUSH
11727: LD_INT 26
11729: PUSH
11730: EMPTY
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: PUSH
11741: LD_INT 101
11743: PUSH
11744: LD_INT 102
11746: PUSH
11747: LD_INT 106
11749: PUSH
11750: EMPTY
11751: LIST
11752: LIST
11753: LIST
11754: PUSH
11755: EMPTY
11756: LIST
11757: LIST
11758: ST_TO_ADDR
11759: GO 14618
11761: LD_INT 2
11763: DOUBLE
11764: EQUAL
11765: IFTRUE 11769
11767: GO 11841
11769: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11770: LD_ADDR_VAR 0 1
11774: PUSH
11775: LD_INT 2
11777: PUSH
11778: LD_INT 4
11780: PUSH
11781: LD_INT 11
11783: PUSH
11784: LD_INT 12
11786: PUSH
11787: LD_INT 15
11789: PUSH
11790: LD_INT 16
11792: PUSH
11793: LD_INT 22
11795: PUSH
11796: LD_INT 23
11798: PUSH
11799: LD_INT 26
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: PUSH
11813: LD_INT 101
11815: PUSH
11816: LD_INT 102
11818: PUSH
11819: LD_INT 105
11821: PUSH
11822: LD_INT 106
11824: PUSH
11825: LD_INT 108
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: ST_TO_ADDR
11839: GO 14618
11841: LD_INT 3
11843: DOUBLE
11844: EQUAL
11845: IFTRUE 11849
11847: GO 11925
11849: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11850: LD_ADDR_VAR 0 1
11854: PUSH
11855: LD_INT 2
11857: PUSH
11858: LD_INT 4
11860: PUSH
11861: LD_INT 5
11863: PUSH
11864: LD_INT 11
11866: PUSH
11867: LD_INT 12
11869: PUSH
11870: LD_INT 15
11872: PUSH
11873: LD_INT 16
11875: PUSH
11876: LD_INT 22
11878: PUSH
11879: LD_INT 26
11881: PUSH
11882: LD_INT 36
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: LIST
11889: LIST
11890: LIST
11891: LIST
11892: LIST
11893: LIST
11894: LIST
11895: LIST
11896: PUSH
11897: LD_INT 101
11899: PUSH
11900: LD_INT 102
11902: PUSH
11903: LD_INT 105
11905: PUSH
11906: LD_INT 106
11908: PUSH
11909: LD_INT 108
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: LIST
11916: LIST
11917: LIST
11918: PUSH
11919: EMPTY
11920: LIST
11921: LIST
11922: ST_TO_ADDR
11923: GO 14618
11925: LD_INT 4
11927: DOUBLE
11928: EQUAL
11929: IFTRUE 11933
11931: GO 12017
11933: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11934: LD_ADDR_VAR 0 1
11938: PUSH
11939: LD_INT 2
11941: PUSH
11942: LD_INT 4
11944: PUSH
11945: LD_INT 5
11947: PUSH
11948: LD_INT 8
11950: PUSH
11951: LD_INT 11
11953: PUSH
11954: LD_INT 12
11956: PUSH
11957: LD_INT 15
11959: PUSH
11960: LD_INT 16
11962: PUSH
11963: LD_INT 22
11965: PUSH
11966: LD_INT 23
11968: PUSH
11969: LD_INT 26
11971: PUSH
11972: LD_INT 36
11974: PUSH
11975: EMPTY
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: LIST
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: PUSH
11989: LD_INT 101
11991: PUSH
11992: LD_INT 102
11994: PUSH
11995: LD_INT 105
11997: PUSH
11998: LD_INT 106
12000: PUSH
12001: LD_INT 108
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: PUSH
12011: EMPTY
12012: LIST
12013: LIST
12014: ST_TO_ADDR
12015: GO 14618
12017: LD_INT 5
12019: DOUBLE
12020: EQUAL
12021: IFTRUE 12025
12023: GO 12125
12025: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
12026: LD_ADDR_VAR 0 1
12030: PUSH
12031: LD_INT 2
12033: PUSH
12034: LD_INT 4
12036: PUSH
12037: LD_INT 5
12039: PUSH
12040: LD_INT 6
12042: PUSH
12043: LD_INT 8
12045: PUSH
12046: LD_INT 11
12048: PUSH
12049: LD_INT 12
12051: PUSH
12052: LD_INT 15
12054: PUSH
12055: LD_INT 16
12057: PUSH
12058: LD_INT 22
12060: PUSH
12061: LD_INT 23
12063: PUSH
12064: LD_INT 25
12066: PUSH
12067: LD_INT 26
12069: PUSH
12070: LD_INT 36
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: LIST
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: PUSH
12089: LD_INT 101
12091: PUSH
12092: LD_INT 102
12094: PUSH
12095: LD_INT 105
12097: PUSH
12098: LD_INT 106
12100: PUSH
12101: LD_INT 108
12103: PUSH
12104: LD_INT 109
12106: PUSH
12107: LD_INT 112
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: LIST
12114: LIST
12115: LIST
12116: LIST
12117: LIST
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: ST_TO_ADDR
12123: GO 14618
12125: LD_INT 6
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12253
12133: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
12134: LD_ADDR_VAR 0 1
12138: PUSH
12139: LD_INT 2
12141: PUSH
12142: LD_INT 4
12144: PUSH
12145: LD_INT 5
12147: PUSH
12148: LD_INT 6
12150: PUSH
12151: LD_INT 8
12153: PUSH
12154: LD_INT 11
12156: PUSH
12157: LD_INT 12
12159: PUSH
12160: LD_INT 15
12162: PUSH
12163: LD_INT 16
12165: PUSH
12166: LD_INT 20
12168: PUSH
12169: LD_INT 21
12171: PUSH
12172: LD_INT 22
12174: PUSH
12175: LD_INT 23
12177: PUSH
12178: LD_INT 25
12180: PUSH
12181: LD_INT 26
12183: PUSH
12184: LD_INT 30
12186: PUSH
12187: LD_INT 31
12189: PUSH
12190: LD_INT 32
12192: PUSH
12193: LD_INT 36
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: LIST
12200: LIST
12201: LIST
12202: LIST
12203: LIST
12204: LIST
12205: LIST
12206: LIST
12207: LIST
12208: LIST
12209: LIST
12210: LIST
12211: LIST
12212: LIST
12213: LIST
12214: LIST
12215: LIST
12216: PUSH
12217: LD_INT 101
12219: PUSH
12220: LD_INT 102
12222: PUSH
12223: LD_INT 105
12225: PUSH
12226: LD_INT 106
12228: PUSH
12229: LD_INT 108
12231: PUSH
12232: LD_INT 109
12234: PUSH
12235: LD_INT 112
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: LIST
12242: LIST
12243: LIST
12244: LIST
12245: LIST
12246: PUSH
12247: EMPTY
12248: LIST
12249: LIST
12250: ST_TO_ADDR
12251: GO 14618
12253: LD_INT 7
12255: DOUBLE
12256: EQUAL
12257: IFTRUE 12261
12259: GO 12361
12261: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12262: LD_ADDR_VAR 0 1
12266: PUSH
12267: LD_INT 2
12269: PUSH
12270: LD_INT 4
12272: PUSH
12273: LD_INT 5
12275: PUSH
12276: LD_INT 7
12278: PUSH
12279: LD_INT 11
12281: PUSH
12282: LD_INT 12
12284: PUSH
12285: LD_INT 15
12287: PUSH
12288: LD_INT 16
12290: PUSH
12291: LD_INT 20
12293: PUSH
12294: LD_INT 21
12296: PUSH
12297: LD_INT 22
12299: PUSH
12300: LD_INT 23
12302: PUSH
12303: LD_INT 25
12305: PUSH
12306: LD_INT 26
12308: PUSH
12309: EMPTY
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: PUSH
12325: LD_INT 101
12327: PUSH
12328: LD_INT 102
12330: PUSH
12331: LD_INT 103
12333: PUSH
12334: LD_INT 105
12336: PUSH
12337: LD_INT 106
12339: PUSH
12340: LD_INT 108
12342: PUSH
12343: LD_INT 112
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: LIST
12354: PUSH
12355: EMPTY
12356: LIST
12357: LIST
12358: ST_TO_ADDR
12359: GO 14618
12361: LD_INT 8
12363: DOUBLE
12364: EQUAL
12365: IFTRUE 12369
12367: GO 12497
12369: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12370: LD_ADDR_VAR 0 1
12374: PUSH
12375: LD_INT 2
12377: PUSH
12378: LD_INT 4
12380: PUSH
12381: LD_INT 5
12383: PUSH
12384: LD_INT 6
12386: PUSH
12387: LD_INT 7
12389: PUSH
12390: LD_INT 8
12392: PUSH
12393: LD_INT 11
12395: PUSH
12396: LD_INT 12
12398: PUSH
12399: LD_INT 15
12401: PUSH
12402: LD_INT 16
12404: PUSH
12405: LD_INT 20
12407: PUSH
12408: LD_INT 21
12410: PUSH
12411: LD_INT 22
12413: PUSH
12414: LD_INT 23
12416: PUSH
12417: LD_INT 25
12419: PUSH
12420: LD_INT 26
12422: PUSH
12423: LD_INT 30
12425: PUSH
12426: LD_INT 31
12428: PUSH
12429: LD_INT 32
12431: PUSH
12432: LD_INT 36
12434: PUSH
12435: EMPTY
12436: LIST
12437: LIST
12438: LIST
12439: LIST
12440: LIST
12441: LIST
12442: LIST
12443: LIST
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: LIST
12456: PUSH
12457: LD_INT 101
12459: PUSH
12460: LD_INT 102
12462: PUSH
12463: LD_INT 103
12465: PUSH
12466: LD_INT 105
12468: PUSH
12469: LD_INT 106
12471: PUSH
12472: LD_INT 108
12474: PUSH
12475: LD_INT 109
12477: PUSH
12478: LD_INT 112
12480: PUSH
12481: EMPTY
12482: LIST
12483: LIST
12484: LIST
12485: LIST
12486: LIST
12487: LIST
12488: LIST
12489: LIST
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: ST_TO_ADDR
12495: GO 14618
12497: LD_INT 9
12499: DOUBLE
12500: EQUAL
12501: IFTRUE 12505
12503: GO 12641
12505: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12506: LD_ADDR_VAR 0 1
12510: PUSH
12511: LD_INT 2
12513: PUSH
12514: LD_INT 4
12516: PUSH
12517: LD_INT 5
12519: PUSH
12520: LD_INT 6
12522: PUSH
12523: LD_INT 7
12525: PUSH
12526: LD_INT 8
12528: PUSH
12529: LD_INT 11
12531: PUSH
12532: LD_INT 12
12534: PUSH
12535: LD_INT 15
12537: PUSH
12538: LD_INT 16
12540: PUSH
12541: LD_INT 20
12543: PUSH
12544: LD_INT 21
12546: PUSH
12547: LD_INT 22
12549: PUSH
12550: LD_INT 23
12552: PUSH
12553: LD_INT 25
12555: PUSH
12556: LD_INT 26
12558: PUSH
12559: LD_INT 28
12561: PUSH
12562: LD_INT 30
12564: PUSH
12565: LD_INT 31
12567: PUSH
12568: LD_INT 32
12570: PUSH
12571: LD_INT 36
12573: PUSH
12574: EMPTY
12575: LIST
12576: LIST
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: LIST
12590: LIST
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: PUSH
12597: LD_INT 101
12599: PUSH
12600: LD_INT 102
12602: PUSH
12603: LD_INT 103
12605: PUSH
12606: LD_INT 105
12608: PUSH
12609: LD_INT 106
12611: PUSH
12612: LD_INT 108
12614: PUSH
12615: LD_INT 109
12617: PUSH
12618: LD_INT 112
12620: PUSH
12621: LD_INT 114
12623: PUSH
12624: EMPTY
12625: LIST
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: LIST
12632: LIST
12633: LIST
12634: PUSH
12635: EMPTY
12636: LIST
12637: LIST
12638: ST_TO_ADDR
12639: GO 14618
12641: LD_INT 10
12643: DOUBLE
12644: EQUAL
12645: IFTRUE 12649
12647: GO 12833
12649: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12650: LD_ADDR_VAR 0 1
12654: PUSH
12655: LD_INT 2
12657: PUSH
12658: LD_INT 4
12660: PUSH
12661: LD_INT 5
12663: PUSH
12664: LD_INT 6
12666: PUSH
12667: LD_INT 7
12669: PUSH
12670: LD_INT 8
12672: PUSH
12673: LD_INT 9
12675: PUSH
12676: LD_INT 10
12678: PUSH
12679: LD_INT 11
12681: PUSH
12682: LD_INT 12
12684: PUSH
12685: LD_INT 13
12687: PUSH
12688: LD_INT 14
12690: PUSH
12691: LD_INT 15
12693: PUSH
12694: LD_INT 16
12696: PUSH
12697: LD_INT 17
12699: PUSH
12700: LD_INT 18
12702: PUSH
12703: LD_INT 19
12705: PUSH
12706: LD_INT 20
12708: PUSH
12709: LD_INT 21
12711: PUSH
12712: LD_INT 22
12714: PUSH
12715: LD_INT 23
12717: PUSH
12718: LD_INT 24
12720: PUSH
12721: LD_INT 25
12723: PUSH
12724: LD_INT 26
12726: PUSH
12727: LD_INT 28
12729: PUSH
12730: LD_INT 30
12732: PUSH
12733: LD_INT 31
12735: PUSH
12736: LD_INT 32
12738: PUSH
12739: LD_INT 36
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: LIST
12750: LIST
12751: LIST
12752: LIST
12753: LIST
12754: LIST
12755: LIST
12756: LIST
12757: LIST
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: LIST
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: PUSH
12773: LD_INT 101
12775: PUSH
12776: LD_INT 102
12778: PUSH
12779: LD_INT 103
12781: PUSH
12782: LD_INT 104
12784: PUSH
12785: LD_INT 105
12787: PUSH
12788: LD_INT 106
12790: PUSH
12791: LD_INT 107
12793: PUSH
12794: LD_INT 108
12796: PUSH
12797: LD_INT 109
12799: PUSH
12800: LD_INT 110
12802: PUSH
12803: LD_INT 111
12805: PUSH
12806: LD_INT 112
12808: PUSH
12809: LD_INT 114
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: ST_TO_ADDR
12831: GO 14618
12833: LD_INT 11
12835: DOUBLE
12836: EQUAL
12837: IFTRUE 12841
12839: GO 13033
12841: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12842: LD_ADDR_VAR 0 1
12846: PUSH
12847: LD_INT 2
12849: PUSH
12850: LD_INT 3
12852: PUSH
12853: LD_INT 4
12855: PUSH
12856: LD_INT 5
12858: PUSH
12859: LD_INT 6
12861: PUSH
12862: LD_INT 7
12864: PUSH
12865: LD_INT 8
12867: PUSH
12868: LD_INT 9
12870: PUSH
12871: LD_INT 10
12873: PUSH
12874: LD_INT 11
12876: PUSH
12877: LD_INT 12
12879: PUSH
12880: LD_INT 13
12882: PUSH
12883: LD_INT 14
12885: PUSH
12886: LD_INT 15
12888: PUSH
12889: LD_INT 16
12891: PUSH
12892: LD_INT 17
12894: PUSH
12895: LD_INT 18
12897: PUSH
12898: LD_INT 19
12900: PUSH
12901: LD_INT 20
12903: PUSH
12904: LD_INT 21
12906: PUSH
12907: LD_INT 22
12909: PUSH
12910: LD_INT 23
12912: PUSH
12913: LD_INT 24
12915: PUSH
12916: LD_INT 25
12918: PUSH
12919: LD_INT 26
12921: PUSH
12922: LD_INT 28
12924: PUSH
12925: LD_INT 30
12927: PUSH
12928: LD_INT 31
12930: PUSH
12931: LD_INT 32
12933: PUSH
12934: LD_INT 34
12936: PUSH
12937: LD_INT 36
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: LIST
12953: LIST
12954: LIST
12955: LIST
12956: LIST
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PUSH
12973: LD_INT 101
12975: PUSH
12976: LD_INT 102
12978: PUSH
12979: LD_INT 103
12981: PUSH
12982: LD_INT 104
12984: PUSH
12985: LD_INT 105
12987: PUSH
12988: LD_INT 106
12990: PUSH
12991: LD_INT 107
12993: PUSH
12994: LD_INT 108
12996: PUSH
12997: LD_INT 109
12999: PUSH
13000: LD_INT 110
13002: PUSH
13003: LD_INT 111
13005: PUSH
13006: LD_INT 112
13008: PUSH
13009: LD_INT 114
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: LIST
13020: LIST
13021: LIST
13022: LIST
13023: LIST
13024: LIST
13025: LIST
13026: PUSH
13027: EMPTY
13028: LIST
13029: LIST
13030: ST_TO_ADDR
13031: GO 14618
13033: LD_INT 12
13035: DOUBLE
13036: EQUAL
13037: IFTRUE 13041
13039: GO 13249
13041: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
13042: LD_ADDR_VAR 0 1
13046: PUSH
13047: LD_INT 1
13049: PUSH
13050: LD_INT 2
13052: PUSH
13053: LD_INT 3
13055: PUSH
13056: LD_INT 4
13058: PUSH
13059: LD_INT 5
13061: PUSH
13062: LD_INT 6
13064: PUSH
13065: LD_INT 7
13067: PUSH
13068: LD_INT 8
13070: PUSH
13071: LD_INT 9
13073: PUSH
13074: LD_INT 10
13076: PUSH
13077: LD_INT 11
13079: PUSH
13080: LD_INT 12
13082: PUSH
13083: LD_INT 13
13085: PUSH
13086: LD_INT 14
13088: PUSH
13089: LD_INT 15
13091: PUSH
13092: LD_INT 16
13094: PUSH
13095: LD_INT 17
13097: PUSH
13098: LD_INT 18
13100: PUSH
13101: LD_INT 19
13103: PUSH
13104: LD_INT 20
13106: PUSH
13107: LD_INT 21
13109: PUSH
13110: LD_INT 22
13112: PUSH
13113: LD_INT 23
13115: PUSH
13116: LD_INT 24
13118: PUSH
13119: LD_INT 25
13121: PUSH
13122: LD_INT 26
13124: PUSH
13125: LD_INT 27
13127: PUSH
13128: LD_INT 28
13130: PUSH
13131: LD_INT 30
13133: PUSH
13134: LD_INT 31
13136: PUSH
13137: LD_INT 32
13139: PUSH
13140: LD_INT 33
13142: PUSH
13143: LD_INT 34
13145: PUSH
13146: LD_INT 36
13148: PUSH
13149: EMPTY
13150: LIST
13151: LIST
13152: LIST
13153: LIST
13154: LIST
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: PUSH
13185: LD_INT 101
13187: PUSH
13188: LD_INT 102
13190: PUSH
13191: LD_INT 103
13193: PUSH
13194: LD_INT 104
13196: PUSH
13197: LD_INT 105
13199: PUSH
13200: LD_INT 106
13202: PUSH
13203: LD_INT 107
13205: PUSH
13206: LD_INT 108
13208: PUSH
13209: LD_INT 109
13211: PUSH
13212: LD_INT 110
13214: PUSH
13215: LD_INT 111
13217: PUSH
13218: LD_INT 112
13220: PUSH
13221: LD_INT 113
13223: PUSH
13224: LD_INT 114
13226: PUSH
13227: EMPTY
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: PUSH
13243: EMPTY
13244: LIST
13245: LIST
13246: ST_TO_ADDR
13247: GO 14618
13249: LD_INT 13
13251: DOUBLE
13252: EQUAL
13253: IFTRUE 13257
13255: GO 13453
13257: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13258: LD_ADDR_VAR 0 1
13262: PUSH
13263: LD_INT 1
13265: PUSH
13266: LD_INT 2
13268: PUSH
13269: LD_INT 3
13271: PUSH
13272: LD_INT 4
13274: PUSH
13275: LD_INT 5
13277: PUSH
13278: LD_INT 8
13280: PUSH
13281: LD_INT 9
13283: PUSH
13284: LD_INT 10
13286: PUSH
13287: LD_INT 11
13289: PUSH
13290: LD_INT 12
13292: PUSH
13293: LD_INT 14
13295: PUSH
13296: LD_INT 15
13298: PUSH
13299: LD_INT 16
13301: PUSH
13302: LD_INT 17
13304: PUSH
13305: LD_INT 18
13307: PUSH
13308: LD_INT 19
13310: PUSH
13311: LD_INT 20
13313: PUSH
13314: LD_INT 21
13316: PUSH
13317: LD_INT 22
13319: PUSH
13320: LD_INT 23
13322: PUSH
13323: LD_INT 24
13325: PUSH
13326: LD_INT 25
13328: PUSH
13329: LD_INT 26
13331: PUSH
13332: LD_INT 27
13334: PUSH
13335: LD_INT 28
13337: PUSH
13338: LD_INT 30
13340: PUSH
13341: LD_INT 31
13343: PUSH
13344: LD_INT 32
13346: PUSH
13347: LD_INT 33
13349: PUSH
13350: LD_INT 34
13352: PUSH
13353: LD_INT 36
13355: PUSH
13356: EMPTY
13357: LIST
13358: LIST
13359: LIST
13360: LIST
13361: LIST
13362: LIST
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: PUSH
13389: LD_INT 101
13391: PUSH
13392: LD_INT 102
13394: PUSH
13395: LD_INT 103
13397: PUSH
13398: LD_INT 104
13400: PUSH
13401: LD_INT 105
13403: PUSH
13404: LD_INT 106
13406: PUSH
13407: LD_INT 107
13409: PUSH
13410: LD_INT 108
13412: PUSH
13413: LD_INT 109
13415: PUSH
13416: LD_INT 110
13418: PUSH
13419: LD_INT 111
13421: PUSH
13422: LD_INT 112
13424: PUSH
13425: LD_INT 113
13427: PUSH
13428: LD_INT 114
13430: PUSH
13431: EMPTY
13432: LIST
13433: LIST
13434: LIST
13435: LIST
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: ST_TO_ADDR
13451: GO 14618
13453: LD_INT 14
13455: DOUBLE
13456: EQUAL
13457: IFTRUE 13461
13459: GO 13673
13461: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13462: LD_ADDR_VAR 0 1
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: LD_INT 2
13472: PUSH
13473: LD_INT 3
13475: PUSH
13476: LD_INT 4
13478: PUSH
13479: LD_INT 5
13481: PUSH
13482: LD_INT 6
13484: PUSH
13485: LD_INT 7
13487: PUSH
13488: LD_INT 8
13490: PUSH
13491: LD_INT 9
13493: PUSH
13494: LD_INT 10
13496: PUSH
13497: LD_INT 11
13499: PUSH
13500: LD_INT 12
13502: PUSH
13503: LD_INT 13
13505: PUSH
13506: LD_INT 14
13508: PUSH
13509: LD_INT 15
13511: PUSH
13512: LD_INT 16
13514: PUSH
13515: LD_INT 17
13517: PUSH
13518: LD_INT 18
13520: PUSH
13521: LD_INT 19
13523: PUSH
13524: LD_INT 20
13526: PUSH
13527: LD_INT 21
13529: PUSH
13530: LD_INT 22
13532: PUSH
13533: LD_INT 23
13535: PUSH
13536: LD_INT 24
13538: PUSH
13539: LD_INT 25
13541: PUSH
13542: LD_INT 26
13544: PUSH
13545: LD_INT 27
13547: PUSH
13548: LD_INT 28
13550: PUSH
13551: LD_INT 29
13553: PUSH
13554: LD_INT 30
13556: PUSH
13557: LD_INT 31
13559: PUSH
13560: LD_INT 32
13562: PUSH
13563: LD_INT 33
13565: PUSH
13566: LD_INT 34
13568: PUSH
13569: LD_INT 36
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: LIST
13602: LIST
13603: LIST
13604: LIST
13605: LIST
13606: LIST
13607: LIST
13608: PUSH
13609: LD_INT 101
13611: PUSH
13612: LD_INT 102
13614: PUSH
13615: LD_INT 103
13617: PUSH
13618: LD_INT 104
13620: PUSH
13621: LD_INT 105
13623: PUSH
13624: LD_INT 106
13626: PUSH
13627: LD_INT 107
13629: PUSH
13630: LD_INT 108
13632: PUSH
13633: LD_INT 109
13635: PUSH
13636: LD_INT 110
13638: PUSH
13639: LD_INT 111
13641: PUSH
13642: LD_INT 112
13644: PUSH
13645: LD_INT 113
13647: PUSH
13648: LD_INT 114
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: LIST
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: LIST
13662: LIST
13663: LIST
13664: LIST
13665: LIST
13666: PUSH
13667: EMPTY
13668: LIST
13669: LIST
13670: ST_TO_ADDR
13671: GO 14618
13673: LD_INT 15
13675: DOUBLE
13676: EQUAL
13677: IFTRUE 13681
13679: GO 13893
13681: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13682: LD_ADDR_VAR 0 1
13686: PUSH
13687: LD_INT 1
13689: PUSH
13690: LD_INT 2
13692: PUSH
13693: LD_INT 3
13695: PUSH
13696: LD_INT 4
13698: PUSH
13699: LD_INT 5
13701: PUSH
13702: LD_INT 6
13704: PUSH
13705: LD_INT 7
13707: PUSH
13708: LD_INT 8
13710: PUSH
13711: LD_INT 9
13713: PUSH
13714: LD_INT 10
13716: PUSH
13717: LD_INT 11
13719: PUSH
13720: LD_INT 12
13722: PUSH
13723: LD_INT 13
13725: PUSH
13726: LD_INT 14
13728: PUSH
13729: LD_INT 15
13731: PUSH
13732: LD_INT 16
13734: PUSH
13735: LD_INT 17
13737: PUSH
13738: LD_INT 18
13740: PUSH
13741: LD_INT 19
13743: PUSH
13744: LD_INT 20
13746: PUSH
13747: LD_INT 21
13749: PUSH
13750: LD_INT 22
13752: PUSH
13753: LD_INT 23
13755: PUSH
13756: LD_INT 24
13758: PUSH
13759: LD_INT 25
13761: PUSH
13762: LD_INT 26
13764: PUSH
13765: LD_INT 27
13767: PUSH
13768: LD_INT 28
13770: PUSH
13771: LD_INT 29
13773: PUSH
13774: LD_INT 30
13776: PUSH
13777: LD_INT 31
13779: PUSH
13780: LD_INT 32
13782: PUSH
13783: LD_INT 33
13785: PUSH
13786: LD_INT 34
13788: PUSH
13789: LD_INT 36
13791: PUSH
13792: EMPTY
13793: LIST
13794: LIST
13795: LIST
13796: LIST
13797: LIST
13798: LIST
13799: LIST
13800: LIST
13801: LIST
13802: LIST
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: LIST
13808: LIST
13809: LIST
13810: LIST
13811: LIST
13812: LIST
13813: LIST
13814: LIST
13815: LIST
13816: LIST
13817: LIST
13818: LIST
13819: LIST
13820: LIST
13821: LIST
13822: LIST
13823: LIST
13824: LIST
13825: LIST
13826: LIST
13827: LIST
13828: PUSH
13829: LD_INT 101
13831: PUSH
13832: LD_INT 102
13834: PUSH
13835: LD_INT 103
13837: PUSH
13838: LD_INT 104
13840: PUSH
13841: LD_INT 105
13843: PUSH
13844: LD_INT 106
13846: PUSH
13847: LD_INT 107
13849: PUSH
13850: LD_INT 108
13852: PUSH
13853: LD_INT 109
13855: PUSH
13856: LD_INT 110
13858: PUSH
13859: LD_INT 111
13861: PUSH
13862: LD_INT 112
13864: PUSH
13865: LD_INT 113
13867: PUSH
13868: LD_INT 114
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: PUSH
13887: EMPTY
13888: LIST
13889: LIST
13890: ST_TO_ADDR
13891: GO 14618
13893: LD_INT 16
13895: DOUBLE
13896: EQUAL
13897: IFTRUE 13901
13899: GO 14025
13901: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13902: LD_ADDR_VAR 0 1
13906: PUSH
13907: LD_INT 2
13909: PUSH
13910: LD_INT 4
13912: PUSH
13913: LD_INT 5
13915: PUSH
13916: LD_INT 7
13918: PUSH
13919: LD_INT 11
13921: PUSH
13922: LD_INT 12
13924: PUSH
13925: LD_INT 15
13927: PUSH
13928: LD_INT 16
13930: PUSH
13931: LD_INT 20
13933: PUSH
13934: LD_INT 21
13936: PUSH
13937: LD_INT 22
13939: PUSH
13940: LD_INT 23
13942: PUSH
13943: LD_INT 25
13945: PUSH
13946: LD_INT 26
13948: PUSH
13949: LD_INT 30
13951: PUSH
13952: LD_INT 31
13954: PUSH
13955: LD_INT 32
13957: PUSH
13958: LD_INT 33
13960: PUSH
13961: LD_INT 34
13963: PUSH
13964: EMPTY
13965: LIST
13966: LIST
13967: LIST
13968: LIST
13969: LIST
13970: LIST
13971: LIST
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: LIST
13983: LIST
13984: PUSH
13985: LD_INT 101
13987: PUSH
13988: LD_INT 102
13990: PUSH
13991: LD_INT 103
13993: PUSH
13994: LD_INT 106
13996: PUSH
13997: LD_INT 108
13999: PUSH
14000: LD_INT 112
14002: PUSH
14003: LD_INT 113
14005: PUSH
14006: LD_INT 114
14008: PUSH
14009: EMPTY
14010: LIST
14011: LIST
14012: LIST
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: LIST
14018: PUSH
14019: EMPTY
14020: LIST
14021: LIST
14022: ST_TO_ADDR
14023: GO 14618
14025: LD_INT 17
14027: DOUBLE
14028: EQUAL
14029: IFTRUE 14033
14031: GO 14245
14033: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
14034: LD_ADDR_VAR 0 1
14038: PUSH
14039: LD_INT 1
14041: PUSH
14042: LD_INT 2
14044: PUSH
14045: LD_INT 3
14047: PUSH
14048: LD_INT 4
14050: PUSH
14051: LD_INT 5
14053: PUSH
14054: LD_INT 6
14056: PUSH
14057: LD_INT 7
14059: PUSH
14060: LD_INT 8
14062: PUSH
14063: LD_INT 9
14065: PUSH
14066: LD_INT 10
14068: PUSH
14069: LD_INT 11
14071: PUSH
14072: LD_INT 12
14074: PUSH
14075: LD_INT 13
14077: PUSH
14078: LD_INT 14
14080: PUSH
14081: LD_INT 15
14083: PUSH
14084: LD_INT 16
14086: PUSH
14087: LD_INT 17
14089: PUSH
14090: LD_INT 18
14092: PUSH
14093: LD_INT 19
14095: PUSH
14096: LD_INT 20
14098: PUSH
14099: LD_INT 21
14101: PUSH
14102: LD_INT 22
14104: PUSH
14105: LD_INT 23
14107: PUSH
14108: LD_INT 24
14110: PUSH
14111: LD_INT 25
14113: PUSH
14114: LD_INT 26
14116: PUSH
14117: LD_INT 27
14119: PUSH
14120: LD_INT 28
14122: PUSH
14123: LD_INT 29
14125: PUSH
14126: LD_INT 30
14128: PUSH
14129: LD_INT 31
14131: PUSH
14132: LD_INT 32
14134: PUSH
14135: LD_INT 33
14137: PUSH
14138: LD_INT 34
14140: PUSH
14141: LD_INT 36
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: LIST
14180: PUSH
14181: LD_INT 101
14183: PUSH
14184: LD_INT 102
14186: PUSH
14187: LD_INT 103
14189: PUSH
14190: LD_INT 104
14192: PUSH
14193: LD_INT 105
14195: PUSH
14196: LD_INT 106
14198: PUSH
14199: LD_INT 107
14201: PUSH
14202: LD_INT 108
14204: PUSH
14205: LD_INT 109
14207: PUSH
14208: LD_INT 110
14210: PUSH
14211: LD_INT 111
14213: PUSH
14214: LD_INT 112
14216: PUSH
14217: LD_INT 113
14219: PUSH
14220: LD_INT 114
14222: PUSH
14223: EMPTY
14224: LIST
14225: LIST
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: PUSH
14239: EMPTY
14240: LIST
14241: LIST
14242: ST_TO_ADDR
14243: GO 14618
14245: LD_INT 18
14247: DOUBLE
14248: EQUAL
14249: IFTRUE 14253
14251: GO 14389
14253: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14254: LD_ADDR_VAR 0 1
14258: PUSH
14259: LD_INT 2
14261: PUSH
14262: LD_INT 4
14264: PUSH
14265: LD_INT 5
14267: PUSH
14268: LD_INT 7
14270: PUSH
14271: LD_INT 11
14273: PUSH
14274: LD_INT 12
14276: PUSH
14277: LD_INT 15
14279: PUSH
14280: LD_INT 16
14282: PUSH
14283: LD_INT 20
14285: PUSH
14286: LD_INT 21
14288: PUSH
14289: LD_INT 22
14291: PUSH
14292: LD_INT 23
14294: PUSH
14295: LD_INT 25
14297: PUSH
14298: LD_INT 26
14300: PUSH
14301: LD_INT 30
14303: PUSH
14304: LD_INT 31
14306: PUSH
14307: LD_INT 32
14309: PUSH
14310: LD_INT 33
14312: PUSH
14313: LD_INT 34
14315: PUSH
14316: LD_INT 35
14318: PUSH
14319: LD_INT 36
14321: PUSH
14322: EMPTY
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: PUSH
14345: LD_INT 101
14347: PUSH
14348: LD_INT 102
14350: PUSH
14351: LD_INT 103
14353: PUSH
14354: LD_INT 106
14356: PUSH
14357: LD_INT 108
14359: PUSH
14360: LD_INT 112
14362: PUSH
14363: LD_INT 113
14365: PUSH
14366: LD_INT 114
14368: PUSH
14369: LD_INT 115
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: ST_TO_ADDR
14387: GO 14618
14389: LD_INT 19
14391: DOUBLE
14392: EQUAL
14393: IFTRUE 14397
14395: GO 14617
14397: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14398: LD_ADDR_VAR 0 1
14402: PUSH
14403: LD_INT 1
14405: PUSH
14406: LD_INT 2
14408: PUSH
14409: LD_INT 3
14411: PUSH
14412: LD_INT 4
14414: PUSH
14415: LD_INT 5
14417: PUSH
14418: LD_INT 6
14420: PUSH
14421: LD_INT 7
14423: PUSH
14424: LD_INT 8
14426: PUSH
14427: LD_INT 9
14429: PUSH
14430: LD_INT 10
14432: PUSH
14433: LD_INT 11
14435: PUSH
14436: LD_INT 12
14438: PUSH
14439: LD_INT 13
14441: PUSH
14442: LD_INT 14
14444: PUSH
14445: LD_INT 15
14447: PUSH
14448: LD_INT 16
14450: PUSH
14451: LD_INT 17
14453: PUSH
14454: LD_INT 18
14456: PUSH
14457: LD_INT 19
14459: PUSH
14460: LD_INT 20
14462: PUSH
14463: LD_INT 21
14465: PUSH
14466: LD_INT 22
14468: PUSH
14469: LD_INT 23
14471: PUSH
14472: LD_INT 24
14474: PUSH
14475: LD_INT 25
14477: PUSH
14478: LD_INT 26
14480: PUSH
14481: LD_INT 27
14483: PUSH
14484: LD_INT 28
14486: PUSH
14487: LD_INT 29
14489: PUSH
14490: LD_INT 30
14492: PUSH
14493: LD_INT 31
14495: PUSH
14496: LD_INT 32
14498: PUSH
14499: LD_INT 33
14501: PUSH
14502: LD_INT 34
14504: PUSH
14505: LD_INT 35
14507: PUSH
14508: LD_INT 36
14510: PUSH
14511: EMPTY
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: PUSH
14549: LD_INT 101
14551: PUSH
14552: LD_INT 102
14554: PUSH
14555: LD_INT 103
14557: PUSH
14558: LD_INT 104
14560: PUSH
14561: LD_INT 105
14563: PUSH
14564: LD_INT 106
14566: PUSH
14567: LD_INT 107
14569: PUSH
14570: LD_INT 108
14572: PUSH
14573: LD_INT 109
14575: PUSH
14576: LD_INT 110
14578: PUSH
14579: LD_INT 111
14581: PUSH
14582: LD_INT 112
14584: PUSH
14585: LD_INT 113
14587: PUSH
14588: LD_INT 114
14590: PUSH
14591: LD_INT 115
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: LIST
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: ST_TO_ADDR
14615: GO 14618
14617: POP
// end else
14618: GO 14837
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
14620: LD_ADDR_VAR 0 1
14624: PUSH
14625: LD_INT 1
14627: PUSH
14628: LD_INT 2
14630: PUSH
14631: LD_INT 3
14633: PUSH
14634: LD_INT 4
14636: PUSH
14637: LD_INT 5
14639: PUSH
14640: LD_INT 6
14642: PUSH
14643: LD_INT 7
14645: PUSH
14646: LD_INT 8
14648: PUSH
14649: LD_INT 9
14651: PUSH
14652: LD_INT 10
14654: PUSH
14655: LD_INT 11
14657: PUSH
14658: LD_INT 12
14660: PUSH
14661: LD_INT 13
14663: PUSH
14664: LD_INT 14
14666: PUSH
14667: LD_INT 15
14669: PUSH
14670: LD_INT 16
14672: PUSH
14673: LD_INT 17
14675: PUSH
14676: LD_INT 18
14678: PUSH
14679: LD_INT 19
14681: PUSH
14682: LD_INT 20
14684: PUSH
14685: LD_INT 21
14687: PUSH
14688: LD_INT 22
14690: PUSH
14691: LD_INT 23
14693: PUSH
14694: LD_INT 24
14696: PUSH
14697: LD_INT 25
14699: PUSH
14700: LD_INT 26
14702: PUSH
14703: LD_INT 27
14705: PUSH
14706: LD_INT 28
14708: PUSH
14709: LD_INT 29
14711: PUSH
14712: LD_INT 30
14714: PUSH
14715: LD_INT 31
14717: PUSH
14718: LD_INT 32
14720: PUSH
14721: LD_INT 33
14723: PUSH
14724: LD_INT 34
14726: PUSH
14727: LD_INT 35
14729: PUSH
14730: LD_INT 36
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: LIST
14739: LIST
14740: LIST
14741: LIST
14742: LIST
14743: LIST
14744: LIST
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: LIST
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: LIST
14756: LIST
14757: LIST
14758: LIST
14759: LIST
14760: LIST
14761: LIST
14762: LIST
14763: LIST
14764: LIST
14765: LIST
14766: LIST
14767: LIST
14768: LIST
14769: LIST
14770: PUSH
14771: LD_INT 101
14773: PUSH
14774: LD_INT 102
14776: PUSH
14777: LD_INT 103
14779: PUSH
14780: LD_INT 104
14782: PUSH
14783: LD_INT 105
14785: PUSH
14786: LD_INT 106
14788: PUSH
14789: LD_INT 107
14791: PUSH
14792: LD_INT 108
14794: PUSH
14795: LD_INT 109
14797: PUSH
14798: LD_INT 110
14800: PUSH
14801: LD_INT 111
14803: PUSH
14804: LD_INT 112
14806: PUSH
14807: LD_INT 113
14809: PUSH
14810: LD_INT 114
14812: PUSH
14813: LD_INT 115
14815: PUSH
14816: EMPTY
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: LIST
14830: LIST
14831: LIST
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: ST_TO_ADDR
// if result then
14837: LD_VAR 0 1
14841: IFFALSE 15130
// begin normal :=  ;
14843: LD_ADDR_VAR 0 3
14847: PUSH
14848: LD_STRING 
14850: ST_TO_ADDR
// hardcore :=  ;
14851: LD_ADDR_VAR 0 4
14855: PUSH
14856: LD_STRING 
14858: ST_TO_ADDR
// for i = 1 to normalCounter do
14859: LD_ADDR_VAR 0 5
14863: PUSH
14864: DOUBLE
14865: LD_INT 1
14867: DEC
14868: ST_TO_ADDR
14869: LD_EXP 44
14873: PUSH
14874: FOR_TO
14875: IFFALSE 14976
// begin tmp := 0 ;
14877: LD_ADDR_VAR 0 2
14881: PUSH
14882: LD_STRING 0
14884: ST_TO_ADDR
// if result [ 1 ] then
14885: LD_VAR 0 1
14889: PUSH
14890: LD_INT 1
14892: ARRAY
14893: IFFALSE 14958
// if result [ 1 ] [ 1 ] = i then
14895: LD_VAR 0 1
14899: PUSH
14900: LD_INT 1
14902: ARRAY
14903: PUSH
14904: LD_INT 1
14906: ARRAY
14907: PUSH
14908: LD_VAR 0 5
14912: EQUAL
14913: IFFALSE 14958
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
14915: LD_ADDR_VAR 0 1
14919: PUSH
14920: LD_VAR 0 1
14924: PPUSH
14925: LD_INT 1
14927: PPUSH
14928: LD_VAR 0 1
14932: PUSH
14933: LD_INT 1
14935: ARRAY
14936: PPUSH
14937: LD_INT 1
14939: PPUSH
14940: CALL_OW 3
14944: PPUSH
14945: CALL_OW 1
14949: ST_TO_ADDR
// tmp := 1 ;
14950: LD_ADDR_VAR 0 2
14954: PUSH
14955: LD_STRING 1
14957: ST_TO_ADDR
// end ; normal := normal & tmp ;
14958: LD_ADDR_VAR 0 3
14962: PUSH
14963: LD_VAR 0 3
14967: PUSH
14968: LD_VAR 0 2
14972: STR
14973: ST_TO_ADDR
// end ;
14974: GO 14874
14976: POP
14977: POP
// for i = 1 to hardcoreCounter do
14978: LD_ADDR_VAR 0 5
14982: PUSH
14983: DOUBLE
14984: LD_INT 1
14986: DEC
14987: ST_TO_ADDR
14988: LD_EXP 45
14992: PUSH
14993: FOR_TO
14994: IFFALSE 15099
// begin tmp := 0 ;
14996: LD_ADDR_VAR 0 2
15000: PUSH
15001: LD_STRING 0
15003: ST_TO_ADDR
// if result [ 2 ] then
15004: LD_VAR 0 1
15008: PUSH
15009: LD_INT 2
15011: ARRAY
15012: IFFALSE 15081
// if result [ 2 ] [ 1 ] = 100 + i then
15014: LD_VAR 0 1
15018: PUSH
15019: LD_INT 2
15021: ARRAY
15022: PUSH
15023: LD_INT 1
15025: ARRAY
15026: PUSH
15027: LD_INT 100
15029: PUSH
15030: LD_VAR 0 5
15034: PLUS
15035: EQUAL
15036: IFFALSE 15081
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
15038: LD_ADDR_VAR 0 1
15042: PUSH
15043: LD_VAR 0 1
15047: PPUSH
15048: LD_INT 2
15050: PPUSH
15051: LD_VAR 0 1
15055: PUSH
15056: LD_INT 2
15058: ARRAY
15059: PPUSH
15060: LD_INT 1
15062: PPUSH
15063: CALL_OW 3
15067: PPUSH
15068: CALL_OW 1
15072: ST_TO_ADDR
// tmp := 1 ;
15073: LD_ADDR_VAR 0 2
15077: PUSH
15078: LD_STRING 1
15080: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
15081: LD_ADDR_VAR 0 4
15085: PUSH
15086: LD_VAR 0 4
15090: PUSH
15091: LD_VAR 0 2
15095: STR
15096: ST_TO_ADDR
// end ;
15097: GO 14993
15099: POP
15100: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
15101: LD_STRING getStreamItemsFromMission("
15103: PUSH
15104: LD_VAR 0 3
15108: STR
15109: PUSH
15110: LD_STRING ","
15112: STR
15113: PUSH
15114: LD_VAR 0 4
15118: STR
15119: PUSH
15120: LD_STRING ")
15122: STR
15123: PPUSH
15124: CALL_OW 559
// end else
15128: GO 15137
// ToLua ( getStreamItemsFromMission("","") ) ;
15130: LD_STRING getStreamItemsFromMission("","")
15132: PPUSH
15133: CALL_OW 559
// end ;
15137: LD_VAR 0 1
15141: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
15142: LD_VAR 0 2
15146: PUSH
15147: LD_INT 100
15149: EQUAL
15150: IFFALSE 16099
// begin if not StreamModeActive then
15152: LD_EXP 43
15156: NOT
15157: IFFALSE 15167
// StreamModeActive := true ;
15159: LD_ADDR_EXP 43
15163: PUSH
15164: LD_INT 1
15166: ST_TO_ADDR
// if p3 = 0 then
15167: LD_VAR 0 3
15171: PUSH
15172: LD_INT 0
15174: EQUAL
15175: IFFALSE 15181
// InitStreamMode ;
15177: CALL 11220 0 0
// if p3 = 1 then
15181: LD_VAR 0 3
15185: PUSH
15186: LD_INT 1
15188: EQUAL
15189: IFFALSE 15199
// sRocket := true ;
15191: LD_ADDR_EXP 48
15195: PUSH
15196: LD_INT 1
15198: ST_TO_ADDR
// if p3 = 2 then
15199: LD_VAR 0 3
15203: PUSH
15204: LD_INT 2
15206: EQUAL
15207: IFFALSE 15217
// sSpeed := true ;
15209: LD_ADDR_EXP 47
15213: PUSH
15214: LD_INT 1
15216: ST_TO_ADDR
// if p3 = 3 then
15217: LD_VAR 0 3
15221: PUSH
15222: LD_INT 3
15224: EQUAL
15225: IFFALSE 15235
// sEngine := true ;
15227: LD_ADDR_EXP 49
15231: PUSH
15232: LD_INT 1
15234: ST_TO_ADDR
// if p3 = 4 then
15235: LD_VAR 0 3
15239: PUSH
15240: LD_INT 4
15242: EQUAL
15243: IFFALSE 15253
// sSpec := true ;
15245: LD_ADDR_EXP 46
15249: PUSH
15250: LD_INT 1
15252: ST_TO_ADDR
// if p3 = 5 then
15253: LD_VAR 0 3
15257: PUSH
15258: LD_INT 5
15260: EQUAL
15261: IFFALSE 15271
// sLevel := true ;
15263: LD_ADDR_EXP 50
15267: PUSH
15268: LD_INT 1
15270: ST_TO_ADDR
// if p3 = 6 then
15271: LD_VAR 0 3
15275: PUSH
15276: LD_INT 6
15278: EQUAL
15279: IFFALSE 15289
// sArmoury := true ;
15281: LD_ADDR_EXP 51
15285: PUSH
15286: LD_INT 1
15288: ST_TO_ADDR
// if p3 = 7 then
15289: LD_VAR 0 3
15293: PUSH
15294: LD_INT 7
15296: EQUAL
15297: IFFALSE 15307
// sRadar := true ;
15299: LD_ADDR_EXP 52
15303: PUSH
15304: LD_INT 1
15306: ST_TO_ADDR
// if p3 = 8 then
15307: LD_VAR 0 3
15311: PUSH
15312: LD_INT 8
15314: EQUAL
15315: IFFALSE 15325
// sBunker := true ;
15317: LD_ADDR_EXP 53
15321: PUSH
15322: LD_INT 1
15324: ST_TO_ADDR
// if p3 = 9 then
15325: LD_VAR 0 3
15329: PUSH
15330: LD_INT 9
15332: EQUAL
15333: IFFALSE 15343
// sHack := true ;
15335: LD_ADDR_EXP 54
15339: PUSH
15340: LD_INT 1
15342: ST_TO_ADDR
// if p3 = 10 then
15343: LD_VAR 0 3
15347: PUSH
15348: LD_INT 10
15350: EQUAL
15351: IFFALSE 15361
// sFire := true ;
15353: LD_ADDR_EXP 55
15357: PUSH
15358: LD_INT 1
15360: ST_TO_ADDR
// if p3 = 11 then
15361: LD_VAR 0 3
15365: PUSH
15366: LD_INT 11
15368: EQUAL
15369: IFFALSE 15379
// sRefresh := true ;
15371: LD_ADDR_EXP 56
15375: PUSH
15376: LD_INT 1
15378: ST_TO_ADDR
// if p3 = 12 then
15379: LD_VAR 0 3
15383: PUSH
15384: LD_INT 12
15386: EQUAL
15387: IFFALSE 15397
// sExp := true ;
15389: LD_ADDR_EXP 57
15393: PUSH
15394: LD_INT 1
15396: ST_TO_ADDR
// if p3 = 13 then
15397: LD_VAR 0 3
15401: PUSH
15402: LD_INT 13
15404: EQUAL
15405: IFFALSE 15415
// sDepot := true ;
15407: LD_ADDR_EXP 58
15411: PUSH
15412: LD_INT 1
15414: ST_TO_ADDR
// if p3 = 14 then
15415: LD_VAR 0 3
15419: PUSH
15420: LD_INT 14
15422: EQUAL
15423: IFFALSE 15433
// sFlag := true ;
15425: LD_ADDR_EXP 59
15429: PUSH
15430: LD_INT 1
15432: ST_TO_ADDR
// if p3 = 15 then
15433: LD_VAR 0 3
15437: PUSH
15438: LD_INT 15
15440: EQUAL
15441: IFFALSE 15451
// sKamikadze := true ;
15443: LD_ADDR_EXP 67
15447: PUSH
15448: LD_INT 1
15450: ST_TO_ADDR
// if p3 = 16 then
15451: LD_VAR 0 3
15455: PUSH
15456: LD_INT 16
15458: EQUAL
15459: IFFALSE 15469
// sTroll := true ;
15461: LD_ADDR_EXP 68
15465: PUSH
15466: LD_INT 1
15468: ST_TO_ADDR
// if p3 = 17 then
15469: LD_VAR 0 3
15473: PUSH
15474: LD_INT 17
15476: EQUAL
15477: IFFALSE 15487
// sSlow := true ;
15479: LD_ADDR_EXP 69
15483: PUSH
15484: LD_INT 1
15486: ST_TO_ADDR
// if p3 = 18 then
15487: LD_VAR 0 3
15491: PUSH
15492: LD_INT 18
15494: EQUAL
15495: IFFALSE 15505
// sLack := true ;
15497: LD_ADDR_EXP 70
15501: PUSH
15502: LD_INT 1
15504: ST_TO_ADDR
// if p3 = 19 then
15505: LD_VAR 0 3
15509: PUSH
15510: LD_INT 19
15512: EQUAL
15513: IFFALSE 15523
// sTank := true ;
15515: LD_ADDR_EXP 72
15519: PUSH
15520: LD_INT 1
15522: ST_TO_ADDR
// if p3 = 20 then
15523: LD_VAR 0 3
15527: PUSH
15528: LD_INT 20
15530: EQUAL
15531: IFFALSE 15541
// sRemote := true ;
15533: LD_ADDR_EXP 73
15537: PUSH
15538: LD_INT 1
15540: ST_TO_ADDR
// if p3 = 21 then
15541: LD_VAR 0 3
15545: PUSH
15546: LD_INT 21
15548: EQUAL
15549: IFFALSE 15559
// sPowell := true ;
15551: LD_ADDR_EXP 74
15555: PUSH
15556: LD_INT 1
15558: ST_TO_ADDR
// if p3 = 22 then
15559: LD_VAR 0 3
15563: PUSH
15564: LD_INT 22
15566: EQUAL
15567: IFFALSE 15577
// sTeleport := true ;
15569: LD_ADDR_EXP 77
15573: PUSH
15574: LD_INT 1
15576: ST_TO_ADDR
// if p3 = 23 then
15577: LD_VAR 0 3
15581: PUSH
15582: LD_INT 23
15584: EQUAL
15585: IFFALSE 15595
// sOilTower := true ;
15587: LD_ADDR_EXP 79
15591: PUSH
15592: LD_INT 1
15594: ST_TO_ADDR
// if p3 = 24 then
15595: LD_VAR 0 3
15599: PUSH
15600: LD_INT 24
15602: EQUAL
15603: IFFALSE 15613
// sShovel := true ;
15605: LD_ADDR_EXP 80
15609: PUSH
15610: LD_INT 1
15612: ST_TO_ADDR
// if p3 = 25 then
15613: LD_VAR 0 3
15617: PUSH
15618: LD_INT 25
15620: EQUAL
15621: IFFALSE 15631
// sSheik := true ;
15623: LD_ADDR_EXP 81
15627: PUSH
15628: LD_INT 1
15630: ST_TO_ADDR
// if p3 = 26 then
15631: LD_VAR 0 3
15635: PUSH
15636: LD_INT 26
15638: EQUAL
15639: IFFALSE 15649
// sEarthquake := true ;
15641: LD_ADDR_EXP 83
15645: PUSH
15646: LD_INT 1
15648: ST_TO_ADDR
// if p3 = 27 then
15649: LD_VAR 0 3
15653: PUSH
15654: LD_INT 27
15656: EQUAL
15657: IFFALSE 15667
// sAI := true ;
15659: LD_ADDR_EXP 84
15663: PUSH
15664: LD_INT 1
15666: ST_TO_ADDR
// if p3 = 28 then
15667: LD_VAR 0 3
15671: PUSH
15672: LD_INT 28
15674: EQUAL
15675: IFFALSE 15685
// sCargo := true ;
15677: LD_ADDR_EXP 87
15681: PUSH
15682: LD_INT 1
15684: ST_TO_ADDR
// if p3 = 29 then
15685: LD_VAR 0 3
15689: PUSH
15690: LD_INT 29
15692: EQUAL
15693: IFFALSE 15703
// sDLaser := true ;
15695: LD_ADDR_EXP 88
15699: PUSH
15700: LD_INT 1
15702: ST_TO_ADDR
// if p3 = 30 then
15703: LD_VAR 0 3
15707: PUSH
15708: LD_INT 30
15710: EQUAL
15711: IFFALSE 15721
// sExchange := true ;
15713: LD_ADDR_EXP 89
15717: PUSH
15718: LD_INT 1
15720: ST_TO_ADDR
// if p3 = 31 then
15721: LD_VAR 0 3
15725: PUSH
15726: LD_INT 31
15728: EQUAL
15729: IFFALSE 15739
// sFac := true ;
15731: LD_ADDR_EXP 90
15735: PUSH
15736: LD_INT 1
15738: ST_TO_ADDR
// if p3 = 32 then
15739: LD_VAR 0 3
15743: PUSH
15744: LD_INT 32
15746: EQUAL
15747: IFFALSE 15757
// sPower := true ;
15749: LD_ADDR_EXP 91
15753: PUSH
15754: LD_INT 1
15756: ST_TO_ADDR
// if p3 = 33 then
15757: LD_VAR 0 3
15761: PUSH
15762: LD_INT 33
15764: EQUAL
15765: IFFALSE 15775
// sRandom := true ;
15767: LD_ADDR_EXP 92
15771: PUSH
15772: LD_INT 1
15774: ST_TO_ADDR
// if p3 = 34 then
15775: LD_VAR 0 3
15779: PUSH
15780: LD_INT 34
15782: EQUAL
15783: IFFALSE 15793
// sShield := true ;
15785: LD_ADDR_EXP 93
15789: PUSH
15790: LD_INT 1
15792: ST_TO_ADDR
// if p3 = 35 then
15793: LD_VAR 0 3
15797: PUSH
15798: LD_INT 35
15800: EQUAL
15801: IFFALSE 15811
// sTime := true ;
15803: LD_ADDR_EXP 94
15807: PUSH
15808: LD_INT 1
15810: ST_TO_ADDR
// if p3 = 36 then
15811: LD_VAR 0 3
15815: PUSH
15816: LD_INT 36
15818: EQUAL
15819: IFFALSE 15829
// sTools := true ;
15821: LD_ADDR_EXP 95
15825: PUSH
15826: LD_INT 1
15828: ST_TO_ADDR
// if p3 = 101 then
15829: LD_VAR 0 3
15833: PUSH
15834: LD_INT 101
15836: EQUAL
15837: IFFALSE 15847
// sSold := true ;
15839: LD_ADDR_EXP 60
15843: PUSH
15844: LD_INT 1
15846: ST_TO_ADDR
// if p3 = 102 then
15847: LD_VAR 0 3
15851: PUSH
15852: LD_INT 102
15854: EQUAL
15855: IFFALSE 15865
// sDiff := true ;
15857: LD_ADDR_EXP 61
15861: PUSH
15862: LD_INT 1
15864: ST_TO_ADDR
// if p3 = 103 then
15865: LD_VAR 0 3
15869: PUSH
15870: LD_INT 103
15872: EQUAL
15873: IFFALSE 15883
// sFog := true ;
15875: LD_ADDR_EXP 64
15879: PUSH
15880: LD_INT 1
15882: ST_TO_ADDR
// if p3 = 104 then
15883: LD_VAR 0 3
15887: PUSH
15888: LD_INT 104
15890: EQUAL
15891: IFFALSE 15901
// sReset := true ;
15893: LD_ADDR_EXP 65
15897: PUSH
15898: LD_INT 1
15900: ST_TO_ADDR
// if p3 = 105 then
15901: LD_VAR 0 3
15905: PUSH
15906: LD_INT 105
15908: EQUAL
15909: IFFALSE 15919
// sSun := true ;
15911: LD_ADDR_EXP 66
15915: PUSH
15916: LD_INT 1
15918: ST_TO_ADDR
// if p3 = 106 then
15919: LD_VAR 0 3
15923: PUSH
15924: LD_INT 106
15926: EQUAL
15927: IFFALSE 15937
// sTiger := true ;
15929: LD_ADDR_EXP 62
15933: PUSH
15934: LD_INT 1
15936: ST_TO_ADDR
// if p3 = 107 then
15937: LD_VAR 0 3
15941: PUSH
15942: LD_INT 107
15944: EQUAL
15945: IFFALSE 15955
// sBomb := true ;
15947: LD_ADDR_EXP 63
15951: PUSH
15952: LD_INT 1
15954: ST_TO_ADDR
// if p3 = 108 then
15955: LD_VAR 0 3
15959: PUSH
15960: LD_INT 108
15962: EQUAL
15963: IFFALSE 15973
// sWound := true ;
15965: LD_ADDR_EXP 71
15969: PUSH
15970: LD_INT 1
15972: ST_TO_ADDR
// if p3 = 109 then
15973: LD_VAR 0 3
15977: PUSH
15978: LD_INT 109
15980: EQUAL
15981: IFFALSE 15991
// sBetray := true ;
15983: LD_ADDR_EXP 75
15987: PUSH
15988: LD_INT 1
15990: ST_TO_ADDR
// if p3 = 110 then
15991: LD_VAR 0 3
15995: PUSH
15996: LD_INT 110
15998: EQUAL
15999: IFFALSE 16009
// sContamin := true ;
16001: LD_ADDR_EXP 76
16005: PUSH
16006: LD_INT 1
16008: ST_TO_ADDR
// if p3 = 111 then
16009: LD_VAR 0 3
16013: PUSH
16014: LD_INT 111
16016: EQUAL
16017: IFFALSE 16027
// sOil := true ;
16019: LD_ADDR_EXP 78
16023: PUSH
16024: LD_INT 1
16026: ST_TO_ADDR
// if p3 = 112 then
16027: LD_VAR 0 3
16031: PUSH
16032: LD_INT 112
16034: EQUAL
16035: IFFALSE 16045
// sStu := true ;
16037: LD_ADDR_EXP 82
16041: PUSH
16042: LD_INT 1
16044: ST_TO_ADDR
// if p3 = 113 then
16045: LD_VAR 0 3
16049: PUSH
16050: LD_INT 113
16052: EQUAL
16053: IFFALSE 16063
// sBazooka := true ;
16055: LD_ADDR_EXP 85
16059: PUSH
16060: LD_INT 1
16062: ST_TO_ADDR
// if p3 = 114 then
16063: LD_VAR 0 3
16067: PUSH
16068: LD_INT 114
16070: EQUAL
16071: IFFALSE 16081
// sMortar := true ;
16073: LD_ADDR_EXP 86
16077: PUSH
16078: LD_INT 1
16080: ST_TO_ADDR
// if p3 = 115 then
16081: LD_VAR 0 3
16085: PUSH
16086: LD_INT 115
16088: EQUAL
16089: IFFALSE 16099
// sRanger := true ;
16091: LD_ADDR_EXP 96
16095: PUSH
16096: LD_INT 1
16098: ST_TO_ADDR
// end ; end ;
16099: PPOPN 6
16101: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
16102: LD_EXP 43
16106: PUSH
16107: LD_EXP 48
16111: AND
16112: IFFALSE 16236
16114: GO 16116
16116: DISABLE
16117: LD_INT 0
16119: PPUSH
16120: PPUSH
// begin enable ;
16121: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
16122: LD_ADDR_VAR 0 2
16126: PUSH
16127: LD_INT 22
16129: PUSH
16130: LD_OWVAR 2
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: PUSH
16139: LD_INT 2
16141: PUSH
16142: LD_INT 34
16144: PUSH
16145: LD_INT 7
16147: PUSH
16148: EMPTY
16149: LIST
16150: LIST
16151: PUSH
16152: LD_INT 34
16154: PUSH
16155: LD_INT 45
16157: PUSH
16158: EMPTY
16159: LIST
16160: LIST
16161: PUSH
16162: LD_INT 34
16164: PUSH
16165: LD_INT 28
16167: PUSH
16168: EMPTY
16169: LIST
16170: LIST
16171: PUSH
16172: LD_INT 34
16174: PUSH
16175: LD_INT 47
16177: PUSH
16178: EMPTY
16179: LIST
16180: LIST
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: LIST
16186: LIST
16187: LIST
16188: PUSH
16189: EMPTY
16190: LIST
16191: LIST
16192: PPUSH
16193: CALL_OW 69
16197: ST_TO_ADDR
// if not tmp then
16198: LD_VAR 0 2
16202: NOT
16203: IFFALSE 16207
// exit ;
16205: GO 16236
// for i in tmp do
16207: LD_ADDR_VAR 0 1
16211: PUSH
16212: LD_VAR 0 2
16216: PUSH
16217: FOR_IN
16218: IFFALSE 16234
// begin SetLives ( i , 0 ) ;
16220: LD_VAR 0 1
16224: PPUSH
16225: LD_INT 0
16227: PPUSH
16228: CALL_OW 234
// end ;
16232: GO 16217
16234: POP
16235: POP
// end ;
16236: PPOPN 2
16238: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
16239: LD_EXP 43
16243: PUSH
16244: LD_EXP 49
16248: AND
16249: IFFALSE 16333
16251: GO 16253
16253: DISABLE
16254: LD_INT 0
16256: PPUSH
16257: PPUSH
// begin enable ;
16258: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
16259: LD_ADDR_VAR 0 2
16263: PUSH
16264: LD_INT 22
16266: PUSH
16267: LD_OWVAR 2
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PUSH
16276: LD_INT 32
16278: PUSH
16279: LD_INT 3
16281: PUSH
16282: EMPTY
16283: LIST
16284: LIST
16285: PUSH
16286: EMPTY
16287: LIST
16288: LIST
16289: PPUSH
16290: CALL_OW 69
16294: ST_TO_ADDR
// if not tmp then
16295: LD_VAR 0 2
16299: NOT
16300: IFFALSE 16304
// exit ;
16302: GO 16333
// for i in tmp do
16304: LD_ADDR_VAR 0 1
16308: PUSH
16309: LD_VAR 0 2
16313: PUSH
16314: FOR_IN
16315: IFFALSE 16331
// begin SetLives ( i , 0 ) ;
16317: LD_VAR 0 1
16321: PPUSH
16322: LD_INT 0
16324: PPUSH
16325: CALL_OW 234
// end ;
16329: GO 16314
16331: POP
16332: POP
// end ;
16333: PPOPN 2
16335: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
16336: LD_EXP 43
16340: PUSH
16341: LD_EXP 46
16345: AND
16346: IFFALSE 16439
16348: GO 16350
16350: DISABLE
16351: LD_INT 0
16353: PPUSH
// begin enable ;
16354: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
16355: LD_ADDR_VAR 0 1
16359: PUSH
16360: LD_INT 22
16362: PUSH
16363: LD_OWVAR 2
16367: PUSH
16368: EMPTY
16369: LIST
16370: LIST
16371: PUSH
16372: LD_INT 2
16374: PUSH
16375: LD_INT 25
16377: PUSH
16378: LD_INT 5
16380: PUSH
16381: EMPTY
16382: LIST
16383: LIST
16384: PUSH
16385: LD_INT 25
16387: PUSH
16388: LD_INT 9
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PUSH
16395: LD_INT 25
16397: PUSH
16398: LD_INT 8
16400: PUSH
16401: EMPTY
16402: LIST
16403: LIST
16404: PUSH
16405: EMPTY
16406: LIST
16407: LIST
16408: LIST
16409: LIST
16410: PUSH
16411: EMPTY
16412: LIST
16413: LIST
16414: PPUSH
16415: CALL_OW 69
16419: PUSH
16420: FOR_IN
16421: IFFALSE 16437
// begin SetClass ( i , 1 ) ;
16423: LD_VAR 0 1
16427: PPUSH
16428: LD_INT 1
16430: PPUSH
16431: CALL_OW 336
// end ;
16435: GO 16420
16437: POP
16438: POP
// end ;
16439: PPOPN 1
16441: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16442: LD_EXP 43
16446: PUSH
16447: LD_EXP 47
16451: AND
16452: PUSH
16453: LD_OWVAR 65
16457: PUSH
16458: LD_INT 7
16460: LESS
16461: AND
16462: IFFALSE 16476
16464: GO 16466
16466: DISABLE
// begin enable ;
16467: ENABLE
// game_speed := 7 ;
16468: LD_ADDR_OWVAR 65
16472: PUSH
16473: LD_INT 7
16475: ST_TO_ADDR
// end ;
16476: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16477: LD_EXP 43
16481: PUSH
16482: LD_EXP 50
16486: AND
16487: IFFALSE 16689
16489: GO 16491
16491: DISABLE
16492: LD_INT 0
16494: PPUSH
16495: PPUSH
16496: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16497: LD_ADDR_VAR 0 3
16501: PUSH
16502: LD_INT 81
16504: PUSH
16505: LD_OWVAR 2
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: PUSH
16514: LD_INT 21
16516: PUSH
16517: LD_INT 1
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: PUSH
16524: EMPTY
16525: LIST
16526: LIST
16527: PPUSH
16528: CALL_OW 69
16532: ST_TO_ADDR
// if not tmp then
16533: LD_VAR 0 3
16537: NOT
16538: IFFALSE 16542
// exit ;
16540: GO 16689
// if tmp > 5 then
16542: LD_VAR 0 3
16546: PUSH
16547: LD_INT 5
16549: GREATER
16550: IFFALSE 16562
// k := 5 else
16552: LD_ADDR_VAR 0 2
16556: PUSH
16557: LD_INT 5
16559: ST_TO_ADDR
16560: GO 16572
// k := tmp ;
16562: LD_ADDR_VAR 0 2
16566: PUSH
16567: LD_VAR 0 3
16571: ST_TO_ADDR
// for i := 1 to k do
16572: LD_ADDR_VAR 0 1
16576: PUSH
16577: DOUBLE
16578: LD_INT 1
16580: DEC
16581: ST_TO_ADDR
16582: LD_VAR 0 2
16586: PUSH
16587: FOR_TO
16588: IFFALSE 16687
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
16590: LD_VAR 0 3
16594: PUSH
16595: LD_VAR 0 1
16599: ARRAY
16600: PPUSH
16601: LD_VAR 0 1
16605: PUSH
16606: LD_INT 4
16608: MOD
16609: PUSH
16610: LD_INT 1
16612: PLUS
16613: PPUSH
16614: CALL_OW 259
16618: PUSH
16619: LD_INT 10
16621: LESS
16622: IFFALSE 16685
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
16624: LD_VAR 0 3
16628: PUSH
16629: LD_VAR 0 1
16633: ARRAY
16634: PPUSH
16635: LD_VAR 0 1
16639: PUSH
16640: LD_INT 4
16642: MOD
16643: PUSH
16644: LD_INT 1
16646: PLUS
16647: PPUSH
16648: LD_VAR 0 3
16652: PUSH
16653: LD_VAR 0 1
16657: ARRAY
16658: PPUSH
16659: LD_VAR 0 1
16663: PUSH
16664: LD_INT 4
16666: MOD
16667: PUSH
16668: LD_INT 1
16670: PLUS
16671: PPUSH
16672: CALL_OW 259
16676: PUSH
16677: LD_INT 1
16679: PLUS
16680: PPUSH
16681: CALL_OW 237
16685: GO 16587
16687: POP
16688: POP
// end ;
16689: PPOPN 3
16691: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16692: LD_EXP 43
16696: PUSH
16697: LD_EXP 51
16701: AND
16702: IFFALSE 16722
16704: GO 16706
16706: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16707: LD_INT 4
16709: PPUSH
16710: LD_OWVAR 2
16714: PPUSH
16715: LD_INT 0
16717: PPUSH
16718: CALL_OW 324
16722: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16723: LD_EXP 43
16727: PUSH
16728: LD_EXP 80
16732: AND
16733: IFFALSE 16753
16735: GO 16737
16737: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16738: LD_INT 19
16740: PPUSH
16741: LD_OWVAR 2
16745: PPUSH
16746: LD_INT 0
16748: PPUSH
16749: CALL_OW 324
16753: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16754: LD_EXP 43
16758: PUSH
16759: LD_EXP 52
16763: AND
16764: IFFALSE 16866
16766: GO 16768
16768: DISABLE
16769: LD_INT 0
16771: PPUSH
16772: PPUSH
// begin enable ;
16773: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16774: LD_ADDR_VAR 0 2
16778: PUSH
16779: LD_INT 22
16781: PUSH
16782: LD_OWVAR 2
16786: PUSH
16787: EMPTY
16788: LIST
16789: LIST
16790: PUSH
16791: LD_INT 2
16793: PUSH
16794: LD_INT 34
16796: PUSH
16797: LD_INT 11
16799: PUSH
16800: EMPTY
16801: LIST
16802: LIST
16803: PUSH
16804: LD_INT 34
16806: PUSH
16807: LD_INT 30
16809: PUSH
16810: EMPTY
16811: LIST
16812: LIST
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: LIST
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: PPUSH
16823: CALL_OW 69
16827: ST_TO_ADDR
// if not tmp then
16828: LD_VAR 0 2
16832: NOT
16833: IFFALSE 16837
// exit ;
16835: GO 16866
// for i in tmp do
16837: LD_ADDR_VAR 0 1
16841: PUSH
16842: LD_VAR 0 2
16846: PUSH
16847: FOR_IN
16848: IFFALSE 16864
// begin SetLives ( i , 0 ) ;
16850: LD_VAR 0 1
16854: PPUSH
16855: LD_INT 0
16857: PPUSH
16858: CALL_OW 234
// end ;
16862: GO 16847
16864: POP
16865: POP
// end ;
16866: PPOPN 2
16868: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16869: LD_EXP 43
16873: PUSH
16874: LD_EXP 53
16878: AND
16879: IFFALSE 16899
16881: GO 16883
16883: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16884: LD_INT 32
16886: PPUSH
16887: LD_OWVAR 2
16891: PPUSH
16892: LD_INT 0
16894: PPUSH
16895: CALL_OW 324
16899: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16900: LD_EXP 43
16904: PUSH
16905: LD_EXP 54
16909: AND
16910: IFFALSE 17091
16912: GO 16914
16914: DISABLE
16915: LD_INT 0
16917: PPUSH
16918: PPUSH
16919: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
16920: LD_ADDR_VAR 0 2
16924: PUSH
16925: LD_INT 22
16927: PUSH
16928: LD_OWVAR 2
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: PUSH
16937: LD_INT 33
16939: PUSH
16940: LD_INT 3
16942: PUSH
16943: EMPTY
16944: LIST
16945: LIST
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PPUSH
16951: CALL_OW 69
16955: ST_TO_ADDR
// if not tmp then
16956: LD_VAR 0 2
16960: NOT
16961: IFFALSE 16965
// exit ;
16963: GO 17091
// side := 0 ;
16965: LD_ADDR_VAR 0 3
16969: PUSH
16970: LD_INT 0
16972: ST_TO_ADDR
// for i := 1 to 8 do
16973: LD_ADDR_VAR 0 1
16977: PUSH
16978: DOUBLE
16979: LD_INT 1
16981: DEC
16982: ST_TO_ADDR
16983: LD_INT 8
16985: PUSH
16986: FOR_TO
16987: IFFALSE 17035
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
16989: LD_OWVAR 2
16993: PUSH
16994: LD_VAR 0 1
16998: NONEQUAL
16999: PUSH
17000: LD_OWVAR 2
17004: PPUSH
17005: LD_VAR 0 1
17009: PPUSH
17010: CALL_OW 81
17014: PUSH
17015: LD_INT 2
17017: EQUAL
17018: AND
17019: IFFALSE 17033
// begin side := i ;
17021: LD_ADDR_VAR 0 3
17025: PUSH
17026: LD_VAR 0 1
17030: ST_TO_ADDR
// break ;
17031: GO 17035
// end ;
17033: GO 16986
17035: POP
17036: POP
// if not side then
17037: LD_VAR 0 3
17041: NOT
17042: IFFALSE 17046
// exit ;
17044: GO 17091
// for i := 1 to tmp do
17046: LD_ADDR_VAR 0 1
17050: PUSH
17051: DOUBLE
17052: LD_INT 1
17054: DEC
17055: ST_TO_ADDR
17056: LD_VAR 0 2
17060: PUSH
17061: FOR_TO
17062: IFFALSE 17089
// if Prob ( 60 ) then
17064: LD_INT 60
17066: PPUSH
17067: CALL_OW 13
17071: IFFALSE 17087
// SetSide ( i , side ) ;
17073: LD_VAR 0 1
17077: PPUSH
17078: LD_VAR 0 3
17082: PPUSH
17083: CALL_OW 235
17087: GO 17061
17089: POP
17090: POP
// end ;
17091: PPOPN 3
17093: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
17094: LD_EXP 43
17098: PUSH
17099: LD_EXP 56
17103: AND
17104: IFFALSE 17223
17106: GO 17108
17108: DISABLE
17109: LD_INT 0
17111: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
17112: LD_ADDR_VAR 0 1
17116: PUSH
17117: LD_INT 22
17119: PUSH
17120: LD_OWVAR 2
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: PUSH
17129: LD_INT 21
17131: PUSH
17132: LD_INT 1
17134: PUSH
17135: EMPTY
17136: LIST
17137: LIST
17138: PUSH
17139: LD_INT 3
17141: PUSH
17142: LD_INT 23
17144: PUSH
17145: LD_INT 0
17147: PUSH
17148: EMPTY
17149: LIST
17150: LIST
17151: PUSH
17152: EMPTY
17153: LIST
17154: LIST
17155: PUSH
17156: EMPTY
17157: LIST
17158: LIST
17159: LIST
17160: PPUSH
17161: CALL_OW 69
17165: PUSH
17166: FOR_IN
17167: IFFALSE 17221
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
17169: LD_VAR 0 1
17173: PPUSH
17174: CALL_OW 257
17178: PUSH
17179: LD_INT 1
17181: PUSH
17182: LD_INT 2
17184: PUSH
17185: LD_INT 3
17187: PUSH
17188: LD_INT 4
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: LIST
17195: LIST
17196: IN
17197: IFFALSE 17219
// SetClass ( un , rand ( 1 , 4 ) ) ;
17199: LD_VAR 0 1
17203: PPUSH
17204: LD_INT 1
17206: PPUSH
17207: LD_INT 4
17209: PPUSH
17210: CALL_OW 12
17214: PPUSH
17215: CALL_OW 336
17219: GO 17166
17221: POP
17222: POP
// end ;
17223: PPOPN 1
17225: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
17226: LD_EXP 43
17230: PUSH
17231: LD_EXP 55
17235: AND
17236: IFFALSE 17315
17238: GO 17240
17240: DISABLE
17241: LD_INT 0
17243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17244: LD_ADDR_VAR 0 1
17248: PUSH
17249: LD_INT 22
17251: PUSH
17252: LD_OWVAR 2
17256: PUSH
17257: EMPTY
17258: LIST
17259: LIST
17260: PUSH
17261: LD_INT 21
17263: PUSH
17264: LD_INT 3
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: PUSH
17271: EMPTY
17272: LIST
17273: LIST
17274: PPUSH
17275: CALL_OW 69
17279: ST_TO_ADDR
// if not tmp then
17280: LD_VAR 0 1
17284: NOT
17285: IFFALSE 17289
// exit ;
17287: GO 17315
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
17289: LD_VAR 0 1
17293: PUSH
17294: LD_INT 1
17296: PPUSH
17297: LD_VAR 0 1
17301: PPUSH
17302: CALL_OW 12
17306: ARRAY
17307: PPUSH
17308: LD_INT 100
17310: PPUSH
17311: CALL_OW 234
// end ;
17315: PPOPN 1
17317: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
17318: LD_EXP 43
17322: PUSH
17323: LD_EXP 57
17327: AND
17328: IFFALSE 17426
17330: GO 17332
17332: DISABLE
17333: LD_INT 0
17335: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17336: LD_ADDR_VAR 0 1
17340: PUSH
17341: LD_INT 22
17343: PUSH
17344: LD_OWVAR 2
17348: PUSH
17349: EMPTY
17350: LIST
17351: LIST
17352: PUSH
17353: LD_INT 21
17355: PUSH
17356: LD_INT 1
17358: PUSH
17359: EMPTY
17360: LIST
17361: LIST
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: PPUSH
17367: CALL_OW 69
17371: ST_TO_ADDR
// if not tmp then
17372: LD_VAR 0 1
17376: NOT
17377: IFFALSE 17381
// exit ;
17379: GO 17426
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
17381: LD_VAR 0 1
17385: PUSH
17386: LD_INT 1
17388: PPUSH
17389: LD_VAR 0 1
17393: PPUSH
17394: CALL_OW 12
17398: ARRAY
17399: PPUSH
17400: LD_INT 1
17402: PPUSH
17403: LD_INT 4
17405: PPUSH
17406: CALL_OW 12
17410: PPUSH
17411: LD_INT 3000
17413: PPUSH
17414: LD_INT 9000
17416: PPUSH
17417: CALL_OW 12
17421: PPUSH
17422: CALL_OW 492
// end ;
17426: PPOPN 1
17428: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17429: LD_EXP 43
17433: PUSH
17434: LD_EXP 58
17438: AND
17439: IFFALSE 17459
17441: GO 17443
17443: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17444: LD_INT 1
17446: PPUSH
17447: LD_OWVAR 2
17451: PPUSH
17452: LD_INT 0
17454: PPUSH
17455: CALL_OW 324
17459: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17460: LD_EXP 43
17464: PUSH
17465: LD_EXP 59
17469: AND
17470: IFFALSE 17553
17472: GO 17474
17474: DISABLE
17475: LD_INT 0
17477: PPUSH
17478: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17479: LD_ADDR_VAR 0 2
17483: PUSH
17484: LD_INT 22
17486: PUSH
17487: LD_OWVAR 2
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: LD_INT 21
17498: PUSH
17499: LD_INT 3
17501: PUSH
17502: EMPTY
17503: LIST
17504: LIST
17505: PUSH
17506: EMPTY
17507: LIST
17508: LIST
17509: PPUSH
17510: CALL_OW 69
17514: ST_TO_ADDR
// if not tmp then
17515: LD_VAR 0 2
17519: NOT
17520: IFFALSE 17524
// exit ;
17522: GO 17553
// for i in tmp do
17524: LD_ADDR_VAR 0 1
17528: PUSH
17529: LD_VAR 0 2
17533: PUSH
17534: FOR_IN
17535: IFFALSE 17551
// SetBLevel ( i , 10 ) ;
17537: LD_VAR 0 1
17541: PPUSH
17542: LD_INT 10
17544: PPUSH
17545: CALL_OW 241
17549: GO 17534
17551: POP
17552: POP
// end ;
17553: PPOPN 2
17555: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17556: LD_EXP 43
17560: PUSH
17561: LD_EXP 60
17565: AND
17566: IFFALSE 17677
17568: GO 17570
17570: DISABLE
17571: LD_INT 0
17573: PPUSH
17574: PPUSH
17575: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17576: LD_ADDR_VAR 0 3
17580: PUSH
17581: LD_INT 22
17583: PUSH
17584: LD_OWVAR 2
17588: PUSH
17589: EMPTY
17590: LIST
17591: LIST
17592: PUSH
17593: LD_INT 25
17595: PUSH
17596: LD_INT 1
17598: PUSH
17599: EMPTY
17600: LIST
17601: LIST
17602: PUSH
17603: EMPTY
17604: LIST
17605: LIST
17606: PPUSH
17607: CALL_OW 69
17611: ST_TO_ADDR
// if not tmp then
17612: LD_VAR 0 3
17616: NOT
17617: IFFALSE 17621
// exit ;
17619: GO 17677
// un := tmp [ rand ( 1 , tmp ) ] ;
17621: LD_ADDR_VAR 0 2
17625: PUSH
17626: LD_VAR 0 3
17630: PUSH
17631: LD_INT 1
17633: PPUSH
17634: LD_VAR 0 3
17638: PPUSH
17639: CALL_OW 12
17643: ARRAY
17644: ST_TO_ADDR
// if Crawls ( un ) then
17645: LD_VAR 0 2
17649: PPUSH
17650: CALL_OW 318
17654: IFFALSE 17665
// ComWalk ( un ) ;
17656: LD_VAR 0 2
17660: PPUSH
17661: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17665: LD_VAR 0 2
17669: PPUSH
17670: LD_INT 5
17672: PPUSH
17673: CALL_OW 336
// end ;
17677: PPOPN 3
17679: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17680: LD_EXP 43
17684: PUSH
17685: LD_EXP 61
17689: AND
17690: PUSH
17691: LD_OWVAR 67
17695: PUSH
17696: LD_INT 3
17698: LESS
17699: AND
17700: IFFALSE 17719
17702: GO 17704
17704: DISABLE
// Difficulty := Difficulty + 1 ;
17705: LD_ADDR_OWVAR 67
17709: PUSH
17710: LD_OWVAR 67
17714: PUSH
17715: LD_INT 1
17717: PLUS
17718: ST_TO_ADDR
17719: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17720: LD_EXP 43
17724: PUSH
17725: LD_EXP 62
17729: AND
17730: IFFALSE 17833
17732: GO 17734
17734: DISABLE
17735: LD_INT 0
17737: PPUSH
// begin for i := 1 to 5 do
17738: LD_ADDR_VAR 0 1
17742: PUSH
17743: DOUBLE
17744: LD_INT 1
17746: DEC
17747: ST_TO_ADDR
17748: LD_INT 5
17750: PUSH
17751: FOR_TO
17752: IFFALSE 17831
// begin uc_nation := nation_nature ;
17754: LD_ADDR_OWVAR 21
17758: PUSH
17759: LD_INT 0
17761: ST_TO_ADDR
// uc_side := 0 ;
17762: LD_ADDR_OWVAR 20
17766: PUSH
17767: LD_INT 0
17769: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17770: LD_ADDR_OWVAR 29
17774: PUSH
17775: LD_INT 12
17777: PUSH
17778: LD_INT 12
17780: PUSH
17781: EMPTY
17782: LIST
17783: LIST
17784: ST_TO_ADDR
// hc_agressivity := 20 ;
17785: LD_ADDR_OWVAR 35
17789: PUSH
17790: LD_INT 20
17792: ST_TO_ADDR
// hc_class := class_tiger ;
17793: LD_ADDR_OWVAR 28
17797: PUSH
17798: LD_INT 14
17800: ST_TO_ADDR
// hc_gallery :=  ;
17801: LD_ADDR_OWVAR 33
17805: PUSH
17806: LD_STRING 
17808: ST_TO_ADDR
// hc_name :=  ;
17809: LD_ADDR_OWVAR 26
17813: PUSH
17814: LD_STRING 
17816: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17817: CALL_OW 44
17821: PPUSH
17822: LD_INT 0
17824: PPUSH
17825: CALL_OW 51
// end ;
17829: GO 17751
17831: POP
17832: POP
// end ;
17833: PPOPN 1
17835: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17836: LD_EXP 43
17840: PUSH
17841: LD_EXP 63
17845: AND
17846: IFFALSE 17855
17848: GO 17850
17850: DISABLE
// StreamSibBomb ;
17851: CALL 17856 0 0
17855: END
// export function StreamSibBomb ; var i , x , y ; begin
17856: LD_INT 0
17858: PPUSH
17859: PPUSH
17860: PPUSH
17861: PPUSH
// result := false ;
17862: LD_ADDR_VAR 0 1
17866: PUSH
17867: LD_INT 0
17869: ST_TO_ADDR
// for i := 1 to 16 do
17870: LD_ADDR_VAR 0 2
17874: PUSH
17875: DOUBLE
17876: LD_INT 1
17878: DEC
17879: ST_TO_ADDR
17880: LD_INT 16
17882: PUSH
17883: FOR_TO
17884: IFFALSE 18083
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17886: LD_ADDR_VAR 0 3
17890: PUSH
17891: LD_INT 10
17893: PUSH
17894: LD_INT 20
17896: PUSH
17897: LD_INT 30
17899: PUSH
17900: LD_INT 40
17902: PUSH
17903: LD_INT 50
17905: PUSH
17906: LD_INT 60
17908: PUSH
17909: LD_INT 70
17911: PUSH
17912: LD_INT 80
17914: PUSH
17915: LD_INT 90
17917: PUSH
17918: LD_INT 100
17920: PUSH
17921: LD_INT 110
17923: PUSH
17924: LD_INT 120
17926: PUSH
17927: LD_INT 130
17929: PUSH
17930: LD_INT 140
17932: PUSH
17933: LD_INT 150
17935: PUSH
17936: EMPTY
17937: LIST
17938: LIST
17939: LIST
17940: LIST
17941: LIST
17942: LIST
17943: LIST
17944: LIST
17945: LIST
17946: LIST
17947: LIST
17948: LIST
17949: LIST
17950: LIST
17951: LIST
17952: PUSH
17953: LD_INT 1
17955: PPUSH
17956: LD_INT 15
17958: PPUSH
17959: CALL_OW 12
17963: ARRAY
17964: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17965: LD_ADDR_VAR 0 4
17969: PUSH
17970: LD_INT 10
17972: PUSH
17973: LD_INT 20
17975: PUSH
17976: LD_INT 30
17978: PUSH
17979: LD_INT 40
17981: PUSH
17982: LD_INT 50
17984: PUSH
17985: LD_INT 60
17987: PUSH
17988: LD_INT 70
17990: PUSH
17991: LD_INT 80
17993: PUSH
17994: LD_INT 90
17996: PUSH
17997: LD_INT 100
17999: PUSH
18000: LD_INT 110
18002: PUSH
18003: LD_INT 120
18005: PUSH
18006: LD_INT 130
18008: PUSH
18009: LD_INT 140
18011: PUSH
18012: LD_INT 150
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: PUSH
18032: LD_INT 1
18034: PPUSH
18035: LD_INT 15
18037: PPUSH
18038: CALL_OW 12
18042: ARRAY
18043: ST_TO_ADDR
// if ValidHex ( x , y ) then
18044: LD_VAR 0 3
18048: PPUSH
18049: LD_VAR 0 4
18053: PPUSH
18054: CALL_OW 488
18058: IFFALSE 18081
// begin result := [ x , y ] ;
18060: LD_ADDR_VAR 0 1
18064: PUSH
18065: LD_VAR 0 3
18069: PUSH
18070: LD_VAR 0 4
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: ST_TO_ADDR
// break ;
18079: GO 18083
// end ; end ;
18081: GO 17883
18083: POP
18084: POP
// if result then
18085: LD_VAR 0 1
18089: IFFALSE 18149
// begin ToLua ( playSibBomb() ) ;
18091: LD_STRING playSibBomb()
18093: PPUSH
18094: CALL_OW 559
// wait ( 0 0$14 ) ;
18098: LD_INT 490
18100: PPUSH
18101: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
18105: LD_VAR 0 1
18109: PUSH
18110: LD_INT 1
18112: ARRAY
18113: PPUSH
18114: LD_VAR 0 1
18118: PUSH
18119: LD_INT 2
18121: ARRAY
18122: PPUSH
18123: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
18127: LD_VAR 0 1
18131: PUSH
18132: LD_INT 1
18134: ARRAY
18135: PPUSH
18136: LD_VAR 0 1
18140: PUSH
18141: LD_INT 2
18143: ARRAY
18144: PPUSH
18145: CALL_OW 429
// end ; end ;
18149: LD_VAR 0 1
18153: RET
// every 0 0$1 trigger StreamModeActive and sReset do
18154: LD_EXP 43
18158: PUSH
18159: LD_EXP 65
18163: AND
18164: IFFALSE 18176
18166: GO 18168
18168: DISABLE
// YouLost (  ) ;
18169: LD_STRING 
18171: PPUSH
18172: CALL_OW 104
18176: END
// every 0 0$1 trigger StreamModeActive and sFog do
18177: LD_EXP 43
18181: PUSH
18182: LD_EXP 64
18186: AND
18187: IFFALSE 18201
18189: GO 18191
18191: DISABLE
// FogOff ( your_side ) ;
18192: LD_OWVAR 2
18196: PPUSH
18197: CALL_OW 344
18201: END
// every 0 0$1 trigger StreamModeActive and sSun do
18202: LD_EXP 43
18206: PUSH
18207: LD_EXP 66
18211: AND
18212: IFFALSE 18240
18214: GO 18216
18216: DISABLE
// begin solar_recharge_percent := 0 ;
18217: LD_ADDR_OWVAR 79
18221: PUSH
18222: LD_INT 0
18224: ST_TO_ADDR
// wait ( 5 5$00 ) ;
18225: LD_INT 10500
18227: PPUSH
18228: CALL_OW 67
// solar_recharge_percent := 100 ;
18232: LD_ADDR_OWVAR 79
18236: PUSH
18237: LD_INT 100
18239: ST_TO_ADDR
// end ;
18240: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
18241: LD_EXP 43
18245: PUSH
18246: LD_EXP 67
18250: AND
18251: IFFALSE 18490
18253: GO 18255
18255: DISABLE
18256: LD_INT 0
18258: PPUSH
18259: PPUSH
18260: PPUSH
// begin tmp := [ ] ;
18261: LD_ADDR_VAR 0 3
18265: PUSH
18266: EMPTY
18267: ST_TO_ADDR
// for i := 1 to 6 do
18268: LD_ADDR_VAR 0 1
18272: PUSH
18273: DOUBLE
18274: LD_INT 1
18276: DEC
18277: ST_TO_ADDR
18278: LD_INT 6
18280: PUSH
18281: FOR_TO
18282: IFFALSE 18387
// begin uc_nation := nation_nature ;
18284: LD_ADDR_OWVAR 21
18288: PUSH
18289: LD_INT 0
18291: ST_TO_ADDR
// uc_side := 0 ;
18292: LD_ADDR_OWVAR 20
18296: PUSH
18297: LD_INT 0
18299: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18300: LD_ADDR_OWVAR 29
18304: PUSH
18305: LD_INT 12
18307: PUSH
18308: LD_INT 12
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: ST_TO_ADDR
// hc_agressivity := 20 ;
18315: LD_ADDR_OWVAR 35
18319: PUSH
18320: LD_INT 20
18322: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
18323: LD_ADDR_OWVAR 28
18327: PUSH
18328: LD_INT 17
18330: ST_TO_ADDR
// hc_gallery :=  ;
18331: LD_ADDR_OWVAR 33
18335: PUSH
18336: LD_STRING 
18338: ST_TO_ADDR
// hc_name :=  ;
18339: LD_ADDR_OWVAR 26
18343: PUSH
18344: LD_STRING 
18346: ST_TO_ADDR
// un := CreateHuman ;
18347: LD_ADDR_VAR 0 2
18351: PUSH
18352: CALL_OW 44
18356: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
18357: LD_VAR 0 2
18361: PPUSH
18362: LD_INT 1
18364: PPUSH
18365: CALL_OW 51
// tmp := tmp ^ un ;
18369: LD_ADDR_VAR 0 3
18373: PUSH
18374: LD_VAR 0 3
18378: PUSH
18379: LD_VAR 0 2
18383: ADD
18384: ST_TO_ADDR
// end ;
18385: GO 18281
18387: POP
18388: POP
// repeat wait ( 0 0$1 ) ;
18389: LD_INT 35
18391: PPUSH
18392: CALL_OW 67
// for un in tmp do
18396: LD_ADDR_VAR 0 2
18400: PUSH
18401: LD_VAR 0 3
18405: PUSH
18406: FOR_IN
18407: IFFALSE 18481
// begin if IsDead ( un ) then
18409: LD_VAR 0 2
18413: PPUSH
18414: CALL_OW 301
18418: IFFALSE 18438
// begin tmp := tmp diff un ;
18420: LD_ADDR_VAR 0 3
18424: PUSH
18425: LD_VAR 0 3
18429: PUSH
18430: LD_VAR 0 2
18434: DIFF
18435: ST_TO_ADDR
// continue ;
18436: GO 18406
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18438: LD_VAR 0 2
18442: PPUSH
18443: LD_INT 3
18445: PUSH
18446: LD_INT 22
18448: PUSH
18449: LD_INT 0
18451: PUSH
18452: EMPTY
18453: LIST
18454: LIST
18455: PUSH
18456: EMPTY
18457: LIST
18458: LIST
18459: PPUSH
18460: CALL_OW 69
18464: PPUSH
18465: LD_VAR 0 2
18469: PPUSH
18470: CALL_OW 74
18474: PPUSH
18475: CALL_OW 115
// end ;
18479: GO 18406
18481: POP
18482: POP
// until not tmp ;
18483: LD_VAR 0 3
18487: NOT
18488: IFFALSE 18389
// end ;
18490: PPOPN 3
18492: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18493: LD_EXP 43
18497: PUSH
18498: LD_EXP 68
18502: AND
18503: IFFALSE 18557
18505: GO 18507
18507: DISABLE
// begin ToLua ( displayTroll(); ) ;
18508: LD_STRING displayTroll();
18510: PPUSH
18511: CALL_OW 559
// wait ( 3 3$00 ) ;
18515: LD_INT 6300
18517: PPUSH
18518: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18522: LD_STRING hideTroll();
18524: PPUSH
18525: CALL_OW 559
// wait ( 1 1$00 ) ;
18529: LD_INT 2100
18531: PPUSH
18532: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18536: LD_STRING displayTroll();
18538: PPUSH
18539: CALL_OW 559
// wait ( 1 1$00 ) ;
18543: LD_INT 2100
18545: PPUSH
18546: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18550: LD_STRING hideTroll();
18552: PPUSH
18553: CALL_OW 559
// end ;
18557: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18558: LD_EXP 43
18562: PUSH
18563: LD_EXP 69
18567: AND
18568: IFFALSE 18631
18570: GO 18572
18572: DISABLE
18573: LD_INT 0
18575: PPUSH
// begin p := 0 ;
18576: LD_ADDR_VAR 0 1
18580: PUSH
18581: LD_INT 0
18583: ST_TO_ADDR
// repeat game_speed := 1 ;
18584: LD_ADDR_OWVAR 65
18588: PUSH
18589: LD_INT 1
18591: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18592: LD_INT 35
18594: PPUSH
18595: CALL_OW 67
// p := p + 1 ;
18599: LD_ADDR_VAR 0 1
18603: PUSH
18604: LD_VAR 0 1
18608: PUSH
18609: LD_INT 1
18611: PLUS
18612: ST_TO_ADDR
// until p >= 60 ;
18613: LD_VAR 0 1
18617: PUSH
18618: LD_INT 60
18620: GREATEREQUAL
18621: IFFALSE 18584
// game_speed := 4 ;
18623: LD_ADDR_OWVAR 65
18627: PUSH
18628: LD_INT 4
18630: ST_TO_ADDR
// end ;
18631: PPOPN 1
18633: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
18634: LD_EXP 43
18638: PUSH
18639: LD_EXP 70
18643: AND
18644: IFFALSE 18790
18646: GO 18648
18648: DISABLE
18649: LD_INT 0
18651: PPUSH
18652: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18653: LD_ADDR_VAR 0 1
18657: PUSH
18658: LD_INT 22
18660: PUSH
18661: LD_OWVAR 2
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: PUSH
18670: LD_INT 2
18672: PUSH
18673: LD_INT 30
18675: PUSH
18676: LD_INT 0
18678: PUSH
18679: EMPTY
18680: LIST
18681: LIST
18682: PUSH
18683: LD_INT 30
18685: PUSH
18686: LD_INT 1
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: LIST
18697: PUSH
18698: EMPTY
18699: LIST
18700: LIST
18701: PPUSH
18702: CALL_OW 69
18706: ST_TO_ADDR
// if not depot then
18707: LD_VAR 0 1
18711: NOT
18712: IFFALSE 18716
// exit ;
18714: GO 18790
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18716: LD_ADDR_VAR 0 2
18720: PUSH
18721: LD_VAR 0 1
18725: PUSH
18726: LD_INT 1
18728: PPUSH
18729: LD_VAR 0 1
18733: PPUSH
18734: CALL_OW 12
18738: ARRAY
18739: PPUSH
18740: CALL_OW 274
18744: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18745: LD_VAR 0 2
18749: PPUSH
18750: LD_INT 1
18752: PPUSH
18753: LD_INT 0
18755: PPUSH
18756: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18760: LD_VAR 0 2
18764: PPUSH
18765: LD_INT 2
18767: PPUSH
18768: LD_INT 0
18770: PPUSH
18771: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18775: LD_VAR 0 2
18779: PPUSH
18780: LD_INT 3
18782: PPUSH
18783: LD_INT 0
18785: PPUSH
18786: CALL_OW 277
// end ;
18790: PPOPN 2
18792: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18793: LD_EXP 43
18797: PUSH
18798: LD_EXP 71
18802: AND
18803: IFFALSE 18900
18805: GO 18807
18807: DISABLE
18808: LD_INT 0
18810: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18811: LD_ADDR_VAR 0 1
18815: PUSH
18816: LD_INT 22
18818: PUSH
18819: LD_OWVAR 2
18823: PUSH
18824: EMPTY
18825: LIST
18826: LIST
18827: PUSH
18828: LD_INT 21
18830: PUSH
18831: LD_INT 1
18833: PUSH
18834: EMPTY
18835: LIST
18836: LIST
18837: PUSH
18838: LD_INT 3
18840: PUSH
18841: LD_INT 23
18843: PUSH
18844: LD_INT 0
18846: PUSH
18847: EMPTY
18848: LIST
18849: LIST
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: EMPTY
18856: LIST
18857: LIST
18858: LIST
18859: PPUSH
18860: CALL_OW 69
18864: ST_TO_ADDR
// if not tmp then
18865: LD_VAR 0 1
18869: NOT
18870: IFFALSE 18874
// exit ;
18872: GO 18900
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18874: LD_VAR 0 1
18878: PUSH
18879: LD_INT 1
18881: PPUSH
18882: LD_VAR 0 1
18886: PPUSH
18887: CALL_OW 12
18891: ARRAY
18892: PPUSH
18893: LD_INT 200
18895: PPUSH
18896: CALL_OW 234
// end ;
18900: PPOPN 1
18902: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
18903: LD_EXP 43
18907: PUSH
18908: LD_EXP 72
18912: AND
18913: IFFALSE 18992
18915: GO 18917
18917: DISABLE
18918: LD_INT 0
18920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
18921: LD_ADDR_VAR 0 1
18925: PUSH
18926: LD_INT 22
18928: PUSH
18929: LD_OWVAR 2
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: PUSH
18938: LD_INT 21
18940: PUSH
18941: LD_INT 2
18943: PUSH
18944: EMPTY
18945: LIST
18946: LIST
18947: PUSH
18948: EMPTY
18949: LIST
18950: LIST
18951: PPUSH
18952: CALL_OW 69
18956: ST_TO_ADDR
// if not tmp then
18957: LD_VAR 0 1
18961: NOT
18962: IFFALSE 18966
// exit ;
18964: GO 18992
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
18966: LD_VAR 0 1
18970: PUSH
18971: LD_INT 1
18973: PPUSH
18974: LD_VAR 0 1
18978: PPUSH
18979: CALL_OW 12
18983: ARRAY
18984: PPUSH
18985: LD_INT 60
18987: PPUSH
18988: CALL_OW 234
// end ;
18992: PPOPN 1
18994: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
18995: LD_EXP 43
18999: PUSH
19000: LD_EXP 73
19004: AND
19005: IFFALSE 19104
19007: GO 19009
19009: DISABLE
19010: LD_INT 0
19012: PPUSH
19013: PPUSH
// begin enable ;
19014: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
19015: LD_ADDR_VAR 0 1
19019: PUSH
19020: LD_INT 22
19022: PUSH
19023: LD_OWVAR 2
19027: PUSH
19028: EMPTY
19029: LIST
19030: LIST
19031: PUSH
19032: LD_INT 61
19034: PUSH
19035: EMPTY
19036: LIST
19037: PUSH
19038: LD_INT 33
19040: PUSH
19041: LD_INT 2
19043: PUSH
19044: EMPTY
19045: LIST
19046: LIST
19047: PUSH
19048: EMPTY
19049: LIST
19050: LIST
19051: LIST
19052: PPUSH
19053: CALL_OW 69
19057: ST_TO_ADDR
// if not tmp then
19058: LD_VAR 0 1
19062: NOT
19063: IFFALSE 19067
// exit ;
19065: GO 19104
// for i in tmp do
19067: LD_ADDR_VAR 0 2
19071: PUSH
19072: LD_VAR 0 1
19076: PUSH
19077: FOR_IN
19078: IFFALSE 19102
// if IsControledBy ( i ) then
19080: LD_VAR 0 2
19084: PPUSH
19085: CALL_OW 312
19089: IFFALSE 19100
// ComUnlink ( i ) ;
19091: LD_VAR 0 2
19095: PPUSH
19096: CALL_OW 136
19100: GO 19077
19102: POP
19103: POP
// end ;
19104: PPOPN 2
19106: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
19107: LD_EXP 43
19111: PUSH
19112: LD_EXP 74
19116: AND
19117: IFFALSE 19257
19119: GO 19121
19121: DISABLE
19122: LD_INT 0
19124: PPUSH
19125: PPUSH
// begin ToLua ( displayPowell(); ) ;
19126: LD_STRING displayPowell();
19128: PPUSH
19129: CALL_OW 559
// uc_side := 0 ;
19133: LD_ADDR_OWVAR 20
19137: PUSH
19138: LD_INT 0
19140: ST_TO_ADDR
// uc_nation := 2 ;
19141: LD_ADDR_OWVAR 21
19145: PUSH
19146: LD_INT 2
19148: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19149: LD_ADDR_OWVAR 37
19153: PUSH
19154: LD_INT 14
19156: ST_TO_ADDR
// vc_engine := engine_siberite ;
19157: LD_ADDR_OWVAR 39
19161: PUSH
19162: LD_INT 3
19164: ST_TO_ADDR
// vc_control := control_apeman ;
19165: LD_ADDR_OWVAR 38
19169: PUSH
19170: LD_INT 5
19172: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
19173: LD_ADDR_OWVAR 40
19177: PUSH
19178: LD_INT 29
19180: ST_TO_ADDR
// un := CreateVehicle ;
19181: LD_ADDR_VAR 0 2
19185: PUSH
19186: CALL_OW 45
19190: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19191: LD_VAR 0 2
19195: PPUSH
19196: LD_INT 1
19198: PPUSH
19199: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19203: LD_INT 35
19205: PPUSH
19206: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19210: LD_VAR 0 2
19214: PPUSH
19215: LD_INT 22
19217: PUSH
19218: LD_OWVAR 2
19222: PUSH
19223: EMPTY
19224: LIST
19225: LIST
19226: PPUSH
19227: CALL_OW 69
19231: PPUSH
19232: LD_VAR 0 2
19236: PPUSH
19237: CALL_OW 74
19241: PPUSH
19242: CALL_OW 115
// until IsDead ( un ) ;
19246: LD_VAR 0 2
19250: PPUSH
19251: CALL_OW 301
19255: IFFALSE 19203
// end ;
19257: PPOPN 2
19259: END
// every 0 0$1 trigger StreamModeActive and sStu do
19260: LD_EXP 43
19264: PUSH
19265: LD_EXP 82
19269: AND
19270: IFFALSE 19286
19272: GO 19274
19274: DISABLE
// begin ToLua ( displayStucuk(); ) ;
19275: LD_STRING displayStucuk();
19277: PPUSH
19278: CALL_OW 559
// ResetFog ;
19282: CALL_OW 335
// end ;
19286: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
19287: LD_EXP 43
19291: PUSH
19292: LD_EXP 75
19296: AND
19297: IFFALSE 19438
19299: GO 19301
19301: DISABLE
19302: LD_INT 0
19304: PPUSH
19305: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19306: LD_ADDR_VAR 0 2
19310: PUSH
19311: LD_INT 22
19313: PUSH
19314: LD_OWVAR 2
19318: PUSH
19319: EMPTY
19320: LIST
19321: LIST
19322: PUSH
19323: LD_INT 21
19325: PUSH
19326: LD_INT 1
19328: PUSH
19329: EMPTY
19330: LIST
19331: LIST
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: PPUSH
19337: CALL_OW 69
19341: ST_TO_ADDR
// if not tmp then
19342: LD_VAR 0 2
19346: NOT
19347: IFFALSE 19351
// exit ;
19349: GO 19438
// un := tmp [ rand ( 1 , tmp ) ] ;
19351: LD_ADDR_VAR 0 1
19355: PUSH
19356: LD_VAR 0 2
19360: PUSH
19361: LD_INT 1
19363: PPUSH
19364: LD_VAR 0 2
19368: PPUSH
19369: CALL_OW 12
19373: ARRAY
19374: ST_TO_ADDR
// SetSide ( un , 0 ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: LD_INT 0
19382: PPUSH
19383: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
19387: LD_VAR 0 1
19391: PPUSH
19392: LD_OWVAR 3
19396: PUSH
19397: LD_VAR 0 1
19401: DIFF
19402: PPUSH
19403: LD_VAR 0 1
19407: PPUSH
19408: CALL_OW 74
19412: PPUSH
19413: CALL_OW 115
// wait ( 0 0$20 ) ;
19417: LD_INT 700
19419: PPUSH
19420: CALL_OW 67
// SetSide ( un , your_side ) ;
19424: LD_VAR 0 1
19428: PPUSH
19429: LD_OWVAR 2
19433: PPUSH
19434: CALL_OW 235
// end ;
19438: PPOPN 2
19440: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19441: LD_EXP 43
19445: PUSH
19446: LD_EXP 76
19450: AND
19451: IFFALSE 19557
19453: GO 19455
19455: DISABLE
19456: LD_INT 0
19458: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19459: LD_ADDR_VAR 0 1
19463: PUSH
19464: LD_INT 22
19466: PUSH
19467: LD_OWVAR 2
19471: PUSH
19472: EMPTY
19473: LIST
19474: LIST
19475: PUSH
19476: LD_INT 2
19478: PUSH
19479: LD_INT 30
19481: PUSH
19482: LD_INT 0
19484: PUSH
19485: EMPTY
19486: LIST
19487: LIST
19488: PUSH
19489: LD_INT 30
19491: PUSH
19492: LD_INT 1
19494: PUSH
19495: EMPTY
19496: LIST
19497: LIST
19498: PUSH
19499: EMPTY
19500: LIST
19501: LIST
19502: LIST
19503: PUSH
19504: EMPTY
19505: LIST
19506: LIST
19507: PPUSH
19508: CALL_OW 69
19512: ST_TO_ADDR
// if not depot then
19513: LD_VAR 0 1
19517: NOT
19518: IFFALSE 19522
// exit ;
19520: GO 19557
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19522: LD_VAR 0 1
19526: PUSH
19527: LD_INT 1
19529: ARRAY
19530: PPUSH
19531: CALL_OW 250
19535: PPUSH
19536: LD_VAR 0 1
19540: PUSH
19541: LD_INT 1
19543: ARRAY
19544: PPUSH
19545: CALL_OW 251
19549: PPUSH
19550: LD_INT 70
19552: PPUSH
19553: CALL_OW 495
// end ;
19557: PPOPN 1
19559: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19560: LD_EXP 43
19564: PUSH
19565: LD_EXP 77
19569: AND
19570: IFFALSE 19781
19572: GO 19574
19574: DISABLE
19575: LD_INT 0
19577: PPUSH
19578: PPUSH
19579: PPUSH
19580: PPUSH
19581: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19582: LD_ADDR_VAR 0 5
19586: PUSH
19587: LD_INT 22
19589: PUSH
19590: LD_OWVAR 2
19594: PUSH
19595: EMPTY
19596: LIST
19597: LIST
19598: PUSH
19599: LD_INT 21
19601: PUSH
19602: LD_INT 1
19604: PUSH
19605: EMPTY
19606: LIST
19607: LIST
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: PPUSH
19613: CALL_OW 69
19617: ST_TO_ADDR
// if not tmp then
19618: LD_VAR 0 5
19622: NOT
19623: IFFALSE 19627
// exit ;
19625: GO 19781
// for i in tmp do
19627: LD_ADDR_VAR 0 1
19631: PUSH
19632: LD_VAR 0 5
19636: PUSH
19637: FOR_IN
19638: IFFALSE 19779
// begin d := rand ( 0 , 5 ) ;
19640: LD_ADDR_VAR 0 4
19644: PUSH
19645: LD_INT 0
19647: PPUSH
19648: LD_INT 5
19650: PPUSH
19651: CALL_OW 12
19655: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19656: LD_ADDR_VAR 0 2
19660: PUSH
19661: LD_VAR 0 1
19665: PPUSH
19666: CALL_OW 250
19670: PPUSH
19671: LD_VAR 0 4
19675: PPUSH
19676: LD_INT 3
19678: PPUSH
19679: LD_INT 12
19681: PPUSH
19682: CALL_OW 12
19686: PPUSH
19687: CALL_OW 272
19691: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19692: LD_ADDR_VAR 0 3
19696: PUSH
19697: LD_VAR 0 1
19701: PPUSH
19702: CALL_OW 251
19706: PPUSH
19707: LD_VAR 0 4
19711: PPUSH
19712: LD_INT 3
19714: PPUSH
19715: LD_INT 12
19717: PPUSH
19718: CALL_OW 12
19722: PPUSH
19723: CALL_OW 273
19727: ST_TO_ADDR
// if ValidHex ( x , y ) then
19728: LD_VAR 0 2
19732: PPUSH
19733: LD_VAR 0 3
19737: PPUSH
19738: CALL_OW 488
19742: IFFALSE 19777
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19744: LD_VAR 0 1
19748: PPUSH
19749: LD_VAR 0 2
19753: PPUSH
19754: LD_VAR 0 3
19758: PPUSH
19759: LD_INT 3
19761: PPUSH
19762: LD_INT 6
19764: PPUSH
19765: CALL_OW 12
19769: PPUSH
19770: LD_INT 1
19772: PPUSH
19773: CALL_OW 483
// end ;
19777: GO 19637
19779: POP
19780: POP
// end ;
19781: PPOPN 5
19783: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19784: LD_EXP 43
19788: PUSH
19789: LD_EXP 78
19793: AND
19794: IFFALSE 19888
19796: GO 19798
19798: DISABLE
19799: LD_INT 0
19801: PPUSH
19802: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19803: LD_ADDR_VAR 0 2
19807: PUSH
19808: LD_INT 22
19810: PUSH
19811: LD_OWVAR 2
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: PUSH
19820: LD_INT 32
19822: PUSH
19823: LD_INT 1
19825: PUSH
19826: EMPTY
19827: LIST
19828: LIST
19829: PUSH
19830: LD_INT 21
19832: PUSH
19833: LD_INT 2
19835: PUSH
19836: EMPTY
19837: LIST
19838: LIST
19839: PUSH
19840: EMPTY
19841: LIST
19842: LIST
19843: LIST
19844: PPUSH
19845: CALL_OW 69
19849: ST_TO_ADDR
// if not tmp then
19850: LD_VAR 0 2
19854: NOT
19855: IFFALSE 19859
// exit ;
19857: GO 19888
// for i in tmp do
19859: LD_ADDR_VAR 0 1
19863: PUSH
19864: LD_VAR 0 2
19868: PUSH
19869: FOR_IN
19870: IFFALSE 19886
// SetFuel ( i , 0 ) ;
19872: LD_VAR 0 1
19876: PPUSH
19877: LD_INT 0
19879: PPUSH
19880: CALL_OW 240
19884: GO 19869
19886: POP
19887: POP
// end ;
19888: PPOPN 2
19890: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19891: LD_EXP 43
19895: PUSH
19896: LD_EXP 79
19900: AND
19901: IFFALSE 19967
19903: GO 19905
19905: DISABLE
19906: LD_INT 0
19908: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19909: LD_ADDR_VAR 0 1
19913: PUSH
19914: LD_INT 22
19916: PUSH
19917: LD_OWVAR 2
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: PUSH
19926: LD_INT 30
19928: PUSH
19929: LD_INT 29
19931: PUSH
19932: EMPTY
19933: LIST
19934: LIST
19935: PUSH
19936: EMPTY
19937: LIST
19938: LIST
19939: PPUSH
19940: CALL_OW 69
19944: ST_TO_ADDR
// if not tmp then
19945: LD_VAR 0 1
19949: NOT
19950: IFFALSE 19954
// exit ;
19952: GO 19967
// DestroyUnit ( tmp [ 1 ] ) ;
19954: LD_VAR 0 1
19958: PUSH
19959: LD_INT 1
19961: ARRAY
19962: PPUSH
19963: CALL_OW 65
// end ;
19967: PPOPN 1
19969: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
19970: LD_EXP 43
19974: PUSH
19975: LD_EXP 81
19979: AND
19980: IFFALSE 20109
19982: GO 19984
19984: DISABLE
19985: LD_INT 0
19987: PPUSH
// begin uc_side := 0 ;
19988: LD_ADDR_OWVAR 20
19992: PUSH
19993: LD_INT 0
19995: ST_TO_ADDR
// uc_nation := nation_arabian ;
19996: LD_ADDR_OWVAR 21
20000: PUSH
20001: LD_INT 2
20003: ST_TO_ADDR
// hc_gallery :=  ;
20004: LD_ADDR_OWVAR 33
20008: PUSH
20009: LD_STRING 
20011: ST_TO_ADDR
// hc_name :=  ;
20012: LD_ADDR_OWVAR 26
20016: PUSH
20017: LD_STRING 
20019: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
20020: LD_INT 1
20022: PPUSH
20023: LD_INT 11
20025: PPUSH
20026: LD_INT 10
20028: PPUSH
20029: CALL_OW 380
// un := CreateHuman ;
20033: LD_ADDR_VAR 0 1
20037: PUSH
20038: CALL_OW 44
20042: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20043: LD_VAR 0 1
20047: PPUSH
20048: LD_INT 1
20050: PPUSH
20051: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20055: LD_INT 35
20057: PPUSH
20058: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20062: LD_VAR 0 1
20066: PPUSH
20067: LD_INT 22
20069: PUSH
20070: LD_OWVAR 2
20074: PUSH
20075: EMPTY
20076: LIST
20077: LIST
20078: PPUSH
20079: CALL_OW 69
20083: PPUSH
20084: LD_VAR 0 1
20088: PPUSH
20089: CALL_OW 74
20093: PPUSH
20094: CALL_OW 115
// until IsDead ( un ) ;
20098: LD_VAR 0 1
20102: PPUSH
20103: CALL_OW 301
20107: IFFALSE 20055
// end ;
20109: PPOPN 1
20111: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
20112: LD_EXP 43
20116: PUSH
20117: LD_EXP 83
20121: AND
20122: IFFALSE 20134
20124: GO 20126
20126: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
20127: LD_STRING earthquake(getX(game), 0, 32)
20129: PPUSH
20130: CALL_OW 559
20134: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
20135: LD_EXP 43
20139: PUSH
20140: LD_EXP 84
20144: AND
20145: IFFALSE 20236
20147: GO 20149
20149: DISABLE
20150: LD_INT 0
20152: PPUSH
// begin enable ;
20153: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
20154: LD_ADDR_VAR 0 1
20158: PUSH
20159: LD_INT 22
20161: PUSH
20162: LD_OWVAR 2
20166: PUSH
20167: EMPTY
20168: LIST
20169: LIST
20170: PUSH
20171: LD_INT 21
20173: PUSH
20174: LD_INT 2
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: PUSH
20181: LD_INT 33
20183: PUSH
20184: LD_INT 3
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: PUSH
20191: EMPTY
20192: LIST
20193: LIST
20194: LIST
20195: PPUSH
20196: CALL_OW 69
20200: ST_TO_ADDR
// if not tmp then
20201: LD_VAR 0 1
20205: NOT
20206: IFFALSE 20210
// exit ;
20208: GO 20236
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20210: LD_VAR 0 1
20214: PUSH
20215: LD_INT 1
20217: PPUSH
20218: LD_VAR 0 1
20222: PPUSH
20223: CALL_OW 12
20227: ARRAY
20228: PPUSH
20229: LD_INT 1
20231: PPUSH
20232: CALL_OW 234
// end ;
20236: PPOPN 1
20238: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
20239: LD_EXP 43
20243: PUSH
20244: LD_EXP 85
20248: AND
20249: IFFALSE 20390
20251: GO 20253
20253: DISABLE
20254: LD_INT 0
20256: PPUSH
20257: PPUSH
20258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20259: LD_ADDR_VAR 0 3
20263: PUSH
20264: LD_INT 22
20266: PUSH
20267: LD_OWVAR 2
20271: PUSH
20272: EMPTY
20273: LIST
20274: LIST
20275: PUSH
20276: LD_INT 25
20278: PUSH
20279: LD_INT 1
20281: PUSH
20282: EMPTY
20283: LIST
20284: LIST
20285: PUSH
20286: EMPTY
20287: LIST
20288: LIST
20289: PPUSH
20290: CALL_OW 69
20294: ST_TO_ADDR
// if not tmp then
20295: LD_VAR 0 3
20299: NOT
20300: IFFALSE 20304
// exit ;
20302: GO 20390
// un := tmp [ rand ( 1 , tmp ) ] ;
20304: LD_ADDR_VAR 0 2
20308: PUSH
20309: LD_VAR 0 3
20313: PUSH
20314: LD_INT 1
20316: PPUSH
20317: LD_VAR 0 3
20321: PPUSH
20322: CALL_OW 12
20326: ARRAY
20327: ST_TO_ADDR
// if Crawls ( un ) then
20328: LD_VAR 0 2
20332: PPUSH
20333: CALL_OW 318
20337: IFFALSE 20348
// ComWalk ( un ) ;
20339: LD_VAR 0 2
20343: PPUSH
20344: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
20348: LD_VAR 0 2
20352: PPUSH
20353: LD_INT 9
20355: PPUSH
20356: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
20360: LD_INT 28
20362: PPUSH
20363: LD_OWVAR 2
20367: PPUSH
20368: LD_INT 2
20370: PPUSH
20371: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
20375: LD_INT 29
20377: PPUSH
20378: LD_OWVAR 2
20382: PPUSH
20383: LD_INT 2
20385: PPUSH
20386: CALL_OW 322
// end ;
20390: PPOPN 3
20392: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
20393: LD_EXP 43
20397: PUSH
20398: LD_EXP 86
20402: AND
20403: IFFALSE 20514
20405: GO 20407
20407: DISABLE
20408: LD_INT 0
20410: PPUSH
20411: PPUSH
20412: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20413: LD_ADDR_VAR 0 3
20417: PUSH
20418: LD_INT 22
20420: PUSH
20421: LD_OWVAR 2
20425: PUSH
20426: EMPTY
20427: LIST
20428: LIST
20429: PUSH
20430: LD_INT 25
20432: PUSH
20433: LD_INT 1
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: PUSH
20440: EMPTY
20441: LIST
20442: LIST
20443: PPUSH
20444: CALL_OW 69
20448: ST_TO_ADDR
// if not tmp then
20449: LD_VAR 0 3
20453: NOT
20454: IFFALSE 20458
// exit ;
20456: GO 20514
// un := tmp [ rand ( 1 , tmp ) ] ;
20458: LD_ADDR_VAR 0 2
20462: PUSH
20463: LD_VAR 0 3
20467: PUSH
20468: LD_INT 1
20470: PPUSH
20471: LD_VAR 0 3
20475: PPUSH
20476: CALL_OW 12
20480: ARRAY
20481: ST_TO_ADDR
// if Crawls ( un ) then
20482: LD_VAR 0 2
20486: PPUSH
20487: CALL_OW 318
20491: IFFALSE 20502
// ComWalk ( un ) ;
20493: LD_VAR 0 2
20497: PPUSH
20498: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20502: LD_VAR 0 2
20506: PPUSH
20507: LD_INT 8
20509: PPUSH
20510: CALL_OW 336
// end ;
20514: PPOPN 3
20516: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20517: LD_EXP 43
20521: PUSH
20522: LD_EXP 87
20526: AND
20527: IFFALSE 20671
20529: GO 20531
20531: DISABLE
20532: LD_INT 0
20534: PPUSH
20535: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20536: LD_ADDR_VAR 0 2
20540: PUSH
20541: LD_INT 22
20543: PUSH
20544: LD_OWVAR 2
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PUSH
20553: LD_INT 21
20555: PUSH
20556: LD_INT 2
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: PUSH
20563: LD_INT 2
20565: PUSH
20566: LD_INT 34
20568: PUSH
20569: LD_INT 12
20571: PUSH
20572: EMPTY
20573: LIST
20574: LIST
20575: PUSH
20576: LD_INT 34
20578: PUSH
20579: LD_INT 51
20581: PUSH
20582: EMPTY
20583: LIST
20584: LIST
20585: PUSH
20586: LD_INT 34
20588: PUSH
20589: LD_INT 32
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PUSH
20596: EMPTY
20597: LIST
20598: LIST
20599: LIST
20600: LIST
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: LIST
20606: PPUSH
20607: CALL_OW 69
20611: ST_TO_ADDR
// if not tmp then
20612: LD_VAR 0 2
20616: NOT
20617: IFFALSE 20621
// exit ;
20619: GO 20671
// for i in tmp do
20621: LD_ADDR_VAR 0 1
20625: PUSH
20626: LD_VAR 0 2
20630: PUSH
20631: FOR_IN
20632: IFFALSE 20669
// if GetCargo ( i , mat_artifact ) = 0 then
20634: LD_VAR 0 1
20638: PPUSH
20639: LD_INT 4
20641: PPUSH
20642: CALL_OW 289
20646: PUSH
20647: LD_INT 0
20649: EQUAL
20650: IFFALSE 20667
// SetCargo ( i , mat_siberit , 100 ) ;
20652: LD_VAR 0 1
20656: PPUSH
20657: LD_INT 3
20659: PPUSH
20660: LD_INT 100
20662: PPUSH
20663: CALL_OW 290
20667: GO 20631
20669: POP
20670: POP
// end ;
20671: PPOPN 2
20673: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20674: LD_EXP 43
20678: PUSH
20679: LD_EXP 88
20683: AND
20684: IFFALSE 20837
20686: GO 20688
20688: DISABLE
20689: LD_INT 0
20691: PPUSH
20692: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20693: LD_ADDR_VAR 0 2
20697: PUSH
20698: LD_INT 22
20700: PUSH
20701: LD_OWVAR 2
20705: PUSH
20706: EMPTY
20707: LIST
20708: LIST
20709: PPUSH
20710: CALL_OW 69
20714: ST_TO_ADDR
// if not tmp then
20715: LD_VAR 0 2
20719: NOT
20720: IFFALSE 20724
// exit ;
20722: GO 20837
// for i := 1 to 2 do
20724: LD_ADDR_VAR 0 1
20728: PUSH
20729: DOUBLE
20730: LD_INT 1
20732: DEC
20733: ST_TO_ADDR
20734: LD_INT 2
20736: PUSH
20737: FOR_TO
20738: IFFALSE 20835
// begin uc_side := your_side ;
20740: LD_ADDR_OWVAR 20
20744: PUSH
20745: LD_OWVAR 2
20749: ST_TO_ADDR
// uc_nation := nation_american ;
20750: LD_ADDR_OWVAR 21
20754: PUSH
20755: LD_INT 1
20757: ST_TO_ADDR
// vc_chassis := us_morphling ;
20758: LD_ADDR_OWVAR 37
20762: PUSH
20763: LD_INT 5
20765: ST_TO_ADDR
// vc_engine := engine_siberite ;
20766: LD_ADDR_OWVAR 39
20770: PUSH
20771: LD_INT 3
20773: ST_TO_ADDR
// vc_control := control_computer ;
20774: LD_ADDR_OWVAR 38
20778: PUSH
20779: LD_INT 3
20781: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20782: LD_ADDR_OWVAR 40
20786: PUSH
20787: LD_INT 10
20789: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
20790: CALL_OW 45
20794: PPUSH
20795: LD_VAR 0 2
20799: PUSH
20800: LD_INT 1
20802: ARRAY
20803: PPUSH
20804: CALL_OW 250
20808: PPUSH
20809: LD_VAR 0 2
20813: PUSH
20814: LD_INT 1
20816: ARRAY
20817: PPUSH
20818: CALL_OW 251
20822: PPUSH
20823: LD_INT 12
20825: PPUSH
20826: LD_INT 1
20828: PPUSH
20829: CALL_OW 50
// end ;
20833: GO 20737
20835: POP
20836: POP
// end ;
20837: PPOPN 2
20839: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20840: LD_EXP 43
20844: PUSH
20845: LD_EXP 89
20849: AND
20850: IFFALSE 21072
20852: GO 20854
20854: DISABLE
20855: LD_INT 0
20857: PPUSH
20858: PPUSH
20859: PPUSH
20860: PPUSH
20861: PPUSH
20862: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20863: LD_ADDR_VAR 0 6
20867: PUSH
20868: LD_INT 22
20870: PUSH
20871: LD_OWVAR 2
20875: PUSH
20876: EMPTY
20877: LIST
20878: LIST
20879: PUSH
20880: LD_INT 21
20882: PUSH
20883: LD_INT 1
20885: PUSH
20886: EMPTY
20887: LIST
20888: LIST
20889: PUSH
20890: LD_INT 3
20892: PUSH
20893: LD_INT 23
20895: PUSH
20896: LD_INT 0
20898: PUSH
20899: EMPTY
20900: LIST
20901: LIST
20902: PUSH
20903: EMPTY
20904: LIST
20905: LIST
20906: PUSH
20907: EMPTY
20908: LIST
20909: LIST
20910: LIST
20911: PPUSH
20912: CALL_OW 69
20916: ST_TO_ADDR
// if not tmp then
20917: LD_VAR 0 6
20921: NOT
20922: IFFALSE 20926
// exit ;
20924: GO 21072
// s1 := rand ( 1 , 4 ) ;
20926: LD_ADDR_VAR 0 2
20930: PUSH
20931: LD_INT 1
20933: PPUSH
20934: LD_INT 4
20936: PPUSH
20937: CALL_OW 12
20941: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
20942: LD_ADDR_VAR 0 4
20946: PUSH
20947: LD_VAR 0 6
20951: PUSH
20952: LD_INT 1
20954: ARRAY
20955: PPUSH
20956: LD_VAR 0 2
20960: PPUSH
20961: CALL_OW 259
20965: ST_TO_ADDR
// if s1 = 1 then
20966: LD_VAR 0 2
20970: PUSH
20971: LD_INT 1
20973: EQUAL
20974: IFFALSE 20994
// s2 := rand ( 2 , 4 ) else
20976: LD_ADDR_VAR 0 3
20980: PUSH
20981: LD_INT 2
20983: PPUSH
20984: LD_INT 4
20986: PPUSH
20987: CALL_OW 12
20991: ST_TO_ADDR
20992: GO 21002
// s2 := 1 ;
20994: LD_ADDR_VAR 0 3
20998: PUSH
20999: LD_INT 1
21001: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
21002: LD_ADDR_VAR 0 5
21006: PUSH
21007: LD_VAR 0 6
21011: PUSH
21012: LD_INT 1
21014: ARRAY
21015: PPUSH
21016: LD_VAR 0 3
21020: PPUSH
21021: CALL_OW 259
21025: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
21026: LD_VAR 0 6
21030: PUSH
21031: LD_INT 1
21033: ARRAY
21034: PPUSH
21035: LD_VAR 0 2
21039: PPUSH
21040: LD_VAR 0 5
21044: PPUSH
21045: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
21049: LD_VAR 0 6
21053: PUSH
21054: LD_INT 1
21056: ARRAY
21057: PPUSH
21058: LD_VAR 0 3
21062: PPUSH
21063: LD_VAR 0 4
21067: PPUSH
21068: CALL_OW 237
// end ;
21072: PPOPN 6
21074: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
21075: LD_EXP 43
21079: PUSH
21080: LD_EXP 90
21084: AND
21085: IFFALSE 21164
21087: GO 21089
21089: DISABLE
21090: LD_INT 0
21092: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
21093: LD_ADDR_VAR 0 1
21097: PUSH
21098: LD_INT 22
21100: PUSH
21101: LD_OWVAR 2
21105: PUSH
21106: EMPTY
21107: LIST
21108: LIST
21109: PUSH
21110: LD_INT 30
21112: PUSH
21113: LD_INT 3
21115: PUSH
21116: EMPTY
21117: LIST
21118: LIST
21119: PUSH
21120: EMPTY
21121: LIST
21122: LIST
21123: PPUSH
21124: CALL_OW 69
21128: ST_TO_ADDR
// if not tmp then
21129: LD_VAR 0 1
21133: NOT
21134: IFFALSE 21138
// exit ;
21136: GO 21164
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21138: LD_VAR 0 1
21142: PUSH
21143: LD_INT 1
21145: PPUSH
21146: LD_VAR 0 1
21150: PPUSH
21151: CALL_OW 12
21155: ARRAY
21156: PPUSH
21157: LD_INT 1
21159: PPUSH
21160: CALL_OW 234
// end ;
21164: PPOPN 1
21166: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
21167: LD_EXP 43
21171: PUSH
21172: LD_EXP 91
21176: AND
21177: IFFALSE 21289
21179: GO 21181
21181: DISABLE
21182: LD_INT 0
21184: PPUSH
21185: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
21186: LD_ADDR_VAR 0 2
21190: PUSH
21191: LD_INT 22
21193: PUSH
21194: LD_OWVAR 2
21198: PUSH
21199: EMPTY
21200: LIST
21201: LIST
21202: PUSH
21203: LD_INT 2
21205: PUSH
21206: LD_INT 30
21208: PUSH
21209: LD_INT 27
21211: PUSH
21212: EMPTY
21213: LIST
21214: LIST
21215: PUSH
21216: LD_INT 30
21218: PUSH
21219: LD_INT 26
21221: PUSH
21222: EMPTY
21223: LIST
21224: LIST
21225: PUSH
21226: LD_INT 30
21228: PUSH
21229: LD_INT 28
21231: PUSH
21232: EMPTY
21233: LIST
21234: LIST
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: LIST
21240: LIST
21241: PUSH
21242: EMPTY
21243: LIST
21244: LIST
21245: PPUSH
21246: CALL_OW 69
21250: ST_TO_ADDR
// if not tmp then
21251: LD_VAR 0 2
21255: NOT
21256: IFFALSE 21260
// exit ;
21258: GO 21289
// for i in tmp do
21260: LD_ADDR_VAR 0 1
21264: PUSH
21265: LD_VAR 0 2
21269: PUSH
21270: FOR_IN
21271: IFFALSE 21287
// SetLives ( i , 1 ) ;
21273: LD_VAR 0 1
21277: PPUSH
21278: LD_INT 1
21280: PPUSH
21281: CALL_OW 234
21285: GO 21270
21287: POP
21288: POP
// end ;
21289: PPOPN 2
21291: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
21292: LD_EXP 43
21296: PUSH
21297: LD_EXP 92
21301: AND
21302: IFFALSE 21576
21304: GO 21306
21306: DISABLE
21307: LD_INT 0
21309: PPUSH
21310: PPUSH
21311: PPUSH
// begin i := rand ( 1 , 7 ) ;
21312: LD_ADDR_VAR 0 1
21316: PUSH
21317: LD_INT 1
21319: PPUSH
21320: LD_INT 7
21322: PPUSH
21323: CALL_OW 12
21327: ST_TO_ADDR
// case i of 1 :
21328: LD_VAR 0 1
21332: PUSH
21333: LD_INT 1
21335: DOUBLE
21336: EQUAL
21337: IFTRUE 21341
21339: GO 21351
21341: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
21342: LD_STRING earthquake(getX(game), 0, 32)
21344: PPUSH
21345: CALL_OW 559
21349: GO 21576
21351: LD_INT 2
21353: DOUBLE
21354: EQUAL
21355: IFTRUE 21359
21357: GO 21373
21359: POP
// begin ToLua ( displayStucuk(); ) ;
21360: LD_STRING displayStucuk();
21362: PPUSH
21363: CALL_OW 559
// ResetFog ;
21367: CALL_OW 335
// end ; 3 :
21371: GO 21576
21373: LD_INT 3
21375: DOUBLE
21376: EQUAL
21377: IFTRUE 21381
21379: GO 21485
21381: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21382: LD_ADDR_VAR 0 2
21386: PUSH
21387: LD_INT 22
21389: PUSH
21390: LD_OWVAR 2
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PUSH
21399: LD_INT 25
21401: PUSH
21402: LD_INT 1
21404: PUSH
21405: EMPTY
21406: LIST
21407: LIST
21408: PUSH
21409: EMPTY
21410: LIST
21411: LIST
21412: PPUSH
21413: CALL_OW 69
21417: ST_TO_ADDR
// if not tmp then
21418: LD_VAR 0 2
21422: NOT
21423: IFFALSE 21427
// exit ;
21425: GO 21576
// un := tmp [ rand ( 1 , tmp ) ] ;
21427: LD_ADDR_VAR 0 3
21431: PUSH
21432: LD_VAR 0 2
21436: PUSH
21437: LD_INT 1
21439: PPUSH
21440: LD_VAR 0 2
21444: PPUSH
21445: CALL_OW 12
21449: ARRAY
21450: ST_TO_ADDR
// if Crawls ( un ) then
21451: LD_VAR 0 3
21455: PPUSH
21456: CALL_OW 318
21460: IFFALSE 21471
// ComWalk ( un ) ;
21462: LD_VAR 0 3
21466: PPUSH
21467: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21471: LD_VAR 0 3
21475: PPUSH
21476: LD_INT 8
21478: PPUSH
21479: CALL_OW 336
// end ; 4 :
21483: GO 21576
21485: LD_INT 4
21487: DOUBLE
21488: EQUAL
21489: IFTRUE 21493
21491: GO 21554
21493: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21494: LD_ADDR_VAR 0 2
21498: PUSH
21499: LD_INT 22
21501: PUSH
21502: LD_OWVAR 2
21506: PUSH
21507: EMPTY
21508: LIST
21509: LIST
21510: PUSH
21511: LD_INT 30
21513: PUSH
21514: LD_INT 29
21516: PUSH
21517: EMPTY
21518: LIST
21519: LIST
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PPUSH
21525: CALL_OW 69
21529: ST_TO_ADDR
// if not tmp then
21530: LD_VAR 0 2
21534: NOT
21535: IFFALSE 21539
// exit ;
21537: GO 21576
// DestroyUnit ( tmp [ 1 ] ) ;
21539: LD_VAR 0 2
21543: PUSH
21544: LD_INT 1
21546: ARRAY
21547: PPUSH
21548: CALL_OW 65
// end ; 5 .. 7 :
21552: GO 21576
21554: LD_INT 5
21556: DOUBLE
21557: GREATEREQUAL
21558: IFFALSE 21566
21560: LD_INT 7
21562: DOUBLE
21563: LESSEQUAL
21564: IFTRUE 21568
21566: GO 21575
21568: POP
// StreamSibBomb ; end ;
21569: CALL 17856 0 0
21573: GO 21576
21575: POP
// end ;
21576: PPOPN 3
21578: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
21579: LD_EXP 43
21583: PUSH
21584: LD_EXP 93
21588: AND
21589: IFFALSE 21745
21591: GO 21593
21593: DISABLE
21594: LD_INT 0
21596: PPUSH
21597: PPUSH
21598: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
21599: LD_ADDR_VAR 0 2
21603: PUSH
21604: LD_INT 81
21606: PUSH
21607: LD_OWVAR 2
21611: PUSH
21612: EMPTY
21613: LIST
21614: LIST
21615: PUSH
21616: LD_INT 2
21618: PUSH
21619: LD_INT 21
21621: PUSH
21622: LD_INT 1
21624: PUSH
21625: EMPTY
21626: LIST
21627: LIST
21628: PUSH
21629: LD_INT 21
21631: PUSH
21632: LD_INT 2
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: LIST
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: PPUSH
21648: CALL_OW 69
21652: ST_TO_ADDR
// if not tmp then
21653: LD_VAR 0 2
21657: NOT
21658: IFFALSE 21662
// exit ;
21660: GO 21745
// p := 0 ;
21662: LD_ADDR_VAR 0 3
21666: PUSH
21667: LD_INT 0
21669: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21670: LD_INT 35
21672: PPUSH
21673: CALL_OW 67
// p := p + 1 ;
21677: LD_ADDR_VAR 0 3
21681: PUSH
21682: LD_VAR 0 3
21686: PUSH
21687: LD_INT 1
21689: PLUS
21690: ST_TO_ADDR
// for i in tmp do
21691: LD_ADDR_VAR 0 1
21695: PUSH
21696: LD_VAR 0 2
21700: PUSH
21701: FOR_IN
21702: IFFALSE 21733
// if GetLives ( i ) < 1000 then
21704: LD_VAR 0 1
21708: PPUSH
21709: CALL_OW 256
21713: PUSH
21714: LD_INT 1000
21716: LESS
21717: IFFALSE 21731
// SetLives ( i , 1000 ) ;
21719: LD_VAR 0 1
21723: PPUSH
21724: LD_INT 1000
21726: PPUSH
21727: CALL_OW 234
21731: GO 21701
21733: POP
21734: POP
// until p > 20 ;
21735: LD_VAR 0 3
21739: PUSH
21740: LD_INT 20
21742: GREATER
21743: IFFALSE 21670
// end ;
21745: PPOPN 3
21747: END
// every 0 0$1 trigger StreamModeActive and sTime do
21748: LD_EXP 43
21752: PUSH
21753: LD_EXP 94
21757: AND
21758: IFFALSE 21793
21760: GO 21762
21762: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21763: LD_INT 28
21765: PPUSH
21766: LD_OWVAR 2
21770: PPUSH
21771: LD_INT 2
21773: PPUSH
21774: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21778: LD_INT 30
21780: PPUSH
21781: LD_OWVAR 2
21785: PPUSH
21786: LD_INT 2
21788: PPUSH
21789: CALL_OW 322
// end ;
21793: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21794: LD_EXP 43
21798: PUSH
21799: LD_EXP 95
21803: AND
21804: IFFALSE 21925
21806: GO 21808
21808: DISABLE
21809: LD_INT 0
21811: PPUSH
21812: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21813: LD_ADDR_VAR 0 2
21817: PUSH
21818: LD_INT 22
21820: PUSH
21821: LD_OWVAR 2
21825: PUSH
21826: EMPTY
21827: LIST
21828: LIST
21829: PUSH
21830: LD_INT 21
21832: PUSH
21833: LD_INT 1
21835: PUSH
21836: EMPTY
21837: LIST
21838: LIST
21839: PUSH
21840: LD_INT 3
21842: PUSH
21843: LD_INT 23
21845: PUSH
21846: LD_INT 0
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: PUSH
21853: EMPTY
21854: LIST
21855: LIST
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: LIST
21861: PPUSH
21862: CALL_OW 69
21866: ST_TO_ADDR
// if not tmp then
21867: LD_VAR 0 2
21871: NOT
21872: IFFALSE 21876
// exit ;
21874: GO 21925
// for i in tmp do
21876: LD_ADDR_VAR 0 1
21880: PUSH
21881: LD_VAR 0 2
21885: PUSH
21886: FOR_IN
21887: IFFALSE 21923
// begin if Crawls ( i ) then
21889: LD_VAR 0 1
21893: PPUSH
21894: CALL_OW 318
21898: IFFALSE 21909
// ComWalk ( i ) ;
21900: LD_VAR 0 1
21904: PPUSH
21905: CALL_OW 138
// SetClass ( i , 2 ) ;
21909: LD_VAR 0 1
21913: PPUSH
21914: LD_INT 2
21916: PPUSH
21917: CALL_OW 336
// end ;
21921: GO 21886
21923: POP
21924: POP
// end ;
21925: PPOPN 2
21927: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
21928: LD_EXP 43
21932: PUSH
21933: LD_EXP 96
21937: AND
21938: IFFALSE 22219
21940: GO 21942
21942: DISABLE
21943: LD_INT 0
21945: PPUSH
21946: PPUSH
21947: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
21948: LD_OWVAR 2
21952: PPUSH
21953: LD_INT 9
21955: PPUSH
21956: LD_INT 1
21958: PPUSH
21959: LD_INT 1
21961: PPUSH
21962: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
21966: LD_INT 9
21968: PPUSH
21969: LD_OWVAR 2
21973: PPUSH
21974: CALL_OW 343
// uc_side := 9 ;
21978: LD_ADDR_OWVAR 20
21982: PUSH
21983: LD_INT 9
21985: ST_TO_ADDR
// uc_nation := 2 ;
21986: LD_ADDR_OWVAR 21
21990: PUSH
21991: LD_INT 2
21993: ST_TO_ADDR
// hc_name := Dark Warrior ;
21994: LD_ADDR_OWVAR 26
21998: PUSH
21999: LD_STRING Dark Warrior
22001: ST_TO_ADDR
// hc_gallery :=  ;
22002: LD_ADDR_OWVAR 33
22006: PUSH
22007: LD_STRING 
22009: ST_TO_ADDR
// hc_noskilllimit := true ;
22010: LD_ADDR_OWVAR 76
22014: PUSH
22015: LD_INT 1
22017: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
22018: LD_ADDR_OWVAR 31
22022: PUSH
22023: LD_INT 30
22025: PUSH
22026: LD_INT 30
22028: PUSH
22029: LD_INT 30
22031: PUSH
22032: LD_INT 30
22034: PUSH
22035: EMPTY
22036: LIST
22037: LIST
22038: LIST
22039: LIST
22040: ST_TO_ADDR
// un := CreateHuman ;
22041: LD_ADDR_VAR 0 3
22045: PUSH
22046: CALL_OW 44
22050: ST_TO_ADDR
// hc_noskilllimit := false ;
22051: LD_ADDR_OWVAR 76
22055: PUSH
22056: LD_INT 0
22058: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
22059: LD_VAR 0 3
22063: PPUSH
22064: LD_INT 1
22066: PPUSH
22067: CALL_OW 51
// p := 0 ;
22071: LD_ADDR_VAR 0 2
22075: PUSH
22076: LD_INT 0
22078: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22079: LD_INT 35
22081: PPUSH
22082: CALL_OW 67
// p := p + 1 ;
22086: LD_ADDR_VAR 0 2
22090: PUSH
22091: LD_VAR 0 2
22095: PUSH
22096: LD_INT 1
22098: PLUS
22099: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
22100: LD_VAR 0 3
22104: PPUSH
22105: CALL_OW 256
22109: PUSH
22110: LD_INT 1000
22112: LESS
22113: IFFALSE 22127
// SetLives ( un , 1000 ) ;
22115: LD_VAR 0 3
22119: PPUSH
22120: LD_INT 1000
22122: PPUSH
22123: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
22127: LD_VAR 0 3
22131: PPUSH
22132: LD_INT 81
22134: PUSH
22135: LD_OWVAR 2
22139: PUSH
22140: EMPTY
22141: LIST
22142: LIST
22143: PUSH
22144: LD_INT 91
22146: PUSH
22147: LD_VAR 0 3
22151: PUSH
22152: LD_INT 30
22154: PUSH
22155: EMPTY
22156: LIST
22157: LIST
22158: LIST
22159: PUSH
22160: EMPTY
22161: LIST
22162: LIST
22163: PPUSH
22164: CALL_OW 69
22168: PPUSH
22169: LD_VAR 0 3
22173: PPUSH
22174: CALL_OW 74
22178: PPUSH
22179: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
22183: LD_VAR 0 2
22187: PUSH
22188: LD_INT 60
22190: GREATER
22191: PUSH
22192: LD_VAR 0 3
22196: PPUSH
22197: CALL_OW 301
22201: OR
22202: IFFALSE 22079
// if un then
22204: LD_VAR 0 3
22208: IFFALSE 22219
// RemoveUnit ( un ) ;
22210: LD_VAR 0 3
22214: PPUSH
22215: CALL_OW 64
// end ; end_of_file
22219: PPOPN 3
22221: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
22222: LD_INT 0
22224: PPUSH
22225: PPUSH
22226: PPUSH
22227: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
22228: LD_VAR 0 1
22232: PPUSH
22233: CALL_OW 264
22237: PUSH
22238: LD_EXP 34
22242: EQUAL
22243: IFFALSE 22315
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
22245: LD_INT 68
22247: PPUSH
22248: LD_VAR 0 1
22252: PPUSH
22253: CALL_OW 255
22257: PPUSH
22258: CALL_OW 321
22262: PUSH
22263: LD_INT 2
22265: EQUAL
22266: IFFALSE 22278
// eff := 70 else
22268: LD_ADDR_VAR 0 4
22272: PUSH
22273: LD_INT 70
22275: ST_TO_ADDR
22276: GO 22286
// eff := 30 ;
22278: LD_ADDR_VAR 0 4
22282: PUSH
22283: LD_INT 30
22285: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
22286: LD_VAR 0 1
22290: PPUSH
22291: CALL_OW 250
22295: PPUSH
22296: LD_VAR 0 1
22300: PPUSH
22301: CALL_OW 251
22305: PPUSH
22306: LD_VAR 0 4
22310: PPUSH
22311: CALL_OW 495
// end ; end ;
22315: LD_VAR 0 2
22319: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
22320: LD_INT 0
22322: PPUSH
// end ;
22323: LD_VAR 0 4
22327: RET
// export function SOS_Command ( cmd ) ; begin
22328: LD_INT 0
22330: PPUSH
// end ;
22331: LD_VAR 0 2
22335: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
22336: LD_VAR 0 1
22340: PUSH
22341: LD_INT 255
22343: EQUAL
22344: PUSH
22345: LD_VAR 0 2
22349: PPUSH
22350: CALL_OW 264
22354: PUSH
22355: LD_INT 14
22357: PUSH
22358: LD_INT 53
22360: PUSH
22361: EMPTY
22362: LIST
22363: LIST
22364: IN
22365: AND
22366: PUSH
22367: LD_VAR 0 4
22371: PPUSH
22372: LD_VAR 0 5
22376: PPUSH
22377: CALL_OW 488
22381: AND
22382: IFFALSE 22406
// CutTreeXYR ( unit , x , y , 12 ) ;
22384: LD_VAR 0 2
22388: PPUSH
22389: LD_VAR 0 4
22393: PPUSH
22394: LD_VAR 0 5
22398: PPUSH
22399: LD_INT 12
22401: PPUSH
22402: CALL 22409 0 4
// end ;
22406: PPOPN 5
22408: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22409: LD_INT 0
22411: PPUSH
22412: PPUSH
22413: PPUSH
22414: PPUSH
22415: PPUSH
22416: PPUSH
22417: PPUSH
22418: PPUSH
22419: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22420: LD_VAR 0 1
22424: NOT
22425: PUSH
22426: LD_VAR 0 2
22430: PPUSH
22431: LD_VAR 0 3
22435: PPUSH
22436: CALL_OW 488
22440: NOT
22441: OR
22442: PUSH
22443: LD_VAR 0 4
22447: NOT
22448: OR
22449: IFFALSE 22453
// exit ;
22451: GO 22793
// list := [ ] ;
22453: LD_ADDR_VAR 0 13
22457: PUSH
22458: EMPTY
22459: ST_TO_ADDR
// if x - r < 0 then
22460: LD_VAR 0 2
22464: PUSH
22465: LD_VAR 0 4
22469: MINUS
22470: PUSH
22471: LD_INT 0
22473: LESS
22474: IFFALSE 22486
// min_x := 0 else
22476: LD_ADDR_VAR 0 7
22480: PUSH
22481: LD_INT 0
22483: ST_TO_ADDR
22484: GO 22502
// min_x := x - r ;
22486: LD_ADDR_VAR 0 7
22490: PUSH
22491: LD_VAR 0 2
22495: PUSH
22496: LD_VAR 0 4
22500: MINUS
22501: ST_TO_ADDR
// if y - r < 0 then
22502: LD_VAR 0 3
22506: PUSH
22507: LD_VAR 0 4
22511: MINUS
22512: PUSH
22513: LD_INT 0
22515: LESS
22516: IFFALSE 22528
// min_y := 0 else
22518: LD_ADDR_VAR 0 8
22522: PUSH
22523: LD_INT 0
22525: ST_TO_ADDR
22526: GO 22544
// min_y := y - r ;
22528: LD_ADDR_VAR 0 8
22532: PUSH
22533: LD_VAR 0 3
22537: PUSH
22538: LD_VAR 0 4
22542: MINUS
22543: ST_TO_ADDR
// max_x := x + r ;
22544: LD_ADDR_VAR 0 9
22548: PUSH
22549: LD_VAR 0 2
22553: PUSH
22554: LD_VAR 0 4
22558: PLUS
22559: ST_TO_ADDR
// max_y := y + r ;
22560: LD_ADDR_VAR 0 10
22564: PUSH
22565: LD_VAR 0 3
22569: PUSH
22570: LD_VAR 0 4
22574: PLUS
22575: ST_TO_ADDR
// for _x = min_x to max_x do
22576: LD_ADDR_VAR 0 11
22580: PUSH
22581: DOUBLE
22582: LD_VAR 0 7
22586: DEC
22587: ST_TO_ADDR
22588: LD_VAR 0 9
22592: PUSH
22593: FOR_TO
22594: IFFALSE 22711
// for _y = min_y to max_y do
22596: LD_ADDR_VAR 0 12
22600: PUSH
22601: DOUBLE
22602: LD_VAR 0 8
22606: DEC
22607: ST_TO_ADDR
22608: LD_VAR 0 10
22612: PUSH
22613: FOR_TO
22614: IFFALSE 22707
// begin if not ValidHex ( _x , _y ) then
22616: LD_VAR 0 11
22620: PPUSH
22621: LD_VAR 0 12
22625: PPUSH
22626: CALL_OW 488
22630: NOT
22631: IFFALSE 22635
// continue ;
22633: GO 22613
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22635: LD_VAR 0 11
22639: PPUSH
22640: LD_VAR 0 12
22644: PPUSH
22645: CALL_OW 351
22649: PUSH
22650: LD_VAR 0 11
22654: PPUSH
22655: LD_VAR 0 12
22659: PPUSH
22660: CALL_OW 554
22664: AND
22665: IFFALSE 22705
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22667: LD_ADDR_VAR 0 13
22671: PUSH
22672: LD_VAR 0 13
22676: PPUSH
22677: LD_VAR 0 13
22681: PUSH
22682: LD_INT 1
22684: PLUS
22685: PPUSH
22686: LD_VAR 0 11
22690: PUSH
22691: LD_VAR 0 12
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: PPUSH
22700: CALL_OW 2
22704: ST_TO_ADDR
// end ;
22705: GO 22613
22707: POP
22708: POP
22709: GO 22593
22711: POP
22712: POP
// if not list then
22713: LD_VAR 0 13
22717: NOT
22718: IFFALSE 22722
// exit ;
22720: GO 22793
// for i in list do
22722: LD_ADDR_VAR 0 6
22726: PUSH
22727: LD_VAR 0 13
22731: PUSH
22732: FOR_IN
22733: IFFALSE 22791
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22735: LD_VAR 0 1
22739: PPUSH
22740: LD_STRING M
22742: PUSH
22743: LD_VAR 0 6
22747: PUSH
22748: LD_INT 1
22750: ARRAY
22751: PUSH
22752: LD_VAR 0 6
22756: PUSH
22757: LD_INT 2
22759: ARRAY
22760: PUSH
22761: LD_INT 0
22763: PUSH
22764: LD_INT 0
22766: PUSH
22767: LD_INT 0
22769: PUSH
22770: LD_INT 0
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: LIST
22780: LIST
22781: PUSH
22782: EMPTY
22783: LIST
22784: PPUSH
22785: CALL_OW 447
22789: GO 22732
22791: POP
22792: POP
// end ;
22793: LD_VAR 0 5
22797: RET
