// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 38 0 0
// PrepareAmericans ;
  19: CALL 445 0 0
// PrepareArabian ;
  23: CALL 552 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 37
// DebugMode ;
  33: CALL 54 0 0
// end ;
  37: END
// export debug ; function Init ; begin
  38: LD_INT 0
  40: PPUSH
// debug := true ;
  41: LD_ADDR_EXP 1
  45: PUSH
  46: LD_INT 1
  48: ST_TO_ADDR
// end ;
  49: LD_VAR 0 1
  53: RET
// function DebugMode ; begin
  54: LD_INT 0
  56: PPUSH
// FogOff ( 1 ) ;
  57: LD_INT 1
  59: PPUSH
  60: CALL_OW 344
// Difficulty := 2 ;
  64: LD_ADDR_OWVAR 67
  68: PUSH
  69: LD_INT 2
  71: ST_TO_ADDR
// end ; end_of_file
  72: LD_VAR 0 1
  76: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
  77: LD_INT 0
  79: PPUSH
  80: PPUSH
// if exist_mode then
  81: LD_VAR 0 2
  85: IFFALSE 110
// unit := CreateCharacter ( prefix & ident ) else
  87: LD_ADDR_VAR 0 5
  91: PUSH
  92: LD_VAR 0 3
  96: PUSH
  97: LD_VAR 0 1
 101: STR
 102: PPUSH
 103: CALL_OW 34
 107: ST_TO_ADDR
 108: GO 125
// unit := NewCharacter ( ident ) ;
 110: LD_ADDR_VAR 0 5
 114: PUSH
 115: LD_VAR 0 1
 119: PPUSH
 120: CALL_OW 25
 124: ST_TO_ADDR
// result := unit ;
 125: LD_ADDR_VAR 0 4
 129: PUSH
 130: LD_VAR 0 5
 134: ST_TO_ADDR
// end ;
 135: LD_VAR 0 4
 139: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 140: LD_INT 0
 142: PPUSH
// uc_side := side ;
 143: LD_ADDR_OWVAR 20
 147: PUSH
 148: LD_VAR 0 1
 152: ST_TO_ADDR
// uc_nation := nation ;
 153: LD_ADDR_OWVAR 21
 157: PUSH
 158: LD_VAR 0 2
 162: ST_TO_ADDR
// vc_chassis := chassis ;
 163: LD_ADDR_OWVAR 37
 167: PUSH
 168: LD_VAR 0 3
 172: ST_TO_ADDR
// vc_engine := engine ;
 173: LD_ADDR_OWVAR 39
 177: PUSH
 178: LD_VAR 0 4
 182: ST_TO_ADDR
// vc_control := control ;
 183: LD_ADDR_OWVAR 38
 187: PUSH
 188: LD_VAR 0 5
 192: ST_TO_ADDR
// vc_weapon := weapon ;
 193: LD_ADDR_OWVAR 40
 197: PUSH
 198: LD_VAR 0 6
 202: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 203: LD_ADDR_OWVAR 41
 207: PUSH
 208: LD_VAR 0 7
 212: ST_TO_ADDR
// result := CreateVehicle ;
 213: LD_ADDR_VAR 0 8
 217: PUSH
 218: CALL_OW 45
 222: ST_TO_ADDR
// end ;
 223: LD_VAR 0 8
 227: RET
// export function SayX ( units , ident ) ; var i ; begin
 228: LD_INT 0
 230: PPUSH
 231: PPUSH
// result := false ;
 232: LD_ADDR_VAR 0 3
 236: PUSH
 237: LD_INT 0
 239: ST_TO_ADDR
// if not units then
 240: LD_VAR 0 1
 244: NOT
 245: IFFALSE 249
// exit ;
 247: GO 303
// for i in units do
 249: LD_ADDR_VAR 0 4
 253: PUSH
 254: LD_VAR 0 1
 258: PUSH
 259: FOR_IN
 260: IFFALSE 301
// if IsOk ( i ) then
 262: LD_VAR 0 4
 266: PPUSH
 267: CALL_OW 302
 271: IFFALSE 299
// begin Say ( i , ident ) ;
 273: LD_VAR 0 4
 277: PPUSH
 278: LD_VAR 0 2
 282: PPUSH
 283: CALL_OW 88
// result := i ;
 287: LD_ADDR_VAR 0 3
 291: PUSH
 292: LD_VAR 0 4
 296: ST_TO_ADDR
// break ;
 297: GO 301
// end ;
 299: GO 259
 301: POP
 302: POP
// end ;
 303: LD_VAR 0 3
 307: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 308: LD_INT 0
 310: PPUSH
 311: PPUSH
// InitUc ;
 312: CALL_OW 18
// InitHc ;
 316: CALL_OW 19
// uc_side := 0 ;
 320: LD_ADDR_OWVAR 20
 324: PUSH
 325: LD_INT 0
 327: ST_TO_ADDR
// uc_nation := 0 ;
 328: LD_ADDR_OWVAR 21
 332: PUSH
 333: LD_INT 0
 335: ST_TO_ADDR
// for i = 1 to amount do
 336: LD_ADDR_VAR 0 4
 340: PUSH
 341: DOUBLE
 342: LD_INT 1
 344: DEC
 345: ST_TO_ADDR
 346: LD_VAR 0 2
 350: PUSH
 351: FOR_TO
 352: IFFALSE 434
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 354: LD_ADDR_OWVAR 29
 358: PUSH
 359: LD_INT 9
 361: PPUSH
 362: LD_INT 12
 364: PPUSH
 365: CALL_OW 12
 369: PUSH
 370: LD_INT 9
 372: PPUSH
 373: LD_INT 12
 375: PPUSH
 376: CALL_OW 12
 380: PUSH
 381: EMPTY
 382: LIST
 383: LIST
 384: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 385: LD_ADDR_OWVAR 35
 389: PUSH
 390: LD_INT 5
 392: NEG
 393: PPUSH
 394: LD_INT 5
 396: PPUSH
 397: CALL_OW 12
 401: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 402: LD_INT 0
 404: PPUSH
 405: LD_INT 12
 407: PPUSH
 408: LD_INT 1
 410: PPUSH
 411: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 415: CALL_OW 44
 419: PPUSH
 420: LD_VAR 0 1
 424: PPUSH
 425: LD_INT 0
 427: PPUSH
 428: CALL_OW 49
// end ;
 432: GO 351
 434: POP
 435: POP
// InitHc ;
 436: CALL_OW 19
// end ; end_of_file
 440: LD_VAR 0 3
 444: RET
// export Gladstone , Lynch ; export function PrepareAmericans ; var i , veh , tmp ; begin
 445: LD_INT 0
 447: PPUSH
 448: PPUSH
 449: PPUSH
 450: PPUSH
// SetBName ( Delta , Delta ) ;
 451: LD_INT 1
 453: PPUSH
 454: LD_STRING Delta
 456: PPUSH
 457: CALL_OW 500
// uc_side := 1 ;
 461: LD_ADDR_OWVAR 20
 465: PUSH
 466: LD_INT 1
 468: ST_TO_ADDR
// uc_nation := 1 ;
 469: LD_ADDR_OWVAR 21
 473: PUSH
 474: LD_INT 1
 476: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 477: LD_ADDR_EXP 3
 481: PUSH
 482: LD_STRING Lynch
 484: PPUSH
 485: LD_INT 0
 487: PPUSH
 488: LD_STRING 
 490: PPUSH
 491: CALL 77 0 3
 495: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 496: LD_ADDR_EXP 2
 500: PUSH
 501: LD_STRING Gladstone
 503: PPUSH
 504: LD_INT 0
 506: PPUSH
 507: LD_STRING 
 509: PPUSH
 510: CALL 77 0 3
 514: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 515: LD_EXP 3
 519: PPUSH
 520: LD_INT 1
 522: PPUSH
 523: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 527: LD_EXP 2
 531: PPUSH
 532: LD_INT 3
 534: PPUSH
 535: CALL_OW 52
// end ; end_of_file
 539: LD_VAR 0 1
 543: RET
// export function Action ; begin
 544: LD_INT 0
 546: PPUSH
// end ; end_of_file
 547: LD_VAR 0 1
 551: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia ; export function PrepareArabian ; begin
 552: LD_INT 0
 554: PPUSH
// uc_side := 2 ;
 555: LD_ADDR_OWVAR 20
 559: PUSH
 560: LD_INT 2
 562: ST_TO_ADDR
// uc_nation := 2 ;
 563: LD_ADDR_OWVAR 21
 567: PUSH
 568: LD_INT 2
 570: ST_TO_ADDR
// end ; end_of_file end_of_file
 571: LD_VAR 0 1
 575: RET
// on UnitDestroyed ( un ) do begin end ; end_of_file
 576: PPOPN 1
 578: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
 579: GO 581
 581: DISABLE
// begin ru_radar := 98 ;
 582: LD_ADDR_EXP 10
 586: PUSH
 587: LD_INT 98
 589: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
 590: LD_ADDR_EXP 11
 594: PUSH
 595: LD_INT 89
 597: ST_TO_ADDR
// us_hack := 99 ;
 598: LD_ADDR_EXP 12
 602: PUSH
 603: LD_INT 99
 605: ST_TO_ADDR
// us_artillery := 97 ;
 606: LD_ADDR_EXP 13
 610: PUSH
 611: LD_INT 97
 613: ST_TO_ADDR
// ar_bio_bomb := 91 ;
 614: LD_ADDR_EXP 14
 618: PUSH
 619: LD_INT 91
 621: ST_TO_ADDR
// end ; end_of_file end_of_file
 622: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
 623: GO 625
 625: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
 626: LD_STRING initStreamRollete();
 628: PPUSH
 629: CALL_OW 559
// InitStreamMode ;
 633: CALL 642 0 0
// DefineStreamItems ( ) ;
 637: CALL 1082 0 0
// end ;
 641: END
// function InitStreamMode ; begin
 642: LD_INT 0
 644: PPUSH
// streamModeActive := false ;
 645: LD_ADDR_EXP 15
 649: PUSH
 650: LD_INT 0
 652: ST_TO_ADDR
// normalCounter := 36 ;
 653: LD_ADDR_EXP 16
 657: PUSH
 658: LD_INT 36
 660: ST_TO_ADDR
// hardcoreCounter := 16 ;
 661: LD_ADDR_EXP 17
 665: PUSH
 666: LD_INT 16
 668: ST_TO_ADDR
// sRocket := false ;
 669: LD_ADDR_EXP 20
 673: PUSH
 674: LD_INT 0
 676: ST_TO_ADDR
// sSpeed := false ;
 677: LD_ADDR_EXP 19
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// sEngine := false ;
 685: LD_ADDR_EXP 21
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// sSpec := false ;
 693: LD_ADDR_EXP 18
 697: PUSH
 698: LD_INT 0
 700: ST_TO_ADDR
// sLevel := false ;
 701: LD_ADDR_EXP 22
 705: PUSH
 706: LD_INT 0
 708: ST_TO_ADDR
// sArmoury := false ;
 709: LD_ADDR_EXP 23
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// sRadar := false ;
 717: LD_ADDR_EXP 24
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// sBunker := false ;
 725: LD_ADDR_EXP 25
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// sHack := false ;
 733: LD_ADDR_EXP 26
 737: PUSH
 738: LD_INT 0
 740: ST_TO_ADDR
// sFire := false ;
 741: LD_ADDR_EXP 27
 745: PUSH
 746: LD_INT 0
 748: ST_TO_ADDR
// sRefresh := false ;
 749: LD_ADDR_EXP 28
 753: PUSH
 754: LD_INT 0
 756: ST_TO_ADDR
// sExp := false ;
 757: LD_ADDR_EXP 29
 761: PUSH
 762: LD_INT 0
 764: ST_TO_ADDR
// sDepot := false ;
 765: LD_ADDR_EXP 30
 769: PUSH
 770: LD_INT 0
 772: ST_TO_ADDR
// sFlag := false ;
 773: LD_ADDR_EXP 31
 777: PUSH
 778: LD_INT 0
 780: ST_TO_ADDR
// sKamikadze := false ;
 781: LD_ADDR_EXP 39
 785: PUSH
 786: LD_INT 0
 788: ST_TO_ADDR
// sTroll := false ;
 789: LD_ADDR_EXP 40
 793: PUSH
 794: LD_INT 0
 796: ST_TO_ADDR
// sSlow := false ;
 797: LD_ADDR_EXP 41
 801: PUSH
 802: LD_INT 0
 804: ST_TO_ADDR
// sLack := false ;
 805: LD_ADDR_EXP 42
 809: PUSH
 810: LD_INT 0
 812: ST_TO_ADDR
// sTank := false ;
 813: LD_ADDR_EXP 44
 817: PUSH
 818: LD_INT 0
 820: ST_TO_ADDR
// sRemote := false ;
 821: LD_ADDR_EXP 45
 825: PUSH
 826: LD_INT 0
 828: ST_TO_ADDR
// sPowell := false ;
 829: LD_ADDR_EXP 46
 833: PUSH
 834: LD_INT 0
 836: ST_TO_ADDR
// sTeleport := false ;
 837: LD_ADDR_EXP 49
 841: PUSH
 842: LD_INT 0
 844: ST_TO_ADDR
// sOilTower := false ;
 845: LD_ADDR_EXP 51
 849: PUSH
 850: LD_INT 0
 852: ST_TO_ADDR
// sShovel := false ;
 853: LD_ADDR_EXP 52
 857: PUSH
 858: LD_INT 0
 860: ST_TO_ADDR
// sSheik := false ;
 861: LD_ADDR_EXP 53
 865: PUSH
 866: LD_INT 0
 868: ST_TO_ADDR
// sEarthquake := false ;
 869: LD_ADDR_EXP 55
 873: PUSH
 874: LD_INT 0
 876: ST_TO_ADDR
// sAI := false ;
 877: LD_ADDR_EXP 56
 881: PUSH
 882: LD_INT 0
 884: ST_TO_ADDR
// sCargo := false ;
 885: LD_ADDR_EXP 59
 889: PUSH
 890: LD_INT 0
 892: ST_TO_ADDR
// sDLaser := false ;
 893: LD_ADDR_EXP 60
 897: PUSH
 898: LD_INT 0
 900: ST_TO_ADDR
// sExchange := false ;
 901: LD_ADDR_EXP 61
 905: PUSH
 906: LD_INT 0
 908: ST_TO_ADDR
// sFac := false ;
 909: LD_ADDR_EXP 62
 913: PUSH
 914: LD_INT 0
 916: ST_TO_ADDR
// sPower := false ;
 917: LD_ADDR_EXP 63
 921: PUSH
 922: LD_INT 0
 924: ST_TO_ADDR
// sRandom := false ;
 925: LD_ADDR_EXP 64
 929: PUSH
 930: LD_INT 0
 932: ST_TO_ADDR
// sShield := false ;
 933: LD_ADDR_EXP 65
 937: PUSH
 938: LD_INT 0
 940: ST_TO_ADDR
// sTime := false ;
 941: LD_ADDR_EXP 66
 945: PUSH
 946: LD_INT 0
 948: ST_TO_ADDR
// sTools := false ;
 949: LD_ADDR_EXP 67
 953: PUSH
 954: LD_INT 0
 956: ST_TO_ADDR
// sSold := false ;
 957: LD_ADDR_EXP 32
 961: PUSH
 962: LD_INT 0
 964: ST_TO_ADDR
// sDiff := false ;
 965: LD_ADDR_EXP 33
 969: PUSH
 970: LD_INT 0
 972: ST_TO_ADDR
// sFog := false ;
 973: LD_ADDR_EXP 36
 977: PUSH
 978: LD_INT 0
 980: ST_TO_ADDR
// sReset := false ;
 981: LD_ADDR_EXP 37
 985: PUSH
 986: LD_INT 0
 988: ST_TO_ADDR
// sSun := false ;
 989: LD_ADDR_EXP 38
 993: PUSH
 994: LD_INT 0
 996: ST_TO_ADDR
// sTiger := false ;
 997: LD_ADDR_EXP 34
1001: PUSH
1002: LD_INT 0
1004: ST_TO_ADDR
// sBomb := false ;
1005: LD_ADDR_EXP 35
1009: PUSH
1010: LD_INT 0
1012: ST_TO_ADDR
// sWound := false ;
1013: LD_ADDR_EXP 43
1017: PUSH
1018: LD_INT 0
1020: ST_TO_ADDR
// sBetray := false ;
1021: LD_ADDR_EXP 47
1025: PUSH
1026: LD_INT 0
1028: ST_TO_ADDR
// sContamin := false ;
1029: LD_ADDR_EXP 48
1033: PUSH
1034: LD_INT 0
1036: ST_TO_ADDR
// sOil := false ;
1037: LD_ADDR_EXP 50
1041: PUSH
1042: LD_INT 0
1044: ST_TO_ADDR
// sStu := false ;
1045: LD_ADDR_EXP 54
1049: PUSH
1050: LD_INT 0
1052: ST_TO_ADDR
// sBazooka := false ;
1053: LD_ADDR_EXP 57
1057: PUSH
1058: LD_INT 0
1060: ST_TO_ADDR
// sMortar := false ;
1061: LD_ADDR_EXP 58
1065: PUSH
1066: LD_INT 0
1068: ST_TO_ADDR
// sRanger := false ;
1069: LD_ADDR_EXP 68
1073: PUSH
1074: LD_INT 0
1076: ST_TO_ADDR
// end ;
1077: LD_VAR 0 1
1081: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
1082: LD_INT 0
1084: PPUSH
1085: PPUSH
1086: PPUSH
1087: PPUSH
1088: PPUSH
// result := [ ] ;
1089: LD_ADDR_VAR 0 1
1093: PUSH
1094: EMPTY
1095: ST_TO_ADDR
// if campaign_id = 1 then
1096: LD_OWVAR 69
1100: PUSH
1101: LD_INT 1
1103: EQUAL
1104: IFFALSE 4042
// begin case mission_number of 1 :
1106: LD_OWVAR 70
1110: PUSH
1111: LD_INT 1
1113: DOUBLE
1114: EQUAL
1115: IFTRUE 1119
1117: GO 1183
1119: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
1120: LD_ADDR_VAR 0 1
1124: PUSH
1125: LD_INT 2
1127: PUSH
1128: LD_INT 4
1130: PUSH
1131: LD_INT 11
1133: PUSH
1134: LD_INT 12
1136: PUSH
1137: LD_INT 15
1139: PUSH
1140: LD_INT 16
1142: PUSH
1143: LD_INT 22
1145: PUSH
1146: LD_INT 23
1148: PUSH
1149: LD_INT 26
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: LIST
1162: PUSH
1163: LD_INT 101
1165: PUSH
1166: LD_INT 102
1168: PUSH
1169: LD_INT 106
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: LIST
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: ST_TO_ADDR
1181: GO 4040
1183: LD_INT 2
1185: DOUBLE
1186: EQUAL
1187: IFTRUE 1191
1189: GO 1263
1191: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
1192: LD_ADDR_VAR 0 1
1196: PUSH
1197: LD_INT 2
1199: PUSH
1200: LD_INT 4
1202: PUSH
1203: LD_INT 11
1205: PUSH
1206: LD_INT 12
1208: PUSH
1209: LD_INT 15
1211: PUSH
1212: LD_INT 16
1214: PUSH
1215: LD_INT 22
1217: PUSH
1218: LD_INT 23
1220: PUSH
1221: LD_INT 26
1223: PUSH
1224: EMPTY
1225: LIST
1226: LIST
1227: LIST
1228: LIST
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: LIST
1234: PUSH
1235: LD_INT 101
1237: PUSH
1238: LD_INT 102
1240: PUSH
1241: LD_INT 105
1243: PUSH
1244: LD_INT 106
1246: PUSH
1247: LD_INT 108
1249: PUSH
1250: EMPTY
1251: LIST
1252: LIST
1253: LIST
1254: LIST
1255: LIST
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: ST_TO_ADDR
1261: GO 4040
1263: LD_INT 3
1265: DOUBLE
1266: EQUAL
1267: IFTRUE 1271
1269: GO 1347
1271: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
1272: LD_ADDR_VAR 0 1
1276: PUSH
1277: LD_INT 2
1279: PUSH
1280: LD_INT 4
1282: PUSH
1283: LD_INT 5
1285: PUSH
1286: LD_INT 11
1288: PUSH
1289: LD_INT 12
1291: PUSH
1292: LD_INT 15
1294: PUSH
1295: LD_INT 16
1297: PUSH
1298: LD_INT 22
1300: PUSH
1301: LD_INT 26
1303: PUSH
1304: LD_INT 36
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: PUSH
1319: LD_INT 101
1321: PUSH
1322: LD_INT 102
1324: PUSH
1325: LD_INT 105
1327: PUSH
1328: LD_INT 106
1330: PUSH
1331: LD_INT 108
1333: PUSH
1334: EMPTY
1335: LIST
1336: LIST
1337: LIST
1338: LIST
1339: LIST
1340: PUSH
1341: EMPTY
1342: LIST
1343: LIST
1344: ST_TO_ADDR
1345: GO 4040
1347: LD_INT 4
1349: DOUBLE
1350: EQUAL
1351: IFTRUE 1355
1353: GO 1439
1355: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
1356: LD_ADDR_VAR 0 1
1360: PUSH
1361: LD_INT 2
1363: PUSH
1364: LD_INT 4
1366: PUSH
1367: LD_INT 5
1369: PUSH
1370: LD_INT 8
1372: PUSH
1373: LD_INT 11
1375: PUSH
1376: LD_INT 12
1378: PUSH
1379: LD_INT 15
1381: PUSH
1382: LD_INT 16
1384: PUSH
1385: LD_INT 22
1387: PUSH
1388: LD_INT 23
1390: PUSH
1391: LD_INT 26
1393: PUSH
1394: LD_INT 36
1396: PUSH
1397: EMPTY
1398: LIST
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: PUSH
1411: LD_INT 101
1413: PUSH
1414: LD_INT 102
1416: PUSH
1417: LD_INT 105
1419: PUSH
1420: LD_INT 106
1422: PUSH
1423: LD_INT 108
1425: PUSH
1426: EMPTY
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: PUSH
1433: EMPTY
1434: LIST
1435: LIST
1436: ST_TO_ADDR
1437: GO 4040
1439: LD_INT 5
1441: DOUBLE
1442: EQUAL
1443: IFTRUE 1447
1445: GO 1547
1447: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
1448: LD_ADDR_VAR 0 1
1452: PUSH
1453: LD_INT 2
1455: PUSH
1456: LD_INT 4
1458: PUSH
1459: LD_INT 5
1461: PUSH
1462: LD_INT 6
1464: PUSH
1465: LD_INT 8
1467: PUSH
1468: LD_INT 11
1470: PUSH
1471: LD_INT 12
1473: PUSH
1474: LD_INT 15
1476: PUSH
1477: LD_INT 16
1479: PUSH
1480: LD_INT 22
1482: PUSH
1483: LD_INT 23
1485: PUSH
1486: LD_INT 25
1488: PUSH
1489: LD_INT 26
1491: PUSH
1492: LD_INT 36
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: LIST
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: LIST
1507: LIST
1508: LIST
1509: LIST
1510: PUSH
1511: LD_INT 101
1513: PUSH
1514: LD_INT 102
1516: PUSH
1517: LD_INT 105
1519: PUSH
1520: LD_INT 106
1522: PUSH
1523: LD_INT 108
1525: PUSH
1526: LD_INT 109
1528: PUSH
1529: LD_INT 112
1531: PUSH
1532: EMPTY
1533: LIST
1534: LIST
1535: LIST
1536: LIST
1537: LIST
1538: LIST
1539: LIST
1540: PUSH
1541: EMPTY
1542: LIST
1543: LIST
1544: ST_TO_ADDR
1545: GO 4040
1547: LD_INT 6
1549: DOUBLE
1550: EQUAL
1551: IFTRUE 1555
1553: GO 1675
1555: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
1556: LD_ADDR_VAR 0 1
1560: PUSH
1561: LD_INT 2
1563: PUSH
1564: LD_INT 4
1566: PUSH
1567: LD_INT 5
1569: PUSH
1570: LD_INT 6
1572: PUSH
1573: LD_INT 8
1575: PUSH
1576: LD_INT 11
1578: PUSH
1579: LD_INT 12
1581: PUSH
1582: LD_INT 15
1584: PUSH
1585: LD_INT 16
1587: PUSH
1588: LD_INT 20
1590: PUSH
1591: LD_INT 21
1593: PUSH
1594: LD_INT 22
1596: PUSH
1597: LD_INT 23
1599: PUSH
1600: LD_INT 25
1602: PUSH
1603: LD_INT 26
1605: PUSH
1606: LD_INT 30
1608: PUSH
1609: LD_INT 31
1611: PUSH
1612: LD_INT 32
1614: PUSH
1615: LD_INT 36
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: LIST
1622: LIST
1623: LIST
1624: LIST
1625: LIST
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: PUSH
1639: LD_INT 101
1641: PUSH
1642: LD_INT 102
1644: PUSH
1645: LD_INT 105
1647: PUSH
1648: LD_INT 106
1650: PUSH
1651: LD_INT 108
1653: PUSH
1654: LD_INT 109
1656: PUSH
1657: LD_INT 112
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: ST_TO_ADDR
1673: GO 4040
1675: LD_INT 7
1677: DOUBLE
1678: EQUAL
1679: IFTRUE 1683
1681: GO 1783
1683: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
1684: LD_ADDR_VAR 0 1
1688: PUSH
1689: LD_INT 2
1691: PUSH
1692: LD_INT 4
1694: PUSH
1695: LD_INT 5
1697: PUSH
1698: LD_INT 7
1700: PUSH
1701: LD_INT 11
1703: PUSH
1704: LD_INT 12
1706: PUSH
1707: LD_INT 15
1709: PUSH
1710: LD_INT 16
1712: PUSH
1713: LD_INT 20
1715: PUSH
1716: LD_INT 21
1718: PUSH
1719: LD_INT 22
1721: PUSH
1722: LD_INT 23
1724: PUSH
1725: LD_INT 25
1727: PUSH
1728: LD_INT 26
1730: PUSH
1731: EMPTY
1732: LIST
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: LIST
1745: LIST
1746: PUSH
1747: LD_INT 101
1749: PUSH
1750: LD_INT 102
1752: PUSH
1753: LD_INT 103
1755: PUSH
1756: LD_INT 105
1758: PUSH
1759: LD_INT 106
1761: PUSH
1762: LD_INT 108
1764: PUSH
1765: LD_INT 112
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: PUSH
1777: EMPTY
1778: LIST
1779: LIST
1780: ST_TO_ADDR
1781: GO 4040
1783: LD_INT 8
1785: DOUBLE
1786: EQUAL
1787: IFTRUE 1791
1789: GO 1919
1791: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
1792: LD_ADDR_VAR 0 1
1796: PUSH
1797: LD_INT 2
1799: PUSH
1800: LD_INT 4
1802: PUSH
1803: LD_INT 5
1805: PUSH
1806: LD_INT 6
1808: PUSH
1809: LD_INT 7
1811: PUSH
1812: LD_INT 8
1814: PUSH
1815: LD_INT 11
1817: PUSH
1818: LD_INT 12
1820: PUSH
1821: LD_INT 15
1823: PUSH
1824: LD_INT 16
1826: PUSH
1827: LD_INT 20
1829: PUSH
1830: LD_INT 21
1832: PUSH
1833: LD_INT 22
1835: PUSH
1836: LD_INT 23
1838: PUSH
1839: LD_INT 25
1841: PUSH
1842: LD_INT 26
1844: PUSH
1845: LD_INT 30
1847: PUSH
1848: LD_INT 31
1850: PUSH
1851: LD_INT 32
1853: PUSH
1854: LD_INT 36
1856: PUSH
1857: EMPTY
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: PUSH
1879: LD_INT 101
1881: PUSH
1882: LD_INT 102
1884: PUSH
1885: LD_INT 103
1887: PUSH
1888: LD_INT 105
1890: PUSH
1891: LD_INT 106
1893: PUSH
1894: LD_INT 108
1896: PUSH
1897: LD_INT 109
1899: PUSH
1900: LD_INT 112
1902: PUSH
1903: EMPTY
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: ST_TO_ADDR
1917: GO 4040
1919: LD_INT 9
1921: DOUBLE
1922: EQUAL
1923: IFTRUE 1927
1925: GO 2063
1927: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
1928: LD_ADDR_VAR 0 1
1932: PUSH
1933: LD_INT 2
1935: PUSH
1936: LD_INT 4
1938: PUSH
1939: LD_INT 5
1941: PUSH
1942: LD_INT 6
1944: PUSH
1945: LD_INT 7
1947: PUSH
1948: LD_INT 8
1950: PUSH
1951: LD_INT 11
1953: PUSH
1954: LD_INT 12
1956: PUSH
1957: LD_INT 15
1959: PUSH
1960: LD_INT 16
1962: PUSH
1963: LD_INT 20
1965: PUSH
1966: LD_INT 21
1968: PUSH
1969: LD_INT 22
1971: PUSH
1972: LD_INT 23
1974: PUSH
1975: LD_INT 25
1977: PUSH
1978: LD_INT 26
1980: PUSH
1981: LD_INT 28
1983: PUSH
1984: LD_INT 30
1986: PUSH
1987: LD_INT 31
1989: PUSH
1990: LD_INT 32
1992: PUSH
1993: LD_INT 36
1995: PUSH
1996: EMPTY
1997: LIST
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: LIST
2012: LIST
2013: LIST
2014: LIST
2015: LIST
2016: LIST
2017: LIST
2018: PUSH
2019: LD_INT 101
2021: PUSH
2022: LD_INT 102
2024: PUSH
2025: LD_INT 103
2027: PUSH
2028: LD_INT 105
2030: PUSH
2031: LD_INT 106
2033: PUSH
2034: LD_INT 108
2036: PUSH
2037: LD_INT 109
2039: PUSH
2040: LD_INT 112
2042: PUSH
2043: LD_INT 114
2045: PUSH
2046: EMPTY
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: LIST
2056: PUSH
2057: EMPTY
2058: LIST
2059: LIST
2060: ST_TO_ADDR
2061: GO 4040
2063: LD_INT 10
2065: DOUBLE
2066: EQUAL
2067: IFTRUE 2071
2069: GO 2255
2071: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
2072: LD_ADDR_VAR 0 1
2076: PUSH
2077: LD_INT 2
2079: PUSH
2080: LD_INT 4
2082: PUSH
2083: LD_INT 5
2085: PUSH
2086: LD_INT 6
2088: PUSH
2089: LD_INT 7
2091: PUSH
2092: LD_INT 8
2094: PUSH
2095: LD_INT 9
2097: PUSH
2098: LD_INT 10
2100: PUSH
2101: LD_INT 11
2103: PUSH
2104: LD_INT 12
2106: PUSH
2107: LD_INT 13
2109: PUSH
2110: LD_INT 14
2112: PUSH
2113: LD_INT 15
2115: PUSH
2116: LD_INT 16
2118: PUSH
2119: LD_INT 17
2121: PUSH
2122: LD_INT 18
2124: PUSH
2125: LD_INT 19
2127: PUSH
2128: LD_INT 20
2130: PUSH
2131: LD_INT 21
2133: PUSH
2134: LD_INT 22
2136: PUSH
2137: LD_INT 23
2139: PUSH
2140: LD_INT 24
2142: PUSH
2143: LD_INT 25
2145: PUSH
2146: LD_INT 26
2148: PUSH
2149: LD_INT 28
2151: PUSH
2152: LD_INT 30
2154: PUSH
2155: LD_INT 31
2157: PUSH
2158: LD_INT 32
2160: PUSH
2161: LD_INT 36
2163: PUSH
2164: EMPTY
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: LIST
2170: LIST
2171: LIST
2172: LIST
2173: LIST
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: LIST
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: LIST
2189: LIST
2190: LIST
2191: LIST
2192: LIST
2193: LIST
2194: PUSH
2195: LD_INT 101
2197: PUSH
2198: LD_INT 102
2200: PUSH
2201: LD_INT 103
2203: PUSH
2204: LD_INT 104
2206: PUSH
2207: LD_INT 105
2209: PUSH
2210: LD_INT 106
2212: PUSH
2213: LD_INT 107
2215: PUSH
2216: LD_INT 108
2218: PUSH
2219: LD_INT 109
2221: PUSH
2222: LD_INT 110
2224: PUSH
2225: LD_INT 111
2227: PUSH
2228: LD_INT 112
2230: PUSH
2231: LD_INT 114
2233: PUSH
2234: EMPTY
2235: LIST
2236: LIST
2237: LIST
2238: LIST
2239: LIST
2240: LIST
2241: LIST
2242: LIST
2243: LIST
2244: LIST
2245: LIST
2246: LIST
2247: LIST
2248: PUSH
2249: EMPTY
2250: LIST
2251: LIST
2252: ST_TO_ADDR
2253: GO 4040
2255: LD_INT 11
2257: DOUBLE
2258: EQUAL
2259: IFTRUE 2263
2261: GO 2455
2263: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
2264: LD_ADDR_VAR 0 1
2268: PUSH
2269: LD_INT 2
2271: PUSH
2272: LD_INT 3
2274: PUSH
2275: LD_INT 4
2277: PUSH
2278: LD_INT 5
2280: PUSH
2281: LD_INT 6
2283: PUSH
2284: LD_INT 7
2286: PUSH
2287: LD_INT 8
2289: PUSH
2290: LD_INT 9
2292: PUSH
2293: LD_INT 10
2295: PUSH
2296: LD_INT 11
2298: PUSH
2299: LD_INT 12
2301: PUSH
2302: LD_INT 13
2304: PUSH
2305: LD_INT 14
2307: PUSH
2308: LD_INT 15
2310: PUSH
2311: LD_INT 16
2313: PUSH
2314: LD_INT 17
2316: PUSH
2317: LD_INT 18
2319: PUSH
2320: LD_INT 19
2322: PUSH
2323: LD_INT 20
2325: PUSH
2326: LD_INT 21
2328: PUSH
2329: LD_INT 22
2331: PUSH
2332: LD_INT 23
2334: PUSH
2335: LD_INT 24
2337: PUSH
2338: LD_INT 25
2340: PUSH
2341: LD_INT 26
2343: PUSH
2344: LD_INT 28
2346: PUSH
2347: LD_INT 30
2349: PUSH
2350: LD_INT 31
2352: PUSH
2353: LD_INT 32
2355: PUSH
2356: LD_INT 34
2358: PUSH
2359: LD_INT 36
2361: PUSH
2362: EMPTY
2363: LIST
2364: LIST
2365: LIST
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: LIST
2371: LIST
2372: LIST
2373: LIST
2374: LIST
2375: LIST
2376: LIST
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: LIST
2382: LIST
2383: LIST
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: LIST
2390: LIST
2391: LIST
2392: LIST
2393: LIST
2394: PUSH
2395: LD_INT 101
2397: PUSH
2398: LD_INT 102
2400: PUSH
2401: LD_INT 103
2403: PUSH
2404: LD_INT 104
2406: PUSH
2407: LD_INT 105
2409: PUSH
2410: LD_INT 106
2412: PUSH
2413: LD_INT 107
2415: PUSH
2416: LD_INT 108
2418: PUSH
2419: LD_INT 109
2421: PUSH
2422: LD_INT 110
2424: PUSH
2425: LD_INT 111
2427: PUSH
2428: LD_INT 112
2430: PUSH
2431: LD_INT 114
2433: PUSH
2434: EMPTY
2435: LIST
2436: LIST
2437: LIST
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: LIST
2446: LIST
2447: LIST
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: ST_TO_ADDR
2453: GO 4040
2455: LD_INT 12
2457: DOUBLE
2458: EQUAL
2459: IFTRUE 2463
2461: GO 2671
2463: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
2464: LD_ADDR_VAR 0 1
2468: PUSH
2469: LD_INT 1
2471: PUSH
2472: LD_INT 2
2474: PUSH
2475: LD_INT 3
2477: PUSH
2478: LD_INT 4
2480: PUSH
2481: LD_INT 5
2483: PUSH
2484: LD_INT 6
2486: PUSH
2487: LD_INT 7
2489: PUSH
2490: LD_INT 8
2492: PUSH
2493: LD_INT 9
2495: PUSH
2496: LD_INT 10
2498: PUSH
2499: LD_INT 11
2501: PUSH
2502: LD_INT 12
2504: PUSH
2505: LD_INT 13
2507: PUSH
2508: LD_INT 14
2510: PUSH
2511: LD_INT 15
2513: PUSH
2514: LD_INT 16
2516: PUSH
2517: LD_INT 17
2519: PUSH
2520: LD_INT 18
2522: PUSH
2523: LD_INT 19
2525: PUSH
2526: LD_INT 20
2528: PUSH
2529: LD_INT 21
2531: PUSH
2532: LD_INT 22
2534: PUSH
2535: LD_INT 23
2537: PUSH
2538: LD_INT 24
2540: PUSH
2541: LD_INT 25
2543: PUSH
2544: LD_INT 26
2546: PUSH
2547: LD_INT 27
2549: PUSH
2550: LD_INT 28
2552: PUSH
2553: LD_INT 30
2555: PUSH
2556: LD_INT 31
2558: PUSH
2559: LD_INT 32
2561: PUSH
2562: LD_INT 33
2564: PUSH
2565: LD_INT 34
2567: PUSH
2568: LD_INT 36
2570: PUSH
2571: EMPTY
2572: LIST
2573: LIST
2574: LIST
2575: LIST
2576: LIST
2577: LIST
2578: LIST
2579: LIST
2580: LIST
2581: LIST
2582: LIST
2583: LIST
2584: LIST
2585: LIST
2586: LIST
2587: LIST
2588: LIST
2589: LIST
2590: LIST
2591: LIST
2592: LIST
2593: LIST
2594: LIST
2595: LIST
2596: LIST
2597: LIST
2598: LIST
2599: LIST
2600: LIST
2601: LIST
2602: LIST
2603: LIST
2604: LIST
2605: LIST
2606: PUSH
2607: LD_INT 101
2609: PUSH
2610: LD_INT 102
2612: PUSH
2613: LD_INT 103
2615: PUSH
2616: LD_INT 104
2618: PUSH
2619: LD_INT 105
2621: PUSH
2622: LD_INT 106
2624: PUSH
2625: LD_INT 107
2627: PUSH
2628: LD_INT 108
2630: PUSH
2631: LD_INT 109
2633: PUSH
2634: LD_INT 110
2636: PUSH
2637: LD_INT 111
2639: PUSH
2640: LD_INT 112
2642: PUSH
2643: LD_INT 113
2645: PUSH
2646: LD_INT 114
2648: PUSH
2649: EMPTY
2650: LIST
2651: LIST
2652: LIST
2653: LIST
2654: LIST
2655: LIST
2656: LIST
2657: LIST
2658: LIST
2659: LIST
2660: LIST
2661: LIST
2662: LIST
2663: LIST
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: ST_TO_ADDR
2669: GO 4040
2671: LD_INT 13
2673: DOUBLE
2674: EQUAL
2675: IFTRUE 2679
2677: GO 2875
2679: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
2680: LD_ADDR_VAR 0 1
2684: PUSH
2685: LD_INT 1
2687: PUSH
2688: LD_INT 2
2690: PUSH
2691: LD_INT 3
2693: PUSH
2694: LD_INT 4
2696: PUSH
2697: LD_INT 5
2699: PUSH
2700: LD_INT 8
2702: PUSH
2703: LD_INT 9
2705: PUSH
2706: LD_INT 10
2708: PUSH
2709: LD_INT 11
2711: PUSH
2712: LD_INT 12
2714: PUSH
2715: LD_INT 14
2717: PUSH
2718: LD_INT 15
2720: PUSH
2721: LD_INT 16
2723: PUSH
2724: LD_INT 17
2726: PUSH
2727: LD_INT 18
2729: PUSH
2730: LD_INT 19
2732: PUSH
2733: LD_INT 20
2735: PUSH
2736: LD_INT 21
2738: PUSH
2739: LD_INT 22
2741: PUSH
2742: LD_INT 23
2744: PUSH
2745: LD_INT 24
2747: PUSH
2748: LD_INT 25
2750: PUSH
2751: LD_INT 26
2753: PUSH
2754: LD_INT 27
2756: PUSH
2757: LD_INT 28
2759: PUSH
2760: LD_INT 30
2762: PUSH
2763: LD_INT 31
2765: PUSH
2766: LD_INT 32
2768: PUSH
2769: LD_INT 33
2771: PUSH
2772: LD_INT 34
2774: PUSH
2775: LD_INT 36
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: LIST
2786: LIST
2787: LIST
2788: LIST
2789: LIST
2790: LIST
2791: LIST
2792: LIST
2793: LIST
2794: LIST
2795: LIST
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: LIST
2801: LIST
2802: LIST
2803: LIST
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_INT 101
2813: PUSH
2814: LD_INT 102
2816: PUSH
2817: LD_INT 103
2819: PUSH
2820: LD_INT 104
2822: PUSH
2823: LD_INT 105
2825: PUSH
2826: LD_INT 106
2828: PUSH
2829: LD_INT 107
2831: PUSH
2832: LD_INT 108
2834: PUSH
2835: LD_INT 109
2837: PUSH
2838: LD_INT 110
2840: PUSH
2841: LD_INT 111
2843: PUSH
2844: LD_INT 112
2846: PUSH
2847: LD_INT 113
2849: PUSH
2850: LD_INT 114
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: LIST
2861: LIST
2862: LIST
2863: LIST
2864: LIST
2865: LIST
2866: LIST
2867: LIST
2868: PUSH
2869: EMPTY
2870: LIST
2871: LIST
2872: ST_TO_ADDR
2873: GO 4040
2875: LD_INT 14
2877: DOUBLE
2878: EQUAL
2879: IFTRUE 2883
2881: GO 3095
2883: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
2884: LD_ADDR_VAR 0 1
2888: PUSH
2889: LD_INT 1
2891: PUSH
2892: LD_INT 2
2894: PUSH
2895: LD_INT 3
2897: PUSH
2898: LD_INT 4
2900: PUSH
2901: LD_INT 5
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: LD_INT 7
2909: PUSH
2910: LD_INT 8
2912: PUSH
2913: LD_INT 9
2915: PUSH
2916: LD_INT 10
2918: PUSH
2919: LD_INT 11
2921: PUSH
2922: LD_INT 12
2924: PUSH
2925: LD_INT 13
2927: PUSH
2928: LD_INT 14
2930: PUSH
2931: LD_INT 15
2933: PUSH
2934: LD_INT 16
2936: PUSH
2937: LD_INT 17
2939: PUSH
2940: LD_INT 18
2942: PUSH
2943: LD_INT 19
2945: PUSH
2946: LD_INT 20
2948: PUSH
2949: LD_INT 21
2951: PUSH
2952: LD_INT 22
2954: PUSH
2955: LD_INT 23
2957: PUSH
2958: LD_INT 24
2960: PUSH
2961: LD_INT 25
2963: PUSH
2964: LD_INT 26
2966: PUSH
2967: LD_INT 27
2969: PUSH
2970: LD_INT 28
2972: PUSH
2973: LD_INT 29
2975: PUSH
2976: LD_INT 30
2978: PUSH
2979: LD_INT 31
2981: PUSH
2982: LD_INT 32
2984: PUSH
2985: LD_INT 33
2987: PUSH
2988: LD_INT 34
2990: PUSH
2991: LD_INT 36
2993: PUSH
2994: EMPTY
2995: LIST
2996: LIST
2997: LIST
2998: LIST
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: LIST
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: LIST
3009: LIST
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: LIST
3016: LIST
3017: LIST
3018: LIST
3019: LIST
3020: LIST
3021: LIST
3022: LIST
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: LIST
3028: LIST
3029: LIST
3030: PUSH
3031: LD_INT 101
3033: PUSH
3034: LD_INT 102
3036: PUSH
3037: LD_INT 103
3039: PUSH
3040: LD_INT 104
3042: PUSH
3043: LD_INT 105
3045: PUSH
3046: LD_INT 106
3048: PUSH
3049: LD_INT 107
3051: PUSH
3052: LD_INT 108
3054: PUSH
3055: LD_INT 109
3057: PUSH
3058: LD_INT 110
3060: PUSH
3061: LD_INT 111
3063: PUSH
3064: LD_INT 112
3066: PUSH
3067: LD_INT 113
3069: PUSH
3070: LD_INT 114
3072: PUSH
3073: EMPTY
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: LIST
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: ST_TO_ADDR
3093: GO 4040
3095: LD_INT 15
3097: DOUBLE
3098: EQUAL
3099: IFTRUE 3103
3101: GO 3315
3103: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
3104: LD_ADDR_VAR 0 1
3108: PUSH
3109: LD_INT 1
3111: PUSH
3112: LD_INT 2
3114: PUSH
3115: LD_INT 3
3117: PUSH
3118: LD_INT 4
3120: PUSH
3121: LD_INT 5
3123: PUSH
3124: LD_INT 6
3126: PUSH
3127: LD_INT 7
3129: PUSH
3130: LD_INT 8
3132: PUSH
3133: LD_INT 9
3135: PUSH
3136: LD_INT 10
3138: PUSH
3139: LD_INT 11
3141: PUSH
3142: LD_INT 12
3144: PUSH
3145: LD_INT 13
3147: PUSH
3148: LD_INT 14
3150: PUSH
3151: LD_INT 15
3153: PUSH
3154: LD_INT 16
3156: PUSH
3157: LD_INT 17
3159: PUSH
3160: LD_INT 18
3162: PUSH
3163: LD_INT 19
3165: PUSH
3166: LD_INT 20
3168: PUSH
3169: LD_INT 21
3171: PUSH
3172: LD_INT 22
3174: PUSH
3175: LD_INT 23
3177: PUSH
3178: LD_INT 24
3180: PUSH
3181: LD_INT 25
3183: PUSH
3184: LD_INT 26
3186: PUSH
3187: LD_INT 27
3189: PUSH
3190: LD_INT 28
3192: PUSH
3193: LD_INT 29
3195: PUSH
3196: LD_INT 30
3198: PUSH
3199: LD_INT 31
3201: PUSH
3202: LD_INT 32
3204: PUSH
3205: LD_INT 33
3207: PUSH
3208: LD_INT 34
3210: PUSH
3211: LD_INT 36
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: PUSH
3251: LD_INT 101
3253: PUSH
3254: LD_INT 102
3256: PUSH
3257: LD_INT 103
3259: PUSH
3260: LD_INT 104
3262: PUSH
3263: LD_INT 105
3265: PUSH
3266: LD_INT 106
3268: PUSH
3269: LD_INT 107
3271: PUSH
3272: LD_INT 108
3274: PUSH
3275: LD_INT 109
3277: PUSH
3278: LD_INT 110
3280: PUSH
3281: LD_INT 111
3283: PUSH
3284: LD_INT 112
3286: PUSH
3287: LD_INT 113
3289: PUSH
3290: LD_INT 114
3292: PUSH
3293: EMPTY
3294: LIST
3295: LIST
3296: LIST
3297: LIST
3298: LIST
3299: LIST
3300: LIST
3301: LIST
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: LIST
3307: LIST
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: ST_TO_ADDR
3313: GO 4040
3315: LD_INT 16
3317: DOUBLE
3318: EQUAL
3319: IFTRUE 3323
3321: GO 3447
3323: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
3324: LD_ADDR_VAR 0 1
3328: PUSH
3329: LD_INT 2
3331: PUSH
3332: LD_INT 4
3334: PUSH
3335: LD_INT 5
3337: PUSH
3338: LD_INT 7
3340: PUSH
3341: LD_INT 11
3343: PUSH
3344: LD_INT 12
3346: PUSH
3347: LD_INT 15
3349: PUSH
3350: LD_INT 16
3352: PUSH
3353: LD_INT 20
3355: PUSH
3356: LD_INT 21
3358: PUSH
3359: LD_INT 22
3361: PUSH
3362: LD_INT 23
3364: PUSH
3365: LD_INT 25
3367: PUSH
3368: LD_INT 26
3370: PUSH
3371: LD_INT 30
3373: PUSH
3374: LD_INT 31
3376: PUSH
3377: LD_INT 32
3379: PUSH
3380: LD_INT 33
3382: PUSH
3383: LD_INT 34
3385: PUSH
3386: EMPTY
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: LIST
3397: LIST
3398: LIST
3399: LIST
3400: LIST
3401: LIST
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: PUSH
3407: LD_INT 101
3409: PUSH
3410: LD_INT 102
3412: PUSH
3413: LD_INT 103
3415: PUSH
3416: LD_INT 106
3418: PUSH
3419: LD_INT 108
3421: PUSH
3422: LD_INT 112
3424: PUSH
3425: LD_INT 113
3427: PUSH
3428: LD_INT 114
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: LIST
3440: PUSH
3441: EMPTY
3442: LIST
3443: LIST
3444: ST_TO_ADDR
3445: GO 4040
3447: LD_INT 17
3449: DOUBLE
3450: EQUAL
3451: IFTRUE 3455
3453: GO 3667
3455: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
3456: LD_ADDR_VAR 0 1
3460: PUSH
3461: LD_INT 1
3463: PUSH
3464: LD_INT 2
3466: PUSH
3467: LD_INT 3
3469: PUSH
3470: LD_INT 4
3472: PUSH
3473: LD_INT 5
3475: PUSH
3476: LD_INT 6
3478: PUSH
3479: LD_INT 7
3481: PUSH
3482: LD_INT 8
3484: PUSH
3485: LD_INT 9
3487: PUSH
3488: LD_INT 10
3490: PUSH
3491: LD_INT 11
3493: PUSH
3494: LD_INT 12
3496: PUSH
3497: LD_INT 13
3499: PUSH
3500: LD_INT 14
3502: PUSH
3503: LD_INT 15
3505: PUSH
3506: LD_INT 16
3508: PUSH
3509: LD_INT 17
3511: PUSH
3512: LD_INT 18
3514: PUSH
3515: LD_INT 19
3517: PUSH
3518: LD_INT 20
3520: PUSH
3521: LD_INT 21
3523: PUSH
3524: LD_INT 22
3526: PUSH
3527: LD_INT 23
3529: PUSH
3530: LD_INT 24
3532: PUSH
3533: LD_INT 25
3535: PUSH
3536: LD_INT 26
3538: PUSH
3539: LD_INT 27
3541: PUSH
3542: LD_INT 28
3544: PUSH
3545: LD_INT 29
3547: PUSH
3548: LD_INT 30
3550: PUSH
3551: LD_INT 31
3553: PUSH
3554: LD_INT 32
3556: PUSH
3557: LD_INT 33
3559: PUSH
3560: LD_INT 34
3562: PUSH
3563: LD_INT 36
3565: PUSH
3566: EMPTY
3567: LIST
3568: LIST
3569: LIST
3570: LIST
3571: LIST
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: LIST
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: LIST
3602: PUSH
3603: LD_INT 101
3605: PUSH
3606: LD_INT 102
3608: PUSH
3609: LD_INT 103
3611: PUSH
3612: LD_INT 104
3614: PUSH
3615: LD_INT 105
3617: PUSH
3618: LD_INT 106
3620: PUSH
3621: LD_INT 107
3623: PUSH
3624: LD_INT 108
3626: PUSH
3627: LD_INT 109
3629: PUSH
3630: LD_INT 110
3632: PUSH
3633: LD_INT 111
3635: PUSH
3636: LD_INT 112
3638: PUSH
3639: LD_INT 113
3641: PUSH
3642: LD_INT 114
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: LIST
3649: LIST
3650: LIST
3651: LIST
3652: LIST
3653: LIST
3654: LIST
3655: LIST
3656: LIST
3657: LIST
3658: LIST
3659: LIST
3660: PUSH
3661: EMPTY
3662: LIST
3663: LIST
3664: ST_TO_ADDR
3665: GO 4040
3667: LD_INT 18
3669: DOUBLE
3670: EQUAL
3671: IFTRUE 3675
3673: GO 3811
3675: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
3676: LD_ADDR_VAR 0 1
3680: PUSH
3681: LD_INT 2
3683: PUSH
3684: LD_INT 4
3686: PUSH
3687: LD_INT 5
3689: PUSH
3690: LD_INT 7
3692: PUSH
3693: LD_INT 11
3695: PUSH
3696: LD_INT 12
3698: PUSH
3699: LD_INT 15
3701: PUSH
3702: LD_INT 16
3704: PUSH
3705: LD_INT 20
3707: PUSH
3708: LD_INT 21
3710: PUSH
3711: LD_INT 22
3713: PUSH
3714: LD_INT 23
3716: PUSH
3717: LD_INT 25
3719: PUSH
3720: LD_INT 26
3722: PUSH
3723: LD_INT 30
3725: PUSH
3726: LD_INT 31
3728: PUSH
3729: LD_INT 32
3731: PUSH
3732: LD_INT 33
3734: PUSH
3735: LD_INT 34
3737: PUSH
3738: LD_INT 35
3740: PUSH
3741: LD_INT 36
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: LIST
3748: LIST
3749: LIST
3750: LIST
3751: LIST
3752: LIST
3753: LIST
3754: LIST
3755: LIST
3756: LIST
3757: LIST
3758: LIST
3759: LIST
3760: LIST
3761: LIST
3762: LIST
3763: LIST
3764: LIST
3765: LIST
3766: PUSH
3767: LD_INT 101
3769: PUSH
3770: LD_INT 102
3772: PUSH
3773: LD_INT 103
3775: PUSH
3776: LD_INT 106
3778: PUSH
3779: LD_INT 108
3781: PUSH
3782: LD_INT 112
3784: PUSH
3785: LD_INT 113
3787: PUSH
3788: LD_INT 114
3790: PUSH
3791: LD_INT 115
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: PUSH
3805: EMPTY
3806: LIST
3807: LIST
3808: ST_TO_ADDR
3809: GO 4040
3811: LD_INT 19
3813: DOUBLE
3814: EQUAL
3815: IFTRUE 3819
3817: GO 4039
3819: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
3820: LD_ADDR_VAR 0 1
3824: PUSH
3825: LD_INT 1
3827: PUSH
3828: LD_INT 2
3830: PUSH
3831: LD_INT 3
3833: PUSH
3834: LD_INT 4
3836: PUSH
3837: LD_INT 5
3839: PUSH
3840: LD_INT 6
3842: PUSH
3843: LD_INT 7
3845: PUSH
3846: LD_INT 8
3848: PUSH
3849: LD_INT 9
3851: PUSH
3852: LD_INT 10
3854: PUSH
3855: LD_INT 11
3857: PUSH
3858: LD_INT 12
3860: PUSH
3861: LD_INT 13
3863: PUSH
3864: LD_INT 14
3866: PUSH
3867: LD_INT 15
3869: PUSH
3870: LD_INT 16
3872: PUSH
3873: LD_INT 17
3875: PUSH
3876: LD_INT 18
3878: PUSH
3879: LD_INT 19
3881: PUSH
3882: LD_INT 20
3884: PUSH
3885: LD_INT 21
3887: PUSH
3888: LD_INT 22
3890: PUSH
3891: LD_INT 23
3893: PUSH
3894: LD_INT 24
3896: PUSH
3897: LD_INT 25
3899: PUSH
3900: LD_INT 26
3902: PUSH
3903: LD_INT 27
3905: PUSH
3906: LD_INT 28
3908: PUSH
3909: LD_INT 29
3911: PUSH
3912: LD_INT 30
3914: PUSH
3915: LD_INT 31
3917: PUSH
3918: LD_INT 32
3920: PUSH
3921: LD_INT 33
3923: PUSH
3924: LD_INT 34
3926: PUSH
3927: LD_INT 35
3929: PUSH
3930: LD_INT 36
3932: PUSH
3933: EMPTY
3934: LIST
3935: LIST
3936: LIST
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: LIST
3942: LIST
3943: LIST
3944: LIST
3945: LIST
3946: LIST
3947: LIST
3948: LIST
3949: LIST
3950: LIST
3951: LIST
3952: LIST
3953: LIST
3954: LIST
3955: LIST
3956: LIST
3957: LIST
3958: LIST
3959: LIST
3960: LIST
3961: LIST
3962: LIST
3963: LIST
3964: LIST
3965: LIST
3966: LIST
3967: LIST
3968: LIST
3969: LIST
3970: PUSH
3971: LD_INT 101
3973: PUSH
3974: LD_INT 102
3976: PUSH
3977: LD_INT 103
3979: PUSH
3980: LD_INT 104
3982: PUSH
3983: LD_INT 105
3985: PUSH
3986: LD_INT 106
3988: PUSH
3989: LD_INT 107
3991: PUSH
3992: LD_INT 108
3994: PUSH
3995: LD_INT 109
3997: PUSH
3998: LD_INT 110
4000: PUSH
4001: LD_INT 111
4003: PUSH
4004: LD_INT 112
4006: PUSH
4007: LD_INT 113
4009: PUSH
4010: LD_INT 114
4012: PUSH
4013: LD_INT 115
4015: PUSH
4016: EMPTY
4017: LIST
4018: LIST
4019: LIST
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: ST_TO_ADDR
4037: GO 4040
4039: POP
// end else
4040: GO 4077
// if campaign_id = 5 then
4042: LD_OWVAR 69
4046: PUSH
4047: LD_INT 5
4049: EQUAL
4050: IFFALSE 4077
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
4052: LD_ADDR_VAR 0 1
4056: PUSH
4057: LD_INT 1
4059: PUSH
4060: LD_INT 2
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: LD_INT 100
4069: PUSH
4070: EMPTY
4071: LIST
4072: PUSH
4073: EMPTY
4074: LIST
4075: LIST
4076: ST_TO_ADDR
// end ; if result then
4077: LD_VAR 0 1
4081: IFFALSE 4370
// begin normal :=  ;
4083: LD_ADDR_VAR 0 3
4087: PUSH
4088: LD_STRING 
4090: ST_TO_ADDR
// hardcore :=  ;
4091: LD_ADDR_VAR 0 4
4095: PUSH
4096: LD_STRING 
4098: ST_TO_ADDR
// for i = 1 to normalCounter do
4099: LD_ADDR_VAR 0 5
4103: PUSH
4104: DOUBLE
4105: LD_INT 1
4107: DEC
4108: ST_TO_ADDR
4109: LD_EXP 16
4113: PUSH
4114: FOR_TO
4115: IFFALSE 4216
// begin tmp := 0 ;
4117: LD_ADDR_VAR 0 2
4121: PUSH
4122: LD_STRING 0
4124: ST_TO_ADDR
// if result [ 1 ] then
4125: LD_VAR 0 1
4129: PUSH
4130: LD_INT 1
4132: ARRAY
4133: IFFALSE 4198
// if result [ 1 ] [ 1 ] = i then
4135: LD_VAR 0 1
4139: PUSH
4140: LD_INT 1
4142: ARRAY
4143: PUSH
4144: LD_INT 1
4146: ARRAY
4147: PUSH
4148: LD_VAR 0 5
4152: EQUAL
4153: IFFALSE 4198
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
4155: LD_ADDR_VAR 0 1
4159: PUSH
4160: LD_VAR 0 1
4164: PPUSH
4165: LD_INT 1
4167: PPUSH
4168: LD_VAR 0 1
4172: PUSH
4173: LD_INT 1
4175: ARRAY
4176: PPUSH
4177: LD_INT 1
4179: PPUSH
4180: CALL_OW 3
4184: PPUSH
4185: CALL_OW 1
4189: ST_TO_ADDR
// tmp := 1 ;
4190: LD_ADDR_VAR 0 2
4194: PUSH
4195: LD_STRING 1
4197: ST_TO_ADDR
// end ; normal := normal & tmp ;
4198: LD_ADDR_VAR 0 3
4202: PUSH
4203: LD_VAR 0 3
4207: PUSH
4208: LD_VAR 0 2
4212: STR
4213: ST_TO_ADDR
// end ;
4214: GO 4114
4216: POP
4217: POP
// for i = 1 to hardcoreCounter do
4218: LD_ADDR_VAR 0 5
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_EXP 17
4232: PUSH
4233: FOR_TO
4234: IFFALSE 4339
// begin tmp := 0 ;
4236: LD_ADDR_VAR 0 2
4240: PUSH
4241: LD_STRING 0
4243: ST_TO_ADDR
// if result [ 2 ] then
4244: LD_VAR 0 1
4248: PUSH
4249: LD_INT 2
4251: ARRAY
4252: IFFALSE 4321
// if result [ 2 ] [ 1 ] = 100 + i then
4254: LD_VAR 0 1
4258: PUSH
4259: LD_INT 2
4261: ARRAY
4262: PUSH
4263: LD_INT 1
4265: ARRAY
4266: PUSH
4267: LD_INT 100
4269: PUSH
4270: LD_VAR 0 5
4274: PLUS
4275: EQUAL
4276: IFFALSE 4321
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
4278: LD_ADDR_VAR 0 1
4282: PUSH
4283: LD_VAR 0 1
4287: PPUSH
4288: LD_INT 2
4290: PPUSH
4291: LD_VAR 0 1
4295: PUSH
4296: LD_INT 2
4298: ARRAY
4299: PPUSH
4300: LD_INT 1
4302: PPUSH
4303: CALL_OW 3
4307: PPUSH
4308: CALL_OW 1
4312: ST_TO_ADDR
// tmp := 1 ;
4313: LD_ADDR_VAR 0 2
4317: PUSH
4318: LD_STRING 1
4320: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
4321: LD_ADDR_VAR 0 4
4325: PUSH
4326: LD_VAR 0 4
4330: PUSH
4331: LD_VAR 0 2
4335: STR
4336: ST_TO_ADDR
// end ;
4337: GO 4233
4339: POP
4340: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
4341: LD_STRING getStreamItemsFromMission("
4343: PUSH
4344: LD_VAR 0 3
4348: STR
4349: PUSH
4350: LD_STRING ","
4352: STR
4353: PUSH
4354: LD_VAR 0 4
4358: STR
4359: PUSH
4360: LD_STRING ")
4362: STR
4363: PPUSH
4364: CALL_OW 559
// end else
4368: GO 4377
// ToLua ( getStreamItemsFromMission("","") ) ;
4370: LD_STRING getStreamItemsFromMission("","")
4372: PPUSH
4373: CALL_OW 559
// end ;
4377: LD_VAR 0 1
4381: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
4382: LD_VAR 0 2
4386: PUSH
4387: LD_INT 100
4389: EQUAL
4390: IFFALSE 5339
// begin if not StreamModeActive then
4392: LD_EXP 15
4396: NOT
4397: IFFALSE 4407
// StreamModeActive := true ;
4399: LD_ADDR_EXP 15
4403: PUSH
4404: LD_INT 1
4406: ST_TO_ADDR
// if p3 = 0 then
4407: LD_VAR 0 3
4411: PUSH
4412: LD_INT 0
4414: EQUAL
4415: IFFALSE 4421
// InitStreamMode ;
4417: CALL 642 0 0
// if p3 = 1 then
4421: LD_VAR 0 3
4425: PUSH
4426: LD_INT 1
4428: EQUAL
4429: IFFALSE 4439
// sRocket := true ;
4431: LD_ADDR_EXP 20
4435: PUSH
4436: LD_INT 1
4438: ST_TO_ADDR
// if p3 = 2 then
4439: LD_VAR 0 3
4443: PUSH
4444: LD_INT 2
4446: EQUAL
4447: IFFALSE 4457
// sSpeed := true ;
4449: LD_ADDR_EXP 19
4453: PUSH
4454: LD_INT 1
4456: ST_TO_ADDR
// if p3 = 3 then
4457: LD_VAR 0 3
4461: PUSH
4462: LD_INT 3
4464: EQUAL
4465: IFFALSE 4475
// sEngine := true ;
4467: LD_ADDR_EXP 21
4471: PUSH
4472: LD_INT 1
4474: ST_TO_ADDR
// if p3 = 4 then
4475: LD_VAR 0 3
4479: PUSH
4480: LD_INT 4
4482: EQUAL
4483: IFFALSE 4493
// sSpec := true ;
4485: LD_ADDR_EXP 18
4489: PUSH
4490: LD_INT 1
4492: ST_TO_ADDR
// if p3 = 5 then
4493: LD_VAR 0 3
4497: PUSH
4498: LD_INT 5
4500: EQUAL
4501: IFFALSE 4511
// sLevel := true ;
4503: LD_ADDR_EXP 22
4507: PUSH
4508: LD_INT 1
4510: ST_TO_ADDR
// if p3 = 6 then
4511: LD_VAR 0 3
4515: PUSH
4516: LD_INT 6
4518: EQUAL
4519: IFFALSE 4529
// sArmoury := true ;
4521: LD_ADDR_EXP 23
4525: PUSH
4526: LD_INT 1
4528: ST_TO_ADDR
// if p3 = 7 then
4529: LD_VAR 0 3
4533: PUSH
4534: LD_INT 7
4536: EQUAL
4537: IFFALSE 4547
// sRadar := true ;
4539: LD_ADDR_EXP 24
4543: PUSH
4544: LD_INT 1
4546: ST_TO_ADDR
// if p3 = 8 then
4547: LD_VAR 0 3
4551: PUSH
4552: LD_INT 8
4554: EQUAL
4555: IFFALSE 4565
// sBunker := true ;
4557: LD_ADDR_EXP 25
4561: PUSH
4562: LD_INT 1
4564: ST_TO_ADDR
// if p3 = 9 then
4565: LD_VAR 0 3
4569: PUSH
4570: LD_INT 9
4572: EQUAL
4573: IFFALSE 4583
// sHack := true ;
4575: LD_ADDR_EXP 26
4579: PUSH
4580: LD_INT 1
4582: ST_TO_ADDR
// if p3 = 10 then
4583: LD_VAR 0 3
4587: PUSH
4588: LD_INT 10
4590: EQUAL
4591: IFFALSE 4601
// sFire := true ;
4593: LD_ADDR_EXP 27
4597: PUSH
4598: LD_INT 1
4600: ST_TO_ADDR
// if p3 = 11 then
4601: LD_VAR 0 3
4605: PUSH
4606: LD_INT 11
4608: EQUAL
4609: IFFALSE 4619
// sRefresh := true ;
4611: LD_ADDR_EXP 28
4615: PUSH
4616: LD_INT 1
4618: ST_TO_ADDR
// if p3 = 12 then
4619: LD_VAR 0 3
4623: PUSH
4624: LD_INT 12
4626: EQUAL
4627: IFFALSE 4637
// sExp := true ;
4629: LD_ADDR_EXP 29
4633: PUSH
4634: LD_INT 1
4636: ST_TO_ADDR
// if p3 = 13 then
4637: LD_VAR 0 3
4641: PUSH
4642: LD_INT 13
4644: EQUAL
4645: IFFALSE 4655
// sDepot := true ;
4647: LD_ADDR_EXP 30
4651: PUSH
4652: LD_INT 1
4654: ST_TO_ADDR
// if p3 = 14 then
4655: LD_VAR 0 3
4659: PUSH
4660: LD_INT 14
4662: EQUAL
4663: IFFALSE 4673
// sFlag := true ;
4665: LD_ADDR_EXP 31
4669: PUSH
4670: LD_INT 1
4672: ST_TO_ADDR
// if p3 = 15 then
4673: LD_VAR 0 3
4677: PUSH
4678: LD_INT 15
4680: EQUAL
4681: IFFALSE 4691
// sKamikadze := true ;
4683: LD_ADDR_EXP 39
4687: PUSH
4688: LD_INT 1
4690: ST_TO_ADDR
// if p3 = 16 then
4691: LD_VAR 0 3
4695: PUSH
4696: LD_INT 16
4698: EQUAL
4699: IFFALSE 4709
// sTroll := true ;
4701: LD_ADDR_EXP 40
4705: PUSH
4706: LD_INT 1
4708: ST_TO_ADDR
// if p3 = 17 then
4709: LD_VAR 0 3
4713: PUSH
4714: LD_INT 17
4716: EQUAL
4717: IFFALSE 4727
// sSlow := true ;
4719: LD_ADDR_EXP 41
4723: PUSH
4724: LD_INT 1
4726: ST_TO_ADDR
// if p3 = 18 then
4727: LD_VAR 0 3
4731: PUSH
4732: LD_INT 18
4734: EQUAL
4735: IFFALSE 4745
// sLack := true ;
4737: LD_ADDR_EXP 42
4741: PUSH
4742: LD_INT 1
4744: ST_TO_ADDR
// if p3 = 19 then
4745: LD_VAR 0 3
4749: PUSH
4750: LD_INT 19
4752: EQUAL
4753: IFFALSE 4763
// sTank := true ;
4755: LD_ADDR_EXP 44
4759: PUSH
4760: LD_INT 1
4762: ST_TO_ADDR
// if p3 = 20 then
4763: LD_VAR 0 3
4767: PUSH
4768: LD_INT 20
4770: EQUAL
4771: IFFALSE 4781
// sRemote := true ;
4773: LD_ADDR_EXP 45
4777: PUSH
4778: LD_INT 1
4780: ST_TO_ADDR
// if p3 = 21 then
4781: LD_VAR 0 3
4785: PUSH
4786: LD_INT 21
4788: EQUAL
4789: IFFALSE 4799
// sPowell := true ;
4791: LD_ADDR_EXP 46
4795: PUSH
4796: LD_INT 1
4798: ST_TO_ADDR
// if p3 = 22 then
4799: LD_VAR 0 3
4803: PUSH
4804: LD_INT 22
4806: EQUAL
4807: IFFALSE 4817
// sTeleport := true ;
4809: LD_ADDR_EXP 49
4813: PUSH
4814: LD_INT 1
4816: ST_TO_ADDR
// if p3 = 23 then
4817: LD_VAR 0 3
4821: PUSH
4822: LD_INT 23
4824: EQUAL
4825: IFFALSE 4835
// sOilTower := true ;
4827: LD_ADDR_EXP 51
4831: PUSH
4832: LD_INT 1
4834: ST_TO_ADDR
// if p3 = 24 then
4835: LD_VAR 0 3
4839: PUSH
4840: LD_INT 24
4842: EQUAL
4843: IFFALSE 4853
// sShovel := true ;
4845: LD_ADDR_EXP 52
4849: PUSH
4850: LD_INT 1
4852: ST_TO_ADDR
// if p3 = 25 then
4853: LD_VAR 0 3
4857: PUSH
4858: LD_INT 25
4860: EQUAL
4861: IFFALSE 4871
// sSheik := true ;
4863: LD_ADDR_EXP 53
4867: PUSH
4868: LD_INT 1
4870: ST_TO_ADDR
// if p3 = 26 then
4871: LD_VAR 0 3
4875: PUSH
4876: LD_INT 26
4878: EQUAL
4879: IFFALSE 4889
// sEarthquake := true ;
4881: LD_ADDR_EXP 55
4885: PUSH
4886: LD_INT 1
4888: ST_TO_ADDR
// if p3 = 27 then
4889: LD_VAR 0 3
4893: PUSH
4894: LD_INT 27
4896: EQUAL
4897: IFFALSE 4907
// sAI := true ;
4899: LD_ADDR_EXP 56
4903: PUSH
4904: LD_INT 1
4906: ST_TO_ADDR
// if p3 = 28 then
4907: LD_VAR 0 3
4911: PUSH
4912: LD_INT 28
4914: EQUAL
4915: IFFALSE 4925
// sCargo := true ;
4917: LD_ADDR_EXP 59
4921: PUSH
4922: LD_INT 1
4924: ST_TO_ADDR
// if p3 = 29 then
4925: LD_VAR 0 3
4929: PUSH
4930: LD_INT 29
4932: EQUAL
4933: IFFALSE 4943
// sDLaser := true ;
4935: LD_ADDR_EXP 60
4939: PUSH
4940: LD_INT 1
4942: ST_TO_ADDR
// if p3 = 30 then
4943: LD_VAR 0 3
4947: PUSH
4948: LD_INT 30
4950: EQUAL
4951: IFFALSE 4961
// sExchange := true ;
4953: LD_ADDR_EXP 61
4957: PUSH
4958: LD_INT 1
4960: ST_TO_ADDR
// if p3 = 31 then
4961: LD_VAR 0 3
4965: PUSH
4966: LD_INT 31
4968: EQUAL
4969: IFFALSE 4979
// sFac := true ;
4971: LD_ADDR_EXP 62
4975: PUSH
4976: LD_INT 1
4978: ST_TO_ADDR
// if p3 = 32 then
4979: LD_VAR 0 3
4983: PUSH
4984: LD_INT 32
4986: EQUAL
4987: IFFALSE 4997
// sPower := true ;
4989: LD_ADDR_EXP 63
4993: PUSH
4994: LD_INT 1
4996: ST_TO_ADDR
// if p3 = 33 then
4997: LD_VAR 0 3
5001: PUSH
5002: LD_INT 33
5004: EQUAL
5005: IFFALSE 5015
// sRandom := true ;
5007: LD_ADDR_EXP 64
5011: PUSH
5012: LD_INT 1
5014: ST_TO_ADDR
// if p3 = 34 then
5015: LD_VAR 0 3
5019: PUSH
5020: LD_INT 34
5022: EQUAL
5023: IFFALSE 5033
// sShield := true ;
5025: LD_ADDR_EXP 65
5029: PUSH
5030: LD_INT 1
5032: ST_TO_ADDR
// if p3 = 35 then
5033: LD_VAR 0 3
5037: PUSH
5038: LD_INT 35
5040: EQUAL
5041: IFFALSE 5051
// sTime := true ;
5043: LD_ADDR_EXP 66
5047: PUSH
5048: LD_INT 1
5050: ST_TO_ADDR
// if p3 = 36 then
5051: LD_VAR 0 3
5055: PUSH
5056: LD_INT 36
5058: EQUAL
5059: IFFALSE 5069
// sTools := true ;
5061: LD_ADDR_EXP 67
5065: PUSH
5066: LD_INT 1
5068: ST_TO_ADDR
// if p3 = 101 then
5069: LD_VAR 0 3
5073: PUSH
5074: LD_INT 101
5076: EQUAL
5077: IFFALSE 5087
// sSold := true ;
5079: LD_ADDR_EXP 32
5083: PUSH
5084: LD_INT 1
5086: ST_TO_ADDR
// if p3 = 102 then
5087: LD_VAR 0 3
5091: PUSH
5092: LD_INT 102
5094: EQUAL
5095: IFFALSE 5105
// sDiff := true ;
5097: LD_ADDR_EXP 33
5101: PUSH
5102: LD_INT 1
5104: ST_TO_ADDR
// if p3 = 103 then
5105: LD_VAR 0 3
5109: PUSH
5110: LD_INT 103
5112: EQUAL
5113: IFFALSE 5123
// sFog := true ;
5115: LD_ADDR_EXP 36
5119: PUSH
5120: LD_INT 1
5122: ST_TO_ADDR
// if p3 = 104 then
5123: LD_VAR 0 3
5127: PUSH
5128: LD_INT 104
5130: EQUAL
5131: IFFALSE 5141
// sReset := true ;
5133: LD_ADDR_EXP 37
5137: PUSH
5138: LD_INT 1
5140: ST_TO_ADDR
// if p3 = 105 then
5141: LD_VAR 0 3
5145: PUSH
5146: LD_INT 105
5148: EQUAL
5149: IFFALSE 5159
// sSun := true ;
5151: LD_ADDR_EXP 38
5155: PUSH
5156: LD_INT 1
5158: ST_TO_ADDR
// if p3 = 106 then
5159: LD_VAR 0 3
5163: PUSH
5164: LD_INT 106
5166: EQUAL
5167: IFFALSE 5177
// sTiger := true ;
5169: LD_ADDR_EXP 34
5173: PUSH
5174: LD_INT 1
5176: ST_TO_ADDR
// if p3 = 107 then
5177: LD_VAR 0 3
5181: PUSH
5182: LD_INT 107
5184: EQUAL
5185: IFFALSE 5195
// sBomb := true ;
5187: LD_ADDR_EXP 35
5191: PUSH
5192: LD_INT 1
5194: ST_TO_ADDR
// if p3 = 108 then
5195: LD_VAR 0 3
5199: PUSH
5200: LD_INT 108
5202: EQUAL
5203: IFFALSE 5213
// sWound := true ;
5205: LD_ADDR_EXP 43
5209: PUSH
5210: LD_INT 1
5212: ST_TO_ADDR
// if p3 = 109 then
5213: LD_VAR 0 3
5217: PUSH
5218: LD_INT 109
5220: EQUAL
5221: IFFALSE 5231
// sBetray := true ;
5223: LD_ADDR_EXP 47
5227: PUSH
5228: LD_INT 1
5230: ST_TO_ADDR
// if p3 = 110 then
5231: LD_VAR 0 3
5235: PUSH
5236: LD_INT 110
5238: EQUAL
5239: IFFALSE 5249
// sContamin := true ;
5241: LD_ADDR_EXP 48
5245: PUSH
5246: LD_INT 1
5248: ST_TO_ADDR
// if p3 = 111 then
5249: LD_VAR 0 3
5253: PUSH
5254: LD_INT 111
5256: EQUAL
5257: IFFALSE 5267
// sOil := true ;
5259: LD_ADDR_EXP 50
5263: PUSH
5264: LD_INT 1
5266: ST_TO_ADDR
// if p3 = 112 then
5267: LD_VAR 0 3
5271: PUSH
5272: LD_INT 112
5274: EQUAL
5275: IFFALSE 5285
// sStu := true ;
5277: LD_ADDR_EXP 54
5281: PUSH
5282: LD_INT 1
5284: ST_TO_ADDR
// if p3 = 113 then
5285: LD_VAR 0 3
5289: PUSH
5290: LD_INT 113
5292: EQUAL
5293: IFFALSE 5303
// sBazooka := true ;
5295: LD_ADDR_EXP 57
5299: PUSH
5300: LD_INT 1
5302: ST_TO_ADDR
// if p3 = 114 then
5303: LD_VAR 0 3
5307: PUSH
5308: LD_INT 114
5310: EQUAL
5311: IFFALSE 5321
// sMortar := true ;
5313: LD_ADDR_EXP 58
5317: PUSH
5318: LD_INT 1
5320: ST_TO_ADDR
// if p3 = 115 then
5321: LD_VAR 0 3
5325: PUSH
5326: LD_INT 115
5328: EQUAL
5329: IFFALSE 5339
// sRanger := true ;
5331: LD_ADDR_EXP 68
5335: PUSH
5336: LD_INT 1
5338: ST_TO_ADDR
// end ; end ;
5339: PPOPN 6
5341: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
5342: LD_EXP 15
5346: PUSH
5347: LD_EXP 20
5351: AND
5352: IFFALSE 5476
5354: GO 5356
5356: DISABLE
5357: LD_INT 0
5359: PPUSH
5360: PPUSH
// begin enable ;
5361: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
5362: LD_ADDR_VAR 0 2
5366: PUSH
5367: LD_INT 22
5369: PUSH
5370: LD_OWVAR 2
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 2
5381: PUSH
5382: LD_INT 34
5384: PUSH
5385: LD_INT 7
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PUSH
5392: LD_INT 34
5394: PUSH
5395: LD_INT 45
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: PUSH
5402: LD_INT 34
5404: PUSH
5405: LD_INT 28
5407: PUSH
5408: EMPTY
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 34
5414: PUSH
5415: LD_INT 47
5417: PUSH
5418: EMPTY
5419: LIST
5420: LIST
5421: PUSH
5422: EMPTY
5423: LIST
5424: LIST
5425: LIST
5426: LIST
5427: LIST
5428: PUSH
5429: EMPTY
5430: LIST
5431: LIST
5432: PPUSH
5433: CALL_OW 69
5437: ST_TO_ADDR
// if not tmp then
5438: LD_VAR 0 2
5442: NOT
5443: IFFALSE 5447
// exit ;
5445: GO 5476
// for i in tmp do
5447: LD_ADDR_VAR 0 1
5451: PUSH
5452: LD_VAR 0 2
5456: PUSH
5457: FOR_IN
5458: IFFALSE 5474
// begin SetLives ( i , 0 ) ;
5460: LD_VAR 0 1
5464: PPUSH
5465: LD_INT 0
5467: PPUSH
5468: CALL_OW 234
// end ;
5472: GO 5457
5474: POP
5475: POP
// end ;
5476: PPOPN 2
5478: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
5479: LD_EXP 15
5483: PUSH
5484: LD_EXP 21
5488: AND
5489: IFFALSE 5573
5491: GO 5493
5493: DISABLE
5494: LD_INT 0
5496: PPUSH
5497: PPUSH
// begin enable ;
5498: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
5499: LD_ADDR_VAR 0 2
5503: PUSH
5504: LD_INT 22
5506: PUSH
5507: LD_OWVAR 2
5511: PUSH
5512: EMPTY
5513: LIST
5514: LIST
5515: PUSH
5516: LD_INT 32
5518: PUSH
5519: LD_INT 3
5521: PUSH
5522: EMPTY
5523: LIST
5524: LIST
5525: PUSH
5526: EMPTY
5527: LIST
5528: LIST
5529: PPUSH
5530: CALL_OW 69
5534: ST_TO_ADDR
// if not tmp then
5535: LD_VAR 0 2
5539: NOT
5540: IFFALSE 5544
// exit ;
5542: GO 5573
// for i in tmp do
5544: LD_ADDR_VAR 0 1
5548: PUSH
5549: LD_VAR 0 2
5553: PUSH
5554: FOR_IN
5555: IFFALSE 5571
// begin SetLives ( i , 0 ) ;
5557: LD_VAR 0 1
5561: PPUSH
5562: LD_INT 0
5564: PPUSH
5565: CALL_OW 234
// end ;
5569: GO 5554
5571: POP
5572: POP
// end ;
5573: PPOPN 2
5575: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
5576: LD_EXP 15
5580: PUSH
5581: LD_EXP 18
5585: AND
5586: IFFALSE 5679
5588: GO 5590
5590: DISABLE
5591: LD_INT 0
5593: PPUSH
// begin enable ;
5594: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
5595: LD_ADDR_VAR 0 1
5599: PUSH
5600: LD_INT 22
5602: PUSH
5603: LD_OWVAR 2
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: PUSH
5612: LD_INT 2
5614: PUSH
5615: LD_INT 25
5617: PUSH
5618: LD_INT 5
5620: PUSH
5621: EMPTY
5622: LIST
5623: LIST
5624: PUSH
5625: LD_INT 25
5627: PUSH
5628: LD_INT 9
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: PUSH
5635: LD_INT 25
5637: PUSH
5638: LD_INT 8
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: PUSH
5645: EMPTY
5646: LIST
5647: LIST
5648: LIST
5649: LIST
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: PPUSH
5655: CALL_OW 69
5659: PUSH
5660: FOR_IN
5661: IFFALSE 5677
// begin SetClass ( i , 1 ) ;
5663: LD_VAR 0 1
5667: PPUSH
5668: LD_INT 1
5670: PPUSH
5671: CALL_OW 336
// end ;
5675: GO 5660
5677: POP
5678: POP
// end ;
5679: PPOPN 1
5681: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
5682: LD_EXP 15
5686: PUSH
5687: LD_EXP 19
5691: AND
5692: PUSH
5693: LD_OWVAR 65
5697: PUSH
5698: LD_INT 7
5700: LESS
5701: AND
5702: IFFALSE 5716
5704: GO 5706
5706: DISABLE
// begin enable ;
5707: ENABLE
// game_speed := 7 ;
5708: LD_ADDR_OWVAR 65
5712: PUSH
5713: LD_INT 7
5715: ST_TO_ADDR
// end ;
5716: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
5717: LD_EXP 15
5721: PUSH
5722: LD_EXP 22
5726: AND
5727: IFFALSE 5929
5729: GO 5731
5731: DISABLE
5732: LD_INT 0
5734: PPUSH
5735: PPUSH
5736: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
5737: LD_ADDR_VAR 0 3
5741: PUSH
5742: LD_INT 81
5744: PUSH
5745: LD_OWVAR 2
5749: PUSH
5750: EMPTY
5751: LIST
5752: LIST
5753: PUSH
5754: LD_INT 21
5756: PUSH
5757: LD_INT 1
5759: PUSH
5760: EMPTY
5761: LIST
5762: LIST
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PPUSH
5768: CALL_OW 69
5772: ST_TO_ADDR
// if not tmp then
5773: LD_VAR 0 3
5777: NOT
5778: IFFALSE 5782
// exit ;
5780: GO 5929
// if tmp > 5 then
5782: LD_VAR 0 3
5786: PUSH
5787: LD_INT 5
5789: GREATER
5790: IFFALSE 5802
// k := 5 else
5792: LD_ADDR_VAR 0 2
5796: PUSH
5797: LD_INT 5
5799: ST_TO_ADDR
5800: GO 5812
// k := tmp ;
5802: LD_ADDR_VAR 0 2
5806: PUSH
5807: LD_VAR 0 3
5811: ST_TO_ADDR
// for i := 1 to k do
5812: LD_ADDR_VAR 0 1
5816: PUSH
5817: DOUBLE
5818: LD_INT 1
5820: DEC
5821: ST_TO_ADDR
5822: LD_VAR 0 2
5826: PUSH
5827: FOR_TO
5828: IFFALSE 5927
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
5830: LD_VAR 0 3
5834: PUSH
5835: LD_VAR 0 1
5839: ARRAY
5840: PPUSH
5841: LD_VAR 0 1
5845: PUSH
5846: LD_INT 4
5848: MOD
5849: PUSH
5850: LD_INT 1
5852: PLUS
5853: PPUSH
5854: CALL_OW 259
5858: PUSH
5859: LD_INT 10
5861: LESS
5862: IFFALSE 5925
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
5864: LD_VAR 0 3
5868: PUSH
5869: LD_VAR 0 1
5873: ARRAY
5874: PPUSH
5875: LD_VAR 0 1
5879: PUSH
5880: LD_INT 4
5882: MOD
5883: PUSH
5884: LD_INT 1
5886: PLUS
5887: PPUSH
5888: LD_VAR 0 3
5892: PUSH
5893: LD_VAR 0 1
5897: ARRAY
5898: PPUSH
5899: LD_VAR 0 1
5903: PUSH
5904: LD_INT 4
5906: MOD
5907: PUSH
5908: LD_INT 1
5910: PLUS
5911: PPUSH
5912: CALL_OW 259
5916: PUSH
5917: LD_INT 1
5919: PLUS
5920: PPUSH
5921: CALL_OW 237
5925: GO 5827
5927: POP
5928: POP
// end ;
5929: PPOPN 3
5931: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
5932: LD_EXP 15
5936: PUSH
5937: LD_EXP 23
5941: AND
5942: IFFALSE 5962
5944: GO 5946
5946: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
5947: LD_INT 4
5949: PPUSH
5950: LD_OWVAR 2
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 324
5962: END
// every 0 0$1 trigger StreamModeActive and sShovel do
5963: LD_EXP 15
5967: PUSH
5968: LD_EXP 52
5972: AND
5973: IFFALSE 5993
5975: GO 5977
5977: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
5978: LD_INT 19
5980: PPUSH
5981: LD_OWVAR 2
5985: PPUSH
5986: LD_INT 0
5988: PPUSH
5989: CALL_OW 324
5993: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
5994: LD_EXP 15
5998: PUSH
5999: LD_EXP 24
6003: AND
6004: IFFALSE 6106
6006: GO 6008
6008: DISABLE
6009: LD_INT 0
6011: PPUSH
6012: PPUSH
// begin enable ;
6013: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
6014: LD_ADDR_VAR 0 2
6018: PUSH
6019: LD_INT 22
6021: PUSH
6022: LD_OWVAR 2
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: PUSH
6031: LD_INT 2
6033: PUSH
6034: LD_INT 34
6036: PUSH
6037: LD_INT 11
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: PUSH
6044: LD_INT 34
6046: PUSH
6047: LD_INT 30
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: PPUSH
6063: CALL_OW 69
6067: ST_TO_ADDR
// if not tmp then
6068: LD_VAR 0 2
6072: NOT
6073: IFFALSE 6077
// exit ;
6075: GO 6106
// for i in tmp do
6077: LD_ADDR_VAR 0 1
6081: PUSH
6082: LD_VAR 0 2
6086: PUSH
6087: FOR_IN
6088: IFFALSE 6104
// begin SetLives ( i , 0 ) ;
6090: LD_VAR 0 1
6094: PPUSH
6095: LD_INT 0
6097: PPUSH
6098: CALL_OW 234
// end ;
6102: GO 6087
6104: POP
6105: POP
// end ;
6106: PPOPN 2
6108: END
// every 0 0$1 trigger StreamModeActive and sBunker do
6109: LD_EXP 15
6113: PUSH
6114: LD_EXP 25
6118: AND
6119: IFFALSE 6139
6121: GO 6123
6123: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
6124: LD_INT 32
6126: PPUSH
6127: LD_OWVAR 2
6131: PPUSH
6132: LD_INT 0
6134: PPUSH
6135: CALL_OW 324
6139: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
6140: LD_EXP 15
6144: PUSH
6145: LD_EXP 26
6149: AND
6150: IFFALSE 6331
6152: GO 6154
6154: DISABLE
6155: LD_INT 0
6157: PPUSH
6158: PPUSH
6159: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_INT 22
6167: PUSH
6168: LD_OWVAR 2
6172: PUSH
6173: EMPTY
6174: LIST
6175: LIST
6176: PUSH
6177: LD_INT 33
6179: PUSH
6180: LD_INT 3
6182: PUSH
6183: EMPTY
6184: LIST
6185: LIST
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: PPUSH
6191: CALL_OW 69
6195: ST_TO_ADDR
// if not tmp then
6196: LD_VAR 0 2
6200: NOT
6201: IFFALSE 6205
// exit ;
6203: GO 6331
// side := 0 ;
6205: LD_ADDR_VAR 0 3
6209: PUSH
6210: LD_INT 0
6212: ST_TO_ADDR
// for i := 1 to 8 do
6213: LD_ADDR_VAR 0 1
6217: PUSH
6218: DOUBLE
6219: LD_INT 1
6221: DEC
6222: ST_TO_ADDR
6223: LD_INT 8
6225: PUSH
6226: FOR_TO
6227: IFFALSE 6275
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
6229: LD_OWVAR 2
6233: PUSH
6234: LD_VAR 0 1
6238: NONEQUAL
6239: PUSH
6240: LD_OWVAR 2
6244: PPUSH
6245: LD_VAR 0 1
6249: PPUSH
6250: CALL_OW 81
6254: PUSH
6255: LD_INT 2
6257: EQUAL
6258: AND
6259: IFFALSE 6273
// begin side := i ;
6261: LD_ADDR_VAR 0 3
6265: PUSH
6266: LD_VAR 0 1
6270: ST_TO_ADDR
// break ;
6271: GO 6275
// end ;
6273: GO 6226
6275: POP
6276: POP
// if not side then
6277: LD_VAR 0 3
6281: NOT
6282: IFFALSE 6286
// exit ;
6284: GO 6331
// for i := 1 to tmp do
6286: LD_ADDR_VAR 0 1
6290: PUSH
6291: DOUBLE
6292: LD_INT 1
6294: DEC
6295: ST_TO_ADDR
6296: LD_VAR 0 2
6300: PUSH
6301: FOR_TO
6302: IFFALSE 6329
// if Prob ( 60 ) then
6304: LD_INT 60
6306: PPUSH
6307: CALL_OW 13
6311: IFFALSE 6327
// SetSide ( i , side ) ;
6313: LD_VAR 0 1
6317: PPUSH
6318: LD_VAR 0 3
6322: PPUSH
6323: CALL_OW 235
6327: GO 6301
6329: POP
6330: POP
// end ;
6331: PPOPN 3
6333: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
6334: LD_EXP 15
6338: PUSH
6339: LD_EXP 28
6343: AND
6344: IFFALSE 6463
6346: GO 6348
6348: DISABLE
6349: LD_INT 0
6351: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
6352: LD_ADDR_VAR 0 1
6356: PUSH
6357: LD_INT 22
6359: PUSH
6360: LD_OWVAR 2
6364: PUSH
6365: EMPTY
6366: LIST
6367: LIST
6368: PUSH
6369: LD_INT 21
6371: PUSH
6372: LD_INT 1
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: PUSH
6379: LD_INT 3
6381: PUSH
6382: LD_INT 23
6384: PUSH
6385: LD_INT 0
6387: PUSH
6388: EMPTY
6389: LIST
6390: LIST
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: LIST
6400: PPUSH
6401: CALL_OW 69
6405: PUSH
6406: FOR_IN
6407: IFFALSE 6461
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
6409: LD_VAR 0 1
6413: PPUSH
6414: CALL_OW 257
6418: PUSH
6419: LD_INT 1
6421: PUSH
6422: LD_INT 2
6424: PUSH
6425: LD_INT 3
6427: PUSH
6428: LD_INT 4
6430: PUSH
6431: EMPTY
6432: LIST
6433: LIST
6434: LIST
6435: LIST
6436: IN
6437: IFFALSE 6459
// SetClass ( un , rand ( 1 , 4 ) ) ;
6439: LD_VAR 0 1
6443: PPUSH
6444: LD_INT 1
6446: PPUSH
6447: LD_INT 4
6449: PPUSH
6450: CALL_OW 12
6454: PPUSH
6455: CALL_OW 336
6459: GO 6406
6461: POP
6462: POP
// end ;
6463: PPOPN 1
6465: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
6466: LD_EXP 15
6470: PUSH
6471: LD_EXP 27
6475: AND
6476: IFFALSE 6555
6478: GO 6480
6480: DISABLE
6481: LD_INT 0
6483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6484: LD_ADDR_VAR 0 1
6488: PUSH
6489: LD_INT 22
6491: PUSH
6492: LD_OWVAR 2
6496: PUSH
6497: EMPTY
6498: LIST
6499: LIST
6500: PUSH
6501: LD_INT 21
6503: PUSH
6504: LD_INT 3
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PUSH
6511: EMPTY
6512: LIST
6513: LIST
6514: PPUSH
6515: CALL_OW 69
6519: ST_TO_ADDR
// if not tmp then
6520: LD_VAR 0 1
6524: NOT
6525: IFFALSE 6529
// exit ;
6527: GO 6555
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
6529: LD_VAR 0 1
6533: PUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_VAR 0 1
6541: PPUSH
6542: CALL_OW 12
6546: ARRAY
6547: PPUSH
6548: LD_INT 100
6550: PPUSH
6551: CALL_OW 234
// end ;
6555: PPOPN 1
6557: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
6558: LD_EXP 15
6562: PUSH
6563: LD_EXP 29
6567: AND
6568: IFFALSE 6666
6570: GO 6572
6572: DISABLE
6573: LD_INT 0
6575: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
6576: LD_ADDR_VAR 0 1
6580: PUSH
6581: LD_INT 22
6583: PUSH
6584: LD_OWVAR 2
6588: PUSH
6589: EMPTY
6590: LIST
6591: LIST
6592: PUSH
6593: LD_INT 21
6595: PUSH
6596: LD_INT 1
6598: PUSH
6599: EMPTY
6600: LIST
6601: LIST
6602: PUSH
6603: EMPTY
6604: LIST
6605: LIST
6606: PPUSH
6607: CALL_OW 69
6611: ST_TO_ADDR
// if not tmp then
6612: LD_VAR 0 1
6616: NOT
6617: IFFALSE 6621
// exit ;
6619: GO 6666
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
6621: LD_VAR 0 1
6625: PUSH
6626: LD_INT 1
6628: PPUSH
6629: LD_VAR 0 1
6633: PPUSH
6634: CALL_OW 12
6638: ARRAY
6639: PPUSH
6640: LD_INT 1
6642: PPUSH
6643: LD_INT 4
6645: PPUSH
6646: CALL_OW 12
6650: PPUSH
6651: LD_INT 3000
6653: PPUSH
6654: LD_INT 9000
6656: PPUSH
6657: CALL_OW 12
6661: PPUSH
6662: CALL_OW 492
// end ;
6666: PPOPN 1
6668: END
// every 0 0$1 trigger StreamModeActive and sDepot do
6669: LD_EXP 15
6673: PUSH
6674: LD_EXP 30
6678: AND
6679: IFFALSE 6699
6681: GO 6683
6683: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
6684: LD_INT 1
6686: PPUSH
6687: LD_OWVAR 2
6691: PPUSH
6692: LD_INT 0
6694: PPUSH
6695: CALL_OW 324
6699: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
6700: LD_EXP 15
6704: PUSH
6705: LD_EXP 31
6709: AND
6710: IFFALSE 6793
6712: GO 6714
6714: DISABLE
6715: LD_INT 0
6717: PPUSH
6718: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
6719: LD_ADDR_VAR 0 2
6723: PUSH
6724: LD_INT 22
6726: PUSH
6727: LD_OWVAR 2
6731: PUSH
6732: EMPTY
6733: LIST
6734: LIST
6735: PUSH
6736: LD_INT 21
6738: PUSH
6739: LD_INT 3
6741: PUSH
6742: EMPTY
6743: LIST
6744: LIST
6745: PUSH
6746: EMPTY
6747: LIST
6748: LIST
6749: PPUSH
6750: CALL_OW 69
6754: ST_TO_ADDR
// if not tmp then
6755: LD_VAR 0 2
6759: NOT
6760: IFFALSE 6764
// exit ;
6762: GO 6793
// for i in tmp do
6764: LD_ADDR_VAR 0 1
6768: PUSH
6769: LD_VAR 0 2
6773: PUSH
6774: FOR_IN
6775: IFFALSE 6791
// SetBLevel ( i , 10 ) ;
6777: LD_VAR 0 1
6781: PPUSH
6782: LD_INT 10
6784: PPUSH
6785: CALL_OW 241
6789: GO 6774
6791: POP
6792: POP
// end ;
6793: PPOPN 2
6795: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
6796: LD_EXP 15
6800: PUSH
6801: LD_EXP 32
6805: AND
6806: IFFALSE 6917
6808: GO 6810
6810: DISABLE
6811: LD_INT 0
6813: PPUSH
6814: PPUSH
6815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
6816: LD_ADDR_VAR 0 3
6820: PUSH
6821: LD_INT 22
6823: PUSH
6824: LD_OWVAR 2
6828: PUSH
6829: EMPTY
6830: LIST
6831: LIST
6832: PUSH
6833: LD_INT 25
6835: PUSH
6836: LD_INT 1
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: PPUSH
6847: CALL_OW 69
6851: ST_TO_ADDR
// if not tmp then
6852: LD_VAR 0 3
6856: NOT
6857: IFFALSE 6861
// exit ;
6859: GO 6917
// un := tmp [ rand ( 1 , tmp ) ] ;
6861: LD_ADDR_VAR 0 2
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: LD_INT 1
6873: PPUSH
6874: LD_VAR 0 3
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: ST_TO_ADDR
// if Crawls ( un ) then
6885: LD_VAR 0 2
6889: PPUSH
6890: CALL_OW 318
6894: IFFALSE 6905
// ComWalk ( un ) ;
6896: LD_VAR 0 2
6900: PPUSH
6901: CALL_OW 138
// SetClass ( un , class_sniper ) ;
6905: LD_VAR 0 2
6909: PPUSH
6910: LD_INT 5
6912: PPUSH
6913: CALL_OW 336
// end ;
6917: PPOPN 3
6919: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
6920: LD_EXP 15
6924: PUSH
6925: LD_EXP 33
6929: AND
6930: PUSH
6931: LD_OWVAR 67
6935: PUSH
6936: LD_INT 3
6938: LESS
6939: AND
6940: IFFALSE 6959
6942: GO 6944
6944: DISABLE
// Difficulty := Difficulty + 1 ;
6945: LD_ADDR_OWVAR 67
6949: PUSH
6950: LD_OWVAR 67
6954: PUSH
6955: LD_INT 1
6957: PLUS
6958: ST_TO_ADDR
6959: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
6960: LD_EXP 15
6964: PUSH
6965: LD_EXP 34
6969: AND
6970: IFFALSE 7073
6972: GO 6974
6974: DISABLE
6975: LD_INT 0
6977: PPUSH
// begin for i := 1 to 5 do
6978: LD_ADDR_VAR 0 1
6982: PUSH
6983: DOUBLE
6984: LD_INT 1
6986: DEC
6987: ST_TO_ADDR
6988: LD_INT 5
6990: PUSH
6991: FOR_TO
6992: IFFALSE 7071
// begin uc_nation := nation_nature ;
6994: LD_ADDR_OWVAR 21
6998: PUSH
6999: LD_INT 0
7001: ST_TO_ADDR
// uc_side := 0 ;
7002: LD_ADDR_OWVAR 20
7006: PUSH
7007: LD_INT 0
7009: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7010: LD_ADDR_OWVAR 29
7014: PUSH
7015: LD_INT 12
7017: PUSH
7018: LD_INT 12
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: ST_TO_ADDR
// hc_agressivity := 20 ;
7025: LD_ADDR_OWVAR 35
7029: PUSH
7030: LD_INT 20
7032: ST_TO_ADDR
// hc_class := class_tiger ;
7033: LD_ADDR_OWVAR 28
7037: PUSH
7038: LD_INT 14
7040: ST_TO_ADDR
// hc_gallery :=  ;
7041: LD_ADDR_OWVAR 33
7045: PUSH
7046: LD_STRING 
7048: ST_TO_ADDR
// hc_name :=  ;
7049: LD_ADDR_OWVAR 26
7053: PUSH
7054: LD_STRING 
7056: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
7057: CALL_OW 44
7061: PPUSH
7062: LD_INT 0
7064: PPUSH
7065: CALL_OW 51
// end ;
7069: GO 6991
7071: POP
7072: POP
// end ;
7073: PPOPN 1
7075: END
// every 0 0$1 trigger StreamModeActive and sBomb do
7076: LD_EXP 15
7080: PUSH
7081: LD_EXP 35
7085: AND
7086: IFFALSE 7095
7088: GO 7090
7090: DISABLE
// StreamSibBomb ;
7091: CALL 7096 0 0
7095: END
// export function StreamSibBomb ; var i , x , y ; begin
7096: LD_INT 0
7098: PPUSH
7099: PPUSH
7100: PPUSH
7101: PPUSH
// result := false ;
7102: LD_ADDR_VAR 0 1
7106: PUSH
7107: LD_INT 0
7109: ST_TO_ADDR
// for i := 1 to 16 do
7110: LD_ADDR_VAR 0 2
7114: PUSH
7115: DOUBLE
7116: LD_INT 1
7118: DEC
7119: ST_TO_ADDR
7120: LD_INT 16
7122: PUSH
7123: FOR_TO
7124: IFFALSE 7323
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
7126: LD_ADDR_VAR 0 3
7130: PUSH
7131: LD_INT 10
7133: PUSH
7134: LD_INT 20
7136: PUSH
7137: LD_INT 30
7139: PUSH
7140: LD_INT 40
7142: PUSH
7143: LD_INT 50
7145: PUSH
7146: LD_INT 60
7148: PUSH
7149: LD_INT 70
7151: PUSH
7152: LD_INT 80
7154: PUSH
7155: LD_INT 90
7157: PUSH
7158: LD_INT 100
7160: PUSH
7161: LD_INT 110
7163: PUSH
7164: LD_INT 120
7166: PUSH
7167: LD_INT 130
7169: PUSH
7170: LD_INT 140
7172: PUSH
7173: LD_INT 150
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: LIST
7180: LIST
7181: LIST
7182: LIST
7183: LIST
7184: LIST
7185: LIST
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: LIST
7191: LIST
7192: PUSH
7193: LD_INT 1
7195: PPUSH
7196: LD_INT 15
7198: PPUSH
7199: CALL_OW 12
7203: ARRAY
7204: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
7205: LD_ADDR_VAR 0 4
7209: PUSH
7210: LD_INT 10
7212: PUSH
7213: LD_INT 20
7215: PUSH
7216: LD_INT 30
7218: PUSH
7219: LD_INT 40
7221: PUSH
7222: LD_INT 50
7224: PUSH
7225: LD_INT 60
7227: PUSH
7228: LD_INT 70
7230: PUSH
7231: LD_INT 80
7233: PUSH
7234: LD_INT 90
7236: PUSH
7237: LD_INT 100
7239: PUSH
7240: LD_INT 110
7242: PUSH
7243: LD_INT 120
7245: PUSH
7246: LD_INT 130
7248: PUSH
7249: LD_INT 140
7251: PUSH
7252: LD_INT 150
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: LIST
7262: LIST
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: LIST
7268: LIST
7269: LIST
7270: LIST
7271: PUSH
7272: LD_INT 1
7274: PPUSH
7275: LD_INT 15
7277: PPUSH
7278: CALL_OW 12
7282: ARRAY
7283: ST_TO_ADDR
// if ValidHex ( x , y ) then
7284: LD_VAR 0 3
7288: PPUSH
7289: LD_VAR 0 4
7293: PPUSH
7294: CALL_OW 488
7298: IFFALSE 7321
// begin result := [ x , y ] ;
7300: LD_ADDR_VAR 0 1
7304: PUSH
7305: LD_VAR 0 3
7309: PUSH
7310: LD_VAR 0 4
7314: PUSH
7315: EMPTY
7316: LIST
7317: LIST
7318: ST_TO_ADDR
// break ;
7319: GO 7323
// end ; end ;
7321: GO 7123
7323: POP
7324: POP
// if result then
7325: LD_VAR 0 1
7329: IFFALSE 7389
// begin ToLua ( playSibBomb() ) ;
7331: LD_STRING playSibBomb()
7333: PPUSH
7334: CALL_OW 559
// wait ( 0 0$14 ) ;
7338: LD_INT 490
7340: PPUSH
7341: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
7345: LD_VAR 0 1
7349: PUSH
7350: LD_INT 1
7352: ARRAY
7353: PPUSH
7354: LD_VAR 0 1
7358: PUSH
7359: LD_INT 2
7361: ARRAY
7362: PPUSH
7363: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
7367: LD_VAR 0 1
7371: PUSH
7372: LD_INT 1
7374: ARRAY
7375: PPUSH
7376: LD_VAR 0 1
7380: PUSH
7381: LD_INT 2
7383: ARRAY
7384: PPUSH
7385: CALL_OW 429
// end ; end ;
7389: LD_VAR 0 1
7393: RET
// every 0 0$1 trigger StreamModeActive and sReset do
7394: LD_EXP 15
7398: PUSH
7399: LD_EXP 37
7403: AND
7404: IFFALSE 7416
7406: GO 7408
7408: DISABLE
// YouLost (  ) ;
7409: LD_STRING 
7411: PPUSH
7412: CALL_OW 104
7416: END
// every 0 0$1 trigger StreamModeActive and sFog do
7417: LD_EXP 15
7421: PUSH
7422: LD_EXP 36
7426: AND
7427: IFFALSE 7441
7429: GO 7431
7431: DISABLE
// FogOff ( your_side ) ;
7432: LD_OWVAR 2
7436: PPUSH
7437: CALL_OW 344
7441: END
// every 0 0$1 trigger StreamModeActive and sSun do
7442: LD_EXP 15
7446: PUSH
7447: LD_EXP 38
7451: AND
7452: IFFALSE 7480
7454: GO 7456
7456: DISABLE
// begin solar_recharge_percent := 0 ;
7457: LD_ADDR_OWVAR 79
7461: PUSH
7462: LD_INT 0
7464: ST_TO_ADDR
// wait ( 5 5$00 ) ;
7465: LD_INT 10500
7467: PPUSH
7468: CALL_OW 67
// solar_recharge_percent := 100 ;
7472: LD_ADDR_OWVAR 79
7476: PUSH
7477: LD_INT 100
7479: ST_TO_ADDR
// end ;
7480: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
7481: LD_EXP 15
7485: PUSH
7486: LD_EXP 39
7490: AND
7491: IFFALSE 7730
7493: GO 7495
7495: DISABLE
7496: LD_INT 0
7498: PPUSH
7499: PPUSH
7500: PPUSH
// begin tmp := [ ] ;
7501: LD_ADDR_VAR 0 3
7505: PUSH
7506: EMPTY
7507: ST_TO_ADDR
// for i := 1 to 6 do
7508: LD_ADDR_VAR 0 1
7512: PUSH
7513: DOUBLE
7514: LD_INT 1
7516: DEC
7517: ST_TO_ADDR
7518: LD_INT 6
7520: PUSH
7521: FOR_TO
7522: IFFALSE 7627
// begin uc_nation := nation_nature ;
7524: LD_ADDR_OWVAR 21
7528: PUSH
7529: LD_INT 0
7531: ST_TO_ADDR
// uc_side := 0 ;
7532: LD_ADDR_OWVAR 20
7536: PUSH
7537: LD_INT 0
7539: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7540: LD_ADDR_OWVAR 29
7544: PUSH
7545: LD_INT 12
7547: PUSH
7548: LD_INT 12
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: ST_TO_ADDR
// hc_agressivity := 20 ;
7555: LD_ADDR_OWVAR 35
7559: PUSH
7560: LD_INT 20
7562: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
7563: LD_ADDR_OWVAR 28
7567: PUSH
7568: LD_INT 17
7570: ST_TO_ADDR
// hc_gallery :=  ;
7571: LD_ADDR_OWVAR 33
7575: PUSH
7576: LD_STRING 
7578: ST_TO_ADDR
// hc_name :=  ;
7579: LD_ADDR_OWVAR 26
7583: PUSH
7584: LD_STRING 
7586: ST_TO_ADDR
// un := CreateHuman ;
7587: LD_ADDR_VAR 0 2
7591: PUSH
7592: CALL_OW 44
7596: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
7597: LD_VAR 0 2
7601: PPUSH
7602: LD_INT 1
7604: PPUSH
7605: CALL_OW 51
// tmp := tmp ^ un ;
7609: LD_ADDR_VAR 0 3
7613: PUSH
7614: LD_VAR 0 3
7618: PUSH
7619: LD_VAR 0 2
7623: ADD
7624: ST_TO_ADDR
// end ;
7625: GO 7521
7627: POP
7628: POP
// repeat wait ( 0 0$1 ) ;
7629: LD_INT 35
7631: PPUSH
7632: CALL_OW 67
// for un in tmp do
7636: LD_ADDR_VAR 0 2
7640: PUSH
7641: LD_VAR 0 3
7645: PUSH
7646: FOR_IN
7647: IFFALSE 7721
// begin if IsDead ( un ) then
7649: LD_VAR 0 2
7653: PPUSH
7654: CALL_OW 301
7658: IFFALSE 7678
// begin tmp := tmp diff un ;
7660: LD_ADDR_VAR 0 3
7664: PUSH
7665: LD_VAR 0 3
7669: PUSH
7670: LD_VAR 0 2
7674: DIFF
7675: ST_TO_ADDR
// continue ;
7676: GO 7646
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
7678: LD_VAR 0 2
7682: PPUSH
7683: LD_INT 3
7685: PUSH
7686: LD_INT 22
7688: PUSH
7689: LD_INT 0
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PPUSH
7700: CALL_OW 69
7704: PPUSH
7705: LD_VAR 0 2
7709: PPUSH
7710: CALL_OW 74
7714: PPUSH
7715: CALL_OW 115
// end ;
7719: GO 7646
7721: POP
7722: POP
// until not tmp ;
7723: LD_VAR 0 3
7727: NOT
7728: IFFALSE 7629
// end ;
7730: PPOPN 3
7732: END
// every 0 0$1 trigger StreamModeActive and sTroll do
7733: LD_EXP 15
7737: PUSH
7738: LD_EXP 40
7742: AND
7743: IFFALSE 7797
7745: GO 7747
7747: DISABLE
// begin ToLua ( displayTroll(); ) ;
7748: LD_STRING displayTroll();
7750: PPUSH
7751: CALL_OW 559
// wait ( 3 3$00 ) ;
7755: LD_INT 6300
7757: PPUSH
7758: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7762: LD_STRING hideTroll();
7764: PPUSH
7765: CALL_OW 559
// wait ( 1 1$00 ) ;
7769: LD_INT 2100
7771: PPUSH
7772: CALL_OW 67
// ToLua ( displayTroll(); ) ;
7776: LD_STRING displayTroll();
7778: PPUSH
7779: CALL_OW 559
// wait ( 1 1$00 ) ;
7783: LD_INT 2100
7785: PPUSH
7786: CALL_OW 67
// ToLua ( hideTroll(); ) ;
7790: LD_STRING hideTroll();
7792: PPUSH
7793: CALL_OW 559
// end ;
7797: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
7798: LD_EXP 15
7802: PUSH
7803: LD_EXP 41
7807: AND
7808: IFFALSE 7871
7810: GO 7812
7812: DISABLE
7813: LD_INT 0
7815: PPUSH
// begin p := 0 ;
7816: LD_ADDR_VAR 0 1
7820: PUSH
7821: LD_INT 0
7823: ST_TO_ADDR
// repeat game_speed := 1 ;
7824: LD_ADDR_OWVAR 65
7828: PUSH
7829: LD_INT 1
7831: ST_TO_ADDR
// wait ( 0 0$1 ) ;
7832: LD_INT 35
7834: PPUSH
7835: CALL_OW 67
// p := p + 1 ;
7839: LD_ADDR_VAR 0 1
7843: PUSH
7844: LD_VAR 0 1
7848: PUSH
7849: LD_INT 1
7851: PLUS
7852: ST_TO_ADDR
// until p >= 60 ;
7853: LD_VAR 0 1
7857: PUSH
7858: LD_INT 60
7860: GREATEREQUAL
7861: IFFALSE 7824
// game_speed := 4 ;
7863: LD_ADDR_OWVAR 65
7867: PUSH
7868: LD_INT 4
7870: ST_TO_ADDR
// end ;
7871: PPOPN 1
7873: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
7874: LD_EXP 15
7878: PUSH
7879: LD_EXP 42
7883: AND
7884: IFFALSE 8030
7886: GO 7888
7888: DISABLE
7889: LD_INT 0
7891: PPUSH
7892: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
7893: LD_ADDR_VAR 0 1
7897: PUSH
7898: LD_INT 22
7900: PUSH
7901: LD_OWVAR 2
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 2
7912: PUSH
7913: LD_INT 30
7915: PUSH
7916: LD_INT 0
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: PUSH
7923: LD_INT 30
7925: PUSH
7926: LD_INT 1
7928: PUSH
7929: EMPTY
7930: LIST
7931: LIST
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: PUSH
7938: EMPTY
7939: LIST
7940: LIST
7941: PPUSH
7942: CALL_OW 69
7946: ST_TO_ADDR
// if not depot then
7947: LD_VAR 0 1
7951: NOT
7952: IFFALSE 7956
// exit ;
7954: GO 8030
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
7956: LD_ADDR_VAR 0 2
7960: PUSH
7961: LD_VAR 0 1
7965: PUSH
7966: LD_INT 1
7968: PPUSH
7969: LD_VAR 0 1
7973: PPUSH
7974: CALL_OW 12
7978: ARRAY
7979: PPUSH
7980: CALL_OW 274
7984: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
7985: LD_VAR 0 2
7989: PPUSH
7990: LD_INT 1
7992: PPUSH
7993: LD_INT 0
7995: PPUSH
7996: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
8000: LD_VAR 0 2
8004: PPUSH
8005: LD_INT 2
8007: PPUSH
8008: LD_INT 0
8010: PPUSH
8011: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
8015: LD_VAR 0 2
8019: PPUSH
8020: LD_INT 3
8022: PPUSH
8023: LD_INT 0
8025: PPUSH
8026: CALL_OW 277
// end ;
8030: PPOPN 2
8032: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
8033: LD_EXP 15
8037: PUSH
8038: LD_EXP 43
8042: AND
8043: IFFALSE 8140
8045: GO 8047
8047: DISABLE
8048: LD_INT 0
8050: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
8051: LD_ADDR_VAR 0 1
8055: PUSH
8056: LD_INT 22
8058: PUSH
8059: LD_OWVAR 2
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: PUSH
8068: LD_INT 21
8070: PUSH
8071: LD_INT 1
8073: PUSH
8074: EMPTY
8075: LIST
8076: LIST
8077: PUSH
8078: LD_INT 3
8080: PUSH
8081: LD_INT 23
8083: PUSH
8084: LD_INT 0
8086: PUSH
8087: EMPTY
8088: LIST
8089: LIST
8090: PUSH
8091: EMPTY
8092: LIST
8093: LIST
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: PPUSH
8100: CALL_OW 69
8104: ST_TO_ADDR
// if not tmp then
8105: LD_VAR 0 1
8109: NOT
8110: IFFALSE 8114
// exit ;
8112: GO 8140
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
8114: LD_VAR 0 1
8118: PUSH
8119: LD_INT 1
8121: PPUSH
8122: LD_VAR 0 1
8126: PPUSH
8127: CALL_OW 12
8131: ARRAY
8132: PPUSH
8133: LD_INT 200
8135: PPUSH
8136: CALL_OW 234
// end ;
8140: PPOPN 1
8142: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
8143: LD_EXP 15
8147: PUSH
8148: LD_EXP 44
8152: AND
8153: IFFALSE 8232
8155: GO 8157
8157: DISABLE
8158: LD_INT 0
8160: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
8161: LD_ADDR_VAR 0 1
8165: PUSH
8166: LD_INT 22
8168: PUSH
8169: LD_OWVAR 2
8173: PUSH
8174: EMPTY
8175: LIST
8176: LIST
8177: PUSH
8178: LD_INT 21
8180: PUSH
8181: LD_INT 2
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: PUSH
8188: EMPTY
8189: LIST
8190: LIST
8191: PPUSH
8192: CALL_OW 69
8196: ST_TO_ADDR
// if not tmp then
8197: LD_VAR 0 1
8201: NOT
8202: IFFALSE 8206
// exit ;
8204: GO 8232
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
8206: LD_VAR 0 1
8210: PUSH
8211: LD_INT 1
8213: PPUSH
8214: LD_VAR 0 1
8218: PPUSH
8219: CALL_OW 12
8223: ARRAY
8224: PPUSH
8225: LD_INT 60
8227: PPUSH
8228: CALL_OW 234
// end ;
8232: PPOPN 1
8234: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
8235: LD_EXP 15
8239: PUSH
8240: LD_EXP 45
8244: AND
8245: IFFALSE 8344
8247: GO 8249
8249: DISABLE
8250: LD_INT 0
8252: PPUSH
8253: PPUSH
// begin enable ;
8254: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
8255: LD_ADDR_VAR 0 1
8259: PUSH
8260: LD_INT 22
8262: PUSH
8263: LD_OWVAR 2
8267: PUSH
8268: EMPTY
8269: LIST
8270: LIST
8271: PUSH
8272: LD_INT 61
8274: PUSH
8275: EMPTY
8276: LIST
8277: PUSH
8278: LD_INT 33
8280: PUSH
8281: LD_INT 2
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: EMPTY
8289: LIST
8290: LIST
8291: LIST
8292: PPUSH
8293: CALL_OW 69
8297: ST_TO_ADDR
// if not tmp then
8298: LD_VAR 0 1
8302: NOT
8303: IFFALSE 8307
// exit ;
8305: GO 8344
// for i in tmp do
8307: LD_ADDR_VAR 0 2
8311: PUSH
8312: LD_VAR 0 1
8316: PUSH
8317: FOR_IN
8318: IFFALSE 8342
// if IsControledBy ( i ) then
8320: LD_VAR 0 2
8324: PPUSH
8325: CALL_OW 312
8329: IFFALSE 8340
// ComUnlink ( i ) ;
8331: LD_VAR 0 2
8335: PPUSH
8336: CALL_OW 136
8340: GO 8317
8342: POP
8343: POP
// end ;
8344: PPOPN 2
8346: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
8347: LD_EXP 15
8351: PUSH
8352: LD_EXP 46
8356: AND
8357: IFFALSE 8497
8359: GO 8361
8361: DISABLE
8362: LD_INT 0
8364: PPUSH
8365: PPUSH
// begin ToLua ( displayPowell(); ) ;
8366: LD_STRING displayPowell();
8368: PPUSH
8369: CALL_OW 559
// uc_side := 0 ;
8373: LD_ADDR_OWVAR 20
8377: PUSH
8378: LD_INT 0
8380: ST_TO_ADDR
// uc_nation := 2 ;
8381: LD_ADDR_OWVAR 21
8385: PUSH
8386: LD_INT 2
8388: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
8389: LD_ADDR_OWVAR 37
8393: PUSH
8394: LD_INT 14
8396: ST_TO_ADDR
// vc_engine := engine_siberite ;
8397: LD_ADDR_OWVAR 39
8401: PUSH
8402: LD_INT 3
8404: ST_TO_ADDR
// vc_control := control_apeman ;
8405: LD_ADDR_OWVAR 38
8409: PUSH
8410: LD_INT 5
8412: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
8413: LD_ADDR_OWVAR 40
8417: PUSH
8418: LD_INT 29
8420: ST_TO_ADDR
// un := CreateVehicle ;
8421: LD_ADDR_VAR 0 2
8425: PUSH
8426: CALL_OW 45
8430: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
8431: LD_VAR 0 2
8435: PPUSH
8436: LD_INT 1
8438: PPUSH
8439: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
8443: LD_INT 35
8445: PPUSH
8446: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
8450: LD_VAR 0 2
8454: PPUSH
8455: LD_INT 22
8457: PUSH
8458: LD_OWVAR 2
8462: PUSH
8463: EMPTY
8464: LIST
8465: LIST
8466: PPUSH
8467: CALL_OW 69
8471: PPUSH
8472: LD_VAR 0 2
8476: PPUSH
8477: CALL_OW 74
8481: PPUSH
8482: CALL_OW 115
// until IsDead ( un ) ;
8486: LD_VAR 0 2
8490: PPUSH
8491: CALL_OW 301
8495: IFFALSE 8443
// end ;
8497: PPOPN 2
8499: END
// every 0 0$1 trigger StreamModeActive and sStu do
8500: LD_EXP 15
8504: PUSH
8505: LD_EXP 54
8509: AND
8510: IFFALSE 8526
8512: GO 8514
8514: DISABLE
// begin ToLua ( displayStucuk(); ) ;
8515: LD_STRING displayStucuk();
8517: PPUSH
8518: CALL_OW 559
// ResetFog ;
8522: CALL_OW 335
// end ;
8526: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
8527: LD_EXP 15
8531: PUSH
8532: LD_EXP 47
8536: AND
8537: IFFALSE 8678
8539: GO 8541
8541: DISABLE
8542: LD_INT 0
8544: PPUSH
8545: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8546: LD_ADDR_VAR 0 2
8550: PUSH
8551: LD_INT 22
8553: PUSH
8554: LD_OWVAR 2
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PUSH
8563: LD_INT 21
8565: PUSH
8566: LD_INT 1
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: PUSH
8573: EMPTY
8574: LIST
8575: LIST
8576: PPUSH
8577: CALL_OW 69
8581: ST_TO_ADDR
// if not tmp then
8582: LD_VAR 0 2
8586: NOT
8587: IFFALSE 8591
// exit ;
8589: GO 8678
// un := tmp [ rand ( 1 , tmp ) ] ;
8591: LD_ADDR_VAR 0 1
8595: PUSH
8596: LD_VAR 0 2
8600: PUSH
8601: LD_INT 1
8603: PPUSH
8604: LD_VAR 0 2
8608: PPUSH
8609: CALL_OW 12
8613: ARRAY
8614: ST_TO_ADDR
// SetSide ( un , 0 ) ;
8615: LD_VAR 0 1
8619: PPUSH
8620: LD_INT 0
8622: PPUSH
8623: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
8627: LD_VAR 0 1
8631: PPUSH
8632: LD_OWVAR 3
8636: PUSH
8637: LD_VAR 0 1
8641: DIFF
8642: PPUSH
8643: LD_VAR 0 1
8647: PPUSH
8648: CALL_OW 74
8652: PPUSH
8653: CALL_OW 115
// wait ( 0 0$20 ) ;
8657: LD_INT 700
8659: PPUSH
8660: CALL_OW 67
// SetSide ( un , your_side ) ;
8664: LD_VAR 0 1
8668: PPUSH
8669: LD_OWVAR 2
8673: PPUSH
8674: CALL_OW 235
// end ;
8678: PPOPN 2
8680: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
8681: LD_EXP 15
8685: PUSH
8686: LD_EXP 48
8690: AND
8691: IFFALSE 8797
8693: GO 8695
8695: DISABLE
8696: LD_INT 0
8698: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8699: LD_ADDR_VAR 0 1
8703: PUSH
8704: LD_INT 22
8706: PUSH
8707: LD_OWVAR 2
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: PUSH
8716: LD_INT 2
8718: PUSH
8719: LD_INT 30
8721: PUSH
8722: LD_INT 0
8724: PUSH
8725: EMPTY
8726: LIST
8727: LIST
8728: PUSH
8729: LD_INT 30
8731: PUSH
8732: LD_INT 1
8734: PUSH
8735: EMPTY
8736: LIST
8737: LIST
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PPUSH
8748: CALL_OW 69
8752: ST_TO_ADDR
// if not depot then
8753: LD_VAR 0 1
8757: NOT
8758: IFFALSE 8762
// exit ;
8760: GO 8797
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
8762: LD_VAR 0 1
8766: PUSH
8767: LD_INT 1
8769: ARRAY
8770: PPUSH
8771: CALL_OW 250
8775: PPUSH
8776: LD_VAR 0 1
8780: PUSH
8781: LD_INT 1
8783: ARRAY
8784: PPUSH
8785: CALL_OW 251
8789: PPUSH
8790: LD_INT 70
8792: PPUSH
8793: CALL_OW 495
// end ;
8797: PPOPN 1
8799: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
8800: LD_EXP 15
8804: PUSH
8805: LD_EXP 49
8809: AND
8810: IFFALSE 9021
8812: GO 8814
8814: DISABLE
8815: LD_INT 0
8817: PPUSH
8818: PPUSH
8819: PPUSH
8820: PPUSH
8821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
8822: LD_ADDR_VAR 0 5
8826: PUSH
8827: LD_INT 22
8829: PUSH
8830: LD_OWVAR 2
8834: PUSH
8835: EMPTY
8836: LIST
8837: LIST
8838: PUSH
8839: LD_INT 21
8841: PUSH
8842: LD_INT 1
8844: PUSH
8845: EMPTY
8846: LIST
8847: LIST
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: PPUSH
8853: CALL_OW 69
8857: ST_TO_ADDR
// if not tmp then
8858: LD_VAR 0 5
8862: NOT
8863: IFFALSE 8867
// exit ;
8865: GO 9021
// for i in tmp do
8867: LD_ADDR_VAR 0 1
8871: PUSH
8872: LD_VAR 0 5
8876: PUSH
8877: FOR_IN
8878: IFFALSE 9019
// begin d := rand ( 0 , 5 ) ;
8880: LD_ADDR_VAR 0 4
8884: PUSH
8885: LD_INT 0
8887: PPUSH
8888: LD_INT 5
8890: PPUSH
8891: CALL_OW 12
8895: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
8896: LD_ADDR_VAR 0 2
8900: PUSH
8901: LD_VAR 0 1
8905: PPUSH
8906: CALL_OW 250
8910: PPUSH
8911: LD_VAR 0 4
8915: PPUSH
8916: LD_INT 3
8918: PPUSH
8919: LD_INT 12
8921: PPUSH
8922: CALL_OW 12
8926: PPUSH
8927: CALL_OW 272
8931: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
8932: LD_ADDR_VAR 0 3
8936: PUSH
8937: LD_VAR 0 1
8941: PPUSH
8942: CALL_OW 251
8946: PPUSH
8947: LD_VAR 0 4
8951: PPUSH
8952: LD_INT 3
8954: PPUSH
8955: LD_INT 12
8957: PPUSH
8958: CALL_OW 12
8962: PPUSH
8963: CALL_OW 273
8967: ST_TO_ADDR
// if ValidHex ( x , y ) then
8968: LD_VAR 0 2
8972: PPUSH
8973: LD_VAR 0 3
8977: PPUSH
8978: CALL_OW 488
8982: IFFALSE 9017
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
8984: LD_VAR 0 1
8988: PPUSH
8989: LD_VAR 0 2
8993: PPUSH
8994: LD_VAR 0 3
8998: PPUSH
8999: LD_INT 3
9001: PPUSH
9002: LD_INT 6
9004: PPUSH
9005: CALL_OW 12
9009: PPUSH
9010: LD_INT 1
9012: PPUSH
9013: CALL_OW 483
// end ;
9017: GO 8877
9019: POP
9020: POP
// end ;
9021: PPOPN 5
9023: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
9024: LD_EXP 15
9028: PUSH
9029: LD_EXP 50
9033: AND
9034: IFFALSE 9128
9036: GO 9038
9038: DISABLE
9039: LD_INT 0
9041: PPUSH
9042: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
9043: LD_ADDR_VAR 0 2
9047: PUSH
9048: LD_INT 22
9050: PUSH
9051: LD_OWVAR 2
9055: PUSH
9056: EMPTY
9057: LIST
9058: LIST
9059: PUSH
9060: LD_INT 32
9062: PUSH
9063: LD_INT 1
9065: PUSH
9066: EMPTY
9067: LIST
9068: LIST
9069: PUSH
9070: LD_INT 21
9072: PUSH
9073: LD_INT 2
9075: PUSH
9076: EMPTY
9077: LIST
9078: LIST
9079: PUSH
9080: EMPTY
9081: LIST
9082: LIST
9083: LIST
9084: PPUSH
9085: CALL_OW 69
9089: ST_TO_ADDR
// if not tmp then
9090: LD_VAR 0 2
9094: NOT
9095: IFFALSE 9099
// exit ;
9097: GO 9128
// for i in tmp do
9099: LD_ADDR_VAR 0 1
9103: PUSH
9104: LD_VAR 0 2
9108: PUSH
9109: FOR_IN
9110: IFFALSE 9126
// SetFuel ( i , 0 ) ;
9112: LD_VAR 0 1
9116: PPUSH
9117: LD_INT 0
9119: PPUSH
9120: CALL_OW 240
9124: GO 9109
9126: POP
9127: POP
// end ;
9128: PPOPN 2
9130: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
9131: LD_EXP 15
9135: PUSH
9136: LD_EXP 51
9140: AND
9141: IFFALSE 9207
9143: GO 9145
9145: DISABLE
9146: LD_INT 0
9148: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
9149: LD_ADDR_VAR 0 1
9153: PUSH
9154: LD_INT 22
9156: PUSH
9157: LD_OWVAR 2
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: PUSH
9166: LD_INT 30
9168: PUSH
9169: LD_INT 29
9171: PUSH
9172: EMPTY
9173: LIST
9174: LIST
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PPUSH
9180: CALL_OW 69
9184: ST_TO_ADDR
// if not tmp then
9185: LD_VAR 0 1
9189: NOT
9190: IFFALSE 9194
// exit ;
9192: GO 9207
// DestroyUnit ( tmp [ 1 ] ) ;
9194: LD_VAR 0 1
9198: PUSH
9199: LD_INT 1
9201: ARRAY
9202: PPUSH
9203: CALL_OW 65
// end ;
9207: PPOPN 1
9209: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
9210: LD_EXP 15
9214: PUSH
9215: LD_EXP 53
9219: AND
9220: IFFALSE 9349
9222: GO 9224
9224: DISABLE
9225: LD_INT 0
9227: PPUSH
// begin uc_side := 0 ;
9228: LD_ADDR_OWVAR 20
9232: PUSH
9233: LD_INT 0
9235: ST_TO_ADDR
// uc_nation := nation_arabian ;
9236: LD_ADDR_OWVAR 21
9240: PUSH
9241: LD_INT 2
9243: ST_TO_ADDR
// hc_gallery :=  ;
9244: LD_ADDR_OWVAR 33
9248: PUSH
9249: LD_STRING 
9251: ST_TO_ADDR
// hc_name :=  ;
9252: LD_ADDR_OWVAR 26
9256: PUSH
9257: LD_STRING 
9259: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
9260: LD_INT 1
9262: PPUSH
9263: LD_INT 11
9265: PPUSH
9266: LD_INT 10
9268: PPUSH
9269: CALL_OW 380
// un := CreateHuman ;
9273: LD_ADDR_VAR 0 1
9277: PUSH
9278: CALL_OW 44
9282: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
9283: LD_VAR 0 1
9287: PPUSH
9288: LD_INT 1
9290: PPUSH
9291: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
9295: LD_INT 35
9297: PPUSH
9298: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
9302: LD_VAR 0 1
9306: PPUSH
9307: LD_INT 22
9309: PUSH
9310: LD_OWVAR 2
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: PPUSH
9319: CALL_OW 69
9323: PPUSH
9324: LD_VAR 0 1
9328: PPUSH
9329: CALL_OW 74
9333: PPUSH
9334: CALL_OW 115
// until IsDead ( un ) ;
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 301
9347: IFFALSE 9295
// end ;
9349: PPOPN 1
9351: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
9352: LD_EXP 15
9356: PUSH
9357: LD_EXP 55
9361: AND
9362: IFFALSE 9374
9364: GO 9366
9366: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
9367: LD_STRING earthquake(getX(game), 0, 32)
9369: PPUSH
9370: CALL_OW 559
9374: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
9375: LD_EXP 15
9379: PUSH
9380: LD_EXP 56
9384: AND
9385: IFFALSE 9476
9387: GO 9389
9389: DISABLE
9390: LD_INT 0
9392: PPUSH
// begin enable ;
9393: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
9394: LD_ADDR_VAR 0 1
9398: PUSH
9399: LD_INT 22
9401: PUSH
9402: LD_OWVAR 2
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 21
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: PUSH
9421: LD_INT 33
9423: PUSH
9424: LD_INT 3
9426: PUSH
9427: EMPTY
9428: LIST
9429: LIST
9430: PUSH
9431: EMPTY
9432: LIST
9433: LIST
9434: LIST
9435: PPUSH
9436: CALL_OW 69
9440: ST_TO_ADDR
// if not tmp then
9441: LD_VAR 0 1
9445: NOT
9446: IFFALSE 9450
// exit ;
9448: GO 9476
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
9450: LD_VAR 0 1
9454: PUSH
9455: LD_INT 1
9457: PPUSH
9458: LD_VAR 0 1
9462: PPUSH
9463: CALL_OW 12
9467: ARRAY
9468: PPUSH
9469: LD_INT 1
9471: PPUSH
9472: CALL_OW 234
// end ;
9476: PPOPN 1
9478: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
9479: LD_EXP 15
9483: PUSH
9484: LD_EXP 57
9488: AND
9489: IFFALSE 9630
9491: GO 9493
9493: DISABLE
9494: LD_INT 0
9496: PPUSH
9497: PPUSH
9498: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9499: LD_ADDR_VAR 0 3
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_OWVAR 2
9511: PUSH
9512: EMPTY
9513: LIST
9514: LIST
9515: PUSH
9516: LD_INT 25
9518: PUSH
9519: LD_INT 1
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: PPUSH
9530: CALL_OW 69
9534: ST_TO_ADDR
// if not tmp then
9535: LD_VAR 0 3
9539: NOT
9540: IFFALSE 9544
// exit ;
9542: GO 9630
// un := tmp [ rand ( 1 , tmp ) ] ;
9544: LD_ADDR_VAR 0 2
9548: PUSH
9549: LD_VAR 0 3
9553: PUSH
9554: LD_INT 1
9556: PPUSH
9557: LD_VAR 0 3
9561: PPUSH
9562: CALL_OW 12
9566: ARRAY
9567: ST_TO_ADDR
// if Crawls ( un ) then
9568: LD_VAR 0 2
9572: PPUSH
9573: CALL_OW 318
9577: IFFALSE 9588
// ComWalk ( un ) ;
9579: LD_VAR 0 2
9583: PPUSH
9584: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
9588: LD_VAR 0 2
9592: PPUSH
9593: LD_INT 9
9595: PPUSH
9596: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
9600: LD_INT 28
9602: PPUSH
9603: LD_OWVAR 2
9607: PPUSH
9608: LD_INT 2
9610: PPUSH
9611: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
9615: LD_INT 29
9617: PPUSH
9618: LD_OWVAR 2
9622: PPUSH
9623: LD_INT 2
9625: PPUSH
9626: CALL_OW 322
// end ;
9630: PPOPN 3
9632: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
9633: LD_EXP 15
9637: PUSH
9638: LD_EXP 58
9642: AND
9643: IFFALSE 9754
9645: GO 9647
9647: DISABLE
9648: LD_INT 0
9650: PPUSH
9651: PPUSH
9652: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
9653: LD_ADDR_VAR 0 3
9657: PUSH
9658: LD_INT 22
9660: PUSH
9661: LD_OWVAR 2
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PUSH
9670: LD_INT 25
9672: PUSH
9673: LD_INT 1
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PPUSH
9684: CALL_OW 69
9688: ST_TO_ADDR
// if not tmp then
9689: LD_VAR 0 3
9693: NOT
9694: IFFALSE 9698
// exit ;
9696: GO 9754
// un := tmp [ rand ( 1 , tmp ) ] ;
9698: LD_ADDR_VAR 0 2
9702: PUSH
9703: LD_VAR 0 3
9707: PUSH
9708: LD_INT 1
9710: PPUSH
9711: LD_VAR 0 3
9715: PPUSH
9716: CALL_OW 12
9720: ARRAY
9721: ST_TO_ADDR
// if Crawls ( un ) then
9722: LD_VAR 0 2
9726: PPUSH
9727: CALL_OW 318
9731: IFFALSE 9742
// ComWalk ( un ) ;
9733: LD_VAR 0 2
9737: PPUSH
9738: CALL_OW 138
// SetClass ( un , class_mortar ) ;
9742: LD_VAR 0 2
9746: PPUSH
9747: LD_INT 8
9749: PPUSH
9750: CALL_OW 336
// end ;
9754: PPOPN 3
9756: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
9757: LD_EXP 15
9761: PUSH
9762: LD_EXP 59
9766: AND
9767: IFFALSE 9911
9769: GO 9771
9771: DISABLE
9772: LD_INT 0
9774: PPUSH
9775: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
9776: LD_ADDR_VAR 0 2
9780: PUSH
9781: LD_INT 22
9783: PUSH
9784: LD_OWVAR 2
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PUSH
9793: LD_INT 21
9795: PUSH
9796: LD_INT 2
9798: PUSH
9799: EMPTY
9800: LIST
9801: LIST
9802: PUSH
9803: LD_INT 2
9805: PUSH
9806: LD_INT 34
9808: PUSH
9809: LD_INT 12
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 34
9818: PUSH
9819: LD_INT 51
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: PUSH
9826: LD_INT 34
9828: PUSH
9829: LD_INT 32
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PUSH
9836: EMPTY
9837: LIST
9838: LIST
9839: LIST
9840: LIST
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: LIST
9846: PPUSH
9847: CALL_OW 69
9851: ST_TO_ADDR
// if not tmp then
9852: LD_VAR 0 2
9856: NOT
9857: IFFALSE 9861
// exit ;
9859: GO 9911
// for i in tmp do
9861: LD_ADDR_VAR 0 1
9865: PUSH
9866: LD_VAR 0 2
9870: PUSH
9871: FOR_IN
9872: IFFALSE 9909
// if GetCargo ( i , mat_artifact ) = 0 then
9874: LD_VAR 0 1
9878: PPUSH
9879: LD_INT 4
9881: PPUSH
9882: CALL_OW 289
9886: PUSH
9887: LD_INT 0
9889: EQUAL
9890: IFFALSE 9907
// SetCargo ( i , mat_siberit , 100 ) ;
9892: LD_VAR 0 1
9896: PPUSH
9897: LD_INT 3
9899: PPUSH
9900: LD_INT 100
9902: PPUSH
9903: CALL_OW 290
9907: GO 9871
9909: POP
9910: POP
// end ;
9911: PPOPN 2
9913: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
9914: LD_EXP 15
9918: PUSH
9919: LD_EXP 60
9923: AND
9924: IFFALSE 10077
9926: GO 9928
9928: DISABLE
9929: LD_INT 0
9931: PPUSH
9932: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
9933: LD_ADDR_VAR 0 2
9937: PUSH
9938: LD_INT 22
9940: PUSH
9941: LD_OWVAR 2
9945: PUSH
9946: EMPTY
9947: LIST
9948: LIST
9949: PPUSH
9950: CALL_OW 69
9954: ST_TO_ADDR
// if not tmp then
9955: LD_VAR 0 2
9959: NOT
9960: IFFALSE 9964
// exit ;
9962: GO 10077
// for i := 1 to 2 do
9964: LD_ADDR_VAR 0 1
9968: PUSH
9969: DOUBLE
9970: LD_INT 1
9972: DEC
9973: ST_TO_ADDR
9974: LD_INT 2
9976: PUSH
9977: FOR_TO
9978: IFFALSE 10075
// begin uc_side := your_side ;
9980: LD_ADDR_OWVAR 20
9984: PUSH
9985: LD_OWVAR 2
9989: ST_TO_ADDR
// uc_nation := nation_american ;
9990: LD_ADDR_OWVAR 21
9994: PUSH
9995: LD_INT 1
9997: ST_TO_ADDR
// vc_chassis := us_morphling ;
9998: LD_ADDR_OWVAR 37
10002: PUSH
10003: LD_INT 5
10005: ST_TO_ADDR
// vc_engine := engine_siberite ;
10006: LD_ADDR_OWVAR 39
10010: PUSH
10011: LD_INT 3
10013: ST_TO_ADDR
// vc_control := control_computer ;
10014: LD_ADDR_OWVAR 38
10018: PUSH
10019: LD_INT 3
10021: ST_TO_ADDR
// vc_weapon := us_double_laser ;
10022: LD_ADDR_OWVAR 40
10026: PUSH
10027: LD_INT 10
10029: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
10030: CALL_OW 45
10034: PPUSH
10035: LD_VAR 0 2
10039: PUSH
10040: LD_INT 1
10042: ARRAY
10043: PPUSH
10044: CALL_OW 250
10048: PPUSH
10049: LD_VAR 0 2
10053: PUSH
10054: LD_INT 1
10056: ARRAY
10057: PPUSH
10058: CALL_OW 251
10062: PPUSH
10063: LD_INT 12
10065: PPUSH
10066: LD_INT 1
10068: PPUSH
10069: CALL_OW 50
// end ;
10073: GO 9977
10075: POP
10076: POP
// end ;
10077: PPOPN 2
10079: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
10080: LD_EXP 15
10084: PUSH
10085: LD_EXP 61
10089: AND
10090: IFFALSE 10312
10092: GO 10094
10094: DISABLE
10095: LD_INT 0
10097: PPUSH
10098: PPUSH
10099: PPUSH
10100: PPUSH
10101: PPUSH
10102: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
10103: LD_ADDR_VAR 0 6
10107: PUSH
10108: LD_INT 22
10110: PUSH
10111: LD_OWVAR 2
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 21
10122: PUSH
10123: LD_INT 1
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: LD_INT 3
10132: PUSH
10133: LD_INT 23
10135: PUSH
10136: LD_INT 0
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: LIST
10151: PPUSH
10152: CALL_OW 69
10156: ST_TO_ADDR
// if not tmp then
10157: LD_VAR 0 6
10161: NOT
10162: IFFALSE 10166
// exit ;
10164: GO 10312
// s1 := rand ( 1 , 4 ) ;
10166: LD_ADDR_VAR 0 2
10170: PUSH
10171: LD_INT 1
10173: PPUSH
10174: LD_INT 4
10176: PPUSH
10177: CALL_OW 12
10181: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
10182: LD_ADDR_VAR 0 4
10186: PUSH
10187: LD_VAR 0 6
10191: PUSH
10192: LD_INT 1
10194: ARRAY
10195: PPUSH
10196: LD_VAR 0 2
10200: PPUSH
10201: CALL_OW 259
10205: ST_TO_ADDR
// if s1 = 1 then
10206: LD_VAR 0 2
10210: PUSH
10211: LD_INT 1
10213: EQUAL
10214: IFFALSE 10234
// s2 := rand ( 2 , 4 ) else
10216: LD_ADDR_VAR 0 3
10220: PUSH
10221: LD_INT 2
10223: PPUSH
10224: LD_INT 4
10226: PPUSH
10227: CALL_OW 12
10231: ST_TO_ADDR
10232: GO 10242
// s2 := 1 ;
10234: LD_ADDR_VAR 0 3
10238: PUSH
10239: LD_INT 1
10241: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
10242: LD_ADDR_VAR 0 5
10246: PUSH
10247: LD_VAR 0 6
10251: PUSH
10252: LD_INT 1
10254: ARRAY
10255: PPUSH
10256: LD_VAR 0 3
10260: PPUSH
10261: CALL_OW 259
10265: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
10266: LD_VAR 0 6
10270: PUSH
10271: LD_INT 1
10273: ARRAY
10274: PPUSH
10275: LD_VAR 0 2
10279: PPUSH
10280: LD_VAR 0 5
10284: PPUSH
10285: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
10289: LD_VAR 0 6
10293: PUSH
10294: LD_INT 1
10296: ARRAY
10297: PPUSH
10298: LD_VAR 0 3
10302: PPUSH
10303: LD_VAR 0 4
10307: PPUSH
10308: CALL_OW 237
// end ;
10312: PPOPN 6
10314: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
10315: LD_EXP 15
10319: PUSH
10320: LD_EXP 62
10324: AND
10325: IFFALSE 10404
10327: GO 10329
10329: DISABLE
10330: LD_INT 0
10332: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
10333: LD_ADDR_VAR 0 1
10337: PUSH
10338: LD_INT 22
10340: PUSH
10341: LD_OWVAR 2
10345: PUSH
10346: EMPTY
10347: LIST
10348: LIST
10349: PUSH
10350: LD_INT 30
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PUSH
10360: EMPTY
10361: LIST
10362: LIST
10363: PPUSH
10364: CALL_OW 69
10368: ST_TO_ADDR
// if not tmp then
10369: LD_VAR 0 1
10373: NOT
10374: IFFALSE 10378
// exit ;
10376: GO 10404
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
10378: LD_VAR 0 1
10382: PUSH
10383: LD_INT 1
10385: PPUSH
10386: LD_VAR 0 1
10390: PPUSH
10391: CALL_OW 12
10395: ARRAY
10396: PPUSH
10397: LD_INT 1
10399: PPUSH
10400: CALL_OW 234
// end ;
10404: PPOPN 1
10406: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
10407: LD_EXP 15
10411: PUSH
10412: LD_EXP 63
10416: AND
10417: IFFALSE 10529
10419: GO 10421
10421: DISABLE
10422: LD_INT 0
10424: PPUSH
10425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
10426: LD_ADDR_VAR 0 2
10430: PUSH
10431: LD_INT 22
10433: PUSH
10434: LD_OWVAR 2
10438: PUSH
10439: EMPTY
10440: LIST
10441: LIST
10442: PUSH
10443: LD_INT 2
10445: PUSH
10446: LD_INT 30
10448: PUSH
10449: LD_INT 27
10451: PUSH
10452: EMPTY
10453: LIST
10454: LIST
10455: PUSH
10456: LD_INT 30
10458: PUSH
10459: LD_INT 26
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: PUSH
10466: LD_INT 30
10468: PUSH
10469: LD_INT 28
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: LIST
10480: LIST
10481: PUSH
10482: EMPTY
10483: LIST
10484: LIST
10485: PPUSH
10486: CALL_OW 69
10490: ST_TO_ADDR
// if not tmp then
10491: LD_VAR 0 2
10495: NOT
10496: IFFALSE 10500
// exit ;
10498: GO 10529
// for i in tmp do
10500: LD_ADDR_VAR 0 1
10504: PUSH
10505: LD_VAR 0 2
10509: PUSH
10510: FOR_IN
10511: IFFALSE 10527
// SetLives ( i , 1 ) ;
10513: LD_VAR 0 1
10517: PPUSH
10518: LD_INT 1
10520: PPUSH
10521: CALL_OW 234
10525: GO 10510
10527: POP
10528: POP
// end ;
10529: PPOPN 2
10531: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
10532: LD_EXP 15
10536: PUSH
10537: LD_EXP 64
10541: AND
10542: IFFALSE 10816
10544: GO 10546
10546: DISABLE
10547: LD_INT 0
10549: PPUSH
10550: PPUSH
10551: PPUSH
// begin i := rand ( 1 , 7 ) ;
10552: LD_ADDR_VAR 0 1
10556: PUSH
10557: LD_INT 1
10559: PPUSH
10560: LD_INT 7
10562: PPUSH
10563: CALL_OW 12
10567: ST_TO_ADDR
// case i of 1 :
10568: LD_VAR 0 1
10572: PUSH
10573: LD_INT 1
10575: DOUBLE
10576: EQUAL
10577: IFTRUE 10581
10579: GO 10591
10581: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
10582: LD_STRING earthquake(getX(game), 0, 32)
10584: PPUSH
10585: CALL_OW 559
10589: GO 10816
10591: LD_INT 2
10593: DOUBLE
10594: EQUAL
10595: IFTRUE 10599
10597: GO 10613
10599: POP
// begin ToLua ( displayStucuk(); ) ;
10600: LD_STRING displayStucuk();
10602: PPUSH
10603: CALL_OW 559
// ResetFog ;
10607: CALL_OW 335
// end ; 3 :
10611: GO 10816
10613: LD_INT 3
10615: DOUBLE
10616: EQUAL
10617: IFTRUE 10621
10619: GO 10725
10621: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10622: LD_ADDR_VAR 0 2
10626: PUSH
10627: LD_INT 22
10629: PUSH
10630: LD_OWVAR 2
10634: PUSH
10635: EMPTY
10636: LIST
10637: LIST
10638: PUSH
10639: LD_INT 25
10641: PUSH
10642: LD_INT 1
10644: PUSH
10645: EMPTY
10646: LIST
10647: LIST
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PPUSH
10653: CALL_OW 69
10657: ST_TO_ADDR
// if not tmp then
10658: LD_VAR 0 2
10662: NOT
10663: IFFALSE 10667
// exit ;
10665: GO 10816
// un := tmp [ rand ( 1 , tmp ) ] ;
10667: LD_ADDR_VAR 0 3
10671: PUSH
10672: LD_VAR 0 2
10676: PUSH
10677: LD_INT 1
10679: PPUSH
10680: LD_VAR 0 2
10684: PPUSH
10685: CALL_OW 12
10689: ARRAY
10690: ST_TO_ADDR
// if Crawls ( un ) then
10691: LD_VAR 0 3
10695: PPUSH
10696: CALL_OW 318
10700: IFFALSE 10711
// ComWalk ( un ) ;
10702: LD_VAR 0 3
10706: PPUSH
10707: CALL_OW 138
// SetClass ( un , class_mortar ) ;
10711: LD_VAR 0 3
10715: PPUSH
10716: LD_INT 8
10718: PPUSH
10719: CALL_OW 336
// end ; 4 :
10723: GO 10816
10725: LD_INT 4
10727: DOUBLE
10728: EQUAL
10729: IFTRUE 10733
10731: GO 10794
10733: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
10734: LD_ADDR_VAR 0 2
10738: PUSH
10739: LD_INT 22
10741: PUSH
10742: LD_OWVAR 2
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PUSH
10751: LD_INT 30
10753: PUSH
10754: LD_INT 29
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: ST_TO_ADDR
// if not tmp then
10770: LD_VAR 0 2
10774: NOT
10775: IFFALSE 10779
// exit ;
10777: GO 10816
// DestroyUnit ( tmp [ 1 ] ) ;
10779: LD_VAR 0 2
10783: PUSH
10784: LD_INT 1
10786: ARRAY
10787: PPUSH
10788: CALL_OW 65
// end ; 5 .. 7 :
10792: GO 10816
10794: LD_INT 5
10796: DOUBLE
10797: GREATEREQUAL
10798: IFFALSE 10806
10800: LD_INT 7
10802: DOUBLE
10803: LESSEQUAL
10804: IFTRUE 10808
10806: GO 10815
10808: POP
// StreamSibBomb ; end ;
10809: CALL 7096 0 0
10813: GO 10816
10815: POP
// end ;
10816: PPOPN 3
10818: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
10819: LD_EXP 15
10823: PUSH
10824: LD_EXP 65
10828: AND
10829: IFFALSE 10985
10831: GO 10833
10833: DISABLE
10834: LD_INT 0
10836: PPUSH
10837: PPUSH
10838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
10839: LD_ADDR_VAR 0 2
10843: PUSH
10844: LD_INT 81
10846: PUSH
10847: LD_OWVAR 2
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: PUSH
10856: LD_INT 2
10858: PUSH
10859: LD_INT 21
10861: PUSH
10862: LD_INT 1
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: PUSH
10869: LD_INT 21
10871: PUSH
10872: LD_INT 2
10874: PUSH
10875: EMPTY
10876: LIST
10877: LIST
10878: PUSH
10879: EMPTY
10880: LIST
10881: LIST
10882: LIST
10883: PUSH
10884: EMPTY
10885: LIST
10886: LIST
10887: PPUSH
10888: CALL_OW 69
10892: ST_TO_ADDR
// if not tmp then
10893: LD_VAR 0 2
10897: NOT
10898: IFFALSE 10902
// exit ;
10900: GO 10985
// p := 0 ;
10902: LD_ADDR_VAR 0 3
10906: PUSH
10907: LD_INT 0
10909: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10910: LD_INT 35
10912: PPUSH
10913: CALL_OW 67
// p := p + 1 ;
10917: LD_ADDR_VAR 0 3
10921: PUSH
10922: LD_VAR 0 3
10926: PUSH
10927: LD_INT 1
10929: PLUS
10930: ST_TO_ADDR
// for i in tmp do
10931: LD_ADDR_VAR 0 1
10935: PUSH
10936: LD_VAR 0 2
10940: PUSH
10941: FOR_IN
10942: IFFALSE 10973
// if GetLives ( i ) < 1000 then
10944: LD_VAR 0 1
10948: PPUSH
10949: CALL_OW 256
10953: PUSH
10954: LD_INT 1000
10956: LESS
10957: IFFALSE 10971
// SetLives ( i , 1000 ) ;
10959: LD_VAR 0 1
10963: PPUSH
10964: LD_INT 1000
10966: PPUSH
10967: CALL_OW 234
10971: GO 10941
10973: POP
10974: POP
// until p > 20 ;
10975: LD_VAR 0 3
10979: PUSH
10980: LD_INT 20
10982: GREATER
10983: IFFALSE 10910
// end ;
10985: PPOPN 3
10987: END
// every 0 0$1 trigger StreamModeActive and sTime do
10988: LD_EXP 15
10992: PUSH
10993: LD_EXP 66
10997: AND
10998: IFFALSE 11033
11000: GO 11002
11002: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
11003: LD_INT 28
11005: PPUSH
11006: LD_OWVAR 2
11010: PPUSH
11011: LD_INT 2
11013: PPUSH
11014: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
11018: LD_INT 30
11020: PPUSH
11021: LD_OWVAR 2
11025: PPUSH
11026: LD_INT 2
11028: PPUSH
11029: CALL_OW 322
// end ;
11033: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
11034: LD_EXP 15
11038: PUSH
11039: LD_EXP 67
11043: AND
11044: IFFALSE 11165
11046: GO 11048
11048: DISABLE
11049: LD_INT 0
11051: PPUSH
11052: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11053: LD_ADDR_VAR 0 2
11057: PUSH
11058: LD_INT 22
11060: PUSH
11061: LD_OWVAR 2
11065: PUSH
11066: EMPTY
11067: LIST
11068: LIST
11069: PUSH
11070: LD_INT 21
11072: PUSH
11073: LD_INT 1
11075: PUSH
11076: EMPTY
11077: LIST
11078: LIST
11079: PUSH
11080: LD_INT 3
11082: PUSH
11083: LD_INT 23
11085: PUSH
11086: LD_INT 0
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: LIST
11101: PPUSH
11102: CALL_OW 69
11106: ST_TO_ADDR
// if not tmp then
11107: LD_VAR 0 2
11111: NOT
11112: IFFALSE 11116
// exit ;
11114: GO 11165
// for i in tmp do
11116: LD_ADDR_VAR 0 1
11120: PUSH
11121: LD_VAR 0 2
11125: PUSH
11126: FOR_IN
11127: IFFALSE 11163
// begin if Crawls ( i ) then
11129: LD_VAR 0 1
11133: PPUSH
11134: CALL_OW 318
11138: IFFALSE 11149
// ComWalk ( i ) ;
11140: LD_VAR 0 1
11144: PPUSH
11145: CALL_OW 138
// SetClass ( i , 2 ) ;
11149: LD_VAR 0 1
11153: PPUSH
11154: LD_INT 2
11156: PPUSH
11157: CALL_OW 336
// end ;
11161: GO 11126
11163: POP
11164: POP
// end ;
11165: PPOPN 2
11167: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
11168: LD_EXP 15
11172: PUSH
11173: LD_EXP 68
11177: AND
11178: IFFALSE 11459
11180: GO 11182
11182: DISABLE
11183: LD_INT 0
11185: PPUSH
11186: PPUSH
11187: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
11188: LD_OWVAR 2
11192: PPUSH
11193: LD_INT 9
11195: PPUSH
11196: LD_INT 1
11198: PPUSH
11199: LD_INT 1
11201: PPUSH
11202: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
11206: LD_INT 9
11208: PPUSH
11209: LD_OWVAR 2
11213: PPUSH
11214: CALL_OW 343
// uc_side := 9 ;
11218: LD_ADDR_OWVAR 20
11222: PUSH
11223: LD_INT 9
11225: ST_TO_ADDR
// uc_nation := 2 ;
11226: LD_ADDR_OWVAR 21
11230: PUSH
11231: LD_INT 2
11233: ST_TO_ADDR
// hc_name := Dark Warrior ;
11234: LD_ADDR_OWVAR 26
11238: PUSH
11239: LD_STRING Dark Warrior
11241: ST_TO_ADDR
// hc_gallery :=  ;
11242: LD_ADDR_OWVAR 33
11246: PUSH
11247: LD_STRING 
11249: ST_TO_ADDR
// hc_noskilllimit := true ;
11250: LD_ADDR_OWVAR 76
11254: PUSH
11255: LD_INT 1
11257: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
11258: LD_ADDR_OWVAR 31
11262: PUSH
11263: LD_INT 30
11265: PUSH
11266: LD_INT 30
11268: PUSH
11269: LD_INT 30
11271: PUSH
11272: LD_INT 30
11274: PUSH
11275: EMPTY
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: ST_TO_ADDR
// un := CreateHuman ;
11281: LD_ADDR_VAR 0 3
11285: PUSH
11286: CALL_OW 44
11290: ST_TO_ADDR
// hc_noskilllimit := false ;
11291: LD_ADDR_OWVAR 76
11295: PUSH
11296: LD_INT 0
11298: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
11299: LD_VAR 0 3
11303: PPUSH
11304: LD_INT 1
11306: PPUSH
11307: CALL_OW 51
// p := 0 ;
11311: LD_ADDR_VAR 0 2
11315: PUSH
11316: LD_INT 0
11318: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11319: LD_INT 35
11321: PPUSH
11322: CALL_OW 67
// p := p + 1 ;
11326: LD_ADDR_VAR 0 2
11330: PUSH
11331: LD_VAR 0 2
11335: PUSH
11336: LD_INT 1
11338: PLUS
11339: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
11340: LD_VAR 0 3
11344: PPUSH
11345: CALL_OW 256
11349: PUSH
11350: LD_INT 1000
11352: LESS
11353: IFFALSE 11367
// SetLives ( un , 1000 ) ;
11355: LD_VAR 0 3
11359: PPUSH
11360: LD_INT 1000
11362: PPUSH
11363: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
11367: LD_VAR 0 3
11371: PPUSH
11372: LD_INT 81
11374: PUSH
11375: LD_OWVAR 2
11379: PUSH
11380: EMPTY
11381: LIST
11382: LIST
11383: PUSH
11384: LD_INT 91
11386: PUSH
11387: LD_VAR 0 3
11391: PUSH
11392: LD_INT 30
11394: PUSH
11395: EMPTY
11396: LIST
11397: LIST
11398: LIST
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: PPUSH
11404: CALL_OW 69
11408: PPUSH
11409: LD_VAR 0 3
11413: PPUSH
11414: CALL_OW 74
11418: PPUSH
11419: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
11423: LD_VAR 0 2
11427: PUSH
11428: LD_INT 60
11430: GREATER
11431: PUSH
11432: LD_VAR 0 3
11436: PPUSH
11437: CALL_OW 301
11441: OR
11442: IFFALSE 11319
// if un then
11444: LD_VAR 0 3
11448: IFFALSE 11459
// RemoveUnit ( un ) ;
11450: LD_VAR 0 3
11454: PPUSH
11455: CALL_OW 64
// end ; end_of_file
11459: PPOPN 3
11461: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
11462: LD_INT 0
11464: PPUSH
11465: PPUSH
11466: PPUSH
11467: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
11468: LD_VAR 0 1
11472: PPUSH
11473: CALL_OW 264
11477: PUSH
11478: LD_EXP 14
11482: EQUAL
11483: IFFALSE 11555
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
11485: LD_INT 68
11487: PPUSH
11488: LD_VAR 0 1
11492: PPUSH
11493: CALL_OW 255
11497: PPUSH
11498: CALL_OW 321
11502: PUSH
11503: LD_INT 2
11505: EQUAL
11506: IFFALSE 11518
// eff := 70 else
11508: LD_ADDR_VAR 0 4
11512: PUSH
11513: LD_INT 70
11515: ST_TO_ADDR
11516: GO 11526
// eff := 30 ;
11518: LD_ADDR_VAR 0 4
11522: PUSH
11523: LD_INT 30
11525: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
11526: LD_VAR 0 1
11530: PPUSH
11531: CALL_OW 250
11535: PPUSH
11536: LD_VAR 0 1
11540: PPUSH
11541: CALL_OW 251
11545: PPUSH
11546: LD_VAR 0 4
11550: PPUSH
11551: CALL_OW 495
// end ; end ;
11555: LD_VAR 0 2
11559: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
11560: LD_INT 0
11562: PPUSH
// end ;
11563: LD_VAR 0 4
11567: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
11568: LD_INT 0
11570: PPUSH
11571: PPUSH
11572: PPUSH
11573: PPUSH
11574: PPUSH
11575: PPUSH
// if cmd = 124 then
11576: LD_VAR 0 1
11580: PUSH
11581: LD_INT 124
11583: EQUAL
11584: IFFALSE 11790
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
11586: LD_ADDR_VAR 0 5
11590: PUSH
11591: LD_INT 2
11593: PUSH
11594: LD_INT 34
11596: PUSH
11597: LD_INT 53
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: PUSH
11604: LD_INT 34
11606: PUSH
11607: LD_INT 14
11609: PUSH
11610: EMPTY
11611: LIST
11612: LIST
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: LIST
11618: PPUSH
11619: CALL_OW 69
11623: ST_TO_ADDR
// if not tmp then
11624: LD_VAR 0 5
11628: NOT
11629: IFFALSE 11633
// exit ;
11631: GO 11790
// for i in tmp do
11633: LD_ADDR_VAR 0 3
11637: PUSH
11638: LD_VAR 0 5
11642: PUSH
11643: FOR_IN
11644: IFFALSE 11788
// begin taskList := GetTaskList ( i ) ;
11646: LD_ADDR_VAR 0 6
11650: PUSH
11651: LD_VAR 0 3
11655: PPUSH
11656: CALL_OW 437
11660: ST_TO_ADDR
// if not taskList then
11661: LD_VAR 0 6
11665: NOT
11666: IFFALSE 11670
// continue ;
11668: GO 11643
// for j = 1 to taskList do
11670: LD_ADDR_VAR 0 4
11674: PUSH
11675: DOUBLE
11676: LD_INT 1
11678: DEC
11679: ST_TO_ADDR
11680: LD_VAR 0 6
11684: PUSH
11685: FOR_TO
11686: IFFALSE 11784
// if taskList [ j ] [ 1 ] = | then
11688: LD_VAR 0 6
11692: PUSH
11693: LD_VAR 0 4
11697: ARRAY
11698: PUSH
11699: LD_INT 1
11701: ARRAY
11702: PUSH
11703: LD_STRING |
11705: EQUAL
11706: IFFALSE 11782
// begin _taskList := Delete ( taskList , 1 ) ;
11708: LD_ADDR_VAR 0 7
11712: PUSH
11713: LD_VAR 0 6
11717: PPUSH
11718: LD_INT 1
11720: PPUSH
11721: CALL_OW 3
11725: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
11726: LD_VAR 0 3
11730: PPUSH
11731: LD_VAR 0 7
11735: PPUSH
11736: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
11740: LD_VAR 0 3
11744: PPUSH
11745: LD_VAR 0 6
11749: PUSH
11750: LD_VAR 0 4
11754: ARRAY
11755: PUSH
11756: LD_INT 2
11758: ARRAY
11759: PPUSH
11760: LD_VAR 0 6
11764: PUSH
11765: LD_VAR 0 4
11769: ARRAY
11770: PUSH
11771: LD_INT 3
11773: ARRAY
11774: PPUSH
11775: LD_INT 8
11777: PPUSH
11778: CALL 11795 0 4
// end ;
11782: GO 11685
11784: POP
11785: POP
// end ;
11786: GO 11643
11788: POP
11789: POP
// end ; end ;
11790: LD_VAR 0 2
11794: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
11795: LD_INT 0
11797: PPUSH
11798: PPUSH
11799: PPUSH
11800: PPUSH
11801: PPUSH
11802: PPUSH
11803: PPUSH
11804: PPUSH
11805: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
11806: LD_VAR 0 1
11810: NOT
11811: PUSH
11812: LD_VAR 0 2
11816: PPUSH
11817: LD_VAR 0 3
11821: PPUSH
11822: CALL_OW 488
11826: NOT
11827: OR
11828: PUSH
11829: LD_VAR 0 4
11833: NOT
11834: OR
11835: IFFALSE 11839
// exit ;
11837: GO 12179
// list := [ ] ;
11839: LD_ADDR_VAR 0 13
11843: PUSH
11844: EMPTY
11845: ST_TO_ADDR
// if x - r < 0 then
11846: LD_VAR 0 2
11850: PUSH
11851: LD_VAR 0 4
11855: MINUS
11856: PUSH
11857: LD_INT 0
11859: LESS
11860: IFFALSE 11872
// min_x := 0 else
11862: LD_ADDR_VAR 0 7
11866: PUSH
11867: LD_INT 0
11869: ST_TO_ADDR
11870: GO 11888
// min_x := x - r ;
11872: LD_ADDR_VAR 0 7
11876: PUSH
11877: LD_VAR 0 2
11881: PUSH
11882: LD_VAR 0 4
11886: MINUS
11887: ST_TO_ADDR
// if y - r < 0 then
11888: LD_VAR 0 3
11892: PUSH
11893: LD_VAR 0 4
11897: MINUS
11898: PUSH
11899: LD_INT 0
11901: LESS
11902: IFFALSE 11914
// min_y := 0 else
11904: LD_ADDR_VAR 0 8
11908: PUSH
11909: LD_INT 0
11911: ST_TO_ADDR
11912: GO 11930
// min_y := y - r ;
11914: LD_ADDR_VAR 0 8
11918: PUSH
11919: LD_VAR 0 3
11923: PUSH
11924: LD_VAR 0 4
11928: MINUS
11929: ST_TO_ADDR
// max_x := x + r ;
11930: LD_ADDR_VAR 0 9
11934: PUSH
11935: LD_VAR 0 2
11939: PUSH
11940: LD_VAR 0 4
11944: PLUS
11945: ST_TO_ADDR
// max_y := y + r ;
11946: LD_ADDR_VAR 0 10
11950: PUSH
11951: LD_VAR 0 3
11955: PUSH
11956: LD_VAR 0 4
11960: PLUS
11961: ST_TO_ADDR
// for _x = min_x to max_x do
11962: LD_ADDR_VAR 0 11
11966: PUSH
11967: DOUBLE
11968: LD_VAR 0 7
11972: DEC
11973: ST_TO_ADDR
11974: LD_VAR 0 9
11978: PUSH
11979: FOR_TO
11980: IFFALSE 12097
// for _y = min_y to max_y do
11982: LD_ADDR_VAR 0 12
11986: PUSH
11987: DOUBLE
11988: LD_VAR 0 8
11992: DEC
11993: ST_TO_ADDR
11994: LD_VAR 0 10
11998: PUSH
11999: FOR_TO
12000: IFFALSE 12093
// begin if not ValidHex ( _x , _y ) then
12002: LD_VAR 0 11
12006: PPUSH
12007: LD_VAR 0 12
12011: PPUSH
12012: CALL_OW 488
12016: NOT
12017: IFFALSE 12021
// continue ;
12019: GO 11999
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
12021: LD_VAR 0 11
12025: PPUSH
12026: LD_VAR 0 12
12030: PPUSH
12031: CALL_OW 351
12035: PUSH
12036: LD_VAR 0 11
12040: PPUSH
12041: LD_VAR 0 12
12045: PPUSH
12046: CALL_OW 554
12050: AND
12051: IFFALSE 12091
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
12053: LD_ADDR_VAR 0 13
12057: PUSH
12058: LD_VAR 0 13
12062: PPUSH
12063: LD_VAR 0 13
12067: PUSH
12068: LD_INT 1
12070: PLUS
12071: PPUSH
12072: LD_VAR 0 11
12076: PUSH
12077: LD_VAR 0 12
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: PPUSH
12086: CALL_OW 2
12090: ST_TO_ADDR
// end ;
12091: GO 11999
12093: POP
12094: POP
12095: GO 11979
12097: POP
12098: POP
// if not list then
12099: LD_VAR 0 13
12103: NOT
12104: IFFALSE 12108
// exit ;
12106: GO 12179
// for i in list do
12108: LD_ADDR_VAR 0 6
12112: PUSH
12113: LD_VAR 0 13
12117: PUSH
12118: FOR_IN
12119: IFFALSE 12177
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
12121: LD_VAR 0 1
12125: PPUSH
12126: LD_STRING M
12128: PUSH
12129: LD_VAR 0 6
12133: PUSH
12134: LD_INT 1
12136: ARRAY
12137: PUSH
12138: LD_VAR 0 6
12142: PUSH
12143: LD_INT 2
12145: ARRAY
12146: PUSH
12147: LD_INT 0
12149: PUSH
12150: LD_INT 0
12152: PUSH
12153: LD_INT 0
12155: PUSH
12156: LD_INT 0
12158: PUSH
12159: EMPTY
12160: LIST
12161: LIST
12162: LIST
12163: LIST
12164: LIST
12165: LIST
12166: LIST
12167: PUSH
12168: EMPTY
12169: LIST
12170: PPUSH
12171: CALL_OW 447
12175: GO 12118
12177: POP
12178: POP
// end ;
12179: LD_VAR 0 5
12183: RET
