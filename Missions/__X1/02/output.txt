// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 580 0 0
// PrepareAmericans ;
  23: CALL 826 0 0
// PrepareArabian ;
  27: CALL 10225 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 198 0 0
// Action ;
  41: CALL 4605 0 0
// end ;
  45: END
// export debug , prefix , missionStart , aviradzeSpotted , deltaSpotted , sciSpotted , aviradzeQuestDone , sciCounterKill , usAlert , usActiveDefend , timeUntilFarmer , attackDeltaAllowed , trickyMove , usPatrol , trap , lostCounter ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := false ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// aviradzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 6
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 8
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// aviradzeQuestDone := false ;
  97: LD_ADDR_EXP 7
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// attackDeltaAllowed := false ;
 105: LD_ADDR_EXP 12
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// usAlert := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// usActiveDefend := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// usPatrol := [ ] ;
 129: LD_ADDR_EXP 14
 133: PUSH
 134: EMPTY
 135: ST_TO_ADDR
// timeUntilFarmer := [ 40 40$00 , 30 30$00 , 20 20$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 11
 140: PUSH
 141: LD_INT 84000
 143: PUSH
 144: LD_INT 63000
 146: PUSH
 147: LD_INT 42000
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// trickyMove := false ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// prefix := 01_ ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 01_
 176: ST_TO_ADDR
// trap := 0 ;
 177: LD_ADDR_EXP 15
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// lostCounter := false ;
 185: LD_ADDR_EXP 16
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// end ;
 193: LD_VAR 0 1
 197: RET
// function DebugMode ; begin
 198: LD_INT 0
 200: PPUSH
// FogOff ( 1 ) ;
 201: LD_INT 1
 203: PPUSH
 204: CALL_OW 344
// Difficulty := 2 ;
 208: LD_ADDR_OWVAR 67
 212: PUSH
 213: LD_INT 2
 215: ST_TO_ADDR
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
// if exist_mode then
 225: LD_VAR 0 2
 229: IFFALSE 254
// unit := CreateCharacter ( prefix & ident ) else
 231: LD_ADDR_VAR 0 5
 235: PUSH
 236: LD_VAR 0 3
 240: PUSH
 241: LD_VAR 0 1
 245: STR
 246: PPUSH
 247: CALL_OW 34
 251: ST_TO_ADDR
 252: GO 269
// unit := NewCharacter ( ident ) ;
 254: LD_ADDR_VAR 0 5
 258: PUSH
 259: LD_VAR 0 1
 263: PPUSH
 264: CALL_OW 25
 268: ST_TO_ADDR
// result := unit ;
 269: LD_ADDR_VAR 0 4
 273: PUSH
 274: LD_VAR 0 5
 278: ST_TO_ADDR
// end ;
 279: LD_VAR 0 4
 283: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 284: LD_INT 0
 286: PPUSH
// uc_side := side ;
 287: LD_ADDR_OWVAR 20
 291: PUSH
 292: LD_VAR 0 1
 296: ST_TO_ADDR
// uc_nation := nation ;
 297: LD_ADDR_OWVAR 21
 301: PUSH
 302: LD_VAR 0 2
 306: ST_TO_ADDR
// vc_chassis := chassis ;
 307: LD_ADDR_OWVAR 37
 311: PUSH
 312: LD_VAR 0 3
 316: ST_TO_ADDR
// vc_engine := engine ;
 317: LD_ADDR_OWVAR 39
 321: PUSH
 322: LD_VAR 0 4
 326: ST_TO_ADDR
// vc_control := control ;
 327: LD_ADDR_OWVAR 38
 331: PUSH
 332: LD_VAR 0 5
 336: ST_TO_ADDR
// vc_weapon := weapon ;
 337: LD_ADDR_OWVAR 40
 341: PUSH
 342: LD_VAR 0 6
 346: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 347: LD_ADDR_OWVAR 41
 351: PUSH
 352: LD_VAR 0 7
 356: ST_TO_ADDR
// result := CreateVehicle ;
 357: LD_ADDR_VAR 0 8
 361: PUSH
 362: CALL_OW 45
 366: ST_TO_ADDR
// end ;
 367: LD_VAR 0 8
 371: RET
// export function SayX ( units , ident ) ; var i ; begin
 372: LD_INT 0
 374: PPUSH
 375: PPUSH
// result := false ;
 376: LD_ADDR_VAR 0 3
 380: PUSH
 381: LD_INT 0
 383: ST_TO_ADDR
// if not units then
 384: LD_VAR 0 1
 388: NOT
 389: IFFALSE 393
// exit ;
 391: GO 447
// for i in units do
 393: LD_ADDR_VAR 0 4
 397: PUSH
 398: LD_VAR 0 1
 402: PUSH
 403: FOR_IN
 404: IFFALSE 445
// if IsOk ( i ) then
 406: LD_VAR 0 4
 410: PPUSH
 411: CALL_OW 302
 415: IFFALSE 443
// begin Say ( i , ident ) ;
 417: LD_VAR 0 4
 421: PPUSH
 422: LD_VAR 0 2
 426: PPUSH
 427: CALL_OW 88
// result := i ;
 431: LD_ADDR_VAR 0 3
 435: PUSH
 436: LD_VAR 0 4
 440: ST_TO_ADDR
// break ;
 441: GO 445
// end ;
 443: GO 403
 445: POP
 446: POP
// end ;
 447: LD_VAR 0 3
 451: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 452: LD_INT 0
 454: PPUSH
 455: PPUSH
// InitUc ;
 456: CALL_OW 18
// InitHc ;
 460: CALL_OW 19
// uc_side := 0 ;
 464: LD_ADDR_OWVAR 20
 468: PUSH
 469: LD_INT 0
 471: ST_TO_ADDR
// uc_nation := 0 ;
 472: LD_ADDR_OWVAR 21
 476: PUSH
 477: LD_INT 0
 479: ST_TO_ADDR
// for i = 1 to amount do
 480: LD_ADDR_VAR 0 4
 484: PUSH
 485: DOUBLE
 486: LD_INT 1
 488: DEC
 489: ST_TO_ADDR
 490: LD_VAR 0 2
 494: PUSH
 495: FOR_TO
 496: IFFALSE 569
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 498: LD_ADDR_OWVAR 29
 502: PUSH
 503: LD_INT 9
 505: PPUSH
 506: LD_INT 12
 508: PPUSH
 509: CALL_OW 12
 513: PUSH
 514: LD_INT 9
 516: PPUSH
 517: LD_INT 12
 519: PPUSH
 520: CALL_OW 12
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: ST_TO_ADDR
// hc_agressivity := 0 ;
 529: LD_ADDR_OWVAR 35
 533: PUSH
 534: LD_INT 0
 536: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 537: LD_INT 0
 539: PPUSH
 540: LD_INT 12
 542: PPUSH
 543: LD_INT 1
 545: PPUSH
 546: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 550: CALL_OW 44
 554: PPUSH
 555: LD_VAR 0 1
 559: PPUSH
 560: LD_INT 0
 562: PPUSH
 563: CALL_OW 49
// end ;
 567: GO 495
 569: POP
 570: POP
// InitHc ;
 571: CALL_OW 19
// end ;
 575: LD_VAR 0 3
 579: RET
// export function PrepareNature ; var i ; begin
 580: LD_INT 0
 582: PPUSH
 583: PPUSH
// SpawnApeman ( forest , 9 ) ;
 584: LD_INT 1
 586: PPUSH
 587: LD_INT 9
 589: PPUSH
 590: CALL 452 0 2
// for i := 1 to 4 do
 594: LD_ADDR_VAR 0 2
 598: PUSH
 599: DOUBLE
 600: LD_INT 1
 602: DEC
 603: ST_TO_ADDR
 604: LD_INT 4
 606: PUSH
 607: FOR_TO
 608: IFFALSE 643
// begin hc_class := 21 ;
 610: LD_ADDR_OWVAR 28
 614: PUSH
 615: LD_INT 21
 617: ST_TO_ADDR
// hc_gallery :=  ;
 618: LD_ADDR_OWVAR 33
 622: PUSH
 623: LD_STRING 
 625: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 626: CALL_OW 44
 630: PPUSH
 631: LD_INT 1
 633: PPUSH
 634: LD_INT 0
 636: PPUSH
 637: CALL_OW 49
// end ;
 641: GO 607
 643: POP
 644: POP
// for i := 1 to 2 do
 645: LD_ADDR_VAR 0 2
 649: PUSH
 650: DOUBLE
 651: LD_INT 1
 653: DEC
 654: ST_TO_ADDR
 655: LD_INT 2
 657: PUSH
 658: FOR_TO
 659: IFFALSE 694
// begin hc_class := 18 ;
 661: LD_ADDR_OWVAR 28
 665: PUSH
 666: LD_INT 18
 668: ST_TO_ADDR
// hc_gallery :=  ;
 669: LD_ADDR_OWVAR 33
 673: PUSH
 674: LD_STRING 
 676: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 677: CALL_OW 44
 681: PPUSH
 682: LD_INT 1
 684: PPUSH
 685: LD_INT 0
 687: PPUSH
 688: CALL_OW 49
// end ;
 692: GO 658
 694: POP
 695: POP
// for i := 1 to 3 do
 696: LD_ADDR_VAR 0 2
 700: PUSH
 701: DOUBLE
 702: LD_INT 1
 704: DEC
 705: ST_TO_ADDR
 706: LD_INT 3
 708: PUSH
 709: FOR_TO
 710: IFFALSE 745
// begin hc_class := 13 ;
 712: LD_ADDR_OWVAR 28
 716: PUSH
 717: LD_INT 13
 719: ST_TO_ADDR
// hc_gallery :=  ;
 720: LD_ADDR_OWVAR 33
 724: PUSH
 725: LD_STRING 
 727: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 728: CALL_OW 44
 732: PPUSH
 733: LD_INT 1
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 49
// end ;
 743: GO 709
 745: POP
 746: POP
// end ;
 747: LD_VAR 0 1
 751: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 752: LD_INT 0
 754: PPUSH
 755: PPUSH
 756: PPUSH
// if not observer or not unit then
 757: LD_VAR 0 1
 761: NOT
 762: PUSH
 763: LD_VAR 0 2
 767: NOT
 768: OR
 769: IFFALSE 773
// exit ;
 771: GO 821
// if not See ( GetSide ( observer ) , unit ) then
 773: LD_VAR 0 1
 777: PPUSH
 778: CALL_OW 255
 782: PPUSH
 783: LD_VAR 0 2
 787: PPUSH
 788: CALL_OW 292
 792: NOT
 793: IFFALSE 797
// exit ;
 795: GO 821
// result := GetDistUnits ( observer , unit ) < 12 ;
 797: LD_ADDR_VAR 0 3
 801: PUSH
 802: LD_VAR 0 1
 806: PPUSH
 807: LD_VAR 0 2
 811: PPUSH
 812: CALL_OW 296
 816: PUSH
 817: LD_INT 12
 819: LESS
 820: ST_TO_ADDR
// end ; end_of_file
 821: LD_VAR 0 3
 825: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp , arm ; begin
 826: LD_INT 0
 828: PPUSH
 829: PPUSH
 830: PPUSH
 831: PPUSH
 832: PPUSH
 833: PPUSH
// usForces := [ ] ;
 834: LD_ADDR_EXP 19
 838: PUSH
 839: EMPTY
 840: ST_TO_ADDR
// usSci := [ ] ;
 841: LD_ADDR_EXP 20
 845: PUSH
 846: EMPTY
 847: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 848: LD_INT 1
 850: PPUSH
 851: LD_STRING Delta
 853: PPUSH
 854: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 858: LD_INT 1
 860: PPUSH
 861: CALL_OW 274
 865: PPUSH
 866: LD_INT 1
 868: PPUSH
 869: LD_INT 400
 871: PPUSH
 872: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 876: LD_INT 1
 878: PPUSH
 879: CALL_OW 274
 883: PPUSH
 884: LD_INT 2
 886: PPUSH
 887: LD_INT 80
 889: PPUSH
 890: CALL_OW 277
// uc_side := 1 ;
 894: LD_ADDR_OWVAR 20
 898: PUSH
 899: LD_INT 1
 901: ST_TO_ADDR
// uc_nation := 1 ;
 902: LD_ADDR_OWVAR 21
 906: PUSH
 907: LD_INT 1
 909: ST_TO_ADDR
// InitHc ;
 910: CALL_OW 19
// hc_importance := 0 ;
 914: LD_ADDR_OWVAR 32
 918: PUSH
 919: LD_INT 0
 921: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 922: LD_ADDR_EXP 18
 926: PUSH
 927: LD_STRING Lynch
 929: PPUSH
 930: LD_INT 0
 932: PPUSH
 933: LD_STRING 
 935: PPUSH
 936: CALL 221 0 3
 940: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Gladstone
 948: PPUSH
 949: LD_INT 0
 951: PPUSH
 952: LD_STRING 
 954: PPUSH
 955: CALL 221 0 3
 959: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 960: LD_EXP 18
 964: PPUSH
 965: LD_INT 1
 967: PPUSH
 968: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 972: LD_EXP 17
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
 984: LD_ADDR_VAR 0 2
 988: PUSH
 989: DOUBLE
 990: LD_INT 1
 992: DEC
 993: ST_TO_ADDR
 994: LD_INT 1
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: LD_INT 2
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: PUSH
1008: LD_OWVAR 67
1012: ARRAY
1013: PUSH
1014: FOR_TO
1015: IFFALSE 1061
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1017: LD_INT 0
1019: PPUSH
1020: LD_INT 2
1022: PPUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 2
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_OWVAR 67
1041: ARRAY
1042: PPUSH
1043: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
1047: CALL_OW 44
1051: PPUSH
1052: LD_INT 1
1054: PPUSH
1055: CALL_OW 52
// end ;
1059: GO 1014
1061: POP
1062: POP
// for i := 1 to 2 + Difficulty do
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: DOUBLE
1069: LD_INT 1
1071: DEC
1072: ST_TO_ADDR
1073: LD_INT 2
1075: PUSH
1076: LD_OWVAR 67
1080: PLUS
1081: PUSH
1082: FOR_TO
1083: IFFALSE 1168
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1085: LD_INT 0
1087: PPUSH
1088: LD_INT 4
1090: PPUSH
1091: LD_INT 1
1093: PUSH
1094: LD_INT 2
1096: PUSH
1097: LD_INT 2
1099: PUSH
1100: EMPTY
1101: LIST
1102: LIST
1103: LIST
1104: PUSH
1105: LD_OWVAR 67
1109: ARRAY
1110: PPUSH
1111: CALL_OW 380
// un := CreateHuman ;
1115: LD_ADDR_VAR 0 3
1119: PUSH
1120: CALL_OW 44
1124: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
1125: LD_VAR 0 3
1129: PPUSH
1130: LD_INT 3
1132: PPUSH
1133: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
1137: LD_ADDR_EXP 20
1141: PUSH
1142: LD_EXP 20
1146: PPUSH
1147: LD_EXP 20
1151: PUSH
1152: LD_INT 1
1154: PLUS
1155: PPUSH
1156: LD_VAR 0 3
1160: PPUSH
1161: CALL_OW 1
1165: ST_TO_ADDR
// end ;
1166: GO 1082
1168: POP
1169: POP
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
1170: LD_ADDR_VAR 0 6
1174: PUSH
1175: LD_INT 22
1177: PUSH
1178: LD_INT 1
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 30
1187: PUSH
1188: LD_INT 4
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: PPUSH
1199: CALL_OW 69
1203: ST_TO_ADDR
// for i := 1 to 3 + Difficulty do
1204: LD_ADDR_VAR 0 2
1208: PUSH
1209: DOUBLE
1210: LD_INT 1
1212: DEC
1213: ST_TO_ADDR
1214: LD_INT 3
1216: PUSH
1217: LD_OWVAR 67
1221: PLUS
1222: PUSH
1223: FOR_TO
1224: IFFALSE 1302
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1226: LD_INT 0
1228: PPUSH
1229: LD_INT 1
1231: PPUSH
1232: LD_INT 1
1234: PUSH
1235: LD_INT 2
1237: PUSH
1238: LD_INT 3
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: LIST
1245: PUSH
1246: LD_OWVAR 67
1250: ARRAY
1251: PPUSH
1252: CALL_OW 380
// un := CreateHuman ;
1256: LD_ADDR_VAR 0 3
1260: PUSH
1261: CALL_OW 44
1265: ST_TO_ADDR
// usForces := usForces ^ un ;
1266: LD_ADDR_EXP 19
1270: PUSH
1271: LD_EXP 19
1275: PUSH
1276: LD_VAR 0 3
1280: ADD
1281: ST_TO_ADDR
// PlaceHumanInUnit ( un , arm [ 1 ] ) ;
1282: LD_VAR 0 3
1286: PPUSH
1287: LD_VAR 0 6
1291: PUSH
1292: LD_INT 1
1294: ARRAY
1295: PPUSH
1296: CALL_OW 52
// end ;
1300: GO 1223
1302: POP
1303: POP
// PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1304: LD_INT 1
1306: PPUSH
1307: LD_INT 1
1309: PPUSH
1310: LD_INT 1
1312: PPUSH
1313: LD_INT 2
1315: PPUSH
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 2
1321: PPUSH
1322: LD_INT 100
1324: PPUSH
1325: CALL 284 0 7
// veh := CreateVehicle ;
1329: LD_ADDR_VAR 0 4
1333: PUSH
1334: CALL_OW 45
1338: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1339: LD_VAR 0 4
1343: PPUSH
1344: LD_INT 2
1346: PPUSH
1347: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 24 , false ) ;
1351: LD_VAR 0 4
1355: PPUSH
1356: LD_INT 43
1358: PPUSH
1359: LD_INT 24
1361: PPUSH
1362: LD_INT 0
1364: PPUSH
1365: CALL_OW 48
// end ;
1369: LD_VAR 0 1
1373: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1374: LD_INT 0
1376: PPUSH
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// if not usSci then
1382: LD_EXP 20
1386: NOT
1387: IFFALSE 1391
// exit ;
1389: GO 1565
// xy := AreaToList ( tameArea , 0 ) ;
1391: LD_ADDR_VAR 0 6
1395: PUSH
1396: LD_INT 5
1398: PPUSH
1399: LD_INT 0
1401: PPUSH
1402: CALL_OW 517
1406: ST_TO_ADDR
// for i in usSci do
1407: LD_ADDR_VAR 0 2
1411: PUSH
1412: LD_EXP 20
1416: PUSH
1417: FOR_IN
1418: IFFALSE 1563
// begin k := rand ( 1 , xy [ 1 ] ) ;
1420: LD_ADDR_VAR 0 4
1424: PUSH
1425: LD_INT 1
1427: PPUSH
1428: LD_VAR 0 6
1432: PUSH
1433: LD_INT 1
1435: ARRAY
1436: PPUSH
1437: CALL_OW 12
1441: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1442: LD_VAR 0 2
1446: PPUSH
1447: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1451: LD_VAR 0 2
1455: PPUSH
1456: LD_VAR 0 6
1460: PUSH
1461: LD_INT 1
1463: ARRAY
1464: PUSH
1465: LD_VAR 0 4
1469: ARRAY
1470: PPUSH
1471: LD_VAR 0 6
1475: PUSH
1476: LD_INT 2
1478: ARRAY
1479: PUSH
1480: LD_VAR 0 4
1484: ARRAY
1485: PPUSH
1486: CALL_OW 171
// for j := 1 to 2 do
1490: LD_ADDR_VAR 0 3
1494: PUSH
1495: DOUBLE
1496: LD_INT 1
1498: DEC
1499: ST_TO_ADDR
1500: LD_INT 2
1502: PUSH
1503: FOR_TO
1504: IFFALSE 1559
// begin tmp := Delete ( xy [ j ] , k ) ;
1506: LD_ADDR_VAR 0 5
1510: PUSH
1511: LD_VAR 0 6
1515: PUSH
1516: LD_VAR 0 3
1520: ARRAY
1521: PPUSH
1522: LD_VAR 0 4
1526: PPUSH
1527: CALL_OW 3
1531: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1532: LD_ADDR_VAR 0 6
1536: PUSH
1537: LD_VAR 0 6
1541: PPUSH
1542: LD_VAR 0 3
1546: PPUSH
1547: LD_VAR 0 5
1551: PPUSH
1552: CALL_OW 1
1556: ST_TO_ADDR
// end ;
1557: GO 1503
1559: POP
1560: POP
// end ;
1561: GO 1417
1563: POP
1564: POP
// end ;
1565: LD_VAR 0 1
1569: RET
// every 0 0$5 + 0 0$10 trigger aviradzeSpotted and usSci and not usAlert and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1570: LD_EXP 4
1574: PUSH
1575: LD_EXP 20
1579: AND
1580: PUSH
1581: LD_EXP 9
1585: NOT
1586: AND
1587: PUSH
1588: LD_INT 22
1590: PUSH
1591: LD_INT 0
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: PUSH
1598: LD_INT 25
1600: PUSH
1601: LD_INT 12
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PPUSH
1612: CALL_OW 69
1616: AND
1617: IFFALSE 2109
1619: GO 1621
1621: DISABLE
1622: LD_INT 0
1624: PPUSH
1625: PPUSH
1626: PPUSH
1627: PPUSH
1628: PPUSH
// begin enable ;
1629: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1630: LD_EXP 20
1634: PPUSH
1635: LD_INT 2
1637: PUSH
1638: LD_INT 60
1640: PUSH
1641: EMPTY
1642: LIST
1643: PUSH
1644: LD_INT 54
1646: PUSH
1647: EMPTY
1648: LIST
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PPUSH
1655: CALL_OW 72
1659: IFFALSE 1663
// exit ;
1661: GO 2109
// for i in usSci do
1663: LD_ADDR_VAR 0 1
1667: PUSH
1668: LD_EXP 20
1672: PUSH
1673: FOR_IN
1674: IFFALSE 2107
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1676: LD_VAR 0 1
1680: PPUSH
1681: CALL_OW 314
1685: NOT
1686: PUSH
1687: LD_VAR 0 1
1691: PPUSH
1692: CALL_OW 256
1696: PUSH
1697: LD_INT 1000
1699: EQUAL
1700: AND
1701: IFFALSE 1908
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1703: LD_ADDR_VAR 0 5
1707: PUSH
1708: LD_INT 22
1710: PUSH
1711: LD_INT 0
1713: PUSH
1714: EMPTY
1715: LIST
1716: LIST
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: LD_INT 12
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: PPUSH
1732: CALL_OW 69
1736: PPUSH
1737: LD_VAR 0 1
1741: PPUSH
1742: CALL_OW 74
1746: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1747: LD_VAR 0 1
1751: PPUSH
1752: LD_VAR 0 5
1756: PPUSH
1757: CALL_OW 296
1761: PUSH
1762: LD_INT 10
1764: LESS
1765: IFFALSE 1798
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1767: LD_VAR 0 1
1771: PPUSH
1772: LD_VAR 0 5
1776: PPUSH
1777: CALL_OW 250
1781: PPUSH
1782: LD_VAR 0 5
1786: PPUSH
1787: CALL_OW 251
1791: PPUSH
1792: CALL_OW 131
1796: GO 1908
// begin d := rand ( 0 , 5 ) ;
1798: LD_ADDR_VAR 0 4
1802: PUSH
1803: LD_INT 0
1805: PPUSH
1806: LD_INT 5
1808: PPUSH
1809: CALL_OW 12
1813: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1814: LD_ADDR_VAR 0 2
1818: PUSH
1819: LD_VAR 0 1
1823: PPUSH
1824: CALL_OW 250
1828: PPUSH
1829: LD_VAR 0 4
1833: PPUSH
1834: LD_INT 3
1836: PPUSH
1837: CALL_OW 272
1841: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: LD_VAR 0 1
1851: PPUSH
1852: CALL_OW 251
1856: PPUSH
1857: LD_VAR 0 4
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: CALL_OW 273
1869: ST_TO_ADDR
// if not ValidHex ( x , y ) then
1870: LD_VAR 0 2
1874: PPUSH
1875: LD_VAR 0 3
1879: PPUSH
1880: CALL_OW 488
1884: NOT
1885: IFFALSE 1889
// continue ;
1887: GO 1673
// ComMoveXY ( i , x , y ) ;
1889: LD_VAR 0 1
1893: PPUSH
1894: LD_VAR 0 2
1898: PPUSH
1899: LD_VAR 0 3
1903: PPUSH
1904: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
1908: LD_VAR 0 1
1912: PPUSH
1913: CALL_OW 256
1917: PUSH
1918: LD_INT 900
1920: LESS
1921: PUSH
1922: LD_VAR 0 1
1926: PPUSH
1927: LD_INT 37
1929: PPUSH
1930: LD_INT 23
1932: PPUSH
1933: CALL_OW 297
1937: PUSH
1938: LD_INT 10
1940: GREATER
1941: AND
1942: IFFALSE 2018
// begin if IsOk ( Gladstone ) and IsInUnit ( Gladstone ) then
1944: LD_EXP 17
1948: PPUSH
1949: CALL_OW 302
1953: PUSH
1954: LD_EXP 17
1958: PPUSH
1959: CALL_OW 310
1963: AND
1964: IFFALSE 1975
// ComExitBuilding ( Gladstone ) ;
1966: LD_EXP 17
1970: PPUSH
1971: CALL_OW 122
// AddComHeal ( Gladstone , i ) ;
1975: LD_EXP 17
1979: PPUSH
1980: LD_VAR 0 1
1984: PPUSH
1985: CALL_OW 188
// AddComEnterUnit ( Gladstone , usLab ) ;
1989: LD_EXP 17
1993: PPUSH
1994: LD_INT 3
1996: PPUSH
1997: CALL_OW 180
// ComMoveXY ( i , 37 , 23 ) ;
2001: LD_VAR 0 1
2005: PPUSH
2006: LD_INT 37
2008: PPUSH
2009: LD_INT 23
2011: PPUSH
2012: CALL_OW 111
// end else
2016: GO 2105
// if GetLives ( i ) = 1000 then
2018: LD_VAR 0 1
2022: PPUSH
2023: CALL_OW 256
2027: PUSH
2028: LD_INT 1000
2030: EQUAL
2031: IFFALSE 2105
// begin if SideShoot ( i ) = 2 then
2033: LD_VAR 0 1
2037: PPUSH
2038: CALL_OW 503
2042: PUSH
2043: LD_INT 2
2045: EQUAL
2046: IFFALSE 2093
// begin if not usAlert then
2048: LD_EXP 9
2052: NOT
2053: IFFALSE 2063
// usAlert := true ;
2055: LD_ADDR_EXP 9
2059: PUSH
2060: LD_INT 1
2062: ST_TO_ADDR
// AddComEnterUnit ( i , usLab ) ;
2063: LD_VAR 0 1
2067: PPUSH
2068: LD_INT 3
2070: PPUSH
2071: CALL_OW 180
// usSci := usSci diff i ;
2075: LD_ADDR_EXP 20
2079: PUSH
2080: LD_EXP 20
2084: PUSH
2085: LD_VAR 0 1
2089: DIFF
2090: ST_TO_ADDR
// end else
2091: GO 2105
// ComMoveToArea ( i , tameArea ) ;
2093: LD_VAR 0 1
2097: PPUSH
2098: LD_INT 5
2100: PPUSH
2101: CALL_OW 113
// end ; end ;
2105: GO 1673
2107: POP
2108: POP
// end ;
2109: PPOPN 5
2111: END
// every 0 0$1 trigger not usAlert and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 999 ] ] ] ) or FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) ) do
2112: LD_EXP 9
2116: NOT
2117: PUSH
2118: LD_INT 22
2120: PUSH
2121: LD_INT 1
2123: PUSH
2124: EMPTY
2125: LIST
2126: LIST
2127: PUSH
2128: LD_INT 21
2130: PUSH
2131: LD_INT 3
2133: PUSH
2134: EMPTY
2135: LIST
2136: LIST
2137: PUSH
2138: LD_INT 3
2140: PUSH
2141: LD_INT 57
2143: PUSH
2144: EMPTY
2145: LIST
2146: PUSH
2147: EMPTY
2148: LIST
2149: LIST
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 24
2156: PUSH
2157: LD_INT 999
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: PUSH
2164: EMPTY
2165: LIST
2166: LIST
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: LIST
2172: LIST
2173: PPUSH
2174: CALL_OW 69
2178: PUSH
2179: LD_INT 7
2181: PPUSH
2182: LD_INT 22
2184: PUSH
2185: LD_INT 2
2187: PUSH
2188: EMPTY
2189: LIST
2190: LIST
2191: PPUSH
2192: CALL_OW 70
2196: OR
2197: AND
2198: IFFALSE 2211
2200: GO 2202
2202: DISABLE
// usAlert := true ;
2203: LD_ADDR_EXP 9
2207: PUSH
2208: LD_INT 1
2210: ST_TO_ADDR
2211: END
// every 0 0$1 trigger usAlert do var i , b , arm ;
2212: LD_EXP 9
2216: IFFALSE 2563
2218: GO 2220
2220: DISABLE
2221: LD_INT 0
2223: PPUSH
2224: PPUSH
2225: PPUSH
// begin usActiveDefend := true ;
2226: LD_ADDR_EXP 10
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// if not usForces then
2234: LD_EXP 19
2238: NOT
2239: IFFALSE 2243
// exit ;
2241: GO 2563
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
2243: LD_ADDR_VAR 0 3
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: LD_INT 1
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 30
2260: PUSH
2261: LD_INT 4
2263: PUSH
2264: EMPTY
2265: LIST
2266: LIST
2267: PUSH
2268: EMPTY
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
2277: LD_ADDR_VAR 0 2
2281: PUSH
2282: LD_INT 22
2284: PUSH
2285: LD_INT 1
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PUSH
2292: LD_INT 30
2294: PUSH
2295: LD_INT 31
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PPUSH
2306: CALL_OW 69
2310: ST_TO_ADDR
// ComExitBuilding ( Lynch ) ;
2311: LD_EXP 18
2315: PPUSH
2316: CALL_OW 122
// AddComEnterUnit ( Lynch , arm [ 1 ] ) ;
2320: LD_EXP 18
2324: PPUSH
2325: LD_VAR 0 3
2329: PUSH
2330: LD_INT 1
2332: ARRAY
2333: PPUSH
2334: CALL_OW 180
// if IsOk ( Gladstone ) then
2338: LD_EXP 17
2342: PPUSH
2343: CALL_OW 302
2347: IFFALSE 2388
// begin ComExitBuilding ( Gladstone ) ;
2349: LD_EXP 17
2353: PPUSH
2354: CALL_OW 122
// AddComEnterUnit ( Gladstone , arm [ 1 ] ) ;
2358: LD_EXP 17
2362: PPUSH
2363: LD_VAR 0 3
2367: PUSH
2368: LD_INT 1
2370: ARRAY
2371: PPUSH
2372: CALL_OW 180
// AddComChangeProfession ( Gladstone , class_soldier ) ;
2376: LD_EXP 17
2380: PPUSH
2381: LD_INT 1
2383: PPUSH
2384: CALL_OW 183
// end ; ComExitBuilding ( usForces [ 1 ] ) ;
2388: LD_EXP 19
2392: PUSH
2393: LD_INT 1
2395: ARRAY
2396: PPUSH
2397: CALL_OW 122
// AddComEnterUnit ( usForces [ 1 ] , b [ 1 ] ) ;
2401: LD_EXP 19
2405: PUSH
2406: LD_INT 1
2408: ARRAY
2409: PPUSH
2410: LD_VAR 0 2
2414: PUSH
2415: LD_INT 1
2417: ARRAY
2418: PPUSH
2419: CALL_OW 180
// ComExitBuilding ( usForces [ 2 ] ) ;
2423: LD_EXP 19
2427: PUSH
2428: LD_INT 2
2430: ARRAY
2431: PPUSH
2432: CALL_OW 122
// AddComEnterUnit ( usForces [ 2 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
2436: LD_EXP 19
2440: PUSH
2441: LD_INT 2
2443: ARRAY
2444: PPUSH
2445: LD_INT 22
2447: PUSH
2448: LD_INT 1
2450: PUSH
2451: EMPTY
2452: LIST
2453: LIST
2454: PUSH
2455: LD_INT 30
2457: PUSH
2458: LD_INT 32
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: PPUSH
2469: CALL_OW 69
2473: PUSH
2474: LD_INT 1
2476: ARRAY
2477: PPUSH
2478: CALL_OW 180
// if b > 1 and usForces > 2 then
2482: LD_VAR 0 2
2486: PUSH
2487: LD_INT 1
2489: GREATER
2490: PUSH
2491: LD_EXP 19
2495: PUSH
2496: LD_INT 2
2498: GREATER
2499: AND
2500: IFFALSE 2563
// begin repeat wait ( 0 0$1 ) ;
2502: LD_INT 35
2504: PPUSH
2505: CALL_OW 67
// until BuildingStatus ( b [ 2 ] ) <> bs_build ;
2509: LD_VAR 0 2
2513: PUSH
2514: LD_INT 2
2516: ARRAY
2517: PPUSH
2518: CALL_OW 461
2522: PUSH
2523: LD_INT 1
2525: NONEQUAL
2526: IFFALSE 2502
// ComExitBuilding ( usForces [ 3 ] ) ;
2528: LD_EXP 19
2532: PUSH
2533: LD_INT 3
2535: ARRAY
2536: PPUSH
2537: CALL_OW 122
// AddComEnterUnit ( usForces [ 3 ] , b [ 2 ] ) ;
2541: LD_EXP 19
2545: PUSH
2546: LD_INT 3
2548: ARRAY
2549: PPUSH
2550: LD_VAR 0 2
2554: PUSH
2555: LD_INT 2
2557: ARRAY
2558: PPUSH
2559: CALL_OW 180
// end ; end ;
2563: PPOPN 3
2565: END
// every 0 0$1 trigger GetLives ( usLab ) < 999 and usAlert and usForces do var i ;
2566: LD_INT 3
2568: PPUSH
2569: CALL_OW 256
2573: PUSH
2574: LD_INT 999
2576: LESS
2577: PUSH
2578: LD_EXP 9
2582: AND
2583: PUSH
2584: LD_EXP 19
2588: AND
2589: IFFALSE 2760
2591: GO 2593
2593: DISABLE
2594: LD_INT 0
2596: PPUSH
// begin for i in usForces do
2597: LD_ADDR_VAR 0 1
2601: PUSH
2602: LD_EXP 19
2606: PUSH
2607: FOR_IN
2608: IFFALSE 2647
// begin if IsInUnit ( i ) then
2610: LD_VAR 0 1
2614: PPUSH
2615: CALL_OW 310
2619: IFFALSE 2630
// ComExitBuilding ( i ) ;
2621: LD_VAR 0 1
2625: PPUSH
2626: CALL_OW 122
// AddComAgressiveMove ( i , 31 , 8 ) ;
2630: LD_VAR 0 1
2634: PPUSH
2635: LD_INT 31
2637: PPUSH
2638: LD_INT 8
2640: PPUSH
2641: CALL_OW 174
// end ;
2645: GO 2607
2647: POP
2648: POP
// wait ( 0 0$8 ) ;
2649: LD_INT 280
2651: PPUSH
2652: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) then
2656: LD_INT 22
2658: PUSH
2659: LD_INT 2
2661: PUSH
2662: EMPTY
2663: LIST
2664: LIST
2665: PUSH
2666: LD_INT 91
2668: PUSH
2669: LD_INT 3
2671: PUSH
2672: LD_INT 14
2674: PUSH
2675: EMPTY
2676: LIST
2677: LIST
2678: LIST
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: PPUSH
2684: CALL_OW 69
2688: IFFALSE 2738
// ComAttackUnit ( usForces , FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) [ 1 ] ) else
2690: LD_EXP 19
2694: PPUSH
2695: LD_INT 22
2697: PUSH
2698: LD_INT 2
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: PUSH
2705: LD_INT 91
2707: PUSH
2708: LD_INT 3
2710: PUSH
2711: LD_INT 14
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: LIST
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: PPUSH
2723: CALL_OW 69
2727: PUSH
2728: LD_INT 1
2730: ARRAY
2731: PPUSH
2732: CALL_OW 115
2736: GO 2760
// begin wait ( 0 0$20 ) ;
2738: LD_INT 700
2740: PPUSH
2741: CALL_OW 67
// AddComMoveXY ( usForces , 39 , 19 ) ;
2745: LD_EXP 19
2749: PPUSH
2750: LD_INT 39
2752: PPUSH
2753: LD_INT 19
2755: PPUSH
2756: CALL_OW 171
// end ; end ;
2760: PPOPN 1
2762: END
// every 0 0$3 trigger ( GetDistUnits ( Heike , Delta ) < 10 or GetLives ( usLab ) < 999 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do var tmp , veh ;
2763: LD_EXP 21
2767: PPUSH
2768: LD_INT 1
2770: PPUSH
2771: CALL_OW 296
2775: PUSH
2776: LD_INT 10
2778: LESS
2779: PUSH
2780: LD_INT 3
2782: PPUSH
2783: CALL_OW 256
2787: PUSH
2788: LD_INT 999
2790: LESS
2791: OR
2792: PUSH
2793: LD_INT 22
2795: PUSH
2796: LD_INT 1
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: LD_INT 25
2805: PUSH
2806: LD_INT 2
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: PUSH
2813: EMPTY
2814: LIST
2815: LIST
2816: PPUSH
2817: CALL_OW 69
2821: AND
2822: IFFALSE 3006
2824: GO 2826
2826: DISABLE
2827: LD_INT 0
2829: PPUSH
2830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
2831: LD_ADDR_VAR 0 1
2835: PUSH
2836: LD_INT 22
2838: PUSH
2839: LD_INT 1
2841: PUSH
2842: EMPTY
2843: LIST
2844: LIST
2845: PUSH
2846: LD_INT 25
2848: PUSH
2849: LD_INT 2
2851: PUSH
2852: EMPTY
2853: LIST
2854: LIST
2855: PUSH
2856: EMPTY
2857: LIST
2858: LIST
2859: PPUSH
2860: CALL_OW 69
2864: ST_TO_ADDR
// veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2865: LD_ADDR_VAR 0 2
2869: PUSH
2870: LD_INT 22
2872: PUSH
2873: LD_INT 1
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PUSH
2880: LD_INT 21
2882: PUSH
2883: LD_INT 2
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: PUSH
2890: LD_INT 58
2892: PUSH
2893: EMPTY
2894: LIST
2895: PUSH
2896: EMPTY
2897: LIST
2898: LIST
2899: LIST
2900: PPUSH
2901: CALL_OW 69
2905: ST_TO_ADDR
// if not tmp then
2906: LD_VAR 0 1
2910: NOT
2911: IFFALSE 2915
// exit ;
2913: GO 3006
// ComExitBuilding ( tmp ) ;
2915: LD_VAR 0 1
2919: PPUSH
2920: CALL_OW 122
// AddComDismantle ( tmp , usLab ) ;
2924: LD_VAR 0 1
2928: PPUSH
2929: LD_INT 3
2931: PPUSH
2932: CALL_OW 227
// if veh and IsOk ( Gladstone ) then
2936: LD_VAR 0 2
2940: PUSH
2941: LD_EXP 17
2945: PPUSH
2946: CALL_OW 302
2950: AND
2951: IFFALSE 3006
// begin if IsInUnit ( Gladstone ) then
2953: LD_EXP 17
2957: PPUSH
2958: CALL_OW 310
2962: IFFALSE 2973
// ComExitBuilding ( Gladstone ) ;
2964: LD_EXP 17
2968: PPUSH
2969: CALL_OW 122
// AddComEnterUnit ( Gladstone , veh [ 1 ] ) ;
2973: LD_EXP 17
2977: PPUSH
2978: LD_VAR 0 2
2982: PUSH
2983: LD_INT 1
2985: ARRAY
2986: PPUSH
2987: CALL_OW 180
// AddComAgressiveMove ( Gladstone , 39 , 14 ) ;
2991: LD_EXP 17
2995: PPUSH
2996: LD_INT 39
2998: PPUSH
2999: LD_INT 14
3001: PPUSH
3002: CALL_OW 174
// end ; end ;
3006: PPOPN 2
3008: END
// every 0 0$1 trigger usAlert and FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) do var i , tmp ;
3009: LD_EXP 9
3013: PUSH
3014: LD_INT 7
3016: PPUSH
3017: LD_INT 22
3019: PUSH
3020: LD_INT 1
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 21
3029: PUSH
3030: LD_INT 1
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 3
3039: PUSH
3040: LD_INT 24
3042: PUSH
3043: LD_INT 600
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: PPUSH
3059: CALL_OW 70
3063: AND
3064: IFFALSE 3192
3066: GO 3068
3068: DISABLE
3069: LD_INT 0
3071: PPUSH
3072: PPUSH
// begin enable ;
3073: ENABLE
// tmp := FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) ;
3074: LD_ADDR_VAR 0 2
3078: PUSH
3079: LD_INT 7
3081: PPUSH
3082: LD_INT 22
3084: PUSH
3085: LD_INT 1
3087: PUSH
3088: EMPTY
3089: LIST
3090: LIST
3091: PUSH
3092: LD_INT 21
3094: PUSH
3095: LD_INT 1
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PUSH
3102: LD_INT 3
3104: PUSH
3105: LD_INT 24
3107: PUSH
3108: LD_INT 600
3110: PUSH
3111: EMPTY
3112: LIST
3113: LIST
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: LIST
3123: PPUSH
3124: CALL_OW 70
3128: ST_TO_ADDR
// if not tmp then
3129: LD_VAR 0 2
3133: NOT
3134: IFFALSE 3138
// exit ;
3136: GO 3192
// for i in tmp do
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: LD_VAR 0 2
3147: PUSH
3148: FOR_IN
3149: IFFALSE 3190
// if IsInUnit ( i ) then
3151: LD_VAR 0 1
3155: PPUSH
3156: CALL_OW 310
3160: IFFALSE 3173
// ComExitBuilding ( i ) else
3162: LD_VAR 0 1
3166: PPUSH
3167: CALL_OW 122
3171: GO 3188
// ComMoveXY ( i , 48 , 74 ) ;
3173: LD_VAR 0 1
3177: PPUSH
3178: LD_INT 48
3180: PPUSH
3181: LD_INT 74
3183: PPUSH
3184: CALL_OW 111
3188: GO 3148
3190: POP
3191: POP
// end ;
3192: PPOPN 2
3194: END
// every 5 5$00 do var i , un , tmp ;
3195: GO 3197
3197: DISABLE
3198: LD_INT 0
3200: PPUSH
3201: PPUSH
3202: PPUSH
// begin tmp := [ ] ;
3203: LD_ADDR_VAR 0 3
3207: PUSH
3208: EMPTY
3209: ST_TO_ADDR
// uc_side := 1 ;
3210: LD_ADDR_OWVAR 20
3214: PUSH
3215: LD_INT 1
3217: ST_TO_ADDR
// uc_nation := 1 ;
3218: LD_ADDR_OWVAR 21
3222: PUSH
3223: LD_INT 1
3225: ST_TO_ADDR
// case Difficulty of 1 :
3226: LD_OWVAR 67
3230: PUSH
3231: LD_INT 1
3233: DOUBLE
3234: EQUAL
3235: IFTRUE 3239
3237: GO 3342
3239: POP
// begin wait ( 1 1$00 ) ;
3240: LD_INT 2100
3242: PPUSH
3243: CALL_OW 67
// for i := 1 to 2 do
3247: LD_ADDR_VAR 0 1
3251: PUSH
3252: DOUBLE
3253: LD_INT 1
3255: DEC
3256: ST_TO_ADDR
3257: LD_INT 2
3259: PUSH
3260: FOR_TO
3261: IFFALSE 3338
// begin PrepareHuman ( false , [ 1 , 4 ] [ i mod 2 + 1 ] , 1 ) ;
3263: LD_INT 0
3265: PPUSH
3266: LD_INT 1
3268: PUSH
3269: LD_INT 4
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PUSH
3276: LD_VAR 0 1
3280: PUSH
3281: LD_INT 2
3283: MOD
3284: PUSH
3285: LD_INT 1
3287: PLUS
3288: ARRAY
3289: PPUSH
3290: LD_INT 1
3292: PPUSH
3293: CALL_OW 380
// un := CreateHuman ;
3297: LD_ADDR_VAR 0 2
3301: PUSH
3302: CALL_OW 44
3306: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3307: LD_ADDR_VAR 0 3
3311: PUSH
3312: LD_VAR 0 3
3316: PPUSH
3317: LD_VAR 0 3
3321: PUSH
3322: LD_INT 1
3324: PLUS
3325: PPUSH
3326: LD_VAR 0 2
3330: PPUSH
3331: CALL_OW 1
3335: ST_TO_ADDR
// end ;
3336: GO 3260
3338: POP
3339: POP
// end ; 2 :
3340: GO 3736
3342: LD_INT 2
3344: DOUBLE
3345: EQUAL
3346: IFTRUE 3350
3348: GO 3484
3350: POP
// begin wait ( 0 0$30 ) ;
3351: LD_INT 1050
3353: PPUSH
3354: CALL_OW 67
// for i := 1 to 2 do
3358: LD_ADDR_VAR 0 1
3362: PUSH
3363: DOUBLE
3364: LD_INT 1
3366: DEC
3367: ST_TO_ADDR
3368: LD_INT 2
3370: PUSH
3371: FOR_TO
3372: IFFALSE 3428
// begin PrepareHuman ( false , 1 , 2 ) ;
3374: LD_INT 0
3376: PPUSH
3377: LD_INT 1
3379: PPUSH
3380: LD_INT 2
3382: PPUSH
3383: CALL_OW 380
// un := CreateHuman ;
3387: LD_ADDR_VAR 0 2
3391: PUSH
3392: CALL_OW 44
3396: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3397: LD_ADDR_VAR 0 3
3401: PUSH
3402: LD_VAR 0 3
3406: PPUSH
3407: LD_VAR 0 3
3411: PUSH
3412: LD_INT 1
3414: PLUS
3415: PPUSH
3416: LD_VAR 0 2
3420: PPUSH
3421: CALL_OW 1
3425: ST_TO_ADDR
// end ;
3426: GO 3371
3428: POP
3429: POP
// PrepareHuman ( false , 4 , 2 ) ;
3430: LD_INT 0
3432: PPUSH
3433: LD_INT 4
3435: PPUSH
3436: LD_INT 2
3438: PPUSH
3439: CALL_OW 380
// un := CreateHuman ;
3443: LD_ADDR_VAR 0 2
3447: PUSH
3448: CALL_OW 44
3452: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3453: LD_ADDR_VAR 0 3
3457: PUSH
3458: LD_VAR 0 3
3462: PPUSH
3463: LD_VAR 0 3
3467: PUSH
3468: LD_INT 1
3470: PLUS
3471: PPUSH
3472: LD_VAR 0 2
3476: PPUSH
3477: CALL_OW 1
3481: ST_TO_ADDR
// end ; 3 :
3482: GO 3736
3484: LD_INT 3
3486: DOUBLE
3487: EQUAL
3488: IFTRUE 3492
3490: GO 3735
3492: POP
// begin for i := 1 to 2 do
3493: LD_ADDR_VAR 0 1
3497: PUSH
3498: DOUBLE
3499: LD_INT 1
3501: DEC
3502: ST_TO_ADDR
3503: LD_INT 2
3505: PUSH
3506: FOR_TO
3507: IFFALSE 3563
// begin PrepareHuman ( false , 1 , 2 ) ;
3509: LD_INT 0
3511: PPUSH
3512: LD_INT 1
3514: PPUSH
3515: LD_INT 2
3517: PPUSH
3518: CALL_OW 380
// un := CreateHuman ;
3522: LD_ADDR_VAR 0 2
3526: PUSH
3527: CALL_OW 44
3531: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3532: LD_ADDR_VAR 0 3
3536: PUSH
3537: LD_VAR 0 3
3541: PPUSH
3542: LD_VAR 0 3
3546: PUSH
3547: LD_INT 1
3549: PLUS
3550: PPUSH
3551: LD_VAR 0 2
3555: PPUSH
3556: CALL_OW 1
3560: ST_TO_ADDR
// end ;
3561: GO 3506
3563: POP
3564: POP
// PrepareHuman ( false , 4 , 2 ) ;
3565: LD_INT 0
3567: PPUSH
3568: LD_INT 4
3570: PPUSH
3571: LD_INT 2
3573: PPUSH
3574: CALL_OW 380
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 2
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3588: LD_ADDR_VAR 0 3
3592: PUSH
3593: LD_VAR 0 3
3597: PPUSH
3598: LD_VAR 0 3
3602: PUSH
3603: LD_INT 1
3605: PLUS
3606: PPUSH
3607: LD_VAR 0 2
3611: PPUSH
3612: CALL_OW 1
3616: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_machine_gun , 90 ) ;
3617: LD_INT 1
3619: PPUSH
3620: LD_INT 1
3622: PPUSH
3623: LD_INT 2
3625: PPUSH
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 1
3631: PPUSH
3632: LD_INT 2
3634: PPUSH
3635: LD_INT 90
3637: PPUSH
3638: CALL 284 0 7
// un := CreateVehicle ;
3642: LD_ADDR_VAR 0 2
3646: PUSH
3647: CALL_OW 45
3651: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: LD_VAR 0 3
3661: PPUSH
3662: LD_VAR 0 3
3666: PUSH
3667: LD_INT 1
3669: PLUS
3670: PPUSH
3671: LD_VAR 0 2
3675: PPUSH
3676: CALL_OW 1
3680: ST_TO_ADDR
// PrepareHuman ( false , 1 , 2 ) ;
3681: LD_INT 0
3683: PPUSH
3684: LD_INT 1
3686: PPUSH
3687: LD_INT 2
3689: PPUSH
3690: CALL_OW 380
// un := CreateHuman ;
3694: LD_ADDR_VAR 0 2
3698: PUSH
3699: CALL_OW 44
3703: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3704: LD_ADDR_VAR 0 3
3708: PUSH
3709: LD_VAR 0 3
3713: PPUSH
3714: LD_VAR 0 3
3718: PUSH
3719: LD_INT 1
3721: PLUS
3722: PPUSH
3723: LD_VAR 0 2
3727: PPUSH
3728: CALL_OW 1
3732: ST_TO_ADDR
// end ; end ;
3733: GO 3736
3735: POP
// for i := 1 to tmp do
3736: LD_ADDR_VAR 0 1
3740: PUSH
3741: DOUBLE
3742: LD_INT 1
3744: DEC
3745: ST_TO_ADDR
3746: LD_VAR 0 3
3750: PUSH
3751: FOR_TO
3752: IFFALSE 3917
// begin SetDir ( tmp [ i ] , 1 ) ;
3754: LD_VAR 0 3
3758: PUSH
3759: LD_VAR 0 1
3763: ARRAY
3764: PPUSH
3765: LD_INT 1
3767: PPUSH
3768: CALL_OW 233
// if GetType ( tmp [ i ] ) = unit_human then
3772: LD_VAR 0 3
3776: PUSH
3777: LD_VAR 0 1
3781: ARRAY
3782: PPUSH
3783: CALL_OW 247
3787: PUSH
3788: LD_INT 1
3790: EQUAL
3791: IFFALSE 3819
// PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) else
3793: LD_VAR 0 3
3797: PUSH
3798: LD_VAR 0 1
3802: ARRAY
3803: PPUSH
3804: LD_INT 28
3806: PPUSH
3807: LD_INT 52
3809: PPUSH
3810: LD_INT 0
3812: PPUSH
3813: CALL_OW 48
3817: GO 3887
// begin PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) ;
3819: LD_VAR 0 3
3823: PUSH
3824: LD_VAR 0 1
3828: ARRAY
3829: PPUSH
3830: LD_INT 28
3832: PPUSH
3833: LD_INT 52
3835: PPUSH
3836: LD_INT 0
3838: PPUSH
3839: CALL_OW 48
// i := i + 1 ;
3843: LD_ADDR_VAR 0 1
3847: PUSH
3848: LD_VAR 0 1
3852: PUSH
3853: LD_INT 1
3855: PLUS
3856: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ i ] , tmp [ i - 1 ] ) ;
3857: LD_VAR 0 3
3861: PUSH
3862: LD_VAR 0 1
3866: ARRAY
3867: PPUSH
3868: LD_VAR 0 3
3872: PUSH
3873: LD_VAR 0 1
3877: PUSH
3878: LD_INT 1
3880: MINUS
3881: ARRAY
3882: PPUSH
3883: CALL_OW 52
// end ; ComMoveXY ( tmp [ i ] , 43 , 56 ) ;
3887: LD_VAR 0 3
3891: PUSH
3892: LD_VAR 0 1
3896: ARRAY
3897: PPUSH
3898: LD_INT 43
3900: PPUSH
3901: LD_INT 56
3903: PPUSH
3904: CALL_OW 111
// wait ( 0 0$2 ) ;
3908: LD_INT 70
3910: PPUSH
3911: CALL_OW 67
// end ;
3915: GO 3751
3917: POP
3918: POP
// wait ( 0 0$2 ) ;
3919: LD_INT 70
3921: PPUSH
3922: CALL_OW 67
// if not FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) then
3926: LD_INT 7
3928: PPUSH
3929: LD_INT 22
3931: PUSH
3932: LD_INT 2
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: PPUSH
3939: CALL_OW 70
3943: NOT
3944: IFFALSE 4142
// begin AddComAgressiveMove ( tmp , 35 , 24 ) ;
3946: LD_VAR 0 3
3950: PPUSH
3951: LD_INT 35
3953: PPUSH
3954: LD_INT 24
3956: PPUSH
3957: CALL_OW 174
// usForces := usForces union UnitFilter ( tmp , [ f_class , 1 ] ) ;
3961: LD_ADDR_EXP 19
3965: PUSH
3966: LD_EXP 19
3970: PUSH
3971: LD_VAR 0 3
3975: PPUSH
3976: LD_INT 25
3978: PUSH
3979: LD_INT 1
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: PPUSH
3986: CALL_OW 72
3990: UNION
3991: ST_TO_ADDR
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
3992: LD_INT 22
3994: PUSH
3995: LD_INT 1
3997: PUSH
3998: EMPTY
3999: LIST
4000: LIST
4001: PUSH
4002: LD_INT 30
4004: PUSH
4005: LD_INT 4
4007: PUSH
4008: EMPTY
4009: LIST
4010: LIST
4011: PUSH
4012: EMPTY
4013: LIST
4014: LIST
4015: PPUSH
4016: CALL_OW 69
4020: PUSH
4021: LD_INT 1
4023: ARRAY
4024: PPUSH
4025: CALL_OW 313
4029: PUSH
4030: LD_INT 6
4032: LESS
4033: IFFALSE 4092
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
4035: LD_VAR 0 3
4039: PPUSH
4040: LD_INT 25
4042: PUSH
4043: LD_INT 1
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: PPUSH
4050: CALL_OW 72
4054: PPUSH
4055: LD_INT 22
4057: PUSH
4058: LD_INT 1
4060: PUSH
4061: EMPTY
4062: LIST
4063: LIST
4064: PUSH
4065: LD_INT 30
4067: PUSH
4068: LD_INT 4
4070: PUSH
4071: EMPTY
4072: LIST
4073: LIST
4074: PUSH
4075: EMPTY
4076: LIST
4077: LIST
4078: PPUSH
4079: CALL_OW 69
4083: PUSH
4084: LD_INT 1
4086: ARRAY
4087: PPUSH
4088: CALL_OW 180
// if UnitFilter ( tmp , [ f_class , 4 ] ) then
4092: LD_VAR 0 3
4096: PPUSH
4097: LD_INT 25
4099: PUSH
4100: LD_INT 4
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: PPUSH
4107: CALL_OW 72
4111: IFFALSE 4140
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 4 ] ) , usLab ) ;
4113: LD_VAR 0 3
4117: PPUSH
4118: LD_INT 25
4120: PUSH
4121: LD_INT 4
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: PPUSH
4128: CALL_OW 72
4132: PPUSH
4133: LD_INT 3
4135: PPUSH
4136: CALL_OW 180
// end else
4140: GO 4417
// begin tmp := tmp union FilterUnitsInArea ( retreatArea , [ f_side , 1 ] ) ;
4142: LD_ADDR_VAR 0 3
4146: PUSH
4147: LD_VAR 0 3
4151: PUSH
4152: LD_INT 6
4154: PPUSH
4155: LD_INT 22
4157: PUSH
4158: LD_INT 1
4160: PUSH
4161: EMPTY
4162: LIST
4163: LIST
4164: PPUSH
4165: CALL_OW 70
4169: UNION
4170: ST_TO_ADDR
// ComMoveXY ( tmp , 45 , 54 ) ;
4171: LD_VAR 0 3
4175: PPUSH
4176: LD_INT 45
4178: PPUSH
4179: LD_INT 54
4181: PPUSH
4182: CALL_OW 111
// wait ( 0 0$3 ) ;
4186: LD_INT 105
4188: PPUSH
4189: CALL_OW 67
// AddComAgressiveMove ( tmp diff UnitFilter ( tmp , [ f_class , 4 ] ) , 35 , 24 ) ;
4193: LD_VAR 0 3
4197: PUSH
4198: LD_VAR 0 3
4202: PPUSH
4203: LD_INT 25
4205: PUSH
4206: LD_INT 4
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PPUSH
4213: CALL_OW 72
4217: DIFF
4218: PPUSH
4219: LD_INT 35
4221: PPUSH
4222: LD_INT 24
4224: PPUSH
4225: CALL_OW 174
// AddComMoveXY ( UnitFilter ( tmp , [ f_class , 4 ] ) , 42 , 49 ) ;
4229: LD_VAR 0 3
4233: PPUSH
4234: LD_INT 25
4236: PUSH
4237: LD_INT 4
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PPUSH
4244: CALL_OW 72
4248: PPUSH
4249: LD_INT 42
4251: PPUSH
4252: LD_INT 49
4254: PPUSH
4255: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4259: LD_INT 35
4261: PPUSH
4262: CALL_OW 67
// for i in tmp do
4266: LD_ADDR_VAR 0 1
4270: PUSH
4271: LD_VAR 0 3
4275: PUSH
4276: FOR_IN
4277: IFFALSE 4408
// if IsDead ( i ) then
4279: LD_VAR 0 1
4283: PPUSH
4284: CALL_OW 301
4288: IFFALSE 4308
// tmp := tmp diff i else
4290: LD_ADDR_VAR 0 3
4294: PUSH
4295: LD_VAR 0 3
4299: PUSH
4300: LD_VAR 0 1
4304: DIFF
4305: ST_TO_ADDR
4306: GO 4406
// if GetClass ( i ) = 1 then
4308: LD_VAR 0 1
4312: PPUSH
4313: CALL_OW 257
4317: PUSH
4318: LD_INT 1
4320: EQUAL
4321: IFFALSE 4406
// begin if GetLives ( i ) < 600 and GetDistUnitXY ( i , 42 , 49 ) > 6 then
4323: LD_VAR 0 1
4327: PPUSH
4328: CALL_OW 256
4332: PUSH
4333: LD_INT 600
4335: LESS
4336: PUSH
4337: LD_VAR 0 1
4341: PPUSH
4342: LD_INT 42
4344: PPUSH
4345: LD_INT 49
4347: PPUSH
4348: CALL_OW 297
4352: PUSH
4353: LD_INT 6
4355: GREATER
4356: AND
4357: IFFALSE 4376
// ComMoveXY ( i , 42 , 49 ) else
4359: LD_VAR 0 1
4363: PPUSH
4364: LD_INT 42
4366: PPUSH
4367: LD_INT 49
4369: PPUSH
4370: CALL_OW 111
4374: GO 4406
// if GetLives ( i ) = 1000 then
4376: LD_VAR 0 1
4380: PPUSH
4381: CALL_OW 256
4385: PUSH
4386: LD_INT 1000
4388: EQUAL
4389: IFFALSE 4406
// ComAgressiveMove ( i , 36 , 25 ) ;
4391: LD_VAR 0 1
4395: PPUSH
4396: LD_INT 36
4398: PPUSH
4399: LD_INT 25
4401: PPUSH
4402: CALL_OW 114
// end ;
4406: GO 4276
4408: POP
4409: POP
// until not tmp ;
4410: LD_VAR 0 3
4414: NOT
4415: IFFALSE 4259
// end ; end ;
4417: PPOPN 3
4419: END
// every 0 0$1 trigger FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) and not attackDeltaAllowed do var i , un , veh ;
4420: LD_INT 7
4422: PPUSH
4423: LD_INT 22
4425: PUSH
4426: LD_INT 2
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PPUSH
4433: CALL_OW 70
4437: PUSH
4438: LD_EXP 12
4442: NOT
4443: AND
4444: IFFALSE 4602
4446: GO 4448
4448: DISABLE
4449: LD_INT 0
4451: PPUSH
4452: PPUSH
4453: PPUSH
// begin for i := 1 to 2 do
4454: LD_ADDR_VAR 0 1
4458: PUSH
4459: DOUBLE
4460: LD_INT 1
4462: DEC
4463: ST_TO_ADDR
4464: LD_INT 2
4466: PUSH
4467: FOR_TO
4468: IFFALSE 4600
// begin wait ( 0 0$3 ) ;
4470: LD_INT 105
4472: PPUSH
4473: CALL_OW 67
// uc_side := 1 ;
4477: LD_ADDR_OWVAR 20
4481: PUSH
4482: LD_INT 1
4484: ST_TO_ADDR
// uc_nation := 1 ;
4485: LD_ADDR_OWVAR 21
4489: PUSH
4490: LD_INT 1
4492: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 90 ) ;
4493: LD_INT 1
4495: PPUSH
4496: LD_INT 1
4498: PPUSH
4499: LD_INT 2
4501: PPUSH
4502: LD_INT 1
4504: PPUSH
4505: LD_INT 1
4507: PPUSH
4508: LD_INT 4
4510: PPUSH
4511: LD_INT 90
4513: PPUSH
4514: CALL 284 0 7
// veh := CreateVehicle ;
4518: LD_ADDR_VAR 0 3
4522: PUSH
4523: CALL_OW 45
4527: ST_TO_ADDR
// PlaceUnitXY ( veh , 29 , 52 , false ) ;
4528: LD_VAR 0 3
4532: PPUSH
4533: LD_INT 29
4535: PPUSH
4536: LD_INT 52
4538: PPUSH
4539: LD_INT 0
4541: PPUSH
4542: CALL_OW 48
// PrepareHuman ( false , 3 , 3 ) ;
4546: LD_INT 0
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: CALL_OW 380
// un := CreateHuman ;
4559: LD_ADDR_VAR 0 2
4563: PUSH
4564: CALL_OW 44
4568: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4569: LD_VAR 0 2
4573: PPUSH
4574: LD_VAR 0 3
4578: PPUSH
4579: CALL_OW 52
// ComAgressiveMove ( veh , 36 , 25 ) ;
4583: LD_VAR 0 3
4587: PPUSH
4588: LD_INT 36
4590: PPUSH
4591: LD_INT 25
4593: PPUSH
4594: CALL_OW 114
// end ;
4598: GO 4467
4600: POP
4601: POP
// end ; end_of_file
4602: PPOPN 3
4604: END
// export function Action ; var i , tmp ; begin
4605: LD_INT 0
4607: PPUSH
4608: PPUSH
4609: PPUSH
// InGameOn ;
4610: CALL_OW 8
// DoNotAttack ( 2 , usLab ) ;
4614: LD_INT 2
4616: PPUSH
4617: LD_INT 3
4619: PPUSH
4620: CALL_OW 471
// ComMoveXY ( Heike , 78 , 61 ) ;
4624: LD_EXP 21
4628: PPUSH
4629: LD_INT 78
4631: PPUSH
4632: LD_INT 61
4634: PPUSH
4635: CALL_OW 111
// if Mike then
4639: LD_EXP 23
4643: IFFALSE 4660
// ComMoveXY ( Mike , 80 , 66 ) ;
4645: LD_EXP 23
4649: PPUSH
4650: LD_INT 80
4652: PPUSH
4653: LD_INT 66
4655: PPUSH
4656: CALL_OW 111
// if Givi then
4660: LD_EXP 22
4664: IFFALSE 4681
// ComMoveXY ( Givi , 82 , 66 ) ;
4666: LD_EXP 22
4670: PPUSH
4671: LD_INT 82
4673: PPUSH
4674: LD_INT 66
4676: PPUSH
4677: CALL_OW 111
// if Kamil then
4681: LD_EXP 24
4685: IFFALSE 4702
// ComMoveXY ( Kamil , 82 , 67 ) ;
4687: LD_EXP 24
4691: PPUSH
4692: LD_INT 82
4694: PPUSH
4695: LD_INT 67
4697: PPUSH
4698: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
4702: LD_EXP 21
4706: PPUSH
4707: CALL_OW 87
// wait ( 0 0$2 ) ;
4711: LD_INT 70
4713: PPUSH
4714: CALL_OW 67
// if Givi and Mike then
4718: LD_EXP 22
4722: PUSH
4723: LD_EXP 23
4727: AND
4728: IFFALSE 5174
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4730: LD_EXP 22
4734: PUSH
4735: LD_EXP 23
4739: PUSH
4740: LD_EXP 24
4744: PUSH
4745: EMPTY
4746: LIST
4747: LIST
4748: LIST
4749: PPUSH
4750: LD_EXP 21
4754: PPUSH
4755: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
4759: LD_EXP 21
4763: PPUSH
4764: LD_EXP 22
4768: PPUSH
4769: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
4773: LD_EXP 22
4777: PPUSH
4778: LD_STRING DG-1-start
4780: PPUSH
4781: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
4785: LD_EXP 21
4789: PPUSH
4790: LD_STRING DH-1-start
4792: PPUSH
4793: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
4797: LD_EXP 23
4801: PPUSH
4802: LD_EXP 21
4806: PPUSH
4807: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
4811: LD_EXP 21
4815: PPUSH
4816: LD_EXP 23
4820: PPUSH
4821: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
4825: LD_EXP 23
4829: PPUSH
4830: LD_STRING DM-1-start
4832: PPUSH
4833: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
4837: LD_EXP 21
4841: PPUSH
4842: LD_STRING DH-2-start
4844: PPUSH
4845: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
4849: LD_EXP 23
4853: PPUSH
4854: LD_STRING DM-2-start
4856: PPUSH
4857: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
4861: LD_EXP 22
4865: PPUSH
4866: LD_STRING DG-2-start
4868: PPUSH
4869: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
4873: LD_EXP 23
4877: PPUSH
4878: LD_EXP 22
4882: PPUSH
4883: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
4887: LD_EXP 21
4891: PPUSH
4892: LD_EXP 23
4896: PPUSH
4897: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
4901: LD_EXP 23
4905: PPUSH
4906: LD_STRING DM-3-start
4908: PPUSH
4909: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
4913: LD_EXP 21
4917: PPUSH
4918: LD_STRING DH-3-start
4920: PPUSH
4921: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
4925: LD_EXP 21
4929: PUSH
4930: LD_EXP 23
4934: PUSH
4935: LD_EXP 22
4939: PUSH
4940: LD_EXP 24
4944: PUSH
4945: EMPTY
4946: LIST
4947: LIST
4948: LIST
4949: LIST
4950: PPUSH
4951: LD_INT 84
4953: PPUSH
4954: LD_INT 51
4956: PPUSH
4957: CALL_OW 111
// wait ( 0 0$2 ) ;
4961: LD_INT 70
4963: PPUSH
4964: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
4968: LD_EXP 22
4972: PPUSH
4973: LD_STRING DG-3-start
4975: PPUSH
4976: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
4980: LD_EXP 21
4984: PUSH
4985: LD_EXP 23
4989: PUSH
4990: LD_EXP 22
4994: PUSH
4995: LD_EXP 24
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: PPUSH
5006: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
5010: LD_EXP 21
5014: PPUSH
5015: LD_EXP 22
5019: PPUSH
5020: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
5024: LD_EXP 22
5028: PUSH
5029: LD_EXP 23
5033: PUSH
5034: LD_EXP 24
5038: PUSH
5039: EMPTY
5040: LIST
5041: LIST
5042: LIST
5043: PPUSH
5044: LD_EXP 21
5048: PPUSH
5049: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
5053: LD_EXP 21
5057: PPUSH
5058: LD_STRING DH-4-start
5060: PPUSH
5061: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
5065: LD_EXP 22
5069: PPUSH
5070: LD_STRING DG-4-start
5072: PPUSH
5073: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
5077: LD_EXP 21
5081: PPUSH
5082: LD_STRING DH-5-start
5084: PPUSH
5085: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
5089: LD_EXP 22
5093: PPUSH
5094: LD_STRING DG-5-start
5096: PPUSH
5097: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
5101: LD_EXP 21
5105: PPUSH
5106: LD_STRING DH-6-start
5108: PPUSH
5109: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
5113: LD_EXP 23
5117: PPUSH
5118: LD_STRING DM-6-start
5120: PPUSH
5121: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
5125: LD_EXP 21
5129: PUSH
5130: LD_EXP 22
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: LD_EXP 23
5143: PPUSH
5144: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
5148: LD_EXP 22
5152: PPUSH
5153: LD_STRING DG-6-start
5155: PPUSH
5156: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
5160: LD_EXP 21
5164: PPUSH
5165: LD_STRING DH-7-start
5167: PPUSH
5168: CALL_OW 88
// end else
5172: GO 5896
// if not Mike and Givi then
5174: LD_EXP 23
5178: NOT
5179: PUSH
5180: LD_EXP 22
5184: AND
5185: IFFALSE 5530
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5187: LD_EXP 22
5191: PUSH
5192: LD_EXP 24
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: PPUSH
5201: LD_EXP 21
5205: PPUSH
5206: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
5210: LD_EXP 21
5214: PPUSH
5215: LD_EXP 22
5219: PPUSH
5220: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
5224: LD_EXP 22
5228: PPUSH
5229: LD_STRING DG-1-start-c
5231: PPUSH
5232: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
5236: LD_EXP 21
5240: PPUSH
5241: LD_STRING DH-1-start-c
5243: PPUSH
5244: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
5248: LD_EXP 22
5252: PPUSH
5253: LD_STRING DG-2-start-c
5255: PPUSH
5256: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
5260: LD_EXP 21
5264: PPUSH
5265: LD_STRING DH-2-start-c
5267: PPUSH
5268: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
5272: LD_EXP 22
5276: PPUSH
5277: LD_STRING DG-3-start-c
5279: PPUSH
5280: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
5284: LD_EXP 21
5288: PPUSH
5289: LD_INT 83
5291: PPUSH
5292: LD_INT 56
5294: PPUSH
5295: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
5299: LD_EXP 22
5303: PPUSH
5304: LD_INT 83
5306: PPUSH
5307: LD_INT 59
5309: PPUSH
5310: CALL_OW 111
// if Kamil then
5314: LD_EXP 24
5318: IFFALSE 5335
// ComMoveXY ( Kamil , 80 , 58 ) ;
5320: LD_EXP 24
5324: PPUSH
5325: LD_INT 80
5327: PPUSH
5328: LD_INT 58
5330: PPUSH
5331: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
5335: LD_EXP 21
5339: PPUSH
5340: LD_EXP 22
5344: PPUSH
5345: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5349: LD_EXP 22
5353: PUSH
5354: LD_EXP 24
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: PPUSH
5363: LD_EXP 21
5367: PPUSH
5368: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
5372: LD_EXP 21
5376: PPUSH
5377: LD_STRING DH-3-start-c
5379: PPUSH
5380: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
5384: LD_EXP 22
5388: PPUSH
5389: LD_STRING DG-4-start-c
5391: PPUSH
5392: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
5396: LD_EXP 21
5400: PPUSH
5401: LD_STRING DH-5-start-c
5403: PPUSH
5404: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
5408: LD_EXP 22
5412: PPUSH
5413: LD_STRING DG-5-start-c
5415: PPUSH
5416: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
5420: LD_EXP 21
5424: PPUSH
5425: LD_STRING DH-6-start-c
5427: PPUSH
5428: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
5432: LD_EXP 22
5436: PPUSH
5437: LD_STRING DG-6-start-c
5439: PPUSH
5440: CALL_OW 88
// if Kamil then
5444: LD_EXP 24
5448: IFFALSE 5504
// begin ComTurnUnit ( Kamil , Heike ) ;
5450: LD_EXP 24
5454: PPUSH
5455: LD_EXP 21
5459: PPUSH
5460: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5464: LD_EXP 24
5468: PPUSH
5469: LD_STRING DKam-1-start-c
5471: PPUSH
5472: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
5476: LD_EXP 22
5480: PPUSH
5481: LD_EXP 24
5485: PPUSH
5486: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
5490: LD_EXP 22
5494: PPUSH
5495: LD_STRING DG-7-start-c
5497: PPUSH
5498: CALL_OW 88
// end else
5502: GO 5528
// begin Say ( Givi , DG-8-start-c ) ;
5504: LD_EXP 22
5508: PPUSH
5509: LD_STRING DG-8-start-c
5511: PPUSH
5512: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
5516: LD_EXP 21
5520: PPUSH
5521: LD_STRING DH-7-start-c
5523: PPUSH
5524: CALL_OW 88
// end ; end else
5528: GO 5896
// if not Givi and Mike then
5530: LD_EXP 22
5534: NOT
5535: PUSH
5536: LD_EXP 23
5540: AND
5541: IFFALSE 5800
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
5543: LD_EXP 23
5547: PUSH
5548: LD_EXP 24
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PPUSH
5557: LD_EXP 21
5561: PPUSH
5562: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
5566: LD_EXP 21
5570: PPUSH
5571: LD_EXP 23
5575: PPUSH
5576: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
5580: LD_EXP 23
5584: PPUSH
5585: LD_STRING DM-1-start-b
5587: PPUSH
5588: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
5592: LD_EXP 21
5596: PPUSH
5597: LD_STRING DH-1-start-b
5599: PPUSH
5600: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
5604: LD_EXP 23
5608: PPUSH
5609: LD_STRING DM-2-start-b
5611: PPUSH
5612: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
5616: LD_EXP 21
5620: PPUSH
5621: LD_STRING DH-2-start-b
5623: PPUSH
5624: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
5628: LD_EXP 23
5632: PPUSH
5633: LD_STRING DM-3-start-b
5635: PPUSH
5636: CALL_OW 88
// if Kamil then
5640: LD_EXP 24
5644: IFFALSE 5661
// ComMoveXY ( Kamil , 80 , 58 ) ;
5646: LD_EXP 24
5650: PPUSH
5651: LD_INT 80
5653: PPUSH
5654: LD_INT 58
5656: PPUSH
5657: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
5661: LD_EXP 21
5665: PPUSH
5666: LD_INT 83
5668: PPUSH
5669: LD_INT 56
5671: PPUSH
5672: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
5676: LD_EXP 23
5680: PPUSH
5681: LD_INT 83
5683: PPUSH
5684: LD_INT 59
5686: PPUSH
5687: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
5691: LD_EXP 21
5695: PPUSH
5696: LD_EXP 23
5700: PPUSH
5701: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
5705: LD_EXP 24
5709: PUSH
5710: LD_EXP 23
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PPUSH
5719: LD_EXP 21
5723: PPUSH
5724: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
5728: LD_EXP 21
5732: PPUSH
5733: LD_STRING DH-3-start-b
5735: PPUSH
5736: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
5740: LD_EXP 23
5744: PPUSH
5745: LD_STRING DM-4-start-b
5747: PPUSH
5748: CALL_OW 88
// if Kamil then
5752: LD_EXP 24
5756: IFFALSE 5786
// begin ComTurnUnit ( Kamil , Heike ) ;
5758: LD_EXP 24
5762: PPUSH
5763: LD_EXP 21
5767: PPUSH
5768: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5772: LD_EXP 24
5776: PPUSH
5777: LD_STRING DKam-1-start-c
5779: PPUSH
5780: CALL_OW 88
// end else
5784: GO 5798
// begin Say ( Mike , DM-5-start-b ) ;
5786: LD_EXP 23
5790: PPUSH
5791: LD_STRING DM-5-start-b
5793: PPUSH
5794: CALL_OW 88
// end ; end else
5798: GO 5896
// if Kamil then
5800: LD_EXP 24
5804: IFFALSE 5884
// begin AddComTurnUnit ( Heike , Kamil ) ;
5806: LD_EXP 21
5810: PPUSH
5811: LD_EXP 24
5815: PPUSH
5816: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
5820: LD_EXP 24
5824: PPUSH
5825: LD_EXP 21
5829: PPUSH
5830: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
5834: LD_EXP 21
5838: PPUSH
5839: LD_STRING DH-1-start-f
5841: PPUSH
5842: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
5846: LD_EXP 24
5850: PPUSH
5851: LD_STRING DKam-1-start-f
5853: PPUSH
5854: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
5858: LD_EXP 21
5862: PPUSH
5863: LD_STRING DH-2-start-f
5865: PPUSH
5866: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
5870: LD_EXP 24
5874: PPUSH
5875: LD_STRING DKam-2-start-f
5877: PPUSH
5878: CALL_OW 88
// end else
5882: GO 5896
// begin Say ( Heike , DH-1-start-d ) ;
5884: LD_EXP 21
5888: PPUSH
5889: LD_STRING DH-1-start-d
5891: PPUSH
5892: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
5896: LD_EXP 21
5900: PUSH
5901: LD_EXP 22
5905: PUSH
5906: LD_EXP 23
5910: PUSH
5911: LD_EXP 24
5915: PUSH
5916: EMPTY
5917: LIST
5918: LIST
5919: LIST
5920: LIST
5921: PPUSH
5922: CALL_OW 139
// InGameOff ;
5926: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
5930: LD_STRING OEast
5932: PPUSH
5933: CALL_OW 337
// SaveForQuickRestart ;
5937: CALL_OW 22
// wait ( 0 0$20 ) ;
5941: LD_INT 700
5943: PPUSH
5944: CALL_OW 67
// SendSciToForest ;
5948: CALL 1374 0 0
// if Difficulty = 1 then
5952: LD_OWVAR 67
5956: PUSH
5957: LD_INT 1
5959: EQUAL
5960: IFFALSE 5964
// exit ;
5962: GO 6081
// wait ( [ 5 5$00 , 2 2$30 ] [ Difficulty - 1 ] ) ;
5964: LD_INT 10500
5966: PUSH
5967: LD_INT 5250
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: PUSH
5974: LD_OWVAR 67
5978: PUSH
5979: LD_INT 1
5981: MINUS
5982: ARRAY
5983: PPUSH
5984: CALL_OW 67
// if usAlert then
5988: LD_EXP 9
5992: IFFALSE 5996
// exit ;
5994: GO 6081
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
5996: LD_ADDR_VAR 0 3
6000: PUSH
6001: LD_INT 22
6003: PUSH
6004: LD_INT 1
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: PUSH
6011: LD_INT 25
6013: PUSH
6014: LD_INT 2
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: PPUSH
6025: CALL_OW 69
6029: ST_TO_ADDR
// if not tmp then
6030: LD_VAR 0 3
6034: NOT
6035: IFFALSE 6039
// exit ;
6037: GO 6081
// ComExitBuilding ( tmp ) ;
6039: LD_VAR 0 3
6043: PPUSH
6044: CALL_OW 122
// AddComBuild ( tmp , b_breastwork , 40 , 13 , 3 ) ;
6048: LD_VAR 0 3
6052: PPUSH
6053: LD_INT 31
6055: PPUSH
6056: LD_INT 40
6058: PPUSH
6059: LD_INT 13
6061: PPUSH
6062: LD_INT 3
6064: PPUSH
6065: CALL_OW 205
// AddComEnterUnit ( tmp , Delta ) ;
6069: LD_VAR 0 3
6073: PPUSH
6074: LD_INT 1
6076: PPUSH
6077: CALL_OW 180
// end ;
6081: LD_VAR 0 1
6085: RET
// every 3 3$00 do
6086: GO 6088
6088: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
6089: LD_INT 1
6091: PPUSH
6092: LD_INT 570
6094: PPUSH
6095: LD_INT 350
6097: PPUSH
6098: CALL_OW 550
// wait ( 2 2$40 ) ;
6102: LD_INT 5600
6104: PPUSH
6105: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
6109: LD_INT 0
6111: PPUSH
6112: LD_INT 570
6114: PPUSH
6115: LD_INT 350
6117: PPUSH
6118: CALL_OW 550
// end ;
6122: END
// every 0 0$1 trigger not aviradzeSpotted and See ( 2 , Aviradze ) do var i , pepAmount ;
6123: LD_EXP 4
6127: NOT
6128: PUSH
6129: LD_INT 2
6131: PPUSH
6132: LD_EXP 25
6136: PPUSH
6137: CALL_OW 292
6141: AND
6142: IFFALSE 7077
6144: GO 6146
6146: DISABLE
6147: LD_INT 0
6149: PPUSH
6150: PPUSH
// begin aviradzeSpotted := true ;
6151: LD_ADDR_EXP 4
6155: PUSH
6156: LD_INT 1
6158: ST_TO_ADDR
// pepAmount := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
6159: LD_ADDR_VAR 0 2
6163: PUSH
6164: LD_INT 22
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: EMPTY
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 21
6176: PUSH
6177: LD_INT 1
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: PPUSH
6188: CALL_OW 69
6192: ST_TO_ADDR
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6193: LD_EXP 21
6197: PPUSH
6198: LD_EXP 25
6202: PPUSH
6203: CALL_OW 250
6207: PPUSH
6208: LD_EXP 25
6212: PPUSH
6213: CALL_OW 251
6217: PPUSH
6218: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6222: LD_INT 35
6224: PPUSH
6225: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 16 ;
6229: LD_EXP 21
6233: PPUSH
6234: LD_EXP 25
6238: PPUSH
6239: CALL_OW 296
6243: PUSH
6244: LD_INT 16
6246: LESS
6247: IFFALSE 6222
// InGameOn ;
6249: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6253: LD_INT 5
6255: PPUSH
6256: LD_INT 2
6258: PPUSH
6259: CALL_OW 343
// if pepAmount > 2 then
6263: LD_VAR 0 2
6267: PUSH
6268: LD_INT 2
6270: GREATER
6271: IFFALSE 6287
// Say ( Heike , DH-1-spot ) else
6273: LD_EXP 21
6277: PPUSH
6278: LD_STRING DH-1-spot
6280: PPUSH
6281: CALL_OW 88
6285: GO 6299
// Say ( Heike , DH-1-spot-d ) ;
6287: LD_EXP 21
6291: PPUSH
6292: LD_STRING DH-1-spot-d
6294: PPUSH
6295: CALL_OW 88
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6299: LD_EXP 21
6303: PPUSH
6304: LD_EXP 25
6308: PPUSH
6309: CALL_OW 250
6313: PPUSH
6314: LD_EXP 25
6318: PPUSH
6319: CALL_OW 251
6323: PPUSH
6324: CALL_OW 111
// for i in [ Kamil , Mike , Givi ] do
6328: LD_ADDR_VAR 0 1
6332: PUSH
6333: LD_EXP 24
6337: PUSH
6338: LD_EXP 23
6342: PUSH
6343: LD_EXP 22
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: LIST
6352: PUSH
6353: FOR_IN
6354: IFFALSE 6393
// if GetDistUnits ( i , Aviradze ) > 7 then
6356: LD_VAR 0 1
6360: PPUSH
6361: LD_EXP 25
6365: PPUSH
6366: CALL_OW 296
6370: PUSH
6371: LD_INT 7
6373: GREATER
6374: IFFALSE 6391
// ComMoveXY ( i , 102 , 40 ) ;
6376: LD_VAR 0 1
6380: PPUSH
6381: LD_INT 102
6383: PPUSH
6384: LD_INT 40
6386: PPUSH
6387: CALL_OW 111
6391: GO 6353
6393: POP
6394: POP
// repeat wait ( 0 0$1 ) ;
6395: LD_INT 35
6397: PPUSH
6398: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 6 ;
6402: LD_EXP 21
6406: PPUSH
6407: LD_EXP 25
6411: PPUSH
6412: CALL_OW 296
6416: PUSH
6417: LD_INT 6
6419: LESS
6420: IFFALSE 6395
// ComTurnUnit ( Heike , Aviradze ) ;
6422: LD_EXP 21
6426: PPUSH
6427: LD_EXP 25
6431: PPUSH
6432: CALL_OW 119
// ComTurnUnit ( [ Aviradze , Sophia , Kaia ] , Heike ) ;
6436: LD_EXP 25
6440: PUSH
6441: LD_EXP 27
6445: PUSH
6446: LD_EXP 26
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: LIST
6455: PPUSH
6456: LD_EXP 21
6460: PPUSH
6461: CALL_OW 119
// if pepAmount > 1 then
6465: LD_VAR 0 2
6469: PUSH
6470: LD_INT 1
6472: GREATER
6473: IFFALSE 6525
// begin wait ( 0 0$2 ) ;
6475: LD_INT 70
6477: PPUSH
6478: CALL_OW 67
// ComTurnUnit ( [ Kamil , Mike , Givi ] , Aviradze ) ;
6482: LD_EXP 24
6486: PUSH
6487: LD_EXP 23
6491: PUSH
6492: LD_EXP 22
6496: PUSH
6497: EMPTY
6498: LIST
6499: LIST
6500: LIST
6501: PPUSH
6502: LD_EXP 25
6506: PPUSH
6507: CALL_OW 119
// Say ( Heike , DH-2-spot ) ;
6511: LD_EXP 21
6515: PPUSH
6516: LD_STRING DH-2-spot
6518: PPUSH
6519: CALL_OW 88
// end else
6523: GO 6537
// Say ( Heike , DH-2-spot-d ) ;
6525: LD_EXP 21
6529: PPUSH
6530: LD_STRING DH-2-spot-d
6532: PPUSH
6533: CALL_OW 88
// Say ( Aviradze , DA-2-spot ) ;
6537: LD_EXP 25
6541: PPUSH
6542: LD_STRING DA-2-spot
6544: PPUSH
6545: CALL_OW 88
// Say ( Heike , DH-3-spot ) ;
6549: LD_EXP 21
6553: PPUSH
6554: LD_STRING DH-3-spot
6556: PPUSH
6557: CALL_OW 88
// ComMoveUnit ( Kaia , Heike ) ;
6561: LD_EXP 26
6565: PPUSH
6566: LD_EXP 21
6570: PPUSH
6571: CALL_OW 112
// ComTurnUNit ( Heike , Kaia ) ;
6575: LD_EXP 21
6579: PPUSH
6580: LD_EXP 26
6584: PPUSH
6585: CALL_OW 119
// wait ( 0 0$0.3 ) ;
6589: LD_INT 10
6591: PPUSH
6592: CALL_OW 67
// async ;
6596: ASYNC
// Say ( Kaia , DK-3-spot ) ;
6597: LD_EXP 26
6601: PPUSH
6602: LD_STRING DK-3-spot
6604: PPUSH
6605: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6609: LD_INT 35
6611: PPUSH
6612: CALL_OW 67
// until GetDistUnits ( Heike , Kaia ) < 4 ;
6616: LD_EXP 21
6620: PPUSH
6621: LD_EXP 26
6625: PPUSH
6626: CALL_OW 296
6630: PUSH
6631: LD_INT 4
6633: LESS
6634: IFFALSE 6609
// ComTurnUnit ( Kaia , Heike ) ;
6636: LD_EXP 26
6640: PPUSH
6641: LD_EXP 21
6645: PPUSH
6646: CALL_OW 119
// sync ;
6650: SYNC
// Say ( Heike , DH-4-spot ) ;
6651: LD_EXP 21
6655: PPUSH
6656: LD_STRING DH-4-spot
6658: PPUSH
6659: CALL_OW 88
// wait ( 0 0$0.3 ) ;
6663: LD_INT 10
6665: PPUSH
6666: CALL_OW 67
// ComTurnUnit ( Heike , Aviradze ) ;
6670: LD_EXP 21
6674: PPUSH
6675: LD_EXP 25
6679: PPUSH
6680: CALL_OW 119
// Say ( Aviradze , DA-4-spot ) ;
6684: LD_EXP 25
6688: PPUSH
6689: LD_STRING DA-4-spot
6691: PPUSH
6692: CALL_OW 88
// ComTurnUnit ( Kaia , Aviradze ) ;
6696: LD_EXP 26
6700: PPUSH
6701: LD_EXP 25
6705: PPUSH
6706: CALL_OW 119
// Say ( Kaia , DK-4-spot ) ;
6710: LD_EXP 26
6714: PPUSH
6715: LD_STRING DK-4-spot
6717: PPUSH
6718: CALL_OW 88
// ComTurnUnit ( Aviradze , Kaia ) ;
6722: LD_EXP 25
6726: PPUSH
6727: LD_EXP 26
6731: PPUSH
6732: CALL_OW 119
// Say ( Aviradze , DA-5-spot ) ;
6736: LD_EXP 25
6740: PPUSH
6741: LD_STRING DA-5-spot
6743: PPUSH
6744: CALL_OW 88
// Say ( Kaia , DK-5-spot ) ;
6748: LD_EXP 26
6752: PPUSH
6753: LD_STRING DK-5-spot
6755: PPUSH
6756: CALL_OW 88
// if pepAmount = 1 then
6760: LD_VAR 0 2
6764: PUSH
6765: LD_INT 1
6767: EQUAL
6768: IFFALSE 6782
// Say ( Heike , DH-5-spot-f ) ;
6770: LD_EXP 21
6774: PPUSH
6775: LD_STRING DH-5-spot-f
6777: PPUSH
6778: CALL_OW 88
// if pepAmount < 3 then
6782: LD_VAR 0 2
6786: PUSH
6787: LD_INT 3
6789: LESS
6790: IFFALSE 6806
// Say ( Aviradze , DA-6-spot-f ) else
6792: LD_EXP 25
6796: PPUSH
6797: LD_STRING DA-6-spot-f
6799: PPUSH
6800: CALL_OW 88
6804: GO 6842
// if pepAmount < 4 then
6806: LD_VAR 0 2
6810: PUSH
6811: LD_INT 4
6813: LESS
6814: IFFALSE 6830
// Say ( Aviradze , DA-6-spot-c ) else
6816: LD_EXP 25
6820: PPUSH
6821: LD_STRING DA-6-spot-c
6823: PPUSH
6824: CALL_OW 88
6828: GO 6842
// Say ( Aviradze , DA-6-spot ) ;
6830: LD_EXP 25
6834: PPUSH
6835: LD_STRING DA-6-spot
6837: PPUSH
6838: CALL_OW 88
// if Kamil then
6842: LD_EXP 24
6846: IFFALSE 6860
// Say ( Kamil , DKam-6-spot ) ;
6848: LD_EXP 24
6852: PPUSH
6853: LD_STRING DKam-6-spot
6855: PPUSH
6856: CALL_OW 88
// Say ( Kaia , DK-6-spot ) ;
6860: LD_EXP 26
6864: PPUSH
6865: LD_STRING DK-6-spot
6867: PPUSH
6868: CALL_OW 88
// ComTurnUnit ( Aviradze , Heike ) ;
6872: LD_EXP 25
6876: PPUSH
6877: LD_EXP 21
6881: PPUSH
6882: CALL_OW 119
// Say ( Aviradze , DA-7-spot ) ;
6886: LD_EXP 25
6890: PPUSH
6891: LD_STRING DA-7-spot
6893: PPUSH
6894: CALL_OW 88
// Say ( Heike , DH-7-spot ) ;
6898: LD_EXP 21
6902: PPUSH
6903: LD_STRING DH-7-spot
6905: PPUSH
6906: CALL_OW 88
// if sciCounterKill >= 3 then
6910: LD_EXP 8
6914: PUSH
6915: LD_INT 3
6917: GREATEREQUAL
6918: IFFALSE 6944
// begin Say ( Heike , DH-7-spot-a ) ;
6920: LD_EXP 21
6924: PPUSH
6925: LD_STRING DH-7-spot-a
6927: PPUSH
6928: CALL_OW 88
// Say ( Aviradze , DA-8-spot-a ) ;
6932: LD_EXP 25
6936: PPUSH
6937: LD_STRING DA-8-spot-a
6939: PPUSH
6940: CALL_OW 88
// end ; InGameOff ;
6944: CALL_OW 9
// if sciCounterKill < 3 then
6948: LD_EXP 8
6952: PUSH
6953: LD_INT 3
6955: LESS
6956: IFFALSE 7015
// begin SetSide ( Kaia , 2 ) ;
6958: LD_EXP 26
6962: PPUSH
6963: LD_INT 2
6965: PPUSH
6966: CALL_OW 235
// ComFree ( Kaia ) ;
6970: LD_EXP 26
6974: PPUSH
6975: CALL_OW 139
// if Kamil then
6979: LD_EXP 24
6983: IFFALSE 7006
// begin ComHold ( Kamil ) ;
6985: LD_EXP 24
6989: PPUSH
6990: CALL_OW 140
// SetSide ( Kamil , 5 ) ;
6994: LD_EXP 24
6998: PPUSH
6999: LD_INT 5
7001: PPUSH
7002: CALL_OW 235
// end ; ChangeMissionObjectives ( OSci ) ;
7006: LD_STRING OSci
7008: PPUSH
7009: CALL_OW 337
// end else
7013: GO 7077
// begin aviradzeQuestDone := true ;
7015: LD_ADDR_EXP 7
7019: PUSH
7020: LD_INT 1
7022: ST_TO_ADDR
// attackDeltaAllowed := true ;
7023: LD_ADDR_EXP 12
7027: PUSH
7028: LD_INT 1
7030: ST_TO_ADDR
// ChangeMissionObjectives ( ODelta2 ) ;
7031: LD_STRING ODelta2
7033: PPUSH
7034: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7038: LD_ADDR_VAR 0 1
7042: PUSH
7043: LD_INT 22
7045: PUSH
7046: LD_INT 5
7048: PUSH
7049: EMPTY
7050: LIST
7051: LIST
7052: PPUSH
7053: CALL_OW 69
7057: PUSH
7058: FOR_IN
7059: IFFALSE 7075
// SetSide ( i , 2 ) ;
7061: LD_VAR 0 1
7065: PPUSH
7066: LD_INT 2
7068: PPUSH
7069: CALL_OW 235
7073: GO 7058
7075: POP
7076: POP
// end ; end ;
7077: PPOPN 2
7079: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and not aviradzeSpotted do
7080: LD_EXP 6
7084: NOT
7085: PUSH
7086: LD_EXP 20
7090: PPUSH
7091: LD_EXP 21
7095: PPUSH
7096: CALL_OW 74
7100: PPUSH
7101: LD_EXP 21
7105: PPUSH
7106: CALL_OW 296
7110: PUSH
7111: LD_INT 8
7113: LESS
7114: AND
7115: PUSH
7116: LD_INT 2
7118: PPUSH
7119: LD_EXP 20
7123: PPUSH
7124: LD_EXP 21
7128: PPUSH
7129: CALL_OW 74
7133: PPUSH
7134: CALL_OW 292
7138: AND
7139: PUSH
7140: LD_INT 22
7142: PUSH
7143: LD_INT 2
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: PUSH
7150: LD_INT 21
7152: PUSH
7153: LD_INT 1
7155: PUSH
7156: EMPTY
7157: LIST
7158: LIST
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PPUSH
7164: CALL_OW 69
7168: PUSH
7169: LD_INT 1
7171: GREATER
7172: AND
7173: PUSH
7174: LD_EXP 4
7178: NOT
7179: AND
7180: IFFALSE 7224
7182: GO 7184
7184: DISABLE
// begin sciSpotted := true ;
7185: LD_ADDR_EXP 6
7189: PUSH
7190: LD_INT 1
7192: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7193: LD_EXP 20
7197: PPUSH
7198: LD_EXP 21
7202: PPUSH
7203: CALL_OW 74
7207: PPUSH
7208: CALL_OW 87
// Say ( Heike , DH-1-sci ) ;
7212: LD_EXP 21
7216: PPUSH
7217: LD_STRING DH-1-sci
7219: PPUSH
7220: CALL_OW 88
// end ;
7224: END
// every 0 0$1 trigger aviradzeSpotted and not sciSpotted and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and aviradzeSpotted and not aviradzeQuestDone do
7225: LD_EXP 4
7229: PUSH
7230: LD_EXP 6
7234: NOT
7235: AND
7236: PUSH
7237: LD_INT 2
7239: PPUSH
7240: LD_EXP 20
7244: PPUSH
7245: LD_EXP 21
7249: PPUSH
7250: CALL_OW 74
7254: PPUSH
7255: CALL_OW 292
7259: AND
7260: PUSH
7261: LD_INT 22
7263: PUSH
7264: LD_INT 2
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: PUSH
7271: LD_INT 21
7273: PUSH
7274: LD_INT 1
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: PUSH
7290: LD_INT 1
7292: GREATER
7293: AND
7294: PUSH
7295: LD_EXP 4
7299: AND
7300: PUSH
7301: LD_EXP 7
7305: NOT
7306: AND
7307: IFFALSE 7369
7309: GO 7311
7311: DISABLE
// begin sciSpotted := true ;
7312: LD_ADDR_EXP 6
7316: PUSH
7317: LD_INT 1
7319: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7320: LD_EXP 20
7324: PPUSH
7325: LD_EXP 21
7329: PPUSH
7330: CALL_OW 74
7334: PPUSH
7335: CALL_OW 87
// Say ( Heike , DH-1-sci-a ) ;
7339: LD_EXP 21
7343: PPUSH
7344: LD_STRING DH-1-sci-a
7346: PPUSH
7347: CALL_OW 88
// if Mike then
7351: LD_EXP 23
7355: IFFALSE 7369
// Say ( Mike , DM-1-sci-a ) ;
7357: LD_EXP 23
7361: PPUSH
7362: LD_STRING DM-1-sci-a
7364: PPUSH
7365: CALL_OW 88
// end ;
7369: END
// every 0 0$1 trigger aviradzeSpotted and ( sciCounterKill >= 3 or not usSci ) and not aviradzeQuestDone do
7370: LD_EXP 4
7374: PUSH
7375: LD_EXP 8
7379: PUSH
7380: LD_INT 3
7382: GREATEREQUAL
7383: PUSH
7384: LD_EXP 20
7388: NOT
7389: OR
7390: AND
7391: PUSH
7392: LD_EXP 7
7396: NOT
7397: AND
7398: IFFALSE 7441
7400: GO 7402
7402: DISABLE
// begin aviradzeQuestDone := true ;
7403: LD_ADDR_EXP 7
7407: PUSH
7408: LD_INT 1
7410: ST_TO_ADDR
// Say ( Heike , DH-1-quest-done ) ;
7411: LD_EXP 21
7415: PPUSH
7416: LD_STRING DH-1-quest-done
7418: PPUSH
7419: CALL_OW 88
// if Givi then
7423: LD_EXP 22
7427: IFFALSE 7441
// Say ( Givi , DG-1-quest-done ) ;
7429: LD_EXP 22
7433: PPUSH
7434: LD_STRING DG-1-quest-done
7436: PPUSH
7437: CALL_OW 88
// end ;
7441: END
// every 0 0$1 trigger See ( 5 , Heike ) and GetDistUnits ( Heike , Aviradze ) < 6 and aviradzeQuestDone and not attackDeltaAllowed do var i ;
7442: LD_INT 5
7444: PPUSH
7445: LD_EXP 21
7449: PPUSH
7450: CALL_OW 292
7454: PUSH
7455: LD_EXP 21
7459: PPUSH
7460: LD_EXP 25
7464: PPUSH
7465: CALL_OW 296
7469: PUSH
7470: LD_INT 6
7472: LESS
7473: AND
7474: PUSH
7475: LD_EXP 7
7479: AND
7480: PUSH
7481: LD_EXP 12
7485: NOT
7486: AND
7487: IFFALSE 7625
7489: GO 7491
7491: DISABLE
7492: LD_INT 0
7494: PPUSH
// begin attackDeltaAllowed := true ;
7495: LD_ADDR_EXP 12
7499: PUSH
7500: LD_INT 1
7502: ST_TO_ADDR
// InGameOn ;
7503: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
7507: LD_EXP 21
7511: PPUSH
7512: CALL_OW 87
// wait ( 0 0$0.3 ) ;
7516: LD_INT 10
7518: PPUSH
7519: CALL_OW 67
// ComTurnUnit ( Aviradze , Heike ) ;
7523: LD_EXP 25
7527: PPUSH
7528: LD_EXP 21
7532: PPUSH
7533: CALL_OW 119
// ComTurnUnit ( Heike , Aviradze ) ;
7537: LD_EXP 21
7541: PPUSH
7542: LD_EXP 25
7546: PPUSH
7547: CALL_OW 119
// Say ( Heike , DH-1-return ) ;
7551: LD_EXP 21
7555: PPUSH
7556: LD_STRING DH-1-return
7558: PPUSH
7559: CALL_OW 88
// Say ( Aviradze , DA-1-return ) ;
7563: LD_EXP 25
7567: PPUSH
7568: LD_STRING DA-1-return
7570: PPUSH
7571: CALL_OW 88
// InGameOff ;
7575: CALL_OW 9
// ChangeMissionObjectives ( ODelta ) ;
7579: LD_STRING ODelta
7581: PPUSH
7582: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7586: LD_ADDR_VAR 0 1
7590: PUSH
7591: LD_INT 22
7593: PUSH
7594: LD_INT 5
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: PPUSH
7601: CALL_OW 69
7605: PUSH
7606: FOR_IN
7607: IFFALSE 7623
// SetSide ( i , 2 ) ;
7609: LD_VAR 0 1
7613: PPUSH
7614: LD_INT 2
7616: PPUSH
7617: CALL_OW 235
7621: GO 7606
7623: POP
7624: POP
// end ;
7625: PPOPN 1
7627: END
// every 0 0$1 trigger attackDeltaAllowed and IsOk ( Markov ) and GetSide ( Delta ) = 1 and IsOk ( Lynch ) and not usAlert do var i , k , tmp ;
7628: LD_EXP 12
7632: PUSH
7633: LD_EXP 28
7637: PPUSH
7638: CALL_OW 302
7642: AND
7643: PUSH
7644: LD_INT 1
7646: PPUSH
7647: CALL_OW 255
7651: PUSH
7652: LD_INT 1
7654: EQUAL
7655: AND
7656: PUSH
7657: LD_EXP 18
7661: PPUSH
7662: CALL_OW 302
7666: AND
7667: PUSH
7668: LD_EXP 9
7672: NOT
7673: AND
7674: IFFALSE 8844
7676: GO 7678
7678: DISABLE
7679: LD_INT 0
7681: PPUSH
7682: PPUSH
7683: PPUSH
// begin trap := 0 ;
7684: LD_ADDR_EXP 15
7688: PUSH
7689: LD_INT 0
7691: ST_TO_ADDR
// wait ( 0 0$15 ) ;
7692: LD_INT 525
7694: PPUSH
7695: CALL_OW 67
// DialogueOn ;
7699: CALL_OW 6
// Say ( Markov , DMar-1-radio ) ;
7703: LD_EXP 28
7707: PPUSH
7708: LD_STRING DMar-1-radio
7710: PPUSH
7711: CALL_OW 88
// Say ( Heike , DH-1-radio ) ;
7715: LD_EXP 21
7719: PPUSH
7720: LD_STRING DH-1-radio
7722: PPUSH
7723: CALL_OW 88
// Say ( Markov , DMar-2-radio ) ;
7727: LD_EXP 28
7731: PPUSH
7732: LD_STRING DMar-2-radio
7734: PPUSH
7735: CALL_OW 88
// Say ( Heike , DH-2-radio ) ;
7739: LD_EXP 21
7743: PPUSH
7744: LD_STRING DH-2-radio
7746: PPUSH
7747: CALL_OW 88
// if IsOk ( Kamil ) or IsOk ( Sophia ) then
7751: LD_EXP 24
7755: PPUSH
7756: CALL_OW 302
7760: PUSH
7761: LD_EXP 27
7765: PPUSH
7766: CALL_OW 302
7770: OR
7771: IFFALSE 8844
// begin case Query ( Q1Trap ) of 1 :
7773: LD_STRING Q1Trap
7775: PPUSH
7776: CALL_OW 97
7780: PUSH
7781: LD_INT 1
7783: DOUBLE
7784: EQUAL
7785: IFTRUE 7789
7787: GO 7983
7789: POP
// begin if IsOk ( Kamil ) then
7790: LD_EXP 24
7794: PPUSH
7795: CALL_OW 302
7799: IFFALSE 7878
// begin Say ( Kamil , DKam-2-radio ) ;
7801: LD_EXP 24
7805: PPUSH
7806: LD_STRING DKam-2-radio
7808: PPUSH
7809: CALL_OW 88
// Say ( Kamil , DKam-3-radio ) ;
7813: LD_EXP 24
7817: PPUSH
7818: LD_STRING DKam-3-radio
7820: PPUSH
7821: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio ) ;
7825: LD_EXP 18
7829: PPUSH
7830: LD_STRING DDelta-3-radio
7832: PPUSH
7833: CALL_OW 94
// dwait ( 0 0$01 ) ;
7837: LD_INT 35
7839: PPUSH
7840: CALL_OW 68
// Say ( Heike , DH-3-radio ) ;
7844: LD_EXP 21
7848: PPUSH
7849: LD_STRING DH-3-radio
7851: PPUSH
7852: CALL_OW 88
// Say ( Kamil , DKam-4-radio ) ;
7856: LD_EXP 24
7860: PPUSH
7861: LD_STRING DKam-4-radio
7863: PPUSH
7864: CALL_OW 88
// trap := 1 ;
7868: LD_ADDR_EXP 15
7872: PUSH
7873: LD_INT 1
7875: ST_TO_ADDR
// end else
7876: GO 7977
// begin Say ( Sophia , DS-1-radio ) ;
7878: LD_EXP 27
7882: PPUSH
7883: LD_STRING DS-1-radio
7885: PPUSH
7886: CALL_OW 88
// Say ( Sophia , DS-2-radio ) ;
7890: LD_EXP 27
7894: PPUSH
7895: LD_STRING DS-2-radio
7897: PPUSH
7898: CALL_OW 88
// SayRadio ( Lynch , DDelta-2-radio-s ) ;
7902: LD_EXP 18
7906: PPUSH
7907: LD_STRING DDelta-2-radio-s
7909: PPUSH
7910: CALL_OW 94
// Say ( Sophia , DS-3-radio ) ;
7914: LD_EXP 27
7918: PPUSH
7919: LD_STRING DS-3-radio
7921: PPUSH
7922: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio-s ) ;
7926: LD_EXP 18
7930: PPUSH
7931: LD_STRING DDelta-3-radio-s
7933: PPUSH
7934: CALL_OW 94
// Say ( Sophia , DS-4-radio-s ) ;
7938: LD_EXP 27
7942: PPUSH
7943: LD_STRING DS-4-radio-s
7945: PPUSH
7946: CALL_OW 88
// dwait ( 0 0$01 ) ;
7950: LD_INT 35
7952: PPUSH
7953: CALL_OW 68
// Say ( Heike , DH-1-trap ) ;
7957: LD_EXP 21
7961: PPUSH
7962: LD_STRING DH-1-trap
7964: PPUSH
7965: CALL_OW 88
// trap := 0 ;
7969: LD_ADDR_EXP 15
7973: PUSH
7974: LD_INT 0
7976: ST_TO_ADDR
// end ; DialogueOff ;
7977: CALL_OW 7
// end ; 2 :
7981: GO 8001
7983: LD_INT 2
7985: DOUBLE
7986: EQUAL
7987: IFTRUE 7991
7989: GO 8000
7991: POP
// begin DialogueOff ;
7992: CALL_OW 7
// exit ;
7996: GO 8844
// end ; end ;
7998: GO 8001
8000: POP
// if trap = 1 then
8001: LD_EXP 15
8005: PUSH
8006: LD_INT 1
8008: EQUAL
8009: IFFALSE 8415
// begin tmp := [ ] ;
8011: LD_ADDR_VAR 0 3
8015: PUSH
8016: EMPTY
8017: ST_TO_ADDR
// k := 3 ;
8018: LD_ADDR_VAR 0 2
8022: PUSH
8023: LD_INT 3
8025: ST_TO_ADDR
// if usForces < 3 then
8026: LD_EXP 19
8030: PUSH
8031: LD_INT 3
8033: LESS
8034: IFFALSE 8046
// k := usForces ;
8036: LD_ADDR_VAR 0 2
8040: PUSH
8041: LD_EXP 19
8045: ST_TO_ADDR
// for i := 1 to k do
8046: LD_ADDR_VAR 0 1
8050: PUSH
8051: DOUBLE
8052: LD_INT 1
8054: DEC
8055: ST_TO_ADDR
8056: LD_VAR 0 2
8060: PUSH
8061: FOR_TO
8062: IFFALSE 8117
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8064: LD_ADDR_VAR 0 3
8068: PUSH
8069: LD_VAR 0 3
8073: PPUSH
8074: LD_VAR 0 3
8078: PUSH
8079: LD_INT 1
8081: PLUS
8082: PPUSH
8083: LD_EXP 19
8087: PUSH
8088: LD_INT 1
8090: ARRAY
8091: PPUSH
8092: CALL_OW 1
8096: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8097: LD_ADDR_EXP 19
8101: PUSH
8102: LD_EXP 19
8106: PPUSH
8107: LD_INT 1
8109: PPUSH
8110: CALL_OW 3
8114: ST_TO_ADDR
// end ;
8115: GO 8061
8117: POP
8118: POP
// usPatrol := tmp ;
8119: LD_ADDR_EXP 14
8123: PUSH
8124: LD_VAR 0 3
8128: ST_TO_ADDR
// for i in tmp do
8129: LD_ADDR_VAR 0 1
8133: PUSH
8134: LD_VAR 0 3
8138: PUSH
8139: FOR_IN
8140: IFFALSE 8270
// begin if IsInUnit ( i ) then
8142: LD_VAR 0 1
8146: PPUSH
8147: CALL_OW 310
8151: IFFALSE 8162
// ComExitBuilding ( i ) ;
8153: LD_VAR 0 1
8157: PPUSH
8158: CALL_OW 122
// AddComAgressiveMove ( i , 63 , 31 ) ;
8162: LD_VAR 0 1
8166: PPUSH
8167: LD_INT 63
8169: PPUSH
8170: LD_INT 31
8172: PPUSH
8173: CALL_OW 174
// AddComWait ( i , 0 0$2 ) ;
8177: LD_VAR 0 1
8181: PPUSH
8182: LD_INT 70
8184: PPUSH
8185: CALL_OW 202
// AddComAgressiveMove ( i , 103 , 43 ) ;
8189: LD_VAR 0 1
8193: PPUSH
8194: LD_INT 103
8196: PPUSH
8197: LD_INT 43
8199: PPUSH
8200: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8204: LD_VAR 0 1
8208: PPUSH
8209: LD_INT 105
8211: PPUSH
8212: CALL_OW 202
// if Difficulty > 1 then
8216: LD_OWVAR 67
8220: PUSH
8221: LD_INT 1
8223: GREATER
8224: IFFALSE 8241
// AddComAgressiveMove ( i , 114 , 69 ) ;
8226: LD_VAR 0 1
8230: PPUSH
8231: LD_INT 114
8233: PPUSH
8234: LD_INT 69
8236: PPUSH
8237: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8241: LD_VAR 0 1
8245: PPUSH
8246: LD_INT 105
8248: PPUSH
8249: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8253: LD_VAR 0 1
8257: PPUSH
8258: LD_INT 42
8260: PPUSH
8261: LD_INT 20
8263: PPUSH
8264: CALL_OW 174
// end ;
8268: GO 8139
8270: POP
8271: POP
// repeat wait ( 0 0$1 ) ;
8272: LD_INT 35
8274: PPUSH
8275: CALL_OW 67
// for i in tmp do
8279: LD_ADDR_VAR 0 1
8283: PUSH
8284: LD_VAR 0 3
8288: PUSH
8289: FOR_IN
8290: IFFALSE 8321
// if IsDead ( i ) then
8292: LD_VAR 0 1
8296: PPUSH
8297: CALL_OW 301
8301: IFFALSE 8319
// tmp := tmp diff i ;
8303: LD_ADDR_VAR 0 3
8307: PUSH
8308: LD_VAR 0 3
8312: PUSH
8313: LD_VAR 0 1
8317: DIFF
8318: ST_TO_ADDR
8319: GO 8289
8321: POP
8322: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8323: LD_VAR 0 3
8327: NOT
8328: PUSH
8329: LD_VAR 0 3
8333: PPUSH
8334: LD_INT 95
8336: PUSH
8337: LD_INT 7
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: PUSH
8344: LD_INT 3
8346: PUSH
8347: LD_INT 60
8349: PUSH
8350: EMPTY
8351: LIST
8352: PUSH
8353: EMPTY
8354: LIST
8355: LIST
8356: PUSH
8357: EMPTY
8358: LIST
8359: LIST
8360: PPUSH
8361: CALL_OW 72
8365: PUSH
8366: LD_VAR 0 3
8370: EQUAL
8371: OR
8372: IFFALSE 8272
// if tmp then
8374: LD_VAR 0 3
8378: IFFALSE 8405
// begin usPatrol := [ ] ;
8380: LD_ADDR_EXP 14
8384: PUSH
8385: EMPTY
8386: ST_TO_ADDR
// usForces := usForces union tmp ;
8387: LD_ADDR_EXP 19
8391: PUSH
8392: LD_EXP 19
8396: PUSH
8397: LD_VAR 0 3
8401: UNION
8402: ST_TO_ADDR
// end else
8403: GO 8413
// trickyMove := true ;
8405: LD_ADDR_EXP 13
8409: PUSH
8410: LD_INT 1
8412: ST_TO_ADDR
// end else
8413: GO 8844
// begin tmp := [ ] ;
8415: LD_ADDR_VAR 0 3
8419: PUSH
8420: EMPTY
8421: ST_TO_ADDR
// k := 4 ;
8422: LD_ADDR_VAR 0 2
8426: PUSH
8427: LD_INT 4
8429: ST_TO_ADDR
// if usForces < 4 then
8430: LD_EXP 19
8434: PUSH
8435: LD_INT 4
8437: LESS
8438: IFFALSE 8450
// k := usForces ;
8440: LD_ADDR_VAR 0 2
8444: PUSH
8445: LD_EXP 19
8449: ST_TO_ADDR
// for i := 1 to k do
8450: LD_ADDR_VAR 0 1
8454: PUSH
8455: DOUBLE
8456: LD_INT 1
8458: DEC
8459: ST_TO_ADDR
8460: LD_VAR 0 2
8464: PUSH
8465: FOR_TO
8466: IFFALSE 8521
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8468: LD_ADDR_VAR 0 3
8472: PUSH
8473: LD_VAR 0 3
8477: PPUSH
8478: LD_VAR 0 3
8482: PUSH
8483: LD_INT 1
8485: PLUS
8486: PPUSH
8487: LD_EXP 19
8491: PUSH
8492: LD_INT 1
8494: ARRAY
8495: PPUSH
8496: CALL_OW 1
8500: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8501: LD_ADDR_EXP 19
8505: PUSH
8506: LD_EXP 19
8510: PPUSH
8511: LD_INT 1
8513: PPUSH
8514: CALL_OW 3
8518: ST_TO_ADDR
// end ;
8519: GO 8465
8521: POP
8522: POP
// if Lynch then
8523: LD_EXP 18
8527: IFFALSE 8545
// tmp := tmp ^ Lynch ;
8529: LD_ADDR_VAR 0 3
8533: PUSH
8534: LD_VAR 0 3
8538: PUSH
8539: LD_EXP 18
8543: ADD
8544: ST_TO_ADDR
// usPatrol := tmp ;
8545: LD_ADDR_EXP 14
8549: PUSH
8550: LD_VAR 0 3
8554: ST_TO_ADDR
// for i in tmp do
8555: LD_ADDR_VAR 0 1
8559: PUSH
8560: LD_VAR 0 3
8564: PUSH
8565: FOR_IN
8566: IFFALSE 8659
// begin if IsInUnit ( i ) then
8568: LD_VAR 0 1
8572: PPUSH
8573: CALL_OW 310
8577: IFFALSE 8588
// ComExitBuilding ( i ) ;
8579: LD_VAR 0 1
8583: PPUSH
8584: CALL_OW 122
// AddComAgressiveMove ( i , 69 , 15 ) ;
8588: LD_VAR 0 1
8592: PPUSH
8593: LD_INT 69
8595: PPUSH
8596: LD_INT 15
8598: PPUSH
8599: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8603: LD_VAR 0 1
8607: PPUSH
8608: LD_INT 700
8610: PPUSH
8611: CALL_OW 202
// AddComAgressiveMove ( i , 55 , 43 ) ;
8615: LD_VAR 0 1
8619: PPUSH
8620: LD_INT 55
8622: PPUSH
8623: LD_INT 43
8625: PPUSH
8626: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8630: LD_VAR 0 1
8634: PPUSH
8635: LD_INT 700
8637: PPUSH
8638: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8642: LD_VAR 0 1
8646: PPUSH
8647: LD_INT 42
8649: PPUSH
8650: LD_INT 20
8652: PPUSH
8653: CALL_OW 174
// end ;
8657: GO 8565
8659: POP
8660: POP
// repeat wait ( 0 0$1 ) ;
8661: LD_INT 35
8663: PPUSH
8664: CALL_OW 67
// for i in tmp do
8668: LD_ADDR_VAR 0 1
8672: PUSH
8673: LD_VAR 0 3
8677: PUSH
8678: FOR_IN
8679: IFFALSE 8710
// if IsDead ( i ) then
8681: LD_VAR 0 1
8685: PPUSH
8686: CALL_OW 301
8690: IFFALSE 8708
// tmp := tmp diff i ;
8692: LD_ADDR_VAR 0 3
8696: PUSH
8697: LD_VAR 0 3
8701: PUSH
8702: LD_VAR 0 1
8706: DIFF
8707: ST_TO_ADDR
8708: GO 8678
8710: POP
8711: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8712: LD_VAR 0 3
8716: NOT
8717: PUSH
8718: LD_VAR 0 3
8722: PPUSH
8723: LD_INT 95
8725: PUSH
8726: LD_INT 7
8728: PUSH
8729: EMPTY
8730: LIST
8731: LIST
8732: PUSH
8733: LD_INT 3
8735: PUSH
8736: LD_INT 60
8738: PUSH
8739: EMPTY
8740: LIST
8741: PUSH
8742: EMPTY
8743: LIST
8744: LIST
8745: PUSH
8746: EMPTY
8747: LIST
8748: LIST
8749: PPUSH
8750: CALL_OW 72
8754: PUSH
8755: LD_VAR 0 3
8759: EQUAL
8760: OR
8761: IFFALSE 8661
// if not tmp then
8763: LD_VAR 0 3
8767: NOT
8768: IFFALSE 8780
// trickyMove := true else
8770: LD_ADDR_EXP 13
8774: PUSH
8775: LD_INT 1
8777: ST_TO_ADDR
8778: GO 8787
// usPatrol := [ ] ;
8780: LD_ADDR_EXP 14
8784: PUSH
8785: EMPTY
8786: ST_TO_ADDR
// if tmp diff Lynch then
8787: LD_VAR 0 3
8791: PUSH
8792: LD_EXP 18
8796: DIFF
8797: IFFALSE 8821
// usForces := usForces union ( tmp diff Lynch ) ;
8799: LD_ADDR_EXP 19
8803: PUSH
8804: LD_EXP 19
8808: PUSH
8809: LD_VAR 0 3
8813: PUSH
8814: LD_EXP 18
8818: DIFF
8819: UNION
8820: ST_TO_ADDR
// if IsOk ( Lynch ) then
8821: LD_EXP 18
8825: PPUSH
8826: CALL_OW 302
8830: IFFALSE 8844
// ComEnterUnit ( Lynch , Delta ) ;
8832: LD_EXP 18
8836: PPUSH
8837: LD_INT 1
8839: PPUSH
8840: CALL_OW 120
// end ; end ; end ;
8844: PPOPN 3
8846: END
// every 0 0$1 trigger trickyMove do
8847: LD_EXP 13
8851: IFFALSE 8863
8853: GO 8855
8855: DISABLE
// SetAchievement ( ACH_TRAP ) ;
8856: LD_STRING ACH_TRAP
8858: PPUSH
8859: CALL_OW 543
8863: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ) do
8864: LD_INT 22
8866: PUSH
8867: LD_INT 2
8869: PUSH
8870: EMPTY
8871: LIST
8872: LIST
8873: PUSH
8874: LD_INT 23
8876: PUSH
8877: LD_INT 1
8879: PUSH
8880: EMPTY
8881: LIST
8882: LIST
8883: PUSH
8884: LD_INT 21
8886: PUSH
8887: LD_INT 2
8889: PUSH
8890: EMPTY
8891: LIST
8892: LIST
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: LIST
8898: PPUSH
8899: CALL_OW 69
8903: IFFALSE 8915
8905: GO 8907
8907: DISABLE
// SetAchievement ( ACH_SCRAP ) ;
8908: LD_STRING ACH_SCRAP
8910: PPUSH
8911: CALL_OW 543
8915: END
// every 0 0$1 trigger UnitFilter ( usPatrol , [ f_see , 2 ] ) do
8916: LD_EXP 14
8920: PPUSH
8921: LD_INT 101
8923: PUSH
8924: LD_INT 2
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: PPUSH
8931: CALL_OW 72
8935: IFFALSE 9068
8937: GO 8939
8939: DISABLE
// begin if not trap then
8940: LD_EXP 15
8944: NOT
8945: IFFALSE 8973
// begin Say ( Heike , DH-2-trap ) ;
8947: LD_EXP 21
8951: PPUSH
8952: LD_STRING DH-2-trap
8954: PPUSH
8955: CALL_OW 88
// Say ( Mike , DM-2-trap ) ;
8959: LD_EXP 23
8963: PPUSH
8964: LD_STRING DM-2-trap
8966: PPUSH
8967: CALL_OW 88
// end else
8971: GO 8985
// begin Say ( Heike , DH-1-trap-a ) ;
8973: LD_EXP 21
8977: PPUSH
8978: LD_STRING DH-1-trap-a
8980: PPUSH
8981: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
8985: LD_INT 35
8987: PPUSH
8988: CALL_OW 67
// until trickyMove ;
8992: LD_EXP 13
8996: IFFALSE 8985
// Say ( Heike , DH-3-trap ) ;
8998: LD_EXP 21
9002: PPUSH
9003: LD_STRING DH-3-trap
9005: PPUSH
9006: CALL_OW 88
// if IsOk ( Givi ) and IsOk ( Kaia ) then
9010: LD_EXP 22
9014: PPUSH
9015: CALL_OW 302
9019: PUSH
9020: LD_EXP 26
9024: PPUSH
9025: CALL_OW 302
9029: AND
9030: IFFALSE 9068
// begin Say ( Givi , DG-3-trap ) ;
9032: LD_EXP 22
9036: PPUSH
9037: LD_STRING DG-3-trap
9039: PPUSH
9040: CALL_OW 88
// Say ( Kaia , DK-3-trap ) ;
9044: LD_EXP 26
9048: PPUSH
9049: LD_STRING DK-3-trap
9051: PPUSH
9052: CALL_OW 88
// Say ( Givi , DG-4-trap ) ;
9056: LD_EXP 22
9060: PPUSH
9061: LD_STRING DG-4-trap
9063: PPUSH
9064: CALL_OW 88
// end ; end ;
9068: END
// every 0 0$1 trigger GetSide ( Delta ) = 2 and attackDeltaAllowed do
9069: LD_INT 1
9071: PPUSH
9072: CALL_OW 255
9076: PUSH
9077: LD_INT 2
9079: EQUAL
9080: PUSH
9081: LD_EXP 12
9085: AND
9086: IFFALSE 9146
9088: GO 9090
9090: DISABLE
// begin if not IsOk ( Kaia ) then
9091: LD_EXP 26
9095: PPUSH
9096: CALL_OW 302
9100: NOT
9101: IFFALSE 9105
// exit ;
9103: GO 9146
// if tick < 5 5$00 then
9105: LD_OWVAR 1
9109: PUSH
9110: LD_INT 10500
9112: LESS
9113: IFFALSE 9122
// SetAchievement ( ACH_DELTA ) ;
9115: LD_STRING ACH_DELTA
9117: PPUSH
9118: CALL_OW 543
// Say ( Kaia , DK-1-capture ) ;
9122: LD_EXP 26
9126: PPUSH
9127: LD_STRING DK-1-capture
9129: PPUSH
9130: CALL_OW 88
// Say ( Heike , DH-1-capture ) ;
9134: LD_EXP 21
9138: PPUSH
9139: LD_STRING DH-1-capture
9141: PPUSH
9142: CALL_OW 88
// end ;
9146: END
// every 0 0$1 trigger GetSide ( usLab ) = 2 and attackDeltaAllowed do
9147: LD_INT 3
9149: PPUSH
9150: CALL_OW 255
9154: PUSH
9155: LD_INT 2
9157: EQUAL
9158: PUSH
9159: LD_EXP 12
9163: AND
9164: IFFALSE 9196
9166: GO 9168
9168: DISABLE
// begin DialogueOn ;
9169: CALL_OW 6
// Say ( Aviradze , DA-1-capture ) ;
9173: LD_EXP 25
9177: PPUSH
9178: LD_STRING DA-1-capture
9180: PPUSH
9181: CALL_OW 88
// DialogueOff ;
9185: CALL_OW 7
// ChangeMissionObjectives ( OTame ) ;
9189: LD_STRING OTame
9191: PPUSH
9192: CALL_OW 337
// end ;
9196: END
// every 0 0$1 trigger GetTech ( tech_ApeLang , 2 ) = state_researched and attackDeltaAllowed do
9197: LD_INT 1
9199: PPUSH
9200: LD_INT 2
9202: PPUSH
9203: CALL_OW 321
9207: PUSH
9208: LD_INT 2
9210: EQUAL
9211: PUSH
9212: LD_EXP 12
9216: AND
9217: IFFALSE 9290
9219: GO 9221
9221: DISABLE
// begin DialogueOn ;
9222: CALL_OW 6
// Say ( Aviradze , DA-1-ape ) ;
9226: LD_EXP 25
9230: PPUSH
9231: LD_STRING DA-1-ape
9233: PPUSH
9234: CALL_OW 88
// Say ( Heike , DH-1-ape ) ;
9238: LD_EXP 21
9242: PPUSH
9243: LD_STRING DH-1-ape
9245: PPUSH
9246: CALL_OW 88
// Say ( Aviradze , DA-2-ape ) ;
9250: LD_EXP 25
9254: PPUSH
9255: LD_STRING DA-2-ape
9257: PPUSH
9258: CALL_OW 88
// Say ( Aviradze , DA-3-ape ) ;
9262: LD_EXP 25
9266: PPUSH
9267: LD_STRING DA-3-ape
9269: PPUSH
9270: CALL_OW 88
// Say ( Heike , DH-3-ape ) ;
9274: LD_EXP 21
9278: PPUSH
9279: LD_STRING DH-3-ape
9281: PPUSH
9282: CALL_OW 88
// DialogueOff ;
9286: CALL_OW 7
// end ;
9290: END
// every 0 0$5 trigger lostCounter >= [ 3 , 2 , 2 ] [ Difficulty ] do
9291: LD_EXP 16
9295: PUSH
9296: LD_INT 3
9298: PUSH
9299: LD_INT 2
9301: PUSH
9302: LD_INT 2
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: LIST
9309: PUSH
9310: LD_OWVAR 67
9314: ARRAY
9315: GREATEREQUAL
9316: IFFALSE 9360
9318: GO 9320
9320: DISABLE
// begin DialogueOn ;
9321: CALL_OW 6
// Say ( Aviradze , DA-1-failure ) ;
9325: LD_EXP 25
9329: PPUSH
9330: LD_STRING DA-1-failure
9332: PPUSH
9333: CALL_OW 88
// Say ( Aviradze , DA-2-failure ) ;
9337: LD_EXP 25
9341: PPUSH
9342: LD_STRING DA-2-failure
9344: PPUSH
9345: CALL_OW 88
// YouLost ( Failure ) ;
9349: LD_STRING Failure
9351: PPUSH
9352: CALL_OW 104
// DialogueOff ;
9356: CALL_OW 7
// end ;
9360: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) and IsOk ( Aviradze ) and GetSide ( Aviradze ) = 2 do var tmp ;
9361: LD_INT 22
9363: PUSH
9364: LD_INT 2
9366: PUSH
9367: EMPTY
9368: LIST
9369: LIST
9370: PUSH
9371: LD_INT 23
9373: PUSH
9374: LD_INT 0
9376: PUSH
9377: EMPTY
9378: LIST
9379: LIST
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: PPUSH
9385: CALL_OW 69
9389: PUSH
9390: LD_EXP 25
9394: PPUSH
9395: CALL_OW 302
9399: AND
9400: PUSH
9401: LD_EXP 25
9405: PPUSH
9406: CALL_OW 255
9410: PUSH
9411: LD_INT 2
9413: EQUAL
9414: AND
9415: IFFALSE 10165
9417: GO 9419
9419: DISABLE
9420: LD_INT 0
9422: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) [ 1 ] ;
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: LD_INT 22
9430: PUSH
9431: LD_INT 2
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: PUSH
9438: LD_INT 23
9440: PUSH
9441: LD_INT 0
9443: PUSH
9444: EMPTY
9445: LIST
9446: LIST
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PPUSH
9452: CALL_OW 69
9456: PUSH
9457: LD_INT 1
9459: ARRAY
9460: ST_TO_ADDR
// InGameOn ;
9461: CALL_OW 8
// CenterNowOnUnits ( tmp ) ;
9465: LD_VAR 0 1
9469: PPUSH
9470: CALL_OW 87
// ComMoveUnit ( tmp , Aviradze ) ;
9474: LD_VAR 0 1
9478: PPUSH
9479: LD_EXP 25
9483: PPUSH
9484: CALL_OW 112
// ComTurnUnit ( Aviradze , tmp ) ;
9488: LD_EXP 25
9492: PPUSH
9493: LD_VAR 0 1
9497: PPUSH
9498: CALL_OW 119
// wait ( 0 0$1 ) ;
9502: LD_INT 35
9504: PPUSH
9505: CALL_OW 67
// Say ( Aviradze , DA-1-tame-a ) ;
9509: LD_EXP 25
9513: PPUSH
9514: LD_STRING DA-1-tame-a
9516: PPUSH
9517: CALL_OW 88
// if IsOk ( Mike ) then
9521: LD_EXP 23
9525: PPUSH
9526: CALL_OW 302
9530: IFFALSE 9568
// begin Say ( Mike , DM-1-tame-a ) ;
9532: LD_EXP 23
9536: PPUSH
9537: LD_STRING DM-1-tame-a
9539: PPUSH
9540: CALL_OW 88
// Say ( Sophia , DS-1-tame-a ) ;
9544: LD_EXP 27
9548: PPUSH
9549: LD_STRING DS-1-tame-a
9551: PPUSH
9552: CALL_OW 88
// Say ( Mike , DM-2-tame-a ) ;
9556: LD_EXP 23
9560: PPUSH
9561: LD_STRING DM-2-tame-a
9563: PPUSH
9564: CALL_OW 88
// end ; wait ( 0 0$3 ) ;
9568: LD_INT 105
9570: PPUSH
9571: CALL_OW 67
// PrepareFarmer ;
9575: CALL 10824 0 0
// CenterOnUnits ( Farmer ) ;
9579: LD_EXP 29
9583: PPUSH
9584: CALL_OW 85
// ComMoveXY ( Farmer , 105 , 59 ) ;
9588: LD_EXP 29
9592: PPUSH
9593: LD_INT 105
9595: PPUSH
9596: LD_INT 59
9598: PPUSH
9599: CALL_OW 111
// AddComHold ( Farmer ) ;
9603: LD_EXP 29
9607: PPUSH
9608: CALL_OW 200
// SayRadio ( Farmer , DF-1-end ) ;
9612: LD_EXP 29
9616: PPUSH
9617: LD_STRING DF-1-end
9619: PPUSH
9620: CALL_OW 94
// Say ( Aviradze , DA-1-end ) ;
9624: LD_EXP 25
9628: PPUSH
9629: LD_STRING DA-1-end
9631: PPUSH
9632: CALL_OW 88
// SayRadio ( Farmer , DF-2-end ) ;
9636: LD_EXP 29
9640: PPUSH
9641: LD_STRING DF-2-end
9643: PPUSH
9644: CALL_OW 94
// Say ( Aviradze , DA-2-end ) ;
9648: LD_EXP 25
9652: PPUSH
9653: LD_STRING DA-2-end
9655: PPUSH
9656: CALL_OW 88
// SayRadio ( Farmer , DF-3-end ) ;
9660: LD_EXP 29
9664: PPUSH
9665: LD_STRING DF-3-end
9667: PPUSH
9668: CALL_OW 94
// Say ( Heike , DH-3-end ) ;
9672: LD_EXP 21
9676: PPUSH
9677: LD_STRING DH-3-end
9679: PPUSH
9680: CALL_OW 88
// SayRadio ( Farmer , DF-4-end ) ;
9684: LD_EXP 29
9688: PPUSH
9689: LD_STRING DF-4-end
9691: PPUSH
9692: CALL_OW 94
// if tick <= [ 20 20$00 , 15 15$00 , 12 12$00 ] [ Difficulty ] then
9696: LD_OWVAR 1
9700: PUSH
9701: LD_INT 42000
9703: PUSH
9704: LD_INT 31500
9706: PUSH
9707: LD_INT 25200
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: LIST
9714: PUSH
9715: LD_OWVAR 67
9719: ARRAY
9720: LESSEQUAL
9721: IFFALSE 9735
// AddMedal ( med1 , 1 ) else
9723: LD_STRING med1
9725: PPUSH
9726: LD_INT 1
9728: PPUSH
9729: CALL_OW 101
9733: GO 9746
// AddMedal ( med1 , - 1 ) ;
9735: LD_STRING med1
9737: PPUSH
9738: LD_INT 1
9740: NEG
9741: PPUSH
9742: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) = 0 then
9746: LD_INT 22
9748: PUSH
9749: LD_INT 1
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: PUSH
9756: LD_INT 25
9758: PUSH
9759: LD_INT 4
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: PPUSH
9770: CALL_OW 69
9774: PUSH
9775: LD_INT 0
9777: EQUAL
9778: IFFALSE 9792
// AddMedal ( med2 , 1 ) else
9780: LD_STRING med2
9782: PPUSH
9783: LD_INT 1
9785: PPUSH
9786: CALL_OW 101
9790: GO 9803
// AddMedal ( med2 , - 1 ) ;
9792: LD_STRING med2
9794: PPUSH
9795: LD_INT 1
9797: NEG
9798: PPUSH
9799: CALL_OW 101
// if trickyMove then
9803: LD_EXP 13
9807: IFFALSE 9821
// AddMedal ( med3 , 1 ) else
9809: LD_STRING med3
9811: PPUSH
9812: LD_INT 1
9814: PPUSH
9815: CALL_OW 101
9819: GO 9832
// AddMedal ( med3 , - 1 ) ;
9821: LD_STRING med3
9823: PPUSH
9824: LD_INT 1
9826: NEG
9827: PPUSH
9828: CALL_OW 101
// GiveMedals ( MAIN ) ;
9832: LD_STRING MAIN
9834: PPUSH
9835: CALL_OW 102
// SaveCharacters ( tmp , 02_ape ) ;
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_STRING 02_ape
9846: PPUSH
9847: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ;
9851: LD_ADDR_VAR 0 1
9855: PUSH
9856: LD_INT 22
9858: PUSH
9859: LD_INT 2
9861: PUSH
9862: EMPTY
9863: LIST
9864: LIST
9865: PUSH
9866: LD_INT 23
9868: PUSH
9869: LD_INT 2
9871: PUSH
9872: EMPTY
9873: LIST
9874: LIST
9875: PUSH
9876: LD_INT 21
9878: PUSH
9879: LD_INT 1
9881: PUSH
9882: EMPTY
9883: LIST
9884: LIST
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: LIST
9890: PPUSH
9891: CALL_OW 69
9895: ST_TO_ADDR
// RewardPeople ( tmp ) ;
9896: LD_VAR 0 1
9900: PPUSH
9901: CALL_OW 43
// SaveCharacters ( Heike , 02_Heike ) ;
9905: LD_EXP 21
9909: PPUSH
9910: LD_STRING 02_Heike
9912: PPUSH
9913: CALL_OW 38
// SaveCharacters ( Aviradze , 02_Aviradze ) ;
9917: LD_EXP 25
9921: PPUSH
9922: LD_STRING 02_Aviradze
9924: PPUSH
9925: CALL_OW 38
// if Givi then
9929: LD_EXP 22
9933: IFFALSE 9947
// SaveCharacters ( Givi , 02_Givi ) ;
9935: LD_EXP 22
9939: PPUSH
9940: LD_STRING 02_Givi
9942: PPUSH
9943: CALL_OW 38
// if Mike then
9947: LD_EXP 23
9951: IFFALSE 9965
// SaveCharacters ( Mike , 02_Mike ) ;
9953: LD_EXP 23
9957: PPUSH
9958: LD_STRING 02_Mike
9960: PPUSH
9961: CALL_OW 38
// if Kamil then
9965: LD_EXP 24
9969: IFFALSE 9983
// SaveCharacters ( Kamil , 02_Kamil ) ;
9971: LD_EXP 24
9975: PPUSH
9976: LD_STRING 02_Kamil
9978: PPUSH
9979: CALL_OW 38
// if Kaia then
9983: LD_EXP 26
9987: IFFALSE 10001
// SaveCharacters ( Kaia , 02_Kaia ) ;
9989: LD_EXP 26
9993: PPUSH
9994: LD_STRING 02_Kaia
9996: PPUSH
9997: CALL_OW 38
// if Sophia then
10001: LD_EXP 27
10005: IFFALSE 10019
// SaveCharacters ( Sophia , 02_Sophia ) ;
10007: LD_EXP 27
10011: PPUSH
10012: LD_STRING 02_Sophia
10014: PPUSH
10015: CALL_OW 38
// if Markov then
10019: LD_EXP 28
10023: IFFALSE 10037
// SaveCharacters ( Markov , 02_Markov ) ;
10025: LD_EXP 28
10029: PPUSH
10030: LD_STRING 02_Markov
10032: PPUSH
10033: CALL_OW 38
// if tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] then
10037: LD_VAR 0 1
10041: PUSH
10042: LD_EXP 21
10046: PUSH
10047: LD_EXP 25
10051: PUSH
10052: LD_EXP 22
10056: PUSH
10057: LD_EXP 23
10061: PUSH
10062: LD_EXP 24
10066: PUSH
10067: LD_EXP 27
10071: PUSH
10072: LD_EXP 26
10076: PUSH
10077: LD_EXP 28
10081: PUSH
10082: EMPTY
10083: LIST
10084: LIST
10085: LIST
10086: LIST
10087: LIST
10088: LIST
10089: LIST
10090: LIST
10091: DIFF
10092: IFFALSE 10157
// SaveCharacters ( tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] , 02_others ) ;
10094: LD_VAR 0 1
10098: PUSH
10099: LD_EXP 21
10103: PUSH
10104: LD_EXP 25
10108: PUSH
10109: LD_EXP 22
10113: PUSH
10114: LD_EXP 23
10118: PUSH
10119: LD_EXP 24
10123: PUSH
10124: LD_EXP 27
10128: PUSH
10129: LD_EXP 26
10133: PUSH
10134: LD_EXP 28
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: LIST
10143: LIST
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: DIFF
10149: PPUSH
10150: LD_STRING 02_others
10152: PPUSH
10153: CALL_OW 38
// YouWin ;
10157: CALL_OW 103
// InGameOff ;
10161: CALL_OW 9
// end ;
10165: PPOPN 1
10167: END
// every 0 0$1 trigger tick > timeUntilFarmer and aviradzeSpotted do
10168: LD_OWVAR 1
10172: PUSH
10173: LD_EXP 11
10177: GREATER
10178: PUSH
10179: LD_EXP 4
10183: AND
10184: IFFALSE 10224
10186: GO 10188
10188: DISABLE
// begin InGameOn ;
10189: CALL_OW 8
// PrepareFarmer ;
10193: CALL 10824 0 0
// CenterNowOnUnits ( Farmer ) ;
10197: LD_EXP 29
10201: PPUSH
10202: CALL_OW 87
// wait ( 0 0$2 ) ;
10206: LD_INT 70
10208: PPUSH
10209: CALL_OW 67
// YouLost ( Farmer ) ;
10213: LD_STRING Farmer
10215: PPUSH
10216: CALL_OW 104
// InGameOff ;
10220: CALL_OW 9
// end ; end_of_file
10224: END
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer ; export function PrepareArabian ; var un , veh ; begin
10225: LD_INT 0
10227: PPUSH
10228: PPUSH
10229: PPUSH
// uc_side := 2 ;
10230: LD_ADDR_OWVAR 20
10234: PUSH
10235: LD_INT 2
10237: ST_TO_ADDR
// uc_nation := 2 ;
10238: LD_ADDR_OWVAR 21
10242: PUSH
10243: LD_INT 2
10245: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
10246: LD_ADDR_EXP 21
10250: PUSH
10251: LD_STRING Heike
10253: PPUSH
10254: LD_EXP 1
10258: NOT
10259: PPUSH
10260: LD_EXP 2
10264: PPUSH
10265: CALL 221 0 3
10269: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
10270: LD_EXP 21
10274: PPUSH
10275: LD_INT 83
10277: PPUSH
10278: LD_INT 72
10280: PPUSH
10281: LD_INT 0
10283: PPUSH
10284: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
10288: LD_ADDR_EXP 22
10292: PUSH
10293: LD_STRING Givi
10295: PPUSH
10296: LD_EXP 1
10300: NOT
10301: PPUSH
10302: LD_EXP 2
10306: PPUSH
10307: CALL 221 0 3
10311: ST_TO_ADDR
// if Givi then
10312: LD_EXP 22
10316: IFFALSE 10336
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
10318: LD_EXP 22
10322: PPUSH
10323: LD_INT 87
10325: PPUSH
10326: LD_INT 76
10328: PPUSH
10329: LD_INT 0
10331: PPUSH
10332: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
10336: LD_ADDR_EXP 23
10340: PUSH
10341: LD_STRING Mike
10343: PPUSH
10344: LD_EXP 1
10348: NOT
10349: PPUSH
10350: LD_EXP 2
10354: PPUSH
10355: CALL 221 0 3
10359: ST_TO_ADDR
// if Mike then
10360: LD_EXP 23
10364: IFFALSE 10384
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
10366: LD_EXP 23
10370: PPUSH
10371: LD_INT 84
10373: PPUSH
10374: LD_INT 76
10376: PPUSH
10377: LD_INT 0
10379: PPUSH
10380: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
10384: LD_ADDR_EXP 24
10388: PUSH
10389: LD_STRING Kamil
10391: PPUSH
10392: LD_EXP 1
10396: NOT
10397: PPUSH
10398: LD_EXP 2
10402: PPUSH
10403: CALL 221 0 3
10407: ST_TO_ADDR
// if Kamil then
10408: LD_EXP 24
10412: IFFALSE 10432
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
10414: LD_EXP 24
10418: PPUSH
10419: LD_INT 85
10421: PPUSH
10422: LD_INT 78
10424: PPUSH
10425: LD_INT 0
10427: PPUSH
10428: CALL_OW 48
// uc_side := 5 ;
10432: LD_ADDR_OWVAR 20
10436: PUSH
10437: LD_INT 5
10439: ST_TO_ADDR
// uc_nation := 2 ;
10440: LD_ADDR_OWVAR 21
10444: PUSH
10445: LD_INT 2
10447: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , false ,  ) ;
10448: LD_ADDR_EXP 25
10452: PUSH
10453: LD_STRING Aviradze
10455: PPUSH
10456: LD_INT 0
10458: PPUSH
10459: LD_STRING 
10461: PPUSH
10462: CALL 221 0 3
10466: ST_TO_ADDR
// PlaceUnitXY ( Aviradze , 106 , 38 , false ) ;
10467: LD_EXP 25
10471: PPUSH
10472: LD_INT 106
10474: PPUSH
10475: LD_INT 38
10477: PPUSH
10478: LD_INT 0
10480: PPUSH
10481: CALL_OW 48
// ComTurnXY ( Aviradze , 103 , 38 ) ;
10485: LD_EXP 25
10489: PPUSH
10490: LD_INT 103
10492: PPUSH
10493: LD_INT 38
10495: PPUSH
10496: CALL_OW 118
// Kaia := PrepareUnit ( Kaia , false ,  ) ;
10500: LD_ADDR_EXP 26
10504: PUSH
10505: LD_STRING Kaia
10507: PPUSH
10508: LD_INT 0
10510: PPUSH
10511: LD_STRING 
10513: PPUSH
10514: CALL 221 0 3
10518: ST_TO_ADDR
// PlaceUnitXY ( Kaia , 100 , 34 , false ) ;
10519: LD_EXP 26
10523: PPUSH
10524: LD_INT 100
10526: PPUSH
10527: LD_INT 34
10529: PPUSH
10530: LD_INT 0
10532: PPUSH
10533: CALL_OW 48
// ComTurnXY ( Kaia , 100 , 39 ) ;
10537: LD_EXP 26
10541: PPUSH
10542: LD_INT 100
10544: PPUSH
10545: LD_INT 39
10547: PPUSH
10548: CALL_OW 118
// Sophia := PrepareUnit ( Sophia , false ,  ) ;
10552: LD_ADDR_EXP 27
10556: PUSH
10557: LD_STRING Sophia
10559: PPUSH
10560: LD_INT 0
10562: PPUSH
10563: LD_STRING 
10565: PPUSH
10566: CALL 221 0 3
10570: ST_TO_ADDR
// PlaceUnitXY ( Sophia , 109 , 50 , false ) ;
10571: LD_EXP 27
10575: PPUSH
10576: LD_INT 109
10578: PPUSH
10579: LD_INT 50
10581: PPUSH
10582: LD_INT 0
10584: PPUSH
10585: CALL_OW 48
// ComTurnXY ( Sophia , 100 , 39 ) ;
10589: LD_EXP 27
10593: PPUSH
10594: LD_INT 100
10596: PPUSH
10597: LD_INT 39
10599: PPUSH
10600: CALL_OW 118
// Markov := PrepareUnit ( Markov , false ,  ) ;
10604: LD_ADDR_EXP 28
10608: PUSH
10609: LD_STRING Markov
10611: PPUSH
10612: LD_INT 0
10614: PPUSH
10615: LD_STRING 
10617: PPUSH
10618: CALL 221 0 3
10622: ST_TO_ADDR
// PrepareTank ( 5 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , [ 90 , 70 , 60 ] [ Difficulty ] ) ;
10623: LD_INT 5
10625: PPUSH
10626: LD_INT 3
10628: PPUSH
10629: LD_INT 21
10631: PPUSH
10632: LD_INT 1
10634: PPUSH
10635: LD_INT 1
10637: PPUSH
10638: LD_INT 42
10640: PPUSH
10641: LD_INT 90
10643: PUSH
10644: LD_INT 70
10646: PUSH
10647: LD_INT 60
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: LIST
10654: PUSH
10655: LD_OWVAR 67
10659: ARRAY
10660: PPUSH
10661: CALL 284 0 7
// veh := CreateVehicle ;
10665: LD_ADDR_VAR 0 3
10669: PUSH
10670: CALL_OW 45
10674: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10675: LD_VAR 0 3
10679: PPUSH
10680: LD_INT 4
10682: PPUSH
10683: CALL_OW 233
// PlaceUnitXY ( veh , 109 , 38 , false ) ;
10687: LD_VAR 0 3
10691: PPUSH
10692: LD_INT 109
10694: PPUSH
10695: LD_INT 38
10697: PPUSH
10698: LD_INT 0
10700: PPUSH
10701: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
10705: LD_EXP 28
10709: PPUSH
10710: LD_VAR 0 3
10714: PPUSH
10715: CALL_OW 52
// ComTurnUnit ( Kaia , Aviradze ) ;
10719: LD_EXP 26
10723: PPUSH
10724: LD_EXP 25
10728: PPUSH
10729: CALL_OW 119
// ComTurnUnit ( Aviradze , Kaia ) ;
10733: LD_EXP 25
10737: PPUSH
10738: LD_EXP 26
10742: PPUSH
10743: CALL_OW 119
// if not Givi or not Mike then
10747: LD_EXP 22
10751: NOT
10752: PUSH
10753: LD_EXP 23
10757: NOT
10758: OR
10759: IFFALSE 10819
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10761: LD_INT 1
10763: PPUSH
10764: LD_INT 1
10766: PPUSH
10767: LD_INT 1
10769: PPUSH
10770: CALL_OW 380
// un := CreateHuman ;
10774: LD_ADDR_VAR 0 2
10778: PUSH
10779: CALL_OW 44
10783: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 40 , 3 , false ) ;
10784: LD_VAR 0 2
10788: PPUSH
10789: LD_INT 112
10791: PPUSH
10792: LD_INT 40
10794: PPUSH
10795: LD_INT 3
10797: PPUSH
10798: LD_INT 0
10800: PPUSH
10801: CALL_OW 50
// ComTurnUnit ( un , Aviradze ) ;
10805: LD_VAR 0 2
10809: PPUSH
10810: LD_EXP 25
10814: PPUSH
10815: CALL_OW 119
// end ; end ;
10819: LD_VAR 0 1
10823: RET
// export function PrepareFarmer ; var i ; begin
10824: LD_INT 0
10826: PPUSH
10827: PPUSH
// uc_side := 5 ;
10828: LD_ADDR_OWVAR 20
10832: PUSH
10833: LD_INT 5
10835: ST_TO_ADDR
// uc_nation := 2 ;
10836: LD_ADDR_OWVAR 21
10840: PUSH
10841: LD_INT 2
10843: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
10844: LD_ADDR_EXP 29
10848: PUSH
10849: LD_STRING Farmer
10851: PPUSH
10852: LD_INT 0
10854: PPUSH
10855: LD_STRING 
10857: PPUSH
10858: CALL 221 0 3
10862: ST_TO_ADDR
// PlaceUnitXY ( Farmer , 106 , 62 , false ) ;
10863: LD_EXP 29
10867: PPUSH
10868: LD_INT 106
10870: PPUSH
10871: LD_INT 62
10873: PPUSH
10874: LD_INT 0
10876: PPUSH
10877: CALL_OW 48
// for i := 1 to 5 do
10881: LD_ADDR_VAR 0 2
10885: PUSH
10886: DOUBLE
10887: LD_INT 1
10889: DEC
10890: ST_TO_ADDR
10891: LD_INT 5
10893: PUSH
10894: FOR_TO
10895: IFFALSE 10933
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
10897: LD_INT 1
10899: PPUSH
10900: LD_INT 1
10902: PPUSH
10903: LD_INT 1
10905: PPUSH
10906: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 105 , 64 , 3 , false ) ;
10910: CALL_OW 44
10914: PPUSH
10915: LD_INT 105
10917: PPUSH
10918: LD_INT 64
10920: PPUSH
10921: LD_INT 3
10923: PPUSH
10924: LD_INT 0
10926: PPUSH
10927: CALL_OW 50
// end ;
10931: GO 10894
10933: POP
10934: POP
// end ; end_of_file
10935: LD_VAR 0 1
10939: RET
// every 2 2$20 + 0 0$10 do
10940: GO 10942
10942: DISABLE
// begin enable ;
10943: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , forest , true ) ;
10944: LD_INT 1
10946: PPUSH
10947: LD_INT 5
10949: PPUSH
10950: CALL_OW 12
10954: PPUSH
10955: LD_INT 1
10957: PPUSH
10958: LD_INT 1
10960: PPUSH
10961: CALL_OW 55
// end ; end_of_file
10965: END
// on UnitDestroyed ( un ) do begin if un = Heike then
10966: LD_VAR 0 1
10970: PUSH
10971: LD_EXP 21
10975: EQUAL
10976: IFFALSE 10985
// YouLost ( Heike ) ;
10978: LD_STRING Heike
10980: PPUSH
10981: CALL_OW 104
// if un = Aviradze then
10985: LD_VAR 0 1
10989: PUSH
10990: LD_EXP 25
10994: EQUAL
10995: IFFALSE 11004
// YouLost ( Aviradze ) ;
10997: LD_STRING Aviradze
10999: PPUSH
11000: CALL_OW 104
// if un = usLab then
11004: LD_VAR 0 1
11008: PUSH
11009: LD_INT 3
11011: EQUAL
11012: IFFALSE 11021
// YouLost ( Lab ) ;
11014: LD_STRING Lab
11016: PPUSH
11017: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) diff [ Heike , Aviradze ] and aviradzeSpotted then
11021: LD_VAR 0 1
11025: PUSH
11026: LD_INT 22
11028: PUSH
11029: LD_INT 2
11031: PUSH
11032: EMPTY
11033: LIST
11034: LIST
11035: PUSH
11036: LD_INT 21
11038: PUSH
11039: LD_INT 1
11041: PUSH
11042: EMPTY
11043: LIST
11044: LIST
11045: PUSH
11046: LD_INT 23
11048: PUSH
11049: LD_INT 2
11051: PUSH
11052: EMPTY
11053: LIST
11054: LIST
11055: PUSH
11056: EMPTY
11057: LIST
11058: LIST
11059: LIST
11060: PPUSH
11061: CALL_OW 69
11065: PUSH
11066: LD_EXP 21
11070: PUSH
11071: LD_EXP 25
11075: PUSH
11076: EMPTY
11077: LIST
11078: LIST
11079: DIFF
11080: IN
11081: PUSH
11082: LD_EXP 4
11086: AND
11087: IFFALSE 11103
// lostCounter := lostCounter + 1 ;
11089: LD_ADDR_EXP 16
11093: PUSH
11094: LD_EXP 16
11098: PUSH
11099: LD_INT 1
11101: PLUS
11102: ST_TO_ADDR
// end ;
11103: PPOPN 1
11105: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un in usSci and killerSide = 2 then
11106: LD_VAR 0 1
11110: PUSH
11111: LD_EXP 20
11115: IN
11116: PUSH
11117: LD_VAR 0 2
11121: PUSH
11122: LD_INT 2
11124: EQUAL
11125: AND
11126: IFFALSE 11158
// begin usSci := usSci diff un ;
11128: LD_ADDR_EXP 20
11132: PUSH
11133: LD_EXP 20
11137: PUSH
11138: LD_VAR 0 1
11142: DIFF
11143: ST_TO_ADDR
// sciCounterKill := sciCounterKill + 1 ;
11144: LD_ADDR_EXP 8
11148: PUSH
11149: LD_EXP 8
11153: PUSH
11154: LD_INT 1
11156: PLUS
11157: ST_TO_ADDR
// end ; end ;
11158: PPOPN 3
11160: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
11161: LD_VAR 0 1
11165: PUSH
11166: LD_INT 2
11168: EQUAL
11169: PUSH
11170: LD_VAR 0 2
11174: PUSH
11175: LD_INT 5
11177: EQUAL
11178: AND
11179: IFFALSE 11188
// YouLost ( FriendlyFire ) ;
11181: LD_STRING FriendlyFire
11183: PPUSH
11184: CALL_OW 104
// end ; end_of_file
11188: PPOPN 2
11190: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
11191: GO 11193
11193: DISABLE
// begin ru_radar := 98 ;
11194: LD_ADDR_EXP 30
11198: PUSH
11199: LD_INT 98
11201: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11202: LD_ADDR_EXP 31
11206: PUSH
11207: LD_INT 89
11209: ST_TO_ADDR
// us_hack := 99 ;
11210: LD_ADDR_EXP 32
11214: PUSH
11215: LD_INT 99
11217: ST_TO_ADDR
// us_artillery := 97 ;
11218: LD_ADDR_EXP 33
11222: PUSH
11223: LD_INT 97
11225: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11226: LD_ADDR_EXP 34
11230: PUSH
11231: LD_INT 91
11233: ST_TO_ADDR
// tech_Artillery := 80 ;
11234: LD_ADDR_EXP 35
11238: PUSH
11239: LD_INT 80
11241: ST_TO_ADDR
// tech_RadMat := 81 ;
11242: LD_ADDR_EXP 36
11246: PUSH
11247: LD_INT 81
11249: ST_TO_ADDR
// tech_BasicTools := 82 ;
11250: LD_ADDR_EXP 37
11254: PUSH
11255: LD_INT 82
11257: ST_TO_ADDR
// tech_Cargo := 83 ;
11258: LD_ADDR_EXP 38
11262: PUSH
11263: LD_INT 83
11265: ST_TO_ADDR
// tech_Track := 84 ;
11266: LD_ADDR_EXP 39
11270: PUSH
11271: LD_INT 84
11273: ST_TO_ADDR
// tech_Crane := 85 ;
11274: LD_ADDR_EXP 40
11278: PUSH
11279: LD_INT 85
11281: ST_TO_ADDR
// tech_Bulldozer := 86 ;
11282: LD_ADDR_EXP 41
11286: PUSH
11287: LD_INT 86
11289: ST_TO_ADDR
// tech_Hovercraft := 87 ;
11290: LD_ADDR_EXP 42
11294: PUSH
11295: LD_INT 87
11297: ST_TO_ADDR
// end ; end_of_file end_of_file
11298: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
11299: GO 11301
11301: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11302: LD_STRING initStreamRollete();
11304: PPUSH
11305: CALL_OW 559
// InitStreamMode ;
11309: CALL 11318 0 0
// DefineStreamItems ( ) ;
11313: CALL 11758 0 0
// end ;
11317: END
// function InitStreamMode ; begin
11318: LD_INT 0
11320: PPUSH
// streamModeActive := false ;
11321: LD_ADDR_EXP 43
11325: PUSH
11326: LD_INT 0
11328: ST_TO_ADDR
// normalCounter := 36 ;
11329: LD_ADDR_EXP 44
11333: PUSH
11334: LD_INT 36
11336: ST_TO_ADDR
// hardcoreCounter := 16 ;
11337: LD_ADDR_EXP 45
11341: PUSH
11342: LD_INT 16
11344: ST_TO_ADDR
// sRocket := false ;
11345: LD_ADDR_EXP 48
11349: PUSH
11350: LD_INT 0
11352: ST_TO_ADDR
// sSpeed := false ;
11353: LD_ADDR_EXP 47
11357: PUSH
11358: LD_INT 0
11360: ST_TO_ADDR
// sEngine := false ;
11361: LD_ADDR_EXP 49
11365: PUSH
11366: LD_INT 0
11368: ST_TO_ADDR
// sSpec := false ;
11369: LD_ADDR_EXP 46
11373: PUSH
11374: LD_INT 0
11376: ST_TO_ADDR
// sLevel := false ;
11377: LD_ADDR_EXP 50
11381: PUSH
11382: LD_INT 0
11384: ST_TO_ADDR
// sArmoury := false ;
11385: LD_ADDR_EXP 51
11389: PUSH
11390: LD_INT 0
11392: ST_TO_ADDR
// sRadar := false ;
11393: LD_ADDR_EXP 52
11397: PUSH
11398: LD_INT 0
11400: ST_TO_ADDR
// sBunker := false ;
11401: LD_ADDR_EXP 53
11405: PUSH
11406: LD_INT 0
11408: ST_TO_ADDR
// sHack := false ;
11409: LD_ADDR_EXP 54
11413: PUSH
11414: LD_INT 0
11416: ST_TO_ADDR
// sFire := false ;
11417: LD_ADDR_EXP 55
11421: PUSH
11422: LD_INT 0
11424: ST_TO_ADDR
// sRefresh := false ;
11425: LD_ADDR_EXP 56
11429: PUSH
11430: LD_INT 0
11432: ST_TO_ADDR
// sExp := false ;
11433: LD_ADDR_EXP 57
11437: PUSH
11438: LD_INT 0
11440: ST_TO_ADDR
// sDepot := false ;
11441: LD_ADDR_EXP 58
11445: PUSH
11446: LD_INT 0
11448: ST_TO_ADDR
// sFlag := false ;
11449: LD_ADDR_EXP 59
11453: PUSH
11454: LD_INT 0
11456: ST_TO_ADDR
// sKamikadze := false ;
11457: LD_ADDR_EXP 67
11461: PUSH
11462: LD_INT 0
11464: ST_TO_ADDR
// sTroll := false ;
11465: LD_ADDR_EXP 68
11469: PUSH
11470: LD_INT 0
11472: ST_TO_ADDR
// sSlow := false ;
11473: LD_ADDR_EXP 69
11477: PUSH
11478: LD_INT 0
11480: ST_TO_ADDR
// sLack := false ;
11481: LD_ADDR_EXP 70
11485: PUSH
11486: LD_INT 0
11488: ST_TO_ADDR
// sTank := false ;
11489: LD_ADDR_EXP 72
11493: PUSH
11494: LD_INT 0
11496: ST_TO_ADDR
// sRemote := false ;
11497: LD_ADDR_EXP 73
11501: PUSH
11502: LD_INT 0
11504: ST_TO_ADDR
// sPowell := false ;
11505: LD_ADDR_EXP 74
11509: PUSH
11510: LD_INT 0
11512: ST_TO_ADDR
// sTeleport := false ;
11513: LD_ADDR_EXP 77
11517: PUSH
11518: LD_INT 0
11520: ST_TO_ADDR
// sOilTower := false ;
11521: LD_ADDR_EXP 79
11525: PUSH
11526: LD_INT 0
11528: ST_TO_ADDR
// sShovel := false ;
11529: LD_ADDR_EXP 80
11533: PUSH
11534: LD_INT 0
11536: ST_TO_ADDR
// sSheik := false ;
11537: LD_ADDR_EXP 81
11541: PUSH
11542: LD_INT 0
11544: ST_TO_ADDR
// sEarthquake := false ;
11545: LD_ADDR_EXP 83
11549: PUSH
11550: LD_INT 0
11552: ST_TO_ADDR
// sAI := false ;
11553: LD_ADDR_EXP 84
11557: PUSH
11558: LD_INT 0
11560: ST_TO_ADDR
// sCargo := false ;
11561: LD_ADDR_EXP 87
11565: PUSH
11566: LD_INT 0
11568: ST_TO_ADDR
// sDLaser := false ;
11569: LD_ADDR_EXP 88
11573: PUSH
11574: LD_INT 0
11576: ST_TO_ADDR
// sExchange := false ;
11577: LD_ADDR_EXP 89
11581: PUSH
11582: LD_INT 0
11584: ST_TO_ADDR
// sFac := false ;
11585: LD_ADDR_EXP 90
11589: PUSH
11590: LD_INT 0
11592: ST_TO_ADDR
// sPower := false ;
11593: LD_ADDR_EXP 91
11597: PUSH
11598: LD_INT 0
11600: ST_TO_ADDR
// sRandom := false ;
11601: LD_ADDR_EXP 92
11605: PUSH
11606: LD_INT 0
11608: ST_TO_ADDR
// sShield := false ;
11609: LD_ADDR_EXP 93
11613: PUSH
11614: LD_INT 0
11616: ST_TO_ADDR
// sTime := false ;
11617: LD_ADDR_EXP 94
11621: PUSH
11622: LD_INT 0
11624: ST_TO_ADDR
// sTools := false ;
11625: LD_ADDR_EXP 95
11629: PUSH
11630: LD_INT 0
11632: ST_TO_ADDR
// sSold := false ;
11633: LD_ADDR_EXP 60
11637: PUSH
11638: LD_INT 0
11640: ST_TO_ADDR
// sDiff := false ;
11641: LD_ADDR_EXP 61
11645: PUSH
11646: LD_INT 0
11648: ST_TO_ADDR
// sFog := false ;
11649: LD_ADDR_EXP 64
11653: PUSH
11654: LD_INT 0
11656: ST_TO_ADDR
// sReset := false ;
11657: LD_ADDR_EXP 65
11661: PUSH
11662: LD_INT 0
11664: ST_TO_ADDR
// sSun := false ;
11665: LD_ADDR_EXP 66
11669: PUSH
11670: LD_INT 0
11672: ST_TO_ADDR
// sTiger := false ;
11673: LD_ADDR_EXP 62
11677: PUSH
11678: LD_INT 0
11680: ST_TO_ADDR
// sBomb := false ;
11681: LD_ADDR_EXP 63
11685: PUSH
11686: LD_INT 0
11688: ST_TO_ADDR
// sWound := false ;
11689: LD_ADDR_EXP 71
11693: PUSH
11694: LD_INT 0
11696: ST_TO_ADDR
// sBetray := false ;
11697: LD_ADDR_EXP 75
11701: PUSH
11702: LD_INT 0
11704: ST_TO_ADDR
// sContamin := false ;
11705: LD_ADDR_EXP 76
11709: PUSH
11710: LD_INT 0
11712: ST_TO_ADDR
// sOil := false ;
11713: LD_ADDR_EXP 78
11717: PUSH
11718: LD_INT 0
11720: ST_TO_ADDR
// sStu := false ;
11721: LD_ADDR_EXP 82
11725: PUSH
11726: LD_INT 0
11728: ST_TO_ADDR
// sBazooka := false ;
11729: LD_ADDR_EXP 85
11733: PUSH
11734: LD_INT 0
11736: ST_TO_ADDR
// sMortar := false ;
11737: LD_ADDR_EXP 86
11741: PUSH
11742: LD_INT 0
11744: ST_TO_ADDR
// sRanger := false ;
11745: LD_ADDR_EXP 96
11749: PUSH
11750: LD_INT 0
11752: ST_TO_ADDR
// end ;
11753: LD_VAR 0 1
11757: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11758: LD_INT 0
11760: PPUSH
11761: PPUSH
11762: PPUSH
11763: PPUSH
11764: PPUSH
// result := [ ] ;
11765: LD_ADDR_VAR 0 1
11769: PUSH
11770: EMPTY
11771: ST_TO_ADDR
// if campaign_id = 1 then
11772: LD_OWVAR 69
11776: PUSH
11777: LD_INT 1
11779: EQUAL
11780: IFFALSE 14718
// begin case mission_number of 1 :
11782: LD_OWVAR 70
11786: PUSH
11787: LD_INT 1
11789: DOUBLE
11790: EQUAL
11791: IFTRUE 11795
11793: GO 11859
11795: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11796: LD_ADDR_VAR 0 1
11800: PUSH
11801: LD_INT 2
11803: PUSH
11804: LD_INT 4
11806: PUSH
11807: LD_INT 11
11809: PUSH
11810: LD_INT 12
11812: PUSH
11813: LD_INT 15
11815: PUSH
11816: LD_INT 16
11818: PUSH
11819: LD_INT 22
11821: PUSH
11822: LD_INT 23
11824: PUSH
11825: LD_INT 26
11827: PUSH
11828: EMPTY
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: LIST
11835: LIST
11836: LIST
11837: LIST
11838: PUSH
11839: LD_INT 101
11841: PUSH
11842: LD_INT 102
11844: PUSH
11845: LD_INT 106
11847: PUSH
11848: EMPTY
11849: LIST
11850: LIST
11851: LIST
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: ST_TO_ADDR
11857: GO 14716
11859: LD_INT 2
11861: DOUBLE
11862: EQUAL
11863: IFTRUE 11867
11865: GO 11939
11867: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11868: LD_ADDR_VAR 0 1
11872: PUSH
11873: LD_INT 2
11875: PUSH
11876: LD_INT 4
11878: PUSH
11879: LD_INT 11
11881: PUSH
11882: LD_INT 12
11884: PUSH
11885: LD_INT 15
11887: PUSH
11888: LD_INT 16
11890: PUSH
11891: LD_INT 22
11893: PUSH
11894: LD_INT 23
11896: PUSH
11897: LD_INT 26
11899: PUSH
11900: EMPTY
11901: LIST
11902: LIST
11903: LIST
11904: LIST
11905: LIST
11906: LIST
11907: LIST
11908: LIST
11909: LIST
11910: PUSH
11911: LD_INT 101
11913: PUSH
11914: LD_INT 102
11916: PUSH
11917: LD_INT 105
11919: PUSH
11920: LD_INT 106
11922: PUSH
11923: LD_INT 108
11925: PUSH
11926: EMPTY
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: LIST
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: ST_TO_ADDR
11937: GO 14716
11939: LD_INT 3
11941: DOUBLE
11942: EQUAL
11943: IFTRUE 11947
11945: GO 12023
11947: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11948: LD_ADDR_VAR 0 1
11952: PUSH
11953: LD_INT 2
11955: PUSH
11956: LD_INT 4
11958: PUSH
11959: LD_INT 5
11961: PUSH
11962: LD_INT 11
11964: PUSH
11965: LD_INT 12
11967: PUSH
11968: LD_INT 15
11970: PUSH
11971: LD_INT 16
11973: PUSH
11974: LD_INT 22
11976: PUSH
11977: LD_INT 26
11979: PUSH
11980: LD_INT 36
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: LIST
11992: LIST
11993: LIST
11994: PUSH
11995: LD_INT 101
11997: PUSH
11998: LD_INT 102
12000: PUSH
12001: LD_INT 105
12003: PUSH
12004: LD_INT 106
12006: PUSH
12007: LD_INT 108
12009: PUSH
12010: EMPTY
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: PUSH
12017: EMPTY
12018: LIST
12019: LIST
12020: ST_TO_ADDR
12021: GO 14716
12023: LD_INT 4
12025: DOUBLE
12026: EQUAL
12027: IFTRUE 12031
12029: GO 12115
12031: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
12032: LD_ADDR_VAR 0 1
12036: PUSH
12037: LD_INT 2
12039: PUSH
12040: LD_INT 4
12042: PUSH
12043: LD_INT 5
12045: PUSH
12046: LD_INT 8
12048: PUSH
12049: LD_INT 11
12051: PUSH
12052: LD_INT 12
12054: PUSH
12055: LD_INT 15
12057: PUSH
12058: LD_INT 16
12060: PUSH
12061: LD_INT 22
12063: PUSH
12064: LD_INT 23
12066: PUSH
12067: LD_INT 26
12069: PUSH
12070: LD_INT 36
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: LIST
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: PUSH
12087: LD_INT 101
12089: PUSH
12090: LD_INT 102
12092: PUSH
12093: LD_INT 105
12095: PUSH
12096: LD_INT 106
12098: PUSH
12099: LD_INT 108
12101: PUSH
12102: EMPTY
12103: LIST
12104: LIST
12105: LIST
12106: LIST
12107: LIST
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: ST_TO_ADDR
12113: GO 14716
12115: LD_INT 5
12117: DOUBLE
12118: EQUAL
12119: IFTRUE 12123
12121: GO 12223
12123: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
12124: LD_ADDR_VAR 0 1
12128: PUSH
12129: LD_INT 2
12131: PUSH
12132: LD_INT 4
12134: PUSH
12135: LD_INT 5
12137: PUSH
12138: LD_INT 6
12140: PUSH
12141: LD_INT 8
12143: PUSH
12144: LD_INT 11
12146: PUSH
12147: LD_INT 12
12149: PUSH
12150: LD_INT 15
12152: PUSH
12153: LD_INT 16
12155: PUSH
12156: LD_INT 22
12158: PUSH
12159: LD_INT 23
12161: PUSH
12162: LD_INT 25
12164: PUSH
12165: LD_INT 26
12167: PUSH
12168: LD_INT 36
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: LIST
12175: LIST
12176: LIST
12177: LIST
12178: LIST
12179: LIST
12180: LIST
12181: LIST
12182: LIST
12183: LIST
12184: LIST
12185: LIST
12186: PUSH
12187: LD_INT 101
12189: PUSH
12190: LD_INT 102
12192: PUSH
12193: LD_INT 105
12195: PUSH
12196: LD_INT 106
12198: PUSH
12199: LD_INT 108
12201: PUSH
12202: LD_INT 109
12204: PUSH
12205: LD_INT 112
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: LIST
12212: LIST
12213: LIST
12214: LIST
12215: LIST
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: ST_TO_ADDR
12221: GO 14716
12223: LD_INT 6
12225: DOUBLE
12226: EQUAL
12227: IFTRUE 12231
12229: GO 12351
12231: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
12232: LD_ADDR_VAR 0 1
12236: PUSH
12237: LD_INT 2
12239: PUSH
12240: LD_INT 4
12242: PUSH
12243: LD_INT 5
12245: PUSH
12246: LD_INT 6
12248: PUSH
12249: LD_INT 8
12251: PUSH
12252: LD_INT 11
12254: PUSH
12255: LD_INT 12
12257: PUSH
12258: LD_INT 15
12260: PUSH
12261: LD_INT 16
12263: PUSH
12264: LD_INT 20
12266: PUSH
12267: LD_INT 21
12269: PUSH
12270: LD_INT 22
12272: PUSH
12273: LD_INT 23
12275: PUSH
12276: LD_INT 25
12278: PUSH
12279: LD_INT 26
12281: PUSH
12282: LD_INT 30
12284: PUSH
12285: LD_INT 31
12287: PUSH
12288: LD_INT 32
12290: PUSH
12291: LD_INT 36
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: PUSH
12315: LD_INT 101
12317: PUSH
12318: LD_INT 102
12320: PUSH
12321: LD_INT 105
12323: PUSH
12324: LD_INT 106
12326: PUSH
12327: LD_INT 108
12329: PUSH
12330: LD_INT 109
12332: PUSH
12333: LD_INT 112
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: LIST
12340: LIST
12341: LIST
12342: LIST
12343: LIST
12344: PUSH
12345: EMPTY
12346: LIST
12347: LIST
12348: ST_TO_ADDR
12349: GO 14716
12351: LD_INT 7
12353: DOUBLE
12354: EQUAL
12355: IFTRUE 12359
12357: GO 12459
12359: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12360: LD_ADDR_VAR 0 1
12364: PUSH
12365: LD_INT 2
12367: PUSH
12368: LD_INT 4
12370: PUSH
12371: LD_INT 5
12373: PUSH
12374: LD_INT 7
12376: PUSH
12377: LD_INT 11
12379: PUSH
12380: LD_INT 12
12382: PUSH
12383: LD_INT 15
12385: PUSH
12386: LD_INT 16
12388: PUSH
12389: LD_INT 20
12391: PUSH
12392: LD_INT 21
12394: PUSH
12395: LD_INT 22
12397: PUSH
12398: LD_INT 23
12400: PUSH
12401: LD_INT 25
12403: PUSH
12404: LD_INT 26
12406: PUSH
12407: EMPTY
12408: LIST
12409: LIST
12410: LIST
12411: LIST
12412: LIST
12413: LIST
12414: LIST
12415: LIST
12416: LIST
12417: LIST
12418: LIST
12419: LIST
12420: LIST
12421: LIST
12422: PUSH
12423: LD_INT 101
12425: PUSH
12426: LD_INT 102
12428: PUSH
12429: LD_INT 103
12431: PUSH
12432: LD_INT 105
12434: PUSH
12435: LD_INT 106
12437: PUSH
12438: LD_INT 108
12440: PUSH
12441: LD_INT 112
12443: PUSH
12444: EMPTY
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: PUSH
12453: EMPTY
12454: LIST
12455: LIST
12456: ST_TO_ADDR
12457: GO 14716
12459: LD_INT 8
12461: DOUBLE
12462: EQUAL
12463: IFTRUE 12467
12465: GO 12595
12467: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12468: LD_ADDR_VAR 0 1
12472: PUSH
12473: LD_INT 2
12475: PUSH
12476: LD_INT 4
12478: PUSH
12479: LD_INT 5
12481: PUSH
12482: LD_INT 6
12484: PUSH
12485: LD_INT 7
12487: PUSH
12488: LD_INT 8
12490: PUSH
12491: LD_INT 11
12493: PUSH
12494: LD_INT 12
12496: PUSH
12497: LD_INT 15
12499: PUSH
12500: LD_INT 16
12502: PUSH
12503: LD_INT 20
12505: PUSH
12506: LD_INT 21
12508: PUSH
12509: LD_INT 22
12511: PUSH
12512: LD_INT 23
12514: PUSH
12515: LD_INT 25
12517: PUSH
12518: LD_INT 26
12520: PUSH
12521: LD_INT 30
12523: PUSH
12524: LD_INT 31
12526: PUSH
12527: LD_INT 32
12529: PUSH
12530: LD_INT 36
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: LIST
12537: LIST
12538: LIST
12539: LIST
12540: LIST
12541: LIST
12542: LIST
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: LIST
12548: LIST
12549: LIST
12550: LIST
12551: LIST
12552: LIST
12553: LIST
12554: PUSH
12555: LD_INT 101
12557: PUSH
12558: LD_INT 102
12560: PUSH
12561: LD_INT 103
12563: PUSH
12564: LD_INT 105
12566: PUSH
12567: LD_INT 106
12569: PUSH
12570: LD_INT 108
12572: PUSH
12573: LD_INT 109
12575: PUSH
12576: LD_INT 112
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: LIST
12586: LIST
12587: LIST
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: ST_TO_ADDR
12593: GO 14716
12595: LD_INT 9
12597: DOUBLE
12598: EQUAL
12599: IFTRUE 12603
12601: GO 12739
12603: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12604: LD_ADDR_VAR 0 1
12608: PUSH
12609: LD_INT 2
12611: PUSH
12612: LD_INT 4
12614: PUSH
12615: LD_INT 5
12617: PUSH
12618: LD_INT 6
12620: PUSH
12621: LD_INT 7
12623: PUSH
12624: LD_INT 8
12626: PUSH
12627: LD_INT 11
12629: PUSH
12630: LD_INT 12
12632: PUSH
12633: LD_INT 15
12635: PUSH
12636: LD_INT 16
12638: PUSH
12639: LD_INT 20
12641: PUSH
12642: LD_INT 21
12644: PUSH
12645: LD_INT 22
12647: PUSH
12648: LD_INT 23
12650: PUSH
12651: LD_INT 25
12653: PUSH
12654: LD_INT 26
12656: PUSH
12657: LD_INT 28
12659: PUSH
12660: LD_INT 30
12662: PUSH
12663: LD_INT 31
12665: PUSH
12666: LD_INT 32
12668: PUSH
12669: LD_INT 36
12671: PUSH
12672: EMPTY
12673: LIST
12674: LIST
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: LIST
12686: LIST
12687: LIST
12688: LIST
12689: LIST
12690: LIST
12691: LIST
12692: LIST
12693: LIST
12694: PUSH
12695: LD_INT 101
12697: PUSH
12698: LD_INT 102
12700: PUSH
12701: LD_INT 103
12703: PUSH
12704: LD_INT 105
12706: PUSH
12707: LD_INT 106
12709: PUSH
12710: LD_INT 108
12712: PUSH
12713: LD_INT 109
12715: PUSH
12716: LD_INT 112
12718: PUSH
12719: LD_INT 114
12721: PUSH
12722: EMPTY
12723: LIST
12724: LIST
12725: LIST
12726: LIST
12727: LIST
12728: LIST
12729: LIST
12730: LIST
12731: LIST
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: ST_TO_ADDR
12737: GO 14716
12739: LD_INT 10
12741: DOUBLE
12742: EQUAL
12743: IFTRUE 12747
12745: GO 12931
12747: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12748: LD_ADDR_VAR 0 1
12752: PUSH
12753: LD_INT 2
12755: PUSH
12756: LD_INT 4
12758: PUSH
12759: LD_INT 5
12761: PUSH
12762: LD_INT 6
12764: PUSH
12765: LD_INT 7
12767: PUSH
12768: LD_INT 8
12770: PUSH
12771: LD_INT 9
12773: PUSH
12774: LD_INT 10
12776: PUSH
12777: LD_INT 11
12779: PUSH
12780: LD_INT 12
12782: PUSH
12783: LD_INT 13
12785: PUSH
12786: LD_INT 14
12788: PUSH
12789: LD_INT 15
12791: PUSH
12792: LD_INT 16
12794: PUSH
12795: LD_INT 17
12797: PUSH
12798: LD_INT 18
12800: PUSH
12801: LD_INT 19
12803: PUSH
12804: LD_INT 20
12806: PUSH
12807: LD_INT 21
12809: PUSH
12810: LD_INT 22
12812: PUSH
12813: LD_INT 23
12815: PUSH
12816: LD_INT 24
12818: PUSH
12819: LD_INT 25
12821: PUSH
12822: LD_INT 26
12824: PUSH
12825: LD_INT 28
12827: PUSH
12828: LD_INT 30
12830: PUSH
12831: LD_INT 31
12833: PUSH
12834: LD_INT 32
12836: PUSH
12837: LD_INT 36
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: LIST
12844: LIST
12845: LIST
12846: LIST
12847: LIST
12848: LIST
12849: LIST
12850: LIST
12851: LIST
12852: LIST
12853: LIST
12854: LIST
12855: LIST
12856: LIST
12857: LIST
12858: LIST
12859: LIST
12860: LIST
12861: LIST
12862: LIST
12863: LIST
12864: LIST
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: LIST
12870: PUSH
12871: LD_INT 101
12873: PUSH
12874: LD_INT 102
12876: PUSH
12877: LD_INT 103
12879: PUSH
12880: LD_INT 104
12882: PUSH
12883: LD_INT 105
12885: PUSH
12886: LD_INT 106
12888: PUSH
12889: LD_INT 107
12891: PUSH
12892: LD_INT 108
12894: PUSH
12895: LD_INT 109
12897: PUSH
12898: LD_INT 110
12900: PUSH
12901: LD_INT 111
12903: PUSH
12904: LD_INT 112
12906: PUSH
12907: LD_INT 114
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: LIST
12914: LIST
12915: LIST
12916: LIST
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: ST_TO_ADDR
12929: GO 14716
12931: LD_INT 11
12933: DOUBLE
12934: EQUAL
12935: IFTRUE 12939
12937: GO 13131
12939: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12940: LD_ADDR_VAR 0 1
12944: PUSH
12945: LD_INT 2
12947: PUSH
12948: LD_INT 3
12950: PUSH
12951: LD_INT 4
12953: PUSH
12954: LD_INT 5
12956: PUSH
12957: LD_INT 6
12959: PUSH
12960: LD_INT 7
12962: PUSH
12963: LD_INT 8
12965: PUSH
12966: LD_INT 9
12968: PUSH
12969: LD_INT 10
12971: PUSH
12972: LD_INT 11
12974: PUSH
12975: LD_INT 12
12977: PUSH
12978: LD_INT 13
12980: PUSH
12981: LD_INT 14
12983: PUSH
12984: LD_INT 15
12986: PUSH
12987: LD_INT 16
12989: PUSH
12990: LD_INT 17
12992: PUSH
12993: LD_INT 18
12995: PUSH
12996: LD_INT 19
12998: PUSH
12999: LD_INT 20
13001: PUSH
13002: LD_INT 21
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 23
13010: PUSH
13011: LD_INT 24
13013: PUSH
13014: LD_INT 25
13016: PUSH
13017: LD_INT 26
13019: PUSH
13020: LD_INT 28
13022: PUSH
13023: LD_INT 30
13025: PUSH
13026: LD_INT 31
13028: PUSH
13029: LD_INT 32
13031: PUSH
13032: LD_INT 34
13034: PUSH
13035: LD_INT 36
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: LIST
13062: LIST
13063: LIST
13064: LIST
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: PUSH
13071: LD_INT 101
13073: PUSH
13074: LD_INT 102
13076: PUSH
13077: LD_INT 103
13079: PUSH
13080: LD_INT 104
13082: PUSH
13083: LD_INT 105
13085: PUSH
13086: LD_INT 106
13088: PUSH
13089: LD_INT 107
13091: PUSH
13092: LD_INT 108
13094: PUSH
13095: LD_INT 109
13097: PUSH
13098: LD_INT 110
13100: PUSH
13101: LD_INT 111
13103: PUSH
13104: LD_INT 112
13106: PUSH
13107: LD_INT 114
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: LIST
13123: LIST
13124: PUSH
13125: EMPTY
13126: LIST
13127: LIST
13128: ST_TO_ADDR
13129: GO 14716
13131: LD_INT 12
13133: DOUBLE
13134: EQUAL
13135: IFTRUE 13139
13137: GO 13347
13139: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
13140: LD_ADDR_VAR 0 1
13144: PUSH
13145: LD_INT 1
13147: PUSH
13148: LD_INT 2
13150: PUSH
13151: LD_INT 3
13153: PUSH
13154: LD_INT 4
13156: PUSH
13157: LD_INT 5
13159: PUSH
13160: LD_INT 6
13162: PUSH
13163: LD_INT 7
13165: PUSH
13166: LD_INT 8
13168: PUSH
13169: LD_INT 9
13171: PUSH
13172: LD_INT 10
13174: PUSH
13175: LD_INT 11
13177: PUSH
13178: LD_INT 12
13180: PUSH
13181: LD_INT 13
13183: PUSH
13184: LD_INT 14
13186: PUSH
13187: LD_INT 15
13189: PUSH
13190: LD_INT 16
13192: PUSH
13193: LD_INT 17
13195: PUSH
13196: LD_INT 18
13198: PUSH
13199: LD_INT 19
13201: PUSH
13202: LD_INT 20
13204: PUSH
13205: LD_INT 21
13207: PUSH
13208: LD_INT 22
13210: PUSH
13211: LD_INT 23
13213: PUSH
13214: LD_INT 24
13216: PUSH
13217: LD_INT 25
13219: PUSH
13220: LD_INT 26
13222: PUSH
13223: LD_INT 27
13225: PUSH
13226: LD_INT 28
13228: PUSH
13229: LD_INT 30
13231: PUSH
13232: LD_INT 31
13234: PUSH
13235: LD_INT 32
13237: PUSH
13238: LD_INT 33
13240: PUSH
13241: LD_INT 34
13243: PUSH
13244: LD_INT 36
13246: PUSH
13247: EMPTY
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: LIST
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: LIST
13267: LIST
13268: LIST
13269: LIST
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: LIST
13282: PUSH
13283: LD_INT 101
13285: PUSH
13286: LD_INT 102
13288: PUSH
13289: LD_INT 103
13291: PUSH
13292: LD_INT 104
13294: PUSH
13295: LD_INT 105
13297: PUSH
13298: LD_INT 106
13300: PUSH
13301: LD_INT 107
13303: PUSH
13304: LD_INT 108
13306: PUSH
13307: LD_INT 109
13309: PUSH
13310: LD_INT 110
13312: PUSH
13313: LD_INT 111
13315: PUSH
13316: LD_INT 112
13318: PUSH
13319: LD_INT 113
13321: PUSH
13322: LD_INT 114
13324: PUSH
13325: EMPTY
13326: LIST
13327: LIST
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: LIST
13333: LIST
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: PUSH
13341: EMPTY
13342: LIST
13343: LIST
13344: ST_TO_ADDR
13345: GO 14716
13347: LD_INT 13
13349: DOUBLE
13350: EQUAL
13351: IFTRUE 13355
13353: GO 13551
13355: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13356: LD_ADDR_VAR 0 1
13360: PUSH
13361: LD_INT 1
13363: PUSH
13364: LD_INT 2
13366: PUSH
13367: LD_INT 3
13369: PUSH
13370: LD_INT 4
13372: PUSH
13373: LD_INT 5
13375: PUSH
13376: LD_INT 8
13378: PUSH
13379: LD_INT 9
13381: PUSH
13382: LD_INT 10
13384: PUSH
13385: LD_INT 11
13387: PUSH
13388: LD_INT 12
13390: PUSH
13391: LD_INT 14
13393: PUSH
13394: LD_INT 15
13396: PUSH
13397: LD_INT 16
13399: PUSH
13400: LD_INT 17
13402: PUSH
13403: LD_INT 18
13405: PUSH
13406: LD_INT 19
13408: PUSH
13409: LD_INT 20
13411: PUSH
13412: LD_INT 21
13414: PUSH
13415: LD_INT 22
13417: PUSH
13418: LD_INT 23
13420: PUSH
13421: LD_INT 24
13423: PUSH
13424: LD_INT 25
13426: PUSH
13427: LD_INT 26
13429: PUSH
13430: LD_INT 27
13432: PUSH
13433: LD_INT 28
13435: PUSH
13436: LD_INT 30
13438: PUSH
13439: LD_INT 31
13441: PUSH
13442: LD_INT 32
13444: PUSH
13445: LD_INT 33
13447: PUSH
13448: LD_INT 34
13450: PUSH
13451: LD_INT 36
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: LIST
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: LIST
13463: LIST
13464: LIST
13465: LIST
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: LIST
13471: LIST
13472: LIST
13473: LIST
13474: LIST
13475: LIST
13476: LIST
13477: LIST
13478: LIST
13479: LIST
13480: LIST
13481: LIST
13482: LIST
13483: LIST
13484: LIST
13485: LIST
13486: PUSH
13487: LD_INT 101
13489: PUSH
13490: LD_INT 102
13492: PUSH
13493: LD_INT 103
13495: PUSH
13496: LD_INT 104
13498: PUSH
13499: LD_INT 105
13501: PUSH
13502: LD_INT 106
13504: PUSH
13505: LD_INT 107
13507: PUSH
13508: LD_INT 108
13510: PUSH
13511: LD_INT 109
13513: PUSH
13514: LD_INT 110
13516: PUSH
13517: LD_INT 111
13519: PUSH
13520: LD_INT 112
13522: PUSH
13523: LD_INT 113
13525: PUSH
13526: LD_INT 114
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: LIST
13533: LIST
13534: LIST
13535: LIST
13536: LIST
13537: LIST
13538: LIST
13539: LIST
13540: LIST
13541: LIST
13542: LIST
13543: LIST
13544: PUSH
13545: EMPTY
13546: LIST
13547: LIST
13548: ST_TO_ADDR
13549: GO 14716
13551: LD_INT 14
13553: DOUBLE
13554: EQUAL
13555: IFTRUE 13559
13557: GO 13771
13559: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13560: LD_ADDR_VAR 0 1
13564: PUSH
13565: LD_INT 1
13567: PUSH
13568: LD_INT 2
13570: PUSH
13571: LD_INT 3
13573: PUSH
13574: LD_INT 4
13576: PUSH
13577: LD_INT 5
13579: PUSH
13580: LD_INT 6
13582: PUSH
13583: LD_INT 7
13585: PUSH
13586: LD_INT 8
13588: PUSH
13589: LD_INT 9
13591: PUSH
13592: LD_INT 10
13594: PUSH
13595: LD_INT 11
13597: PUSH
13598: LD_INT 12
13600: PUSH
13601: LD_INT 13
13603: PUSH
13604: LD_INT 14
13606: PUSH
13607: LD_INT 15
13609: PUSH
13610: LD_INT 16
13612: PUSH
13613: LD_INT 17
13615: PUSH
13616: LD_INT 18
13618: PUSH
13619: LD_INT 19
13621: PUSH
13622: LD_INT 20
13624: PUSH
13625: LD_INT 21
13627: PUSH
13628: LD_INT 22
13630: PUSH
13631: LD_INT 23
13633: PUSH
13634: LD_INT 24
13636: PUSH
13637: LD_INT 25
13639: PUSH
13640: LD_INT 26
13642: PUSH
13643: LD_INT 27
13645: PUSH
13646: LD_INT 28
13648: PUSH
13649: LD_INT 29
13651: PUSH
13652: LD_INT 30
13654: PUSH
13655: LD_INT 31
13657: PUSH
13658: LD_INT 32
13660: PUSH
13661: LD_INT 33
13663: PUSH
13664: LD_INT 34
13666: PUSH
13667: LD_INT 36
13669: PUSH
13670: EMPTY
13671: LIST
13672: LIST
13673: LIST
13674: LIST
13675: LIST
13676: LIST
13677: LIST
13678: LIST
13679: LIST
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: LIST
13700: LIST
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: LIST
13706: PUSH
13707: LD_INT 101
13709: PUSH
13710: LD_INT 102
13712: PUSH
13713: LD_INT 103
13715: PUSH
13716: LD_INT 104
13718: PUSH
13719: LD_INT 105
13721: PUSH
13722: LD_INT 106
13724: PUSH
13725: LD_INT 107
13727: PUSH
13728: LD_INT 108
13730: PUSH
13731: LD_INT 109
13733: PUSH
13734: LD_INT 110
13736: PUSH
13737: LD_INT 111
13739: PUSH
13740: LD_INT 112
13742: PUSH
13743: LD_INT 113
13745: PUSH
13746: LD_INT 114
13748: PUSH
13749: EMPTY
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: LIST
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: ST_TO_ADDR
13769: GO 14716
13771: LD_INT 15
13773: DOUBLE
13774: EQUAL
13775: IFTRUE 13779
13777: GO 13991
13779: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13780: LD_ADDR_VAR 0 1
13784: PUSH
13785: LD_INT 1
13787: PUSH
13788: LD_INT 2
13790: PUSH
13791: LD_INT 3
13793: PUSH
13794: LD_INT 4
13796: PUSH
13797: LD_INT 5
13799: PUSH
13800: LD_INT 6
13802: PUSH
13803: LD_INT 7
13805: PUSH
13806: LD_INT 8
13808: PUSH
13809: LD_INT 9
13811: PUSH
13812: LD_INT 10
13814: PUSH
13815: LD_INT 11
13817: PUSH
13818: LD_INT 12
13820: PUSH
13821: LD_INT 13
13823: PUSH
13824: LD_INT 14
13826: PUSH
13827: LD_INT 15
13829: PUSH
13830: LD_INT 16
13832: PUSH
13833: LD_INT 17
13835: PUSH
13836: LD_INT 18
13838: PUSH
13839: LD_INT 19
13841: PUSH
13842: LD_INT 20
13844: PUSH
13845: LD_INT 21
13847: PUSH
13848: LD_INT 22
13850: PUSH
13851: LD_INT 23
13853: PUSH
13854: LD_INT 24
13856: PUSH
13857: LD_INT 25
13859: PUSH
13860: LD_INT 26
13862: PUSH
13863: LD_INT 27
13865: PUSH
13866: LD_INT 28
13868: PUSH
13869: LD_INT 29
13871: PUSH
13872: LD_INT 30
13874: PUSH
13875: LD_INT 31
13877: PUSH
13878: LD_INT 32
13880: PUSH
13881: LD_INT 33
13883: PUSH
13884: LD_INT 34
13886: PUSH
13887: LD_INT 36
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: LIST
13894: LIST
13895: LIST
13896: LIST
13897: LIST
13898: LIST
13899: LIST
13900: LIST
13901: LIST
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: PUSH
13927: LD_INT 101
13929: PUSH
13930: LD_INT 102
13932: PUSH
13933: LD_INT 103
13935: PUSH
13936: LD_INT 104
13938: PUSH
13939: LD_INT 105
13941: PUSH
13942: LD_INT 106
13944: PUSH
13945: LD_INT 107
13947: PUSH
13948: LD_INT 108
13950: PUSH
13951: LD_INT 109
13953: PUSH
13954: LD_INT 110
13956: PUSH
13957: LD_INT 111
13959: PUSH
13960: LD_INT 112
13962: PUSH
13963: LD_INT 113
13965: PUSH
13966: LD_INT 114
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: LIST
13983: LIST
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: ST_TO_ADDR
13989: GO 14716
13991: LD_INT 16
13993: DOUBLE
13994: EQUAL
13995: IFTRUE 13999
13997: GO 14123
13999: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
14000: LD_ADDR_VAR 0 1
14004: PUSH
14005: LD_INT 2
14007: PUSH
14008: LD_INT 4
14010: PUSH
14011: LD_INT 5
14013: PUSH
14014: LD_INT 7
14016: PUSH
14017: LD_INT 11
14019: PUSH
14020: LD_INT 12
14022: PUSH
14023: LD_INT 15
14025: PUSH
14026: LD_INT 16
14028: PUSH
14029: LD_INT 20
14031: PUSH
14032: LD_INT 21
14034: PUSH
14035: LD_INT 22
14037: PUSH
14038: LD_INT 23
14040: PUSH
14041: LD_INT 25
14043: PUSH
14044: LD_INT 26
14046: PUSH
14047: LD_INT 30
14049: PUSH
14050: LD_INT 31
14052: PUSH
14053: LD_INT 32
14055: PUSH
14056: LD_INT 33
14058: PUSH
14059: LD_INT 34
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: LIST
14066: LIST
14067: LIST
14068: LIST
14069: LIST
14070: LIST
14071: LIST
14072: LIST
14073: LIST
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: PUSH
14083: LD_INT 101
14085: PUSH
14086: LD_INT 102
14088: PUSH
14089: LD_INT 103
14091: PUSH
14092: LD_INT 106
14094: PUSH
14095: LD_INT 108
14097: PUSH
14098: LD_INT 112
14100: PUSH
14101: LD_INT 113
14103: PUSH
14104: LD_INT 114
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: PUSH
14117: EMPTY
14118: LIST
14119: LIST
14120: ST_TO_ADDR
14121: GO 14716
14123: LD_INT 17
14125: DOUBLE
14126: EQUAL
14127: IFTRUE 14131
14129: GO 14343
14131: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
14132: LD_ADDR_VAR 0 1
14136: PUSH
14137: LD_INT 1
14139: PUSH
14140: LD_INT 2
14142: PUSH
14143: LD_INT 3
14145: PUSH
14146: LD_INT 4
14148: PUSH
14149: LD_INT 5
14151: PUSH
14152: LD_INT 6
14154: PUSH
14155: LD_INT 7
14157: PUSH
14158: LD_INT 8
14160: PUSH
14161: LD_INT 9
14163: PUSH
14164: LD_INT 10
14166: PUSH
14167: LD_INT 11
14169: PUSH
14170: LD_INT 12
14172: PUSH
14173: LD_INT 13
14175: PUSH
14176: LD_INT 14
14178: PUSH
14179: LD_INT 15
14181: PUSH
14182: LD_INT 16
14184: PUSH
14185: LD_INT 17
14187: PUSH
14188: LD_INT 18
14190: PUSH
14191: LD_INT 19
14193: PUSH
14194: LD_INT 20
14196: PUSH
14197: LD_INT 21
14199: PUSH
14200: LD_INT 22
14202: PUSH
14203: LD_INT 23
14205: PUSH
14206: LD_INT 24
14208: PUSH
14209: LD_INT 25
14211: PUSH
14212: LD_INT 26
14214: PUSH
14215: LD_INT 27
14217: PUSH
14218: LD_INT 28
14220: PUSH
14221: LD_INT 29
14223: PUSH
14224: LD_INT 30
14226: PUSH
14227: LD_INT 31
14229: PUSH
14230: LD_INT 32
14232: PUSH
14233: LD_INT 33
14235: PUSH
14236: LD_INT 34
14238: PUSH
14239: LD_INT 36
14241: PUSH
14242: EMPTY
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: LIST
14250: LIST
14251: LIST
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: LIST
14257: LIST
14258: LIST
14259: LIST
14260: LIST
14261: LIST
14262: LIST
14263: LIST
14264: LIST
14265: LIST
14266: LIST
14267: LIST
14268: LIST
14269: LIST
14270: LIST
14271: LIST
14272: LIST
14273: LIST
14274: LIST
14275: LIST
14276: LIST
14277: LIST
14278: PUSH
14279: LD_INT 101
14281: PUSH
14282: LD_INT 102
14284: PUSH
14285: LD_INT 103
14287: PUSH
14288: LD_INT 104
14290: PUSH
14291: LD_INT 105
14293: PUSH
14294: LD_INT 106
14296: PUSH
14297: LD_INT 107
14299: PUSH
14300: LD_INT 108
14302: PUSH
14303: LD_INT 109
14305: PUSH
14306: LD_INT 110
14308: PUSH
14309: LD_INT 111
14311: PUSH
14312: LD_INT 112
14314: PUSH
14315: LD_INT 113
14317: PUSH
14318: LD_INT 114
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: PUSH
14337: EMPTY
14338: LIST
14339: LIST
14340: ST_TO_ADDR
14341: GO 14716
14343: LD_INT 18
14345: DOUBLE
14346: EQUAL
14347: IFTRUE 14351
14349: GO 14487
14351: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14352: LD_ADDR_VAR 0 1
14356: PUSH
14357: LD_INT 2
14359: PUSH
14360: LD_INT 4
14362: PUSH
14363: LD_INT 5
14365: PUSH
14366: LD_INT 7
14368: PUSH
14369: LD_INT 11
14371: PUSH
14372: LD_INT 12
14374: PUSH
14375: LD_INT 15
14377: PUSH
14378: LD_INT 16
14380: PUSH
14381: LD_INT 20
14383: PUSH
14384: LD_INT 21
14386: PUSH
14387: LD_INT 22
14389: PUSH
14390: LD_INT 23
14392: PUSH
14393: LD_INT 25
14395: PUSH
14396: LD_INT 26
14398: PUSH
14399: LD_INT 30
14401: PUSH
14402: LD_INT 31
14404: PUSH
14405: LD_INT 32
14407: PUSH
14408: LD_INT 33
14410: PUSH
14411: LD_INT 34
14413: PUSH
14414: LD_INT 35
14416: PUSH
14417: LD_INT 36
14419: PUSH
14420: EMPTY
14421: LIST
14422: LIST
14423: LIST
14424: LIST
14425: LIST
14426: LIST
14427: LIST
14428: LIST
14429: LIST
14430: LIST
14431: LIST
14432: LIST
14433: LIST
14434: LIST
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: LIST
14440: LIST
14441: LIST
14442: PUSH
14443: LD_INT 101
14445: PUSH
14446: LD_INT 102
14448: PUSH
14449: LD_INT 103
14451: PUSH
14452: LD_INT 106
14454: PUSH
14455: LD_INT 108
14457: PUSH
14458: LD_INT 112
14460: PUSH
14461: LD_INT 113
14463: PUSH
14464: LD_INT 114
14466: PUSH
14467: LD_INT 115
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: LIST
14476: LIST
14477: LIST
14478: LIST
14479: LIST
14480: PUSH
14481: EMPTY
14482: LIST
14483: LIST
14484: ST_TO_ADDR
14485: GO 14716
14487: LD_INT 19
14489: DOUBLE
14490: EQUAL
14491: IFTRUE 14495
14493: GO 14715
14495: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14496: LD_ADDR_VAR 0 1
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: LD_INT 2
14506: PUSH
14507: LD_INT 3
14509: PUSH
14510: LD_INT 4
14512: PUSH
14513: LD_INT 5
14515: PUSH
14516: LD_INT 6
14518: PUSH
14519: LD_INT 7
14521: PUSH
14522: LD_INT 8
14524: PUSH
14525: LD_INT 9
14527: PUSH
14528: LD_INT 10
14530: PUSH
14531: LD_INT 11
14533: PUSH
14534: LD_INT 12
14536: PUSH
14537: LD_INT 13
14539: PUSH
14540: LD_INT 14
14542: PUSH
14543: LD_INT 15
14545: PUSH
14546: LD_INT 16
14548: PUSH
14549: LD_INT 17
14551: PUSH
14552: LD_INT 18
14554: PUSH
14555: LD_INT 19
14557: PUSH
14558: LD_INT 20
14560: PUSH
14561: LD_INT 21
14563: PUSH
14564: LD_INT 22
14566: PUSH
14567: LD_INT 23
14569: PUSH
14570: LD_INT 24
14572: PUSH
14573: LD_INT 25
14575: PUSH
14576: LD_INT 26
14578: PUSH
14579: LD_INT 27
14581: PUSH
14582: LD_INT 28
14584: PUSH
14585: LD_INT 29
14587: PUSH
14588: LD_INT 30
14590: PUSH
14591: LD_INT 31
14593: PUSH
14594: LD_INT 32
14596: PUSH
14597: LD_INT 33
14599: PUSH
14600: LD_INT 34
14602: PUSH
14603: LD_INT 35
14605: PUSH
14606: LD_INT 36
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: LIST
14617: LIST
14618: LIST
14619: LIST
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: LIST
14628: LIST
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: LIST
14636: LIST
14637: LIST
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: LIST
14643: LIST
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 101
14649: PUSH
14650: LD_INT 102
14652: PUSH
14653: LD_INT 103
14655: PUSH
14656: LD_INT 104
14658: PUSH
14659: LD_INT 105
14661: PUSH
14662: LD_INT 106
14664: PUSH
14665: LD_INT 107
14667: PUSH
14668: LD_INT 108
14670: PUSH
14671: LD_INT 109
14673: PUSH
14674: LD_INT 110
14676: PUSH
14677: LD_INT 111
14679: PUSH
14680: LD_INT 112
14682: PUSH
14683: LD_INT 113
14685: PUSH
14686: LD_INT 114
14688: PUSH
14689: LD_INT 115
14691: PUSH
14692: EMPTY
14693: LIST
14694: LIST
14695: LIST
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: LIST
14706: LIST
14707: LIST
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: ST_TO_ADDR
14713: GO 14716
14715: POP
// end else
14716: GO 14935
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
14718: LD_ADDR_VAR 0 1
14722: PUSH
14723: LD_INT 1
14725: PUSH
14726: LD_INT 2
14728: PUSH
14729: LD_INT 3
14731: PUSH
14732: LD_INT 4
14734: PUSH
14735: LD_INT 5
14737: PUSH
14738: LD_INT 6
14740: PUSH
14741: LD_INT 7
14743: PUSH
14744: LD_INT 8
14746: PUSH
14747: LD_INT 9
14749: PUSH
14750: LD_INT 10
14752: PUSH
14753: LD_INT 11
14755: PUSH
14756: LD_INT 12
14758: PUSH
14759: LD_INT 13
14761: PUSH
14762: LD_INT 14
14764: PUSH
14765: LD_INT 15
14767: PUSH
14768: LD_INT 16
14770: PUSH
14771: LD_INT 17
14773: PUSH
14774: LD_INT 18
14776: PUSH
14777: LD_INT 19
14779: PUSH
14780: LD_INT 20
14782: PUSH
14783: LD_INT 21
14785: PUSH
14786: LD_INT 22
14788: PUSH
14789: LD_INT 23
14791: PUSH
14792: LD_INT 24
14794: PUSH
14795: LD_INT 25
14797: PUSH
14798: LD_INT 26
14800: PUSH
14801: LD_INT 27
14803: PUSH
14804: LD_INT 28
14806: PUSH
14807: LD_INT 29
14809: PUSH
14810: LD_INT 30
14812: PUSH
14813: LD_INT 31
14815: PUSH
14816: LD_INT 32
14818: PUSH
14819: LD_INT 33
14821: PUSH
14822: LD_INT 34
14824: PUSH
14825: LD_INT 35
14827: PUSH
14828: LD_INT 36
14830: PUSH
14831: EMPTY
14832: LIST
14833: LIST
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: LIST
14855: LIST
14856: LIST
14857: LIST
14858: LIST
14859: LIST
14860: LIST
14861: LIST
14862: LIST
14863: LIST
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: PUSH
14869: LD_INT 101
14871: PUSH
14872: LD_INT 102
14874: PUSH
14875: LD_INT 103
14877: PUSH
14878: LD_INT 104
14880: PUSH
14881: LD_INT 105
14883: PUSH
14884: LD_INT 106
14886: PUSH
14887: LD_INT 107
14889: PUSH
14890: LD_INT 108
14892: PUSH
14893: LD_INT 109
14895: PUSH
14896: LD_INT 110
14898: PUSH
14899: LD_INT 111
14901: PUSH
14902: LD_INT 112
14904: PUSH
14905: LD_INT 113
14907: PUSH
14908: LD_INT 114
14910: PUSH
14911: LD_INT 115
14913: PUSH
14914: EMPTY
14915: LIST
14916: LIST
14917: LIST
14918: LIST
14919: LIST
14920: LIST
14921: LIST
14922: LIST
14923: LIST
14924: LIST
14925: LIST
14926: LIST
14927: LIST
14928: LIST
14929: LIST
14930: PUSH
14931: EMPTY
14932: LIST
14933: LIST
14934: ST_TO_ADDR
// if result then
14935: LD_VAR 0 1
14939: IFFALSE 15228
// begin normal :=  ;
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_STRING 
14948: ST_TO_ADDR
// hardcore :=  ;
14949: LD_ADDR_VAR 0 4
14953: PUSH
14954: LD_STRING 
14956: ST_TO_ADDR
// for i = 1 to normalCounter do
14957: LD_ADDR_VAR 0 5
14961: PUSH
14962: DOUBLE
14963: LD_INT 1
14965: DEC
14966: ST_TO_ADDR
14967: LD_EXP 44
14971: PUSH
14972: FOR_TO
14973: IFFALSE 15074
// begin tmp := 0 ;
14975: LD_ADDR_VAR 0 2
14979: PUSH
14980: LD_STRING 0
14982: ST_TO_ADDR
// if result [ 1 ] then
14983: LD_VAR 0 1
14987: PUSH
14988: LD_INT 1
14990: ARRAY
14991: IFFALSE 15056
// if result [ 1 ] [ 1 ] = i then
14993: LD_VAR 0 1
14997: PUSH
14998: LD_INT 1
15000: ARRAY
15001: PUSH
15002: LD_INT 1
15004: ARRAY
15005: PUSH
15006: LD_VAR 0 5
15010: EQUAL
15011: IFFALSE 15056
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
15013: LD_ADDR_VAR 0 1
15017: PUSH
15018: LD_VAR 0 1
15022: PPUSH
15023: LD_INT 1
15025: PPUSH
15026: LD_VAR 0 1
15030: PUSH
15031: LD_INT 1
15033: ARRAY
15034: PPUSH
15035: LD_INT 1
15037: PPUSH
15038: CALL_OW 3
15042: PPUSH
15043: CALL_OW 1
15047: ST_TO_ADDR
// tmp := 1 ;
15048: LD_ADDR_VAR 0 2
15052: PUSH
15053: LD_STRING 1
15055: ST_TO_ADDR
// end ; normal := normal & tmp ;
15056: LD_ADDR_VAR 0 3
15060: PUSH
15061: LD_VAR 0 3
15065: PUSH
15066: LD_VAR 0 2
15070: STR
15071: ST_TO_ADDR
// end ;
15072: GO 14972
15074: POP
15075: POP
// for i = 1 to hardcoreCounter do
15076: LD_ADDR_VAR 0 5
15080: PUSH
15081: DOUBLE
15082: LD_INT 1
15084: DEC
15085: ST_TO_ADDR
15086: LD_EXP 45
15090: PUSH
15091: FOR_TO
15092: IFFALSE 15197
// begin tmp := 0 ;
15094: LD_ADDR_VAR 0 2
15098: PUSH
15099: LD_STRING 0
15101: ST_TO_ADDR
// if result [ 2 ] then
15102: LD_VAR 0 1
15106: PUSH
15107: LD_INT 2
15109: ARRAY
15110: IFFALSE 15179
// if result [ 2 ] [ 1 ] = 100 + i then
15112: LD_VAR 0 1
15116: PUSH
15117: LD_INT 2
15119: ARRAY
15120: PUSH
15121: LD_INT 1
15123: ARRAY
15124: PUSH
15125: LD_INT 100
15127: PUSH
15128: LD_VAR 0 5
15132: PLUS
15133: EQUAL
15134: IFFALSE 15179
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
15136: LD_ADDR_VAR 0 1
15140: PUSH
15141: LD_VAR 0 1
15145: PPUSH
15146: LD_INT 2
15148: PPUSH
15149: LD_VAR 0 1
15153: PUSH
15154: LD_INT 2
15156: ARRAY
15157: PPUSH
15158: LD_INT 1
15160: PPUSH
15161: CALL_OW 3
15165: PPUSH
15166: CALL_OW 1
15170: ST_TO_ADDR
// tmp := 1 ;
15171: LD_ADDR_VAR 0 2
15175: PUSH
15176: LD_STRING 1
15178: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
15179: LD_ADDR_VAR 0 4
15183: PUSH
15184: LD_VAR 0 4
15188: PUSH
15189: LD_VAR 0 2
15193: STR
15194: ST_TO_ADDR
// end ;
15195: GO 15091
15197: POP
15198: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
15199: LD_STRING getStreamItemsFromMission("
15201: PUSH
15202: LD_VAR 0 3
15206: STR
15207: PUSH
15208: LD_STRING ","
15210: STR
15211: PUSH
15212: LD_VAR 0 4
15216: STR
15217: PUSH
15218: LD_STRING ")
15220: STR
15221: PPUSH
15222: CALL_OW 559
// end else
15226: GO 15235
// ToLua ( getStreamItemsFromMission("","") ) ;
15228: LD_STRING getStreamItemsFromMission("","")
15230: PPUSH
15231: CALL_OW 559
// end ;
15235: LD_VAR 0 1
15239: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
15240: LD_VAR 0 2
15244: PUSH
15245: LD_INT 100
15247: EQUAL
15248: IFFALSE 16197
// begin if not StreamModeActive then
15250: LD_EXP 43
15254: NOT
15255: IFFALSE 15265
// StreamModeActive := true ;
15257: LD_ADDR_EXP 43
15261: PUSH
15262: LD_INT 1
15264: ST_TO_ADDR
// if p3 = 0 then
15265: LD_VAR 0 3
15269: PUSH
15270: LD_INT 0
15272: EQUAL
15273: IFFALSE 15279
// InitStreamMode ;
15275: CALL 11318 0 0
// if p3 = 1 then
15279: LD_VAR 0 3
15283: PUSH
15284: LD_INT 1
15286: EQUAL
15287: IFFALSE 15297
// sRocket := true ;
15289: LD_ADDR_EXP 48
15293: PUSH
15294: LD_INT 1
15296: ST_TO_ADDR
// if p3 = 2 then
15297: LD_VAR 0 3
15301: PUSH
15302: LD_INT 2
15304: EQUAL
15305: IFFALSE 15315
// sSpeed := true ;
15307: LD_ADDR_EXP 47
15311: PUSH
15312: LD_INT 1
15314: ST_TO_ADDR
// if p3 = 3 then
15315: LD_VAR 0 3
15319: PUSH
15320: LD_INT 3
15322: EQUAL
15323: IFFALSE 15333
// sEngine := true ;
15325: LD_ADDR_EXP 49
15329: PUSH
15330: LD_INT 1
15332: ST_TO_ADDR
// if p3 = 4 then
15333: LD_VAR 0 3
15337: PUSH
15338: LD_INT 4
15340: EQUAL
15341: IFFALSE 15351
// sSpec := true ;
15343: LD_ADDR_EXP 46
15347: PUSH
15348: LD_INT 1
15350: ST_TO_ADDR
// if p3 = 5 then
15351: LD_VAR 0 3
15355: PUSH
15356: LD_INT 5
15358: EQUAL
15359: IFFALSE 15369
// sLevel := true ;
15361: LD_ADDR_EXP 50
15365: PUSH
15366: LD_INT 1
15368: ST_TO_ADDR
// if p3 = 6 then
15369: LD_VAR 0 3
15373: PUSH
15374: LD_INT 6
15376: EQUAL
15377: IFFALSE 15387
// sArmoury := true ;
15379: LD_ADDR_EXP 51
15383: PUSH
15384: LD_INT 1
15386: ST_TO_ADDR
// if p3 = 7 then
15387: LD_VAR 0 3
15391: PUSH
15392: LD_INT 7
15394: EQUAL
15395: IFFALSE 15405
// sRadar := true ;
15397: LD_ADDR_EXP 52
15401: PUSH
15402: LD_INT 1
15404: ST_TO_ADDR
// if p3 = 8 then
15405: LD_VAR 0 3
15409: PUSH
15410: LD_INT 8
15412: EQUAL
15413: IFFALSE 15423
// sBunker := true ;
15415: LD_ADDR_EXP 53
15419: PUSH
15420: LD_INT 1
15422: ST_TO_ADDR
// if p3 = 9 then
15423: LD_VAR 0 3
15427: PUSH
15428: LD_INT 9
15430: EQUAL
15431: IFFALSE 15441
// sHack := true ;
15433: LD_ADDR_EXP 54
15437: PUSH
15438: LD_INT 1
15440: ST_TO_ADDR
// if p3 = 10 then
15441: LD_VAR 0 3
15445: PUSH
15446: LD_INT 10
15448: EQUAL
15449: IFFALSE 15459
// sFire := true ;
15451: LD_ADDR_EXP 55
15455: PUSH
15456: LD_INT 1
15458: ST_TO_ADDR
// if p3 = 11 then
15459: LD_VAR 0 3
15463: PUSH
15464: LD_INT 11
15466: EQUAL
15467: IFFALSE 15477
// sRefresh := true ;
15469: LD_ADDR_EXP 56
15473: PUSH
15474: LD_INT 1
15476: ST_TO_ADDR
// if p3 = 12 then
15477: LD_VAR 0 3
15481: PUSH
15482: LD_INT 12
15484: EQUAL
15485: IFFALSE 15495
// sExp := true ;
15487: LD_ADDR_EXP 57
15491: PUSH
15492: LD_INT 1
15494: ST_TO_ADDR
// if p3 = 13 then
15495: LD_VAR 0 3
15499: PUSH
15500: LD_INT 13
15502: EQUAL
15503: IFFALSE 15513
// sDepot := true ;
15505: LD_ADDR_EXP 58
15509: PUSH
15510: LD_INT 1
15512: ST_TO_ADDR
// if p3 = 14 then
15513: LD_VAR 0 3
15517: PUSH
15518: LD_INT 14
15520: EQUAL
15521: IFFALSE 15531
// sFlag := true ;
15523: LD_ADDR_EXP 59
15527: PUSH
15528: LD_INT 1
15530: ST_TO_ADDR
// if p3 = 15 then
15531: LD_VAR 0 3
15535: PUSH
15536: LD_INT 15
15538: EQUAL
15539: IFFALSE 15549
// sKamikadze := true ;
15541: LD_ADDR_EXP 67
15545: PUSH
15546: LD_INT 1
15548: ST_TO_ADDR
// if p3 = 16 then
15549: LD_VAR 0 3
15553: PUSH
15554: LD_INT 16
15556: EQUAL
15557: IFFALSE 15567
// sTroll := true ;
15559: LD_ADDR_EXP 68
15563: PUSH
15564: LD_INT 1
15566: ST_TO_ADDR
// if p3 = 17 then
15567: LD_VAR 0 3
15571: PUSH
15572: LD_INT 17
15574: EQUAL
15575: IFFALSE 15585
// sSlow := true ;
15577: LD_ADDR_EXP 69
15581: PUSH
15582: LD_INT 1
15584: ST_TO_ADDR
// if p3 = 18 then
15585: LD_VAR 0 3
15589: PUSH
15590: LD_INT 18
15592: EQUAL
15593: IFFALSE 15603
// sLack := true ;
15595: LD_ADDR_EXP 70
15599: PUSH
15600: LD_INT 1
15602: ST_TO_ADDR
// if p3 = 19 then
15603: LD_VAR 0 3
15607: PUSH
15608: LD_INT 19
15610: EQUAL
15611: IFFALSE 15621
// sTank := true ;
15613: LD_ADDR_EXP 72
15617: PUSH
15618: LD_INT 1
15620: ST_TO_ADDR
// if p3 = 20 then
15621: LD_VAR 0 3
15625: PUSH
15626: LD_INT 20
15628: EQUAL
15629: IFFALSE 15639
// sRemote := true ;
15631: LD_ADDR_EXP 73
15635: PUSH
15636: LD_INT 1
15638: ST_TO_ADDR
// if p3 = 21 then
15639: LD_VAR 0 3
15643: PUSH
15644: LD_INT 21
15646: EQUAL
15647: IFFALSE 15657
// sPowell := true ;
15649: LD_ADDR_EXP 74
15653: PUSH
15654: LD_INT 1
15656: ST_TO_ADDR
// if p3 = 22 then
15657: LD_VAR 0 3
15661: PUSH
15662: LD_INT 22
15664: EQUAL
15665: IFFALSE 15675
// sTeleport := true ;
15667: LD_ADDR_EXP 77
15671: PUSH
15672: LD_INT 1
15674: ST_TO_ADDR
// if p3 = 23 then
15675: LD_VAR 0 3
15679: PUSH
15680: LD_INT 23
15682: EQUAL
15683: IFFALSE 15693
// sOilTower := true ;
15685: LD_ADDR_EXP 79
15689: PUSH
15690: LD_INT 1
15692: ST_TO_ADDR
// if p3 = 24 then
15693: LD_VAR 0 3
15697: PUSH
15698: LD_INT 24
15700: EQUAL
15701: IFFALSE 15711
// sShovel := true ;
15703: LD_ADDR_EXP 80
15707: PUSH
15708: LD_INT 1
15710: ST_TO_ADDR
// if p3 = 25 then
15711: LD_VAR 0 3
15715: PUSH
15716: LD_INT 25
15718: EQUAL
15719: IFFALSE 15729
// sSheik := true ;
15721: LD_ADDR_EXP 81
15725: PUSH
15726: LD_INT 1
15728: ST_TO_ADDR
// if p3 = 26 then
15729: LD_VAR 0 3
15733: PUSH
15734: LD_INT 26
15736: EQUAL
15737: IFFALSE 15747
// sEarthquake := true ;
15739: LD_ADDR_EXP 83
15743: PUSH
15744: LD_INT 1
15746: ST_TO_ADDR
// if p3 = 27 then
15747: LD_VAR 0 3
15751: PUSH
15752: LD_INT 27
15754: EQUAL
15755: IFFALSE 15765
// sAI := true ;
15757: LD_ADDR_EXP 84
15761: PUSH
15762: LD_INT 1
15764: ST_TO_ADDR
// if p3 = 28 then
15765: LD_VAR 0 3
15769: PUSH
15770: LD_INT 28
15772: EQUAL
15773: IFFALSE 15783
// sCargo := true ;
15775: LD_ADDR_EXP 87
15779: PUSH
15780: LD_INT 1
15782: ST_TO_ADDR
// if p3 = 29 then
15783: LD_VAR 0 3
15787: PUSH
15788: LD_INT 29
15790: EQUAL
15791: IFFALSE 15801
// sDLaser := true ;
15793: LD_ADDR_EXP 88
15797: PUSH
15798: LD_INT 1
15800: ST_TO_ADDR
// if p3 = 30 then
15801: LD_VAR 0 3
15805: PUSH
15806: LD_INT 30
15808: EQUAL
15809: IFFALSE 15819
// sExchange := true ;
15811: LD_ADDR_EXP 89
15815: PUSH
15816: LD_INT 1
15818: ST_TO_ADDR
// if p3 = 31 then
15819: LD_VAR 0 3
15823: PUSH
15824: LD_INT 31
15826: EQUAL
15827: IFFALSE 15837
// sFac := true ;
15829: LD_ADDR_EXP 90
15833: PUSH
15834: LD_INT 1
15836: ST_TO_ADDR
// if p3 = 32 then
15837: LD_VAR 0 3
15841: PUSH
15842: LD_INT 32
15844: EQUAL
15845: IFFALSE 15855
// sPower := true ;
15847: LD_ADDR_EXP 91
15851: PUSH
15852: LD_INT 1
15854: ST_TO_ADDR
// if p3 = 33 then
15855: LD_VAR 0 3
15859: PUSH
15860: LD_INT 33
15862: EQUAL
15863: IFFALSE 15873
// sRandom := true ;
15865: LD_ADDR_EXP 92
15869: PUSH
15870: LD_INT 1
15872: ST_TO_ADDR
// if p3 = 34 then
15873: LD_VAR 0 3
15877: PUSH
15878: LD_INT 34
15880: EQUAL
15881: IFFALSE 15891
// sShield := true ;
15883: LD_ADDR_EXP 93
15887: PUSH
15888: LD_INT 1
15890: ST_TO_ADDR
// if p3 = 35 then
15891: LD_VAR 0 3
15895: PUSH
15896: LD_INT 35
15898: EQUAL
15899: IFFALSE 15909
// sTime := true ;
15901: LD_ADDR_EXP 94
15905: PUSH
15906: LD_INT 1
15908: ST_TO_ADDR
// if p3 = 36 then
15909: LD_VAR 0 3
15913: PUSH
15914: LD_INT 36
15916: EQUAL
15917: IFFALSE 15927
// sTools := true ;
15919: LD_ADDR_EXP 95
15923: PUSH
15924: LD_INT 1
15926: ST_TO_ADDR
// if p3 = 101 then
15927: LD_VAR 0 3
15931: PUSH
15932: LD_INT 101
15934: EQUAL
15935: IFFALSE 15945
// sSold := true ;
15937: LD_ADDR_EXP 60
15941: PUSH
15942: LD_INT 1
15944: ST_TO_ADDR
// if p3 = 102 then
15945: LD_VAR 0 3
15949: PUSH
15950: LD_INT 102
15952: EQUAL
15953: IFFALSE 15963
// sDiff := true ;
15955: LD_ADDR_EXP 61
15959: PUSH
15960: LD_INT 1
15962: ST_TO_ADDR
// if p3 = 103 then
15963: LD_VAR 0 3
15967: PUSH
15968: LD_INT 103
15970: EQUAL
15971: IFFALSE 15981
// sFog := true ;
15973: LD_ADDR_EXP 64
15977: PUSH
15978: LD_INT 1
15980: ST_TO_ADDR
// if p3 = 104 then
15981: LD_VAR 0 3
15985: PUSH
15986: LD_INT 104
15988: EQUAL
15989: IFFALSE 15999
// sReset := true ;
15991: LD_ADDR_EXP 65
15995: PUSH
15996: LD_INT 1
15998: ST_TO_ADDR
// if p3 = 105 then
15999: LD_VAR 0 3
16003: PUSH
16004: LD_INT 105
16006: EQUAL
16007: IFFALSE 16017
// sSun := true ;
16009: LD_ADDR_EXP 66
16013: PUSH
16014: LD_INT 1
16016: ST_TO_ADDR
// if p3 = 106 then
16017: LD_VAR 0 3
16021: PUSH
16022: LD_INT 106
16024: EQUAL
16025: IFFALSE 16035
// sTiger := true ;
16027: LD_ADDR_EXP 62
16031: PUSH
16032: LD_INT 1
16034: ST_TO_ADDR
// if p3 = 107 then
16035: LD_VAR 0 3
16039: PUSH
16040: LD_INT 107
16042: EQUAL
16043: IFFALSE 16053
// sBomb := true ;
16045: LD_ADDR_EXP 63
16049: PUSH
16050: LD_INT 1
16052: ST_TO_ADDR
// if p3 = 108 then
16053: LD_VAR 0 3
16057: PUSH
16058: LD_INT 108
16060: EQUAL
16061: IFFALSE 16071
// sWound := true ;
16063: LD_ADDR_EXP 71
16067: PUSH
16068: LD_INT 1
16070: ST_TO_ADDR
// if p3 = 109 then
16071: LD_VAR 0 3
16075: PUSH
16076: LD_INT 109
16078: EQUAL
16079: IFFALSE 16089
// sBetray := true ;
16081: LD_ADDR_EXP 75
16085: PUSH
16086: LD_INT 1
16088: ST_TO_ADDR
// if p3 = 110 then
16089: LD_VAR 0 3
16093: PUSH
16094: LD_INT 110
16096: EQUAL
16097: IFFALSE 16107
// sContamin := true ;
16099: LD_ADDR_EXP 76
16103: PUSH
16104: LD_INT 1
16106: ST_TO_ADDR
// if p3 = 111 then
16107: LD_VAR 0 3
16111: PUSH
16112: LD_INT 111
16114: EQUAL
16115: IFFALSE 16125
// sOil := true ;
16117: LD_ADDR_EXP 78
16121: PUSH
16122: LD_INT 1
16124: ST_TO_ADDR
// if p3 = 112 then
16125: LD_VAR 0 3
16129: PUSH
16130: LD_INT 112
16132: EQUAL
16133: IFFALSE 16143
// sStu := true ;
16135: LD_ADDR_EXP 82
16139: PUSH
16140: LD_INT 1
16142: ST_TO_ADDR
// if p3 = 113 then
16143: LD_VAR 0 3
16147: PUSH
16148: LD_INT 113
16150: EQUAL
16151: IFFALSE 16161
// sBazooka := true ;
16153: LD_ADDR_EXP 85
16157: PUSH
16158: LD_INT 1
16160: ST_TO_ADDR
// if p3 = 114 then
16161: LD_VAR 0 3
16165: PUSH
16166: LD_INT 114
16168: EQUAL
16169: IFFALSE 16179
// sMortar := true ;
16171: LD_ADDR_EXP 86
16175: PUSH
16176: LD_INT 1
16178: ST_TO_ADDR
// if p3 = 115 then
16179: LD_VAR 0 3
16183: PUSH
16184: LD_INT 115
16186: EQUAL
16187: IFFALSE 16197
// sRanger := true ;
16189: LD_ADDR_EXP 96
16193: PUSH
16194: LD_INT 1
16196: ST_TO_ADDR
// end ; end ;
16197: PPOPN 6
16199: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
16200: LD_EXP 43
16204: PUSH
16205: LD_EXP 48
16209: AND
16210: IFFALSE 16334
16212: GO 16214
16214: DISABLE
16215: LD_INT 0
16217: PPUSH
16218: PPUSH
// begin enable ;
16219: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
16220: LD_ADDR_VAR 0 2
16224: PUSH
16225: LD_INT 22
16227: PUSH
16228: LD_OWVAR 2
16232: PUSH
16233: EMPTY
16234: LIST
16235: LIST
16236: PUSH
16237: LD_INT 2
16239: PUSH
16240: LD_INT 34
16242: PUSH
16243: LD_INT 7
16245: PUSH
16246: EMPTY
16247: LIST
16248: LIST
16249: PUSH
16250: LD_INT 34
16252: PUSH
16253: LD_INT 45
16255: PUSH
16256: EMPTY
16257: LIST
16258: LIST
16259: PUSH
16260: LD_INT 34
16262: PUSH
16263: LD_INT 28
16265: PUSH
16266: EMPTY
16267: LIST
16268: LIST
16269: PUSH
16270: LD_INT 34
16272: PUSH
16273: LD_INT 47
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: LIST
16284: LIST
16285: LIST
16286: PUSH
16287: EMPTY
16288: LIST
16289: LIST
16290: PPUSH
16291: CALL_OW 69
16295: ST_TO_ADDR
// if not tmp then
16296: LD_VAR 0 2
16300: NOT
16301: IFFALSE 16305
// exit ;
16303: GO 16334
// for i in tmp do
16305: LD_ADDR_VAR 0 1
16309: PUSH
16310: LD_VAR 0 2
16314: PUSH
16315: FOR_IN
16316: IFFALSE 16332
// begin SetLives ( i , 0 ) ;
16318: LD_VAR 0 1
16322: PPUSH
16323: LD_INT 0
16325: PPUSH
16326: CALL_OW 234
// end ;
16330: GO 16315
16332: POP
16333: POP
// end ;
16334: PPOPN 2
16336: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
16337: LD_EXP 43
16341: PUSH
16342: LD_EXP 49
16346: AND
16347: IFFALSE 16431
16349: GO 16351
16351: DISABLE
16352: LD_INT 0
16354: PPUSH
16355: PPUSH
// begin enable ;
16356: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
16357: LD_ADDR_VAR 0 2
16361: PUSH
16362: LD_INT 22
16364: PUSH
16365: LD_OWVAR 2
16369: PUSH
16370: EMPTY
16371: LIST
16372: LIST
16373: PUSH
16374: LD_INT 32
16376: PUSH
16377: LD_INT 3
16379: PUSH
16380: EMPTY
16381: LIST
16382: LIST
16383: PUSH
16384: EMPTY
16385: LIST
16386: LIST
16387: PPUSH
16388: CALL_OW 69
16392: ST_TO_ADDR
// if not tmp then
16393: LD_VAR 0 2
16397: NOT
16398: IFFALSE 16402
// exit ;
16400: GO 16431
// for i in tmp do
16402: LD_ADDR_VAR 0 1
16406: PUSH
16407: LD_VAR 0 2
16411: PUSH
16412: FOR_IN
16413: IFFALSE 16429
// begin SetLives ( i , 0 ) ;
16415: LD_VAR 0 1
16419: PPUSH
16420: LD_INT 0
16422: PPUSH
16423: CALL_OW 234
// end ;
16427: GO 16412
16429: POP
16430: POP
// end ;
16431: PPOPN 2
16433: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
16434: LD_EXP 43
16438: PUSH
16439: LD_EXP 46
16443: AND
16444: IFFALSE 16537
16446: GO 16448
16448: DISABLE
16449: LD_INT 0
16451: PPUSH
// begin enable ;
16452: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
16453: LD_ADDR_VAR 0 1
16457: PUSH
16458: LD_INT 22
16460: PUSH
16461: LD_OWVAR 2
16465: PUSH
16466: EMPTY
16467: LIST
16468: LIST
16469: PUSH
16470: LD_INT 2
16472: PUSH
16473: LD_INT 25
16475: PUSH
16476: LD_INT 5
16478: PUSH
16479: EMPTY
16480: LIST
16481: LIST
16482: PUSH
16483: LD_INT 25
16485: PUSH
16486: LD_INT 9
16488: PUSH
16489: EMPTY
16490: LIST
16491: LIST
16492: PUSH
16493: LD_INT 25
16495: PUSH
16496: LD_INT 8
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PUSH
16503: EMPTY
16504: LIST
16505: LIST
16506: LIST
16507: LIST
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: PPUSH
16513: CALL_OW 69
16517: PUSH
16518: FOR_IN
16519: IFFALSE 16535
// begin SetClass ( i , 1 ) ;
16521: LD_VAR 0 1
16525: PPUSH
16526: LD_INT 1
16528: PPUSH
16529: CALL_OW 336
// end ;
16533: GO 16518
16535: POP
16536: POP
// end ;
16537: PPOPN 1
16539: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16540: LD_EXP 43
16544: PUSH
16545: LD_EXP 47
16549: AND
16550: PUSH
16551: LD_OWVAR 65
16555: PUSH
16556: LD_INT 7
16558: LESS
16559: AND
16560: IFFALSE 16574
16562: GO 16564
16564: DISABLE
// begin enable ;
16565: ENABLE
// game_speed := 7 ;
16566: LD_ADDR_OWVAR 65
16570: PUSH
16571: LD_INT 7
16573: ST_TO_ADDR
// end ;
16574: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16575: LD_EXP 43
16579: PUSH
16580: LD_EXP 50
16584: AND
16585: IFFALSE 16787
16587: GO 16589
16589: DISABLE
16590: LD_INT 0
16592: PPUSH
16593: PPUSH
16594: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16595: LD_ADDR_VAR 0 3
16599: PUSH
16600: LD_INT 81
16602: PUSH
16603: LD_OWVAR 2
16607: PUSH
16608: EMPTY
16609: LIST
16610: LIST
16611: PUSH
16612: LD_INT 21
16614: PUSH
16615: LD_INT 1
16617: PUSH
16618: EMPTY
16619: LIST
16620: LIST
16621: PUSH
16622: EMPTY
16623: LIST
16624: LIST
16625: PPUSH
16626: CALL_OW 69
16630: ST_TO_ADDR
// if not tmp then
16631: LD_VAR 0 3
16635: NOT
16636: IFFALSE 16640
// exit ;
16638: GO 16787
// if tmp > 5 then
16640: LD_VAR 0 3
16644: PUSH
16645: LD_INT 5
16647: GREATER
16648: IFFALSE 16660
// k := 5 else
16650: LD_ADDR_VAR 0 2
16654: PUSH
16655: LD_INT 5
16657: ST_TO_ADDR
16658: GO 16670
// k := tmp ;
16660: LD_ADDR_VAR 0 2
16664: PUSH
16665: LD_VAR 0 3
16669: ST_TO_ADDR
// for i := 1 to k do
16670: LD_ADDR_VAR 0 1
16674: PUSH
16675: DOUBLE
16676: LD_INT 1
16678: DEC
16679: ST_TO_ADDR
16680: LD_VAR 0 2
16684: PUSH
16685: FOR_TO
16686: IFFALSE 16785
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
16688: LD_VAR 0 3
16692: PUSH
16693: LD_VAR 0 1
16697: ARRAY
16698: PPUSH
16699: LD_VAR 0 1
16703: PUSH
16704: LD_INT 4
16706: MOD
16707: PUSH
16708: LD_INT 1
16710: PLUS
16711: PPUSH
16712: CALL_OW 259
16716: PUSH
16717: LD_INT 10
16719: LESS
16720: IFFALSE 16783
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
16722: LD_VAR 0 3
16726: PUSH
16727: LD_VAR 0 1
16731: ARRAY
16732: PPUSH
16733: LD_VAR 0 1
16737: PUSH
16738: LD_INT 4
16740: MOD
16741: PUSH
16742: LD_INT 1
16744: PLUS
16745: PPUSH
16746: LD_VAR 0 3
16750: PUSH
16751: LD_VAR 0 1
16755: ARRAY
16756: PPUSH
16757: LD_VAR 0 1
16761: PUSH
16762: LD_INT 4
16764: MOD
16765: PUSH
16766: LD_INT 1
16768: PLUS
16769: PPUSH
16770: CALL_OW 259
16774: PUSH
16775: LD_INT 1
16777: PLUS
16778: PPUSH
16779: CALL_OW 237
16783: GO 16685
16785: POP
16786: POP
// end ;
16787: PPOPN 3
16789: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16790: LD_EXP 43
16794: PUSH
16795: LD_EXP 51
16799: AND
16800: IFFALSE 16820
16802: GO 16804
16804: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16805: LD_INT 4
16807: PPUSH
16808: LD_OWVAR 2
16812: PPUSH
16813: LD_INT 0
16815: PPUSH
16816: CALL_OW 324
16820: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16821: LD_EXP 43
16825: PUSH
16826: LD_EXP 80
16830: AND
16831: IFFALSE 16851
16833: GO 16835
16835: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16836: LD_INT 19
16838: PPUSH
16839: LD_OWVAR 2
16843: PPUSH
16844: LD_INT 0
16846: PPUSH
16847: CALL_OW 324
16851: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16852: LD_EXP 43
16856: PUSH
16857: LD_EXP 52
16861: AND
16862: IFFALSE 16964
16864: GO 16866
16866: DISABLE
16867: LD_INT 0
16869: PPUSH
16870: PPUSH
// begin enable ;
16871: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16872: LD_ADDR_VAR 0 2
16876: PUSH
16877: LD_INT 22
16879: PUSH
16880: LD_OWVAR 2
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: PUSH
16889: LD_INT 2
16891: PUSH
16892: LD_INT 34
16894: PUSH
16895: LD_INT 11
16897: PUSH
16898: EMPTY
16899: LIST
16900: LIST
16901: PUSH
16902: LD_INT 34
16904: PUSH
16905: LD_INT 30
16907: PUSH
16908: EMPTY
16909: LIST
16910: LIST
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: LIST
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: PPUSH
16921: CALL_OW 69
16925: ST_TO_ADDR
// if not tmp then
16926: LD_VAR 0 2
16930: NOT
16931: IFFALSE 16935
// exit ;
16933: GO 16964
// for i in tmp do
16935: LD_ADDR_VAR 0 1
16939: PUSH
16940: LD_VAR 0 2
16944: PUSH
16945: FOR_IN
16946: IFFALSE 16962
// begin SetLives ( i , 0 ) ;
16948: LD_VAR 0 1
16952: PPUSH
16953: LD_INT 0
16955: PPUSH
16956: CALL_OW 234
// end ;
16960: GO 16945
16962: POP
16963: POP
// end ;
16964: PPOPN 2
16966: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16967: LD_EXP 43
16971: PUSH
16972: LD_EXP 53
16976: AND
16977: IFFALSE 16997
16979: GO 16981
16981: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16982: LD_INT 32
16984: PPUSH
16985: LD_OWVAR 2
16989: PPUSH
16990: LD_INT 0
16992: PPUSH
16993: CALL_OW 324
16997: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16998: LD_EXP 43
17002: PUSH
17003: LD_EXP 54
17007: AND
17008: IFFALSE 17189
17010: GO 17012
17012: DISABLE
17013: LD_INT 0
17015: PPUSH
17016: PPUSH
17017: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
17018: LD_ADDR_VAR 0 2
17022: PUSH
17023: LD_INT 22
17025: PUSH
17026: LD_OWVAR 2
17030: PUSH
17031: EMPTY
17032: LIST
17033: LIST
17034: PUSH
17035: LD_INT 33
17037: PUSH
17038: LD_INT 3
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: PPUSH
17049: CALL_OW 69
17053: ST_TO_ADDR
// if not tmp then
17054: LD_VAR 0 2
17058: NOT
17059: IFFALSE 17063
// exit ;
17061: GO 17189
// side := 0 ;
17063: LD_ADDR_VAR 0 3
17067: PUSH
17068: LD_INT 0
17070: ST_TO_ADDR
// for i := 1 to 8 do
17071: LD_ADDR_VAR 0 1
17075: PUSH
17076: DOUBLE
17077: LD_INT 1
17079: DEC
17080: ST_TO_ADDR
17081: LD_INT 8
17083: PUSH
17084: FOR_TO
17085: IFFALSE 17133
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
17087: LD_OWVAR 2
17091: PUSH
17092: LD_VAR 0 1
17096: NONEQUAL
17097: PUSH
17098: LD_OWVAR 2
17102: PPUSH
17103: LD_VAR 0 1
17107: PPUSH
17108: CALL_OW 81
17112: PUSH
17113: LD_INT 2
17115: EQUAL
17116: AND
17117: IFFALSE 17131
// begin side := i ;
17119: LD_ADDR_VAR 0 3
17123: PUSH
17124: LD_VAR 0 1
17128: ST_TO_ADDR
// break ;
17129: GO 17133
// end ;
17131: GO 17084
17133: POP
17134: POP
// if not side then
17135: LD_VAR 0 3
17139: NOT
17140: IFFALSE 17144
// exit ;
17142: GO 17189
// for i := 1 to tmp do
17144: LD_ADDR_VAR 0 1
17148: PUSH
17149: DOUBLE
17150: LD_INT 1
17152: DEC
17153: ST_TO_ADDR
17154: LD_VAR 0 2
17158: PUSH
17159: FOR_TO
17160: IFFALSE 17187
// if Prob ( 60 ) then
17162: LD_INT 60
17164: PPUSH
17165: CALL_OW 13
17169: IFFALSE 17185
// SetSide ( i , side ) ;
17171: LD_VAR 0 1
17175: PPUSH
17176: LD_VAR 0 3
17180: PPUSH
17181: CALL_OW 235
17185: GO 17159
17187: POP
17188: POP
// end ;
17189: PPOPN 3
17191: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
17192: LD_EXP 43
17196: PUSH
17197: LD_EXP 56
17201: AND
17202: IFFALSE 17321
17204: GO 17206
17206: DISABLE
17207: LD_INT 0
17209: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
17210: LD_ADDR_VAR 0 1
17214: PUSH
17215: LD_INT 22
17217: PUSH
17218: LD_OWVAR 2
17222: PUSH
17223: EMPTY
17224: LIST
17225: LIST
17226: PUSH
17227: LD_INT 21
17229: PUSH
17230: LD_INT 1
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: PUSH
17237: LD_INT 3
17239: PUSH
17240: LD_INT 23
17242: PUSH
17243: LD_INT 0
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: PUSH
17250: EMPTY
17251: LIST
17252: LIST
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: LIST
17258: PPUSH
17259: CALL_OW 69
17263: PUSH
17264: FOR_IN
17265: IFFALSE 17319
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
17267: LD_VAR 0 1
17271: PPUSH
17272: CALL_OW 257
17276: PUSH
17277: LD_INT 1
17279: PUSH
17280: LD_INT 2
17282: PUSH
17283: LD_INT 3
17285: PUSH
17286: LD_INT 4
17288: PUSH
17289: EMPTY
17290: LIST
17291: LIST
17292: LIST
17293: LIST
17294: IN
17295: IFFALSE 17317
// SetClass ( un , rand ( 1 , 4 ) ) ;
17297: LD_VAR 0 1
17301: PPUSH
17302: LD_INT 1
17304: PPUSH
17305: LD_INT 4
17307: PPUSH
17308: CALL_OW 12
17312: PPUSH
17313: CALL_OW 336
17317: GO 17264
17319: POP
17320: POP
// end ;
17321: PPOPN 1
17323: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
17324: LD_EXP 43
17328: PUSH
17329: LD_EXP 55
17333: AND
17334: IFFALSE 17413
17336: GO 17338
17338: DISABLE
17339: LD_INT 0
17341: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17342: LD_ADDR_VAR 0 1
17346: PUSH
17347: LD_INT 22
17349: PUSH
17350: LD_OWVAR 2
17354: PUSH
17355: EMPTY
17356: LIST
17357: LIST
17358: PUSH
17359: LD_INT 21
17361: PUSH
17362: LD_INT 3
17364: PUSH
17365: EMPTY
17366: LIST
17367: LIST
17368: PUSH
17369: EMPTY
17370: LIST
17371: LIST
17372: PPUSH
17373: CALL_OW 69
17377: ST_TO_ADDR
// if not tmp then
17378: LD_VAR 0 1
17382: NOT
17383: IFFALSE 17387
// exit ;
17385: GO 17413
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
17387: LD_VAR 0 1
17391: PUSH
17392: LD_INT 1
17394: PPUSH
17395: LD_VAR 0 1
17399: PPUSH
17400: CALL_OW 12
17404: ARRAY
17405: PPUSH
17406: LD_INT 100
17408: PPUSH
17409: CALL_OW 234
// end ;
17413: PPOPN 1
17415: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
17416: LD_EXP 43
17420: PUSH
17421: LD_EXP 57
17425: AND
17426: IFFALSE 17524
17428: GO 17430
17430: DISABLE
17431: LD_INT 0
17433: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17434: LD_ADDR_VAR 0 1
17438: PUSH
17439: LD_INT 22
17441: PUSH
17442: LD_OWVAR 2
17446: PUSH
17447: EMPTY
17448: LIST
17449: LIST
17450: PUSH
17451: LD_INT 21
17453: PUSH
17454: LD_INT 1
17456: PUSH
17457: EMPTY
17458: LIST
17459: LIST
17460: PUSH
17461: EMPTY
17462: LIST
17463: LIST
17464: PPUSH
17465: CALL_OW 69
17469: ST_TO_ADDR
// if not tmp then
17470: LD_VAR 0 1
17474: NOT
17475: IFFALSE 17479
// exit ;
17477: GO 17524
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
17479: LD_VAR 0 1
17483: PUSH
17484: LD_INT 1
17486: PPUSH
17487: LD_VAR 0 1
17491: PPUSH
17492: CALL_OW 12
17496: ARRAY
17497: PPUSH
17498: LD_INT 1
17500: PPUSH
17501: LD_INT 4
17503: PPUSH
17504: CALL_OW 12
17508: PPUSH
17509: LD_INT 3000
17511: PPUSH
17512: LD_INT 9000
17514: PPUSH
17515: CALL_OW 12
17519: PPUSH
17520: CALL_OW 492
// end ;
17524: PPOPN 1
17526: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17527: LD_EXP 43
17531: PUSH
17532: LD_EXP 58
17536: AND
17537: IFFALSE 17557
17539: GO 17541
17541: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17542: LD_INT 1
17544: PPUSH
17545: LD_OWVAR 2
17549: PPUSH
17550: LD_INT 0
17552: PPUSH
17553: CALL_OW 324
17557: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17558: LD_EXP 43
17562: PUSH
17563: LD_EXP 59
17567: AND
17568: IFFALSE 17651
17570: GO 17572
17572: DISABLE
17573: LD_INT 0
17575: PPUSH
17576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17577: LD_ADDR_VAR 0 2
17581: PUSH
17582: LD_INT 22
17584: PUSH
17585: LD_OWVAR 2
17589: PUSH
17590: EMPTY
17591: LIST
17592: LIST
17593: PUSH
17594: LD_INT 21
17596: PUSH
17597: LD_INT 3
17599: PUSH
17600: EMPTY
17601: LIST
17602: LIST
17603: PUSH
17604: EMPTY
17605: LIST
17606: LIST
17607: PPUSH
17608: CALL_OW 69
17612: ST_TO_ADDR
// if not tmp then
17613: LD_VAR 0 2
17617: NOT
17618: IFFALSE 17622
// exit ;
17620: GO 17651
// for i in tmp do
17622: LD_ADDR_VAR 0 1
17626: PUSH
17627: LD_VAR 0 2
17631: PUSH
17632: FOR_IN
17633: IFFALSE 17649
// SetBLevel ( i , 10 ) ;
17635: LD_VAR 0 1
17639: PPUSH
17640: LD_INT 10
17642: PPUSH
17643: CALL_OW 241
17647: GO 17632
17649: POP
17650: POP
// end ;
17651: PPOPN 2
17653: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17654: LD_EXP 43
17658: PUSH
17659: LD_EXP 60
17663: AND
17664: IFFALSE 17775
17666: GO 17668
17668: DISABLE
17669: LD_INT 0
17671: PPUSH
17672: PPUSH
17673: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17674: LD_ADDR_VAR 0 3
17678: PUSH
17679: LD_INT 22
17681: PUSH
17682: LD_OWVAR 2
17686: PUSH
17687: EMPTY
17688: LIST
17689: LIST
17690: PUSH
17691: LD_INT 25
17693: PUSH
17694: LD_INT 1
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: PUSH
17701: EMPTY
17702: LIST
17703: LIST
17704: PPUSH
17705: CALL_OW 69
17709: ST_TO_ADDR
// if not tmp then
17710: LD_VAR 0 3
17714: NOT
17715: IFFALSE 17719
// exit ;
17717: GO 17775
// un := tmp [ rand ( 1 , tmp ) ] ;
17719: LD_ADDR_VAR 0 2
17723: PUSH
17724: LD_VAR 0 3
17728: PUSH
17729: LD_INT 1
17731: PPUSH
17732: LD_VAR 0 3
17736: PPUSH
17737: CALL_OW 12
17741: ARRAY
17742: ST_TO_ADDR
// if Crawls ( un ) then
17743: LD_VAR 0 2
17747: PPUSH
17748: CALL_OW 318
17752: IFFALSE 17763
// ComWalk ( un ) ;
17754: LD_VAR 0 2
17758: PPUSH
17759: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17763: LD_VAR 0 2
17767: PPUSH
17768: LD_INT 5
17770: PPUSH
17771: CALL_OW 336
// end ;
17775: PPOPN 3
17777: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17778: LD_EXP 43
17782: PUSH
17783: LD_EXP 61
17787: AND
17788: PUSH
17789: LD_OWVAR 67
17793: PUSH
17794: LD_INT 3
17796: LESS
17797: AND
17798: IFFALSE 17817
17800: GO 17802
17802: DISABLE
// Difficulty := Difficulty + 1 ;
17803: LD_ADDR_OWVAR 67
17807: PUSH
17808: LD_OWVAR 67
17812: PUSH
17813: LD_INT 1
17815: PLUS
17816: ST_TO_ADDR
17817: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17818: LD_EXP 43
17822: PUSH
17823: LD_EXP 62
17827: AND
17828: IFFALSE 17931
17830: GO 17832
17832: DISABLE
17833: LD_INT 0
17835: PPUSH
// begin for i := 1 to 5 do
17836: LD_ADDR_VAR 0 1
17840: PUSH
17841: DOUBLE
17842: LD_INT 1
17844: DEC
17845: ST_TO_ADDR
17846: LD_INT 5
17848: PUSH
17849: FOR_TO
17850: IFFALSE 17929
// begin uc_nation := nation_nature ;
17852: LD_ADDR_OWVAR 21
17856: PUSH
17857: LD_INT 0
17859: ST_TO_ADDR
// uc_side := 0 ;
17860: LD_ADDR_OWVAR 20
17864: PUSH
17865: LD_INT 0
17867: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17868: LD_ADDR_OWVAR 29
17872: PUSH
17873: LD_INT 12
17875: PUSH
17876: LD_INT 12
17878: PUSH
17879: EMPTY
17880: LIST
17881: LIST
17882: ST_TO_ADDR
// hc_agressivity := 20 ;
17883: LD_ADDR_OWVAR 35
17887: PUSH
17888: LD_INT 20
17890: ST_TO_ADDR
// hc_class := class_tiger ;
17891: LD_ADDR_OWVAR 28
17895: PUSH
17896: LD_INT 14
17898: ST_TO_ADDR
// hc_gallery :=  ;
17899: LD_ADDR_OWVAR 33
17903: PUSH
17904: LD_STRING 
17906: ST_TO_ADDR
// hc_name :=  ;
17907: LD_ADDR_OWVAR 26
17911: PUSH
17912: LD_STRING 
17914: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17915: CALL_OW 44
17919: PPUSH
17920: LD_INT 0
17922: PPUSH
17923: CALL_OW 51
// end ;
17927: GO 17849
17929: POP
17930: POP
// end ;
17931: PPOPN 1
17933: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17934: LD_EXP 43
17938: PUSH
17939: LD_EXP 63
17943: AND
17944: IFFALSE 17953
17946: GO 17948
17948: DISABLE
// StreamSibBomb ;
17949: CALL 17954 0 0
17953: END
// export function StreamSibBomb ; var i , x , y ; begin
17954: LD_INT 0
17956: PPUSH
17957: PPUSH
17958: PPUSH
17959: PPUSH
// result := false ;
17960: LD_ADDR_VAR 0 1
17964: PUSH
17965: LD_INT 0
17967: ST_TO_ADDR
// for i := 1 to 16 do
17968: LD_ADDR_VAR 0 2
17972: PUSH
17973: DOUBLE
17974: LD_INT 1
17976: DEC
17977: ST_TO_ADDR
17978: LD_INT 16
17980: PUSH
17981: FOR_TO
17982: IFFALSE 18181
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17984: LD_ADDR_VAR 0 3
17988: PUSH
17989: LD_INT 10
17991: PUSH
17992: LD_INT 20
17994: PUSH
17995: LD_INT 30
17997: PUSH
17998: LD_INT 40
18000: PUSH
18001: LD_INT 50
18003: PUSH
18004: LD_INT 60
18006: PUSH
18007: LD_INT 70
18009: PUSH
18010: LD_INT 80
18012: PUSH
18013: LD_INT 90
18015: PUSH
18016: LD_INT 100
18018: PUSH
18019: LD_INT 110
18021: PUSH
18022: LD_INT 120
18024: PUSH
18025: LD_INT 130
18027: PUSH
18028: LD_INT 140
18030: PUSH
18031: LD_INT 150
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: PUSH
18051: LD_INT 1
18053: PPUSH
18054: LD_INT 15
18056: PPUSH
18057: CALL_OW 12
18061: ARRAY
18062: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18063: LD_ADDR_VAR 0 4
18067: PUSH
18068: LD_INT 10
18070: PUSH
18071: LD_INT 20
18073: PUSH
18074: LD_INT 30
18076: PUSH
18077: LD_INT 40
18079: PUSH
18080: LD_INT 50
18082: PUSH
18083: LD_INT 60
18085: PUSH
18086: LD_INT 70
18088: PUSH
18089: LD_INT 80
18091: PUSH
18092: LD_INT 90
18094: PUSH
18095: LD_INT 100
18097: PUSH
18098: LD_INT 110
18100: PUSH
18101: LD_INT 120
18103: PUSH
18104: LD_INT 130
18106: PUSH
18107: LD_INT 140
18109: PUSH
18110: LD_INT 150
18112: PUSH
18113: EMPTY
18114: LIST
18115: LIST
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: LIST
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: LIST
18126: LIST
18127: LIST
18128: LIST
18129: PUSH
18130: LD_INT 1
18132: PPUSH
18133: LD_INT 15
18135: PPUSH
18136: CALL_OW 12
18140: ARRAY
18141: ST_TO_ADDR
// if ValidHex ( x , y ) then
18142: LD_VAR 0 3
18146: PPUSH
18147: LD_VAR 0 4
18151: PPUSH
18152: CALL_OW 488
18156: IFFALSE 18179
// begin result := [ x , y ] ;
18158: LD_ADDR_VAR 0 1
18162: PUSH
18163: LD_VAR 0 3
18167: PUSH
18168: LD_VAR 0 4
18172: PUSH
18173: EMPTY
18174: LIST
18175: LIST
18176: ST_TO_ADDR
// break ;
18177: GO 18181
// end ; end ;
18179: GO 17981
18181: POP
18182: POP
// if result then
18183: LD_VAR 0 1
18187: IFFALSE 18247
// begin ToLua ( playSibBomb() ) ;
18189: LD_STRING playSibBomb()
18191: PPUSH
18192: CALL_OW 559
// wait ( 0 0$14 ) ;
18196: LD_INT 490
18198: PPUSH
18199: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
18203: LD_VAR 0 1
18207: PUSH
18208: LD_INT 1
18210: ARRAY
18211: PPUSH
18212: LD_VAR 0 1
18216: PUSH
18217: LD_INT 2
18219: ARRAY
18220: PPUSH
18221: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
18225: LD_VAR 0 1
18229: PUSH
18230: LD_INT 1
18232: ARRAY
18233: PPUSH
18234: LD_VAR 0 1
18238: PUSH
18239: LD_INT 2
18241: ARRAY
18242: PPUSH
18243: CALL_OW 429
// end ; end ;
18247: LD_VAR 0 1
18251: RET
// every 0 0$1 trigger StreamModeActive and sReset do
18252: LD_EXP 43
18256: PUSH
18257: LD_EXP 65
18261: AND
18262: IFFALSE 18274
18264: GO 18266
18266: DISABLE
// YouLost (  ) ;
18267: LD_STRING 
18269: PPUSH
18270: CALL_OW 104
18274: END
// every 0 0$1 trigger StreamModeActive and sFog do
18275: LD_EXP 43
18279: PUSH
18280: LD_EXP 64
18284: AND
18285: IFFALSE 18299
18287: GO 18289
18289: DISABLE
// FogOff ( your_side ) ;
18290: LD_OWVAR 2
18294: PPUSH
18295: CALL_OW 344
18299: END
// every 0 0$1 trigger StreamModeActive and sSun do
18300: LD_EXP 43
18304: PUSH
18305: LD_EXP 66
18309: AND
18310: IFFALSE 18338
18312: GO 18314
18314: DISABLE
// begin solar_recharge_percent := 0 ;
18315: LD_ADDR_OWVAR 79
18319: PUSH
18320: LD_INT 0
18322: ST_TO_ADDR
// wait ( 5 5$00 ) ;
18323: LD_INT 10500
18325: PPUSH
18326: CALL_OW 67
// solar_recharge_percent := 100 ;
18330: LD_ADDR_OWVAR 79
18334: PUSH
18335: LD_INT 100
18337: ST_TO_ADDR
// end ;
18338: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
18339: LD_EXP 43
18343: PUSH
18344: LD_EXP 67
18348: AND
18349: IFFALSE 18588
18351: GO 18353
18353: DISABLE
18354: LD_INT 0
18356: PPUSH
18357: PPUSH
18358: PPUSH
// begin tmp := [ ] ;
18359: LD_ADDR_VAR 0 3
18363: PUSH
18364: EMPTY
18365: ST_TO_ADDR
// for i := 1 to 6 do
18366: LD_ADDR_VAR 0 1
18370: PUSH
18371: DOUBLE
18372: LD_INT 1
18374: DEC
18375: ST_TO_ADDR
18376: LD_INT 6
18378: PUSH
18379: FOR_TO
18380: IFFALSE 18485
// begin uc_nation := nation_nature ;
18382: LD_ADDR_OWVAR 21
18386: PUSH
18387: LD_INT 0
18389: ST_TO_ADDR
// uc_side := 0 ;
18390: LD_ADDR_OWVAR 20
18394: PUSH
18395: LD_INT 0
18397: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18398: LD_ADDR_OWVAR 29
18402: PUSH
18403: LD_INT 12
18405: PUSH
18406: LD_INT 12
18408: PUSH
18409: EMPTY
18410: LIST
18411: LIST
18412: ST_TO_ADDR
// hc_agressivity := 20 ;
18413: LD_ADDR_OWVAR 35
18417: PUSH
18418: LD_INT 20
18420: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
18421: LD_ADDR_OWVAR 28
18425: PUSH
18426: LD_INT 17
18428: ST_TO_ADDR
// hc_gallery :=  ;
18429: LD_ADDR_OWVAR 33
18433: PUSH
18434: LD_STRING 
18436: ST_TO_ADDR
// hc_name :=  ;
18437: LD_ADDR_OWVAR 26
18441: PUSH
18442: LD_STRING 
18444: ST_TO_ADDR
// un := CreateHuman ;
18445: LD_ADDR_VAR 0 2
18449: PUSH
18450: CALL_OW 44
18454: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
18455: LD_VAR 0 2
18459: PPUSH
18460: LD_INT 1
18462: PPUSH
18463: CALL_OW 51
// tmp := tmp ^ un ;
18467: LD_ADDR_VAR 0 3
18471: PUSH
18472: LD_VAR 0 3
18476: PUSH
18477: LD_VAR 0 2
18481: ADD
18482: ST_TO_ADDR
// end ;
18483: GO 18379
18485: POP
18486: POP
// repeat wait ( 0 0$1 ) ;
18487: LD_INT 35
18489: PPUSH
18490: CALL_OW 67
// for un in tmp do
18494: LD_ADDR_VAR 0 2
18498: PUSH
18499: LD_VAR 0 3
18503: PUSH
18504: FOR_IN
18505: IFFALSE 18579
// begin if IsDead ( un ) then
18507: LD_VAR 0 2
18511: PPUSH
18512: CALL_OW 301
18516: IFFALSE 18536
// begin tmp := tmp diff un ;
18518: LD_ADDR_VAR 0 3
18522: PUSH
18523: LD_VAR 0 3
18527: PUSH
18528: LD_VAR 0 2
18532: DIFF
18533: ST_TO_ADDR
// continue ;
18534: GO 18504
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18536: LD_VAR 0 2
18540: PPUSH
18541: LD_INT 3
18543: PUSH
18544: LD_INT 22
18546: PUSH
18547: LD_INT 0
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: PUSH
18554: EMPTY
18555: LIST
18556: LIST
18557: PPUSH
18558: CALL_OW 69
18562: PPUSH
18563: LD_VAR 0 2
18567: PPUSH
18568: CALL_OW 74
18572: PPUSH
18573: CALL_OW 115
// end ;
18577: GO 18504
18579: POP
18580: POP
// until not tmp ;
18581: LD_VAR 0 3
18585: NOT
18586: IFFALSE 18487
// end ;
18588: PPOPN 3
18590: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18591: LD_EXP 43
18595: PUSH
18596: LD_EXP 68
18600: AND
18601: IFFALSE 18655
18603: GO 18605
18605: DISABLE
// begin ToLua ( displayTroll(); ) ;
18606: LD_STRING displayTroll();
18608: PPUSH
18609: CALL_OW 559
// wait ( 3 3$00 ) ;
18613: LD_INT 6300
18615: PPUSH
18616: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18620: LD_STRING hideTroll();
18622: PPUSH
18623: CALL_OW 559
// wait ( 1 1$00 ) ;
18627: LD_INT 2100
18629: PPUSH
18630: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18634: LD_STRING displayTroll();
18636: PPUSH
18637: CALL_OW 559
// wait ( 1 1$00 ) ;
18641: LD_INT 2100
18643: PPUSH
18644: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18648: LD_STRING hideTroll();
18650: PPUSH
18651: CALL_OW 559
// end ;
18655: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18656: LD_EXP 43
18660: PUSH
18661: LD_EXP 69
18665: AND
18666: IFFALSE 18729
18668: GO 18670
18670: DISABLE
18671: LD_INT 0
18673: PPUSH
// begin p := 0 ;
18674: LD_ADDR_VAR 0 1
18678: PUSH
18679: LD_INT 0
18681: ST_TO_ADDR
// repeat game_speed := 1 ;
18682: LD_ADDR_OWVAR 65
18686: PUSH
18687: LD_INT 1
18689: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18690: LD_INT 35
18692: PPUSH
18693: CALL_OW 67
// p := p + 1 ;
18697: LD_ADDR_VAR 0 1
18701: PUSH
18702: LD_VAR 0 1
18706: PUSH
18707: LD_INT 1
18709: PLUS
18710: ST_TO_ADDR
// until p >= 60 ;
18711: LD_VAR 0 1
18715: PUSH
18716: LD_INT 60
18718: GREATEREQUAL
18719: IFFALSE 18682
// game_speed := 4 ;
18721: LD_ADDR_OWVAR 65
18725: PUSH
18726: LD_INT 4
18728: ST_TO_ADDR
// end ;
18729: PPOPN 1
18731: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
18732: LD_EXP 43
18736: PUSH
18737: LD_EXP 70
18741: AND
18742: IFFALSE 18888
18744: GO 18746
18746: DISABLE
18747: LD_INT 0
18749: PPUSH
18750: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18751: LD_ADDR_VAR 0 1
18755: PUSH
18756: LD_INT 22
18758: PUSH
18759: LD_OWVAR 2
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: PUSH
18768: LD_INT 2
18770: PUSH
18771: LD_INT 30
18773: PUSH
18774: LD_INT 0
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: PUSH
18781: LD_INT 30
18783: PUSH
18784: LD_INT 1
18786: PUSH
18787: EMPTY
18788: LIST
18789: LIST
18790: PUSH
18791: EMPTY
18792: LIST
18793: LIST
18794: LIST
18795: PUSH
18796: EMPTY
18797: LIST
18798: LIST
18799: PPUSH
18800: CALL_OW 69
18804: ST_TO_ADDR
// if not depot then
18805: LD_VAR 0 1
18809: NOT
18810: IFFALSE 18814
// exit ;
18812: GO 18888
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18814: LD_ADDR_VAR 0 2
18818: PUSH
18819: LD_VAR 0 1
18823: PUSH
18824: LD_INT 1
18826: PPUSH
18827: LD_VAR 0 1
18831: PPUSH
18832: CALL_OW 12
18836: ARRAY
18837: PPUSH
18838: CALL_OW 274
18842: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18843: LD_VAR 0 2
18847: PPUSH
18848: LD_INT 1
18850: PPUSH
18851: LD_INT 0
18853: PPUSH
18854: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18858: LD_VAR 0 2
18862: PPUSH
18863: LD_INT 2
18865: PPUSH
18866: LD_INT 0
18868: PPUSH
18869: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18873: LD_VAR 0 2
18877: PPUSH
18878: LD_INT 3
18880: PPUSH
18881: LD_INT 0
18883: PPUSH
18884: CALL_OW 277
// end ;
18888: PPOPN 2
18890: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18891: LD_EXP 43
18895: PUSH
18896: LD_EXP 71
18900: AND
18901: IFFALSE 18998
18903: GO 18905
18905: DISABLE
18906: LD_INT 0
18908: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18909: LD_ADDR_VAR 0 1
18913: PUSH
18914: LD_INT 22
18916: PUSH
18917: LD_OWVAR 2
18921: PUSH
18922: EMPTY
18923: LIST
18924: LIST
18925: PUSH
18926: LD_INT 21
18928: PUSH
18929: LD_INT 1
18931: PUSH
18932: EMPTY
18933: LIST
18934: LIST
18935: PUSH
18936: LD_INT 3
18938: PUSH
18939: LD_INT 23
18941: PUSH
18942: LD_INT 0
18944: PUSH
18945: EMPTY
18946: LIST
18947: LIST
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: PUSH
18953: EMPTY
18954: LIST
18955: LIST
18956: LIST
18957: PPUSH
18958: CALL_OW 69
18962: ST_TO_ADDR
// if not tmp then
18963: LD_VAR 0 1
18967: NOT
18968: IFFALSE 18972
// exit ;
18970: GO 18998
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18972: LD_VAR 0 1
18976: PUSH
18977: LD_INT 1
18979: PPUSH
18980: LD_VAR 0 1
18984: PPUSH
18985: CALL_OW 12
18989: ARRAY
18990: PPUSH
18991: LD_INT 200
18993: PPUSH
18994: CALL_OW 234
// end ;
18998: PPOPN 1
19000: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
19001: LD_EXP 43
19005: PUSH
19006: LD_EXP 72
19010: AND
19011: IFFALSE 19090
19013: GO 19015
19015: DISABLE
19016: LD_INT 0
19018: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
19019: LD_ADDR_VAR 0 1
19023: PUSH
19024: LD_INT 22
19026: PUSH
19027: LD_OWVAR 2
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: PUSH
19036: LD_INT 21
19038: PUSH
19039: LD_INT 2
19041: PUSH
19042: EMPTY
19043: LIST
19044: LIST
19045: PUSH
19046: EMPTY
19047: LIST
19048: LIST
19049: PPUSH
19050: CALL_OW 69
19054: ST_TO_ADDR
// if not tmp then
19055: LD_VAR 0 1
19059: NOT
19060: IFFALSE 19064
// exit ;
19062: GO 19090
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
19064: LD_VAR 0 1
19068: PUSH
19069: LD_INT 1
19071: PPUSH
19072: LD_VAR 0 1
19076: PPUSH
19077: CALL_OW 12
19081: ARRAY
19082: PPUSH
19083: LD_INT 60
19085: PPUSH
19086: CALL_OW 234
// end ;
19090: PPOPN 1
19092: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
19093: LD_EXP 43
19097: PUSH
19098: LD_EXP 73
19102: AND
19103: IFFALSE 19202
19105: GO 19107
19107: DISABLE
19108: LD_INT 0
19110: PPUSH
19111: PPUSH
// begin enable ;
19112: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
19113: LD_ADDR_VAR 0 1
19117: PUSH
19118: LD_INT 22
19120: PUSH
19121: LD_OWVAR 2
19125: PUSH
19126: EMPTY
19127: LIST
19128: LIST
19129: PUSH
19130: LD_INT 61
19132: PUSH
19133: EMPTY
19134: LIST
19135: PUSH
19136: LD_INT 33
19138: PUSH
19139: LD_INT 2
19141: PUSH
19142: EMPTY
19143: LIST
19144: LIST
19145: PUSH
19146: EMPTY
19147: LIST
19148: LIST
19149: LIST
19150: PPUSH
19151: CALL_OW 69
19155: ST_TO_ADDR
// if not tmp then
19156: LD_VAR 0 1
19160: NOT
19161: IFFALSE 19165
// exit ;
19163: GO 19202
// for i in tmp do
19165: LD_ADDR_VAR 0 2
19169: PUSH
19170: LD_VAR 0 1
19174: PUSH
19175: FOR_IN
19176: IFFALSE 19200
// if IsControledBy ( i ) then
19178: LD_VAR 0 2
19182: PPUSH
19183: CALL_OW 312
19187: IFFALSE 19198
// ComUnlink ( i ) ;
19189: LD_VAR 0 2
19193: PPUSH
19194: CALL_OW 136
19198: GO 19175
19200: POP
19201: POP
// end ;
19202: PPOPN 2
19204: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
19205: LD_EXP 43
19209: PUSH
19210: LD_EXP 74
19214: AND
19215: IFFALSE 19355
19217: GO 19219
19219: DISABLE
19220: LD_INT 0
19222: PPUSH
19223: PPUSH
// begin ToLua ( displayPowell(); ) ;
19224: LD_STRING displayPowell();
19226: PPUSH
19227: CALL_OW 559
// uc_side := 0 ;
19231: LD_ADDR_OWVAR 20
19235: PUSH
19236: LD_INT 0
19238: ST_TO_ADDR
// uc_nation := 2 ;
19239: LD_ADDR_OWVAR 21
19243: PUSH
19244: LD_INT 2
19246: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19247: LD_ADDR_OWVAR 37
19251: PUSH
19252: LD_INT 14
19254: ST_TO_ADDR
// vc_engine := engine_siberite ;
19255: LD_ADDR_OWVAR 39
19259: PUSH
19260: LD_INT 3
19262: ST_TO_ADDR
// vc_control := control_apeman ;
19263: LD_ADDR_OWVAR 38
19267: PUSH
19268: LD_INT 5
19270: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
19271: LD_ADDR_OWVAR 40
19275: PUSH
19276: LD_INT 29
19278: ST_TO_ADDR
// un := CreateVehicle ;
19279: LD_ADDR_VAR 0 2
19283: PUSH
19284: CALL_OW 45
19288: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19289: LD_VAR 0 2
19293: PPUSH
19294: LD_INT 1
19296: PPUSH
19297: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19301: LD_INT 35
19303: PPUSH
19304: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19308: LD_VAR 0 2
19312: PPUSH
19313: LD_INT 22
19315: PUSH
19316: LD_OWVAR 2
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: PPUSH
19325: CALL_OW 69
19329: PPUSH
19330: LD_VAR 0 2
19334: PPUSH
19335: CALL_OW 74
19339: PPUSH
19340: CALL_OW 115
// until IsDead ( un ) ;
19344: LD_VAR 0 2
19348: PPUSH
19349: CALL_OW 301
19353: IFFALSE 19301
// end ;
19355: PPOPN 2
19357: END
// every 0 0$1 trigger StreamModeActive and sStu do
19358: LD_EXP 43
19362: PUSH
19363: LD_EXP 82
19367: AND
19368: IFFALSE 19384
19370: GO 19372
19372: DISABLE
// begin ToLua ( displayStucuk(); ) ;
19373: LD_STRING displayStucuk();
19375: PPUSH
19376: CALL_OW 559
// ResetFog ;
19380: CALL_OW 335
// end ;
19384: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
19385: LD_EXP 43
19389: PUSH
19390: LD_EXP 75
19394: AND
19395: IFFALSE 19536
19397: GO 19399
19399: DISABLE
19400: LD_INT 0
19402: PPUSH
19403: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19404: LD_ADDR_VAR 0 2
19408: PUSH
19409: LD_INT 22
19411: PUSH
19412: LD_OWVAR 2
19416: PUSH
19417: EMPTY
19418: LIST
19419: LIST
19420: PUSH
19421: LD_INT 21
19423: PUSH
19424: LD_INT 1
19426: PUSH
19427: EMPTY
19428: LIST
19429: LIST
19430: PUSH
19431: EMPTY
19432: LIST
19433: LIST
19434: PPUSH
19435: CALL_OW 69
19439: ST_TO_ADDR
// if not tmp then
19440: LD_VAR 0 2
19444: NOT
19445: IFFALSE 19449
// exit ;
19447: GO 19536
// un := tmp [ rand ( 1 , tmp ) ] ;
19449: LD_ADDR_VAR 0 1
19453: PUSH
19454: LD_VAR 0 2
19458: PUSH
19459: LD_INT 1
19461: PPUSH
19462: LD_VAR 0 2
19466: PPUSH
19467: CALL_OW 12
19471: ARRAY
19472: ST_TO_ADDR
// SetSide ( un , 0 ) ;
19473: LD_VAR 0 1
19477: PPUSH
19478: LD_INT 0
19480: PPUSH
19481: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
19485: LD_VAR 0 1
19489: PPUSH
19490: LD_OWVAR 3
19494: PUSH
19495: LD_VAR 0 1
19499: DIFF
19500: PPUSH
19501: LD_VAR 0 1
19505: PPUSH
19506: CALL_OW 74
19510: PPUSH
19511: CALL_OW 115
// wait ( 0 0$20 ) ;
19515: LD_INT 700
19517: PPUSH
19518: CALL_OW 67
// SetSide ( un , your_side ) ;
19522: LD_VAR 0 1
19526: PPUSH
19527: LD_OWVAR 2
19531: PPUSH
19532: CALL_OW 235
// end ;
19536: PPOPN 2
19538: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19539: LD_EXP 43
19543: PUSH
19544: LD_EXP 76
19548: AND
19549: IFFALSE 19655
19551: GO 19553
19553: DISABLE
19554: LD_INT 0
19556: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19557: LD_ADDR_VAR 0 1
19561: PUSH
19562: LD_INT 22
19564: PUSH
19565: LD_OWVAR 2
19569: PUSH
19570: EMPTY
19571: LIST
19572: LIST
19573: PUSH
19574: LD_INT 2
19576: PUSH
19577: LD_INT 30
19579: PUSH
19580: LD_INT 0
19582: PUSH
19583: EMPTY
19584: LIST
19585: LIST
19586: PUSH
19587: LD_INT 30
19589: PUSH
19590: LD_INT 1
19592: PUSH
19593: EMPTY
19594: LIST
19595: LIST
19596: PUSH
19597: EMPTY
19598: LIST
19599: LIST
19600: LIST
19601: PUSH
19602: EMPTY
19603: LIST
19604: LIST
19605: PPUSH
19606: CALL_OW 69
19610: ST_TO_ADDR
// if not depot then
19611: LD_VAR 0 1
19615: NOT
19616: IFFALSE 19620
// exit ;
19618: GO 19655
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19620: LD_VAR 0 1
19624: PUSH
19625: LD_INT 1
19627: ARRAY
19628: PPUSH
19629: CALL_OW 250
19633: PPUSH
19634: LD_VAR 0 1
19638: PUSH
19639: LD_INT 1
19641: ARRAY
19642: PPUSH
19643: CALL_OW 251
19647: PPUSH
19648: LD_INT 70
19650: PPUSH
19651: CALL_OW 495
// end ;
19655: PPOPN 1
19657: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19658: LD_EXP 43
19662: PUSH
19663: LD_EXP 77
19667: AND
19668: IFFALSE 19879
19670: GO 19672
19672: DISABLE
19673: LD_INT 0
19675: PPUSH
19676: PPUSH
19677: PPUSH
19678: PPUSH
19679: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19680: LD_ADDR_VAR 0 5
19684: PUSH
19685: LD_INT 22
19687: PUSH
19688: LD_OWVAR 2
19692: PUSH
19693: EMPTY
19694: LIST
19695: LIST
19696: PUSH
19697: LD_INT 21
19699: PUSH
19700: LD_INT 1
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: PUSH
19707: EMPTY
19708: LIST
19709: LIST
19710: PPUSH
19711: CALL_OW 69
19715: ST_TO_ADDR
// if not tmp then
19716: LD_VAR 0 5
19720: NOT
19721: IFFALSE 19725
// exit ;
19723: GO 19879
// for i in tmp do
19725: LD_ADDR_VAR 0 1
19729: PUSH
19730: LD_VAR 0 5
19734: PUSH
19735: FOR_IN
19736: IFFALSE 19877
// begin d := rand ( 0 , 5 ) ;
19738: LD_ADDR_VAR 0 4
19742: PUSH
19743: LD_INT 0
19745: PPUSH
19746: LD_INT 5
19748: PPUSH
19749: CALL_OW 12
19753: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19754: LD_ADDR_VAR 0 2
19758: PUSH
19759: LD_VAR 0 1
19763: PPUSH
19764: CALL_OW 250
19768: PPUSH
19769: LD_VAR 0 4
19773: PPUSH
19774: LD_INT 3
19776: PPUSH
19777: LD_INT 12
19779: PPUSH
19780: CALL_OW 12
19784: PPUSH
19785: CALL_OW 272
19789: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19790: LD_ADDR_VAR 0 3
19794: PUSH
19795: LD_VAR 0 1
19799: PPUSH
19800: CALL_OW 251
19804: PPUSH
19805: LD_VAR 0 4
19809: PPUSH
19810: LD_INT 3
19812: PPUSH
19813: LD_INT 12
19815: PPUSH
19816: CALL_OW 12
19820: PPUSH
19821: CALL_OW 273
19825: ST_TO_ADDR
// if ValidHex ( x , y ) then
19826: LD_VAR 0 2
19830: PPUSH
19831: LD_VAR 0 3
19835: PPUSH
19836: CALL_OW 488
19840: IFFALSE 19875
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19842: LD_VAR 0 1
19846: PPUSH
19847: LD_VAR 0 2
19851: PPUSH
19852: LD_VAR 0 3
19856: PPUSH
19857: LD_INT 3
19859: PPUSH
19860: LD_INT 6
19862: PPUSH
19863: CALL_OW 12
19867: PPUSH
19868: LD_INT 1
19870: PPUSH
19871: CALL_OW 483
// end ;
19875: GO 19735
19877: POP
19878: POP
// end ;
19879: PPOPN 5
19881: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19882: LD_EXP 43
19886: PUSH
19887: LD_EXP 78
19891: AND
19892: IFFALSE 19986
19894: GO 19896
19896: DISABLE
19897: LD_INT 0
19899: PPUSH
19900: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19901: LD_ADDR_VAR 0 2
19905: PUSH
19906: LD_INT 22
19908: PUSH
19909: LD_OWVAR 2
19913: PUSH
19914: EMPTY
19915: LIST
19916: LIST
19917: PUSH
19918: LD_INT 32
19920: PUSH
19921: LD_INT 1
19923: PUSH
19924: EMPTY
19925: LIST
19926: LIST
19927: PUSH
19928: LD_INT 21
19930: PUSH
19931: LD_INT 2
19933: PUSH
19934: EMPTY
19935: LIST
19936: LIST
19937: PUSH
19938: EMPTY
19939: LIST
19940: LIST
19941: LIST
19942: PPUSH
19943: CALL_OW 69
19947: ST_TO_ADDR
// if not tmp then
19948: LD_VAR 0 2
19952: NOT
19953: IFFALSE 19957
// exit ;
19955: GO 19986
// for i in tmp do
19957: LD_ADDR_VAR 0 1
19961: PUSH
19962: LD_VAR 0 2
19966: PUSH
19967: FOR_IN
19968: IFFALSE 19984
// SetFuel ( i , 0 ) ;
19970: LD_VAR 0 1
19974: PPUSH
19975: LD_INT 0
19977: PPUSH
19978: CALL_OW 240
19982: GO 19967
19984: POP
19985: POP
// end ;
19986: PPOPN 2
19988: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19989: LD_EXP 43
19993: PUSH
19994: LD_EXP 79
19998: AND
19999: IFFALSE 20065
20001: GO 20003
20003: DISABLE
20004: LD_INT 0
20006: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20007: LD_ADDR_VAR 0 1
20011: PUSH
20012: LD_INT 22
20014: PUSH
20015: LD_OWVAR 2
20019: PUSH
20020: EMPTY
20021: LIST
20022: LIST
20023: PUSH
20024: LD_INT 30
20026: PUSH
20027: LD_INT 29
20029: PUSH
20030: EMPTY
20031: LIST
20032: LIST
20033: PUSH
20034: EMPTY
20035: LIST
20036: LIST
20037: PPUSH
20038: CALL_OW 69
20042: ST_TO_ADDR
// if not tmp then
20043: LD_VAR 0 1
20047: NOT
20048: IFFALSE 20052
// exit ;
20050: GO 20065
// DestroyUnit ( tmp [ 1 ] ) ;
20052: LD_VAR 0 1
20056: PUSH
20057: LD_INT 1
20059: ARRAY
20060: PPUSH
20061: CALL_OW 65
// end ;
20065: PPOPN 1
20067: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
20068: LD_EXP 43
20072: PUSH
20073: LD_EXP 81
20077: AND
20078: IFFALSE 20207
20080: GO 20082
20082: DISABLE
20083: LD_INT 0
20085: PPUSH
// begin uc_side := 0 ;
20086: LD_ADDR_OWVAR 20
20090: PUSH
20091: LD_INT 0
20093: ST_TO_ADDR
// uc_nation := nation_arabian ;
20094: LD_ADDR_OWVAR 21
20098: PUSH
20099: LD_INT 2
20101: ST_TO_ADDR
// hc_gallery :=  ;
20102: LD_ADDR_OWVAR 33
20106: PUSH
20107: LD_STRING 
20109: ST_TO_ADDR
// hc_name :=  ;
20110: LD_ADDR_OWVAR 26
20114: PUSH
20115: LD_STRING 
20117: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
20118: LD_INT 1
20120: PPUSH
20121: LD_INT 11
20123: PPUSH
20124: LD_INT 10
20126: PPUSH
20127: CALL_OW 380
// un := CreateHuman ;
20131: LD_ADDR_VAR 0 1
20135: PUSH
20136: CALL_OW 44
20140: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20141: LD_VAR 0 1
20145: PPUSH
20146: LD_INT 1
20148: PPUSH
20149: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20153: LD_INT 35
20155: PPUSH
20156: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20160: LD_VAR 0 1
20164: PPUSH
20165: LD_INT 22
20167: PUSH
20168: LD_OWVAR 2
20172: PUSH
20173: EMPTY
20174: LIST
20175: LIST
20176: PPUSH
20177: CALL_OW 69
20181: PPUSH
20182: LD_VAR 0 1
20186: PPUSH
20187: CALL_OW 74
20191: PPUSH
20192: CALL_OW 115
// until IsDead ( un ) ;
20196: LD_VAR 0 1
20200: PPUSH
20201: CALL_OW 301
20205: IFFALSE 20153
// end ;
20207: PPOPN 1
20209: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
20210: LD_EXP 43
20214: PUSH
20215: LD_EXP 83
20219: AND
20220: IFFALSE 20232
20222: GO 20224
20224: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
20225: LD_STRING earthquake(getX(game), 0, 32)
20227: PPUSH
20228: CALL_OW 559
20232: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
20233: LD_EXP 43
20237: PUSH
20238: LD_EXP 84
20242: AND
20243: IFFALSE 20334
20245: GO 20247
20247: DISABLE
20248: LD_INT 0
20250: PPUSH
// begin enable ;
20251: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
20252: LD_ADDR_VAR 0 1
20256: PUSH
20257: LD_INT 22
20259: PUSH
20260: LD_OWVAR 2
20264: PUSH
20265: EMPTY
20266: LIST
20267: LIST
20268: PUSH
20269: LD_INT 21
20271: PUSH
20272: LD_INT 2
20274: PUSH
20275: EMPTY
20276: LIST
20277: LIST
20278: PUSH
20279: LD_INT 33
20281: PUSH
20282: LD_INT 3
20284: PUSH
20285: EMPTY
20286: LIST
20287: LIST
20288: PUSH
20289: EMPTY
20290: LIST
20291: LIST
20292: LIST
20293: PPUSH
20294: CALL_OW 69
20298: ST_TO_ADDR
// if not tmp then
20299: LD_VAR 0 1
20303: NOT
20304: IFFALSE 20308
// exit ;
20306: GO 20334
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20308: LD_VAR 0 1
20312: PUSH
20313: LD_INT 1
20315: PPUSH
20316: LD_VAR 0 1
20320: PPUSH
20321: CALL_OW 12
20325: ARRAY
20326: PPUSH
20327: LD_INT 1
20329: PPUSH
20330: CALL_OW 234
// end ;
20334: PPOPN 1
20336: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
20337: LD_EXP 43
20341: PUSH
20342: LD_EXP 85
20346: AND
20347: IFFALSE 20488
20349: GO 20351
20351: DISABLE
20352: LD_INT 0
20354: PPUSH
20355: PPUSH
20356: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20357: LD_ADDR_VAR 0 3
20361: PUSH
20362: LD_INT 22
20364: PUSH
20365: LD_OWVAR 2
20369: PUSH
20370: EMPTY
20371: LIST
20372: LIST
20373: PUSH
20374: LD_INT 25
20376: PUSH
20377: LD_INT 1
20379: PUSH
20380: EMPTY
20381: LIST
20382: LIST
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: PPUSH
20388: CALL_OW 69
20392: ST_TO_ADDR
// if not tmp then
20393: LD_VAR 0 3
20397: NOT
20398: IFFALSE 20402
// exit ;
20400: GO 20488
// un := tmp [ rand ( 1 , tmp ) ] ;
20402: LD_ADDR_VAR 0 2
20406: PUSH
20407: LD_VAR 0 3
20411: PUSH
20412: LD_INT 1
20414: PPUSH
20415: LD_VAR 0 3
20419: PPUSH
20420: CALL_OW 12
20424: ARRAY
20425: ST_TO_ADDR
// if Crawls ( un ) then
20426: LD_VAR 0 2
20430: PPUSH
20431: CALL_OW 318
20435: IFFALSE 20446
// ComWalk ( un ) ;
20437: LD_VAR 0 2
20441: PPUSH
20442: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
20446: LD_VAR 0 2
20450: PPUSH
20451: LD_INT 9
20453: PPUSH
20454: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
20458: LD_INT 28
20460: PPUSH
20461: LD_OWVAR 2
20465: PPUSH
20466: LD_INT 2
20468: PPUSH
20469: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
20473: LD_INT 29
20475: PPUSH
20476: LD_OWVAR 2
20480: PPUSH
20481: LD_INT 2
20483: PPUSH
20484: CALL_OW 322
// end ;
20488: PPOPN 3
20490: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
20491: LD_EXP 43
20495: PUSH
20496: LD_EXP 86
20500: AND
20501: IFFALSE 20612
20503: GO 20505
20505: DISABLE
20506: LD_INT 0
20508: PPUSH
20509: PPUSH
20510: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20511: LD_ADDR_VAR 0 3
20515: PUSH
20516: LD_INT 22
20518: PUSH
20519: LD_OWVAR 2
20523: PUSH
20524: EMPTY
20525: LIST
20526: LIST
20527: PUSH
20528: LD_INT 25
20530: PUSH
20531: LD_INT 1
20533: PUSH
20534: EMPTY
20535: LIST
20536: LIST
20537: PUSH
20538: EMPTY
20539: LIST
20540: LIST
20541: PPUSH
20542: CALL_OW 69
20546: ST_TO_ADDR
// if not tmp then
20547: LD_VAR 0 3
20551: NOT
20552: IFFALSE 20556
// exit ;
20554: GO 20612
// un := tmp [ rand ( 1 , tmp ) ] ;
20556: LD_ADDR_VAR 0 2
20560: PUSH
20561: LD_VAR 0 3
20565: PUSH
20566: LD_INT 1
20568: PPUSH
20569: LD_VAR 0 3
20573: PPUSH
20574: CALL_OW 12
20578: ARRAY
20579: ST_TO_ADDR
// if Crawls ( un ) then
20580: LD_VAR 0 2
20584: PPUSH
20585: CALL_OW 318
20589: IFFALSE 20600
// ComWalk ( un ) ;
20591: LD_VAR 0 2
20595: PPUSH
20596: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20600: LD_VAR 0 2
20604: PPUSH
20605: LD_INT 8
20607: PPUSH
20608: CALL_OW 336
// end ;
20612: PPOPN 3
20614: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20615: LD_EXP 43
20619: PUSH
20620: LD_EXP 87
20624: AND
20625: IFFALSE 20769
20627: GO 20629
20629: DISABLE
20630: LD_INT 0
20632: PPUSH
20633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20634: LD_ADDR_VAR 0 2
20638: PUSH
20639: LD_INT 22
20641: PUSH
20642: LD_OWVAR 2
20646: PUSH
20647: EMPTY
20648: LIST
20649: LIST
20650: PUSH
20651: LD_INT 21
20653: PUSH
20654: LD_INT 2
20656: PUSH
20657: EMPTY
20658: LIST
20659: LIST
20660: PUSH
20661: LD_INT 2
20663: PUSH
20664: LD_INT 34
20666: PUSH
20667: LD_INT 12
20669: PUSH
20670: EMPTY
20671: LIST
20672: LIST
20673: PUSH
20674: LD_INT 34
20676: PUSH
20677: LD_INT 51
20679: PUSH
20680: EMPTY
20681: LIST
20682: LIST
20683: PUSH
20684: LD_INT 34
20686: PUSH
20687: LD_INT 32
20689: PUSH
20690: EMPTY
20691: LIST
20692: LIST
20693: PUSH
20694: EMPTY
20695: LIST
20696: LIST
20697: LIST
20698: LIST
20699: PUSH
20700: EMPTY
20701: LIST
20702: LIST
20703: LIST
20704: PPUSH
20705: CALL_OW 69
20709: ST_TO_ADDR
// if not tmp then
20710: LD_VAR 0 2
20714: NOT
20715: IFFALSE 20719
// exit ;
20717: GO 20769
// for i in tmp do
20719: LD_ADDR_VAR 0 1
20723: PUSH
20724: LD_VAR 0 2
20728: PUSH
20729: FOR_IN
20730: IFFALSE 20767
// if GetCargo ( i , mat_artifact ) = 0 then
20732: LD_VAR 0 1
20736: PPUSH
20737: LD_INT 4
20739: PPUSH
20740: CALL_OW 289
20744: PUSH
20745: LD_INT 0
20747: EQUAL
20748: IFFALSE 20765
// SetCargo ( i , mat_siberit , 100 ) ;
20750: LD_VAR 0 1
20754: PPUSH
20755: LD_INT 3
20757: PPUSH
20758: LD_INT 100
20760: PPUSH
20761: CALL_OW 290
20765: GO 20729
20767: POP
20768: POP
// end ;
20769: PPOPN 2
20771: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20772: LD_EXP 43
20776: PUSH
20777: LD_EXP 88
20781: AND
20782: IFFALSE 20965
20784: GO 20786
20786: DISABLE
20787: LD_INT 0
20789: PPUSH
20790: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20791: LD_ADDR_VAR 0 2
20795: PUSH
20796: LD_INT 22
20798: PUSH
20799: LD_OWVAR 2
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: PPUSH
20808: CALL_OW 69
20812: ST_TO_ADDR
// if not tmp then
20813: LD_VAR 0 2
20817: NOT
20818: IFFALSE 20822
// exit ;
20820: GO 20965
// for i := 1 to 2 do
20822: LD_ADDR_VAR 0 1
20826: PUSH
20827: DOUBLE
20828: LD_INT 1
20830: DEC
20831: ST_TO_ADDR
20832: LD_INT 2
20834: PUSH
20835: FOR_TO
20836: IFFALSE 20963
// begin uc_side := your_side ;
20838: LD_ADDR_OWVAR 20
20842: PUSH
20843: LD_OWVAR 2
20847: ST_TO_ADDR
// uc_nation := nation_american ;
20848: LD_ADDR_OWVAR 21
20852: PUSH
20853: LD_INT 1
20855: ST_TO_ADDR
// vc_chassis := us_morphling ;
20856: LD_ADDR_OWVAR 37
20860: PUSH
20861: LD_INT 5
20863: ST_TO_ADDR
// vc_engine := engine_siberite ;
20864: LD_ADDR_OWVAR 39
20868: PUSH
20869: LD_INT 3
20871: ST_TO_ADDR
// vc_control := control_computer ;
20872: LD_ADDR_OWVAR 38
20876: PUSH
20877: LD_INT 3
20879: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20880: LD_ADDR_OWVAR 40
20884: PUSH
20885: LD_INT 10
20887: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
20888: LD_VAR 0 2
20892: PUSH
20893: LD_INT 1
20895: ARRAY
20896: PPUSH
20897: CALL_OW 310
20901: NOT
20902: IFFALSE 20949
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
20904: CALL_OW 45
20908: PPUSH
20909: LD_VAR 0 2
20913: PUSH
20914: LD_INT 1
20916: ARRAY
20917: PPUSH
20918: CALL_OW 250
20922: PPUSH
20923: LD_VAR 0 2
20927: PUSH
20928: LD_INT 1
20930: ARRAY
20931: PPUSH
20932: CALL_OW 251
20936: PPUSH
20937: LD_INT 12
20939: PPUSH
20940: LD_INT 1
20942: PPUSH
20943: CALL_OW 50
20947: GO 20961
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
20949: CALL_OW 45
20953: PPUSH
20954: LD_INT 1
20956: PPUSH
20957: CALL_OW 51
// end ;
20961: GO 20835
20963: POP
20964: POP
// end ;
20965: PPOPN 2
20967: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20968: LD_EXP 43
20972: PUSH
20973: LD_EXP 89
20977: AND
20978: IFFALSE 21200
20980: GO 20982
20982: DISABLE
20983: LD_INT 0
20985: PPUSH
20986: PPUSH
20987: PPUSH
20988: PPUSH
20989: PPUSH
20990: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20991: LD_ADDR_VAR 0 6
20995: PUSH
20996: LD_INT 22
20998: PUSH
20999: LD_OWVAR 2
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: PUSH
21008: LD_INT 21
21010: PUSH
21011: LD_INT 1
21013: PUSH
21014: EMPTY
21015: LIST
21016: LIST
21017: PUSH
21018: LD_INT 3
21020: PUSH
21021: LD_INT 23
21023: PUSH
21024: LD_INT 0
21026: PUSH
21027: EMPTY
21028: LIST
21029: LIST
21030: PUSH
21031: EMPTY
21032: LIST
21033: LIST
21034: PUSH
21035: EMPTY
21036: LIST
21037: LIST
21038: LIST
21039: PPUSH
21040: CALL_OW 69
21044: ST_TO_ADDR
// if not tmp then
21045: LD_VAR 0 6
21049: NOT
21050: IFFALSE 21054
// exit ;
21052: GO 21200
// s1 := rand ( 1 , 4 ) ;
21054: LD_ADDR_VAR 0 2
21058: PUSH
21059: LD_INT 1
21061: PPUSH
21062: LD_INT 4
21064: PPUSH
21065: CALL_OW 12
21069: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
21070: LD_ADDR_VAR 0 4
21074: PUSH
21075: LD_VAR 0 6
21079: PUSH
21080: LD_INT 1
21082: ARRAY
21083: PPUSH
21084: LD_VAR 0 2
21088: PPUSH
21089: CALL_OW 259
21093: ST_TO_ADDR
// if s1 = 1 then
21094: LD_VAR 0 2
21098: PUSH
21099: LD_INT 1
21101: EQUAL
21102: IFFALSE 21122
// s2 := rand ( 2 , 4 ) else
21104: LD_ADDR_VAR 0 3
21108: PUSH
21109: LD_INT 2
21111: PPUSH
21112: LD_INT 4
21114: PPUSH
21115: CALL_OW 12
21119: ST_TO_ADDR
21120: GO 21130
// s2 := 1 ;
21122: LD_ADDR_VAR 0 3
21126: PUSH
21127: LD_INT 1
21129: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
21130: LD_ADDR_VAR 0 5
21134: PUSH
21135: LD_VAR 0 6
21139: PUSH
21140: LD_INT 1
21142: ARRAY
21143: PPUSH
21144: LD_VAR 0 3
21148: PPUSH
21149: CALL_OW 259
21153: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
21154: LD_VAR 0 6
21158: PUSH
21159: LD_INT 1
21161: ARRAY
21162: PPUSH
21163: LD_VAR 0 2
21167: PPUSH
21168: LD_VAR 0 5
21172: PPUSH
21173: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
21177: LD_VAR 0 6
21181: PUSH
21182: LD_INT 1
21184: ARRAY
21185: PPUSH
21186: LD_VAR 0 3
21190: PPUSH
21191: LD_VAR 0 4
21195: PPUSH
21196: CALL_OW 237
// end ;
21200: PPOPN 6
21202: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
21203: LD_EXP 43
21207: PUSH
21208: LD_EXP 90
21212: AND
21213: IFFALSE 21292
21215: GO 21217
21217: DISABLE
21218: LD_INT 0
21220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
21221: LD_ADDR_VAR 0 1
21225: PUSH
21226: LD_INT 22
21228: PUSH
21229: LD_OWVAR 2
21233: PUSH
21234: EMPTY
21235: LIST
21236: LIST
21237: PUSH
21238: LD_INT 30
21240: PUSH
21241: LD_INT 3
21243: PUSH
21244: EMPTY
21245: LIST
21246: LIST
21247: PUSH
21248: EMPTY
21249: LIST
21250: LIST
21251: PPUSH
21252: CALL_OW 69
21256: ST_TO_ADDR
// if not tmp then
21257: LD_VAR 0 1
21261: NOT
21262: IFFALSE 21266
// exit ;
21264: GO 21292
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21266: LD_VAR 0 1
21270: PUSH
21271: LD_INT 1
21273: PPUSH
21274: LD_VAR 0 1
21278: PPUSH
21279: CALL_OW 12
21283: ARRAY
21284: PPUSH
21285: LD_INT 1
21287: PPUSH
21288: CALL_OW 234
// end ;
21292: PPOPN 1
21294: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
21295: LD_EXP 43
21299: PUSH
21300: LD_EXP 91
21304: AND
21305: IFFALSE 21417
21307: GO 21309
21309: DISABLE
21310: LD_INT 0
21312: PPUSH
21313: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
21314: LD_ADDR_VAR 0 2
21318: PUSH
21319: LD_INT 22
21321: PUSH
21322: LD_OWVAR 2
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: PUSH
21331: LD_INT 2
21333: PUSH
21334: LD_INT 30
21336: PUSH
21337: LD_INT 27
21339: PUSH
21340: EMPTY
21341: LIST
21342: LIST
21343: PUSH
21344: LD_INT 30
21346: PUSH
21347: LD_INT 26
21349: PUSH
21350: EMPTY
21351: LIST
21352: LIST
21353: PUSH
21354: LD_INT 30
21356: PUSH
21357: LD_INT 28
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: LIST
21368: LIST
21369: PUSH
21370: EMPTY
21371: LIST
21372: LIST
21373: PPUSH
21374: CALL_OW 69
21378: ST_TO_ADDR
// if not tmp then
21379: LD_VAR 0 2
21383: NOT
21384: IFFALSE 21388
// exit ;
21386: GO 21417
// for i in tmp do
21388: LD_ADDR_VAR 0 1
21392: PUSH
21393: LD_VAR 0 2
21397: PUSH
21398: FOR_IN
21399: IFFALSE 21415
// SetLives ( i , 1 ) ;
21401: LD_VAR 0 1
21405: PPUSH
21406: LD_INT 1
21408: PPUSH
21409: CALL_OW 234
21413: GO 21398
21415: POP
21416: POP
// end ;
21417: PPOPN 2
21419: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
21420: LD_EXP 43
21424: PUSH
21425: LD_EXP 92
21429: AND
21430: IFFALSE 21704
21432: GO 21434
21434: DISABLE
21435: LD_INT 0
21437: PPUSH
21438: PPUSH
21439: PPUSH
// begin i := rand ( 1 , 7 ) ;
21440: LD_ADDR_VAR 0 1
21444: PUSH
21445: LD_INT 1
21447: PPUSH
21448: LD_INT 7
21450: PPUSH
21451: CALL_OW 12
21455: ST_TO_ADDR
// case i of 1 :
21456: LD_VAR 0 1
21460: PUSH
21461: LD_INT 1
21463: DOUBLE
21464: EQUAL
21465: IFTRUE 21469
21467: GO 21479
21469: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
21470: LD_STRING earthquake(getX(game), 0, 32)
21472: PPUSH
21473: CALL_OW 559
21477: GO 21704
21479: LD_INT 2
21481: DOUBLE
21482: EQUAL
21483: IFTRUE 21487
21485: GO 21501
21487: POP
// begin ToLua ( displayStucuk(); ) ;
21488: LD_STRING displayStucuk();
21490: PPUSH
21491: CALL_OW 559
// ResetFog ;
21495: CALL_OW 335
// end ; 3 :
21499: GO 21704
21501: LD_INT 3
21503: DOUBLE
21504: EQUAL
21505: IFTRUE 21509
21507: GO 21613
21509: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21510: LD_ADDR_VAR 0 2
21514: PUSH
21515: LD_INT 22
21517: PUSH
21518: LD_OWVAR 2
21522: PUSH
21523: EMPTY
21524: LIST
21525: LIST
21526: PUSH
21527: LD_INT 25
21529: PUSH
21530: LD_INT 1
21532: PUSH
21533: EMPTY
21534: LIST
21535: LIST
21536: PUSH
21537: EMPTY
21538: LIST
21539: LIST
21540: PPUSH
21541: CALL_OW 69
21545: ST_TO_ADDR
// if not tmp then
21546: LD_VAR 0 2
21550: NOT
21551: IFFALSE 21555
// exit ;
21553: GO 21704
// un := tmp [ rand ( 1 , tmp ) ] ;
21555: LD_ADDR_VAR 0 3
21559: PUSH
21560: LD_VAR 0 2
21564: PUSH
21565: LD_INT 1
21567: PPUSH
21568: LD_VAR 0 2
21572: PPUSH
21573: CALL_OW 12
21577: ARRAY
21578: ST_TO_ADDR
// if Crawls ( un ) then
21579: LD_VAR 0 3
21583: PPUSH
21584: CALL_OW 318
21588: IFFALSE 21599
// ComWalk ( un ) ;
21590: LD_VAR 0 3
21594: PPUSH
21595: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21599: LD_VAR 0 3
21603: PPUSH
21604: LD_INT 8
21606: PPUSH
21607: CALL_OW 336
// end ; 4 :
21611: GO 21704
21613: LD_INT 4
21615: DOUBLE
21616: EQUAL
21617: IFTRUE 21621
21619: GO 21682
21621: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21622: LD_ADDR_VAR 0 2
21626: PUSH
21627: LD_INT 22
21629: PUSH
21630: LD_OWVAR 2
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: LD_INT 30
21641: PUSH
21642: LD_INT 29
21644: PUSH
21645: EMPTY
21646: LIST
21647: LIST
21648: PUSH
21649: EMPTY
21650: LIST
21651: LIST
21652: PPUSH
21653: CALL_OW 69
21657: ST_TO_ADDR
// if not tmp then
21658: LD_VAR 0 2
21662: NOT
21663: IFFALSE 21667
// exit ;
21665: GO 21704
// DestroyUnit ( tmp [ 1 ] ) ;
21667: LD_VAR 0 2
21671: PUSH
21672: LD_INT 1
21674: ARRAY
21675: PPUSH
21676: CALL_OW 65
// end ; 5 .. 7 :
21680: GO 21704
21682: LD_INT 5
21684: DOUBLE
21685: GREATEREQUAL
21686: IFFALSE 21694
21688: LD_INT 7
21690: DOUBLE
21691: LESSEQUAL
21692: IFTRUE 21696
21694: GO 21703
21696: POP
// StreamSibBomb ; end ;
21697: CALL 17954 0 0
21701: GO 21704
21703: POP
// end ;
21704: PPOPN 3
21706: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
21707: LD_EXP 43
21711: PUSH
21712: LD_EXP 93
21716: AND
21717: IFFALSE 21873
21719: GO 21721
21721: DISABLE
21722: LD_INT 0
21724: PPUSH
21725: PPUSH
21726: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
21727: LD_ADDR_VAR 0 2
21731: PUSH
21732: LD_INT 81
21734: PUSH
21735: LD_OWVAR 2
21739: PUSH
21740: EMPTY
21741: LIST
21742: LIST
21743: PUSH
21744: LD_INT 2
21746: PUSH
21747: LD_INT 21
21749: PUSH
21750: LD_INT 1
21752: PUSH
21753: EMPTY
21754: LIST
21755: LIST
21756: PUSH
21757: LD_INT 21
21759: PUSH
21760: LD_INT 2
21762: PUSH
21763: EMPTY
21764: LIST
21765: LIST
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: PUSH
21772: EMPTY
21773: LIST
21774: LIST
21775: PPUSH
21776: CALL_OW 69
21780: ST_TO_ADDR
// if not tmp then
21781: LD_VAR 0 2
21785: NOT
21786: IFFALSE 21790
// exit ;
21788: GO 21873
// p := 0 ;
21790: LD_ADDR_VAR 0 3
21794: PUSH
21795: LD_INT 0
21797: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21798: LD_INT 35
21800: PPUSH
21801: CALL_OW 67
// p := p + 1 ;
21805: LD_ADDR_VAR 0 3
21809: PUSH
21810: LD_VAR 0 3
21814: PUSH
21815: LD_INT 1
21817: PLUS
21818: ST_TO_ADDR
// for i in tmp do
21819: LD_ADDR_VAR 0 1
21823: PUSH
21824: LD_VAR 0 2
21828: PUSH
21829: FOR_IN
21830: IFFALSE 21861
// if GetLives ( i ) < 1000 then
21832: LD_VAR 0 1
21836: PPUSH
21837: CALL_OW 256
21841: PUSH
21842: LD_INT 1000
21844: LESS
21845: IFFALSE 21859
// SetLives ( i , 1000 ) ;
21847: LD_VAR 0 1
21851: PPUSH
21852: LD_INT 1000
21854: PPUSH
21855: CALL_OW 234
21859: GO 21829
21861: POP
21862: POP
// until p > 20 ;
21863: LD_VAR 0 3
21867: PUSH
21868: LD_INT 20
21870: GREATER
21871: IFFALSE 21798
// end ;
21873: PPOPN 3
21875: END
// every 0 0$1 trigger StreamModeActive and sTime do
21876: LD_EXP 43
21880: PUSH
21881: LD_EXP 94
21885: AND
21886: IFFALSE 21921
21888: GO 21890
21890: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21891: LD_INT 28
21893: PPUSH
21894: LD_OWVAR 2
21898: PPUSH
21899: LD_INT 2
21901: PPUSH
21902: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21906: LD_INT 30
21908: PPUSH
21909: LD_OWVAR 2
21913: PPUSH
21914: LD_INT 2
21916: PPUSH
21917: CALL_OW 322
// end ;
21921: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21922: LD_EXP 43
21926: PUSH
21927: LD_EXP 95
21931: AND
21932: IFFALSE 22053
21934: GO 21936
21936: DISABLE
21937: LD_INT 0
21939: PPUSH
21940: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21941: LD_ADDR_VAR 0 2
21945: PUSH
21946: LD_INT 22
21948: PUSH
21949: LD_OWVAR 2
21953: PUSH
21954: EMPTY
21955: LIST
21956: LIST
21957: PUSH
21958: LD_INT 21
21960: PUSH
21961: LD_INT 1
21963: PUSH
21964: EMPTY
21965: LIST
21966: LIST
21967: PUSH
21968: LD_INT 3
21970: PUSH
21971: LD_INT 23
21973: PUSH
21974: LD_INT 0
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: PUSH
21981: EMPTY
21982: LIST
21983: LIST
21984: PUSH
21985: EMPTY
21986: LIST
21987: LIST
21988: LIST
21989: PPUSH
21990: CALL_OW 69
21994: ST_TO_ADDR
// if not tmp then
21995: LD_VAR 0 2
21999: NOT
22000: IFFALSE 22004
// exit ;
22002: GO 22053
// for i in tmp do
22004: LD_ADDR_VAR 0 1
22008: PUSH
22009: LD_VAR 0 2
22013: PUSH
22014: FOR_IN
22015: IFFALSE 22051
// begin if Crawls ( i ) then
22017: LD_VAR 0 1
22021: PPUSH
22022: CALL_OW 318
22026: IFFALSE 22037
// ComWalk ( i ) ;
22028: LD_VAR 0 1
22032: PPUSH
22033: CALL_OW 138
// SetClass ( i , 2 ) ;
22037: LD_VAR 0 1
22041: PPUSH
22042: LD_INT 2
22044: PPUSH
22045: CALL_OW 336
// end ;
22049: GO 22014
22051: POP
22052: POP
// end ;
22053: PPOPN 2
22055: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
22056: LD_EXP 43
22060: PUSH
22061: LD_EXP 96
22065: AND
22066: IFFALSE 22347
22068: GO 22070
22070: DISABLE
22071: LD_INT 0
22073: PPUSH
22074: PPUSH
22075: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
22076: LD_OWVAR 2
22080: PPUSH
22081: LD_INT 9
22083: PPUSH
22084: LD_INT 1
22086: PPUSH
22087: LD_INT 1
22089: PPUSH
22090: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
22094: LD_INT 9
22096: PPUSH
22097: LD_OWVAR 2
22101: PPUSH
22102: CALL_OW 343
// uc_side := 9 ;
22106: LD_ADDR_OWVAR 20
22110: PUSH
22111: LD_INT 9
22113: ST_TO_ADDR
// uc_nation := 2 ;
22114: LD_ADDR_OWVAR 21
22118: PUSH
22119: LD_INT 2
22121: ST_TO_ADDR
// hc_name := Dark Warrior ;
22122: LD_ADDR_OWVAR 26
22126: PUSH
22127: LD_STRING Dark Warrior
22129: ST_TO_ADDR
// hc_gallery :=  ;
22130: LD_ADDR_OWVAR 33
22134: PUSH
22135: LD_STRING 
22137: ST_TO_ADDR
// hc_noskilllimit := true ;
22138: LD_ADDR_OWVAR 76
22142: PUSH
22143: LD_INT 1
22145: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
22146: LD_ADDR_OWVAR 31
22150: PUSH
22151: LD_INT 30
22153: PUSH
22154: LD_INT 30
22156: PUSH
22157: LD_INT 30
22159: PUSH
22160: LD_INT 30
22162: PUSH
22163: EMPTY
22164: LIST
22165: LIST
22166: LIST
22167: LIST
22168: ST_TO_ADDR
// un := CreateHuman ;
22169: LD_ADDR_VAR 0 3
22173: PUSH
22174: CALL_OW 44
22178: ST_TO_ADDR
// hc_noskilllimit := false ;
22179: LD_ADDR_OWVAR 76
22183: PUSH
22184: LD_INT 0
22186: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
22187: LD_VAR 0 3
22191: PPUSH
22192: LD_INT 1
22194: PPUSH
22195: CALL_OW 51
// p := 0 ;
22199: LD_ADDR_VAR 0 2
22203: PUSH
22204: LD_INT 0
22206: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22207: LD_INT 35
22209: PPUSH
22210: CALL_OW 67
// p := p + 1 ;
22214: LD_ADDR_VAR 0 2
22218: PUSH
22219: LD_VAR 0 2
22223: PUSH
22224: LD_INT 1
22226: PLUS
22227: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
22228: LD_VAR 0 3
22232: PPUSH
22233: CALL_OW 256
22237: PUSH
22238: LD_INT 1000
22240: LESS
22241: IFFALSE 22255
// SetLives ( un , 1000 ) ;
22243: LD_VAR 0 3
22247: PPUSH
22248: LD_INT 1000
22250: PPUSH
22251: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
22255: LD_VAR 0 3
22259: PPUSH
22260: LD_INT 81
22262: PUSH
22263: LD_OWVAR 2
22267: PUSH
22268: EMPTY
22269: LIST
22270: LIST
22271: PUSH
22272: LD_INT 91
22274: PUSH
22275: LD_VAR 0 3
22279: PUSH
22280: LD_INT 30
22282: PUSH
22283: EMPTY
22284: LIST
22285: LIST
22286: LIST
22287: PUSH
22288: EMPTY
22289: LIST
22290: LIST
22291: PPUSH
22292: CALL_OW 69
22296: PPUSH
22297: LD_VAR 0 3
22301: PPUSH
22302: CALL_OW 74
22306: PPUSH
22307: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
22311: LD_VAR 0 2
22315: PUSH
22316: LD_INT 60
22318: GREATER
22319: PUSH
22320: LD_VAR 0 3
22324: PPUSH
22325: CALL_OW 301
22329: OR
22330: IFFALSE 22207
// if un then
22332: LD_VAR 0 3
22336: IFFALSE 22347
// RemoveUnit ( un ) ;
22338: LD_VAR 0 3
22342: PPUSH
22343: CALL_OW 64
// end ; end_of_file
22347: PPOPN 3
22349: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
22350: LD_INT 0
22352: PPUSH
22353: PPUSH
22354: PPUSH
22355: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
22356: LD_VAR 0 1
22360: PPUSH
22361: CALL_OW 264
22365: PUSH
22366: LD_EXP 34
22370: EQUAL
22371: IFFALSE 22443
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
22373: LD_INT 68
22375: PPUSH
22376: LD_VAR 0 1
22380: PPUSH
22381: CALL_OW 255
22385: PPUSH
22386: CALL_OW 321
22390: PUSH
22391: LD_INT 2
22393: EQUAL
22394: IFFALSE 22406
// eff := 70 else
22396: LD_ADDR_VAR 0 4
22400: PUSH
22401: LD_INT 70
22403: ST_TO_ADDR
22404: GO 22414
// eff := 30 ;
22406: LD_ADDR_VAR 0 4
22410: PUSH
22411: LD_INT 30
22413: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
22414: LD_VAR 0 1
22418: PPUSH
22419: CALL_OW 250
22423: PPUSH
22424: LD_VAR 0 1
22428: PPUSH
22429: CALL_OW 251
22433: PPUSH
22434: LD_VAR 0 4
22438: PPUSH
22439: CALL_OW 495
// end ; end ;
22443: LD_VAR 0 2
22447: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
22448: LD_INT 0
22450: PPUSH
// end ;
22451: LD_VAR 0 4
22455: RET
// export function SOS_Command ( cmd ) ; begin
22456: LD_INT 0
22458: PPUSH
// end ;
22459: LD_VAR 0 2
22463: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
22464: LD_VAR 0 1
22468: PUSH
22469: LD_INT 255
22471: EQUAL
22472: PUSH
22473: LD_VAR 0 2
22477: PPUSH
22478: CALL_OW 264
22482: PUSH
22483: LD_INT 14
22485: PUSH
22486: LD_INT 53
22488: PUSH
22489: EMPTY
22490: LIST
22491: LIST
22492: IN
22493: AND
22494: PUSH
22495: LD_VAR 0 4
22499: PPUSH
22500: LD_VAR 0 5
22504: PPUSH
22505: CALL_OW 488
22509: AND
22510: IFFALSE 22534
// CutTreeXYR ( unit , x , y , 12 ) ;
22512: LD_VAR 0 2
22516: PPUSH
22517: LD_VAR 0 4
22521: PPUSH
22522: LD_VAR 0 5
22526: PPUSH
22527: LD_INT 12
22529: PPUSH
22530: CALL 22537 0 4
// end ;
22534: PPOPN 5
22536: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22537: LD_INT 0
22539: PPUSH
22540: PPUSH
22541: PPUSH
22542: PPUSH
22543: PPUSH
22544: PPUSH
22545: PPUSH
22546: PPUSH
22547: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22548: LD_VAR 0 1
22552: NOT
22553: PUSH
22554: LD_VAR 0 2
22558: PPUSH
22559: LD_VAR 0 3
22563: PPUSH
22564: CALL_OW 488
22568: NOT
22569: OR
22570: PUSH
22571: LD_VAR 0 4
22575: NOT
22576: OR
22577: IFFALSE 22581
// exit ;
22579: GO 22921
// list := [ ] ;
22581: LD_ADDR_VAR 0 13
22585: PUSH
22586: EMPTY
22587: ST_TO_ADDR
// if x - r < 0 then
22588: LD_VAR 0 2
22592: PUSH
22593: LD_VAR 0 4
22597: MINUS
22598: PUSH
22599: LD_INT 0
22601: LESS
22602: IFFALSE 22614
// min_x := 0 else
22604: LD_ADDR_VAR 0 7
22608: PUSH
22609: LD_INT 0
22611: ST_TO_ADDR
22612: GO 22630
// min_x := x - r ;
22614: LD_ADDR_VAR 0 7
22618: PUSH
22619: LD_VAR 0 2
22623: PUSH
22624: LD_VAR 0 4
22628: MINUS
22629: ST_TO_ADDR
// if y - r < 0 then
22630: LD_VAR 0 3
22634: PUSH
22635: LD_VAR 0 4
22639: MINUS
22640: PUSH
22641: LD_INT 0
22643: LESS
22644: IFFALSE 22656
// min_y := 0 else
22646: LD_ADDR_VAR 0 8
22650: PUSH
22651: LD_INT 0
22653: ST_TO_ADDR
22654: GO 22672
// min_y := y - r ;
22656: LD_ADDR_VAR 0 8
22660: PUSH
22661: LD_VAR 0 3
22665: PUSH
22666: LD_VAR 0 4
22670: MINUS
22671: ST_TO_ADDR
// max_x := x + r ;
22672: LD_ADDR_VAR 0 9
22676: PUSH
22677: LD_VAR 0 2
22681: PUSH
22682: LD_VAR 0 4
22686: PLUS
22687: ST_TO_ADDR
// max_y := y + r ;
22688: LD_ADDR_VAR 0 10
22692: PUSH
22693: LD_VAR 0 3
22697: PUSH
22698: LD_VAR 0 4
22702: PLUS
22703: ST_TO_ADDR
// for _x = min_x to max_x do
22704: LD_ADDR_VAR 0 11
22708: PUSH
22709: DOUBLE
22710: LD_VAR 0 7
22714: DEC
22715: ST_TO_ADDR
22716: LD_VAR 0 9
22720: PUSH
22721: FOR_TO
22722: IFFALSE 22839
// for _y = min_y to max_y do
22724: LD_ADDR_VAR 0 12
22728: PUSH
22729: DOUBLE
22730: LD_VAR 0 8
22734: DEC
22735: ST_TO_ADDR
22736: LD_VAR 0 10
22740: PUSH
22741: FOR_TO
22742: IFFALSE 22835
// begin if not ValidHex ( _x , _y ) then
22744: LD_VAR 0 11
22748: PPUSH
22749: LD_VAR 0 12
22753: PPUSH
22754: CALL_OW 488
22758: NOT
22759: IFFALSE 22763
// continue ;
22761: GO 22741
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22763: LD_VAR 0 11
22767: PPUSH
22768: LD_VAR 0 12
22772: PPUSH
22773: CALL_OW 351
22777: PUSH
22778: LD_VAR 0 11
22782: PPUSH
22783: LD_VAR 0 12
22787: PPUSH
22788: CALL_OW 554
22792: AND
22793: IFFALSE 22833
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22795: LD_ADDR_VAR 0 13
22799: PUSH
22800: LD_VAR 0 13
22804: PPUSH
22805: LD_VAR 0 13
22809: PUSH
22810: LD_INT 1
22812: PLUS
22813: PPUSH
22814: LD_VAR 0 11
22818: PUSH
22819: LD_VAR 0 12
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: PPUSH
22828: CALL_OW 2
22832: ST_TO_ADDR
// end ;
22833: GO 22741
22835: POP
22836: POP
22837: GO 22721
22839: POP
22840: POP
// if not list then
22841: LD_VAR 0 13
22845: NOT
22846: IFFALSE 22850
// exit ;
22848: GO 22921
// for i in list do
22850: LD_ADDR_VAR 0 6
22854: PUSH
22855: LD_VAR 0 13
22859: PUSH
22860: FOR_IN
22861: IFFALSE 22919
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22863: LD_VAR 0 1
22867: PPUSH
22868: LD_STRING M
22870: PUSH
22871: LD_VAR 0 6
22875: PUSH
22876: LD_INT 1
22878: ARRAY
22879: PUSH
22880: LD_VAR 0 6
22884: PUSH
22885: LD_INT 2
22887: ARRAY
22888: PUSH
22889: LD_INT 0
22891: PUSH
22892: LD_INT 0
22894: PUSH
22895: LD_INT 0
22897: PUSH
22898: LD_INT 0
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: LIST
22907: LIST
22908: LIST
22909: PUSH
22910: EMPTY
22911: LIST
22912: PPUSH
22913: CALL_OW 447
22917: GO 22860
22919: POP
22920: POP
// end ;
22921: LD_VAR 0 5
22925: RET
