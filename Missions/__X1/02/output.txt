// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 461 0 0
// PrepareAmericans ;
  23: CALL 633 0 0
// PrepareArabian ;
  27: CALL 1167 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 70 0 0
// Action ;
  41: CALL 861 0 0
// end ;
  45: END
// export debug , prefix ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := true ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 1
  56: ST_TO_ADDR
// prefix := 01 ;
  57: LD_ADDR_EXP 2
  61: PUSH
  62: LD_STRING 01
  64: ST_TO_ADDR
// end ;
  65: LD_VAR 0 1
  69: RET
// function DebugMode ; begin
  70: LD_INT 0
  72: PPUSH
// FogOff ( 1 ) ;
  73: LD_INT 1
  75: PPUSH
  76: CALL_OW 344
// Difficulty := 2 ;
  80: LD_ADDR_OWVAR 67
  84: PUSH
  85: LD_INT 2
  87: ST_TO_ADDR
// end ; end_of_file
  88: LD_VAR 0 1
  92: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
  93: LD_INT 0
  95: PPUSH
  96: PPUSH
// if exist_mode then
  97: LD_VAR 0 2
 101: IFFALSE 126
// unit := CreateCharacter ( prefix & ident ) else
 103: LD_ADDR_VAR 0 5
 107: PUSH
 108: LD_VAR 0 3
 112: PUSH
 113: LD_VAR 0 1
 117: STR
 118: PPUSH
 119: CALL_OW 34
 123: ST_TO_ADDR
 124: GO 141
// unit := NewCharacter ( ident ) ;
 126: LD_ADDR_VAR 0 5
 130: PUSH
 131: LD_VAR 0 1
 135: PPUSH
 136: CALL_OW 25
 140: ST_TO_ADDR
// result := unit ;
 141: LD_ADDR_VAR 0 4
 145: PUSH
 146: LD_VAR 0 5
 150: ST_TO_ADDR
// end ;
 151: LD_VAR 0 4
 155: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 156: LD_INT 0
 158: PPUSH
// uc_side := side ;
 159: LD_ADDR_OWVAR 20
 163: PUSH
 164: LD_VAR 0 1
 168: ST_TO_ADDR
// uc_nation := nation ;
 169: LD_ADDR_OWVAR 21
 173: PUSH
 174: LD_VAR 0 2
 178: ST_TO_ADDR
// vc_chassis := chassis ;
 179: LD_ADDR_OWVAR 37
 183: PUSH
 184: LD_VAR 0 3
 188: ST_TO_ADDR
// vc_engine := engine ;
 189: LD_ADDR_OWVAR 39
 193: PUSH
 194: LD_VAR 0 4
 198: ST_TO_ADDR
// vc_control := control ;
 199: LD_ADDR_OWVAR 38
 203: PUSH
 204: LD_VAR 0 5
 208: ST_TO_ADDR
// vc_weapon := weapon ;
 209: LD_ADDR_OWVAR 40
 213: PUSH
 214: LD_VAR 0 6
 218: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 219: LD_ADDR_OWVAR 41
 223: PUSH
 224: LD_VAR 0 7
 228: ST_TO_ADDR
// result := CreateVehicle ;
 229: LD_ADDR_VAR 0 8
 233: PUSH
 234: CALL_OW 45
 238: ST_TO_ADDR
// end ;
 239: LD_VAR 0 8
 243: RET
// export function SayX ( units , ident ) ; var i ; begin
 244: LD_INT 0
 246: PPUSH
 247: PPUSH
// result := false ;
 248: LD_ADDR_VAR 0 3
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// if not units then
 256: LD_VAR 0 1
 260: NOT
 261: IFFALSE 265
// exit ;
 263: GO 319
// for i in units do
 265: LD_ADDR_VAR 0 4
 269: PUSH
 270: LD_VAR 0 1
 274: PUSH
 275: FOR_IN
 276: IFFALSE 317
// if IsOk ( i ) then
 278: LD_VAR 0 4
 282: PPUSH
 283: CALL_OW 302
 287: IFFALSE 315
// begin Say ( i , ident ) ;
 289: LD_VAR 0 4
 293: PPUSH
 294: LD_VAR 0 2
 298: PPUSH
 299: CALL_OW 88
// result := i ;
 303: LD_ADDR_VAR 0 3
 307: PUSH
 308: LD_VAR 0 4
 312: ST_TO_ADDR
// break ;
 313: GO 317
// end ;
 315: GO 275
 317: POP
 318: POP
// end ;
 319: LD_VAR 0 3
 323: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 324: LD_INT 0
 326: PPUSH
 327: PPUSH
// InitUc ;
 328: CALL_OW 18
// InitHc ;
 332: CALL_OW 19
// uc_side := 0 ;
 336: LD_ADDR_OWVAR 20
 340: PUSH
 341: LD_INT 0
 343: ST_TO_ADDR
// uc_nation := 0 ;
 344: LD_ADDR_OWVAR 21
 348: PUSH
 349: LD_INT 0
 351: ST_TO_ADDR
// for i = 1 to amount do
 352: LD_ADDR_VAR 0 4
 356: PUSH
 357: DOUBLE
 358: LD_INT 1
 360: DEC
 361: ST_TO_ADDR
 362: LD_VAR 0 2
 366: PUSH
 367: FOR_TO
 368: IFFALSE 450
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 370: LD_ADDR_OWVAR 29
 374: PUSH
 375: LD_INT 9
 377: PPUSH
 378: LD_INT 12
 380: PPUSH
 381: CALL_OW 12
 385: PUSH
 386: LD_INT 9
 388: PPUSH
 389: LD_INT 12
 391: PPUSH
 392: CALL_OW 12
 396: PUSH
 397: EMPTY
 398: LIST
 399: LIST
 400: ST_TO_ADDR
// hc_agressivity := rand ( - 5 , 5 ) ;
 401: LD_ADDR_OWVAR 35
 405: PUSH
 406: LD_INT 5
 408: NEG
 409: PPUSH
 410: LD_INT 5
 412: PPUSH
 413: CALL_OW 12
 417: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 418: LD_INT 0
 420: PPUSH
 421: LD_INT 12
 423: PPUSH
 424: LD_INT 1
 426: PPUSH
 427: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 431: CALL_OW 44
 435: PPUSH
 436: LD_VAR 0 1
 440: PPUSH
 441: LD_INT 0
 443: PPUSH
 444: CALL_OW 49
// end ;
 448: GO 367
 450: POP
 451: POP
// InitHc ;
 452: CALL_OW 19
// end ;
 456: LD_VAR 0 3
 460: RET
// export function PrepareNature ; var i ; begin
 461: LD_INT 0
 463: PPUSH
 464: PPUSH
// SpawnApeman ( forest , 9 ) ;
 465: LD_INT 1
 467: PPUSH
 468: LD_INT 9
 470: PPUSH
 471: CALL 324 0 2
// for i := 1 to 4 do
 475: LD_ADDR_VAR 0 2
 479: PUSH
 480: DOUBLE
 481: LD_INT 1
 483: DEC
 484: ST_TO_ADDR
 485: LD_INT 4
 487: PUSH
 488: FOR_TO
 489: IFFALSE 524
// begin hc_class := 21 ;
 491: LD_ADDR_OWVAR 28
 495: PUSH
 496: LD_INT 21
 498: ST_TO_ADDR
// hc_gallery :=  ;
 499: LD_ADDR_OWVAR 33
 503: PUSH
 504: LD_STRING 
 506: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 507: CALL_OW 44
 511: PPUSH
 512: LD_INT 1
 514: PPUSH
 515: LD_INT 0
 517: PPUSH
 518: CALL_OW 49
// end ;
 522: GO 488
 524: POP
 525: POP
// for i := 1 to 2 do
 526: LD_ADDR_VAR 0 2
 530: PUSH
 531: DOUBLE
 532: LD_INT 1
 534: DEC
 535: ST_TO_ADDR
 536: LD_INT 2
 538: PUSH
 539: FOR_TO
 540: IFFALSE 575
// begin hc_class := 18 ;
 542: LD_ADDR_OWVAR 28
 546: PUSH
 547: LD_INT 18
 549: ST_TO_ADDR
// hc_gallery :=  ;
 550: LD_ADDR_OWVAR 33
 554: PUSH
 555: LD_STRING 
 557: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 558: CALL_OW 44
 562: PPUSH
 563: LD_INT 1
 565: PPUSH
 566: LD_INT 0
 568: PPUSH
 569: CALL_OW 49
// end ;
 573: GO 539
 575: POP
 576: POP
// for i := 1 to 3 do
 577: LD_ADDR_VAR 0 2
 581: PUSH
 582: DOUBLE
 583: LD_INT 1
 585: DEC
 586: ST_TO_ADDR
 587: LD_INT 3
 589: PUSH
 590: FOR_TO
 591: IFFALSE 626
// begin hc_class := 13 ;
 593: LD_ADDR_OWVAR 28
 597: PUSH
 598: LD_INT 13
 600: ST_TO_ADDR
// hc_gallery :=  ;
 601: LD_ADDR_OWVAR 33
 605: PUSH
 606: LD_STRING 
 608: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 609: CALL_OW 44
 613: PPUSH
 614: LD_INT 1
 616: PPUSH
 617: LD_INT 0
 619: PPUSH
 620: CALL_OW 49
// end ;
 624: GO 590
 626: POP
 627: POP
// end ; end_of_file
 628: LD_VAR 0 1
 632: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , veh , tmp ; begin
 633: LD_INT 0
 635: PPUSH
 636: PPUSH
 637: PPUSH
 638: PPUSH
// usForces := [ ] ;
 639: LD_ADDR_EXP 5
 643: PUSH
 644: EMPTY
 645: ST_TO_ADDR
// usSci := [ ] ;
 646: LD_ADDR_EXP 6
 650: PUSH
 651: EMPTY
 652: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 653: LD_INT 1
 655: PPUSH
 656: LD_STRING Delta
 658: PPUSH
 659: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 663: LD_INT 1
 665: PPUSH
 666: CALL_OW 274
 670: PPUSH
 671: LD_INT 1
 673: PPUSH
 674: LD_INT 400
 676: PPUSH
 677: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 681: LD_INT 1
 683: PPUSH
 684: CALL_OW 274
 688: PPUSH
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 80
 694: PPUSH
 695: CALL_OW 277
// uc_side := 1 ;
 699: LD_ADDR_OWVAR 20
 703: PUSH
 704: LD_INT 1
 706: ST_TO_ADDR
// uc_nation := 1 ;
 707: LD_ADDR_OWVAR 21
 711: PUSH
 712: LD_INT 1
 714: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 715: LD_ADDR_EXP 4
 719: PUSH
 720: LD_STRING Lynch
 722: PPUSH
 723: LD_INT 0
 725: PPUSH
 726: LD_STRING 
 728: PPUSH
 729: CALL 93 0 3
 733: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 734: LD_ADDR_EXP 3
 738: PUSH
 739: LD_STRING Gladstone
 741: PPUSH
 742: LD_INT 0
 744: PPUSH
 745: LD_STRING 
 747: PPUSH
 748: CALL 93 0 3
 752: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 753: LD_EXP 4
 757: PPUSH
 758: LD_INT 1
 760: PPUSH
 761: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 765: LD_EXP 3
 769: PPUSH
 770: LD_INT 3
 772: PPUSH
 773: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
 777: LD_ADDR_VAR 0 2
 781: PUSH
 782: DOUBLE
 783: LD_INT 1
 785: DEC
 786: ST_TO_ADDR
 787: LD_INT 1
 789: PUSH
 790: LD_INT 2
 792: PUSH
 793: LD_INT 2
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: LIST
 800: PUSH
 801: LD_OWVAR 67
 805: ARRAY
 806: PUSH
 807: FOR_TO
 808: IFFALSE 854
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
 810: LD_INT 0
 812: PPUSH
 813: LD_INT 2
 815: PPUSH
 816: LD_INT 1
 818: PUSH
 819: LD_INT 2
 821: PUSH
 822: LD_INT 2
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: PUSH
 830: LD_OWVAR 67
 834: ARRAY
 835: PPUSH
 836: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
 840: CALL_OW 44
 844: PPUSH
 845: LD_INT 1
 847: PPUSH
 848: CALL_OW 52
// end ;
 852: GO 807
 854: POP
 855: POP
// end ; end_of_file
 856: LD_VAR 0 1
 860: RET
// export function Action ; begin
 861: LD_INT 0
 863: PPUSH
// InGameOn ;
 864: CALL_OW 8
// ComMoveXY ( Heike , 81 , 65 ) ;
 868: LD_EXP 7
 872: PPUSH
 873: LD_INT 81
 875: PPUSH
 876: LD_INT 65
 878: PPUSH
 879: CALL_OW 111
// if Mike then
 883: LD_EXP 9
 887: IFFALSE 904
// ComMoveXY ( Mike , 81 , 68 ) ;
 889: LD_EXP 9
 893: PPUSH
 894: LD_INT 81
 896: PPUSH
 897: LD_INT 68
 899: PPUSH
 900: CALL_OW 111
// if Givi then
 904: LD_EXP 8
 908: IFFALSE 925
// ComMoveXY ( Givi , 85 , 72 ) ;
 910: LD_EXP 8
 914: PPUSH
 915: LD_INT 85
 917: PPUSH
 918: LD_INT 72
 920: PPUSH
 921: CALL_OW 111
// if Kamil then
 925: LD_EXP 10
 929: IFFALSE 946
// ComMoveXY ( Kamil , 83 , 73 ) ;
 931: LD_EXP 10
 935: PPUSH
 936: LD_INT 83
 938: PPUSH
 939: LD_INT 73
 941: PPUSH
 942: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
 946: LD_EXP 7
 950: PPUSH
 951: CALL_OW 87
// if Givi or Mike or Kamil then
 955: LD_EXP 8
 959: PUSH
 960: LD_EXP 9
 964: OR
 965: PUSH
 966: LD_EXP 10
 970: OR
 971: IFFALSE 1151
// begin if Givi then
 973: LD_EXP 8
 977: IFFALSE 1019
// begin AddComTurnUnit ( Givi , Heike ) ;
 979: LD_EXP 8
 983: PPUSH
 984: LD_EXP 7
 988: PPUSH
 989: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
 993: LD_EXP 7
 997: PPUSH
 998: LD_EXP 8
1002: PPUSH
1003: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
1007: LD_EXP 8
1011: PPUSH
1012: LD_STRING DG-1-start
1014: PPUSH
1015: CALL_OW 88
// end ; Say ( Heike , DH-1-start ) ;
1019: LD_EXP 7
1023: PPUSH
1024: LD_STRING DH-1-start
1026: PPUSH
1027: CALL_OW 88
// if Mike then
1031: LD_EXP 9
1035: IFFALSE 1077
// begin AddComTurnUnit ( Mike , Heike ) ;
1037: LD_EXP 9
1041: PPUSH
1042: LD_EXP 7
1046: PPUSH
1047: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
1051: LD_EXP 7
1055: PPUSH
1056: LD_EXP 9
1060: PPUSH
1061: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
1065: LD_EXP 9
1069: PPUSH
1070: LD_STRING DM-1-start
1072: PPUSH
1073: CALL_OW 88
// end ; if Givi or Mike then
1077: LD_EXP 8
1081: PUSH
1082: LD_EXP 9
1086: OR
1087: IFFALSE 1101
// Say ( Heike , DH-2-start ) ;
1089: LD_EXP 7
1093: PPUSH
1094: LD_STRING DH-2-start
1096: PPUSH
1097: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
1101: LD_EXP 9
1105: PPUSH
1106: LD_STRING DM-2-start
1108: PPUSH
1109: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
1113: LD_EXP 8
1117: PPUSH
1118: LD_STRING DG-2-start
1120: PPUSH
1121: CALL_OW 88
// Say ( Mike , DM-3-start ) ;
1125: LD_EXP 9
1129: PPUSH
1130: LD_STRING DM-3-start
1132: PPUSH
1133: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
1137: LD_EXP 7
1141: PPUSH
1142: LD_STRING DH-3-start
1144: PPUSH
1145: CALL_OW 88
// end else
1149: GO 1151
// begin end ; InGameOff ;
1151: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
1155: LD_STRING OEast
1157: PPUSH
1158: CALL_OW 337
// end ; end_of_file
1162: LD_VAR 0 1
1166: RET
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia ; export function PrepareArabian ; begin
1167: LD_INT 0
1169: PPUSH
// uc_side := 2 ;
1170: LD_ADDR_OWVAR 20
1174: PUSH
1175: LD_INT 2
1177: ST_TO_ADDR
// uc_nation := 2 ;
1178: LD_ADDR_OWVAR 21
1182: PUSH
1183: LD_INT 2
1185: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
1186: LD_ADDR_EXP 7
1190: PUSH
1191: LD_STRING Heike
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_EXP 2
1204: PPUSH
1205: CALL 93 0 3
1209: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
1210: LD_EXP 7
1214: PPUSH
1215: LD_INT 83
1217: PPUSH
1218: LD_INT 72
1220: PPUSH
1221: LD_INT 0
1223: PPUSH
1224: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
1228: LD_ADDR_EXP 8
1232: PUSH
1233: LD_STRING Givi
1235: PPUSH
1236: LD_EXP 1
1240: NOT
1241: PPUSH
1242: LD_EXP 2
1246: PPUSH
1247: CALL 93 0 3
1251: ST_TO_ADDR
// if Givi then
1252: LD_EXP 8
1256: IFFALSE 1276
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
1258: LD_EXP 8
1262: PPUSH
1263: LD_INT 87
1265: PPUSH
1266: LD_INT 76
1268: PPUSH
1269: LD_INT 0
1271: PPUSH
1272: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
1276: LD_ADDR_EXP 9
1280: PUSH
1281: LD_STRING Mike
1283: PPUSH
1284: LD_EXP 1
1288: NOT
1289: PPUSH
1290: LD_EXP 2
1294: PPUSH
1295: CALL 93 0 3
1299: ST_TO_ADDR
// if Mike then
1300: LD_EXP 9
1304: IFFALSE 1324
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
1306: LD_EXP 9
1310: PPUSH
1311: LD_INT 84
1313: PPUSH
1314: LD_INT 76
1316: PPUSH
1317: LD_INT 0
1319: PPUSH
1320: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
1324: LD_ADDR_EXP 10
1328: PUSH
1329: LD_STRING Kamil
1331: PPUSH
1332: LD_EXP 1
1336: NOT
1337: PPUSH
1338: LD_EXP 2
1342: PPUSH
1343: CALL 93 0 3
1347: ST_TO_ADDR
// if Kamil then
1348: LD_EXP 10
1352: IFFALSE 1372
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
1354: LD_EXP 10
1358: PPUSH
1359: LD_INT 85
1361: PPUSH
1362: LD_INT 78
1364: PPUSH
1365: LD_INT 0
1367: PPUSH
1368: CALL_OW 48
// end ; end_of_file end_of_file
1372: LD_VAR 0 1
1376: RET
// on UnitDestroyed ( un ) do begin end ; end_of_file
1377: PPOPN 1
1379: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
1380: GO 1382
1382: DISABLE
// begin ru_radar := 98 ;
1383: LD_ADDR_EXP 13
1387: PUSH
1388: LD_INT 98
1390: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
1391: LD_ADDR_EXP 14
1395: PUSH
1396: LD_INT 89
1398: ST_TO_ADDR
// us_hack := 99 ;
1399: LD_ADDR_EXP 15
1403: PUSH
1404: LD_INT 99
1406: ST_TO_ADDR
// us_artillery := 97 ;
1407: LD_ADDR_EXP 16
1411: PUSH
1412: LD_INT 97
1414: ST_TO_ADDR
// ar_bio_bomb := 91 ;
1415: LD_ADDR_EXP 17
1419: PUSH
1420: LD_INT 91
1422: ST_TO_ADDR
// end ; end_of_file end_of_file
1423: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
1424: GO 1426
1426: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
1427: LD_STRING initStreamRollete();
1429: PPUSH
1430: CALL_OW 559
// InitStreamMode ;
1434: CALL 1443 0 0
// DefineStreamItems ( ) ;
1438: CALL 1883 0 0
// end ;
1442: END
// function InitStreamMode ; begin
1443: LD_INT 0
1445: PPUSH
// streamModeActive := false ;
1446: LD_ADDR_EXP 18
1450: PUSH
1451: LD_INT 0
1453: ST_TO_ADDR
// normalCounter := 36 ;
1454: LD_ADDR_EXP 19
1458: PUSH
1459: LD_INT 36
1461: ST_TO_ADDR
// hardcoreCounter := 16 ;
1462: LD_ADDR_EXP 20
1466: PUSH
1467: LD_INT 16
1469: ST_TO_ADDR
// sRocket := false ;
1470: LD_ADDR_EXP 23
1474: PUSH
1475: LD_INT 0
1477: ST_TO_ADDR
// sSpeed := false ;
1478: LD_ADDR_EXP 22
1482: PUSH
1483: LD_INT 0
1485: ST_TO_ADDR
// sEngine := false ;
1486: LD_ADDR_EXP 24
1490: PUSH
1491: LD_INT 0
1493: ST_TO_ADDR
// sSpec := false ;
1494: LD_ADDR_EXP 21
1498: PUSH
1499: LD_INT 0
1501: ST_TO_ADDR
// sLevel := false ;
1502: LD_ADDR_EXP 25
1506: PUSH
1507: LD_INT 0
1509: ST_TO_ADDR
// sArmoury := false ;
1510: LD_ADDR_EXP 26
1514: PUSH
1515: LD_INT 0
1517: ST_TO_ADDR
// sRadar := false ;
1518: LD_ADDR_EXP 27
1522: PUSH
1523: LD_INT 0
1525: ST_TO_ADDR
// sBunker := false ;
1526: LD_ADDR_EXP 28
1530: PUSH
1531: LD_INT 0
1533: ST_TO_ADDR
// sHack := false ;
1534: LD_ADDR_EXP 29
1538: PUSH
1539: LD_INT 0
1541: ST_TO_ADDR
// sFire := false ;
1542: LD_ADDR_EXP 30
1546: PUSH
1547: LD_INT 0
1549: ST_TO_ADDR
// sRefresh := false ;
1550: LD_ADDR_EXP 31
1554: PUSH
1555: LD_INT 0
1557: ST_TO_ADDR
// sExp := false ;
1558: LD_ADDR_EXP 32
1562: PUSH
1563: LD_INT 0
1565: ST_TO_ADDR
// sDepot := false ;
1566: LD_ADDR_EXP 33
1570: PUSH
1571: LD_INT 0
1573: ST_TO_ADDR
// sFlag := false ;
1574: LD_ADDR_EXP 34
1578: PUSH
1579: LD_INT 0
1581: ST_TO_ADDR
// sKamikadze := false ;
1582: LD_ADDR_EXP 42
1586: PUSH
1587: LD_INT 0
1589: ST_TO_ADDR
// sTroll := false ;
1590: LD_ADDR_EXP 43
1594: PUSH
1595: LD_INT 0
1597: ST_TO_ADDR
// sSlow := false ;
1598: LD_ADDR_EXP 44
1602: PUSH
1603: LD_INT 0
1605: ST_TO_ADDR
// sLack := false ;
1606: LD_ADDR_EXP 45
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// sTank := false ;
1614: LD_ADDR_EXP 47
1618: PUSH
1619: LD_INT 0
1621: ST_TO_ADDR
// sRemote := false ;
1622: LD_ADDR_EXP 48
1626: PUSH
1627: LD_INT 0
1629: ST_TO_ADDR
// sPowell := false ;
1630: LD_ADDR_EXP 49
1634: PUSH
1635: LD_INT 0
1637: ST_TO_ADDR
// sTeleport := false ;
1638: LD_ADDR_EXP 52
1642: PUSH
1643: LD_INT 0
1645: ST_TO_ADDR
// sOilTower := false ;
1646: LD_ADDR_EXP 54
1650: PUSH
1651: LD_INT 0
1653: ST_TO_ADDR
// sShovel := false ;
1654: LD_ADDR_EXP 55
1658: PUSH
1659: LD_INT 0
1661: ST_TO_ADDR
// sSheik := false ;
1662: LD_ADDR_EXP 56
1666: PUSH
1667: LD_INT 0
1669: ST_TO_ADDR
// sEarthquake := false ;
1670: LD_ADDR_EXP 58
1674: PUSH
1675: LD_INT 0
1677: ST_TO_ADDR
// sAI := false ;
1678: LD_ADDR_EXP 59
1682: PUSH
1683: LD_INT 0
1685: ST_TO_ADDR
// sCargo := false ;
1686: LD_ADDR_EXP 62
1690: PUSH
1691: LD_INT 0
1693: ST_TO_ADDR
// sDLaser := false ;
1694: LD_ADDR_EXP 63
1698: PUSH
1699: LD_INT 0
1701: ST_TO_ADDR
// sExchange := false ;
1702: LD_ADDR_EXP 64
1706: PUSH
1707: LD_INT 0
1709: ST_TO_ADDR
// sFac := false ;
1710: LD_ADDR_EXP 65
1714: PUSH
1715: LD_INT 0
1717: ST_TO_ADDR
// sPower := false ;
1718: LD_ADDR_EXP 66
1722: PUSH
1723: LD_INT 0
1725: ST_TO_ADDR
// sRandom := false ;
1726: LD_ADDR_EXP 67
1730: PUSH
1731: LD_INT 0
1733: ST_TO_ADDR
// sShield := false ;
1734: LD_ADDR_EXP 68
1738: PUSH
1739: LD_INT 0
1741: ST_TO_ADDR
// sTime := false ;
1742: LD_ADDR_EXP 69
1746: PUSH
1747: LD_INT 0
1749: ST_TO_ADDR
// sTools := false ;
1750: LD_ADDR_EXP 70
1754: PUSH
1755: LD_INT 0
1757: ST_TO_ADDR
// sSold := false ;
1758: LD_ADDR_EXP 35
1762: PUSH
1763: LD_INT 0
1765: ST_TO_ADDR
// sDiff := false ;
1766: LD_ADDR_EXP 36
1770: PUSH
1771: LD_INT 0
1773: ST_TO_ADDR
// sFog := false ;
1774: LD_ADDR_EXP 39
1778: PUSH
1779: LD_INT 0
1781: ST_TO_ADDR
// sReset := false ;
1782: LD_ADDR_EXP 40
1786: PUSH
1787: LD_INT 0
1789: ST_TO_ADDR
// sSun := false ;
1790: LD_ADDR_EXP 41
1794: PUSH
1795: LD_INT 0
1797: ST_TO_ADDR
// sTiger := false ;
1798: LD_ADDR_EXP 37
1802: PUSH
1803: LD_INT 0
1805: ST_TO_ADDR
// sBomb := false ;
1806: LD_ADDR_EXP 38
1810: PUSH
1811: LD_INT 0
1813: ST_TO_ADDR
// sWound := false ;
1814: LD_ADDR_EXP 46
1818: PUSH
1819: LD_INT 0
1821: ST_TO_ADDR
// sBetray := false ;
1822: LD_ADDR_EXP 50
1826: PUSH
1827: LD_INT 0
1829: ST_TO_ADDR
// sContamin := false ;
1830: LD_ADDR_EXP 51
1834: PUSH
1835: LD_INT 0
1837: ST_TO_ADDR
// sOil := false ;
1838: LD_ADDR_EXP 53
1842: PUSH
1843: LD_INT 0
1845: ST_TO_ADDR
// sStu := false ;
1846: LD_ADDR_EXP 57
1850: PUSH
1851: LD_INT 0
1853: ST_TO_ADDR
// sBazooka := false ;
1854: LD_ADDR_EXP 60
1858: PUSH
1859: LD_INT 0
1861: ST_TO_ADDR
// sMortar := false ;
1862: LD_ADDR_EXP 61
1866: PUSH
1867: LD_INT 0
1869: ST_TO_ADDR
// sRanger := false ;
1870: LD_ADDR_EXP 71
1874: PUSH
1875: LD_INT 0
1877: ST_TO_ADDR
// end ;
1878: LD_VAR 0 1
1882: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
1883: LD_INT 0
1885: PPUSH
1886: PPUSH
1887: PPUSH
1888: PPUSH
1889: PPUSH
// result := [ ] ;
1890: LD_ADDR_VAR 0 1
1894: PUSH
1895: EMPTY
1896: ST_TO_ADDR
// if campaign_id = 1 then
1897: LD_OWVAR 69
1901: PUSH
1902: LD_INT 1
1904: EQUAL
1905: IFFALSE 4843
// begin case mission_number of 1 :
1907: LD_OWVAR 70
1911: PUSH
1912: LD_INT 1
1914: DOUBLE
1915: EQUAL
1916: IFTRUE 1920
1918: GO 1984
1920: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
1921: LD_ADDR_VAR 0 1
1925: PUSH
1926: LD_INT 2
1928: PUSH
1929: LD_INT 4
1931: PUSH
1932: LD_INT 11
1934: PUSH
1935: LD_INT 12
1937: PUSH
1938: LD_INT 15
1940: PUSH
1941: LD_INT 16
1943: PUSH
1944: LD_INT 22
1946: PUSH
1947: LD_INT 23
1949: PUSH
1950: LD_INT 26
1952: PUSH
1953: EMPTY
1954: LIST
1955: LIST
1956: LIST
1957: LIST
1958: LIST
1959: LIST
1960: LIST
1961: LIST
1962: LIST
1963: PUSH
1964: LD_INT 101
1966: PUSH
1967: LD_INT 102
1969: PUSH
1970: LD_INT 106
1972: PUSH
1973: EMPTY
1974: LIST
1975: LIST
1976: LIST
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: ST_TO_ADDR
1982: GO 4841
1984: LD_INT 2
1986: DOUBLE
1987: EQUAL
1988: IFTRUE 1992
1990: GO 2064
1992: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
1993: LD_ADDR_VAR 0 1
1997: PUSH
1998: LD_INT 2
2000: PUSH
2001: LD_INT 4
2003: PUSH
2004: LD_INT 11
2006: PUSH
2007: LD_INT 12
2009: PUSH
2010: LD_INT 15
2012: PUSH
2013: LD_INT 16
2015: PUSH
2016: LD_INT 22
2018: PUSH
2019: LD_INT 23
2021: PUSH
2022: LD_INT 26
2024: PUSH
2025: EMPTY
2026: LIST
2027: LIST
2028: LIST
2029: LIST
2030: LIST
2031: LIST
2032: LIST
2033: LIST
2034: LIST
2035: PUSH
2036: LD_INT 101
2038: PUSH
2039: LD_INT 102
2041: PUSH
2042: LD_INT 105
2044: PUSH
2045: LD_INT 106
2047: PUSH
2048: LD_INT 108
2050: PUSH
2051: EMPTY
2052: LIST
2053: LIST
2054: LIST
2055: LIST
2056: LIST
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: ST_TO_ADDR
2062: GO 4841
2064: LD_INT 3
2066: DOUBLE
2067: EQUAL
2068: IFTRUE 2072
2070: GO 2148
2072: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
2073: LD_ADDR_VAR 0 1
2077: PUSH
2078: LD_INT 2
2080: PUSH
2081: LD_INT 4
2083: PUSH
2084: LD_INT 5
2086: PUSH
2087: LD_INT 11
2089: PUSH
2090: LD_INT 12
2092: PUSH
2093: LD_INT 15
2095: PUSH
2096: LD_INT 16
2098: PUSH
2099: LD_INT 22
2101: PUSH
2102: LD_INT 26
2104: PUSH
2105: LD_INT 36
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: PUSH
2120: LD_INT 101
2122: PUSH
2123: LD_INT 102
2125: PUSH
2126: LD_INT 105
2128: PUSH
2129: LD_INT 106
2131: PUSH
2132: LD_INT 108
2134: PUSH
2135: EMPTY
2136: LIST
2137: LIST
2138: LIST
2139: LIST
2140: LIST
2141: PUSH
2142: EMPTY
2143: LIST
2144: LIST
2145: ST_TO_ADDR
2146: GO 4841
2148: LD_INT 4
2150: DOUBLE
2151: EQUAL
2152: IFTRUE 2156
2154: GO 2240
2156: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
2157: LD_ADDR_VAR 0 1
2161: PUSH
2162: LD_INT 2
2164: PUSH
2165: LD_INT 4
2167: PUSH
2168: LD_INT 5
2170: PUSH
2171: LD_INT 8
2173: PUSH
2174: LD_INT 11
2176: PUSH
2177: LD_INT 12
2179: PUSH
2180: LD_INT 15
2182: PUSH
2183: LD_INT 16
2185: PUSH
2186: LD_INT 22
2188: PUSH
2189: LD_INT 23
2191: PUSH
2192: LD_INT 26
2194: PUSH
2195: LD_INT 36
2197: PUSH
2198: EMPTY
2199: LIST
2200: LIST
2201: LIST
2202: LIST
2203: LIST
2204: LIST
2205: LIST
2206: LIST
2207: LIST
2208: LIST
2209: LIST
2210: LIST
2211: PUSH
2212: LD_INT 101
2214: PUSH
2215: LD_INT 102
2217: PUSH
2218: LD_INT 105
2220: PUSH
2221: LD_INT 106
2223: PUSH
2224: LD_INT 108
2226: PUSH
2227: EMPTY
2228: LIST
2229: LIST
2230: LIST
2231: LIST
2232: LIST
2233: PUSH
2234: EMPTY
2235: LIST
2236: LIST
2237: ST_TO_ADDR
2238: GO 4841
2240: LD_INT 5
2242: DOUBLE
2243: EQUAL
2244: IFTRUE 2248
2246: GO 2348
2248: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
2249: LD_ADDR_VAR 0 1
2253: PUSH
2254: LD_INT 2
2256: PUSH
2257: LD_INT 4
2259: PUSH
2260: LD_INT 5
2262: PUSH
2263: LD_INT 6
2265: PUSH
2266: LD_INT 8
2268: PUSH
2269: LD_INT 11
2271: PUSH
2272: LD_INT 12
2274: PUSH
2275: LD_INT 15
2277: PUSH
2278: LD_INT 16
2280: PUSH
2281: LD_INT 22
2283: PUSH
2284: LD_INT 23
2286: PUSH
2287: LD_INT 25
2289: PUSH
2290: LD_INT 26
2292: PUSH
2293: LD_INT 36
2295: PUSH
2296: EMPTY
2297: LIST
2298: LIST
2299: LIST
2300: LIST
2301: LIST
2302: LIST
2303: LIST
2304: LIST
2305: LIST
2306: LIST
2307: LIST
2308: LIST
2309: LIST
2310: LIST
2311: PUSH
2312: LD_INT 101
2314: PUSH
2315: LD_INT 102
2317: PUSH
2318: LD_INT 105
2320: PUSH
2321: LD_INT 106
2323: PUSH
2324: LD_INT 108
2326: PUSH
2327: LD_INT 109
2329: PUSH
2330: LD_INT 112
2332: PUSH
2333: EMPTY
2334: LIST
2335: LIST
2336: LIST
2337: LIST
2338: LIST
2339: LIST
2340: LIST
2341: PUSH
2342: EMPTY
2343: LIST
2344: LIST
2345: ST_TO_ADDR
2346: GO 4841
2348: LD_INT 6
2350: DOUBLE
2351: EQUAL
2352: IFTRUE 2356
2354: GO 2476
2356: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
2357: LD_ADDR_VAR 0 1
2361: PUSH
2362: LD_INT 2
2364: PUSH
2365: LD_INT 4
2367: PUSH
2368: LD_INT 5
2370: PUSH
2371: LD_INT 6
2373: PUSH
2374: LD_INT 8
2376: PUSH
2377: LD_INT 11
2379: PUSH
2380: LD_INT 12
2382: PUSH
2383: LD_INT 15
2385: PUSH
2386: LD_INT 16
2388: PUSH
2389: LD_INT 20
2391: PUSH
2392: LD_INT 21
2394: PUSH
2395: LD_INT 22
2397: PUSH
2398: LD_INT 23
2400: PUSH
2401: LD_INT 25
2403: PUSH
2404: LD_INT 26
2406: PUSH
2407: LD_INT 30
2409: PUSH
2410: LD_INT 31
2412: PUSH
2413: LD_INT 32
2415: PUSH
2416: LD_INT 36
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: LIST
2426: LIST
2427: LIST
2428: LIST
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: LIST
2436: LIST
2437: LIST
2438: LIST
2439: PUSH
2440: LD_INT 101
2442: PUSH
2443: LD_INT 102
2445: PUSH
2446: LD_INT 105
2448: PUSH
2449: LD_INT 106
2451: PUSH
2452: LD_INT 108
2454: PUSH
2455: LD_INT 109
2457: PUSH
2458: LD_INT 112
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: LIST
2469: PUSH
2470: EMPTY
2471: LIST
2472: LIST
2473: ST_TO_ADDR
2474: GO 4841
2476: LD_INT 7
2478: DOUBLE
2479: EQUAL
2480: IFTRUE 2484
2482: GO 2584
2484: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
2485: LD_ADDR_VAR 0 1
2489: PUSH
2490: LD_INT 2
2492: PUSH
2493: LD_INT 4
2495: PUSH
2496: LD_INT 5
2498: PUSH
2499: LD_INT 7
2501: PUSH
2502: LD_INT 11
2504: PUSH
2505: LD_INT 12
2507: PUSH
2508: LD_INT 15
2510: PUSH
2511: LD_INT 16
2513: PUSH
2514: LD_INT 20
2516: PUSH
2517: LD_INT 21
2519: PUSH
2520: LD_INT 22
2522: PUSH
2523: LD_INT 23
2525: PUSH
2526: LD_INT 25
2528: PUSH
2529: LD_INT 26
2531: PUSH
2532: EMPTY
2533: LIST
2534: LIST
2535: LIST
2536: LIST
2537: LIST
2538: LIST
2539: LIST
2540: LIST
2541: LIST
2542: LIST
2543: LIST
2544: LIST
2545: LIST
2546: LIST
2547: PUSH
2548: LD_INT 101
2550: PUSH
2551: LD_INT 102
2553: PUSH
2554: LD_INT 103
2556: PUSH
2557: LD_INT 105
2559: PUSH
2560: LD_INT 106
2562: PUSH
2563: LD_INT 108
2565: PUSH
2566: LD_INT 112
2568: PUSH
2569: EMPTY
2570: LIST
2571: LIST
2572: LIST
2573: LIST
2574: LIST
2575: LIST
2576: LIST
2577: PUSH
2578: EMPTY
2579: LIST
2580: LIST
2581: ST_TO_ADDR
2582: GO 4841
2584: LD_INT 8
2586: DOUBLE
2587: EQUAL
2588: IFTRUE 2592
2590: GO 2720
2592: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
2593: LD_ADDR_VAR 0 1
2597: PUSH
2598: LD_INT 2
2600: PUSH
2601: LD_INT 4
2603: PUSH
2604: LD_INT 5
2606: PUSH
2607: LD_INT 6
2609: PUSH
2610: LD_INT 7
2612: PUSH
2613: LD_INT 8
2615: PUSH
2616: LD_INT 11
2618: PUSH
2619: LD_INT 12
2621: PUSH
2622: LD_INT 15
2624: PUSH
2625: LD_INT 16
2627: PUSH
2628: LD_INT 20
2630: PUSH
2631: LD_INT 21
2633: PUSH
2634: LD_INT 22
2636: PUSH
2637: LD_INT 23
2639: PUSH
2640: LD_INT 25
2642: PUSH
2643: LD_INT 26
2645: PUSH
2646: LD_INT 30
2648: PUSH
2649: LD_INT 31
2651: PUSH
2652: LD_INT 32
2654: PUSH
2655: LD_INT 36
2657: PUSH
2658: EMPTY
2659: LIST
2660: LIST
2661: LIST
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: LIST
2667: LIST
2668: LIST
2669: LIST
2670: LIST
2671: LIST
2672: LIST
2673: LIST
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: LIST
2679: PUSH
2680: LD_INT 101
2682: PUSH
2683: LD_INT 102
2685: PUSH
2686: LD_INT 103
2688: PUSH
2689: LD_INT 105
2691: PUSH
2692: LD_INT 106
2694: PUSH
2695: LD_INT 108
2697: PUSH
2698: LD_INT 109
2700: PUSH
2701: LD_INT 112
2703: PUSH
2704: EMPTY
2705: LIST
2706: LIST
2707: LIST
2708: LIST
2709: LIST
2710: LIST
2711: LIST
2712: LIST
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: ST_TO_ADDR
2718: GO 4841
2720: LD_INT 9
2722: DOUBLE
2723: EQUAL
2724: IFTRUE 2728
2726: GO 2864
2728: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
2729: LD_ADDR_VAR 0 1
2733: PUSH
2734: LD_INT 2
2736: PUSH
2737: LD_INT 4
2739: PUSH
2740: LD_INT 5
2742: PUSH
2743: LD_INT 6
2745: PUSH
2746: LD_INT 7
2748: PUSH
2749: LD_INT 8
2751: PUSH
2752: LD_INT 11
2754: PUSH
2755: LD_INT 12
2757: PUSH
2758: LD_INT 15
2760: PUSH
2761: LD_INT 16
2763: PUSH
2764: LD_INT 20
2766: PUSH
2767: LD_INT 21
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 23
2775: PUSH
2776: LD_INT 25
2778: PUSH
2779: LD_INT 26
2781: PUSH
2782: LD_INT 28
2784: PUSH
2785: LD_INT 30
2787: PUSH
2788: LD_INT 31
2790: PUSH
2791: LD_INT 32
2793: PUSH
2794: LD_INT 36
2796: PUSH
2797: EMPTY
2798: LIST
2799: LIST
2800: LIST
2801: LIST
2802: LIST
2803: LIST
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: LIST
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: PUSH
2820: LD_INT 101
2822: PUSH
2823: LD_INT 102
2825: PUSH
2826: LD_INT 103
2828: PUSH
2829: LD_INT 105
2831: PUSH
2832: LD_INT 106
2834: PUSH
2835: LD_INT 108
2837: PUSH
2838: LD_INT 109
2840: PUSH
2841: LD_INT 112
2843: PUSH
2844: LD_INT 114
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: LIST
2851: LIST
2852: LIST
2853: LIST
2854: LIST
2855: LIST
2856: LIST
2857: PUSH
2858: EMPTY
2859: LIST
2860: LIST
2861: ST_TO_ADDR
2862: GO 4841
2864: LD_INT 10
2866: DOUBLE
2867: EQUAL
2868: IFTRUE 2872
2870: GO 3056
2872: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
2873: LD_ADDR_VAR 0 1
2877: PUSH
2878: LD_INT 2
2880: PUSH
2881: LD_INT 4
2883: PUSH
2884: LD_INT 5
2886: PUSH
2887: LD_INT 6
2889: PUSH
2890: LD_INT 7
2892: PUSH
2893: LD_INT 8
2895: PUSH
2896: LD_INT 9
2898: PUSH
2899: LD_INT 10
2901: PUSH
2902: LD_INT 11
2904: PUSH
2905: LD_INT 12
2907: PUSH
2908: LD_INT 13
2910: PUSH
2911: LD_INT 14
2913: PUSH
2914: LD_INT 15
2916: PUSH
2917: LD_INT 16
2919: PUSH
2920: LD_INT 17
2922: PUSH
2923: LD_INT 18
2925: PUSH
2926: LD_INT 19
2928: PUSH
2929: LD_INT 20
2931: PUSH
2932: LD_INT 21
2934: PUSH
2935: LD_INT 22
2937: PUSH
2938: LD_INT 23
2940: PUSH
2941: LD_INT 24
2943: PUSH
2944: LD_INT 25
2946: PUSH
2947: LD_INT 26
2949: PUSH
2950: LD_INT 28
2952: PUSH
2953: LD_INT 30
2955: PUSH
2956: LD_INT 31
2958: PUSH
2959: LD_INT 32
2961: PUSH
2962: LD_INT 36
2964: PUSH
2965: EMPTY
2966: LIST
2967: LIST
2968: LIST
2969: LIST
2970: LIST
2971: LIST
2972: LIST
2973: LIST
2974: LIST
2975: LIST
2976: LIST
2977: LIST
2978: LIST
2979: LIST
2980: LIST
2981: LIST
2982: LIST
2983: LIST
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: LIST
2995: PUSH
2996: LD_INT 101
2998: PUSH
2999: LD_INT 102
3001: PUSH
3002: LD_INT 103
3004: PUSH
3005: LD_INT 104
3007: PUSH
3008: LD_INT 105
3010: PUSH
3011: LD_INT 106
3013: PUSH
3014: LD_INT 107
3016: PUSH
3017: LD_INT 108
3019: PUSH
3020: LD_INT 109
3022: PUSH
3023: LD_INT 110
3025: PUSH
3026: LD_INT 111
3028: PUSH
3029: LD_INT 112
3031: PUSH
3032: LD_INT 114
3034: PUSH
3035: EMPTY
3036: LIST
3037: LIST
3038: LIST
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: LIST
3047: LIST
3048: LIST
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: ST_TO_ADDR
3054: GO 4841
3056: LD_INT 11
3058: DOUBLE
3059: EQUAL
3060: IFTRUE 3064
3062: GO 3256
3064: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
3065: LD_ADDR_VAR 0 1
3069: PUSH
3070: LD_INT 2
3072: PUSH
3073: LD_INT 3
3075: PUSH
3076: LD_INT 4
3078: PUSH
3079: LD_INT 5
3081: PUSH
3082: LD_INT 6
3084: PUSH
3085: LD_INT 7
3087: PUSH
3088: LD_INT 8
3090: PUSH
3091: LD_INT 9
3093: PUSH
3094: LD_INT 10
3096: PUSH
3097: LD_INT 11
3099: PUSH
3100: LD_INT 12
3102: PUSH
3103: LD_INT 13
3105: PUSH
3106: LD_INT 14
3108: PUSH
3109: LD_INT 15
3111: PUSH
3112: LD_INT 16
3114: PUSH
3115: LD_INT 17
3117: PUSH
3118: LD_INT 18
3120: PUSH
3121: LD_INT 19
3123: PUSH
3124: LD_INT 20
3126: PUSH
3127: LD_INT 21
3129: PUSH
3130: LD_INT 22
3132: PUSH
3133: LD_INT 23
3135: PUSH
3136: LD_INT 24
3138: PUSH
3139: LD_INT 25
3141: PUSH
3142: LD_INT 26
3144: PUSH
3145: LD_INT 28
3147: PUSH
3148: LD_INT 30
3150: PUSH
3151: LD_INT 31
3153: PUSH
3154: LD_INT 32
3156: PUSH
3157: LD_INT 34
3159: PUSH
3160: LD_INT 36
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: LIST
3186: LIST
3187: LIST
3188: LIST
3189: LIST
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: LIST
3195: PUSH
3196: LD_INT 101
3198: PUSH
3199: LD_INT 102
3201: PUSH
3202: LD_INT 103
3204: PUSH
3205: LD_INT 104
3207: PUSH
3208: LD_INT 105
3210: PUSH
3211: LD_INT 106
3213: PUSH
3214: LD_INT 107
3216: PUSH
3217: LD_INT 108
3219: PUSH
3220: LD_INT 109
3222: PUSH
3223: LD_INT 110
3225: PUSH
3226: LD_INT 111
3228: PUSH
3229: LD_INT 112
3231: PUSH
3232: LD_INT 114
3234: PUSH
3235: EMPTY
3236: LIST
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: LIST
3242: LIST
3243: LIST
3244: LIST
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: ST_TO_ADDR
3254: GO 4841
3256: LD_INT 12
3258: DOUBLE
3259: EQUAL
3260: IFTRUE 3264
3262: GO 3472
3264: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
3265: LD_ADDR_VAR 0 1
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: LD_INT 2
3275: PUSH
3276: LD_INT 3
3278: PUSH
3279: LD_INT 4
3281: PUSH
3282: LD_INT 5
3284: PUSH
3285: LD_INT 6
3287: PUSH
3288: LD_INT 7
3290: PUSH
3291: LD_INT 8
3293: PUSH
3294: LD_INT 9
3296: PUSH
3297: LD_INT 10
3299: PUSH
3300: LD_INT 11
3302: PUSH
3303: LD_INT 12
3305: PUSH
3306: LD_INT 13
3308: PUSH
3309: LD_INT 14
3311: PUSH
3312: LD_INT 15
3314: PUSH
3315: LD_INT 16
3317: PUSH
3318: LD_INT 17
3320: PUSH
3321: LD_INT 18
3323: PUSH
3324: LD_INT 19
3326: PUSH
3327: LD_INT 20
3329: PUSH
3330: LD_INT 21
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_INT 23
3338: PUSH
3339: LD_INT 24
3341: PUSH
3342: LD_INT 25
3344: PUSH
3345: LD_INT 26
3347: PUSH
3348: LD_INT 27
3350: PUSH
3351: LD_INT 28
3353: PUSH
3354: LD_INT 30
3356: PUSH
3357: LD_INT 31
3359: PUSH
3360: LD_INT 32
3362: PUSH
3363: LD_INT 33
3365: PUSH
3366: LD_INT 34
3368: PUSH
3369: LD_INT 36
3371: PUSH
3372: EMPTY
3373: LIST
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: LIST
3383: LIST
3384: LIST
3385: LIST
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: LIST
3397: LIST
3398: LIST
3399: LIST
3400: LIST
3401: LIST
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: PUSH
3408: LD_INT 101
3410: PUSH
3411: LD_INT 102
3413: PUSH
3414: LD_INT 103
3416: PUSH
3417: LD_INT 104
3419: PUSH
3420: LD_INT 105
3422: PUSH
3423: LD_INT 106
3425: PUSH
3426: LD_INT 107
3428: PUSH
3429: LD_INT 108
3431: PUSH
3432: LD_INT 109
3434: PUSH
3435: LD_INT 110
3437: PUSH
3438: LD_INT 111
3440: PUSH
3441: LD_INT 112
3443: PUSH
3444: LD_INT 113
3446: PUSH
3447: LD_INT 114
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: LIST
3461: LIST
3462: LIST
3463: LIST
3464: LIST
3465: PUSH
3466: EMPTY
3467: LIST
3468: LIST
3469: ST_TO_ADDR
3470: GO 4841
3472: LD_INT 13
3474: DOUBLE
3475: EQUAL
3476: IFTRUE 3480
3478: GO 3676
3480: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
3481: LD_ADDR_VAR 0 1
3485: PUSH
3486: LD_INT 1
3488: PUSH
3489: LD_INT 2
3491: PUSH
3492: LD_INT 3
3494: PUSH
3495: LD_INT 4
3497: PUSH
3498: LD_INT 5
3500: PUSH
3501: LD_INT 8
3503: PUSH
3504: LD_INT 9
3506: PUSH
3507: LD_INT 10
3509: PUSH
3510: LD_INT 11
3512: PUSH
3513: LD_INT 12
3515: PUSH
3516: LD_INT 14
3518: PUSH
3519: LD_INT 15
3521: PUSH
3522: LD_INT 16
3524: PUSH
3525: LD_INT 17
3527: PUSH
3528: LD_INT 18
3530: PUSH
3531: LD_INT 19
3533: PUSH
3534: LD_INT 20
3536: PUSH
3537: LD_INT 21
3539: PUSH
3540: LD_INT 22
3542: PUSH
3543: LD_INT 23
3545: PUSH
3546: LD_INT 24
3548: PUSH
3549: LD_INT 25
3551: PUSH
3552: LD_INT 26
3554: PUSH
3555: LD_INT 27
3557: PUSH
3558: LD_INT 28
3560: PUSH
3561: LD_INT 30
3563: PUSH
3564: LD_INT 31
3566: PUSH
3567: LD_INT 32
3569: PUSH
3570: LD_INT 33
3572: PUSH
3573: LD_INT 34
3575: PUSH
3576: LD_INT 36
3578: PUSH
3579: EMPTY
3580: LIST
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: LIST
3595: LIST
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: LIST
3606: LIST
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: PUSH
3612: LD_INT 101
3614: PUSH
3615: LD_INT 102
3617: PUSH
3618: LD_INT 103
3620: PUSH
3621: LD_INT 104
3623: PUSH
3624: LD_INT 105
3626: PUSH
3627: LD_INT 106
3629: PUSH
3630: LD_INT 107
3632: PUSH
3633: LD_INT 108
3635: PUSH
3636: LD_INT 109
3638: PUSH
3639: LD_INT 110
3641: PUSH
3642: LD_INT 111
3644: PUSH
3645: LD_INT 112
3647: PUSH
3648: LD_INT 113
3650: PUSH
3651: LD_INT 114
3653: PUSH
3654: EMPTY
3655: LIST
3656: LIST
3657: LIST
3658: LIST
3659: LIST
3660: LIST
3661: LIST
3662: LIST
3663: LIST
3664: LIST
3665: LIST
3666: LIST
3667: LIST
3668: LIST
3669: PUSH
3670: EMPTY
3671: LIST
3672: LIST
3673: ST_TO_ADDR
3674: GO 4841
3676: LD_INT 14
3678: DOUBLE
3679: EQUAL
3680: IFTRUE 3684
3682: GO 3896
3684: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
3685: LD_ADDR_VAR 0 1
3689: PUSH
3690: LD_INT 1
3692: PUSH
3693: LD_INT 2
3695: PUSH
3696: LD_INT 3
3698: PUSH
3699: LD_INT 4
3701: PUSH
3702: LD_INT 5
3704: PUSH
3705: LD_INT 6
3707: PUSH
3708: LD_INT 7
3710: PUSH
3711: LD_INT 8
3713: PUSH
3714: LD_INT 9
3716: PUSH
3717: LD_INT 10
3719: PUSH
3720: LD_INT 11
3722: PUSH
3723: LD_INT 12
3725: PUSH
3726: LD_INT 13
3728: PUSH
3729: LD_INT 14
3731: PUSH
3732: LD_INT 15
3734: PUSH
3735: LD_INT 16
3737: PUSH
3738: LD_INT 17
3740: PUSH
3741: LD_INT 18
3743: PUSH
3744: LD_INT 19
3746: PUSH
3747: LD_INT 20
3749: PUSH
3750: LD_INT 21
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 23
3758: PUSH
3759: LD_INT 24
3761: PUSH
3762: LD_INT 25
3764: PUSH
3765: LD_INT 26
3767: PUSH
3768: LD_INT 27
3770: PUSH
3771: LD_INT 28
3773: PUSH
3774: LD_INT 29
3776: PUSH
3777: LD_INT 30
3779: PUSH
3780: LD_INT 31
3782: PUSH
3783: LD_INT 32
3785: PUSH
3786: LD_INT 33
3788: PUSH
3789: LD_INT 34
3791: PUSH
3792: LD_INT 36
3794: PUSH
3795: EMPTY
3796: LIST
3797: LIST
3798: LIST
3799: LIST
3800: LIST
3801: LIST
3802: LIST
3803: LIST
3804: LIST
3805: LIST
3806: LIST
3807: LIST
3808: LIST
3809: LIST
3810: LIST
3811: LIST
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: LIST
3821: LIST
3822: LIST
3823: LIST
3824: LIST
3825: LIST
3826: LIST
3827: LIST
3828: LIST
3829: LIST
3830: LIST
3831: PUSH
3832: LD_INT 101
3834: PUSH
3835: LD_INT 102
3837: PUSH
3838: LD_INT 103
3840: PUSH
3841: LD_INT 104
3843: PUSH
3844: LD_INT 105
3846: PUSH
3847: LD_INT 106
3849: PUSH
3850: LD_INT 107
3852: PUSH
3853: LD_INT 108
3855: PUSH
3856: LD_INT 109
3858: PUSH
3859: LD_INT 110
3861: PUSH
3862: LD_INT 111
3864: PUSH
3865: LD_INT 112
3867: PUSH
3868: LD_INT 113
3870: PUSH
3871: LD_INT 114
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: LIST
3878: LIST
3879: LIST
3880: LIST
3881: LIST
3882: LIST
3883: LIST
3884: LIST
3885: LIST
3886: LIST
3887: LIST
3888: LIST
3889: PUSH
3890: EMPTY
3891: LIST
3892: LIST
3893: ST_TO_ADDR
3894: GO 4841
3896: LD_INT 15
3898: DOUBLE
3899: EQUAL
3900: IFTRUE 3904
3902: GO 4116
3904: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
3905: LD_ADDR_VAR 0 1
3909: PUSH
3910: LD_INT 1
3912: PUSH
3913: LD_INT 2
3915: PUSH
3916: LD_INT 3
3918: PUSH
3919: LD_INT 4
3921: PUSH
3922: LD_INT 5
3924: PUSH
3925: LD_INT 6
3927: PUSH
3928: LD_INT 7
3930: PUSH
3931: LD_INT 8
3933: PUSH
3934: LD_INT 9
3936: PUSH
3937: LD_INT 10
3939: PUSH
3940: LD_INT 11
3942: PUSH
3943: LD_INT 12
3945: PUSH
3946: LD_INT 13
3948: PUSH
3949: LD_INT 14
3951: PUSH
3952: LD_INT 15
3954: PUSH
3955: LD_INT 16
3957: PUSH
3958: LD_INT 17
3960: PUSH
3961: LD_INT 18
3963: PUSH
3964: LD_INT 19
3966: PUSH
3967: LD_INT 20
3969: PUSH
3970: LD_INT 21
3972: PUSH
3973: LD_INT 22
3975: PUSH
3976: LD_INT 23
3978: PUSH
3979: LD_INT 24
3981: PUSH
3982: LD_INT 25
3984: PUSH
3985: LD_INT 26
3987: PUSH
3988: LD_INT 27
3990: PUSH
3991: LD_INT 28
3993: PUSH
3994: LD_INT 29
3996: PUSH
3997: LD_INT 30
3999: PUSH
4000: LD_INT 31
4002: PUSH
4003: LD_INT 32
4005: PUSH
4006: LD_INT 33
4008: PUSH
4009: LD_INT 34
4011: PUSH
4012: LD_INT 36
4014: PUSH
4015: EMPTY
4016: LIST
4017: LIST
4018: LIST
4019: LIST
4020: LIST
4021: LIST
4022: LIST
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: LIST
4028: LIST
4029: LIST
4030: LIST
4031: LIST
4032: LIST
4033: LIST
4034: LIST
4035: LIST
4036: LIST
4037: LIST
4038: LIST
4039: LIST
4040: LIST
4041: LIST
4042: LIST
4043: LIST
4044: LIST
4045: LIST
4046: LIST
4047: LIST
4048: LIST
4049: LIST
4050: LIST
4051: PUSH
4052: LD_INT 101
4054: PUSH
4055: LD_INT 102
4057: PUSH
4058: LD_INT 103
4060: PUSH
4061: LD_INT 104
4063: PUSH
4064: LD_INT 105
4066: PUSH
4067: LD_INT 106
4069: PUSH
4070: LD_INT 107
4072: PUSH
4073: LD_INT 108
4075: PUSH
4076: LD_INT 109
4078: PUSH
4079: LD_INT 110
4081: PUSH
4082: LD_INT 111
4084: PUSH
4085: LD_INT 112
4087: PUSH
4088: LD_INT 113
4090: PUSH
4091: LD_INT 114
4093: PUSH
4094: EMPTY
4095: LIST
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: LIST
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: LIST
4109: PUSH
4110: EMPTY
4111: LIST
4112: LIST
4113: ST_TO_ADDR
4114: GO 4841
4116: LD_INT 16
4118: DOUBLE
4119: EQUAL
4120: IFTRUE 4124
4122: GO 4248
4124: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
4125: LD_ADDR_VAR 0 1
4129: PUSH
4130: LD_INT 2
4132: PUSH
4133: LD_INT 4
4135: PUSH
4136: LD_INT 5
4138: PUSH
4139: LD_INT 7
4141: PUSH
4142: LD_INT 11
4144: PUSH
4145: LD_INT 12
4147: PUSH
4148: LD_INT 15
4150: PUSH
4151: LD_INT 16
4153: PUSH
4154: LD_INT 20
4156: PUSH
4157: LD_INT 21
4159: PUSH
4160: LD_INT 22
4162: PUSH
4163: LD_INT 23
4165: PUSH
4166: LD_INT 25
4168: PUSH
4169: LD_INT 26
4171: PUSH
4172: LD_INT 30
4174: PUSH
4175: LD_INT 31
4177: PUSH
4178: LD_INT 32
4180: PUSH
4181: LD_INT 33
4183: PUSH
4184: LD_INT 34
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: LIST
4191: LIST
4192: LIST
4193: LIST
4194: LIST
4195: LIST
4196: LIST
4197: LIST
4198: LIST
4199: LIST
4200: LIST
4201: LIST
4202: LIST
4203: LIST
4204: LIST
4205: LIST
4206: LIST
4207: PUSH
4208: LD_INT 101
4210: PUSH
4211: LD_INT 102
4213: PUSH
4214: LD_INT 103
4216: PUSH
4217: LD_INT 106
4219: PUSH
4220: LD_INT 108
4222: PUSH
4223: LD_INT 112
4225: PUSH
4226: LD_INT 113
4228: PUSH
4229: LD_INT 114
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: LIST
4236: LIST
4237: LIST
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: ST_TO_ADDR
4246: GO 4841
4248: LD_INT 17
4250: DOUBLE
4251: EQUAL
4252: IFTRUE 4256
4254: GO 4468
4256: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
4257: LD_ADDR_VAR 0 1
4261: PUSH
4262: LD_INT 1
4264: PUSH
4265: LD_INT 2
4267: PUSH
4268: LD_INT 3
4270: PUSH
4271: LD_INT 4
4273: PUSH
4274: LD_INT 5
4276: PUSH
4277: LD_INT 6
4279: PUSH
4280: LD_INT 7
4282: PUSH
4283: LD_INT 8
4285: PUSH
4286: LD_INT 9
4288: PUSH
4289: LD_INT 10
4291: PUSH
4292: LD_INT 11
4294: PUSH
4295: LD_INT 12
4297: PUSH
4298: LD_INT 13
4300: PUSH
4301: LD_INT 14
4303: PUSH
4304: LD_INT 15
4306: PUSH
4307: LD_INT 16
4309: PUSH
4310: LD_INT 17
4312: PUSH
4313: LD_INT 18
4315: PUSH
4316: LD_INT 19
4318: PUSH
4319: LD_INT 20
4321: PUSH
4322: LD_INT 21
4324: PUSH
4325: LD_INT 22
4327: PUSH
4328: LD_INT 23
4330: PUSH
4331: LD_INT 24
4333: PUSH
4334: LD_INT 25
4336: PUSH
4337: LD_INT 26
4339: PUSH
4340: LD_INT 27
4342: PUSH
4343: LD_INT 28
4345: PUSH
4346: LD_INT 29
4348: PUSH
4349: LD_INT 30
4351: PUSH
4352: LD_INT 31
4354: PUSH
4355: LD_INT 32
4357: PUSH
4358: LD_INT 33
4360: PUSH
4361: LD_INT 34
4363: PUSH
4364: LD_INT 36
4366: PUSH
4367: EMPTY
4368: LIST
4369: LIST
4370: LIST
4371: LIST
4372: LIST
4373: LIST
4374: LIST
4375: LIST
4376: LIST
4377: LIST
4378: LIST
4379: LIST
4380: LIST
4381: LIST
4382: LIST
4383: LIST
4384: LIST
4385: LIST
4386: LIST
4387: LIST
4388: LIST
4389: LIST
4390: LIST
4391: LIST
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: LIST
4397: LIST
4398: LIST
4399: LIST
4400: LIST
4401: LIST
4402: LIST
4403: PUSH
4404: LD_INT 101
4406: PUSH
4407: LD_INT 102
4409: PUSH
4410: LD_INT 103
4412: PUSH
4413: LD_INT 104
4415: PUSH
4416: LD_INT 105
4418: PUSH
4419: LD_INT 106
4421: PUSH
4422: LD_INT 107
4424: PUSH
4425: LD_INT 108
4427: PUSH
4428: LD_INT 109
4430: PUSH
4431: LD_INT 110
4433: PUSH
4434: LD_INT 111
4436: PUSH
4437: LD_INT 112
4439: PUSH
4440: LD_INT 113
4442: PUSH
4443: LD_INT 114
4445: PUSH
4446: EMPTY
4447: LIST
4448: LIST
4449: LIST
4450: LIST
4451: LIST
4452: LIST
4453: LIST
4454: LIST
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: LIST
4460: LIST
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: ST_TO_ADDR
4466: GO 4841
4468: LD_INT 18
4470: DOUBLE
4471: EQUAL
4472: IFTRUE 4476
4474: GO 4612
4476: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
4477: LD_ADDR_VAR 0 1
4481: PUSH
4482: LD_INT 2
4484: PUSH
4485: LD_INT 4
4487: PUSH
4488: LD_INT 5
4490: PUSH
4491: LD_INT 7
4493: PUSH
4494: LD_INT 11
4496: PUSH
4497: LD_INT 12
4499: PUSH
4500: LD_INT 15
4502: PUSH
4503: LD_INT 16
4505: PUSH
4506: LD_INT 20
4508: PUSH
4509: LD_INT 21
4511: PUSH
4512: LD_INT 22
4514: PUSH
4515: LD_INT 23
4517: PUSH
4518: LD_INT 25
4520: PUSH
4521: LD_INT 26
4523: PUSH
4524: LD_INT 30
4526: PUSH
4527: LD_INT 31
4529: PUSH
4530: LD_INT 32
4532: PUSH
4533: LD_INT 33
4535: PUSH
4536: LD_INT 34
4538: PUSH
4539: LD_INT 35
4541: PUSH
4542: LD_INT 36
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: LIST
4552: LIST
4553: LIST
4554: LIST
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: LIST
4560: LIST
4561: LIST
4562: LIST
4563: LIST
4564: LIST
4565: LIST
4566: LIST
4567: PUSH
4568: LD_INT 101
4570: PUSH
4571: LD_INT 102
4573: PUSH
4574: LD_INT 103
4576: PUSH
4577: LD_INT 106
4579: PUSH
4580: LD_INT 108
4582: PUSH
4583: LD_INT 112
4585: PUSH
4586: LD_INT 113
4588: PUSH
4589: LD_INT 114
4591: PUSH
4592: LD_INT 115
4594: PUSH
4595: EMPTY
4596: LIST
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: LIST
4605: PUSH
4606: EMPTY
4607: LIST
4608: LIST
4609: ST_TO_ADDR
4610: GO 4841
4612: LD_INT 19
4614: DOUBLE
4615: EQUAL
4616: IFTRUE 4620
4618: GO 4840
4620: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
4621: LD_ADDR_VAR 0 1
4625: PUSH
4626: LD_INT 1
4628: PUSH
4629: LD_INT 2
4631: PUSH
4632: LD_INT 3
4634: PUSH
4635: LD_INT 4
4637: PUSH
4638: LD_INT 5
4640: PUSH
4641: LD_INT 6
4643: PUSH
4644: LD_INT 7
4646: PUSH
4647: LD_INT 8
4649: PUSH
4650: LD_INT 9
4652: PUSH
4653: LD_INT 10
4655: PUSH
4656: LD_INT 11
4658: PUSH
4659: LD_INT 12
4661: PUSH
4662: LD_INT 13
4664: PUSH
4665: LD_INT 14
4667: PUSH
4668: LD_INT 15
4670: PUSH
4671: LD_INT 16
4673: PUSH
4674: LD_INT 17
4676: PUSH
4677: LD_INT 18
4679: PUSH
4680: LD_INT 19
4682: PUSH
4683: LD_INT 20
4685: PUSH
4686: LD_INT 21
4688: PUSH
4689: LD_INT 22
4691: PUSH
4692: LD_INT 23
4694: PUSH
4695: LD_INT 24
4697: PUSH
4698: LD_INT 25
4700: PUSH
4701: LD_INT 26
4703: PUSH
4704: LD_INT 27
4706: PUSH
4707: LD_INT 28
4709: PUSH
4710: LD_INT 29
4712: PUSH
4713: LD_INT 30
4715: PUSH
4716: LD_INT 31
4718: PUSH
4719: LD_INT 32
4721: PUSH
4722: LD_INT 33
4724: PUSH
4725: LD_INT 34
4727: PUSH
4728: LD_INT 35
4730: PUSH
4731: LD_INT 36
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: LIST
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: LIST
4743: LIST
4744: LIST
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: LIST
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: LIST
4763: LIST
4764: LIST
4765: LIST
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: LIST
4771: PUSH
4772: LD_INT 101
4774: PUSH
4775: LD_INT 102
4777: PUSH
4778: LD_INT 103
4780: PUSH
4781: LD_INT 104
4783: PUSH
4784: LD_INT 105
4786: PUSH
4787: LD_INT 106
4789: PUSH
4790: LD_INT 107
4792: PUSH
4793: LD_INT 108
4795: PUSH
4796: LD_INT 109
4798: PUSH
4799: LD_INT 110
4801: PUSH
4802: LD_INT 111
4804: PUSH
4805: LD_INT 112
4807: PUSH
4808: LD_INT 113
4810: PUSH
4811: LD_INT 114
4813: PUSH
4814: LD_INT 115
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: LIST
4821: LIST
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: LIST
4830: LIST
4831: LIST
4832: LIST
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: ST_TO_ADDR
4838: GO 4841
4840: POP
// end else
4841: GO 4878
// if campaign_id = 5 then
4843: LD_OWVAR 69
4847: PUSH
4848: LD_INT 5
4850: EQUAL
4851: IFFALSE 4878
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
4853: LD_ADDR_VAR 0 1
4857: PUSH
4858: LD_INT 1
4860: PUSH
4861: LD_INT 2
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 100
4870: PUSH
4871: EMPTY
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: ST_TO_ADDR
// end ; if result then
4878: LD_VAR 0 1
4882: IFFALSE 5171
// begin normal :=  ;
4884: LD_ADDR_VAR 0 3
4888: PUSH
4889: LD_STRING 
4891: ST_TO_ADDR
// hardcore :=  ;
4892: LD_ADDR_VAR 0 4
4896: PUSH
4897: LD_STRING 
4899: ST_TO_ADDR
// for i = 1 to normalCounter do
4900: LD_ADDR_VAR 0 5
4904: PUSH
4905: DOUBLE
4906: LD_INT 1
4908: DEC
4909: ST_TO_ADDR
4910: LD_EXP 19
4914: PUSH
4915: FOR_TO
4916: IFFALSE 5017
// begin tmp := 0 ;
4918: LD_ADDR_VAR 0 2
4922: PUSH
4923: LD_STRING 0
4925: ST_TO_ADDR
// if result [ 1 ] then
4926: LD_VAR 0 1
4930: PUSH
4931: LD_INT 1
4933: ARRAY
4934: IFFALSE 4999
// if result [ 1 ] [ 1 ] = i then
4936: LD_VAR 0 1
4940: PUSH
4941: LD_INT 1
4943: ARRAY
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: PUSH
4949: LD_VAR 0 5
4953: EQUAL
4954: IFFALSE 4999
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
4956: LD_ADDR_VAR 0 1
4960: PUSH
4961: LD_VAR 0 1
4965: PPUSH
4966: LD_INT 1
4968: PPUSH
4969: LD_VAR 0 1
4973: PUSH
4974: LD_INT 1
4976: ARRAY
4977: PPUSH
4978: LD_INT 1
4980: PPUSH
4981: CALL_OW 3
4985: PPUSH
4986: CALL_OW 1
4990: ST_TO_ADDR
// tmp := 1 ;
4991: LD_ADDR_VAR 0 2
4995: PUSH
4996: LD_STRING 1
4998: ST_TO_ADDR
// end ; normal := normal & tmp ;
4999: LD_ADDR_VAR 0 3
5003: PUSH
5004: LD_VAR 0 3
5008: PUSH
5009: LD_VAR 0 2
5013: STR
5014: ST_TO_ADDR
// end ;
5015: GO 4915
5017: POP
5018: POP
// for i = 1 to hardcoreCounter do
5019: LD_ADDR_VAR 0 5
5023: PUSH
5024: DOUBLE
5025: LD_INT 1
5027: DEC
5028: ST_TO_ADDR
5029: LD_EXP 20
5033: PUSH
5034: FOR_TO
5035: IFFALSE 5140
// begin tmp := 0 ;
5037: LD_ADDR_VAR 0 2
5041: PUSH
5042: LD_STRING 0
5044: ST_TO_ADDR
// if result [ 2 ] then
5045: LD_VAR 0 1
5049: PUSH
5050: LD_INT 2
5052: ARRAY
5053: IFFALSE 5122
// if result [ 2 ] [ 1 ] = 100 + i then
5055: LD_VAR 0 1
5059: PUSH
5060: LD_INT 2
5062: ARRAY
5063: PUSH
5064: LD_INT 1
5066: ARRAY
5067: PUSH
5068: LD_INT 100
5070: PUSH
5071: LD_VAR 0 5
5075: PLUS
5076: EQUAL
5077: IFFALSE 5122
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
5079: LD_ADDR_VAR 0 1
5083: PUSH
5084: LD_VAR 0 1
5088: PPUSH
5089: LD_INT 2
5091: PPUSH
5092: LD_VAR 0 1
5096: PUSH
5097: LD_INT 2
5099: ARRAY
5100: PPUSH
5101: LD_INT 1
5103: PPUSH
5104: CALL_OW 3
5108: PPUSH
5109: CALL_OW 1
5113: ST_TO_ADDR
// tmp := 1 ;
5114: LD_ADDR_VAR 0 2
5118: PUSH
5119: LD_STRING 1
5121: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
5122: LD_ADDR_VAR 0 4
5126: PUSH
5127: LD_VAR 0 4
5131: PUSH
5132: LD_VAR 0 2
5136: STR
5137: ST_TO_ADDR
// end ;
5138: GO 5034
5140: POP
5141: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
5142: LD_STRING getStreamItemsFromMission("
5144: PUSH
5145: LD_VAR 0 3
5149: STR
5150: PUSH
5151: LD_STRING ","
5153: STR
5154: PUSH
5155: LD_VAR 0 4
5159: STR
5160: PUSH
5161: LD_STRING ")
5163: STR
5164: PPUSH
5165: CALL_OW 559
// end else
5169: GO 5178
// ToLua ( getStreamItemsFromMission("","") ) ;
5171: LD_STRING getStreamItemsFromMission("","")
5173: PPUSH
5174: CALL_OW 559
// end ;
5178: LD_VAR 0 1
5182: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
5183: LD_VAR 0 2
5187: PUSH
5188: LD_INT 100
5190: EQUAL
5191: IFFALSE 6140
// begin if not StreamModeActive then
5193: LD_EXP 18
5197: NOT
5198: IFFALSE 5208
// StreamModeActive := true ;
5200: LD_ADDR_EXP 18
5204: PUSH
5205: LD_INT 1
5207: ST_TO_ADDR
// if p3 = 0 then
5208: LD_VAR 0 3
5212: PUSH
5213: LD_INT 0
5215: EQUAL
5216: IFFALSE 5222
// InitStreamMode ;
5218: CALL 1443 0 0
// if p3 = 1 then
5222: LD_VAR 0 3
5226: PUSH
5227: LD_INT 1
5229: EQUAL
5230: IFFALSE 5240
// sRocket := true ;
5232: LD_ADDR_EXP 23
5236: PUSH
5237: LD_INT 1
5239: ST_TO_ADDR
// if p3 = 2 then
5240: LD_VAR 0 3
5244: PUSH
5245: LD_INT 2
5247: EQUAL
5248: IFFALSE 5258
// sSpeed := true ;
5250: LD_ADDR_EXP 22
5254: PUSH
5255: LD_INT 1
5257: ST_TO_ADDR
// if p3 = 3 then
5258: LD_VAR 0 3
5262: PUSH
5263: LD_INT 3
5265: EQUAL
5266: IFFALSE 5276
// sEngine := true ;
5268: LD_ADDR_EXP 24
5272: PUSH
5273: LD_INT 1
5275: ST_TO_ADDR
// if p3 = 4 then
5276: LD_VAR 0 3
5280: PUSH
5281: LD_INT 4
5283: EQUAL
5284: IFFALSE 5294
// sSpec := true ;
5286: LD_ADDR_EXP 21
5290: PUSH
5291: LD_INT 1
5293: ST_TO_ADDR
// if p3 = 5 then
5294: LD_VAR 0 3
5298: PUSH
5299: LD_INT 5
5301: EQUAL
5302: IFFALSE 5312
// sLevel := true ;
5304: LD_ADDR_EXP 25
5308: PUSH
5309: LD_INT 1
5311: ST_TO_ADDR
// if p3 = 6 then
5312: LD_VAR 0 3
5316: PUSH
5317: LD_INT 6
5319: EQUAL
5320: IFFALSE 5330
// sArmoury := true ;
5322: LD_ADDR_EXP 26
5326: PUSH
5327: LD_INT 1
5329: ST_TO_ADDR
// if p3 = 7 then
5330: LD_VAR 0 3
5334: PUSH
5335: LD_INT 7
5337: EQUAL
5338: IFFALSE 5348
// sRadar := true ;
5340: LD_ADDR_EXP 27
5344: PUSH
5345: LD_INT 1
5347: ST_TO_ADDR
// if p3 = 8 then
5348: LD_VAR 0 3
5352: PUSH
5353: LD_INT 8
5355: EQUAL
5356: IFFALSE 5366
// sBunker := true ;
5358: LD_ADDR_EXP 28
5362: PUSH
5363: LD_INT 1
5365: ST_TO_ADDR
// if p3 = 9 then
5366: LD_VAR 0 3
5370: PUSH
5371: LD_INT 9
5373: EQUAL
5374: IFFALSE 5384
// sHack := true ;
5376: LD_ADDR_EXP 29
5380: PUSH
5381: LD_INT 1
5383: ST_TO_ADDR
// if p3 = 10 then
5384: LD_VAR 0 3
5388: PUSH
5389: LD_INT 10
5391: EQUAL
5392: IFFALSE 5402
// sFire := true ;
5394: LD_ADDR_EXP 30
5398: PUSH
5399: LD_INT 1
5401: ST_TO_ADDR
// if p3 = 11 then
5402: LD_VAR 0 3
5406: PUSH
5407: LD_INT 11
5409: EQUAL
5410: IFFALSE 5420
// sRefresh := true ;
5412: LD_ADDR_EXP 31
5416: PUSH
5417: LD_INT 1
5419: ST_TO_ADDR
// if p3 = 12 then
5420: LD_VAR 0 3
5424: PUSH
5425: LD_INT 12
5427: EQUAL
5428: IFFALSE 5438
// sExp := true ;
5430: LD_ADDR_EXP 32
5434: PUSH
5435: LD_INT 1
5437: ST_TO_ADDR
// if p3 = 13 then
5438: LD_VAR 0 3
5442: PUSH
5443: LD_INT 13
5445: EQUAL
5446: IFFALSE 5456
// sDepot := true ;
5448: LD_ADDR_EXP 33
5452: PUSH
5453: LD_INT 1
5455: ST_TO_ADDR
// if p3 = 14 then
5456: LD_VAR 0 3
5460: PUSH
5461: LD_INT 14
5463: EQUAL
5464: IFFALSE 5474
// sFlag := true ;
5466: LD_ADDR_EXP 34
5470: PUSH
5471: LD_INT 1
5473: ST_TO_ADDR
// if p3 = 15 then
5474: LD_VAR 0 3
5478: PUSH
5479: LD_INT 15
5481: EQUAL
5482: IFFALSE 5492
// sKamikadze := true ;
5484: LD_ADDR_EXP 42
5488: PUSH
5489: LD_INT 1
5491: ST_TO_ADDR
// if p3 = 16 then
5492: LD_VAR 0 3
5496: PUSH
5497: LD_INT 16
5499: EQUAL
5500: IFFALSE 5510
// sTroll := true ;
5502: LD_ADDR_EXP 43
5506: PUSH
5507: LD_INT 1
5509: ST_TO_ADDR
// if p3 = 17 then
5510: LD_VAR 0 3
5514: PUSH
5515: LD_INT 17
5517: EQUAL
5518: IFFALSE 5528
// sSlow := true ;
5520: LD_ADDR_EXP 44
5524: PUSH
5525: LD_INT 1
5527: ST_TO_ADDR
// if p3 = 18 then
5528: LD_VAR 0 3
5532: PUSH
5533: LD_INT 18
5535: EQUAL
5536: IFFALSE 5546
// sLack := true ;
5538: LD_ADDR_EXP 45
5542: PUSH
5543: LD_INT 1
5545: ST_TO_ADDR
// if p3 = 19 then
5546: LD_VAR 0 3
5550: PUSH
5551: LD_INT 19
5553: EQUAL
5554: IFFALSE 5564
// sTank := true ;
5556: LD_ADDR_EXP 47
5560: PUSH
5561: LD_INT 1
5563: ST_TO_ADDR
// if p3 = 20 then
5564: LD_VAR 0 3
5568: PUSH
5569: LD_INT 20
5571: EQUAL
5572: IFFALSE 5582
// sRemote := true ;
5574: LD_ADDR_EXP 48
5578: PUSH
5579: LD_INT 1
5581: ST_TO_ADDR
// if p3 = 21 then
5582: LD_VAR 0 3
5586: PUSH
5587: LD_INT 21
5589: EQUAL
5590: IFFALSE 5600
// sPowell := true ;
5592: LD_ADDR_EXP 49
5596: PUSH
5597: LD_INT 1
5599: ST_TO_ADDR
// if p3 = 22 then
5600: LD_VAR 0 3
5604: PUSH
5605: LD_INT 22
5607: EQUAL
5608: IFFALSE 5618
// sTeleport := true ;
5610: LD_ADDR_EXP 52
5614: PUSH
5615: LD_INT 1
5617: ST_TO_ADDR
// if p3 = 23 then
5618: LD_VAR 0 3
5622: PUSH
5623: LD_INT 23
5625: EQUAL
5626: IFFALSE 5636
// sOilTower := true ;
5628: LD_ADDR_EXP 54
5632: PUSH
5633: LD_INT 1
5635: ST_TO_ADDR
// if p3 = 24 then
5636: LD_VAR 0 3
5640: PUSH
5641: LD_INT 24
5643: EQUAL
5644: IFFALSE 5654
// sShovel := true ;
5646: LD_ADDR_EXP 55
5650: PUSH
5651: LD_INT 1
5653: ST_TO_ADDR
// if p3 = 25 then
5654: LD_VAR 0 3
5658: PUSH
5659: LD_INT 25
5661: EQUAL
5662: IFFALSE 5672
// sSheik := true ;
5664: LD_ADDR_EXP 56
5668: PUSH
5669: LD_INT 1
5671: ST_TO_ADDR
// if p3 = 26 then
5672: LD_VAR 0 3
5676: PUSH
5677: LD_INT 26
5679: EQUAL
5680: IFFALSE 5690
// sEarthquake := true ;
5682: LD_ADDR_EXP 58
5686: PUSH
5687: LD_INT 1
5689: ST_TO_ADDR
// if p3 = 27 then
5690: LD_VAR 0 3
5694: PUSH
5695: LD_INT 27
5697: EQUAL
5698: IFFALSE 5708
// sAI := true ;
5700: LD_ADDR_EXP 59
5704: PUSH
5705: LD_INT 1
5707: ST_TO_ADDR
// if p3 = 28 then
5708: LD_VAR 0 3
5712: PUSH
5713: LD_INT 28
5715: EQUAL
5716: IFFALSE 5726
// sCargo := true ;
5718: LD_ADDR_EXP 62
5722: PUSH
5723: LD_INT 1
5725: ST_TO_ADDR
// if p3 = 29 then
5726: LD_VAR 0 3
5730: PUSH
5731: LD_INT 29
5733: EQUAL
5734: IFFALSE 5744
// sDLaser := true ;
5736: LD_ADDR_EXP 63
5740: PUSH
5741: LD_INT 1
5743: ST_TO_ADDR
// if p3 = 30 then
5744: LD_VAR 0 3
5748: PUSH
5749: LD_INT 30
5751: EQUAL
5752: IFFALSE 5762
// sExchange := true ;
5754: LD_ADDR_EXP 64
5758: PUSH
5759: LD_INT 1
5761: ST_TO_ADDR
// if p3 = 31 then
5762: LD_VAR 0 3
5766: PUSH
5767: LD_INT 31
5769: EQUAL
5770: IFFALSE 5780
// sFac := true ;
5772: LD_ADDR_EXP 65
5776: PUSH
5777: LD_INT 1
5779: ST_TO_ADDR
// if p3 = 32 then
5780: LD_VAR 0 3
5784: PUSH
5785: LD_INT 32
5787: EQUAL
5788: IFFALSE 5798
// sPower := true ;
5790: LD_ADDR_EXP 66
5794: PUSH
5795: LD_INT 1
5797: ST_TO_ADDR
// if p3 = 33 then
5798: LD_VAR 0 3
5802: PUSH
5803: LD_INT 33
5805: EQUAL
5806: IFFALSE 5816
// sRandom := true ;
5808: LD_ADDR_EXP 67
5812: PUSH
5813: LD_INT 1
5815: ST_TO_ADDR
// if p3 = 34 then
5816: LD_VAR 0 3
5820: PUSH
5821: LD_INT 34
5823: EQUAL
5824: IFFALSE 5834
// sShield := true ;
5826: LD_ADDR_EXP 68
5830: PUSH
5831: LD_INT 1
5833: ST_TO_ADDR
// if p3 = 35 then
5834: LD_VAR 0 3
5838: PUSH
5839: LD_INT 35
5841: EQUAL
5842: IFFALSE 5852
// sTime := true ;
5844: LD_ADDR_EXP 69
5848: PUSH
5849: LD_INT 1
5851: ST_TO_ADDR
// if p3 = 36 then
5852: LD_VAR 0 3
5856: PUSH
5857: LD_INT 36
5859: EQUAL
5860: IFFALSE 5870
// sTools := true ;
5862: LD_ADDR_EXP 70
5866: PUSH
5867: LD_INT 1
5869: ST_TO_ADDR
// if p3 = 101 then
5870: LD_VAR 0 3
5874: PUSH
5875: LD_INT 101
5877: EQUAL
5878: IFFALSE 5888
// sSold := true ;
5880: LD_ADDR_EXP 35
5884: PUSH
5885: LD_INT 1
5887: ST_TO_ADDR
// if p3 = 102 then
5888: LD_VAR 0 3
5892: PUSH
5893: LD_INT 102
5895: EQUAL
5896: IFFALSE 5906
// sDiff := true ;
5898: LD_ADDR_EXP 36
5902: PUSH
5903: LD_INT 1
5905: ST_TO_ADDR
// if p3 = 103 then
5906: LD_VAR 0 3
5910: PUSH
5911: LD_INT 103
5913: EQUAL
5914: IFFALSE 5924
// sFog := true ;
5916: LD_ADDR_EXP 39
5920: PUSH
5921: LD_INT 1
5923: ST_TO_ADDR
// if p3 = 104 then
5924: LD_VAR 0 3
5928: PUSH
5929: LD_INT 104
5931: EQUAL
5932: IFFALSE 5942
// sReset := true ;
5934: LD_ADDR_EXP 40
5938: PUSH
5939: LD_INT 1
5941: ST_TO_ADDR
// if p3 = 105 then
5942: LD_VAR 0 3
5946: PUSH
5947: LD_INT 105
5949: EQUAL
5950: IFFALSE 5960
// sSun := true ;
5952: LD_ADDR_EXP 41
5956: PUSH
5957: LD_INT 1
5959: ST_TO_ADDR
// if p3 = 106 then
5960: LD_VAR 0 3
5964: PUSH
5965: LD_INT 106
5967: EQUAL
5968: IFFALSE 5978
// sTiger := true ;
5970: LD_ADDR_EXP 37
5974: PUSH
5975: LD_INT 1
5977: ST_TO_ADDR
// if p3 = 107 then
5978: LD_VAR 0 3
5982: PUSH
5983: LD_INT 107
5985: EQUAL
5986: IFFALSE 5996
// sBomb := true ;
5988: LD_ADDR_EXP 38
5992: PUSH
5993: LD_INT 1
5995: ST_TO_ADDR
// if p3 = 108 then
5996: LD_VAR 0 3
6000: PUSH
6001: LD_INT 108
6003: EQUAL
6004: IFFALSE 6014
// sWound := true ;
6006: LD_ADDR_EXP 46
6010: PUSH
6011: LD_INT 1
6013: ST_TO_ADDR
// if p3 = 109 then
6014: LD_VAR 0 3
6018: PUSH
6019: LD_INT 109
6021: EQUAL
6022: IFFALSE 6032
// sBetray := true ;
6024: LD_ADDR_EXP 50
6028: PUSH
6029: LD_INT 1
6031: ST_TO_ADDR
// if p3 = 110 then
6032: LD_VAR 0 3
6036: PUSH
6037: LD_INT 110
6039: EQUAL
6040: IFFALSE 6050
// sContamin := true ;
6042: LD_ADDR_EXP 51
6046: PUSH
6047: LD_INT 1
6049: ST_TO_ADDR
// if p3 = 111 then
6050: LD_VAR 0 3
6054: PUSH
6055: LD_INT 111
6057: EQUAL
6058: IFFALSE 6068
// sOil := true ;
6060: LD_ADDR_EXP 53
6064: PUSH
6065: LD_INT 1
6067: ST_TO_ADDR
// if p3 = 112 then
6068: LD_VAR 0 3
6072: PUSH
6073: LD_INT 112
6075: EQUAL
6076: IFFALSE 6086
// sStu := true ;
6078: LD_ADDR_EXP 57
6082: PUSH
6083: LD_INT 1
6085: ST_TO_ADDR
// if p3 = 113 then
6086: LD_VAR 0 3
6090: PUSH
6091: LD_INT 113
6093: EQUAL
6094: IFFALSE 6104
// sBazooka := true ;
6096: LD_ADDR_EXP 60
6100: PUSH
6101: LD_INT 1
6103: ST_TO_ADDR
// if p3 = 114 then
6104: LD_VAR 0 3
6108: PUSH
6109: LD_INT 114
6111: EQUAL
6112: IFFALSE 6122
// sMortar := true ;
6114: LD_ADDR_EXP 61
6118: PUSH
6119: LD_INT 1
6121: ST_TO_ADDR
// if p3 = 115 then
6122: LD_VAR 0 3
6126: PUSH
6127: LD_INT 115
6129: EQUAL
6130: IFFALSE 6140
// sRanger := true ;
6132: LD_ADDR_EXP 71
6136: PUSH
6137: LD_INT 1
6139: ST_TO_ADDR
// end ; end ;
6140: PPOPN 6
6142: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
6143: LD_EXP 18
6147: PUSH
6148: LD_EXP 23
6152: AND
6153: IFFALSE 6277
6155: GO 6157
6157: DISABLE
6158: LD_INT 0
6160: PPUSH
6161: PPUSH
// begin enable ;
6162: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
6163: LD_ADDR_VAR 0 2
6167: PUSH
6168: LD_INT 22
6170: PUSH
6171: LD_OWVAR 2
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PUSH
6180: LD_INT 2
6182: PUSH
6183: LD_INT 34
6185: PUSH
6186: LD_INT 7
6188: PUSH
6189: EMPTY
6190: LIST
6191: LIST
6192: PUSH
6193: LD_INT 34
6195: PUSH
6196: LD_INT 45
6198: PUSH
6199: EMPTY
6200: LIST
6201: LIST
6202: PUSH
6203: LD_INT 34
6205: PUSH
6206: LD_INT 28
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PUSH
6213: LD_INT 34
6215: PUSH
6216: LD_INT 47
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: LIST
6227: LIST
6228: LIST
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: PPUSH
6234: CALL_OW 69
6238: ST_TO_ADDR
// if not tmp then
6239: LD_VAR 0 2
6243: NOT
6244: IFFALSE 6248
// exit ;
6246: GO 6277
// for i in tmp do
6248: LD_ADDR_VAR 0 1
6252: PUSH
6253: LD_VAR 0 2
6257: PUSH
6258: FOR_IN
6259: IFFALSE 6275
// begin SetLives ( i , 0 ) ;
6261: LD_VAR 0 1
6265: PPUSH
6266: LD_INT 0
6268: PPUSH
6269: CALL_OW 234
// end ;
6273: GO 6258
6275: POP
6276: POP
// end ;
6277: PPOPN 2
6279: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
6280: LD_EXP 18
6284: PUSH
6285: LD_EXP 24
6289: AND
6290: IFFALSE 6374
6292: GO 6294
6294: DISABLE
6295: LD_INT 0
6297: PPUSH
6298: PPUSH
// begin enable ;
6299: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
6300: LD_ADDR_VAR 0 2
6304: PUSH
6305: LD_INT 22
6307: PUSH
6308: LD_OWVAR 2
6312: PUSH
6313: EMPTY
6314: LIST
6315: LIST
6316: PUSH
6317: LD_INT 32
6319: PUSH
6320: LD_INT 3
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PPUSH
6331: CALL_OW 69
6335: ST_TO_ADDR
// if not tmp then
6336: LD_VAR 0 2
6340: NOT
6341: IFFALSE 6345
// exit ;
6343: GO 6374
// for i in tmp do
6345: LD_ADDR_VAR 0 1
6349: PUSH
6350: LD_VAR 0 2
6354: PUSH
6355: FOR_IN
6356: IFFALSE 6372
// begin SetLives ( i , 0 ) ;
6358: LD_VAR 0 1
6362: PPUSH
6363: LD_INT 0
6365: PPUSH
6366: CALL_OW 234
// end ;
6370: GO 6355
6372: POP
6373: POP
// end ;
6374: PPOPN 2
6376: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
6377: LD_EXP 18
6381: PUSH
6382: LD_EXP 21
6386: AND
6387: IFFALSE 6480
6389: GO 6391
6391: DISABLE
6392: LD_INT 0
6394: PPUSH
// begin enable ;
6395: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
6396: LD_ADDR_VAR 0 1
6400: PUSH
6401: LD_INT 22
6403: PUSH
6404: LD_OWVAR 2
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PUSH
6413: LD_INT 2
6415: PUSH
6416: LD_INT 25
6418: PUSH
6419: LD_INT 5
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: PUSH
6426: LD_INT 25
6428: PUSH
6429: LD_INT 9
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: PUSH
6436: LD_INT 25
6438: PUSH
6439: LD_INT 8
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: LIST
6450: LIST
6451: PUSH
6452: EMPTY
6453: LIST
6454: LIST
6455: PPUSH
6456: CALL_OW 69
6460: PUSH
6461: FOR_IN
6462: IFFALSE 6478
// begin SetClass ( i , 1 ) ;
6464: LD_VAR 0 1
6468: PPUSH
6469: LD_INT 1
6471: PPUSH
6472: CALL_OW 336
// end ;
6476: GO 6461
6478: POP
6479: POP
// end ;
6480: PPOPN 1
6482: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
6483: LD_EXP 18
6487: PUSH
6488: LD_EXP 22
6492: AND
6493: PUSH
6494: LD_OWVAR 65
6498: PUSH
6499: LD_INT 7
6501: LESS
6502: AND
6503: IFFALSE 6517
6505: GO 6507
6507: DISABLE
// begin enable ;
6508: ENABLE
// game_speed := 7 ;
6509: LD_ADDR_OWVAR 65
6513: PUSH
6514: LD_INT 7
6516: ST_TO_ADDR
// end ;
6517: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
6518: LD_EXP 18
6522: PUSH
6523: LD_EXP 25
6527: AND
6528: IFFALSE 6730
6530: GO 6532
6532: DISABLE
6533: LD_INT 0
6535: PPUSH
6536: PPUSH
6537: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
6538: LD_ADDR_VAR 0 3
6542: PUSH
6543: LD_INT 81
6545: PUSH
6546: LD_OWVAR 2
6550: PUSH
6551: EMPTY
6552: LIST
6553: LIST
6554: PUSH
6555: LD_INT 21
6557: PUSH
6558: LD_INT 1
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: PUSH
6565: EMPTY
6566: LIST
6567: LIST
6568: PPUSH
6569: CALL_OW 69
6573: ST_TO_ADDR
// if not tmp then
6574: LD_VAR 0 3
6578: NOT
6579: IFFALSE 6583
// exit ;
6581: GO 6730
// if tmp > 5 then
6583: LD_VAR 0 3
6587: PUSH
6588: LD_INT 5
6590: GREATER
6591: IFFALSE 6603
// k := 5 else
6593: LD_ADDR_VAR 0 2
6597: PUSH
6598: LD_INT 5
6600: ST_TO_ADDR
6601: GO 6613
// k := tmp ;
6603: LD_ADDR_VAR 0 2
6607: PUSH
6608: LD_VAR 0 3
6612: ST_TO_ADDR
// for i := 1 to k do
6613: LD_ADDR_VAR 0 1
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_VAR 0 2
6627: PUSH
6628: FOR_TO
6629: IFFALSE 6728
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
6631: LD_VAR 0 3
6635: PUSH
6636: LD_VAR 0 1
6640: ARRAY
6641: PPUSH
6642: LD_VAR 0 1
6646: PUSH
6647: LD_INT 4
6649: MOD
6650: PUSH
6651: LD_INT 1
6653: PLUS
6654: PPUSH
6655: CALL_OW 259
6659: PUSH
6660: LD_INT 10
6662: LESS
6663: IFFALSE 6726
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
6665: LD_VAR 0 3
6669: PUSH
6670: LD_VAR 0 1
6674: ARRAY
6675: PPUSH
6676: LD_VAR 0 1
6680: PUSH
6681: LD_INT 4
6683: MOD
6684: PUSH
6685: LD_INT 1
6687: PLUS
6688: PPUSH
6689: LD_VAR 0 3
6693: PUSH
6694: LD_VAR 0 1
6698: ARRAY
6699: PPUSH
6700: LD_VAR 0 1
6704: PUSH
6705: LD_INT 4
6707: MOD
6708: PUSH
6709: LD_INT 1
6711: PLUS
6712: PPUSH
6713: CALL_OW 259
6717: PUSH
6718: LD_INT 1
6720: PLUS
6721: PPUSH
6722: CALL_OW 237
6726: GO 6628
6728: POP
6729: POP
// end ;
6730: PPOPN 3
6732: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
6733: LD_EXP 18
6737: PUSH
6738: LD_EXP 26
6742: AND
6743: IFFALSE 6763
6745: GO 6747
6747: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
6748: LD_INT 4
6750: PPUSH
6751: LD_OWVAR 2
6755: PPUSH
6756: LD_INT 0
6758: PPUSH
6759: CALL_OW 324
6763: END
// every 0 0$1 trigger StreamModeActive and sShovel do
6764: LD_EXP 18
6768: PUSH
6769: LD_EXP 55
6773: AND
6774: IFFALSE 6794
6776: GO 6778
6778: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
6779: LD_INT 19
6781: PPUSH
6782: LD_OWVAR 2
6786: PPUSH
6787: LD_INT 0
6789: PPUSH
6790: CALL_OW 324
6794: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
6795: LD_EXP 18
6799: PUSH
6800: LD_EXP 27
6804: AND
6805: IFFALSE 6907
6807: GO 6809
6809: DISABLE
6810: LD_INT 0
6812: PPUSH
6813: PPUSH
// begin enable ;
6814: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
6815: LD_ADDR_VAR 0 2
6819: PUSH
6820: LD_INT 22
6822: PUSH
6823: LD_OWVAR 2
6827: PUSH
6828: EMPTY
6829: LIST
6830: LIST
6831: PUSH
6832: LD_INT 2
6834: PUSH
6835: LD_INT 34
6837: PUSH
6838: LD_INT 11
6840: PUSH
6841: EMPTY
6842: LIST
6843: LIST
6844: PUSH
6845: LD_INT 34
6847: PUSH
6848: LD_INT 30
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: PUSH
6860: EMPTY
6861: LIST
6862: LIST
6863: PPUSH
6864: CALL_OW 69
6868: ST_TO_ADDR
// if not tmp then
6869: LD_VAR 0 2
6873: NOT
6874: IFFALSE 6878
// exit ;
6876: GO 6907
// for i in tmp do
6878: LD_ADDR_VAR 0 1
6882: PUSH
6883: LD_VAR 0 2
6887: PUSH
6888: FOR_IN
6889: IFFALSE 6905
// begin SetLives ( i , 0 ) ;
6891: LD_VAR 0 1
6895: PPUSH
6896: LD_INT 0
6898: PPUSH
6899: CALL_OW 234
// end ;
6903: GO 6888
6905: POP
6906: POP
// end ;
6907: PPOPN 2
6909: END
// every 0 0$1 trigger StreamModeActive and sBunker do
6910: LD_EXP 18
6914: PUSH
6915: LD_EXP 28
6919: AND
6920: IFFALSE 6940
6922: GO 6924
6924: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
6925: LD_INT 32
6927: PPUSH
6928: LD_OWVAR 2
6932: PPUSH
6933: LD_INT 0
6935: PPUSH
6936: CALL_OW 324
6940: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
6941: LD_EXP 18
6945: PUSH
6946: LD_EXP 29
6950: AND
6951: IFFALSE 7132
6953: GO 6955
6955: DISABLE
6956: LD_INT 0
6958: PPUSH
6959: PPUSH
6960: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
6961: LD_ADDR_VAR 0 2
6965: PUSH
6966: LD_INT 22
6968: PUSH
6969: LD_OWVAR 2
6973: PUSH
6974: EMPTY
6975: LIST
6976: LIST
6977: PUSH
6978: LD_INT 33
6980: PUSH
6981: LD_INT 3
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PPUSH
6992: CALL_OW 69
6996: ST_TO_ADDR
// if not tmp then
6997: LD_VAR 0 2
7001: NOT
7002: IFFALSE 7006
// exit ;
7004: GO 7132
// side := 0 ;
7006: LD_ADDR_VAR 0 3
7010: PUSH
7011: LD_INT 0
7013: ST_TO_ADDR
// for i := 1 to 8 do
7014: LD_ADDR_VAR 0 1
7018: PUSH
7019: DOUBLE
7020: LD_INT 1
7022: DEC
7023: ST_TO_ADDR
7024: LD_INT 8
7026: PUSH
7027: FOR_TO
7028: IFFALSE 7076
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
7030: LD_OWVAR 2
7034: PUSH
7035: LD_VAR 0 1
7039: NONEQUAL
7040: PUSH
7041: LD_OWVAR 2
7045: PPUSH
7046: LD_VAR 0 1
7050: PPUSH
7051: CALL_OW 81
7055: PUSH
7056: LD_INT 2
7058: EQUAL
7059: AND
7060: IFFALSE 7074
// begin side := i ;
7062: LD_ADDR_VAR 0 3
7066: PUSH
7067: LD_VAR 0 1
7071: ST_TO_ADDR
// break ;
7072: GO 7076
// end ;
7074: GO 7027
7076: POP
7077: POP
// if not side then
7078: LD_VAR 0 3
7082: NOT
7083: IFFALSE 7087
// exit ;
7085: GO 7132
// for i := 1 to tmp do
7087: LD_ADDR_VAR 0 1
7091: PUSH
7092: DOUBLE
7093: LD_INT 1
7095: DEC
7096: ST_TO_ADDR
7097: LD_VAR 0 2
7101: PUSH
7102: FOR_TO
7103: IFFALSE 7130
// if Prob ( 60 ) then
7105: LD_INT 60
7107: PPUSH
7108: CALL_OW 13
7112: IFFALSE 7128
// SetSide ( i , side ) ;
7114: LD_VAR 0 1
7118: PPUSH
7119: LD_VAR 0 3
7123: PPUSH
7124: CALL_OW 235
7128: GO 7102
7130: POP
7131: POP
// end ;
7132: PPOPN 3
7134: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
7135: LD_EXP 18
7139: PUSH
7140: LD_EXP 31
7144: AND
7145: IFFALSE 7264
7147: GO 7149
7149: DISABLE
7150: LD_INT 0
7152: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
7153: LD_ADDR_VAR 0 1
7157: PUSH
7158: LD_INT 22
7160: PUSH
7161: LD_OWVAR 2
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PUSH
7170: LD_INT 21
7172: PUSH
7173: LD_INT 1
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: LD_INT 3
7182: PUSH
7183: LD_INT 23
7185: PUSH
7186: LD_INT 0
7188: PUSH
7189: EMPTY
7190: LIST
7191: LIST
7192: PUSH
7193: EMPTY
7194: LIST
7195: LIST
7196: PUSH
7197: EMPTY
7198: LIST
7199: LIST
7200: LIST
7201: PPUSH
7202: CALL_OW 69
7206: PUSH
7207: FOR_IN
7208: IFFALSE 7262
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
7210: LD_VAR 0 1
7214: PPUSH
7215: CALL_OW 257
7219: PUSH
7220: LD_INT 1
7222: PUSH
7223: LD_INT 2
7225: PUSH
7226: LD_INT 3
7228: PUSH
7229: LD_INT 4
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: IN
7238: IFFALSE 7260
// SetClass ( un , rand ( 1 , 4 ) ) ;
7240: LD_VAR 0 1
7244: PPUSH
7245: LD_INT 1
7247: PPUSH
7248: LD_INT 4
7250: PPUSH
7251: CALL_OW 12
7255: PPUSH
7256: CALL_OW 336
7260: GO 7207
7262: POP
7263: POP
// end ;
7264: PPOPN 1
7266: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
7267: LD_EXP 18
7271: PUSH
7272: LD_EXP 30
7276: AND
7277: IFFALSE 7356
7279: GO 7281
7281: DISABLE
7282: LD_INT 0
7284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
7285: LD_ADDR_VAR 0 1
7289: PUSH
7290: LD_INT 22
7292: PUSH
7293: LD_OWVAR 2
7297: PUSH
7298: EMPTY
7299: LIST
7300: LIST
7301: PUSH
7302: LD_INT 21
7304: PUSH
7305: LD_INT 3
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: PPUSH
7316: CALL_OW 69
7320: ST_TO_ADDR
// if not tmp then
7321: LD_VAR 0 1
7325: NOT
7326: IFFALSE 7330
// exit ;
7328: GO 7356
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
7330: LD_VAR 0 1
7334: PUSH
7335: LD_INT 1
7337: PPUSH
7338: LD_VAR 0 1
7342: PPUSH
7343: CALL_OW 12
7347: ARRAY
7348: PPUSH
7349: LD_INT 100
7351: PPUSH
7352: CALL_OW 234
// end ;
7356: PPOPN 1
7358: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
7359: LD_EXP 18
7363: PUSH
7364: LD_EXP 32
7368: AND
7369: IFFALSE 7467
7371: GO 7373
7373: DISABLE
7374: LD_INT 0
7376: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
7377: LD_ADDR_VAR 0 1
7381: PUSH
7382: LD_INT 22
7384: PUSH
7385: LD_OWVAR 2
7389: PUSH
7390: EMPTY
7391: LIST
7392: LIST
7393: PUSH
7394: LD_INT 21
7396: PUSH
7397: LD_INT 1
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: ST_TO_ADDR
// if not tmp then
7413: LD_VAR 0 1
7417: NOT
7418: IFFALSE 7422
// exit ;
7420: GO 7467
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
7422: LD_VAR 0 1
7426: PUSH
7427: LD_INT 1
7429: PPUSH
7430: LD_VAR 0 1
7434: PPUSH
7435: CALL_OW 12
7439: ARRAY
7440: PPUSH
7441: LD_INT 1
7443: PPUSH
7444: LD_INT 4
7446: PPUSH
7447: CALL_OW 12
7451: PPUSH
7452: LD_INT 3000
7454: PPUSH
7455: LD_INT 9000
7457: PPUSH
7458: CALL_OW 12
7462: PPUSH
7463: CALL_OW 492
// end ;
7467: PPOPN 1
7469: END
// every 0 0$1 trigger StreamModeActive and sDepot do
7470: LD_EXP 18
7474: PUSH
7475: LD_EXP 33
7479: AND
7480: IFFALSE 7500
7482: GO 7484
7484: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
7485: LD_INT 1
7487: PPUSH
7488: LD_OWVAR 2
7492: PPUSH
7493: LD_INT 0
7495: PPUSH
7496: CALL_OW 324
7500: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
7501: LD_EXP 18
7505: PUSH
7506: LD_EXP 34
7510: AND
7511: IFFALSE 7594
7513: GO 7515
7515: DISABLE
7516: LD_INT 0
7518: PPUSH
7519: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
7520: LD_ADDR_VAR 0 2
7524: PUSH
7525: LD_INT 22
7527: PUSH
7528: LD_OWVAR 2
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 21
7539: PUSH
7540: LD_INT 3
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PPUSH
7551: CALL_OW 69
7555: ST_TO_ADDR
// if not tmp then
7556: LD_VAR 0 2
7560: NOT
7561: IFFALSE 7565
// exit ;
7563: GO 7594
// for i in tmp do
7565: LD_ADDR_VAR 0 1
7569: PUSH
7570: LD_VAR 0 2
7574: PUSH
7575: FOR_IN
7576: IFFALSE 7592
// SetBLevel ( i , 10 ) ;
7578: LD_VAR 0 1
7582: PPUSH
7583: LD_INT 10
7585: PPUSH
7586: CALL_OW 241
7590: GO 7575
7592: POP
7593: POP
// end ;
7594: PPOPN 2
7596: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
7597: LD_EXP 18
7601: PUSH
7602: LD_EXP 35
7606: AND
7607: IFFALSE 7718
7609: GO 7611
7611: DISABLE
7612: LD_INT 0
7614: PPUSH
7615: PPUSH
7616: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
7617: LD_ADDR_VAR 0 3
7621: PUSH
7622: LD_INT 22
7624: PUSH
7625: LD_OWVAR 2
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PUSH
7634: LD_INT 25
7636: PUSH
7637: LD_INT 1
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: PPUSH
7648: CALL_OW 69
7652: ST_TO_ADDR
// if not tmp then
7653: LD_VAR 0 3
7657: NOT
7658: IFFALSE 7662
// exit ;
7660: GO 7718
// un := tmp [ rand ( 1 , tmp ) ] ;
7662: LD_ADDR_VAR 0 2
7666: PUSH
7667: LD_VAR 0 3
7671: PUSH
7672: LD_INT 1
7674: PPUSH
7675: LD_VAR 0 3
7679: PPUSH
7680: CALL_OW 12
7684: ARRAY
7685: ST_TO_ADDR
// if Crawls ( un ) then
7686: LD_VAR 0 2
7690: PPUSH
7691: CALL_OW 318
7695: IFFALSE 7706
// ComWalk ( un ) ;
7697: LD_VAR 0 2
7701: PPUSH
7702: CALL_OW 138
// SetClass ( un , class_sniper ) ;
7706: LD_VAR 0 2
7710: PPUSH
7711: LD_INT 5
7713: PPUSH
7714: CALL_OW 336
// end ;
7718: PPOPN 3
7720: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
7721: LD_EXP 18
7725: PUSH
7726: LD_EXP 36
7730: AND
7731: PUSH
7732: LD_OWVAR 67
7736: PUSH
7737: LD_INT 3
7739: LESS
7740: AND
7741: IFFALSE 7760
7743: GO 7745
7745: DISABLE
// Difficulty := Difficulty + 1 ;
7746: LD_ADDR_OWVAR 67
7750: PUSH
7751: LD_OWVAR 67
7755: PUSH
7756: LD_INT 1
7758: PLUS
7759: ST_TO_ADDR
7760: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
7761: LD_EXP 18
7765: PUSH
7766: LD_EXP 37
7770: AND
7771: IFFALSE 7874
7773: GO 7775
7775: DISABLE
7776: LD_INT 0
7778: PPUSH
// begin for i := 1 to 5 do
7779: LD_ADDR_VAR 0 1
7783: PUSH
7784: DOUBLE
7785: LD_INT 1
7787: DEC
7788: ST_TO_ADDR
7789: LD_INT 5
7791: PUSH
7792: FOR_TO
7793: IFFALSE 7872
// begin uc_nation := nation_nature ;
7795: LD_ADDR_OWVAR 21
7799: PUSH
7800: LD_INT 0
7802: ST_TO_ADDR
// uc_side := 0 ;
7803: LD_ADDR_OWVAR 20
7807: PUSH
7808: LD_INT 0
7810: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
7811: LD_ADDR_OWVAR 29
7815: PUSH
7816: LD_INT 12
7818: PUSH
7819: LD_INT 12
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: ST_TO_ADDR
// hc_agressivity := 20 ;
7826: LD_ADDR_OWVAR 35
7830: PUSH
7831: LD_INT 20
7833: ST_TO_ADDR
// hc_class := class_tiger ;
7834: LD_ADDR_OWVAR 28
7838: PUSH
7839: LD_INT 14
7841: ST_TO_ADDR
// hc_gallery :=  ;
7842: LD_ADDR_OWVAR 33
7846: PUSH
7847: LD_STRING 
7849: ST_TO_ADDR
// hc_name :=  ;
7850: LD_ADDR_OWVAR 26
7854: PUSH
7855: LD_STRING 
7857: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
7858: CALL_OW 44
7862: PPUSH
7863: LD_INT 0
7865: PPUSH
7866: CALL_OW 51
// end ;
7870: GO 7792
7872: POP
7873: POP
// end ;
7874: PPOPN 1
7876: END
// every 0 0$1 trigger StreamModeActive and sBomb do
7877: LD_EXP 18
7881: PUSH
7882: LD_EXP 38
7886: AND
7887: IFFALSE 7896
7889: GO 7891
7891: DISABLE
// StreamSibBomb ;
7892: CALL 7897 0 0
7896: END
// export function StreamSibBomb ; var i , x , y ; begin
7897: LD_INT 0
7899: PPUSH
7900: PPUSH
7901: PPUSH
7902: PPUSH
// result := false ;
7903: LD_ADDR_VAR 0 1
7907: PUSH
7908: LD_INT 0
7910: ST_TO_ADDR
// for i := 1 to 16 do
7911: LD_ADDR_VAR 0 2
7915: PUSH
7916: DOUBLE
7917: LD_INT 1
7919: DEC
7920: ST_TO_ADDR
7921: LD_INT 16
7923: PUSH
7924: FOR_TO
7925: IFFALSE 8124
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
7927: LD_ADDR_VAR 0 3
7931: PUSH
7932: LD_INT 10
7934: PUSH
7935: LD_INT 20
7937: PUSH
7938: LD_INT 30
7940: PUSH
7941: LD_INT 40
7943: PUSH
7944: LD_INT 50
7946: PUSH
7947: LD_INT 60
7949: PUSH
7950: LD_INT 70
7952: PUSH
7953: LD_INT 80
7955: PUSH
7956: LD_INT 90
7958: PUSH
7959: LD_INT 100
7961: PUSH
7962: LD_INT 110
7964: PUSH
7965: LD_INT 120
7967: PUSH
7968: LD_INT 130
7970: PUSH
7971: LD_INT 140
7973: PUSH
7974: LD_INT 150
7976: PUSH
7977: EMPTY
7978: LIST
7979: LIST
7980: LIST
7981: LIST
7982: LIST
7983: LIST
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: LIST
7993: PUSH
7994: LD_INT 1
7996: PPUSH
7997: LD_INT 15
7999: PPUSH
8000: CALL_OW 12
8004: ARRAY
8005: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
8006: LD_ADDR_VAR 0 4
8010: PUSH
8011: LD_INT 10
8013: PUSH
8014: LD_INT 20
8016: PUSH
8017: LD_INT 30
8019: PUSH
8020: LD_INT 40
8022: PUSH
8023: LD_INT 50
8025: PUSH
8026: LD_INT 60
8028: PUSH
8029: LD_INT 70
8031: PUSH
8032: LD_INT 80
8034: PUSH
8035: LD_INT 90
8037: PUSH
8038: LD_INT 100
8040: PUSH
8041: LD_INT 110
8043: PUSH
8044: LD_INT 120
8046: PUSH
8047: LD_INT 130
8049: PUSH
8050: LD_INT 140
8052: PUSH
8053: LD_INT 150
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: LIST
8060: LIST
8061: LIST
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: LIST
8069: LIST
8070: LIST
8071: LIST
8072: PUSH
8073: LD_INT 1
8075: PPUSH
8076: LD_INT 15
8078: PPUSH
8079: CALL_OW 12
8083: ARRAY
8084: ST_TO_ADDR
// if ValidHex ( x , y ) then
8085: LD_VAR 0 3
8089: PPUSH
8090: LD_VAR 0 4
8094: PPUSH
8095: CALL_OW 488
8099: IFFALSE 8122
// begin result := [ x , y ] ;
8101: LD_ADDR_VAR 0 1
8105: PUSH
8106: LD_VAR 0 3
8110: PUSH
8111: LD_VAR 0 4
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: ST_TO_ADDR
// break ;
8120: GO 8124
// end ; end ;
8122: GO 7924
8124: POP
8125: POP
// if result then
8126: LD_VAR 0 1
8130: IFFALSE 8190
// begin ToLua ( playSibBomb() ) ;
8132: LD_STRING playSibBomb()
8134: PPUSH
8135: CALL_OW 559
// wait ( 0 0$14 ) ;
8139: LD_INT 490
8141: PPUSH
8142: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
8146: LD_VAR 0 1
8150: PUSH
8151: LD_INT 1
8153: ARRAY
8154: PPUSH
8155: LD_VAR 0 1
8159: PUSH
8160: LD_INT 2
8162: ARRAY
8163: PPUSH
8164: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
8168: LD_VAR 0 1
8172: PUSH
8173: LD_INT 1
8175: ARRAY
8176: PPUSH
8177: LD_VAR 0 1
8181: PUSH
8182: LD_INT 2
8184: ARRAY
8185: PPUSH
8186: CALL_OW 429
// end ; end ;
8190: LD_VAR 0 1
8194: RET
// every 0 0$1 trigger StreamModeActive and sReset do
8195: LD_EXP 18
8199: PUSH
8200: LD_EXP 40
8204: AND
8205: IFFALSE 8217
8207: GO 8209
8209: DISABLE
// YouLost (  ) ;
8210: LD_STRING 
8212: PPUSH
8213: CALL_OW 104
8217: END
// every 0 0$1 trigger StreamModeActive and sFog do
8218: LD_EXP 18
8222: PUSH
8223: LD_EXP 39
8227: AND
8228: IFFALSE 8242
8230: GO 8232
8232: DISABLE
// FogOff ( your_side ) ;
8233: LD_OWVAR 2
8237: PPUSH
8238: CALL_OW 344
8242: END
// every 0 0$1 trigger StreamModeActive and sSun do
8243: LD_EXP 18
8247: PUSH
8248: LD_EXP 41
8252: AND
8253: IFFALSE 8281
8255: GO 8257
8257: DISABLE
// begin solar_recharge_percent := 0 ;
8258: LD_ADDR_OWVAR 79
8262: PUSH
8263: LD_INT 0
8265: ST_TO_ADDR
// wait ( 5 5$00 ) ;
8266: LD_INT 10500
8268: PPUSH
8269: CALL_OW 67
// solar_recharge_percent := 100 ;
8273: LD_ADDR_OWVAR 79
8277: PUSH
8278: LD_INT 100
8280: ST_TO_ADDR
// end ;
8281: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
8282: LD_EXP 18
8286: PUSH
8287: LD_EXP 42
8291: AND
8292: IFFALSE 8531
8294: GO 8296
8296: DISABLE
8297: LD_INT 0
8299: PPUSH
8300: PPUSH
8301: PPUSH
// begin tmp := [ ] ;
8302: LD_ADDR_VAR 0 3
8306: PUSH
8307: EMPTY
8308: ST_TO_ADDR
// for i := 1 to 6 do
8309: LD_ADDR_VAR 0 1
8313: PUSH
8314: DOUBLE
8315: LD_INT 1
8317: DEC
8318: ST_TO_ADDR
8319: LD_INT 6
8321: PUSH
8322: FOR_TO
8323: IFFALSE 8428
// begin uc_nation := nation_nature ;
8325: LD_ADDR_OWVAR 21
8329: PUSH
8330: LD_INT 0
8332: ST_TO_ADDR
// uc_side := 0 ;
8333: LD_ADDR_OWVAR 20
8337: PUSH
8338: LD_INT 0
8340: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
8341: LD_ADDR_OWVAR 29
8345: PUSH
8346: LD_INT 12
8348: PUSH
8349: LD_INT 12
8351: PUSH
8352: EMPTY
8353: LIST
8354: LIST
8355: ST_TO_ADDR
// hc_agressivity := 20 ;
8356: LD_ADDR_OWVAR 35
8360: PUSH
8361: LD_INT 20
8363: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
8364: LD_ADDR_OWVAR 28
8368: PUSH
8369: LD_INT 17
8371: ST_TO_ADDR
// hc_gallery :=  ;
8372: LD_ADDR_OWVAR 33
8376: PUSH
8377: LD_STRING 
8379: ST_TO_ADDR
// hc_name :=  ;
8380: LD_ADDR_OWVAR 26
8384: PUSH
8385: LD_STRING 
8387: ST_TO_ADDR
// un := CreateHuman ;
8388: LD_ADDR_VAR 0 2
8392: PUSH
8393: CALL_OW 44
8397: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
8398: LD_VAR 0 2
8402: PPUSH
8403: LD_INT 1
8405: PPUSH
8406: CALL_OW 51
// tmp := tmp ^ un ;
8410: LD_ADDR_VAR 0 3
8414: PUSH
8415: LD_VAR 0 3
8419: PUSH
8420: LD_VAR 0 2
8424: ADD
8425: ST_TO_ADDR
// end ;
8426: GO 8322
8428: POP
8429: POP
// repeat wait ( 0 0$1 ) ;
8430: LD_INT 35
8432: PPUSH
8433: CALL_OW 67
// for un in tmp do
8437: LD_ADDR_VAR 0 2
8441: PUSH
8442: LD_VAR 0 3
8446: PUSH
8447: FOR_IN
8448: IFFALSE 8522
// begin if IsDead ( un ) then
8450: LD_VAR 0 2
8454: PPUSH
8455: CALL_OW 301
8459: IFFALSE 8479
// begin tmp := tmp diff un ;
8461: LD_ADDR_VAR 0 3
8465: PUSH
8466: LD_VAR 0 3
8470: PUSH
8471: LD_VAR 0 2
8475: DIFF
8476: ST_TO_ADDR
// continue ;
8477: GO 8447
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
8479: LD_VAR 0 2
8483: PPUSH
8484: LD_INT 3
8486: PUSH
8487: LD_INT 22
8489: PUSH
8490: LD_INT 0
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PPUSH
8501: CALL_OW 69
8505: PPUSH
8506: LD_VAR 0 2
8510: PPUSH
8511: CALL_OW 74
8515: PPUSH
8516: CALL_OW 115
// end ;
8520: GO 8447
8522: POP
8523: POP
// until not tmp ;
8524: LD_VAR 0 3
8528: NOT
8529: IFFALSE 8430
// end ;
8531: PPOPN 3
8533: END
// every 0 0$1 trigger StreamModeActive and sTroll do
8534: LD_EXP 18
8538: PUSH
8539: LD_EXP 43
8543: AND
8544: IFFALSE 8598
8546: GO 8548
8548: DISABLE
// begin ToLua ( displayTroll(); ) ;
8549: LD_STRING displayTroll();
8551: PPUSH
8552: CALL_OW 559
// wait ( 3 3$00 ) ;
8556: LD_INT 6300
8558: PPUSH
8559: CALL_OW 67
// ToLua ( hideTroll(); ) ;
8563: LD_STRING hideTroll();
8565: PPUSH
8566: CALL_OW 559
// wait ( 1 1$00 ) ;
8570: LD_INT 2100
8572: PPUSH
8573: CALL_OW 67
// ToLua ( displayTroll(); ) ;
8577: LD_STRING displayTroll();
8579: PPUSH
8580: CALL_OW 559
// wait ( 1 1$00 ) ;
8584: LD_INT 2100
8586: PPUSH
8587: CALL_OW 67
// ToLua ( hideTroll(); ) ;
8591: LD_STRING hideTroll();
8593: PPUSH
8594: CALL_OW 559
// end ;
8598: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
8599: LD_EXP 18
8603: PUSH
8604: LD_EXP 44
8608: AND
8609: IFFALSE 8672
8611: GO 8613
8613: DISABLE
8614: LD_INT 0
8616: PPUSH
// begin p := 0 ;
8617: LD_ADDR_VAR 0 1
8621: PUSH
8622: LD_INT 0
8624: ST_TO_ADDR
// repeat game_speed := 1 ;
8625: LD_ADDR_OWVAR 65
8629: PUSH
8630: LD_INT 1
8632: ST_TO_ADDR
// wait ( 0 0$1 ) ;
8633: LD_INT 35
8635: PPUSH
8636: CALL_OW 67
// p := p + 1 ;
8640: LD_ADDR_VAR 0 1
8644: PUSH
8645: LD_VAR 0 1
8649: PUSH
8650: LD_INT 1
8652: PLUS
8653: ST_TO_ADDR
// until p >= 60 ;
8654: LD_VAR 0 1
8658: PUSH
8659: LD_INT 60
8661: GREATEREQUAL
8662: IFFALSE 8625
// game_speed := 4 ;
8664: LD_ADDR_OWVAR 65
8668: PUSH
8669: LD_INT 4
8671: ST_TO_ADDR
// end ;
8672: PPOPN 1
8674: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
8675: LD_EXP 18
8679: PUSH
8680: LD_EXP 45
8684: AND
8685: IFFALSE 8831
8687: GO 8689
8689: DISABLE
8690: LD_INT 0
8692: PPUSH
8693: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
8694: LD_ADDR_VAR 0 1
8698: PUSH
8699: LD_INT 22
8701: PUSH
8702: LD_OWVAR 2
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PUSH
8711: LD_INT 2
8713: PUSH
8714: LD_INT 30
8716: PUSH
8717: LD_INT 0
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: PUSH
8724: LD_INT 30
8726: PUSH
8727: LD_INT 1
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: LIST
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: PPUSH
8743: CALL_OW 69
8747: ST_TO_ADDR
// if not depot then
8748: LD_VAR 0 1
8752: NOT
8753: IFFALSE 8757
// exit ;
8755: GO 8831
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
8757: LD_ADDR_VAR 0 2
8761: PUSH
8762: LD_VAR 0 1
8766: PUSH
8767: LD_INT 1
8769: PPUSH
8770: LD_VAR 0 1
8774: PPUSH
8775: CALL_OW 12
8779: ARRAY
8780: PPUSH
8781: CALL_OW 274
8785: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
8786: LD_VAR 0 2
8790: PPUSH
8791: LD_INT 1
8793: PPUSH
8794: LD_INT 0
8796: PPUSH
8797: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
8801: LD_VAR 0 2
8805: PPUSH
8806: LD_INT 2
8808: PPUSH
8809: LD_INT 0
8811: PPUSH
8812: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
8816: LD_VAR 0 2
8820: PPUSH
8821: LD_INT 3
8823: PPUSH
8824: LD_INT 0
8826: PPUSH
8827: CALL_OW 277
// end ;
8831: PPOPN 2
8833: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
8834: LD_EXP 18
8838: PUSH
8839: LD_EXP 46
8843: AND
8844: IFFALSE 8941
8846: GO 8848
8848: DISABLE
8849: LD_INT 0
8851: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
8852: LD_ADDR_VAR 0 1
8856: PUSH
8857: LD_INT 22
8859: PUSH
8860: LD_OWVAR 2
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: PUSH
8869: LD_INT 21
8871: PUSH
8872: LD_INT 1
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 3
8881: PUSH
8882: LD_INT 23
8884: PUSH
8885: LD_INT 0
8887: PUSH
8888: EMPTY
8889: LIST
8890: LIST
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: LIST
8900: PPUSH
8901: CALL_OW 69
8905: ST_TO_ADDR
// if not tmp then
8906: LD_VAR 0 1
8910: NOT
8911: IFFALSE 8915
// exit ;
8913: GO 8941
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
8915: LD_VAR 0 1
8919: PUSH
8920: LD_INT 1
8922: PPUSH
8923: LD_VAR 0 1
8927: PPUSH
8928: CALL_OW 12
8932: ARRAY
8933: PPUSH
8934: LD_INT 200
8936: PPUSH
8937: CALL_OW 234
// end ;
8941: PPOPN 1
8943: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
8944: LD_EXP 18
8948: PUSH
8949: LD_EXP 47
8953: AND
8954: IFFALSE 9033
8956: GO 8958
8958: DISABLE
8959: LD_INT 0
8961: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
8962: LD_ADDR_VAR 0 1
8966: PUSH
8967: LD_INT 22
8969: PUSH
8970: LD_OWVAR 2
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: PUSH
8979: LD_INT 21
8981: PUSH
8982: LD_INT 2
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: PPUSH
8993: CALL_OW 69
8997: ST_TO_ADDR
// if not tmp then
8998: LD_VAR 0 1
9002: NOT
9003: IFFALSE 9007
// exit ;
9005: GO 9033
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
9007: LD_VAR 0 1
9011: PUSH
9012: LD_INT 1
9014: PPUSH
9015: LD_VAR 0 1
9019: PPUSH
9020: CALL_OW 12
9024: ARRAY
9025: PPUSH
9026: LD_INT 60
9028: PPUSH
9029: CALL_OW 234
// end ;
9033: PPOPN 1
9035: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
9036: LD_EXP 18
9040: PUSH
9041: LD_EXP 48
9045: AND
9046: IFFALSE 9145
9048: GO 9050
9050: DISABLE
9051: LD_INT 0
9053: PPUSH
9054: PPUSH
// begin enable ;
9055: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
9056: LD_ADDR_VAR 0 1
9060: PUSH
9061: LD_INT 22
9063: PUSH
9064: LD_OWVAR 2
9068: PUSH
9069: EMPTY
9070: LIST
9071: LIST
9072: PUSH
9073: LD_INT 61
9075: PUSH
9076: EMPTY
9077: LIST
9078: PUSH
9079: LD_INT 33
9081: PUSH
9082: LD_INT 2
9084: PUSH
9085: EMPTY
9086: LIST
9087: LIST
9088: PUSH
9089: EMPTY
9090: LIST
9091: LIST
9092: LIST
9093: PPUSH
9094: CALL_OW 69
9098: ST_TO_ADDR
// if not tmp then
9099: LD_VAR 0 1
9103: NOT
9104: IFFALSE 9108
// exit ;
9106: GO 9145
// for i in tmp do
9108: LD_ADDR_VAR 0 2
9112: PUSH
9113: LD_VAR 0 1
9117: PUSH
9118: FOR_IN
9119: IFFALSE 9143
// if IsControledBy ( i ) then
9121: LD_VAR 0 2
9125: PPUSH
9126: CALL_OW 312
9130: IFFALSE 9141
// ComUnlink ( i ) ;
9132: LD_VAR 0 2
9136: PPUSH
9137: CALL_OW 136
9141: GO 9118
9143: POP
9144: POP
// end ;
9145: PPOPN 2
9147: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
9148: LD_EXP 18
9152: PUSH
9153: LD_EXP 49
9157: AND
9158: IFFALSE 9298
9160: GO 9162
9162: DISABLE
9163: LD_INT 0
9165: PPUSH
9166: PPUSH
// begin ToLua ( displayPowell(); ) ;
9167: LD_STRING displayPowell();
9169: PPUSH
9170: CALL_OW 559
// uc_side := 0 ;
9174: LD_ADDR_OWVAR 20
9178: PUSH
9179: LD_INT 0
9181: ST_TO_ADDR
// uc_nation := 2 ;
9182: LD_ADDR_OWVAR 21
9186: PUSH
9187: LD_INT 2
9189: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
9190: LD_ADDR_OWVAR 37
9194: PUSH
9195: LD_INT 14
9197: ST_TO_ADDR
// vc_engine := engine_siberite ;
9198: LD_ADDR_OWVAR 39
9202: PUSH
9203: LD_INT 3
9205: ST_TO_ADDR
// vc_control := control_apeman ;
9206: LD_ADDR_OWVAR 38
9210: PUSH
9211: LD_INT 5
9213: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
9214: LD_ADDR_OWVAR 40
9218: PUSH
9219: LD_INT 29
9221: ST_TO_ADDR
// un := CreateVehicle ;
9222: LD_ADDR_VAR 0 2
9226: PUSH
9227: CALL_OW 45
9231: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
9232: LD_VAR 0 2
9236: PPUSH
9237: LD_INT 1
9239: PPUSH
9240: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
9244: LD_INT 35
9246: PPUSH
9247: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
9251: LD_VAR 0 2
9255: PPUSH
9256: LD_INT 22
9258: PUSH
9259: LD_OWVAR 2
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: PPUSH
9268: CALL_OW 69
9272: PPUSH
9273: LD_VAR 0 2
9277: PPUSH
9278: CALL_OW 74
9282: PPUSH
9283: CALL_OW 115
// until IsDead ( un ) ;
9287: LD_VAR 0 2
9291: PPUSH
9292: CALL_OW 301
9296: IFFALSE 9244
// end ;
9298: PPOPN 2
9300: END
// every 0 0$1 trigger StreamModeActive and sStu do
9301: LD_EXP 18
9305: PUSH
9306: LD_EXP 57
9310: AND
9311: IFFALSE 9327
9313: GO 9315
9315: DISABLE
// begin ToLua ( displayStucuk(); ) ;
9316: LD_STRING displayStucuk();
9318: PPUSH
9319: CALL_OW 559
// ResetFog ;
9323: CALL_OW 335
// end ;
9327: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
9328: LD_EXP 18
9332: PUSH
9333: LD_EXP 50
9337: AND
9338: IFFALSE 9479
9340: GO 9342
9342: DISABLE
9343: LD_INT 0
9345: PPUSH
9346: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
9347: LD_ADDR_VAR 0 2
9351: PUSH
9352: LD_INT 22
9354: PUSH
9355: LD_OWVAR 2
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PUSH
9364: LD_INT 21
9366: PUSH
9367: LD_INT 1
9369: PUSH
9370: EMPTY
9371: LIST
9372: LIST
9373: PUSH
9374: EMPTY
9375: LIST
9376: LIST
9377: PPUSH
9378: CALL_OW 69
9382: ST_TO_ADDR
// if not tmp then
9383: LD_VAR 0 2
9387: NOT
9388: IFFALSE 9392
// exit ;
9390: GO 9479
// un := tmp [ rand ( 1 , tmp ) ] ;
9392: LD_ADDR_VAR 0 1
9396: PUSH
9397: LD_VAR 0 2
9401: PUSH
9402: LD_INT 1
9404: PPUSH
9405: LD_VAR 0 2
9409: PPUSH
9410: CALL_OW 12
9414: ARRAY
9415: ST_TO_ADDR
// SetSide ( un , 0 ) ;
9416: LD_VAR 0 1
9420: PPUSH
9421: LD_INT 0
9423: PPUSH
9424: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
9428: LD_VAR 0 1
9432: PPUSH
9433: LD_OWVAR 3
9437: PUSH
9438: LD_VAR 0 1
9442: DIFF
9443: PPUSH
9444: LD_VAR 0 1
9448: PPUSH
9449: CALL_OW 74
9453: PPUSH
9454: CALL_OW 115
// wait ( 0 0$20 ) ;
9458: LD_INT 700
9460: PPUSH
9461: CALL_OW 67
// SetSide ( un , your_side ) ;
9465: LD_VAR 0 1
9469: PPUSH
9470: LD_OWVAR 2
9474: PPUSH
9475: CALL_OW 235
// end ;
9479: PPOPN 2
9481: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
9482: LD_EXP 18
9486: PUSH
9487: LD_EXP 51
9491: AND
9492: IFFALSE 9598
9494: GO 9496
9496: DISABLE
9497: LD_INT 0
9499: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
9500: LD_ADDR_VAR 0 1
9504: PUSH
9505: LD_INT 22
9507: PUSH
9508: LD_OWVAR 2
9512: PUSH
9513: EMPTY
9514: LIST
9515: LIST
9516: PUSH
9517: LD_INT 2
9519: PUSH
9520: LD_INT 30
9522: PUSH
9523: LD_INT 0
9525: PUSH
9526: EMPTY
9527: LIST
9528: LIST
9529: PUSH
9530: LD_INT 30
9532: PUSH
9533: LD_INT 1
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: PUSH
9540: EMPTY
9541: LIST
9542: LIST
9543: LIST
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: PPUSH
9549: CALL_OW 69
9553: ST_TO_ADDR
// if not depot then
9554: LD_VAR 0 1
9558: NOT
9559: IFFALSE 9563
// exit ;
9561: GO 9598
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
9563: LD_VAR 0 1
9567: PUSH
9568: LD_INT 1
9570: ARRAY
9571: PPUSH
9572: CALL_OW 250
9576: PPUSH
9577: LD_VAR 0 1
9581: PUSH
9582: LD_INT 1
9584: ARRAY
9585: PPUSH
9586: CALL_OW 251
9590: PPUSH
9591: LD_INT 70
9593: PPUSH
9594: CALL_OW 495
// end ;
9598: PPOPN 1
9600: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
9601: LD_EXP 18
9605: PUSH
9606: LD_EXP 52
9610: AND
9611: IFFALSE 9822
9613: GO 9615
9615: DISABLE
9616: LD_INT 0
9618: PPUSH
9619: PPUSH
9620: PPUSH
9621: PPUSH
9622: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
9623: LD_ADDR_VAR 0 5
9627: PUSH
9628: LD_INT 22
9630: PUSH
9631: LD_OWVAR 2
9635: PUSH
9636: EMPTY
9637: LIST
9638: LIST
9639: PUSH
9640: LD_INT 21
9642: PUSH
9643: LD_INT 1
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: PPUSH
9654: CALL_OW 69
9658: ST_TO_ADDR
// if not tmp then
9659: LD_VAR 0 5
9663: NOT
9664: IFFALSE 9668
// exit ;
9666: GO 9822
// for i in tmp do
9668: LD_ADDR_VAR 0 1
9672: PUSH
9673: LD_VAR 0 5
9677: PUSH
9678: FOR_IN
9679: IFFALSE 9820
// begin d := rand ( 0 , 5 ) ;
9681: LD_ADDR_VAR 0 4
9685: PUSH
9686: LD_INT 0
9688: PPUSH
9689: LD_INT 5
9691: PPUSH
9692: CALL_OW 12
9696: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
9697: LD_ADDR_VAR 0 2
9701: PUSH
9702: LD_VAR 0 1
9706: PPUSH
9707: CALL_OW 250
9711: PPUSH
9712: LD_VAR 0 4
9716: PPUSH
9717: LD_INT 3
9719: PPUSH
9720: LD_INT 12
9722: PPUSH
9723: CALL_OW 12
9727: PPUSH
9728: CALL_OW 272
9732: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
9733: LD_ADDR_VAR 0 3
9737: PUSH
9738: LD_VAR 0 1
9742: PPUSH
9743: CALL_OW 251
9747: PPUSH
9748: LD_VAR 0 4
9752: PPUSH
9753: LD_INT 3
9755: PPUSH
9756: LD_INT 12
9758: PPUSH
9759: CALL_OW 12
9763: PPUSH
9764: CALL_OW 273
9768: ST_TO_ADDR
// if ValidHex ( x , y ) then
9769: LD_VAR 0 2
9773: PPUSH
9774: LD_VAR 0 3
9778: PPUSH
9779: CALL_OW 488
9783: IFFALSE 9818
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
9785: LD_VAR 0 1
9789: PPUSH
9790: LD_VAR 0 2
9794: PPUSH
9795: LD_VAR 0 3
9799: PPUSH
9800: LD_INT 3
9802: PPUSH
9803: LD_INT 6
9805: PPUSH
9806: CALL_OW 12
9810: PPUSH
9811: LD_INT 1
9813: PPUSH
9814: CALL_OW 483
// end ;
9818: GO 9678
9820: POP
9821: POP
// end ;
9822: PPOPN 5
9824: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
9825: LD_EXP 18
9829: PUSH
9830: LD_EXP 53
9834: AND
9835: IFFALSE 9929
9837: GO 9839
9839: DISABLE
9840: LD_INT 0
9842: PPUSH
9843: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
9844: LD_ADDR_VAR 0 2
9848: PUSH
9849: LD_INT 22
9851: PUSH
9852: LD_OWVAR 2
9856: PUSH
9857: EMPTY
9858: LIST
9859: LIST
9860: PUSH
9861: LD_INT 32
9863: PUSH
9864: LD_INT 1
9866: PUSH
9867: EMPTY
9868: LIST
9869: LIST
9870: PUSH
9871: LD_INT 21
9873: PUSH
9874: LD_INT 2
9876: PUSH
9877: EMPTY
9878: LIST
9879: LIST
9880: PUSH
9881: EMPTY
9882: LIST
9883: LIST
9884: LIST
9885: PPUSH
9886: CALL_OW 69
9890: ST_TO_ADDR
// if not tmp then
9891: LD_VAR 0 2
9895: NOT
9896: IFFALSE 9900
// exit ;
9898: GO 9929
// for i in tmp do
9900: LD_ADDR_VAR 0 1
9904: PUSH
9905: LD_VAR 0 2
9909: PUSH
9910: FOR_IN
9911: IFFALSE 9927
// SetFuel ( i , 0 ) ;
9913: LD_VAR 0 1
9917: PPUSH
9918: LD_INT 0
9920: PPUSH
9921: CALL_OW 240
9925: GO 9910
9927: POP
9928: POP
// end ;
9929: PPOPN 2
9931: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
9932: LD_EXP 18
9936: PUSH
9937: LD_EXP 54
9941: AND
9942: IFFALSE 10008
9944: GO 9946
9946: DISABLE
9947: LD_INT 0
9949: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
9950: LD_ADDR_VAR 0 1
9954: PUSH
9955: LD_INT 22
9957: PUSH
9958: LD_OWVAR 2
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: LD_INT 30
9969: PUSH
9970: LD_INT 29
9972: PUSH
9973: EMPTY
9974: LIST
9975: LIST
9976: PUSH
9977: EMPTY
9978: LIST
9979: LIST
9980: PPUSH
9981: CALL_OW 69
9985: ST_TO_ADDR
// if not tmp then
9986: LD_VAR 0 1
9990: NOT
9991: IFFALSE 9995
// exit ;
9993: GO 10008
// DestroyUnit ( tmp [ 1 ] ) ;
9995: LD_VAR 0 1
9999: PUSH
10000: LD_INT 1
10002: ARRAY
10003: PPUSH
10004: CALL_OW 65
// end ;
10008: PPOPN 1
10010: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
10011: LD_EXP 18
10015: PUSH
10016: LD_EXP 56
10020: AND
10021: IFFALSE 10150
10023: GO 10025
10025: DISABLE
10026: LD_INT 0
10028: PPUSH
// begin uc_side := 0 ;
10029: LD_ADDR_OWVAR 20
10033: PUSH
10034: LD_INT 0
10036: ST_TO_ADDR
// uc_nation := nation_arabian ;
10037: LD_ADDR_OWVAR 21
10041: PUSH
10042: LD_INT 2
10044: ST_TO_ADDR
// hc_gallery :=  ;
10045: LD_ADDR_OWVAR 33
10049: PUSH
10050: LD_STRING 
10052: ST_TO_ADDR
// hc_name :=  ;
10053: LD_ADDR_OWVAR 26
10057: PUSH
10058: LD_STRING 
10060: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
10061: LD_INT 1
10063: PPUSH
10064: LD_INT 11
10066: PPUSH
10067: LD_INT 10
10069: PPUSH
10070: CALL_OW 380
// un := CreateHuman ;
10074: LD_ADDR_VAR 0 1
10078: PUSH
10079: CALL_OW 44
10083: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
10084: LD_VAR 0 1
10088: PPUSH
10089: LD_INT 1
10091: PPUSH
10092: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
10096: LD_INT 35
10098: PPUSH
10099: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
10103: LD_VAR 0 1
10107: PPUSH
10108: LD_INT 22
10110: PUSH
10111: LD_OWVAR 2
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PPUSH
10120: CALL_OW 69
10124: PPUSH
10125: LD_VAR 0 1
10129: PPUSH
10130: CALL_OW 74
10134: PPUSH
10135: CALL_OW 115
// until IsDead ( un ) ;
10139: LD_VAR 0 1
10143: PPUSH
10144: CALL_OW 301
10148: IFFALSE 10096
// end ;
10150: PPOPN 1
10152: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
10153: LD_EXP 18
10157: PUSH
10158: LD_EXP 58
10162: AND
10163: IFFALSE 10175
10165: GO 10167
10167: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
10168: LD_STRING earthquake(getX(game), 0, 32)
10170: PPUSH
10171: CALL_OW 559
10175: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
10176: LD_EXP 18
10180: PUSH
10181: LD_EXP 59
10185: AND
10186: IFFALSE 10277
10188: GO 10190
10190: DISABLE
10191: LD_INT 0
10193: PPUSH
// begin enable ;
10194: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
10195: LD_ADDR_VAR 0 1
10199: PUSH
10200: LD_INT 22
10202: PUSH
10203: LD_OWVAR 2
10207: PUSH
10208: EMPTY
10209: LIST
10210: LIST
10211: PUSH
10212: LD_INT 21
10214: PUSH
10215: LD_INT 2
10217: PUSH
10218: EMPTY
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 33
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: EMPTY
10229: LIST
10230: LIST
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: LIST
10236: PPUSH
10237: CALL_OW 69
10241: ST_TO_ADDR
// if not tmp then
10242: LD_VAR 0 1
10246: NOT
10247: IFFALSE 10251
// exit ;
10249: GO 10277
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
10251: LD_VAR 0 1
10255: PUSH
10256: LD_INT 1
10258: PPUSH
10259: LD_VAR 0 1
10263: PPUSH
10264: CALL_OW 12
10268: ARRAY
10269: PPUSH
10270: LD_INT 1
10272: PPUSH
10273: CALL_OW 234
// end ;
10277: PPOPN 1
10279: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
10280: LD_EXP 18
10284: PUSH
10285: LD_EXP 60
10289: AND
10290: IFFALSE 10431
10292: GO 10294
10294: DISABLE
10295: LD_INT 0
10297: PPUSH
10298: PPUSH
10299: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10300: LD_ADDR_VAR 0 3
10304: PUSH
10305: LD_INT 22
10307: PUSH
10308: LD_OWVAR 2
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: PUSH
10317: LD_INT 25
10319: PUSH
10320: LD_INT 1
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: PPUSH
10331: CALL_OW 69
10335: ST_TO_ADDR
// if not tmp then
10336: LD_VAR 0 3
10340: NOT
10341: IFFALSE 10345
// exit ;
10343: GO 10431
// un := tmp [ rand ( 1 , tmp ) ] ;
10345: LD_ADDR_VAR 0 2
10349: PUSH
10350: LD_VAR 0 3
10354: PUSH
10355: LD_INT 1
10357: PPUSH
10358: LD_VAR 0 3
10362: PPUSH
10363: CALL_OW 12
10367: ARRAY
10368: ST_TO_ADDR
// if Crawls ( un ) then
10369: LD_VAR 0 2
10373: PPUSH
10374: CALL_OW 318
10378: IFFALSE 10389
// ComWalk ( un ) ;
10380: LD_VAR 0 2
10384: PPUSH
10385: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
10389: LD_VAR 0 2
10393: PPUSH
10394: LD_INT 9
10396: PPUSH
10397: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
10401: LD_INT 28
10403: PPUSH
10404: LD_OWVAR 2
10408: PPUSH
10409: LD_INT 2
10411: PPUSH
10412: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
10416: LD_INT 29
10418: PPUSH
10419: LD_OWVAR 2
10423: PPUSH
10424: LD_INT 2
10426: PPUSH
10427: CALL_OW 322
// end ;
10431: PPOPN 3
10433: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
10434: LD_EXP 18
10438: PUSH
10439: LD_EXP 61
10443: AND
10444: IFFALSE 10555
10446: GO 10448
10448: DISABLE
10449: LD_INT 0
10451: PPUSH
10452: PPUSH
10453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
10454: LD_ADDR_VAR 0 3
10458: PUSH
10459: LD_INT 22
10461: PUSH
10462: LD_OWVAR 2
10466: PUSH
10467: EMPTY
10468: LIST
10469: LIST
10470: PUSH
10471: LD_INT 25
10473: PUSH
10474: LD_INT 1
10476: PUSH
10477: EMPTY
10478: LIST
10479: LIST
10480: PUSH
10481: EMPTY
10482: LIST
10483: LIST
10484: PPUSH
10485: CALL_OW 69
10489: ST_TO_ADDR
// if not tmp then
10490: LD_VAR 0 3
10494: NOT
10495: IFFALSE 10499
// exit ;
10497: GO 10555
// un := tmp [ rand ( 1 , tmp ) ] ;
10499: LD_ADDR_VAR 0 2
10503: PUSH
10504: LD_VAR 0 3
10508: PUSH
10509: LD_INT 1
10511: PPUSH
10512: LD_VAR 0 3
10516: PPUSH
10517: CALL_OW 12
10521: ARRAY
10522: ST_TO_ADDR
// if Crawls ( un ) then
10523: LD_VAR 0 2
10527: PPUSH
10528: CALL_OW 318
10532: IFFALSE 10543
// ComWalk ( un ) ;
10534: LD_VAR 0 2
10538: PPUSH
10539: CALL_OW 138
// SetClass ( un , class_mortar ) ;
10543: LD_VAR 0 2
10547: PPUSH
10548: LD_INT 8
10550: PPUSH
10551: CALL_OW 336
// end ;
10555: PPOPN 3
10557: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
10558: LD_EXP 18
10562: PUSH
10563: LD_EXP 62
10567: AND
10568: IFFALSE 10712
10570: GO 10572
10572: DISABLE
10573: LD_INT 0
10575: PPUSH
10576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
10577: LD_ADDR_VAR 0 2
10581: PUSH
10582: LD_INT 22
10584: PUSH
10585: LD_OWVAR 2
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PUSH
10594: LD_INT 21
10596: PUSH
10597: LD_INT 2
10599: PUSH
10600: EMPTY
10601: LIST
10602: LIST
10603: PUSH
10604: LD_INT 2
10606: PUSH
10607: LD_INT 34
10609: PUSH
10610: LD_INT 12
10612: PUSH
10613: EMPTY
10614: LIST
10615: LIST
10616: PUSH
10617: LD_INT 34
10619: PUSH
10620: LD_INT 51
10622: PUSH
10623: EMPTY
10624: LIST
10625: LIST
10626: PUSH
10627: LD_INT 34
10629: PUSH
10630: LD_INT 32
10632: PUSH
10633: EMPTY
10634: LIST
10635: LIST
10636: PUSH
10637: EMPTY
10638: LIST
10639: LIST
10640: LIST
10641: LIST
10642: PUSH
10643: EMPTY
10644: LIST
10645: LIST
10646: LIST
10647: PPUSH
10648: CALL_OW 69
10652: ST_TO_ADDR
// if not tmp then
10653: LD_VAR 0 2
10657: NOT
10658: IFFALSE 10662
// exit ;
10660: GO 10712
// for i in tmp do
10662: LD_ADDR_VAR 0 1
10666: PUSH
10667: LD_VAR 0 2
10671: PUSH
10672: FOR_IN
10673: IFFALSE 10710
// if GetCargo ( i , mat_artifact ) = 0 then
10675: LD_VAR 0 1
10679: PPUSH
10680: LD_INT 4
10682: PPUSH
10683: CALL_OW 289
10687: PUSH
10688: LD_INT 0
10690: EQUAL
10691: IFFALSE 10708
// SetCargo ( i , mat_siberit , 100 ) ;
10693: LD_VAR 0 1
10697: PPUSH
10698: LD_INT 3
10700: PPUSH
10701: LD_INT 100
10703: PPUSH
10704: CALL_OW 290
10708: GO 10672
10710: POP
10711: POP
// end ;
10712: PPOPN 2
10714: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
10715: LD_EXP 18
10719: PUSH
10720: LD_EXP 63
10724: AND
10725: IFFALSE 10878
10727: GO 10729
10729: DISABLE
10730: LD_INT 0
10732: PPUSH
10733: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
10734: LD_ADDR_VAR 0 2
10738: PUSH
10739: LD_INT 22
10741: PUSH
10742: LD_OWVAR 2
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PPUSH
10751: CALL_OW 69
10755: ST_TO_ADDR
// if not tmp then
10756: LD_VAR 0 2
10760: NOT
10761: IFFALSE 10765
// exit ;
10763: GO 10878
// for i := 1 to 2 do
10765: LD_ADDR_VAR 0 1
10769: PUSH
10770: DOUBLE
10771: LD_INT 1
10773: DEC
10774: ST_TO_ADDR
10775: LD_INT 2
10777: PUSH
10778: FOR_TO
10779: IFFALSE 10876
// begin uc_side := your_side ;
10781: LD_ADDR_OWVAR 20
10785: PUSH
10786: LD_OWVAR 2
10790: ST_TO_ADDR
// uc_nation := nation_american ;
10791: LD_ADDR_OWVAR 21
10795: PUSH
10796: LD_INT 1
10798: ST_TO_ADDR
// vc_chassis := us_morphling ;
10799: LD_ADDR_OWVAR 37
10803: PUSH
10804: LD_INT 5
10806: ST_TO_ADDR
// vc_engine := engine_siberite ;
10807: LD_ADDR_OWVAR 39
10811: PUSH
10812: LD_INT 3
10814: ST_TO_ADDR
// vc_control := control_computer ;
10815: LD_ADDR_OWVAR 38
10819: PUSH
10820: LD_INT 3
10822: ST_TO_ADDR
// vc_weapon := us_double_laser ;
10823: LD_ADDR_OWVAR 40
10827: PUSH
10828: LD_INT 10
10830: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
10831: CALL_OW 45
10835: PPUSH
10836: LD_VAR 0 2
10840: PUSH
10841: LD_INT 1
10843: ARRAY
10844: PPUSH
10845: CALL_OW 250
10849: PPUSH
10850: LD_VAR 0 2
10854: PUSH
10855: LD_INT 1
10857: ARRAY
10858: PPUSH
10859: CALL_OW 251
10863: PPUSH
10864: LD_INT 12
10866: PPUSH
10867: LD_INT 1
10869: PPUSH
10870: CALL_OW 50
// end ;
10874: GO 10778
10876: POP
10877: POP
// end ;
10878: PPOPN 2
10880: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
10881: LD_EXP 18
10885: PUSH
10886: LD_EXP 64
10890: AND
10891: IFFALSE 11113
10893: GO 10895
10895: DISABLE
10896: LD_INT 0
10898: PPUSH
10899: PPUSH
10900: PPUSH
10901: PPUSH
10902: PPUSH
10903: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
10904: LD_ADDR_VAR 0 6
10908: PUSH
10909: LD_INT 22
10911: PUSH
10912: LD_OWVAR 2
10916: PUSH
10917: EMPTY
10918: LIST
10919: LIST
10920: PUSH
10921: LD_INT 21
10923: PUSH
10924: LD_INT 1
10926: PUSH
10927: EMPTY
10928: LIST
10929: LIST
10930: PUSH
10931: LD_INT 3
10933: PUSH
10934: LD_INT 23
10936: PUSH
10937: LD_INT 0
10939: PUSH
10940: EMPTY
10941: LIST
10942: LIST
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: LIST
10952: PPUSH
10953: CALL_OW 69
10957: ST_TO_ADDR
// if not tmp then
10958: LD_VAR 0 6
10962: NOT
10963: IFFALSE 10967
// exit ;
10965: GO 11113
// s1 := rand ( 1 , 4 ) ;
10967: LD_ADDR_VAR 0 2
10971: PUSH
10972: LD_INT 1
10974: PPUSH
10975: LD_INT 4
10977: PPUSH
10978: CALL_OW 12
10982: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
10983: LD_ADDR_VAR 0 4
10987: PUSH
10988: LD_VAR 0 6
10992: PUSH
10993: LD_INT 1
10995: ARRAY
10996: PPUSH
10997: LD_VAR 0 2
11001: PPUSH
11002: CALL_OW 259
11006: ST_TO_ADDR
// if s1 = 1 then
11007: LD_VAR 0 2
11011: PUSH
11012: LD_INT 1
11014: EQUAL
11015: IFFALSE 11035
// s2 := rand ( 2 , 4 ) else
11017: LD_ADDR_VAR 0 3
11021: PUSH
11022: LD_INT 2
11024: PPUSH
11025: LD_INT 4
11027: PPUSH
11028: CALL_OW 12
11032: ST_TO_ADDR
11033: GO 11043
// s2 := 1 ;
11035: LD_ADDR_VAR 0 3
11039: PUSH
11040: LD_INT 1
11042: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
11043: LD_ADDR_VAR 0 5
11047: PUSH
11048: LD_VAR 0 6
11052: PUSH
11053: LD_INT 1
11055: ARRAY
11056: PPUSH
11057: LD_VAR 0 3
11061: PPUSH
11062: CALL_OW 259
11066: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
11067: LD_VAR 0 6
11071: PUSH
11072: LD_INT 1
11074: ARRAY
11075: PPUSH
11076: LD_VAR 0 2
11080: PPUSH
11081: LD_VAR 0 5
11085: PPUSH
11086: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
11090: LD_VAR 0 6
11094: PUSH
11095: LD_INT 1
11097: ARRAY
11098: PPUSH
11099: LD_VAR 0 3
11103: PPUSH
11104: LD_VAR 0 4
11108: PPUSH
11109: CALL_OW 237
// end ;
11113: PPOPN 6
11115: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
11116: LD_EXP 18
11120: PUSH
11121: LD_EXP 65
11125: AND
11126: IFFALSE 11205
11128: GO 11130
11130: DISABLE
11131: LD_INT 0
11133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
11134: LD_ADDR_VAR 0 1
11138: PUSH
11139: LD_INT 22
11141: PUSH
11142: LD_OWVAR 2
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: PUSH
11151: LD_INT 30
11153: PUSH
11154: LD_INT 3
11156: PUSH
11157: EMPTY
11158: LIST
11159: LIST
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PPUSH
11165: CALL_OW 69
11169: ST_TO_ADDR
// if not tmp then
11170: LD_VAR 0 1
11174: NOT
11175: IFFALSE 11179
// exit ;
11177: GO 11205
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
11179: LD_VAR 0 1
11183: PUSH
11184: LD_INT 1
11186: PPUSH
11187: LD_VAR 0 1
11191: PPUSH
11192: CALL_OW 12
11196: ARRAY
11197: PPUSH
11198: LD_INT 1
11200: PPUSH
11201: CALL_OW 234
// end ;
11205: PPOPN 1
11207: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
11208: LD_EXP 18
11212: PUSH
11213: LD_EXP 66
11217: AND
11218: IFFALSE 11330
11220: GO 11222
11222: DISABLE
11223: LD_INT 0
11225: PPUSH
11226: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
11227: LD_ADDR_VAR 0 2
11231: PUSH
11232: LD_INT 22
11234: PUSH
11235: LD_OWVAR 2
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: LD_INT 2
11246: PUSH
11247: LD_INT 30
11249: PUSH
11250: LD_INT 27
11252: PUSH
11253: EMPTY
11254: LIST
11255: LIST
11256: PUSH
11257: LD_INT 30
11259: PUSH
11260: LD_INT 26
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: PUSH
11267: LD_INT 30
11269: PUSH
11270: LD_INT 28
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PPUSH
11287: CALL_OW 69
11291: ST_TO_ADDR
// if not tmp then
11292: LD_VAR 0 2
11296: NOT
11297: IFFALSE 11301
// exit ;
11299: GO 11330
// for i in tmp do
11301: LD_ADDR_VAR 0 1
11305: PUSH
11306: LD_VAR 0 2
11310: PUSH
11311: FOR_IN
11312: IFFALSE 11328
// SetLives ( i , 1 ) ;
11314: LD_VAR 0 1
11318: PPUSH
11319: LD_INT 1
11321: PPUSH
11322: CALL_OW 234
11326: GO 11311
11328: POP
11329: POP
// end ;
11330: PPOPN 2
11332: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
11333: LD_EXP 18
11337: PUSH
11338: LD_EXP 67
11342: AND
11343: IFFALSE 11617
11345: GO 11347
11347: DISABLE
11348: LD_INT 0
11350: PPUSH
11351: PPUSH
11352: PPUSH
// begin i := rand ( 1 , 7 ) ;
11353: LD_ADDR_VAR 0 1
11357: PUSH
11358: LD_INT 1
11360: PPUSH
11361: LD_INT 7
11363: PPUSH
11364: CALL_OW 12
11368: ST_TO_ADDR
// case i of 1 :
11369: LD_VAR 0 1
11373: PUSH
11374: LD_INT 1
11376: DOUBLE
11377: EQUAL
11378: IFTRUE 11382
11380: GO 11392
11382: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
11383: LD_STRING earthquake(getX(game), 0, 32)
11385: PPUSH
11386: CALL_OW 559
11390: GO 11617
11392: LD_INT 2
11394: DOUBLE
11395: EQUAL
11396: IFTRUE 11400
11398: GO 11414
11400: POP
// begin ToLua ( displayStucuk(); ) ;
11401: LD_STRING displayStucuk();
11403: PPUSH
11404: CALL_OW 559
// ResetFog ;
11408: CALL_OW 335
// end ; 3 :
11412: GO 11617
11414: LD_INT 3
11416: DOUBLE
11417: EQUAL
11418: IFTRUE 11422
11420: GO 11526
11422: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
11423: LD_ADDR_VAR 0 2
11427: PUSH
11428: LD_INT 22
11430: PUSH
11431: LD_OWVAR 2
11435: PUSH
11436: EMPTY
11437: LIST
11438: LIST
11439: PUSH
11440: LD_INT 25
11442: PUSH
11443: LD_INT 1
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PUSH
11450: EMPTY
11451: LIST
11452: LIST
11453: PPUSH
11454: CALL_OW 69
11458: ST_TO_ADDR
// if not tmp then
11459: LD_VAR 0 2
11463: NOT
11464: IFFALSE 11468
// exit ;
11466: GO 11617
// un := tmp [ rand ( 1 , tmp ) ] ;
11468: LD_ADDR_VAR 0 3
11472: PUSH
11473: LD_VAR 0 2
11477: PUSH
11478: LD_INT 1
11480: PPUSH
11481: LD_VAR 0 2
11485: PPUSH
11486: CALL_OW 12
11490: ARRAY
11491: ST_TO_ADDR
// if Crawls ( un ) then
11492: LD_VAR 0 3
11496: PPUSH
11497: CALL_OW 318
11501: IFFALSE 11512
// ComWalk ( un ) ;
11503: LD_VAR 0 3
11507: PPUSH
11508: CALL_OW 138
// SetClass ( un , class_mortar ) ;
11512: LD_VAR 0 3
11516: PPUSH
11517: LD_INT 8
11519: PPUSH
11520: CALL_OW 336
// end ; 4 :
11524: GO 11617
11526: LD_INT 4
11528: DOUBLE
11529: EQUAL
11530: IFTRUE 11534
11532: GO 11595
11534: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
11535: LD_ADDR_VAR 0 2
11539: PUSH
11540: LD_INT 22
11542: PUSH
11543: LD_OWVAR 2
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 30
11554: PUSH
11555: LD_INT 29
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: EMPTY
11563: LIST
11564: LIST
11565: PPUSH
11566: CALL_OW 69
11570: ST_TO_ADDR
// if not tmp then
11571: LD_VAR 0 2
11575: NOT
11576: IFFALSE 11580
// exit ;
11578: GO 11617
// DestroyUnit ( tmp [ 1 ] ) ;
11580: LD_VAR 0 2
11584: PUSH
11585: LD_INT 1
11587: ARRAY
11588: PPUSH
11589: CALL_OW 65
// end ; 5 .. 7 :
11593: GO 11617
11595: LD_INT 5
11597: DOUBLE
11598: GREATEREQUAL
11599: IFFALSE 11607
11601: LD_INT 7
11603: DOUBLE
11604: LESSEQUAL
11605: IFTRUE 11609
11607: GO 11616
11609: POP
// StreamSibBomb ; end ;
11610: CALL 7897 0 0
11614: GO 11617
11616: POP
// end ;
11617: PPOPN 3
11619: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
11620: LD_EXP 18
11624: PUSH
11625: LD_EXP 68
11629: AND
11630: IFFALSE 11786
11632: GO 11634
11634: DISABLE
11635: LD_INT 0
11637: PPUSH
11638: PPUSH
11639: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
11640: LD_ADDR_VAR 0 2
11644: PUSH
11645: LD_INT 81
11647: PUSH
11648: LD_OWVAR 2
11652: PUSH
11653: EMPTY
11654: LIST
11655: LIST
11656: PUSH
11657: LD_INT 2
11659: PUSH
11660: LD_INT 21
11662: PUSH
11663: LD_INT 1
11665: PUSH
11666: EMPTY
11667: LIST
11668: LIST
11669: PUSH
11670: LD_INT 21
11672: PUSH
11673: LD_INT 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: LIST
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: PPUSH
11689: CALL_OW 69
11693: ST_TO_ADDR
// if not tmp then
11694: LD_VAR 0 2
11698: NOT
11699: IFFALSE 11703
// exit ;
11701: GO 11786
// p := 0 ;
11703: LD_ADDR_VAR 0 3
11707: PUSH
11708: LD_INT 0
11710: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11711: LD_INT 35
11713: PPUSH
11714: CALL_OW 67
// p := p + 1 ;
11718: LD_ADDR_VAR 0 3
11722: PUSH
11723: LD_VAR 0 3
11727: PUSH
11728: LD_INT 1
11730: PLUS
11731: ST_TO_ADDR
// for i in tmp do
11732: LD_ADDR_VAR 0 1
11736: PUSH
11737: LD_VAR 0 2
11741: PUSH
11742: FOR_IN
11743: IFFALSE 11774
// if GetLives ( i ) < 1000 then
11745: LD_VAR 0 1
11749: PPUSH
11750: CALL_OW 256
11754: PUSH
11755: LD_INT 1000
11757: LESS
11758: IFFALSE 11772
// SetLives ( i , 1000 ) ;
11760: LD_VAR 0 1
11764: PPUSH
11765: LD_INT 1000
11767: PPUSH
11768: CALL_OW 234
11772: GO 11742
11774: POP
11775: POP
// until p > 20 ;
11776: LD_VAR 0 3
11780: PUSH
11781: LD_INT 20
11783: GREATER
11784: IFFALSE 11711
// end ;
11786: PPOPN 3
11788: END
// every 0 0$1 trigger StreamModeActive and sTime do
11789: LD_EXP 18
11793: PUSH
11794: LD_EXP 69
11798: AND
11799: IFFALSE 11834
11801: GO 11803
11803: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
11804: LD_INT 28
11806: PPUSH
11807: LD_OWVAR 2
11811: PPUSH
11812: LD_INT 2
11814: PPUSH
11815: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
11819: LD_INT 30
11821: PPUSH
11822: LD_OWVAR 2
11826: PPUSH
11827: LD_INT 2
11829: PPUSH
11830: CALL_OW 322
// end ;
11834: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
11835: LD_EXP 18
11839: PUSH
11840: LD_EXP 70
11844: AND
11845: IFFALSE 11966
11847: GO 11849
11849: DISABLE
11850: LD_INT 0
11852: PPUSH
11853: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
11854: LD_ADDR_VAR 0 2
11858: PUSH
11859: LD_INT 22
11861: PUSH
11862: LD_OWVAR 2
11866: PUSH
11867: EMPTY
11868: LIST
11869: LIST
11870: PUSH
11871: LD_INT 21
11873: PUSH
11874: LD_INT 1
11876: PUSH
11877: EMPTY
11878: LIST
11879: LIST
11880: PUSH
11881: LD_INT 3
11883: PUSH
11884: LD_INT 23
11886: PUSH
11887: LD_INT 0
11889: PUSH
11890: EMPTY
11891: LIST
11892: LIST
11893: PUSH
11894: EMPTY
11895: LIST
11896: LIST
11897: PUSH
11898: EMPTY
11899: LIST
11900: LIST
11901: LIST
11902: PPUSH
11903: CALL_OW 69
11907: ST_TO_ADDR
// if not tmp then
11908: LD_VAR 0 2
11912: NOT
11913: IFFALSE 11917
// exit ;
11915: GO 11966
// for i in tmp do
11917: LD_ADDR_VAR 0 1
11921: PUSH
11922: LD_VAR 0 2
11926: PUSH
11927: FOR_IN
11928: IFFALSE 11964
// begin if Crawls ( i ) then
11930: LD_VAR 0 1
11934: PPUSH
11935: CALL_OW 318
11939: IFFALSE 11950
// ComWalk ( i ) ;
11941: LD_VAR 0 1
11945: PPUSH
11946: CALL_OW 138
// SetClass ( i , 2 ) ;
11950: LD_VAR 0 1
11954: PPUSH
11955: LD_INT 2
11957: PPUSH
11958: CALL_OW 336
// end ;
11962: GO 11927
11964: POP
11965: POP
// end ;
11966: PPOPN 2
11968: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
11969: LD_EXP 18
11973: PUSH
11974: LD_EXP 71
11978: AND
11979: IFFALSE 12260
11981: GO 11983
11983: DISABLE
11984: LD_INT 0
11986: PPUSH
11987: PPUSH
11988: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
11989: LD_OWVAR 2
11993: PPUSH
11994: LD_INT 9
11996: PPUSH
11997: LD_INT 1
11999: PPUSH
12000: LD_INT 1
12002: PPUSH
12003: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
12007: LD_INT 9
12009: PPUSH
12010: LD_OWVAR 2
12014: PPUSH
12015: CALL_OW 343
// uc_side := 9 ;
12019: LD_ADDR_OWVAR 20
12023: PUSH
12024: LD_INT 9
12026: ST_TO_ADDR
// uc_nation := 2 ;
12027: LD_ADDR_OWVAR 21
12031: PUSH
12032: LD_INT 2
12034: ST_TO_ADDR
// hc_name := Dark Warrior ;
12035: LD_ADDR_OWVAR 26
12039: PUSH
12040: LD_STRING Dark Warrior
12042: ST_TO_ADDR
// hc_gallery :=  ;
12043: LD_ADDR_OWVAR 33
12047: PUSH
12048: LD_STRING 
12050: ST_TO_ADDR
// hc_noskilllimit := true ;
12051: LD_ADDR_OWVAR 76
12055: PUSH
12056: LD_INT 1
12058: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
12059: LD_ADDR_OWVAR 31
12063: PUSH
12064: LD_INT 30
12066: PUSH
12067: LD_INT 30
12069: PUSH
12070: LD_INT 30
12072: PUSH
12073: LD_INT 30
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: ST_TO_ADDR
// un := CreateHuman ;
12082: LD_ADDR_VAR 0 3
12086: PUSH
12087: CALL_OW 44
12091: ST_TO_ADDR
// hc_noskilllimit := false ;
12092: LD_ADDR_OWVAR 76
12096: PUSH
12097: LD_INT 0
12099: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
12100: LD_VAR 0 3
12104: PPUSH
12105: LD_INT 1
12107: PPUSH
12108: CALL_OW 51
// p := 0 ;
12112: LD_ADDR_VAR 0 2
12116: PUSH
12117: LD_INT 0
12119: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
12120: LD_INT 35
12122: PPUSH
12123: CALL_OW 67
// p := p + 1 ;
12127: LD_ADDR_VAR 0 2
12131: PUSH
12132: LD_VAR 0 2
12136: PUSH
12137: LD_INT 1
12139: PLUS
12140: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
12141: LD_VAR 0 3
12145: PPUSH
12146: CALL_OW 256
12150: PUSH
12151: LD_INT 1000
12153: LESS
12154: IFFALSE 12168
// SetLives ( un , 1000 ) ;
12156: LD_VAR 0 3
12160: PPUSH
12161: LD_INT 1000
12163: PPUSH
12164: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
12168: LD_VAR 0 3
12172: PPUSH
12173: LD_INT 81
12175: PUSH
12176: LD_OWVAR 2
12180: PUSH
12181: EMPTY
12182: LIST
12183: LIST
12184: PUSH
12185: LD_INT 91
12187: PUSH
12188: LD_VAR 0 3
12192: PUSH
12193: LD_INT 30
12195: PUSH
12196: EMPTY
12197: LIST
12198: LIST
12199: LIST
12200: PUSH
12201: EMPTY
12202: LIST
12203: LIST
12204: PPUSH
12205: CALL_OW 69
12209: PPUSH
12210: LD_VAR 0 3
12214: PPUSH
12215: CALL_OW 74
12219: PPUSH
12220: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
12224: LD_VAR 0 2
12228: PUSH
12229: LD_INT 60
12231: GREATER
12232: PUSH
12233: LD_VAR 0 3
12237: PPUSH
12238: CALL_OW 301
12242: OR
12243: IFFALSE 12120
// if un then
12245: LD_VAR 0 3
12249: IFFALSE 12260
// RemoveUnit ( un ) ;
12251: LD_VAR 0 3
12255: PPUSH
12256: CALL_OW 64
// end ; end_of_file
12260: PPOPN 3
12262: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
12263: LD_INT 0
12265: PPUSH
12266: PPUSH
12267: PPUSH
12268: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
12269: LD_VAR 0 1
12273: PPUSH
12274: CALL_OW 264
12278: PUSH
12279: LD_EXP 17
12283: EQUAL
12284: IFFALSE 12356
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
12286: LD_INT 68
12288: PPUSH
12289: LD_VAR 0 1
12293: PPUSH
12294: CALL_OW 255
12298: PPUSH
12299: CALL_OW 321
12303: PUSH
12304: LD_INT 2
12306: EQUAL
12307: IFFALSE 12319
// eff := 70 else
12309: LD_ADDR_VAR 0 4
12313: PUSH
12314: LD_INT 70
12316: ST_TO_ADDR
12317: GO 12327
// eff := 30 ;
12319: LD_ADDR_VAR 0 4
12323: PUSH
12324: LD_INT 30
12326: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
12327: LD_VAR 0 1
12331: PPUSH
12332: CALL_OW 250
12336: PPUSH
12337: LD_VAR 0 1
12341: PPUSH
12342: CALL_OW 251
12346: PPUSH
12347: LD_VAR 0 4
12351: PPUSH
12352: CALL_OW 495
// end ; end ;
12356: LD_VAR 0 2
12360: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
12361: LD_INT 0
12363: PPUSH
// end ;
12364: LD_VAR 0 4
12368: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
12369: LD_INT 0
12371: PPUSH
12372: PPUSH
12373: PPUSH
12374: PPUSH
12375: PPUSH
12376: PPUSH
// if cmd = 124 then
12377: LD_VAR 0 1
12381: PUSH
12382: LD_INT 124
12384: EQUAL
12385: IFFALSE 12591
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
12387: LD_ADDR_VAR 0 5
12391: PUSH
12392: LD_INT 2
12394: PUSH
12395: LD_INT 34
12397: PUSH
12398: LD_INT 53
12400: PUSH
12401: EMPTY
12402: LIST
12403: LIST
12404: PUSH
12405: LD_INT 34
12407: PUSH
12408: LD_INT 14
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: EMPTY
12416: LIST
12417: LIST
12418: LIST
12419: PPUSH
12420: CALL_OW 69
12424: ST_TO_ADDR
// if not tmp then
12425: LD_VAR 0 5
12429: NOT
12430: IFFALSE 12434
// exit ;
12432: GO 12591
// for i in tmp do
12434: LD_ADDR_VAR 0 3
12438: PUSH
12439: LD_VAR 0 5
12443: PUSH
12444: FOR_IN
12445: IFFALSE 12589
// begin taskList := GetTaskList ( i ) ;
12447: LD_ADDR_VAR 0 6
12451: PUSH
12452: LD_VAR 0 3
12456: PPUSH
12457: CALL_OW 437
12461: ST_TO_ADDR
// if not taskList then
12462: LD_VAR 0 6
12466: NOT
12467: IFFALSE 12471
// continue ;
12469: GO 12444
// for j = 1 to taskList do
12471: LD_ADDR_VAR 0 4
12475: PUSH
12476: DOUBLE
12477: LD_INT 1
12479: DEC
12480: ST_TO_ADDR
12481: LD_VAR 0 6
12485: PUSH
12486: FOR_TO
12487: IFFALSE 12585
// if taskList [ j ] [ 1 ] = | then
12489: LD_VAR 0 6
12493: PUSH
12494: LD_VAR 0 4
12498: ARRAY
12499: PUSH
12500: LD_INT 1
12502: ARRAY
12503: PUSH
12504: LD_STRING |
12506: EQUAL
12507: IFFALSE 12583
// begin _taskList := Delete ( taskList , 1 ) ;
12509: LD_ADDR_VAR 0 7
12513: PUSH
12514: LD_VAR 0 6
12518: PPUSH
12519: LD_INT 1
12521: PPUSH
12522: CALL_OW 3
12526: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
12527: LD_VAR 0 3
12531: PPUSH
12532: LD_VAR 0 7
12536: PPUSH
12537: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
12541: LD_VAR 0 3
12545: PPUSH
12546: LD_VAR 0 6
12550: PUSH
12551: LD_VAR 0 4
12555: ARRAY
12556: PUSH
12557: LD_INT 2
12559: ARRAY
12560: PPUSH
12561: LD_VAR 0 6
12565: PUSH
12566: LD_VAR 0 4
12570: ARRAY
12571: PUSH
12572: LD_INT 3
12574: ARRAY
12575: PPUSH
12576: LD_INT 8
12578: PPUSH
12579: CALL 12596 0 4
// end ;
12583: GO 12486
12585: POP
12586: POP
// end ;
12587: GO 12444
12589: POP
12590: POP
// end ; end ;
12591: LD_VAR 0 2
12595: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
12596: LD_INT 0
12598: PPUSH
12599: PPUSH
12600: PPUSH
12601: PPUSH
12602: PPUSH
12603: PPUSH
12604: PPUSH
12605: PPUSH
12606: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
12607: LD_VAR 0 1
12611: NOT
12612: PUSH
12613: LD_VAR 0 2
12617: PPUSH
12618: LD_VAR 0 3
12622: PPUSH
12623: CALL_OW 488
12627: NOT
12628: OR
12629: PUSH
12630: LD_VAR 0 4
12634: NOT
12635: OR
12636: IFFALSE 12640
// exit ;
12638: GO 12980
// list := [ ] ;
12640: LD_ADDR_VAR 0 13
12644: PUSH
12645: EMPTY
12646: ST_TO_ADDR
// if x - r < 0 then
12647: LD_VAR 0 2
12651: PUSH
12652: LD_VAR 0 4
12656: MINUS
12657: PUSH
12658: LD_INT 0
12660: LESS
12661: IFFALSE 12673
// min_x := 0 else
12663: LD_ADDR_VAR 0 7
12667: PUSH
12668: LD_INT 0
12670: ST_TO_ADDR
12671: GO 12689
// min_x := x - r ;
12673: LD_ADDR_VAR 0 7
12677: PUSH
12678: LD_VAR 0 2
12682: PUSH
12683: LD_VAR 0 4
12687: MINUS
12688: ST_TO_ADDR
// if y - r < 0 then
12689: LD_VAR 0 3
12693: PUSH
12694: LD_VAR 0 4
12698: MINUS
12699: PUSH
12700: LD_INT 0
12702: LESS
12703: IFFALSE 12715
// min_y := 0 else
12705: LD_ADDR_VAR 0 8
12709: PUSH
12710: LD_INT 0
12712: ST_TO_ADDR
12713: GO 12731
// min_y := y - r ;
12715: LD_ADDR_VAR 0 8
12719: PUSH
12720: LD_VAR 0 3
12724: PUSH
12725: LD_VAR 0 4
12729: MINUS
12730: ST_TO_ADDR
// max_x := x + r ;
12731: LD_ADDR_VAR 0 9
12735: PUSH
12736: LD_VAR 0 2
12740: PUSH
12741: LD_VAR 0 4
12745: PLUS
12746: ST_TO_ADDR
// max_y := y + r ;
12747: LD_ADDR_VAR 0 10
12751: PUSH
12752: LD_VAR 0 3
12756: PUSH
12757: LD_VAR 0 4
12761: PLUS
12762: ST_TO_ADDR
// for _x = min_x to max_x do
12763: LD_ADDR_VAR 0 11
12767: PUSH
12768: DOUBLE
12769: LD_VAR 0 7
12773: DEC
12774: ST_TO_ADDR
12775: LD_VAR 0 9
12779: PUSH
12780: FOR_TO
12781: IFFALSE 12898
// for _y = min_y to max_y do
12783: LD_ADDR_VAR 0 12
12787: PUSH
12788: DOUBLE
12789: LD_VAR 0 8
12793: DEC
12794: ST_TO_ADDR
12795: LD_VAR 0 10
12799: PUSH
12800: FOR_TO
12801: IFFALSE 12894
// begin if not ValidHex ( _x , _y ) then
12803: LD_VAR 0 11
12807: PPUSH
12808: LD_VAR 0 12
12812: PPUSH
12813: CALL_OW 488
12817: NOT
12818: IFFALSE 12822
// continue ;
12820: GO 12800
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
12822: LD_VAR 0 11
12826: PPUSH
12827: LD_VAR 0 12
12831: PPUSH
12832: CALL_OW 351
12836: PUSH
12837: LD_VAR 0 11
12841: PPUSH
12842: LD_VAR 0 12
12846: PPUSH
12847: CALL_OW 554
12851: AND
12852: IFFALSE 12892
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
12854: LD_ADDR_VAR 0 13
12858: PUSH
12859: LD_VAR 0 13
12863: PPUSH
12864: LD_VAR 0 13
12868: PUSH
12869: LD_INT 1
12871: PLUS
12872: PPUSH
12873: LD_VAR 0 11
12877: PUSH
12878: LD_VAR 0 12
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: PPUSH
12887: CALL_OW 2
12891: ST_TO_ADDR
// end ;
12892: GO 12800
12894: POP
12895: POP
12896: GO 12780
12898: POP
12899: POP
// if not list then
12900: LD_VAR 0 13
12904: NOT
12905: IFFALSE 12909
// exit ;
12907: GO 12980
// for i in list do
12909: LD_ADDR_VAR 0 6
12913: PUSH
12914: LD_VAR 0 13
12918: PUSH
12919: FOR_IN
12920: IFFALSE 12978
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
12922: LD_VAR 0 1
12926: PPUSH
12927: LD_STRING M
12929: PUSH
12930: LD_VAR 0 6
12934: PUSH
12935: LD_INT 1
12937: ARRAY
12938: PUSH
12939: LD_VAR 0 6
12943: PUSH
12944: LD_INT 2
12946: ARRAY
12947: PUSH
12948: LD_INT 0
12950: PUSH
12951: LD_INT 0
12953: PUSH
12954: LD_INT 0
12956: PUSH
12957: LD_INT 0
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: PUSH
12969: EMPTY
12970: LIST
12971: PPUSH
12972: CALL_OW 447
12976: GO 12919
12978: POP
12979: POP
// end ;
12980: LD_VAR 0 5
12984: RET
