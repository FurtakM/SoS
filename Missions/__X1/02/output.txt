// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// Init ;
  15: CALL 46 0 0
// PrepareNature ;
  19: CALL 580 0 0
// PrepareAmericans ;
  23: CALL 826 0 0
// PrepareArabian ;
  27: CALL 10523 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 41
// DebugMode ;
  37: CALL 198 0 0
// Action ;
  41: CALL 4605 0 0
// end ;
  45: END
// export debug , prefix , missionStart , aviradzeSpotted , deltaSpotted , sciSpotted , aviradzeQuestDone , sciCounterKill , usAlert , usActiveDefend , timeUntilFarmer , attackDeltaAllowed , trickyMove , usPatrol , trap , lostCounter ; function Init ; begin
  46: LD_INT 0
  48: PPUSH
// debug := false ;
  49: LD_ADDR_EXP 1
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// missionStart := false ;
  57: LD_ADDR_EXP 3
  61: PUSH
  62: LD_INT 0
  64: ST_TO_ADDR
// aviradzeSpotted := false ;
  65: LD_ADDR_EXP 4
  69: PUSH
  70: LD_INT 0
  72: ST_TO_ADDR
// deltaSpotted := false ;
  73: LD_ADDR_EXP 5
  77: PUSH
  78: LD_INT 0
  80: ST_TO_ADDR
// sciSpotted := false ;
  81: LD_ADDR_EXP 6
  85: PUSH
  86: LD_INT 0
  88: ST_TO_ADDR
// sciCounterKill := 0 ;
  89: LD_ADDR_EXP 8
  93: PUSH
  94: LD_INT 0
  96: ST_TO_ADDR
// aviradzeQuestDone := false ;
  97: LD_ADDR_EXP 7
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// attackDeltaAllowed := false ;
 105: LD_ADDR_EXP 12
 109: PUSH
 110: LD_INT 0
 112: ST_TO_ADDR
// usAlert := false ;
 113: LD_ADDR_EXP 9
 117: PUSH
 118: LD_INT 0
 120: ST_TO_ADDR
// usActiveDefend := false ;
 121: LD_ADDR_EXP 10
 125: PUSH
 126: LD_INT 0
 128: ST_TO_ADDR
// usPatrol := [ ] ;
 129: LD_ADDR_EXP 14
 133: PUSH
 134: EMPTY
 135: ST_TO_ADDR
// timeUntilFarmer := [ 40 40$00 , 30 30$00 , 20 20$00 ] [ Difficulty ] ;
 136: LD_ADDR_EXP 11
 140: PUSH
 141: LD_INT 84000
 143: PUSH
 144: LD_INT 63000
 146: PUSH
 147: LD_INT 42000
 149: PUSH
 150: EMPTY
 151: LIST
 152: LIST
 153: LIST
 154: PUSH
 155: LD_OWVAR 67
 159: ARRAY
 160: ST_TO_ADDR
// trickyMove := false ;
 161: LD_ADDR_EXP 13
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// prefix := 01_ ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 01_
 176: ST_TO_ADDR
// trap := 0 ;
 177: LD_ADDR_EXP 15
 181: PUSH
 182: LD_INT 0
 184: ST_TO_ADDR
// lostCounter := false ;
 185: LD_ADDR_EXP 16
 189: PUSH
 190: LD_INT 0
 192: ST_TO_ADDR
// end ;
 193: LD_VAR 0 1
 197: RET
// function DebugMode ; begin
 198: LD_INT 0
 200: PPUSH
// FogOff ( 1 ) ;
 201: LD_INT 1
 203: PPUSH
 204: CALL_OW 344
// Difficulty := 2 ;
 208: LD_ADDR_OWVAR 67
 212: PUSH
 213: LD_INT 2
 215: ST_TO_ADDR
// end ; end_of_file
 216: LD_VAR 0 1
 220: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 221: LD_INT 0
 223: PPUSH
 224: PPUSH
// if exist_mode then
 225: LD_VAR 0 2
 229: IFFALSE 254
// unit := CreateCharacter ( prefix & ident ) else
 231: LD_ADDR_VAR 0 5
 235: PUSH
 236: LD_VAR 0 3
 240: PUSH
 241: LD_VAR 0 1
 245: STR
 246: PPUSH
 247: CALL_OW 34
 251: ST_TO_ADDR
 252: GO 269
// unit := NewCharacter ( ident ) ;
 254: LD_ADDR_VAR 0 5
 258: PUSH
 259: LD_VAR 0 1
 263: PPUSH
 264: CALL_OW 25
 268: ST_TO_ADDR
// result := unit ;
 269: LD_ADDR_VAR 0 4
 273: PUSH
 274: LD_VAR 0 5
 278: ST_TO_ADDR
// end ;
 279: LD_VAR 0 4
 283: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 284: LD_INT 0
 286: PPUSH
// uc_side := side ;
 287: LD_ADDR_OWVAR 20
 291: PUSH
 292: LD_VAR 0 1
 296: ST_TO_ADDR
// uc_nation := nation ;
 297: LD_ADDR_OWVAR 21
 301: PUSH
 302: LD_VAR 0 2
 306: ST_TO_ADDR
// vc_chassis := chassis ;
 307: LD_ADDR_OWVAR 37
 311: PUSH
 312: LD_VAR 0 3
 316: ST_TO_ADDR
// vc_engine := engine ;
 317: LD_ADDR_OWVAR 39
 321: PUSH
 322: LD_VAR 0 4
 326: ST_TO_ADDR
// vc_control := control ;
 327: LD_ADDR_OWVAR 38
 331: PUSH
 332: LD_VAR 0 5
 336: ST_TO_ADDR
// vc_weapon := weapon ;
 337: LD_ADDR_OWVAR 40
 341: PUSH
 342: LD_VAR 0 6
 346: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 347: LD_ADDR_OWVAR 41
 351: PUSH
 352: LD_VAR 0 7
 356: ST_TO_ADDR
// result := CreateVehicle ;
 357: LD_ADDR_VAR 0 8
 361: PUSH
 362: CALL_OW 45
 366: ST_TO_ADDR
// end ;
 367: LD_VAR 0 8
 371: RET
// export function SayX ( units , ident ) ; var i ; begin
 372: LD_INT 0
 374: PPUSH
 375: PPUSH
// result := false ;
 376: LD_ADDR_VAR 0 3
 380: PUSH
 381: LD_INT 0
 383: ST_TO_ADDR
// if not units then
 384: LD_VAR 0 1
 388: NOT
 389: IFFALSE 393
// exit ;
 391: GO 447
// for i in units do
 393: LD_ADDR_VAR 0 4
 397: PUSH
 398: LD_VAR 0 1
 402: PUSH
 403: FOR_IN
 404: IFFALSE 445
// if IsOk ( i ) then
 406: LD_VAR 0 4
 410: PPUSH
 411: CALL_OW 302
 415: IFFALSE 443
// begin Say ( i , ident ) ;
 417: LD_VAR 0 4
 421: PPUSH
 422: LD_VAR 0 2
 426: PPUSH
 427: CALL_OW 88
// result := i ;
 431: LD_ADDR_VAR 0 3
 435: PUSH
 436: LD_VAR 0 4
 440: ST_TO_ADDR
// break ;
 441: GO 445
// end ;
 443: GO 403
 445: POP
 446: POP
// end ;
 447: LD_VAR 0 3
 451: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 452: LD_INT 0
 454: PPUSH
 455: PPUSH
// InitUc ;
 456: CALL_OW 18
// InitHc ;
 460: CALL_OW 19
// uc_side := 0 ;
 464: LD_ADDR_OWVAR 20
 468: PUSH
 469: LD_INT 0
 471: ST_TO_ADDR
// uc_nation := 0 ;
 472: LD_ADDR_OWVAR 21
 476: PUSH
 477: LD_INT 0
 479: ST_TO_ADDR
// for i = 1 to amount do
 480: LD_ADDR_VAR 0 4
 484: PUSH
 485: DOUBLE
 486: LD_INT 1
 488: DEC
 489: ST_TO_ADDR
 490: LD_VAR 0 2
 494: PUSH
 495: FOR_TO
 496: IFFALSE 569
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 498: LD_ADDR_OWVAR 29
 502: PUSH
 503: LD_INT 9
 505: PPUSH
 506: LD_INT 12
 508: PPUSH
 509: CALL_OW 12
 513: PUSH
 514: LD_INT 9
 516: PPUSH
 517: LD_INT 12
 519: PPUSH
 520: CALL_OW 12
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: ST_TO_ADDR
// hc_agressivity := 0 ;
 529: LD_ADDR_OWVAR 35
 533: PUSH
 534: LD_INT 0
 536: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 537: LD_INT 0
 539: PPUSH
 540: LD_INT 12
 542: PPUSH
 543: LD_INT 1
 545: PPUSH
 546: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 550: CALL_OW 44
 554: PPUSH
 555: LD_VAR 0 1
 559: PPUSH
 560: LD_INT 0
 562: PPUSH
 563: CALL_OW 49
// end ;
 567: GO 495
 569: POP
 570: POP
// InitHc ;
 571: CALL_OW 19
// end ;
 575: LD_VAR 0 3
 579: RET
// export function PrepareNature ; var i ; begin
 580: LD_INT 0
 582: PPUSH
 583: PPUSH
// SpawnApeman ( forest , 9 ) ;
 584: LD_INT 1
 586: PPUSH
 587: LD_INT 9
 589: PPUSH
 590: CALL 452 0 2
// for i := 1 to 4 do
 594: LD_ADDR_VAR 0 2
 598: PUSH
 599: DOUBLE
 600: LD_INT 1
 602: DEC
 603: ST_TO_ADDR
 604: LD_INT 4
 606: PUSH
 607: FOR_TO
 608: IFFALSE 643
// begin hc_class := 21 ;
 610: LD_ADDR_OWVAR 28
 614: PUSH
 615: LD_INT 21
 617: ST_TO_ADDR
// hc_gallery :=  ;
 618: LD_ADDR_OWVAR 33
 622: PUSH
 623: LD_STRING 
 625: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 626: CALL_OW 44
 630: PPUSH
 631: LD_INT 1
 633: PPUSH
 634: LD_INT 0
 636: PPUSH
 637: CALL_OW 49
// end ;
 641: GO 607
 643: POP
 644: POP
// for i := 1 to 2 do
 645: LD_ADDR_VAR 0 2
 649: PUSH
 650: DOUBLE
 651: LD_INT 1
 653: DEC
 654: ST_TO_ADDR
 655: LD_INT 2
 657: PUSH
 658: FOR_TO
 659: IFFALSE 694
// begin hc_class := 18 ;
 661: LD_ADDR_OWVAR 28
 665: PUSH
 666: LD_INT 18
 668: ST_TO_ADDR
// hc_gallery :=  ;
 669: LD_ADDR_OWVAR 33
 673: PUSH
 674: LD_STRING 
 676: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 677: CALL_OW 44
 681: PPUSH
 682: LD_INT 1
 684: PPUSH
 685: LD_INT 0
 687: PPUSH
 688: CALL_OW 49
// end ;
 692: GO 658
 694: POP
 695: POP
// for i := 1 to 3 do
 696: LD_ADDR_VAR 0 2
 700: PUSH
 701: DOUBLE
 702: LD_INT 1
 704: DEC
 705: ST_TO_ADDR
 706: LD_INT 3
 708: PUSH
 709: FOR_TO
 710: IFFALSE 745
// begin hc_class := 13 ;
 712: LD_ADDR_OWVAR 28
 716: PUSH
 717: LD_INT 13
 719: ST_TO_ADDR
// hc_gallery :=  ;
 720: LD_ADDR_OWVAR 33
 724: PUSH
 725: LD_STRING 
 727: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 728: CALL_OW 44
 732: PPUSH
 733: LD_INT 1
 735: PPUSH
 736: LD_INT 0
 738: PPUSH
 739: CALL_OW 49
// end ;
 743: GO 709
 745: POP
 746: POP
// end ;
 747: LD_VAR 0 1
 751: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 752: LD_INT 0
 754: PPUSH
 755: PPUSH
 756: PPUSH
// if not observer or not unit then
 757: LD_VAR 0 1
 761: NOT
 762: PUSH
 763: LD_VAR 0 2
 767: NOT
 768: OR
 769: IFFALSE 773
// exit ;
 771: GO 821
// if not See ( GetSide ( observer ) , unit ) then
 773: LD_VAR 0 1
 777: PPUSH
 778: CALL_OW 255
 782: PPUSH
 783: LD_VAR 0 2
 787: PPUSH
 788: CALL_OW 292
 792: NOT
 793: IFFALSE 797
// exit ;
 795: GO 821
// result := GetDistUnits ( observer , unit ) < 12 ;
 797: LD_ADDR_VAR 0 3
 801: PUSH
 802: LD_VAR 0 1
 806: PPUSH
 807: LD_VAR 0 2
 811: PPUSH
 812: CALL_OW 296
 816: PUSH
 817: LD_INT 12
 819: LESS
 820: ST_TO_ADDR
// end ; end_of_file
 821: LD_VAR 0 3
 825: RET
// export Gladstone , Lynch ; export usForces , usSci ; export function PrepareAmericans ; var i , un , veh , tmp , arm ; begin
 826: LD_INT 0
 828: PPUSH
 829: PPUSH
 830: PPUSH
 831: PPUSH
 832: PPUSH
 833: PPUSH
// usForces := [ ] ;
 834: LD_ADDR_EXP 19
 838: PUSH
 839: EMPTY
 840: ST_TO_ADDR
// usSci := [ ] ;
 841: LD_ADDR_EXP 20
 845: PUSH
 846: EMPTY
 847: ST_TO_ADDR
// SetBName ( Delta , Delta ) ;
 848: LD_INT 1
 850: PPUSH
 851: LD_STRING Delta
 853: PPUSH
 854: CALL_OW 500
// SetResourceType ( GetBase ( Delta ) , mat_cans , 400 ) ;
 858: LD_INT 1
 860: PPUSH
 861: CALL_OW 274
 865: PPUSH
 866: LD_INT 1
 868: PPUSH
 869: LD_INT 400
 871: PPUSH
 872: CALL_OW 277
// SetResourceType ( GetBase ( Delta ) , mat_oil , 80 ) ;
 876: LD_INT 1
 878: PPUSH
 879: CALL_OW 274
 883: PPUSH
 884: LD_INT 2
 886: PPUSH
 887: LD_INT 80
 889: PPUSH
 890: CALL_OW 277
// uc_side := 1 ;
 894: LD_ADDR_OWVAR 20
 898: PUSH
 899: LD_INT 1
 901: ST_TO_ADDR
// uc_nation := 1 ;
 902: LD_ADDR_OWVAR 21
 906: PUSH
 907: LD_INT 1
 909: ST_TO_ADDR
// InitHc ;
 910: CALL_OW 19
// hc_importance := 0 ;
 914: LD_ADDR_OWVAR 32
 918: PUSH
 919: LD_INT 0
 921: ST_TO_ADDR
// Lynch := PrepareUnit ( Lynch , false ,  ) ;
 922: LD_ADDR_EXP 18
 926: PUSH
 927: LD_STRING Lynch
 929: PPUSH
 930: LD_INT 0
 932: PPUSH
 933: LD_STRING 
 935: PPUSH
 936: CALL 221 0 3
 940: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , false ,  ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Gladstone
 948: PPUSH
 949: LD_INT 0
 951: PPUSH
 952: LD_STRING 
 954: PPUSH
 955: CALL 221 0 3
 959: ST_TO_ADDR
// PlaceHumanInUnit ( Lynch , Delta ) ;
 960: LD_EXP 18
 964: PPUSH
 965: LD_INT 1
 967: PPUSH
 968: CALL_OW 52
// PlaceHumanInUnit ( Gladstone , usLab ) ;
 972: LD_EXP 17
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: CALL_OW 52
// for i := 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
 984: LD_ADDR_VAR 0 2
 988: PUSH
 989: DOUBLE
 990: LD_INT 1
 992: DEC
 993: ST_TO_ADDR
 994: LD_INT 1
 996: PUSH
 997: LD_INT 2
 999: PUSH
1000: LD_INT 2
1002: PUSH
1003: EMPTY
1004: LIST
1005: LIST
1006: LIST
1007: PUSH
1008: LD_OWVAR 67
1012: ARRAY
1013: PUSH
1014: FOR_TO
1015: IFFALSE 1061
// begin PrepareHuman ( false , 2 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1017: LD_INT 0
1019: PPUSH
1020: LD_INT 2
1022: PPUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 2
1028: PUSH
1029: LD_INT 2
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_OWVAR 67
1041: ARRAY
1042: PPUSH
1043: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , Delta ) ;
1047: CALL_OW 44
1051: PPUSH
1052: LD_INT 1
1054: PPUSH
1055: CALL_OW 52
// end ;
1059: GO 1014
1061: POP
1062: POP
// for i := 1 to 2 + Difficulty do
1063: LD_ADDR_VAR 0 2
1067: PUSH
1068: DOUBLE
1069: LD_INT 1
1071: DEC
1072: ST_TO_ADDR
1073: LD_INT 2
1075: PUSH
1076: LD_OWVAR 67
1080: PLUS
1081: PUSH
1082: FOR_TO
1083: IFFALSE 1168
// begin PrepareHuman ( false , 4 , [ 1 , 2 , 2 ] [ Difficulty ] ) ;
1085: LD_INT 0
1087: PPUSH
1088: LD_INT 4
1090: PPUSH
1091: LD_INT 1
1093: PUSH
1094: LD_INT 2
1096: PUSH
1097: LD_INT 2
1099: PUSH
1100: EMPTY
1101: LIST
1102: LIST
1103: LIST
1104: PUSH
1105: LD_OWVAR 67
1109: ARRAY
1110: PPUSH
1111: CALL_OW 380
// un := CreateHuman ;
1115: LD_ADDR_VAR 0 3
1119: PUSH
1120: CALL_OW 44
1124: ST_TO_ADDR
// PlaceHumanInUnit ( un , usLab ) ;
1125: LD_VAR 0 3
1129: PPUSH
1130: LD_INT 3
1132: PPUSH
1133: CALL_OW 52
// usSci := Replace ( usSci , usSci + 1 , un ) ;
1137: LD_ADDR_EXP 20
1141: PUSH
1142: LD_EXP 20
1146: PPUSH
1147: LD_EXP 20
1151: PUSH
1152: LD_INT 1
1154: PLUS
1155: PPUSH
1156: LD_VAR 0 3
1160: PPUSH
1161: CALL_OW 1
1165: ST_TO_ADDR
// end ;
1166: GO 1082
1168: POP
1169: POP
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
1170: LD_ADDR_VAR 0 6
1174: PUSH
1175: LD_INT 22
1177: PUSH
1178: LD_INT 1
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: PUSH
1185: LD_INT 30
1187: PUSH
1188: LD_INT 4
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: PPUSH
1199: CALL_OW 69
1203: ST_TO_ADDR
// for i := 1 to 3 + Difficulty do
1204: LD_ADDR_VAR 0 2
1208: PUSH
1209: DOUBLE
1210: LD_INT 1
1212: DEC
1213: ST_TO_ADDR
1214: LD_INT 3
1216: PUSH
1217: LD_OWVAR 67
1221: PLUS
1222: PUSH
1223: FOR_TO
1224: IFFALSE 1302
// begin PrepareHuman ( false , 1 , [ 1 , 2 , 3 ] [ Difficulty ] ) ;
1226: LD_INT 0
1228: PPUSH
1229: LD_INT 1
1231: PPUSH
1232: LD_INT 1
1234: PUSH
1235: LD_INT 2
1237: PUSH
1238: LD_INT 3
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: LIST
1245: PUSH
1246: LD_OWVAR 67
1250: ARRAY
1251: PPUSH
1252: CALL_OW 380
// un := CreateHuman ;
1256: LD_ADDR_VAR 0 3
1260: PUSH
1261: CALL_OW 44
1265: ST_TO_ADDR
// usForces := usForces ^ un ;
1266: LD_ADDR_EXP 19
1270: PUSH
1271: LD_EXP 19
1275: PUSH
1276: LD_VAR 0 3
1280: ADD
1281: ST_TO_ADDR
// PlaceHumanInUnit ( un , arm [ 1 ] ) ;
1282: LD_VAR 0 3
1286: PPUSH
1287: LD_VAR 0 6
1291: PUSH
1292: LD_INT 1
1294: ARRAY
1295: PPUSH
1296: CALL_OW 52
// end ;
1300: GO 1223
1302: POP
1303: POP
// PrepareTank ( 1 , 1 , us_light_wheeled , engine_solar , control_manual , us_machine_gun , 100 ) ;
1304: LD_INT 1
1306: PPUSH
1307: LD_INT 1
1309: PPUSH
1310: LD_INT 1
1312: PPUSH
1313: LD_INT 2
1315: PPUSH
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 2
1321: PPUSH
1322: LD_INT 100
1324: PPUSH
1325: CALL 284 0 7
// veh := CreateVehicle ;
1329: LD_ADDR_VAR 0 4
1333: PUSH
1334: CALL_OW 45
1338: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1339: LD_VAR 0 4
1343: PPUSH
1344: LD_INT 2
1346: PPUSH
1347: CALL_OW 233
// PlaceUnitXY ( veh , 43 , 24 , false ) ;
1351: LD_VAR 0 4
1355: PPUSH
1356: LD_INT 43
1358: PPUSH
1359: LD_INT 24
1361: PPUSH
1362: LD_INT 0
1364: PPUSH
1365: CALL_OW 48
// end ;
1369: LD_VAR 0 1
1373: RET
// export function SendSciToForest ; var i , j , k , tmp , xy ; begin
1374: LD_INT 0
1376: PPUSH
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// if not usSci then
1382: LD_EXP 20
1386: NOT
1387: IFFALSE 1391
// exit ;
1389: GO 1565
// xy := AreaToList ( tameArea , 0 ) ;
1391: LD_ADDR_VAR 0 6
1395: PUSH
1396: LD_INT 5
1398: PPUSH
1399: LD_INT 0
1401: PPUSH
1402: CALL_OW 517
1406: ST_TO_ADDR
// for i in usSci do
1407: LD_ADDR_VAR 0 2
1411: PUSH
1412: LD_EXP 20
1416: PUSH
1417: FOR_IN
1418: IFFALSE 1563
// begin k := rand ( 1 , xy [ 1 ] ) ;
1420: LD_ADDR_VAR 0 4
1424: PUSH
1425: LD_INT 1
1427: PPUSH
1428: LD_VAR 0 6
1432: PUSH
1433: LD_INT 1
1435: ARRAY
1436: PPUSH
1437: CALL_OW 12
1441: ST_TO_ADDR
// ComExitBuilding ( i ) ;
1442: LD_VAR 0 2
1446: PPUSH
1447: CALL_OW 122
// AddComMoveXY ( i , xy [ 1 ] [ k ] , xy [ 2 ] [ k ] ) ;
1451: LD_VAR 0 2
1455: PPUSH
1456: LD_VAR 0 6
1460: PUSH
1461: LD_INT 1
1463: ARRAY
1464: PUSH
1465: LD_VAR 0 4
1469: ARRAY
1470: PPUSH
1471: LD_VAR 0 6
1475: PUSH
1476: LD_INT 2
1478: ARRAY
1479: PUSH
1480: LD_VAR 0 4
1484: ARRAY
1485: PPUSH
1486: CALL_OW 171
// for j := 1 to 2 do
1490: LD_ADDR_VAR 0 3
1494: PUSH
1495: DOUBLE
1496: LD_INT 1
1498: DEC
1499: ST_TO_ADDR
1500: LD_INT 2
1502: PUSH
1503: FOR_TO
1504: IFFALSE 1559
// begin tmp := Delete ( xy [ j ] , k ) ;
1506: LD_ADDR_VAR 0 5
1510: PUSH
1511: LD_VAR 0 6
1515: PUSH
1516: LD_VAR 0 3
1520: ARRAY
1521: PPUSH
1522: LD_VAR 0 4
1526: PPUSH
1527: CALL_OW 3
1531: ST_TO_ADDR
// xy := Replace ( xy , j , tmp ) ;
1532: LD_ADDR_VAR 0 6
1536: PUSH
1537: LD_VAR 0 6
1541: PPUSH
1542: LD_VAR 0 3
1546: PPUSH
1547: LD_VAR 0 5
1551: PPUSH
1552: CALL_OW 1
1556: ST_TO_ADDR
// end ;
1557: GO 1503
1559: POP
1560: POP
// end ;
1561: GO 1417
1563: POP
1564: POP
// end ;
1565: LD_VAR 0 1
1569: RET
// every 0 0$5 + 0 0$10 trigger aviradzeSpotted and usSci and not usAlert and FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) do var i , x , y , d , ape ;
1570: LD_EXP 4
1574: PUSH
1575: LD_EXP 20
1579: AND
1580: PUSH
1581: LD_EXP 9
1585: NOT
1586: AND
1587: PUSH
1588: LD_INT 22
1590: PUSH
1591: LD_INT 0
1593: PUSH
1594: EMPTY
1595: LIST
1596: LIST
1597: PUSH
1598: LD_INT 25
1600: PUSH
1601: LD_INT 12
1603: PUSH
1604: EMPTY
1605: LIST
1606: LIST
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PPUSH
1612: CALL_OW 69
1616: AND
1617: IFFALSE 2109
1619: GO 1621
1621: DISABLE
1622: LD_INT 0
1624: PPUSH
1625: PPUSH
1626: PPUSH
1627: PPUSH
1628: PPUSH
// begin enable ;
1629: ENABLE
// if UnitFilter ( usSci , [ f_or , [ f_hastask ] , [ f_inside ] ] ) then
1630: LD_EXP 20
1634: PPUSH
1635: LD_INT 2
1637: PUSH
1638: LD_INT 60
1640: PUSH
1641: EMPTY
1642: LIST
1643: PUSH
1644: LD_INT 54
1646: PUSH
1647: EMPTY
1648: LIST
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PPUSH
1655: CALL_OW 72
1659: IFFALSE 1663
// exit ;
1661: GO 2109
// for i in usSci do
1663: LD_ADDR_VAR 0 1
1667: PUSH
1668: LD_EXP 20
1672: PUSH
1673: FOR_IN
1674: IFFALSE 2107
// begin if not HasTask ( i ) and GetLives ( i ) = 1000 then
1676: LD_VAR 0 1
1680: PPUSH
1681: CALL_OW 314
1685: NOT
1686: PUSH
1687: LD_VAR 0 1
1691: PPUSH
1692: CALL_OW 256
1696: PUSH
1697: LD_INT 1000
1699: EQUAL
1700: AND
1701: IFFALSE 1908
// begin ape := NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) , i ) ;
1703: LD_ADDR_VAR 0 5
1707: PUSH
1708: LD_INT 22
1710: PUSH
1711: LD_INT 0
1713: PUSH
1714: EMPTY
1715: LIST
1716: LIST
1717: PUSH
1718: LD_INT 25
1720: PUSH
1721: LD_INT 12
1723: PUSH
1724: EMPTY
1725: LIST
1726: LIST
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: PPUSH
1732: CALL_OW 69
1736: PPUSH
1737: LD_VAR 0 1
1741: PPUSH
1742: CALL_OW 74
1746: ST_TO_ADDR
// if GetDistUnits ( i , ape ) < 10 then
1747: LD_VAR 0 1
1751: PPUSH
1752: LD_VAR 0 5
1756: PPUSH
1757: CALL_OW 296
1761: PUSH
1762: LD_INT 10
1764: LESS
1765: IFFALSE 1798
// ComTameXY ( i , GetX ( ape ) , GetY ( ape ) ) else
1767: LD_VAR 0 1
1771: PPUSH
1772: LD_VAR 0 5
1776: PPUSH
1777: CALL_OW 250
1781: PPUSH
1782: LD_VAR 0 5
1786: PPUSH
1787: CALL_OW 251
1791: PPUSH
1792: CALL_OW 131
1796: GO 1908
// begin d := rand ( 0 , 5 ) ;
1798: LD_ADDR_VAR 0 4
1802: PUSH
1803: LD_INT 0
1805: PPUSH
1806: LD_INT 5
1808: PPUSH
1809: CALL_OW 12
1813: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , 3 ) ;
1814: LD_ADDR_VAR 0 2
1818: PUSH
1819: LD_VAR 0 1
1823: PPUSH
1824: CALL_OW 250
1828: PPUSH
1829: LD_VAR 0 4
1833: PPUSH
1834: LD_INT 3
1836: PPUSH
1837: CALL_OW 272
1841: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , 3 ) ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: LD_VAR 0 1
1851: PPUSH
1852: CALL_OW 251
1856: PPUSH
1857: LD_VAR 0 4
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: CALL_OW 273
1869: ST_TO_ADDR
// if not ValidHex ( x , y ) then
1870: LD_VAR 0 2
1874: PPUSH
1875: LD_VAR 0 3
1879: PPUSH
1880: CALL_OW 488
1884: NOT
1885: IFFALSE 1889
// continue ;
1887: GO 1673
// ComMoveXY ( i , x , y ) ;
1889: LD_VAR 0 1
1893: PPUSH
1894: LD_VAR 0 2
1898: PPUSH
1899: LD_VAR 0 3
1903: PPUSH
1904: CALL_OW 111
// end ; end ; if GetLives ( i ) < 900 and GetDistUnitXY ( i , 37 , 23 ) > 10 then
1908: LD_VAR 0 1
1912: PPUSH
1913: CALL_OW 256
1917: PUSH
1918: LD_INT 900
1920: LESS
1921: PUSH
1922: LD_VAR 0 1
1926: PPUSH
1927: LD_INT 37
1929: PPUSH
1930: LD_INT 23
1932: PPUSH
1933: CALL_OW 297
1937: PUSH
1938: LD_INT 10
1940: GREATER
1941: AND
1942: IFFALSE 2018
// begin if IsOk ( Gladstone ) and IsInUnit ( Gladstone ) then
1944: LD_EXP 17
1948: PPUSH
1949: CALL_OW 302
1953: PUSH
1954: LD_EXP 17
1958: PPUSH
1959: CALL_OW 310
1963: AND
1964: IFFALSE 1975
// ComExitBuilding ( Gladstone ) ;
1966: LD_EXP 17
1970: PPUSH
1971: CALL_OW 122
// AddComHeal ( Gladstone , i ) ;
1975: LD_EXP 17
1979: PPUSH
1980: LD_VAR 0 1
1984: PPUSH
1985: CALL_OW 188
// AddComEnterUnit ( Gladstone , usLab ) ;
1989: LD_EXP 17
1993: PPUSH
1994: LD_INT 3
1996: PPUSH
1997: CALL_OW 180
// ComMoveXY ( i , 37 , 23 ) ;
2001: LD_VAR 0 1
2005: PPUSH
2006: LD_INT 37
2008: PPUSH
2009: LD_INT 23
2011: PPUSH
2012: CALL_OW 111
// end else
2016: GO 2105
// if GetLives ( i ) = 1000 then
2018: LD_VAR 0 1
2022: PPUSH
2023: CALL_OW 256
2027: PUSH
2028: LD_INT 1000
2030: EQUAL
2031: IFFALSE 2105
// begin if SideShoot ( i ) = 2 then
2033: LD_VAR 0 1
2037: PPUSH
2038: CALL_OW 503
2042: PUSH
2043: LD_INT 2
2045: EQUAL
2046: IFFALSE 2093
// begin if not usAlert then
2048: LD_EXP 9
2052: NOT
2053: IFFALSE 2063
// usAlert := true ;
2055: LD_ADDR_EXP 9
2059: PUSH
2060: LD_INT 1
2062: ST_TO_ADDR
// AddComEnterUnit ( i , usLab ) ;
2063: LD_VAR 0 1
2067: PPUSH
2068: LD_INT 3
2070: PPUSH
2071: CALL_OW 180
// usSci := usSci diff i ;
2075: LD_ADDR_EXP 20
2079: PUSH
2080: LD_EXP 20
2084: PUSH
2085: LD_VAR 0 1
2089: DIFF
2090: ST_TO_ADDR
// end else
2091: GO 2105
// ComMoveToArea ( i , tameArea ) ;
2093: LD_VAR 0 1
2097: PPUSH
2098: LD_INT 5
2100: PPUSH
2101: CALL_OW 113
// end ; end ;
2105: GO 1673
2107: POP
2108: POP
// end ;
2109: PPOPN 5
2111: END
// every 0 0$1 trigger not usAlert and ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] , [ f_not , [ f_constructed ] ] , [ f_not , [ f_lives , 999 ] ] ] ) or FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) ) do
2112: LD_EXP 9
2116: NOT
2117: PUSH
2118: LD_INT 22
2120: PUSH
2121: LD_INT 1
2123: PUSH
2124: EMPTY
2125: LIST
2126: LIST
2127: PUSH
2128: LD_INT 21
2130: PUSH
2131: LD_INT 3
2133: PUSH
2134: EMPTY
2135: LIST
2136: LIST
2137: PUSH
2138: LD_INT 3
2140: PUSH
2141: LD_INT 57
2143: PUSH
2144: EMPTY
2145: LIST
2146: PUSH
2147: EMPTY
2148: LIST
2149: LIST
2150: PUSH
2151: LD_INT 3
2153: PUSH
2154: LD_INT 24
2156: PUSH
2157: LD_INT 999
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: PUSH
2164: EMPTY
2165: LIST
2166: LIST
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: LIST
2172: LIST
2173: PPUSH
2174: CALL_OW 69
2178: PUSH
2179: LD_INT 7
2181: PPUSH
2182: LD_INT 22
2184: PUSH
2185: LD_INT 2
2187: PUSH
2188: EMPTY
2189: LIST
2190: LIST
2191: PPUSH
2192: CALL_OW 70
2196: OR
2197: AND
2198: IFFALSE 2211
2200: GO 2202
2202: DISABLE
// usAlert := true ;
2203: LD_ADDR_EXP 9
2207: PUSH
2208: LD_INT 1
2210: ST_TO_ADDR
2211: END
// every 0 0$1 trigger usAlert do var i , b , arm ;
2212: LD_EXP 9
2216: IFFALSE 2563
2218: GO 2220
2220: DISABLE
2221: LD_INT 0
2223: PPUSH
2224: PPUSH
2225: PPUSH
// begin usActiveDefend := true ;
2226: LD_ADDR_EXP 10
2230: PUSH
2231: LD_INT 1
2233: ST_TO_ADDR
// if not usForces then
2234: LD_EXP 19
2238: NOT
2239: IFFALSE 2243
// exit ;
2241: GO 2563
// arm := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) ;
2243: LD_ADDR_VAR 0 3
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: LD_INT 1
2253: PUSH
2254: EMPTY
2255: LIST
2256: LIST
2257: PUSH
2258: LD_INT 30
2260: PUSH
2261: LD_INT 4
2263: PUSH
2264: EMPTY
2265: LIST
2266: LIST
2267: PUSH
2268: EMPTY
2269: LIST
2270: LIST
2271: PPUSH
2272: CALL_OW 69
2276: ST_TO_ADDR
// b := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) ;
2277: LD_ADDR_VAR 0 2
2281: PUSH
2282: LD_INT 22
2284: PUSH
2285: LD_INT 1
2287: PUSH
2288: EMPTY
2289: LIST
2290: LIST
2291: PUSH
2292: LD_INT 30
2294: PUSH
2295: LD_INT 31
2297: PUSH
2298: EMPTY
2299: LIST
2300: LIST
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: PPUSH
2306: CALL_OW 69
2310: ST_TO_ADDR
// ComExitBuilding ( Lynch ) ;
2311: LD_EXP 18
2315: PPUSH
2316: CALL_OW 122
// AddComEnterUnit ( Lynch , arm [ 1 ] ) ;
2320: LD_EXP 18
2324: PPUSH
2325: LD_VAR 0 3
2329: PUSH
2330: LD_INT 1
2332: ARRAY
2333: PPUSH
2334: CALL_OW 180
// if IsOk ( Gladstone ) then
2338: LD_EXP 17
2342: PPUSH
2343: CALL_OW 302
2347: IFFALSE 2388
// begin ComExitBuilding ( Gladstone ) ;
2349: LD_EXP 17
2353: PPUSH
2354: CALL_OW 122
// AddComEnterUnit ( Gladstone , arm [ 1 ] ) ;
2358: LD_EXP 17
2362: PPUSH
2363: LD_VAR 0 3
2367: PUSH
2368: LD_INT 1
2370: ARRAY
2371: PPUSH
2372: CALL_OW 180
// AddComChangeProfession ( Gladstone , class_soldier ) ;
2376: LD_EXP 17
2380: PPUSH
2381: LD_INT 1
2383: PPUSH
2384: CALL_OW 183
// end ; ComExitBuilding ( usForces [ 1 ] ) ;
2388: LD_EXP 19
2392: PUSH
2393: LD_INT 1
2395: ARRAY
2396: PPUSH
2397: CALL_OW 122
// AddComEnterUnit ( usForces [ 1 ] , b [ 1 ] ) ;
2401: LD_EXP 19
2405: PUSH
2406: LD_INT 1
2408: ARRAY
2409: PPUSH
2410: LD_VAR 0 2
2414: PUSH
2415: LD_INT 1
2417: ARRAY
2418: PPUSH
2419: CALL_OW 180
// ComExitBuilding ( usForces [ 2 ] ) ;
2423: LD_EXP 19
2427: PUSH
2428: LD_INT 2
2430: ARRAY
2431: PPUSH
2432: CALL_OW 122
// AddComEnterUnit ( usForces [ 2 ] , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) [ 1 ] ) ;
2436: LD_EXP 19
2440: PUSH
2441: LD_INT 2
2443: ARRAY
2444: PPUSH
2445: LD_INT 22
2447: PUSH
2448: LD_INT 1
2450: PUSH
2451: EMPTY
2452: LIST
2453: LIST
2454: PUSH
2455: LD_INT 30
2457: PUSH
2458: LD_INT 32
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: PUSH
2465: EMPTY
2466: LIST
2467: LIST
2468: PPUSH
2469: CALL_OW 69
2473: PUSH
2474: LD_INT 1
2476: ARRAY
2477: PPUSH
2478: CALL_OW 180
// if b > 1 and usForces > 2 then
2482: LD_VAR 0 2
2486: PUSH
2487: LD_INT 1
2489: GREATER
2490: PUSH
2491: LD_EXP 19
2495: PUSH
2496: LD_INT 2
2498: GREATER
2499: AND
2500: IFFALSE 2563
// begin repeat wait ( 0 0$1 ) ;
2502: LD_INT 35
2504: PPUSH
2505: CALL_OW 67
// until BuildingStatus ( b [ 2 ] ) <> bs_build ;
2509: LD_VAR 0 2
2513: PUSH
2514: LD_INT 2
2516: ARRAY
2517: PPUSH
2518: CALL_OW 461
2522: PUSH
2523: LD_INT 1
2525: NONEQUAL
2526: IFFALSE 2502
// ComExitBuilding ( usForces [ 3 ] ) ;
2528: LD_EXP 19
2532: PUSH
2533: LD_INT 3
2535: ARRAY
2536: PPUSH
2537: CALL_OW 122
// AddComEnterUnit ( usForces [ 3 ] , b [ 2 ] ) ;
2541: LD_EXP 19
2545: PUSH
2546: LD_INT 3
2548: ARRAY
2549: PPUSH
2550: LD_VAR 0 2
2554: PUSH
2555: LD_INT 2
2557: ARRAY
2558: PPUSH
2559: CALL_OW 180
// end ; end ;
2563: PPOPN 3
2565: END
// every 0 0$1 trigger GetLives ( usLab ) < 999 and usAlert and usForces do var i ;
2566: LD_INT 3
2568: PPUSH
2569: CALL_OW 256
2573: PUSH
2574: LD_INT 999
2576: LESS
2577: PUSH
2578: LD_EXP 9
2582: AND
2583: PUSH
2584: LD_EXP 19
2588: AND
2589: IFFALSE 2760
2591: GO 2593
2593: DISABLE
2594: LD_INT 0
2596: PPUSH
// begin for i in usForces do
2597: LD_ADDR_VAR 0 1
2601: PUSH
2602: LD_EXP 19
2606: PUSH
2607: FOR_IN
2608: IFFALSE 2647
// begin if IsInUnit ( i ) then
2610: LD_VAR 0 1
2614: PPUSH
2615: CALL_OW 310
2619: IFFALSE 2630
// ComExitBuilding ( i ) ;
2621: LD_VAR 0 1
2625: PPUSH
2626: CALL_OW 122
// AddComAgressiveMove ( i , 31 , 8 ) ;
2630: LD_VAR 0 1
2634: PPUSH
2635: LD_INT 31
2637: PPUSH
2638: LD_INT 8
2640: PPUSH
2641: CALL_OW 174
// end ;
2645: GO 2607
2647: POP
2648: POP
// wait ( 0 0$8 ) ;
2649: LD_INT 280
2651: PPUSH
2652: CALL_OW 67
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) then
2656: LD_INT 22
2658: PUSH
2659: LD_INT 2
2661: PUSH
2662: EMPTY
2663: LIST
2664: LIST
2665: PUSH
2666: LD_INT 91
2668: PUSH
2669: LD_INT 3
2671: PUSH
2672: LD_INT 14
2674: PUSH
2675: EMPTY
2676: LIST
2677: LIST
2678: LIST
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: PPUSH
2684: CALL_OW 69
2688: IFFALSE 2738
// ComAttackUnit ( usForces , FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , usLab , 14 ] ] ) [ 1 ] ) else
2690: LD_EXP 19
2694: PPUSH
2695: LD_INT 22
2697: PUSH
2698: LD_INT 2
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: PUSH
2705: LD_INT 91
2707: PUSH
2708: LD_INT 3
2710: PUSH
2711: LD_INT 14
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: LIST
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: PPUSH
2723: CALL_OW 69
2727: PUSH
2728: LD_INT 1
2730: ARRAY
2731: PPUSH
2732: CALL_OW 115
2736: GO 2760
// begin wait ( 0 0$20 ) ;
2738: LD_INT 700
2740: PPUSH
2741: CALL_OW 67
// AddComMoveXY ( usForces , 39 , 19 ) ;
2745: LD_EXP 19
2749: PPUSH
2750: LD_INT 39
2752: PPUSH
2753: LD_INT 19
2755: PPUSH
2756: CALL_OW 171
// end ; end ;
2760: PPOPN 1
2762: END
// every 0 0$3 trigger ( GetDistUnits ( Heike , Delta ) < 10 or GetLives ( usLab ) < 999 ) and FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) do var tmp , veh ;
2763: LD_EXP 21
2767: PPUSH
2768: LD_INT 1
2770: PPUSH
2771: CALL_OW 296
2775: PUSH
2776: LD_INT 10
2778: LESS
2779: PUSH
2780: LD_INT 3
2782: PPUSH
2783: CALL_OW 256
2787: PUSH
2788: LD_INT 999
2790: LESS
2791: OR
2792: PUSH
2793: LD_INT 22
2795: PUSH
2796: LD_INT 1
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: LD_INT 25
2805: PUSH
2806: LD_INT 2
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: PUSH
2813: EMPTY
2814: LIST
2815: LIST
2816: PPUSH
2817: CALL_OW 69
2821: AND
2822: IFFALSE 3006
2824: GO 2826
2826: DISABLE
2827: LD_INT 0
2829: PPUSH
2830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
2831: LD_ADDR_VAR 0 1
2835: PUSH
2836: LD_INT 22
2838: PUSH
2839: LD_INT 1
2841: PUSH
2842: EMPTY
2843: LIST
2844: LIST
2845: PUSH
2846: LD_INT 25
2848: PUSH
2849: LD_INT 2
2851: PUSH
2852: EMPTY
2853: LIST
2854: LIST
2855: PUSH
2856: EMPTY
2857: LIST
2858: LIST
2859: PPUSH
2860: CALL_OW 69
2864: ST_TO_ADDR
// veh := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
2865: LD_ADDR_VAR 0 2
2869: PUSH
2870: LD_INT 22
2872: PUSH
2873: LD_INT 1
2875: PUSH
2876: EMPTY
2877: LIST
2878: LIST
2879: PUSH
2880: LD_INT 21
2882: PUSH
2883: LD_INT 2
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: PUSH
2890: LD_INT 58
2892: PUSH
2893: EMPTY
2894: LIST
2895: PUSH
2896: EMPTY
2897: LIST
2898: LIST
2899: LIST
2900: PPUSH
2901: CALL_OW 69
2905: ST_TO_ADDR
// if not tmp then
2906: LD_VAR 0 1
2910: NOT
2911: IFFALSE 2915
// exit ;
2913: GO 3006
// ComExitBuilding ( tmp ) ;
2915: LD_VAR 0 1
2919: PPUSH
2920: CALL_OW 122
// AddComDismantle ( tmp , usLab ) ;
2924: LD_VAR 0 1
2928: PPUSH
2929: LD_INT 3
2931: PPUSH
2932: CALL_OW 227
// if veh and IsOk ( Gladstone ) then
2936: LD_VAR 0 2
2940: PUSH
2941: LD_EXP 17
2945: PPUSH
2946: CALL_OW 302
2950: AND
2951: IFFALSE 3006
// begin if IsInUnit ( Gladstone ) then
2953: LD_EXP 17
2957: PPUSH
2958: CALL_OW 310
2962: IFFALSE 2973
// ComExitBuilding ( Gladstone ) ;
2964: LD_EXP 17
2968: PPUSH
2969: CALL_OW 122
// AddComEnterUnit ( Gladstone , veh [ 1 ] ) ;
2973: LD_EXP 17
2977: PPUSH
2978: LD_VAR 0 2
2982: PUSH
2983: LD_INT 1
2985: ARRAY
2986: PPUSH
2987: CALL_OW 180
// AddComAgressiveMove ( Gladstone , 39 , 14 ) ;
2991: LD_EXP 17
2995: PPUSH
2996: LD_INT 39
2998: PPUSH
2999: LD_INT 14
3001: PPUSH
3002: CALL_OW 174
// end ; end ;
3006: PPOPN 2
3008: END
// every 0 0$1 trigger usAlert and FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) do var i , tmp ;
3009: LD_EXP 9
3013: PUSH
3014: LD_INT 7
3016: PPUSH
3017: LD_INT 22
3019: PUSH
3020: LD_INT 1
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 21
3029: PUSH
3030: LD_INT 1
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 3
3039: PUSH
3040: LD_INT 24
3042: PUSH
3043: LD_INT 600
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: PPUSH
3059: CALL_OW 70
3063: AND
3064: IFFALSE 3192
3066: GO 3068
3068: DISABLE
3069: LD_INT 0
3071: PPUSH
3072: PPUSH
// begin enable ;
3073: ENABLE
// tmp := FilterUnitsInArea ( deltaBaseArea , [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 600 ] ] ] ) ;
3074: LD_ADDR_VAR 0 2
3078: PUSH
3079: LD_INT 7
3081: PPUSH
3082: LD_INT 22
3084: PUSH
3085: LD_INT 1
3087: PUSH
3088: EMPTY
3089: LIST
3090: LIST
3091: PUSH
3092: LD_INT 21
3094: PUSH
3095: LD_INT 1
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: PUSH
3102: LD_INT 3
3104: PUSH
3105: LD_INT 24
3107: PUSH
3108: LD_INT 600
3110: PUSH
3111: EMPTY
3112: LIST
3113: LIST
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: LIST
3123: PPUSH
3124: CALL_OW 70
3128: ST_TO_ADDR
// if not tmp then
3129: LD_VAR 0 2
3133: NOT
3134: IFFALSE 3138
// exit ;
3136: GO 3192
// for i in tmp do
3138: LD_ADDR_VAR 0 1
3142: PUSH
3143: LD_VAR 0 2
3147: PUSH
3148: FOR_IN
3149: IFFALSE 3190
// if IsInUnit ( i ) then
3151: LD_VAR 0 1
3155: PPUSH
3156: CALL_OW 310
3160: IFFALSE 3173
// ComExitBuilding ( i ) else
3162: LD_VAR 0 1
3166: PPUSH
3167: CALL_OW 122
3171: GO 3188
// ComMoveXY ( i , 48 , 74 ) ;
3173: LD_VAR 0 1
3177: PPUSH
3178: LD_INT 48
3180: PPUSH
3181: LD_INT 74
3183: PPUSH
3184: CALL_OW 111
3188: GO 3148
3190: POP
3191: POP
// end ;
3192: PPOPN 2
3194: END
// every 5 5$00 do var i , un , tmp ;
3195: GO 3197
3197: DISABLE
3198: LD_INT 0
3200: PPUSH
3201: PPUSH
3202: PPUSH
// begin tmp := [ ] ;
3203: LD_ADDR_VAR 0 3
3207: PUSH
3208: EMPTY
3209: ST_TO_ADDR
// uc_side := 1 ;
3210: LD_ADDR_OWVAR 20
3214: PUSH
3215: LD_INT 1
3217: ST_TO_ADDR
// uc_nation := 1 ;
3218: LD_ADDR_OWVAR 21
3222: PUSH
3223: LD_INT 1
3225: ST_TO_ADDR
// case Difficulty of 1 :
3226: LD_OWVAR 67
3230: PUSH
3231: LD_INT 1
3233: DOUBLE
3234: EQUAL
3235: IFTRUE 3239
3237: GO 3342
3239: POP
// begin wait ( 1 1$00 ) ;
3240: LD_INT 2100
3242: PPUSH
3243: CALL_OW 67
// for i := 1 to 2 do
3247: LD_ADDR_VAR 0 1
3251: PUSH
3252: DOUBLE
3253: LD_INT 1
3255: DEC
3256: ST_TO_ADDR
3257: LD_INT 2
3259: PUSH
3260: FOR_TO
3261: IFFALSE 3338
// begin PrepareHuman ( false , [ 1 , 4 ] [ i mod 2 + 1 ] , 1 ) ;
3263: LD_INT 0
3265: PPUSH
3266: LD_INT 1
3268: PUSH
3269: LD_INT 4
3271: PUSH
3272: EMPTY
3273: LIST
3274: LIST
3275: PUSH
3276: LD_VAR 0 1
3280: PUSH
3281: LD_INT 2
3283: MOD
3284: PUSH
3285: LD_INT 1
3287: PLUS
3288: ARRAY
3289: PPUSH
3290: LD_INT 1
3292: PPUSH
3293: CALL_OW 380
// un := CreateHuman ;
3297: LD_ADDR_VAR 0 2
3301: PUSH
3302: CALL_OW 44
3306: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3307: LD_ADDR_VAR 0 3
3311: PUSH
3312: LD_VAR 0 3
3316: PPUSH
3317: LD_VAR 0 3
3321: PUSH
3322: LD_INT 1
3324: PLUS
3325: PPUSH
3326: LD_VAR 0 2
3330: PPUSH
3331: CALL_OW 1
3335: ST_TO_ADDR
// end ;
3336: GO 3260
3338: POP
3339: POP
// end ; 2 :
3340: GO 3736
3342: LD_INT 2
3344: DOUBLE
3345: EQUAL
3346: IFTRUE 3350
3348: GO 3484
3350: POP
// begin wait ( 0 0$30 ) ;
3351: LD_INT 1050
3353: PPUSH
3354: CALL_OW 67
// for i := 1 to 2 do
3358: LD_ADDR_VAR 0 1
3362: PUSH
3363: DOUBLE
3364: LD_INT 1
3366: DEC
3367: ST_TO_ADDR
3368: LD_INT 2
3370: PUSH
3371: FOR_TO
3372: IFFALSE 3428
// begin PrepareHuman ( false , 1 , 2 ) ;
3374: LD_INT 0
3376: PPUSH
3377: LD_INT 1
3379: PPUSH
3380: LD_INT 2
3382: PPUSH
3383: CALL_OW 380
// un := CreateHuman ;
3387: LD_ADDR_VAR 0 2
3391: PUSH
3392: CALL_OW 44
3396: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3397: LD_ADDR_VAR 0 3
3401: PUSH
3402: LD_VAR 0 3
3406: PPUSH
3407: LD_VAR 0 3
3411: PUSH
3412: LD_INT 1
3414: PLUS
3415: PPUSH
3416: LD_VAR 0 2
3420: PPUSH
3421: CALL_OW 1
3425: ST_TO_ADDR
// end ;
3426: GO 3371
3428: POP
3429: POP
// PrepareHuman ( false , 4 , 2 ) ;
3430: LD_INT 0
3432: PPUSH
3433: LD_INT 4
3435: PPUSH
3436: LD_INT 2
3438: PPUSH
3439: CALL_OW 380
// un := CreateHuman ;
3443: LD_ADDR_VAR 0 2
3447: PUSH
3448: CALL_OW 44
3452: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3453: LD_ADDR_VAR 0 3
3457: PUSH
3458: LD_VAR 0 3
3462: PPUSH
3463: LD_VAR 0 3
3467: PUSH
3468: LD_INT 1
3470: PLUS
3471: PPUSH
3472: LD_VAR 0 2
3476: PPUSH
3477: CALL_OW 1
3481: ST_TO_ADDR
// end ; 3 :
3482: GO 3736
3484: LD_INT 3
3486: DOUBLE
3487: EQUAL
3488: IFTRUE 3492
3490: GO 3735
3492: POP
// begin for i := 1 to 2 do
3493: LD_ADDR_VAR 0 1
3497: PUSH
3498: DOUBLE
3499: LD_INT 1
3501: DEC
3502: ST_TO_ADDR
3503: LD_INT 2
3505: PUSH
3506: FOR_TO
3507: IFFALSE 3563
// begin PrepareHuman ( false , 1 , 2 ) ;
3509: LD_INT 0
3511: PPUSH
3512: LD_INT 1
3514: PPUSH
3515: LD_INT 2
3517: PPUSH
3518: CALL_OW 380
// un := CreateHuman ;
3522: LD_ADDR_VAR 0 2
3526: PUSH
3527: CALL_OW 44
3531: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3532: LD_ADDR_VAR 0 3
3536: PUSH
3537: LD_VAR 0 3
3541: PPUSH
3542: LD_VAR 0 3
3546: PUSH
3547: LD_INT 1
3549: PLUS
3550: PPUSH
3551: LD_VAR 0 2
3555: PPUSH
3556: CALL_OW 1
3560: ST_TO_ADDR
// end ;
3561: GO 3506
3563: POP
3564: POP
// PrepareHuman ( false , 4 , 2 ) ;
3565: LD_INT 0
3567: PPUSH
3568: LD_INT 4
3570: PPUSH
3571: LD_INT 2
3573: PPUSH
3574: CALL_OW 380
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 2
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3588: LD_ADDR_VAR 0 3
3592: PUSH
3593: LD_VAR 0 3
3597: PPUSH
3598: LD_VAR 0 3
3602: PUSH
3603: LD_INT 1
3605: PLUS
3606: PPUSH
3607: LD_VAR 0 2
3611: PPUSH
3612: CALL_OW 1
3616: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_solar , control_manual , us_machine_gun , 90 ) ;
3617: LD_INT 1
3619: PPUSH
3620: LD_INT 1
3622: PPUSH
3623: LD_INT 2
3625: PPUSH
3626: LD_INT 2
3628: PPUSH
3629: LD_INT 1
3631: PPUSH
3632: LD_INT 2
3634: PPUSH
3635: LD_INT 90
3637: PPUSH
3638: CALL 284 0 7
// un := CreateVehicle ;
3642: LD_ADDR_VAR 0 2
3646: PUSH
3647: CALL_OW 45
3651: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3652: LD_ADDR_VAR 0 3
3656: PUSH
3657: LD_VAR 0 3
3661: PPUSH
3662: LD_VAR 0 3
3666: PUSH
3667: LD_INT 1
3669: PLUS
3670: PPUSH
3671: LD_VAR 0 2
3675: PPUSH
3676: CALL_OW 1
3680: ST_TO_ADDR
// PrepareHuman ( false , 1 , 2 ) ;
3681: LD_INT 0
3683: PPUSH
3684: LD_INT 1
3686: PPUSH
3687: LD_INT 2
3689: PPUSH
3690: CALL_OW 380
// un := CreateHuman ;
3694: LD_ADDR_VAR 0 2
3698: PUSH
3699: CALL_OW 44
3703: ST_TO_ADDR
// tmp := Replace ( tmp , tmp + 1 , un ) ;
3704: LD_ADDR_VAR 0 3
3708: PUSH
3709: LD_VAR 0 3
3713: PPUSH
3714: LD_VAR 0 3
3718: PUSH
3719: LD_INT 1
3721: PLUS
3722: PPUSH
3723: LD_VAR 0 2
3727: PPUSH
3728: CALL_OW 1
3732: ST_TO_ADDR
// end ; end ;
3733: GO 3736
3735: POP
// for i := 1 to tmp do
3736: LD_ADDR_VAR 0 1
3740: PUSH
3741: DOUBLE
3742: LD_INT 1
3744: DEC
3745: ST_TO_ADDR
3746: LD_VAR 0 3
3750: PUSH
3751: FOR_TO
3752: IFFALSE 3917
// begin SetDir ( tmp [ i ] , 1 ) ;
3754: LD_VAR 0 3
3758: PUSH
3759: LD_VAR 0 1
3763: ARRAY
3764: PPUSH
3765: LD_INT 1
3767: PPUSH
3768: CALL_OW 233
// if GetType ( tmp [ i ] ) = unit_human then
3772: LD_VAR 0 3
3776: PUSH
3777: LD_VAR 0 1
3781: ARRAY
3782: PPUSH
3783: CALL_OW 247
3787: PUSH
3788: LD_INT 1
3790: EQUAL
3791: IFFALSE 3819
// PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) else
3793: LD_VAR 0 3
3797: PUSH
3798: LD_VAR 0 1
3802: ARRAY
3803: PPUSH
3804: LD_INT 28
3806: PPUSH
3807: LD_INT 52
3809: PPUSH
3810: LD_INT 0
3812: PPUSH
3813: CALL_OW 48
3817: GO 3887
// begin PlaceUnitXY ( tmp [ i ] , 28 , 52 , false ) ;
3819: LD_VAR 0 3
3823: PUSH
3824: LD_VAR 0 1
3828: ARRAY
3829: PPUSH
3830: LD_INT 28
3832: PPUSH
3833: LD_INT 52
3835: PPUSH
3836: LD_INT 0
3838: PPUSH
3839: CALL_OW 48
// i := i + 1 ;
3843: LD_ADDR_VAR 0 1
3847: PUSH
3848: LD_VAR 0 1
3852: PUSH
3853: LD_INT 1
3855: PLUS
3856: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ i ] , tmp [ i - 1 ] ) ;
3857: LD_VAR 0 3
3861: PUSH
3862: LD_VAR 0 1
3866: ARRAY
3867: PPUSH
3868: LD_VAR 0 3
3872: PUSH
3873: LD_VAR 0 1
3877: PUSH
3878: LD_INT 1
3880: MINUS
3881: ARRAY
3882: PPUSH
3883: CALL_OW 52
// end ; ComMoveXY ( tmp [ i ] , 43 , 56 ) ;
3887: LD_VAR 0 3
3891: PUSH
3892: LD_VAR 0 1
3896: ARRAY
3897: PPUSH
3898: LD_INT 43
3900: PPUSH
3901: LD_INT 56
3903: PPUSH
3904: CALL_OW 111
// wait ( 0 0$2 ) ;
3908: LD_INT 70
3910: PPUSH
3911: CALL_OW 67
// end ;
3915: GO 3751
3917: POP
3918: POP
// wait ( 0 0$2 ) ;
3919: LD_INT 70
3921: PPUSH
3922: CALL_OW 67
// if not FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) then
3926: LD_INT 7
3928: PPUSH
3929: LD_INT 22
3931: PUSH
3932: LD_INT 2
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: PPUSH
3939: CALL_OW 70
3943: NOT
3944: IFFALSE 4142
// begin AddComAgressiveMove ( tmp , 35 , 24 ) ;
3946: LD_VAR 0 3
3950: PPUSH
3951: LD_INT 35
3953: PPUSH
3954: LD_INT 24
3956: PPUSH
3957: CALL_OW 174
// usForces := usForces union UnitFilter ( tmp , [ f_class , 1 ] ) ;
3961: LD_ADDR_EXP 19
3965: PUSH
3966: LD_EXP 19
3970: PUSH
3971: LD_VAR 0 3
3975: PPUSH
3976: LD_INT 25
3978: PUSH
3979: LD_INT 1
3981: PUSH
3982: EMPTY
3983: LIST
3984: LIST
3985: PPUSH
3986: CALL_OW 72
3990: UNION
3991: ST_TO_ADDR
// if UnitsInside ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) < 6 then
3992: LD_INT 22
3994: PUSH
3995: LD_INT 1
3997: PUSH
3998: EMPTY
3999: LIST
4000: LIST
4001: PUSH
4002: LD_INT 30
4004: PUSH
4005: LD_INT 4
4007: PUSH
4008: EMPTY
4009: LIST
4010: LIST
4011: PUSH
4012: EMPTY
4013: LIST
4014: LIST
4015: PPUSH
4016: CALL_OW 69
4020: PUSH
4021: LD_INT 1
4023: ARRAY
4024: PPUSH
4025: CALL_OW 313
4029: PUSH
4030: LD_INT 6
4032: LESS
4033: IFFALSE 4092
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 1 ] ) , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ) ;
4035: LD_VAR 0 3
4039: PPUSH
4040: LD_INT 25
4042: PUSH
4043: LD_INT 1
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: PPUSH
4050: CALL_OW 72
4054: PPUSH
4055: LD_INT 22
4057: PUSH
4058: LD_INT 1
4060: PUSH
4061: EMPTY
4062: LIST
4063: LIST
4064: PUSH
4065: LD_INT 30
4067: PUSH
4068: LD_INT 4
4070: PUSH
4071: EMPTY
4072: LIST
4073: LIST
4074: PUSH
4075: EMPTY
4076: LIST
4077: LIST
4078: PPUSH
4079: CALL_OW 69
4083: PUSH
4084: LD_INT 1
4086: ARRAY
4087: PPUSH
4088: CALL_OW 180
// if UnitFilter ( tmp , [ f_class , 4 ] ) then
4092: LD_VAR 0 3
4096: PPUSH
4097: LD_INT 25
4099: PUSH
4100: LD_INT 4
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: PPUSH
4107: CALL_OW 72
4111: IFFALSE 4140
// AddComEnterUnit ( UnitFilter ( tmp , [ f_class , 4 ] ) , usLab ) ;
4113: LD_VAR 0 3
4117: PPUSH
4118: LD_INT 25
4120: PUSH
4121: LD_INT 4
4123: PUSH
4124: EMPTY
4125: LIST
4126: LIST
4127: PPUSH
4128: CALL_OW 72
4132: PPUSH
4133: LD_INT 3
4135: PPUSH
4136: CALL_OW 180
// end else
4140: GO 4417
// begin tmp := tmp union FilterUnitsInArea ( retreatArea , [ f_side , 1 ] ) ;
4142: LD_ADDR_VAR 0 3
4146: PUSH
4147: LD_VAR 0 3
4151: PUSH
4152: LD_INT 6
4154: PPUSH
4155: LD_INT 22
4157: PUSH
4158: LD_INT 1
4160: PUSH
4161: EMPTY
4162: LIST
4163: LIST
4164: PPUSH
4165: CALL_OW 70
4169: UNION
4170: ST_TO_ADDR
// ComMoveXY ( tmp , 45 , 54 ) ;
4171: LD_VAR 0 3
4175: PPUSH
4176: LD_INT 45
4178: PPUSH
4179: LD_INT 54
4181: PPUSH
4182: CALL_OW 111
// wait ( 0 0$3 ) ;
4186: LD_INT 105
4188: PPUSH
4189: CALL_OW 67
// AddComAgressiveMove ( tmp diff UnitFilter ( tmp , [ f_class , 4 ] ) , 35 , 24 ) ;
4193: LD_VAR 0 3
4197: PUSH
4198: LD_VAR 0 3
4202: PPUSH
4203: LD_INT 25
4205: PUSH
4206: LD_INT 4
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PPUSH
4213: CALL_OW 72
4217: DIFF
4218: PPUSH
4219: LD_INT 35
4221: PPUSH
4222: LD_INT 24
4224: PPUSH
4225: CALL_OW 174
// AddComMoveXY ( UnitFilter ( tmp , [ f_class , 4 ] ) , 42 , 49 ) ;
4229: LD_VAR 0 3
4233: PPUSH
4234: LD_INT 25
4236: PUSH
4237: LD_INT 4
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PPUSH
4244: CALL_OW 72
4248: PPUSH
4249: LD_INT 42
4251: PPUSH
4252: LD_INT 49
4254: PPUSH
4255: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4259: LD_INT 35
4261: PPUSH
4262: CALL_OW 67
// for i in tmp do
4266: LD_ADDR_VAR 0 1
4270: PUSH
4271: LD_VAR 0 3
4275: PUSH
4276: FOR_IN
4277: IFFALSE 4408
// if IsDead ( i ) then
4279: LD_VAR 0 1
4283: PPUSH
4284: CALL_OW 301
4288: IFFALSE 4308
// tmp := tmp diff i else
4290: LD_ADDR_VAR 0 3
4294: PUSH
4295: LD_VAR 0 3
4299: PUSH
4300: LD_VAR 0 1
4304: DIFF
4305: ST_TO_ADDR
4306: GO 4406
// if GetClass ( i ) = 1 then
4308: LD_VAR 0 1
4312: PPUSH
4313: CALL_OW 257
4317: PUSH
4318: LD_INT 1
4320: EQUAL
4321: IFFALSE 4406
// begin if GetLives ( i ) < 600 and GetDistUnitXY ( i , 42 , 49 ) > 6 then
4323: LD_VAR 0 1
4327: PPUSH
4328: CALL_OW 256
4332: PUSH
4333: LD_INT 600
4335: LESS
4336: PUSH
4337: LD_VAR 0 1
4341: PPUSH
4342: LD_INT 42
4344: PPUSH
4345: LD_INT 49
4347: PPUSH
4348: CALL_OW 297
4352: PUSH
4353: LD_INT 6
4355: GREATER
4356: AND
4357: IFFALSE 4376
// ComMoveXY ( i , 42 , 49 ) else
4359: LD_VAR 0 1
4363: PPUSH
4364: LD_INT 42
4366: PPUSH
4367: LD_INT 49
4369: PPUSH
4370: CALL_OW 111
4374: GO 4406
// if GetLives ( i ) = 1000 then
4376: LD_VAR 0 1
4380: PPUSH
4381: CALL_OW 256
4385: PUSH
4386: LD_INT 1000
4388: EQUAL
4389: IFFALSE 4406
// ComAgressiveMove ( i , 36 , 25 ) ;
4391: LD_VAR 0 1
4395: PPUSH
4396: LD_INT 36
4398: PPUSH
4399: LD_INT 25
4401: PPUSH
4402: CALL_OW 114
// end ;
4406: GO 4276
4408: POP
4409: POP
// until not tmp ;
4410: LD_VAR 0 3
4414: NOT
4415: IFFALSE 4259
// end ; end ;
4417: PPOPN 3
4419: END
// every 0 0$1 trigger FilterUnitsInArea ( deltaBaseArea , [ f_side , 2 ] ) and not attackDeltaAllowed do var i , un , veh ;
4420: LD_INT 7
4422: PPUSH
4423: LD_INT 22
4425: PUSH
4426: LD_INT 2
4428: PUSH
4429: EMPTY
4430: LIST
4431: LIST
4432: PPUSH
4433: CALL_OW 70
4437: PUSH
4438: LD_EXP 12
4442: NOT
4443: AND
4444: IFFALSE 4602
4446: GO 4448
4448: DISABLE
4449: LD_INT 0
4451: PPUSH
4452: PPUSH
4453: PPUSH
// begin for i := 1 to 2 do
4454: LD_ADDR_VAR 0 1
4458: PUSH
4459: DOUBLE
4460: LD_INT 1
4462: DEC
4463: ST_TO_ADDR
4464: LD_INT 2
4466: PUSH
4467: FOR_TO
4468: IFFALSE 4600
// begin wait ( 0 0$3 ) ;
4470: LD_INT 105
4472: PPUSH
4473: CALL_OW 67
// uc_side := 1 ;
4477: LD_ADDR_OWVAR 20
4481: PUSH
4482: LD_INT 1
4484: ST_TO_ADDR
// uc_nation := 1 ;
4485: LD_ADDR_OWVAR 21
4489: PUSH
4490: LD_INT 1
4492: ST_TO_ADDR
// PrepareTank ( 1 , 1 , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun , 90 ) ;
4493: LD_INT 1
4495: PPUSH
4496: LD_INT 1
4498: PPUSH
4499: LD_INT 2
4501: PPUSH
4502: LD_INT 1
4504: PPUSH
4505: LD_INT 1
4507: PPUSH
4508: LD_INT 4
4510: PPUSH
4511: LD_INT 90
4513: PPUSH
4514: CALL 284 0 7
// veh := CreateVehicle ;
4518: LD_ADDR_VAR 0 3
4522: PUSH
4523: CALL_OW 45
4527: ST_TO_ADDR
// PlaceUnitXY ( veh , 29 , 52 , false ) ;
4528: LD_VAR 0 3
4532: PPUSH
4533: LD_INT 29
4535: PPUSH
4536: LD_INT 52
4538: PPUSH
4539: LD_INT 0
4541: PPUSH
4542: CALL_OW 48
// PrepareHuman ( false , 3 , 3 ) ;
4546: LD_INT 0
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: CALL_OW 380
// un := CreateHuman ;
4559: LD_ADDR_VAR 0 2
4563: PUSH
4564: CALL_OW 44
4568: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
4569: LD_VAR 0 2
4573: PPUSH
4574: LD_VAR 0 3
4578: PPUSH
4579: CALL_OW 52
// ComAgressiveMove ( veh , 36 , 25 ) ;
4583: LD_VAR 0 3
4587: PPUSH
4588: LD_INT 36
4590: PPUSH
4591: LD_INT 25
4593: PPUSH
4594: CALL_OW 114
// end ;
4598: GO 4467
4600: POP
4601: POP
// end ; end_of_file
4602: PPOPN 3
4604: END
// export function Action ; var i , tmp ; begin
4605: LD_INT 0
4607: PPUSH
4608: PPUSH
4609: PPUSH
// InGameOn ;
4610: CALL_OW 8
// DoNotAttack ( 2 , usLab ) ;
4614: LD_INT 2
4616: PPUSH
4617: LD_INT 3
4619: PPUSH
4620: CALL_OW 471
// ComMoveXY ( Heike , 78 , 61 ) ;
4624: LD_EXP 21
4628: PPUSH
4629: LD_INT 78
4631: PPUSH
4632: LD_INT 61
4634: PPUSH
4635: CALL_OW 111
// if Mike then
4639: LD_EXP 23
4643: IFFALSE 4660
// ComMoveXY ( Mike , 80 , 66 ) ;
4645: LD_EXP 23
4649: PPUSH
4650: LD_INT 80
4652: PPUSH
4653: LD_INT 66
4655: PPUSH
4656: CALL_OW 111
// if Givi then
4660: LD_EXP 22
4664: IFFALSE 4681
// ComMoveXY ( Givi , 82 , 66 ) ;
4666: LD_EXP 22
4670: PPUSH
4671: LD_INT 82
4673: PPUSH
4674: LD_INT 66
4676: PPUSH
4677: CALL_OW 111
// if Kamil then
4681: LD_EXP 24
4685: IFFALSE 4702
// ComMoveXY ( Kamil , 82 , 67 ) ;
4687: LD_EXP 24
4691: PPUSH
4692: LD_INT 82
4694: PPUSH
4695: LD_INT 67
4697: PPUSH
4698: CALL_OW 111
// CenterNowOnUnits ( Heike ) ;
4702: LD_EXP 21
4706: PPUSH
4707: CALL_OW 87
// wait ( 0 0$2 ) ;
4711: LD_INT 70
4713: PPUSH
4714: CALL_OW 67
// if Givi and Mike then
4718: LD_EXP 22
4722: PUSH
4723: LD_EXP 23
4727: AND
4728: IFFALSE 5174
// begin AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
4730: LD_EXP 22
4734: PUSH
4735: LD_EXP 23
4739: PUSH
4740: LD_EXP 24
4744: PUSH
4745: EMPTY
4746: LIST
4747: LIST
4748: LIST
4749: PPUSH
4750: LD_EXP 21
4754: PPUSH
4755: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
4759: LD_EXP 21
4763: PPUSH
4764: LD_EXP 22
4768: PPUSH
4769: CALL_OW 179
// Say ( Givi , DG-1-start ) ;
4773: LD_EXP 22
4777: PPUSH
4778: LD_STRING DG-1-start
4780: PPUSH
4781: CALL_OW 88
// Say ( Heike , DH-1-start ) ;
4785: LD_EXP 21
4789: PPUSH
4790: LD_STRING DH-1-start
4792: PPUSH
4793: CALL_OW 88
// AddComTurnUnit ( Mike , Heike ) ;
4797: LD_EXP 23
4801: PPUSH
4802: LD_EXP 21
4806: PPUSH
4807: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
4811: LD_EXP 21
4815: PPUSH
4816: LD_EXP 23
4820: PPUSH
4821: CALL_OW 179
// Say ( Mike , DM-1-start ) ;
4825: LD_EXP 23
4829: PPUSH
4830: LD_STRING DM-1-start
4832: PPUSH
4833: CALL_OW 88
// Say ( Heike , DH-2-start ) ;
4837: LD_EXP 21
4841: PPUSH
4842: LD_STRING DH-2-start
4844: PPUSH
4845: CALL_OW 88
// Say ( Mike , DM-2-start ) ;
4849: LD_EXP 23
4853: PPUSH
4854: LD_STRING DM-2-start
4856: PPUSH
4857: CALL_OW 88
// Say ( Givi , DG-2-start ) ;
4861: LD_EXP 22
4865: PPUSH
4866: LD_STRING DG-2-start
4868: PPUSH
4869: CALL_OW 88
// ComTurnUnit ( Mike , Givi ) ;
4873: LD_EXP 23
4877: PPUSH
4878: LD_EXP 22
4882: PPUSH
4883: CALL_OW 119
// ComTurnUnit ( Heike , Mike ) ;
4887: LD_EXP 21
4891: PPUSH
4892: LD_EXP 23
4896: PPUSH
4897: CALL_OW 119
// Say ( Mike , DM-3-start ) ;
4901: LD_EXP 23
4905: PPUSH
4906: LD_STRING DM-3-start
4908: PPUSH
4909: CALL_OW 88
// Say ( Heike , DH-3-start ) ;
4913: LD_EXP 21
4917: PPUSH
4918: LD_STRING DH-3-start
4920: PPUSH
4921: CALL_OW 88
// ComMoveXY ( [ Heike , Mike , Givi , Kamil ] , 84 , 51 ) ;
4925: LD_EXP 21
4929: PUSH
4930: LD_EXP 23
4934: PUSH
4935: LD_EXP 22
4939: PUSH
4940: LD_EXP 24
4944: PUSH
4945: EMPTY
4946: LIST
4947: LIST
4948: LIST
4949: LIST
4950: PPUSH
4951: LD_INT 84
4953: PPUSH
4954: LD_INT 51
4956: PPUSH
4957: CALL_OW 111
// wait ( 0 0$2 ) ;
4961: LD_INT 70
4963: PPUSH
4964: CALL_OW 67
// Say ( Givi , DG-3-start ) ;
4968: LD_EXP 22
4972: PPUSH
4973: LD_STRING DG-3-start
4975: PPUSH
4976: CALL_OW 88
// ComHold ( [ Heike , Mike , Givi , Kamil ] ) ;
4980: LD_EXP 21
4984: PUSH
4985: LD_EXP 23
4989: PUSH
4990: LD_EXP 22
4994: PUSH
4995: LD_EXP 24
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: PPUSH
5006: CALL_OW 140
// AddComTurnUnit ( Heike , Givi ) ;
5010: LD_EXP 21
5014: PPUSH
5015: LD_EXP 22
5019: PPUSH
5020: CALL_OW 179
// AddComTurnUnit ( [ Givi , Mike , Kamil ] , Heike ) ;
5024: LD_EXP 22
5028: PUSH
5029: LD_EXP 23
5033: PUSH
5034: LD_EXP 24
5038: PUSH
5039: EMPTY
5040: LIST
5041: LIST
5042: LIST
5043: PPUSH
5044: LD_EXP 21
5048: PPUSH
5049: CALL_OW 179
// Say ( Heike , DH-4-start ) ;
5053: LD_EXP 21
5057: PPUSH
5058: LD_STRING DH-4-start
5060: PPUSH
5061: CALL_OW 88
// Say ( Givi , DG-4-start ) ;
5065: LD_EXP 22
5069: PPUSH
5070: LD_STRING DG-4-start
5072: PPUSH
5073: CALL_OW 88
// Say ( Heike , DH-5-start ) ;
5077: LD_EXP 21
5081: PPUSH
5082: LD_STRING DH-5-start
5084: PPUSH
5085: CALL_OW 88
// Say ( Givi , DG-5-start ) ;
5089: LD_EXP 22
5093: PPUSH
5094: LD_STRING DG-5-start
5096: PPUSH
5097: CALL_OW 88
// Say ( Heike , DH-6-start ) ;
5101: LD_EXP 21
5105: PPUSH
5106: LD_STRING DH-6-start
5108: PPUSH
5109: CALL_OW 88
// Say ( Mike , DM-6-start ) ;
5113: LD_EXP 23
5117: PPUSH
5118: LD_STRING DM-6-start
5120: PPUSH
5121: CALL_OW 88
// ComTurnUnit ( [ Heike , Givi ] , Mike ) ;
5125: LD_EXP 21
5129: PUSH
5130: LD_EXP 22
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: LD_EXP 23
5143: PPUSH
5144: CALL_OW 119
// Say ( Givi , DG-6-start ) ;
5148: LD_EXP 22
5152: PPUSH
5153: LD_STRING DG-6-start
5155: PPUSH
5156: CALL_OW 88
// Say ( Heike , DH-7-start ) ;
5160: LD_EXP 21
5164: PPUSH
5165: LD_STRING DH-7-start
5167: PPUSH
5168: CALL_OW 88
// end else
5172: GO 5896
// if not Mike and Givi then
5174: LD_EXP 23
5178: NOT
5179: PUSH
5180: LD_EXP 22
5184: AND
5185: IFFALSE 5530
// begin AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5187: LD_EXP 22
5191: PUSH
5192: LD_EXP 24
5196: PUSH
5197: EMPTY
5198: LIST
5199: LIST
5200: PPUSH
5201: LD_EXP 21
5205: PPUSH
5206: CALL_OW 179
// AddComTurnUnit ( Heike , Givi ) ;
5210: LD_EXP 21
5214: PPUSH
5215: LD_EXP 22
5219: PPUSH
5220: CALL_OW 179
// Say ( Givi , DG-1-start-c ) ;
5224: LD_EXP 22
5228: PPUSH
5229: LD_STRING DG-1-start-c
5231: PPUSH
5232: CALL_OW 88
// Say ( Heike , DH-1-start-c ) ;
5236: LD_EXP 21
5240: PPUSH
5241: LD_STRING DH-1-start-c
5243: PPUSH
5244: CALL_OW 88
// Say ( Givi , DG-2-start-c ) ;
5248: LD_EXP 22
5252: PPUSH
5253: LD_STRING DG-2-start-c
5255: PPUSH
5256: CALL_OW 88
// Say ( Heike , DH-2-start-c ) ;
5260: LD_EXP 21
5264: PPUSH
5265: LD_STRING DH-2-start-c
5267: PPUSH
5268: CALL_OW 88
// Say ( Givi , DG-3-start-c ) ;
5272: LD_EXP 22
5276: PPUSH
5277: LD_STRING DG-3-start-c
5279: PPUSH
5280: CALL_OW 88
// ComMoveXY ( Heike , 83 , 56 ) ;
5284: LD_EXP 21
5288: PPUSH
5289: LD_INT 83
5291: PPUSH
5292: LD_INT 56
5294: PPUSH
5295: CALL_OW 111
// ComMoveXY ( Givi , 83 , 59 ) ;
5299: LD_EXP 22
5303: PPUSH
5304: LD_INT 83
5306: PPUSH
5307: LD_INT 59
5309: PPUSH
5310: CALL_OW 111
// if Kamil then
5314: LD_EXP 24
5318: IFFALSE 5335
// ComMoveXY ( Kamil , 80 , 58 ) ;
5320: LD_EXP 24
5324: PPUSH
5325: LD_INT 80
5327: PPUSH
5328: LD_INT 58
5330: PPUSH
5331: CALL_OW 111
// AddComTurnUnit ( Heike , Givi ) ;
5335: LD_EXP 21
5339: PPUSH
5340: LD_EXP 22
5344: PPUSH
5345: CALL_OW 179
// AddComTurnUnit ( [ Givi , Kamil ] , Heike ) ;
5349: LD_EXP 22
5353: PUSH
5354: LD_EXP 24
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: PPUSH
5363: LD_EXP 21
5367: PPUSH
5368: CALL_OW 179
// Say ( Heike , DH-3-start-c ) ;
5372: LD_EXP 21
5376: PPUSH
5377: LD_STRING DH-3-start-c
5379: PPUSH
5380: CALL_OW 88
// Say ( Givi , DG-4-start-c ) ;
5384: LD_EXP 22
5388: PPUSH
5389: LD_STRING DG-4-start-c
5391: PPUSH
5392: CALL_OW 88
// Say ( Heike , DH-5-start-c ) ;
5396: LD_EXP 21
5400: PPUSH
5401: LD_STRING DH-5-start-c
5403: PPUSH
5404: CALL_OW 88
// Say ( Givi , DG-5-start-c ) ;
5408: LD_EXP 22
5412: PPUSH
5413: LD_STRING DG-5-start-c
5415: PPUSH
5416: CALL_OW 88
// Say ( Heike , DH-6-start-c ) ;
5420: LD_EXP 21
5424: PPUSH
5425: LD_STRING DH-6-start-c
5427: PPUSH
5428: CALL_OW 88
// Say ( Givi , DG-6-start-c ) ;
5432: LD_EXP 22
5436: PPUSH
5437: LD_STRING DG-6-start-c
5439: PPUSH
5440: CALL_OW 88
// if Kamil then
5444: LD_EXP 24
5448: IFFALSE 5504
// begin ComTurnUnit ( Kamil , Heike ) ;
5450: LD_EXP 24
5454: PPUSH
5455: LD_EXP 21
5459: PPUSH
5460: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5464: LD_EXP 24
5468: PPUSH
5469: LD_STRING DKam-1-start-c
5471: PPUSH
5472: CALL_OW 88
// ComTurnUnit ( Givi , Kamil ) ;
5476: LD_EXP 22
5480: PPUSH
5481: LD_EXP 24
5485: PPUSH
5486: CALL_OW 119
// Say ( Givi , DG-7-start-c ) ;
5490: LD_EXP 22
5494: PPUSH
5495: LD_STRING DG-7-start-c
5497: PPUSH
5498: CALL_OW 88
// end else
5502: GO 5528
// begin Say ( Givi , DG-8-start-c ) ;
5504: LD_EXP 22
5508: PPUSH
5509: LD_STRING DG-8-start-c
5511: PPUSH
5512: CALL_OW 88
// Say ( Heike , DH-7-start-c ) ;
5516: LD_EXP 21
5520: PPUSH
5521: LD_STRING DH-7-start-c
5523: PPUSH
5524: CALL_OW 88
// end ; end else
5528: GO 5896
// if not Givi and Mike then
5530: LD_EXP 22
5534: NOT
5535: PUSH
5536: LD_EXP 23
5540: AND
5541: IFFALSE 5800
// begin AddComTurnUnit ( [ Mike , Kamil ] , Heike ) ;
5543: LD_EXP 23
5547: PUSH
5548: LD_EXP 24
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PPUSH
5557: LD_EXP 21
5561: PPUSH
5562: CALL_OW 179
// AddComTurnUnit ( Heike , Mike ) ;
5566: LD_EXP 21
5570: PPUSH
5571: LD_EXP 23
5575: PPUSH
5576: CALL_OW 179
// Say ( Mike , DM-1-start-b ) ;
5580: LD_EXP 23
5584: PPUSH
5585: LD_STRING DM-1-start-b
5587: PPUSH
5588: CALL_OW 88
// Say ( Heike , DH-1-start-b ) ;
5592: LD_EXP 21
5596: PPUSH
5597: LD_STRING DH-1-start-b
5599: PPUSH
5600: CALL_OW 88
// Say ( Mike , DM-2-start-b ) ;
5604: LD_EXP 23
5608: PPUSH
5609: LD_STRING DM-2-start-b
5611: PPUSH
5612: CALL_OW 88
// Say ( Heike , DH-2-start-b ) ;
5616: LD_EXP 21
5620: PPUSH
5621: LD_STRING DH-2-start-b
5623: PPUSH
5624: CALL_OW 88
// Say ( Mike , DM-3-start-b ) ;
5628: LD_EXP 23
5632: PPUSH
5633: LD_STRING DM-3-start-b
5635: PPUSH
5636: CALL_OW 88
// if Kamil then
5640: LD_EXP 24
5644: IFFALSE 5661
// ComMoveXY ( Kamil , 80 , 58 ) ;
5646: LD_EXP 24
5650: PPUSH
5651: LD_INT 80
5653: PPUSH
5654: LD_INT 58
5656: PPUSH
5657: CALL_OW 111
// ComMoveXY ( Heike , 83 , 56 ) ;
5661: LD_EXP 21
5665: PPUSH
5666: LD_INT 83
5668: PPUSH
5669: LD_INT 56
5671: PPUSH
5672: CALL_OW 111
// ComMoveXY ( Mike , 83 , 59 ) ;
5676: LD_EXP 23
5680: PPUSH
5681: LD_INT 83
5683: PPUSH
5684: LD_INT 59
5686: PPUSH
5687: CALL_OW 111
// AddComTurnUnit ( Heike , Mike ) ;
5691: LD_EXP 21
5695: PPUSH
5696: LD_EXP 23
5700: PPUSH
5701: CALL_OW 179
// AddComTurnUnit ( [ Kamil , Mike ] , Heike ) ;
5705: LD_EXP 24
5709: PUSH
5710: LD_EXP 23
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PPUSH
5719: LD_EXP 21
5723: PPUSH
5724: CALL_OW 179
// Say ( Heike , DH-3-start-b ) ;
5728: LD_EXP 21
5732: PPUSH
5733: LD_STRING DH-3-start-b
5735: PPUSH
5736: CALL_OW 88
// Say ( Mike , DM-4-start-b ) ;
5740: LD_EXP 23
5744: PPUSH
5745: LD_STRING DM-4-start-b
5747: PPUSH
5748: CALL_OW 88
// if Kamil then
5752: LD_EXP 24
5756: IFFALSE 5786
// begin ComTurnUnit ( Kamil , Heike ) ;
5758: LD_EXP 24
5762: PPUSH
5763: LD_EXP 21
5767: PPUSH
5768: CALL_OW 119
// Say ( Kamil , DKam-1-start-c ) ;
5772: LD_EXP 24
5776: PPUSH
5777: LD_STRING DKam-1-start-c
5779: PPUSH
5780: CALL_OW 88
// end else
5784: GO 5798
// begin Say ( Mike , DM-5-start-b ) ;
5786: LD_EXP 23
5790: PPUSH
5791: LD_STRING DM-5-start-b
5793: PPUSH
5794: CALL_OW 88
// end ; end else
5798: GO 5896
// if Kamil then
5800: LD_EXP 24
5804: IFFALSE 5884
// begin AddComTurnUnit ( Heike , Kamil ) ;
5806: LD_EXP 21
5810: PPUSH
5811: LD_EXP 24
5815: PPUSH
5816: CALL_OW 179
// AddComTurnUnit ( Kamil , Heike ) ;
5820: LD_EXP 24
5824: PPUSH
5825: LD_EXP 21
5829: PPUSH
5830: CALL_OW 179
// Say ( Heike , DH-1-start-f ) ;
5834: LD_EXP 21
5838: PPUSH
5839: LD_STRING DH-1-start-f
5841: PPUSH
5842: CALL_OW 88
// Say ( Kamil , DKam-1-start-f ) ;
5846: LD_EXP 24
5850: PPUSH
5851: LD_STRING DKam-1-start-f
5853: PPUSH
5854: CALL_OW 88
// Say ( Heike , DH-2-start-f ) ;
5858: LD_EXP 21
5862: PPUSH
5863: LD_STRING DH-2-start-f
5865: PPUSH
5866: CALL_OW 88
// Say ( Kamil , DKam-2-start-f ) ;
5870: LD_EXP 24
5874: PPUSH
5875: LD_STRING DKam-2-start-f
5877: PPUSH
5878: CALL_OW 88
// end else
5882: GO 5896
// begin Say ( Heike , DH-1-start-d ) ;
5884: LD_EXP 21
5888: PPUSH
5889: LD_STRING DH-1-start-d
5891: PPUSH
5892: CALL_OW 88
// end ; ComFree ( [ Heike , Givi , Mike , Kamil ] ) ;
5896: LD_EXP 21
5900: PUSH
5901: LD_EXP 22
5905: PUSH
5906: LD_EXP 23
5910: PUSH
5911: LD_EXP 24
5915: PUSH
5916: EMPTY
5917: LIST
5918: LIST
5919: LIST
5920: LIST
5921: PPUSH
5922: CALL_OW 139
// InGameOff ;
5926: CALL_OW 9
// ChangeMissionObjectives ( OEast ) ;
5930: LD_STRING OEast
5932: PPUSH
5933: CALL_OW 337
// SaveForQuickRestart ;
5937: CALL_OW 22
// wait ( 0 0$20 ) ;
5941: LD_INT 700
5943: PPUSH
5944: CALL_OW 67
// SendSciToForest ;
5948: CALL 1374 0 0
// if Difficulty = 1 then
5952: LD_OWVAR 67
5956: PUSH
5957: LD_INT 1
5959: EQUAL
5960: IFFALSE 5964
// exit ;
5962: GO 6081
// wait ( [ 5 5$00 , 2 2$30 ] [ Difficulty - 1 ] ) ;
5964: LD_INT 10500
5966: PUSH
5967: LD_INT 5250
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: PUSH
5974: LD_OWVAR 67
5978: PUSH
5979: LD_INT 1
5981: MINUS
5982: ARRAY
5983: PPUSH
5984: CALL_OW 67
// if usAlert then
5988: LD_EXP 9
5992: IFFALSE 5996
// exit ;
5994: GO 6081
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) ;
5996: LD_ADDR_VAR 0 3
6000: PUSH
6001: LD_INT 22
6003: PUSH
6004: LD_INT 1
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: PUSH
6011: LD_INT 25
6013: PUSH
6014: LD_INT 2
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: PPUSH
6025: CALL_OW 69
6029: ST_TO_ADDR
// if not tmp then
6030: LD_VAR 0 3
6034: NOT
6035: IFFALSE 6039
// exit ;
6037: GO 6081
// ComExitBuilding ( tmp ) ;
6039: LD_VAR 0 3
6043: PPUSH
6044: CALL_OW 122
// AddComBuild ( tmp , b_breastwork , 40 , 13 , 3 ) ;
6048: LD_VAR 0 3
6052: PPUSH
6053: LD_INT 31
6055: PPUSH
6056: LD_INT 40
6058: PPUSH
6059: LD_INT 13
6061: PPUSH
6062: LD_INT 3
6064: PPUSH
6065: CALL_OW 205
// AddComEnterUnit ( tmp , Delta ) ;
6069: LD_VAR 0 3
6073: PPUSH
6074: LD_INT 1
6076: PPUSH
6077: CALL_OW 180
// end ;
6081: LD_VAR 0 1
6085: RET
// every 3 3$00 do
6086: GO 6088
6088: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
6089: LD_INT 1
6091: PPUSH
6092: LD_INT 570
6094: PPUSH
6095: LD_INT 350
6097: PPUSH
6098: CALL_OW 550
// wait ( 2 2$40 ) ;
6102: LD_INT 5600
6104: PPUSH
6105: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
6109: LD_INT 0
6111: PPUSH
6112: LD_INT 570
6114: PPUSH
6115: LD_INT 350
6117: PPUSH
6118: CALL_OW 550
// end ;
6122: END
// every 0 0$1 trigger not aviradzeSpotted and See ( 2 , Aviradze ) do var i , pepAmount ;
6123: LD_EXP 4
6127: NOT
6128: PUSH
6129: LD_INT 2
6131: PPUSH
6132: LD_EXP 25
6136: PPUSH
6137: CALL_OW 292
6141: AND
6142: IFFALSE 7077
6144: GO 6146
6146: DISABLE
6147: LD_INT 0
6149: PPUSH
6150: PPUSH
// begin aviradzeSpotted := true ;
6151: LD_ADDR_EXP 4
6155: PUSH
6156: LD_INT 1
6158: ST_TO_ADDR
// pepAmount := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ;
6159: LD_ADDR_VAR 0 2
6163: PUSH
6164: LD_INT 22
6166: PUSH
6167: LD_INT 2
6169: PUSH
6170: EMPTY
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 21
6176: PUSH
6177: LD_INT 1
6179: PUSH
6180: EMPTY
6181: LIST
6182: LIST
6183: PUSH
6184: EMPTY
6185: LIST
6186: LIST
6187: PPUSH
6188: CALL_OW 69
6192: ST_TO_ADDR
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6193: LD_EXP 21
6197: PPUSH
6198: LD_EXP 25
6202: PPUSH
6203: CALL_OW 250
6207: PPUSH
6208: LD_EXP 25
6212: PPUSH
6213: CALL_OW 251
6217: PPUSH
6218: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6222: LD_INT 35
6224: PPUSH
6225: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 16 ;
6229: LD_EXP 21
6233: PPUSH
6234: LD_EXP 25
6238: PPUSH
6239: CALL_OW 296
6243: PUSH
6244: LD_INT 16
6246: LESS
6247: IFFALSE 6222
// InGameOn ;
6249: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6253: LD_INT 5
6255: PPUSH
6256: LD_INT 2
6258: PPUSH
6259: CALL_OW 343
// if pepAmount > 2 then
6263: LD_VAR 0 2
6267: PUSH
6268: LD_INT 2
6270: GREATER
6271: IFFALSE 6287
// Say ( Heike , DH-1-spot ) else
6273: LD_EXP 21
6277: PPUSH
6278: LD_STRING DH-1-spot
6280: PPUSH
6281: CALL_OW 88
6285: GO 6299
// Say ( Heike , DH-1-spot-d ) ;
6287: LD_EXP 21
6291: PPUSH
6292: LD_STRING DH-1-spot-d
6294: PPUSH
6295: CALL_OW 88
// ComMoveXY ( Heike , GetX ( Aviradze ) , GetY ( Aviradze ) ) ;
6299: LD_EXP 21
6303: PPUSH
6304: LD_EXP 25
6308: PPUSH
6309: CALL_OW 250
6313: PPUSH
6314: LD_EXP 25
6318: PPUSH
6319: CALL_OW 251
6323: PPUSH
6324: CALL_OW 111
// for i in [ Kamil , Mike , Givi ] do
6328: LD_ADDR_VAR 0 1
6332: PUSH
6333: LD_EXP 24
6337: PUSH
6338: LD_EXP 23
6342: PUSH
6343: LD_EXP 22
6347: PUSH
6348: EMPTY
6349: LIST
6350: LIST
6351: LIST
6352: PUSH
6353: FOR_IN
6354: IFFALSE 6393
// if GetDistUnits ( i , Aviradze ) > 7 then
6356: LD_VAR 0 1
6360: PPUSH
6361: LD_EXP 25
6365: PPUSH
6366: CALL_OW 296
6370: PUSH
6371: LD_INT 7
6373: GREATER
6374: IFFALSE 6391
// ComMoveXY ( i , 102 , 40 ) ;
6376: LD_VAR 0 1
6380: PPUSH
6381: LD_INT 102
6383: PPUSH
6384: LD_INT 40
6386: PPUSH
6387: CALL_OW 111
6391: GO 6353
6393: POP
6394: POP
// repeat wait ( 0 0$1 ) ;
6395: LD_INT 35
6397: PPUSH
6398: CALL_OW 67
// until GetDistUnits ( Heike , Aviradze ) < 6 ;
6402: LD_EXP 21
6406: PPUSH
6407: LD_EXP 25
6411: PPUSH
6412: CALL_OW 296
6416: PUSH
6417: LD_INT 6
6419: LESS
6420: IFFALSE 6395
// ComTurnUnit ( Heike , Aviradze ) ;
6422: LD_EXP 21
6426: PPUSH
6427: LD_EXP 25
6431: PPUSH
6432: CALL_OW 119
// ComTurnUnit ( [ Aviradze , Sophia , Kaia ] , Heike ) ;
6436: LD_EXP 25
6440: PUSH
6441: LD_EXP 27
6445: PUSH
6446: LD_EXP 26
6450: PUSH
6451: EMPTY
6452: LIST
6453: LIST
6454: LIST
6455: PPUSH
6456: LD_EXP 21
6460: PPUSH
6461: CALL_OW 119
// if pepAmount > 1 then
6465: LD_VAR 0 2
6469: PUSH
6470: LD_INT 1
6472: GREATER
6473: IFFALSE 6525
// begin wait ( 0 0$2 ) ;
6475: LD_INT 70
6477: PPUSH
6478: CALL_OW 67
// ComTurnUnit ( [ Kamil , Mike , Givi ] , Aviradze ) ;
6482: LD_EXP 24
6486: PUSH
6487: LD_EXP 23
6491: PUSH
6492: LD_EXP 22
6496: PUSH
6497: EMPTY
6498: LIST
6499: LIST
6500: LIST
6501: PPUSH
6502: LD_EXP 25
6506: PPUSH
6507: CALL_OW 119
// Say ( Heike , DH-2-spot ) ;
6511: LD_EXP 21
6515: PPUSH
6516: LD_STRING DH-2-spot
6518: PPUSH
6519: CALL_OW 88
// end else
6523: GO 6537
// Say ( Heike , DH-2-spot-d ) ;
6525: LD_EXP 21
6529: PPUSH
6530: LD_STRING DH-2-spot-d
6532: PPUSH
6533: CALL_OW 88
// Say ( Aviradze , DA-2-spot ) ;
6537: LD_EXP 25
6541: PPUSH
6542: LD_STRING DA-2-spot
6544: PPUSH
6545: CALL_OW 88
// Say ( Heike , DH-3-spot ) ;
6549: LD_EXP 21
6553: PPUSH
6554: LD_STRING DH-3-spot
6556: PPUSH
6557: CALL_OW 88
// ComMoveUnit ( Kaia , Heike ) ;
6561: LD_EXP 26
6565: PPUSH
6566: LD_EXP 21
6570: PPUSH
6571: CALL_OW 112
// ComTurnUNit ( Heike , Kaia ) ;
6575: LD_EXP 21
6579: PPUSH
6580: LD_EXP 26
6584: PPUSH
6585: CALL_OW 119
// wait ( 0 0$0.3 ) ;
6589: LD_INT 10
6591: PPUSH
6592: CALL_OW 67
// async ;
6596: ASYNC
// Say ( Kaia , DK-3-spot ) ;
6597: LD_EXP 26
6601: PPUSH
6602: LD_STRING DK-3-spot
6604: PPUSH
6605: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
6609: LD_INT 35
6611: PPUSH
6612: CALL_OW 67
// until GetDistUnits ( Heike , Kaia ) < 4 ;
6616: LD_EXP 21
6620: PPUSH
6621: LD_EXP 26
6625: PPUSH
6626: CALL_OW 296
6630: PUSH
6631: LD_INT 4
6633: LESS
6634: IFFALSE 6609
// ComTurnUnit ( Kaia , Heike ) ;
6636: LD_EXP 26
6640: PPUSH
6641: LD_EXP 21
6645: PPUSH
6646: CALL_OW 119
// sync ;
6650: SYNC
// Say ( Heike , DH-4-spot ) ;
6651: LD_EXP 21
6655: PPUSH
6656: LD_STRING DH-4-spot
6658: PPUSH
6659: CALL_OW 88
// wait ( 0 0$0.3 ) ;
6663: LD_INT 10
6665: PPUSH
6666: CALL_OW 67
// ComTurnUnit ( Heike , Aviradze ) ;
6670: LD_EXP 21
6674: PPUSH
6675: LD_EXP 25
6679: PPUSH
6680: CALL_OW 119
// Say ( Aviradze , DA-4-spot ) ;
6684: LD_EXP 25
6688: PPUSH
6689: LD_STRING DA-4-spot
6691: PPUSH
6692: CALL_OW 88
// ComTurnUnit ( Kaia , Aviradze ) ;
6696: LD_EXP 26
6700: PPUSH
6701: LD_EXP 25
6705: PPUSH
6706: CALL_OW 119
// Say ( Kaia , DK-4-spot ) ;
6710: LD_EXP 26
6714: PPUSH
6715: LD_STRING DK-4-spot
6717: PPUSH
6718: CALL_OW 88
// ComTurnUnit ( Aviradze , Kaia ) ;
6722: LD_EXP 25
6726: PPUSH
6727: LD_EXP 26
6731: PPUSH
6732: CALL_OW 119
// Say ( Aviradze , DA-5-spot ) ;
6736: LD_EXP 25
6740: PPUSH
6741: LD_STRING DA-5-spot
6743: PPUSH
6744: CALL_OW 88
// Say ( Kaia , DK-5-spot ) ;
6748: LD_EXP 26
6752: PPUSH
6753: LD_STRING DK-5-spot
6755: PPUSH
6756: CALL_OW 88
// if pepAmount = 1 then
6760: LD_VAR 0 2
6764: PUSH
6765: LD_INT 1
6767: EQUAL
6768: IFFALSE 6782
// Say ( Heike , DH-5-spot-f ) ;
6770: LD_EXP 21
6774: PPUSH
6775: LD_STRING DH-5-spot-f
6777: PPUSH
6778: CALL_OW 88
// if pepAmount < 3 then
6782: LD_VAR 0 2
6786: PUSH
6787: LD_INT 3
6789: LESS
6790: IFFALSE 6806
// Say ( Aviradze , DA-6-spot-f ) else
6792: LD_EXP 25
6796: PPUSH
6797: LD_STRING DA-6-spot-f
6799: PPUSH
6800: CALL_OW 88
6804: GO 6842
// if pepAmount < 4 then
6806: LD_VAR 0 2
6810: PUSH
6811: LD_INT 4
6813: LESS
6814: IFFALSE 6830
// Say ( Aviradze , DA-6-spot-c ) else
6816: LD_EXP 25
6820: PPUSH
6821: LD_STRING DA-6-spot-c
6823: PPUSH
6824: CALL_OW 88
6828: GO 6842
// Say ( Aviradze , DA-6-spot ) ;
6830: LD_EXP 25
6834: PPUSH
6835: LD_STRING DA-6-spot
6837: PPUSH
6838: CALL_OW 88
// if Kamil then
6842: LD_EXP 24
6846: IFFALSE 6860
// Say ( Kamil , DKam-6-spot ) ;
6848: LD_EXP 24
6852: PPUSH
6853: LD_STRING DKam-6-spot
6855: PPUSH
6856: CALL_OW 88
// Say ( Kaia , DK-6-spot ) ;
6860: LD_EXP 26
6864: PPUSH
6865: LD_STRING DK-6-spot
6867: PPUSH
6868: CALL_OW 88
// ComTurnUnit ( Aviradze , Heike ) ;
6872: LD_EXP 25
6876: PPUSH
6877: LD_EXP 21
6881: PPUSH
6882: CALL_OW 119
// Say ( Aviradze , DA-7-spot ) ;
6886: LD_EXP 25
6890: PPUSH
6891: LD_STRING DA-7-spot
6893: PPUSH
6894: CALL_OW 88
// Say ( Heike , DH-7-spot ) ;
6898: LD_EXP 21
6902: PPUSH
6903: LD_STRING DH-7-spot
6905: PPUSH
6906: CALL_OW 88
// if sciCounterKill >= 3 then
6910: LD_EXP 8
6914: PUSH
6915: LD_INT 3
6917: GREATEREQUAL
6918: IFFALSE 6944
// begin Say ( Heike , DH-7-spot-a ) ;
6920: LD_EXP 21
6924: PPUSH
6925: LD_STRING DH-7-spot-a
6927: PPUSH
6928: CALL_OW 88
// Say ( Aviradze , DA-8-spot-a ) ;
6932: LD_EXP 25
6936: PPUSH
6937: LD_STRING DA-8-spot-a
6939: PPUSH
6940: CALL_OW 88
// end ; InGameOff ;
6944: CALL_OW 9
// if sciCounterKill < 3 then
6948: LD_EXP 8
6952: PUSH
6953: LD_INT 3
6955: LESS
6956: IFFALSE 7015
// begin SetSide ( Kaia , 2 ) ;
6958: LD_EXP 26
6962: PPUSH
6963: LD_INT 2
6965: PPUSH
6966: CALL_OW 235
// ComFree ( Kaia ) ;
6970: LD_EXP 26
6974: PPUSH
6975: CALL_OW 139
// if Kamil then
6979: LD_EXP 24
6983: IFFALSE 7006
// begin ComHold ( Kamil ) ;
6985: LD_EXP 24
6989: PPUSH
6990: CALL_OW 140
// SetSide ( Kamil , 5 ) ;
6994: LD_EXP 24
6998: PPUSH
6999: LD_INT 5
7001: PPUSH
7002: CALL_OW 235
// end ; ChangeMissionObjectives ( OSci ) ;
7006: LD_STRING OSci
7008: PPUSH
7009: CALL_OW 337
// end else
7013: GO 7077
// begin aviradzeQuestDone := true ;
7015: LD_ADDR_EXP 7
7019: PUSH
7020: LD_INT 1
7022: ST_TO_ADDR
// attackDeltaAllowed := true ;
7023: LD_ADDR_EXP 12
7027: PUSH
7028: LD_INT 1
7030: ST_TO_ADDR
// ChangeMissionObjectives ( ODelta2 ) ;
7031: LD_STRING ODelta2
7033: PPUSH
7034: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7038: LD_ADDR_VAR 0 1
7042: PUSH
7043: LD_INT 22
7045: PUSH
7046: LD_INT 5
7048: PUSH
7049: EMPTY
7050: LIST
7051: LIST
7052: PPUSH
7053: CALL_OW 69
7057: PUSH
7058: FOR_IN
7059: IFFALSE 7075
// SetSide ( i , 2 ) ;
7061: LD_VAR 0 1
7065: PPUSH
7066: LD_INT 2
7068: PPUSH
7069: CALL_OW 235
7073: GO 7058
7075: POP
7076: POP
// end ; end ;
7077: PPOPN 2
7079: END
// every 0 0$1 trigger not sciSpotted and GetDistUnits ( NearestUnitToUnit ( usSci , Heike ) , Heike ) < 8 and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and not aviradzeSpotted do
7080: LD_EXP 6
7084: NOT
7085: PUSH
7086: LD_EXP 20
7090: PPUSH
7091: LD_EXP 21
7095: PPUSH
7096: CALL_OW 74
7100: PPUSH
7101: LD_EXP 21
7105: PPUSH
7106: CALL_OW 296
7110: PUSH
7111: LD_INT 8
7113: LESS
7114: AND
7115: PUSH
7116: LD_INT 2
7118: PPUSH
7119: LD_EXP 20
7123: PPUSH
7124: LD_EXP 21
7128: PPUSH
7129: CALL_OW 74
7133: PPUSH
7134: CALL_OW 292
7138: AND
7139: PUSH
7140: LD_INT 22
7142: PUSH
7143: LD_INT 2
7145: PUSH
7146: EMPTY
7147: LIST
7148: LIST
7149: PUSH
7150: LD_INT 21
7152: PUSH
7153: LD_INT 1
7155: PUSH
7156: EMPTY
7157: LIST
7158: LIST
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PPUSH
7164: CALL_OW 69
7168: PUSH
7169: LD_INT 1
7171: GREATER
7172: AND
7173: PUSH
7174: LD_EXP 4
7178: NOT
7179: AND
7180: IFFALSE 7224
7182: GO 7184
7184: DISABLE
// begin sciSpotted := true ;
7185: LD_ADDR_EXP 6
7189: PUSH
7190: LD_INT 1
7192: ST_TO_ADDR
// CenterNowOnUnits ( NearestUnitToUnit ( usSci , Heike ) ) ;
7193: LD_EXP 20
7197: PPUSH
7198: LD_EXP 21
7202: PPUSH
7203: CALL_OW 74
7207: PPUSH
7208: CALL_OW 87
// Say ( Heike , DH-1-sci ) ;
7212: LD_EXP 21
7216: PPUSH
7217: LD_STRING DH-1-sci
7219: PPUSH
7220: CALL_OW 88
// end ;
7224: END
// every 0 0$1 trigger aviradzeSpotted and not sciSpotted and See ( 2 , NearestUnitToUnit ( usSci , Heike ) ) and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) > 1 and aviradzeSpotted and not aviradzeQuestDone do var un ;
7225: LD_EXP 4
7229: PUSH
7230: LD_EXP 6
7234: NOT
7235: AND
7236: PUSH
7237: LD_INT 2
7239: PPUSH
7240: LD_EXP 20
7244: PPUSH
7245: LD_EXP 21
7249: PPUSH
7250: CALL_OW 74
7254: PPUSH
7255: CALL_OW 292
7259: AND
7260: PUSH
7261: LD_INT 22
7263: PUSH
7264: LD_INT 2
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: PUSH
7271: LD_INT 21
7273: PUSH
7274: LD_INT 1
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: PUSH
7290: LD_INT 1
7292: GREATER
7293: AND
7294: PUSH
7295: LD_EXP 4
7299: AND
7300: PUSH
7301: LD_EXP 7
7305: NOT
7306: AND
7307: IFFALSE 7448
7309: GO 7311
7311: DISABLE
7312: LD_INT 0
7314: PPUSH
// begin sciSpotted := true ;
7315: LD_ADDR_EXP 6
7319: PUSH
7320: LD_INT 1
7322: ST_TO_ADDR
// un := NearestUnitToUnit ( usSci , Heike ) ;
7323: LD_ADDR_VAR 0 1
7327: PUSH
7328: LD_EXP 20
7332: PPUSH
7333: LD_EXP 21
7337: PPUSH
7338: CALL_OW 74
7342: ST_TO_ADDR
// DialogueOn ;
7343: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 2 , - 3 ) ;
7347: LD_VAR 0 1
7351: PPUSH
7352: CALL_OW 250
7356: PPUSH
7357: LD_VAR 0 1
7361: PPUSH
7362: CALL_OW 251
7366: PPUSH
7367: LD_INT 2
7369: PPUSH
7370: LD_INT 3
7372: NEG
7373: PPUSH
7374: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7378: LD_VAR 0 1
7382: PPUSH
7383: CALL_OW 87
// Say ( Heike , DH-1-sci-a ) ;
7387: LD_EXP 21
7391: PPUSH
7392: LD_STRING DH-1-sci-a
7394: PPUSH
7395: CALL_OW 88
// if Mike then
7399: LD_EXP 23
7403: IFFALSE 7417
// Say ( Mike , DM-1-sci-a ) ;
7405: LD_EXP 23
7409: PPUSH
7410: LD_STRING DM-1-sci-a
7412: PPUSH
7413: CALL_OW 88
// RemoveSeeing ( GetX ( un ) , GetY ( un ) , 2 ) ;
7417: LD_VAR 0 1
7421: PPUSH
7422: CALL_OW 250
7426: PPUSH
7427: LD_VAR 0 1
7431: PPUSH
7432: CALL_OW 251
7436: PPUSH
7437: LD_INT 2
7439: PPUSH
7440: CALL_OW 331
// DialogueOff ;
7444: CALL_OW 7
// end ;
7448: PPOPN 1
7450: END
// every 0 0$1 trigger aviradzeSpotted and ( sciCounterKill >= 3 or not usSci ) and not aviradzeQuestDone do
7451: LD_EXP 4
7455: PUSH
7456: LD_EXP 8
7460: PUSH
7461: LD_INT 3
7463: GREATEREQUAL
7464: PUSH
7465: LD_EXP 20
7469: NOT
7470: OR
7471: AND
7472: PUSH
7473: LD_EXP 7
7477: NOT
7478: AND
7479: IFFALSE 7522
7481: GO 7483
7483: DISABLE
// begin aviradzeQuestDone := true ;
7484: LD_ADDR_EXP 7
7488: PUSH
7489: LD_INT 1
7491: ST_TO_ADDR
// Say ( Heike , DH-1-quest-done ) ;
7492: LD_EXP 21
7496: PPUSH
7497: LD_STRING DH-1-quest-done
7499: PPUSH
7500: CALL_OW 88
// if Givi then
7504: LD_EXP 22
7508: IFFALSE 7522
// Say ( Givi , DG-1-quest-done ) ;
7510: LD_EXP 22
7514: PPUSH
7515: LD_STRING DG-1-quest-done
7517: PPUSH
7518: CALL_OW 88
// end ;
7522: END
// every 0 0$1 trigger See ( 5 , Heike ) and GetDistUnits ( Heike , Aviradze ) < 6 and aviradzeQuestDone and not attackDeltaAllowed do var i ;
7523: LD_INT 5
7525: PPUSH
7526: LD_EXP 21
7530: PPUSH
7531: CALL_OW 292
7535: PUSH
7536: LD_EXP 21
7540: PPUSH
7541: LD_EXP 25
7545: PPUSH
7546: CALL_OW 296
7550: PUSH
7551: LD_INT 6
7553: LESS
7554: AND
7555: PUSH
7556: LD_EXP 7
7560: AND
7561: PUSH
7562: LD_EXP 12
7566: NOT
7567: AND
7568: IFFALSE 7706
7570: GO 7572
7572: DISABLE
7573: LD_INT 0
7575: PPUSH
// begin attackDeltaAllowed := true ;
7576: LD_ADDR_EXP 12
7580: PUSH
7581: LD_INT 1
7583: ST_TO_ADDR
// InGameOn ;
7584: CALL_OW 8
// CenterNowOnUnits ( Heike ) ;
7588: LD_EXP 21
7592: PPUSH
7593: CALL_OW 87
// wait ( 0 0$0.3 ) ;
7597: LD_INT 10
7599: PPUSH
7600: CALL_OW 67
// ComTurnUnit ( Aviradze , Heike ) ;
7604: LD_EXP 25
7608: PPUSH
7609: LD_EXP 21
7613: PPUSH
7614: CALL_OW 119
// ComTurnUnit ( Heike , Aviradze ) ;
7618: LD_EXP 21
7622: PPUSH
7623: LD_EXP 25
7627: PPUSH
7628: CALL_OW 119
// Say ( Heike , DH-1-return ) ;
7632: LD_EXP 21
7636: PPUSH
7637: LD_STRING DH-1-return
7639: PPUSH
7640: CALL_OW 88
// Say ( Aviradze , DA-1-return ) ;
7644: LD_EXP 25
7648: PPUSH
7649: LD_STRING DA-1-return
7651: PPUSH
7652: CALL_OW 88
// InGameOff ;
7656: CALL_OW 9
// ChangeMissionObjectives ( ODelta ) ;
7660: LD_STRING ODelta
7662: PPUSH
7663: CALL_OW 337
// for i in FilterAllUnits ( [ f_side , 5 ] ) do
7667: LD_ADDR_VAR 0 1
7671: PUSH
7672: LD_INT 22
7674: PUSH
7675: LD_INT 5
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PPUSH
7682: CALL_OW 69
7686: PUSH
7687: FOR_IN
7688: IFFALSE 7704
// SetSide ( i , 2 ) ;
7690: LD_VAR 0 1
7694: PPUSH
7695: LD_INT 2
7697: PPUSH
7698: CALL_OW 235
7702: GO 7687
7704: POP
7705: POP
// end ;
7706: PPOPN 1
7708: END
// every 0 0$1 trigger attackDeltaAllowed and IsOk ( Markov ) and GetSide ( Delta ) = 1 and IsOk ( Lynch ) and not usAlert do var i , k , tmp ;
7709: LD_EXP 12
7713: PUSH
7714: LD_EXP 28
7718: PPUSH
7719: CALL_OW 302
7723: AND
7724: PUSH
7725: LD_INT 1
7727: PPUSH
7728: CALL_OW 255
7732: PUSH
7733: LD_INT 1
7735: EQUAL
7736: AND
7737: PUSH
7738: LD_EXP 18
7742: PPUSH
7743: CALL_OW 302
7747: AND
7748: PUSH
7749: LD_EXP 9
7753: NOT
7754: AND
7755: IFFALSE 8971
7757: GO 7759
7759: DISABLE
7760: LD_INT 0
7762: PPUSH
7763: PPUSH
7764: PPUSH
// begin trap := 0 ;
7765: LD_ADDR_EXP 15
7769: PUSH
7770: LD_INT 0
7772: ST_TO_ADDR
// wait ( 0 0$15 ) ;
7773: LD_INT 525
7775: PPUSH
7776: CALL_OW 67
// DialogueOn ;
7780: CALL_OW 6
// Say ( Markov , DMar-1-radio ) ;
7784: LD_EXP 28
7788: PPUSH
7789: LD_STRING DMar-1-radio
7791: PPUSH
7792: CALL_OW 88
// Say ( Heike , DH-1-radio ) ;
7796: LD_EXP 21
7800: PPUSH
7801: LD_STRING DH-1-radio
7803: PPUSH
7804: CALL_OW 88
// Say ( Markov , DMar-2-radio ) ;
7808: LD_EXP 28
7812: PPUSH
7813: LD_STRING DMar-2-radio
7815: PPUSH
7816: CALL_OW 88
// Say ( Heike , DH-2-radio ) ;
7820: LD_EXP 21
7824: PPUSH
7825: LD_STRING DH-2-radio
7827: PPUSH
7828: CALL_OW 88
// if IsOk ( Kamil ) or IsOk ( Sophia ) then
7832: LD_EXP 24
7836: PPUSH
7837: CALL_OW 302
7841: PUSH
7842: LD_EXP 27
7846: PPUSH
7847: CALL_OW 302
7851: OR
7852: IFFALSE 8971
// begin case Query ( Q1Trap ) of 1 :
7854: LD_STRING Q1Trap
7856: PPUSH
7857: CALL_OW 97
7861: PUSH
7862: LD_INT 1
7864: DOUBLE
7865: EQUAL
7866: IFTRUE 7870
7868: GO 8064
7870: POP
// begin if IsOk ( Kamil ) then
7871: LD_EXP 24
7875: PPUSH
7876: CALL_OW 302
7880: IFFALSE 7959
// begin Say ( Kamil , DKam-2-radio ) ;
7882: LD_EXP 24
7886: PPUSH
7887: LD_STRING DKam-2-radio
7889: PPUSH
7890: CALL_OW 88
// Say ( Kamil , DKam-3-radio ) ;
7894: LD_EXP 24
7898: PPUSH
7899: LD_STRING DKam-3-radio
7901: PPUSH
7902: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio ) ;
7906: LD_EXP 18
7910: PPUSH
7911: LD_STRING DDelta-3-radio
7913: PPUSH
7914: CALL_OW 94
// dwait ( 0 0$01 ) ;
7918: LD_INT 35
7920: PPUSH
7921: CALL_OW 68
// Say ( Heike , DH-3-radio ) ;
7925: LD_EXP 21
7929: PPUSH
7930: LD_STRING DH-3-radio
7932: PPUSH
7933: CALL_OW 88
// Say ( Kamil , DKam-4-radio ) ;
7937: LD_EXP 24
7941: PPUSH
7942: LD_STRING DKam-4-radio
7944: PPUSH
7945: CALL_OW 88
// trap := 1 ;
7949: LD_ADDR_EXP 15
7953: PUSH
7954: LD_INT 1
7956: ST_TO_ADDR
// end else
7957: GO 8058
// begin Say ( Sophia , DS-1-radio ) ;
7959: LD_EXP 27
7963: PPUSH
7964: LD_STRING DS-1-radio
7966: PPUSH
7967: CALL_OW 88
// Say ( Sophia , DS-2-radio ) ;
7971: LD_EXP 27
7975: PPUSH
7976: LD_STRING DS-2-radio
7978: PPUSH
7979: CALL_OW 88
// SayRadio ( Lynch , DDelta-2-radio-s ) ;
7983: LD_EXP 18
7987: PPUSH
7988: LD_STRING DDelta-2-radio-s
7990: PPUSH
7991: CALL_OW 94
// Say ( Sophia , DS-3-radio ) ;
7995: LD_EXP 27
7999: PPUSH
8000: LD_STRING DS-3-radio
8002: PPUSH
8003: CALL_OW 88
// SayRadio ( Lynch , DDelta-3-radio-s ) ;
8007: LD_EXP 18
8011: PPUSH
8012: LD_STRING DDelta-3-radio-s
8014: PPUSH
8015: CALL_OW 94
// Say ( Sophia , DS-4-radio-s ) ;
8019: LD_EXP 27
8023: PPUSH
8024: LD_STRING DS-4-radio-s
8026: PPUSH
8027: CALL_OW 88
// dwait ( 0 0$01 ) ;
8031: LD_INT 35
8033: PPUSH
8034: CALL_OW 68
// Say ( Heike , DH-1-trap ) ;
8038: LD_EXP 21
8042: PPUSH
8043: LD_STRING DH-1-trap
8045: PPUSH
8046: CALL_OW 88
// trap := 0 ;
8050: LD_ADDR_EXP 15
8054: PUSH
8055: LD_INT 0
8057: ST_TO_ADDR
// end ; DialogueOff ;
8058: CALL_OW 7
// end ; 2 :
8062: GO 8082
8064: LD_INT 2
8066: DOUBLE
8067: EQUAL
8068: IFTRUE 8072
8070: GO 8081
8072: POP
// begin DialogueOff ;
8073: CALL_OW 7
// exit ;
8077: GO 8971
// end ; end ;
8079: GO 8082
8081: POP
// if trap = 1 then
8082: LD_EXP 15
8086: PUSH
8087: LD_INT 1
8089: EQUAL
8090: IFFALSE 8542
// begin PlaceSeeing ( 64 , 32 , 2 , 8 ) ;
8092: LD_INT 64
8094: PPUSH
8095: LD_INT 32
8097: PPUSH
8098: LD_INT 2
8100: PPUSH
8101: LD_INT 8
8103: PPUSH
8104: CALL_OW 330
// CenterOnXY ( 64 , 32 ) ;
8108: LD_INT 64
8110: PPUSH
8111: LD_INT 32
8113: PPUSH
8114: CALL_OW 84
// tmp := [ ] ;
8118: LD_ADDR_VAR 0 3
8122: PUSH
8123: EMPTY
8124: ST_TO_ADDR
// k := 3 ;
8125: LD_ADDR_VAR 0 2
8129: PUSH
8130: LD_INT 3
8132: ST_TO_ADDR
// if usForces < 3 then
8133: LD_EXP 19
8137: PUSH
8138: LD_INT 3
8140: LESS
8141: IFFALSE 8153
// k := usForces ;
8143: LD_ADDR_VAR 0 2
8147: PUSH
8148: LD_EXP 19
8152: ST_TO_ADDR
// for i := 1 to k do
8153: LD_ADDR_VAR 0 1
8157: PUSH
8158: DOUBLE
8159: LD_INT 1
8161: DEC
8162: ST_TO_ADDR
8163: LD_VAR 0 2
8167: PUSH
8168: FOR_TO
8169: IFFALSE 8224
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8171: LD_ADDR_VAR 0 3
8175: PUSH
8176: LD_VAR 0 3
8180: PPUSH
8181: LD_VAR 0 3
8185: PUSH
8186: LD_INT 1
8188: PLUS
8189: PPUSH
8190: LD_EXP 19
8194: PUSH
8195: LD_INT 1
8197: ARRAY
8198: PPUSH
8199: CALL_OW 1
8203: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8204: LD_ADDR_EXP 19
8208: PUSH
8209: LD_EXP 19
8213: PPUSH
8214: LD_INT 1
8216: PPUSH
8217: CALL_OW 3
8221: ST_TO_ADDR
// end ;
8222: GO 8168
8224: POP
8225: POP
// usPatrol := tmp ;
8226: LD_ADDR_EXP 14
8230: PUSH
8231: LD_VAR 0 3
8235: ST_TO_ADDR
// for i in tmp do
8236: LD_ADDR_VAR 0 1
8240: PUSH
8241: LD_VAR 0 3
8245: PUSH
8246: FOR_IN
8247: IFFALSE 8377
// begin if IsInUnit ( i ) then
8249: LD_VAR 0 1
8253: PPUSH
8254: CALL_OW 310
8258: IFFALSE 8269
// ComExitBuilding ( i ) ;
8260: LD_VAR 0 1
8264: PPUSH
8265: CALL_OW 122
// AddComAgressiveMove ( i , 63 , 31 ) ;
8269: LD_VAR 0 1
8273: PPUSH
8274: LD_INT 63
8276: PPUSH
8277: LD_INT 31
8279: PPUSH
8280: CALL_OW 174
// AddComWait ( i , 0 0$2 ) ;
8284: LD_VAR 0 1
8288: PPUSH
8289: LD_INT 70
8291: PPUSH
8292: CALL_OW 202
// AddComAgressiveMove ( i , 103 , 43 ) ;
8296: LD_VAR 0 1
8300: PPUSH
8301: LD_INT 103
8303: PPUSH
8304: LD_INT 43
8306: PPUSH
8307: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8311: LD_VAR 0 1
8315: PPUSH
8316: LD_INT 105
8318: PPUSH
8319: CALL_OW 202
// if Difficulty > 1 then
8323: LD_OWVAR 67
8327: PUSH
8328: LD_INT 1
8330: GREATER
8331: IFFALSE 8348
// AddComAgressiveMove ( i , 114 , 69 ) ;
8333: LD_VAR 0 1
8337: PPUSH
8338: LD_INT 114
8340: PPUSH
8341: LD_INT 69
8343: PPUSH
8344: CALL_OW 174
// AddComWait ( i , 0 0$3 ) ;
8348: LD_VAR 0 1
8352: PPUSH
8353: LD_INT 105
8355: PPUSH
8356: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8360: LD_VAR 0 1
8364: PPUSH
8365: LD_INT 42
8367: PPUSH
8368: LD_INT 20
8370: PPUSH
8371: CALL_OW 174
// end ;
8375: GO 8246
8377: POP
8378: POP
// wait ( 0 0$5 ) ;
8379: LD_INT 175
8381: PPUSH
8382: CALL_OW 67
// RemoveSeeing ( 64 , 32 , 2 ) ;
8386: LD_INT 64
8388: PPUSH
8389: LD_INT 32
8391: PPUSH
8392: LD_INT 2
8394: PPUSH
8395: CALL_OW 331
// repeat wait ( 0 0$1 ) ;
8399: LD_INT 35
8401: PPUSH
8402: CALL_OW 67
// for i in tmp do
8406: LD_ADDR_VAR 0 1
8410: PUSH
8411: LD_VAR 0 3
8415: PUSH
8416: FOR_IN
8417: IFFALSE 8448
// if IsDead ( i ) then
8419: LD_VAR 0 1
8423: PPUSH
8424: CALL_OW 301
8428: IFFALSE 8446
// tmp := tmp diff i ;
8430: LD_ADDR_VAR 0 3
8434: PUSH
8435: LD_VAR 0 3
8439: PUSH
8440: LD_VAR 0 1
8444: DIFF
8445: ST_TO_ADDR
8446: GO 8416
8448: POP
8449: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8450: LD_VAR 0 3
8454: NOT
8455: PUSH
8456: LD_VAR 0 3
8460: PPUSH
8461: LD_INT 95
8463: PUSH
8464: LD_INT 7
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: PUSH
8471: LD_INT 3
8473: PUSH
8474: LD_INT 60
8476: PUSH
8477: EMPTY
8478: LIST
8479: PUSH
8480: EMPTY
8481: LIST
8482: LIST
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 72
8492: PUSH
8493: LD_VAR 0 3
8497: EQUAL
8498: OR
8499: IFFALSE 8399
// if tmp then
8501: LD_VAR 0 3
8505: IFFALSE 8532
// begin usPatrol := [ ] ;
8507: LD_ADDR_EXP 14
8511: PUSH
8512: EMPTY
8513: ST_TO_ADDR
// usForces := usForces union tmp ;
8514: LD_ADDR_EXP 19
8518: PUSH
8519: LD_EXP 19
8523: PUSH
8524: LD_VAR 0 3
8528: UNION
8529: ST_TO_ADDR
// end else
8530: GO 8540
// trickyMove := true ;
8532: LD_ADDR_EXP 13
8536: PUSH
8537: LD_INT 1
8539: ST_TO_ADDR
// end else
8540: GO 8971
// begin tmp := [ ] ;
8542: LD_ADDR_VAR 0 3
8546: PUSH
8547: EMPTY
8548: ST_TO_ADDR
// k := 4 ;
8549: LD_ADDR_VAR 0 2
8553: PUSH
8554: LD_INT 4
8556: ST_TO_ADDR
// if usForces < 4 then
8557: LD_EXP 19
8561: PUSH
8562: LD_INT 4
8564: LESS
8565: IFFALSE 8577
// k := usForces ;
8567: LD_ADDR_VAR 0 2
8571: PUSH
8572: LD_EXP 19
8576: ST_TO_ADDR
// for i := 1 to k do
8577: LD_ADDR_VAR 0 1
8581: PUSH
8582: DOUBLE
8583: LD_INT 1
8585: DEC
8586: ST_TO_ADDR
8587: LD_VAR 0 2
8591: PUSH
8592: FOR_TO
8593: IFFALSE 8648
// begin tmp := Replace ( tmp , tmp + 1 , usForces [ 1 ] ) ;
8595: LD_ADDR_VAR 0 3
8599: PUSH
8600: LD_VAR 0 3
8604: PPUSH
8605: LD_VAR 0 3
8609: PUSH
8610: LD_INT 1
8612: PLUS
8613: PPUSH
8614: LD_EXP 19
8618: PUSH
8619: LD_INT 1
8621: ARRAY
8622: PPUSH
8623: CALL_OW 1
8627: ST_TO_ADDR
// usForces := Delete ( usForces , 1 ) ;
8628: LD_ADDR_EXP 19
8632: PUSH
8633: LD_EXP 19
8637: PPUSH
8638: LD_INT 1
8640: PPUSH
8641: CALL_OW 3
8645: ST_TO_ADDR
// end ;
8646: GO 8592
8648: POP
8649: POP
// if Lynch then
8650: LD_EXP 18
8654: IFFALSE 8672
// tmp := tmp ^ Lynch ;
8656: LD_ADDR_VAR 0 3
8660: PUSH
8661: LD_VAR 0 3
8665: PUSH
8666: LD_EXP 18
8670: ADD
8671: ST_TO_ADDR
// usPatrol := tmp ;
8672: LD_ADDR_EXP 14
8676: PUSH
8677: LD_VAR 0 3
8681: ST_TO_ADDR
// for i in tmp do
8682: LD_ADDR_VAR 0 1
8686: PUSH
8687: LD_VAR 0 3
8691: PUSH
8692: FOR_IN
8693: IFFALSE 8786
// begin if IsInUnit ( i ) then
8695: LD_VAR 0 1
8699: PPUSH
8700: CALL_OW 310
8704: IFFALSE 8715
// ComExitBuilding ( i ) ;
8706: LD_VAR 0 1
8710: PPUSH
8711: CALL_OW 122
// AddComAgressiveMove ( i , 69 , 15 ) ;
8715: LD_VAR 0 1
8719: PPUSH
8720: LD_INT 69
8722: PPUSH
8723: LD_INT 15
8725: PPUSH
8726: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8730: LD_VAR 0 1
8734: PPUSH
8735: LD_INT 700
8737: PPUSH
8738: CALL_OW 202
// AddComAgressiveMove ( i , 55 , 43 ) ;
8742: LD_VAR 0 1
8746: PPUSH
8747: LD_INT 55
8749: PPUSH
8750: LD_INT 43
8752: PPUSH
8753: CALL_OW 174
// AddComWait ( i , 0 0$20 ) ;
8757: LD_VAR 0 1
8761: PPUSH
8762: LD_INT 700
8764: PPUSH
8765: CALL_OW 202
// AddComAgressiveMove ( i , 42 , 20 ) ;
8769: LD_VAR 0 1
8773: PPUSH
8774: LD_INT 42
8776: PPUSH
8777: LD_INT 20
8779: PPUSH
8780: CALL_OW 174
// end ;
8784: GO 8692
8786: POP
8787: POP
// repeat wait ( 0 0$1 ) ;
8788: LD_INT 35
8790: PPUSH
8791: CALL_OW 67
// for i in tmp do
8795: LD_ADDR_VAR 0 1
8799: PUSH
8800: LD_VAR 0 3
8804: PUSH
8805: FOR_IN
8806: IFFALSE 8837
// if IsDead ( i ) then
8808: LD_VAR 0 1
8812: PPUSH
8813: CALL_OW 301
8817: IFFALSE 8835
// tmp := tmp diff i ;
8819: LD_ADDR_VAR 0 3
8823: PUSH
8824: LD_VAR 0 3
8828: PUSH
8829: LD_VAR 0 1
8833: DIFF
8834: ST_TO_ADDR
8835: GO 8805
8837: POP
8838: POP
// until not tmp or UnitFilter ( tmp , [ [ f_inarea , deltaBaseArea ] , [ f_not , [ f_hastask ] ] ] ) = tmp ;
8839: LD_VAR 0 3
8843: NOT
8844: PUSH
8845: LD_VAR 0 3
8849: PPUSH
8850: LD_INT 95
8852: PUSH
8853: LD_INT 7
8855: PUSH
8856: EMPTY
8857: LIST
8858: LIST
8859: PUSH
8860: LD_INT 3
8862: PUSH
8863: LD_INT 60
8865: PUSH
8866: EMPTY
8867: LIST
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: PUSH
8873: EMPTY
8874: LIST
8875: LIST
8876: PPUSH
8877: CALL_OW 72
8881: PUSH
8882: LD_VAR 0 3
8886: EQUAL
8887: OR
8888: IFFALSE 8788
// if not tmp then
8890: LD_VAR 0 3
8894: NOT
8895: IFFALSE 8907
// trickyMove := true else
8897: LD_ADDR_EXP 13
8901: PUSH
8902: LD_INT 1
8904: ST_TO_ADDR
8905: GO 8914
// usPatrol := [ ] ;
8907: LD_ADDR_EXP 14
8911: PUSH
8912: EMPTY
8913: ST_TO_ADDR
// if tmp diff Lynch then
8914: LD_VAR 0 3
8918: PUSH
8919: LD_EXP 18
8923: DIFF
8924: IFFALSE 8948
// usForces := usForces union ( tmp diff Lynch ) ;
8926: LD_ADDR_EXP 19
8930: PUSH
8931: LD_EXP 19
8935: PUSH
8936: LD_VAR 0 3
8940: PUSH
8941: LD_EXP 18
8945: DIFF
8946: UNION
8947: ST_TO_ADDR
// if IsOk ( Lynch ) then
8948: LD_EXP 18
8952: PPUSH
8953: CALL_OW 302
8957: IFFALSE 8971
// ComEnterUnit ( Lynch , Delta ) ;
8959: LD_EXP 18
8963: PPUSH
8964: LD_INT 1
8966: PPUSH
8967: CALL_OW 120
// end ; end ; end ;
8971: PPOPN 3
8973: END
// every 0 0$1 trigger trickyMove do
8974: LD_EXP 13
8978: IFFALSE 8990
8980: GO 8982
8982: DISABLE
// SetAchievement ( ACH_TRAP ) ;
8983: LD_STRING ACH_TRAP
8985: PPUSH
8986: CALL_OW 543
8990: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 1 ] , [ f_type , unit_vehicle ] ] ) do
8991: LD_INT 22
8993: PUSH
8994: LD_INT 2
8996: PUSH
8997: EMPTY
8998: LIST
8999: LIST
9000: PUSH
9001: LD_INT 23
9003: PUSH
9004: LD_INT 1
9006: PUSH
9007: EMPTY
9008: LIST
9009: LIST
9010: PUSH
9011: LD_INT 21
9013: PUSH
9014: LD_INT 2
9016: PUSH
9017: EMPTY
9018: LIST
9019: LIST
9020: PUSH
9021: EMPTY
9022: LIST
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: IFFALSE 9042
9032: GO 9034
9034: DISABLE
// SetAchievement ( ACH_SCRAP ) ;
9035: LD_STRING ACH_SCRAP
9037: PPUSH
9038: CALL_OW 543
9042: END
// every 0 0$1 trigger UnitFilter ( usPatrol , [ f_see , 2 ] ) do
9043: LD_EXP 14
9047: PPUSH
9048: LD_INT 101
9050: PUSH
9051: LD_INT 2
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 72
9062: IFFALSE 9195
9064: GO 9066
9066: DISABLE
// begin if not trap then
9067: LD_EXP 15
9071: NOT
9072: IFFALSE 9100
// begin Say ( Heike , DH-2-trap ) ;
9074: LD_EXP 21
9078: PPUSH
9079: LD_STRING DH-2-trap
9081: PPUSH
9082: CALL_OW 88
// Say ( Mike , DM-2-trap ) ;
9086: LD_EXP 23
9090: PPUSH
9091: LD_STRING DM-2-trap
9093: PPUSH
9094: CALL_OW 88
// end else
9098: GO 9112
// begin Say ( Heike , DH-1-trap-a ) ;
9100: LD_EXP 21
9104: PPUSH
9105: LD_STRING DH-1-trap-a
9107: PPUSH
9108: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
9112: LD_INT 35
9114: PPUSH
9115: CALL_OW 67
// until trickyMove ;
9119: LD_EXP 13
9123: IFFALSE 9112
// Say ( Heike , DH-3-trap ) ;
9125: LD_EXP 21
9129: PPUSH
9130: LD_STRING DH-3-trap
9132: PPUSH
9133: CALL_OW 88
// if IsOk ( Givi ) and IsOk ( Kaia ) then
9137: LD_EXP 22
9141: PPUSH
9142: CALL_OW 302
9146: PUSH
9147: LD_EXP 26
9151: PPUSH
9152: CALL_OW 302
9156: AND
9157: IFFALSE 9195
// begin Say ( Givi , DG-3-trap ) ;
9159: LD_EXP 22
9163: PPUSH
9164: LD_STRING DG-3-trap
9166: PPUSH
9167: CALL_OW 88
// Say ( Kaia , DK-3-trap ) ;
9171: LD_EXP 26
9175: PPUSH
9176: LD_STRING DK-3-trap
9178: PPUSH
9179: CALL_OW 88
// Say ( Givi , DG-4-trap ) ;
9183: LD_EXP 22
9187: PPUSH
9188: LD_STRING DG-4-trap
9190: PPUSH
9191: CALL_OW 88
// end ; end ;
9195: END
// every 0 0$1 trigger GetSide ( Delta ) = 2 and attackDeltaAllowed do var i , tmp ;
9196: LD_INT 1
9198: PPUSH
9199: CALL_OW 255
9203: PUSH
9204: LD_INT 2
9206: EQUAL
9207: PUSH
9208: LD_EXP 12
9212: AND
9213: IFFALSE 9372
9215: GO 9217
9217: DISABLE
9218: LD_INT 0
9220: PPUSH
9221: PPUSH
// begin if not IsOk ( Kaia ) then
9222: LD_EXP 26
9226: PPUSH
9227: CALL_OW 302
9231: NOT
9232: IFFALSE 9236
// exit ;
9234: GO 9372
// if tick < 5 5$00 then
9236: LD_OWVAR 1
9240: PUSH
9241: LD_INT 10500
9243: LESS
9244: IFFALSE 9253
// SetAchievement ( ACH_DELTA ) ;
9246: LD_STRING ACH_DELTA
9248: PPUSH
9249: CALL_OW 543
// Say ( Kaia , DK-1-capture ) ;
9253: LD_EXP 26
9257: PPUSH
9258: LD_STRING DK-1-capture
9260: PPUSH
9261: CALL_OW 88
// Say ( Heike , DH-1-capture ) ;
9265: LD_EXP 21
9269: PPUSH
9270: LD_STRING DH-1-capture
9272: PPUSH
9273: CALL_OW 88
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
9277: LD_ADDR_VAR 0 2
9281: PUSH
9282: LD_INT 22
9284: PUSH
9285: LD_INT 1
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: PUSH
9292: LD_INT 25
9294: PUSH
9295: LD_INT 1
9297: PUSH
9298: EMPTY
9299: LIST
9300: LIST
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: PPUSH
9306: CALL_OW 69
9310: ST_TO_ADDR
// if not tmp then
9311: LD_VAR 0 2
9315: NOT
9316: IFFALSE 9320
// exit ;
9318: GO 9372
// for i in tmp do
9320: LD_ADDR_VAR 0 1
9324: PUSH
9325: LD_VAR 0 2
9329: PUSH
9330: FOR_IN
9331: IFFALSE 9370
// begin if IsInUnit ( i ) then
9333: LD_VAR 0 1
9337: PPUSH
9338: CALL_OW 310
9342: IFFALSE 9353
// ComExitBuilding ( i ) ;
9344: LD_VAR 0 1
9348: PPUSH
9349: CALL_OW 122
// AddComAgressiveMove ( i , 38 , 23 ) ;
9353: LD_VAR 0 1
9357: PPUSH
9358: LD_INT 38
9360: PPUSH
9361: LD_INT 23
9363: PPUSH
9364: CALL_OW 174
// end ;
9368: GO 9330
9370: POP
9371: POP
// end ;
9372: PPOPN 2
9374: END
// every 0 0$1 trigger GetSide ( usLab ) = 2 and attackDeltaAllowed do
9375: LD_INT 3
9377: PPUSH
9378: CALL_OW 255
9382: PUSH
9383: LD_INT 2
9385: EQUAL
9386: PUSH
9387: LD_EXP 12
9391: AND
9392: IFFALSE 9424
9394: GO 9396
9396: DISABLE
// begin DialogueOn ;
9397: CALL_OW 6
// Say ( Aviradze , DA-1-capture ) ;
9401: LD_EXP 25
9405: PPUSH
9406: LD_STRING DA-1-capture
9408: PPUSH
9409: CALL_OW 88
// DialogueOff ;
9413: CALL_OW 7
// ChangeMissionObjectives ( OTame ) ;
9417: LD_STRING OTame
9419: PPUSH
9420: CALL_OW 337
// end ;
9424: END
// every 0 0$1 trigger GetTech ( tech_ApeLang , 2 ) = state_researched and attackDeltaAllowed do
9425: LD_INT 1
9427: PPUSH
9428: LD_INT 2
9430: PPUSH
9431: CALL_OW 321
9435: PUSH
9436: LD_INT 2
9438: EQUAL
9439: PUSH
9440: LD_EXP 12
9444: AND
9445: IFFALSE 9592
9447: GO 9449
9449: DISABLE
// begin DialogueOn ;
9450: CALL_OW 6
// Say ( Aviradze , DA-1-ape ) ;
9454: LD_EXP 25
9458: PPUSH
9459: LD_STRING DA-1-ape
9461: PPUSH
9462: CALL_OW 88
// Say ( Heike , DH-1-ape ) ;
9466: LD_EXP 21
9470: PPUSH
9471: LD_STRING DH-1-ape
9473: PPUSH
9474: CALL_OW 88
// Say ( Aviradze , DA-2-ape ) ;
9478: LD_EXP 25
9482: PPUSH
9483: LD_STRING DA-2-ape
9485: PPUSH
9486: CALL_OW 88
// Say ( Aviradze , DA-3-ape ) ;
9490: LD_EXP 25
9494: PPUSH
9495: LD_STRING DA-3-ape
9497: PPUSH
9498: CALL_OW 88
// Say ( Heike , DH-3-ape ) ;
9502: LD_EXP 21
9506: PPUSH
9507: LD_STRING DH-3-ape
9509: PPUSH
9510: CALL_OW 88
// DialogueOff ;
9514: CALL_OW 7
// if FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) then
9518: LD_INT 22
9520: PUSH
9521: LD_INT 0
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PUSH
9528: LD_INT 25
9530: PUSH
9531: LD_INT 12
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: PPUSH
9542: CALL_OW 69
9546: IFFALSE 9558
// SpawnApeman ( forest , 2 ) ;
9548: LD_INT 1
9550: PPUSH
9551: LD_INT 2
9553: PPUSH
9554: CALL 452 0 2
// repeat wait ( 0 0$1 ) ;
9558: LD_INT 35
9560: PPUSH
9561: CALL_OW 67
// until FilterAllUnits ( [ f_class , class_apeman ] ) = 0 ;
9565: LD_INT 25
9567: PUSH
9568: LD_INT 12
9570: PUSH
9571: EMPTY
9572: LIST
9573: LIST
9574: PPUSH
9575: CALL_OW 69
9579: PUSH
9580: LD_INT 0
9582: EQUAL
9583: IFFALSE 9558
// YouLost ( Ape ) ;
9585: LD_STRING Ape
9587: PPUSH
9588: CALL_OW 104
// end ;
9592: END
// every 0 0$5 trigger lostCounter >= [ 3 , 2 , 2 ] [ Difficulty ] do
9593: LD_EXP 16
9597: PUSH
9598: LD_INT 3
9600: PUSH
9601: LD_INT 2
9603: PUSH
9604: LD_INT 2
9606: PUSH
9607: EMPTY
9608: LIST
9609: LIST
9610: LIST
9611: PUSH
9612: LD_OWVAR 67
9616: ARRAY
9617: GREATEREQUAL
9618: IFFALSE 9662
9620: GO 9622
9622: DISABLE
// begin DialogueOn ;
9623: CALL_OW 6
// Say ( Aviradze , DA-1-failure ) ;
9627: LD_EXP 25
9631: PPUSH
9632: LD_STRING DA-1-failure
9634: PPUSH
9635: CALL_OW 88
// Say ( Aviradze , DA-2-failure ) ;
9639: LD_EXP 25
9643: PPUSH
9644: LD_STRING DA-2-failure
9646: PPUSH
9647: CALL_OW 88
// YouLost ( Failure ) ;
9651: LD_STRING Failure
9653: PPUSH
9654: CALL_OW 104
// DialogueOff ;
9658: CALL_OW 7
// end ;
9662: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) and IsOk ( Aviradze ) and GetSide ( Aviradze ) = 2 do var tmp ;
9663: LD_INT 22
9665: PUSH
9666: LD_INT 2
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: PUSH
9673: LD_INT 23
9675: PUSH
9676: LD_INT 0
9678: PUSH
9679: EMPTY
9680: LIST
9681: LIST
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PPUSH
9687: CALL_OW 69
9691: PUSH
9692: LD_EXP 25
9696: PPUSH
9697: CALL_OW 302
9701: AND
9702: PUSH
9703: LD_EXP 25
9707: PPUSH
9708: CALL_OW 255
9712: PUSH
9713: LD_INT 2
9715: EQUAL
9716: AND
9717: IFFALSE 10463
9719: GO 9721
9721: DISABLE
9722: LD_INT 0
9724: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
9725: LD_ADDR_VAR 0 1
9729: PUSH
9730: LD_INT 22
9732: PUSH
9733: LD_INT 2
9735: PUSH
9736: EMPTY
9737: LIST
9738: LIST
9739: PUSH
9740: LD_INT 23
9742: PUSH
9743: LD_INT 0
9745: PUSH
9746: EMPTY
9747: LIST
9748: LIST
9749: PUSH
9750: EMPTY
9751: LIST
9752: LIST
9753: PPUSH
9754: CALL_OW 69
9758: ST_TO_ADDR
// InGameOn ;
9759: CALL_OW 8
// CenterNowOnUnits ( tmp ) ;
9763: LD_VAR 0 1
9767: PPUSH
9768: CALL_OW 87
// ComMoveUnit ( tmp , Aviradze ) ;
9772: LD_VAR 0 1
9776: PPUSH
9777: LD_EXP 25
9781: PPUSH
9782: CALL_OW 112
// ComTurnUnit ( Aviradze , tmp ) ;
9786: LD_EXP 25
9790: PPUSH
9791: LD_VAR 0 1
9795: PPUSH
9796: CALL_OW 119
// wait ( 0 0$1 ) ;
9800: LD_INT 35
9802: PPUSH
9803: CALL_OW 67
// Say ( Aviradze , DA-1-tame-a ) ;
9807: LD_EXP 25
9811: PPUSH
9812: LD_STRING DA-1-tame-a
9814: PPUSH
9815: CALL_OW 88
// if IsOk ( Mike ) then
9819: LD_EXP 23
9823: PPUSH
9824: CALL_OW 302
9828: IFFALSE 9866
// begin Say ( Mike , DM-1-tame-a ) ;
9830: LD_EXP 23
9834: PPUSH
9835: LD_STRING DM-1-tame-a
9837: PPUSH
9838: CALL_OW 88
// Say ( Sophia , DS-1-tame-a ) ;
9842: LD_EXP 27
9846: PPUSH
9847: LD_STRING DS-1-tame-a
9849: PPUSH
9850: CALL_OW 88
// Say ( Mike , DM-2-tame-a ) ;
9854: LD_EXP 23
9858: PPUSH
9859: LD_STRING DM-2-tame-a
9861: PPUSH
9862: CALL_OW 88
// end ; wait ( 0 0$3 ) ;
9866: LD_INT 105
9868: PPUSH
9869: CALL_OW 67
// PrepareFarmer ;
9873: CALL 11138 0 0
// CenterOnUnits ( Farmer ) ;
9877: LD_EXP 29
9881: PPUSH
9882: CALL_OW 85
// ComMoveXY ( Farmer , 105 , 59 ) ;
9886: LD_EXP 29
9890: PPUSH
9891: LD_INT 105
9893: PPUSH
9894: LD_INT 59
9896: PPUSH
9897: CALL_OW 111
// AddComHold ( Farmer ) ;
9901: LD_EXP 29
9905: PPUSH
9906: CALL_OW 200
// SayRadio ( Farmer , DF-1-end ) ;
9910: LD_EXP 29
9914: PPUSH
9915: LD_STRING DF-1-end
9917: PPUSH
9918: CALL_OW 94
// Say ( Aviradze , DA-1-end ) ;
9922: LD_EXP 25
9926: PPUSH
9927: LD_STRING DA-1-end
9929: PPUSH
9930: CALL_OW 88
// SayRadio ( Farmer , DF-2-end ) ;
9934: LD_EXP 29
9938: PPUSH
9939: LD_STRING DF-2-end
9941: PPUSH
9942: CALL_OW 94
// Say ( Aviradze , DA-2-end ) ;
9946: LD_EXP 25
9950: PPUSH
9951: LD_STRING DA-2-end
9953: PPUSH
9954: CALL_OW 88
// SayRadio ( Farmer , DF-3-end ) ;
9958: LD_EXP 29
9962: PPUSH
9963: LD_STRING DF-3-end
9965: PPUSH
9966: CALL_OW 94
// Say ( Heike , DH-3-end ) ;
9970: LD_EXP 21
9974: PPUSH
9975: LD_STRING DH-3-end
9977: PPUSH
9978: CALL_OW 88
// SayRadio ( Farmer , DF-4-end ) ;
9982: LD_EXP 29
9986: PPUSH
9987: LD_STRING DF-4-end
9989: PPUSH
9990: CALL_OW 94
// if tick <= [ 25 25$00 , 23 23$00 , 21 21$00 ] [ Difficulty ] then
9994: LD_OWVAR 1
9998: PUSH
9999: LD_INT 52500
10001: PUSH
10002: LD_INT 48300
10004: PUSH
10005: LD_INT 44100
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: LIST
10012: PUSH
10013: LD_OWVAR 67
10017: ARRAY
10018: LESSEQUAL
10019: IFFALSE 10033
// AddMedal ( med1 , 1 ) else
10021: LD_STRING med1
10023: PPUSH
10024: LD_INT 1
10026: PPUSH
10027: CALL_OW 101
10031: GO 10044
// AddMedal ( med1 , - 1 ) ;
10033: LD_STRING med1
10035: PPUSH
10036: LD_INT 1
10038: NEG
10039: PPUSH
10040: CALL_OW 101
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) = 0 then
10044: LD_INT 22
10046: PUSH
10047: LD_INT 1
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PUSH
10054: LD_INT 25
10056: PUSH
10057: LD_INT 4
10059: PUSH
10060: EMPTY
10061: LIST
10062: LIST
10063: PUSH
10064: EMPTY
10065: LIST
10066: LIST
10067: PPUSH
10068: CALL_OW 69
10072: PUSH
10073: LD_INT 0
10075: EQUAL
10076: IFFALSE 10090
// AddMedal ( med2 , 1 ) else
10078: LD_STRING med2
10080: PPUSH
10081: LD_INT 1
10083: PPUSH
10084: CALL_OW 101
10088: GO 10101
// AddMedal ( med2 , - 1 ) ;
10090: LD_STRING med2
10092: PPUSH
10093: LD_INT 1
10095: NEG
10096: PPUSH
10097: CALL_OW 101
// if trickyMove then
10101: LD_EXP 13
10105: IFFALSE 10119
// AddMedal ( med3 , 1 ) else
10107: LD_STRING med3
10109: PPUSH
10110: LD_INT 1
10112: PPUSH
10113: CALL_OW 101
10117: GO 10130
// AddMedal ( med3 , - 1 ) ;
10119: LD_STRING med3
10121: PPUSH
10122: LD_INT 1
10124: NEG
10125: PPUSH
10126: CALL_OW 101
// GiveMedals ( MAIN ) ;
10130: LD_STRING MAIN
10132: PPUSH
10133: CALL_OW 102
// SaveCharacters ( tmp , 02_ape ) ;
10137: LD_VAR 0 1
10141: PPUSH
10142: LD_STRING 02_ape
10144: PPUSH
10145: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_human ] ] ) ;
10149: LD_ADDR_VAR 0 1
10153: PUSH
10154: LD_INT 22
10156: PUSH
10157: LD_INT 2
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: PUSH
10164: LD_INT 23
10166: PUSH
10167: LD_INT 2
10169: PUSH
10170: EMPTY
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 21
10176: PUSH
10177: LD_INT 1
10179: PUSH
10180: EMPTY
10181: LIST
10182: LIST
10183: PUSH
10184: EMPTY
10185: LIST
10186: LIST
10187: LIST
10188: PPUSH
10189: CALL_OW 69
10193: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10194: LD_VAR 0 1
10198: PPUSH
10199: CALL_OW 43
// SaveCharacters ( Heike , 02_Heike ) ;
10203: LD_EXP 21
10207: PPUSH
10208: LD_STRING 02_Heike
10210: PPUSH
10211: CALL_OW 38
// SaveCharacters ( Aviradze , 02_Aviradze ) ;
10215: LD_EXP 25
10219: PPUSH
10220: LD_STRING 02_Aviradze
10222: PPUSH
10223: CALL_OW 38
// if Givi then
10227: LD_EXP 22
10231: IFFALSE 10245
// SaveCharacters ( Givi , 02_Givi ) ;
10233: LD_EXP 22
10237: PPUSH
10238: LD_STRING 02_Givi
10240: PPUSH
10241: CALL_OW 38
// if Mike then
10245: LD_EXP 23
10249: IFFALSE 10263
// SaveCharacters ( Mike , 02_Mike ) ;
10251: LD_EXP 23
10255: PPUSH
10256: LD_STRING 02_Mike
10258: PPUSH
10259: CALL_OW 38
// if Kamil then
10263: LD_EXP 24
10267: IFFALSE 10281
// SaveCharacters ( Kamil , 02_Kamil ) ;
10269: LD_EXP 24
10273: PPUSH
10274: LD_STRING 02_Kamil
10276: PPUSH
10277: CALL_OW 38
// if Kaia then
10281: LD_EXP 26
10285: IFFALSE 10299
// SaveCharacters ( Kaia , 02_Kaia ) ;
10287: LD_EXP 26
10291: PPUSH
10292: LD_STRING 02_Kaia
10294: PPUSH
10295: CALL_OW 38
// if Sophia then
10299: LD_EXP 27
10303: IFFALSE 10317
// SaveCharacters ( Sophia , 02_Sophia ) ;
10305: LD_EXP 27
10309: PPUSH
10310: LD_STRING 02_Sophia
10312: PPUSH
10313: CALL_OW 38
// if Markov then
10317: LD_EXP 28
10321: IFFALSE 10335
// SaveCharacters ( Markov , 02_Markov ) ;
10323: LD_EXP 28
10327: PPUSH
10328: LD_STRING 02_Markov
10330: PPUSH
10331: CALL_OW 38
// if tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] then
10335: LD_VAR 0 1
10339: PUSH
10340: LD_EXP 21
10344: PUSH
10345: LD_EXP 25
10349: PUSH
10350: LD_EXP 22
10354: PUSH
10355: LD_EXP 23
10359: PUSH
10360: LD_EXP 24
10364: PUSH
10365: LD_EXP 27
10369: PUSH
10370: LD_EXP 26
10374: PUSH
10375: LD_EXP 28
10379: PUSH
10380: EMPTY
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: LIST
10387: LIST
10388: LIST
10389: DIFF
10390: IFFALSE 10455
// SaveCharacters ( tmp diff [ Heike , Aviradze , Givi , Mike , Kamil , Sophia , Kaia , Markov ] , 02_others ) ;
10392: LD_VAR 0 1
10396: PUSH
10397: LD_EXP 21
10401: PUSH
10402: LD_EXP 25
10406: PUSH
10407: LD_EXP 22
10411: PUSH
10412: LD_EXP 23
10416: PUSH
10417: LD_EXP 24
10421: PUSH
10422: LD_EXP 27
10426: PUSH
10427: LD_EXP 26
10431: PUSH
10432: LD_EXP 28
10436: PUSH
10437: EMPTY
10438: LIST
10439: LIST
10440: LIST
10441: LIST
10442: LIST
10443: LIST
10444: LIST
10445: LIST
10446: DIFF
10447: PPUSH
10448: LD_STRING 02_others
10450: PPUSH
10451: CALL_OW 38
// YouWin ;
10455: CALL_OW 103
// InGameOff ;
10459: CALL_OW 9
// end ;
10463: PPOPN 1
10465: END
// every 0 0$1 trigger tick > timeUntilFarmer and aviradzeSpotted do
10466: LD_OWVAR 1
10470: PUSH
10471: LD_EXP 11
10475: GREATER
10476: PUSH
10477: LD_EXP 4
10481: AND
10482: IFFALSE 10522
10484: GO 10486
10486: DISABLE
// begin InGameOn ;
10487: CALL_OW 8
// PrepareFarmer ;
10491: CALL 11138 0 0
// CenterNowOnUnits ( Farmer ) ;
10495: LD_EXP 29
10499: PPUSH
10500: CALL_OW 87
// wait ( 0 0$2 ) ;
10504: LD_INT 70
10506: PPUSH
10507: CALL_OW 67
// YouLost ( Farmer ) ;
10511: LD_STRING Farmer
10513: PPUSH
10514: CALL_OW 104
// InGameOff ;
10518: CALL_OW 9
// end ; end_of_file
10522: END
// export Heike , Givi , Mike , Kamil , Aviradze , Kaia , Sophia , Markov , Farmer ; export function PrepareArabian ; var un , veh ; begin
10523: LD_INT 0
10525: PPUSH
10526: PPUSH
10527: PPUSH
// uc_side := 2 ;
10528: LD_ADDR_OWVAR 20
10532: PUSH
10533: LD_INT 2
10535: ST_TO_ADDR
// uc_nation := 2 ;
10536: LD_ADDR_OWVAR 21
10540: PUSH
10541: LD_INT 2
10543: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
10544: LD_ADDR_EXP 21
10548: PUSH
10549: LD_STRING Heike
10551: PPUSH
10552: LD_EXP 1
10556: NOT
10557: PPUSH
10558: LD_EXP 2
10562: PPUSH
10563: CALL 221 0 3
10567: ST_TO_ADDR
// PlaceUnitXY ( Heike , 83 , 72 , false ) ;
10568: LD_EXP 21
10572: PPUSH
10573: LD_INT 83
10575: PPUSH
10576: LD_INT 72
10578: PPUSH
10579: LD_INT 0
10581: PPUSH
10582: CALL_OW 48
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
10586: LD_ADDR_EXP 22
10590: PUSH
10591: LD_STRING Givi
10593: PPUSH
10594: LD_EXP 1
10598: NOT
10599: PPUSH
10600: LD_EXP 2
10604: PPUSH
10605: CALL 221 0 3
10609: ST_TO_ADDR
// if Givi then
10610: LD_EXP 22
10614: IFFALSE 10634
// PlaceUnitXY ( Givi , 87 , 76 , false ) ;
10616: LD_EXP 22
10620: PPUSH
10621: LD_INT 87
10623: PPUSH
10624: LD_INT 76
10626: PPUSH
10627: LD_INT 0
10629: PPUSH
10630: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
10634: LD_ADDR_EXP 23
10638: PUSH
10639: LD_STRING Mike
10641: PPUSH
10642: LD_EXP 1
10646: NOT
10647: PPUSH
10648: LD_EXP 2
10652: PPUSH
10653: CALL 221 0 3
10657: ST_TO_ADDR
// if Mike then
10658: LD_EXP 23
10662: IFFALSE 10682
// PlaceUnitXY ( Mike , 84 , 76 , false ) ;
10664: LD_EXP 23
10668: PPUSH
10669: LD_INT 84
10671: PPUSH
10672: LD_INT 76
10674: PPUSH
10675: LD_INT 0
10677: PPUSH
10678: CALL_OW 48
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
10682: LD_ADDR_EXP 24
10686: PUSH
10687: LD_STRING Kamil
10689: PPUSH
10690: LD_EXP 1
10694: NOT
10695: PPUSH
10696: LD_EXP 2
10700: PPUSH
10701: CALL 221 0 3
10705: ST_TO_ADDR
// if Kamil then
10706: LD_EXP 24
10710: IFFALSE 10730
// PlaceUnitXY ( Kamil , 85 , 78 , false ) ;
10712: LD_EXP 24
10716: PPUSH
10717: LD_INT 85
10719: PPUSH
10720: LD_INT 78
10722: PPUSH
10723: LD_INT 0
10725: PPUSH
10726: CALL_OW 48
// uc_side := 5 ;
10730: LD_ADDR_OWVAR 20
10734: PUSH
10735: LD_INT 5
10737: ST_TO_ADDR
// uc_nation := 2 ;
10738: LD_ADDR_OWVAR 21
10742: PUSH
10743: LD_INT 2
10745: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , false ,  ) ;
10746: LD_ADDR_EXP 25
10750: PUSH
10751: LD_STRING Aviradze
10753: PPUSH
10754: LD_INT 0
10756: PPUSH
10757: LD_STRING 
10759: PPUSH
10760: CALL 221 0 3
10764: ST_TO_ADDR
// PlaceUnitXY ( Aviradze , 106 , 38 , false ) ;
10765: LD_EXP 25
10769: PPUSH
10770: LD_INT 106
10772: PPUSH
10773: LD_INT 38
10775: PPUSH
10776: LD_INT 0
10778: PPUSH
10779: CALL_OW 48
// ComTurnXY ( Aviradze , 103 , 38 ) ;
10783: LD_EXP 25
10787: PPUSH
10788: LD_INT 103
10790: PPUSH
10791: LD_INT 38
10793: PPUSH
10794: CALL_OW 118
// Kaia := PrepareUnit ( Kaia , false ,  ) ;
10798: LD_ADDR_EXP 26
10802: PUSH
10803: LD_STRING Kaia
10805: PPUSH
10806: LD_INT 0
10808: PPUSH
10809: LD_STRING 
10811: PPUSH
10812: CALL 221 0 3
10816: ST_TO_ADDR
// PlaceUnitXY ( Kaia , 100 , 34 , false ) ;
10817: LD_EXP 26
10821: PPUSH
10822: LD_INT 100
10824: PPUSH
10825: LD_INT 34
10827: PPUSH
10828: LD_INT 0
10830: PPUSH
10831: CALL_OW 48
// ComTurnXY ( Kaia , 100 , 39 ) ;
10835: LD_EXP 26
10839: PPUSH
10840: LD_INT 100
10842: PPUSH
10843: LD_INT 39
10845: PPUSH
10846: CALL_OW 118
// Sophia := PrepareUnit ( Sophia , false ,  ) ;
10850: LD_ADDR_EXP 27
10854: PUSH
10855: LD_STRING Sophia
10857: PPUSH
10858: LD_INT 0
10860: PPUSH
10861: LD_STRING 
10863: PPUSH
10864: CALL 221 0 3
10868: ST_TO_ADDR
// PlaceUnitXY ( Sophia , 109 , 50 , false ) ;
10869: LD_EXP 27
10873: PPUSH
10874: LD_INT 109
10876: PPUSH
10877: LD_INT 50
10879: PPUSH
10880: LD_INT 0
10882: PPUSH
10883: CALL_OW 48
// ComTurnXY ( Sophia , 100 , 39 ) ;
10887: LD_EXP 27
10891: PPUSH
10892: LD_INT 100
10894: PPUSH
10895: LD_INT 39
10897: PPUSH
10898: CALL_OW 118
// Markov := PrepareUnit ( Markov , false ,  ) ;
10902: LD_ADDR_EXP 28
10906: PUSH
10907: LD_STRING Markov
10909: PPUSH
10910: LD_INT 0
10912: PPUSH
10913: LD_STRING 
10915: PPUSH
10916: CALL 221 0 3
10920: ST_TO_ADDR
// PrepareTank ( 5 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_heavy_machine_gun , [ 90 , 70 , 60 ] [ Difficulty ] ) ;
10921: LD_INT 5
10923: PPUSH
10924: LD_INT 3
10926: PPUSH
10927: LD_INT 21
10929: PPUSH
10930: LD_INT 1
10932: PPUSH
10933: LD_INT 1
10935: PPUSH
10936: LD_INT 42
10938: PPUSH
10939: LD_INT 90
10941: PUSH
10942: LD_INT 70
10944: PUSH
10945: LD_INT 60
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: LIST
10952: PUSH
10953: LD_OWVAR 67
10957: ARRAY
10958: PPUSH
10959: CALL 284 0 7
// veh := CreateVehicle ;
10963: LD_ADDR_VAR 0 3
10967: PUSH
10968: CALL_OW 45
10972: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10973: LD_VAR 0 3
10977: PPUSH
10978: LD_INT 4
10980: PPUSH
10981: CALL_OW 233
// PlaceUnitXY ( veh , 109 , 38 , false ) ;
10985: LD_VAR 0 3
10989: PPUSH
10990: LD_INT 109
10992: PPUSH
10993: LD_INT 38
10995: PPUSH
10996: LD_INT 0
10998: PPUSH
10999: CALL_OW 48
// PlaceHumanInUnit ( Markov , veh ) ;
11003: LD_EXP 28
11007: PPUSH
11008: LD_VAR 0 3
11012: PPUSH
11013: CALL_OW 52
// ComTurnUnit ( Kaia , Aviradze ) ;
11017: LD_EXP 26
11021: PPUSH
11022: LD_EXP 25
11026: PPUSH
11027: CALL_OW 119
// ComTurnUnit ( Aviradze , Kaia ) ;
11031: LD_EXP 25
11035: PPUSH
11036: LD_EXP 26
11040: PPUSH
11041: CALL_OW 119
// if not Givi or not Mike then
11045: LD_EXP 22
11049: NOT
11050: PUSH
11051: LD_EXP 23
11055: NOT
11056: OR
11057: IFFALSE 11133
// begin uc_nation := 2 ;
11059: LD_ADDR_OWVAR 21
11063: PUSH
11064: LD_INT 2
11066: ST_TO_ADDR
// uc_side := 5 ;
11067: LD_ADDR_OWVAR 20
11071: PUSH
11072: LD_INT 5
11074: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 1 ) ;
11075: LD_INT 1
11077: PPUSH
11078: LD_INT 1
11080: PPUSH
11081: LD_INT 1
11083: PPUSH
11084: CALL_OW 380
// un := CreateHuman ;
11088: LD_ADDR_VAR 0 2
11092: PUSH
11093: CALL_OW 44
11097: ST_TO_ADDR
// PlaceUnitXYR ( un , 112 , 40 , 3 , false ) ;
11098: LD_VAR 0 2
11102: PPUSH
11103: LD_INT 112
11105: PPUSH
11106: LD_INT 40
11108: PPUSH
11109: LD_INT 3
11111: PPUSH
11112: LD_INT 0
11114: PPUSH
11115: CALL_OW 50
// ComTurnUnit ( un , Aviradze ) ;
11119: LD_VAR 0 2
11123: PPUSH
11124: LD_EXP 25
11128: PPUSH
11129: CALL_OW 119
// end ; end ;
11133: LD_VAR 0 1
11137: RET
// export function PrepareFarmer ; var i ; begin
11138: LD_INT 0
11140: PPUSH
11141: PPUSH
// uc_side := 5 ;
11142: LD_ADDR_OWVAR 20
11146: PUSH
11147: LD_INT 5
11149: ST_TO_ADDR
// uc_nation := 2 ;
11150: LD_ADDR_OWVAR 21
11154: PUSH
11155: LD_INT 2
11157: ST_TO_ADDR
// Farmer := PrepareUnit ( Farmer , false ,  ) ;
11158: LD_ADDR_EXP 29
11162: PUSH
11163: LD_STRING Farmer
11165: PPUSH
11166: LD_INT 0
11168: PPUSH
11169: LD_STRING 
11171: PPUSH
11172: CALL 221 0 3
11176: ST_TO_ADDR
// PlaceUnitXY ( Farmer , 106 , 62 , false ) ;
11177: LD_EXP 29
11181: PPUSH
11182: LD_INT 106
11184: PPUSH
11185: LD_INT 62
11187: PPUSH
11188: LD_INT 0
11190: PPUSH
11191: CALL_OW 48
// for i := 1 to 5 do
11195: LD_ADDR_VAR 0 2
11199: PUSH
11200: DOUBLE
11201: LD_INT 1
11203: DEC
11204: ST_TO_ADDR
11205: LD_INT 5
11207: PUSH
11208: FOR_TO
11209: IFFALSE 11247
// begin PrepareHuman ( sex_male , 1 , 1 ) ;
11211: LD_INT 1
11213: PPUSH
11214: LD_INT 1
11216: PPUSH
11217: LD_INT 1
11219: PPUSH
11220: CALL_OW 380
// PlaceUnitXYR ( CreateHuman , 105 , 64 , 3 , false ) ;
11224: CALL_OW 44
11228: PPUSH
11229: LD_INT 105
11231: PPUSH
11232: LD_INT 64
11234: PPUSH
11235: LD_INT 3
11237: PPUSH
11238: LD_INT 0
11240: PPUSH
11241: CALL_OW 50
// end ;
11245: GO 11208
11247: POP
11248: POP
// end ; end_of_file
11249: LD_VAR 0 1
11253: RET
// every 2 2$20 + 0 0$10 do
11254: GO 11256
11256: DISABLE
// begin enable ;
11257: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , forest , true ) ;
11258: LD_INT 1
11260: PPUSH
11261: LD_INT 5
11263: PPUSH
11264: CALL_OW 12
11268: PPUSH
11269: LD_INT 1
11271: PPUSH
11272: LD_INT 1
11274: PPUSH
11275: CALL_OW 55
// if tick > 6 6$00 then
11279: LD_OWVAR 1
11283: PUSH
11284: LD_INT 12600
11286: GREATER
11287: IFFALSE 11290
// disable ;
11289: DISABLE
// end ; end_of_file
11290: END
// on UnitDestroyed ( un ) do begin if un = Heike then
11291: LD_VAR 0 1
11295: PUSH
11296: LD_EXP 21
11300: EQUAL
11301: IFFALSE 11310
// YouLost ( Heike ) ;
11303: LD_STRING Heike
11305: PPUSH
11306: CALL_OW 104
// if un = Aviradze then
11310: LD_VAR 0 1
11314: PUSH
11315: LD_EXP 25
11319: EQUAL
11320: IFFALSE 11329
// YouLost ( Aviradze ) ;
11322: LD_STRING Aviradze
11324: PPUSH
11325: CALL_OW 104
// if un = usLab then
11329: LD_VAR 0 1
11333: PUSH
11334: LD_INT 3
11336: EQUAL
11337: IFFALSE 11346
// YouLost ( Lab ) ;
11339: LD_STRING Lab
11341: PPUSH
11342: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) diff [ Heike , Aviradze ] and aviradzeSpotted then
11346: LD_VAR 0 1
11350: PUSH
11351: LD_INT 22
11353: PUSH
11354: LD_INT 2
11356: PUSH
11357: EMPTY
11358: LIST
11359: LIST
11360: PUSH
11361: LD_INT 21
11363: PUSH
11364: LD_INT 1
11366: PUSH
11367: EMPTY
11368: LIST
11369: LIST
11370: PUSH
11371: LD_INT 23
11373: PUSH
11374: LD_INT 2
11376: PUSH
11377: EMPTY
11378: LIST
11379: LIST
11380: PUSH
11381: EMPTY
11382: LIST
11383: LIST
11384: LIST
11385: PPUSH
11386: CALL_OW 69
11390: PUSH
11391: LD_EXP 21
11395: PUSH
11396: LD_EXP 25
11400: PUSH
11401: EMPTY
11402: LIST
11403: LIST
11404: DIFF
11405: IN
11406: PUSH
11407: LD_EXP 4
11411: AND
11412: IFFALSE 11428
// lostCounter := lostCounter + 1 ;
11414: LD_ADDR_EXP 16
11418: PUSH
11419: LD_EXP 16
11423: PUSH
11424: LD_INT 1
11426: PLUS
11427: ST_TO_ADDR
// end ;
11428: PPOPN 1
11430: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un in usSci and killerSide = 2 then
11431: LD_VAR 0 1
11435: PUSH
11436: LD_EXP 20
11440: IN
11441: PUSH
11442: LD_VAR 0 2
11446: PUSH
11447: LD_INT 2
11449: EQUAL
11450: AND
11451: IFFALSE 11483
// begin usSci := usSci diff un ;
11453: LD_ADDR_EXP 20
11457: PUSH
11458: LD_EXP 20
11462: PUSH
11463: LD_VAR 0 1
11467: DIFF
11468: ST_TO_ADDR
// sciCounterKill := sciCounterKill + 1 ;
11469: LD_ADDR_EXP 8
11473: PUSH
11474: LD_EXP 8
11478: PUSH
11479: LD_INT 1
11481: PLUS
11482: ST_TO_ADDR
// end ; end ;
11483: PPOPN 3
11485: END
// on Contact ( s1 , s2 ) do begin if s1 = 2 and s2 = 5 then
11486: LD_VAR 0 1
11490: PUSH
11491: LD_INT 2
11493: EQUAL
11494: PUSH
11495: LD_VAR 0 2
11499: PUSH
11500: LD_INT 5
11502: EQUAL
11503: AND
11504: IFFALSE 11513
// YouLost ( FriendlyFire ) ;
11506: LD_STRING FriendlyFire
11508: PPUSH
11509: CALL_OW 104
// end ; end_of_file
11513: PPOPN 2
11515: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
11516: GO 11518
11518: DISABLE
// begin ru_radar := 98 ;
11519: LD_ADDR_EXP 30
11523: PUSH
11524: LD_INT 98
11526: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
11527: LD_ADDR_EXP 31
11531: PUSH
11532: LD_INT 89
11534: ST_TO_ADDR
// us_hack := 99 ;
11535: LD_ADDR_EXP 32
11539: PUSH
11540: LD_INT 99
11542: ST_TO_ADDR
// us_artillery := 97 ;
11543: LD_ADDR_EXP 33
11547: PUSH
11548: LD_INT 97
11550: ST_TO_ADDR
// ar_bio_bomb := 91 ;
11551: LD_ADDR_EXP 34
11555: PUSH
11556: LD_INT 91
11558: ST_TO_ADDR
// tech_Artillery := 80 ;
11559: LD_ADDR_EXP 35
11563: PUSH
11564: LD_INT 80
11566: ST_TO_ADDR
// tech_RadMat := 81 ;
11567: LD_ADDR_EXP 36
11571: PUSH
11572: LD_INT 81
11574: ST_TO_ADDR
// tech_BasicTools := 82 ;
11575: LD_ADDR_EXP 37
11579: PUSH
11580: LD_INT 82
11582: ST_TO_ADDR
// tech_Cargo := 83 ;
11583: LD_ADDR_EXP 38
11587: PUSH
11588: LD_INT 83
11590: ST_TO_ADDR
// tech_Track := 84 ;
11591: LD_ADDR_EXP 39
11595: PUSH
11596: LD_INT 84
11598: ST_TO_ADDR
// tech_Crane := 85 ;
11599: LD_ADDR_EXP 40
11603: PUSH
11604: LD_INT 85
11606: ST_TO_ADDR
// tech_Bulldozer := 86 ;
11607: LD_ADDR_EXP 41
11611: PUSH
11612: LD_INT 86
11614: ST_TO_ADDR
// tech_Hovercraft := 87 ;
11615: LD_ADDR_EXP 42
11619: PUSH
11620: LD_INT 87
11622: ST_TO_ADDR
// end ; end_of_file end_of_file
11623: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
11624: GO 11626
11626: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11627: LD_STRING initStreamRollete();
11629: PPUSH
11630: CALL_OW 559
// InitStreamMode ;
11634: CALL 11643 0 0
// DefineStreamItems ( ) ;
11638: CALL 12083 0 0
// end ;
11642: END
// function InitStreamMode ; begin
11643: LD_INT 0
11645: PPUSH
// streamModeActive := false ;
11646: LD_ADDR_EXP 43
11650: PUSH
11651: LD_INT 0
11653: ST_TO_ADDR
// normalCounter := 36 ;
11654: LD_ADDR_EXP 44
11658: PUSH
11659: LD_INT 36
11661: ST_TO_ADDR
// hardcoreCounter := 16 ;
11662: LD_ADDR_EXP 45
11666: PUSH
11667: LD_INT 16
11669: ST_TO_ADDR
// sRocket := false ;
11670: LD_ADDR_EXP 48
11674: PUSH
11675: LD_INT 0
11677: ST_TO_ADDR
// sSpeed := false ;
11678: LD_ADDR_EXP 47
11682: PUSH
11683: LD_INT 0
11685: ST_TO_ADDR
// sEngine := false ;
11686: LD_ADDR_EXP 49
11690: PUSH
11691: LD_INT 0
11693: ST_TO_ADDR
// sSpec := false ;
11694: LD_ADDR_EXP 46
11698: PUSH
11699: LD_INT 0
11701: ST_TO_ADDR
// sLevel := false ;
11702: LD_ADDR_EXP 50
11706: PUSH
11707: LD_INT 0
11709: ST_TO_ADDR
// sArmoury := false ;
11710: LD_ADDR_EXP 51
11714: PUSH
11715: LD_INT 0
11717: ST_TO_ADDR
// sRadar := false ;
11718: LD_ADDR_EXP 52
11722: PUSH
11723: LD_INT 0
11725: ST_TO_ADDR
// sBunker := false ;
11726: LD_ADDR_EXP 53
11730: PUSH
11731: LD_INT 0
11733: ST_TO_ADDR
// sHack := false ;
11734: LD_ADDR_EXP 54
11738: PUSH
11739: LD_INT 0
11741: ST_TO_ADDR
// sFire := false ;
11742: LD_ADDR_EXP 55
11746: PUSH
11747: LD_INT 0
11749: ST_TO_ADDR
// sRefresh := false ;
11750: LD_ADDR_EXP 56
11754: PUSH
11755: LD_INT 0
11757: ST_TO_ADDR
// sExp := false ;
11758: LD_ADDR_EXP 57
11762: PUSH
11763: LD_INT 0
11765: ST_TO_ADDR
// sDepot := false ;
11766: LD_ADDR_EXP 58
11770: PUSH
11771: LD_INT 0
11773: ST_TO_ADDR
// sFlag := false ;
11774: LD_ADDR_EXP 59
11778: PUSH
11779: LD_INT 0
11781: ST_TO_ADDR
// sKamikadze := false ;
11782: LD_ADDR_EXP 67
11786: PUSH
11787: LD_INT 0
11789: ST_TO_ADDR
// sTroll := false ;
11790: LD_ADDR_EXP 68
11794: PUSH
11795: LD_INT 0
11797: ST_TO_ADDR
// sSlow := false ;
11798: LD_ADDR_EXP 69
11802: PUSH
11803: LD_INT 0
11805: ST_TO_ADDR
// sLack := false ;
11806: LD_ADDR_EXP 70
11810: PUSH
11811: LD_INT 0
11813: ST_TO_ADDR
// sTank := false ;
11814: LD_ADDR_EXP 72
11818: PUSH
11819: LD_INT 0
11821: ST_TO_ADDR
// sRemote := false ;
11822: LD_ADDR_EXP 73
11826: PUSH
11827: LD_INT 0
11829: ST_TO_ADDR
// sPowell := false ;
11830: LD_ADDR_EXP 74
11834: PUSH
11835: LD_INT 0
11837: ST_TO_ADDR
// sTeleport := false ;
11838: LD_ADDR_EXP 77
11842: PUSH
11843: LD_INT 0
11845: ST_TO_ADDR
// sOilTower := false ;
11846: LD_ADDR_EXP 79
11850: PUSH
11851: LD_INT 0
11853: ST_TO_ADDR
// sShovel := false ;
11854: LD_ADDR_EXP 80
11858: PUSH
11859: LD_INT 0
11861: ST_TO_ADDR
// sSheik := false ;
11862: LD_ADDR_EXP 81
11866: PUSH
11867: LD_INT 0
11869: ST_TO_ADDR
// sEarthquake := false ;
11870: LD_ADDR_EXP 83
11874: PUSH
11875: LD_INT 0
11877: ST_TO_ADDR
// sAI := false ;
11878: LD_ADDR_EXP 84
11882: PUSH
11883: LD_INT 0
11885: ST_TO_ADDR
// sCargo := false ;
11886: LD_ADDR_EXP 87
11890: PUSH
11891: LD_INT 0
11893: ST_TO_ADDR
// sDLaser := false ;
11894: LD_ADDR_EXP 88
11898: PUSH
11899: LD_INT 0
11901: ST_TO_ADDR
// sExchange := false ;
11902: LD_ADDR_EXP 89
11906: PUSH
11907: LD_INT 0
11909: ST_TO_ADDR
// sFac := false ;
11910: LD_ADDR_EXP 90
11914: PUSH
11915: LD_INT 0
11917: ST_TO_ADDR
// sPower := false ;
11918: LD_ADDR_EXP 91
11922: PUSH
11923: LD_INT 0
11925: ST_TO_ADDR
// sRandom := false ;
11926: LD_ADDR_EXP 92
11930: PUSH
11931: LD_INT 0
11933: ST_TO_ADDR
// sShield := false ;
11934: LD_ADDR_EXP 93
11938: PUSH
11939: LD_INT 0
11941: ST_TO_ADDR
// sTime := false ;
11942: LD_ADDR_EXP 94
11946: PUSH
11947: LD_INT 0
11949: ST_TO_ADDR
// sTools := false ;
11950: LD_ADDR_EXP 95
11954: PUSH
11955: LD_INT 0
11957: ST_TO_ADDR
// sSold := false ;
11958: LD_ADDR_EXP 60
11962: PUSH
11963: LD_INT 0
11965: ST_TO_ADDR
// sDiff := false ;
11966: LD_ADDR_EXP 61
11970: PUSH
11971: LD_INT 0
11973: ST_TO_ADDR
// sFog := false ;
11974: LD_ADDR_EXP 64
11978: PUSH
11979: LD_INT 0
11981: ST_TO_ADDR
// sReset := false ;
11982: LD_ADDR_EXP 65
11986: PUSH
11987: LD_INT 0
11989: ST_TO_ADDR
// sSun := false ;
11990: LD_ADDR_EXP 66
11994: PUSH
11995: LD_INT 0
11997: ST_TO_ADDR
// sTiger := false ;
11998: LD_ADDR_EXP 62
12002: PUSH
12003: LD_INT 0
12005: ST_TO_ADDR
// sBomb := false ;
12006: LD_ADDR_EXP 63
12010: PUSH
12011: LD_INT 0
12013: ST_TO_ADDR
// sWound := false ;
12014: LD_ADDR_EXP 71
12018: PUSH
12019: LD_INT 0
12021: ST_TO_ADDR
// sBetray := false ;
12022: LD_ADDR_EXP 75
12026: PUSH
12027: LD_INT 0
12029: ST_TO_ADDR
// sContamin := false ;
12030: LD_ADDR_EXP 76
12034: PUSH
12035: LD_INT 0
12037: ST_TO_ADDR
// sOil := false ;
12038: LD_ADDR_EXP 78
12042: PUSH
12043: LD_INT 0
12045: ST_TO_ADDR
// sStu := false ;
12046: LD_ADDR_EXP 82
12050: PUSH
12051: LD_INT 0
12053: ST_TO_ADDR
// sBazooka := false ;
12054: LD_ADDR_EXP 85
12058: PUSH
12059: LD_INT 0
12061: ST_TO_ADDR
// sMortar := false ;
12062: LD_ADDR_EXP 86
12066: PUSH
12067: LD_INT 0
12069: ST_TO_ADDR
// sRanger := false ;
12070: LD_ADDR_EXP 96
12074: PUSH
12075: LD_INT 0
12077: ST_TO_ADDR
// end ;
12078: LD_VAR 0 1
12082: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
12083: LD_INT 0
12085: PPUSH
12086: PPUSH
12087: PPUSH
12088: PPUSH
12089: PPUSH
// result := [ ] ;
12090: LD_ADDR_VAR 0 1
12094: PUSH
12095: EMPTY
12096: ST_TO_ADDR
// if campaign_id = 1 then
12097: LD_OWVAR 69
12101: PUSH
12102: LD_INT 1
12104: EQUAL
12105: IFFALSE 15043
// begin case mission_number of 1 :
12107: LD_OWVAR 70
12111: PUSH
12112: LD_INT 1
12114: DOUBLE
12115: EQUAL
12116: IFTRUE 12120
12118: GO 12184
12120: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
12121: LD_ADDR_VAR 0 1
12125: PUSH
12126: LD_INT 2
12128: PUSH
12129: LD_INT 4
12131: PUSH
12132: LD_INT 11
12134: PUSH
12135: LD_INT 12
12137: PUSH
12138: LD_INT 15
12140: PUSH
12141: LD_INT 16
12143: PUSH
12144: LD_INT 22
12146: PUSH
12147: LD_INT 23
12149: PUSH
12150: LD_INT 26
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: LIST
12163: PUSH
12164: LD_INT 101
12166: PUSH
12167: LD_INT 102
12169: PUSH
12170: LD_INT 106
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: LIST
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: ST_TO_ADDR
12182: GO 15041
12184: LD_INT 2
12186: DOUBLE
12187: EQUAL
12188: IFTRUE 12192
12190: GO 12264
12192: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
12193: LD_ADDR_VAR 0 1
12197: PUSH
12198: LD_INT 2
12200: PUSH
12201: LD_INT 4
12203: PUSH
12204: LD_INT 11
12206: PUSH
12207: LD_INT 12
12209: PUSH
12210: LD_INT 15
12212: PUSH
12213: LD_INT 16
12215: PUSH
12216: LD_INT 22
12218: PUSH
12219: LD_INT 23
12221: PUSH
12222: LD_INT 26
12224: PUSH
12225: EMPTY
12226: LIST
12227: LIST
12228: LIST
12229: LIST
12230: LIST
12231: LIST
12232: LIST
12233: LIST
12234: LIST
12235: PUSH
12236: LD_INT 101
12238: PUSH
12239: LD_INT 102
12241: PUSH
12242: LD_INT 105
12244: PUSH
12245: LD_INT 106
12247: PUSH
12248: LD_INT 108
12250: PUSH
12251: EMPTY
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: LIST
12257: PUSH
12258: EMPTY
12259: LIST
12260: LIST
12261: ST_TO_ADDR
12262: GO 15041
12264: LD_INT 3
12266: DOUBLE
12267: EQUAL
12268: IFTRUE 12272
12270: GO 12348
12272: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
12273: LD_ADDR_VAR 0 1
12277: PUSH
12278: LD_INT 2
12280: PUSH
12281: LD_INT 4
12283: PUSH
12284: LD_INT 5
12286: PUSH
12287: LD_INT 11
12289: PUSH
12290: LD_INT 12
12292: PUSH
12293: LD_INT 15
12295: PUSH
12296: LD_INT 16
12298: PUSH
12299: LD_INT 22
12301: PUSH
12302: LD_INT 26
12304: PUSH
12305: LD_INT 36
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: PUSH
12320: LD_INT 101
12322: PUSH
12323: LD_INT 102
12325: PUSH
12326: LD_INT 105
12328: PUSH
12329: LD_INT 106
12331: PUSH
12332: LD_INT 108
12334: PUSH
12335: EMPTY
12336: LIST
12337: LIST
12338: LIST
12339: LIST
12340: LIST
12341: PUSH
12342: EMPTY
12343: LIST
12344: LIST
12345: ST_TO_ADDR
12346: GO 15041
12348: LD_INT 4
12350: DOUBLE
12351: EQUAL
12352: IFTRUE 12356
12354: GO 12440
12356: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
12357: LD_ADDR_VAR 0 1
12361: PUSH
12362: LD_INT 2
12364: PUSH
12365: LD_INT 4
12367: PUSH
12368: LD_INT 5
12370: PUSH
12371: LD_INT 8
12373: PUSH
12374: LD_INT 11
12376: PUSH
12377: LD_INT 12
12379: PUSH
12380: LD_INT 15
12382: PUSH
12383: LD_INT 16
12385: PUSH
12386: LD_INT 22
12388: PUSH
12389: LD_INT 23
12391: PUSH
12392: LD_INT 26
12394: PUSH
12395: LD_INT 36
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: LIST
12409: LIST
12410: LIST
12411: PUSH
12412: LD_INT 101
12414: PUSH
12415: LD_INT 102
12417: PUSH
12418: LD_INT 105
12420: PUSH
12421: LD_INT 106
12423: PUSH
12424: LD_INT 108
12426: PUSH
12427: EMPTY
12428: LIST
12429: LIST
12430: LIST
12431: LIST
12432: LIST
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: ST_TO_ADDR
12438: GO 15041
12440: LD_INT 5
12442: DOUBLE
12443: EQUAL
12444: IFTRUE 12448
12446: GO 12548
12448: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
12449: LD_ADDR_VAR 0 1
12453: PUSH
12454: LD_INT 2
12456: PUSH
12457: LD_INT 4
12459: PUSH
12460: LD_INT 5
12462: PUSH
12463: LD_INT 6
12465: PUSH
12466: LD_INT 8
12468: PUSH
12469: LD_INT 11
12471: PUSH
12472: LD_INT 12
12474: PUSH
12475: LD_INT 15
12477: PUSH
12478: LD_INT 16
12480: PUSH
12481: LD_INT 22
12483: PUSH
12484: LD_INT 23
12486: PUSH
12487: LD_INT 25
12489: PUSH
12490: LD_INT 26
12492: PUSH
12493: LD_INT 36
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: LIST
12511: PUSH
12512: LD_INT 101
12514: PUSH
12515: LD_INT 102
12517: PUSH
12518: LD_INT 105
12520: PUSH
12521: LD_INT 106
12523: PUSH
12524: LD_INT 108
12526: PUSH
12527: LD_INT 109
12529: PUSH
12530: LD_INT 112
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: LIST
12537: LIST
12538: LIST
12539: LIST
12540: LIST
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: ST_TO_ADDR
12546: GO 15041
12548: LD_INT 6
12550: DOUBLE
12551: EQUAL
12552: IFTRUE 12556
12554: GO 12676
12556: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
12557: LD_ADDR_VAR 0 1
12561: PUSH
12562: LD_INT 2
12564: PUSH
12565: LD_INT 4
12567: PUSH
12568: LD_INT 5
12570: PUSH
12571: LD_INT 6
12573: PUSH
12574: LD_INT 8
12576: PUSH
12577: LD_INT 11
12579: PUSH
12580: LD_INT 12
12582: PUSH
12583: LD_INT 15
12585: PUSH
12586: LD_INT 16
12588: PUSH
12589: LD_INT 20
12591: PUSH
12592: LD_INT 21
12594: PUSH
12595: LD_INT 22
12597: PUSH
12598: LD_INT 23
12600: PUSH
12601: LD_INT 25
12603: PUSH
12604: LD_INT 26
12606: PUSH
12607: LD_INT 30
12609: PUSH
12610: LD_INT 31
12612: PUSH
12613: LD_INT 32
12615: PUSH
12616: LD_INT 36
12618: PUSH
12619: EMPTY
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: LIST
12632: LIST
12633: LIST
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: LIST
12639: PUSH
12640: LD_INT 101
12642: PUSH
12643: LD_INT 102
12645: PUSH
12646: LD_INT 105
12648: PUSH
12649: LD_INT 106
12651: PUSH
12652: LD_INT 108
12654: PUSH
12655: LD_INT 109
12657: PUSH
12658: LD_INT 112
12660: PUSH
12661: EMPTY
12662: LIST
12663: LIST
12664: LIST
12665: LIST
12666: LIST
12667: LIST
12668: LIST
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: ST_TO_ADDR
12674: GO 15041
12676: LD_INT 7
12678: DOUBLE
12679: EQUAL
12680: IFTRUE 12684
12682: GO 12784
12684: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12685: LD_ADDR_VAR 0 1
12689: PUSH
12690: LD_INT 2
12692: PUSH
12693: LD_INT 4
12695: PUSH
12696: LD_INT 5
12698: PUSH
12699: LD_INT 7
12701: PUSH
12702: LD_INT 11
12704: PUSH
12705: LD_INT 12
12707: PUSH
12708: LD_INT 15
12710: PUSH
12711: LD_INT 16
12713: PUSH
12714: LD_INT 20
12716: PUSH
12717: LD_INT 21
12719: PUSH
12720: LD_INT 22
12722: PUSH
12723: LD_INT 23
12725: PUSH
12726: LD_INT 25
12728: PUSH
12729: LD_INT 26
12731: PUSH
12732: EMPTY
12733: LIST
12734: LIST
12735: LIST
12736: LIST
12737: LIST
12738: LIST
12739: LIST
12740: LIST
12741: LIST
12742: LIST
12743: LIST
12744: LIST
12745: LIST
12746: LIST
12747: PUSH
12748: LD_INT 101
12750: PUSH
12751: LD_INT 102
12753: PUSH
12754: LD_INT 103
12756: PUSH
12757: LD_INT 105
12759: PUSH
12760: LD_INT 106
12762: PUSH
12763: LD_INT 108
12765: PUSH
12766: LD_INT 112
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: ST_TO_ADDR
12782: GO 15041
12784: LD_INT 8
12786: DOUBLE
12787: EQUAL
12788: IFTRUE 12792
12790: GO 12920
12792: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12793: LD_ADDR_VAR 0 1
12797: PUSH
12798: LD_INT 2
12800: PUSH
12801: LD_INT 4
12803: PUSH
12804: LD_INT 5
12806: PUSH
12807: LD_INT 6
12809: PUSH
12810: LD_INT 7
12812: PUSH
12813: LD_INT 8
12815: PUSH
12816: LD_INT 11
12818: PUSH
12819: LD_INT 12
12821: PUSH
12822: LD_INT 15
12824: PUSH
12825: LD_INT 16
12827: PUSH
12828: LD_INT 20
12830: PUSH
12831: LD_INT 21
12833: PUSH
12834: LD_INT 22
12836: PUSH
12837: LD_INT 23
12839: PUSH
12840: LD_INT 25
12842: PUSH
12843: LD_INT 26
12845: PUSH
12846: LD_INT 30
12848: PUSH
12849: LD_INT 31
12851: PUSH
12852: LD_INT 32
12854: PUSH
12855: LD_INT 36
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: LIST
12862: LIST
12863: LIST
12864: LIST
12865: LIST
12866: LIST
12867: LIST
12868: LIST
12869: LIST
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: LIST
12878: LIST
12879: PUSH
12880: LD_INT 101
12882: PUSH
12883: LD_INT 102
12885: PUSH
12886: LD_INT 103
12888: PUSH
12889: LD_INT 105
12891: PUSH
12892: LD_INT 106
12894: PUSH
12895: LD_INT 108
12897: PUSH
12898: LD_INT 109
12900: PUSH
12901: LD_INT 112
12903: PUSH
12904: EMPTY
12905: LIST
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: LIST
12911: LIST
12912: LIST
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: ST_TO_ADDR
12918: GO 15041
12920: LD_INT 9
12922: DOUBLE
12923: EQUAL
12924: IFTRUE 12928
12926: GO 13064
12928: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12929: LD_ADDR_VAR 0 1
12933: PUSH
12934: LD_INT 2
12936: PUSH
12937: LD_INT 4
12939: PUSH
12940: LD_INT 5
12942: PUSH
12943: LD_INT 6
12945: PUSH
12946: LD_INT 7
12948: PUSH
12949: LD_INT 8
12951: PUSH
12952: LD_INT 11
12954: PUSH
12955: LD_INT 12
12957: PUSH
12958: LD_INT 15
12960: PUSH
12961: LD_INT 16
12963: PUSH
12964: LD_INT 20
12966: PUSH
12967: LD_INT 21
12969: PUSH
12970: LD_INT 22
12972: PUSH
12973: LD_INT 23
12975: PUSH
12976: LD_INT 25
12978: PUSH
12979: LD_INT 26
12981: PUSH
12982: LD_INT 28
12984: PUSH
12985: LD_INT 30
12987: PUSH
12988: LD_INT 31
12990: PUSH
12991: LD_INT 32
12993: PUSH
12994: LD_INT 36
12996: PUSH
12997: EMPTY
12998: LIST
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: LIST
13012: LIST
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: PUSH
13020: LD_INT 101
13022: PUSH
13023: LD_INT 102
13025: PUSH
13026: LD_INT 103
13028: PUSH
13029: LD_INT 105
13031: PUSH
13032: LD_INT 106
13034: PUSH
13035: LD_INT 108
13037: PUSH
13038: LD_INT 109
13040: PUSH
13041: LD_INT 112
13043: PUSH
13044: LD_INT 114
13046: PUSH
13047: EMPTY
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: LIST
13056: LIST
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: ST_TO_ADDR
13062: GO 15041
13064: LD_INT 10
13066: DOUBLE
13067: EQUAL
13068: IFTRUE 13072
13070: GO 13256
13072: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
13073: LD_ADDR_VAR 0 1
13077: PUSH
13078: LD_INT 2
13080: PUSH
13081: LD_INT 4
13083: PUSH
13084: LD_INT 5
13086: PUSH
13087: LD_INT 6
13089: PUSH
13090: LD_INT 7
13092: PUSH
13093: LD_INT 8
13095: PUSH
13096: LD_INT 9
13098: PUSH
13099: LD_INT 10
13101: PUSH
13102: LD_INT 11
13104: PUSH
13105: LD_INT 12
13107: PUSH
13108: LD_INT 13
13110: PUSH
13111: LD_INT 14
13113: PUSH
13114: LD_INT 15
13116: PUSH
13117: LD_INT 16
13119: PUSH
13120: LD_INT 17
13122: PUSH
13123: LD_INT 18
13125: PUSH
13126: LD_INT 19
13128: PUSH
13129: LD_INT 20
13131: PUSH
13132: LD_INT 21
13134: PUSH
13135: LD_INT 22
13137: PUSH
13138: LD_INT 23
13140: PUSH
13141: LD_INT 24
13143: PUSH
13144: LD_INT 25
13146: PUSH
13147: LD_INT 26
13149: PUSH
13150: LD_INT 28
13152: PUSH
13153: LD_INT 30
13155: PUSH
13156: LD_INT 31
13158: PUSH
13159: LD_INT 32
13161: PUSH
13162: LD_INT 36
13164: PUSH
13165: EMPTY
13166: LIST
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: LIST
13192: LIST
13193: LIST
13194: LIST
13195: PUSH
13196: LD_INT 101
13198: PUSH
13199: LD_INT 102
13201: PUSH
13202: LD_INT 103
13204: PUSH
13205: LD_INT 104
13207: PUSH
13208: LD_INT 105
13210: PUSH
13211: LD_INT 106
13213: PUSH
13214: LD_INT 107
13216: PUSH
13217: LD_INT 108
13219: PUSH
13220: LD_INT 109
13222: PUSH
13223: LD_INT 110
13225: PUSH
13226: LD_INT 111
13228: PUSH
13229: LD_INT 112
13231: PUSH
13232: LD_INT 114
13234: PUSH
13235: EMPTY
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: LIST
13244: LIST
13245: LIST
13246: LIST
13247: LIST
13248: LIST
13249: PUSH
13250: EMPTY
13251: LIST
13252: LIST
13253: ST_TO_ADDR
13254: GO 15041
13256: LD_INT 11
13258: DOUBLE
13259: EQUAL
13260: IFTRUE 13264
13262: GO 13456
13264: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
13265: LD_ADDR_VAR 0 1
13269: PUSH
13270: LD_INT 2
13272: PUSH
13273: LD_INT 3
13275: PUSH
13276: LD_INT 4
13278: PUSH
13279: LD_INT 5
13281: PUSH
13282: LD_INT 6
13284: PUSH
13285: LD_INT 7
13287: PUSH
13288: LD_INT 8
13290: PUSH
13291: LD_INT 9
13293: PUSH
13294: LD_INT 10
13296: PUSH
13297: LD_INT 11
13299: PUSH
13300: LD_INT 12
13302: PUSH
13303: LD_INT 13
13305: PUSH
13306: LD_INT 14
13308: PUSH
13309: LD_INT 15
13311: PUSH
13312: LD_INT 16
13314: PUSH
13315: LD_INT 17
13317: PUSH
13318: LD_INT 18
13320: PUSH
13321: LD_INT 19
13323: PUSH
13324: LD_INT 20
13326: PUSH
13327: LD_INT 21
13329: PUSH
13330: LD_INT 22
13332: PUSH
13333: LD_INT 23
13335: PUSH
13336: LD_INT 24
13338: PUSH
13339: LD_INT 25
13341: PUSH
13342: LD_INT 26
13344: PUSH
13345: LD_INT 28
13347: PUSH
13348: LD_INT 30
13350: PUSH
13351: LD_INT 31
13353: PUSH
13354: LD_INT 32
13356: PUSH
13357: LD_INT 34
13359: PUSH
13360: LD_INT 36
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: LIST
13367: LIST
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: LIST
13394: LIST
13395: PUSH
13396: LD_INT 101
13398: PUSH
13399: LD_INT 102
13401: PUSH
13402: LD_INT 103
13404: PUSH
13405: LD_INT 104
13407: PUSH
13408: LD_INT 105
13410: PUSH
13411: LD_INT 106
13413: PUSH
13414: LD_INT 107
13416: PUSH
13417: LD_INT 108
13419: PUSH
13420: LD_INT 109
13422: PUSH
13423: LD_INT 110
13425: PUSH
13426: LD_INT 111
13428: PUSH
13429: LD_INT 112
13431: PUSH
13432: LD_INT 114
13434: PUSH
13435: EMPTY
13436: LIST
13437: LIST
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: LIST
13448: LIST
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: ST_TO_ADDR
13454: GO 15041
13456: LD_INT 12
13458: DOUBLE
13459: EQUAL
13460: IFTRUE 13464
13462: GO 13672
13464: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
13465: LD_ADDR_VAR 0 1
13469: PUSH
13470: LD_INT 1
13472: PUSH
13473: LD_INT 2
13475: PUSH
13476: LD_INT 3
13478: PUSH
13479: LD_INT 4
13481: PUSH
13482: LD_INT 5
13484: PUSH
13485: LD_INT 6
13487: PUSH
13488: LD_INT 7
13490: PUSH
13491: LD_INT 8
13493: PUSH
13494: LD_INT 9
13496: PUSH
13497: LD_INT 10
13499: PUSH
13500: LD_INT 11
13502: PUSH
13503: LD_INT 12
13505: PUSH
13506: LD_INT 13
13508: PUSH
13509: LD_INT 14
13511: PUSH
13512: LD_INT 15
13514: PUSH
13515: LD_INT 16
13517: PUSH
13518: LD_INT 17
13520: PUSH
13521: LD_INT 18
13523: PUSH
13524: LD_INT 19
13526: PUSH
13527: LD_INT 20
13529: PUSH
13530: LD_INT 21
13532: PUSH
13533: LD_INT 22
13535: PUSH
13536: LD_INT 23
13538: PUSH
13539: LD_INT 24
13541: PUSH
13542: LD_INT 25
13544: PUSH
13545: LD_INT 26
13547: PUSH
13548: LD_INT 27
13550: PUSH
13551: LD_INT 28
13553: PUSH
13554: LD_INT 30
13556: PUSH
13557: LD_INT 31
13559: PUSH
13560: LD_INT 32
13562: PUSH
13563: LD_INT 33
13565: PUSH
13566: LD_INT 34
13568: PUSH
13569: LD_INT 36
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: LIST
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: LIST
13585: LIST
13586: LIST
13587: LIST
13588: LIST
13589: LIST
13590: LIST
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: LIST
13602: LIST
13603: LIST
13604: LIST
13605: LIST
13606: LIST
13607: PUSH
13608: LD_INT 101
13610: PUSH
13611: LD_INT 102
13613: PUSH
13614: LD_INT 103
13616: PUSH
13617: LD_INT 104
13619: PUSH
13620: LD_INT 105
13622: PUSH
13623: LD_INT 106
13625: PUSH
13626: LD_INT 107
13628: PUSH
13629: LD_INT 108
13631: PUSH
13632: LD_INT 109
13634: PUSH
13635: LD_INT 110
13637: PUSH
13638: LD_INT 111
13640: PUSH
13641: LD_INT 112
13643: PUSH
13644: LD_INT 113
13646: PUSH
13647: LD_INT 114
13649: PUSH
13650: EMPTY
13651: LIST
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: LIST
13657: LIST
13658: LIST
13659: LIST
13660: LIST
13661: LIST
13662: LIST
13663: LIST
13664: LIST
13665: PUSH
13666: EMPTY
13667: LIST
13668: LIST
13669: ST_TO_ADDR
13670: GO 15041
13672: LD_INT 13
13674: DOUBLE
13675: EQUAL
13676: IFTRUE 13680
13678: GO 13876
13680: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13681: LD_ADDR_VAR 0 1
13685: PUSH
13686: LD_INT 1
13688: PUSH
13689: LD_INT 2
13691: PUSH
13692: LD_INT 3
13694: PUSH
13695: LD_INT 4
13697: PUSH
13698: LD_INT 5
13700: PUSH
13701: LD_INT 8
13703: PUSH
13704: LD_INT 9
13706: PUSH
13707: LD_INT 10
13709: PUSH
13710: LD_INT 11
13712: PUSH
13713: LD_INT 12
13715: PUSH
13716: LD_INT 14
13718: PUSH
13719: LD_INT 15
13721: PUSH
13722: LD_INT 16
13724: PUSH
13725: LD_INT 17
13727: PUSH
13728: LD_INT 18
13730: PUSH
13731: LD_INT 19
13733: PUSH
13734: LD_INT 20
13736: PUSH
13737: LD_INT 21
13739: PUSH
13740: LD_INT 22
13742: PUSH
13743: LD_INT 23
13745: PUSH
13746: LD_INT 24
13748: PUSH
13749: LD_INT 25
13751: PUSH
13752: LD_INT 26
13754: PUSH
13755: LD_INT 27
13757: PUSH
13758: LD_INT 28
13760: PUSH
13761: LD_INT 30
13763: PUSH
13764: LD_INT 31
13766: PUSH
13767: LD_INT 32
13769: PUSH
13770: LD_INT 33
13772: PUSH
13773: LD_INT 34
13775: PUSH
13776: LD_INT 36
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: LIST
13785: LIST
13786: LIST
13787: LIST
13788: LIST
13789: LIST
13790: LIST
13791: LIST
13792: LIST
13793: LIST
13794: LIST
13795: LIST
13796: LIST
13797: LIST
13798: LIST
13799: LIST
13800: LIST
13801: LIST
13802: LIST
13803: LIST
13804: LIST
13805: LIST
13806: LIST
13807: LIST
13808: LIST
13809: LIST
13810: LIST
13811: PUSH
13812: LD_INT 101
13814: PUSH
13815: LD_INT 102
13817: PUSH
13818: LD_INT 103
13820: PUSH
13821: LD_INT 104
13823: PUSH
13824: LD_INT 105
13826: PUSH
13827: LD_INT 106
13829: PUSH
13830: LD_INT 107
13832: PUSH
13833: LD_INT 108
13835: PUSH
13836: LD_INT 109
13838: PUSH
13839: LD_INT 110
13841: PUSH
13842: LD_INT 111
13844: PUSH
13845: LD_INT 112
13847: PUSH
13848: LD_INT 113
13850: PUSH
13851: LD_INT 114
13853: PUSH
13854: EMPTY
13855: LIST
13856: LIST
13857: LIST
13858: LIST
13859: LIST
13860: LIST
13861: LIST
13862: LIST
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: ST_TO_ADDR
13874: GO 15041
13876: LD_INT 14
13878: DOUBLE
13879: EQUAL
13880: IFTRUE 13884
13882: GO 14096
13884: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13885: LD_ADDR_VAR 0 1
13889: PUSH
13890: LD_INT 1
13892: PUSH
13893: LD_INT 2
13895: PUSH
13896: LD_INT 3
13898: PUSH
13899: LD_INT 4
13901: PUSH
13902: LD_INT 5
13904: PUSH
13905: LD_INT 6
13907: PUSH
13908: LD_INT 7
13910: PUSH
13911: LD_INT 8
13913: PUSH
13914: LD_INT 9
13916: PUSH
13917: LD_INT 10
13919: PUSH
13920: LD_INT 11
13922: PUSH
13923: LD_INT 12
13925: PUSH
13926: LD_INT 13
13928: PUSH
13929: LD_INT 14
13931: PUSH
13932: LD_INT 15
13934: PUSH
13935: LD_INT 16
13937: PUSH
13938: LD_INT 17
13940: PUSH
13941: LD_INT 18
13943: PUSH
13944: LD_INT 19
13946: PUSH
13947: LD_INT 20
13949: PUSH
13950: LD_INT 21
13952: PUSH
13953: LD_INT 22
13955: PUSH
13956: LD_INT 23
13958: PUSH
13959: LD_INT 24
13961: PUSH
13962: LD_INT 25
13964: PUSH
13965: LD_INT 26
13967: PUSH
13968: LD_INT 27
13970: PUSH
13971: LD_INT 28
13973: PUSH
13974: LD_INT 29
13976: PUSH
13977: LD_INT 30
13979: PUSH
13980: LD_INT 31
13982: PUSH
13983: LD_INT 32
13985: PUSH
13986: LD_INT 33
13988: PUSH
13989: LD_INT 34
13991: PUSH
13992: LD_INT 36
13994: PUSH
13995: EMPTY
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: LIST
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: LIST
14006: LIST
14007: LIST
14008: LIST
14009: LIST
14010: LIST
14011: LIST
14012: LIST
14013: LIST
14014: LIST
14015: LIST
14016: LIST
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: LIST
14022: LIST
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: PUSH
14032: LD_INT 101
14034: PUSH
14035: LD_INT 102
14037: PUSH
14038: LD_INT 103
14040: PUSH
14041: LD_INT 104
14043: PUSH
14044: LD_INT 105
14046: PUSH
14047: LD_INT 106
14049: PUSH
14050: LD_INT 107
14052: PUSH
14053: LD_INT 108
14055: PUSH
14056: LD_INT 109
14058: PUSH
14059: LD_INT 110
14061: PUSH
14062: LD_INT 111
14064: PUSH
14065: LD_INT 112
14067: PUSH
14068: LD_INT 113
14070: PUSH
14071: LD_INT 114
14073: PUSH
14074: EMPTY
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: LIST
14080: LIST
14081: LIST
14082: LIST
14083: LIST
14084: LIST
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: PUSH
14090: EMPTY
14091: LIST
14092: LIST
14093: ST_TO_ADDR
14094: GO 15041
14096: LD_INT 15
14098: DOUBLE
14099: EQUAL
14100: IFTRUE 14104
14102: GO 14316
14104: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
14105: LD_ADDR_VAR 0 1
14109: PUSH
14110: LD_INT 1
14112: PUSH
14113: LD_INT 2
14115: PUSH
14116: LD_INT 3
14118: PUSH
14119: LD_INT 4
14121: PUSH
14122: LD_INT 5
14124: PUSH
14125: LD_INT 6
14127: PUSH
14128: LD_INT 7
14130: PUSH
14131: LD_INT 8
14133: PUSH
14134: LD_INT 9
14136: PUSH
14137: LD_INT 10
14139: PUSH
14140: LD_INT 11
14142: PUSH
14143: LD_INT 12
14145: PUSH
14146: LD_INT 13
14148: PUSH
14149: LD_INT 14
14151: PUSH
14152: LD_INT 15
14154: PUSH
14155: LD_INT 16
14157: PUSH
14158: LD_INT 17
14160: PUSH
14161: LD_INT 18
14163: PUSH
14164: LD_INT 19
14166: PUSH
14167: LD_INT 20
14169: PUSH
14170: LD_INT 21
14172: PUSH
14173: LD_INT 22
14175: PUSH
14176: LD_INT 23
14178: PUSH
14179: LD_INT 24
14181: PUSH
14182: LD_INT 25
14184: PUSH
14185: LD_INT 26
14187: PUSH
14188: LD_INT 27
14190: PUSH
14191: LD_INT 28
14193: PUSH
14194: LD_INT 29
14196: PUSH
14197: LD_INT 30
14199: PUSH
14200: LD_INT 31
14202: PUSH
14203: LD_INT 32
14205: PUSH
14206: LD_INT 33
14208: PUSH
14209: LD_INT 34
14211: PUSH
14212: LD_INT 36
14214: PUSH
14215: EMPTY
14216: LIST
14217: LIST
14218: LIST
14219: LIST
14220: LIST
14221: LIST
14222: LIST
14223: LIST
14224: LIST
14225: LIST
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: LIST
14240: LIST
14241: LIST
14242: LIST
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: LIST
14250: LIST
14251: PUSH
14252: LD_INT 101
14254: PUSH
14255: LD_INT 102
14257: PUSH
14258: LD_INT 103
14260: PUSH
14261: LD_INT 104
14263: PUSH
14264: LD_INT 105
14266: PUSH
14267: LD_INT 106
14269: PUSH
14270: LD_INT 107
14272: PUSH
14273: LD_INT 108
14275: PUSH
14276: LD_INT 109
14278: PUSH
14279: LD_INT 110
14281: PUSH
14282: LD_INT 111
14284: PUSH
14285: LD_INT 112
14287: PUSH
14288: LD_INT 113
14290: PUSH
14291: LD_INT 114
14293: PUSH
14294: EMPTY
14295: LIST
14296: LIST
14297: LIST
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: LIST
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: LIST
14308: LIST
14309: PUSH
14310: EMPTY
14311: LIST
14312: LIST
14313: ST_TO_ADDR
14314: GO 15041
14316: LD_INT 16
14318: DOUBLE
14319: EQUAL
14320: IFTRUE 14324
14322: GO 14448
14324: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
14325: LD_ADDR_VAR 0 1
14329: PUSH
14330: LD_INT 2
14332: PUSH
14333: LD_INT 4
14335: PUSH
14336: LD_INT 5
14338: PUSH
14339: LD_INT 7
14341: PUSH
14342: LD_INT 11
14344: PUSH
14345: LD_INT 12
14347: PUSH
14348: LD_INT 15
14350: PUSH
14351: LD_INT 16
14353: PUSH
14354: LD_INT 20
14356: PUSH
14357: LD_INT 21
14359: PUSH
14360: LD_INT 22
14362: PUSH
14363: LD_INT 23
14365: PUSH
14366: LD_INT 25
14368: PUSH
14369: LD_INT 26
14371: PUSH
14372: LD_INT 30
14374: PUSH
14375: LD_INT 31
14377: PUSH
14378: LD_INT 32
14380: PUSH
14381: LD_INT 33
14383: PUSH
14384: LD_INT 34
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: PUSH
14408: LD_INT 101
14410: PUSH
14411: LD_INT 102
14413: PUSH
14414: LD_INT 103
14416: PUSH
14417: LD_INT 106
14419: PUSH
14420: LD_INT 108
14422: PUSH
14423: LD_INT 112
14425: PUSH
14426: LD_INT 113
14428: PUSH
14429: LD_INT 114
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: LIST
14440: LIST
14441: PUSH
14442: EMPTY
14443: LIST
14444: LIST
14445: ST_TO_ADDR
14446: GO 15041
14448: LD_INT 17
14450: DOUBLE
14451: EQUAL
14452: IFTRUE 14456
14454: GO 14668
14456: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
14457: LD_ADDR_VAR 0 1
14461: PUSH
14462: LD_INT 1
14464: PUSH
14465: LD_INT 2
14467: PUSH
14468: LD_INT 3
14470: PUSH
14471: LD_INT 4
14473: PUSH
14474: LD_INT 5
14476: PUSH
14477: LD_INT 6
14479: PUSH
14480: LD_INT 7
14482: PUSH
14483: LD_INT 8
14485: PUSH
14486: LD_INT 9
14488: PUSH
14489: LD_INT 10
14491: PUSH
14492: LD_INT 11
14494: PUSH
14495: LD_INT 12
14497: PUSH
14498: LD_INT 13
14500: PUSH
14501: LD_INT 14
14503: PUSH
14504: LD_INT 15
14506: PUSH
14507: LD_INT 16
14509: PUSH
14510: LD_INT 17
14512: PUSH
14513: LD_INT 18
14515: PUSH
14516: LD_INT 19
14518: PUSH
14519: LD_INT 20
14521: PUSH
14522: LD_INT 21
14524: PUSH
14525: LD_INT 22
14527: PUSH
14528: LD_INT 23
14530: PUSH
14531: LD_INT 24
14533: PUSH
14534: LD_INT 25
14536: PUSH
14537: LD_INT 26
14539: PUSH
14540: LD_INT 27
14542: PUSH
14543: LD_INT 28
14545: PUSH
14546: LD_INT 29
14548: PUSH
14549: LD_INT 30
14551: PUSH
14552: LD_INT 31
14554: PUSH
14555: LD_INT 32
14557: PUSH
14558: LD_INT 33
14560: PUSH
14561: LD_INT 34
14563: PUSH
14564: LD_INT 36
14566: PUSH
14567: EMPTY
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: PUSH
14604: LD_INT 101
14606: PUSH
14607: LD_INT 102
14609: PUSH
14610: LD_INT 103
14612: PUSH
14613: LD_INT 104
14615: PUSH
14616: LD_INT 105
14618: PUSH
14619: LD_INT 106
14621: PUSH
14622: LD_INT 107
14624: PUSH
14625: LD_INT 108
14627: PUSH
14628: LD_INT 109
14630: PUSH
14631: LD_INT 110
14633: PUSH
14634: LD_INT 111
14636: PUSH
14637: LD_INT 112
14639: PUSH
14640: LD_INT 113
14642: PUSH
14643: LD_INT 114
14645: PUSH
14646: EMPTY
14647: LIST
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: LIST
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: ST_TO_ADDR
14666: GO 15041
14668: LD_INT 18
14670: DOUBLE
14671: EQUAL
14672: IFTRUE 14676
14674: GO 14812
14676: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14677: LD_ADDR_VAR 0 1
14681: PUSH
14682: LD_INT 2
14684: PUSH
14685: LD_INT 4
14687: PUSH
14688: LD_INT 5
14690: PUSH
14691: LD_INT 7
14693: PUSH
14694: LD_INT 11
14696: PUSH
14697: LD_INT 12
14699: PUSH
14700: LD_INT 15
14702: PUSH
14703: LD_INT 16
14705: PUSH
14706: LD_INT 20
14708: PUSH
14709: LD_INT 21
14711: PUSH
14712: LD_INT 22
14714: PUSH
14715: LD_INT 23
14717: PUSH
14718: LD_INT 25
14720: PUSH
14721: LD_INT 26
14723: PUSH
14724: LD_INT 30
14726: PUSH
14727: LD_INT 31
14729: PUSH
14730: LD_INT 32
14732: PUSH
14733: LD_INT 33
14735: PUSH
14736: LD_INT 34
14738: PUSH
14739: LD_INT 35
14741: PUSH
14742: LD_INT 36
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: LIST
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: LIST
14756: LIST
14757: LIST
14758: LIST
14759: LIST
14760: LIST
14761: LIST
14762: LIST
14763: LIST
14764: LIST
14765: LIST
14766: LIST
14767: PUSH
14768: LD_INT 101
14770: PUSH
14771: LD_INT 102
14773: PUSH
14774: LD_INT 103
14776: PUSH
14777: LD_INT 106
14779: PUSH
14780: LD_INT 108
14782: PUSH
14783: LD_INT 112
14785: PUSH
14786: LD_INT 113
14788: PUSH
14789: LD_INT 114
14791: PUSH
14792: LD_INT 115
14794: PUSH
14795: EMPTY
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: PUSH
14806: EMPTY
14807: LIST
14808: LIST
14809: ST_TO_ADDR
14810: GO 15041
14812: LD_INT 19
14814: DOUBLE
14815: EQUAL
14816: IFTRUE 14820
14818: GO 15040
14820: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14821: LD_ADDR_VAR 0 1
14825: PUSH
14826: LD_INT 1
14828: PUSH
14829: LD_INT 2
14831: PUSH
14832: LD_INT 3
14834: PUSH
14835: LD_INT 4
14837: PUSH
14838: LD_INT 5
14840: PUSH
14841: LD_INT 6
14843: PUSH
14844: LD_INT 7
14846: PUSH
14847: LD_INT 8
14849: PUSH
14850: LD_INT 9
14852: PUSH
14853: LD_INT 10
14855: PUSH
14856: LD_INT 11
14858: PUSH
14859: LD_INT 12
14861: PUSH
14862: LD_INT 13
14864: PUSH
14865: LD_INT 14
14867: PUSH
14868: LD_INT 15
14870: PUSH
14871: LD_INT 16
14873: PUSH
14874: LD_INT 17
14876: PUSH
14877: LD_INT 18
14879: PUSH
14880: LD_INT 19
14882: PUSH
14883: LD_INT 20
14885: PUSH
14886: LD_INT 21
14888: PUSH
14889: LD_INT 22
14891: PUSH
14892: LD_INT 23
14894: PUSH
14895: LD_INT 24
14897: PUSH
14898: LD_INT 25
14900: PUSH
14901: LD_INT 26
14903: PUSH
14904: LD_INT 27
14906: PUSH
14907: LD_INT 28
14909: PUSH
14910: LD_INT 29
14912: PUSH
14913: LD_INT 30
14915: PUSH
14916: LD_INT 31
14918: PUSH
14919: LD_INT 32
14921: PUSH
14922: LD_INT 33
14924: PUSH
14925: LD_INT 34
14927: PUSH
14928: LD_INT 35
14930: PUSH
14931: LD_INT 36
14933: PUSH
14934: EMPTY
14935: LIST
14936: LIST
14937: LIST
14938: LIST
14939: LIST
14940: LIST
14941: LIST
14942: LIST
14943: LIST
14944: LIST
14945: LIST
14946: LIST
14947: LIST
14948: LIST
14949: LIST
14950: LIST
14951: LIST
14952: LIST
14953: LIST
14954: LIST
14955: LIST
14956: LIST
14957: LIST
14958: LIST
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: LIST
14964: LIST
14965: LIST
14966: LIST
14967: LIST
14968: LIST
14969: LIST
14970: LIST
14971: PUSH
14972: LD_INT 101
14974: PUSH
14975: LD_INT 102
14977: PUSH
14978: LD_INT 103
14980: PUSH
14981: LD_INT 104
14983: PUSH
14984: LD_INT 105
14986: PUSH
14987: LD_INT 106
14989: PUSH
14990: LD_INT 107
14992: PUSH
14993: LD_INT 108
14995: PUSH
14996: LD_INT 109
14998: PUSH
14999: LD_INT 110
15001: PUSH
15002: LD_INT 111
15004: PUSH
15005: LD_INT 112
15007: PUSH
15008: LD_INT 113
15010: PUSH
15011: LD_INT 114
15013: PUSH
15014: LD_INT 115
15016: PUSH
15017: EMPTY
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: PUSH
15034: EMPTY
15035: LIST
15036: LIST
15037: ST_TO_ADDR
15038: GO 15041
15040: POP
// end else
15041: GO 15260
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
15043: LD_ADDR_VAR 0 1
15047: PUSH
15048: LD_INT 1
15050: PUSH
15051: LD_INT 2
15053: PUSH
15054: LD_INT 3
15056: PUSH
15057: LD_INT 4
15059: PUSH
15060: LD_INT 5
15062: PUSH
15063: LD_INT 6
15065: PUSH
15066: LD_INT 7
15068: PUSH
15069: LD_INT 8
15071: PUSH
15072: LD_INT 9
15074: PUSH
15075: LD_INT 10
15077: PUSH
15078: LD_INT 11
15080: PUSH
15081: LD_INT 12
15083: PUSH
15084: LD_INT 13
15086: PUSH
15087: LD_INT 14
15089: PUSH
15090: LD_INT 15
15092: PUSH
15093: LD_INT 16
15095: PUSH
15096: LD_INT 17
15098: PUSH
15099: LD_INT 18
15101: PUSH
15102: LD_INT 19
15104: PUSH
15105: LD_INT 20
15107: PUSH
15108: LD_INT 21
15110: PUSH
15111: LD_INT 22
15113: PUSH
15114: LD_INT 23
15116: PUSH
15117: LD_INT 24
15119: PUSH
15120: LD_INT 25
15122: PUSH
15123: LD_INT 26
15125: PUSH
15126: LD_INT 27
15128: PUSH
15129: LD_INT 28
15131: PUSH
15132: LD_INT 29
15134: PUSH
15135: LD_INT 30
15137: PUSH
15138: LD_INT 31
15140: PUSH
15141: LD_INT 32
15143: PUSH
15144: LD_INT 33
15146: PUSH
15147: LD_INT 34
15149: PUSH
15150: LD_INT 35
15152: PUSH
15153: LD_INT 36
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: LIST
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: LIST
15170: LIST
15171: LIST
15172: LIST
15173: LIST
15174: LIST
15175: LIST
15176: LIST
15177: LIST
15178: LIST
15179: LIST
15180: LIST
15181: LIST
15182: LIST
15183: LIST
15184: LIST
15185: LIST
15186: LIST
15187: LIST
15188: LIST
15189: LIST
15190: LIST
15191: LIST
15192: LIST
15193: PUSH
15194: LD_INT 101
15196: PUSH
15197: LD_INT 102
15199: PUSH
15200: LD_INT 103
15202: PUSH
15203: LD_INT 104
15205: PUSH
15206: LD_INT 105
15208: PUSH
15209: LD_INT 106
15211: PUSH
15212: LD_INT 107
15214: PUSH
15215: LD_INT 108
15217: PUSH
15218: LD_INT 109
15220: PUSH
15221: LD_INT 110
15223: PUSH
15224: LD_INT 111
15226: PUSH
15227: LD_INT 112
15229: PUSH
15230: LD_INT 113
15232: PUSH
15233: LD_INT 114
15235: PUSH
15236: LD_INT 115
15238: PUSH
15239: EMPTY
15240: LIST
15241: LIST
15242: LIST
15243: LIST
15244: LIST
15245: LIST
15246: LIST
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: LIST
15252: LIST
15253: LIST
15254: LIST
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: ST_TO_ADDR
// if result then
15260: LD_VAR 0 1
15264: IFFALSE 15553
// begin normal :=  ;
15266: LD_ADDR_VAR 0 3
15270: PUSH
15271: LD_STRING 
15273: ST_TO_ADDR
// hardcore :=  ;
15274: LD_ADDR_VAR 0 4
15278: PUSH
15279: LD_STRING 
15281: ST_TO_ADDR
// for i = 1 to normalCounter do
15282: LD_ADDR_VAR 0 5
15286: PUSH
15287: DOUBLE
15288: LD_INT 1
15290: DEC
15291: ST_TO_ADDR
15292: LD_EXP 44
15296: PUSH
15297: FOR_TO
15298: IFFALSE 15399
// begin tmp := 0 ;
15300: LD_ADDR_VAR 0 2
15304: PUSH
15305: LD_STRING 0
15307: ST_TO_ADDR
// if result [ 1 ] then
15308: LD_VAR 0 1
15312: PUSH
15313: LD_INT 1
15315: ARRAY
15316: IFFALSE 15381
// if result [ 1 ] [ 1 ] = i then
15318: LD_VAR 0 1
15322: PUSH
15323: LD_INT 1
15325: ARRAY
15326: PUSH
15327: LD_INT 1
15329: ARRAY
15330: PUSH
15331: LD_VAR 0 5
15335: EQUAL
15336: IFFALSE 15381
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
15338: LD_ADDR_VAR 0 1
15342: PUSH
15343: LD_VAR 0 1
15347: PPUSH
15348: LD_INT 1
15350: PPUSH
15351: LD_VAR 0 1
15355: PUSH
15356: LD_INT 1
15358: ARRAY
15359: PPUSH
15360: LD_INT 1
15362: PPUSH
15363: CALL_OW 3
15367: PPUSH
15368: CALL_OW 1
15372: ST_TO_ADDR
// tmp := 1 ;
15373: LD_ADDR_VAR 0 2
15377: PUSH
15378: LD_STRING 1
15380: ST_TO_ADDR
// end ; normal := normal & tmp ;
15381: LD_ADDR_VAR 0 3
15385: PUSH
15386: LD_VAR 0 3
15390: PUSH
15391: LD_VAR 0 2
15395: STR
15396: ST_TO_ADDR
// end ;
15397: GO 15297
15399: POP
15400: POP
// for i = 1 to hardcoreCounter do
15401: LD_ADDR_VAR 0 5
15405: PUSH
15406: DOUBLE
15407: LD_INT 1
15409: DEC
15410: ST_TO_ADDR
15411: LD_EXP 45
15415: PUSH
15416: FOR_TO
15417: IFFALSE 15522
// begin tmp := 0 ;
15419: LD_ADDR_VAR 0 2
15423: PUSH
15424: LD_STRING 0
15426: ST_TO_ADDR
// if result [ 2 ] then
15427: LD_VAR 0 1
15431: PUSH
15432: LD_INT 2
15434: ARRAY
15435: IFFALSE 15504
// if result [ 2 ] [ 1 ] = 100 + i then
15437: LD_VAR 0 1
15441: PUSH
15442: LD_INT 2
15444: ARRAY
15445: PUSH
15446: LD_INT 1
15448: ARRAY
15449: PUSH
15450: LD_INT 100
15452: PUSH
15453: LD_VAR 0 5
15457: PLUS
15458: EQUAL
15459: IFFALSE 15504
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
15461: LD_ADDR_VAR 0 1
15465: PUSH
15466: LD_VAR 0 1
15470: PPUSH
15471: LD_INT 2
15473: PPUSH
15474: LD_VAR 0 1
15478: PUSH
15479: LD_INT 2
15481: ARRAY
15482: PPUSH
15483: LD_INT 1
15485: PPUSH
15486: CALL_OW 3
15490: PPUSH
15491: CALL_OW 1
15495: ST_TO_ADDR
// tmp := 1 ;
15496: LD_ADDR_VAR 0 2
15500: PUSH
15501: LD_STRING 1
15503: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
15504: LD_ADDR_VAR 0 4
15508: PUSH
15509: LD_VAR 0 4
15513: PUSH
15514: LD_VAR 0 2
15518: STR
15519: ST_TO_ADDR
// end ;
15520: GO 15416
15522: POP
15523: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
15524: LD_STRING getStreamItemsFromMission("
15526: PUSH
15527: LD_VAR 0 3
15531: STR
15532: PUSH
15533: LD_STRING ","
15535: STR
15536: PUSH
15537: LD_VAR 0 4
15541: STR
15542: PUSH
15543: LD_STRING ")
15545: STR
15546: PPUSH
15547: CALL_OW 559
// end else
15551: GO 15560
// ToLua ( getStreamItemsFromMission("","") ) ;
15553: LD_STRING getStreamItemsFromMission("","")
15555: PPUSH
15556: CALL_OW 559
// end ;
15560: LD_VAR 0 1
15564: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
15565: LD_VAR 0 2
15569: PUSH
15570: LD_INT 100
15572: EQUAL
15573: IFFALSE 16522
// begin if not StreamModeActive then
15575: LD_EXP 43
15579: NOT
15580: IFFALSE 15590
// StreamModeActive := true ;
15582: LD_ADDR_EXP 43
15586: PUSH
15587: LD_INT 1
15589: ST_TO_ADDR
// if p3 = 0 then
15590: LD_VAR 0 3
15594: PUSH
15595: LD_INT 0
15597: EQUAL
15598: IFFALSE 15604
// InitStreamMode ;
15600: CALL 11643 0 0
// if p3 = 1 then
15604: LD_VAR 0 3
15608: PUSH
15609: LD_INT 1
15611: EQUAL
15612: IFFALSE 15622
// sRocket := true ;
15614: LD_ADDR_EXP 48
15618: PUSH
15619: LD_INT 1
15621: ST_TO_ADDR
// if p3 = 2 then
15622: LD_VAR 0 3
15626: PUSH
15627: LD_INT 2
15629: EQUAL
15630: IFFALSE 15640
// sSpeed := true ;
15632: LD_ADDR_EXP 47
15636: PUSH
15637: LD_INT 1
15639: ST_TO_ADDR
// if p3 = 3 then
15640: LD_VAR 0 3
15644: PUSH
15645: LD_INT 3
15647: EQUAL
15648: IFFALSE 15658
// sEngine := true ;
15650: LD_ADDR_EXP 49
15654: PUSH
15655: LD_INT 1
15657: ST_TO_ADDR
// if p3 = 4 then
15658: LD_VAR 0 3
15662: PUSH
15663: LD_INT 4
15665: EQUAL
15666: IFFALSE 15676
// sSpec := true ;
15668: LD_ADDR_EXP 46
15672: PUSH
15673: LD_INT 1
15675: ST_TO_ADDR
// if p3 = 5 then
15676: LD_VAR 0 3
15680: PUSH
15681: LD_INT 5
15683: EQUAL
15684: IFFALSE 15694
// sLevel := true ;
15686: LD_ADDR_EXP 50
15690: PUSH
15691: LD_INT 1
15693: ST_TO_ADDR
// if p3 = 6 then
15694: LD_VAR 0 3
15698: PUSH
15699: LD_INT 6
15701: EQUAL
15702: IFFALSE 15712
// sArmoury := true ;
15704: LD_ADDR_EXP 51
15708: PUSH
15709: LD_INT 1
15711: ST_TO_ADDR
// if p3 = 7 then
15712: LD_VAR 0 3
15716: PUSH
15717: LD_INT 7
15719: EQUAL
15720: IFFALSE 15730
// sRadar := true ;
15722: LD_ADDR_EXP 52
15726: PUSH
15727: LD_INT 1
15729: ST_TO_ADDR
// if p3 = 8 then
15730: LD_VAR 0 3
15734: PUSH
15735: LD_INT 8
15737: EQUAL
15738: IFFALSE 15748
// sBunker := true ;
15740: LD_ADDR_EXP 53
15744: PUSH
15745: LD_INT 1
15747: ST_TO_ADDR
// if p3 = 9 then
15748: LD_VAR 0 3
15752: PUSH
15753: LD_INT 9
15755: EQUAL
15756: IFFALSE 15766
// sHack := true ;
15758: LD_ADDR_EXP 54
15762: PUSH
15763: LD_INT 1
15765: ST_TO_ADDR
// if p3 = 10 then
15766: LD_VAR 0 3
15770: PUSH
15771: LD_INT 10
15773: EQUAL
15774: IFFALSE 15784
// sFire := true ;
15776: LD_ADDR_EXP 55
15780: PUSH
15781: LD_INT 1
15783: ST_TO_ADDR
// if p3 = 11 then
15784: LD_VAR 0 3
15788: PUSH
15789: LD_INT 11
15791: EQUAL
15792: IFFALSE 15802
// sRefresh := true ;
15794: LD_ADDR_EXP 56
15798: PUSH
15799: LD_INT 1
15801: ST_TO_ADDR
// if p3 = 12 then
15802: LD_VAR 0 3
15806: PUSH
15807: LD_INT 12
15809: EQUAL
15810: IFFALSE 15820
// sExp := true ;
15812: LD_ADDR_EXP 57
15816: PUSH
15817: LD_INT 1
15819: ST_TO_ADDR
// if p3 = 13 then
15820: LD_VAR 0 3
15824: PUSH
15825: LD_INT 13
15827: EQUAL
15828: IFFALSE 15838
// sDepot := true ;
15830: LD_ADDR_EXP 58
15834: PUSH
15835: LD_INT 1
15837: ST_TO_ADDR
// if p3 = 14 then
15838: LD_VAR 0 3
15842: PUSH
15843: LD_INT 14
15845: EQUAL
15846: IFFALSE 15856
// sFlag := true ;
15848: LD_ADDR_EXP 59
15852: PUSH
15853: LD_INT 1
15855: ST_TO_ADDR
// if p3 = 15 then
15856: LD_VAR 0 3
15860: PUSH
15861: LD_INT 15
15863: EQUAL
15864: IFFALSE 15874
// sKamikadze := true ;
15866: LD_ADDR_EXP 67
15870: PUSH
15871: LD_INT 1
15873: ST_TO_ADDR
// if p3 = 16 then
15874: LD_VAR 0 3
15878: PUSH
15879: LD_INT 16
15881: EQUAL
15882: IFFALSE 15892
// sTroll := true ;
15884: LD_ADDR_EXP 68
15888: PUSH
15889: LD_INT 1
15891: ST_TO_ADDR
// if p3 = 17 then
15892: LD_VAR 0 3
15896: PUSH
15897: LD_INT 17
15899: EQUAL
15900: IFFALSE 15910
// sSlow := true ;
15902: LD_ADDR_EXP 69
15906: PUSH
15907: LD_INT 1
15909: ST_TO_ADDR
// if p3 = 18 then
15910: LD_VAR 0 3
15914: PUSH
15915: LD_INT 18
15917: EQUAL
15918: IFFALSE 15928
// sLack := true ;
15920: LD_ADDR_EXP 70
15924: PUSH
15925: LD_INT 1
15927: ST_TO_ADDR
// if p3 = 19 then
15928: LD_VAR 0 3
15932: PUSH
15933: LD_INT 19
15935: EQUAL
15936: IFFALSE 15946
// sTank := true ;
15938: LD_ADDR_EXP 72
15942: PUSH
15943: LD_INT 1
15945: ST_TO_ADDR
// if p3 = 20 then
15946: LD_VAR 0 3
15950: PUSH
15951: LD_INT 20
15953: EQUAL
15954: IFFALSE 15964
// sRemote := true ;
15956: LD_ADDR_EXP 73
15960: PUSH
15961: LD_INT 1
15963: ST_TO_ADDR
// if p3 = 21 then
15964: LD_VAR 0 3
15968: PUSH
15969: LD_INT 21
15971: EQUAL
15972: IFFALSE 15982
// sPowell := true ;
15974: LD_ADDR_EXP 74
15978: PUSH
15979: LD_INT 1
15981: ST_TO_ADDR
// if p3 = 22 then
15982: LD_VAR 0 3
15986: PUSH
15987: LD_INT 22
15989: EQUAL
15990: IFFALSE 16000
// sTeleport := true ;
15992: LD_ADDR_EXP 77
15996: PUSH
15997: LD_INT 1
15999: ST_TO_ADDR
// if p3 = 23 then
16000: LD_VAR 0 3
16004: PUSH
16005: LD_INT 23
16007: EQUAL
16008: IFFALSE 16018
// sOilTower := true ;
16010: LD_ADDR_EXP 79
16014: PUSH
16015: LD_INT 1
16017: ST_TO_ADDR
// if p3 = 24 then
16018: LD_VAR 0 3
16022: PUSH
16023: LD_INT 24
16025: EQUAL
16026: IFFALSE 16036
// sShovel := true ;
16028: LD_ADDR_EXP 80
16032: PUSH
16033: LD_INT 1
16035: ST_TO_ADDR
// if p3 = 25 then
16036: LD_VAR 0 3
16040: PUSH
16041: LD_INT 25
16043: EQUAL
16044: IFFALSE 16054
// sSheik := true ;
16046: LD_ADDR_EXP 81
16050: PUSH
16051: LD_INT 1
16053: ST_TO_ADDR
// if p3 = 26 then
16054: LD_VAR 0 3
16058: PUSH
16059: LD_INT 26
16061: EQUAL
16062: IFFALSE 16072
// sEarthquake := true ;
16064: LD_ADDR_EXP 83
16068: PUSH
16069: LD_INT 1
16071: ST_TO_ADDR
// if p3 = 27 then
16072: LD_VAR 0 3
16076: PUSH
16077: LD_INT 27
16079: EQUAL
16080: IFFALSE 16090
// sAI := true ;
16082: LD_ADDR_EXP 84
16086: PUSH
16087: LD_INT 1
16089: ST_TO_ADDR
// if p3 = 28 then
16090: LD_VAR 0 3
16094: PUSH
16095: LD_INT 28
16097: EQUAL
16098: IFFALSE 16108
// sCargo := true ;
16100: LD_ADDR_EXP 87
16104: PUSH
16105: LD_INT 1
16107: ST_TO_ADDR
// if p3 = 29 then
16108: LD_VAR 0 3
16112: PUSH
16113: LD_INT 29
16115: EQUAL
16116: IFFALSE 16126
// sDLaser := true ;
16118: LD_ADDR_EXP 88
16122: PUSH
16123: LD_INT 1
16125: ST_TO_ADDR
// if p3 = 30 then
16126: LD_VAR 0 3
16130: PUSH
16131: LD_INT 30
16133: EQUAL
16134: IFFALSE 16144
// sExchange := true ;
16136: LD_ADDR_EXP 89
16140: PUSH
16141: LD_INT 1
16143: ST_TO_ADDR
// if p3 = 31 then
16144: LD_VAR 0 3
16148: PUSH
16149: LD_INT 31
16151: EQUAL
16152: IFFALSE 16162
// sFac := true ;
16154: LD_ADDR_EXP 90
16158: PUSH
16159: LD_INT 1
16161: ST_TO_ADDR
// if p3 = 32 then
16162: LD_VAR 0 3
16166: PUSH
16167: LD_INT 32
16169: EQUAL
16170: IFFALSE 16180
// sPower := true ;
16172: LD_ADDR_EXP 91
16176: PUSH
16177: LD_INT 1
16179: ST_TO_ADDR
// if p3 = 33 then
16180: LD_VAR 0 3
16184: PUSH
16185: LD_INT 33
16187: EQUAL
16188: IFFALSE 16198
// sRandom := true ;
16190: LD_ADDR_EXP 92
16194: PUSH
16195: LD_INT 1
16197: ST_TO_ADDR
// if p3 = 34 then
16198: LD_VAR 0 3
16202: PUSH
16203: LD_INT 34
16205: EQUAL
16206: IFFALSE 16216
// sShield := true ;
16208: LD_ADDR_EXP 93
16212: PUSH
16213: LD_INT 1
16215: ST_TO_ADDR
// if p3 = 35 then
16216: LD_VAR 0 3
16220: PUSH
16221: LD_INT 35
16223: EQUAL
16224: IFFALSE 16234
// sTime := true ;
16226: LD_ADDR_EXP 94
16230: PUSH
16231: LD_INT 1
16233: ST_TO_ADDR
// if p3 = 36 then
16234: LD_VAR 0 3
16238: PUSH
16239: LD_INT 36
16241: EQUAL
16242: IFFALSE 16252
// sTools := true ;
16244: LD_ADDR_EXP 95
16248: PUSH
16249: LD_INT 1
16251: ST_TO_ADDR
// if p3 = 101 then
16252: LD_VAR 0 3
16256: PUSH
16257: LD_INT 101
16259: EQUAL
16260: IFFALSE 16270
// sSold := true ;
16262: LD_ADDR_EXP 60
16266: PUSH
16267: LD_INT 1
16269: ST_TO_ADDR
// if p3 = 102 then
16270: LD_VAR 0 3
16274: PUSH
16275: LD_INT 102
16277: EQUAL
16278: IFFALSE 16288
// sDiff := true ;
16280: LD_ADDR_EXP 61
16284: PUSH
16285: LD_INT 1
16287: ST_TO_ADDR
// if p3 = 103 then
16288: LD_VAR 0 3
16292: PUSH
16293: LD_INT 103
16295: EQUAL
16296: IFFALSE 16306
// sFog := true ;
16298: LD_ADDR_EXP 64
16302: PUSH
16303: LD_INT 1
16305: ST_TO_ADDR
// if p3 = 104 then
16306: LD_VAR 0 3
16310: PUSH
16311: LD_INT 104
16313: EQUAL
16314: IFFALSE 16324
// sReset := true ;
16316: LD_ADDR_EXP 65
16320: PUSH
16321: LD_INT 1
16323: ST_TO_ADDR
// if p3 = 105 then
16324: LD_VAR 0 3
16328: PUSH
16329: LD_INT 105
16331: EQUAL
16332: IFFALSE 16342
// sSun := true ;
16334: LD_ADDR_EXP 66
16338: PUSH
16339: LD_INT 1
16341: ST_TO_ADDR
// if p3 = 106 then
16342: LD_VAR 0 3
16346: PUSH
16347: LD_INT 106
16349: EQUAL
16350: IFFALSE 16360
// sTiger := true ;
16352: LD_ADDR_EXP 62
16356: PUSH
16357: LD_INT 1
16359: ST_TO_ADDR
// if p3 = 107 then
16360: LD_VAR 0 3
16364: PUSH
16365: LD_INT 107
16367: EQUAL
16368: IFFALSE 16378
// sBomb := true ;
16370: LD_ADDR_EXP 63
16374: PUSH
16375: LD_INT 1
16377: ST_TO_ADDR
// if p3 = 108 then
16378: LD_VAR 0 3
16382: PUSH
16383: LD_INT 108
16385: EQUAL
16386: IFFALSE 16396
// sWound := true ;
16388: LD_ADDR_EXP 71
16392: PUSH
16393: LD_INT 1
16395: ST_TO_ADDR
// if p3 = 109 then
16396: LD_VAR 0 3
16400: PUSH
16401: LD_INT 109
16403: EQUAL
16404: IFFALSE 16414
// sBetray := true ;
16406: LD_ADDR_EXP 75
16410: PUSH
16411: LD_INT 1
16413: ST_TO_ADDR
// if p3 = 110 then
16414: LD_VAR 0 3
16418: PUSH
16419: LD_INT 110
16421: EQUAL
16422: IFFALSE 16432
// sContamin := true ;
16424: LD_ADDR_EXP 76
16428: PUSH
16429: LD_INT 1
16431: ST_TO_ADDR
// if p3 = 111 then
16432: LD_VAR 0 3
16436: PUSH
16437: LD_INT 111
16439: EQUAL
16440: IFFALSE 16450
// sOil := true ;
16442: LD_ADDR_EXP 78
16446: PUSH
16447: LD_INT 1
16449: ST_TO_ADDR
// if p3 = 112 then
16450: LD_VAR 0 3
16454: PUSH
16455: LD_INT 112
16457: EQUAL
16458: IFFALSE 16468
// sStu := true ;
16460: LD_ADDR_EXP 82
16464: PUSH
16465: LD_INT 1
16467: ST_TO_ADDR
// if p3 = 113 then
16468: LD_VAR 0 3
16472: PUSH
16473: LD_INT 113
16475: EQUAL
16476: IFFALSE 16486
// sBazooka := true ;
16478: LD_ADDR_EXP 85
16482: PUSH
16483: LD_INT 1
16485: ST_TO_ADDR
// if p3 = 114 then
16486: LD_VAR 0 3
16490: PUSH
16491: LD_INT 114
16493: EQUAL
16494: IFFALSE 16504
// sMortar := true ;
16496: LD_ADDR_EXP 86
16500: PUSH
16501: LD_INT 1
16503: ST_TO_ADDR
// if p3 = 115 then
16504: LD_VAR 0 3
16508: PUSH
16509: LD_INT 115
16511: EQUAL
16512: IFFALSE 16522
// sRanger := true ;
16514: LD_ADDR_EXP 96
16518: PUSH
16519: LD_INT 1
16521: ST_TO_ADDR
// end ; end ;
16522: PPOPN 6
16524: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
16525: LD_EXP 43
16529: PUSH
16530: LD_EXP 48
16534: AND
16535: IFFALSE 16659
16537: GO 16539
16539: DISABLE
16540: LD_INT 0
16542: PPUSH
16543: PPUSH
// begin enable ;
16544: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
16545: LD_ADDR_VAR 0 2
16549: PUSH
16550: LD_INT 22
16552: PUSH
16553: LD_OWVAR 2
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: PUSH
16562: LD_INT 2
16564: PUSH
16565: LD_INT 34
16567: PUSH
16568: LD_INT 7
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PUSH
16575: LD_INT 34
16577: PUSH
16578: LD_INT 45
16580: PUSH
16581: EMPTY
16582: LIST
16583: LIST
16584: PUSH
16585: LD_INT 34
16587: PUSH
16588: LD_INT 28
16590: PUSH
16591: EMPTY
16592: LIST
16593: LIST
16594: PUSH
16595: LD_INT 34
16597: PUSH
16598: LD_INT 47
16600: PUSH
16601: EMPTY
16602: LIST
16603: LIST
16604: PUSH
16605: EMPTY
16606: LIST
16607: LIST
16608: LIST
16609: LIST
16610: LIST
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: PPUSH
16616: CALL_OW 69
16620: ST_TO_ADDR
// if not tmp then
16621: LD_VAR 0 2
16625: NOT
16626: IFFALSE 16630
// exit ;
16628: GO 16659
// for i in tmp do
16630: LD_ADDR_VAR 0 1
16634: PUSH
16635: LD_VAR 0 2
16639: PUSH
16640: FOR_IN
16641: IFFALSE 16657
// begin SetLives ( i , 0 ) ;
16643: LD_VAR 0 1
16647: PPUSH
16648: LD_INT 0
16650: PPUSH
16651: CALL_OW 234
// end ;
16655: GO 16640
16657: POP
16658: POP
// end ;
16659: PPOPN 2
16661: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
16662: LD_EXP 43
16666: PUSH
16667: LD_EXP 49
16671: AND
16672: IFFALSE 16756
16674: GO 16676
16676: DISABLE
16677: LD_INT 0
16679: PPUSH
16680: PPUSH
// begin enable ;
16681: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
16682: LD_ADDR_VAR 0 2
16686: PUSH
16687: LD_INT 22
16689: PUSH
16690: LD_OWVAR 2
16694: PUSH
16695: EMPTY
16696: LIST
16697: LIST
16698: PUSH
16699: LD_INT 32
16701: PUSH
16702: LD_INT 3
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: PPUSH
16713: CALL_OW 69
16717: ST_TO_ADDR
// if not tmp then
16718: LD_VAR 0 2
16722: NOT
16723: IFFALSE 16727
// exit ;
16725: GO 16756
// for i in tmp do
16727: LD_ADDR_VAR 0 1
16731: PUSH
16732: LD_VAR 0 2
16736: PUSH
16737: FOR_IN
16738: IFFALSE 16754
// begin SetLives ( i , 0 ) ;
16740: LD_VAR 0 1
16744: PPUSH
16745: LD_INT 0
16747: PPUSH
16748: CALL_OW 234
// end ;
16752: GO 16737
16754: POP
16755: POP
// end ;
16756: PPOPN 2
16758: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
16759: LD_EXP 43
16763: PUSH
16764: LD_EXP 46
16768: AND
16769: IFFALSE 16862
16771: GO 16773
16773: DISABLE
16774: LD_INT 0
16776: PPUSH
// begin enable ;
16777: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
16778: LD_ADDR_VAR 0 1
16782: PUSH
16783: LD_INT 22
16785: PUSH
16786: LD_OWVAR 2
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: LD_INT 25
16800: PUSH
16801: LD_INT 5
16803: PUSH
16804: EMPTY
16805: LIST
16806: LIST
16807: PUSH
16808: LD_INT 25
16810: PUSH
16811: LD_INT 9
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: PUSH
16818: LD_INT 25
16820: PUSH
16821: LD_INT 8
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: EMPTY
16829: LIST
16830: LIST
16831: LIST
16832: LIST
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: PPUSH
16838: CALL_OW 69
16842: PUSH
16843: FOR_IN
16844: IFFALSE 16860
// begin SetClass ( i , 1 ) ;
16846: LD_VAR 0 1
16850: PPUSH
16851: LD_INT 1
16853: PPUSH
16854: CALL_OW 336
// end ;
16858: GO 16843
16860: POP
16861: POP
// end ;
16862: PPOPN 1
16864: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16865: LD_EXP 43
16869: PUSH
16870: LD_EXP 47
16874: AND
16875: PUSH
16876: LD_OWVAR 65
16880: PUSH
16881: LD_INT 7
16883: LESS
16884: AND
16885: IFFALSE 16899
16887: GO 16889
16889: DISABLE
// begin enable ;
16890: ENABLE
// game_speed := 7 ;
16891: LD_ADDR_OWVAR 65
16895: PUSH
16896: LD_INT 7
16898: ST_TO_ADDR
// end ;
16899: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16900: LD_EXP 43
16904: PUSH
16905: LD_EXP 50
16909: AND
16910: IFFALSE 17112
16912: GO 16914
16914: DISABLE
16915: LD_INT 0
16917: PPUSH
16918: PPUSH
16919: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16920: LD_ADDR_VAR 0 3
16924: PUSH
16925: LD_INT 81
16927: PUSH
16928: LD_OWVAR 2
16932: PUSH
16933: EMPTY
16934: LIST
16935: LIST
16936: PUSH
16937: LD_INT 21
16939: PUSH
16940: LD_INT 1
16942: PUSH
16943: EMPTY
16944: LIST
16945: LIST
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PPUSH
16951: CALL_OW 69
16955: ST_TO_ADDR
// if not tmp then
16956: LD_VAR 0 3
16960: NOT
16961: IFFALSE 16965
// exit ;
16963: GO 17112
// if tmp > 5 then
16965: LD_VAR 0 3
16969: PUSH
16970: LD_INT 5
16972: GREATER
16973: IFFALSE 16985
// k := 5 else
16975: LD_ADDR_VAR 0 2
16979: PUSH
16980: LD_INT 5
16982: ST_TO_ADDR
16983: GO 16995
// k := tmp ;
16985: LD_ADDR_VAR 0 2
16989: PUSH
16990: LD_VAR 0 3
16994: ST_TO_ADDR
// for i := 1 to k do
16995: LD_ADDR_VAR 0 1
16999: PUSH
17000: DOUBLE
17001: LD_INT 1
17003: DEC
17004: ST_TO_ADDR
17005: LD_VAR 0 2
17009: PUSH
17010: FOR_TO
17011: IFFALSE 17110
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
17013: LD_VAR 0 3
17017: PUSH
17018: LD_VAR 0 1
17022: ARRAY
17023: PPUSH
17024: LD_VAR 0 1
17028: PUSH
17029: LD_INT 4
17031: MOD
17032: PUSH
17033: LD_INT 1
17035: PLUS
17036: PPUSH
17037: CALL_OW 259
17041: PUSH
17042: LD_INT 10
17044: LESS
17045: IFFALSE 17108
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
17047: LD_VAR 0 3
17051: PUSH
17052: LD_VAR 0 1
17056: ARRAY
17057: PPUSH
17058: LD_VAR 0 1
17062: PUSH
17063: LD_INT 4
17065: MOD
17066: PUSH
17067: LD_INT 1
17069: PLUS
17070: PPUSH
17071: LD_VAR 0 3
17075: PUSH
17076: LD_VAR 0 1
17080: ARRAY
17081: PPUSH
17082: LD_VAR 0 1
17086: PUSH
17087: LD_INT 4
17089: MOD
17090: PUSH
17091: LD_INT 1
17093: PLUS
17094: PPUSH
17095: CALL_OW 259
17099: PUSH
17100: LD_INT 1
17102: PLUS
17103: PPUSH
17104: CALL_OW 237
17108: GO 17010
17110: POP
17111: POP
// end ;
17112: PPOPN 3
17114: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
17115: LD_EXP 43
17119: PUSH
17120: LD_EXP 51
17124: AND
17125: IFFALSE 17145
17127: GO 17129
17129: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
17130: LD_INT 4
17132: PPUSH
17133: LD_OWVAR 2
17137: PPUSH
17138: LD_INT 0
17140: PPUSH
17141: CALL_OW 324
17145: END
// every 0 0$1 trigger StreamModeActive and sShovel do
17146: LD_EXP 43
17150: PUSH
17151: LD_EXP 80
17155: AND
17156: IFFALSE 17176
17158: GO 17160
17160: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
17161: LD_INT 19
17163: PPUSH
17164: LD_OWVAR 2
17168: PPUSH
17169: LD_INT 0
17171: PPUSH
17172: CALL_OW 324
17176: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
17177: LD_EXP 43
17181: PUSH
17182: LD_EXP 52
17186: AND
17187: IFFALSE 17289
17189: GO 17191
17191: DISABLE
17192: LD_INT 0
17194: PPUSH
17195: PPUSH
// begin enable ;
17196: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
17197: LD_ADDR_VAR 0 2
17201: PUSH
17202: LD_INT 22
17204: PUSH
17205: LD_OWVAR 2
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: PUSH
17214: LD_INT 2
17216: PUSH
17217: LD_INT 34
17219: PUSH
17220: LD_INT 11
17222: PUSH
17223: EMPTY
17224: LIST
17225: LIST
17226: PUSH
17227: LD_INT 34
17229: PUSH
17230: LD_INT 30
17232: PUSH
17233: EMPTY
17234: LIST
17235: LIST
17236: PUSH
17237: EMPTY
17238: LIST
17239: LIST
17240: LIST
17241: PUSH
17242: EMPTY
17243: LIST
17244: LIST
17245: PPUSH
17246: CALL_OW 69
17250: ST_TO_ADDR
// if not tmp then
17251: LD_VAR 0 2
17255: NOT
17256: IFFALSE 17260
// exit ;
17258: GO 17289
// for i in tmp do
17260: LD_ADDR_VAR 0 1
17264: PUSH
17265: LD_VAR 0 2
17269: PUSH
17270: FOR_IN
17271: IFFALSE 17287
// begin SetLives ( i , 0 ) ;
17273: LD_VAR 0 1
17277: PPUSH
17278: LD_INT 0
17280: PPUSH
17281: CALL_OW 234
// end ;
17285: GO 17270
17287: POP
17288: POP
// end ;
17289: PPOPN 2
17291: END
// every 0 0$1 trigger StreamModeActive and sBunker do
17292: LD_EXP 43
17296: PUSH
17297: LD_EXP 53
17301: AND
17302: IFFALSE 17322
17304: GO 17306
17306: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
17307: LD_INT 32
17309: PPUSH
17310: LD_OWVAR 2
17314: PPUSH
17315: LD_INT 0
17317: PPUSH
17318: CALL_OW 324
17322: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
17323: LD_EXP 43
17327: PUSH
17328: LD_EXP 54
17332: AND
17333: IFFALSE 17514
17335: GO 17337
17337: DISABLE
17338: LD_INT 0
17340: PPUSH
17341: PPUSH
17342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
17343: LD_ADDR_VAR 0 2
17347: PUSH
17348: LD_INT 22
17350: PUSH
17351: LD_OWVAR 2
17355: PUSH
17356: EMPTY
17357: LIST
17358: LIST
17359: PUSH
17360: LD_INT 33
17362: PUSH
17363: LD_INT 3
17365: PUSH
17366: EMPTY
17367: LIST
17368: LIST
17369: PUSH
17370: EMPTY
17371: LIST
17372: LIST
17373: PPUSH
17374: CALL_OW 69
17378: ST_TO_ADDR
// if not tmp then
17379: LD_VAR 0 2
17383: NOT
17384: IFFALSE 17388
// exit ;
17386: GO 17514
// side := 0 ;
17388: LD_ADDR_VAR 0 3
17392: PUSH
17393: LD_INT 0
17395: ST_TO_ADDR
// for i := 1 to 8 do
17396: LD_ADDR_VAR 0 1
17400: PUSH
17401: DOUBLE
17402: LD_INT 1
17404: DEC
17405: ST_TO_ADDR
17406: LD_INT 8
17408: PUSH
17409: FOR_TO
17410: IFFALSE 17458
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
17412: LD_OWVAR 2
17416: PUSH
17417: LD_VAR 0 1
17421: NONEQUAL
17422: PUSH
17423: LD_OWVAR 2
17427: PPUSH
17428: LD_VAR 0 1
17432: PPUSH
17433: CALL_OW 81
17437: PUSH
17438: LD_INT 2
17440: EQUAL
17441: AND
17442: IFFALSE 17456
// begin side := i ;
17444: LD_ADDR_VAR 0 3
17448: PUSH
17449: LD_VAR 0 1
17453: ST_TO_ADDR
// break ;
17454: GO 17458
// end ;
17456: GO 17409
17458: POP
17459: POP
// if not side then
17460: LD_VAR 0 3
17464: NOT
17465: IFFALSE 17469
// exit ;
17467: GO 17514
// for i := 1 to tmp do
17469: LD_ADDR_VAR 0 1
17473: PUSH
17474: DOUBLE
17475: LD_INT 1
17477: DEC
17478: ST_TO_ADDR
17479: LD_VAR 0 2
17483: PUSH
17484: FOR_TO
17485: IFFALSE 17512
// if Prob ( 60 ) then
17487: LD_INT 60
17489: PPUSH
17490: CALL_OW 13
17494: IFFALSE 17510
// SetSide ( i , side ) ;
17496: LD_VAR 0 1
17500: PPUSH
17501: LD_VAR 0 3
17505: PPUSH
17506: CALL_OW 235
17510: GO 17484
17512: POP
17513: POP
// end ;
17514: PPOPN 3
17516: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
17517: LD_EXP 43
17521: PUSH
17522: LD_EXP 56
17526: AND
17527: IFFALSE 17646
17529: GO 17531
17531: DISABLE
17532: LD_INT 0
17534: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
17535: LD_ADDR_VAR 0 1
17539: PUSH
17540: LD_INT 22
17542: PUSH
17543: LD_OWVAR 2
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: PUSH
17552: LD_INT 21
17554: PUSH
17555: LD_INT 1
17557: PUSH
17558: EMPTY
17559: LIST
17560: LIST
17561: PUSH
17562: LD_INT 3
17564: PUSH
17565: LD_INT 23
17567: PUSH
17568: LD_INT 0
17570: PUSH
17571: EMPTY
17572: LIST
17573: LIST
17574: PUSH
17575: EMPTY
17576: LIST
17577: LIST
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: LIST
17583: PPUSH
17584: CALL_OW 69
17588: PUSH
17589: FOR_IN
17590: IFFALSE 17644
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
17592: LD_VAR 0 1
17596: PPUSH
17597: CALL_OW 257
17601: PUSH
17602: LD_INT 1
17604: PUSH
17605: LD_INT 2
17607: PUSH
17608: LD_INT 3
17610: PUSH
17611: LD_INT 4
17613: PUSH
17614: EMPTY
17615: LIST
17616: LIST
17617: LIST
17618: LIST
17619: IN
17620: IFFALSE 17642
// SetClass ( un , rand ( 1 , 4 ) ) ;
17622: LD_VAR 0 1
17626: PPUSH
17627: LD_INT 1
17629: PPUSH
17630: LD_INT 4
17632: PPUSH
17633: CALL_OW 12
17637: PPUSH
17638: CALL_OW 336
17642: GO 17589
17644: POP
17645: POP
// end ;
17646: PPOPN 1
17648: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
17649: LD_EXP 43
17653: PUSH
17654: LD_EXP 55
17658: AND
17659: IFFALSE 17738
17661: GO 17663
17663: DISABLE
17664: LD_INT 0
17666: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17667: LD_ADDR_VAR 0 1
17671: PUSH
17672: LD_INT 22
17674: PUSH
17675: LD_OWVAR 2
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: PUSH
17684: LD_INT 21
17686: PUSH
17687: LD_INT 3
17689: PUSH
17690: EMPTY
17691: LIST
17692: LIST
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: PPUSH
17698: CALL_OW 69
17702: ST_TO_ADDR
// if not tmp then
17703: LD_VAR 0 1
17707: NOT
17708: IFFALSE 17712
// exit ;
17710: GO 17738
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
17712: LD_VAR 0 1
17716: PUSH
17717: LD_INT 1
17719: PPUSH
17720: LD_VAR 0 1
17724: PPUSH
17725: CALL_OW 12
17729: ARRAY
17730: PPUSH
17731: LD_INT 100
17733: PPUSH
17734: CALL_OW 234
// end ;
17738: PPOPN 1
17740: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
17741: LD_EXP 43
17745: PUSH
17746: LD_EXP 57
17750: AND
17751: IFFALSE 17849
17753: GO 17755
17755: DISABLE
17756: LD_INT 0
17758: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17759: LD_ADDR_VAR 0 1
17763: PUSH
17764: LD_INT 22
17766: PUSH
17767: LD_OWVAR 2
17771: PUSH
17772: EMPTY
17773: LIST
17774: LIST
17775: PUSH
17776: LD_INT 21
17778: PUSH
17779: LD_INT 1
17781: PUSH
17782: EMPTY
17783: LIST
17784: LIST
17785: PUSH
17786: EMPTY
17787: LIST
17788: LIST
17789: PPUSH
17790: CALL_OW 69
17794: ST_TO_ADDR
// if not tmp then
17795: LD_VAR 0 1
17799: NOT
17800: IFFALSE 17804
// exit ;
17802: GO 17849
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
17804: LD_VAR 0 1
17808: PUSH
17809: LD_INT 1
17811: PPUSH
17812: LD_VAR 0 1
17816: PPUSH
17817: CALL_OW 12
17821: ARRAY
17822: PPUSH
17823: LD_INT 1
17825: PPUSH
17826: LD_INT 4
17828: PPUSH
17829: CALL_OW 12
17833: PPUSH
17834: LD_INT 3000
17836: PPUSH
17837: LD_INT 9000
17839: PPUSH
17840: CALL_OW 12
17844: PPUSH
17845: CALL_OW 492
// end ;
17849: PPOPN 1
17851: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17852: LD_EXP 43
17856: PUSH
17857: LD_EXP 58
17861: AND
17862: IFFALSE 17882
17864: GO 17866
17866: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17867: LD_INT 1
17869: PPUSH
17870: LD_OWVAR 2
17874: PPUSH
17875: LD_INT 0
17877: PPUSH
17878: CALL_OW 324
17882: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17883: LD_EXP 43
17887: PUSH
17888: LD_EXP 59
17892: AND
17893: IFFALSE 17976
17895: GO 17897
17897: DISABLE
17898: LD_INT 0
17900: PPUSH
17901: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17902: LD_ADDR_VAR 0 2
17906: PUSH
17907: LD_INT 22
17909: PUSH
17910: LD_OWVAR 2
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: PUSH
17919: LD_INT 21
17921: PUSH
17922: LD_INT 3
17924: PUSH
17925: EMPTY
17926: LIST
17927: LIST
17928: PUSH
17929: EMPTY
17930: LIST
17931: LIST
17932: PPUSH
17933: CALL_OW 69
17937: ST_TO_ADDR
// if not tmp then
17938: LD_VAR 0 2
17942: NOT
17943: IFFALSE 17947
// exit ;
17945: GO 17976
// for i in tmp do
17947: LD_ADDR_VAR 0 1
17951: PUSH
17952: LD_VAR 0 2
17956: PUSH
17957: FOR_IN
17958: IFFALSE 17974
// SetBLevel ( i , 10 ) ;
17960: LD_VAR 0 1
17964: PPUSH
17965: LD_INT 10
17967: PPUSH
17968: CALL_OW 241
17972: GO 17957
17974: POP
17975: POP
// end ;
17976: PPOPN 2
17978: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17979: LD_EXP 43
17983: PUSH
17984: LD_EXP 60
17988: AND
17989: IFFALSE 18100
17991: GO 17993
17993: DISABLE
17994: LD_INT 0
17996: PPUSH
17997: PPUSH
17998: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17999: LD_ADDR_VAR 0 3
18003: PUSH
18004: LD_INT 22
18006: PUSH
18007: LD_OWVAR 2
18011: PUSH
18012: EMPTY
18013: LIST
18014: LIST
18015: PUSH
18016: LD_INT 25
18018: PUSH
18019: LD_INT 1
18021: PUSH
18022: EMPTY
18023: LIST
18024: LIST
18025: PUSH
18026: EMPTY
18027: LIST
18028: LIST
18029: PPUSH
18030: CALL_OW 69
18034: ST_TO_ADDR
// if not tmp then
18035: LD_VAR 0 3
18039: NOT
18040: IFFALSE 18044
// exit ;
18042: GO 18100
// un := tmp [ rand ( 1 , tmp ) ] ;
18044: LD_ADDR_VAR 0 2
18048: PUSH
18049: LD_VAR 0 3
18053: PUSH
18054: LD_INT 1
18056: PPUSH
18057: LD_VAR 0 3
18061: PPUSH
18062: CALL_OW 12
18066: ARRAY
18067: ST_TO_ADDR
// if Crawls ( un ) then
18068: LD_VAR 0 2
18072: PPUSH
18073: CALL_OW 318
18077: IFFALSE 18088
// ComWalk ( un ) ;
18079: LD_VAR 0 2
18083: PPUSH
18084: CALL_OW 138
// SetClass ( un , class_sniper ) ;
18088: LD_VAR 0 2
18092: PPUSH
18093: LD_INT 5
18095: PPUSH
18096: CALL_OW 336
// end ;
18100: PPOPN 3
18102: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
18103: LD_EXP 43
18107: PUSH
18108: LD_EXP 61
18112: AND
18113: PUSH
18114: LD_OWVAR 67
18118: PUSH
18119: LD_INT 3
18121: LESS
18122: AND
18123: IFFALSE 18142
18125: GO 18127
18127: DISABLE
// Difficulty := Difficulty + 1 ;
18128: LD_ADDR_OWVAR 67
18132: PUSH
18133: LD_OWVAR 67
18137: PUSH
18138: LD_INT 1
18140: PLUS
18141: ST_TO_ADDR
18142: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
18143: LD_EXP 43
18147: PUSH
18148: LD_EXP 62
18152: AND
18153: IFFALSE 18256
18155: GO 18157
18157: DISABLE
18158: LD_INT 0
18160: PPUSH
// begin for i := 1 to 5 do
18161: LD_ADDR_VAR 0 1
18165: PUSH
18166: DOUBLE
18167: LD_INT 1
18169: DEC
18170: ST_TO_ADDR
18171: LD_INT 5
18173: PUSH
18174: FOR_TO
18175: IFFALSE 18254
// begin uc_nation := nation_nature ;
18177: LD_ADDR_OWVAR 21
18181: PUSH
18182: LD_INT 0
18184: ST_TO_ADDR
// uc_side := 0 ;
18185: LD_ADDR_OWVAR 20
18189: PUSH
18190: LD_INT 0
18192: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18193: LD_ADDR_OWVAR 29
18197: PUSH
18198: LD_INT 12
18200: PUSH
18201: LD_INT 12
18203: PUSH
18204: EMPTY
18205: LIST
18206: LIST
18207: ST_TO_ADDR
// hc_agressivity := 20 ;
18208: LD_ADDR_OWVAR 35
18212: PUSH
18213: LD_INT 20
18215: ST_TO_ADDR
// hc_class := class_tiger ;
18216: LD_ADDR_OWVAR 28
18220: PUSH
18221: LD_INT 14
18223: ST_TO_ADDR
// hc_gallery :=  ;
18224: LD_ADDR_OWVAR 33
18228: PUSH
18229: LD_STRING 
18231: ST_TO_ADDR
// hc_name :=  ;
18232: LD_ADDR_OWVAR 26
18236: PUSH
18237: LD_STRING 
18239: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
18240: CALL_OW 44
18244: PPUSH
18245: LD_INT 0
18247: PPUSH
18248: CALL_OW 51
// end ;
18252: GO 18174
18254: POP
18255: POP
// end ;
18256: PPOPN 1
18258: END
// every 0 0$1 trigger StreamModeActive and sBomb do
18259: LD_EXP 43
18263: PUSH
18264: LD_EXP 63
18268: AND
18269: IFFALSE 18278
18271: GO 18273
18273: DISABLE
// StreamSibBomb ;
18274: CALL 18279 0 0
18278: END
// export function StreamSibBomb ; var i , x , y ; begin
18279: LD_INT 0
18281: PPUSH
18282: PPUSH
18283: PPUSH
18284: PPUSH
// result := false ;
18285: LD_ADDR_VAR 0 1
18289: PUSH
18290: LD_INT 0
18292: ST_TO_ADDR
// for i := 1 to 16 do
18293: LD_ADDR_VAR 0 2
18297: PUSH
18298: DOUBLE
18299: LD_INT 1
18301: DEC
18302: ST_TO_ADDR
18303: LD_INT 16
18305: PUSH
18306: FOR_TO
18307: IFFALSE 18506
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18309: LD_ADDR_VAR 0 3
18313: PUSH
18314: LD_INT 10
18316: PUSH
18317: LD_INT 20
18319: PUSH
18320: LD_INT 30
18322: PUSH
18323: LD_INT 40
18325: PUSH
18326: LD_INT 50
18328: PUSH
18329: LD_INT 60
18331: PUSH
18332: LD_INT 70
18334: PUSH
18335: LD_INT 80
18337: PUSH
18338: LD_INT 90
18340: PUSH
18341: LD_INT 100
18343: PUSH
18344: LD_INT 110
18346: PUSH
18347: LD_INT 120
18349: PUSH
18350: LD_INT 130
18352: PUSH
18353: LD_INT 140
18355: PUSH
18356: LD_INT 150
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: LIST
18363: LIST
18364: LIST
18365: LIST
18366: LIST
18367: LIST
18368: LIST
18369: LIST
18370: LIST
18371: LIST
18372: LIST
18373: LIST
18374: LIST
18375: PUSH
18376: LD_INT 1
18378: PPUSH
18379: LD_INT 15
18381: PPUSH
18382: CALL_OW 12
18386: ARRAY
18387: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
18388: LD_ADDR_VAR 0 4
18392: PUSH
18393: LD_INT 10
18395: PUSH
18396: LD_INT 20
18398: PUSH
18399: LD_INT 30
18401: PUSH
18402: LD_INT 40
18404: PUSH
18405: LD_INT 50
18407: PUSH
18408: LD_INT 60
18410: PUSH
18411: LD_INT 70
18413: PUSH
18414: LD_INT 80
18416: PUSH
18417: LD_INT 90
18419: PUSH
18420: LD_INT 100
18422: PUSH
18423: LD_INT 110
18425: PUSH
18426: LD_INT 120
18428: PUSH
18429: LD_INT 130
18431: PUSH
18432: LD_INT 140
18434: PUSH
18435: LD_INT 150
18437: PUSH
18438: EMPTY
18439: LIST
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: LIST
18445: LIST
18446: LIST
18447: LIST
18448: LIST
18449: LIST
18450: LIST
18451: LIST
18452: LIST
18453: LIST
18454: PUSH
18455: LD_INT 1
18457: PPUSH
18458: LD_INT 15
18460: PPUSH
18461: CALL_OW 12
18465: ARRAY
18466: ST_TO_ADDR
// if ValidHex ( x , y ) then
18467: LD_VAR 0 3
18471: PPUSH
18472: LD_VAR 0 4
18476: PPUSH
18477: CALL_OW 488
18481: IFFALSE 18504
// begin result := [ x , y ] ;
18483: LD_ADDR_VAR 0 1
18487: PUSH
18488: LD_VAR 0 3
18492: PUSH
18493: LD_VAR 0 4
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: ST_TO_ADDR
// break ;
18502: GO 18506
// end ; end ;
18504: GO 18306
18506: POP
18507: POP
// if result then
18508: LD_VAR 0 1
18512: IFFALSE 18572
// begin ToLua ( playSibBomb() ) ;
18514: LD_STRING playSibBomb()
18516: PPUSH
18517: CALL_OW 559
// wait ( 0 0$14 ) ;
18521: LD_INT 490
18523: PPUSH
18524: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
18528: LD_VAR 0 1
18532: PUSH
18533: LD_INT 1
18535: ARRAY
18536: PPUSH
18537: LD_VAR 0 1
18541: PUSH
18542: LD_INT 2
18544: ARRAY
18545: PPUSH
18546: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
18550: LD_VAR 0 1
18554: PUSH
18555: LD_INT 1
18557: ARRAY
18558: PPUSH
18559: LD_VAR 0 1
18563: PUSH
18564: LD_INT 2
18566: ARRAY
18567: PPUSH
18568: CALL_OW 429
// end ; end ;
18572: LD_VAR 0 1
18576: RET
// every 0 0$1 trigger StreamModeActive and sReset do
18577: LD_EXP 43
18581: PUSH
18582: LD_EXP 65
18586: AND
18587: IFFALSE 18599
18589: GO 18591
18591: DISABLE
// YouLost (  ) ;
18592: LD_STRING 
18594: PPUSH
18595: CALL_OW 104
18599: END
// every 0 0$1 trigger StreamModeActive and sFog do
18600: LD_EXP 43
18604: PUSH
18605: LD_EXP 64
18609: AND
18610: IFFALSE 18624
18612: GO 18614
18614: DISABLE
// FogOff ( your_side ) ;
18615: LD_OWVAR 2
18619: PPUSH
18620: CALL_OW 344
18624: END
// every 0 0$1 trigger StreamModeActive and sSun do
18625: LD_EXP 43
18629: PUSH
18630: LD_EXP 66
18634: AND
18635: IFFALSE 18663
18637: GO 18639
18639: DISABLE
// begin solar_recharge_percent := 0 ;
18640: LD_ADDR_OWVAR 79
18644: PUSH
18645: LD_INT 0
18647: ST_TO_ADDR
// wait ( 5 5$00 ) ;
18648: LD_INT 10500
18650: PPUSH
18651: CALL_OW 67
// solar_recharge_percent := 100 ;
18655: LD_ADDR_OWVAR 79
18659: PUSH
18660: LD_INT 100
18662: ST_TO_ADDR
// end ;
18663: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
18664: LD_EXP 43
18668: PUSH
18669: LD_EXP 67
18673: AND
18674: IFFALSE 18913
18676: GO 18678
18678: DISABLE
18679: LD_INT 0
18681: PPUSH
18682: PPUSH
18683: PPUSH
// begin tmp := [ ] ;
18684: LD_ADDR_VAR 0 3
18688: PUSH
18689: EMPTY
18690: ST_TO_ADDR
// for i := 1 to 6 do
18691: LD_ADDR_VAR 0 1
18695: PUSH
18696: DOUBLE
18697: LD_INT 1
18699: DEC
18700: ST_TO_ADDR
18701: LD_INT 6
18703: PUSH
18704: FOR_TO
18705: IFFALSE 18810
// begin uc_nation := nation_nature ;
18707: LD_ADDR_OWVAR 21
18711: PUSH
18712: LD_INT 0
18714: ST_TO_ADDR
// uc_side := 0 ;
18715: LD_ADDR_OWVAR 20
18719: PUSH
18720: LD_INT 0
18722: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18723: LD_ADDR_OWVAR 29
18727: PUSH
18728: LD_INT 12
18730: PUSH
18731: LD_INT 12
18733: PUSH
18734: EMPTY
18735: LIST
18736: LIST
18737: ST_TO_ADDR
// hc_agressivity := 20 ;
18738: LD_ADDR_OWVAR 35
18742: PUSH
18743: LD_INT 20
18745: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
18746: LD_ADDR_OWVAR 28
18750: PUSH
18751: LD_INT 17
18753: ST_TO_ADDR
// hc_gallery :=  ;
18754: LD_ADDR_OWVAR 33
18758: PUSH
18759: LD_STRING 
18761: ST_TO_ADDR
// hc_name :=  ;
18762: LD_ADDR_OWVAR 26
18766: PUSH
18767: LD_STRING 
18769: ST_TO_ADDR
// un := CreateHuman ;
18770: LD_ADDR_VAR 0 2
18774: PUSH
18775: CALL_OW 44
18779: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
18780: LD_VAR 0 2
18784: PPUSH
18785: LD_INT 1
18787: PPUSH
18788: CALL_OW 51
// tmp := tmp ^ un ;
18792: LD_ADDR_VAR 0 3
18796: PUSH
18797: LD_VAR 0 3
18801: PUSH
18802: LD_VAR 0 2
18806: ADD
18807: ST_TO_ADDR
// end ;
18808: GO 18704
18810: POP
18811: POP
// repeat wait ( 0 0$1 ) ;
18812: LD_INT 35
18814: PPUSH
18815: CALL_OW 67
// for un in tmp do
18819: LD_ADDR_VAR 0 2
18823: PUSH
18824: LD_VAR 0 3
18828: PUSH
18829: FOR_IN
18830: IFFALSE 18904
// begin if IsDead ( un ) then
18832: LD_VAR 0 2
18836: PPUSH
18837: CALL_OW 301
18841: IFFALSE 18861
// begin tmp := tmp diff un ;
18843: LD_ADDR_VAR 0 3
18847: PUSH
18848: LD_VAR 0 3
18852: PUSH
18853: LD_VAR 0 2
18857: DIFF
18858: ST_TO_ADDR
// continue ;
18859: GO 18829
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18861: LD_VAR 0 2
18865: PPUSH
18866: LD_INT 3
18868: PUSH
18869: LD_INT 22
18871: PUSH
18872: LD_INT 0
18874: PUSH
18875: EMPTY
18876: LIST
18877: LIST
18878: PUSH
18879: EMPTY
18880: LIST
18881: LIST
18882: PPUSH
18883: CALL_OW 69
18887: PPUSH
18888: LD_VAR 0 2
18892: PPUSH
18893: CALL_OW 74
18897: PPUSH
18898: CALL_OW 115
// end ;
18902: GO 18829
18904: POP
18905: POP
// until not tmp ;
18906: LD_VAR 0 3
18910: NOT
18911: IFFALSE 18812
// end ;
18913: PPOPN 3
18915: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18916: LD_EXP 43
18920: PUSH
18921: LD_EXP 68
18925: AND
18926: IFFALSE 18980
18928: GO 18930
18930: DISABLE
// begin ToLua ( displayTroll(); ) ;
18931: LD_STRING displayTroll();
18933: PPUSH
18934: CALL_OW 559
// wait ( 3 3$00 ) ;
18938: LD_INT 6300
18940: PPUSH
18941: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18945: LD_STRING hideTroll();
18947: PPUSH
18948: CALL_OW 559
// wait ( 1 1$00 ) ;
18952: LD_INT 2100
18954: PPUSH
18955: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18959: LD_STRING displayTroll();
18961: PPUSH
18962: CALL_OW 559
// wait ( 1 1$00 ) ;
18966: LD_INT 2100
18968: PPUSH
18969: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18973: LD_STRING hideTroll();
18975: PPUSH
18976: CALL_OW 559
// end ;
18980: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18981: LD_EXP 43
18985: PUSH
18986: LD_EXP 69
18990: AND
18991: IFFALSE 19054
18993: GO 18995
18995: DISABLE
18996: LD_INT 0
18998: PPUSH
// begin p := 0 ;
18999: LD_ADDR_VAR 0 1
19003: PUSH
19004: LD_INT 0
19006: ST_TO_ADDR
// repeat game_speed := 1 ;
19007: LD_ADDR_OWVAR 65
19011: PUSH
19012: LD_INT 1
19014: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19015: LD_INT 35
19017: PPUSH
19018: CALL_OW 67
// p := p + 1 ;
19022: LD_ADDR_VAR 0 1
19026: PUSH
19027: LD_VAR 0 1
19031: PUSH
19032: LD_INT 1
19034: PLUS
19035: ST_TO_ADDR
// until p >= 60 ;
19036: LD_VAR 0 1
19040: PUSH
19041: LD_INT 60
19043: GREATEREQUAL
19044: IFFALSE 19007
// game_speed := 4 ;
19046: LD_ADDR_OWVAR 65
19050: PUSH
19051: LD_INT 4
19053: ST_TO_ADDR
// end ;
19054: PPOPN 1
19056: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
19057: LD_EXP 43
19061: PUSH
19062: LD_EXP 70
19066: AND
19067: IFFALSE 19213
19069: GO 19071
19071: DISABLE
19072: LD_INT 0
19074: PPUSH
19075: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19076: LD_ADDR_VAR 0 1
19080: PUSH
19081: LD_INT 22
19083: PUSH
19084: LD_OWVAR 2
19088: PUSH
19089: EMPTY
19090: LIST
19091: LIST
19092: PUSH
19093: LD_INT 2
19095: PUSH
19096: LD_INT 30
19098: PUSH
19099: LD_INT 0
19101: PUSH
19102: EMPTY
19103: LIST
19104: LIST
19105: PUSH
19106: LD_INT 30
19108: PUSH
19109: LD_INT 1
19111: PUSH
19112: EMPTY
19113: LIST
19114: LIST
19115: PUSH
19116: EMPTY
19117: LIST
19118: LIST
19119: LIST
19120: PUSH
19121: EMPTY
19122: LIST
19123: LIST
19124: PPUSH
19125: CALL_OW 69
19129: ST_TO_ADDR
// if not depot then
19130: LD_VAR 0 1
19134: NOT
19135: IFFALSE 19139
// exit ;
19137: GO 19213
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
19139: LD_ADDR_VAR 0 2
19143: PUSH
19144: LD_VAR 0 1
19148: PUSH
19149: LD_INT 1
19151: PPUSH
19152: LD_VAR 0 1
19156: PPUSH
19157: CALL_OW 12
19161: ARRAY
19162: PPUSH
19163: CALL_OW 274
19167: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
19168: LD_VAR 0 2
19172: PPUSH
19173: LD_INT 1
19175: PPUSH
19176: LD_INT 0
19178: PPUSH
19179: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
19183: LD_VAR 0 2
19187: PPUSH
19188: LD_INT 2
19190: PPUSH
19191: LD_INT 0
19193: PPUSH
19194: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
19198: LD_VAR 0 2
19202: PPUSH
19203: LD_INT 3
19205: PPUSH
19206: LD_INT 0
19208: PPUSH
19209: CALL_OW 277
// end ;
19213: PPOPN 2
19215: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
19216: LD_EXP 43
19220: PUSH
19221: LD_EXP 71
19225: AND
19226: IFFALSE 19323
19228: GO 19230
19230: DISABLE
19231: LD_INT 0
19233: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
19234: LD_ADDR_VAR 0 1
19238: PUSH
19239: LD_INT 22
19241: PUSH
19242: LD_OWVAR 2
19246: PUSH
19247: EMPTY
19248: LIST
19249: LIST
19250: PUSH
19251: LD_INT 21
19253: PUSH
19254: LD_INT 1
19256: PUSH
19257: EMPTY
19258: LIST
19259: LIST
19260: PUSH
19261: LD_INT 3
19263: PUSH
19264: LD_INT 23
19266: PUSH
19267: LD_INT 0
19269: PUSH
19270: EMPTY
19271: LIST
19272: LIST
19273: PUSH
19274: EMPTY
19275: LIST
19276: LIST
19277: PUSH
19278: EMPTY
19279: LIST
19280: LIST
19281: LIST
19282: PPUSH
19283: CALL_OW 69
19287: ST_TO_ADDR
// if not tmp then
19288: LD_VAR 0 1
19292: NOT
19293: IFFALSE 19297
// exit ;
19295: GO 19323
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
19297: LD_VAR 0 1
19301: PUSH
19302: LD_INT 1
19304: PPUSH
19305: LD_VAR 0 1
19309: PPUSH
19310: CALL_OW 12
19314: ARRAY
19315: PPUSH
19316: LD_INT 200
19318: PPUSH
19319: CALL_OW 234
// end ;
19323: PPOPN 1
19325: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
19326: LD_EXP 43
19330: PUSH
19331: LD_EXP 72
19335: AND
19336: IFFALSE 19415
19338: GO 19340
19340: DISABLE
19341: LD_INT 0
19343: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
19344: LD_ADDR_VAR 0 1
19348: PUSH
19349: LD_INT 22
19351: PUSH
19352: LD_OWVAR 2
19356: PUSH
19357: EMPTY
19358: LIST
19359: LIST
19360: PUSH
19361: LD_INT 21
19363: PUSH
19364: LD_INT 2
19366: PUSH
19367: EMPTY
19368: LIST
19369: LIST
19370: PUSH
19371: EMPTY
19372: LIST
19373: LIST
19374: PPUSH
19375: CALL_OW 69
19379: ST_TO_ADDR
// if not tmp then
19380: LD_VAR 0 1
19384: NOT
19385: IFFALSE 19389
// exit ;
19387: GO 19415
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
19389: LD_VAR 0 1
19393: PUSH
19394: LD_INT 1
19396: PPUSH
19397: LD_VAR 0 1
19401: PPUSH
19402: CALL_OW 12
19406: ARRAY
19407: PPUSH
19408: LD_INT 60
19410: PPUSH
19411: CALL_OW 234
// end ;
19415: PPOPN 1
19417: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
19418: LD_EXP 43
19422: PUSH
19423: LD_EXP 73
19427: AND
19428: IFFALSE 19527
19430: GO 19432
19432: DISABLE
19433: LD_INT 0
19435: PPUSH
19436: PPUSH
// begin enable ;
19437: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
19438: LD_ADDR_VAR 0 1
19442: PUSH
19443: LD_INT 22
19445: PUSH
19446: LD_OWVAR 2
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PUSH
19455: LD_INT 61
19457: PUSH
19458: EMPTY
19459: LIST
19460: PUSH
19461: LD_INT 33
19463: PUSH
19464: LD_INT 2
19466: PUSH
19467: EMPTY
19468: LIST
19469: LIST
19470: PUSH
19471: EMPTY
19472: LIST
19473: LIST
19474: LIST
19475: PPUSH
19476: CALL_OW 69
19480: ST_TO_ADDR
// if not tmp then
19481: LD_VAR 0 1
19485: NOT
19486: IFFALSE 19490
// exit ;
19488: GO 19527
// for i in tmp do
19490: LD_ADDR_VAR 0 2
19494: PUSH
19495: LD_VAR 0 1
19499: PUSH
19500: FOR_IN
19501: IFFALSE 19525
// if IsControledBy ( i ) then
19503: LD_VAR 0 2
19507: PPUSH
19508: CALL_OW 312
19512: IFFALSE 19523
// ComUnlink ( i ) ;
19514: LD_VAR 0 2
19518: PPUSH
19519: CALL_OW 136
19523: GO 19500
19525: POP
19526: POP
// end ;
19527: PPOPN 2
19529: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
19530: LD_EXP 43
19534: PUSH
19535: LD_EXP 74
19539: AND
19540: IFFALSE 19680
19542: GO 19544
19544: DISABLE
19545: LD_INT 0
19547: PPUSH
19548: PPUSH
// begin ToLua ( displayPowell(); ) ;
19549: LD_STRING displayPowell();
19551: PPUSH
19552: CALL_OW 559
// uc_side := 0 ;
19556: LD_ADDR_OWVAR 20
19560: PUSH
19561: LD_INT 0
19563: ST_TO_ADDR
// uc_nation := 2 ;
19564: LD_ADDR_OWVAR 21
19568: PUSH
19569: LD_INT 2
19571: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19572: LD_ADDR_OWVAR 37
19576: PUSH
19577: LD_INT 14
19579: ST_TO_ADDR
// vc_engine := engine_siberite ;
19580: LD_ADDR_OWVAR 39
19584: PUSH
19585: LD_INT 3
19587: ST_TO_ADDR
// vc_control := control_apeman ;
19588: LD_ADDR_OWVAR 38
19592: PUSH
19593: LD_INT 5
19595: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
19596: LD_ADDR_OWVAR 40
19600: PUSH
19601: LD_INT 29
19603: ST_TO_ADDR
// un := CreateVehicle ;
19604: LD_ADDR_VAR 0 2
19608: PUSH
19609: CALL_OW 45
19613: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19614: LD_VAR 0 2
19618: PPUSH
19619: LD_INT 1
19621: PPUSH
19622: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19626: LD_INT 35
19628: PPUSH
19629: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19633: LD_VAR 0 2
19637: PPUSH
19638: LD_INT 22
19640: PUSH
19641: LD_OWVAR 2
19645: PUSH
19646: EMPTY
19647: LIST
19648: LIST
19649: PPUSH
19650: CALL_OW 69
19654: PPUSH
19655: LD_VAR 0 2
19659: PPUSH
19660: CALL_OW 74
19664: PPUSH
19665: CALL_OW 115
// until IsDead ( un ) ;
19669: LD_VAR 0 2
19673: PPUSH
19674: CALL_OW 301
19678: IFFALSE 19626
// end ;
19680: PPOPN 2
19682: END
// every 0 0$1 trigger StreamModeActive and sStu do
19683: LD_EXP 43
19687: PUSH
19688: LD_EXP 82
19692: AND
19693: IFFALSE 19709
19695: GO 19697
19697: DISABLE
// begin ToLua ( displayStucuk(); ) ;
19698: LD_STRING displayStucuk();
19700: PPUSH
19701: CALL_OW 559
// ResetFog ;
19705: CALL_OW 335
// end ;
19709: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
19710: LD_EXP 43
19714: PUSH
19715: LD_EXP 75
19719: AND
19720: IFFALSE 19861
19722: GO 19724
19724: DISABLE
19725: LD_INT 0
19727: PPUSH
19728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19729: LD_ADDR_VAR 0 2
19733: PUSH
19734: LD_INT 22
19736: PUSH
19737: LD_OWVAR 2
19741: PUSH
19742: EMPTY
19743: LIST
19744: LIST
19745: PUSH
19746: LD_INT 21
19748: PUSH
19749: LD_INT 1
19751: PUSH
19752: EMPTY
19753: LIST
19754: LIST
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PPUSH
19760: CALL_OW 69
19764: ST_TO_ADDR
// if not tmp then
19765: LD_VAR 0 2
19769: NOT
19770: IFFALSE 19774
// exit ;
19772: GO 19861
// un := tmp [ rand ( 1 , tmp ) ] ;
19774: LD_ADDR_VAR 0 1
19778: PUSH
19779: LD_VAR 0 2
19783: PUSH
19784: LD_INT 1
19786: PPUSH
19787: LD_VAR 0 2
19791: PPUSH
19792: CALL_OW 12
19796: ARRAY
19797: ST_TO_ADDR
// SetSide ( un , 0 ) ;
19798: LD_VAR 0 1
19802: PPUSH
19803: LD_INT 0
19805: PPUSH
19806: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
19810: LD_VAR 0 1
19814: PPUSH
19815: LD_OWVAR 3
19819: PUSH
19820: LD_VAR 0 1
19824: DIFF
19825: PPUSH
19826: LD_VAR 0 1
19830: PPUSH
19831: CALL_OW 74
19835: PPUSH
19836: CALL_OW 115
// wait ( 0 0$20 ) ;
19840: LD_INT 700
19842: PPUSH
19843: CALL_OW 67
// SetSide ( un , your_side ) ;
19847: LD_VAR 0 1
19851: PPUSH
19852: LD_OWVAR 2
19856: PPUSH
19857: CALL_OW 235
// end ;
19861: PPOPN 2
19863: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19864: LD_EXP 43
19868: PUSH
19869: LD_EXP 76
19873: AND
19874: IFFALSE 19980
19876: GO 19878
19878: DISABLE
19879: LD_INT 0
19881: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19882: LD_ADDR_VAR 0 1
19886: PUSH
19887: LD_INT 22
19889: PUSH
19890: LD_OWVAR 2
19894: PUSH
19895: EMPTY
19896: LIST
19897: LIST
19898: PUSH
19899: LD_INT 2
19901: PUSH
19902: LD_INT 30
19904: PUSH
19905: LD_INT 0
19907: PUSH
19908: EMPTY
19909: LIST
19910: LIST
19911: PUSH
19912: LD_INT 30
19914: PUSH
19915: LD_INT 1
19917: PUSH
19918: EMPTY
19919: LIST
19920: LIST
19921: PUSH
19922: EMPTY
19923: LIST
19924: LIST
19925: LIST
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: PPUSH
19931: CALL_OW 69
19935: ST_TO_ADDR
// if not depot then
19936: LD_VAR 0 1
19940: NOT
19941: IFFALSE 19945
// exit ;
19943: GO 19980
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19945: LD_VAR 0 1
19949: PUSH
19950: LD_INT 1
19952: ARRAY
19953: PPUSH
19954: CALL_OW 250
19958: PPUSH
19959: LD_VAR 0 1
19963: PUSH
19964: LD_INT 1
19966: ARRAY
19967: PPUSH
19968: CALL_OW 251
19972: PPUSH
19973: LD_INT 70
19975: PPUSH
19976: CALL_OW 495
// end ;
19980: PPOPN 1
19982: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19983: LD_EXP 43
19987: PUSH
19988: LD_EXP 77
19992: AND
19993: IFFALSE 20204
19995: GO 19997
19997: DISABLE
19998: LD_INT 0
20000: PPUSH
20001: PPUSH
20002: PPUSH
20003: PPUSH
20004: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
20005: LD_ADDR_VAR 0 5
20009: PUSH
20010: LD_INT 22
20012: PUSH
20013: LD_OWVAR 2
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: PUSH
20022: LD_INT 21
20024: PUSH
20025: LD_INT 1
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PPUSH
20036: CALL_OW 69
20040: ST_TO_ADDR
// if not tmp then
20041: LD_VAR 0 5
20045: NOT
20046: IFFALSE 20050
// exit ;
20048: GO 20204
// for i in tmp do
20050: LD_ADDR_VAR 0 1
20054: PUSH
20055: LD_VAR 0 5
20059: PUSH
20060: FOR_IN
20061: IFFALSE 20202
// begin d := rand ( 0 , 5 ) ;
20063: LD_ADDR_VAR 0 4
20067: PUSH
20068: LD_INT 0
20070: PPUSH
20071: LD_INT 5
20073: PPUSH
20074: CALL_OW 12
20078: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
20079: LD_ADDR_VAR 0 2
20083: PUSH
20084: LD_VAR 0 1
20088: PPUSH
20089: CALL_OW 250
20093: PPUSH
20094: LD_VAR 0 4
20098: PPUSH
20099: LD_INT 3
20101: PPUSH
20102: LD_INT 12
20104: PPUSH
20105: CALL_OW 12
20109: PPUSH
20110: CALL_OW 272
20114: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
20115: LD_ADDR_VAR 0 3
20119: PUSH
20120: LD_VAR 0 1
20124: PPUSH
20125: CALL_OW 251
20129: PPUSH
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_INT 3
20137: PPUSH
20138: LD_INT 12
20140: PPUSH
20141: CALL_OW 12
20145: PPUSH
20146: CALL_OW 273
20150: ST_TO_ADDR
// if ValidHex ( x , y ) then
20151: LD_VAR 0 2
20155: PPUSH
20156: LD_VAR 0 3
20160: PPUSH
20161: CALL_OW 488
20165: IFFALSE 20200
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
20167: LD_VAR 0 1
20171: PPUSH
20172: LD_VAR 0 2
20176: PPUSH
20177: LD_VAR 0 3
20181: PPUSH
20182: LD_INT 3
20184: PPUSH
20185: LD_INT 6
20187: PPUSH
20188: CALL_OW 12
20192: PPUSH
20193: LD_INT 1
20195: PPUSH
20196: CALL_OW 483
// end ;
20200: GO 20060
20202: POP
20203: POP
// end ;
20204: PPOPN 5
20206: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
20207: LD_EXP 43
20211: PUSH
20212: LD_EXP 78
20216: AND
20217: IFFALSE 20311
20219: GO 20221
20221: DISABLE
20222: LD_INT 0
20224: PPUSH
20225: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
20226: LD_ADDR_VAR 0 2
20230: PUSH
20231: LD_INT 22
20233: PUSH
20234: LD_OWVAR 2
20238: PUSH
20239: EMPTY
20240: LIST
20241: LIST
20242: PUSH
20243: LD_INT 32
20245: PUSH
20246: LD_INT 1
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PUSH
20253: LD_INT 21
20255: PUSH
20256: LD_INT 2
20258: PUSH
20259: EMPTY
20260: LIST
20261: LIST
20262: PUSH
20263: EMPTY
20264: LIST
20265: LIST
20266: LIST
20267: PPUSH
20268: CALL_OW 69
20272: ST_TO_ADDR
// if not tmp then
20273: LD_VAR 0 2
20277: NOT
20278: IFFALSE 20282
// exit ;
20280: GO 20311
// for i in tmp do
20282: LD_ADDR_VAR 0 1
20286: PUSH
20287: LD_VAR 0 2
20291: PUSH
20292: FOR_IN
20293: IFFALSE 20309
// SetFuel ( i , 0 ) ;
20295: LD_VAR 0 1
20299: PPUSH
20300: LD_INT 0
20302: PPUSH
20303: CALL_OW 240
20307: GO 20292
20309: POP
20310: POP
// end ;
20311: PPOPN 2
20313: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
20314: LD_EXP 43
20318: PUSH
20319: LD_EXP 79
20323: AND
20324: IFFALSE 20390
20326: GO 20328
20328: DISABLE
20329: LD_INT 0
20331: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
20332: LD_ADDR_VAR 0 1
20336: PUSH
20337: LD_INT 22
20339: PUSH
20340: LD_OWVAR 2
20344: PUSH
20345: EMPTY
20346: LIST
20347: LIST
20348: PUSH
20349: LD_INT 30
20351: PUSH
20352: LD_INT 29
20354: PUSH
20355: EMPTY
20356: LIST
20357: LIST
20358: PUSH
20359: EMPTY
20360: LIST
20361: LIST
20362: PPUSH
20363: CALL_OW 69
20367: ST_TO_ADDR
// if not tmp then
20368: LD_VAR 0 1
20372: NOT
20373: IFFALSE 20377
// exit ;
20375: GO 20390
// DestroyUnit ( tmp [ 1 ] ) ;
20377: LD_VAR 0 1
20381: PUSH
20382: LD_INT 1
20384: ARRAY
20385: PPUSH
20386: CALL_OW 65
// end ;
20390: PPOPN 1
20392: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
20393: LD_EXP 43
20397: PUSH
20398: LD_EXP 81
20402: AND
20403: IFFALSE 20532
20405: GO 20407
20407: DISABLE
20408: LD_INT 0
20410: PPUSH
// begin uc_side := 0 ;
20411: LD_ADDR_OWVAR 20
20415: PUSH
20416: LD_INT 0
20418: ST_TO_ADDR
// uc_nation := nation_arabian ;
20419: LD_ADDR_OWVAR 21
20423: PUSH
20424: LD_INT 2
20426: ST_TO_ADDR
// hc_gallery :=  ;
20427: LD_ADDR_OWVAR 33
20431: PUSH
20432: LD_STRING 
20434: ST_TO_ADDR
// hc_name :=  ;
20435: LD_ADDR_OWVAR 26
20439: PUSH
20440: LD_STRING 
20442: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
20443: LD_INT 1
20445: PPUSH
20446: LD_INT 11
20448: PPUSH
20449: LD_INT 10
20451: PPUSH
20452: CALL_OW 380
// un := CreateHuman ;
20456: LD_ADDR_VAR 0 1
20460: PUSH
20461: CALL_OW 44
20465: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
20466: LD_VAR 0 1
20470: PPUSH
20471: LD_INT 1
20473: PPUSH
20474: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
20478: LD_INT 35
20480: PPUSH
20481: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
20485: LD_VAR 0 1
20489: PPUSH
20490: LD_INT 22
20492: PUSH
20493: LD_OWVAR 2
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: PPUSH
20502: CALL_OW 69
20506: PPUSH
20507: LD_VAR 0 1
20511: PPUSH
20512: CALL_OW 74
20516: PPUSH
20517: CALL_OW 115
// until IsDead ( un ) ;
20521: LD_VAR 0 1
20525: PPUSH
20526: CALL_OW 301
20530: IFFALSE 20478
// end ;
20532: PPOPN 1
20534: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
20535: LD_EXP 43
20539: PUSH
20540: LD_EXP 83
20544: AND
20545: IFFALSE 20557
20547: GO 20549
20549: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
20550: LD_STRING earthquake(getX(game), 0, 32)
20552: PPUSH
20553: CALL_OW 559
20557: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
20558: LD_EXP 43
20562: PUSH
20563: LD_EXP 84
20567: AND
20568: IFFALSE 20659
20570: GO 20572
20572: DISABLE
20573: LD_INT 0
20575: PPUSH
// begin enable ;
20576: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
20577: LD_ADDR_VAR 0 1
20581: PUSH
20582: LD_INT 22
20584: PUSH
20585: LD_OWVAR 2
20589: PUSH
20590: EMPTY
20591: LIST
20592: LIST
20593: PUSH
20594: LD_INT 21
20596: PUSH
20597: LD_INT 2
20599: PUSH
20600: EMPTY
20601: LIST
20602: LIST
20603: PUSH
20604: LD_INT 33
20606: PUSH
20607: LD_INT 3
20609: PUSH
20610: EMPTY
20611: LIST
20612: LIST
20613: PUSH
20614: EMPTY
20615: LIST
20616: LIST
20617: LIST
20618: PPUSH
20619: CALL_OW 69
20623: ST_TO_ADDR
// if not tmp then
20624: LD_VAR 0 1
20628: NOT
20629: IFFALSE 20633
// exit ;
20631: GO 20659
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20633: LD_VAR 0 1
20637: PUSH
20638: LD_INT 1
20640: PPUSH
20641: LD_VAR 0 1
20645: PPUSH
20646: CALL_OW 12
20650: ARRAY
20651: PPUSH
20652: LD_INT 1
20654: PPUSH
20655: CALL_OW 234
// end ;
20659: PPOPN 1
20661: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
20662: LD_EXP 43
20666: PUSH
20667: LD_EXP 85
20671: AND
20672: IFFALSE 20813
20674: GO 20676
20676: DISABLE
20677: LD_INT 0
20679: PPUSH
20680: PPUSH
20681: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20682: LD_ADDR_VAR 0 3
20686: PUSH
20687: LD_INT 22
20689: PUSH
20690: LD_OWVAR 2
20694: PUSH
20695: EMPTY
20696: LIST
20697: LIST
20698: PUSH
20699: LD_INT 25
20701: PUSH
20702: LD_INT 1
20704: PUSH
20705: EMPTY
20706: LIST
20707: LIST
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: PPUSH
20713: CALL_OW 69
20717: ST_TO_ADDR
// if not tmp then
20718: LD_VAR 0 3
20722: NOT
20723: IFFALSE 20727
// exit ;
20725: GO 20813
// un := tmp [ rand ( 1 , tmp ) ] ;
20727: LD_ADDR_VAR 0 2
20731: PUSH
20732: LD_VAR 0 3
20736: PUSH
20737: LD_INT 1
20739: PPUSH
20740: LD_VAR 0 3
20744: PPUSH
20745: CALL_OW 12
20749: ARRAY
20750: ST_TO_ADDR
// if Crawls ( un ) then
20751: LD_VAR 0 2
20755: PPUSH
20756: CALL_OW 318
20760: IFFALSE 20771
// ComWalk ( un ) ;
20762: LD_VAR 0 2
20766: PPUSH
20767: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
20771: LD_VAR 0 2
20775: PPUSH
20776: LD_INT 9
20778: PPUSH
20779: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
20783: LD_INT 28
20785: PPUSH
20786: LD_OWVAR 2
20790: PPUSH
20791: LD_INT 2
20793: PPUSH
20794: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
20798: LD_INT 29
20800: PPUSH
20801: LD_OWVAR 2
20805: PPUSH
20806: LD_INT 2
20808: PPUSH
20809: CALL_OW 322
// end ;
20813: PPOPN 3
20815: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
20816: LD_EXP 43
20820: PUSH
20821: LD_EXP 86
20825: AND
20826: IFFALSE 20937
20828: GO 20830
20830: DISABLE
20831: LD_INT 0
20833: PPUSH
20834: PPUSH
20835: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20836: LD_ADDR_VAR 0 3
20840: PUSH
20841: LD_INT 22
20843: PUSH
20844: LD_OWVAR 2
20848: PUSH
20849: EMPTY
20850: LIST
20851: LIST
20852: PUSH
20853: LD_INT 25
20855: PUSH
20856: LD_INT 1
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: PUSH
20863: EMPTY
20864: LIST
20865: LIST
20866: PPUSH
20867: CALL_OW 69
20871: ST_TO_ADDR
// if not tmp then
20872: LD_VAR 0 3
20876: NOT
20877: IFFALSE 20881
// exit ;
20879: GO 20937
// un := tmp [ rand ( 1 , tmp ) ] ;
20881: LD_ADDR_VAR 0 2
20885: PUSH
20886: LD_VAR 0 3
20890: PUSH
20891: LD_INT 1
20893: PPUSH
20894: LD_VAR 0 3
20898: PPUSH
20899: CALL_OW 12
20903: ARRAY
20904: ST_TO_ADDR
// if Crawls ( un ) then
20905: LD_VAR 0 2
20909: PPUSH
20910: CALL_OW 318
20914: IFFALSE 20925
// ComWalk ( un ) ;
20916: LD_VAR 0 2
20920: PPUSH
20921: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20925: LD_VAR 0 2
20929: PPUSH
20930: LD_INT 8
20932: PPUSH
20933: CALL_OW 336
// end ;
20937: PPOPN 3
20939: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20940: LD_EXP 43
20944: PUSH
20945: LD_EXP 87
20949: AND
20950: IFFALSE 21094
20952: GO 20954
20954: DISABLE
20955: LD_INT 0
20957: PPUSH
20958: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20959: LD_ADDR_VAR 0 2
20963: PUSH
20964: LD_INT 22
20966: PUSH
20967: LD_OWVAR 2
20971: PUSH
20972: EMPTY
20973: LIST
20974: LIST
20975: PUSH
20976: LD_INT 21
20978: PUSH
20979: LD_INT 2
20981: PUSH
20982: EMPTY
20983: LIST
20984: LIST
20985: PUSH
20986: LD_INT 2
20988: PUSH
20989: LD_INT 34
20991: PUSH
20992: LD_INT 12
20994: PUSH
20995: EMPTY
20996: LIST
20997: LIST
20998: PUSH
20999: LD_INT 34
21001: PUSH
21002: LD_INT 51
21004: PUSH
21005: EMPTY
21006: LIST
21007: LIST
21008: PUSH
21009: LD_INT 34
21011: PUSH
21012: LD_INT 32
21014: PUSH
21015: EMPTY
21016: LIST
21017: LIST
21018: PUSH
21019: EMPTY
21020: LIST
21021: LIST
21022: LIST
21023: LIST
21024: PUSH
21025: EMPTY
21026: LIST
21027: LIST
21028: LIST
21029: PPUSH
21030: CALL_OW 69
21034: ST_TO_ADDR
// if not tmp then
21035: LD_VAR 0 2
21039: NOT
21040: IFFALSE 21044
// exit ;
21042: GO 21094
// for i in tmp do
21044: LD_ADDR_VAR 0 1
21048: PUSH
21049: LD_VAR 0 2
21053: PUSH
21054: FOR_IN
21055: IFFALSE 21092
// if GetCargo ( i , mat_artifact ) = 0 then
21057: LD_VAR 0 1
21061: PPUSH
21062: LD_INT 4
21064: PPUSH
21065: CALL_OW 289
21069: PUSH
21070: LD_INT 0
21072: EQUAL
21073: IFFALSE 21090
// SetCargo ( i , mat_siberit , 100 ) ;
21075: LD_VAR 0 1
21079: PPUSH
21080: LD_INT 3
21082: PPUSH
21083: LD_INT 100
21085: PPUSH
21086: CALL_OW 290
21090: GO 21054
21092: POP
21093: POP
// end ;
21094: PPOPN 2
21096: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
21097: LD_EXP 43
21101: PUSH
21102: LD_EXP 88
21106: AND
21107: IFFALSE 21290
21109: GO 21111
21111: DISABLE
21112: LD_INT 0
21114: PPUSH
21115: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
21116: LD_ADDR_VAR 0 2
21120: PUSH
21121: LD_INT 22
21123: PUSH
21124: LD_OWVAR 2
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: PPUSH
21133: CALL_OW 69
21137: ST_TO_ADDR
// if not tmp then
21138: LD_VAR 0 2
21142: NOT
21143: IFFALSE 21147
// exit ;
21145: GO 21290
// for i := 1 to 2 do
21147: LD_ADDR_VAR 0 1
21151: PUSH
21152: DOUBLE
21153: LD_INT 1
21155: DEC
21156: ST_TO_ADDR
21157: LD_INT 2
21159: PUSH
21160: FOR_TO
21161: IFFALSE 21288
// begin uc_side := your_side ;
21163: LD_ADDR_OWVAR 20
21167: PUSH
21168: LD_OWVAR 2
21172: ST_TO_ADDR
// uc_nation := nation_american ;
21173: LD_ADDR_OWVAR 21
21177: PUSH
21178: LD_INT 1
21180: ST_TO_ADDR
// vc_chassis := us_morphling ;
21181: LD_ADDR_OWVAR 37
21185: PUSH
21186: LD_INT 5
21188: ST_TO_ADDR
// vc_engine := engine_siberite ;
21189: LD_ADDR_OWVAR 39
21193: PUSH
21194: LD_INT 3
21196: ST_TO_ADDR
// vc_control := control_computer ;
21197: LD_ADDR_OWVAR 38
21201: PUSH
21202: LD_INT 3
21204: ST_TO_ADDR
// vc_weapon := us_double_laser ;
21205: LD_ADDR_OWVAR 40
21209: PUSH
21210: LD_INT 10
21212: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
21213: LD_VAR 0 2
21217: PUSH
21218: LD_INT 1
21220: ARRAY
21221: PPUSH
21222: CALL_OW 310
21226: NOT
21227: IFFALSE 21274
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
21229: CALL_OW 45
21233: PPUSH
21234: LD_VAR 0 2
21238: PUSH
21239: LD_INT 1
21241: ARRAY
21242: PPUSH
21243: CALL_OW 250
21247: PPUSH
21248: LD_VAR 0 2
21252: PUSH
21253: LD_INT 1
21255: ARRAY
21256: PPUSH
21257: CALL_OW 251
21261: PPUSH
21262: LD_INT 12
21264: PPUSH
21265: LD_INT 1
21267: PPUSH
21268: CALL_OW 50
21272: GO 21286
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
21274: CALL_OW 45
21278: PPUSH
21279: LD_INT 1
21281: PPUSH
21282: CALL_OW 51
// end ;
21286: GO 21160
21288: POP
21289: POP
// end ;
21290: PPOPN 2
21292: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
21293: LD_EXP 43
21297: PUSH
21298: LD_EXP 89
21302: AND
21303: IFFALSE 21525
21305: GO 21307
21307: DISABLE
21308: LD_INT 0
21310: PPUSH
21311: PPUSH
21312: PPUSH
21313: PPUSH
21314: PPUSH
21315: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21316: LD_ADDR_VAR 0 6
21320: PUSH
21321: LD_INT 22
21323: PUSH
21324: LD_OWVAR 2
21328: PUSH
21329: EMPTY
21330: LIST
21331: LIST
21332: PUSH
21333: LD_INT 21
21335: PUSH
21336: LD_INT 1
21338: PUSH
21339: EMPTY
21340: LIST
21341: LIST
21342: PUSH
21343: LD_INT 3
21345: PUSH
21346: LD_INT 23
21348: PUSH
21349: LD_INT 0
21351: PUSH
21352: EMPTY
21353: LIST
21354: LIST
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: LIST
21364: PPUSH
21365: CALL_OW 69
21369: ST_TO_ADDR
// if not tmp then
21370: LD_VAR 0 6
21374: NOT
21375: IFFALSE 21379
// exit ;
21377: GO 21525
// s1 := rand ( 1 , 4 ) ;
21379: LD_ADDR_VAR 0 2
21383: PUSH
21384: LD_INT 1
21386: PPUSH
21387: LD_INT 4
21389: PPUSH
21390: CALL_OW 12
21394: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
21395: LD_ADDR_VAR 0 4
21399: PUSH
21400: LD_VAR 0 6
21404: PUSH
21405: LD_INT 1
21407: ARRAY
21408: PPUSH
21409: LD_VAR 0 2
21413: PPUSH
21414: CALL_OW 259
21418: ST_TO_ADDR
// if s1 = 1 then
21419: LD_VAR 0 2
21423: PUSH
21424: LD_INT 1
21426: EQUAL
21427: IFFALSE 21447
// s2 := rand ( 2 , 4 ) else
21429: LD_ADDR_VAR 0 3
21433: PUSH
21434: LD_INT 2
21436: PPUSH
21437: LD_INT 4
21439: PPUSH
21440: CALL_OW 12
21444: ST_TO_ADDR
21445: GO 21455
// s2 := 1 ;
21447: LD_ADDR_VAR 0 3
21451: PUSH
21452: LD_INT 1
21454: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
21455: LD_ADDR_VAR 0 5
21459: PUSH
21460: LD_VAR 0 6
21464: PUSH
21465: LD_INT 1
21467: ARRAY
21468: PPUSH
21469: LD_VAR 0 3
21473: PPUSH
21474: CALL_OW 259
21478: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
21479: LD_VAR 0 6
21483: PUSH
21484: LD_INT 1
21486: ARRAY
21487: PPUSH
21488: LD_VAR 0 2
21492: PPUSH
21493: LD_VAR 0 5
21497: PPUSH
21498: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
21502: LD_VAR 0 6
21506: PUSH
21507: LD_INT 1
21509: ARRAY
21510: PPUSH
21511: LD_VAR 0 3
21515: PPUSH
21516: LD_VAR 0 4
21520: PPUSH
21521: CALL_OW 237
// end ;
21525: PPOPN 6
21527: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
21528: LD_EXP 43
21532: PUSH
21533: LD_EXP 90
21537: AND
21538: IFFALSE 21617
21540: GO 21542
21542: DISABLE
21543: LD_INT 0
21545: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
21546: LD_ADDR_VAR 0 1
21550: PUSH
21551: LD_INT 22
21553: PUSH
21554: LD_OWVAR 2
21558: PUSH
21559: EMPTY
21560: LIST
21561: LIST
21562: PUSH
21563: LD_INT 30
21565: PUSH
21566: LD_INT 3
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: PPUSH
21577: CALL_OW 69
21581: ST_TO_ADDR
// if not tmp then
21582: LD_VAR 0 1
21586: NOT
21587: IFFALSE 21591
// exit ;
21589: GO 21617
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21591: LD_VAR 0 1
21595: PUSH
21596: LD_INT 1
21598: PPUSH
21599: LD_VAR 0 1
21603: PPUSH
21604: CALL_OW 12
21608: ARRAY
21609: PPUSH
21610: LD_INT 1
21612: PPUSH
21613: CALL_OW 234
// end ;
21617: PPOPN 1
21619: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
21620: LD_EXP 43
21624: PUSH
21625: LD_EXP 91
21629: AND
21630: IFFALSE 21742
21632: GO 21634
21634: DISABLE
21635: LD_INT 0
21637: PPUSH
21638: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
21639: LD_ADDR_VAR 0 2
21643: PUSH
21644: LD_INT 22
21646: PUSH
21647: LD_OWVAR 2
21651: PUSH
21652: EMPTY
21653: LIST
21654: LIST
21655: PUSH
21656: LD_INT 2
21658: PUSH
21659: LD_INT 30
21661: PUSH
21662: LD_INT 27
21664: PUSH
21665: EMPTY
21666: LIST
21667: LIST
21668: PUSH
21669: LD_INT 30
21671: PUSH
21672: LD_INT 26
21674: PUSH
21675: EMPTY
21676: LIST
21677: LIST
21678: PUSH
21679: LD_INT 30
21681: PUSH
21682: LD_INT 28
21684: PUSH
21685: EMPTY
21686: LIST
21687: LIST
21688: PUSH
21689: EMPTY
21690: LIST
21691: LIST
21692: LIST
21693: LIST
21694: PUSH
21695: EMPTY
21696: LIST
21697: LIST
21698: PPUSH
21699: CALL_OW 69
21703: ST_TO_ADDR
// if not tmp then
21704: LD_VAR 0 2
21708: NOT
21709: IFFALSE 21713
// exit ;
21711: GO 21742
// for i in tmp do
21713: LD_ADDR_VAR 0 1
21717: PUSH
21718: LD_VAR 0 2
21722: PUSH
21723: FOR_IN
21724: IFFALSE 21740
// SetLives ( i , 1 ) ;
21726: LD_VAR 0 1
21730: PPUSH
21731: LD_INT 1
21733: PPUSH
21734: CALL_OW 234
21738: GO 21723
21740: POP
21741: POP
// end ;
21742: PPOPN 2
21744: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
21745: LD_EXP 43
21749: PUSH
21750: LD_EXP 92
21754: AND
21755: IFFALSE 22029
21757: GO 21759
21759: DISABLE
21760: LD_INT 0
21762: PPUSH
21763: PPUSH
21764: PPUSH
// begin i := rand ( 1 , 7 ) ;
21765: LD_ADDR_VAR 0 1
21769: PUSH
21770: LD_INT 1
21772: PPUSH
21773: LD_INT 7
21775: PPUSH
21776: CALL_OW 12
21780: ST_TO_ADDR
// case i of 1 :
21781: LD_VAR 0 1
21785: PUSH
21786: LD_INT 1
21788: DOUBLE
21789: EQUAL
21790: IFTRUE 21794
21792: GO 21804
21794: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
21795: LD_STRING earthquake(getX(game), 0, 32)
21797: PPUSH
21798: CALL_OW 559
21802: GO 22029
21804: LD_INT 2
21806: DOUBLE
21807: EQUAL
21808: IFTRUE 21812
21810: GO 21826
21812: POP
// begin ToLua ( displayStucuk(); ) ;
21813: LD_STRING displayStucuk();
21815: PPUSH
21816: CALL_OW 559
// ResetFog ;
21820: CALL_OW 335
// end ; 3 :
21824: GO 22029
21826: LD_INT 3
21828: DOUBLE
21829: EQUAL
21830: IFTRUE 21834
21832: GO 21938
21834: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21835: LD_ADDR_VAR 0 2
21839: PUSH
21840: LD_INT 22
21842: PUSH
21843: LD_OWVAR 2
21847: PUSH
21848: EMPTY
21849: LIST
21850: LIST
21851: PUSH
21852: LD_INT 25
21854: PUSH
21855: LD_INT 1
21857: PUSH
21858: EMPTY
21859: LIST
21860: LIST
21861: PUSH
21862: EMPTY
21863: LIST
21864: LIST
21865: PPUSH
21866: CALL_OW 69
21870: ST_TO_ADDR
// if not tmp then
21871: LD_VAR 0 2
21875: NOT
21876: IFFALSE 21880
// exit ;
21878: GO 22029
// un := tmp [ rand ( 1 , tmp ) ] ;
21880: LD_ADDR_VAR 0 3
21884: PUSH
21885: LD_VAR 0 2
21889: PUSH
21890: LD_INT 1
21892: PPUSH
21893: LD_VAR 0 2
21897: PPUSH
21898: CALL_OW 12
21902: ARRAY
21903: ST_TO_ADDR
// if Crawls ( un ) then
21904: LD_VAR 0 3
21908: PPUSH
21909: CALL_OW 318
21913: IFFALSE 21924
// ComWalk ( un ) ;
21915: LD_VAR 0 3
21919: PPUSH
21920: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21924: LD_VAR 0 3
21928: PPUSH
21929: LD_INT 8
21931: PPUSH
21932: CALL_OW 336
// end ; 4 :
21936: GO 22029
21938: LD_INT 4
21940: DOUBLE
21941: EQUAL
21942: IFTRUE 21946
21944: GO 22007
21946: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21947: LD_ADDR_VAR 0 2
21951: PUSH
21952: LD_INT 22
21954: PUSH
21955: LD_OWVAR 2
21959: PUSH
21960: EMPTY
21961: LIST
21962: LIST
21963: PUSH
21964: LD_INT 30
21966: PUSH
21967: LD_INT 29
21969: PUSH
21970: EMPTY
21971: LIST
21972: LIST
21973: PUSH
21974: EMPTY
21975: LIST
21976: LIST
21977: PPUSH
21978: CALL_OW 69
21982: ST_TO_ADDR
// if not tmp then
21983: LD_VAR 0 2
21987: NOT
21988: IFFALSE 21992
// exit ;
21990: GO 22029
// DestroyUnit ( tmp [ 1 ] ) ;
21992: LD_VAR 0 2
21996: PUSH
21997: LD_INT 1
21999: ARRAY
22000: PPUSH
22001: CALL_OW 65
// end ; 5 .. 7 :
22005: GO 22029
22007: LD_INT 5
22009: DOUBLE
22010: GREATEREQUAL
22011: IFFALSE 22019
22013: LD_INT 7
22015: DOUBLE
22016: LESSEQUAL
22017: IFTRUE 22021
22019: GO 22028
22021: POP
// StreamSibBomb ; end ;
22022: CALL 18279 0 0
22026: GO 22029
22028: POP
// end ;
22029: PPOPN 3
22031: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
22032: LD_EXP 43
22036: PUSH
22037: LD_EXP 93
22041: AND
22042: IFFALSE 22198
22044: GO 22046
22046: DISABLE
22047: LD_INT 0
22049: PPUSH
22050: PPUSH
22051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
22052: LD_ADDR_VAR 0 2
22056: PUSH
22057: LD_INT 81
22059: PUSH
22060: LD_OWVAR 2
22064: PUSH
22065: EMPTY
22066: LIST
22067: LIST
22068: PUSH
22069: LD_INT 2
22071: PUSH
22072: LD_INT 21
22074: PUSH
22075: LD_INT 1
22077: PUSH
22078: EMPTY
22079: LIST
22080: LIST
22081: PUSH
22082: LD_INT 21
22084: PUSH
22085: LD_INT 2
22087: PUSH
22088: EMPTY
22089: LIST
22090: LIST
22091: PUSH
22092: EMPTY
22093: LIST
22094: LIST
22095: LIST
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PPUSH
22101: CALL_OW 69
22105: ST_TO_ADDR
// if not tmp then
22106: LD_VAR 0 2
22110: NOT
22111: IFFALSE 22115
// exit ;
22113: GO 22198
// p := 0 ;
22115: LD_ADDR_VAR 0 3
22119: PUSH
22120: LD_INT 0
22122: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22123: LD_INT 35
22125: PPUSH
22126: CALL_OW 67
// p := p + 1 ;
22130: LD_ADDR_VAR 0 3
22134: PUSH
22135: LD_VAR 0 3
22139: PUSH
22140: LD_INT 1
22142: PLUS
22143: ST_TO_ADDR
// for i in tmp do
22144: LD_ADDR_VAR 0 1
22148: PUSH
22149: LD_VAR 0 2
22153: PUSH
22154: FOR_IN
22155: IFFALSE 22186
// if GetLives ( i ) < 1000 then
22157: LD_VAR 0 1
22161: PPUSH
22162: CALL_OW 256
22166: PUSH
22167: LD_INT 1000
22169: LESS
22170: IFFALSE 22184
// SetLives ( i , 1000 ) ;
22172: LD_VAR 0 1
22176: PPUSH
22177: LD_INT 1000
22179: PPUSH
22180: CALL_OW 234
22184: GO 22154
22186: POP
22187: POP
// until p > 20 ;
22188: LD_VAR 0 3
22192: PUSH
22193: LD_INT 20
22195: GREATER
22196: IFFALSE 22123
// end ;
22198: PPOPN 3
22200: END
// every 0 0$1 trigger StreamModeActive and sTime do
22201: LD_EXP 43
22205: PUSH
22206: LD_EXP 94
22210: AND
22211: IFFALSE 22246
22213: GO 22215
22215: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
22216: LD_INT 28
22218: PPUSH
22219: LD_OWVAR 2
22223: PPUSH
22224: LD_INT 2
22226: PPUSH
22227: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
22231: LD_INT 30
22233: PPUSH
22234: LD_OWVAR 2
22238: PPUSH
22239: LD_INT 2
22241: PPUSH
22242: CALL_OW 322
// end ;
22246: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
22247: LD_EXP 43
22251: PUSH
22252: LD_EXP 95
22256: AND
22257: IFFALSE 22378
22259: GO 22261
22261: DISABLE
22262: LD_INT 0
22264: PPUSH
22265: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
22266: LD_ADDR_VAR 0 2
22270: PUSH
22271: LD_INT 22
22273: PUSH
22274: LD_OWVAR 2
22278: PUSH
22279: EMPTY
22280: LIST
22281: LIST
22282: PUSH
22283: LD_INT 21
22285: PUSH
22286: LD_INT 1
22288: PUSH
22289: EMPTY
22290: LIST
22291: LIST
22292: PUSH
22293: LD_INT 3
22295: PUSH
22296: LD_INT 23
22298: PUSH
22299: LD_INT 0
22301: PUSH
22302: EMPTY
22303: LIST
22304: LIST
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: LIST
22314: PPUSH
22315: CALL_OW 69
22319: ST_TO_ADDR
// if not tmp then
22320: LD_VAR 0 2
22324: NOT
22325: IFFALSE 22329
// exit ;
22327: GO 22378
// for i in tmp do
22329: LD_ADDR_VAR 0 1
22333: PUSH
22334: LD_VAR 0 2
22338: PUSH
22339: FOR_IN
22340: IFFALSE 22376
// begin if Crawls ( i ) then
22342: LD_VAR 0 1
22346: PPUSH
22347: CALL_OW 318
22351: IFFALSE 22362
// ComWalk ( i ) ;
22353: LD_VAR 0 1
22357: PPUSH
22358: CALL_OW 138
// SetClass ( i , 2 ) ;
22362: LD_VAR 0 1
22366: PPUSH
22367: LD_INT 2
22369: PPUSH
22370: CALL_OW 336
// end ;
22374: GO 22339
22376: POP
22377: POP
// end ;
22378: PPOPN 2
22380: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
22381: LD_EXP 43
22385: PUSH
22386: LD_EXP 96
22390: AND
22391: IFFALSE 22672
22393: GO 22395
22395: DISABLE
22396: LD_INT 0
22398: PPUSH
22399: PPUSH
22400: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
22401: LD_OWVAR 2
22405: PPUSH
22406: LD_INT 9
22408: PPUSH
22409: LD_INT 1
22411: PPUSH
22412: LD_INT 1
22414: PPUSH
22415: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
22419: LD_INT 9
22421: PPUSH
22422: LD_OWVAR 2
22426: PPUSH
22427: CALL_OW 343
// uc_side := 9 ;
22431: LD_ADDR_OWVAR 20
22435: PUSH
22436: LD_INT 9
22438: ST_TO_ADDR
// uc_nation := 2 ;
22439: LD_ADDR_OWVAR 21
22443: PUSH
22444: LD_INT 2
22446: ST_TO_ADDR
// hc_name := Dark Warrior ;
22447: LD_ADDR_OWVAR 26
22451: PUSH
22452: LD_STRING Dark Warrior
22454: ST_TO_ADDR
// hc_gallery :=  ;
22455: LD_ADDR_OWVAR 33
22459: PUSH
22460: LD_STRING 
22462: ST_TO_ADDR
// hc_noskilllimit := true ;
22463: LD_ADDR_OWVAR 76
22467: PUSH
22468: LD_INT 1
22470: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
22471: LD_ADDR_OWVAR 31
22475: PUSH
22476: LD_INT 30
22478: PUSH
22479: LD_INT 30
22481: PUSH
22482: LD_INT 30
22484: PUSH
22485: LD_INT 30
22487: PUSH
22488: EMPTY
22489: LIST
22490: LIST
22491: LIST
22492: LIST
22493: ST_TO_ADDR
// un := CreateHuman ;
22494: LD_ADDR_VAR 0 3
22498: PUSH
22499: CALL_OW 44
22503: ST_TO_ADDR
// hc_noskilllimit := false ;
22504: LD_ADDR_OWVAR 76
22508: PUSH
22509: LD_INT 0
22511: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
22512: LD_VAR 0 3
22516: PPUSH
22517: LD_INT 1
22519: PPUSH
22520: CALL_OW 51
// p := 0 ;
22524: LD_ADDR_VAR 0 2
22528: PUSH
22529: LD_INT 0
22531: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
22532: LD_INT 35
22534: PPUSH
22535: CALL_OW 67
// p := p + 1 ;
22539: LD_ADDR_VAR 0 2
22543: PUSH
22544: LD_VAR 0 2
22548: PUSH
22549: LD_INT 1
22551: PLUS
22552: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
22553: LD_VAR 0 3
22557: PPUSH
22558: CALL_OW 256
22562: PUSH
22563: LD_INT 1000
22565: LESS
22566: IFFALSE 22580
// SetLives ( un , 1000 ) ;
22568: LD_VAR 0 3
22572: PPUSH
22573: LD_INT 1000
22575: PPUSH
22576: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
22580: LD_VAR 0 3
22584: PPUSH
22585: LD_INT 81
22587: PUSH
22588: LD_OWVAR 2
22592: PUSH
22593: EMPTY
22594: LIST
22595: LIST
22596: PUSH
22597: LD_INT 91
22599: PUSH
22600: LD_VAR 0 3
22604: PUSH
22605: LD_INT 30
22607: PUSH
22608: EMPTY
22609: LIST
22610: LIST
22611: LIST
22612: PUSH
22613: EMPTY
22614: LIST
22615: LIST
22616: PPUSH
22617: CALL_OW 69
22621: PPUSH
22622: LD_VAR 0 3
22626: PPUSH
22627: CALL_OW 74
22631: PPUSH
22632: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
22636: LD_VAR 0 2
22640: PUSH
22641: LD_INT 60
22643: GREATER
22644: PUSH
22645: LD_VAR 0 3
22649: PPUSH
22650: CALL_OW 301
22654: OR
22655: IFFALSE 22532
// if un then
22657: LD_VAR 0 3
22661: IFFALSE 22672
// RemoveUnit ( un ) ;
22663: LD_VAR 0 3
22667: PPUSH
22668: CALL_OW 64
// end ; end_of_file
22672: PPOPN 3
22674: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
22675: LD_INT 0
22677: PPUSH
22678: PPUSH
22679: PPUSH
22680: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
22681: LD_VAR 0 1
22685: PPUSH
22686: CALL_OW 264
22690: PUSH
22691: LD_EXP 34
22695: EQUAL
22696: IFFALSE 22768
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
22698: LD_INT 68
22700: PPUSH
22701: LD_VAR 0 1
22705: PPUSH
22706: CALL_OW 255
22710: PPUSH
22711: CALL_OW 321
22715: PUSH
22716: LD_INT 2
22718: EQUAL
22719: IFFALSE 22731
// eff := 70 else
22721: LD_ADDR_VAR 0 4
22725: PUSH
22726: LD_INT 70
22728: ST_TO_ADDR
22729: GO 22739
// eff := 30 ;
22731: LD_ADDR_VAR 0 4
22735: PUSH
22736: LD_INT 30
22738: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
22739: LD_VAR 0 1
22743: PPUSH
22744: CALL_OW 250
22748: PPUSH
22749: LD_VAR 0 1
22753: PPUSH
22754: CALL_OW 251
22758: PPUSH
22759: LD_VAR 0 4
22763: PPUSH
22764: CALL_OW 495
// end ; end ;
22768: LD_VAR 0 2
22772: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
22773: LD_INT 0
22775: PPUSH
// end ;
22776: LD_VAR 0 4
22780: RET
// export function SOS_Command ( cmd ) ; begin
22781: LD_INT 0
22783: PPUSH
// end ;
22784: LD_VAR 0 2
22788: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
22789: LD_VAR 0 1
22793: PUSH
22794: LD_INT 255
22796: EQUAL
22797: PUSH
22798: LD_VAR 0 2
22802: PPUSH
22803: CALL_OW 264
22807: PUSH
22808: LD_INT 14
22810: PUSH
22811: LD_INT 53
22813: PUSH
22814: EMPTY
22815: LIST
22816: LIST
22817: IN
22818: AND
22819: PUSH
22820: LD_VAR 0 4
22824: PPUSH
22825: LD_VAR 0 5
22829: PPUSH
22830: CALL_OW 488
22834: AND
22835: IFFALSE 22859
// CutTreeXYR ( unit , x , y , 12 ) ;
22837: LD_VAR 0 2
22841: PPUSH
22842: LD_VAR 0 4
22846: PPUSH
22847: LD_VAR 0 5
22851: PPUSH
22852: LD_INT 12
22854: PPUSH
22855: CALL 22862 0 4
// end ;
22859: PPOPN 5
22861: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22862: LD_INT 0
22864: PPUSH
22865: PPUSH
22866: PPUSH
22867: PPUSH
22868: PPUSH
22869: PPUSH
22870: PPUSH
22871: PPUSH
22872: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22873: LD_VAR 0 1
22877: NOT
22878: PUSH
22879: LD_VAR 0 2
22883: PPUSH
22884: LD_VAR 0 3
22888: PPUSH
22889: CALL_OW 488
22893: NOT
22894: OR
22895: PUSH
22896: LD_VAR 0 4
22900: NOT
22901: OR
22902: IFFALSE 22906
// exit ;
22904: GO 23246
// list := [ ] ;
22906: LD_ADDR_VAR 0 13
22910: PUSH
22911: EMPTY
22912: ST_TO_ADDR
// if x - r < 0 then
22913: LD_VAR 0 2
22917: PUSH
22918: LD_VAR 0 4
22922: MINUS
22923: PUSH
22924: LD_INT 0
22926: LESS
22927: IFFALSE 22939
// min_x := 0 else
22929: LD_ADDR_VAR 0 7
22933: PUSH
22934: LD_INT 0
22936: ST_TO_ADDR
22937: GO 22955
// min_x := x - r ;
22939: LD_ADDR_VAR 0 7
22943: PUSH
22944: LD_VAR 0 2
22948: PUSH
22949: LD_VAR 0 4
22953: MINUS
22954: ST_TO_ADDR
// if y - r < 0 then
22955: LD_VAR 0 3
22959: PUSH
22960: LD_VAR 0 4
22964: MINUS
22965: PUSH
22966: LD_INT 0
22968: LESS
22969: IFFALSE 22981
// min_y := 0 else
22971: LD_ADDR_VAR 0 8
22975: PUSH
22976: LD_INT 0
22978: ST_TO_ADDR
22979: GO 22997
// min_y := y - r ;
22981: LD_ADDR_VAR 0 8
22985: PUSH
22986: LD_VAR 0 3
22990: PUSH
22991: LD_VAR 0 4
22995: MINUS
22996: ST_TO_ADDR
// max_x := x + r ;
22997: LD_ADDR_VAR 0 9
23001: PUSH
23002: LD_VAR 0 2
23006: PUSH
23007: LD_VAR 0 4
23011: PLUS
23012: ST_TO_ADDR
// max_y := y + r ;
23013: LD_ADDR_VAR 0 10
23017: PUSH
23018: LD_VAR 0 3
23022: PUSH
23023: LD_VAR 0 4
23027: PLUS
23028: ST_TO_ADDR
// for _x = min_x to max_x do
23029: LD_ADDR_VAR 0 11
23033: PUSH
23034: DOUBLE
23035: LD_VAR 0 7
23039: DEC
23040: ST_TO_ADDR
23041: LD_VAR 0 9
23045: PUSH
23046: FOR_TO
23047: IFFALSE 23164
// for _y = min_y to max_y do
23049: LD_ADDR_VAR 0 12
23053: PUSH
23054: DOUBLE
23055: LD_VAR 0 8
23059: DEC
23060: ST_TO_ADDR
23061: LD_VAR 0 10
23065: PUSH
23066: FOR_TO
23067: IFFALSE 23160
// begin if not ValidHex ( _x , _y ) then
23069: LD_VAR 0 11
23073: PPUSH
23074: LD_VAR 0 12
23078: PPUSH
23079: CALL_OW 488
23083: NOT
23084: IFFALSE 23088
// continue ;
23086: GO 23066
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
23088: LD_VAR 0 11
23092: PPUSH
23093: LD_VAR 0 12
23097: PPUSH
23098: CALL_OW 351
23102: PUSH
23103: LD_VAR 0 11
23107: PPUSH
23108: LD_VAR 0 12
23112: PPUSH
23113: CALL_OW 554
23117: AND
23118: IFFALSE 23158
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
23120: LD_ADDR_VAR 0 13
23124: PUSH
23125: LD_VAR 0 13
23129: PPUSH
23130: LD_VAR 0 13
23134: PUSH
23135: LD_INT 1
23137: PLUS
23138: PPUSH
23139: LD_VAR 0 11
23143: PUSH
23144: LD_VAR 0 12
23148: PUSH
23149: EMPTY
23150: LIST
23151: LIST
23152: PPUSH
23153: CALL_OW 2
23157: ST_TO_ADDR
// end ;
23158: GO 23066
23160: POP
23161: POP
23162: GO 23046
23164: POP
23165: POP
// if not list then
23166: LD_VAR 0 13
23170: NOT
23171: IFFALSE 23175
// exit ;
23173: GO 23246
// for i in list do
23175: LD_ADDR_VAR 0 6
23179: PUSH
23180: LD_VAR 0 13
23184: PUSH
23185: FOR_IN
23186: IFFALSE 23244
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
23188: LD_VAR 0 1
23192: PPUSH
23193: LD_STRING M
23195: PUSH
23196: LD_VAR 0 6
23200: PUSH
23201: LD_INT 1
23203: ARRAY
23204: PUSH
23205: LD_VAR 0 6
23209: PUSH
23210: LD_INT 2
23212: ARRAY
23213: PUSH
23214: LD_INT 0
23216: PUSH
23217: LD_INT 0
23219: PUSH
23220: LD_INT 0
23222: PUSH
23223: LD_INT 0
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: LIST
23233: LIST
23234: PUSH
23235: EMPTY
23236: LIST
23237: PPUSH
23238: CALL_OW 447
23242: GO 23185
23244: POP
23245: POP
// end ;
23246: LD_VAR 0 5
23250: RET
