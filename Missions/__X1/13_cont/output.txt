// export side_Neutral , side_Am , side_Ru ; export Burlak , Bystrov ; export Belkov , Gnyevko , Kirilenkova ; export Kovalyuk , Scholtze ; export Kuzmov ; export Karamazov , Petrovova , Gleb , Petrosyan ; export Lipshchin , Titov , Dolgov , Xavier ; export Oblukov , Kozlov , Kapitsova ; export Masha ; export Ostatni ; export Gladkov , GladkovFake ; export Rusove ; function load_char ( Ident ) ; begin
   0: LD_INT 0
   2: PPUSH
// if TestCharacters ( Ident ) then
   3: LD_VAR 0 1
   7: PPUSH
   8: CALL_OW 28
  12: IFFALSE 59
// begin Result = CreateCharacter ( Ident ) ;
  14: LD_ADDR_VAR 0 2
  18: PUSH
  19: LD_VAR 0 1
  23: PPUSH
  24: CALL_OW 34
  28: ST_TO_ADDR
// if IsDead ( Result ) then
  29: LD_VAR 0 2
  33: PPUSH
  34: CALL_OW 301
  38: IFFALSE 57
// begin DestroyUnit ( Result ) ;
  40: LD_VAR 0 2
  44: PPUSH
  45: CALL_OW 65
// Result = 0 ;
  49: LD_ADDR_VAR 0 2
  53: PUSH
  54: LD_INT 0
  56: ST_TO_ADDR
// end ; end else
  57: GO 74
// Result = NewCharacter ( Ident ) ;
  59: LD_ADDR_VAR 0 2
  63: PUSH
  64: LD_VAR 0 1
  68: PPUSH
  69: CALL_OW 25
  73: ST_TO_ADDR
// if Result then
  74: LD_VAR 0 2
  78: IFFALSE 92
// SetSide ( Result , 3 ) ;
  80: LD_VAR 0 2
  84: PPUSH
  85: LD_INT 3
  87: PPUSH
  88: CALL_OW 235
// end ;
  92: LD_VAR 0 2
  96: RET
// function load_create ( Ident ) ; begin
  97: LD_INT 0
  99: PPUSH
// if TestCharacters ( Ident ) then
 100: LD_VAR 0 1
 104: PPUSH
 105: CALL_OW 28
 109: IFFALSE 156
// begin Result = CreateCharacter ( Ident ) ;
 111: LD_ADDR_VAR 0 2
 115: PUSH
 116: LD_VAR 0 1
 120: PPUSH
 121: CALL_OW 34
 125: ST_TO_ADDR
// if IsDead ( Result ) then
 126: LD_VAR 0 2
 130: PPUSH
 131: CALL_OW 301
 135: IFFALSE 154
// begin DestroyUnit ( Result ) ;
 137: LD_VAR 0 2
 141: PPUSH
 142: CALL_OW 65
// Result = 0 ;
 146: LD_ADDR_VAR 0 2
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// end ; end else
 154: GO 171
// Result = NewCharacter ( Ident ) ;
 156: LD_ADDR_VAR 0 2
 160: PUSH
 161: LD_VAR 0 1
 165: PPUSH
 166: CALL_OW 25
 170: ST_TO_ADDR
// if Result then
 171: LD_VAR 0 2
 175: IFFALSE 189
// SetSide ( Result , 3 ) ;
 177: LD_VAR 0 2
 181: PPUSH
 182: LD_INT 3
 184: PPUSH
 185: CALL_OW 235
// end ;
 189: LD_VAR 0 2
 193: RET
// function load_set ( Ident ) ; begin
 194: LD_INT 0
 196: PPUSH
// if TestCharacters ( Ident ) then
 197: LD_VAR 0 1
 201: PPUSH
 202: CALL_OW 28
 206: IFFALSE 225
// Result = CreateCharacterSet ( Ident ) else
 208: LD_ADDR_VAR 0 2
 212: PUSH
 213: LD_VAR 0 1
 217: PPUSH
 218: CALL_OW 31
 222: ST_TO_ADDR
 223: GO 232
// Result = [ ] ;
 225: LD_ADDR_VAR 0 2
 229: PUSH
 230: EMPTY
 231: ST_TO_ADDR
// end ;
 232: LD_VAR 0 2
 236: RET
// function vytvor_gladkova ; begin
 237: LD_INT 0
 239: PPUSH
// UC_Nation = NATION_RUSSIAN ;
 240: LD_ADDR_OWVAR 21
 244: PUSH
 245: LD_INT 3
 247: ST_TO_ADDR
// UC_side = side_Ru ;
 248: LD_ADDR_OWVAR 20
 252: PUSH
 253: LD_EXP 3
 257: ST_TO_ADDR
// HC_name =  ;
 258: LD_ADDR_OWVAR 26
 262: PUSH
 263: LD_STRING 
 265: ST_TO_ADDR
// HC_sex = SEX_MALE ;
 266: LD_ADDR_OWVAR 27
 270: PUSH
 271: LD_INT 1
 273: ST_TO_ADDR
// HC_class = CLASS_SOLDIER ;
 274: LD_ADDR_OWVAR 28
 278: PUSH
 279: LD_INT 1
 281: ST_TO_ADDR
// PrepareSoldierSkills ( 7 ) ;
 282: LD_INT 7
 284: PPUSH
 285: CALL_OW 375
// Result = CreateHuman ;
 289: LD_ADDR_VAR 0 1
 293: PUSH
 294: CALL_OW 44
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// function load ; var MashaSpec ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// UC_Side = side_Ru ;
 308: LD_ADDR_OWVAR 20
 312: PUSH
 313: LD_EXP 3
 317: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
 318: LD_ADDR_OWVAR 21
 322: PUSH
 323: LD_INT 3
 325: ST_TO_ADDR
// Burlak = load_char ( Burlak ) ;
 326: LD_ADDR_EXP 4
 330: PUSH
 331: LD_STRING Burlak
 333: PPUSH
 334: CALL 0 0 1
 338: ST_TO_ADDR
// Bystrov = NewCharacter ( Bystrov ) ;
 339: LD_ADDR_EXP 5
 343: PUSH
 344: LD_STRING Bystrov
 346: PPUSH
 347: CALL_OW 25
 351: ST_TO_ADDR
// Gladkov = load_char ( Gladkov ) ;
 352: LD_ADDR_EXP 25
 356: PUSH
 357: LD_STRING Gladkov
 359: PPUSH
 360: CALL 0 0 1
 364: ST_TO_ADDR
// if not Gladkov then
 365: LD_EXP 25
 369: NOT
 370: IFFALSE 382
// GladkovFake = vytvor_gladkova ;
 372: LD_ADDR_EXP 26
 376: PUSH
 377: CALL 237 0 0
 381: ST_TO_ADDR
// MashaSpec = LoadVariable ( Masha , [ ] ) ;
 382: LD_ADDR_VAR 0 2
 386: PUSH
 387: LD_STRING Masha
 389: PPUSH
 390: EMPTY
 391: PPUSH
 392: CALL_OW 30
 396: ST_TO_ADDR
// if MashaSpec = 0 then
 397: LD_VAR 0 2
 401: PUSH
 402: LD_INT 0
 404: EQUAL
 405: IFFALSE 417
// Masha = 0 else
 407: LD_ADDR_EXP 23
 411: PUSH
 412: LD_INT 0
 414: ST_TO_ADDR
 415: GO 563
// begin UC_Nation = NATION_RUSSIAN ;
 417: LD_ADDR_OWVAR 21
 421: PUSH
 422: LD_INT 3
 424: ST_TO_ADDR
// UC_Side = side_Ru ;
 425: LD_ADDR_OWVAR 20
 429: PUSH
 430: LD_EXP 3
 434: ST_TO_ADDR
// VC_Chassis = MashaSpec [ 1 ] ;
 435: LD_ADDR_OWVAR 37
 439: PUSH
 440: LD_VAR 0 2
 444: PUSH
 445: LD_INT 1
 447: ARRAY
 448: ST_TO_ADDR
// VC_Engine = MashaSpec [ 2 ] ;
 449: LD_ADDR_OWVAR 39
 453: PUSH
 454: LD_VAR 0 2
 458: PUSH
 459: LD_INT 2
 461: ARRAY
 462: ST_TO_ADDR
// VC_Control = MashaSpec [ 3 ] ;
 463: LD_ADDR_OWVAR 38
 467: PUSH
 468: LD_VAR 0 2
 472: PUSH
 473: LD_INT 3
 475: ARRAY
 476: ST_TO_ADDR
// VC_Weapon = MashaSpec [ 4 ] ;
 477: LD_ADDR_OWVAR 40
 481: PUSH
 482: LD_VAR 0 2
 486: PUSH
 487: LD_INT 4
 489: ARRAY
 490: ST_TO_ADDR
// if ( VC_Weapon = 0 ) or ( VC_Control = 0 ) or ( VC_Engine = 0 ) or ( VC_Chassis = 0 ) then
 491: LD_OWVAR 40
 495: PUSH
 496: LD_INT 0
 498: EQUAL
 499: PUSH
 500: LD_OWVAR 38
 504: PUSH
 505: LD_INT 0
 507: EQUAL
 508: OR
 509: PUSH
 510: LD_OWVAR 39
 514: PUSH
 515: LD_INT 0
 517: EQUAL
 518: OR
 519: PUSH
 520: LD_OWVAR 37
 524: PUSH
 525: LD_INT 0
 527: EQUAL
 528: OR
 529: IFFALSE 541
// Masha = 0 else
 531: LD_ADDR_EXP 23
 535: PUSH
 536: LD_INT 0
 538: ST_TO_ADDR
 539: GO 563
// begin Masha = CreateVehicle ;
 541: LD_ADDR_EXP 23
 545: PUSH
 546: CALL_OW 45
 550: ST_TO_ADDR
// SetMark ( Masha , 1 ) ;
 551: LD_EXP 23
 555: PPUSH
 556: LD_INT 1
 558: PPUSH
 559: CALL_OW 242
// end ; end ; if LoadVariable ( GlebLoc , 0 ) = 13 then
 563: LD_STRING GlebLoc
 565: PPUSH
 566: LD_INT 0
 568: PPUSH
 569: CALL_OW 30
 573: PUSH
 574: LD_INT 13
 576: EQUAL
 577: IFFALSE 592
// Gleb = load_char ( Gleb ) ;
 579: LD_ADDR_EXP 14
 583: PUSH
 584: LD_STRING Gleb
 586: PPUSH
 587: CALL 0 0 1
 591: ST_TO_ADDR
// if LoadVariable ( BelkovLoc , 0 ) = 13 then
 592: LD_STRING BelkovLoc
 594: PPUSH
 595: LD_INT 0
 597: PPUSH
 598: CALL_OW 30
 602: PUSH
 603: LD_INT 13
 605: EQUAL
 606: IFFALSE 621
// Belkov = load_char ( Belkov ) ;
 608: LD_ADDR_EXP 6
 612: PUSH
 613: LD_STRING Belkov
 615: PPUSH
 616: CALL 0 0 1
 620: ST_TO_ADDR
// if LoadVariable ( GnyevkoLoc , 0 ) = 13 then
 621: LD_STRING GnyevkoLoc
 623: PPUSH
 624: LD_INT 0
 626: PPUSH
 627: CALL_OW 30
 631: PUSH
 632: LD_INT 13
 634: EQUAL
 635: IFFALSE 650
// Gnyevko = load_char ( Gnyevko ) ;
 637: LD_ADDR_EXP 7
 641: PUSH
 642: LD_STRING Gnyevko
 644: PPUSH
 645: CALL 0 0 1
 649: ST_TO_ADDR
// if LoadVariable ( KirilenkovaLoc , 0 ) = 13 then
 650: LD_STRING KirilenkovaLoc
 652: PPUSH
 653: LD_INT 0
 655: PPUSH
 656: CALL_OW 30
 660: PUSH
 661: LD_INT 13
 663: EQUAL
 664: IFFALSE 679
// Kirilenkova = load_char ( Kirilenkova ) ;
 666: LD_ADDR_EXP 8
 670: PUSH
 671: LD_STRING Kirilenkova
 673: PPUSH
 674: CALL 0 0 1
 678: ST_TO_ADDR
// if LoadVariable ( KovalyukLoc , 0 ) = 13 then
 679: LD_STRING KovalyukLoc
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL_OW 30
 689: PUSH
 690: LD_INT 13
 692: EQUAL
 693: IFFALSE 708
// Kovalyuk = load_char ( Kovalyuk ) ;
 695: LD_ADDR_EXP 9
 699: PUSH
 700: LD_STRING Kovalyuk
 702: PPUSH
 703: CALL 0 0 1
 707: ST_TO_ADDR
// if LoadVariable ( ScholtzeLoc , 0 ) = 13 then
 708: LD_STRING ScholtzeLoc
 710: PPUSH
 711: LD_INT 0
 713: PPUSH
 714: CALL_OW 30
 718: PUSH
 719: LD_INT 13
 721: EQUAL
 722: IFFALSE 737
// Scholtze = load_char ( Scholtze ) ;
 724: LD_ADDR_EXP 10
 728: PUSH
 729: LD_STRING Scholtze
 731: PPUSH
 732: CALL 0 0 1
 736: ST_TO_ADDR
// if LoadVariable ( KuzmovLoc , 0 ) = 13 then
 737: LD_STRING KuzmovLoc
 739: PPUSH
 740: LD_INT 0
 742: PPUSH
 743: CALL_OW 30
 747: PUSH
 748: LD_INT 13
 750: EQUAL
 751: IFFALSE 766
// Kuzmov = load_char ( Kuzmov ) ;
 753: LD_ADDR_EXP 11
 757: PUSH
 758: LD_STRING Kuzmov
 760: PPUSH
 761: CALL 0 0 1
 765: ST_TO_ADDR
// if LoadVariable ( KaramazovLoc , 0 ) = 13 then
 766: LD_STRING KaramazovLoc
 768: PPUSH
 769: LD_INT 0
 771: PPUSH
 772: CALL_OW 30
 776: PUSH
 777: LD_INT 13
 779: EQUAL
 780: IFFALSE 795
// Karamazov = load_char ( Karamazov ) ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_STRING Karamazov
 789: PPUSH
 790: CALL 0 0 1
 794: ST_TO_ADDR
// if LoadVariable ( PetrovovaLoc , 0 ) = 13 then
 795: LD_STRING PetrovovaLoc
 797: PPUSH
 798: LD_INT 0
 800: PPUSH
 801: CALL_OW 30
 805: PUSH
 806: LD_INT 13
 808: EQUAL
 809: IFFALSE 824
// Petrovova = load_char ( Petrovova ) ;
 811: LD_ADDR_EXP 13
 815: PUSH
 816: LD_STRING Petrovova
 818: PPUSH
 819: CALL 0 0 1
 823: ST_TO_ADDR
// if LoadVariable ( GlebLoc , 0 ) = 13 then
 824: LD_STRING GlebLoc
 826: PPUSH
 827: LD_INT 0
 829: PPUSH
 830: CALL_OW 30
 834: PUSH
 835: LD_INT 13
 837: EQUAL
 838: IFFALSE 853
// Gleb = load_char ( Gleb ) ;
 840: LD_ADDR_EXP 14
 844: PUSH
 845: LD_STRING Gleb
 847: PPUSH
 848: CALL 0 0 1
 852: ST_TO_ADDR
// if LoadVariable ( PetrosyanLoc , 0 ) = 13 then
 853: LD_STRING PetrosyanLoc
 855: PPUSH
 856: LD_INT 0
 858: PPUSH
 859: CALL_OW 30
 863: PUSH
 864: LD_INT 13
 866: EQUAL
 867: IFFALSE 882
// Petrosyan = load_char ( Petrosyan ) ;
 869: LD_ADDR_EXP 15
 873: PUSH
 874: LD_STRING Petrosyan
 876: PPUSH
 877: CALL 0 0 1
 881: ST_TO_ADDR
// if LoadVariable ( LipshchinLoc , 0 ) = 13 then
 882: LD_STRING LipshchinLoc
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 30
 892: PUSH
 893: LD_INT 13
 895: EQUAL
 896: IFFALSE 911
// Lipshchin = load_char ( Lipshchin ) ;
 898: LD_ADDR_EXP 16
 902: PUSH
 903: LD_STRING Lipshchin
 905: PPUSH
 906: CALL 0 0 1
 910: ST_TO_ADDR
// if LoadVariable ( TitovLoc , 0 ) = 13 then
 911: LD_STRING TitovLoc
 913: PPUSH
 914: LD_INT 0
 916: PPUSH
 917: CALL_OW 30
 921: PUSH
 922: LD_INT 13
 924: EQUAL
 925: IFFALSE 940
// Titov = load_char ( Titov ) ;
 927: LD_ADDR_EXP 17
 931: PUSH
 932: LD_STRING Titov
 934: PPUSH
 935: CALL 0 0 1
 939: ST_TO_ADDR
// if LoadVariable ( DolgovLoc , 0 ) = 13 then
 940: LD_STRING DolgovLoc
 942: PPUSH
 943: LD_INT 0
 945: PPUSH
 946: CALL_OW 30
 950: PUSH
 951: LD_INT 13
 953: EQUAL
 954: IFFALSE 969
// Dolgov = load_char ( Dolgov ) ;
 956: LD_ADDR_EXP 18
 960: PUSH
 961: LD_STRING Dolgov
 963: PPUSH
 964: CALL 0 0 1
 968: ST_TO_ADDR
// if LoadVariable ( XavierLoc , 0 ) = 13 then
 969: LD_STRING XavierLoc
 971: PPUSH
 972: LD_INT 0
 974: PPUSH
 975: CALL_OW 30
 979: PUSH
 980: LD_INT 13
 982: EQUAL
 983: IFFALSE 998
// Xavier = load_char ( Xavier ) ;
 985: LD_ADDR_EXP 19
 989: PUSH
 990: LD_STRING Xavier
 992: PPUSH
 993: CALL 0 0 1
 997: ST_TO_ADDR
// if LoadVariable ( OblukovLoc , 0 ) = 13 then
 998: LD_STRING OblukovLoc
1000: PPUSH
1001: LD_INT 0
1003: PPUSH
1004: CALL_OW 30
1008: PUSH
1009: LD_INT 13
1011: EQUAL
1012: IFFALSE 1027
// Oblukov = load_char ( Oblukov ) ;
1014: LD_ADDR_EXP 20
1018: PUSH
1019: LD_STRING Oblukov
1021: PPUSH
1022: CALL 0 0 1
1026: ST_TO_ADDR
// if LoadVariable ( KozlovLoc , 0 ) = 13 then
1027: LD_STRING KozlovLoc
1029: PPUSH
1030: LD_INT 0
1032: PPUSH
1033: CALL_OW 30
1037: PUSH
1038: LD_INT 13
1040: EQUAL
1041: IFFALSE 1056
// Kozlov = load_char ( Kozlov ) ;
1043: LD_ADDR_EXP 21
1047: PUSH
1048: LD_STRING Kozlov
1050: PPUSH
1051: CALL 0 0 1
1055: ST_TO_ADDR
// if LoadVariable ( KapitsovaLoc , 0 ) = 13 then
1056: LD_STRING KapitsovaLoc
1058: PPUSH
1059: LD_INT 0
1061: PPUSH
1062: CALL_OW 30
1066: PUSH
1067: LD_INT 13
1069: EQUAL
1070: IFFALSE 1085
// Kapitsova = load_char ( Kapitsova ) ;
1072: LD_ADDR_EXP 22
1076: PUSH
1077: LD_STRING Kapitsova
1079: PPUSH
1080: CALL 0 0 1
1084: ST_TO_ADDR
// Ostatni = load_set ( Others_Ru13 ) ;
1085: LD_ADDR_EXP 24
1089: PUSH
1090: LD_STRING Others_Ru13
1092: PPUSH
1093: CALL 194 0 1
1097: ST_TO_ADDR
// DeleteCharacters ( Others_Ru13 ) ;
1098: LD_STRING Others_Ru13
1100: PPUSH
1101: CALL_OW 40
// Rusove = ( [ Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] union Ostatni ) diff [ 0 ] ;
1105: LD_ADDR_EXP 27
1109: PUSH
1110: LD_EXP 14
1114: PUSH
1115: LD_EXP 6
1119: PUSH
1120: LD_EXP 7
1124: PUSH
1125: LD_EXP 8
1129: PUSH
1130: LD_EXP 9
1134: PUSH
1135: LD_EXP 10
1139: PUSH
1140: LD_EXP 11
1144: PUSH
1145: LD_EXP 12
1149: PUSH
1150: LD_EXP 13
1154: PUSH
1155: LD_EXP 14
1159: PUSH
1160: LD_EXP 15
1164: PUSH
1165: LD_EXP 16
1169: PUSH
1170: LD_EXP 17
1174: PUSH
1175: LD_EXP 18
1179: PUSH
1180: LD_EXP 19
1184: PUSH
1185: LD_EXP 20
1189: PUSH
1190: LD_EXP 21
1194: PUSH
1195: LD_EXP 22
1199: PUSH
1200: EMPTY
1201: LIST
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PUSH
1220: LD_EXP 24
1224: UNION
1225: PUSH
1226: LD_INT 0
1228: PUSH
1229: EMPTY
1230: LIST
1231: DIFF
1232: ST_TO_ADDR
// SetSide ( [ Burlak , Bystrov , Gladkov ] , side_Ru ) ;
1233: LD_EXP 4
1237: PUSH
1238: LD_EXP 5
1242: PUSH
1243: LD_EXP 25
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: PPUSH
1253: LD_EXP 3
1257: PPUSH
1258: CALL_OW 235
// SetSide ( Rusove , side_Ru ) ;
1262: LD_EXP 27
1266: PPUSH
1267: LD_EXP 3
1271: PPUSH
1272: CALL_OW 235
// end ;
1276: LD_VAR 0 1
1280: RET
// function save_char ( Handle , Ident ) ; begin
1281: LD_INT 0
1283: PPUSH
// if Handle then
1284: LD_VAR 0 1
1288: IFFALSE 1307
// SaveCharacters ( [ Handle ] , Ident ) ;
1290: LD_VAR 0 1
1294: PUSH
1295: EMPTY
1296: LIST
1297: PPUSH
1298: LD_VAR 0 2
1302: PPUSH
1303: CALL_OW 38
// end ;
1307: LD_VAR 0 3
1311: RET
// function save ; var MashaSpec , Survivors4 , O , Opice ; begin
1312: LD_INT 0
1314: PPUSH
1315: PPUSH
1316: PPUSH
1317: PPUSH
1318: PPUSH
// save_char ( Burlak , Burlak ) ;
1319: LD_EXP 4
1323: PPUSH
1324: LD_STRING Burlak
1326: PPUSH
1327: CALL 1281 0 2
// save_char ( Bystrov , Bystrov ) ;
1331: LD_EXP 5
1335: PPUSH
1336: LD_STRING Bystrov
1338: PPUSH
1339: CALL 1281 0 2
// save_char ( Gleb , Gleb ) ;
1343: LD_EXP 14
1347: PPUSH
1348: LD_STRING Gleb
1350: PPUSH
1351: CALL 1281 0 2
// save_char ( Belkov , Belkov ) ;
1355: LD_EXP 6
1359: PPUSH
1360: LD_STRING Belkov
1362: PPUSH
1363: CALL 1281 0 2
// save_char ( Gnyevko , Gnyevko ) ;
1367: LD_EXP 7
1371: PPUSH
1372: LD_STRING Gnyevko
1374: PPUSH
1375: CALL 1281 0 2
// save_char ( Kirilenkova , Kirilenkova ) ;
1379: LD_EXP 8
1383: PPUSH
1384: LD_STRING Kirilenkova
1386: PPUSH
1387: CALL 1281 0 2
// save_char ( Kovalyuk , Kovalyuk ) ;
1391: LD_EXP 9
1395: PPUSH
1396: LD_STRING Kovalyuk
1398: PPUSH
1399: CALL 1281 0 2
// save_char ( Scholtze , Scholtze ) ;
1403: LD_EXP 10
1407: PPUSH
1408: LD_STRING Scholtze
1410: PPUSH
1411: CALL 1281 0 2
// save_char ( Kuzmov , Kuzmov ) ;
1415: LD_EXP 11
1419: PPUSH
1420: LD_STRING Kuzmov
1422: PPUSH
1423: CALL 1281 0 2
// save_char ( Karamazov , Karamazov ) ;
1427: LD_EXP 12
1431: PPUSH
1432: LD_STRING Karamazov
1434: PPUSH
1435: CALL 1281 0 2
// save_char ( Petrovova , Petrovova ) ;
1439: LD_EXP 13
1443: PPUSH
1444: LD_STRING Petrovova
1446: PPUSH
1447: CALL 1281 0 2
// save_char ( Gleb , Gleb ) ;
1451: LD_EXP 14
1455: PPUSH
1456: LD_STRING Gleb
1458: PPUSH
1459: CALL 1281 0 2
// save_char ( Petrosyan , Petrosyan ) ;
1463: LD_EXP 15
1467: PPUSH
1468: LD_STRING Petrosyan
1470: PPUSH
1471: CALL 1281 0 2
// save_char ( Lipshchin , Lipshchin ) ;
1475: LD_EXP 16
1479: PPUSH
1480: LD_STRING Lipshchin
1482: PPUSH
1483: CALL 1281 0 2
// save_char ( Titov , Titov ) ;
1487: LD_EXP 17
1491: PPUSH
1492: LD_STRING Titov
1494: PPUSH
1495: CALL 1281 0 2
// save_char ( Dolgov , Dolgov ) ;
1499: LD_EXP 18
1503: PPUSH
1504: LD_STRING Dolgov
1506: PPUSH
1507: CALL 1281 0 2
// save_char ( Xavier , Xavier ) ;
1511: LD_EXP 19
1515: PPUSH
1516: LD_STRING Xavier
1518: PPUSH
1519: CALL 1281 0 2
// save_char ( Oblukov , Oblukov ) ;
1523: LD_EXP 20
1527: PPUSH
1528: LD_STRING Oblukov
1530: PPUSH
1531: CALL 1281 0 2
// save_char ( Kozlov , Kozlov ) ;
1535: LD_EXP 21
1539: PPUSH
1540: LD_STRING Kozlov
1542: PPUSH
1543: CALL 1281 0 2
// save_char ( Kapitsova , Kapitsova ) ;
1547: LD_EXP 22
1551: PPUSH
1552: LD_STRING Kapitsova
1554: PPUSH
1555: CALL 1281 0 2
// Survivors4 = load_set ( Survivors4 ) ;
1559: LD_ADDR_VAR 0 3
1563: PUSH
1564: LD_STRING Survivors4
1566: PPUSH
1567: CALL 194 0 1
1571: ST_TO_ADDR
// O = Rusove diff [ 0 , Burlak , Bystrov , Gleb , Belkov , Gnyevko , Kirilenkova , Kovalyuk , Scholtze , Kuzmov , Karamazov , Petrovova , Gleb , Petrosyan , Lipshchin , Titov , Dolgov , Xavier , Oblukov , Kozlov , Kapitsova ] ;
1572: LD_ADDR_VAR 0 4
1576: PUSH
1577: LD_EXP 27
1581: PUSH
1582: LD_INT 0
1584: PUSH
1585: LD_EXP 4
1589: PUSH
1590: LD_EXP 5
1594: PUSH
1595: LD_EXP 14
1599: PUSH
1600: LD_EXP 6
1604: PUSH
1605: LD_EXP 7
1609: PUSH
1610: LD_EXP 8
1614: PUSH
1615: LD_EXP 9
1619: PUSH
1620: LD_EXP 10
1624: PUSH
1625: LD_EXP 11
1629: PUSH
1630: LD_EXP 12
1634: PUSH
1635: LD_EXP 13
1639: PUSH
1640: LD_EXP 14
1644: PUSH
1645: LD_EXP 15
1649: PUSH
1650: LD_EXP 16
1654: PUSH
1655: LD_EXP 17
1659: PUSH
1660: LD_EXP 18
1664: PUSH
1665: LD_EXP 19
1669: PUSH
1670: LD_EXP 20
1674: PUSH
1675: LD_EXP 21
1679: PUSH
1680: LD_EXP 22
1684: PUSH
1685: EMPTY
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: DIFF
1708: ST_TO_ADDR
// Opice = UnitFilter ( Rusove , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
1709: LD_ADDR_VAR 0 5
1713: PUSH
1714: LD_EXP 27
1718: PPUSH
1719: LD_INT 2
1721: PUSH
1722: LD_INT 25
1724: PUSH
1725: LD_INT 12
1727: PUSH
1728: EMPTY
1729: LIST
1730: LIST
1731: PUSH
1732: LD_INT 25
1734: PUSH
1735: LD_INT 15
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: PUSH
1742: LD_INT 25
1744: PUSH
1745: LD_INT 16
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: PUSH
1752: LD_INT 25
1754: PUSH
1755: LD_INT 17
1757: PUSH
1758: EMPTY
1759: LIST
1760: LIST
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: LIST
1767: LIST
1768: PUSH
1769: EMPTY
1770: LIST
1771: PPUSH
1772: CALL_OW 72
1776: ST_TO_ADDR
// O = O diff Opice ;
1777: LD_ADDR_VAR 0 4
1781: PUSH
1782: LD_VAR 0 4
1786: PUSH
1787: LD_VAR 0 5
1791: DIFF
1792: ST_TO_ADDR
// SaveCharacters ( Survivors4 union O , Survivors4 ) ;
1793: LD_VAR 0 3
1797: PUSH
1798: LD_VAR 0 4
1802: UNION
1803: PPUSH
1804: LD_STRING Survivors4
1806: PPUSH
1807: CALL_OW 38
// SaveVariable ( JMM and IsDead ( JMM ) , JMMKilled ) ;
1811: LD_EXP 44
1815: PUSH
1816: LD_EXP 44
1820: PPUSH
1821: CALL_OW 301
1825: AND
1826: PPUSH
1827: LD_STRING JMMKilled
1829: PPUSH
1830: CALL_OW 39
// if Masha and IsOk ( Masha ) and ( GetSide ( Masha ) = side_Ru ) and IsInArea ( Masha , Cil ) then
1834: LD_EXP 23
1838: PUSH
1839: LD_EXP 23
1843: PPUSH
1844: CALL_OW 302
1848: AND
1849: PUSH
1850: LD_EXP 23
1854: PPUSH
1855: CALL_OW 255
1859: PUSH
1860: LD_EXP 3
1864: EQUAL
1865: AND
1866: PUSH
1867: LD_EXP 23
1871: PPUSH
1872: LD_INT 10
1874: PPUSH
1875: CALL_OW 308
1879: AND
1880: IFFALSE 1884
// begin end else
1882: GO 1891
// DeleteVariable ( Masha ) ;
1884: LD_STRING Masha
1886: PPUSH
1887: CALL_OW 41
// end ;
1891: LD_VAR 0 1
1895: RET
// function dej_medaile ; begin
1896: LD_INT 0
1898: PPUSH
// if JMM and IsDead ( JMM ) then
1899: LD_EXP 44
1903: PUSH
1904: LD_EXP 44
1908: PPUSH
1909: CALL_OW 301
1913: AND
1914: IFFALSE 1928
// AddMedal ( Macmillan , 1 ) else
1916: LD_STRING Macmillan
1918: PPUSH
1919: LD_INT 1
1921: PPUSH
1922: CALL_OW 101
1926: GO 1939
// AddMedal ( Macmillan , - 1 ) ;
1928: LD_STRING Macmillan
1930: PPUSH
1931: LD_INT 1
1933: NEG
1934: PPUSH
1935: CALL_OW 101
// if ( OK_North = 2 ) and ( OK_East = 2 ) then
1939: LD_EXP 31
1943: PUSH
1944: LD_INT 2
1946: EQUAL
1947: PUSH
1948: LD_EXP 32
1952: PUSH
1953: LD_INT 2
1955: EQUAL
1956: AND
1957: IFFALSE 1971
// AddMedal ( Precision , 1 ) else
1959: LD_STRING Precision
1961: PPUSH
1962: LD_INT 1
1964: PPUSH
1965: CALL_OW 101
1969: GO 1982
// AddMedal ( Precision , - 1 ) ;
1971: LD_STRING Precision
1973: PPUSH
1974: LD_INT 1
1976: NEG
1977: PPUSH
1978: CALL_OW 101
// if TimeLapser then
1982: LD_EXP 33
1986: IFFALSE 2000
// AddMedal ( TimeLapser , 1 ) else
1988: LD_STRING TimeLapser
1990: PPUSH
1991: LD_INT 1
1993: PPUSH
1994: CALL_OW 101
1998: GO 2011
// AddMedal ( TimeLapser , - 1 ) ;
2000: LD_STRING TimeLapser
2002: PPUSH
2003: LD_INT 1
2005: NEG
2006: PPUSH
2007: CALL_OW 101
// SA_EndMission ( 3 , 13 , JMM and IsDead ( JMM ) , ( OK_North = 2 ) and ( OK_East = 2 ) , TimeLapser > 0 ) ;
2011: LD_INT 3
2013: PPUSH
2014: LD_INT 13
2016: PPUSH
2017: LD_EXP 44
2021: PUSH
2022: LD_EXP 44
2026: PPUSH
2027: CALL_OW 301
2031: AND
2032: PPUSH
2033: LD_EXP 31
2037: PUSH
2038: LD_INT 2
2040: EQUAL
2041: PUSH
2042: LD_EXP 32
2046: PUSH
2047: LD_INT 2
2049: EQUAL
2050: AND
2051: PPUSH
2052: LD_EXP 33
2056: PUSH
2057: LD_INT 0
2059: GREATER
2060: PPUSH
2061: CALL 18089 0 5
// end ;
2065: LD_VAR 0 1
2069: RET
// export function vyhral ; var Lidi , Opice ; begin
2070: LD_INT 0
2072: PPUSH
2073: PPUSH
2074: PPUSH
// dej_medaile ;
2075: CALL 1896 0 0
// GiveMedals ( Main ) ;
2079: LD_STRING Main
2081: PPUSH
2082: CALL_OW 102
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_TYPE , UNIT_HUMAN ] , [ F_ALIVE ] ] ) ;
2086: LD_ADDR_VAR 0 2
2090: PUSH
2091: LD_INT 22
2093: PUSH
2094: LD_EXP 3
2098: PUSH
2099: EMPTY
2100: LIST
2101: LIST
2102: PUSH
2103: LD_INT 21
2105: PUSH
2106: LD_INT 1
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 51
2115: PUSH
2116: EMPTY
2117: LIST
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: LIST
2123: PPUSH
2124: CALL_OW 69
2128: ST_TO_ADDR
// Opice = UnitFilter ( Lidi , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
2129: LD_ADDR_VAR 0 3
2133: PUSH
2134: LD_VAR 0 2
2138: PPUSH
2139: LD_INT 2
2141: PUSH
2142: LD_INT 25
2144: PUSH
2145: LD_INT 12
2147: PUSH
2148: EMPTY
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 25
2154: PUSH
2155: LD_INT 15
2157: PUSH
2158: EMPTY
2159: LIST
2160: LIST
2161: PUSH
2162: LD_INT 25
2164: PUSH
2165: LD_INT 16
2167: PUSH
2168: EMPTY
2169: LIST
2170: LIST
2171: PUSH
2172: LD_INT 25
2174: PUSH
2175: LD_INT 17
2177: PUSH
2178: EMPTY
2179: LIST
2180: LIST
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: LIST
2188: PUSH
2189: EMPTY
2190: LIST
2191: PPUSH
2192: CALL_OW 72
2196: ST_TO_ADDR
// RewardPeople ( Lidi diff Opice ) ;
2197: LD_VAR 0 2
2201: PUSH
2202: LD_VAR 0 3
2206: DIFF
2207: PPUSH
2208: CALL_OW 43
// save ;
2212: CALL 1312 0 0
// YouWin ;
2216: CALL_OW 103
// end ;
2220: LD_VAR 0 1
2224: RET
// starting begin RandomizeAll ;
2225: CALL_OW 11
// InitUC ;
2229: CALL_OW 18
// InitBC ;
2233: CALL_OW 21
// InitHC ;
2237: CALL_OW 19
// InitVC ;
2241: CALL_OW 20
// side_Neutral = 0 ;
2245: LD_ADDR_EXP 1
2249: PUSH
2250: LD_INT 0
2252: ST_TO_ADDR
// side_Am = 1 ;
2253: LD_ADDR_EXP 2
2257: PUSH
2258: LD_INT 1
2260: ST_TO_ADDR
// side_Ru = 3 ;
2261: LD_ADDR_EXP 3
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// load ;
2269: CALL 304 0 0
// init_difficulty ;
2273: CALL 11987 0 0
// init_suroviny ;
2277: CALL 12682 0 0
// init_nature ;
2281: CALL 17753 0 0
// init_rusove ;
2285: CALL 2302 0 0
// init_amici ;
2289: CALL 5275 0 0
// init_jmm ;
2293: CALL 13132 0 0
// uvod ;
2297: CALL 2593 0 0
// end ; end_of_file
2301: END
// var LabyST ; export ArtefaktMajAmici ; export KdeJeArtefakt ; export AutoSArtefaktem ; export OK_North , OK_East ; export TimeLapser ; var LabySArtefaktem ; var MericiLaborator ; var Slozitost ; export VelikostArtefaktu ; export function init_rusove ; begin
2302: LD_INT 0
2304: PPUSH
// disable ( 1 ) ;
2305: LD_INT 1
2307: DISABLE_MARKED
// disable ( 2 ) ;
2308: LD_INT 2
2310: DISABLE_MARKED
// VelikostArtefaktu = 4 ;
2311: LD_ADDR_EXP 34
2315: PUSH
2316: LD_INT 4
2318: ST_TO_ADDR
// OK_North = 0 ;
2319: LD_ADDR_EXP 31
2323: PUSH
2324: LD_INT 0
2326: ST_TO_ADDR
// OK_East = 0 ;
2327: LD_ADDR_EXP 32
2331: PUSH
2332: LD_INT 0
2334: ST_TO_ADDR
// LabyST = [ ] ;
2335: LD_ADDR_LOC 1
2339: PUSH
2340: EMPTY
2341: ST_TO_ADDR
// KdeJeArtefakt = 0 ;
2342: LD_ADDR_EXP 29
2346: PUSH
2347: LD_INT 0
2349: ST_TO_ADDR
// ArtefaktMajAmici = false ;
2350: LD_ADDR_EXP 28
2354: PUSH
2355: LD_INT 0
2357: ST_TO_ADDR
// AutoSArtefaktem = 0 ;
2358: LD_ADDR_EXP 30
2362: PUSH
2363: LD_INT 0
2365: ST_TO_ADDR
// LabySArtefaktem = [ ] ;
2366: LD_ADDR_LOC 2
2370: PUSH
2371: EMPTY
2372: ST_TO_ADDR
// MericiLaborator = 0 ;
2373: LD_ADDR_LOC 3
2377: PUSH
2378: LD_INT 0
2380: ST_TO_ADDR
// TimeLapser = false ;
2381: LD_ADDR_EXP 33
2385: PUSH
2386: LD_INT 0
2388: ST_TO_ADDR
// Slozitost = dif_ArtefaktDoba [ Difficulty ] ;
2389: LD_ADDR_LOC 4
2393: PUSH
2394: LD_EXP 43
2398: PUSH
2399: LD_OWVAR 67
2403: ARRAY
2404: ST_TO_ADDR
// end ;
2405: LD_VAR 0 1
2409: RET
// function vytvor_nakladak ( Material , Amount ) ; begin
2410: LD_INT 0
2412: PPUSH
// UC_Side = side_Ru ;
2413: LD_ADDR_OWVAR 20
2417: PUSH
2418: LD_EXP 3
2422: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
2423: LD_ADDR_OWVAR 21
2427: PUSH
2428: LD_INT 3
2430: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
2431: LD_ADDR_OWVAR 37
2435: PUSH
2436: LD_INT 21
2438: ST_TO_ADDR
// VC_Control = CONTROL_COMPUTER ;
2439: LD_ADDR_OWVAR 38
2443: PUSH
2444: LD_INT 3
2446: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
2447: LD_ADDR_OWVAR 39
2451: PUSH
2452: LD_INT 3
2454: ST_TO_ADDR
// VC_Weapon = RU_CARGO_BAY ;
2455: LD_ADDR_OWVAR 40
2459: PUSH
2460: LD_INT 51
2462: ST_TO_ADDR
// Result = CreateVehicle ;
2463: LD_ADDR_VAR 0 3
2467: PUSH
2468: CALL_OW 45
2472: ST_TO_ADDR
// if Amount > 0 then
2473: LD_VAR 0 2
2477: PUSH
2478: LD_INT 0
2480: GREATER
2481: IFFALSE 2502
// SetCargo ( Result , Material , Amount ) ;
2483: LD_VAR 0 3
2487: PPUSH
2488: LD_VAR 0 1
2492: PPUSH
2493: LD_VAR 0 2
2497: PPUSH
2498: CALL_OW 290
// end ;
2502: LD_VAR 0 3
2506: RET
// function vytvor_tank ( Zbran ) ; begin
2507: LD_INT 0
2509: PPUSH
// UC_Side = side_Ru ;
2510: LD_ADDR_OWVAR 20
2514: PUSH
2515: LD_EXP 3
2519: ST_TO_ADDR
// UC_Nation = NATION_RUSSIAN ;
2520: LD_ADDR_OWVAR 21
2524: PUSH
2525: LD_INT 3
2527: ST_TO_ADDR
// VC_Chassis = RU_MEDIUM_WHEELED ;
2528: LD_ADDR_OWVAR 37
2532: PUSH
2533: LD_INT 21
2535: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
2536: LD_ADDR_OWVAR 38
2540: PUSH
2541: LD_INT 1
2543: ST_TO_ADDR
// VC_Engine = ENGINE_COMBUSTION ;
2544: LD_ADDR_OWVAR 39
2548: PUSH
2549: LD_INT 1
2551: ST_TO_ADDR
// VC_Weapon = Zbran ;
2552: LD_ADDR_OWVAR 40
2556: PUSH
2557: LD_VAR 0 1
2561: ST_TO_ADDR
// VC_Fuel_Battery = Rand ( 70 , 90 ) ;
2562: LD_ADDR_OWVAR 41
2566: PUSH
2567: LD_INT 70
2569: PPUSH
2570: LD_INT 90
2572: PPUSH
2573: CALL_OW 12
2577: ST_TO_ADDR
// Result = CreateVehicle ;
2578: LD_ADDR_VAR 0 2
2582: PUSH
2583: CALL_OW 45
2587: ST_TO_ADDR
// end ;
2588: LD_VAR 0 2
2592: RET
// export function uvod ; var I , Auto ; begin
2593: LD_INT 0
2595: PPUSH
2596: PPUSH
2597: PPUSH
// if Masha then
2598: LD_EXP 23
2602: IFFALSE 2635
// begin PlaceHumanInUnit ( Burlak , Masha ) ;
2604: LD_EXP 4
2608: PPUSH
2609: LD_EXP 23
2613: PPUSH
2614: CALL_OW 52
// PlaceUnitArea ( Masha , Start , false ) ;
2618: LD_EXP 23
2622: PPUSH
2623: LD_INT 1
2625: PPUSH
2626: LD_INT 0
2628: PPUSH
2629: CALL_OW 49
// end else
2633: GO 2677
// begin Auto = vytvor_tank ( RU_GUN ) ;
2635: LD_ADDR_VAR 0 3
2639: PUSH
2640: LD_INT 44
2642: PPUSH
2643: CALL 2507 0 1
2647: ST_TO_ADDR
// PlaceHumanInUnit ( Burlak , Auto ) ;
2648: LD_EXP 4
2652: PPUSH
2653: LD_VAR 0 3
2657: PPUSH
2658: CALL_OW 52
// PlaceUnitArea ( Auto , Start , false ) ;
2662: LD_VAR 0 3
2666: PPUSH
2667: LD_INT 1
2669: PPUSH
2670: LD_INT 0
2672: PPUSH
2673: CALL_OW 49
// end ; PlaceUnitArea ( vytvor_nakladak ( MAT_OIL , 100 ) , Start , false ) ;
2677: LD_INT 2
2679: PPUSH
2680: LD_INT 100
2682: PPUSH
2683: CALL 2410 0 2
2687: PPUSH
2688: LD_INT 1
2690: PPUSH
2691: LD_INT 0
2693: PPUSH
2694: CALL_OW 49
// AutoSArtefaktem = vytvor_nakladak ( MAT_ARTIFACT , VelikostArtefaktu * 10 ) ;
2698: LD_ADDR_EXP 30
2702: PUSH
2703: LD_INT 4
2705: PPUSH
2706: LD_EXP 34
2710: PUSH
2711: LD_INT 10
2713: MUL
2714: PPUSH
2715: CALL 2410 0 2
2719: ST_TO_ADDR
// PlaceUnitArea ( AutoSArtefaktem , Start , false ) ;
2720: LD_EXP 30
2724: PPUSH
2725: LD_INT 1
2727: PPUSH
2728: LD_INT 0
2730: PPUSH
2731: CALL_OW 49
// PlaceUnitArea ( Bystrov , Start , false ) ;
2735: LD_EXP 5
2739: PPUSH
2740: LD_INT 1
2742: PPUSH
2743: LD_INT 0
2745: PPUSH
2746: CALL_OW 49
// for I in Rusove do
2750: LD_ADDR_VAR 0 2
2754: PUSH
2755: LD_EXP 27
2759: PUSH
2760: FOR_IN
2761: IFFALSE 2780
// PlaceUnitArea ( I , Start , false ) ;
2763: LD_VAR 0 2
2767: PPUSH
2768: LD_INT 1
2770: PPUSH
2771: LD_INT 0
2773: PPUSH
2774: CALL_OW 49
2778: GO 2760
2780: POP
2781: POP
// InGameOn ;
2782: CALL_OW 8
// I = IsInUnit ( Burlak ) ;
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_EXP 4
2795: PPUSH
2796: CALL_OW 310
2800: ST_TO_ADDR
// if I then
2801: LD_VAR 0 2
2805: IFFALSE 2818
// CenterNowOnUnits ( I ) else
2807: LD_VAR 0 2
2811: PPUSH
2812: CALL_OW 87
2816: GO 2827
// CenterNowOnUnits ( Burlak ) ;
2818: LD_EXP 4
2822: PPUSH
2823: CALL_OW 87
// dialog_Arrival ;
2827: CALL 14921 0 0
// SaveForQuickRestart ;
2831: CALL_OW 22
// ChangeMissionObjectives ( MStart ) ;
2835: LD_STRING MStart
2837: PPUSH
2838: CALL_OW 337
// Hint ( LocateMotherlode ) ;
2842: LD_STRING LocateMotherlode
2844: PPUSH
2845: CALL_OW 339
// InGameOff ;
2849: CALL_OW 9
// end ;
2853: LD_VAR 0 1
2857: RET
// export function rusove_UnitDestroyed ( Un ) ; begin
2858: LD_INT 0
2860: PPUSH
// if Un = Burlak then
2861: LD_VAR 0 1
2865: PUSH
2866: LD_EXP 4
2870: EQUAL
2871: IFFALSE 2882
// begin YouLost ( Burlak ) ;
2873: LD_STRING Burlak
2875: PPUSH
2876: CALL_OW 104
// exit ;
2880: GO 2948
// end ; if Un = AutoSArtefaktem then
2882: LD_VAR 0 1
2886: PUSH
2887: LD_EXP 30
2891: EQUAL
2892: IFFALSE 2913
// begin Wait ( 0 0$1 ) ;
2894: LD_INT 35
2896: PPUSH
2897: CALL_OW 67
// rusove_ArtifactUnloaded ( 0 , VelikostArtefaktu ) ;
2901: LD_INT 0
2903: PPUSH
2904: LD_EXP 34
2908: PPUSH
2909: CALL 4555 0 2
// end ; if Un in LabyST then
2913: LD_VAR 0 1
2917: PUSH
2918: LD_LOC 1
2922: IN
2923: IFFALSE 2948
// begin LabyST = LabyST diff [ Un ] ;
2925: LD_ADDR_LOC 1
2929: PUSH
2930: LD_LOC 1
2934: PUSH
2935: LD_VAR 0 1
2939: PUSH
2940: EMPTY
2941: LIST
2942: DIFF
2943: ST_TO_ADDR
// nastav_artefakt ;
2944: CALL 4930 0 0
// end ; end ;
2948: LD_VAR 0 2
2952: RET
// function je_NW_pulka ( X , Y ) ; begin
2953: LD_INT 0
2955: PPUSH
// X := X - ( Y div 2 ) ;
2956: LD_ADDR_VAR 0 1
2960: PUSH
2961: LD_VAR 0 1
2965: PUSH
2966: LD_VAR 0 2
2970: PUSH
2971: LD_INT 2
2973: DIV
2974: MINUS
2975: ST_TO_ADDR
// Result := ( X + Y ) <= 160 ;
2976: LD_ADDR_VAR 0 3
2980: PUSH
2981: LD_VAR 0 1
2985: PUSH
2986: LD_VAR 0 2
2990: PLUS
2991: PUSH
2992: LD_INT 160
2994: LESSEQUAL
2995: ST_TO_ADDR
// end ;
2996: LD_VAR 0 3
3000: RET
// export function rusove_BuildingStarted ( Bu , Hu ) ; var Typ ; begin
3001: LD_INT 0
3003: PPUSH
3004: PPUSH
// if GetSide ( Bu ) <> side_Ru then
3005: LD_VAR 0 1
3009: PPUSH
3010: CALL_OW 255
3014: PUSH
3015: LD_EXP 3
3019: NONEQUAL
3020: IFFALSE 3024
// exit ;
3022: GO 3207
// Typ = GetBType ( Bu ) ;
3024: LD_ADDR_VAR 0 4
3028: PUSH
3029: LD_VAR 0 1
3033: PPUSH
3034: CALL_OW 266
3038: ST_TO_ADDR
// if Typ = B_DEPOT then
3039: LD_VAR 0 4
3043: PUSH
3044: LD_INT 0
3046: EQUAL
3047: IFFALSE 3123
// begin if not IsInArea ( Bu , Base_NDepot ) and not IsInArea ( Bu , Base_EDepot ) then
3049: LD_VAR 0 1
3053: PPUSH
3054: LD_INT 25
3056: PPUSH
3057: CALL_OW 308
3061: NOT
3062: PUSH
3063: LD_VAR 0 1
3067: PPUSH
3068: LD_INT 24
3070: PPUSH
3071: CALL_OW 308
3075: NOT
3076: AND
3077: IFFALSE 3123
// begin DialogueOn ;
3079: CALL_OW 6
// if je_NW_pulka ( GetX ( Bu ) , GetY ( Bu ) ) then
3083: LD_VAR 0 1
3087: PPUSH
3088: CALL_OW 250
3092: PPUSH
3093: LD_VAR 0 1
3097: PPUSH
3098: CALL_OW 251
3102: PPUSH
3103: CALL 2953 0 2
3107: IFFALSE 3115
// dialog_BadBaseN else
3109: CALL 14965 0 0
3113: GO 3119
// dialog_BadBaseE ;
3115: CALL 14996 0 0
// DialogueOff ;
3119: CALL_OW 7
// end ; end ; if Typ = B_LAB then
3123: LD_VAR 0 4
3127: PUSH
3128: LD_INT 6
3130: EQUAL
3131: IFFALSE 3207
// begin if not IsInArea ( Bu , Base_N2 ) and not IsInArea ( Bu , Base_E2 ) then
3133: LD_VAR 0 1
3137: PPUSH
3138: LD_INT 7
3140: PPUSH
3141: CALL_OW 308
3145: NOT
3146: PUSH
3147: LD_VAR 0 1
3151: PPUSH
3152: LD_INT 9
3154: PPUSH
3155: CALL_OW 308
3159: NOT
3160: AND
3161: IFFALSE 3207
// begin DialogueOn ;
3163: CALL_OW 6
// if je_NW_pulka ( GetX ( Bu ) , GetY ( Bu ) ) then
3167: LD_VAR 0 1
3171: PPUSH
3172: CALL_OW 250
3176: PPUSH
3177: LD_VAR 0 1
3181: PPUSH
3182: CALL_OW 251
3186: PPUSH
3187: CALL 2953 0 2
3191: IFFALSE 3199
// dialog_BadLabN else
3193: CALL 15027 0 0
3197: GO 3203
// dialog_BadLabE ;
3199: CALL 15058 0 0
// DialogueOff ;
3203: CALL_OW 7
// end ; end ; end ;
3207: LD_VAR 0 3
3211: RET
// function je_artefakt_v_zakladne ( Lab ) ; var X , Y , Found ; begin
3212: LD_INT 0
3214: PPUSH
3215: PPUSH
3216: PPUSH
3217: PPUSH
// Result = false ;
3218: LD_ADDR_VAR 0 2
3222: PUSH
3223: LD_INT 0
3225: ST_TO_ADDR
// if ArtefaktMajAmici then
3226: LD_EXP 28
3230: IFFALSE 3234
// exit ;
3232: GO 3303
// if KdeJeArtefakt = 0 then
3234: LD_EXP 29
3238: PUSH
3239: LD_INT 0
3241: EQUAL
3242: IFFALSE 3246
// exit ;
3244: GO 3303
// X = KdeJeArtefakt [ 1 ] ;
3246: LD_ADDR_VAR 0 3
3250: PUSH
3251: LD_EXP 29
3255: PUSH
3256: LD_INT 1
3258: ARRAY
3259: ST_TO_ADDR
// Y = KdeJeArtefakt [ 2 ] ;
3260: LD_ADDR_VAR 0 4
3264: PUSH
3265: LD_EXP 29
3269: PUSH
3270: LD_INT 2
3272: ARRAY
3273: ST_TO_ADDR
// Result = GetDistUnitXY ( Lab , X , Y ) <= 9 ;
3274: LD_ADDR_VAR 0 2
3278: PUSH
3279: LD_VAR 0 1
3283: PPUSH
3284: LD_VAR 0 3
3288: PPUSH
3289: LD_VAR 0 4
3293: PPUSH
3294: CALL_OW 297
3298: PUSH
3299: LD_INT 9
3301: LESSEQUAL
3302: ST_TO_ADDR
// end ;
3303: LD_VAR 0 2
3307: RET
// function rusove_SpaceTimeHotovo ( Lab ) ; begin
3308: LD_INT 0
3310: PPUSH
// if not je_artefakt_v_zakladne ( Lab ) and ( IsInArea ( Lab , Base_N2 ) or IsInArea ( Lab , Base_E2 ) ) then
3311: LD_VAR 0 1
3315: PPUSH
3316: CALL 3212 0 1
3320: NOT
3321: PUSH
3322: LD_VAR 0 1
3326: PPUSH
3327: LD_INT 7
3329: PPUSH
3330: CALL_OW 308
3334: PUSH
3335: LD_VAR 0 1
3339: PPUSH
3340: LD_INT 9
3342: PPUSH
3343: CALL_OW 308
3347: OR
3348: AND
3349: IFFALSE 3363
// begin DialogueOn ;
3351: CALL_OW 6
// dialog_NoArtefact ;
3355: CALL 15089 0 0
// DialogueOff ;
3359: CALL_OW 7
// end ; end ;
3363: LD_VAR 0 2
3367: RET
// export function rusove_UpgradeComplete ( Build ) ; begin
3368: LD_INT 0
3370: PPUSH
// if ( GetSide ( Build ) = side_Ru ) and ( GetBType ( Build ) in [ B_LAB , B_LAB_HALF , B_LAB_FULL ] ) then
3371: LD_VAR 0 1
3375: PPUSH
3376: CALL_OW 255
3380: PUSH
3381: LD_EXP 3
3385: EQUAL
3386: PUSH
3387: LD_VAR 0 1
3391: PPUSH
3392: CALL_OW 266
3396: PUSH
3397: LD_INT 6
3399: PUSH
3400: LD_INT 7
3402: PUSH
3403: LD_INT 8
3405: PUSH
3406: EMPTY
3407: LIST
3408: LIST
3409: LIST
3410: IN
3411: AND
3412: IFFALSE 3495
// begin if not Build in LabyST then
3414: LD_VAR 0 1
3418: PUSH
3419: LD_LOC 1
3423: IN
3424: NOT
3425: IFFALSE 3495
// if ( GetLabKind ( Build , 1 ) = B_LAB_SPACETIME ) or ( GetLabKind ( Build , 2 ) = B_LAB_SPACETIME ) then
3427: LD_VAR 0 1
3431: PPUSH
3432: LD_INT 1
3434: PPUSH
3435: CALL_OW 268
3439: PUSH
3440: LD_INT 14
3442: EQUAL
3443: PUSH
3444: LD_VAR 0 1
3448: PPUSH
3449: LD_INT 2
3451: PPUSH
3452: CALL_OW 268
3456: PUSH
3457: LD_INT 14
3459: EQUAL
3460: OR
3461: IFFALSE 3495
// begin rusove_SpaceTimeHotovo ( Build ) ;
3463: LD_VAR 0 1
3467: PPUSH
3468: CALL 3308 0 1
// LabyST = LabyST union [ Build ] ;
3472: LD_ADDR_LOC 1
3476: PUSH
3477: LD_LOC 1
3481: PUSH
3482: LD_VAR 0 1
3486: PUSH
3487: EMPTY
3488: LIST
3489: UNION
3490: ST_TO_ADDR
// nastav_artefakt ;
3491: CALL 4930 0 0
// end ; end ; end ;
3495: LD_VAR 0 2
3499: RET
// export function rusove_ResearchComplete ( Tech , Lab ) ; begin
3500: LD_INT 0
3502: PPUSH
// if GetSide ( Lab ) <> side_Ru then
3503: LD_VAR 0 2
3507: PPUSH
3508: CALL_OW 255
3512: PUSH
3513: LD_EXP 3
3517: NONEQUAL
3518: IFFALSE 3522
// exit ;
3520: GO 3569
// if Tech = TECH_LAPSER then
3522: LD_VAR 0 1
3526: PUSH
3527: LD_INT 31
3529: EQUAL
3530: IFFALSE 3558
// begin DialogueOn ;
3532: CALL_OW 6
// dialog_TimeLapser2 ;
3536: CALL 15230 0 0
// ChangeMissionObjectives ( MTimeLapser ) ;
3540: LD_STRING MTimeLapser
3542: PPUSH
3543: CALL_OW 337
// Hint ( TimeLapser ) ;
3547: LD_STRING TimeLapser
3549: PPUSH
3550: CALL_OW 339
// DialogueOff ;
3554: CALL_OW 7
// end ; Wait ( 0 0$1 ) ;
3558: LD_INT 35
3560: PPUSH
3561: CALL_OW 67
// nastav_artefakt ;
3565: CALL 4930 0 0
// end ;
3569: LD_VAR 0 3
3573: RET
// export function rusove_ResearchStarted ( Tech , Lab ) ; begin
3574: LD_INT 0
3576: PPUSH
// if GetSide ( Lab ) <> side_Ru then
3577: LD_VAR 0 2
3581: PPUSH
3582: CALL_OW 255
3586: PUSH
3587: LD_EXP 3
3591: NONEQUAL
3592: IFFALSE 3596
// exit ;
3594: GO 3600
// nastav_artefakt ;
3596: CALL 4930 0 0
// end ;
3600: LD_VAR 0 3
3604: RET
// export function rusove_ResearchCancel ( Tech , Lab ) ; begin
3605: LD_INT 0
3607: PPUSH
// if GetSide ( Lab ) <> side_Ru then
3608: LD_VAR 0 2
3612: PPUSH
3613: CALL_OW 255
3617: PUSH
3618: LD_EXP 3
3622: NONEQUAL
3623: IFFALSE 3627
// exit ;
3625: GO 3638
// Wait ( 0 0$0.2 ) ;
3627: LD_INT 7
3629: PPUSH
3630: CALL_OW 67
// nastav_artefakt ;
3634: CALL 4930 0 0
// end ;
3638: LD_VAR 0 3
3642: RET
// export function rusove_SpecResearchCancel ( Lab , Progress ) ; begin
3643: LD_INT 0
3645: PPUSH
// zrus_pouziti_artefaktu ;
3646: CALL 4772 0 0
// Wait ( 0 0$0.2 ) ;
3650: LD_INT 7
3652: PPUSH
3653: CALL_OW 67
// nastav_artefakt ;
3657: CALL 4930 0 0
// end ;
3661: LD_VAR 0 3
3665: RET
// function mereni_complete ( Lab ) ; var OldOKN , OldOKE ; begin
3666: LD_INT 0
3668: PPUSH
3669: PPUSH
3670: PPUSH
// if not je_artefakt_v_zakladne ( Lab ) then
3671: LD_VAR 0 1
3675: PPUSH
3676: CALL 3212 0 1
3680: NOT
3681: IFFALSE 3685
// exit ;
3683: GO 4014
// OldOKN = OK_North ;
3685: LD_ADDR_VAR 0 3
3689: PUSH
3690: LD_EXP 31
3694: ST_TO_ADDR
// OldOKE = OK_East ;
3695: LD_ADDR_VAR 0 4
3699: PUSH
3700: LD_EXP 32
3704: ST_TO_ADDR
// if IsInArea ( Lab , Base_N2 ) then
3705: LD_VAR 0 1
3709: PPUSH
3710: LD_INT 7
3712: PPUSH
3713: CALL_OW 308
3717: IFFALSE 3737
// OK_North = max ( OK_North , 1 ) ;
3719: LD_ADDR_EXP 31
3723: PUSH
3724: LD_EXP 31
3728: PPUSH
3729: LD_INT 1
3731: PPUSH
3732: CALL 15712 0 2
3736: ST_TO_ADDR
// if IsInArea ( Lab , Base_N1 ) then
3737: LD_VAR 0 1
3741: PPUSH
3742: LD_INT 6
3744: PPUSH
3745: CALL_OW 308
3749: IFFALSE 3769
// OK_North = max ( OK_North , 2 ) ;
3751: LD_ADDR_EXP 31
3755: PUSH
3756: LD_EXP 31
3760: PPUSH
3761: LD_INT 2
3763: PPUSH
3764: CALL 15712 0 2
3768: ST_TO_ADDR
// if IsInArea ( Lab , Base_E2 ) then
3769: LD_VAR 0 1
3773: PPUSH
3774: LD_INT 9
3776: PPUSH
3777: CALL_OW 308
3781: IFFALSE 3801
// OK_East = max ( OK_East , 1 ) ;
3783: LD_ADDR_EXP 32
3787: PUSH
3788: LD_EXP 32
3792: PPUSH
3793: LD_INT 1
3795: PPUSH
3796: CALL 15712 0 2
3800: ST_TO_ADDR
// if IsInArea ( Lab , Base_E1 ) then
3801: LD_VAR 0 1
3805: PPUSH
3806: LD_INT 8
3808: PPUSH
3809: CALL_OW 308
3813: IFFALSE 3833
// OK_East = max ( OK_East , 2 ) ;
3815: LD_ADDR_EXP 32
3819: PUSH
3820: LD_EXP 32
3824: PPUSH
3825: LD_INT 2
3827: PPUSH
3828: CALL 15712 0 2
3832: ST_TO_ADDR
// if not OldOKN and OK_North then
3833: LD_VAR 0 3
3837: NOT
3838: PUSH
3839: LD_EXP 31
3843: AND
3844: IFFALSE 3899
// begin DialogueOn ;
3846: CALL_OW 6
// if OK_East then
3850: LD_EXP 32
3854: IFFALSE 3862
// dialog_Done2 else
3856: CALL 15151 0 0
3860: GO 3888
// begin dialog_Done1 ;
3862: CALL 15120 0 0
// if GetTech ( TECH_LAPSER , side_Ru ) <> STATE_RESEARCHED then
3866: LD_INT 31
3868: PPUSH
3869: LD_EXP 3
3873: PPUSH
3874: CALL_OW 321
3878: PUSH
3879: LD_INT 2
3881: NONEQUAL
3882: IFFALSE 3888
// dialog_TimeLapser1 ;
3884: CALL 15182 0 0
// end ; DialogueOff ;
3888: CALL_OW 7
// ChangeMissionObjectives ( MOutNorth ) ;
3892: LD_STRING MOutNorth
3894: PPUSH
3895: CALL_OW 337
// end ; if not OldOKE and OK_East then
3899: LD_VAR 0 4
3903: NOT
3904: PUSH
3905: LD_EXP 32
3909: AND
3910: IFFALSE 3965
// begin DialogueOn ;
3912: CALL_OW 6
// if OK_North then
3916: LD_EXP 31
3920: IFFALSE 3928
// dialog_Done2 else
3922: CALL 15151 0 0
3926: GO 3954
// begin dialog_Done1 ;
3928: CALL 15120 0 0
// if GetTech ( TECH_LAPSER , side_Ru ) <> STATE_RESEARCHED then
3932: LD_INT 31
3934: PPUSH
3935: LD_EXP 3
3939: PPUSH
3940: CALL_OW 321
3944: PUSH
3945: LD_INT 2
3947: NONEQUAL
3948: IFFALSE 3954
// dialog_TimeLapser1 ;
3950: CALL 15182 0 0
// end ; DialogueOff ;
3954: CALL_OW 7
// ChangeMissionObjectives ( MOutEast ) ;
3958: LD_STRING MOutEast
3960: PPUSH
3961: CALL_OW 337
// end ; if not ( OldOKN and OldOKE ) and OK_North and OK_East then
3965: LD_VAR 0 3
3969: PUSH
3970: LD_VAR 0 4
3974: AND
3975: NOT
3976: PUSH
3977: LD_EXP 31
3981: AND
3982: PUSH
3983: LD_EXP 32
3987: AND
3988: IFFALSE 4010
// begin ChangeMissionObjectives ( MFinish ) ;
3990: LD_STRING MFinish
3992: PPUSH
3993: CALL_OW 337
// SetAreaMapShow ( Cil , 1 ) ;
3997: LD_INT 10
3999: PPUSH
4000: LD_INT 1
4002: PPUSH
4003: CALL_OW 424
// enable ( 1 ) ;
4007: LD_INT 1
4009: ENABLE_MARKED
// end ; nastav_artefakt ;
4010: CALL 4930 0 0
// end ;
4014: LD_VAR 0 2
4018: RET
// function postavil_lapser ; begin
4019: LD_INT 0
4021: PPUSH
// if not TimeLapser then
4022: LD_EXP 33
4026: NOT
4027: IFFALSE 4044
// begin TimeLapser = true ;
4029: LD_ADDR_EXP 33
4033: PUSH
4034: LD_INT 1
4036: ST_TO_ADDR
// ChangeMissionObjectives ( MTLOut ) ;
4037: LD_STRING MTLOut
4039: PPUSH
4040: CALL_OW 337
// end ; end ;
4044: LD_VAR 0 1
4048: RET
// export function rusove_VehicleConstructed ( Veh , Fact ) ; begin
4049: LD_INT 0
4051: PPUSH
// if ( GetSide ( Veh ) = side_Ru ) and ( GetWeapon ( Veh ) = RU_TIME_LAPSER ) then
4052: LD_VAR 0 1
4056: PPUSH
4057: CALL_OW 255
4061: PUSH
4062: LD_EXP 3
4066: EQUAL
4067: PUSH
4068: LD_VAR 0 1
4072: PPUSH
4073: CALL_OW 264
4077: PUSH
4078: LD_INT 49
4080: EQUAL
4081: AND
4082: IFFALSE 4088
// postavil_lapser ;
4084: CALL 4019 0 0
// end ;
4088: LD_VAR 0 3
4092: RET
// export function rusove_WeaponPlaced ( Build , Fact ) ; begin
4093: LD_INT 0
4095: PPUSH
// if ( GetSide ( Build ) = side_Ru ) and ( GetBWeapon ( Build ) = RU_TIME_LAPSER ) then
4096: LD_VAR 0 1
4100: PPUSH
4101: CALL_OW 255
4105: PUSH
4106: LD_EXP 3
4110: EQUAL
4111: PUSH
4112: LD_VAR 0 1
4116: PPUSH
4117: CALL_OW 269
4121: PUSH
4122: LD_INT 49
4124: EQUAL
4125: AND
4126: IFFALSE 4132
// postavil_lapser ;
4128: CALL 4019 0 0
// end ;
4132: LD_VAR 0 3
4136: RET
// function zjisti_konec ; var Lidi ; begin
4137: LD_INT 0
4139: PPUSH
4140: PPUSH
// End_The_Mission_Allowed = false ;
4141: LD_ADDR_OWVAR 57
4145: PUSH
4146: LD_INT 0
4148: ST_TO_ADDR
// if not IsInArea ( Burlak , Cil ) then
4149: LD_EXP 4
4153: PPUSH
4154: LD_INT 10
4156: PPUSH
4157: CALL_OW 308
4161: NOT
4162: IFFALSE 4166
// exit ;
4164: GO 4285
// if not AutoSArtefaktem then
4166: LD_EXP 30
4170: NOT
4171: IFFALSE 4175
// exit ;
4173: GO 4285
// if GetSide ( AutoSArtefaktem ) <> side_Ru then
4175: LD_EXP 30
4179: PPUSH
4180: CALL_OW 255
4184: PUSH
4185: LD_EXP 3
4189: NONEQUAL
4190: IFFALSE 4194
// exit ;
4192: GO 4285
// if not IsInArea ( AutoSArtefaktem , Cil ) then
4194: LD_EXP 30
4198: PPUSH
4199: LD_INT 10
4201: PPUSH
4202: CALL_OW 308
4206: NOT
4207: IFFALSE 4211
// exit ;
4209: GO 4285
// Lidi = FilterUnitsExceptArea ( Cil , [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
4211: LD_ADDR_VAR 0 2
4215: PUSH
4216: LD_INT 10
4218: PPUSH
4219: LD_INT 22
4221: PUSH
4222: LD_EXP 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 52
4233: PUSH
4234: EMPTY
4235: LIST
4236: PUSH
4237: LD_INT 50
4239: PUSH
4240: EMPTY
4241: LIST
4242: PUSH
4243: LD_INT 21
4245: PUSH
4246: LD_INT 1
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: LIST
4257: LIST
4258: PPUSH
4259: CALL_OW 71
4263: ST_TO_ADDR
// if not Lidi then
4264: LD_VAR 0 2
4268: NOT
4269: IFFALSE 4277
// vyhral else
4271: CALL 2070 0 0
4275: GO 4285
// begin End_The_Mission_Allowed = true ;
4277: LD_ADDR_OWVAR 57
4281: PUSH
4282: LD_INT 1
4284: ST_TO_ADDR
// end ; end ;
4285: LD_VAR 0 1
4289: RET
// on EndTheMissionRaised ( Unknown ) do var Lidi , I ;
4290: LD_INT 0
4292: PPUSH
4293: PPUSH
// begin Lidi = FilterUnitsExceptArea ( Cil , [ [ F_SIDE , side_Ru ] , [ F_PLACED ] , [ F_OK ] , [ F_TYPE , UNIT_HUMAN ] ] ) ;
4294: LD_ADDR_VAR 0 2
4298: PUSH
4299: LD_INT 10
4301: PPUSH
4302: LD_INT 22
4304: PUSH
4305: LD_EXP 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 52
4316: PUSH
4317: EMPTY
4318: LIST
4319: PUSH
4320: LD_INT 50
4322: PUSH
4323: EMPTY
4324: LIST
4325: PUSH
4326: LD_INT 21
4328: PUSH
4329: LD_INT 1
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: PPUSH
4342: CALL_OW 71
4346: ST_TO_ADDR
// for I in Lidi do
4347: LD_ADDR_VAR 0 3
4351: PUSH
4352: LD_VAR 0 2
4356: PUSH
4357: FOR_IN
4358: IFFALSE 4371
// DestroyUnit ( I ) ;
4360: LD_VAR 0 3
4364: PPUSH
4365: CALL_OW 65
4369: GO 4357
4371: POP
4372: POP
// vyhral ;
4373: CALL 2070 0 0
// end ;
4377: PPOPN 3
4379: END
// every 0 0$4.1 marked 1 do
4380: GO 4382
4382: DISABLE
// begin zjisti_konec ;
4383: CALL 4137 0 0
// enable ;
4387: ENABLE
// end ;
4388: END
// export function rusove_ArtifactLoaded ( Un , Size ) ; begin
4389: LD_INT 0
4391: PPUSH
// zrus_pouziti_artefaktu ;
4392: CALL 4772 0 0
// KdeJeArtefakt = 0 ;
4396: LD_ADDR_EXP 29
4400: PUSH
4401: LD_INT 0
4403: ST_TO_ADDR
// AutoSArtefaktem = Un ;
4404: LD_ADDR_EXP 30
4408: PUSH
4409: LD_VAR 0 1
4413: ST_TO_ADDR
// if GetSide ( Un ) = side_Ru then
4414: LD_VAR 0 1
4418: PPUSH
4419: CALL_OW 255
4423: PUSH
4424: LD_EXP 3
4428: EQUAL
4429: IFFALSE 4441
// ArtefaktMajAmici = false else
4431: LD_ADDR_EXP 28
4435: PUSH
4436: LD_INT 0
4438: ST_TO_ADDR
4439: GO 4461
// begin ArtefaktMajAmici = true ;
4441: LD_ADDR_EXP 28
4445: PUSH
4446: LD_INT 1
4448: ST_TO_ADDR
// DialogueOn ;
4449: CALL_OW 6
// dialog_ArtefactSteal ;
4453: CALL 15302 0 0
// DialogueOff ;
4457: CALL_OW 7
// end ; nastav_artefakt ;
4461: CALL 4930 0 0
// end ;
4465: LD_VAR 0 3
4469: RET
// export function event_ArtefactStolen ; begin
4470: LD_INT 0
4472: PPUSH
// YouLost ( Artefact ) ;
4473: LD_STRING Artefact
4475: PPUSH
4476: CALL_OW 104
// end ;
4480: LD_VAR 0 1
4484: RET
// every 0 0$5.1 trigger ArtefaktMajAmici do
4485: LD_EXP 28
4489: IFFALSE 4554
4491: GO 4493
4493: DISABLE
// begin if IsInArea ( AutoSArtefaktem , AmericaniArtefakt ) then
4494: LD_EXP 30
4498: PPUSH
4499: LD_INT 26
4501: PPUSH
4502: CALL_OW 308
4506: IFFALSE 4514
// event_ArtefactStolen else
4508: CALL 4470 0 0
4512: GO 4553
// begin ComAgressiveMove ( AutoSArtefaktem , 143 , 13 ) ;
4514: LD_EXP 30
4518: PPUSH
4519: LD_INT 143
4521: PPUSH
4522: LD_INT 13
4524: PPUSH
4525: CALL_OW 114
// AddComMoveToArea ( AutoSArtefaktem , AmericaniArtefakt ) ;
4529: LD_EXP 30
4533: PPUSH
4534: LD_INT 26
4536: PPUSH
4537: CALL_OW 173
// AddComSailEvent ( AutoSArtefaktem , 102 ) ;
4541: LD_EXP 30
4545: PPUSH
4546: LD_INT 102
4548: PPUSH
4549: CALL_OW 224
// end ; enable ;
4553: ENABLE
// end ;
4554: END
// export function rusove_ArtifactUnloaded ( Un , Size ) ; var Souradnice ; begin
4555: LD_INT 0
4557: PPUSH
4558: PPUSH
// AutoSArtefaktem = 0 ;
4559: LD_ADDR_EXP 30
4563: PUSH
4564: LD_INT 0
4566: ST_TO_ADDR
// ArtefaktMajAmici = false ;
4567: LD_ADDR_EXP 28
4571: PUSH
4572: LD_INT 0
4574: ST_TO_ADDR
// Souradnice = FindArtifact ( VelikostArtefaktu ) ;
4575: LD_ADDR_VAR 0 4
4579: PUSH
4580: LD_EXP 34
4584: PPUSH
4585: CALL_OW 469
4589: ST_TO_ADDR
// KdeJeArtefakt = [ Souradnice [ 1 ] , Souradnice [ 2 ] ] ;
4590: LD_ADDR_EXP 29
4594: PUSH
4595: LD_VAR 0 4
4599: PUSH
4600: LD_INT 1
4602: ARRAY
4603: PUSH
4604: LD_VAR 0 4
4608: PUSH
4609: LD_INT 2
4611: ARRAY
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: ST_TO_ADDR
// nastav_artefakt ;
4617: CALL 4930 0 0
// end ;
4621: LD_VAR 0 3
4625: RET
// function je_lab ( Lab ) ; begin
4626: LD_INT 0
4628: PPUSH
// Result = GetBType ( Lab ) in [ B_LAB , B_LAB_HALF , B_LAB_FULL ] ;
4629: LD_ADDR_VAR 0 2
4633: PUSH
4634: LD_VAR 0 1
4638: PPUSH
4639: CALL_OW 266
4643: PUSH
4644: LD_INT 6
4646: PUSH
4647: LD_INT 7
4649: PUSH
4650: LD_INT 8
4652: PUSH
4653: EMPTY
4654: LIST
4655: LIST
4656: LIST
4657: IN
4658: ST_TO_ADDR
// end ;
4659: LD_VAR 0 2
4663: RET
// function muze_pouzit_artefakt ( Lab ) ; begin
4664: LD_INT 0
4666: PPUSH
// Result = false ;
4667: LD_ADDR_VAR 0 2
4671: PUSH
4672: LD_INT 0
4674: ST_TO_ADDR
// if not IsInArea ( Lab , Base_N2 ) and not IsInArea ( Lab , Base_E2 ) then
4675: LD_VAR 0 1
4679: PPUSH
4680: LD_INT 7
4682: PPUSH
4683: CALL_OW 308
4687: NOT
4688: PUSH
4689: LD_VAR 0 1
4693: PPUSH
4694: LD_INT 9
4696: PPUSH
4697: CALL_OW 308
4701: NOT
4702: AND
4703: IFFALSE 4707
// exit ;
4705: GO 4767
// if not je_artefakt_v_zakladne ( Lab ) then
4707: LD_VAR 0 1
4711: PPUSH
4712: CALL 3212 0 1
4716: NOT
4717: IFFALSE 4721
// exit ;
4719: GO 4767
// if ( GetLabKind ( Lab , 1 ) <> B_LAB_SPACETIME ) and ( GetLabKind ( Lab , 2 ) <> B_LAB_SPACETIME ) then
4721: LD_VAR 0 1
4725: PPUSH
4726: LD_INT 1
4728: PPUSH
4729: CALL_OW 268
4733: PUSH
4734: LD_INT 14
4736: NONEQUAL
4737: PUSH
4738: LD_VAR 0 1
4742: PPUSH
4743: LD_INT 2
4745: PPUSH
4746: CALL_OW 268
4750: PUSH
4751: LD_INT 14
4753: NONEQUAL
4754: AND
4755: IFFALSE 4759
// exit ;
4757: GO 4767
// Result = true ;
4759: LD_ADDR_VAR 0 2
4763: PUSH
4764: LD_INT 1
4766: ST_TO_ADDR
// end ;
4767: LD_VAR 0 2
4771: RET
// function zrus_pouziti_artefaktu ; begin
4772: LD_INT 0
4774: PPUSH
// SetNoActivity ( MericiLaborator ) ;
4775: LD_LOC 3
4779: PPUSH
4780: CALL_OW 487
// MericiLaborator = 0 ;
4784: LD_ADDR_LOC 3
4788: PUSH
4789: LD_INT 0
4791: ST_TO_ADDR
// end ;
4792: LD_VAR 0 1
4796: RET
// export function rusove_SpecResearchComplete ( Lab ) ; begin
4797: LD_INT 0
4799: PPUSH
// mereni_complete ( MericiLaborator ) ;
4800: LD_LOC 3
4804: PPUSH
4805: CALL 3666 0 1
// zrus_pouziti_artefaktu ;
4809: CALL 4772 0 0
// nastav_artefakt ;
4813: CALL 4930 0 0
// end ;
4817: LD_VAR 0 2
4821: RET
// export function rusove_ArtifactUsed ( Side , Number , P1 , P2 ) ; var Lab ; begin
4822: LD_INT 0
4824: PPUSH
4825: PPUSH
// if Side <> side_Ru then
4826: LD_VAR 0 1
4830: PUSH
4831: LD_EXP 3
4835: NONEQUAL
4836: IFFALSE 4840
// exit ;
4838: GO 4894
// if not LabySArtefaktem then
4840: LD_LOC 2
4844: NOT
4845: IFFALSE 4849
// exit ;
4847: GO 4894
// Lab = LabySArtefaktem [ 1 ] ;
4849: LD_ADDR_VAR 0 6
4853: PUSH
4854: LD_LOC 2
4858: PUSH
4859: LD_INT 1
4861: ARRAY
4862: ST_TO_ADDR
// MericiLaborator = Lab ;
4863: LD_ADDR_LOC 3
4867: PUSH
4868: LD_VAR 0 6
4872: ST_TO_ADDR
// SetSpecResearch ( Lab , Slozitost , true ) ;
4873: LD_VAR 0 6
4877: PPUSH
4878: LD_LOC 4
4882: PPUSH
4883: LD_INT 1
4885: PPUSH
4886: CALL_OW 486
// nastav_artefakt ;
4890: CALL 4930 0 0
// end ;
4894: LD_VAR 0 5
4898: RET
// function nastav_pouziti ( Jak , Lab ) ; var L ; begin
4899: LD_INT 0
4901: PPUSH
4902: PPUSH
// SetArtifactUse ( side_Ru , ART_USE_EYE , Jak , Lab ) ;
4903: LD_EXP 3
4907: PPUSH
4908: LD_INT 4
4910: PPUSH
4911: LD_VAR 0 1
4915: PPUSH
4916: LD_VAR 0 2
4920: PPUSH
4921: CALL_OW 468
// end ;
4925: LD_VAR 0 3
4929: RET
// function nastav_artefakt ; var L ; begin
4930: LD_INT 0
4932: PPUSH
4933: PPUSH
// if MericiLaborator then
4934: LD_LOC 3
4938: IFFALSE 4971
// begin for L in LabySArtefaktem do
4940: LD_ADDR_VAR 0 2
4944: PUSH
4945: LD_LOC 2
4949: PUSH
4950: FOR_IN
4951: IFFALSE 4967
// nastav_pouziti ( ART_GRAY , L ) end else
4953: LD_INT 1
4955: PPUSH
4956: LD_VAR 0 2
4960: PPUSH
4961: CALL 4899 0 2
4965: GO 4950
4967: POP
4968: POP
4969: GO 5206
// begin for L in LabySArtefaktem do
4971: LD_ADDR_VAR 0 2
4975: PUSH
4976: LD_LOC 2
4980: PUSH
4981: FOR_IN
4982: IFFALSE 4998
// nastav_pouziti ( ART_NO , L ) ;
4984: LD_INT 0
4986: PPUSH
4987: LD_VAR 0 2
4991: PPUSH
4992: CALL 4899 0 2
4996: GO 4981
4998: POP
4999: POP
// LabySArtefaktem = [ ] ;
5000: LD_ADDR_LOC 2
5004: PUSH
5005: EMPTY
5006: ST_TO_ADDR
// if KdeJeArtefakt then
5007: LD_EXP 29
5011: IFFALSE 5133
// begin for L in LabyST do
5013: LD_ADDR_VAR 0 2
5017: PUSH
5018: LD_LOC 1
5022: PUSH
5023: FOR_IN
5024: IFFALSE 5058
// if muze_pouzit_artefakt ( L ) then
5026: LD_VAR 0 2
5030: PPUSH
5031: CALL 4664 0 1
5035: IFFALSE 5056
// LabySArtefaktem = LabySArtefaktem union [ L ] ;
5037: LD_ADDR_LOC 2
5041: PUSH
5042: LD_LOC 2
5046: PUSH
5047: LD_VAR 0 2
5051: PUSH
5052: EMPTY
5053: LIST
5054: UNION
5055: ST_TO_ADDR
5056: GO 5023
5058: POP
5059: POP
// if ( LabySArtefaktem > 1 ) then
5060: LD_LOC 2
5064: PUSH
5065: LD_INT 1
5067: GREATER
5068: IFFALSE 5131
// begin L = NearestUnitToXY ( LabySArtefaktem , KdeJeArtefakt [ 1 ] , KdeJeArtefakt [ 2 ] ) ;
5070: LD_ADDR_VAR 0 2
5074: PUSH
5075: LD_LOC 2
5079: PPUSH
5080: LD_EXP 29
5084: PUSH
5085: LD_INT 1
5087: ARRAY
5088: PPUSH
5089: LD_EXP 29
5093: PUSH
5094: LD_INT 2
5096: ARRAY
5097: PPUSH
5098: CALL_OW 73
5102: ST_TO_ADDR
// if L then
5103: LD_VAR 0 2
5107: IFFALSE 5124
// LabySArtefaktem = [ L ] else
5109: LD_ADDR_LOC 2
5113: PUSH
5114: LD_VAR 0 2
5118: PUSH
5119: EMPTY
5120: LIST
5121: ST_TO_ADDR
5122: GO 5131
// LabySArtefaktem = [ ] ;
5124: LD_ADDR_LOC 2
5128: PUSH
5129: EMPTY
5130: ST_TO_ADDR
// end ; end else
5131: GO 5140
// LabySArtefaktem = [ ] ;
5133: LD_ADDR_LOC 2
5137: PUSH
5138: EMPTY
5139: ST_TO_ADDR
// if LabySArtefaktem then
5140: LD_LOC 2
5144: IFFALSE 5202
// begin for L in LabySArtefaktem do
5146: LD_ADDR_VAR 0 2
5150: PUSH
5151: LD_LOC 2
5155: PUSH
5156: FOR_IN
5157: IFFALSE 5198
// if GetActResearch ( L ) then
5159: LD_VAR 0 2
5163: PPUSH
5164: CALL_OW 485
5168: IFFALSE 5184
// nastav_pouziti ( ART_GRAY , L ) else
5170: LD_INT 1
5172: PPUSH
5173: LD_VAR 0 2
5177: PPUSH
5178: CALL 4899 0 2
5182: GO 5196
// nastav_pouziti ( ART_INSTANT , L ) ;
5184: LD_INT 2
5186: PPUSH
5187: LD_VAR 0 2
5191: PPUSH
5192: CALL 4899 0 2
5196: GO 5156
5198: POP
5199: POP
// end else
5200: GO 5206
// zrus_pouziti_artefaktu ;
5202: CALL 4772 0 0
// end ; end ;
5206: LD_VAR 0 1
5210: RET
// export function rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
5211: LD_INT 0
5213: PPUSH
// if Masha = VehOld then
5214: LD_EXP 23
5218: PUSH
5219: LD_VAR 0 2
5223: EQUAL
5224: IFFALSE 5236
// Masha = VehNew ;
5226: LD_ADDR_EXP 23
5230: PUSH
5231: LD_VAR 0 1
5235: ST_TO_ADDR
// if VehOld = AutoSArtefaktem then
5236: LD_VAR 0 2
5240: PUSH
5241: LD_EXP 30
5245: EQUAL
5246: IFFALSE 5270
// begin AutoSArtefaktem = VehNew ;
5248: LD_ADDR_EXP 30
5252: PUSH
5253: LD_VAR 0 1
5257: ST_TO_ADDR
// rusove_ArtifactLoaded ( VehNew , 0 ) ;
5258: LD_VAR 0 1
5262: PPUSH
5263: LD_INT 0
5265: PPUSH
5266: CALL 4389 0 2
// end ; end ; end_of_file
5270: LD_VAR 0 5
5274: RET
// var AmSci1 , AmSci2 , AmSci3 , AmSci4 ; var AmMech1 , AmMech2 , AmMech3 , AmMech4 ; var AmEng1 , AmEng2 ; var AmEng_Oil , AmEng_Sib ; var Obranci , Obranci_Oil , Obranci_Sib ; var Patrola ; var Konvoj , Doprovod ; var Tanky ; var Max_Tanky , Max_Doprovod ; var Kradenik ; var MamKontrolovatVyrobu ; var VyrobenoAut ; var ProbihaPrevoz ; var PrevozNalozil , PrevozVylozil ; var VidelRusa ; var ProbihaUtok ; var CisloUtoku ; var PrvniUtok ; var ZacalyUtoky ; var Utok_ZbyvaMinut ; var CasyUtoku ; var Utok_Auta ; var KdoLeci ; var KdoOpravuje ; var ZnicenOil , ZnicenSib ; var KonvojBylRozebran ; var RozebratAuta ; var RegUtok , RegPatrola ; var MakroObrana , MakroUtok , MakroUtokMove ; var MakroPatrola ; var MakroPrevoz ; export function init_amici ; var Base , Reg ; begin
5275: LD_INT 0
5277: PPUSH
5278: PPUSH
5279: PPUSH
// disable ( 21 ) ;
5280: LD_INT 21
5282: DISABLE_MARKED
// disable ( 22 ) ;
5283: LD_INT 22
5285: DISABLE_MARKED
// RevealFogArea ( side_Am , Americani ) ;
5286: LD_EXP 2
5290: PPUSH
5291: LD_INT 2
5293: PPUSH
5294: CALL_OW 332
// RevealFogArea ( side_Am , Americani_Oil ) ;
5298: LD_EXP 2
5302: PPUSH
5303: LD_INT 19
5305: PPUSH
5306: CALL_OW 332
// RevealFogArea ( side_Am , Americani_Sib ) ;
5310: LD_EXP 2
5314: PPUSH
5315: LD_INT 20
5317: PPUSH
5318: CALL_OW 332
// PrvniUtok = dif_PrvniUtok [ Difficulty ] ;
5322: LD_ADDR_LOC 35
5326: PUSH
5327: LD_EXP 41
5331: PUSH
5332: LD_OWVAR 67
5336: ARRAY
5337: ST_TO_ADDR
// CasyUtoku = dif_CasovacUtoku [ Difficulty ] ;
5338: LD_ADDR_LOC 38
5342: PUSH
5343: LD_EXP 42
5347: PUSH
5348: LD_OWVAR 67
5352: ARRAY
5353: ST_TO_ADDR
// vytvor_postavy ;
5354: CALL 5872 0 0
// Kradenik = 0 ;
5358: LD_ADDR_LOC 26
5362: PUSH
5363: LD_INT 0
5365: ST_TO_ADDR
// Tanky = [ ] ;
5366: LD_ADDR_LOC 23
5370: PUSH
5371: EMPTY
5372: ST_TO_ADDR
// Konvoj = [ ] ;
5373: LD_ADDR_LOC 21
5377: PUSH
5378: EMPTY
5379: ST_TO_ADDR
// Doprovod = [ ] ;
5380: LD_ADDR_LOC 22
5384: PUSH
5385: EMPTY
5386: ST_TO_ADDR
// Max_Tanky = 7 ;
5387: LD_ADDR_LOC 24
5391: PUSH
5392: LD_INT 7
5394: ST_TO_ADDR
// Max_Doprovod = 2 ;
5395: LD_ADDR_LOC 25
5399: PUSH
5400: LD_INT 2
5402: ST_TO_ADDR
// ProbihaPrevoz = 0 ;
5403: LD_ADDR_LOC 29
5407: PUSH
5408: LD_INT 0
5410: ST_TO_ADDR
// VidelRusa = false ;
5411: LD_ADDR_LOC 32
5415: PUSH
5416: LD_INT 0
5418: ST_TO_ADDR
// ZacalyUtoky = false ;
5419: LD_ADDR_LOC 36
5423: PUSH
5424: LD_INT 0
5426: ST_TO_ADDR
// ProbihaUtok = false ;
5427: LD_ADDR_LOC 33
5431: PUSH
5432: LD_INT 0
5434: ST_TO_ADDR
// Utok_ZbyvaMinut = - 1 ;
5435: LD_ADDR_LOC 37
5439: PUSH
5440: LD_INT 1
5442: NEG
5443: ST_TO_ADDR
// CisloUtoku = 1 ;
5444: LD_ADDR_LOC 34
5448: PUSH
5449: LD_INT 1
5451: ST_TO_ADDR
// Utok_Auta = [ ] ;
5452: LD_ADDR_LOC 39
5456: PUSH
5457: EMPTY
5458: ST_TO_ADDR
// KdoLeci = [ ] ;
5459: LD_ADDR_LOC 40
5463: PUSH
5464: EMPTY
5465: ST_TO_ADDR
// KdoOpravuje = [ ] ;
5466: LD_ADDR_LOC 41
5470: PUSH
5471: EMPTY
5472: ST_TO_ADDR
// ZnicenOil = false ;
5473: LD_ADDR_LOC 42
5477: PUSH
5478: LD_INT 0
5480: ST_TO_ADDR
// ZnicenSib = false ;
5481: LD_ADDR_LOC 43
5485: PUSH
5486: LD_INT 0
5488: ST_TO_ADDR
// KonvojBylRozebran = false ;
5489: LD_ADDR_LOC 44
5493: PUSH
5494: LD_INT 0
5496: ST_TO_ADDR
// RozebratAuta = false ;
5497: LD_ADDR_LOC 45
5501: PUSH
5502: LD_INT 0
5504: ST_TO_ADDR
// MamKontrolovatVyrobu = false ;
5505: LD_ADDR_LOC 27
5509: PUSH
5510: LD_INT 0
5512: ST_TO_ADDR
// VyrobenoAut = 0 ;
5513: LD_ADDR_LOC 28
5517: PUSH
5518: LD_INT 0
5520: ST_TO_ADDR
// sur ( AmDepot , 500 , 280 , 250 ) ;
5521: LD_INT 15
5523: PPUSH
5524: LD_INT 500
5526: PPUSH
5527: LD_INT 280
5529: PPUSH
5530: LD_INT 250
5532: PPUSH
5533: CALL 6855 0 4
// sur ( AmDepot_Oil , 180 - Difficulty * 30 , 50 , 0 ) ;
5537: LD_INT 1
5539: PPUSH
5540: LD_INT 180
5542: PUSH
5543: LD_OWVAR 67
5547: PUSH
5548: LD_INT 30
5550: MUL
5551: MINUS
5552: PPUSH
5553: LD_INT 50
5555: PPUSH
5556: LD_INT 0
5558: PPUSH
5559: CALL 6855 0 4
// sur ( AmDepot_Sib , 180 - Difficulty * 30 , 30 , 50 ) ;
5563: LD_INT 3
5565: PPUSH
5566: LD_INT 180
5568: PUSH
5569: LD_OWVAR 67
5573: PUSH
5574: LD_INT 30
5576: MUL
5577: MINUS
5578: PPUSH
5579: LD_INT 30
5581: PPUSH
5582: LD_INT 50
5584: PPUSH
5585: CALL 6855 0 4
// zacni_zkoumat ;
5589: CALL 6615 0 0
// zacni_vyrabet ;
5593: CALL 6793 0 0
// if Obranci_Oil then
5597: LD_LOC 18
5601: IFFALSE 5650
// begin Reg = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_PROTECT , Americani_Oil ] ] ) ;
5603: LD_ADDR_VAR 0 3
5607: PUSH
5608: LD_EXP 2
5612: PPUSH
5613: LD_INT 3
5615: PUSH
5616: LD_INT 19
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: PUSH
5623: EMPTY
5624: LIST
5625: PPUSH
5626: CALL_OW 399
5630: ST_TO_ADDR
// McDefend ( 1 , Reg , Obranci_Oil , [ ] ) ;
5631: LD_INT 1
5633: PPUSH
5634: LD_VAR 0 3
5638: PPUSH
5639: LD_LOC 18
5643: PPUSH
5644: EMPTY
5645: PPUSH
5646: CALL_OW 401
// end ; if Obranci_Sib then
5650: LD_LOC 19
5654: IFFALSE 5703
// begin Reg = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_PROTECT , Americani_Sib ] ] ) ;
5656: LD_ADDR_VAR 0 3
5660: PUSH
5661: LD_EXP 2
5665: PPUSH
5666: LD_INT 3
5668: PUSH
5669: LD_INT 20
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: PUSH
5676: EMPTY
5677: LIST
5678: PPUSH
5679: CALL_OW 399
5683: ST_TO_ADDR
// McDefend ( 1 , Reg , Obranci_Sib , [ ] ) ;
5684: LD_INT 1
5686: PPUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_LOC 19
5696: PPUSH
5697: EMPTY
5698: PPUSH
5699: CALL_OW 401
// end ; RegUtok = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_GUARD , AreaUtok ] , MC_REG_IGNORE_FOG ] ) ;
5703: LD_ADDR_LOC 46
5707: PUSH
5708: LD_EXP 2
5712: PPUSH
5713: LD_INT 2
5715: PUSH
5716: LD_INT 21
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 7
5725: PUSH
5726: EMPTY
5727: LIST
5728: LIST
5729: PPUSH
5730: CALL_OW 399
5734: ST_TO_ADDR
// RegPatrola = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_GUARD , AreaUtok ] , - MC_REG_ONLY_IMPORTANT ] ) ;
5735: LD_ADDR_LOC 47
5739: PUSH
5740: LD_EXP 2
5744: PPUSH
5745: LD_INT 2
5747: PUSH
5748: LD_INT 21
5750: PUSH
5751: EMPTY
5752: LIST
5753: LIST
5754: PUSH
5755: LD_INT 8
5757: NEG
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: PPUSH
5763: CALL_OW 399
5767: ST_TO_ADDR
// Reg = McRegistry ( side_Am , [ [ MC_REG_AREA_TO_PROTECT , AmericaniObrana ] ] ) ;
5768: LD_ADDR_VAR 0 3
5772: PUSH
5773: LD_EXP 2
5777: PPUSH
5778: LD_INT 3
5780: PUSH
5781: LD_INT 23
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: EMPTY
5789: LIST
5790: PPUSH
5791: CALL_OW 399
5795: ST_TO_ADDR
// MakroObrana = McDefend ( 2 , Reg , Tanky union Obranci , [ [ MC_AREA_DONT_LEAVE , Americani ] ] ) ;
5796: LD_ADDR_LOC 48
5800: PUSH
5801: LD_INT 2
5803: PPUSH
5804: LD_VAR 0 3
5808: PPUSH
5809: LD_LOC 23
5813: PUSH
5814: LD_LOC 17
5818: UNION
5819: PPUSH
5820: LD_INT 2
5822: PUSH
5823: LD_INT 2
5825: PUSH
5826: EMPTY
5827: LIST
5828: LIST
5829: PUSH
5830: EMPTY
5831: LIST
5832: PPUSH
5833: CALL_OW 401
5837: ST_TO_ADDR
// MakroPatrola = McPatrol ( 100 , RegPatrola , Patrola , [ MC_NO_STOP ] ) ;
5838: LD_ADDR_LOC 51
5842: PUSH
5843: LD_INT 100
5845: PPUSH
5846: LD_LOC 47
5850: PPUSH
5851: LD_LOC 20
5855: PPUSH
5856: LD_INT 10
5858: PUSH
5859: EMPTY
5860: LIST
5861: PPUSH
5862: CALL_OW 403
5866: ST_TO_ADDR
// end ;
5867: LD_VAR 0 1
5871: RET
// function vytvor_postavy ; begin
5872: LD_INT 0
5874: PPUSH
// AmSci1 = vytvor_postavu_B ( AmLabWS , CLASS_SCIENTISTIC ) ;
5875: LD_ADDR_LOC 5
5879: PUSH
5880: LD_INT 24
5882: PPUSH
5883: LD_INT 4
5885: PPUSH
5886: CALL 6471 0 2
5890: ST_TO_ADDR
// AmSci2 = vytvor_postavu_B ( AmLabWS , CLASS_SCIENTISTIC ) ;
5891: LD_ADDR_LOC 6
5895: PUSH
5896: LD_INT 24
5898: PPUSH
5899: LD_INT 4
5901: PPUSH
5902: CALL 6471 0 2
5906: ST_TO_ADDR
// AmSci3 = vytvor_postavu_B ( AmLabCO , CLASS_SCIENTISTIC ) ;
5907: LD_ADDR_LOC 7
5911: PUSH
5912: LD_INT 25
5914: PPUSH
5915: LD_INT 4
5917: PPUSH
5918: CALL 6471 0 2
5922: ST_TO_ADDR
// AmSci4 = vytvor_postavu_B ( AmLabCO , CLASS_SCIENTISTIC ) ;
5923: LD_ADDR_LOC 8
5927: PUSH
5928: LD_INT 25
5930: PPUSH
5931: LD_INT 4
5933: PPUSH
5934: CALL 6471 0 2
5938: ST_TO_ADDR
// AmMech1 = vytvor_postavu_B ( AmFactGun , CLASS_MECHANIC ) ;
5939: LD_ADDR_LOC 9
5943: PUSH
5944: LD_INT 30
5946: PPUSH
5947: LD_INT 3
5949: PPUSH
5950: CALL 6471 0 2
5954: ST_TO_ADDR
// AmMech2 = vytvor_postavu_B ( AmFactGun , CLASS_MECHANIC ) ;
5955: LD_ADDR_LOC 10
5959: PUSH
5960: LD_INT 30
5962: PPUSH
5963: LD_INT 3
5965: PPUSH
5966: CALL 6471 0 2
5970: ST_TO_ADDR
// AmMech3 = vytvor_postavu_B ( AmFactRock , CLASS_MECHANIC ) ;
5971: LD_ADDR_LOC 11
5975: PUSH
5976: LD_INT 26
5978: PPUSH
5979: LD_INT 3
5981: PPUSH
5982: CALL 6471 0 2
5986: ST_TO_ADDR
// AmMech4 = vytvor_postavu_B ( AmFactRock , CLASS_MECHANIC ) ;
5987: LD_ADDR_LOC 12
5991: PUSH
5992: LD_INT 26
5994: PPUSH
5995: LD_INT 3
5997: PPUSH
5998: CALL 6471 0 2
6002: ST_TO_ADDR
// AmEng1 = vytvor_postavu_A ( Americani , CLASS_ENGINEER ) ;
6003: LD_ADDR_LOC 13
6007: PUSH
6008: LD_INT 2
6010: PPUSH
6011: LD_INT 2
6013: PPUSH
6014: CALL 6508 0 2
6018: ST_TO_ADDR
// AmEng2 = vytvor_postavu_A ( Americani , CLASS_ENGINEER ) ;
6019: LD_ADDR_LOC 14
6023: PUSH
6024: LD_INT 2
6026: PPUSH
6027: LD_INT 2
6029: PPUSH
6030: CALL 6508 0 2
6034: ST_TO_ADDR
// AmEng_Oil = vytvor_postavu_B ( AmDepot_Oil , CLASS_ENGINEER ) ;
6035: LD_ADDR_LOC 15
6039: PUSH
6040: LD_INT 1
6042: PPUSH
6043: LD_INT 2
6045: PPUSH
6046: CALL 6471 0 2
6050: ST_TO_ADDR
// AmEng_Sib = vytvor_postavu_B ( AmDepot_Sib , CLASS_ENGINEER ) ;
6051: LD_ADDR_LOC 16
6055: PUSH
6056: LD_INT 3
6058: PPUSH
6059: LD_INT 2
6061: PPUSH
6062: CALL 6471 0 2
6066: ST_TO_ADDR
// Obranci = vytvor_postavy_A ( 8 , Americani , CLASS_SOLDIER ) union vytvor_postavy_A ( 2 , Americani , CLASS_SNIPER ) ;
6067: LD_ADDR_LOC 17
6071: PUSH
6072: LD_INT 8
6074: PPUSH
6075: LD_INT 2
6077: PPUSH
6078: LD_INT 1
6080: PPUSH
6081: CALL 6548 0 3
6085: PUSH
6086: LD_INT 2
6088: PPUSH
6089: LD_INT 2
6091: PPUSH
6092: LD_INT 5
6094: PPUSH
6095: CALL 6548 0 3
6099: UNION
6100: ST_TO_ADDR
// Patrola = vytvor_postavy_A ( Difficulty + 2 , Americani , CLASS_SOLDIER ) ;
6101: LD_ADDR_LOC 20
6105: PUSH
6106: LD_OWVAR 67
6110: PUSH
6111: LD_INT 2
6113: PLUS
6114: PPUSH
6115: LD_INT 2
6117: PPUSH
6118: LD_INT 1
6120: PPUSH
6121: CALL 6548 0 3
6125: ST_TO_ADDR
// Obranci_Oil = vytvor_postavy_A ( Difficulty - 1 , Americani_Oil , CLASS_SOLDIER ) ;
6126: LD_ADDR_LOC 18
6130: PUSH
6131: LD_OWVAR 67
6135: PUSH
6136: LD_INT 1
6138: MINUS
6139: PPUSH
6140: LD_INT 19
6142: PPUSH
6143: LD_INT 1
6145: PPUSH
6146: CALL 6548 0 3
6150: ST_TO_ADDR
// Obranci_Sib = vytvor_postavy_A ( Difficulty - 1 , Americani_Sib , CLASS_SOLDIER ) ;
6151: LD_ADDR_LOC 19
6155: PUSH
6156: LD_OWVAR 67
6160: PUSH
6161: LD_INT 1
6163: MINUS
6164: PPUSH
6165: LD_INT 20
6167: PPUSH
6168: LD_INT 1
6170: PPUSH
6171: CALL 6548 0 3
6175: ST_TO_ADDR
// end ;
6176: LD_VAR 0 1
6180: RET
// function zpet_domu ( Kdo ) ; begin
6181: LD_INT 0
6183: PPUSH
// if Kdo = AmSci1 then
6184: LD_VAR 0 1
6188: PUSH
6189: LD_LOC 5
6193: EQUAL
6194: IFFALSE 6210
// AddComEnterUnit ( Kdo , AmLabWS ) else
6196: LD_VAR 0 1
6200: PPUSH
6201: LD_INT 24
6203: PPUSH
6204: CALL_OW 180
6208: GO 6390
// if Kdo = AmSci2 then
6210: LD_VAR 0 1
6214: PUSH
6215: LD_LOC 6
6219: EQUAL
6220: IFFALSE 6236
// AddComEnterUnit ( Kdo , AmLabWS ) else
6222: LD_VAR 0 1
6226: PPUSH
6227: LD_INT 24
6229: PPUSH
6230: CALL_OW 180
6234: GO 6390
// if Kdo = AmSci3 then
6236: LD_VAR 0 1
6240: PUSH
6241: LD_LOC 7
6245: EQUAL
6246: IFFALSE 6262
// AddComEnterUnit ( Kdo , AmLabCO ) else
6248: LD_VAR 0 1
6252: PPUSH
6253: LD_INT 25
6255: PPUSH
6256: CALL_OW 180
6260: GO 6390
// if Kdo = AmSci4 then
6262: LD_VAR 0 1
6266: PUSH
6267: LD_LOC 8
6271: EQUAL
6272: IFFALSE 6288
// AddComEnterUnit ( Kdo , AmLabCO ) else
6274: LD_VAR 0 1
6278: PPUSH
6279: LD_INT 25
6281: PPUSH
6282: CALL_OW 180
6286: GO 6390
// if Kdo = AmMech1 then
6288: LD_VAR 0 1
6292: PUSH
6293: LD_LOC 9
6297: EQUAL
6298: IFFALSE 6314
// AddComEnterUnit ( Kdo , AmFactGun ) else
6300: LD_VAR 0 1
6304: PPUSH
6305: LD_INT 30
6307: PPUSH
6308: CALL_OW 180
6312: GO 6390
// if Kdo = AmMech2 then
6314: LD_VAR 0 1
6318: PUSH
6319: LD_LOC 10
6323: EQUAL
6324: IFFALSE 6340
// AddComEnterUnit ( Kdo , AmFactGun ) else
6326: LD_VAR 0 1
6330: PPUSH
6331: LD_INT 30
6333: PPUSH
6334: CALL_OW 180
6338: GO 6390
// if Kdo = AmMech3 then
6340: LD_VAR 0 1
6344: PUSH
6345: LD_LOC 11
6349: EQUAL
6350: IFFALSE 6366
// AddComEnterUnit ( Kdo , AmFactRock ) else
6352: LD_VAR 0 1
6356: PPUSH
6357: LD_INT 26
6359: PPUSH
6360: CALL_OW 180
6364: GO 6390
// if Kdo = AmMech4 then
6366: LD_VAR 0 1
6370: PUSH
6371: LD_LOC 12
6375: EQUAL
6376: IFFALSE 6390
// AddComEnterUnit ( Kdo , AmFactRock ) ;
6378: LD_VAR 0 1
6382: PPUSH
6383: LD_INT 26
6385: PPUSH
6386: CALL_OW 180
// end ;
6390: LD_VAR 0 2
6394: RET
// function vytvor_postavu ( Cls ) ; var X , Y ; begin
6395: LD_INT 0
6397: PPUSH
6398: PPUSH
6399: PPUSH
// UC_Side = side_Am ;
6400: LD_ADDR_OWVAR 20
6404: PUSH
6405: LD_EXP 2
6409: ST_TO_ADDR
// UC_Nation = NATION_AMERICAN ;
6410: LD_ADDR_OWVAR 21
6414: PUSH
6415: LD_INT 1
6417: ST_TO_ADDR
// HC_Sex = Rand ( SEX_MALE , SEX_FEMALE ) ;
6418: LD_ADDR_OWVAR 27
6422: PUSH
6423: LD_INT 1
6425: PPUSH
6426: LD_INT 2
6428: PPUSH
6429: CALL_OW 12
6433: ST_TO_ADDR
// HC_Class = Cls ;
6434: LD_ADDR_OWVAR 28
6438: PUSH
6439: LD_VAR 0 1
6443: ST_TO_ADDR
// PrepareClassSkills ( Cls , 7 ) ;
6444: LD_VAR 0 1
6448: PPUSH
6449: LD_INT 7
6451: PPUSH
6452: CALL_OW 374
// Result = CreateHuman ;
6456: LD_ADDR_VAR 0 2
6460: PUSH
6461: CALL_OW 44
6465: ST_TO_ADDR
// end ;
6466: LD_VAR 0 2
6470: RET
// function vytvor_postavu_B ( Budova , Cls ) ; begin
6471: LD_INT 0
6473: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6474: LD_ADDR_VAR 0 3
6478: PUSH
6479: LD_VAR 0 2
6483: PPUSH
6484: CALL 6395 0 1
6488: ST_TO_ADDR
// PlaceHumanInUnit ( Result , Budova ) ;
6489: LD_VAR 0 3
6493: PPUSH
6494: LD_VAR 0 1
6498: PPUSH
6499: CALL_OW 52
// end ;
6503: LD_VAR 0 3
6507: RET
// function vytvor_postavu_A ( Area , Cls ) ; begin
6508: LD_INT 0
6510: PPUSH
// Result = vytvor_postavu ( Cls ) ;
6511: LD_ADDR_VAR 0 3
6515: PUSH
6516: LD_VAR 0 2
6520: PPUSH
6521: CALL 6395 0 1
6525: ST_TO_ADDR
// PlaceUnitArea ( Result , Area , false ) ;
6526: LD_VAR 0 3
6530: PPUSH
6531: LD_VAR 0 1
6535: PPUSH
6536: LD_INT 0
6538: PPUSH
6539: CALL_OW 49
// end ;
6543: LD_VAR 0 3
6547: RET
// function vytvor_postavy_A ( Pocet , Area , Cls ) ; var I ; begin
6548: LD_INT 0
6550: PPUSH
6551: PPUSH
// Result = [ ] ;
6552: LD_ADDR_VAR 0 4
6556: PUSH
6557: EMPTY
6558: ST_TO_ADDR
// for I = 1 to Pocet do
6559: LD_ADDR_VAR 0 5
6563: PUSH
6564: DOUBLE
6565: LD_INT 1
6567: DEC
6568: ST_TO_ADDR
6569: LD_VAR 0 1
6573: PUSH
6574: FOR_TO
6575: IFFALSE 6608
// Result = Result union [ vytvor_postavu_A ( Area , Cls ) ] ;
6577: LD_ADDR_VAR 0 4
6581: PUSH
6582: LD_VAR 0 4
6586: PUSH
6587: LD_VAR 0 2
6591: PPUSH
6592: LD_VAR 0 3
6596: PPUSH
6597: CALL 6508 0 2
6601: PUSH
6602: EMPTY
6603: LIST
6604: UNION
6605: ST_TO_ADDR
6606: GO 6574
6608: POP
6609: POP
// end ;
6610: LD_VAR 0 4
6614: RET
// function zacni_zkoumat ; begin
6615: LD_INT 0
6617: PPUSH
// AddComResearch ( AmLabWS , TECH_TECH1 ) ;
6618: LD_INT 24
6620: PPUSH
6621: LD_INT 48
6623: PPUSH
6624: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_WEAP1 ) ;
6628: LD_INT 24
6630: PPUSH
6631: LD_INT 51
6633: PPUSH
6634: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_SIB1 ) ;
6638: LD_INT 24
6640: PPUSH
6641: LD_INT 54
6643: PPUSH
6644: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_TECH2 ) ;
6648: LD_INT 24
6650: PPUSH
6651: LD_INT 49
6653: PPUSH
6654: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_WEAP2 ) ;
6658: LD_INT 24
6660: PPUSH
6661: LD_INT 52
6663: PPUSH
6664: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_SIB2 ) ;
6668: LD_INT 24
6670: PPUSH
6671: LD_INT 55
6673: PPUSH
6674: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_TECH3 ) ;
6678: LD_INT 24
6680: PPUSH
6681: LD_INT 50
6683: PPUSH
6684: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_WEAP3 ) ;
6688: LD_INT 24
6690: PPUSH
6691: LD_INT 53
6693: PPUSH
6694: CALL_OW 184
// AddComResearch ( AmLabWS , TECH_SIB3 ) ;
6698: LD_INT 24
6700: PPUSH
6701: LD_INT 56
6703: PPUSH
6704: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_MATDET ) ;
6708: LD_INT 25
6710: PPUSH
6711: LD_INT 7
6713: PPUSH
6714: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_VIRUS ) ;
6718: LD_INT 25
6720: PPUSH
6721: LD_INT 33
6723: PPUSH
6724: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_COMP1 ) ;
6728: LD_INT 25
6730: PPUSH
6731: LD_INT 57
6733: PPUSH
6734: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_OPTO1 ) ;
6738: LD_INT 25
6740: PPUSH
6741: LD_INT 60
6743: PPUSH
6744: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_COMP2 ) ;
6748: LD_INT 25
6750: PPUSH
6751: LD_INT 58
6753: PPUSH
6754: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_OPTO2 ) ;
6758: LD_INT 25
6760: PPUSH
6761: LD_INT 61
6763: PPUSH
6764: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_COMP3 ) ;
6768: LD_INT 25
6770: PPUSH
6771: LD_INT 59
6773: PPUSH
6774: CALL_OW 184
// AddComResearch ( AmLabCO , TECH_OPTO3 ) ;
6778: LD_INT 25
6780: PPUSH
6781: LD_INT 62
6783: PPUSH
6784: CALL_OW 184
// end ;
6788: LD_VAR 0 1
6792: RET
// function zacni_vyrabet ; var I ; begin
6793: LD_INT 0
6795: PPUSH
6796: PPUSH
// for I = 1 to 2 do
6797: LD_ADDR_VAR 0 2
6801: PUSH
6802: DOUBLE
6803: LD_INT 1
6805: DEC
6806: ST_TO_ADDR
6807: LD_INT 2
6809: PUSH
6810: FOR_TO
6811: IFFALSE 6819
// vyrob_nakladak ;
6813: CALL 7579 0 0
6817: GO 6810
6819: POP
6820: POP
// for I = 1 to Max_Doprovod do
6821: LD_ADDR_VAR 0 2
6825: PUSH
6826: DOUBLE
6827: LD_INT 1
6829: DEC
6830: ST_TO_ADDR
6831: LD_LOC 25
6835: PUSH
6836: FOR_TO
6837: IFFALSE 6848
// vyrob_tank ( false ) ;
6839: LD_INT 0
6841: PPUSH
6842: CALL 7606 0 1
6846: GO 6836
6848: POP
6849: POP
// end ;
6850: LD_VAR 0 1
6854: RET
// function sur ( Budova , Cans , Oil , Sib ) ; var Base ; begin
6855: LD_INT 0
6857: PPUSH
6858: PPUSH
// Base = GetBase ( Budova ) ;
6859: LD_ADDR_VAR 0 6
6863: PUSH
6864: LD_VAR 0 1
6868: PPUSH
6869: CALL_OW 274
6873: ST_TO_ADDR
// SetResourceType ( Base , MAT_CANS , Cans ) ;
6874: LD_VAR 0 6
6878: PPUSH
6879: LD_INT 1
6881: PPUSH
6882: LD_VAR 0 2
6886: PPUSH
6887: CALL_OW 277
// SetResourceType ( Base , MAT_OIL , Oil ) ;
6891: LD_VAR 0 6
6895: PPUSH
6896: LD_INT 2
6898: PPUSH
6899: LD_VAR 0 3
6903: PPUSH
6904: CALL_OW 277
// SetResourceType ( Base , MAT_SIBERIT , Sib ) ;
6908: LD_VAR 0 6
6912: PPUSH
6913: LD_INT 3
6915: PPUSH
6916: LD_VAR 0 4
6920: PPUSH
6921: CALL_OW 277
// end ;
6925: LD_VAR 0 5
6929: RET
// export function amici_VehicleConstructed ( Veh , Fact ) ; var Weapon ; begin
6930: LD_INT 0
6932: PPUSH
6933: PPUSH
// if GetSide ( Veh ) = side_Am then
6934: LD_VAR 0 1
6938: PPUSH
6939: CALL_OW 255
6943: PUSH
6944: LD_EXP 2
6948: EQUAL
6949: IFFALSE 7161
// begin Weapon = GetWeapon ( Veh ) ;
6951: LD_ADDR_VAR 0 4
6955: PUSH
6956: LD_VAR 0 1
6960: PPUSH
6961: CALL_OW 264
6965: ST_TO_ADDR
// VyrobenoAut = VyrobenoAut + 1 ;
6966: LD_ADDR_LOC 28
6970: PUSH
6971: LD_LOC 28
6975: PUSH
6976: LD_INT 1
6978: PLUS
6979: ST_TO_ADDR
// if VyrobenoAut >= 2 + Max_Doprovod then
6980: LD_LOC 28
6984: PUSH
6985: LD_INT 2
6987: PUSH
6988: LD_LOC 25
6992: PLUS
6993: GREATEREQUAL
6994: IFFALSE 7004
// MamKontrolovatVyrobu = true ;
6996: LD_ADDR_LOC 27
7000: PUSH
7001: LD_INT 1
7003: ST_TO_ADDR
// if ( Weapon = US_CARGO_BAY ) then
7004: LD_VAR 0 4
7008: PUSH
7009: LD_INT 12
7011: EQUAL
7012: IFFALSE 7063
// begin if not Kradenik then
7014: LD_LOC 26
7018: NOT
7019: IFFALSE 7033
// Kradenik = Veh else
7021: LD_ADDR_LOC 26
7025: PUSH
7026: LD_VAR 0 1
7030: ST_TO_ADDR
7031: GO 7052
// Konvoj = Konvoj union [ Veh ] ;
7033: LD_ADDR_LOC 21
7037: PUSH
7038: LD_LOC 21
7042: PUSH
7043: LD_VAR 0 1
7047: PUSH
7048: EMPTY
7049: LIST
7050: UNION
7051: ST_TO_ADDR
// AddComHold ( Veh ) ;
7052: LD_VAR 0 1
7056: PPUSH
7057: CALL_OW 200
// end else
7061: GO 7161
// begin if not KonvojBylRozebran and ( Doprovod < Max_Doprovod ) and ( Weapon <> US_DOUBLE_LASER ) then
7063: LD_LOC 44
7067: NOT
7068: PUSH
7069: LD_LOC 22
7073: PUSH
7074: LD_LOC 25
7078: LESS
7079: AND
7080: PUSH
7081: LD_VAR 0 4
7085: PUSH
7086: LD_INT 10
7088: NONEQUAL
7089: AND
7090: IFFALSE 7113
// begin Doprovod = Doprovod union [ Veh ] ;
7092: LD_ADDR_LOC 22
7096: PUSH
7097: LD_LOC 22
7101: PUSH
7102: LD_VAR 0 1
7106: PUSH
7107: EMPTY
7108: LIST
7109: UNION
7110: ST_TO_ADDR
// end else
7111: GO 7161
// begin Tanky = Tanky union [ Veh ] ;
7113: LD_ADDR_LOC 23
7117: PUSH
7118: LD_LOC 23
7122: PUSH
7123: LD_VAR 0 1
7127: PUSH
7128: EMPTY
7129: LIST
7130: UNION
7131: ST_TO_ADDR
// ComMoveToArea ( Veh , Parkoviste ) ;
7132: LD_VAR 0 1
7136: PPUSH
7137: LD_INT 3
7139: PPUSH
7140: CALL_OW 113
// AddMcUnits ( MakroObrana , [ Veh ] ) ;
7144: LD_LOC 48
7148: PPUSH
7149: LD_VAR 0 1
7153: PUSH
7154: EMPTY
7155: LIST
7156: PPUSH
7157: CALL_OW 390
// end ; end ; end ; end ;
7161: LD_VAR 0 3
7165: RET
// function jednotka_pryc ( Un ) ; begin
7166: LD_INT 0
7168: PPUSH
// if Un = Kradenik then
7169: LD_VAR 0 1
7173: PUSH
7174: LD_LOC 26
7178: EQUAL
7179: IFFALSE 7189
// Kradenik = 0 ;
7181: LD_ADDR_LOC 26
7185: PUSH
7186: LD_INT 0
7188: ST_TO_ADDR
// if Un in Tanky then
7189: LD_VAR 0 1
7193: PUSH
7194: LD_LOC 23
7198: IN
7199: IFFALSE 7220
// Tanky = Tanky diff [ Un ] ;
7201: LD_ADDR_LOC 23
7205: PUSH
7206: LD_LOC 23
7210: PUSH
7211: LD_VAR 0 1
7215: PUSH
7216: EMPTY
7217: LIST
7218: DIFF
7219: ST_TO_ADDR
// if Un in Konvoj then
7220: LD_VAR 0 1
7224: PUSH
7225: LD_LOC 21
7229: IN
7230: IFFALSE 7251
// Konvoj = Konvoj diff [ Un ] ;
7232: LD_ADDR_LOC 21
7236: PUSH
7237: LD_LOC 21
7241: PUSH
7242: LD_VAR 0 1
7246: PUSH
7247: EMPTY
7248: LIST
7249: DIFF
7250: ST_TO_ADDR
// if Un in Doprovod then
7251: LD_VAR 0 1
7255: PUSH
7256: LD_LOC 22
7260: IN
7261: IFFALSE 7282
// Doprovod = Doprovod diff [ Un ] ;
7263: LD_ADDR_LOC 22
7267: PUSH
7268: LD_LOC 22
7272: PUSH
7273: LD_VAR 0 1
7277: PUSH
7278: EMPTY
7279: LIST
7280: DIFF
7281: ST_TO_ADDR
// if Un in Obranci then
7282: LD_VAR 0 1
7286: PUSH
7287: LD_LOC 17
7291: IN
7292: IFFALSE 7313
// Obranci = Obranci diff [ Un ] ;
7294: LD_ADDR_LOC 17
7298: PUSH
7299: LD_LOC 17
7303: PUSH
7304: LD_VAR 0 1
7308: PUSH
7309: EMPTY
7310: LIST
7311: DIFF
7312: ST_TO_ADDR
// if Un in Patrola then
7313: LD_VAR 0 1
7317: PUSH
7318: LD_LOC 20
7322: IN
7323: IFFALSE 7344
// Patrola = Patrola diff [ Un ] ;
7325: LD_ADDR_LOC 20
7329: PUSH
7330: LD_LOC 20
7334: PUSH
7335: LD_VAR 0 1
7339: PUSH
7340: EMPTY
7341: LIST
7342: DIFF
7343: ST_TO_ADDR
// if Un in Utok_Auta then
7344: LD_VAR 0 1
7348: PUSH
7349: LD_LOC 39
7353: IN
7354: IFFALSE 7375
// Utok_Auta = Utok_Auta diff [ Un ] ;
7356: LD_ADDR_LOC 39
7360: PUSH
7361: LD_LOC 39
7365: PUSH
7366: LD_VAR 0 1
7370: PUSH
7371: EMPTY
7372: LIST
7373: DIFF
7374: ST_TO_ADDR
// if Un in RozebratAuta then
7375: LD_VAR 0 1
7379: PUSH
7380: LD_LOC 45
7384: IN
7385: IFFALSE 7406
// RozebratAuta = RozebratAuta diff [ Un ] ;
7387: LD_ADDR_LOC 45
7391: PUSH
7392: LD_LOC 45
7396: PUSH
7397: LD_VAR 0 1
7401: PUSH
7402: EMPTY
7403: LIST
7404: DIFF
7405: ST_TO_ADDR
// if Un in KdoLeci then
7406: LD_VAR 0 1
7410: PUSH
7411: LD_LOC 40
7415: IN
7416: IFFALSE 7437
// KdoLeci = KdoLeci diff [ Un ] ;
7418: LD_ADDR_LOC 40
7422: PUSH
7423: LD_LOC 40
7427: PUSH
7428: LD_VAR 0 1
7432: PUSH
7433: EMPTY
7434: LIST
7435: DIFF
7436: ST_TO_ADDR
// if Un in KdoOpravuje then
7437: LD_VAR 0 1
7441: PUSH
7442: LD_LOC 41
7446: IN
7447: IFFALSE 7468
// KdoOpravuje = KdoOpravuje diff [ Un ] ;
7449: LD_ADDR_LOC 41
7453: PUSH
7454: LD_LOC 41
7458: PUSH
7459: LD_VAR 0 1
7463: PUSH
7464: EMPTY
7465: LIST
7466: DIFF
7467: ST_TO_ADDR
// if not Konvoj then
7468: LD_LOC 21
7472: NOT
7473: IFFALSE 7483
// ProbihaPrevoz = 0 ;
7475: LD_ADDR_LOC 29
7479: PUSH
7480: LD_INT 0
7482: ST_TO_ADDR
// if not Patrola then
7483: LD_LOC 20
7487: NOT
7488: IFFALSE 7499
// KillMc ( MakroPatrola ) ;
7490: LD_LOC 51
7494: PPUSH
7495: CALL_OW 387
// end ;
7499: LD_VAR 0 2
7503: RET
// export function amici_UnitDestroyed ( Un ) ; begin
7504: LD_INT 0
7506: PPUSH
// jednotka_pryc ( Un ) ;
7507: LD_VAR 0 1
7511: PPUSH
7512: CALL 7166 0 1
// end ;
7516: LD_VAR 0 2
7520: RET
// export function amici_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ; begin
7521: LD_INT 0
7523: PPUSH
// if ( OrigSide = side_Am ) then
7524: LD_VAR 0 3
7528: PUSH
7529: LD_EXP 2
7533: EQUAL
7534: IFFALSE 7545
// jednotka_pryc ( VehOld ) ;
7536: LD_VAR 0 2
7540: PPUSH
7541: CALL 7166 0 1
// end ;
7545: LD_VAR 0 5
7549: RET
// export function amici_BuildingCaptured ( Build , OrigSide , Eng ) ; begin
7550: LD_INT 0
7552: PPUSH
// if ( OrigSide = side_Am ) then
7553: LD_VAR 0 2
7557: PUSH
7558: LD_EXP 2
7562: EQUAL
7563: IFFALSE 7574
// jednotka_pryc ( Build ) ;
7565: LD_VAR 0 1
7569: PPUSH
7570: CALL 7166 0 1
// end ;
7574: LD_VAR 0 4
7578: RET
// function vyrob_nakladak ; begin
7579: LD_INT 0
7581: PPUSH
// AddComConstruct ( AmFactRock , US_MEDIUM_WHEELED , ENGINE_SIBERITE , CONTROL_COMPUTER , US_CARGO_BAY ) ;
7582: LD_INT 26
7584: PPUSH
7585: LD_INT 2
7587: PPUSH
7588: LD_INT 3
7590: PPUSH
7591: LD_INT 3
7593: PPUSH
7594: LD_INT 12
7596: PPUSH
7597: CALL_OW 185
// end ;
7601: LD_VAR 0 1
7605: RET
// function vyrob_tank ( PovolitDblAPasy ) ; var P , Chassis , Weapon , Tovarna ; begin
7606: LD_INT 0
7608: PPUSH
7609: PPUSH
7610: PPUSH
7611: PPUSH
7612: PPUSH
// if PovolitDblAPasy then
7613: LD_VAR 0 1
7617: IFFALSE 7637
// P = Rand ( 1 , 100 ) else
7619: LD_ADDR_VAR 0 3
7623: PUSH
7624: LD_INT 1
7626: PPUSH
7627: LD_INT 100
7629: PPUSH
7630: CALL_OW 12
7634: ST_TO_ADDR
7635: GO 7691
// begin P = Rand ( 1 , 79 ) ;
7637: LD_ADDR_VAR 0 3
7641: PUSH
7642: LD_INT 1
7644: PPUSH
7645: LD_INT 79
7647: PPUSH
7648: CALL_OW 12
7652: ST_TO_ADDR
// while ( P >= 30 ) and ( P < 45 ) do
7653: LD_VAR 0 3
7657: PUSH
7658: LD_INT 30
7660: GREATEREQUAL
7661: PUSH
7662: LD_VAR 0 3
7666: PUSH
7667: LD_INT 45
7669: LESS
7670: AND
7671: IFFALSE 7691
// P = Rand ( 1 , 79 ) ;
7673: LD_ADDR_VAR 0 3
7677: PUSH
7678: LD_INT 1
7680: PPUSH
7681: LD_INT 79
7683: PPUSH
7684: CALL_OW 12
7688: ST_TO_ADDR
7689: GO 7653
// end ; if ( Difficulty = 1 ) and ( P >= 80 ) then
7691: LD_OWVAR 67
7695: PUSH
7696: LD_INT 1
7698: EQUAL
7699: PUSH
7700: LD_VAR 0 3
7704: PUSH
7705: LD_INT 80
7707: GREATEREQUAL
7708: AND
7709: IFFALSE 7727
// P = Rand ( 1 , 79 ) ;
7711: LD_ADDR_VAR 0 3
7715: PUSH
7716: LD_INT 1
7718: PPUSH
7719: LD_INT 79
7721: PPUSH
7722: CALL_OW 12
7726: ST_TO_ADDR
// if P < 15 then
7727: LD_VAR 0 3
7731: PUSH
7732: LD_INT 15
7734: LESS
7735: IFFALSE 7755
// begin Weapon = US_LASER ;
7737: LD_ADDR_VAR 0 5
7741: PUSH
7742: LD_INT 9
7744: ST_TO_ADDR
// Chassis = US_MEDIUM_WHEELED ;
7745: LD_ADDR_VAR 0 4
7749: PUSH
7750: LD_INT 2
7752: ST_TO_ADDR
// end else
7753: GO 7883
// if P < 30 then
7755: LD_VAR 0 3
7759: PUSH
7760: LD_INT 30
7762: LESS
7763: IFFALSE 7783
// begin Weapon = US_GATLING_GUN ;
7765: LD_ADDR_VAR 0 5
7769: PUSH
7770: LD_INT 4
7772: ST_TO_ADDR
// Chassis = US_MEDIUM_WHEELED ;
7773: LD_ADDR_VAR 0 4
7777: PUSH
7778: LD_INT 2
7780: ST_TO_ADDR
// end else
7781: GO 7883
// if P < 45 then
7783: LD_VAR 0 3
7787: PUSH
7788: LD_INT 45
7790: LESS
7791: IFFALSE 7811
// begin Weapon = US_HEAVY_GUN ;
7793: LD_ADDR_VAR 0 5
7797: PUSH
7798: LD_INT 6
7800: ST_TO_ADDR
// Chassis = US_HEAVY_TRACKED ;
7801: LD_ADDR_VAR 0 4
7805: PUSH
7806: LD_INT 4
7808: ST_TO_ADDR
// end else
7809: GO 7883
// if P < 60 then
7811: LD_VAR 0 3
7815: PUSH
7816: LD_INT 60
7818: LESS
7819: IFFALSE 7839
// begin Weapon = US_DOUBLE_GUN ;
7821: LD_ADDR_VAR 0 5
7825: PUSH
7826: LD_INT 5
7828: ST_TO_ADDR
// Chassis = US_MEDIUM_WHEELED ;
7829: LD_ADDR_VAR 0 4
7833: PUSH
7834: LD_INT 2
7836: ST_TO_ADDR
// end else
7837: GO 7883
// if P < 80 then
7839: LD_VAR 0 3
7843: PUSH
7844: LD_INT 80
7846: LESS
7847: IFFALSE 7867
// begin Weapon = US_ROCKET_LAUNCHER ;
7849: LD_ADDR_VAR 0 5
7853: PUSH
7854: LD_INT 7
7856: ST_TO_ADDR
// Chassis = US_MEDIUM_WHEELED ;
7857: LD_ADDR_VAR 0 4
7861: PUSH
7862: LD_INT 2
7864: ST_TO_ADDR
// end else
7865: GO 7883
// begin Weapon = US_DOUBLE_LASER ;
7867: LD_ADDR_VAR 0 5
7871: PUSH
7872: LD_INT 10
7874: ST_TO_ADDR
// Chassis = US_HEAVY_TRACKED ;
7875: LD_ADDR_VAR 0 4
7879: PUSH
7880: LD_INT 4
7882: ST_TO_ADDR
// end ; if PovolitDblAPasy then
7883: LD_VAR 0 1
7887: IFFALSE 7907
// Chassis = Rand ( Chassis , US_HEAVY_TRACKED ) ;
7889: LD_ADDR_VAR 0 4
7893: PUSH
7894: LD_VAR 0 4
7898: PPUSH
7899: LD_INT 4
7901: PPUSH
7902: CALL_OW 12
7906: ST_TO_ADDR
// if Weapon = US_ROCKET_LAUNCHER then
7907: LD_VAR 0 5
7911: PUSH
7912: LD_INT 7
7914: EQUAL
7915: IFFALSE 7927
// Tovarna = AmFactRock else
7917: LD_ADDR_VAR 0 6
7921: PUSH
7922: LD_INT 26
7924: ST_TO_ADDR
7925: GO 7935
// Tovarna = AmFactGun ;
7927: LD_ADDR_VAR 0 6
7931: PUSH
7932: LD_INT 30
7934: ST_TO_ADDR
// AddComConstruct ( Tovarna , Chassis , ENGINE_SIBERITE , CONTROL_COMPUTER , Weapon ) ;
7935: LD_VAR 0 6
7939: PPUSH
7940: LD_VAR 0 4
7944: PPUSH
7945: LD_INT 3
7947: PPUSH
7948: LD_INT 3
7950: PPUSH
7951: LD_VAR 0 5
7955: PPUSH
7956: CALL_OW 185
// end ;
7960: LD_VAR 0 2
7964: RET
// function kontrola_jednotek ; var Base , Cans , Oil , Sib ; begin
7965: LD_INT 0
7967: PPUSH
7968: PPUSH
7969: PPUSH
7970: PPUSH
7971: PPUSH
// Base = GetBase ( AmDepot ) ;
7972: LD_ADDR_VAR 0 2
7976: PUSH
7977: LD_INT 15
7979: PPUSH
7980: CALL_OW 274
7984: ST_TO_ADDR
// if not Kradenik then
7985: LD_LOC 26
7989: NOT
7990: IFFALSE 7996
// vyrob_nakladak ;
7992: CALL 7579 0 0
// if not Konvoj and not KonvojBylRozebran then
7996: LD_LOC 21
8000: NOT
8001: PUSH
8002: LD_LOC 44
8006: NOT
8007: AND
8008: IFFALSE 8014
// vyrob_nakladak ;
8010: CALL 7579 0 0
// if ( Tanky < Max_Tanky ) or ( not KonvojBylRozebran and ( Doprovod < Max_Doprovod ) ) then
8014: LD_LOC 23
8018: PUSH
8019: LD_LOC 24
8023: LESS
8024: PUSH
8025: LD_LOC 44
8029: NOT
8030: PUSH
8031: LD_LOC 22
8035: PUSH
8036: LD_LOC 25
8040: LESS
8041: AND
8042: OR
8043: IFFALSE 8136
// begin Cans = GetResourceType ( Base , MAT_CANS ) ;
8045: LD_ADDR_VAR 0 3
8049: PUSH
8050: LD_VAR 0 2
8054: PPUSH
8055: LD_INT 1
8057: PPUSH
8058: CALL_OW 275
8062: ST_TO_ADDR
// Oil = GetResourceType ( Base , MAT_OIL ) ;
8063: LD_ADDR_VAR 0 4
8067: PUSH
8068: LD_VAR 0 2
8072: PPUSH
8073: LD_INT 2
8075: PPUSH
8076: CALL_OW 275
8080: ST_TO_ADDR
// Sib = GetResourceType ( Base , MAT_SIBERIT ) ;
8081: LD_ADDR_VAR 0 5
8085: PUSH
8086: LD_VAR 0 2
8090: PPUSH
8091: LD_INT 3
8093: PPUSH
8094: CALL_OW 275
8098: ST_TO_ADDR
// if ( Cans >= 200 ) and ( Oil >= 30 ) and ( Sib >= 20 ) then
8099: LD_VAR 0 3
8103: PUSH
8104: LD_INT 200
8106: GREATEREQUAL
8107: PUSH
8108: LD_VAR 0 4
8112: PUSH
8113: LD_INT 30
8115: GREATEREQUAL
8116: AND
8117: PUSH
8118: LD_VAR 0 5
8122: PUSH
8123: LD_INT 20
8125: GREATEREQUAL
8126: AND
8127: IFFALSE 8136
// vyrob_tank ( true ) ;
8129: LD_INT 1
8131: PPUSH
8132: CALL 7606 0 1
// end ; end ;
8136: LD_VAR 0 1
8140: RET
// every 0 0$51 + 0 0$3 trigger MamKontrolovatVyrobu do
8141: LD_LOC 27
8145: IFFALSE 8155
8147: GO 8149
8149: DISABLE
// begin kontrola_jednotek ;
8150: CALL 7965 0 0
// enable ;
8154: ENABLE
// end ;
8155: END
// every 1 1$7 do var Inz ;
8156: GO 8158
8158: DISABLE
8159: LD_INT 0
8161: PPUSH
// begin Inz = FilterAllUnits ( [ [ F_SIDE , side_Am ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] , [ F_OK ] ] ) diff [ AmEng_Oil , AmEng_Sib ] ;
8162: LD_ADDR_VAR 0 1
8166: PUSH
8167: LD_INT 22
8169: PUSH
8170: LD_EXP 2
8174: PUSH
8175: EMPTY
8176: LIST
8177: LIST
8178: PUSH
8179: LD_INT 21
8181: PUSH
8182: LD_INT 1
8184: PUSH
8185: EMPTY
8186: LIST
8187: LIST
8188: PUSH
8189: LD_INT 25
8191: PUSH
8192: LD_INT 2
8194: PUSH
8195: EMPTY
8196: LIST
8197: LIST
8198: PUSH
8199: LD_INT 50
8201: PUSH
8202: EMPTY
8203: LIST
8204: PUSH
8205: EMPTY
8206: LIST
8207: LIST
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 69
8215: PUSH
8216: LD_LOC 15
8220: PUSH
8221: LD_LOC 16
8225: PUSH
8226: EMPTY
8227: LIST
8228: LIST
8229: DIFF
8230: ST_TO_ADDR
// sbirej_bedny ( Inz , Americani ) ;
8231: LD_VAR 0 1
8235: PPUSH
8236: LD_INT 2
8238: PPUSH
8239: CALL 16291 0 2
// opravuj_budovy ( Inz , Americani , side_Am ) ;
8243: LD_VAR 0 1
8247: PPUSH
8248: LD_INT 2
8250: PPUSH
8251: LD_EXP 2
8255: PPUSH
8256: CALL 16149 0 3
// enable ;
8260: ENABLE
// end ;
8261: PPOPN 1
8263: END
// function kontrola_prevoz ; var Base , Base_Oil , Base_Sib ; var Ropa , Sibe , KolikRopy , KolikSibe ; begin
8264: LD_INT 0
8266: PPUSH
8267: PPUSH
8268: PPUSH
8269: PPUSH
8270: PPUSH
8271: PPUSH
8272: PPUSH
8273: PPUSH
// if ProbihaPrevoz then
8274: LD_LOC 29
8278: IFFALSE 8282
// exit ;
8280: GO 8638
// if not IsOK ( AmDepot ) or ( GetSide ( AmDepot ) <> side_Am ) then
8282: LD_INT 15
8284: PPUSH
8285: CALL_OW 302
8289: NOT
8290: PUSH
8291: LD_INT 15
8293: PPUSH
8294: CALL_OW 255
8298: PUSH
8299: LD_EXP 2
8303: NONEQUAL
8304: OR
8305: IFFALSE 8309
// exit ;
8307: GO 8638
// if not Konvoj then
8309: LD_LOC 21
8313: NOT
8314: IFFALSE 8318
// exit ;
8316: GO 8638
// if Doprovod < Max_Doprovod then
8318: LD_LOC 22
8322: PUSH
8323: LD_LOC 25
8327: LESS
8328: IFFALSE 8332
// exit ;
8330: GO 8638
// Base = GetBase ( AmDepot ) ;
8332: LD_ADDR_VAR 0 2
8336: PUSH
8337: LD_INT 15
8339: PPUSH
8340: CALL_OW 274
8344: ST_TO_ADDR
// Base_Oil = GetBase ( AmDepot_Oil ) ;
8345: LD_ADDR_VAR 0 3
8349: PUSH
8350: LD_INT 1
8352: PPUSH
8353: CALL_OW 274
8357: ST_TO_ADDR
// Base_Sib = GetBase ( AmDepot_Sib ) ;
8358: LD_ADDR_VAR 0 4
8362: PUSH
8363: LD_INT 3
8365: PPUSH
8366: CALL_OW 274
8370: ST_TO_ADDR
// KolikRopy = GetResourceType ( Base , MAT_OIL ) ;
8371: LD_ADDR_VAR 0 7
8375: PUSH
8376: LD_VAR 0 2
8380: PPUSH
8381: LD_INT 2
8383: PPUSH
8384: CALL_OW 275
8388: ST_TO_ADDR
// KolikSibe = GetResourceType ( Base , MAT_SIBERIT ) ;
8389: LD_ADDR_VAR 0 8
8393: PUSH
8394: LD_VAR 0 2
8398: PPUSH
8399: LD_INT 3
8401: PPUSH
8402: CALL_OW 275
8406: ST_TO_ADDR
// Ropa = IsOk ( AmDepot_Oil ) and ( GetSide ( AmDepot_Oil ) = side_Am ) and GetResourceType ( Base_Oil , MAT_OIL ) > 100 ;
8407: LD_ADDR_VAR 0 5
8411: PUSH
8412: LD_INT 1
8414: PPUSH
8415: CALL_OW 302
8419: PUSH
8420: LD_INT 1
8422: PPUSH
8423: CALL_OW 255
8427: PUSH
8428: LD_EXP 2
8432: EQUAL
8433: AND
8434: PUSH
8435: LD_VAR 0 3
8439: PPUSH
8440: LD_INT 2
8442: PPUSH
8443: CALL_OW 275
8447: PUSH
8448: LD_INT 100
8450: GREATER
8451: AND
8452: ST_TO_ADDR
// Sibe = IsOk ( AmDepot_Sib ) and ( GetSide ( AmDepot_Sib ) = side_Am ) and GetResourceType ( Base_Sib , MAT_SIBERIT ) > 20 ;
8453: LD_ADDR_VAR 0 6
8457: PUSH
8458: LD_INT 3
8460: PPUSH
8461: CALL_OW 302
8465: PUSH
8466: LD_INT 3
8468: PPUSH
8469: CALL_OW 255
8473: PUSH
8474: LD_EXP 2
8478: EQUAL
8479: AND
8480: PUSH
8481: LD_VAR 0 4
8485: PPUSH
8486: LD_INT 3
8488: PPUSH
8489: CALL_OW 275
8493: PUSH
8494: LD_INT 20
8496: GREATER
8497: AND
8498: ST_TO_ADDR
// if Ropa or Sibe then
8499: LD_VAR 0 5
8503: PUSH
8504: LD_VAR 0 6
8508: OR
8509: IFFALSE 8638
// begin if Ropa and Sibe then
8511: LD_VAR 0 5
8515: PUSH
8516: LD_VAR 0 6
8520: AND
8521: IFFALSE 8622
// if KolikSibe < 30 then
8523: LD_VAR 0 8
8527: PUSH
8528: LD_INT 30
8530: LESS
8531: IFFALSE 8543
// Ropa = false else
8533: LD_ADDR_VAR 0 5
8537: PUSH
8538: LD_INT 0
8540: ST_TO_ADDR
8541: GO 8622
// if KolikRopy > 10 * KolikSibe then
8543: LD_VAR 0 7
8547: PUSH
8548: LD_INT 10
8550: PUSH
8551: LD_VAR 0 8
8555: MUL
8556: GREATER
8557: IFFALSE 8569
// Ropa = false else
8559: LD_ADDR_VAR 0 5
8563: PUSH
8564: LD_INT 0
8566: ST_TO_ADDR
8567: GO 8622
// if KolikRopy < 5 * KolikSibe then
8569: LD_VAR 0 7
8573: PUSH
8574: LD_INT 5
8576: PUSH
8577: LD_VAR 0 8
8581: MUL
8582: LESS
8583: IFFALSE 8595
// Sibe = false else
8585: LD_ADDR_VAR 0 6
8589: PUSH
8590: LD_INT 0
8592: ST_TO_ADDR
8593: GO 8622
// if Prob ( 50 ) then
8595: LD_INT 50
8597: PPUSH
8598: CALL_OW 13
8602: IFFALSE 8614
// Ropa = false else
8604: LD_ADDR_VAR 0 5
8608: PUSH
8609: LD_INT 0
8611: ST_TO_ADDR
8612: GO 8622
// Sibe = false ;
8614: LD_ADDR_VAR 0 6
8618: PUSH
8619: LD_INT 0
8621: ST_TO_ADDR
// if Sibe then
8622: LD_VAR 0 6
8626: IFFALSE 8634
// prevoz_sibe else
8628: CALL 9029 0 0
8632: GO 8638
// prevoz_ropa ;
8634: CALL 8841 0 0
// end ; end ;
8638: LD_VAR 0 1
8642: RET
// function prevoz_init ( Co ) ; begin
8643: LD_INT 0
8645: PPUSH
// ProbihaPrevoz = Co ;
8646: LD_ADDR_LOC 29
8650: PUSH
8651: LD_VAR 0 1
8655: ST_TO_ADDR
// PrevozNalozil = false ;
8656: LD_ADDR_LOC 30
8660: PUSH
8661: LD_INT 0
8663: ST_TO_ADDR
// PrevozVylozil = false ;
8664: LD_ADDR_LOC 31
8668: PUSH
8669: LD_INT 0
8671: ST_TO_ADDR
// end ;
8672: LD_VAR 0 2
8676: RET
// export function amici_McDone ( McId , State ) ; begin
8677: LD_INT 0
8679: PPUSH
// if MakroPrevoz and ( McId = MakroPrevoz ) then
8680: LD_LOC 52
8684: PUSH
8685: LD_VAR 0 1
8689: PUSH
8690: LD_LOC 52
8694: EQUAL
8695: AND
8696: IFFALSE 8749
// begin case ProbihaPrevoz of 1 :
8698: LD_LOC 29
8702: PUSH
8703: LD_INT 1
8705: DOUBLE
8706: EQUAL
8707: IFTRUE 8711
8709: GO 8718
8711: POP
// prevoz_ropa_2 ; 2 :
8712: CALL 8904 0 0
8716: GO 8749
8718: LD_INT 2
8720: DOUBLE
8721: EQUAL
8722: IFTRUE 8726
8724: GO 8733
8726: POP
// prevoz_sibe_2 ; 3 :
8727: CALL 9092 0 0
8731: GO 8749
8733: LD_INT 3
8735: DOUBLE
8736: EQUAL
8737: IFTRUE 8741
8739: GO 8748
8741: POP
// prevoz_konec ; end ;
8742: CALL 9217 0 0
8746: GO 8749
8748: POP
// end ; if MakroUtokMove and ( McId = MakroUtokMove ) then
8749: LD_LOC 50
8753: PUSH
8754: LD_VAR 0 1
8758: PUSH
8759: LD_LOC 50
8763: EQUAL
8764: AND
8765: IFFALSE 8836
// begin MakroUtok = McAttack ( 10 , RegUtok , Utok_Auta , [ [ MC_RETREAT_AREA_PEOPLE , Parkoviste ] , [ MC_RETREAT_AREA_VEHICLES , Parkoviste ] , [ MC_RETREAT_LIVES_PEOPLE , 10 ] , [ MC_RETREAT_LIVES_VEHICLES , 10 ] ] ) ;
8767: LD_ADDR_LOC 49
8771: PUSH
8772: LD_INT 10
8774: PPUSH
8775: LD_LOC 46
8779: PPUSH
8780: LD_LOC 39
8784: PPUSH
8785: LD_INT 7
8787: PUSH
8788: LD_INT 3
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PUSH
8795: LD_INT 8
8797: PUSH
8798: LD_INT 3
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PUSH
8805: LD_INT 5
8807: PUSH
8808: LD_INT 10
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: PUSH
8815: LD_INT 6
8817: PUSH
8818: LD_INT 10
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PUSH
8825: EMPTY
8826: LIST
8827: LIST
8828: LIST
8829: LIST
8830: PPUSH
8831: CALL_OW 402
8835: ST_TO_ADDR
// end ; end ;
8836: LD_VAR 0 3
8840: RET
// function prevoz_ropa ; var Way ; begin
8841: LD_INT 0
8843: PPUSH
8844: PPUSH
// prevoz_init ( 1 ) ;
8845: LD_INT 1
8847: PPUSH
8848: CALL 8643 0 1
// Way = cesta_B_X ^ cesta_X_O ;
8852: LD_ADDR_VAR 0 2
8856: PUSH
8857: CALL 9350 0 0
8861: PUSH
8862: CALL 9501 0 0
8866: ADD
8867: ST_TO_ADDR
// MakroPrevoz = McMove ( 50 , Konvoj union Doprovod , Way , [ ] ) ;
8868: LD_ADDR_LOC 52
8872: PUSH
8873: LD_INT 50
8875: PPUSH
8876: LD_LOC 21
8880: PUSH
8881: LD_LOC 22
8885: UNION
8886: PPUSH
8887: LD_VAR 0 2
8891: PPUSH
8892: EMPTY
8893: PPUSH
8894: CALL_OW 398
8898: ST_TO_ADDR
// end ;
8899: LD_VAR 0 1
8903: RET
// function prevoz_ropa_2 ; var I , Way ; begin
8904: LD_INT 0
8906: PPUSH
8907: PPUSH
8908: PPUSH
// if not ProbihaPrevoz then
8909: LD_LOC 29
8913: NOT
8914: IFFALSE 8918
// exit ;
8916: GO 9024
// if PrevozNalozil then
8918: LD_LOC 30
8922: IFFALSE 8926
// exit ;
8924: GO 9024
// ProbihaPrevoz = 3 ;
8926: LD_ADDR_LOC 29
8930: PUSH
8931: LD_INT 3
8933: ST_TO_ADDR
// PrevozNalozil = true ;
8934: LD_ADDR_LOC 30
8938: PUSH
8939: LD_INT 1
8941: ST_TO_ADDR
// for I in Konvoj do
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_LOC 21
8951: PUSH
8952: FOR_IN
8953: IFFALSE 8975
// naloz ( I , AmDepot_Oil , MAT_OIL , 100 ) ;
8955: LD_VAR 0 2
8959: PPUSH
8960: LD_INT 1
8962: PPUSH
8963: LD_INT 2
8965: PPUSH
8966: LD_INT 100
8968: PPUSH
8969: CALL 15754 0 4
8973: GO 8952
8975: POP
8976: POP
// Way = cesta_O_X ^ cesta_X_B ;
8977: LD_ADDR_VAR 0 3
8981: PUSH
8982: CALL 9571 0 0
8986: PUSH
8987: CALL 9420 0 0
8991: ADD
8992: ST_TO_ADDR
// MakroPrevoz = McMove ( 50 , Konvoj union Doprovod , Way , [ ] ) ;
8993: LD_ADDR_LOC 52
8997: PUSH
8998: LD_INT 50
9000: PPUSH
9001: LD_LOC 21
9005: PUSH
9006: LD_LOC 22
9010: UNION
9011: PPUSH
9012: LD_VAR 0 3
9016: PPUSH
9017: EMPTY
9018: PPUSH
9019: CALL_OW 398
9023: ST_TO_ADDR
// end ;
9024: LD_VAR 0 1
9028: RET
// function prevoz_sibe ; var Way ; begin
9029: LD_INT 0
9031: PPUSH
9032: PPUSH
// prevoz_init ( 2 ) ;
9033: LD_INT 2
9035: PPUSH
9036: CALL 8643 0 1
// Way = cesta_B_X ^ cesta_X_S ;
9040: LD_ADDR_VAR 0 2
9044: PUSH
9045: CALL 9350 0 0
9049: PUSH
9050: CALL 9630 0 0
9054: ADD
9055: ST_TO_ADDR
// MakroPrevoz = McMove ( 50 , Konvoj union Doprovod , Way , [ ] ) ;
9056: LD_ADDR_LOC 52
9060: PUSH
9061: LD_INT 50
9063: PPUSH
9064: LD_LOC 21
9068: PUSH
9069: LD_LOC 22
9073: UNION
9074: PPUSH
9075: LD_VAR 0 2
9079: PPUSH
9080: EMPTY
9081: PPUSH
9082: CALL_OW 398
9086: ST_TO_ADDR
// end ;
9087: LD_VAR 0 1
9091: RET
// function prevoz_sibe_2 ; var I , Way ; begin
9092: LD_INT 0
9094: PPUSH
9095: PPUSH
9096: PPUSH
// if not ProbihaPrevoz then
9097: LD_LOC 29
9101: NOT
9102: IFFALSE 9106
// exit ;
9104: GO 9212
// if PrevozNalozil then
9106: LD_LOC 30
9110: IFFALSE 9114
// exit ;
9112: GO 9212
// ProbihaPrevoz = 3 ;
9114: LD_ADDR_LOC 29
9118: PUSH
9119: LD_INT 3
9121: ST_TO_ADDR
// PrevozNalozil = true ;
9122: LD_ADDR_LOC 30
9126: PUSH
9127: LD_INT 1
9129: ST_TO_ADDR
// for I in Konvoj do
9130: LD_ADDR_VAR 0 2
9134: PUSH
9135: LD_LOC 21
9139: PUSH
9140: FOR_IN
9141: IFFALSE 9163
// naloz ( I , AmDepot_Sib , MAT_SIBERIT , 100 ) ;
9143: LD_VAR 0 2
9147: PPUSH
9148: LD_INT 3
9150: PPUSH
9151: LD_INT 3
9153: PPUSH
9154: LD_INT 100
9156: PPUSH
9157: CALL 15754 0 4
9161: GO 9140
9163: POP
9164: POP
// Way = cesta_S_X ^ cesta_X_B ;
9165: LD_ADDR_VAR 0 3
9169: PUSH
9170: CALL 9689 0 0
9174: PUSH
9175: CALL 9420 0 0
9179: ADD
9180: ST_TO_ADDR
// MakroPrevoz = McMove ( 50 , Konvoj union Doprovod , Way , [ ] ) ;
9181: LD_ADDR_LOC 52
9185: PUSH
9186: LD_INT 50
9188: PPUSH
9189: LD_LOC 21
9193: PUSH
9194: LD_LOC 22
9198: UNION
9199: PPUSH
9200: LD_VAR 0 3
9204: PPUSH
9205: EMPTY
9206: PPUSH
9207: CALL_OW 398
9211: ST_TO_ADDR
// end ;
9212: LD_VAR 0 1
9216: RET
// function prevoz_konec ; var Nakladaky ; begin
9217: LD_INT 0
9219: PPUSH
9220: PPUSH
// if not ProbihaPrevoz then
9221: LD_LOC 29
9225: NOT
9226: IFFALSE 9230
// exit ;
9228: GO 9329
// ProbihaPrevoz = 0 ;
9230: LD_ADDR_LOC 29
9234: PUSH
9235: LD_INT 0
9237: ST_TO_ADDR
// if PrevozVylozil then
9238: LD_LOC 31
9242: IFFALSE 9246
// exit ;
9244: GO 9329
// PrevozVylozil = true ;
9246: LD_ADDR_LOC 31
9250: PUSH
9251: LD_INT 1
9253: ST_TO_ADDR
// Nakladaky = UnitFilter ( Konvoj , [ [ F_WEAPON , US_CARGO_BAY ] ] ) ;
9254: LD_ADDR_VAR 0 2
9258: PUSH
9259: LD_LOC 21
9263: PPUSH
9264: LD_INT 34
9266: PUSH
9267: LD_INT 12
9269: PUSH
9270: EMPTY
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: PPUSH
9277: CALL_OW 72
9281: ST_TO_ADDR
// AddComMoveUnit ( Nakladaky , AmDepot ) ;
9282: LD_VAR 0 2
9286: PPUSH
9287: LD_INT 15
9289: PPUSH
9290: CALL_OW 172
// AddComMoveToArea ( Konvoj union Doprovod , Parkoviste ) ;
9294: LD_LOC 21
9298: PUSH
9299: LD_LOC 22
9303: UNION
9304: PPUSH
9305: LD_INT 3
9307: PPUSH
9308: CALL_OW 173
// AddComHold ( Konvoj ) ;
9312: LD_LOC 21
9316: PPUSH
9317: CALL_OW 200
// ProbihaPrevoz = false ;
9321: LD_ADDR_LOC 29
9325: PUSH
9326: LD_INT 0
9328: ST_TO_ADDR
// end ;
9329: LD_VAR 0 1
9333: RET
// every 1 1$5 do
9334: GO 9336
9336: DISABLE
// begin kontrola_prevoz ;
9337: CALL 8264 0 0
// if not KonvojBylRozebran then
9341: LD_LOC 44
9345: NOT
9346: IFFALSE 9349
// enable ;
9348: ENABLE
// end ;
9349: END
// function cesta_B_X ; begin
9350: LD_INT 0
9352: PPUSH
// Result = [ [ 148 , 44 ] , [ 157 , 57 ] , [ 148 , 73 ] , [ 136 , 75 ] , [ 119 , 78 ] ] ;
9353: LD_ADDR_VAR 0 1
9357: PUSH
9358: LD_INT 148
9360: PUSH
9361: LD_INT 44
9363: PUSH
9364: EMPTY
9365: LIST
9366: LIST
9367: PUSH
9368: LD_INT 157
9370: PUSH
9371: LD_INT 57
9373: PUSH
9374: EMPTY
9375: LIST
9376: LIST
9377: PUSH
9378: LD_INT 148
9380: PUSH
9381: LD_INT 73
9383: PUSH
9384: EMPTY
9385: LIST
9386: LIST
9387: PUSH
9388: LD_INT 136
9390: PUSH
9391: LD_INT 75
9393: PUSH
9394: EMPTY
9395: LIST
9396: LIST
9397: PUSH
9398: LD_INT 119
9400: PUSH
9401: LD_INT 78
9403: PUSH
9404: EMPTY
9405: LIST
9406: LIST
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: LIST
9412: LIST
9413: LIST
9414: ST_TO_ADDR
// end ;
9415: LD_VAR 0 1
9419: RET
// function cesta_X_B ; begin
9420: LD_INT 0
9422: PPUSH
// Result = [ [ 121 , 78 ] , [ 135 , 75 ] , [ 151 , 71 ] , [ 156 , 58 ] , [ 142 , 37 ] , [ 139 , 14 ] ] ;
9423: LD_ADDR_VAR 0 1
9427: PUSH
9428: LD_INT 121
9430: PUSH
9431: LD_INT 78
9433: PUSH
9434: EMPTY
9435: LIST
9436: LIST
9437: PUSH
9438: LD_INT 135
9440: PUSH
9441: LD_INT 75
9443: PUSH
9444: EMPTY
9445: LIST
9446: LIST
9447: PUSH
9448: LD_INT 151
9450: PUSH
9451: LD_INT 71
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: PUSH
9458: LD_INT 156
9460: PUSH
9461: LD_INT 58
9463: PUSH
9464: EMPTY
9465: LIST
9466: LIST
9467: PUSH
9468: LD_INT 142
9470: PUSH
9471: LD_INT 37
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: PUSH
9478: LD_INT 139
9480: PUSH
9481: LD_INT 14
9483: PUSH
9484: EMPTY
9485: LIST
9486: LIST
9487: PUSH
9488: EMPTY
9489: LIST
9490: LIST
9491: LIST
9492: LIST
9493: LIST
9494: LIST
9495: ST_TO_ADDR
// end ;
9496: LD_VAR 0 1
9500: RET
// function cesta_X_O ; begin
9501: LD_INT 0
9503: PPUSH
// Result = [ [ 108 , 78 ] , [ 96 , 77 ] , [ 86 , 72 ] , [ 79 , 74 ] , [ 67 , 72 ] ] ;
9504: LD_ADDR_VAR 0 1
9508: PUSH
9509: LD_INT 108
9511: PUSH
9512: LD_INT 78
9514: PUSH
9515: EMPTY
9516: LIST
9517: LIST
9518: PUSH
9519: LD_INT 96
9521: PUSH
9522: LD_INT 77
9524: PUSH
9525: EMPTY
9526: LIST
9527: LIST
9528: PUSH
9529: LD_INT 86
9531: PUSH
9532: LD_INT 72
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: PUSH
9539: LD_INT 79
9541: PUSH
9542: LD_INT 74
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: PUSH
9549: LD_INT 67
9551: PUSH
9552: LD_INT 72
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PUSH
9559: EMPTY
9560: LIST
9561: LIST
9562: LIST
9563: LIST
9564: LIST
9565: ST_TO_ADDR
// end ;
9566: LD_VAR 0 1
9570: RET
// function cesta_O_X ; begin
9571: LD_INT 0
9573: PPUSH
// Result = [ [ 74 , 72 ] , [ 88 , 73 ] , [ 103 , 79 ] , [ 109 , 78 ] ] ;
9574: LD_ADDR_VAR 0 1
9578: PUSH
9579: LD_INT 74
9581: PUSH
9582: LD_INT 72
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: PUSH
9589: LD_INT 88
9591: PUSH
9592: LD_INT 73
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PUSH
9599: LD_INT 103
9601: PUSH
9602: LD_INT 79
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: PUSH
9609: LD_INT 109
9611: PUSH
9612: LD_INT 78
9614: PUSH
9615: EMPTY
9616: LIST
9617: LIST
9618: PUSH
9619: EMPTY
9620: LIST
9621: LIST
9622: LIST
9623: LIST
9624: ST_TO_ADDR
// end ;
9625: LD_VAR 0 1
9629: RET
// function cesta_X_S ; begin
9630: LD_INT 0
9632: PPUSH
// Result = [ [ 121 , 90 ] , [ 126 , 98 ] , [ 134 , 113 ] , [ 135 , 124 ] ] ;
9633: LD_ADDR_VAR 0 1
9637: PUSH
9638: LD_INT 121
9640: PUSH
9641: LD_INT 90
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: PUSH
9648: LD_INT 126
9650: PUSH
9651: LD_INT 98
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PUSH
9658: LD_INT 134
9660: PUSH
9661: LD_INT 113
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PUSH
9668: LD_INT 135
9670: PUSH
9671: LD_INT 124
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: PUSH
9678: EMPTY
9679: LIST
9680: LIST
9681: LIST
9682: LIST
9683: ST_TO_ADDR
// end ;
9684: LD_VAR 0 1
9688: RET
// function cesta_S_X ; begin
9689: LD_INT 0
9691: PPUSH
// Result = [ [ 135 , 122 ] , [ 132 , 110 ] , [ 128 , 104 ] , [ 122 , 92 ] , [ 118 , 86 ] ] ;
9692: LD_ADDR_VAR 0 1
9696: PUSH
9697: LD_INT 135
9699: PUSH
9700: LD_INT 122
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: PUSH
9707: LD_INT 132
9709: PUSH
9710: LD_INT 110
9712: PUSH
9713: EMPTY
9714: LIST
9715: LIST
9716: PUSH
9717: LD_INT 128
9719: PUSH
9720: LD_INT 104
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: PUSH
9727: LD_INT 122
9729: PUSH
9730: LD_INT 92
9732: PUSH
9733: EMPTY
9734: LIST
9735: LIST
9736: PUSH
9737: LD_INT 118
9739: PUSH
9740: LD_INT 86
9742: PUSH
9743: EMPTY
9744: LIST
9745: LIST
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: LIST
9751: LIST
9752: LIST
9753: ST_TO_ADDR
// end ;
9754: LD_VAR 0 1
9758: RET
// every 0 0$1.1 trigger vidi_strana_stranu ( side_Am , side_Ru ) do
9759: LD_EXP 2
9763: PPUSH
9764: LD_EXP 3
9768: PPUSH
9769: CALL 15968 0 2
9773: IFFALSE 9786
9775: GO 9777
9777: DISABLE
// begin VidelRusa = true ;
9778: LD_ADDR_LOC 32
9782: PUSH
9783: LD_INT 1
9785: ST_TO_ADDR
// end ;
9786: END
// function zkontroluj_artefakt ; begin
9787: LD_INT 0
9789: PPUSH
// if ArtefaktMajAmici then
9790: LD_EXP 28
9794: IFFALSE 9798
// exit ;
9796: GO 9947
// if AutoSArtefaktem then
9798: LD_EXP 30
9802: IFFALSE 9806
// exit ;
9804: GO 9947
// if not KdeJeArtefakt then
9806: LD_EXP 29
9810: NOT
9811: IFFALSE 9815
// exit ;
9813: GO 9947
// if not Kradenik then
9815: LD_LOC 26
9819: NOT
9820: IFFALSE 9824
// exit ;
9822: GO 9947
// ComMoveUnit ( Kradenik , AmDepot ) ;
9824: LD_LOC 26
9828: PPUSH
9829: LD_INT 15
9831: PPUSH
9832: CALL_OW 112
// AddComMoveXY ( Kradenik , KdeJeArtefakt [ 1 ] , KdeJeArtefakt [ 2 ] ) ;
9836: LD_LOC 26
9840: PPUSH
9841: LD_EXP 29
9845: PUSH
9846: LD_INT 1
9848: ARRAY
9849: PPUSH
9850: LD_EXP 29
9854: PUSH
9855: LD_INT 2
9857: ARRAY
9858: PPUSH
9859: CALL_OW 171
// AddComSailEvent ( Kradenik , 111 ) ;
9863: LD_LOC 26
9867: PPUSH
9868: LD_INT 111
9870: PPUSH
9871: CALL_OW 224
// AddComWait ( Kradenik , 0 0$1 ) ;
9875: LD_LOC 26
9879: PPUSH
9880: LD_INT 35
9882: PPUSH
9883: CALL_OW 202
// AddComCollect ( Kradenik , KdeJeArtefakt [ 1 ] , KdeJeArtefakt [ 2 ] ) ;
9887: LD_LOC 26
9891: PPUSH
9892: LD_EXP 29
9896: PUSH
9897: LD_INT 1
9899: ARRAY
9900: PPUSH
9901: LD_EXP 29
9905: PUSH
9906: LD_INT 2
9908: ARRAY
9909: PPUSH
9910: CALL_OW 177
// AddComMoveToArea ( Kradenik , Americani ) ;
9914: LD_LOC 26
9918: PPUSH
9919: LD_INT 2
9921: PPUSH
9922: CALL_OW 173
// AddComMoveUnit ( Kradenik , AmDepot ) ;
9926: LD_LOC 26
9930: PPUSH
9931: LD_INT 15
9933: PPUSH
9934: CALL_OW 172
// AddComHold ( Kradenik ) ;
9938: LD_LOC 26
9942: PPUSH
9943: CALL_OW 200
// end ;
9947: LD_VAR 0 1
9951: RET
// export function event_KradenikPredKradenim ; begin
9952: LD_INT 0
9954: PPUSH
// if not IsOk ( Kradenik ) then
9955: LD_LOC 26
9959: PPUSH
9960: CALL_OW 302
9964: NOT
9965: IFFALSE 9969
// exit ;
9967: GO 9987
// uvolni_auto ( Kradenik , 10 * VelikostArtefaktu ) ;
9969: LD_LOC 26
9973: PPUSH
9974: LD_INT 10
9976: PUSH
9977: LD_EXP 34
9981: MUL
9982: PPUSH
9983: CALL 17451 0 2
// end ;
9987: LD_VAR 0 1
9991: RET
// every 2 2$1 do
9992: GO 9994
9994: DISABLE
// begin if Difficulty = 1 then
9995: LD_OWVAR 67
9999: PUSH
10000: LD_INT 1
10002: EQUAL
10003: IFFALSE 10007
// exit ;
10005: GO 10012
// zkontroluj_artefakt ;
10007: CALL 9787 0 0
// enable ;
10011: ENABLE
// end ;
10012: END
// export function amici_vezmi_doprovod ; var KolikChci , Volne , Vsechny , Dbl , I ; begin
10013: LD_INT 0
10015: PPUSH
10016: PPUSH
10017: PPUSH
10018: PPUSH
10019: PPUSH
10020: PPUSH
// Result = [ ] ;
10021: LD_ADDR_VAR 0 1
10025: PUSH
10026: EMPTY
10027: ST_TO_ADDR
// KolikChci = dif_JMMDoprovodPocet [ Difficulty ] ;
10028: LD_ADDR_VAR 0 2
10032: PUSH
10033: LD_EXP 39
10037: PUSH
10038: LD_OWVAR 67
10042: ARRAY
10043: ST_TO_ADDR
// Vsechny = Tanky diff Utok_Auta ;
10044: LD_ADDR_VAR 0 4
10048: PUSH
10049: LD_LOC 23
10053: PUSH
10054: LD_LOC 39
10058: DIFF
10059: ST_TO_ADDR
// Volne = UnitFilter ( Vsechny , [ [ F_CONTROL , CONTROL_COMPUTER ] ] ) ;
10060: LD_ADDR_VAR 0 3
10064: PUSH
10065: LD_VAR 0 4
10069: PPUSH
10070: LD_INT 33
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: EMPTY
10077: LIST
10078: LIST
10079: PUSH
10080: EMPTY
10081: LIST
10082: PPUSH
10083: CALL_OW 72
10087: ST_TO_ADDR
// Dbl = UnitFilter ( Volne , [ [ F_WEAPON , US_DOUBLE_LASER ] ] ) ;
10088: LD_ADDR_VAR 0 5
10092: PUSH
10093: LD_VAR 0 3
10097: PPUSH
10098: LD_INT 34
10100: PUSH
10101: LD_INT 10
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: PUSH
10108: EMPTY
10109: LIST
10110: PPUSH
10111: CALL_OW 72
10115: ST_TO_ADDR
// Volne = Volne diff Dbl ;
10116: LD_ADDR_VAR 0 3
10120: PUSH
10121: LD_VAR 0 3
10125: PUSH
10126: LD_VAR 0 5
10130: DIFF
10131: ST_TO_ADDR
// if Volne < KolikChci then
10132: LD_VAR 0 3
10136: PUSH
10137: LD_VAR 0 2
10141: LESS
10142: IFFALSE 10146
// exit ;
10144: GO 10209
// for I = 1 to KolikChci do
10146: LD_ADDR_VAR 0 6
10150: PUSH
10151: DOUBLE
10152: LD_INT 1
10154: DEC
10155: ST_TO_ADDR
10156: LD_VAR 0 2
10160: PUSH
10161: FOR_TO
10162: IFFALSE 10191
// Result = Result union [ Volne [ I ] ] ;
10164: LD_ADDR_VAR 0 1
10168: PUSH
10169: LD_VAR 0 1
10173: PUSH
10174: LD_VAR 0 3
10178: PUSH
10179: LD_VAR 0 6
10183: ARRAY
10184: PUSH
10185: EMPTY
10186: LIST
10187: UNION
10188: ST_TO_ADDR
10189: GO 10161
10191: POP
10192: POP
// Tanky = Tanky diff Result ;
10193: LD_ADDR_LOC 23
10197: PUSH
10198: LD_LOC 23
10202: PUSH
10203: LD_VAR 0 1
10207: DIFF
10208: ST_TO_ADDR
// end ;
10209: LD_VAR 0 1
10213: RET
// function zjisti_auta_na_utok ; var KolikChci , I , Riditelne , Dbl ; begin
10214: LD_INT 0
10216: PPUSH
10217: PPUSH
10218: PPUSH
10219: PPUSH
10220: PPUSH
// KolikChci = dif_UtokSkupina [ Difficulty ] ;
10221: LD_ADDR_VAR 0 2
10225: PUSH
10226: LD_EXP 40
10230: PUSH
10231: LD_OWVAR 67
10235: ARRAY
10236: ST_TO_ADDR
// I = Rand ( 1 , 100 ) ;
10237: LD_ADDR_VAR 0 3
10241: PUSH
10242: LD_INT 1
10244: PPUSH
10245: LD_INT 100
10247: PPUSH
10248: CALL_OW 12
10252: ST_TO_ADDR
// if ( I < 25 ) then
10253: LD_VAR 0 3
10257: PUSH
10258: LD_INT 25
10260: LESS
10261: IFFALSE 10279
// KolikChci = KolikChci - 1 else
10263: LD_ADDR_VAR 0 2
10267: PUSH
10268: LD_VAR 0 2
10272: PUSH
10273: LD_INT 1
10275: MINUS
10276: ST_TO_ADDR
10277: GO 10313
// if ( I > 75 ) and ( CisloUtoku > 1 ) then
10279: LD_VAR 0 3
10283: PUSH
10284: LD_INT 75
10286: GREATER
10287: PUSH
10288: LD_LOC 34
10292: PUSH
10293: LD_INT 1
10295: GREATER
10296: AND
10297: IFFALSE 10313
// KolikChci = KolikChci + 1 ;
10299: LD_ADDR_VAR 0 2
10303: PUSH
10304: LD_VAR 0 2
10308: PUSH
10309: LD_INT 1
10311: PLUS
10312: ST_TO_ADDR
// Riditelne = [ ] ;
10313: LD_ADDR_VAR 0 4
10317: PUSH
10318: EMPTY
10319: ST_TO_ADDR
// for I in Tanky do
10320: LD_ADDR_VAR 0 3
10324: PUSH
10325: LD_LOC 23
10329: PUSH
10330: FOR_IN
10331: IFFALSE 10417
// begin if ( GetControl ( I ) = CONTROL_MANUAL ) and not IsDrivenBy ( I ) then
10333: LD_VAR 0 3
10337: PPUSH
10338: CALL_OW 263
10342: PUSH
10343: LD_INT 1
10345: EQUAL
10346: PUSH
10347: LD_VAR 0 3
10351: PPUSH
10352: CALL_OW 311
10356: NOT
10357: AND
10358: IFFALSE 10362
// continue ;
10360: GO 10330
// if ( GetWeapon ( I ) = US_CARGO_BAY ) then
10362: LD_VAR 0 3
10366: PPUSH
10367: CALL_OW 264
10371: PUSH
10372: LD_INT 12
10374: EQUAL
10375: IFFALSE 10379
// continue ;
10377: GO 10330
// if ( GetLives ( I ) < HRANICE_ZDRAVI ) then
10379: LD_VAR 0 3
10383: PPUSH
10384: CALL_OW 256
10388: PUSH
10389: LD_INT 1000
10391: LESS
10392: IFFALSE 10396
// continue ;
10394: GO 10330
// Riditelne = Riditelne union [ I ] ;
10396: LD_ADDR_VAR 0 4
10400: PUSH
10401: LD_VAR 0 4
10405: PUSH
10406: LD_VAR 0 3
10410: PUSH
10411: EMPTY
10412: LIST
10413: UNION
10414: ST_TO_ADDR
// end ;
10415: GO 10330
10417: POP
10418: POP
// Dbl = UnitFilter ( Riditelne , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_WEAPON , US_DOUBLE_LASER ] ] ) ;
10419: LD_ADDR_VAR 0 5
10423: PUSH
10424: LD_VAR 0 4
10428: PPUSH
10429: LD_INT 21
10431: PUSH
10432: LD_INT 2
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PUSH
10439: LD_INT 34
10441: PUSH
10442: LD_INT 10
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: EMPTY
10450: LIST
10451: LIST
10452: PPUSH
10453: CALL_OW 72
10457: ST_TO_ADDR
// Riditelne = Riditelne diff Dbl ;
10458: LD_ADDR_VAR 0 4
10462: PUSH
10463: LD_VAR 0 4
10467: PUSH
10468: LD_VAR 0 5
10472: DIFF
10473: ST_TO_ADDR
// if ( Dbl >= 2 ) then
10474: LD_VAR 0 5
10478: PUSH
10479: LD_INT 2
10481: GREATEREQUAL
10482: IFFALSE 10517
// begin Riditelne = [ Dbl [ 1 ] , Dbl [ 2 ] ] ^ Riditelne ;
10484: LD_ADDR_VAR 0 4
10488: PUSH
10489: LD_VAR 0 5
10493: PUSH
10494: LD_INT 1
10496: ARRAY
10497: PUSH
10498: LD_VAR 0 5
10502: PUSH
10503: LD_INT 2
10505: ARRAY
10506: PUSH
10507: EMPTY
10508: LIST
10509: LIST
10510: PUSH
10511: LD_VAR 0 4
10515: ADD
10516: ST_TO_ADDR
// end ; if ( CisloUtoku = 1 ) and ( KolikChci > Riditelne ) then
10517: LD_LOC 34
10521: PUSH
10522: LD_INT 1
10524: EQUAL
10525: PUSH
10526: LD_VAR 0 2
10530: PUSH
10531: LD_VAR 0 4
10535: GREATER
10536: AND
10537: IFFALSE 10551
// Result = Riditelne else
10539: LD_ADDR_VAR 0 1
10543: PUSH
10544: LD_VAR 0 4
10548: ST_TO_ADDR
10549: GO 10623
// if Riditelne >= KolikChci then
10551: LD_VAR 0 4
10555: PUSH
10556: LD_VAR 0 2
10560: GREATEREQUAL
10561: IFFALSE 10616
// begin Result = [ ] ;
10563: LD_ADDR_VAR 0 1
10567: PUSH
10568: EMPTY
10569: ST_TO_ADDR
// for I = 1 to KolikChci do
10570: LD_ADDR_VAR 0 3
10574: PUSH
10575: DOUBLE
10576: LD_INT 1
10578: DEC
10579: ST_TO_ADDR
10580: LD_VAR 0 2
10584: PUSH
10585: FOR_TO
10586: IFFALSE 10612
// Result = Result union Riditelne [ I ] ;
10588: LD_ADDR_VAR 0 1
10592: PUSH
10593: LD_VAR 0 1
10597: PUSH
10598: LD_VAR 0 4
10602: PUSH
10603: LD_VAR 0 3
10607: ARRAY
10608: UNION
10609: ST_TO_ADDR
10610: GO 10585
10612: POP
10613: POP
// end else
10614: GO 10623
// Result = [ ] ;
10616: LD_ADDR_VAR 0 1
10620: PUSH
10621: EMPTY
10622: ST_TO_ADDR
// if Prob ( 50 ) and ( Obranci > 4 ) then
10623: LD_INT 50
10625: PPUSH
10626: CALL_OW 13
10630: PUSH
10631: LD_LOC 17
10635: PUSH
10636: LD_INT 4
10638: GREATER
10639: AND
10640: IFFALSE 10695
// for I = 1 to Rand ( 1 , 2 ) do
10642: LD_ADDR_VAR 0 3
10646: PUSH
10647: DOUBLE
10648: LD_INT 1
10650: DEC
10651: ST_TO_ADDR
10652: LD_INT 1
10654: PPUSH
10655: LD_INT 2
10657: PPUSH
10658: CALL_OW 12
10662: PUSH
10663: FOR_TO
10664: IFFALSE 10693
// Result = Result union [ Obranci [ I ] ] ;
10666: LD_ADDR_VAR 0 1
10670: PUSH
10671: LD_VAR 0 1
10675: PUSH
10676: LD_LOC 17
10680: PUSH
10681: LD_VAR 0 3
10685: ARRAY
10686: PUSH
10687: EMPTY
10688: LIST
10689: UNION
10690: ST_TO_ADDR
10691: GO 10663
10693: POP
10694: POP
// end ;
10695: LD_VAR 0 1
10699: RET
// function zacni_utok ; var Area , I , Prio ; begin
10700: LD_INT 0
10702: PPUSH
10703: PPUSH
10704: PPUSH
10705: PPUSH
// ProbihaUtok = true ;
10706: LD_ADDR_LOC 33
10710: PUSH
10711: LD_INT 1
10713: ST_TO_ADDR
// MakroUtokMove = McMove ( 11 , Utok_Auta , [ [ 135 , 15 ] , [ 142 , 40 ] , [ 156 , 56 ] ] , [ MC_MOVE_DONTCAPTURE ] ) ;
10714: LD_ADDR_LOC 50
10718: PUSH
10719: LD_INT 11
10721: PPUSH
10722: LD_LOC 39
10726: PPUSH
10727: LD_INT 135
10729: PUSH
10730: LD_INT 15
10732: PUSH
10733: EMPTY
10734: LIST
10735: LIST
10736: PUSH
10737: LD_INT 142
10739: PUSH
10740: LD_INT 40
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: PUSH
10747: LD_INT 156
10749: PUSH
10750: LD_INT 56
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: LIST
10761: PPUSH
10762: LD_INT 5
10764: PUSH
10765: EMPTY
10766: LIST
10767: PPUSH
10768: CALL_OW 398
10772: ST_TO_ADDR
// end ;
10773: LD_VAR 0 1
10777: RET
// function rozeber_konvoj ; var I , F ; begin
10778: LD_INT 0
10780: PPUSH
10781: PPUSH
10782: PPUSH
// if KonvojBylRozebran then
10783: LD_LOC 44
10787: IFFALSE 10791
// exit ;
10789: GO 10845
// KonvojBylRozebran = true ;
10791: LD_ADDR_LOC 44
10795: PUSH
10796: LD_INT 1
10798: ST_TO_ADDR
// Tanky = Tanky union Doprovod ;
10799: LD_ADDR_LOC 23
10803: PUSH
10804: LD_LOC 23
10808: PUSH
10809: LD_LOC 22
10813: UNION
10814: ST_TO_ADDR
// Doprovod = [ ] ;
10815: LD_ADDR_LOC 22
10819: PUSH
10820: EMPTY
10821: ST_TO_ADDR
// RozebratAuta = RozebratAuta union Konvoj ;
10822: LD_ADDR_LOC 45
10826: PUSH
10827: LD_LOC 45
10831: PUSH
10832: LD_LOC 21
10836: UNION
10837: ST_TO_ADDR
// Konvoj = [ ] ;
10838: LD_ADDR_LOC 21
10842: PUSH
10843: EMPTY
10844: ST_TO_ADDR
// end ;
10845: LD_VAR 0 1
10849: RET
// every 0 0$5.3 trigger ProbihaPrevoz = 0 marked 22 do
10850: LD_LOC 29
10854: PUSH
10855: LD_INT 0
10857: EQUAL
10858: IFFALSE 10867
10860: GO 10862
10862: DISABLE
// begin rozeber_konvoj ;
10863: CALL 10778 0 0
// end ;
10867: END
// function vrat_utok ; var I ; begin
10868: LD_INT 0
10870: PPUSH
10871: PPUSH
// ProbihaUtok = false ;
10872: LD_ADDR_LOC 33
10876: PUSH
10877: LD_INT 0
10879: ST_TO_ADDR
// CisloUtoku = CisloUtoku + 1 ;
10880: LD_ADDR_LOC 34
10884: PUSH
10885: LD_LOC 34
10889: PUSH
10890: LD_INT 1
10892: PLUS
10893: ST_TO_ADDR
// MakroUtok = 0 ;
10894: LD_ADDR_LOC 49
10898: PUSH
10899: LD_INT 0
10901: ST_TO_ADDR
// MakroUtokMove = 0 ;
10902: LD_ADDR_LOC 50
10906: PUSH
10907: LD_INT 0
10909: ST_TO_ADDR
// AddComMoveToArea ( Utok_Auta , Parkoviste ) ;
10910: LD_LOC 39
10914: PPUSH
10915: LD_INT 3
10917: PPUSH
10918: CALL_OW 173
// end ;
10922: LD_VAR 0 1
10926: RET
// export function amici_McAttackDone ( McId , Un ) ; begin
10927: LD_INT 0
10929: PPUSH
// vrat_utok ;
10930: CALL 10868 0 0
// end ;
10934: LD_VAR 0 3
10938: RET
// function zjisti_cas_utoku ; begin
10939: LD_INT 0
10941: PPUSH
// if CasyUtoku then
10942: LD_LOC 38
10946: IFFALSE 10992
// begin Result = CasyUtoku [ 1 ] ;
10948: LD_ADDR_VAR 0 1
10952: PUSH
10953: LD_LOC 38
10957: PUSH
10958: LD_INT 1
10960: ARRAY
10961: ST_TO_ADDR
// if CasyUtoku > 1 then
10962: LD_LOC 38
10966: PUSH
10967: LD_INT 1
10969: GREATER
10970: IFFALSE 10990
// CasyUtoku = Delete ( CasyUtoku , 1 ) ;
10972: LD_ADDR_LOC 38
10976: PUSH
10977: LD_LOC 38
10981: PPUSH
10982: LD_INT 1
10984: PPUSH
10985: CALL_OW 3
10989: ST_TO_ADDR
// end else
10990: GO 11000
// Result = 5 ;
10992: LD_ADDR_VAR 0 1
10996: PUSH
10997: LD_INT 5
10999: ST_TO_ADDR
// end ;
11000: LD_VAR 0 1
11004: RET
// function utoceni_splneny_predpoklady ; begin
11005: LD_INT 0
11007: PPUSH
// Result = VidelRusa or ( Tick > 12 12$0 ) ;
11008: LD_ADDR_VAR 0 1
11012: PUSH
11013: LD_LOC 32
11017: PUSH
11018: LD_OWVAR 1
11022: PUSH
11023: LD_INT 25200
11025: GREATER
11026: OR
11027: ST_TO_ADDR
// if not ZnicenSib and not ZnicenOil and ( Tick < 15 15$0 ) then
11028: LD_LOC 43
11032: NOT
11033: PUSH
11034: LD_LOC 42
11038: NOT
11039: AND
11040: PUSH
11041: LD_OWVAR 1
11045: PUSH
11046: LD_INT 31500
11048: LESS
11049: AND
11050: IFFALSE 11060
// Result = false ;
11052: LD_ADDR_VAR 0 1
11056: PUSH
11057: LD_INT 0
11059: ST_TO_ADDR
// if Prob ( 25 ) then
11060: LD_INT 25
11062: PPUSH
11063: CALL_OW 13
11067: IFFALSE 11077
// Result = false ;
11069: LD_ADDR_VAR 0 1
11073: PUSH
11074: LD_INT 0
11076: ST_TO_ADDR
// end ;
11077: LD_VAR 0 1
11081: RET
// function casovac_utok ; begin
11082: LD_INT 0
11084: PPUSH
// if ProbihaUtok then
11085: LD_LOC 33
11089: IFFALSE 11093
// exit ;
11091: GO 11218
// if Utok_ZbyvaMinut = - 1 then
11093: LD_LOC 37
11097: PUSH
11098: LD_INT 1
11100: NEG
11101: EQUAL
11102: IFFALSE 11114
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
11104: LD_ADDR_LOC 37
11108: PUSH
11109: CALL 10939 0 0
11113: ST_TO_ADDR
// if Utok_ZbyvaMinut > 0 then
11114: LD_LOC 37
11118: PUSH
11119: LD_INT 0
11121: GREATER
11122: IFFALSE 11138
// Utok_ZbyvaMinut = Utok_ZbyvaMinut - 1 ;
11124: LD_ADDR_LOC 37
11128: PUSH
11129: LD_LOC 37
11133: PUSH
11134: LD_INT 1
11136: MINUS
11137: ST_TO_ADDR
// if not utoceni_splneny_predpoklady then
11138: CALL 11005 0 0
11142: NOT
11143: IFFALSE 11147
// exit ;
11145: GO 11218
// if Utok_ZbyvaMinut > 0 then
11147: LD_LOC 37
11151: PUSH
11152: LD_INT 0
11154: GREATER
11155: IFFALSE 11159
// exit ;
11157: GO 11218
// if not ZacalyUtoky then
11159: LD_LOC 36
11163: NOT
11164: IFFALSE 11177
// begin enable ( 22 ) ;
11166: LD_INT 22
11168: ENABLE_MARKED
// ZacalyUtoky = true ;
11169: LD_ADDR_LOC 36
11173: PUSH
11174: LD_INT 1
11176: ST_TO_ADDR
// end ; if ProbihaPrevoz then
11177: LD_LOC 29
11181: IFFALSE 11185
// exit ;
11183: GO 11218
// Utok_Auta = zjisti_auta_na_utok ;
11185: LD_ADDR_LOC 39
11189: PUSH
11190: CALL 10214 0 0
11194: ST_TO_ADDR
// if not Utok_Auta then
11195: LD_LOC 39
11199: NOT
11200: IFFALSE 11204
// exit ;
11202: GO 11218
// zacni_utok ;
11204: CALL 10700 0 0
// Utok_ZbyvaMinut = zjisti_cas_utoku ;
11208: LD_ADDR_LOC 37
11212: PUSH
11213: CALL 10939 0 0
11217: ST_TO_ADDR
// end ;
11218: LD_VAR 0 1
11222: RET
// every 0 0$45 marked 21 do
11223: GO 11225
11225: DISABLE
// begin Wait ( Rand ( 0 0$0 , 0 0$30 ) ) ;
11226: LD_INT 0
11228: PPUSH
11229: LD_INT 1050
11231: PPUSH
11232: CALL_OW 12
11236: PPUSH
11237: CALL_OW 67
// casovac_utok ;
11241: CALL 11082 0 0
// enable ;
11245: ENABLE
// end ;
11246: END
// every 0 0$30 do
11247: GO 11249
11249: DISABLE
// begin Wait ( 1 1$0 * Rand ( PrvniUtok [ 1 ] , PrvniUtok [ 2 ] ) ) ;
11250: LD_INT 2100
11252: PUSH
11253: LD_LOC 35
11257: PUSH
11258: LD_INT 1
11260: ARRAY
11261: PPUSH
11262: LD_LOC 35
11266: PUSH
11267: LD_INT 2
11269: ARRAY
11270: PPUSH
11271: CALL_OW 12
11275: MUL
11276: PPUSH
11277: CALL_OW 67
// enable ( 21 ) ;
11281: LD_INT 21
11283: ENABLE_MARKED
// end ;
11284: END
// function opravuj ; begin
11285: LD_INT 0
11287: PPUSH
// if KdoOpravuje then
11288: LD_LOC 41
11292: IFFALSE 11296
// exit ;
11294: GO 11348
// KdoOpravuje = opravuj_auta ( [ AmMech1 , AmMech2 , AmMech3 , AmMech4 ] , 114 , Americani , side_Am , Utok_Auta ) ;
11296: LD_ADDR_LOC 41
11300: PUSH
11301: LD_LOC 9
11305: PUSH
11306: LD_LOC 10
11310: PUSH
11311: LD_LOC 11
11315: PUSH
11316: LD_LOC 12
11320: PUSH
11321: EMPTY
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: PPUSH
11327: LD_INT 114
11329: PPUSH
11330: LD_INT 2
11332: PPUSH
11333: LD_EXP 2
11337: PPUSH
11338: LD_LOC 39
11342: PPUSH
11343: CALL 16521 0 5
11347: ST_TO_ADDR
// end ;
11348: LD_VAR 0 1
11352: RET
// function kuryruj ; begin
11353: LD_INT 0
11355: PPUSH
// if KdoLeci then
11356: LD_LOC 40
11360: IFFALSE 11364
// exit ;
11362: GO 11411
// KdoLeci = kuryruj_lidi ( [ AmSci1 , AmSci2 , AmSci3 , AmSci4 ] , 113 , Americani , side_Am ) ;
11364: LD_ADDR_LOC 40
11368: PUSH
11369: LD_LOC 5
11373: PUSH
11374: LD_LOC 6
11378: PUSH
11379: LD_LOC 7
11383: PUSH
11384: LD_LOC 8
11388: PUSH
11389: EMPTY
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: PPUSH
11395: LD_INT 113
11397: PPUSH
11398: LD_INT 2
11400: PPUSH
11401: LD_EXP 2
11405: PPUSH
11406: CALL 16823 0 4
11410: ST_TO_ADDR
// end ;
11411: LD_VAR 0 1
11415: RET
// export function event_AmiciOprava ( Event ) ; var Kdo ; begin
11416: LD_INT 0
11418: PPUSH
11419: PPUSH
// case Event of 113 :
11420: LD_VAR 0 1
11424: PUSH
11425: LD_INT 113
11427: DOUBLE
11428: EQUAL
11429: IFTRUE 11433
11431: GO 11469
11433: POP
// begin for Kdo in KdoLeci do
11434: LD_ADDR_VAR 0 3
11438: PUSH
11439: LD_LOC 40
11443: PUSH
11444: FOR_IN
11445: IFFALSE 11458
// zpet_domu ( Kdo ) ;
11447: LD_VAR 0 3
11451: PPUSH
11452: CALL 6181 0 1
11456: GO 11444
11458: POP
11459: POP
// KdoLeci = [ ] ;
11460: LD_ADDR_LOC 40
11464: PUSH
11465: EMPTY
11466: ST_TO_ADDR
// end ; 114 :
11467: GO 11514
11469: LD_INT 114
11471: DOUBLE
11472: EQUAL
11473: IFTRUE 11477
11475: GO 11513
11477: POP
// begin for Kdo in KdoOpravuje do
11478: LD_ADDR_VAR 0 3
11482: PUSH
11483: LD_LOC 41
11487: PUSH
11488: FOR_IN
11489: IFFALSE 11502
// zpet_domu ( Kdo ) ;
11491: LD_VAR 0 3
11495: PPUSH
11496: CALL 6181 0 1
11500: GO 11488
11502: POP
11503: POP
// KdoOpravuje = [ ] ;
11504: LD_ADDR_LOC 41
11508: PUSH
11509: EMPTY
11510: ST_TO_ADDR
// end ; end ;
11511: GO 11514
11513: POP
// end ;
11514: LD_VAR 0 2
11518: RET
// every 0 0$57 do
11519: GO 11521
11521: DISABLE
// begin opravuj ;
11522: CALL 11285 0 0
// kuryruj ;
11526: CALL 11353 0 0
// enable ;
11530: ENABLE
// end ;
11531: END
// every 0 0$7.1 do
11532: GO 11534
11534: DISABLE
// begin if zije_zakladna ( side_Am , AmDepot_Oil , Americani_Oil , Obranci_Oil ) then
11535: LD_EXP 2
11539: PPUSH
11540: LD_INT 1
11542: PPUSH
11543: LD_INT 19
11545: PPUSH
11546: LD_LOC 18
11550: PPUSH
11551: CALL 17111 0 4
11555: IFFALSE 11560
// enable else
11557: ENABLE
11558: GO 11568
// ZnicenOil = true ;
11560: LD_ADDR_LOC 42
11564: PUSH
11565: LD_INT 1
11567: ST_TO_ADDR
// end ;
11568: END
// every 0 0$7.9 do
11569: GO 11571
11571: DISABLE
// begin if zije_zakladna ( side_Am , AmDepot_Sib , Americani_Sib , Obranci_Sib ) then
11572: LD_EXP 2
11576: PPUSH
11577: LD_INT 3
11579: PPUSH
11580: LD_INT 20
11582: PPUSH
11583: LD_LOC 19
11587: PPUSH
11588: CALL 17111 0 4
11592: IFFALSE 11597
// enable else
11594: ENABLE
11595: GO 11605
// ZnicenSib = true ;
11597: LD_ADDR_LOC 43
11601: PUSH
11602: LD_INT 1
11604: ST_TO_ADDR
// end ;
11605: END
// function zkontroluj_suroviny ( Mat , Amount ) ; var Base , Inz ; begin
11606: LD_INT 0
11608: PPUSH
11609: PPUSH
11610: PPUSH
// if not IsOk ( AmDepot ) then
11611: LD_INT 15
11613: PPUSH
11614: CALL_OW 302
11618: NOT
11619: IFFALSE 11623
// exit ;
11621: GO 11778
// Base = GetBase ( AmDepot ) ;
11623: LD_ADDR_VAR 0 4
11627: PUSH
11628: LD_INT 15
11630: PPUSH
11631: CALL_OW 274
11635: ST_TO_ADDR
// if GetResourceType ( Base , Mat ) >= Amount then
11636: LD_VAR 0 4
11640: PPUSH
11641: LD_VAR 0 1
11645: PPUSH
11646: CALL_OW 275
11650: PUSH
11651: LD_VAR 0 2
11655: GREATEREQUAL
11656: IFFALSE 11660
// exit ;
11658: GO 11778
// Inz = FilterUnitsInArea ( Americani , [ [ F_SIDE , side_Am ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_ENGINEER ] ] ) ;
11660: LD_ADDR_VAR 0 5
11664: PUSH
11665: LD_INT 2
11667: PPUSH
11668: LD_INT 22
11670: PUSH
11671: LD_EXP 2
11675: PUSH
11676: EMPTY
11677: LIST
11678: LIST
11679: PUSH
11680: LD_INT 21
11682: PUSH
11683: LD_INT 1
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: PUSH
11690: LD_INT 25
11692: PUSH
11693: LD_INT 2
11695: PUSH
11696: EMPTY
11697: LIST
11698: LIST
11699: PUSH
11700: EMPTY
11701: LIST
11702: LIST
11703: LIST
11704: PPUSH
11705: CALL_OW 70
11709: ST_TO_ADDR
// if Inz and ( GetListOfCratesInArea ( Americani ) < 15 ) then
11710: LD_VAR 0 5
11714: PUSH
11715: LD_INT 2
11717: PPUSH
11718: CALL_OW 435
11722: PUSH
11723: LD_INT 15
11725: LESS
11726: AND
11727: IFFALSE 11761
// begin CreateResourcesArea ( Mat , 5 , BednyAmericani , true ) ;
11729: LD_VAR 0 1
11733: PPUSH
11734: LD_INT 5
11736: PPUSH
11737: LD_INT 22
11739: PPUSH
11740: LD_INT 1
11742: PPUSH
11743: CALL_OW 59
// sbirej_bedny ( Inz , BednyAmericani ) ;
11747: LD_VAR 0 5
11751: PPUSH
11752: LD_INT 22
11754: PPUSH
11755: CALL 16291 0 2
// end else
11759: GO 11778
// begin AddResourceType ( Base , Mat , 50 ) ;
11761: LD_VAR 0 4
11765: PPUSH
11766: LD_VAR 0 1
11770: PPUSH
11771: LD_INT 50
11773: PPUSH
11774: CALL_OW 276
// end ; end ;
11778: LD_VAR 0 3
11782: RET
// every 2 2$12 do
11783: GO 11785
11785: DISABLE
// begin zkontroluj_suroviny ( MAT_CANS , 250 ) ;
11786: LD_INT 1
11788: PPUSH
11789: LD_INT 250
11791: PPUSH
11792: CALL 11606 0 2
// zkontroluj_suroviny ( MAT_SIBERIT , 50 ) ;
11796: LD_INT 3
11798: PPUSH
11799: LD_INT 50
11801: PPUSH
11802: CALL 11606 0 2
// zkontroluj_suroviny ( MAT_OIL , 150 ) ;
11806: LD_INT 2
11808: PPUSH
11809: LD_INT 150
11811: PPUSH
11812: CALL 11606 0 2
// enable ;
11816: ENABLE
// end ;
11817: END
// every 0 0$17 trigger RozebratAuta do var F , Hotovo , I ;
11818: LD_LOC 45
11822: IFFALSE 11984
11824: GO 11826
11826: DISABLE
11827: LD_INT 0
11829: PPUSH
11830: PPUSH
11831: PPUSH
// begin F = UnitFilter ( [ AmFactGun , AmFactRock ] , [ [ F_SIDE , side_Am ] , [ F_OK ] ] ) ;
11832: LD_ADDR_VAR 0 1
11836: PUSH
11837: LD_INT 30
11839: PUSH
11840: LD_INT 26
11842: PUSH
11843: EMPTY
11844: LIST
11845: LIST
11846: PPUSH
11847: LD_INT 22
11849: PUSH
11850: LD_EXP 2
11854: PUSH
11855: EMPTY
11856: LIST
11857: LIST
11858: PUSH
11859: LD_INT 50
11861: PUSH
11862: EMPTY
11863: LIST
11864: PUSH
11865: EMPTY
11866: LIST
11867: LIST
11868: PPUSH
11869: CALL_OW 72
11873: ST_TO_ADDR
// if F then
11874: LD_VAR 0 1
11878: IFFALSE 11983
// begin Hotovo = [ ] ;
11880: LD_ADDR_VAR 0 2
11884: PUSH
11885: EMPTY
11886: ST_TO_ADDR
// for I in RozebratAuta do
11887: LD_ADDR_VAR 0 3
11891: PUSH
11892: LD_LOC 45
11896: PUSH
11897: FOR_IN
11898: IFFALSE 11965
// begin if IsDead ( I ) then
11900: LD_VAR 0 3
11904: PPUSH
11905: CALL_OW 301
11909: IFFALSE 11932
// Hotovo = Hotovo union [ I ] else
11911: LD_ADDR_VAR 0 2
11915: PUSH
11916: LD_VAR 0 2
11920: PUSH
11921: LD_VAR 0 3
11925: PUSH
11926: EMPTY
11927: LIST
11928: UNION
11929: ST_TO_ADDR
11930: GO 11963
// if not HasTask ( I ) then
11932: LD_VAR 0 3
11936: PPUSH
11937: CALL_OW 314
11941: NOT
11942: IFFALSE 11963
// ComRecycle ( I , nahoda_seznam ( F ) ) ;
11944: LD_VAR 0 3
11948: PPUSH
11949: LD_VAR 0 1
11953: PPUSH
11954: CALL 17307 0 1
11958: PPUSH
11959: CALL_OW 168
// end ;
11963: GO 11897
11965: POP
11966: POP
// RozebratAuta = RozebratAuta diff Hotovo ;
11967: LD_ADDR_LOC 45
11971: PUSH
11972: LD_LOC 45
11976: PUSH
11977: LD_VAR 0 2
11981: DIFF
11982: ST_TO_ADDR
// end ; enable ;
11983: ENABLE
// end ; end_of_file
11984: PPOPN 3
11986: END
// export dif_BednyStart , dif_BednyRZ , dif_BednyRV ; export dif_CekamJMM , dif_JMMDoprovodPocet ; export dif_UtokSkupina , dif_PrvniUtok , dif_CasovacUtoku ; export dif_ArtefaktDoba ; export function init_difficulty ; begin
11987: LD_INT 0
11989: PPUSH
// dif_BednyRZ = [ 10 , 8 , 6 ] ;
11990: LD_ADDR_EXP 36
11994: PUSH
11995: LD_INT 10
11997: PUSH
11998: LD_INT 8
12000: PUSH
12001: LD_INT 6
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: LIST
12008: ST_TO_ADDR
// dif_BednyRV = [ 10 , 8 , 6 ] ;
12009: LD_ADDR_EXP 37
12013: PUSH
12014: LD_INT 10
12016: PUSH
12017: LD_INT 8
12019: PUSH
12020: LD_INT 6
12022: PUSH
12023: EMPTY
12024: LIST
12025: LIST
12026: LIST
12027: ST_TO_ADDR
// dif_BednyStart = [ 6 , 5 , 4 ] ;
12028: LD_ADDR_EXP 35
12032: PUSH
12033: LD_INT 6
12035: PUSH
12036: LD_INT 5
12038: PUSH
12039: LD_INT 4
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: LIST
12046: ST_TO_ADDR
// dif_CekamJMM = [ [ 24 24$0 , 28 28$0 ] , [ 20 20$0 , 24 24$0 ] , [ 16 16$0 , 20 20$0 ] ] ;
12047: LD_ADDR_EXP 38
12051: PUSH
12052: LD_INT 50400
12054: PUSH
12055: LD_INT 58800
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: PUSH
12062: LD_INT 42000
12064: PUSH
12065: LD_INT 50400
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: PUSH
12072: LD_INT 33600
12074: PUSH
12075: LD_INT 42000
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: EMPTY
12083: LIST
12084: LIST
12085: LIST
12086: ST_TO_ADDR
// dif_JMMDoprovodPocet = [ 2 , 3 , 5 ] ;
12087: LD_ADDR_EXP 39
12091: PUSH
12092: LD_INT 2
12094: PUSH
12095: LD_INT 3
12097: PUSH
12098: LD_INT 5
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: LIST
12105: ST_TO_ADDR
// dif_UtokSkupina = [ 3 , 4 , 6 ] ;
12106: LD_ADDR_EXP 40
12110: PUSH
12111: LD_INT 3
12113: PUSH
12114: LD_INT 4
12116: PUSH
12117: LD_INT 6
12119: PUSH
12120: EMPTY
12121: LIST
12122: LIST
12123: LIST
12124: ST_TO_ADDR
// dif_PrvniUtok = [ [ 6 , 8 ] , [ 4 , 5 ] , [ 3 , 7 ] ] ;
12125: LD_ADDR_EXP 41
12129: PUSH
12130: LD_INT 6
12132: PUSH
12133: LD_INT 8
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: LD_INT 4
12142: PUSH
12143: LD_INT 5
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: PUSH
12150: LD_INT 3
12152: PUSH
12153: LD_INT 7
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: PUSH
12160: EMPTY
12161: LIST
12162: LIST
12163: LIST
12164: ST_TO_ADDR
// dif_CasovacUtoku = [ [ 10 , 8 ] , [ 8 , 8 , 7 ] , [ 6 , 5 , 5 ] ] ;
12165: LD_ADDR_EXP 42
12169: PUSH
12170: LD_INT 10
12172: PUSH
12173: LD_INT 8
12175: PUSH
12176: EMPTY
12177: LIST
12178: LIST
12179: PUSH
12180: LD_INT 8
12182: PUSH
12183: LD_INT 8
12185: PUSH
12186: LD_INT 7
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: LIST
12193: PUSH
12194: LD_INT 6
12196: PUSH
12197: LD_INT 5
12199: PUSH
12200: LD_INT 5
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: LIST
12207: PUSH
12208: EMPTY
12209: LIST
12210: LIST
12211: LIST
12212: ST_TO_ADDR
// dif_ArtefaktDoba = [ 250 , 400 , 600 ] ;
12213: LD_ADDR_EXP 43
12217: PUSH
12218: LD_INT 250
12220: PUSH
12221: LD_INT 400
12223: PUSH
12224: LD_INT 600
12226: PUSH
12227: EMPTY
12228: LIST
12229: LIST
12230: LIST
12231: ST_TO_ADDR
// end ; end_of_file
12232: LD_VAR 0 1
12236: RET
// on UnitDestroyed ( Un ) do begin rusove_UnitDestroyed ( Un ) ;
12237: LD_VAR 0 1
12241: PPUSH
12242: CALL 2858 0 1
// amici_UnitDestroyed ( Un ) ;
12246: LD_VAR 0 1
12250: PPUSH
12251: CALL 7504 0 1
// jmm_UnitDestroyed ( Un ) ;
12255: LD_VAR 0 1
12259: PPUSH
12260: CALL 14260 0 1
// end ;
12264: PPOPN 1
12266: END
// on VehicleConstructed ( Veh , Fact ) do begin amici_VehicleConstructed ( Veh , Fact ) ;
12267: LD_VAR 0 1
12271: PPUSH
12272: LD_VAR 0 2
12276: PPUSH
12277: CALL 6930 0 2
// rusove_VehicleConstructed ( Veh , Fact ) ;
12281: LD_VAR 0 1
12285: PPUSH
12286: LD_VAR 0 2
12290: PPUSH
12291: CALL 4049 0 2
// end ;
12295: PPOPN 2
12297: END
// on WeaponPlaced ( Build , Fact ) do begin rusove_WeaponPlaced ( Build , Fact ) ;
12298: LD_VAR 0 1
12302: PPUSH
12303: LD_VAR 0 2
12307: PPUSH
12308: CALL 4093 0 2
// end ;
12312: PPOPN 2
12314: END
// on SpecResearchComplete ( Lab ) do begin rusove_SpecResearchComplete ( Lab ) ;
12315: LD_VAR 0 1
12319: PPUSH
12320: CALL 4797 0 1
// end ;
12324: PPOPN 1
12326: END
// on SpecResearchCancel ( Lab , Progress ) do begin rusove_SpecResearchCancel ( Lab , Progress ) ;
12327: LD_VAR 0 1
12331: PPUSH
12332: LD_VAR 0 2
12336: PPUSH
12337: CALL 3643 0 2
// end ;
12341: PPOPN 2
12343: END
// on VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) do begin amici_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
12344: LD_VAR 0 1
12348: PPUSH
12349: LD_VAR 0 2
12353: PPUSH
12354: LD_VAR 0 3
12358: PPUSH
12359: LD_VAR 0 4
12363: PPUSH
12364: CALL 7521 0 4
// rusove_VehicleCaptured ( VehNew , VehOld , OrigSide , Hum ) ;
12368: LD_VAR 0 1
12372: PPUSH
12373: LD_VAR 0 2
12377: PPUSH
12378: LD_VAR 0 3
12382: PPUSH
12383: LD_VAR 0 4
12387: PPUSH
12388: CALL 5211 0 4
// end ;
12392: PPOPN 4
12394: END
// on SailEvent ( Event ) do begin case Event of 102 :
12395: LD_VAR 0 1
12399: PUSH
12400: LD_INT 102
12402: DOUBLE
12403: EQUAL
12404: IFTRUE 12408
12406: GO 12415
12408: POP
// event_ArtefactStolen ; 111 :
12409: CALL 4470 0 0
12413: GO 12457
12415: LD_INT 111
12417: DOUBLE
12418: EQUAL
12419: IFTRUE 12423
12421: GO 12430
12423: POP
// event_KradenikPredKradenim ; 113 , 114 :
12424: CALL 9952 0 0
12428: GO 12457
12430: LD_INT 113
12432: DOUBLE
12433: EQUAL
12434: IFTRUE 12444
12436: LD_INT 114
12438: DOUBLE
12439: EQUAL
12440: IFTRUE 12444
12442: GO 12456
12444: POP
// event_AmiciOprava ( Event ) ; end ;
12445: LD_VAR 0 1
12449: PPUSH
12450: CALL 11416 0 1
12454: GO 12457
12456: POP
// end ;
12457: PPOPN 1
12459: END
// on UpgradeComplete ( Build ) do begin rusove_UpgradeComplete ( Build ) ;
12460: LD_VAR 0 1
12464: PPUSH
12465: CALL 3368 0 1
// end ;
12469: PPOPN 1
12471: END
// on ResearchComplete ( Tech , Lab ) do begin rusove_ResearchComplete ( Tech , Lab ) ;
12472: LD_VAR 0 1
12476: PPUSH
12477: LD_VAR 0 2
12481: PPUSH
12482: CALL 3500 0 2
// end ;
12486: PPOPN 2
12488: END
// on ResearchStarted ( Tech , Lab ) do begin rusove_ResearchStarted ( Tech , Lab ) ;
12489: LD_VAR 0 1
12493: PPUSH
12494: LD_VAR 0 2
12498: PPUSH
12499: CALL 3574 0 2
// end ;
12503: PPOPN 2
12505: END
// on ResearchCancel ( Tech , Lab ) do begin rusove_ResearchCancel ( Tech , Lab ) ;
12506: LD_VAR 0 1
12510: PPUSH
12511: LD_VAR 0 2
12515: PPUSH
12516: CALL 3605 0 2
// end ;
12520: PPOPN 2
12522: END
// on BuildingStarted ( Build , Hum ) do begin rusove_BuildingStarted ( Build , Hum ) ;
12523: LD_VAR 0 1
12527: PPUSH
12528: LD_VAR 0 2
12532: PPUSH
12533: CALL 3001 0 2
// end ;
12537: PPOPN 2
12539: END
// on BuildingCaptured ( Build , OrigSide , Eng ) do begin amici_BuildingCaptured ( Build , OrigSide , Eng ) ;
12540: LD_VAR 0 1
12544: PPUSH
12545: LD_VAR 0 2
12549: PPUSH
12550: LD_VAR 0 3
12554: PPUSH
12555: CALL 7550 0 3
// end ;
12559: PPOPN 3
12561: END
// on ArtifactLoaded ( Un , Size ) do begin rusove_ArtifactLoaded ( Un , Size ) ;
12562: LD_VAR 0 1
12566: PPUSH
12567: LD_VAR 0 2
12571: PPUSH
12572: CALL 4389 0 2
// end ;
12576: PPOPN 2
12578: END
// on ArtifactUnloaded ( Un , Size ) do begin rusove_ArtifactUnloaded ( Un , Size ) ;
12579: LD_VAR 0 1
12583: PPUSH
12584: LD_VAR 0 2
12588: PPUSH
12589: CALL 4555 0 2
// end ;
12593: PPOPN 2
12595: END
// on ArtifactUsed ( Side , Number , P1 , P2 ) do begin rusove_ArtifactUsed ( Side , Number , P1 , P2 ) ;
12596: LD_VAR 0 1
12600: PPUSH
12601: LD_VAR 0 2
12605: PPUSH
12606: LD_VAR 0 3
12610: PPUSH
12611: LD_VAR 0 4
12615: PPUSH
12616: CALL 4822 0 4
// end ;
12620: PPOPN 4
12622: END
// on McAttackDone ( McId , Un ) do begin amici_McAttackDone ( McId , Un ) ;
12623: LD_VAR 0 1
12627: PPUSH
12628: LD_VAR 0 2
12632: PPUSH
12633: CALL 10927 0 2
// end ;
12637: PPOPN 2
12639: END
// on McDone ( McId , State ) do begin amici_McDone ( McId , State ) ;
12640: LD_VAR 0 1
12644: PPUSH
12645: LD_VAR 0 2
12649: PPUSH
12650: CALL 8677 0 2
// end ;
12654: PPOPN 2
12656: END
// on EvacuateVehicle ( Hum , Veh , Unk1 , Unk2 ) do begin jmm_EvacuateVehicle ( Hum , Veh ) ;
12657: LD_VAR 0 1
12661: PPUSH
12662: LD_VAR 0 2
12666: PPUSH
12667: CALL 14430 0 2
// end ;
12671: PPOPN 4
12673: END
// every 1 1$59 do
12674: GO 12676
12676: DISABLE
// begin RandomizeAll ;
12677: CALL_OW 11
// end ; end_of_file
12681: END
// var BednyRZ , BednyRV ; export function init_suroviny ; var I ; begin
12682: LD_INT 0
12684: PPUSH
12685: PPUSH
// BednyRZ = dif_BednyRZ [ Difficulty ] ;
12686: LD_ADDR_LOC 53
12690: PUSH
12691: LD_EXP 36
12695: PUSH
12696: LD_OWVAR 67
12700: ARRAY
12701: ST_TO_ADDR
// BednyRV = dif_BednyRV [ Difficulty ] ;
12702: LD_ADDR_LOC 54
12706: PUSH
12707: LD_EXP 37
12711: PUSH
12712: LD_OWVAR 67
12716: ARRAY
12717: ST_TO_ADDR
// CreateCratesArea ( 5 , BednyRusoveZStart , false ) ;
12718: LD_INT 5
12720: PPUSH
12721: LD_INT 17
12723: PPUSH
12724: LD_INT 0
12726: PPUSH
12727: CALL_OW 55
// CreateCratesArea ( 5 , BednyRusoveVStart , false ) ;
12731: LD_INT 5
12733: PPUSH
12734: LD_INT 18
12736: PPUSH
12737: LD_INT 0
12739: PPUSH
12740: CALL_OW 55
// for I = 2 to dif_BednyStart [ Difficulty ] do
12744: LD_ADDR_VAR 0 2
12748: PUSH
12749: DOUBLE
12750: LD_INT 2
12752: DEC
12753: ST_TO_ADDR
12754: LD_EXP 35
12758: PUSH
12759: LD_OWVAR 67
12763: ARRAY
12764: PUSH
12765: FOR_TO
12766: IFFALSE 12812
// begin CreateCratesArea ( Rand ( 4 , 5 ) , BednyRusoveZ , false ) ;
12768: LD_INT 4
12770: PPUSH
12771: LD_INT 5
12773: PPUSH
12774: CALL_OW 12
12778: PPUSH
12779: LD_INT 15
12781: PPUSH
12782: LD_INT 0
12784: PPUSH
12785: CALL_OW 55
// CreateCratesArea ( Rand ( 4 , 5 ) , BednyRusoveV , false ) ;
12789: LD_INT 4
12791: PPUSH
12792: LD_INT 5
12794: PPUSH
12795: CALL_OW 12
12799: PPUSH
12800: LD_INT 16
12802: PPUSH
12803: LD_INT 0
12805: PPUSH
12806: CALL_OW 55
// end ;
12810: GO 12765
12812: POP
12813: POP
// end ;
12814: LD_VAR 0 1
12818: RET
// every 2 2$34 do var Baze ;
12819: GO 12821
12821: DISABLE
12822: LD_INT 0
12824: PPUSH
// begin if IsOK ( AmDepot ) then
12825: LD_INT 15
12827: PPUSH
12828: CALL_OW 302
12832: IFFALSE 12893
// begin Wait ( Rand ( 0 0$1 , 0 0$30 ) ) ;
12834: LD_INT 35
12836: PPUSH
12837: LD_INT 1050
12839: PPUSH
12840: CALL_OW 12
12844: PPUSH
12845: CALL_OW 67
// Baze = GetBase ( AmDepot ) ;
12849: LD_ADDR_VAR 0 1
12853: PUSH
12854: LD_INT 15
12856: PPUSH
12857: CALL_OW 274
12861: ST_TO_ADDR
// if GetResourceType ( Baze , MAT_CANS ) < 1500 then
12862: LD_VAR 0 1
12866: PPUSH
12867: LD_INT 1
12869: PPUSH
12870: CALL_OW 275
12874: PUSH
12875: LD_INT 1500
12877: LESS
12878: IFFALSE 12893
// CreateCratesArea ( 5 , BednyAmericani , true ) ;
12880: LD_INT 5
12882: PPUSH
12883: LD_INT 22
12885: PPUSH
12886: LD_INT 1
12888: PPUSH
12889: CALL_OW 55
// end ; enable ;
12893: ENABLE
// end ;
12894: PPOPN 1
12896: END
// every 5 5$13.7 + 5 5$9 do var Pocet ;
12897: GO 12899
12899: DISABLE
12900: LD_INT 0
12902: PPUSH
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
12903: LD_INT 35
12905: PPUSH
12906: LD_INT 2100
12908: PPUSH
12909: CALL_OW 12
12913: PPUSH
12914: CALL_OW 67
// Pocet = Rand ( 0 , 5 ) ;
12918: LD_ADDR_VAR 0 1
12922: PUSH
12923: LD_INT 0
12925: PPUSH
12926: LD_INT 5
12928: PPUSH
12929: CALL_OW 12
12933: ST_TO_ADDR
// if Pocet > 0 then
12934: LD_VAR 0 1
12938: PUSH
12939: LD_INT 0
12941: GREATER
12942: IFFALSE 12956
// CreateCratesAnywhere ( Pocet , true ) ;
12944: LD_VAR 0 1
12948: PPUSH
12949: LD_INT 1
12951: PPUSH
12952: CALL_OW 57
// enable ;
12956: ENABLE
// end ;
12957: PPOPN 1
12959: END
// every 3 3$43 + 1 1$30 do
12960: GO 12962
12962: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
12963: LD_INT 35
12965: PPUSH
12966: LD_INT 4200
12968: PPUSH
12969: CALL_OW 12
12973: PPUSH
12974: CALL_OW 67
// if ( BednyRZ <> 0 ) then
12978: LD_LOC 53
12982: PUSH
12983: LD_INT 0
12985: NONEQUAL
12986: IFFALSE 13045
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveZ , true ) ;
12988: LD_INT 3
12990: PPUSH
12991: LD_INT 5
12993: PPUSH
12994: CALL_OW 12
12998: PPUSH
12999: LD_INT 15
13001: PPUSH
13002: LD_INT 1
13004: PPUSH
13005: CALL_OW 55
// if ( BednyRZ <> - 1 ) then
13009: LD_LOC 53
13013: PUSH
13014: LD_INT 1
13016: NEG
13017: NONEQUAL
13018: IFFALSE 13034
// BednyRZ = BednyRZ - 1 ;
13020: LD_ADDR_LOC 53
13024: PUSH
13025: LD_LOC 53
13029: PUSH
13030: LD_INT 1
13032: MINUS
13033: ST_TO_ADDR
// if ( BednyRZ <> 0 ) then
13034: LD_LOC 53
13038: PUSH
13039: LD_INT 0
13041: NONEQUAL
13042: IFFALSE 13045
// enable ;
13044: ENABLE
// end ; end ;
13045: END
// every 3 3$53 + 0 0$59 do
13046: GO 13048
13048: DISABLE
// begin Wait ( Rand ( 0 0$1 , 2 2$0 ) ) ;
13049: LD_INT 35
13051: PPUSH
13052: LD_INT 4200
13054: PPUSH
13055: CALL_OW 12
13059: PPUSH
13060: CALL_OW 67
// if ( BednyRV <> 0 ) then
13064: LD_LOC 54
13068: PUSH
13069: LD_INT 0
13071: NONEQUAL
13072: IFFALSE 13131
// begin CreateCratesArea ( Rand ( 3 , 5 ) , BednyRusoveV , true ) ;
13074: LD_INT 3
13076: PPUSH
13077: LD_INT 5
13079: PPUSH
13080: CALL_OW 12
13084: PPUSH
13085: LD_INT 16
13087: PPUSH
13088: LD_INT 1
13090: PPUSH
13091: CALL_OW 55
// if ( BednyRV <> - 1 ) then
13095: LD_LOC 54
13099: PUSH
13100: LD_INT 1
13102: NEG
13103: NONEQUAL
13104: IFFALSE 13120
// BednyRV = BednyRV - 1 ;
13106: LD_ADDR_LOC 54
13110: PUSH
13111: LD_LOC 54
13115: PUSH
13116: LD_INT 1
13118: MINUS
13119: ST_TO_ADDR
// if ( BednyRV <> 0 ) then
13120: LD_LOC 54
13124: PUSH
13125: LD_INT 0
13127: NONEQUAL
13128: IFFALSE 13131
// enable ;
13130: ENABLE
// end ; end ; end_of_file
13131: END
// export JMM ; var JMMAuto , JMMDoprovod ; var CekatJMM ; var MakroMove ; var JMMUtekl ; var VidelJMM ; export function init_jmm ; begin
13132: LD_INT 0
13134: PPUSH
// disable ( 11 ) ;
13135: LD_INT 11
13137: DISABLE_MARKED
// disable ( 12 ) ;
13138: LD_INT 12
13140: DISABLE_MARKED
// disable ( 13 ) ;
13141: LD_INT 13
13143: DISABLE_MARKED
// disable ( 14 ) ;
13144: LD_INT 14
13146: DISABLE_MARKED
// disable ( 15 ) ;
13147: LD_INT 15
13149: DISABLE_MARKED
// CekatJMM = dif_CekamJMM [ Difficulty ] ;
13150: LD_ADDR_LOC 57
13154: PUSH
13155: LD_EXP 38
13159: PUSH
13160: LD_OWVAR 67
13164: ARRAY
13165: ST_TO_ADDR
// JMMDoprovod = [ ] ;
13166: LD_ADDR_LOC 56
13170: PUSH
13171: EMPTY
13172: ST_TO_ADDR
// MakroMove = 0 ;
13173: LD_ADDR_LOC 58
13177: PUSH
13178: LD_INT 0
13180: ST_TO_ADDR
// JMMUtekl = false ;
13181: LD_ADDR_LOC 59
13185: PUSH
13186: LD_INT 0
13188: ST_TO_ADDR
// VidelJMM = false ;
13189: LD_ADDR_LOC 60
13193: PUSH
13194: LD_INT 0
13196: ST_TO_ADDR
// vytvor_jmm ;
13197: CALL 13248 0 0
// vytvor_jmm_auto ;
13201: CALL 13325 0 0
// PlaceHumanInUnit ( JMM , JMMAuto ) ;
13205: LD_EXP 44
13209: PPUSH
13210: LD_LOC 55
13214: PPUSH
13215: CALL_OW 52
// PlaceUnitArea ( JMMAuto , JMMStart , false ) ;
13219: LD_LOC 55
13223: PPUSH
13224: LD_INT 4
13226: PPUSH
13227: LD_INT 0
13229: PPUSH
13230: CALL_OW 49
// ComHold ( JMMAuto ) ;
13234: LD_LOC 55
13238: PPUSH
13239: CALL_OW 140
// end ;
13243: LD_VAR 0 1
13247: RET
// function vytvor_jmm ; begin
13248: LD_INT 0
13250: PPUSH
// if JMM then
13251: LD_EXP 44
13255: IFFALSE 13259
// exit ;
13257: GO 13320
// UC_Side = side_Am ;
13259: LD_ADDR_OWVAR 20
13263: PUSH
13264: LD_EXP 2
13268: ST_TO_ADDR
// if TestCharacters ( Macmillan ) then
13269: LD_STRING Macmillan
13271: PPUSH
13272: CALL_OW 28
13276: IFFALSE 13293
// JMM = CreateCharacter ( Macmillan ) else
13278: LD_ADDR_EXP 44
13282: PUSH
13283: LD_STRING Macmillan
13285: PPUSH
13286: CALL_OW 34
13290: ST_TO_ADDR
13291: GO 13306
// JMM = NewCharacter ( Macmillan ) ;
13293: LD_ADDR_EXP 44
13297: PUSH
13298: LD_STRING Macmillan
13300: PPUSH
13301: CALL_OW 25
13305: ST_TO_ADDR
// SetSide ( JMM , side_Am ) ;
13306: LD_EXP 44
13310: PPUSH
13311: LD_EXP 2
13315: PPUSH
13316: CALL_OW 235
// end ;
13320: LD_VAR 0 1
13324: RET
// function vytvor_jmm_auto ; begin
13325: LD_INT 0
13327: PPUSH
// if JMMAuto then
13328: LD_LOC 55
13332: IFFALSE 13336
// exit ;
13334: GO 13422
// UC_Side = side_Am ;
13336: LD_ADDR_OWVAR 20
13340: PUSH
13341: LD_EXP 2
13345: ST_TO_ADDR
// UC_Nation = NATION_AMERICAN ;
13346: LD_ADDR_OWVAR 21
13350: PUSH
13351: LD_INT 1
13353: ST_TO_ADDR
// VC_Chassis = US_MORPHLING ;
13354: LD_ADDR_OWVAR 37
13358: PUSH
13359: LD_INT 5
13361: ST_TO_ADDR
// VC_Control = CONTROL_MANUAL ;
13362: LD_ADDR_OWVAR 38
13366: PUSH
13367: LD_INT 1
13369: ST_TO_ADDR
// VC_Engine = ENGINE_SIBERITE ;
13370: LD_ADDR_OWVAR 39
13374: PUSH
13375: LD_INT 3
13377: ST_TO_ADDR
// VC_Weapon = US_HEAVY_GUN ;
13378: LD_ADDR_OWVAR 40
13382: PUSH
13383: LD_INT 6
13385: ST_TO_ADDR
// JMMAuto = CreateVehicle ;
13386: LD_ADDR_LOC 55
13390: PUSH
13391: CALL_OW 45
13395: ST_TO_ADDR
// SetMark ( JMMAuto , 1 ) ;
13396: LD_LOC 55
13400: PPUSH
13401: LD_INT 1
13403: PPUSH
13404: CALL_OW 242
// SetSide ( JMMAuto , side_Am ) ;
13408: LD_LOC 55
13412: PPUSH
13413: LD_EXP 2
13417: PPUSH
13418: CALL_OW 235
// end ;
13422: LD_VAR 0 1
13426: RET
// function jmm_start ; begin
13427: LD_INT 0
13429: PPUSH
// DialogueOn ;
13430: CALL_OW 6
// dialog_JMMStart ;
13434: CALL 15322 0 0
// ChangeMissionObjectives ( MJMM ) ;
13438: LD_STRING MJMM
13440: PPUSH
13441: CALL_OW 337
// DialogueOff ;
13445: CALL_OW 7
// enable ( 11 ) ;
13449: LD_INT 11
13451: ENABLE_MARKED
// end ;
13452: LD_VAR 0 1
13456: RET
// function jmm_appear ; var Kdo ; begin
13457: LD_INT 0
13459: PPUSH
13460: PPUSH
// Result = false ;
13461: LD_ADDR_VAR 0 1
13465: PUSH
13466: LD_INT 0
13468: ST_TO_ADDR
// JMMDoprovod = amici_vezmi_doprovod ;
13469: LD_ADDR_LOC 56
13473: PUSH
13474: CALL 10013 0 0
13478: ST_TO_ADDR
// if not JMMDoprovod then
13479: LD_LOC 56
13483: NOT
13484: IFFALSE 13488
// exit ;
13486: GO 13728
// enable ( 15 ) ;
13488: LD_INT 15
13490: ENABLE_MARKED
// Kdo = IsInUnit ( JMM ) ;
13491: LD_ADDR_VAR 0 2
13495: PUSH
13496: LD_EXP 44
13500: PPUSH
13501: CALL_OW 310
13505: ST_TO_ADDR
// if not Kdo then
13506: LD_VAR 0 2
13510: NOT
13511: IFFALSE 13523
// Kdo = JMM ;
13513: LD_ADDR_VAR 0 2
13517: PUSH
13518: LD_EXP 44
13522: ST_TO_ADDR
// ComFree ( Kdo ) ;
13523: LD_VAR 0 2
13527: PPUSH
13528: CALL_OW 139
// Wait ( 0 0$1 ) ;
13532: LD_INT 35
13534: PPUSH
13535: CALL_OW 67
// MakroMove = McMove ( 50 , JMMDoprovod union [ Kdo ] , [ [ 142 , 38 ] , [ 153 , 49 ] , [ 156 , 60 ] , [ 152 , 67 ] , [ 151 , 72 ] , [ 144 , 74 ] , [ 135 , 76 ] , [ 129 , 75 ] , [ 119 , 78 ] , [ 105 , 105 ] , [ 98 , 125 ] , [ 80 , 155 ] ] , [ MC_MOVE_WAITWP , MC_MOVE_DONTCAPTURE , MC_MOVE_AGRESSIVE ] ) ;
13539: LD_ADDR_LOC 58
13543: PUSH
13544: LD_INT 50
13546: PPUSH
13547: LD_LOC 56
13551: PUSH
13552: LD_VAR 0 2
13556: PUSH
13557: EMPTY
13558: LIST
13559: UNION
13560: PPUSH
13561: LD_INT 142
13563: PUSH
13564: LD_INT 38
13566: PUSH
13567: EMPTY
13568: LIST
13569: LIST
13570: PUSH
13571: LD_INT 153
13573: PUSH
13574: LD_INT 49
13576: PUSH
13577: EMPTY
13578: LIST
13579: LIST
13580: PUSH
13581: LD_INT 156
13583: PUSH
13584: LD_INT 60
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PUSH
13591: LD_INT 152
13593: PUSH
13594: LD_INT 67
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 151
13603: PUSH
13604: LD_INT 72
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 144
13613: PUSH
13614: LD_INT 74
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 135
13623: PUSH
13624: LD_INT 76
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 129
13633: PUSH
13634: LD_INT 75
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: LD_INT 119
13643: PUSH
13644: LD_INT 78
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: LD_INT 105
13653: PUSH
13654: LD_INT 105
13656: PUSH
13657: EMPTY
13658: LIST
13659: LIST
13660: PUSH
13661: LD_INT 98
13663: PUSH
13664: LD_INT 125
13666: PUSH
13667: EMPTY
13668: LIST
13669: LIST
13670: PUSH
13671: LD_INT 80
13673: PUSH
13674: LD_INT 155
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: PPUSH
13695: LD_INT 3
13697: PUSH
13698: LD_INT 5
13700: PUSH
13701: LD_INT 6
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: LIST
13708: PPUSH
13709: CALL_OW 398
13713: ST_TO_ADDR
// enable ( 12 ) ;
13714: LD_INT 12
13716: ENABLE_MARKED
// enable ( 14 ) ;
13717: LD_INT 14
13719: ENABLE_MARKED
// Result = true ;
13720: LD_ADDR_VAR 0 1
13724: PUSH
13725: LD_INT 1
13727: ST_TO_ADDR
// end ;
13728: LD_VAR 0 1
13732: RET
// every 0 0$0.8 marked 15 do var Vidi , Auto ;
13733: GO 13735
13735: DISABLE
13736: LD_INT 0
13738: PPUSH
13739: PPUSH
// begin if VidelJMM then
13740: LD_LOC 60
13744: IFFALSE 13748
// exit ;
13746: GO 13834
// Auto = IsInUnit ( JMM ) ;
13748: LD_ADDR_VAR 0 2
13752: PUSH
13753: LD_EXP 44
13757: PPUSH
13758: CALL_OW 310
13762: ST_TO_ADDR
// Vidi = See ( side_Ru , JMM ) or ( Auto and See ( side_Ru , Auto ) ) ;
13763: LD_ADDR_VAR 0 1
13767: PUSH
13768: LD_EXP 3
13772: PPUSH
13773: LD_EXP 44
13777: PPUSH
13778: CALL_OW 292
13782: PUSH
13783: LD_VAR 0 2
13787: PUSH
13788: LD_EXP 3
13792: PPUSH
13793: LD_VAR 0 2
13797: PPUSH
13798: CALL_OW 292
13802: AND
13803: OR
13804: ST_TO_ADDR
// if Vidi then
13805: LD_VAR 0 1
13809: IFFALSE 13833
// begin VidelJMM = true ;
13811: LD_ADDR_LOC 60
13815: PUSH
13816: LD_INT 1
13818: ST_TO_ADDR
// DialogueOn ;
13819: CALL_OW 6
// dialog_JMMAppear ;
13823: CALL 15470 0 0
// DialogueOff ;
13827: CALL_OW 7
// end else
13831: GO 13834
// enable ;
13833: ENABLE
// end ;
13834: PPOPN 2
13836: END
// every 0 0$30 do
13837: GO 13839
13839: DISABLE
// begin Wait ( Rand ( CekatJMM [ 1 ] , CekatJMM [ 2 ] ) ) ;
13840: LD_LOC 57
13844: PUSH
13845: LD_INT 1
13847: ARRAY
13848: PPUSH
13849: LD_LOC 57
13853: PUSH
13854: LD_INT 2
13856: ARRAY
13857: PPUSH
13858: CALL_OW 12
13862: PPUSH
13863: CALL_OW 67
// jmm_start ;
13867: CALL 13427 0 0
// end ;
13871: END
// every 1 1$30 marked 11 do
13872: GO 13874
13874: DISABLE
// begin Wait ( Rand ( 0 0$1 , 1 1$0 ) ) ;
13875: LD_INT 35
13877: PPUSH
13878: LD_INT 2100
13880: PPUSH
13881: CALL_OW 12
13885: PPUSH
13886: CALL_OW 67
// if not jmm_appear then
13890: CALL 13457 0 0
13894: NOT
13895: IFFALSE 13898
// enable ;
13897: ENABLE
// end ;
13898: END
// every 0 0$1 marked 12 do
13899: GO 13901
13901: DISABLE
// begin WaitForMc ( MakroMove ) ;
13902: LD_LOC 58
13906: PPUSH
13907: CALL_OW 385
// enable ( 13 ) ;
13911: LD_INT 13
13913: ENABLE_MARKED
// end ;
13914: END
// function presun_unikova_zona ; var Kdo , List ; begin
13915: LD_INT 0
13917: PPUSH
13918: PPUSH
13919: PPUSH
// Kdo = IsInUnit ( JMM ) ;
13920: LD_ADDR_VAR 0 2
13924: PUSH
13925: LD_EXP 44
13929: PPUSH
13930: CALL_OW 310
13934: ST_TO_ADDR
// if not Kdo then
13935: LD_VAR 0 2
13939: NOT
13940: IFFALSE 13952
// Kdo = JMM ;
13942: LD_ADDR_VAR 0 2
13946: PUSH
13947: LD_EXP 44
13951: ST_TO_ADDR
// List = [ Kdo ] union JMMDoprovod ;
13952: LD_ADDR_VAR 0 3
13956: PUSH
13957: LD_VAR 0 2
13961: PUSH
13962: EMPTY
13963: LIST
13964: PUSH
13965: LD_LOC 56
13969: UNION
13970: ST_TO_ADDR
// Result = true ;
13971: LD_ADDR_VAR 0 1
13975: PUSH
13976: LD_INT 1
13978: ST_TO_ADDR
// for Kdo in List do
13979: LD_ADDR_VAR 0 2
13983: PUSH
13984: LD_VAR 0 3
13988: PUSH
13989: FOR_IN
13990: IFFALSE 14044
// begin if not IsPlaced ( Kdo ) then
13992: LD_VAR 0 2
13996: PPUSH
13997: CALL_OW 305
14001: NOT
14002: IFFALSE 14006
// continue ;
14004: GO 13989
// if IsInArea ( Kdo , JMMUtek ) then
14006: LD_VAR 0 2
14010: PPUSH
14011: LD_INT 5
14013: PPUSH
14014: CALL_OW 308
14018: IFFALSE 14022
// continue ;
14020: GO 13989
// ComMoveToArea ( Kdo , JMMUtek ) ;
14022: LD_VAR 0 2
14026: PPUSH
14027: LD_INT 5
14029: PPUSH
14030: CALL_OW 113
// Result = false ;
14034: LD_ADDR_VAR 0 1
14038: PUSH
14039: LD_INT 0
14041: ST_TO_ADDR
// end ;
14042: GO 13989
14044: POP
14045: POP
// end ;
14046: LD_VAR 0 1
14050: RET
// every 0 0$3.4 marked 13 do
14051: GO 14053
14053: DISABLE
// begin if not presun_unikova_zona then
14054: CALL 13915 0 0
14058: NOT
14059: IFFALSE 14062
// enable ;
14061: ENABLE
// end ;
14062: END
// every 0 0$1.2 marked 14 do var Kdo , List , Odstraneno ;
14063: GO 14065
14065: DISABLE
14066: LD_INT 0
14068: PPUSH
14069: PPUSH
14070: PPUSH
// begin if JMMDoprovod then
14071: LD_LOC 56
14075: IFFALSE 14170
// begin Odstraneno = [ ] ;
14077: LD_ADDR_VAR 0 3
14081: PUSH
14082: EMPTY
14083: ST_TO_ADDR
// for Kdo in JMMDoprovod do
14084: LD_ADDR_VAR 0 1
14088: PUSH
14089: LD_LOC 56
14093: PUSH
14094: FOR_IN
14095: IFFALSE 14152
// if IsPlaced ( Kdo ) and IsInArea ( Kdo , JMMUtek ) then
14097: LD_VAR 0 1
14101: PPUSH
14102: CALL_OW 305
14106: PUSH
14107: LD_VAR 0 1
14111: PPUSH
14112: LD_INT 5
14114: PPUSH
14115: CALL_OW 308
14119: AND
14120: IFFALSE 14150
// begin RemoveUnit ( Kdo ) ;
14122: LD_VAR 0 1
14126: PPUSH
14127: CALL_OW 64
// Odstraneno = Odstraneno union [ Kdo ] ;
14131: LD_ADDR_VAR 0 3
14135: PUSH
14136: LD_VAR 0 3
14140: PUSH
14141: LD_VAR 0 1
14145: PUSH
14146: EMPTY
14147: LIST
14148: UNION
14149: ST_TO_ADDR
// end ;
14150: GO 14094
14152: POP
14153: POP
// JMMDoprovod = JMMDoprovod diff Odstraneno ;
14154: LD_ADDR_LOC 56
14158: PUSH
14159: LD_LOC 56
14163: PUSH
14164: LD_VAR 0 3
14168: DIFF
14169: ST_TO_ADDR
// end ; if not JMMUtekl then
14170: LD_LOC 59
14174: NOT
14175: IFFALSE 14238
// begin Kdo = IsInUnit ( JMM ) ;
14177: LD_ADDR_VAR 0 1
14181: PUSH
14182: LD_EXP 44
14186: PPUSH
14187: CALL_OW 310
14191: ST_TO_ADDR
// if not Kdo then
14192: LD_VAR 0 1
14196: NOT
14197: IFFALSE 14209
// Kdo = JMM ;
14199: LD_ADDR_VAR 0 1
14203: PUSH
14204: LD_EXP 44
14208: ST_TO_ADDR
// if IsPlaced ( Kdo ) and IsInArea ( Kdo , JMMUtek ) then
14209: LD_VAR 0 1
14213: PPUSH
14214: CALL_OW 305
14218: PUSH
14219: LD_VAR 0 1
14223: PPUSH
14224: LD_INT 5
14226: PPUSH
14227: CALL_OW 308
14231: AND
14232: IFFALSE 14238
// jmm_Escapes ;
14234: CALL 14357 0 0
// end ; if JmmDoprovod or not JMMUtekl then
14238: LD_LOC 56
14242: PUSH
14243: LD_LOC 59
14247: NOT
14248: OR
14249: IFFALSE 14254
// enable else
14251: ENABLE
14252: GO 14257
// disable ( 13 ) ;
14254: LD_INT 13
14256: DISABLE_MARKED
// end ;
14257: PPOPN 3
14259: END
// export function jmm_UnitDestroyed ( Un ) ; begin
14260: LD_INT 0
14262: PPUSH
// if Un = JMMAuto then
14263: LD_VAR 0 1
14267: PUSH
14268: LD_LOC 55
14272: EQUAL
14273: IFFALSE 14283
// JMMAuto = 0 ;
14275: LD_ADDR_LOC 55
14279: PUSH
14280: LD_INT 0
14282: ST_TO_ADDR
// if Un in JMMDoprovod then
14283: LD_VAR 0 1
14287: PUSH
14288: LD_LOC 56
14292: IN
14293: IFFALSE 14314
// JMMDoprovod = JMMDoprovod diff [ Un ] ;
14295: LD_ADDR_LOC 56
14299: PUSH
14300: LD_LOC 56
14304: PUSH
14305: LD_VAR 0 1
14309: PUSH
14310: EMPTY
14311: LIST
14312: DIFF
14313: ST_TO_ADDR
// if Un = JMM then
14314: LD_VAR 0 1
14318: PUSH
14319: LD_EXP 44
14323: EQUAL
14324: IFFALSE 14352
// begin disable ( 15 ) ;
14326: LD_INT 15
14328: DISABLE_MARKED
// DialogueOn ;
14329: CALL_OW 6
// dialog_JMMDies ;
14333: CALL 15626 0 0
// SA_OnJMMKilled ;
14337: CALL 18029 0 0
// ChangeMissionObjectives ( MJMMOut ) ;
14341: LD_STRING MJMMOut
14343: PPUSH
14344: CALL_OW 337
// DialogueOff ;
14348: CALL_OW 7
// end ; end ;
14352: LD_VAR 0 2
14356: RET
// function jmm_Escapes ; var I ; begin
14357: LD_INT 0
14359: PPUSH
14360: PPUSH
// disable ( 15 ) ;
14361: LD_INT 15
14363: DISABLE_MARKED
// DialogueOn ;
14364: CALL_OW 6
// JMMUtekl = true ;
14368: LD_ADDR_LOC 59
14372: PUSH
14373: LD_INT 1
14375: ST_TO_ADDR
// I = IsInUnit ( JMM ) ;
14376: LD_ADDR_VAR 0 2
14380: PUSH
14381: LD_EXP 44
14385: PPUSH
14386: CALL_OW 310
14390: ST_TO_ADDR
// if I then
14391: LD_VAR 0 2
14395: IFFALSE 14408
// RemoveUnit ( I ) else
14397: LD_VAR 0 2
14401: PPUSH
14402: CALL_OW 64
14406: GO 14417
// RemoveUnit ( JMM ) ;
14408: LD_EXP 44
14412: PPUSH
14413: CALL_OW 64
// dialog_JMMEscapes ;
14417: CALL 15507 0 0
// DialogueOff ;
14421: CALL_OW 7
// end ;
14425: LD_VAR 0 1
14429: RET
// export function jmm_EvacuateVehicle ( Hum , Veh ) ; begin
14430: LD_INT 0
14432: PPUSH
// if MakroMove and ( Hum = JMM ) then
14433: LD_LOC 58
14437: PUSH
14438: LD_VAR 0 1
14442: PUSH
14443: LD_EXP 44
14447: EQUAL
14448: AND
14449: IFFALSE 14487
// begin JMMAuto = 0 ;
14451: LD_ADDR_LOC 55
14455: PUSH
14456: LD_INT 0
14458: ST_TO_ADDR
// RemoveMcUnits ( MakroMove , Veh ) ;
14459: LD_LOC 58
14463: PPUSH
14464: LD_VAR 0 2
14468: PPUSH
14469: CALL_OW 391
// AddMcUnits ( JMM , Veh ) ;
14473: LD_EXP 44
14477: PPUSH
14478: LD_VAR 0 2
14482: PPUSH
14483: CALL_OW 390
// end ; end ; end_of_file
14487: LD_VAR 0 3
14491: RET
// function najdi_nekoho ; var Lidi ; begin
14492: LD_INT 0
14494: PPUSH
14495: PPUSH
// Lidi = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
14496: LD_ADDR_VAR 0 2
14500: PUSH
14501: LD_INT 22
14503: PUSH
14504: LD_EXP 3
14508: PUSH
14509: EMPTY
14510: LIST
14511: LIST
14512: PUSH
14513: LD_INT 50
14515: PUSH
14516: EMPTY
14517: LIST
14518: PUSH
14519: LD_INT 52
14521: PUSH
14522: EMPTY
14523: LIST
14524: PUSH
14525: LD_INT 21
14527: PUSH
14528: LD_INT 1
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: PUSH
14535: LD_INT 26
14537: PUSH
14538: LD_INT 1
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: PUSH
14545: EMPTY
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: PPUSH
14552: CALL_OW 69
14556: PUSH
14557: LD_EXP 4
14561: PUSH
14562: EMPTY
14563: LIST
14564: DIFF
14565: ST_TO_ADDR
// Lidi = bez_opic ( Lidi ) ;
14566: LD_ADDR_VAR 0 2
14570: PUSH
14571: LD_VAR 0 2
14575: PPUSH
14576: CALL 16056 0 1
14580: ST_TO_ADDR
// if Lidi then
14581: LD_VAR 0 2
14585: IFFALSE 14603
// Result = Lidi [ 1 ] else
14587: LD_ADDR_VAR 0 1
14591: PUSH
14592: LD_VAR 0 2
14596: PUSH
14597: LD_INT 1
14599: ARRAY
14600: ST_TO_ADDR
14601: GO 14613
// Result = Burlak ;
14603: LD_ADDR_VAR 0 1
14607: PUSH
14608: LD_EXP 4
14612: ST_TO_ADDR
// end ;
14613: LD_VAR 0 1
14617: RET
// function najdi_vedce ; var Vedci ; begin
14618: LD_INT 0
14620: PPUSH
14621: PPUSH
// Vedci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_SCIENTISTIC ] , [ F_SEX , SEX_MALE ] ] ) diff [ Bystrov , Burlak ] ;
14622: LD_ADDR_VAR 0 2
14626: PUSH
14627: LD_INT 22
14629: PUSH
14630: LD_EXP 3
14634: PUSH
14635: EMPTY
14636: LIST
14637: LIST
14638: PUSH
14639: LD_INT 50
14641: PUSH
14642: EMPTY
14643: LIST
14644: PUSH
14645: LD_INT 52
14647: PUSH
14648: EMPTY
14649: LIST
14650: PUSH
14651: LD_INT 21
14653: PUSH
14654: LD_INT 1
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: PUSH
14661: LD_INT 25
14663: PUSH
14664: LD_INT 4
14666: PUSH
14667: EMPTY
14668: LIST
14669: LIST
14670: PUSH
14671: LD_INT 26
14673: PUSH
14674: LD_INT 1
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: PUSH
14681: EMPTY
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: LIST
14687: LIST
14688: PPUSH
14689: CALL_OW 69
14693: PUSH
14694: LD_EXP 5
14698: PUSH
14699: LD_EXP 4
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: DIFF
14708: ST_TO_ADDR
// Vedci = bez_opic ( Vedci ) ;
14709: LD_ADDR_VAR 0 2
14713: PUSH
14714: LD_VAR 0 2
14718: PPUSH
14719: CALL 16056 0 1
14723: ST_TO_ADDR
// if Vedci then
14724: LD_VAR 0 2
14728: IFFALSE 14746
// Result = Vedci [ 1 ] else
14730: LD_ADDR_VAR 0 1
14734: PUSH
14735: LD_VAR 0 2
14739: PUSH
14740: LD_INT 1
14742: ARRAY
14743: ST_TO_ADDR
14744: GO 14779
// if IsOK ( Bystrov ) then
14746: LD_EXP 5
14750: PPUSH
14751: CALL_OW 302
14755: IFFALSE 14769
// Result = Bystrov else
14757: LD_ADDR_VAR 0 1
14761: PUSH
14762: LD_EXP 5
14766: ST_TO_ADDR
14767: GO 14779
// Result = najdi_nekoho ;
14769: LD_ADDR_VAR 0 1
14773: PUSH
14774: CALL 14492 0 0
14778: ST_TO_ADDR
// end ;
14779: LD_VAR 0 1
14783: RET
// function najdi_vojaka ; var Vojaci ; begin
14784: LD_INT 0
14786: PPUSH
14787: PPUSH
// Vojaci = FilterAllUnits ( [ [ F_SIDE , side_Ru ] , [ F_OK ] , [ F_PLACED ] , [ F_TYPE , UNIT_HUMAN ] , [ F_CLASS , CLASS_SOLDIER ] , [ F_SEX , SEX_MALE ] ] ) diff [ Burlak ] ;
14788: LD_ADDR_VAR 0 2
14792: PUSH
14793: LD_INT 22
14795: PUSH
14796: LD_EXP 3
14800: PUSH
14801: EMPTY
14802: LIST
14803: LIST
14804: PUSH
14805: LD_INT 50
14807: PUSH
14808: EMPTY
14809: LIST
14810: PUSH
14811: LD_INT 52
14813: PUSH
14814: EMPTY
14815: LIST
14816: PUSH
14817: LD_INT 21
14819: PUSH
14820: LD_INT 1
14822: PUSH
14823: EMPTY
14824: LIST
14825: LIST
14826: PUSH
14827: LD_INT 25
14829: PUSH
14830: LD_INT 1
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: PUSH
14837: LD_INT 26
14839: PUSH
14840: LD_INT 1
14842: PUSH
14843: EMPTY
14844: LIST
14845: LIST
14846: PUSH
14847: EMPTY
14848: LIST
14849: LIST
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: PPUSH
14855: CALL_OW 69
14859: PUSH
14860: LD_EXP 4
14864: PUSH
14865: EMPTY
14866: LIST
14867: DIFF
14868: ST_TO_ADDR
// Vojaci = bez_opic ( Vojaci ) ;
14869: LD_ADDR_VAR 0 2
14873: PUSH
14874: LD_VAR 0 2
14878: PPUSH
14879: CALL 16056 0 1
14883: ST_TO_ADDR
// if Vojaci then
14884: LD_VAR 0 2
14888: IFFALSE 14906
// Result = Vojaci [ 1 ] else
14890: LD_ADDR_VAR 0 1
14894: PUSH
14895: LD_VAR 0 2
14899: PUSH
14900: LD_INT 1
14902: ARRAY
14903: ST_TO_ADDR
14904: GO 14916
// Result = najdi_nekoho ;
14906: LD_ADDR_VAR 0 1
14910: PUSH
14911: CALL 14492 0 0
14915: ST_TO_ADDR
// end ;
14916: LD_VAR 0 1
14920: RET
// export function dialog_Arrival ; begin
14921: LD_INT 0
14923: PPUSH
// Say ( Burlak , DArrival-Bur-1 ) ;
14924: LD_EXP 4
14928: PPUSH
14929: LD_STRING DArrival-Bur-1
14931: PPUSH
14932: CALL_OW 88
// Say ( Bystrov , DArrival-Bys-1 ) ;
14936: LD_EXP 5
14940: PPUSH
14941: LD_STRING DArrival-Bys-1
14943: PPUSH
14944: CALL_OW 88
// Say ( Burlak , DArrival-Bur-2 ) ;
14948: LD_EXP 4
14952: PPUSH
14953: LD_STRING DArrival-Bur-2
14955: PPUSH
14956: CALL_OW 88
// end ;
14960: LD_VAR 0 1
14964: RET
// export function dialog_BadBaseN ; begin
14965: LD_INT 0
14967: PPUSH
// if IsOK ( Bystrov ) then
14968: LD_EXP 5
14972: PPUSH
14973: CALL_OW 302
14977: IFFALSE 14991
// Say ( Bystrov , DBadBase-Bys-1 ) ;
14979: LD_EXP 5
14983: PPUSH
14984: LD_STRING DBadBase-Bys-1
14986: PPUSH
14987: CALL_OW 88
// end ;
14991: LD_VAR 0 1
14995: RET
// export function dialog_BadBaseE ; begin
14996: LD_INT 0
14998: PPUSH
// if IsOK ( Bystrov ) then
14999: LD_EXP 5
15003: PPUSH
15004: CALL_OW 302
15008: IFFALSE 15022
// Say ( Bystrov , DBadBase-Bys-1a ) ;
15010: LD_EXP 5
15014: PPUSH
15015: LD_STRING DBadBase-Bys-1a
15017: PPUSH
15018: CALL_OW 88
// end ;
15022: LD_VAR 0 1
15026: RET
// export function dialog_BadLabN ; begin
15027: LD_INT 0
15029: PPUSH
// if IsOK ( Bystrov ) then
15030: LD_EXP 5
15034: PPUSH
15035: CALL_OW 302
15039: IFFALSE 15053
// Say ( Bystrov , DBasLab-Bys-1 ) ;
15041: LD_EXP 5
15045: PPUSH
15046: LD_STRING DBasLab-Bys-1
15048: PPUSH
15049: CALL_OW 88
// end ;
15053: LD_VAR 0 1
15057: RET
// export function dialog_BadLabE ; begin
15058: LD_INT 0
15060: PPUSH
// if IsOK ( Bystrov ) then
15061: LD_EXP 5
15065: PPUSH
15066: CALL_OW 302
15070: IFFALSE 15084
// Say ( Bystrov , DBasLab-Bys-1a ) ;
15072: LD_EXP 5
15076: PPUSH
15077: LD_STRING DBasLab-Bys-1a
15079: PPUSH
15080: CALL_OW 88
// end ;
15084: LD_VAR 0 1
15088: RET
// export function dialog_NoArtefact ; begin
15089: LD_INT 0
15091: PPUSH
// if IsOK ( Bystrov ) then
15092: LD_EXP 5
15096: PPUSH
15097: CALL_OW 302
15101: IFFALSE 15115
// Say ( Bystrov , DNoArtefact-Bys-1 ) ;
15103: LD_EXP 5
15107: PPUSH
15108: LD_STRING DNoArtefact-Bys-1
15110: PPUSH
15111: CALL_OW 88
// end ;
15115: LD_VAR 0 1
15119: RET
// export function dialog_Done1 ; begin
15120: LD_INT 0
15122: PPUSH
// if IsOK ( Bystrov ) then
15123: LD_EXP 5
15127: PPUSH
15128: CALL_OW 302
15132: IFFALSE 15146
// Say ( Bystrov , DDone-Bys-1 ) ;
15134: LD_EXP 5
15138: PPUSH
15139: LD_STRING DDone-Bys-1
15141: PPUSH
15142: CALL_OW 88
// end ;
15146: LD_VAR 0 1
15150: RET
// export function dialog_Done2 ; begin
15151: LD_INT 0
15153: PPUSH
// if IsOK ( Bystrov ) then
15154: LD_EXP 5
15158: PPUSH
15159: CALL_OW 302
15163: IFFALSE 15177
// Say ( Bystrov , DDone-Bys-1a ) ;
15165: LD_EXP 5
15169: PPUSH
15170: LD_STRING DDone-Bys-1a
15172: PPUSH
15173: CALL_OW 88
// end ;
15177: LD_VAR 0 1
15181: RET
// export function dialog_TimeLapser1 ; var Sci ; begin
15182: LD_INT 0
15184: PPUSH
15185: PPUSH
// Sci = najdi_vedce ;
15186: LD_ADDR_VAR 0 2
15190: PUSH
15191: CALL 14618 0 0
15195: ST_TO_ADDR
// if Sci and IsOK ( Sci ) then
15196: LD_VAR 0 2
15200: PUSH
15201: LD_VAR 0 2
15205: PPUSH
15206: CALL_OW 302
15210: AND
15211: IFFALSE 15225
// Say ( Sci , DTimeLapser1-Sci1-1 ) ;
15213: LD_VAR 0 2
15217: PPUSH
15218: LD_STRING DTimeLapser1-Sci1-1
15220: PPUSH
15221: CALL_OW 88
// end ;
15225: LD_VAR 0 1
15229: RET
// export function dialog_TimeLapser2 ; var Sci ; begin
15230: LD_INT 0
15232: PPUSH
15233: PPUSH
// Sci = najdi_vedce ;
15234: LD_ADDR_VAR 0 2
15238: PUSH
15239: CALL 14618 0 0
15243: ST_TO_ADDR
// if Sci and IsOK ( Sci ) then
15244: LD_VAR 0 2
15248: PUSH
15249: LD_VAR 0 2
15253: PPUSH
15254: CALL_OW 302
15258: AND
15259: IFFALSE 15297
// begin Say ( Sci , DTimeLapser2-Sci1-1 ) ;
15261: LD_VAR 0 2
15265: PPUSH
15266: LD_STRING DTimeLapser2-Sci1-1
15268: PPUSH
15269: CALL_OW 88
// Say ( Burlak , DTimeLapser2-Bur-1 ) ;
15273: LD_EXP 4
15277: PPUSH
15278: LD_STRING DTimeLapser2-Bur-1
15280: PPUSH
15281: CALL_OW 88
// Say ( Sci , DTimeLapser2-Sci1-2 ) ;
15285: LD_VAR 0 2
15289: PPUSH
15290: LD_STRING DTimeLapser2-Sci1-2
15292: PPUSH
15293: CALL_OW 88
// end ; end ;
15297: LD_VAR 0 1
15301: RET
// export function dialog_ArtefactSteal ; begin
15302: LD_INT 0
15304: PPUSH
// Say ( Burlak , DArtefactSteal-Bur-1 ) ;
15305: LD_EXP 4
15309: PPUSH
15310: LD_STRING DArtefactSteal-Bur-1
15312: PPUSH
15313: CALL_OW 88
// end ;
15317: LD_VAR 0 1
15321: RET
// export function dialog_JMMStart ; var G ; begin
15322: LD_INT 0
15324: PPUSH
15325: PPUSH
// if Gladkov then
15326: LD_EXP 25
15330: IFFALSE 15344
// G = Gladkov else
15332: LD_ADDR_VAR 0 2
15336: PUSH
15337: LD_EXP 25
15341: ST_TO_ADDR
15342: GO 15354
// G = GladkovFake ;
15344: LD_ADDR_VAR 0 2
15348: PUSH
15349: LD_EXP 26
15353: ST_TO_ADDR
// SayRadio ( G , DJMMStart-Gla-1 ) ;
15354: LD_VAR 0 2
15358: PPUSH
15359: LD_STRING DJMMStart-Gla-1
15361: PPUSH
15362: CALL_OW 94
// SayRadio ( Burlak , DJMMStart-Bur-1 ) ;
15366: LD_EXP 4
15370: PPUSH
15371: LD_STRING DJMMStart-Bur-1
15373: PPUSH
15374: CALL_OW 94
// if Kuzmov and IsOK ( Kuzmov ) then
15378: LD_EXP 11
15382: PUSH
15383: LD_EXP 11
15387: PPUSH
15388: CALL_OW 302
15392: AND
15393: IFFALSE 15407
// Say ( Kuzmov , DJMMStart-Kuz-1 ) ;
15395: LD_EXP 11
15399: PPUSH
15400: LD_STRING DJMMStart-Kuz-1
15402: PPUSH
15403: CALL_OW 88
// if Gnyevko and IsOK ( Gnyevko ) then
15407: LD_EXP 7
15411: PUSH
15412: LD_EXP 7
15416: PPUSH
15417: CALL_OW 302
15421: AND
15422: IFFALSE 15436
// Say ( Gnyevko , DJMMStart-Gny-1 ) ;
15424: LD_EXP 7
15428: PPUSH
15429: LD_STRING DJMMStart-Gny-1
15431: PPUSH
15432: CALL_OW 88
// if Petrovova and IsOK ( Petrovova ) then
15436: LD_EXP 13
15440: PUSH
15441: LD_EXP 13
15445: PPUSH
15446: CALL_OW 302
15450: AND
15451: IFFALSE 15465
// Say ( Petrovova , DJMMStart-Ptr-1 ) ;
15453: LD_EXP 13
15457: PPUSH
15458: LD_STRING DJMMStart-Ptr-1
15460: PPUSH
15461: CALL_OW 88
// end ;
15465: LD_VAR 0 1
15469: RET
// export function dialog_JMMAppear ; var Nekdo ; begin
15470: LD_INT 0
15472: PPUSH
15473: PPUSH
// Nekdo = najdi_vojaka ;
15474: LD_ADDR_VAR 0 2
15478: PUSH
15479: CALL 14784 0 0
15483: ST_TO_ADDR
// if Nekdo then
15484: LD_VAR 0 2
15488: IFFALSE 15502
// Say ( Nekdo , DJMMAppear-RSol1-1 ) ;
15490: LD_VAR 0 2
15494: PPUSH
15495: LD_STRING DJMMAppear-RSol1-1
15497: PPUSH
15498: CALL_OW 88
// end ;
15502: LD_VAR 0 1
15506: RET
// export function dialog_JMMEscapes ; var Nekdo ; begin
15507: LD_INT 0
15509: PPUSH
15510: PPUSH
// Nekdo = najdi_vojaka ;
15511: LD_ADDR_VAR 0 2
15515: PUSH
15516: CALL 14784 0 0
15520: ST_TO_ADDR
// if Nekdo and ( Nekdo <> Kuzmov ) and ( Nekdo <> Gnyevko ) then
15521: LD_VAR 0 2
15525: PUSH
15526: LD_VAR 0 2
15530: PUSH
15531: LD_EXP 11
15535: NONEQUAL
15536: AND
15537: PUSH
15538: LD_VAR 0 2
15542: PUSH
15543: LD_EXP 7
15547: NONEQUAL
15548: AND
15549: IFFALSE 15563
// Say ( Nekdo , DJMMEscapes-RSol1-1 ) ;
15551: LD_VAR 0 2
15555: PPUSH
15556: LD_STRING DJMMEscapes-RSol1-1
15558: PPUSH
15559: CALL_OW 88
// if Kuzmov and IsOK ( Kuzmov ) then
15563: LD_EXP 11
15567: PUSH
15568: LD_EXP 11
15572: PPUSH
15573: CALL_OW 302
15577: AND
15578: IFFALSE 15592
// Say ( Kuzmov , DJMMEscapes-Kuz-1 ) ;
15580: LD_EXP 11
15584: PPUSH
15585: LD_STRING DJMMEscapes-Kuz-1
15587: PPUSH
15588: CALL_OW 88
// if Gnyevko and IsOK ( Gnyevko ) then
15592: LD_EXP 7
15596: PUSH
15597: LD_EXP 7
15601: PPUSH
15602: CALL_OW 302
15606: AND
15607: IFFALSE 15621
// Say ( Gnyevko , DJMMEscapes-Gny-1 ) ;
15609: LD_EXP 7
15613: PPUSH
15614: LD_STRING DJMMEscapes-Gny-1
15616: PPUSH
15617: CALL_OW 88
// end ;
15621: LD_VAR 0 1
15625: RET
// export function dialog_JMMDies ; var Nekdo ; begin
15626: LD_INT 0
15628: PPUSH
15629: PPUSH
// Nekdo = najdi_vojaka ;
15630: LD_ADDR_VAR 0 2
15634: PUSH
15635: CALL 14784 0 0
15639: ST_TO_ADDR
// Say ( Burlak , DJMMDies-Bur-1 ) ;
15640: LD_EXP 4
15644: PPUSH
15645: LD_STRING DJMMDies-Bur-1
15647: PPUSH
15648: CALL_OW 88
// if Gnyevko and IsOK ( Gnyevko ) then
15652: LD_EXP 7
15656: PUSH
15657: LD_EXP 7
15661: PPUSH
15662: CALL_OW 302
15666: AND
15667: IFFALSE 15683
// Say ( Gnyevko , DJMMDies-Gny-1 ) else
15669: LD_EXP 7
15673: PPUSH
15674: LD_STRING DJMMDies-Gny-1
15676: PPUSH
15677: CALL_OW 88
15681: GO 15707
// if ( Nekdo <> Burlak ) then
15683: LD_VAR 0 2
15687: PUSH
15688: LD_EXP 4
15692: NONEQUAL
15693: IFFALSE 15707
// Say ( Nekdo , DJMMDies-RSol1-1 ) ;
15695: LD_VAR 0 2
15699: PPUSH
15700: LD_STRING DJMMDies-RSol1-1
15702: PPUSH
15703: CALL_OW 88
// end ; end_of_file
15707: LD_VAR 0 1
15711: RET
// export function max ( A , B ) ; begin
15712: LD_INT 0
15714: PPUSH
// if A > B then
15715: LD_VAR 0 1
15719: PUSH
15720: LD_VAR 0 2
15724: GREATER
15725: IFFALSE 15739
// Result = A else
15727: LD_ADDR_VAR 0 3
15731: PUSH
15732: LD_VAR 0 1
15736: ST_TO_ADDR
15737: GO 15749
// Result = B ;
15739: LD_ADDR_VAR 0 3
15743: PUSH
15744: LD_VAR 0 2
15748: ST_TO_ADDR
// end ;
15749: LD_VAR 0 3
15753: RET
// export function naloz ( Auto , Budova , Material , Pocet ) ; var Base , Kolik , Volno ; begin
15754: LD_INT 0
15756: PPUSH
15757: PPUSH
15758: PPUSH
15759: PPUSH
// if not GetWeapon ( Auto ) in [ US_CARGO_BAY , RU_CARGO_BAY , AR_CARGO_BAY ] then
15760: LD_VAR 0 1
15764: PPUSH
15765: CALL_OW 264
15769: PUSH
15770: LD_INT 12
15772: PUSH
15773: LD_INT 51
15775: PUSH
15776: LD_INT 32
15778: PUSH
15779: EMPTY
15780: LIST
15781: LIST
15782: LIST
15783: IN
15784: NOT
15785: IFFALSE 15789
// exit ;
15787: GO 15963
// Base = GetBase ( Budova ) ;
15789: LD_ADDR_VAR 0 6
15793: PUSH
15794: LD_VAR 0 2
15798: PPUSH
15799: CALL_OW 274
15803: ST_TO_ADDR
// Kolik = GetResourceType ( Base , Material ) ;
15804: LD_ADDR_VAR 0 7
15808: PUSH
15809: LD_VAR 0 6
15813: PPUSH
15814: LD_VAR 0 3
15818: PPUSH
15819: CALL_OW 275
15823: ST_TO_ADDR
// if Kolik = 0 then
15824: LD_VAR 0 7
15828: PUSH
15829: LD_INT 0
15831: EQUAL
15832: IFFALSE 15836
// exit ;
15834: GO 15963
// Volno = CanCarryHowMuch ( Auto ) ;
15836: LD_ADDR_VAR 0 8
15840: PUSH
15841: LD_VAR 0 1
15845: PPUSH
15846: CALL_OW 466
15850: ST_TO_ADDR
// if Volno = 0 then
15851: LD_VAR 0 8
15855: PUSH
15856: LD_INT 0
15858: EQUAL
15859: IFFALSE 15863
// exit ;
15861: GO 15963
// if Pocet > Kolik then
15863: LD_VAR 0 4
15867: PUSH
15868: LD_VAR 0 7
15872: GREATER
15873: IFFALSE 15885
// Pocet = Kolik ;
15875: LD_ADDR_VAR 0 4
15879: PUSH
15880: LD_VAR 0 7
15884: ST_TO_ADDR
// if Pocet > Volno then
15885: LD_VAR 0 4
15889: PUSH
15890: LD_VAR 0 8
15894: GREATER
15895: IFFALSE 15907
// Pocet = Volno ;
15897: LD_ADDR_VAR 0 4
15901: PUSH
15902: LD_VAR 0 8
15906: ST_TO_ADDR
// if Pocet = 0 then
15907: LD_VAR 0 4
15911: PUSH
15912: LD_INT 0
15914: EQUAL
15915: IFFALSE 15919
// exit ;
15917: GO 15963
// SetResourceType ( Base , Material , Kolik - Pocet ) ;
15919: LD_VAR 0 6
15923: PPUSH
15924: LD_VAR 0 3
15928: PPUSH
15929: LD_VAR 0 7
15933: PUSH
15934: LD_VAR 0 4
15938: MINUS
15939: PPUSH
15940: CALL_OW 277
// AddCargo ( Auto , Material , Pocet ) ;
15944: LD_VAR 0 1
15948: PPUSH
15949: LD_VAR 0 3
15953: PPUSH
15954: LD_VAR 0 4
15958: PPUSH
15959: CALL_OW 291
// end ;
15963: LD_VAR 0 5
15967: RET
// export function vidi_strana_stranu ( Kdo , Koho ) ; var KohoJednotky , Jednotka ; begin
15968: LD_INT 0
15970: PPUSH
15971: PPUSH
15972: PPUSH
// KohoJednotky = FilterAllUnits ( [ [ F_SIDE , Koho ] ] ) ;
15973: LD_ADDR_VAR 0 4
15977: PUSH
15978: LD_INT 22
15980: PUSH
15981: LD_VAR 0 2
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PUSH
15990: EMPTY
15991: LIST
15992: PPUSH
15993: CALL_OW 69
15997: ST_TO_ADDR
// for Jednotka in KohoJednotky do
15998: LD_ADDR_VAR 0 5
16002: PUSH
16003: LD_VAR 0 4
16007: PUSH
16008: FOR_IN
16009: IFFALSE 16041
// if See ( Kdo , Jednotka ) then
16011: LD_VAR 0 1
16015: PPUSH
16016: LD_VAR 0 5
16020: PPUSH
16021: CALL_OW 292
16025: IFFALSE 16039
// begin Result = true ;
16027: LD_ADDR_VAR 0 3
16031: PUSH
16032: LD_INT 1
16034: ST_TO_ADDR
// exit ;
16035: POP
16036: POP
16037: GO 16051
// end ;
16039: GO 16008
16041: POP
16042: POP
// Result = false ;
16043: LD_ADDR_VAR 0 3
16047: PUSH
16048: LD_INT 0
16050: ST_TO_ADDR
// end ;
16051: LD_VAR 0 3
16055: RET
// export function bez_opic ( List ) ; var Opice ; begin
16056: LD_INT 0
16058: PPUSH
16059: PPUSH
// Opice = UnitFilter ( List , [ [ F_OR , [ F_CLASS , CLASS_APEMAN ] , [ F_CLASS , CLASS_APEMAN_SOLDIER ] , [ F_CLASS , CLASS_APEMAN_ENGINEER ] , [ F_CLASS , CLASS_APEMAN_KAMIKAZE ] ] ] ) ;
16060: LD_ADDR_VAR 0 3
16064: PUSH
16065: LD_VAR 0 1
16069: PPUSH
16070: LD_INT 2
16072: PUSH
16073: LD_INT 25
16075: PUSH
16076: LD_INT 12
16078: PUSH
16079: EMPTY
16080: LIST
16081: LIST
16082: PUSH
16083: LD_INT 25
16085: PUSH
16086: LD_INT 15
16088: PUSH
16089: EMPTY
16090: LIST
16091: LIST
16092: PUSH
16093: LD_INT 25
16095: PUSH
16096: LD_INT 16
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PUSH
16103: LD_INT 25
16105: PUSH
16106: LD_INT 17
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: LIST
16117: LIST
16118: LIST
16119: PUSH
16120: EMPTY
16121: LIST
16122: PPUSH
16123: CALL_OW 72
16127: ST_TO_ADDR
// Result = List diff Opice ;
16128: LD_ADDR_VAR 0 2
16132: PUSH
16133: LD_VAR 0 1
16137: PUSH
16138: LD_VAR 0 3
16142: DIFF
16143: ST_TO_ADDR
// end ;
16144: LD_VAR 0 2
16148: RET
// export function opravuj_budovy ( Jednotky , Area , Side ) ; var Budovy , Opravit , I , Kde ; begin
16149: LD_INT 0
16151: PPUSH
16152: PPUSH
16153: PPUSH
16154: PPUSH
16155: PPUSH
// Budovy = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_BUILDING ] , [ F_SIDE , Side ] ] ) ;
16156: LD_ADDR_VAR 0 5
16160: PUSH
16161: LD_VAR 0 2
16165: PPUSH
16166: LD_INT 21
16168: PUSH
16169: LD_INT 3
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: PUSH
16176: LD_INT 22
16178: PUSH
16179: LD_VAR 0 3
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: PUSH
16188: EMPTY
16189: LIST
16190: LIST
16191: PPUSH
16192: CALL_OW 70
16196: ST_TO_ADDR
// Opravit = [ ] ;
16197: LD_ADDR_VAR 0 6
16201: PUSH
16202: EMPTY
16203: ST_TO_ADDR
// for I in Budovy do
16204: LD_ADDR_VAR 0 7
16208: PUSH
16209: LD_VAR 0 5
16213: PUSH
16214: FOR_IN
16215: IFFALSE 16253
// if GetLives ( I ) < HRANICE_ZDRAVI then
16217: LD_VAR 0 7
16221: PPUSH
16222: CALL_OW 256
16226: PUSH
16227: LD_INT 1000
16229: LESS
16230: IFFALSE 16251
// Opravit = Opravit union [ I ] ;
16232: LD_ADDR_VAR 0 6
16236: PUSH
16237: LD_VAR 0 6
16241: PUSH
16242: LD_VAR 0 7
16246: PUSH
16247: EMPTY
16248: LIST
16249: UNION
16250: ST_TO_ADDR
16251: GO 16214
16253: POP
16254: POP
// for I in Opravit do
16255: LD_ADDR_VAR 0 7
16259: PUSH
16260: LD_VAR 0 6
16264: PUSH
16265: FOR_IN
16266: IFFALSE 16284
// AddComRepairBuilding ( Jednotky , I ) ;
16268: LD_VAR 0 1
16272: PPUSH
16273: LD_VAR 0 7
16277: PPUSH
16278: CALL_OW 190
16282: GO 16265
16284: POP
16285: POP
// end ;
16286: LD_VAR 0 4
16290: RET
// export function sbirej_bedny ( Jednotky , Area ) ; var I , Ok , Kdo , Bedny , Delka , X , Y ; begin
16291: LD_INT 0
16293: PPUSH
16294: PPUSH
16295: PPUSH
16296: PPUSH
16297: PPUSH
16298: PPUSH
16299: PPUSH
16300: PPUSH
// Ok = false ;
16301: LD_ADDR_VAR 0 5
16305: PUSH
16306: LD_INT 0
16308: ST_TO_ADDR
// for Kdo in Jednotky do
16309: LD_ADDR_VAR 0 6
16313: PUSH
16314: LD_VAR 0 1
16318: PUSH
16319: FOR_IN
16320: IFFALSE 16345
// if IsOk ( Kdo ) then
16322: LD_VAR 0 6
16326: PPUSH
16327: CALL_OW 302
16331: IFFALSE 16343
// begin Ok = true ;
16333: LD_ADDR_VAR 0 5
16337: PUSH
16338: LD_INT 1
16340: ST_TO_ADDR
// break ;
16341: GO 16345
// end ;
16343: GO 16319
16345: POP
16346: POP
// if not Ok then
16347: LD_VAR 0 5
16351: NOT
16352: IFFALSE 16356
// exit ;
16354: GO 16516
// Bedny = GetListOfCratesInArea ( Area ) ;
16356: LD_ADDR_VAR 0 7
16360: PUSH
16361: LD_VAR 0 2
16365: PPUSH
16366: CALL_OW 435
16370: ST_TO_ADDR
// if not Bedny then
16371: LD_VAR 0 7
16375: NOT
16376: IFFALSE 16380
// exit ;
16378: GO 16516
// Delka = Bedny div 2 ;
16380: LD_ADDR_VAR 0 8
16384: PUSH
16385: LD_VAR 0 7
16389: PUSH
16390: LD_INT 2
16392: DIV
16393: ST_TO_ADDR
// for I = 1 to Delka do
16394: LD_ADDR_VAR 0 4
16398: PUSH
16399: DOUBLE
16400: LD_INT 1
16402: DEC
16403: ST_TO_ADDR
16404: LD_VAR 0 8
16408: PUSH
16409: FOR_TO
16410: IFFALSE 16514
// begin X = Bedny [ 2 * I - 1 ] ;
16412: LD_ADDR_VAR 0 9
16416: PUSH
16417: LD_VAR 0 7
16421: PUSH
16422: LD_INT 2
16424: PUSH
16425: LD_VAR 0 4
16429: MUL
16430: PUSH
16431: LD_INT 1
16433: MINUS
16434: ARRAY
16435: ST_TO_ADDR
// Y = Bedny [ 2 * I ] ;
16436: LD_ADDR_VAR 0 10
16440: PUSH
16441: LD_VAR 0 7
16445: PUSH
16446: LD_INT 2
16448: PUSH
16449: LD_VAR 0 4
16453: MUL
16454: ARRAY
16455: ST_TO_ADDR
// for Kdo in Jednotky do
16456: LD_ADDR_VAR 0 6
16460: PUSH
16461: LD_VAR 0 1
16465: PUSH
16466: FOR_IN
16467: IFFALSE 16510
// if IsOk ( Kdo ) and Prob ( 50 ) then
16469: LD_VAR 0 6
16473: PPUSH
16474: CALL_OW 302
16478: PUSH
16479: LD_INT 50
16481: PPUSH
16482: CALL_OW 13
16486: AND
16487: IFFALSE 16508
// AddComCollect ( Kdo , X , Y ) ;
16489: LD_VAR 0 6
16493: PPUSH
16494: LD_VAR 0 9
16498: PPUSH
16499: LD_VAR 0 10
16503: PPUSH
16504: CALL_OW 177
16508: GO 16466
16510: POP
16511: POP
// end ;
16512: GO 16409
16514: POP
16515: POP
// end ;
16516: LD_VAR 0 3
16520: RET
// export function opravuj_auta ( List , Event , Area , Side , Ignore ) ; var Auta , Opravit , I , Kde , Mech ; begin
16521: LD_INT 0
16523: PPUSH
16524: PPUSH
16525: PPUSH
16526: PPUSH
16527: PPUSH
16528: PPUSH
// Result = [ ] ;
16529: LD_ADDR_VAR 0 6
16533: PUSH
16534: EMPTY
16535: ST_TO_ADDR
// Mech = 0 ;
16536: LD_ADDR_VAR 0 11
16540: PUSH
16541: LD_INT 0
16543: ST_TO_ADDR
// for I in List do
16544: LD_ADDR_VAR 0 9
16548: PUSH
16549: LD_VAR 0 1
16553: PUSH
16554: FOR_IN
16555: IFFALSE 16582
// if IsOk ( I ) then
16557: LD_VAR 0 9
16561: PPUSH
16562: CALL_OW 302
16566: IFFALSE 16580
// begin Mech = I ;
16568: LD_ADDR_VAR 0 11
16572: PUSH
16573: LD_VAR 0 9
16577: ST_TO_ADDR
// break ;
16578: GO 16582
// end ;
16580: GO 16554
16582: POP
16583: POP
// if not Mech then
16584: LD_VAR 0 11
16588: NOT
16589: IFFALSE 16593
// exit ;
16591: GO 16818
// Auta = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_VEHICLE ] , [ F_SIDE , Side ] ] ) diff Ignore ;
16593: LD_ADDR_VAR 0 7
16597: PUSH
16598: LD_VAR 0 3
16602: PPUSH
16603: LD_INT 21
16605: PUSH
16606: LD_INT 2
16608: PUSH
16609: EMPTY
16610: LIST
16611: LIST
16612: PUSH
16613: LD_INT 22
16615: PUSH
16616: LD_VAR 0 4
16620: PUSH
16621: EMPTY
16622: LIST
16623: LIST
16624: PUSH
16625: EMPTY
16626: LIST
16627: LIST
16628: PPUSH
16629: CALL_OW 70
16633: PUSH
16634: LD_VAR 0 5
16638: DIFF
16639: ST_TO_ADDR
// Opravit = [ ] ;
16640: LD_ADDR_VAR 0 8
16644: PUSH
16645: EMPTY
16646: ST_TO_ADDR
// for I in Auta do
16647: LD_ADDR_VAR 0 9
16651: PUSH
16652: LD_VAR 0 7
16656: PUSH
16657: FOR_IN
16658: IFFALSE 16696
// if GetLives ( I ) < HRANICE_ZDRAVI then
16660: LD_VAR 0 9
16664: PPUSH
16665: CALL_OW 256
16669: PUSH
16670: LD_INT 1000
16672: LESS
16673: IFFALSE 16694
// Opravit = Opravit union [ I ] ;
16675: LD_ADDR_VAR 0 8
16679: PUSH
16680: LD_VAR 0 8
16684: PUSH
16685: LD_VAR 0 9
16689: PUSH
16690: EMPTY
16691: LIST
16692: UNION
16693: ST_TO_ADDR
16694: GO 16657
16696: POP
16697: POP
// if Opravit then
16698: LD_VAR 0 8
16702: IFFALSE 16818
// begin Kde = IsInUnit ( Mech ) ;
16704: LD_ADDR_VAR 0 10
16708: PUSH
16709: LD_VAR 0 11
16713: PPUSH
16714: CALL_OW 310
16718: ST_TO_ADDR
// if Kde then
16719: LD_VAR 0 10
16723: IFFALSE 16760
// if GetType ( Kde ) = UNIT_BUILDING then
16725: LD_VAR 0 10
16729: PPUSH
16730: CALL_OW 247
16734: PUSH
16735: LD_INT 3
16737: EQUAL
16738: IFFALSE 16751
// ComExitBuilding ( Mech ) else
16740: LD_VAR 0 11
16744: PPUSH
16745: CALL_OW 122
16749: GO 16760
// ComExitVehicle ( Mech ) ;
16751: LD_VAR 0 11
16755: PPUSH
16756: CALL_OW 121
// for I in Opravit do
16760: LD_ADDR_VAR 0 9
16764: PUSH
16765: LD_VAR 0 8
16769: PUSH
16770: FOR_IN
16771: IFFALSE 16789
// AddComRepairVehicle ( Mech , I ) ;
16773: LD_VAR 0 11
16777: PPUSH
16778: LD_VAR 0 9
16782: PPUSH
16783: CALL_OW 189
16787: GO 16770
16789: POP
16790: POP
// AddComSailEvent ( Mech , Event ) ;
16791: LD_VAR 0 11
16795: PPUSH
16796: LD_VAR 0 2
16800: PPUSH
16801: CALL_OW 224
// Result = [ Mech ] ;
16805: LD_ADDR_VAR 0 6
16809: PUSH
16810: LD_VAR 0 11
16814: PUSH
16815: EMPTY
16816: LIST
16817: ST_TO_ADDR
// end ; end ;
16818: LD_VAR 0 6
16822: RET
// export function kuryruj_lidi ( List , Event , Area , Side ) ; var Lidi , Opravit , I , Kde , Felcar , Budova ; begin
16823: LD_INT 0
16825: PPUSH
16826: PPUSH
16827: PPUSH
16828: PPUSH
16829: PPUSH
16830: PPUSH
16831: PPUSH
// Result = [ ] ;
16832: LD_ADDR_VAR 0 5
16836: PUSH
16837: EMPTY
16838: ST_TO_ADDR
// Felcar = 0 ;
16839: LD_ADDR_VAR 0 10
16843: PUSH
16844: LD_INT 0
16846: ST_TO_ADDR
// for I in List do
16847: LD_ADDR_VAR 0 8
16851: PUSH
16852: LD_VAR 0 1
16856: PUSH
16857: FOR_IN
16858: IFFALSE 16885
// if IsOk ( I ) then
16860: LD_VAR 0 8
16864: PPUSH
16865: CALL_OW 302
16869: IFFALSE 16883
// begin Felcar = I ;
16871: LD_ADDR_VAR 0 10
16875: PUSH
16876: LD_VAR 0 8
16880: ST_TO_ADDR
// break ;
16881: GO 16885
// end ;
16883: GO 16857
16885: POP
16886: POP
// Lidi = FilterUnitsInArea ( Area , [ [ F_TYPE , UNIT_HUMAN ] , [ F_SIDE , Side ] ] ) ;
16887: LD_ADDR_VAR 0 6
16891: PUSH
16892: LD_VAR 0 3
16896: PPUSH
16897: LD_INT 21
16899: PUSH
16900: LD_INT 1
16902: PUSH
16903: EMPTY
16904: LIST
16905: LIST
16906: PUSH
16907: LD_INT 22
16909: PUSH
16910: LD_VAR 0 4
16914: PUSH
16915: EMPTY
16916: LIST
16917: LIST
16918: PUSH
16919: EMPTY
16920: LIST
16921: LIST
16922: PPUSH
16923: CALL_OW 70
16927: ST_TO_ADDR
// Opravit = [ ] ;
16928: LD_ADDR_VAR 0 7
16932: PUSH
16933: EMPTY
16934: ST_TO_ADDR
// for I in Lidi do
16935: LD_ADDR_VAR 0 8
16939: PUSH
16940: LD_VAR 0 6
16944: PUSH
16945: FOR_IN
16946: IFFALSE 16984
// if GetLives ( I ) < HRANICE_ZDRAVI then
16948: LD_VAR 0 8
16952: PPUSH
16953: CALL_OW 256
16957: PUSH
16958: LD_INT 1000
16960: LESS
16961: IFFALSE 16982
// Opravit = Opravit union [ I ] ;
16963: LD_ADDR_VAR 0 7
16967: PUSH
16968: LD_VAR 0 7
16972: PUSH
16973: LD_VAR 0 8
16977: PUSH
16978: EMPTY
16979: LIST
16980: UNION
16981: ST_TO_ADDR
16982: GO 16945
16984: POP
16985: POP
// if Opravit then
16986: LD_VAR 0 7
16990: IFFALSE 17106
// begin Kde = IsInUnit ( Felcar ) ;
16992: LD_ADDR_VAR 0 9
16996: PUSH
16997: LD_VAR 0 10
17001: PPUSH
17002: CALL_OW 310
17006: ST_TO_ADDR
// if Kde then
17007: LD_VAR 0 9
17011: IFFALSE 17048
// if GetType ( Kde ) = UNIT_BUILDING then
17013: LD_VAR 0 9
17017: PPUSH
17018: CALL_OW 247
17022: PUSH
17023: LD_INT 3
17025: EQUAL
17026: IFFALSE 17039
// ComExitBuilding ( Felcar ) else
17028: LD_VAR 0 10
17032: PPUSH
17033: CALL_OW 122
17037: GO 17048
// ComExitVehicle ( Felcar ) ;
17039: LD_VAR 0 10
17043: PPUSH
17044: CALL_OW 121
// for I in Opravit do
17048: LD_ADDR_VAR 0 8
17052: PUSH
17053: LD_VAR 0 7
17057: PUSH
17058: FOR_IN
17059: IFFALSE 17077
// AddComHeal ( Felcar , I ) ;
17061: LD_VAR 0 10
17065: PPUSH
17066: LD_VAR 0 8
17070: PPUSH
17071: CALL_OW 188
17075: GO 17058
17077: POP
17078: POP
// AddComSailEvent ( Felcar , Event ) ;
17079: LD_VAR 0 10
17083: PPUSH
17084: LD_VAR 0 2
17088: PPUSH
17089: CALL_OW 224
// Result = [ Felcar ] ;
17093: LD_ADDR_VAR 0 5
17097: PUSH
17098: LD_VAR 0 10
17102: PUSH
17103: EMPTY
17104: LIST
17105: ST_TO_ADDR
// end ; end ;
17106: LD_VAR 0 5
17110: RET
// export function zije_zakladna ( Side , Depot , Area , Lidi ) ; var I , List ; begin
17111: LD_INT 0
17113: PPUSH
17114: PPUSH
17115: PPUSH
// Result = true ;
17116: LD_ADDR_VAR 0 5
17120: PUSH
17121: LD_INT 1
17123: ST_TO_ADDR
// for I in Lidi do
17124: LD_ADDR_VAR 0 6
17128: PUSH
17129: LD_VAR 0 4
17133: PUSH
17134: FOR_IN
17135: IFFALSE 17171
// if ( GetSide ( I ) = Side ) and IsOk ( I ) then
17137: LD_VAR 0 6
17141: PPUSH
17142: CALL_OW 255
17146: PUSH
17147: LD_VAR 0 1
17151: EQUAL
17152: PUSH
17153: LD_VAR 0 6
17157: PPUSH
17158: CALL_OW 302
17162: AND
17163: IFFALSE 17169
// exit ;
17165: POP
17166: POP
17167: GO 17302
17169: GO 17134
17171: POP
17172: POP
// List = FilterUnitsInArea ( Area , [ [ F_SIDE , Side ] , [ F_TYPE , UNIT_BUILDING ] , [ F_OK ] , [ F_OR , [ F_BTYPE , B_DEPOT ] , [ F_BTYPE , B_WAREHOUSE ] ] ] ) ;
17173: LD_ADDR_VAR 0 7
17177: PUSH
17178: LD_VAR 0 3
17182: PPUSH
17183: LD_INT 22
17185: PUSH
17186: LD_VAR 0 1
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: PUSH
17195: LD_INT 21
17197: PUSH
17198: LD_INT 3
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: PUSH
17205: LD_INT 50
17207: PUSH
17208: EMPTY
17209: LIST
17210: PUSH
17211: LD_INT 2
17213: PUSH
17214: LD_INT 30
17216: PUSH
17217: LD_INT 0
17219: PUSH
17220: EMPTY
17221: LIST
17222: LIST
17223: PUSH
17224: LD_INT 30
17226: PUSH
17227: LD_INT 1
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: PUSH
17234: EMPTY
17235: LIST
17236: LIST
17237: LIST
17238: PUSH
17239: EMPTY
17240: LIST
17241: LIST
17242: LIST
17243: LIST
17244: PPUSH
17245: CALL_OW 70
17249: ST_TO_ADDR
// if List then
17250: LD_VAR 0 7
17254: IFFALSE 17258
// exit ;
17256: GO 17302
// if Depot and ( GetSide ( Depot ) = Side ) and IsOk ( Depot ) then
17258: LD_VAR 0 2
17262: PUSH
17263: LD_VAR 0 2
17267: PPUSH
17268: CALL_OW 255
17272: PUSH
17273: LD_VAR 0 1
17277: EQUAL
17278: AND
17279: PUSH
17280: LD_VAR 0 2
17284: PPUSH
17285: CALL_OW 302
17289: AND
17290: IFFALSE 17294
// exit ;
17292: GO 17302
// Result = false ;
17294: LD_ADDR_VAR 0 5
17298: PUSH
17299: LD_INT 0
17301: ST_TO_ADDR
// end ;
17302: LD_VAR 0 5
17306: RET
// export function nahoda_seznam ( Seznam ) ; begin
17307: LD_INT 0
17309: PPUSH
// if Seznam then
17310: LD_VAR 0 1
17314: IFFALSE 17342
// Result = Seznam [ Rand ( 1 , Seznam ) ] else
17316: LD_ADDR_VAR 0 2
17320: PUSH
17321: LD_VAR 0 1
17325: PUSH
17326: LD_INT 1
17328: PPUSH
17329: LD_VAR 0 1
17333: PPUSH
17334: CALL_OW 12
17338: ARRAY
17339: ST_TO_ADDR
17340: GO 17350
// Result = 0 ;
17342: LD_ADDR_VAR 0 2
17346: PUSH
17347: LD_INT 0
17349: ST_TO_ADDR
// end ;
17350: LD_VAR 0 2
17354: RET
// function uvolni_material ( Auto , Kolik , Co ) ; var Veze ; begin
17355: LD_INT 0
17357: PPUSH
17358: PPUSH
// Veze = GetCargo ( Auto , Co ) ;
17359: LD_ADDR_VAR 0 5
17363: PUSH
17364: LD_VAR 0 1
17368: PPUSH
17369: LD_VAR 0 3
17373: PPUSH
17374: CALL_OW 289
17378: ST_TO_ADDR
// if Veze > 0 then
17379: LD_VAR 0 5
17383: PUSH
17384: LD_INT 0
17386: GREATER
17387: IFFALSE 17446
// begin if ( Kolik >= Veze ) then
17389: LD_VAR 0 2
17393: PUSH
17394: LD_VAR 0 5
17398: GREATEREQUAL
17399: IFFALSE 17411
// Veze = 0 else
17401: LD_ADDR_VAR 0 5
17405: PUSH
17406: LD_INT 0
17408: ST_TO_ADDR
17409: GO 17427
// Veze = Veze - Kolik ;
17411: LD_ADDR_VAR 0 5
17415: PUSH
17416: LD_VAR 0 5
17420: PUSH
17421: LD_VAR 0 2
17425: MINUS
17426: ST_TO_ADDR
// SetCargo ( Auto , Co , Veze ) ;
17427: LD_VAR 0 1
17431: PPUSH
17432: LD_VAR 0 3
17436: PPUSH
17437: LD_VAR 0 5
17441: PPUSH
17442: CALL_OW 290
// end ; end ;
17446: LD_VAR 0 4
17450: RET
// export function uvolni_auto ( Auto , Kolik ) ; var Uveze ; begin
17451: LD_INT 0
17453: PPUSH
17454: PPUSH
// Uveze = CanCarryHowMuch ( Auto ) ;
17455: LD_ADDR_VAR 0 4
17459: PUSH
17460: LD_VAR 0 1
17464: PPUSH
17465: CALL_OW 466
17469: ST_TO_ADDR
// if Uveze >= Kolik then
17470: LD_VAR 0 4
17474: PUSH
17475: LD_VAR 0 2
17479: GREATEREQUAL
17480: IFFALSE 17484
// exit ;
17482: GO 17611
// uvolni_material ( Auto , Kolik - Uveze , MAT_CANS ) ;
17484: LD_VAR 0 1
17488: PPUSH
17489: LD_VAR 0 2
17493: PUSH
17494: LD_VAR 0 4
17498: MINUS
17499: PPUSH
17500: LD_INT 1
17502: PPUSH
17503: CALL 17355 0 3
// Uveze = CanCarryHowMuch ( Auto ) ;
17507: LD_ADDR_VAR 0 4
17511: PUSH
17512: LD_VAR 0 1
17516: PPUSH
17517: CALL_OW 466
17521: ST_TO_ADDR
// if Uveze >= Kolik then
17522: LD_VAR 0 4
17526: PUSH
17527: LD_VAR 0 2
17531: GREATEREQUAL
17532: IFFALSE 17536
// exit ;
17534: GO 17611
// uvolni_material ( Auto , Kolik - Uveze , MAT_OIL ) ;
17536: LD_VAR 0 1
17540: PPUSH
17541: LD_VAR 0 2
17545: PUSH
17546: LD_VAR 0 4
17550: MINUS
17551: PPUSH
17552: LD_INT 2
17554: PPUSH
17555: CALL 17355 0 3
// Uveze = CanCarryHowMuch ( Auto ) ;
17559: LD_ADDR_VAR 0 4
17563: PUSH
17564: LD_VAR 0 1
17568: PPUSH
17569: CALL_OW 466
17573: ST_TO_ADDR
// if Uveze >= Kolik then
17574: LD_VAR 0 4
17578: PUSH
17579: LD_VAR 0 2
17583: GREATEREQUAL
17584: IFFALSE 17588
// exit ;
17586: GO 17611
// uvolni_material ( Auto , Kolik - Uveze , MAT_SIBERIT ) ;
17588: LD_VAR 0 1
17592: PPUSH
17593: LD_VAR 0 2
17597: PUSH
17598: LD_VAR 0 4
17602: MINUS
17603: PPUSH
17604: LD_INT 3
17606: PPUSH
17607: CALL 17355 0 3
// end ; end_of_file
17611: LD_VAR 0 3
17615: RET
// function create_nature ( Cls , Cnt , Area ) ; var i , h ; begin
17616: LD_INT 0
17618: PPUSH
17619: PPUSH
17620: PPUSH
// Result = [ ] ;
17621: LD_ADDR_VAR 0 4
17625: PUSH
17626: EMPTY
17627: ST_TO_ADDR
// UC_nation = NATION_NATURE ;
17628: LD_ADDR_OWVAR 21
17632: PUSH
17633: LD_INT 0
17635: ST_TO_ADDR
// UC_side = side_neutral ;
17636: LD_ADDR_OWVAR 20
17640: PUSH
17641: LD_EXP 1
17645: ST_TO_ADDR
// HC_Class = Cls ;
17646: LD_ADDR_OWVAR 28
17650: PUSH
17651: LD_VAR 0 1
17655: ST_TO_ADDR
// HC_Name =  ;
17656: LD_ADDR_OWVAR 26
17660: PUSH
17661: LD_STRING 
17663: ST_TO_ADDR
// hc_agressivity = rand ( 0 , 20 ) ;
17664: LD_ADDR_OWVAR 35
17668: PUSH
17669: LD_INT 0
17671: PPUSH
17672: LD_INT 20
17674: PPUSH
17675: CALL_OW 12
17679: ST_TO_ADDR
// for i = 1 to Cnt do
17680: LD_ADDR_VAR 0 5
17684: PUSH
17685: DOUBLE
17686: LD_INT 1
17688: DEC
17689: ST_TO_ADDR
17690: LD_VAR 0 2
17694: PUSH
17695: FOR_TO
17696: IFFALSE 17746
// begin h = CreateHuman ;
17698: LD_ADDR_VAR 0 6
17702: PUSH
17703: CALL_OW 44
17707: ST_TO_ADDR
// Result = Result union [ h ] ;
17708: LD_ADDR_VAR 0 4
17712: PUSH
17713: LD_VAR 0 4
17717: PUSH
17718: LD_VAR 0 6
17722: PUSH
17723: EMPTY
17724: LIST
17725: UNION
17726: ST_TO_ADDR
// PlaceUnitArea ( h , Area , false ) ;
17727: LD_VAR 0 6
17731: PPUSH
17732: LD_VAR 0 3
17736: PPUSH
17737: LD_INT 0
17739: PPUSH
17740: CALL_OW 49
// end ;
17744: GO 17695
17746: POP
17747: POP
// end ;
17748: LD_VAR 0 4
17752: RET
// export function init_nature ; begin
17753: LD_INT 0
17755: PPUSH
// create_nature ( CLASS_APEMAN , Rand ( 5 , 7 ) - Difficulty , Les_N ) ;
17756: LD_INT 12
17758: PPUSH
17759: LD_INT 5
17761: PPUSH
17762: LD_INT 7
17764: PPUSH
17765: CALL_OW 12
17769: PUSH
17770: LD_OWVAR 67
17774: MINUS
17775: PPUSH
17776: LD_INT 11
17778: PPUSH
17779: CALL 17616 0 3
// create_nature ( CLASS_APEMAN , Rand ( 5 , 7 ) - Difficulty , Les_S ) ;
17783: LD_INT 12
17785: PPUSH
17786: LD_INT 5
17788: PPUSH
17789: LD_INT 7
17791: PPUSH
17792: CALL_OW 12
17796: PUSH
17797: LD_OWVAR 67
17801: MINUS
17802: PPUSH
17803: LD_INT 12
17805: PPUSH
17806: CALL 17616 0 3
// create_nature ( CLASS_TIGER , Rand ( 3 , 5 ) , Les ) ;
17810: LD_INT 14
17812: PPUSH
17813: LD_INT 3
17815: PPUSH
17816: LD_INT 5
17818: PPUSH
17819: CALL_OW 12
17823: PPUSH
17824: LD_INT 13
17826: PPUSH
17827: CALL 17616 0 3
// create_nature ( CLASS_PHORORHACOS , Rand ( 2 , 4 ) , Louka ) ;
17831: LD_INT 18
17833: PPUSH
17834: LD_INT 2
17836: PPUSH
17837: LD_INT 4
17839: PPUSH
17840: CALL_OW 12
17844: PPUSH
17845: LD_INT 14
17847: PPUSH
17848: CALL 17616 0 3
// end ; end_of_file
17852: LD_VAR 0 1
17856: RET
// every 0 0$2 + 0 0$0.1 do
17857: GO 17859
17859: DISABLE
// begin if FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ) > FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_or , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman_soldier ] , [ f_class , class_apeman_kamikaze ] ] ] ] ) then
17860: LD_INT 22
17862: PUSH
17863: LD_INT 3
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: PUSH
17870: LD_INT 2
17872: PUSH
17873: LD_INT 25
17875: PUSH
17876: LD_INT 12
17878: PUSH
17879: EMPTY
17880: LIST
17881: LIST
17882: PUSH
17883: LD_INT 25
17885: PUSH
17886: LD_INT 16
17888: PUSH
17889: EMPTY
17890: LIST
17891: LIST
17892: PUSH
17893: LD_INT 25
17895: PUSH
17896: LD_INT 15
17898: PUSH
17899: EMPTY
17900: LIST
17901: LIST
17902: PUSH
17903: LD_INT 25
17905: PUSH
17906: LD_INT 17
17908: PUSH
17909: EMPTY
17910: LIST
17911: LIST
17912: PUSH
17913: EMPTY
17914: LIST
17915: LIST
17916: LIST
17917: LIST
17918: LIST
17919: PUSH
17920: EMPTY
17921: LIST
17922: LIST
17923: PPUSH
17924: CALL_OW 69
17928: PUSH
17929: LD_INT 22
17931: PUSH
17932: LD_INT 3
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: PUSH
17939: LD_INT 21
17941: PUSH
17942: LD_INT 1
17944: PUSH
17945: EMPTY
17946: LIST
17947: LIST
17948: PUSH
17949: LD_INT 3
17951: PUSH
17952: LD_INT 2
17954: PUSH
17955: LD_INT 25
17957: PUSH
17958: LD_INT 12
17960: PUSH
17961: EMPTY
17962: LIST
17963: LIST
17964: PUSH
17965: LD_INT 25
17967: PUSH
17968: LD_INT 16
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: PUSH
17975: LD_INT 25
17977: PUSH
17978: LD_INT 15
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PUSH
17985: LD_INT 25
17987: PUSH
17988: LD_INT 17
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: PUSH
18002: EMPTY
18003: LIST
18004: LIST
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: LIST
18010: PPUSH
18011: CALL_OW 69
18015: GREATER
18016: IFFALSE 18027
// begin SetAchievement ( ACH_POTA ) ;
18018: LD_STRING ACH_POTA
18020: PPUSH
18021: CALL_OW 543
// exit ;
18025: GO 18028
// end ; enable ;
18027: ENABLE
// end ;
18028: END
// export function SA_OnJMMKilled ; begin
18029: LD_INT 0
18031: PPUSH
// SetAchievement ( ACH_FRWL ) ;
18032: LD_STRING ACH_FRWL
18034: PPUSH
18035: CALL_OW 543
// end ;
18039: LD_VAR 0 1
18043: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) = 0 do
18044: LD_INT 22
18046: PUSH
18047: LD_INT 1
18049: PUSH
18050: EMPTY
18051: LIST
18052: LIST
18053: PUSH
18054: LD_INT 21
18056: PUSH
18057: LD_INT 3
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: PUSH
18064: EMPTY
18065: LIST
18066: LIST
18067: PPUSH
18068: CALL_OW 69
18072: PUSH
18073: LD_INT 0
18075: EQUAL
18076: IFFALSE 18088
18078: GO 18080
18080: DISABLE
// SetAchievement ( ACH_DEC ) ; end_of_file
18081: LD_STRING ACH_DEC
18083: PPUSH
18084: CALL_OW 543
18088: END
// export function SA_EndMission ( campaignNumber , missionNumber , medal1 , medal2 , medal3 ) ; var achiv ; begin
18089: LD_INT 0
18091: PPUSH
18092: PPUSH
// if not missionNumber then
18093: LD_VAR 0 2
18097: NOT
18098: IFFALSE 18102
// exit ;
18100: GO 18232
// achiv := false ;
18102: LD_ADDR_VAR 0 7
18106: PUSH
18107: LD_INT 0
18109: ST_TO_ADDR
// case campaignNumber of 1 :
18110: LD_VAR 0 1
18114: PUSH
18115: LD_INT 1
18117: DOUBLE
18118: EQUAL
18119: IFTRUE 18123
18121: GO 18134
18123: POP
// achiv := ACH_GOTA ; 2 :
18124: LD_ADDR_VAR 0 7
18128: PUSH
18129: LD_STRING ACH_GOTA
18131: ST_TO_ADDR
18132: GO 18184
18134: LD_INT 2
18136: DOUBLE
18137: EQUAL
18138: IFTRUE 18142
18140: GO 18145
18142: POP
// ; 3 :
18143: GO 18184
18145: LD_INT 3
18147: DOUBLE
18148: EQUAL
18149: IFTRUE 18153
18151: GO 18164
18153: POP
// achiv := ACH_MOTSU ; 4 :
18154: LD_ADDR_VAR 0 7
18158: PUSH
18159: LD_STRING ACH_MOTSU
18161: ST_TO_ADDR
18162: GO 18184
18164: LD_INT 4
18166: DOUBLE
18167: EQUAL
18168: IFTRUE 18172
18170: GO 18183
18172: POP
// achiv := ACH_LOP ; end ;
18173: LD_ADDR_VAR 0 7
18177: PUSH
18178: LD_STRING ACH_LOP
18180: ST_TO_ADDR
18181: GO 18184
18183: POP
// if Difficulty = 3 and achiv and medal1 and medal2 and medal3 then
18184: LD_OWVAR 67
18188: PUSH
18189: LD_INT 3
18191: EQUAL
18192: PUSH
18193: LD_VAR 0 7
18197: AND
18198: PUSH
18199: LD_VAR 0 3
18203: AND
18204: PUSH
18205: LD_VAR 0 4
18209: AND
18210: PUSH
18211: LD_VAR 0 5
18215: AND
18216: IFFALSE 18232
// SetAchievementEX ( achiv , missionNumber ) ;
18218: LD_VAR 0 7
18222: PPUSH
18223: LD_VAR 0 2
18227: PPUSH
18228: CALL_OW 564
// end ;
18232: LD_VAR 0 6
18236: RET
// export function SA_BehemothConstructed ; begin
18237: LD_INT 0
18239: PPUSH
// SetAchievement ( ACH_SMC ) ;
18240: LD_STRING ACH_SMC
18242: PPUSH
18243: CALL_OW 543
// end ;
18247: LD_VAR 0 1
18251: RET
