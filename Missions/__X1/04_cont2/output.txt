// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 45 0 0
// InitTag ;
   8: CALL 229 0 0
// PrepareNature ( natureArea ) ;
  12: LD_INT 2
  14: PPUSH
  15: CALL 704 0 1
// PrepareRussian ;
  19: CALL 3274 0 0
// PrepareArabian ;
  23: CALL 2626 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 2 ) ;
  33: LD_INT 2
  35: PPUSH
  36: CALL_OW 344
// Action ;
  40: CALL 6866 0 0
// end ;
  44: END
// export debug , prefix ; export ibrahimOnRuSide , ruEscapeAllowed , gameTime , loseCounter , flamethrowers , kaiaKilledByRussian , hannibalPath , ruEscapeCounter , baseHill , explodeFirstDepot , explodeSecondDepot , gaidarKilled , outerAreaAchived , earlyEscape ; function Init ; begin
  45: LD_INT 0
  47: PPUSH
// debug := false ;
  48: LD_ADDR_EXP 1
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// prefix := 04_1_ ;
  56: LD_ADDR_EXP 2
  60: PUSH
  61: LD_STRING 04_1_
  63: ST_TO_ADDR
// ibrahimOnRuSide := LoadVariable ( 03_IbrahimHasEscaped , false ) ;
  64: LD_ADDR_EXP 3
  68: PUSH
  69: LD_STRING 03_IbrahimHasEscaped
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: CALL_OW 30
  79: ST_TO_ADDR
// ruEscapeCounter := LoadVariable ( 04_1_EscapeCounter , 0 ) ;
  80: LD_ADDR_EXP 10
  84: PUSH
  85: LD_STRING 04_1_EscapeCounter
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// loseCounter := LoadVariable ( 04_1_DeadCounter , 0 ) ;
  96: LD_ADDR_EXP 6
 100: PUSH
 101: LD_STRING 04_1_DeadCounter
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// baseHill := LoadVariable ( 04_1_BaseHill , false ) ;
 112: LD_ADDR_EXP 11
 116: PUSH
 117: LD_STRING 04_1_BaseHill
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL_OW 30
 127: ST_TO_ADDR
// gameTime := LoadVariable ( 04_1_Time , 40 40$00 ) ;
 128: LD_ADDR_EXP 5
 132: PUSH
 133: LD_STRING 04_1_Time
 135: PPUSH
 136: LD_INT 84000
 138: PPUSH
 139: CALL_OW 30
 143: ST_TO_ADDR
// flamethrowers := LoadVariable ( 04_1_Flamethrower , 0 ) ;
 144: LD_ADDR_EXP 7
 148: PUSH
 149: LD_STRING 04_1_Flamethrower
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: CALL_OW 30
 159: ST_TO_ADDR
// ruEscapeAllowed := false ;
 160: LD_ADDR_EXP 4
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// explodeFirstDepot := false ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// explodeSecondDepot := false ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// gaidarKilled := false ;
 184: LD_ADDR_EXP 14
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// kaiaKilledByRussian := false ;
 192: LD_ADDR_EXP 8
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// outerAreaAchived := false ;
 200: LD_ADDR_EXP 15
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// hannibalPath := false ;
 208: LD_ADDR_EXP 9
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// earlyEscape := false ;
 216: LD_ADDR_EXP 16
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// export tEscape ; function InitTag ; begin
 229: LD_INT 0
 231: PPUSH
// tEscape := 10 ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: LD_INT 10
 239: ST_TO_ADDR
// end ;
 240: LD_VAR 0 1
 244: RET
// every 0 0$1 trigger debug do var i ;
 245: LD_EXP 1
 249: IFFALSE 333
 251: GO 253
 253: DISABLE
 254: LD_INT 0
 256: PPUSH
// begin enable ;
 257: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) do
 258: LD_ADDR_VAR 0 1
 262: PUSH
 263: LD_INT 22
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: LD_INT 21
 278: PUSH
 279: LD_INT 3
 281: PUSH
 282: EMPTY
 283: LIST
 284: LIST
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: FOR_IN
 300: IFFALSE 331
// if GetLives ( i ) < 1000 then
 302: LD_VAR 0 1
 306: PPUSH
 307: CALL_OW 256
 311: PUSH
 312: LD_INT 1000
 314: LESS
 315: IFFALSE 329
// SetLives ( i , 1000 ) ;
 317: LD_VAR 0 1
 321: PPUSH
 322: LD_INT 1000
 324: PPUSH
 325: CALL_OW 234
 329: GO 299
 331: POP
 332: POP
// end ; end_of_file
 333: PPOPN 1
 335: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 336: LD_INT 0
 338: PPUSH
 339: PPUSH
// if exist_mode then
 340: LD_VAR 0 2
 344: IFFALSE 369
// unit := CreateCharacter ( prefix & ident ) else
 346: LD_ADDR_VAR 0 5
 350: PUSH
 351: LD_VAR 0 3
 355: PUSH
 356: LD_VAR 0 1
 360: STR
 361: PPUSH
 362: CALL_OW 34
 366: ST_TO_ADDR
 367: GO 384
// unit := NewCharacter ( ident ) ;
 369: LD_ADDR_VAR 0 5
 373: PUSH
 374: LD_VAR 0 1
 378: PPUSH
 379: CALL_OW 25
 383: ST_TO_ADDR
// result := unit ;
 384: LD_ADDR_VAR 0 4
 388: PUSH
 389: LD_VAR 0 5
 393: ST_TO_ADDR
// end ;
 394: LD_VAR 0 4
 398: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 399: LD_INT 0
 401: PPUSH
// uc_side := side ;
 402: LD_ADDR_OWVAR 20
 406: PUSH
 407: LD_VAR 0 1
 411: ST_TO_ADDR
// uc_nation := nation ;
 412: LD_ADDR_OWVAR 21
 416: PUSH
 417: LD_VAR 0 2
 421: ST_TO_ADDR
// vc_chassis := chassis ;
 422: LD_ADDR_OWVAR 37
 426: PUSH
 427: LD_VAR 0 3
 431: ST_TO_ADDR
// vc_engine := engine ;
 432: LD_ADDR_OWVAR 39
 436: PUSH
 437: LD_VAR 0 4
 441: ST_TO_ADDR
// vc_control := control ;
 442: LD_ADDR_OWVAR 38
 446: PUSH
 447: LD_VAR 0 5
 451: ST_TO_ADDR
// vc_weapon := weapon ;
 452: LD_ADDR_OWVAR 40
 456: PUSH
 457: LD_VAR 0 6
 461: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 462: LD_ADDR_OWVAR 41
 466: PUSH
 467: LD_VAR 0 7
 471: ST_TO_ADDR
// result := CreateVehicle ;
 472: LD_ADDR_VAR 0 8
 476: PUSH
 477: CALL_OW 45
 481: ST_TO_ADDR
// end ;
 482: LD_VAR 0 8
 486: RET
// export function SayX ( units , ident ) ; var i ; begin
 487: LD_INT 0
 489: PPUSH
 490: PPUSH
// result := false ;
 491: LD_ADDR_VAR 0 3
 495: PUSH
 496: LD_INT 0
 498: ST_TO_ADDR
// if not units then
 499: LD_VAR 0 1
 503: NOT
 504: IFFALSE 508
// exit ;
 506: GO 562
// for i in units do
 508: LD_ADDR_VAR 0 4
 512: PUSH
 513: LD_VAR 0 1
 517: PUSH
 518: FOR_IN
 519: IFFALSE 560
// if IsOk ( i ) then
 521: LD_VAR 0 4
 525: PPUSH
 526: CALL_OW 302
 530: IFFALSE 558
// begin Say ( i , ident ) ;
 532: LD_VAR 0 4
 536: PPUSH
 537: LD_VAR 0 2
 541: PPUSH
 542: CALL_OW 88
// result := i ;
 546: LD_ADDR_VAR 0 3
 550: PUSH
 551: LD_VAR 0 4
 555: ST_TO_ADDR
// break ;
 556: GO 560
// end ;
 558: GO 518
 560: POP
 561: POP
// end ;
 562: LD_VAR 0 3
 566: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 567: LD_INT 0
 569: PPUSH
 570: PPUSH
// InitUc ;
 571: CALL_OW 18
// InitHc ;
 575: CALL_OW 19
// uc_side := 0 ;
 579: LD_ADDR_OWVAR 20
 583: PUSH
 584: LD_INT 0
 586: ST_TO_ADDR
// uc_nation := 0 ;
 587: LD_ADDR_OWVAR 21
 591: PUSH
 592: LD_INT 0
 594: ST_TO_ADDR
// for i = 1 to amount do
 595: LD_ADDR_VAR 0 4
 599: PUSH
 600: DOUBLE
 601: LD_INT 1
 603: DEC
 604: ST_TO_ADDR
 605: LD_VAR 0 2
 609: PUSH
 610: FOR_TO
 611: IFFALSE 693
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 613: LD_ADDR_OWVAR 29
 617: PUSH
 618: LD_INT 9
 620: PPUSH
 621: LD_INT 12
 623: PPUSH
 624: CALL_OW 12
 628: PUSH
 629: LD_INT 9
 631: PPUSH
 632: LD_INT 12
 634: PPUSH
 635: CALL_OW 12
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 644: LD_ADDR_OWVAR 35
 648: PUSH
 649: LD_INT 1
 651: NEG
 652: PPUSH
 653: LD_INT 1
 655: PPUSH
 656: CALL_OW 12
 660: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 661: LD_INT 0
 663: PPUSH
 664: LD_INT 12
 666: PPUSH
 667: LD_INT 1
 669: PPUSH
 670: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 674: CALL_OW 44
 678: PPUSH
 679: LD_VAR 0 1
 683: PPUSH
 684: LD_INT 0
 686: PPUSH
 687: CALL_OW 49
// end ;
 691: GO 610
 693: POP
 694: POP
// InitHc ;
 695: CALL_OW 19
// end ;
 699: LD_VAR 0 3
 703: RET
// export function PrepareNature ( forest ) ; var i ; begin
 704: LD_INT 0
 706: PPUSH
 707: PPUSH
// SpawnApeman ( forest , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
 708: LD_VAR 0 1
 712: PPUSH
 713: LD_INT 3
 715: PUSH
 716: LD_INT 3
 718: PUSH
 719: LD_INT 2
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_OWVAR 67
 731: ARRAY
 732: PPUSH
 733: CALL 567 0 2
// for i := 1 to 2 do
 737: LD_ADDR_VAR 0 3
 741: PUSH
 742: DOUBLE
 743: LD_INT 1
 745: DEC
 746: ST_TO_ADDR
 747: LD_INT 2
 749: PUSH
 750: FOR_TO
 751: IFFALSE 788
// begin hc_class := 21 ;
 753: LD_ADDR_OWVAR 28
 757: PUSH
 758: LD_INT 21
 760: ST_TO_ADDR
// hc_gallery :=  ;
 761: LD_ADDR_OWVAR 33
 765: PUSH
 766: LD_STRING 
 768: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 769: CALL_OW 44
 773: PPUSH
 774: LD_VAR 0 1
 778: PPUSH
 779: LD_INT 0
 781: PPUSH
 782: CALL_OW 49
// end ;
 786: GO 750
 788: POP
 789: POP
// for i := 1 to 2 do
 790: LD_ADDR_VAR 0 3
 794: PUSH
 795: DOUBLE
 796: LD_INT 1
 798: DEC
 799: ST_TO_ADDR
 800: LD_INT 2
 802: PUSH
 803: FOR_TO
 804: IFFALSE 841
// begin hc_class := 18 ;
 806: LD_ADDR_OWVAR 28
 810: PUSH
 811: LD_INT 18
 813: ST_TO_ADDR
// hc_gallery :=  ;
 814: LD_ADDR_OWVAR 33
 818: PUSH
 819: LD_STRING 
 821: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 822: CALL_OW 44
 826: PPUSH
 827: LD_VAR 0 1
 831: PPUSH
 832: LD_INT 0
 834: PPUSH
 835: CALL_OW 49
// end ;
 839: GO 803
 841: POP
 842: POP
// for i := 1 to 2 do
 843: LD_ADDR_VAR 0 3
 847: PUSH
 848: DOUBLE
 849: LD_INT 1
 851: DEC
 852: ST_TO_ADDR
 853: LD_INT 2
 855: PUSH
 856: FOR_TO
 857: IFFALSE 894
// begin hc_class := 13 ;
 859: LD_ADDR_OWVAR 28
 863: PUSH
 864: LD_INT 13
 866: ST_TO_ADDR
// hc_gallery :=  ;
 867: LD_ADDR_OWVAR 33
 871: PUSH
 872: LD_STRING 
 874: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 875: CALL_OW 44
 879: PPUSH
 880: LD_VAR 0 1
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// end ;
 892: GO 856
 894: POP
 895: POP
// end ;
 896: LD_VAR 0 2
 900: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 901: LD_INT 0
 903: PPUSH
 904: PPUSH
 905: PPUSH
// if not observer or not unit then
 906: LD_VAR 0 1
 910: NOT
 911: PUSH
 912: LD_VAR 0 2
 916: NOT
 917: OR
 918: IFFALSE 922
// exit ;
 920: GO 970
// if not See ( GetSide ( observer ) , unit ) then
 922: LD_VAR 0 1
 926: PPUSH
 927: CALL_OW 255
 931: PPUSH
 932: LD_VAR 0 2
 936: PPUSH
 937: CALL_OW 292
 941: NOT
 942: IFFALSE 946
// exit ;
 944: GO 970
// result := GetDistUnits ( observer , unit ) < 12 ;
 946: LD_ADDR_VAR 0 3
 950: PUSH
 951: LD_VAR 0 1
 955: PPUSH
 956: LD_VAR 0 2
 960: PPUSH
 961: CALL_OW 296
 965: PUSH
 966: LD_INT 12
 968: LESS
 969: ST_TO_ADDR
// end ;
 970: LD_VAR 0 3
 974: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 975: LD_INT 0
 977: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 978: LD_VAR 0 2
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: LD_VAR 0 2
 991: PUSH
 992: LD_INT 2
 994: ARRAY
 995: PPUSH
 996: CALL_OW 488
1000: PUSH
1001: LD_VAR 0 2
1005: PUSH
1006: LD_INT 1
1008: ARRAY
1009: PPUSH
1010: LD_VAR 0 2
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 428
1023: PUSH
1024: LD_INT 0
1026: EQUAL
1027: AND
1028: IFFALSE 1062
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
1030: LD_VAR 0 1
1034: PPUSH
1035: LD_VAR 0 2
1039: PUSH
1040: LD_INT 1
1042: ARRAY
1043: PPUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_INT 2
1051: ARRAY
1052: PPUSH
1053: LD_VAR 0 3
1057: PPUSH
1058: CALL_OW 48
// end ;
1062: LD_VAR 0 4
1066: RET
// export function Video ( mode ) ; begin
1067: LD_INT 0
1069: PPUSH
// ingame_video = mode ;
1070: LD_ADDR_OWVAR 52
1074: PUSH
1075: LD_VAR 0 1
1079: ST_TO_ADDR
// interface_hidden = mode ;
1080: LD_ADDR_OWVAR 54
1084: PUSH
1085: LD_VAR 0 1
1089: ST_TO_ADDR
// end ;
1090: LD_VAR 0 2
1094: RET
// export function ReverseArray ( array ) ; var i ; begin
1095: LD_INT 0
1097: PPUSH
1098: PPUSH
// if not array then
1099: LD_VAR 0 1
1103: NOT
1104: IFFALSE 1108
// exit ;
1106: GO 1166
// result := [ ] ;
1108: LD_ADDR_VAR 0 2
1112: PUSH
1113: EMPTY
1114: ST_TO_ADDR
// for i := 1 to array do
1115: LD_ADDR_VAR 0 3
1119: PUSH
1120: DOUBLE
1121: LD_INT 1
1123: DEC
1124: ST_TO_ADDR
1125: LD_VAR 0 1
1129: PUSH
1130: FOR_TO
1131: IFFALSE 1164
// result := Insert ( result , 1 , array [ i ] ) ;
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 2
1142: PPUSH
1143: LD_INT 1
1145: PPUSH
1146: LD_VAR 0 1
1150: PUSH
1151: LD_VAR 0 3
1155: ARRAY
1156: PPUSH
1157: CALL_OW 2
1161: ST_TO_ADDR
1162: GO 1130
1164: POP
1165: POP
// end ;
1166: LD_VAR 0 2
1170: RET
// export function ComExit ( unit ) ; begin
1171: LD_INT 0
1173: PPUSH
// result := IsInUnit ( unit ) ;
1174: LD_ADDR_VAR 0 2
1178: PUSH
1179: LD_VAR 0 1
1183: PPUSH
1184: CALL_OW 310
1188: ST_TO_ADDR
// if not result then
1189: LD_VAR 0 2
1193: NOT
1194: IFFALSE 1198
// exit ;
1196: GO 1233
// if GetType ( result ) = unit_vehicle then
1198: LD_VAR 0 2
1202: PPUSH
1203: CALL_OW 247
1207: PUSH
1208: LD_INT 2
1210: EQUAL
1211: IFFALSE 1224
// ComExitVehicle ( unit ) else
1213: LD_VAR 0 1
1217: PPUSH
1218: CALL_OW 121
1222: GO 1233
// ComExitBuilding ( unit ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: CALL_OW 122
// end ;
1233: LD_VAR 0 2
1237: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1238: LD_INT 0
1240: PPUSH
1241: PPUSH
// if not side or not nation then
1242: LD_VAR 0 1
1246: NOT
1247: PUSH
1248: LD_VAR 0 2
1252: NOT
1253: OR
1254: IFFALSE 1258
// exit ;
1256: GO 2022
// case nation of nation_american :
1258: LD_VAR 0 2
1262: PUSH
1263: LD_INT 1
1265: DOUBLE
1266: EQUAL
1267: IFTRUE 1271
1269: GO 1485
1271: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1272: LD_ADDR_VAR 0 4
1276: PUSH
1277: LD_INT 35
1279: PUSH
1280: LD_INT 45
1282: PUSH
1283: LD_INT 46
1285: PUSH
1286: LD_INT 47
1288: PUSH
1289: LD_INT 82
1291: PUSH
1292: LD_INT 83
1294: PUSH
1295: LD_INT 84
1297: PUSH
1298: LD_INT 85
1300: PUSH
1301: LD_INT 86
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: LD_INT 2
1309: PUSH
1310: LD_INT 6
1312: PUSH
1313: LD_INT 15
1315: PUSH
1316: LD_INT 16
1318: PUSH
1319: LD_INT 7
1321: PUSH
1322: LD_INT 12
1324: PUSH
1325: LD_INT 13
1327: PUSH
1328: LD_INT 10
1330: PUSH
1331: LD_INT 14
1333: PUSH
1334: LD_INT 20
1336: PUSH
1337: LD_INT 21
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_INT 25
1345: PUSH
1346: LD_INT 32
1348: PUSH
1349: LD_INT 27
1351: PUSH
1352: LD_INT 36
1354: PUSH
1355: LD_INT 69
1357: PUSH
1358: LD_INT 39
1360: PUSH
1361: LD_INT 34
1363: PUSH
1364: LD_INT 40
1366: PUSH
1367: LD_INT 48
1369: PUSH
1370: LD_INT 49
1372: PUSH
1373: LD_INT 50
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 52
1381: PUSH
1382: LD_INT 53
1384: PUSH
1385: LD_INT 54
1387: PUSH
1388: LD_INT 55
1390: PUSH
1391: LD_INT 56
1393: PUSH
1394: LD_INT 57
1396: PUSH
1397: LD_INT 58
1399: PUSH
1400: LD_INT 59
1402: PUSH
1403: LD_INT 60
1405: PUSH
1406: LD_INT 61
1408: PUSH
1409: LD_INT 62
1411: PUSH
1412: LD_INT 80
1414: PUSH
1415: LD_INT 82
1417: PUSH
1418: LD_INT 83
1420: PUSH
1421: LD_INT 84
1423: PUSH
1424: LD_INT 85
1426: PUSH
1427: LD_INT 86
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: ST_TO_ADDR
1483: GO 1946
1485: LD_INT 2
1487: DOUBLE
1488: EQUAL
1489: IFTRUE 1493
1491: GO 1715
1493: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_INT 35
1501: PUSH
1502: LD_INT 45
1504: PUSH
1505: LD_INT 46
1507: PUSH
1508: LD_INT 47
1510: PUSH
1511: LD_INT 82
1513: PUSH
1514: LD_INT 83
1516: PUSH
1517: LD_INT 84
1519: PUSH
1520: LD_INT 85
1522: PUSH
1523: LD_INT 87
1525: PUSH
1526: LD_INT 70
1528: PUSH
1529: LD_INT 1
1531: PUSH
1532: LD_INT 11
1534: PUSH
1535: LD_INT 3
1537: PUSH
1538: LD_INT 4
1540: PUSH
1541: LD_INT 5
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: LD_INT 15
1549: PUSH
1550: LD_INT 18
1552: PUSH
1553: LD_INT 7
1555: PUSH
1556: LD_INT 17
1558: PUSH
1559: LD_INT 8
1561: PUSH
1562: LD_INT 20
1564: PUSH
1565: LD_INT 21
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: LD_INT 72
1573: PUSH
1574: LD_INT 26
1576: PUSH
1577: LD_INT 69
1579: PUSH
1580: LD_INT 39
1582: PUSH
1583: LD_INT 40
1585: PUSH
1586: LD_INT 41
1588: PUSH
1589: LD_INT 42
1591: PUSH
1592: LD_INT 43
1594: PUSH
1595: LD_INT 48
1597: PUSH
1598: LD_INT 49
1600: PUSH
1601: LD_INT 50
1603: PUSH
1604: LD_INT 51
1606: PUSH
1607: LD_INT 52
1609: PUSH
1610: LD_INT 53
1612: PUSH
1613: LD_INT 54
1615: PUSH
1616: LD_INT 55
1618: PUSH
1619: LD_INT 56
1621: PUSH
1622: LD_INT 60
1624: PUSH
1625: LD_INT 61
1627: PUSH
1628: LD_INT 62
1630: PUSH
1631: LD_INT 66
1633: PUSH
1634: LD_INT 67
1636: PUSH
1637: LD_INT 68
1639: PUSH
1640: LD_INT 81
1642: PUSH
1643: LD_INT 82
1645: PUSH
1646: LD_INT 83
1648: PUSH
1649: LD_INT 84
1651: PUSH
1652: LD_INT 85
1654: PUSH
1655: LD_INT 87
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: LIST
1711: LIST
1712: ST_TO_ADDR
1713: GO 1946
1715: LD_INT 3
1717: DOUBLE
1718: EQUAL
1719: IFTRUE 1723
1721: GO 1945
1723: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_INT 46
1731: PUSH
1732: LD_INT 47
1734: PUSH
1735: LD_INT 1
1737: PUSH
1738: LD_INT 2
1740: PUSH
1741: LD_INT 82
1743: PUSH
1744: LD_INT 83
1746: PUSH
1747: LD_INT 84
1749: PUSH
1750: LD_INT 85
1752: PUSH
1753: LD_INT 86
1755: PUSH
1756: LD_INT 11
1758: PUSH
1759: LD_INT 9
1761: PUSH
1762: LD_INT 20
1764: PUSH
1765: LD_INT 19
1767: PUSH
1768: LD_INT 21
1770: PUSH
1771: LD_INT 24
1773: PUSH
1774: LD_INT 22
1776: PUSH
1777: LD_INT 25
1779: PUSH
1780: LD_INT 28
1782: PUSH
1783: LD_INT 29
1785: PUSH
1786: LD_INT 30
1788: PUSH
1789: LD_INT 31
1791: PUSH
1792: LD_INT 37
1794: PUSH
1795: LD_INT 38
1797: PUSH
1798: LD_INT 32
1800: PUSH
1801: LD_INT 27
1803: PUSH
1804: LD_INT 33
1806: PUSH
1807: LD_INT 69
1809: PUSH
1810: LD_INT 39
1812: PUSH
1813: LD_INT 34
1815: PUSH
1816: LD_INT 40
1818: PUSH
1819: LD_INT 71
1821: PUSH
1822: LD_INT 23
1824: PUSH
1825: LD_INT 44
1827: PUSH
1828: LD_INT 48
1830: PUSH
1831: LD_INT 49
1833: PUSH
1834: LD_INT 50
1836: PUSH
1837: LD_INT 51
1839: PUSH
1840: LD_INT 52
1842: PUSH
1843: LD_INT 53
1845: PUSH
1846: LD_INT 54
1848: PUSH
1849: LD_INT 55
1851: PUSH
1852: LD_INT 56
1854: PUSH
1855: LD_INT 57
1857: PUSH
1858: LD_INT 58
1860: PUSH
1861: LD_INT 59
1863: PUSH
1864: LD_INT 63
1866: PUSH
1867: LD_INT 64
1869: PUSH
1870: LD_INT 65
1872: PUSH
1873: LD_INT 82
1875: PUSH
1876: LD_INT 83
1878: PUSH
1879: LD_INT 84
1881: PUSH
1882: LD_INT 85
1884: PUSH
1885: LD_INT 86
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: ST_TO_ADDR
1943: GO 1946
1945: POP
// if state > - 1 and state < 3 then
1946: LD_VAR 0 3
1950: PUSH
1951: LD_INT 1
1953: NEG
1954: GREATER
1955: PUSH
1956: LD_VAR 0 3
1960: PUSH
1961: LD_INT 3
1963: LESS
1964: AND
1965: IFFALSE 2022
// for i in result do
1967: LD_ADDR_VAR 0 5
1971: PUSH
1972: LD_VAR 0 4
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2020
// if GetTech ( i , side ) <> state then
1980: LD_VAR 0 5
1984: PPUSH
1985: LD_VAR 0 1
1989: PPUSH
1990: CALL_OW 321
1994: PUSH
1995: LD_VAR 0 3
1999: NONEQUAL
2000: IFFALSE 2018
// result := result diff i ;
2002: LD_ADDR_VAR 0 4
2006: PUSH
2007: LD_VAR 0 4
2011: PUSH
2012: LD_VAR 0 5
2016: DIFF
2017: ST_TO_ADDR
2018: GO 1977
2020: POP
2021: POP
// end ;
2022: LD_VAR 0 4
2026: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
2027: LD_INT 0
2029: PPUSH
2030: PPUSH
2031: PPUSH
2032: PPUSH
// if not list then
2033: LD_VAR 0 3
2037: NOT
2038: IFFALSE 2042
// exit ;
2040: GO 2350
// result := [ ] ;
2042: LD_ADDR_VAR 0 5
2046: PUSH
2047: EMPTY
2048: ST_TO_ADDR
// for i in list do
2049: LD_ADDR_VAR 0 6
2053: PUSH
2054: LD_VAR 0 3
2058: PUSH
2059: FOR_IN
2060: IFFALSE 2262
// begin tmp := GetDistUnitXY ( i , x , y ) ;
2062: LD_ADDR_VAR 0 8
2066: PUSH
2067: LD_VAR 0 6
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: LD_VAR 0 2
2081: PPUSH
2082: CALL_OW 297
2086: ST_TO_ADDR
// if not result then
2087: LD_VAR 0 5
2091: NOT
2092: IFFALSE 2118
// result := [ [ i , tmp ] ] else
2094: LD_ADDR_VAR 0 5
2098: PUSH
2099: LD_VAR 0 6
2103: PUSH
2104: LD_VAR 0 8
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: EMPTY
2114: LIST
2115: ST_TO_ADDR
2116: GO 2260
// begin if result [ result ] [ 2 ] < tmp then
2118: LD_VAR 0 5
2122: PUSH
2123: LD_VAR 0 5
2127: ARRAY
2128: PUSH
2129: LD_INT 2
2131: ARRAY
2132: PUSH
2133: LD_VAR 0 8
2137: LESS
2138: IFFALSE 2180
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
2140: LD_ADDR_VAR 0 5
2144: PUSH
2145: LD_VAR 0 5
2149: PPUSH
2150: LD_VAR 0 5
2154: PUSH
2155: LD_INT 1
2157: PLUS
2158: PPUSH
2159: LD_VAR 0 6
2163: PUSH
2164: LD_VAR 0 8
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PPUSH
2173: CALL_OW 2
2177: ST_TO_ADDR
2178: GO 2260
// for j = 1 to result do
2180: LD_ADDR_VAR 0 7
2184: PUSH
2185: DOUBLE
2186: LD_INT 1
2188: DEC
2189: ST_TO_ADDR
2190: LD_VAR 0 5
2194: PUSH
2195: FOR_TO
2196: IFFALSE 2258
// begin if tmp < result [ j ] [ 2 ] then
2198: LD_VAR 0 8
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_VAR 0 7
2212: ARRAY
2213: PUSH
2214: LD_INT 2
2216: ARRAY
2217: LESS
2218: IFFALSE 2256
// begin result := Insert ( result , j , [ i , tmp ] ) ;
2220: LD_ADDR_VAR 0 5
2224: PUSH
2225: LD_VAR 0 5
2229: PPUSH
2230: LD_VAR 0 7
2234: PPUSH
2235: LD_VAR 0 6
2239: PUSH
2240: LD_VAR 0 8
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PPUSH
2249: CALL_OW 2
2253: ST_TO_ADDR
// break ;
2254: GO 2258
// end ; end ;
2256: GO 2195
2258: POP
2259: POP
// end ; end ;
2260: GO 2059
2262: POP
2263: POP
// if result and not asc then
2264: LD_VAR 0 5
2268: PUSH
2269: LD_VAR 0 4
2273: NOT
2274: AND
2275: IFFALSE 2350
// begin tmp := result ;
2277: LD_ADDR_VAR 0 8
2281: PUSH
2282: LD_VAR 0 5
2286: ST_TO_ADDR
// for i = tmp downto 1 do
2287: LD_ADDR_VAR 0 6
2291: PUSH
2292: DOUBLE
2293: LD_VAR 0 8
2297: INC
2298: ST_TO_ADDR
2299: LD_INT 1
2301: PUSH
2302: FOR_DOWNTO
2303: IFFALSE 2348
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PPUSH
2315: LD_VAR 0 8
2319: PUSH
2320: LD_VAR 0 6
2324: MINUS
2325: PUSH
2326: LD_INT 1
2328: PLUS
2329: PPUSH
2330: LD_VAR 0 8
2334: PUSH
2335: LD_VAR 0 6
2339: ARRAY
2340: PPUSH
2341: CALL_OW 1
2345: ST_TO_ADDR
2346: GO 2302
2348: POP
2349: POP
// end ; end ;
2350: LD_VAR 0 5
2354: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
2355: LD_INT 0
2357: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
2358: LD_ADDR_VAR 0 4
2362: PUSH
2363: LD_VAR 0 1
2367: PPUSH
2368: CALL_OW 250
2372: PPUSH
2373: LD_VAR 0 1
2377: PPUSH
2378: CALL_OW 251
2382: PPUSH
2383: LD_VAR 0 2
2387: PPUSH
2388: LD_VAR 0 3
2392: PPUSH
2393: CALL 2027 0 4
2397: ST_TO_ADDR
// end ;
2398: LD_VAR 0 4
2402: RET
// export function NearestEmptyBuilding ( unit , btype ) ; var side , tmp , i , places ; begin
2403: LD_INT 0
2405: PPUSH
2406: PPUSH
2407: PPUSH
2408: PPUSH
2409: PPUSH
// if not unit then
2410: LD_VAR 0 1
2414: NOT
2415: IFFALSE 2419
// exit ;
2417: GO 2621
// side := GetSide ( unit ) ;
2419: LD_ADDR_VAR 0 4
2423: PUSH
2424: LD_VAR 0 1
2428: PPUSH
2429: CALL_OW 255
2433: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
2434: LD_ADDR_VAR 0 5
2438: PUSH
2439: LD_INT 22
2441: PUSH
2442: LD_VAR 0 4
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: PUSH
2451: LD_INT 30
2453: PUSH
2454: LD_VAR 0 2
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PPUSH
2467: CALL_OW 69
2471: ST_TO_ADDR
// if not tmp then
2472: LD_VAR 0 5
2476: NOT
2477: IFFALSE 2481
// exit ;
2479: GO 2621
// tmp := SortByDistanceUnit ( unit , tmp , true ) ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 1
2490: PPUSH
2491: LD_VAR 0 5
2495: PPUSH
2496: LD_INT 1
2498: PPUSH
2499: CALL 2355 0 3
2503: ST_TO_ADDR
// places := 1 ;
2504: LD_ADDR_VAR 0 7
2508: PUSH
2509: LD_INT 1
2511: ST_TO_ADDR
// if btype in [ b_depot , b_warehouse , b_armoury , b_barracks , b_workshop , b_factory , b_lab , b_lab_half , b_lab_full ] then
2512: LD_VAR 0 2
2516: PUSH
2517: LD_INT 0
2519: PUSH
2520: LD_INT 1
2522: PUSH
2523: LD_INT 4
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: LD_INT 2
2531: PUSH
2532: LD_INT 3
2534: PUSH
2535: LD_INT 6
2537: PUSH
2538: LD_INT 7
2540: PUSH
2541: LD_INT 8
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: LIST
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: IN
2555: IFFALSE 2565
// places := 6 ;
2557: LD_ADDR_VAR 0 7
2561: PUSH
2562: LD_INT 6
2564: ST_TO_ADDR
// for i in tmp do
2565: LD_ADDR_VAR 0 6
2569: PUSH
2570: LD_VAR 0 5
2574: PUSH
2575: FOR_IN
2576: IFFALSE 2619
// begin if UnitsInside ( i ) - places <= 0 then
2578: LD_VAR 0 6
2582: PPUSH
2583: CALL_OW 313
2587: PUSH
2588: LD_VAR 0 7
2592: MINUS
2593: PUSH
2594: LD_INT 0
2596: LESSEQUAL
2597: IFFALSE 2603
// continue else
2599: GO 2575
2601: GO 2617
// begin result := i ;
2603: LD_ADDR_VAR 0 3
2607: PUSH
2608: LD_VAR 0 6
2612: ST_TO_ADDR
// exit ;
2613: POP
2614: POP
2615: GO 2621
// end ; end ;
2617: GO 2575
2619: POP
2620: POP
// end ; end_of_file
2621: LD_VAR 0 3
2625: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Shariff , Kurt , Aviradze , heikeSecondSquad , heikeVehicles , heikeApes ; export function PrepareArabian ; var i ; begin
2626: LD_INT 0
2628: PPUSH
2629: PPUSH
// uc_side := 2 ;
2630: LD_ADDR_OWVAR 20
2634: PUSH
2635: LD_INT 2
2637: ST_TO_ADDR
// uc_nation := 2 ;
2638: LD_ADDR_OWVAR 21
2642: PUSH
2643: LD_INT 2
2645: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2646: LD_ADDR_EXP 18
2650: PUSH
2651: LD_STRING Heike
2653: PPUSH
2654: LD_EXP 1
2658: NOT
2659: PPUSH
2660: LD_EXP 2
2664: PPUSH
2665: CALL 336 0 3
2669: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
2670: LD_ADDR_EXP 21
2674: PUSH
2675: LD_STRING Ibrahim
2677: PPUSH
2678: LD_EXP 1
2682: NOT
2683: PPUSH
2684: LD_EXP 2
2688: PPUSH
2689: CALL 336 0 3
2693: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2694: LD_ADDR_EXP 19
2698: PUSH
2699: LD_STRING Givi
2701: PPUSH
2702: LD_EXP 1
2706: NOT
2707: PPUSH
2708: LD_EXP 2
2712: PPUSH
2713: CALL 336 0 3
2717: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2718: LD_ADDR_EXP 22
2722: PUSH
2723: LD_STRING Kamil
2725: PPUSH
2726: LD_EXP 1
2730: NOT
2731: PPUSH
2732: LD_EXP 2
2736: PPUSH
2737: CALL 336 0 3
2741: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2742: LD_ADDR_EXP 23
2746: PUSH
2747: LD_STRING Kaia
2749: PPUSH
2750: LD_EXP 1
2754: NOT
2755: PPUSH
2756: LD_EXP 2
2760: PPUSH
2761: CALL 336 0 3
2765: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2766: LD_ADDR_EXP 24
2770: PUSH
2771: LD_STRING Sophia
2773: PPUSH
2774: LD_EXP 1
2778: NOT
2779: PPUSH
2780: LD_EXP 2
2784: PPUSH
2785: CALL 336 0 3
2789: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2790: LD_ADDR_EXP 25
2794: PUSH
2795: LD_STRING Markov
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_EXP 2
2808: PPUSH
2809: CALL 336 0 3
2813: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2814: LD_ADDR_EXP 28
2818: PUSH
2819: LD_STRING Aviradze
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_EXP 2
2832: PPUSH
2833: CALL 336 0 3
2837: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , ( not debug ) , prefix ) ;
2838: LD_ADDR_EXP 27
2842: PUSH
2843: LD_STRING Kurt
2845: PPUSH
2846: LD_EXP 1
2850: NOT
2851: PPUSH
2852: LD_EXP 2
2856: PPUSH
2857: CALL 336 0 3
2861: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2862: LD_ADDR_EXP 20
2866: PUSH
2867: LD_STRING Mike
2869: PPUSH
2870: LD_EXP 1
2874: NOT
2875: PPUSH
2876: LD_EXP 2
2880: PPUSH
2881: CALL 336 0 3
2885: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_1_others ) ;
2886: LD_ADDR_EXP 29
2890: PUSH
2891: LD_STRING 04_1_others
2893: PPUSH
2894: CALL_OW 31
2898: ST_TO_ADDR
// heikeApes := CreateCharacterSet ( 04_1_apes ) ;
2899: LD_ADDR_EXP 31
2903: PUSH
2904: LD_STRING 04_1_apes
2906: PPUSH
2907: CALL_OW 31
2911: ST_TO_ADDR
// heikeVehicles := LoadVariable ( 04_1_Vehicles , [ ] ) ;
2912: LD_ADDR_EXP 30
2916: PUSH
2917: LD_STRING 04_1_Vehicles
2919: PPUSH
2920: EMPTY
2921: PPUSH
2922: CALL_OW 30
2926: ST_TO_ADDR
// uc_side := 5 ;
2927: LD_ADDR_OWVAR 20
2931: PUSH
2932: LD_INT 5
2934: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
2935: LD_ADDR_EXP 26
2939: PUSH
2940: LD_STRING Abdul
2942: PPUSH
2943: LD_INT 0
2945: PPUSH
2946: LD_STRING 
2948: PPUSH
2949: CALL 336 0 3
2953: ST_TO_ADDR
// end ;
2954: LD_VAR 0 1
2958: RET
// export cargoDriver ; every 2 2$00 trigger LoadVariable ( 04_1_KaganCaptured , 0 ) and not FilterAllUnits ( [ f_side , 5 ] ) and ( HexInfo ( 124 , 26 ) = 0 xor GetSide ( HexInfo ( 124 , 26 ) ) = 2 ) do var veh ;
2959: LD_STRING 04_1_KaganCaptured
2961: PPUSH
2962: LD_INT 0
2964: PPUSH
2965: CALL_OW 30
2969: PUSH
2970: LD_INT 22
2972: PUSH
2973: LD_INT 5
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: PPUSH
2980: CALL_OW 69
2984: NOT
2985: AND
2986: PUSH
2987: LD_INT 124
2989: PPUSH
2990: LD_INT 26
2992: PPUSH
2993: CALL_OW 428
2997: PUSH
2998: LD_INT 0
3000: EQUAL
3001: PUSH
3002: LD_INT 124
3004: PPUSH
3005: LD_INT 26
3007: PPUSH
3008: CALL_OW 428
3012: PPUSH
3013: CALL_OW 255
3017: PUSH
3018: LD_INT 2
3020: EQUAL
3021: XOR
3022: AND
3023: IFFALSE 3271
3025: GO 3027
3027: DISABLE
3028: LD_INT 0
3030: PPUSH
// begin enable ;
3031: ENABLE
// uc_side := 5 ;
3032: LD_ADDR_OWVAR 20
3036: PUSH
3037: LD_INT 5
3039: ST_TO_ADDR
// uc_nation := 2 ;
3040: LD_ADDR_OWVAR 21
3044: PUSH
3045: LD_INT 2
3047: ST_TO_ADDR
// PrepareTank ( 5 , 2 , ar_medium_trike , engine_solar , control_manual , ar_cargo_bay , 70 ) ;
3048: LD_INT 5
3050: PPUSH
3051: LD_INT 2
3053: PPUSH
3054: LD_INT 13
3056: PPUSH
3057: LD_INT 2
3059: PPUSH
3060: LD_INT 1
3062: PPUSH
3063: LD_INT 32
3065: PPUSH
3066: LD_INT 70
3068: PPUSH
3069: CALL 399 0 7
// veh := CreateVehicle ;
3073: LD_ADDR_VAR 0 1
3077: PUSH
3078: CALL_OW 45
3082: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3083: LD_VAR 0 1
3087: PPUSH
3088: LD_INT 3
3090: PPUSH
3091: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
3095: LD_VAR 0 1
3099: PPUSH
3100: LD_INT 8
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 49
// if not cargoDriver then
3110: LD_EXP 32
3114: NOT
3115: IFFALSE 3140
// begin PrepareHuman ( false , 1 , 3 ) ;
3117: LD_INT 0
3119: PPUSH
3120: LD_INT 1
3122: PPUSH
3123: LD_INT 3
3125: PPUSH
3126: CALL_OW 380
// cargoDriver := CreateHuman ;
3130: LD_ADDR_EXP 32
3134: PUSH
3135: CALL_OW 44
3139: ST_TO_ADDR
// end ; PlaceHumanInUnit ( cargoDriver , veh ) ;
3140: LD_EXP 32
3144: PPUSH
3145: LD_VAR 0 1
3149: PPUSH
3150: CALL_OW 52
// SetCargo ( veh , mat_oil , 100 ) ;
3154: LD_VAR 0 1
3158: PPUSH
3159: LD_INT 2
3161: PPUSH
3162: LD_INT 100
3164: PPUSH
3165: CALL_OW 290
// ComMoveXY ( veh , 142 , 15 ) ;
3169: LD_VAR 0 1
3173: PPUSH
3174: LD_INT 142
3176: PPUSH
3177: LD_INT 15
3179: PPUSH
3180: CALL_OW 111
// AddComUnload ( veh ) ;
3184: LD_VAR 0 1
3188: PPUSH
3189: CALL_OW 219
// AddComMoveXY ( veh , 133 , 2 ) ;
3193: LD_VAR 0 1
3197: PPUSH
3198: LD_INT 133
3200: PPUSH
3201: LD_INT 2
3203: PPUSH
3204: CALL_OW 171
// wait ( 0 0$5 ) ;
3208: LD_INT 175
3210: PPUSH
3211: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
3215: LD_INT 35
3217: PPUSH
3218: CALL_OW 67
// until IsAt ( veh , 133 , 2 ) or IsInArea ( veh , spawnArea ) ;
3222: LD_VAR 0 1
3226: PPUSH
3227: LD_INT 133
3229: PPUSH
3230: LD_INT 2
3232: PPUSH
3233: CALL_OW 307
3237: PUSH
3238: LD_VAR 0 1
3242: PPUSH
3243: LD_INT 8
3245: PPUSH
3246: CALL_OW 308
3250: OR
3251: IFFALSE 3215
// RemoveUnit ( cargoDriver ) ;
3253: LD_EXP 32
3257: PPUSH
3258: CALL_OW 64
// RemoveUnit ( veh ) ;
3262: LD_VAR 0 1
3266: PPUSH
3267: CALL_OW 64
// end ; end_of_file
3271: PPOPN 1
3273: END
// export Burlak , Gaidar , Kuzmov ; export ruForce , ruEng , ruMech , ruSci , ruMobile ; export ruSol ; export function PrepareRussian ; var base , blist , i , b , un , tmp , fac , oil ; begin
3274: LD_INT 0
3276: PPUSH
3277: PPUSH
3278: PPUSH
3279: PPUSH
3280: PPUSH
3281: PPUSH
3282: PPUSH
3283: PPUSH
3284: PPUSH
// uc_side := 3 ;
3285: LD_ADDR_OWVAR 20
3289: PUSH
3290: LD_INT 3
3292: ST_TO_ADDR
// uc_nation := 3 ;
3293: LD_ADDR_OWVAR 21
3297: PUSH
3298: LD_INT 3
3300: ST_TO_ADDR
// ruForce := [ ] ;
3301: LD_ADDR_EXP 36
3305: PUSH
3306: EMPTY
3307: ST_TO_ADDR
// ruMech := [ ] ;
3308: LD_ADDR_EXP 38
3312: PUSH
3313: EMPTY
3314: ST_TO_ADDR
// ruEng := [ ] ;
3315: LD_ADDR_EXP 37
3319: PUSH
3320: EMPTY
3321: ST_TO_ADDR
// ruSci := [ ] ;
3322: LD_ADDR_EXP 39
3326: PUSH
3327: EMPTY
3328: ST_TO_ADDR
// ruMobile := [ ] ;
3329: LD_ADDR_EXP 40
3333: PUSH
3334: EMPTY
3335: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ,  ) ;
3336: LD_ADDR_EXP 33
3340: PUSH
3341: LD_STRING Burlak
3343: PPUSH
3344: LD_INT 0
3346: PPUSH
3347: LD_STRING 
3349: PPUSH
3350: CALL 336 0 3
3354: ST_TO_ADDR
// Gaidar := PrepareUnit ( Gaydar , false ,  ) ;
3355: LD_ADDR_EXP 34
3359: PUSH
3360: LD_STRING Gaydar
3362: PPUSH
3363: LD_INT 0
3365: PPUSH
3366: LD_STRING 
3368: PPUSH
3369: CALL 336 0 3
3373: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , false ,  ) ;
3374: LD_ADDR_EXP 35
3378: PUSH
3379: LD_STRING Kuzmov
3381: PPUSH
3382: LD_INT 0
3384: PPUSH
3385: LD_STRING 
3387: PPUSH
3388: CALL 336 0 3
3392: ST_TO_ADDR
// PlaceHumanInUnit ( Kuzmov , ruMainBase ) ;
3393: LD_EXP 35
3397: PPUSH
3398: LD_INT 200
3400: PPUSH
3401: CALL_OW 52
// SetBName ( ruMainBase , chuikov ) ;
3405: LD_INT 200
3407: PPUSH
3408: LD_STRING chuikov
3410: PPUSH
3411: CALL_OW 500
// SetResourceType ( GetBase ( ruMainBase ) , mat_cans , [ 800 , 1000 , 1250 ] [ Difficulty ] ) ;
3415: LD_INT 200
3417: PPUSH
3418: CALL_OW 274
3422: PPUSH
3423: LD_INT 1
3425: PPUSH
3426: LD_INT 800
3428: PUSH
3429: LD_INT 1000
3431: PUSH
3432: LD_INT 1250
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: LIST
3439: PUSH
3440: LD_OWVAR 67
3444: ARRAY
3445: PPUSH
3446: CALL_OW 277
// SetResourceType ( GetBase ( ruMainBase ) , mat_oil , 160 ) ;
3450: LD_INT 200
3452: PPUSH
3453: CALL_OW 274
3457: PPUSH
3458: LD_INT 2
3460: PPUSH
3461: LD_INT 160
3463: PPUSH
3464: CALL_OW 277
// SetResourceType ( GetBase ( ruSecBase ) , mat_cans , 200 ) ;
3468: LD_INT 225
3470: PPUSH
3471: CALL_OW 274
3475: PPUSH
3476: LD_INT 1
3478: PPUSH
3479: LD_INT 200
3481: PPUSH
3482: CALL_OW 277
// oil := 150 ;
3486: LD_ADDR_VAR 0 9
3490: PUSH
3491: LD_INT 150
3493: ST_TO_ADDR
// if gameTime >= [ 45 45$00 , 40 40$00 , 35 35$00 ] [ Difficulty ] then
3494: LD_EXP 5
3498: PUSH
3499: LD_INT 94500
3501: PUSH
3502: LD_INT 84000
3504: PUSH
3505: LD_INT 73500
3507: PUSH
3508: EMPTY
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_OWVAR 67
3517: ARRAY
3518: GREATEREQUAL
3519: IFFALSE 3674
// begin oil := 450 ;
3521: LD_ADDR_VAR 0 9
3525: PUSH
3526: LD_INT 450
3528: ST_TO_ADDR
// tmp := [ [ 123 , 17 , 3 , b_breastwork ] , [ 152 , 38 , 3 , b_breastwork ] , [ 81 , 6 , 4 , b_breastwork ] , [ 113 , 67 , 4 , b_bunker ] ] ;
3529: LD_ADDR_VAR 0 7
3533: PUSH
3534: LD_INT 123
3536: PUSH
3537: LD_INT 17
3539: PUSH
3540: LD_INT 3
3542: PUSH
3543: LD_INT 31
3545: PUSH
3546: EMPTY
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: PUSH
3552: LD_INT 152
3554: PUSH
3555: LD_INT 38
3557: PUSH
3558: LD_INT 3
3560: PUSH
3561: LD_INT 31
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: LIST
3568: LIST
3569: PUSH
3570: LD_INT 81
3572: PUSH
3573: LD_INT 6
3575: PUSH
3576: LD_INT 4
3578: PUSH
3579: LD_INT 31
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: PUSH
3588: LD_INT 113
3590: PUSH
3591: LD_INT 67
3593: PUSH
3594: LD_INT 4
3596: PUSH
3597: LD_INT 32
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: ST_TO_ADDR
// for i in tmp do
3612: LD_ADDR_VAR 0 4
3616: PUSH
3617: LD_VAR 0 7
3621: PUSH
3622: FOR_IN
3623: IFFALSE 3672
// begin bc_type := i [ 4 ] ;
3625: LD_ADDR_OWVAR 42
3629: PUSH
3630: LD_VAR 0 4
3634: PUSH
3635: LD_INT 4
3637: ARRAY
3638: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3639: LD_VAR 0 4
3643: PUSH
3644: LD_INT 1
3646: ARRAY
3647: PPUSH
3648: LD_VAR 0 4
3652: PUSH
3653: LD_INT 2
3655: ARRAY
3656: PPUSH
3657: LD_VAR 0 4
3661: PUSH
3662: LD_INT 3
3664: ARRAY
3665: PPUSH
3666: CALL_OW 47
// end ;
3670: GO 3622
3672: POP
3673: POP
// end ; SetResourceType ( GetBase ( ruSecBase ) , mat_oil , oil ) ;
3674: LD_INT 225
3676: PPUSH
3677: CALL_OW 274
3681: PPUSH
3682: LD_INT 2
3684: PPUSH
3685: LD_VAR 0 9
3689: PPUSH
3690: CALL_OW 277
// if Difficulty > 1 then
3694: LD_OWVAR 67
3698: PUSH
3699: LD_INT 1
3701: GREATER
3702: IFFALSE 3797
// begin bc_type := b_bunker ;
3704: LD_ADDR_OWVAR 42
3708: PUSH
3709: LD_INT 32
3711: ST_TO_ADDR
// tmp := [ [ 121 , 85 , 5 ] , [ 93 , 72 , 1 ] ] ;
3712: LD_ADDR_VAR 0 7
3716: PUSH
3717: LD_INT 121
3719: PUSH
3720: LD_INT 85
3722: PUSH
3723: LD_INT 5
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: LIST
3730: PUSH
3731: LD_INT 93
3733: PUSH
3734: LD_INT 72
3736: PUSH
3737: LD_INT 1
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: LIST
3744: PUSH
3745: EMPTY
3746: LIST
3747: LIST
3748: ST_TO_ADDR
// for i in tmp do
3749: LD_ADDR_VAR 0 4
3753: PUSH
3754: LD_VAR 0 7
3758: PUSH
3759: FOR_IN
3760: IFFALSE 3795
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3762: LD_VAR 0 4
3766: PUSH
3767: LD_INT 1
3769: ARRAY
3770: PPUSH
3771: LD_VAR 0 4
3775: PUSH
3776: LD_INT 2
3778: ARRAY
3779: PPUSH
3780: LD_VAR 0 4
3784: PUSH
3785: LD_INT 3
3787: ARRAY
3788: PPUSH
3789: CALL_OW 47
3793: GO 3759
3795: POP
3796: POP
// end ; base := GetBase ( ruMainBase ) ;
3797: LD_ADDR_VAR 0 2
3801: PUSH
3802: LD_INT 200
3804: PPUSH
3805: CALL_OW 274
3809: ST_TO_ADDR
// blist := GetBuildList ( base ) ;
3810: LD_ADDR_VAR 0 3
3814: PUSH
3815: LD_VAR 0 2
3819: PPUSH
3820: CALL_OW 417
3824: ST_TO_ADDR
// for b in blist do
3825: LD_ADDR_VAR 0 5
3829: PUSH
3830: LD_VAR 0 3
3834: PUSH
3835: FOR_IN
3836: IFFALSE 4287
// begin if b [ 1 ] = b_factory then
3838: LD_VAR 0 5
3842: PUSH
3843: LD_INT 1
3845: ARRAY
3846: PUSH
3847: LD_INT 3
3849: EQUAL
3850: IFFALSE 4001
// begin fac := HexInfo ( b [ 2 ] , b [ 3 ] ) ;
3852: LD_ADDR_VAR 0 8
3856: PUSH
3857: LD_VAR 0 5
3861: PUSH
3862: LD_INT 2
3864: ARRAY
3865: PPUSH
3866: LD_VAR 0 5
3870: PUSH
3871: LD_INT 3
3873: ARRAY
3874: PPUSH
3875: CALL_OW 428
3879: ST_TO_ADDR
// for i := 1 to [ 2 , 2 + Difficulty ] [ ( ruEscapeCounter > 3 ) + 1 ] do
3880: LD_ADDR_VAR 0 4
3884: PUSH
3885: DOUBLE
3886: LD_INT 1
3888: DEC
3889: ST_TO_ADDR
3890: LD_INT 2
3892: PUSH
3893: LD_INT 2
3895: PUSH
3896: LD_OWVAR 67
3900: PLUS
3901: PUSH
3902: EMPTY
3903: LIST
3904: LIST
3905: PUSH
3906: LD_EXP 10
3910: PUSH
3911: LD_INT 3
3913: GREATER
3914: PUSH
3915: LD_INT 1
3917: PLUS
3918: ARRAY
3919: PUSH
3920: FOR_TO
3921: IFFALSE 3997
// begin PrepareHuman ( false , 3 , 1 + Difficulty ) ;
3923: LD_INT 0
3925: PPUSH
3926: LD_INT 3
3928: PPUSH
3929: LD_INT 1
3931: PUSH
3932: LD_OWVAR 67
3936: PLUS
3937: PPUSH
3938: CALL_OW 380
// un := CreateHuman ;
3942: LD_ADDR_VAR 0 6
3946: PUSH
3947: CALL_OW 44
3951: ST_TO_ADDR
// ruMech := Replace ( ruMech , ruMech + 1 , un ) ;
3952: LD_ADDR_EXP 38
3956: PUSH
3957: LD_EXP 38
3961: PPUSH
3962: LD_EXP 38
3966: PUSH
3967: LD_INT 1
3969: PLUS
3970: PPUSH
3971: LD_VAR 0 6
3975: PPUSH
3976: CALL_OW 1
3980: ST_TO_ADDR
// PlaceHumanInUnit ( un , fac ) ;
3981: LD_VAR 0 6
3985: PPUSH
3986: LD_VAR 0 8
3990: PPUSH
3991: CALL_OW 52
// end ;
3995: GO 3920
3997: POP
3998: POP
// end else
3999: GO 4285
// if b [ 1 ] in [ b_lab , b_lab_half , b_lab_full , b_lab_weapon ] then
4001: LD_VAR 0 5
4005: PUSH
4006: LD_INT 1
4008: ARRAY
4009: PUSH
4010: LD_INT 6
4012: PUSH
4013: LD_INT 7
4015: PUSH
4016: LD_INT 8
4018: PUSH
4019: LD_INT 10
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: IN
4028: IFFALSE 4138
// begin for i := 1 to 2 do
4030: LD_ADDR_VAR 0 4
4034: PUSH
4035: DOUBLE
4036: LD_INT 1
4038: DEC
4039: ST_TO_ADDR
4040: LD_INT 2
4042: PUSH
4043: FOR_TO
4044: IFFALSE 4134
// begin PrepareHuman ( false , 4 , Difficulty ) ;
4046: LD_INT 0
4048: PPUSH
4049: LD_INT 4
4051: PPUSH
4052: LD_OWVAR 67
4056: PPUSH
4057: CALL_OW 380
// un := CreateHuman ;
4061: LD_ADDR_VAR 0 6
4065: PUSH
4066: CALL_OW 44
4070: ST_TO_ADDR
// ruSci := Replace ( ruSci , ruSci + 1 , un ) ;
4071: LD_ADDR_EXP 39
4075: PUSH
4076: LD_EXP 39
4080: PPUSH
4081: LD_EXP 39
4085: PUSH
4086: LD_INT 1
4088: PLUS
4089: PPUSH
4090: LD_VAR 0 6
4094: PPUSH
4095: CALL_OW 1
4099: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4100: LD_VAR 0 6
4104: PPUSH
4105: LD_VAR 0 5
4109: PUSH
4110: LD_INT 2
4112: ARRAY
4113: PPUSH
4114: LD_VAR 0 5
4118: PUSH
4119: LD_INT 3
4121: ARRAY
4122: PPUSH
4123: CALL_OW 428
4127: PPUSH
4128: CALL_OW 52
// end ;
4132: GO 4043
4134: POP
4135: POP
// end else
4136: GO 4285
// if b [ 1 ] = b_warehouse then
4138: LD_VAR 0 5
4142: PUSH
4143: LD_INT 1
4145: ARRAY
4146: PUSH
4147: LD_INT 1
4149: EQUAL
4150: IFFALSE 4285
// begin for i := 1 to [ 1 , 1 + Difficulty ] [ ( ruEscapeCounter > 3 ) + 1 ] do
4152: LD_ADDR_VAR 0 4
4156: PUSH
4157: DOUBLE
4158: LD_INT 1
4160: DEC
4161: ST_TO_ADDR
4162: LD_INT 1
4164: PUSH
4165: LD_INT 1
4167: PUSH
4168: LD_OWVAR 67
4172: PLUS
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PUSH
4178: LD_EXP 10
4182: PUSH
4183: LD_INT 3
4185: GREATER
4186: PUSH
4187: LD_INT 1
4189: PLUS
4190: ARRAY
4191: PUSH
4192: FOR_TO
4193: IFFALSE 4283
// begin PrepareHuman ( false , 2 , Difficulty ) ;
4195: LD_INT 0
4197: PPUSH
4198: LD_INT 2
4200: PPUSH
4201: LD_OWVAR 67
4205: PPUSH
4206: CALL_OW 380
// un := CreateHuman ;
4210: LD_ADDR_VAR 0 6
4214: PUSH
4215: CALL_OW 44
4219: ST_TO_ADDR
// ruEng := Replace ( ruEng , ruEng + 1 , un ) ;
4220: LD_ADDR_EXP 37
4224: PUSH
4225: LD_EXP 37
4229: PPUSH
4230: LD_EXP 37
4234: PUSH
4235: LD_INT 1
4237: PLUS
4238: PPUSH
4239: LD_VAR 0 6
4243: PPUSH
4244: CALL_OW 1
4248: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4249: LD_VAR 0 6
4253: PPUSH
4254: LD_VAR 0 5
4258: PUSH
4259: LD_INT 2
4261: ARRAY
4262: PPUSH
4263: LD_VAR 0 5
4267: PUSH
4268: LD_INT 3
4270: ARRAY
4271: PPUSH
4272: CALL_OW 428
4276: PPUSH
4277: CALL_OW 52
// end ;
4281: GO 4192
4283: POP
4284: POP
// end ; end ;
4285: GO 3835
4287: POP
4288: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4289: LD_ADDR_VAR 0 3
4293: PUSH
4294: LD_INT 22
4296: PUSH
4297: LD_INT 3
4299: PUSH
4300: EMPTY
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 21
4306: PUSH
4307: LD_INT 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: EMPTY
4315: LIST
4316: LIST
4317: PPUSH
4318: CALL_OW 69
4322: ST_TO_ADDR
// for b in blist do
4323: LD_ADDR_VAR 0 5
4327: PUSH
4328: LD_VAR 0 3
4332: PUSH
4333: FOR_IN
4334: IFFALSE 4356
// SetBLevel ( b , 3 + Difficulty ) ;
4336: LD_VAR 0 5
4340: PPUSH
4341: LD_INT 3
4343: PUSH
4344: LD_OWVAR 67
4348: PLUS
4349: PPUSH
4350: CALL_OW 241
4354: GO 4333
4356: POP
4357: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4358: LD_ADDR_VAR 0 3
4362: PUSH
4363: LD_INT 22
4365: PUSH
4366: LD_INT 3
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: LD_INT 30
4375: PUSH
4376: LD_INT 32
4378: PUSH
4379: EMPTY
4380: LIST
4381: LIST
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: PPUSH
4387: CALL_OW 69
4391: ST_TO_ADDR
// for b in blist do
4392: LD_ADDR_VAR 0 5
4396: PUSH
4397: LD_VAR 0 3
4401: PUSH
4402: FOR_IN
4403: IFFALSE 4512
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4405: LD_INT 0
4407: PPUSH
4408: LD_INT 1
4410: PPUSH
4411: LD_INT 1
4413: PUSH
4414: LD_OWVAR 67
4418: PLUS
4419: PPUSH
4420: CALL_OW 380
// un := CreateHuman ;
4424: LD_ADDR_VAR 0 6
4428: PUSH
4429: CALL_OW 44
4433: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4434: LD_ADDR_EXP 36
4438: PUSH
4439: LD_EXP 36
4443: PPUSH
4444: LD_EXP 36
4448: PUSH
4449: LD_INT 1
4451: PLUS
4452: PPUSH
4453: LD_VAR 0 6
4457: PPUSH
4458: CALL_OW 1
4462: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4463: LD_VAR 0 6
4467: PPUSH
4468: LD_VAR 0 5
4472: PPUSH
4473: CALL_OW 52
// PlaceWeaponTurret ( b , [ ru_gun , ru_gatling_gun ] [ b mod 2 + 1 ] ) ;
4477: LD_VAR 0 5
4481: PPUSH
4482: LD_INT 44
4484: PUSH
4485: LD_INT 43
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: LD_INT 2
4499: MOD
4500: PUSH
4501: LD_INT 1
4503: PLUS
4504: ARRAY
4505: PPUSH
4506: CALL_OW 431
// end ;
4510: GO 4402
4512: POP
4513: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4514: LD_ADDR_VAR 0 3
4518: PUSH
4519: LD_INT 22
4521: PUSH
4522: LD_INT 3
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: PUSH
4529: LD_INT 30
4531: PUSH
4532: LD_INT 31
4534: PUSH
4535: EMPTY
4536: LIST
4537: LIST
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PPUSH
4543: CALL_OW 69
4547: ST_TO_ADDR
// for b in blist do
4548: LD_ADDR_VAR 0 5
4552: PUSH
4553: LD_VAR 0 3
4557: PUSH
4558: FOR_IN
4559: IFFALSE 4658
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4561: LD_INT 0
4563: PPUSH
4564: LD_INT 1
4566: PPUSH
4567: LD_INT 1
4569: PUSH
4570: LD_OWVAR 67
4574: PLUS
4575: PPUSH
4576: CALL_OW 380
// un := CreateHuman ;
4580: LD_ADDR_VAR 0 6
4584: PUSH
4585: CALL_OW 44
4589: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4590: LD_ADDR_EXP 36
4594: PUSH
4595: LD_EXP 36
4599: PPUSH
4600: LD_EXP 36
4604: PUSH
4605: LD_INT 1
4607: PLUS
4608: PPUSH
4609: LD_VAR 0 6
4613: PPUSH
4614: CALL_OW 1
4618: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) + 3 ) ;
4619: LD_VAR 0 6
4623: PPUSH
4624: LD_VAR 0 5
4628: PPUSH
4629: CALL_OW 254
4633: PUSH
4634: LD_INT 3
4636: PLUS
4637: PPUSH
4638: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4642: LD_VAR 0 6
4646: PPUSH
4647: LD_VAR 0 5
4651: PPUSH
4652: CALL_OW 52
// end ;
4656: GO 4558
4658: POP
4659: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4660: LD_ADDR_VAR 0 3
4664: PUSH
4665: LD_INT 22
4667: PUSH
4668: LD_INT 3
4670: PUSH
4671: EMPTY
4672: LIST
4673: LIST
4674: PUSH
4675: LD_INT 2
4677: PUSH
4678: LD_INT 30
4680: PUSH
4681: LD_INT 4
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: PUSH
4688: LD_INT 30
4690: PUSH
4691: LD_INT 5
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: LIST
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: PPUSH
4707: CALL_OW 69
4711: ST_TO_ADDR
// for b in blist do
4712: LD_ADDR_VAR 0 5
4716: PUSH
4717: LD_VAR 0 3
4721: PUSH
4722: FOR_IN
4723: IFFALSE 4819
// begin for i := 1 to 2 do
4725: LD_ADDR_VAR 0 4
4729: PUSH
4730: DOUBLE
4731: LD_INT 1
4733: DEC
4734: ST_TO_ADDR
4735: LD_INT 2
4737: PUSH
4738: FOR_TO
4739: IFFALSE 4815
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4741: LD_INT 0
4743: PPUSH
4744: LD_INT 1
4746: PPUSH
4747: LD_INT 1
4749: PUSH
4750: LD_OWVAR 67
4754: PLUS
4755: PPUSH
4756: CALL_OW 380
// un := CreateHuman ;
4760: LD_ADDR_VAR 0 6
4764: PUSH
4765: CALL_OW 44
4769: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4770: LD_ADDR_EXP 36
4774: PUSH
4775: LD_EXP 36
4779: PPUSH
4780: LD_EXP 36
4784: PUSH
4785: LD_INT 1
4787: PLUS
4788: PPUSH
4789: LD_VAR 0 6
4793: PPUSH
4794: CALL_OW 1
4798: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4799: LD_VAR 0 6
4803: PPUSH
4804: LD_VAR 0 5
4808: PPUSH
4809: CALL_OW 52
// end ;
4813: GO 4738
4815: POP
4816: POP
// end ;
4817: GO 4722
4819: POP
4820: POP
// if ibrahimOnRuSide then
4821: LD_EXP 3
4825: IFFALSE 4923
// begin Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
4827: LD_ADDR_EXP 21
4831: PUSH
4832: LD_STRING IbrahimRu
4834: PPUSH
4835: LD_INT 0
4837: PPUSH
4838: LD_STRING 
4840: PPUSH
4841: CALL 336 0 3
4845: ST_TO_ADDR
// PlaceUnitXY ( Ibrahim , 121 , 78 , false ) ;
4846: LD_EXP 21
4850: PPUSH
4851: LD_INT 121
4853: PPUSH
4854: LD_INT 78
4856: PPUSH
4857: LD_INT 0
4859: PPUSH
4860: CALL_OW 48
// ComHold ( Ibrahim ) ;
4864: LD_EXP 21
4868: PPUSH
4869: CALL_OW 140
// PrepareHuman ( sex_male , 1 , 2 ) ;
4873: LD_INT 1
4875: PPUSH
4876: LD_INT 1
4878: PPUSH
4879: LD_INT 2
4881: PPUSH
4882: CALL_OW 380
// ruSol := CreateHuman ;
4886: LD_ADDR_EXP 41
4890: PUSH
4891: CALL_OW 44
4895: ST_TO_ADDR
// PlaceUnitXY ( ruSol , 121 , 75 , false ) ;
4896: LD_EXP 41
4900: PPUSH
4901: LD_INT 121
4903: PPUSH
4904: LD_INT 75
4906: PPUSH
4907: LD_INT 0
4909: PPUSH
4910: CALL_OW 48
// ComHold ( ruSol ) ;
4914: LD_EXP 41
4918: PPUSH
4919: CALL_OW 140
// end ; for i := 1 to [ 2 , 2 + Difficulty ] [ ( ruEscapeCounter > 3 ) + 1 ] do
4923: LD_ADDR_VAR 0 4
4927: PUSH
4928: DOUBLE
4929: LD_INT 1
4931: DEC
4932: ST_TO_ADDR
4933: LD_INT 2
4935: PUSH
4936: LD_INT 2
4938: PUSH
4939: LD_OWVAR 67
4943: PLUS
4944: PUSH
4945: EMPTY
4946: LIST
4947: LIST
4948: PUSH
4949: LD_EXP 10
4953: PUSH
4954: LD_INT 3
4956: GREATER
4957: PUSH
4958: LD_INT 1
4960: PLUS
4961: ARRAY
4962: PUSH
4963: FOR_TO
4964: IFFALSE 5033
// AddComConstruct ( fac , [ ru_medium_wheeled , ru_heavy_wheeled , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] ) ;
4966: LD_VAR 0 8
4970: PPUSH
4971: LD_INT 21
4973: PUSH
4974: LD_INT 23
4976: PUSH
4977: LD_INT 24
4979: PUSH
4980: EMPTY
4981: LIST
4982: LIST
4983: LIST
4984: PUSH
4985: LD_VAR 0 4
4989: PUSH
4990: LD_INT 3
4992: MOD
4993: PUSH
4994: LD_INT 1
4996: PLUS
4997: ARRAY
4998: PPUSH
4999: LD_INT 1
5001: PPUSH
5002: LD_INT 1
5004: PPUSH
5005: LD_INT 43
5007: PUSH
5008: LD_INT 44
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: PUSH
5015: LD_INT 1
5017: PPUSH
5018: LD_INT 2
5020: PPUSH
5021: CALL_OW 12
5025: ARRAY
5026: PPUSH
5027: CALL_OW 185
5031: GO 4963
5033: POP
5034: POP
// end ;
5035: LD_VAR 0 1
5039: RET
// every 0 0$1 trigger ruMobile and not ruEscapeAllowed do var i , filter , tmp , enemy , x ;
5040: LD_EXP 40
5044: PUSH
5045: LD_EXP 4
5049: NOT
5050: AND
5051: IFFALSE 5538
5053: GO 5055
5055: DISABLE
5056: LD_INT 0
5058: PPUSH
5059: PPUSH
5060: PPUSH
5061: PPUSH
5062: PPUSH
// begin enable ;
5063: ENABLE
// filter := UnitFilter ( ruMobile , [ f_type , unit_vehicle ] ) ;
5064: LD_ADDR_VAR 0 2
5068: PUSH
5069: LD_EXP 40
5073: PPUSH
5074: LD_INT 21
5076: PUSH
5077: LD_INT 2
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PPUSH
5084: CALL_OW 72
5088: ST_TO_ADDR
// enemy := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_or , [ f_inarea , zone1 ] , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) ;
5089: LD_ADDR_VAR 0 4
5093: PUSH
5094: LD_INT 81
5096: PUSH
5097: LD_INT 3
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 2
5106: PUSH
5107: LD_INT 95
5109: PUSH
5110: LD_INT 4
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: LD_INT 95
5119: PUSH
5120: LD_INT 5
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: LD_INT 95
5129: PUSH
5130: LD_INT 6
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: PUSH
5137: LD_INT 95
5139: PUSH
5140: LD_INT 7
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PUSH
5147: EMPTY
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: PUSH
5154: EMPTY
5155: LIST
5156: LIST
5157: PPUSH
5158: CALL_OW 69
5162: ST_TO_ADDR
// for i in filter do
5163: LD_ADDR_VAR 0 1
5167: PUSH
5168: LD_VAR 0 2
5172: PUSH
5173: FOR_IN
5174: IFFALSE 5536
// begin tmp := IsDrivenBy ( i ) ;
5176: LD_ADDR_VAR 0 3
5180: PUSH
5181: LD_VAR 0 1
5185: PPUSH
5186: CALL_OW 311
5190: ST_TO_ADDR
// if not tmp then
5191: LD_VAR 0 3
5195: NOT
5196: IFFALSE 5200
// continue ;
5198: GO 5173
// if GetFuel ( i ) > 90 and GetTag ( i ) = 2 then
5200: LD_VAR 0 1
5204: PPUSH
5205: CALL_OW 261
5209: PUSH
5210: LD_INT 90
5212: GREATER
5213: PUSH
5214: LD_VAR 0 1
5218: PPUSH
5219: CALL_OW 110
5223: PUSH
5224: LD_INT 2
5226: EQUAL
5227: AND
5228: IFFALSE 5244
// SetTag ( i , 0 ) else
5230: LD_VAR 0 1
5234: PPUSH
5235: LD_INT 0
5237: PPUSH
5238: CALL_OW 109
5242: GO 5287
// if GetTag ( i ) = 2 then
5244: LD_VAR 0 1
5248: PPUSH
5249: CALL_OW 110
5253: PUSH
5254: LD_INT 2
5256: EQUAL
5257: IFFALSE 5287
// begin x := rand ( 1 , 2 ) ;
5259: LD_ADDR_VAR 0 5
5263: PUSH
5264: LD_INT 1
5266: PPUSH
5267: LD_INT 2
5269: PPUSH
5270: CALL_OW 12
5274: ST_TO_ADDR
// AddComMoveUnit ( i , ruMainBase ) ;
5275: LD_VAR 0 1
5279: PPUSH
5280: LD_INT 200
5282: PPUSH
5283: CALL_OW 172
// end ; if GetLives ( i ) >= 600 and not GetTag ( i ) then
5287: LD_VAR 0 1
5291: PPUSH
5292: CALL_OW 256
5296: PUSH
5297: LD_INT 600
5299: GREATEREQUAL
5300: PUSH
5301: LD_VAR 0 1
5305: PPUSH
5306: CALL_OW 110
5310: NOT
5311: AND
5312: IFFALSE 5338
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
5314: LD_VAR 0 1
5318: PPUSH
5319: LD_VAR 0 4
5323: PPUSH
5324: LD_VAR 0 1
5328: PPUSH
5329: CALL_OW 74
5333: PPUSH
5334: CALL_OW 115
// if GetLives ( i ) < 600 and not GetTag ( i ) then
5338: LD_VAR 0 1
5342: PPUSH
5343: CALL_OW 256
5347: PUSH
5348: LD_INT 600
5350: LESS
5351: PUSH
5352: LD_VAR 0 1
5356: PPUSH
5357: CALL_OW 110
5361: NOT
5362: AND
5363: IFFALSE 5392
// begin SetTag ( i , 1 ) ;
5365: LD_VAR 0 1
5369: PPUSH
5370: LD_INT 1
5372: PPUSH
5373: CALL_OW 109
// ComMoveXY ( i , 112 , 119 ) ;
5377: LD_VAR 0 1
5381: PPUSH
5382: LD_INT 112
5384: PPUSH
5385: LD_INT 119
5387: PPUSH
5388: CALL_OW 111
// end ; if GetTag ( i ) = 1 and GetDistUnitXY ( i , 112 , 119 ) < 9 and tmp then
5392: LD_VAR 0 1
5396: PPUSH
5397: CALL_OW 110
5401: PUSH
5402: LD_INT 1
5404: EQUAL
5405: PUSH
5406: LD_VAR 0 1
5410: PPUSH
5411: LD_INT 112
5413: PPUSH
5414: LD_INT 119
5416: PPUSH
5417: CALL_OW 297
5421: PUSH
5422: LD_INT 9
5424: LESS
5425: AND
5426: PUSH
5427: LD_VAR 0 3
5431: AND
5432: IFFALSE 5534
// begin ComExitVehicle ( tmp ) ;
5434: LD_VAR 0 3
5438: PPUSH
5439: CALL_OW 121
// AddComRepairVehicle ( tmp , i ) ;
5443: LD_VAR 0 3
5447: PPUSH
5448: LD_VAR 0 1
5452: PPUSH
5453: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
5457: LD_INT 35
5459: PPUSH
5460: CALL_OW 67
// until GetLives ( i ) = 1000 ;
5464: LD_VAR 0 1
5468: PPUSH
5469: CALL_OW 256
5473: PUSH
5474: LD_INT 1000
5476: EQUAL
5477: IFFALSE 5457
// ComEnterUnit ( tmp , i ) ;
5479: LD_VAR 0 3
5483: PPUSH
5484: LD_VAR 0 1
5488: PPUSH
5489: CALL_OW 120
// if GetFuel ( i ) <= 50 then
5493: LD_VAR 0 1
5497: PPUSH
5498: CALL_OW 261
5502: PUSH
5503: LD_INT 50
5505: LESSEQUAL
5506: IFFALSE 5522
// SetTag ( i , 2 ) else
5508: LD_VAR 0 1
5512: PPUSH
5513: LD_INT 2
5515: PPUSH
5516: CALL_OW 109
5520: GO 5534
// SetTag ( i , 0 ) ;
5522: LD_VAR 0 1
5526: PPUSH
5527: LD_INT 0
5529: PPUSH
5530: CALL_OW 109
// end ; end ;
5534: GO 5173
5536: POP
5537: POP
// end ;
5538: PPOPN 5
5540: END
// every 0 0$1 trigger not ruEscapeAllowed and ruEng do var i , filter , tmp , enemy ;
5541: LD_EXP 4
5545: NOT
5546: PUSH
5547: LD_EXP 37
5551: AND
5552: IFFALSE 5813
5554: GO 5556
5556: DISABLE
5557: LD_INT 0
5559: PPUSH
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5564: LD_ADDR_VAR 0 2
5568: PUSH
5569: LD_INT 3
5571: PPUSH
5572: LD_INT 22
5574: PUSH
5575: LD_INT 3
5577: PUSH
5578: EMPTY
5579: LIST
5580: LIST
5581: PUSH
5582: LD_INT 21
5584: PUSH
5585: LD_INT 3
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: PUSH
5592: LD_INT 3
5594: PUSH
5595: LD_INT 24
5597: PUSH
5598: LD_INT 1000
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 70
5618: ST_TO_ADDR
// tmp := UnitFilter ( ruEng , [ f_ok ] ) ;
5619: LD_ADDR_VAR 0 3
5623: PUSH
5624: LD_EXP 37
5628: PPUSH
5629: LD_INT 50
5631: PUSH
5632: EMPTY
5633: LIST
5634: PPUSH
5635: CALL_OW 72
5639: ST_TO_ADDR
// if filter and tmp then
5640: LD_VAR 0 2
5644: PUSH
5645: LD_VAR 0 3
5649: AND
5650: IFFALSE 5742
// begin for i in tmp do
5652: LD_ADDR_VAR 0 1
5656: PUSH
5657: LD_VAR 0 3
5661: PUSH
5662: FOR_IN
5663: IFFALSE 5738
// begin if GetTag ( i ) = tEscape then
5665: LD_VAR 0 1
5669: PPUSH
5670: CALL_OW 110
5674: PUSH
5675: LD_EXP 17
5679: EQUAL
5680: IFFALSE 5684
// continue ;
5682: GO 5662
// if IsInUnit ( i ) then
5684: LD_VAR 0 1
5688: PPUSH
5689: CALL_OW 310
5693: IFFALSE 5706
// ComExitBuilding ( i ) else
5695: LD_VAR 0 1
5699: PPUSH
5700: CALL_OW 122
5704: GO 5736
// if not HasTask ( i ) then
5706: LD_VAR 0 1
5710: PPUSH
5711: CALL_OW 314
5715: NOT
5716: IFFALSE 5736
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5718: LD_VAR 0 1
5722: PPUSH
5723: LD_VAR 0 2
5727: PUSH
5728: LD_INT 1
5730: ARRAY
5731: PPUSH
5732: CALL_OW 130
// end ;
5736: GO 5662
5738: POP
5739: POP
// end else
5740: GO 5813
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5742: LD_VAR 0 3
5746: PPUSH
5747: LD_INT 3
5749: PUSH
5750: LD_INT 54
5752: PUSH
5753: EMPTY
5754: LIST
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: PPUSH
5760: CALL_OW 72
5764: IFFALSE 5813
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5766: LD_ADDR_VAR 0 1
5770: PUSH
5771: LD_VAR 0 3
5775: PPUSH
5776: LD_INT 3
5778: PUSH
5779: LD_INT 54
5781: PUSH
5782: EMPTY
5783: LIST
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PPUSH
5789: CALL_OW 72
5793: PUSH
5794: FOR_IN
5795: IFFALSE 5811
// ComEnterUnit ( i , ruMainBase ) ;
5797: LD_VAR 0 1
5801: PPUSH
5802: LD_INT 200
5804: PPUSH
5805: CALL_OW 120
5809: GO 5794
5811: POP
5812: POP
// end ; end ;
5813: PPOPN 4
5815: END
// every 0 0$1 trigger not ruEscapeAllowed and ruSci do var i , filter , tmp , lab ;
5816: LD_EXP 4
5820: NOT
5821: PUSH
5822: LD_EXP 39
5826: AND
5827: IFFALSE 6106
5829: GO 5831
5831: DISABLE
5832: LD_INT 0
5834: PPUSH
5835: PPUSH
5836: PPUSH
5837: PPUSH
// begin enable ;
5838: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5839: LD_ADDR_VAR 0 2
5843: PUSH
5844: LD_INT 3
5846: PPUSH
5847: LD_INT 22
5849: PUSH
5850: LD_INT 3
5852: PUSH
5853: EMPTY
5854: LIST
5855: LIST
5856: PUSH
5857: LD_INT 21
5859: PUSH
5860: LD_INT 1
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: PUSH
5867: LD_INT 3
5869: PUSH
5870: LD_INT 24
5872: PUSH
5873: LD_INT 1000
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PPUSH
5889: CALL_OW 70
5893: ST_TO_ADDR
// tmp := UnitFilter ( ruSci , [ f_ok ] ) ;
5894: LD_ADDR_VAR 0 3
5898: PUSH
5899: LD_EXP 39
5903: PPUSH
5904: LD_INT 50
5906: PUSH
5907: EMPTY
5908: LIST
5909: PPUSH
5910: CALL_OW 72
5914: ST_TO_ADDR
// lab := HexInfo ( 118 , 121 ) ;
5915: LD_ADDR_VAR 0 4
5919: PUSH
5920: LD_INT 118
5922: PPUSH
5923: LD_INT 121
5925: PPUSH
5926: CALL_OW 428
5930: ST_TO_ADDR
// if filter and tmp then
5931: LD_VAR 0 2
5935: PUSH
5936: LD_VAR 0 3
5940: AND
5941: IFFALSE 6033
// begin for i in tmp do
5943: LD_ADDR_VAR 0 1
5947: PUSH
5948: LD_VAR 0 3
5952: PUSH
5953: FOR_IN
5954: IFFALSE 6029
// begin if GetTag ( i ) = tEscape then
5956: LD_VAR 0 1
5960: PPUSH
5961: CALL_OW 110
5965: PUSH
5966: LD_EXP 17
5970: EQUAL
5971: IFFALSE 5975
// continue ;
5973: GO 5953
// if IsInUnit ( i ) then
5975: LD_VAR 0 1
5979: PPUSH
5980: CALL_OW 310
5984: IFFALSE 5997
// ComExitBuilding ( i ) else
5986: LD_VAR 0 1
5990: PPUSH
5991: CALL_OW 122
5995: GO 6027
// if not HasTask ( i ) then
5997: LD_VAR 0 1
6001: PPUSH
6002: CALL_OW 314
6006: NOT
6007: IFFALSE 6027
// ComHeal ( i , filter [ 1 ] ) ;
6009: LD_VAR 0 1
6013: PPUSH
6014: LD_VAR 0 2
6018: PUSH
6019: LD_INT 1
6021: ARRAY
6022: PPUSH
6023: CALL_OW 128
// end ;
6027: GO 5953
6029: POP
6030: POP
// end else
6031: GO 6106
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
6033: LD_VAR 0 3
6037: PPUSH
6038: LD_INT 3
6040: PUSH
6041: LD_INT 54
6043: PUSH
6044: EMPTY
6045: LIST
6046: PUSH
6047: EMPTY
6048: LIST
6049: LIST
6050: PPUSH
6051: CALL_OW 72
6055: IFFALSE 6106
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
6057: LD_ADDR_VAR 0 1
6061: PUSH
6062: LD_VAR 0 3
6066: PPUSH
6067: LD_INT 3
6069: PUSH
6070: LD_INT 54
6072: PUSH
6073: EMPTY
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PPUSH
6080: CALL_OW 72
6084: PUSH
6085: FOR_IN
6086: IFFALSE 6104
// ComEnterUnit ( i , lab ) ;
6088: LD_VAR 0 1
6092: PPUSH
6093: LD_VAR 0 4
6097: PPUSH
6098: CALL_OW 120
6102: GO 6085
6104: POP
6105: POP
// end ; end ; end_of_file
6106: PPOPN 4
6108: END
// on UnitDestroyed ( un ) do begin if un = Heike then
6109: LD_VAR 0 1
6113: PUSH
6114: LD_EXP 18
6118: EQUAL
6119: IFFALSE 6128
// YouLost ( Heike ) ;
6121: LD_STRING Heike
6123: PPUSH
6124: CALL_OW 104
// if un in ruEng then
6128: LD_VAR 0 1
6132: PUSH
6133: LD_EXP 37
6137: IN
6138: IFFALSE 6156
// ruEng := ruEng diff un ;
6140: LD_ADDR_EXP 37
6144: PUSH
6145: LD_EXP 37
6149: PUSH
6150: LD_VAR 0 1
6154: DIFF
6155: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) then
6156: LD_VAR 0 1
6160: PUSH
6161: LD_INT 22
6163: PUSH
6164: LD_INT 2
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: PUSH
6171: LD_INT 21
6173: PUSH
6174: LD_INT 1
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: PUSH
6181: LD_INT 23
6183: PUSH
6184: LD_INT 2
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: PPUSH
6196: CALL_OW 69
6200: IN
6201: IFFALSE 6217
// loseCounter := loseCounter + 1 ;
6203: LD_ADDR_EXP 6
6207: PUSH
6208: LD_EXP 6
6212: PUSH
6213: LD_INT 1
6215: PLUS
6216: ST_TO_ADDR
// end ;
6217: PPOPN 1
6219: END
// on EvacuateVehicle ( driver , un , p1 , p2 ) do var weapon , fac ;
6220: LD_INT 0
6222: PPUSH
6223: PPUSH
// begin if un in ruMobile then
6224: LD_VAR 0 2
6228: PUSH
6229: LD_EXP 40
6233: IN
6234: IFFALSE 6393
// begin ruMobile := ruMobile diff un ;
6236: LD_ADDR_EXP 40
6240: PUSH
6241: LD_EXP 40
6245: PUSH
6246: LD_VAR 0 2
6250: DIFF
6251: ST_TO_ADDR
// weapon := GetWeapon ( un ) ;
6252: LD_ADDR_VAR 0 5
6256: PUSH
6257: LD_VAR 0 2
6261: PPUSH
6262: CALL_OW 264
6266: ST_TO_ADDR
// fac := HexInfo ( 110 , 126 ) ;
6267: LD_ADDR_VAR 0 6
6271: PUSH
6272: LD_INT 110
6274: PPUSH
6275: LD_INT 126
6277: PPUSH
6278: CALL_OW 428
6282: ST_TO_ADDR
// if not driver or not fac then
6283: LD_VAR 0 1
6287: NOT
6288: PUSH
6289: LD_VAR 0 6
6293: NOT
6294: OR
6295: IFFALSE 6299
// exit ;
6297: GO 6393
// AddComMoveXY ( driver , 111 , 121 ) ;
6299: LD_VAR 0 1
6303: PPUSH
6304: LD_INT 111
6306: PPUSH
6307: LD_INT 121
6309: PPUSH
6310: CALL_OW 171
// AddComEnterUnit ( driver , fac ) ;
6314: LD_VAR 0 1
6318: PPUSH
6319: LD_VAR 0 6
6323: PPUSH
6324: CALL_OW 180
// repeat wait ( 0 0$1 ) ;
6328: LD_INT 35
6330: PPUSH
6331: CALL_OW 67
// until IsDead ( driver ) or IsInUnit ( driver ) ;
6335: LD_VAR 0 1
6339: PPUSH
6340: CALL_OW 301
6344: PUSH
6345: LD_VAR 0 1
6349: PPUSH
6350: CALL_OW 310
6354: OR
6355: IFFALSE 6328
// if IsDead ( driver ) then
6357: LD_VAR 0 1
6361: PPUSH
6362: CALL_OW 301
6366: IFFALSE 6370
// exit ;
6368: GO 6393
// AddComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_manual , weapon ) ;
6370: LD_VAR 0 6
6374: PPUSH
6375: LD_INT 21
6377: PPUSH
6378: LD_INT 1
6380: PPUSH
6381: LD_INT 1
6383: PPUSH
6384: LD_VAR 0 5
6388: PPUSH
6389: CALL_OW 185
// end ; end ;
6393: PPOPN 6
6395: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 3 then
6396: LD_VAR 0 2
6400: PPUSH
6401: CALL_OW 255
6405: PUSH
6406: LD_INT 3
6408: EQUAL
6409: IFFALSE 6455
// begin ruMobile := Replace ( ruMobile , ruMobile + 1 , veh ) ;
6411: LD_ADDR_EXP 40
6415: PUSH
6416: LD_EXP 40
6420: PPUSH
6421: LD_EXP 40
6425: PUSH
6426: LD_INT 1
6428: PLUS
6429: PPUSH
6430: LD_VAR 0 1
6434: PPUSH
6435: CALL_OW 1
6439: ST_TO_ADDR
// AddComMoveXY ( veh , 110 , 117 ) ;
6440: LD_VAR 0 1
6444: PPUSH
6445: LD_INT 110
6447: PPUSH
6448: LD_INT 117
6450: PPUSH
6451: CALL_OW 171
// end ; end ;
6455: PPOPN 2
6457: END
// on LeaveBuilding ( b , un ) do var barracks ;
6458: LD_INT 0
6460: PPUSH
// begin if b in [ HexInfo ( 130 , 17 ) , HexInfo ( 138 , 22 ) , HexInfo ( 123 , 17 ) ] then
6461: LD_VAR 0 1
6465: PUSH
6466: LD_INT 130
6468: PPUSH
6469: LD_INT 17
6471: PPUSH
6472: CALL_OW 428
6476: PUSH
6477: LD_INT 138
6479: PPUSH
6480: LD_INT 22
6482: PPUSH
6483: CALL_OW 428
6487: PUSH
6488: LD_INT 123
6490: PPUSH
6491: LD_INT 17
6493: PPUSH
6494: CALL_OW 428
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: LIST
6503: IN
6504: IFFALSE 6528
// begin AddComEnterUnit ( un , HexInfo ( 135 , 31 ) ) ;
6506: LD_VAR 0 2
6510: PPUSH
6511: LD_INT 135
6513: PPUSH
6514: LD_INT 31
6516: PPUSH
6517: CALL_OW 428
6521: PPUSH
6522: CALL_OW 180
// exit ;
6526: GO 6802
// end ; if b = HexInfo ( 135 , 31 ) then
6528: LD_VAR 0 1
6532: PUSH
6533: LD_INT 135
6535: PPUSH
6536: LD_INT 31
6538: PPUSH
6539: CALL_OW 428
6543: EQUAL
6544: IFFALSE 6616
// begin AddComEnterUnit ( un , HexInfo ( 106 , 51 ) ) ;
6546: LD_VAR 0 2
6550: PPUSH
6551: LD_INT 106
6553: PPUSH
6554: LD_INT 51
6556: PPUSH
6557: CALL_OW 428
6561: PPUSH
6562: CALL_OW 180
// if not explodeFirstDepot then
6566: LD_EXP 12
6570: NOT
6571: IFFALSE 6614
// begin explodeFirstDepot := true ;
6573: LD_ADDR_EXP 12
6577: PUSH
6578: LD_INT 1
6580: ST_TO_ADDR
// wait ( 0 0$15 ) ;
6581: LD_INT 525
6583: PPUSH
6584: CALL_OW 67
// MineExplosion ( 127 , 27 , 1 ) ;
6588: LD_INT 127
6590: PPUSH
6591: LD_INT 27
6593: PPUSH
6594: LD_INT 1
6596: PPUSH
6597: CALL_OW 453
// MineExplosion ( 125 , 29 , 1 ) ;
6601: LD_INT 125
6603: PPUSH
6604: LD_INT 29
6606: PPUSH
6607: LD_INT 1
6609: PPUSH
6610: CALL_OW 453
// end ; exit ;
6614: GO 6802
// end ; if b = HexInfo ( 106 , 51 ) then
6616: LD_VAR 0 1
6620: PUSH
6621: LD_INT 106
6623: PPUSH
6624: LD_INT 51
6626: PPUSH
6627: CALL_OW 428
6631: EQUAL
6632: IFFALSE 6732
// begin AddComMoveXY ( un , 106 , 93 ) ;
6634: LD_VAR 0 2
6638: PPUSH
6639: LD_INT 106
6641: PPUSH
6642: LD_INT 93
6644: PPUSH
6645: CALL_OW 171
// if not explodeSecondDepot then
6649: LD_EXP 13
6653: NOT
6654: IFFALSE 6730
// begin explodeSecondDepot := true ;
6656: LD_ADDR_EXP 13
6660: PUSH
6661: LD_INT 1
6663: ST_TO_ADDR
// wait ( 0 0$12 ) ;
6664: LD_INT 420
6666: PPUSH
6667: CALL_OW 67
// MineExplosion ( 111 , 75 , 1 ) ;
6671: LD_INT 111
6673: PPUSH
6674: LD_INT 75
6676: PPUSH
6677: LD_INT 1
6679: PPUSH
6680: CALL_OW 453
// MineExplosion ( 111 , 75 , 1 ) ;
6684: LD_INT 111
6686: PPUSH
6687: LD_INT 75
6689: PPUSH
6690: LD_INT 1
6692: PPUSH
6693: CALL_OW 453
// MineExplosion ( 108 , 69 , 1 ) ;
6697: LD_INT 108
6699: PPUSH
6700: LD_INT 69
6702: PPUSH
6703: LD_INT 1
6705: PPUSH
6706: CALL_OW 453
// wait ( 0 0$2 ) ;
6710: LD_INT 70
6712: PPUSH
6713: CALL_OW 67
// MineExplosion ( 94 , 65 , 1 ) ;
6717: LD_INT 94
6719: PPUSH
6720: LD_INT 65
6722: PPUSH
6723: LD_INT 1
6725: PPUSH
6726: CALL_OW 453
// end ; exit ;
6730: GO 6802
// end ; if GetBType ( b ) = b_bunker then
6732: LD_VAR 0 1
6736: PPUSH
6737: CALL_OW 266
6741: PUSH
6742: LD_INT 32
6744: EQUAL
6745: IFFALSE 6802
// begin barracks := NearestEmptyBuilding ( un , b_barracks ) ;
6747: LD_ADDR_VAR 0 3
6751: PUSH
6752: LD_VAR 0 2
6756: PPUSH
6757: LD_INT 5
6759: PPUSH
6760: CALL 2403 0 2
6764: ST_TO_ADDR
// if barracks then
6765: LD_VAR 0 3
6769: IFFALSE 6787
// AddComEnterUnit ( un , barracks ) else
6771: LD_VAR 0 2
6775: PPUSH
6776: LD_VAR 0 3
6780: PPUSH
6781: CALL_OW 180
6785: GO 6802
// AddComMoveXY ( un , 116 , 110 ) ;
6787: LD_VAR 0 2
6791: PPUSH
6792: LD_INT 116
6794: PPUSH
6795: LD_INT 110
6797: PPUSH
6798: CALL_OW 171
// end ; end ;
6802: PPOPN 3
6804: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un = Kaia and killerSide in [ 3 , 6 ] then
6805: LD_VAR 0 1
6809: PUSH
6810: LD_EXP 23
6814: EQUAL
6815: PUSH
6816: LD_VAR 0 2
6820: PUSH
6821: LD_INT 3
6823: PUSH
6824: LD_INT 6
6826: PUSH
6827: EMPTY
6828: LIST
6829: LIST
6830: IN
6831: AND
6832: IFFALSE 6863
// kaiaKilledByRussian := [ GetX ( un ) , GetY ( un ) ] ;
6834: LD_ADDR_EXP 8
6838: PUSH
6839: LD_VAR 0 1
6843: PPUSH
6844: CALL_OW 250
6848: PUSH
6849: LD_VAR 0 1
6853: PPUSH
6854: CALL_OW 251
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: ST_TO_ADDR
// end ; end_of_file
6863: PPOPN 3
6865: END
// export function Action ; var i , un , veh , tmp , rutmp ; begin
6866: LD_INT 0
6868: PPUSH
6869: PPUSH
6870: PPUSH
6871: PPUSH
6872: PPUSH
6873: PPUSH
// InGameOn ;
6874: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6878: LD_INT 5
6880: PPUSH
6881: LD_INT 2
6883: PPUSH
6884: CALL_OW 343
// music_nat := 4 ;
6888: LD_ADDR_OWVAR 71
6892: PUSH
6893: LD_INT 4
6895: ST_TO_ADDR
// music_class := music_combat ;
6896: LD_ADDR_OWVAR 72
6900: PUSH
6901: LD_INT 1
6903: ST_TO_ADDR
// PlaceSeeing ( 133 , 2 , 2 , 10 ) ;
6904: LD_INT 133
6906: PPUSH
6907: LD_INT 2
6909: PPUSH
6910: LD_INT 2
6912: PPUSH
6913: LD_INT 10
6915: PPUSH
6916: CALL_OW 330
// CenterNowOnXY ( 133 , 2 ) ;
6920: LD_INT 133
6922: PPUSH
6923: LD_INT 2
6925: PPUSH
6926: CALL_OW 86
// wait ( 0 0$1 ) ;
6930: LD_INT 35
6932: PPUSH
6933: CALL_OW 67
// uc_side := 6 ;
6937: LD_ADDR_OWVAR 20
6941: PUSH
6942: LD_INT 6
6944: ST_TO_ADDR
// uc_nation := 3 ;
6945: LD_ADDR_OWVAR 21
6949: PUSH
6950: LD_INT 3
6952: ST_TO_ADDR
// rutmp := [ ] ;
6953: LD_ADDR_VAR 0 6
6957: PUSH
6958: EMPTY
6959: ST_TO_ADDR
// PrepareTank ( 6 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_gun , 66 ) ;
6960: LD_INT 6
6962: PPUSH
6963: LD_INT 3
6965: PPUSH
6966: LD_INT 21
6968: PPUSH
6969: LD_INT 1
6971: PPUSH
6972: LD_INT 1
6974: PPUSH
6975: LD_INT 44
6977: PPUSH
6978: LD_INT 66
6980: PPUSH
6981: CALL 399 0 7
// veh := CreateVehicle ;
6985: LD_ADDR_VAR 0 4
6989: PUSH
6990: CALL_OW 45
6994: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
6995: LD_VAR 0 4
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7007: LD_VAR 0 4
7011: PPUSH
7012: LD_INT 8
7014: PPUSH
7015: LD_INT 0
7017: PPUSH
7018: CALL_OW 49
// SetLives ( veh , 500 ) ;
7022: LD_VAR 0 4
7026: PPUSH
7027: LD_INT 500
7029: PPUSH
7030: CALL_OW 234
// PrepareHuman ( false , 3 , 3 ) ;
7034: LD_INT 0
7036: PPUSH
7037: LD_INT 3
7039: PPUSH
7040: LD_INT 3
7042: PPUSH
7043: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7047: CALL_OW 44
7051: PPUSH
7052: LD_VAR 0 4
7056: PPUSH
7057: CALL_OW 52
// ComMoveXY ( veh , 133 , 11 ) ;
7061: LD_VAR 0 4
7065: PPUSH
7066: LD_INT 133
7068: PPUSH
7069: LD_INT 11
7071: PPUSH
7072: CALL_OW 111
// rutmp := [ veh ] ;
7076: LD_ADDR_VAR 0 6
7080: PUSH
7081: LD_VAR 0 4
7085: PUSH
7086: EMPTY
7087: LIST
7088: ST_TO_ADDR
// for i := 1 to 4 do
7089: LD_ADDR_VAR 0 2
7093: PUSH
7094: DOUBLE
7095: LD_INT 1
7097: DEC
7098: ST_TO_ADDR
7099: LD_INT 4
7101: PUSH
7102: FOR_TO
7103: IFFALSE 7210
// begin PrepareHuman ( false , i , 2 ) ;
7105: LD_INT 0
7107: PPUSH
7108: LD_VAR 0 2
7112: PPUSH
7113: LD_INT 2
7115: PPUSH
7116: CALL_OW 380
// un := CreateHuman ;
7120: LD_ADDR_VAR 0 3
7124: PUSH
7125: CALL_OW 44
7129: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7130: LD_VAR 0 3
7134: PPUSH
7135: LD_INT 3
7137: PPUSH
7138: CALL_OW 233
// PlaceUnitArea ( un , spawnArea , false ) ;
7142: LD_VAR 0 3
7146: PPUSH
7147: LD_INT 8
7149: PPUSH
7150: LD_INT 0
7152: PPUSH
7153: CALL_OW 49
// rutmp := Replace ( rutmp , rutmp + 1 , un ) ;
7157: LD_ADDR_VAR 0 6
7161: PUSH
7162: LD_VAR 0 6
7166: PPUSH
7167: LD_VAR 0 6
7171: PUSH
7172: LD_INT 1
7174: PLUS
7175: PPUSH
7176: LD_VAR 0 3
7180: PPUSH
7181: CALL_OW 1
7185: ST_TO_ADDR
// ComMoveXY ( un , 133 , 11 ) ;
7186: LD_VAR 0 3
7190: PPUSH
7191: LD_INT 133
7193: PPUSH
7194: LD_INT 11
7196: PPUSH
7197: CALL_OW 111
// wait ( 0 0$0.5 ) ;
7201: LD_INT 18
7203: PPUSH
7204: CALL_OW 67
// end ;
7208: GO 7102
7210: POP
7211: POP
// for i in rutmp do
7212: LD_ADDR_VAR 0 2
7216: PUSH
7217: LD_VAR 0 6
7221: PUSH
7222: FOR_IN
7223: IFFALSE 7272
// begin AddComMoveXY ( i , 99 , 65 ) ;
7225: LD_VAR 0 2
7229: PPUSH
7230: LD_INT 99
7232: PPUSH
7233: LD_INT 65
7235: PPUSH
7236: CALL_OW 171
// AddComMoveXY ( i , 76 , 108 ) ;
7240: LD_VAR 0 2
7244: PPUSH
7245: LD_INT 76
7247: PPUSH
7248: LD_INT 108
7250: PPUSH
7251: CALL_OW 171
// AddComMoveXY ( i , 92 , 176 ) ;
7255: LD_VAR 0 2
7259: PPUSH
7260: LD_INT 92
7262: PPUSH
7263: LD_INT 176
7265: PPUSH
7266: CALL_OW 171
// end ;
7270: GO 7222
7272: POP
7273: POP
// wait ( 0 0$10 ) ;
7274: LD_INT 350
7276: PPUSH
7277: CALL_OW 67
// tmp := [ Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Kurt , Aviradze ] union heikeSecondSquad ;
7281: LD_ADDR_VAR 0 5
7285: PUSH
7286: LD_EXP 18
7290: PUSH
7291: LD_EXP 19
7295: PUSH
7296: LD_EXP 20
7300: PUSH
7301: LD_EXP 21
7305: PUSH
7306: LD_EXP 22
7310: PUSH
7311: LD_EXP 23
7315: PUSH
7316: LD_EXP 24
7320: PUSH
7321: LD_EXP 25
7325: PUSH
7326: LD_EXP 27
7330: PUSH
7331: LD_EXP 28
7335: PUSH
7336: EMPTY
7337: LIST
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: LIST
7343: LIST
7344: LIST
7345: LIST
7346: LIST
7347: PUSH
7348: LD_EXP 29
7352: UNION
7353: ST_TO_ADDR
// tmp := tmp diff 0 ;
7354: LD_ADDR_VAR 0 5
7358: PUSH
7359: LD_VAR 0 5
7363: PUSH
7364: LD_INT 0
7366: DIFF
7367: ST_TO_ADDR
// for i in heikeVehicles do
7368: LD_ADDR_VAR 0 2
7372: PUSH
7373: LD_EXP 30
7377: PUSH
7378: FOR_IN
7379: IFFALSE 7645
// begin if not tmp then
7381: LD_VAR 0 5
7385: NOT
7386: IFFALSE 7390
// continue ;
7388: GO 7378
// PrepareTank ( 2 , i [ 5 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] , 34 ) ;
7390: LD_INT 2
7392: PPUSH
7393: LD_VAR 0 2
7397: PUSH
7398: LD_INT 5
7400: ARRAY
7401: PPUSH
7402: LD_VAR 0 2
7406: PUSH
7407: LD_INT 1
7409: ARRAY
7410: PPUSH
7411: LD_VAR 0 2
7415: PUSH
7416: LD_INT 2
7418: ARRAY
7419: PPUSH
7420: LD_VAR 0 2
7424: PUSH
7425: LD_INT 3
7427: ARRAY
7428: PPUSH
7429: LD_VAR 0 2
7433: PUSH
7434: LD_INT 4
7436: ARRAY
7437: PPUSH
7438: LD_INT 34
7440: PPUSH
7441: CALL 399 0 7
// veh := CreateVehicle ;
7445: LD_ADDR_VAR 0 4
7449: PUSH
7450: CALL_OW 45
7454: ST_TO_ADDR
// if i [ 4 ] in [ ru_cargo_bay , ar_cargo_bay , us_cargo_bay ] then
7455: LD_VAR 0 2
7459: PUSH
7460: LD_INT 4
7462: ARRAY
7463: PUSH
7464: LD_INT 51
7466: PUSH
7467: LD_INT 32
7469: PUSH
7470: LD_INT 12
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: IN
7478: IFFALSE 7558
// begin if i [ 7 ] [ 1 ] then
7480: LD_VAR 0 2
7484: PUSH
7485: LD_INT 7
7487: ARRAY
7488: PUSH
7489: LD_INT 1
7491: ARRAY
7492: IFFALSE 7519
// AddCargo ( veh , mat_cans , i [ 7 ] [ 1 ] ) ;
7494: LD_VAR 0 4
7498: PPUSH
7499: LD_INT 1
7501: PPUSH
7502: LD_VAR 0 2
7506: PUSH
7507: LD_INT 7
7509: ARRAY
7510: PUSH
7511: LD_INT 1
7513: ARRAY
7514: PPUSH
7515: CALL_OW 291
// if i [ 7 ] [ 2 ] then
7519: LD_VAR 0 2
7523: PUSH
7524: LD_INT 7
7526: ARRAY
7527: PUSH
7528: LD_INT 2
7530: ARRAY
7531: IFFALSE 7558
// AddCargo ( veh , mat_oil , i [ 7 ] [ 2 ] ) ;
7533: LD_VAR 0 4
7537: PPUSH
7538: LD_INT 2
7540: PPUSH
7541: LD_VAR 0 2
7545: PUSH
7546: LD_INT 7
7548: ARRAY
7549: PUSH
7550: LD_INT 2
7552: ARRAY
7553: PPUSH
7554: CALL_OW 291
// end ; SetDir ( veh , 3 ) ;
7558: LD_VAR 0 4
7562: PPUSH
7563: LD_INT 3
7565: PPUSH
7566: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7570: LD_VAR 0 4
7574: PPUSH
7575: LD_INT 8
7577: PPUSH
7578: LD_INT 0
7580: PPUSH
7581: CALL_OW 49
// PlaceHumanInUnit ( tmp [ 1 ] , veh ) ;
7585: LD_VAR 0 5
7589: PUSH
7590: LD_INT 1
7592: ARRAY
7593: PPUSH
7594: LD_VAR 0 4
7598: PPUSH
7599: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
7603: LD_ADDR_VAR 0 5
7607: PUSH
7608: LD_VAR 0 5
7612: PPUSH
7613: LD_INT 1
7615: PPUSH
7616: CALL_OW 3
7620: ST_TO_ADDR
// ComAgressiveMove ( veh , 133 , 7 ) ;
7621: LD_VAR 0 4
7625: PPUSH
7626: LD_INT 133
7628: PPUSH
7629: LD_INT 7
7631: PPUSH
7632: CALL_OW 114
// wait ( 0 0$1 ) ;
7636: LD_INT 35
7638: PPUSH
7639: CALL_OW 67
// end ;
7643: GO 7378
7645: POP
7646: POP
// if tmp then
7647: LD_VAR 0 5
7651: IFFALSE 7707
// for i in tmp do
7653: LD_ADDR_VAR 0 2
7657: PUSH
7658: LD_VAR 0 5
7662: PUSH
7663: FOR_IN
7664: IFFALSE 7705
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_INT 10
7673: PPUSH
7674: LD_INT 0
7676: PPUSH
7677: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7681: LD_VAR 0 2
7685: PPUSH
7686: LD_INT 146
7688: PPUSH
7689: LD_INT 7
7691: PPUSH
7692: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7696: LD_INT 18
7698: PPUSH
7699: CALL_OW 67
// end ;
7703: GO 7663
7705: POP
7706: POP
// if heikeApes then
7707: LD_EXP 31
7711: IFFALSE 7767
// for i in heikeApes do
7713: LD_ADDR_VAR 0 2
7717: PUSH
7718: LD_EXP 31
7722: PUSH
7723: FOR_IN
7724: IFFALSE 7765
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7726: LD_VAR 0 2
7730: PPUSH
7731: LD_INT 10
7733: PPUSH
7734: LD_INT 0
7736: PPUSH
7737: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7741: LD_VAR 0 2
7745: PPUSH
7746: LD_INT 146
7748: PPUSH
7749: LD_INT 7
7751: PPUSH
7752: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7756: LD_INT 18
7758: PPUSH
7759: CALL_OW 67
// end ;
7763: GO 7723
7765: POP
7766: POP
// DialogueOn ;
7767: CALL_OW 6
// Say ( Heike , DH-outpost-a-1 ) ;
7771: LD_EXP 18
7775: PPUSH
7776: LD_STRING DH-outpost-a-1
7778: PPUSH
7779: CALL_OW 88
// DialogueOff ;
7783: CALL_OW 7
// RemoveSeeing ( 133 , 2 , 2 ) ;
7787: LD_INT 133
7789: PPUSH
7790: LD_INT 2
7792: PPUSH
7793: LD_INT 2
7795: PPUSH
7796: CALL_OW 331
// InGameOff ;
7800: CALL_OW 9
// music_nat := 0 ;
7804: LD_ADDR_OWVAR 71
7808: PUSH
7809: LD_INT 0
7811: ST_TO_ADDR
// music_class := 0 ;
7812: LD_ADDR_OWVAR 72
7816: PUSH
7817: LD_INT 0
7819: ST_TO_ADDR
// ChangeMissionObjectives ( Outposts ) ;
7820: LD_STRING Outposts
7822: PPUSH
7823: CALL_OW 337
// SaveForQuickRestart ;
7827: CALL_OW 22
// end ;
7831: LD_VAR 0 1
7835: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 20 ] ] ) and ibrahimOnRuSide and IsOk ( Ibrahim ) do
7836: LD_INT 22
7838: PUSH
7839: LD_INT 2
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 91
7848: PUSH
7849: LD_EXP 21
7853: PUSH
7854: LD_INT 20
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: LIST
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 69
7870: PUSH
7871: LD_EXP 3
7875: AND
7876: PUSH
7877: LD_EXP 21
7881: PPUSH
7882: CALL_OW 302
7886: AND
7887: IFFALSE 7975
7889: GO 7891
7891: DISABLE
// begin IbrahimBetrayal ;
7892: CALL 7976 0 0
// repeat wait ( 0 0$1 ) ;
7896: LD_INT 35
7898: PPUSH
7899: CALL_OW 67
// until IsDead ( Ibrahim ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 6 ] ] ) ;
7903: LD_EXP 21
7907: PPUSH
7908: CALL_OW 301
7912: PUSH
7913: LD_INT 22
7915: PUSH
7916: LD_INT 2
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: PUSH
7923: LD_INT 91
7925: PUSH
7926: LD_EXP 21
7930: PUSH
7931: LD_INT 6
7933: PUSH
7934: EMPTY
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: PPUSH
7943: CALL_OW 69
7947: OR
7948: IFFALSE 7896
// if IsDead ( Ibrahim ) then
7950: LD_EXP 21
7954: PPUSH
7955: CALL_OW 301
7959: IFFALSE 7963
// exit ;
7961: GO 7975
// SetSide ( Ibrahim , 2 ) ;
7963: LD_EXP 21
7967: PPUSH
7968: LD_INT 2
7970: PPUSH
7971: CALL_OW 235
// end ;
7975: END
// export function IbrahimBetrayal ; var i , tmp ; begin
7976: LD_INT 0
7978: PPUSH
7979: PPUSH
7980: PPUSH
// PlaceSeeing ( 122 , 77 , 2 , - 6 ) ;
7981: LD_INT 122
7983: PPUSH
7984: LD_INT 77
7986: PPUSH
7987: LD_INT 2
7989: PPUSH
7990: LD_INT 6
7992: NEG
7993: PPUSH
7994: CALL_OW 330
// ComMoveXY ( Ibrahim , 123 , 79 ) ;
7998: LD_EXP 21
8002: PPUSH
8003: LD_INT 123
8005: PPUSH
8006: LD_INT 79
8008: PPUSH
8009: CALL_OW 111
// AddComTurnXY ( Ibrahim , 125 , 82 ) ;
8013: LD_EXP 21
8017: PPUSH
8018: LD_INT 125
8020: PPUSH
8021: LD_INT 82
8023: PPUSH
8024: CALL_OW 178
// wait ( 0 0$2 ) ;
8028: LD_INT 70
8030: PPUSH
8031: CALL_OW 67
// ComTurnUnit ( ruSol , Ibrahim ) ;
8035: LD_EXP 41
8039: PPUSH
8040: LD_EXP 21
8044: PPUSH
8045: CALL_OW 119
// Say ( ruSol , DRum-outpost-b-3 ) ;
8049: LD_EXP 41
8053: PPUSH
8054: LD_STRING DRum-outpost-b-3
8056: PPUSH
8057: CALL_OW 88
// tmp := [ HexInfo ( 125 , 76 ) , HexInfo ( 125 , 79 ) , HexInfo ( 125 , 82 ) ] ;
8061: LD_ADDR_VAR 0 3
8065: PUSH
8066: LD_INT 125
8068: PPUSH
8069: LD_INT 76
8071: PPUSH
8072: CALL_OW 428
8076: PUSH
8077: LD_INT 125
8079: PPUSH
8080: LD_INT 79
8082: PPUSH
8083: CALL_OW 428
8087: PUSH
8088: LD_INT 125
8090: PPUSH
8091: LD_INT 82
8093: PPUSH
8094: CALL_OW 428
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: LIST
8103: ST_TO_ADDR
// for i in tmp do
8104: LD_ADDR_VAR 0 2
8108: PUSH
8109: LD_VAR 0 3
8113: PUSH
8114: FOR_IN
8115: IFFALSE 8131
// SetLives ( i , 200 ) ;
8117: LD_VAR 0 2
8121: PPUSH
8122: LD_INT 200
8124: PPUSH
8125: CALL_OW 234
8129: GO 8114
8131: POP
8132: POP
// Say ( Ibrahim , DI-outpost-b-4 ) ;
8133: LD_EXP 21
8137: PPUSH
8138: LD_STRING DI-outpost-b-4
8140: PPUSH
8141: CALL_OW 88
// SetSide ( Ibrahim , 5 ) ;
8145: LD_EXP 21
8149: PPUSH
8150: LD_INT 5
8152: PPUSH
8153: CALL_OW 235
// ComFree ( [ Ibrahim , ruSol ] ) ;
8157: LD_EXP 21
8161: PUSH
8162: LD_EXP 41
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PPUSH
8171: CALL_OW 139
// RemoveSeeing ( 122 , 77 , 2 ) ;
8175: LD_INT 122
8177: PPUSH
8178: LD_INT 77
8180: PPUSH
8181: LD_INT 2
8183: PPUSH
8184: CALL_OW 331
// if Givi then
8188: LD_EXP 19
8192: IFFALSE 8208
// Say ( Givi , DG-1-outpost-b-5 ) else
8194: LD_EXP 19
8198: PPUSH
8199: LD_STRING DG-1-outpost-b-5
8201: PPUSH
8202: CALL_OW 88
8206: GO 8273
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-outpost-b-a-5 ) then
8208: LD_EXP 29
8212: PPUSH
8213: LD_INT 26
8215: PUSH
8216: LD_INT 2
8218: PUSH
8219: EMPTY
8220: LIST
8221: LIST
8222: PPUSH
8223: CALL_OW 72
8227: PUSH
8228: LD_INT 1
8230: ARRAY
8231: PPUSH
8232: LD_STRING DArf-outpost-b-a-5
8234: PPUSH
8235: CALL_OW 88
8239: NOT
8240: IFFALSE 8273
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-outpost-b-a-5 ) ;
8242: LD_EXP 29
8246: PPUSH
8247: LD_INT 26
8249: PUSH
8250: LD_INT 1
8252: PUSH
8253: EMPTY
8254: LIST
8255: LIST
8256: PPUSH
8257: CALL_OW 72
8261: PUSH
8262: LD_INT 1
8264: ARRAY
8265: PPUSH
8266: LD_STRING DArm-outpost-b-a-5
8268: PPUSH
8269: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
8273: LD_INT 35
8275: PPUSH
8276: CALL_OW 67
// until IsDead ( Ibrahim ) or ( GetDistUnits ( Heike , Ibrahim ) < 6 and IsOk ( Ibrahim ) ) ;
8280: LD_EXP 21
8284: PPUSH
8285: CALL_OW 301
8289: PUSH
8290: LD_EXP 18
8294: PPUSH
8295: LD_EXP 21
8299: PPUSH
8300: CALL_OW 296
8304: PUSH
8305: LD_INT 6
8307: LESS
8308: PUSH
8309: LD_EXP 21
8313: PPUSH
8314: CALL_OW 302
8318: AND
8319: OR
8320: IFFALSE 8273
// if IsDead ( Ibrahim ) then
8322: LD_EXP 21
8326: PPUSH
8327: CALL_OW 301
8331: IFFALSE 8347
// begin Say ( Heike , DH-ibrahimdead-1 ) ;
8333: LD_EXP 18
8337: PPUSH
8338: LD_STRING DH-ibrahimdead-1
8340: PPUSH
8341: CALL_OW 88
// exit ;
8345: GO 8392
// end ; CenterNowOnUnits ( Ibrahim ) ;
8347: LD_EXP 21
8351: PPUSH
8352: CALL_OW 87
// Say ( Ibrahim , DI-ibrahimlives-1 ) ;
8356: LD_EXP 21
8360: PPUSH
8361: LD_STRING DI-ibrahimlives-1
8363: PPUSH
8364: CALL_OW 88
// Say ( Heike , DH-Ibrahimlives-2 ) ;
8368: LD_EXP 18
8372: PPUSH
8373: LD_STRING DH-Ibrahimlives-2
8375: PPUSH
8376: CALL_OW 88
// SetSide ( Ibrahim , 2 ) ;
8380: LD_EXP 21
8384: PPUSH
8385: LD_INT 2
8387: PPUSH
8388: CALL_OW 235
// end ;
8392: LD_VAR 0 1
8396: RET
// every 0 0$1 trigger FilterUnitsInArea ( outerArea , [ f_side , 2 ] ) or tick >= [ 9 9$00 , 8 8$00 , 8 8$00 ] [ Difficulty ] do
8397: LD_INT 11
8399: PPUSH
8400: LD_INT 22
8402: PUSH
8403: LD_INT 2
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PPUSH
8410: CALL_OW 70
8414: PUSH
8415: LD_OWVAR 1
8419: PUSH
8420: LD_INT 18900
8422: PUSH
8423: LD_INT 16800
8425: PUSH
8426: LD_INT 16800
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: PUSH
8434: LD_OWVAR 67
8438: ARRAY
8439: GREATEREQUAL
8440: OR
8441: IFFALSE 8848
8443: GO 8445
8445: DISABLE
// begin outerAreaAchived := true ;
8446: LD_ADDR_EXP 15
8450: PUSH
8451: LD_INT 1
8453: ST_TO_ADDR
// wait ( 0 0$20 ) ;
8454: LD_INT 700
8456: PPUSH
8457: CALL_OW 67
// DialogueOn ;
8461: CALL_OW 6
// SayRadio ( Shariff , DShar-radio-1 ) ;
8465: LD_EXP 26
8469: PPUSH
8470: LD_STRING DShar-radio-1
8472: PPUSH
8473: CALL_OW 94
// SayRadio ( Shariff , DShar-radio-2 ) ;
8477: LD_EXP 26
8481: PPUSH
8482: LD_STRING DShar-radio-2
8484: PPUSH
8485: CALL_OW 94
// Say ( Heike , DH-radio-2 ) ;
8489: LD_EXP 18
8493: PPUSH
8494: LD_STRING DH-radio-2
8496: PPUSH
8497: CALL_OW 88
// DialogueOff ;
8501: CALL_OW 7
// ChangeMissionObjectives ( Gaidar ) ;
8505: LD_STRING Gaidar
8507: PPUSH
8508: CALL_OW 337
// if Difficulty < 3 then
8512: LD_OWVAR 67
8516: PUSH
8517: LD_INT 3
8519: LESS
8520: IFFALSE 8586
// begin DialogueOn ;
8522: CALL_OW 6
// PlaceSeeing ( 11 , 14 , 2 , - 6 ) ;
8526: LD_INT 11
8528: PPUSH
8529: LD_INT 14
8531: PPUSH
8532: LD_INT 2
8534: PPUSH
8535: LD_INT 6
8537: NEG
8538: PPUSH
8539: CALL_OW 330
// RemoveSeeing ( 11 , 14 , 2 ) ;
8543: LD_INT 11
8545: PPUSH
8546: LD_INT 14
8548: PPUSH
8549: LD_INT 2
8551: PPUSH
8552: CALL_OW 331
// CenterOnXY ( 11 , 14 ) ;
8556: LD_INT 11
8558: PPUSH
8559: LD_INT 14
8561: PPUSH
8562: CALL_OW 84
// dwait ( 0 0$1 ) ;
8566: LD_INT 35
8568: PPUSH
8569: CALL_OW 68
// CenterNowOnUnits ( Heike ) ;
8573: LD_EXP 18
8577: PPUSH
8578: CALL_OW 87
// DialogueOff ;
8582: CALL_OW 7
// end ; wait ( 0 0$30 + rand ( 0 0$10 , 0 0$15 ) * Difficulty ) ;
8586: LD_INT 1050
8588: PUSH
8589: LD_INT 350
8591: PPUSH
8592: LD_INT 525
8594: PPUSH
8595: CALL_OW 12
8599: PUSH
8600: LD_OWVAR 67
8604: MUL
8605: PLUS
8606: PPUSH
8607: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8611: LD_INT 35
8613: PPUSH
8614: CALL_OW 67
// until HexInfo ( 2 , 1 ) = 0 ;
8618: LD_INT 2
8620: PPUSH
8621: LD_INT 1
8623: PPUSH
8624: CALL_OW 428
8628: PUSH
8629: LD_INT 0
8631: EQUAL
8632: IFFALSE 8611
// SetDir ( Gaidar , 2 ) ;
8634: LD_EXP 34
8638: PPUSH
8639: LD_INT 2
8641: PPUSH
8642: CALL_OW 233
// PlaceUnitXY ( Gaidar , 2 , 1 , false ) ;
8646: LD_EXP 34
8650: PPUSH
8651: LD_INT 2
8653: PPUSH
8654: LD_INT 1
8656: PPUSH
8657: LD_INT 0
8659: PPUSH
8660: CALL_OW 48
// ComMoveXY ( Gaidar , 19 , 24 ) ;
8664: LD_EXP 34
8668: PPUSH
8669: LD_INT 19
8671: PPUSH
8672: LD_INT 24
8674: PPUSH
8675: CALL_OW 111
// AddComWait ( Gaidar , 0 0$6 ) ;
8679: LD_EXP 34
8683: PPUSH
8684: LD_INT 210
8686: PPUSH
8687: CALL_OW 202
// AddComMoveXY ( Gaidar , 38 , 47 ) ;
8691: LD_EXP 34
8695: PPUSH
8696: LD_INT 38
8698: PPUSH
8699: LD_INT 47
8701: PPUSH
8702: CALL_OW 171
// AddComMoveXY ( Gaidar , 32 , 59 ) ;
8706: LD_EXP 34
8710: PPUSH
8711: LD_INT 32
8713: PPUSH
8714: LD_INT 59
8716: PPUSH
8717: CALL_OW 171
// AddComWait ( Gaidar , 0 0$10 ) ;
8721: LD_EXP 34
8725: PPUSH
8726: LD_INT 350
8728: PPUSH
8729: CALL_OW 202
// AddComMoveXY ( Gaidar , 62 , 116 ) ;
8733: LD_EXP 34
8737: PPUSH
8738: LD_INT 62
8740: PPUSH
8741: LD_INT 116
8743: PPUSH
8744: CALL_OW 171
// AddComMoveXY ( Gaidar , 92 , 177 ) ;
8748: LD_EXP 34
8752: PPUSH
8753: LD_INT 92
8755: PPUSH
8756: LD_INT 177
8758: PPUSH
8759: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8763: LD_INT 35
8765: PPUSH
8766: CALL_OW 67
// until IsDead ( Gaidar ) or IsAt ( Gaidar , 92 , 177 ) ;
8770: LD_EXP 34
8774: PPUSH
8775: CALL_OW 301
8779: PUSH
8780: LD_EXP 34
8784: PPUSH
8785: LD_INT 92
8787: PPUSH
8788: LD_INT 177
8790: PPUSH
8791: CALL_OW 307
8795: OR
8796: IFFALSE 8763
// if IsAt ( Gaidar , 92 , 177 ) then
8798: LD_EXP 34
8802: PPUSH
8803: LD_INT 92
8805: PPUSH
8806: LD_INT 177
8808: PPUSH
8809: CALL_OW 307
8813: IFFALSE 8826
// begin RemoveUnit ( Gaidar ) ;
8815: LD_EXP 34
8819: PPUSH
8820: CALL_OW 64
// exit ;
8824: GO 8848
// end ; gaidarKilled := true ;
8826: LD_ADDR_EXP 14
8830: PUSH
8831: LD_INT 1
8833: ST_TO_ADDR
// ChangeMissionObjectives ( GaidarKilled ) ;
8834: LD_STRING GaidarKilled
8836: PPUSH
8837: CALL_OW 337
// SetAchievement ( ACH_COMMISAR ) ;
8841: LD_STRING ACH_COMMISAR
8843: PPUSH
8844: CALL_OW 543
// end ;
8848: END
// every 0 0$1 trigger See ( 2 , Gaidar ) do
8849: LD_INT 2
8851: PPUSH
8852: LD_EXP 34
8856: PPUSH
8857: CALL_OW 292
8861: IFFALSE 8878
8863: GO 8865
8865: DISABLE
// Say ( Gaidar , DT-objective-1 ) ;
8866: LD_EXP 34
8870: PPUSH
8871: LD_STRING DT-objective-1
8873: PPUSH
8874: CALL_OW 88
8878: END
// every 0 0$5 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) do
8879: LD_INT 22
8881: PUSH
8882: LD_INT 2
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: LD_INT 2
8891: PUSH
8892: LD_INT 95
8894: PUSH
8895: LD_INT 5
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: PUSH
8902: LD_INT 95
8904: PUSH
8905: LD_INT 6
8907: PUSH
8908: EMPTY
8909: LIST
8910: LIST
8911: PUSH
8912: LD_INT 95
8914: PUSH
8915: LD_INT 7
8917: PUSH
8918: EMPTY
8919: LIST
8920: LIST
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: PPUSH
8932: CALL_OW 69
8936: IFFALSE 8965
8938: GO 8940
8940: DISABLE
// begin Say ( Heike , DH-outpost-last-1 ) ;
8941: LD_EXP 18
8945: PPUSH
8946: LD_STRING DH-outpost-last-1
8948: PPUSH
8949: CALL_OW 88
// SayRadio ( Burlak , DB-outpost-last-2 ) ;
8953: LD_EXP 33
8957: PPUSH
8958: LD_STRING DB-outpost-last-2
8960: PPUSH
8961: CALL_OW 94
// end ;
8965: END
// every 0 0$1 trigger GetLives ( ruMainBase ) < 999 or GetSide ( ruMainBase ) = 2 do var i , tmp ;
8966: LD_INT 200
8968: PPUSH
8969: CALL_OW 256
8973: PUSH
8974: LD_INT 999
8976: LESS
8977: PUSH
8978: LD_INT 200
8980: PPUSH
8981: CALL_OW 255
8985: PUSH
8986: LD_INT 2
8988: EQUAL
8989: OR
8990: IFFALSE 9163
8992: GO 8994
8994: DISABLE
8995: LD_INT 0
8997: PPUSH
8998: PPUSH
// begin if not earlyEscape then
8999: LD_EXP 16
9003: NOT
9004: IFFALSE 9030
// begin SayRadio ( Burlak , DB-end-1 ) ;
9006: LD_EXP 33
9010: PPUSH
9011: LD_STRING DB-end-1
9013: PPUSH
9014: CALL_OW 94
// Say ( Heike , DH-end-2 ) ;
9018: LD_EXP 18
9022: PPUSH
9023: LD_STRING DH-end-2
9025: PPUSH
9026: CALL_OW 88
// end ; if tick <= 15 15$00 then
9030: LD_OWVAR 1
9034: PUSH
9035: LD_INT 31500
9037: LESSEQUAL
9038: IFFALSE 9047
// SetAchievement ( ACH_FIST ) ;
9040: LD_STRING ACH_FIST
9042: PPUSH
9043: CALL_OW 543
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9047: LD_ADDR_VAR 0 2
9051: PUSH
9052: LD_INT 22
9054: PUSH
9055: LD_INT 3
9057: PUSH
9058: EMPTY
9059: LIST
9060: LIST
9061: PUSH
9062: LD_INT 3
9064: PUSH
9065: LD_INT 21
9067: PUSH
9068: LD_INT 3
9070: PUSH
9071: EMPTY
9072: LIST
9073: LIST
9074: PUSH
9075: EMPTY
9076: LIST
9077: LIST
9078: PUSH
9079: EMPTY
9080: LIST
9081: LIST
9082: PPUSH
9083: CALL_OW 69
9087: ST_TO_ADDR
// if not tmp then
9088: LD_VAR 0 2
9092: NOT
9093: IFFALSE 9097
// exit ;
9095: GO 9163
// for i in tmp do
9097: LD_ADDR_VAR 0 1
9101: PUSH
9102: LD_VAR 0 2
9106: PUSH
9107: FOR_IN
9108: IFFALSE 9161
// begin SetTag ( i , tEscape ) ;
9110: LD_VAR 0 1
9114: PPUSH
9115: LD_EXP 17
9119: PPUSH
9120: CALL_OW 109
// if IsInUnit ( i ) then
9124: LD_VAR 0 1
9128: PPUSH
9129: CALL_OW 310
9133: IFFALSE 9144
// ComExitBuilding ( i ) ;
9135: LD_VAR 0 1
9139: PPUSH
9140: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9144: LD_VAR 0 1
9148: PPUSH
9149: LD_INT 92
9151: PPUSH
9152: LD_INT 177
9154: PPUSH
9155: CALL_OW 171
// end ;
9159: GO 9107
9161: POP
9162: POP
// end ;
9163: PPOPN 2
9165: END
// every 0 0$1 trigger FilterUnitsInArea ( zone1 , [ f_side , 2 ] ) and not outerAreaAchived and IsOk ( Kurt ) do
9166: LD_INT 4
9168: PPUSH
9169: LD_INT 22
9171: PUSH
9172: LD_INT 2
9174: PUSH
9175: EMPTY
9176: LIST
9177: LIST
9178: PPUSH
9179: CALL_OW 70
9183: PUSH
9184: LD_EXP 15
9188: NOT
9189: AND
9190: PUSH
9191: LD_EXP 27
9195: PPUSH
9196: CALL_OW 302
9200: AND
9201: IFFALSE 9441
9203: GO 9205
9205: DISABLE
// begin DialogueOn ;
9206: CALL_OW 6
// PlaceSeeing ( 111 , 54 , 2 , - 16 ) ;
9210: LD_INT 111
9212: PPUSH
9213: LD_INT 54
9215: PPUSH
9216: LD_INT 2
9218: PPUSH
9219: LD_INT 16
9221: NEG
9222: PPUSH
9223: CALL_OW 330
// CenterNowOnXY ( 111 , 53 ) ;
9227: LD_INT 111
9229: PPUSH
9230: LD_INT 53
9232: PPUSH
9233: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
9237: LD_INT 10
9239: PPUSH
9240: CALL_OW 68
// Say ( Kurt , DKs-Hannibal-1 ) ;
9244: LD_EXP 27
9248: PPUSH
9249: LD_STRING DKs-Hannibal-1
9251: PPUSH
9252: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-2 ) ;
9256: LD_EXP 27
9260: PPUSH
9261: LD_STRING DKs-Hannibal-2
9263: PPUSH
9264: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-3 ) ;
9268: LD_EXP 27
9272: PPUSH
9273: LD_STRING DKs-Hannibal-3
9275: PPUSH
9276: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-4 ) ;
9280: LD_EXP 27
9284: PPUSH
9285: LD_STRING DKs-Hannibal-4
9287: PPUSH
9288: CALL_OW 88
// dwait ( 0 0$1 ) ;
9292: LD_INT 35
9294: PPUSH
9295: CALL_OW 68
// RemoveSeeing ( 111 , 54 , 2 ) ;
9299: LD_INT 111
9301: PPUSH
9302: LD_INT 54
9304: PPUSH
9305: LD_INT 2
9307: PPUSH
9308: CALL_OW 331
// PlaceSeeing ( 173 , 76 , 2 , - 12 ) ;
9312: LD_INT 173
9314: PPUSH
9315: LD_INT 76
9317: PPUSH
9318: LD_INT 2
9320: PPUSH
9321: LD_INT 12
9323: NEG
9324: PPUSH
9325: CALL_OW 330
// RemoveSeeing ( 173 , 76 , 2 ) ;
9329: LD_INT 173
9331: PPUSH
9332: LD_INT 76
9334: PPUSH
9335: LD_INT 2
9337: PPUSH
9338: CALL_OW 331
// CenterNowOnXY ( 173 , 76 ) ;
9342: LD_INT 173
9344: PPUSH
9345: LD_INT 76
9347: PPUSH
9348: CALL_OW 86
// Say ( Kurt , DKs-Hannibal-5 ) ;
9352: LD_EXP 27
9356: PPUSH
9357: LD_STRING DKs-Hannibal-5
9359: PPUSH
9360: CALL_OW 88
// if Kamil and not FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_flame_thrower ] ] ) then
9364: LD_EXP 22
9368: PUSH
9369: LD_INT 22
9371: PUSH
9372: LD_INT 2
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: PUSH
9379: LD_INT 34
9381: PUSH
9382: LD_INT 26
9384: PUSH
9385: EMPTY
9386: LIST
9387: LIST
9388: PUSH
9389: EMPTY
9390: LIST
9391: LIST
9392: PPUSH
9393: CALL_OW 69
9397: NOT
9398: AND
9399: IFFALSE 9437
// begin Say ( Kamil , DKam-Hannibal-a-6 ) ;
9401: LD_EXP 22
9405: PPUSH
9406: LD_STRING DKam-Hannibal-a-6
9408: PPUSH
9409: CALL_OW 88
// Say ( Kamil , DKam-Hannibal-a-7 ) ;
9413: LD_EXP 22
9417: PPUSH
9418: LD_STRING DKam-Hannibal-a-7
9420: PPUSH
9421: CALL_OW 88
// Say ( Givi , DG-Hannibal-a-8 ) ;
9425: LD_EXP 19
9429: PPUSH
9430: LD_STRING DG-Hannibal-a-8
9432: PPUSH
9433: CALL_OW 88
// end ; DialogueOff ;
9437: CALL_OW 7
// end ;
9441: END
// every 0 0$1 trigger IsOk ( ruSecBase ) and IsOk ( ruMainBase ) and FilterUnitsInArea ( showDefenceArea , [ f_type , unit_building ] ) > 2 and FilterUnitsInArea ( forestArea , [ f_side , 2 ] ) > 3 do
9442: LD_INT 225
9444: PPUSH
9445: CALL_OW 302
9449: PUSH
9450: LD_INT 200
9452: PPUSH
9453: CALL_OW 302
9457: AND
9458: PUSH
9459: LD_INT 12
9461: PPUSH
9462: LD_INT 21
9464: PUSH
9465: LD_INT 3
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: PPUSH
9472: CALL_OW 70
9476: PUSH
9477: LD_INT 2
9479: GREATER
9480: AND
9481: PUSH
9482: LD_INT 13
9484: PPUSH
9485: LD_INT 22
9487: PUSH
9488: LD_INT 2
9490: PUSH
9491: EMPTY
9492: LIST
9493: LIST
9494: PPUSH
9495: CALL_OW 70
9499: PUSH
9500: LD_INT 3
9502: GREATER
9503: AND
9504: IFFALSE 9517
9506: GO 9508
9508: DISABLE
// hannibalPath := true ;
9509: LD_ADDR_EXP 9
9513: PUSH
9514: LD_INT 1
9516: ST_TO_ADDR
9517: END
// every 0 0$3 trigger hannibalPath and FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) do var i , tmp , hasFlameThrower ;
9518: LD_EXP 9
9522: PUSH
9523: LD_INT 6
9525: PPUSH
9526: LD_INT 22
9528: PUSH
9529: LD_INT 2
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PPUSH
9536: CALL_OW 70
9540: AND
9541: IFFALSE 9878
9543: GO 9545
9545: DISABLE
9546: LD_INT 0
9548: PPUSH
9549: PPUSH
9550: PPUSH
// begin tmp := FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) ;
9551: LD_ADDR_VAR 0 2
9555: PUSH
9556: LD_INT 6
9558: PPUSH
9559: LD_INT 22
9561: PUSH
9562: LD_INT 2
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: PPUSH
9569: CALL_OW 70
9573: ST_TO_ADDR
// hasFlameThrower := UnitFilter ( tmp , [ f_weapon , ar_flame_thrower ] ) > 0 ;
9574: LD_ADDR_VAR 0 3
9578: PUSH
9579: LD_VAR 0 2
9583: PPUSH
9584: LD_INT 34
9586: PUSH
9587: LD_INT 26
9589: PUSH
9590: EMPTY
9591: LIST
9592: LIST
9593: PPUSH
9594: CALL_OW 72
9598: PUSH
9599: LD_INT 0
9601: GREATER
9602: ST_TO_ADDR
// Say ( Heike , DH-Cleverattack-1 ) ;
9603: LD_EXP 18
9607: PPUSH
9608: LD_STRING DH-Cleverattack-1
9610: PPUSH
9611: CALL_OW 88
// Say ( Heike , DH-Cleverattack-2 ) ;
9615: LD_EXP 18
9619: PPUSH
9620: LD_STRING DH-Cleverattack-2
9622: PPUSH
9623: CALL_OW 88
// if hasFlameThrower then
9627: LD_VAR 0 3
9631: IFFALSE 9659
// begin SayRadio ( Burlak , DB-Cleverattack-3 ) ;
9633: LD_EXP 33
9637: PPUSH
9638: LD_STRING DB-Cleverattack-3
9640: PPUSH
9641: CALL_OW 94
// Say ( Heike , DH-Cleverattack-4 ) ;
9645: LD_EXP 18
9649: PPUSH
9650: LD_STRING DH-Cleverattack-4
9652: PPUSH
9653: CALL_OW 88
// end else
9657: GO 9683
// begin SayRadio ( Burlak , DB-Cleverattack-a-3 ) ;
9659: LD_EXP 33
9663: PPUSH
9664: LD_STRING DB-Cleverattack-a-3
9666: PPUSH
9667: CALL_OW 94
// Say ( Heike , DH-Cleverattack-a-4 ) ;
9671: LD_EXP 18
9675: PPUSH
9676: LD_STRING DH-Cleverattack-a-4
9678: PPUSH
9679: CALL_OW 88
// end ; if not hasFlameThrower then
9683: LD_VAR 0 3
9687: NOT
9688: IFFALSE 9692
// exit ;
9690: GO 9878
// earlyEscape := true ;
9692: LD_ADDR_EXP 16
9696: PUSH
9697: LD_INT 1
9699: ST_TO_ADDR
// wait ( 0 0$4 ) ;
9700: LD_INT 140
9702: PPUSH
9703: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ] ) diff [ Ibrahim , Kuzmov , Gaidar ] ;
9707: LD_ADDR_VAR 0 2
9711: PUSH
9712: LD_INT 22
9714: PUSH
9715: LD_INT 3
9717: PUSH
9718: EMPTY
9719: LIST
9720: LIST
9721: PUSH
9722: LD_INT 2
9724: PUSH
9725: LD_INT 25
9727: PUSH
9728: LD_INT 1
9730: PUSH
9731: EMPTY
9732: LIST
9733: LIST
9734: PUSH
9735: LD_INT 25
9737: PUSH
9738: LD_INT 2
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: PUSH
9745: LD_INT 25
9747: PUSH
9748: LD_INT 4
9750: PUSH
9751: EMPTY
9752: LIST
9753: LIST
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: LIST
9759: LIST
9760: PUSH
9761: EMPTY
9762: LIST
9763: LIST
9764: PPUSH
9765: CALL_OW 69
9769: PUSH
9770: LD_EXP 21
9774: PUSH
9775: LD_EXP 35
9779: PUSH
9780: LD_EXP 34
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: LIST
9789: DIFF
9790: ST_TO_ADDR
// for i in tmp do
9791: LD_ADDR_VAR 0 1
9795: PUSH
9796: LD_VAR 0 2
9800: PUSH
9801: FOR_IN
9802: IFFALSE 9876
// begin if Prob ( 40 + 10 * Difficulty ) then
9804: LD_INT 40
9806: PUSH
9807: LD_INT 10
9809: PUSH
9810: LD_OWVAR 67
9814: MUL
9815: PLUS
9816: PPUSH
9817: CALL_OW 13
9821: IFFALSE 9825
// continue ;
9823: GO 9801
// SetTag ( i , tEscape ) ;
9825: LD_VAR 0 1
9829: PPUSH
9830: LD_EXP 17
9834: PPUSH
9835: CALL_OW 109
// if IsInUnit ( i ) then
9839: LD_VAR 0 1
9843: PPUSH
9844: CALL_OW 310
9848: IFFALSE 9859
// ComExitBuilding ( i ) ;
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9859: LD_VAR 0 1
9863: PPUSH
9864: LD_INT 92
9866: PPUSH
9867: LD_INT 177
9869: PPUSH
9870: CALL_OW 171
// end ;
9874: GO 9801
9876: POP
9877: POP
// end ;
9878: PPOPN 3
9880: END
// every 0 0$1 trigger FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do var i ;
9881: LD_INT 9
9883: PPUSH
9884: LD_INT 2
9886: PUSH
9887: LD_INT 22
9889: PUSH
9890: LD_INT 3
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: PUSH
9897: LD_INT 22
9899: PUSH
9900: LD_INT 6
9902: PUSH
9903: EMPTY
9904: LIST
9905: LIST
9906: PUSH
9907: EMPTY
9908: LIST
9909: LIST
9910: LIST
9911: PPUSH
9912: CALL_OW 70
9916: IFFALSE 10014
9918: GO 9920
9920: DISABLE
9921: LD_INT 0
9923: PPUSH
// begin enable ;
9924: ENABLE
// for i in FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do
9925: LD_ADDR_VAR 0 1
9929: PUSH
9930: LD_INT 9
9932: PPUSH
9933: LD_INT 2
9935: PUSH
9936: LD_INT 22
9938: PUSH
9939: LD_INT 3
9941: PUSH
9942: EMPTY
9943: LIST
9944: LIST
9945: PUSH
9946: LD_INT 22
9948: PUSH
9949: LD_INT 6
9951: PUSH
9952: EMPTY
9953: LIST
9954: LIST
9955: PUSH
9956: EMPTY
9957: LIST
9958: LIST
9959: LIST
9960: PPUSH
9961: CALL_OW 70
9965: PUSH
9966: FOR_IN
9967: IFFALSE 10012
// if GetTag ( i ) = tEscape or GetSide ( i ) = 6 then
9969: LD_VAR 0 1
9973: PPUSH
9974: CALL_OW 110
9978: PUSH
9979: LD_EXP 17
9983: EQUAL
9984: PUSH
9985: LD_VAR 0 1
9989: PPUSH
9990: CALL_OW 255
9994: PUSH
9995: LD_INT 6
9997: EQUAL
9998: OR
9999: IFFALSE 10010
// RemoveUnit ( i ) ;
10001: LD_VAR 0 1
10005: PPUSH
10006: CALL_OW 64
10010: GO 9966
10012: POP
10013: POP
// end ;
10014: PPOPN 1
10016: END
// every 0 0$1 trigger Kaia and GetLives ( Kaia ) < 3 do
10017: LD_EXP 23
10021: PUSH
10022: LD_EXP 23
10026: PPUSH
10027: CALL_OW 256
10031: PUSH
10032: LD_INT 3
10034: LESS
10035: AND
10036: IFFALSE 10082
10038: GO 10040
10040: DISABLE
// begin DialogueOn ;
10041: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
10045: LD_EXP 23
10049: PPUSH
10050: CALL_OW 87
// ForceSay ( Kaia , DK-Kkilled-1 ) ;
10054: LD_EXP 23
10058: PPUSH
10059: LD_STRING DK-Kkilled-1
10061: PPUSH
10062: CALL_OW 91
// Say ( Heike , DH-Kkilled-2 ) ;
10066: LD_EXP 18
10070: PPUSH
10071: LD_STRING DH-Kkilled-2
10073: PPUSH
10074: CALL_OW 88
// DialogueOff ;
10078: CALL_OW 7
// end ;
10082: END
// every 0 0$1 trigger kaiaKilledByRussian do
10083: LD_EXP 8
10087: IFFALSE 10104
10089: GO 10091
10091: DISABLE
// Say ( Heike , DH-Kkilled-3 ) ;
10092: LD_EXP 18
10096: PPUSH
10097: LD_STRING DH-Kkilled-3
10099: PPUSH
10100: CALL_OW 88
10104: END
// every 0 0$1 trigger tick >= 22 22$00 do
10105: LD_OWVAR 1
10109: PUSH
10110: LD_INT 46200
10112: GREATEREQUAL
10113: IFFALSE 10142
10115: GO 10117
10117: DISABLE
// begin SayRadio ( Shariff , DShar-slow-1 ) ;
10118: LD_EXP 26
10122: PPUSH
10123: LD_STRING DShar-slow-1
10125: PPUSH
10126: CALL_OW 94
// SayRadio ( Shariff , DShar-slow-2 ) ;
10130: LD_EXP 26
10134: PPUSH
10135: LD_STRING DShar-slow-2
10137: PPUSH
10138: CALL_OW 94
// end ;
10142: END
// every 0 0$1 trigger tick >= [ 40 40$00 , 36 36$00 , 32 32$00 ] [ Difficulty ] do
10143: LD_OWVAR 1
10147: PUSH
10148: LD_INT 84000
10150: PUSH
10151: LD_INT 75600
10153: PUSH
10154: LD_INT 67200
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: LIST
10161: PUSH
10162: LD_OWVAR 67
10166: ARRAY
10167: GREATEREQUAL
10168: IFFALSE 10212
10170: GO 10172
10172: DISABLE
// begin DialogueOn ;
10173: CALL_OW 6
// SayRadio ( Shariff , DShar-fail-1 ) ;
10177: LD_EXP 26
10181: PPUSH
10182: LD_STRING DShar-fail-1
10184: PPUSH
10185: CALL_OW 94
// SayRadio ( Shariff , DShar-fail-2 ) ;
10189: LD_EXP 26
10193: PPUSH
10194: LD_STRING DShar-fail-2
10196: PPUSH
10197: CALL_OW 94
// DialogueOff ;
10201: CALL_OW 7
// YouLost ( Time ) ;
10205: LD_STRING Time
10207: PPUSH
10208: CALL_OW 104
// end ;
10212: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) = 0 do var tmp ;
10213: LD_INT 22
10215: PUSH
10216: LD_INT 3
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: PUSH
10223: LD_INT 2
10225: PUSH
10226: LD_INT 30
10228: PUSH
10229: LD_INT 1
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: PUSH
10236: LD_INT 30
10238: PUSH
10239: LD_INT 0
10241: PUSH
10242: EMPTY
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: LIST
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: PPUSH
10255: CALL_OW 69
10259: PUSH
10260: LD_INT 0
10262: EQUAL
10263: IFFALSE 10754
10265: GO 10267
10267: DISABLE
10268: LD_INT 0
10270: PPUSH
// begin if ( tick + gameTime ) <= [ 75 75$00 , 70 70$00 , 65 65$00 ] [ Difficulty ] then
10271: LD_OWVAR 1
10275: PUSH
10276: LD_EXP 5
10280: PLUS
10281: PUSH
10282: LD_INT 157500
10284: PUSH
10285: LD_INT 147000
10287: PUSH
10288: LD_INT 136500
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: PUSH
10296: LD_OWVAR 67
10300: ARRAY
10301: LESSEQUAL
10302: IFFALSE 10316
// AddMedal ( med1 , 1 ) else
10304: LD_STRING med1
10306: PPUSH
10307: LD_INT 1
10309: PPUSH
10310: CALL_OW 101
10314: GO 10327
// AddMedal ( med1 , - 1 ) ;
10316: LD_STRING med1
10318: PPUSH
10319: LD_INT 1
10321: NEG
10322: PPUSH
10323: CALL_OW 101
// if ( flamethrowers >= 3 ) * baseHill * hannibalPath * ( loseCounter < [ 6 , 5 , 4 ] [ Difficulty ] ) then
10327: LD_EXP 7
10331: PUSH
10332: LD_INT 3
10334: GREATEREQUAL
10335: PUSH
10336: LD_EXP 11
10340: MUL
10341: PUSH
10342: LD_EXP 9
10346: MUL
10347: PUSH
10348: LD_EXP 6
10352: PUSH
10353: LD_INT 6
10355: PUSH
10356: LD_INT 5
10358: PUSH
10359: LD_INT 4
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: LIST
10366: PUSH
10367: LD_OWVAR 67
10371: ARRAY
10372: LESS
10373: MUL
10374: IFFALSE 10388
// AddMedal ( med2 , 1 ) else
10376: LD_STRING med2
10378: PPUSH
10379: LD_INT 1
10381: PPUSH
10382: CALL_OW 101
10386: GO 10399
// AddMedal ( med2 , - 1 ) ;
10388: LD_STRING med2
10390: PPUSH
10391: LD_INT 1
10393: NEG
10394: PPUSH
10395: CALL_OW 101
// if gaidarKilled then
10399: LD_EXP 14
10403: IFFALSE 10417
// AddMedal ( med3 , 1 ) else
10405: LD_STRING med3
10407: PPUSH
10408: LD_INT 1
10410: PPUSH
10411: CALL_OW 101
10415: GO 10428
// AddMedal ( med3 , - 1 ) ;
10417: LD_STRING med3
10419: PPUSH
10420: LD_INT 1
10422: NEG
10423: PPUSH
10424: CALL_OW 101
// GiveMedals ( MAIN ) ;
10428: LD_STRING MAIN
10430: PPUSH
10431: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_nation , 0 ] ] ] ) ) ;
10435: LD_INT 22
10437: PUSH
10438: LD_INT 2
10440: PUSH
10441: EMPTY
10442: LIST
10443: LIST
10444: PUSH
10445: LD_INT 3
10447: PUSH
10448: LD_INT 23
10450: PUSH
10451: LD_INT 0
10453: PUSH
10454: EMPTY
10455: LIST
10456: LIST
10457: PUSH
10458: EMPTY
10459: LIST
10460: LIST
10461: PUSH
10462: EMPTY
10463: LIST
10464: LIST
10465: PPUSH
10466: CALL_OW 69
10470: PPUSH
10471: CALL_OW 43
// SaveCharacters ( Heike , 04_2_Heike ) ;
10475: LD_EXP 18
10479: PPUSH
10480: LD_STRING 04_2_Heike
10482: PPUSH
10483: CALL_OW 38
// if Aviradze then
10487: LD_EXP 28
10491: IFFALSE 10505
// SaveCharacters ( Aviradze , 04_2_Aviradze ) ;
10493: LD_EXP 28
10497: PPUSH
10498: LD_STRING 04_2_Aviradze
10500: PPUSH
10501: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
10505: LD_EXP 21
10509: PUSH
10510: LD_EXP 21
10514: PPUSH
10515: CALL_OW 255
10519: PUSH
10520: LD_INT 2
10522: EQUAL
10523: AND
10524: IFFALSE 10554
// begin if ibrahimOnRuSide then
10526: LD_EXP 3
10530: IFFALSE 10542
// SaveVariable ( true , 04_2_IbrahimJoined ) ;
10532: LD_INT 1
10534: PPUSH
10535: LD_STRING 04_2_IbrahimJoined
10537: PPUSH
10538: CALL_OW 39
// SaveCharacters ( Ibrahim , 04_2_Ibrahim ) ;
10542: LD_EXP 21
10546: PPUSH
10547: LD_STRING 04_2_Ibrahim
10549: PPUSH
10550: CALL_OW 38
// end ; if Kamil then
10554: LD_EXP 22
10558: IFFALSE 10572
// SaveCharacters ( Kamil , 04_2_Kamil ) ;
10560: LD_EXP 22
10564: PPUSH
10565: LD_STRING 04_2_Kamil
10567: PPUSH
10568: CALL_OW 38
// if Sophia then
10572: LD_EXP 24
10576: IFFALSE 10590
// SaveCharacters ( Sophia , 04_2_Sophia ) ;
10578: LD_EXP 24
10582: PPUSH
10583: LD_STRING 04_2_Sophia
10585: PPUSH
10586: CALL_OW 38
// if Kaia then
10590: LD_EXP 23
10594: IFFALSE 10608
// SaveCharacters ( Kaia , 04_2_Kaia ) ;
10596: LD_EXP 23
10600: PPUSH
10601: LD_STRING 04_2_Kaia
10603: PPUSH
10604: CALL_OW 38
// if Givi then
10608: LD_EXP 19
10612: IFFALSE 10626
// SaveCharacters ( Givi , 04_2_Givi ) ;
10614: LD_EXP 19
10618: PPUSH
10619: LD_STRING 04_2_Givi
10621: PPUSH
10622: CALL_OW 38
// if Mike then
10626: LD_EXP 20
10630: IFFALSE 10644
// SaveCharacters ( Mike , 04_2_Mike ) ;
10632: LD_EXP 20
10636: PPUSH
10637: LD_STRING 04_2_Mike
10639: PPUSH
10640: CALL_OW 38
// if Markov then
10644: LD_EXP 25
10648: IFFALSE 10662
// SaveCharacters ( Markov , 04_2_Markov ) ;
10650: LD_EXP 25
10654: PPUSH
10655: LD_STRING 04_2_Markov
10657: PPUSH
10658: CALL_OW 38
// if Kurt then
10662: LD_EXP 27
10666: IFFALSE 10680
// SaveCharacters ( Kurt , 04_2_Kurt ) ;
10668: LD_EXP 27
10672: PPUSH
10673: LD_STRING 04_2_Kurt
10675: PPUSH
10676: CALL_OW 38
// if heikeSecondSquad then
10680: LD_EXP 29
10684: IFFALSE 10698
// SaveCharacters ( heikeSecondSquad , 04_2_others ) ;
10686: LD_EXP 29
10690: PPUSH
10691: LD_STRING 04_2_others
10693: PPUSH
10694: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
10698: LD_ADDR_VAR 0 1
10702: PUSH
10703: LD_INT 22
10705: PUSH
10706: LD_INT 2
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 23
10715: PUSH
10716: LD_INT 0
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: EMPTY
10724: LIST
10725: LIST
10726: PPUSH
10727: CALL_OW 69
10731: ST_TO_ADDR
// if tmp then
10732: LD_VAR 0 1
10736: IFFALSE 10750
// SaveCharacters ( tmp , 04_2_apes ) ;
10738: LD_VAR 0 1
10742: PPUSH
10743: LD_STRING 04_2_apes
10745: PPUSH
10746: CALL_OW 38
// YouWin ;
10750: CALL_OW 103
// end ;
10754: PPOPN 1
10756: END
