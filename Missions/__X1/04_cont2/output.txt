// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 45 0 0
// InitTag ;
   8: CALL 197 0 0
// PrepareNature ( natureArea ) ;
  12: LD_INT 2
  14: PPUSH
  15: CALL 672 0 1
// PrepareRussian ;
  19: CALL 3210 0 0
// PrepareArabian ;
  23: CALL 2594 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 2 ) ;
  33: LD_INT 2
  35: PPUSH
  36: CALL_OW 344
// Action ;
  40: CALL 6634 0 0
// end ;
  44: END
// export debug , prefix ; export ibrahimOnRuSide , ruEscapeAllowed , gameTime , loseCounter , flamethrowers , ruEscapeCounter , baseHill , explodeFirstDepot , explodeSecondDepot , gaidarKilled ; function Init ; begin
  45: LD_INT 0
  47: PPUSH
// debug := false ;
  48: LD_ADDR_EXP 1
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// prefix := 04_1_ ;
  56: LD_ADDR_EXP 2
  60: PUSH
  61: LD_STRING 04_1_
  63: ST_TO_ADDR
// ibrahimOnRuSide := LoadVariable ( 03_IbrahimHasEscaped , false ) ;
  64: LD_ADDR_EXP 3
  68: PUSH
  69: LD_STRING 03_IbrahimHasEscaped
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: CALL_OW 30
  79: ST_TO_ADDR
// ruEscapeCounter := LoadVariable ( 04_1_EscapeCounter , 0 ) ;
  80: LD_ADDR_EXP 8
  84: PUSH
  85: LD_STRING 04_1_EscapeCounter
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// loseCounter := LoadVariable ( 04_1_DeadCounter , 0 ) ;
  96: LD_ADDR_EXP 6
 100: PUSH
 101: LD_STRING 04_1_DeadCounter
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// baseHill := LoadVariable ( 04_1_BaseHill , false ) ;
 112: LD_ADDR_EXP 9
 116: PUSH
 117: LD_STRING 04_1_BaseHill
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL_OW 30
 127: ST_TO_ADDR
// gameTime := LoadVariable ( 04_1_Time , 40 40$00 ) ;
 128: LD_ADDR_EXP 5
 132: PUSH
 133: LD_STRING 04_1_Time
 135: PPUSH
 136: LD_INT 84000
 138: PPUSH
 139: CALL_OW 30
 143: ST_TO_ADDR
// flamethrowers := LoadVariable ( 04_1_Flamethrower , 0 ) ;
 144: LD_ADDR_EXP 7
 148: PUSH
 149: LD_STRING 04_1_Flamethrower
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: CALL_OW 30
 159: ST_TO_ADDR
// ruEscapeAllowed := false ;
 160: LD_ADDR_EXP 4
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// explodeFirstDepot := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// explodeSecondDepot := false ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// gaidarKilled := false ;
 184: LD_ADDR_EXP 12
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// end ;
 192: LD_VAR 0 1
 196: RET
// export tEscape ; function InitTag ; begin
 197: LD_INT 0
 199: PPUSH
// tEscape := 10 ;
 200: LD_ADDR_EXP 13
 204: PUSH
 205: LD_INT 10
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// every 0 0$1 trigger debug do var i ;
 213: LD_EXP 1
 217: IFFALSE 301
 219: GO 221
 221: DISABLE
 222: LD_INT 0
 224: PPUSH
// begin enable ;
 225: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) do
 226: LD_ADDR_VAR 0 1
 230: PUSH
 231: LD_INT 22
 233: PUSH
 234: LD_INT 2
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: PUSH
 241: LD_INT 3
 243: PUSH
 244: LD_INT 21
 246: PUSH
 247: LD_INT 3
 249: PUSH
 250: EMPTY
 251: LIST
 252: LIST
 253: PUSH
 254: EMPTY
 255: LIST
 256: LIST
 257: PUSH
 258: EMPTY
 259: LIST
 260: LIST
 261: PPUSH
 262: CALL_OW 69
 266: PUSH
 267: FOR_IN
 268: IFFALSE 299
// if GetLives ( i ) < 1000 then
 270: LD_VAR 0 1
 274: PPUSH
 275: CALL_OW 256
 279: PUSH
 280: LD_INT 1000
 282: LESS
 283: IFFALSE 297
// SetLives ( i , 1000 ) ;
 285: LD_VAR 0 1
 289: PPUSH
 290: LD_INT 1000
 292: PPUSH
 293: CALL_OW 234
 297: GO 267
 299: POP
 300: POP
// end ; end_of_file
 301: PPOPN 1
 303: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// if exist_mode then
 308: LD_VAR 0 2
 312: IFFALSE 337
// unit := CreateCharacter ( prefix & ident ) else
 314: LD_ADDR_VAR 0 5
 318: PUSH
 319: LD_VAR 0 3
 323: PUSH
 324: LD_VAR 0 1
 328: STR
 329: PPUSH
 330: CALL_OW 34
 334: ST_TO_ADDR
 335: GO 352
// unit := NewCharacter ( ident ) ;
 337: LD_ADDR_VAR 0 5
 341: PUSH
 342: LD_VAR 0 1
 346: PPUSH
 347: CALL_OW 25
 351: ST_TO_ADDR
// result := unit ;
 352: LD_ADDR_VAR 0 4
 356: PUSH
 357: LD_VAR 0 5
 361: ST_TO_ADDR
// end ;
 362: LD_VAR 0 4
 366: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 367: LD_INT 0
 369: PPUSH
// uc_side := side ;
 370: LD_ADDR_OWVAR 20
 374: PUSH
 375: LD_VAR 0 1
 379: ST_TO_ADDR
// uc_nation := nation ;
 380: LD_ADDR_OWVAR 21
 384: PUSH
 385: LD_VAR 0 2
 389: ST_TO_ADDR
// vc_chassis := chassis ;
 390: LD_ADDR_OWVAR 37
 394: PUSH
 395: LD_VAR 0 3
 399: ST_TO_ADDR
// vc_engine := engine ;
 400: LD_ADDR_OWVAR 39
 404: PUSH
 405: LD_VAR 0 4
 409: ST_TO_ADDR
// vc_control := control ;
 410: LD_ADDR_OWVAR 38
 414: PUSH
 415: LD_VAR 0 5
 419: ST_TO_ADDR
// vc_weapon := weapon ;
 420: LD_ADDR_OWVAR 40
 424: PUSH
 425: LD_VAR 0 6
 429: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 430: LD_ADDR_OWVAR 41
 434: PUSH
 435: LD_VAR 0 7
 439: ST_TO_ADDR
// result := CreateVehicle ;
 440: LD_ADDR_VAR 0 8
 444: PUSH
 445: CALL_OW 45
 449: ST_TO_ADDR
// end ;
 450: LD_VAR 0 8
 454: RET
// export function SayX ( units , ident ) ; var i ; begin
 455: LD_INT 0
 457: PPUSH
 458: PPUSH
// result := false ;
 459: LD_ADDR_VAR 0 3
 463: PUSH
 464: LD_INT 0
 466: ST_TO_ADDR
// if not units then
 467: LD_VAR 0 1
 471: NOT
 472: IFFALSE 476
// exit ;
 474: GO 530
// for i in units do
 476: LD_ADDR_VAR 0 4
 480: PUSH
 481: LD_VAR 0 1
 485: PUSH
 486: FOR_IN
 487: IFFALSE 528
// if IsOk ( i ) then
 489: LD_VAR 0 4
 493: PPUSH
 494: CALL_OW 302
 498: IFFALSE 526
// begin Say ( i , ident ) ;
 500: LD_VAR 0 4
 504: PPUSH
 505: LD_VAR 0 2
 509: PPUSH
 510: CALL_OW 88
// result := i ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: LD_VAR 0 4
 523: ST_TO_ADDR
// break ;
 524: GO 528
// end ;
 526: GO 486
 528: POP
 529: POP
// end ;
 530: LD_VAR 0 3
 534: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 535: LD_INT 0
 537: PPUSH
 538: PPUSH
// InitUc ;
 539: CALL_OW 18
// InitHc ;
 543: CALL_OW 19
// uc_side := 0 ;
 547: LD_ADDR_OWVAR 20
 551: PUSH
 552: LD_INT 0
 554: ST_TO_ADDR
// uc_nation := 0 ;
 555: LD_ADDR_OWVAR 21
 559: PUSH
 560: LD_INT 0
 562: ST_TO_ADDR
// for i = 1 to amount do
 563: LD_ADDR_VAR 0 4
 567: PUSH
 568: DOUBLE
 569: LD_INT 1
 571: DEC
 572: ST_TO_ADDR
 573: LD_VAR 0 2
 577: PUSH
 578: FOR_TO
 579: IFFALSE 661
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 581: LD_ADDR_OWVAR 29
 585: PUSH
 586: LD_INT 9
 588: PPUSH
 589: LD_INT 12
 591: PPUSH
 592: CALL_OW 12
 596: PUSH
 597: LD_INT 9
 599: PPUSH
 600: LD_INT 12
 602: PPUSH
 603: CALL_OW 12
 607: PUSH
 608: EMPTY
 609: LIST
 610: LIST
 611: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 612: LD_ADDR_OWVAR 35
 616: PUSH
 617: LD_INT 1
 619: NEG
 620: PPUSH
 621: LD_INT 1
 623: PPUSH
 624: CALL_OW 12
 628: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 629: LD_INT 0
 631: PPUSH
 632: LD_INT 12
 634: PPUSH
 635: LD_INT 1
 637: PPUSH
 638: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 642: CALL_OW 44
 646: PPUSH
 647: LD_VAR 0 1
 651: PPUSH
 652: LD_INT 0
 654: PPUSH
 655: CALL_OW 49
// end ;
 659: GO 578
 661: POP
 662: POP
// InitHc ;
 663: CALL_OW 19
// end ;
 667: LD_VAR 0 3
 671: RET
// export function PrepareNature ( forest ) ; var i ; begin
 672: LD_INT 0
 674: PPUSH
 675: PPUSH
// SpawnApeman ( forest , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
 676: LD_VAR 0 1
 680: PPUSH
 681: LD_INT 3
 683: PUSH
 684: LD_INT 3
 686: PUSH
 687: LD_INT 2
 689: PUSH
 690: EMPTY
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: LD_OWVAR 67
 699: ARRAY
 700: PPUSH
 701: CALL 535 0 2
// for i := 1 to 2 do
 705: LD_ADDR_VAR 0 3
 709: PUSH
 710: DOUBLE
 711: LD_INT 1
 713: DEC
 714: ST_TO_ADDR
 715: LD_INT 2
 717: PUSH
 718: FOR_TO
 719: IFFALSE 756
// begin hc_class := 21 ;
 721: LD_ADDR_OWVAR 28
 725: PUSH
 726: LD_INT 21
 728: ST_TO_ADDR
// hc_gallery :=  ;
 729: LD_ADDR_OWVAR 33
 733: PUSH
 734: LD_STRING 
 736: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 737: CALL_OW 44
 741: PPUSH
 742: LD_VAR 0 1
 746: PPUSH
 747: LD_INT 0
 749: PPUSH
 750: CALL_OW 49
// end ;
 754: GO 718
 756: POP
 757: POP
// for i := 1 to 2 do
 758: LD_ADDR_VAR 0 3
 762: PUSH
 763: DOUBLE
 764: LD_INT 1
 766: DEC
 767: ST_TO_ADDR
 768: LD_INT 2
 770: PUSH
 771: FOR_TO
 772: IFFALSE 809
// begin hc_class := 18 ;
 774: LD_ADDR_OWVAR 28
 778: PUSH
 779: LD_INT 18
 781: ST_TO_ADDR
// hc_gallery :=  ;
 782: LD_ADDR_OWVAR 33
 786: PUSH
 787: LD_STRING 
 789: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 790: CALL_OW 44
 794: PPUSH
 795: LD_VAR 0 1
 799: PPUSH
 800: LD_INT 0
 802: PPUSH
 803: CALL_OW 49
// end ;
 807: GO 771
 809: POP
 810: POP
// for i := 1 to 2 do
 811: LD_ADDR_VAR 0 3
 815: PUSH
 816: DOUBLE
 817: LD_INT 1
 819: DEC
 820: ST_TO_ADDR
 821: LD_INT 2
 823: PUSH
 824: FOR_TO
 825: IFFALSE 862
// begin hc_class := 13 ;
 827: LD_ADDR_OWVAR 28
 831: PUSH
 832: LD_INT 13
 834: ST_TO_ADDR
// hc_gallery :=  ;
 835: LD_ADDR_OWVAR 33
 839: PUSH
 840: LD_STRING 
 842: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 843: CALL_OW 44
 847: PPUSH
 848: LD_VAR 0 1
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL_OW 49
// end ;
 860: GO 824
 862: POP
 863: POP
// end ;
 864: LD_VAR 0 2
 868: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 869: LD_INT 0
 871: PPUSH
 872: PPUSH
 873: PPUSH
// if not observer or not unit then
 874: LD_VAR 0 1
 878: NOT
 879: PUSH
 880: LD_VAR 0 2
 884: NOT
 885: OR
 886: IFFALSE 890
// exit ;
 888: GO 938
// if not See ( GetSide ( observer ) , unit ) then
 890: LD_VAR 0 1
 894: PPUSH
 895: CALL_OW 255
 899: PPUSH
 900: LD_VAR 0 2
 904: PPUSH
 905: CALL_OW 292
 909: NOT
 910: IFFALSE 914
// exit ;
 912: GO 938
// result := GetDistUnits ( observer , unit ) < 12 ;
 914: LD_ADDR_VAR 0 3
 918: PUSH
 919: LD_VAR 0 1
 923: PPUSH
 924: LD_VAR 0 2
 928: PPUSH
 929: CALL_OW 296
 933: PUSH
 934: LD_INT 12
 936: LESS
 937: ST_TO_ADDR
// end ;
 938: LD_VAR 0 3
 942: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 943: LD_INT 0
 945: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 946: LD_VAR 0 2
 950: PUSH
 951: LD_INT 1
 953: ARRAY
 954: PPUSH
 955: LD_VAR 0 2
 959: PUSH
 960: LD_INT 2
 962: ARRAY
 963: PPUSH
 964: CALL_OW 488
 968: PUSH
 969: LD_VAR 0 2
 973: PUSH
 974: LD_INT 1
 976: ARRAY
 977: PPUSH
 978: LD_VAR 0 2
 982: PUSH
 983: LD_INT 2
 985: ARRAY
 986: PPUSH
 987: CALL_OW 428
 991: PUSH
 992: LD_INT 0
 994: EQUAL
 995: AND
 996: IFFALSE 1030
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 998: LD_VAR 0 1
1002: PPUSH
1003: LD_VAR 0 2
1007: PUSH
1008: LD_INT 1
1010: ARRAY
1011: PPUSH
1012: LD_VAR 0 2
1016: PUSH
1017: LD_INT 2
1019: ARRAY
1020: PPUSH
1021: LD_VAR 0 3
1025: PPUSH
1026: CALL_OW 48
// end ;
1030: LD_VAR 0 4
1034: RET
// export function Video ( mode ) ; begin
1035: LD_INT 0
1037: PPUSH
// ingame_video = mode ;
1038: LD_ADDR_OWVAR 52
1042: PUSH
1043: LD_VAR 0 1
1047: ST_TO_ADDR
// interface_hidden = mode ;
1048: LD_ADDR_OWVAR 54
1052: PUSH
1053: LD_VAR 0 1
1057: ST_TO_ADDR
// end ;
1058: LD_VAR 0 2
1062: RET
// export function ReverseArray ( array ) ; var i ; begin
1063: LD_INT 0
1065: PPUSH
1066: PPUSH
// if not array then
1067: LD_VAR 0 1
1071: NOT
1072: IFFALSE 1076
// exit ;
1074: GO 1134
// result := [ ] ;
1076: LD_ADDR_VAR 0 2
1080: PUSH
1081: EMPTY
1082: ST_TO_ADDR
// for i := 1 to array do
1083: LD_ADDR_VAR 0 3
1087: PUSH
1088: DOUBLE
1089: LD_INT 1
1091: DEC
1092: ST_TO_ADDR
1093: LD_VAR 0 1
1097: PUSH
1098: FOR_TO
1099: IFFALSE 1132
// result := Insert ( result , 1 , array [ i ] ) ;
1101: LD_ADDR_VAR 0 2
1105: PUSH
1106: LD_VAR 0 2
1110: PPUSH
1111: LD_INT 1
1113: PPUSH
1114: LD_VAR 0 1
1118: PUSH
1119: LD_VAR 0 3
1123: ARRAY
1124: PPUSH
1125: CALL_OW 2
1129: ST_TO_ADDR
1130: GO 1098
1132: POP
1133: POP
// end ;
1134: LD_VAR 0 2
1138: RET
// export function ComExit ( unit ) ; begin
1139: LD_INT 0
1141: PPUSH
// result := IsInUnit ( unit ) ;
1142: LD_ADDR_VAR 0 2
1146: PUSH
1147: LD_VAR 0 1
1151: PPUSH
1152: CALL_OW 310
1156: ST_TO_ADDR
// if not result then
1157: LD_VAR 0 2
1161: NOT
1162: IFFALSE 1166
// exit ;
1164: GO 1201
// if GetType ( result ) = unit_vehicle then
1166: LD_VAR 0 2
1170: PPUSH
1171: CALL_OW 247
1175: PUSH
1176: LD_INT 2
1178: EQUAL
1179: IFFALSE 1192
// ComExitVehicle ( unit ) else
1181: LD_VAR 0 1
1185: PPUSH
1186: CALL_OW 121
1190: GO 1201
// ComExitBuilding ( unit ) ;
1192: LD_VAR 0 1
1196: PPUSH
1197: CALL_OW 122
// end ;
1201: LD_VAR 0 2
1205: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1206: LD_INT 0
1208: PPUSH
1209: PPUSH
// if not side or not nation then
1210: LD_VAR 0 1
1214: NOT
1215: PUSH
1216: LD_VAR 0 2
1220: NOT
1221: OR
1222: IFFALSE 1226
// exit ;
1224: GO 1990
// case nation of nation_american :
1226: LD_VAR 0 2
1230: PUSH
1231: LD_INT 1
1233: DOUBLE
1234: EQUAL
1235: IFTRUE 1239
1237: GO 1453
1239: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1240: LD_ADDR_VAR 0 4
1244: PUSH
1245: LD_INT 35
1247: PUSH
1248: LD_INT 45
1250: PUSH
1251: LD_INT 46
1253: PUSH
1254: LD_INT 47
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 83
1262: PUSH
1263: LD_INT 84
1265: PUSH
1266: LD_INT 85
1268: PUSH
1269: LD_INT 86
1271: PUSH
1272: LD_INT 1
1274: PUSH
1275: LD_INT 2
1277: PUSH
1278: LD_INT 6
1280: PUSH
1281: LD_INT 15
1283: PUSH
1284: LD_INT 16
1286: PUSH
1287: LD_INT 7
1289: PUSH
1290: LD_INT 12
1292: PUSH
1293: LD_INT 13
1295: PUSH
1296: LD_INT 10
1298: PUSH
1299: LD_INT 14
1301: PUSH
1302: LD_INT 20
1304: PUSH
1305: LD_INT 21
1307: PUSH
1308: LD_INT 22
1310: PUSH
1311: LD_INT 25
1313: PUSH
1314: LD_INT 32
1316: PUSH
1317: LD_INT 27
1319: PUSH
1320: LD_INT 36
1322: PUSH
1323: LD_INT 69
1325: PUSH
1326: LD_INT 39
1328: PUSH
1329: LD_INT 34
1331: PUSH
1332: LD_INT 40
1334: PUSH
1335: LD_INT 48
1337: PUSH
1338: LD_INT 49
1340: PUSH
1341: LD_INT 50
1343: PUSH
1344: LD_INT 51
1346: PUSH
1347: LD_INT 52
1349: PUSH
1350: LD_INT 53
1352: PUSH
1353: LD_INT 54
1355: PUSH
1356: LD_INT 55
1358: PUSH
1359: LD_INT 56
1361: PUSH
1362: LD_INT 57
1364: PUSH
1365: LD_INT 58
1367: PUSH
1368: LD_INT 59
1370: PUSH
1371: LD_INT 60
1373: PUSH
1374: LD_INT 61
1376: PUSH
1377: LD_INT 62
1379: PUSH
1380: LD_INT 80
1382: PUSH
1383: LD_INT 82
1385: PUSH
1386: LD_INT 83
1388: PUSH
1389: LD_INT 84
1391: PUSH
1392: LD_INT 85
1394: PUSH
1395: LD_INT 86
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: ST_TO_ADDR
1451: GO 1914
1453: LD_INT 2
1455: DOUBLE
1456: EQUAL
1457: IFTRUE 1461
1459: GO 1683
1461: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1462: LD_ADDR_VAR 0 4
1466: PUSH
1467: LD_INT 35
1469: PUSH
1470: LD_INT 45
1472: PUSH
1473: LD_INT 46
1475: PUSH
1476: LD_INT 47
1478: PUSH
1479: LD_INT 82
1481: PUSH
1482: LD_INT 83
1484: PUSH
1485: LD_INT 84
1487: PUSH
1488: LD_INT 85
1490: PUSH
1491: LD_INT 87
1493: PUSH
1494: LD_INT 70
1496: PUSH
1497: LD_INT 1
1499: PUSH
1500: LD_INT 11
1502: PUSH
1503: LD_INT 3
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 5
1511: PUSH
1512: LD_INT 6
1514: PUSH
1515: LD_INT 15
1517: PUSH
1518: LD_INT 18
1520: PUSH
1521: LD_INT 7
1523: PUSH
1524: LD_INT 17
1526: PUSH
1527: LD_INT 8
1529: PUSH
1530: LD_INT 20
1532: PUSH
1533: LD_INT 21
1535: PUSH
1536: LD_INT 22
1538: PUSH
1539: LD_INT 72
1541: PUSH
1542: LD_INT 26
1544: PUSH
1545: LD_INT 69
1547: PUSH
1548: LD_INT 39
1550: PUSH
1551: LD_INT 40
1553: PUSH
1554: LD_INT 41
1556: PUSH
1557: LD_INT 42
1559: PUSH
1560: LD_INT 43
1562: PUSH
1563: LD_INT 48
1565: PUSH
1566: LD_INT 49
1568: PUSH
1569: LD_INT 50
1571: PUSH
1572: LD_INT 51
1574: PUSH
1575: LD_INT 52
1577: PUSH
1578: LD_INT 53
1580: PUSH
1581: LD_INT 54
1583: PUSH
1584: LD_INT 55
1586: PUSH
1587: LD_INT 56
1589: PUSH
1590: LD_INT 60
1592: PUSH
1593: LD_INT 61
1595: PUSH
1596: LD_INT 62
1598: PUSH
1599: LD_INT 66
1601: PUSH
1602: LD_INT 67
1604: PUSH
1605: LD_INT 68
1607: PUSH
1608: LD_INT 81
1610: PUSH
1611: LD_INT 82
1613: PUSH
1614: LD_INT 83
1616: PUSH
1617: LD_INT 84
1619: PUSH
1620: LD_INT 85
1622: PUSH
1623: LD_INT 87
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: ST_TO_ADDR
1681: GO 1914
1683: LD_INT 3
1685: DOUBLE
1686: EQUAL
1687: IFTRUE 1691
1689: GO 1913
1691: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1692: LD_ADDR_VAR 0 4
1696: PUSH
1697: LD_INT 46
1699: PUSH
1700: LD_INT 47
1702: PUSH
1703: LD_INT 1
1705: PUSH
1706: LD_INT 2
1708: PUSH
1709: LD_INT 82
1711: PUSH
1712: LD_INT 83
1714: PUSH
1715: LD_INT 84
1717: PUSH
1718: LD_INT 85
1720: PUSH
1721: LD_INT 86
1723: PUSH
1724: LD_INT 11
1726: PUSH
1727: LD_INT 9
1729: PUSH
1730: LD_INT 20
1732: PUSH
1733: LD_INT 19
1735: PUSH
1736: LD_INT 21
1738: PUSH
1739: LD_INT 24
1741: PUSH
1742: LD_INT 22
1744: PUSH
1745: LD_INT 25
1747: PUSH
1748: LD_INT 28
1750: PUSH
1751: LD_INT 29
1753: PUSH
1754: LD_INT 30
1756: PUSH
1757: LD_INT 31
1759: PUSH
1760: LD_INT 37
1762: PUSH
1763: LD_INT 38
1765: PUSH
1766: LD_INT 32
1768: PUSH
1769: LD_INT 27
1771: PUSH
1772: LD_INT 33
1774: PUSH
1775: LD_INT 69
1777: PUSH
1778: LD_INT 39
1780: PUSH
1781: LD_INT 34
1783: PUSH
1784: LD_INT 40
1786: PUSH
1787: LD_INT 71
1789: PUSH
1790: LD_INT 23
1792: PUSH
1793: LD_INT 44
1795: PUSH
1796: LD_INT 48
1798: PUSH
1799: LD_INT 49
1801: PUSH
1802: LD_INT 50
1804: PUSH
1805: LD_INT 51
1807: PUSH
1808: LD_INT 52
1810: PUSH
1811: LD_INT 53
1813: PUSH
1814: LD_INT 54
1816: PUSH
1817: LD_INT 55
1819: PUSH
1820: LD_INT 56
1822: PUSH
1823: LD_INT 57
1825: PUSH
1826: LD_INT 58
1828: PUSH
1829: LD_INT 59
1831: PUSH
1832: LD_INT 63
1834: PUSH
1835: LD_INT 64
1837: PUSH
1838: LD_INT 65
1840: PUSH
1841: LD_INT 82
1843: PUSH
1844: LD_INT 83
1846: PUSH
1847: LD_INT 84
1849: PUSH
1850: LD_INT 85
1852: PUSH
1853: LD_INT 86
1855: PUSH
1856: EMPTY
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: ST_TO_ADDR
1911: GO 1914
1913: POP
// if state > - 1 and state < 3 then
1914: LD_VAR 0 3
1918: PUSH
1919: LD_INT 1
1921: NEG
1922: GREATER
1923: PUSH
1924: LD_VAR 0 3
1928: PUSH
1929: LD_INT 3
1931: LESS
1932: AND
1933: IFFALSE 1990
// for i in result do
1935: LD_ADDR_VAR 0 5
1939: PUSH
1940: LD_VAR 0 4
1944: PUSH
1945: FOR_IN
1946: IFFALSE 1988
// if GetTech ( i , side ) <> state then
1948: LD_VAR 0 5
1952: PPUSH
1953: LD_VAR 0 1
1957: PPUSH
1958: CALL_OW 321
1962: PUSH
1963: LD_VAR 0 3
1967: NONEQUAL
1968: IFFALSE 1986
// result := result diff i ;
1970: LD_ADDR_VAR 0 4
1974: PUSH
1975: LD_VAR 0 4
1979: PUSH
1980: LD_VAR 0 5
1984: DIFF
1985: ST_TO_ADDR
1986: GO 1945
1988: POP
1989: POP
// end ;
1990: LD_VAR 0 4
1994: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
1995: LD_INT 0
1997: PPUSH
1998: PPUSH
1999: PPUSH
2000: PPUSH
// if not list then
2001: LD_VAR 0 3
2005: NOT
2006: IFFALSE 2010
// exit ;
2008: GO 2318
// result := [ ] ;
2010: LD_ADDR_VAR 0 5
2014: PUSH
2015: EMPTY
2016: ST_TO_ADDR
// for i in list do
2017: LD_ADDR_VAR 0 6
2021: PUSH
2022: LD_VAR 0 3
2026: PUSH
2027: FOR_IN
2028: IFFALSE 2230
// begin tmp := GetDistUnitXY ( i , x , y ) ;
2030: LD_ADDR_VAR 0 8
2034: PUSH
2035: LD_VAR 0 6
2039: PPUSH
2040: LD_VAR 0 1
2044: PPUSH
2045: LD_VAR 0 2
2049: PPUSH
2050: CALL_OW 297
2054: ST_TO_ADDR
// if not result then
2055: LD_VAR 0 5
2059: NOT
2060: IFFALSE 2086
// result := [ [ i , tmp ] ] else
2062: LD_ADDR_VAR 0 5
2066: PUSH
2067: LD_VAR 0 6
2071: PUSH
2072: LD_VAR 0 8
2076: PUSH
2077: EMPTY
2078: LIST
2079: LIST
2080: PUSH
2081: EMPTY
2082: LIST
2083: ST_TO_ADDR
2084: GO 2228
// begin if result [ result ] [ 2 ] < tmp then
2086: LD_VAR 0 5
2090: PUSH
2091: LD_VAR 0 5
2095: ARRAY
2096: PUSH
2097: LD_INT 2
2099: ARRAY
2100: PUSH
2101: LD_VAR 0 8
2105: LESS
2106: IFFALSE 2148
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
2108: LD_ADDR_VAR 0 5
2112: PUSH
2113: LD_VAR 0 5
2117: PPUSH
2118: LD_VAR 0 5
2122: PUSH
2123: LD_INT 1
2125: PLUS
2126: PPUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_VAR 0 8
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: PPUSH
2141: CALL_OW 2
2145: ST_TO_ADDR
2146: GO 2228
// for j = 1 to result do
2148: LD_ADDR_VAR 0 7
2152: PUSH
2153: DOUBLE
2154: LD_INT 1
2156: DEC
2157: ST_TO_ADDR
2158: LD_VAR 0 5
2162: PUSH
2163: FOR_TO
2164: IFFALSE 2226
// begin if tmp < result [ j ] [ 2 ] then
2166: LD_VAR 0 8
2170: PUSH
2171: LD_VAR 0 5
2175: PUSH
2176: LD_VAR 0 7
2180: ARRAY
2181: PUSH
2182: LD_INT 2
2184: ARRAY
2185: LESS
2186: IFFALSE 2224
// begin result := Insert ( result , j , [ i , tmp ] ) ;
2188: LD_ADDR_VAR 0 5
2192: PUSH
2193: LD_VAR 0 5
2197: PPUSH
2198: LD_VAR 0 7
2202: PPUSH
2203: LD_VAR 0 6
2207: PUSH
2208: LD_VAR 0 8
2212: PUSH
2213: EMPTY
2214: LIST
2215: LIST
2216: PPUSH
2217: CALL_OW 2
2221: ST_TO_ADDR
// break ;
2222: GO 2226
// end ; end ;
2224: GO 2163
2226: POP
2227: POP
// end ; end ;
2228: GO 2027
2230: POP
2231: POP
// if result and not asc then
2232: LD_VAR 0 5
2236: PUSH
2237: LD_VAR 0 4
2241: NOT
2242: AND
2243: IFFALSE 2318
// begin tmp := result ;
2245: LD_ADDR_VAR 0 8
2249: PUSH
2250: LD_VAR 0 5
2254: ST_TO_ADDR
// for i = tmp downto 1 do
2255: LD_ADDR_VAR 0 6
2259: PUSH
2260: DOUBLE
2261: LD_VAR 0 8
2265: INC
2266: ST_TO_ADDR
2267: LD_INT 1
2269: PUSH
2270: FOR_DOWNTO
2271: IFFALSE 2316
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
2273: LD_ADDR_VAR 0 5
2277: PUSH
2278: LD_VAR 0 5
2282: PPUSH
2283: LD_VAR 0 8
2287: PUSH
2288: LD_VAR 0 6
2292: MINUS
2293: PUSH
2294: LD_INT 1
2296: PLUS
2297: PPUSH
2298: LD_VAR 0 8
2302: PUSH
2303: LD_VAR 0 6
2307: ARRAY
2308: PPUSH
2309: CALL_OW 1
2313: ST_TO_ADDR
2314: GO 2270
2316: POP
2317: POP
// end ; end ;
2318: LD_VAR 0 5
2322: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
2323: LD_INT 0
2325: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
2326: LD_ADDR_VAR 0 4
2330: PUSH
2331: LD_VAR 0 1
2335: PPUSH
2336: CALL_OW 250
2340: PPUSH
2341: LD_VAR 0 1
2345: PPUSH
2346: CALL_OW 251
2350: PPUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: LD_VAR 0 3
2360: PPUSH
2361: CALL 1995 0 4
2365: ST_TO_ADDR
// end ;
2366: LD_VAR 0 4
2370: RET
// export function NearestEmptyBuilding ( unit , btype ) ; var side , tmp , i , places ; begin
2371: LD_INT 0
2373: PPUSH
2374: PPUSH
2375: PPUSH
2376: PPUSH
2377: PPUSH
// if not unit then
2378: LD_VAR 0 1
2382: NOT
2383: IFFALSE 2387
// exit ;
2385: GO 2589
// side := GetSide ( unit ) ;
2387: LD_ADDR_VAR 0 4
2391: PUSH
2392: LD_VAR 0 1
2396: PPUSH
2397: CALL_OW 255
2401: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
2402: LD_ADDR_VAR 0 5
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: LD_VAR 0 4
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: PUSH
2419: LD_INT 30
2421: PUSH
2422: LD_VAR 0 2
2426: PUSH
2427: EMPTY
2428: LIST
2429: LIST
2430: PUSH
2431: EMPTY
2432: LIST
2433: LIST
2434: PPUSH
2435: CALL_OW 69
2439: ST_TO_ADDR
// if not tmp then
2440: LD_VAR 0 5
2444: NOT
2445: IFFALSE 2449
// exit ;
2447: GO 2589
// tmp := SortByDistanceUnit ( unit , tmp , true ) ;
2449: LD_ADDR_VAR 0 5
2453: PUSH
2454: LD_VAR 0 1
2458: PPUSH
2459: LD_VAR 0 5
2463: PPUSH
2464: LD_INT 1
2466: PPUSH
2467: CALL 2323 0 3
2471: ST_TO_ADDR
// places := 1 ;
2472: LD_ADDR_VAR 0 7
2476: PUSH
2477: LD_INT 1
2479: ST_TO_ADDR
// if btype in [ b_depot , b_warehouse , b_armoury , b_barracks , b_workshop , b_factory , b_lab , b_lab_half , b_lab_full ] then
2480: LD_VAR 0 2
2484: PUSH
2485: LD_INT 0
2487: PUSH
2488: LD_INT 1
2490: PUSH
2491: LD_INT 4
2493: PUSH
2494: LD_INT 5
2496: PUSH
2497: LD_INT 2
2499: PUSH
2500: LD_INT 3
2502: PUSH
2503: LD_INT 6
2505: PUSH
2506: LD_INT 7
2508: PUSH
2509: LD_INT 8
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: LIST
2516: LIST
2517: LIST
2518: LIST
2519: LIST
2520: LIST
2521: LIST
2522: IN
2523: IFFALSE 2533
// places := 6 ;
2525: LD_ADDR_VAR 0 7
2529: PUSH
2530: LD_INT 6
2532: ST_TO_ADDR
// for i in tmp do
2533: LD_ADDR_VAR 0 6
2537: PUSH
2538: LD_VAR 0 5
2542: PUSH
2543: FOR_IN
2544: IFFALSE 2587
// begin if UnitsInside ( i ) - places <= 0 then
2546: LD_VAR 0 6
2550: PPUSH
2551: CALL_OW 313
2555: PUSH
2556: LD_VAR 0 7
2560: MINUS
2561: PUSH
2562: LD_INT 0
2564: LESSEQUAL
2565: IFFALSE 2571
// continue else
2567: GO 2543
2569: GO 2585
// begin result := i ;
2571: LD_ADDR_VAR 0 3
2575: PUSH
2576: LD_VAR 0 6
2580: ST_TO_ADDR
// exit ;
2581: POP
2582: POP
2583: GO 2589
// end ; end ;
2585: GO 2543
2587: POP
2588: POP
// end ; end_of_file
2589: LD_VAR 0 3
2593: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Shariff , Kurt , Aviradze , heikeSecondSquad , heikeVehicles , heikeApes ; export function PrepareArabian ; var i ; begin
2594: LD_INT 0
2596: PPUSH
2597: PPUSH
// uc_side := 2 ;
2598: LD_ADDR_OWVAR 20
2602: PUSH
2603: LD_INT 2
2605: ST_TO_ADDR
// uc_nation := 2 ;
2606: LD_ADDR_OWVAR 21
2610: PUSH
2611: LD_INT 2
2613: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2614: LD_ADDR_EXP 14
2618: PUSH
2619: LD_STRING Heike
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_EXP 2
2632: PPUSH
2633: CALL 304 0 3
2637: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
2638: LD_ADDR_EXP 17
2642: PUSH
2643: LD_STRING Ibrahim
2645: PPUSH
2646: LD_EXP 1
2650: NOT
2651: PPUSH
2652: LD_EXP 2
2656: PPUSH
2657: CALL 304 0 3
2661: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2662: LD_ADDR_EXP 15
2666: PUSH
2667: LD_STRING Givi
2669: PPUSH
2670: LD_EXP 1
2674: NOT
2675: PPUSH
2676: LD_EXP 2
2680: PPUSH
2681: CALL 304 0 3
2685: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2686: LD_ADDR_EXP 18
2690: PUSH
2691: LD_STRING Kamil
2693: PPUSH
2694: LD_EXP 1
2698: NOT
2699: PPUSH
2700: LD_EXP 2
2704: PPUSH
2705: CALL 304 0 3
2709: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2710: LD_ADDR_EXP 19
2714: PUSH
2715: LD_STRING Kaia
2717: PPUSH
2718: LD_EXP 1
2722: NOT
2723: PPUSH
2724: LD_EXP 2
2728: PPUSH
2729: CALL 304 0 3
2733: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2734: LD_ADDR_EXP 20
2738: PUSH
2739: LD_STRING Sophia
2741: PPUSH
2742: LD_EXP 1
2746: NOT
2747: PPUSH
2748: LD_EXP 2
2752: PPUSH
2753: CALL 304 0 3
2757: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2758: LD_ADDR_EXP 21
2762: PUSH
2763: LD_STRING Markov
2765: PPUSH
2766: LD_EXP 1
2770: NOT
2771: PPUSH
2772: LD_EXP 2
2776: PPUSH
2777: CALL 304 0 3
2781: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2782: LD_ADDR_EXP 24
2786: PUSH
2787: LD_STRING Aviradze
2789: PPUSH
2790: LD_EXP 1
2794: NOT
2795: PPUSH
2796: LD_EXP 2
2800: PPUSH
2801: CALL 304 0 3
2805: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , false ,  ) ;
2806: LD_ADDR_EXP 23
2810: PUSH
2811: LD_STRING Kurt
2813: PPUSH
2814: LD_INT 0
2816: PPUSH
2817: LD_STRING 
2819: PPUSH
2820: CALL 304 0 3
2824: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2825: LD_ADDR_EXP 16
2829: PUSH
2830: LD_STRING Mike
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_EXP 2
2843: PPUSH
2844: CALL 304 0 3
2848: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_1_others ) ;
2849: LD_ADDR_EXP 25
2853: PUSH
2854: LD_STRING 04_1_others
2856: PPUSH
2857: CALL_OW 31
2861: ST_TO_ADDR
// heikeApes := CreateCharacterSet ( 04_1_apes ) ;
2862: LD_ADDR_EXP 27
2866: PUSH
2867: LD_STRING 04_1_apes
2869: PPUSH
2870: CALL_OW 31
2874: ST_TO_ADDR
// heikeVehicles := LoadVariable ( 04_1_Vehicles , [ ] ) ;
2875: LD_ADDR_EXP 26
2879: PUSH
2880: LD_STRING 04_1_Vehicles
2882: PPUSH
2883: EMPTY
2884: PPUSH
2885: CALL_OW 30
2889: ST_TO_ADDR
// uc_side := 5 ;
2890: LD_ADDR_OWVAR 20
2894: PUSH
2895: LD_INT 5
2897: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
2898: LD_ADDR_EXP 22
2902: PUSH
2903: LD_STRING Abdul
2905: PPUSH
2906: LD_INT 0
2908: PPUSH
2909: LD_STRING 
2911: PPUSH
2912: CALL 304 0 3
2916: ST_TO_ADDR
// end ;
2917: LD_VAR 0 1
2921: RET
// every 3 3$00 trigger HexInfo ( 124 , 26 ) = 0 xor GetSide ( HexInfo ( 124 , 26 ) ) = 2 do var un , veh ;
2922: LD_INT 124
2924: PPUSH
2925: LD_INT 26
2927: PPUSH
2928: CALL_OW 428
2932: PUSH
2933: LD_INT 0
2935: EQUAL
2936: PUSH
2937: LD_INT 124
2939: PPUSH
2940: LD_INT 26
2942: PPUSH
2943: CALL_OW 428
2947: PPUSH
2948: CALL_OW 255
2952: PUSH
2953: LD_INT 2
2955: EQUAL
2956: XOR
2957: IFFALSE 3207
2959: GO 2961
2961: DISABLE
2962: LD_INT 0
2964: PPUSH
2965: PPUSH
// begin uc_side := 5 ;
2966: LD_ADDR_OWVAR 20
2970: PUSH
2971: LD_INT 5
2973: ST_TO_ADDR
// uc_nation := 2 ;
2974: LD_ADDR_OWVAR 21
2978: PUSH
2979: LD_INT 2
2981: ST_TO_ADDR
// PrepareTank ( 5 , 2 , ar_medium_trike , engine_solar , control_manual , ar_cargo_bay , 70 ) ;
2982: LD_INT 5
2984: PPUSH
2985: LD_INT 2
2987: PPUSH
2988: LD_INT 13
2990: PPUSH
2991: LD_INT 2
2993: PPUSH
2994: LD_INT 1
2996: PPUSH
2997: LD_INT 32
2999: PPUSH
3000: LD_INT 70
3002: PPUSH
3003: CALL 367 0 7
// veh := CreateVehicle ;
3007: LD_ADDR_VAR 0 2
3011: PUSH
3012: CALL_OW 45
3016: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3017: LD_VAR 0 2
3021: PPUSH
3022: LD_INT 3
3024: PPUSH
3025: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
3029: LD_VAR 0 2
3033: PPUSH
3034: LD_INT 8
3036: PPUSH
3037: LD_INT 0
3039: PPUSH
3040: CALL_OW 49
// PrepareHuman ( false , 1 , 3 ) ;
3044: LD_INT 0
3046: PPUSH
3047: LD_INT 1
3049: PPUSH
3050: LD_INT 3
3052: PPUSH
3053: CALL_OW 380
// un := CreateHuman ;
3057: LD_ADDR_VAR 0 1
3061: PUSH
3062: CALL_OW 44
3066: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
3067: LD_VAR 0 1
3071: PPUSH
3072: LD_VAR 0 2
3076: PPUSH
3077: CALL_OW 52
// SetCargo ( veh , mat_oil , 100 ) ;
3081: LD_VAR 0 2
3085: PPUSH
3086: LD_INT 2
3088: PPUSH
3089: LD_INT 100
3091: PPUSH
3092: CALL_OW 290
// ComMoveXY ( veh , 127 , 23 ) ;
3096: LD_VAR 0 2
3100: PPUSH
3101: LD_INT 127
3103: PPUSH
3104: LD_INT 23
3106: PPUSH
3107: CALL_OW 111
// AddComUnload ( veh ) ;
3111: LD_VAR 0 2
3115: PPUSH
3116: CALL_OW 219
// AddComMoveXY ( veh , 133 , 2 ) ;
3120: LD_VAR 0 2
3124: PPUSH
3125: LD_INT 133
3127: PPUSH
3128: LD_INT 2
3130: PPUSH
3131: CALL_OW 171
// wait ( 0 0$5 ) ;
3135: LD_INT 175
3137: PPUSH
3138: CALL_OW 67
// CenterOnUnits ( veh ) ;
3142: LD_VAR 0 2
3146: PPUSH
3147: CALL_OW 85
// repeat wait ( 0 0$1 ) ;
3151: LD_INT 35
3153: PPUSH
3154: CALL_OW 67
// until IsAt ( veh , 133 , 2 ) or IsInArea ( veh , spawnArea ) ;
3158: LD_VAR 0 2
3162: PPUSH
3163: LD_INT 133
3165: PPUSH
3166: LD_INT 2
3168: PPUSH
3169: CALL_OW 307
3173: PUSH
3174: LD_VAR 0 2
3178: PPUSH
3179: LD_INT 8
3181: PPUSH
3182: CALL_OW 308
3186: OR
3187: IFFALSE 3151
// RemoveUnit ( un ) ;
3189: LD_VAR 0 1
3193: PPUSH
3194: CALL_OW 64
// RemoveUnit ( veh ) ;
3198: LD_VAR 0 2
3202: PPUSH
3203: CALL_OW 64
// end ; end_of_file
3207: PPOPN 2
3209: END
// export Burlak , Gaidar , Kuzmov ; export ruForce , ruEng , ruMech , ruSci , ruMobile ; export ruSol ; export function PrepareRussian ; var base , blist , i , b , un , tmp , fac , oil ; begin
3210: LD_INT 0
3212: PPUSH
3213: PPUSH
3214: PPUSH
3215: PPUSH
3216: PPUSH
3217: PPUSH
3218: PPUSH
3219: PPUSH
3220: PPUSH
// uc_side := 3 ;
3221: LD_ADDR_OWVAR 20
3225: PUSH
3226: LD_INT 3
3228: ST_TO_ADDR
// uc_nation := 3 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 3
3236: ST_TO_ADDR
// ruForce := [ ] ;
3237: LD_ADDR_EXP 31
3241: PUSH
3242: EMPTY
3243: ST_TO_ADDR
// ruMech := [ ] ;
3244: LD_ADDR_EXP 33
3248: PUSH
3249: EMPTY
3250: ST_TO_ADDR
// ruEng := [ ] ;
3251: LD_ADDR_EXP 32
3255: PUSH
3256: EMPTY
3257: ST_TO_ADDR
// ruSci := [ ] ;
3258: LD_ADDR_EXP 34
3262: PUSH
3263: EMPTY
3264: ST_TO_ADDR
// ruMobile := [ ] ;
3265: LD_ADDR_EXP 35
3269: PUSH
3270: EMPTY
3271: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ,  ) ;
3272: LD_ADDR_EXP 28
3276: PUSH
3277: LD_STRING Burlak
3279: PPUSH
3280: LD_INT 0
3282: PPUSH
3283: LD_STRING 
3285: PPUSH
3286: CALL 304 0 3
3290: ST_TO_ADDR
// Gaidar := PrepareUnit ( Gaydar , false ,  ) ;
3291: LD_ADDR_EXP 29
3295: PUSH
3296: LD_STRING Gaydar
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: LD_STRING 
3304: PPUSH
3305: CALL 304 0 3
3309: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , false ,  ) ;
3310: LD_ADDR_EXP 30
3314: PUSH
3315: LD_STRING Kuzmov
3317: PPUSH
3318: LD_INT 0
3320: PPUSH
3321: LD_STRING 
3323: PPUSH
3324: CALL 304 0 3
3328: ST_TO_ADDR
// PlaceHumanInUnit ( Kuzmov , ruMainBase ) ;
3329: LD_EXP 30
3333: PPUSH
3334: LD_INT 200
3336: PPUSH
3337: CALL_OW 52
// SetBName ( ruMainBase , chuikov ) ;
3341: LD_INT 200
3343: PPUSH
3344: LD_STRING chuikov
3346: PPUSH
3347: CALL_OW 500
// SetResourceType ( GetBase ( ruMainBase ) , mat_cans , [ 800 , 1000 , 1250 ] [ Difficulty ] ) ;
3351: LD_INT 200
3353: PPUSH
3354: CALL_OW 274
3358: PPUSH
3359: LD_INT 1
3361: PPUSH
3362: LD_INT 800
3364: PUSH
3365: LD_INT 1000
3367: PUSH
3368: LD_INT 1250
3370: PUSH
3371: EMPTY
3372: LIST
3373: LIST
3374: LIST
3375: PUSH
3376: LD_OWVAR 67
3380: ARRAY
3381: PPUSH
3382: CALL_OW 277
// SetResourceType ( GetBase ( ruMainBase ) , mat_oil , 160 ) ;
3386: LD_INT 200
3388: PPUSH
3389: CALL_OW 274
3393: PPUSH
3394: LD_INT 2
3396: PPUSH
3397: LD_INT 160
3399: PPUSH
3400: CALL_OW 277
// SetResourceType ( GetBase ( ruSecBase ) , mat_cans , 200 ) ;
3404: LD_INT 225
3406: PPUSH
3407: CALL_OW 274
3411: PPUSH
3412: LD_INT 1
3414: PPUSH
3415: LD_INT 200
3417: PPUSH
3418: CALL_OW 277
// oil := 150 ;
3422: LD_ADDR_VAR 0 9
3426: PUSH
3427: LD_INT 150
3429: ST_TO_ADDR
// if gameTime >= [ 40 40$00 , 35 35$00 , 33 33$00 ] [ Difficulty ] then
3430: LD_EXP 5
3434: PUSH
3435: LD_INT 84000
3437: PUSH
3438: LD_INT 73500
3440: PUSH
3441: LD_INT 69300
3443: PUSH
3444: EMPTY
3445: LIST
3446: LIST
3447: LIST
3448: PUSH
3449: LD_OWVAR 67
3453: ARRAY
3454: GREATEREQUAL
3455: IFFALSE 3610
// begin oil := 450 ;
3457: LD_ADDR_VAR 0 9
3461: PUSH
3462: LD_INT 450
3464: ST_TO_ADDR
// tmp := [ [ 123 , 17 , 3 , b_breastwork ] , [ 152 , 38 , 3 , b_breastwork ] , [ 81 , 6 , 4 , b_breastwork ] , [ 113 , 67 , 4 , b_bunker ] ] ;
3465: LD_ADDR_VAR 0 7
3469: PUSH
3470: LD_INT 123
3472: PUSH
3473: LD_INT 17
3475: PUSH
3476: LD_INT 3
3478: PUSH
3479: LD_INT 31
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 152
3490: PUSH
3491: LD_INT 38
3493: PUSH
3494: LD_INT 3
3496: PUSH
3497: LD_INT 31
3499: PUSH
3500: EMPTY
3501: LIST
3502: LIST
3503: LIST
3504: LIST
3505: PUSH
3506: LD_INT 81
3508: PUSH
3509: LD_INT 6
3511: PUSH
3512: LD_INT 4
3514: PUSH
3515: LD_INT 31
3517: PUSH
3518: EMPTY
3519: LIST
3520: LIST
3521: LIST
3522: LIST
3523: PUSH
3524: LD_INT 113
3526: PUSH
3527: LD_INT 67
3529: PUSH
3530: LD_INT 4
3532: PUSH
3533: LD_INT 32
3535: PUSH
3536: EMPTY
3537: LIST
3538: LIST
3539: LIST
3540: LIST
3541: PUSH
3542: EMPTY
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: ST_TO_ADDR
// for i in tmp do
3548: LD_ADDR_VAR 0 4
3552: PUSH
3553: LD_VAR 0 7
3557: PUSH
3558: FOR_IN
3559: IFFALSE 3608
// begin bc_type := i [ 4 ] ;
3561: LD_ADDR_OWVAR 42
3565: PUSH
3566: LD_VAR 0 4
3570: PUSH
3571: LD_INT 4
3573: ARRAY
3574: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3575: LD_VAR 0 4
3579: PUSH
3580: LD_INT 1
3582: ARRAY
3583: PPUSH
3584: LD_VAR 0 4
3588: PUSH
3589: LD_INT 2
3591: ARRAY
3592: PPUSH
3593: LD_VAR 0 4
3597: PUSH
3598: LD_INT 3
3600: ARRAY
3601: PPUSH
3602: CALL_OW 47
// end ;
3606: GO 3558
3608: POP
3609: POP
// end ; SetResourceType ( GetBase ( ruSecBase ) , mat_oil , oil ) ;
3610: LD_INT 225
3612: PPUSH
3613: CALL_OW 274
3617: PPUSH
3618: LD_INT 2
3620: PPUSH
3621: LD_VAR 0 9
3625: PPUSH
3626: CALL_OW 277
// if Difficulty > 1 then
3630: LD_OWVAR 67
3634: PUSH
3635: LD_INT 1
3637: GREATER
3638: IFFALSE 3733
// begin bc_type := b_bunker ;
3640: LD_ADDR_OWVAR 42
3644: PUSH
3645: LD_INT 32
3647: ST_TO_ADDR
// tmp := [ [ 121 , 85 , 5 ] , [ 93 , 72 , 1 ] ] ;
3648: LD_ADDR_VAR 0 7
3652: PUSH
3653: LD_INT 121
3655: PUSH
3656: LD_INT 85
3658: PUSH
3659: LD_INT 5
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: LIST
3666: PUSH
3667: LD_INT 93
3669: PUSH
3670: LD_INT 72
3672: PUSH
3673: LD_INT 1
3675: PUSH
3676: EMPTY
3677: LIST
3678: LIST
3679: LIST
3680: PUSH
3681: EMPTY
3682: LIST
3683: LIST
3684: ST_TO_ADDR
// for i in tmp do
3685: LD_ADDR_VAR 0 4
3689: PUSH
3690: LD_VAR 0 7
3694: PUSH
3695: FOR_IN
3696: IFFALSE 3731
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3698: LD_VAR 0 4
3702: PUSH
3703: LD_INT 1
3705: ARRAY
3706: PPUSH
3707: LD_VAR 0 4
3711: PUSH
3712: LD_INT 2
3714: ARRAY
3715: PPUSH
3716: LD_VAR 0 4
3720: PUSH
3721: LD_INT 3
3723: ARRAY
3724: PPUSH
3725: CALL_OW 47
3729: GO 3695
3731: POP
3732: POP
// end ; base := GetBase ( ruMainBase ) ;
3733: LD_ADDR_VAR 0 2
3737: PUSH
3738: LD_INT 200
3740: PPUSH
3741: CALL_OW 274
3745: ST_TO_ADDR
// blist := GetBuildList ( base ) ;
3746: LD_ADDR_VAR 0 3
3750: PUSH
3751: LD_VAR 0 2
3755: PPUSH
3756: CALL_OW 417
3760: ST_TO_ADDR
// for b in blist do
3761: LD_ADDR_VAR 0 5
3765: PUSH
3766: LD_VAR 0 3
3770: PUSH
3771: FOR_IN
3772: IFFALSE 4175
// begin if b [ 1 ] = b_factory then
3774: LD_VAR 0 5
3778: PUSH
3779: LD_INT 1
3781: ARRAY
3782: PUSH
3783: LD_INT 3
3785: EQUAL
3786: IFFALSE 3916
// begin fac := HexInfo ( b [ 2 ] , b [ 3 ] ) ;
3788: LD_ADDR_VAR 0 8
3792: PUSH
3793: LD_VAR 0 5
3797: PUSH
3798: LD_INT 2
3800: ARRAY
3801: PPUSH
3802: LD_VAR 0 5
3806: PUSH
3807: LD_INT 3
3809: ARRAY
3810: PPUSH
3811: CALL_OW 428
3815: ST_TO_ADDR
// for i := 1 to 2 + Difficulty do
3816: LD_ADDR_VAR 0 4
3820: PUSH
3821: DOUBLE
3822: LD_INT 1
3824: DEC
3825: ST_TO_ADDR
3826: LD_INT 2
3828: PUSH
3829: LD_OWVAR 67
3833: PLUS
3834: PUSH
3835: FOR_TO
3836: IFFALSE 3912
// begin PrepareHuman ( false , 3 , 1 + Difficulty ) ;
3838: LD_INT 0
3840: PPUSH
3841: LD_INT 3
3843: PPUSH
3844: LD_INT 1
3846: PUSH
3847: LD_OWVAR 67
3851: PLUS
3852: PPUSH
3853: CALL_OW 380
// un := CreateHuman ;
3857: LD_ADDR_VAR 0 6
3861: PUSH
3862: CALL_OW 44
3866: ST_TO_ADDR
// ruMech := Replace ( ruMech , ruMech + 1 , un ) ;
3867: LD_ADDR_EXP 33
3871: PUSH
3872: LD_EXP 33
3876: PPUSH
3877: LD_EXP 33
3881: PUSH
3882: LD_INT 1
3884: PLUS
3885: PPUSH
3886: LD_VAR 0 6
3890: PPUSH
3891: CALL_OW 1
3895: ST_TO_ADDR
// PlaceHumanInUnit ( un , fac ) ;
3896: LD_VAR 0 6
3900: PPUSH
3901: LD_VAR 0 8
3905: PPUSH
3906: CALL_OW 52
// end ;
3910: GO 3835
3912: POP
3913: POP
// end else
3914: GO 4173
// if b [ 1 ] in [ b_lab , b_lab_half , b_lab_full , b_lab_weapon ] then
3916: LD_VAR 0 5
3920: PUSH
3921: LD_INT 1
3923: ARRAY
3924: PUSH
3925: LD_INT 6
3927: PUSH
3928: LD_INT 7
3930: PUSH
3931: LD_INT 8
3933: PUSH
3934: LD_INT 10
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: LIST
3941: LIST
3942: IN
3943: IFFALSE 4053
// begin for i := 1 to 2 do
3945: LD_ADDR_VAR 0 4
3949: PUSH
3950: DOUBLE
3951: LD_INT 1
3953: DEC
3954: ST_TO_ADDR
3955: LD_INT 2
3957: PUSH
3958: FOR_TO
3959: IFFALSE 4049
// begin PrepareHuman ( false , 4 , Difficulty ) ;
3961: LD_INT 0
3963: PPUSH
3964: LD_INT 4
3966: PPUSH
3967: LD_OWVAR 67
3971: PPUSH
3972: CALL_OW 380
// un := CreateHuman ;
3976: LD_ADDR_VAR 0 6
3980: PUSH
3981: CALL_OW 44
3985: ST_TO_ADDR
// ruSci := Replace ( ruSci , ruSci + 1 , un ) ;
3986: LD_ADDR_EXP 34
3990: PUSH
3991: LD_EXP 34
3995: PPUSH
3996: LD_EXP 34
4000: PUSH
4001: LD_INT 1
4003: PLUS
4004: PPUSH
4005: LD_VAR 0 6
4009: PPUSH
4010: CALL_OW 1
4014: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4015: LD_VAR 0 6
4019: PPUSH
4020: LD_VAR 0 5
4024: PUSH
4025: LD_INT 2
4027: ARRAY
4028: PPUSH
4029: LD_VAR 0 5
4033: PUSH
4034: LD_INT 3
4036: ARRAY
4037: PPUSH
4038: CALL_OW 428
4042: PPUSH
4043: CALL_OW 52
// end ;
4047: GO 3958
4049: POP
4050: POP
// end else
4051: GO 4173
// if b [ 1 ] = b_warehouse then
4053: LD_VAR 0 5
4057: PUSH
4058: LD_INT 1
4060: ARRAY
4061: PUSH
4062: LD_INT 1
4064: EQUAL
4065: IFFALSE 4173
// begin for i := 1 to 3 do
4067: LD_ADDR_VAR 0 4
4071: PUSH
4072: DOUBLE
4073: LD_INT 1
4075: DEC
4076: ST_TO_ADDR
4077: LD_INT 3
4079: PUSH
4080: FOR_TO
4081: IFFALSE 4171
// begin PrepareHuman ( false , 2 , Difficulty ) ;
4083: LD_INT 0
4085: PPUSH
4086: LD_INT 2
4088: PPUSH
4089: LD_OWVAR 67
4093: PPUSH
4094: CALL_OW 380
// un := CreateHuman ;
4098: LD_ADDR_VAR 0 6
4102: PUSH
4103: CALL_OW 44
4107: ST_TO_ADDR
// ruEng := Replace ( ruEng , ruEng + 1 , un ) ;
4108: LD_ADDR_EXP 32
4112: PUSH
4113: LD_EXP 32
4117: PPUSH
4118: LD_EXP 32
4122: PUSH
4123: LD_INT 1
4125: PLUS
4126: PPUSH
4127: LD_VAR 0 6
4131: PPUSH
4132: CALL_OW 1
4136: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4137: LD_VAR 0 6
4141: PPUSH
4142: LD_VAR 0 5
4146: PUSH
4147: LD_INT 2
4149: ARRAY
4150: PPUSH
4151: LD_VAR 0 5
4155: PUSH
4156: LD_INT 3
4158: ARRAY
4159: PPUSH
4160: CALL_OW 428
4164: PPUSH
4165: CALL_OW 52
// end ;
4169: GO 4080
4171: POP
4172: POP
// end ; end ;
4173: GO 3771
4175: POP
4176: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4177: LD_ADDR_VAR 0 3
4181: PUSH
4182: LD_INT 22
4184: PUSH
4185: LD_INT 3
4187: PUSH
4188: EMPTY
4189: LIST
4190: LIST
4191: PUSH
4192: LD_INT 21
4194: PUSH
4195: LD_INT 3
4197: PUSH
4198: EMPTY
4199: LIST
4200: LIST
4201: PUSH
4202: EMPTY
4203: LIST
4204: LIST
4205: PPUSH
4206: CALL_OW 69
4210: ST_TO_ADDR
// for b in blist do
4211: LD_ADDR_VAR 0 5
4215: PUSH
4216: LD_VAR 0 3
4220: PUSH
4221: FOR_IN
4222: IFFALSE 4244
// SetBLevel ( b , 3 + Difficulty ) ;
4224: LD_VAR 0 5
4228: PPUSH
4229: LD_INT 3
4231: PUSH
4232: LD_OWVAR 67
4236: PLUS
4237: PPUSH
4238: CALL_OW 241
4242: GO 4221
4244: POP
4245: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4246: LD_ADDR_VAR 0 3
4250: PUSH
4251: LD_INT 22
4253: PUSH
4254: LD_INT 3
4256: PUSH
4257: EMPTY
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 30
4263: PUSH
4264: LD_INT 32
4266: PUSH
4267: EMPTY
4268: LIST
4269: LIST
4270: PUSH
4271: EMPTY
4272: LIST
4273: LIST
4274: PPUSH
4275: CALL_OW 69
4279: ST_TO_ADDR
// for b in blist do
4280: LD_ADDR_VAR 0 5
4284: PUSH
4285: LD_VAR 0 3
4289: PUSH
4290: FOR_IN
4291: IFFALSE 4400
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4293: LD_INT 0
4295: PPUSH
4296: LD_INT 1
4298: PPUSH
4299: LD_INT 1
4301: PUSH
4302: LD_OWVAR 67
4306: PLUS
4307: PPUSH
4308: CALL_OW 380
// un := CreateHuman ;
4312: LD_ADDR_VAR 0 6
4316: PUSH
4317: CALL_OW 44
4321: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4322: LD_ADDR_EXP 31
4326: PUSH
4327: LD_EXP 31
4331: PPUSH
4332: LD_EXP 31
4336: PUSH
4337: LD_INT 1
4339: PLUS
4340: PPUSH
4341: LD_VAR 0 6
4345: PPUSH
4346: CALL_OW 1
4350: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4351: LD_VAR 0 6
4355: PPUSH
4356: LD_VAR 0 5
4360: PPUSH
4361: CALL_OW 52
// PlaceWeaponTurret ( b , [ ru_gun , ru_gatling_gun ] [ b mod 2 + 1 ] ) ;
4365: LD_VAR 0 5
4369: PPUSH
4370: LD_INT 44
4372: PUSH
4373: LD_INT 43
4375: PUSH
4376: EMPTY
4377: LIST
4378: LIST
4379: PUSH
4380: LD_VAR 0 5
4384: PUSH
4385: LD_INT 2
4387: MOD
4388: PUSH
4389: LD_INT 1
4391: PLUS
4392: ARRAY
4393: PPUSH
4394: CALL_OW 431
// end ;
4398: GO 4290
4400: POP
4401: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4402: LD_ADDR_VAR 0 3
4406: PUSH
4407: LD_INT 22
4409: PUSH
4410: LD_INT 3
4412: PUSH
4413: EMPTY
4414: LIST
4415: LIST
4416: PUSH
4417: LD_INT 30
4419: PUSH
4420: LD_INT 31
4422: PUSH
4423: EMPTY
4424: LIST
4425: LIST
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PPUSH
4431: CALL_OW 69
4435: ST_TO_ADDR
// for b in blist do
4436: LD_ADDR_VAR 0 5
4440: PUSH
4441: LD_VAR 0 3
4445: PUSH
4446: FOR_IN
4447: IFFALSE 4546
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4449: LD_INT 0
4451: PPUSH
4452: LD_INT 1
4454: PPUSH
4455: LD_INT 1
4457: PUSH
4458: LD_OWVAR 67
4462: PLUS
4463: PPUSH
4464: CALL_OW 380
// un := CreateHuman ;
4468: LD_ADDR_VAR 0 6
4472: PUSH
4473: CALL_OW 44
4477: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4478: LD_ADDR_EXP 31
4482: PUSH
4483: LD_EXP 31
4487: PPUSH
4488: LD_EXP 31
4492: PUSH
4493: LD_INT 1
4495: PLUS
4496: PPUSH
4497: LD_VAR 0 6
4501: PPUSH
4502: CALL_OW 1
4506: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) + 3 ) ;
4507: LD_VAR 0 6
4511: PPUSH
4512: LD_VAR 0 5
4516: PPUSH
4517: CALL_OW 254
4521: PUSH
4522: LD_INT 3
4524: PLUS
4525: PPUSH
4526: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4530: LD_VAR 0 6
4534: PPUSH
4535: LD_VAR 0 5
4539: PPUSH
4540: CALL_OW 52
// end ;
4544: GO 4446
4546: POP
4547: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4548: LD_ADDR_VAR 0 3
4552: PUSH
4553: LD_INT 22
4555: PUSH
4556: LD_INT 3
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 2
4565: PUSH
4566: LD_INT 30
4568: PUSH
4569: LD_INT 4
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 30
4578: PUSH
4579: LD_INT 5
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: EMPTY
4587: LIST
4588: LIST
4589: LIST
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: PPUSH
4595: CALL_OW 69
4599: ST_TO_ADDR
// for b in blist do
4600: LD_ADDR_VAR 0 5
4604: PUSH
4605: LD_VAR 0 3
4609: PUSH
4610: FOR_IN
4611: IFFALSE 4707
// begin for i := 1 to 2 do
4613: LD_ADDR_VAR 0 4
4617: PUSH
4618: DOUBLE
4619: LD_INT 1
4621: DEC
4622: ST_TO_ADDR
4623: LD_INT 2
4625: PUSH
4626: FOR_TO
4627: IFFALSE 4703
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4629: LD_INT 0
4631: PPUSH
4632: LD_INT 1
4634: PPUSH
4635: LD_INT 1
4637: PUSH
4638: LD_OWVAR 67
4642: PLUS
4643: PPUSH
4644: CALL_OW 380
// un := CreateHuman ;
4648: LD_ADDR_VAR 0 6
4652: PUSH
4653: CALL_OW 44
4657: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4658: LD_ADDR_EXP 31
4662: PUSH
4663: LD_EXP 31
4667: PPUSH
4668: LD_EXP 31
4672: PUSH
4673: LD_INT 1
4675: PLUS
4676: PPUSH
4677: LD_VAR 0 6
4681: PPUSH
4682: CALL_OW 1
4686: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4687: LD_VAR 0 6
4691: PPUSH
4692: LD_VAR 0 5
4696: PPUSH
4697: CALL_OW 52
// end ;
4701: GO 4626
4703: POP
4704: POP
// end ;
4705: GO 4610
4707: POP
4708: POP
// if ibrahimOnRuSide then
4709: LD_EXP 3
4713: IFFALSE 4811
// begin Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
4715: LD_ADDR_EXP 17
4719: PUSH
4720: LD_STRING IbrahimRu
4722: PPUSH
4723: LD_INT 0
4725: PPUSH
4726: LD_STRING 
4728: PPUSH
4729: CALL 304 0 3
4733: ST_TO_ADDR
// PlaceUnitXY ( Ibrahim , 121 , 78 , false ) ;
4734: LD_EXP 17
4738: PPUSH
4739: LD_INT 121
4741: PPUSH
4742: LD_INT 78
4744: PPUSH
4745: LD_INT 0
4747: PPUSH
4748: CALL_OW 48
// ComHold ( Ibrahim ) ;
4752: LD_EXP 17
4756: PPUSH
4757: CALL_OW 140
// PrepareHuman ( sex_male , 1 , 1 ) ;
4761: LD_INT 1
4763: PPUSH
4764: LD_INT 1
4766: PPUSH
4767: LD_INT 1
4769: PPUSH
4770: CALL_OW 380
// ruSol := CreateHuman ;
4774: LD_ADDR_EXP 36
4778: PUSH
4779: CALL_OW 44
4783: ST_TO_ADDR
// PlaceUnitXY ( ruSol , 121 , 75 , false ) ;
4784: LD_EXP 36
4788: PPUSH
4789: LD_INT 121
4791: PPUSH
4792: LD_INT 75
4794: PPUSH
4795: LD_INT 0
4797: PPUSH
4798: CALL_OW 48
// ComHold ( ruSol ) ;
4802: LD_EXP 36
4806: PPUSH
4807: CALL_OW 140
// end ; for i := 1 to 2 + Difficulty do
4811: LD_ADDR_VAR 0 4
4815: PUSH
4816: DOUBLE
4817: LD_INT 1
4819: DEC
4820: ST_TO_ADDR
4821: LD_INT 2
4823: PUSH
4824: LD_OWVAR 67
4828: PLUS
4829: PUSH
4830: FOR_TO
4831: IFFALSE 4900
// AddComConstruct ( fac , [ ru_medium_wheeled , ru_heavy_wheeled , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] ) ;
4833: LD_VAR 0 8
4837: PPUSH
4838: LD_INT 21
4840: PUSH
4841: LD_INT 23
4843: PUSH
4844: LD_INT 24
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: LIST
4851: PUSH
4852: LD_VAR 0 4
4856: PUSH
4857: LD_INT 3
4859: MOD
4860: PUSH
4861: LD_INT 1
4863: PLUS
4864: ARRAY
4865: PPUSH
4866: LD_INT 1
4868: PPUSH
4869: LD_INT 1
4871: PPUSH
4872: LD_INT 43
4874: PUSH
4875: LD_INT 44
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PUSH
4882: LD_INT 1
4884: PPUSH
4885: LD_INT 2
4887: PPUSH
4888: CALL_OW 12
4892: ARRAY
4893: PPUSH
4894: CALL_OW 185
4898: GO 4830
4900: POP
4901: POP
// end ;
4902: LD_VAR 0 1
4906: RET
// every 0 0$1 trigger ruMobile and not ruEscapeAllowed do var i , filter , tmp , enemy , x ;
4907: LD_EXP 35
4911: PUSH
4912: LD_EXP 4
4916: NOT
4917: AND
4918: IFFALSE 5405
4920: GO 4922
4922: DISABLE
4923: LD_INT 0
4925: PPUSH
4926: PPUSH
4927: PPUSH
4928: PPUSH
4929: PPUSH
// begin enable ;
4930: ENABLE
// filter := UnitFilter ( ruMobile , [ f_type , unit_vehicle ] ) ;
4931: LD_ADDR_VAR 0 2
4935: PUSH
4936: LD_EXP 35
4940: PPUSH
4941: LD_INT 21
4943: PUSH
4944: LD_INT 2
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PPUSH
4951: CALL_OW 72
4955: ST_TO_ADDR
// enemy := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_or , [ f_inarea , zone1 ] , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) ;
4956: LD_ADDR_VAR 0 4
4960: PUSH
4961: LD_INT 81
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: PUSH
4971: LD_INT 2
4973: PUSH
4974: LD_INT 95
4976: PUSH
4977: LD_INT 4
4979: PUSH
4980: EMPTY
4981: LIST
4982: LIST
4983: PUSH
4984: LD_INT 95
4986: PUSH
4987: LD_INT 5
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: PUSH
4994: LD_INT 95
4996: PUSH
4997: LD_INT 6
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 95
5006: PUSH
5007: LD_INT 7
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: LIST
5018: LIST
5019: LIST
5020: PUSH
5021: EMPTY
5022: LIST
5023: LIST
5024: PPUSH
5025: CALL_OW 69
5029: ST_TO_ADDR
// for i in filter do
5030: LD_ADDR_VAR 0 1
5034: PUSH
5035: LD_VAR 0 2
5039: PUSH
5040: FOR_IN
5041: IFFALSE 5403
// begin tmp := IsDrivenBy ( i ) ;
5043: LD_ADDR_VAR 0 3
5047: PUSH
5048: LD_VAR 0 1
5052: PPUSH
5053: CALL_OW 311
5057: ST_TO_ADDR
// if not tmp then
5058: LD_VAR 0 3
5062: NOT
5063: IFFALSE 5067
// continue ;
5065: GO 5040
// if GetFuel ( i ) > 90 and GetTag ( i ) = 2 then
5067: LD_VAR 0 1
5071: PPUSH
5072: CALL_OW 261
5076: PUSH
5077: LD_INT 90
5079: GREATER
5080: PUSH
5081: LD_VAR 0 1
5085: PPUSH
5086: CALL_OW 110
5090: PUSH
5091: LD_INT 2
5093: EQUAL
5094: AND
5095: IFFALSE 5111
// SetTag ( i , 0 ) else
5097: LD_VAR 0 1
5101: PPUSH
5102: LD_INT 0
5104: PPUSH
5105: CALL_OW 109
5109: GO 5154
// if GetTag ( i ) = 2 then
5111: LD_VAR 0 1
5115: PPUSH
5116: CALL_OW 110
5120: PUSH
5121: LD_INT 2
5123: EQUAL
5124: IFFALSE 5154
// begin x := rand ( 1 , 2 ) ;
5126: LD_ADDR_VAR 0 5
5130: PUSH
5131: LD_INT 1
5133: PPUSH
5134: LD_INT 2
5136: PPUSH
5137: CALL_OW 12
5141: ST_TO_ADDR
// AddComMoveUnit ( i , ruMainBase ) ;
5142: LD_VAR 0 1
5146: PPUSH
5147: LD_INT 200
5149: PPUSH
5150: CALL_OW 172
// end ; if GetLives ( i ) >= 600 and not GetTag ( i ) then
5154: LD_VAR 0 1
5158: PPUSH
5159: CALL_OW 256
5163: PUSH
5164: LD_INT 600
5166: GREATEREQUAL
5167: PUSH
5168: LD_VAR 0 1
5172: PPUSH
5173: CALL_OW 110
5177: NOT
5178: AND
5179: IFFALSE 5205
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
5181: LD_VAR 0 1
5185: PPUSH
5186: LD_VAR 0 4
5190: PPUSH
5191: LD_VAR 0 1
5195: PPUSH
5196: CALL_OW 74
5200: PPUSH
5201: CALL_OW 115
// if GetLives ( i ) < 600 and not GetTag ( i ) then
5205: LD_VAR 0 1
5209: PPUSH
5210: CALL_OW 256
5214: PUSH
5215: LD_INT 600
5217: LESS
5218: PUSH
5219: LD_VAR 0 1
5223: PPUSH
5224: CALL_OW 110
5228: NOT
5229: AND
5230: IFFALSE 5259
// begin SetTag ( i , 1 ) ;
5232: LD_VAR 0 1
5236: PPUSH
5237: LD_INT 1
5239: PPUSH
5240: CALL_OW 109
// ComMoveXY ( i , 112 , 119 ) ;
5244: LD_VAR 0 1
5248: PPUSH
5249: LD_INT 112
5251: PPUSH
5252: LD_INT 119
5254: PPUSH
5255: CALL_OW 111
// end ; if GetTag ( i ) = 1 and GetDistUnitXY ( i , 112 , 119 ) < 9 and tmp then
5259: LD_VAR 0 1
5263: PPUSH
5264: CALL_OW 110
5268: PUSH
5269: LD_INT 1
5271: EQUAL
5272: PUSH
5273: LD_VAR 0 1
5277: PPUSH
5278: LD_INT 112
5280: PPUSH
5281: LD_INT 119
5283: PPUSH
5284: CALL_OW 297
5288: PUSH
5289: LD_INT 9
5291: LESS
5292: AND
5293: PUSH
5294: LD_VAR 0 3
5298: AND
5299: IFFALSE 5401
// begin ComExitVehicle ( tmp ) ;
5301: LD_VAR 0 3
5305: PPUSH
5306: CALL_OW 121
// AddComRepairVehicle ( tmp , i ) ;
5310: LD_VAR 0 3
5314: PPUSH
5315: LD_VAR 0 1
5319: PPUSH
5320: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
5324: LD_INT 35
5326: PPUSH
5327: CALL_OW 67
// until GetLives ( i ) = 1000 ;
5331: LD_VAR 0 1
5335: PPUSH
5336: CALL_OW 256
5340: PUSH
5341: LD_INT 1000
5343: EQUAL
5344: IFFALSE 5324
// ComEnterUnit ( tmp , i ) ;
5346: LD_VAR 0 3
5350: PPUSH
5351: LD_VAR 0 1
5355: PPUSH
5356: CALL_OW 120
// if GetFuel ( i ) <= 50 then
5360: LD_VAR 0 1
5364: PPUSH
5365: CALL_OW 261
5369: PUSH
5370: LD_INT 50
5372: LESSEQUAL
5373: IFFALSE 5389
// SetTag ( i , 2 ) else
5375: LD_VAR 0 1
5379: PPUSH
5380: LD_INT 2
5382: PPUSH
5383: CALL_OW 109
5387: GO 5401
// SetTag ( i , 0 ) ;
5389: LD_VAR 0 1
5393: PPUSH
5394: LD_INT 0
5396: PPUSH
5397: CALL_OW 109
// end ; end ;
5401: GO 5040
5403: POP
5404: POP
// end ;
5405: PPOPN 5
5407: END
// every 0 0$1 trigger not ruEscapeAllowed and ruEng do var i , filter , tmp , enemy ;
5408: LD_EXP 4
5412: NOT
5413: PUSH
5414: LD_EXP 32
5418: AND
5419: IFFALSE 5661
5421: GO 5423
5423: DISABLE
5424: LD_INT 0
5426: PPUSH
5427: PPUSH
5428: PPUSH
5429: PPUSH
// begin enable ;
5430: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: LD_INT 3
5438: PPUSH
5439: LD_INT 22
5441: PUSH
5442: LD_INT 3
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PUSH
5449: LD_INT 21
5451: PUSH
5452: LD_INT 3
5454: PUSH
5455: EMPTY
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 3
5461: PUSH
5462: LD_INT 24
5464: PUSH
5465: LD_INT 1000
5467: PUSH
5468: EMPTY
5469: LIST
5470: LIST
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: LIST
5480: PPUSH
5481: CALL_OW 70
5485: ST_TO_ADDR
// tmp := UnitFilter ( ruEng , [ f_ok ] ) ;
5486: LD_ADDR_VAR 0 3
5490: PUSH
5491: LD_EXP 32
5495: PPUSH
5496: LD_INT 50
5498: PUSH
5499: EMPTY
5500: LIST
5501: PPUSH
5502: CALL_OW 72
5506: ST_TO_ADDR
// if filter and tmp then
5507: LD_VAR 0 2
5511: PUSH
5512: LD_VAR 0 3
5516: AND
5517: IFFALSE 5590
// begin for i in tmp do
5519: LD_ADDR_VAR 0 1
5523: PUSH
5524: LD_VAR 0 3
5528: PUSH
5529: FOR_IN
5530: IFFALSE 5586
// if IsInUnit ( i ) then
5532: LD_VAR 0 1
5536: PPUSH
5537: CALL_OW 310
5541: IFFALSE 5554
// ComExitBuilding ( i ) else
5543: LD_VAR 0 1
5547: PPUSH
5548: CALL_OW 122
5552: GO 5584
// if not HasTask ( i ) then
5554: LD_VAR 0 1
5558: PPUSH
5559: CALL_OW 314
5563: NOT
5564: IFFALSE 5584
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5566: LD_VAR 0 1
5570: PPUSH
5571: LD_VAR 0 2
5575: PUSH
5576: LD_INT 1
5578: ARRAY
5579: PPUSH
5580: CALL_OW 130
5584: GO 5529
5586: POP
5587: POP
// end else
5588: GO 5661
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5590: LD_VAR 0 3
5594: PPUSH
5595: LD_INT 3
5597: PUSH
5598: LD_INT 54
5600: PUSH
5601: EMPTY
5602: LIST
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PPUSH
5608: CALL_OW 72
5612: IFFALSE 5661
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5614: LD_ADDR_VAR 0 1
5618: PUSH
5619: LD_VAR 0 3
5623: PPUSH
5624: LD_INT 3
5626: PUSH
5627: LD_INT 54
5629: PUSH
5630: EMPTY
5631: LIST
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PPUSH
5637: CALL_OW 72
5641: PUSH
5642: FOR_IN
5643: IFFALSE 5659
// ComEnterUnit ( i , ruMainBase ) ;
5645: LD_VAR 0 1
5649: PPUSH
5650: LD_INT 200
5652: PPUSH
5653: CALL_OW 120
5657: GO 5642
5659: POP
5660: POP
// end ; end ;
5661: PPOPN 4
5663: END
// every 0 0$1 trigger not ruEscapeAllowed and ruSci do var i , filter , tmp , lab ;
5664: LD_EXP 4
5668: NOT
5669: PUSH
5670: LD_EXP 34
5674: AND
5675: IFFALSE 5935
5677: GO 5679
5679: DISABLE
5680: LD_INT 0
5682: PPUSH
5683: PPUSH
5684: PPUSH
5685: PPUSH
// begin enable ;
5686: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5687: LD_ADDR_VAR 0 2
5691: PUSH
5692: LD_INT 3
5694: PPUSH
5695: LD_INT 22
5697: PUSH
5698: LD_INT 3
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PUSH
5705: LD_INT 21
5707: PUSH
5708: LD_INT 1
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PUSH
5715: LD_INT 3
5717: PUSH
5718: LD_INT 24
5720: PUSH
5721: LD_INT 1000
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: LIST
5736: PPUSH
5737: CALL_OW 70
5741: ST_TO_ADDR
// tmp := UnitFilter ( ruSci , [ f_ok ] ) ;
5742: LD_ADDR_VAR 0 3
5746: PUSH
5747: LD_EXP 34
5751: PPUSH
5752: LD_INT 50
5754: PUSH
5755: EMPTY
5756: LIST
5757: PPUSH
5758: CALL_OW 72
5762: ST_TO_ADDR
// lab := HexInfo ( 118 , 121 ) ;
5763: LD_ADDR_VAR 0 4
5767: PUSH
5768: LD_INT 118
5770: PPUSH
5771: LD_INT 121
5773: PPUSH
5774: CALL_OW 428
5778: ST_TO_ADDR
// if filter and tmp then
5779: LD_VAR 0 2
5783: PUSH
5784: LD_VAR 0 3
5788: AND
5789: IFFALSE 5862
// begin for i in tmp do
5791: LD_ADDR_VAR 0 1
5795: PUSH
5796: LD_VAR 0 3
5800: PUSH
5801: FOR_IN
5802: IFFALSE 5858
// if IsInUnit ( i ) then
5804: LD_VAR 0 1
5808: PPUSH
5809: CALL_OW 310
5813: IFFALSE 5826
// ComExitBuilding ( i ) else
5815: LD_VAR 0 1
5819: PPUSH
5820: CALL_OW 122
5824: GO 5856
// if not HasTask ( i ) then
5826: LD_VAR 0 1
5830: PPUSH
5831: CALL_OW 314
5835: NOT
5836: IFFALSE 5856
// ComHeal ( i , filter [ 1 ] ) ;
5838: LD_VAR 0 1
5842: PPUSH
5843: LD_VAR 0 2
5847: PUSH
5848: LD_INT 1
5850: ARRAY
5851: PPUSH
5852: CALL_OW 128
5856: GO 5801
5858: POP
5859: POP
// end else
5860: GO 5935
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5862: LD_VAR 0 3
5866: PPUSH
5867: LD_INT 3
5869: PUSH
5870: LD_INT 54
5872: PUSH
5873: EMPTY
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 72
5884: IFFALSE 5935
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5886: LD_ADDR_VAR 0 1
5890: PUSH
5891: LD_VAR 0 3
5895: PPUSH
5896: LD_INT 3
5898: PUSH
5899: LD_INT 54
5901: PUSH
5902: EMPTY
5903: LIST
5904: PUSH
5905: EMPTY
5906: LIST
5907: LIST
5908: PPUSH
5909: CALL_OW 72
5913: PUSH
5914: FOR_IN
5915: IFFALSE 5933
// ComEnterUnit ( i , lab ) ;
5917: LD_VAR 0 1
5921: PPUSH
5922: LD_VAR 0 4
5926: PPUSH
5927: CALL_OW 120
5931: GO 5914
5933: POP
5934: POP
// end ; end ; end_of_file
5935: PPOPN 4
5937: END
// on UnitDestroyed ( un ) do begin if un = Heike then
5938: LD_VAR 0 1
5942: PUSH
5943: LD_EXP 14
5947: EQUAL
5948: IFFALSE 5957
// YouLost ( Heike ) ;
5950: LD_STRING Heike
5952: PPUSH
5953: CALL_OW 104
// if un in ruEng then
5957: LD_VAR 0 1
5961: PUSH
5962: LD_EXP 32
5966: IN
5967: IFFALSE 5985
// ruEng := ruEng diff un ;
5969: LD_ADDR_EXP 32
5973: PUSH
5974: LD_EXP 32
5978: PUSH
5979: LD_VAR 0 1
5983: DIFF
5984: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) then
5985: LD_VAR 0 1
5989: PUSH
5990: LD_INT 22
5992: PUSH
5993: LD_INT 2
5995: PUSH
5996: EMPTY
5997: LIST
5998: LIST
5999: PUSH
6000: LD_INT 21
6002: PUSH
6003: LD_INT 1
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PUSH
6010: LD_INT 23
6012: PUSH
6013: LD_INT 2
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: PUSH
6020: EMPTY
6021: LIST
6022: LIST
6023: LIST
6024: PPUSH
6025: CALL_OW 69
6029: IN
6030: IFFALSE 6046
// loseCounter := loseCounter + 1 ;
6032: LD_ADDR_EXP 6
6036: PUSH
6037: LD_EXP 6
6041: PUSH
6042: LD_INT 1
6044: PLUS
6045: ST_TO_ADDR
// end ;
6046: PPOPN 1
6048: END
// on EvacuateVehicle ( driver , un , p1 , p2 ) do var weapon , fac ;
6049: LD_INT 0
6051: PPUSH
6052: PPUSH
// begin if un in ruMobile then
6053: LD_VAR 0 2
6057: PUSH
6058: LD_EXP 35
6062: IN
6063: IFFALSE 6222
// begin ruMobile := ruMobile diff un ;
6065: LD_ADDR_EXP 35
6069: PUSH
6070: LD_EXP 35
6074: PUSH
6075: LD_VAR 0 2
6079: DIFF
6080: ST_TO_ADDR
// weapon := GetWeapon ( un ) ;
6081: LD_ADDR_VAR 0 5
6085: PUSH
6086: LD_VAR 0 2
6090: PPUSH
6091: CALL_OW 264
6095: ST_TO_ADDR
// fac := HexInfo ( 110 , 126 ) ;
6096: LD_ADDR_VAR 0 6
6100: PUSH
6101: LD_INT 110
6103: PPUSH
6104: LD_INT 126
6106: PPUSH
6107: CALL_OW 428
6111: ST_TO_ADDR
// if not driver or not fac then
6112: LD_VAR 0 1
6116: NOT
6117: PUSH
6118: LD_VAR 0 6
6122: NOT
6123: OR
6124: IFFALSE 6128
// exit ;
6126: GO 6222
// AddComMoveXY ( driver , 111 , 121 ) ;
6128: LD_VAR 0 1
6132: PPUSH
6133: LD_INT 111
6135: PPUSH
6136: LD_INT 121
6138: PPUSH
6139: CALL_OW 171
// AddComEnterUnit ( driver , fac ) ;
6143: LD_VAR 0 1
6147: PPUSH
6148: LD_VAR 0 6
6152: PPUSH
6153: CALL_OW 180
// repeat wait ( 0 0$1 ) ;
6157: LD_INT 35
6159: PPUSH
6160: CALL_OW 67
// until IsDead ( driver ) or IsInUnit ( driver ) ;
6164: LD_VAR 0 1
6168: PPUSH
6169: CALL_OW 301
6173: PUSH
6174: LD_VAR 0 1
6178: PPUSH
6179: CALL_OW 310
6183: OR
6184: IFFALSE 6157
// if IsDead ( driver ) then
6186: LD_VAR 0 1
6190: PPUSH
6191: CALL_OW 301
6195: IFFALSE 6199
// exit ;
6197: GO 6222
// AddComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_manual , weapon ) ;
6199: LD_VAR 0 6
6203: PPUSH
6204: LD_INT 21
6206: PPUSH
6207: LD_INT 1
6209: PPUSH
6210: LD_INT 1
6212: PPUSH
6213: LD_VAR 0 5
6217: PPUSH
6218: CALL_OW 185
// end ; end ;
6222: PPOPN 6
6224: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 3 then
6225: LD_VAR 0 2
6229: PPUSH
6230: CALL_OW 255
6234: PUSH
6235: LD_INT 3
6237: EQUAL
6238: IFFALSE 6284
// begin ruMobile := Replace ( ruMobile , ruMobile + 1 , veh ) ;
6240: LD_ADDR_EXP 35
6244: PUSH
6245: LD_EXP 35
6249: PPUSH
6250: LD_EXP 35
6254: PUSH
6255: LD_INT 1
6257: PLUS
6258: PPUSH
6259: LD_VAR 0 1
6263: PPUSH
6264: CALL_OW 1
6268: ST_TO_ADDR
// AddComMoveXY ( veh , 110 , 117 ) ;
6269: LD_VAR 0 1
6273: PPUSH
6274: LD_INT 110
6276: PPUSH
6277: LD_INT 117
6279: PPUSH
6280: CALL_OW 171
// end ; end ;
6284: PPOPN 2
6286: END
// on LeaveBuilding ( b , un ) do var barracks ;
6287: LD_INT 0
6289: PPUSH
// begin if b in [ HexInfo ( 130 , 17 ) , HexInfo ( 138 , 22 ) , HexInfo ( 123 , 17 ) ] then
6290: LD_VAR 0 1
6294: PUSH
6295: LD_INT 130
6297: PPUSH
6298: LD_INT 17
6300: PPUSH
6301: CALL_OW 428
6305: PUSH
6306: LD_INT 138
6308: PPUSH
6309: LD_INT 22
6311: PPUSH
6312: CALL_OW 428
6316: PUSH
6317: LD_INT 123
6319: PPUSH
6320: LD_INT 17
6322: PPUSH
6323: CALL_OW 428
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: LIST
6332: IN
6333: IFFALSE 6357
// begin AddComEnterUnit ( un , HexInfo ( 135 , 31 ) ) ;
6335: LD_VAR 0 2
6339: PPUSH
6340: LD_INT 135
6342: PPUSH
6343: LD_INT 31
6345: PPUSH
6346: CALL_OW 428
6350: PPUSH
6351: CALL_OW 180
// exit ;
6355: GO 6631
// end ; if b = HexInfo ( 135 , 31 ) then
6357: LD_VAR 0 1
6361: PUSH
6362: LD_INT 135
6364: PPUSH
6365: LD_INT 31
6367: PPUSH
6368: CALL_OW 428
6372: EQUAL
6373: IFFALSE 6445
// begin AddComEnterUnit ( un , HexInfo ( 106 , 51 ) ) ;
6375: LD_VAR 0 2
6379: PPUSH
6380: LD_INT 106
6382: PPUSH
6383: LD_INT 51
6385: PPUSH
6386: CALL_OW 428
6390: PPUSH
6391: CALL_OW 180
// if not explodeFirstDepot then
6395: LD_EXP 10
6399: NOT
6400: IFFALSE 6443
// begin explodeFirstDepot := true ;
6402: LD_ADDR_EXP 10
6406: PUSH
6407: LD_INT 1
6409: ST_TO_ADDR
// wait ( 0 0$15 ) ;
6410: LD_INT 525
6412: PPUSH
6413: CALL_OW 67
// MineExplosion ( 127 , 27 , 1 ) ;
6417: LD_INT 127
6419: PPUSH
6420: LD_INT 27
6422: PPUSH
6423: LD_INT 1
6425: PPUSH
6426: CALL_OW 453
// MineExplosion ( 125 , 29 , 1 ) ;
6430: LD_INT 125
6432: PPUSH
6433: LD_INT 29
6435: PPUSH
6436: LD_INT 1
6438: PPUSH
6439: CALL_OW 453
// end ; exit ;
6443: GO 6631
// end ; if b = HexInfo ( 106 , 51 ) then
6445: LD_VAR 0 1
6449: PUSH
6450: LD_INT 106
6452: PPUSH
6453: LD_INT 51
6455: PPUSH
6456: CALL_OW 428
6460: EQUAL
6461: IFFALSE 6561
// begin AddComMoveXY ( un , 106 , 93 ) ;
6463: LD_VAR 0 2
6467: PPUSH
6468: LD_INT 106
6470: PPUSH
6471: LD_INT 93
6473: PPUSH
6474: CALL_OW 171
// if not explodeSecondDepot then
6478: LD_EXP 11
6482: NOT
6483: IFFALSE 6559
// begin explodeSecondDepot := true ;
6485: LD_ADDR_EXP 11
6489: PUSH
6490: LD_INT 1
6492: ST_TO_ADDR
// wait ( 0 0$12 ) ;
6493: LD_INT 420
6495: PPUSH
6496: CALL_OW 67
// MineExplosion ( 111 , 75 , 1 ) ;
6500: LD_INT 111
6502: PPUSH
6503: LD_INT 75
6505: PPUSH
6506: LD_INT 1
6508: PPUSH
6509: CALL_OW 453
// MineExplosion ( 111 , 75 , 1 ) ;
6513: LD_INT 111
6515: PPUSH
6516: LD_INT 75
6518: PPUSH
6519: LD_INT 1
6521: PPUSH
6522: CALL_OW 453
// MineExplosion ( 108 , 69 , 1 ) ;
6526: LD_INT 108
6528: PPUSH
6529: LD_INT 69
6531: PPUSH
6532: LD_INT 1
6534: PPUSH
6535: CALL_OW 453
// wait ( 0 0$2 ) ;
6539: LD_INT 70
6541: PPUSH
6542: CALL_OW 67
// MineExplosion ( 94 , 65 , 1 ) ;
6546: LD_INT 94
6548: PPUSH
6549: LD_INT 65
6551: PPUSH
6552: LD_INT 1
6554: PPUSH
6555: CALL_OW 453
// end ; exit ;
6559: GO 6631
// end ; if GetBType ( b ) = b_bunker then
6561: LD_VAR 0 1
6565: PPUSH
6566: CALL_OW 266
6570: PUSH
6571: LD_INT 32
6573: EQUAL
6574: IFFALSE 6631
// begin barracks := NearestEmptyBuilding ( un , b_barracks ) ;
6576: LD_ADDR_VAR 0 3
6580: PUSH
6581: LD_VAR 0 2
6585: PPUSH
6586: LD_INT 5
6588: PPUSH
6589: CALL 2371 0 2
6593: ST_TO_ADDR
// if barracks then
6594: LD_VAR 0 3
6598: IFFALSE 6616
// AddComEnterUnit ( un , barracks ) else
6600: LD_VAR 0 2
6604: PPUSH
6605: LD_VAR 0 3
6609: PPUSH
6610: CALL_OW 180
6614: GO 6631
// AddComMoveXY ( un , 116 , 110 ) ;
6616: LD_VAR 0 2
6620: PPUSH
6621: LD_INT 116
6623: PPUSH
6624: LD_INT 110
6626: PPUSH
6627: CALL_OW 171
// end ; end ; end_of_file
6631: PPOPN 3
6633: END
// export function Action ; var i , un , veh , tmp , rutmp ; begin
6634: LD_INT 0
6636: PPUSH
6637: PPUSH
6638: PPUSH
6639: PPUSH
6640: PPUSH
6641: PPUSH
// InGameOn ;
6642: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6646: LD_INT 5
6648: PPUSH
6649: LD_INT 2
6651: PPUSH
6652: CALL_OW 343
// music_nat := 4 ;
6656: LD_ADDR_OWVAR 71
6660: PUSH
6661: LD_INT 4
6663: ST_TO_ADDR
// music_class := music_combat ;
6664: LD_ADDR_OWVAR 72
6668: PUSH
6669: LD_INT 1
6671: ST_TO_ADDR
// PlaceSeeing ( 133 , 2 , 2 , 10 ) ;
6672: LD_INT 133
6674: PPUSH
6675: LD_INT 2
6677: PPUSH
6678: LD_INT 2
6680: PPUSH
6681: LD_INT 10
6683: PPUSH
6684: CALL_OW 330
// CenterNowOnXY ( 133 , 2 ) ;
6688: LD_INT 133
6690: PPUSH
6691: LD_INT 2
6693: PPUSH
6694: CALL_OW 86
// wait ( 0 0$1 ) ;
6698: LD_INT 35
6700: PPUSH
6701: CALL_OW 67
// uc_side := 6 ;
6705: LD_ADDR_OWVAR 20
6709: PUSH
6710: LD_INT 6
6712: ST_TO_ADDR
// uc_nation := 3 ;
6713: LD_ADDR_OWVAR 21
6717: PUSH
6718: LD_INT 3
6720: ST_TO_ADDR
// rutmp := [ ] ;
6721: LD_ADDR_VAR 0 6
6725: PUSH
6726: EMPTY
6727: ST_TO_ADDR
// PrepareTank ( 6 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_gun , 66 ) ;
6728: LD_INT 6
6730: PPUSH
6731: LD_INT 3
6733: PPUSH
6734: LD_INT 21
6736: PPUSH
6737: LD_INT 1
6739: PPUSH
6740: LD_INT 1
6742: PPUSH
6743: LD_INT 44
6745: PPUSH
6746: LD_INT 66
6748: PPUSH
6749: CALL 367 0 7
// veh := CreateVehicle ;
6753: LD_ADDR_VAR 0 4
6757: PUSH
6758: CALL_OW 45
6762: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
6763: LD_VAR 0 4
6767: PPUSH
6768: LD_INT 3
6770: PPUSH
6771: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
6775: LD_VAR 0 4
6779: PPUSH
6780: LD_INT 8
6782: PPUSH
6783: LD_INT 0
6785: PPUSH
6786: CALL_OW 49
// SetLives ( veh , 500 ) ;
6790: LD_VAR 0 4
6794: PPUSH
6795: LD_INT 500
6797: PPUSH
6798: CALL_OW 234
// PrepareHuman ( false , 3 , 3 ) ;
6802: LD_INT 0
6804: PPUSH
6805: LD_INT 3
6807: PPUSH
6808: LD_INT 3
6810: PPUSH
6811: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6815: CALL_OW 44
6819: PPUSH
6820: LD_VAR 0 4
6824: PPUSH
6825: CALL_OW 52
// ComMoveXY ( veh , 133 , 11 ) ;
6829: LD_VAR 0 4
6833: PPUSH
6834: LD_INT 133
6836: PPUSH
6837: LD_INT 11
6839: PPUSH
6840: CALL_OW 111
// rutmp := [ veh ] ;
6844: LD_ADDR_VAR 0 6
6848: PUSH
6849: LD_VAR 0 4
6853: PUSH
6854: EMPTY
6855: LIST
6856: ST_TO_ADDR
// for i := 1 to 4 do
6857: LD_ADDR_VAR 0 2
6861: PUSH
6862: DOUBLE
6863: LD_INT 1
6865: DEC
6866: ST_TO_ADDR
6867: LD_INT 4
6869: PUSH
6870: FOR_TO
6871: IFFALSE 6978
// begin PrepareHuman ( false , i , 2 ) ;
6873: LD_INT 0
6875: PPUSH
6876: LD_VAR 0 2
6880: PPUSH
6881: LD_INT 2
6883: PPUSH
6884: CALL_OW 380
// un := CreateHuman ;
6888: LD_ADDR_VAR 0 3
6892: PUSH
6893: CALL_OW 44
6897: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6898: LD_VAR 0 3
6902: PPUSH
6903: LD_INT 3
6905: PPUSH
6906: CALL_OW 233
// PlaceUnitArea ( un , spawnArea , false ) ;
6910: LD_VAR 0 3
6914: PPUSH
6915: LD_INT 8
6917: PPUSH
6918: LD_INT 0
6920: PPUSH
6921: CALL_OW 49
// rutmp := Replace ( rutmp , rutmp + 1 , un ) ;
6925: LD_ADDR_VAR 0 6
6929: PUSH
6930: LD_VAR 0 6
6934: PPUSH
6935: LD_VAR 0 6
6939: PUSH
6940: LD_INT 1
6942: PLUS
6943: PPUSH
6944: LD_VAR 0 3
6948: PPUSH
6949: CALL_OW 1
6953: ST_TO_ADDR
// ComMoveXY ( un , 133 , 11 ) ;
6954: LD_VAR 0 3
6958: PPUSH
6959: LD_INT 133
6961: PPUSH
6962: LD_INT 11
6964: PPUSH
6965: CALL_OW 111
// wait ( 0 0$0.5 ) ;
6969: LD_INT 18
6971: PPUSH
6972: CALL_OW 67
// end ;
6976: GO 6870
6978: POP
6979: POP
// for i in rutmp do
6980: LD_ADDR_VAR 0 2
6984: PUSH
6985: LD_VAR 0 6
6989: PUSH
6990: FOR_IN
6991: IFFALSE 7040
// begin AddComMoveXY ( i , 99 , 65 ) ;
6993: LD_VAR 0 2
6997: PPUSH
6998: LD_INT 99
7000: PPUSH
7001: LD_INT 65
7003: PPUSH
7004: CALL_OW 171
// AddComMoveXY ( i , 76 , 108 ) ;
7008: LD_VAR 0 2
7012: PPUSH
7013: LD_INT 76
7015: PPUSH
7016: LD_INT 108
7018: PPUSH
7019: CALL_OW 171
// AddComMoveXY ( i , 92 , 176 ) ;
7023: LD_VAR 0 2
7027: PPUSH
7028: LD_INT 92
7030: PPUSH
7031: LD_INT 176
7033: PPUSH
7034: CALL_OW 171
// end ;
7038: GO 6990
7040: POP
7041: POP
// wait ( 0 0$10 ) ;
7042: LD_INT 350
7044: PPUSH
7045: CALL_OW 67
// tmp := [ Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Kurt , Aviradze ] union heikeSecondSquad ;
7049: LD_ADDR_VAR 0 5
7053: PUSH
7054: LD_EXP 14
7058: PUSH
7059: LD_EXP 15
7063: PUSH
7064: LD_EXP 16
7068: PUSH
7069: LD_EXP 17
7073: PUSH
7074: LD_EXP 18
7078: PUSH
7079: LD_EXP 19
7083: PUSH
7084: LD_EXP 20
7088: PUSH
7089: LD_EXP 21
7093: PUSH
7094: LD_EXP 23
7098: PUSH
7099: LD_EXP 24
7103: PUSH
7104: EMPTY
7105: LIST
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: LIST
7112: LIST
7113: LIST
7114: LIST
7115: PUSH
7116: LD_EXP 25
7120: UNION
7121: ST_TO_ADDR
// tmp := tmp diff 0 ;
7122: LD_ADDR_VAR 0 5
7126: PUSH
7127: LD_VAR 0 5
7131: PUSH
7132: LD_INT 0
7134: DIFF
7135: ST_TO_ADDR
// for i in heikeVehicles do
7136: LD_ADDR_VAR 0 2
7140: PUSH
7141: LD_EXP 26
7145: PUSH
7146: FOR_IN
7147: IFFALSE 7413
// begin if not tmp then
7149: LD_VAR 0 5
7153: NOT
7154: IFFALSE 7158
// continue ;
7156: GO 7146
// PrepareTank ( 2 , i [ 5 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] , 34 ) ;
7158: LD_INT 2
7160: PPUSH
7161: LD_VAR 0 2
7165: PUSH
7166: LD_INT 5
7168: ARRAY
7169: PPUSH
7170: LD_VAR 0 2
7174: PUSH
7175: LD_INT 1
7177: ARRAY
7178: PPUSH
7179: LD_VAR 0 2
7183: PUSH
7184: LD_INT 2
7186: ARRAY
7187: PPUSH
7188: LD_VAR 0 2
7192: PUSH
7193: LD_INT 3
7195: ARRAY
7196: PPUSH
7197: LD_VAR 0 2
7201: PUSH
7202: LD_INT 4
7204: ARRAY
7205: PPUSH
7206: LD_INT 34
7208: PPUSH
7209: CALL 367 0 7
// veh := CreateVehicle ;
7213: LD_ADDR_VAR 0 4
7217: PUSH
7218: CALL_OW 45
7222: ST_TO_ADDR
// if i [ 4 ] in [ ru_cargo_bay , ar_cargo_bay , us_cargo_bay ] then
7223: LD_VAR 0 2
7227: PUSH
7228: LD_INT 4
7230: ARRAY
7231: PUSH
7232: LD_INT 51
7234: PUSH
7235: LD_INT 32
7237: PUSH
7238: LD_INT 12
7240: PUSH
7241: EMPTY
7242: LIST
7243: LIST
7244: LIST
7245: IN
7246: IFFALSE 7326
// begin if i [ 7 ] [ 1 ] then
7248: LD_VAR 0 2
7252: PUSH
7253: LD_INT 7
7255: ARRAY
7256: PUSH
7257: LD_INT 1
7259: ARRAY
7260: IFFALSE 7287
// AddCargo ( veh , mat_cans , i [ 7 ] [ 1 ] ) ;
7262: LD_VAR 0 4
7266: PPUSH
7267: LD_INT 1
7269: PPUSH
7270: LD_VAR 0 2
7274: PUSH
7275: LD_INT 7
7277: ARRAY
7278: PUSH
7279: LD_INT 1
7281: ARRAY
7282: PPUSH
7283: CALL_OW 291
// if i [ 7 ] [ 2 ] then
7287: LD_VAR 0 2
7291: PUSH
7292: LD_INT 7
7294: ARRAY
7295: PUSH
7296: LD_INT 2
7298: ARRAY
7299: IFFALSE 7326
// AddCargo ( veh , mat_oil , i [ 7 ] [ 2 ] ) ;
7301: LD_VAR 0 4
7305: PPUSH
7306: LD_INT 2
7308: PPUSH
7309: LD_VAR 0 2
7313: PUSH
7314: LD_INT 7
7316: ARRAY
7317: PUSH
7318: LD_INT 2
7320: ARRAY
7321: PPUSH
7322: CALL_OW 291
// end ; SetDir ( veh , 3 ) ;
7326: LD_VAR 0 4
7330: PPUSH
7331: LD_INT 3
7333: PPUSH
7334: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7338: LD_VAR 0 4
7342: PPUSH
7343: LD_INT 8
7345: PPUSH
7346: LD_INT 0
7348: PPUSH
7349: CALL_OW 49
// PlaceHumanInUnit ( tmp [ 1 ] , veh ) ;
7353: LD_VAR 0 5
7357: PUSH
7358: LD_INT 1
7360: ARRAY
7361: PPUSH
7362: LD_VAR 0 4
7366: PPUSH
7367: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
7371: LD_ADDR_VAR 0 5
7375: PUSH
7376: LD_VAR 0 5
7380: PPUSH
7381: LD_INT 1
7383: PPUSH
7384: CALL_OW 3
7388: ST_TO_ADDR
// ComAgressiveMove ( veh , 133 , 7 ) ;
7389: LD_VAR 0 4
7393: PPUSH
7394: LD_INT 133
7396: PPUSH
7397: LD_INT 7
7399: PPUSH
7400: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7404: LD_INT 18
7406: PPUSH
7407: CALL_OW 67
// end ;
7411: GO 7146
7413: POP
7414: POP
// if tmp then
7415: LD_VAR 0 5
7419: IFFALSE 7475
// for i in tmp do
7421: LD_ADDR_VAR 0 2
7425: PUSH
7426: LD_VAR 0 5
7430: PUSH
7431: FOR_IN
7432: IFFALSE 7473
// begin PlaceUnitArea ( i , spawnArea , false ) ;
7434: LD_VAR 0 2
7438: PPUSH
7439: LD_INT 8
7441: PPUSH
7442: LD_INT 0
7444: PPUSH
7445: CALL_OW 49
// ComAgressiveMove ( i , 134 , 4 ) ;
7449: LD_VAR 0 2
7453: PPUSH
7454: LD_INT 134
7456: PPUSH
7457: LD_INT 4
7459: PPUSH
7460: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7464: LD_INT 18
7466: PPUSH
7467: CALL_OW 67
// end ;
7471: GO 7431
7473: POP
7474: POP
// if heikeApes then
7475: LD_EXP 27
7479: IFFALSE 7535
// for i in heikeApes do
7481: LD_ADDR_VAR 0 2
7485: PUSH
7486: LD_EXP 27
7490: PUSH
7491: FOR_IN
7492: IFFALSE 7533
// begin PlaceUnitArea ( i , spawnArea , false ) ;
7494: LD_VAR 0 2
7498: PPUSH
7499: LD_INT 8
7501: PPUSH
7502: LD_INT 0
7504: PPUSH
7505: CALL_OW 49
// ComAgressiveMove ( i , 134 , 4 ) ;
7509: LD_VAR 0 2
7513: PPUSH
7514: LD_INT 134
7516: PPUSH
7517: LD_INT 4
7519: PPUSH
7520: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7524: LD_INT 18
7526: PPUSH
7527: CALL_OW 67
// end ;
7531: GO 7491
7533: POP
7534: POP
// DialogueOn ;
7535: CALL_OW 6
// Say ( Heike , DH-outpost-a-1 ) ;
7539: LD_EXP 14
7543: PPUSH
7544: LD_STRING DH-outpost-a-1
7546: PPUSH
7547: CALL_OW 88
// DialogueOff ;
7551: CALL_OW 7
// RemoveSeeing ( 133 , 2 , 2 ) ;
7555: LD_INT 133
7557: PPUSH
7558: LD_INT 2
7560: PPUSH
7561: LD_INT 2
7563: PPUSH
7564: CALL_OW 331
// InGameOff ;
7568: CALL_OW 9
// music_nat := 0 ;
7572: LD_ADDR_OWVAR 71
7576: PUSH
7577: LD_INT 0
7579: ST_TO_ADDR
// music_class := 0 ;
7580: LD_ADDR_OWVAR 72
7584: PUSH
7585: LD_INT 0
7587: ST_TO_ADDR
// ChangeMissionObjectives ( Outposts ) ;
7588: LD_STRING Outposts
7590: PPUSH
7591: CALL_OW 337
// SaveForQuickRestart ;
7595: CALL_OW 22
// end ;
7599: LD_VAR 0 1
7603: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 20 ] ] ) and ibrahimOnRuSide and IsOk ( Ibrahim ) do
7604: LD_INT 22
7606: PUSH
7607: LD_INT 2
7609: PUSH
7610: EMPTY
7611: LIST
7612: LIST
7613: PUSH
7614: LD_INT 91
7616: PUSH
7617: LD_EXP 17
7621: PUSH
7622: LD_INT 20
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: LIST
7629: PUSH
7630: EMPTY
7631: LIST
7632: LIST
7633: PPUSH
7634: CALL_OW 69
7638: PUSH
7639: LD_EXP 3
7643: AND
7644: PUSH
7645: LD_EXP 17
7649: PPUSH
7650: CALL_OW 302
7654: AND
7655: IFFALSE 7743
7657: GO 7659
7659: DISABLE
// begin IbrahimBetrayal ;
7660: CALL 7744 0 0
// repeat wait ( 0 0$1 ) ;
7664: LD_INT 35
7666: PPUSH
7667: CALL_OW 67
// until IsDead ( Ibrahim ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 6 ] ] ) ;
7671: LD_EXP 17
7675: PPUSH
7676: CALL_OW 301
7680: PUSH
7681: LD_INT 22
7683: PUSH
7684: LD_INT 2
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PUSH
7691: LD_INT 91
7693: PUSH
7694: LD_EXP 17
7698: PUSH
7699: LD_INT 6
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PPUSH
7711: CALL_OW 69
7715: OR
7716: IFFALSE 7664
// if IsDead ( Ibrahim ) then
7718: LD_EXP 17
7722: PPUSH
7723: CALL_OW 301
7727: IFFALSE 7731
// exit ;
7729: GO 7743
// SetSide ( Ibrahim , 2 ) ;
7731: LD_EXP 17
7735: PPUSH
7736: LD_INT 2
7738: PPUSH
7739: CALL_OW 235
// end ;
7743: END
// export function IbrahimBetrayal ; var i , tmp ; begin
7744: LD_INT 0
7746: PPUSH
7747: PPUSH
7748: PPUSH
// PlaceSeeing ( 122 , 77 , 2 , - 6 ) ;
7749: LD_INT 122
7751: PPUSH
7752: LD_INT 77
7754: PPUSH
7755: LD_INT 2
7757: PPUSH
7758: LD_INT 6
7760: NEG
7761: PPUSH
7762: CALL_OW 330
// ComMoveXY ( Ibrahim , 123 , 79 ) ;
7766: LD_EXP 17
7770: PPUSH
7771: LD_INT 123
7773: PPUSH
7774: LD_INT 79
7776: PPUSH
7777: CALL_OW 111
// AddComTurnXY ( Ibrahim , 125 , 82 ) ;
7781: LD_EXP 17
7785: PPUSH
7786: LD_INT 125
7788: PPUSH
7789: LD_INT 82
7791: PPUSH
7792: CALL_OW 178
// wait ( 0 0$2 ) ;
7796: LD_INT 70
7798: PPUSH
7799: CALL_OW 67
// ComTurnUnit ( ruSol , Ibrahim ) ;
7803: LD_EXP 36
7807: PPUSH
7808: LD_EXP 17
7812: PPUSH
7813: CALL_OW 119
// Say ( ruSol , DRum-outpost-b-3 ) ;
7817: LD_EXP 36
7821: PPUSH
7822: LD_STRING DRum-outpost-b-3
7824: PPUSH
7825: CALL_OW 88
// tmp := [ HexInfo ( 125 , 76 ) , HexInfo ( 125 , 79 ) , HexInfo ( 125 , 82 ) ] ;
7829: LD_ADDR_VAR 0 3
7833: PUSH
7834: LD_INT 125
7836: PPUSH
7837: LD_INT 76
7839: PPUSH
7840: CALL_OW 428
7844: PUSH
7845: LD_INT 125
7847: PPUSH
7848: LD_INT 79
7850: PPUSH
7851: CALL_OW 428
7855: PUSH
7856: LD_INT 125
7858: PPUSH
7859: LD_INT 82
7861: PPUSH
7862: CALL_OW 428
7866: PUSH
7867: EMPTY
7868: LIST
7869: LIST
7870: LIST
7871: ST_TO_ADDR
// for i in tmp do
7872: LD_ADDR_VAR 0 2
7876: PUSH
7877: LD_VAR 0 3
7881: PUSH
7882: FOR_IN
7883: IFFALSE 7899
// SetLives ( i , 200 ) ;
7885: LD_VAR 0 2
7889: PPUSH
7890: LD_INT 200
7892: PPUSH
7893: CALL_OW 234
7897: GO 7882
7899: POP
7900: POP
// Say ( Ibrahim , DI-outpost-b-4 ) ;
7901: LD_EXP 17
7905: PPUSH
7906: LD_STRING DI-outpost-b-4
7908: PPUSH
7909: CALL_OW 88
// SetSide ( Ibrahim , 5 ) ;
7913: LD_EXP 17
7917: PPUSH
7918: LD_INT 5
7920: PPUSH
7921: CALL_OW 235
// ComFree ( [ Ibrahim , ruSol ] ) ;
7925: LD_EXP 17
7929: PUSH
7930: LD_EXP 36
7934: PUSH
7935: EMPTY
7936: LIST
7937: LIST
7938: PPUSH
7939: CALL_OW 139
// RemoveSeeing ( 122 , 77 , 2 ) ;
7943: LD_INT 122
7945: PPUSH
7946: LD_INT 77
7948: PPUSH
7949: LD_INT 2
7951: PPUSH
7952: CALL_OW 331
// if Givi then
7956: LD_EXP 15
7960: IFFALSE 7976
// Say ( Givi , DG-1-outpost-b-5 ) else
7962: LD_EXP 15
7966: PPUSH
7967: LD_STRING DG-1-outpost-b-5
7969: PPUSH
7970: CALL_OW 88
7974: GO 8041
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-outpost-b-a-5 ) then
7976: LD_EXP 25
7980: PPUSH
7981: LD_INT 26
7983: PUSH
7984: LD_INT 2
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: PPUSH
7991: CALL_OW 72
7995: PUSH
7996: LD_INT 1
7998: ARRAY
7999: PPUSH
8000: LD_STRING DArf-outpost-b-a-5
8002: PPUSH
8003: CALL_OW 88
8007: NOT
8008: IFFALSE 8041
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-outpost-b-a-5 ) ;
8010: LD_EXP 25
8014: PPUSH
8015: LD_INT 26
8017: PUSH
8018: LD_INT 1
8020: PUSH
8021: EMPTY
8022: LIST
8023: LIST
8024: PPUSH
8025: CALL_OW 72
8029: PUSH
8030: LD_INT 1
8032: ARRAY
8033: PPUSH
8034: LD_STRING DArm-outpost-b-a-5
8036: PPUSH
8037: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
8041: LD_INT 35
8043: PPUSH
8044: CALL_OW 67
// until IsDead ( Ibrahim ) or ( GetDistUnits ( Heike , Ibrahim ) < 6 and IsOk ( Ibrahim ) ) ;
8048: LD_EXP 17
8052: PPUSH
8053: CALL_OW 301
8057: PUSH
8058: LD_EXP 14
8062: PPUSH
8063: LD_EXP 17
8067: PPUSH
8068: CALL_OW 296
8072: PUSH
8073: LD_INT 6
8075: LESS
8076: PUSH
8077: LD_EXP 17
8081: PPUSH
8082: CALL_OW 302
8086: AND
8087: OR
8088: IFFALSE 8041
// if IsDead ( Ibrahim ) then
8090: LD_EXP 17
8094: PPUSH
8095: CALL_OW 301
8099: IFFALSE 8115
// begin Say ( Heike , DH-ibrahimdead-1 ) ;
8101: LD_EXP 14
8105: PPUSH
8106: LD_STRING DH-ibrahimdead-1
8108: PPUSH
8109: CALL_OW 88
// exit ;
8113: GO 8160
// end ; CenterNowOnUnits ( Ibrahim ) ;
8115: LD_EXP 17
8119: PPUSH
8120: CALL_OW 87
// Say ( Ibrahim , DI-ibrahimlives-1 ) ;
8124: LD_EXP 17
8128: PPUSH
8129: LD_STRING DI-ibrahimlives-1
8131: PPUSH
8132: CALL_OW 88
// Say ( Heike , DH-Ibrahimlives-2 ) ;
8136: LD_EXP 14
8140: PPUSH
8141: LD_STRING DH-Ibrahimlives-2
8143: PPUSH
8144: CALL_OW 88
// SetSide ( Ibrahim , 2 ) ;
8148: LD_EXP 17
8152: PPUSH
8153: LD_INT 2
8155: PPUSH
8156: CALL_OW 235
// end ;
8160: LD_VAR 0 1
8164: RET
// every 0 0$2 trigger IsDead ( ruSecBase ) or GetSide ( ruSecBase ) = 2 do
8165: LD_INT 225
8167: PPUSH
8168: CALL_OW 301
8172: PUSH
8173: LD_INT 225
8175: PPUSH
8176: CALL_OW 255
8180: PUSH
8181: LD_INT 2
8183: EQUAL
8184: OR
8185: IFFALSE 8510
8187: GO 8189
8189: DISABLE
// begin wait ( 0 0$20 ) ;
8190: LD_INT 700
8192: PPUSH
8193: CALL_OW 67
// DialogueOn ;
8197: CALL_OW 6
// SayRadio ( Shariff , DShar-radio-1 ) ;
8201: LD_EXP 22
8205: PPUSH
8206: LD_STRING DShar-radio-1
8208: PPUSH
8209: CALL_OW 94
// SayRadio ( Shariff , DShar-radio-2 ) ;
8213: LD_EXP 22
8217: PPUSH
8218: LD_STRING DShar-radio-2
8220: PPUSH
8221: CALL_OW 94
// Say ( Heike , DH-radio-2 ) ;
8225: LD_EXP 14
8229: PPUSH
8230: LD_STRING DH-radio-2
8232: PPUSH
8233: CALL_OW 88
// DialogueOff ;
8237: CALL_OW 7
// ChangeMissionObjectives ( Gaidar ) ;
8241: LD_STRING Gaidar
8243: PPUSH
8244: CALL_OW 337
// wait ( 0 0$30 + rand ( 0 0$10 , 0 0$20 ) * Difficulty ) ;
8248: LD_INT 1050
8250: PUSH
8251: LD_INT 350
8253: PPUSH
8254: LD_INT 700
8256: PPUSH
8257: CALL_OW 12
8261: PUSH
8262: LD_OWVAR 67
8266: MUL
8267: PLUS
8268: PPUSH
8269: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8273: LD_INT 35
8275: PPUSH
8276: CALL_OW 67
// until HexInfo ( 2 , 1 ) = 0 ;
8280: LD_INT 2
8282: PPUSH
8283: LD_INT 1
8285: PPUSH
8286: CALL_OW 428
8290: PUSH
8291: LD_INT 0
8293: EQUAL
8294: IFFALSE 8273
// SetDir ( Gaidar , 2 ) ;
8296: LD_EXP 29
8300: PPUSH
8301: LD_INT 2
8303: PPUSH
8304: CALL_OW 233
// PlaceUnitXY ( Gaidar , 2 , 1 , false ) ;
8308: LD_EXP 29
8312: PPUSH
8313: LD_INT 2
8315: PPUSH
8316: LD_INT 1
8318: PPUSH
8319: LD_INT 0
8321: PPUSH
8322: CALL_OW 48
// ComMoveXY ( Gaidar , 19 , 24 ) ;
8326: LD_EXP 29
8330: PPUSH
8331: LD_INT 19
8333: PPUSH
8334: LD_INT 24
8336: PPUSH
8337: CALL_OW 111
// AddComWait ( Gaidar , 0 0$6 ) ;
8341: LD_EXP 29
8345: PPUSH
8346: LD_INT 210
8348: PPUSH
8349: CALL_OW 202
// AddComMoveXY ( Gaidar , 38 , 47 ) ;
8353: LD_EXP 29
8357: PPUSH
8358: LD_INT 38
8360: PPUSH
8361: LD_INT 47
8363: PPUSH
8364: CALL_OW 171
// AddComMoveXY ( Gaidar , 32 , 59 ) ;
8368: LD_EXP 29
8372: PPUSH
8373: LD_INT 32
8375: PPUSH
8376: LD_INT 59
8378: PPUSH
8379: CALL_OW 171
// AddComWait ( Gaidar , 0 0$10 ) ;
8383: LD_EXP 29
8387: PPUSH
8388: LD_INT 350
8390: PPUSH
8391: CALL_OW 202
// AddComMoveXY ( Gaidar , 62 , 116 ) ;
8395: LD_EXP 29
8399: PPUSH
8400: LD_INT 62
8402: PPUSH
8403: LD_INT 116
8405: PPUSH
8406: CALL_OW 171
// AddComMoveXY ( Gaidar , 92 , 177 ) ;
8410: LD_EXP 29
8414: PPUSH
8415: LD_INT 92
8417: PPUSH
8418: LD_INT 177
8420: PPUSH
8421: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8425: LD_INT 35
8427: PPUSH
8428: CALL_OW 67
// until IsDead ( Gaidar ) or IsAt ( Gaidar , 92 , 177 ) ;
8432: LD_EXP 29
8436: PPUSH
8437: CALL_OW 301
8441: PUSH
8442: LD_EXP 29
8446: PPUSH
8447: LD_INT 92
8449: PPUSH
8450: LD_INT 177
8452: PPUSH
8453: CALL_OW 307
8457: OR
8458: IFFALSE 8425
// if IsAt ( Gaidar , 92 , 177 ) then
8460: LD_EXP 29
8464: PPUSH
8465: LD_INT 92
8467: PPUSH
8468: LD_INT 177
8470: PPUSH
8471: CALL_OW 307
8475: IFFALSE 8488
// begin RemoveUnit ( Gaidar ) ;
8477: LD_EXP 29
8481: PPUSH
8482: CALL_OW 64
// exit ;
8486: GO 8510
// end ; gaidarKilled := true ;
8488: LD_ADDR_EXP 12
8492: PUSH
8493: LD_INT 1
8495: ST_TO_ADDR
// ChangeMissionObjectives ( GaidarKilled ) ;
8496: LD_STRING GaidarKilled
8498: PPUSH
8499: CALL_OW 337
// SetAchievement ( ACH_COMMISAR ) ;
8503: LD_STRING ACH_COMMISAR
8505: PPUSH
8506: CALL_OW 543
// end ;
8510: END
// every 0 0$1 trigger See ( 2 , Gaidar ) do
8511: LD_INT 2
8513: PPUSH
8514: LD_EXP 29
8518: PPUSH
8519: CALL_OW 292
8523: IFFALSE 8540
8525: GO 8527
8527: DISABLE
// Say ( Gaidar , DT-objective-1 ) ;
8528: LD_EXP 29
8532: PPUSH
8533: LD_STRING DT-objective-1
8535: PPUSH
8536: CALL_OW 88
8540: END
// every 0 0$5 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) do
8541: LD_INT 22
8543: PUSH
8544: LD_INT 2
8546: PUSH
8547: EMPTY
8548: LIST
8549: LIST
8550: PUSH
8551: LD_INT 2
8553: PUSH
8554: LD_INT 95
8556: PUSH
8557: LD_INT 5
8559: PUSH
8560: EMPTY
8561: LIST
8562: LIST
8563: PUSH
8564: LD_INT 95
8566: PUSH
8567: LD_INT 6
8569: PUSH
8570: EMPTY
8571: LIST
8572: LIST
8573: PUSH
8574: LD_INT 95
8576: PUSH
8577: LD_INT 7
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PUSH
8584: EMPTY
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: PPUSH
8594: CALL_OW 69
8598: IFFALSE 8627
8600: GO 8602
8602: DISABLE
// begin Say ( Heike , DH-outpost-last-1 ) ;
8603: LD_EXP 14
8607: PPUSH
8608: LD_STRING DH-outpost-last-1
8610: PPUSH
8611: CALL_OW 88
// SayRadio ( Burlak , DB-outpost-last-2 ) ;
8615: LD_EXP 28
8619: PPUSH
8620: LD_STRING DB-outpost-last-2
8622: PPUSH
8623: CALL_OW 94
// end ;
8627: END
// every 0 0$1 trigger GetLives ( ruMainBase ) < 999 or GetSide ( ruMainBase ) = 2 do var i , tmp ;
8628: LD_INT 200
8630: PPUSH
8631: CALL_OW 256
8635: PUSH
8636: LD_INT 999
8638: LESS
8639: PUSH
8640: LD_INT 200
8642: PPUSH
8643: CALL_OW 255
8647: PUSH
8648: LD_INT 2
8650: EQUAL
8651: OR
8652: IFFALSE 8818
8654: GO 8656
8656: DISABLE
8657: LD_INT 0
8659: PPUSH
8660: PPUSH
// begin SayRadio ( Burlak , DB-end-1 ) ;
8661: LD_EXP 28
8665: PPUSH
8666: LD_STRING DB-end-1
8668: PPUSH
8669: CALL_OW 94
// Say ( Heike , DH-end-2 ) ;
8673: LD_EXP 14
8677: PPUSH
8678: LD_STRING DH-end-2
8680: PPUSH
8681: CALL_OW 88
// if tick <= 15 15$00 then
8685: LD_OWVAR 1
8689: PUSH
8690: LD_INT 31500
8692: LESSEQUAL
8693: IFFALSE 8702
// SetAchievement ( ACH_FIST ) ;
8695: LD_STRING ACH_FIST
8697: PPUSH
8698: CALL_OW 543
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
8702: LD_ADDR_VAR 0 2
8706: PUSH
8707: LD_INT 22
8709: PUSH
8710: LD_INT 3
8712: PUSH
8713: EMPTY
8714: LIST
8715: LIST
8716: PUSH
8717: LD_INT 3
8719: PUSH
8720: LD_INT 21
8722: PUSH
8723: LD_INT 3
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PPUSH
8738: CALL_OW 69
8742: ST_TO_ADDR
// if not tmp then
8743: LD_VAR 0 2
8747: NOT
8748: IFFALSE 8752
// exit ;
8750: GO 8818
// for i in tmp do
8752: LD_ADDR_VAR 0 1
8756: PUSH
8757: LD_VAR 0 2
8761: PUSH
8762: FOR_IN
8763: IFFALSE 8816
// begin SetTag ( i , tEscape ) ;
8765: LD_VAR 0 1
8769: PPUSH
8770: LD_EXP 13
8774: PPUSH
8775: CALL_OW 109
// if IsInUnit ( i ) then
8779: LD_VAR 0 1
8783: PPUSH
8784: CALL_OW 310
8788: IFFALSE 8799
// ComExitBuilding ( i ) ;
8790: LD_VAR 0 1
8794: PPUSH
8795: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
8799: LD_VAR 0 1
8803: PPUSH
8804: LD_INT 92
8806: PPUSH
8807: LD_INT 177
8809: PPUSH
8810: CALL_OW 171
// end ;
8814: GO 8762
8816: POP
8817: POP
// end ;
8818: PPOPN 2
8820: END
// every 0 0$1 trigger FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do var i ;
8821: LD_INT 9
8823: PPUSH
8824: LD_INT 2
8826: PUSH
8827: LD_INT 22
8829: PUSH
8830: LD_INT 3
8832: PUSH
8833: EMPTY
8834: LIST
8835: LIST
8836: PUSH
8837: LD_INT 22
8839: PUSH
8840: LD_INT 6
8842: PUSH
8843: EMPTY
8844: LIST
8845: LIST
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: LIST
8851: PPUSH
8852: CALL_OW 70
8856: IFFALSE 8954
8858: GO 8860
8860: DISABLE
8861: LD_INT 0
8863: PPUSH
// begin enable ;
8864: ENABLE
// for i in FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do
8865: LD_ADDR_VAR 0 1
8869: PUSH
8870: LD_INT 9
8872: PPUSH
8873: LD_INT 2
8875: PUSH
8876: LD_INT 22
8878: PUSH
8879: LD_INT 3
8881: PUSH
8882: EMPTY
8883: LIST
8884: LIST
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_INT 6
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: LIST
8900: PPUSH
8901: CALL_OW 70
8905: PUSH
8906: FOR_IN
8907: IFFALSE 8952
// if GetTag ( i ) = tEscape or GetSide ( i ) = 6 then
8909: LD_VAR 0 1
8913: PPUSH
8914: CALL_OW 110
8918: PUSH
8919: LD_EXP 13
8923: EQUAL
8924: PUSH
8925: LD_VAR 0 1
8929: PPUSH
8930: CALL_OW 255
8934: PUSH
8935: LD_INT 6
8937: EQUAL
8938: OR
8939: IFFALSE 8950
// RemoveUnit ( i ) ;
8941: LD_VAR 0 1
8945: PPUSH
8946: CALL_OW 64
8950: GO 8906
8952: POP
8953: POP
// end ;
8954: PPOPN 1
8956: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) = 0 do var tmp ;
8957: LD_INT 22
8959: PUSH
8960: LD_INT 3
8962: PUSH
8963: EMPTY
8964: LIST
8965: LIST
8966: PUSH
8967: LD_INT 2
8969: PUSH
8970: LD_INT 30
8972: PUSH
8973: LD_INT 1
8975: PUSH
8976: EMPTY
8977: LIST
8978: LIST
8979: PUSH
8980: LD_INT 30
8982: PUSH
8983: LD_INT 0
8985: PUSH
8986: EMPTY
8987: LIST
8988: LIST
8989: PUSH
8990: EMPTY
8991: LIST
8992: LIST
8993: LIST
8994: PUSH
8995: EMPTY
8996: LIST
8997: LIST
8998: PPUSH
8999: CALL_OW 69
9003: PUSH
9004: LD_INT 0
9006: EQUAL
9007: IFFALSE 9461
9009: GO 9011
9011: DISABLE
9012: LD_INT 0
9014: PPUSH
// begin if tick + gameTime <= [ 70 70$00 , 65 65$00 , 60 60$00 ] [ Difficulty ] then
9015: LD_OWVAR 1
9019: PUSH
9020: LD_EXP 5
9024: PLUS
9025: PUSH
9026: LD_INT 147000
9028: PUSH
9029: LD_INT 136500
9031: PUSH
9032: LD_INT 126000
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: LIST
9039: PUSH
9040: LD_OWVAR 67
9044: ARRAY
9045: LESSEQUAL
9046: IFFALSE 9060
// AddMedal ( med1 , 1 ) else
9048: LD_STRING med1
9050: PPUSH
9051: LD_INT 1
9053: PPUSH
9054: CALL_OW 101
9058: GO 9071
// AddMedal ( med1 , - 1 ) ;
9060: LD_STRING med1
9062: PPUSH
9063: LD_INT 1
9065: NEG
9066: PPUSH
9067: CALL_OW 101
// if ( flamethrowers >= 3 ) * baseHill * ( loseCounter < [ 6 , 5 , 4 ] [ Difficulty ] ) then
9071: LD_EXP 7
9075: PUSH
9076: LD_INT 3
9078: GREATEREQUAL
9079: PUSH
9080: LD_EXP 9
9084: MUL
9085: PUSH
9086: LD_EXP 6
9090: PUSH
9091: LD_INT 6
9093: PUSH
9094: LD_INT 5
9096: PUSH
9097: LD_INT 4
9099: PUSH
9100: EMPTY
9101: LIST
9102: LIST
9103: LIST
9104: PUSH
9105: LD_OWVAR 67
9109: ARRAY
9110: LESS
9111: MUL
9112: IFFALSE 9126
// AddMedal ( med2 , 1 ) else
9114: LD_STRING med2
9116: PPUSH
9117: LD_INT 1
9119: PPUSH
9120: CALL_OW 101
9124: GO 9137
// AddMedal ( med2 , - 1 ) ;
9126: LD_STRING med2
9128: PPUSH
9129: LD_INT 1
9131: NEG
9132: PPUSH
9133: CALL_OW 101
// if gaidarKilled then
9137: LD_EXP 12
9141: IFFALSE 9155
// AddMedal ( med3 , 1 ) else
9143: LD_STRING med3
9145: PPUSH
9146: LD_INT 1
9148: PPUSH
9149: CALL_OW 101
9153: GO 9166
// AddMedal ( med3 , - 1 ) ;
9155: LD_STRING med3
9157: PPUSH
9158: LD_INT 1
9160: NEG
9161: PPUSH
9162: CALL_OW 101
// GiveMedals ( MAIN ) ;
9166: LD_STRING MAIN
9168: PPUSH
9169: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_nation , 0 ] ] ] ) ) ;
9173: LD_INT 22
9175: PUSH
9176: LD_INT 2
9178: PUSH
9179: EMPTY
9180: LIST
9181: LIST
9182: PUSH
9183: LD_INT 3
9185: PUSH
9186: LD_INT 23
9188: PUSH
9189: LD_INT 0
9191: PUSH
9192: EMPTY
9193: LIST
9194: LIST
9195: PUSH
9196: EMPTY
9197: LIST
9198: LIST
9199: PUSH
9200: EMPTY
9201: LIST
9202: LIST
9203: PPUSH
9204: CALL_OW 69
9208: PPUSH
9209: CALL_OW 43
// SaveCharacters ( Heike , 04_2_Heike ) ;
9213: LD_EXP 14
9217: PPUSH
9218: LD_STRING 04_2_Heike
9220: PPUSH
9221: CALL_OW 38
// if Aviradze then
9225: LD_EXP 24
9229: IFFALSE 9243
// SaveCharacters ( Aviradze , 04_2_Aviradze ) ;
9231: LD_EXP 24
9235: PPUSH
9236: LD_STRING 04_2_Aviradze
9238: PPUSH
9239: CALL_OW 38
// if Ibrahim then
9243: LD_EXP 17
9247: IFFALSE 9261
// SaveCharacters ( Ibrahim , 04_2_Ibrahim ) ;
9249: LD_EXP 17
9253: PPUSH
9254: LD_STRING 04_2_Ibrahim
9256: PPUSH
9257: CALL_OW 38
// if Kamil then
9261: LD_EXP 18
9265: IFFALSE 9279
// SaveCharacters ( Kamil , 04_2_Kamil ) ;
9267: LD_EXP 18
9271: PPUSH
9272: LD_STRING 04_2_Kamil
9274: PPUSH
9275: CALL_OW 38
// if Sophia then
9279: LD_EXP 20
9283: IFFALSE 9297
// SaveCharacters ( Sophia , 04_2_Sophia ) ;
9285: LD_EXP 20
9289: PPUSH
9290: LD_STRING 04_2_Sophia
9292: PPUSH
9293: CALL_OW 38
// if Kaia then
9297: LD_EXP 19
9301: IFFALSE 9315
// SaveCharacters ( Kaia , 04_2_Kaia ) ;
9303: LD_EXP 19
9307: PPUSH
9308: LD_STRING 04_2_Kaia
9310: PPUSH
9311: CALL_OW 38
// if Givi then
9315: LD_EXP 15
9319: IFFALSE 9333
// SaveCharacters ( Givi , 04_2_Givi ) ;
9321: LD_EXP 15
9325: PPUSH
9326: LD_STRING 04_2_Givi
9328: PPUSH
9329: CALL_OW 38
// if Mike then
9333: LD_EXP 16
9337: IFFALSE 9351
// SaveCharacters ( Mike , 04_2_Mike ) ;
9339: LD_EXP 16
9343: PPUSH
9344: LD_STRING 04_2_Mike
9346: PPUSH
9347: CALL_OW 38
// if Markov then
9351: LD_EXP 21
9355: IFFALSE 9369
// SaveCharacters ( Markov , 04_2_Markov ) ;
9357: LD_EXP 21
9361: PPUSH
9362: LD_STRING 04_2_Markov
9364: PPUSH
9365: CALL_OW 38
// if Kurt then
9369: LD_EXP 23
9373: IFFALSE 9387
// SaveCharacters ( Kurt , 04_2_Kurt ) ;
9375: LD_EXP 23
9379: PPUSH
9380: LD_STRING 04_2_Kurt
9382: PPUSH
9383: CALL_OW 38
// if heikeSecondSquad then
9387: LD_EXP 25
9391: IFFALSE 9405
// SaveCharacters ( heikeSecondSquad , 04_2_others ) ;
9393: LD_EXP 25
9397: PPUSH
9398: LD_STRING 04_2_others
9400: PPUSH
9401: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
9405: LD_ADDR_VAR 0 1
9409: PUSH
9410: LD_INT 22
9412: PUSH
9413: LD_INT 2
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: PUSH
9420: LD_INT 23
9422: PUSH
9423: LD_INT 0
9425: PUSH
9426: EMPTY
9427: LIST
9428: LIST
9429: PUSH
9430: EMPTY
9431: LIST
9432: LIST
9433: PPUSH
9434: CALL_OW 69
9438: ST_TO_ADDR
// if tmp then
9439: LD_VAR 0 1
9443: IFFALSE 9457
// SaveCharacters ( tmp , 04_2_apes ) ;
9445: LD_VAR 0 1
9449: PPUSH
9450: LD_STRING 04_2_apes
9452: PPUSH
9453: CALL_OW 38
// YouWin ;
9457: CALL_OW 103
// end ;
9461: PPOPN 1
9463: END
