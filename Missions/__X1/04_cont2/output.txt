// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 45 0 0
// InitTag ;
   8: CALL 229 0 0
// PrepareNature ( natureArea ) ;
  12: LD_INT 2
  14: PPUSH
  15: CALL 704 0 1
// PrepareRussian ;
  19: CALL 3285 0 0
// PrepareArabian ;
  23: CALL 2626 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 2 ) ;
  33: LD_INT 2
  35: PPUSH
  36: CALL_OW 344
// Action ;
  40: CALL 6877 0 0
// end ;
  44: END
// export debug , prefix ; export ibrahimOnRuSide , ruEscapeAllowed , gameTime , loseCounter , flamethrowers , kaiaKilledByRussian , hannibalPath , ruEscapeCounter , baseHill , explodeFirstDepot , explodeSecondDepot , gaidarKilled , outerAreaAchived , earlyEscape ; function Init ; begin
  45: LD_INT 0
  47: PPUSH
// debug := false ;
  48: LD_ADDR_EXP 1
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// prefix := 04_1_ ;
  56: LD_ADDR_EXP 2
  60: PUSH
  61: LD_STRING 04_1_
  63: ST_TO_ADDR
// ibrahimOnRuSide := LoadVariable ( 03_IbrahimHasEscaped , false ) ;
  64: LD_ADDR_EXP 3
  68: PUSH
  69: LD_STRING 03_IbrahimHasEscaped
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: CALL_OW 30
  79: ST_TO_ADDR
// ruEscapeCounter := LoadVariable ( 04_1_EscapeCounter , 0 ) ;
  80: LD_ADDR_EXP 10
  84: PUSH
  85: LD_STRING 04_1_EscapeCounter
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// loseCounter := LoadVariable ( 04_1_DeadCounter , 0 ) ;
  96: LD_ADDR_EXP 6
 100: PUSH
 101: LD_STRING 04_1_DeadCounter
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// baseHill := LoadVariable ( 04_1_BaseHill , false ) ;
 112: LD_ADDR_EXP 11
 116: PUSH
 117: LD_STRING 04_1_BaseHill
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL_OW 30
 127: ST_TO_ADDR
// gameTime := LoadVariable ( 04_1_Time , 40 40$00 ) ;
 128: LD_ADDR_EXP 5
 132: PUSH
 133: LD_STRING 04_1_Time
 135: PPUSH
 136: LD_INT 84000
 138: PPUSH
 139: CALL_OW 30
 143: ST_TO_ADDR
// flamethrowers := LoadVariable ( 04_1_Flamethrower , 0 ) ;
 144: LD_ADDR_EXP 7
 148: PUSH
 149: LD_STRING 04_1_Flamethrower
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: CALL_OW 30
 159: ST_TO_ADDR
// ruEscapeAllowed := false ;
 160: LD_ADDR_EXP 4
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// explodeFirstDepot := false ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// explodeSecondDepot := false ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// gaidarKilled := false ;
 184: LD_ADDR_EXP 14
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// kaiaKilledByRussian := false ;
 192: LD_ADDR_EXP 8
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// outerAreaAchived := false ;
 200: LD_ADDR_EXP 15
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// hannibalPath := false ;
 208: LD_ADDR_EXP 9
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// earlyEscape := false ;
 216: LD_ADDR_EXP 16
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// export tEscape ; function InitTag ; begin
 229: LD_INT 0
 231: PPUSH
// tEscape := 10 ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: LD_INT 10
 239: ST_TO_ADDR
// end ;
 240: LD_VAR 0 1
 244: RET
// every 0 0$1 trigger debug do var i ;
 245: LD_EXP 1
 249: IFFALSE 333
 251: GO 253
 253: DISABLE
 254: LD_INT 0
 256: PPUSH
// begin enable ;
 257: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) do
 258: LD_ADDR_VAR 0 1
 262: PUSH
 263: LD_INT 22
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: LD_INT 21
 278: PUSH
 279: LD_INT 3
 281: PUSH
 282: EMPTY
 283: LIST
 284: LIST
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: FOR_IN
 300: IFFALSE 331
// if GetLives ( i ) < 1000 then
 302: LD_VAR 0 1
 306: PPUSH
 307: CALL_OW 256
 311: PUSH
 312: LD_INT 1000
 314: LESS
 315: IFFALSE 329
// SetLives ( i , 1000 ) ;
 317: LD_VAR 0 1
 321: PPUSH
 322: LD_INT 1000
 324: PPUSH
 325: CALL_OW 234
 329: GO 299
 331: POP
 332: POP
// end ; end_of_file
 333: PPOPN 1
 335: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 336: LD_INT 0
 338: PPUSH
 339: PPUSH
// if exist_mode then
 340: LD_VAR 0 2
 344: IFFALSE 369
// unit := CreateCharacter ( prefix & ident ) else
 346: LD_ADDR_VAR 0 5
 350: PUSH
 351: LD_VAR 0 3
 355: PUSH
 356: LD_VAR 0 1
 360: STR
 361: PPUSH
 362: CALL_OW 34
 366: ST_TO_ADDR
 367: GO 384
// unit := NewCharacter ( ident ) ;
 369: LD_ADDR_VAR 0 5
 373: PUSH
 374: LD_VAR 0 1
 378: PPUSH
 379: CALL_OW 25
 383: ST_TO_ADDR
// result := unit ;
 384: LD_ADDR_VAR 0 4
 388: PUSH
 389: LD_VAR 0 5
 393: ST_TO_ADDR
// end ;
 394: LD_VAR 0 4
 398: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 399: LD_INT 0
 401: PPUSH
// uc_side := side ;
 402: LD_ADDR_OWVAR 20
 406: PUSH
 407: LD_VAR 0 1
 411: ST_TO_ADDR
// uc_nation := nation ;
 412: LD_ADDR_OWVAR 21
 416: PUSH
 417: LD_VAR 0 2
 421: ST_TO_ADDR
// vc_chassis := chassis ;
 422: LD_ADDR_OWVAR 37
 426: PUSH
 427: LD_VAR 0 3
 431: ST_TO_ADDR
// vc_engine := engine ;
 432: LD_ADDR_OWVAR 39
 436: PUSH
 437: LD_VAR 0 4
 441: ST_TO_ADDR
// vc_control := control ;
 442: LD_ADDR_OWVAR 38
 446: PUSH
 447: LD_VAR 0 5
 451: ST_TO_ADDR
// vc_weapon := weapon ;
 452: LD_ADDR_OWVAR 40
 456: PUSH
 457: LD_VAR 0 6
 461: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 462: LD_ADDR_OWVAR 41
 466: PUSH
 467: LD_VAR 0 7
 471: ST_TO_ADDR
// result := CreateVehicle ;
 472: LD_ADDR_VAR 0 8
 476: PUSH
 477: CALL_OW 45
 481: ST_TO_ADDR
// end ;
 482: LD_VAR 0 8
 486: RET
// export function SayX ( units , ident ) ; var i ; begin
 487: LD_INT 0
 489: PPUSH
 490: PPUSH
// result := false ;
 491: LD_ADDR_VAR 0 3
 495: PUSH
 496: LD_INT 0
 498: ST_TO_ADDR
// if not units then
 499: LD_VAR 0 1
 503: NOT
 504: IFFALSE 508
// exit ;
 506: GO 562
// for i in units do
 508: LD_ADDR_VAR 0 4
 512: PUSH
 513: LD_VAR 0 1
 517: PUSH
 518: FOR_IN
 519: IFFALSE 560
// if IsOk ( i ) then
 521: LD_VAR 0 4
 525: PPUSH
 526: CALL_OW 302
 530: IFFALSE 558
// begin Say ( i , ident ) ;
 532: LD_VAR 0 4
 536: PPUSH
 537: LD_VAR 0 2
 541: PPUSH
 542: CALL_OW 88
// result := i ;
 546: LD_ADDR_VAR 0 3
 550: PUSH
 551: LD_VAR 0 4
 555: ST_TO_ADDR
// break ;
 556: GO 560
// end ;
 558: GO 518
 560: POP
 561: POP
// end ;
 562: LD_VAR 0 3
 566: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 567: LD_INT 0
 569: PPUSH
 570: PPUSH
// InitUc ;
 571: CALL_OW 18
// InitHc ;
 575: CALL_OW 19
// uc_side := 0 ;
 579: LD_ADDR_OWVAR 20
 583: PUSH
 584: LD_INT 0
 586: ST_TO_ADDR
// uc_nation := 0 ;
 587: LD_ADDR_OWVAR 21
 591: PUSH
 592: LD_INT 0
 594: ST_TO_ADDR
// for i = 1 to amount do
 595: LD_ADDR_VAR 0 4
 599: PUSH
 600: DOUBLE
 601: LD_INT 1
 603: DEC
 604: ST_TO_ADDR
 605: LD_VAR 0 2
 609: PUSH
 610: FOR_TO
 611: IFFALSE 693
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 613: LD_ADDR_OWVAR 29
 617: PUSH
 618: LD_INT 9
 620: PPUSH
 621: LD_INT 12
 623: PPUSH
 624: CALL_OW 12
 628: PUSH
 629: LD_INT 9
 631: PPUSH
 632: LD_INT 12
 634: PPUSH
 635: CALL_OW 12
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 644: LD_ADDR_OWVAR 35
 648: PUSH
 649: LD_INT 1
 651: NEG
 652: PPUSH
 653: LD_INT 1
 655: PPUSH
 656: CALL_OW 12
 660: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 661: LD_INT 0
 663: PPUSH
 664: LD_INT 12
 666: PPUSH
 667: LD_INT 1
 669: PPUSH
 670: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 674: CALL_OW 44
 678: PPUSH
 679: LD_VAR 0 1
 683: PPUSH
 684: LD_INT 0
 686: PPUSH
 687: CALL_OW 49
// end ;
 691: GO 610
 693: POP
 694: POP
// InitHc ;
 695: CALL_OW 19
// end ;
 699: LD_VAR 0 3
 703: RET
// export function PrepareNature ( forest ) ; var i ; begin
 704: LD_INT 0
 706: PPUSH
 707: PPUSH
// SpawnApeman ( forest , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
 708: LD_VAR 0 1
 712: PPUSH
 713: LD_INT 3
 715: PUSH
 716: LD_INT 3
 718: PUSH
 719: LD_INT 2
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_OWVAR 67
 731: ARRAY
 732: PPUSH
 733: CALL 567 0 2
// for i := 1 to 2 do
 737: LD_ADDR_VAR 0 3
 741: PUSH
 742: DOUBLE
 743: LD_INT 1
 745: DEC
 746: ST_TO_ADDR
 747: LD_INT 2
 749: PUSH
 750: FOR_TO
 751: IFFALSE 788
// begin hc_class := 21 ;
 753: LD_ADDR_OWVAR 28
 757: PUSH
 758: LD_INT 21
 760: ST_TO_ADDR
// hc_gallery :=  ;
 761: LD_ADDR_OWVAR 33
 765: PUSH
 766: LD_STRING 
 768: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 769: CALL_OW 44
 773: PPUSH
 774: LD_VAR 0 1
 778: PPUSH
 779: LD_INT 0
 781: PPUSH
 782: CALL_OW 49
// end ;
 786: GO 750
 788: POP
 789: POP
// for i := 1 to 2 do
 790: LD_ADDR_VAR 0 3
 794: PUSH
 795: DOUBLE
 796: LD_INT 1
 798: DEC
 799: ST_TO_ADDR
 800: LD_INT 2
 802: PUSH
 803: FOR_TO
 804: IFFALSE 841
// begin hc_class := 18 ;
 806: LD_ADDR_OWVAR 28
 810: PUSH
 811: LD_INT 18
 813: ST_TO_ADDR
// hc_gallery :=  ;
 814: LD_ADDR_OWVAR 33
 818: PUSH
 819: LD_STRING 
 821: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 822: CALL_OW 44
 826: PPUSH
 827: LD_VAR 0 1
 831: PPUSH
 832: LD_INT 0
 834: PPUSH
 835: CALL_OW 49
// end ;
 839: GO 803
 841: POP
 842: POP
// for i := 1 to 2 do
 843: LD_ADDR_VAR 0 3
 847: PUSH
 848: DOUBLE
 849: LD_INT 1
 851: DEC
 852: ST_TO_ADDR
 853: LD_INT 2
 855: PUSH
 856: FOR_TO
 857: IFFALSE 894
// begin hc_class := 13 ;
 859: LD_ADDR_OWVAR 28
 863: PUSH
 864: LD_INT 13
 866: ST_TO_ADDR
// hc_gallery :=  ;
 867: LD_ADDR_OWVAR 33
 871: PUSH
 872: LD_STRING 
 874: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 875: CALL_OW 44
 879: PPUSH
 880: LD_VAR 0 1
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// end ;
 892: GO 856
 894: POP
 895: POP
// end ;
 896: LD_VAR 0 2
 900: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 901: LD_INT 0
 903: PPUSH
 904: PPUSH
 905: PPUSH
// if not observer or not unit then
 906: LD_VAR 0 1
 910: NOT
 911: PUSH
 912: LD_VAR 0 2
 916: NOT
 917: OR
 918: IFFALSE 922
// exit ;
 920: GO 970
// if not See ( GetSide ( observer ) , unit ) then
 922: LD_VAR 0 1
 926: PPUSH
 927: CALL_OW 255
 931: PPUSH
 932: LD_VAR 0 2
 936: PPUSH
 937: CALL_OW 292
 941: NOT
 942: IFFALSE 946
// exit ;
 944: GO 970
// result := GetDistUnits ( observer , unit ) < 12 ;
 946: LD_ADDR_VAR 0 3
 950: PUSH
 951: LD_VAR 0 1
 955: PPUSH
 956: LD_VAR 0 2
 960: PPUSH
 961: CALL_OW 296
 965: PUSH
 966: LD_INT 12
 968: LESS
 969: ST_TO_ADDR
// end ;
 970: LD_VAR 0 3
 974: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 975: LD_INT 0
 977: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 978: LD_VAR 0 2
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: LD_VAR 0 2
 991: PUSH
 992: LD_INT 2
 994: ARRAY
 995: PPUSH
 996: CALL_OW 488
1000: PUSH
1001: LD_VAR 0 2
1005: PUSH
1006: LD_INT 1
1008: ARRAY
1009: PPUSH
1010: LD_VAR 0 2
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 428
1023: PUSH
1024: LD_INT 0
1026: EQUAL
1027: AND
1028: IFFALSE 1062
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
1030: LD_VAR 0 1
1034: PPUSH
1035: LD_VAR 0 2
1039: PUSH
1040: LD_INT 1
1042: ARRAY
1043: PPUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_INT 2
1051: ARRAY
1052: PPUSH
1053: LD_VAR 0 3
1057: PPUSH
1058: CALL_OW 48
// end ;
1062: LD_VAR 0 4
1066: RET
// export function Video ( mode ) ; begin
1067: LD_INT 0
1069: PPUSH
// ingame_video = mode ;
1070: LD_ADDR_OWVAR 52
1074: PUSH
1075: LD_VAR 0 1
1079: ST_TO_ADDR
// interface_hidden = mode ;
1080: LD_ADDR_OWVAR 54
1084: PUSH
1085: LD_VAR 0 1
1089: ST_TO_ADDR
// end ;
1090: LD_VAR 0 2
1094: RET
// export function ReverseArray ( array ) ; var i ; begin
1095: LD_INT 0
1097: PPUSH
1098: PPUSH
// if not array then
1099: LD_VAR 0 1
1103: NOT
1104: IFFALSE 1108
// exit ;
1106: GO 1166
// result := [ ] ;
1108: LD_ADDR_VAR 0 2
1112: PUSH
1113: EMPTY
1114: ST_TO_ADDR
// for i := 1 to array do
1115: LD_ADDR_VAR 0 3
1119: PUSH
1120: DOUBLE
1121: LD_INT 1
1123: DEC
1124: ST_TO_ADDR
1125: LD_VAR 0 1
1129: PUSH
1130: FOR_TO
1131: IFFALSE 1164
// result := Insert ( result , 1 , array [ i ] ) ;
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 2
1142: PPUSH
1143: LD_INT 1
1145: PPUSH
1146: LD_VAR 0 1
1150: PUSH
1151: LD_VAR 0 3
1155: ARRAY
1156: PPUSH
1157: CALL_OW 2
1161: ST_TO_ADDR
1162: GO 1130
1164: POP
1165: POP
// end ;
1166: LD_VAR 0 2
1170: RET
// export function ComExit ( unit ) ; begin
1171: LD_INT 0
1173: PPUSH
// result := IsInUnit ( unit ) ;
1174: LD_ADDR_VAR 0 2
1178: PUSH
1179: LD_VAR 0 1
1183: PPUSH
1184: CALL_OW 310
1188: ST_TO_ADDR
// if not result then
1189: LD_VAR 0 2
1193: NOT
1194: IFFALSE 1198
// exit ;
1196: GO 1233
// if GetType ( result ) = unit_vehicle then
1198: LD_VAR 0 2
1202: PPUSH
1203: CALL_OW 247
1207: PUSH
1208: LD_INT 2
1210: EQUAL
1211: IFFALSE 1224
// ComExitVehicle ( unit ) else
1213: LD_VAR 0 1
1217: PPUSH
1218: CALL_OW 121
1222: GO 1233
// ComExitBuilding ( unit ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: CALL_OW 122
// end ;
1233: LD_VAR 0 2
1237: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1238: LD_INT 0
1240: PPUSH
1241: PPUSH
// if not side or not nation then
1242: LD_VAR 0 1
1246: NOT
1247: PUSH
1248: LD_VAR 0 2
1252: NOT
1253: OR
1254: IFFALSE 1258
// exit ;
1256: GO 2022
// case nation of nation_american :
1258: LD_VAR 0 2
1262: PUSH
1263: LD_INT 1
1265: DOUBLE
1266: EQUAL
1267: IFTRUE 1271
1269: GO 1485
1271: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1272: LD_ADDR_VAR 0 4
1276: PUSH
1277: LD_INT 35
1279: PUSH
1280: LD_INT 45
1282: PUSH
1283: LD_INT 46
1285: PUSH
1286: LD_INT 47
1288: PUSH
1289: LD_INT 82
1291: PUSH
1292: LD_INT 83
1294: PUSH
1295: LD_INT 84
1297: PUSH
1298: LD_INT 85
1300: PUSH
1301: LD_INT 86
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: LD_INT 2
1309: PUSH
1310: LD_INT 6
1312: PUSH
1313: LD_INT 15
1315: PUSH
1316: LD_INT 16
1318: PUSH
1319: LD_INT 7
1321: PUSH
1322: LD_INT 12
1324: PUSH
1325: LD_INT 13
1327: PUSH
1328: LD_INT 10
1330: PUSH
1331: LD_INT 14
1333: PUSH
1334: LD_INT 20
1336: PUSH
1337: LD_INT 21
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_INT 25
1345: PUSH
1346: LD_INT 32
1348: PUSH
1349: LD_INT 27
1351: PUSH
1352: LD_INT 36
1354: PUSH
1355: LD_INT 69
1357: PUSH
1358: LD_INT 39
1360: PUSH
1361: LD_INT 34
1363: PUSH
1364: LD_INT 40
1366: PUSH
1367: LD_INT 48
1369: PUSH
1370: LD_INT 49
1372: PUSH
1373: LD_INT 50
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 52
1381: PUSH
1382: LD_INT 53
1384: PUSH
1385: LD_INT 54
1387: PUSH
1388: LD_INT 55
1390: PUSH
1391: LD_INT 56
1393: PUSH
1394: LD_INT 57
1396: PUSH
1397: LD_INT 58
1399: PUSH
1400: LD_INT 59
1402: PUSH
1403: LD_INT 60
1405: PUSH
1406: LD_INT 61
1408: PUSH
1409: LD_INT 62
1411: PUSH
1412: LD_INT 80
1414: PUSH
1415: LD_INT 82
1417: PUSH
1418: LD_INT 83
1420: PUSH
1421: LD_INT 84
1423: PUSH
1424: LD_INT 85
1426: PUSH
1427: LD_INT 86
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: ST_TO_ADDR
1483: GO 1946
1485: LD_INT 2
1487: DOUBLE
1488: EQUAL
1489: IFTRUE 1493
1491: GO 1715
1493: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_INT 35
1501: PUSH
1502: LD_INT 45
1504: PUSH
1505: LD_INT 46
1507: PUSH
1508: LD_INT 47
1510: PUSH
1511: LD_INT 82
1513: PUSH
1514: LD_INT 83
1516: PUSH
1517: LD_INT 84
1519: PUSH
1520: LD_INT 85
1522: PUSH
1523: LD_INT 87
1525: PUSH
1526: LD_INT 70
1528: PUSH
1529: LD_INT 1
1531: PUSH
1532: LD_INT 11
1534: PUSH
1535: LD_INT 3
1537: PUSH
1538: LD_INT 4
1540: PUSH
1541: LD_INT 5
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: LD_INT 15
1549: PUSH
1550: LD_INT 18
1552: PUSH
1553: LD_INT 7
1555: PUSH
1556: LD_INT 17
1558: PUSH
1559: LD_INT 8
1561: PUSH
1562: LD_INT 20
1564: PUSH
1565: LD_INT 21
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: LD_INT 72
1573: PUSH
1574: LD_INT 26
1576: PUSH
1577: LD_INT 69
1579: PUSH
1580: LD_INT 39
1582: PUSH
1583: LD_INT 40
1585: PUSH
1586: LD_INT 41
1588: PUSH
1589: LD_INT 42
1591: PUSH
1592: LD_INT 43
1594: PUSH
1595: LD_INT 48
1597: PUSH
1598: LD_INT 49
1600: PUSH
1601: LD_INT 50
1603: PUSH
1604: LD_INT 51
1606: PUSH
1607: LD_INT 52
1609: PUSH
1610: LD_INT 53
1612: PUSH
1613: LD_INT 54
1615: PUSH
1616: LD_INT 55
1618: PUSH
1619: LD_INT 56
1621: PUSH
1622: LD_INT 60
1624: PUSH
1625: LD_INT 61
1627: PUSH
1628: LD_INT 62
1630: PUSH
1631: LD_INT 66
1633: PUSH
1634: LD_INT 67
1636: PUSH
1637: LD_INT 68
1639: PUSH
1640: LD_INT 81
1642: PUSH
1643: LD_INT 82
1645: PUSH
1646: LD_INT 83
1648: PUSH
1649: LD_INT 84
1651: PUSH
1652: LD_INT 85
1654: PUSH
1655: LD_INT 87
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: LIST
1711: LIST
1712: ST_TO_ADDR
1713: GO 1946
1715: LD_INT 3
1717: DOUBLE
1718: EQUAL
1719: IFTRUE 1723
1721: GO 1945
1723: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_INT 46
1731: PUSH
1732: LD_INT 47
1734: PUSH
1735: LD_INT 1
1737: PUSH
1738: LD_INT 2
1740: PUSH
1741: LD_INT 82
1743: PUSH
1744: LD_INT 83
1746: PUSH
1747: LD_INT 84
1749: PUSH
1750: LD_INT 85
1752: PUSH
1753: LD_INT 86
1755: PUSH
1756: LD_INT 11
1758: PUSH
1759: LD_INT 9
1761: PUSH
1762: LD_INT 20
1764: PUSH
1765: LD_INT 19
1767: PUSH
1768: LD_INT 21
1770: PUSH
1771: LD_INT 24
1773: PUSH
1774: LD_INT 22
1776: PUSH
1777: LD_INT 25
1779: PUSH
1780: LD_INT 28
1782: PUSH
1783: LD_INT 29
1785: PUSH
1786: LD_INT 30
1788: PUSH
1789: LD_INT 31
1791: PUSH
1792: LD_INT 37
1794: PUSH
1795: LD_INT 38
1797: PUSH
1798: LD_INT 32
1800: PUSH
1801: LD_INT 27
1803: PUSH
1804: LD_INT 33
1806: PUSH
1807: LD_INT 69
1809: PUSH
1810: LD_INT 39
1812: PUSH
1813: LD_INT 34
1815: PUSH
1816: LD_INT 40
1818: PUSH
1819: LD_INT 71
1821: PUSH
1822: LD_INT 23
1824: PUSH
1825: LD_INT 44
1827: PUSH
1828: LD_INT 48
1830: PUSH
1831: LD_INT 49
1833: PUSH
1834: LD_INT 50
1836: PUSH
1837: LD_INT 51
1839: PUSH
1840: LD_INT 52
1842: PUSH
1843: LD_INT 53
1845: PUSH
1846: LD_INT 54
1848: PUSH
1849: LD_INT 55
1851: PUSH
1852: LD_INT 56
1854: PUSH
1855: LD_INT 57
1857: PUSH
1858: LD_INT 58
1860: PUSH
1861: LD_INT 59
1863: PUSH
1864: LD_INT 63
1866: PUSH
1867: LD_INT 64
1869: PUSH
1870: LD_INT 65
1872: PUSH
1873: LD_INT 82
1875: PUSH
1876: LD_INT 83
1878: PUSH
1879: LD_INT 84
1881: PUSH
1882: LD_INT 85
1884: PUSH
1885: LD_INT 86
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: ST_TO_ADDR
1943: GO 1946
1945: POP
// if state > - 1 and state < 3 then
1946: LD_VAR 0 3
1950: PUSH
1951: LD_INT 1
1953: NEG
1954: GREATER
1955: PUSH
1956: LD_VAR 0 3
1960: PUSH
1961: LD_INT 3
1963: LESS
1964: AND
1965: IFFALSE 2022
// for i in result do
1967: LD_ADDR_VAR 0 5
1971: PUSH
1972: LD_VAR 0 4
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2020
// if GetTech ( i , side ) <> state then
1980: LD_VAR 0 5
1984: PPUSH
1985: LD_VAR 0 1
1989: PPUSH
1990: CALL_OW 321
1994: PUSH
1995: LD_VAR 0 3
1999: NONEQUAL
2000: IFFALSE 2018
// result := result diff i ;
2002: LD_ADDR_VAR 0 4
2006: PUSH
2007: LD_VAR 0 4
2011: PUSH
2012: LD_VAR 0 5
2016: DIFF
2017: ST_TO_ADDR
2018: GO 1977
2020: POP
2021: POP
// end ;
2022: LD_VAR 0 4
2026: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
2027: LD_INT 0
2029: PPUSH
2030: PPUSH
2031: PPUSH
2032: PPUSH
// if not list then
2033: LD_VAR 0 3
2037: NOT
2038: IFFALSE 2042
// exit ;
2040: GO 2350
// result := [ ] ;
2042: LD_ADDR_VAR 0 5
2046: PUSH
2047: EMPTY
2048: ST_TO_ADDR
// for i in list do
2049: LD_ADDR_VAR 0 6
2053: PUSH
2054: LD_VAR 0 3
2058: PUSH
2059: FOR_IN
2060: IFFALSE 2262
// begin tmp := GetDistUnitXY ( i , x , y ) ;
2062: LD_ADDR_VAR 0 8
2066: PUSH
2067: LD_VAR 0 6
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: LD_VAR 0 2
2081: PPUSH
2082: CALL_OW 297
2086: ST_TO_ADDR
// if not result then
2087: LD_VAR 0 5
2091: NOT
2092: IFFALSE 2118
// result := [ [ i , tmp ] ] else
2094: LD_ADDR_VAR 0 5
2098: PUSH
2099: LD_VAR 0 6
2103: PUSH
2104: LD_VAR 0 8
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: EMPTY
2114: LIST
2115: ST_TO_ADDR
2116: GO 2260
// begin if result [ result ] [ 2 ] < tmp then
2118: LD_VAR 0 5
2122: PUSH
2123: LD_VAR 0 5
2127: ARRAY
2128: PUSH
2129: LD_INT 2
2131: ARRAY
2132: PUSH
2133: LD_VAR 0 8
2137: LESS
2138: IFFALSE 2180
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
2140: LD_ADDR_VAR 0 5
2144: PUSH
2145: LD_VAR 0 5
2149: PPUSH
2150: LD_VAR 0 5
2154: PUSH
2155: LD_INT 1
2157: PLUS
2158: PPUSH
2159: LD_VAR 0 6
2163: PUSH
2164: LD_VAR 0 8
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PPUSH
2173: CALL_OW 2
2177: ST_TO_ADDR
2178: GO 2260
// for j = 1 to result do
2180: LD_ADDR_VAR 0 7
2184: PUSH
2185: DOUBLE
2186: LD_INT 1
2188: DEC
2189: ST_TO_ADDR
2190: LD_VAR 0 5
2194: PUSH
2195: FOR_TO
2196: IFFALSE 2258
// begin if tmp < result [ j ] [ 2 ] then
2198: LD_VAR 0 8
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_VAR 0 7
2212: ARRAY
2213: PUSH
2214: LD_INT 2
2216: ARRAY
2217: LESS
2218: IFFALSE 2256
// begin result := Insert ( result , j , [ i , tmp ] ) ;
2220: LD_ADDR_VAR 0 5
2224: PUSH
2225: LD_VAR 0 5
2229: PPUSH
2230: LD_VAR 0 7
2234: PPUSH
2235: LD_VAR 0 6
2239: PUSH
2240: LD_VAR 0 8
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PPUSH
2249: CALL_OW 2
2253: ST_TO_ADDR
// break ;
2254: GO 2258
// end ; end ;
2256: GO 2195
2258: POP
2259: POP
// end ; end ;
2260: GO 2059
2262: POP
2263: POP
// if result and not asc then
2264: LD_VAR 0 5
2268: PUSH
2269: LD_VAR 0 4
2273: NOT
2274: AND
2275: IFFALSE 2350
// begin tmp := result ;
2277: LD_ADDR_VAR 0 8
2281: PUSH
2282: LD_VAR 0 5
2286: ST_TO_ADDR
// for i = tmp downto 1 do
2287: LD_ADDR_VAR 0 6
2291: PUSH
2292: DOUBLE
2293: LD_VAR 0 8
2297: INC
2298: ST_TO_ADDR
2299: LD_INT 1
2301: PUSH
2302: FOR_DOWNTO
2303: IFFALSE 2348
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PPUSH
2315: LD_VAR 0 8
2319: PUSH
2320: LD_VAR 0 6
2324: MINUS
2325: PUSH
2326: LD_INT 1
2328: PLUS
2329: PPUSH
2330: LD_VAR 0 8
2334: PUSH
2335: LD_VAR 0 6
2339: ARRAY
2340: PPUSH
2341: CALL_OW 1
2345: ST_TO_ADDR
2346: GO 2302
2348: POP
2349: POP
// end ; end ;
2350: LD_VAR 0 5
2354: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
2355: LD_INT 0
2357: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
2358: LD_ADDR_VAR 0 4
2362: PUSH
2363: LD_VAR 0 1
2367: PPUSH
2368: CALL_OW 250
2372: PPUSH
2373: LD_VAR 0 1
2377: PPUSH
2378: CALL_OW 251
2382: PPUSH
2383: LD_VAR 0 2
2387: PPUSH
2388: LD_VAR 0 3
2392: PPUSH
2393: CALL 2027 0 4
2397: ST_TO_ADDR
// end ;
2398: LD_VAR 0 4
2402: RET
// export function NearestEmptyBuilding ( unit , btype ) ; var side , tmp , i , places ; begin
2403: LD_INT 0
2405: PPUSH
2406: PPUSH
2407: PPUSH
2408: PPUSH
2409: PPUSH
// if not unit then
2410: LD_VAR 0 1
2414: NOT
2415: IFFALSE 2419
// exit ;
2417: GO 2621
// side := GetSide ( unit ) ;
2419: LD_ADDR_VAR 0 4
2423: PUSH
2424: LD_VAR 0 1
2428: PPUSH
2429: CALL_OW 255
2433: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
2434: LD_ADDR_VAR 0 5
2438: PUSH
2439: LD_INT 22
2441: PUSH
2442: LD_VAR 0 4
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: PUSH
2451: LD_INT 30
2453: PUSH
2454: LD_VAR 0 2
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PPUSH
2467: CALL_OW 69
2471: ST_TO_ADDR
// if not tmp then
2472: LD_VAR 0 5
2476: NOT
2477: IFFALSE 2481
// exit ;
2479: GO 2621
// tmp := SortByDistanceUnit ( unit , tmp , true ) ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 1
2490: PPUSH
2491: LD_VAR 0 5
2495: PPUSH
2496: LD_INT 1
2498: PPUSH
2499: CALL 2355 0 3
2503: ST_TO_ADDR
// places := 1 ;
2504: LD_ADDR_VAR 0 7
2508: PUSH
2509: LD_INT 1
2511: ST_TO_ADDR
// if btype in [ b_depot , b_warehouse , b_armoury , b_barracks , b_workshop , b_factory , b_lab , b_lab_half , b_lab_full ] then
2512: LD_VAR 0 2
2516: PUSH
2517: LD_INT 0
2519: PUSH
2520: LD_INT 1
2522: PUSH
2523: LD_INT 4
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: LD_INT 2
2531: PUSH
2532: LD_INT 3
2534: PUSH
2535: LD_INT 6
2537: PUSH
2538: LD_INT 7
2540: PUSH
2541: LD_INT 8
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: LIST
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: IN
2555: IFFALSE 2565
// places := 6 ;
2557: LD_ADDR_VAR 0 7
2561: PUSH
2562: LD_INT 6
2564: ST_TO_ADDR
// for i in tmp do
2565: LD_ADDR_VAR 0 6
2569: PUSH
2570: LD_VAR 0 5
2574: PUSH
2575: FOR_IN
2576: IFFALSE 2619
// begin if UnitsInside ( i ) - places <= 0 then
2578: LD_VAR 0 6
2582: PPUSH
2583: CALL_OW 313
2587: PUSH
2588: LD_VAR 0 7
2592: MINUS
2593: PUSH
2594: LD_INT 0
2596: LESSEQUAL
2597: IFFALSE 2603
// continue else
2599: GO 2575
2601: GO 2617
// begin result := i ;
2603: LD_ADDR_VAR 0 3
2607: PUSH
2608: LD_VAR 0 6
2612: ST_TO_ADDR
// exit ;
2613: POP
2614: POP
2615: GO 2621
// end ; end ;
2617: GO 2575
2619: POP
2620: POP
// end ; end_of_file
2621: LD_VAR 0 3
2625: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Shariff , Kurt , Aviradze , heikeSecondSquad , heikeVehicles , heikeApes ; export function PrepareArabian ; var i ; begin
2626: LD_INT 0
2628: PPUSH
2629: PPUSH
// uc_side := 2 ;
2630: LD_ADDR_OWVAR 20
2634: PUSH
2635: LD_INT 2
2637: ST_TO_ADDR
// uc_nation := 2 ;
2638: LD_ADDR_OWVAR 21
2642: PUSH
2643: LD_INT 2
2645: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2646: LD_ADDR_EXP 18
2650: PUSH
2651: LD_STRING Heike
2653: PPUSH
2654: LD_EXP 1
2658: NOT
2659: PPUSH
2660: LD_EXP 2
2664: PPUSH
2665: CALL 336 0 3
2669: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
2670: LD_ADDR_EXP 21
2674: PUSH
2675: LD_STRING Ibrahim
2677: PPUSH
2678: LD_EXP 1
2682: NOT
2683: PPUSH
2684: LD_EXP 2
2688: PPUSH
2689: CALL 336 0 3
2693: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2694: LD_ADDR_EXP 19
2698: PUSH
2699: LD_STRING Givi
2701: PPUSH
2702: LD_EXP 1
2706: NOT
2707: PPUSH
2708: LD_EXP 2
2712: PPUSH
2713: CALL 336 0 3
2717: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2718: LD_ADDR_EXP 22
2722: PUSH
2723: LD_STRING Kamil
2725: PPUSH
2726: LD_EXP 1
2730: NOT
2731: PPUSH
2732: LD_EXP 2
2736: PPUSH
2737: CALL 336 0 3
2741: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2742: LD_ADDR_EXP 23
2746: PUSH
2747: LD_STRING Kaia
2749: PPUSH
2750: LD_EXP 1
2754: NOT
2755: PPUSH
2756: LD_EXP 2
2760: PPUSH
2761: CALL 336 0 3
2765: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2766: LD_ADDR_EXP 24
2770: PUSH
2771: LD_STRING Sophia
2773: PPUSH
2774: LD_EXP 1
2778: NOT
2779: PPUSH
2780: LD_EXP 2
2784: PPUSH
2785: CALL 336 0 3
2789: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2790: LD_ADDR_EXP 25
2794: PUSH
2795: LD_STRING Markov
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_EXP 2
2808: PPUSH
2809: CALL 336 0 3
2813: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2814: LD_ADDR_EXP 28
2818: PUSH
2819: LD_STRING Aviradze
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_EXP 2
2832: PPUSH
2833: CALL 336 0 3
2837: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , ( not debug ) , prefix ) ;
2838: LD_ADDR_EXP 27
2842: PUSH
2843: LD_STRING Kurt
2845: PPUSH
2846: LD_EXP 1
2850: NOT
2851: PPUSH
2852: LD_EXP 2
2856: PPUSH
2857: CALL 336 0 3
2861: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2862: LD_ADDR_EXP 20
2866: PUSH
2867: LD_STRING Mike
2869: PPUSH
2870: LD_EXP 1
2874: NOT
2875: PPUSH
2876: LD_EXP 2
2880: PPUSH
2881: CALL 336 0 3
2885: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_1_others ) ;
2886: LD_ADDR_EXP 29
2890: PUSH
2891: LD_STRING 04_1_others
2893: PPUSH
2894: CALL_OW 31
2898: ST_TO_ADDR
// heikeApes := CreateCharacterSet ( 04_1_apes ) ;
2899: LD_ADDR_EXP 31
2903: PUSH
2904: LD_STRING 04_1_apes
2906: PPUSH
2907: CALL_OW 31
2911: ST_TO_ADDR
// heikeVehicles := LoadVariable ( 04_1_Vehicles , [ ] ) ;
2912: LD_ADDR_EXP 30
2916: PUSH
2917: LD_STRING 04_1_Vehicles
2919: PPUSH
2920: EMPTY
2921: PPUSH
2922: CALL_OW 30
2926: ST_TO_ADDR
// uc_side := 5 ;
2927: LD_ADDR_OWVAR 20
2931: PUSH
2932: LD_INT 5
2934: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
2935: LD_ADDR_EXP 26
2939: PUSH
2940: LD_STRING Abdul
2942: PPUSH
2943: LD_INT 0
2945: PPUSH
2946: LD_STRING 
2948: PPUSH
2949: CALL 336 0 3
2953: ST_TO_ADDR
// end ;
2954: LD_VAR 0 1
2958: RET
// export cargoDriver ; every 2 2$00 trigger LoadVariable ( 04_1_KaganCaptured , 0 ) and not FilterAllUnits ( [ f_side , 5 ] ) and ( HexInfo ( 124 , 26 ) = 0 xor GetSide ( HexInfo ( 124 , 26 ) ) = 2 ) do var veh ;
2959: LD_STRING 04_1_KaganCaptured
2961: PPUSH
2962: LD_INT 0
2964: PPUSH
2965: CALL_OW 30
2969: PUSH
2970: LD_INT 22
2972: PUSH
2973: LD_INT 5
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: PPUSH
2980: CALL_OW 69
2984: NOT
2985: AND
2986: PUSH
2987: LD_INT 124
2989: PPUSH
2990: LD_INT 26
2992: PPUSH
2993: CALL_OW 428
2997: PUSH
2998: LD_INT 0
3000: EQUAL
3001: PUSH
3002: LD_INT 124
3004: PPUSH
3005: LD_INT 26
3007: PPUSH
3008: CALL_OW 428
3012: PPUSH
3013: CALL_OW 255
3017: PUSH
3018: LD_INT 2
3020: EQUAL
3021: XOR
3022: AND
3023: IFFALSE 3282
3025: GO 3027
3027: DISABLE
3028: LD_INT 0
3030: PPUSH
// begin enable ;
3031: ENABLE
// uc_side := 5 ;
3032: LD_ADDR_OWVAR 20
3036: PUSH
3037: LD_INT 5
3039: ST_TO_ADDR
// uc_nation := 2 ;
3040: LD_ADDR_OWVAR 21
3044: PUSH
3045: LD_INT 2
3047: ST_TO_ADDR
// PrepareTank ( 5 , 2 , ar_medium_trike , engine_solar , control_manual , ar_cargo_bay , 70 ) ;
3048: LD_INT 5
3050: PPUSH
3051: LD_INT 2
3053: PPUSH
3054: LD_INT 13
3056: PPUSH
3057: LD_INT 2
3059: PPUSH
3060: LD_INT 1
3062: PPUSH
3063: LD_INT 32
3065: PPUSH
3066: LD_INT 70
3068: PPUSH
3069: CALL 399 0 7
// veh := CreateVehicle ;
3073: LD_ADDR_VAR 0 1
3077: PUSH
3078: CALL_OW 45
3082: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3083: LD_VAR 0 1
3087: PPUSH
3088: LD_INT 3
3090: PPUSH
3091: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
3095: LD_VAR 0 1
3099: PPUSH
3100: LD_INT 8
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 49
// if not cargoDriver then
3110: LD_EXP 32
3114: NOT
3115: IFFALSE 3140
// begin PrepareHuman ( false , 1 , 3 ) ;
3117: LD_INT 0
3119: PPUSH
3120: LD_INT 1
3122: PPUSH
3123: LD_INT 3
3125: PPUSH
3126: CALL_OW 380
// cargoDriver := CreateHuman ;
3130: LD_ADDR_EXP 32
3134: PUSH
3135: CALL_OW 44
3139: ST_TO_ADDR
// end ; PlaceHumanInUnit ( cargoDriver , veh ) ;
3140: LD_EXP 32
3144: PPUSH
3145: LD_VAR 0 1
3149: PPUSH
3150: CALL_OW 52
// SetCargo ( veh , mat_oil , 100 ) ;
3154: LD_VAR 0 1
3158: PPUSH
3159: LD_INT 2
3161: PPUSH
3162: LD_INT 100
3164: PPUSH
3165: CALL_OW 290
// ComMoveXY ( veh , 142 , 15 ) ;
3169: LD_VAR 0 1
3173: PPUSH
3174: LD_INT 142
3176: PPUSH
3177: LD_INT 15
3179: PPUSH
3180: CALL_OW 111
// AddComUnload ( veh ) ;
3184: LD_VAR 0 1
3188: PPUSH
3189: CALL_OW 219
// AddComMoveXY ( veh , 133 , 2 ) ;
3193: LD_VAR 0 1
3197: PPUSH
3198: LD_INT 133
3200: PPUSH
3201: LD_INT 2
3203: PPUSH
3204: CALL_OW 171
// wait ( 0 0$5 ) ;
3208: LD_INT 175
3210: PPUSH
3211: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
3215: LD_INT 35
3217: PPUSH
3218: CALL_OW 67
// until IsAt ( veh , 133 , 2 ) or IsInArea ( veh , spawnArea ) ;
3222: LD_VAR 0 1
3226: PPUSH
3227: LD_INT 133
3229: PPUSH
3230: LD_INT 2
3232: PPUSH
3233: CALL_OW 307
3237: PUSH
3238: LD_VAR 0 1
3242: PPUSH
3243: LD_INT 8
3245: PPUSH
3246: CALL_OW 308
3250: OR
3251: IFFALSE 3215
// RemoveUnit ( cargoDriver ) ;
3253: LD_EXP 32
3257: PPUSH
3258: CALL_OW 64
// RemoveUnit ( veh ) ;
3262: LD_VAR 0 1
3266: PPUSH
3267: CALL_OW 64
// if tick >= 20 20$00 then
3271: LD_OWVAR 1
3275: PUSH
3276: LD_INT 42000
3278: GREATEREQUAL
3279: IFFALSE 3282
// disable ;
3281: DISABLE
// end ; end_of_file
3282: PPOPN 1
3284: END
// export Burlak , Gaidar , Kuzmov ; export ruForce , ruEng , ruMech , ruSci , ruMobile ; export ruSol ; export function PrepareRussian ; var base , blist , i , b , un , tmp , fac , oil ; begin
3285: LD_INT 0
3287: PPUSH
3288: PPUSH
3289: PPUSH
3290: PPUSH
3291: PPUSH
3292: PPUSH
3293: PPUSH
3294: PPUSH
3295: PPUSH
// uc_side := 3 ;
3296: LD_ADDR_OWVAR 20
3300: PUSH
3301: LD_INT 3
3303: ST_TO_ADDR
// uc_nation := 3 ;
3304: LD_ADDR_OWVAR 21
3308: PUSH
3309: LD_INT 3
3311: ST_TO_ADDR
// ruForce := [ ] ;
3312: LD_ADDR_EXP 36
3316: PUSH
3317: EMPTY
3318: ST_TO_ADDR
// ruMech := [ ] ;
3319: LD_ADDR_EXP 38
3323: PUSH
3324: EMPTY
3325: ST_TO_ADDR
// ruEng := [ ] ;
3326: LD_ADDR_EXP 37
3330: PUSH
3331: EMPTY
3332: ST_TO_ADDR
// ruSci := [ ] ;
3333: LD_ADDR_EXP 39
3337: PUSH
3338: EMPTY
3339: ST_TO_ADDR
// ruMobile := [ ] ;
3340: LD_ADDR_EXP 40
3344: PUSH
3345: EMPTY
3346: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ,  ) ;
3347: LD_ADDR_EXP 33
3351: PUSH
3352: LD_STRING Burlak
3354: PPUSH
3355: LD_INT 0
3357: PPUSH
3358: LD_STRING 
3360: PPUSH
3361: CALL 336 0 3
3365: ST_TO_ADDR
// Gaidar := PrepareUnit ( Gaydar , false ,  ) ;
3366: LD_ADDR_EXP 34
3370: PUSH
3371: LD_STRING Gaydar
3373: PPUSH
3374: LD_INT 0
3376: PPUSH
3377: LD_STRING 
3379: PPUSH
3380: CALL 336 0 3
3384: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , false ,  ) ;
3385: LD_ADDR_EXP 35
3389: PUSH
3390: LD_STRING Kuzmov
3392: PPUSH
3393: LD_INT 0
3395: PPUSH
3396: LD_STRING 
3398: PPUSH
3399: CALL 336 0 3
3403: ST_TO_ADDR
// PlaceHumanInUnit ( Kuzmov , ruMainBase ) ;
3404: LD_EXP 35
3408: PPUSH
3409: LD_INT 200
3411: PPUSH
3412: CALL_OW 52
// SetBName ( ruMainBase , chuikov ) ;
3416: LD_INT 200
3418: PPUSH
3419: LD_STRING chuikov
3421: PPUSH
3422: CALL_OW 500
// SetResourceType ( GetBase ( ruMainBase ) , mat_cans , [ 800 , 1000 , 1250 ] [ Difficulty ] ) ;
3426: LD_INT 200
3428: PPUSH
3429: CALL_OW 274
3433: PPUSH
3434: LD_INT 1
3436: PPUSH
3437: LD_INT 800
3439: PUSH
3440: LD_INT 1000
3442: PUSH
3443: LD_INT 1250
3445: PUSH
3446: EMPTY
3447: LIST
3448: LIST
3449: LIST
3450: PUSH
3451: LD_OWVAR 67
3455: ARRAY
3456: PPUSH
3457: CALL_OW 277
// SetResourceType ( GetBase ( ruMainBase ) , mat_oil , 160 ) ;
3461: LD_INT 200
3463: PPUSH
3464: CALL_OW 274
3468: PPUSH
3469: LD_INT 2
3471: PPUSH
3472: LD_INT 160
3474: PPUSH
3475: CALL_OW 277
// SetResourceType ( GetBase ( ruSecBase ) , mat_cans , 200 ) ;
3479: LD_INT 225
3481: PPUSH
3482: CALL_OW 274
3486: PPUSH
3487: LD_INT 1
3489: PPUSH
3490: LD_INT 200
3492: PPUSH
3493: CALL_OW 277
// oil := 150 ;
3497: LD_ADDR_VAR 0 9
3501: PUSH
3502: LD_INT 150
3504: ST_TO_ADDR
// if gameTime >= [ 45 45$00 , 40 40$00 , 35 35$00 ] [ Difficulty ] then
3505: LD_EXP 5
3509: PUSH
3510: LD_INT 94500
3512: PUSH
3513: LD_INT 84000
3515: PUSH
3516: LD_INT 73500
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: LIST
3523: PUSH
3524: LD_OWVAR 67
3528: ARRAY
3529: GREATEREQUAL
3530: IFFALSE 3685
// begin oil := 450 ;
3532: LD_ADDR_VAR 0 9
3536: PUSH
3537: LD_INT 450
3539: ST_TO_ADDR
// tmp := [ [ 123 , 17 , 3 , b_breastwork ] , [ 152 , 38 , 3 , b_breastwork ] , [ 81 , 6 , 4 , b_breastwork ] , [ 113 , 67 , 4 , b_bunker ] ] ;
3540: LD_ADDR_VAR 0 7
3544: PUSH
3545: LD_INT 123
3547: PUSH
3548: LD_INT 17
3550: PUSH
3551: LD_INT 3
3553: PUSH
3554: LD_INT 31
3556: PUSH
3557: EMPTY
3558: LIST
3559: LIST
3560: LIST
3561: LIST
3562: PUSH
3563: LD_INT 152
3565: PUSH
3566: LD_INT 38
3568: PUSH
3569: LD_INT 3
3571: PUSH
3572: LD_INT 31
3574: PUSH
3575: EMPTY
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: PUSH
3581: LD_INT 81
3583: PUSH
3584: LD_INT 6
3586: PUSH
3587: LD_INT 4
3589: PUSH
3590: LD_INT 31
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: LIST
3597: LIST
3598: PUSH
3599: LD_INT 113
3601: PUSH
3602: LD_INT 67
3604: PUSH
3605: LD_INT 4
3607: PUSH
3608: LD_INT 32
3610: PUSH
3611: EMPTY
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: LIST
3621: LIST
3622: ST_TO_ADDR
// for i in tmp do
3623: LD_ADDR_VAR 0 4
3627: PUSH
3628: LD_VAR 0 7
3632: PUSH
3633: FOR_IN
3634: IFFALSE 3683
// begin bc_type := i [ 4 ] ;
3636: LD_ADDR_OWVAR 42
3640: PUSH
3641: LD_VAR 0 4
3645: PUSH
3646: LD_INT 4
3648: ARRAY
3649: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3650: LD_VAR 0 4
3654: PUSH
3655: LD_INT 1
3657: ARRAY
3658: PPUSH
3659: LD_VAR 0 4
3663: PUSH
3664: LD_INT 2
3666: ARRAY
3667: PPUSH
3668: LD_VAR 0 4
3672: PUSH
3673: LD_INT 3
3675: ARRAY
3676: PPUSH
3677: CALL_OW 47
// end ;
3681: GO 3633
3683: POP
3684: POP
// end ; SetResourceType ( GetBase ( ruSecBase ) , mat_oil , oil ) ;
3685: LD_INT 225
3687: PPUSH
3688: CALL_OW 274
3692: PPUSH
3693: LD_INT 2
3695: PPUSH
3696: LD_VAR 0 9
3700: PPUSH
3701: CALL_OW 277
// if Difficulty > 1 then
3705: LD_OWVAR 67
3709: PUSH
3710: LD_INT 1
3712: GREATER
3713: IFFALSE 3808
// begin bc_type := b_bunker ;
3715: LD_ADDR_OWVAR 42
3719: PUSH
3720: LD_INT 32
3722: ST_TO_ADDR
// tmp := [ [ 121 , 85 , 5 ] , [ 93 , 72 , 1 ] ] ;
3723: LD_ADDR_VAR 0 7
3727: PUSH
3728: LD_INT 121
3730: PUSH
3731: LD_INT 85
3733: PUSH
3734: LD_INT 5
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: PUSH
3742: LD_INT 93
3744: PUSH
3745: LD_INT 72
3747: PUSH
3748: LD_INT 1
3750: PUSH
3751: EMPTY
3752: LIST
3753: LIST
3754: LIST
3755: PUSH
3756: EMPTY
3757: LIST
3758: LIST
3759: ST_TO_ADDR
// for i in tmp do
3760: LD_ADDR_VAR 0 4
3764: PUSH
3765: LD_VAR 0 7
3769: PUSH
3770: FOR_IN
3771: IFFALSE 3806
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3773: LD_VAR 0 4
3777: PUSH
3778: LD_INT 1
3780: ARRAY
3781: PPUSH
3782: LD_VAR 0 4
3786: PUSH
3787: LD_INT 2
3789: ARRAY
3790: PPUSH
3791: LD_VAR 0 4
3795: PUSH
3796: LD_INT 3
3798: ARRAY
3799: PPUSH
3800: CALL_OW 47
3804: GO 3770
3806: POP
3807: POP
// end ; base := GetBase ( ruMainBase ) ;
3808: LD_ADDR_VAR 0 2
3812: PUSH
3813: LD_INT 200
3815: PPUSH
3816: CALL_OW 274
3820: ST_TO_ADDR
// blist := GetBuildList ( base ) ;
3821: LD_ADDR_VAR 0 3
3825: PUSH
3826: LD_VAR 0 2
3830: PPUSH
3831: CALL_OW 417
3835: ST_TO_ADDR
// for b in blist do
3836: LD_ADDR_VAR 0 5
3840: PUSH
3841: LD_VAR 0 3
3845: PUSH
3846: FOR_IN
3847: IFFALSE 4298
// begin if b [ 1 ] = b_factory then
3849: LD_VAR 0 5
3853: PUSH
3854: LD_INT 1
3856: ARRAY
3857: PUSH
3858: LD_INT 3
3860: EQUAL
3861: IFFALSE 4012
// begin fac := HexInfo ( b [ 2 ] , b [ 3 ] ) ;
3863: LD_ADDR_VAR 0 8
3867: PUSH
3868: LD_VAR 0 5
3872: PUSH
3873: LD_INT 2
3875: ARRAY
3876: PPUSH
3877: LD_VAR 0 5
3881: PUSH
3882: LD_INT 3
3884: ARRAY
3885: PPUSH
3886: CALL_OW 428
3890: ST_TO_ADDR
// for i := 1 to [ 2 , 2 + Difficulty ] [ ( ruEscapeCounter > 3 ) + 1 ] do
3891: LD_ADDR_VAR 0 4
3895: PUSH
3896: DOUBLE
3897: LD_INT 1
3899: DEC
3900: ST_TO_ADDR
3901: LD_INT 2
3903: PUSH
3904: LD_INT 2
3906: PUSH
3907: LD_OWVAR 67
3911: PLUS
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: PUSH
3917: LD_EXP 10
3921: PUSH
3922: LD_INT 3
3924: GREATER
3925: PUSH
3926: LD_INT 1
3928: PLUS
3929: ARRAY
3930: PUSH
3931: FOR_TO
3932: IFFALSE 4008
// begin PrepareHuman ( false , 3 , 1 + Difficulty ) ;
3934: LD_INT 0
3936: PPUSH
3937: LD_INT 3
3939: PPUSH
3940: LD_INT 1
3942: PUSH
3943: LD_OWVAR 67
3947: PLUS
3948: PPUSH
3949: CALL_OW 380
// un := CreateHuman ;
3953: LD_ADDR_VAR 0 6
3957: PUSH
3958: CALL_OW 44
3962: ST_TO_ADDR
// ruMech := Replace ( ruMech , ruMech + 1 , un ) ;
3963: LD_ADDR_EXP 38
3967: PUSH
3968: LD_EXP 38
3972: PPUSH
3973: LD_EXP 38
3977: PUSH
3978: LD_INT 1
3980: PLUS
3981: PPUSH
3982: LD_VAR 0 6
3986: PPUSH
3987: CALL_OW 1
3991: ST_TO_ADDR
// PlaceHumanInUnit ( un , fac ) ;
3992: LD_VAR 0 6
3996: PPUSH
3997: LD_VAR 0 8
4001: PPUSH
4002: CALL_OW 52
// end ;
4006: GO 3931
4008: POP
4009: POP
// end else
4010: GO 4296
// if b [ 1 ] in [ b_lab , b_lab_half , b_lab_full , b_lab_weapon ] then
4012: LD_VAR 0 5
4016: PUSH
4017: LD_INT 1
4019: ARRAY
4020: PUSH
4021: LD_INT 6
4023: PUSH
4024: LD_INT 7
4026: PUSH
4027: LD_INT 8
4029: PUSH
4030: LD_INT 10
4032: PUSH
4033: EMPTY
4034: LIST
4035: LIST
4036: LIST
4037: LIST
4038: IN
4039: IFFALSE 4149
// begin for i := 1 to 2 do
4041: LD_ADDR_VAR 0 4
4045: PUSH
4046: DOUBLE
4047: LD_INT 1
4049: DEC
4050: ST_TO_ADDR
4051: LD_INT 2
4053: PUSH
4054: FOR_TO
4055: IFFALSE 4145
// begin PrepareHuman ( false , 4 , Difficulty ) ;
4057: LD_INT 0
4059: PPUSH
4060: LD_INT 4
4062: PPUSH
4063: LD_OWVAR 67
4067: PPUSH
4068: CALL_OW 380
// un := CreateHuman ;
4072: LD_ADDR_VAR 0 6
4076: PUSH
4077: CALL_OW 44
4081: ST_TO_ADDR
// ruSci := Replace ( ruSci , ruSci + 1 , un ) ;
4082: LD_ADDR_EXP 39
4086: PUSH
4087: LD_EXP 39
4091: PPUSH
4092: LD_EXP 39
4096: PUSH
4097: LD_INT 1
4099: PLUS
4100: PPUSH
4101: LD_VAR 0 6
4105: PPUSH
4106: CALL_OW 1
4110: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4111: LD_VAR 0 6
4115: PPUSH
4116: LD_VAR 0 5
4120: PUSH
4121: LD_INT 2
4123: ARRAY
4124: PPUSH
4125: LD_VAR 0 5
4129: PUSH
4130: LD_INT 3
4132: ARRAY
4133: PPUSH
4134: CALL_OW 428
4138: PPUSH
4139: CALL_OW 52
// end ;
4143: GO 4054
4145: POP
4146: POP
// end else
4147: GO 4296
// if b [ 1 ] = b_warehouse then
4149: LD_VAR 0 5
4153: PUSH
4154: LD_INT 1
4156: ARRAY
4157: PUSH
4158: LD_INT 1
4160: EQUAL
4161: IFFALSE 4296
// begin for i := 1 to [ 1 , 1 + Difficulty ] [ ( ruEscapeCounter > 3 ) + 1 ] do
4163: LD_ADDR_VAR 0 4
4167: PUSH
4168: DOUBLE
4169: LD_INT 1
4171: DEC
4172: ST_TO_ADDR
4173: LD_INT 1
4175: PUSH
4176: LD_INT 1
4178: PUSH
4179: LD_OWVAR 67
4183: PLUS
4184: PUSH
4185: EMPTY
4186: LIST
4187: LIST
4188: PUSH
4189: LD_EXP 10
4193: PUSH
4194: LD_INT 3
4196: GREATER
4197: PUSH
4198: LD_INT 1
4200: PLUS
4201: ARRAY
4202: PUSH
4203: FOR_TO
4204: IFFALSE 4294
// begin PrepareHuman ( false , 2 , Difficulty ) ;
4206: LD_INT 0
4208: PPUSH
4209: LD_INT 2
4211: PPUSH
4212: LD_OWVAR 67
4216: PPUSH
4217: CALL_OW 380
// un := CreateHuman ;
4221: LD_ADDR_VAR 0 6
4225: PUSH
4226: CALL_OW 44
4230: ST_TO_ADDR
// ruEng := Replace ( ruEng , ruEng + 1 , un ) ;
4231: LD_ADDR_EXP 37
4235: PUSH
4236: LD_EXP 37
4240: PPUSH
4241: LD_EXP 37
4245: PUSH
4246: LD_INT 1
4248: PLUS
4249: PPUSH
4250: LD_VAR 0 6
4254: PPUSH
4255: CALL_OW 1
4259: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4260: LD_VAR 0 6
4264: PPUSH
4265: LD_VAR 0 5
4269: PUSH
4270: LD_INT 2
4272: ARRAY
4273: PPUSH
4274: LD_VAR 0 5
4278: PUSH
4279: LD_INT 3
4281: ARRAY
4282: PPUSH
4283: CALL_OW 428
4287: PPUSH
4288: CALL_OW 52
// end ;
4292: GO 4203
4294: POP
4295: POP
// end ; end ;
4296: GO 3846
4298: POP
4299: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4300: LD_ADDR_VAR 0 3
4304: PUSH
4305: LD_INT 22
4307: PUSH
4308: LD_INT 3
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: PUSH
4315: LD_INT 21
4317: PUSH
4318: LD_INT 3
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PPUSH
4329: CALL_OW 69
4333: ST_TO_ADDR
// for b in blist do
4334: LD_ADDR_VAR 0 5
4338: PUSH
4339: LD_VAR 0 3
4343: PUSH
4344: FOR_IN
4345: IFFALSE 4367
// SetBLevel ( b , 3 + Difficulty ) ;
4347: LD_VAR 0 5
4351: PPUSH
4352: LD_INT 3
4354: PUSH
4355: LD_OWVAR 67
4359: PLUS
4360: PPUSH
4361: CALL_OW 241
4365: GO 4344
4367: POP
4368: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4369: LD_ADDR_VAR 0 3
4373: PUSH
4374: LD_INT 22
4376: PUSH
4377: LD_INT 3
4379: PUSH
4380: EMPTY
4381: LIST
4382: LIST
4383: PUSH
4384: LD_INT 30
4386: PUSH
4387: LD_INT 32
4389: PUSH
4390: EMPTY
4391: LIST
4392: LIST
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PPUSH
4398: CALL_OW 69
4402: ST_TO_ADDR
// for b in blist do
4403: LD_ADDR_VAR 0 5
4407: PUSH
4408: LD_VAR 0 3
4412: PUSH
4413: FOR_IN
4414: IFFALSE 4523
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4416: LD_INT 0
4418: PPUSH
4419: LD_INT 1
4421: PPUSH
4422: LD_INT 1
4424: PUSH
4425: LD_OWVAR 67
4429: PLUS
4430: PPUSH
4431: CALL_OW 380
// un := CreateHuman ;
4435: LD_ADDR_VAR 0 6
4439: PUSH
4440: CALL_OW 44
4444: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4445: LD_ADDR_EXP 36
4449: PUSH
4450: LD_EXP 36
4454: PPUSH
4455: LD_EXP 36
4459: PUSH
4460: LD_INT 1
4462: PLUS
4463: PPUSH
4464: LD_VAR 0 6
4468: PPUSH
4469: CALL_OW 1
4473: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4474: LD_VAR 0 6
4478: PPUSH
4479: LD_VAR 0 5
4483: PPUSH
4484: CALL_OW 52
// PlaceWeaponTurret ( b , [ ru_gun , ru_gatling_gun ] [ b mod 2 + 1 ] ) ;
4488: LD_VAR 0 5
4492: PPUSH
4493: LD_INT 44
4495: PUSH
4496: LD_INT 43
4498: PUSH
4499: EMPTY
4500: LIST
4501: LIST
4502: PUSH
4503: LD_VAR 0 5
4507: PUSH
4508: LD_INT 2
4510: MOD
4511: PUSH
4512: LD_INT 1
4514: PLUS
4515: ARRAY
4516: PPUSH
4517: CALL_OW 431
// end ;
4521: GO 4413
4523: POP
4524: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4525: LD_ADDR_VAR 0 3
4529: PUSH
4530: LD_INT 22
4532: PUSH
4533: LD_INT 3
4535: PUSH
4536: EMPTY
4537: LIST
4538: LIST
4539: PUSH
4540: LD_INT 30
4542: PUSH
4543: LD_INT 31
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: PPUSH
4554: CALL_OW 69
4558: ST_TO_ADDR
// for b in blist do
4559: LD_ADDR_VAR 0 5
4563: PUSH
4564: LD_VAR 0 3
4568: PUSH
4569: FOR_IN
4570: IFFALSE 4669
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4572: LD_INT 0
4574: PPUSH
4575: LD_INT 1
4577: PPUSH
4578: LD_INT 1
4580: PUSH
4581: LD_OWVAR 67
4585: PLUS
4586: PPUSH
4587: CALL_OW 380
// un := CreateHuman ;
4591: LD_ADDR_VAR 0 6
4595: PUSH
4596: CALL_OW 44
4600: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4601: LD_ADDR_EXP 36
4605: PUSH
4606: LD_EXP 36
4610: PPUSH
4611: LD_EXP 36
4615: PUSH
4616: LD_INT 1
4618: PLUS
4619: PPUSH
4620: LD_VAR 0 6
4624: PPUSH
4625: CALL_OW 1
4629: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) + 3 ) ;
4630: LD_VAR 0 6
4634: PPUSH
4635: LD_VAR 0 5
4639: PPUSH
4640: CALL_OW 254
4644: PUSH
4645: LD_INT 3
4647: PLUS
4648: PPUSH
4649: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4653: LD_VAR 0 6
4657: PPUSH
4658: LD_VAR 0 5
4662: PPUSH
4663: CALL_OW 52
// end ;
4667: GO 4569
4669: POP
4670: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4671: LD_ADDR_VAR 0 3
4675: PUSH
4676: LD_INT 22
4678: PUSH
4679: LD_INT 3
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 2
4688: PUSH
4689: LD_INT 30
4691: PUSH
4692: LD_INT 4
4694: PUSH
4695: EMPTY
4696: LIST
4697: LIST
4698: PUSH
4699: LD_INT 30
4701: PUSH
4702: LD_INT 5
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PUSH
4709: EMPTY
4710: LIST
4711: LIST
4712: LIST
4713: PUSH
4714: EMPTY
4715: LIST
4716: LIST
4717: PPUSH
4718: CALL_OW 69
4722: ST_TO_ADDR
// for b in blist do
4723: LD_ADDR_VAR 0 5
4727: PUSH
4728: LD_VAR 0 3
4732: PUSH
4733: FOR_IN
4734: IFFALSE 4830
// begin for i := 1 to 2 do
4736: LD_ADDR_VAR 0 4
4740: PUSH
4741: DOUBLE
4742: LD_INT 1
4744: DEC
4745: ST_TO_ADDR
4746: LD_INT 2
4748: PUSH
4749: FOR_TO
4750: IFFALSE 4826
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4752: LD_INT 0
4754: PPUSH
4755: LD_INT 1
4757: PPUSH
4758: LD_INT 1
4760: PUSH
4761: LD_OWVAR 67
4765: PLUS
4766: PPUSH
4767: CALL_OW 380
// un := CreateHuman ;
4771: LD_ADDR_VAR 0 6
4775: PUSH
4776: CALL_OW 44
4780: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4781: LD_ADDR_EXP 36
4785: PUSH
4786: LD_EXP 36
4790: PPUSH
4791: LD_EXP 36
4795: PUSH
4796: LD_INT 1
4798: PLUS
4799: PPUSH
4800: LD_VAR 0 6
4804: PPUSH
4805: CALL_OW 1
4809: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4810: LD_VAR 0 6
4814: PPUSH
4815: LD_VAR 0 5
4819: PPUSH
4820: CALL_OW 52
// end ;
4824: GO 4749
4826: POP
4827: POP
// end ;
4828: GO 4733
4830: POP
4831: POP
// if ibrahimOnRuSide then
4832: LD_EXP 3
4836: IFFALSE 4934
// begin Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
4838: LD_ADDR_EXP 21
4842: PUSH
4843: LD_STRING IbrahimRu
4845: PPUSH
4846: LD_INT 0
4848: PPUSH
4849: LD_STRING 
4851: PPUSH
4852: CALL 336 0 3
4856: ST_TO_ADDR
// PlaceUnitXY ( Ibrahim , 121 , 78 , false ) ;
4857: LD_EXP 21
4861: PPUSH
4862: LD_INT 121
4864: PPUSH
4865: LD_INT 78
4867: PPUSH
4868: LD_INT 0
4870: PPUSH
4871: CALL_OW 48
// ComHold ( Ibrahim ) ;
4875: LD_EXP 21
4879: PPUSH
4880: CALL_OW 140
// PrepareHuman ( sex_male , 1 , 2 ) ;
4884: LD_INT 1
4886: PPUSH
4887: LD_INT 1
4889: PPUSH
4890: LD_INT 2
4892: PPUSH
4893: CALL_OW 380
// ruSol := CreateHuman ;
4897: LD_ADDR_EXP 41
4901: PUSH
4902: CALL_OW 44
4906: ST_TO_ADDR
// PlaceUnitXY ( ruSol , 121 , 75 , false ) ;
4907: LD_EXP 41
4911: PPUSH
4912: LD_INT 121
4914: PPUSH
4915: LD_INT 75
4917: PPUSH
4918: LD_INT 0
4920: PPUSH
4921: CALL_OW 48
// ComHold ( ruSol ) ;
4925: LD_EXP 41
4929: PPUSH
4930: CALL_OW 140
// end ; for i := 1 to [ 2 , 2 + Difficulty ] [ ( ruEscapeCounter > 3 ) + 1 ] do
4934: LD_ADDR_VAR 0 4
4938: PUSH
4939: DOUBLE
4940: LD_INT 1
4942: DEC
4943: ST_TO_ADDR
4944: LD_INT 2
4946: PUSH
4947: LD_INT 2
4949: PUSH
4950: LD_OWVAR 67
4954: PLUS
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: PUSH
4960: LD_EXP 10
4964: PUSH
4965: LD_INT 3
4967: GREATER
4968: PUSH
4969: LD_INT 1
4971: PLUS
4972: ARRAY
4973: PUSH
4974: FOR_TO
4975: IFFALSE 5044
// AddComConstruct ( fac , [ ru_medium_wheeled , ru_heavy_wheeled , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] ) ;
4977: LD_VAR 0 8
4981: PPUSH
4982: LD_INT 21
4984: PUSH
4985: LD_INT 23
4987: PUSH
4988: LD_INT 24
4990: PUSH
4991: EMPTY
4992: LIST
4993: LIST
4994: LIST
4995: PUSH
4996: LD_VAR 0 4
5000: PUSH
5001: LD_INT 3
5003: MOD
5004: PUSH
5005: LD_INT 1
5007: PLUS
5008: ARRAY
5009: PPUSH
5010: LD_INT 1
5012: PPUSH
5013: LD_INT 1
5015: PPUSH
5016: LD_INT 43
5018: PUSH
5019: LD_INT 44
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PUSH
5026: LD_INT 1
5028: PPUSH
5029: LD_INT 2
5031: PPUSH
5032: CALL_OW 12
5036: ARRAY
5037: PPUSH
5038: CALL_OW 185
5042: GO 4974
5044: POP
5045: POP
// end ;
5046: LD_VAR 0 1
5050: RET
// every 0 0$1 trigger ruMobile and not ruEscapeAllowed do var i , filter , tmp , enemy , x ;
5051: LD_EXP 40
5055: PUSH
5056: LD_EXP 4
5060: NOT
5061: AND
5062: IFFALSE 5549
5064: GO 5066
5066: DISABLE
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
5072: PPUSH
5073: PPUSH
// begin enable ;
5074: ENABLE
// filter := UnitFilter ( ruMobile , [ f_type , unit_vehicle ] ) ;
5075: LD_ADDR_VAR 0 2
5079: PUSH
5080: LD_EXP 40
5084: PPUSH
5085: LD_INT 21
5087: PUSH
5088: LD_INT 2
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PPUSH
5095: CALL_OW 72
5099: ST_TO_ADDR
// enemy := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_or , [ f_inarea , zone1 ] , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) ;
5100: LD_ADDR_VAR 0 4
5104: PUSH
5105: LD_INT 81
5107: PUSH
5108: LD_INT 3
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: PUSH
5115: LD_INT 2
5117: PUSH
5118: LD_INT 95
5120: PUSH
5121: LD_INT 4
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PUSH
5128: LD_INT 95
5130: PUSH
5131: LD_INT 5
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PUSH
5138: LD_INT 95
5140: PUSH
5141: LD_INT 6
5143: PUSH
5144: EMPTY
5145: LIST
5146: LIST
5147: PUSH
5148: LD_INT 95
5150: PUSH
5151: LD_INT 7
5153: PUSH
5154: EMPTY
5155: LIST
5156: LIST
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: LIST
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PPUSH
5169: CALL_OW 69
5173: ST_TO_ADDR
// for i in filter do
5174: LD_ADDR_VAR 0 1
5178: PUSH
5179: LD_VAR 0 2
5183: PUSH
5184: FOR_IN
5185: IFFALSE 5547
// begin tmp := IsDrivenBy ( i ) ;
5187: LD_ADDR_VAR 0 3
5191: PUSH
5192: LD_VAR 0 1
5196: PPUSH
5197: CALL_OW 311
5201: ST_TO_ADDR
// if not tmp then
5202: LD_VAR 0 3
5206: NOT
5207: IFFALSE 5211
// continue ;
5209: GO 5184
// if GetFuel ( i ) > 90 and GetTag ( i ) = 2 then
5211: LD_VAR 0 1
5215: PPUSH
5216: CALL_OW 261
5220: PUSH
5221: LD_INT 90
5223: GREATER
5224: PUSH
5225: LD_VAR 0 1
5229: PPUSH
5230: CALL_OW 110
5234: PUSH
5235: LD_INT 2
5237: EQUAL
5238: AND
5239: IFFALSE 5255
// SetTag ( i , 0 ) else
5241: LD_VAR 0 1
5245: PPUSH
5246: LD_INT 0
5248: PPUSH
5249: CALL_OW 109
5253: GO 5298
// if GetTag ( i ) = 2 then
5255: LD_VAR 0 1
5259: PPUSH
5260: CALL_OW 110
5264: PUSH
5265: LD_INT 2
5267: EQUAL
5268: IFFALSE 5298
// begin x := rand ( 1 , 2 ) ;
5270: LD_ADDR_VAR 0 5
5274: PUSH
5275: LD_INT 1
5277: PPUSH
5278: LD_INT 2
5280: PPUSH
5281: CALL_OW 12
5285: ST_TO_ADDR
// AddComMoveUnit ( i , ruMainBase ) ;
5286: LD_VAR 0 1
5290: PPUSH
5291: LD_INT 200
5293: PPUSH
5294: CALL_OW 172
// end ; if GetLives ( i ) >= 600 and not GetTag ( i ) then
5298: LD_VAR 0 1
5302: PPUSH
5303: CALL_OW 256
5307: PUSH
5308: LD_INT 600
5310: GREATEREQUAL
5311: PUSH
5312: LD_VAR 0 1
5316: PPUSH
5317: CALL_OW 110
5321: NOT
5322: AND
5323: IFFALSE 5349
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
5325: LD_VAR 0 1
5329: PPUSH
5330: LD_VAR 0 4
5334: PPUSH
5335: LD_VAR 0 1
5339: PPUSH
5340: CALL_OW 74
5344: PPUSH
5345: CALL_OW 115
// if GetLives ( i ) < 600 and not GetTag ( i ) then
5349: LD_VAR 0 1
5353: PPUSH
5354: CALL_OW 256
5358: PUSH
5359: LD_INT 600
5361: LESS
5362: PUSH
5363: LD_VAR 0 1
5367: PPUSH
5368: CALL_OW 110
5372: NOT
5373: AND
5374: IFFALSE 5403
// begin SetTag ( i , 1 ) ;
5376: LD_VAR 0 1
5380: PPUSH
5381: LD_INT 1
5383: PPUSH
5384: CALL_OW 109
// ComMoveXY ( i , 112 , 119 ) ;
5388: LD_VAR 0 1
5392: PPUSH
5393: LD_INT 112
5395: PPUSH
5396: LD_INT 119
5398: PPUSH
5399: CALL_OW 111
// end ; if GetTag ( i ) = 1 and GetDistUnitXY ( i , 112 , 119 ) < 9 and tmp then
5403: LD_VAR 0 1
5407: PPUSH
5408: CALL_OW 110
5412: PUSH
5413: LD_INT 1
5415: EQUAL
5416: PUSH
5417: LD_VAR 0 1
5421: PPUSH
5422: LD_INT 112
5424: PPUSH
5425: LD_INT 119
5427: PPUSH
5428: CALL_OW 297
5432: PUSH
5433: LD_INT 9
5435: LESS
5436: AND
5437: PUSH
5438: LD_VAR 0 3
5442: AND
5443: IFFALSE 5545
// begin ComExitVehicle ( tmp ) ;
5445: LD_VAR 0 3
5449: PPUSH
5450: CALL_OW 121
// AddComRepairVehicle ( tmp , i ) ;
5454: LD_VAR 0 3
5458: PPUSH
5459: LD_VAR 0 1
5463: PPUSH
5464: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
5468: LD_INT 35
5470: PPUSH
5471: CALL_OW 67
// until GetLives ( i ) = 1000 ;
5475: LD_VAR 0 1
5479: PPUSH
5480: CALL_OW 256
5484: PUSH
5485: LD_INT 1000
5487: EQUAL
5488: IFFALSE 5468
// ComEnterUnit ( tmp , i ) ;
5490: LD_VAR 0 3
5494: PPUSH
5495: LD_VAR 0 1
5499: PPUSH
5500: CALL_OW 120
// if GetFuel ( i ) <= 50 then
5504: LD_VAR 0 1
5508: PPUSH
5509: CALL_OW 261
5513: PUSH
5514: LD_INT 50
5516: LESSEQUAL
5517: IFFALSE 5533
// SetTag ( i , 2 ) else
5519: LD_VAR 0 1
5523: PPUSH
5524: LD_INT 2
5526: PPUSH
5527: CALL_OW 109
5531: GO 5545
// SetTag ( i , 0 ) ;
5533: LD_VAR 0 1
5537: PPUSH
5538: LD_INT 0
5540: PPUSH
5541: CALL_OW 109
// end ; end ;
5545: GO 5184
5547: POP
5548: POP
// end ;
5549: PPOPN 5
5551: END
// every 0 0$1 trigger not ruEscapeAllowed and ruEng do var i , filter , tmp , enemy ;
5552: LD_EXP 4
5556: NOT
5557: PUSH
5558: LD_EXP 37
5562: AND
5563: IFFALSE 5824
5565: GO 5567
5567: DISABLE
5568: LD_INT 0
5570: PPUSH
5571: PPUSH
5572: PPUSH
5573: PPUSH
// begin enable ;
5574: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5575: LD_ADDR_VAR 0 2
5579: PUSH
5580: LD_INT 3
5582: PPUSH
5583: LD_INT 22
5585: PUSH
5586: LD_INT 3
5588: PUSH
5589: EMPTY
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 21
5595: PUSH
5596: LD_INT 3
5598: PUSH
5599: EMPTY
5600: LIST
5601: LIST
5602: PUSH
5603: LD_INT 3
5605: PUSH
5606: LD_INT 24
5608: PUSH
5609: LD_INT 1000
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: LIST
5624: PPUSH
5625: CALL_OW 70
5629: ST_TO_ADDR
// tmp := UnitFilter ( ruEng , [ f_ok ] ) ;
5630: LD_ADDR_VAR 0 3
5634: PUSH
5635: LD_EXP 37
5639: PPUSH
5640: LD_INT 50
5642: PUSH
5643: EMPTY
5644: LIST
5645: PPUSH
5646: CALL_OW 72
5650: ST_TO_ADDR
// if filter and tmp then
5651: LD_VAR 0 2
5655: PUSH
5656: LD_VAR 0 3
5660: AND
5661: IFFALSE 5753
// begin for i in tmp do
5663: LD_ADDR_VAR 0 1
5667: PUSH
5668: LD_VAR 0 3
5672: PUSH
5673: FOR_IN
5674: IFFALSE 5749
// begin if GetTag ( i ) = tEscape then
5676: LD_VAR 0 1
5680: PPUSH
5681: CALL_OW 110
5685: PUSH
5686: LD_EXP 17
5690: EQUAL
5691: IFFALSE 5695
// continue ;
5693: GO 5673
// if IsInUnit ( i ) then
5695: LD_VAR 0 1
5699: PPUSH
5700: CALL_OW 310
5704: IFFALSE 5717
// ComExitBuilding ( i ) else
5706: LD_VAR 0 1
5710: PPUSH
5711: CALL_OW 122
5715: GO 5747
// if not HasTask ( i ) then
5717: LD_VAR 0 1
5721: PPUSH
5722: CALL_OW 314
5726: NOT
5727: IFFALSE 5747
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5729: LD_VAR 0 1
5733: PPUSH
5734: LD_VAR 0 2
5738: PUSH
5739: LD_INT 1
5741: ARRAY
5742: PPUSH
5743: CALL_OW 130
// end ;
5747: GO 5673
5749: POP
5750: POP
// end else
5751: GO 5824
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5753: LD_VAR 0 3
5757: PPUSH
5758: LD_INT 3
5760: PUSH
5761: LD_INT 54
5763: PUSH
5764: EMPTY
5765: LIST
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PPUSH
5771: CALL_OW 72
5775: IFFALSE 5824
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5777: LD_ADDR_VAR 0 1
5781: PUSH
5782: LD_VAR 0 3
5786: PPUSH
5787: LD_INT 3
5789: PUSH
5790: LD_INT 54
5792: PUSH
5793: EMPTY
5794: LIST
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: PPUSH
5800: CALL_OW 72
5804: PUSH
5805: FOR_IN
5806: IFFALSE 5822
// ComEnterUnit ( i , ruMainBase ) ;
5808: LD_VAR 0 1
5812: PPUSH
5813: LD_INT 200
5815: PPUSH
5816: CALL_OW 120
5820: GO 5805
5822: POP
5823: POP
// end ; end ;
5824: PPOPN 4
5826: END
// every 0 0$1 trigger not ruEscapeAllowed and ruSci do var i , filter , tmp , lab ;
5827: LD_EXP 4
5831: NOT
5832: PUSH
5833: LD_EXP 39
5837: AND
5838: IFFALSE 6117
5840: GO 5842
5842: DISABLE
5843: LD_INT 0
5845: PPUSH
5846: PPUSH
5847: PPUSH
5848: PPUSH
// begin enable ;
5849: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5850: LD_ADDR_VAR 0 2
5854: PUSH
5855: LD_INT 3
5857: PPUSH
5858: LD_INT 22
5860: PUSH
5861: LD_INT 3
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 21
5870: PUSH
5871: LD_INT 1
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 3
5880: PUSH
5881: LD_INT 24
5883: PUSH
5884: LD_INT 1000
5886: PUSH
5887: EMPTY
5888: LIST
5889: LIST
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: LIST
5899: PPUSH
5900: CALL_OW 70
5904: ST_TO_ADDR
// tmp := UnitFilter ( ruSci , [ f_ok ] ) ;
5905: LD_ADDR_VAR 0 3
5909: PUSH
5910: LD_EXP 39
5914: PPUSH
5915: LD_INT 50
5917: PUSH
5918: EMPTY
5919: LIST
5920: PPUSH
5921: CALL_OW 72
5925: ST_TO_ADDR
// lab := HexInfo ( 118 , 121 ) ;
5926: LD_ADDR_VAR 0 4
5930: PUSH
5931: LD_INT 118
5933: PPUSH
5934: LD_INT 121
5936: PPUSH
5937: CALL_OW 428
5941: ST_TO_ADDR
// if filter and tmp then
5942: LD_VAR 0 2
5946: PUSH
5947: LD_VAR 0 3
5951: AND
5952: IFFALSE 6044
// begin for i in tmp do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: LD_VAR 0 3
5963: PUSH
5964: FOR_IN
5965: IFFALSE 6040
// begin if GetTag ( i ) = tEscape then
5967: LD_VAR 0 1
5971: PPUSH
5972: CALL_OW 110
5976: PUSH
5977: LD_EXP 17
5981: EQUAL
5982: IFFALSE 5986
// continue ;
5984: GO 5964
// if IsInUnit ( i ) then
5986: LD_VAR 0 1
5990: PPUSH
5991: CALL_OW 310
5995: IFFALSE 6008
// ComExitBuilding ( i ) else
5997: LD_VAR 0 1
6001: PPUSH
6002: CALL_OW 122
6006: GO 6038
// if not HasTask ( i ) then
6008: LD_VAR 0 1
6012: PPUSH
6013: CALL_OW 314
6017: NOT
6018: IFFALSE 6038
// ComHeal ( i , filter [ 1 ] ) ;
6020: LD_VAR 0 1
6024: PPUSH
6025: LD_VAR 0 2
6029: PUSH
6030: LD_INT 1
6032: ARRAY
6033: PPUSH
6034: CALL_OW 128
// end ;
6038: GO 5964
6040: POP
6041: POP
// end else
6042: GO 6117
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
6044: LD_VAR 0 3
6048: PPUSH
6049: LD_INT 3
6051: PUSH
6052: LD_INT 54
6054: PUSH
6055: EMPTY
6056: LIST
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PPUSH
6062: CALL_OW 72
6066: IFFALSE 6117
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
6068: LD_ADDR_VAR 0 1
6072: PUSH
6073: LD_VAR 0 3
6077: PPUSH
6078: LD_INT 3
6080: PUSH
6081: LD_INT 54
6083: PUSH
6084: EMPTY
6085: LIST
6086: PUSH
6087: EMPTY
6088: LIST
6089: LIST
6090: PPUSH
6091: CALL_OW 72
6095: PUSH
6096: FOR_IN
6097: IFFALSE 6115
// ComEnterUnit ( i , lab ) ;
6099: LD_VAR 0 1
6103: PPUSH
6104: LD_VAR 0 4
6108: PPUSH
6109: CALL_OW 120
6113: GO 6096
6115: POP
6116: POP
// end ; end ; end_of_file
6117: PPOPN 4
6119: END
// on UnitDestroyed ( un ) do begin if un = Heike then
6120: LD_VAR 0 1
6124: PUSH
6125: LD_EXP 18
6129: EQUAL
6130: IFFALSE 6139
// YouLost ( Heike ) ;
6132: LD_STRING Heike
6134: PPUSH
6135: CALL_OW 104
// if un in ruEng then
6139: LD_VAR 0 1
6143: PUSH
6144: LD_EXP 37
6148: IN
6149: IFFALSE 6167
// ruEng := ruEng diff un ;
6151: LD_ADDR_EXP 37
6155: PUSH
6156: LD_EXP 37
6160: PUSH
6161: LD_VAR 0 1
6165: DIFF
6166: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) then
6167: LD_VAR 0 1
6171: PUSH
6172: LD_INT 22
6174: PUSH
6175: LD_INT 2
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PUSH
6182: LD_INT 21
6184: PUSH
6185: LD_INT 1
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 23
6194: PUSH
6195: LD_INT 2
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: PUSH
6202: EMPTY
6203: LIST
6204: LIST
6205: LIST
6206: PPUSH
6207: CALL_OW 69
6211: IN
6212: IFFALSE 6228
// loseCounter := loseCounter + 1 ;
6214: LD_ADDR_EXP 6
6218: PUSH
6219: LD_EXP 6
6223: PUSH
6224: LD_INT 1
6226: PLUS
6227: ST_TO_ADDR
// end ;
6228: PPOPN 1
6230: END
// on EvacuateVehicle ( driver , un , p1 , p2 ) do var weapon , fac ;
6231: LD_INT 0
6233: PPUSH
6234: PPUSH
// begin if un in ruMobile then
6235: LD_VAR 0 2
6239: PUSH
6240: LD_EXP 40
6244: IN
6245: IFFALSE 6404
// begin ruMobile := ruMobile diff un ;
6247: LD_ADDR_EXP 40
6251: PUSH
6252: LD_EXP 40
6256: PUSH
6257: LD_VAR 0 2
6261: DIFF
6262: ST_TO_ADDR
// weapon := GetWeapon ( un ) ;
6263: LD_ADDR_VAR 0 5
6267: PUSH
6268: LD_VAR 0 2
6272: PPUSH
6273: CALL_OW 264
6277: ST_TO_ADDR
// fac := HexInfo ( 110 , 126 ) ;
6278: LD_ADDR_VAR 0 6
6282: PUSH
6283: LD_INT 110
6285: PPUSH
6286: LD_INT 126
6288: PPUSH
6289: CALL_OW 428
6293: ST_TO_ADDR
// if not driver or not fac then
6294: LD_VAR 0 1
6298: NOT
6299: PUSH
6300: LD_VAR 0 6
6304: NOT
6305: OR
6306: IFFALSE 6310
// exit ;
6308: GO 6404
// AddComMoveXY ( driver , 111 , 121 ) ;
6310: LD_VAR 0 1
6314: PPUSH
6315: LD_INT 111
6317: PPUSH
6318: LD_INT 121
6320: PPUSH
6321: CALL_OW 171
// AddComEnterUnit ( driver , fac ) ;
6325: LD_VAR 0 1
6329: PPUSH
6330: LD_VAR 0 6
6334: PPUSH
6335: CALL_OW 180
// repeat wait ( 0 0$1 ) ;
6339: LD_INT 35
6341: PPUSH
6342: CALL_OW 67
// until IsDead ( driver ) or IsInUnit ( driver ) ;
6346: LD_VAR 0 1
6350: PPUSH
6351: CALL_OW 301
6355: PUSH
6356: LD_VAR 0 1
6360: PPUSH
6361: CALL_OW 310
6365: OR
6366: IFFALSE 6339
// if IsDead ( driver ) then
6368: LD_VAR 0 1
6372: PPUSH
6373: CALL_OW 301
6377: IFFALSE 6381
// exit ;
6379: GO 6404
// AddComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_manual , weapon ) ;
6381: LD_VAR 0 6
6385: PPUSH
6386: LD_INT 21
6388: PPUSH
6389: LD_INT 1
6391: PPUSH
6392: LD_INT 1
6394: PPUSH
6395: LD_VAR 0 5
6399: PPUSH
6400: CALL_OW 185
// end ; end ;
6404: PPOPN 6
6406: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 3 then
6407: LD_VAR 0 2
6411: PPUSH
6412: CALL_OW 255
6416: PUSH
6417: LD_INT 3
6419: EQUAL
6420: IFFALSE 6466
// begin ruMobile := Replace ( ruMobile , ruMobile + 1 , veh ) ;
6422: LD_ADDR_EXP 40
6426: PUSH
6427: LD_EXP 40
6431: PPUSH
6432: LD_EXP 40
6436: PUSH
6437: LD_INT 1
6439: PLUS
6440: PPUSH
6441: LD_VAR 0 1
6445: PPUSH
6446: CALL_OW 1
6450: ST_TO_ADDR
// AddComMoveXY ( veh , 110 , 117 ) ;
6451: LD_VAR 0 1
6455: PPUSH
6456: LD_INT 110
6458: PPUSH
6459: LD_INT 117
6461: PPUSH
6462: CALL_OW 171
// end ; end ;
6466: PPOPN 2
6468: END
// on LeaveBuilding ( b , un ) do var barracks ;
6469: LD_INT 0
6471: PPUSH
// begin if b in [ HexInfo ( 130 , 17 ) , HexInfo ( 138 , 22 ) , HexInfo ( 123 , 17 ) ] then
6472: LD_VAR 0 1
6476: PUSH
6477: LD_INT 130
6479: PPUSH
6480: LD_INT 17
6482: PPUSH
6483: CALL_OW 428
6487: PUSH
6488: LD_INT 138
6490: PPUSH
6491: LD_INT 22
6493: PPUSH
6494: CALL_OW 428
6498: PUSH
6499: LD_INT 123
6501: PPUSH
6502: LD_INT 17
6504: PPUSH
6505: CALL_OW 428
6509: PUSH
6510: EMPTY
6511: LIST
6512: LIST
6513: LIST
6514: IN
6515: IFFALSE 6539
// begin AddComEnterUnit ( un , HexInfo ( 135 , 31 ) ) ;
6517: LD_VAR 0 2
6521: PPUSH
6522: LD_INT 135
6524: PPUSH
6525: LD_INT 31
6527: PPUSH
6528: CALL_OW 428
6532: PPUSH
6533: CALL_OW 180
// exit ;
6537: GO 6813
// end ; if b = HexInfo ( 135 , 31 ) then
6539: LD_VAR 0 1
6543: PUSH
6544: LD_INT 135
6546: PPUSH
6547: LD_INT 31
6549: PPUSH
6550: CALL_OW 428
6554: EQUAL
6555: IFFALSE 6627
// begin AddComEnterUnit ( un , HexInfo ( 106 , 51 ) ) ;
6557: LD_VAR 0 2
6561: PPUSH
6562: LD_INT 106
6564: PPUSH
6565: LD_INT 51
6567: PPUSH
6568: CALL_OW 428
6572: PPUSH
6573: CALL_OW 180
// if not explodeFirstDepot then
6577: LD_EXP 12
6581: NOT
6582: IFFALSE 6625
// begin explodeFirstDepot := true ;
6584: LD_ADDR_EXP 12
6588: PUSH
6589: LD_INT 1
6591: ST_TO_ADDR
// wait ( 0 0$15 ) ;
6592: LD_INT 525
6594: PPUSH
6595: CALL_OW 67
// MineExplosion ( 127 , 27 , 1 ) ;
6599: LD_INT 127
6601: PPUSH
6602: LD_INT 27
6604: PPUSH
6605: LD_INT 1
6607: PPUSH
6608: CALL_OW 453
// MineExplosion ( 125 , 29 , 1 ) ;
6612: LD_INT 125
6614: PPUSH
6615: LD_INT 29
6617: PPUSH
6618: LD_INT 1
6620: PPUSH
6621: CALL_OW 453
// end ; exit ;
6625: GO 6813
// end ; if b = HexInfo ( 106 , 51 ) then
6627: LD_VAR 0 1
6631: PUSH
6632: LD_INT 106
6634: PPUSH
6635: LD_INT 51
6637: PPUSH
6638: CALL_OW 428
6642: EQUAL
6643: IFFALSE 6743
// begin AddComMoveXY ( un , 106 , 93 ) ;
6645: LD_VAR 0 2
6649: PPUSH
6650: LD_INT 106
6652: PPUSH
6653: LD_INT 93
6655: PPUSH
6656: CALL_OW 171
// if not explodeSecondDepot then
6660: LD_EXP 13
6664: NOT
6665: IFFALSE 6741
// begin explodeSecondDepot := true ;
6667: LD_ADDR_EXP 13
6671: PUSH
6672: LD_INT 1
6674: ST_TO_ADDR
// wait ( 0 0$12 ) ;
6675: LD_INT 420
6677: PPUSH
6678: CALL_OW 67
// MineExplosion ( 111 , 75 , 1 ) ;
6682: LD_INT 111
6684: PPUSH
6685: LD_INT 75
6687: PPUSH
6688: LD_INT 1
6690: PPUSH
6691: CALL_OW 453
// MineExplosion ( 111 , 75 , 1 ) ;
6695: LD_INT 111
6697: PPUSH
6698: LD_INT 75
6700: PPUSH
6701: LD_INT 1
6703: PPUSH
6704: CALL_OW 453
// MineExplosion ( 108 , 69 , 1 ) ;
6708: LD_INT 108
6710: PPUSH
6711: LD_INT 69
6713: PPUSH
6714: LD_INT 1
6716: PPUSH
6717: CALL_OW 453
// wait ( 0 0$2 ) ;
6721: LD_INT 70
6723: PPUSH
6724: CALL_OW 67
// MineExplosion ( 94 , 65 , 1 ) ;
6728: LD_INT 94
6730: PPUSH
6731: LD_INT 65
6733: PPUSH
6734: LD_INT 1
6736: PPUSH
6737: CALL_OW 453
// end ; exit ;
6741: GO 6813
// end ; if GetBType ( b ) = b_bunker then
6743: LD_VAR 0 1
6747: PPUSH
6748: CALL_OW 266
6752: PUSH
6753: LD_INT 32
6755: EQUAL
6756: IFFALSE 6813
// begin barracks := NearestEmptyBuilding ( un , b_barracks ) ;
6758: LD_ADDR_VAR 0 3
6762: PUSH
6763: LD_VAR 0 2
6767: PPUSH
6768: LD_INT 5
6770: PPUSH
6771: CALL 2403 0 2
6775: ST_TO_ADDR
// if barracks then
6776: LD_VAR 0 3
6780: IFFALSE 6798
// AddComEnterUnit ( un , barracks ) else
6782: LD_VAR 0 2
6786: PPUSH
6787: LD_VAR 0 3
6791: PPUSH
6792: CALL_OW 180
6796: GO 6813
// AddComMoveXY ( un , 116 , 110 ) ;
6798: LD_VAR 0 2
6802: PPUSH
6803: LD_INT 116
6805: PPUSH
6806: LD_INT 110
6808: PPUSH
6809: CALL_OW 171
// end ; end ;
6813: PPOPN 3
6815: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un = Kaia and killerSide in [ 3 , 6 ] then
6816: LD_VAR 0 1
6820: PUSH
6821: LD_EXP 23
6825: EQUAL
6826: PUSH
6827: LD_VAR 0 2
6831: PUSH
6832: LD_INT 3
6834: PUSH
6835: LD_INT 6
6837: PUSH
6838: EMPTY
6839: LIST
6840: LIST
6841: IN
6842: AND
6843: IFFALSE 6874
// kaiaKilledByRussian := [ GetX ( un ) , GetY ( un ) ] ;
6845: LD_ADDR_EXP 8
6849: PUSH
6850: LD_VAR 0 1
6854: PPUSH
6855: CALL_OW 250
6859: PUSH
6860: LD_VAR 0 1
6864: PPUSH
6865: CALL_OW 251
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: ST_TO_ADDR
// end ; end_of_file
6874: PPOPN 3
6876: END
// export function Action ; var i , un , veh , tmp , rutmp ; begin
6877: LD_INT 0
6879: PPUSH
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
6884: PPUSH
// InGameOn ;
6885: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6889: LD_INT 5
6891: PPUSH
6892: LD_INT 2
6894: PPUSH
6895: CALL_OW 343
// music_nat := 4 ;
6899: LD_ADDR_OWVAR 71
6903: PUSH
6904: LD_INT 4
6906: ST_TO_ADDR
// music_class := music_combat ;
6907: LD_ADDR_OWVAR 72
6911: PUSH
6912: LD_INT 1
6914: ST_TO_ADDR
// PlaceSeeing ( 133 , 2 , 2 , 10 ) ;
6915: LD_INT 133
6917: PPUSH
6918: LD_INT 2
6920: PPUSH
6921: LD_INT 2
6923: PPUSH
6924: LD_INT 10
6926: PPUSH
6927: CALL_OW 330
// CenterNowOnXY ( 133 , 2 ) ;
6931: LD_INT 133
6933: PPUSH
6934: LD_INT 2
6936: PPUSH
6937: CALL_OW 86
// wait ( 0 0$1 ) ;
6941: LD_INT 35
6943: PPUSH
6944: CALL_OW 67
// uc_side := 6 ;
6948: LD_ADDR_OWVAR 20
6952: PUSH
6953: LD_INT 6
6955: ST_TO_ADDR
// uc_nation := 3 ;
6956: LD_ADDR_OWVAR 21
6960: PUSH
6961: LD_INT 3
6963: ST_TO_ADDR
// rutmp := [ ] ;
6964: LD_ADDR_VAR 0 6
6968: PUSH
6969: EMPTY
6970: ST_TO_ADDR
// PrepareTank ( 6 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_gun , 66 ) ;
6971: LD_INT 6
6973: PPUSH
6974: LD_INT 3
6976: PPUSH
6977: LD_INT 21
6979: PPUSH
6980: LD_INT 1
6982: PPUSH
6983: LD_INT 1
6985: PPUSH
6986: LD_INT 44
6988: PPUSH
6989: LD_INT 66
6991: PPUSH
6992: CALL 399 0 7
// veh := CreateVehicle ;
6996: LD_ADDR_VAR 0 4
7000: PUSH
7001: CALL_OW 45
7005: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
7006: LD_VAR 0 4
7010: PPUSH
7011: LD_INT 3
7013: PPUSH
7014: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7018: LD_VAR 0 4
7022: PPUSH
7023: LD_INT 8
7025: PPUSH
7026: LD_INT 0
7028: PPUSH
7029: CALL_OW 49
// SetLives ( veh , 500 ) ;
7033: LD_VAR 0 4
7037: PPUSH
7038: LD_INT 500
7040: PPUSH
7041: CALL_OW 234
// PrepareHuman ( false , 3 , 3 ) ;
7045: LD_INT 0
7047: PPUSH
7048: LD_INT 3
7050: PPUSH
7051: LD_INT 3
7053: PPUSH
7054: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7058: CALL_OW 44
7062: PPUSH
7063: LD_VAR 0 4
7067: PPUSH
7068: CALL_OW 52
// ComMoveXY ( veh , 133 , 11 ) ;
7072: LD_VAR 0 4
7076: PPUSH
7077: LD_INT 133
7079: PPUSH
7080: LD_INT 11
7082: PPUSH
7083: CALL_OW 111
// rutmp := [ veh ] ;
7087: LD_ADDR_VAR 0 6
7091: PUSH
7092: LD_VAR 0 4
7096: PUSH
7097: EMPTY
7098: LIST
7099: ST_TO_ADDR
// for i := 1 to 4 do
7100: LD_ADDR_VAR 0 2
7104: PUSH
7105: DOUBLE
7106: LD_INT 1
7108: DEC
7109: ST_TO_ADDR
7110: LD_INT 4
7112: PUSH
7113: FOR_TO
7114: IFFALSE 7221
// begin PrepareHuman ( false , i , 2 ) ;
7116: LD_INT 0
7118: PPUSH
7119: LD_VAR 0 2
7123: PPUSH
7124: LD_INT 2
7126: PPUSH
7127: CALL_OW 380
// un := CreateHuman ;
7131: LD_ADDR_VAR 0 3
7135: PUSH
7136: CALL_OW 44
7140: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7141: LD_VAR 0 3
7145: PPUSH
7146: LD_INT 3
7148: PPUSH
7149: CALL_OW 233
// PlaceUnitArea ( un , spawnArea , false ) ;
7153: LD_VAR 0 3
7157: PPUSH
7158: LD_INT 8
7160: PPUSH
7161: LD_INT 0
7163: PPUSH
7164: CALL_OW 49
// rutmp := Replace ( rutmp , rutmp + 1 , un ) ;
7168: LD_ADDR_VAR 0 6
7172: PUSH
7173: LD_VAR 0 6
7177: PPUSH
7178: LD_VAR 0 6
7182: PUSH
7183: LD_INT 1
7185: PLUS
7186: PPUSH
7187: LD_VAR 0 3
7191: PPUSH
7192: CALL_OW 1
7196: ST_TO_ADDR
// ComMoveXY ( un , 133 , 11 ) ;
7197: LD_VAR 0 3
7201: PPUSH
7202: LD_INT 133
7204: PPUSH
7205: LD_INT 11
7207: PPUSH
7208: CALL_OW 111
// wait ( 0 0$0.5 ) ;
7212: LD_INT 18
7214: PPUSH
7215: CALL_OW 67
// end ;
7219: GO 7113
7221: POP
7222: POP
// for i in rutmp do
7223: LD_ADDR_VAR 0 2
7227: PUSH
7228: LD_VAR 0 6
7232: PUSH
7233: FOR_IN
7234: IFFALSE 7283
// begin AddComMoveXY ( i , 99 , 65 ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_INT 99
7243: PPUSH
7244: LD_INT 65
7246: PPUSH
7247: CALL_OW 171
// AddComMoveXY ( i , 76 , 108 ) ;
7251: LD_VAR 0 2
7255: PPUSH
7256: LD_INT 76
7258: PPUSH
7259: LD_INT 108
7261: PPUSH
7262: CALL_OW 171
// AddComMoveXY ( i , 92 , 176 ) ;
7266: LD_VAR 0 2
7270: PPUSH
7271: LD_INT 92
7273: PPUSH
7274: LD_INT 176
7276: PPUSH
7277: CALL_OW 171
// end ;
7281: GO 7233
7283: POP
7284: POP
// wait ( 0 0$10 ) ;
7285: LD_INT 350
7287: PPUSH
7288: CALL_OW 67
// tmp := [ Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Kurt , Aviradze ] union heikeSecondSquad ;
7292: LD_ADDR_VAR 0 5
7296: PUSH
7297: LD_EXP 18
7301: PUSH
7302: LD_EXP 19
7306: PUSH
7307: LD_EXP 20
7311: PUSH
7312: LD_EXP 21
7316: PUSH
7317: LD_EXP 22
7321: PUSH
7322: LD_EXP 23
7326: PUSH
7327: LD_EXP 24
7331: PUSH
7332: LD_EXP 25
7336: PUSH
7337: LD_EXP 27
7341: PUSH
7342: LD_EXP 28
7346: PUSH
7347: EMPTY
7348: LIST
7349: LIST
7350: LIST
7351: LIST
7352: LIST
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: LIST
7358: PUSH
7359: LD_EXP 29
7363: UNION
7364: ST_TO_ADDR
// tmp := tmp diff 0 ;
7365: LD_ADDR_VAR 0 5
7369: PUSH
7370: LD_VAR 0 5
7374: PUSH
7375: LD_INT 0
7377: DIFF
7378: ST_TO_ADDR
// for i in heikeVehicles do
7379: LD_ADDR_VAR 0 2
7383: PUSH
7384: LD_EXP 30
7388: PUSH
7389: FOR_IN
7390: IFFALSE 7656
// begin if not tmp then
7392: LD_VAR 0 5
7396: NOT
7397: IFFALSE 7401
// continue ;
7399: GO 7389
// PrepareTank ( 2 , i [ 5 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] , 34 ) ;
7401: LD_INT 2
7403: PPUSH
7404: LD_VAR 0 2
7408: PUSH
7409: LD_INT 5
7411: ARRAY
7412: PPUSH
7413: LD_VAR 0 2
7417: PUSH
7418: LD_INT 1
7420: ARRAY
7421: PPUSH
7422: LD_VAR 0 2
7426: PUSH
7427: LD_INT 2
7429: ARRAY
7430: PPUSH
7431: LD_VAR 0 2
7435: PUSH
7436: LD_INT 3
7438: ARRAY
7439: PPUSH
7440: LD_VAR 0 2
7444: PUSH
7445: LD_INT 4
7447: ARRAY
7448: PPUSH
7449: LD_INT 34
7451: PPUSH
7452: CALL 399 0 7
// veh := CreateVehicle ;
7456: LD_ADDR_VAR 0 4
7460: PUSH
7461: CALL_OW 45
7465: ST_TO_ADDR
// if i [ 4 ] in [ ru_cargo_bay , ar_cargo_bay , us_cargo_bay ] then
7466: LD_VAR 0 2
7470: PUSH
7471: LD_INT 4
7473: ARRAY
7474: PUSH
7475: LD_INT 51
7477: PUSH
7478: LD_INT 32
7480: PUSH
7481: LD_INT 12
7483: PUSH
7484: EMPTY
7485: LIST
7486: LIST
7487: LIST
7488: IN
7489: IFFALSE 7569
// begin if i [ 7 ] [ 1 ] then
7491: LD_VAR 0 2
7495: PUSH
7496: LD_INT 7
7498: ARRAY
7499: PUSH
7500: LD_INT 1
7502: ARRAY
7503: IFFALSE 7530
// AddCargo ( veh , mat_cans , i [ 7 ] [ 1 ] ) ;
7505: LD_VAR 0 4
7509: PPUSH
7510: LD_INT 1
7512: PPUSH
7513: LD_VAR 0 2
7517: PUSH
7518: LD_INT 7
7520: ARRAY
7521: PUSH
7522: LD_INT 1
7524: ARRAY
7525: PPUSH
7526: CALL_OW 291
// if i [ 7 ] [ 2 ] then
7530: LD_VAR 0 2
7534: PUSH
7535: LD_INT 7
7537: ARRAY
7538: PUSH
7539: LD_INT 2
7541: ARRAY
7542: IFFALSE 7569
// AddCargo ( veh , mat_oil , i [ 7 ] [ 2 ] ) ;
7544: LD_VAR 0 4
7548: PPUSH
7549: LD_INT 2
7551: PPUSH
7552: LD_VAR 0 2
7556: PUSH
7557: LD_INT 7
7559: ARRAY
7560: PUSH
7561: LD_INT 2
7563: ARRAY
7564: PPUSH
7565: CALL_OW 291
// end ; SetDir ( veh , 3 ) ;
7569: LD_VAR 0 4
7573: PPUSH
7574: LD_INT 3
7576: PPUSH
7577: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7581: LD_VAR 0 4
7585: PPUSH
7586: LD_INT 8
7588: PPUSH
7589: LD_INT 0
7591: PPUSH
7592: CALL_OW 49
// PlaceHumanInUnit ( tmp [ 1 ] , veh ) ;
7596: LD_VAR 0 5
7600: PUSH
7601: LD_INT 1
7603: ARRAY
7604: PPUSH
7605: LD_VAR 0 4
7609: PPUSH
7610: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
7614: LD_ADDR_VAR 0 5
7618: PUSH
7619: LD_VAR 0 5
7623: PPUSH
7624: LD_INT 1
7626: PPUSH
7627: CALL_OW 3
7631: ST_TO_ADDR
// ComAgressiveMove ( veh , 133 , 7 ) ;
7632: LD_VAR 0 4
7636: PPUSH
7637: LD_INT 133
7639: PPUSH
7640: LD_INT 7
7642: PPUSH
7643: CALL_OW 114
// wait ( 0 0$1 ) ;
7647: LD_INT 35
7649: PPUSH
7650: CALL_OW 67
// end ;
7654: GO 7389
7656: POP
7657: POP
// if tmp then
7658: LD_VAR 0 5
7662: IFFALSE 7718
// for i in tmp do
7664: LD_ADDR_VAR 0 2
7668: PUSH
7669: LD_VAR 0 5
7673: PUSH
7674: FOR_IN
7675: IFFALSE 7716
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7677: LD_VAR 0 2
7681: PPUSH
7682: LD_INT 10
7684: PPUSH
7685: LD_INT 0
7687: PPUSH
7688: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7692: LD_VAR 0 2
7696: PPUSH
7697: LD_INT 146
7699: PPUSH
7700: LD_INT 7
7702: PPUSH
7703: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7707: LD_INT 18
7709: PPUSH
7710: CALL_OW 67
// end ;
7714: GO 7674
7716: POP
7717: POP
// if heikeApes then
7718: LD_EXP 31
7722: IFFALSE 7778
// for i in heikeApes do
7724: LD_ADDR_VAR 0 2
7728: PUSH
7729: LD_EXP 31
7733: PUSH
7734: FOR_IN
7735: IFFALSE 7776
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7737: LD_VAR 0 2
7741: PPUSH
7742: LD_INT 10
7744: PPUSH
7745: LD_INT 0
7747: PPUSH
7748: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7752: LD_VAR 0 2
7756: PPUSH
7757: LD_INT 146
7759: PPUSH
7760: LD_INT 7
7762: PPUSH
7763: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7767: LD_INT 18
7769: PPUSH
7770: CALL_OW 67
// end ;
7774: GO 7734
7776: POP
7777: POP
// DialogueOn ;
7778: CALL_OW 6
// Say ( Heike , DH-outpost-a-1 ) ;
7782: LD_EXP 18
7786: PPUSH
7787: LD_STRING DH-outpost-a-1
7789: PPUSH
7790: CALL_OW 88
// DialogueOff ;
7794: CALL_OW 7
// RemoveSeeing ( 133 , 2 , 2 ) ;
7798: LD_INT 133
7800: PPUSH
7801: LD_INT 2
7803: PPUSH
7804: LD_INT 2
7806: PPUSH
7807: CALL_OW 331
// InGameOff ;
7811: CALL_OW 9
// music_nat := 0 ;
7815: LD_ADDR_OWVAR 71
7819: PUSH
7820: LD_INT 0
7822: ST_TO_ADDR
// music_class := 0 ;
7823: LD_ADDR_OWVAR 72
7827: PUSH
7828: LD_INT 0
7830: ST_TO_ADDR
// ChangeMissionObjectives ( Outposts ) ;
7831: LD_STRING Outposts
7833: PPUSH
7834: CALL_OW 337
// SaveForQuickRestart ;
7838: CALL_OW 22
// end ;
7842: LD_VAR 0 1
7846: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 20 ] ] ) and ibrahimOnRuSide and IsOk ( Ibrahim ) do var x , y , d , lives ;
7847: LD_INT 22
7849: PUSH
7850: LD_INT 2
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PUSH
7857: LD_INT 91
7859: PUSH
7860: LD_EXP 21
7864: PUSH
7865: LD_INT 20
7867: PUSH
7868: EMPTY
7869: LIST
7870: LIST
7871: LIST
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: PPUSH
7877: CALL_OW 69
7881: PUSH
7882: LD_EXP 3
7886: AND
7887: PUSH
7888: LD_EXP 21
7892: PPUSH
7893: CALL_OW 302
7897: AND
7898: IFFALSE 8145
7900: GO 7902
7902: DISABLE
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
7907: PPUSH
7908: PPUSH
// begin IbrahimBetrayal ;
7909: CALL 8148 0 0
// repeat wait ( 0 0$1 ) ;
7913: LD_INT 35
7915: PPUSH
7916: CALL_OW 67
// until IsDead ( Ibrahim ) or ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 6 ] ] ) and IsOk ( Ibrahim ) ) ;
7920: LD_EXP 21
7924: PPUSH
7925: CALL_OW 301
7929: PUSH
7930: LD_INT 22
7932: PUSH
7933: LD_INT 2
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: PUSH
7940: LD_INT 91
7942: PUSH
7943: LD_EXP 21
7947: PUSH
7948: LD_INT 6
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: PUSH
7956: EMPTY
7957: LIST
7958: LIST
7959: PPUSH
7960: CALL_OW 69
7964: PUSH
7965: LD_EXP 21
7969: PPUSH
7970: CALL_OW 302
7974: AND
7975: OR
7976: IFFALSE 7913
// if IsDead ( Ibrahim ) then
7978: LD_EXP 21
7982: PPUSH
7983: CALL_OW 301
7987: IFFALSE 7991
// exit ;
7989: GO 8145
// x := GetX ( Ibrahim ) ;
7991: LD_ADDR_VAR 0 1
7995: PUSH
7996: LD_EXP 21
8000: PPUSH
8001: CALL_OW 250
8005: ST_TO_ADDR
// y := GetY ( Ibrahim ) ;
8006: LD_ADDR_VAR 0 2
8010: PUSH
8011: LD_EXP 21
8015: PPUSH
8016: CALL_OW 251
8020: ST_TO_ADDR
// d := GetDir ( Ibrahim ) ;
8021: LD_ADDR_VAR 0 3
8025: PUSH
8026: LD_EXP 21
8030: PPUSH
8031: CALL_OW 254
8035: ST_TO_ADDR
// lives := GetLives ( Ibrahim ) ;
8036: LD_ADDR_VAR 0 4
8040: PUSH
8041: LD_EXP 21
8045: PPUSH
8046: CALL_OW 256
8050: ST_TO_ADDR
// RemoveUnit ( Ibrahim ) ;
8051: LD_EXP 21
8055: PPUSH
8056: CALL_OW 64
// uc_side := 2 ;
8060: LD_ADDR_OWVAR 20
8064: PUSH
8065: LD_INT 2
8067: ST_TO_ADDR
// uc_nation := 2 ;
8068: LD_ADDR_OWVAR 21
8072: PUSH
8073: LD_INT 2
8075: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , false ,  ) ;
8076: LD_ADDR_EXP 21
8080: PUSH
8081: LD_STRING Ibrahim
8083: PPUSH
8084: LD_INT 0
8086: PPUSH
8087: LD_STRING 
8089: PPUSH
8090: CALL 336 0 3
8094: ST_TO_ADDR
// SetDir ( Ibrahim , d ) ;
8095: LD_EXP 21
8099: PPUSH
8100: LD_VAR 0 3
8104: PPUSH
8105: CALL_OW 233
// PlaceUnitXY ( Ibrahim , x , y , false ) ;
8109: LD_EXP 21
8113: PPUSH
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_VAR 0 2
8123: PPUSH
8124: LD_INT 0
8126: PPUSH
8127: CALL_OW 48
// SetLives ( Ibrahim , lives ) ;
8131: LD_EXP 21
8135: PPUSH
8136: LD_VAR 0 4
8140: PPUSH
8141: CALL_OW 234
// end ;
8145: PPOPN 4
8147: END
// export function IbrahimBetrayal ; var i , tmp ; begin
8148: LD_INT 0
8150: PPUSH
8151: PPUSH
8152: PPUSH
// PlaceSeeing ( 122 , 77 , 2 , - 6 ) ;
8153: LD_INT 122
8155: PPUSH
8156: LD_INT 77
8158: PPUSH
8159: LD_INT 2
8161: PPUSH
8162: LD_INT 6
8164: NEG
8165: PPUSH
8166: CALL_OW 330
// ComMoveXY ( Ibrahim , 123 , 79 ) ;
8170: LD_EXP 21
8174: PPUSH
8175: LD_INT 123
8177: PPUSH
8178: LD_INT 79
8180: PPUSH
8181: CALL_OW 111
// AddComTurnXY ( Ibrahim , 125 , 82 ) ;
8185: LD_EXP 21
8189: PPUSH
8190: LD_INT 125
8192: PPUSH
8193: LD_INT 82
8195: PPUSH
8196: CALL_OW 178
// wait ( 0 0$2 ) ;
8200: LD_INT 70
8202: PPUSH
8203: CALL_OW 67
// ComTurnUnit ( ruSol , Ibrahim ) ;
8207: LD_EXP 41
8211: PPUSH
8212: LD_EXP 21
8216: PPUSH
8217: CALL_OW 119
// Say ( ruSol , DRum-outpost-b-3 ) ;
8221: LD_EXP 41
8225: PPUSH
8226: LD_STRING DRum-outpost-b-3
8228: PPUSH
8229: CALL_OW 88
// tmp := [ HexInfo ( 125 , 76 ) , HexInfo ( 125 , 79 ) , HexInfo ( 125 , 82 ) ] ;
8233: LD_ADDR_VAR 0 3
8237: PUSH
8238: LD_INT 125
8240: PPUSH
8241: LD_INT 76
8243: PPUSH
8244: CALL_OW 428
8248: PUSH
8249: LD_INT 125
8251: PPUSH
8252: LD_INT 79
8254: PPUSH
8255: CALL_OW 428
8259: PUSH
8260: LD_INT 125
8262: PPUSH
8263: LD_INT 82
8265: PPUSH
8266: CALL_OW 428
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: LIST
8275: ST_TO_ADDR
// for i in tmp do
8276: LD_ADDR_VAR 0 2
8280: PUSH
8281: LD_VAR 0 3
8285: PUSH
8286: FOR_IN
8287: IFFALSE 8303
// SetLives ( i , 200 ) ;
8289: LD_VAR 0 2
8293: PPUSH
8294: LD_INT 200
8296: PPUSH
8297: CALL_OW 234
8301: GO 8286
8303: POP
8304: POP
// Say ( Ibrahim , DI-outpost-b-4 ) ;
8305: LD_EXP 21
8309: PPUSH
8310: LD_STRING DI-outpost-b-4
8312: PPUSH
8313: CALL_OW 88
// SetSide ( Ibrahim , 5 ) ;
8317: LD_EXP 21
8321: PPUSH
8322: LD_INT 5
8324: PPUSH
8325: CALL_OW 235
// ComFree ( [ Ibrahim , ruSol ] ) ;
8329: LD_EXP 21
8333: PUSH
8334: LD_EXP 41
8338: PUSH
8339: EMPTY
8340: LIST
8341: LIST
8342: PPUSH
8343: CALL_OW 139
// RemoveSeeing ( 122 , 77 , 2 ) ;
8347: LD_INT 122
8349: PPUSH
8350: LD_INT 77
8352: PPUSH
8353: LD_INT 2
8355: PPUSH
8356: CALL_OW 331
// if Givi then
8360: LD_EXP 19
8364: IFFALSE 8380
// Say ( Givi , DG-1-outpost-b-5 ) else
8366: LD_EXP 19
8370: PPUSH
8371: LD_STRING DG-1-outpost-b-5
8373: PPUSH
8374: CALL_OW 88
8378: GO 8445
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-outpost-b-a-5 ) then
8380: LD_EXP 29
8384: PPUSH
8385: LD_INT 26
8387: PUSH
8388: LD_INT 2
8390: PUSH
8391: EMPTY
8392: LIST
8393: LIST
8394: PPUSH
8395: CALL_OW 72
8399: PUSH
8400: LD_INT 1
8402: ARRAY
8403: PPUSH
8404: LD_STRING DArf-outpost-b-a-5
8406: PPUSH
8407: CALL_OW 88
8411: NOT
8412: IFFALSE 8445
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-outpost-b-a-5 ) ;
8414: LD_EXP 29
8418: PPUSH
8419: LD_INT 26
8421: PUSH
8422: LD_INT 1
8424: PUSH
8425: EMPTY
8426: LIST
8427: LIST
8428: PPUSH
8429: CALL_OW 72
8433: PUSH
8434: LD_INT 1
8436: ARRAY
8437: PPUSH
8438: LD_STRING DArm-outpost-b-a-5
8440: PPUSH
8441: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
8445: LD_INT 35
8447: PPUSH
8448: CALL_OW 67
// until IsDead ( Ibrahim ) or ( GetDistUnits ( Heike , Ibrahim ) < 6 and IsOk ( Ibrahim ) ) ;
8452: LD_EXP 21
8456: PPUSH
8457: CALL_OW 301
8461: PUSH
8462: LD_EXP 18
8466: PPUSH
8467: LD_EXP 21
8471: PPUSH
8472: CALL_OW 296
8476: PUSH
8477: LD_INT 6
8479: LESS
8480: PUSH
8481: LD_EXP 21
8485: PPUSH
8486: CALL_OW 302
8490: AND
8491: OR
8492: IFFALSE 8445
// if IsDead ( Ibrahim ) then
8494: LD_EXP 21
8498: PPUSH
8499: CALL_OW 301
8503: IFFALSE 8519
// begin Say ( Heike , DH-ibrahimdead-1 ) ;
8505: LD_EXP 18
8509: PPUSH
8510: LD_STRING DH-ibrahimdead-1
8512: PPUSH
8513: CALL_OW 88
// exit ;
8517: GO 8560
// end ; CenterNowOnUnits ( Ibrahim ) ;
8519: LD_EXP 21
8523: PPUSH
8524: CALL_OW 87
// DialogueOn ;
8528: CALL_OW 6
// Say ( Ibrahim , DI-ibrahimlives-1 ) ;
8532: LD_EXP 21
8536: PPUSH
8537: LD_STRING DI-ibrahimlives-1
8539: PPUSH
8540: CALL_OW 88
// Say ( Heike , DH-Ibrahimlives-2 ) ;
8544: LD_EXP 18
8548: PPUSH
8549: LD_STRING DH-Ibrahimlives-2
8551: PPUSH
8552: CALL_OW 88
// DialogueOff ;
8556: CALL_OW 7
// end ;
8560: LD_VAR 0 1
8564: RET
// every 0 0$1 trigger FilterUnitsInArea ( outerArea , [ f_side , 2 ] ) or tick >= [ 9 9$00 , 8 8$00 , 8 8$00 ] [ Difficulty ] do
8565: LD_INT 11
8567: PPUSH
8568: LD_INT 22
8570: PUSH
8571: LD_INT 2
8573: PUSH
8574: EMPTY
8575: LIST
8576: LIST
8577: PPUSH
8578: CALL_OW 70
8582: PUSH
8583: LD_OWVAR 1
8587: PUSH
8588: LD_INT 18900
8590: PUSH
8591: LD_INT 16800
8593: PUSH
8594: LD_INT 16800
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: LIST
8601: PUSH
8602: LD_OWVAR 67
8606: ARRAY
8607: GREATEREQUAL
8608: OR
8609: IFFALSE 9016
8611: GO 8613
8613: DISABLE
// begin outerAreaAchived := true ;
8614: LD_ADDR_EXP 15
8618: PUSH
8619: LD_INT 1
8621: ST_TO_ADDR
// wait ( 0 0$20 ) ;
8622: LD_INT 700
8624: PPUSH
8625: CALL_OW 67
// DialogueOn ;
8629: CALL_OW 6
// SayRadio ( Shariff , DShar-radio-1 ) ;
8633: LD_EXP 26
8637: PPUSH
8638: LD_STRING DShar-radio-1
8640: PPUSH
8641: CALL_OW 94
// SayRadio ( Shariff , DShar-radio-2 ) ;
8645: LD_EXP 26
8649: PPUSH
8650: LD_STRING DShar-radio-2
8652: PPUSH
8653: CALL_OW 94
// Say ( Heike , DH-radio-2 ) ;
8657: LD_EXP 18
8661: PPUSH
8662: LD_STRING DH-radio-2
8664: PPUSH
8665: CALL_OW 88
// DialogueOff ;
8669: CALL_OW 7
// ChangeMissionObjectives ( Gaidar ) ;
8673: LD_STRING Gaidar
8675: PPUSH
8676: CALL_OW 337
// if Difficulty < 3 then
8680: LD_OWVAR 67
8684: PUSH
8685: LD_INT 3
8687: LESS
8688: IFFALSE 8754
// begin DialogueOn ;
8690: CALL_OW 6
// PlaceSeeing ( 11 , 14 , 2 , - 6 ) ;
8694: LD_INT 11
8696: PPUSH
8697: LD_INT 14
8699: PPUSH
8700: LD_INT 2
8702: PPUSH
8703: LD_INT 6
8705: NEG
8706: PPUSH
8707: CALL_OW 330
// RemoveSeeing ( 11 , 14 , 2 ) ;
8711: LD_INT 11
8713: PPUSH
8714: LD_INT 14
8716: PPUSH
8717: LD_INT 2
8719: PPUSH
8720: CALL_OW 331
// CenterOnXY ( 11 , 14 ) ;
8724: LD_INT 11
8726: PPUSH
8727: LD_INT 14
8729: PPUSH
8730: CALL_OW 84
// dwait ( 0 0$1 ) ;
8734: LD_INT 35
8736: PPUSH
8737: CALL_OW 68
// CenterNowOnUnits ( Heike ) ;
8741: LD_EXP 18
8745: PPUSH
8746: CALL_OW 87
// DialogueOff ;
8750: CALL_OW 7
// end ; wait ( 0 0$30 + rand ( 0 0$10 , 0 0$15 ) * Difficulty ) ;
8754: LD_INT 1050
8756: PUSH
8757: LD_INT 350
8759: PPUSH
8760: LD_INT 525
8762: PPUSH
8763: CALL_OW 12
8767: PUSH
8768: LD_OWVAR 67
8772: MUL
8773: PLUS
8774: PPUSH
8775: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8779: LD_INT 35
8781: PPUSH
8782: CALL_OW 67
// until HexInfo ( 2 , 1 ) = 0 ;
8786: LD_INT 2
8788: PPUSH
8789: LD_INT 1
8791: PPUSH
8792: CALL_OW 428
8796: PUSH
8797: LD_INT 0
8799: EQUAL
8800: IFFALSE 8779
// SetDir ( Gaidar , 2 ) ;
8802: LD_EXP 34
8806: PPUSH
8807: LD_INT 2
8809: PPUSH
8810: CALL_OW 233
// PlaceUnitXY ( Gaidar , 2 , 1 , false ) ;
8814: LD_EXP 34
8818: PPUSH
8819: LD_INT 2
8821: PPUSH
8822: LD_INT 1
8824: PPUSH
8825: LD_INT 0
8827: PPUSH
8828: CALL_OW 48
// ComMoveXY ( Gaidar , 19 , 24 ) ;
8832: LD_EXP 34
8836: PPUSH
8837: LD_INT 19
8839: PPUSH
8840: LD_INT 24
8842: PPUSH
8843: CALL_OW 111
// AddComWait ( Gaidar , 0 0$6 ) ;
8847: LD_EXP 34
8851: PPUSH
8852: LD_INT 210
8854: PPUSH
8855: CALL_OW 202
// AddComMoveXY ( Gaidar , 38 , 47 ) ;
8859: LD_EXP 34
8863: PPUSH
8864: LD_INT 38
8866: PPUSH
8867: LD_INT 47
8869: PPUSH
8870: CALL_OW 171
// AddComMoveXY ( Gaidar , 32 , 59 ) ;
8874: LD_EXP 34
8878: PPUSH
8879: LD_INT 32
8881: PPUSH
8882: LD_INT 59
8884: PPUSH
8885: CALL_OW 171
// AddComWait ( Gaidar , 0 0$10 ) ;
8889: LD_EXP 34
8893: PPUSH
8894: LD_INT 350
8896: PPUSH
8897: CALL_OW 202
// AddComMoveXY ( Gaidar , 62 , 116 ) ;
8901: LD_EXP 34
8905: PPUSH
8906: LD_INT 62
8908: PPUSH
8909: LD_INT 116
8911: PPUSH
8912: CALL_OW 171
// AddComMoveXY ( Gaidar , 92 , 177 ) ;
8916: LD_EXP 34
8920: PPUSH
8921: LD_INT 92
8923: PPUSH
8924: LD_INT 177
8926: PPUSH
8927: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8931: LD_INT 35
8933: PPUSH
8934: CALL_OW 67
// until IsDead ( Gaidar ) or IsAt ( Gaidar , 92 , 177 ) ;
8938: LD_EXP 34
8942: PPUSH
8943: CALL_OW 301
8947: PUSH
8948: LD_EXP 34
8952: PPUSH
8953: LD_INT 92
8955: PPUSH
8956: LD_INT 177
8958: PPUSH
8959: CALL_OW 307
8963: OR
8964: IFFALSE 8931
// if IsAt ( Gaidar , 92 , 177 ) then
8966: LD_EXP 34
8970: PPUSH
8971: LD_INT 92
8973: PPUSH
8974: LD_INT 177
8976: PPUSH
8977: CALL_OW 307
8981: IFFALSE 8994
// begin RemoveUnit ( Gaidar ) ;
8983: LD_EXP 34
8987: PPUSH
8988: CALL_OW 64
// exit ;
8992: GO 9016
// end ; gaidarKilled := true ;
8994: LD_ADDR_EXP 14
8998: PUSH
8999: LD_INT 1
9001: ST_TO_ADDR
// ChangeMissionObjectives ( GaidarKilled ) ;
9002: LD_STRING GaidarKilled
9004: PPUSH
9005: CALL_OW 337
// SetAchievement ( ACH_COMMISAR ) ;
9009: LD_STRING ACH_COMMISAR
9011: PPUSH
9012: CALL_OW 543
// end ;
9016: END
// every 0 0$1 trigger See ( 2 , Gaidar ) do
9017: LD_INT 2
9019: PPUSH
9020: LD_EXP 34
9024: PPUSH
9025: CALL_OW 292
9029: IFFALSE 9046
9031: GO 9033
9033: DISABLE
// Say ( Gaidar , DT-objective-1 ) ;
9034: LD_EXP 34
9038: PPUSH
9039: LD_STRING DT-objective-1
9041: PPUSH
9042: CALL_OW 88
9046: END
// every 0 0$5 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) do
9047: LD_INT 22
9049: PUSH
9050: LD_INT 2
9052: PUSH
9053: EMPTY
9054: LIST
9055: LIST
9056: PUSH
9057: LD_INT 2
9059: PUSH
9060: LD_INT 95
9062: PUSH
9063: LD_INT 5
9065: PUSH
9066: EMPTY
9067: LIST
9068: LIST
9069: PUSH
9070: LD_INT 95
9072: PUSH
9073: LD_INT 6
9075: PUSH
9076: EMPTY
9077: LIST
9078: LIST
9079: PUSH
9080: LD_INT 95
9082: PUSH
9083: LD_INT 7
9085: PUSH
9086: EMPTY
9087: LIST
9088: LIST
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: LIST
9094: LIST
9095: PUSH
9096: EMPTY
9097: LIST
9098: LIST
9099: PPUSH
9100: CALL_OW 69
9104: IFFALSE 9141
9106: GO 9108
9108: DISABLE
// begin DialogueOn ;
9109: CALL_OW 6
// Say ( Heike , DH-outpost-last-1 ) ;
9113: LD_EXP 18
9117: PPUSH
9118: LD_STRING DH-outpost-last-1
9120: PPUSH
9121: CALL_OW 88
// SayRadio ( Burlak , DB-outpost-last-2 ) ;
9125: LD_EXP 33
9129: PPUSH
9130: LD_STRING DB-outpost-last-2
9132: PPUSH
9133: CALL_OW 94
// DialogueOff ;
9137: CALL_OW 7
// end ;
9141: END
// every 0 0$1 trigger GetLives ( ruMainBase ) < 999 or GetSide ( ruMainBase ) = 2 do var i , tmp ;
9142: LD_INT 200
9144: PPUSH
9145: CALL_OW 256
9149: PUSH
9150: LD_INT 999
9152: LESS
9153: PUSH
9154: LD_INT 200
9156: PPUSH
9157: CALL_OW 255
9161: PUSH
9162: LD_INT 2
9164: EQUAL
9165: OR
9166: IFFALSE 9339
9168: GO 9170
9170: DISABLE
9171: LD_INT 0
9173: PPUSH
9174: PPUSH
// begin if not earlyEscape then
9175: LD_EXP 16
9179: NOT
9180: IFFALSE 9206
// begin SayRadio ( Burlak , DB-end-1 ) ;
9182: LD_EXP 33
9186: PPUSH
9187: LD_STRING DB-end-1
9189: PPUSH
9190: CALL_OW 94
// Say ( Heike , DH-end-2 ) ;
9194: LD_EXP 18
9198: PPUSH
9199: LD_STRING DH-end-2
9201: PPUSH
9202: CALL_OW 88
// end ; if tick <= 15 15$00 then
9206: LD_OWVAR 1
9210: PUSH
9211: LD_INT 31500
9213: LESSEQUAL
9214: IFFALSE 9223
// SetAchievement ( ACH_FIST ) ;
9216: LD_STRING ACH_FIST
9218: PPUSH
9219: CALL_OW 543
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9223: LD_ADDR_VAR 0 2
9227: PUSH
9228: LD_INT 22
9230: PUSH
9231: LD_INT 3
9233: PUSH
9234: EMPTY
9235: LIST
9236: LIST
9237: PUSH
9238: LD_INT 3
9240: PUSH
9241: LD_INT 21
9243: PUSH
9244: LD_INT 3
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: PUSH
9251: EMPTY
9252: LIST
9253: LIST
9254: PUSH
9255: EMPTY
9256: LIST
9257: LIST
9258: PPUSH
9259: CALL_OW 69
9263: ST_TO_ADDR
// if not tmp then
9264: LD_VAR 0 2
9268: NOT
9269: IFFALSE 9273
// exit ;
9271: GO 9339
// for i in tmp do
9273: LD_ADDR_VAR 0 1
9277: PUSH
9278: LD_VAR 0 2
9282: PUSH
9283: FOR_IN
9284: IFFALSE 9337
// begin SetTag ( i , tEscape ) ;
9286: LD_VAR 0 1
9290: PPUSH
9291: LD_EXP 17
9295: PPUSH
9296: CALL_OW 109
// if IsInUnit ( i ) then
9300: LD_VAR 0 1
9304: PPUSH
9305: CALL_OW 310
9309: IFFALSE 9320
// ComExitBuilding ( i ) ;
9311: LD_VAR 0 1
9315: PPUSH
9316: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9320: LD_VAR 0 1
9324: PPUSH
9325: LD_INT 92
9327: PPUSH
9328: LD_INT 177
9330: PPUSH
9331: CALL_OW 171
// end ;
9335: GO 9283
9337: POP
9338: POP
// end ;
9339: PPOPN 2
9341: END
// every 0 0$1 trigger FilterUnitsInArea ( zone1 , [ f_side , 2 ] ) and not outerAreaAchived and IsOk ( Kurt ) do
9342: LD_INT 4
9344: PPUSH
9345: LD_INT 22
9347: PUSH
9348: LD_INT 2
9350: PUSH
9351: EMPTY
9352: LIST
9353: LIST
9354: PPUSH
9355: CALL_OW 70
9359: PUSH
9360: LD_EXP 15
9364: NOT
9365: AND
9366: PUSH
9367: LD_EXP 27
9371: PPUSH
9372: CALL_OW 302
9376: AND
9377: IFFALSE 9617
9379: GO 9381
9381: DISABLE
// begin DialogueOn ;
9382: CALL_OW 6
// PlaceSeeing ( 111 , 54 , 2 , - 16 ) ;
9386: LD_INT 111
9388: PPUSH
9389: LD_INT 54
9391: PPUSH
9392: LD_INT 2
9394: PPUSH
9395: LD_INT 16
9397: NEG
9398: PPUSH
9399: CALL_OW 330
// CenterNowOnXY ( 111 , 53 ) ;
9403: LD_INT 111
9405: PPUSH
9406: LD_INT 53
9408: PPUSH
9409: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
9413: LD_INT 10
9415: PPUSH
9416: CALL_OW 68
// Say ( Kurt , DKs-Hannibal-1 ) ;
9420: LD_EXP 27
9424: PPUSH
9425: LD_STRING DKs-Hannibal-1
9427: PPUSH
9428: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-2 ) ;
9432: LD_EXP 27
9436: PPUSH
9437: LD_STRING DKs-Hannibal-2
9439: PPUSH
9440: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-3 ) ;
9444: LD_EXP 27
9448: PPUSH
9449: LD_STRING DKs-Hannibal-3
9451: PPUSH
9452: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-4 ) ;
9456: LD_EXP 27
9460: PPUSH
9461: LD_STRING DKs-Hannibal-4
9463: PPUSH
9464: CALL_OW 88
// dwait ( 0 0$1 ) ;
9468: LD_INT 35
9470: PPUSH
9471: CALL_OW 68
// RemoveSeeing ( 111 , 54 , 2 ) ;
9475: LD_INT 111
9477: PPUSH
9478: LD_INT 54
9480: PPUSH
9481: LD_INT 2
9483: PPUSH
9484: CALL_OW 331
// PlaceSeeing ( 173 , 76 , 2 , - 12 ) ;
9488: LD_INT 173
9490: PPUSH
9491: LD_INT 76
9493: PPUSH
9494: LD_INT 2
9496: PPUSH
9497: LD_INT 12
9499: NEG
9500: PPUSH
9501: CALL_OW 330
// RemoveSeeing ( 173 , 76 , 2 ) ;
9505: LD_INT 173
9507: PPUSH
9508: LD_INT 76
9510: PPUSH
9511: LD_INT 2
9513: PPUSH
9514: CALL_OW 331
// CenterNowOnXY ( 173 , 76 ) ;
9518: LD_INT 173
9520: PPUSH
9521: LD_INT 76
9523: PPUSH
9524: CALL_OW 86
// Say ( Kurt , DKs-Hannibal-5 ) ;
9528: LD_EXP 27
9532: PPUSH
9533: LD_STRING DKs-Hannibal-5
9535: PPUSH
9536: CALL_OW 88
// if Kamil and not FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_flame_thrower ] ] ) then
9540: LD_EXP 22
9544: PUSH
9545: LD_INT 22
9547: PUSH
9548: LD_INT 2
9550: PUSH
9551: EMPTY
9552: LIST
9553: LIST
9554: PUSH
9555: LD_INT 34
9557: PUSH
9558: LD_INT 26
9560: PUSH
9561: EMPTY
9562: LIST
9563: LIST
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: PPUSH
9569: CALL_OW 69
9573: NOT
9574: AND
9575: IFFALSE 9613
// begin Say ( Kamil , DKam-Hannibal-a-6 ) ;
9577: LD_EXP 22
9581: PPUSH
9582: LD_STRING DKam-Hannibal-a-6
9584: PPUSH
9585: CALL_OW 88
// Say ( Kamil , DKam-Hannibal-a-7 ) ;
9589: LD_EXP 22
9593: PPUSH
9594: LD_STRING DKam-Hannibal-a-7
9596: PPUSH
9597: CALL_OW 88
// Say ( Givi , DG-Hannibal-a-8 ) ;
9601: LD_EXP 19
9605: PPUSH
9606: LD_STRING DG-Hannibal-a-8
9608: PPUSH
9609: CALL_OW 88
// end ; DialogueOff ;
9613: CALL_OW 7
// end ;
9617: END
// every 0 0$1 trigger IsOk ( ruSecBase ) and IsOk ( ruMainBase ) and FilterUnitsInArea ( showDefenceArea , [ f_type , unit_building ] ) > 2 and FilterUnitsInArea ( forestArea , [ f_side , 2 ] ) > 3 do
9618: LD_INT 225
9620: PPUSH
9621: CALL_OW 302
9625: PUSH
9626: LD_INT 200
9628: PPUSH
9629: CALL_OW 302
9633: AND
9634: PUSH
9635: LD_INT 12
9637: PPUSH
9638: LD_INT 21
9640: PUSH
9641: LD_INT 3
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: PPUSH
9648: CALL_OW 70
9652: PUSH
9653: LD_INT 2
9655: GREATER
9656: AND
9657: PUSH
9658: LD_INT 13
9660: PPUSH
9661: LD_INT 22
9663: PUSH
9664: LD_INT 2
9666: PUSH
9667: EMPTY
9668: LIST
9669: LIST
9670: PPUSH
9671: CALL_OW 70
9675: PUSH
9676: LD_INT 3
9678: GREATER
9679: AND
9680: IFFALSE 9693
9682: GO 9684
9684: DISABLE
// hannibalPath := true ;
9685: LD_ADDR_EXP 9
9689: PUSH
9690: LD_INT 1
9692: ST_TO_ADDR
9693: END
// every 0 0$3 trigger hannibalPath and FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) do var i , tmp , hasFlameThrower ;
9694: LD_EXP 9
9698: PUSH
9699: LD_INT 6
9701: PPUSH
9702: LD_INT 22
9704: PUSH
9705: LD_INT 2
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: PPUSH
9712: CALL_OW 70
9716: AND
9717: IFFALSE 10062
9719: GO 9721
9721: DISABLE
9722: LD_INT 0
9724: PPUSH
9725: PPUSH
9726: PPUSH
// begin tmp := FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) ;
9727: LD_ADDR_VAR 0 2
9731: PUSH
9732: LD_INT 6
9734: PPUSH
9735: LD_INT 22
9737: PUSH
9738: LD_INT 2
9740: PUSH
9741: EMPTY
9742: LIST
9743: LIST
9744: PPUSH
9745: CALL_OW 70
9749: ST_TO_ADDR
// hasFlameThrower := UnitFilter ( tmp , [ f_weapon , ar_flame_thrower ] ) > 0 ;
9750: LD_ADDR_VAR 0 3
9754: PUSH
9755: LD_VAR 0 2
9759: PPUSH
9760: LD_INT 34
9762: PUSH
9763: LD_INT 26
9765: PUSH
9766: EMPTY
9767: LIST
9768: LIST
9769: PPUSH
9770: CALL_OW 72
9774: PUSH
9775: LD_INT 0
9777: GREATER
9778: ST_TO_ADDR
// DialogueOn ;
9779: CALL_OW 6
// Say ( Heike , DH-Cleverattack-1 ) ;
9783: LD_EXP 18
9787: PPUSH
9788: LD_STRING DH-Cleverattack-1
9790: PPUSH
9791: CALL_OW 88
// Say ( Heike , DH-Cleverattack-2 ) ;
9795: LD_EXP 18
9799: PPUSH
9800: LD_STRING DH-Cleverattack-2
9802: PPUSH
9803: CALL_OW 88
// if hasFlameThrower then
9807: LD_VAR 0 3
9811: IFFALSE 9839
// begin SayRadio ( Burlak , DB-Cleverattack-3 ) ;
9813: LD_EXP 33
9817: PPUSH
9818: LD_STRING DB-Cleverattack-3
9820: PPUSH
9821: CALL_OW 94
// Say ( Heike , DH-Cleverattack-4 ) ;
9825: LD_EXP 18
9829: PPUSH
9830: LD_STRING DH-Cleverattack-4
9832: PPUSH
9833: CALL_OW 88
// end else
9837: GO 9863
// begin SayRadio ( Burlak , DB-Cleverattack-a-3 ) ;
9839: LD_EXP 33
9843: PPUSH
9844: LD_STRING DB-Cleverattack-a-3
9846: PPUSH
9847: CALL_OW 94
// Say ( Heike , DH-Cleverattack-a-4 ) ;
9851: LD_EXP 18
9855: PPUSH
9856: LD_STRING DH-Cleverattack-a-4
9858: PPUSH
9859: CALL_OW 88
// end ; DialogueOff ;
9863: CALL_OW 7
// if not hasFlameThrower then
9867: LD_VAR 0 3
9871: NOT
9872: IFFALSE 9876
// exit ;
9874: GO 10062
// earlyEscape := true ;
9876: LD_ADDR_EXP 16
9880: PUSH
9881: LD_INT 1
9883: ST_TO_ADDR
// wait ( 0 0$4 ) ;
9884: LD_INT 140
9886: PPUSH
9887: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ] ) diff [ Ibrahim , Kuzmov , Gaidar ] ;
9891: LD_ADDR_VAR 0 2
9895: PUSH
9896: LD_INT 22
9898: PUSH
9899: LD_INT 3
9901: PUSH
9902: EMPTY
9903: LIST
9904: LIST
9905: PUSH
9906: LD_INT 2
9908: PUSH
9909: LD_INT 25
9911: PUSH
9912: LD_INT 1
9914: PUSH
9915: EMPTY
9916: LIST
9917: LIST
9918: PUSH
9919: LD_INT 25
9921: PUSH
9922: LD_INT 2
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: PUSH
9929: LD_INT 25
9931: PUSH
9932: LD_INT 4
9934: PUSH
9935: EMPTY
9936: LIST
9937: LIST
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: LIST
9943: LIST
9944: PUSH
9945: EMPTY
9946: LIST
9947: LIST
9948: PPUSH
9949: CALL_OW 69
9953: PUSH
9954: LD_EXP 21
9958: PUSH
9959: LD_EXP 35
9963: PUSH
9964: LD_EXP 34
9968: PUSH
9969: EMPTY
9970: LIST
9971: LIST
9972: LIST
9973: DIFF
9974: ST_TO_ADDR
// for i in tmp do
9975: LD_ADDR_VAR 0 1
9979: PUSH
9980: LD_VAR 0 2
9984: PUSH
9985: FOR_IN
9986: IFFALSE 10060
// begin if Prob ( 40 + 10 * Difficulty ) then
9988: LD_INT 40
9990: PUSH
9991: LD_INT 10
9993: PUSH
9994: LD_OWVAR 67
9998: MUL
9999: PLUS
10000: PPUSH
10001: CALL_OW 13
10005: IFFALSE 10009
// continue ;
10007: GO 9985
// SetTag ( i , tEscape ) ;
10009: LD_VAR 0 1
10013: PPUSH
10014: LD_EXP 17
10018: PPUSH
10019: CALL_OW 109
// if IsInUnit ( i ) then
10023: LD_VAR 0 1
10027: PPUSH
10028: CALL_OW 310
10032: IFFALSE 10043
// ComExitBuilding ( i ) ;
10034: LD_VAR 0 1
10038: PPUSH
10039: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
10043: LD_VAR 0 1
10047: PPUSH
10048: LD_INT 92
10050: PPUSH
10051: LD_INT 177
10053: PPUSH
10054: CALL_OW 171
// end ;
10058: GO 9985
10060: POP
10061: POP
// end ;
10062: PPOPN 3
10064: END
// every 0 0$1 trigger FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do var i ;
10065: LD_INT 9
10067: PPUSH
10068: LD_INT 2
10070: PUSH
10071: LD_INT 22
10073: PUSH
10074: LD_INT 3
10076: PUSH
10077: EMPTY
10078: LIST
10079: LIST
10080: PUSH
10081: LD_INT 22
10083: PUSH
10084: LD_INT 6
10086: PUSH
10087: EMPTY
10088: LIST
10089: LIST
10090: PUSH
10091: EMPTY
10092: LIST
10093: LIST
10094: LIST
10095: PPUSH
10096: CALL_OW 70
10100: IFFALSE 10198
10102: GO 10104
10104: DISABLE
10105: LD_INT 0
10107: PPUSH
// begin enable ;
10108: ENABLE
// for i in FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do
10109: LD_ADDR_VAR 0 1
10113: PUSH
10114: LD_INT 9
10116: PPUSH
10117: LD_INT 2
10119: PUSH
10120: LD_INT 22
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: LD_INT 22
10132: PUSH
10133: LD_INT 6
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: PUSH
10140: EMPTY
10141: LIST
10142: LIST
10143: LIST
10144: PPUSH
10145: CALL_OW 70
10149: PUSH
10150: FOR_IN
10151: IFFALSE 10196
// if GetTag ( i ) = tEscape or GetSide ( i ) = 6 then
10153: LD_VAR 0 1
10157: PPUSH
10158: CALL_OW 110
10162: PUSH
10163: LD_EXP 17
10167: EQUAL
10168: PUSH
10169: LD_VAR 0 1
10173: PPUSH
10174: CALL_OW 255
10178: PUSH
10179: LD_INT 6
10181: EQUAL
10182: OR
10183: IFFALSE 10194
// RemoveUnit ( i ) ;
10185: LD_VAR 0 1
10189: PPUSH
10190: CALL_OW 64
10194: GO 10150
10196: POP
10197: POP
// end ;
10198: PPOPN 1
10200: END
// every 0 0$1 trigger Kaia and GetLives ( Kaia ) < 3 do
10201: LD_EXP 23
10205: PUSH
10206: LD_EXP 23
10210: PPUSH
10211: CALL_OW 256
10215: PUSH
10216: LD_INT 3
10218: LESS
10219: AND
10220: IFFALSE 10266
10222: GO 10224
10224: DISABLE
// begin DialogueOn ;
10225: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
10229: LD_EXP 23
10233: PPUSH
10234: CALL_OW 87
// ForceSay ( Kaia , DK-Kkilled-1 ) ;
10238: LD_EXP 23
10242: PPUSH
10243: LD_STRING DK-Kkilled-1
10245: PPUSH
10246: CALL_OW 91
// Say ( Heike , DH-Kkilled-2 ) ;
10250: LD_EXP 18
10254: PPUSH
10255: LD_STRING DH-Kkilled-2
10257: PPUSH
10258: CALL_OW 88
// DialogueOff ;
10262: CALL_OW 7
// end ;
10266: END
// every 0 0$1 trigger kaiaKilledByRussian do
10267: LD_EXP 8
10271: IFFALSE 10288
10273: GO 10275
10275: DISABLE
// Say ( Heike , DH-Kkilled-3 ) ;
10276: LD_EXP 18
10280: PPUSH
10281: LD_STRING DH-Kkilled-3
10283: PPUSH
10284: CALL_OW 88
10288: END
// every 0 0$1 trigger tick >= 22 22$00 do
10289: LD_OWVAR 1
10293: PUSH
10294: LD_INT 46200
10296: GREATEREQUAL
10297: IFFALSE 10334
10299: GO 10301
10301: DISABLE
// begin DialogueOn ;
10302: CALL_OW 6
// SayRadio ( Shariff , DShar-slow-1 ) ;
10306: LD_EXP 26
10310: PPUSH
10311: LD_STRING DShar-slow-1
10313: PPUSH
10314: CALL_OW 94
// SayRadio ( Shariff , DShar-slow-2 ) ;
10318: LD_EXP 26
10322: PPUSH
10323: LD_STRING DShar-slow-2
10325: PPUSH
10326: CALL_OW 94
// DialogueOff ;
10330: CALL_OW 7
// end ;
10334: END
// every 0 0$1 trigger tick >= [ 40 40$00 , 36 36$00 , 32 32$00 ] [ Difficulty ] do
10335: LD_OWVAR 1
10339: PUSH
10340: LD_INT 84000
10342: PUSH
10343: LD_INT 75600
10345: PUSH
10346: LD_INT 67200
10348: PUSH
10349: EMPTY
10350: LIST
10351: LIST
10352: LIST
10353: PUSH
10354: LD_OWVAR 67
10358: ARRAY
10359: GREATEREQUAL
10360: IFFALSE 10404
10362: GO 10364
10364: DISABLE
// begin DialogueOn ;
10365: CALL_OW 6
// SayRadio ( Shariff , DShar-fail-1 ) ;
10369: LD_EXP 26
10373: PPUSH
10374: LD_STRING DShar-fail-1
10376: PPUSH
10377: CALL_OW 94
// SayRadio ( Shariff , DShar-fail-2 ) ;
10381: LD_EXP 26
10385: PPUSH
10386: LD_STRING DShar-fail-2
10388: PPUSH
10389: CALL_OW 94
// DialogueOff ;
10393: CALL_OW 7
// YouLost ( Time ) ;
10397: LD_STRING Time
10399: PPUSH
10400: CALL_OW 104
// end ;
10404: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) = 0 do var tmp ;
10405: LD_INT 22
10407: PUSH
10408: LD_INT 3
10410: PUSH
10411: EMPTY
10412: LIST
10413: LIST
10414: PUSH
10415: LD_INT 2
10417: PUSH
10418: LD_INT 30
10420: PUSH
10421: LD_INT 1
10423: PUSH
10424: EMPTY
10425: LIST
10426: LIST
10427: PUSH
10428: LD_INT 30
10430: PUSH
10431: LD_INT 0
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: LIST
10442: PUSH
10443: EMPTY
10444: LIST
10445: LIST
10446: PPUSH
10447: CALL_OW 69
10451: PUSH
10452: LD_INT 0
10454: EQUAL
10455: IFFALSE 10946
10457: GO 10459
10459: DISABLE
10460: LD_INT 0
10462: PPUSH
// begin if ( tick + gameTime ) <= [ 75 75$00 , 70 70$00 , 65 65$00 ] [ Difficulty ] then
10463: LD_OWVAR 1
10467: PUSH
10468: LD_EXP 5
10472: PLUS
10473: PUSH
10474: LD_INT 157500
10476: PUSH
10477: LD_INT 147000
10479: PUSH
10480: LD_INT 136500
10482: PUSH
10483: EMPTY
10484: LIST
10485: LIST
10486: LIST
10487: PUSH
10488: LD_OWVAR 67
10492: ARRAY
10493: LESSEQUAL
10494: IFFALSE 10508
// AddMedal ( med1 , 1 ) else
10496: LD_STRING med1
10498: PPUSH
10499: LD_INT 1
10501: PPUSH
10502: CALL_OW 101
10506: GO 10519
// AddMedal ( med1 , - 1 ) ;
10508: LD_STRING med1
10510: PPUSH
10511: LD_INT 1
10513: NEG
10514: PPUSH
10515: CALL_OW 101
// if ( flamethrowers >= 3 ) * baseHill * hannibalPath * ( loseCounter < [ 6 , 5 , 4 ] [ Difficulty ] ) then
10519: LD_EXP 7
10523: PUSH
10524: LD_INT 3
10526: GREATEREQUAL
10527: PUSH
10528: LD_EXP 11
10532: MUL
10533: PUSH
10534: LD_EXP 9
10538: MUL
10539: PUSH
10540: LD_EXP 6
10544: PUSH
10545: LD_INT 6
10547: PUSH
10548: LD_INT 5
10550: PUSH
10551: LD_INT 4
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: LIST
10558: PUSH
10559: LD_OWVAR 67
10563: ARRAY
10564: LESS
10565: MUL
10566: IFFALSE 10580
// AddMedal ( med2 , 1 ) else
10568: LD_STRING med2
10570: PPUSH
10571: LD_INT 1
10573: PPUSH
10574: CALL_OW 101
10578: GO 10591
// AddMedal ( med2 , - 1 ) ;
10580: LD_STRING med2
10582: PPUSH
10583: LD_INT 1
10585: NEG
10586: PPUSH
10587: CALL_OW 101
// if gaidarKilled then
10591: LD_EXP 14
10595: IFFALSE 10609
// AddMedal ( med3 , 1 ) else
10597: LD_STRING med3
10599: PPUSH
10600: LD_INT 1
10602: PPUSH
10603: CALL_OW 101
10607: GO 10620
// AddMedal ( med3 , - 1 ) ;
10609: LD_STRING med3
10611: PPUSH
10612: LD_INT 1
10614: NEG
10615: PPUSH
10616: CALL_OW 101
// GiveMedals ( MAIN ) ;
10620: LD_STRING MAIN
10622: PPUSH
10623: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_nation , 0 ] ] ] ) ) ;
10627: LD_INT 22
10629: PUSH
10630: LD_INT 2
10632: PUSH
10633: EMPTY
10634: LIST
10635: LIST
10636: PUSH
10637: LD_INT 3
10639: PUSH
10640: LD_INT 23
10642: PUSH
10643: LD_INT 0
10645: PUSH
10646: EMPTY
10647: LIST
10648: LIST
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: PUSH
10654: EMPTY
10655: LIST
10656: LIST
10657: PPUSH
10658: CALL_OW 69
10662: PPUSH
10663: CALL_OW 43
// SaveCharacters ( Heike , 04_2_Heike ) ;
10667: LD_EXP 18
10671: PPUSH
10672: LD_STRING 04_2_Heike
10674: PPUSH
10675: CALL_OW 38
// if Aviradze then
10679: LD_EXP 28
10683: IFFALSE 10697
// SaveCharacters ( Aviradze , 04_2_Aviradze ) ;
10685: LD_EXP 28
10689: PPUSH
10690: LD_STRING 04_2_Aviradze
10692: PPUSH
10693: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
10697: LD_EXP 21
10701: PUSH
10702: LD_EXP 21
10706: PPUSH
10707: CALL_OW 255
10711: PUSH
10712: LD_INT 2
10714: EQUAL
10715: AND
10716: IFFALSE 10746
// begin if ibrahimOnRuSide then
10718: LD_EXP 3
10722: IFFALSE 10734
// SaveVariable ( true , 04_2_IbrahimJoined ) ;
10724: LD_INT 1
10726: PPUSH
10727: LD_STRING 04_2_IbrahimJoined
10729: PPUSH
10730: CALL_OW 39
// SaveCharacters ( Ibrahim , 04_2_Ibrahim ) ;
10734: LD_EXP 21
10738: PPUSH
10739: LD_STRING 04_2_Ibrahim
10741: PPUSH
10742: CALL_OW 38
// end ; if Kamil then
10746: LD_EXP 22
10750: IFFALSE 10764
// SaveCharacters ( Kamil , 04_2_Kamil ) ;
10752: LD_EXP 22
10756: PPUSH
10757: LD_STRING 04_2_Kamil
10759: PPUSH
10760: CALL_OW 38
// if Sophia then
10764: LD_EXP 24
10768: IFFALSE 10782
// SaveCharacters ( Sophia , 04_2_Sophia ) ;
10770: LD_EXP 24
10774: PPUSH
10775: LD_STRING 04_2_Sophia
10777: PPUSH
10778: CALL_OW 38
// if Kaia then
10782: LD_EXP 23
10786: IFFALSE 10800
// SaveCharacters ( Kaia , 04_2_Kaia ) ;
10788: LD_EXP 23
10792: PPUSH
10793: LD_STRING 04_2_Kaia
10795: PPUSH
10796: CALL_OW 38
// if Givi then
10800: LD_EXP 19
10804: IFFALSE 10818
// SaveCharacters ( Givi , 04_2_Givi ) ;
10806: LD_EXP 19
10810: PPUSH
10811: LD_STRING 04_2_Givi
10813: PPUSH
10814: CALL_OW 38
// if Mike then
10818: LD_EXP 20
10822: IFFALSE 10836
// SaveCharacters ( Mike , 04_2_Mike ) ;
10824: LD_EXP 20
10828: PPUSH
10829: LD_STRING 04_2_Mike
10831: PPUSH
10832: CALL_OW 38
// if Markov then
10836: LD_EXP 25
10840: IFFALSE 10854
// SaveCharacters ( Markov , 04_2_Markov ) ;
10842: LD_EXP 25
10846: PPUSH
10847: LD_STRING 04_2_Markov
10849: PPUSH
10850: CALL_OW 38
// if Kurt then
10854: LD_EXP 27
10858: IFFALSE 10872
// SaveCharacters ( Kurt , 04_2_Kurt ) ;
10860: LD_EXP 27
10864: PPUSH
10865: LD_STRING 04_2_Kurt
10867: PPUSH
10868: CALL_OW 38
// if heikeSecondSquad then
10872: LD_EXP 29
10876: IFFALSE 10890
// SaveCharacters ( heikeSecondSquad , 04_2_others ) ;
10878: LD_EXP 29
10882: PPUSH
10883: LD_STRING 04_2_others
10885: PPUSH
10886: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
10890: LD_ADDR_VAR 0 1
10894: PUSH
10895: LD_INT 22
10897: PUSH
10898: LD_INT 2
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: PUSH
10905: LD_INT 23
10907: PUSH
10908: LD_INT 0
10910: PUSH
10911: EMPTY
10912: LIST
10913: LIST
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: PPUSH
10919: CALL_OW 69
10923: ST_TO_ADDR
// if tmp then
10924: LD_VAR 0 1
10928: IFFALSE 10942
// SaveCharacters ( tmp , 04_2_apes ) ;
10930: LD_VAR 0 1
10934: PPUSH
10935: LD_STRING 04_2_apes
10937: PPUSH
10938: CALL_OW 38
// YouWin ;
10942: CALL_OW 103
// end ;
10946: PPOPN 1
10948: END
