// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 45 0 0
// InitTag ;
   8: CALL 229 0 0
// PrepareNature ( natureArea ) ;
  12: LD_INT 2
  14: PPUSH
  15: CALL 704 0 1
// PrepareRussian ;
  19: CALL 3274 0 0
// PrepareArabian ;
  23: CALL 2626 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 2 ) ;
  33: LD_INT 2
  35: PPUSH
  36: CALL_OW 344
// Action ;
  40: CALL 6797 0 0
// end ;
  44: END
// export debug , prefix ; export ibrahimOnRuSide , ruEscapeAllowed , gameTime , loseCounter , flamethrowers , kaiaKilledByRussian , hannibalPath , ruEscapeCounter , baseHill , explodeFirstDepot , explodeSecondDepot , gaidarKilled , outerAreaAchived , earlyEscape ; function Init ; begin
  45: LD_INT 0
  47: PPUSH
// debug := false ;
  48: LD_ADDR_EXP 1
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// prefix := 04_1_ ;
  56: LD_ADDR_EXP 2
  60: PUSH
  61: LD_STRING 04_1_
  63: ST_TO_ADDR
// ibrahimOnRuSide := LoadVariable ( 03_IbrahimHasEscaped , false ) ;
  64: LD_ADDR_EXP 3
  68: PUSH
  69: LD_STRING 03_IbrahimHasEscaped
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: CALL_OW 30
  79: ST_TO_ADDR
// ruEscapeCounter := LoadVariable ( 04_1_EscapeCounter , 0 ) ;
  80: LD_ADDR_EXP 10
  84: PUSH
  85: LD_STRING 04_1_EscapeCounter
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// loseCounter := LoadVariable ( 04_1_DeadCounter , 0 ) ;
  96: LD_ADDR_EXP 6
 100: PUSH
 101: LD_STRING 04_1_DeadCounter
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// baseHill := LoadVariable ( 04_1_BaseHill , false ) ;
 112: LD_ADDR_EXP 11
 116: PUSH
 117: LD_STRING 04_1_BaseHill
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL_OW 30
 127: ST_TO_ADDR
// gameTime := LoadVariable ( 04_1_Time , 40 40$00 ) ;
 128: LD_ADDR_EXP 5
 132: PUSH
 133: LD_STRING 04_1_Time
 135: PPUSH
 136: LD_INT 84000
 138: PPUSH
 139: CALL_OW 30
 143: ST_TO_ADDR
// flamethrowers := LoadVariable ( 04_1_Flamethrower , 0 ) ;
 144: LD_ADDR_EXP 7
 148: PUSH
 149: LD_STRING 04_1_Flamethrower
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: CALL_OW 30
 159: ST_TO_ADDR
// ruEscapeAllowed := false ;
 160: LD_ADDR_EXP 4
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// explodeFirstDepot := false ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// explodeSecondDepot := false ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// gaidarKilled := false ;
 184: LD_ADDR_EXP 14
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// kaiaKilledByRussian := false ;
 192: LD_ADDR_EXP 8
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// outerAreaAchived := false ;
 200: LD_ADDR_EXP 15
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// hannibalPath := false ;
 208: LD_ADDR_EXP 9
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// earlyEscape := false ;
 216: LD_ADDR_EXP 16
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// export tEscape ; function InitTag ; begin
 229: LD_INT 0
 231: PPUSH
// tEscape := 10 ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: LD_INT 10
 239: ST_TO_ADDR
// end ;
 240: LD_VAR 0 1
 244: RET
// every 0 0$1 trigger debug do var i ;
 245: LD_EXP 1
 249: IFFALSE 333
 251: GO 253
 253: DISABLE
 254: LD_INT 0
 256: PPUSH
// begin enable ;
 257: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) do
 258: LD_ADDR_VAR 0 1
 262: PUSH
 263: LD_INT 22
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: LD_INT 21
 278: PUSH
 279: LD_INT 3
 281: PUSH
 282: EMPTY
 283: LIST
 284: LIST
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: FOR_IN
 300: IFFALSE 331
// if GetLives ( i ) < 1000 then
 302: LD_VAR 0 1
 306: PPUSH
 307: CALL_OW 256
 311: PUSH
 312: LD_INT 1000
 314: LESS
 315: IFFALSE 329
// SetLives ( i , 1000 ) ;
 317: LD_VAR 0 1
 321: PPUSH
 322: LD_INT 1000
 324: PPUSH
 325: CALL_OW 234
 329: GO 299
 331: POP
 332: POP
// end ; end_of_file
 333: PPOPN 1
 335: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 336: LD_INT 0
 338: PPUSH
 339: PPUSH
// if exist_mode then
 340: LD_VAR 0 2
 344: IFFALSE 369
// unit := CreateCharacter ( prefix & ident ) else
 346: LD_ADDR_VAR 0 5
 350: PUSH
 351: LD_VAR 0 3
 355: PUSH
 356: LD_VAR 0 1
 360: STR
 361: PPUSH
 362: CALL_OW 34
 366: ST_TO_ADDR
 367: GO 384
// unit := NewCharacter ( ident ) ;
 369: LD_ADDR_VAR 0 5
 373: PUSH
 374: LD_VAR 0 1
 378: PPUSH
 379: CALL_OW 25
 383: ST_TO_ADDR
// result := unit ;
 384: LD_ADDR_VAR 0 4
 388: PUSH
 389: LD_VAR 0 5
 393: ST_TO_ADDR
// end ;
 394: LD_VAR 0 4
 398: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 399: LD_INT 0
 401: PPUSH
// uc_side := side ;
 402: LD_ADDR_OWVAR 20
 406: PUSH
 407: LD_VAR 0 1
 411: ST_TO_ADDR
// uc_nation := nation ;
 412: LD_ADDR_OWVAR 21
 416: PUSH
 417: LD_VAR 0 2
 421: ST_TO_ADDR
// vc_chassis := chassis ;
 422: LD_ADDR_OWVAR 37
 426: PUSH
 427: LD_VAR 0 3
 431: ST_TO_ADDR
// vc_engine := engine ;
 432: LD_ADDR_OWVAR 39
 436: PUSH
 437: LD_VAR 0 4
 441: ST_TO_ADDR
// vc_control := control ;
 442: LD_ADDR_OWVAR 38
 446: PUSH
 447: LD_VAR 0 5
 451: ST_TO_ADDR
// vc_weapon := weapon ;
 452: LD_ADDR_OWVAR 40
 456: PUSH
 457: LD_VAR 0 6
 461: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 462: LD_ADDR_OWVAR 41
 466: PUSH
 467: LD_VAR 0 7
 471: ST_TO_ADDR
// result := CreateVehicle ;
 472: LD_ADDR_VAR 0 8
 476: PUSH
 477: CALL_OW 45
 481: ST_TO_ADDR
// end ;
 482: LD_VAR 0 8
 486: RET
// export function SayX ( units , ident ) ; var i ; begin
 487: LD_INT 0
 489: PPUSH
 490: PPUSH
// result := false ;
 491: LD_ADDR_VAR 0 3
 495: PUSH
 496: LD_INT 0
 498: ST_TO_ADDR
// if not units then
 499: LD_VAR 0 1
 503: NOT
 504: IFFALSE 508
// exit ;
 506: GO 562
// for i in units do
 508: LD_ADDR_VAR 0 4
 512: PUSH
 513: LD_VAR 0 1
 517: PUSH
 518: FOR_IN
 519: IFFALSE 560
// if IsOk ( i ) then
 521: LD_VAR 0 4
 525: PPUSH
 526: CALL_OW 302
 530: IFFALSE 558
// begin Say ( i , ident ) ;
 532: LD_VAR 0 4
 536: PPUSH
 537: LD_VAR 0 2
 541: PPUSH
 542: CALL_OW 88
// result := i ;
 546: LD_ADDR_VAR 0 3
 550: PUSH
 551: LD_VAR 0 4
 555: ST_TO_ADDR
// break ;
 556: GO 560
// end ;
 558: GO 518
 560: POP
 561: POP
// end ;
 562: LD_VAR 0 3
 566: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 567: LD_INT 0
 569: PPUSH
 570: PPUSH
// InitUc ;
 571: CALL_OW 18
// InitHc ;
 575: CALL_OW 19
// uc_side := 0 ;
 579: LD_ADDR_OWVAR 20
 583: PUSH
 584: LD_INT 0
 586: ST_TO_ADDR
// uc_nation := 0 ;
 587: LD_ADDR_OWVAR 21
 591: PUSH
 592: LD_INT 0
 594: ST_TO_ADDR
// for i = 1 to amount do
 595: LD_ADDR_VAR 0 4
 599: PUSH
 600: DOUBLE
 601: LD_INT 1
 603: DEC
 604: ST_TO_ADDR
 605: LD_VAR 0 2
 609: PUSH
 610: FOR_TO
 611: IFFALSE 693
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 613: LD_ADDR_OWVAR 29
 617: PUSH
 618: LD_INT 9
 620: PPUSH
 621: LD_INT 12
 623: PPUSH
 624: CALL_OW 12
 628: PUSH
 629: LD_INT 9
 631: PPUSH
 632: LD_INT 12
 634: PPUSH
 635: CALL_OW 12
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 644: LD_ADDR_OWVAR 35
 648: PUSH
 649: LD_INT 1
 651: NEG
 652: PPUSH
 653: LD_INT 1
 655: PPUSH
 656: CALL_OW 12
 660: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 661: LD_INT 0
 663: PPUSH
 664: LD_INT 12
 666: PPUSH
 667: LD_INT 1
 669: PPUSH
 670: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 674: CALL_OW 44
 678: PPUSH
 679: LD_VAR 0 1
 683: PPUSH
 684: LD_INT 0
 686: PPUSH
 687: CALL_OW 49
// end ;
 691: GO 610
 693: POP
 694: POP
// InitHc ;
 695: CALL_OW 19
// end ;
 699: LD_VAR 0 3
 703: RET
// export function PrepareNature ( forest ) ; var i ; begin
 704: LD_INT 0
 706: PPUSH
 707: PPUSH
// SpawnApeman ( forest , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
 708: LD_VAR 0 1
 712: PPUSH
 713: LD_INT 3
 715: PUSH
 716: LD_INT 3
 718: PUSH
 719: LD_INT 2
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_OWVAR 67
 731: ARRAY
 732: PPUSH
 733: CALL 567 0 2
// for i := 1 to 2 do
 737: LD_ADDR_VAR 0 3
 741: PUSH
 742: DOUBLE
 743: LD_INT 1
 745: DEC
 746: ST_TO_ADDR
 747: LD_INT 2
 749: PUSH
 750: FOR_TO
 751: IFFALSE 788
// begin hc_class := 21 ;
 753: LD_ADDR_OWVAR 28
 757: PUSH
 758: LD_INT 21
 760: ST_TO_ADDR
// hc_gallery :=  ;
 761: LD_ADDR_OWVAR 33
 765: PUSH
 766: LD_STRING 
 768: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 769: CALL_OW 44
 773: PPUSH
 774: LD_VAR 0 1
 778: PPUSH
 779: LD_INT 0
 781: PPUSH
 782: CALL_OW 49
// end ;
 786: GO 750
 788: POP
 789: POP
// for i := 1 to 2 do
 790: LD_ADDR_VAR 0 3
 794: PUSH
 795: DOUBLE
 796: LD_INT 1
 798: DEC
 799: ST_TO_ADDR
 800: LD_INT 2
 802: PUSH
 803: FOR_TO
 804: IFFALSE 841
// begin hc_class := 18 ;
 806: LD_ADDR_OWVAR 28
 810: PUSH
 811: LD_INT 18
 813: ST_TO_ADDR
// hc_gallery :=  ;
 814: LD_ADDR_OWVAR 33
 818: PUSH
 819: LD_STRING 
 821: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 822: CALL_OW 44
 826: PPUSH
 827: LD_VAR 0 1
 831: PPUSH
 832: LD_INT 0
 834: PPUSH
 835: CALL_OW 49
// end ;
 839: GO 803
 841: POP
 842: POP
// for i := 1 to 2 do
 843: LD_ADDR_VAR 0 3
 847: PUSH
 848: DOUBLE
 849: LD_INT 1
 851: DEC
 852: ST_TO_ADDR
 853: LD_INT 2
 855: PUSH
 856: FOR_TO
 857: IFFALSE 894
// begin hc_class := 13 ;
 859: LD_ADDR_OWVAR 28
 863: PUSH
 864: LD_INT 13
 866: ST_TO_ADDR
// hc_gallery :=  ;
 867: LD_ADDR_OWVAR 33
 871: PUSH
 872: LD_STRING 
 874: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 875: CALL_OW 44
 879: PPUSH
 880: LD_VAR 0 1
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// end ;
 892: GO 856
 894: POP
 895: POP
// end ;
 896: LD_VAR 0 2
 900: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 901: LD_INT 0
 903: PPUSH
 904: PPUSH
 905: PPUSH
// if not observer or not unit then
 906: LD_VAR 0 1
 910: NOT
 911: PUSH
 912: LD_VAR 0 2
 916: NOT
 917: OR
 918: IFFALSE 922
// exit ;
 920: GO 970
// if not See ( GetSide ( observer ) , unit ) then
 922: LD_VAR 0 1
 926: PPUSH
 927: CALL_OW 255
 931: PPUSH
 932: LD_VAR 0 2
 936: PPUSH
 937: CALL_OW 292
 941: NOT
 942: IFFALSE 946
// exit ;
 944: GO 970
// result := GetDistUnits ( observer , unit ) < 12 ;
 946: LD_ADDR_VAR 0 3
 950: PUSH
 951: LD_VAR 0 1
 955: PPUSH
 956: LD_VAR 0 2
 960: PPUSH
 961: CALL_OW 296
 965: PUSH
 966: LD_INT 12
 968: LESS
 969: ST_TO_ADDR
// end ;
 970: LD_VAR 0 3
 974: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 975: LD_INT 0
 977: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 978: LD_VAR 0 2
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: LD_VAR 0 2
 991: PUSH
 992: LD_INT 2
 994: ARRAY
 995: PPUSH
 996: CALL_OW 488
1000: PUSH
1001: LD_VAR 0 2
1005: PUSH
1006: LD_INT 1
1008: ARRAY
1009: PPUSH
1010: LD_VAR 0 2
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 428
1023: PUSH
1024: LD_INT 0
1026: EQUAL
1027: AND
1028: IFFALSE 1062
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
1030: LD_VAR 0 1
1034: PPUSH
1035: LD_VAR 0 2
1039: PUSH
1040: LD_INT 1
1042: ARRAY
1043: PPUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_INT 2
1051: ARRAY
1052: PPUSH
1053: LD_VAR 0 3
1057: PPUSH
1058: CALL_OW 48
// end ;
1062: LD_VAR 0 4
1066: RET
// export function Video ( mode ) ; begin
1067: LD_INT 0
1069: PPUSH
// ingame_video = mode ;
1070: LD_ADDR_OWVAR 52
1074: PUSH
1075: LD_VAR 0 1
1079: ST_TO_ADDR
// interface_hidden = mode ;
1080: LD_ADDR_OWVAR 54
1084: PUSH
1085: LD_VAR 0 1
1089: ST_TO_ADDR
// end ;
1090: LD_VAR 0 2
1094: RET
// export function ReverseArray ( array ) ; var i ; begin
1095: LD_INT 0
1097: PPUSH
1098: PPUSH
// if not array then
1099: LD_VAR 0 1
1103: NOT
1104: IFFALSE 1108
// exit ;
1106: GO 1166
// result := [ ] ;
1108: LD_ADDR_VAR 0 2
1112: PUSH
1113: EMPTY
1114: ST_TO_ADDR
// for i := 1 to array do
1115: LD_ADDR_VAR 0 3
1119: PUSH
1120: DOUBLE
1121: LD_INT 1
1123: DEC
1124: ST_TO_ADDR
1125: LD_VAR 0 1
1129: PUSH
1130: FOR_TO
1131: IFFALSE 1164
// result := Insert ( result , 1 , array [ i ] ) ;
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 2
1142: PPUSH
1143: LD_INT 1
1145: PPUSH
1146: LD_VAR 0 1
1150: PUSH
1151: LD_VAR 0 3
1155: ARRAY
1156: PPUSH
1157: CALL_OW 2
1161: ST_TO_ADDR
1162: GO 1130
1164: POP
1165: POP
// end ;
1166: LD_VAR 0 2
1170: RET
// export function ComExit ( unit ) ; begin
1171: LD_INT 0
1173: PPUSH
// result := IsInUnit ( unit ) ;
1174: LD_ADDR_VAR 0 2
1178: PUSH
1179: LD_VAR 0 1
1183: PPUSH
1184: CALL_OW 310
1188: ST_TO_ADDR
// if not result then
1189: LD_VAR 0 2
1193: NOT
1194: IFFALSE 1198
// exit ;
1196: GO 1233
// if GetType ( result ) = unit_vehicle then
1198: LD_VAR 0 2
1202: PPUSH
1203: CALL_OW 247
1207: PUSH
1208: LD_INT 2
1210: EQUAL
1211: IFFALSE 1224
// ComExitVehicle ( unit ) else
1213: LD_VAR 0 1
1217: PPUSH
1218: CALL_OW 121
1222: GO 1233
// ComExitBuilding ( unit ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: CALL_OW 122
// end ;
1233: LD_VAR 0 2
1237: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1238: LD_INT 0
1240: PPUSH
1241: PPUSH
// if not side or not nation then
1242: LD_VAR 0 1
1246: NOT
1247: PUSH
1248: LD_VAR 0 2
1252: NOT
1253: OR
1254: IFFALSE 1258
// exit ;
1256: GO 2022
// case nation of nation_american :
1258: LD_VAR 0 2
1262: PUSH
1263: LD_INT 1
1265: DOUBLE
1266: EQUAL
1267: IFTRUE 1271
1269: GO 1485
1271: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1272: LD_ADDR_VAR 0 4
1276: PUSH
1277: LD_INT 35
1279: PUSH
1280: LD_INT 45
1282: PUSH
1283: LD_INT 46
1285: PUSH
1286: LD_INT 47
1288: PUSH
1289: LD_INT 82
1291: PUSH
1292: LD_INT 83
1294: PUSH
1295: LD_INT 84
1297: PUSH
1298: LD_INT 85
1300: PUSH
1301: LD_INT 86
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: LD_INT 2
1309: PUSH
1310: LD_INT 6
1312: PUSH
1313: LD_INT 15
1315: PUSH
1316: LD_INT 16
1318: PUSH
1319: LD_INT 7
1321: PUSH
1322: LD_INT 12
1324: PUSH
1325: LD_INT 13
1327: PUSH
1328: LD_INT 10
1330: PUSH
1331: LD_INT 14
1333: PUSH
1334: LD_INT 20
1336: PUSH
1337: LD_INT 21
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_INT 25
1345: PUSH
1346: LD_INT 32
1348: PUSH
1349: LD_INT 27
1351: PUSH
1352: LD_INT 36
1354: PUSH
1355: LD_INT 69
1357: PUSH
1358: LD_INT 39
1360: PUSH
1361: LD_INT 34
1363: PUSH
1364: LD_INT 40
1366: PUSH
1367: LD_INT 48
1369: PUSH
1370: LD_INT 49
1372: PUSH
1373: LD_INT 50
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 52
1381: PUSH
1382: LD_INT 53
1384: PUSH
1385: LD_INT 54
1387: PUSH
1388: LD_INT 55
1390: PUSH
1391: LD_INT 56
1393: PUSH
1394: LD_INT 57
1396: PUSH
1397: LD_INT 58
1399: PUSH
1400: LD_INT 59
1402: PUSH
1403: LD_INT 60
1405: PUSH
1406: LD_INT 61
1408: PUSH
1409: LD_INT 62
1411: PUSH
1412: LD_INT 80
1414: PUSH
1415: LD_INT 82
1417: PUSH
1418: LD_INT 83
1420: PUSH
1421: LD_INT 84
1423: PUSH
1424: LD_INT 85
1426: PUSH
1427: LD_INT 86
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: ST_TO_ADDR
1483: GO 1946
1485: LD_INT 2
1487: DOUBLE
1488: EQUAL
1489: IFTRUE 1493
1491: GO 1715
1493: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_INT 35
1501: PUSH
1502: LD_INT 45
1504: PUSH
1505: LD_INT 46
1507: PUSH
1508: LD_INT 47
1510: PUSH
1511: LD_INT 82
1513: PUSH
1514: LD_INT 83
1516: PUSH
1517: LD_INT 84
1519: PUSH
1520: LD_INT 85
1522: PUSH
1523: LD_INT 87
1525: PUSH
1526: LD_INT 70
1528: PUSH
1529: LD_INT 1
1531: PUSH
1532: LD_INT 11
1534: PUSH
1535: LD_INT 3
1537: PUSH
1538: LD_INT 4
1540: PUSH
1541: LD_INT 5
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: LD_INT 15
1549: PUSH
1550: LD_INT 18
1552: PUSH
1553: LD_INT 7
1555: PUSH
1556: LD_INT 17
1558: PUSH
1559: LD_INT 8
1561: PUSH
1562: LD_INT 20
1564: PUSH
1565: LD_INT 21
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: LD_INT 72
1573: PUSH
1574: LD_INT 26
1576: PUSH
1577: LD_INT 69
1579: PUSH
1580: LD_INT 39
1582: PUSH
1583: LD_INT 40
1585: PUSH
1586: LD_INT 41
1588: PUSH
1589: LD_INT 42
1591: PUSH
1592: LD_INT 43
1594: PUSH
1595: LD_INT 48
1597: PUSH
1598: LD_INT 49
1600: PUSH
1601: LD_INT 50
1603: PUSH
1604: LD_INT 51
1606: PUSH
1607: LD_INT 52
1609: PUSH
1610: LD_INT 53
1612: PUSH
1613: LD_INT 54
1615: PUSH
1616: LD_INT 55
1618: PUSH
1619: LD_INT 56
1621: PUSH
1622: LD_INT 60
1624: PUSH
1625: LD_INT 61
1627: PUSH
1628: LD_INT 62
1630: PUSH
1631: LD_INT 66
1633: PUSH
1634: LD_INT 67
1636: PUSH
1637: LD_INT 68
1639: PUSH
1640: LD_INT 81
1642: PUSH
1643: LD_INT 82
1645: PUSH
1646: LD_INT 83
1648: PUSH
1649: LD_INT 84
1651: PUSH
1652: LD_INT 85
1654: PUSH
1655: LD_INT 87
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: LIST
1711: LIST
1712: ST_TO_ADDR
1713: GO 1946
1715: LD_INT 3
1717: DOUBLE
1718: EQUAL
1719: IFTRUE 1723
1721: GO 1945
1723: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_INT 46
1731: PUSH
1732: LD_INT 47
1734: PUSH
1735: LD_INT 1
1737: PUSH
1738: LD_INT 2
1740: PUSH
1741: LD_INT 82
1743: PUSH
1744: LD_INT 83
1746: PUSH
1747: LD_INT 84
1749: PUSH
1750: LD_INT 85
1752: PUSH
1753: LD_INT 86
1755: PUSH
1756: LD_INT 11
1758: PUSH
1759: LD_INT 9
1761: PUSH
1762: LD_INT 20
1764: PUSH
1765: LD_INT 19
1767: PUSH
1768: LD_INT 21
1770: PUSH
1771: LD_INT 24
1773: PUSH
1774: LD_INT 22
1776: PUSH
1777: LD_INT 25
1779: PUSH
1780: LD_INT 28
1782: PUSH
1783: LD_INT 29
1785: PUSH
1786: LD_INT 30
1788: PUSH
1789: LD_INT 31
1791: PUSH
1792: LD_INT 37
1794: PUSH
1795: LD_INT 38
1797: PUSH
1798: LD_INT 32
1800: PUSH
1801: LD_INT 27
1803: PUSH
1804: LD_INT 33
1806: PUSH
1807: LD_INT 69
1809: PUSH
1810: LD_INT 39
1812: PUSH
1813: LD_INT 34
1815: PUSH
1816: LD_INT 40
1818: PUSH
1819: LD_INT 71
1821: PUSH
1822: LD_INT 23
1824: PUSH
1825: LD_INT 44
1827: PUSH
1828: LD_INT 48
1830: PUSH
1831: LD_INT 49
1833: PUSH
1834: LD_INT 50
1836: PUSH
1837: LD_INT 51
1839: PUSH
1840: LD_INT 52
1842: PUSH
1843: LD_INT 53
1845: PUSH
1846: LD_INT 54
1848: PUSH
1849: LD_INT 55
1851: PUSH
1852: LD_INT 56
1854: PUSH
1855: LD_INT 57
1857: PUSH
1858: LD_INT 58
1860: PUSH
1861: LD_INT 59
1863: PUSH
1864: LD_INT 63
1866: PUSH
1867: LD_INT 64
1869: PUSH
1870: LD_INT 65
1872: PUSH
1873: LD_INT 82
1875: PUSH
1876: LD_INT 83
1878: PUSH
1879: LD_INT 84
1881: PUSH
1882: LD_INT 85
1884: PUSH
1885: LD_INT 86
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: ST_TO_ADDR
1943: GO 1946
1945: POP
// if state > - 1 and state < 3 then
1946: LD_VAR 0 3
1950: PUSH
1951: LD_INT 1
1953: NEG
1954: GREATER
1955: PUSH
1956: LD_VAR 0 3
1960: PUSH
1961: LD_INT 3
1963: LESS
1964: AND
1965: IFFALSE 2022
// for i in result do
1967: LD_ADDR_VAR 0 5
1971: PUSH
1972: LD_VAR 0 4
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2020
// if GetTech ( i , side ) <> state then
1980: LD_VAR 0 5
1984: PPUSH
1985: LD_VAR 0 1
1989: PPUSH
1990: CALL_OW 321
1994: PUSH
1995: LD_VAR 0 3
1999: NONEQUAL
2000: IFFALSE 2018
// result := result diff i ;
2002: LD_ADDR_VAR 0 4
2006: PUSH
2007: LD_VAR 0 4
2011: PUSH
2012: LD_VAR 0 5
2016: DIFF
2017: ST_TO_ADDR
2018: GO 1977
2020: POP
2021: POP
// end ;
2022: LD_VAR 0 4
2026: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
2027: LD_INT 0
2029: PPUSH
2030: PPUSH
2031: PPUSH
2032: PPUSH
// if not list then
2033: LD_VAR 0 3
2037: NOT
2038: IFFALSE 2042
// exit ;
2040: GO 2350
// result := [ ] ;
2042: LD_ADDR_VAR 0 5
2046: PUSH
2047: EMPTY
2048: ST_TO_ADDR
// for i in list do
2049: LD_ADDR_VAR 0 6
2053: PUSH
2054: LD_VAR 0 3
2058: PUSH
2059: FOR_IN
2060: IFFALSE 2262
// begin tmp := GetDistUnitXY ( i , x , y ) ;
2062: LD_ADDR_VAR 0 8
2066: PUSH
2067: LD_VAR 0 6
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: LD_VAR 0 2
2081: PPUSH
2082: CALL_OW 297
2086: ST_TO_ADDR
// if not result then
2087: LD_VAR 0 5
2091: NOT
2092: IFFALSE 2118
// result := [ [ i , tmp ] ] else
2094: LD_ADDR_VAR 0 5
2098: PUSH
2099: LD_VAR 0 6
2103: PUSH
2104: LD_VAR 0 8
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: EMPTY
2114: LIST
2115: ST_TO_ADDR
2116: GO 2260
// begin if result [ result ] [ 2 ] < tmp then
2118: LD_VAR 0 5
2122: PUSH
2123: LD_VAR 0 5
2127: ARRAY
2128: PUSH
2129: LD_INT 2
2131: ARRAY
2132: PUSH
2133: LD_VAR 0 8
2137: LESS
2138: IFFALSE 2180
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
2140: LD_ADDR_VAR 0 5
2144: PUSH
2145: LD_VAR 0 5
2149: PPUSH
2150: LD_VAR 0 5
2154: PUSH
2155: LD_INT 1
2157: PLUS
2158: PPUSH
2159: LD_VAR 0 6
2163: PUSH
2164: LD_VAR 0 8
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PPUSH
2173: CALL_OW 2
2177: ST_TO_ADDR
2178: GO 2260
// for j = 1 to result do
2180: LD_ADDR_VAR 0 7
2184: PUSH
2185: DOUBLE
2186: LD_INT 1
2188: DEC
2189: ST_TO_ADDR
2190: LD_VAR 0 5
2194: PUSH
2195: FOR_TO
2196: IFFALSE 2258
// begin if tmp < result [ j ] [ 2 ] then
2198: LD_VAR 0 8
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_VAR 0 7
2212: ARRAY
2213: PUSH
2214: LD_INT 2
2216: ARRAY
2217: LESS
2218: IFFALSE 2256
// begin result := Insert ( result , j , [ i , tmp ] ) ;
2220: LD_ADDR_VAR 0 5
2224: PUSH
2225: LD_VAR 0 5
2229: PPUSH
2230: LD_VAR 0 7
2234: PPUSH
2235: LD_VAR 0 6
2239: PUSH
2240: LD_VAR 0 8
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PPUSH
2249: CALL_OW 2
2253: ST_TO_ADDR
// break ;
2254: GO 2258
// end ; end ;
2256: GO 2195
2258: POP
2259: POP
// end ; end ;
2260: GO 2059
2262: POP
2263: POP
// if result and not asc then
2264: LD_VAR 0 5
2268: PUSH
2269: LD_VAR 0 4
2273: NOT
2274: AND
2275: IFFALSE 2350
// begin tmp := result ;
2277: LD_ADDR_VAR 0 8
2281: PUSH
2282: LD_VAR 0 5
2286: ST_TO_ADDR
// for i = tmp downto 1 do
2287: LD_ADDR_VAR 0 6
2291: PUSH
2292: DOUBLE
2293: LD_VAR 0 8
2297: INC
2298: ST_TO_ADDR
2299: LD_INT 1
2301: PUSH
2302: FOR_DOWNTO
2303: IFFALSE 2348
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PPUSH
2315: LD_VAR 0 8
2319: PUSH
2320: LD_VAR 0 6
2324: MINUS
2325: PUSH
2326: LD_INT 1
2328: PLUS
2329: PPUSH
2330: LD_VAR 0 8
2334: PUSH
2335: LD_VAR 0 6
2339: ARRAY
2340: PPUSH
2341: CALL_OW 1
2345: ST_TO_ADDR
2346: GO 2302
2348: POP
2349: POP
// end ; end ;
2350: LD_VAR 0 5
2354: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
2355: LD_INT 0
2357: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
2358: LD_ADDR_VAR 0 4
2362: PUSH
2363: LD_VAR 0 1
2367: PPUSH
2368: CALL_OW 250
2372: PPUSH
2373: LD_VAR 0 1
2377: PPUSH
2378: CALL_OW 251
2382: PPUSH
2383: LD_VAR 0 2
2387: PPUSH
2388: LD_VAR 0 3
2392: PPUSH
2393: CALL 2027 0 4
2397: ST_TO_ADDR
// end ;
2398: LD_VAR 0 4
2402: RET
// export function NearestEmptyBuilding ( unit , btype ) ; var side , tmp , i , places ; begin
2403: LD_INT 0
2405: PPUSH
2406: PPUSH
2407: PPUSH
2408: PPUSH
2409: PPUSH
// if not unit then
2410: LD_VAR 0 1
2414: NOT
2415: IFFALSE 2419
// exit ;
2417: GO 2621
// side := GetSide ( unit ) ;
2419: LD_ADDR_VAR 0 4
2423: PUSH
2424: LD_VAR 0 1
2428: PPUSH
2429: CALL_OW 255
2433: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
2434: LD_ADDR_VAR 0 5
2438: PUSH
2439: LD_INT 22
2441: PUSH
2442: LD_VAR 0 4
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: PUSH
2451: LD_INT 30
2453: PUSH
2454: LD_VAR 0 2
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PPUSH
2467: CALL_OW 69
2471: ST_TO_ADDR
// if not tmp then
2472: LD_VAR 0 5
2476: NOT
2477: IFFALSE 2481
// exit ;
2479: GO 2621
// tmp := SortByDistanceUnit ( unit , tmp , true ) ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 1
2490: PPUSH
2491: LD_VAR 0 5
2495: PPUSH
2496: LD_INT 1
2498: PPUSH
2499: CALL 2355 0 3
2503: ST_TO_ADDR
// places := 1 ;
2504: LD_ADDR_VAR 0 7
2508: PUSH
2509: LD_INT 1
2511: ST_TO_ADDR
// if btype in [ b_depot , b_warehouse , b_armoury , b_barracks , b_workshop , b_factory , b_lab , b_lab_half , b_lab_full ] then
2512: LD_VAR 0 2
2516: PUSH
2517: LD_INT 0
2519: PUSH
2520: LD_INT 1
2522: PUSH
2523: LD_INT 4
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: LD_INT 2
2531: PUSH
2532: LD_INT 3
2534: PUSH
2535: LD_INT 6
2537: PUSH
2538: LD_INT 7
2540: PUSH
2541: LD_INT 8
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: LIST
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: IN
2555: IFFALSE 2565
// places := 6 ;
2557: LD_ADDR_VAR 0 7
2561: PUSH
2562: LD_INT 6
2564: ST_TO_ADDR
// for i in tmp do
2565: LD_ADDR_VAR 0 6
2569: PUSH
2570: LD_VAR 0 5
2574: PUSH
2575: FOR_IN
2576: IFFALSE 2619
// begin if UnitsInside ( i ) - places <= 0 then
2578: LD_VAR 0 6
2582: PPUSH
2583: CALL_OW 313
2587: PUSH
2588: LD_VAR 0 7
2592: MINUS
2593: PUSH
2594: LD_INT 0
2596: LESSEQUAL
2597: IFFALSE 2603
// continue else
2599: GO 2575
2601: GO 2617
// begin result := i ;
2603: LD_ADDR_VAR 0 3
2607: PUSH
2608: LD_VAR 0 6
2612: ST_TO_ADDR
// exit ;
2613: POP
2614: POP
2615: GO 2621
// end ; end ;
2617: GO 2575
2619: POP
2620: POP
// end ; end_of_file
2621: LD_VAR 0 3
2625: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Shariff , Kurt , Aviradze , heikeSecondSquad , heikeVehicles , heikeApes ; export function PrepareArabian ; var i ; begin
2626: LD_INT 0
2628: PPUSH
2629: PPUSH
// uc_side := 2 ;
2630: LD_ADDR_OWVAR 20
2634: PUSH
2635: LD_INT 2
2637: ST_TO_ADDR
// uc_nation := 2 ;
2638: LD_ADDR_OWVAR 21
2642: PUSH
2643: LD_INT 2
2645: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2646: LD_ADDR_EXP 18
2650: PUSH
2651: LD_STRING Heike
2653: PPUSH
2654: LD_EXP 1
2658: NOT
2659: PPUSH
2660: LD_EXP 2
2664: PPUSH
2665: CALL 336 0 3
2669: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
2670: LD_ADDR_EXP 21
2674: PUSH
2675: LD_STRING Ibrahim
2677: PPUSH
2678: LD_EXP 1
2682: NOT
2683: PPUSH
2684: LD_EXP 2
2688: PPUSH
2689: CALL 336 0 3
2693: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2694: LD_ADDR_EXP 19
2698: PUSH
2699: LD_STRING Givi
2701: PPUSH
2702: LD_EXP 1
2706: NOT
2707: PPUSH
2708: LD_EXP 2
2712: PPUSH
2713: CALL 336 0 3
2717: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2718: LD_ADDR_EXP 22
2722: PUSH
2723: LD_STRING Kamil
2725: PPUSH
2726: LD_EXP 1
2730: NOT
2731: PPUSH
2732: LD_EXP 2
2736: PPUSH
2737: CALL 336 0 3
2741: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2742: LD_ADDR_EXP 23
2746: PUSH
2747: LD_STRING Kaia
2749: PPUSH
2750: LD_EXP 1
2754: NOT
2755: PPUSH
2756: LD_EXP 2
2760: PPUSH
2761: CALL 336 0 3
2765: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2766: LD_ADDR_EXP 24
2770: PUSH
2771: LD_STRING Sophia
2773: PPUSH
2774: LD_EXP 1
2778: NOT
2779: PPUSH
2780: LD_EXP 2
2784: PPUSH
2785: CALL 336 0 3
2789: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2790: LD_ADDR_EXP 25
2794: PUSH
2795: LD_STRING Markov
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_EXP 2
2808: PPUSH
2809: CALL 336 0 3
2813: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2814: LD_ADDR_EXP 28
2818: PUSH
2819: LD_STRING Aviradze
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_EXP 2
2832: PPUSH
2833: CALL 336 0 3
2837: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , ( not debug ) , prefix ) ;
2838: LD_ADDR_EXP 27
2842: PUSH
2843: LD_STRING Kurt
2845: PPUSH
2846: LD_EXP 1
2850: NOT
2851: PPUSH
2852: LD_EXP 2
2856: PPUSH
2857: CALL 336 0 3
2861: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2862: LD_ADDR_EXP 20
2866: PUSH
2867: LD_STRING Mike
2869: PPUSH
2870: LD_EXP 1
2874: NOT
2875: PPUSH
2876: LD_EXP 2
2880: PPUSH
2881: CALL 336 0 3
2885: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_1_others ) ;
2886: LD_ADDR_EXP 29
2890: PUSH
2891: LD_STRING 04_1_others
2893: PPUSH
2894: CALL_OW 31
2898: ST_TO_ADDR
// heikeApes := CreateCharacterSet ( 04_1_apes ) ;
2899: LD_ADDR_EXP 31
2903: PUSH
2904: LD_STRING 04_1_apes
2906: PPUSH
2907: CALL_OW 31
2911: ST_TO_ADDR
// heikeVehicles := LoadVariable ( 04_1_Vehicles , [ ] ) ;
2912: LD_ADDR_EXP 30
2916: PUSH
2917: LD_STRING 04_1_Vehicles
2919: PPUSH
2920: EMPTY
2921: PPUSH
2922: CALL_OW 30
2926: ST_TO_ADDR
// uc_side := 5 ;
2927: LD_ADDR_OWVAR 20
2931: PUSH
2932: LD_INT 5
2934: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
2935: LD_ADDR_EXP 26
2939: PUSH
2940: LD_STRING Abdul
2942: PPUSH
2943: LD_INT 0
2945: PPUSH
2946: LD_STRING 
2948: PPUSH
2949: CALL 336 0 3
2953: ST_TO_ADDR
// end ;
2954: LD_VAR 0 1
2958: RET
// export cargoDriver ; every 2 2$00 trigger LoadVariable ( 04_1_KaganCaptured , 0 ) and not FilterAllUnits ( [ f_side , 5 ] ) and ( HexInfo ( 124 , 26 ) = 0 xor GetSide ( HexInfo ( 124 , 26 ) ) = 2 ) do var veh ;
2959: LD_STRING 04_1_KaganCaptured
2961: PPUSH
2962: LD_INT 0
2964: PPUSH
2965: CALL_OW 30
2969: PUSH
2970: LD_INT 22
2972: PUSH
2973: LD_INT 5
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: PPUSH
2980: CALL_OW 69
2984: NOT
2985: AND
2986: PUSH
2987: LD_INT 124
2989: PPUSH
2990: LD_INT 26
2992: PPUSH
2993: CALL_OW 428
2997: PUSH
2998: LD_INT 0
3000: EQUAL
3001: PUSH
3002: LD_INT 124
3004: PPUSH
3005: LD_INT 26
3007: PPUSH
3008: CALL_OW 428
3012: PPUSH
3013: CALL_OW 255
3017: PUSH
3018: LD_INT 2
3020: EQUAL
3021: XOR
3022: AND
3023: IFFALSE 3271
3025: GO 3027
3027: DISABLE
3028: LD_INT 0
3030: PPUSH
// begin enable ;
3031: ENABLE
// uc_side := 5 ;
3032: LD_ADDR_OWVAR 20
3036: PUSH
3037: LD_INT 5
3039: ST_TO_ADDR
// uc_nation := 2 ;
3040: LD_ADDR_OWVAR 21
3044: PUSH
3045: LD_INT 2
3047: ST_TO_ADDR
// PrepareTank ( 5 , 2 , ar_medium_trike , engine_solar , control_manual , ar_cargo_bay , 70 ) ;
3048: LD_INT 5
3050: PPUSH
3051: LD_INT 2
3053: PPUSH
3054: LD_INT 13
3056: PPUSH
3057: LD_INT 2
3059: PPUSH
3060: LD_INT 1
3062: PPUSH
3063: LD_INT 32
3065: PPUSH
3066: LD_INT 70
3068: PPUSH
3069: CALL 399 0 7
// veh := CreateVehicle ;
3073: LD_ADDR_VAR 0 1
3077: PUSH
3078: CALL_OW 45
3082: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3083: LD_VAR 0 1
3087: PPUSH
3088: LD_INT 3
3090: PPUSH
3091: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
3095: LD_VAR 0 1
3099: PPUSH
3100: LD_INT 8
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 49
// if not cargoDriver then
3110: LD_EXP 32
3114: NOT
3115: IFFALSE 3140
// begin PrepareHuman ( false , 1 , 3 ) ;
3117: LD_INT 0
3119: PPUSH
3120: LD_INT 1
3122: PPUSH
3123: LD_INT 3
3125: PPUSH
3126: CALL_OW 380
// cargoDriver := CreateHuman ;
3130: LD_ADDR_EXP 32
3134: PUSH
3135: CALL_OW 44
3139: ST_TO_ADDR
// end ; PlaceHumanInUnit ( cargoDriver , veh ) ;
3140: LD_EXP 32
3144: PPUSH
3145: LD_VAR 0 1
3149: PPUSH
3150: CALL_OW 52
// SetCargo ( veh , mat_oil , 100 ) ;
3154: LD_VAR 0 1
3158: PPUSH
3159: LD_INT 2
3161: PPUSH
3162: LD_INT 100
3164: PPUSH
3165: CALL_OW 290
// ComMoveXY ( veh , 142 , 15 ) ;
3169: LD_VAR 0 1
3173: PPUSH
3174: LD_INT 142
3176: PPUSH
3177: LD_INT 15
3179: PPUSH
3180: CALL_OW 111
// AddComUnload ( veh ) ;
3184: LD_VAR 0 1
3188: PPUSH
3189: CALL_OW 219
// AddComMoveXY ( veh , 133 , 2 ) ;
3193: LD_VAR 0 1
3197: PPUSH
3198: LD_INT 133
3200: PPUSH
3201: LD_INT 2
3203: PPUSH
3204: CALL_OW 171
// wait ( 0 0$5 ) ;
3208: LD_INT 175
3210: PPUSH
3211: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
3215: LD_INT 35
3217: PPUSH
3218: CALL_OW 67
// until IsAt ( veh , 133 , 2 ) or IsInArea ( veh , spawnArea ) ;
3222: LD_VAR 0 1
3226: PPUSH
3227: LD_INT 133
3229: PPUSH
3230: LD_INT 2
3232: PPUSH
3233: CALL_OW 307
3237: PUSH
3238: LD_VAR 0 1
3242: PPUSH
3243: LD_INT 8
3245: PPUSH
3246: CALL_OW 308
3250: OR
3251: IFFALSE 3215
// RemoveUnit ( cargoDriver ) ;
3253: LD_EXP 32
3257: PPUSH
3258: CALL_OW 64
// RemoveUnit ( veh ) ;
3262: LD_VAR 0 1
3266: PPUSH
3267: CALL_OW 64
// end ; end_of_file
3271: PPOPN 1
3273: END
// export Burlak , Gaidar , Kuzmov ; export ruForce , ruEng , ruMech , ruSci , ruMobile ; export ruSol ; export function PrepareRussian ; var base , blist , i , b , un , tmp , fac , oil ; begin
3274: LD_INT 0
3276: PPUSH
3277: PPUSH
3278: PPUSH
3279: PPUSH
3280: PPUSH
3281: PPUSH
3282: PPUSH
3283: PPUSH
3284: PPUSH
// uc_side := 3 ;
3285: LD_ADDR_OWVAR 20
3289: PUSH
3290: LD_INT 3
3292: ST_TO_ADDR
// uc_nation := 3 ;
3293: LD_ADDR_OWVAR 21
3297: PUSH
3298: LD_INT 3
3300: ST_TO_ADDR
// ruForce := [ ] ;
3301: LD_ADDR_EXP 36
3305: PUSH
3306: EMPTY
3307: ST_TO_ADDR
// ruMech := [ ] ;
3308: LD_ADDR_EXP 38
3312: PUSH
3313: EMPTY
3314: ST_TO_ADDR
// ruEng := [ ] ;
3315: LD_ADDR_EXP 37
3319: PUSH
3320: EMPTY
3321: ST_TO_ADDR
// ruSci := [ ] ;
3322: LD_ADDR_EXP 39
3326: PUSH
3327: EMPTY
3328: ST_TO_ADDR
// ruMobile := [ ] ;
3329: LD_ADDR_EXP 40
3333: PUSH
3334: EMPTY
3335: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ,  ) ;
3336: LD_ADDR_EXP 33
3340: PUSH
3341: LD_STRING Burlak
3343: PPUSH
3344: LD_INT 0
3346: PPUSH
3347: LD_STRING 
3349: PPUSH
3350: CALL 336 0 3
3354: ST_TO_ADDR
// Gaidar := PrepareUnit ( Gaydar , false ,  ) ;
3355: LD_ADDR_EXP 34
3359: PUSH
3360: LD_STRING Gaydar
3362: PPUSH
3363: LD_INT 0
3365: PPUSH
3366: LD_STRING 
3368: PPUSH
3369: CALL 336 0 3
3373: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , false ,  ) ;
3374: LD_ADDR_EXP 35
3378: PUSH
3379: LD_STRING Kuzmov
3381: PPUSH
3382: LD_INT 0
3384: PPUSH
3385: LD_STRING 
3387: PPUSH
3388: CALL 336 0 3
3392: ST_TO_ADDR
// PlaceHumanInUnit ( Kuzmov , ruMainBase ) ;
3393: LD_EXP 35
3397: PPUSH
3398: LD_INT 200
3400: PPUSH
3401: CALL_OW 52
// SetBName ( ruMainBase , chuikov ) ;
3405: LD_INT 200
3407: PPUSH
3408: LD_STRING chuikov
3410: PPUSH
3411: CALL_OW 500
// SetResourceType ( GetBase ( ruMainBase ) , mat_cans , [ 800 , 1000 , 1250 ] [ Difficulty ] ) ;
3415: LD_INT 200
3417: PPUSH
3418: CALL_OW 274
3422: PPUSH
3423: LD_INT 1
3425: PPUSH
3426: LD_INT 800
3428: PUSH
3429: LD_INT 1000
3431: PUSH
3432: LD_INT 1250
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: LIST
3439: PUSH
3440: LD_OWVAR 67
3444: ARRAY
3445: PPUSH
3446: CALL_OW 277
// SetResourceType ( GetBase ( ruMainBase ) , mat_oil , 160 ) ;
3450: LD_INT 200
3452: PPUSH
3453: CALL_OW 274
3457: PPUSH
3458: LD_INT 2
3460: PPUSH
3461: LD_INT 160
3463: PPUSH
3464: CALL_OW 277
// SetResourceType ( GetBase ( ruSecBase ) , mat_cans , 200 ) ;
3468: LD_INT 225
3470: PPUSH
3471: CALL_OW 274
3475: PPUSH
3476: LD_INT 1
3478: PPUSH
3479: LD_INT 200
3481: PPUSH
3482: CALL_OW 277
// oil := 150 ;
3486: LD_ADDR_VAR 0 9
3490: PUSH
3491: LD_INT 150
3493: ST_TO_ADDR
// if gameTime >= [ 45 45$00 , 40 40$00 , 35 35$00 ] [ Difficulty ] then
3494: LD_EXP 5
3498: PUSH
3499: LD_INT 94500
3501: PUSH
3502: LD_INT 84000
3504: PUSH
3505: LD_INT 73500
3507: PUSH
3508: EMPTY
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_OWVAR 67
3517: ARRAY
3518: GREATEREQUAL
3519: IFFALSE 3674
// begin oil := 450 ;
3521: LD_ADDR_VAR 0 9
3525: PUSH
3526: LD_INT 450
3528: ST_TO_ADDR
// tmp := [ [ 123 , 17 , 3 , b_breastwork ] , [ 152 , 38 , 3 , b_breastwork ] , [ 81 , 6 , 4 , b_breastwork ] , [ 113 , 67 , 4 , b_bunker ] ] ;
3529: LD_ADDR_VAR 0 7
3533: PUSH
3534: LD_INT 123
3536: PUSH
3537: LD_INT 17
3539: PUSH
3540: LD_INT 3
3542: PUSH
3543: LD_INT 31
3545: PUSH
3546: EMPTY
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: PUSH
3552: LD_INT 152
3554: PUSH
3555: LD_INT 38
3557: PUSH
3558: LD_INT 3
3560: PUSH
3561: LD_INT 31
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: LIST
3568: LIST
3569: PUSH
3570: LD_INT 81
3572: PUSH
3573: LD_INT 6
3575: PUSH
3576: LD_INT 4
3578: PUSH
3579: LD_INT 31
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: PUSH
3588: LD_INT 113
3590: PUSH
3591: LD_INT 67
3593: PUSH
3594: LD_INT 4
3596: PUSH
3597: LD_INT 32
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: ST_TO_ADDR
// for i in tmp do
3612: LD_ADDR_VAR 0 4
3616: PUSH
3617: LD_VAR 0 7
3621: PUSH
3622: FOR_IN
3623: IFFALSE 3672
// begin bc_type := i [ 4 ] ;
3625: LD_ADDR_OWVAR 42
3629: PUSH
3630: LD_VAR 0 4
3634: PUSH
3635: LD_INT 4
3637: ARRAY
3638: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3639: LD_VAR 0 4
3643: PUSH
3644: LD_INT 1
3646: ARRAY
3647: PPUSH
3648: LD_VAR 0 4
3652: PUSH
3653: LD_INT 2
3655: ARRAY
3656: PPUSH
3657: LD_VAR 0 4
3661: PUSH
3662: LD_INT 3
3664: ARRAY
3665: PPUSH
3666: CALL_OW 47
// end ;
3670: GO 3622
3672: POP
3673: POP
// end ; SetResourceType ( GetBase ( ruSecBase ) , mat_oil , oil ) ;
3674: LD_INT 225
3676: PPUSH
3677: CALL_OW 274
3681: PPUSH
3682: LD_INT 2
3684: PPUSH
3685: LD_VAR 0 9
3689: PPUSH
3690: CALL_OW 277
// if Difficulty > 1 then
3694: LD_OWVAR 67
3698: PUSH
3699: LD_INT 1
3701: GREATER
3702: IFFALSE 3797
// begin bc_type := b_bunker ;
3704: LD_ADDR_OWVAR 42
3708: PUSH
3709: LD_INT 32
3711: ST_TO_ADDR
// tmp := [ [ 121 , 85 , 5 ] , [ 93 , 72 , 1 ] ] ;
3712: LD_ADDR_VAR 0 7
3716: PUSH
3717: LD_INT 121
3719: PUSH
3720: LD_INT 85
3722: PUSH
3723: LD_INT 5
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: LIST
3730: PUSH
3731: LD_INT 93
3733: PUSH
3734: LD_INT 72
3736: PUSH
3737: LD_INT 1
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: LIST
3744: PUSH
3745: EMPTY
3746: LIST
3747: LIST
3748: ST_TO_ADDR
// for i in tmp do
3749: LD_ADDR_VAR 0 4
3753: PUSH
3754: LD_VAR 0 7
3758: PUSH
3759: FOR_IN
3760: IFFALSE 3795
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3762: LD_VAR 0 4
3766: PUSH
3767: LD_INT 1
3769: ARRAY
3770: PPUSH
3771: LD_VAR 0 4
3775: PUSH
3776: LD_INT 2
3778: ARRAY
3779: PPUSH
3780: LD_VAR 0 4
3784: PUSH
3785: LD_INT 3
3787: ARRAY
3788: PPUSH
3789: CALL_OW 47
3793: GO 3759
3795: POP
3796: POP
// end ; base := GetBase ( ruMainBase ) ;
3797: LD_ADDR_VAR 0 2
3801: PUSH
3802: LD_INT 200
3804: PPUSH
3805: CALL_OW 274
3809: ST_TO_ADDR
// blist := GetBuildList ( base ) ;
3810: LD_ADDR_VAR 0 3
3814: PUSH
3815: LD_VAR 0 2
3819: PPUSH
3820: CALL_OW 417
3824: ST_TO_ADDR
// for b in blist do
3825: LD_ADDR_VAR 0 5
3829: PUSH
3830: LD_VAR 0 3
3834: PUSH
3835: FOR_IN
3836: IFFALSE 4239
// begin if b [ 1 ] = b_factory then
3838: LD_VAR 0 5
3842: PUSH
3843: LD_INT 1
3845: ARRAY
3846: PUSH
3847: LD_INT 3
3849: EQUAL
3850: IFFALSE 3980
// begin fac := HexInfo ( b [ 2 ] , b [ 3 ] ) ;
3852: LD_ADDR_VAR 0 8
3856: PUSH
3857: LD_VAR 0 5
3861: PUSH
3862: LD_INT 2
3864: ARRAY
3865: PPUSH
3866: LD_VAR 0 5
3870: PUSH
3871: LD_INT 3
3873: ARRAY
3874: PPUSH
3875: CALL_OW 428
3879: ST_TO_ADDR
// for i := 1 to 2 + Difficulty do
3880: LD_ADDR_VAR 0 4
3884: PUSH
3885: DOUBLE
3886: LD_INT 1
3888: DEC
3889: ST_TO_ADDR
3890: LD_INT 2
3892: PUSH
3893: LD_OWVAR 67
3897: PLUS
3898: PUSH
3899: FOR_TO
3900: IFFALSE 3976
// begin PrepareHuman ( false , 3 , 1 + Difficulty ) ;
3902: LD_INT 0
3904: PPUSH
3905: LD_INT 3
3907: PPUSH
3908: LD_INT 1
3910: PUSH
3911: LD_OWVAR 67
3915: PLUS
3916: PPUSH
3917: CALL_OW 380
// un := CreateHuman ;
3921: LD_ADDR_VAR 0 6
3925: PUSH
3926: CALL_OW 44
3930: ST_TO_ADDR
// ruMech := Replace ( ruMech , ruMech + 1 , un ) ;
3931: LD_ADDR_EXP 38
3935: PUSH
3936: LD_EXP 38
3940: PPUSH
3941: LD_EXP 38
3945: PUSH
3946: LD_INT 1
3948: PLUS
3949: PPUSH
3950: LD_VAR 0 6
3954: PPUSH
3955: CALL_OW 1
3959: ST_TO_ADDR
// PlaceHumanInUnit ( un , fac ) ;
3960: LD_VAR 0 6
3964: PPUSH
3965: LD_VAR 0 8
3969: PPUSH
3970: CALL_OW 52
// end ;
3974: GO 3899
3976: POP
3977: POP
// end else
3978: GO 4237
// if b [ 1 ] in [ b_lab , b_lab_half , b_lab_full , b_lab_weapon ] then
3980: LD_VAR 0 5
3984: PUSH
3985: LD_INT 1
3987: ARRAY
3988: PUSH
3989: LD_INT 6
3991: PUSH
3992: LD_INT 7
3994: PUSH
3995: LD_INT 8
3997: PUSH
3998: LD_INT 10
4000: PUSH
4001: EMPTY
4002: LIST
4003: LIST
4004: LIST
4005: LIST
4006: IN
4007: IFFALSE 4117
// begin for i := 1 to 2 do
4009: LD_ADDR_VAR 0 4
4013: PUSH
4014: DOUBLE
4015: LD_INT 1
4017: DEC
4018: ST_TO_ADDR
4019: LD_INT 2
4021: PUSH
4022: FOR_TO
4023: IFFALSE 4113
// begin PrepareHuman ( false , 4 , Difficulty ) ;
4025: LD_INT 0
4027: PPUSH
4028: LD_INT 4
4030: PPUSH
4031: LD_OWVAR 67
4035: PPUSH
4036: CALL_OW 380
// un := CreateHuman ;
4040: LD_ADDR_VAR 0 6
4044: PUSH
4045: CALL_OW 44
4049: ST_TO_ADDR
// ruSci := Replace ( ruSci , ruSci + 1 , un ) ;
4050: LD_ADDR_EXP 39
4054: PUSH
4055: LD_EXP 39
4059: PPUSH
4060: LD_EXP 39
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: PPUSH
4069: LD_VAR 0 6
4073: PPUSH
4074: CALL_OW 1
4078: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4079: LD_VAR 0 6
4083: PPUSH
4084: LD_VAR 0 5
4088: PUSH
4089: LD_INT 2
4091: ARRAY
4092: PPUSH
4093: LD_VAR 0 5
4097: PUSH
4098: LD_INT 3
4100: ARRAY
4101: PPUSH
4102: CALL_OW 428
4106: PPUSH
4107: CALL_OW 52
// end ;
4111: GO 4022
4113: POP
4114: POP
// end else
4115: GO 4237
// if b [ 1 ] = b_warehouse then
4117: LD_VAR 0 5
4121: PUSH
4122: LD_INT 1
4124: ARRAY
4125: PUSH
4126: LD_INT 1
4128: EQUAL
4129: IFFALSE 4237
// begin for i := 1 to 3 do
4131: LD_ADDR_VAR 0 4
4135: PUSH
4136: DOUBLE
4137: LD_INT 1
4139: DEC
4140: ST_TO_ADDR
4141: LD_INT 3
4143: PUSH
4144: FOR_TO
4145: IFFALSE 4235
// begin PrepareHuman ( false , 2 , Difficulty ) ;
4147: LD_INT 0
4149: PPUSH
4150: LD_INT 2
4152: PPUSH
4153: LD_OWVAR 67
4157: PPUSH
4158: CALL_OW 380
// un := CreateHuman ;
4162: LD_ADDR_VAR 0 6
4166: PUSH
4167: CALL_OW 44
4171: ST_TO_ADDR
// ruEng := Replace ( ruEng , ruEng + 1 , un ) ;
4172: LD_ADDR_EXP 37
4176: PUSH
4177: LD_EXP 37
4181: PPUSH
4182: LD_EXP 37
4186: PUSH
4187: LD_INT 1
4189: PLUS
4190: PPUSH
4191: LD_VAR 0 6
4195: PPUSH
4196: CALL_OW 1
4200: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4201: LD_VAR 0 6
4205: PPUSH
4206: LD_VAR 0 5
4210: PUSH
4211: LD_INT 2
4213: ARRAY
4214: PPUSH
4215: LD_VAR 0 5
4219: PUSH
4220: LD_INT 3
4222: ARRAY
4223: PPUSH
4224: CALL_OW 428
4228: PPUSH
4229: CALL_OW 52
// end ;
4233: GO 4144
4235: POP
4236: POP
// end ; end ;
4237: GO 3835
4239: POP
4240: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4241: LD_ADDR_VAR 0 3
4245: PUSH
4246: LD_INT 22
4248: PUSH
4249: LD_INT 3
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_INT 21
4258: PUSH
4259: LD_INT 3
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: PUSH
4266: EMPTY
4267: LIST
4268: LIST
4269: PPUSH
4270: CALL_OW 69
4274: ST_TO_ADDR
// for b in blist do
4275: LD_ADDR_VAR 0 5
4279: PUSH
4280: LD_VAR 0 3
4284: PUSH
4285: FOR_IN
4286: IFFALSE 4308
// SetBLevel ( b , 3 + Difficulty ) ;
4288: LD_VAR 0 5
4292: PPUSH
4293: LD_INT 3
4295: PUSH
4296: LD_OWVAR 67
4300: PLUS
4301: PPUSH
4302: CALL_OW 241
4306: GO 4285
4308: POP
4309: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4310: LD_ADDR_VAR 0 3
4314: PUSH
4315: LD_INT 22
4317: PUSH
4318: LD_INT 3
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: PUSH
4325: LD_INT 30
4327: PUSH
4328: LD_INT 32
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PPUSH
4339: CALL_OW 69
4343: ST_TO_ADDR
// for b in blist do
4344: LD_ADDR_VAR 0 5
4348: PUSH
4349: LD_VAR 0 3
4353: PUSH
4354: FOR_IN
4355: IFFALSE 4464
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4357: LD_INT 0
4359: PPUSH
4360: LD_INT 1
4362: PPUSH
4363: LD_INT 1
4365: PUSH
4366: LD_OWVAR 67
4370: PLUS
4371: PPUSH
4372: CALL_OW 380
// un := CreateHuman ;
4376: LD_ADDR_VAR 0 6
4380: PUSH
4381: CALL_OW 44
4385: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4386: LD_ADDR_EXP 36
4390: PUSH
4391: LD_EXP 36
4395: PPUSH
4396: LD_EXP 36
4400: PUSH
4401: LD_INT 1
4403: PLUS
4404: PPUSH
4405: LD_VAR 0 6
4409: PPUSH
4410: CALL_OW 1
4414: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4415: LD_VAR 0 6
4419: PPUSH
4420: LD_VAR 0 5
4424: PPUSH
4425: CALL_OW 52
// PlaceWeaponTurret ( b , [ ru_gun , ru_gatling_gun ] [ b mod 2 + 1 ] ) ;
4429: LD_VAR 0 5
4433: PPUSH
4434: LD_INT 44
4436: PUSH
4437: LD_INT 43
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PUSH
4444: LD_VAR 0 5
4448: PUSH
4449: LD_INT 2
4451: MOD
4452: PUSH
4453: LD_INT 1
4455: PLUS
4456: ARRAY
4457: PPUSH
4458: CALL_OW 431
// end ;
4462: GO 4354
4464: POP
4465: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: LD_INT 22
4473: PUSH
4474: LD_INT 3
4476: PUSH
4477: EMPTY
4478: LIST
4479: LIST
4480: PUSH
4481: LD_INT 30
4483: PUSH
4484: LD_INT 31
4486: PUSH
4487: EMPTY
4488: LIST
4489: LIST
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PPUSH
4495: CALL_OW 69
4499: ST_TO_ADDR
// for b in blist do
4500: LD_ADDR_VAR 0 5
4504: PUSH
4505: LD_VAR 0 3
4509: PUSH
4510: FOR_IN
4511: IFFALSE 4610
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4513: LD_INT 0
4515: PPUSH
4516: LD_INT 1
4518: PPUSH
4519: LD_INT 1
4521: PUSH
4522: LD_OWVAR 67
4526: PLUS
4527: PPUSH
4528: CALL_OW 380
// un := CreateHuman ;
4532: LD_ADDR_VAR 0 6
4536: PUSH
4537: CALL_OW 44
4541: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4542: LD_ADDR_EXP 36
4546: PUSH
4547: LD_EXP 36
4551: PPUSH
4552: LD_EXP 36
4556: PUSH
4557: LD_INT 1
4559: PLUS
4560: PPUSH
4561: LD_VAR 0 6
4565: PPUSH
4566: CALL_OW 1
4570: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) + 3 ) ;
4571: LD_VAR 0 6
4575: PPUSH
4576: LD_VAR 0 5
4580: PPUSH
4581: CALL_OW 254
4585: PUSH
4586: LD_INT 3
4588: PLUS
4589: PPUSH
4590: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4594: LD_VAR 0 6
4598: PPUSH
4599: LD_VAR 0 5
4603: PPUSH
4604: CALL_OW 52
// end ;
4608: GO 4510
4610: POP
4611: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4612: LD_ADDR_VAR 0 3
4616: PUSH
4617: LD_INT 22
4619: PUSH
4620: LD_INT 3
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: PUSH
4627: LD_INT 2
4629: PUSH
4630: LD_INT 30
4632: PUSH
4633: LD_INT 4
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PUSH
4640: LD_INT 30
4642: PUSH
4643: LD_INT 5
4645: PUSH
4646: EMPTY
4647: LIST
4648: LIST
4649: PUSH
4650: EMPTY
4651: LIST
4652: LIST
4653: LIST
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: PPUSH
4659: CALL_OW 69
4663: ST_TO_ADDR
// for b in blist do
4664: LD_ADDR_VAR 0 5
4668: PUSH
4669: LD_VAR 0 3
4673: PUSH
4674: FOR_IN
4675: IFFALSE 4771
// begin for i := 1 to 2 do
4677: LD_ADDR_VAR 0 4
4681: PUSH
4682: DOUBLE
4683: LD_INT 1
4685: DEC
4686: ST_TO_ADDR
4687: LD_INT 2
4689: PUSH
4690: FOR_TO
4691: IFFALSE 4767
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4693: LD_INT 0
4695: PPUSH
4696: LD_INT 1
4698: PPUSH
4699: LD_INT 1
4701: PUSH
4702: LD_OWVAR 67
4706: PLUS
4707: PPUSH
4708: CALL_OW 380
// un := CreateHuman ;
4712: LD_ADDR_VAR 0 6
4716: PUSH
4717: CALL_OW 44
4721: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4722: LD_ADDR_EXP 36
4726: PUSH
4727: LD_EXP 36
4731: PPUSH
4732: LD_EXP 36
4736: PUSH
4737: LD_INT 1
4739: PLUS
4740: PPUSH
4741: LD_VAR 0 6
4745: PPUSH
4746: CALL_OW 1
4750: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4751: LD_VAR 0 6
4755: PPUSH
4756: LD_VAR 0 5
4760: PPUSH
4761: CALL_OW 52
// end ;
4765: GO 4690
4767: POP
4768: POP
// end ;
4769: GO 4674
4771: POP
4772: POP
// if ibrahimOnRuSide then
4773: LD_EXP 3
4777: IFFALSE 4875
// begin Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
4779: LD_ADDR_EXP 21
4783: PUSH
4784: LD_STRING IbrahimRu
4786: PPUSH
4787: LD_INT 0
4789: PPUSH
4790: LD_STRING 
4792: PPUSH
4793: CALL 336 0 3
4797: ST_TO_ADDR
// PlaceUnitXY ( Ibrahim , 121 , 78 , false ) ;
4798: LD_EXP 21
4802: PPUSH
4803: LD_INT 121
4805: PPUSH
4806: LD_INT 78
4808: PPUSH
4809: LD_INT 0
4811: PPUSH
4812: CALL_OW 48
// ComHold ( Ibrahim ) ;
4816: LD_EXP 21
4820: PPUSH
4821: CALL_OW 140
// PrepareHuman ( sex_male , 1 , 2 ) ;
4825: LD_INT 1
4827: PPUSH
4828: LD_INT 1
4830: PPUSH
4831: LD_INT 2
4833: PPUSH
4834: CALL_OW 380
// ruSol := CreateHuman ;
4838: LD_ADDR_EXP 41
4842: PUSH
4843: CALL_OW 44
4847: ST_TO_ADDR
// PlaceUnitXY ( ruSol , 121 , 75 , false ) ;
4848: LD_EXP 41
4852: PPUSH
4853: LD_INT 121
4855: PPUSH
4856: LD_INT 75
4858: PPUSH
4859: LD_INT 0
4861: PPUSH
4862: CALL_OW 48
// ComHold ( ruSol ) ;
4866: LD_EXP 41
4870: PPUSH
4871: CALL_OW 140
// end ; for i := 1 to 2 + Difficulty do
4875: LD_ADDR_VAR 0 4
4879: PUSH
4880: DOUBLE
4881: LD_INT 1
4883: DEC
4884: ST_TO_ADDR
4885: LD_INT 2
4887: PUSH
4888: LD_OWVAR 67
4892: PLUS
4893: PUSH
4894: FOR_TO
4895: IFFALSE 4964
// AddComConstruct ( fac , [ ru_medium_wheeled , ru_heavy_wheeled , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] ) ;
4897: LD_VAR 0 8
4901: PPUSH
4902: LD_INT 21
4904: PUSH
4905: LD_INT 23
4907: PUSH
4908: LD_INT 24
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: LIST
4915: PUSH
4916: LD_VAR 0 4
4920: PUSH
4921: LD_INT 3
4923: MOD
4924: PUSH
4925: LD_INT 1
4927: PLUS
4928: ARRAY
4929: PPUSH
4930: LD_INT 1
4932: PPUSH
4933: LD_INT 1
4935: PPUSH
4936: LD_INT 43
4938: PUSH
4939: LD_INT 44
4941: PUSH
4942: EMPTY
4943: LIST
4944: LIST
4945: PUSH
4946: LD_INT 1
4948: PPUSH
4949: LD_INT 2
4951: PPUSH
4952: CALL_OW 12
4956: ARRAY
4957: PPUSH
4958: CALL_OW 185
4962: GO 4894
4964: POP
4965: POP
// end ;
4966: LD_VAR 0 1
4970: RET
// every 0 0$1 trigger ruMobile and not ruEscapeAllowed do var i , filter , tmp , enemy , x ;
4971: LD_EXP 40
4975: PUSH
4976: LD_EXP 4
4980: NOT
4981: AND
4982: IFFALSE 5469
4984: GO 4986
4986: DISABLE
4987: LD_INT 0
4989: PPUSH
4990: PPUSH
4991: PPUSH
4992: PPUSH
4993: PPUSH
// begin enable ;
4994: ENABLE
// filter := UnitFilter ( ruMobile , [ f_type , unit_vehicle ] ) ;
4995: LD_ADDR_VAR 0 2
4999: PUSH
5000: LD_EXP 40
5004: PPUSH
5005: LD_INT 21
5007: PUSH
5008: LD_INT 2
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: PPUSH
5015: CALL_OW 72
5019: ST_TO_ADDR
// enemy := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_or , [ f_inarea , zone1 ] , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) ;
5020: LD_ADDR_VAR 0 4
5024: PUSH
5025: LD_INT 81
5027: PUSH
5028: LD_INT 3
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: PUSH
5035: LD_INT 2
5037: PUSH
5038: LD_INT 95
5040: PUSH
5041: LD_INT 4
5043: PUSH
5044: EMPTY
5045: LIST
5046: LIST
5047: PUSH
5048: LD_INT 95
5050: PUSH
5051: LD_INT 5
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: LD_INT 95
5060: PUSH
5061: LD_INT 6
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 95
5070: PUSH
5071: LD_INT 7
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: LIST
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: PPUSH
5089: CALL_OW 69
5093: ST_TO_ADDR
// for i in filter do
5094: LD_ADDR_VAR 0 1
5098: PUSH
5099: LD_VAR 0 2
5103: PUSH
5104: FOR_IN
5105: IFFALSE 5467
// begin tmp := IsDrivenBy ( i ) ;
5107: LD_ADDR_VAR 0 3
5111: PUSH
5112: LD_VAR 0 1
5116: PPUSH
5117: CALL_OW 311
5121: ST_TO_ADDR
// if not tmp then
5122: LD_VAR 0 3
5126: NOT
5127: IFFALSE 5131
// continue ;
5129: GO 5104
// if GetFuel ( i ) > 90 and GetTag ( i ) = 2 then
5131: LD_VAR 0 1
5135: PPUSH
5136: CALL_OW 261
5140: PUSH
5141: LD_INT 90
5143: GREATER
5144: PUSH
5145: LD_VAR 0 1
5149: PPUSH
5150: CALL_OW 110
5154: PUSH
5155: LD_INT 2
5157: EQUAL
5158: AND
5159: IFFALSE 5175
// SetTag ( i , 0 ) else
5161: LD_VAR 0 1
5165: PPUSH
5166: LD_INT 0
5168: PPUSH
5169: CALL_OW 109
5173: GO 5218
// if GetTag ( i ) = 2 then
5175: LD_VAR 0 1
5179: PPUSH
5180: CALL_OW 110
5184: PUSH
5185: LD_INT 2
5187: EQUAL
5188: IFFALSE 5218
// begin x := rand ( 1 , 2 ) ;
5190: LD_ADDR_VAR 0 5
5194: PUSH
5195: LD_INT 1
5197: PPUSH
5198: LD_INT 2
5200: PPUSH
5201: CALL_OW 12
5205: ST_TO_ADDR
// AddComMoveUnit ( i , ruMainBase ) ;
5206: LD_VAR 0 1
5210: PPUSH
5211: LD_INT 200
5213: PPUSH
5214: CALL_OW 172
// end ; if GetLives ( i ) >= 600 and not GetTag ( i ) then
5218: LD_VAR 0 1
5222: PPUSH
5223: CALL_OW 256
5227: PUSH
5228: LD_INT 600
5230: GREATEREQUAL
5231: PUSH
5232: LD_VAR 0 1
5236: PPUSH
5237: CALL_OW 110
5241: NOT
5242: AND
5243: IFFALSE 5269
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
5245: LD_VAR 0 1
5249: PPUSH
5250: LD_VAR 0 4
5254: PPUSH
5255: LD_VAR 0 1
5259: PPUSH
5260: CALL_OW 74
5264: PPUSH
5265: CALL_OW 115
// if GetLives ( i ) < 600 and not GetTag ( i ) then
5269: LD_VAR 0 1
5273: PPUSH
5274: CALL_OW 256
5278: PUSH
5279: LD_INT 600
5281: LESS
5282: PUSH
5283: LD_VAR 0 1
5287: PPUSH
5288: CALL_OW 110
5292: NOT
5293: AND
5294: IFFALSE 5323
// begin SetTag ( i , 1 ) ;
5296: LD_VAR 0 1
5300: PPUSH
5301: LD_INT 1
5303: PPUSH
5304: CALL_OW 109
// ComMoveXY ( i , 112 , 119 ) ;
5308: LD_VAR 0 1
5312: PPUSH
5313: LD_INT 112
5315: PPUSH
5316: LD_INT 119
5318: PPUSH
5319: CALL_OW 111
// end ; if GetTag ( i ) = 1 and GetDistUnitXY ( i , 112 , 119 ) < 9 and tmp then
5323: LD_VAR 0 1
5327: PPUSH
5328: CALL_OW 110
5332: PUSH
5333: LD_INT 1
5335: EQUAL
5336: PUSH
5337: LD_VAR 0 1
5341: PPUSH
5342: LD_INT 112
5344: PPUSH
5345: LD_INT 119
5347: PPUSH
5348: CALL_OW 297
5352: PUSH
5353: LD_INT 9
5355: LESS
5356: AND
5357: PUSH
5358: LD_VAR 0 3
5362: AND
5363: IFFALSE 5465
// begin ComExitVehicle ( tmp ) ;
5365: LD_VAR 0 3
5369: PPUSH
5370: CALL_OW 121
// AddComRepairVehicle ( tmp , i ) ;
5374: LD_VAR 0 3
5378: PPUSH
5379: LD_VAR 0 1
5383: PPUSH
5384: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
5388: LD_INT 35
5390: PPUSH
5391: CALL_OW 67
// until GetLives ( i ) = 1000 ;
5395: LD_VAR 0 1
5399: PPUSH
5400: CALL_OW 256
5404: PUSH
5405: LD_INT 1000
5407: EQUAL
5408: IFFALSE 5388
// ComEnterUnit ( tmp , i ) ;
5410: LD_VAR 0 3
5414: PPUSH
5415: LD_VAR 0 1
5419: PPUSH
5420: CALL_OW 120
// if GetFuel ( i ) <= 50 then
5424: LD_VAR 0 1
5428: PPUSH
5429: CALL_OW 261
5433: PUSH
5434: LD_INT 50
5436: LESSEQUAL
5437: IFFALSE 5453
// SetTag ( i , 2 ) else
5439: LD_VAR 0 1
5443: PPUSH
5444: LD_INT 2
5446: PPUSH
5447: CALL_OW 109
5451: GO 5465
// SetTag ( i , 0 ) ;
5453: LD_VAR 0 1
5457: PPUSH
5458: LD_INT 0
5460: PPUSH
5461: CALL_OW 109
// end ; end ;
5465: GO 5104
5467: POP
5468: POP
// end ;
5469: PPOPN 5
5471: END
// every 0 0$1 trigger not ruEscapeAllowed and ruEng do var i , filter , tmp , enemy ;
5472: LD_EXP 4
5476: NOT
5477: PUSH
5478: LD_EXP 37
5482: AND
5483: IFFALSE 5744
5485: GO 5487
5487: DISABLE
5488: LD_INT 0
5490: PPUSH
5491: PPUSH
5492: PPUSH
5493: PPUSH
// begin enable ;
5494: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5495: LD_ADDR_VAR 0 2
5499: PUSH
5500: LD_INT 3
5502: PPUSH
5503: LD_INT 22
5505: PUSH
5506: LD_INT 3
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 21
5515: PUSH
5516: LD_INT 3
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: LD_INT 3
5525: PUSH
5526: LD_INT 24
5528: PUSH
5529: LD_INT 1000
5531: PUSH
5532: EMPTY
5533: LIST
5534: LIST
5535: PUSH
5536: EMPTY
5537: LIST
5538: LIST
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: PPUSH
5545: CALL_OW 70
5549: ST_TO_ADDR
// tmp := UnitFilter ( ruEng , [ f_ok ] ) ;
5550: LD_ADDR_VAR 0 3
5554: PUSH
5555: LD_EXP 37
5559: PPUSH
5560: LD_INT 50
5562: PUSH
5563: EMPTY
5564: LIST
5565: PPUSH
5566: CALL_OW 72
5570: ST_TO_ADDR
// if filter and tmp then
5571: LD_VAR 0 2
5575: PUSH
5576: LD_VAR 0 3
5580: AND
5581: IFFALSE 5673
// begin for i in tmp do
5583: LD_ADDR_VAR 0 1
5587: PUSH
5588: LD_VAR 0 3
5592: PUSH
5593: FOR_IN
5594: IFFALSE 5669
// begin if GetTag ( i ) = tEscape then
5596: LD_VAR 0 1
5600: PPUSH
5601: CALL_OW 110
5605: PUSH
5606: LD_EXP 17
5610: EQUAL
5611: IFFALSE 5615
// continue ;
5613: GO 5593
// if IsInUnit ( i ) then
5615: LD_VAR 0 1
5619: PPUSH
5620: CALL_OW 310
5624: IFFALSE 5637
// ComExitBuilding ( i ) else
5626: LD_VAR 0 1
5630: PPUSH
5631: CALL_OW 122
5635: GO 5667
// if not HasTask ( i ) then
5637: LD_VAR 0 1
5641: PPUSH
5642: CALL_OW 314
5646: NOT
5647: IFFALSE 5667
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5649: LD_VAR 0 1
5653: PPUSH
5654: LD_VAR 0 2
5658: PUSH
5659: LD_INT 1
5661: ARRAY
5662: PPUSH
5663: CALL_OW 130
// end ;
5667: GO 5593
5669: POP
5670: POP
// end else
5671: GO 5744
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5673: LD_VAR 0 3
5677: PPUSH
5678: LD_INT 3
5680: PUSH
5681: LD_INT 54
5683: PUSH
5684: EMPTY
5685: LIST
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: PPUSH
5691: CALL_OW 72
5695: IFFALSE 5744
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5697: LD_ADDR_VAR 0 1
5701: PUSH
5702: LD_VAR 0 3
5706: PPUSH
5707: LD_INT 3
5709: PUSH
5710: LD_INT 54
5712: PUSH
5713: EMPTY
5714: LIST
5715: PUSH
5716: EMPTY
5717: LIST
5718: LIST
5719: PPUSH
5720: CALL_OW 72
5724: PUSH
5725: FOR_IN
5726: IFFALSE 5742
// ComEnterUnit ( i , ruMainBase ) ;
5728: LD_VAR 0 1
5732: PPUSH
5733: LD_INT 200
5735: PPUSH
5736: CALL_OW 120
5740: GO 5725
5742: POP
5743: POP
// end ; end ;
5744: PPOPN 4
5746: END
// every 0 0$1 trigger not ruEscapeAllowed and ruSci do var i , filter , tmp , lab ;
5747: LD_EXP 4
5751: NOT
5752: PUSH
5753: LD_EXP 39
5757: AND
5758: IFFALSE 6037
5760: GO 5762
5762: DISABLE
5763: LD_INT 0
5765: PPUSH
5766: PPUSH
5767: PPUSH
5768: PPUSH
// begin enable ;
5769: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5770: LD_ADDR_VAR 0 2
5774: PUSH
5775: LD_INT 3
5777: PPUSH
5778: LD_INT 22
5780: PUSH
5781: LD_INT 3
5783: PUSH
5784: EMPTY
5785: LIST
5786: LIST
5787: PUSH
5788: LD_INT 21
5790: PUSH
5791: LD_INT 1
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 3
5800: PUSH
5801: LD_INT 24
5803: PUSH
5804: LD_INT 1000
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PUSH
5811: EMPTY
5812: LIST
5813: LIST
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: LIST
5819: PPUSH
5820: CALL_OW 70
5824: ST_TO_ADDR
// tmp := UnitFilter ( ruSci , [ f_ok ] ) ;
5825: LD_ADDR_VAR 0 3
5829: PUSH
5830: LD_EXP 39
5834: PPUSH
5835: LD_INT 50
5837: PUSH
5838: EMPTY
5839: LIST
5840: PPUSH
5841: CALL_OW 72
5845: ST_TO_ADDR
// lab := HexInfo ( 118 , 121 ) ;
5846: LD_ADDR_VAR 0 4
5850: PUSH
5851: LD_INT 118
5853: PPUSH
5854: LD_INT 121
5856: PPUSH
5857: CALL_OW 428
5861: ST_TO_ADDR
// if filter and tmp then
5862: LD_VAR 0 2
5866: PUSH
5867: LD_VAR 0 3
5871: AND
5872: IFFALSE 5964
// begin for i in tmp do
5874: LD_ADDR_VAR 0 1
5878: PUSH
5879: LD_VAR 0 3
5883: PUSH
5884: FOR_IN
5885: IFFALSE 5960
// begin if GetTag ( i ) = tEscape then
5887: LD_VAR 0 1
5891: PPUSH
5892: CALL_OW 110
5896: PUSH
5897: LD_EXP 17
5901: EQUAL
5902: IFFALSE 5906
// continue ;
5904: GO 5884
// if IsInUnit ( i ) then
5906: LD_VAR 0 1
5910: PPUSH
5911: CALL_OW 310
5915: IFFALSE 5928
// ComExitBuilding ( i ) else
5917: LD_VAR 0 1
5921: PPUSH
5922: CALL_OW 122
5926: GO 5958
// if not HasTask ( i ) then
5928: LD_VAR 0 1
5932: PPUSH
5933: CALL_OW 314
5937: NOT
5938: IFFALSE 5958
// ComHeal ( i , filter [ 1 ] ) ;
5940: LD_VAR 0 1
5944: PPUSH
5945: LD_VAR 0 2
5949: PUSH
5950: LD_INT 1
5952: ARRAY
5953: PPUSH
5954: CALL_OW 128
// end ;
5958: GO 5884
5960: POP
5961: POP
// end else
5962: GO 6037
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5964: LD_VAR 0 3
5968: PPUSH
5969: LD_INT 3
5971: PUSH
5972: LD_INT 54
5974: PUSH
5975: EMPTY
5976: LIST
5977: PUSH
5978: EMPTY
5979: LIST
5980: LIST
5981: PPUSH
5982: CALL_OW 72
5986: IFFALSE 6037
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5988: LD_ADDR_VAR 0 1
5992: PUSH
5993: LD_VAR 0 3
5997: PPUSH
5998: LD_INT 3
6000: PUSH
6001: LD_INT 54
6003: PUSH
6004: EMPTY
6005: LIST
6006: PUSH
6007: EMPTY
6008: LIST
6009: LIST
6010: PPUSH
6011: CALL_OW 72
6015: PUSH
6016: FOR_IN
6017: IFFALSE 6035
// ComEnterUnit ( i , lab ) ;
6019: LD_VAR 0 1
6023: PPUSH
6024: LD_VAR 0 4
6028: PPUSH
6029: CALL_OW 120
6033: GO 6016
6035: POP
6036: POP
// end ; end ; end_of_file
6037: PPOPN 4
6039: END
// on UnitDestroyed ( un ) do begin if un = Heike then
6040: LD_VAR 0 1
6044: PUSH
6045: LD_EXP 18
6049: EQUAL
6050: IFFALSE 6059
// YouLost ( Heike ) ;
6052: LD_STRING Heike
6054: PPUSH
6055: CALL_OW 104
// if un in ruEng then
6059: LD_VAR 0 1
6063: PUSH
6064: LD_EXP 37
6068: IN
6069: IFFALSE 6087
// ruEng := ruEng diff un ;
6071: LD_ADDR_EXP 37
6075: PUSH
6076: LD_EXP 37
6080: PUSH
6081: LD_VAR 0 1
6085: DIFF
6086: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) then
6087: LD_VAR 0 1
6091: PUSH
6092: LD_INT 22
6094: PUSH
6095: LD_INT 2
6097: PUSH
6098: EMPTY
6099: LIST
6100: LIST
6101: PUSH
6102: LD_INT 21
6104: PUSH
6105: LD_INT 1
6107: PUSH
6108: EMPTY
6109: LIST
6110: LIST
6111: PUSH
6112: LD_INT 23
6114: PUSH
6115: LD_INT 2
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: LIST
6126: PPUSH
6127: CALL_OW 69
6131: IN
6132: IFFALSE 6148
// loseCounter := loseCounter + 1 ;
6134: LD_ADDR_EXP 6
6138: PUSH
6139: LD_EXP 6
6143: PUSH
6144: LD_INT 1
6146: PLUS
6147: ST_TO_ADDR
// end ;
6148: PPOPN 1
6150: END
// on EvacuateVehicle ( driver , un , p1 , p2 ) do var weapon , fac ;
6151: LD_INT 0
6153: PPUSH
6154: PPUSH
// begin if un in ruMobile then
6155: LD_VAR 0 2
6159: PUSH
6160: LD_EXP 40
6164: IN
6165: IFFALSE 6324
// begin ruMobile := ruMobile diff un ;
6167: LD_ADDR_EXP 40
6171: PUSH
6172: LD_EXP 40
6176: PUSH
6177: LD_VAR 0 2
6181: DIFF
6182: ST_TO_ADDR
// weapon := GetWeapon ( un ) ;
6183: LD_ADDR_VAR 0 5
6187: PUSH
6188: LD_VAR 0 2
6192: PPUSH
6193: CALL_OW 264
6197: ST_TO_ADDR
// fac := HexInfo ( 110 , 126 ) ;
6198: LD_ADDR_VAR 0 6
6202: PUSH
6203: LD_INT 110
6205: PPUSH
6206: LD_INT 126
6208: PPUSH
6209: CALL_OW 428
6213: ST_TO_ADDR
// if not driver or not fac then
6214: LD_VAR 0 1
6218: NOT
6219: PUSH
6220: LD_VAR 0 6
6224: NOT
6225: OR
6226: IFFALSE 6230
// exit ;
6228: GO 6324
// AddComMoveXY ( driver , 111 , 121 ) ;
6230: LD_VAR 0 1
6234: PPUSH
6235: LD_INT 111
6237: PPUSH
6238: LD_INT 121
6240: PPUSH
6241: CALL_OW 171
// AddComEnterUnit ( driver , fac ) ;
6245: LD_VAR 0 1
6249: PPUSH
6250: LD_VAR 0 6
6254: PPUSH
6255: CALL_OW 180
// repeat wait ( 0 0$1 ) ;
6259: LD_INT 35
6261: PPUSH
6262: CALL_OW 67
// until IsDead ( driver ) or IsInUnit ( driver ) ;
6266: LD_VAR 0 1
6270: PPUSH
6271: CALL_OW 301
6275: PUSH
6276: LD_VAR 0 1
6280: PPUSH
6281: CALL_OW 310
6285: OR
6286: IFFALSE 6259
// if IsDead ( driver ) then
6288: LD_VAR 0 1
6292: PPUSH
6293: CALL_OW 301
6297: IFFALSE 6301
// exit ;
6299: GO 6324
// AddComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_manual , weapon ) ;
6301: LD_VAR 0 6
6305: PPUSH
6306: LD_INT 21
6308: PPUSH
6309: LD_INT 1
6311: PPUSH
6312: LD_INT 1
6314: PPUSH
6315: LD_VAR 0 5
6319: PPUSH
6320: CALL_OW 185
// end ; end ;
6324: PPOPN 6
6326: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 3 then
6327: LD_VAR 0 2
6331: PPUSH
6332: CALL_OW 255
6336: PUSH
6337: LD_INT 3
6339: EQUAL
6340: IFFALSE 6386
// begin ruMobile := Replace ( ruMobile , ruMobile + 1 , veh ) ;
6342: LD_ADDR_EXP 40
6346: PUSH
6347: LD_EXP 40
6351: PPUSH
6352: LD_EXP 40
6356: PUSH
6357: LD_INT 1
6359: PLUS
6360: PPUSH
6361: LD_VAR 0 1
6365: PPUSH
6366: CALL_OW 1
6370: ST_TO_ADDR
// AddComMoveXY ( veh , 110 , 117 ) ;
6371: LD_VAR 0 1
6375: PPUSH
6376: LD_INT 110
6378: PPUSH
6379: LD_INT 117
6381: PPUSH
6382: CALL_OW 171
// end ; end ;
6386: PPOPN 2
6388: END
// on LeaveBuilding ( b , un ) do var barracks ;
6389: LD_INT 0
6391: PPUSH
// begin if b in [ HexInfo ( 130 , 17 ) , HexInfo ( 138 , 22 ) , HexInfo ( 123 , 17 ) ] then
6392: LD_VAR 0 1
6396: PUSH
6397: LD_INT 130
6399: PPUSH
6400: LD_INT 17
6402: PPUSH
6403: CALL_OW 428
6407: PUSH
6408: LD_INT 138
6410: PPUSH
6411: LD_INT 22
6413: PPUSH
6414: CALL_OW 428
6418: PUSH
6419: LD_INT 123
6421: PPUSH
6422: LD_INT 17
6424: PPUSH
6425: CALL_OW 428
6429: PUSH
6430: EMPTY
6431: LIST
6432: LIST
6433: LIST
6434: IN
6435: IFFALSE 6459
// begin AddComEnterUnit ( un , HexInfo ( 135 , 31 ) ) ;
6437: LD_VAR 0 2
6441: PPUSH
6442: LD_INT 135
6444: PPUSH
6445: LD_INT 31
6447: PPUSH
6448: CALL_OW 428
6452: PPUSH
6453: CALL_OW 180
// exit ;
6457: GO 6733
// end ; if b = HexInfo ( 135 , 31 ) then
6459: LD_VAR 0 1
6463: PUSH
6464: LD_INT 135
6466: PPUSH
6467: LD_INT 31
6469: PPUSH
6470: CALL_OW 428
6474: EQUAL
6475: IFFALSE 6547
// begin AddComEnterUnit ( un , HexInfo ( 106 , 51 ) ) ;
6477: LD_VAR 0 2
6481: PPUSH
6482: LD_INT 106
6484: PPUSH
6485: LD_INT 51
6487: PPUSH
6488: CALL_OW 428
6492: PPUSH
6493: CALL_OW 180
// if not explodeFirstDepot then
6497: LD_EXP 12
6501: NOT
6502: IFFALSE 6545
// begin explodeFirstDepot := true ;
6504: LD_ADDR_EXP 12
6508: PUSH
6509: LD_INT 1
6511: ST_TO_ADDR
// wait ( 0 0$15 ) ;
6512: LD_INT 525
6514: PPUSH
6515: CALL_OW 67
// MineExplosion ( 127 , 27 , 1 ) ;
6519: LD_INT 127
6521: PPUSH
6522: LD_INT 27
6524: PPUSH
6525: LD_INT 1
6527: PPUSH
6528: CALL_OW 453
// MineExplosion ( 125 , 29 , 1 ) ;
6532: LD_INT 125
6534: PPUSH
6535: LD_INT 29
6537: PPUSH
6538: LD_INT 1
6540: PPUSH
6541: CALL_OW 453
// end ; exit ;
6545: GO 6733
// end ; if b = HexInfo ( 106 , 51 ) then
6547: LD_VAR 0 1
6551: PUSH
6552: LD_INT 106
6554: PPUSH
6555: LD_INT 51
6557: PPUSH
6558: CALL_OW 428
6562: EQUAL
6563: IFFALSE 6663
// begin AddComMoveXY ( un , 106 , 93 ) ;
6565: LD_VAR 0 2
6569: PPUSH
6570: LD_INT 106
6572: PPUSH
6573: LD_INT 93
6575: PPUSH
6576: CALL_OW 171
// if not explodeSecondDepot then
6580: LD_EXP 13
6584: NOT
6585: IFFALSE 6661
// begin explodeSecondDepot := true ;
6587: LD_ADDR_EXP 13
6591: PUSH
6592: LD_INT 1
6594: ST_TO_ADDR
// wait ( 0 0$12 ) ;
6595: LD_INT 420
6597: PPUSH
6598: CALL_OW 67
// MineExplosion ( 111 , 75 , 1 ) ;
6602: LD_INT 111
6604: PPUSH
6605: LD_INT 75
6607: PPUSH
6608: LD_INT 1
6610: PPUSH
6611: CALL_OW 453
// MineExplosion ( 111 , 75 , 1 ) ;
6615: LD_INT 111
6617: PPUSH
6618: LD_INT 75
6620: PPUSH
6621: LD_INT 1
6623: PPUSH
6624: CALL_OW 453
// MineExplosion ( 108 , 69 , 1 ) ;
6628: LD_INT 108
6630: PPUSH
6631: LD_INT 69
6633: PPUSH
6634: LD_INT 1
6636: PPUSH
6637: CALL_OW 453
// wait ( 0 0$2 ) ;
6641: LD_INT 70
6643: PPUSH
6644: CALL_OW 67
// MineExplosion ( 94 , 65 , 1 ) ;
6648: LD_INT 94
6650: PPUSH
6651: LD_INT 65
6653: PPUSH
6654: LD_INT 1
6656: PPUSH
6657: CALL_OW 453
// end ; exit ;
6661: GO 6733
// end ; if GetBType ( b ) = b_bunker then
6663: LD_VAR 0 1
6667: PPUSH
6668: CALL_OW 266
6672: PUSH
6673: LD_INT 32
6675: EQUAL
6676: IFFALSE 6733
// begin barracks := NearestEmptyBuilding ( un , b_barracks ) ;
6678: LD_ADDR_VAR 0 3
6682: PUSH
6683: LD_VAR 0 2
6687: PPUSH
6688: LD_INT 5
6690: PPUSH
6691: CALL 2403 0 2
6695: ST_TO_ADDR
// if barracks then
6696: LD_VAR 0 3
6700: IFFALSE 6718
// AddComEnterUnit ( un , barracks ) else
6702: LD_VAR 0 2
6706: PPUSH
6707: LD_VAR 0 3
6711: PPUSH
6712: CALL_OW 180
6716: GO 6733
// AddComMoveXY ( un , 116 , 110 ) ;
6718: LD_VAR 0 2
6722: PPUSH
6723: LD_INT 116
6725: PPUSH
6726: LD_INT 110
6728: PPUSH
6729: CALL_OW 171
// end ; end ;
6733: PPOPN 3
6735: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un = Kaia and killerSide in [ 3 , 6 ] then
6736: LD_VAR 0 1
6740: PUSH
6741: LD_EXP 23
6745: EQUAL
6746: PUSH
6747: LD_VAR 0 2
6751: PUSH
6752: LD_INT 3
6754: PUSH
6755: LD_INT 6
6757: PUSH
6758: EMPTY
6759: LIST
6760: LIST
6761: IN
6762: AND
6763: IFFALSE 6794
// kaiaKilledByRussian := [ GetX ( un ) , GetY ( un ) ] ;
6765: LD_ADDR_EXP 8
6769: PUSH
6770: LD_VAR 0 1
6774: PPUSH
6775: CALL_OW 250
6779: PUSH
6780: LD_VAR 0 1
6784: PPUSH
6785: CALL_OW 251
6789: PUSH
6790: EMPTY
6791: LIST
6792: LIST
6793: ST_TO_ADDR
// end ; end_of_file
6794: PPOPN 3
6796: END
// export function Action ; var i , un , veh , tmp , rutmp ; begin
6797: LD_INT 0
6799: PPUSH
6800: PPUSH
6801: PPUSH
6802: PPUSH
6803: PPUSH
6804: PPUSH
// InGameOn ;
6805: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6809: LD_INT 5
6811: PPUSH
6812: LD_INT 2
6814: PPUSH
6815: CALL_OW 343
// music_nat := 4 ;
6819: LD_ADDR_OWVAR 71
6823: PUSH
6824: LD_INT 4
6826: ST_TO_ADDR
// music_class := music_combat ;
6827: LD_ADDR_OWVAR 72
6831: PUSH
6832: LD_INT 1
6834: ST_TO_ADDR
// PlaceSeeing ( 133 , 2 , 2 , 10 ) ;
6835: LD_INT 133
6837: PPUSH
6838: LD_INT 2
6840: PPUSH
6841: LD_INT 2
6843: PPUSH
6844: LD_INT 10
6846: PPUSH
6847: CALL_OW 330
// CenterNowOnXY ( 133 , 2 ) ;
6851: LD_INT 133
6853: PPUSH
6854: LD_INT 2
6856: PPUSH
6857: CALL_OW 86
// wait ( 0 0$1 ) ;
6861: LD_INT 35
6863: PPUSH
6864: CALL_OW 67
// uc_side := 6 ;
6868: LD_ADDR_OWVAR 20
6872: PUSH
6873: LD_INT 6
6875: ST_TO_ADDR
// uc_nation := 3 ;
6876: LD_ADDR_OWVAR 21
6880: PUSH
6881: LD_INT 3
6883: ST_TO_ADDR
// rutmp := [ ] ;
6884: LD_ADDR_VAR 0 6
6888: PUSH
6889: EMPTY
6890: ST_TO_ADDR
// PrepareTank ( 6 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_gun , 66 ) ;
6891: LD_INT 6
6893: PPUSH
6894: LD_INT 3
6896: PPUSH
6897: LD_INT 21
6899: PPUSH
6900: LD_INT 1
6902: PPUSH
6903: LD_INT 1
6905: PPUSH
6906: LD_INT 44
6908: PPUSH
6909: LD_INT 66
6911: PPUSH
6912: CALL 399 0 7
// veh := CreateVehicle ;
6916: LD_ADDR_VAR 0 4
6920: PUSH
6921: CALL_OW 45
6925: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
6926: LD_VAR 0 4
6930: PPUSH
6931: LD_INT 3
6933: PPUSH
6934: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
6938: LD_VAR 0 4
6942: PPUSH
6943: LD_INT 8
6945: PPUSH
6946: LD_INT 0
6948: PPUSH
6949: CALL_OW 49
// SetLives ( veh , 500 ) ;
6953: LD_VAR 0 4
6957: PPUSH
6958: LD_INT 500
6960: PPUSH
6961: CALL_OW 234
// PrepareHuman ( false , 3 , 3 ) ;
6965: LD_INT 0
6967: PPUSH
6968: LD_INT 3
6970: PPUSH
6971: LD_INT 3
6973: PPUSH
6974: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6978: CALL_OW 44
6982: PPUSH
6983: LD_VAR 0 4
6987: PPUSH
6988: CALL_OW 52
// ComMoveXY ( veh , 133 , 11 ) ;
6992: LD_VAR 0 4
6996: PPUSH
6997: LD_INT 133
6999: PPUSH
7000: LD_INT 11
7002: PPUSH
7003: CALL_OW 111
// rutmp := [ veh ] ;
7007: LD_ADDR_VAR 0 6
7011: PUSH
7012: LD_VAR 0 4
7016: PUSH
7017: EMPTY
7018: LIST
7019: ST_TO_ADDR
// for i := 1 to 4 do
7020: LD_ADDR_VAR 0 2
7024: PUSH
7025: DOUBLE
7026: LD_INT 1
7028: DEC
7029: ST_TO_ADDR
7030: LD_INT 4
7032: PUSH
7033: FOR_TO
7034: IFFALSE 7141
// begin PrepareHuman ( false , i , 2 ) ;
7036: LD_INT 0
7038: PPUSH
7039: LD_VAR 0 2
7043: PPUSH
7044: LD_INT 2
7046: PPUSH
7047: CALL_OW 380
// un := CreateHuman ;
7051: LD_ADDR_VAR 0 3
7055: PUSH
7056: CALL_OW 44
7060: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7061: LD_VAR 0 3
7065: PPUSH
7066: LD_INT 3
7068: PPUSH
7069: CALL_OW 233
// PlaceUnitArea ( un , spawnArea , false ) ;
7073: LD_VAR 0 3
7077: PPUSH
7078: LD_INT 8
7080: PPUSH
7081: LD_INT 0
7083: PPUSH
7084: CALL_OW 49
// rutmp := Replace ( rutmp , rutmp + 1 , un ) ;
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_VAR 0 6
7097: PPUSH
7098: LD_VAR 0 6
7102: PUSH
7103: LD_INT 1
7105: PLUS
7106: PPUSH
7107: LD_VAR 0 3
7111: PPUSH
7112: CALL_OW 1
7116: ST_TO_ADDR
// ComMoveXY ( un , 133 , 11 ) ;
7117: LD_VAR 0 3
7121: PPUSH
7122: LD_INT 133
7124: PPUSH
7125: LD_INT 11
7127: PPUSH
7128: CALL_OW 111
// wait ( 0 0$0.5 ) ;
7132: LD_INT 18
7134: PPUSH
7135: CALL_OW 67
// end ;
7139: GO 7033
7141: POP
7142: POP
// for i in rutmp do
7143: LD_ADDR_VAR 0 2
7147: PUSH
7148: LD_VAR 0 6
7152: PUSH
7153: FOR_IN
7154: IFFALSE 7203
// begin AddComMoveXY ( i , 99 , 65 ) ;
7156: LD_VAR 0 2
7160: PPUSH
7161: LD_INT 99
7163: PPUSH
7164: LD_INT 65
7166: PPUSH
7167: CALL_OW 171
// AddComMoveXY ( i , 76 , 108 ) ;
7171: LD_VAR 0 2
7175: PPUSH
7176: LD_INT 76
7178: PPUSH
7179: LD_INT 108
7181: PPUSH
7182: CALL_OW 171
// AddComMoveXY ( i , 92 , 176 ) ;
7186: LD_VAR 0 2
7190: PPUSH
7191: LD_INT 92
7193: PPUSH
7194: LD_INT 176
7196: PPUSH
7197: CALL_OW 171
// end ;
7201: GO 7153
7203: POP
7204: POP
// wait ( 0 0$10 ) ;
7205: LD_INT 350
7207: PPUSH
7208: CALL_OW 67
// tmp := [ Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Kurt , Aviradze ] union heikeSecondSquad ;
7212: LD_ADDR_VAR 0 5
7216: PUSH
7217: LD_EXP 18
7221: PUSH
7222: LD_EXP 19
7226: PUSH
7227: LD_EXP 20
7231: PUSH
7232: LD_EXP 21
7236: PUSH
7237: LD_EXP 22
7241: PUSH
7242: LD_EXP 23
7246: PUSH
7247: LD_EXP 24
7251: PUSH
7252: LD_EXP 25
7256: PUSH
7257: LD_EXP 27
7261: PUSH
7262: LD_EXP 28
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: LIST
7275: LIST
7276: LIST
7277: LIST
7278: PUSH
7279: LD_EXP 29
7283: UNION
7284: ST_TO_ADDR
// tmp := tmp diff 0 ;
7285: LD_ADDR_VAR 0 5
7289: PUSH
7290: LD_VAR 0 5
7294: PUSH
7295: LD_INT 0
7297: DIFF
7298: ST_TO_ADDR
// for i in heikeVehicles do
7299: LD_ADDR_VAR 0 2
7303: PUSH
7304: LD_EXP 30
7308: PUSH
7309: FOR_IN
7310: IFFALSE 7576
// begin if not tmp then
7312: LD_VAR 0 5
7316: NOT
7317: IFFALSE 7321
// continue ;
7319: GO 7309
// PrepareTank ( 2 , i [ 5 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] , 34 ) ;
7321: LD_INT 2
7323: PPUSH
7324: LD_VAR 0 2
7328: PUSH
7329: LD_INT 5
7331: ARRAY
7332: PPUSH
7333: LD_VAR 0 2
7337: PUSH
7338: LD_INT 1
7340: ARRAY
7341: PPUSH
7342: LD_VAR 0 2
7346: PUSH
7347: LD_INT 2
7349: ARRAY
7350: PPUSH
7351: LD_VAR 0 2
7355: PUSH
7356: LD_INT 3
7358: ARRAY
7359: PPUSH
7360: LD_VAR 0 2
7364: PUSH
7365: LD_INT 4
7367: ARRAY
7368: PPUSH
7369: LD_INT 34
7371: PPUSH
7372: CALL 399 0 7
// veh := CreateVehicle ;
7376: LD_ADDR_VAR 0 4
7380: PUSH
7381: CALL_OW 45
7385: ST_TO_ADDR
// if i [ 4 ] in [ ru_cargo_bay , ar_cargo_bay , us_cargo_bay ] then
7386: LD_VAR 0 2
7390: PUSH
7391: LD_INT 4
7393: ARRAY
7394: PUSH
7395: LD_INT 51
7397: PUSH
7398: LD_INT 32
7400: PUSH
7401: LD_INT 12
7403: PUSH
7404: EMPTY
7405: LIST
7406: LIST
7407: LIST
7408: IN
7409: IFFALSE 7489
// begin if i [ 7 ] [ 1 ] then
7411: LD_VAR 0 2
7415: PUSH
7416: LD_INT 7
7418: ARRAY
7419: PUSH
7420: LD_INT 1
7422: ARRAY
7423: IFFALSE 7450
// AddCargo ( veh , mat_cans , i [ 7 ] [ 1 ] ) ;
7425: LD_VAR 0 4
7429: PPUSH
7430: LD_INT 1
7432: PPUSH
7433: LD_VAR 0 2
7437: PUSH
7438: LD_INT 7
7440: ARRAY
7441: PUSH
7442: LD_INT 1
7444: ARRAY
7445: PPUSH
7446: CALL_OW 291
// if i [ 7 ] [ 2 ] then
7450: LD_VAR 0 2
7454: PUSH
7455: LD_INT 7
7457: ARRAY
7458: PUSH
7459: LD_INT 2
7461: ARRAY
7462: IFFALSE 7489
// AddCargo ( veh , mat_oil , i [ 7 ] [ 2 ] ) ;
7464: LD_VAR 0 4
7468: PPUSH
7469: LD_INT 2
7471: PPUSH
7472: LD_VAR 0 2
7476: PUSH
7477: LD_INT 7
7479: ARRAY
7480: PUSH
7481: LD_INT 2
7483: ARRAY
7484: PPUSH
7485: CALL_OW 291
// end ; SetDir ( veh , 3 ) ;
7489: LD_VAR 0 4
7493: PPUSH
7494: LD_INT 3
7496: PPUSH
7497: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7501: LD_VAR 0 4
7505: PPUSH
7506: LD_INT 8
7508: PPUSH
7509: LD_INT 0
7511: PPUSH
7512: CALL_OW 49
// PlaceHumanInUnit ( tmp [ 1 ] , veh ) ;
7516: LD_VAR 0 5
7520: PUSH
7521: LD_INT 1
7523: ARRAY
7524: PPUSH
7525: LD_VAR 0 4
7529: PPUSH
7530: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
7534: LD_ADDR_VAR 0 5
7538: PUSH
7539: LD_VAR 0 5
7543: PPUSH
7544: LD_INT 1
7546: PPUSH
7547: CALL_OW 3
7551: ST_TO_ADDR
// ComAgressiveMove ( veh , 133 , 7 ) ;
7552: LD_VAR 0 4
7556: PPUSH
7557: LD_INT 133
7559: PPUSH
7560: LD_INT 7
7562: PPUSH
7563: CALL_OW 114
// wait ( 0 0$1 ) ;
7567: LD_INT 35
7569: PPUSH
7570: CALL_OW 67
// end ;
7574: GO 7309
7576: POP
7577: POP
// if tmp then
7578: LD_VAR 0 5
7582: IFFALSE 7638
// for i in tmp do
7584: LD_ADDR_VAR 0 2
7588: PUSH
7589: LD_VAR 0 5
7593: PUSH
7594: FOR_IN
7595: IFFALSE 7636
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7597: LD_VAR 0 2
7601: PPUSH
7602: LD_INT 10
7604: PPUSH
7605: LD_INT 0
7607: PPUSH
7608: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7612: LD_VAR 0 2
7616: PPUSH
7617: LD_INT 146
7619: PPUSH
7620: LD_INT 7
7622: PPUSH
7623: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7627: LD_INT 18
7629: PPUSH
7630: CALL_OW 67
// end ;
7634: GO 7594
7636: POP
7637: POP
// if heikeApes then
7638: LD_EXP 31
7642: IFFALSE 7698
// for i in heikeApes do
7644: LD_ADDR_VAR 0 2
7648: PUSH
7649: LD_EXP 31
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7696
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7657: LD_VAR 0 2
7661: PPUSH
7662: LD_INT 10
7664: PPUSH
7665: LD_INT 0
7667: PPUSH
7668: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7672: LD_VAR 0 2
7676: PPUSH
7677: LD_INT 146
7679: PPUSH
7680: LD_INT 7
7682: PPUSH
7683: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7687: LD_INT 18
7689: PPUSH
7690: CALL_OW 67
// end ;
7694: GO 7654
7696: POP
7697: POP
// DialogueOn ;
7698: CALL_OW 6
// Say ( Heike , DH-outpost-a-1 ) ;
7702: LD_EXP 18
7706: PPUSH
7707: LD_STRING DH-outpost-a-1
7709: PPUSH
7710: CALL_OW 88
// DialogueOff ;
7714: CALL_OW 7
// RemoveSeeing ( 133 , 2 , 2 ) ;
7718: LD_INT 133
7720: PPUSH
7721: LD_INT 2
7723: PPUSH
7724: LD_INT 2
7726: PPUSH
7727: CALL_OW 331
// InGameOff ;
7731: CALL_OW 9
// music_nat := 0 ;
7735: LD_ADDR_OWVAR 71
7739: PUSH
7740: LD_INT 0
7742: ST_TO_ADDR
// music_class := 0 ;
7743: LD_ADDR_OWVAR 72
7747: PUSH
7748: LD_INT 0
7750: ST_TO_ADDR
// ChangeMissionObjectives ( Outposts ) ;
7751: LD_STRING Outposts
7753: PPUSH
7754: CALL_OW 337
// SaveForQuickRestart ;
7758: CALL_OW 22
// end ;
7762: LD_VAR 0 1
7766: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 20 ] ] ) and ibrahimOnRuSide and IsOk ( Ibrahim ) do
7767: LD_INT 22
7769: PUSH
7770: LD_INT 2
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: LD_INT 91
7779: PUSH
7780: LD_EXP 21
7784: PUSH
7785: LD_INT 20
7787: PUSH
7788: EMPTY
7789: LIST
7790: LIST
7791: LIST
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: PPUSH
7797: CALL_OW 69
7801: PUSH
7802: LD_EXP 3
7806: AND
7807: PUSH
7808: LD_EXP 21
7812: PPUSH
7813: CALL_OW 302
7817: AND
7818: IFFALSE 7906
7820: GO 7822
7822: DISABLE
// begin IbrahimBetrayal ;
7823: CALL 7907 0 0
// repeat wait ( 0 0$1 ) ;
7827: LD_INT 35
7829: PPUSH
7830: CALL_OW 67
// until IsDead ( Ibrahim ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 6 ] ] ) ;
7834: LD_EXP 21
7838: PPUSH
7839: CALL_OW 301
7843: PUSH
7844: LD_INT 22
7846: PUSH
7847: LD_INT 2
7849: PUSH
7850: EMPTY
7851: LIST
7852: LIST
7853: PUSH
7854: LD_INT 91
7856: PUSH
7857: LD_EXP 21
7861: PUSH
7862: LD_INT 6
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: LIST
7869: PUSH
7870: EMPTY
7871: LIST
7872: LIST
7873: PPUSH
7874: CALL_OW 69
7878: OR
7879: IFFALSE 7827
// if IsDead ( Ibrahim ) then
7881: LD_EXP 21
7885: PPUSH
7886: CALL_OW 301
7890: IFFALSE 7894
// exit ;
7892: GO 7906
// SetSide ( Ibrahim , 2 ) ;
7894: LD_EXP 21
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 235
// end ;
7906: END
// export function IbrahimBetrayal ; var i , tmp ; begin
7907: LD_INT 0
7909: PPUSH
7910: PPUSH
7911: PPUSH
// PlaceSeeing ( 122 , 77 , 2 , - 6 ) ;
7912: LD_INT 122
7914: PPUSH
7915: LD_INT 77
7917: PPUSH
7918: LD_INT 2
7920: PPUSH
7921: LD_INT 6
7923: NEG
7924: PPUSH
7925: CALL_OW 330
// ComMoveXY ( Ibrahim , 123 , 79 ) ;
7929: LD_EXP 21
7933: PPUSH
7934: LD_INT 123
7936: PPUSH
7937: LD_INT 79
7939: PPUSH
7940: CALL_OW 111
// AddComTurnXY ( Ibrahim , 125 , 82 ) ;
7944: LD_EXP 21
7948: PPUSH
7949: LD_INT 125
7951: PPUSH
7952: LD_INT 82
7954: PPUSH
7955: CALL_OW 178
// wait ( 0 0$2 ) ;
7959: LD_INT 70
7961: PPUSH
7962: CALL_OW 67
// ComTurnUnit ( ruSol , Ibrahim ) ;
7966: LD_EXP 41
7970: PPUSH
7971: LD_EXP 21
7975: PPUSH
7976: CALL_OW 119
// Say ( ruSol , DRum-outpost-b-3 ) ;
7980: LD_EXP 41
7984: PPUSH
7985: LD_STRING DRum-outpost-b-3
7987: PPUSH
7988: CALL_OW 88
// tmp := [ HexInfo ( 125 , 76 ) , HexInfo ( 125 , 79 ) , HexInfo ( 125 , 82 ) ] ;
7992: LD_ADDR_VAR 0 3
7996: PUSH
7997: LD_INT 125
7999: PPUSH
8000: LD_INT 76
8002: PPUSH
8003: CALL_OW 428
8007: PUSH
8008: LD_INT 125
8010: PPUSH
8011: LD_INT 79
8013: PPUSH
8014: CALL_OW 428
8018: PUSH
8019: LD_INT 125
8021: PPUSH
8022: LD_INT 82
8024: PPUSH
8025: CALL_OW 428
8029: PUSH
8030: EMPTY
8031: LIST
8032: LIST
8033: LIST
8034: ST_TO_ADDR
// for i in tmp do
8035: LD_ADDR_VAR 0 2
8039: PUSH
8040: LD_VAR 0 3
8044: PUSH
8045: FOR_IN
8046: IFFALSE 8062
// SetLives ( i , 200 ) ;
8048: LD_VAR 0 2
8052: PPUSH
8053: LD_INT 200
8055: PPUSH
8056: CALL_OW 234
8060: GO 8045
8062: POP
8063: POP
// Say ( Ibrahim , DI-outpost-b-4 ) ;
8064: LD_EXP 21
8068: PPUSH
8069: LD_STRING DI-outpost-b-4
8071: PPUSH
8072: CALL_OW 88
// SetSide ( Ibrahim , 5 ) ;
8076: LD_EXP 21
8080: PPUSH
8081: LD_INT 5
8083: PPUSH
8084: CALL_OW 235
// ComFree ( [ Ibrahim , ruSol ] ) ;
8088: LD_EXP 21
8092: PUSH
8093: LD_EXP 41
8097: PUSH
8098: EMPTY
8099: LIST
8100: LIST
8101: PPUSH
8102: CALL_OW 139
// RemoveSeeing ( 122 , 77 , 2 ) ;
8106: LD_INT 122
8108: PPUSH
8109: LD_INT 77
8111: PPUSH
8112: LD_INT 2
8114: PPUSH
8115: CALL_OW 331
// if Givi then
8119: LD_EXP 19
8123: IFFALSE 8139
// Say ( Givi , DG-1-outpost-b-5 ) else
8125: LD_EXP 19
8129: PPUSH
8130: LD_STRING DG-1-outpost-b-5
8132: PPUSH
8133: CALL_OW 88
8137: GO 8204
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-outpost-b-a-5 ) then
8139: LD_EXP 29
8143: PPUSH
8144: LD_INT 26
8146: PUSH
8147: LD_INT 2
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PPUSH
8154: CALL_OW 72
8158: PUSH
8159: LD_INT 1
8161: ARRAY
8162: PPUSH
8163: LD_STRING DArf-outpost-b-a-5
8165: PPUSH
8166: CALL_OW 88
8170: NOT
8171: IFFALSE 8204
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-outpost-b-a-5 ) ;
8173: LD_EXP 29
8177: PPUSH
8178: LD_INT 26
8180: PUSH
8181: LD_INT 1
8183: PUSH
8184: EMPTY
8185: LIST
8186: LIST
8187: PPUSH
8188: CALL_OW 72
8192: PUSH
8193: LD_INT 1
8195: ARRAY
8196: PPUSH
8197: LD_STRING DArm-outpost-b-a-5
8199: PPUSH
8200: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
8204: LD_INT 35
8206: PPUSH
8207: CALL_OW 67
// until IsDead ( Ibrahim ) or ( GetDistUnits ( Heike , Ibrahim ) < 6 and IsOk ( Ibrahim ) ) ;
8211: LD_EXP 21
8215: PPUSH
8216: CALL_OW 301
8220: PUSH
8221: LD_EXP 18
8225: PPUSH
8226: LD_EXP 21
8230: PPUSH
8231: CALL_OW 296
8235: PUSH
8236: LD_INT 6
8238: LESS
8239: PUSH
8240: LD_EXP 21
8244: PPUSH
8245: CALL_OW 302
8249: AND
8250: OR
8251: IFFALSE 8204
// if IsDead ( Ibrahim ) then
8253: LD_EXP 21
8257: PPUSH
8258: CALL_OW 301
8262: IFFALSE 8278
// begin Say ( Heike , DH-ibrahimdead-1 ) ;
8264: LD_EXP 18
8268: PPUSH
8269: LD_STRING DH-ibrahimdead-1
8271: PPUSH
8272: CALL_OW 88
// exit ;
8276: GO 8323
// end ; CenterNowOnUnits ( Ibrahim ) ;
8278: LD_EXP 21
8282: PPUSH
8283: CALL_OW 87
// Say ( Ibrahim , DI-ibrahimlives-1 ) ;
8287: LD_EXP 21
8291: PPUSH
8292: LD_STRING DI-ibrahimlives-1
8294: PPUSH
8295: CALL_OW 88
// Say ( Heike , DH-Ibrahimlives-2 ) ;
8299: LD_EXP 18
8303: PPUSH
8304: LD_STRING DH-Ibrahimlives-2
8306: PPUSH
8307: CALL_OW 88
// SetSide ( Ibrahim , 2 ) ;
8311: LD_EXP 21
8315: PPUSH
8316: LD_INT 2
8318: PPUSH
8319: CALL_OW 235
// end ;
8323: LD_VAR 0 1
8327: RET
// every 0 0$1 trigger FilterUnitsInArea ( outerArea , [ f_side , 2 ] ) or tick >= [ 9 9$00 , 8 8$00 , 8 8$00 ] [ Difficulty ] do
8328: LD_INT 11
8330: PPUSH
8331: LD_INT 22
8333: PUSH
8334: LD_INT 2
8336: PUSH
8337: EMPTY
8338: LIST
8339: LIST
8340: PPUSH
8341: CALL_OW 70
8345: PUSH
8346: LD_OWVAR 1
8350: PUSH
8351: LD_INT 18900
8353: PUSH
8354: LD_INT 16800
8356: PUSH
8357: LD_INT 16800
8359: PUSH
8360: EMPTY
8361: LIST
8362: LIST
8363: LIST
8364: PUSH
8365: LD_OWVAR 67
8369: ARRAY
8370: GREATEREQUAL
8371: OR
8372: IFFALSE 8779
8374: GO 8376
8376: DISABLE
// begin outerAreaAchived := true ;
8377: LD_ADDR_EXP 15
8381: PUSH
8382: LD_INT 1
8384: ST_TO_ADDR
// wait ( 0 0$20 ) ;
8385: LD_INT 700
8387: PPUSH
8388: CALL_OW 67
// DialogueOn ;
8392: CALL_OW 6
// SayRadio ( Shariff , DShar-radio-1 ) ;
8396: LD_EXP 26
8400: PPUSH
8401: LD_STRING DShar-radio-1
8403: PPUSH
8404: CALL_OW 94
// SayRadio ( Shariff , DShar-radio-2 ) ;
8408: LD_EXP 26
8412: PPUSH
8413: LD_STRING DShar-radio-2
8415: PPUSH
8416: CALL_OW 94
// Say ( Heike , DH-radio-2 ) ;
8420: LD_EXP 18
8424: PPUSH
8425: LD_STRING DH-radio-2
8427: PPUSH
8428: CALL_OW 88
// DialogueOff ;
8432: CALL_OW 7
// ChangeMissionObjectives ( Gaidar ) ;
8436: LD_STRING Gaidar
8438: PPUSH
8439: CALL_OW 337
// if Difficulty < 3 then
8443: LD_OWVAR 67
8447: PUSH
8448: LD_INT 3
8450: LESS
8451: IFFALSE 8517
// begin DialogueOn ;
8453: CALL_OW 6
// PlaceSeeing ( 11 , 14 , 2 , - 6 ) ;
8457: LD_INT 11
8459: PPUSH
8460: LD_INT 14
8462: PPUSH
8463: LD_INT 2
8465: PPUSH
8466: LD_INT 6
8468: NEG
8469: PPUSH
8470: CALL_OW 330
// RemoveSeeing ( 11 , 14 , 2 ) ;
8474: LD_INT 11
8476: PPUSH
8477: LD_INT 14
8479: PPUSH
8480: LD_INT 2
8482: PPUSH
8483: CALL_OW 331
// CenterOnXY ( 11 , 14 ) ;
8487: LD_INT 11
8489: PPUSH
8490: LD_INT 14
8492: PPUSH
8493: CALL_OW 84
// dwait ( 0 0$1 ) ;
8497: LD_INT 35
8499: PPUSH
8500: CALL_OW 68
// CenterNowOnUnits ( Heike ) ;
8504: LD_EXP 18
8508: PPUSH
8509: CALL_OW 87
// DialogueOff ;
8513: CALL_OW 7
// end ; wait ( 0 0$30 + rand ( 0 0$10 , 0 0$15 ) * Difficulty ) ;
8517: LD_INT 1050
8519: PUSH
8520: LD_INT 350
8522: PPUSH
8523: LD_INT 525
8525: PPUSH
8526: CALL_OW 12
8530: PUSH
8531: LD_OWVAR 67
8535: MUL
8536: PLUS
8537: PPUSH
8538: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8542: LD_INT 35
8544: PPUSH
8545: CALL_OW 67
// until HexInfo ( 2 , 1 ) = 0 ;
8549: LD_INT 2
8551: PPUSH
8552: LD_INT 1
8554: PPUSH
8555: CALL_OW 428
8559: PUSH
8560: LD_INT 0
8562: EQUAL
8563: IFFALSE 8542
// SetDir ( Gaidar , 2 ) ;
8565: LD_EXP 34
8569: PPUSH
8570: LD_INT 2
8572: PPUSH
8573: CALL_OW 233
// PlaceUnitXY ( Gaidar , 2 , 1 , false ) ;
8577: LD_EXP 34
8581: PPUSH
8582: LD_INT 2
8584: PPUSH
8585: LD_INT 1
8587: PPUSH
8588: LD_INT 0
8590: PPUSH
8591: CALL_OW 48
// ComMoveXY ( Gaidar , 19 , 24 ) ;
8595: LD_EXP 34
8599: PPUSH
8600: LD_INT 19
8602: PPUSH
8603: LD_INT 24
8605: PPUSH
8606: CALL_OW 111
// AddComWait ( Gaidar , 0 0$6 ) ;
8610: LD_EXP 34
8614: PPUSH
8615: LD_INT 210
8617: PPUSH
8618: CALL_OW 202
// AddComMoveXY ( Gaidar , 38 , 47 ) ;
8622: LD_EXP 34
8626: PPUSH
8627: LD_INT 38
8629: PPUSH
8630: LD_INT 47
8632: PPUSH
8633: CALL_OW 171
// AddComMoveXY ( Gaidar , 32 , 59 ) ;
8637: LD_EXP 34
8641: PPUSH
8642: LD_INT 32
8644: PPUSH
8645: LD_INT 59
8647: PPUSH
8648: CALL_OW 171
// AddComWait ( Gaidar , 0 0$10 ) ;
8652: LD_EXP 34
8656: PPUSH
8657: LD_INT 350
8659: PPUSH
8660: CALL_OW 202
// AddComMoveXY ( Gaidar , 62 , 116 ) ;
8664: LD_EXP 34
8668: PPUSH
8669: LD_INT 62
8671: PPUSH
8672: LD_INT 116
8674: PPUSH
8675: CALL_OW 171
// AddComMoveXY ( Gaidar , 92 , 177 ) ;
8679: LD_EXP 34
8683: PPUSH
8684: LD_INT 92
8686: PPUSH
8687: LD_INT 177
8689: PPUSH
8690: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8694: LD_INT 35
8696: PPUSH
8697: CALL_OW 67
// until IsDead ( Gaidar ) or IsAt ( Gaidar , 92 , 177 ) ;
8701: LD_EXP 34
8705: PPUSH
8706: CALL_OW 301
8710: PUSH
8711: LD_EXP 34
8715: PPUSH
8716: LD_INT 92
8718: PPUSH
8719: LD_INT 177
8721: PPUSH
8722: CALL_OW 307
8726: OR
8727: IFFALSE 8694
// if IsAt ( Gaidar , 92 , 177 ) then
8729: LD_EXP 34
8733: PPUSH
8734: LD_INT 92
8736: PPUSH
8737: LD_INT 177
8739: PPUSH
8740: CALL_OW 307
8744: IFFALSE 8757
// begin RemoveUnit ( Gaidar ) ;
8746: LD_EXP 34
8750: PPUSH
8751: CALL_OW 64
// exit ;
8755: GO 8779
// end ; gaidarKilled := true ;
8757: LD_ADDR_EXP 14
8761: PUSH
8762: LD_INT 1
8764: ST_TO_ADDR
// ChangeMissionObjectives ( GaidarKilled ) ;
8765: LD_STRING GaidarKilled
8767: PPUSH
8768: CALL_OW 337
// SetAchievement ( ACH_COMMISAR ) ;
8772: LD_STRING ACH_COMMISAR
8774: PPUSH
8775: CALL_OW 543
// end ;
8779: END
// every 0 0$1 trigger See ( 2 , Gaidar ) do
8780: LD_INT 2
8782: PPUSH
8783: LD_EXP 34
8787: PPUSH
8788: CALL_OW 292
8792: IFFALSE 8809
8794: GO 8796
8796: DISABLE
// Say ( Gaidar , DT-objective-1 ) ;
8797: LD_EXP 34
8801: PPUSH
8802: LD_STRING DT-objective-1
8804: PPUSH
8805: CALL_OW 88
8809: END
// every 0 0$5 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) do
8810: LD_INT 22
8812: PUSH
8813: LD_INT 2
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 2
8822: PUSH
8823: LD_INT 95
8825: PUSH
8826: LD_INT 5
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: PUSH
8833: LD_INT 95
8835: PUSH
8836: LD_INT 6
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: PUSH
8843: LD_INT 95
8845: PUSH
8846: LD_INT 7
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: PUSH
8859: EMPTY
8860: LIST
8861: LIST
8862: PPUSH
8863: CALL_OW 69
8867: IFFALSE 8896
8869: GO 8871
8871: DISABLE
// begin Say ( Heike , DH-outpost-last-1 ) ;
8872: LD_EXP 18
8876: PPUSH
8877: LD_STRING DH-outpost-last-1
8879: PPUSH
8880: CALL_OW 88
// SayRadio ( Burlak , DB-outpost-last-2 ) ;
8884: LD_EXP 33
8888: PPUSH
8889: LD_STRING DB-outpost-last-2
8891: PPUSH
8892: CALL_OW 94
// end ;
8896: END
// every 0 0$1 trigger GetLives ( ruMainBase ) < 999 or GetSide ( ruMainBase ) = 2 do var i , tmp ;
8897: LD_INT 200
8899: PPUSH
8900: CALL_OW 256
8904: PUSH
8905: LD_INT 999
8907: LESS
8908: PUSH
8909: LD_INT 200
8911: PPUSH
8912: CALL_OW 255
8916: PUSH
8917: LD_INT 2
8919: EQUAL
8920: OR
8921: IFFALSE 9094
8923: GO 8925
8925: DISABLE
8926: LD_INT 0
8928: PPUSH
8929: PPUSH
// begin if not earlyEscape then
8930: LD_EXP 16
8934: NOT
8935: IFFALSE 8961
// begin SayRadio ( Burlak , DB-end-1 ) ;
8937: LD_EXP 33
8941: PPUSH
8942: LD_STRING DB-end-1
8944: PPUSH
8945: CALL_OW 94
// Say ( Heike , DH-end-2 ) ;
8949: LD_EXP 18
8953: PPUSH
8954: LD_STRING DH-end-2
8956: PPUSH
8957: CALL_OW 88
// end ; if tick <= 15 15$00 then
8961: LD_OWVAR 1
8965: PUSH
8966: LD_INT 31500
8968: LESSEQUAL
8969: IFFALSE 8978
// SetAchievement ( ACH_FIST ) ;
8971: LD_STRING ACH_FIST
8973: PPUSH
8974: CALL_OW 543
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
8978: LD_ADDR_VAR 0 2
8982: PUSH
8983: LD_INT 22
8985: PUSH
8986: LD_INT 3
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: PUSH
8993: LD_INT 3
8995: PUSH
8996: LD_INT 21
8998: PUSH
8999: LD_INT 3
9001: PUSH
9002: EMPTY
9003: LIST
9004: LIST
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PPUSH
9014: CALL_OW 69
9018: ST_TO_ADDR
// if not tmp then
9019: LD_VAR 0 2
9023: NOT
9024: IFFALSE 9028
// exit ;
9026: GO 9094
// for i in tmp do
9028: LD_ADDR_VAR 0 1
9032: PUSH
9033: LD_VAR 0 2
9037: PUSH
9038: FOR_IN
9039: IFFALSE 9092
// begin SetTag ( i , tEscape ) ;
9041: LD_VAR 0 1
9045: PPUSH
9046: LD_EXP 17
9050: PPUSH
9051: CALL_OW 109
// if IsInUnit ( i ) then
9055: LD_VAR 0 1
9059: PPUSH
9060: CALL_OW 310
9064: IFFALSE 9075
// ComExitBuilding ( i ) ;
9066: LD_VAR 0 1
9070: PPUSH
9071: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9075: LD_VAR 0 1
9079: PPUSH
9080: LD_INT 92
9082: PPUSH
9083: LD_INT 177
9085: PPUSH
9086: CALL_OW 171
// end ;
9090: GO 9038
9092: POP
9093: POP
// end ;
9094: PPOPN 2
9096: END
// every 0 0$1 trigger FilterUnitsInArea ( zone1 , [ f_side , 2 ] ) and not outerAreaAchived and IsOk ( Kurt ) do
9097: LD_INT 4
9099: PPUSH
9100: LD_INT 22
9102: PUSH
9103: LD_INT 2
9105: PUSH
9106: EMPTY
9107: LIST
9108: LIST
9109: PPUSH
9110: CALL_OW 70
9114: PUSH
9115: LD_EXP 15
9119: NOT
9120: AND
9121: PUSH
9122: LD_EXP 27
9126: PPUSH
9127: CALL_OW 302
9131: AND
9132: IFFALSE 9372
9134: GO 9136
9136: DISABLE
// begin DialogueOn ;
9137: CALL_OW 6
// PlaceSeeing ( 111 , 54 , 2 , - 16 ) ;
9141: LD_INT 111
9143: PPUSH
9144: LD_INT 54
9146: PPUSH
9147: LD_INT 2
9149: PPUSH
9150: LD_INT 16
9152: NEG
9153: PPUSH
9154: CALL_OW 330
// CenterNowOnXY ( 111 , 53 ) ;
9158: LD_INT 111
9160: PPUSH
9161: LD_INT 53
9163: PPUSH
9164: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
9168: LD_INT 10
9170: PPUSH
9171: CALL_OW 68
// Say ( Kurt , DKs-Hannibal-1 ) ;
9175: LD_EXP 27
9179: PPUSH
9180: LD_STRING DKs-Hannibal-1
9182: PPUSH
9183: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-2 ) ;
9187: LD_EXP 27
9191: PPUSH
9192: LD_STRING DKs-Hannibal-2
9194: PPUSH
9195: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-3 ) ;
9199: LD_EXP 27
9203: PPUSH
9204: LD_STRING DKs-Hannibal-3
9206: PPUSH
9207: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-4 ) ;
9211: LD_EXP 27
9215: PPUSH
9216: LD_STRING DKs-Hannibal-4
9218: PPUSH
9219: CALL_OW 88
// dwait ( 0 0$1 ) ;
9223: LD_INT 35
9225: PPUSH
9226: CALL_OW 68
// RemoveSeeing ( 111 , 54 , 2 ) ;
9230: LD_INT 111
9232: PPUSH
9233: LD_INT 54
9235: PPUSH
9236: LD_INT 2
9238: PPUSH
9239: CALL_OW 331
// PlaceSeeing ( 173 , 76 , 2 , - 12 ) ;
9243: LD_INT 173
9245: PPUSH
9246: LD_INT 76
9248: PPUSH
9249: LD_INT 2
9251: PPUSH
9252: LD_INT 12
9254: NEG
9255: PPUSH
9256: CALL_OW 330
// RemoveSeeing ( 173 , 76 , 2 ) ;
9260: LD_INT 173
9262: PPUSH
9263: LD_INT 76
9265: PPUSH
9266: LD_INT 2
9268: PPUSH
9269: CALL_OW 331
// CenterNowOnXY ( 173 , 76 ) ;
9273: LD_INT 173
9275: PPUSH
9276: LD_INT 76
9278: PPUSH
9279: CALL_OW 86
// Say ( Kurt , DKs-Hannibal-5 ) ;
9283: LD_EXP 27
9287: PPUSH
9288: LD_STRING DKs-Hannibal-5
9290: PPUSH
9291: CALL_OW 88
// if Kamil and not FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_flame_thrower ] ] ) then
9295: LD_EXP 22
9299: PUSH
9300: LD_INT 22
9302: PUSH
9303: LD_INT 2
9305: PUSH
9306: EMPTY
9307: LIST
9308: LIST
9309: PUSH
9310: LD_INT 34
9312: PUSH
9313: LD_INT 26
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PPUSH
9324: CALL_OW 69
9328: NOT
9329: AND
9330: IFFALSE 9368
// begin Say ( Kamil , DKam-Hannibal-a-6 ) ;
9332: LD_EXP 22
9336: PPUSH
9337: LD_STRING DKam-Hannibal-a-6
9339: PPUSH
9340: CALL_OW 88
// Say ( Kamil , DKam-Hannibal-a-7 ) ;
9344: LD_EXP 22
9348: PPUSH
9349: LD_STRING DKam-Hannibal-a-7
9351: PPUSH
9352: CALL_OW 88
// Say ( Givi , DG-Hannibal-a-8 ) ;
9356: LD_EXP 19
9360: PPUSH
9361: LD_STRING DG-Hannibal-a-8
9363: PPUSH
9364: CALL_OW 88
// end ; DialogueOff ;
9368: CALL_OW 7
// end ;
9372: END
// every 0 0$1 trigger IsOk ( ruSecBase ) and IsOk ( ruMainBase ) and FilterUnitsInArea ( showDefenceArea , [ f_type , unit_building ] ) > 2 and FilterUnitsInArea ( forestArea , [ f_side , 2 ] ) > 3 do
9373: LD_INT 225
9375: PPUSH
9376: CALL_OW 302
9380: PUSH
9381: LD_INT 200
9383: PPUSH
9384: CALL_OW 302
9388: AND
9389: PUSH
9390: LD_INT 12
9392: PPUSH
9393: LD_INT 21
9395: PUSH
9396: LD_INT 3
9398: PUSH
9399: EMPTY
9400: LIST
9401: LIST
9402: PPUSH
9403: CALL_OW 70
9407: PUSH
9408: LD_INT 2
9410: GREATER
9411: AND
9412: PUSH
9413: LD_INT 13
9415: PPUSH
9416: LD_INT 22
9418: PUSH
9419: LD_INT 2
9421: PUSH
9422: EMPTY
9423: LIST
9424: LIST
9425: PPUSH
9426: CALL_OW 70
9430: PUSH
9431: LD_INT 3
9433: GREATER
9434: AND
9435: IFFALSE 9448
9437: GO 9439
9439: DISABLE
// hannibalPath := true ;
9440: LD_ADDR_EXP 9
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
9448: END
// every 0 0$3 trigger hannibalPath and FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) do var i , tmp , hasFlameThrower ;
9449: LD_EXP 9
9453: PUSH
9454: LD_INT 6
9456: PPUSH
9457: LD_INT 22
9459: PUSH
9460: LD_INT 2
9462: PUSH
9463: EMPTY
9464: LIST
9465: LIST
9466: PPUSH
9467: CALL_OW 70
9471: AND
9472: IFFALSE 9809
9474: GO 9476
9476: DISABLE
9477: LD_INT 0
9479: PPUSH
9480: PPUSH
9481: PPUSH
// begin tmp := FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) ;
9482: LD_ADDR_VAR 0 2
9486: PUSH
9487: LD_INT 6
9489: PPUSH
9490: LD_INT 22
9492: PUSH
9493: LD_INT 2
9495: PUSH
9496: EMPTY
9497: LIST
9498: LIST
9499: PPUSH
9500: CALL_OW 70
9504: ST_TO_ADDR
// hasFlameThrower := UnitFilter ( tmp , [ f_weapon , ar_flame_thrower ] ) > 0 ;
9505: LD_ADDR_VAR 0 3
9509: PUSH
9510: LD_VAR 0 2
9514: PPUSH
9515: LD_INT 34
9517: PUSH
9518: LD_INT 26
9520: PUSH
9521: EMPTY
9522: LIST
9523: LIST
9524: PPUSH
9525: CALL_OW 72
9529: PUSH
9530: LD_INT 0
9532: GREATER
9533: ST_TO_ADDR
// Say ( Heike , DH-Cleverattack-1 ) ;
9534: LD_EXP 18
9538: PPUSH
9539: LD_STRING DH-Cleverattack-1
9541: PPUSH
9542: CALL_OW 88
// Say ( Heike , DH-Cleverattack-2 ) ;
9546: LD_EXP 18
9550: PPUSH
9551: LD_STRING DH-Cleverattack-2
9553: PPUSH
9554: CALL_OW 88
// if hasFlameThrower then
9558: LD_VAR 0 3
9562: IFFALSE 9590
// begin SayRadio ( Burlak , DB-Cleverattack-3 ) ;
9564: LD_EXP 33
9568: PPUSH
9569: LD_STRING DB-Cleverattack-3
9571: PPUSH
9572: CALL_OW 94
// Say ( Heike , DH-Cleverattack-4 ) ;
9576: LD_EXP 18
9580: PPUSH
9581: LD_STRING DH-Cleverattack-4
9583: PPUSH
9584: CALL_OW 88
// end else
9588: GO 9614
// begin SayRadio ( Burlak , DB-Cleverattack-a-3 ) ;
9590: LD_EXP 33
9594: PPUSH
9595: LD_STRING DB-Cleverattack-a-3
9597: PPUSH
9598: CALL_OW 94
// Say ( Heike , DH-Cleverattack-a-4 ) ;
9602: LD_EXP 18
9606: PPUSH
9607: LD_STRING DH-Cleverattack-a-4
9609: PPUSH
9610: CALL_OW 88
// end ; if not hasFlameThrower then
9614: LD_VAR 0 3
9618: NOT
9619: IFFALSE 9623
// exit ;
9621: GO 9809
// earlyEscape := true ;
9623: LD_ADDR_EXP 16
9627: PUSH
9628: LD_INT 1
9630: ST_TO_ADDR
// wait ( 0 0$4 ) ;
9631: LD_INT 140
9633: PPUSH
9634: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ] ) diff [ Ibrahim , Kuzmov , Gaidar ] ;
9638: LD_ADDR_VAR 0 2
9642: PUSH
9643: LD_INT 22
9645: PUSH
9646: LD_INT 3
9648: PUSH
9649: EMPTY
9650: LIST
9651: LIST
9652: PUSH
9653: LD_INT 2
9655: PUSH
9656: LD_INT 25
9658: PUSH
9659: LD_INT 1
9661: PUSH
9662: EMPTY
9663: LIST
9664: LIST
9665: PUSH
9666: LD_INT 25
9668: PUSH
9669: LD_INT 2
9671: PUSH
9672: EMPTY
9673: LIST
9674: LIST
9675: PUSH
9676: LD_INT 25
9678: PUSH
9679: LD_INT 4
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: LIST
9690: LIST
9691: PUSH
9692: EMPTY
9693: LIST
9694: LIST
9695: PPUSH
9696: CALL_OW 69
9700: PUSH
9701: LD_EXP 21
9705: PUSH
9706: LD_EXP 35
9710: PUSH
9711: LD_EXP 34
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: LIST
9720: DIFF
9721: ST_TO_ADDR
// for i in tmp do
9722: LD_ADDR_VAR 0 1
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: FOR_IN
9733: IFFALSE 9807
// begin if Prob ( 40 + 10 * Difficulty ) then
9735: LD_INT 40
9737: PUSH
9738: LD_INT 10
9740: PUSH
9741: LD_OWVAR 67
9745: MUL
9746: PLUS
9747: PPUSH
9748: CALL_OW 13
9752: IFFALSE 9756
// continue ;
9754: GO 9732
// SetTag ( i , tEscape ) ;
9756: LD_VAR 0 1
9760: PPUSH
9761: LD_EXP 17
9765: PPUSH
9766: CALL_OW 109
// if IsInUnit ( i ) then
9770: LD_VAR 0 1
9774: PPUSH
9775: CALL_OW 310
9779: IFFALSE 9790
// ComExitBuilding ( i ) ;
9781: LD_VAR 0 1
9785: PPUSH
9786: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9790: LD_VAR 0 1
9794: PPUSH
9795: LD_INT 92
9797: PPUSH
9798: LD_INT 177
9800: PPUSH
9801: CALL_OW 171
// end ;
9805: GO 9732
9807: POP
9808: POP
// end ;
9809: PPOPN 3
9811: END
// every 0 0$1 trigger FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do var i ;
9812: LD_INT 9
9814: PPUSH
9815: LD_INT 2
9817: PUSH
9818: LD_INT 22
9820: PUSH
9821: LD_INT 3
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: PUSH
9828: LD_INT 22
9830: PUSH
9831: LD_INT 6
9833: PUSH
9834: EMPTY
9835: LIST
9836: LIST
9837: PUSH
9838: EMPTY
9839: LIST
9840: LIST
9841: LIST
9842: PPUSH
9843: CALL_OW 70
9847: IFFALSE 9945
9849: GO 9851
9851: DISABLE
9852: LD_INT 0
9854: PPUSH
// begin enable ;
9855: ENABLE
// for i in FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do
9856: LD_ADDR_VAR 0 1
9860: PUSH
9861: LD_INT 9
9863: PPUSH
9864: LD_INT 2
9866: PUSH
9867: LD_INT 22
9869: PUSH
9870: LD_INT 3
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: PUSH
9877: LD_INT 22
9879: PUSH
9880: LD_INT 6
9882: PUSH
9883: EMPTY
9884: LIST
9885: LIST
9886: PUSH
9887: EMPTY
9888: LIST
9889: LIST
9890: LIST
9891: PPUSH
9892: CALL_OW 70
9896: PUSH
9897: FOR_IN
9898: IFFALSE 9943
// if GetTag ( i ) = tEscape or GetSide ( i ) = 6 then
9900: LD_VAR 0 1
9904: PPUSH
9905: CALL_OW 110
9909: PUSH
9910: LD_EXP 17
9914: EQUAL
9915: PUSH
9916: LD_VAR 0 1
9920: PPUSH
9921: CALL_OW 255
9925: PUSH
9926: LD_INT 6
9928: EQUAL
9929: OR
9930: IFFALSE 9941
// RemoveUnit ( i ) ;
9932: LD_VAR 0 1
9936: PPUSH
9937: CALL_OW 64
9941: GO 9897
9943: POP
9944: POP
// end ;
9945: PPOPN 1
9947: END
// every 0 0$1 trigger Kaia and GetLives ( Kaia ) < 3 do
9948: LD_EXP 23
9952: PUSH
9953: LD_EXP 23
9957: PPUSH
9958: CALL_OW 256
9962: PUSH
9963: LD_INT 3
9965: LESS
9966: AND
9967: IFFALSE 10013
9969: GO 9971
9971: DISABLE
// begin DialogueOn ;
9972: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
9976: LD_EXP 23
9980: PPUSH
9981: CALL_OW 87
// ForceSay ( Kaia , DK-Kkilled-1 ) ;
9985: LD_EXP 23
9989: PPUSH
9990: LD_STRING DK-Kkilled-1
9992: PPUSH
9993: CALL_OW 91
// Say ( Heike , DH-Kkilled-2 ) ;
9997: LD_EXP 18
10001: PPUSH
10002: LD_STRING DH-Kkilled-2
10004: PPUSH
10005: CALL_OW 88
// DialogueOff ;
10009: CALL_OW 7
// end ;
10013: END
// every 0 0$1 trigger kaiaKilledByRussian do
10014: LD_EXP 8
10018: IFFALSE 10035
10020: GO 10022
10022: DISABLE
// Say ( Heike , DH-Kkilled-3 ) ;
10023: LD_EXP 18
10027: PPUSH
10028: LD_STRING DH-Kkilled-3
10030: PPUSH
10031: CALL_OW 88
10035: END
// every 0 0$1 trigger tick >= 22 22$00 do
10036: LD_OWVAR 1
10040: PUSH
10041: LD_INT 46200
10043: GREATEREQUAL
10044: IFFALSE 10073
10046: GO 10048
10048: DISABLE
// begin SayRadio ( Shariff , DShar-slow-1 ) ;
10049: LD_EXP 26
10053: PPUSH
10054: LD_STRING DShar-slow-1
10056: PPUSH
10057: CALL_OW 94
// SayRadio ( Shariff , DShar-slow-2 ) ;
10061: LD_EXP 26
10065: PPUSH
10066: LD_STRING DShar-slow-2
10068: PPUSH
10069: CALL_OW 94
// end ;
10073: END
// every 0 0$1 trigger tick >= [ 40 40$00 , 36 36$00 , 32 32$00 ] [ Difficulty ] do
10074: LD_OWVAR 1
10078: PUSH
10079: LD_INT 84000
10081: PUSH
10082: LD_INT 75600
10084: PUSH
10085: LD_INT 67200
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: LIST
10092: PUSH
10093: LD_OWVAR 67
10097: ARRAY
10098: GREATEREQUAL
10099: IFFALSE 10143
10101: GO 10103
10103: DISABLE
// begin DialogueOn ;
10104: CALL_OW 6
// SayRadio ( Shariff , DShar-fail-1 ) ;
10108: LD_EXP 26
10112: PPUSH
10113: LD_STRING DShar-fail-1
10115: PPUSH
10116: CALL_OW 94
// SayRadio ( Shariff , DShar-fail-2 ) ;
10120: LD_EXP 26
10124: PPUSH
10125: LD_STRING DShar-fail-2
10127: PPUSH
10128: CALL_OW 94
// DialogueOff ;
10132: CALL_OW 7
// YouLost ( Time ) ;
10136: LD_STRING Time
10138: PPUSH
10139: CALL_OW 104
// end ;
10143: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) = 0 do var tmp ;
10144: LD_INT 22
10146: PUSH
10147: LD_INT 3
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: PUSH
10154: LD_INT 2
10156: PUSH
10157: LD_INT 30
10159: PUSH
10160: LD_INT 1
10162: PUSH
10163: EMPTY
10164: LIST
10165: LIST
10166: PUSH
10167: LD_INT 30
10169: PUSH
10170: LD_INT 0
10172: PUSH
10173: EMPTY
10174: LIST
10175: LIST
10176: PUSH
10177: EMPTY
10178: LIST
10179: LIST
10180: LIST
10181: PUSH
10182: EMPTY
10183: LIST
10184: LIST
10185: PPUSH
10186: CALL_OW 69
10190: PUSH
10191: LD_INT 0
10193: EQUAL
10194: IFFALSE 10685
10196: GO 10198
10198: DISABLE
10199: LD_INT 0
10201: PPUSH
// begin if ( tick + gameTime ) <= [ 75 75$00 , 70 70$00 , 65 65$00 ] [ Difficulty ] then
10202: LD_OWVAR 1
10206: PUSH
10207: LD_EXP 5
10211: PLUS
10212: PUSH
10213: LD_INT 157500
10215: PUSH
10216: LD_INT 147000
10218: PUSH
10219: LD_INT 136500
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: PUSH
10227: LD_OWVAR 67
10231: ARRAY
10232: LESSEQUAL
10233: IFFALSE 10247
// AddMedal ( med1 , 1 ) else
10235: LD_STRING med1
10237: PPUSH
10238: LD_INT 1
10240: PPUSH
10241: CALL_OW 101
10245: GO 10258
// AddMedal ( med1 , - 1 ) ;
10247: LD_STRING med1
10249: PPUSH
10250: LD_INT 1
10252: NEG
10253: PPUSH
10254: CALL_OW 101
// if ( flamethrowers >= 3 ) * baseHill * hannibalPath * ( loseCounter < [ 6 , 5 , 4 ] [ Difficulty ] ) then
10258: LD_EXP 7
10262: PUSH
10263: LD_INT 3
10265: GREATEREQUAL
10266: PUSH
10267: LD_EXP 11
10271: MUL
10272: PUSH
10273: LD_EXP 9
10277: MUL
10278: PUSH
10279: LD_EXP 6
10283: PUSH
10284: LD_INT 6
10286: PUSH
10287: LD_INT 5
10289: PUSH
10290: LD_INT 4
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: LIST
10297: PUSH
10298: LD_OWVAR 67
10302: ARRAY
10303: LESS
10304: MUL
10305: IFFALSE 10319
// AddMedal ( med2 , 1 ) else
10307: LD_STRING med2
10309: PPUSH
10310: LD_INT 1
10312: PPUSH
10313: CALL_OW 101
10317: GO 10330
// AddMedal ( med2 , - 1 ) ;
10319: LD_STRING med2
10321: PPUSH
10322: LD_INT 1
10324: NEG
10325: PPUSH
10326: CALL_OW 101
// if gaidarKilled then
10330: LD_EXP 14
10334: IFFALSE 10348
// AddMedal ( med3 , 1 ) else
10336: LD_STRING med3
10338: PPUSH
10339: LD_INT 1
10341: PPUSH
10342: CALL_OW 101
10346: GO 10359
// AddMedal ( med3 , - 1 ) ;
10348: LD_STRING med3
10350: PPUSH
10351: LD_INT 1
10353: NEG
10354: PPUSH
10355: CALL_OW 101
// GiveMedals ( MAIN ) ;
10359: LD_STRING MAIN
10361: PPUSH
10362: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_nation , 0 ] ] ] ) ) ;
10366: LD_INT 22
10368: PUSH
10369: LD_INT 2
10371: PUSH
10372: EMPTY
10373: LIST
10374: LIST
10375: PUSH
10376: LD_INT 3
10378: PUSH
10379: LD_INT 23
10381: PUSH
10382: LD_INT 0
10384: PUSH
10385: EMPTY
10386: LIST
10387: LIST
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: PPUSH
10397: CALL_OW 69
10401: PPUSH
10402: CALL_OW 43
// SaveCharacters ( Heike , 04_2_Heike ) ;
10406: LD_EXP 18
10410: PPUSH
10411: LD_STRING 04_2_Heike
10413: PPUSH
10414: CALL_OW 38
// if Aviradze then
10418: LD_EXP 28
10422: IFFALSE 10436
// SaveCharacters ( Aviradze , 04_2_Aviradze ) ;
10424: LD_EXP 28
10428: PPUSH
10429: LD_STRING 04_2_Aviradze
10431: PPUSH
10432: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
10436: LD_EXP 21
10440: PUSH
10441: LD_EXP 21
10445: PPUSH
10446: CALL_OW 255
10450: PUSH
10451: LD_INT 2
10453: EQUAL
10454: AND
10455: IFFALSE 10485
// begin if ibrahimOnRuSide then
10457: LD_EXP 3
10461: IFFALSE 10473
// SaveVariable ( true , 04_2_IbrahimJoined ) ;
10463: LD_INT 1
10465: PPUSH
10466: LD_STRING 04_2_IbrahimJoined
10468: PPUSH
10469: CALL_OW 39
// SaveCharacters ( Ibrahim , 04_2_Ibrahim ) ;
10473: LD_EXP 21
10477: PPUSH
10478: LD_STRING 04_2_Ibrahim
10480: PPUSH
10481: CALL_OW 38
// end ; if Kamil then
10485: LD_EXP 22
10489: IFFALSE 10503
// SaveCharacters ( Kamil , 04_2_Kamil ) ;
10491: LD_EXP 22
10495: PPUSH
10496: LD_STRING 04_2_Kamil
10498: PPUSH
10499: CALL_OW 38
// if Sophia then
10503: LD_EXP 24
10507: IFFALSE 10521
// SaveCharacters ( Sophia , 04_2_Sophia ) ;
10509: LD_EXP 24
10513: PPUSH
10514: LD_STRING 04_2_Sophia
10516: PPUSH
10517: CALL_OW 38
// if Kaia then
10521: LD_EXP 23
10525: IFFALSE 10539
// SaveCharacters ( Kaia , 04_2_Kaia ) ;
10527: LD_EXP 23
10531: PPUSH
10532: LD_STRING 04_2_Kaia
10534: PPUSH
10535: CALL_OW 38
// if Givi then
10539: LD_EXP 19
10543: IFFALSE 10557
// SaveCharacters ( Givi , 04_2_Givi ) ;
10545: LD_EXP 19
10549: PPUSH
10550: LD_STRING 04_2_Givi
10552: PPUSH
10553: CALL_OW 38
// if Mike then
10557: LD_EXP 20
10561: IFFALSE 10575
// SaveCharacters ( Mike , 04_2_Mike ) ;
10563: LD_EXP 20
10567: PPUSH
10568: LD_STRING 04_2_Mike
10570: PPUSH
10571: CALL_OW 38
// if Markov then
10575: LD_EXP 25
10579: IFFALSE 10593
// SaveCharacters ( Markov , 04_2_Markov ) ;
10581: LD_EXP 25
10585: PPUSH
10586: LD_STRING 04_2_Markov
10588: PPUSH
10589: CALL_OW 38
// if Kurt then
10593: LD_EXP 27
10597: IFFALSE 10611
// SaveCharacters ( Kurt , 04_2_Kurt ) ;
10599: LD_EXP 27
10603: PPUSH
10604: LD_STRING 04_2_Kurt
10606: PPUSH
10607: CALL_OW 38
// if heikeSecondSquad then
10611: LD_EXP 29
10615: IFFALSE 10629
// SaveCharacters ( heikeSecondSquad , 04_2_others ) ;
10617: LD_EXP 29
10621: PPUSH
10622: LD_STRING 04_2_others
10624: PPUSH
10625: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
10629: LD_ADDR_VAR 0 1
10633: PUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 2
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PUSH
10644: LD_INT 23
10646: PUSH
10647: LD_INT 0
10649: PUSH
10650: EMPTY
10651: LIST
10652: LIST
10653: PUSH
10654: EMPTY
10655: LIST
10656: LIST
10657: PPUSH
10658: CALL_OW 69
10662: ST_TO_ADDR
// if tmp then
10663: LD_VAR 0 1
10667: IFFALSE 10681
// SaveCharacters ( tmp , 04_2_apes ) ;
10669: LD_VAR 0 1
10673: PPUSH
10674: LD_STRING 04_2_apes
10676: PPUSH
10677: CALL_OW 38
// YouWin ;
10681: CALL_OW 103
// end ;
10685: PPOPN 1
10687: END
