// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 45 0 0
// InitTag ;
   8: CALL 229 0 0
// PrepareNature ( natureArea ) ;
  12: LD_INT 2
  14: PPUSH
  15: CALL 704 0 1
// PrepareRussian ;
  19: CALL 3274 0 0
// PrepareArabian ;
  23: CALL 2626 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 2 ) ;
  33: LD_INT 2
  35: PPUSH
  36: CALL_OW 344
// Action ;
  40: CALL 6866 0 0
// end ;
  44: END
// export debug , prefix ; export ibrahimOnRuSide , ruEscapeAllowed , gameTime , loseCounter , flamethrowers , kaiaKilledByRussian , hannibalPath , ruEscapeCounter , baseHill , explodeFirstDepot , explodeSecondDepot , gaidarKilled , outerAreaAchived , earlyEscape ; function Init ; begin
  45: LD_INT 0
  47: PPUSH
// debug := false ;
  48: LD_ADDR_EXP 1
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// prefix := 04_1_ ;
  56: LD_ADDR_EXP 2
  60: PUSH
  61: LD_STRING 04_1_
  63: ST_TO_ADDR
// ibrahimOnRuSide := LoadVariable ( 03_IbrahimHasEscaped , false ) ;
  64: LD_ADDR_EXP 3
  68: PUSH
  69: LD_STRING 03_IbrahimHasEscaped
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: CALL_OW 30
  79: ST_TO_ADDR
// ruEscapeCounter := LoadVariable ( 04_1_EscapeCounter , 0 ) ;
  80: LD_ADDR_EXP 10
  84: PUSH
  85: LD_STRING 04_1_EscapeCounter
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// loseCounter := LoadVariable ( 04_1_DeadCounter , 0 ) ;
  96: LD_ADDR_EXP 6
 100: PUSH
 101: LD_STRING 04_1_DeadCounter
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// baseHill := LoadVariable ( 04_1_BaseHill , false ) ;
 112: LD_ADDR_EXP 11
 116: PUSH
 117: LD_STRING 04_1_BaseHill
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL_OW 30
 127: ST_TO_ADDR
// gameTime := LoadVariable ( 04_1_Time , 40 40$00 ) ;
 128: LD_ADDR_EXP 5
 132: PUSH
 133: LD_STRING 04_1_Time
 135: PPUSH
 136: LD_INT 84000
 138: PPUSH
 139: CALL_OW 30
 143: ST_TO_ADDR
// flamethrowers := LoadVariable ( 04_1_Flamethrower , 0 ) ;
 144: LD_ADDR_EXP 7
 148: PUSH
 149: LD_STRING 04_1_Flamethrower
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: CALL_OW 30
 159: ST_TO_ADDR
// ruEscapeAllowed := false ;
 160: LD_ADDR_EXP 4
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// explodeFirstDepot := false ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// explodeSecondDepot := false ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// gaidarKilled := false ;
 184: LD_ADDR_EXP 14
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// kaiaKilledByRussian := false ;
 192: LD_ADDR_EXP 8
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// outerAreaAchived := false ;
 200: LD_ADDR_EXP 15
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// hannibalPath := false ;
 208: LD_ADDR_EXP 9
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// earlyEscape := false ;
 216: LD_ADDR_EXP 16
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// export tEscape ; function InitTag ; begin
 229: LD_INT 0
 231: PPUSH
// tEscape := 10 ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: LD_INT 10
 239: ST_TO_ADDR
// end ;
 240: LD_VAR 0 1
 244: RET
// every 0 0$1 trigger debug do var i ;
 245: LD_EXP 1
 249: IFFALSE 333
 251: GO 253
 253: DISABLE
 254: LD_INT 0
 256: PPUSH
// begin enable ;
 257: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) do
 258: LD_ADDR_VAR 0 1
 262: PUSH
 263: LD_INT 22
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: LD_INT 21
 278: PUSH
 279: LD_INT 3
 281: PUSH
 282: EMPTY
 283: LIST
 284: LIST
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: FOR_IN
 300: IFFALSE 331
// if GetLives ( i ) < 1000 then
 302: LD_VAR 0 1
 306: PPUSH
 307: CALL_OW 256
 311: PUSH
 312: LD_INT 1000
 314: LESS
 315: IFFALSE 329
// SetLives ( i , 1000 ) ;
 317: LD_VAR 0 1
 321: PPUSH
 322: LD_INT 1000
 324: PPUSH
 325: CALL_OW 234
 329: GO 299
 331: POP
 332: POP
// end ; end_of_file
 333: PPOPN 1
 335: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 336: LD_INT 0
 338: PPUSH
 339: PPUSH
// if exist_mode then
 340: LD_VAR 0 2
 344: IFFALSE 369
// unit := CreateCharacter ( prefix & ident ) else
 346: LD_ADDR_VAR 0 5
 350: PUSH
 351: LD_VAR 0 3
 355: PUSH
 356: LD_VAR 0 1
 360: STR
 361: PPUSH
 362: CALL_OW 34
 366: ST_TO_ADDR
 367: GO 384
// unit := NewCharacter ( ident ) ;
 369: LD_ADDR_VAR 0 5
 373: PUSH
 374: LD_VAR 0 1
 378: PPUSH
 379: CALL_OW 25
 383: ST_TO_ADDR
// result := unit ;
 384: LD_ADDR_VAR 0 4
 388: PUSH
 389: LD_VAR 0 5
 393: ST_TO_ADDR
// end ;
 394: LD_VAR 0 4
 398: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 399: LD_INT 0
 401: PPUSH
// uc_side := side ;
 402: LD_ADDR_OWVAR 20
 406: PUSH
 407: LD_VAR 0 1
 411: ST_TO_ADDR
// uc_nation := nation ;
 412: LD_ADDR_OWVAR 21
 416: PUSH
 417: LD_VAR 0 2
 421: ST_TO_ADDR
// vc_chassis := chassis ;
 422: LD_ADDR_OWVAR 37
 426: PUSH
 427: LD_VAR 0 3
 431: ST_TO_ADDR
// vc_engine := engine ;
 432: LD_ADDR_OWVAR 39
 436: PUSH
 437: LD_VAR 0 4
 441: ST_TO_ADDR
// vc_control := control ;
 442: LD_ADDR_OWVAR 38
 446: PUSH
 447: LD_VAR 0 5
 451: ST_TO_ADDR
// vc_weapon := weapon ;
 452: LD_ADDR_OWVAR 40
 456: PUSH
 457: LD_VAR 0 6
 461: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 462: LD_ADDR_OWVAR 41
 466: PUSH
 467: LD_VAR 0 7
 471: ST_TO_ADDR
// result := CreateVehicle ;
 472: LD_ADDR_VAR 0 8
 476: PUSH
 477: CALL_OW 45
 481: ST_TO_ADDR
// end ;
 482: LD_VAR 0 8
 486: RET
// export function SayX ( units , ident ) ; var i ; begin
 487: LD_INT 0
 489: PPUSH
 490: PPUSH
// result := false ;
 491: LD_ADDR_VAR 0 3
 495: PUSH
 496: LD_INT 0
 498: ST_TO_ADDR
// if not units then
 499: LD_VAR 0 1
 503: NOT
 504: IFFALSE 508
// exit ;
 506: GO 562
// for i in units do
 508: LD_ADDR_VAR 0 4
 512: PUSH
 513: LD_VAR 0 1
 517: PUSH
 518: FOR_IN
 519: IFFALSE 560
// if IsOk ( i ) then
 521: LD_VAR 0 4
 525: PPUSH
 526: CALL_OW 302
 530: IFFALSE 558
// begin Say ( i , ident ) ;
 532: LD_VAR 0 4
 536: PPUSH
 537: LD_VAR 0 2
 541: PPUSH
 542: CALL_OW 88
// result := i ;
 546: LD_ADDR_VAR 0 3
 550: PUSH
 551: LD_VAR 0 4
 555: ST_TO_ADDR
// break ;
 556: GO 560
// end ;
 558: GO 518
 560: POP
 561: POP
// end ;
 562: LD_VAR 0 3
 566: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 567: LD_INT 0
 569: PPUSH
 570: PPUSH
// InitUc ;
 571: CALL_OW 18
// InitHc ;
 575: CALL_OW 19
// uc_side := 0 ;
 579: LD_ADDR_OWVAR 20
 583: PUSH
 584: LD_INT 0
 586: ST_TO_ADDR
// uc_nation := 0 ;
 587: LD_ADDR_OWVAR 21
 591: PUSH
 592: LD_INT 0
 594: ST_TO_ADDR
// for i = 1 to amount do
 595: LD_ADDR_VAR 0 4
 599: PUSH
 600: DOUBLE
 601: LD_INT 1
 603: DEC
 604: ST_TO_ADDR
 605: LD_VAR 0 2
 609: PUSH
 610: FOR_TO
 611: IFFALSE 693
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 613: LD_ADDR_OWVAR 29
 617: PUSH
 618: LD_INT 9
 620: PPUSH
 621: LD_INT 12
 623: PPUSH
 624: CALL_OW 12
 628: PUSH
 629: LD_INT 9
 631: PPUSH
 632: LD_INT 12
 634: PPUSH
 635: CALL_OW 12
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 644: LD_ADDR_OWVAR 35
 648: PUSH
 649: LD_INT 1
 651: NEG
 652: PPUSH
 653: LD_INT 1
 655: PPUSH
 656: CALL_OW 12
 660: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 661: LD_INT 0
 663: PPUSH
 664: LD_INT 12
 666: PPUSH
 667: LD_INT 1
 669: PPUSH
 670: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 674: CALL_OW 44
 678: PPUSH
 679: LD_VAR 0 1
 683: PPUSH
 684: LD_INT 0
 686: PPUSH
 687: CALL_OW 49
// end ;
 691: GO 610
 693: POP
 694: POP
// InitHc ;
 695: CALL_OW 19
// end ;
 699: LD_VAR 0 3
 703: RET
// export function PrepareNature ( forest ) ; var i ; begin
 704: LD_INT 0
 706: PPUSH
 707: PPUSH
// SpawnApeman ( forest , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
 708: LD_VAR 0 1
 712: PPUSH
 713: LD_INT 3
 715: PUSH
 716: LD_INT 3
 718: PUSH
 719: LD_INT 2
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_OWVAR 67
 731: ARRAY
 732: PPUSH
 733: CALL 567 0 2
// for i := 1 to 2 do
 737: LD_ADDR_VAR 0 3
 741: PUSH
 742: DOUBLE
 743: LD_INT 1
 745: DEC
 746: ST_TO_ADDR
 747: LD_INT 2
 749: PUSH
 750: FOR_TO
 751: IFFALSE 788
// begin hc_class := 21 ;
 753: LD_ADDR_OWVAR 28
 757: PUSH
 758: LD_INT 21
 760: ST_TO_ADDR
// hc_gallery :=  ;
 761: LD_ADDR_OWVAR 33
 765: PUSH
 766: LD_STRING 
 768: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 769: CALL_OW 44
 773: PPUSH
 774: LD_VAR 0 1
 778: PPUSH
 779: LD_INT 0
 781: PPUSH
 782: CALL_OW 49
// end ;
 786: GO 750
 788: POP
 789: POP
// for i := 1 to 2 do
 790: LD_ADDR_VAR 0 3
 794: PUSH
 795: DOUBLE
 796: LD_INT 1
 798: DEC
 799: ST_TO_ADDR
 800: LD_INT 2
 802: PUSH
 803: FOR_TO
 804: IFFALSE 841
// begin hc_class := 18 ;
 806: LD_ADDR_OWVAR 28
 810: PUSH
 811: LD_INT 18
 813: ST_TO_ADDR
// hc_gallery :=  ;
 814: LD_ADDR_OWVAR 33
 818: PUSH
 819: LD_STRING 
 821: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 822: CALL_OW 44
 826: PPUSH
 827: LD_VAR 0 1
 831: PPUSH
 832: LD_INT 0
 834: PPUSH
 835: CALL_OW 49
// end ;
 839: GO 803
 841: POP
 842: POP
// for i := 1 to 2 do
 843: LD_ADDR_VAR 0 3
 847: PUSH
 848: DOUBLE
 849: LD_INT 1
 851: DEC
 852: ST_TO_ADDR
 853: LD_INT 2
 855: PUSH
 856: FOR_TO
 857: IFFALSE 894
// begin hc_class := 13 ;
 859: LD_ADDR_OWVAR 28
 863: PUSH
 864: LD_INT 13
 866: ST_TO_ADDR
// hc_gallery :=  ;
 867: LD_ADDR_OWVAR 33
 871: PUSH
 872: LD_STRING 
 874: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 875: CALL_OW 44
 879: PPUSH
 880: LD_VAR 0 1
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// end ;
 892: GO 856
 894: POP
 895: POP
// end ;
 896: LD_VAR 0 2
 900: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 901: LD_INT 0
 903: PPUSH
 904: PPUSH
 905: PPUSH
// if not observer or not unit then
 906: LD_VAR 0 1
 910: NOT
 911: PUSH
 912: LD_VAR 0 2
 916: NOT
 917: OR
 918: IFFALSE 922
// exit ;
 920: GO 970
// if not See ( GetSide ( observer ) , unit ) then
 922: LD_VAR 0 1
 926: PPUSH
 927: CALL_OW 255
 931: PPUSH
 932: LD_VAR 0 2
 936: PPUSH
 937: CALL_OW 292
 941: NOT
 942: IFFALSE 946
// exit ;
 944: GO 970
// result := GetDistUnits ( observer , unit ) < 12 ;
 946: LD_ADDR_VAR 0 3
 950: PUSH
 951: LD_VAR 0 1
 955: PPUSH
 956: LD_VAR 0 2
 960: PPUSH
 961: CALL_OW 296
 965: PUSH
 966: LD_INT 12
 968: LESS
 969: ST_TO_ADDR
// end ;
 970: LD_VAR 0 3
 974: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 975: LD_INT 0
 977: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 978: LD_VAR 0 2
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: LD_VAR 0 2
 991: PUSH
 992: LD_INT 2
 994: ARRAY
 995: PPUSH
 996: CALL_OW 488
1000: PUSH
1001: LD_VAR 0 2
1005: PUSH
1006: LD_INT 1
1008: ARRAY
1009: PPUSH
1010: LD_VAR 0 2
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 428
1023: PUSH
1024: LD_INT 0
1026: EQUAL
1027: AND
1028: IFFALSE 1062
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
1030: LD_VAR 0 1
1034: PPUSH
1035: LD_VAR 0 2
1039: PUSH
1040: LD_INT 1
1042: ARRAY
1043: PPUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_INT 2
1051: ARRAY
1052: PPUSH
1053: LD_VAR 0 3
1057: PPUSH
1058: CALL_OW 48
// end ;
1062: LD_VAR 0 4
1066: RET
// export function Video ( mode ) ; begin
1067: LD_INT 0
1069: PPUSH
// ingame_video = mode ;
1070: LD_ADDR_OWVAR 52
1074: PUSH
1075: LD_VAR 0 1
1079: ST_TO_ADDR
// interface_hidden = mode ;
1080: LD_ADDR_OWVAR 54
1084: PUSH
1085: LD_VAR 0 1
1089: ST_TO_ADDR
// end ;
1090: LD_VAR 0 2
1094: RET
// export function ReverseArray ( array ) ; var i ; begin
1095: LD_INT 0
1097: PPUSH
1098: PPUSH
// if not array then
1099: LD_VAR 0 1
1103: NOT
1104: IFFALSE 1108
// exit ;
1106: GO 1166
// result := [ ] ;
1108: LD_ADDR_VAR 0 2
1112: PUSH
1113: EMPTY
1114: ST_TO_ADDR
// for i := 1 to array do
1115: LD_ADDR_VAR 0 3
1119: PUSH
1120: DOUBLE
1121: LD_INT 1
1123: DEC
1124: ST_TO_ADDR
1125: LD_VAR 0 1
1129: PUSH
1130: FOR_TO
1131: IFFALSE 1164
// result := Insert ( result , 1 , array [ i ] ) ;
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 2
1142: PPUSH
1143: LD_INT 1
1145: PPUSH
1146: LD_VAR 0 1
1150: PUSH
1151: LD_VAR 0 3
1155: ARRAY
1156: PPUSH
1157: CALL_OW 2
1161: ST_TO_ADDR
1162: GO 1130
1164: POP
1165: POP
// end ;
1166: LD_VAR 0 2
1170: RET
// export function ComExit ( unit ) ; begin
1171: LD_INT 0
1173: PPUSH
// result := IsInUnit ( unit ) ;
1174: LD_ADDR_VAR 0 2
1178: PUSH
1179: LD_VAR 0 1
1183: PPUSH
1184: CALL_OW 310
1188: ST_TO_ADDR
// if not result then
1189: LD_VAR 0 2
1193: NOT
1194: IFFALSE 1198
// exit ;
1196: GO 1233
// if GetType ( result ) = unit_vehicle then
1198: LD_VAR 0 2
1202: PPUSH
1203: CALL_OW 247
1207: PUSH
1208: LD_INT 2
1210: EQUAL
1211: IFFALSE 1224
// ComExitVehicle ( unit ) else
1213: LD_VAR 0 1
1217: PPUSH
1218: CALL_OW 121
1222: GO 1233
// ComExitBuilding ( unit ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: CALL_OW 122
// end ;
1233: LD_VAR 0 2
1237: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1238: LD_INT 0
1240: PPUSH
1241: PPUSH
// if not side or not nation then
1242: LD_VAR 0 1
1246: NOT
1247: PUSH
1248: LD_VAR 0 2
1252: NOT
1253: OR
1254: IFFALSE 1258
// exit ;
1256: GO 2022
// case nation of nation_american :
1258: LD_VAR 0 2
1262: PUSH
1263: LD_INT 1
1265: DOUBLE
1266: EQUAL
1267: IFTRUE 1271
1269: GO 1485
1271: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1272: LD_ADDR_VAR 0 4
1276: PUSH
1277: LD_INT 35
1279: PUSH
1280: LD_INT 45
1282: PUSH
1283: LD_INT 46
1285: PUSH
1286: LD_INT 47
1288: PUSH
1289: LD_INT 82
1291: PUSH
1292: LD_INT 83
1294: PUSH
1295: LD_INT 84
1297: PUSH
1298: LD_INT 85
1300: PUSH
1301: LD_INT 86
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: LD_INT 2
1309: PUSH
1310: LD_INT 6
1312: PUSH
1313: LD_INT 15
1315: PUSH
1316: LD_INT 16
1318: PUSH
1319: LD_INT 7
1321: PUSH
1322: LD_INT 12
1324: PUSH
1325: LD_INT 13
1327: PUSH
1328: LD_INT 10
1330: PUSH
1331: LD_INT 14
1333: PUSH
1334: LD_INT 20
1336: PUSH
1337: LD_INT 21
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_INT 25
1345: PUSH
1346: LD_INT 32
1348: PUSH
1349: LD_INT 27
1351: PUSH
1352: LD_INT 36
1354: PUSH
1355: LD_INT 69
1357: PUSH
1358: LD_INT 39
1360: PUSH
1361: LD_INT 34
1363: PUSH
1364: LD_INT 40
1366: PUSH
1367: LD_INT 48
1369: PUSH
1370: LD_INT 49
1372: PUSH
1373: LD_INT 50
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 52
1381: PUSH
1382: LD_INT 53
1384: PUSH
1385: LD_INT 54
1387: PUSH
1388: LD_INT 55
1390: PUSH
1391: LD_INT 56
1393: PUSH
1394: LD_INT 57
1396: PUSH
1397: LD_INT 58
1399: PUSH
1400: LD_INT 59
1402: PUSH
1403: LD_INT 60
1405: PUSH
1406: LD_INT 61
1408: PUSH
1409: LD_INT 62
1411: PUSH
1412: LD_INT 80
1414: PUSH
1415: LD_INT 82
1417: PUSH
1418: LD_INT 83
1420: PUSH
1421: LD_INT 84
1423: PUSH
1424: LD_INT 85
1426: PUSH
1427: LD_INT 86
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: ST_TO_ADDR
1483: GO 1946
1485: LD_INT 2
1487: DOUBLE
1488: EQUAL
1489: IFTRUE 1493
1491: GO 1715
1493: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_INT 35
1501: PUSH
1502: LD_INT 45
1504: PUSH
1505: LD_INT 46
1507: PUSH
1508: LD_INT 47
1510: PUSH
1511: LD_INT 82
1513: PUSH
1514: LD_INT 83
1516: PUSH
1517: LD_INT 84
1519: PUSH
1520: LD_INT 85
1522: PUSH
1523: LD_INT 87
1525: PUSH
1526: LD_INT 70
1528: PUSH
1529: LD_INT 1
1531: PUSH
1532: LD_INT 11
1534: PUSH
1535: LD_INT 3
1537: PUSH
1538: LD_INT 4
1540: PUSH
1541: LD_INT 5
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: LD_INT 15
1549: PUSH
1550: LD_INT 18
1552: PUSH
1553: LD_INT 7
1555: PUSH
1556: LD_INT 17
1558: PUSH
1559: LD_INT 8
1561: PUSH
1562: LD_INT 20
1564: PUSH
1565: LD_INT 21
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: LD_INT 72
1573: PUSH
1574: LD_INT 26
1576: PUSH
1577: LD_INT 69
1579: PUSH
1580: LD_INT 39
1582: PUSH
1583: LD_INT 40
1585: PUSH
1586: LD_INT 41
1588: PUSH
1589: LD_INT 42
1591: PUSH
1592: LD_INT 43
1594: PUSH
1595: LD_INT 48
1597: PUSH
1598: LD_INT 49
1600: PUSH
1601: LD_INT 50
1603: PUSH
1604: LD_INT 51
1606: PUSH
1607: LD_INT 52
1609: PUSH
1610: LD_INT 53
1612: PUSH
1613: LD_INT 54
1615: PUSH
1616: LD_INT 55
1618: PUSH
1619: LD_INT 56
1621: PUSH
1622: LD_INT 60
1624: PUSH
1625: LD_INT 61
1627: PUSH
1628: LD_INT 62
1630: PUSH
1631: LD_INT 66
1633: PUSH
1634: LD_INT 67
1636: PUSH
1637: LD_INT 68
1639: PUSH
1640: LD_INT 81
1642: PUSH
1643: LD_INT 82
1645: PUSH
1646: LD_INT 83
1648: PUSH
1649: LD_INT 84
1651: PUSH
1652: LD_INT 85
1654: PUSH
1655: LD_INT 87
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: LIST
1711: LIST
1712: ST_TO_ADDR
1713: GO 1946
1715: LD_INT 3
1717: DOUBLE
1718: EQUAL
1719: IFTRUE 1723
1721: GO 1945
1723: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_INT 46
1731: PUSH
1732: LD_INT 47
1734: PUSH
1735: LD_INT 1
1737: PUSH
1738: LD_INT 2
1740: PUSH
1741: LD_INT 82
1743: PUSH
1744: LD_INT 83
1746: PUSH
1747: LD_INT 84
1749: PUSH
1750: LD_INT 85
1752: PUSH
1753: LD_INT 86
1755: PUSH
1756: LD_INT 11
1758: PUSH
1759: LD_INT 9
1761: PUSH
1762: LD_INT 20
1764: PUSH
1765: LD_INT 19
1767: PUSH
1768: LD_INT 21
1770: PUSH
1771: LD_INT 24
1773: PUSH
1774: LD_INT 22
1776: PUSH
1777: LD_INT 25
1779: PUSH
1780: LD_INT 28
1782: PUSH
1783: LD_INT 29
1785: PUSH
1786: LD_INT 30
1788: PUSH
1789: LD_INT 31
1791: PUSH
1792: LD_INT 37
1794: PUSH
1795: LD_INT 38
1797: PUSH
1798: LD_INT 32
1800: PUSH
1801: LD_INT 27
1803: PUSH
1804: LD_INT 33
1806: PUSH
1807: LD_INT 69
1809: PUSH
1810: LD_INT 39
1812: PUSH
1813: LD_INT 34
1815: PUSH
1816: LD_INT 40
1818: PUSH
1819: LD_INT 71
1821: PUSH
1822: LD_INT 23
1824: PUSH
1825: LD_INT 44
1827: PUSH
1828: LD_INT 48
1830: PUSH
1831: LD_INT 49
1833: PUSH
1834: LD_INT 50
1836: PUSH
1837: LD_INT 51
1839: PUSH
1840: LD_INT 52
1842: PUSH
1843: LD_INT 53
1845: PUSH
1846: LD_INT 54
1848: PUSH
1849: LD_INT 55
1851: PUSH
1852: LD_INT 56
1854: PUSH
1855: LD_INT 57
1857: PUSH
1858: LD_INT 58
1860: PUSH
1861: LD_INT 59
1863: PUSH
1864: LD_INT 63
1866: PUSH
1867: LD_INT 64
1869: PUSH
1870: LD_INT 65
1872: PUSH
1873: LD_INT 82
1875: PUSH
1876: LD_INT 83
1878: PUSH
1879: LD_INT 84
1881: PUSH
1882: LD_INT 85
1884: PUSH
1885: LD_INT 86
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: ST_TO_ADDR
1943: GO 1946
1945: POP
// if state > - 1 and state < 3 then
1946: LD_VAR 0 3
1950: PUSH
1951: LD_INT 1
1953: NEG
1954: GREATER
1955: PUSH
1956: LD_VAR 0 3
1960: PUSH
1961: LD_INT 3
1963: LESS
1964: AND
1965: IFFALSE 2022
// for i in result do
1967: LD_ADDR_VAR 0 5
1971: PUSH
1972: LD_VAR 0 4
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2020
// if GetTech ( i , side ) <> state then
1980: LD_VAR 0 5
1984: PPUSH
1985: LD_VAR 0 1
1989: PPUSH
1990: CALL_OW 321
1994: PUSH
1995: LD_VAR 0 3
1999: NONEQUAL
2000: IFFALSE 2018
// result := result diff i ;
2002: LD_ADDR_VAR 0 4
2006: PUSH
2007: LD_VAR 0 4
2011: PUSH
2012: LD_VAR 0 5
2016: DIFF
2017: ST_TO_ADDR
2018: GO 1977
2020: POP
2021: POP
// end ;
2022: LD_VAR 0 4
2026: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
2027: LD_INT 0
2029: PPUSH
2030: PPUSH
2031: PPUSH
2032: PPUSH
// if not list then
2033: LD_VAR 0 3
2037: NOT
2038: IFFALSE 2042
// exit ;
2040: GO 2350
// result := [ ] ;
2042: LD_ADDR_VAR 0 5
2046: PUSH
2047: EMPTY
2048: ST_TO_ADDR
// for i in list do
2049: LD_ADDR_VAR 0 6
2053: PUSH
2054: LD_VAR 0 3
2058: PUSH
2059: FOR_IN
2060: IFFALSE 2262
// begin tmp := GetDistUnitXY ( i , x , y ) ;
2062: LD_ADDR_VAR 0 8
2066: PUSH
2067: LD_VAR 0 6
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: LD_VAR 0 2
2081: PPUSH
2082: CALL_OW 297
2086: ST_TO_ADDR
// if not result then
2087: LD_VAR 0 5
2091: NOT
2092: IFFALSE 2118
// result := [ [ i , tmp ] ] else
2094: LD_ADDR_VAR 0 5
2098: PUSH
2099: LD_VAR 0 6
2103: PUSH
2104: LD_VAR 0 8
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: EMPTY
2114: LIST
2115: ST_TO_ADDR
2116: GO 2260
// begin if result [ result ] [ 2 ] < tmp then
2118: LD_VAR 0 5
2122: PUSH
2123: LD_VAR 0 5
2127: ARRAY
2128: PUSH
2129: LD_INT 2
2131: ARRAY
2132: PUSH
2133: LD_VAR 0 8
2137: LESS
2138: IFFALSE 2180
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
2140: LD_ADDR_VAR 0 5
2144: PUSH
2145: LD_VAR 0 5
2149: PPUSH
2150: LD_VAR 0 5
2154: PUSH
2155: LD_INT 1
2157: PLUS
2158: PPUSH
2159: LD_VAR 0 6
2163: PUSH
2164: LD_VAR 0 8
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PPUSH
2173: CALL_OW 2
2177: ST_TO_ADDR
2178: GO 2260
// for j = 1 to result do
2180: LD_ADDR_VAR 0 7
2184: PUSH
2185: DOUBLE
2186: LD_INT 1
2188: DEC
2189: ST_TO_ADDR
2190: LD_VAR 0 5
2194: PUSH
2195: FOR_TO
2196: IFFALSE 2258
// begin if tmp < result [ j ] [ 2 ] then
2198: LD_VAR 0 8
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_VAR 0 7
2212: ARRAY
2213: PUSH
2214: LD_INT 2
2216: ARRAY
2217: LESS
2218: IFFALSE 2256
// begin result := Insert ( result , j , [ i , tmp ] ) ;
2220: LD_ADDR_VAR 0 5
2224: PUSH
2225: LD_VAR 0 5
2229: PPUSH
2230: LD_VAR 0 7
2234: PPUSH
2235: LD_VAR 0 6
2239: PUSH
2240: LD_VAR 0 8
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PPUSH
2249: CALL_OW 2
2253: ST_TO_ADDR
// break ;
2254: GO 2258
// end ; end ;
2256: GO 2195
2258: POP
2259: POP
// end ; end ;
2260: GO 2059
2262: POP
2263: POP
// if result and not asc then
2264: LD_VAR 0 5
2268: PUSH
2269: LD_VAR 0 4
2273: NOT
2274: AND
2275: IFFALSE 2350
// begin tmp := result ;
2277: LD_ADDR_VAR 0 8
2281: PUSH
2282: LD_VAR 0 5
2286: ST_TO_ADDR
// for i = tmp downto 1 do
2287: LD_ADDR_VAR 0 6
2291: PUSH
2292: DOUBLE
2293: LD_VAR 0 8
2297: INC
2298: ST_TO_ADDR
2299: LD_INT 1
2301: PUSH
2302: FOR_DOWNTO
2303: IFFALSE 2348
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PPUSH
2315: LD_VAR 0 8
2319: PUSH
2320: LD_VAR 0 6
2324: MINUS
2325: PUSH
2326: LD_INT 1
2328: PLUS
2329: PPUSH
2330: LD_VAR 0 8
2334: PUSH
2335: LD_VAR 0 6
2339: ARRAY
2340: PPUSH
2341: CALL_OW 1
2345: ST_TO_ADDR
2346: GO 2302
2348: POP
2349: POP
// end ; end ;
2350: LD_VAR 0 5
2354: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
2355: LD_INT 0
2357: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
2358: LD_ADDR_VAR 0 4
2362: PUSH
2363: LD_VAR 0 1
2367: PPUSH
2368: CALL_OW 250
2372: PPUSH
2373: LD_VAR 0 1
2377: PPUSH
2378: CALL_OW 251
2382: PPUSH
2383: LD_VAR 0 2
2387: PPUSH
2388: LD_VAR 0 3
2392: PPUSH
2393: CALL 2027 0 4
2397: ST_TO_ADDR
// end ;
2398: LD_VAR 0 4
2402: RET
// export function NearestEmptyBuilding ( unit , btype ) ; var side , tmp , i , places ; begin
2403: LD_INT 0
2405: PPUSH
2406: PPUSH
2407: PPUSH
2408: PPUSH
2409: PPUSH
// if not unit then
2410: LD_VAR 0 1
2414: NOT
2415: IFFALSE 2419
// exit ;
2417: GO 2621
// side := GetSide ( unit ) ;
2419: LD_ADDR_VAR 0 4
2423: PUSH
2424: LD_VAR 0 1
2428: PPUSH
2429: CALL_OW 255
2433: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
2434: LD_ADDR_VAR 0 5
2438: PUSH
2439: LD_INT 22
2441: PUSH
2442: LD_VAR 0 4
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: PUSH
2451: LD_INT 30
2453: PUSH
2454: LD_VAR 0 2
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PPUSH
2467: CALL_OW 69
2471: ST_TO_ADDR
// if not tmp then
2472: LD_VAR 0 5
2476: NOT
2477: IFFALSE 2481
// exit ;
2479: GO 2621
// tmp := SortByDistanceUnit ( unit , tmp , true ) ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 1
2490: PPUSH
2491: LD_VAR 0 5
2495: PPUSH
2496: LD_INT 1
2498: PPUSH
2499: CALL 2355 0 3
2503: ST_TO_ADDR
// places := 1 ;
2504: LD_ADDR_VAR 0 7
2508: PUSH
2509: LD_INT 1
2511: ST_TO_ADDR
// if btype in [ b_depot , b_warehouse , b_armoury , b_barracks , b_workshop , b_factory , b_lab , b_lab_half , b_lab_full ] then
2512: LD_VAR 0 2
2516: PUSH
2517: LD_INT 0
2519: PUSH
2520: LD_INT 1
2522: PUSH
2523: LD_INT 4
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: LD_INT 2
2531: PUSH
2532: LD_INT 3
2534: PUSH
2535: LD_INT 6
2537: PUSH
2538: LD_INT 7
2540: PUSH
2541: LD_INT 8
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: LIST
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: IN
2555: IFFALSE 2565
// places := 6 ;
2557: LD_ADDR_VAR 0 7
2561: PUSH
2562: LD_INT 6
2564: ST_TO_ADDR
// for i in tmp do
2565: LD_ADDR_VAR 0 6
2569: PUSH
2570: LD_VAR 0 5
2574: PUSH
2575: FOR_IN
2576: IFFALSE 2619
// begin if UnitsInside ( i ) - places <= 0 then
2578: LD_VAR 0 6
2582: PPUSH
2583: CALL_OW 313
2587: PUSH
2588: LD_VAR 0 7
2592: MINUS
2593: PUSH
2594: LD_INT 0
2596: LESSEQUAL
2597: IFFALSE 2603
// continue else
2599: GO 2575
2601: GO 2617
// begin result := i ;
2603: LD_ADDR_VAR 0 3
2607: PUSH
2608: LD_VAR 0 6
2612: ST_TO_ADDR
// exit ;
2613: POP
2614: POP
2615: GO 2621
// end ; end ;
2617: GO 2575
2619: POP
2620: POP
// end ; end_of_file
2621: LD_VAR 0 3
2625: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Shariff , Kurt , Aviradze , heikeSecondSquad , heikeVehicles , heikeApes ; export function PrepareArabian ; var i ; begin
2626: LD_INT 0
2628: PPUSH
2629: PPUSH
// uc_side := 2 ;
2630: LD_ADDR_OWVAR 20
2634: PUSH
2635: LD_INT 2
2637: ST_TO_ADDR
// uc_nation := 2 ;
2638: LD_ADDR_OWVAR 21
2642: PUSH
2643: LD_INT 2
2645: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2646: LD_ADDR_EXP 18
2650: PUSH
2651: LD_STRING Heike
2653: PPUSH
2654: LD_EXP 1
2658: NOT
2659: PPUSH
2660: LD_EXP 2
2664: PPUSH
2665: CALL 336 0 3
2669: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
2670: LD_ADDR_EXP 21
2674: PUSH
2675: LD_STRING Ibrahim
2677: PPUSH
2678: LD_EXP 1
2682: NOT
2683: PPUSH
2684: LD_EXP 2
2688: PPUSH
2689: CALL 336 0 3
2693: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2694: LD_ADDR_EXP 19
2698: PUSH
2699: LD_STRING Givi
2701: PPUSH
2702: LD_EXP 1
2706: NOT
2707: PPUSH
2708: LD_EXP 2
2712: PPUSH
2713: CALL 336 0 3
2717: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2718: LD_ADDR_EXP 22
2722: PUSH
2723: LD_STRING Kamil
2725: PPUSH
2726: LD_EXP 1
2730: NOT
2731: PPUSH
2732: LD_EXP 2
2736: PPUSH
2737: CALL 336 0 3
2741: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2742: LD_ADDR_EXP 23
2746: PUSH
2747: LD_STRING Kaia
2749: PPUSH
2750: LD_EXP 1
2754: NOT
2755: PPUSH
2756: LD_EXP 2
2760: PPUSH
2761: CALL 336 0 3
2765: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2766: LD_ADDR_EXP 24
2770: PUSH
2771: LD_STRING Sophia
2773: PPUSH
2774: LD_EXP 1
2778: NOT
2779: PPUSH
2780: LD_EXP 2
2784: PPUSH
2785: CALL 336 0 3
2789: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2790: LD_ADDR_EXP 25
2794: PUSH
2795: LD_STRING Markov
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_EXP 2
2808: PPUSH
2809: CALL 336 0 3
2813: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2814: LD_ADDR_EXP 28
2818: PUSH
2819: LD_STRING Aviradze
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_EXP 2
2832: PPUSH
2833: CALL 336 0 3
2837: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , ( not debug ) , prefix ) ;
2838: LD_ADDR_EXP 27
2842: PUSH
2843: LD_STRING Kurt
2845: PPUSH
2846: LD_EXP 1
2850: NOT
2851: PPUSH
2852: LD_EXP 2
2856: PPUSH
2857: CALL 336 0 3
2861: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2862: LD_ADDR_EXP 20
2866: PUSH
2867: LD_STRING Mike
2869: PPUSH
2870: LD_EXP 1
2874: NOT
2875: PPUSH
2876: LD_EXP 2
2880: PPUSH
2881: CALL 336 0 3
2885: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_1_others ) ;
2886: LD_ADDR_EXP 29
2890: PUSH
2891: LD_STRING 04_1_others
2893: PPUSH
2894: CALL_OW 31
2898: ST_TO_ADDR
// heikeApes := CreateCharacterSet ( 04_1_apes ) ;
2899: LD_ADDR_EXP 31
2903: PUSH
2904: LD_STRING 04_1_apes
2906: PPUSH
2907: CALL_OW 31
2911: ST_TO_ADDR
// heikeVehicles := LoadVariable ( 04_1_Vehicles , [ ] ) ;
2912: LD_ADDR_EXP 30
2916: PUSH
2917: LD_STRING 04_1_Vehicles
2919: PPUSH
2920: EMPTY
2921: PPUSH
2922: CALL_OW 30
2926: ST_TO_ADDR
// uc_side := 5 ;
2927: LD_ADDR_OWVAR 20
2931: PUSH
2932: LD_INT 5
2934: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
2935: LD_ADDR_EXP 26
2939: PUSH
2940: LD_STRING Abdul
2942: PPUSH
2943: LD_INT 0
2945: PPUSH
2946: LD_STRING 
2948: PPUSH
2949: CALL 336 0 3
2953: ST_TO_ADDR
// end ;
2954: LD_VAR 0 1
2958: RET
// export cargoDriver ; every 2 2$00 trigger LoadVariable ( 04_1_KaganCaptured , 0 ) and not FilterAllUnits ( [ f_side , 5 ] ) and ( HexInfo ( 124 , 26 ) = 0 xor GetSide ( HexInfo ( 124 , 26 ) ) = 2 ) do var veh ;
2959: LD_STRING 04_1_KaganCaptured
2961: PPUSH
2962: LD_INT 0
2964: PPUSH
2965: CALL_OW 30
2969: PUSH
2970: LD_INT 22
2972: PUSH
2973: LD_INT 5
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: PPUSH
2980: CALL_OW 69
2984: NOT
2985: AND
2986: PUSH
2987: LD_INT 124
2989: PPUSH
2990: LD_INT 26
2992: PPUSH
2993: CALL_OW 428
2997: PUSH
2998: LD_INT 0
3000: EQUAL
3001: PUSH
3002: LD_INT 124
3004: PPUSH
3005: LD_INT 26
3007: PPUSH
3008: CALL_OW 428
3012: PPUSH
3013: CALL_OW 255
3017: PUSH
3018: LD_INT 2
3020: EQUAL
3021: XOR
3022: AND
3023: IFFALSE 3271
3025: GO 3027
3027: DISABLE
3028: LD_INT 0
3030: PPUSH
// begin enable ;
3031: ENABLE
// uc_side := 5 ;
3032: LD_ADDR_OWVAR 20
3036: PUSH
3037: LD_INT 5
3039: ST_TO_ADDR
// uc_nation := 2 ;
3040: LD_ADDR_OWVAR 21
3044: PUSH
3045: LD_INT 2
3047: ST_TO_ADDR
// PrepareTank ( 5 , 2 , ar_medium_trike , engine_solar , control_manual , ar_cargo_bay , 70 ) ;
3048: LD_INT 5
3050: PPUSH
3051: LD_INT 2
3053: PPUSH
3054: LD_INT 13
3056: PPUSH
3057: LD_INT 2
3059: PPUSH
3060: LD_INT 1
3062: PPUSH
3063: LD_INT 32
3065: PPUSH
3066: LD_INT 70
3068: PPUSH
3069: CALL 399 0 7
// veh := CreateVehicle ;
3073: LD_ADDR_VAR 0 1
3077: PUSH
3078: CALL_OW 45
3082: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3083: LD_VAR 0 1
3087: PPUSH
3088: LD_INT 3
3090: PPUSH
3091: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
3095: LD_VAR 0 1
3099: PPUSH
3100: LD_INT 8
3102: PPUSH
3103: LD_INT 0
3105: PPUSH
3106: CALL_OW 49
// if not cargoDriver then
3110: LD_EXP 32
3114: NOT
3115: IFFALSE 3140
// begin PrepareHuman ( false , 1 , 3 ) ;
3117: LD_INT 0
3119: PPUSH
3120: LD_INT 1
3122: PPUSH
3123: LD_INT 3
3125: PPUSH
3126: CALL_OW 380
// cargoDriver := CreateHuman ;
3130: LD_ADDR_EXP 32
3134: PUSH
3135: CALL_OW 44
3139: ST_TO_ADDR
// end ; PlaceHumanInUnit ( cargoDriver , veh ) ;
3140: LD_EXP 32
3144: PPUSH
3145: LD_VAR 0 1
3149: PPUSH
3150: CALL_OW 52
// SetCargo ( veh , mat_oil , 100 ) ;
3154: LD_VAR 0 1
3158: PPUSH
3159: LD_INT 2
3161: PPUSH
3162: LD_INT 100
3164: PPUSH
3165: CALL_OW 290
// ComMoveXY ( veh , 142 , 15 ) ;
3169: LD_VAR 0 1
3173: PPUSH
3174: LD_INT 142
3176: PPUSH
3177: LD_INT 15
3179: PPUSH
3180: CALL_OW 111
// AddComUnload ( veh ) ;
3184: LD_VAR 0 1
3188: PPUSH
3189: CALL_OW 219
// AddComMoveXY ( veh , 133 , 2 ) ;
3193: LD_VAR 0 1
3197: PPUSH
3198: LD_INT 133
3200: PPUSH
3201: LD_INT 2
3203: PPUSH
3204: CALL_OW 171
// wait ( 0 0$5 ) ;
3208: LD_INT 175
3210: PPUSH
3211: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
3215: LD_INT 35
3217: PPUSH
3218: CALL_OW 67
// until IsAt ( veh , 133 , 2 ) or IsInArea ( veh , spawnArea ) ;
3222: LD_VAR 0 1
3226: PPUSH
3227: LD_INT 133
3229: PPUSH
3230: LD_INT 2
3232: PPUSH
3233: CALL_OW 307
3237: PUSH
3238: LD_VAR 0 1
3242: PPUSH
3243: LD_INT 8
3245: PPUSH
3246: CALL_OW 308
3250: OR
3251: IFFALSE 3215
// RemoveUnit ( cargoDriver ) ;
3253: LD_EXP 32
3257: PPUSH
3258: CALL_OW 64
// RemoveUnit ( veh ) ;
3262: LD_VAR 0 1
3266: PPUSH
3267: CALL_OW 64
// end ; end_of_file
3271: PPOPN 1
3273: END
// export Burlak , Gaidar , Kuzmov ; export ruForce , ruEng , ruMech , ruSci , ruMobile ; export ruSol ; export function PrepareRussian ; var base , blist , i , b , un , tmp , fac , oil ; begin
3274: LD_INT 0
3276: PPUSH
3277: PPUSH
3278: PPUSH
3279: PPUSH
3280: PPUSH
3281: PPUSH
3282: PPUSH
3283: PPUSH
3284: PPUSH
// uc_side := 3 ;
3285: LD_ADDR_OWVAR 20
3289: PUSH
3290: LD_INT 3
3292: ST_TO_ADDR
// uc_nation := 3 ;
3293: LD_ADDR_OWVAR 21
3297: PUSH
3298: LD_INT 3
3300: ST_TO_ADDR
// ruForce := [ ] ;
3301: LD_ADDR_EXP 36
3305: PUSH
3306: EMPTY
3307: ST_TO_ADDR
// ruMech := [ ] ;
3308: LD_ADDR_EXP 38
3312: PUSH
3313: EMPTY
3314: ST_TO_ADDR
// ruEng := [ ] ;
3315: LD_ADDR_EXP 37
3319: PUSH
3320: EMPTY
3321: ST_TO_ADDR
// ruSci := [ ] ;
3322: LD_ADDR_EXP 39
3326: PUSH
3327: EMPTY
3328: ST_TO_ADDR
// ruMobile := [ ] ;
3329: LD_ADDR_EXP 40
3333: PUSH
3334: EMPTY
3335: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ,  ) ;
3336: LD_ADDR_EXP 33
3340: PUSH
3341: LD_STRING Burlak
3343: PPUSH
3344: LD_INT 0
3346: PPUSH
3347: LD_STRING 
3349: PPUSH
3350: CALL 336 0 3
3354: ST_TO_ADDR
// Gaidar := PrepareUnit ( Gaydar , false ,  ) ;
3355: LD_ADDR_EXP 34
3359: PUSH
3360: LD_STRING Gaydar
3362: PPUSH
3363: LD_INT 0
3365: PPUSH
3366: LD_STRING 
3368: PPUSH
3369: CALL 336 0 3
3373: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , false ,  ) ;
3374: LD_ADDR_EXP 35
3378: PUSH
3379: LD_STRING Kuzmov
3381: PPUSH
3382: LD_INT 0
3384: PPUSH
3385: LD_STRING 
3387: PPUSH
3388: CALL 336 0 3
3392: ST_TO_ADDR
// PlaceHumanInUnit ( Kuzmov , ruMainBase ) ;
3393: LD_EXP 35
3397: PPUSH
3398: LD_INT 200
3400: PPUSH
3401: CALL_OW 52
// SetBName ( ruMainBase , chuikov ) ;
3405: LD_INT 200
3407: PPUSH
3408: LD_STRING chuikov
3410: PPUSH
3411: CALL_OW 500
// SetResourceType ( GetBase ( ruMainBase ) , mat_cans , [ 800 , 1000 , 1250 ] [ Difficulty ] ) ;
3415: LD_INT 200
3417: PPUSH
3418: CALL_OW 274
3422: PPUSH
3423: LD_INT 1
3425: PPUSH
3426: LD_INT 800
3428: PUSH
3429: LD_INT 1000
3431: PUSH
3432: LD_INT 1250
3434: PUSH
3435: EMPTY
3436: LIST
3437: LIST
3438: LIST
3439: PUSH
3440: LD_OWVAR 67
3444: ARRAY
3445: PPUSH
3446: CALL_OW 277
// SetResourceType ( GetBase ( ruMainBase ) , mat_oil , 160 ) ;
3450: LD_INT 200
3452: PPUSH
3453: CALL_OW 274
3457: PPUSH
3458: LD_INT 2
3460: PPUSH
3461: LD_INT 160
3463: PPUSH
3464: CALL_OW 277
// SetResourceType ( GetBase ( ruSecBase ) , mat_cans , 200 ) ;
3468: LD_INT 225
3470: PPUSH
3471: CALL_OW 274
3475: PPUSH
3476: LD_INT 1
3478: PPUSH
3479: LD_INT 200
3481: PPUSH
3482: CALL_OW 277
// oil := 150 ;
3486: LD_ADDR_VAR 0 9
3490: PUSH
3491: LD_INT 150
3493: ST_TO_ADDR
// if gameTime >= [ 45 45$00 , 40 40$00 , 35 35$00 ] [ Difficulty ] then
3494: LD_EXP 5
3498: PUSH
3499: LD_INT 94500
3501: PUSH
3502: LD_INT 84000
3504: PUSH
3505: LD_INT 73500
3507: PUSH
3508: EMPTY
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_OWVAR 67
3517: ARRAY
3518: GREATEREQUAL
3519: IFFALSE 3674
// begin oil := 450 ;
3521: LD_ADDR_VAR 0 9
3525: PUSH
3526: LD_INT 450
3528: ST_TO_ADDR
// tmp := [ [ 123 , 17 , 3 , b_breastwork ] , [ 152 , 38 , 3 , b_breastwork ] , [ 81 , 6 , 4 , b_breastwork ] , [ 113 , 67 , 4 , b_bunker ] ] ;
3529: LD_ADDR_VAR 0 7
3533: PUSH
3534: LD_INT 123
3536: PUSH
3537: LD_INT 17
3539: PUSH
3540: LD_INT 3
3542: PUSH
3543: LD_INT 31
3545: PUSH
3546: EMPTY
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: PUSH
3552: LD_INT 152
3554: PUSH
3555: LD_INT 38
3557: PUSH
3558: LD_INT 3
3560: PUSH
3561: LD_INT 31
3563: PUSH
3564: EMPTY
3565: LIST
3566: LIST
3567: LIST
3568: LIST
3569: PUSH
3570: LD_INT 81
3572: PUSH
3573: LD_INT 6
3575: PUSH
3576: LD_INT 4
3578: PUSH
3579: LD_INT 31
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: PUSH
3588: LD_INT 113
3590: PUSH
3591: LD_INT 67
3593: PUSH
3594: LD_INT 4
3596: PUSH
3597: LD_INT 32
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: ST_TO_ADDR
// for i in tmp do
3612: LD_ADDR_VAR 0 4
3616: PUSH
3617: LD_VAR 0 7
3621: PUSH
3622: FOR_IN
3623: IFFALSE 3672
// begin bc_type := i [ 4 ] ;
3625: LD_ADDR_OWVAR 42
3629: PUSH
3630: LD_VAR 0 4
3634: PUSH
3635: LD_INT 4
3637: ARRAY
3638: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3639: LD_VAR 0 4
3643: PUSH
3644: LD_INT 1
3646: ARRAY
3647: PPUSH
3648: LD_VAR 0 4
3652: PUSH
3653: LD_INT 2
3655: ARRAY
3656: PPUSH
3657: LD_VAR 0 4
3661: PUSH
3662: LD_INT 3
3664: ARRAY
3665: PPUSH
3666: CALL_OW 47
// end ;
3670: GO 3622
3672: POP
3673: POP
// end ; SetResourceType ( GetBase ( ruSecBase ) , mat_oil , oil ) ;
3674: LD_INT 225
3676: PPUSH
3677: CALL_OW 274
3681: PPUSH
3682: LD_INT 2
3684: PPUSH
3685: LD_VAR 0 9
3689: PPUSH
3690: CALL_OW 277
// if Difficulty > 1 then
3694: LD_OWVAR 67
3698: PUSH
3699: LD_INT 1
3701: GREATER
3702: IFFALSE 3797
// begin bc_type := b_bunker ;
3704: LD_ADDR_OWVAR 42
3708: PUSH
3709: LD_INT 32
3711: ST_TO_ADDR
// tmp := [ [ 121 , 85 , 5 ] , [ 93 , 72 , 1 ] ] ;
3712: LD_ADDR_VAR 0 7
3716: PUSH
3717: LD_INT 121
3719: PUSH
3720: LD_INT 85
3722: PUSH
3723: LD_INT 5
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: LIST
3730: PUSH
3731: LD_INT 93
3733: PUSH
3734: LD_INT 72
3736: PUSH
3737: LD_INT 1
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: LIST
3744: PUSH
3745: EMPTY
3746: LIST
3747: LIST
3748: ST_TO_ADDR
// for i in tmp do
3749: LD_ADDR_VAR 0 4
3753: PUSH
3754: LD_VAR 0 7
3758: PUSH
3759: FOR_IN
3760: IFFALSE 3795
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3762: LD_VAR 0 4
3766: PUSH
3767: LD_INT 1
3769: ARRAY
3770: PPUSH
3771: LD_VAR 0 4
3775: PUSH
3776: LD_INT 2
3778: ARRAY
3779: PPUSH
3780: LD_VAR 0 4
3784: PUSH
3785: LD_INT 3
3787: ARRAY
3788: PPUSH
3789: CALL_OW 47
3793: GO 3759
3795: POP
3796: POP
// end ; base := GetBase ( ruMainBase ) ;
3797: LD_ADDR_VAR 0 2
3801: PUSH
3802: LD_INT 200
3804: PPUSH
3805: CALL_OW 274
3809: ST_TO_ADDR
// blist := GetBuildList ( base ) ;
3810: LD_ADDR_VAR 0 3
3814: PUSH
3815: LD_VAR 0 2
3819: PPUSH
3820: CALL_OW 417
3824: ST_TO_ADDR
// for b in blist do
3825: LD_ADDR_VAR 0 5
3829: PUSH
3830: LD_VAR 0 3
3834: PUSH
3835: FOR_IN
3836: IFFALSE 4287
// begin if b [ 1 ] = b_factory then
3838: LD_VAR 0 5
3842: PUSH
3843: LD_INT 1
3845: ARRAY
3846: PUSH
3847: LD_INT 3
3849: EQUAL
3850: IFFALSE 4001
// begin fac := HexInfo ( b [ 2 ] , b [ 3 ] ) ;
3852: LD_ADDR_VAR 0 8
3856: PUSH
3857: LD_VAR 0 5
3861: PUSH
3862: LD_INT 2
3864: ARRAY
3865: PPUSH
3866: LD_VAR 0 5
3870: PUSH
3871: LD_INT 3
3873: ARRAY
3874: PPUSH
3875: CALL_OW 428
3879: ST_TO_ADDR
// for i := 1 to [ 2 , 2 + Difficulty ] [ ( ruEscapeCounter > 3 ) + 1 ] do
3880: LD_ADDR_VAR 0 4
3884: PUSH
3885: DOUBLE
3886: LD_INT 1
3888: DEC
3889: ST_TO_ADDR
3890: LD_INT 2
3892: PUSH
3893: LD_INT 2
3895: PUSH
3896: LD_OWVAR 67
3900: PLUS
3901: PUSH
3902: EMPTY
3903: LIST
3904: LIST
3905: PUSH
3906: LD_EXP 10
3910: PUSH
3911: LD_INT 3
3913: GREATER
3914: PUSH
3915: LD_INT 1
3917: PLUS
3918: ARRAY
3919: PUSH
3920: FOR_TO
3921: IFFALSE 3997
// begin PrepareHuman ( false , 3 , 1 + Difficulty ) ;
3923: LD_INT 0
3925: PPUSH
3926: LD_INT 3
3928: PPUSH
3929: LD_INT 1
3931: PUSH
3932: LD_OWVAR 67
3936: PLUS
3937: PPUSH
3938: CALL_OW 380
// un := CreateHuman ;
3942: LD_ADDR_VAR 0 6
3946: PUSH
3947: CALL_OW 44
3951: ST_TO_ADDR
// ruMech := Replace ( ruMech , ruMech + 1 , un ) ;
3952: LD_ADDR_EXP 38
3956: PUSH
3957: LD_EXP 38
3961: PPUSH
3962: LD_EXP 38
3966: PUSH
3967: LD_INT 1
3969: PLUS
3970: PPUSH
3971: LD_VAR 0 6
3975: PPUSH
3976: CALL_OW 1
3980: ST_TO_ADDR
// PlaceHumanInUnit ( un , fac ) ;
3981: LD_VAR 0 6
3985: PPUSH
3986: LD_VAR 0 8
3990: PPUSH
3991: CALL_OW 52
// end ;
3995: GO 3920
3997: POP
3998: POP
// end else
3999: GO 4285
// if b [ 1 ] in [ b_lab , b_lab_half , b_lab_full , b_lab_weapon ] then
4001: LD_VAR 0 5
4005: PUSH
4006: LD_INT 1
4008: ARRAY
4009: PUSH
4010: LD_INT 6
4012: PUSH
4013: LD_INT 7
4015: PUSH
4016: LD_INT 8
4018: PUSH
4019: LD_INT 10
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: LIST
4027: IN
4028: IFFALSE 4138
// begin for i := 1 to 2 do
4030: LD_ADDR_VAR 0 4
4034: PUSH
4035: DOUBLE
4036: LD_INT 1
4038: DEC
4039: ST_TO_ADDR
4040: LD_INT 2
4042: PUSH
4043: FOR_TO
4044: IFFALSE 4134
// begin PrepareHuman ( false , 4 , Difficulty ) ;
4046: LD_INT 0
4048: PPUSH
4049: LD_INT 4
4051: PPUSH
4052: LD_OWVAR 67
4056: PPUSH
4057: CALL_OW 380
// un := CreateHuman ;
4061: LD_ADDR_VAR 0 6
4065: PUSH
4066: CALL_OW 44
4070: ST_TO_ADDR
// ruSci := Replace ( ruSci , ruSci + 1 , un ) ;
4071: LD_ADDR_EXP 39
4075: PUSH
4076: LD_EXP 39
4080: PPUSH
4081: LD_EXP 39
4085: PUSH
4086: LD_INT 1
4088: PLUS
4089: PPUSH
4090: LD_VAR 0 6
4094: PPUSH
4095: CALL_OW 1
4099: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4100: LD_VAR 0 6
4104: PPUSH
4105: LD_VAR 0 5
4109: PUSH
4110: LD_INT 2
4112: ARRAY
4113: PPUSH
4114: LD_VAR 0 5
4118: PUSH
4119: LD_INT 3
4121: ARRAY
4122: PPUSH
4123: CALL_OW 428
4127: PPUSH
4128: CALL_OW 52
// end ;
4132: GO 4043
4134: POP
4135: POP
// end else
4136: GO 4285
// if b [ 1 ] = b_warehouse then
4138: LD_VAR 0 5
4142: PUSH
4143: LD_INT 1
4145: ARRAY
4146: PUSH
4147: LD_INT 1
4149: EQUAL
4150: IFFALSE 4285
// begin for i := 1 to [ 1 , 1 + Difficulty ] [ ( ruEscapeCounter > 3 ) + 1 ] do
4152: LD_ADDR_VAR 0 4
4156: PUSH
4157: DOUBLE
4158: LD_INT 1
4160: DEC
4161: ST_TO_ADDR
4162: LD_INT 1
4164: PUSH
4165: LD_INT 1
4167: PUSH
4168: LD_OWVAR 67
4172: PLUS
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PUSH
4178: LD_EXP 10
4182: PUSH
4183: LD_INT 3
4185: GREATER
4186: PUSH
4187: LD_INT 1
4189: PLUS
4190: ARRAY
4191: PUSH
4192: FOR_TO
4193: IFFALSE 4283
// begin PrepareHuman ( false , 2 , Difficulty ) ;
4195: LD_INT 0
4197: PPUSH
4198: LD_INT 2
4200: PPUSH
4201: LD_OWVAR 67
4205: PPUSH
4206: CALL_OW 380
// un := CreateHuman ;
4210: LD_ADDR_VAR 0 6
4214: PUSH
4215: CALL_OW 44
4219: ST_TO_ADDR
// ruEng := Replace ( ruEng , ruEng + 1 , un ) ;
4220: LD_ADDR_EXP 37
4224: PUSH
4225: LD_EXP 37
4229: PPUSH
4230: LD_EXP 37
4234: PUSH
4235: LD_INT 1
4237: PLUS
4238: PPUSH
4239: LD_VAR 0 6
4243: PPUSH
4244: CALL_OW 1
4248: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4249: LD_VAR 0 6
4253: PPUSH
4254: LD_VAR 0 5
4258: PUSH
4259: LD_INT 2
4261: ARRAY
4262: PPUSH
4263: LD_VAR 0 5
4267: PUSH
4268: LD_INT 3
4270: ARRAY
4271: PPUSH
4272: CALL_OW 428
4276: PPUSH
4277: CALL_OW 52
// end ;
4281: GO 4192
4283: POP
4284: POP
// end ; end ;
4285: GO 3835
4287: POP
4288: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4289: LD_ADDR_VAR 0 3
4293: PUSH
4294: LD_INT 22
4296: PUSH
4297: LD_INT 3
4299: PUSH
4300: EMPTY
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 21
4306: PUSH
4307: LD_INT 3
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: EMPTY
4315: LIST
4316: LIST
4317: PPUSH
4318: CALL_OW 69
4322: ST_TO_ADDR
// for b in blist do
4323: LD_ADDR_VAR 0 5
4327: PUSH
4328: LD_VAR 0 3
4332: PUSH
4333: FOR_IN
4334: IFFALSE 4356
// SetBLevel ( b , 3 + Difficulty ) ;
4336: LD_VAR 0 5
4340: PPUSH
4341: LD_INT 3
4343: PUSH
4344: LD_OWVAR 67
4348: PLUS
4349: PPUSH
4350: CALL_OW 241
4354: GO 4333
4356: POP
4357: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4358: LD_ADDR_VAR 0 3
4362: PUSH
4363: LD_INT 22
4365: PUSH
4366: LD_INT 3
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: LD_INT 30
4375: PUSH
4376: LD_INT 32
4378: PUSH
4379: EMPTY
4380: LIST
4381: LIST
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: PPUSH
4387: CALL_OW 69
4391: ST_TO_ADDR
// for b in blist do
4392: LD_ADDR_VAR 0 5
4396: PUSH
4397: LD_VAR 0 3
4401: PUSH
4402: FOR_IN
4403: IFFALSE 4512
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4405: LD_INT 0
4407: PPUSH
4408: LD_INT 1
4410: PPUSH
4411: LD_INT 1
4413: PUSH
4414: LD_OWVAR 67
4418: PLUS
4419: PPUSH
4420: CALL_OW 380
// un := CreateHuman ;
4424: LD_ADDR_VAR 0 6
4428: PUSH
4429: CALL_OW 44
4433: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4434: LD_ADDR_EXP 36
4438: PUSH
4439: LD_EXP 36
4443: PPUSH
4444: LD_EXP 36
4448: PUSH
4449: LD_INT 1
4451: PLUS
4452: PPUSH
4453: LD_VAR 0 6
4457: PPUSH
4458: CALL_OW 1
4462: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4463: LD_VAR 0 6
4467: PPUSH
4468: LD_VAR 0 5
4472: PPUSH
4473: CALL_OW 52
// PlaceWeaponTurret ( b , [ ru_gun , ru_gatling_gun ] [ b mod 2 + 1 ] ) ;
4477: LD_VAR 0 5
4481: PPUSH
4482: LD_INT 44
4484: PUSH
4485: LD_INT 43
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: LD_INT 2
4499: MOD
4500: PUSH
4501: LD_INT 1
4503: PLUS
4504: ARRAY
4505: PPUSH
4506: CALL_OW 431
// end ;
4510: GO 4402
4512: POP
4513: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4514: LD_ADDR_VAR 0 3
4518: PUSH
4519: LD_INT 22
4521: PUSH
4522: LD_INT 3
4524: PUSH
4525: EMPTY
4526: LIST
4527: LIST
4528: PUSH
4529: LD_INT 30
4531: PUSH
4532: LD_INT 31
4534: PUSH
4535: EMPTY
4536: LIST
4537: LIST
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PPUSH
4543: CALL_OW 69
4547: ST_TO_ADDR
// for b in blist do
4548: LD_ADDR_VAR 0 5
4552: PUSH
4553: LD_VAR 0 3
4557: PUSH
4558: FOR_IN
4559: IFFALSE 4658
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4561: LD_INT 0
4563: PPUSH
4564: LD_INT 1
4566: PPUSH
4567: LD_INT 1
4569: PUSH
4570: LD_OWVAR 67
4574: PLUS
4575: PPUSH
4576: CALL_OW 380
// un := CreateHuman ;
4580: LD_ADDR_VAR 0 6
4584: PUSH
4585: CALL_OW 44
4589: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4590: LD_ADDR_EXP 36
4594: PUSH
4595: LD_EXP 36
4599: PPUSH
4600: LD_EXP 36
4604: PUSH
4605: LD_INT 1
4607: PLUS
4608: PPUSH
4609: LD_VAR 0 6
4613: PPUSH
4614: CALL_OW 1
4618: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) + 3 ) ;
4619: LD_VAR 0 6
4623: PPUSH
4624: LD_VAR 0 5
4628: PPUSH
4629: CALL_OW 254
4633: PUSH
4634: LD_INT 3
4636: PLUS
4637: PPUSH
4638: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4642: LD_VAR 0 6
4646: PPUSH
4647: LD_VAR 0 5
4651: PPUSH
4652: CALL_OW 52
// end ;
4656: GO 4558
4658: POP
4659: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4660: LD_ADDR_VAR 0 3
4664: PUSH
4665: LD_INT 22
4667: PUSH
4668: LD_INT 3
4670: PUSH
4671: EMPTY
4672: LIST
4673: LIST
4674: PUSH
4675: LD_INT 2
4677: PUSH
4678: LD_INT 30
4680: PUSH
4681: LD_INT 4
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: PUSH
4688: LD_INT 30
4690: PUSH
4691: LD_INT 5
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: LIST
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: PPUSH
4707: CALL_OW 69
4711: ST_TO_ADDR
// for b in blist do
4712: LD_ADDR_VAR 0 5
4716: PUSH
4717: LD_VAR 0 3
4721: PUSH
4722: FOR_IN
4723: IFFALSE 4819
// begin for i := 1 to 2 do
4725: LD_ADDR_VAR 0 4
4729: PUSH
4730: DOUBLE
4731: LD_INT 1
4733: DEC
4734: ST_TO_ADDR
4735: LD_INT 2
4737: PUSH
4738: FOR_TO
4739: IFFALSE 4815
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4741: LD_INT 0
4743: PPUSH
4744: LD_INT 1
4746: PPUSH
4747: LD_INT 1
4749: PUSH
4750: LD_OWVAR 67
4754: PLUS
4755: PPUSH
4756: CALL_OW 380
// un := CreateHuman ;
4760: LD_ADDR_VAR 0 6
4764: PUSH
4765: CALL_OW 44
4769: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4770: LD_ADDR_EXP 36
4774: PUSH
4775: LD_EXP 36
4779: PPUSH
4780: LD_EXP 36
4784: PUSH
4785: LD_INT 1
4787: PLUS
4788: PPUSH
4789: LD_VAR 0 6
4793: PPUSH
4794: CALL_OW 1
4798: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4799: LD_VAR 0 6
4803: PPUSH
4804: LD_VAR 0 5
4808: PPUSH
4809: CALL_OW 52
// end ;
4813: GO 4738
4815: POP
4816: POP
// end ;
4817: GO 4722
4819: POP
4820: POP
// if ibrahimOnRuSide then
4821: LD_EXP 3
4825: IFFALSE 4923
// begin Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
4827: LD_ADDR_EXP 21
4831: PUSH
4832: LD_STRING IbrahimRu
4834: PPUSH
4835: LD_INT 0
4837: PPUSH
4838: LD_STRING 
4840: PPUSH
4841: CALL 336 0 3
4845: ST_TO_ADDR
// PlaceUnitXY ( Ibrahim , 121 , 78 , false ) ;
4846: LD_EXP 21
4850: PPUSH
4851: LD_INT 121
4853: PPUSH
4854: LD_INT 78
4856: PPUSH
4857: LD_INT 0
4859: PPUSH
4860: CALL_OW 48
// ComHold ( Ibrahim ) ;
4864: LD_EXP 21
4868: PPUSH
4869: CALL_OW 140
// PrepareHuman ( sex_male , 1 , 2 ) ;
4873: LD_INT 1
4875: PPUSH
4876: LD_INT 1
4878: PPUSH
4879: LD_INT 2
4881: PPUSH
4882: CALL_OW 380
// ruSol := CreateHuman ;
4886: LD_ADDR_EXP 41
4890: PUSH
4891: CALL_OW 44
4895: ST_TO_ADDR
// PlaceUnitXY ( ruSol , 121 , 75 , false ) ;
4896: LD_EXP 41
4900: PPUSH
4901: LD_INT 121
4903: PPUSH
4904: LD_INT 75
4906: PPUSH
4907: LD_INT 0
4909: PPUSH
4910: CALL_OW 48
// ComHold ( ruSol ) ;
4914: LD_EXP 41
4918: PPUSH
4919: CALL_OW 140
// end ; for i := 1 to [ 2 , 2 + Difficulty ] [ ( ruEscapeCounter > 3 ) + 1 ] do
4923: LD_ADDR_VAR 0 4
4927: PUSH
4928: DOUBLE
4929: LD_INT 1
4931: DEC
4932: ST_TO_ADDR
4933: LD_INT 2
4935: PUSH
4936: LD_INT 2
4938: PUSH
4939: LD_OWVAR 67
4943: PLUS
4944: PUSH
4945: EMPTY
4946: LIST
4947: LIST
4948: PUSH
4949: LD_EXP 10
4953: PUSH
4954: LD_INT 3
4956: GREATER
4957: PUSH
4958: LD_INT 1
4960: PLUS
4961: ARRAY
4962: PUSH
4963: FOR_TO
4964: IFFALSE 5033
// AddComConstruct ( fac , [ ru_medium_wheeled , ru_heavy_wheeled , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] ) ;
4966: LD_VAR 0 8
4970: PPUSH
4971: LD_INT 21
4973: PUSH
4974: LD_INT 23
4976: PUSH
4977: LD_INT 24
4979: PUSH
4980: EMPTY
4981: LIST
4982: LIST
4983: LIST
4984: PUSH
4985: LD_VAR 0 4
4989: PUSH
4990: LD_INT 3
4992: MOD
4993: PUSH
4994: LD_INT 1
4996: PLUS
4997: ARRAY
4998: PPUSH
4999: LD_INT 1
5001: PPUSH
5002: LD_INT 1
5004: PPUSH
5005: LD_INT 43
5007: PUSH
5008: LD_INT 44
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: PUSH
5015: LD_INT 1
5017: PPUSH
5018: LD_INT 2
5020: PPUSH
5021: CALL_OW 12
5025: ARRAY
5026: PPUSH
5027: CALL_OW 185
5031: GO 4963
5033: POP
5034: POP
// end ;
5035: LD_VAR 0 1
5039: RET
// every 0 0$1 trigger ruMobile and not ruEscapeAllowed do var i , filter , tmp , enemy , x ;
5040: LD_EXP 40
5044: PUSH
5045: LD_EXP 4
5049: NOT
5050: AND
5051: IFFALSE 5538
5053: GO 5055
5055: DISABLE
5056: LD_INT 0
5058: PPUSH
5059: PPUSH
5060: PPUSH
5061: PPUSH
5062: PPUSH
// begin enable ;
5063: ENABLE
// filter := UnitFilter ( ruMobile , [ f_type , unit_vehicle ] ) ;
5064: LD_ADDR_VAR 0 2
5068: PUSH
5069: LD_EXP 40
5073: PPUSH
5074: LD_INT 21
5076: PUSH
5077: LD_INT 2
5079: PUSH
5080: EMPTY
5081: LIST
5082: LIST
5083: PPUSH
5084: CALL_OW 72
5088: ST_TO_ADDR
// enemy := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_or , [ f_inarea , zone1 ] , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) ;
5089: LD_ADDR_VAR 0 4
5093: PUSH
5094: LD_INT 81
5096: PUSH
5097: LD_INT 3
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: LD_INT 2
5106: PUSH
5107: LD_INT 95
5109: PUSH
5110: LD_INT 4
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: LD_INT 95
5119: PUSH
5120: LD_INT 5
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: LD_INT 95
5129: PUSH
5130: LD_INT 6
5132: PUSH
5133: EMPTY
5134: LIST
5135: LIST
5136: PUSH
5137: LD_INT 95
5139: PUSH
5140: LD_INT 7
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: PUSH
5147: EMPTY
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: PUSH
5154: EMPTY
5155: LIST
5156: LIST
5157: PPUSH
5158: CALL_OW 69
5162: ST_TO_ADDR
// for i in filter do
5163: LD_ADDR_VAR 0 1
5167: PUSH
5168: LD_VAR 0 2
5172: PUSH
5173: FOR_IN
5174: IFFALSE 5536
// begin tmp := IsDrivenBy ( i ) ;
5176: LD_ADDR_VAR 0 3
5180: PUSH
5181: LD_VAR 0 1
5185: PPUSH
5186: CALL_OW 311
5190: ST_TO_ADDR
// if not tmp then
5191: LD_VAR 0 3
5195: NOT
5196: IFFALSE 5200
// continue ;
5198: GO 5173
// if GetFuel ( i ) > 90 and GetTag ( i ) = 2 then
5200: LD_VAR 0 1
5204: PPUSH
5205: CALL_OW 261
5209: PUSH
5210: LD_INT 90
5212: GREATER
5213: PUSH
5214: LD_VAR 0 1
5218: PPUSH
5219: CALL_OW 110
5223: PUSH
5224: LD_INT 2
5226: EQUAL
5227: AND
5228: IFFALSE 5244
// SetTag ( i , 0 ) else
5230: LD_VAR 0 1
5234: PPUSH
5235: LD_INT 0
5237: PPUSH
5238: CALL_OW 109
5242: GO 5287
// if GetTag ( i ) = 2 then
5244: LD_VAR 0 1
5248: PPUSH
5249: CALL_OW 110
5253: PUSH
5254: LD_INT 2
5256: EQUAL
5257: IFFALSE 5287
// begin x := rand ( 1 , 2 ) ;
5259: LD_ADDR_VAR 0 5
5263: PUSH
5264: LD_INT 1
5266: PPUSH
5267: LD_INT 2
5269: PPUSH
5270: CALL_OW 12
5274: ST_TO_ADDR
// AddComMoveUnit ( i , ruMainBase ) ;
5275: LD_VAR 0 1
5279: PPUSH
5280: LD_INT 200
5282: PPUSH
5283: CALL_OW 172
// end ; if GetLives ( i ) >= 600 and not GetTag ( i ) then
5287: LD_VAR 0 1
5291: PPUSH
5292: CALL_OW 256
5296: PUSH
5297: LD_INT 600
5299: GREATEREQUAL
5300: PUSH
5301: LD_VAR 0 1
5305: PPUSH
5306: CALL_OW 110
5310: NOT
5311: AND
5312: IFFALSE 5338
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
5314: LD_VAR 0 1
5318: PPUSH
5319: LD_VAR 0 4
5323: PPUSH
5324: LD_VAR 0 1
5328: PPUSH
5329: CALL_OW 74
5333: PPUSH
5334: CALL_OW 115
// if GetLives ( i ) < 600 and not GetTag ( i ) then
5338: LD_VAR 0 1
5342: PPUSH
5343: CALL_OW 256
5347: PUSH
5348: LD_INT 600
5350: LESS
5351: PUSH
5352: LD_VAR 0 1
5356: PPUSH
5357: CALL_OW 110
5361: NOT
5362: AND
5363: IFFALSE 5392
// begin SetTag ( i , 1 ) ;
5365: LD_VAR 0 1
5369: PPUSH
5370: LD_INT 1
5372: PPUSH
5373: CALL_OW 109
// ComMoveXY ( i , 112 , 119 ) ;
5377: LD_VAR 0 1
5381: PPUSH
5382: LD_INT 112
5384: PPUSH
5385: LD_INT 119
5387: PPUSH
5388: CALL_OW 111
// end ; if GetTag ( i ) = 1 and GetDistUnitXY ( i , 112 , 119 ) < 9 and tmp then
5392: LD_VAR 0 1
5396: PPUSH
5397: CALL_OW 110
5401: PUSH
5402: LD_INT 1
5404: EQUAL
5405: PUSH
5406: LD_VAR 0 1
5410: PPUSH
5411: LD_INT 112
5413: PPUSH
5414: LD_INT 119
5416: PPUSH
5417: CALL_OW 297
5421: PUSH
5422: LD_INT 9
5424: LESS
5425: AND
5426: PUSH
5427: LD_VAR 0 3
5431: AND
5432: IFFALSE 5534
// begin ComExitVehicle ( tmp ) ;
5434: LD_VAR 0 3
5438: PPUSH
5439: CALL_OW 121
// AddComRepairVehicle ( tmp , i ) ;
5443: LD_VAR 0 3
5447: PPUSH
5448: LD_VAR 0 1
5452: PPUSH
5453: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
5457: LD_INT 35
5459: PPUSH
5460: CALL_OW 67
// until GetLives ( i ) = 1000 ;
5464: LD_VAR 0 1
5468: PPUSH
5469: CALL_OW 256
5473: PUSH
5474: LD_INT 1000
5476: EQUAL
5477: IFFALSE 5457
// ComEnterUnit ( tmp , i ) ;
5479: LD_VAR 0 3
5483: PPUSH
5484: LD_VAR 0 1
5488: PPUSH
5489: CALL_OW 120
// if GetFuel ( i ) <= 50 then
5493: LD_VAR 0 1
5497: PPUSH
5498: CALL_OW 261
5502: PUSH
5503: LD_INT 50
5505: LESSEQUAL
5506: IFFALSE 5522
// SetTag ( i , 2 ) else
5508: LD_VAR 0 1
5512: PPUSH
5513: LD_INT 2
5515: PPUSH
5516: CALL_OW 109
5520: GO 5534
// SetTag ( i , 0 ) ;
5522: LD_VAR 0 1
5526: PPUSH
5527: LD_INT 0
5529: PPUSH
5530: CALL_OW 109
// end ; end ;
5534: GO 5173
5536: POP
5537: POP
// end ;
5538: PPOPN 5
5540: END
// every 0 0$1 trigger not ruEscapeAllowed and ruEng do var i , filter , tmp , enemy ;
5541: LD_EXP 4
5545: NOT
5546: PUSH
5547: LD_EXP 37
5551: AND
5552: IFFALSE 5813
5554: GO 5556
5556: DISABLE
5557: LD_INT 0
5559: PPUSH
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5564: LD_ADDR_VAR 0 2
5568: PUSH
5569: LD_INT 3
5571: PPUSH
5572: LD_INT 22
5574: PUSH
5575: LD_INT 3
5577: PUSH
5578: EMPTY
5579: LIST
5580: LIST
5581: PUSH
5582: LD_INT 21
5584: PUSH
5585: LD_INT 3
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: PUSH
5592: LD_INT 3
5594: PUSH
5595: LD_INT 24
5597: PUSH
5598: LD_INT 1000
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PUSH
5609: EMPTY
5610: LIST
5611: LIST
5612: LIST
5613: PPUSH
5614: CALL_OW 70
5618: ST_TO_ADDR
// tmp := UnitFilter ( ruEng , [ f_ok ] ) ;
5619: LD_ADDR_VAR 0 3
5623: PUSH
5624: LD_EXP 37
5628: PPUSH
5629: LD_INT 50
5631: PUSH
5632: EMPTY
5633: LIST
5634: PPUSH
5635: CALL_OW 72
5639: ST_TO_ADDR
// if filter and tmp then
5640: LD_VAR 0 2
5644: PUSH
5645: LD_VAR 0 3
5649: AND
5650: IFFALSE 5742
// begin for i in tmp do
5652: LD_ADDR_VAR 0 1
5656: PUSH
5657: LD_VAR 0 3
5661: PUSH
5662: FOR_IN
5663: IFFALSE 5738
// begin if GetTag ( i ) = tEscape then
5665: LD_VAR 0 1
5669: PPUSH
5670: CALL_OW 110
5674: PUSH
5675: LD_EXP 17
5679: EQUAL
5680: IFFALSE 5684
// continue ;
5682: GO 5662
// if IsInUnit ( i ) then
5684: LD_VAR 0 1
5688: PPUSH
5689: CALL_OW 310
5693: IFFALSE 5706
// ComExitBuilding ( i ) else
5695: LD_VAR 0 1
5699: PPUSH
5700: CALL_OW 122
5704: GO 5736
// if not HasTask ( i ) then
5706: LD_VAR 0 1
5710: PPUSH
5711: CALL_OW 314
5715: NOT
5716: IFFALSE 5736
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5718: LD_VAR 0 1
5722: PPUSH
5723: LD_VAR 0 2
5727: PUSH
5728: LD_INT 1
5730: ARRAY
5731: PPUSH
5732: CALL_OW 130
// end ;
5736: GO 5662
5738: POP
5739: POP
// end else
5740: GO 5813
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5742: LD_VAR 0 3
5746: PPUSH
5747: LD_INT 3
5749: PUSH
5750: LD_INT 54
5752: PUSH
5753: EMPTY
5754: LIST
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: PPUSH
5760: CALL_OW 72
5764: IFFALSE 5813
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5766: LD_ADDR_VAR 0 1
5770: PUSH
5771: LD_VAR 0 3
5775: PPUSH
5776: LD_INT 3
5778: PUSH
5779: LD_INT 54
5781: PUSH
5782: EMPTY
5783: LIST
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PPUSH
5789: CALL_OW 72
5793: PUSH
5794: FOR_IN
5795: IFFALSE 5811
// ComEnterUnit ( i , ruMainBase ) ;
5797: LD_VAR 0 1
5801: PPUSH
5802: LD_INT 200
5804: PPUSH
5805: CALL_OW 120
5809: GO 5794
5811: POP
5812: POP
// end ; end ;
5813: PPOPN 4
5815: END
// every 0 0$1 trigger not ruEscapeAllowed and ruSci do var i , filter , tmp , lab ;
5816: LD_EXP 4
5820: NOT
5821: PUSH
5822: LD_EXP 39
5826: AND
5827: IFFALSE 6106
5829: GO 5831
5831: DISABLE
5832: LD_INT 0
5834: PPUSH
5835: PPUSH
5836: PPUSH
5837: PPUSH
// begin enable ;
5838: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5839: LD_ADDR_VAR 0 2
5843: PUSH
5844: LD_INT 3
5846: PPUSH
5847: LD_INT 22
5849: PUSH
5850: LD_INT 3
5852: PUSH
5853: EMPTY
5854: LIST
5855: LIST
5856: PUSH
5857: LD_INT 21
5859: PUSH
5860: LD_INT 1
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: PUSH
5867: LD_INT 3
5869: PUSH
5870: LD_INT 24
5872: PUSH
5873: LD_INT 1000
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PPUSH
5889: CALL_OW 70
5893: ST_TO_ADDR
// tmp := UnitFilter ( ruSci , [ f_ok ] ) ;
5894: LD_ADDR_VAR 0 3
5898: PUSH
5899: LD_EXP 39
5903: PPUSH
5904: LD_INT 50
5906: PUSH
5907: EMPTY
5908: LIST
5909: PPUSH
5910: CALL_OW 72
5914: ST_TO_ADDR
// lab := HexInfo ( 118 , 121 ) ;
5915: LD_ADDR_VAR 0 4
5919: PUSH
5920: LD_INT 118
5922: PPUSH
5923: LD_INT 121
5925: PPUSH
5926: CALL_OW 428
5930: ST_TO_ADDR
// if filter and tmp then
5931: LD_VAR 0 2
5935: PUSH
5936: LD_VAR 0 3
5940: AND
5941: IFFALSE 6033
// begin for i in tmp do
5943: LD_ADDR_VAR 0 1
5947: PUSH
5948: LD_VAR 0 3
5952: PUSH
5953: FOR_IN
5954: IFFALSE 6029
// begin if GetTag ( i ) = tEscape then
5956: LD_VAR 0 1
5960: PPUSH
5961: CALL_OW 110
5965: PUSH
5966: LD_EXP 17
5970: EQUAL
5971: IFFALSE 5975
// continue ;
5973: GO 5953
// if IsInUnit ( i ) then
5975: LD_VAR 0 1
5979: PPUSH
5980: CALL_OW 310
5984: IFFALSE 5997
// ComExitBuilding ( i ) else
5986: LD_VAR 0 1
5990: PPUSH
5991: CALL_OW 122
5995: GO 6027
// if not HasTask ( i ) then
5997: LD_VAR 0 1
6001: PPUSH
6002: CALL_OW 314
6006: NOT
6007: IFFALSE 6027
// ComHeal ( i , filter [ 1 ] ) ;
6009: LD_VAR 0 1
6013: PPUSH
6014: LD_VAR 0 2
6018: PUSH
6019: LD_INT 1
6021: ARRAY
6022: PPUSH
6023: CALL_OW 128
// end ;
6027: GO 5953
6029: POP
6030: POP
// end else
6031: GO 6106
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
6033: LD_VAR 0 3
6037: PPUSH
6038: LD_INT 3
6040: PUSH
6041: LD_INT 54
6043: PUSH
6044: EMPTY
6045: LIST
6046: PUSH
6047: EMPTY
6048: LIST
6049: LIST
6050: PPUSH
6051: CALL_OW 72
6055: IFFALSE 6106
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
6057: LD_ADDR_VAR 0 1
6061: PUSH
6062: LD_VAR 0 3
6066: PPUSH
6067: LD_INT 3
6069: PUSH
6070: LD_INT 54
6072: PUSH
6073: EMPTY
6074: LIST
6075: PUSH
6076: EMPTY
6077: LIST
6078: LIST
6079: PPUSH
6080: CALL_OW 72
6084: PUSH
6085: FOR_IN
6086: IFFALSE 6104
// ComEnterUnit ( i , lab ) ;
6088: LD_VAR 0 1
6092: PPUSH
6093: LD_VAR 0 4
6097: PPUSH
6098: CALL_OW 120
6102: GO 6085
6104: POP
6105: POP
// end ; end ; end_of_file
6106: PPOPN 4
6108: END
// on UnitDestroyed ( un ) do begin if un = Heike then
6109: LD_VAR 0 1
6113: PUSH
6114: LD_EXP 18
6118: EQUAL
6119: IFFALSE 6128
// YouLost ( Heike ) ;
6121: LD_STRING Heike
6123: PPUSH
6124: CALL_OW 104
// if un in ruEng then
6128: LD_VAR 0 1
6132: PUSH
6133: LD_EXP 37
6137: IN
6138: IFFALSE 6156
// ruEng := ruEng diff un ;
6140: LD_ADDR_EXP 37
6144: PUSH
6145: LD_EXP 37
6149: PUSH
6150: LD_VAR 0 1
6154: DIFF
6155: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) then
6156: LD_VAR 0 1
6160: PUSH
6161: LD_INT 22
6163: PUSH
6164: LD_INT 2
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: PUSH
6171: LD_INT 21
6173: PUSH
6174: LD_INT 1
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: PUSH
6181: LD_INT 23
6183: PUSH
6184: LD_INT 2
6186: PUSH
6187: EMPTY
6188: LIST
6189: LIST
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: PPUSH
6196: CALL_OW 69
6200: IN
6201: IFFALSE 6217
// loseCounter := loseCounter + 1 ;
6203: LD_ADDR_EXP 6
6207: PUSH
6208: LD_EXP 6
6212: PUSH
6213: LD_INT 1
6215: PLUS
6216: ST_TO_ADDR
// end ;
6217: PPOPN 1
6219: END
// on EvacuateVehicle ( driver , un , p1 , p2 ) do var weapon , fac ;
6220: LD_INT 0
6222: PPUSH
6223: PPUSH
// begin if un in ruMobile then
6224: LD_VAR 0 2
6228: PUSH
6229: LD_EXP 40
6233: IN
6234: IFFALSE 6393
// begin ruMobile := ruMobile diff un ;
6236: LD_ADDR_EXP 40
6240: PUSH
6241: LD_EXP 40
6245: PUSH
6246: LD_VAR 0 2
6250: DIFF
6251: ST_TO_ADDR
// weapon := GetWeapon ( un ) ;
6252: LD_ADDR_VAR 0 5
6256: PUSH
6257: LD_VAR 0 2
6261: PPUSH
6262: CALL_OW 264
6266: ST_TO_ADDR
// fac := HexInfo ( 110 , 126 ) ;
6267: LD_ADDR_VAR 0 6
6271: PUSH
6272: LD_INT 110
6274: PPUSH
6275: LD_INT 126
6277: PPUSH
6278: CALL_OW 428
6282: ST_TO_ADDR
// if not driver or not fac then
6283: LD_VAR 0 1
6287: NOT
6288: PUSH
6289: LD_VAR 0 6
6293: NOT
6294: OR
6295: IFFALSE 6299
// exit ;
6297: GO 6393
// AddComMoveXY ( driver , 111 , 121 ) ;
6299: LD_VAR 0 1
6303: PPUSH
6304: LD_INT 111
6306: PPUSH
6307: LD_INT 121
6309: PPUSH
6310: CALL_OW 171
// AddComEnterUnit ( driver , fac ) ;
6314: LD_VAR 0 1
6318: PPUSH
6319: LD_VAR 0 6
6323: PPUSH
6324: CALL_OW 180
// repeat wait ( 0 0$1 ) ;
6328: LD_INT 35
6330: PPUSH
6331: CALL_OW 67
// until IsDead ( driver ) or IsInUnit ( driver ) ;
6335: LD_VAR 0 1
6339: PPUSH
6340: CALL_OW 301
6344: PUSH
6345: LD_VAR 0 1
6349: PPUSH
6350: CALL_OW 310
6354: OR
6355: IFFALSE 6328
// if IsDead ( driver ) then
6357: LD_VAR 0 1
6361: PPUSH
6362: CALL_OW 301
6366: IFFALSE 6370
// exit ;
6368: GO 6393
// AddComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_manual , weapon ) ;
6370: LD_VAR 0 6
6374: PPUSH
6375: LD_INT 21
6377: PPUSH
6378: LD_INT 1
6380: PPUSH
6381: LD_INT 1
6383: PPUSH
6384: LD_VAR 0 5
6388: PPUSH
6389: CALL_OW 185
// end ; end ;
6393: PPOPN 6
6395: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 3 then
6396: LD_VAR 0 2
6400: PPUSH
6401: CALL_OW 255
6405: PUSH
6406: LD_INT 3
6408: EQUAL
6409: IFFALSE 6455
// begin ruMobile := Replace ( ruMobile , ruMobile + 1 , veh ) ;
6411: LD_ADDR_EXP 40
6415: PUSH
6416: LD_EXP 40
6420: PPUSH
6421: LD_EXP 40
6425: PUSH
6426: LD_INT 1
6428: PLUS
6429: PPUSH
6430: LD_VAR 0 1
6434: PPUSH
6435: CALL_OW 1
6439: ST_TO_ADDR
// AddComMoveXY ( veh , 110 , 117 ) ;
6440: LD_VAR 0 1
6444: PPUSH
6445: LD_INT 110
6447: PPUSH
6448: LD_INT 117
6450: PPUSH
6451: CALL_OW 171
// end ; end ;
6455: PPOPN 2
6457: END
// on LeaveBuilding ( b , un ) do var barracks ;
6458: LD_INT 0
6460: PPUSH
// begin if b in [ HexInfo ( 130 , 17 ) , HexInfo ( 138 , 22 ) , HexInfo ( 123 , 17 ) ] then
6461: LD_VAR 0 1
6465: PUSH
6466: LD_INT 130
6468: PPUSH
6469: LD_INT 17
6471: PPUSH
6472: CALL_OW 428
6476: PUSH
6477: LD_INT 138
6479: PPUSH
6480: LD_INT 22
6482: PPUSH
6483: CALL_OW 428
6487: PUSH
6488: LD_INT 123
6490: PPUSH
6491: LD_INT 17
6493: PPUSH
6494: CALL_OW 428
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: LIST
6503: IN
6504: IFFALSE 6528
// begin AddComEnterUnit ( un , HexInfo ( 135 , 31 ) ) ;
6506: LD_VAR 0 2
6510: PPUSH
6511: LD_INT 135
6513: PPUSH
6514: LD_INT 31
6516: PPUSH
6517: CALL_OW 428
6521: PPUSH
6522: CALL_OW 180
// exit ;
6526: GO 6802
// end ; if b = HexInfo ( 135 , 31 ) then
6528: LD_VAR 0 1
6532: PUSH
6533: LD_INT 135
6535: PPUSH
6536: LD_INT 31
6538: PPUSH
6539: CALL_OW 428
6543: EQUAL
6544: IFFALSE 6616
// begin AddComEnterUnit ( un , HexInfo ( 106 , 51 ) ) ;
6546: LD_VAR 0 2
6550: PPUSH
6551: LD_INT 106
6553: PPUSH
6554: LD_INT 51
6556: PPUSH
6557: CALL_OW 428
6561: PPUSH
6562: CALL_OW 180
// if not explodeFirstDepot then
6566: LD_EXP 12
6570: NOT
6571: IFFALSE 6614
// begin explodeFirstDepot := true ;
6573: LD_ADDR_EXP 12
6577: PUSH
6578: LD_INT 1
6580: ST_TO_ADDR
// wait ( 0 0$15 ) ;
6581: LD_INT 525
6583: PPUSH
6584: CALL_OW 67
// MineExplosion ( 127 , 27 , 1 ) ;
6588: LD_INT 127
6590: PPUSH
6591: LD_INT 27
6593: PPUSH
6594: LD_INT 1
6596: PPUSH
6597: CALL_OW 453
// MineExplosion ( 125 , 29 , 1 ) ;
6601: LD_INT 125
6603: PPUSH
6604: LD_INT 29
6606: PPUSH
6607: LD_INT 1
6609: PPUSH
6610: CALL_OW 453
// end ; exit ;
6614: GO 6802
// end ; if b = HexInfo ( 106 , 51 ) then
6616: LD_VAR 0 1
6620: PUSH
6621: LD_INT 106
6623: PPUSH
6624: LD_INT 51
6626: PPUSH
6627: CALL_OW 428
6631: EQUAL
6632: IFFALSE 6732
// begin AddComMoveXY ( un , 106 , 93 ) ;
6634: LD_VAR 0 2
6638: PPUSH
6639: LD_INT 106
6641: PPUSH
6642: LD_INT 93
6644: PPUSH
6645: CALL_OW 171
// if not explodeSecondDepot then
6649: LD_EXP 13
6653: NOT
6654: IFFALSE 6730
// begin explodeSecondDepot := true ;
6656: LD_ADDR_EXP 13
6660: PUSH
6661: LD_INT 1
6663: ST_TO_ADDR
// wait ( 0 0$12 ) ;
6664: LD_INT 420
6666: PPUSH
6667: CALL_OW 67
// MineExplosion ( 111 , 75 , 1 ) ;
6671: LD_INT 111
6673: PPUSH
6674: LD_INT 75
6676: PPUSH
6677: LD_INT 1
6679: PPUSH
6680: CALL_OW 453
// MineExplosion ( 111 , 75 , 1 ) ;
6684: LD_INT 111
6686: PPUSH
6687: LD_INT 75
6689: PPUSH
6690: LD_INT 1
6692: PPUSH
6693: CALL_OW 453
// MineExplosion ( 108 , 69 , 1 ) ;
6697: LD_INT 108
6699: PPUSH
6700: LD_INT 69
6702: PPUSH
6703: LD_INT 1
6705: PPUSH
6706: CALL_OW 453
// wait ( 0 0$2 ) ;
6710: LD_INT 70
6712: PPUSH
6713: CALL_OW 67
// MineExplosion ( 94 , 65 , 1 ) ;
6717: LD_INT 94
6719: PPUSH
6720: LD_INT 65
6722: PPUSH
6723: LD_INT 1
6725: PPUSH
6726: CALL_OW 453
// end ; exit ;
6730: GO 6802
// end ; if GetBType ( b ) = b_bunker then
6732: LD_VAR 0 1
6736: PPUSH
6737: CALL_OW 266
6741: PUSH
6742: LD_INT 32
6744: EQUAL
6745: IFFALSE 6802
// begin barracks := NearestEmptyBuilding ( un , b_barracks ) ;
6747: LD_ADDR_VAR 0 3
6751: PUSH
6752: LD_VAR 0 2
6756: PPUSH
6757: LD_INT 5
6759: PPUSH
6760: CALL 2403 0 2
6764: ST_TO_ADDR
// if barracks then
6765: LD_VAR 0 3
6769: IFFALSE 6787
// AddComEnterUnit ( un , barracks ) else
6771: LD_VAR 0 2
6775: PPUSH
6776: LD_VAR 0 3
6780: PPUSH
6781: CALL_OW 180
6785: GO 6802
// AddComMoveXY ( un , 116 , 110 ) ;
6787: LD_VAR 0 2
6791: PPUSH
6792: LD_INT 116
6794: PPUSH
6795: LD_INT 110
6797: PPUSH
6798: CALL_OW 171
// end ; end ;
6802: PPOPN 3
6804: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un = Kaia and killerSide in [ 3 , 6 ] then
6805: LD_VAR 0 1
6809: PUSH
6810: LD_EXP 23
6814: EQUAL
6815: PUSH
6816: LD_VAR 0 2
6820: PUSH
6821: LD_INT 3
6823: PUSH
6824: LD_INT 6
6826: PUSH
6827: EMPTY
6828: LIST
6829: LIST
6830: IN
6831: AND
6832: IFFALSE 6863
// kaiaKilledByRussian := [ GetX ( un ) , GetY ( un ) ] ;
6834: LD_ADDR_EXP 8
6838: PUSH
6839: LD_VAR 0 1
6843: PPUSH
6844: CALL_OW 250
6848: PUSH
6849: LD_VAR 0 1
6853: PPUSH
6854: CALL_OW 251
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: ST_TO_ADDR
// end ; end_of_file
6863: PPOPN 3
6865: END
// export function Action ; var i , un , veh , tmp , rutmp ; begin
6866: LD_INT 0
6868: PPUSH
6869: PPUSH
6870: PPUSH
6871: PPUSH
6872: PPUSH
6873: PPUSH
// InGameOn ;
6874: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6878: LD_INT 5
6880: PPUSH
6881: LD_INT 2
6883: PPUSH
6884: CALL_OW 343
// music_nat := 4 ;
6888: LD_ADDR_OWVAR 71
6892: PUSH
6893: LD_INT 4
6895: ST_TO_ADDR
// music_class := music_combat ;
6896: LD_ADDR_OWVAR 72
6900: PUSH
6901: LD_INT 1
6903: ST_TO_ADDR
// PlaceSeeing ( 133 , 2 , 2 , 10 ) ;
6904: LD_INT 133
6906: PPUSH
6907: LD_INT 2
6909: PPUSH
6910: LD_INT 2
6912: PPUSH
6913: LD_INT 10
6915: PPUSH
6916: CALL_OW 330
// CenterNowOnXY ( 133 , 2 ) ;
6920: LD_INT 133
6922: PPUSH
6923: LD_INT 2
6925: PPUSH
6926: CALL_OW 86
// wait ( 0 0$1 ) ;
6930: LD_INT 35
6932: PPUSH
6933: CALL_OW 67
// uc_side := 6 ;
6937: LD_ADDR_OWVAR 20
6941: PUSH
6942: LD_INT 6
6944: ST_TO_ADDR
// uc_nation := 3 ;
6945: LD_ADDR_OWVAR 21
6949: PUSH
6950: LD_INT 3
6952: ST_TO_ADDR
// rutmp := [ ] ;
6953: LD_ADDR_VAR 0 6
6957: PUSH
6958: EMPTY
6959: ST_TO_ADDR
// PrepareTank ( 6 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_gun , 66 ) ;
6960: LD_INT 6
6962: PPUSH
6963: LD_INT 3
6965: PPUSH
6966: LD_INT 21
6968: PPUSH
6969: LD_INT 1
6971: PPUSH
6972: LD_INT 1
6974: PPUSH
6975: LD_INT 44
6977: PPUSH
6978: LD_INT 66
6980: PPUSH
6981: CALL 399 0 7
// veh := CreateVehicle ;
6985: LD_ADDR_VAR 0 4
6989: PUSH
6990: CALL_OW 45
6994: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
6995: LD_VAR 0 4
6999: PPUSH
7000: LD_INT 3
7002: PPUSH
7003: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7007: LD_VAR 0 4
7011: PPUSH
7012: LD_INT 8
7014: PPUSH
7015: LD_INT 0
7017: PPUSH
7018: CALL_OW 49
// SetLives ( veh , 500 ) ;
7022: LD_VAR 0 4
7026: PPUSH
7027: LD_INT 500
7029: PPUSH
7030: CALL_OW 234
// PrepareHuman ( false , 3 , 3 ) ;
7034: LD_INT 0
7036: PPUSH
7037: LD_INT 3
7039: PPUSH
7040: LD_INT 3
7042: PPUSH
7043: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7047: CALL_OW 44
7051: PPUSH
7052: LD_VAR 0 4
7056: PPUSH
7057: CALL_OW 52
// ComMoveXY ( veh , 133 , 11 ) ;
7061: LD_VAR 0 4
7065: PPUSH
7066: LD_INT 133
7068: PPUSH
7069: LD_INT 11
7071: PPUSH
7072: CALL_OW 111
// rutmp := [ veh ] ;
7076: LD_ADDR_VAR 0 6
7080: PUSH
7081: LD_VAR 0 4
7085: PUSH
7086: EMPTY
7087: LIST
7088: ST_TO_ADDR
// for i := 1 to 4 do
7089: LD_ADDR_VAR 0 2
7093: PUSH
7094: DOUBLE
7095: LD_INT 1
7097: DEC
7098: ST_TO_ADDR
7099: LD_INT 4
7101: PUSH
7102: FOR_TO
7103: IFFALSE 7210
// begin PrepareHuman ( false , i , 2 ) ;
7105: LD_INT 0
7107: PPUSH
7108: LD_VAR 0 2
7112: PPUSH
7113: LD_INT 2
7115: PPUSH
7116: CALL_OW 380
// un := CreateHuman ;
7120: LD_ADDR_VAR 0 3
7124: PUSH
7125: CALL_OW 44
7129: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7130: LD_VAR 0 3
7134: PPUSH
7135: LD_INT 3
7137: PPUSH
7138: CALL_OW 233
// PlaceUnitArea ( un , spawnArea , false ) ;
7142: LD_VAR 0 3
7146: PPUSH
7147: LD_INT 8
7149: PPUSH
7150: LD_INT 0
7152: PPUSH
7153: CALL_OW 49
// rutmp := Replace ( rutmp , rutmp + 1 , un ) ;
7157: LD_ADDR_VAR 0 6
7161: PUSH
7162: LD_VAR 0 6
7166: PPUSH
7167: LD_VAR 0 6
7171: PUSH
7172: LD_INT 1
7174: PLUS
7175: PPUSH
7176: LD_VAR 0 3
7180: PPUSH
7181: CALL_OW 1
7185: ST_TO_ADDR
// ComMoveXY ( un , 133 , 11 ) ;
7186: LD_VAR 0 3
7190: PPUSH
7191: LD_INT 133
7193: PPUSH
7194: LD_INT 11
7196: PPUSH
7197: CALL_OW 111
// wait ( 0 0$0.5 ) ;
7201: LD_INT 18
7203: PPUSH
7204: CALL_OW 67
// end ;
7208: GO 7102
7210: POP
7211: POP
// for i in rutmp do
7212: LD_ADDR_VAR 0 2
7216: PUSH
7217: LD_VAR 0 6
7221: PUSH
7222: FOR_IN
7223: IFFALSE 7272
// begin AddComMoveXY ( i , 99 , 65 ) ;
7225: LD_VAR 0 2
7229: PPUSH
7230: LD_INT 99
7232: PPUSH
7233: LD_INT 65
7235: PPUSH
7236: CALL_OW 171
// AddComMoveXY ( i , 76 , 108 ) ;
7240: LD_VAR 0 2
7244: PPUSH
7245: LD_INT 76
7247: PPUSH
7248: LD_INT 108
7250: PPUSH
7251: CALL_OW 171
// AddComMoveXY ( i , 92 , 176 ) ;
7255: LD_VAR 0 2
7259: PPUSH
7260: LD_INT 92
7262: PPUSH
7263: LD_INT 176
7265: PPUSH
7266: CALL_OW 171
// end ;
7270: GO 7222
7272: POP
7273: POP
// wait ( 0 0$10 ) ;
7274: LD_INT 350
7276: PPUSH
7277: CALL_OW 67
// tmp := [ Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Kurt , Aviradze ] union heikeSecondSquad ;
7281: LD_ADDR_VAR 0 5
7285: PUSH
7286: LD_EXP 18
7290: PUSH
7291: LD_EXP 19
7295: PUSH
7296: LD_EXP 20
7300: PUSH
7301: LD_EXP 21
7305: PUSH
7306: LD_EXP 22
7310: PUSH
7311: LD_EXP 23
7315: PUSH
7316: LD_EXP 24
7320: PUSH
7321: LD_EXP 25
7325: PUSH
7326: LD_EXP 27
7330: PUSH
7331: LD_EXP 28
7335: PUSH
7336: EMPTY
7337: LIST
7338: LIST
7339: LIST
7340: LIST
7341: LIST
7342: LIST
7343: LIST
7344: LIST
7345: LIST
7346: LIST
7347: PUSH
7348: LD_EXP 29
7352: UNION
7353: ST_TO_ADDR
// tmp := tmp diff 0 ;
7354: LD_ADDR_VAR 0 5
7358: PUSH
7359: LD_VAR 0 5
7363: PUSH
7364: LD_INT 0
7366: DIFF
7367: ST_TO_ADDR
// for i in heikeVehicles do
7368: LD_ADDR_VAR 0 2
7372: PUSH
7373: LD_EXP 30
7377: PUSH
7378: FOR_IN
7379: IFFALSE 7645
// begin if not tmp then
7381: LD_VAR 0 5
7385: NOT
7386: IFFALSE 7390
// continue ;
7388: GO 7378
// PrepareTank ( 2 , i [ 5 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] , 34 ) ;
7390: LD_INT 2
7392: PPUSH
7393: LD_VAR 0 2
7397: PUSH
7398: LD_INT 5
7400: ARRAY
7401: PPUSH
7402: LD_VAR 0 2
7406: PUSH
7407: LD_INT 1
7409: ARRAY
7410: PPUSH
7411: LD_VAR 0 2
7415: PUSH
7416: LD_INT 2
7418: ARRAY
7419: PPUSH
7420: LD_VAR 0 2
7424: PUSH
7425: LD_INT 3
7427: ARRAY
7428: PPUSH
7429: LD_VAR 0 2
7433: PUSH
7434: LD_INT 4
7436: ARRAY
7437: PPUSH
7438: LD_INT 34
7440: PPUSH
7441: CALL 399 0 7
// veh := CreateVehicle ;
7445: LD_ADDR_VAR 0 4
7449: PUSH
7450: CALL_OW 45
7454: ST_TO_ADDR
// if i [ 4 ] in [ ru_cargo_bay , ar_cargo_bay , us_cargo_bay ] then
7455: LD_VAR 0 2
7459: PUSH
7460: LD_INT 4
7462: ARRAY
7463: PUSH
7464: LD_INT 51
7466: PUSH
7467: LD_INT 32
7469: PUSH
7470: LD_INT 12
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: LIST
7477: IN
7478: IFFALSE 7558
// begin if i [ 7 ] [ 1 ] then
7480: LD_VAR 0 2
7484: PUSH
7485: LD_INT 7
7487: ARRAY
7488: PUSH
7489: LD_INT 1
7491: ARRAY
7492: IFFALSE 7519
// AddCargo ( veh , mat_cans , i [ 7 ] [ 1 ] ) ;
7494: LD_VAR 0 4
7498: PPUSH
7499: LD_INT 1
7501: PPUSH
7502: LD_VAR 0 2
7506: PUSH
7507: LD_INT 7
7509: ARRAY
7510: PUSH
7511: LD_INT 1
7513: ARRAY
7514: PPUSH
7515: CALL_OW 291
// if i [ 7 ] [ 2 ] then
7519: LD_VAR 0 2
7523: PUSH
7524: LD_INT 7
7526: ARRAY
7527: PUSH
7528: LD_INT 2
7530: ARRAY
7531: IFFALSE 7558
// AddCargo ( veh , mat_oil , i [ 7 ] [ 2 ] ) ;
7533: LD_VAR 0 4
7537: PPUSH
7538: LD_INT 2
7540: PPUSH
7541: LD_VAR 0 2
7545: PUSH
7546: LD_INT 7
7548: ARRAY
7549: PUSH
7550: LD_INT 2
7552: ARRAY
7553: PPUSH
7554: CALL_OW 291
// end ; SetDir ( veh , 3 ) ;
7558: LD_VAR 0 4
7562: PPUSH
7563: LD_INT 3
7565: PPUSH
7566: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7570: LD_VAR 0 4
7574: PPUSH
7575: LD_INT 8
7577: PPUSH
7578: LD_INT 0
7580: PPUSH
7581: CALL_OW 49
// PlaceHumanInUnit ( tmp [ 1 ] , veh ) ;
7585: LD_VAR 0 5
7589: PUSH
7590: LD_INT 1
7592: ARRAY
7593: PPUSH
7594: LD_VAR 0 4
7598: PPUSH
7599: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
7603: LD_ADDR_VAR 0 5
7607: PUSH
7608: LD_VAR 0 5
7612: PPUSH
7613: LD_INT 1
7615: PPUSH
7616: CALL_OW 3
7620: ST_TO_ADDR
// ComAgressiveMove ( veh , 133 , 7 ) ;
7621: LD_VAR 0 4
7625: PPUSH
7626: LD_INT 133
7628: PPUSH
7629: LD_INT 7
7631: PPUSH
7632: CALL_OW 114
// wait ( 0 0$1 ) ;
7636: LD_INT 35
7638: PPUSH
7639: CALL_OW 67
// end ;
7643: GO 7378
7645: POP
7646: POP
// if tmp then
7647: LD_VAR 0 5
7651: IFFALSE 7707
// for i in tmp do
7653: LD_ADDR_VAR 0 2
7657: PUSH
7658: LD_VAR 0 5
7662: PUSH
7663: FOR_IN
7664: IFFALSE 7705
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7666: LD_VAR 0 2
7670: PPUSH
7671: LD_INT 10
7673: PPUSH
7674: LD_INT 0
7676: PPUSH
7677: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7681: LD_VAR 0 2
7685: PPUSH
7686: LD_INT 146
7688: PPUSH
7689: LD_INT 7
7691: PPUSH
7692: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7696: LD_INT 18
7698: PPUSH
7699: CALL_OW 67
// end ;
7703: GO 7663
7705: POP
7706: POP
// if heikeApes then
7707: LD_EXP 31
7711: IFFALSE 7767
// for i in heikeApes do
7713: LD_ADDR_VAR 0 2
7717: PUSH
7718: LD_EXP 31
7722: PUSH
7723: FOR_IN
7724: IFFALSE 7765
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7726: LD_VAR 0 2
7730: PPUSH
7731: LD_INT 10
7733: PPUSH
7734: LD_INT 0
7736: PPUSH
7737: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7741: LD_VAR 0 2
7745: PPUSH
7746: LD_INT 146
7748: PPUSH
7749: LD_INT 7
7751: PPUSH
7752: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7756: LD_INT 18
7758: PPUSH
7759: CALL_OW 67
// end ;
7763: GO 7723
7765: POP
7766: POP
// DialogueOn ;
7767: CALL_OW 6
// Say ( Heike , DH-outpost-a-1 ) ;
7771: LD_EXP 18
7775: PPUSH
7776: LD_STRING DH-outpost-a-1
7778: PPUSH
7779: CALL_OW 88
// DialogueOff ;
7783: CALL_OW 7
// RemoveSeeing ( 133 , 2 , 2 ) ;
7787: LD_INT 133
7789: PPUSH
7790: LD_INT 2
7792: PPUSH
7793: LD_INT 2
7795: PPUSH
7796: CALL_OW 331
// InGameOff ;
7800: CALL_OW 9
// music_nat := 0 ;
7804: LD_ADDR_OWVAR 71
7808: PUSH
7809: LD_INT 0
7811: ST_TO_ADDR
// music_class := 0 ;
7812: LD_ADDR_OWVAR 72
7816: PUSH
7817: LD_INT 0
7819: ST_TO_ADDR
// ChangeMissionObjectives ( Outposts ) ;
7820: LD_STRING Outposts
7822: PPUSH
7823: CALL_OW 337
// SaveForQuickRestart ;
7827: CALL_OW 22
// end ;
7831: LD_VAR 0 1
7835: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 20 ] ] ) and ibrahimOnRuSide and IsOk ( Ibrahim ) do
7836: LD_INT 22
7838: PUSH
7839: LD_INT 2
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: PUSH
7846: LD_INT 91
7848: PUSH
7849: LD_EXP 21
7853: PUSH
7854: LD_INT 20
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: LIST
7861: PUSH
7862: EMPTY
7863: LIST
7864: LIST
7865: PPUSH
7866: CALL_OW 69
7870: PUSH
7871: LD_EXP 3
7875: AND
7876: PUSH
7877: LD_EXP 21
7881: PPUSH
7882: CALL_OW 302
7886: AND
7887: IFFALSE 7975
7889: GO 7891
7891: DISABLE
// begin IbrahimBetrayal ;
7892: CALL 7976 0 0
// repeat wait ( 0 0$1 ) ;
7896: LD_INT 35
7898: PPUSH
7899: CALL_OW 67
// until IsDead ( Ibrahim ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 6 ] ] ) ;
7903: LD_EXP 21
7907: PPUSH
7908: CALL_OW 301
7912: PUSH
7913: LD_INT 22
7915: PUSH
7916: LD_INT 2
7918: PUSH
7919: EMPTY
7920: LIST
7921: LIST
7922: PUSH
7923: LD_INT 91
7925: PUSH
7926: LD_EXP 21
7930: PUSH
7931: LD_INT 6
7933: PUSH
7934: EMPTY
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: PPUSH
7943: CALL_OW 69
7947: OR
7948: IFFALSE 7896
// if IsDead ( Ibrahim ) then
7950: LD_EXP 21
7954: PPUSH
7955: CALL_OW 301
7959: IFFALSE 7963
// exit ;
7961: GO 7975
// SetSide ( Ibrahim , 2 ) ;
7963: LD_EXP 21
7967: PPUSH
7968: LD_INT 2
7970: PPUSH
7971: CALL_OW 235
// end ;
7975: END
// export function IbrahimBetrayal ; var i , tmp ; begin
7976: LD_INT 0
7978: PPUSH
7979: PPUSH
7980: PPUSH
// PlaceSeeing ( 122 , 77 , 2 , - 6 ) ;
7981: LD_INT 122
7983: PPUSH
7984: LD_INT 77
7986: PPUSH
7987: LD_INT 2
7989: PPUSH
7990: LD_INT 6
7992: NEG
7993: PPUSH
7994: CALL_OW 330
// ComMoveXY ( Ibrahim , 123 , 79 ) ;
7998: LD_EXP 21
8002: PPUSH
8003: LD_INT 123
8005: PPUSH
8006: LD_INT 79
8008: PPUSH
8009: CALL_OW 111
// AddComTurnXY ( Ibrahim , 125 , 82 ) ;
8013: LD_EXP 21
8017: PPUSH
8018: LD_INT 125
8020: PPUSH
8021: LD_INT 82
8023: PPUSH
8024: CALL_OW 178
// wait ( 0 0$2 ) ;
8028: LD_INT 70
8030: PPUSH
8031: CALL_OW 67
// ComTurnUnit ( ruSol , Ibrahim ) ;
8035: LD_EXP 41
8039: PPUSH
8040: LD_EXP 21
8044: PPUSH
8045: CALL_OW 119
// Say ( ruSol , DRum-outpost-b-3 ) ;
8049: LD_EXP 41
8053: PPUSH
8054: LD_STRING DRum-outpost-b-3
8056: PPUSH
8057: CALL_OW 88
// tmp := [ HexInfo ( 125 , 76 ) , HexInfo ( 125 , 79 ) , HexInfo ( 125 , 82 ) ] ;
8061: LD_ADDR_VAR 0 3
8065: PUSH
8066: LD_INT 125
8068: PPUSH
8069: LD_INT 76
8071: PPUSH
8072: CALL_OW 428
8076: PUSH
8077: LD_INT 125
8079: PPUSH
8080: LD_INT 79
8082: PPUSH
8083: CALL_OW 428
8087: PUSH
8088: LD_INT 125
8090: PPUSH
8091: LD_INT 82
8093: PPUSH
8094: CALL_OW 428
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: LIST
8103: ST_TO_ADDR
// for i in tmp do
8104: LD_ADDR_VAR 0 2
8108: PUSH
8109: LD_VAR 0 3
8113: PUSH
8114: FOR_IN
8115: IFFALSE 8131
// SetLives ( i , 200 ) ;
8117: LD_VAR 0 2
8121: PPUSH
8122: LD_INT 200
8124: PPUSH
8125: CALL_OW 234
8129: GO 8114
8131: POP
8132: POP
// Say ( Ibrahim , DI-outpost-b-4 ) ;
8133: LD_EXP 21
8137: PPUSH
8138: LD_STRING DI-outpost-b-4
8140: PPUSH
8141: CALL_OW 88
// SetSide ( Ibrahim , 5 ) ;
8145: LD_EXP 21
8149: PPUSH
8150: LD_INT 5
8152: PPUSH
8153: CALL_OW 235
// ComFree ( [ Ibrahim , ruSol ] ) ;
8157: LD_EXP 21
8161: PUSH
8162: LD_EXP 41
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PPUSH
8171: CALL_OW 139
// RemoveSeeing ( 122 , 77 , 2 ) ;
8175: LD_INT 122
8177: PPUSH
8178: LD_INT 77
8180: PPUSH
8181: LD_INT 2
8183: PPUSH
8184: CALL_OW 331
// if Givi then
8188: LD_EXP 19
8192: IFFALSE 8208
// Say ( Givi , DG-1-outpost-b-5 ) else
8194: LD_EXP 19
8198: PPUSH
8199: LD_STRING DG-1-outpost-b-5
8201: PPUSH
8202: CALL_OW 88
8206: GO 8273
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-outpost-b-a-5 ) then
8208: LD_EXP 29
8212: PPUSH
8213: LD_INT 26
8215: PUSH
8216: LD_INT 2
8218: PUSH
8219: EMPTY
8220: LIST
8221: LIST
8222: PPUSH
8223: CALL_OW 72
8227: PUSH
8228: LD_INT 1
8230: ARRAY
8231: PPUSH
8232: LD_STRING DArf-outpost-b-a-5
8234: PPUSH
8235: CALL_OW 88
8239: NOT
8240: IFFALSE 8273
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-outpost-b-a-5 ) ;
8242: LD_EXP 29
8246: PPUSH
8247: LD_INT 26
8249: PUSH
8250: LD_INT 1
8252: PUSH
8253: EMPTY
8254: LIST
8255: LIST
8256: PPUSH
8257: CALL_OW 72
8261: PUSH
8262: LD_INT 1
8264: ARRAY
8265: PPUSH
8266: LD_STRING DArm-outpost-b-a-5
8268: PPUSH
8269: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
8273: LD_INT 35
8275: PPUSH
8276: CALL_OW 67
// until IsDead ( Ibrahim ) or ( GetDistUnits ( Heike , Ibrahim ) < 6 and IsOk ( Ibrahim ) ) ;
8280: LD_EXP 21
8284: PPUSH
8285: CALL_OW 301
8289: PUSH
8290: LD_EXP 18
8294: PPUSH
8295: LD_EXP 21
8299: PPUSH
8300: CALL_OW 296
8304: PUSH
8305: LD_INT 6
8307: LESS
8308: PUSH
8309: LD_EXP 21
8313: PPUSH
8314: CALL_OW 302
8318: AND
8319: OR
8320: IFFALSE 8273
// if IsDead ( Ibrahim ) then
8322: LD_EXP 21
8326: PPUSH
8327: CALL_OW 301
8331: IFFALSE 8347
// begin Say ( Heike , DH-ibrahimdead-1 ) ;
8333: LD_EXP 18
8337: PPUSH
8338: LD_STRING DH-ibrahimdead-1
8340: PPUSH
8341: CALL_OW 88
// exit ;
8345: GO 8400
// end ; CenterNowOnUnits ( Ibrahim ) ;
8347: LD_EXP 21
8351: PPUSH
8352: CALL_OW 87
// DialogueOn ;
8356: CALL_OW 6
// Say ( Ibrahim , DI-ibrahimlives-1 ) ;
8360: LD_EXP 21
8364: PPUSH
8365: LD_STRING DI-ibrahimlives-1
8367: PPUSH
8368: CALL_OW 88
// Say ( Heike , DH-Ibrahimlives-2 ) ;
8372: LD_EXP 18
8376: PPUSH
8377: LD_STRING DH-Ibrahimlives-2
8379: PPUSH
8380: CALL_OW 88
// DialogueOff ;
8384: CALL_OW 7
// SetSide ( Ibrahim , 2 ) ;
8388: LD_EXP 21
8392: PPUSH
8393: LD_INT 2
8395: PPUSH
8396: CALL_OW 235
// end ;
8400: LD_VAR 0 1
8404: RET
// every 0 0$1 trigger FilterUnitsInArea ( outerArea , [ f_side , 2 ] ) or tick >= [ 9 9$00 , 8 8$00 , 8 8$00 ] [ Difficulty ] do
8405: LD_INT 11
8407: PPUSH
8408: LD_INT 22
8410: PUSH
8411: LD_INT 2
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PPUSH
8418: CALL_OW 70
8422: PUSH
8423: LD_OWVAR 1
8427: PUSH
8428: LD_INT 18900
8430: PUSH
8431: LD_INT 16800
8433: PUSH
8434: LD_INT 16800
8436: PUSH
8437: EMPTY
8438: LIST
8439: LIST
8440: LIST
8441: PUSH
8442: LD_OWVAR 67
8446: ARRAY
8447: GREATEREQUAL
8448: OR
8449: IFFALSE 8856
8451: GO 8453
8453: DISABLE
// begin outerAreaAchived := true ;
8454: LD_ADDR_EXP 15
8458: PUSH
8459: LD_INT 1
8461: ST_TO_ADDR
// wait ( 0 0$20 ) ;
8462: LD_INT 700
8464: PPUSH
8465: CALL_OW 67
// DialogueOn ;
8469: CALL_OW 6
// SayRadio ( Shariff , DShar-radio-1 ) ;
8473: LD_EXP 26
8477: PPUSH
8478: LD_STRING DShar-radio-1
8480: PPUSH
8481: CALL_OW 94
// SayRadio ( Shariff , DShar-radio-2 ) ;
8485: LD_EXP 26
8489: PPUSH
8490: LD_STRING DShar-radio-2
8492: PPUSH
8493: CALL_OW 94
// Say ( Heike , DH-radio-2 ) ;
8497: LD_EXP 18
8501: PPUSH
8502: LD_STRING DH-radio-2
8504: PPUSH
8505: CALL_OW 88
// DialogueOff ;
8509: CALL_OW 7
// ChangeMissionObjectives ( Gaidar ) ;
8513: LD_STRING Gaidar
8515: PPUSH
8516: CALL_OW 337
// if Difficulty < 3 then
8520: LD_OWVAR 67
8524: PUSH
8525: LD_INT 3
8527: LESS
8528: IFFALSE 8594
// begin DialogueOn ;
8530: CALL_OW 6
// PlaceSeeing ( 11 , 14 , 2 , - 6 ) ;
8534: LD_INT 11
8536: PPUSH
8537: LD_INT 14
8539: PPUSH
8540: LD_INT 2
8542: PPUSH
8543: LD_INT 6
8545: NEG
8546: PPUSH
8547: CALL_OW 330
// RemoveSeeing ( 11 , 14 , 2 ) ;
8551: LD_INT 11
8553: PPUSH
8554: LD_INT 14
8556: PPUSH
8557: LD_INT 2
8559: PPUSH
8560: CALL_OW 331
// CenterOnXY ( 11 , 14 ) ;
8564: LD_INT 11
8566: PPUSH
8567: LD_INT 14
8569: PPUSH
8570: CALL_OW 84
// dwait ( 0 0$1 ) ;
8574: LD_INT 35
8576: PPUSH
8577: CALL_OW 68
// CenterNowOnUnits ( Heike ) ;
8581: LD_EXP 18
8585: PPUSH
8586: CALL_OW 87
// DialogueOff ;
8590: CALL_OW 7
// end ; wait ( 0 0$30 + rand ( 0 0$10 , 0 0$15 ) * Difficulty ) ;
8594: LD_INT 1050
8596: PUSH
8597: LD_INT 350
8599: PPUSH
8600: LD_INT 525
8602: PPUSH
8603: CALL_OW 12
8607: PUSH
8608: LD_OWVAR 67
8612: MUL
8613: PLUS
8614: PPUSH
8615: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8619: LD_INT 35
8621: PPUSH
8622: CALL_OW 67
// until HexInfo ( 2 , 1 ) = 0 ;
8626: LD_INT 2
8628: PPUSH
8629: LD_INT 1
8631: PPUSH
8632: CALL_OW 428
8636: PUSH
8637: LD_INT 0
8639: EQUAL
8640: IFFALSE 8619
// SetDir ( Gaidar , 2 ) ;
8642: LD_EXP 34
8646: PPUSH
8647: LD_INT 2
8649: PPUSH
8650: CALL_OW 233
// PlaceUnitXY ( Gaidar , 2 , 1 , false ) ;
8654: LD_EXP 34
8658: PPUSH
8659: LD_INT 2
8661: PPUSH
8662: LD_INT 1
8664: PPUSH
8665: LD_INT 0
8667: PPUSH
8668: CALL_OW 48
// ComMoveXY ( Gaidar , 19 , 24 ) ;
8672: LD_EXP 34
8676: PPUSH
8677: LD_INT 19
8679: PPUSH
8680: LD_INT 24
8682: PPUSH
8683: CALL_OW 111
// AddComWait ( Gaidar , 0 0$6 ) ;
8687: LD_EXP 34
8691: PPUSH
8692: LD_INT 210
8694: PPUSH
8695: CALL_OW 202
// AddComMoveXY ( Gaidar , 38 , 47 ) ;
8699: LD_EXP 34
8703: PPUSH
8704: LD_INT 38
8706: PPUSH
8707: LD_INT 47
8709: PPUSH
8710: CALL_OW 171
// AddComMoveXY ( Gaidar , 32 , 59 ) ;
8714: LD_EXP 34
8718: PPUSH
8719: LD_INT 32
8721: PPUSH
8722: LD_INT 59
8724: PPUSH
8725: CALL_OW 171
// AddComWait ( Gaidar , 0 0$10 ) ;
8729: LD_EXP 34
8733: PPUSH
8734: LD_INT 350
8736: PPUSH
8737: CALL_OW 202
// AddComMoveXY ( Gaidar , 62 , 116 ) ;
8741: LD_EXP 34
8745: PPUSH
8746: LD_INT 62
8748: PPUSH
8749: LD_INT 116
8751: PPUSH
8752: CALL_OW 171
// AddComMoveXY ( Gaidar , 92 , 177 ) ;
8756: LD_EXP 34
8760: PPUSH
8761: LD_INT 92
8763: PPUSH
8764: LD_INT 177
8766: PPUSH
8767: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8771: LD_INT 35
8773: PPUSH
8774: CALL_OW 67
// until IsDead ( Gaidar ) or IsAt ( Gaidar , 92 , 177 ) ;
8778: LD_EXP 34
8782: PPUSH
8783: CALL_OW 301
8787: PUSH
8788: LD_EXP 34
8792: PPUSH
8793: LD_INT 92
8795: PPUSH
8796: LD_INT 177
8798: PPUSH
8799: CALL_OW 307
8803: OR
8804: IFFALSE 8771
// if IsAt ( Gaidar , 92 , 177 ) then
8806: LD_EXP 34
8810: PPUSH
8811: LD_INT 92
8813: PPUSH
8814: LD_INT 177
8816: PPUSH
8817: CALL_OW 307
8821: IFFALSE 8834
// begin RemoveUnit ( Gaidar ) ;
8823: LD_EXP 34
8827: PPUSH
8828: CALL_OW 64
// exit ;
8832: GO 8856
// end ; gaidarKilled := true ;
8834: LD_ADDR_EXP 14
8838: PUSH
8839: LD_INT 1
8841: ST_TO_ADDR
// ChangeMissionObjectives ( GaidarKilled ) ;
8842: LD_STRING GaidarKilled
8844: PPUSH
8845: CALL_OW 337
// SetAchievement ( ACH_COMMISAR ) ;
8849: LD_STRING ACH_COMMISAR
8851: PPUSH
8852: CALL_OW 543
// end ;
8856: END
// every 0 0$1 trigger See ( 2 , Gaidar ) do
8857: LD_INT 2
8859: PPUSH
8860: LD_EXP 34
8864: PPUSH
8865: CALL_OW 292
8869: IFFALSE 8886
8871: GO 8873
8873: DISABLE
// Say ( Gaidar , DT-objective-1 ) ;
8874: LD_EXP 34
8878: PPUSH
8879: LD_STRING DT-objective-1
8881: PPUSH
8882: CALL_OW 88
8886: END
// every 0 0$5 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) do
8887: LD_INT 22
8889: PUSH
8890: LD_INT 2
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: PUSH
8897: LD_INT 2
8899: PUSH
8900: LD_INT 95
8902: PUSH
8903: LD_INT 5
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PUSH
8910: LD_INT 95
8912: PUSH
8913: LD_INT 6
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PUSH
8920: LD_INT 95
8922: PUSH
8923: LD_INT 7
8925: PUSH
8926: EMPTY
8927: LIST
8928: LIST
8929: PUSH
8930: EMPTY
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: PUSH
8936: EMPTY
8937: LIST
8938: LIST
8939: PPUSH
8940: CALL_OW 69
8944: IFFALSE 8981
8946: GO 8948
8948: DISABLE
// begin DialogueOn ;
8949: CALL_OW 6
// Say ( Heike , DH-outpost-last-1 ) ;
8953: LD_EXP 18
8957: PPUSH
8958: LD_STRING DH-outpost-last-1
8960: PPUSH
8961: CALL_OW 88
// SayRadio ( Burlak , DB-outpost-last-2 ) ;
8965: LD_EXP 33
8969: PPUSH
8970: LD_STRING DB-outpost-last-2
8972: PPUSH
8973: CALL_OW 94
// DialogueOff ;
8977: CALL_OW 7
// end ;
8981: END
// every 0 0$1 trigger GetLives ( ruMainBase ) < 999 or GetSide ( ruMainBase ) = 2 do var i , tmp ;
8982: LD_INT 200
8984: PPUSH
8985: CALL_OW 256
8989: PUSH
8990: LD_INT 999
8992: LESS
8993: PUSH
8994: LD_INT 200
8996: PPUSH
8997: CALL_OW 255
9001: PUSH
9002: LD_INT 2
9004: EQUAL
9005: OR
9006: IFFALSE 9179
9008: GO 9010
9010: DISABLE
9011: LD_INT 0
9013: PPUSH
9014: PPUSH
// begin if not earlyEscape then
9015: LD_EXP 16
9019: NOT
9020: IFFALSE 9046
// begin SayRadio ( Burlak , DB-end-1 ) ;
9022: LD_EXP 33
9026: PPUSH
9027: LD_STRING DB-end-1
9029: PPUSH
9030: CALL_OW 94
// Say ( Heike , DH-end-2 ) ;
9034: LD_EXP 18
9038: PPUSH
9039: LD_STRING DH-end-2
9041: PPUSH
9042: CALL_OW 88
// end ; if tick <= 15 15$00 then
9046: LD_OWVAR 1
9050: PUSH
9051: LD_INT 31500
9053: LESSEQUAL
9054: IFFALSE 9063
// SetAchievement ( ACH_FIST ) ;
9056: LD_STRING ACH_FIST
9058: PPUSH
9059: CALL_OW 543
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9063: LD_ADDR_VAR 0 2
9067: PUSH
9068: LD_INT 22
9070: PUSH
9071: LD_INT 3
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: LD_INT 3
9080: PUSH
9081: LD_INT 21
9083: PUSH
9084: LD_INT 3
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: PUSH
9091: EMPTY
9092: LIST
9093: LIST
9094: PUSH
9095: EMPTY
9096: LIST
9097: LIST
9098: PPUSH
9099: CALL_OW 69
9103: ST_TO_ADDR
// if not tmp then
9104: LD_VAR 0 2
9108: NOT
9109: IFFALSE 9113
// exit ;
9111: GO 9179
// for i in tmp do
9113: LD_ADDR_VAR 0 1
9117: PUSH
9118: LD_VAR 0 2
9122: PUSH
9123: FOR_IN
9124: IFFALSE 9177
// begin SetTag ( i , tEscape ) ;
9126: LD_VAR 0 1
9130: PPUSH
9131: LD_EXP 17
9135: PPUSH
9136: CALL_OW 109
// if IsInUnit ( i ) then
9140: LD_VAR 0 1
9144: PPUSH
9145: CALL_OW 310
9149: IFFALSE 9160
// ComExitBuilding ( i ) ;
9151: LD_VAR 0 1
9155: PPUSH
9156: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9160: LD_VAR 0 1
9164: PPUSH
9165: LD_INT 92
9167: PPUSH
9168: LD_INT 177
9170: PPUSH
9171: CALL_OW 171
// end ;
9175: GO 9123
9177: POP
9178: POP
// end ;
9179: PPOPN 2
9181: END
// every 0 0$1 trigger FilterUnitsInArea ( zone1 , [ f_side , 2 ] ) and not outerAreaAchived and IsOk ( Kurt ) do
9182: LD_INT 4
9184: PPUSH
9185: LD_INT 22
9187: PUSH
9188: LD_INT 2
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 70
9199: PUSH
9200: LD_EXP 15
9204: NOT
9205: AND
9206: PUSH
9207: LD_EXP 27
9211: PPUSH
9212: CALL_OW 302
9216: AND
9217: IFFALSE 9457
9219: GO 9221
9221: DISABLE
// begin DialogueOn ;
9222: CALL_OW 6
// PlaceSeeing ( 111 , 54 , 2 , - 16 ) ;
9226: LD_INT 111
9228: PPUSH
9229: LD_INT 54
9231: PPUSH
9232: LD_INT 2
9234: PPUSH
9235: LD_INT 16
9237: NEG
9238: PPUSH
9239: CALL_OW 330
// CenterNowOnXY ( 111 , 53 ) ;
9243: LD_INT 111
9245: PPUSH
9246: LD_INT 53
9248: PPUSH
9249: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
9253: LD_INT 10
9255: PPUSH
9256: CALL_OW 68
// Say ( Kurt , DKs-Hannibal-1 ) ;
9260: LD_EXP 27
9264: PPUSH
9265: LD_STRING DKs-Hannibal-1
9267: PPUSH
9268: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-2 ) ;
9272: LD_EXP 27
9276: PPUSH
9277: LD_STRING DKs-Hannibal-2
9279: PPUSH
9280: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-3 ) ;
9284: LD_EXP 27
9288: PPUSH
9289: LD_STRING DKs-Hannibal-3
9291: PPUSH
9292: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-4 ) ;
9296: LD_EXP 27
9300: PPUSH
9301: LD_STRING DKs-Hannibal-4
9303: PPUSH
9304: CALL_OW 88
// dwait ( 0 0$1 ) ;
9308: LD_INT 35
9310: PPUSH
9311: CALL_OW 68
// RemoveSeeing ( 111 , 54 , 2 ) ;
9315: LD_INT 111
9317: PPUSH
9318: LD_INT 54
9320: PPUSH
9321: LD_INT 2
9323: PPUSH
9324: CALL_OW 331
// PlaceSeeing ( 173 , 76 , 2 , - 12 ) ;
9328: LD_INT 173
9330: PPUSH
9331: LD_INT 76
9333: PPUSH
9334: LD_INT 2
9336: PPUSH
9337: LD_INT 12
9339: NEG
9340: PPUSH
9341: CALL_OW 330
// RemoveSeeing ( 173 , 76 , 2 ) ;
9345: LD_INT 173
9347: PPUSH
9348: LD_INT 76
9350: PPUSH
9351: LD_INT 2
9353: PPUSH
9354: CALL_OW 331
// CenterNowOnXY ( 173 , 76 ) ;
9358: LD_INT 173
9360: PPUSH
9361: LD_INT 76
9363: PPUSH
9364: CALL_OW 86
// Say ( Kurt , DKs-Hannibal-5 ) ;
9368: LD_EXP 27
9372: PPUSH
9373: LD_STRING DKs-Hannibal-5
9375: PPUSH
9376: CALL_OW 88
// if Kamil and not FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_flame_thrower ] ] ) then
9380: LD_EXP 22
9384: PUSH
9385: LD_INT 22
9387: PUSH
9388: LD_INT 2
9390: PUSH
9391: EMPTY
9392: LIST
9393: LIST
9394: PUSH
9395: LD_INT 34
9397: PUSH
9398: LD_INT 26
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PPUSH
9409: CALL_OW 69
9413: NOT
9414: AND
9415: IFFALSE 9453
// begin Say ( Kamil , DKam-Hannibal-a-6 ) ;
9417: LD_EXP 22
9421: PPUSH
9422: LD_STRING DKam-Hannibal-a-6
9424: PPUSH
9425: CALL_OW 88
// Say ( Kamil , DKam-Hannibal-a-7 ) ;
9429: LD_EXP 22
9433: PPUSH
9434: LD_STRING DKam-Hannibal-a-7
9436: PPUSH
9437: CALL_OW 88
// Say ( Givi , DG-Hannibal-a-8 ) ;
9441: LD_EXP 19
9445: PPUSH
9446: LD_STRING DG-Hannibal-a-8
9448: PPUSH
9449: CALL_OW 88
// end ; DialogueOff ;
9453: CALL_OW 7
// end ;
9457: END
// every 0 0$1 trigger IsOk ( ruSecBase ) and IsOk ( ruMainBase ) and FilterUnitsInArea ( showDefenceArea , [ f_type , unit_building ] ) > 2 and FilterUnitsInArea ( forestArea , [ f_side , 2 ] ) > 3 do
9458: LD_INT 225
9460: PPUSH
9461: CALL_OW 302
9465: PUSH
9466: LD_INT 200
9468: PPUSH
9469: CALL_OW 302
9473: AND
9474: PUSH
9475: LD_INT 12
9477: PPUSH
9478: LD_INT 21
9480: PUSH
9481: LD_INT 3
9483: PUSH
9484: EMPTY
9485: LIST
9486: LIST
9487: PPUSH
9488: CALL_OW 70
9492: PUSH
9493: LD_INT 2
9495: GREATER
9496: AND
9497: PUSH
9498: LD_INT 13
9500: PPUSH
9501: LD_INT 22
9503: PUSH
9504: LD_INT 2
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: PPUSH
9511: CALL_OW 70
9515: PUSH
9516: LD_INT 3
9518: GREATER
9519: AND
9520: IFFALSE 9533
9522: GO 9524
9524: DISABLE
// hannibalPath := true ;
9525: LD_ADDR_EXP 9
9529: PUSH
9530: LD_INT 1
9532: ST_TO_ADDR
9533: END
// every 0 0$3 trigger hannibalPath and FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) do var i , tmp , hasFlameThrower ;
9534: LD_EXP 9
9538: PUSH
9539: LD_INT 6
9541: PPUSH
9542: LD_INT 22
9544: PUSH
9545: LD_INT 2
9547: PUSH
9548: EMPTY
9549: LIST
9550: LIST
9551: PPUSH
9552: CALL_OW 70
9556: AND
9557: IFFALSE 9902
9559: GO 9561
9561: DISABLE
9562: LD_INT 0
9564: PPUSH
9565: PPUSH
9566: PPUSH
// begin tmp := FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) ;
9567: LD_ADDR_VAR 0 2
9571: PUSH
9572: LD_INT 6
9574: PPUSH
9575: LD_INT 22
9577: PUSH
9578: LD_INT 2
9580: PUSH
9581: EMPTY
9582: LIST
9583: LIST
9584: PPUSH
9585: CALL_OW 70
9589: ST_TO_ADDR
// hasFlameThrower := UnitFilter ( tmp , [ f_weapon , ar_flame_thrower ] ) > 0 ;
9590: LD_ADDR_VAR 0 3
9594: PUSH
9595: LD_VAR 0 2
9599: PPUSH
9600: LD_INT 34
9602: PUSH
9603: LD_INT 26
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 72
9614: PUSH
9615: LD_INT 0
9617: GREATER
9618: ST_TO_ADDR
// DialogueOn ;
9619: CALL_OW 6
// Say ( Heike , DH-Cleverattack-1 ) ;
9623: LD_EXP 18
9627: PPUSH
9628: LD_STRING DH-Cleverattack-1
9630: PPUSH
9631: CALL_OW 88
// Say ( Heike , DH-Cleverattack-2 ) ;
9635: LD_EXP 18
9639: PPUSH
9640: LD_STRING DH-Cleverattack-2
9642: PPUSH
9643: CALL_OW 88
// if hasFlameThrower then
9647: LD_VAR 0 3
9651: IFFALSE 9679
// begin SayRadio ( Burlak , DB-Cleverattack-3 ) ;
9653: LD_EXP 33
9657: PPUSH
9658: LD_STRING DB-Cleverattack-3
9660: PPUSH
9661: CALL_OW 94
// Say ( Heike , DH-Cleverattack-4 ) ;
9665: LD_EXP 18
9669: PPUSH
9670: LD_STRING DH-Cleverattack-4
9672: PPUSH
9673: CALL_OW 88
// end else
9677: GO 9703
// begin SayRadio ( Burlak , DB-Cleverattack-a-3 ) ;
9679: LD_EXP 33
9683: PPUSH
9684: LD_STRING DB-Cleverattack-a-3
9686: PPUSH
9687: CALL_OW 94
// Say ( Heike , DH-Cleverattack-a-4 ) ;
9691: LD_EXP 18
9695: PPUSH
9696: LD_STRING DH-Cleverattack-a-4
9698: PPUSH
9699: CALL_OW 88
// end ; DialogueOff ;
9703: CALL_OW 7
// if not hasFlameThrower then
9707: LD_VAR 0 3
9711: NOT
9712: IFFALSE 9716
// exit ;
9714: GO 9902
// earlyEscape := true ;
9716: LD_ADDR_EXP 16
9720: PUSH
9721: LD_INT 1
9723: ST_TO_ADDR
// wait ( 0 0$4 ) ;
9724: LD_INT 140
9726: PPUSH
9727: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ] ) diff [ Ibrahim , Kuzmov , Gaidar ] ;
9731: LD_ADDR_VAR 0 2
9735: PUSH
9736: LD_INT 22
9738: PUSH
9739: LD_INT 3
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PUSH
9746: LD_INT 2
9748: PUSH
9749: LD_INT 25
9751: PUSH
9752: LD_INT 1
9754: PUSH
9755: EMPTY
9756: LIST
9757: LIST
9758: PUSH
9759: LD_INT 25
9761: PUSH
9762: LD_INT 2
9764: PUSH
9765: EMPTY
9766: LIST
9767: LIST
9768: PUSH
9769: LD_INT 25
9771: PUSH
9772: LD_INT 4
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PUSH
9779: EMPTY
9780: LIST
9781: LIST
9782: LIST
9783: LIST
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PPUSH
9789: CALL_OW 69
9793: PUSH
9794: LD_EXP 21
9798: PUSH
9799: LD_EXP 35
9803: PUSH
9804: LD_EXP 34
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: LIST
9813: DIFF
9814: ST_TO_ADDR
// for i in tmp do
9815: LD_ADDR_VAR 0 1
9819: PUSH
9820: LD_VAR 0 2
9824: PUSH
9825: FOR_IN
9826: IFFALSE 9900
// begin if Prob ( 40 + 10 * Difficulty ) then
9828: LD_INT 40
9830: PUSH
9831: LD_INT 10
9833: PUSH
9834: LD_OWVAR 67
9838: MUL
9839: PLUS
9840: PPUSH
9841: CALL_OW 13
9845: IFFALSE 9849
// continue ;
9847: GO 9825
// SetTag ( i , tEscape ) ;
9849: LD_VAR 0 1
9853: PPUSH
9854: LD_EXP 17
9858: PPUSH
9859: CALL_OW 109
// if IsInUnit ( i ) then
9863: LD_VAR 0 1
9867: PPUSH
9868: CALL_OW 310
9872: IFFALSE 9883
// ComExitBuilding ( i ) ;
9874: LD_VAR 0 1
9878: PPUSH
9879: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9883: LD_VAR 0 1
9887: PPUSH
9888: LD_INT 92
9890: PPUSH
9891: LD_INT 177
9893: PPUSH
9894: CALL_OW 171
// end ;
9898: GO 9825
9900: POP
9901: POP
// end ;
9902: PPOPN 3
9904: END
// every 0 0$1 trigger FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do var i ;
9905: LD_INT 9
9907: PPUSH
9908: LD_INT 2
9910: PUSH
9911: LD_INT 22
9913: PUSH
9914: LD_INT 3
9916: PUSH
9917: EMPTY
9918: LIST
9919: LIST
9920: PUSH
9921: LD_INT 22
9923: PUSH
9924: LD_INT 6
9926: PUSH
9927: EMPTY
9928: LIST
9929: LIST
9930: PUSH
9931: EMPTY
9932: LIST
9933: LIST
9934: LIST
9935: PPUSH
9936: CALL_OW 70
9940: IFFALSE 10038
9942: GO 9944
9944: DISABLE
9945: LD_INT 0
9947: PPUSH
// begin enable ;
9948: ENABLE
// for i in FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do
9949: LD_ADDR_VAR 0 1
9953: PUSH
9954: LD_INT 9
9956: PPUSH
9957: LD_INT 2
9959: PUSH
9960: LD_INT 22
9962: PUSH
9963: LD_INT 3
9965: PUSH
9966: EMPTY
9967: LIST
9968: LIST
9969: PUSH
9970: LD_INT 22
9972: PUSH
9973: LD_INT 6
9975: PUSH
9976: EMPTY
9977: LIST
9978: LIST
9979: PUSH
9980: EMPTY
9981: LIST
9982: LIST
9983: LIST
9984: PPUSH
9985: CALL_OW 70
9989: PUSH
9990: FOR_IN
9991: IFFALSE 10036
// if GetTag ( i ) = tEscape or GetSide ( i ) = 6 then
9993: LD_VAR 0 1
9997: PPUSH
9998: CALL_OW 110
10002: PUSH
10003: LD_EXP 17
10007: EQUAL
10008: PUSH
10009: LD_VAR 0 1
10013: PPUSH
10014: CALL_OW 255
10018: PUSH
10019: LD_INT 6
10021: EQUAL
10022: OR
10023: IFFALSE 10034
// RemoveUnit ( i ) ;
10025: LD_VAR 0 1
10029: PPUSH
10030: CALL_OW 64
10034: GO 9990
10036: POP
10037: POP
// end ;
10038: PPOPN 1
10040: END
// every 0 0$1 trigger Kaia and GetLives ( Kaia ) < 3 do
10041: LD_EXP 23
10045: PUSH
10046: LD_EXP 23
10050: PPUSH
10051: CALL_OW 256
10055: PUSH
10056: LD_INT 3
10058: LESS
10059: AND
10060: IFFALSE 10106
10062: GO 10064
10064: DISABLE
// begin DialogueOn ;
10065: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
10069: LD_EXP 23
10073: PPUSH
10074: CALL_OW 87
// ForceSay ( Kaia , DK-Kkilled-1 ) ;
10078: LD_EXP 23
10082: PPUSH
10083: LD_STRING DK-Kkilled-1
10085: PPUSH
10086: CALL_OW 91
// Say ( Heike , DH-Kkilled-2 ) ;
10090: LD_EXP 18
10094: PPUSH
10095: LD_STRING DH-Kkilled-2
10097: PPUSH
10098: CALL_OW 88
// DialogueOff ;
10102: CALL_OW 7
// end ;
10106: END
// every 0 0$1 trigger kaiaKilledByRussian do
10107: LD_EXP 8
10111: IFFALSE 10128
10113: GO 10115
10115: DISABLE
// Say ( Heike , DH-Kkilled-3 ) ;
10116: LD_EXP 18
10120: PPUSH
10121: LD_STRING DH-Kkilled-3
10123: PPUSH
10124: CALL_OW 88
10128: END
// every 0 0$1 trigger tick >= 22 22$00 do
10129: LD_OWVAR 1
10133: PUSH
10134: LD_INT 46200
10136: GREATEREQUAL
10137: IFFALSE 10174
10139: GO 10141
10141: DISABLE
// begin DialogueOn ;
10142: CALL_OW 6
// SayRadio ( Shariff , DShar-slow-1 ) ;
10146: LD_EXP 26
10150: PPUSH
10151: LD_STRING DShar-slow-1
10153: PPUSH
10154: CALL_OW 94
// SayRadio ( Shariff , DShar-slow-2 ) ;
10158: LD_EXP 26
10162: PPUSH
10163: LD_STRING DShar-slow-2
10165: PPUSH
10166: CALL_OW 94
// DialogueOff ;
10170: CALL_OW 7
// end ;
10174: END
// every 0 0$1 trigger tick >= [ 40 40$00 , 36 36$00 , 32 32$00 ] [ Difficulty ] do
10175: LD_OWVAR 1
10179: PUSH
10180: LD_INT 84000
10182: PUSH
10183: LD_INT 75600
10185: PUSH
10186: LD_INT 67200
10188: PUSH
10189: EMPTY
10190: LIST
10191: LIST
10192: LIST
10193: PUSH
10194: LD_OWVAR 67
10198: ARRAY
10199: GREATEREQUAL
10200: IFFALSE 10244
10202: GO 10204
10204: DISABLE
// begin DialogueOn ;
10205: CALL_OW 6
// SayRadio ( Shariff , DShar-fail-1 ) ;
10209: LD_EXP 26
10213: PPUSH
10214: LD_STRING DShar-fail-1
10216: PPUSH
10217: CALL_OW 94
// SayRadio ( Shariff , DShar-fail-2 ) ;
10221: LD_EXP 26
10225: PPUSH
10226: LD_STRING DShar-fail-2
10228: PPUSH
10229: CALL_OW 94
// DialogueOff ;
10233: CALL_OW 7
// YouLost ( Time ) ;
10237: LD_STRING Time
10239: PPUSH
10240: CALL_OW 104
// end ;
10244: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) = 0 do var tmp ;
10245: LD_INT 22
10247: PUSH
10248: LD_INT 3
10250: PUSH
10251: EMPTY
10252: LIST
10253: LIST
10254: PUSH
10255: LD_INT 2
10257: PUSH
10258: LD_INT 30
10260: PUSH
10261: LD_INT 1
10263: PUSH
10264: EMPTY
10265: LIST
10266: LIST
10267: PUSH
10268: LD_INT 30
10270: PUSH
10271: LD_INT 0
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: LIST
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PPUSH
10287: CALL_OW 69
10291: PUSH
10292: LD_INT 0
10294: EQUAL
10295: IFFALSE 10786
10297: GO 10299
10299: DISABLE
10300: LD_INT 0
10302: PPUSH
// begin if ( tick + gameTime ) <= [ 75 75$00 , 70 70$00 , 65 65$00 ] [ Difficulty ] then
10303: LD_OWVAR 1
10307: PUSH
10308: LD_EXP 5
10312: PLUS
10313: PUSH
10314: LD_INT 157500
10316: PUSH
10317: LD_INT 147000
10319: PUSH
10320: LD_INT 136500
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: LIST
10327: PUSH
10328: LD_OWVAR 67
10332: ARRAY
10333: LESSEQUAL
10334: IFFALSE 10348
// AddMedal ( med1 , 1 ) else
10336: LD_STRING med1
10338: PPUSH
10339: LD_INT 1
10341: PPUSH
10342: CALL_OW 101
10346: GO 10359
// AddMedal ( med1 , - 1 ) ;
10348: LD_STRING med1
10350: PPUSH
10351: LD_INT 1
10353: NEG
10354: PPUSH
10355: CALL_OW 101
// if ( flamethrowers >= 3 ) * baseHill * hannibalPath * ( loseCounter < [ 6 , 5 , 4 ] [ Difficulty ] ) then
10359: LD_EXP 7
10363: PUSH
10364: LD_INT 3
10366: GREATEREQUAL
10367: PUSH
10368: LD_EXP 11
10372: MUL
10373: PUSH
10374: LD_EXP 9
10378: MUL
10379: PUSH
10380: LD_EXP 6
10384: PUSH
10385: LD_INT 6
10387: PUSH
10388: LD_INT 5
10390: PUSH
10391: LD_INT 4
10393: PUSH
10394: EMPTY
10395: LIST
10396: LIST
10397: LIST
10398: PUSH
10399: LD_OWVAR 67
10403: ARRAY
10404: LESS
10405: MUL
10406: IFFALSE 10420
// AddMedal ( med2 , 1 ) else
10408: LD_STRING med2
10410: PPUSH
10411: LD_INT 1
10413: PPUSH
10414: CALL_OW 101
10418: GO 10431
// AddMedal ( med2 , - 1 ) ;
10420: LD_STRING med2
10422: PPUSH
10423: LD_INT 1
10425: NEG
10426: PPUSH
10427: CALL_OW 101
// if gaidarKilled then
10431: LD_EXP 14
10435: IFFALSE 10449
// AddMedal ( med3 , 1 ) else
10437: LD_STRING med3
10439: PPUSH
10440: LD_INT 1
10442: PPUSH
10443: CALL_OW 101
10447: GO 10460
// AddMedal ( med3 , - 1 ) ;
10449: LD_STRING med3
10451: PPUSH
10452: LD_INT 1
10454: NEG
10455: PPUSH
10456: CALL_OW 101
// GiveMedals ( MAIN ) ;
10460: LD_STRING MAIN
10462: PPUSH
10463: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_nation , 0 ] ] ] ) ) ;
10467: LD_INT 22
10469: PUSH
10470: LD_INT 2
10472: PUSH
10473: EMPTY
10474: LIST
10475: LIST
10476: PUSH
10477: LD_INT 3
10479: PUSH
10480: LD_INT 23
10482: PUSH
10483: LD_INT 0
10485: PUSH
10486: EMPTY
10487: LIST
10488: LIST
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: PUSH
10494: EMPTY
10495: LIST
10496: LIST
10497: PPUSH
10498: CALL_OW 69
10502: PPUSH
10503: CALL_OW 43
// SaveCharacters ( Heike , 04_2_Heike ) ;
10507: LD_EXP 18
10511: PPUSH
10512: LD_STRING 04_2_Heike
10514: PPUSH
10515: CALL_OW 38
// if Aviradze then
10519: LD_EXP 28
10523: IFFALSE 10537
// SaveCharacters ( Aviradze , 04_2_Aviradze ) ;
10525: LD_EXP 28
10529: PPUSH
10530: LD_STRING 04_2_Aviradze
10532: PPUSH
10533: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
10537: LD_EXP 21
10541: PUSH
10542: LD_EXP 21
10546: PPUSH
10547: CALL_OW 255
10551: PUSH
10552: LD_INT 2
10554: EQUAL
10555: AND
10556: IFFALSE 10586
// begin if ibrahimOnRuSide then
10558: LD_EXP 3
10562: IFFALSE 10574
// SaveVariable ( true , 04_2_IbrahimJoined ) ;
10564: LD_INT 1
10566: PPUSH
10567: LD_STRING 04_2_IbrahimJoined
10569: PPUSH
10570: CALL_OW 39
// SaveCharacters ( Ibrahim , 04_2_Ibrahim ) ;
10574: LD_EXP 21
10578: PPUSH
10579: LD_STRING 04_2_Ibrahim
10581: PPUSH
10582: CALL_OW 38
// end ; if Kamil then
10586: LD_EXP 22
10590: IFFALSE 10604
// SaveCharacters ( Kamil , 04_2_Kamil ) ;
10592: LD_EXP 22
10596: PPUSH
10597: LD_STRING 04_2_Kamil
10599: PPUSH
10600: CALL_OW 38
// if Sophia then
10604: LD_EXP 24
10608: IFFALSE 10622
// SaveCharacters ( Sophia , 04_2_Sophia ) ;
10610: LD_EXP 24
10614: PPUSH
10615: LD_STRING 04_2_Sophia
10617: PPUSH
10618: CALL_OW 38
// if Kaia then
10622: LD_EXP 23
10626: IFFALSE 10640
// SaveCharacters ( Kaia , 04_2_Kaia ) ;
10628: LD_EXP 23
10632: PPUSH
10633: LD_STRING 04_2_Kaia
10635: PPUSH
10636: CALL_OW 38
// if Givi then
10640: LD_EXP 19
10644: IFFALSE 10658
// SaveCharacters ( Givi , 04_2_Givi ) ;
10646: LD_EXP 19
10650: PPUSH
10651: LD_STRING 04_2_Givi
10653: PPUSH
10654: CALL_OW 38
// if Mike then
10658: LD_EXP 20
10662: IFFALSE 10676
// SaveCharacters ( Mike , 04_2_Mike ) ;
10664: LD_EXP 20
10668: PPUSH
10669: LD_STRING 04_2_Mike
10671: PPUSH
10672: CALL_OW 38
// if Markov then
10676: LD_EXP 25
10680: IFFALSE 10694
// SaveCharacters ( Markov , 04_2_Markov ) ;
10682: LD_EXP 25
10686: PPUSH
10687: LD_STRING 04_2_Markov
10689: PPUSH
10690: CALL_OW 38
// if Kurt then
10694: LD_EXP 27
10698: IFFALSE 10712
// SaveCharacters ( Kurt , 04_2_Kurt ) ;
10700: LD_EXP 27
10704: PPUSH
10705: LD_STRING 04_2_Kurt
10707: PPUSH
10708: CALL_OW 38
// if heikeSecondSquad then
10712: LD_EXP 29
10716: IFFALSE 10730
// SaveCharacters ( heikeSecondSquad , 04_2_others ) ;
10718: LD_EXP 29
10722: PPUSH
10723: LD_STRING 04_2_others
10725: PPUSH
10726: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
10730: LD_ADDR_VAR 0 1
10734: PUSH
10735: LD_INT 22
10737: PUSH
10738: LD_INT 2
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: PUSH
10745: LD_INT 23
10747: PUSH
10748: LD_INT 0
10750: PUSH
10751: EMPTY
10752: LIST
10753: LIST
10754: PUSH
10755: EMPTY
10756: LIST
10757: LIST
10758: PPUSH
10759: CALL_OW 69
10763: ST_TO_ADDR
// if tmp then
10764: LD_VAR 0 1
10768: IFFALSE 10782
// SaveCharacters ( tmp , 04_2_apes ) ;
10770: LD_VAR 0 1
10774: PPUSH
10775: LD_STRING 04_2_apes
10777: PPUSH
10778: CALL_OW 38
// YouWin ;
10782: CALL_OW 103
// end ;
10786: PPOPN 1
10788: END
