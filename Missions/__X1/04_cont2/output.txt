// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 45 0 0
// InitTag ;
   8: CALL 229 0 0
// PrepareNature ( natureArea ) ;
  12: LD_INT 2
  14: PPUSH
  15: CALL 704 0 1
// PrepareRussian ;
  19: CALL 3257 0 0
// PrepareArabian ;
  23: CALL 2626 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 2 ) ;
  33: LD_INT 2
  35: PPUSH
  36: CALL_OW 344
// Action ;
  40: CALL 6780 0 0
// end ;
  44: END
// export debug , prefix ; export ibrahimOnRuSide , ruEscapeAllowed , gameTime , loseCounter , flamethrowers , kaiaKilledByRussian , hannibalPath , ruEscapeCounter , baseHill , explodeFirstDepot , explodeSecondDepot , gaidarKilled , outerAreaAchived , earlyEscape ; function Init ; begin
  45: LD_INT 0
  47: PPUSH
// debug := false ;
  48: LD_ADDR_EXP 1
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// prefix := 04_1_ ;
  56: LD_ADDR_EXP 2
  60: PUSH
  61: LD_STRING 04_1_
  63: ST_TO_ADDR
// ibrahimOnRuSide := LoadVariable ( 03_IbrahimHasEscaped , false ) ;
  64: LD_ADDR_EXP 3
  68: PUSH
  69: LD_STRING 03_IbrahimHasEscaped
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: CALL_OW 30
  79: ST_TO_ADDR
// ruEscapeCounter := LoadVariable ( 04_1_EscapeCounter , 0 ) ;
  80: LD_ADDR_EXP 10
  84: PUSH
  85: LD_STRING 04_1_EscapeCounter
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// loseCounter := LoadVariable ( 04_1_DeadCounter , 0 ) ;
  96: LD_ADDR_EXP 6
 100: PUSH
 101: LD_STRING 04_1_DeadCounter
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// baseHill := LoadVariable ( 04_1_BaseHill , false ) ;
 112: LD_ADDR_EXP 11
 116: PUSH
 117: LD_STRING 04_1_BaseHill
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL_OW 30
 127: ST_TO_ADDR
// gameTime := LoadVariable ( 04_1_Time , 40 40$00 ) ;
 128: LD_ADDR_EXP 5
 132: PUSH
 133: LD_STRING 04_1_Time
 135: PPUSH
 136: LD_INT 84000
 138: PPUSH
 139: CALL_OW 30
 143: ST_TO_ADDR
// flamethrowers := LoadVariable ( 04_1_Flamethrower , 0 ) ;
 144: LD_ADDR_EXP 7
 148: PUSH
 149: LD_STRING 04_1_Flamethrower
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: CALL_OW 30
 159: ST_TO_ADDR
// ruEscapeAllowed := false ;
 160: LD_ADDR_EXP 4
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// explodeFirstDepot := false ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// explodeSecondDepot := false ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// gaidarKilled := false ;
 184: LD_ADDR_EXP 14
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// kaiaKilledByRussian := false ;
 192: LD_ADDR_EXP 8
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// outerAreaAchived := false ;
 200: LD_ADDR_EXP 15
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// hannibalPath := false ;
 208: LD_ADDR_EXP 9
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// earlyEscape := false ;
 216: LD_ADDR_EXP 16
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// end ;
 224: LD_VAR 0 1
 228: RET
// export tEscape ; function InitTag ; begin
 229: LD_INT 0
 231: PPUSH
// tEscape := 10 ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: LD_INT 10
 239: ST_TO_ADDR
// end ;
 240: LD_VAR 0 1
 244: RET
// every 0 0$1 trigger debug do var i ;
 245: LD_EXP 1
 249: IFFALSE 333
 251: GO 253
 253: DISABLE
 254: LD_INT 0
 256: PPUSH
// begin enable ;
 257: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) do
 258: LD_ADDR_VAR 0 1
 262: PUSH
 263: LD_INT 22
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: EMPTY
 270: LIST
 271: LIST
 272: PUSH
 273: LD_INT 3
 275: PUSH
 276: LD_INT 21
 278: PUSH
 279: LD_INT 3
 281: PUSH
 282: EMPTY
 283: LIST
 284: LIST
 285: PUSH
 286: EMPTY
 287: LIST
 288: LIST
 289: PUSH
 290: EMPTY
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL_OW 69
 298: PUSH
 299: FOR_IN
 300: IFFALSE 331
// if GetLives ( i ) < 1000 then
 302: LD_VAR 0 1
 306: PPUSH
 307: CALL_OW 256
 311: PUSH
 312: LD_INT 1000
 314: LESS
 315: IFFALSE 329
// SetLives ( i , 1000 ) ;
 317: LD_VAR 0 1
 321: PPUSH
 322: LD_INT 1000
 324: PPUSH
 325: CALL_OW 234
 329: GO 299
 331: POP
 332: POP
// end ; end_of_file
 333: PPOPN 1
 335: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 336: LD_INT 0
 338: PPUSH
 339: PPUSH
// if exist_mode then
 340: LD_VAR 0 2
 344: IFFALSE 369
// unit := CreateCharacter ( prefix & ident ) else
 346: LD_ADDR_VAR 0 5
 350: PUSH
 351: LD_VAR 0 3
 355: PUSH
 356: LD_VAR 0 1
 360: STR
 361: PPUSH
 362: CALL_OW 34
 366: ST_TO_ADDR
 367: GO 384
// unit := NewCharacter ( ident ) ;
 369: LD_ADDR_VAR 0 5
 373: PUSH
 374: LD_VAR 0 1
 378: PPUSH
 379: CALL_OW 25
 383: ST_TO_ADDR
// result := unit ;
 384: LD_ADDR_VAR 0 4
 388: PUSH
 389: LD_VAR 0 5
 393: ST_TO_ADDR
// end ;
 394: LD_VAR 0 4
 398: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 399: LD_INT 0
 401: PPUSH
// uc_side := side ;
 402: LD_ADDR_OWVAR 20
 406: PUSH
 407: LD_VAR 0 1
 411: ST_TO_ADDR
// uc_nation := nation ;
 412: LD_ADDR_OWVAR 21
 416: PUSH
 417: LD_VAR 0 2
 421: ST_TO_ADDR
// vc_chassis := chassis ;
 422: LD_ADDR_OWVAR 37
 426: PUSH
 427: LD_VAR 0 3
 431: ST_TO_ADDR
// vc_engine := engine ;
 432: LD_ADDR_OWVAR 39
 436: PUSH
 437: LD_VAR 0 4
 441: ST_TO_ADDR
// vc_control := control ;
 442: LD_ADDR_OWVAR 38
 446: PUSH
 447: LD_VAR 0 5
 451: ST_TO_ADDR
// vc_weapon := weapon ;
 452: LD_ADDR_OWVAR 40
 456: PUSH
 457: LD_VAR 0 6
 461: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 462: LD_ADDR_OWVAR 41
 466: PUSH
 467: LD_VAR 0 7
 471: ST_TO_ADDR
// result := CreateVehicle ;
 472: LD_ADDR_VAR 0 8
 476: PUSH
 477: CALL_OW 45
 481: ST_TO_ADDR
// end ;
 482: LD_VAR 0 8
 486: RET
// export function SayX ( units , ident ) ; var i ; begin
 487: LD_INT 0
 489: PPUSH
 490: PPUSH
// result := false ;
 491: LD_ADDR_VAR 0 3
 495: PUSH
 496: LD_INT 0
 498: ST_TO_ADDR
// if not units then
 499: LD_VAR 0 1
 503: NOT
 504: IFFALSE 508
// exit ;
 506: GO 562
// for i in units do
 508: LD_ADDR_VAR 0 4
 512: PUSH
 513: LD_VAR 0 1
 517: PUSH
 518: FOR_IN
 519: IFFALSE 560
// if IsOk ( i ) then
 521: LD_VAR 0 4
 525: PPUSH
 526: CALL_OW 302
 530: IFFALSE 558
// begin Say ( i , ident ) ;
 532: LD_VAR 0 4
 536: PPUSH
 537: LD_VAR 0 2
 541: PPUSH
 542: CALL_OW 88
// result := i ;
 546: LD_ADDR_VAR 0 3
 550: PUSH
 551: LD_VAR 0 4
 555: ST_TO_ADDR
// break ;
 556: GO 560
// end ;
 558: GO 518
 560: POP
 561: POP
// end ;
 562: LD_VAR 0 3
 566: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 567: LD_INT 0
 569: PPUSH
 570: PPUSH
// InitUc ;
 571: CALL_OW 18
// InitHc ;
 575: CALL_OW 19
// uc_side := 0 ;
 579: LD_ADDR_OWVAR 20
 583: PUSH
 584: LD_INT 0
 586: ST_TO_ADDR
// uc_nation := 0 ;
 587: LD_ADDR_OWVAR 21
 591: PUSH
 592: LD_INT 0
 594: ST_TO_ADDR
// for i = 1 to amount do
 595: LD_ADDR_VAR 0 4
 599: PUSH
 600: DOUBLE
 601: LD_INT 1
 603: DEC
 604: ST_TO_ADDR
 605: LD_VAR 0 2
 609: PUSH
 610: FOR_TO
 611: IFFALSE 693
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 613: LD_ADDR_OWVAR 29
 617: PUSH
 618: LD_INT 9
 620: PPUSH
 621: LD_INT 12
 623: PPUSH
 624: CALL_OW 12
 628: PUSH
 629: LD_INT 9
 631: PPUSH
 632: LD_INT 12
 634: PPUSH
 635: CALL_OW 12
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 644: LD_ADDR_OWVAR 35
 648: PUSH
 649: LD_INT 1
 651: NEG
 652: PPUSH
 653: LD_INT 1
 655: PPUSH
 656: CALL_OW 12
 660: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 661: LD_INT 0
 663: PPUSH
 664: LD_INT 12
 666: PPUSH
 667: LD_INT 1
 669: PPUSH
 670: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 674: CALL_OW 44
 678: PPUSH
 679: LD_VAR 0 1
 683: PPUSH
 684: LD_INT 0
 686: PPUSH
 687: CALL_OW 49
// end ;
 691: GO 610
 693: POP
 694: POP
// InitHc ;
 695: CALL_OW 19
// end ;
 699: LD_VAR 0 3
 703: RET
// export function PrepareNature ( forest ) ; var i ; begin
 704: LD_INT 0
 706: PPUSH
 707: PPUSH
// SpawnApeman ( forest , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
 708: LD_VAR 0 1
 712: PPUSH
 713: LD_INT 3
 715: PUSH
 716: LD_INT 3
 718: PUSH
 719: LD_INT 2
 721: PUSH
 722: EMPTY
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_OWVAR 67
 731: ARRAY
 732: PPUSH
 733: CALL 567 0 2
// for i := 1 to 2 do
 737: LD_ADDR_VAR 0 3
 741: PUSH
 742: DOUBLE
 743: LD_INT 1
 745: DEC
 746: ST_TO_ADDR
 747: LD_INT 2
 749: PUSH
 750: FOR_TO
 751: IFFALSE 788
// begin hc_class := 21 ;
 753: LD_ADDR_OWVAR 28
 757: PUSH
 758: LD_INT 21
 760: ST_TO_ADDR
// hc_gallery :=  ;
 761: LD_ADDR_OWVAR 33
 765: PUSH
 766: LD_STRING 
 768: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 769: CALL_OW 44
 773: PPUSH
 774: LD_VAR 0 1
 778: PPUSH
 779: LD_INT 0
 781: PPUSH
 782: CALL_OW 49
// end ;
 786: GO 750
 788: POP
 789: POP
// for i := 1 to 2 do
 790: LD_ADDR_VAR 0 3
 794: PUSH
 795: DOUBLE
 796: LD_INT 1
 798: DEC
 799: ST_TO_ADDR
 800: LD_INT 2
 802: PUSH
 803: FOR_TO
 804: IFFALSE 841
// begin hc_class := 18 ;
 806: LD_ADDR_OWVAR 28
 810: PUSH
 811: LD_INT 18
 813: ST_TO_ADDR
// hc_gallery :=  ;
 814: LD_ADDR_OWVAR 33
 818: PUSH
 819: LD_STRING 
 821: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 822: CALL_OW 44
 826: PPUSH
 827: LD_VAR 0 1
 831: PPUSH
 832: LD_INT 0
 834: PPUSH
 835: CALL_OW 49
// end ;
 839: GO 803
 841: POP
 842: POP
// for i := 1 to 2 do
 843: LD_ADDR_VAR 0 3
 847: PUSH
 848: DOUBLE
 849: LD_INT 1
 851: DEC
 852: ST_TO_ADDR
 853: LD_INT 2
 855: PUSH
 856: FOR_TO
 857: IFFALSE 894
// begin hc_class := 13 ;
 859: LD_ADDR_OWVAR 28
 863: PUSH
 864: LD_INT 13
 866: ST_TO_ADDR
// hc_gallery :=  ;
 867: LD_ADDR_OWVAR 33
 871: PUSH
 872: LD_STRING 
 874: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 875: CALL_OW 44
 879: PPUSH
 880: LD_VAR 0 1
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// end ;
 892: GO 856
 894: POP
 895: POP
// end ;
 896: LD_VAR 0 2
 900: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 901: LD_INT 0
 903: PPUSH
 904: PPUSH
 905: PPUSH
// if not observer or not unit then
 906: LD_VAR 0 1
 910: NOT
 911: PUSH
 912: LD_VAR 0 2
 916: NOT
 917: OR
 918: IFFALSE 922
// exit ;
 920: GO 970
// if not See ( GetSide ( observer ) , unit ) then
 922: LD_VAR 0 1
 926: PPUSH
 927: CALL_OW 255
 931: PPUSH
 932: LD_VAR 0 2
 936: PPUSH
 937: CALL_OW 292
 941: NOT
 942: IFFALSE 946
// exit ;
 944: GO 970
// result := GetDistUnits ( observer , unit ) < 12 ;
 946: LD_ADDR_VAR 0 3
 950: PUSH
 951: LD_VAR 0 1
 955: PPUSH
 956: LD_VAR 0 2
 960: PPUSH
 961: CALL_OW 296
 965: PUSH
 966: LD_INT 12
 968: LESS
 969: ST_TO_ADDR
// end ;
 970: LD_VAR 0 3
 974: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 975: LD_INT 0
 977: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 978: LD_VAR 0 2
 982: PUSH
 983: LD_INT 1
 985: ARRAY
 986: PPUSH
 987: LD_VAR 0 2
 991: PUSH
 992: LD_INT 2
 994: ARRAY
 995: PPUSH
 996: CALL_OW 488
1000: PUSH
1001: LD_VAR 0 2
1005: PUSH
1006: LD_INT 1
1008: ARRAY
1009: PPUSH
1010: LD_VAR 0 2
1014: PUSH
1015: LD_INT 2
1017: ARRAY
1018: PPUSH
1019: CALL_OW 428
1023: PUSH
1024: LD_INT 0
1026: EQUAL
1027: AND
1028: IFFALSE 1062
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
1030: LD_VAR 0 1
1034: PPUSH
1035: LD_VAR 0 2
1039: PUSH
1040: LD_INT 1
1042: ARRAY
1043: PPUSH
1044: LD_VAR 0 2
1048: PUSH
1049: LD_INT 2
1051: ARRAY
1052: PPUSH
1053: LD_VAR 0 3
1057: PPUSH
1058: CALL_OW 48
// end ;
1062: LD_VAR 0 4
1066: RET
// export function Video ( mode ) ; begin
1067: LD_INT 0
1069: PPUSH
// ingame_video = mode ;
1070: LD_ADDR_OWVAR 52
1074: PUSH
1075: LD_VAR 0 1
1079: ST_TO_ADDR
// interface_hidden = mode ;
1080: LD_ADDR_OWVAR 54
1084: PUSH
1085: LD_VAR 0 1
1089: ST_TO_ADDR
// end ;
1090: LD_VAR 0 2
1094: RET
// export function ReverseArray ( array ) ; var i ; begin
1095: LD_INT 0
1097: PPUSH
1098: PPUSH
// if not array then
1099: LD_VAR 0 1
1103: NOT
1104: IFFALSE 1108
// exit ;
1106: GO 1166
// result := [ ] ;
1108: LD_ADDR_VAR 0 2
1112: PUSH
1113: EMPTY
1114: ST_TO_ADDR
// for i := 1 to array do
1115: LD_ADDR_VAR 0 3
1119: PUSH
1120: DOUBLE
1121: LD_INT 1
1123: DEC
1124: ST_TO_ADDR
1125: LD_VAR 0 1
1129: PUSH
1130: FOR_TO
1131: IFFALSE 1164
// result := Insert ( result , 1 , array [ i ] ) ;
1133: LD_ADDR_VAR 0 2
1137: PUSH
1138: LD_VAR 0 2
1142: PPUSH
1143: LD_INT 1
1145: PPUSH
1146: LD_VAR 0 1
1150: PUSH
1151: LD_VAR 0 3
1155: ARRAY
1156: PPUSH
1157: CALL_OW 2
1161: ST_TO_ADDR
1162: GO 1130
1164: POP
1165: POP
// end ;
1166: LD_VAR 0 2
1170: RET
// export function ComExit ( unit ) ; begin
1171: LD_INT 0
1173: PPUSH
// result := IsInUnit ( unit ) ;
1174: LD_ADDR_VAR 0 2
1178: PUSH
1179: LD_VAR 0 1
1183: PPUSH
1184: CALL_OW 310
1188: ST_TO_ADDR
// if not result then
1189: LD_VAR 0 2
1193: NOT
1194: IFFALSE 1198
// exit ;
1196: GO 1233
// if GetType ( result ) = unit_vehicle then
1198: LD_VAR 0 2
1202: PPUSH
1203: CALL_OW 247
1207: PUSH
1208: LD_INT 2
1210: EQUAL
1211: IFFALSE 1224
// ComExitVehicle ( unit ) else
1213: LD_VAR 0 1
1217: PPUSH
1218: CALL_OW 121
1222: GO 1233
// ComExitBuilding ( unit ) ;
1224: LD_VAR 0 1
1228: PPUSH
1229: CALL_OW 122
// end ;
1233: LD_VAR 0 2
1237: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1238: LD_INT 0
1240: PPUSH
1241: PPUSH
// if not side or not nation then
1242: LD_VAR 0 1
1246: NOT
1247: PUSH
1248: LD_VAR 0 2
1252: NOT
1253: OR
1254: IFFALSE 1258
// exit ;
1256: GO 2022
// case nation of nation_american :
1258: LD_VAR 0 2
1262: PUSH
1263: LD_INT 1
1265: DOUBLE
1266: EQUAL
1267: IFTRUE 1271
1269: GO 1485
1271: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1272: LD_ADDR_VAR 0 4
1276: PUSH
1277: LD_INT 35
1279: PUSH
1280: LD_INT 45
1282: PUSH
1283: LD_INT 46
1285: PUSH
1286: LD_INT 47
1288: PUSH
1289: LD_INT 82
1291: PUSH
1292: LD_INT 83
1294: PUSH
1295: LD_INT 84
1297: PUSH
1298: LD_INT 85
1300: PUSH
1301: LD_INT 86
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: LD_INT 2
1309: PUSH
1310: LD_INT 6
1312: PUSH
1313: LD_INT 15
1315: PUSH
1316: LD_INT 16
1318: PUSH
1319: LD_INT 7
1321: PUSH
1322: LD_INT 12
1324: PUSH
1325: LD_INT 13
1327: PUSH
1328: LD_INT 10
1330: PUSH
1331: LD_INT 14
1333: PUSH
1334: LD_INT 20
1336: PUSH
1337: LD_INT 21
1339: PUSH
1340: LD_INT 22
1342: PUSH
1343: LD_INT 25
1345: PUSH
1346: LD_INT 32
1348: PUSH
1349: LD_INT 27
1351: PUSH
1352: LD_INT 36
1354: PUSH
1355: LD_INT 69
1357: PUSH
1358: LD_INT 39
1360: PUSH
1361: LD_INT 34
1363: PUSH
1364: LD_INT 40
1366: PUSH
1367: LD_INT 48
1369: PUSH
1370: LD_INT 49
1372: PUSH
1373: LD_INT 50
1375: PUSH
1376: LD_INT 51
1378: PUSH
1379: LD_INT 52
1381: PUSH
1382: LD_INT 53
1384: PUSH
1385: LD_INT 54
1387: PUSH
1388: LD_INT 55
1390: PUSH
1391: LD_INT 56
1393: PUSH
1394: LD_INT 57
1396: PUSH
1397: LD_INT 58
1399: PUSH
1400: LD_INT 59
1402: PUSH
1403: LD_INT 60
1405: PUSH
1406: LD_INT 61
1408: PUSH
1409: LD_INT 62
1411: PUSH
1412: LD_INT 80
1414: PUSH
1415: LD_INT 82
1417: PUSH
1418: LD_INT 83
1420: PUSH
1421: LD_INT 84
1423: PUSH
1424: LD_INT 85
1426: PUSH
1427: LD_INT 86
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: LIST
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: ST_TO_ADDR
1483: GO 1946
1485: LD_INT 2
1487: DOUBLE
1488: EQUAL
1489: IFTRUE 1493
1491: GO 1715
1493: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_INT 35
1501: PUSH
1502: LD_INT 45
1504: PUSH
1505: LD_INT 46
1507: PUSH
1508: LD_INT 47
1510: PUSH
1511: LD_INT 82
1513: PUSH
1514: LD_INT 83
1516: PUSH
1517: LD_INT 84
1519: PUSH
1520: LD_INT 85
1522: PUSH
1523: LD_INT 87
1525: PUSH
1526: LD_INT 70
1528: PUSH
1529: LD_INT 1
1531: PUSH
1532: LD_INT 11
1534: PUSH
1535: LD_INT 3
1537: PUSH
1538: LD_INT 4
1540: PUSH
1541: LD_INT 5
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: LD_INT 15
1549: PUSH
1550: LD_INT 18
1552: PUSH
1553: LD_INT 7
1555: PUSH
1556: LD_INT 17
1558: PUSH
1559: LD_INT 8
1561: PUSH
1562: LD_INT 20
1564: PUSH
1565: LD_INT 21
1567: PUSH
1568: LD_INT 22
1570: PUSH
1571: LD_INT 72
1573: PUSH
1574: LD_INT 26
1576: PUSH
1577: LD_INT 69
1579: PUSH
1580: LD_INT 39
1582: PUSH
1583: LD_INT 40
1585: PUSH
1586: LD_INT 41
1588: PUSH
1589: LD_INT 42
1591: PUSH
1592: LD_INT 43
1594: PUSH
1595: LD_INT 48
1597: PUSH
1598: LD_INT 49
1600: PUSH
1601: LD_INT 50
1603: PUSH
1604: LD_INT 51
1606: PUSH
1607: LD_INT 52
1609: PUSH
1610: LD_INT 53
1612: PUSH
1613: LD_INT 54
1615: PUSH
1616: LD_INT 55
1618: PUSH
1619: LD_INT 56
1621: PUSH
1622: LD_INT 60
1624: PUSH
1625: LD_INT 61
1627: PUSH
1628: LD_INT 62
1630: PUSH
1631: LD_INT 66
1633: PUSH
1634: LD_INT 67
1636: PUSH
1637: LD_INT 68
1639: PUSH
1640: LD_INT 81
1642: PUSH
1643: LD_INT 82
1645: PUSH
1646: LD_INT 83
1648: PUSH
1649: LD_INT 84
1651: PUSH
1652: LD_INT 85
1654: PUSH
1655: LD_INT 87
1657: PUSH
1658: EMPTY
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: LIST
1697: LIST
1698: LIST
1699: LIST
1700: LIST
1701: LIST
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: LIST
1711: LIST
1712: ST_TO_ADDR
1713: GO 1946
1715: LD_INT 3
1717: DOUBLE
1718: EQUAL
1719: IFTRUE 1723
1721: GO 1945
1723: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1724: LD_ADDR_VAR 0 4
1728: PUSH
1729: LD_INT 46
1731: PUSH
1732: LD_INT 47
1734: PUSH
1735: LD_INT 1
1737: PUSH
1738: LD_INT 2
1740: PUSH
1741: LD_INT 82
1743: PUSH
1744: LD_INT 83
1746: PUSH
1747: LD_INT 84
1749: PUSH
1750: LD_INT 85
1752: PUSH
1753: LD_INT 86
1755: PUSH
1756: LD_INT 11
1758: PUSH
1759: LD_INT 9
1761: PUSH
1762: LD_INT 20
1764: PUSH
1765: LD_INT 19
1767: PUSH
1768: LD_INT 21
1770: PUSH
1771: LD_INT 24
1773: PUSH
1774: LD_INT 22
1776: PUSH
1777: LD_INT 25
1779: PUSH
1780: LD_INT 28
1782: PUSH
1783: LD_INT 29
1785: PUSH
1786: LD_INT 30
1788: PUSH
1789: LD_INT 31
1791: PUSH
1792: LD_INT 37
1794: PUSH
1795: LD_INT 38
1797: PUSH
1798: LD_INT 32
1800: PUSH
1801: LD_INT 27
1803: PUSH
1804: LD_INT 33
1806: PUSH
1807: LD_INT 69
1809: PUSH
1810: LD_INT 39
1812: PUSH
1813: LD_INT 34
1815: PUSH
1816: LD_INT 40
1818: PUSH
1819: LD_INT 71
1821: PUSH
1822: LD_INT 23
1824: PUSH
1825: LD_INT 44
1827: PUSH
1828: LD_INT 48
1830: PUSH
1831: LD_INT 49
1833: PUSH
1834: LD_INT 50
1836: PUSH
1837: LD_INT 51
1839: PUSH
1840: LD_INT 52
1842: PUSH
1843: LD_INT 53
1845: PUSH
1846: LD_INT 54
1848: PUSH
1849: LD_INT 55
1851: PUSH
1852: LD_INT 56
1854: PUSH
1855: LD_INT 57
1857: PUSH
1858: LD_INT 58
1860: PUSH
1861: LD_INT 59
1863: PUSH
1864: LD_INT 63
1866: PUSH
1867: LD_INT 64
1869: PUSH
1870: LD_INT 65
1872: PUSH
1873: LD_INT 82
1875: PUSH
1876: LD_INT 83
1878: PUSH
1879: LD_INT 84
1881: PUSH
1882: LD_INT 85
1884: PUSH
1885: LD_INT 86
1887: PUSH
1888: EMPTY
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: LIST
1911: LIST
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: LIST
1931: LIST
1932: LIST
1933: LIST
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: ST_TO_ADDR
1943: GO 1946
1945: POP
// if state > - 1 and state < 3 then
1946: LD_VAR 0 3
1950: PUSH
1951: LD_INT 1
1953: NEG
1954: GREATER
1955: PUSH
1956: LD_VAR 0 3
1960: PUSH
1961: LD_INT 3
1963: LESS
1964: AND
1965: IFFALSE 2022
// for i in result do
1967: LD_ADDR_VAR 0 5
1971: PUSH
1972: LD_VAR 0 4
1976: PUSH
1977: FOR_IN
1978: IFFALSE 2020
// if GetTech ( i , side ) <> state then
1980: LD_VAR 0 5
1984: PPUSH
1985: LD_VAR 0 1
1989: PPUSH
1990: CALL_OW 321
1994: PUSH
1995: LD_VAR 0 3
1999: NONEQUAL
2000: IFFALSE 2018
// result := result diff i ;
2002: LD_ADDR_VAR 0 4
2006: PUSH
2007: LD_VAR 0 4
2011: PUSH
2012: LD_VAR 0 5
2016: DIFF
2017: ST_TO_ADDR
2018: GO 1977
2020: POP
2021: POP
// end ;
2022: LD_VAR 0 4
2026: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
2027: LD_INT 0
2029: PPUSH
2030: PPUSH
2031: PPUSH
2032: PPUSH
// if not list then
2033: LD_VAR 0 3
2037: NOT
2038: IFFALSE 2042
// exit ;
2040: GO 2350
// result := [ ] ;
2042: LD_ADDR_VAR 0 5
2046: PUSH
2047: EMPTY
2048: ST_TO_ADDR
// for i in list do
2049: LD_ADDR_VAR 0 6
2053: PUSH
2054: LD_VAR 0 3
2058: PUSH
2059: FOR_IN
2060: IFFALSE 2262
// begin tmp := GetDistUnitXY ( i , x , y ) ;
2062: LD_ADDR_VAR 0 8
2066: PUSH
2067: LD_VAR 0 6
2071: PPUSH
2072: LD_VAR 0 1
2076: PPUSH
2077: LD_VAR 0 2
2081: PPUSH
2082: CALL_OW 297
2086: ST_TO_ADDR
// if not result then
2087: LD_VAR 0 5
2091: NOT
2092: IFFALSE 2118
// result := [ [ i , tmp ] ] else
2094: LD_ADDR_VAR 0 5
2098: PUSH
2099: LD_VAR 0 6
2103: PUSH
2104: LD_VAR 0 8
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: EMPTY
2114: LIST
2115: ST_TO_ADDR
2116: GO 2260
// begin if result [ result ] [ 2 ] < tmp then
2118: LD_VAR 0 5
2122: PUSH
2123: LD_VAR 0 5
2127: ARRAY
2128: PUSH
2129: LD_INT 2
2131: ARRAY
2132: PUSH
2133: LD_VAR 0 8
2137: LESS
2138: IFFALSE 2180
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
2140: LD_ADDR_VAR 0 5
2144: PUSH
2145: LD_VAR 0 5
2149: PPUSH
2150: LD_VAR 0 5
2154: PUSH
2155: LD_INT 1
2157: PLUS
2158: PPUSH
2159: LD_VAR 0 6
2163: PUSH
2164: LD_VAR 0 8
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PPUSH
2173: CALL_OW 2
2177: ST_TO_ADDR
2178: GO 2260
// for j = 1 to result do
2180: LD_ADDR_VAR 0 7
2184: PUSH
2185: DOUBLE
2186: LD_INT 1
2188: DEC
2189: ST_TO_ADDR
2190: LD_VAR 0 5
2194: PUSH
2195: FOR_TO
2196: IFFALSE 2258
// begin if tmp < result [ j ] [ 2 ] then
2198: LD_VAR 0 8
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_VAR 0 7
2212: ARRAY
2213: PUSH
2214: LD_INT 2
2216: ARRAY
2217: LESS
2218: IFFALSE 2256
// begin result := Insert ( result , j , [ i , tmp ] ) ;
2220: LD_ADDR_VAR 0 5
2224: PUSH
2225: LD_VAR 0 5
2229: PPUSH
2230: LD_VAR 0 7
2234: PPUSH
2235: LD_VAR 0 6
2239: PUSH
2240: LD_VAR 0 8
2244: PUSH
2245: EMPTY
2246: LIST
2247: LIST
2248: PPUSH
2249: CALL_OW 2
2253: ST_TO_ADDR
// break ;
2254: GO 2258
// end ; end ;
2256: GO 2195
2258: POP
2259: POP
// end ; end ;
2260: GO 2059
2262: POP
2263: POP
// if result and not asc then
2264: LD_VAR 0 5
2268: PUSH
2269: LD_VAR 0 4
2273: NOT
2274: AND
2275: IFFALSE 2350
// begin tmp := result ;
2277: LD_ADDR_VAR 0 8
2281: PUSH
2282: LD_VAR 0 5
2286: ST_TO_ADDR
// for i = tmp downto 1 do
2287: LD_ADDR_VAR 0 6
2291: PUSH
2292: DOUBLE
2293: LD_VAR 0 8
2297: INC
2298: ST_TO_ADDR
2299: LD_INT 1
2301: PUSH
2302: FOR_DOWNTO
2303: IFFALSE 2348
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PPUSH
2315: LD_VAR 0 8
2319: PUSH
2320: LD_VAR 0 6
2324: MINUS
2325: PUSH
2326: LD_INT 1
2328: PLUS
2329: PPUSH
2330: LD_VAR 0 8
2334: PUSH
2335: LD_VAR 0 6
2339: ARRAY
2340: PPUSH
2341: CALL_OW 1
2345: ST_TO_ADDR
2346: GO 2302
2348: POP
2349: POP
// end ; end ;
2350: LD_VAR 0 5
2354: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
2355: LD_INT 0
2357: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
2358: LD_ADDR_VAR 0 4
2362: PUSH
2363: LD_VAR 0 1
2367: PPUSH
2368: CALL_OW 250
2372: PPUSH
2373: LD_VAR 0 1
2377: PPUSH
2378: CALL_OW 251
2382: PPUSH
2383: LD_VAR 0 2
2387: PPUSH
2388: LD_VAR 0 3
2392: PPUSH
2393: CALL 2027 0 4
2397: ST_TO_ADDR
// end ;
2398: LD_VAR 0 4
2402: RET
// export function NearestEmptyBuilding ( unit , btype ) ; var side , tmp , i , places ; begin
2403: LD_INT 0
2405: PPUSH
2406: PPUSH
2407: PPUSH
2408: PPUSH
2409: PPUSH
// if not unit then
2410: LD_VAR 0 1
2414: NOT
2415: IFFALSE 2419
// exit ;
2417: GO 2621
// side := GetSide ( unit ) ;
2419: LD_ADDR_VAR 0 4
2423: PUSH
2424: LD_VAR 0 1
2428: PPUSH
2429: CALL_OW 255
2433: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
2434: LD_ADDR_VAR 0 5
2438: PUSH
2439: LD_INT 22
2441: PUSH
2442: LD_VAR 0 4
2446: PUSH
2447: EMPTY
2448: LIST
2449: LIST
2450: PUSH
2451: LD_INT 30
2453: PUSH
2454: LD_VAR 0 2
2458: PUSH
2459: EMPTY
2460: LIST
2461: LIST
2462: PUSH
2463: EMPTY
2464: LIST
2465: LIST
2466: PPUSH
2467: CALL_OW 69
2471: ST_TO_ADDR
// if not tmp then
2472: LD_VAR 0 5
2476: NOT
2477: IFFALSE 2481
// exit ;
2479: GO 2621
// tmp := SortByDistanceUnit ( unit , tmp , true ) ;
2481: LD_ADDR_VAR 0 5
2485: PUSH
2486: LD_VAR 0 1
2490: PPUSH
2491: LD_VAR 0 5
2495: PPUSH
2496: LD_INT 1
2498: PPUSH
2499: CALL 2355 0 3
2503: ST_TO_ADDR
// places := 1 ;
2504: LD_ADDR_VAR 0 7
2508: PUSH
2509: LD_INT 1
2511: ST_TO_ADDR
// if btype in [ b_depot , b_warehouse , b_armoury , b_barracks , b_workshop , b_factory , b_lab , b_lab_half , b_lab_full ] then
2512: LD_VAR 0 2
2516: PUSH
2517: LD_INT 0
2519: PUSH
2520: LD_INT 1
2522: PUSH
2523: LD_INT 4
2525: PUSH
2526: LD_INT 5
2528: PUSH
2529: LD_INT 2
2531: PUSH
2532: LD_INT 3
2534: PUSH
2535: LD_INT 6
2537: PUSH
2538: LD_INT 7
2540: PUSH
2541: LD_INT 8
2543: PUSH
2544: EMPTY
2545: LIST
2546: LIST
2547: LIST
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: IN
2555: IFFALSE 2565
// places := 6 ;
2557: LD_ADDR_VAR 0 7
2561: PUSH
2562: LD_INT 6
2564: ST_TO_ADDR
// for i in tmp do
2565: LD_ADDR_VAR 0 6
2569: PUSH
2570: LD_VAR 0 5
2574: PUSH
2575: FOR_IN
2576: IFFALSE 2619
// begin if UnitsInside ( i ) - places <= 0 then
2578: LD_VAR 0 6
2582: PPUSH
2583: CALL_OW 313
2587: PUSH
2588: LD_VAR 0 7
2592: MINUS
2593: PUSH
2594: LD_INT 0
2596: LESSEQUAL
2597: IFFALSE 2603
// continue else
2599: GO 2575
2601: GO 2617
// begin result := i ;
2603: LD_ADDR_VAR 0 3
2607: PUSH
2608: LD_VAR 0 6
2612: ST_TO_ADDR
// exit ;
2613: POP
2614: POP
2615: GO 2621
// end ; end ;
2617: GO 2575
2619: POP
2620: POP
// end ; end_of_file
2621: LD_VAR 0 3
2625: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Shariff , Kurt , Aviradze , heikeSecondSquad , heikeVehicles , heikeApes ; export function PrepareArabian ; var i ; begin
2626: LD_INT 0
2628: PPUSH
2629: PPUSH
// uc_side := 2 ;
2630: LD_ADDR_OWVAR 20
2634: PUSH
2635: LD_INT 2
2637: ST_TO_ADDR
// uc_nation := 2 ;
2638: LD_ADDR_OWVAR 21
2642: PUSH
2643: LD_INT 2
2645: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2646: LD_ADDR_EXP 18
2650: PUSH
2651: LD_STRING Heike
2653: PPUSH
2654: LD_EXP 1
2658: NOT
2659: PPUSH
2660: LD_EXP 2
2664: PPUSH
2665: CALL 336 0 3
2669: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
2670: LD_ADDR_EXP 21
2674: PUSH
2675: LD_STRING Ibrahim
2677: PPUSH
2678: LD_EXP 1
2682: NOT
2683: PPUSH
2684: LD_EXP 2
2688: PPUSH
2689: CALL 336 0 3
2693: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2694: LD_ADDR_EXP 19
2698: PUSH
2699: LD_STRING Givi
2701: PPUSH
2702: LD_EXP 1
2706: NOT
2707: PPUSH
2708: LD_EXP 2
2712: PPUSH
2713: CALL 336 0 3
2717: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2718: LD_ADDR_EXP 22
2722: PUSH
2723: LD_STRING Kamil
2725: PPUSH
2726: LD_EXP 1
2730: NOT
2731: PPUSH
2732: LD_EXP 2
2736: PPUSH
2737: CALL 336 0 3
2741: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2742: LD_ADDR_EXP 23
2746: PUSH
2747: LD_STRING Kaia
2749: PPUSH
2750: LD_EXP 1
2754: NOT
2755: PPUSH
2756: LD_EXP 2
2760: PPUSH
2761: CALL 336 0 3
2765: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2766: LD_ADDR_EXP 24
2770: PUSH
2771: LD_STRING Sophia
2773: PPUSH
2774: LD_EXP 1
2778: NOT
2779: PPUSH
2780: LD_EXP 2
2784: PPUSH
2785: CALL 336 0 3
2789: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2790: LD_ADDR_EXP 25
2794: PUSH
2795: LD_STRING Markov
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_EXP 2
2808: PPUSH
2809: CALL 336 0 3
2813: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2814: LD_ADDR_EXP 28
2818: PUSH
2819: LD_STRING Aviradze
2821: PPUSH
2822: LD_EXP 1
2826: NOT
2827: PPUSH
2828: LD_EXP 2
2832: PPUSH
2833: CALL 336 0 3
2837: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , ( not debug ) , prefix ) ;
2838: LD_ADDR_EXP 27
2842: PUSH
2843: LD_STRING Kurt
2845: PPUSH
2846: LD_EXP 1
2850: NOT
2851: PPUSH
2852: LD_EXP 2
2856: PPUSH
2857: CALL 336 0 3
2861: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2862: LD_ADDR_EXP 20
2866: PUSH
2867: LD_STRING Mike
2869: PPUSH
2870: LD_EXP 1
2874: NOT
2875: PPUSH
2876: LD_EXP 2
2880: PPUSH
2881: CALL 336 0 3
2885: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_1_others ) ;
2886: LD_ADDR_EXP 29
2890: PUSH
2891: LD_STRING 04_1_others
2893: PPUSH
2894: CALL_OW 31
2898: ST_TO_ADDR
// heikeApes := CreateCharacterSet ( 04_1_apes ) ;
2899: LD_ADDR_EXP 31
2903: PUSH
2904: LD_STRING 04_1_apes
2906: PPUSH
2907: CALL_OW 31
2911: ST_TO_ADDR
// heikeVehicles := LoadVariable ( 04_1_Vehicles , [ ] ) ;
2912: LD_ADDR_EXP 30
2916: PUSH
2917: LD_STRING 04_1_Vehicles
2919: PPUSH
2920: EMPTY
2921: PPUSH
2922: CALL_OW 30
2926: ST_TO_ADDR
// uc_side := 5 ;
2927: LD_ADDR_OWVAR 20
2931: PUSH
2932: LD_INT 5
2934: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
2935: LD_ADDR_EXP 26
2939: PUSH
2940: LD_STRING Abdul
2942: PPUSH
2943: LD_INT 0
2945: PPUSH
2946: LD_STRING 
2948: PPUSH
2949: CALL 336 0 3
2953: ST_TO_ADDR
// end ;
2954: LD_VAR 0 1
2958: RET
// export cargoDriver ; every 2 2$00 trigger LoadVariable ( 04_1_KaganCaptured , 0 ) and HexInfo ( 124 , 26 ) = 0 xor GetSide ( HexInfo ( 124 , 26 ) ) = 2 do var veh ;
2959: LD_STRING 04_1_KaganCaptured
2961: PPUSH
2962: LD_INT 0
2964: PPUSH
2965: CALL_OW 30
2969: PUSH
2970: LD_INT 124
2972: PPUSH
2973: LD_INT 26
2975: PPUSH
2976: CALL_OW 428
2980: PUSH
2981: LD_INT 0
2983: EQUAL
2984: AND
2985: PUSH
2986: LD_INT 124
2988: PPUSH
2989: LD_INT 26
2991: PPUSH
2992: CALL_OW 428
2996: PPUSH
2997: CALL_OW 255
3001: PUSH
3002: LD_INT 2
3004: EQUAL
3005: XOR
3006: IFFALSE 3254
3008: GO 3010
3010: DISABLE
3011: LD_INT 0
3013: PPUSH
// begin enable ;
3014: ENABLE
// uc_side := 5 ;
3015: LD_ADDR_OWVAR 20
3019: PUSH
3020: LD_INT 5
3022: ST_TO_ADDR
// uc_nation := 2 ;
3023: LD_ADDR_OWVAR 21
3027: PUSH
3028: LD_INT 2
3030: ST_TO_ADDR
// PrepareTank ( 5 , 2 , ar_medium_trike , engine_solar , control_manual , ar_cargo_bay , 70 ) ;
3031: LD_INT 5
3033: PPUSH
3034: LD_INT 2
3036: PPUSH
3037: LD_INT 13
3039: PPUSH
3040: LD_INT 2
3042: PPUSH
3043: LD_INT 1
3045: PPUSH
3046: LD_INT 32
3048: PPUSH
3049: LD_INT 70
3051: PPUSH
3052: CALL 399 0 7
// veh := CreateVehicle ;
3056: LD_ADDR_VAR 0 1
3060: PUSH
3061: CALL_OW 45
3065: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3066: LD_VAR 0 1
3070: PPUSH
3071: LD_INT 3
3073: PPUSH
3074: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
3078: LD_VAR 0 1
3082: PPUSH
3083: LD_INT 8
3085: PPUSH
3086: LD_INT 0
3088: PPUSH
3089: CALL_OW 49
// if not cargoDriver then
3093: LD_EXP 32
3097: NOT
3098: IFFALSE 3123
// begin PrepareHuman ( false , 1 , 3 ) ;
3100: LD_INT 0
3102: PPUSH
3103: LD_INT 1
3105: PPUSH
3106: LD_INT 3
3108: PPUSH
3109: CALL_OW 380
// cargoDriver := CreateHuman ;
3113: LD_ADDR_EXP 32
3117: PUSH
3118: CALL_OW 44
3122: ST_TO_ADDR
// end ; PlaceHumanInUnit ( cargoDriver , veh ) ;
3123: LD_EXP 32
3127: PPUSH
3128: LD_VAR 0 1
3132: PPUSH
3133: CALL_OW 52
// SetCargo ( veh , mat_oil , 100 ) ;
3137: LD_VAR 0 1
3141: PPUSH
3142: LD_INT 2
3144: PPUSH
3145: LD_INT 100
3147: PPUSH
3148: CALL_OW 290
// ComMoveXY ( veh , 142 , 15 ) ;
3152: LD_VAR 0 1
3156: PPUSH
3157: LD_INT 142
3159: PPUSH
3160: LD_INT 15
3162: PPUSH
3163: CALL_OW 111
// AddComUnload ( veh ) ;
3167: LD_VAR 0 1
3171: PPUSH
3172: CALL_OW 219
// AddComMoveXY ( veh , 133 , 2 ) ;
3176: LD_VAR 0 1
3180: PPUSH
3181: LD_INT 133
3183: PPUSH
3184: LD_INT 2
3186: PPUSH
3187: CALL_OW 171
// wait ( 0 0$5 ) ;
3191: LD_INT 175
3193: PPUSH
3194: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
3198: LD_INT 35
3200: PPUSH
3201: CALL_OW 67
// until IsAt ( veh , 133 , 2 ) or IsInArea ( veh , spawnArea ) ;
3205: LD_VAR 0 1
3209: PPUSH
3210: LD_INT 133
3212: PPUSH
3213: LD_INT 2
3215: PPUSH
3216: CALL_OW 307
3220: PUSH
3221: LD_VAR 0 1
3225: PPUSH
3226: LD_INT 8
3228: PPUSH
3229: CALL_OW 308
3233: OR
3234: IFFALSE 3198
// RemoveUnit ( cargoDriver ) ;
3236: LD_EXP 32
3240: PPUSH
3241: CALL_OW 64
// RemoveUnit ( veh ) ;
3245: LD_VAR 0 1
3249: PPUSH
3250: CALL_OW 64
// end ; end_of_file
3254: PPOPN 1
3256: END
// export Burlak , Gaidar , Kuzmov ; export ruForce , ruEng , ruMech , ruSci , ruMobile ; export ruSol ; export function PrepareRussian ; var base , blist , i , b , un , tmp , fac , oil ; begin
3257: LD_INT 0
3259: PPUSH
3260: PPUSH
3261: PPUSH
3262: PPUSH
3263: PPUSH
3264: PPUSH
3265: PPUSH
3266: PPUSH
3267: PPUSH
// uc_side := 3 ;
3268: LD_ADDR_OWVAR 20
3272: PUSH
3273: LD_INT 3
3275: ST_TO_ADDR
// uc_nation := 3 ;
3276: LD_ADDR_OWVAR 21
3280: PUSH
3281: LD_INT 3
3283: ST_TO_ADDR
// ruForce := [ ] ;
3284: LD_ADDR_EXP 36
3288: PUSH
3289: EMPTY
3290: ST_TO_ADDR
// ruMech := [ ] ;
3291: LD_ADDR_EXP 38
3295: PUSH
3296: EMPTY
3297: ST_TO_ADDR
// ruEng := [ ] ;
3298: LD_ADDR_EXP 37
3302: PUSH
3303: EMPTY
3304: ST_TO_ADDR
// ruSci := [ ] ;
3305: LD_ADDR_EXP 39
3309: PUSH
3310: EMPTY
3311: ST_TO_ADDR
// ruMobile := [ ] ;
3312: LD_ADDR_EXP 40
3316: PUSH
3317: EMPTY
3318: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ,  ) ;
3319: LD_ADDR_EXP 33
3323: PUSH
3324: LD_STRING Burlak
3326: PPUSH
3327: LD_INT 0
3329: PPUSH
3330: LD_STRING 
3332: PPUSH
3333: CALL 336 0 3
3337: ST_TO_ADDR
// Gaidar := PrepareUnit ( Gaydar , false ,  ) ;
3338: LD_ADDR_EXP 34
3342: PUSH
3343: LD_STRING Gaydar
3345: PPUSH
3346: LD_INT 0
3348: PPUSH
3349: LD_STRING 
3351: PPUSH
3352: CALL 336 0 3
3356: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , false ,  ) ;
3357: LD_ADDR_EXP 35
3361: PUSH
3362: LD_STRING Kuzmov
3364: PPUSH
3365: LD_INT 0
3367: PPUSH
3368: LD_STRING 
3370: PPUSH
3371: CALL 336 0 3
3375: ST_TO_ADDR
// PlaceHumanInUnit ( Kuzmov , ruMainBase ) ;
3376: LD_EXP 35
3380: PPUSH
3381: LD_INT 200
3383: PPUSH
3384: CALL_OW 52
// SetBName ( ruMainBase , chuikov ) ;
3388: LD_INT 200
3390: PPUSH
3391: LD_STRING chuikov
3393: PPUSH
3394: CALL_OW 500
// SetResourceType ( GetBase ( ruMainBase ) , mat_cans , [ 800 , 1000 , 1250 ] [ Difficulty ] ) ;
3398: LD_INT 200
3400: PPUSH
3401: CALL_OW 274
3405: PPUSH
3406: LD_INT 1
3408: PPUSH
3409: LD_INT 800
3411: PUSH
3412: LD_INT 1000
3414: PUSH
3415: LD_INT 1250
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: LIST
3422: PUSH
3423: LD_OWVAR 67
3427: ARRAY
3428: PPUSH
3429: CALL_OW 277
// SetResourceType ( GetBase ( ruMainBase ) , mat_oil , 160 ) ;
3433: LD_INT 200
3435: PPUSH
3436: CALL_OW 274
3440: PPUSH
3441: LD_INT 2
3443: PPUSH
3444: LD_INT 160
3446: PPUSH
3447: CALL_OW 277
// SetResourceType ( GetBase ( ruSecBase ) , mat_cans , 200 ) ;
3451: LD_INT 225
3453: PPUSH
3454: CALL_OW 274
3458: PPUSH
3459: LD_INT 1
3461: PPUSH
3462: LD_INT 200
3464: PPUSH
3465: CALL_OW 277
// oil := 150 ;
3469: LD_ADDR_VAR 0 9
3473: PUSH
3474: LD_INT 150
3476: ST_TO_ADDR
// if gameTime >= [ 45 45$00 , 40 40$00 , 35 35$00 ] [ Difficulty ] then
3477: LD_EXP 5
3481: PUSH
3482: LD_INT 94500
3484: PUSH
3485: LD_INT 84000
3487: PUSH
3488: LD_INT 73500
3490: PUSH
3491: EMPTY
3492: LIST
3493: LIST
3494: LIST
3495: PUSH
3496: LD_OWVAR 67
3500: ARRAY
3501: GREATEREQUAL
3502: IFFALSE 3657
// begin oil := 450 ;
3504: LD_ADDR_VAR 0 9
3508: PUSH
3509: LD_INT 450
3511: ST_TO_ADDR
// tmp := [ [ 123 , 17 , 3 , b_breastwork ] , [ 152 , 38 , 3 , b_breastwork ] , [ 81 , 6 , 4 , b_breastwork ] , [ 113 , 67 , 4 , b_bunker ] ] ;
3512: LD_ADDR_VAR 0 7
3516: PUSH
3517: LD_INT 123
3519: PUSH
3520: LD_INT 17
3522: PUSH
3523: LD_INT 3
3525: PUSH
3526: LD_INT 31
3528: PUSH
3529: EMPTY
3530: LIST
3531: LIST
3532: LIST
3533: LIST
3534: PUSH
3535: LD_INT 152
3537: PUSH
3538: LD_INT 38
3540: PUSH
3541: LD_INT 3
3543: PUSH
3544: LD_INT 31
3546: PUSH
3547: EMPTY
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: PUSH
3553: LD_INT 81
3555: PUSH
3556: LD_INT 6
3558: PUSH
3559: LD_INT 4
3561: PUSH
3562: LD_INT 31
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: LIST
3569: LIST
3570: PUSH
3571: LD_INT 113
3573: PUSH
3574: LD_INT 67
3576: PUSH
3577: LD_INT 4
3579: PUSH
3580: LD_INT 32
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: ST_TO_ADDR
// for i in tmp do
3595: LD_ADDR_VAR 0 4
3599: PUSH
3600: LD_VAR 0 7
3604: PUSH
3605: FOR_IN
3606: IFFALSE 3655
// begin bc_type := i [ 4 ] ;
3608: LD_ADDR_OWVAR 42
3612: PUSH
3613: LD_VAR 0 4
3617: PUSH
3618: LD_INT 4
3620: ARRAY
3621: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3622: LD_VAR 0 4
3626: PUSH
3627: LD_INT 1
3629: ARRAY
3630: PPUSH
3631: LD_VAR 0 4
3635: PUSH
3636: LD_INT 2
3638: ARRAY
3639: PPUSH
3640: LD_VAR 0 4
3644: PUSH
3645: LD_INT 3
3647: ARRAY
3648: PPUSH
3649: CALL_OW 47
// end ;
3653: GO 3605
3655: POP
3656: POP
// end ; SetResourceType ( GetBase ( ruSecBase ) , mat_oil , oil ) ;
3657: LD_INT 225
3659: PPUSH
3660: CALL_OW 274
3664: PPUSH
3665: LD_INT 2
3667: PPUSH
3668: LD_VAR 0 9
3672: PPUSH
3673: CALL_OW 277
// if Difficulty > 1 then
3677: LD_OWVAR 67
3681: PUSH
3682: LD_INT 1
3684: GREATER
3685: IFFALSE 3780
// begin bc_type := b_bunker ;
3687: LD_ADDR_OWVAR 42
3691: PUSH
3692: LD_INT 32
3694: ST_TO_ADDR
// tmp := [ [ 121 , 85 , 5 ] , [ 93 , 72 , 1 ] ] ;
3695: LD_ADDR_VAR 0 7
3699: PUSH
3700: LD_INT 121
3702: PUSH
3703: LD_INT 85
3705: PUSH
3706: LD_INT 5
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: LIST
3713: PUSH
3714: LD_INT 93
3716: PUSH
3717: LD_INT 72
3719: PUSH
3720: LD_INT 1
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: LIST
3727: PUSH
3728: EMPTY
3729: LIST
3730: LIST
3731: ST_TO_ADDR
// for i in tmp do
3732: LD_ADDR_VAR 0 4
3736: PUSH
3737: LD_VAR 0 7
3741: PUSH
3742: FOR_IN
3743: IFFALSE 3778
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3745: LD_VAR 0 4
3749: PUSH
3750: LD_INT 1
3752: ARRAY
3753: PPUSH
3754: LD_VAR 0 4
3758: PUSH
3759: LD_INT 2
3761: ARRAY
3762: PPUSH
3763: LD_VAR 0 4
3767: PUSH
3768: LD_INT 3
3770: ARRAY
3771: PPUSH
3772: CALL_OW 47
3776: GO 3742
3778: POP
3779: POP
// end ; base := GetBase ( ruMainBase ) ;
3780: LD_ADDR_VAR 0 2
3784: PUSH
3785: LD_INT 200
3787: PPUSH
3788: CALL_OW 274
3792: ST_TO_ADDR
// blist := GetBuildList ( base ) ;
3793: LD_ADDR_VAR 0 3
3797: PUSH
3798: LD_VAR 0 2
3802: PPUSH
3803: CALL_OW 417
3807: ST_TO_ADDR
// for b in blist do
3808: LD_ADDR_VAR 0 5
3812: PUSH
3813: LD_VAR 0 3
3817: PUSH
3818: FOR_IN
3819: IFFALSE 4222
// begin if b [ 1 ] = b_factory then
3821: LD_VAR 0 5
3825: PUSH
3826: LD_INT 1
3828: ARRAY
3829: PUSH
3830: LD_INT 3
3832: EQUAL
3833: IFFALSE 3963
// begin fac := HexInfo ( b [ 2 ] , b [ 3 ] ) ;
3835: LD_ADDR_VAR 0 8
3839: PUSH
3840: LD_VAR 0 5
3844: PUSH
3845: LD_INT 2
3847: ARRAY
3848: PPUSH
3849: LD_VAR 0 5
3853: PUSH
3854: LD_INT 3
3856: ARRAY
3857: PPUSH
3858: CALL_OW 428
3862: ST_TO_ADDR
// for i := 1 to 2 + Difficulty do
3863: LD_ADDR_VAR 0 4
3867: PUSH
3868: DOUBLE
3869: LD_INT 1
3871: DEC
3872: ST_TO_ADDR
3873: LD_INT 2
3875: PUSH
3876: LD_OWVAR 67
3880: PLUS
3881: PUSH
3882: FOR_TO
3883: IFFALSE 3959
// begin PrepareHuman ( false , 3 , 1 + Difficulty ) ;
3885: LD_INT 0
3887: PPUSH
3888: LD_INT 3
3890: PPUSH
3891: LD_INT 1
3893: PUSH
3894: LD_OWVAR 67
3898: PLUS
3899: PPUSH
3900: CALL_OW 380
// un := CreateHuman ;
3904: LD_ADDR_VAR 0 6
3908: PUSH
3909: CALL_OW 44
3913: ST_TO_ADDR
// ruMech := Replace ( ruMech , ruMech + 1 , un ) ;
3914: LD_ADDR_EXP 38
3918: PUSH
3919: LD_EXP 38
3923: PPUSH
3924: LD_EXP 38
3928: PUSH
3929: LD_INT 1
3931: PLUS
3932: PPUSH
3933: LD_VAR 0 6
3937: PPUSH
3938: CALL_OW 1
3942: ST_TO_ADDR
// PlaceHumanInUnit ( un , fac ) ;
3943: LD_VAR 0 6
3947: PPUSH
3948: LD_VAR 0 8
3952: PPUSH
3953: CALL_OW 52
// end ;
3957: GO 3882
3959: POP
3960: POP
// end else
3961: GO 4220
// if b [ 1 ] in [ b_lab , b_lab_half , b_lab_full , b_lab_weapon ] then
3963: LD_VAR 0 5
3967: PUSH
3968: LD_INT 1
3970: ARRAY
3971: PUSH
3972: LD_INT 6
3974: PUSH
3975: LD_INT 7
3977: PUSH
3978: LD_INT 8
3980: PUSH
3981: LD_INT 10
3983: PUSH
3984: EMPTY
3985: LIST
3986: LIST
3987: LIST
3988: LIST
3989: IN
3990: IFFALSE 4100
// begin for i := 1 to 2 do
3992: LD_ADDR_VAR 0 4
3996: PUSH
3997: DOUBLE
3998: LD_INT 1
4000: DEC
4001: ST_TO_ADDR
4002: LD_INT 2
4004: PUSH
4005: FOR_TO
4006: IFFALSE 4096
// begin PrepareHuman ( false , 4 , Difficulty ) ;
4008: LD_INT 0
4010: PPUSH
4011: LD_INT 4
4013: PPUSH
4014: LD_OWVAR 67
4018: PPUSH
4019: CALL_OW 380
// un := CreateHuman ;
4023: LD_ADDR_VAR 0 6
4027: PUSH
4028: CALL_OW 44
4032: ST_TO_ADDR
// ruSci := Replace ( ruSci , ruSci + 1 , un ) ;
4033: LD_ADDR_EXP 39
4037: PUSH
4038: LD_EXP 39
4042: PPUSH
4043: LD_EXP 39
4047: PUSH
4048: LD_INT 1
4050: PLUS
4051: PPUSH
4052: LD_VAR 0 6
4056: PPUSH
4057: CALL_OW 1
4061: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4062: LD_VAR 0 6
4066: PPUSH
4067: LD_VAR 0 5
4071: PUSH
4072: LD_INT 2
4074: ARRAY
4075: PPUSH
4076: LD_VAR 0 5
4080: PUSH
4081: LD_INT 3
4083: ARRAY
4084: PPUSH
4085: CALL_OW 428
4089: PPUSH
4090: CALL_OW 52
// end ;
4094: GO 4005
4096: POP
4097: POP
// end else
4098: GO 4220
// if b [ 1 ] = b_warehouse then
4100: LD_VAR 0 5
4104: PUSH
4105: LD_INT 1
4107: ARRAY
4108: PUSH
4109: LD_INT 1
4111: EQUAL
4112: IFFALSE 4220
// begin for i := 1 to 3 do
4114: LD_ADDR_VAR 0 4
4118: PUSH
4119: DOUBLE
4120: LD_INT 1
4122: DEC
4123: ST_TO_ADDR
4124: LD_INT 3
4126: PUSH
4127: FOR_TO
4128: IFFALSE 4218
// begin PrepareHuman ( false , 2 , Difficulty ) ;
4130: LD_INT 0
4132: PPUSH
4133: LD_INT 2
4135: PPUSH
4136: LD_OWVAR 67
4140: PPUSH
4141: CALL_OW 380
// un := CreateHuman ;
4145: LD_ADDR_VAR 0 6
4149: PUSH
4150: CALL_OW 44
4154: ST_TO_ADDR
// ruEng := Replace ( ruEng , ruEng + 1 , un ) ;
4155: LD_ADDR_EXP 37
4159: PUSH
4160: LD_EXP 37
4164: PPUSH
4165: LD_EXP 37
4169: PUSH
4170: LD_INT 1
4172: PLUS
4173: PPUSH
4174: LD_VAR 0 6
4178: PPUSH
4179: CALL_OW 1
4183: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4184: LD_VAR 0 6
4188: PPUSH
4189: LD_VAR 0 5
4193: PUSH
4194: LD_INT 2
4196: ARRAY
4197: PPUSH
4198: LD_VAR 0 5
4202: PUSH
4203: LD_INT 3
4205: ARRAY
4206: PPUSH
4207: CALL_OW 428
4211: PPUSH
4212: CALL_OW 52
// end ;
4216: GO 4127
4218: POP
4219: POP
// end ; end ;
4220: GO 3818
4222: POP
4223: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4224: LD_ADDR_VAR 0 3
4228: PUSH
4229: LD_INT 22
4231: PUSH
4232: LD_INT 3
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 21
4241: PUSH
4242: LD_INT 3
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: EMPTY
4250: LIST
4251: LIST
4252: PPUSH
4253: CALL_OW 69
4257: ST_TO_ADDR
// for b in blist do
4258: LD_ADDR_VAR 0 5
4262: PUSH
4263: LD_VAR 0 3
4267: PUSH
4268: FOR_IN
4269: IFFALSE 4291
// SetBLevel ( b , 3 + Difficulty ) ;
4271: LD_VAR 0 5
4275: PPUSH
4276: LD_INT 3
4278: PUSH
4279: LD_OWVAR 67
4283: PLUS
4284: PPUSH
4285: CALL_OW 241
4289: GO 4268
4291: POP
4292: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4293: LD_ADDR_VAR 0 3
4297: PUSH
4298: LD_INT 22
4300: PUSH
4301: LD_INT 3
4303: PUSH
4304: EMPTY
4305: LIST
4306: LIST
4307: PUSH
4308: LD_INT 30
4310: PUSH
4311: LD_INT 32
4313: PUSH
4314: EMPTY
4315: LIST
4316: LIST
4317: PUSH
4318: EMPTY
4319: LIST
4320: LIST
4321: PPUSH
4322: CALL_OW 69
4326: ST_TO_ADDR
// for b in blist do
4327: LD_ADDR_VAR 0 5
4331: PUSH
4332: LD_VAR 0 3
4336: PUSH
4337: FOR_IN
4338: IFFALSE 4447
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4340: LD_INT 0
4342: PPUSH
4343: LD_INT 1
4345: PPUSH
4346: LD_INT 1
4348: PUSH
4349: LD_OWVAR 67
4353: PLUS
4354: PPUSH
4355: CALL_OW 380
// un := CreateHuman ;
4359: LD_ADDR_VAR 0 6
4363: PUSH
4364: CALL_OW 44
4368: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4369: LD_ADDR_EXP 36
4373: PUSH
4374: LD_EXP 36
4378: PPUSH
4379: LD_EXP 36
4383: PUSH
4384: LD_INT 1
4386: PLUS
4387: PPUSH
4388: LD_VAR 0 6
4392: PPUSH
4393: CALL_OW 1
4397: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4398: LD_VAR 0 6
4402: PPUSH
4403: LD_VAR 0 5
4407: PPUSH
4408: CALL_OW 52
// PlaceWeaponTurret ( b , [ ru_gun , ru_gatling_gun ] [ b mod 2 + 1 ] ) ;
4412: LD_VAR 0 5
4416: PPUSH
4417: LD_INT 44
4419: PUSH
4420: LD_INT 43
4422: PUSH
4423: EMPTY
4424: LIST
4425: LIST
4426: PUSH
4427: LD_VAR 0 5
4431: PUSH
4432: LD_INT 2
4434: MOD
4435: PUSH
4436: LD_INT 1
4438: PLUS
4439: ARRAY
4440: PPUSH
4441: CALL_OW 431
// end ;
4445: GO 4337
4447: POP
4448: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4449: LD_ADDR_VAR 0 3
4453: PUSH
4454: LD_INT 22
4456: PUSH
4457: LD_INT 3
4459: PUSH
4460: EMPTY
4461: LIST
4462: LIST
4463: PUSH
4464: LD_INT 30
4466: PUSH
4467: LD_INT 31
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: PPUSH
4478: CALL_OW 69
4482: ST_TO_ADDR
// for b in blist do
4483: LD_ADDR_VAR 0 5
4487: PUSH
4488: LD_VAR 0 3
4492: PUSH
4493: FOR_IN
4494: IFFALSE 4593
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4496: LD_INT 0
4498: PPUSH
4499: LD_INT 1
4501: PPUSH
4502: LD_INT 1
4504: PUSH
4505: LD_OWVAR 67
4509: PLUS
4510: PPUSH
4511: CALL_OW 380
// un := CreateHuman ;
4515: LD_ADDR_VAR 0 6
4519: PUSH
4520: CALL_OW 44
4524: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4525: LD_ADDR_EXP 36
4529: PUSH
4530: LD_EXP 36
4534: PPUSH
4535: LD_EXP 36
4539: PUSH
4540: LD_INT 1
4542: PLUS
4543: PPUSH
4544: LD_VAR 0 6
4548: PPUSH
4549: CALL_OW 1
4553: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) + 3 ) ;
4554: LD_VAR 0 6
4558: PPUSH
4559: LD_VAR 0 5
4563: PPUSH
4564: CALL_OW 254
4568: PUSH
4569: LD_INT 3
4571: PLUS
4572: PPUSH
4573: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4577: LD_VAR 0 6
4581: PPUSH
4582: LD_VAR 0 5
4586: PPUSH
4587: CALL_OW 52
// end ;
4591: GO 4493
4593: POP
4594: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4595: LD_ADDR_VAR 0 3
4599: PUSH
4600: LD_INT 22
4602: PUSH
4603: LD_INT 3
4605: PUSH
4606: EMPTY
4607: LIST
4608: LIST
4609: PUSH
4610: LD_INT 2
4612: PUSH
4613: LD_INT 30
4615: PUSH
4616: LD_INT 4
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PUSH
4623: LD_INT 30
4625: PUSH
4626: LD_INT 5
4628: PUSH
4629: EMPTY
4630: LIST
4631: LIST
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: LIST
4637: PUSH
4638: EMPTY
4639: LIST
4640: LIST
4641: PPUSH
4642: CALL_OW 69
4646: ST_TO_ADDR
// for b in blist do
4647: LD_ADDR_VAR 0 5
4651: PUSH
4652: LD_VAR 0 3
4656: PUSH
4657: FOR_IN
4658: IFFALSE 4754
// begin for i := 1 to 2 do
4660: LD_ADDR_VAR 0 4
4664: PUSH
4665: DOUBLE
4666: LD_INT 1
4668: DEC
4669: ST_TO_ADDR
4670: LD_INT 2
4672: PUSH
4673: FOR_TO
4674: IFFALSE 4750
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4676: LD_INT 0
4678: PPUSH
4679: LD_INT 1
4681: PPUSH
4682: LD_INT 1
4684: PUSH
4685: LD_OWVAR 67
4689: PLUS
4690: PPUSH
4691: CALL_OW 380
// un := CreateHuman ;
4695: LD_ADDR_VAR 0 6
4699: PUSH
4700: CALL_OW 44
4704: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4705: LD_ADDR_EXP 36
4709: PUSH
4710: LD_EXP 36
4714: PPUSH
4715: LD_EXP 36
4719: PUSH
4720: LD_INT 1
4722: PLUS
4723: PPUSH
4724: LD_VAR 0 6
4728: PPUSH
4729: CALL_OW 1
4733: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4734: LD_VAR 0 6
4738: PPUSH
4739: LD_VAR 0 5
4743: PPUSH
4744: CALL_OW 52
// end ;
4748: GO 4673
4750: POP
4751: POP
// end ;
4752: GO 4657
4754: POP
4755: POP
// if ibrahimOnRuSide then
4756: LD_EXP 3
4760: IFFALSE 4858
// begin Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
4762: LD_ADDR_EXP 21
4766: PUSH
4767: LD_STRING IbrahimRu
4769: PPUSH
4770: LD_INT 0
4772: PPUSH
4773: LD_STRING 
4775: PPUSH
4776: CALL 336 0 3
4780: ST_TO_ADDR
// PlaceUnitXY ( Ibrahim , 121 , 78 , false ) ;
4781: LD_EXP 21
4785: PPUSH
4786: LD_INT 121
4788: PPUSH
4789: LD_INT 78
4791: PPUSH
4792: LD_INT 0
4794: PPUSH
4795: CALL_OW 48
// ComHold ( Ibrahim ) ;
4799: LD_EXP 21
4803: PPUSH
4804: CALL_OW 140
// PrepareHuman ( sex_male , 1 , 2 ) ;
4808: LD_INT 1
4810: PPUSH
4811: LD_INT 1
4813: PPUSH
4814: LD_INT 2
4816: PPUSH
4817: CALL_OW 380
// ruSol := CreateHuman ;
4821: LD_ADDR_EXP 41
4825: PUSH
4826: CALL_OW 44
4830: ST_TO_ADDR
// PlaceUnitXY ( ruSol , 121 , 75 , false ) ;
4831: LD_EXP 41
4835: PPUSH
4836: LD_INT 121
4838: PPUSH
4839: LD_INT 75
4841: PPUSH
4842: LD_INT 0
4844: PPUSH
4845: CALL_OW 48
// ComHold ( ruSol ) ;
4849: LD_EXP 41
4853: PPUSH
4854: CALL_OW 140
// end ; for i := 1 to 2 + Difficulty do
4858: LD_ADDR_VAR 0 4
4862: PUSH
4863: DOUBLE
4864: LD_INT 1
4866: DEC
4867: ST_TO_ADDR
4868: LD_INT 2
4870: PUSH
4871: LD_OWVAR 67
4875: PLUS
4876: PUSH
4877: FOR_TO
4878: IFFALSE 4947
// AddComConstruct ( fac , [ ru_medium_wheeled , ru_heavy_wheeled , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] ) ;
4880: LD_VAR 0 8
4884: PPUSH
4885: LD_INT 21
4887: PUSH
4888: LD_INT 23
4890: PUSH
4891: LD_INT 24
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: LIST
4898: PUSH
4899: LD_VAR 0 4
4903: PUSH
4904: LD_INT 3
4906: MOD
4907: PUSH
4908: LD_INT 1
4910: PLUS
4911: ARRAY
4912: PPUSH
4913: LD_INT 1
4915: PPUSH
4916: LD_INT 1
4918: PPUSH
4919: LD_INT 43
4921: PUSH
4922: LD_INT 44
4924: PUSH
4925: EMPTY
4926: LIST
4927: LIST
4928: PUSH
4929: LD_INT 1
4931: PPUSH
4932: LD_INT 2
4934: PPUSH
4935: CALL_OW 12
4939: ARRAY
4940: PPUSH
4941: CALL_OW 185
4945: GO 4877
4947: POP
4948: POP
// end ;
4949: LD_VAR 0 1
4953: RET
// every 0 0$1 trigger ruMobile and not ruEscapeAllowed do var i , filter , tmp , enemy , x ;
4954: LD_EXP 40
4958: PUSH
4959: LD_EXP 4
4963: NOT
4964: AND
4965: IFFALSE 5452
4967: GO 4969
4969: DISABLE
4970: LD_INT 0
4972: PPUSH
4973: PPUSH
4974: PPUSH
4975: PPUSH
4976: PPUSH
// begin enable ;
4977: ENABLE
// filter := UnitFilter ( ruMobile , [ f_type , unit_vehicle ] ) ;
4978: LD_ADDR_VAR 0 2
4982: PUSH
4983: LD_EXP 40
4987: PPUSH
4988: LD_INT 21
4990: PUSH
4991: LD_INT 2
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PPUSH
4998: CALL_OW 72
5002: ST_TO_ADDR
// enemy := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_or , [ f_inarea , zone1 ] , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) ;
5003: LD_ADDR_VAR 0 4
5007: PUSH
5008: LD_INT 81
5010: PUSH
5011: LD_INT 3
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: PUSH
5018: LD_INT 2
5020: PUSH
5021: LD_INT 95
5023: PUSH
5024: LD_INT 4
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: LD_INT 95
5033: PUSH
5034: LD_INT 5
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 95
5043: PUSH
5044: LD_INT 6
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: PUSH
5051: LD_INT 95
5053: PUSH
5054: LD_INT 7
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: LIST
5065: LIST
5066: LIST
5067: PUSH
5068: EMPTY
5069: LIST
5070: LIST
5071: PPUSH
5072: CALL_OW 69
5076: ST_TO_ADDR
// for i in filter do
5077: LD_ADDR_VAR 0 1
5081: PUSH
5082: LD_VAR 0 2
5086: PUSH
5087: FOR_IN
5088: IFFALSE 5450
// begin tmp := IsDrivenBy ( i ) ;
5090: LD_ADDR_VAR 0 3
5094: PUSH
5095: LD_VAR 0 1
5099: PPUSH
5100: CALL_OW 311
5104: ST_TO_ADDR
// if not tmp then
5105: LD_VAR 0 3
5109: NOT
5110: IFFALSE 5114
// continue ;
5112: GO 5087
// if GetFuel ( i ) > 90 and GetTag ( i ) = 2 then
5114: LD_VAR 0 1
5118: PPUSH
5119: CALL_OW 261
5123: PUSH
5124: LD_INT 90
5126: GREATER
5127: PUSH
5128: LD_VAR 0 1
5132: PPUSH
5133: CALL_OW 110
5137: PUSH
5138: LD_INT 2
5140: EQUAL
5141: AND
5142: IFFALSE 5158
// SetTag ( i , 0 ) else
5144: LD_VAR 0 1
5148: PPUSH
5149: LD_INT 0
5151: PPUSH
5152: CALL_OW 109
5156: GO 5201
// if GetTag ( i ) = 2 then
5158: LD_VAR 0 1
5162: PPUSH
5163: CALL_OW 110
5167: PUSH
5168: LD_INT 2
5170: EQUAL
5171: IFFALSE 5201
// begin x := rand ( 1 , 2 ) ;
5173: LD_ADDR_VAR 0 5
5177: PUSH
5178: LD_INT 1
5180: PPUSH
5181: LD_INT 2
5183: PPUSH
5184: CALL_OW 12
5188: ST_TO_ADDR
// AddComMoveUnit ( i , ruMainBase ) ;
5189: LD_VAR 0 1
5193: PPUSH
5194: LD_INT 200
5196: PPUSH
5197: CALL_OW 172
// end ; if GetLives ( i ) >= 600 and not GetTag ( i ) then
5201: LD_VAR 0 1
5205: PPUSH
5206: CALL_OW 256
5210: PUSH
5211: LD_INT 600
5213: GREATEREQUAL
5214: PUSH
5215: LD_VAR 0 1
5219: PPUSH
5220: CALL_OW 110
5224: NOT
5225: AND
5226: IFFALSE 5252
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
5228: LD_VAR 0 1
5232: PPUSH
5233: LD_VAR 0 4
5237: PPUSH
5238: LD_VAR 0 1
5242: PPUSH
5243: CALL_OW 74
5247: PPUSH
5248: CALL_OW 115
// if GetLives ( i ) < 600 and not GetTag ( i ) then
5252: LD_VAR 0 1
5256: PPUSH
5257: CALL_OW 256
5261: PUSH
5262: LD_INT 600
5264: LESS
5265: PUSH
5266: LD_VAR 0 1
5270: PPUSH
5271: CALL_OW 110
5275: NOT
5276: AND
5277: IFFALSE 5306
// begin SetTag ( i , 1 ) ;
5279: LD_VAR 0 1
5283: PPUSH
5284: LD_INT 1
5286: PPUSH
5287: CALL_OW 109
// ComMoveXY ( i , 112 , 119 ) ;
5291: LD_VAR 0 1
5295: PPUSH
5296: LD_INT 112
5298: PPUSH
5299: LD_INT 119
5301: PPUSH
5302: CALL_OW 111
// end ; if GetTag ( i ) = 1 and GetDistUnitXY ( i , 112 , 119 ) < 9 and tmp then
5306: LD_VAR 0 1
5310: PPUSH
5311: CALL_OW 110
5315: PUSH
5316: LD_INT 1
5318: EQUAL
5319: PUSH
5320: LD_VAR 0 1
5324: PPUSH
5325: LD_INT 112
5327: PPUSH
5328: LD_INT 119
5330: PPUSH
5331: CALL_OW 297
5335: PUSH
5336: LD_INT 9
5338: LESS
5339: AND
5340: PUSH
5341: LD_VAR 0 3
5345: AND
5346: IFFALSE 5448
// begin ComExitVehicle ( tmp ) ;
5348: LD_VAR 0 3
5352: PPUSH
5353: CALL_OW 121
// AddComRepairVehicle ( tmp , i ) ;
5357: LD_VAR 0 3
5361: PPUSH
5362: LD_VAR 0 1
5366: PPUSH
5367: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
5371: LD_INT 35
5373: PPUSH
5374: CALL_OW 67
// until GetLives ( i ) = 1000 ;
5378: LD_VAR 0 1
5382: PPUSH
5383: CALL_OW 256
5387: PUSH
5388: LD_INT 1000
5390: EQUAL
5391: IFFALSE 5371
// ComEnterUnit ( tmp , i ) ;
5393: LD_VAR 0 3
5397: PPUSH
5398: LD_VAR 0 1
5402: PPUSH
5403: CALL_OW 120
// if GetFuel ( i ) <= 50 then
5407: LD_VAR 0 1
5411: PPUSH
5412: CALL_OW 261
5416: PUSH
5417: LD_INT 50
5419: LESSEQUAL
5420: IFFALSE 5436
// SetTag ( i , 2 ) else
5422: LD_VAR 0 1
5426: PPUSH
5427: LD_INT 2
5429: PPUSH
5430: CALL_OW 109
5434: GO 5448
// SetTag ( i , 0 ) ;
5436: LD_VAR 0 1
5440: PPUSH
5441: LD_INT 0
5443: PPUSH
5444: CALL_OW 109
// end ; end ;
5448: GO 5087
5450: POP
5451: POP
// end ;
5452: PPOPN 5
5454: END
// every 0 0$1 trigger not ruEscapeAllowed and ruEng do var i , filter , tmp , enemy ;
5455: LD_EXP 4
5459: NOT
5460: PUSH
5461: LD_EXP 37
5465: AND
5466: IFFALSE 5727
5468: GO 5470
5470: DISABLE
5471: LD_INT 0
5473: PPUSH
5474: PPUSH
5475: PPUSH
5476: PPUSH
// begin enable ;
5477: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5478: LD_ADDR_VAR 0 2
5482: PUSH
5483: LD_INT 3
5485: PPUSH
5486: LD_INT 22
5488: PUSH
5489: LD_INT 3
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: PUSH
5496: LD_INT 21
5498: PUSH
5499: LD_INT 3
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: PUSH
5506: LD_INT 3
5508: PUSH
5509: LD_INT 24
5511: PUSH
5512: LD_INT 1000
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: LIST
5527: PPUSH
5528: CALL_OW 70
5532: ST_TO_ADDR
// tmp := UnitFilter ( ruEng , [ f_ok ] ) ;
5533: LD_ADDR_VAR 0 3
5537: PUSH
5538: LD_EXP 37
5542: PPUSH
5543: LD_INT 50
5545: PUSH
5546: EMPTY
5547: LIST
5548: PPUSH
5549: CALL_OW 72
5553: ST_TO_ADDR
// if filter and tmp then
5554: LD_VAR 0 2
5558: PUSH
5559: LD_VAR 0 3
5563: AND
5564: IFFALSE 5656
// begin for i in tmp do
5566: LD_ADDR_VAR 0 1
5570: PUSH
5571: LD_VAR 0 3
5575: PUSH
5576: FOR_IN
5577: IFFALSE 5652
// begin if GetTag ( i ) = tEscape then
5579: LD_VAR 0 1
5583: PPUSH
5584: CALL_OW 110
5588: PUSH
5589: LD_EXP 17
5593: EQUAL
5594: IFFALSE 5598
// continue ;
5596: GO 5576
// if IsInUnit ( i ) then
5598: LD_VAR 0 1
5602: PPUSH
5603: CALL_OW 310
5607: IFFALSE 5620
// ComExitBuilding ( i ) else
5609: LD_VAR 0 1
5613: PPUSH
5614: CALL_OW 122
5618: GO 5650
// if not HasTask ( i ) then
5620: LD_VAR 0 1
5624: PPUSH
5625: CALL_OW 314
5629: NOT
5630: IFFALSE 5650
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5632: LD_VAR 0 1
5636: PPUSH
5637: LD_VAR 0 2
5641: PUSH
5642: LD_INT 1
5644: ARRAY
5645: PPUSH
5646: CALL_OW 130
// end ;
5650: GO 5576
5652: POP
5653: POP
// end else
5654: GO 5727
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5656: LD_VAR 0 3
5660: PPUSH
5661: LD_INT 3
5663: PUSH
5664: LD_INT 54
5666: PUSH
5667: EMPTY
5668: LIST
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: PPUSH
5674: CALL_OW 72
5678: IFFALSE 5727
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: LD_VAR 0 3
5689: PPUSH
5690: LD_INT 3
5692: PUSH
5693: LD_INT 54
5695: PUSH
5696: EMPTY
5697: LIST
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: PPUSH
5703: CALL_OW 72
5707: PUSH
5708: FOR_IN
5709: IFFALSE 5725
// ComEnterUnit ( i , ruMainBase ) ;
5711: LD_VAR 0 1
5715: PPUSH
5716: LD_INT 200
5718: PPUSH
5719: CALL_OW 120
5723: GO 5708
5725: POP
5726: POP
// end ; end ;
5727: PPOPN 4
5729: END
// every 0 0$1 trigger not ruEscapeAllowed and ruSci do var i , filter , tmp , lab ;
5730: LD_EXP 4
5734: NOT
5735: PUSH
5736: LD_EXP 39
5740: AND
5741: IFFALSE 6020
5743: GO 5745
5745: DISABLE
5746: LD_INT 0
5748: PPUSH
5749: PPUSH
5750: PPUSH
5751: PPUSH
// begin enable ;
5752: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5753: LD_ADDR_VAR 0 2
5757: PUSH
5758: LD_INT 3
5760: PPUSH
5761: LD_INT 22
5763: PUSH
5764: LD_INT 3
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PUSH
5771: LD_INT 21
5773: PUSH
5774: LD_INT 1
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: PUSH
5781: LD_INT 3
5783: PUSH
5784: LD_INT 24
5786: PUSH
5787: LD_INT 1000
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PPUSH
5803: CALL_OW 70
5807: ST_TO_ADDR
// tmp := UnitFilter ( ruSci , [ f_ok ] ) ;
5808: LD_ADDR_VAR 0 3
5812: PUSH
5813: LD_EXP 39
5817: PPUSH
5818: LD_INT 50
5820: PUSH
5821: EMPTY
5822: LIST
5823: PPUSH
5824: CALL_OW 72
5828: ST_TO_ADDR
// lab := HexInfo ( 118 , 121 ) ;
5829: LD_ADDR_VAR 0 4
5833: PUSH
5834: LD_INT 118
5836: PPUSH
5837: LD_INT 121
5839: PPUSH
5840: CALL_OW 428
5844: ST_TO_ADDR
// if filter and tmp then
5845: LD_VAR 0 2
5849: PUSH
5850: LD_VAR 0 3
5854: AND
5855: IFFALSE 5947
// begin for i in tmp do
5857: LD_ADDR_VAR 0 1
5861: PUSH
5862: LD_VAR 0 3
5866: PUSH
5867: FOR_IN
5868: IFFALSE 5943
// begin if GetTag ( i ) = tEscape then
5870: LD_VAR 0 1
5874: PPUSH
5875: CALL_OW 110
5879: PUSH
5880: LD_EXP 17
5884: EQUAL
5885: IFFALSE 5889
// continue ;
5887: GO 5867
// if IsInUnit ( i ) then
5889: LD_VAR 0 1
5893: PPUSH
5894: CALL_OW 310
5898: IFFALSE 5911
// ComExitBuilding ( i ) else
5900: LD_VAR 0 1
5904: PPUSH
5905: CALL_OW 122
5909: GO 5941
// if not HasTask ( i ) then
5911: LD_VAR 0 1
5915: PPUSH
5916: CALL_OW 314
5920: NOT
5921: IFFALSE 5941
// ComHeal ( i , filter [ 1 ] ) ;
5923: LD_VAR 0 1
5927: PPUSH
5928: LD_VAR 0 2
5932: PUSH
5933: LD_INT 1
5935: ARRAY
5936: PPUSH
5937: CALL_OW 128
// end ;
5941: GO 5867
5943: POP
5944: POP
// end else
5945: GO 6020
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5947: LD_VAR 0 3
5951: PPUSH
5952: LD_INT 3
5954: PUSH
5955: LD_INT 54
5957: PUSH
5958: EMPTY
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: PPUSH
5965: CALL_OW 72
5969: IFFALSE 6020
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5971: LD_ADDR_VAR 0 1
5975: PUSH
5976: LD_VAR 0 3
5980: PPUSH
5981: LD_INT 3
5983: PUSH
5984: LD_INT 54
5986: PUSH
5987: EMPTY
5988: LIST
5989: PUSH
5990: EMPTY
5991: LIST
5992: LIST
5993: PPUSH
5994: CALL_OW 72
5998: PUSH
5999: FOR_IN
6000: IFFALSE 6018
// ComEnterUnit ( i , lab ) ;
6002: LD_VAR 0 1
6006: PPUSH
6007: LD_VAR 0 4
6011: PPUSH
6012: CALL_OW 120
6016: GO 5999
6018: POP
6019: POP
// end ; end ; end_of_file
6020: PPOPN 4
6022: END
// on UnitDestroyed ( un ) do begin if un = Heike then
6023: LD_VAR 0 1
6027: PUSH
6028: LD_EXP 18
6032: EQUAL
6033: IFFALSE 6042
// YouLost ( Heike ) ;
6035: LD_STRING Heike
6037: PPUSH
6038: CALL_OW 104
// if un in ruEng then
6042: LD_VAR 0 1
6046: PUSH
6047: LD_EXP 37
6051: IN
6052: IFFALSE 6070
// ruEng := ruEng diff un ;
6054: LD_ADDR_EXP 37
6058: PUSH
6059: LD_EXP 37
6063: PUSH
6064: LD_VAR 0 1
6068: DIFF
6069: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) then
6070: LD_VAR 0 1
6074: PUSH
6075: LD_INT 22
6077: PUSH
6078: LD_INT 2
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PUSH
6085: LD_INT 21
6087: PUSH
6088: LD_INT 1
6090: PUSH
6091: EMPTY
6092: LIST
6093: LIST
6094: PUSH
6095: LD_INT 23
6097: PUSH
6098: LD_INT 2
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 69
6114: IN
6115: IFFALSE 6131
// loseCounter := loseCounter + 1 ;
6117: LD_ADDR_EXP 6
6121: PUSH
6122: LD_EXP 6
6126: PUSH
6127: LD_INT 1
6129: PLUS
6130: ST_TO_ADDR
// end ;
6131: PPOPN 1
6133: END
// on EvacuateVehicle ( driver , un , p1 , p2 ) do var weapon , fac ;
6134: LD_INT 0
6136: PPUSH
6137: PPUSH
// begin if un in ruMobile then
6138: LD_VAR 0 2
6142: PUSH
6143: LD_EXP 40
6147: IN
6148: IFFALSE 6307
// begin ruMobile := ruMobile diff un ;
6150: LD_ADDR_EXP 40
6154: PUSH
6155: LD_EXP 40
6159: PUSH
6160: LD_VAR 0 2
6164: DIFF
6165: ST_TO_ADDR
// weapon := GetWeapon ( un ) ;
6166: LD_ADDR_VAR 0 5
6170: PUSH
6171: LD_VAR 0 2
6175: PPUSH
6176: CALL_OW 264
6180: ST_TO_ADDR
// fac := HexInfo ( 110 , 126 ) ;
6181: LD_ADDR_VAR 0 6
6185: PUSH
6186: LD_INT 110
6188: PPUSH
6189: LD_INT 126
6191: PPUSH
6192: CALL_OW 428
6196: ST_TO_ADDR
// if not driver or not fac then
6197: LD_VAR 0 1
6201: NOT
6202: PUSH
6203: LD_VAR 0 6
6207: NOT
6208: OR
6209: IFFALSE 6213
// exit ;
6211: GO 6307
// AddComMoveXY ( driver , 111 , 121 ) ;
6213: LD_VAR 0 1
6217: PPUSH
6218: LD_INT 111
6220: PPUSH
6221: LD_INT 121
6223: PPUSH
6224: CALL_OW 171
// AddComEnterUnit ( driver , fac ) ;
6228: LD_VAR 0 1
6232: PPUSH
6233: LD_VAR 0 6
6237: PPUSH
6238: CALL_OW 180
// repeat wait ( 0 0$1 ) ;
6242: LD_INT 35
6244: PPUSH
6245: CALL_OW 67
// until IsDead ( driver ) or IsInUnit ( driver ) ;
6249: LD_VAR 0 1
6253: PPUSH
6254: CALL_OW 301
6258: PUSH
6259: LD_VAR 0 1
6263: PPUSH
6264: CALL_OW 310
6268: OR
6269: IFFALSE 6242
// if IsDead ( driver ) then
6271: LD_VAR 0 1
6275: PPUSH
6276: CALL_OW 301
6280: IFFALSE 6284
// exit ;
6282: GO 6307
// AddComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_manual , weapon ) ;
6284: LD_VAR 0 6
6288: PPUSH
6289: LD_INT 21
6291: PPUSH
6292: LD_INT 1
6294: PPUSH
6295: LD_INT 1
6297: PPUSH
6298: LD_VAR 0 5
6302: PPUSH
6303: CALL_OW 185
// end ; end ;
6307: PPOPN 6
6309: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 3 then
6310: LD_VAR 0 2
6314: PPUSH
6315: CALL_OW 255
6319: PUSH
6320: LD_INT 3
6322: EQUAL
6323: IFFALSE 6369
// begin ruMobile := Replace ( ruMobile , ruMobile + 1 , veh ) ;
6325: LD_ADDR_EXP 40
6329: PUSH
6330: LD_EXP 40
6334: PPUSH
6335: LD_EXP 40
6339: PUSH
6340: LD_INT 1
6342: PLUS
6343: PPUSH
6344: LD_VAR 0 1
6348: PPUSH
6349: CALL_OW 1
6353: ST_TO_ADDR
// AddComMoveXY ( veh , 110 , 117 ) ;
6354: LD_VAR 0 1
6358: PPUSH
6359: LD_INT 110
6361: PPUSH
6362: LD_INT 117
6364: PPUSH
6365: CALL_OW 171
// end ; end ;
6369: PPOPN 2
6371: END
// on LeaveBuilding ( b , un ) do var barracks ;
6372: LD_INT 0
6374: PPUSH
// begin if b in [ HexInfo ( 130 , 17 ) , HexInfo ( 138 , 22 ) , HexInfo ( 123 , 17 ) ] then
6375: LD_VAR 0 1
6379: PUSH
6380: LD_INT 130
6382: PPUSH
6383: LD_INT 17
6385: PPUSH
6386: CALL_OW 428
6390: PUSH
6391: LD_INT 138
6393: PPUSH
6394: LD_INT 22
6396: PPUSH
6397: CALL_OW 428
6401: PUSH
6402: LD_INT 123
6404: PPUSH
6405: LD_INT 17
6407: PPUSH
6408: CALL_OW 428
6412: PUSH
6413: EMPTY
6414: LIST
6415: LIST
6416: LIST
6417: IN
6418: IFFALSE 6442
// begin AddComEnterUnit ( un , HexInfo ( 135 , 31 ) ) ;
6420: LD_VAR 0 2
6424: PPUSH
6425: LD_INT 135
6427: PPUSH
6428: LD_INT 31
6430: PPUSH
6431: CALL_OW 428
6435: PPUSH
6436: CALL_OW 180
// exit ;
6440: GO 6716
// end ; if b = HexInfo ( 135 , 31 ) then
6442: LD_VAR 0 1
6446: PUSH
6447: LD_INT 135
6449: PPUSH
6450: LD_INT 31
6452: PPUSH
6453: CALL_OW 428
6457: EQUAL
6458: IFFALSE 6530
// begin AddComEnterUnit ( un , HexInfo ( 106 , 51 ) ) ;
6460: LD_VAR 0 2
6464: PPUSH
6465: LD_INT 106
6467: PPUSH
6468: LD_INT 51
6470: PPUSH
6471: CALL_OW 428
6475: PPUSH
6476: CALL_OW 180
// if not explodeFirstDepot then
6480: LD_EXP 12
6484: NOT
6485: IFFALSE 6528
// begin explodeFirstDepot := true ;
6487: LD_ADDR_EXP 12
6491: PUSH
6492: LD_INT 1
6494: ST_TO_ADDR
// wait ( 0 0$15 ) ;
6495: LD_INT 525
6497: PPUSH
6498: CALL_OW 67
// MineExplosion ( 127 , 27 , 1 ) ;
6502: LD_INT 127
6504: PPUSH
6505: LD_INT 27
6507: PPUSH
6508: LD_INT 1
6510: PPUSH
6511: CALL_OW 453
// MineExplosion ( 125 , 29 , 1 ) ;
6515: LD_INT 125
6517: PPUSH
6518: LD_INT 29
6520: PPUSH
6521: LD_INT 1
6523: PPUSH
6524: CALL_OW 453
// end ; exit ;
6528: GO 6716
// end ; if b = HexInfo ( 106 , 51 ) then
6530: LD_VAR 0 1
6534: PUSH
6535: LD_INT 106
6537: PPUSH
6538: LD_INT 51
6540: PPUSH
6541: CALL_OW 428
6545: EQUAL
6546: IFFALSE 6646
// begin AddComMoveXY ( un , 106 , 93 ) ;
6548: LD_VAR 0 2
6552: PPUSH
6553: LD_INT 106
6555: PPUSH
6556: LD_INT 93
6558: PPUSH
6559: CALL_OW 171
// if not explodeSecondDepot then
6563: LD_EXP 13
6567: NOT
6568: IFFALSE 6644
// begin explodeSecondDepot := true ;
6570: LD_ADDR_EXP 13
6574: PUSH
6575: LD_INT 1
6577: ST_TO_ADDR
// wait ( 0 0$12 ) ;
6578: LD_INT 420
6580: PPUSH
6581: CALL_OW 67
// MineExplosion ( 111 , 75 , 1 ) ;
6585: LD_INT 111
6587: PPUSH
6588: LD_INT 75
6590: PPUSH
6591: LD_INT 1
6593: PPUSH
6594: CALL_OW 453
// MineExplosion ( 111 , 75 , 1 ) ;
6598: LD_INT 111
6600: PPUSH
6601: LD_INT 75
6603: PPUSH
6604: LD_INT 1
6606: PPUSH
6607: CALL_OW 453
// MineExplosion ( 108 , 69 , 1 ) ;
6611: LD_INT 108
6613: PPUSH
6614: LD_INT 69
6616: PPUSH
6617: LD_INT 1
6619: PPUSH
6620: CALL_OW 453
// wait ( 0 0$2 ) ;
6624: LD_INT 70
6626: PPUSH
6627: CALL_OW 67
// MineExplosion ( 94 , 65 , 1 ) ;
6631: LD_INT 94
6633: PPUSH
6634: LD_INT 65
6636: PPUSH
6637: LD_INT 1
6639: PPUSH
6640: CALL_OW 453
// end ; exit ;
6644: GO 6716
// end ; if GetBType ( b ) = b_bunker then
6646: LD_VAR 0 1
6650: PPUSH
6651: CALL_OW 266
6655: PUSH
6656: LD_INT 32
6658: EQUAL
6659: IFFALSE 6716
// begin barracks := NearestEmptyBuilding ( un , b_barracks ) ;
6661: LD_ADDR_VAR 0 3
6665: PUSH
6666: LD_VAR 0 2
6670: PPUSH
6671: LD_INT 5
6673: PPUSH
6674: CALL 2403 0 2
6678: ST_TO_ADDR
// if barracks then
6679: LD_VAR 0 3
6683: IFFALSE 6701
// AddComEnterUnit ( un , barracks ) else
6685: LD_VAR 0 2
6689: PPUSH
6690: LD_VAR 0 3
6694: PPUSH
6695: CALL_OW 180
6699: GO 6716
// AddComMoveXY ( un , 116 , 110 ) ;
6701: LD_VAR 0 2
6705: PPUSH
6706: LD_INT 116
6708: PPUSH
6709: LD_INT 110
6711: PPUSH
6712: CALL_OW 171
// end ; end ;
6716: PPOPN 3
6718: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin if un = Kaia and killerSide in [ 3 , 6 ] then
6719: LD_VAR 0 1
6723: PUSH
6724: LD_EXP 23
6728: EQUAL
6729: PUSH
6730: LD_VAR 0 2
6734: PUSH
6735: LD_INT 3
6737: PUSH
6738: LD_INT 6
6740: PUSH
6741: EMPTY
6742: LIST
6743: LIST
6744: IN
6745: AND
6746: IFFALSE 6777
// kaiaKilledByRussian := [ GetX ( un ) , GetY ( un ) ] ;
6748: LD_ADDR_EXP 8
6752: PUSH
6753: LD_VAR 0 1
6757: PPUSH
6758: CALL_OW 250
6762: PUSH
6763: LD_VAR 0 1
6767: PPUSH
6768: CALL_OW 251
6772: PUSH
6773: EMPTY
6774: LIST
6775: LIST
6776: ST_TO_ADDR
// end ; end_of_file
6777: PPOPN 3
6779: END
// export function Action ; var i , un , veh , tmp , rutmp ; begin
6780: LD_INT 0
6782: PPUSH
6783: PPUSH
6784: PPUSH
6785: PPUSH
6786: PPUSH
6787: PPUSH
// InGameOn ;
6788: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6792: LD_INT 5
6794: PPUSH
6795: LD_INT 2
6797: PPUSH
6798: CALL_OW 343
// music_nat := 4 ;
6802: LD_ADDR_OWVAR 71
6806: PUSH
6807: LD_INT 4
6809: ST_TO_ADDR
// music_class := music_combat ;
6810: LD_ADDR_OWVAR 72
6814: PUSH
6815: LD_INT 1
6817: ST_TO_ADDR
// PlaceSeeing ( 133 , 2 , 2 , 10 ) ;
6818: LD_INT 133
6820: PPUSH
6821: LD_INT 2
6823: PPUSH
6824: LD_INT 2
6826: PPUSH
6827: LD_INT 10
6829: PPUSH
6830: CALL_OW 330
// CenterNowOnXY ( 133 , 2 ) ;
6834: LD_INT 133
6836: PPUSH
6837: LD_INT 2
6839: PPUSH
6840: CALL_OW 86
// wait ( 0 0$1 ) ;
6844: LD_INT 35
6846: PPUSH
6847: CALL_OW 67
// uc_side := 6 ;
6851: LD_ADDR_OWVAR 20
6855: PUSH
6856: LD_INT 6
6858: ST_TO_ADDR
// uc_nation := 3 ;
6859: LD_ADDR_OWVAR 21
6863: PUSH
6864: LD_INT 3
6866: ST_TO_ADDR
// rutmp := [ ] ;
6867: LD_ADDR_VAR 0 6
6871: PUSH
6872: EMPTY
6873: ST_TO_ADDR
// PrepareTank ( 6 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_gun , 66 ) ;
6874: LD_INT 6
6876: PPUSH
6877: LD_INT 3
6879: PPUSH
6880: LD_INT 21
6882: PPUSH
6883: LD_INT 1
6885: PPUSH
6886: LD_INT 1
6888: PPUSH
6889: LD_INT 44
6891: PPUSH
6892: LD_INT 66
6894: PPUSH
6895: CALL 399 0 7
// veh := CreateVehicle ;
6899: LD_ADDR_VAR 0 4
6903: PUSH
6904: CALL_OW 45
6908: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
6909: LD_VAR 0 4
6913: PPUSH
6914: LD_INT 3
6916: PPUSH
6917: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
6921: LD_VAR 0 4
6925: PPUSH
6926: LD_INT 8
6928: PPUSH
6929: LD_INT 0
6931: PPUSH
6932: CALL_OW 49
// SetLives ( veh , 500 ) ;
6936: LD_VAR 0 4
6940: PPUSH
6941: LD_INT 500
6943: PPUSH
6944: CALL_OW 234
// PrepareHuman ( false , 3 , 3 ) ;
6948: LD_INT 0
6950: PPUSH
6951: LD_INT 3
6953: PPUSH
6954: LD_INT 3
6956: PPUSH
6957: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6961: CALL_OW 44
6965: PPUSH
6966: LD_VAR 0 4
6970: PPUSH
6971: CALL_OW 52
// ComMoveXY ( veh , 133 , 11 ) ;
6975: LD_VAR 0 4
6979: PPUSH
6980: LD_INT 133
6982: PPUSH
6983: LD_INT 11
6985: PPUSH
6986: CALL_OW 111
// rutmp := [ veh ] ;
6990: LD_ADDR_VAR 0 6
6994: PUSH
6995: LD_VAR 0 4
6999: PUSH
7000: EMPTY
7001: LIST
7002: ST_TO_ADDR
// for i := 1 to 4 do
7003: LD_ADDR_VAR 0 2
7007: PUSH
7008: DOUBLE
7009: LD_INT 1
7011: DEC
7012: ST_TO_ADDR
7013: LD_INT 4
7015: PUSH
7016: FOR_TO
7017: IFFALSE 7124
// begin PrepareHuman ( false , i , 2 ) ;
7019: LD_INT 0
7021: PPUSH
7022: LD_VAR 0 2
7026: PPUSH
7027: LD_INT 2
7029: PPUSH
7030: CALL_OW 380
// un := CreateHuman ;
7034: LD_ADDR_VAR 0 3
7038: PUSH
7039: CALL_OW 44
7043: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7044: LD_VAR 0 3
7048: PPUSH
7049: LD_INT 3
7051: PPUSH
7052: CALL_OW 233
// PlaceUnitArea ( un , spawnArea , false ) ;
7056: LD_VAR 0 3
7060: PPUSH
7061: LD_INT 8
7063: PPUSH
7064: LD_INT 0
7066: PPUSH
7067: CALL_OW 49
// rutmp := Replace ( rutmp , rutmp + 1 , un ) ;
7071: LD_ADDR_VAR 0 6
7075: PUSH
7076: LD_VAR 0 6
7080: PPUSH
7081: LD_VAR 0 6
7085: PUSH
7086: LD_INT 1
7088: PLUS
7089: PPUSH
7090: LD_VAR 0 3
7094: PPUSH
7095: CALL_OW 1
7099: ST_TO_ADDR
// ComMoveXY ( un , 133 , 11 ) ;
7100: LD_VAR 0 3
7104: PPUSH
7105: LD_INT 133
7107: PPUSH
7108: LD_INT 11
7110: PPUSH
7111: CALL_OW 111
// wait ( 0 0$0.5 ) ;
7115: LD_INT 18
7117: PPUSH
7118: CALL_OW 67
// end ;
7122: GO 7016
7124: POP
7125: POP
// for i in rutmp do
7126: LD_ADDR_VAR 0 2
7130: PUSH
7131: LD_VAR 0 6
7135: PUSH
7136: FOR_IN
7137: IFFALSE 7186
// begin AddComMoveXY ( i , 99 , 65 ) ;
7139: LD_VAR 0 2
7143: PPUSH
7144: LD_INT 99
7146: PPUSH
7147: LD_INT 65
7149: PPUSH
7150: CALL_OW 171
// AddComMoveXY ( i , 76 , 108 ) ;
7154: LD_VAR 0 2
7158: PPUSH
7159: LD_INT 76
7161: PPUSH
7162: LD_INT 108
7164: PPUSH
7165: CALL_OW 171
// AddComMoveXY ( i , 92 , 176 ) ;
7169: LD_VAR 0 2
7173: PPUSH
7174: LD_INT 92
7176: PPUSH
7177: LD_INT 176
7179: PPUSH
7180: CALL_OW 171
// end ;
7184: GO 7136
7186: POP
7187: POP
// wait ( 0 0$10 ) ;
7188: LD_INT 350
7190: PPUSH
7191: CALL_OW 67
// tmp := [ Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Kurt , Aviradze ] union heikeSecondSquad ;
7195: LD_ADDR_VAR 0 5
7199: PUSH
7200: LD_EXP 18
7204: PUSH
7205: LD_EXP 19
7209: PUSH
7210: LD_EXP 20
7214: PUSH
7215: LD_EXP 21
7219: PUSH
7220: LD_EXP 22
7224: PUSH
7225: LD_EXP 23
7229: PUSH
7230: LD_EXP 24
7234: PUSH
7235: LD_EXP 25
7239: PUSH
7240: LD_EXP 27
7244: PUSH
7245: LD_EXP 28
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: LIST
7254: LIST
7255: LIST
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_EXP 29
7266: UNION
7267: ST_TO_ADDR
// tmp := tmp diff 0 ;
7268: LD_ADDR_VAR 0 5
7272: PUSH
7273: LD_VAR 0 5
7277: PUSH
7278: LD_INT 0
7280: DIFF
7281: ST_TO_ADDR
// for i in heikeVehicles do
7282: LD_ADDR_VAR 0 2
7286: PUSH
7287: LD_EXP 30
7291: PUSH
7292: FOR_IN
7293: IFFALSE 7559
// begin if not tmp then
7295: LD_VAR 0 5
7299: NOT
7300: IFFALSE 7304
// continue ;
7302: GO 7292
// PrepareTank ( 2 , i [ 5 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] , 34 ) ;
7304: LD_INT 2
7306: PPUSH
7307: LD_VAR 0 2
7311: PUSH
7312: LD_INT 5
7314: ARRAY
7315: PPUSH
7316: LD_VAR 0 2
7320: PUSH
7321: LD_INT 1
7323: ARRAY
7324: PPUSH
7325: LD_VAR 0 2
7329: PUSH
7330: LD_INT 2
7332: ARRAY
7333: PPUSH
7334: LD_VAR 0 2
7338: PUSH
7339: LD_INT 3
7341: ARRAY
7342: PPUSH
7343: LD_VAR 0 2
7347: PUSH
7348: LD_INT 4
7350: ARRAY
7351: PPUSH
7352: LD_INT 34
7354: PPUSH
7355: CALL 399 0 7
// veh := CreateVehicle ;
7359: LD_ADDR_VAR 0 4
7363: PUSH
7364: CALL_OW 45
7368: ST_TO_ADDR
// if i [ 4 ] in [ ru_cargo_bay , ar_cargo_bay , us_cargo_bay ] then
7369: LD_VAR 0 2
7373: PUSH
7374: LD_INT 4
7376: ARRAY
7377: PUSH
7378: LD_INT 51
7380: PUSH
7381: LD_INT 32
7383: PUSH
7384: LD_INT 12
7386: PUSH
7387: EMPTY
7388: LIST
7389: LIST
7390: LIST
7391: IN
7392: IFFALSE 7472
// begin if i [ 7 ] [ 1 ] then
7394: LD_VAR 0 2
7398: PUSH
7399: LD_INT 7
7401: ARRAY
7402: PUSH
7403: LD_INT 1
7405: ARRAY
7406: IFFALSE 7433
// AddCargo ( veh , mat_cans , i [ 7 ] [ 1 ] ) ;
7408: LD_VAR 0 4
7412: PPUSH
7413: LD_INT 1
7415: PPUSH
7416: LD_VAR 0 2
7420: PUSH
7421: LD_INT 7
7423: ARRAY
7424: PUSH
7425: LD_INT 1
7427: ARRAY
7428: PPUSH
7429: CALL_OW 291
// if i [ 7 ] [ 2 ] then
7433: LD_VAR 0 2
7437: PUSH
7438: LD_INT 7
7440: ARRAY
7441: PUSH
7442: LD_INT 2
7444: ARRAY
7445: IFFALSE 7472
// AddCargo ( veh , mat_oil , i [ 7 ] [ 2 ] ) ;
7447: LD_VAR 0 4
7451: PPUSH
7452: LD_INT 2
7454: PPUSH
7455: LD_VAR 0 2
7459: PUSH
7460: LD_INT 7
7462: ARRAY
7463: PUSH
7464: LD_INT 2
7466: ARRAY
7467: PPUSH
7468: CALL_OW 291
// end ; SetDir ( veh , 3 ) ;
7472: LD_VAR 0 4
7476: PPUSH
7477: LD_INT 3
7479: PPUSH
7480: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7484: LD_VAR 0 4
7488: PPUSH
7489: LD_INT 8
7491: PPUSH
7492: LD_INT 0
7494: PPUSH
7495: CALL_OW 49
// PlaceHumanInUnit ( tmp [ 1 ] , veh ) ;
7499: LD_VAR 0 5
7503: PUSH
7504: LD_INT 1
7506: ARRAY
7507: PPUSH
7508: LD_VAR 0 4
7512: PPUSH
7513: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
7517: LD_ADDR_VAR 0 5
7521: PUSH
7522: LD_VAR 0 5
7526: PPUSH
7527: LD_INT 1
7529: PPUSH
7530: CALL_OW 3
7534: ST_TO_ADDR
// ComAgressiveMove ( veh , 133 , 7 ) ;
7535: LD_VAR 0 4
7539: PPUSH
7540: LD_INT 133
7542: PPUSH
7543: LD_INT 7
7545: PPUSH
7546: CALL_OW 114
// wait ( 0 0$1 ) ;
7550: LD_INT 35
7552: PPUSH
7553: CALL_OW 67
// end ;
7557: GO 7292
7559: POP
7560: POP
// if tmp then
7561: LD_VAR 0 5
7565: IFFALSE 7621
// for i in tmp do
7567: LD_ADDR_VAR 0 2
7571: PUSH
7572: LD_VAR 0 5
7576: PUSH
7577: FOR_IN
7578: IFFALSE 7619
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7580: LD_VAR 0 2
7584: PPUSH
7585: LD_INT 10
7587: PPUSH
7588: LD_INT 0
7590: PPUSH
7591: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7595: LD_VAR 0 2
7599: PPUSH
7600: LD_INT 146
7602: PPUSH
7603: LD_INT 7
7605: PPUSH
7606: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7610: LD_INT 18
7612: PPUSH
7613: CALL_OW 67
// end ;
7617: GO 7577
7619: POP
7620: POP
// if heikeApes then
7621: LD_EXP 31
7625: IFFALSE 7681
// for i in heikeApes do
7627: LD_ADDR_VAR 0 2
7631: PUSH
7632: LD_EXP 31
7636: PUSH
7637: FOR_IN
7638: IFFALSE 7679
// begin PlaceUnitArea ( i , spawnHumanArea , false ) ;
7640: LD_VAR 0 2
7644: PPUSH
7645: LD_INT 10
7647: PPUSH
7648: LD_INT 0
7650: PPUSH
7651: CALL_OW 49
// ComAgressiveMove ( i , 146 , 7 ) ;
7655: LD_VAR 0 2
7659: PPUSH
7660: LD_INT 146
7662: PPUSH
7663: LD_INT 7
7665: PPUSH
7666: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7670: LD_INT 18
7672: PPUSH
7673: CALL_OW 67
// end ;
7677: GO 7637
7679: POP
7680: POP
// DialogueOn ;
7681: CALL_OW 6
// Say ( Heike , DH-outpost-a-1 ) ;
7685: LD_EXP 18
7689: PPUSH
7690: LD_STRING DH-outpost-a-1
7692: PPUSH
7693: CALL_OW 88
// DialogueOff ;
7697: CALL_OW 7
// RemoveSeeing ( 133 , 2 , 2 ) ;
7701: LD_INT 133
7703: PPUSH
7704: LD_INT 2
7706: PPUSH
7707: LD_INT 2
7709: PPUSH
7710: CALL_OW 331
// InGameOff ;
7714: CALL_OW 9
// music_nat := 0 ;
7718: LD_ADDR_OWVAR 71
7722: PUSH
7723: LD_INT 0
7725: ST_TO_ADDR
// music_class := 0 ;
7726: LD_ADDR_OWVAR 72
7730: PUSH
7731: LD_INT 0
7733: ST_TO_ADDR
// ChangeMissionObjectives ( Outposts ) ;
7734: LD_STRING Outposts
7736: PPUSH
7737: CALL_OW 337
// SaveForQuickRestart ;
7741: CALL_OW 22
// end ;
7745: LD_VAR 0 1
7749: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 20 ] ] ) and ibrahimOnRuSide and IsOk ( Ibrahim ) do
7750: LD_INT 22
7752: PUSH
7753: LD_INT 2
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: PUSH
7760: LD_INT 91
7762: PUSH
7763: LD_EXP 21
7767: PUSH
7768: LD_INT 20
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: LIST
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: PPUSH
7780: CALL_OW 69
7784: PUSH
7785: LD_EXP 3
7789: AND
7790: PUSH
7791: LD_EXP 21
7795: PPUSH
7796: CALL_OW 302
7800: AND
7801: IFFALSE 7889
7803: GO 7805
7805: DISABLE
// begin IbrahimBetrayal ;
7806: CALL 7890 0 0
// repeat wait ( 0 0$1 ) ;
7810: LD_INT 35
7812: PPUSH
7813: CALL_OW 67
// until IsDead ( Ibrahim ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 6 ] ] ) ;
7817: LD_EXP 21
7821: PPUSH
7822: CALL_OW 301
7826: PUSH
7827: LD_INT 22
7829: PUSH
7830: LD_INT 2
7832: PUSH
7833: EMPTY
7834: LIST
7835: LIST
7836: PUSH
7837: LD_INT 91
7839: PUSH
7840: LD_EXP 21
7844: PUSH
7845: LD_INT 6
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: LIST
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PPUSH
7857: CALL_OW 69
7861: OR
7862: IFFALSE 7810
// if IsDead ( Ibrahim ) then
7864: LD_EXP 21
7868: PPUSH
7869: CALL_OW 301
7873: IFFALSE 7877
// exit ;
7875: GO 7889
// SetSide ( Ibrahim , 2 ) ;
7877: LD_EXP 21
7881: PPUSH
7882: LD_INT 2
7884: PPUSH
7885: CALL_OW 235
// end ;
7889: END
// export function IbrahimBetrayal ; var i , tmp ; begin
7890: LD_INT 0
7892: PPUSH
7893: PPUSH
7894: PPUSH
// PlaceSeeing ( 122 , 77 , 2 , - 6 ) ;
7895: LD_INT 122
7897: PPUSH
7898: LD_INT 77
7900: PPUSH
7901: LD_INT 2
7903: PPUSH
7904: LD_INT 6
7906: NEG
7907: PPUSH
7908: CALL_OW 330
// ComMoveXY ( Ibrahim , 123 , 79 ) ;
7912: LD_EXP 21
7916: PPUSH
7917: LD_INT 123
7919: PPUSH
7920: LD_INT 79
7922: PPUSH
7923: CALL_OW 111
// AddComTurnXY ( Ibrahim , 125 , 82 ) ;
7927: LD_EXP 21
7931: PPUSH
7932: LD_INT 125
7934: PPUSH
7935: LD_INT 82
7937: PPUSH
7938: CALL_OW 178
// wait ( 0 0$2 ) ;
7942: LD_INT 70
7944: PPUSH
7945: CALL_OW 67
// ComTurnUnit ( ruSol , Ibrahim ) ;
7949: LD_EXP 41
7953: PPUSH
7954: LD_EXP 21
7958: PPUSH
7959: CALL_OW 119
// Say ( ruSol , DRum-outpost-b-3 ) ;
7963: LD_EXP 41
7967: PPUSH
7968: LD_STRING DRum-outpost-b-3
7970: PPUSH
7971: CALL_OW 88
// tmp := [ HexInfo ( 125 , 76 ) , HexInfo ( 125 , 79 ) , HexInfo ( 125 , 82 ) ] ;
7975: LD_ADDR_VAR 0 3
7979: PUSH
7980: LD_INT 125
7982: PPUSH
7983: LD_INT 76
7985: PPUSH
7986: CALL_OW 428
7990: PUSH
7991: LD_INT 125
7993: PPUSH
7994: LD_INT 79
7996: PPUSH
7997: CALL_OW 428
8001: PUSH
8002: LD_INT 125
8004: PPUSH
8005: LD_INT 82
8007: PPUSH
8008: CALL_OW 428
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: LIST
8017: ST_TO_ADDR
// for i in tmp do
8018: LD_ADDR_VAR 0 2
8022: PUSH
8023: LD_VAR 0 3
8027: PUSH
8028: FOR_IN
8029: IFFALSE 8045
// SetLives ( i , 200 ) ;
8031: LD_VAR 0 2
8035: PPUSH
8036: LD_INT 200
8038: PPUSH
8039: CALL_OW 234
8043: GO 8028
8045: POP
8046: POP
// Say ( Ibrahim , DI-outpost-b-4 ) ;
8047: LD_EXP 21
8051: PPUSH
8052: LD_STRING DI-outpost-b-4
8054: PPUSH
8055: CALL_OW 88
// SetSide ( Ibrahim , 5 ) ;
8059: LD_EXP 21
8063: PPUSH
8064: LD_INT 5
8066: PPUSH
8067: CALL_OW 235
// ComFree ( [ Ibrahim , ruSol ] ) ;
8071: LD_EXP 21
8075: PUSH
8076: LD_EXP 41
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PPUSH
8085: CALL_OW 139
// RemoveSeeing ( 122 , 77 , 2 ) ;
8089: LD_INT 122
8091: PPUSH
8092: LD_INT 77
8094: PPUSH
8095: LD_INT 2
8097: PPUSH
8098: CALL_OW 331
// if Givi then
8102: LD_EXP 19
8106: IFFALSE 8122
// Say ( Givi , DG-1-outpost-b-5 ) else
8108: LD_EXP 19
8112: PPUSH
8113: LD_STRING DG-1-outpost-b-5
8115: PPUSH
8116: CALL_OW 88
8120: GO 8187
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-outpost-b-a-5 ) then
8122: LD_EXP 29
8126: PPUSH
8127: LD_INT 26
8129: PUSH
8130: LD_INT 2
8132: PUSH
8133: EMPTY
8134: LIST
8135: LIST
8136: PPUSH
8137: CALL_OW 72
8141: PUSH
8142: LD_INT 1
8144: ARRAY
8145: PPUSH
8146: LD_STRING DArf-outpost-b-a-5
8148: PPUSH
8149: CALL_OW 88
8153: NOT
8154: IFFALSE 8187
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-outpost-b-a-5 ) ;
8156: LD_EXP 29
8160: PPUSH
8161: LD_INT 26
8163: PUSH
8164: LD_INT 1
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PPUSH
8171: CALL_OW 72
8175: PUSH
8176: LD_INT 1
8178: ARRAY
8179: PPUSH
8180: LD_STRING DArm-outpost-b-a-5
8182: PPUSH
8183: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
8187: LD_INT 35
8189: PPUSH
8190: CALL_OW 67
// until IsDead ( Ibrahim ) or ( GetDistUnits ( Heike , Ibrahim ) < 6 and IsOk ( Ibrahim ) ) ;
8194: LD_EXP 21
8198: PPUSH
8199: CALL_OW 301
8203: PUSH
8204: LD_EXP 18
8208: PPUSH
8209: LD_EXP 21
8213: PPUSH
8214: CALL_OW 296
8218: PUSH
8219: LD_INT 6
8221: LESS
8222: PUSH
8223: LD_EXP 21
8227: PPUSH
8228: CALL_OW 302
8232: AND
8233: OR
8234: IFFALSE 8187
// if IsDead ( Ibrahim ) then
8236: LD_EXP 21
8240: PPUSH
8241: CALL_OW 301
8245: IFFALSE 8261
// begin Say ( Heike , DH-ibrahimdead-1 ) ;
8247: LD_EXP 18
8251: PPUSH
8252: LD_STRING DH-ibrahimdead-1
8254: PPUSH
8255: CALL_OW 88
// exit ;
8259: GO 8306
// end ; CenterNowOnUnits ( Ibrahim ) ;
8261: LD_EXP 21
8265: PPUSH
8266: CALL_OW 87
// Say ( Ibrahim , DI-ibrahimlives-1 ) ;
8270: LD_EXP 21
8274: PPUSH
8275: LD_STRING DI-ibrahimlives-1
8277: PPUSH
8278: CALL_OW 88
// Say ( Heike , DH-Ibrahimlives-2 ) ;
8282: LD_EXP 18
8286: PPUSH
8287: LD_STRING DH-Ibrahimlives-2
8289: PPUSH
8290: CALL_OW 88
// SetSide ( Ibrahim , 2 ) ;
8294: LD_EXP 21
8298: PPUSH
8299: LD_INT 2
8301: PPUSH
8302: CALL_OW 235
// end ;
8306: LD_VAR 0 1
8310: RET
// every 0 0$2 trigger FilterUnitsInArea ( outerArea , [ f_side , 2 ] ) do
8311: LD_INT 11
8313: PPUSH
8314: LD_INT 22
8316: PUSH
8317: LD_INT 2
8319: PUSH
8320: EMPTY
8321: LIST
8322: LIST
8323: PPUSH
8324: CALL_OW 70
8328: IFFALSE 8735
8330: GO 8332
8332: DISABLE
// begin outerAreaAchived := true ;
8333: LD_ADDR_EXP 15
8337: PUSH
8338: LD_INT 1
8340: ST_TO_ADDR
// wait ( 0 0$20 ) ;
8341: LD_INT 700
8343: PPUSH
8344: CALL_OW 67
// DialogueOn ;
8348: CALL_OW 6
// SayRadio ( Shariff , DShar-radio-1 ) ;
8352: LD_EXP 26
8356: PPUSH
8357: LD_STRING DShar-radio-1
8359: PPUSH
8360: CALL_OW 94
// SayRadio ( Shariff , DShar-radio-2 ) ;
8364: LD_EXP 26
8368: PPUSH
8369: LD_STRING DShar-radio-2
8371: PPUSH
8372: CALL_OW 94
// Say ( Heike , DH-radio-2 ) ;
8376: LD_EXP 18
8380: PPUSH
8381: LD_STRING DH-radio-2
8383: PPUSH
8384: CALL_OW 88
// DialogueOff ;
8388: CALL_OW 7
// ChangeMissionObjectives ( Gaidar ) ;
8392: LD_STRING Gaidar
8394: PPUSH
8395: CALL_OW 337
// if Difficulty < 3 then
8399: LD_OWVAR 67
8403: PUSH
8404: LD_INT 3
8406: LESS
8407: IFFALSE 8473
// begin DialogueOn ;
8409: CALL_OW 6
// PlaceSeeing ( 11 , 14 , 2 , - 6 ) ;
8413: LD_INT 11
8415: PPUSH
8416: LD_INT 14
8418: PPUSH
8419: LD_INT 2
8421: PPUSH
8422: LD_INT 6
8424: NEG
8425: PPUSH
8426: CALL_OW 330
// RemoveSeeing ( 11 , 14 , 2 ) ;
8430: LD_INT 11
8432: PPUSH
8433: LD_INT 14
8435: PPUSH
8436: LD_INT 2
8438: PPUSH
8439: CALL_OW 331
// CenterOnXY ( 11 , 14 ) ;
8443: LD_INT 11
8445: PPUSH
8446: LD_INT 14
8448: PPUSH
8449: CALL_OW 84
// dwait ( 0 0$1 ) ;
8453: LD_INT 35
8455: PPUSH
8456: CALL_OW 68
// CenterNowOnUnits ( Heike ) ;
8460: LD_EXP 18
8464: PPUSH
8465: CALL_OW 87
// DialogueOff ;
8469: CALL_OW 7
// end ; wait ( 0 0$10 + rand ( 0 0$10 , 0 0$15 ) * Difficulty ) ;
8473: LD_INT 350
8475: PUSH
8476: LD_INT 350
8478: PPUSH
8479: LD_INT 525
8481: PPUSH
8482: CALL_OW 12
8486: PUSH
8487: LD_OWVAR 67
8491: MUL
8492: PLUS
8493: PPUSH
8494: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8498: LD_INT 35
8500: PPUSH
8501: CALL_OW 67
// until HexInfo ( 2 , 1 ) = 0 ;
8505: LD_INT 2
8507: PPUSH
8508: LD_INT 1
8510: PPUSH
8511: CALL_OW 428
8515: PUSH
8516: LD_INT 0
8518: EQUAL
8519: IFFALSE 8498
// SetDir ( Gaidar , 2 ) ;
8521: LD_EXP 34
8525: PPUSH
8526: LD_INT 2
8528: PPUSH
8529: CALL_OW 233
// PlaceUnitXY ( Gaidar , 2 , 1 , false ) ;
8533: LD_EXP 34
8537: PPUSH
8538: LD_INT 2
8540: PPUSH
8541: LD_INT 1
8543: PPUSH
8544: LD_INT 0
8546: PPUSH
8547: CALL_OW 48
// ComMoveXY ( Gaidar , 19 , 24 ) ;
8551: LD_EXP 34
8555: PPUSH
8556: LD_INT 19
8558: PPUSH
8559: LD_INT 24
8561: PPUSH
8562: CALL_OW 111
// AddComWait ( Gaidar , 0 0$6 ) ;
8566: LD_EXP 34
8570: PPUSH
8571: LD_INT 210
8573: PPUSH
8574: CALL_OW 202
// AddComMoveXY ( Gaidar , 38 , 47 ) ;
8578: LD_EXP 34
8582: PPUSH
8583: LD_INT 38
8585: PPUSH
8586: LD_INT 47
8588: PPUSH
8589: CALL_OW 171
// AddComMoveXY ( Gaidar , 32 , 59 ) ;
8593: LD_EXP 34
8597: PPUSH
8598: LD_INT 32
8600: PPUSH
8601: LD_INT 59
8603: PPUSH
8604: CALL_OW 171
// AddComWait ( Gaidar , 0 0$10 ) ;
8608: LD_EXP 34
8612: PPUSH
8613: LD_INT 350
8615: PPUSH
8616: CALL_OW 202
// AddComMoveXY ( Gaidar , 62 , 116 ) ;
8620: LD_EXP 34
8624: PPUSH
8625: LD_INT 62
8627: PPUSH
8628: LD_INT 116
8630: PPUSH
8631: CALL_OW 171
// AddComMoveXY ( Gaidar , 92 , 177 ) ;
8635: LD_EXP 34
8639: PPUSH
8640: LD_INT 92
8642: PPUSH
8643: LD_INT 177
8645: PPUSH
8646: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8650: LD_INT 35
8652: PPUSH
8653: CALL_OW 67
// until IsDead ( Gaidar ) or IsAt ( Gaidar , 92 , 177 ) ;
8657: LD_EXP 34
8661: PPUSH
8662: CALL_OW 301
8666: PUSH
8667: LD_EXP 34
8671: PPUSH
8672: LD_INT 92
8674: PPUSH
8675: LD_INT 177
8677: PPUSH
8678: CALL_OW 307
8682: OR
8683: IFFALSE 8650
// if IsAt ( Gaidar , 92 , 177 ) then
8685: LD_EXP 34
8689: PPUSH
8690: LD_INT 92
8692: PPUSH
8693: LD_INT 177
8695: PPUSH
8696: CALL_OW 307
8700: IFFALSE 8713
// begin RemoveUnit ( Gaidar ) ;
8702: LD_EXP 34
8706: PPUSH
8707: CALL_OW 64
// exit ;
8711: GO 8735
// end ; gaidarKilled := true ;
8713: LD_ADDR_EXP 14
8717: PUSH
8718: LD_INT 1
8720: ST_TO_ADDR
// ChangeMissionObjectives ( GaidarKilled ) ;
8721: LD_STRING GaidarKilled
8723: PPUSH
8724: CALL_OW 337
// SetAchievement ( ACH_COMMISAR ) ;
8728: LD_STRING ACH_COMMISAR
8730: PPUSH
8731: CALL_OW 543
// end ;
8735: END
// every 0 0$1 trigger See ( 2 , Gaidar ) do
8736: LD_INT 2
8738: PPUSH
8739: LD_EXP 34
8743: PPUSH
8744: CALL_OW 292
8748: IFFALSE 8765
8750: GO 8752
8752: DISABLE
// Say ( Gaidar , DT-objective-1 ) ;
8753: LD_EXP 34
8757: PPUSH
8758: LD_STRING DT-objective-1
8760: PPUSH
8761: CALL_OW 88
8765: END
// every 0 0$5 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) do
8766: LD_INT 22
8768: PUSH
8769: LD_INT 2
8771: PUSH
8772: EMPTY
8773: LIST
8774: LIST
8775: PUSH
8776: LD_INT 2
8778: PUSH
8779: LD_INT 95
8781: PUSH
8782: LD_INT 5
8784: PUSH
8785: EMPTY
8786: LIST
8787: LIST
8788: PUSH
8789: LD_INT 95
8791: PUSH
8792: LD_INT 6
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: PUSH
8799: LD_INT 95
8801: PUSH
8802: LD_INT 7
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: PUSH
8809: EMPTY
8810: LIST
8811: LIST
8812: LIST
8813: LIST
8814: PUSH
8815: EMPTY
8816: LIST
8817: LIST
8818: PPUSH
8819: CALL_OW 69
8823: IFFALSE 8852
8825: GO 8827
8827: DISABLE
// begin Say ( Heike , DH-outpost-last-1 ) ;
8828: LD_EXP 18
8832: PPUSH
8833: LD_STRING DH-outpost-last-1
8835: PPUSH
8836: CALL_OW 88
// SayRadio ( Burlak , DB-outpost-last-2 ) ;
8840: LD_EXP 33
8844: PPUSH
8845: LD_STRING DB-outpost-last-2
8847: PPUSH
8848: CALL_OW 94
// end ;
8852: END
// every 0 0$1 trigger GetLives ( ruMainBase ) < 999 or GetSide ( ruMainBase ) = 2 do var i , tmp ;
8853: LD_INT 200
8855: PPUSH
8856: CALL_OW 256
8860: PUSH
8861: LD_INT 999
8863: LESS
8864: PUSH
8865: LD_INT 200
8867: PPUSH
8868: CALL_OW 255
8872: PUSH
8873: LD_INT 2
8875: EQUAL
8876: OR
8877: IFFALSE 9050
8879: GO 8881
8881: DISABLE
8882: LD_INT 0
8884: PPUSH
8885: PPUSH
// begin if not earlyEscape then
8886: LD_EXP 16
8890: NOT
8891: IFFALSE 8917
// begin SayRadio ( Burlak , DB-end-1 ) ;
8893: LD_EXP 33
8897: PPUSH
8898: LD_STRING DB-end-1
8900: PPUSH
8901: CALL_OW 94
// Say ( Heike , DH-end-2 ) ;
8905: LD_EXP 18
8909: PPUSH
8910: LD_STRING DH-end-2
8912: PPUSH
8913: CALL_OW 88
// end ; if tick <= 15 15$00 then
8917: LD_OWVAR 1
8921: PUSH
8922: LD_INT 31500
8924: LESSEQUAL
8925: IFFALSE 8934
// SetAchievement ( ACH_FIST ) ;
8927: LD_STRING ACH_FIST
8929: PPUSH
8930: CALL_OW 543
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
8934: LD_ADDR_VAR 0 2
8938: PUSH
8939: LD_INT 22
8941: PUSH
8942: LD_INT 3
8944: PUSH
8945: EMPTY
8946: LIST
8947: LIST
8948: PUSH
8949: LD_INT 3
8951: PUSH
8952: LD_INT 21
8954: PUSH
8955: LD_INT 3
8957: PUSH
8958: EMPTY
8959: LIST
8960: LIST
8961: PUSH
8962: EMPTY
8963: LIST
8964: LIST
8965: PUSH
8966: EMPTY
8967: LIST
8968: LIST
8969: PPUSH
8970: CALL_OW 69
8974: ST_TO_ADDR
// if not tmp then
8975: LD_VAR 0 2
8979: NOT
8980: IFFALSE 8984
// exit ;
8982: GO 9050
// for i in tmp do
8984: LD_ADDR_VAR 0 1
8988: PUSH
8989: LD_VAR 0 2
8993: PUSH
8994: FOR_IN
8995: IFFALSE 9048
// begin SetTag ( i , tEscape ) ;
8997: LD_VAR 0 1
9001: PPUSH
9002: LD_EXP 17
9006: PPUSH
9007: CALL_OW 109
// if IsInUnit ( i ) then
9011: LD_VAR 0 1
9015: PPUSH
9016: CALL_OW 310
9020: IFFALSE 9031
// ComExitBuilding ( i ) ;
9022: LD_VAR 0 1
9026: PPUSH
9027: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9031: LD_VAR 0 1
9035: PPUSH
9036: LD_INT 92
9038: PPUSH
9039: LD_INT 177
9041: PPUSH
9042: CALL_OW 171
// end ;
9046: GO 8994
9048: POP
9049: POP
// end ;
9050: PPOPN 2
9052: END
// every 0 0$1 trigger FilterUnitsInArea ( zone1 , [ f_side , 2 ] ) and not outerAreaAchived and IsOk ( Kurt ) do
9053: LD_INT 4
9055: PPUSH
9056: LD_INT 22
9058: PUSH
9059: LD_INT 2
9061: PUSH
9062: EMPTY
9063: LIST
9064: LIST
9065: PPUSH
9066: CALL_OW 70
9070: PUSH
9071: LD_EXP 15
9075: NOT
9076: AND
9077: PUSH
9078: LD_EXP 27
9082: PPUSH
9083: CALL_OW 302
9087: AND
9088: IFFALSE 9308
9090: GO 9092
9092: DISABLE
// begin DialogueOn ;
9093: CALL_OW 6
// ShowArea ( 2 , showDefenceArea ) ;
9097: LD_INT 2
9099: PPUSH
9100: LD_INT 12
9102: PPUSH
9103: CALL_OW 334
// CenterNowOnXY ( 111 , 53 ) ;
9107: LD_INT 111
9109: PPUSH
9110: LD_INT 53
9112: PPUSH
9113: CALL_OW 86
// dwait ( 0 0$0.3 ) ;
9117: LD_INT 10
9119: PPUSH
9120: CALL_OW 68
// Say ( Kurt , DKs-Hannibal-1 ) ;
9124: LD_EXP 27
9128: PPUSH
9129: LD_STRING DKs-Hannibal-1
9131: PPUSH
9132: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-2 ) ;
9136: LD_EXP 27
9140: PPUSH
9141: LD_STRING DKs-Hannibal-2
9143: PPUSH
9144: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-3 ) ;
9148: LD_EXP 27
9152: PPUSH
9153: LD_STRING DKs-Hannibal-3
9155: PPUSH
9156: CALL_OW 88
// Say ( Kurt , DKs-Hannibal-4 ) ;
9160: LD_EXP 27
9164: PPUSH
9165: LD_STRING DKs-Hannibal-4
9167: PPUSH
9168: CALL_OW 88
// dwait ( 0 0$1 ) ;
9172: LD_INT 35
9174: PPUSH
9175: CALL_OW 68
// PlaceSeeing ( 173 , 76 , 2 , - 12 ) ;
9179: LD_INT 173
9181: PPUSH
9182: LD_INT 76
9184: PPUSH
9185: LD_INT 2
9187: PPUSH
9188: LD_INT 12
9190: NEG
9191: PPUSH
9192: CALL_OW 330
// RemoveSeeing ( 173 , 76 , 2 ) ;
9196: LD_INT 173
9198: PPUSH
9199: LD_INT 76
9201: PPUSH
9202: LD_INT 2
9204: PPUSH
9205: CALL_OW 331
// CenterNowOnXY ( 173 , 76 ) ;
9209: LD_INT 173
9211: PPUSH
9212: LD_INT 76
9214: PPUSH
9215: CALL_OW 86
// Say ( Kurt , DKs-Hannibal-5 ) ;
9219: LD_EXP 27
9223: PPUSH
9224: LD_STRING DKs-Hannibal-5
9226: PPUSH
9227: CALL_OW 88
// if Kamil and not FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_flame_thrower ] ] ) then
9231: LD_EXP 22
9235: PUSH
9236: LD_INT 22
9238: PUSH
9239: LD_INT 2
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: PUSH
9246: LD_INT 34
9248: PUSH
9249: LD_INT 26
9251: PUSH
9252: EMPTY
9253: LIST
9254: LIST
9255: PUSH
9256: EMPTY
9257: LIST
9258: LIST
9259: PPUSH
9260: CALL_OW 69
9264: NOT
9265: AND
9266: IFFALSE 9304
// begin Say ( Kamil , DKam-Hannibal-a-6 ) ;
9268: LD_EXP 22
9272: PPUSH
9273: LD_STRING DKam-Hannibal-a-6
9275: PPUSH
9276: CALL_OW 88
// Say ( Kamil , DKam-Hannibal-a-7 ) ;
9280: LD_EXP 22
9284: PPUSH
9285: LD_STRING DKam-Hannibal-a-7
9287: PPUSH
9288: CALL_OW 88
// Say ( Givi , DG-Hannibal-a-8 ) ;
9292: LD_EXP 19
9296: PPUSH
9297: LD_STRING DG-Hannibal-a-8
9299: PPUSH
9300: CALL_OW 88
// end ; DialogueOff ;
9304: CALL_OW 7
// end ;
9308: END
// every 0 0$1 trigger IsOk ( ruSecBase ) and IsOk ( ruMainBase ) and FilterUnitsInArea ( showDefenceArea , [ f_type , unit_building ] ) > 2 and FilterUnitsInArea ( forestArea , [ f_side , 2 ] ) > 3 do
9309: LD_INT 225
9311: PPUSH
9312: CALL_OW 302
9316: PUSH
9317: LD_INT 200
9319: PPUSH
9320: CALL_OW 302
9324: AND
9325: PUSH
9326: LD_INT 12
9328: PPUSH
9329: LD_INT 21
9331: PUSH
9332: LD_INT 3
9334: PUSH
9335: EMPTY
9336: LIST
9337: LIST
9338: PPUSH
9339: CALL_OW 70
9343: PUSH
9344: LD_INT 2
9346: GREATER
9347: AND
9348: PUSH
9349: LD_INT 13
9351: PPUSH
9352: LD_INT 22
9354: PUSH
9355: LD_INT 2
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PPUSH
9362: CALL_OW 70
9366: PUSH
9367: LD_INT 3
9369: GREATER
9370: AND
9371: IFFALSE 9384
9373: GO 9375
9375: DISABLE
// hannibalPath := true ;
9376: LD_ADDR_EXP 9
9380: PUSH
9381: LD_INT 1
9383: ST_TO_ADDR
9384: END
// every 0 0$3 trigger hannibalPath and FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) do var i , tmp , hasFlameThrower ;
9385: LD_EXP 9
9389: PUSH
9390: LD_INT 6
9392: PPUSH
9393: LD_INT 22
9395: PUSH
9396: LD_INT 2
9398: PUSH
9399: EMPTY
9400: LIST
9401: LIST
9402: PPUSH
9403: CALL_OW 70
9407: AND
9408: IFFALSE 9745
9410: GO 9412
9412: DISABLE
9413: LD_INT 0
9415: PPUSH
9416: PPUSH
9417: PPUSH
// begin tmp := FilterUnitsInArea ( zone3 , [ f_side , 2 ] ) ;
9418: LD_ADDR_VAR 0 2
9422: PUSH
9423: LD_INT 6
9425: PPUSH
9426: LD_INT 22
9428: PUSH
9429: LD_INT 2
9431: PUSH
9432: EMPTY
9433: LIST
9434: LIST
9435: PPUSH
9436: CALL_OW 70
9440: ST_TO_ADDR
// hasFlameThrower := UnitFilter ( tmp , [ f_weapon , ar_flame_thrower ] ) > 0 ;
9441: LD_ADDR_VAR 0 3
9445: PUSH
9446: LD_VAR 0 2
9450: PPUSH
9451: LD_INT 34
9453: PUSH
9454: LD_INT 26
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: PPUSH
9461: CALL_OW 72
9465: PUSH
9466: LD_INT 0
9468: GREATER
9469: ST_TO_ADDR
// Say ( Heike , DH-Cleverattack-1 ) ;
9470: LD_EXP 18
9474: PPUSH
9475: LD_STRING DH-Cleverattack-1
9477: PPUSH
9478: CALL_OW 88
// Say ( Heike , DH-Cleverattack-2 ) ;
9482: LD_EXP 18
9486: PPUSH
9487: LD_STRING DH-Cleverattack-2
9489: PPUSH
9490: CALL_OW 88
// if hasFlameThrower then
9494: LD_VAR 0 3
9498: IFFALSE 9526
// begin SayRadio ( Burlak , DB-Cleverattack-3 ) ;
9500: LD_EXP 33
9504: PPUSH
9505: LD_STRING DB-Cleverattack-3
9507: PPUSH
9508: CALL_OW 94
// Say ( Heike , DH-Cleverattack-4 ) ;
9512: LD_EXP 18
9516: PPUSH
9517: LD_STRING DH-Cleverattack-4
9519: PPUSH
9520: CALL_OW 88
// end else
9524: GO 9550
// begin SayRadio ( Burlak , DB-Cleverattack-a-3 ) ;
9526: LD_EXP 33
9530: PPUSH
9531: LD_STRING DB-Cleverattack-a-3
9533: PPUSH
9534: CALL_OW 94
// Say ( Heike , DH-Cleverattack-a-4 ) ;
9538: LD_EXP 18
9542: PPUSH
9543: LD_STRING DH-Cleverattack-a-4
9545: PPUSH
9546: CALL_OW 88
// end ; if not hasFlameThrower then
9550: LD_VAR 0 3
9554: NOT
9555: IFFALSE 9559
// exit ;
9557: GO 9745
// earlyEscape := true ;
9559: LD_ADDR_EXP 16
9563: PUSH
9564: LD_INT 1
9566: ST_TO_ADDR
// wait ( 0 0$4 ) ;
9567: LD_INT 140
9569: PPUSH
9570: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 4 ] ] ] ) diff [ Ibrahim , Kuzmov , Gaidar ] ;
9574: LD_ADDR_VAR 0 2
9578: PUSH
9579: LD_INT 22
9581: PUSH
9582: LD_INT 3
9584: PUSH
9585: EMPTY
9586: LIST
9587: LIST
9588: PUSH
9589: LD_INT 2
9591: PUSH
9592: LD_INT 25
9594: PUSH
9595: LD_INT 1
9597: PUSH
9598: EMPTY
9599: LIST
9600: LIST
9601: PUSH
9602: LD_INT 25
9604: PUSH
9605: LD_INT 2
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: PUSH
9612: LD_INT 25
9614: PUSH
9615: LD_INT 4
9617: PUSH
9618: EMPTY
9619: LIST
9620: LIST
9621: PUSH
9622: EMPTY
9623: LIST
9624: LIST
9625: LIST
9626: LIST
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: PPUSH
9632: CALL_OW 69
9636: PUSH
9637: LD_EXP 21
9641: PUSH
9642: LD_EXP 35
9646: PUSH
9647: LD_EXP 34
9651: PUSH
9652: EMPTY
9653: LIST
9654: LIST
9655: LIST
9656: DIFF
9657: ST_TO_ADDR
// for i in tmp do
9658: LD_ADDR_VAR 0 1
9662: PUSH
9663: LD_VAR 0 2
9667: PUSH
9668: FOR_IN
9669: IFFALSE 9743
// begin if Prob ( 40 + 10 * Difficulty ) then
9671: LD_INT 40
9673: PUSH
9674: LD_INT 10
9676: PUSH
9677: LD_OWVAR 67
9681: MUL
9682: PLUS
9683: PPUSH
9684: CALL_OW 13
9688: IFFALSE 9692
// continue ;
9690: GO 9668
// SetTag ( i , tEscape ) ;
9692: LD_VAR 0 1
9696: PPUSH
9697: LD_EXP 17
9701: PPUSH
9702: CALL_OW 109
// if IsInUnit ( i ) then
9706: LD_VAR 0 1
9710: PPUSH
9711: CALL_OW 310
9715: IFFALSE 9726
// ComExitBuilding ( i ) ;
9717: LD_VAR 0 1
9721: PPUSH
9722: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
9726: LD_VAR 0 1
9730: PPUSH
9731: LD_INT 92
9733: PPUSH
9734: LD_INT 177
9736: PPUSH
9737: CALL_OW 171
// end ;
9741: GO 9668
9743: POP
9744: POP
// end ;
9745: PPOPN 3
9747: END
// every 0 0$1 trigger FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do var i ;
9748: LD_INT 9
9750: PPUSH
9751: LD_INT 2
9753: PUSH
9754: LD_INT 22
9756: PUSH
9757: LD_INT 3
9759: PUSH
9760: EMPTY
9761: LIST
9762: LIST
9763: PUSH
9764: LD_INT 22
9766: PUSH
9767: LD_INT 6
9769: PUSH
9770: EMPTY
9771: LIST
9772: LIST
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: LIST
9778: PPUSH
9779: CALL_OW 70
9783: IFFALSE 9881
9785: GO 9787
9787: DISABLE
9788: LD_INT 0
9790: PPUSH
// begin enable ;
9791: ENABLE
// for i in FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do
9792: LD_ADDR_VAR 0 1
9796: PUSH
9797: LD_INT 9
9799: PPUSH
9800: LD_INT 2
9802: PUSH
9803: LD_INT 22
9805: PUSH
9806: LD_INT 3
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PUSH
9813: LD_INT 22
9815: PUSH
9816: LD_INT 6
9818: PUSH
9819: EMPTY
9820: LIST
9821: LIST
9822: PUSH
9823: EMPTY
9824: LIST
9825: LIST
9826: LIST
9827: PPUSH
9828: CALL_OW 70
9832: PUSH
9833: FOR_IN
9834: IFFALSE 9879
// if GetTag ( i ) = tEscape or GetSide ( i ) = 6 then
9836: LD_VAR 0 1
9840: PPUSH
9841: CALL_OW 110
9845: PUSH
9846: LD_EXP 17
9850: EQUAL
9851: PUSH
9852: LD_VAR 0 1
9856: PPUSH
9857: CALL_OW 255
9861: PUSH
9862: LD_INT 6
9864: EQUAL
9865: OR
9866: IFFALSE 9877
// RemoveUnit ( i ) ;
9868: LD_VAR 0 1
9872: PPUSH
9873: CALL_OW 64
9877: GO 9833
9879: POP
9880: POP
// end ;
9881: PPOPN 1
9883: END
// every 0 0$1 trigger Kaia and GetLives ( Kaia ) < 3 do
9884: LD_EXP 23
9888: PUSH
9889: LD_EXP 23
9893: PPUSH
9894: CALL_OW 256
9898: PUSH
9899: LD_INT 3
9901: LESS
9902: AND
9903: IFFALSE 9949
9905: GO 9907
9907: DISABLE
// begin DialogueOn ;
9908: CALL_OW 6
// CenterNowOnUnits ( Kaia ) ;
9912: LD_EXP 23
9916: PPUSH
9917: CALL_OW 87
// ForceSay ( Kaia , DK-Kkilled-1 ) ;
9921: LD_EXP 23
9925: PPUSH
9926: LD_STRING DK-Kkilled-1
9928: PPUSH
9929: CALL_OW 91
// Say ( Heike , DH-Kkilled-2 ) ;
9933: LD_EXP 18
9937: PPUSH
9938: LD_STRING DH-Kkilled-2
9940: PPUSH
9941: CALL_OW 88
// DialogueOff ;
9945: CALL_OW 7
// end ;
9949: END
// every 0 0$1 trigger kaiaKilledByRussian do
9950: LD_EXP 8
9954: IFFALSE 9971
9956: GO 9958
9958: DISABLE
// Say ( Heike , DH-Kkilled-3 ) ;
9959: LD_EXP 18
9963: PPUSH
9964: LD_STRING DH-Kkilled-3
9966: PPUSH
9967: CALL_OW 88
9971: END
// every 0 0$1 trigger tick >= 22 22$00 do
9972: LD_OWVAR 1
9976: PUSH
9977: LD_INT 46200
9979: GREATEREQUAL
9980: IFFALSE 10009
9982: GO 9984
9984: DISABLE
// begin SayRadio ( Shariff , DShar-slow-1 ) ;
9985: LD_EXP 26
9989: PPUSH
9990: LD_STRING DShar-slow-1
9992: PPUSH
9993: CALL_OW 94
// SayRadio ( Shariff , DShar-slow-2 ) ;
9997: LD_EXP 26
10001: PPUSH
10002: LD_STRING DShar-slow-2
10004: PPUSH
10005: CALL_OW 94
// end ;
10009: END
// every 0 0$1 trigger tick >= [ 40 40$00 , 36 36$00 , 32 32$00 ] [ Difficulty ] do
10010: LD_OWVAR 1
10014: PUSH
10015: LD_INT 84000
10017: PUSH
10018: LD_INT 75600
10020: PUSH
10021: LD_INT 67200
10023: PUSH
10024: EMPTY
10025: LIST
10026: LIST
10027: LIST
10028: PUSH
10029: LD_OWVAR 67
10033: ARRAY
10034: GREATEREQUAL
10035: IFFALSE 10079
10037: GO 10039
10039: DISABLE
// begin DialogueOn ;
10040: CALL_OW 6
// SayRadio ( Shariff , DShar-fail-1 ) ;
10044: LD_EXP 26
10048: PPUSH
10049: LD_STRING DShar-fail-1
10051: PPUSH
10052: CALL_OW 94
// SayRadio ( Shariff , DShar-fail-2 ) ;
10056: LD_EXP 26
10060: PPUSH
10061: LD_STRING DShar-fail-2
10063: PPUSH
10064: CALL_OW 94
// DialogueOff ;
10068: CALL_OW 7
// YouLost ( Time ) ;
10072: LD_STRING Time
10074: PPUSH
10075: CALL_OW 104
// end ;
10079: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) = 0 do var tmp ;
10080: LD_INT 22
10082: PUSH
10083: LD_INT 3
10085: PUSH
10086: EMPTY
10087: LIST
10088: LIST
10089: PUSH
10090: LD_INT 2
10092: PUSH
10093: LD_INT 30
10095: PUSH
10096: LD_INT 1
10098: PUSH
10099: EMPTY
10100: LIST
10101: LIST
10102: PUSH
10103: LD_INT 30
10105: PUSH
10106: LD_INT 0
10108: PUSH
10109: EMPTY
10110: LIST
10111: LIST
10112: PUSH
10113: EMPTY
10114: LIST
10115: LIST
10116: LIST
10117: PUSH
10118: EMPTY
10119: LIST
10120: LIST
10121: PPUSH
10122: CALL_OW 69
10126: PUSH
10127: LD_INT 0
10129: EQUAL
10130: IFFALSE 10621
10132: GO 10134
10134: DISABLE
10135: LD_INT 0
10137: PPUSH
// begin if tick + gameTime <= [ 70 70$00 , 65 65$00 , 60 60$00 ] [ Difficulty ] then
10138: LD_OWVAR 1
10142: PUSH
10143: LD_EXP 5
10147: PLUS
10148: PUSH
10149: LD_INT 147000
10151: PUSH
10152: LD_INT 136500
10154: PUSH
10155: LD_INT 126000
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: LIST
10162: PUSH
10163: LD_OWVAR 67
10167: ARRAY
10168: LESSEQUAL
10169: IFFALSE 10183
// AddMedal ( med1 , 1 ) else
10171: LD_STRING med1
10173: PPUSH
10174: LD_INT 1
10176: PPUSH
10177: CALL_OW 101
10181: GO 10194
// AddMedal ( med1 , - 1 ) ;
10183: LD_STRING med1
10185: PPUSH
10186: LD_INT 1
10188: NEG
10189: PPUSH
10190: CALL_OW 101
// if ( flamethrowers >= 3 ) * baseHill * hannibalPath * ( loseCounter < [ 6 , 5 , 4 ] [ Difficulty ] ) then
10194: LD_EXP 7
10198: PUSH
10199: LD_INT 3
10201: GREATEREQUAL
10202: PUSH
10203: LD_EXP 11
10207: MUL
10208: PUSH
10209: LD_EXP 9
10213: MUL
10214: PUSH
10215: LD_EXP 6
10219: PUSH
10220: LD_INT 6
10222: PUSH
10223: LD_INT 5
10225: PUSH
10226: LD_INT 4
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: LIST
10233: PUSH
10234: LD_OWVAR 67
10238: ARRAY
10239: LESS
10240: MUL
10241: IFFALSE 10255
// AddMedal ( med2 , 1 ) else
10243: LD_STRING med2
10245: PPUSH
10246: LD_INT 1
10248: PPUSH
10249: CALL_OW 101
10253: GO 10266
// AddMedal ( med2 , - 1 ) ;
10255: LD_STRING med2
10257: PPUSH
10258: LD_INT 1
10260: NEG
10261: PPUSH
10262: CALL_OW 101
// if gaidarKilled then
10266: LD_EXP 14
10270: IFFALSE 10284
// AddMedal ( med3 , 1 ) else
10272: LD_STRING med3
10274: PPUSH
10275: LD_INT 1
10277: PPUSH
10278: CALL_OW 101
10282: GO 10295
// AddMedal ( med3 , - 1 ) ;
10284: LD_STRING med3
10286: PPUSH
10287: LD_INT 1
10289: NEG
10290: PPUSH
10291: CALL_OW 101
// GiveMedals ( MAIN ) ;
10295: LD_STRING MAIN
10297: PPUSH
10298: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_nation , 0 ] ] ] ) ) ;
10302: LD_INT 22
10304: PUSH
10305: LD_INT 2
10307: PUSH
10308: EMPTY
10309: LIST
10310: LIST
10311: PUSH
10312: LD_INT 3
10314: PUSH
10315: LD_INT 23
10317: PUSH
10318: LD_INT 0
10320: PUSH
10321: EMPTY
10322: LIST
10323: LIST
10324: PUSH
10325: EMPTY
10326: LIST
10327: LIST
10328: PUSH
10329: EMPTY
10330: LIST
10331: LIST
10332: PPUSH
10333: CALL_OW 69
10337: PPUSH
10338: CALL_OW 43
// SaveCharacters ( Heike , 04_2_Heike ) ;
10342: LD_EXP 18
10346: PPUSH
10347: LD_STRING 04_2_Heike
10349: PPUSH
10350: CALL_OW 38
// if Aviradze then
10354: LD_EXP 28
10358: IFFALSE 10372
// SaveCharacters ( Aviradze , 04_2_Aviradze ) ;
10360: LD_EXP 28
10364: PPUSH
10365: LD_STRING 04_2_Aviradze
10367: PPUSH
10368: CALL_OW 38
// if Ibrahim and GetSide ( Ibrahim ) = 2 then
10372: LD_EXP 21
10376: PUSH
10377: LD_EXP 21
10381: PPUSH
10382: CALL_OW 255
10386: PUSH
10387: LD_INT 2
10389: EQUAL
10390: AND
10391: IFFALSE 10421
// begin if ibrahimOnRuSide then
10393: LD_EXP 3
10397: IFFALSE 10409
// SaveVariable ( true , 04_2_IbrahimJoined ) ;
10399: LD_INT 1
10401: PPUSH
10402: LD_STRING 04_2_IbrahimJoined
10404: PPUSH
10405: CALL_OW 39
// SaveCharacters ( Ibrahim , 04_2_Ibrahim ) ;
10409: LD_EXP 21
10413: PPUSH
10414: LD_STRING 04_2_Ibrahim
10416: PPUSH
10417: CALL_OW 38
// end ; if Kamil then
10421: LD_EXP 22
10425: IFFALSE 10439
// SaveCharacters ( Kamil , 04_2_Kamil ) ;
10427: LD_EXP 22
10431: PPUSH
10432: LD_STRING 04_2_Kamil
10434: PPUSH
10435: CALL_OW 38
// if Sophia then
10439: LD_EXP 24
10443: IFFALSE 10457
// SaveCharacters ( Sophia , 04_2_Sophia ) ;
10445: LD_EXP 24
10449: PPUSH
10450: LD_STRING 04_2_Sophia
10452: PPUSH
10453: CALL_OW 38
// if Kaia then
10457: LD_EXP 23
10461: IFFALSE 10475
// SaveCharacters ( Kaia , 04_2_Kaia ) ;
10463: LD_EXP 23
10467: PPUSH
10468: LD_STRING 04_2_Kaia
10470: PPUSH
10471: CALL_OW 38
// if Givi then
10475: LD_EXP 19
10479: IFFALSE 10493
// SaveCharacters ( Givi , 04_2_Givi ) ;
10481: LD_EXP 19
10485: PPUSH
10486: LD_STRING 04_2_Givi
10488: PPUSH
10489: CALL_OW 38
// if Mike then
10493: LD_EXP 20
10497: IFFALSE 10511
// SaveCharacters ( Mike , 04_2_Mike ) ;
10499: LD_EXP 20
10503: PPUSH
10504: LD_STRING 04_2_Mike
10506: PPUSH
10507: CALL_OW 38
// if Markov then
10511: LD_EXP 25
10515: IFFALSE 10529
// SaveCharacters ( Markov , 04_2_Markov ) ;
10517: LD_EXP 25
10521: PPUSH
10522: LD_STRING 04_2_Markov
10524: PPUSH
10525: CALL_OW 38
// if Kurt then
10529: LD_EXP 27
10533: IFFALSE 10547
// SaveCharacters ( Kurt , 04_2_Kurt ) ;
10535: LD_EXP 27
10539: PPUSH
10540: LD_STRING 04_2_Kurt
10542: PPUSH
10543: CALL_OW 38
// if heikeSecondSquad then
10547: LD_EXP 29
10551: IFFALSE 10565
// SaveCharacters ( heikeSecondSquad , 04_2_others ) ;
10553: LD_EXP 29
10557: PPUSH
10558: LD_STRING 04_2_others
10560: PPUSH
10561: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
10565: LD_ADDR_VAR 0 1
10569: PUSH
10570: LD_INT 22
10572: PUSH
10573: LD_INT 2
10575: PUSH
10576: EMPTY
10577: LIST
10578: LIST
10579: PUSH
10580: LD_INT 23
10582: PUSH
10583: LD_INT 0
10585: PUSH
10586: EMPTY
10587: LIST
10588: LIST
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PPUSH
10594: CALL_OW 69
10598: ST_TO_ADDR
// if tmp then
10599: LD_VAR 0 1
10603: IFFALSE 10617
// SaveCharacters ( tmp , 04_2_apes ) ;
10605: LD_VAR 0 1
10609: PPUSH
10610: LD_STRING 04_2_apes
10612: PPUSH
10613: CALL_OW 38
// YouWin ;
10617: CALL_OW 103
// end ;
10621: PPOPN 1
10623: END
