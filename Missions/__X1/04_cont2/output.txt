// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 41 0 0
// PrepareNature ( natureArea ) ;
   8: LD_INT 2
  10: PPUSH
  11: CALL 449 0 1
// PrepareRussian ;
  15: CALL 2045 0 0
// PrepareArabian ;
  19: CALL 1772 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 2 ) ;
  29: LD_INT 2
  31: PPUSH
  32: CALL_OW 344
// Action ;
  36: CALL 3376 0 0
// end ;
  40: END
// export debug , prefix ; export ibrahimOnRuSide ; function Init ; begin
  41: LD_INT 0
  43: PPUSH
// debug := true ;
  44: LD_ADDR_EXP 1
  48: PUSH
  49: LD_INT 1
  51: ST_TO_ADDR
// prefix := 04_1_ ;
  52: LD_ADDR_EXP 2
  56: PUSH
  57: LD_STRING 04_1_
  59: ST_TO_ADDR
// ibrahimOnRuSide := LoadVariable ( 03_IbrahimHasEscaped , false ) ;
  60: LD_ADDR_EXP 3
  64: PUSH
  65: LD_STRING 03_IbrahimHasEscaped
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: CALL_OW 30
  75: ST_TO_ADDR
// end ; end_of_file
  76: LD_VAR 0 1
  80: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
  81: LD_INT 0
  83: PPUSH
  84: PPUSH
// if exist_mode then
  85: LD_VAR 0 2
  89: IFFALSE 114
// unit := CreateCharacter ( prefix & ident ) else
  91: LD_ADDR_VAR 0 5
  95: PUSH
  96: LD_VAR 0 3
 100: PUSH
 101: LD_VAR 0 1
 105: STR
 106: PPUSH
 107: CALL_OW 34
 111: ST_TO_ADDR
 112: GO 129
// unit := NewCharacter ( ident ) ;
 114: LD_ADDR_VAR 0 5
 118: PUSH
 119: LD_VAR 0 1
 123: PPUSH
 124: CALL_OW 25
 128: ST_TO_ADDR
// result := unit ;
 129: LD_ADDR_VAR 0 4
 133: PUSH
 134: LD_VAR 0 5
 138: ST_TO_ADDR
// end ;
 139: LD_VAR 0 4
 143: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 144: LD_INT 0
 146: PPUSH
// uc_side := side ;
 147: LD_ADDR_OWVAR 20
 151: PUSH
 152: LD_VAR 0 1
 156: ST_TO_ADDR
// uc_nation := nation ;
 157: LD_ADDR_OWVAR 21
 161: PUSH
 162: LD_VAR 0 2
 166: ST_TO_ADDR
// vc_chassis := chassis ;
 167: LD_ADDR_OWVAR 37
 171: PUSH
 172: LD_VAR 0 3
 176: ST_TO_ADDR
// vc_engine := engine ;
 177: LD_ADDR_OWVAR 39
 181: PUSH
 182: LD_VAR 0 4
 186: ST_TO_ADDR
// vc_control := control ;
 187: LD_ADDR_OWVAR 38
 191: PUSH
 192: LD_VAR 0 5
 196: ST_TO_ADDR
// vc_weapon := weapon ;
 197: LD_ADDR_OWVAR 40
 201: PUSH
 202: LD_VAR 0 6
 206: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 207: LD_ADDR_OWVAR 41
 211: PUSH
 212: LD_VAR 0 7
 216: ST_TO_ADDR
// result := CreateVehicle ;
 217: LD_ADDR_VAR 0 8
 221: PUSH
 222: CALL_OW 45
 226: ST_TO_ADDR
// end ;
 227: LD_VAR 0 8
 231: RET
// export function SayX ( units , ident ) ; var i ; begin
 232: LD_INT 0
 234: PPUSH
 235: PPUSH
// result := false ;
 236: LD_ADDR_VAR 0 3
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// if not units then
 244: LD_VAR 0 1
 248: NOT
 249: IFFALSE 253
// exit ;
 251: GO 307
// for i in units do
 253: LD_ADDR_VAR 0 4
 257: PUSH
 258: LD_VAR 0 1
 262: PUSH
 263: FOR_IN
 264: IFFALSE 305
// if IsOk ( i ) then
 266: LD_VAR 0 4
 270: PPUSH
 271: CALL_OW 302
 275: IFFALSE 303
// begin Say ( i , ident ) ;
 277: LD_VAR 0 4
 281: PPUSH
 282: LD_VAR 0 2
 286: PPUSH
 287: CALL_OW 88
// result := i ;
 291: LD_ADDR_VAR 0 3
 295: PUSH
 296: LD_VAR 0 4
 300: ST_TO_ADDR
// break ;
 301: GO 305
// end ;
 303: GO 263
 305: POP
 306: POP
// end ;
 307: LD_VAR 0 3
 311: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 312: LD_INT 0
 314: PPUSH
 315: PPUSH
// InitUc ;
 316: CALL_OW 18
// InitHc ;
 320: CALL_OW 19
// uc_side := 0 ;
 324: LD_ADDR_OWVAR 20
 328: PUSH
 329: LD_INT 0
 331: ST_TO_ADDR
// uc_nation := 0 ;
 332: LD_ADDR_OWVAR 21
 336: PUSH
 337: LD_INT 0
 339: ST_TO_ADDR
// for i = 1 to amount do
 340: LD_ADDR_VAR 0 4
 344: PUSH
 345: DOUBLE
 346: LD_INT 1
 348: DEC
 349: ST_TO_ADDR
 350: LD_VAR 0 2
 354: PUSH
 355: FOR_TO
 356: IFFALSE 438
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 358: LD_ADDR_OWVAR 29
 362: PUSH
 363: LD_INT 9
 365: PPUSH
 366: LD_INT 12
 368: PPUSH
 369: CALL_OW 12
 373: PUSH
 374: LD_INT 9
 376: PPUSH
 377: LD_INT 12
 379: PPUSH
 380: CALL_OW 12
 384: PUSH
 385: EMPTY
 386: LIST
 387: LIST
 388: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 389: LD_ADDR_OWVAR 35
 393: PUSH
 394: LD_INT 1
 396: NEG
 397: PPUSH
 398: LD_INT 1
 400: PPUSH
 401: CALL_OW 12
 405: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 406: LD_INT 0
 408: PPUSH
 409: LD_INT 12
 411: PPUSH
 412: LD_INT 1
 414: PPUSH
 415: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 419: CALL_OW 44
 423: PPUSH
 424: LD_VAR 0 1
 428: PPUSH
 429: LD_INT 0
 431: PPUSH
 432: CALL_OW 49
// end ;
 436: GO 355
 438: POP
 439: POP
// InitHc ;
 440: CALL_OW 19
// end ;
 444: LD_VAR 0 3
 448: RET
// export function PrepareNature ( forest ) ; var i ; begin
 449: LD_INT 0
 451: PPUSH
 452: PPUSH
// SpawnApeman ( forest , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
 453: LD_VAR 0 1
 457: PPUSH
 458: LD_INT 3
 460: PUSH
 461: LD_INT 3
 463: PUSH
 464: LD_INT 2
 466: PUSH
 467: EMPTY
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_OWVAR 67
 476: ARRAY
 477: PPUSH
 478: CALL 312 0 2
// for i := 1 to 2 do
 482: LD_ADDR_VAR 0 3
 486: PUSH
 487: DOUBLE
 488: LD_INT 1
 490: DEC
 491: ST_TO_ADDR
 492: LD_INT 2
 494: PUSH
 495: FOR_TO
 496: IFFALSE 533
// begin hc_class := 21 ;
 498: LD_ADDR_OWVAR 28
 502: PUSH
 503: LD_INT 21
 505: ST_TO_ADDR
// hc_gallery :=  ;
 506: LD_ADDR_OWVAR 33
 510: PUSH
 511: LD_STRING 
 513: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 514: CALL_OW 44
 518: PPUSH
 519: LD_VAR 0 1
 523: PPUSH
 524: LD_INT 0
 526: PPUSH
 527: CALL_OW 49
// end ;
 531: GO 495
 533: POP
 534: POP
// for i := 1 to 2 do
 535: LD_ADDR_VAR 0 3
 539: PUSH
 540: DOUBLE
 541: LD_INT 1
 543: DEC
 544: ST_TO_ADDR
 545: LD_INT 2
 547: PUSH
 548: FOR_TO
 549: IFFALSE 586
// begin hc_class := 18 ;
 551: LD_ADDR_OWVAR 28
 555: PUSH
 556: LD_INT 18
 558: ST_TO_ADDR
// hc_gallery :=  ;
 559: LD_ADDR_OWVAR 33
 563: PUSH
 564: LD_STRING 
 566: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 567: CALL_OW 44
 571: PPUSH
 572: LD_VAR 0 1
 576: PPUSH
 577: LD_INT 0
 579: PPUSH
 580: CALL_OW 49
// end ;
 584: GO 548
 586: POP
 587: POP
// for i := 1 to 2 do
 588: LD_ADDR_VAR 0 3
 592: PUSH
 593: DOUBLE
 594: LD_INT 1
 596: DEC
 597: ST_TO_ADDR
 598: LD_INT 2
 600: PUSH
 601: FOR_TO
 602: IFFALSE 639
// begin hc_class := 13 ;
 604: LD_ADDR_OWVAR 28
 608: PUSH
 609: LD_INT 13
 611: ST_TO_ADDR
// hc_gallery :=  ;
 612: LD_ADDR_OWVAR 33
 616: PUSH
 617: LD_STRING 
 619: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 620: CALL_OW 44
 624: PPUSH
 625: LD_VAR 0 1
 629: PPUSH
 630: LD_INT 0
 632: PPUSH
 633: CALL_OW 49
// end ;
 637: GO 601
 639: POP
 640: POP
// end ;
 641: LD_VAR 0 2
 645: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 646: LD_INT 0
 648: PPUSH
 649: PPUSH
 650: PPUSH
// if not observer or not unit then
 651: LD_VAR 0 1
 655: NOT
 656: PUSH
 657: LD_VAR 0 2
 661: NOT
 662: OR
 663: IFFALSE 667
// exit ;
 665: GO 715
// if not See ( GetSide ( observer ) , unit ) then
 667: LD_VAR 0 1
 671: PPUSH
 672: CALL_OW 255
 676: PPUSH
 677: LD_VAR 0 2
 681: PPUSH
 682: CALL_OW 292
 686: NOT
 687: IFFALSE 691
// exit ;
 689: GO 715
// result := GetDistUnits ( observer , unit ) < 12 ;
 691: LD_ADDR_VAR 0 3
 695: PUSH
 696: LD_VAR 0 1
 700: PPUSH
 701: LD_VAR 0 2
 705: PPUSH
 706: CALL_OW 296
 710: PUSH
 711: LD_INT 12
 713: LESS
 714: ST_TO_ADDR
// end ;
 715: LD_VAR 0 3
 719: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 720: LD_INT 0
 722: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 723: LD_VAR 0 2
 727: PUSH
 728: LD_INT 1
 730: ARRAY
 731: PPUSH
 732: LD_VAR 0 2
 736: PUSH
 737: LD_INT 2
 739: ARRAY
 740: PPUSH
 741: CALL_OW 488
 745: PUSH
 746: LD_VAR 0 2
 750: PUSH
 751: LD_INT 1
 753: ARRAY
 754: PPUSH
 755: LD_VAR 0 2
 759: PUSH
 760: LD_INT 2
 762: ARRAY
 763: PPUSH
 764: CALL_OW 428
 768: PUSH
 769: LD_INT 0
 771: EQUAL
 772: AND
 773: IFFALSE 807
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 775: LD_VAR 0 1
 779: PPUSH
 780: LD_VAR 0 2
 784: PUSH
 785: LD_INT 1
 787: ARRAY
 788: PPUSH
 789: LD_VAR 0 2
 793: PUSH
 794: LD_INT 2
 796: ARRAY
 797: PPUSH
 798: LD_VAR 0 3
 802: PPUSH
 803: CALL_OW 48
// end ;
 807: LD_VAR 0 4
 811: RET
// export function Video ( mode ) ; begin
 812: LD_INT 0
 814: PPUSH
// ingame_video = mode ;
 815: LD_ADDR_OWVAR 52
 819: PUSH
 820: LD_VAR 0 1
 824: ST_TO_ADDR
// interface_hidden = mode ;
 825: LD_ADDR_OWVAR 54
 829: PUSH
 830: LD_VAR 0 1
 834: ST_TO_ADDR
// end ;
 835: LD_VAR 0 2
 839: RET
// export function ReverseArray ( array ) ; var i ; begin
 840: LD_INT 0
 842: PPUSH
 843: PPUSH
// if not array then
 844: LD_VAR 0 1
 848: NOT
 849: IFFALSE 853
// exit ;
 851: GO 911
// result := [ ] ;
 853: LD_ADDR_VAR 0 2
 857: PUSH
 858: EMPTY
 859: ST_TO_ADDR
// for i := 1 to array do
 860: LD_ADDR_VAR 0 3
 864: PUSH
 865: DOUBLE
 866: LD_INT 1
 868: DEC
 869: ST_TO_ADDR
 870: LD_VAR 0 1
 874: PUSH
 875: FOR_TO
 876: IFFALSE 909
// result := Insert ( result , 1 , array [ i ] ) ;
 878: LD_ADDR_VAR 0 2
 882: PUSH
 883: LD_VAR 0 2
 887: PPUSH
 888: LD_INT 1
 890: PPUSH
 891: LD_VAR 0 1
 895: PUSH
 896: LD_VAR 0 3
 900: ARRAY
 901: PPUSH
 902: CALL_OW 2
 906: ST_TO_ADDR
 907: GO 875
 909: POP
 910: POP
// end ;
 911: LD_VAR 0 2
 915: RET
// export function ComExit ( unit ) ; begin
 916: LD_INT 0
 918: PPUSH
// result := IsInUnit ( unit ) ;
 919: LD_ADDR_VAR 0 2
 923: PUSH
 924: LD_VAR 0 1
 928: PPUSH
 929: CALL_OW 310
 933: ST_TO_ADDR
// if not result then
 934: LD_VAR 0 2
 938: NOT
 939: IFFALSE 943
// exit ;
 941: GO 978
// if GetType ( result ) = unit_vehicle then
 943: LD_VAR 0 2
 947: PPUSH
 948: CALL_OW 247
 952: PUSH
 953: LD_INT 2
 955: EQUAL
 956: IFFALSE 969
// ComExitVehicle ( unit ) else
 958: LD_VAR 0 1
 962: PPUSH
 963: CALL_OW 121
 967: GO 978
// ComExitBuilding ( unit ) ;
 969: LD_VAR 0 1
 973: PPUSH
 974: CALL_OW 122
// end ;
 978: LD_VAR 0 2
 982: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
 983: LD_INT 0
 985: PPUSH
 986: PPUSH
// if not side or not nation then
 987: LD_VAR 0 1
 991: NOT
 992: PUSH
 993: LD_VAR 0 2
 997: NOT
 998: OR
 999: IFFALSE 1003
// exit ;
1001: GO 1767
// case nation of nation_american :
1003: LD_VAR 0 2
1007: PUSH
1008: LD_INT 1
1010: DOUBLE
1011: EQUAL
1012: IFTRUE 1016
1014: GO 1230
1016: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1017: LD_ADDR_VAR 0 4
1021: PUSH
1022: LD_INT 35
1024: PUSH
1025: LD_INT 45
1027: PUSH
1028: LD_INT 46
1030: PUSH
1031: LD_INT 47
1033: PUSH
1034: LD_INT 82
1036: PUSH
1037: LD_INT 83
1039: PUSH
1040: LD_INT 84
1042: PUSH
1043: LD_INT 85
1045: PUSH
1046: LD_INT 86
1048: PUSH
1049: LD_INT 1
1051: PUSH
1052: LD_INT 2
1054: PUSH
1055: LD_INT 6
1057: PUSH
1058: LD_INT 15
1060: PUSH
1061: LD_INT 16
1063: PUSH
1064: LD_INT 7
1066: PUSH
1067: LD_INT 12
1069: PUSH
1070: LD_INT 13
1072: PUSH
1073: LD_INT 10
1075: PUSH
1076: LD_INT 14
1078: PUSH
1079: LD_INT 20
1081: PUSH
1082: LD_INT 21
1084: PUSH
1085: LD_INT 22
1087: PUSH
1088: LD_INT 25
1090: PUSH
1091: LD_INT 32
1093: PUSH
1094: LD_INT 27
1096: PUSH
1097: LD_INT 36
1099: PUSH
1100: LD_INT 69
1102: PUSH
1103: LD_INT 39
1105: PUSH
1106: LD_INT 34
1108: PUSH
1109: LD_INT 40
1111: PUSH
1112: LD_INT 48
1114: PUSH
1115: LD_INT 49
1117: PUSH
1118: LD_INT 50
1120: PUSH
1121: LD_INT 51
1123: PUSH
1124: LD_INT 52
1126: PUSH
1127: LD_INT 53
1129: PUSH
1130: LD_INT 54
1132: PUSH
1133: LD_INT 55
1135: PUSH
1136: LD_INT 56
1138: PUSH
1139: LD_INT 57
1141: PUSH
1142: LD_INT 58
1144: PUSH
1145: LD_INT 59
1147: PUSH
1148: LD_INT 60
1150: PUSH
1151: LD_INT 61
1153: PUSH
1154: LD_INT 62
1156: PUSH
1157: LD_INT 80
1159: PUSH
1160: LD_INT 82
1162: PUSH
1163: LD_INT 83
1165: PUSH
1166: LD_INT 84
1168: PUSH
1169: LD_INT 85
1171: PUSH
1172: LD_INT 86
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: LIST
1227: ST_TO_ADDR
1228: GO 1691
1230: LD_INT 2
1232: DOUBLE
1233: EQUAL
1234: IFTRUE 1238
1236: GO 1460
1238: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1239: LD_ADDR_VAR 0 4
1243: PUSH
1244: LD_INT 35
1246: PUSH
1247: LD_INT 45
1249: PUSH
1250: LD_INT 46
1252: PUSH
1253: LD_INT 47
1255: PUSH
1256: LD_INT 82
1258: PUSH
1259: LD_INT 83
1261: PUSH
1262: LD_INT 84
1264: PUSH
1265: LD_INT 85
1267: PUSH
1268: LD_INT 87
1270: PUSH
1271: LD_INT 70
1273: PUSH
1274: LD_INT 1
1276: PUSH
1277: LD_INT 11
1279: PUSH
1280: LD_INT 3
1282: PUSH
1283: LD_INT 4
1285: PUSH
1286: LD_INT 5
1288: PUSH
1289: LD_INT 6
1291: PUSH
1292: LD_INT 15
1294: PUSH
1295: LD_INT 18
1297: PUSH
1298: LD_INT 7
1300: PUSH
1301: LD_INT 17
1303: PUSH
1304: LD_INT 8
1306: PUSH
1307: LD_INT 20
1309: PUSH
1310: LD_INT 21
1312: PUSH
1313: LD_INT 22
1315: PUSH
1316: LD_INT 72
1318: PUSH
1319: LD_INT 26
1321: PUSH
1322: LD_INT 69
1324: PUSH
1325: LD_INT 39
1327: PUSH
1328: LD_INT 40
1330: PUSH
1331: LD_INT 41
1333: PUSH
1334: LD_INT 42
1336: PUSH
1337: LD_INT 43
1339: PUSH
1340: LD_INT 48
1342: PUSH
1343: LD_INT 49
1345: PUSH
1346: LD_INT 50
1348: PUSH
1349: LD_INT 51
1351: PUSH
1352: LD_INT 52
1354: PUSH
1355: LD_INT 53
1357: PUSH
1358: LD_INT 54
1360: PUSH
1361: LD_INT 55
1363: PUSH
1364: LD_INT 56
1366: PUSH
1367: LD_INT 60
1369: PUSH
1370: LD_INT 61
1372: PUSH
1373: LD_INT 62
1375: PUSH
1376: LD_INT 66
1378: PUSH
1379: LD_INT 67
1381: PUSH
1382: LD_INT 68
1384: PUSH
1385: LD_INT 81
1387: PUSH
1388: LD_INT 82
1390: PUSH
1391: LD_INT 83
1393: PUSH
1394: LD_INT 84
1396: PUSH
1397: LD_INT 85
1399: PUSH
1400: LD_INT 87
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: LIST
1451: LIST
1452: LIST
1453: LIST
1454: LIST
1455: LIST
1456: LIST
1457: ST_TO_ADDR
1458: GO 1691
1460: LD_INT 3
1462: DOUBLE
1463: EQUAL
1464: IFTRUE 1468
1466: GO 1690
1468: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1469: LD_ADDR_VAR 0 4
1473: PUSH
1474: LD_INT 46
1476: PUSH
1477: LD_INT 47
1479: PUSH
1480: LD_INT 1
1482: PUSH
1483: LD_INT 2
1485: PUSH
1486: LD_INT 82
1488: PUSH
1489: LD_INT 83
1491: PUSH
1492: LD_INT 84
1494: PUSH
1495: LD_INT 85
1497: PUSH
1498: LD_INT 86
1500: PUSH
1501: LD_INT 11
1503: PUSH
1504: LD_INT 9
1506: PUSH
1507: LD_INT 20
1509: PUSH
1510: LD_INT 19
1512: PUSH
1513: LD_INT 21
1515: PUSH
1516: LD_INT 24
1518: PUSH
1519: LD_INT 22
1521: PUSH
1522: LD_INT 25
1524: PUSH
1525: LD_INT 28
1527: PUSH
1528: LD_INT 29
1530: PUSH
1531: LD_INT 30
1533: PUSH
1534: LD_INT 31
1536: PUSH
1537: LD_INT 37
1539: PUSH
1540: LD_INT 38
1542: PUSH
1543: LD_INT 32
1545: PUSH
1546: LD_INT 27
1548: PUSH
1549: LD_INT 33
1551: PUSH
1552: LD_INT 69
1554: PUSH
1555: LD_INT 39
1557: PUSH
1558: LD_INT 34
1560: PUSH
1561: LD_INT 40
1563: PUSH
1564: LD_INT 71
1566: PUSH
1567: LD_INT 23
1569: PUSH
1570: LD_INT 44
1572: PUSH
1573: LD_INT 48
1575: PUSH
1576: LD_INT 49
1578: PUSH
1579: LD_INT 50
1581: PUSH
1582: LD_INT 51
1584: PUSH
1585: LD_INT 52
1587: PUSH
1588: LD_INT 53
1590: PUSH
1591: LD_INT 54
1593: PUSH
1594: LD_INT 55
1596: PUSH
1597: LD_INT 56
1599: PUSH
1600: LD_INT 57
1602: PUSH
1603: LD_INT 58
1605: PUSH
1606: LD_INT 59
1608: PUSH
1609: LD_INT 63
1611: PUSH
1612: LD_INT 64
1614: PUSH
1615: LD_INT 65
1617: PUSH
1618: LD_INT 82
1620: PUSH
1621: LD_INT 83
1623: PUSH
1624: LD_INT 84
1626: PUSH
1627: LD_INT 85
1629: PUSH
1630: LD_INT 86
1632: PUSH
1633: EMPTY
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: LIST
1681: LIST
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: LIST
1687: ST_TO_ADDR
1688: GO 1691
1690: POP
// if state > - 1 and state < 3 then
1691: LD_VAR 0 3
1695: PUSH
1696: LD_INT 1
1698: NEG
1699: GREATER
1700: PUSH
1701: LD_VAR 0 3
1705: PUSH
1706: LD_INT 3
1708: LESS
1709: AND
1710: IFFALSE 1767
// for i in result do
1712: LD_ADDR_VAR 0 5
1716: PUSH
1717: LD_VAR 0 4
1721: PUSH
1722: FOR_IN
1723: IFFALSE 1765
// if GetTech ( i , side ) <> state then
1725: LD_VAR 0 5
1729: PPUSH
1730: LD_VAR 0 1
1734: PPUSH
1735: CALL_OW 321
1739: PUSH
1740: LD_VAR 0 3
1744: NONEQUAL
1745: IFFALSE 1763
// result := result diff i ;
1747: LD_ADDR_VAR 0 4
1751: PUSH
1752: LD_VAR 0 4
1756: PUSH
1757: LD_VAR 0 5
1761: DIFF
1762: ST_TO_ADDR
1763: GO 1722
1765: POP
1766: POP
// end ; end_of_file
1767: LD_VAR 0 4
1771: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Omar , Kurt , Aviradze , heikeSecondSquad ; export function PrepareArabian ; var i ; begin
1772: LD_INT 0
1774: PPUSH
1775: PPUSH
// uc_side := 2 ;
1776: LD_ADDR_OWVAR 20
1780: PUSH
1781: LD_INT 2
1783: ST_TO_ADDR
// uc_nation := 2 ;
1784: LD_ADDR_OWVAR 21
1788: PUSH
1789: LD_INT 2
1791: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
1792: LD_ADDR_EXP 4
1796: PUSH
1797: LD_STRING Heike
1799: PPUSH
1800: LD_EXP 1
1804: NOT
1805: PPUSH
1806: LD_EXP 2
1810: PPUSH
1811: CALL 81 0 3
1815: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
1816: LD_ADDR_EXP 7
1820: PUSH
1821: LD_STRING Ibrahim
1823: PPUSH
1824: LD_EXP 1
1828: NOT
1829: PPUSH
1830: LD_EXP 2
1834: PPUSH
1835: CALL 81 0 3
1839: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
1840: LD_ADDR_EXP 5
1844: PUSH
1845: LD_STRING Givi
1847: PPUSH
1848: LD_EXP 1
1852: NOT
1853: PPUSH
1854: LD_EXP 2
1858: PPUSH
1859: CALL 81 0 3
1863: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
1864: LD_ADDR_EXP 8
1868: PUSH
1869: LD_STRING Kamil
1871: PPUSH
1872: LD_EXP 1
1876: NOT
1877: PPUSH
1878: LD_EXP 2
1882: PPUSH
1883: CALL 81 0 3
1887: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
1888: LD_ADDR_EXP 9
1892: PUSH
1893: LD_STRING Kaia
1895: PPUSH
1896: LD_EXP 1
1900: NOT
1901: PPUSH
1902: LD_EXP 2
1906: PPUSH
1907: CALL 81 0 3
1911: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
1912: LD_ADDR_EXP 10
1916: PUSH
1917: LD_STRING Sophia
1919: PPUSH
1920: LD_EXP 1
1924: NOT
1925: PPUSH
1926: LD_EXP 2
1930: PPUSH
1931: CALL 81 0 3
1935: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
1936: LD_ADDR_EXP 11
1940: PUSH
1941: LD_STRING Markov
1943: PPUSH
1944: LD_EXP 1
1948: NOT
1949: PPUSH
1950: LD_EXP 2
1954: PPUSH
1955: CALL 81 0 3
1959: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
1960: LD_ADDR_EXP 14
1964: PUSH
1965: LD_STRING Aviradze
1967: PPUSH
1968: LD_EXP 1
1972: NOT
1973: PPUSH
1974: LD_EXP 2
1978: PPUSH
1979: CALL 81 0 3
1983: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , false ,  ) ;
1984: LD_ADDR_EXP 13
1988: PUSH
1989: LD_STRING Kurt
1991: PPUSH
1992: LD_INT 0
1994: PPUSH
1995: LD_STRING 
1997: PPUSH
1998: CALL 81 0 3
2002: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2003: LD_ADDR_EXP 6
2007: PUSH
2008: LD_STRING Mike
2010: PPUSH
2011: LD_EXP 1
2015: NOT
2016: PPUSH
2017: LD_EXP 2
2021: PPUSH
2022: CALL 81 0 3
2026: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_1_others ) ;
2027: LD_ADDR_EXP 15
2031: PUSH
2032: LD_STRING 04_1_others
2034: PPUSH
2035: CALL_OW 31
2039: ST_TO_ADDR
// end ; end_of_file
2040: LD_VAR 0 1
2044: RET
// export Burlak , Gaidar , Kuzmov ; export ruForce , ruEng , ruMech , ruSci , ruMobile ; export ruSol ; export function PrepareRussian ; var base , blist , i , b , un , tmp ; begin
2045: LD_INT 0
2047: PPUSH
2048: PPUSH
2049: PPUSH
2050: PPUSH
2051: PPUSH
2052: PPUSH
2053: PPUSH
// uc_side := 3 ;
2054: LD_ADDR_OWVAR 20
2058: PUSH
2059: LD_INT 3
2061: ST_TO_ADDR
// uc_nation := 3 ;
2062: LD_ADDR_OWVAR 21
2066: PUSH
2067: LD_INT 3
2069: ST_TO_ADDR
// ruForce := [ ] ;
2070: LD_ADDR_EXP 19
2074: PUSH
2075: EMPTY
2076: ST_TO_ADDR
// ruMech := [ ] ;
2077: LD_ADDR_EXP 21
2081: PUSH
2082: EMPTY
2083: ST_TO_ADDR
// ruEng := [ ] ;
2084: LD_ADDR_EXP 20
2088: PUSH
2089: EMPTY
2090: ST_TO_ADDR
// ruSci := [ ] ;
2091: LD_ADDR_EXP 22
2095: PUSH
2096: EMPTY
2097: ST_TO_ADDR
// ruMobile := [ ] ;
2098: LD_ADDR_EXP 23
2102: PUSH
2103: EMPTY
2104: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ,  ) ;
2105: LD_ADDR_EXP 16
2109: PUSH
2110: LD_STRING Burlak
2112: PPUSH
2113: LD_INT 0
2115: PPUSH
2116: LD_STRING 
2118: PPUSH
2119: CALL 81 0 3
2123: ST_TO_ADDR
// Gaidar := PrepareUnit ( Gaydar , false ,  ) ;
2124: LD_ADDR_EXP 17
2128: PUSH
2129: LD_STRING Gaydar
2131: PPUSH
2132: LD_INT 0
2134: PPUSH
2135: LD_STRING 
2137: PPUSH
2138: CALL 81 0 3
2142: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , false ,  ) ;
2143: LD_ADDR_EXP 18
2147: PUSH
2148: LD_STRING Kuzmov
2150: PPUSH
2151: LD_INT 0
2153: PPUSH
2154: LD_STRING 
2156: PPUSH
2157: CALL 81 0 3
2161: ST_TO_ADDR
// PlaceHumanInUnit ( Kuzmov , ruMainBase ) ;
2162: LD_EXP 18
2166: PPUSH
2167: LD_INT 200
2169: PPUSH
2170: CALL_OW 52
// SetBName ( ruMainBase , chuikov ) ;
2174: LD_INT 200
2176: PPUSH
2177: LD_STRING chuikov
2179: PPUSH
2180: CALL_OW 500
// if Difficulty > 1 then
2184: LD_OWVAR 67
2188: PUSH
2189: LD_INT 1
2191: GREATER
2192: IFFALSE 2287
// begin bc_type := b_bunker ;
2194: LD_ADDR_OWVAR 42
2198: PUSH
2199: LD_INT 32
2201: ST_TO_ADDR
// tmp := [ [ 121 , 85 , 5 ] , [ 93 , 72 , 1 ] ] ;
2202: LD_ADDR_VAR 0 7
2206: PUSH
2207: LD_INT 121
2209: PUSH
2210: LD_INT 85
2212: PUSH
2213: LD_INT 5
2215: PUSH
2216: EMPTY
2217: LIST
2218: LIST
2219: LIST
2220: PUSH
2221: LD_INT 93
2223: PUSH
2224: LD_INT 72
2226: PUSH
2227: LD_INT 1
2229: PUSH
2230: EMPTY
2231: LIST
2232: LIST
2233: LIST
2234: PUSH
2235: EMPTY
2236: LIST
2237: LIST
2238: ST_TO_ADDR
// for i in tmp do
2239: LD_ADDR_VAR 0 4
2243: PUSH
2244: LD_VAR 0 7
2248: PUSH
2249: FOR_IN
2250: IFFALSE 2285
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
2252: LD_VAR 0 4
2256: PUSH
2257: LD_INT 1
2259: ARRAY
2260: PPUSH
2261: LD_VAR 0 4
2265: PUSH
2266: LD_INT 2
2268: ARRAY
2269: PPUSH
2270: LD_VAR 0 4
2274: PUSH
2275: LD_INT 3
2277: ARRAY
2278: PPUSH
2279: CALL_OW 47
2283: GO 2249
2285: POP
2286: POP
// end ; base := GetBase ( ruMainBase ) ;
2287: LD_ADDR_VAR 0 2
2291: PUSH
2292: LD_INT 200
2294: PPUSH
2295: CALL_OW 274
2299: ST_TO_ADDR
// blist := GetBuildList ( base ) ;
2300: LD_ADDR_VAR 0 3
2304: PUSH
2305: LD_VAR 0 2
2309: PPUSH
2310: CALL_OW 417
2314: ST_TO_ADDR
// for b in blist do
2315: LD_ADDR_VAR 0 5
2319: PUSH
2320: LD_VAR 0 3
2324: PUSH
2325: FOR_IN
2326: IFFALSE 2713
// begin if b [ 1 ] = b_factory then
2328: LD_VAR 0 5
2332: PUSH
2333: LD_INT 1
2335: ARRAY
2336: PUSH
2337: LD_INT 3
2339: EQUAL
2340: IFFALSE 2454
// begin for i := 1 to 5 do
2342: LD_ADDR_VAR 0 4
2346: PUSH
2347: DOUBLE
2348: LD_INT 1
2350: DEC
2351: ST_TO_ADDR
2352: LD_INT 5
2354: PUSH
2355: FOR_TO
2356: IFFALSE 2450
// begin PrepareHuman ( false , 3 , 1 + Difficulty ) ;
2358: LD_INT 0
2360: PPUSH
2361: LD_INT 3
2363: PPUSH
2364: LD_INT 1
2366: PUSH
2367: LD_OWVAR 67
2371: PLUS
2372: PPUSH
2373: CALL_OW 380
// un := CreateHuman ;
2377: LD_ADDR_VAR 0 6
2381: PUSH
2382: CALL_OW 44
2386: ST_TO_ADDR
// ruMech := Replace ( ruMech , ruMech + 1 , un ) ;
2387: LD_ADDR_EXP 21
2391: PUSH
2392: LD_EXP 21
2396: PPUSH
2397: LD_EXP 21
2401: PUSH
2402: LD_INT 1
2404: PLUS
2405: PPUSH
2406: LD_VAR 0 6
2410: PPUSH
2411: CALL_OW 1
2415: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
2416: LD_VAR 0 6
2420: PPUSH
2421: LD_VAR 0 5
2425: PUSH
2426: LD_INT 2
2428: ARRAY
2429: PPUSH
2430: LD_VAR 0 5
2434: PUSH
2435: LD_INT 3
2437: ARRAY
2438: PPUSH
2439: CALL_OW 428
2443: PPUSH
2444: CALL_OW 52
// end ;
2448: GO 2355
2450: POP
2451: POP
// end else
2452: GO 2711
// if b [ 1 ] in [ b_lab , b_lab_half , b_lab_full , b_lab_weapon ] then
2454: LD_VAR 0 5
2458: PUSH
2459: LD_INT 1
2461: ARRAY
2462: PUSH
2463: LD_INT 6
2465: PUSH
2466: LD_INT 7
2468: PUSH
2469: LD_INT 8
2471: PUSH
2472: LD_INT 10
2474: PUSH
2475: EMPTY
2476: LIST
2477: LIST
2478: LIST
2479: LIST
2480: IN
2481: IFFALSE 2591
// begin for i := 1 to 2 do
2483: LD_ADDR_VAR 0 4
2487: PUSH
2488: DOUBLE
2489: LD_INT 1
2491: DEC
2492: ST_TO_ADDR
2493: LD_INT 2
2495: PUSH
2496: FOR_TO
2497: IFFALSE 2587
// begin PrepareHuman ( false , 4 , Difficulty ) ;
2499: LD_INT 0
2501: PPUSH
2502: LD_INT 4
2504: PPUSH
2505: LD_OWVAR 67
2509: PPUSH
2510: CALL_OW 380
// un := CreateHuman ;
2514: LD_ADDR_VAR 0 6
2518: PUSH
2519: CALL_OW 44
2523: ST_TO_ADDR
// ruSci := Replace ( ruSci , ruSci + 1 , un ) ;
2524: LD_ADDR_EXP 22
2528: PUSH
2529: LD_EXP 22
2533: PPUSH
2534: LD_EXP 22
2538: PUSH
2539: LD_INT 1
2541: PLUS
2542: PPUSH
2543: LD_VAR 0 6
2547: PPUSH
2548: CALL_OW 1
2552: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
2553: LD_VAR 0 6
2557: PPUSH
2558: LD_VAR 0 5
2562: PUSH
2563: LD_INT 2
2565: ARRAY
2566: PPUSH
2567: LD_VAR 0 5
2571: PUSH
2572: LD_INT 3
2574: ARRAY
2575: PPUSH
2576: CALL_OW 428
2580: PPUSH
2581: CALL_OW 52
// end ;
2585: GO 2496
2587: POP
2588: POP
// end else
2589: GO 2711
// if b [ 1 ] = b_warehouse then
2591: LD_VAR 0 5
2595: PUSH
2596: LD_INT 1
2598: ARRAY
2599: PUSH
2600: LD_INT 1
2602: EQUAL
2603: IFFALSE 2711
// begin for i := 1 to 3 do
2605: LD_ADDR_VAR 0 4
2609: PUSH
2610: DOUBLE
2611: LD_INT 1
2613: DEC
2614: ST_TO_ADDR
2615: LD_INT 3
2617: PUSH
2618: FOR_TO
2619: IFFALSE 2709
// begin PrepareHuman ( false , 2 , Difficulty ) ;
2621: LD_INT 0
2623: PPUSH
2624: LD_INT 2
2626: PPUSH
2627: LD_OWVAR 67
2631: PPUSH
2632: CALL_OW 380
// un := CreateHuman ;
2636: LD_ADDR_VAR 0 6
2640: PUSH
2641: CALL_OW 44
2645: ST_TO_ADDR
// ruEng := Replace ( ruEng , ruEng + 1 , un ) ;
2646: LD_ADDR_EXP 20
2650: PUSH
2651: LD_EXP 20
2655: PPUSH
2656: LD_EXP 20
2660: PUSH
2661: LD_INT 1
2663: PLUS
2664: PPUSH
2665: LD_VAR 0 6
2669: PPUSH
2670: CALL_OW 1
2674: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
2675: LD_VAR 0 6
2679: PPUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_INT 2
2687: ARRAY
2688: PPUSH
2689: LD_VAR 0 5
2693: PUSH
2694: LD_INT 3
2696: ARRAY
2697: PPUSH
2698: CALL_OW 428
2702: PPUSH
2703: CALL_OW 52
// end ;
2707: GO 2618
2709: POP
2710: POP
// end ; end ;
2711: GO 2325
2713: POP
2714: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
2715: LD_ADDR_VAR 0 3
2719: PUSH
2720: LD_INT 22
2722: PUSH
2723: LD_INT 3
2725: PUSH
2726: EMPTY
2727: LIST
2728: LIST
2729: PUSH
2730: LD_INT 21
2732: PUSH
2733: LD_INT 3
2735: PUSH
2736: EMPTY
2737: LIST
2738: LIST
2739: PUSH
2740: EMPTY
2741: LIST
2742: LIST
2743: PPUSH
2744: CALL_OW 69
2748: ST_TO_ADDR
// for b in blist do
2749: LD_ADDR_VAR 0 5
2753: PUSH
2754: LD_VAR 0 3
2758: PUSH
2759: FOR_IN
2760: IFFALSE 2782
// SetBLevel ( b , 3 + Difficulty ) ;
2762: LD_VAR 0 5
2766: PPUSH
2767: LD_INT 3
2769: PUSH
2770: LD_OWVAR 67
2774: PLUS
2775: PPUSH
2776: CALL_OW 241
2780: GO 2759
2782: POP
2783: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
2784: LD_ADDR_VAR 0 3
2788: PUSH
2789: LD_INT 22
2791: PUSH
2792: LD_INT 3
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: PUSH
2799: LD_INT 30
2801: PUSH
2802: LD_INT 32
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: PUSH
2809: EMPTY
2810: LIST
2811: LIST
2812: PPUSH
2813: CALL_OW 69
2817: ST_TO_ADDR
// for b in blist do
2818: LD_ADDR_VAR 0 5
2822: PUSH
2823: LD_VAR 0 3
2827: PUSH
2828: FOR_IN
2829: IFFALSE 2938
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
2831: LD_INT 0
2833: PPUSH
2834: LD_INT 1
2836: PPUSH
2837: LD_INT 1
2839: PUSH
2840: LD_OWVAR 67
2844: PLUS
2845: PPUSH
2846: CALL_OW 380
// un := CreateHuman ;
2850: LD_ADDR_VAR 0 6
2854: PUSH
2855: CALL_OW 44
2859: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
2860: LD_ADDR_EXP 19
2864: PUSH
2865: LD_EXP 19
2869: PPUSH
2870: LD_EXP 19
2874: PUSH
2875: LD_INT 1
2877: PLUS
2878: PPUSH
2879: LD_VAR 0 6
2883: PPUSH
2884: CALL_OW 1
2888: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
2889: LD_VAR 0 6
2893: PPUSH
2894: LD_VAR 0 5
2898: PPUSH
2899: CALL_OW 52
// PlaceWeaponTurret ( b , [ ru_gun , ru_gatling_gun ] [ b mod 2 + 1 ] ) ;
2903: LD_VAR 0 5
2907: PPUSH
2908: LD_INT 44
2910: PUSH
2911: LD_INT 43
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: PUSH
2918: LD_VAR 0 5
2922: PUSH
2923: LD_INT 2
2925: MOD
2926: PUSH
2927: LD_INT 1
2929: PLUS
2930: ARRAY
2931: PPUSH
2932: CALL_OW 431
// end ;
2936: GO 2828
2938: POP
2939: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
2940: LD_ADDR_VAR 0 3
2944: PUSH
2945: LD_INT 22
2947: PUSH
2948: LD_INT 3
2950: PUSH
2951: EMPTY
2952: LIST
2953: LIST
2954: PUSH
2955: LD_INT 30
2957: PUSH
2958: LD_INT 31
2960: PUSH
2961: EMPTY
2962: LIST
2963: LIST
2964: PUSH
2965: EMPTY
2966: LIST
2967: LIST
2968: PPUSH
2969: CALL_OW 69
2973: ST_TO_ADDR
// for b in blist do
2974: LD_ADDR_VAR 0 5
2978: PUSH
2979: LD_VAR 0 3
2983: PUSH
2984: FOR_IN
2985: IFFALSE 3084
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
2987: LD_INT 0
2989: PPUSH
2990: LD_INT 1
2992: PPUSH
2993: LD_INT 1
2995: PUSH
2996: LD_OWVAR 67
3000: PLUS
3001: PPUSH
3002: CALL_OW 380
// un := CreateHuman ;
3006: LD_ADDR_VAR 0 6
3010: PUSH
3011: CALL_OW 44
3015: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
3016: LD_ADDR_EXP 19
3020: PUSH
3021: LD_EXP 19
3025: PPUSH
3026: LD_EXP 19
3030: PUSH
3031: LD_INT 1
3033: PLUS
3034: PPUSH
3035: LD_VAR 0 6
3039: PPUSH
3040: CALL_OW 1
3044: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) + 3 ) ;
3045: LD_VAR 0 6
3049: PPUSH
3050: LD_VAR 0 5
3054: PPUSH
3055: CALL_OW 254
3059: PUSH
3060: LD_INT 3
3062: PLUS
3063: PPUSH
3064: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
3068: LD_VAR 0 6
3072: PPUSH
3073: LD_VAR 0 5
3077: PPUSH
3078: CALL_OW 52
// end ;
3082: GO 2984
3084: POP
3085: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
3086: LD_ADDR_VAR 0 3
3090: PUSH
3091: LD_INT 22
3093: PUSH
3094: LD_INT 3
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 2
3103: PUSH
3104: LD_INT 30
3106: PUSH
3107: LD_INT 4
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: LD_INT 30
3116: PUSH
3117: LD_INT 5
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: PUSH
3124: EMPTY
3125: LIST
3126: LIST
3127: LIST
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PPUSH
3133: CALL_OW 69
3137: ST_TO_ADDR
// for b in blist do
3138: LD_ADDR_VAR 0 5
3142: PUSH
3143: LD_VAR 0 3
3147: PUSH
3148: FOR_IN
3149: IFFALSE 3245
// begin for i := 1 to 2 do
3151: LD_ADDR_VAR 0 4
3155: PUSH
3156: DOUBLE
3157: LD_INT 1
3159: DEC
3160: ST_TO_ADDR
3161: LD_INT 2
3163: PUSH
3164: FOR_TO
3165: IFFALSE 3241
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
3167: LD_INT 0
3169: PPUSH
3170: LD_INT 1
3172: PPUSH
3173: LD_INT 1
3175: PUSH
3176: LD_OWVAR 67
3180: PLUS
3181: PPUSH
3182: CALL_OW 380
// un := CreateHuman ;
3186: LD_ADDR_VAR 0 6
3190: PUSH
3191: CALL_OW 44
3195: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
3196: LD_ADDR_EXP 19
3200: PUSH
3201: LD_EXP 19
3205: PPUSH
3206: LD_EXP 19
3210: PUSH
3211: LD_INT 1
3213: PLUS
3214: PPUSH
3215: LD_VAR 0 6
3219: PPUSH
3220: CALL_OW 1
3224: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
3225: LD_VAR 0 6
3229: PPUSH
3230: LD_VAR 0 5
3234: PPUSH
3235: CALL_OW 52
// end ;
3239: GO 3164
3241: POP
3242: POP
// end ;
3243: GO 3148
3245: POP
3246: POP
// if ibrahimOnRuSide then
3247: LD_EXP 3
3251: IFFALSE 3349
// begin Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
3253: LD_ADDR_EXP 7
3257: PUSH
3258: LD_STRING IbrahimRu
3260: PPUSH
3261: LD_INT 0
3263: PPUSH
3264: LD_STRING 
3266: PPUSH
3267: CALL 81 0 3
3271: ST_TO_ADDR
// PlaceUnitXY ( Ibrahim , 121 , 78 , false ) ;
3272: LD_EXP 7
3276: PPUSH
3277: LD_INT 121
3279: PPUSH
3280: LD_INT 78
3282: PPUSH
3283: LD_INT 0
3285: PPUSH
3286: CALL_OW 48
// ComHold ( Ibrahim ) ;
3290: LD_EXP 7
3294: PPUSH
3295: CALL_OW 140
// PrepareHuman ( sex_male , 1 , 1 ) ;
3299: LD_INT 1
3301: PPUSH
3302: LD_INT 1
3304: PPUSH
3305: LD_INT 1
3307: PPUSH
3308: CALL_OW 380
// ruSol := CreateHuman ;
3312: LD_ADDR_EXP 24
3316: PUSH
3317: CALL_OW 44
3321: ST_TO_ADDR
// PlaceUnitXY ( ruSol , 121 , 75 , false ) ;
3322: LD_EXP 24
3326: PPUSH
3327: LD_INT 121
3329: PPUSH
3330: LD_INT 75
3332: PPUSH
3333: LD_INT 0
3335: PPUSH
3336: CALL_OW 48
// ComHold ( ruSol ) ;
3340: LD_EXP 24
3344: PPUSH
3345: CALL_OW 140
// end ; end ; end_of_file
3349: LD_VAR 0 1
3353: RET
// on UnitDestroyed ( un ) do begin if un = Heike then
3354: LD_VAR 0 1
3358: PUSH
3359: LD_EXP 4
3363: EQUAL
3364: IFFALSE 3373
// YouLost ( Heike ) ;
3366: LD_STRING Heike
3368: PPUSH
3369: CALL_OW 104
// end ; end_of_file
3373: PPOPN 1
3375: END
// export function Action ; begin
3376: LD_INT 0
3378: PPUSH
// end ;
3379: LD_VAR 0 1
3383: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 20 ] ] ) and ibrahimOnRuSide and IsOk ( Ibrahim ) do
3384: LD_INT 22
3386: PUSH
3387: LD_INT 2
3389: PUSH
3390: EMPTY
3391: LIST
3392: LIST
3393: PUSH
3394: LD_INT 91
3396: PUSH
3397: LD_EXP 7
3401: PUSH
3402: LD_INT 20
3404: PUSH
3405: EMPTY
3406: LIST
3407: LIST
3408: LIST
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: PPUSH
3414: CALL_OW 69
3418: PUSH
3419: LD_EXP 3
3423: AND
3424: PUSH
3425: LD_EXP 7
3429: PPUSH
3430: CALL_OW 302
3434: AND
3435: IFFALSE 3523
3437: GO 3439
3439: DISABLE
// begin IbrahimBetrayal ;
3440: CALL 3524 0 0
// repeat wait ( 0 0$1 ) ;
3444: LD_INT 35
3446: PPUSH
3447: CALL_OW 67
// until IsDead ( Ibrahim ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 6 ] ] ) ;
3451: LD_EXP 7
3455: PPUSH
3456: CALL_OW 301
3460: PUSH
3461: LD_INT 22
3463: PUSH
3464: LD_INT 2
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: PUSH
3471: LD_INT 91
3473: PUSH
3474: LD_EXP 7
3478: PUSH
3479: LD_INT 6
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: EMPTY
3488: LIST
3489: LIST
3490: PPUSH
3491: CALL_OW 69
3495: OR
3496: IFFALSE 3444
// if IsDead ( Ibrahim ) then
3498: LD_EXP 7
3502: PPUSH
3503: CALL_OW 301
3507: IFFALSE 3511
// exit ;
3509: GO 3523
// SetSide ( Ibrahim , 2 ) ;
3511: LD_EXP 7
3515: PPUSH
3516: LD_INT 2
3518: PPUSH
3519: CALL_OW 235
// end ;
3523: END
// export function IbrahimBetrayal ; var i , tmp ; begin
3524: LD_INT 0
3526: PPUSH
3527: PPUSH
3528: PPUSH
// PlaceSeeing ( 122 , 77 , 2 , - 6 ) ;
3529: LD_INT 122
3531: PPUSH
3532: LD_INT 77
3534: PPUSH
3535: LD_INT 2
3537: PPUSH
3538: LD_INT 6
3540: NEG
3541: PPUSH
3542: CALL_OW 330
// ComMoveXY ( Ibrahim , 123 , 79 ) ;
3546: LD_EXP 7
3550: PPUSH
3551: LD_INT 123
3553: PPUSH
3554: LD_INT 79
3556: PPUSH
3557: CALL_OW 111
// AddComTurnXY ( Ibrahim , 125 , 82 ) ;
3561: LD_EXP 7
3565: PPUSH
3566: LD_INT 125
3568: PPUSH
3569: LD_INT 82
3571: PPUSH
3572: CALL_OW 178
// wait ( 0 0$2 ) ;
3576: LD_INT 70
3578: PPUSH
3579: CALL_OW 67
// ComTurnUnit ( ruSol , Ibrahim ) ;
3583: LD_EXP 24
3587: PPUSH
3588: LD_EXP 7
3592: PPUSH
3593: CALL_OW 119
// Say ( ruSol , DRum-outpost-b-3 ) ;
3597: LD_EXP 24
3601: PPUSH
3602: LD_STRING DRum-outpost-b-3
3604: PPUSH
3605: CALL_OW 88
// tmp := [ HexInfo ( 125 , 76 ) , HexInfo ( 125 , 79 ) , HexInfo ( 125 , 82 ) ] ;
3609: LD_ADDR_VAR 0 3
3613: PUSH
3614: LD_INT 125
3616: PPUSH
3617: LD_INT 76
3619: PPUSH
3620: CALL_OW 428
3624: PUSH
3625: LD_INT 125
3627: PPUSH
3628: LD_INT 79
3630: PPUSH
3631: CALL_OW 428
3635: PUSH
3636: LD_INT 125
3638: PPUSH
3639: LD_INT 82
3641: PPUSH
3642: CALL_OW 428
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: LIST
3651: ST_TO_ADDR
// for i in tmp do
3652: LD_ADDR_VAR 0 2
3656: PUSH
3657: LD_VAR 0 3
3661: PUSH
3662: FOR_IN
3663: IFFALSE 3679
// SetLives ( i , 200 ) ;
3665: LD_VAR 0 2
3669: PPUSH
3670: LD_INT 200
3672: PPUSH
3673: CALL_OW 234
3677: GO 3662
3679: POP
3680: POP
// Say ( Ibrahim , DI-outpost-b-4 ) ;
3681: LD_EXP 7
3685: PPUSH
3686: LD_STRING DI-outpost-b-4
3688: PPUSH
3689: CALL_OW 88
// SetSide ( Ibrahim , 5 ) ;
3693: LD_EXP 7
3697: PPUSH
3698: LD_INT 5
3700: PPUSH
3701: CALL_OW 235
// ComFree ( [ Ibrahim , ruSol ] ) ;
3705: LD_EXP 7
3709: PUSH
3710: LD_EXP 24
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: PPUSH
3719: CALL_OW 139
// RemoveSeeing ( 122 , 77 , 2 ) ;
3723: LD_INT 122
3725: PPUSH
3726: LD_INT 77
3728: PPUSH
3729: LD_INT 2
3731: PPUSH
3732: CALL_OW 331
// end ;
3736: LD_VAR 0 1
3740: RET
