// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 45 0 0
// InitTag ;
   8: CALL 197 0 0
// PrepareNature ( natureArea ) ;
  12: LD_INT 2
  14: PPUSH
  15: CALL 672 0 1
// PrepareRussian ;
  19: CALL 3400 0 0
// PrepareArabian ;
  23: CALL 2594 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 2 ) ;
  33: LD_INT 2
  35: PPUSH
  36: CALL_OW 344
// Action ;
  40: CALL 6824 0 0
// end ;
  44: END
// export debug , prefix ; export ibrahimOnRuSide , ruEscapeAllowed , gameTime , loseCounter , flamethrowers , ruEscapeCounter , baseHill , explodeFirstDepot , explodeSecondDepot , gaidarKilled ; function Init ; begin
  45: LD_INT 0
  47: PPUSH
// debug := false ;
  48: LD_ADDR_EXP 1
  52: PUSH
  53: LD_INT 0
  55: ST_TO_ADDR
// prefix := 04_1_ ;
  56: LD_ADDR_EXP 2
  60: PUSH
  61: LD_STRING 04_1_
  63: ST_TO_ADDR
// ibrahimOnRuSide := LoadVariable ( 03_IbrahimHasEscaped , false ) ;
  64: LD_ADDR_EXP 3
  68: PUSH
  69: LD_STRING 03_IbrahimHasEscaped
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: CALL_OW 30
  79: ST_TO_ADDR
// ruEscapeCounter := LoadVariable ( 04_1_EscapeCounter , 0 ) ;
  80: LD_ADDR_EXP 8
  84: PUSH
  85: LD_STRING 04_1_EscapeCounter
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// loseCounter := LoadVariable ( 04_1_DeadCounter , 0 ) ;
  96: LD_ADDR_EXP 6
 100: PUSH
 101: LD_STRING 04_1_DeadCounter
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// baseHill := LoadVariable ( 04_1_BaseHill , false ) ;
 112: LD_ADDR_EXP 9
 116: PUSH
 117: LD_STRING 04_1_BaseHill
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL_OW 30
 127: ST_TO_ADDR
// gameTime := LoadVariable ( 04_1_Time , 40 40$00 ) ;
 128: LD_ADDR_EXP 5
 132: PUSH
 133: LD_STRING 04_1_Time
 135: PPUSH
 136: LD_INT 84000
 138: PPUSH
 139: CALL_OW 30
 143: ST_TO_ADDR
// flamethrowers := LoadVariable ( 04_1_Flamethrower , 0 ) ;
 144: LD_ADDR_EXP 7
 148: PUSH
 149: LD_STRING 04_1_Flamethrower
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: CALL_OW 30
 159: ST_TO_ADDR
// ruEscapeAllowed := false ;
 160: LD_ADDR_EXP 4
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// explodeFirstDepot := false ;
 168: LD_ADDR_EXP 10
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// explodeSecondDepot := false ;
 176: LD_ADDR_EXP 11
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// gaidarKilled := false ;
 184: LD_ADDR_EXP 12
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// end ;
 192: LD_VAR 0 1
 196: RET
// export tEscape ; function InitTag ; begin
 197: LD_INT 0
 199: PPUSH
// tEscape := 10 ;
 200: LD_ADDR_EXP 13
 204: PUSH
 205: LD_INT 10
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// every 0 0$1 trigger debug do var i ;
 213: LD_EXP 1
 217: IFFALSE 301
 219: GO 221
 221: DISABLE
 222: LD_INT 0
 224: PPUSH
// begin enable ;
 225: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_type , unit_building ] ] ] ) do
 226: LD_ADDR_VAR 0 1
 230: PUSH
 231: LD_INT 22
 233: PUSH
 234: LD_INT 2
 236: PUSH
 237: EMPTY
 238: LIST
 239: LIST
 240: PUSH
 241: LD_INT 3
 243: PUSH
 244: LD_INT 21
 246: PUSH
 247: LD_INT 3
 249: PUSH
 250: EMPTY
 251: LIST
 252: LIST
 253: PUSH
 254: EMPTY
 255: LIST
 256: LIST
 257: PUSH
 258: EMPTY
 259: LIST
 260: LIST
 261: PPUSH
 262: CALL_OW 69
 266: PUSH
 267: FOR_IN
 268: IFFALSE 299
// if GetLives ( i ) < 1000 then
 270: LD_VAR 0 1
 274: PPUSH
 275: CALL_OW 256
 279: PUSH
 280: LD_INT 1000
 282: LESS
 283: IFFALSE 297
// SetLives ( i , 1000 ) ;
 285: LD_VAR 0 1
 289: PPUSH
 290: LD_INT 1000
 292: PPUSH
 293: CALL_OW 234
 297: GO 267
 299: POP
 300: POP
// end ; end_of_file
 301: PPOPN 1
 303: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// if exist_mode then
 308: LD_VAR 0 2
 312: IFFALSE 337
// unit := CreateCharacter ( prefix & ident ) else
 314: LD_ADDR_VAR 0 5
 318: PUSH
 319: LD_VAR 0 3
 323: PUSH
 324: LD_VAR 0 1
 328: STR
 329: PPUSH
 330: CALL_OW 34
 334: ST_TO_ADDR
 335: GO 352
// unit := NewCharacter ( ident ) ;
 337: LD_ADDR_VAR 0 5
 341: PUSH
 342: LD_VAR 0 1
 346: PPUSH
 347: CALL_OW 25
 351: ST_TO_ADDR
// result := unit ;
 352: LD_ADDR_VAR 0 4
 356: PUSH
 357: LD_VAR 0 5
 361: ST_TO_ADDR
// end ;
 362: LD_VAR 0 4
 366: RET
// export function PrepareTank ( side , nation , chassis , engine , control , weapon , fuel ) ; begin
 367: LD_INT 0
 369: PPUSH
// uc_side := side ;
 370: LD_ADDR_OWVAR 20
 374: PUSH
 375: LD_VAR 0 1
 379: ST_TO_ADDR
// uc_nation := nation ;
 380: LD_ADDR_OWVAR 21
 384: PUSH
 385: LD_VAR 0 2
 389: ST_TO_ADDR
// vc_chassis := chassis ;
 390: LD_ADDR_OWVAR 37
 394: PUSH
 395: LD_VAR 0 3
 399: ST_TO_ADDR
// vc_engine := engine ;
 400: LD_ADDR_OWVAR 39
 404: PUSH
 405: LD_VAR 0 4
 409: ST_TO_ADDR
// vc_control := control ;
 410: LD_ADDR_OWVAR 38
 414: PUSH
 415: LD_VAR 0 5
 419: ST_TO_ADDR
// vc_weapon := weapon ;
 420: LD_ADDR_OWVAR 40
 424: PUSH
 425: LD_VAR 0 6
 429: ST_TO_ADDR
// vc_fuel_battery := fuel ;
 430: LD_ADDR_OWVAR 41
 434: PUSH
 435: LD_VAR 0 7
 439: ST_TO_ADDR
// result := CreateVehicle ;
 440: LD_ADDR_VAR 0 8
 444: PUSH
 445: CALL_OW 45
 449: ST_TO_ADDR
// end ;
 450: LD_VAR 0 8
 454: RET
// export function SayX ( units , ident ) ; var i ; begin
 455: LD_INT 0
 457: PPUSH
 458: PPUSH
// result := false ;
 459: LD_ADDR_VAR 0 3
 463: PUSH
 464: LD_INT 0
 466: ST_TO_ADDR
// if not units then
 467: LD_VAR 0 1
 471: NOT
 472: IFFALSE 476
// exit ;
 474: GO 530
// for i in units do
 476: LD_ADDR_VAR 0 4
 480: PUSH
 481: LD_VAR 0 1
 485: PUSH
 486: FOR_IN
 487: IFFALSE 528
// if IsOk ( i ) then
 489: LD_VAR 0 4
 493: PPUSH
 494: CALL_OW 302
 498: IFFALSE 526
// begin Say ( i , ident ) ;
 500: LD_VAR 0 4
 504: PPUSH
 505: LD_VAR 0 2
 509: PPUSH
 510: CALL_OW 88
// result := i ;
 514: LD_ADDR_VAR 0 3
 518: PUSH
 519: LD_VAR 0 4
 523: ST_TO_ADDR
// break ;
 524: GO 528
// end ;
 526: GO 486
 528: POP
 529: POP
// end ;
 530: LD_VAR 0 3
 534: RET
// export function SpawnApeman ( area , amount ) ; var i ; begin
 535: LD_INT 0
 537: PPUSH
 538: PPUSH
// InitUc ;
 539: CALL_OW 18
// InitHc ;
 543: CALL_OW 19
// uc_side := 0 ;
 547: LD_ADDR_OWVAR 20
 551: PUSH
 552: LD_INT 0
 554: ST_TO_ADDR
// uc_nation := 0 ;
 555: LD_ADDR_OWVAR 21
 559: PUSH
 560: LD_INT 0
 562: ST_TO_ADDR
// for i = 1 to amount do
 563: LD_ADDR_VAR 0 4
 567: PUSH
 568: DOUBLE
 569: LD_INT 1
 571: DEC
 572: ST_TO_ADDR
 573: LD_VAR 0 2
 577: PUSH
 578: FOR_TO
 579: IFFALSE 661
// begin hc_attr := [ rand ( 9 , 12 ) , rand ( 9 , 12 ) ] ;
 581: LD_ADDR_OWVAR 29
 585: PUSH
 586: LD_INT 9
 588: PPUSH
 589: LD_INT 12
 591: PPUSH
 592: CALL_OW 12
 596: PUSH
 597: LD_INT 9
 599: PPUSH
 600: LD_INT 12
 602: PPUSH
 603: CALL_OW 12
 607: PUSH
 608: EMPTY
 609: LIST
 610: LIST
 611: ST_TO_ADDR
// hc_agressivity := rand ( - 1 , 1 ) ;
 612: LD_ADDR_OWVAR 35
 616: PUSH
 617: LD_INT 1
 619: NEG
 620: PPUSH
 621: LD_INT 1
 623: PPUSH
 624: CALL_OW 12
 628: ST_TO_ADDR
// PrepareHuman ( false , class_apeman , 1 ) ;
 629: LD_INT 0
 631: PPUSH
 632: LD_INT 12
 634: PPUSH
 635: LD_INT 1
 637: PPUSH
 638: CALL_OW 380
// PlaceUnitArea ( CreateHuman , area , false ) ;
 642: CALL_OW 44
 646: PPUSH
 647: LD_VAR 0 1
 651: PPUSH
 652: LD_INT 0
 654: PPUSH
 655: CALL_OW 49
// end ;
 659: GO 578
 661: POP
 662: POP
// InitHc ;
 663: CALL_OW 19
// end ;
 667: LD_VAR 0 3
 671: RET
// export function PrepareNature ( forest ) ; var i ; begin
 672: LD_INT 0
 674: PPUSH
 675: PPUSH
// SpawnApeman ( forest , [ 3 , 3 , 2 ] [ Difficulty ] ) ;
 676: LD_VAR 0 1
 680: PPUSH
 681: LD_INT 3
 683: PUSH
 684: LD_INT 3
 686: PUSH
 687: LD_INT 2
 689: PUSH
 690: EMPTY
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: LD_OWVAR 67
 699: ARRAY
 700: PPUSH
 701: CALL 535 0 2
// for i := 1 to 2 do
 705: LD_ADDR_VAR 0 3
 709: PUSH
 710: DOUBLE
 711: LD_INT 1
 713: DEC
 714: ST_TO_ADDR
 715: LD_INT 2
 717: PUSH
 718: FOR_TO
 719: IFFALSE 756
// begin hc_class := 21 ;
 721: LD_ADDR_OWVAR 28
 725: PUSH
 726: LD_INT 21
 728: ST_TO_ADDR
// hc_gallery :=  ;
 729: LD_ADDR_OWVAR 33
 733: PUSH
 734: LD_STRING 
 736: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 737: CALL_OW 44
 741: PPUSH
 742: LD_VAR 0 1
 746: PPUSH
 747: LD_INT 0
 749: PPUSH
 750: CALL_OW 49
// end ;
 754: GO 718
 756: POP
 757: POP
// for i := 1 to 2 do
 758: LD_ADDR_VAR 0 3
 762: PUSH
 763: DOUBLE
 764: LD_INT 1
 766: DEC
 767: ST_TO_ADDR
 768: LD_INT 2
 770: PUSH
 771: FOR_TO
 772: IFFALSE 809
// begin hc_class := 18 ;
 774: LD_ADDR_OWVAR 28
 778: PUSH
 779: LD_INT 18
 781: ST_TO_ADDR
// hc_gallery :=  ;
 782: LD_ADDR_OWVAR 33
 786: PUSH
 787: LD_STRING 
 789: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 790: CALL_OW 44
 794: PPUSH
 795: LD_VAR 0 1
 799: PPUSH
 800: LD_INT 0
 802: PPUSH
 803: CALL_OW 49
// end ;
 807: GO 771
 809: POP
 810: POP
// for i := 1 to 2 do
 811: LD_ADDR_VAR 0 3
 815: PUSH
 816: DOUBLE
 817: LD_INT 1
 819: DEC
 820: ST_TO_ADDR
 821: LD_INT 2
 823: PUSH
 824: FOR_TO
 825: IFFALSE 862
// begin hc_class := 13 ;
 827: LD_ADDR_OWVAR 28
 831: PUSH
 832: LD_INT 13
 834: ST_TO_ADDR
// hc_gallery :=  ;
 835: LD_ADDR_OWVAR 33
 839: PUSH
 840: LD_STRING 
 842: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , forest , false ) ;
 843: CALL_OW 44
 847: PPUSH
 848: LD_VAR 0 1
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL_OW 49
// end ;
 860: GO 824
 862: POP
 863: POP
// end ;
 864: LD_VAR 0 2
 868: RET
// export function SeeUnit ( observer , unit ) ; var i , tmp ; begin
 869: LD_INT 0
 871: PPUSH
 872: PPUSH
 873: PPUSH
// if not observer or not unit then
 874: LD_VAR 0 1
 878: NOT
 879: PUSH
 880: LD_VAR 0 2
 884: NOT
 885: OR
 886: IFFALSE 890
// exit ;
 888: GO 938
// if not See ( GetSide ( observer ) , unit ) then
 890: LD_VAR 0 1
 894: PPUSH
 895: CALL_OW 255
 899: PPUSH
 900: LD_VAR 0 2
 904: PPUSH
 905: CALL_OW 292
 909: NOT
 910: IFFALSE 914
// exit ;
 912: GO 938
// result := GetDistUnits ( observer , unit ) < 12 ;
 914: LD_ADDR_VAR 0 3
 918: PUSH
 919: LD_VAR 0 1
 923: PPUSH
 924: LD_VAR 0 2
 928: PPUSH
 929: CALL_OW 296
 933: PUSH
 934: LD_INT 12
 936: LESS
 937: ST_TO_ADDR
// end ;
 938: LD_VAR 0 3
 942: RET
// export function PlaceUnitHex ( un , hex , mode ) ; begin
 943: LD_INT 0
 945: PPUSH
// if ValidHex ( hex [ 1 ] , hex [ 2 ] ) and HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
 946: LD_VAR 0 2
 950: PUSH
 951: LD_INT 1
 953: ARRAY
 954: PPUSH
 955: LD_VAR 0 2
 959: PUSH
 960: LD_INT 2
 962: ARRAY
 963: PPUSH
 964: CALL_OW 488
 968: PUSH
 969: LD_VAR 0 2
 973: PUSH
 974: LD_INT 1
 976: ARRAY
 977: PPUSH
 978: LD_VAR 0 2
 982: PUSH
 983: LD_INT 2
 985: ARRAY
 986: PPUSH
 987: CALL_OW 428
 991: PUSH
 992: LD_INT 0
 994: EQUAL
 995: AND
 996: IFFALSE 1030
// PlaceUnitXY ( un , hex [ 1 ] , hex [ 2 ] , mode ) ;
 998: LD_VAR 0 1
1002: PPUSH
1003: LD_VAR 0 2
1007: PUSH
1008: LD_INT 1
1010: ARRAY
1011: PPUSH
1012: LD_VAR 0 2
1016: PUSH
1017: LD_INT 2
1019: ARRAY
1020: PPUSH
1021: LD_VAR 0 3
1025: PPUSH
1026: CALL_OW 48
// end ;
1030: LD_VAR 0 4
1034: RET
// export function Video ( mode ) ; begin
1035: LD_INT 0
1037: PPUSH
// ingame_video = mode ;
1038: LD_ADDR_OWVAR 52
1042: PUSH
1043: LD_VAR 0 1
1047: ST_TO_ADDR
// interface_hidden = mode ;
1048: LD_ADDR_OWVAR 54
1052: PUSH
1053: LD_VAR 0 1
1057: ST_TO_ADDR
// end ;
1058: LD_VAR 0 2
1062: RET
// export function ReverseArray ( array ) ; var i ; begin
1063: LD_INT 0
1065: PPUSH
1066: PPUSH
// if not array then
1067: LD_VAR 0 1
1071: NOT
1072: IFFALSE 1076
// exit ;
1074: GO 1134
// result := [ ] ;
1076: LD_ADDR_VAR 0 2
1080: PUSH
1081: EMPTY
1082: ST_TO_ADDR
// for i := 1 to array do
1083: LD_ADDR_VAR 0 3
1087: PUSH
1088: DOUBLE
1089: LD_INT 1
1091: DEC
1092: ST_TO_ADDR
1093: LD_VAR 0 1
1097: PUSH
1098: FOR_TO
1099: IFFALSE 1132
// result := Insert ( result , 1 , array [ i ] ) ;
1101: LD_ADDR_VAR 0 2
1105: PUSH
1106: LD_VAR 0 2
1110: PPUSH
1111: LD_INT 1
1113: PPUSH
1114: LD_VAR 0 1
1118: PUSH
1119: LD_VAR 0 3
1123: ARRAY
1124: PPUSH
1125: CALL_OW 2
1129: ST_TO_ADDR
1130: GO 1098
1132: POP
1133: POP
// end ;
1134: LD_VAR 0 2
1138: RET
// export function ComExit ( unit ) ; begin
1139: LD_INT 0
1141: PPUSH
// result := IsInUnit ( unit ) ;
1142: LD_ADDR_VAR 0 2
1146: PUSH
1147: LD_VAR 0 1
1151: PPUSH
1152: CALL_OW 310
1156: ST_TO_ADDR
// if not result then
1157: LD_VAR 0 2
1161: NOT
1162: IFFALSE 1166
// exit ;
1164: GO 1201
// if GetType ( result ) = unit_vehicle then
1166: LD_VAR 0 2
1170: PPUSH
1171: CALL_OW 247
1175: PUSH
1176: LD_INT 2
1178: EQUAL
1179: IFFALSE 1192
// ComExitVehicle ( unit ) else
1181: LD_VAR 0 1
1185: PPUSH
1186: CALL_OW 121
1190: GO 1201
// ComExitBuilding ( unit ) ;
1192: LD_VAR 0 1
1196: PPUSH
1197: CALL_OW 122
// end ;
1201: LD_VAR 0 2
1205: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
1206: LD_INT 0
1208: PPUSH
1209: PPUSH
// if not side or not nation then
1210: LD_VAR 0 1
1214: NOT
1215: PUSH
1216: LD_VAR 0 2
1220: NOT
1221: OR
1222: IFFALSE 1226
// exit ;
1224: GO 1990
// case nation of nation_american :
1226: LD_VAR 0 2
1230: PUSH
1231: LD_INT 1
1233: DOUBLE
1234: EQUAL
1235: IFTRUE 1239
1237: GO 1453
1239: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
1240: LD_ADDR_VAR 0 4
1244: PUSH
1245: LD_INT 35
1247: PUSH
1248: LD_INT 45
1250: PUSH
1251: LD_INT 46
1253: PUSH
1254: LD_INT 47
1256: PUSH
1257: LD_INT 82
1259: PUSH
1260: LD_INT 83
1262: PUSH
1263: LD_INT 84
1265: PUSH
1266: LD_INT 85
1268: PUSH
1269: LD_INT 86
1271: PUSH
1272: LD_INT 1
1274: PUSH
1275: LD_INT 2
1277: PUSH
1278: LD_INT 6
1280: PUSH
1281: LD_INT 15
1283: PUSH
1284: LD_INT 16
1286: PUSH
1287: LD_INT 7
1289: PUSH
1290: LD_INT 12
1292: PUSH
1293: LD_INT 13
1295: PUSH
1296: LD_INT 10
1298: PUSH
1299: LD_INT 14
1301: PUSH
1302: LD_INT 20
1304: PUSH
1305: LD_INT 21
1307: PUSH
1308: LD_INT 22
1310: PUSH
1311: LD_INT 25
1313: PUSH
1314: LD_INT 32
1316: PUSH
1317: LD_INT 27
1319: PUSH
1320: LD_INT 36
1322: PUSH
1323: LD_INT 69
1325: PUSH
1326: LD_INT 39
1328: PUSH
1329: LD_INT 34
1331: PUSH
1332: LD_INT 40
1334: PUSH
1335: LD_INT 48
1337: PUSH
1338: LD_INT 49
1340: PUSH
1341: LD_INT 50
1343: PUSH
1344: LD_INT 51
1346: PUSH
1347: LD_INT 52
1349: PUSH
1350: LD_INT 53
1352: PUSH
1353: LD_INT 54
1355: PUSH
1356: LD_INT 55
1358: PUSH
1359: LD_INT 56
1361: PUSH
1362: LD_INT 57
1364: PUSH
1365: LD_INT 58
1367: PUSH
1368: LD_INT 59
1370: PUSH
1371: LD_INT 60
1373: PUSH
1374: LD_INT 61
1376: PUSH
1377: LD_INT 62
1379: PUSH
1380: LD_INT 80
1382: PUSH
1383: LD_INT 82
1385: PUSH
1386: LD_INT 83
1388: PUSH
1389: LD_INT 84
1391: PUSH
1392: LD_INT 85
1394: PUSH
1395: LD_INT 86
1397: PUSH
1398: EMPTY
1399: LIST
1400: LIST
1401: LIST
1402: LIST
1403: LIST
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: LIST
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: LIST
1429: LIST
1430: LIST
1431: LIST
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: LIST
1438: LIST
1439: LIST
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: LIST
1447: LIST
1448: LIST
1449: LIST
1450: ST_TO_ADDR
1451: GO 1914
1453: LD_INT 2
1455: DOUBLE
1456: EQUAL
1457: IFTRUE 1461
1459: GO 1683
1461: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
1462: LD_ADDR_VAR 0 4
1466: PUSH
1467: LD_INT 35
1469: PUSH
1470: LD_INT 45
1472: PUSH
1473: LD_INT 46
1475: PUSH
1476: LD_INT 47
1478: PUSH
1479: LD_INT 82
1481: PUSH
1482: LD_INT 83
1484: PUSH
1485: LD_INT 84
1487: PUSH
1488: LD_INT 85
1490: PUSH
1491: LD_INT 87
1493: PUSH
1494: LD_INT 70
1496: PUSH
1497: LD_INT 1
1499: PUSH
1500: LD_INT 11
1502: PUSH
1503: LD_INT 3
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 5
1511: PUSH
1512: LD_INT 6
1514: PUSH
1515: LD_INT 15
1517: PUSH
1518: LD_INT 18
1520: PUSH
1521: LD_INT 7
1523: PUSH
1524: LD_INT 17
1526: PUSH
1527: LD_INT 8
1529: PUSH
1530: LD_INT 20
1532: PUSH
1533: LD_INT 21
1535: PUSH
1536: LD_INT 22
1538: PUSH
1539: LD_INT 72
1541: PUSH
1542: LD_INT 26
1544: PUSH
1545: LD_INT 69
1547: PUSH
1548: LD_INT 39
1550: PUSH
1551: LD_INT 40
1553: PUSH
1554: LD_INT 41
1556: PUSH
1557: LD_INT 42
1559: PUSH
1560: LD_INT 43
1562: PUSH
1563: LD_INT 48
1565: PUSH
1566: LD_INT 49
1568: PUSH
1569: LD_INT 50
1571: PUSH
1572: LD_INT 51
1574: PUSH
1575: LD_INT 52
1577: PUSH
1578: LD_INT 53
1580: PUSH
1581: LD_INT 54
1583: PUSH
1584: LD_INT 55
1586: PUSH
1587: LD_INT 56
1589: PUSH
1590: LD_INT 60
1592: PUSH
1593: LD_INT 61
1595: PUSH
1596: LD_INT 62
1598: PUSH
1599: LD_INT 66
1601: PUSH
1602: LD_INT 67
1604: PUSH
1605: LD_INT 68
1607: PUSH
1608: LD_INT 81
1610: PUSH
1611: LD_INT 82
1613: PUSH
1614: LD_INT 83
1616: PUSH
1617: LD_INT 84
1619: PUSH
1620: LD_INT 85
1622: PUSH
1623: LD_INT 87
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: LIST
1630: LIST
1631: LIST
1632: LIST
1633: LIST
1634: LIST
1635: LIST
1636: LIST
1637: LIST
1638: LIST
1639: LIST
1640: LIST
1641: LIST
1642: LIST
1643: LIST
1644: LIST
1645: LIST
1646: LIST
1647: LIST
1648: LIST
1649: LIST
1650: LIST
1651: LIST
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: LIST
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: LIST
1662: LIST
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: LIST
1679: LIST
1680: ST_TO_ADDR
1681: GO 1914
1683: LD_INT 3
1685: DOUBLE
1686: EQUAL
1687: IFTRUE 1691
1689: GO 1913
1691: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
1692: LD_ADDR_VAR 0 4
1696: PUSH
1697: LD_INT 46
1699: PUSH
1700: LD_INT 47
1702: PUSH
1703: LD_INT 1
1705: PUSH
1706: LD_INT 2
1708: PUSH
1709: LD_INT 82
1711: PUSH
1712: LD_INT 83
1714: PUSH
1715: LD_INT 84
1717: PUSH
1718: LD_INT 85
1720: PUSH
1721: LD_INT 86
1723: PUSH
1724: LD_INT 11
1726: PUSH
1727: LD_INT 9
1729: PUSH
1730: LD_INT 20
1732: PUSH
1733: LD_INT 19
1735: PUSH
1736: LD_INT 21
1738: PUSH
1739: LD_INT 24
1741: PUSH
1742: LD_INT 22
1744: PUSH
1745: LD_INT 25
1747: PUSH
1748: LD_INT 28
1750: PUSH
1751: LD_INT 29
1753: PUSH
1754: LD_INT 30
1756: PUSH
1757: LD_INT 31
1759: PUSH
1760: LD_INT 37
1762: PUSH
1763: LD_INT 38
1765: PUSH
1766: LD_INT 32
1768: PUSH
1769: LD_INT 27
1771: PUSH
1772: LD_INT 33
1774: PUSH
1775: LD_INT 69
1777: PUSH
1778: LD_INT 39
1780: PUSH
1781: LD_INT 34
1783: PUSH
1784: LD_INT 40
1786: PUSH
1787: LD_INT 71
1789: PUSH
1790: LD_INT 23
1792: PUSH
1793: LD_INT 44
1795: PUSH
1796: LD_INT 48
1798: PUSH
1799: LD_INT 49
1801: PUSH
1802: LD_INT 50
1804: PUSH
1805: LD_INT 51
1807: PUSH
1808: LD_INT 52
1810: PUSH
1811: LD_INT 53
1813: PUSH
1814: LD_INT 54
1816: PUSH
1817: LD_INT 55
1819: PUSH
1820: LD_INT 56
1822: PUSH
1823: LD_INT 57
1825: PUSH
1826: LD_INT 58
1828: PUSH
1829: LD_INT 59
1831: PUSH
1832: LD_INT 63
1834: PUSH
1835: LD_INT 64
1837: PUSH
1838: LD_INT 65
1840: PUSH
1841: LD_INT 82
1843: PUSH
1844: LD_INT 83
1846: PUSH
1847: LD_INT 84
1849: PUSH
1850: LD_INT 85
1852: PUSH
1853: LD_INT 86
1855: PUSH
1856: EMPTY
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: LIST
1876: LIST
1877: LIST
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: LIST
1903: LIST
1904: LIST
1905: LIST
1906: LIST
1907: LIST
1908: LIST
1909: LIST
1910: ST_TO_ADDR
1911: GO 1914
1913: POP
// if state > - 1 and state < 3 then
1914: LD_VAR 0 3
1918: PUSH
1919: LD_INT 1
1921: NEG
1922: GREATER
1923: PUSH
1924: LD_VAR 0 3
1928: PUSH
1929: LD_INT 3
1931: LESS
1932: AND
1933: IFFALSE 1990
// for i in result do
1935: LD_ADDR_VAR 0 5
1939: PUSH
1940: LD_VAR 0 4
1944: PUSH
1945: FOR_IN
1946: IFFALSE 1988
// if GetTech ( i , side ) <> state then
1948: LD_VAR 0 5
1952: PPUSH
1953: LD_VAR 0 1
1957: PPUSH
1958: CALL_OW 321
1962: PUSH
1963: LD_VAR 0 3
1967: NONEQUAL
1968: IFFALSE 1986
// result := result diff i ;
1970: LD_ADDR_VAR 0 4
1974: PUSH
1975: LD_VAR 0 4
1979: PUSH
1980: LD_VAR 0 5
1984: DIFF
1985: ST_TO_ADDR
1986: GO 1945
1988: POP
1989: POP
// end ;
1990: LD_VAR 0 4
1994: RET
// export function SortByDistanceXY ( x , y , list , asc ) ; var i , j , tmp ; begin
1995: LD_INT 0
1997: PPUSH
1998: PPUSH
1999: PPUSH
2000: PPUSH
// if not list then
2001: LD_VAR 0 3
2005: NOT
2006: IFFALSE 2010
// exit ;
2008: GO 2318
// result := [ ] ;
2010: LD_ADDR_VAR 0 5
2014: PUSH
2015: EMPTY
2016: ST_TO_ADDR
// for i in list do
2017: LD_ADDR_VAR 0 6
2021: PUSH
2022: LD_VAR 0 3
2026: PUSH
2027: FOR_IN
2028: IFFALSE 2230
// begin tmp := GetDistUnitXY ( i , x , y ) ;
2030: LD_ADDR_VAR 0 8
2034: PUSH
2035: LD_VAR 0 6
2039: PPUSH
2040: LD_VAR 0 1
2044: PPUSH
2045: LD_VAR 0 2
2049: PPUSH
2050: CALL_OW 297
2054: ST_TO_ADDR
// if not result then
2055: LD_VAR 0 5
2059: NOT
2060: IFFALSE 2086
// result := [ [ i , tmp ] ] else
2062: LD_ADDR_VAR 0 5
2066: PUSH
2067: LD_VAR 0 6
2071: PUSH
2072: LD_VAR 0 8
2076: PUSH
2077: EMPTY
2078: LIST
2079: LIST
2080: PUSH
2081: EMPTY
2082: LIST
2083: ST_TO_ADDR
2084: GO 2228
// begin if result [ result ] [ 2 ] < tmp then
2086: LD_VAR 0 5
2090: PUSH
2091: LD_VAR 0 5
2095: ARRAY
2096: PUSH
2097: LD_INT 2
2099: ARRAY
2100: PUSH
2101: LD_VAR 0 8
2105: LESS
2106: IFFALSE 2148
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
2108: LD_ADDR_VAR 0 5
2112: PUSH
2113: LD_VAR 0 5
2117: PPUSH
2118: LD_VAR 0 5
2122: PUSH
2123: LD_INT 1
2125: PLUS
2126: PPUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_VAR 0 8
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: PPUSH
2141: CALL_OW 2
2145: ST_TO_ADDR
2146: GO 2228
// for j = 1 to result do
2148: LD_ADDR_VAR 0 7
2152: PUSH
2153: DOUBLE
2154: LD_INT 1
2156: DEC
2157: ST_TO_ADDR
2158: LD_VAR 0 5
2162: PUSH
2163: FOR_TO
2164: IFFALSE 2226
// begin if tmp < result [ j ] [ 2 ] then
2166: LD_VAR 0 8
2170: PUSH
2171: LD_VAR 0 5
2175: PUSH
2176: LD_VAR 0 7
2180: ARRAY
2181: PUSH
2182: LD_INT 2
2184: ARRAY
2185: LESS
2186: IFFALSE 2224
// begin result := Insert ( result , j , [ i , tmp ] ) ;
2188: LD_ADDR_VAR 0 5
2192: PUSH
2193: LD_VAR 0 5
2197: PPUSH
2198: LD_VAR 0 7
2202: PPUSH
2203: LD_VAR 0 6
2207: PUSH
2208: LD_VAR 0 8
2212: PUSH
2213: EMPTY
2214: LIST
2215: LIST
2216: PPUSH
2217: CALL_OW 2
2221: ST_TO_ADDR
// break ;
2222: GO 2226
// end ; end ;
2224: GO 2163
2226: POP
2227: POP
// end ; end ;
2228: GO 2027
2230: POP
2231: POP
// if result and not asc then
2232: LD_VAR 0 5
2236: PUSH
2237: LD_VAR 0 4
2241: NOT
2242: AND
2243: IFFALSE 2318
// begin tmp := result ;
2245: LD_ADDR_VAR 0 8
2249: PUSH
2250: LD_VAR 0 5
2254: ST_TO_ADDR
// for i = tmp downto 1 do
2255: LD_ADDR_VAR 0 6
2259: PUSH
2260: DOUBLE
2261: LD_VAR 0 8
2265: INC
2266: ST_TO_ADDR
2267: LD_INT 1
2269: PUSH
2270: FOR_DOWNTO
2271: IFFALSE 2316
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
2273: LD_ADDR_VAR 0 5
2277: PUSH
2278: LD_VAR 0 5
2282: PPUSH
2283: LD_VAR 0 8
2287: PUSH
2288: LD_VAR 0 6
2292: MINUS
2293: PUSH
2294: LD_INT 1
2296: PLUS
2297: PPUSH
2298: LD_VAR 0 8
2302: PUSH
2303: LD_VAR 0 6
2307: ARRAY
2308: PPUSH
2309: CALL_OW 1
2313: ST_TO_ADDR
2314: GO 2270
2316: POP
2317: POP
// end ; end ;
2318: LD_VAR 0 5
2322: RET
// export function SortByDistanceUnit ( unit , list , asc ) ; begin
2323: LD_INT 0
2325: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc ) ;
2326: LD_ADDR_VAR 0 4
2330: PUSH
2331: LD_VAR 0 1
2335: PPUSH
2336: CALL_OW 250
2340: PPUSH
2341: LD_VAR 0 1
2345: PPUSH
2346: CALL_OW 251
2350: PPUSH
2351: LD_VAR 0 2
2355: PPUSH
2356: LD_VAR 0 3
2360: PPUSH
2361: CALL 1995 0 4
2365: ST_TO_ADDR
// end ;
2366: LD_VAR 0 4
2370: RET
// export function NearestEmptyBuilding ( unit , btype ) ; var side , tmp , i , places ; begin
2371: LD_INT 0
2373: PPUSH
2374: PPUSH
2375: PPUSH
2376: PPUSH
2377: PPUSH
// if not unit then
2378: LD_VAR 0 1
2382: NOT
2383: IFFALSE 2387
// exit ;
2385: GO 2589
// side := GetSide ( unit ) ;
2387: LD_ADDR_VAR 0 4
2391: PUSH
2392: LD_VAR 0 1
2396: PPUSH
2397: CALL_OW 255
2401: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
2402: LD_ADDR_VAR 0 5
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: LD_VAR 0 4
2414: PUSH
2415: EMPTY
2416: LIST
2417: LIST
2418: PUSH
2419: LD_INT 30
2421: PUSH
2422: LD_VAR 0 2
2426: PUSH
2427: EMPTY
2428: LIST
2429: LIST
2430: PUSH
2431: EMPTY
2432: LIST
2433: LIST
2434: PPUSH
2435: CALL_OW 69
2439: ST_TO_ADDR
// if not tmp then
2440: LD_VAR 0 5
2444: NOT
2445: IFFALSE 2449
// exit ;
2447: GO 2589
// tmp := SortByDistanceUnit ( unit , tmp , true ) ;
2449: LD_ADDR_VAR 0 5
2453: PUSH
2454: LD_VAR 0 1
2458: PPUSH
2459: LD_VAR 0 5
2463: PPUSH
2464: LD_INT 1
2466: PPUSH
2467: CALL 2323 0 3
2471: ST_TO_ADDR
// places := 1 ;
2472: LD_ADDR_VAR 0 7
2476: PUSH
2477: LD_INT 1
2479: ST_TO_ADDR
// if btype in [ b_depot , b_warehouse , b_armoury , b_barracks , b_workshop , b_factory , b_lab , b_lab_half , b_lab_full ] then
2480: LD_VAR 0 2
2484: PUSH
2485: LD_INT 0
2487: PUSH
2488: LD_INT 1
2490: PUSH
2491: LD_INT 4
2493: PUSH
2494: LD_INT 5
2496: PUSH
2497: LD_INT 2
2499: PUSH
2500: LD_INT 3
2502: PUSH
2503: LD_INT 6
2505: PUSH
2506: LD_INT 7
2508: PUSH
2509: LD_INT 8
2511: PUSH
2512: EMPTY
2513: LIST
2514: LIST
2515: LIST
2516: LIST
2517: LIST
2518: LIST
2519: LIST
2520: LIST
2521: LIST
2522: IN
2523: IFFALSE 2533
// places := 6 ;
2525: LD_ADDR_VAR 0 7
2529: PUSH
2530: LD_INT 6
2532: ST_TO_ADDR
// for i in tmp do
2533: LD_ADDR_VAR 0 6
2537: PUSH
2538: LD_VAR 0 5
2542: PUSH
2543: FOR_IN
2544: IFFALSE 2587
// begin if UnitsInside ( i ) - places <= 0 then
2546: LD_VAR 0 6
2550: PPUSH
2551: CALL_OW 313
2555: PUSH
2556: LD_VAR 0 7
2560: MINUS
2561: PUSH
2562: LD_INT 0
2564: LESSEQUAL
2565: IFFALSE 2571
// continue else
2567: GO 2543
2569: GO 2585
// begin result := i ;
2571: LD_ADDR_VAR 0 3
2575: PUSH
2576: LD_VAR 0 6
2580: ST_TO_ADDR
// exit ;
2581: POP
2582: POP
2583: GO 2589
// end ; end ;
2585: GO 2543
2587: POP
2588: POP
// end ; end_of_file
2589: LD_VAR 0 3
2593: RET
// export Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Shariff , Kurt , Aviradze , heikeSecondSquad , heikeVehicles , heikeApes ; export function PrepareArabian ; var i ; begin
2594: LD_INT 0
2596: PPUSH
2597: PPUSH
// uc_side := 2 ;
2598: LD_ADDR_OWVAR 20
2602: PUSH
2603: LD_INT 2
2605: ST_TO_ADDR
// uc_nation := 2 ;
2606: LD_ADDR_OWVAR 21
2610: PUSH
2611: LD_INT 2
2613: ST_TO_ADDR
// Heike := PrepareUnit ( Heike , ( not debug ) , prefix ) ;
2614: LD_ADDR_EXP 14
2618: PUSH
2619: LD_STRING Heike
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_EXP 2
2632: PPUSH
2633: CALL 304 0 3
2637: ST_TO_ADDR
// Ibrahim := PrepareUnit ( Ibrahim , ( not debug ) , prefix ) ;
2638: LD_ADDR_EXP 17
2642: PUSH
2643: LD_STRING Ibrahim
2645: PPUSH
2646: LD_EXP 1
2650: NOT
2651: PPUSH
2652: LD_EXP 2
2656: PPUSH
2657: CALL 304 0 3
2661: ST_TO_ADDR
// Givi := PrepareUnit ( Givi , ( not debug ) , prefix ) ;
2662: LD_ADDR_EXP 15
2666: PUSH
2667: LD_STRING Givi
2669: PPUSH
2670: LD_EXP 1
2674: NOT
2675: PPUSH
2676: LD_EXP 2
2680: PPUSH
2681: CALL 304 0 3
2685: ST_TO_ADDR
// Kamil := PrepareUnit ( Kamil , ( not debug ) , prefix ) ;
2686: LD_ADDR_EXP 18
2690: PUSH
2691: LD_STRING Kamil
2693: PPUSH
2694: LD_EXP 1
2698: NOT
2699: PPUSH
2700: LD_EXP 2
2704: PPUSH
2705: CALL 304 0 3
2709: ST_TO_ADDR
// Kaia := PrepareUnit ( Kaia , ( not debug ) , prefix ) ;
2710: LD_ADDR_EXP 19
2714: PUSH
2715: LD_STRING Kaia
2717: PPUSH
2718: LD_EXP 1
2722: NOT
2723: PPUSH
2724: LD_EXP 2
2728: PPUSH
2729: CALL 304 0 3
2733: ST_TO_ADDR
// Sophia := PrepareUnit ( Sophia , ( not debug ) , prefix ) ;
2734: LD_ADDR_EXP 20
2738: PUSH
2739: LD_STRING Sophia
2741: PPUSH
2742: LD_EXP 1
2746: NOT
2747: PPUSH
2748: LD_EXP 2
2752: PPUSH
2753: CALL 304 0 3
2757: ST_TO_ADDR
// Markov := PrepareUnit ( Markov , ( not debug ) , prefix ) ;
2758: LD_ADDR_EXP 21
2762: PUSH
2763: LD_STRING Markov
2765: PPUSH
2766: LD_EXP 1
2770: NOT
2771: PPUSH
2772: LD_EXP 2
2776: PPUSH
2777: CALL 304 0 3
2781: ST_TO_ADDR
// Aviradze := PrepareUnit ( Aviradze , ( not debug ) , prefix ) ;
2782: LD_ADDR_EXP 24
2786: PUSH
2787: LD_STRING Aviradze
2789: PPUSH
2790: LD_EXP 1
2794: NOT
2795: PPUSH
2796: LD_EXP 2
2800: PPUSH
2801: CALL 304 0 3
2805: ST_TO_ADDR
// Kurt := PrepareUnit ( Kurt , false ,  ) ;
2806: LD_ADDR_EXP 23
2810: PUSH
2811: LD_STRING Kurt
2813: PPUSH
2814: LD_INT 0
2816: PPUSH
2817: LD_STRING 
2819: PPUSH
2820: CALL 304 0 3
2824: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , prefix ) ;
2825: LD_ADDR_EXP 16
2829: PUSH
2830: LD_STRING Mike
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_EXP 2
2843: PPUSH
2844: CALL 304 0 3
2848: ST_TO_ADDR
// heikeSecondSquad := CreateCharacterSet ( 04_1_others ) ;
2849: LD_ADDR_EXP 25
2853: PUSH
2854: LD_STRING 04_1_others
2856: PPUSH
2857: CALL_OW 31
2861: ST_TO_ADDR
// heikeApes := CreateCharacterSet ( 04_1_apes ) ;
2862: LD_ADDR_EXP 27
2866: PUSH
2867: LD_STRING 04_1_apes
2869: PPUSH
2870: CALL_OW 31
2874: ST_TO_ADDR
// heikeVehicles := LoadVariable ( 04_1_Vehicles , [ [ ar_medium_trike , engine_combustion , control_manual , ar_gun , 2 , 1000 , [ 0 , 0 ] ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gatling_gun , 2 , 1000 , [ 0 , 0 ] ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun , 2 , 1000 , [ 0 , 0 ] ] , [ ar_medium_trike , engine_combustion , control_manual , ar_gun , 2 , 1000 , [ 0 , 0 ] ] , [ ar_medium_trike , engine_combustion , control_manual , ar_cargo_bay , 2 , 1000 , [ 40 , 40 ] ] ] ) ;
2875: LD_ADDR_EXP 26
2879: PUSH
2880: LD_STRING 04_1_Vehicles
2882: PPUSH
2883: LD_INT 13
2885: PUSH
2886: LD_INT 1
2888: PUSH
2889: LD_INT 1
2891: PUSH
2892: LD_INT 27
2894: PUSH
2895: LD_INT 2
2897: PUSH
2898: LD_INT 1000
2900: PUSH
2901: LD_INT 0
2903: PUSH
2904: LD_INT 0
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: PUSH
2911: EMPTY
2912: LIST
2913: LIST
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 13
2922: PUSH
2923: LD_INT 1
2925: PUSH
2926: LD_INT 1
2928: PUSH
2929: LD_INT 25
2931: PUSH
2932: LD_INT 2
2934: PUSH
2935: LD_INT 1000
2937: PUSH
2938: LD_INT 0
2940: PUSH
2941: LD_INT 0
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: LIST
2952: LIST
2953: LIST
2954: LIST
2955: LIST
2956: PUSH
2957: LD_INT 13
2959: PUSH
2960: LD_INT 1
2962: PUSH
2963: LD_INT 1
2965: PUSH
2966: LD_INT 27
2968: PUSH
2969: LD_INT 2
2971: PUSH
2972: LD_INT 1000
2974: PUSH
2975: LD_INT 0
2977: PUSH
2978: LD_INT 0
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: PUSH
2994: LD_INT 13
2996: PUSH
2997: LD_INT 1
2999: PUSH
3000: LD_INT 1
3002: PUSH
3003: LD_INT 27
3005: PUSH
3006: LD_INT 2
3008: PUSH
3009: LD_INT 1000
3011: PUSH
3012: LD_INT 0
3014: PUSH
3015: LD_INT 0
3017: PUSH
3018: EMPTY
3019: LIST
3020: LIST
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: LIST
3028: LIST
3029: LIST
3030: PUSH
3031: LD_INT 13
3033: PUSH
3034: LD_INT 1
3036: PUSH
3037: LD_INT 1
3039: PUSH
3040: LD_INT 32
3042: PUSH
3043: LD_INT 2
3045: PUSH
3046: LD_INT 1000
3048: PUSH
3049: LD_INT 40
3051: PUSH
3052: LD_INT 40
3054: PUSH
3055: EMPTY
3056: LIST
3057: LIST
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: LIST
3065: LIST
3066: LIST
3067: PUSH
3068: EMPTY
3069: LIST
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: PPUSH
3075: CALL_OW 30
3079: ST_TO_ADDR
// uc_side := 5 ;
3080: LD_ADDR_OWVAR 20
3084: PUSH
3085: LD_INT 5
3087: ST_TO_ADDR
// Shariff := PrepareUnit ( Abdul , false ,  ) ;
3088: LD_ADDR_EXP 22
3092: PUSH
3093: LD_STRING Abdul
3095: PPUSH
3096: LD_INT 0
3098: PPUSH
3099: LD_STRING 
3101: PPUSH
3102: CALL 304 0 3
3106: ST_TO_ADDR
// end ;
3107: LD_VAR 0 1
3111: RET
// every 3 3$00 trigger HexInfo ( 124 , 26 ) = 0 xor GetSide ( HexInfo ( 124 , 26 ) ) = 2 do var un , veh ;
3112: LD_INT 124
3114: PPUSH
3115: LD_INT 26
3117: PPUSH
3118: CALL_OW 428
3122: PUSH
3123: LD_INT 0
3125: EQUAL
3126: PUSH
3127: LD_INT 124
3129: PPUSH
3130: LD_INT 26
3132: PPUSH
3133: CALL_OW 428
3137: PPUSH
3138: CALL_OW 255
3142: PUSH
3143: LD_INT 2
3145: EQUAL
3146: XOR
3147: IFFALSE 3397
3149: GO 3151
3151: DISABLE
3152: LD_INT 0
3154: PPUSH
3155: PPUSH
// begin uc_side := 5 ;
3156: LD_ADDR_OWVAR 20
3160: PUSH
3161: LD_INT 5
3163: ST_TO_ADDR
// uc_nation := 2 ;
3164: LD_ADDR_OWVAR 21
3168: PUSH
3169: LD_INT 2
3171: ST_TO_ADDR
// PrepareTank ( 5 , 2 , ar_medium_trike , engine_solar , control_manual , ar_cargo_bay , 70 ) ;
3172: LD_INT 5
3174: PPUSH
3175: LD_INT 2
3177: PPUSH
3178: LD_INT 13
3180: PPUSH
3181: LD_INT 2
3183: PPUSH
3184: LD_INT 1
3186: PPUSH
3187: LD_INT 32
3189: PPUSH
3190: LD_INT 70
3192: PPUSH
3193: CALL 367 0 7
// veh := CreateVehicle ;
3197: LD_ADDR_VAR 0 2
3201: PUSH
3202: CALL_OW 45
3206: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3207: LD_VAR 0 2
3211: PPUSH
3212: LD_INT 3
3214: PPUSH
3215: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
3219: LD_VAR 0 2
3223: PPUSH
3224: LD_INT 8
3226: PPUSH
3227: LD_INT 0
3229: PPUSH
3230: CALL_OW 49
// PrepareHuman ( false , 1 , 3 ) ;
3234: LD_INT 0
3236: PPUSH
3237: LD_INT 1
3239: PPUSH
3240: LD_INT 3
3242: PPUSH
3243: CALL_OW 380
// un := CreateHuman ;
3247: LD_ADDR_VAR 0 1
3251: PUSH
3252: CALL_OW 44
3256: ST_TO_ADDR
// PlaceHumanInUnit ( un , veh ) ;
3257: LD_VAR 0 1
3261: PPUSH
3262: LD_VAR 0 2
3266: PPUSH
3267: CALL_OW 52
// SetCargo ( veh , mat_oil , 100 ) ;
3271: LD_VAR 0 2
3275: PPUSH
3276: LD_INT 2
3278: PPUSH
3279: LD_INT 100
3281: PPUSH
3282: CALL_OW 290
// ComMoveXY ( veh , 127 , 23 ) ;
3286: LD_VAR 0 2
3290: PPUSH
3291: LD_INT 127
3293: PPUSH
3294: LD_INT 23
3296: PPUSH
3297: CALL_OW 111
// AddComUnload ( veh ) ;
3301: LD_VAR 0 2
3305: PPUSH
3306: CALL_OW 219
// AddComMoveXY ( veh , 133 , 2 ) ;
3310: LD_VAR 0 2
3314: PPUSH
3315: LD_INT 133
3317: PPUSH
3318: LD_INT 2
3320: PPUSH
3321: CALL_OW 171
// wait ( 0 0$5 ) ;
3325: LD_INT 175
3327: PPUSH
3328: CALL_OW 67
// CenterOnUnits ( veh ) ;
3332: LD_VAR 0 2
3336: PPUSH
3337: CALL_OW 85
// repeat wait ( 0 0$1 ) ;
3341: LD_INT 35
3343: PPUSH
3344: CALL_OW 67
// until IsAt ( veh , 133 , 2 ) or IsInArea ( veh , spawnArea ) ;
3348: LD_VAR 0 2
3352: PPUSH
3353: LD_INT 133
3355: PPUSH
3356: LD_INT 2
3358: PPUSH
3359: CALL_OW 307
3363: PUSH
3364: LD_VAR 0 2
3368: PPUSH
3369: LD_INT 8
3371: PPUSH
3372: CALL_OW 308
3376: OR
3377: IFFALSE 3341
// RemoveUnit ( un ) ;
3379: LD_VAR 0 1
3383: PPUSH
3384: CALL_OW 64
// RemoveUnit ( veh ) ;
3388: LD_VAR 0 2
3392: PPUSH
3393: CALL_OW 64
// end ; end_of_file
3397: PPOPN 2
3399: END
// export Burlak , Gaidar , Kuzmov ; export ruForce , ruEng , ruMech , ruSci , ruMobile ; export ruSol ; export function PrepareRussian ; var base , blist , i , b , un , tmp , fac , oil ; begin
3400: LD_INT 0
3402: PPUSH
3403: PPUSH
3404: PPUSH
3405: PPUSH
3406: PPUSH
3407: PPUSH
3408: PPUSH
3409: PPUSH
3410: PPUSH
// uc_side := 3 ;
3411: LD_ADDR_OWVAR 20
3415: PUSH
3416: LD_INT 3
3418: ST_TO_ADDR
// uc_nation := 3 ;
3419: LD_ADDR_OWVAR 21
3423: PUSH
3424: LD_INT 3
3426: ST_TO_ADDR
// ruForce := [ ] ;
3427: LD_ADDR_EXP 31
3431: PUSH
3432: EMPTY
3433: ST_TO_ADDR
// ruMech := [ ] ;
3434: LD_ADDR_EXP 33
3438: PUSH
3439: EMPTY
3440: ST_TO_ADDR
// ruEng := [ ] ;
3441: LD_ADDR_EXP 32
3445: PUSH
3446: EMPTY
3447: ST_TO_ADDR
// ruSci := [ ] ;
3448: LD_ADDR_EXP 34
3452: PUSH
3453: EMPTY
3454: ST_TO_ADDR
// ruMobile := [ ] ;
3455: LD_ADDR_EXP 35
3459: PUSH
3460: EMPTY
3461: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , false ,  ) ;
3462: LD_ADDR_EXP 28
3466: PUSH
3467: LD_STRING Burlak
3469: PPUSH
3470: LD_INT 0
3472: PPUSH
3473: LD_STRING 
3475: PPUSH
3476: CALL 304 0 3
3480: ST_TO_ADDR
// Gaidar := PrepareUnit ( Gaydar , false ,  ) ;
3481: LD_ADDR_EXP 29
3485: PUSH
3486: LD_STRING Gaydar
3488: PPUSH
3489: LD_INT 0
3491: PPUSH
3492: LD_STRING 
3494: PPUSH
3495: CALL 304 0 3
3499: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , false ,  ) ;
3500: LD_ADDR_EXP 30
3504: PUSH
3505: LD_STRING Kuzmov
3507: PPUSH
3508: LD_INT 0
3510: PPUSH
3511: LD_STRING 
3513: PPUSH
3514: CALL 304 0 3
3518: ST_TO_ADDR
// PlaceHumanInUnit ( Kuzmov , ruMainBase ) ;
3519: LD_EXP 30
3523: PPUSH
3524: LD_INT 200
3526: PPUSH
3527: CALL_OW 52
// SetBName ( ruMainBase , chuikov ) ;
3531: LD_INT 200
3533: PPUSH
3534: LD_STRING chuikov
3536: PPUSH
3537: CALL_OW 500
// SetResourceType ( GetBase ( ruMainBase ) , mat_cans , [ 800 , 1000 , 1250 ] [ Difficulty ] ) ;
3541: LD_INT 200
3543: PPUSH
3544: CALL_OW 274
3548: PPUSH
3549: LD_INT 1
3551: PPUSH
3552: LD_INT 800
3554: PUSH
3555: LD_INT 1000
3557: PUSH
3558: LD_INT 1250
3560: PUSH
3561: EMPTY
3562: LIST
3563: LIST
3564: LIST
3565: PUSH
3566: LD_OWVAR 67
3570: ARRAY
3571: PPUSH
3572: CALL_OW 277
// SetResourceType ( GetBase ( ruMainBase ) , mat_oil , 160 ) ;
3576: LD_INT 200
3578: PPUSH
3579: CALL_OW 274
3583: PPUSH
3584: LD_INT 2
3586: PPUSH
3587: LD_INT 160
3589: PPUSH
3590: CALL_OW 277
// SetResourceType ( GetBase ( ruSecBase ) , mat_cans , 200 ) ;
3594: LD_INT 225
3596: PPUSH
3597: CALL_OW 274
3601: PPUSH
3602: LD_INT 1
3604: PPUSH
3605: LD_INT 200
3607: PPUSH
3608: CALL_OW 277
// oil := 150 ;
3612: LD_ADDR_VAR 0 9
3616: PUSH
3617: LD_INT 150
3619: ST_TO_ADDR
// if gameTime >= [ 40 40$00 , 35 35$00 , 33 33$00 ] [ Difficulty ] then
3620: LD_EXP 5
3624: PUSH
3625: LD_INT 84000
3627: PUSH
3628: LD_INT 73500
3630: PUSH
3631: LD_INT 69300
3633: PUSH
3634: EMPTY
3635: LIST
3636: LIST
3637: LIST
3638: PUSH
3639: LD_OWVAR 67
3643: ARRAY
3644: GREATEREQUAL
3645: IFFALSE 3800
// begin oil := 450 ;
3647: LD_ADDR_VAR 0 9
3651: PUSH
3652: LD_INT 450
3654: ST_TO_ADDR
// tmp := [ [ 123 , 17 , 3 , b_breastwork ] , [ 152 , 38 , 3 , b_breastwork ] , [ 81 , 6 , 4 , b_breastwork ] , [ 113 , 67 , 4 , b_bunker ] ] ;
3655: LD_ADDR_VAR 0 7
3659: PUSH
3660: LD_INT 123
3662: PUSH
3663: LD_INT 17
3665: PUSH
3666: LD_INT 3
3668: PUSH
3669: LD_INT 31
3671: PUSH
3672: EMPTY
3673: LIST
3674: LIST
3675: LIST
3676: LIST
3677: PUSH
3678: LD_INT 152
3680: PUSH
3681: LD_INT 38
3683: PUSH
3684: LD_INT 3
3686: PUSH
3687: LD_INT 31
3689: PUSH
3690: EMPTY
3691: LIST
3692: LIST
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 81
3698: PUSH
3699: LD_INT 6
3701: PUSH
3702: LD_INT 4
3704: PUSH
3705: LD_INT 31
3707: PUSH
3708: EMPTY
3709: LIST
3710: LIST
3711: LIST
3712: LIST
3713: PUSH
3714: LD_INT 113
3716: PUSH
3717: LD_INT 67
3719: PUSH
3720: LD_INT 4
3722: PUSH
3723: LD_INT 32
3725: PUSH
3726: EMPTY
3727: LIST
3728: LIST
3729: LIST
3730: LIST
3731: PUSH
3732: EMPTY
3733: LIST
3734: LIST
3735: LIST
3736: LIST
3737: ST_TO_ADDR
// for i in tmp do
3738: LD_ADDR_VAR 0 4
3742: PUSH
3743: LD_VAR 0 7
3747: PUSH
3748: FOR_IN
3749: IFFALSE 3798
// begin bc_type := i [ 4 ] ;
3751: LD_ADDR_OWVAR 42
3755: PUSH
3756: LD_VAR 0 4
3760: PUSH
3761: LD_INT 4
3763: ARRAY
3764: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3765: LD_VAR 0 4
3769: PUSH
3770: LD_INT 1
3772: ARRAY
3773: PPUSH
3774: LD_VAR 0 4
3778: PUSH
3779: LD_INT 2
3781: ARRAY
3782: PPUSH
3783: LD_VAR 0 4
3787: PUSH
3788: LD_INT 3
3790: ARRAY
3791: PPUSH
3792: CALL_OW 47
// end ;
3796: GO 3748
3798: POP
3799: POP
// end ; SetResourceType ( GetBase ( ruSecBase ) , mat_oil , oil ) ;
3800: LD_INT 225
3802: PPUSH
3803: CALL_OW 274
3807: PPUSH
3808: LD_INT 2
3810: PPUSH
3811: LD_VAR 0 9
3815: PPUSH
3816: CALL_OW 277
// if Difficulty > 1 then
3820: LD_OWVAR 67
3824: PUSH
3825: LD_INT 1
3827: GREATER
3828: IFFALSE 3923
// begin bc_type := b_bunker ;
3830: LD_ADDR_OWVAR 42
3834: PUSH
3835: LD_INT 32
3837: ST_TO_ADDR
// tmp := [ [ 121 , 85 , 5 ] , [ 93 , 72 , 1 ] ] ;
3838: LD_ADDR_VAR 0 7
3842: PUSH
3843: LD_INT 121
3845: PUSH
3846: LD_INT 85
3848: PUSH
3849: LD_INT 5
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: LIST
3856: PUSH
3857: LD_INT 93
3859: PUSH
3860: LD_INT 72
3862: PUSH
3863: LD_INT 1
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: ST_TO_ADDR
// for i in tmp do
3875: LD_ADDR_VAR 0 4
3879: PUSH
3880: LD_VAR 0 7
3884: PUSH
3885: FOR_IN
3886: IFFALSE 3921
// CreateAndPlaceBuildingXYD ( i [ 1 ] , i [ 2 ] , i [ 3 ] ) ;
3888: LD_VAR 0 4
3892: PUSH
3893: LD_INT 1
3895: ARRAY
3896: PPUSH
3897: LD_VAR 0 4
3901: PUSH
3902: LD_INT 2
3904: ARRAY
3905: PPUSH
3906: LD_VAR 0 4
3910: PUSH
3911: LD_INT 3
3913: ARRAY
3914: PPUSH
3915: CALL_OW 47
3919: GO 3885
3921: POP
3922: POP
// end ; base := GetBase ( ruMainBase ) ;
3923: LD_ADDR_VAR 0 2
3927: PUSH
3928: LD_INT 200
3930: PPUSH
3931: CALL_OW 274
3935: ST_TO_ADDR
// blist := GetBuildList ( base ) ;
3936: LD_ADDR_VAR 0 3
3940: PUSH
3941: LD_VAR 0 2
3945: PPUSH
3946: CALL_OW 417
3950: ST_TO_ADDR
// for b in blist do
3951: LD_ADDR_VAR 0 5
3955: PUSH
3956: LD_VAR 0 3
3960: PUSH
3961: FOR_IN
3962: IFFALSE 4365
// begin if b [ 1 ] = b_factory then
3964: LD_VAR 0 5
3968: PUSH
3969: LD_INT 1
3971: ARRAY
3972: PUSH
3973: LD_INT 3
3975: EQUAL
3976: IFFALSE 4106
// begin fac := HexInfo ( b [ 2 ] , b [ 3 ] ) ;
3978: LD_ADDR_VAR 0 8
3982: PUSH
3983: LD_VAR 0 5
3987: PUSH
3988: LD_INT 2
3990: ARRAY
3991: PPUSH
3992: LD_VAR 0 5
3996: PUSH
3997: LD_INT 3
3999: ARRAY
4000: PPUSH
4001: CALL_OW 428
4005: ST_TO_ADDR
// for i := 1 to 2 + Difficulty do
4006: LD_ADDR_VAR 0 4
4010: PUSH
4011: DOUBLE
4012: LD_INT 1
4014: DEC
4015: ST_TO_ADDR
4016: LD_INT 2
4018: PUSH
4019: LD_OWVAR 67
4023: PLUS
4024: PUSH
4025: FOR_TO
4026: IFFALSE 4102
// begin PrepareHuman ( false , 3 , 1 + Difficulty ) ;
4028: LD_INT 0
4030: PPUSH
4031: LD_INT 3
4033: PPUSH
4034: LD_INT 1
4036: PUSH
4037: LD_OWVAR 67
4041: PLUS
4042: PPUSH
4043: CALL_OW 380
// un := CreateHuman ;
4047: LD_ADDR_VAR 0 6
4051: PUSH
4052: CALL_OW 44
4056: ST_TO_ADDR
// ruMech := Replace ( ruMech , ruMech + 1 , un ) ;
4057: LD_ADDR_EXP 33
4061: PUSH
4062: LD_EXP 33
4066: PPUSH
4067: LD_EXP 33
4071: PUSH
4072: LD_INT 1
4074: PLUS
4075: PPUSH
4076: LD_VAR 0 6
4080: PPUSH
4081: CALL_OW 1
4085: ST_TO_ADDR
// PlaceHumanInUnit ( un , fac ) ;
4086: LD_VAR 0 6
4090: PPUSH
4091: LD_VAR 0 8
4095: PPUSH
4096: CALL_OW 52
// end ;
4100: GO 4025
4102: POP
4103: POP
// end else
4104: GO 4363
// if b [ 1 ] in [ b_lab , b_lab_half , b_lab_full , b_lab_weapon ] then
4106: LD_VAR 0 5
4110: PUSH
4111: LD_INT 1
4113: ARRAY
4114: PUSH
4115: LD_INT 6
4117: PUSH
4118: LD_INT 7
4120: PUSH
4121: LD_INT 8
4123: PUSH
4124: LD_INT 10
4126: PUSH
4127: EMPTY
4128: LIST
4129: LIST
4130: LIST
4131: LIST
4132: IN
4133: IFFALSE 4243
// begin for i := 1 to 2 do
4135: LD_ADDR_VAR 0 4
4139: PUSH
4140: DOUBLE
4141: LD_INT 1
4143: DEC
4144: ST_TO_ADDR
4145: LD_INT 2
4147: PUSH
4148: FOR_TO
4149: IFFALSE 4239
// begin PrepareHuman ( false , 4 , Difficulty ) ;
4151: LD_INT 0
4153: PPUSH
4154: LD_INT 4
4156: PPUSH
4157: LD_OWVAR 67
4161: PPUSH
4162: CALL_OW 380
// un := CreateHuman ;
4166: LD_ADDR_VAR 0 6
4170: PUSH
4171: CALL_OW 44
4175: ST_TO_ADDR
// ruSci := Replace ( ruSci , ruSci + 1 , un ) ;
4176: LD_ADDR_EXP 34
4180: PUSH
4181: LD_EXP 34
4185: PPUSH
4186: LD_EXP 34
4190: PUSH
4191: LD_INT 1
4193: PLUS
4194: PPUSH
4195: LD_VAR 0 6
4199: PPUSH
4200: CALL_OW 1
4204: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4205: LD_VAR 0 6
4209: PPUSH
4210: LD_VAR 0 5
4214: PUSH
4215: LD_INT 2
4217: ARRAY
4218: PPUSH
4219: LD_VAR 0 5
4223: PUSH
4224: LD_INT 3
4226: ARRAY
4227: PPUSH
4228: CALL_OW 428
4232: PPUSH
4233: CALL_OW 52
// end ;
4237: GO 4148
4239: POP
4240: POP
// end else
4241: GO 4363
// if b [ 1 ] = b_warehouse then
4243: LD_VAR 0 5
4247: PUSH
4248: LD_INT 1
4250: ARRAY
4251: PUSH
4252: LD_INT 1
4254: EQUAL
4255: IFFALSE 4363
// begin for i := 1 to 3 do
4257: LD_ADDR_VAR 0 4
4261: PUSH
4262: DOUBLE
4263: LD_INT 1
4265: DEC
4266: ST_TO_ADDR
4267: LD_INT 3
4269: PUSH
4270: FOR_TO
4271: IFFALSE 4361
// begin PrepareHuman ( false , 2 , Difficulty ) ;
4273: LD_INT 0
4275: PPUSH
4276: LD_INT 2
4278: PPUSH
4279: LD_OWVAR 67
4283: PPUSH
4284: CALL_OW 380
// un := CreateHuman ;
4288: LD_ADDR_VAR 0 6
4292: PUSH
4293: CALL_OW 44
4297: ST_TO_ADDR
// ruEng := Replace ( ruEng , ruEng + 1 , un ) ;
4298: LD_ADDR_EXP 32
4302: PUSH
4303: LD_EXP 32
4307: PPUSH
4308: LD_EXP 32
4312: PUSH
4313: LD_INT 1
4315: PLUS
4316: PPUSH
4317: LD_VAR 0 6
4321: PPUSH
4322: CALL_OW 1
4326: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( b [ 2 ] , b [ 3 ] ) ) ;
4327: LD_VAR 0 6
4331: PPUSH
4332: LD_VAR 0 5
4336: PUSH
4337: LD_INT 2
4339: ARRAY
4340: PPUSH
4341: LD_VAR 0 5
4345: PUSH
4346: LD_INT 3
4348: ARRAY
4349: PPUSH
4350: CALL_OW 428
4354: PPUSH
4355: CALL_OW 52
// end ;
4359: GO 4270
4361: POP
4362: POP
// end ; end ;
4363: GO 3961
4365: POP
4366: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ;
4367: LD_ADDR_VAR 0 3
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 3
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 21
4384: PUSH
4385: LD_INT 3
4387: PUSH
4388: EMPTY
4389: LIST
4390: LIST
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PPUSH
4396: CALL_OW 69
4400: ST_TO_ADDR
// for b in blist do
4401: LD_ADDR_VAR 0 5
4405: PUSH
4406: LD_VAR 0 3
4410: PUSH
4411: FOR_IN
4412: IFFALSE 4434
// SetBLevel ( b , 3 + Difficulty ) ;
4414: LD_VAR 0 5
4418: PPUSH
4419: LD_INT 3
4421: PUSH
4422: LD_OWVAR 67
4426: PLUS
4427: PPUSH
4428: CALL_OW 241
4432: GO 4411
4434: POP
4435: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_bunker ] ] ) ;
4436: LD_ADDR_VAR 0 3
4440: PUSH
4441: LD_INT 22
4443: PUSH
4444: LD_INT 3
4446: PUSH
4447: EMPTY
4448: LIST
4449: LIST
4450: PUSH
4451: LD_INT 30
4453: PUSH
4454: LD_INT 32
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PPUSH
4465: CALL_OW 69
4469: ST_TO_ADDR
// for b in blist do
4470: LD_ADDR_VAR 0 5
4474: PUSH
4475: LD_VAR 0 3
4479: PUSH
4480: FOR_IN
4481: IFFALSE 4590
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4483: LD_INT 0
4485: PPUSH
4486: LD_INT 1
4488: PPUSH
4489: LD_INT 1
4491: PUSH
4492: LD_OWVAR 67
4496: PLUS
4497: PPUSH
4498: CALL_OW 380
// un := CreateHuman ;
4502: LD_ADDR_VAR 0 6
4506: PUSH
4507: CALL_OW 44
4511: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4512: LD_ADDR_EXP 31
4516: PUSH
4517: LD_EXP 31
4521: PPUSH
4522: LD_EXP 31
4526: PUSH
4527: LD_INT 1
4529: PLUS
4530: PPUSH
4531: LD_VAR 0 6
4535: PPUSH
4536: CALL_OW 1
4540: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4541: LD_VAR 0 6
4545: PPUSH
4546: LD_VAR 0 5
4550: PPUSH
4551: CALL_OW 52
// PlaceWeaponTurret ( b , [ ru_gun , ru_gatling_gun ] [ b mod 2 + 1 ] ) ;
4555: LD_VAR 0 5
4559: PPUSH
4560: LD_INT 44
4562: PUSH
4563: LD_INT 43
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PUSH
4570: LD_VAR 0 5
4574: PUSH
4575: LD_INT 2
4577: MOD
4578: PUSH
4579: LD_INT 1
4581: PLUS
4582: ARRAY
4583: PPUSH
4584: CALL_OW 431
// end ;
4588: GO 4480
4590: POP
4591: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_breastwork ] ] ) ;
4592: LD_ADDR_VAR 0 3
4596: PUSH
4597: LD_INT 22
4599: PUSH
4600: LD_INT 3
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: PUSH
4607: LD_INT 30
4609: PUSH
4610: LD_INT 31
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PPUSH
4621: CALL_OW 69
4625: ST_TO_ADDR
// for b in blist do
4626: LD_ADDR_VAR 0 5
4630: PUSH
4631: LD_VAR 0 3
4635: PUSH
4636: FOR_IN
4637: IFFALSE 4736
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4639: LD_INT 0
4641: PPUSH
4642: LD_INT 1
4644: PPUSH
4645: LD_INT 1
4647: PUSH
4648: LD_OWVAR 67
4652: PLUS
4653: PPUSH
4654: CALL_OW 380
// un := CreateHuman ;
4658: LD_ADDR_VAR 0 6
4662: PUSH
4663: CALL_OW 44
4667: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4668: LD_ADDR_EXP 31
4672: PUSH
4673: LD_EXP 31
4677: PPUSH
4678: LD_EXP 31
4682: PUSH
4683: LD_INT 1
4685: PLUS
4686: PPUSH
4687: LD_VAR 0 6
4691: PPUSH
4692: CALL_OW 1
4696: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) + 3 ) ;
4697: LD_VAR 0 6
4701: PPUSH
4702: LD_VAR 0 5
4706: PPUSH
4707: CALL_OW 254
4711: PUSH
4712: LD_INT 3
4714: PLUS
4715: PPUSH
4716: CALL_OW 233
// PlaceHumanInUnit ( un , b ) ;
4720: LD_VAR 0 6
4724: PPUSH
4725: LD_VAR 0 5
4729: PPUSH
4730: CALL_OW 52
// end ;
4734: GO 4636
4736: POP
4737: POP
// blist := FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
4738: LD_ADDR_VAR 0 3
4742: PUSH
4743: LD_INT 22
4745: PUSH
4746: LD_INT 3
4748: PUSH
4749: EMPTY
4750: LIST
4751: LIST
4752: PUSH
4753: LD_INT 2
4755: PUSH
4756: LD_INT 30
4758: PUSH
4759: LD_INT 4
4761: PUSH
4762: EMPTY
4763: LIST
4764: LIST
4765: PUSH
4766: LD_INT 30
4768: PUSH
4769: LD_INT 5
4771: PUSH
4772: EMPTY
4773: LIST
4774: LIST
4775: PUSH
4776: EMPTY
4777: LIST
4778: LIST
4779: LIST
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PPUSH
4785: CALL_OW 69
4789: ST_TO_ADDR
// for b in blist do
4790: LD_ADDR_VAR 0 5
4794: PUSH
4795: LD_VAR 0 3
4799: PUSH
4800: FOR_IN
4801: IFFALSE 4897
// begin for i := 1 to 2 do
4803: LD_ADDR_VAR 0 4
4807: PUSH
4808: DOUBLE
4809: LD_INT 1
4811: DEC
4812: ST_TO_ADDR
4813: LD_INT 2
4815: PUSH
4816: FOR_TO
4817: IFFALSE 4893
// begin PrepareHuman ( false , 1 , 1 + Difficulty ) ;
4819: LD_INT 0
4821: PPUSH
4822: LD_INT 1
4824: PPUSH
4825: LD_INT 1
4827: PUSH
4828: LD_OWVAR 67
4832: PLUS
4833: PPUSH
4834: CALL_OW 380
// un := CreateHuman ;
4838: LD_ADDR_VAR 0 6
4842: PUSH
4843: CALL_OW 44
4847: ST_TO_ADDR
// ruForce := Replace ( ruForce , ruForce + 1 , un ) ;
4848: LD_ADDR_EXP 31
4852: PUSH
4853: LD_EXP 31
4857: PPUSH
4858: LD_EXP 31
4862: PUSH
4863: LD_INT 1
4865: PLUS
4866: PPUSH
4867: LD_VAR 0 6
4871: PPUSH
4872: CALL_OW 1
4876: ST_TO_ADDR
// PlaceHumanInUnit ( un , b ) ;
4877: LD_VAR 0 6
4881: PPUSH
4882: LD_VAR 0 5
4886: PPUSH
4887: CALL_OW 52
// end ;
4891: GO 4816
4893: POP
4894: POP
// end ;
4895: GO 4800
4897: POP
4898: POP
// if ibrahimOnRuSide then
4899: LD_EXP 3
4903: IFFALSE 5001
// begin Ibrahim := PrepareUnit ( IbrahimRu , false ,  ) ;
4905: LD_ADDR_EXP 17
4909: PUSH
4910: LD_STRING IbrahimRu
4912: PPUSH
4913: LD_INT 0
4915: PPUSH
4916: LD_STRING 
4918: PPUSH
4919: CALL 304 0 3
4923: ST_TO_ADDR
// PlaceUnitXY ( Ibrahim , 121 , 78 , false ) ;
4924: LD_EXP 17
4928: PPUSH
4929: LD_INT 121
4931: PPUSH
4932: LD_INT 78
4934: PPUSH
4935: LD_INT 0
4937: PPUSH
4938: CALL_OW 48
// ComHold ( Ibrahim ) ;
4942: LD_EXP 17
4946: PPUSH
4947: CALL_OW 140
// PrepareHuman ( sex_male , 1 , 1 ) ;
4951: LD_INT 1
4953: PPUSH
4954: LD_INT 1
4956: PPUSH
4957: LD_INT 1
4959: PPUSH
4960: CALL_OW 380
// ruSol := CreateHuman ;
4964: LD_ADDR_EXP 36
4968: PUSH
4969: CALL_OW 44
4973: ST_TO_ADDR
// PlaceUnitXY ( ruSol , 121 , 75 , false ) ;
4974: LD_EXP 36
4978: PPUSH
4979: LD_INT 121
4981: PPUSH
4982: LD_INT 75
4984: PPUSH
4985: LD_INT 0
4987: PPUSH
4988: CALL_OW 48
// ComHold ( ruSol ) ;
4992: LD_EXP 36
4996: PPUSH
4997: CALL_OW 140
// end ; for i := 1 to 2 + Difficulty do
5001: LD_ADDR_VAR 0 4
5005: PUSH
5006: DOUBLE
5007: LD_INT 1
5009: DEC
5010: ST_TO_ADDR
5011: LD_INT 2
5013: PUSH
5014: LD_OWVAR 67
5018: PLUS
5019: PUSH
5020: FOR_TO
5021: IFFALSE 5090
// AddComConstruct ( fac , [ ru_medium_wheeled , ru_heavy_wheeled , ru_heavy_tracked ] [ i mod 3 + 1 ] , engine_combustion , control_manual , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] ) ;
5023: LD_VAR 0 8
5027: PPUSH
5028: LD_INT 21
5030: PUSH
5031: LD_INT 23
5033: PUSH
5034: LD_INT 24
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: LIST
5041: PUSH
5042: LD_VAR 0 4
5046: PUSH
5047: LD_INT 3
5049: MOD
5050: PUSH
5051: LD_INT 1
5053: PLUS
5054: ARRAY
5055: PPUSH
5056: LD_INT 1
5058: PPUSH
5059: LD_INT 1
5061: PPUSH
5062: LD_INT 43
5064: PUSH
5065: LD_INT 44
5067: PUSH
5068: EMPTY
5069: LIST
5070: LIST
5071: PUSH
5072: LD_INT 1
5074: PPUSH
5075: LD_INT 2
5077: PPUSH
5078: CALL_OW 12
5082: ARRAY
5083: PPUSH
5084: CALL_OW 185
5088: GO 5020
5090: POP
5091: POP
// end ;
5092: LD_VAR 0 1
5096: RET
// every 0 0$1 trigger ruMobile and not ruEscapeAllowed do var i , filter , tmp , enemy , x ;
5097: LD_EXP 35
5101: PUSH
5102: LD_EXP 4
5106: NOT
5107: AND
5108: IFFALSE 5595
5110: GO 5112
5112: DISABLE
5113: LD_INT 0
5115: PPUSH
5116: PPUSH
5117: PPUSH
5118: PPUSH
5119: PPUSH
// begin enable ;
5120: ENABLE
// filter := UnitFilter ( ruMobile , [ f_type , unit_vehicle ] ) ;
5121: LD_ADDR_VAR 0 2
5125: PUSH
5126: LD_EXP 35
5130: PPUSH
5131: LD_INT 21
5133: PUSH
5134: LD_INT 2
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PPUSH
5141: CALL_OW 72
5145: ST_TO_ADDR
// enemy := FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_or , [ f_inarea , zone1 ] , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) ;
5146: LD_ADDR_VAR 0 4
5150: PUSH
5151: LD_INT 81
5153: PUSH
5154: LD_INT 3
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PUSH
5161: LD_INT 2
5163: PUSH
5164: LD_INT 95
5166: PUSH
5167: LD_INT 4
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: PUSH
5174: LD_INT 95
5176: PUSH
5177: LD_INT 5
5179: PUSH
5180: EMPTY
5181: LIST
5182: LIST
5183: PUSH
5184: LD_INT 95
5186: PUSH
5187: LD_INT 6
5189: PUSH
5190: EMPTY
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 95
5196: PUSH
5197: LD_INT 7
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: PUSH
5211: EMPTY
5212: LIST
5213: LIST
5214: PPUSH
5215: CALL_OW 69
5219: ST_TO_ADDR
// for i in filter do
5220: LD_ADDR_VAR 0 1
5224: PUSH
5225: LD_VAR 0 2
5229: PUSH
5230: FOR_IN
5231: IFFALSE 5593
// begin tmp := IsDrivenBy ( i ) ;
5233: LD_ADDR_VAR 0 3
5237: PUSH
5238: LD_VAR 0 1
5242: PPUSH
5243: CALL_OW 311
5247: ST_TO_ADDR
// if not tmp then
5248: LD_VAR 0 3
5252: NOT
5253: IFFALSE 5257
// continue ;
5255: GO 5230
// if GetFuel ( i ) > 90 and GetTag ( i ) = 2 then
5257: LD_VAR 0 1
5261: PPUSH
5262: CALL_OW 261
5266: PUSH
5267: LD_INT 90
5269: GREATER
5270: PUSH
5271: LD_VAR 0 1
5275: PPUSH
5276: CALL_OW 110
5280: PUSH
5281: LD_INT 2
5283: EQUAL
5284: AND
5285: IFFALSE 5301
// SetTag ( i , 0 ) else
5287: LD_VAR 0 1
5291: PPUSH
5292: LD_INT 0
5294: PPUSH
5295: CALL_OW 109
5299: GO 5344
// if GetTag ( i ) = 2 then
5301: LD_VAR 0 1
5305: PPUSH
5306: CALL_OW 110
5310: PUSH
5311: LD_INT 2
5313: EQUAL
5314: IFFALSE 5344
// begin x := rand ( 1 , 2 ) ;
5316: LD_ADDR_VAR 0 5
5320: PUSH
5321: LD_INT 1
5323: PPUSH
5324: LD_INT 2
5326: PPUSH
5327: CALL_OW 12
5331: ST_TO_ADDR
// AddComMoveUnit ( i , ruMainBase ) ;
5332: LD_VAR 0 1
5336: PPUSH
5337: LD_INT 200
5339: PPUSH
5340: CALL_OW 172
// end ; if GetLives ( i ) >= 600 and not GetTag ( i ) then
5344: LD_VAR 0 1
5348: PPUSH
5349: CALL_OW 256
5353: PUSH
5354: LD_INT 600
5356: GREATEREQUAL
5357: PUSH
5358: LD_VAR 0 1
5362: PPUSH
5363: CALL_OW 110
5367: NOT
5368: AND
5369: IFFALSE 5395
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
5371: LD_VAR 0 1
5375: PPUSH
5376: LD_VAR 0 4
5380: PPUSH
5381: LD_VAR 0 1
5385: PPUSH
5386: CALL_OW 74
5390: PPUSH
5391: CALL_OW 115
// if GetLives ( i ) < 600 and not GetTag ( i ) then
5395: LD_VAR 0 1
5399: PPUSH
5400: CALL_OW 256
5404: PUSH
5405: LD_INT 600
5407: LESS
5408: PUSH
5409: LD_VAR 0 1
5413: PPUSH
5414: CALL_OW 110
5418: NOT
5419: AND
5420: IFFALSE 5449
// begin SetTag ( i , 1 ) ;
5422: LD_VAR 0 1
5426: PPUSH
5427: LD_INT 1
5429: PPUSH
5430: CALL_OW 109
// ComMoveXY ( i , 112 , 119 ) ;
5434: LD_VAR 0 1
5438: PPUSH
5439: LD_INT 112
5441: PPUSH
5442: LD_INT 119
5444: PPUSH
5445: CALL_OW 111
// end ; if GetTag ( i ) = 1 and GetDistUnitXY ( i , 112 , 119 ) < 9 and tmp then
5449: LD_VAR 0 1
5453: PPUSH
5454: CALL_OW 110
5458: PUSH
5459: LD_INT 1
5461: EQUAL
5462: PUSH
5463: LD_VAR 0 1
5467: PPUSH
5468: LD_INT 112
5470: PPUSH
5471: LD_INT 119
5473: PPUSH
5474: CALL_OW 297
5478: PUSH
5479: LD_INT 9
5481: LESS
5482: AND
5483: PUSH
5484: LD_VAR 0 3
5488: AND
5489: IFFALSE 5591
// begin ComExitVehicle ( tmp ) ;
5491: LD_VAR 0 3
5495: PPUSH
5496: CALL_OW 121
// AddComRepairVehicle ( tmp , i ) ;
5500: LD_VAR 0 3
5504: PPUSH
5505: LD_VAR 0 1
5509: PPUSH
5510: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
5514: LD_INT 35
5516: PPUSH
5517: CALL_OW 67
// until GetLives ( i ) = 1000 ;
5521: LD_VAR 0 1
5525: PPUSH
5526: CALL_OW 256
5530: PUSH
5531: LD_INT 1000
5533: EQUAL
5534: IFFALSE 5514
// ComEnterUnit ( tmp , i ) ;
5536: LD_VAR 0 3
5540: PPUSH
5541: LD_VAR 0 1
5545: PPUSH
5546: CALL_OW 120
// if GetFuel ( i ) <= 50 then
5550: LD_VAR 0 1
5554: PPUSH
5555: CALL_OW 261
5559: PUSH
5560: LD_INT 50
5562: LESSEQUAL
5563: IFFALSE 5579
// SetTag ( i , 2 ) else
5565: LD_VAR 0 1
5569: PPUSH
5570: LD_INT 2
5572: PPUSH
5573: CALL_OW 109
5577: GO 5591
// SetTag ( i , 0 ) ;
5579: LD_VAR 0 1
5583: PPUSH
5584: LD_INT 0
5586: PPUSH
5587: CALL_OW 109
// end ; end ;
5591: GO 5230
5593: POP
5594: POP
// end ;
5595: PPOPN 5
5597: END
// every 0 0$1 trigger not ruEscapeAllowed and ruEng do var i , filter , tmp , enemy ;
5598: LD_EXP 4
5602: NOT
5603: PUSH
5604: LD_EXP 32
5608: AND
5609: IFFALSE 5851
5611: GO 5613
5613: DISABLE
5614: LD_INT 0
5616: PPUSH
5617: PPUSH
5618: PPUSH
5619: PPUSH
// begin enable ;
5620: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5621: LD_ADDR_VAR 0 2
5625: PUSH
5626: LD_INT 3
5628: PPUSH
5629: LD_INT 22
5631: PUSH
5632: LD_INT 3
5634: PUSH
5635: EMPTY
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 21
5641: PUSH
5642: LD_INT 3
5644: PUSH
5645: EMPTY
5646: LIST
5647: LIST
5648: PUSH
5649: LD_INT 3
5651: PUSH
5652: LD_INT 24
5654: PUSH
5655: LD_INT 1000
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: LIST
5670: PPUSH
5671: CALL_OW 70
5675: ST_TO_ADDR
// tmp := UnitFilter ( ruEng , [ f_ok ] ) ;
5676: LD_ADDR_VAR 0 3
5680: PUSH
5681: LD_EXP 32
5685: PPUSH
5686: LD_INT 50
5688: PUSH
5689: EMPTY
5690: LIST
5691: PPUSH
5692: CALL_OW 72
5696: ST_TO_ADDR
// if filter and tmp then
5697: LD_VAR 0 2
5701: PUSH
5702: LD_VAR 0 3
5706: AND
5707: IFFALSE 5780
// begin for i in tmp do
5709: LD_ADDR_VAR 0 1
5713: PUSH
5714: LD_VAR 0 3
5718: PUSH
5719: FOR_IN
5720: IFFALSE 5776
// if IsInUnit ( i ) then
5722: LD_VAR 0 1
5726: PPUSH
5727: CALL_OW 310
5731: IFFALSE 5744
// ComExitBuilding ( i ) else
5733: LD_VAR 0 1
5737: PPUSH
5738: CALL_OW 122
5742: GO 5774
// if not HasTask ( i ) then
5744: LD_VAR 0 1
5748: PPUSH
5749: CALL_OW 314
5753: NOT
5754: IFFALSE 5774
// ComRepairBuilding ( i , filter [ 1 ] ) ;
5756: LD_VAR 0 1
5760: PPUSH
5761: LD_VAR 0 2
5765: PUSH
5766: LD_INT 1
5768: ARRAY
5769: PPUSH
5770: CALL_OW 130
5774: GO 5719
5776: POP
5777: POP
// end else
5778: GO 5851
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
5780: LD_VAR 0 3
5784: PPUSH
5785: LD_INT 3
5787: PUSH
5788: LD_INT 54
5790: PUSH
5791: EMPTY
5792: LIST
5793: PUSH
5794: EMPTY
5795: LIST
5796: LIST
5797: PPUSH
5798: CALL_OW 72
5802: IFFALSE 5851
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
5804: LD_ADDR_VAR 0 1
5808: PUSH
5809: LD_VAR 0 3
5813: PPUSH
5814: LD_INT 3
5816: PUSH
5817: LD_INT 54
5819: PUSH
5820: EMPTY
5821: LIST
5822: PUSH
5823: EMPTY
5824: LIST
5825: LIST
5826: PPUSH
5827: CALL_OW 72
5831: PUSH
5832: FOR_IN
5833: IFFALSE 5849
// ComEnterUnit ( i , ruMainBase ) ;
5835: LD_VAR 0 1
5839: PPUSH
5840: LD_INT 200
5842: PPUSH
5843: CALL_OW 120
5847: GO 5832
5849: POP
5850: POP
// end ; end ;
5851: PPOPN 4
5853: END
// every 0 0$1 trigger not ruEscapeAllowed and ruSci do var i , filter , tmp , lab ;
5854: LD_EXP 4
5858: NOT
5859: PUSH
5860: LD_EXP 34
5864: AND
5865: IFFALSE 6125
5867: GO 5869
5869: DISABLE
5870: LD_INT 0
5872: PPUSH
5873: PPUSH
5874: PPUSH
5875: PPUSH
// begin enable ;
5876: ENABLE
// filter := FilterUnitsInArea ( ruMainBaseArea , [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
5877: LD_ADDR_VAR 0 2
5881: PUSH
5882: LD_INT 3
5884: PPUSH
5885: LD_INT 22
5887: PUSH
5888: LD_INT 3
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: PUSH
5895: LD_INT 21
5897: PUSH
5898: LD_INT 1
5900: PUSH
5901: EMPTY
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 3
5907: PUSH
5908: LD_INT 24
5910: PUSH
5911: LD_INT 1000
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: PUSH
5922: EMPTY
5923: LIST
5924: LIST
5925: LIST
5926: PPUSH
5927: CALL_OW 70
5931: ST_TO_ADDR
// tmp := UnitFilter ( ruSci , [ f_ok ] ) ;
5932: LD_ADDR_VAR 0 3
5936: PUSH
5937: LD_EXP 34
5941: PPUSH
5942: LD_INT 50
5944: PUSH
5945: EMPTY
5946: LIST
5947: PPUSH
5948: CALL_OW 72
5952: ST_TO_ADDR
// lab := HexInfo ( 118 , 121 ) ;
5953: LD_ADDR_VAR 0 4
5957: PUSH
5958: LD_INT 118
5960: PPUSH
5961: LD_INT 121
5963: PPUSH
5964: CALL_OW 428
5968: ST_TO_ADDR
// if filter and tmp then
5969: LD_VAR 0 2
5973: PUSH
5974: LD_VAR 0 3
5978: AND
5979: IFFALSE 6052
// begin for i in tmp do
5981: LD_ADDR_VAR 0 1
5985: PUSH
5986: LD_VAR 0 3
5990: PUSH
5991: FOR_IN
5992: IFFALSE 6048
// if IsInUnit ( i ) then
5994: LD_VAR 0 1
5998: PPUSH
5999: CALL_OW 310
6003: IFFALSE 6016
// ComExitBuilding ( i ) else
6005: LD_VAR 0 1
6009: PPUSH
6010: CALL_OW 122
6014: GO 6046
// if not HasTask ( i ) then
6016: LD_VAR 0 1
6020: PPUSH
6021: CALL_OW 314
6025: NOT
6026: IFFALSE 6046
// ComHeal ( i , filter [ 1 ] ) ;
6028: LD_VAR 0 1
6032: PPUSH
6033: LD_VAR 0 2
6037: PUSH
6038: LD_INT 1
6040: ARRAY
6041: PPUSH
6042: CALL_OW 128
6046: GO 5991
6048: POP
6049: POP
// end else
6050: GO 6125
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
6052: LD_VAR 0 3
6056: PPUSH
6057: LD_INT 3
6059: PUSH
6060: LD_INT 54
6062: PUSH
6063: EMPTY
6064: LIST
6065: PUSH
6066: EMPTY
6067: LIST
6068: LIST
6069: PPUSH
6070: CALL_OW 72
6074: IFFALSE 6125
// begin for i in UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) do
6076: LD_ADDR_VAR 0 1
6080: PUSH
6081: LD_VAR 0 3
6085: PPUSH
6086: LD_INT 3
6088: PUSH
6089: LD_INT 54
6091: PUSH
6092: EMPTY
6093: LIST
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PPUSH
6099: CALL_OW 72
6103: PUSH
6104: FOR_IN
6105: IFFALSE 6123
// ComEnterUnit ( i , lab ) ;
6107: LD_VAR 0 1
6111: PPUSH
6112: LD_VAR 0 4
6116: PPUSH
6117: CALL_OW 120
6121: GO 6104
6123: POP
6124: POP
// end ; end ; end_of_file
6125: PPOPN 4
6127: END
// on UnitDestroyed ( un ) do begin if un = Heike then
6128: LD_VAR 0 1
6132: PUSH
6133: LD_EXP 14
6137: EQUAL
6138: IFFALSE 6147
// YouLost ( Heike ) ;
6140: LD_STRING Heike
6142: PPUSH
6143: CALL_OW 104
// if un in ruEng then
6147: LD_VAR 0 1
6151: PUSH
6152: LD_EXP 32
6156: IN
6157: IFFALSE 6175
// ruEng := ruEng diff un ;
6159: LD_ADDR_EXP 32
6163: PUSH
6164: LD_EXP 32
6168: PUSH
6169: LD_VAR 0 1
6173: DIFF
6174: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) then
6175: LD_VAR 0 1
6179: PUSH
6180: LD_INT 22
6182: PUSH
6183: LD_INT 2
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: PUSH
6190: LD_INT 21
6192: PUSH
6193: LD_INT 1
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: PUSH
6200: LD_INT 23
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: EMPTY
6207: LIST
6208: LIST
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: LIST
6214: PPUSH
6215: CALL_OW 69
6219: IN
6220: IFFALSE 6236
// loseCounter := loseCounter + 1 ;
6222: LD_ADDR_EXP 6
6226: PUSH
6227: LD_EXP 6
6231: PUSH
6232: LD_INT 1
6234: PLUS
6235: ST_TO_ADDR
// end ;
6236: PPOPN 1
6238: END
// on EvacuateVehicle ( driver , un , p1 , p2 ) do var weapon , fac ;
6239: LD_INT 0
6241: PPUSH
6242: PPUSH
// begin if un in ruMobile then
6243: LD_VAR 0 2
6247: PUSH
6248: LD_EXP 35
6252: IN
6253: IFFALSE 6412
// begin ruMobile := ruMobile diff un ;
6255: LD_ADDR_EXP 35
6259: PUSH
6260: LD_EXP 35
6264: PUSH
6265: LD_VAR 0 2
6269: DIFF
6270: ST_TO_ADDR
// weapon := GetWeapon ( un ) ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_VAR 0 2
6280: PPUSH
6281: CALL_OW 264
6285: ST_TO_ADDR
// fac := HexInfo ( 110 , 126 ) ;
6286: LD_ADDR_VAR 0 6
6290: PUSH
6291: LD_INT 110
6293: PPUSH
6294: LD_INT 126
6296: PPUSH
6297: CALL_OW 428
6301: ST_TO_ADDR
// if not driver or not fac then
6302: LD_VAR 0 1
6306: NOT
6307: PUSH
6308: LD_VAR 0 6
6312: NOT
6313: OR
6314: IFFALSE 6318
// exit ;
6316: GO 6412
// AddComMoveXY ( driver , 111 , 121 ) ;
6318: LD_VAR 0 1
6322: PPUSH
6323: LD_INT 111
6325: PPUSH
6326: LD_INT 121
6328: PPUSH
6329: CALL_OW 171
// AddComEnterUnit ( driver , fac ) ;
6333: LD_VAR 0 1
6337: PPUSH
6338: LD_VAR 0 6
6342: PPUSH
6343: CALL_OW 180
// repeat wait ( 0 0$1 ) ;
6347: LD_INT 35
6349: PPUSH
6350: CALL_OW 67
// until IsDead ( driver ) or IsInUnit ( driver ) ;
6354: LD_VAR 0 1
6358: PPUSH
6359: CALL_OW 301
6363: PUSH
6364: LD_VAR 0 1
6368: PPUSH
6369: CALL_OW 310
6373: OR
6374: IFFALSE 6347
// if IsDead ( driver ) then
6376: LD_VAR 0 1
6380: PPUSH
6381: CALL_OW 301
6385: IFFALSE 6389
// exit ;
6387: GO 6412
// AddComConstruct ( fac , ru_medium_wheeled , engine_combustion , control_manual , weapon ) ;
6389: LD_VAR 0 6
6393: PPUSH
6394: LD_INT 21
6396: PPUSH
6397: LD_INT 1
6399: PPUSH
6400: LD_INT 1
6402: PPUSH
6403: LD_VAR 0 5
6407: PPUSH
6408: CALL_OW 185
// end ; end ;
6412: PPOPN 6
6414: END
// on VehicleConstructed ( veh , fac ) do begin if GetSide ( fac ) = 3 then
6415: LD_VAR 0 2
6419: PPUSH
6420: CALL_OW 255
6424: PUSH
6425: LD_INT 3
6427: EQUAL
6428: IFFALSE 6474
// begin ruMobile := Replace ( ruMobile , ruMobile + 1 , veh ) ;
6430: LD_ADDR_EXP 35
6434: PUSH
6435: LD_EXP 35
6439: PPUSH
6440: LD_EXP 35
6444: PUSH
6445: LD_INT 1
6447: PLUS
6448: PPUSH
6449: LD_VAR 0 1
6453: PPUSH
6454: CALL_OW 1
6458: ST_TO_ADDR
// AddComMoveXY ( veh , 110 , 117 ) ;
6459: LD_VAR 0 1
6463: PPUSH
6464: LD_INT 110
6466: PPUSH
6467: LD_INT 117
6469: PPUSH
6470: CALL_OW 171
// end ; end ;
6474: PPOPN 2
6476: END
// on LeaveBuilding ( b , un ) do var barracks ;
6477: LD_INT 0
6479: PPUSH
// begin if b in [ HexInfo ( 130 , 17 ) , HexInfo ( 138 , 22 ) , HexInfo ( 123 , 17 ) ] then
6480: LD_VAR 0 1
6484: PUSH
6485: LD_INT 130
6487: PPUSH
6488: LD_INT 17
6490: PPUSH
6491: CALL_OW 428
6495: PUSH
6496: LD_INT 138
6498: PPUSH
6499: LD_INT 22
6501: PPUSH
6502: CALL_OW 428
6506: PUSH
6507: LD_INT 123
6509: PPUSH
6510: LD_INT 17
6512: PPUSH
6513: CALL_OW 428
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: IN
6523: IFFALSE 6547
// begin AddComEnterUnit ( un , HexInfo ( 135 , 31 ) ) ;
6525: LD_VAR 0 2
6529: PPUSH
6530: LD_INT 135
6532: PPUSH
6533: LD_INT 31
6535: PPUSH
6536: CALL_OW 428
6540: PPUSH
6541: CALL_OW 180
// exit ;
6545: GO 6821
// end ; if b = HexInfo ( 135 , 31 ) then
6547: LD_VAR 0 1
6551: PUSH
6552: LD_INT 135
6554: PPUSH
6555: LD_INT 31
6557: PPUSH
6558: CALL_OW 428
6562: EQUAL
6563: IFFALSE 6635
// begin AddComEnterUnit ( un , HexInfo ( 106 , 51 ) ) ;
6565: LD_VAR 0 2
6569: PPUSH
6570: LD_INT 106
6572: PPUSH
6573: LD_INT 51
6575: PPUSH
6576: CALL_OW 428
6580: PPUSH
6581: CALL_OW 180
// if not explodeFirstDepot then
6585: LD_EXP 10
6589: NOT
6590: IFFALSE 6633
// begin explodeFirstDepot := true ;
6592: LD_ADDR_EXP 10
6596: PUSH
6597: LD_INT 1
6599: ST_TO_ADDR
// wait ( 0 0$15 ) ;
6600: LD_INT 525
6602: PPUSH
6603: CALL_OW 67
// MineExplosion ( 127 , 27 , 1 ) ;
6607: LD_INT 127
6609: PPUSH
6610: LD_INT 27
6612: PPUSH
6613: LD_INT 1
6615: PPUSH
6616: CALL_OW 453
// MineExplosion ( 125 , 29 , 1 ) ;
6620: LD_INT 125
6622: PPUSH
6623: LD_INT 29
6625: PPUSH
6626: LD_INT 1
6628: PPUSH
6629: CALL_OW 453
// end ; exit ;
6633: GO 6821
// end ; if b = HexInfo ( 106 , 51 ) then
6635: LD_VAR 0 1
6639: PUSH
6640: LD_INT 106
6642: PPUSH
6643: LD_INT 51
6645: PPUSH
6646: CALL_OW 428
6650: EQUAL
6651: IFFALSE 6751
// begin AddComMoveXY ( un , 106 , 93 ) ;
6653: LD_VAR 0 2
6657: PPUSH
6658: LD_INT 106
6660: PPUSH
6661: LD_INT 93
6663: PPUSH
6664: CALL_OW 171
// if not explodeSecondDepot then
6668: LD_EXP 11
6672: NOT
6673: IFFALSE 6749
// begin explodeSecondDepot := true ;
6675: LD_ADDR_EXP 11
6679: PUSH
6680: LD_INT 1
6682: ST_TO_ADDR
// wait ( 0 0$12 ) ;
6683: LD_INT 420
6685: PPUSH
6686: CALL_OW 67
// MineExplosion ( 111 , 75 , 1 ) ;
6690: LD_INT 111
6692: PPUSH
6693: LD_INT 75
6695: PPUSH
6696: LD_INT 1
6698: PPUSH
6699: CALL_OW 453
// MineExplosion ( 111 , 75 , 1 ) ;
6703: LD_INT 111
6705: PPUSH
6706: LD_INT 75
6708: PPUSH
6709: LD_INT 1
6711: PPUSH
6712: CALL_OW 453
// MineExplosion ( 108 , 69 , 1 ) ;
6716: LD_INT 108
6718: PPUSH
6719: LD_INT 69
6721: PPUSH
6722: LD_INT 1
6724: PPUSH
6725: CALL_OW 453
// wait ( 0 0$2 ) ;
6729: LD_INT 70
6731: PPUSH
6732: CALL_OW 67
// MineExplosion ( 94 , 65 , 1 ) ;
6736: LD_INT 94
6738: PPUSH
6739: LD_INT 65
6741: PPUSH
6742: LD_INT 1
6744: PPUSH
6745: CALL_OW 453
// end ; exit ;
6749: GO 6821
// end ; if GetBType ( b ) = b_bunker then
6751: LD_VAR 0 1
6755: PPUSH
6756: CALL_OW 266
6760: PUSH
6761: LD_INT 32
6763: EQUAL
6764: IFFALSE 6821
// begin barracks := NearestEmptyBuilding ( un , b_barracks ) ;
6766: LD_ADDR_VAR 0 3
6770: PUSH
6771: LD_VAR 0 2
6775: PPUSH
6776: LD_INT 5
6778: PPUSH
6779: CALL 2371 0 2
6783: ST_TO_ADDR
// if barracks then
6784: LD_VAR 0 3
6788: IFFALSE 6806
// AddComEnterUnit ( un , barracks ) else
6790: LD_VAR 0 2
6794: PPUSH
6795: LD_VAR 0 3
6799: PPUSH
6800: CALL_OW 180
6804: GO 6821
// AddComMoveXY ( un , 116 , 110 ) ;
6806: LD_VAR 0 2
6810: PPUSH
6811: LD_INT 116
6813: PPUSH
6814: LD_INT 110
6816: PPUSH
6817: CALL_OW 171
// end ; end ; end_of_file
6821: PPOPN 3
6823: END
// export function Action ; var i , un , veh , tmp , rutmp ; begin
6824: LD_INT 0
6826: PPUSH
6827: PPUSH
6828: PPUSH
6829: PPUSH
6830: PPUSH
6831: PPUSH
// InGameOn ;
6832: CALL_OW 8
// ChangeSideFog ( 5 , 2 ) ;
6836: LD_INT 5
6838: PPUSH
6839: LD_INT 2
6841: PPUSH
6842: CALL_OW 343
// music_nat := 4 ;
6846: LD_ADDR_OWVAR 71
6850: PUSH
6851: LD_INT 4
6853: ST_TO_ADDR
// music_class := music_combat ;
6854: LD_ADDR_OWVAR 72
6858: PUSH
6859: LD_INT 1
6861: ST_TO_ADDR
// PlaceSeeing ( 133 , 2 , 2 , 10 ) ;
6862: LD_INT 133
6864: PPUSH
6865: LD_INT 2
6867: PPUSH
6868: LD_INT 2
6870: PPUSH
6871: LD_INT 10
6873: PPUSH
6874: CALL_OW 330
// CenterNowOnXY ( 133 , 2 ) ;
6878: LD_INT 133
6880: PPUSH
6881: LD_INT 2
6883: PPUSH
6884: CALL_OW 86
// wait ( 0 0$1 ) ;
6888: LD_INT 35
6890: PPUSH
6891: CALL_OW 67
// uc_side := 6 ;
6895: LD_ADDR_OWVAR 20
6899: PUSH
6900: LD_INT 6
6902: ST_TO_ADDR
// uc_nation := 3 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 3
6910: ST_TO_ADDR
// rutmp := [ ] ;
6911: LD_ADDR_VAR 0 6
6915: PUSH
6916: EMPTY
6917: ST_TO_ADDR
// PrepareTank ( 6 , 3 , ru_medium_wheeled , engine_combustion , control_manual , ru_gun , 66 ) ;
6918: LD_INT 6
6920: PPUSH
6921: LD_INT 3
6923: PPUSH
6924: LD_INT 21
6926: PPUSH
6927: LD_INT 1
6929: PPUSH
6930: LD_INT 1
6932: PPUSH
6933: LD_INT 44
6935: PPUSH
6936: LD_INT 66
6938: PPUSH
6939: CALL 367 0 7
// veh := CreateVehicle ;
6943: LD_ADDR_VAR 0 4
6947: PUSH
6948: CALL_OW 45
6952: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
6953: LD_VAR 0 4
6957: PPUSH
6958: LD_INT 3
6960: PPUSH
6961: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
6965: LD_VAR 0 4
6969: PPUSH
6970: LD_INT 8
6972: PPUSH
6973: LD_INT 0
6975: PPUSH
6976: CALL_OW 49
// SetLives ( veh , 500 ) ;
6980: LD_VAR 0 4
6984: PPUSH
6985: LD_INT 500
6987: PPUSH
6988: CALL_OW 234
// PrepareHuman ( false , 3 , 3 ) ;
6992: LD_INT 0
6994: PPUSH
6995: LD_INT 3
6997: PPUSH
6998: LD_INT 3
7000: PPUSH
7001: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7005: CALL_OW 44
7009: PPUSH
7010: LD_VAR 0 4
7014: PPUSH
7015: CALL_OW 52
// ComMoveXY ( veh , 133 , 11 ) ;
7019: LD_VAR 0 4
7023: PPUSH
7024: LD_INT 133
7026: PPUSH
7027: LD_INT 11
7029: PPUSH
7030: CALL_OW 111
// rutmp := [ veh ] ;
7034: LD_ADDR_VAR 0 6
7038: PUSH
7039: LD_VAR 0 4
7043: PUSH
7044: EMPTY
7045: LIST
7046: ST_TO_ADDR
// for i := 1 to 4 do
7047: LD_ADDR_VAR 0 2
7051: PUSH
7052: DOUBLE
7053: LD_INT 1
7055: DEC
7056: ST_TO_ADDR
7057: LD_INT 4
7059: PUSH
7060: FOR_TO
7061: IFFALSE 7168
// begin PrepareHuman ( false , i , 2 ) ;
7063: LD_INT 0
7065: PPUSH
7066: LD_VAR 0 2
7070: PPUSH
7071: LD_INT 2
7073: PPUSH
7074: CALL_OW 380
// un := CreateHuman ;
7078: LD_ADDR_VAR 0 3
7082: PUSH
7083: CALL_OW 44
7087: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7088: LD_VAR 0 3
7092: PPUSH
7093: LD_INT 3
7095: PPUSH
7096: CALL_OW 233
// PlaceUnitArea ( un , spawnArea , false ) ;
7100: LD_VAR 0 3
7104: PPUSH
7105: LD_INT 8
7107: PPUSH
7108: LD_INT 0
7110: PPUSH
7111: CALL_OW 49
// rutmp := Replace ( rutmp , rutmp + 1 , un ) ;
7115: LD_ADDR_VAR 0 6
7119: PUSH
7120: LD_VAR 0 6
7124: PPUSH
7125: LD_VAR 0 6
7129: PUSH
7130: LD_INT 1
7132: PLUS
7133: PPUSH
7134: LD_VAR 0 3
7138: PPUSH
7139: CALL_OW 1
7143: ST_TO_ADDR
// ComMoveXY ( un , 133 , 11 ) ;
7144: LD_VAR 0 3
7148: PPUSH
7149: LD_INT 133
7151: PPUSH
7152: LD_INT 11
7154: PPUSH
7155: CALL_OW 111
// wait ( 0 0$0.5 ) ;
7159: LD_INT 18
7161: PPUSH
7162: CALL_OW 67
// end ;
7166: GO 7060
7168: POP
7169: POP
// for i in rutmp do
7170: LD_ADDR_VAR 0 2
7174: PUSH
7175: LD_VAR 0 6
7179: PUSH
7180: FOR_IN
7181: IFFALSE 7230
// begin AddComMoveXY ( i , 99 , 65 ) ;
7183: LD_VAR 0 2
7187: PPUSH
7188: LD_INT 99
7190: PPUSH
7191: LD_INT 65
7193: PPUSH
7194: CALL_OW 171
// AddComMoveXY ( i , 76 , 108 ) ;
7198: LD_VAR 0 2
7202: PPUSH
7203: LD_INT 76
7205: PPUSH
7206: LD_INT 108
7208: PPUSH
7209: CALL_OW 171
// AddComMoveXY ( i , 92 , 176 ) ;
7213: LD_VAR 0 2
7217: PPUSH
7218: LD_INT 92
7220: PPUSH
7221: LD_INT 176
7223: PPUSH
7224: CALL_OW 171
// end ;
7228: GO 7180
7230: POP
7231: POP
// wait ( 0 0$10 ) ;
7232: LD_INT 350
7234: PPUSH
7235: CALL_OW 67
// tmp := [ Heike , Givi , Mike , Ibrahim , Kamil , Kaia , Sophia , Markov , Kurt , Aviradze ] union heikeSecondSquad ;
7239: LD_ADDR_VAR 0 5
7243: PUSH
7244: LD_EXP 14
7248: PUSH
7249: LD_EXP 15
7253: PUSH
7254: LD_EXP 16
7258: PUSH
7259: LD_EXP 17
7263: PUSH
7264: LD_EXP 18
7268: PUSH
7269: LD_EXP 19
7273: PUSH
7274: LD_EXP 20
7278: PUSH
7279: LD_EXP 21
7283: PUSH
7284: LD_EXP 23
7288: PUSH
7289: LD_EXP 24
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: LIST
7298: LIST
7299: LIST
7300: LIST
7301: LIST
7302: LIST
7303: LIST
7304: LIST
7305: PUSH
7306: LD_EXP 25
7310: UNION
7311: ST_TO_ADDR
// tmp := tmp diff 0 ;
7312: LD_ADDR_VAR 0 5
7316: PUSH
7317: LD_VAR 0 5
7321: PUSH
7322: LD_INT 0
7324: DIFF
7325: ST_TO_ADDR
// for i in heikeVehicles do
7326: LD_ADDR_VAR 0 2
7330: PUSH
7331: LD_EXP 26
7335: PUSH
7336: FOR_IN
7337: IFFALSE 7603
// begin if not tmp then
7339: LD_VAR 0 5
7343: NOT
7344: IFFALSE 7348
// continue ;
7346: GO 7336
// PrepareTank ( 2 , i [ 5 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] , i [ 4 ] , 34 ) ;
7348: LD_INT 2
7350: PPUSH
7351: LD_VAR 0 2
7355: PUSH
7356: LD_INT 5
7358: ARRAY
7359: PPUSH
7360: LD_VAR 0 2
7364: PUSH
7365: LD_INT 1
7367: ARRAY
7368: PPUSH
7369: LD_VAR 0 2
7373: PUSH
7374: LD_INT 2
7376: ARRAY
7377: PPUSH
7378: LD_VAR 0 2
7382: PUSH
7383: LD_INT 3
7385: ARRAY
7386: PPUSH
7387: LD_VAR 0 2
7391: PUSH
7392: LD_INT 4
7394: ARRAY
7395: PPUSH
7396: LD_INT 34
7398: PPUSH
7399: CALL 367 0 7
// veh := CreateVehicle ;
7403: LD_ADDR_VAR 0 4
7407: PUSH
7408: CALL_OW 45
7412: ST_TO_ADDR
// if i [ 4 ] in [ ru_cargo_bay , ar_cargo_bay , us_cargo_bay ] then
7413: LD_VAR 0 2
7417: PUSH
7418: LD_INT 4
7420: ARRAY
7421: PUSH
7422: LD_INT 51
7424: PUSH
7425: LD_INT 32
7427: PUSH
7428: LD_INT 12
7430: PUSH
7431: EMPTY
7432: LIST
7433: LIST
7434: LIST
7435: IN
7436: IFFALSE 7516
// begin if i [ 7 ] [ 1 ] then
7438: LD_VAR 0 2
7442: PUSH
7443: LD_INT 7
7445: ARRAY
7446: PUSH
7447: LD_INT 1
7449: ARRAY
7450: IFFALSE 7477
// AddCargo ( veh , mat_cans , i [ 7 ] [ 1 ] ) ;
7452: LD_VAR 0 4
7456: PPUSH
7457: LD_INT 1
7459: PPUSH
7460: LD_VAR 0 2
7464: PUSH
7465: LD_INT 7
7467: ARRAY
7468: PUSH
7469: LD_INT 1
7471: ARRAY
7472: PPUSH
7473: CALL_OW 291
// if i [ 7 ] [ 2 ] then
7477: LD_VAR 0 2
7481: PUSH
7482: LD_INT 7
7484: ARRAY
7485: PUSH
7486: LD_INT 2
7488: ARRAY
7489: IFFALSE 7516
// AddCargo ( veh , mat_oil , i [ 7 ] [ 2 ] ) ;
7491: LD_VAR 0 4
7495: PPUSH
7496: LD_INT 2
7498: PPUSH
7499: LD_VAR 0 2
7503: PUSH
7504: LD_INT 7
7506: ARRAY
7507: PUSH
7508: LD_INT 2
7510: ARRAY
7511: PPUSH
7512: CALL_OW 291
// end ; SetDir ( veh , 3 ) ;
7516: LD_VAR 0 4
7520: PPUSH
7521: LD_INT 3
7523: PPUSH
7524: CALL_OW 233
// PlaceUnitArea ( veh , spawnArea , false ) ;
7528: LD_VAR 0 4
7532: PPUSH
7533: LD_INT 8
7535: PPUSH
7536: LD_INT 0
7538: PPUSH
7539: CALL_OW 49
// PlaceHumanInUnit ( tmp [ 1 ] , veh ) ;
7543: LD_VAR 0 5
7547: PUSH
7548: LD_INT 1
7550: ARRAY
7551: PPUSH
7552: LD_VAR 0 4
7556: PPUSH
7557: CALL_OW 52
// tmp := Delete ( tmp , 1 ) ;
7561: LD_ADDR_VAR 0 5
7565: PUSH
7566: LD_VAR 0 5
7570: PPUSH
7571: LD_INT 1
7573: PPUSH
7574: CALL_OW 3
7578: ST_TO_ADDR
// ComAgressiveMove ( veh , 133 , 7 ) ;
7579: LD_VAR 0 4
7583: PPUSH
7584: LD_INT 133
7586: PPUSH
7587: LD_INT 7
7589: PPUSH
7590: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7594: LD_INT 18
7596: PPUSH
7597: CALL_OW 67
// end ;
7601: GO 7336
7603: POP
7604: POP
// if tmp then
7605: LD_VAR 0 5
7609: IFFALSE 7665
// for i in tmp do
7611: LD_ADDR_VAR 0 2
7615: PUSH
7616: LD_VAR 0 5
7620: PUSH
7621: FOR_IN
7622: IFFALSE 7663
// begin PlaceUnitArea ( i , spawnArea , false ) ;
7624: LD_VAR 0 2
7628: PPUSH
7629: LD_INT 8
7631: PPUSH
7632: LD_INT 0
7634: PPUSH
7635: CALL_OW 49
// ComAgressiveMove ( i , 134 , 4 ) ;
7639: LD_VAR 0 2
7643: PPUSH
7644: LD_INT 134
7646: PPUSH
7647: LD_INT 4
7649: PPUSH
7650: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7654: LD_INT 18
7656: PPUSH
7657: CALL_OW 67
// end ;
7661: GO 7621
7663: POP
7664: POP
// if heikeApes then
7665: LD_EXP 27
7669: IFFALSE 7725
// for i in heikeApes do
7671: LD_ADDR_VAR 0 2
7675: PUSH
7676: LD_EXP 27
7680: PUSH
7681: FOR_IN
7682: IFFALSE 7723
// begin PlaceUnitArea ( i , spawnArea , false ) ;
7684: LD_VAR 0 2
7688: PPUSH
7689: LD_INT 8
7691: PPUSH
7692: LD_INT 0
7694: PPUSH
7695: CALL_OW 49
// ComAgressiveMove ( i , 134 , 4 ) ;
7699: LD_VAR 0 2
7703: PPUSH
7704: LD_INT 134
7706: PPUSH
7707: LD_INT 4
7709: PPUSH
7710: CALL_OW 114
// wait ( 0 0$0.5 ) ;
7714: LD_INT 18
7716: PPUSH
7717: CALL_OW 67
// end ;
7721: GO 7681
7723: POP
7724: POP
// DialogueOn ;
7725: CALL_OW 6
// Say ( Heike , DH-outpost-a-1 ) ;
7729: LD_EXP 14
7733: PPUSH
7734: LD_STRING DH-outpost-a-1
7736: PPUSH
7737: CALL_OW 88
// DialogueOff ;
7741: CALL_OW 7
// RemoveSeeing ( 133 , 2 , 2 ) ;
7745: LD_INT 133
7747: PPUSH
7748: LD_INT 2
7750: PPUSH
7751: LD_INT 2
7753: PPUSH
7754: CALL_OW 331
// InGameOff ;
7758: CALL_OW 9
// music_nat := 0 ;
7762: LD_ADDR_OWVAR 71
7766: PUSH
7767: LD_INT 0
7769: ST_TO_ADDR
// music_class := 0 ;
7770: LD_ADDR_OWVAR 72
7774: PUSH
7775: LD_INT 0
7777: ST_TO_ADDR
// ChangeMissionObjectives ( Outposts ) ;
7778: LD_STRING Outposts
7780: PPUSH
7781: CALL_OW 337
// SaveForQuickRestart ;
7785: CALL_OW 22
// end ;
7789: LD_VAR 0 1
7793: RET
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 20 ] ] ) and ibrahimOnRuSide and IsOk ( Ibrahim ) do
7794: LD_INT 22
7796: PUSH
7797: LD_INT 2
7799: PUSH
7800: EMPTY
7801: LIST
7802: LIST
7803: PUSH
7804: LD_INT 91
7806: PUSH
7807: LD_EXP 17
7811: PUSH
7812: LD_INT 20
7814: PUSH
7815: EMPTY
7816: LIST
7817: LIST
7818: LIST
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PPUSH
7824: CALL_OW 69
7828: PUSH
7829: LD_EXP 3
7833: AND
7834: PUSH
7835: LD_EXP 17
7839: PPUSH
7840: CALL_OW 302
7844: AND
7845: IFFALSE 7933
7847: GO 7849
7849: DISABLE
// begin IbrahimBetrayal ;
7850: CALL 7934 0 0
// repeat wait ( 0 0$1 ) ;
7854: LD_INT 35
7856: PPUSH
7857: CALL_OW 67
// until IsDead ( Ibrahim ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_dist , Ibrahim , 6 ] ] ) ;
7861: LD_EXP 17
7865: PPUSH
7866: CALL_OW 301
7870: PUSH
7871: LD_INT 22
7873: PUSH
7874: LD_INT 2
7876: PUSH
7877: EMPTY
7878: LIST
7879: LIST
7880: PUSH
7881: LD_INT 91
7883: PUSH
7884: LD_EXP 17
7888: PUSH
7889: LD_INT 6
7891: PUSH
7892: EMPTY
7893: LIST
7894: LIST
7895: LIST
7896: PUSH
7897: EMPTY
7898: LIST
7899: LIST
7900: PPUSH
7901: CALL_OW 69
7905: OR
7906: IFFALSE 7854
// if IsDead ( Ibrahim ) then
7908: LD_EXP 17
7912: PPUSH
7913: CALL_OW 301
7917: IFFALSE 7921
// exit ;
7919: GO 7933
// SetSide ( Ibrahim , 2 ) ;
7921: LD_EXP 17
7925: PPUSH
7926: LD_INT 2
7928: PPUSH
7929: CALL_OW 235
// end ;
7933: END
// export function IbrahimBetrayal ; var i , tmp ; begin
7934: LD_INT 0
7936: PPUSH
7937: PPUSH
7938: PPUSH
// PlaceSeeing ( 122 , 77 , 2 , - 6 ) ;
7939: LD_INT 122
7941: PPUSH
7942: LD_INT 77
7944: PPUSH
7945: LD_INT 2
7947: PPUSH
7948: LD_INT 6
7950: NEG
7951: PPUSH
7952: CALL_OW 330
// ComMoveXY ( Ibrahim , 123 , 79 ) ;
7956: LD_EXP 17
7960: PPUSH
7961: LD_INT 123
7963: PPUSH
7964: LD_INT 79
7966: PPUSH
7967: CALL_OW 111
// AddComTurnXY ( Ibrahim , 125 , 82 ) ;
7971: LD_EXP 17
7975: PPUSH
7976: LD_INT 125
7978: PPUSH
7979: LD_INT 82
7981: PPUSH
7982: CALL_OW 178
// wait ( 0 0$2 ) ;
7986: LD_INT 70
7988: PPUSH
7989: CALL_OW 67
// ComTurnUnit ( ruSol , Ibrahim ) ;
7993: LD_EXP 36
7997: PPUSH
7998: LD_EXP 17
8002: PPUSH
8003: CALL_OW 119
// Say ( ruSol , DRum-outpost-b-3 ) ;
8007: LD_EXP 36
8011: PPUSH
8012: LD_STRING DRum-outpost-b-3
8014: PPUSH
8015: CALL_OW 88
// tmp := [ HexInfo ( 125 , 76 ) , HexInfo ( 125 , 79 ) , HexInfo ( 125 , 82 ) ] ;
8019: LD_ADDR_VAR 0 3
8023: PUSH
8024: LD_INT 125
8026: PPUSH
8027: LD_INT 76
8029: PPUSH
8030: CALL_OW 428
8034: PUSH
8035: LD_INT 125
8037: PPUSH
8038: LD_INT 79
8040: PPUSH
8041: CALL_OW 428
8045: PUSH
8046: LD_INT 125
8048: PPUSH
8049: LD_INT 82
8051: PPUSH
8052: CALL_OW 428
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: LIST
8061: ST_TO_ADDR
// for i in tmp do
8062: LD_ADDR_VAR 0 2
8066: PUSH
8067: LD_VAR 0 3
8071: PUSH
8072: FOR_IN
8073: IFFALSE 8089
// SetLives ( i , 200 ) ;
8075: LD_VAR 0 2
8079: PPUSH
8080: LD_INT 200
8082: PPUSH
8083: CALL_OW 234
8087: GO 8072
8089: POP
8090: POP
// Say ( Ibrahim , DI-outpost-b-4 ) ;
8091: LD_EXP 17
8095: PPUSH
8096: LD_STRING DI-outpost-b-4
8098: PPUSH
8099: CALL_OW 88
// SetSide ( Ibrahim , 5 ) ;
8103: LD_EXP 17
8107: PPUSH
8108: LD_INT 5
8110: PPUSH
8111: CALL_OW 235
// ComFree ( [ Ibrahim , ruSol ] ) ;
8115: LD_EXP 17
8119: PUSH
8120: LD_EXP 36
8124: PUSH
8125: EMPTY
8126: LIST
8127: LIST
8128: PPUSH
8129: CALL_OW 139
// RemoveSeeing ( 122 , 77 , 2 ) ;
8133: LD_INT 122
8135: PPUSH
8136: LD_INT 77
8138: PPUSH
8139: LD_INT 2
8141: PPUSH
8142: CALL_OW 331
// if Givi then
8146: LD_EXP 15
8150: IFFALSE 8166
// Say ( Givi , DG-1-outpost-b-5 ) else
8152: LD_EXP 15
8156: PPUSH
8157: LD_STRING DG-1-outpost-b-5
8159: PPUSH
8160: CALL_OW 88
8164: GO 8231
// if not Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_female ] ) [ 1 ] , DArf-outpost-b-a-5 ) then
8166: LD_EXP 25
8170: PPUSH
8171: LD_INT 26
8173: PUSH
8174: LD_INT 2
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PPUSH
8181: CALL_OW 72
8185: PUSH
8186: LD_INT 1
8188: ARRAY
8189: PPUSH
8190: LD_STRING DArf-outpost-b-a-5
8192: PPUSH
8193: CALL_OW 88
8197: NOT
8198: IFFALSE 8231
// Say ( UnitFilter ( heikeSecondSquad , [ f_sex , sex_male ] ) [ 1 ] , DArm-outpost-b-a-5 ) ;
8200: LD_EXP 25
8204: PPUSH
8205: LD_INT 26
8207: PUSH
8208: LD_INT 1
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: PPUSH
8215: CALL_OW 72
8219: PUSH
8220: LD_INT 1
8222: ARRAY
8223: PPUSH
8224: LD_STRING DArm-outpost-b-a-5
8226: PPUSH
8227: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
8231: LD_INT 35
8233: PPUSH
8234: CALL_OW 67
// until IsDead ( Ibrahim ) or ( GetDistUnits ( Heike , Ibrahim ) < 6 and IsOk ( Ibrahim ) ) ;
8238: LD_EXP 17
8242: PPUSH
8243: CALL_OW 301
8247: PUSH
8248: LD_EXP 14
8252: PPUSH
8253: LD_EXP 17
8257: PPUSH
8258: CALL_OW 296
8262: PUSH
8263: LD_INT 6
8265: LESS
8266: PUSH
8267: LD_EXP 17
8271: PPUSH
8272: CALL_OW 302
8276: AND
8277: OR
8278: IFFALSE 8231
// if IsDead ( Ibrahim ) then
8280: LD_EXP 17
8284: PPUSH
8285: CALL_OW 301
8289: IFFALSE 8305
// begin Say ( Heike , DH-ibrahimdead-1 ) ;
8291: LD_EXP 14
8295: PPUSH
8296: LD_STRING DH-ibrahimdead-1
8298: PPUSH
8299: CALL_OW 88
// exit ;
8303: GO 8350
// end ; CenterNowOnUnits ( Ibrahim ) ;
8305: LD_EXP 17
8309: PPUSH
8310: CALL_OW 87
// Say ( Ibrahim , DI-ibrahimlives-1 ) ;
8314: LD_EXP 17
8318: PPUSH
8319: LD_STRING DI-ibrahimlives-1
8321: PPUSH
8322: CALL_OW 88
// Say ( Heike , DH-Ibrahimlives-2 ) ;
8326: LD_EXP 14
8330: PPUSH
8331: LD_STRING DH-Ibrahimlives-2
8333: PPUSH
8334: CALL_OW 88
// SetSide ( Ibrahim , 2 ) ;
8338: LD_EXP 17
8342: PPUSH
8343: LD_INT 2
8345: PPUSH
8346: CALL_OW 235
// end ;
8350: LD_VAR 0 1
8354: RET
// every 0 0$2 trigger IsDead ( ruSecBase ) or GetSide ( ruSecBase ) = 2 do
8355: LD_INT 225
8357: PPUSH
8358: CALL_OW 301
8362: PUSH
8363: LD_INT 225
8365: PPUSH
8366: CALL_OW 255
8370: PUSH
8371: LD_INT 2
8373: EQUAL
8374: OR
8375: IFFALSE 8658
8377: GO 8379
8379: DISABLE
// begin wait ( 0 0$20 ) ;
8380: LD_INT 700
8382: PPUSH
8383: CALL_OW 67
// DialogueOn ;
8387: CALL_OW 6
// SayRadio ( Shariff , DShar-radio-1 ) ;
8391: LD_EXP 22
8395: PPUSH
8396: LD_STRING DShar-radio-1
8398: PPUSH
8399: CALL_OW 94
// SayRadio ( Shariff , DShar-radio-2 ) ;
8403: LD_EXP 22
8407: PPUSH
8408: LD_STRING DShar-radio-2
8410: PPUSH
8411: CALL_OW 94
// Say ( Heike , DH-radio-2 ) ;
8415: LD_EXP 14
8419: PPUSH
8420: LD_STRING DH-radio-2
8422: PPUSH
8423: CALL_OW 88
// DialogueOff ;
8427: CALL_OW 7
// ChangeMissionObjectives ( Gaidar ) ;
8431: LD_STRING Gaidar
8433: PPUSH
8434: CALL_OW 337
// wait ( 0 0$30 + rand ( 0 0$10 , 0 0$20 ) * Difficulty ) ;
8438: LD_INT 1050
8440: PUSH
8441: LD_INT 350
8443: PPUSH
8444: LD_INT 700
8446: PPUSH
8447: CALL_OW 12
8451: PUSH
8452: LD_OWVAR 67
8456: MUL
8457: PLUS
8458: PPUSH
8459: CALL_OW 67
// PlaceUnitXY ( Gaidar , 2 , 1 , false ) ;
8463: LD_EXP 29
8467: PPUSH
8468: LD_INT 2
8470: PPUSH
8471: LD_INT 1
8473: PPUSH
8474: LD_INT 0
8476: PPUSH
8477: CALL_OW 48
// ComMoveXY ( Gaidar , 19 , 24 ) ;
8481: LD_EXP 29
8485: PPUSH
8486: LD_INT 19
8488: PPUSH
8489: LD_INT 24
8491: PPUSH
8492: CALL_OW 111
// AddComWait ( Gaidar , 0 0$6 ) ;
8496: LD_EXP 29
8500: PPUSH
8501: LD_INT 210
8503: PPUSH
8504: CALL_OW 202
// AddComMoveXY ( Gaidar , 38 , 47 ) ;
8508: LD_EXP 29
8512: PPUSH
8513: LD_INT 38
8515: PPUSH
8516: LD_INT 47
8518: PPUSH
8519: CALL_OW 171
// AddComMoveXY ( Gaidar , 32 , 59 ) ;
8523: LD_EXP 29
8527: PPUSH
8528: LD_INT 32
8530: PPUSH
8531: LD_INT 59
8533: PPUSH
8534: CALL_OW 171
// AddComWait ( Gaidar , 0 0$10 ) ;
8538: LD_EXP 29
8542: PPUSH
8543: LD_INT 350
8545: PPUSH
8546: CALL_OW 202
// AddComMoveXY ( Gaidar , 62 , 116 ) ;
8550: LD_EXP 29
8554: PPUSH
8555: LD_INT 62
8557: PPUSH
8558: LD_INT 116
8560: PPUSH
8561: CALL_OW 171
// AddComMoveXY ( Gaidar , 92 , 177 ) ;
8565: LD_EXP 29
8569: PPUSH
8570: LD_INT 92
8572: PPUSH
8573: LD_INT 177
8575: PPUSH
8576: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8580: LD_INT 35
8582: PPUSH
8583: CALL_OW 67
// until IsDead ( Gaidar ) or IsAt ( Gaidar , 92 , 177 ) ;
8587: LD_EXP 29
8591: PPUSH
8592: CALL_OW 301
8596: PUSH
8597: LD_EXP 29
8601: PPUSH
8602: LD_INT 92
8604: PPUSH
8605: LD_INT 177
8607: PPUSH
8608: CALL_OW 307
8612: OR
8613: IFFALSE 8580
// if IsAt ( Gaidar , 92 , 177 ) then
8615: LD_EXP 29
8619: PPUSH
8620: LD_INT 92
8622: PPUSH
8623: LD_INT 177
8625: PPUSH
8626: CALL_OW 307
8630: IFFALSE 8643
// begin RemoveUnit ( Gaidar ) ;
8632: LD_EXP 29
8636: PPUSH
8637: CALL_OW 64
// exit ;
8641: GO 8658
// end ; gaidarKilled := true ;
8643: LD_ADDR_EXP 12
8647: PUSH
8648: LD_INT 1
8650: ST_TO_ADDR
// ChangeMissionObjectives ( GaidarKilled ) ;
8651: LD_STRING GaidarKilled
8653: PPUSH
8654: CALL_OW 337
// end ;
8658: END
// every 0 0$1 trigger See ( 2 , Gaidar ) do
8659: LD_INT 2
8661: PPUSH
8662: LD_EXP 29
8666: PPUSH
8667: CALL_OW 292
8671: IFFALSE 8688
8673: GO 8675
8675: DISABLE
// Say ( Gaidar , DT-objective-1 ) ;
8676: LD_EXP 29
8680: PPUSH
8681: LD_STRING DT-objective-1
8683: PPUSH
8684: CALL_OW 88
8688: END
// every 0 0$5 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_inarea , zone2 ] , [ f_inarea , zone3 ] , [ f_inarea , zone4 ] ] ] ) do
8689: LD_INT 22
8691: PUSH
8692: LD_INT 2
8694: PUSH
8695: EMPTY
8696: LIST
8697: LIST
8698: PUSH
8699: LD_INT 2
8701: PUSH
8702: LD_INT 95
8704: PUSH
8705: LD_INT 5
8707: PUSH
8708: EMPTY
8709: LIST
8710: LIST
8711: PUSH
8712: LD_INT 95
8714: PUSH
8715: LD_INT 6
8717: PUSH
8718: EMPTY
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 95
8724: PUSH
8725: LD_INT 7
8727: PUSH
8728: EMPTY
8729: LIST
8730: LIST
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: PUSH
8738: EMPTY
8739: LIST
8740: LIST
8741: PPUSH
8742: CALL_OW 69
8746: IFFALSE 8775
8748: GO 8750
8750: DISABLE
// begin Say ( Heike , DH-outpost-last-1 ) ;
8751: LD_EXP 14
8755: PPUSH
8756: LD_STRING DH-outpost-last-1
8758: PPUSH
8759: CALL_OW 88
// SayRadio ( Burlak , DB-outpost-last-2 ) ;
8763: LD_EXP 28
8767: PPUSH
8768: LD_STRING DB-outpost-last-2
8770: PPUSH
8771: CALL_OW 94
// end ;
8775: END
// every 0 0$1 trigger GetLives ( ruMainBase ) < 999 or GetSide ( ruMainBase ) = 2 do var i , tmp ;
8776: LD_INT 200
8778: PPUSH
8779: CALL_OW 256
8783: PUSH
8784: LD_INT 999
8786: LESS
8787: PUSH
8788: LD_INT 200
8790: PPUSH
8791: CALL_OW 255
8795: PUSH
8796: LD_INT 2
8798: EQUAL
8799: OR
8800: IFFALSE 8949
8802: GO 8804
8804: DISABLE
8805: LD_INT 0
8807: PPUSH
8808: PPUSH
// begin SayRadio ( Burlak , DB-end-1 ) ;
8809: LD_EXP 28
8813: PPUSH
8814: LD_STRING DB-end-1
8816: PPUSH
8817: CALL_OW 94
// Say ( Heike , DH-end-2 ) ;
8821: LD_EXP 14
8825: PPUSH
8826: LD_STRING DH-end-2
8828: PPUSH
8829: CALL_OW 88
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
8833: LD_ADDR_VAR 0 2
8837: PUSH
8838: LD_INT 22
8840: PUSH
8841: LD_INT 3
8843: PUSH
8844: EMPTY
8845: LIST
8846: LIST
8847: PUSH
8848: LD_INT 3
8850: PUSH
8851: LD_INT 21
8853: PUSH
8854: LD_INT 3
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: PUSH
8861: EMPTY
8862: LIST
8863: LIST
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: PPUSH
8869: CALL_OW 69
8873: ST_TO_ADDR
// if not tmp then
8874: LD_VAR 0 2
8878: NOT
8879: IFFALSE 8883
// exit ;
8881: GO 8949
// for i in tmp do
8883: LD_ADDR_VAR 0 1
8887: PUSH
8888: LD_VAR 0 2
8892: PUSH
8893: FOR_IN
8894: IFFALSE 8947
// begin SetTag ( i , tEscape ) ;
8896: LD_VAR 0 1
8900: PPUSH
8901: LD_EXP 13
8905: PPUSH
8906: CALL_OW 109
// if IsInUnit ( i ) then
8910: LD_VAR 0 1
8914: PPUSH
8915: CALL_OW 310
8919: IFFALSE 8930
// ComExitBuilding ( i ) ;
8921: LD_VAR 0 1
8925: PPUSH
8926: CALL_OW 122
// AddComMoveXY ( i , 92 , 177 ) ;
8930: LD_VAR 0 1
8934: PPUSH
8935: LD_INT 92
8937: PPUSH
8938: LD_INT 177
8940: PPUSH
8941: CALL_OW 171
// end ;
8945: GO 8893
8947: POP
8948: POP
// end ;
8949: PPOPN 2
8951: END
// every 0 0$1 trigger FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do var i ;
8952: LD_INT 9
8954: PPUSH
8955: LD_INT 2
8957: PUSH
8958: LD_INT 22
8960: PUSH
8961: LD_INT 3
8963: PUSH
8964: EMPTY
8965: LIST
8966: LIST
8967: PUSH
8968: LD_INT 22
8970: PUSH
8971: LD_INT 6
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: EMPTY
8979: LIST
8980: LIST
8981: LIST
8982: PPUSH
8983: CALL_OW 70
8987: IFFALSE 9085
8989: GO 8991
8991: DISABLE
8992: LD_INT 0
8994: PPUSH
// begin enable ;
8995: ENABLE
// for i in FilterUnitsInArea ( escapeArea , [ f_or , [ f_side , 3 ] , [ f_side , 6 ] ] ) do
8996: LD_ADDR_VAR 0 1
9000: PUSH
9001: LD_INT 9
9003: PPUSH
9004: LD_INT 2
9006: PUSH
9007: LD_INT 22
9009: PUSH
9010: LD_INT 3
9012: PUSH
9013: EMPTY
9014: LIST
9015: LIST
9016: PUSH
9017: LD_INT 22
9019: PUSH
9020: LD_INT 6
9022: PUSH
9023: EMPTY
9024: LIST
9025: LIST
9026: PUSH
9027: EMPTY
9028: LIST
9029: LIST
9030: LIST
9031: PPUSH
9032: CALL_OW 70
9036: PUSH
9037: FOR_IN
9038: IFFALSE 9083
// if GetTag ( i ) = tEscape or GetSide ( i ) = 6 then
9040: LD_VAR 0 1
9044: PPUSH
9045: CALL_OW 110
9049: PUSH
9050: LD_EXP 13
9054: EQUAL
9055: PUSH
9056: LD_VAR 0 1
9060: PPUSH
9061: CALL_OW 255
9065: PUSH
9066: LD_INT 6
9068: EQUAL
9069: OR
9070: IFFALSE 9081
// RemoveUnit ( i ) ;
9072: LD_VAR 0 1
9076: PPUSH
9077: CALL_OW 64
9081: GO 9037
9083: POP
9084: POP
// end ;
9085: PPOPN 1
9087: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_btype , b_warehouse ] , [ f_btype , b_depot ] ] ] ) = 0 do var tmp ;
9088: LD_INT 22
9090: PUSH
9091: LD_INT 3
9093: PUSH
9094: EMPTY
9095: LIST
9096: LIST
9097: PUSH
9098: LD_INT 2
9100: PUSH
9101: LD_INT 30
9103: PUSH
9104: LD_INT 1
9106: PUSH
9107: EMPTY
9108: LIST
9109: LIST
9110: PUSH
9111: LD_INT 30
9113: PUSH
9114: LD_INT 0
9116: PUSH
9117: EMPTY
9118: LIST
9119: LIST
9120: PUSH
9121: EMPTY
9122: LIST
9123: LIST
9124: LIST
9125: PUSH
9126: EMPTY
9127: LIST
9128: LIST
9129: PPUSH
9130: CALL_OW 69
9134: PUSH
9135: LD_INT 0
9137: EQUAL
9138: IFFALSE 9592
9140: GO 9142
9142: DISABLE
9143: LD_INT 0
9145: PPUSH
// begin if tick + gameTime <= [ 60 60$00 , 55 55$00 , 50 50$00 ] [ Difficulty ] then
9146: LD_OWVAR 1
9150: PUSH
9151: LD_EXP 5
9155: PLUS
9156: PUSH
9157: LD_INT 126000
9159: PUSH
9160: LD_INT 115500
9162: PUSH
9163: LD_INT 105000
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: LIST
9170: PUSH
9171: LD_OWVAR 67
9175: ARRAY
9176: LESSEQUAL
9177: IFFALSE 9191
// AddMedal ( med1 , 1 ) else
9179: LD_STRING med1
9181: PPUSH
9182: LD_INT 1
9184: PPUSH
9185: CALL_OW 101
9189: GO 9202
// AddMedal ( med1 , - 1 ) ;
9191: LD_STRING med1
9193: PPUSH
9194: LD_INT 1
9196: NEG
9197: PPUSH
9198: CALL_OW 101
// if ( flamethrowers >= 3 ) * baseHill * ( loseCounter < [ 6 , 5 , 4 ] [ Difficulty ] ) then
9202: LD_EXP 7
9206: PUSH
9207: LD_INT 3
9209: GREATEREQUAL
9210: PUSH
9211: LD_EXP 9
9215: MUL
9216: PUSH
9217: LD_EXP 6
9221: PUSH
9222: LD_INT 6
9224: PUSH
9225: LD_INT 5
9227: PUSH
9228: LD_INT 4
9230: PUSH
9231: EMPTY
9232: LIST
9233: LIST
9234: LIST
9235: PUSH
9236: LD_OWVAR 67
9240: ARRAY
9241: LESS
9242: MUL
9243: IFFALSE 9257
// AddMedal ( med2 , 1 ) else
9245: LD_STRING med2
9247: PPUSH
9248: LD_INT 1
9250: PPUSH
9251: CALL_OW 101
9255: GO 9268
// AddMedal ( med2 , - 1 ) ;
9257: LD_STRING med2
9259: PPUSH
9260: LD_INT 1
9262: NEG
9263: PPUSH
9264: CALL_OW 101
// if gaidarKilled then
9268: LD_EXP 12
9272: IFFALSE 9286
// AddMedal ( med3 , 1 ) else
9274: LD_STRING med3
9276: PPUSH
9277: LD_INT 1
9279: PPUSH
9280: CALL_OW 101
9284: GO 9297
// AddMedal ( med3 , - 1 ) ;
9286: LD_STRING med3
9288: PPUSH
9289: LD_INT 1
9291: NEG
9292: PPUSH
9293: CALL_OW 101
// GiveMedals ( MAIN ) ;
9297: LD_STRING MAIN
9299: PPUSH
9300: CALL_OW 102
// RewardPeople ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_not , [ f_nation , 0 ] ] ] ) ) ;
9304: LD_INT 22
9306: PUSH
9307: LD_INT 2
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PUSH
9314: LD_INT 3
9316: PUSH
9317: LD_INT 23
9319: PUSH
9320: LD_INT 0
9322: PUSH
9323: EMPTY
9324: LIST
9325: LIST
9326: PUSH
9327: EMPTY
9328: LIST
9329: LIST
9330: PUSH
9331: EMPTY
9332: LIST
9333: LIST
9334: PPUSH
9335: CALL_OW 69
9339: PPUSH
9340: CALL_OW 43
// SaveCharacters ( Heike , 04_2_Heike ) ;
9344: LD_EXP 14
9348: PPUSH
9349: LD_STRING 04_2_Heike
9351: PPUSH
9352: CALL_OW 38
// if Aviradze then
9356: LD_EXP 24
9360: IFFALSE 9374
// SaveCharacters ( Aviradze , 04_2_Aviradze ) ;
9362: LD_EXP 24
9366: PPUSH
9367: LD_STRING 04_2_Aviradze
9369: PPUSH
9370: CALL_OW 38
// if Ibrahim then
9374: LD_EXP 17
9378: IFFALSE 9392
// SaveCharacters ( Ibrahim , 04_2_Ibrahim ) ;
9380: LD_EXP 17
9384: PPUSH
9385: LD_STRING 04_2_Ibrahim
9387: PPUSH
9388: CALL_OW 38
// if Kamil then
9392: LD_EXP 18
9396: IFFALSE 9410
// SaveCharacters ( Kamil , 04_2_Kamil ) ;
9398: LD_EXP 18
9402: PPUSH
9403: LD_STRING 04_2_Kamil
9405: PPUSH
9406: CALL_OW 38
// if Sophia then
9410: LD_EXP 20
9414: IFFALSE 9428
// SaveCharacters ( Sophia , 04_2_Sophia ) ;
9416: LD_EXP 20
9420: PPUSH
9421: LD_STRING 04_2_Sophia
9423: PPUSH
9424: CALL_OW 38
// if Kaia then
9428: LD_EXP 19
9432: IFFALSE 9446
// SaveCharacters ( Kaia , 04_2_Kaia ) ;
9434: LD_EXP 19
9438: PPUSH
9439: LD_STRING 04_2_Kaia
9441: PPUSH
9442: CALL_OW 38
// if Givi then
9446: LD_EXP 15
9450: IFFALSE 9464
// SaveCharacters ( Givi , 04_2_Givi ) ;
9452: LD_EXP 15
9456: PPUSH
9457: LD_STRING 04_2_Givi
9459: PPUSH
9460: CALL_OW 38
// if Mike then
9464: LD_EXP 16
9468: IFFALSE 9482
// SaveCharacters ( Mike , 04_2_Mike ) ;
9470: LD_EXP 16
9474: PPUSH
9475: LD_STRING 04_2_Mike
9477: PPUSH
9478: CALL_OW 38
// if Markov then
9482: LD_EXP 21
9486: IFFALSE 9500
// SaveCharacters ( Markov , 04_2_Markov ) ;
9488: LD_EXP 21
9492: PPUSH
9493: LD_STRING 04_2_Markov
9495: PPUSH
9496: CALL_OW 38
// if Kurt then
9500: LD_EXP 23
9504: IFFALSE 9518
// SaveCharacters ( Kurt , 04_2_Kurt ) ;
9506: LD_EXP 23
9510: PPUSH
9511: LD_STRING 04_2_Kurt
9513: PPUSH
9514: CALL_OW 38
// if heikeSecondSquad then
9518: LD_EXP 25
9522: IFFALSE 9536
// SaveCharacters ( heikeSecondSquad , 04_2_others ) ;
9524: LD_EXP 25
9528: PPUSH
9529: LD_STRING 04_2_others
9531: PPUSH
9532: CALL_OW 38
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 0 ] ] ) ;
9536: LD_ADDR_VAR 0 1
9540: PUSH
9541: LD_INT 22
9543: PUSH
9544: LD_INT 2
9546: PUSH
9547: EMPTY
9548: LIST
9549: LIST
9550: PUSH
9551: LD_INT 23
9553: PUSH
9554: LD_INT 0
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: EMPTY
9562: LIST
9563: LIST
9564: PPUSH
9565: CALL_OW 69
9569: ST_TO_ADDR
// if tmp then
9570: LD_VAR 0 1
9574: IFFALSE 9588
// SaveCharacters ( tmp , 04_2_apes ) ;
9576: LD_VAR 0 1
9580: PPUSH
9581: LD_STRING 04_2_apes
9583: PPUSH
9584: CALL_OW 38
// YouWin ;
9588: CALL_OW 103
// end ;
9592: PPOPN 1
9594: END
