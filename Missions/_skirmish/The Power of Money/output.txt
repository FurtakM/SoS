// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 66 0 0
// PrepareAnimals ( 6 , 3 , 4 , apearea ) ;
  15: LD_INT 6
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 21
  26: PPUSH
  27: CALL 10567 0 4
// PrepareAmerican ;
  31: CALL 3957 0 0
// PrepareRussian ;
  35: CALL 277 0 0
// Action ;
  39: CALL 8298 0 0
// end ;
  43: END
// every 0 0$01 do
  44: GO 46
  46: DISABLE
// begin enable ;
  47: ENABLE
// display_strings := [ #tick , tick ] ;
  48: LD_ADDR_OWVAR 47
  52: PUSH
  53: LD_STRING #tick
  55: PUSH
  56: LD_OWVAR 1
  60: PUSH
  61: EMPTY
  62: LIST
  63: LIST
  64: ST_TO_ADDR
// end ;
  65: END
// export conv_squad , escort , medal1 , medal2 , medal3 , path , convoy_start , dest_counter ; export riv , ar_attacks , ar_force , us_force , conv_counter , crates_counter ; function Init ; begin
  66: LD_INT 0
  68: PPUSH
// medal1 := true ;
  69: LD_ADDR_EXP 3
  73: PUSH
  74: LD_INT 1
  76: ST_TO_ADDR
// medal2 := true ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 1
  84: ST_TO_ADDR
// medal3 := true ;
  85: LD_ADDR_EXP 5
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// path := [ pp1 , pp2 , pp3 , pp4 , conv_end ] ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 10
 100: PUSH
 101: LD_INT 11
 103: PUSH
 104: LD_INT 12
 106: PUSH
 107: LD_INT 13
 109: PUSH
 110: LD_INT 9
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: LIST
 118: LIST
 119: ST_TO_ADDR
// conv_squad := [ ] ;
 120: LD_ADDR_EXP 1
 124: PUSH
 125: EMPTY
 126: ST_TO_ADDR
// escort := [ ] ;
 127: LD_ADDR_EXP 2
 131: PUSH
 132: EMPTY
 133: ST_TO_ADDR
// riv := [ ] ;
 134: LD_ADDR_EXP 9
 138: PUSH
 139: EMPTY
 140: ST_TO_ADDR
// ar_force := [ ] ;
 141: LD_ADDR_EXP 11
 145: PUSH
 146: EMPTY
 147: ST_TO_ADDR
// ar_attacks := false ;
 148: LD_ADDR_EXP 10
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// us_force := [ ] ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: EMPTY
 162: ST_TO_ADDR
// convoy_start := false ;
 163: LD_ADDR_EXP 7
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// conv_counter := 0 ;
 171: LD_ADDR_EXP 13
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// dest_counter := 0 ;
 179: LD_ADDR_EXP 8
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// crates_counter := 0 0$40 ;
 187: LD_ADDR_EXP 14
 191: PUSH
 192: LD_INT 1400
 194: ST_TO_ADDR
// end ;
 195: LD_VAR 0 1
 199: RET
// every 2 2$00 do
 200: GO 202
 202: DISABLE
// begin while ( tick <= [ 47 47$00 , 44 44$00 , 41 41$00 ] [ Difficulty ] ) do
 203: LD_OWVAR 1
 207: PUSH
 208: LD_INT 98700
 210: PUSH
 211: LD_INT 92400
 213: PUSH
 214: LD_INT 86100
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: PUSH
 222: LD_OWVAR 67
 226: ARRAY
 227: LESSEQUAL
 228: IFFALSE 276
// begin Wait ( crates_counter ) ;
 230: LD_EXP 14
 234: PPUSH
 235: CALL_OW 67
// crates_counter := crates_counter + 0 0$09 ;
 239: LD_ADDR_EXP 14
 243: PUSH
 244: LD_EXP 14
 248: PUSH
 249: LD_INT 315
 251: PLUS
 252: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 5
 258: PPUSH
 259: CALL_OW 12
 263: PPUSH
 264: LD_INT 22
 266: PPUSH
 267: LD_INT 1
 269: PPUSH
 270: CALL_OW 55
// end ;
 274: GO 203
// end ; end_of_file
 276: END
// export Stolypin , Popov , Saseda ; export function PrepareRussian ; var un , force , i , c , skill , team ; begin
 277: LD_INT 0
 279: PPUSH
 280: PPUSH
 281: PPUSH
 282: PPUSH
 283: PPUSH
 284: PPUSH
 285: PPUSH
// uc_side := 6 ;
 286: LD_ADDR_OWVAR 20
 290: PUSH
 291: LD_INT 6
 293: ST_TO_ADDR
// uc_nation := 3 ;
 294: LD_ADDR_OWVAR 21
 298: PUSH
 299: LD_INT 3
 301: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
 302: LD_INT 3
 304: PPUSH
 305: LD_INT 6
 307: PPUSH
 308: CALL_OW 343
// Popov := NewCharacter ( Gaydar ) ;
 312: LD_ADDR_EXP 16
 316: PUSH
 317: LD_STRING Gaydar
 319: PPUSH
 320: CALL_OW 25
 324: ST_TO_ADDR
// uc_side := 7 ;
 325: LD_ADDR_OWVAR 20
 329: PUSH
 330: LD_INT 7
 332: ST_TO_ADDR
// hc_gallery := sandal ;
 333: LD_ADDR_OWVAR 33
 337: PUSH
 338: LD_STRING sandal
 340: ST_TO_ADDR
// hc_face_number := 9 ;
 341: LD_ADDR_OWVAR 34
 345: PUSH
 346: LD_INT 9
 348: ST_TO_ADDR
// hc_skills := [ 3 , 5 , 2 , 7 ] ;
 349: LD_ADDR_OWVAR 31
 353: PUSH
 354: LD_INT 3
 356: PUSH
 357: LD_INT 5
 359: PUSH
 360: LD_INT 2
 362: PUSH
 363: LD_INT 7
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: ST_TO_ADDR
// hc_sex := sex_male ;
 372: LD_ADDR_OWVAR 27
 376: PUSH
 377: LD_INT 1
 379: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 380: LD_ADDR_OWVAR 29
 384: PUSH
 385: LD_INT 10
 387: PUSH
 388: LD_INT 11
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: ST_TO_ADDR
// hc_class := 4 ;
 395: LD_ADDR_OWVAR 28
 399: PUSH
 400: LD_INT 4
 402: ST_TO_ADDR
// hc_name := Fiodor Saseda ;
 403: LD_ADDR_OWVAR 26
 407: PUSH
 408: LD_STRING Fiodor Saseda
 410: ST_TO_ADDR
// Saseda := CreateHuman ;
 411: LD_ADDR_EXP 17
 415: PUSH
 416: CALL_OW 44
 420: ST_TO_ADDR
// uc_side := 3 ;
 421: LD_ADDR_OWVAR 20
 425: PUSH
 426: LD_INT 3
 428: ST_TO_ADDR
// hc_importance := 100 ;
 429: LD_ADDR_OWVAR 32
 433: PUSH
 434: LD_INT 100
 436: ST_TO_ADDR
// hc_class := 1 ;
 437: LD_ADDR_OWVAR 28
 441: PUSH
 442: LD_INT 1
 444: ST_TO_ADDR
// hc_sex := sex_male ;
 445: LD_ADDR_OWVAR 27
 449: PUSH
 450: LD_INT 1
 452: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
 453: LD_ADDR_OWVAR 31
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 3
 463: PUSH
 464: LD_INT 4
 466: PUSH
 467: LD_INT 2
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: ST_TO_ADDR
// hc_name := W. I. Stolypin ;
 476: LD_ADDR_OWVAR 26
 480: PUSH
 481: LD_STRING W. I. Stolypin
 483: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 484: LD_ADDR_OWVAR 29
 488: PUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: ST_TO_ADDR
// hc_gallery := ru ;
 499: LD_ADDR_OWVAR 33
 503: PUSH
 504: LD_STRING ru
 506: ST_TO_ADDR
// hc_face_number := 15 ;
 507: LD_ADDR_OWVAR 34
 511: PUSH
 512: LD_INT 15
 514: ST_TO_ADDR
// Stolypin := CreateHuman ;
 515: LD_ADDR_EXP 15
 519: PUSH
 520: CALL_OW 44
 524: ST_TO_ADDR
// hc_importance := 0 ;
 525: LD_ADDR_OWVAR 32
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// hc_gallery :=  ;
 533: LD_ADDR_OWVAR 33
 537: PUSH
 538: LD_STRING 
 540: ST_TO_ADDR
// hc_name :=  ;
 541: LD_ADDR_OWVAR 26
 545: PUSH
 546: LD_STRING 
 548: ST_TO_ADDR
// skill := [ 6 , 5 , 5 ] [ Difficulty ] ;
 549: LD_ADDR_VAR 0 6
 553: PUSH
 554: LD_INT 6
 556: PUSH
 557: LD_INT 5
 559: PUSH
 560: LD_INT 5
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: LD_OWVAR 67
 572: ARRAY
 573: ST_TO_ADDR
// c := 1 ;
 574: LD_ADDR_VAR 0 5
 578: PUSH
 579: LD_INT 1
 581: ST_TO_ADDR
// for i = 1 to 21 do
 582: LD_ADDR_VAR 0 4
 586: PUSH
 587: DOUBLE
 588: LD_INT 1
 590: DEC
 591: ST_TO_ADDR
 592: LD_INT 21
 594: PUSH
 595: FOR_TO
 596: IFFALSE 697
// begin if i = 10 then
 598: LD_VAR 0 4
 602: PUSH
 603: LD_INT 10
 605: EQUAL
 606: IFFALSE 616
// c := 2 ;
 608: LD_ADDR_VAR 0 5
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// if i = 14 then
 616: LD_VAR 0 4
 620: PUSH
 621: LD_INT 14
 623: EQUAL
 624: IFFALSE 634
// c := 3 ;
 626: LD_ADDR_VAR 0 5
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// if i = 18 then
 634: LD_VAR 0 4
 638: PUSH
 639: LD_INT 18
 641: EQUAL
 642: IFFALSE 652
// c := 4 ;
 644: LD_ADDR_VAR 0 5
 648: PUSH
 649: LD_INT 4
 651: ST_TO_ADDR
// PrepareHuman ( false , c , skill ) ;
 652: LD_INT 0
 654: PPUSH
 655: LD_VAR 0 5
 659: PPUSH
 660: LD_VAR 0 6
 664: PPUSH
 665: CALL_OW 380
// un := CreateHuman ;
 669: LD_ADDR_VAR 0 2
 673: PUSH
 674: CALL_OW 44
 678: ST_TO_ADDR
// force := force ^ un ;
 679: LD_ADDR_VAR 0 3
 683: PUSH
 684: LD_VAR 0 3
 688: PUSH
 689: LD_VAR 0 2
 693: ADD
 694: ST_TO_ADDR
// end ;
 695: GO 595
 697: POP
 698: POP
// team := CharacterSelection ( text , [ 8 , 7 , 7 ] [ Difficulty ] , [ 8 , 7 , 7 ] [ Difficulty ] , [ sel_change_class , Stolypin , sel_changeable , sel_not_hired ] ^ force , [ [ class_soldier , 3 ] , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
 699: LD_ADDR_VAR 0 7
 703: PUSH
 704: LD_STRING text
 706: PPUSH
 707: LD_INT 8
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 7
 715: PUSH
 716: EMPTY
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_OWVAR 67
 725: ARRAY
 726: PPUSH
 727: LD_INT 8
 729: PUSH
 730: LD_INT 7
 732: PUSH
 733: LD_INT 7
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_OWVAR 67
 745: ARRAY
 746: PPUSH
 747: LD_INT -5
 749: PUSH
 750: LD_EXP 15
 754: PUSH
 755: LD_INT -3
 757: PUSH
 758: LD_INT -2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PUSH
 767: LD_VAR 0 3
 771: ADD
 772: PPUSH
 773: LD_INT 1
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 2
 788: PUSH
 789: LD_INT 1
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 4
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL_OW 42
 809: ST_TO_ADDR
// team := team ^ Stolypin ;
 810: LD_ADDR_VAR 0 7
 814: PUSH
 815: LD_VAR 0 7
 819: PUSH
 820: LD_EXP 15
 824: ADD
 825: ST_TO_ADDR
// for i = 1 to team do
 826: LD_ADDR_VAR 0 4
 830: PUSH
 831: DOUBLE
 832: LD_INT 1
 834: DEC
 835: ST_TO_ADDR
 836: LD_VAR 0 7
 840: PUSH
 841: FOR_TO
 842: IFFALSE 867
// PlaceUnitArea ( team [ i ] , rus_start , false ) ;
 844: LD_VAR 0 7
 848: PUSH
 849: LD_VAR 0 4
 853: ARRAY
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: LD_INT 0
 860: PPUSH
 861: CALL_OW 49
 865: GO 841
 867: POP
 868: POP
// CenterNowOnUnits ( Stolypin ) ;
 869: LD_EXP 15
 873: PPUSH
 874: CALL_OW 87
// end ;
 878: LD_VAR 0 1
 882: RET
// export conv_ready ; export function Convoy ( type ) ; var i , veh , skill ; begin
 883: LD_INT 0
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
// Randomize ;
 889: CALL_OW 10
// uc_side := 6 ;
 893: LD_ADDR_OWVAR 20
 897: PUSH
 898: LD_INT 6
 900: ST_TO_ADDR
// uc_nation := 3 ;
 901: LD_ADDR_OWVAR 21
 905: PUSH
 906: LD_INT 3
 908: ST_TO_ADDR
// hc_name :=  ;
 909: LD_ADDR_OWVAR 26
 913: PUSH
 914: LD_STRING 
 916: ST_TO_ADDR
// hc_gallery :=  ;
 917: LD_ADDR_OWVAR 33
 921: PUSH
 922: LD_STRING 
 924: ST_TO_ADDR
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
 925: LD_ADDR_VAR 0 5
 929: PUSH
 930: LD_INT 5
 932: PUSH
 933: LD_INT 5
 935: PUSH
 936: LD_INT 4
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_OWVAR 67
 948: ARRAY
 949: ST_TO_ADDR
// conv_ready := false ;
 950: LD_ADDR_EXP 18
 954: PUSH
 955: LD_INT 0
 957: ST_TO_ADDR
// case type of 1 :
 958: LD_VAR 0 1
 962: PUSH
 963: LD_INT 1
 965: DOUBLE
 966: EQUAL
 967: IFTRUE 971
 969: GO 1241
 971: POP
// begin if Rand ( 0 , 1 ) = 1 then
 972: LD_INT 0
 974: PPUSH
 975: LD_INT 1
 977: PPUSH
 978: CALL_OW 12
 982: PUSH
 983: LD_INT 1
 985: EQUAL
 986: IFFALSE 992
// AddEscort ( ) ;
 988: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
 992: LD_INT 70
 994: PPUSH
 995: CALL_OW 67
// vc_chassis := ru_medium_wheeled ;
 999: LD_ADDR_OWVAR 37
1003: PUSH
1004: LD_INT 21
1006: ST_TO_ADDR
// vc_engine := engine_combustion ;
1007: LD_ADDR_OWVAR 39
1011: PUSH
1012: LD_INT 1
1014: ST_TO_ADDR
// vc_control := control_manual ;
1015: LD_ADDR_OWVAR 38
1019: PUSH
1020: LD_INT 1
1022: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1023: LD_ADDR_OWVAR 40
1027: PUSH
1028: LD_INT 51
1030: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1031: LD_ADDR_OWVAR 41
1035: PUSH
1036: LD_INT 50
1038: PPUSH
1039: LD_INT 99
1041: PPUSH
1042: CALL_OW 12
1046: ST_TO_ADDR
// if uc_side <> 6 then
1047: LD_OWVAR 20
1051: PUSH
1052: LD_INT 6
1054: NONEQUAL
1055: IFFALSE 1065
// uc_side := 6 ;
1057: LD_ADDR_OWVAR 20
1061: PUSH
1062: LD_INT 6
1064: ST_TO_ADDR
// veh := CreateVehicle ;
1065: LD_ADDR_VAR 0 4
1069: PUSH
1070: CALL_OW 45
1074: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1075: LD_VAR 0 4
1079: PPUSH
1080: LD_INT 3
1082: PPUSH
1083: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1087: LD_VAR 0 4
1091: PPUSH
1092: LD_INT 8
1094: PPUSH
1095: LD_INT 0
1097: PPUSH
1098: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1102: LD_INT 0
1104: PPUSH
1105: LD_INT 1
1107: PPUSH
1108: LD_INT 2
1110: PPUSH
1111: CALL_OW 12
1115: PPUSH
1116: LD_VAR 0 5
1120: PPUSH
1121: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1125: CALL_OW 44
1129: PPUSH
1130: LD_VAR 0 4
1134: PPUSH
1135: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1139: LD_VAR 0 4
1143: PPUSH
1144: LD_INT 500
1146: PPUSH
1147: LD_INT 1000
1149: PPUSH
1150: CALL_OW 12
1154: PPUSH
1155: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1159: LD_VAR 0 4
1163: PPUSH
1164: LD_INT 1
1166: PPUSH
1167: LD_INT 2
1169: PPUSH
1170: CALL_OW 12
1174: PPUSH
1175: LD_INT 2
1177: PPUSH
1178: LD_INT 10
1180: PPUSH
1181: CALL_OW 12
1185: PUSH
1186: LD_INT 10
1188: MUL
1189: PPUSH
1190: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1194: LD_ADDR_EXP 1
1198: PUSH
1199: LD_EXP 1
1203: PPUSH
1204: LD_INT 1
1206: PPUSH
1207: LD_VAR 0 4
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: PPUSH
1219: CALL_OW 2
1223: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
1224: LD_INT 35
1226: PPUSH
1227: CALL_OW 67
// conv_ready := true ;
1231: LD_ADDR_EXP 18
1235: PUSH
1236: LD_INT 1
1238: ST_TO_ADDR
// end ; 2 :
1239: GO 2861
1241: LD_INT 2
1243: DOUBLE
1244: EQUAL
1245: IFTRUE 1249
1247: GO 1549
1249: POP
// begin AddEscort ( ) ;
1250: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1254: LD_INT 70
1256: PPUSH
1257: CALL_OW 67
// for i = 1 to 2 do
1261: LD_ADDR_VAR 0 3
1265: PUSH
1266: DOUBLE
1267: LD_INT 1
1269: DEC
1270: ST_TO_ADDR
1271: LD_INT 2
1273: PUSH
1274: FOR_TO
1275: IFFALSE 1526
// begin vc_chassis := ru_medium_wheeled ;
1277: LD_ADDR_OWVAR 37
1281: PUSH
1282: LD_INT 21
1284: ST_TO_ADDR
// vc_engine := engine_combustion ;
1285: LD_ADDR_OWVAR 39
1289: PUSH
1290: LD_INT 1
1292: ST_TO_ADDR
// vc_control := control_manual ;
1293: LD_ADDR_OWVAR 38
1297: PUSH
1298: LD_INT 1
1300: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1301: LD_ADDR_OWVAR 40
1305: PUSH
1306: LD_INT 51
1308: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1309: LD_ADDR_OWVAR 41
1313: PUSH
1314: LD_INT 50
1316: PPUSH
1317: LD_INT 99
1319: PPUSH
1320: CALL_OW 12
1324: ST_TO_ADDR
// if uc_side <> 6 then
1325: LD_OWVAR 20
1329: PUSH
1330: LD_INT 6
1332: NONEQUAL
1333: IFFALSE 1343
// uc_side := 6 ;
1335: LD_ADDR_OWVAR 20
1339: PUSH
1340: LD_INT 6
1342: ST_TO_ADDR
// veh := CreateVehicle ;
1343: LD_ADDR_VAR 0 4
1347: PUSH
1348: CALL_OW 45
1352: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1353: LD_VAR 0 4
1357: PPUSH
1358: LD_INT 3
1360: PPUSH
1361: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1365: LD_VAR 0 4
1369: PPUSH
1370: LD_INT 8
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1380: LD_INT 0
1382: PPUSH
1383: LD_INT 1
1385: PPUSH
1386: LD_INT 2
1388: PPUSH
1389: CALL_OW 12
1393: PPUSH
1394: LD_VAR 0 5
1398: PPUSH
1399: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1403: CALL_OW 44
1407: PPUSH
1408: LD_VAR 0 4
1412: PPUSH
1413: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1417: LD_VAR 0 4
1421: PPUSH
1422: LD_INT 500
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 12
1432: PPUSH
1433: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1437: LD_VAR 0 4
1441: PPUSH
1442: LD_INT 1
1444: PPUSH
1445: LD_INT 2
1447: PPUSH
1448: CALL_OW 12
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 10
1458: PPUSH
1459: CALL_OW 12
1463: PUSH
1464: LD_INT 10
1466: MUL
1467: PPUSH
1468: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1472: LD_ADDR_EXP 1
1476: PUSH
1477: LD_EXP 1
1481: PPUSH
1482: LD_INT 1
1484: PPUSH
1485: LD_VAR 0 4
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: PPUSH
1497: CALL_OW 2
1501: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1502: LD_VAR 0 4
1506: PPUSH
1507: LD_INT 120
1509: PPUSH
1510: LD_INT 10
1512: PPUSH
1513: CALL_OW 111
// Wait ( 0 0$02 ) ;
1517: LD_INT 70
1519: PPUSH
1520: CALL_OW 67
// end ;
1524: GO 1274
1526: POP
1527: POP
// AddEscort ( ) ;
1528: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1532: LD_INT 70
1534: PPUSH
1535: CALL_OW 67
// conv_ready := true ;
1539: LD_ADDR_EXP 18
1543: PUSH
1544: LD_INT 1
1546: ST_TO_ADDR
// end ; 3 :
1547: GO 2861
1549: LD_INT 3
1551: DOUBLE
1552: EQUAL
1553: IFTRUE 1557
1555: GO 1976
1557: POP
// begin AddEscort ( ) ;
1558: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1562: LD_INT 70
1564: PPUSH
1565: CALL_OW 67
// for i = 1 to 2 do
1569: LD_ADDR_VAR 0 3
1573: PUSH
1574: DOUBLE
1575: LD_INT 1
1577: DEC
1578: ST_TO_ADDR
1579: LD_INT 2
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1834
// begin vc_chassis := ru_medium_wheeled ;
1585: LD_ADDR_OWVAR 37
1589: PUSH
1590: LD_INT 21
1592: ST_TO_ADDR
// vc_engine := engine_combustion ;
1593: LD_ADDR_OWVAR 39
1597: PUSH
1598: LD_INT 1
1600: ST_TO_ADDR
// vc_control := control_manual ;
1601: LD_ADDR_OWVAR 38
1605: PUSH
1606: LD_INT 1
1608: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1609: LD_ADDR_OWVAR 40
1613: PUSH
1614: LD_INT 51
1616: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1617: LD_ADDR_OWVAR 41
1621: PUSH
1622: LD_INT 50
1624: PPUSH
1625: LD_INT 99
1627: PPUSH
1628: CALL_OW 12
1632: ST_TO_ADDR
// if uc_side <> 6 then
1633: LD_OWVAR 20
1637: PUSH
1638: LD_INT 6
1640: NONEQUAL
1641: IFFALSE 1651
// uc_side := 6 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 6
1650: ST_TO_ADDR
// veh := CreateVehicle ;
1651: LD_ADDR_VAR 0 4
1655: PUSH
1656: CALL_OW 45
1660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_INT 3
1668: PPUSH
1669: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1673: LD_VAR 0 4
1677: PPUSH
1678: LD_INT 8
1680: PPUSH
1681: LD_INT 0
1683: PPUSH
1684: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1688: LD_INT 0
1690: PPUSH
1691: LD_INT 1
1693: PPUSH
1694: LD_INT 2
1696: PPUSH
1697: CALL_OW 12
1701: PPUSH
1702: LD_VAR 0 5
1706: PPUSH
1707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1711: CALL_OW 44
1715: PPUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1725: LD_VAR 0 4
1729: PPUSH
1730: LD_INT 500
1732: PPUSH
1733: LD_INT 1000
1735: PPUSH
1736: CALL_OW 12
1740: PPUSH
1741: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1745: LD_VAR 0 4
1749: PPUSH
1750: LD_INT 1
1752: PPUSH
1753: LD_INT 2
1755: PPUSH
1756: CALL_OW 12
1760: PPUSH
1761: LD_INT 2
1763: PPUSH
1764: LD_INT 10
1766: PPUSH
1767: CALL_OW 12
1771: PUSH
1772: LD_INT 10
1774: MUL
1775: PPUSH
1776: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1780: LD_ADDR_EXP 1
1784: PUSH
1785: LD_EXP 1
1789: PPUSH
1790: LD_INT 1
1792: PPUSH
1793: LD_VAR 0 4
1797: PUSH
1798: LD_INT 1
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 120
1817: PPUSH
1818: LD_INT 10
1820: PPUSH
1821: CALL_OW 111
// Wait ( 0 0$02 ) ;
1825: LD_INT 70
1827: PPUSH
1828: CALL_OW 67
// end ;
1832: GO 1582
1834: POP
1835: POP
// for i = 1 to 2 do
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: DOUBLE
1842: LD_INT 1
1844: DEC
1845: ST_TO_ADDR
1846: LD_INT 2
1848: PUSH
1849: FOR_TO
1850: IFFALSE 1957
// begin PrepareHuman ( false , 1 , skill ) ;
1852: LD_INT 0
1854: PPUSH
1855: LD_INT 1
1857: PPUSH
1858: LD_VAR 0 5
1862: PPUSH
1863: CALL_OW 380
// if uc_side <> 6 then
1867: LD_OWVAR 20
1871: PUSH
1872: LD_INT 6
1874: NONEQUAL
1875: IFFALSE 1885
// uc_side := 6 ;
1877: LD_ADDR_OWVAR 20
1881: PUSH
1882: LD_INT 6
1884: ST_TO_ADDR
// veh := CreateHuman ;
1885: LD_ADDR_VAR 0 4
1889: PUSH
1890: CALL_OW 44
1894: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1895: LD_VAR 0 4
1899: PPUSH
1900: LD_INT 8
1902: PPUSH
1903: LD_INT 0
1905: PPUSH
1906: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
1910: LD_ADDR_EXP 2
1914: PUSH
1915: LD_EXP 2
1919: PPUSH
1920: LD_INT 1
1922: PPUSH
1923: LD_VAR 0 4
1927: PPUSH
1928: CALL_OW 2
1932: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1933: LD_VAR 0 4
1937: PPUSH
1938: LD_INT 120
1940: PPUSH
1941: LD_INT 10
1943: PPUSH
1944: CALL_OW 111
// Wait ( 0 0$02 ) ;
1948: LD_INT 70
1950: PPUSH
1951: CALL_OW 67
// end ;
1955: GO 1849
1957: POP
1958: POP
// Wait ( 0 0$02 ) ;
1959: LD_INT 70
1961: PPUSH
1962: CALL_OW 67
// conv_ready := true ;
1966: LD_ADDR_EXP 18
1970: PUSH
1971: LD_INT 1
1973: ST_TO_ADDR
// end ; 4 :
1974: GO 2861
1976: LD_INT 4
1978: DOUBLE
1979: EQUAL
1980: IFTRUE 1984
1982: GO 2290
1984: POP
// begin if Rand ( 0 , 1 ) = 1 then
1985: LD_INT 0
1987: PPUSH
1988: LD_INT 1
1990: PPUSH
1991: CALL_OW 12
1995: PUSH
1996: LD_INT 1
1998: EQUAL
1999: IFFALSE 2005
// AddEscort ( ) ;
2001: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2005: LD_INT 70
2007: PPUSH
2008: CALL_OW 67
// for i = 1 to 5 do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 1
2020: DEC
2021: ST_TO_ADDR
2022: LD_INT 5
2024: PUSH
2025: FOR_TO
2026: IFFALSE 2148
// begin PrepareHuman ( false , Rand ( 2 , 4 ) , skill ) ;
2028: LD_INT 0
2030: PPUSH
2031: LD_INT 2
2033: PPUSH
2034: LD_INT 4
2036: PPUSH
2037: CALL_OW 12
2041: PPUSH
2042: LD_VAR 0 5
2046: PPUSH
2047: CALL_OW 380
// if uc_side <> 6 then
2051: LD_OWVAR 20
2055: PUSH
2056: LD_INT 6
2058: NONEQUAL
2059: IFFALSE 2069
// uc_side := 6 ;
2061: LD_ADDR_OWVAR 20
2065: PUSH
2066: LD_INT 6
2068: ST_TO_ADDR
// veh := CreateHuman ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: CALL_OW 44
2078: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2079: LD_VAR 0 4
2083: PPUSH
2084: LD_INT 8
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 49
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2094: LD_ADDR_EXP 1
2098: PUSH
2099: LD_EXP 1
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_VAR 0 4
2111: PUSH
2112: LD_INT 1
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: PPUSH
2119: CALL_OW 2
2123: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2124: LD_VAR 0 4
2128: PPUSH
2129: LD_INT 120
2131: PPUSH
2132: LD_INT 10
2134: PPUSH
2135: CALL_OW 111
// Wait ( 0 0$02 ) ;
2139: LD_INT 70
2141: PPUSH
2142: CALL_OW 67
// end ;
2146: GO 2025
2148: POP
2149: POP
// for i = 1 to 2 do
2150: LD_ADDR_VAR 0 3
2154: PUSH
2155: DOUBLE
2156: LD_INT 1
2158: DEC
2159: ST_TO_ADDR
2160: LD_INT 2
2162: PUSH
2163: FOR_TO
2164: IFFALSE 2271
// begin PrepareHuman ( false , 1 , skill ) ;
2166: LD_INT 0
2168: PPUSH
2169: LD_INT 1
2171: PPUSH
2172: LD_VAR 0 5
2176: PPUSH
2177: CALL_OW 380
// if uc_side <> 6 then
2181: LD_OWVAR 20
2185: PUSH
2186: LD_INT 6
2188: NONEQUAL
2189: IFFALSE 2199
// uc_side := 6 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 6
2198: ST_TO_ADDR
// veh := CreateHuman ;
2199: LD_ADDR_VAR 0 4
2203: PUSH
2204: CALL_OW 44
2208: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2209: LD_VAR 0 4
2213: PPUSH
2214: LD_INT 8
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
2224: LD_ADDR_EXP 2
2228: PUSH
2229: LD_EXP 2
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: LD_VAR 0 4
2241: PPUSH
2242: CALL_OW 2
2246: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2247: LD_VAR 0 4
2251: PPUSH
2252: LD_INT 120
2254: PPUSH
2255: LD_INT 10
2257: PPUSH
2258: CALL_OW 111
// Wait ( 0 0$02 ) ;
2262: LD_INT 70
2264: PPUSH
2265: CALL_OW 67
// end ;
2269: GO 2163
2271: POP
2272: POP
// Wait ( 0 0$02 ) ;
2273: LD_INT 70
2275: PPUSH
2276: CALL_OW 67
// conv_ready := true ;
2280: LD_ADDR_EXP 18
2284: PUSH
2285: LD_INT 1
2287: ST_TO_ADDR
// end ; 5 :
2288: GO 2861
2290: LD_INT 5
2292: DOUBLE
2293: EQUAL
2294: IFTRUE 2298
2296: GO 2860
2298: POP
// begin AddEscort ( ) ;
2299: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2303: LD_INT 70
2305: PPUSH
2306: CALL_OW 67
// AddEscort ( ) ;
2310: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2314: LD_INT 70
2316: PPUSH
2317: CALL_OW 67
// for i = 1 to 2 do
2321: LD_ADDR_VAR 0 3
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 2
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2586
// begin vc_chassis := ru_medium_wheeled ;
2337: LD_ADDR_OWVAR 37
2341: PUSH
2342: LD_INT 21
2344: ST_TO_ADDR
// vc_engine := engine_combustion ;
2345: LD_ADDR_OWVAR 39
2349: PUSH
2350: LD_INT 1
2352: ST_TO_ADDR
// vc_control := control_manual ;
2353: LD_ADDR_OWVAR 38
2357: PUSH
2358: LD_INT 1
2360: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_INT 51
2368: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2369: LD_ADDR_OWVAR 41
2373: PUSH
2374: LD_INT 50
2376: PPUSH
2377: LD_INT 99
2379: PPUSH
2380: CALL_OW 12
2384: ST_TO_ADDR
// if uc_side <> 6 then
2385: LD_OWVAR 20
2389: PUSH
2390: LD_INT 6
2392: NONEQUAL
2393: IFFALSE 2403
// uc_side := 6 ;
2395: LD_ADDR_OWVAR 20
2399: PUSH
2400: LD_INT 6
2402: ST_TO_ADDR
// veh := CreateVehicle ;
2403: LD_ADDR_VAR 0 4
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2413: LD_VAR 0 4
2417: PPUSH
2418: LD_INT 3
2420: PPUSH
2421: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2425: LD_VAR 0 4
2429: PPUSH
2430: LD_INT 8
2432: PPUSH
2433: LD_INT 0
2435: PPUSH
2436: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2440: LD_INT 0
2442: PPUSH
2443: LD_INT 1
2445: PPUSH
2446: LD_INT 2
2448: PPUSH
2449: CALL_OW 12
2453: PPUSH
2454: LD_VAR 0 5
2458: PPUSH
2459: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2463: CALL_OW 44
2467: PPUSH
2468: LD_VAR 0 4
2472: PPUSH
2473: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2477: LD_VAR 0 4
2481: PPUSH
2482: LD_INT 500
2484: PPUSH
2485: LD_INT 1000
2487: PPUSH
2488: CALL_OW 12
2492: PPUSH
2493: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 2
2507: PPUSH
2508: CALL_OW 12
2512: PPUSH
2513: LD_INT 2
2515: PPUSH
2516: LD_INT 10
2518: PPUSH
2519: CALL_OW 12
2523: PUSH
2524: LD_INT 10
2526: MUL
2527: PPUSH
2528: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2532: LD_ADDR_EXP 1
2536: PUSH
2537: LD_EXP 1
2541: PPUSH
2542: LD_INT 1
2544: PPUSH
2545: LD_VAR 0 4
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 2
2561: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2562: LD_VAR 0 4
2566: PPUSH
2567: LD_INT 120
2569: PPUSH
2570: LD_INT 10
2572: PPUSH
2573: CALL_OW 111
// Wait ( 0 0$02 ) ;
2577: LD_INT 70
2579: PPUSH
2580: CALL_OW 67
// end ;
2584: GO 2334
2586: POP
2587: POP
// if Rand ( 0 , 1 ) = 1 then
2588: LD_INT 0
2590: PPUSH
2591: LD_INT 1
2593: PPUSH
2594: CALL_OW 12
2598: PUSH
2599: LD_INT 1
2601: EQUAL
2602: IFFALSE 2638
// begin vc_chassis := ru_medium_tracked ;
2604: LD_ADDR_OWVAR 37
2608: PUSH
2609: LD_INT 22
2611: ST_TO_ADDR
// vc_engine := engine_combustion ;
2612: LD_ADDR_OWVAR 39
2616: PUSH
2617: LD_INT 1
2619: ST_TO_ADDR
// vc_control := control_manual ;
2620: LD_ADDR_OWVAR 38
2624: PUSH
2625: LD_INT 1
2627: ST_TO_ADDR
// vc_weapon := ru_crane ;
2628: LD_ADDR_OWVAR 40
2632: PUSH
2633: LD_INT 52
2635: ST_TO_ADDR
// end else
2636: GO 2670
// begin vc_chassis := ru_heavy_wheeled ;
2638: LD_ADDR_OWVAR 37
2642: PUSH
2643: LD_INT 23
2645: ST_TO_ADDR
// vc_engine := engine_combustion ;
2646: LD_ADDR_OWVAR 39
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// vc_control := control_manual ;
2654: LD_ADDR_OWVAR 38
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2662: LD_ADDR_OWVAR 40
2666: PUSH
2667: LD_INT 53
2669: ST_TO_ADDR
// end ; vc_fuel_battery := Rand ( 50 , 99 ) ;
2670: LD_ADDR_OWVAR 41
2674: PUSH
2675: LD_INT 50
2677: PPUSH
2678: LD_INT 99
2680: PPUSH
2681: CALL_OW 12
2685: ST_TO_ADDR
// if uc_side <> 6 then
2686: LD_OWVAR 20
2690: PUSH
2691: LD_INT 6
2693: NONEQUAL
2694: IFFALSE 2704
// uc_side := 6 ;
2696: LD_ADDR_OWVAR 20
2700: PUSH
2701: LD_INT 6
2703: ST_TO_ADDR
// veh := CreateVehicle ;
2704: LD_ADDR_VAR 0 4
2708: PUSH
2709: CALL_OW 45
2713: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2714: LD_VAR 0 4
2718: PPUSH
2719: LD_INT 3
2721: PPUSH
2722: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2726: LD_VAR 0 4
2730: PPUSH
2731: LD_INT 8
2733: PPUSH
2734: LD_INT 0
2736: PPUSH
2737: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2741: LD_INT 0
2743: PPUSH
2744: LD_INT 1
2746: PPUSH
2747: LD_INT 2
2749: PPUSH
2750: CALL_OW 12
2754: PPUSH
2755: LD_VAR 0 5
2759: PPUSH
2760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2764: CALL_OW 44
2768: PPUSH
2769: LD_VAR 0 4
2773: PPUSH
2774: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2778: LD_VAR 0 4
2782: PPUSH
2783: LD_INT 500
2785: PPUSH
2786: LD_INT 1000
2788: PPUSH
2789: CALL_OW 12
2793: PPUSH
2794: CALL_OW 234
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2798: LD_ADDR_EXP 1
2802: PUSH
2803: LD_EXP 1
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_VAR 0 4
2815: PUSH
2816: LD_INT 1
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: PPUSH
2823: CALL_OW 2
2827: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2828: LD_VAR 0 4
2832: PPUSH
2833: LD_INT 120
2835: PPUSH
2836: LD_INT 10
2838: PPUSH
2839: CALL_OW 111
// Wait ( 0 0$02 ) ;
2843: LD_INT 70
2845: PPUSH
2846: CALL_OW 67
// conv_ready := true ;
2850: LD_ADDR_EXP 18
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// end ; end ;
2858: GO 2861
2860: POP
// end ;
2861: LD_VAR 0 2
2865: RET
// export function AddEscort ( ) ; var veh , skill ; begin
2866: LD_INT 0
2868: PPUSH
2869: PPUSH
2870: PPUSH
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
2871: LD_ADDR_VAR 0 3
2875: PUSH
2876: LD_INT 5
2878: PUSH
2879: LD_INT 5
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: LIST
2889: PUSH
2890: LD_OWVAR 67
2894: ARRAY
2895: ST_TO_ADDR
// uc_side := 6 ;
2896: LD_ADDR_OWVAR 20
2900: PUSH
2901: LD_INT 6
2903: ST_TO_ADDR
// uc_nation := 3 ;
2904: LD_ADDR_OWVAR 21
2908: PUSH
2909: LD_INT 3
2911: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2912: LD_ADDR_OWVAR 37
2916: PUSH
2917: LD_INT 21
2919: ST_TO_ADDR
// vc_engine := engine_combustion ;
2920: LD_ADDR_OWVAR 39
2924: PUSH
2925: LD_INT 1
2927: ST_TO_ADDR
// vc_control := control_manual ;
2928: LD_ADDR_OWVAR 38
2932: PUSH
2933: LD_INT 1
2935: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 2 ) ] ;
2936: LD_ADDR_OWVAR 40
2940: PUSH
2941: LD_INT 44
2943: PUSH
2944: LD_INT 42
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: PUSH
2951: LD_INT 1
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 12
2961: ARRAY
2962: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2963: LD_ADDR_OWVAR 41
2967: PUSH
2968: LD_INT 50
2970: PPUSH
2971: LD_INT 99
2973: PPUSH
2974: CALL_OW 12
2978: ST_TO_ADDR
// veh := CreateVehicle ;
2979: LD_ADDR_VAR 0 2
2983: PUSH
2984: CALL_OW 45
2988: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2989: LD_VAR 0 2
2993: PPUSH
2994: LD_INT 3
2996: PPUSH
2997: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
3001: LD_VAR 0 2
3005: PPUSH
3006: LD_INT 8
3008: PPUSH
3009: LD_INT 0
3011: PPUSH
3012: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3016: LD_INT 0
3018: PPUSH
3019: LD_INT 3
3021: PPUSH
3022: LD_VAR 0 3
3026: PPUSH
3027: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3031: CALL_OW 44
3035: PPUSH
3036: LD_VAR 0 2
3040: PPUSH
3041: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
3045: LD_VAR 0 2
3049: PPUSH
3050: LD_INT 500
3052: PPUSH
3053: LD_INT 1000
3055: PPUSH
3056: CALL_OW 12
3060: PPUSH
3061: CALL_OW 234
// escort := Insert ( escort , 1 , veh ) ;
3065: LD_ADDR_EXP 2
3069: PUSH
3070: LD_EXP 2
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_VAR 0 2
3082: PPUSH
3083: CALL_OW 2
3087: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
3088: LD_VAR 0 2
3092: PPUSH
3093: LD_INT 120
3095: PPUSH
3096: LD_INT 10
3098: PPUSH
3099: CALL_OW 111
// end ;
3103: LD_VAR 0 1
3107: RET
// every 4 trigger conv_ready and FilterAllUnits ( [ f_side , 6 ] ) do var i , j ;
3108: LD_EXP 18
3112: PUSH
3113: LD_INT 22
3115: PUSH
3116: LD_INT 6
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PPUSH
3123: CALL_OW 69
3127: AND
3128: IFFALSE 3861
3130: GO 3132
3132: DISABLE
3133: LD_INT 0
3135: PPUSH
3136: PPUSH
// begin enable ;
3137: ENABLE
// if conv_squad then
3138: LD_EXP 1
3142: IFFALSE 3399
// for i = conv_squad downto 1 do
3144: LD_ADDR_VAR 0 1
3148: PUSH
3149: DOUBLE
3150: LD_EXP 1
3154: INC
3155: ST_TO_ADDR
3156: LD_INT 1
3158: PUSH
3159: FOR_DOWNTO
3160: IFFALSE 3397
// begin if IsInArea ( conv_squad [ i ] [ 1 ] , conv_end ) then
3162: LD_EXP 1
3166: PUSH
3167: LD_VAR 0 1
3171: ARRAY
3172: PUSH
3173: LD_INT 1
3175: ARRAY
3176: PPUSH
3177: LD_INT 9
3179: PPUSH
3180: CALL_OW 308
3184: IFFALSE 3247
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3186: LD_ADDR_VAR 0 2
3190: PUSH
3191: LD_INT 9
3193: PPUSH
3194: LD_INT 22
3196: PUSH
3197: LD_INT 6
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 70
3208: PUSH
3209: FOR_IN
3210: IFFALSE 3223
// RemoveUnit ( j ) ;
3212: LD_VAR 0 2
3216: PPUSH
3217: CALL_OW 64
3221: GO 3209
3223: POP
3224: POP
// conv_squad := Delete ( conv_squad , i ) ;
3225: LD_ADDR_EXP 1
3229: PUSH
3230: LD_EXP 1
3234: PPUSH
3235: LD_VAR 0 1
3239: PPUSH
3240: CALL_OW 3
3244: ST_TO_ADDR
// break ;
3245: GO 3397
// end ; if IsInArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) then
3247: LD_EXP 1
3251: PUSH
3252: LD_VAR 0 1
3256: ARRAY
3257: PUSH
3258: LD_INT 1
3260: ARRAY
3261: PPUSH
3262: LD_EXP 6
3266: PUSH
3267: LD_EXP 1
3271: PUSH
3272: LD_VAR 0 1
3276: ARRAY
3277: PUSH
3278: LD_INT 2
3280: ARRAY
3281: ARRAY
3282: PPUSH
3283: CALL_OW 308
3287: IFFALSE 3333
// conv_squad := Replace2 ( conv_squad , i , 2 , conv_squad [ i ] [ 2 ] + 1 ) else
3289: LD_ADDR_EXP 1
3293: PUSH
3294: LD_EXP 1
3298: PPUSH
3299: LD_VAR 0 1
3303: PPUSH
3304: LD_INT 2
3306: PPUSH
3307: LD_EXP 1
3311: PUSH
3312: LD_VAR 0 1
3316: ARRAY
3317: PUSH
3318: LD_INT 2
3320: ARRAY
3321: PUSH
3322: LD_INT 1
3324: PLUS
3325: PPUSH
3326: CALL 10135 0 4
3330: ST_TO_ADDR
3331: GO 3395
// if not HasTask ( conv_squad [ i ] [ 1 ] ) then
3333: LD_EXP 1
3337: PUSH
3338: LD_VAR 0 1
3342: ARRAY
3343: PUSH
3344: LD_INT 1
3346: ARRAY
3347: PPUSH
3348: CALL_OW 314
3352: NOT
3353: IFFALSE 3395
// ComMoveToArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) ;
3355: LD_EXP 1
3359: PUSH
3360: LD_VAR 0 1
3364: ARRAY
3365: PUSH
3366: LD_INT 1
3368: ARRAY
3369: PPUSH
3370: LD_EXP 6
3374: PUSH
3375: LD_EXP 1
3379: PUSH
3380: LD_VAR 0 1
3384: ARRAY
3385: PUSH
3386: LD_INT 2
3388: ARRAY
3389: ARRAY
3390: PPUSH
3391: CALL_OW 113
// end ;
3395: GO 3159
3397: POP
3398: POP
// if escort then
3399: LD_EXP 2
3403: IFFALSE 3728
// for i = escort downto 1 do
3405: LD_ADDR_VAR 0 1
3409: PUSH
3410: DOUBLE
3411: LD_EXP 2
3415: INC
3416: ST_TO_ADDR
3417: LD_INT 1
3419: PUSH
3420: FOR_DOWNTO
3421: IFFALSE 3726
// begin if IsInArea ( escort [ i ] , conv_end ) then
3423: LD_EXP 2
3427: PUSH
3428: LD_VAR 0 1
3432: ARRAY
3433: PPUSH
3434: LD_INT 9
3436: PPUSH
3437: CALL_OW 308
3441: IFFALSE 3504
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3443: LD_ADDR_VAR 0 2
3447: PUSH
3448: LD_INT 9
3450: PPUSH
3451: LD_INT 22
3453: PUSH
3454: LD_INT 6
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 70
3465: PUSH
3466: FOR_IN
3467: IFFALSE 3480
// RemoveUnit ( j ) ;
3469: LD_VAR 0 2
3473: PPUSH
3474: CALL_OW 64
3478: GO 3466
3480: POP
3481: POP
// escort := Delete ( escort , i ) ;
3482: LD_ADDR_EXP 2
3486: PUSH
3487: LD_EXP 2
3491: PPUSH
3492: LD_VAR 0 1
3496: PPUSH
3497: CALL_OW 3
3501: ST_TO_ADDR
// break ;
3502: GO 3726
// end ; if FindTarget ( escort [ i ] ) and GetDistUnits ( escort [ i ] , FindTarget ( escort [ i ] ) ) < 13 then
3504: LD_EXP 2
3508: PUSH
3509: LD_VAR 0 1
3513: ARRAY
3514: PPUSH
3515: CALL 10443 0 1
3519: PUSH
3520: LD_EXP 2
3524: PUSH
3525: LD_VAR 0 1
3529: ARRAY
3530: PPUSH
3531: LD_EXP 2
3535: PUSH
3536: LD_VAR 0 1
3540: ARRAY
3541: PPUSH
3542: CALL 10443 0 1
3546: PPUSH
3547: CALL_OW 296
3551: PUSH
3552: LD_INT 13
3554: LESS
3555: AND
3556: IFFALSE 3591
// ComAttackUnit ( escort [ i ] , FindTarget ( escort [ i ] ) ) else
3558: LD_EXP 2
3562: PUSH
3563: LD_VAR 0 1
3567: ARRAY
3568: PPUSH
3569: LD_EXP 2
3573: PUSH
3574: LD_VAR 0 1
3578: ARRAY
3579: PPUSH
3580: CALL 10443 0 1
3584: PPUSH
3585: CALL_OW 115
3589: GO 3724
// if conv_squad and GetDistUnitXY ( escort [ i ] , 64 , 117 ) > 35 and not HasTask ( escort [ i ] ) then
3591: LD_EXP 1
3595: PUSH
3596: LD_EXP 2
3600: PUSH
3601: LD_VAR 0 1
3605: ARRAY
3606: PPUSH
3607: LD_INT 64
3609: PPUSH
3610: LD_INT 117
3612: PPUSH
3613: CALL_OW 297
3617: PUSH
3618: LD_INT 35
3620: GREATER
3621: AND
3622: PUSH
3623: LD_EXP 2
3627: PUSH
3628: LD_VAR 0 1
3632: ARRAY
3633: PPUSH
3634: CALL_OW 314
3638: NOT
3639: AND
3640: IFFALSE 3706
// begin if GetDistUnits ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) > 6 then
3642: LD_EXP 2
3646: PUSH
3647: LD_VAR 0 1
3651: ARRAY
3652: PPUSH
3653: LD_EXP 1
3657: PUSH
3658: LD_INT 1
3660: ARRAY
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: PPUSH
3666: CALL_OW 296
3670: PUSH
3671: LD_INT 6
3673: GREATER
3674: IFFALSE 3704
// ComMoveUnit ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) end else
3676: LD_EXP 2
3680: PUSH
3681: LD_VAR 0 1
3685: ARRAY
3686: PPUSH
3687: LD_EXP 1
3691: PUSH
3692: LD_INT 1
3694: ARRAY
3695: PUSH
3696: LD_INT 1
3698: ARRAY
3699: PPUSH
3700: CALL_OW 112
3704: GO 3724
// ComMoveToArea ( escort [ i ] , conv_end ) ;
3706: LD_EXP 2
3710: PUSH
3711: LD_VAR 0 1
3715: ARRAY
3716: PPUSH
3717: LD_INT 9
3719: PPUSH
3720: CALL_OW 113
// end ;
3724: GO 3420
3726: POP
3727: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) then
3728: LD_INT 22
3730: PUSH
3731: LD_INT 6
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PUSH
3738: LD_INT 21
3740: PUSH
3741: LD_INT 1
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 69
3756: IFFALSE 3861
// for j in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) do
3758: LD_ADDR_VAR 0 2
3762: PUSH
3763: LD_INT 22
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 21
3775: PUSH
3776: LD_INT 1
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PPUSH
3787: CALL_OW 69
3791: PUSH
3792: FOR_IN
3793: IFFALSE 3859
// begin if not HasTask ( j ) and not IsInArea ( j , conv_end ) then
3795: LD_VAR 0 2
3799: PPUSH
3800: CALL_OW 314
3804: NOT
3805: PUSH
3806: LD_VAR 0 2
3810: PPUSH
3811: LD_INT 9
3813: PPUSH
3814: CALL_OW 308
3818: NOT
3819: AND
3820: IFFALSE 3834
// ComMoveToArea ( j , conv_end ) ;
3822: LD_VAR 0 2
3826: PPUSH
3827: LD_INT 9
3829: PPUSH
3830: CALL_OW 113
// if IsInArea ( j , conv_end ) then
3834: LD_VAR 0 2
3838: PPUSH
3839: LD_INT 9
3841: PPUSH
3842: CALL_OW 308
3846: IFFALSE 3857
// RemoveUnit ( j ) ;
3848: LD_VAR 0 2
3852: PPUSH
3853: CALL_OW 64
// end ;
3857: GO 3792
3859: POP
3860: POP
// end ;
3861: PPOPN 2
3863: END
// every 0 0$01 trigger UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do var i ;
3864: LD_EXP 2
3868: PUSH
3869: LD_EXP 1
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: LD_INT 22
3880: PUSH
3881: LD_INT 3
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PPUSH
3888: CALL_OW 72
3892: IFFALSE 3954
3894: GO 3896
3896: DISABLE
3897: LD_INT 0
3899: PPUSH
// begin enable ;
3900: ENABLE
// for i in UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do
3901: LD_ADDR_VAR 0 1
3905: PUSH
3906: LD_EXP 2
3910: PUSH
3911: LD_EXP 1
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PPUSH
3920: LD_INT 22
3922: PUSH
3923: LD_INT 3
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PPUSH
3930: CALL_OW 72
3934: PUSH
3935: FOR_IN
3936: IFFALSE 3952
// SetSide ( i , 6 ) ;
3938: LD_VAR 0 1
3942: PPUSH
3943: LD_INT 6
3945: PPUSH
3946: CALL_OW 235
3950: GO 3935
3952: POP
3953: POP
// end ; end_of_file
3954: PPOPN 1
3956: END
// export Collins ; export us_alert , us_retreat , us_patrol , us_count ; export function PrepareAmerican ; var i , un , skill , towers ; begin
3957: LD_INT 0
3959: PPUSH
3960: PPUSH
3961: PPUSH
3962: PPUSH
3963: PPUSH
// uc_side := 1 ;
3964: LD_ADDR_OWVAR 20
3968: PUSH
3969: LD_INT 1
3971: ST_TO_ADDR
// uc_nation := 1 ;
3972: LD_ADDR_OWVAR 21
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// us_alert := false ;
3980: LD_ADDR_EXP 20
3984: PUSH
3985: LD_INT 0
3987: ST_TO_ADDR
// us_retreat := false ;
3988: LD_ADDR_EXP 21
3992: PUSH
3993: LD_INT 0
3995: ST_TO_ADDR
// us_patrol := false ;
3996: LD_ADDR_EXP 22
4000: PUSH
4001: LD_INT 0
4003: ST_TO_ADDR
// us_count := 0 ;
4004: LD_ADDR_EXP 23
4008: PUSH
4009: LD_INT 0
4011: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4012: LD_ADDR_VAR 0 4
4016: PUSH
4017: LD_INT 5
4019: PUSH
4020: LD_INT 6
4022: PUSH
4023: LD_INT 7
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: LIST
4030: PUSH
4031: LD_OWVAR 67
4035: ARRAY
4036: ST_TO_ADDR
// hc_class := 1 ;
4037: LD_ADDR_OWVAR 28
4041: PUSH
4042: LD_INT 1
4044: ST_TO_ADDR
// hc_sex := sex_male ;
4045: LD_ADDR_OWVAR 27
4049: PUSH
4050: LD_INT 1
4052: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
4053: LD_ADDR_OWVAR 31
4057: PUSH
4058: LD_INT 6
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 4
4066: PUSH
4067: LD_INT 2
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: ST_TO_ADDR
// hc_name := Jack Collins ;
4076: LD_ADDR_OWVAR 26
4080: PUSH
4081: LD_STRING Jack Collins
4083: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
4084: LD_ADDR_OWVAR 29
4088: PUSH
4089: LD_INT 11
4091: PUSH
4092: LD_INT 11
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// hc_gallery :=  ;
4099: LD_ADDR_OWVAR 33
4103: PUSH
4104: LD_STRING 
4106: ST_TO_ADDR
// Collins := CreateHuman ;
4107: LD_ADDR_EXP 19
4111: PUSH
4112: CALL_OW 44
4116: ST_TO_ADDR
// PlaceHumanInUnit ( Collins , us_depot ) ;
4117: LD_EXP 19
4121: PPUSH
4122: LD_INT 50
4124: PPUSH
4125: CALL_OW 52
// hc_name :=  ;
4129: LD_ADDR_OWVAR 26
4133: PUSH
4134: LD_STRING 
4136: ST_TO_ADDR
// if Difficulty > 1 then
4137: LD_OWVAR 67
4141: PUSH
4142: LD_INT 1
4144: GREATER
4145: IFFALSE 4199
// begin bc_type := b_bunker ;
4147: LD_ADDR_OWVAR 42
4151: PUSH
4152: LD_INT 32
4154: ST_TO_ADDR
// bc_level := 5 ;
4155: LD_ADDR_OWVAR 43
4159: PUSH
4160: LD_INT 5
4162: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 40 , 33 , 2 ) ;
4163: LD_INT 40
4165: PPUSH
4166: LD_INT 33
4168: PPUSH
4169: LD_INT 2
4171: PPUSH
4172: CALL_OW 47
// if Difficulty > 2 then
4176: LD_OWVAR 67
4180: PUSH
4181: LD_INT 2
4183: GREATER
4184: IFFALSE 4199
// CreateAndPlaceBuildingXYD ( 41 , 42 , 0 ) ;
4186: LD_INT 41
4188: PPUSH
4189: LD_INT 42
4191: PPUSH
4192: LD_INT 0
4194: PPUSH
4195: CALL_OW 47
// end ; PrepareHuman ( false , 2 , skill ) ;
4199: LD_INT 0
4201: PPUSH
4202: LD_INT 2
4204: PPUSH
4205: LD_VAR 0 4
4209: PPUSH
4210: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
4214: CALL_OW 44
4218: PPUSH
4219: LD_INT 50
4221: PPUSH
4222: CALL_OW 52
// PrepareHuman ( false , 3 , skill ) ;
4226: LD_INT 0
4228: PPUSH
4229: LD_INT 3
4231: PPUSH
4232: LD_VAR 0 4
4236: PPUSH
4237: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4241: CALL_OW 44
4245: PPUSH
4246: LD_INT 56
4248: PPUSH
4249: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4253: CALL_OW 44
4257: PPUSH
4258: LD_INT 56
4260: PPUSH
4261: CALL_OW 52
// PrepareHuman ( false , 4 , skill ) ;
4265: LD_INT 0
4267: PPUSH
4268: LD_INT 4
4270: PPUSH
4271: LD_VAR 0 4
4275: PPUSH
4276: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
4280: CALL_OW 44
4284: PPUSH
4285: LD_INT 63
4287: PPUSH
4288: CALL_OW 52
// PrepareHuman ( false , 1 , skill ) ;
4292: LD_INT 0
4294: PPUSH
4295: LD_INT 1
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 380
// un := CreateHuman ;
4307: LD_ADDR_VAR 0 3
4311: PUSH
4312: CALL_OW 44
4316: ST_TO_ADDR
// SetDir ( un , 4 ) ;
4317: LD_VAR 0 3
4321: PPUSH
4322: LD_INT 4
4324: PPUSH
4325: CALL_OW 233
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
4329: LD_VAR 0 3
4333: PPUSH
4334: LD_INT 22
4336: PUSH
4337: LD_INT 1
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PUSH
4344: LD_INT 30
4346: PUSH
4347: LD_INT 31
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PPUSH
4358: CALL_OW 69
4362: PUSH
4363: LD_INT 1
4365: ARRAY
4366: PPUSH
4367: CALL_OW 52
// towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) ;
4371: LD_ADDR_VAR 0 5
4375: PUSH
4376: LD_INT 22
4378: PUSH
4379: LD_INT 1
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 30
4388: PUSH
4389: LD_INT 32
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PPUSH
4400: CALL_OW 69
4404: ST_TO_ADDR
// for i in towers do
4405: LD_ADDR_VAR 0 2
4409: PUSH
4410: LD_VAR 0 5
4414: PUSH
4415: FOR_IN
4416: IFFALSE 4484
// begin PrepareHuman ( false , 1 , skill ) ;
4418: LD_INT 0
4420: PPUSH
4421: LD_INT 1
4423: PPUSH
4424: LD_VAR 0 4
4428: PPUSH
4429: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4433: CALL_OW 44
4437: PPUSH
4438: LD_VAR 0 2
4442: PPUSH
4443: CALL_OW 52
// PlaceWeaponTurret ( i , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
4447: LD_VAR 0 2
4451: PPUSH
4452: LD_INT 4
4454: PUSH
4455: LD_INT 3
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 3
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: CALL_OW 431
// end ;
4482: GO 4415
4484: POP
4485: POP
// PrepareHuman ( false , 1 , skill ) ;
4486: LD_INT 0
4488: PPUSH
4489: LD_INT 1
4491: PPUSH
4492: LD_VAR 0 4
4496: PPUSH
4497: CALL_OW 380
// us_patrol := CreateHuman ;
4501: LD_ADDR_EXP 22
4505: PUSH
4506: CALL_OW 44
4510: ST_TO_ADDR
// PlaceUnitXY ( us_patrol , 12 , 5 , false ) ;
4511: LD_EXP 22
4515: PPUSH
4516: LD_INT 12
4518: PPUSH
4519: LD_INT 5
4521: PPUSH
4522: LD_INT 0
4524: PPUSH
4525: CALL_OW 48
// end ;
4529: LD_VAR 0 1
4533: RET
// every 0 0$01 trigger us_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
4534: LD_EXP 23
4538: PUSH
4539: LD_INT 3
4541: PUSH
4542: LD_INT 4
4544: PUSH
4545: LD_INT 5
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_OWVAR 67
4557: ARRAY
4558: GREATEREQUAL
4559: IFFALSE 4584
4561: GO 4563
4563: DISABLE
// begin Say ( Collins , DPM_C2 ) ;
4564: LD_EXP 19
4568: PPUSH
4569: LD_STRING DPM_C2
4571: PPUSH
4572: CALL_OW 88
// us_retreat := true ;
4576: LD_ADDR_EXP 21
4580: PUSH
4581: LD_INT 1
4583: ST_TO_ADDR
// end ;
4584: END
// every 10 10$00 trigger not us_alert do var R ;
4585: LD_EXP 20
4589: NOT
4590: IFFALSE 4664
4592: GO 4594
4594: DISABLE
4595: LD_INT 0
4597: PPUSH
// begin uc_side := 1 ;
4598: LD_ADDR_OWVAR 20
4602: PUSH
4603: LD_INT 1
4605: ST_TO_ADDR
// uc_nation := 1 ;
4606: LD_ADDR_OWVAR 21
4610: PUSH
4611: LD_INT 1
4613: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
4614: LD_INT 0
4616: PPUSH
4617: LD_INT 1
4619: PPUSH
4620: LD_INT 0
4622: PPUSH
4623: CALL_OW 380
// R := CreateHuman ;
4627: LD_ADDR_VAR 0 1
4631: PUSH
4632: CALL_OW 44
4636: ST_TO_ADDR
// SayRadio ( R , DPM_R1 ) ;
4637: LD_VAR 0 1
4641: PPUSH
4642: LD_STRING DPM_R1
4644: PPUSH
4645: CALL_OW 94
// Wait ( 0 0$03 ) ;
4649: LD_INT 105
4651: PPUSH
4652: CALL_OW 67
// us_retreat := true ;
4656: LD_ADDR_EXP 21
4660: PUSH
4661: LD_INT 1
4663: ST_TO_ADDR
// end ;
4664: PPOPN 1
4666: END
// every 0 0$01 trigger us_alert do var i ;
4667: LD_EXP 20
4671: IFFALSE 4931
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin Say ( Collins , DPM_C1 ) ;
4679: LD_EXP 19
4683: PPUSH
4684: LD_STRING DPM_C1
4686: PPUSH
4687: CALL_OW 88
// if UnitsInside ( us_fac ) then
4691: LD_INT 56
4693: PPUSH
4694: CALL_OW 313
4698: IFFALSE 4753
// for i in UnitsInside ( us_fac ) do
4700: LD_ADDR_VAR 0 1
4704: PUSH
4705: LD_INT 56
4707: PPUSH
4708: CALL_OW 313
4712: PUSH
4713: FOR_IN
4714: IFFALSE 4751
// begin ComExitBuilding ( i ) ;
4716: LD_VAR 0 1
4720: PPUSH
4721: CALL_OW 122
// AddComEnterUnit ( i , us_arm ) ;
4725: LD_VAR 0 1
4729: PPUSH
4730: LD_INT 69
4732: PPUSH
4733: CALL_OW 180
// AddComChangeProfession ( i , 1 ) ;
4737: LD_VAR 0 1
4741: PPUSH
4742: LD_INT 1
4744: PPUSH
4745: CALL_OW 183
// end ;
4749: GO 4713
4751: POP
4752: POP
// ComExitBuilding ( Collins ) ;
4753: LD_EXP 19
4757: PPUSH
4758: CALL_OW 122
// AddComEnterUnit ( Collins , us_arm ) ;
4762: LD_EXP 19
4766: PPUSH
4767: LD_INT 69
4769: PPUSH
4770: CALL_OW 180
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] ) ;
4774: LD_INT 22
4776: PUSH
4777: LD_INT 1
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PUSH
4784: LD_INT 25
4786: PUSH
4787: LD_INT 2
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: PUSH
4803: LD_INT 1
4805: ARRAY
4806: PPUSH
4807: CALL_OW 122
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , 67 , 52 ) ;
4811: LD_INT 22
4813: PUSH
4814: LD_INT 1
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: PUSH
4821: LD_INT 25
4823: PUSH
4824: LD_INT 2
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PPUSH
4835: CALL_OW 69
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: LD_INT 67
4846: PPUSH
4847: LD_INT 52
4849: PPUSH
4850: CALL_OW 171
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] ) ;
4854: LD_INT 22
4856: PUSH
4857: LD_INT 1
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: LD_INT 25
4866: PUSH
4867: LD_INT 4
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PPUSH
4878: CALL_OW 69
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: CALL_OW 122
// AddComEnterUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] , us_arm ) ;
4891: LD_INT 22
4893: PUSH
4894: LD_INT 1
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 25
4903: PUSH
4904: LD_INT 4
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 69
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 69
4926: PPUSH
4927: CALL_OW 180
// end ;
4931: PPOPN 1
4933: END
// every 3 3$00 trigger not us_alert and GetSide ( us_fac ) = 1 do
4934: LD_EXP 20
4938: NOT
4939: PUSH
4940: LD_INT 56
4942: PPUSH
4943: CALL_OW 255
4947: PUSH
4948: LD_INT 1
4950: EQUAL
4951: AND
4952: IFFALSE 4995
4954: GO 4956
4956: DISABLE
// begin AddComConstruct ( us_fac , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun ) ;
4957: LD_INT 56
4959: PPUSH
4960: LD_INT 2
4962: PPUSH
4963: LD_INT 1
4965: PPUSH
4966: LD_INT 1
4968: PPUSH
4969: LD_INT 4
4971: PPUSH
4972: CALL_OW 185
// AddComConstruct ( us_fac , us_medium_tracked , engine_solar , control_manual , us_double_gun ) ;
4976: LD_INT 56
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: LD_INT 2
4984: PPUSH
4985: LD_INT 1
4987: PPUSH
4988: LD_INT 5
4990: PPUSH
4991: CALL_OW 185
// end ;
4995: END
// every 0 0$01 trigger us_patrol do
4996: LD_EXP 22
5000: IFFALSE 5048
5002: GO 5004
5004: DISABLE
// SetPatrol ( us_patrol , [ 12 , 5 , 56 , 4 , 94 , 34 , 92 , 108 ] ) ;
5005: LD_EXP 22
5009: PPUSH
5010: LD_INT 12
5012: PUSH
5013: LD_INT 5
5015: PUSH
5016: LD_INT 56
5018: PUSH
5019: LD_INT 4
5021: PUSH
5022: LD_INT 94
5024: PUSH
5025: LD_INT 34
5027: PUSH
5028: LD_INT 92
5030: PUSH
5031: LD_INT 108
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL 5049 0 2
5048: END
// export function SetPatrol ( un , points ) ; var s , i , turn ; begin
5049: LD_INT 0
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
// s = 1 ;
5055: LD_ADDR_VAR 0 4
5059: PUSH
5060: LD_INT 1
5062: ST_TO_ADDR
// turn := true ;
5063: LD_ADDR_VAR 0 6
5067: PUSH
5068: LD_INT 1
5070: ST_TO_ADDR
// while ( un and not us_alert ) do
5071: LD_VAR 0 1
5075: PUSH
5076: LD_EXP 20
5080: NOT
5081: AND
5082: IFFALSE 5261
// begin wait ( 35 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// if not HasTask ( un ) then
5091: LD_VAR 0 1
5095: PPUSH
5096: CALL_OW 314
5100: NOT
5101: IFFALSE 5220
// begin ComMoveXY ( un , points [ s ] , points [ s + 1 ] ) ;
5103: LD_VAR 0 1
5107: PPUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_VAR 0 4
5117: ARRAY
5118: PPUSH
5119: LD_VAR 0 2
5123: PUSH
5124: LD_VAR 0 4
5128: PUSH
5129: LD_INT 1
5131: PLUS
5132: ARRAY
5133: PPUSH
5134: CALL_OW 111
// if s + 2 > points then
5138: LD_VAR 0 4
5142: PUSH
5143: LD_INT 2
5145: PLUS
5146: PUSH
5147: LD_VAR 0 2
5151: GREATER
5152: IFFALSE 5162
// turn := false ;
5154: LD_ADDR_VAR 0 6
5158: PUSH
5159: LD_INT 0
5161: ST_TO_ADDR
// if s - 2 < 1 then
5162: LD_VAR 0 4
5166: PUSH
5167: LD_INT 2
5169: MINUS
5170: PUSH
5171: LD_INT 1
5173: LESS
5174: IFFALSE 5184
// turn := true ;
5176: LD_ADDR_VAR 0 6
5180: PUSH
5181: LD_INT 1
5183: ST_TO_ADDR
// if turn then
5184: LD_VAR 0 6
5188: IFFALSE 5206
// s := s + 2 else
5190: LD_ADDR_VAR 0 4
5194: PUSH
5195: LD_VAR 0 4
5199: PUSH
5200: LD_INT 2
5202: PLUS
5203: ST_TO_ADDR
5204: GO 5220
// s := s - 2 ;
5206: LD_ADDR_VAR 0 4
5210: PUSH
5211: LD_VAR 0 4
5215: PUSH
5216: LD_INT 2
5218: MINUS
5219: ST_TO_ADDR
// end ; if GetLives ( un ) < 1000 or See ( 3 , un ) then
5220: LD_VAR 0 1
5224: PPUSH
5225: CALL_OW 256
5229: PUSH
5230: LD_INT 1000
5232: LESS
5233: PUSH
5234: LD_INT 3
5236: PPUSH
5237: LD_VAR 0 1
5241: PPUSH
5242: CALL_OW 292
5246: OR
5247: IFFALSE 5259
// begin us_alert := true ;
5249: LD_ADDR_EXP 20
5253: PUSH
5254: LD_INT 1
5256: ST_TO_ADDR
// break ;
5257: GO 5261
// end ; end ;
5259: GO 5071
// ComEnterUnit ( un , us_arm ) ;
5261: LD_VAR 0 1
5265: PPUSH
5266: LD_INT 69
5268: PPUSH
5269: CALL_OW 120
// end ;
5273: LD_VAR 0 3
5277: RET
// every 0 0$01 trigger us_retreat do var i , point ;
5278: LD_EXP 21
5282: IFFALSE 5457
5284: GO 5286
5286: DISABLE
5287: LD_INT 0
5289: PPUSH
5290: PPUSH
// begin point := false ;
5291: LD_ADDR_VAR 0 2
5295: PUSH
5296: LD_INT 0
5298: ST_TO_ADDR
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5299: LD_INT 5
5301: PPUSH
5302: LD_INT 22
5304: PUSH
5305: LD_INT 3
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 70
5316: PUSH
5317: LD_INT 0
5319: EQUAL
5320: IFFALSE 5332
// point := us_ret1 else
5322: LD_ADDR_VAR 0 2
5326: PUSH
5327: LD_INT 3
5329: ST_TO_ADDR
5330: GO 5373
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5332: LD_INT 5
5334: PPUSH
5335: LD_INT 22
5337: PUSH
5338: LD_INT 3
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PPUSH
5345: CALL_OW 70
5349: PUSH
5350: LD_INT 0
5352: EQUAL
5353: IFFALSE 5365
// point := us_ret2 else
5355: LD_ADDR_VAR 0 2
5359: PUSH
5360: LD_INT 2
5362: ST_TO_ADDR
5363: GO 5373
// point := us_ret3 ;
5365: LD_ADDR_VAR 0 2
5369: PUSH
5370: LD_INT 4
5372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
5373: LD_ADDR_VAR 0 1
5377: PUSH
5378: LD_INT 22
5380: PUSH
5381: LD_INT 1
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 21
5390: PUSH
5391: LD_INT 1
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: PPUSH
5402: CALL_OW 69
5406: PUSH
5407: FOR_IN
5408: IFFALSE 5455
// begin if IsInUnit ( i ) then
5410: LD_VAR 0 1
5414: PPUSH
5415: CALL_OW 310
5419: IFFALSE 5439
// begin ComExitBuilding ( i ) ;
5421: LD_VAR 0 1
5425: PPUSH
5426: CALL_OW 122
// ComExitVehicle ( i ) ;
5430: LD_VAR 0 1
5434: PPUSH
5435: CALL_OW 121
// end ; AddComMoveToArea ( i , point ) ;
5439: LD_VAR 0 1
5443: PPUSH
5444: LD_VAR 0 2
5448: PPUSH
5449: CALL_OW 173
// end ;
5453: GO 5407
5455: POP
5456: POP
// end ;
5457: PPOPN 2
5459: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) do
5460: LD_EXP 21
5464: PUSH
5465: LD_INT 3
5467: PPUSH
5468: LD_INT 22
5470: PUSH
5471: LD_INT 1
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PPUSH
5478: CALL_OW 70
5482: AND
5483: IFFALSE 5529
5485: GO 5487
5487: DISABLE
// begin enable ;
5488: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) [ 1 ] ) ;
5489: LD_INT 3
5491: PPUSH
5492: LD_INT 22
5494: PUSH
5495: LD_INT 1
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 70
5506: PUSH
5507: LD_INT 1
5509: ARRAY
5510: PPUSH
5511: CALL_OW 64
// if medal1 then
5515: LD_EXP 3
5519: IFFALSE 5529
// medal1 := false ;
5521: LD_ADDR_EXP 3
5525: PUSH
5526: LD_INT 0
5528: ST_TO_ADDR
// end ;
5529: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) do
5530: LD_EXP 21
5534: PUSH
5535: LD_INT 2
5537: PPUSH
5538: LD_INT 22
5540: PUSH
5541: LD_INT 1
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PPUSH
5548: CALL_OW 70
5552: AND
5553: IFFALSE 5599
5555: GO 5557
5557: DISABLE
// begin enable ;
5558: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) [ 1 ] ) ;
5559: LD_INT 2
5561: PPUSH
5562: LD_INT 22
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL_OW 70
5576: PUSH
5577: LD_INT 1
5579: ARRAY
5580: PPUSH
5581: CALL_OW 64
// if medal1 then
5585: LD_EXP 3
5589: IFFALSE 5599
// medal1 := false ;
5591: LD_ADDR_EXP 3
5595: PUSH
5596: LD_INT 0
5598: ST_TO_ADDR
// end ;
5599: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) do
5600: LD_EXP 21
5604: PUSH
5605: LD_INT 4
5607: PPUSH
5608: LD_INT 22
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PPUSH
5618: CALL_OW 70
5622: AND
5623: IFFALSE 5669
5625: GO 5627
5627: DISABLE
// begin enable ;
5628: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) [ 1 ] ) ;
5629: LD_INT 4
5631: PPUSH
5632: LD_INT 22
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PPUSH
5642: CALL_OW 70
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PPUSH
5651: CALL_OW 64
// if medal1 then
5655: LD_EXP 3
5659: IFFALSE 5669
// medal1 := false ;
5661: LD_ADDR_EXP 3
5665: PUSH
5666: LD_INT 0
5668: ST_TO_ADDR
// end ;
5669: END
// every 0 0$03 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
5670: LD_INT 22
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PPUSH
5680: CALL_OW 69
5684: PUSH
5685: LD_INT 0
5687: EQUAL
5688: IFFALSE 5701
5690: GO 5692
5692: DISABLE
// us_retreat := false ;
5693: LD_ADDR_EXP 21
5697: PUSH
5698: LD_INT 0
5700: ST_TO_ADDR
5701: END
// export function CounterAttack ; var i , j , un , skill ; begin
5702: LD_INT 0
5704: PPUSH
5705: PPUSH
5706: PPUSH
5707: PPUSH
5708: PPUSH
// uc_side := 1 ;
5709: LD_ADDR_OWVAR 20
5713: PUSH
5714: LD_INT 1
5716: ST_TO_ADDR
// uc_nation := 1 ;
5717: LD_ADDR_OWVAR 21
5721: PUSH
5722: LD_INT 1
5724: ST_TO_ADDR
// skill := [ 4 , 5 , 5 ] [ Difficulty ] ;
5725: LD_ADDR_VAR 0 5
5729: PUSH
5730: LD_INT 4
5732: PUSH
5733: LD_INT 5
5735: PUSH
5736: LD_INT 5
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5750: LD_ADDR_VAR 0 2
5754: PUSH
5755: DOUBLE
5756: LD_INT 1
5758: DEC
5759: ST_TO_ADDR
5760: LD_INT 4
5762: PUSH
5763: LD_INT 5
5765: PUSH
5766: LD_INT 6
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PUSH
5774: LD_OWVAR 67
5778: ARRAY
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5981
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
5783: LD_ADDR_OWVAR 37
5787: PUSH
5788: LD_INT 2
5790: PUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 4
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: PUSH
5802: LD_INT 1
5804: PPUSH
5805: LD_INT 3
5807: PPUSH
5808: CALL_OW 12
5812: ARRAY
5813: ST_TO_ADDR
// vc_engine := engine_combustion ;
5814: LD_ADDR_OWVAR 39
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// vc_control := control_manual ;
5822: LD_ADDR_OWVAR 38
5826: PUSH
5827: LD_INT 1
5829: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_light_gun ] [ Rand ( 1 , 3 ) ] ;
5830: LD_ADDR_OWVAR 40
5834: PUSH
5835: LD_INT 4
5837: PUSH
5838: LD_INT 5
5840: PUSH
5841: LD_INT 3
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 1
5851: PPUSH
5852: LD_INT 3
5854: PPUSH
5855: CALL_OW 12
5859: ARRAY
5860: ST_TO_ADDR
// vc_fuel_battery := Rand ( 88 , 99 ) ;
5861: LD_ADDR_OWVAR 41
5865: PUSH
5866: LD_INT 88
5868: PPUSH
5869: LD_INT 99
5871: PPUSH
5872: CALL_OW 12
5876: ST_TO_ADDR
// un := CreateVehicle ;
5877: LD_ADDR_VAR 0 4
5881: PUSH
5882: CALL_OW 45
5886: ST_TO_ADDR
// PlaceUnitXY ( un , 64 , 117 , false ) ;
5887: LD_VAR 0 4
5891: PPUSH
5892: LD_INT 64
5894: PPUSH
5895: LD_INT 117
5897: PPUSH
5898: LD_INT 0
5900: PPUSH
5901: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
5905: LD_INT 0
5907: PPUSH
5908: LD_INT 3
5910: PPUSH
5911: LD_VAR 0 5
5915: PPUSH
5916: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5920: CALL_OW 44
5924: PPUSH
5925: LD_VAR 0 4
5929: PPUSH
5930: CALL_OW 52
// us_force := Insert ( us_force , 1 , un ) ;
5934: LD_ADDR_EXP 12
5938: PUSH
5939: LD_EXP 12
5943: PPUSH
5944: LD_INT 1
5946: PPUSH
5947: LD_VAR 0 4
5951: PPUSH
5952: CALL_OW 2
5956: ST_TO_ADDR
// ComMoveXY ( un , 60 , 109 ) ;
5957: LD_VAR 0 4
5961: PPUSH
5962: LD_INT 60
5964: PPUSH
5965: LD_INT 109
5967: PPUSH
5968: CALL_OW 111
// Wait ( 0 0$02 ) ;
5972: LD_INT 70
5974: PPUSH
5975: CALL_OW 67
// end ;
5979: GO 5780
5981: POP
5982: POP
// RemoveSeeing ( 62 , 113 , 3 ) ;
5983: LD_INT 62
5985: PPUSH
5986: LD_INT 113
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: CALL_OW 331
// while ( FilterAllUnits ( [ f_side , 1 ] ) ) do
5996: LD_INT 22
5998: PUSH
5999: LD_INT 1
6001: PUSH
6002: EMPTY
6003: LIST
6004: LIST
6005: PPUSH
6006: CALL_OW 69
6010: IFFALSE 6211
// begin Wait ( 0 0$01 ) ;
6012: LD_INT 35
6014: PPUSH
6015: CALL_OW 67
// for i = 1 to us_force do
6019: LD_ADDR_VAR 0 2
6023: PUSH
6024: DOUBLE
6025: LD_INT 1
6027: DEC
6028: ST_TO_ADDR
6029: LD_EXP 12
6033: PUSH
6034: FOR_TO
6035: IFFALSE 6070
// ComAttackUnit ( us_force [ i ] , FindTarget ( us_force [ i ] ) ) ;
6037: LD_EXP 12
6041: PUSH
6042: LD_VAR 0 2
6046: ARRAY
6047: PPUSH
6048: LD_EXP 12
6052: PUSH
6053: LD_VAR 0 2
6057: ARRAY
6058: PPUSH
6059: CALL 10443 0 1
6063: PPUSH
6064: CALL_OW 115
6068: GO 6034
6070: POP
6071: POP
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) then
6072: LD_INT 22
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 25
6084: PUSH
6085: LD_INT 3
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 3
6094: PUSH
6095: LD_INT 55
6097: PUSH
6098: EMPTY
6099: LIST
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 69
6114: IFFALSE 6209
// for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) do
6116: LD_ADDR_VAR 0 3
6120: PUSH
6121: LD_INT 22
6123: PUSH
6124: LD_INT 1
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: LD_INT 25
6133: PUSH
6134: LD_INT 3
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 3
6143: PUSH
6144: LD_INT 55
6146: PUSH
6147: EMPTY
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: EMPTY
6155: LIST
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 69
6163: PUSH
6164: FOR_IN
6165: IFFALSE 6207
// if not IsInArea ( j , conv_end ) then
6167: LD_VAR 0 3
6171: PPUSH
6172: LD_INT 9
6174: PPUSH
6175: CALL_OW 308
6179: NOT
6180: IFFALSE 6196
// ComMoveToArea ( j , conv_end ) else
6182: LD_VAR 0 3
6186: PPUSH
6187: LD_INT 9
6189: PPUSH
6190: CALL_OW 113
6194: GO 6205
// RemoveUnit ( j ) ;
6196: LD_VAR 0 3
6200: PPUSH
6201: CALL_OW 64
6205: GO 6164
6207: POP
6208: POP
// end ;
6209: GO 5996
// end ; end_of_file
6211: LD_VAR 0 1
6215: RET
// export function PrepareArabian ; begin
6216: LD_INT 0
6218: PPUSH
// RobertFarmer ;
6219: CALL 6240 0 0
// PrepareHovercrafts ;
6223: CALL 7114 0 0
// ar_attacks := true ;
6227: LD_ADDR_EXP 10
6231: PUSH
6232: LD_INT 1
6234: ST_TO_ADDR
// end ;
6235: LD_VAR 0 1
6239: RET
// export Farmer ; export function RobertFarmer ; begin
6240: LD_INT 0
6242: PPUSH
// uc_side := 2 ;
6243: LD_ADDR_OWVAR 20
6247: PUSH
6248: LD_INT 2
6250: ST_TO_ADDR
// uc_nation := 2 ;
6251: LD_ADDR_OWVAR 21
6255: PUSH
6256: LD_INT 2
6258: ST_TO_ADDR
// Farmer := NewCharacter ( Farmer ) ;
6259: LD_ADDR_EXP 24
6263: PUSH
6264: LD_STRING Farmer
6266: PPUSH
6267: CALL_OW 25
6271: ST_TO_ADDR
// SayRadio ( Farmer , DPM_F1 ) ;
6272: LD_EXP 24
6276: PPUSH
6277: LD_STRING DPM_F1
6279: PPUSH
6280: CALL_OW 94
// end ;
6284: LD_VAR 0 1
6288: RET
// export function PrepareAttack ( type ) ; var i , un , veh , skill ; begin
6289: LD_INT 0
6291: PPUSH
6292: PPUSH
6293: PPUSH
6294: PPUSH
6295: PPUSH
// uc_side := 2 ;
6296: LD_ADDR_OWVAR 20
6300: PUSH
6301: LD_INT 2
6303: ST_TO_ADDR
// uc_nation := 2 ;
6304: LD_ADDR_OWVAR 21
6308: PUSH
6309: LD_INT 2
6311: ST_TO_ADDR
// skill := [ 4 , 6 , 7 ] [ Difficulty ] ;
6312: LD_ADDR_VAR 0 6
6316: PUSH
6317: LD_INT 4
6319: PUSH
6320: LD_INT 6
6322: PUSH
6323: LD_INT 7
6325: PUSH
6326: EMPTY
6327: LIST
6328: LIST
6329: LIST
6330: PUSH
6331: LD_OWVAR 67
6335: ARRAY
6336: ST_TO_ADDR
// Randomize ;
6337: CALL_OW 10
// case type of 1 :
6341: LD_VAR 0 1
6345: PUSH
6346: LD_INT 1
6348: DOUBLE
6349: EQUAL
6350: IFTRUE 6354
6352: GO 6476
6354: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6355: LD_ADDR_VAR 0 3
6359: PUSH
6360: DOUBLE
6361: LD_INT 1
6363: DEC
6364: ST_TO_ADDR
6365: LD_INT 3
6367: PUSH
6368: LD_INT 4
6370: PUSH
6371: LD_INT 5
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: LIST
6378: PUSH
6379: LD_OWVAR 67
6383: ARRAY
6384: PUSH
6385: FOR_TO
6386: IFFALSE 6472
// begin PrepareHuman ( false , [ class_soldier , class_soldier , class_mortar ] [ Rand ( 1 , 3 ) ] , skill ) ;
6388: LD_INT 0
6390: PPUSH
6391: LD_INT 1
6393: PUSH
6394: LD_INT 1
6396: PUSH
6397: LD_INT 8
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 3
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: PPUSH
6417: LD_VAR 0 6
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 4
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , ar3 , false ) ;
6436: LD_VAR 0 4
6440: PPUSH
6441: LD_INT 18
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// ComMoveToArea ( un , spot3 ) ;
6451: LD_VAR 0 4
6455: PPUSH
6456: LD_INT 20
6458: PPUSH
6459: CALL_OW 113
// Wait ( 0 0$01 ) ;
6463: LD_INT 35
6465: PPUSH
6466: CALL_OW 67
// end ;
6470: GO 6385
6472: POP
6473: POP
// end ; 2 :
6474: GO 7109
6476: LD_INT 2
6478: DOUBLE
6479: EQUAL
6480: IFTRUE 6484
6482: GO 6751
6484: POP
// begin for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
6485: LD_ADDR_VAR 0 3
6489: PUSH
6490: DOUBLE
6491: LD_INT 1
6493: DEC
6494: ST_TO_ADDR
6495: LD_INT 4
6497: PUSH
6498: LD_INT 5
6500: PUSH
6501: LD_INT 5
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: PUSH
6509: LD_OWVAR 67
6513: ARRAY
6514: PUSH
6515: FOR_TO
6516: IFFALSE 6579
// begin PrepareHuman ( false , class_soldier , skill ) ;
6518: LD_INT 0
6520: PPUSH
6521: LD_INT 1
6523: PPUSH
6524: LD_VAR 0 6
6528: PPUSH
6529: CALL_OW 380
// un := CreateHuman ;
6533: LD_ADDR_VAR 0 4
6537: PUSH
6538: CALL_OW 44
6542: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6543: LD_VAR 0 4
6547: PPUSH
6548: LD_INT 17
6550: PPUSH
6551: LD_INT 0
6553: PPUSH
6554: CALL_OW 49
// ComMoveToArea ( un , spot2 ) ;
6558: LD_VAR 0 4
6562: PPUSH
6563: LD_INT 19
6565: PPUSH
6566: CALL_OW 113
// Wait ( 0 0$01 ) ;
6570: LD_INT 35
6572: PPUSH
6573: CALL_OW 67
// end ;
6577: GO 6515
6579: POP
6580: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6581: LD_ADDR_VAR 0 3
6585: PUSH
6586: DOUBLE
6587: LD_INT 1
6589: DEC
6590: ST_TO_ADDR
6591: LD_INT 2
6593: PUSH
6594: LD_INT 3
6596: PUSH
6597: LD_INT 4
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: PUSH
6605: LD_OWVAR 67
6609: ARRAY
6610: PUSH
6611: FOR_TO
6612: IFFALSE 6747
// begin vc_chassis := ar_medium_trike ;
6614: LD_ADDR_OWVAR 37
6618: PUSH
6619: LD_INT 13
6621: ST_TO_ADDR
// vc_engine := engine_combustion ;
6622: LD_ADDR_OWVAR 39
6626: PUSH
6627: LD_INT 1
6629: ST_TO_ADDR
// vc_control := control_manual ;
6630: LD_ADDR_OWVAR 38
6634: PUSH
6635: LD_INT 1
6637: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_light_gun , ar_gun ] [ Rand ( 1 , 3 ) ] ;
6638: LD_ADDR_OWVAR 40
6642: PUSH
6643: LD_INT 24
6645: PUSH
6646: LD_INT 23
6648: PUSH
6649: LD_INT 27
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 1
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 12
6667: ARRAY
6668: ST_TO_ADDR
// veh := CreateVehicle ;
6669: LD_ADDR_VAR 0 5
6673: PUSH
6674: CALL_OW 45
6678: ST_TO_ADDR
// PlaceUnitArea ( veh , ar2 , false ) ;
6679: LD_VAR 0 5
6683: PPUSH
6684: LD_INT 17
6686: PPUSH
6687: LD_INT 0
6689: PPUSH
6690: CALL_OW 49
// PrepareHuman ( false , 1 , skill ) ;
6694: LD_INT 0
6696: PPUSH
6697: LD_INT 1
6699: PPUSH
6700: LD_VAR 0 6
6704: PPUSH
6705: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6709: CALL_OW 44
6713: PPUSH
6714: LD_VAR 0 5
6718: PPUSH
6719: CALL_OW 52
// ComMoveXY ( veh , 89 , 40 ) ;
6723: LD_VAR 0 5
6727: PPUSH
6728: LD_INT 89
6730: PPUSH
6731: LD_INT 40
6733: PPUSH
6734: CALL_OW 111
// Wait ( 0 0$02 ) ;
6738: LD_INT 70
6740: PPUSH
6741: CALL_OW 67
// end ;
6745: GO 6611
6747: POP
6748: POP
// end ; 3 :
6749: GO 7109
6751: LD_INT 3
6753: DOUBLE
6754: EQUAL
6755: IFTRUE 6759
6757: GO 7108
6759: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( tick div 15 15$00 ) do
6760: LD_ADDR_VAR 0 3
6764: PUSH
6765: DOUBLE
6766: LD_INT 1
6768: DEC
6769: ST_TO_ADDR
6770: LD_INT 3
6772: PUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 5
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: PUSH
6784: LD_OWVAR 67
6788: ARRAY
6789: PUSH
6790: LD_OWVAR 1
6794: PUSH
6795: LD_INT 31500
6797: DIV
6798: PLUS
6799: PUSH
6800: FOR_TO
6801: IFFALSE 6909
// begin PrepareHuman ( false , [ class_soldier , class_mortar ] [ Rand ( 1 , 2 ) ] , skill ) ;
6803: LD_INT 0
6805: PPUSH
6806: LD_INT 1
6808: PUSH
6809: LD_INT 8
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PUSH
6816: LD_INT 1
6818: PPUSH
6819: LD_INT 2
6821: PPUSH
6822: CALL_OW 12
6826: ARRAY
6827: PPUSH
6828: LD_VAR 0 6
6832: PPUSH
6833: CALL_OW 380
// un := CreateHuman ;
6837: LD_ADDR_VAR 0 4
6841: PUSH
6842: CALL_OW 44
6846: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6847: LD_VAR 0 4
6851: PPUSH
6852: LD_INT 17
6854: PPUSH
6855: LD_INT 0
6857: PPUSH
6858: CALL_OW 49
// ar_force := Insert ( ar_force , 1 , un ) ;
6862: LD_ADDR_EXP 11
6866: PUSH
6867: LD_EXP 11
6871: PPUSH
6872: LD_INT 1
6874: PPUSH
6875: LD_VAR 0 4
6879: PPUSH
6880: CALL_OW 2
6884: ST_TO_ADDR
// ComMoveXY ( un , 17 , 9 ) ;
6885: LD_VAR 0 4
6889: PPUSH
6890: LD_INT 17
6892: PPUSH
6893: LD_INT 9
6895: PPUSH
6896: CALL_OW 111
// Wait ( 0 0$01 ) ;
6900: LD_INT 35
6902: PPUSH
6903: CALL_OW 67
// end ;
6907: GO 6800
6909: POP
6910: POP
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: DOUBLE
6917: LD_INT 1
6919: DEC
6920: ST_TO_ADDR
6921: LD_INT 4
6923: PUSH
6924: LD_INT 5
6926: PUSH
6927: LD_INT 6
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: PUSH
6935: LD_OWVAR 67
6939: ARRAY
6940: PUSH
6941: FOR_TO
6942: IFFALSE 7104
// begin vc_chassis := ar_half_tracked ;
6944: LD_ADDR_OWVAR 37
6948: PUSH
6949: LD_INT 14
6951: ST_TO_ADDR
// vc_engine := engine_combustion ;
6952: LD_ADDR_OWVAR 39
6956: PUSH
6957: LD_INT 1
6959: ST_TO_ADDR
// vc_control := control_manual ;
6960: LD_ADDR_OWVAR 38
6964: PUSH
6965: LD_INT 1
6967: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ;
6968: LD_ADDR_OWVAR 40
6972: PUSH
6973: LD_INT 25
6975: PUSH
6976: LD_INT 27
6978: PUSH
6979: LD_INT 28
6981: PUSH
6982: LD_INT 26
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: LIST
6989: LIST
6990: PUSH
6991: LD_INT 1
6993: PPUSH
6994: LD_INT 4
6996: PPUSH
6997: CALL_OW 12
7001: ARRAY
7002: ST_TO_ADDR
// veh := CreateVehicle ;
7003: LD_ADDR_VAR 0 5
7007: PUSH
7008: CALL_OW 45
7012: ST_TO_ADDR
// PlaceUnitArea ( veh , ar1 , false ) ;
7013: LD_VAR 0 5
7017: PPUSH
7018: LD_INT 16
7020: PPUSH
7021: LD_INT 0
7023: PPUSH
7024: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7028: LD_INT 0
7030: PPUSH
7031: LD_INT 3
7033: PPUSH
7034: LD_VAR 0 6
7038: PPUSH
7039: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7043: CALL_OW 44
7047: PPUSH
7048: LD_VAR 0 5
7052: PPUSH
7053: CALL_OW 52
// ar_force := Insert ( ar_force , 1 , veh ) ;
7057: LD_ADDR_EXP 11
7061: PUSH
7062: LD_EXP 11
7066: PPUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_VAR 0 5
7074: PPUSH
7075: CALL_OW 2
7079: ST_TO_ADDR
// ComMoveXY ( veh , 125 , 31 ) ;
7080: LD_VAR 0 5
7084: PPUSH
7085: LD_INT 125
7087: PPUSH
7088: LD_INT 31
7090: PPUSH
7091: CALL_OW 111
// Wait ( 0 0$02 ) ;
7095: LD_INT 70
7097: PPUSH
7098: CALL_OW 67
// end ;
7102: GO 6941
7104: POP
7105: POP
// end ; end ;
7106: GO 7109
7108: POP
// end ;
7109: LD_VAR 0 2
7113: RET
// export function PrepareHovercrafts ; var i , un , areas , skill ; begin
7114: LD_INT 0
7116: PPUSH
7117: PPUSH
7118: PPUSH
7119: PPUSH
7120: PPUSH
// areas := [ river1 , river2 ] ;
7121: LD_ADDR_VAR 0 4
7125: PUSH
7126: LD_INT 14
7128: PUSH
7129: LD_INT 15
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7136: LD_ADDR_VAR 0 5
7140: PUSH
7141: LD_INT 5
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 7
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: LIST
7154: PUSH
7155: LD_OWVAR 67
7159: ARRAY
7160: ST_TO_ADDR
// uc_side := 2 ;
7161: LD_ADDR_OWVAR 20
7165: PUSH
7166: LD_INT 2
7168: ST_TO_ADDR
// uc_nation := 2 ;
7169: LD_ADDR_OWVAR 21
7173: PUSH
7174: LD_INT 2
7176: ST_TO_ADDR
// hc_name :=  ;
7177: LD_ADDR_OWVAR 26
7181: PUSH
7182: LD_STRING 
7184: ST_TO_ADDR
// hc_gallery :=  ;
7185: LD_ADDR_OWVAR 33
7189: PUSH
7190: LD_STRING 
7192: ST_TO_ADDR
// for i = 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
7193: LD_ADDR_VAR 0 2
7197: PUSH
7198: DOUBLE
7199: LD_INT 1
7201: DEC
7202: ST_TO_ADDR
7203: LD_INT 1
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 2
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: LIST
7216: PUSH
7217: LD_OWVAR 67
7221: ARRAY
7222: PUSH
7223: FOR_TO
7224: IFFALSE 7362
// begin vc_chassis := ar_hovercraft ;
7226: LD_ADDR_OWVAR 37
7230: PUSH
7231: LD_INT 11
7233: ST_TO_ADDR
// vc_engine := engine_solar ;
7234: LD_ADDR_OWVAR 39
7238: PUSH
7239: LD_INT 2
7241: ST_TO_ADDR
// vc_control := control_manual ;
7242: LD_ADDR_OWVAR 38
7246: PUSH
7247: LD_INT 1
7249: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
7250: LD_ADDR_OWVAR 40
7254: PUSH
7255: LD_INT 24
7257: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7258: LD_ADDR_OWVAR 41
7262: PUSH
7263: LD_INT 100
7265: ST_TO_ADDR
// un := CreateVehicle ;
7266: LD_ADDR_VAR 0 3
7270: PUSH
7271: CALL_OW 45
7275: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ i ] , false ) ;
7276: LD_VAR 0 3
7280: PPUSH
7281: LD_VAR 0 4
7285: PUSH
7286: LD_VAR 0 2
7290: ARRAY
7291: PPUSH
7292: LD_INT 0
7294: PPUSH
7295: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7299: LD_INT 0
7301: PPUSH
7302: LD_INT 3
7304: PPUSH
7305: LD_VAR 0 5
7309: PPUSH
7310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
7314: CALL_OW 44
7318: PPUSH
7319: LD_VAR 0 3
7323: PPUSH
7324: CALL_OW 52
// riv := Insert ( riv , 1 , [ un , i ] ) ;
7328: LD_ADDR_EXP 9
7332: PUSH
7333: LD_EXP 9
7337: PPUSH
7338: LD_INT 1
7340: PPUSH
7341: LD_VAR 0 3
7345: PUSH
7346: LD_VAR 0 2
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PPUSH
7355: CALL_OW 2
7359: ST_TO_ADDR
// end ;
7360: GO 7223
7362: POP
7363: POP
// end ;
7364: LD_VAR 0 1
7368: RET
// every 0 0$01 trigger riv do var i , c ;
7369: LD_EXP 9
7373: IFFALSE 7808
7375: GO 7377
7377: DISABLE
7378: LD_INT 0
7380: PPUSH
7381: PPUSH
// begin enable ;
7382: ENABLE
// for i = riv downto 1 do
7383: LD_ADDR_VAR 0 1
7387: PUSH
7388: DOUBLE
7389: LD_EXP 9
7393: INC
7394: ST_TO_ADDR
7395: LD_INT 1
7397: PUSH
7398: FOR_DOWNTO
7399: IFFALSE 7806
// begin if not riv [ i ] [ 1 ] then
7401: LD_EXP 9
7405: PUSH
7406: LD_VAR 0 1
7410: ARRAY
7411: PUSH
7412: LD_INT 1
7414: ARRAY
7415: NOT
7416: IFFALSE 7438
// begin riv := Delete ( riv , 1 ) ;
7418: LD_ADDR_EXP 9
7422: PUSH
7423: LD_EXP 9
7427: PPUSH
7428: LD_INT 1
7430: PPUSH
7431: CALL_OW 3
7435: ST_TO_ADDR
// break ;
7436: GO 7806
// end ; if not HasTask ( riv [ i ] [ 1 ] ) then
7438: LD_EXP 9
7442: PUSH
7443: LD_VAR 0 1
7447: ARRAY
7448: PUSH
7449: LD_INT 1
7451: ARRAY
7452: PPUSH
7453: CALL_OW 314
7457: NOT
7458: IFFALSE 7526
// begin if riv [ i ] [ 2 ] = 1 then
7460: LD_EXP 9
7464: PUSH
7465: LD_VAR 0 1
7469: ARRAY
7470: PUSH
7471: LD_INT 2
7473: ARRAY
7474: PUSH
7475: LD_INT 1
7477: EQUAL
7478: IFFALSE 7490
// c := 2 else
7480: LD_ADDR_VAR 0 2
7484: PUSH
7485: LD_INT 2
7487: ST_TO_ADDR
7488: GO 7498
// c := 1 ;
7490: LD_ADDR_VAR 0 2
7494: PUSH
7495: LD_INT 1
7497: ST_TO_ADDR
// riv := Replace2 ( riv , i , 2 , c ) ;
7498: LD_ADDR_EXP 9
7502: PUSH
7503: LD_EXP 9
7507: PPUSH
7508: LD_VAR 0 1
7512: PPUSH
7513: LD_INT 2
7515: PPUSH
7516: LD_VAR 0 2
7520: PPUSH
7521: CALL 10135 0 4
7525: ST_TO_ADDR
// end ; if not IsInArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) then
7526: LD_EXP 9
7530: PUSH
7531: LD_VAR 0 1
7535: ARRAY
7536: PUSH
7537: LD_INT 1
7539: ARRAY
7540: PPUSH
7541: LD_INT 14
7543: PUSH
7544: LD_INT 15
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: LD_EXP 9
7555: PUSH
7556: LD_VAR 0 1
7560: ARRAY
7561: PUSH
7562: LD_INT 2
7564: ARRAY
7565: ARRAY
7566: PPUSH
7567: CALL_OW 308
7571: NOT
7572: IFFALSE 7804
// begin if GetFuel ( riv [ i ] [ 1 ] ) < 50 then
7574: LD_EXP 9
7578: PUSH
7579: LD_VAR 0 1
7583: ARRAY
7584: PUSH
7585: LD_INT 1
7587: ARRAY
7588: PPUSH
7589: CALL_OW 261
7593: PUSH
7594: LD_INT 50
7596: LESS
7597: IFFALSE 7621
// SetFuel ( riv [ i ] [ 1 ] , 67 ) ;
7599: LD_EXP 9
7603: PUSH
7604: LD_VAR 0 1
7608: ARRAY
7609: PUSH
7610: LD_INT 1
7612: ARRAY
7613: PPUSH
7614: LD_INT 67
7616: PPUSH
7617: CALL_OW 240
// if GetDistUnits ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) < 9 then
7621: LD_EXP 9
7625: PUSH
7626: LD_VAR 0 1
7630: ARRAY
7631: PUSH
7632: LD_INT 1
7634: ARRAY
7635: PPUSH
7636: LD_INT 22
7638: PUSH
7639: LD_INT 3
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PPUSH
7646: CALL_OW 69
7650: PPUSH
7651: LD_EXP 9
7655: PUSH
7656: LD_VAR 0 1
7660: ARRAY
7661: PUSH
7662: LD_INT 1
7664: ARRAY
7665: PPUSH
7666: CALL_OW 74
7670: PPUSH
7671: CALL_OW 296
7675: PUSH
7676: LD_INT 9
7678: LESS
7679: IFFALSE 7737
// ComAttackUnit ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) else
7681: LD_EXP 9
7685: PUSH
7686: LD_VAR 0 1
7690: ARRAY
7691: PUSH
7692: LD_INT 1
7694: ARRAY
7695: PPUSH
7696: LD_INT 22
7698: PUSH
7699: LD_INT 3
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PPUSH
7706: CALL_OW 69
7710: PPUSH
7711: LD_EXP 9
7715: PUSH
7716: LD_VAR 0 1
7720: ARRAY
7721: PUSH
7722: LD_INT 1
7724: ARRAY
7725: PPUSH
7726: CALL_OW 74
7730: PPUSH
7731: CALL_OW 115
7735: GO 7804
// begin ComMoveToArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) ;
7737: LD_EXP 9
7741: PUSH
7742: LD_VAR 0 1
7746: ARRAY
7747: PUSH
7748: LD_INT 1
7750: ARRAY
7751: PPUSH
7752: LD_INT 14
7754: PUSH
7755: LD_INT 15
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: PUSH
7762: LD_EXP 9
7766: PUSH
7767: LD_VAR 0 1
7771: ARRAY
7772: PUSH
7773: LD_INT 2
7775: ARRAY
7776: ARRAY
7777: PPUSH
7778: CALL_OW 113
// AddComWait ( riv [ i ] [ 1 ] , 0 0$10 ) ;
7782: LD_EXP 9
7786: PUSH
7787: LD_VAR 0 1
7791: ARRAY
7792: PUSH
7793: LD_INT 1
7795: ARRAY
7796: PPUSH
7797: LD_INT 350
7799: PPUSH
7800: CALL_OW 202
// end ; end ; end ;
7804: GO 7398
7806: POP
7807: POP
// end ;
7808: PPOPN 2
7810: END
// every 10 10$00 trigger convoy_start do var i , un ;
7811: LD_EXP 7
7815: IFFALSE 7936
7817: GO 7819
7819: DISABLE
7820: LD_INT 0
7822: PPUSH
7823: PPUSH
// begin enable ;
7824: ENABLE
// for i = 1 to 2 do
7825: LD_ADDR_VAR 0 1
7829: PUSH
7830: DOUBLE
7831: LD_INT 1
7833: DEC
7834: ST_TO_ADDR
7835: LD_INT 2
7837: PUSH
7838: FOR_TO
7839: IFFALSE 7934
// begin uc_side := 2 ;
7841: LD_ADDR_OWVAR 20
7845: PUSH
7846: LD_INT 2
7848: ST_TO_ADDR
// uc_nation := 2 ;
7849: LD_ADDR_OWVAR 21
7853: PUSH
7854: LD_INT 2
7856: ST_TO_ADDR
// PrepareHuman ( false , 1 , 4 ) ;
7857: LD_INT 0
7859: PPUSH
7860: LD_INT 1
7862: PPUSH
7863: LD_INT 4
7865: PPUSH
7866: CALL_OW 380
// un := CreateHuman ;
7870: LD_ADDR_VAR 0 2
7874: PUSH
7875: CALL_OW 44
7879: ST_TO_ADDR
// PlaceUnitXY ( un , 10 , 2 , false ) ;
7880: LD_VAR 0 2
7884: PPUSH
7885: LD_INT 10
7887: PPUSH
7888: LD_INT 2
7890: PPUSH
7891: LD_INT 0
7893: PPUSH
7894: CALL_OW 48
// ComMoveXY ( un , 24 , 36 ) ;
7898: LD_VAR 0 2
7902: PPUSH
7903: LD_INT 24
7905: PPUSH
7906: LD_INT 36
7908: PPUSH
7909: CALL_OW 111
// AddComMoveToArea ( un , conv_end ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: LD_INT 9
7920: PPUSH
7921: CALL_OW 173
// Wait ( 0 0$02 ) ;
7925: LD_INT 70
7927: PPUSH
7928: CALL_OW 67
// end ;
7932: GO 7838
7934: POP
7935: POP
// end ;
7936: PPOPN 2
7938: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , rest ;
7939: LD_INT 22
7941: PUSH
7942: LD_INT 2
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PPUSH
7949: CALL_OW 69
7953: IFFALSE 8264
7955: GO 7957
7957: DISABLE
7958: LD_INT 0
7960: PPUSH
7961: PPUSH
// begin enable ;
7962: ENABLE
// rest := FilterAllUnits ( [ f_side , 2 ] ) diff ar_force ;
7963: LD_ADDR_VAR 0 2
7967: PUSH
7968: LD_INT 22
7970: PUSH
7971: LD_INT 2
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: PPUSH
7978: CALL_OW 69
7982: PUSH
7983: LD_EXP 11
7987: DIFF
7988: ST_TO_ADDR
// if rest then
7989: LD_VAR 0 2
7993: IFFALSE 8065
// for i in rest do
7995: LD_ADDR_VAR 0 1
7999: PUSH
8000: LD_VAR 0 2
8004: PUSH
8005: FOR_IN
8006: IFFALSE 8063
// if GetClass ( i ) = 3 then
8008: LD_VAR 0 1
8012: PPUSH
8013: CALL_OW 257
8017: PUSH
8018: LD_INT 3
8020: EQUAL
8021: IFFALSE 8061
// begin if not IsInArea ( i , ar2 ) then
8023: LD_VAR 0 1
8027: PPUSH
8028: LD_INT 17
8030: PPUSH
8031: CALL_OW 308
8035: NOT
8036: IFFALSE 8052
// ComMoveToArea ( i , ar2 ) else
8038: LD_VAR 0 1
8042: PPUSH
8043: LD_INT 17
8045: PPUSH
8046: CALL_OW 113
8050: GO 8061
// RemoveUnit ( i ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 64
// end ;
8061: GO 8005
8063: POP
8064: POP
// if ar_force then
8065: LD_EXP 11
8069: IFFALSE 8264
// for i in ar_force do
8071: LD_ADDR_VAR 0 1
8075: PUSH
8076: LD_EXP 11
8080: PUSH
8081: FOR_IN
8082: IFFALSE 8262
// begin if GetClass ( i ) = class_soldier then
8084: LD_VAR 0 1
8088: PPUSH
8089: CALL_OW 257
8093: PUSH
8094: LD_INT 1
8096: EQUAL
8097: IFFALSE 8189
// if FindTarget ( i ) in FilterAllUnits ( [ f_type , unit_building ] ) then
8099: LD_VAR 0 1
8103: PPUSH
8104: CALL 10443 0 1
8108: PUSH
8109: LD_INT 21
8111: PUSH
8112: LD_INT 3
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PPUSH
8119: CALL_OW 69
8123: IN
8124: IFFALSE 8170
// ComPlaceDelayedCharge ( i , GetX ( FindTarget ( i ) ) , GetY ( FindTarget ( i ) ) , 0 ) else
8126: LD_VAR 0 1
8130: PPUSH
8131: LD_VAR 0 1
8135: PPUSH
8136: CALL 10443 0 1
8140: PPUSH
8141: CALL_OW 250
8145: PPUSH
8146: LD_VAR 0 1
8150: PPUSH
8151: CALL 10443 0 1
8155: PPUSH
8156: CALL_OW 251
8160: PPUSH
8161: LD_INT 0
8163: PPUSH
8164: CALL_OW 132
8168: GO 8189
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8170: LD_VAR 0 1
8174: PPUSH
8175: LD_VAR 0 1
8179: PPUSH
8180: CALL 10443 0 1
8184: PPUSH
8185: CALL_OW 115
// if not GetClass ( i ) = 1 then
8189: LD_VAR 0 1
8193: PPUSH
8194: CALL_OW 257
8198: PUSH
8199: LD_INT 1
8201: EQUAL
8202: NOT
8203: IFFALSE 8224
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8205: LD_VAR 0 1
8209: PPUSH
8210: LD_VAR 0 1
8214: PPUSH
8215: CALL 10443 0 1
8219: PPUSH
8220: CALL_OW 115
// if GetDistUnitXY ( i , 65 , 118 ) < 40 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_INT 65
8231: PPUSH
8232: LD_INT 118
8234: PPUSH
8235: CALL_OW 297
8239: PUSH
8240: LD_INT 40
8242: LESS
8243: IFFALSE 8260
// ComMoveXY ( i , 65 , 118 ) ;
8245: LD_VAR 0 1
8249: PPUSH
8250: LD_INT 65
8252: PPUSH
8253: LD_INT 118
8255: PPUSH
8256: CALL_OW 111
// end ;
8260: GO 8081
8262: POP
8263: POP
// end ;
8264: PPOPN 2
8266: END
// every 0 0$01 trigger FilterUnitsInArea ( conv_end , [ f_side , 2 ] ) do
8267: LD_INT 9
8269: PPUSH
8270: LD_INT 22
8272: PUSH
8273: LD_INT 2
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PPUSH
8280: CALL_OW 70
8284: IFFALSE 8297
8286: GO 8288
8288: DISABLE
// medal2 := false ; end_of_file
8289: LD_ADDR_EXP 4
8293: PUSH
8294: LD_INT 0
8296: ST_TO_ADDR
8297: END
// export function Action ; begin
8298: LD_INT 0
8300: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
8301: LD_ADDR_OWVAR 67
8305: PUSH
8306: LD_INT 0
8308: PPUSH
8309: CALL_OW 426
8313: ST_TO_ADDR
// case Query ( info ) of 1 :
8314: LD_STRING info
8316: PPUSH
8317: CALL_OW 97
8321: PUSH
8322: LD_INT 1
8324: DOUBLE
8325: EQUAL
8326: IFTRUE 8330
8328: GO 8333
8330: POP
// ; end ;
8331: GO 8334
8333: POP
// ChangeMissionObjectives ( PM_1 ) ;
8334: LD_STRING PM_1
8336: PPUSH
8337: CALL_OW 337
// SaveForQuickRestart ;
8341: CALL_OW 22
// end ;
8345: LD_VAR 0 1
8349: RET
// every 0 0$01 trigger GetSide ( us_depot ) = 3 do
8350: LD_INT 50
8352: PPUSH
8353: CALL_OW 255
8357: PUSH
8358: LD_INT 3
8360: EQUAL
8361: IFFALSE 8642
8363: GO 8365
8365: DISABLE
// begin Say ( Stolypin , DPM_S1 ) ;
8366: LD_EXP 15
8370: PPUSH
8371: LD_STRING DPM_S1
8373: PPUSH
8374: CALL_OW 88
// SayRadio ( Popov , DPM_P1 ) ;
8378: LD_EXP 16
8382: PPUSH
8383: LD_STRING DPM_P1
8385: PPUSH
8386: CALL_OW 94
// Say ( Stolypin , DPM_S2 ) ;
8390: LD_EXP 15
8394: PPUSH
8395: LD_STRING DPM_S2
8397: PPUSH
8398: CALL_OW 88
// SaveForQuickRestart ;
8402: CALL_OW 22
// ChangeMissionObjectives ( PM_2 ) ;
8406: LD_STRING PM_2
8408: PPUSH
8409: CALL_OW 337
// Wait ( 2 2$30 ) ;
8413: LD_INT 5250
8415: PPUSH
8416: CALL_OW 67
// CenterOnXY ( 117 , 4 ) ;
8420: LD_INT 117
8422: PPUSH
8423: LD_INT 4
8425: PPUSH
8426: CALL_OW 84
// Convoy ( 1 ) ;
8430: LD_INT 1
8432: PPUSH
8433: CALL 883 0 1
// Wait ( 0 0$30 ) ;
8437: LD_INT 1050
8439: PPUSH
8440: CALL_OW 67
// Convoy ( 2 ) ;
8444: LD_INT 2
8446: PPUSH
8447: CALL 883 0 1
// Wait ( 1 1$30 ) ;
8451: LD_INT 3150
8453: PPUSH
8454: CALL_OW 67
// Convoy ( 3 ) ;
8458: LD_INT 3
8460: PPUSH
8461: CALL 883 0 1
// Wait ( 5 5$00 ) ;
8465: LD_INT 10500
8467: PPUSH
8468: CALL_OW 67
// convoy_start := true ;
8472: LD_ADDR_EXP 7
8476: PUSH
8477: LD_INT 1
8479: ST_TO_ADDR
// PrepareArabian ;
8480: CALL 6216 0 0
// PrepareAttack ( 1 ) ;
8484: LD_INT 1
8486: PPUSH
8487: CALL 6289 0 1
// while ( convoy_start ) do
8491: LD_EXP 7
8495: IFFALSE 8642
// begin Wait ( Rand ( 2 2$00 , 4 4$00 ) ) ;
8497: LD_INT 4200
8499: PPUSH
8500: LD_INT 8400
8502: PPUSH
8503: CALL_OW 12
8507: PPUSH
8508: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) < 20 then
8512: LD_INT 22
8514: PUSH
8515: LD_INT 2
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PPUSH
8522: CALL_OW 69
8526: PUSH
8527: LD_INT 20
8529: LESS
8530: IFFALSE 8547
// PrepareAttack ( Rand ( 1 , 2 ) ) ;
8532: LD_INT 1
8534: PPUSH
8535: LD_INT 2
8537: PPUSH
8538: CALL_OW 12
8542: PPUSH
8543: CALL 6289 0 1
// Convoy ( Rand ( 1 , 5 ) ) ;
8547: LD_INT 1
8549: PPUSH
8550: LD_INT 5
8552: PPUSH
8553: CALL_OW 12
8557: PPUSH
8558: CALL 883 0 1
// conv_counter := conv_counter + 1 ;
8562: LD_ADDR_EXP 13
8566: PUSH
8567: LD_EXP 13
8571: PUSH
8572: LD_INT 1
8574: PLUS
8575: ST_TO_ADDR
// if conv_counter mod [ 5 , 4 , 3 ] [ Difficulty ] = 0 then
8576: LD_EXP 13
8580: PUSH
8581: LD_INT 5
8583: PUSH
8584: LD_INT 4
8586: PUSH
8587: LD_INT 3
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: LIST
8594: PUSH
8595: LD_OWVAR 67
8599: ARRAY
8600: MOD
8601: PUSH
8602: LD_INT 0
8604: EQUAL
8605: IFFALSE 8640
// begin Wait ( 1 1$20 ) ;
8607: LD_INT 2800
8609: PPUSH
8610: CALL_OW 67
// SayRadio ( Farmer , DPM_F2 ) ;
8614: LD_EXP 24
8618: PPUSH
8619: LD_STRING DPM_F2
8621: PPUSH
8622: CALL_OW 94
// PrepareAttack ( 3 ) ;
8626: LD_INT 3
8628: PPUSH
8629: CALL 6289 0 1
// Wait ( 4 4$00 ) ;
8633: LD_INT 8400
8635: PPUSH
8636: CALL_OW 67
// end ; end ;
8640: GO 8491
// end ;
8642: END
// every 1 1$30 trigger conv_counter mod 3 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8643: LD_EXP 13
8647: PUSH
8648: LD_INT 3
8650: MOD
8651: PUSH
8652: LD_INT 0
8654: EQUAL
8655: PUSH
8656: LD_INT 22
8658: PUSH
8659: LD_INT 2
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PPUSH
8666: CALL_OW 69
8670: PUSH
8671: LD_INT 0
8673: EQUAL
8674: AND
8675: IFFALSE 8692
8677: GO 8679
8679: DISABLE
// SayRadio ( Farmer , DPM_F3 ) ;
8680: LD_EXP 24
8684: PPUSH
8685: LD_STRING DPM_F3
8687: PPUSH
8688: CALL_OW 94
8692: END
// every 1 1$30 trigger conv_counter mod 5 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8693: LD_EXP 13
8697: PUSH
8698: LD_INT 5
8700: MOD
8701: PUSH
8702: LD_INT 0
8704: EQUAL
8705: PUSH
8706: LD_INT 22
8708: PUSH
8709: LD_INT 2
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: PPUSH
8716: CALL_OW 69
8720: PUSH
8721: LD_INT 0
8723: EQUAL
8724: AND
8725: IFFALSE 8742
8727: GO 8729
8729: DISABLE
// SayRadio ( Farmer , DPM_F4 ) ;
8730: LD_EXP 24
8734: PPUSH
8735: LD_STRING DPM_F4
8737: PPUSH
8738: CALL_OW 94
8742: END
// every 0 0$10 trigger conv_counter >= 8 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
8743: LD_EXP 13
8747: PUSH
8748: LD_INT 8
8750: GREATEREQUAL
8751: PUSH
8752: LD_INT 22
8754: PUSH
8755: LD_INT 6
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: PPUSH
8762: CALL_OW 69
8766: PUSH
8767: LD_INT 0
8769: EQUAL
8770: AND
8771: IFFALSE 8870
8773: GO 8775
8775: DISABLE
// begin SayRadio ( Popov , DPM_PEnd ) ;
8776: LD_EXP 16
8780: PPUSH
8781: LD_STRING DPM_PEnd
8783: PPUSH
8784: CALL_OW 94
// AddMedal ( med1 , medal1 ) ;
8788: LD_STRING med1
8790: PPUSH
8791: LD_EXP 3
8795: PPUSH
8796: CALL_OW 101
// AddMedal ( med2 , medal2 ) ;
8800: LD_STRING med2
8802: PPUSH
8803: LD_EXP 4
8807: PPUSH
8808: CALL_OW 101
// if dest_counter >= [ 15 , 10 , 7 ] [ Difficulty ] then
8812: LD_EXP 8
8816: PUSH
8817: LD_INT 15
8819: PUSH
8820: LD_INT 10
8822: PUSH
8823: LD_INT 7
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: PUSH
8831: LD_OWVAR 67
8835: ARRAY
8836: GREATEREQUAL
8837: IFFALSE 8847
// medal3 := false ;
8839: LD_ADDR_EXP 5
8843: PUSH
8844: LD_INT 0
8846: ST_TO_ADDR
// AddMedal ( med3 , medal3 ) ;
8847: LD_STRING med3
8849: PPUSH
8850: LD_EXP 5
8854: PPUSH
8855: CALL_OW 101
// GiveMedals ( MAIN ) ;
8859: LD_STRING MAIN
8861: PPUSH
8862: CALL_OW 102
// YouWin ;
8866: CALL_OW 103
// end ;
8870: END
// every 4 4$00 trigger convoy_start do var i ;
8871: LD_EXP 7
8875: IFFALSE 9233
8877: GO 8879
8879: DISABLE
8880: LD_INT 0
8882: PPUSH
// begin SayRadio ( Popov , DPM_PHelp ) ;
8883: LD_EXP 16
8887: PPUSH
8888: LD_STRING DPM_PHelp
8890: PPUSH
8891: CALL_OW 94
// Wait ( 0 0$30 ) ;
8895: LD_INT 1050
8897: PPUSH
8898: CALL_OW 67
// Randomize ;
8902: CALL_OW 10
// uc_side := 3 ;
8906: LD_ADDR_OWVAR 20
8910: PUSH
8911: LD_INT 3
8913: ST_TO_ADDR
// uc_nation := 3 ;
8914: LD_ADDR_OWVAR 21
8918: PUSH
8919: LD_INT 3
8921: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ Difficulty ] do
8922: LD_ADDR_VAR 0 1
8926: PUSH
8927: DOUBLE
8928: LD_INT 1
8930: DEC
8931: ST_TO_ADDR
8932: LD_INT 5
8934: PUSH
8935: LD_INT 4
8937: PUSH
8938: LD_INT 3
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: LIST
8945: PUSH
8946: LD_OWVAR 67
8950: ARRAY
8951: PUSH
8952: FOR_TO
8953: IFFALSE 8993
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , 5 ) ;
8955: LD_INT 0
8957: PPUSH
8958: LD_INT 1
8960: PPUSH
8961: LD_INT 3
8963: PPUSH
8964: CALL_OW 12
8968: PPUSH
8969: LD_INT 5
8971: PPUSH
8972: CALL_OW 380
// PlaceUnitArea ( CreateHuman , rus_start , false ) ;
8976: CALL_OW 44
8980: PPUSH
8981: LD_INT 1
8983: PPUSH
8984: LD_INT 0
8986: PPUSH
8987: CALL_OW 49
// end ;
8991: GO 8952
8993: POP
8994: POP
// vc_chassis := ru_heavy_wheeled ;
8995: LD_ADDR_OWVAR 37
8999: PUSH
9000: LD_INT 23
9002: ST_TO_ADDR
// vc_engine := engine_combustion ;
9003: LD_ADDR_OWVAR 39
9007: PUSH
9008: LD_INT 1
9010: ST_TO_ADDR
// vc_control := control_manual ;
9011: LD_ADDR_OWVAR 38
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// vc_weapon := 89 ;
9019: LD_ADDR_OWVAR 40
9023: PUSH
9024: LD_INT 89
9026: ST_TO_ADDR
// vc_fuel_battery := 88 ;
9027: LD_ADDR_OWVAR 41
9031: PUSH
9032: LD_INT 88
9034: ST_TO_ADDR
// i := CreateVehicle ;
9035: LD_ADDR_VAR 0 1
9039: PUSH
9040: CALL_OW 45
9044: ST_TO_ADDR
// SetDir ( i , 5 ) ;
9045: LD_VAR 0 1
9049: PPUSH
9050: LD_INT 5
9052: PPUSH
9053: CALL_OW 233
// PlaceUnitXY ( i , 63 , 115 , false ) ;
9057: LD_VAR 0 1
9061: PPUSH
9062: LD_INT 63
9064: PPUSH
9065: LD_INT 115
9067: PPUSH
9068: LD_INT 0
9070: PPUSH
9071: CALL_OW 48
// SetCargo ( i , mat_cans , 200 ) ;
9075: LD_VAR 0 1
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 200
9085: PPUSH
9086: CALL_OW 290
// PrepareHuman ( false , 3 , 5 ) ;
9090: LD_INT 0
9092: PPUSH
9093: LD_INT 3
9095: PPUSH
9096: LD_INT 5
9098: PPUSH
9099: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9103: CALL_OW 44
9107: PPUSH
9108: LD_VAR 0 1
9112: PPUSH
9113: CALL_OW 52
// DialogueOn ;
9117: CALL_OW 6
// CenterNowOnXY ( 169 , 115 ) ;
9121: LD_INT 169
9123: PPUSH
9124: LD_INT 115
9126: PPUSH
9127: CALL_OW 86
// DWait ( 0 0$01 ) ;
9131: LD_INT 35
9133: PPUSH
9134: CALL_OW 68
// CenterNowOnXY ( 63 , 115 ) ;
9138: LD_INT 63
9140: PPUSH
9141: LD_INT 115
9143: PPUSH
9144: CALL_OW 86
// DWait ( 0 0$01 ) ;
9148: LD_INT 35
9150: PPUSH
9151: CALL_OW 68
// DialogueOff ;
9155: CALL_OW 7
// ComMoveXY ( i , 57 , 53 ) ;
9159: LD_VAR 0 1
9163: PPUSH
9164: LD_INT 57
9166: PPUSH
9167: LD_INT 53
9169: PPUSH
9170: CALL_OW 111
// Wait ( Rand ( 3 3$00 , 7 7$00 ) ) ;
9174: LD_INT 6300
9176: PPUSH
9177: LD_INT 14700
9179: PPUSH
9180: CALL_OW 12
9184: PPUSH
9185: CALL_OW 67
// PlaceUnitXY ( Saseda , 86 , 112 , false ) ;
9189: LD_EXP 17
9193: PPUSH
9194: LD_INT 86
9196: PPUSH
9197: LD_INT 112
9199: PPUSH
9200: LD_INT 0
9202: PPUSH
9203: CALL_OW 48
// Wait ( 0 0$0.3 ) ;
9207: LD_INT 10
9209: PPUSH
9210: CALL_OW 67
// SayRadio ( Saseda , DPM_Sa1 ) ;
9214: LD_EXP 17
9218: PPUSH
9219: LD_STRING DPM_Sa1
9221: PPUSH
9222: CALL_OW 94
// ChangeMissionObjectives ( PM_3 ) ;
9226: LD_STRING PM_3
9228: PPUSH
9229: CALL_OW 337
// end ;
9233: PPOPN 1
9235: END
// every 0 0$01 trigger See ( 3 , Saseda ) do
9236: LD_INT 3
9238: PPUSH
9239: LD_EXP 17
9243: PPUSH
9244: CALL_OW 292
9248: IFFALSE 9297
9250: GO 9252
9252: DISABLE
// begin Say ( Saseda , DPM_Sa2 ) ;
9253: LD_EXP 17
9257: PPUSH
9258: LD_STRING DPM_Sa2
9260: PPUSH
9261: CALL_OW 88
// ChangeMissionObjectives ( PM_4 ) ;
9265: LD_STRING PM_4
9267: PPUSH
9268: CALL_OW 337
// SetTech ( tech_rocket , 3 , state_enabled ) ;
9272: LD_INT 40
9274: PPUSH
9275: LD_INT 3
9277: PPUSH
9278: LD_INT 1
9280: PPUSH
9281: CALL_OW 322
// SetSide ( Saseda , 3 ) ;
9285: LD_EXP 17
9289: PPUSH
9290: LD_INT 3
9292: PPUSH
9293: CALL_OW 235
// end ;
9297: END
// every 16 16$00 trigger not medal1 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
9298: LD_EXP 3
9302: NOT
9303: PUSH
9304: LD_INT 22
9306: PUSH
9307: LD_INT 6
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PPUSH
9314: CALL_OW 69
9318: PUSH
9319: LD_INT 0
9321: EQUAL
9322: AND
9323: IFFALSE 9370
9325: GO 9327
9327: DISABLE
// begin Say ( Stolypin , DPM_S3 ) ;
9328: LD_EXP 15
9332: PPUSH
9333: LD_STRING DPM_S3
9335: PPUSH
9336: CALL_OW 88
// PlaceSeeing ( 62 , 113 , 3 , 10 ) ;
9340: LD_INT 62
9342: PPUSH
9343: LD_INT 113
9345: PPUSH
9346: LD_INT 3
9348: PPUSH
9349: LD_INT 10
9351: PPUSH
9352: CALL_OW 330
// CenterOnXY ( 62 , 113 ) ;
9356: LD_INT 62
9358: PPUSH
9359: LD_INT 113
9361: PPUSH
9362: CALL_OW 84
// CounterAttack ;
9366: CALL 5702 0 0
// end ; end_of_file
9370: END
// on LeaveBuilding ( b , h ) do begin if GetSide ( b ) = 1 then
9371: LD_VAR 0 1
9375: PPUSH
9376: CALL_OW 255
9380: PUSH
9381: LD_INT 1
9383: EQUAL
9384: IFFALSE 9420
// if not us_retreat then
9386: LD_EXP 21
9390: NOT
9391: IFFALSE 9420
// if GetClass ( h ) = 1 then
9393: LD_VAR 0 2
9397: PPUSH
9398: CALL_OW 257
9402: PUSH
9403: LD_INT 1
9405: EQUAL
9406: IFFALSE 9420
// ComEnterUnit ( h , us_arm ) ;
9408: LD_VAR 0 2
9412: PPUSH
9413: LD_INT 69
9415: PPUSH
9416: CALL_OW 120
// end ;
9420: PPOPN 2
9422: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
9423: LD_VAR 0 1
9427: PPUSH
9428: CALL 22093 0 1
// if GetSide ( un ) = 1 then
9432: LD_VAR 0 1
9436: PPUSH
9437: CALL_OW 255
9441: PUSH
9442: LD_INT 1
9444: EQUAL
9445: IFFALSE 9461
// us_count := us_count + 1 ;
9447: LD_ADDR_EXP 23
9451: PUSH
9452: LD_EXP 23
9456: PUSH
9457: LD_INT 1
9459: PLUS
9460: ST_TO_ADDR
// if un in us_force then
9461: LD_VAR 0 1
9465: PUSH
9466: LD_EXP 12
9470: IN
9471: IFFALSE 9489
// us_force := us_force diff un ;
9473: LD_ADDR_EXP 12
9477: PUSH
9478: LD_EXP 12
9482: PUSH
9483: LD_VAR 0 1
9487: DIFF
9488: ST_TO_ADDR
// if un in ar_force then
9489: LD_VAR 0 1
9493: PUSH
9494: LD_EXP 11
9498: IN
9499: IFFALSE 9517
// ar_force := ar_force diff un ;
9501: LD_ADDR_EXP 11
9505: PUSH
9506: LD_EXP 11
9510: PUSH
9511: LD_VAR 0 1
9515: DIFF
9516: ST_TO_ADDR
// if un = Stolypin then
9517: LD_VAR 0 1
9521: PUSH
9522: LD_EXP 15
9526: EQUAL
9527: IFFALSE 9536
// YouLost ( dead ) ;
9529: LD_STRING dead
9531: PPUSH
9532: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) then
9536: LD_VAR 0 1
9540: PUSH
9541: LD_INT 22
9543: PUSH
9544: LD_INT 1
9546: PUSH
9547: EMPTY
9548: LIST
9549: LIST
9550: PUSH
9551: LD_INT 30
9553: PUSH
9554: LD_INT 0
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PUSH
9561: EMPTY
9562: LIST
9563: LIST
9564: PPUSH
9565: CALL_OW 69
9569: IN
9570: IFFALSE 9579
// YouLost ( depot ) ;
9572: LD_STRING depot
9574: PPUSH
9575: CALL_OW 104
// if GetSide ( un ) = 6 then
9579: LD_VAR 0 1
9583: PPUSH
9584: CALL_OW 255
9588: PUSH
9589: LD_INT 6
9591: EQUAL
9592: IFFALSE 9608
// dest_counter := dest_counter + 1 ;
9594: LD_ADDR_EXP 8
9598: PUSH
9599: LD_EXP 8
9603: PUSH
9604: LD_INT 1
9606: PLUS
9607: ST_TO_ADDR
// end ;
9608: PPOPN 1
9610: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 1 then
9611: LD_VAR 0 1
9615: PPUSH
9616: CALL_OW 255
9620: PUSH
9621: LD_INT 1
9623: EQUAL
9624: IFFALSE 9641
// ComMoveXY ( un , 57 , 52 ) ;
9626: LD_VAR 0 1
9630: PPUSH
9631: LD_INT 57
9633: PPUSH
9634: LD_INT 52
9636: PPUSH
9637: CALL_OW 111
// end ;
9641: PPOPN 2
9643: END
// on Contact ( s1 , s2 ) do begin if not us_alert then
9644: LD_EXP 20
9648: NOT
9649: IFFALSE 9699
// if ( s1 = 3 and s2 = 1 ) or ( s1 = 1 and s2 = 3 ) then
9651: LD_VAR 0 1
9655: PUSH
9656: LD_INT 3
9658: EQUAL
9659: PUSH
9660: LD_VAR 0 2
9664: PUSH
9665: LD_INT 1
9667: EQUAL
9668: AND
9669: PUSH
9670: LD_VAR 0 1
9674: PUSH
9675: LD_INT 1
9677: EQUAL
9678: PUSH
9679: LD_VAR 0 2
9683: PUSH
9684: LD_INT 3
9686: EQUAL
9687: AND
9688: OR
9689: IFFALSE 9699
// us_alert := true ;
9691: LD_ADDR_EXP 20
9695: PUSH
9696: LD_INT 1
9698: ST_TO_ADDR
// if ( s1 = 6 and s2 = 3 ) or ( s1 = 3 and s2 = 6 ) then
9699: LD_VAR 0 1
9703: PUSH
9704: LD_INT 6
9706: EQUAL
9707: PUSH
9708: LD_VAR 0 2
9712: PUSH
9713: LD_INT 3
9715: EQUAL
9716: AND
9717: PUSH
9718: LD_VAR 0 1
9722: PUSH
9723: LD_INT 3
9725: EQUAL
9726: PUSH
9727: LD_VAR 0 2
9731: PUSH
9732: LD_INT 6
9734: EQUAL
9735: AND
9736: OR
9737: IFFALSE 9746
// YouLost ( alat ) ;
9739: LD_STRING alat
9741: PPUSH
9742: CALL_OW 104
// end ;
9746: PPOPN 2
9748: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_empty ] , [ f_type , unit_vehicle ] ] ) then
9749: LD_VAR 0 1
9753: PPUSH
9754: CALL_OW 255
9758: PUSH
9759: LD_INT 2
9761: EQUAL
9762: PUSH
9763: LD_VAR 0 1
9767: PUSH
9768: LD_INT 58
9770: PUSH
9771: EMPTY
9772: LIST
9773: PUSH
9774: LD_INT 21
9776: PUSH
9777: LD_INT 2
9779: PUSH
9780: EMPTY
9781: LIST
9782: LIST
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: PPUSH
9788: CALL_OW 69
9792: IN
9793: AND
9794: IFFALSE 9915
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 2 then
9796: LD_OWVAR 3
9800: PUSH
9801: LD_VAR 0 1
9805: DIFF
9806: PPUSH
9807: LD_VAR 0 1
9811: PPUSH
9812: CALL_OW 74
9816: PPUSH
9817: CALL_OW 255
9821: PUSH
9822: LD_INT 2
9824: NONEQUAL
9825: IFFALSE 9915
// begin Wait ( 0 0$1.3 ) ;
9827: LD_INT 46
9829: PPUSH
9830: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9834: LD_VAR 0 1
9838: PPUSH
9839: CALL_OW 250
9843: PPUSH
9844: LD_VAR 0 1
9848: PPUSH
9849: CALL_OW 251
9853: PPUSH
9854: LD_INT 1
9856: PPUSH
9857: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9861: LD_VAR 0 1
9865: PPUSH
9866: CALL_OW 250
9870: PPUSH
9871: LD_VAR 0 1
9875: PPUSH
9876: CALL_OW 251
9880: PPUSH
9881: LD_INT 1
9883: PPUSH
9884: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9888: LD_VAR 0 1
9892: PPUSH
9893: CALL_OW 250
9897: PPUSH
9898: LD_VAR 0 1
9902: PPUSH
9903: CALL_OW 251
9907: PPUSH
9908: LD_INT 1
9910: PPUSH
9911: CALL_OW 453
// end ; end ;
9915: PPOPN 1
9917: END
// on EvacuateVehicle ( driver , un , c1 , c2 ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) and not GetSide ( NearestUnit ( un ) ) = 2 then
9918: LD_VAR 0 2
9922: PUSH
9923: LD_INT 22
9925: PUSH
9926: LD_INT 2
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: LD_INT 21
9935: PUSH
9936: LD_INT 2
9938: PUSH
9939: EMPTY
9940: LIST
9941: LIST
9942: PUSH
9943: EMPTY
9944: LIST
9945: LIST
9946: PPUSH
9947: CALL_OW 69
9951: IN
9952: PUSH
9953: LD_VAR 0 2
9957: PPUSH
9958: CALL 10488 0 1
9962: PPUSH
9963: CALL_OW 255
9967: PUSH
9968: LD_INT 2
9970: EQUAL
9971: NOT
9972: AND
9973: IFFALSE 10098
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
9975: LD_INT 105
9977: PPUSH
9978: LD_INT 210
9980: PPUSH
9981: CALL_OW 12
9985: PPUSH
9986: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9990: LD_VAR 0 2
9994: PPUSH
9995: CALL_OW 250
9999: PPUSH
10000: LD_VAR 0 2
10004: PPUSH
10005: CALL_OW 251
10009: PPUSH
10010: LD_INT 3
10012: PPUSH
10013: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10017: LD_VAR 0 2
10021: PPUSH
10022: CALL_OW 250
10026: PPUSH
10027: LD_VAR 0 2
10031: PPUSH
10032: CALL_OW 251
10036: PPUSH
10037: LD_INT 3
10039: PPUSH
10040: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10044: LD_VAR 0 2
10048: PPUSH
10049: CALL_OW 250
10053: PPUSH
10054: LD_VAR 0 2
10058: PPUSH
10059: CALL_OW 251
10063: PPUSH
10064: LD_INT 3
10066: PPUSH
10067: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10071: LD_VAR 0 2
10075: PPUSH
10076: CALL_OW 250
10080: PPUSH
10081: LD_VAR 0 2
10085: PPUSH
10086: CALL_OW 251
10090: PPUSH
10091: LD_INT 3
10093: PPUSH
10094: CALL_OW 453
// end ; end ;
10098: PPOPN 4
10100: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
10101: LD_VAR 0 1
10105: PPUSH
10106: LD_VAR 0 2
10110: PPUSH
10111: LD_VAR 0 3
10115: PPUSH
10116: CALL 22191 0 3
// end ;
10120: PPOPN 3
10122: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10123: LD_VAR 0 1
10127: PPUSH
10128: CALL 22199 0 1
// end ; end_of_file
10132: PPOPN 1
10134: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
10135: LD_INT 0
10137: PPUSH
10138: PPUSH
10139: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
10140: LD_ADDR_VAR 0 7
10144: PUSH
10145: LD_VAR 0 1
10149: PUSH
10150: LD_VAR 0 2
10154: ARRAY
10155: PPUSH
10156: LD_VAR 0 3
10160: PPUSH
10161: LD_VAR 0 4
10165: PPUSH
10166: CALL_OW 1
10170: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
10171: LD_ADDR_VAR 0 1
10175: PUSH
10176: LD_VAR 0 1
10180: PPUSH
10181: LD_VAR 0 2
10185: PPUSH
10186: LD_VAR 0 7
10190: PPUSH
10191: CALL_OW 1
10195: ST_TO_ADDR
// result := tab ;
10196: LD_ADDR_VAR 0 5
10200: PUSH
10201: LD_VAR 0 1
10205: ST_TO_ADDR
// end ;
10206: LD_VAR 0 5
10210: RET
// export function IsDriver ( unit ) ; begin
10211: LD_INT 0
10213: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
10214: LD_VAR 0 1
10218: PUSH
10219: LD_INT 55
10221: PUSH
10222: EMPTY
10223: LIST
10224: PPUSH
10225: CALL_OW 69
10229: IN
10230: IFFALSE 10249
// result := IsInUnit ( unit ) else
10232: LD_ADDR_VAR 0 2
10236: PUSH
10237: LD_VAR 0 1
10241: PPUSH
10242: CALL_OW 310
10246: ST_TO_ADDR
10247: GO 10257
// result := false ;
10249: LD_ADDR_VAR 0 2
10253: PUSH
10254: LD_INT 0
10256: ST_TO_ADDR
// end ;
10257: LD_VAR 0 2
10261: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10262: LD_INT 0
10264: PPUSH
10265: PPUSH
10266: PPUSH
// if not GetControl ( veh ) = control_manual then
10267: LD_VAR 0 1
10271: PPUSH
10272: CALL_OW 263
10276: PUSH
10277: LD_INT 1
10279: EQUAL
10280: NOT
10281: IFFALSE 10293
// result := false else
10283: LD_ADDR_VAR 0 2
10287: PUSH
10288: LD_INT 0
10290: ST_TO_ADDR
10291: GO 10438
// if veh in FilterAllUnits ( [ f_empty ] ) then
10293: LD_VAR 0 1
10297: PUSH
10298: LD_INT 58
10300: PUSH
10301: EMPTY
10302: LIST
10303: PPUSH
10304: CALL_OW 69
10308: IN
10309: IFFALSE 10321
// result := false else
10311: LD_ADDR_VAR 0 2
10315: PUSH
10316: LD_INT 0
10318: ST_TO_ADDR
10319: GO 10438
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10321: LD_ADDR_VAR 0 4
10325: PUSH
10326: LD_INT 22
10328: PUSH
10329: LD_VAR 0 1
10333: PPUSH
10334: CALL_OW 255
10338: PUSH
10339: EMPTY
10340: LIST
10341: LIST
10342: PUSH
10343: LD_INT 55
10345: PUSH
10346: EMPTY
10347: LIST
10348: PUSH
10349: EMPTY
10350: LIST
10351: LIST
10352: PPUSH
10353: CALL_OW 69
10357: ST_TO_ADDR
// if not filter then
10358: LD_VAR 0 4
10362: NOT
10363: IFFALSE 10375
// result := false else
10365: LD_ADDR_VAR 0 2
10369: PUSH
10370: LD_INT 0
10372: ST_TO_ADDR
10373: GO 10438
// for i = 1 to filter do
10375: LD_ADDR_VAR 0 3
10379: PUSH
10380: DOUBLE
10381: LD_INT 1
10383: DEC
10384: ST_TO_ADDR
10385: LD_VAR 0 4
10389: PUSH
10390: FOR_TO
10391: IFFALSE 10436
// if IsDriver ( filter [ i ] ) = veh then
10393: LD_VAR 0 4
10397: PUSH
10398: LD_VAR 0 3
10402: ARRAY
10403: PPUSH
10404: CALL 10211 0 1
10408: PUSH
10409: LD_VAR 0 1
10413: EQUAL
10414: IFFALSE 10434
// begin result := filter [ i ] ;
10416: LD_ADDR_VAR 0 2
10420: PUSH
10421: LD_VAR 0 4
10425: PUSH
10426: LD_VAR 0 3
10430: ARRAY
10431: ST_TO_ADDR
// break ;
10432: GO 10436
// end ;
10434: GO 10390
10436: POP
10437: POP
// end ; end ;
10438: LD_VAR 0 2
10442: RET
// export function FindTarget ( unit ) ; begin
10443: LD_INT 0
10445: PPUSH
// result := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ;
10446: LD_ADDR_VAR 0 2
10450: PUSH
10451: LD_INT 81
10453: PUSH
10454: LD_VAR 0 1
10458: PPUSH
10459: CALL_OW 255
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: PPUSH
10468: CALL_OW 69
10472: PPUSH
10473: LD_VAR 0 1
10477: PPUSH
10478: CALL_OW 74
10482: ST_TO_ADDR
// end ;
10483: LD_VAR 0 2
10487: RET
// export function NearestUnit ( unit ) ; begin
10488: LD_INT 0
10490: PPUSH
// result := NearestUnitToUnit ( all_units diff unit , unit ) ;
10491: LD_ADDR_VAR 0 2
10495: PUSH
10496: LD_OWVAR 3
10500: PUSH
10501: LD_VAR 0 1
10505: DIFF
10506: PPUSH
10507: LD_VAR 0 1
10511: PPUSH
10512: CALL_OW 74
10516: ST_TO_ADDR
// end ; end_of_file
10517: LD_VAR 0 2
10521: RET
// every 12 12$00 do
10522: GO 10524
10524: DISABLE
// begin SetWeather ( 1 , 570 , 350 ) ;
10525: LD_INT 1
10527: PPUSH
10528: LD_INT 570
10530: PPUSH
10531: LD_INT 350
10533: PPUSH
10534: CALL_OW 550
// Wait ( Rand ( 5 5$00 , 10 10$00 ) ) ;
10538: LD_INT 10500
10540: PPUSH
10541: LD_INT 21000
10543: PPUSH
10544: CALL_OW 12
10548: PPUSH
10549: CALL_OW 67
// SetWeather ( 0 , 570 , 350 ) ;
10553: LD_INT 0
10555: PPUSH
10556: LD_INT 570
10558: PPUSH
10559: LD_INT 350
10561: PPUSH
10562: CALL_OW 550
// end ;
10566: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
10567: LD_INT 0
10569: PPUSH
10570: PPUSH
10571: PPUSH
10572: PPUSH
10573: PPUSH
// uc_nation = nation_nature ;
10574: LD_ADDR_OWVAR 21
10578: PUSH
10579: LD_INT 0
10581: ST_TO_ADDR
// uc_side = 0 ;
10582: LD_ADDR_OWVAR 20
10586: PUSH
10587: LD_INT 0
10589: ST_TO_ADDR
// l = 0 ;
10590: LD_ADDR_VAR 0 6
10594: PUSH
10595: LD_INT 0
10597: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
10598: LD_ADDR_OWVAR 24
10602: PUSH
10603: LD_INT 0
10605: PPUSH
10606: LD_INT 5
10608: PPUSH
10609: CALL_OW 12
10613: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
10614: LD_ADDR_OWVAR 35
10618: PUSH
10619: LD_INT 5
10621: NEG
10622: PPUSH
10623: LD_INT 5
10625: PPUSH
10626: CALL_OW 12
10630: ST_TO_ADDR
// hc_gallery =  ;
10631: LD_ADDR_OWVAR 33
10635: PUSH
10636: LD_STRING 
10638: ST_TO_ADDR
// hc_class = class_apeman ;
10639: LD_ADDR_OWVAR 28
10643: PUSH
10644: LD_INT 12
10646: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
10647: LD_ADDR_OWVAR 29
10651: PUSH
10652: LD_INT 11
10654: PPUSH
10655: LD_INT 13
10657: PPUSH
10658: CALL_OW 12
10662: PUSH
10663: LD_INT 10
10665: PPUSH
10666: LD_INT 11
10668: PPUSH
10669: CALL_OW 12
10673: PUSH
10674: EMPTY
10675: LIST
10676: LIST
10677: ST_TO_ADDR
// hc_sex = sex_male ;
10678: LD_ADDR_OWVAR 27
10682: PUSH
10683: LD_INT 1
10685: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
10686: LD_ADDR_OWVAR 31
10690: PUSH
10691: LD_INT 0
10693: PPUSH
10694: LD_INT 2
10696: PPUSH
10697: CALL_OW 12
10701: PUSH
10702: LD_INT 0
10704: PUSH
10705: LD_INT 0
10707: PUSH
10708: LD_INT 0
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: LIST
10715: LIST
10716: ST_TO_ADDR
// apeman = CreateHuman ;
10717: LD_ADDR_VAR 0 7
10721: PUSH
10722: CALL_OW 44
10726: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
10727: LD_VAR 0 7
10731: PPUSH
10732: LD_VAR 0 4
10736: PPUSH
10737: LD_INT 0
10739: PPUSH
10740: CALL_OW 49
// l = l + 1 ;
10744: LD_ADDR_VAR 0 6
10748: PUSH
10749: LD_VAR 0 6
10753: PUSH
10754: LD_INT 1
10756: PLUS
10757: ST_TO_ADDR
// end until l = num1 ;
10758: LD_VAR 0 6
10762: PUSH
10763: LD_VAR 0 1
10767: EQUAL
10768: IFFALSE 10598
// l = 0 ;
10770: LD_ADDR_VAR 0 6
10774: PUSH
10775: LD_INT 0
10777: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
10778: LD_ADDR_OWVAR 35
10782: PUSH
10783: LD_INT 0
10785: PPUSH
10786: LD_INT 25
10788: PPUSH
10789: CALL_OW 12
10793: ST_TO_ADDR
// hc_class = class_tiger ;
10794: LD_ADDR_OWVAR 28
10798: PUSH
10799: LD_INT 14
10801: ST_TO_ADDR
// hc_sex = sex_male ;
10802: LD_ADDR_OWVAR 27
10806: PUSH
10807: LD_INT 1
10809: ST_TO_ADDR
// hc_gallery = sandnature ;
10810: LD_ADDR_OWVAR 33
10814: PUSH
10815: LD_STRING sandnature
10817: ST_TO_ADDR
// hc_face_number = 3 ;
10818: LD_ADDR_OWVAR 34
10822: PUSH
10823: LD_INT 3
10825: ST_TO_ADDR
// tiger = CreateHuman ;
10826: LD_ADDR_VAR 0 8
10830: PUSH
10831: CALL_OW 44
10835: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10836: LD_VAR 0 8
10840: PPUSH
10841: LD_VAR 0 4
10845: PPUSH
10846: LD_INT 0
10848: PPUSH
10849: CALL_OW 49
// l = l + 1 ;
10853: LD_ADDR_VAR 0 6
10857: PUSH
10858: LD_VAR 0 6
10862: PUSH
10863: LD_INT 1
10865: PLUS
10866: ST_TO_ADDR
// end until l = num2 ;
10867: LD_VAR 0 6
10871: PUSH
10872: LD_VAR 0 2
10876: EQUAL
10877: IFFALSE 10778
// l = 0 ;
10879: LD_ADDR_VAR 0 6
10883: PUSH
10884: LD_INT 0
10886: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
10887: LD_ADDR_OWVAR 28
10891: PUSH
10892: LD_INT 18
10894: ST_TO_ADDR
// hc_gallery = sandnature ;
10895: LD_ADDR_OWVAR 33
10899: PUSH
10900: LD_STRING sandnature
10902: ST_TO_ADDR
// hc_face_number = 1 ;
10903: LD_ADDR_OWVAR 34
10907: PUSH
10908: LD_INT 1
10910: ST_TO_ADDR
// bird = CreateHuman ;
10911: LD_ADDR_VAR 0 9
10915: PUSH
10916: CALL_OW 44
10920: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
10921: LD_VAR 0 9
10925: PPUSH
10926: LD_INT 0
10928: PPUSH
10929: CALL_OW 51
// l = l + 1 ;
10933: LD_ADDR_VAR 0 6
10937: PUSH
10938: LD_VAR 0 6
10942: PUSH
10943: LD_INT 1
10945: PLUS
10946: ST_TO_ADDR
// end until l = num3 ;
10947: LD_VAR 0 6
10951: PUSH
10952: LD_VAR 0 3
10956: EQUAL
10957: IFFALSE 10887
// end ; end_of_file
10959: LD_VAR 0 5
10963: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
10964: GO 10966
10966: DISABLE
// begin ru_radar := 98 ;
10967: LD_ADDR_EXP 25
10971: PUSH
10972: LD_INT 98
10974: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10975: LD_ADDR_EXP 26
10979: PUSH
10980: LD_INT 89
10982: ST_TO_ADDR
// us_hack := 99 ;
10983: LD_ADDR_EXP 27
10987: PUSH
10988: LD_INT 99
10990: ST_TO_ADDR
// us_artillery := 97 ;
10991: LD_ADDR_EXP 28
10995: PUSH
10996: LD_INT 97
10998: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10999: LD_ADDR_EXP 29
11003: PUSH
11004: LD_INT 91
11006: ST_TO_ADDR
// tech_Artillery := 80 ;
11007: LD_ADDR_EXP 30
11011: PUSH
11012: LD_INT 80
11014: ST_TO_ADDR
// tech_RadMat := 81 ;
11015: LD_ADDR_EXP 31
11019: PUSH
11020: LD_INT 81
11022: ST_TO_ADDR
// tech_BasicTools := 82 ;
11023: LD_ADDR_EXP 32
11027: PUSH
11028: LD_INT 82
11030: ST_TO_ADDR
// tech_Cargo := 83 ;
11031: LD_ADDR_EXP 33
11035: PUSH
11036: LD_INT 83
11038: ST_TO_ADDR
// tech_Track := 84 ;
11039: LD_ADDR_EXP 34
11043: PUSH
11044: LD_INT 84
11046: ST_TO_ADDR
// tech_Crane := 85 ;
11047: LD_ADDR_EXP 35
11051: PUSH
11052: LD_INT 85
11054: ST_TO_ADDR
// tech_Bulldozer := 86 ;
11055: LD_ADDR_EXP 36
11059: PUSH
11060: LD_INT 86
11062: ST_TO_ADDR
// tech_Hovercraft := 87 ;
11063: LD_ADDR_EXP 37
11067: PUSH
11068: LD_INT 87
11070: ST_TO_ADDR
// end ; end_of_file end_of_file
11071: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
11072: GO 11074
11074: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11075: LD_STRING initStreamRollete();
11077: PPUSH
11078: CALL_OW 559
// InitStreamMode ;
11082: CALL 11091 0 0
// DefineStreamItems ( ) ;
11086: CALL 11531 0 0
// end ;
11090: END
// function InitStreamMode ; begin
11091: LD_INT 0
11093: PPUSH
// streamModeActive := false ;
11094: LD_ADDR_EXP 38
11098: PUSH
11099: LD_INT 0
11101: ST_TO_ADDR
// normalCounter := 36 ;
11102: LD_ADDR_EXP 39
11106: PUSH
11107: LD_INT 36
11109: ST_TO_ADDR
// hardcoreCounter := 16 ;
11110: LD_ADDR_EXP 40
11114: PUSH
11115: LD_INT 16
11117: ST_TO_ADDR
// sRocket := false ;
11118: LD_ADDR_EXP 43
11122: PUSH
11123: LD_INT 0
11125: ST_TO_ADDR
// sSpeed := false ;
11126: LD_ADDR_EXP 42
11130: PUSH
11131: LD_INT 0
11133: ST_TO_ADDR
// sEngine := false ;
11134: LD_ADDR_EXP 44
11138: PUSH
11139: LD_INT 0
11141: ST_TO_ADDR
// sSpec := false ;
11142: LD_ADDR_EXP 41
11146: PUSH
11147: LD_INT 0
11149: ST_TO_ADDR
// sLevel := false ;
11150: LD_ADDR_EXP 45
11154: PUSH
11155: LD_INT 0
11157: ST_TO_ADDR
// sArmoury := false ;
11158: LD_ADDR_EXP 46
11162: PUSH
11163: LD_INT 0
11165: ST_TO_ADDR
// sRadar := false ;
11166: LD_ADDR_EXP 47
11170: PUSH
11171: LD_INT 0
11173: ST_TO_ADDR
// sBunker := false ;
11174: LD_ADDR_EXP 48
11178: PUSH
11179: LD_INT 0
11181: ST_TO_ADDR
// sHack := false ;
11182: LD_ADDR_EXP 49
11186: PUSH
11187: LD_INT 0
11189: ST_TO_ADDR
// sFire := false ;
11190: LD_ADDR_EXP 50
11194: PUSH
11195: LD_INT 0
11197: ST_TO_ADDR
// sRefresh := false ;
11198: LD_ADDR_EXP 51
11202: PUSH
11203: LD_INT 0
11205: ST_TO_ADDR
// sExp := false ;
11206: LD_ADDR_EXP 52
11210: PUSH
11211: LD_INT 0
11213: ST_TO_ADDR
// sDepot := false ;
11214: LD_ADDR_EXP 53
11218: PUSH
11219: LD_INT 0
11221: ST_TO_ADDR
// sFlag := false ;
11222: LD_ADDR_EXP 54
11226: PUSH
11227: LD_INT 0
11229: ST_TO_ADDR
// sKamikadze := false ;
11230: LD_ADDR_EXP 62
11234: PUSH
11235: LD_INT 0
11237: ST_TO_ADDR
// sTroll := false ;
11238: LD_ADDR_EXP 63
11242: PUSH
11243: LD_INT 0
11245: ST_TO_ADDR
// sSlow := false ;
11246: LD_ADDR_EXP 64
11250: PUSH
11251: LD_INT 0
11253: ST_TO_ADDR
// sLack := false ;
11254: LD_ADDR_EXP 65
11258: PUSH
11259: LD_INT 0
11261: ST_TO_ADDR
// sTank := false ;
11262: LD_ADDR_EXP 67
11266: PUSH
11267: LD_INT 0
11269: ST_TO_ADDR
// sRemote := false ;
11270: LD_ADDR_EXP 68
11274: PUSH
11275: LD_INT 0
11277: ST_TO_ADDR
// sPowell := false ;
11278: LD_ADDR_EXP 69
11282: PUSH
11283: LD_INT 0
11285: ST_TO_ADDR
// sTeleport := false ;
11286: LD_ADDR_EXP 72
11290: PUSH
11291: LD_INT 0
11293: ST_TO_ADDR
// sOilTower := false ;
11294: LD_ADDR_EXP 74
11298: PUSH
11299: LD_INT 0
11301: ST_TO_ADDR
// sShovel := false ;
11302: LD_ADDR_EXP 75
11306: PUSH
11307: LD_INT 0
11309: ST_TO_ADDR
// sSheik := false ;
11310: LD_ADDR_EXP 76
11314: PUSH
11315: LD_INT 0
11317: ST_TO_ADDR
// sEarthquake := false ;
11318: LD_ADDR_EXP 78
11322: PUSH
11323: LD_INT 0
11325: ST_TO_ADDR
// sAI := false ;
11326: LD_ADDR_EXP 79
11330: PUSH
11331: LD_INT 0
11333: ST_TO_ADDR
// sCargo := false ;
11334: LD_ADDR_EXP 82
11338: PUSH
11339: LD_INT 0
11341: ST_TO_ADDR
// sDLaser := false ;
11342: LD_ADDR_EXP 83
11346: PUSH
11347: LD_INT 0
11349: ST_TO_ADDR
// sExchange := false ;
11350: LD_ADDR_EXP 84
11354: PUSH
11355: LD_INT 0
11357: ST_TO_ADDR
// sFac := false ;
11358: LD_ADDR_EXP 85
11362: PUSH
11363: LD_INT 0
11365: ST_TO_ADDR
// sPower := false ;
11366: LD_ADDR_EXP 86
11370: PUSH
11371: LD_INT 0
11373: ST_TO_ADDR
// sRandom := false ;
11374: LD_ADDR_EXP 87
11378: PUSH
11379: LD_INT 0
11381: ST_TO_ADDR
// sShield := false ;
11382: LD_ADDR_EXP 88
11386: PUSH
11387: LD_INT 0
11389: ST_TO_ADDR
// sTime := false ;
11390: LD_ADDR_EXP 89
11394: PUSH
11395: LD_INT 0
11397: ST_TO_ADDR
// sTools := false ;
11398: LD_ADDR_EXP 90
11402: PUSH
11403: LD_INT 0
11405: ST_TO_ADDR
// sSold := false ;
11406: LD_ADDR_EXP 55
11410: PUSH
11411: LD_INT 0
11413: ST_TO_ADDR
// sDiff := false ;
11414: LD_ADDR_EXP 56
11418: PUSH
11419: LD_INT 0
11421: ST_TO_ADDR
// sFog := false ;
11422: LD_ADDR_EXP 59
11426: PUSH
11427: LD_INT 0
11429: ST_TO_ADDR
// sReset := false ;
11430: LD_ADDR_EXP 60
11434: PUSH
11435: LD_INT 0
11437: ST_TO_ADDR
// sSun := false ;
11438: LD_ADDR_EXP 61
11442: PUSH
11443: LD_INT 0
11445: ST_TO_ADDR
// sTiger := false ;
11446: LD_ADDR_EXP 57
11450: PUSH
11451: LD_INT 0
11453: ST_TO_ADDR
// sBomb := false ;
11454: LD_ADDR_EXP 58
11458: PUSH
11459: LD_INT 0
11461: ST_TO_ADDR
// sWound := false ;
11462: LD_ADDR_EXP 66
11466: PUSH
11467: LD_INT 0
11469: ST_TO_ADDR
// sBetray := false ;
11470: LD_ADDR_EXP 70
11474: PUSH
11475: LD_INT 0
11477: ST_TO_ADDR
// sContamin := false ;
11478: LD_ADDR_EXP 71
11482: PUSH
11483: LD_INT 0
11485: ST_TO_ADDR
// sOil := false ;
11486: LD_ADDR_EXP 73
11490: PUSH
11491: LD_INT 0
11493: ST_TO_ADDR
// sStu := false ;
11494: LD_ADDR_EXP 77
11498: PUSH
11499: LD_INT 0
11501: ST_TO_ADDR
// sBazooka := false ;
11502: LD_ADDR_EXP 80
11506: PUSH
11507: LD_INT 0
11509: ST_TO_ADDR
// sMortar := false ;
11510: LD_ADDR_EXP 81
11514: PUSH
11515: LD_INT 0
11517: ST_TO_ADDR
// sRanger := false ;
11518: LD_ADDR_EXP 91
11522: PUSH
11523: LD_INT 0
11525: ST_TO_ADDR
// end ;
11526: LD_VAR 0 1
11530: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11531: LD_INT 0
11533: PPUSH
11534: PPUSH
11535: PPUSH
11536: PPUSH
11537: PPUSH
// result := [ ] ;
11538: LD_ADDR_VAR 0 1
11542: PUSH
11543: EMPTY
11544: ST_TO_ADDR
// if campaign_id = 1 then
11545: LD_OWVAR 69
11549: PUSH
11550: LD_INT 1
11552: EQUAL
11553: IFFALSE 14491
// begin case mission_number of 1 :
11555: LD_OWVAR 70
11559: PUSH
11560: LD_INT 1
11562: DOUBLE
11563: EQUAL
11564: IFTRUE 11568
11566: GO 11632
11568: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11569: LD_ADDR_VAR 0 1
11573: PUSH
11574: LD_INT 2
11576: PUSH
11577: LD_INT 4
11579: PUSH
11580: LD_INT 11
11582: PUSH
11583: LD_INT 12
11585: PUSH
11586: LD_INT 15
11588: PUSH
11589: LD_INT 16
11591: PUSH
11592: LD_INT 22
11594: PUSH
11595: LD_INT 23
11597: PUSH
11598: LD_INT 26
11600: PUSH
11601: EMPTY
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: LD_INT 101
11614: PUSH
11615: LD_INT 102
11617: PUSH
11618: LD_INT 106
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: LIST
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: ST_TO_ADDR
11630: GO 14489
11632: LD_INT 2
11634: DOUBLE
11635: EQUAL
11636: IFTRUE 11640
11638: GO 11712
11640: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11641: LD_ADDR_VAR 0 1
11645: PUSH
11646: LD_INT 2
11648: PUSH
11649: LD_INT 4
11651: PUSH
11652: LD_INT 11
11654: PUSH
11655: LD_INT 12
11657: PUSH
11658: LD_INT 15
11660: PUSH
11661: LD_INT 16
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 23
11669: PUSH
11670: LD_INT 26
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: LIST
11682: LIST
11683: PUSH
11684: LD_INT 101
11686: PUSH
11687: LD_INT 102
11689: PUSH
11690: LD_INT 105
11692: PUSH
11693: LD_INT 106
11695: PUSH
11696: LD_INT 108
11698: PUSH
11699: EMPTY
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: ST_TO_ADDR
11710: GO 14489
11712: LD_INT 3
11714: DOUBLE
11715: EQUAL
11716: IFTRUE 11720
11718: GO 11796
11720: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11721: LD_ADDR_VAR 0 1
11725: PUSH
11726: LD_INT 2
11728: PUSH
11729: LD_INT 4
11731: PUSH
11732: LD_INT 5
11734: PUSH
11735: LD_INT 11
11737: PUSH
11738: LD_INT 12
11740: PUSH
11741: LD_INT 15
11743: PUSH
11744: LD_INT 16
11746: PUSH
11747: LD_INT 22
11749: PUSH
11750: LD_INT 26
11752: PUSH
11753: LD_INT 36
11755: PUSH
11756: EMPTY
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: PUSH
11768: LD_INT 101
11770: PUSH
11771: LD_INT 102
11773: PUSH
11774: LD_INT 105
11776: PUSH
11777: LD_INT 106
11779: PUSH
11780: LD_INT 108
11782: PUSH
11783: EMPTY
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: PUSH
11790: EMPTY
11791: LIST
11792: LIST
11793: ST_TO_ADDR
11794: GO 14489
11796: LD_INT 4
11798: DOUBLE
11799: EQUAL
11800: IFTRUE 11804
11802: GO 11888
11804: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11805: LD_ADDR_VAR 0 1
11809: PUSH
11810: LD_INT 2
11812: PUSH
11813: LD_INT 4
11815: PUSH
11816: LD_INT 5
11818: PUSH
11819: LD_INT 8
11821: PUSH
11822: LD_INT 11
11824: PUSH
11825: LD_INT 12
11827: PUSH
11828: LD_INT 15
11830: PUSH
11831: LD_INT 16
11833: PUSH
11834: LD_INT 22
11836: PUSH
11837: LD_INT 23
11839: PUSH
11840: LD_INT 26
11842: PUSH
11843: LD_INT 36
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 101
11862: PUSH
11863: LD_INT 102
11865: PUSH
11866: LD_INT 105
11868: PUSH
11869: LD_INT 106
11871: PUSH
11872: LD_INT 108
11874: PUSH
11875: EMPTY
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: PUSH
11882: EMPTY
11883: LIST
11884: LIST
11885: ST_TO_ADDR
11886: GO 14489
11888: LD_INT 5
11890: DOUBLE
11891: EQUAL
11892: IFTRUE 11896
11894: GO 11996
11896: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
11897: LD_ADDR_VAR 0 1
11901: PUSH
11902: LD_INT 2
11904: PUSH
11905: LD_INT 4
11907: PUSH
11908: LD_INT 5
11910: PUSH
11911: LD_INT 6
11913: PUSH
11914: LD_INT 8
11916: PUSH
11917: LD_INT 11
11919: PUSH
11920: LD_INT 12
11922: PUSH
11923: LD_INT 15
11925: PUSH
11926: LD_INT 16
11928: PUSH
11929: LD_INT 22
11931: PUSH
11932: LD_INT 23
11934: PUSH
11935: LD_INT 25
11937: PUSH
11938: LD_INT 26
11940: PUSH
11941: LD_INT 36
11943: PUSH
11944: EMPTY
11945: LIST
11946: LIST
11947: LIST
11948: LIST
11949: LIST
11950: LIST
11951: LIST
11952: LIST
11953: LIST
11954: LIST
11955: LIST
11956: LIST
11957: LIST
11958: LIST
11959: PUSH
11960: LD_INT 101
11962: PUSH
11963: LD_INT 102
11965: PUSH
11966: LD_INT 105
11968: PUSH
11969: LD_INT 106
11971: PUSH
11972: LD_INT 108
11974: PUSH
11975: LD_INT 109
11977: PUSH
11978: LD_INT 112
11980: PUSH
11981: EMPTY
11982: LIST
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: PUSH
11990: EMPTY
11991: LIST
11992: LIST
11993: ST_TO_ADDR
11994: GO 14489
11996: LD_INT 6
11998: DOUBLE
11999: EQUAL
12000: IFTRUE 12004
12002: GO 12124
12004: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
12005: LD_ADDR_VAR 0 1
12009: PUSH
12010: LD_INT 2
12012: PUSH
12013: LD_INT 4
12015: PUSH
12016: LD_INT 5
12018: PUSH
12019: LD_INT 6
12021: PUSH
12022: LD_INT 8
12024: PUSH
12025: LD_INT 11
12027: PUSH
12028: LD_INT 12
12030: PUSH
12031: LD_INT 15
12033: PUSH
12034: LD_INT 16
12036: PUSH
12037: LD_INT 20
12039: PUSH
12040: LD_INT 21
12042: PUSH
12043: LD_INT 22
12045: PUSH
12046: LD_INT 23
12048: PUSH
12049: LD_INT 25
12051: PUSH
12052: LD_INT 26
12054: PUSH
12055: LD_INT 30
12057: PUSH
12058: LD_INT 31
12060: PUSH
12061: LD_INT 32
12063: PUSH
12064: LD_INT 36
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: LIST
12071: LIST
12072: LIST
12073: LIST
12074: LIST
12075: LIST
12076: LIST
12077: LIST
12078: LIST
12079: LIST
12080: LIST
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: PUSH
12088: LD_INT 101
12090: PUSH
12091: LD_INT 102
12093: PUSH
12094: LD_INT 105
12096: PUSH
12097: LD_INT 106
12099: PUSH
12100: LD_INT 108
12102: PUSH
12103: LD_INT 109
12105: PUSH
12106: LD_INT 112
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: LIST
12113: LIST
12114: LIST
12115: LIST
12116: LIST
12117: PUSH
12118: EMPTY
12119: LIST
12120: LIST
12121: ST_TO_ADDR
12122: GO 14489
12124: LD_INT 7
12126: DOUBLE
12127: EQUAL
12128: IFTRUE 12132
12130: GO 12232
12132: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12133: LD_ADDR_VAR 0 1
12137: PUSH
12138: LD_INT 2
12140: PUSH
12141: LD_INT 4
12143: PUSH
12144: LD_INT 5
12146: PUSH
12147: LD_INT 7
12149: PUSH
12150: LD_INT 11
12152: PUSH
12153: LD_INT 12
12155: PUSH
12156: LD_INT 15
12158: PUSH
12159: LD_INT 16
12161: PUSH
12162: LD_INT 20
12164: PUSH
12165: LD_INT 21
12167: PUSH
12168: LD_INT 22
12170: PUSH
12171: LD_INT 23
12173: PUSH
12174: LD_INT 25
12176: PUSH
12177: LD_INT 26
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: LIST
12184: LIST
12185: LIST
12186: LIST
12187: LIST
12188: LIST
12189: LIST
12190: LIST
12191: LIST
12192: LIST
12193: LIST
12194: LIST
12195: PUSH
12196: LD_INT 101
12198: PUSH
12199: LD_INT 102
12201: PUSH
12202: LD_INT 103
12204: PUSH
12205: LD_INT 105
12207: PUSH
12208: LD_INT 106
12210: PUSH
12211: LD_INT 108
12213: PUSH
12214: LD_INT 112
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: LIST
12221: LIST
12222: LIST
12223: LIST
12224: LIST
12225: PUSH
12226: EMPTY
12227: LIST
12228: LIST
12229: ST_TO_ADDR
12230: GO 14489
12232: LD_INT 8
12234: DOUBLE
12235: EQUAL
12236: IFTRUE 12240
12238: GO 12368
12240: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12241: LD_ADDR_VAR 0 1
12245: PUSH
12246: LD_INT 2
12248: PUSH
12249: LD_INT 4
12251: PUSH
12252: LD_INT 5
12254: PUSH
12255: LD_INT 6
12257: PUSH
12258: LD_INT 7
12260: PUSH
12261: LD_INT 8
12263: PUSH
12264: LD_INT 11
12266: PUSH
12267: LD_INT 12
12269: PUSH
12270: LD_INT 15
12272: PUSH
12273: LD_INT 16
12275: PUSH
12276: LD_INT 20
12278: PUSH
12279: LD_INT 21
12281: PUSH
12282: LD_INT 22
12284: PUSH
12285: LD_INT 23
12287: PUSH
12288: LD_INT 25
12290: PUSH
12291: LD_INT 26
12293: PUSH
12294: LD_INT 30
12296: PUSH
12297: LD_INT 31
12299: PUSH
12300: LD_INT 32
12302: PUSH
12303: LD_INT 36
12305: PUSH
12306: EMPTY
12307: LIST
12308: LIST
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 101
12330: PUSH
12331: LD_INT 102
12333: PUSH
12334: LD_INT 103
12336: PUSH
12337: LD_INT 105
12339: PUSH
12340: LD_INT 106
12342: PUSH
12343: LD_INT 108
12345: PUSH
12346: LD_INT 109
12348: PUSH
12349: LD_INT 112
12351: PUSH
12352: EMPTY
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: PUSH
12362: EMPTY
12363: LIST
12364: LIST
12365: ST_TO_ADDR
12366: GO 14489
12368: LD_INT 9
12370: DOUBLE
12371: EQUAL
12372: IFTRUE 12376
12374: GO 12512
12376: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12377: LD_ADDR_VAR 0 1
12381: PUSH
12382: LD_INT 2
12384: PUSH
12385: LD_INT 4
12387: PUSH
12388: LD_INT 5
12390: PUSH
12391: LD_INT 6
12393: PUSH
12394: LD_INT 7
12396: PUSH
12397: LD_INT 8
12399: PUSH
12400: LD_INT 11
12402: PUSH
12403: LD_INT 12
12405: PUSH
12406: LD_INT 15
12408: PUSH
12409: LD_INT 16
12411: PUSH
12412: LD_INT 20
12414: PUSH
12415: LD_INT 21
12417: PUSH
12418: LD_INT 22
12420: PUSH
12421: LD_INT 23
12423: PUSH
12424: LD_INT 25
12426: PUSH
12427: LD_INT 26
12429: PUSH
12430: LD_INT 28
12432: PUSH
12433: LD_INT 30
12435: PUSH
12436: LD_INT 31
12438: PUSH
12439: LD_INT 32
12441: PUSH
12442: LD_INT 36
12444: PUSH
12445: EMPTY
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: LIST
12456: LIST
12457: LIST
12458: LIST
12459: LIST
12460: LIST
12461: LIST
12462: LIST
12463: LIST
12464: LIST
12465: LIST
12466: LIST
12467: PUSH
12468: LD_INT 101
12470: PUSH
12471: LD_INT 102
12473: PUSH
12474: LD_INT 103
12476: PUSH
12477: LD_INT 105
12479: PUSH
12480: LD_INT 106
12482: PUSH
12483: LD_INT 108
12485: PUSH
12486: LD_INT 109
12488: PUSH
12489: LD_INT 112
12491: PUSH
12492: LD_INT 114
12494: PUSH
12495: EMPTY
12496: LIST
12497: LIST
12498: LIST
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: ST_TO_ADDR
12510: GO 14489
12512: LD_INT 10
12514: DOUBLE
12515: EQUAL
12516: IFTRUE 12520
12518: GO 12704
12520: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12521: LD_ADDR_VAR 0 1
12525: PUSH
12526: LD_INT 2
12528: PUSH
12529: LD_INT 4
12531: PUSH
12532: LD_INT 5
12534: PUSH
12535: LD_INT 6
12537: PUSH
12538: LD_INT 7
12540: PUSH
12541: LD_INT 8
12543: PUSH
12544: LD_INT 9
12546: PUSH
12547: LD_INT 10
12549: PUSH
12550: LD_INT 11
12552: PUSH
12553: LD_INT 12
12555: PUSH
12556: LD_INT 13
12558: PUSH
12559: LD_INT 14
12561: PUSH
12562: LD_INT 15
12564: PUSH
12565: LD_INT 16
12567: PUSH
12568: LD_INT 17
12570: PUSH
12571: LD_INT 18
12573: PUSH
12574: LD_INT 19
12576: PUSH
12577: LD_INT 20
12579: PUSH
12580: LD_INT 21
12582: PUSH
12583: LD_INT 22
12585: PUSH
12586: LD_INT 23
12588: PUSH
12589: LD_INT 24
12591: PUSH
12592: LD_INT 25
12594: PUSH
12595: LD_INT 26
12597: PUSH
12598: LD_INT 28
12600: PUSH
12601: LD_INT 30
12603: PUSH
12604: LD_INT 31
12606: PUSH
12607: LD_INT 32
12609: PUSH
12610: LD_INT 36
12612: PUSH
12613: EMPTY
12614: LIST
12615: LIST
12616: LIST
12617: LIST
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: LIST
12632: LIST
12633: LIST
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: LIST
12639: LIST
12640: LIST
12641: LIST
12642: LIST
12643: PUSH
12644: LD_INT 101
12646: PUSH
12647: LD_INT 102
12649: PUSH
12650: LD_INT 103
12652: PUSH
12653: LD_INT 104
12655: PUSH
12656: LD_INT 105
12658: PUSH
12659: LD_INT 106
12661: PUSH
12662: LD_INT 107
12664: PUSH
12665: LD_INT 108
12667: PUSH
12668: LD_INT 109
12670: PUSH
12671: LD_INT 110
12673: PUSH
12674: LD_INT 111
12676: PUSH
12677: LD_INT 112
12679: PUSH
12680: LD_INT 114
12682: PUSH
12683: EMPTY
12684: LIST
12685: LIST
12686: LIST
12687: LIST
12688: LIST
12689: LIST
12690: LIST
12691: LIST
12692: LIST
12693: LIST
12694: LIST
12695: LIST
12696: LIST
12697: PUSH
12698: EMPTY
12699: LIST
12700: LIST
12701: ST_TO_ADDR
12702: GO 14489
12704: LD_INT 11
12706: DOUBLE
12707: EQUAL
12708: IFTRUE 12712
12710: GO 12904
12712: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12713: LD_ADDR_VAR 0 1
12717: PUSH
12718: LD_INT 2
12720: PUSH
12721: LD_INT 3
12723: PUSH
12724: LD_INT 4
12726: PUSH
12727: LD_INT 5
12729: PUSH
12730: LD_INT 6
12732: PUSH
12733: LD_INT 7
12735: PUSH
12736: LD_INT 8
12738: PUSH
12739: LD_INT 9
12741: PUSH
12742: LD_INT 10
12744: PUSH
12745: LD_INT 11
12747: PUSH
12748: LD_INT 12
12750: PUSH
12751: LD_INT 13
12753: PUSH
12754: LD_INT 14
12756: PUSH
12757: LD_INT 15
12759: PUSH
12760: LD_INT 16
12762: PUSH
12763: LD_INT 17
12765: PUSH
12766: LD_INT 18
12768: PUSH
12769: LD_INT 19
12771: PUSH
12772: LD_INT 20
12774: PUSH
12775: LD_INT 21
12777: PUSH
12778: LD_INT 22
12780: PUSH
12781: LD_INT 23
12783: PUSH
12784: LD_INT 24
12786: PUSH
12787: LD_INT 25
12789: PUSH
12790: LD_INT 26
12792: PUSH
12793: LD_INT 28
12795: PUSH
12796: LD_INT 30
12798: PUSH
12799: LD_INT 31
12801: PUSH
12802: LD_INT 32
12804: PUSH
12805: LD_INT 34
12807: PUSH
12808: LD_INT 36
12810: PUSH
12811: EMPTY
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: LIST
12830: LIST
12831: LIST
12832: LIST
12833: LIST
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: PUSH
12844: LD_INT 101
12846: PUSH
12847: LD_INT 102
12849: PUSH
12850: LD_INT 103
12852: PUSH
12853: LD_INT 104
12855: PUSH
12856: LD_INT 105
12858: PUSH
12859: LD_INT 106
12861: PUSH
12862: LD_INT 107
12864: PUSH
12865: LD_INT 108
12867: PUSH
12868: LD_INT 109
12870: PUSH
12871: LD_INT 110
12873: PUSH
12874: LD_INT 111
12876: PUSH
12877: LD_INT 112
12879: PUSH
12880: LD_INT 114
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: LIST
12897: PUSH
12898: EMPTY
12899: LIST
12900: LIST
12901: ST_TO_ADDR
12902: GO 14489
12904: LD_INT 12
12906: DOUBLE
12907: EQUAL
12908: IFTRUE 12912
12910: GO 13120
12912: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
12913: LD_ADDR_VAR 0 1
12917: PUSH
12918: LD_INT 1
12920: PUSH
12921: LD_INT 2
12923: PUSH
12924: LD_INT 3
12926: PUSH
12927: LD_INT 4
12929: PUSH
12930: LD_INT 5
12932: PUSH
12933: LD_INT 6
12935: PUSH
12936: LD_INT 7
12938: PUSH
12939: LD_INT 8
12941: PUSH
12942: LD_INT 9
12944: PUSH
12945: LD_INT 10
12947: PUSH
12948: LD_INT 11
12950: PUSH
12951: LD_INT 12
12953: PUSH
12954: LD_INT 13
12956: PUSH
12957: LD_INT 14
12959: PUSH
12960: LD_INT 15
12962: PUSH
12963: LD_INT 16
12965: PUSH
12966: LD_INT 17
12968: PUSH
12969: LD_INT 18
12971: PUSH
12972: LD_INT 19
12974: PUSH
12975: LD_INT 20
12977: PUSH
12978: LD_INT 21
12980: PUSH
12981: LD_INT 22
12983: PUSH
12984: LD_INT 23
12986: PUSH
12987: LD_INT 24
12989: PUSH
12990: LD_INT 25
12992: PUSH
12993: LD_INT 26
12995: PUSH
12996: LD_INT 27
12998: PUSH
12999: LD_INT 28
13001: PUSH
13002: LD_INT 30
13004: PUSH
13005: LD_INT 31
13007: PUSH
13008: LD_INT 32
13010: PUSH
13011: LD_INT 33
13013: PUSH
13014: LD_INT 34
13016: PUSH
13017: LD_INT 36
13019: PUSH
13020: EMPTY
13021: LIST
13022: LIST
13023: LIST
13024: LIST
13025: LIST
13026: LIST
13027: LIST
13028: LIST
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: LIST
13038: LIST
13039: LIST
13040: LIST
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: LIST
13050: LIST
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: PUSH
13056: LD_INT 101
13058: PUSH
13059: LD_INT 102
13061: PUSH
13062: LD_INT 103
13064: PUSH
13065: LD_INT 104
13067: PUSH
13068: LD_INT 105
13070: PUSH
13071: LD_INT 106
13073: PUSH
13074: LD_INT 107
13076: PUSH
13077: LD_INT 108
13079: PUSH
13080: LD_INT 109
13082: PUSH
13083: LD_INT 110
13085: PUSH
13086: LD_INT 111
13088: PUSH
13089: LD_INT 112
13091: PUSH
13092: LD_INT 113
13094: PUSH
13095: LD_INT 114
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: LIST
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: LIST
13107: LIST
13108: LIST
13109: LIST
13110: LIST
13111: LIST
13112: LIST
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: ST_TO_ADDR
13118: GO 14489
13120: LD_INT 13
13122: DOUBLE
13123: EQUAL
13124: IFTRUE 13128
13126: GO 13324
13128: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13129: LD_ADDR_VAR 0 1
13133: PUSH
13134: LD_INT 1
13136: PUSH
13137: LD_INT 2
13139: PUSH
13140: LD_INT 3
13142: PUSH
13143: LD_INT 4
13145: PUSH
13146: LD_INT 5
13148: PUSH
13149: LD_INT 8
13151: PUSH
13152: LD_INT 9
13154: PUSH
13155: LD_INT 10
13157: PUSH
13158: LD_INT 11
13160: PUSH
13161: LD_INT 12
13163: PUSH
13164: LD_INT 14
13166: PUSH
13167: LD_INT 15
13169: PUSH
13170: LD_INT 16
13172: PUSH
13173: LD_INT 17
13175: PUSH
13176: LD_INT 18
13178: PUSH
13179: LD_INT 19
13181: PUSH
13182: LD_INT 20
13184: PUSH
13185: LD_INT 21
13187: PUSH
13188: LD_INT 22
13190: PUSH
13191: LD_INT 23
13193: PUSH
13194: LD_INT 24
13196: PUSH
13197: LD_INT 25
13199: PUSH
13200: LD_INT 26
13202: PUSH
13203: LD_INT 27
13205: PUSH
13206: LD_INT 28
13208: PUSH
13209: LD_INT 30
13211: PUSH
13212: LD_INT 31
13214: PUSH
13215: LD_INT 32
13217: PUSH
13218: LD_INT 33
13220: PUSH
13221: LD_INT 34
13223: PUSH
13224: LD_INT 36
13226: PUSH
13227: EMPTY
13228: LIST
13229: LIST
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: LIST
13244: LIST
13245: LIST
13246: LIST
13247: LIST
13248: LIST
13249: LIST
13250: LIST
13251: LIST
13252: LIST
13253: LIST
13254: LIST
13255: LIST
13256: LIST
13257: LIST
13258: LIST
13259: PUSH
13260: LD_INT 101
13262: PUSH
13263: LD_INT 102
13265: PUSH
13266: LD_INT 103
13268: PUSH
13269: LD_INT 104
13271: PUSH
13272: LD_INT 105
13274: PUSH
13275: LD_INT 106
13277: PUSH
13278: LD_INT 107
13280: PUSH
13281: LD_INT 108
13283: PUSH
13284: LD_INT 109
13286: PUSH
13287: LD_INT 110
13289: PUSH
13290: LD_INT 111
13292: PUSH
13293: LD_INT 112
13295: PUSH
13296: LD_INT 113
13298: PUSH
13299: LD_INT 114
13301: PUSH
13302: EMPTY
13303: LIST
13304: LIST
13305: LIST
13306: LIST
13307: LIST
13308: LIST
13309: LIST
13310: LIST
13311: LIST
13312: LIST
13313: LIST
13314: LIST
13315: LIST
13316: LIST
13317: PUSH
13318: EMPTY
13319: LIST
13320: LIST
13321: ST_TO_ADDR
13322: GO 14489
13324: LD_INT 14
13326: DOUBLE
13327: EQUAL
13328: IFTRUE 13332
13330: GO 13544
13332: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13333: LD_ADDR_VAR 0 1
13337: PUSH
13338: LD_INT 1
13340: PUSH
13341: LD_INT 2
13343: PUSH
13344: LD_INT 3
13346: PUSH
13347: LD_INT 4
13349: PUSH
13350: LD_INT 5
13352: PUSH
13353: LD_INT 6
13355: PUSH
13356: LD_INT 7
13358: PUSH
13359: LD_INT 8
13361: PUSH
13362: LD_INT 9
13364: PUSH
13365: LD_INT 10
13367: PUSH
13368: LD_INT 11
13370: PUSH
13371: LD_INT 12
13373: PUSH
13374: LD_INT 13
13376: PUSH
13377: LD_INT 14
13379: PUSH
13380: LD_INT 15
13382: PUSH
13383: LD_INT 16
13385: PUSH
13386: LD_INT 17
13388: PUSH
13389: LD_INT 18
13391: PUSH
13392: LD_INT 19
13394: PUSH
13395: LD_INT 20
13397: PUSH
13398: LD_INT 21
13400: PUSH
13401: LD_INT 22
13403: PUSH
13404: LD_INT 23
13406: PUSH
13407: LD_INT 24
13409: PUSH
13410: LD_INT 25
13412: PUSH
13413: LD_INT 26
13415: PUSH
13416: LD_INT 27
13418: PUSH
13419: LD_INT 28
13421: PUSH
13422: LD_INT 29
13424: PUSH
13425: LD_INT 30
13427: PUSH
13428: LD_INT 31
13430: PUSH
13431: LD_INT 32
13433: PUSH
13434: LD_INT 33
13436: PUSH
13437: LD_INT 34
13439: PUSH
13440: LD_INT 36
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: LIST
13447: LIST
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: LIST
13455: LIST
13456: LIST
13457: LIST
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: LIST
13463: LIST
13464: LIST
13465: LIST
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: LIST
13471: LIST
13472: LIST
13473: LIST
13474: LIST
13475: LIST
13476: LIST
13477: LIST
13478: LIST
13479: PUSH
13480: LD_INT 101
13482: PUSH
13483: LD_INT 102
13485: PUSH
13486: LD_INT 103
13488: PUSH
13489: LD_INT 104
13491: PUSH
13492: LD_INT 105
13494: PUSH
13495: LD_INT 106
13497: PUSH
13498: LD_INT 107
13500: PUSH
13501: LD_INT 108
13503: PUSH
13504: LD_INT 109
13506: PUSH
13507: LD_INT 110
13509: PUSH
13510: LD_INT 111
13512: PUSH
13513: LD_INT 112
13515: PUSH
13516: LD_INT 113
13518: PUSH
13519: LD_INT 114
13521: PUSH
13522: EMPTY
13523: LIST
13524: LIST
13525: LIST
13526: LIST
13527: LIST
13528: LIST
13529: LIST
13530: LIST
13531: LIST
13532: LIST
13533: LIST
13534: LIST
13535: LIST
13536: LIST
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: ST_TO_ADDR
13542: GO 14489
13544: LD_INT 15
13546: DOUBLE
13547: EQUAL
13548: IFTRUE 13552
13550: GO 13764
13552: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13553: LD_ADDR_VAR 0 1
13557: PUSH
13558: LD_INT 1
13560: PUSH
13561: LD_INT 2
13563: PUSH
13564: LD_INT 3
13566: PUSH
13567: LD_INT 4
13569: PUSH
13570: LD_INT 5
13572: PUSH
13573: LD_INT 6
13575: PUSH
13576: LD_INT 7
13578: PUSH
13579: LD_INT 8
13581: PUSH
13582: LD_INT 9
13584: PUSH
13585: LD_INT 10
13587: PUSH
13588: LD_INT 11
13590: PUSH
13591: LD_INT 12
13593: PUSH
13594: LD_INT 13
13596: PUSH
13597: LD_INT 14
13599: PUSH
13600: LD_INT 15
13602: PUSH
13603: LD_INT 16
13605: PUSH
13606: LD_INT 17
13608: PUSH
13609: LD_INT 18
13611: PUSH
13612: LD_INT 19
13614: PUSH
13615: LD_INT 20
13617: PUSH
13618: LD_INT 21
13620: PUSH
13621: LD_INT 22
13623: PUSH
13624: LD_INT 23
13626: PUSH
13627: LD_INT 24
13629: PUSH
13630: LD_INT 25
13632: PUSH
13633: LD_INT 26
13635: PUSH
13636: LD_INT 27
13638: PUSH
13639: LD_INT 28
13641: PUSH
13642: LD_INT 29
13644: PUSH
13645: LD_INT 30
13647: PUSH
13648: LD_INT 31
13650: PUSH
13651: LD_INT 32
13653: PUSH
13654: LD_INT 33
13656: PUSH
13657: LD_INT 34
13659: PUSH
13660: LD_INT 36
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: LIST
13667: LIST
13668: LIST
13669: LIST
13670: LIST
13671: LIST
13672: LIST
13673: LIST
13674: LIST
13675: LIST
13676: LIST
13677: LIST
13678: LIST
13679: LIST
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: LIST
13685: LIST
13686: LIST
13687: LIST
13688: LIST
13689: LIST
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: LIST
13695: LIST
13696: LIST
13697: LIST
13698: LIST
13699: PUSH
13700: LD_INT 101
13702: PUSH
13703: LD_INT 102
13705: PUSH
13706: LD_INT 103
13708: PUSH
13709: LD_INT 104
13711: PUSH
13712: LD_INT 105
13714: PUSH
13715: LD_INT 106
13717: PUSH
13718: LD_INT 107
13720: PUSH
13721: LD_INT 108
13723: PUSH
13724: LD_INT 109
13726: PUSH
13727: LD_INT 110
13729: PUSH
13730: LD_INT 111
13732: PUSH
13733: LD_INT 112
13735: PUSH
13736: LD_INT 113
13738: PUSH
13739: LD_INT 114
13741: PUSH
13742: EMPTY
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: LIST
13749: LIST
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: PUSH
13758: EMPTY
13759: LIST
13760: LIST
13761: ST_TO_ADDR
13762: GO 14489
13764: LD_INT 16
13766: DOUBLE
13767: EQUAL
13768: IFTRUE 13772
13770: GO 13896
13772: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13773: LD_ADDR_VAR 0 1
13777: PUSH
13778: LD_INT 2
13780: PUSH
13781: LD_INT 4
13783: PUSH
13784: LD_INT 5
13786: PUSH
13787: LD_INT 7
13789: PUSH
13790: LD_INT 11
13792: PUSH
13793: LD_INT 12
13795: PUSH
13796: LD_INT 15
13798: PUSH
13799: LD_INT 16
13801: PUSH
13802: LD_INT 20
13804: PUSH
13805: LD_INT 21
13807: PUSH
13808: LD_INT 22
13810: PUSH
13811: LD_INT 23
13813: PUSH
13814: LD_INT 25
13816: PUSH
13817: LD_INT 26
13819: PUSH
13820: LD_INT 30
13822: PUSH
13823: LD_INT 31
13825: PUSH
13826: LD_INT 32
13828: PUSH
13829: LD_INT 33
13831: PUSH
13832: LD_INT 34
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: LIST
13839: LIST
13840: LIST
13841: LIST
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: LIST
13847: LIST
13848: LIST
13849: LIST
13850: LIST
13851: LIST
13852: LIST
13853: LIST
13854: LIST
13855: PUSH
13856: LD_INT 101
13858: PUSH
13859: LD_INT 102
13861: PUSH
13862: LD_INT 103
13864: PUSH
13865: LD_INT 106
13867: PUSH
13868: LD_INT 108
13870: PUSH
13871: LD_INT 112
13873: PUSH
13874: LD_INT 113
13876: PUSH
13877: LD_INT 114
13879: PUSH
13880: EMPTY
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: ST_TO_ADDR
13894: GO 14489
13896: LD_INT 17
13898: DOUBLE
13899: EQUAL
13900: IFTRUE 13904
13902: GO 14116
13904: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
13905: LD_ADDR_VAR 0 1
13909: PUSH
13910: LD_INT 1
13912: PUSH
13913: LD_INT 2
13915: PUSH
13916: LD_INT 3
13918: PUSH
13919: LD_INT 4
13921: PUSH
13922: LD_INT 5
13924: PUSH
13925: LD_INT 6
13927: PUSH
13928: LD_INT 7
13930: PUSH
13931: LD_INT 8
13933: PUSH
13934: LD_INT 9
13936: PUSH
13937: LD_INT 10
13939: PUSH
13940: LD_INT 11
13942: PUSH
13943: LD_INT 12
13945: PUSH
13946: LD_INT 13
13948: PUSH
13949: LD_INT 14
13951: PUSH
13952: LD_INT 15
13954: PUSH
13955: LD_INT 16
13957: PUSH
13958: LD_INT 17
13960: PUSH
13961: LD_INT 18
13963: PUSH
13964: LD_INT 19
13966: PUSH
13967: LD_INT 20
13969: PUSH
13970: LD_INT 21
13972: PUSH
13973: LD_INT 22
13975: PUSH
13976: LD_INT 23
13978: PUSH
13979: LD_INT 24
13981: PUSH
13982: LD_INT 25
13984: PUSH
13985: LD_INT 26
13987: PUSH
13988: LD_INT 27
13990: PUSH
13991: LD_INT 28
13993: PUSH
13994: LD_INT 29
13996: PUSH
13997: LD_INT 30
13999: PUSH
14000: LD_INT 31
14002: PUSH
14003: LD_INT 32
14005: PUSH
14006: LD_INT 33
14008: PUSH
14009: LD_INT 34
14011: PUSH
14012: LD_INT 36
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: LIST
14019: LIST
14020: LIST
14021: LIST
14022: LIST
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: LIST
14036: LIST
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: LIST
14045: LIST
14046: LIST
14047: LIST
14048: LIST
14049: LIST
14050: LIST
14051: PUSH
14052: LD_INT 101
14054: PUSH
14055: LD_INT 102
14057: PUSH
14058: LD_INT 103
14060: PUSH
14061: LD_INT 104
14063: PUSH
14064: LD_INT 105
14066: PUSH
14067: LD_INT 106
14069: PUSH
14070: LD_INT 107
14072: PUSH
14073: LD_INT 108
14075: PUSH
14076: LD_INT 109
14078: PUSH
14079: LD_INT 110
14081: PUSH
14082: LD_INT 111
14084: PUSH
14085: LD_INT 112
14087: PUSH
14088: LD_INT 113
14090: PUSH
14091: LD_INT 114
14093: PUSH
14094: EMPTY
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: PUSH
14110: EMPTY
14111: LIST
14112: LIST
14113: ST_TO_ADDR
14114: GO 14489
14116: LD_INT 18
14118: DOUBLE
14119: EQUAL
14120: IFTRUE 14124
14122: GO 14260
14124: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14125: LD_ADDR_VAR 0 1
14129: PUSH
14130: LD_INT 2
14132: PUSH
14133: LD_INT 4
14135: PUSH
14136: LD_INT 5
14138: PUSH
14139: LD_INT 7
14141: PUSH
14142: LD_INT 11
14144: PUSH
14145: LD_INT 12
14147: PUSH
14148: LD_INT 15
14150: PUSH
14151: LD_INT 16
14153: PUSH
14154: LD_INT 20
14156: PUSH
14157: LD_INT 21
14159: PUSH
14160: LD_INT 22
14162: PUSH
14163: LD_INT 23
14165: PUSH
14166: LD_INT 25
14168: PUSH
14169: LD_INT 26
14171: PUSH
14172: LD_INT 30
14174: PUSH
14175: LD_INT 31
14177: PUSH
14178: LD_INT 32
14180: PUSH
14181: LD_INT 33
14183: PUSH
14184: LD_INT 34
14186: PUSH
14187: LD_INT 35
14189: PUSH
14190: LD_INT 36
14192: PUSH
14193: EMPTY
14194: LIST
14195: LIST
14196: LIST
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: PUSH
14216: LD_INT 101
14218: PUSH
14219: LD_INT 102
14221: PUSH
14222: LD_INT 103
14224: PUSH
14225: LD_INT 106
14227: PUSH
14228: LD_INT 108
14230: PUSH
14231: LD_INT 112
14233: PUSH
14234: LD_INT 113
14236: PUSH
14237: LD_INT 114
14239: PUSH
14240: LD_INT 115
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: LIST
14247: LIST
14248: LIST
14249: LIST
14250: LIST
14251: LIST
14252: LIST
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: ST_TO_ADDR
14258: GO 14489
14260: LD_INT 19
14262: DOUBLE
14263: EQUAL
14264: IFTRUE 14268
14266: GO 14488
14268: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14269: LD_ADDR_VAR 0 1
14273: PUSH
14274: LD_INT 1
14276: PUSH
14277: LD_INT 2
14279: PUSH
14280: LD_INT 3
14282: PUSH
14283: LD_INT 4
14285: PUSH
14286: LD_INT 5
14288: PUSH
14289: LD_INT 6
14291: PUSH
14292: LD_INT 7
14294: PUSH
14295: LD_INT 8
14297: PUSH
14298: LD_INT 9
14300: PUSH
14301: LD_INT 10
14303: PUSH
14304: LD_INT 11
14306: PUSH
14307: LD_INT 12
14309: PUSH
14310: LD_INT 13
14312: PUSH
14313: LD_INT 14
14315: PUSH
14316: LD_INT 15
14318: PUSH
14319: LD_INT 16
14321: PUSH
14322: LD_INT 17
14324: PUSH
14325: LD_INT 18
14327: PUSH
14328: LD_INT 19
14330: PUSH
14331: LD_INT 20
14333: PUSH
14334: LD_INT 21
14336: PUSH
14337: LD_INT 22
14339: PUSH
14340: LD_INT 23
14342: PUSH
14343: LD_INT 24
14345: PUSH
14346: LD_INT 25
14348: PUSH
14349: LD_INT 26
14351: PUSH
14352: LD_INT 27
14354: PUSH
14355: LD_INT 28
14357: PUSH
14358: LD_INT 29
14360: PUSH
14361: LD_INT 30
14363: PUSH
14364: LD_INT 31
14366: PUSH
14367: LD_INT 32
14369: PUSH
14370: LD_INT 33
14372: PUSH
14373: LD_INT 34
14375: PUSH
14376: LD_INT 35
14378: PUSH
14379: LD_INT 36
14381: PUSH
14382: EMPTY
14383: LIST
14384: LIST
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: PUSH
14420: LD_INT 101
14422: PUSH
14423: LD_INT 102
14425: PUSH
14426: LD_INT 103
14428: PUSH
14429: LD_INT 104
14431: PUSH
14432: LD_INT 105
14434: PUSH
14435: LD_INT 106
14437: PUSH
14438: LD_INT 107
14440: PUSH
14441: LD_INT 108
14443: PUSH
14444: LD_INT 109
14446: PUSH
14447: LD_INT 110
14449: PUSH
14450: LD_INT 111
14452: PUSH
14453: LD_INT 112
14455: PUSH
14456: LD_INT 113
14458: PUSH
14459: LD_INT 114
14461: PUSH
14462: LD_INT 115
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: LIST
14469: LIST
14470: LIST
14471: LIST
14472: LIST
14473: LIST
14474: LIST
14475: LIST
14476: LIST
14477: LIST
14478: LIST
14479: LIST
14480: LIST
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: ST_TO_ADDR
14486: GO 14489
14488: POP
// end else
14489: GO 14708
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
14491: LD_ADDR_VAR 0 1
14495: PUSH
14496: LD_INT 1
14498: PUSH
14499: LD_INT 2
14501: PUSH
14502: LD_INT 3
14504: PUSH
14505: LD_INT 4
14507: PUSH
14508: LD_INT 5
14510: PUSH
14511: LD_INT 6
14513: PUSH
14514: LD_INT 7
14516: PUSH
14517: LD_INT 8
14519: PUSH
14520: LD_INT 9
14522: PUSH
14523: LD_INT 10
14525: PUSH
14526: LD_INT 11
14528: PUSH
14529: LD_INT 12
14531: PUSH
14532: LD_INT 13
14534: PUSH
14535: LD_INT 14
14537: PUSH
14538: LD_INT 15
14540: PUSH
14541: LD_INT 16
14543: PUSH
14544: LD_INT 17
14546: PUSH
14547: LD_INT 18
14549: PUSH
14550: LD_INT 19
14552: PUSH
14553: LD_INT 20
14555: PUSH
14556: LD_INT 21
14558: PUSH
14559: LD_INT 22
14561: PUSH
14562: LD_INT 23
14564: PUSH
14565: LD_INT 24
14567: PUSH
14568: LD_INT 25
14570: PUSH
14571: LD_INT 26
14573: PUSH
14574: LD_INT 27
14576: PUSH
14577: LD_INT 28
14579: PUSH
14580: LD_INT 29
14582: PUSH
14583: LD_INT 30
14585: PUSH
14586: LD_INT 31
14588: PUSH
14589: LD_INT 32
14591: PUSH
14592: LD_INT 33
14594: PUSH
14595: LD_INT 34
14597: PUSH
14598: LD_INT 35
14600: PUSH
14601: LD_INT 36
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: LIST
14617: LIST
14618: LIST
14619: LIST
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: LIST
14628: LIST
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: LIST
14636: LIST
14637: LIST
14638: LIST
14639: LIST
14640: LIST
14641: PUSH
14642: LD_INT 101
14644: PUSH
14645: LD_INT 102
14647: PUSH
14648: LD_INT 103
14650: PUSH
14651: LD_INT 104
14653: PUSH
14654: LD_INT 105
14656: PUSH
14657: LD_INT 106
14659: PUSH
14660: LD_INT 107
14662: PUSH
14663: LD_INT 108
14665: PUSH
14666: LD_INT 109
14668: PUSH
14669: LD_INT 110
14671: PUSH
14672: LD_INT 111
14674: PUSH
14675: LD_INT 112
14677: PUSH
14678: LD_INT 113
14680: PUSH
14681: LD_INT 114
14683: PUSH
14684: LD_INT 115
14686: PUSH
14687: EMPTY
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: LIST
14693: LIST
14694: LIST
14695: LIST
14696: LIST
14697: LIST
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: PUSH
14704: EMPTY
14705: LIST
14706: LIST
14707: ST_TO_ADDR
// if result then
14708: LD_VAR 0 1
14712: IFFALSE 15001
// begin normal :=  ;
14714: LD_ADDR_VAR 0 3
14718: PUSH
14719: LD_STRING 
14721: ST_TO_ADDR
// hardcore :=  ;
14722: LD_ADDR_VAR 0 4
14726: PUSH
14727: LD_STRING 
14729: ST_TO_ADDR
// for i = 1 to normalCounter do
14730: LD_ADDR_VAR 0 5
14734: PUSH
14735: DOUBLE
14736: LD_INT 1
14738: DEC
14739: ST_TO_ADDR
14740: LD_EXP 39
14744: PUSH
14745: FOR_TO
14746: IFFALSE 14847
// begin tmp := 0 ;
14748: LD_ADDR_VAR 0 2
14752: PUSH
14753: LD_STRING 0
14755: ST_TO_ADDR
// if result [ 1 ] then
14756: LD_VAR 0 1
14760: PUSH
14761: LD_INT 1
14763: ARRAY
14764: IFFALSE 14829
// if result [ 1 ] [ 1 ] = i then
14766: LD_VAR 0 1
14770: PUSH
14771: LD_INT 1
14773: ARRAY
14774: PUSH
14775: LD_INT 1
14777: ARRAY
14778: PUSH
14779: LD_VAR 0 5
14783: EQUAL
14784: IFFALSE 14829
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
14786: LD_ADDR_VAR 0 1
14790: PUSH
14791: LD_VAR 0 1
14795: PPUSH
14796: LD_INT 1
14798: PPUSH
14799: LD_VAR 0 1
14803: PUSH
14804: LD_INT 1
14806: ARRAY
14807: PPUSH
14808: LD_INT 1
14810: PPUSH
14811: CALL_OW 3
14815: PPUSH
14816: CALL_OW 1
14820: ST_TO_ADDR
// tmp := 1 ;
14821: LD_ADDR_VAR 0 2
14825: PUSH
14826: LD_STRING 1
14828: ST_TO_ADDR
// end ; normal := normal & tmp ;
14829: LD_ADDR_VAR 0 3
14833: PUSH
14834: LD_VAR 0 3
14838: PUSH
14839: LD_VAR 0 2
14843: STR
14844: ST_TO_ADDR
// end ;
14845: GO 14745
14847: POP
14848: POP
// for i = 1 to hardcoreCounter do
14849: LD_ADDR_VAR 0 5
14853: PUSH
14854: DOUBLE
14855: LD_INT 1
14857: DEC
14858: ST_TO_ADDR
14859: LD_EXP 40
14863: PUSH
14864: FOR_TO
14865: IFFALSE 14970
// begin tmp := 0 ;
14867: LD_ADDR_VAR 0 2
14871: PUSH
14872: LD_STRING 0
14874: ST_TO_ADDR
// if result [ 2 ] then
14875: LD_VAR 0 1
14879: PUSH
14880: LD_INT 2
14882: ARRAY
14883: IFFALSE 14952
// if result [ 2 ] [ 1 ] = 100 + i then
14885: LD_VAR 0 1
14889: PUSH
14890: LD_INT 2
14892: ARRAY
14893: PUSH
14894: LD_INT 1
14896: ARRAY
14897: PUSH
14898: LD_INT 100
14900: PUSH
14901: LD_VAR 0 5
14905: PLUS
14906: EQUAL
14907: IFFALSE 14952
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
14909: LD_ADDR_VAR 0 1
14913: PUSH
14914: LD_VAR 0 1
14918: PPUSH
14919: LD_INT 2
14921: PPUSH
14922: LD_VAR 0 1
14926: PUSH
14927: LD_INT 2
14929: ARRAY
14930: PPUSH
14931: LD_INT 1
14933: PPUSH
14934: CALL_OW 3
14938: PPUSH
14939: CALL_OW 1
14943: ST_TO_ADDR
// tmp := 1 ;
14944: LD_ADDR_VAR 0 2
14948: PUSH
14949: LD_STRING 1
14951: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
14952: LD_ADDR_VAR 0 4
14956: PUSH
14957: LD_VAR 0 4
14961: PUSH
14962: LD_VAR 0 2
14966: STR
14967: ST_TO_ADDR
// end ;
14968: GO 14864
14970: POP
14971: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
14972: LD_STRING getStreamItemsFromMission("
14974: PUSH
14975: LD_VAR 0 3
14979: STR
14980: PUSH
14981: LD_STRING ","
14983: STR
14984: PUSH
14985: LD_VAR 0 4
14989: STR
14990: PUSH
14991: LD_STRING ")
14993: STR
14994: PPUSH
14995: CALL_OW 559
// end else
14999: GO 15008
// ToLua ( getStreamItemsFromMission("","") ) ;
15001: LD_STRING getStreamItemsFromMission("","")
15003: PPUSH
15004: CALL_OW 559
// end ;
15008: LD_VAR 0 1
15012: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
15013: LD_VAR 0 2
15017: PUSH
15018: LD_INT 100
15020: EQUAL
15021: IFFALSE 15970
// begin if not StreamModeActive then
15023: LD_EXP 38
15027: NOT
15028: IFFALSE 15038
// StreamModeActive := true ;
15030: LD_ADDR_EXP 38
15034: PUSH
15035: LD_INT 1
15037: ST_TO_ADDR
// if p3 = 0 then
15038: LD_VAR 0 3
15042: PUSH
15043: LD_INT 0
15045: EQUAL
15046: IFFALSE 15052
// InitStreamMode ;
15048: CALL 11091 0 0
// if p3 = 1 then
15052: LD_VAR 0 3
15056: PUSH
15057: LD_INT 1
15059: EQUAL
15060: IFFALSE 15070
// sRocket := true ;
15062: LD_ADDR_EXP 43
15066: PUSH
15067: LD_INT 1
15069: ST_TO_ADDR
// if p3 = 2 then
15070: LD_VAR 0 3
15074: PUSH
15075: LD_INT 2
15077: EQUAL
15078: IFFALSE 15088
// sSpeed := true ;
15080: LD_ADDR_EXP 42
15084: PUSH
15085: LD_INT 1
15087: ST_TO_ADDR
// if p3 = 3 then
15088: LD_VAR 0 3
15092: PUSH
15093: LD_INT 3
15095: EQUAL
15096: IFFALSE 15106
// sEngine := true ;
15098: LD_ADDR_EXP 44
15102: PUSH
15103: LD_INT 1
15105: ST_TO_ADDR
// if p3 = 4 then
15106: LD_VAR 0 3
15110: PUSH
15111: LD_INT 4
15113: EQUAL
15114: IFFALSE 15124
// sSpec := true ;
15116: LD_ADDR_EXP 41
15120: PUSH
15121: LD_INT 1
15123: ST_TO_ADDR
// if p3 = 5 then
15124: LD_VAR 0 3
15128: PUSH
15129: LD_INT 5
15131: EQUAL
15132: IFFALSE 15142
// sLevel := true ;
15134: LD_ADDR_EXP 45
15138: PUSH
15139: LD_INT 1
15141: ST_TO_ADDR
// if p3 = 6 then
15142: LD_VAR 0 3
15146: PUSH
15147: LD_INT 6
15149: EQUAL
15150: IFFALSE 15160
// sArmoury := true ;
15152: LD_ADDR_EXP 46
15156: PUSH
15157: LD_INT 1
15159: ST_TO_ADDR
// if p3 = 7 then
15160: LD_VAR 0 3
15164: PUSH
15165: LD_INT 7
15167: EQUAL
15168: IFFALSE 15178
// sRadar := true ;
15170: LD_ADDR_EXP 47
15174: PUSH
15175: LD_INT 1
15177: ST_TO_ADDR
// if p3 = 8 then
15178: LD_VAR 0 3
15182: PUSH
15183: LD_INT 8
15185: EQUAL
15186: IFFALSE 15196
// sBunker := true ;
15188: LD_ADDR_EXP 48
15192: PUSH
15193: LD_INT 1
15195: ST_TO_ADDR
// if p3 = 9 then
15196: LD_VAR 0 3
15200: PUSH
15201: LD_INT 9
15203: EQUAL
15204: IFFALSE 15214
// sHack := true ;
15206: LD_ADDR_EXP 49
15210: PUSH
15211: LD_INT 1
15213: ST_TO_ADDR
// if p3 = 10 then
15214: LD_VAR 0 3
15218: PUSH
15219: LD_INT 10
15221: EQUAL
15222: IFFALSE 15232
// sFire := true ;
15224: LD_ADDR_EXP 50
15228: PUSH
15229: LD_INT 1
15231: ST_TO_ADDR
// if p3 = 11 then
15232: LD_VAR 0 3
15236: PUSH
15237: LD_INT 11
15239: EQUAL
15240: IFFALSE 15250
// sRefresh := true ;
15242: LD_ADDR_EXP 51
15246: PUSH
15247: LD_INT 1
15249: ST_TO_ADDR
// if p3 = 12 then
15250: LD_VAR 0 3
15254: PUSH
15255: LD_INT 12
15257: EQUAL
15258: IFFALSE 15268
// sExp := true ;
15260: LD_ADDR_EXP 52
15264: PUSH
15265: LD_INT 1
15267: ST_TO_ADDR
// if p3 = 13 then
15268: LD_VAR 0 3
15272: PUSH
15273: LD_INT 13
15275: EQUAL
15276: IFFALSE 15286
// sDepot := true ;
15278: LD_ADDR_EXP 53
15282: PUSH
15283: LD_INT 1
15285: ST_TO_ADDR
// if p3 = 14 then
15286: LD_VAR 0 3
15290: PUSH
15291: LD_INT 14
15293: EQUAL
15294: IFFALSE 15304
// sFlag := true ;
15296: LD_ADDR_EXP 54
15300: PUSH
15301: LD_INT 1
15303: ST_TO_ADDR
// if p3 = 15 then
15304: LD_VAR 0 3
15308: PUSH
15309: LD_INT 15
15311: EQUAL
15312: IFFALSE 15322
// sKamikadze := true ;
15314: LD_ADDR_EXP 62
15318: PUSH
15319: LD_INT 1
15321: ST_TO_ADDR
// if p3 = 16 then
15322: LD_VAR 0 3
15326: PUSH
15327: LD_INT 16
15329: EQUAL
15330: IFFALSE 15340
// sTroll := true ;
15332: LD_ADDR_EXP 63
15336: PUSH
15337: LD_INT 1
15339: ST_TO_ADDR
// if p3 = 17 then
15340: LD_VAR 0 3
15344: PUSH
15345: LD_INT 17
15347: EQUAL
15348: IFFALSE 15358
// sSlow := true ;
15350: LD_ADDR_EXP 64
15354: PUSH
15355: LD_INT 1
15357: ST_TO_ADDR
// if p3 = 18 then
15358: LD_VAR 0 3
15362: PUSH
15363: LD_INT 18
15365: EQUAL
15366: IFFALSE 15376
// sLack := true ;
15368: LD_ADDR_EXP 65
15372: PUSH
15373: LD_INT 1
15375: ST_TO_ADDR
// if p3 = 19 then
15376: LD_VAR 0 3
15380: PUSH
15381: LD_INT 19
15383: EQUAL
15384: IFFALSE 15394
// sTank := true ;
15386: LD_ADDR_EXP 67
15390: PUSH
15391: LD_INT 1
15393: ST_TO_ADDR
// if p3 = 20 then
15394: LD_VAR 0 3
15398: PUSH
15399: LD_INT 20
15401: EQUAL
15402: IFFALSE 15412
// sRemote := true ;
15404: LD_ADDR_EXP 68
15408: PUSH
15409: LD_INT 1
15411: ST_TO_ADDR
// if p3 = 21 then
15412: LD_VAR 0 3
15416: PUSH
15417: LD_INT 21
15419: EQUAL
15420: IFFALSE 15430
// sPowell := true ;
15422: LD_ADDR_EXP 69
15426: PUSH
15427: LD_INT 1
15429: ST_TO_ADDR
// if p3 = 22 then
15430: LD_VAR 0 3
15434: PUSH
15435: LD_INT 22
15437: EQUAL
15438: IFFALSE 15448
// sTeleport := true ;
15440: LD_ADDR_EXP 72
15444: PUSH
15445: LD_INT 1
15447: ST_TO_ADDR
// if p3 = 23 then
15448: LD_VAR 0 3
15452: PUSH
15453: LD_INT 23
15455: EQUAL
15456: IFFALSE 15466
// sOilTower := true ;
15458: LD_ADDR_EXP 74
15462: PUSH
15463: LD_INT 1
15465: ST_TO_ADDR
// if p3 = 24 then
15466: LD_VAR 0 3
15470: PUSH
15471: LD_INT 24
15473: EQUAL
15474: IFFALSE 15484
// sShovel := true ;
15476: LD_ADDR_EXP 75
15480: PUSH
15481: LD_INT 1
15483: ST_TO_ADDR
// if p3 = 25 then
15484: LD_VAR 0 3
15488: PUSH
15489: LD_INT 25
15491: EQUAL
15492: IFFALSE 15502
// sSheik := true ;
15494: LD_ADDR_EXP 76
15498: PUSH
15499: LD_INT 1
15501: ST_TO_ADDR
// if p3 = 26 then
15502: LD_VAR 0 3
15506: PUSH
15507: LD_INT 26
15509: EQUAL
15510: IFFALSE 15520
// sEarthquake := true ;
15512: LD_ADDR_EXP 78
15516: PUSH
15517: LD_INT 1
15519: ST_TO_ADDR
// if p3 = 27 then
15520: LD_VAR 0 3
15524: PUSH
15525: LD_INT 27
15527: EQUAL
15528: IFFALSE 15538
// sAI := true ;
15530: LD_ADDR_EXP 79
15534: PUSH
15535: LD_INT 1
15537: ST_TO_ADDR
// if p3 = 28 then
15538: LD_VAR 0 3
15542: PUSH
15543: LD_INT 28
15545: EQUAL
15546: IFFALSE 15556
// sCargo := true ;
15548: LD_ADDR_EXP 82
15552: PUSH
15553: LD_INT 1
15555: ST_TO_ADDR
// if p3 = 29 then
15556: LD_VAR 0 3
15560: PUSH
15561: LD_INT 29
15563: EQUAL
15564: IFFALSE 15574
// sDLaser := true ;
15566: LD_ADDR_EXP 83
15570: PUSH
15571: LD_INT 1
15573: ST_TO_ADDR
// if p3 = 30 then
15574: LD_VAR 0 3
15578: PUSH
15579: LD_INT 30
15581: EQUAL
15582: IFFALSE 15592
// sExchange := true ;
15584: LD_ADDR_EXP 84
15588: PUSH
15589: LD_INT 1
15591: ST_TO_ADDR
// if p3 = 31 then
15592: LD_VAR 0 3
15596: PUSH
15597: LD_INT 31
15599: EQUAL
15600: IFFALSE 15610
// sFac := true ;
15602: LD_ADDR_EXP 85
15606: PUSH
15607: LD_INT 1
15609: ST_TO_ADDR
// if p3 = 32 then
15610: LD_VAR 0 3
15614: PUSH
15615: LD_INT 32
15617: EQUAL
15618: IFFALSE 15628
// sPower := true ;
15620: LD_ADDR_EXP 86
15624: PUSH
15625: LD_INT 1
15627: ST_TO_ADDR
// if p3 = 33 then
15628: LD_VAR 0 3
15632: PUSH
15633: LD_INT 33
15635: EQUAL
15636: IFFALSE 15646
// sRandom := true ;
15638: LD_ADDR_EXP 87
15642: PUSH
15643: LD_INT 1
15645: ST_TO_ADDR
// if p3 = 34 then
15646: LD_VAR 0 3
15650: PUSH
15651: LD_INT 34
15653: EQUAL
15654: IFFALSE 15664
// sShield := true ;
15656: LD_ADDR_EXP 88
15660: PUSH
15661: LD_INT 1
15663: ST_TO_ADDR
// if p3 = 35 then
15664: LD_VAR 0 3
15668: PUSH
15669: LD_INT 35
15671: EQUAL
15672: IFFALSE 15682
// sTime := true ;
15674: LD_ADDR_EXP 89
15678: PUSH
15679: LD_INT 1
15681: ST_TO_ADDR
// if p3 = 36 then
15682: LD_VAR 0 3
15686: PUSH
15687: LD_INT 36
15689: EQUAL
15690: IFFALSE 15700
// sTools := true ;
15692: LD_ADDR_EXP 90
15696: PUSH
15697: LD_INT 1
15699: ST_TO_ADDR
// if p3 = 101 then
15700: LD_VAR 0 3
15704: PUSH
15705: LD_INT 101
15707: EQUAL
15708: IFFALSE 15718
// sSold := true ;
15710: LD_ADDR_EXP 55
15714: PUSH
15715: LD_INT 1
15717: ST_TO_ADDR
// if p3 = 102 then
15718: LD_VAR 0 3
15722: PUSH
15723: LD_INT 102
15725: EQUAL
15726: IFFALSE 15736
// sDiff := true ;
15728: LD_ADDR_EXP 56
15732: PUSH
15733: LD_INT 1
15735: ST_TO_ADDR
// if p3 = 103 then
15736: LD_VAR 0 3
15740: PUSH
15741: LD_INT 103
15743: EQUAL
15744: IFFALSE 15754
// sFog := true ;
15746: LD_ADDR_EXP 59
15750: PUSH
15751: LD_INT 1
15753: ST_TO_ADDR
// if p3 = 104 then
15754: LD_VAR 0 3
15758: PUSH
15759: LD_INT 104
15761: EQUAL
15762: IFFALSE 15772
// sReset := true ;
15764: LD_ADDR_EXP 60
15768: PUSH
15769: LD_INT 1
15771: ST_TO_ADDR
// if p3 = 105 then
15772: LD_VAR 0 3
15776: PUSH
15777: LD_INT 105
15779: EQUAL
15780: IFFALSE 15790
// sSun := true ;
15782: LD_ADDR_EXP 61
15786: PUSH
15787: LD_INT 1
15789: ST_TO_ADDR
// if p3 = 106 then
15790: LD_VAR 0 3
15794: PUSH
15795: LD_INT 106
15797: EQUAL
15798: IFFALSE 15808
// sTiger := true ;
15800: LD_ADDR_EXP 57
15804: PUSH
15805: LD_INT 1
15807: ST_TO_ADDR
// if p3 = 107 then
15808: LD_VAR 0 3
15812: PUSH
15813: LD_INT 107
15815: EQUAL
15816: IFFALSE 15826
// sBomb := true ;
15818: LD_ADDR_EXP 58
15822: PUSH
15823: LD_INT 1
15825: ST_TO_ADDR
// if p3 = 108 then
15826: LD_VAR 0 3
15830: PUSH
15831: LD_INT 108
15833: EQUAL
15834: IFFALSE 15844
// sWound := true ;
15836: LD_ADDR_EXP 66
15840: PUSH
15841: LD_INT 1
15843: ST_TO_ADDR
// if p3 = 109 then
15844: LD_VAR 0 3
15848: PUSH
15849: LD_INT 109
15851: EQUAL
15852: IFFALSE 15862
// sBetray := true ;
15854: LD_ADDR_EXP 70
15858: PUSH
15859: LD_INT 1
15861: ST_TO_ADDR
// if p3 = 110 then
15862: LD_VAR 0 3
15866: PUSH
15867: LD_INT 110
15869: EQUAL
15870: IFFALSE 15880
// sContamin := true ;
15872: LD_ADDR_EXP 71
15876: PUSH
15877: LD_INT 1
15879: ST_TO_ADDR
// if p3 = 111 then
15880: LD_VAR 0 3
15884: PUSH
15885: LD_INT 111
15887: EQUAL
15888: IFFALSE 15898
// sOil := true ;
15890: LD_ADDR_EXP 73
15894: PUSH
15895: LD_INT 1
15897: ST_TO_ADDR
// if p3 = 112 then
15898: LD_VAR 0 3
15902: PUSH
15903: LD_INT 112
15905: EQUAL
15906: IFFALSE 15916
// sStu := true ;
15908: LD_ADDR_EXP 77
15912: PUSH
15913: LD_INT 1
15915: ST_TO_ADDR
// if p3 = 113 then
15916: LD_VAR 0 3
15920: PUSH
15921: LD_INT 113
15923: EQUAL
15924: IFFALSE 15934
// sBazooka := true ;
15926: LD_ADDR_EXP 80
15930: PUSH
15931: LD_INT 1
15933: ST_TO_ADDR
// if p3 = 114 then
15934: LD_VAR 0 3
15938: PUSH
15939: LD_INT 114
15941: EQUAL
15942: IFFALSE 15952
// sMortar := true ;
15944: LD_ADDR_EXP 81
15948: PUSH
15949: LD_INT 1
15951: ST_TO_ADDR
// if p3 = 115 then
15952: LD_VAR 0 3
15956: PUSH
15957: LD_INT 115
15959: EQUAL
15960: IFFALSE 15970
// sRanger := true ;
15962: LD_ADDR_EXP 91
15966: PUSH
15967: LD_INT 1
15969: ST_TO_ADDR
// end ; end ;
15970: PPOPN 6
15972: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
15973: LD_EXP 38
15977: PUSH
15978: LD_EXP 43
15982: AND
15983: IFFALSE 16107
15985: GO 15987
15987: DISABLE
15988: LD_INT 0
15990: PPUSH
15991: PPUSH
// begin enable ;
15992: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
15993: LD_ADDR_VAR 0 2
15997: PUSH
15998: LD_INT 22
16000: PUSH
16001: LD_OWVAR 2
16005: PUSH
16006: EMPTY
16007: LIST
16008: LIST
16009: PUSH
16010: LD_INT 2
16012: PUSH
16013: LD_INT 34
16015: PUSH
16016: LD_INT 7
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PUSH
16023: LD_INT 34
16025: PUSH
16026: LD_INT 45
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: PUSH
16033: LD_INT 34
16035: PUSH
16036: LD_INT 28
16038: PUSH
16039: EMPTY
16040: LIST
16041: LIST
16042: PUSH
16043: LD_INT 34
16045: PUSH
16046: LD_INT 47
16048: PUSH
16049: EMPTY
16050: LIST
16051: LIST
16052: PUSH
16053: EMPTY
16054: LIST
16055: LIST
16056: LIST
16057: LIST
16058: LIST
16059: PUSH
16060: EMPTY
16061: LIST
16062: LIST
16063: PPUSH
16064: CALL_OW 69
16068: ST_TO_ADDR
// if not tmp then
16069: LD_VAR 0 2
16073: NOT
16074: IFFALSE 16078
// exit ;
16076: GO 16107
// for i in tmp do
16078: LD_ADDR_VAR 0 1
16082: PUSH
16083: LD_VAR 0 2
16087: PUSH
16088: FOR_IN
16089: IFFALSE 16105
// begin SetLives ( i , 0 ) ;
16091: LD_VAR 0 1
16095: PPUSH
16096: LD_INT 0
16098: PPUSH
16099: CALL_OW 234
// end ;
16103: GO 16088
16105: POP
16106: POP
// end ;
16107: PPOPN 2
16109: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
16110: LD_EXP 38
16114: PUSH
16115: LD_EXP 44
16119: AND
16120: IFFALSE 16204
16122: GO 16124
16124: DISABLE
16125: LD_INT 0
16127: PPUSH
16128: PPUSH
// begin enable ;
16129: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
16130: LD_ADDR_VAR 0 2
16134: PUSH
16135: LD_INT 22
16137: PUSH
16138: LD_OWVAR 2
16142: PUSH
16143: EMPTY
16144: LIST
16145: LIST
16146: PUSH
16147: LD_INT 32
16149: PUSH
16150: LD_INT 3
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: PPUSH
16161: CALL_OW 69
16165: ST_TO_ADDR
// if not tmp then
16166: LD_VAR 0 2
16170: NOT
16171: IFFALSE 16175
// exit ;
16173: GO 16204
// for i in tmp do
16175: LD_ADDR_VAR 0 1
16179: PUSH
16180: LD_VAR 0 2
16184: PUSH
16185: FOR_IN
16186: IFFALSE 16202
// begin SetLives ( i , 0 ) ;
16188: LD_VAR 0 1
16192: PPUSH
16193: LD_INT 0
16195: PPUSH
16196: CALL_OW 234
// end ;
16200: GO 16185
16202: POP
16203: POP
// end ;
16204: PPOPN 2
16206: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
16207: LD_EXP 38
16211: PUSH
16212: LD_EXP 41
16216: AND
16217: IFFALSE 16310
16219: GO 16221
16221: DISABLE
16222: LD_INT 0
16224: PPUSH
// begin enable ;
16225: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
16226: LD_ADDR_VAR 0 1
16230: PUSH
16231: LD_INT 22
16233: PUSH
16234: LD_OWVAR 2
16238: PUSH
16239: EMPTY
16240: LIST
16241: LIST
16242: PUSH
16243: LD_INT 2
16245: PUSH
16246: LD_INT 25
16248: PUSH
16249: LD_INT 5
16251: PUSH
16252: EMPTY
16253: LIST
16254: LIST
16255: PUSH
16256: LD_INT 25
16258: PUSH
16259: LD_INT 9
16261: PUSH
16262: EMPTY
16263: LIST
16264: LIST
16265: PUSH
16266: LD_INT 25
16268: PUSH
16269: LD_INT 8
16271: PUSH
16272: EMPTY
16273: LIST
16274: LIST
16275: PUSH
16276: EMPTY
16277: LIST
16278: LIST
16279: LIST
16280: LIST
16281: PUSH
16282: EMPTY
16283: LIST
16284: LIST
16285: PPUSH
16286: CALL_OW 69
16290: PUSH
16291: FOR_IN
16292: IFFALSE 16308
// begin SetClass ( i , 1 ) ;
16294: LD_VAR 0 1
16298: PPUSH
16299: LD_INT 1
16301: PPUSH
16302: CALL_OW 336
// end ;
16306: GO 16291
16308: POP
16309: POP
// end ;
16310: PPOPN 1
16312: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16313: LD_EXP 38
16317: PUSH
16318: LD_EXP 42
16322: AND
16323: PUSH
16324: LD_OWVAR 65
16328: PUSH
16329: LD_INT 7
16331: LESS
16332: AND
16333: IFFALSE 16347
16335: GO 16337
16337: DISABLE
// begin enable ;
16338: ENABLE
// game_speed := 7 ;
16339: LD_ADDR_OWVAR 65
16343: PUSH
16344: LD_INT 7
16346: ST_TO_ADDR
// end ;
16347: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16348: LD_EXP 38
16352: PUSH
16353: LD_EXP 45
16357: AND
16358: IFFALSE 16560
16360: GO 16362
16362: DISABLE
16363: LD_INT 0
16365: PPUSH
16366: PPUSH
16367: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16368: LD_ADDR_VAR 0 3
16372: PUSH
16373: LD_INT 81
16375: PUSH
16376: LD_OWVAR 2
16380: PUSH
16381: EMPTY
16382: LIST
16383: LIST
16384: PUSH
16385: LD_INT 21
16387: PUSH
16388: LD_INT 1
16390: PUSH
16391: EMPTY
16392: LIST
16393: LIST
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: PPUSH
16399: CALL_OW 69
16403: ST_TO_ADDR
// if not tmp then
16404: LD_VAR 0 3
16408: NOT
16409: IFFALSE 16413
// exit ;
16411: GO 16560
// if tmp > 5 then
16413: LD_VAR 0 3
16417: PUSH
16418: LD_INT 5
16420: GREATER
16421: IFFALSE 16433
// k := 5 else
16423: LD_ADDR_VAR 0 2
16427: PUSH
16428: LD_INT 5
16430: ST_TO_ADDR
16431: GO 16443
// k := tmp ;
16433: LD_ADDR_VAR 0 2
16437: PUSH
16438: LD_VAR 0 3
16442: ST_TO_ADDR
// for i := 1 to k do
16443: LD_ADDR_VAR 0 1
16447: PUSH
16448: DOUBLE
16449: LD_INT 1
16451: DEC
16452: ST_TO_ADDR
16453: LD_VAR 0 2
16457: PUSH
16458: FOR_TO
16459: IFFALSE 16558
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
16461: LD_VAR 0 3
16465: PUSH
16466: LD_VAR 0 1
16470: ARRAY
16471: PPUSH
16472: LD_VAR 0 1
16476: PUSH
16477: LD_INT 4
16479: MOD
16480: PUSH
16481: LD_INT 1
16483: PLUS
16484: PPUSH
16485: CALL_OW 259
16489: PUSH
16490: LD_INT 10
16492: LESS
16493: IFFALSE 16556
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
16495: LD_VAR 0 3
16499: PUSH
16500: LD_VAR 0 1
16504: ARRAY
16505: PPUSH
16506: LD_VAR 0 1
16510: PUSH
16511: LD_INT 4
16513: MOD
16514: PUSH
16515: LD_INT 1
16517: PLUS
16518: PPUSH
16519: LD_VAR 0 3
16523: PUSH
16524: LD_VAR 0 1
16528: ARRAY
16529: PPUSH
16530: LD_VAR 0 1
16534: PUSH
16535: LD_INT 4
16537: MOD
16538: PUSH
16539: LD_INT 1
16541: PLUS
16542: PPUSH
16543: CALL_OW 259
16547: PUSH
16548: LD_INT 1
16550: PLUS
16551: PPUSH
16552: CALL_OW 237
16556: GO 16458
16558: POP
16559: POP
// end ;
16560: PPOPN 3
16562: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16563: LD_EXP 38
16567: PUSH
16568: LD_EXP 46
16572: AND
16573: IFFALSE 16593
16575: GO 16577
16577: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16578: LD_INT 4
16580: PPUSH
16581: LD_OWVAR 2
16585: PPUSH
16586: LD_INT 0
16588: PPUSH
16589: CALL_OW 324
16593: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16594: LD_EXP 38
16598: PUSH
16599: LD_EXP 75
16603: AND
16604: IFFALSE 16624
16606: GO 16608
16608: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16609: LD_INT 19
16611: PPUSH
16612: LD_OWVAR 2
16616: PPUSH
16617: LD_INT 0
16619: PPUSH
16620: CALL_OW 324
16624: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16625: LD_EXP 38
16629: PUSH
16630: LD_EXP 47
16634: AND
16635: IFFALSE 16737
16637: GO 16639
16639: DISABLE
16640: LD_INT 0
16642: PPUSH
16643: PPUSH
// begin enable ;
16644: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16645: LD_ADDR_VAR 0 2
16649: PUSH
16650: LD_INT 22
16652: PUSH
16653: LD_OWVAR 2
16657: PUSH
16658: EMPTY
16659: LIST
16660: LIST
16661: PUSH
16662: LD_INT 2
16664: PUSH
16665: LD_INT 34
16667: PUSH
16668: LD_INT 11
16670: PUSH
16671: EMPTY
16672: LIST
16673: LIST
16674: PUSH
16675: LD_INT 34
16677: PUSH
16678: LD_INT 30
16680: PUSH
16681: EMPTY
16682: LIST
16683: LIST
16684: PUSH
16685: EMPTY
16686: LIST
16687: LIST
16688: LIST
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: PPUSH
16694: CALL_OW 69
16698: ST_TO_ADDR
// if not tmp then
16699: LD_VAR 0 2
16703: NOT
16704: IFFALSE 16708
// exit ;
16706: GO 16737
// for i in tmp do
16708: LD_ADDR_VAR 0 1
16712: PUSH
16713: LD_VAR 0 2
16717: PUSH
16718: FOR_IN
16719: IFFALSE 16735
// begin SetLives ( i , 0 ) ;
16721: LD_VAR 0 1
16725: PPUSH
16726: LD_INT 0
16728: PPUSH
16729: CALL_OW 234
// end ;
16733: GO 16718
16735: POP
16736: POP
// end ;
16737: PPOPN 2
16739: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16740: LD_EXP 38
16744: PUSH
16745: LD_EXP 48
16749: AND
16750: IFFALSE 16770
16752: GO 16754
16754: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16755: LD_INT 32
16757: PPUSH
16758: LD_OWVAR 2
16762: PPUSH
16763: LD_INT 0
16765: PPUSH
16766: CALL_OW 324
16770: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16771: LD_EXP 38
16775: PUSH
16776: LD_EXP 49
16780: AND
16781: IFFALSE 16962
16783: GO 16785
16785: DISABLE
16786: LD_INT 0
16788: PPUSH
16789: PPUSH
16790: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
16791: LD_ADDR_VAR 0 2
16795: PUSH
16796: LD_INT 22
16798: PUSH
16799: LD_OWVAR 2
16803: PUSH
16804: EMPTY
16805: LIST
16806: LIST
16807: PUSH
16808: LD_INT 33
16810: PUSH
16811: LD_INT 3
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: PUSH
16818: EMPTY
16819: LIST
16820: LIST
16821: PPUSH
16822: CALL_OW 69
16826: ST_TO_ADDR
// if not tmp then
16827: LD_VAR 0 2
16831: NOT
16832: IFFALSE 16836
// exit ;
16834: GO 16962
// side := 0 ;
16836: LD_ADDR_VAR 0 3
16840: PUSH
16841: LD_INT 0
16843: ST_TO_ADDR
// for i := 1 to 8 do
16844: LD_ADDR_VAR 0 1
16848: PUSH
16849: DOUBLE
16850: LD_INT 1
16852: DEC
16853: ST_TO_ADDR
16854: LD_INT 8
16856: PUSH
16857: FOR_TO
16858: IFFALSE 16906
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
16860: LD_OWVAR 2
16864: PUSH
16865: LD_VAR 0 1
16869: NONEQUAL
16870: PUSH
16871: LD_OWVAR 2
16875: PPUSH
16876: LD_VAR 0 1
16880: PPUSH
16881: CALL_OW 81
16885: PUSH
16886: LD_INT 2
16888: EQUAL
16889: AND
16890: IFFALSE 16904
// begin side := i ;
16892: LD_ADDR_VAR 0 3
16896: PUSH
16897: LD_VAR 0 1
16901: ST_TO_ADDR
// break ;
16902: GO 16906
// end ;
16904: GO 16857
16906: POP
16907: POP
// if not side then
16908: LD_VAR 0 3
16912: NOT
16913: IFFALSE 16917
// exit ;
16915: GO 16962
// for i := 1 to tmp do
16917: LD_ADDR_VAR 0 1
16921: PUSH
16922: DOUBLE
16923: LD_INT 1
16925: DEC
16926: ST_TO_ADDR
16927: LD_VAR 0 2
16931: PUSH
16932: FOR_TO
16933: IFFALSE 16960
// if Prob ( 60 ) then
16935: LD_INT 60
16937: PPUSH
16938: CALL_OW 13
16942: IFFALSE 16958
// SetSide ( i , side ) ;
16944: LD_VAR 0 1
16948: PPUSH
16949: LD_VAR 0 3
16953: PPUSH
16954: CALL_OW 235
16958: GO 16932
16960: POP
16961: POP
// end ;
16962: PPOPN 3
16964: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
16965: LD_EXP 38
16969: PUSH
16970: LD_EXP 51
16974: AND
16975: IFFALSE 17094
16977: GO 16979
16979: DISABLE
16980: LD_INT 0
16982: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
16983: LD_ADDR_VAR 0 1
16987: PUSH
16988: LD_INT 22
16990: PUSH
16991: LD_OWVAR 2
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: LD_INT 21
17002: PUSH
17003: LD_INT 1
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: PUSH
17010: LD_INT 3
17012: PUSH
17013: LD_INT 23
17015: PUSH
17016: LD_INT 0
17018: PUSH
17019: EMPTY
17020: LIST
17021: LIST
17022: PUSH
17023: EMPTY
17024: LIST
17025: LIST
17026: PUSH
17027: EMPTY
17028: LIST
17029: LIST
17030: LIST
17031: PPUSH
17032: CALL_OW 69
17036: PUSH
17037: FOR_IN
17038: IFFALSE 17092
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
17040: LD_VAR 0 1
17044: PPUSH
17045: CALL_OW 257
17049: PUSH
17050: LD_INT 1
17052: PUSH
17053: LD_INT 2
17055: PUSH
17056: LD_INT 3
17058: PUSH
17059: LD_INT 4
17061: PUSH
17062: EMPTY
17063: LIST
17064: LIST
17065: LIST
17066: LIST
17067: IN
17068: IFFALSE 17090
// SetClass ( un , rand ( 1 , 4 ) ) ;
17070: LD_VAR 0 1
17074: PPUSH
17075: LD_INT 1
17077: PPUSH
17078: LD_INT 4
17080: PPUSH
17081: CALL_OW 12
17085: PPUSH
17086: CALL_OW 336
17090: GO 17037
17092: POP
17093: POP
// end ;
17094: PPOPN 1
17096: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
17097: LD_EXP 38
17101: PUSH
17102: LD_EXP 50
17106: AND
17107: IFFALSE 17186
17109: GO 17111
17111: DISABLE
17112: LD_INT 0
17114: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17115: LD_ADDR_VAR 0 1
17119: PUSH
17120: LD_INT 22
17122: PUSH
17123: LD_OWVAR 2
17127: PUSH
17128: EMPTY
17129: LIST
17130: LIST
17131: PUSH
17132: LD_INT 21
17134: PUSH
17135: LD_INT 3
17137: PUSH
17138: EMPTY
17139: LIST
17140: LIST
17141: PUSH
17142: EMPTY
17143: LIST
17144: LIST
17145: PPUSH
17146: CALL_OW 69
17150: ST_TO_ADDR
// if not tmp then
17151: LD_VAR 0 1
17155: NOT
17156: IFFALSE 17160
// exit ;
17158: GO 17186
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
17160: LD_VAR 0 1
17164: PUSH
17165: LD_INT 1
17167: PPUSH
17168: LD_VAR 0 1
17172: PPUSH
17173: CALL_OW 12
17177: ARRAY
17178: PPUSH
17179: LD_INT 100
17181: PPUSH
17182: CALL_OW 234
// end ;
17186: PPOPN 1
17188: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
17189: LD_EXP 38
17193: PUSH
17194: LD_EXP 52
17198: AND
17199: IFFALSE 17297
17201: GO 17203
17203: DISABLE
17204: LD_INT 0
17206: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
17207: LD_ADDR_VAR 0 1
17211: PUSH
17212: LD_INT 22
17214: PUSH
17215: LD_OWVAR 2
17219: PUSH
17220: EMPTY
17221: LIST
17222: LIST
17223: PUSH
17224: LD_INT 21
17226: PUSH
17227: LD_INT 1
17229: PUSH
17230: EMPTY
17231: LIST
17232: LIST
17233: PUSH
17234: EMPTY
17235: LIST
17236: LIST
17237: PPUSH
17238: CALL_OW 69
17242: ST_TO_ADDR
// if not tmp then
17243: LD_VAR 0 1
17247: NOT
17248: IFFALSE 17252
// exit ;
17250: GO 17297
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
17252: LD_VAR 0 1
17256: PUSH
17257: LD_INT 1
17259: PPUSH
17260: LD_VAR 0 1
17264: PPUSH
17265: CALL_OW 12
17269: ARRAY
17270: PPUSH
17271: LD_INT 1
17273: PPUSH
17274: LD_INT 4
17276: PPUSH
17277: CALL_OW 12
17281: PPUSH
17282: LD_INT 3000
17284: PPUSH
17285: LD_INT 9000
17287: PPUSH
17288: CALL_OW 12
17292: PPUSH
17293: CALL_OW 492
// end ;
17297: PPOPN 1
17299: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17300: LD_EXP 38
17304: PUSH
17305: LD_EXP 53
17309: AND
17310: IFFALSE 17330
17312: GO 17314
17314: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17315: LD_INT 1
17317: PPUSH
17318: LD_OWVAR 2
17322: PPUSH
17323: LD_INT 0
17325: PPUSH
17326: CALL_OW 324
17330: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17331: LD_EXP 38
17335: PUSH
17336: LD_EXP 54
17340: AND
17341: IFFALSE 17424
17343: GO 17345
17345: DISABLE
17346: LD_INT 0
17348: PPUSH
17349: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17350: LD_ADDR_VAR 0 2
17354: PUSH
17355: LD_INT 22
17357: PUSH
17358: LD_OWVAR 2
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: PUSH
17367: LD_INT 21
17369: PUSH
17370: LD_INT 3
17372: PUSH
17373: EMPTY
17374: LIST
17375: LIST
17376: PUSH
17377: EMPTY
17378: LIST
17379: LIST
17380: PPUSH
17381: CALL_OW 69
17385: ST_TO_ADDR
// if not tmp then
17386: LD_VAR 0 2
17390: NOT
17391: IFFALSE 17395
// exit ;
17393: GO 17424
// for i in tmp do
17395: LD_ADDR_VAR 0 1
17399: PUSH
17400: LD_VAR 0 2
17404: PUSH
17405: FOR_IN
17406: IFFALSE 17422
// SetBLevel ( i , 10 ) ;
17408: LD_VAR 0 1
17412: PPUSH
17413: LD_INT 10
17415: PPUSH
17416: CALL_OW 241
17420: GO 17405
17422: POP
17423: POP
// end ;
17424: PPOPN 2
17426: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17427: LD_EXP 38
17431: PUSH
17432: LD_EXP 55
17436: AND
17437: IFFALSE 17548
17439: GO 17441
17441: DISABLE
17442: LD_INT 0
17444: PPUSH
17445: PPUSH
17446: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17447: LD_ADDR_VAR 0 3
17451: PUSH
17452: LD_INT 22
17454: PUSH
17455: LD_OWVAR 2
17459: PUSH
17460: EMPTY
17461: LIST
17462: LIST
17463: PUSH
17464: LD_INT 25
17466: PUSH
17467: LD_INT 1
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: PUSH
17474: EMPTY
17475: LIST
17476: LIST
17477: PPUSH
17478: CALL_OW 69
17482: ST_TO_ADDR
// if not tmp then
17483: LD_VAR 0 3
17487: NOT
17488: IFFALSE 17492
// exit ;
17490: GO 17548
// un := tmp [ rand ( 1 , tmp ) ] ;
17492: LD_ADDR_VAR 0 2
17496: PUSH
17497: LD_VAR 0 3
17501: PUSH
17502: LD_INT 1
17504: PPUSH
17505: LD_VAR 0 3
17509: PPUSH
17510: CALL_OW 12
17514: ARRAY
17515: ST_TO_ADDR
// if Crawls ( un ) then
17516: LD_VAR 0 2
17520: PPUSH
17521: CALL_OW 318
17525: IFFALSE 17536
// ComWalk ( un ) ;
17527: LD_VAR 0 2
17531: PPUSH
17532: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17536: LD_VAR 0 2
17540: PPUSH
17541: LD_INT 5
17543: PPUSH
17544: CALL_OW 336
// end ;
17548: PPOPN 3
17550: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17551: LD_EXP 38
17555: PUSH
17556: LD_EXP 56
17560: AND
17561: PUSH
17562: LD_OWVAR 67
17566: PUSH
17567: LD_INT 3
17569: LESS
17570: AND
17571: IFFALSE 17590
17573: GO 17575
17575: DISABLE
// Difficulty := Difficulty + 1 ;
17576: LD_ADDR_OWVAR 67
17580: PUSH
17581: LD_OWVAR 67
17585: PUSH
17586: LD_INT 1
17588: PLUS
17589: ST_TO_ADDR
17590: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17591: LD_EXP 38
17595: PUSH
17596: LD_EXP 57
17600: AND
17601: IFFALSE 17704
17603: GO 17605
17605: DISABLE
17606: LD_INT 0
17608: PPUSH
// begin for i := 1 to 5 do
17609: LD_ADDR_VAR 0 1
17613: PUSH
17614: DOUBLE
17615: LD_INT 1
17617: DEC
17618: ST_TO_ADDR
17619: LD_INT 5
17621: PUSH
17622: FOR_TO
17623: IFFALSE 17702
// begin uc_nation := nation_nature ;
17625: LD_ADDR_OWVAR 21
17629: PUSH
17630: LD_INT 0
17632: ST_TO_ADDR
// uc_side := 0 ;
17633: LD_ADDR_OWVAR 20
17637: PUSH
17638: LD_INT 0
17640: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17641: LD_ADDR_OWVAR 29
17645: PUSH
17646: LD_INT 12
17648: PUSH
17649: LD_INT 12
17651: PUSH
17652: EMPTY
17653: LIST
17654: LIST
17655: ST_TO_ADDR
// hc_agressivity := 20 ;
17656: LD_ADDR_OWVAR 35
17660: PUSH
17661: LD_INT 20
17663: ST_TO_ADDR
// hc_class := class_tiger ;
17664: LD_ADDR_OWVAR 28
17668: PUSH
17669: LD_INT 14
17671: ST_TO_ADDR
// hc_gallery :=  ;
17672: LD_ADDR_OWVAR 33
17676: PUSH
17677: LD_STRING 
17679: ST_TO_ADDR
// hc_name :=  ;
17680: LD_ADDR_OWVAR 26
17684: PUSH
17685: LD_STRING 
17687: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17688: CALL_OW 44
17692: PPUSH
17693: LD_INT 0
17695: PPUSH
17696: CALL_OW 51
// end ;
17700: GO 17622
17702: POP
17703: POP
// end ;
17704: PPOPN 1
17706: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17707: LD_EXP 38
17711: PUSH
17712: LD_EXP 58
17716: AND
17717: IFFALSE 17726
17719: GO 17721
17721: DISABLE
// StreamSibBomb ;
17722: CALL 17727 0 0
17726: END
// export function StreamSibBomb ; var i , x , y ; begin
17727: LD_INT 0
17729: PPUSH
17730: PPUSH
17731: PPUSH
17732: PPUSH
// result := false ;
17733: LD_ADDR_VAR 0 1
17737: PUSH
17738: LD_INT 0
17740: ST_TO_ADDR
// for i := 1 to 16 do
17741: LD_ADDR_VAR 0 2
17745: PUSH
17746: DOUBLE
17747: LD_INT 1
17749: DEC
17750: ST_TO_ADDR
17751: LD_INT 16
17753: PUSH
17754: FOR_TO
17755: IFFALSE 17954
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17757: LD_ADDR_VAR 0 3
17761: PUSH
17762: LD_INT 10
17764: PUSH
17765: LD_INT 20
17767: PUSH
17768: LD_INT 30
17770: PUSH
17771: LD_INT 40
17773: PUSH
17774: LD_INT 50
17776: PUSH
17777: LD_INT 60
17779: PUSH
17780: LD_INT 70
17782: PUSH
17783: LD_INT 80
17785: PUSH
17786: LD_INT 90
17788: PUSH
17789: LD_INT 100
17791: PUSH
17792: LD_INT 110
17794: PUSH
17795: LD_INT 120
17797: PUSH
17798: LD_INT 130
17800: PUSH
17801: LD_INT 140
17803: PUSH
17804: LD_INT 150
17806: PUSH
17807: EMPTY
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: LIST
17819: LIST
17820: LIST
17821: LIST
17822: LIST
17823: PUSH
17824: LD_INT 1
17826: PPUSH
17827: LD_INT 15
17829: PPUSH
17830: CALL_OW 12
17834: ARRAY
17835: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17836: LD_ADDR_VAR 0 4
17840: PUSH
17841: LD_INT 10
17843: PUSH
17844: LD_INT 20
17846: PUSH
17847: LD_INT 30
17849: PUSH
17850: LD_INT 40
17852: PUSH
17853: LD_INT 50
17855: PUSH
17856: LD_INT 60
17858: PUSH
17859: LD_INT 70
17861: PUSH
17862: LD_INT 80
17864: PUSH
17865: LD_INT 90
17867: PUSH
17868: LD_INT 100
17870: PUSH
17871: LD_INT 110
17873: PUSH
17874: LD_INT 120
17876: PUSH
17877: LD_INT 130
17879: PUSH
17880: LD_INT 140
17882: PUSH
17883: LD_INT 150
17885: PUSH
17886: EMPTY
17887: LIST
17888: LIST
17889: LIST
17890: LIST
17891: LIST
17892: LIST
17893: LIST
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: LIST
17900: LIST
17901: LIST
17902: PUSH
17903: LD_INT 1
17905: PPUSH
17906: LD_INT 15
17908: PPUSH
17909: CALL_OW 12
17913: ARRAY
17914: ST_TO_ADDR
// if ValidHex ( x , y ) then
17915: LD_VAR 0 3
17919: PPUSH
17920: LD_VAR 0 4
17924: PPUSH
17925: CALL_OW 488
17929: IFFALSE 17952
// begin result := [ x , y ] ;
17931: LD_ADDR_VAR 0 1
17935: PUSH
17936: LD_VAR 0 3
17940: PUSH
17941: LD_VAR 0 4
17945: PUSH
17946: EMPTY
17947: LIST
17948: LIST
17949: ST_TO_ADDR
// break ;
17950: GO 17954
// end ; end ;
17952: GO 17754
17954: POP
17955: POP
// if result then
17956: LD_VAR 0 1
17960: IFFALSE 18020
// begin ToLua ( playSibBomb() ) ;
17962: LD_STRING playSibBomb()
17964: PPUSH
17965: CALL_OW 559
// wait ( 0 0$14 ) ;
17969: LD_INT 490
17971: PPUSH
17972: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
17976: LD_VAR 0 1
17980: PUSH
17981: LD_INT 1
17983: ARRAY
17984: PPUSH
17985: LD_VAR 0 1
17989: PUSH
17990: LD_INT 2
17992: ARRAY
17993: PPUSH
17994: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
17998: LD_VAR 0 1
18002: PUSH
18003: LD_INT 1
18005: ARRAY
18006: PPUSH
18007: LD_VAR 0 1
18011: PUSH
18012: LD_INT 2
18014: ARRAY
18015: PPUSH
18016: CALL_OW 429
// end ; end ;
18020: LD_VAR 0 1
18024: RET
// every 0 0$1 trigger StreamModeActive and sReset do
18025: LD_EXP 38
18029: PUSH
18030: LD_EXP 60
18034: AND
18035: IFFALSE 18047
18037: GO 18039
18039: DISABLE
// YouLost (  ) ;
18040: LD_STRING 
18042: PPUSH
18043: CALL_OW 104
18047: END
// every 0 0$1 trigger StreamModeActive and sFog do
18048: LD_EXP 38
18052: PUSH
18053: LD_EXP 59
18057: AND
18058: IFFALSE 18072
18060: GO 18062
18062: DISABLE
// FogOff ( your_side ) ;
18063: LD_OWVAR 2
18067: PPUSH
18068: CALL_OW 344
18072: END
// every 0 0$1 trigger StreamModeActive and sSun do
18073: LD_EXP 38
18077: PUSH
18078: LD_EXP 61
18082: AND
18083: IFFALSE 18111
18085: GO 18087
18087: DISABLE
// begin solar_recharge_percent := 0 ;
18088: LD_ADDR_OWVAR 79
18092: PUSH
18093: LD_INT 0
18095: ST_TO_ADDR
// wait ( 5 5$00 ) ;
18096: LD_INT 10500
18098: PPUSH
18099: CALL_OW 67
// solar_recharge_percent := 100 ;
18103: LD_ADDR_OWVAR 79
18107: PUSH
18108: LD_INT 100
18110: ST_TO_ADDR
// end ;
18111: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
18112: LD_EXP 38
18116: PUSH
18117: LD_EXP 62
18121: AND
18122: IFFALSE 18361
18124: GO 18126
18126: DISABLE
18127: LD_INT 0
18129: PPUSH
18130: PPUSH
18131: PPUSH
// begin tmp := [ ] ;
18132: LD_ADDR_VAR 0 3
18136: PUSH
18137: EMPTY
18138: ST_TO_ADDR
// for i := 1 to 6 do
18139: LD_ADDR_VAR 0 1
18143: PUSH
18144: DOUBLE
18145: LD_INT 1
18147: DEC
18148: ST_TO_ADDR
18149: LD_INT 6
18151: PUSH
18152: FOR_TO
18153: IFFALSE 18258
// begin uc_nation := nation_nature ;
18155: LD_ADDR_OWVAR 21
18159: PUSH
18160: LD_INT 0
18162: ST_TO_ADDR
// uc_side := 0 ;
18163: LD_ADDR_OWVAR 20
18167: PUSH
18168: LD_INT 0
18170: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
18171: LD_ADDR_OWVAR 29
18175: PUSH
18176: LD_INT 12
18178: PUSH
18179: LD_INT 12
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: ST_TO_ADDR
// hc_agressivity := 20 ;
18186: LD_ADDR_OWVAR 35
18190: PUSH
18191: LD_INT 20
18193: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
18194: LD_ADDR_OWVAR 28
18198: PUSH
18199: LD_INT 17
18201: ST_TO_ADDR
// hc_gallery :=  ;
18202: LD_ADDR_OWVAR 33
18206: PUSH
18207: LD_STRING 
18209: ST_TO_ADDR
// hc_name :=  ;
18210: LD_ADDR_OWVAR 26
18214: PUSH
18215: LD_STRING 
18217: ST_TO_ADDR
// un := CreateHuman ;
18218: LD_ADDR_VAR 0 2
18222: PUSH
18223: CALL_OW 44
18227: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
18228: LD_VAR 0 2
18232: PPUSH
18233: LD_INT 1
18235: PPUSH
18236: CALL_OW 51
// tmp := tmp ^ un ;
18240: LD_ADDR_VAR 0 3
18244: PUSH
18245: LD_VAR 0 3
18249: PUSH
18250: LD_VAR 0 2
18254: ADD
18255: ST_TO_ADDR
// end ;
18256: GO 18152
18258: POP
18259: POP
// repeat wait ( 0 0$1 ) ;
18260: LD_INT 35
18262: PPUSH
18263: CALL_OW 67
// for un in tmp do
18267: LD_ADDR_VAR 0 2
18271: PUSH
18272: LD_VAR 0 3
18276: PUSH
18277: FOR_IN
18278: IFFALSE 18352
// begin if IsDead ( un ) then
18280: LD_VAR 0 2
18284: PPUSH
18285: CALL_OW 301
18289: IFFALSE 18309
// begin tmp := tmp diff un ;
18291: LD_ADDR_VAR 0 3
18295: PUSH
18296: LD_VAR 0 3
18300: PUSH
18301: LD_VAR 0 2
18305: DIFF
18306: ST_TO_ADDR
// continue ;
18307: GO 18277
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18309: LD_VAR 0 2
18313: PPUSH
18314: LD_INT 3
18316: PUSH
18317: LD_INT 22
18319: PUSH
18320: LD_INT 0
18322: PUSH
18323: EMPTY
18324: LIST
18325: LIST
18326: PUSH
18327: EMPTY
18328: LIST
18329: LIST
18330: PPUSH
18331: CALL_OW 69
18335: PPUSH
18336: LD_VAR 0 2
18340: PPUSH
18341: CALL_OW 74
18345: PPUSH
18346: CALL_OW 115
// end ;
18350: GO 18277
18352: POP
18353: POP
// until not tmp ;
18354: LD_VAR 0 3
18358: NOT
18359: IFFALSE 18260
// end ;
18361: PPOPN 3
18363: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18364: LD_EXP 38
18368: PUSH
18369: LD_EXP 63
18373: AND
18374: IFFALSE 18428
18376: GO 18378
18378: DISABLE
// begin ToLua ( displayTroll(); ) ;
18379: LD_STRING displayTroll();
18381: PPUSH
18382: CALL_OW 559
// wait ( 3 3$00 ) ;
18386: LD_INT 6300
18388: PPUSH
18389: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18393: LD_STRING hideTroll();
18395: PPUSH
18396: CALL_OW 559
// wait ( 1 1$00 ) ;
18400: LD_INT 2100
18402: PPUSH
18403: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18407: LD_STRING displayTroll();
18409: PPUSH
18410: CALL_OW 559
// wait ( 1 1$00 ) ;
18414: LD_INT 2100
18416: PPUSH
18417: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18421: LD_STRING hideTroll();
18423: PPUSH
18424: CALL_OW 559
// end ;
18428: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18429: LD_EXP 38
18433: PUSH
18434: LD_EXP 64
18438: AND
18439: IFFALSE 18502
18441: GO 18443
18443: DISABLE
18444: LD_INT 0
18446: PPUSH
// begin p := 0 ;
18447: LD_ADDR_VAR 0 1
18451: PUSH
18452: LD_INT 0
18454: ST_TO_ADDR
// repeat game_speed := 1 ;
18455: LD_ADDR_OWVAR 65
18459: PUSH
18460: LD_INT 1
18462: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18463: LD_INT 35
18465: PPUSH
18466: CALL_OW 67
// p := p + 1 ;
18470: LD_ADDR_VAR 0 1
18474: PUSH
18475: LD_VAR 0 1
18479: PUSH
18480: LD_INT 1
18482: PLUS
18483: ST_TO_ADDR
// until p >= 60 ;
18484: LD_VAR 0 1
18488: PUSH
18489: LD_INT 60
18491: GREATEREQUAL
18492: IFFALSE 18455
// game_speed := 4 ;
18494: LD_ADDR_OWVAR 65
18498: PUSH
18499: LD_INT 4
18501: ST_TO_ADDR
// end ;
18502: PPOPN 1
18504: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
18505: LD_EXP 38
18509: PUSH
18510: LD_EXP 65
18514: AND
18515: IFFALSE 18661
18517: GO 18519
18519: DISABLE
18520: LD_INT 0
18522: PPUSH
18523: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18524: LD_ADDR_VAR 0 1
18528: PUSH
18529: LD_INT 22
18531: PUSH
18532: LD_OWVAR 2
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: PUSH
18541: LD_INT 2
18543: PUSH
18544: LD_INT 30
18546: PUSH
18547: LD_INT 0
18549: PUSH
18550: EMPTY
18551: LIST
18552: LIST
18553: PUSH
18554: LD_INT 30
18556: PUSH
18557: LD_INT 1
18559: PUSH
18560: EMPTY
18561: LIST
18562: LIST
18563: PUSH
18564: EMPTY
18565: LIST
18566: LIST
18567: LIST
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PPUSH
18573: CALL_OW 69
18577: ST_TO_ADDR
// if not depot then
18578: LD_VAR 0 1
18582: NOT
18583: IFFALSE 18587
// exit ;
18585: GO 18661
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18587: LD_ADDR_VAR 0 2
18591: PUSH
18592: LD_VAR 0 1
18596: PUSH
18597: LD_INT 1
18599: PPUSH
18600: LD_VAR 0 1
18604: PPUSH
18605: CALL_OW 12
18609: ARRAY
18610: PPUSH
18611: CALL_OW 274
18615: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18616: LD_VAR 0 2
18620: PPUSH
18621: LD_INT 1
18623: PPUSH
18624: LD_INT 0
18626: PPUSH
18627: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18631: LD_VAR 0 2
18635: PPUSH
18636: LD_INT 2
18638: PPUSH
18639: LD_INT 0
18641: PPUSH
18642: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18646: LD_VAR 0 2
18650: PPUSH
18651: LD_INT 3
18653: PPUSH
18654: LD_INT 0
18656: PPUSH
18657: CALL_OW 277
// end ;
18661: PPOPN 2
18663: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18664: LD_EXP 38
18668: PUSH
18669: LD_EXP 66
18673: AND
18674: IFFALSE 18771
18676: GO 18678
18678: DISABLE
18679: LD_INT 0
18681: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18682: LD_ADDR_VAR 0 1
18686: PUSH
18687: LD_INT 22
18689: PUSH
18690: LD_OWVAR 2
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PUSH
18699: LD_INT 21
18701: PUSH
18702: LD_INT 1
18704: PUSH
18705: EMPTY
18706: LIST
18707: LIST
18708: PUSH
18709: LD_INT 3
18711: PUSH
18712: LD_INT 23
18714: PUSH
18715: LD_INT 0
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: PUSH
18722: EMPTY
18723: LIST
18724: LIST
18725: PUSH
18726: EMPTY
18727: LIST
18728: LIST
18729: LIST
18730: PPUSH
18731: CALL_OW 69
18735: ST_TO_ADDR
// if not tmp then
18736: LD_VAR 0 1
18740: NOT
18741: IFFALSE 18745
// exit ;
18743: GO 18771
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18745: LD_VAR 0 1
18749: PUSH
18750: LD_INT 1
18752: PPUSH
18753: LD_VAR 0 1
18757: PPUSH
18758: CALL_OW 12
18762: ARRAY
18763: PPUSH
18764: LD_INT 200
18766: PPUSH
18767: CALL_OW 234
// end ;
18771: PPOPN 1
18773: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
18774: LD_EXP 38
18778: PUSH
18779: LD_EXP 67
18783: AND
18784: IFFALSE 18863
18786: GO 18788
18788: DISABLE
18789: LD_INT 0
18791: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
18792: LD_ADDR_VAR 0 1
18796: PUSH
18797: LD_INT 22
18799: PUSH
18800: LD_OWVAR 2
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PUSH
18809: LD_INT 21
18811: PUSH
18812: LD_INT 2
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: PPUSH
18823: CALL_OW 69
18827: ST_TO_ADDR
// if not tmp then
18828: LD_VAR 0 1
18832: NOT
18833: IFFALSE 18837
// exit ;
18835: GO 18863
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
18837: LD_VAR 0 1
18841: PUSH
18842: LD_INT 1
18844: PPUSH
18845: LD_VAR 0 1
18849: PPUSH
18850: CALL_OW 12
18854: ARRAY
18855: PPUSH
18856: LD_INT 60
18858: PPUSH
18859: CALL_OW 234
// end ;
18863: PPOPN 1
18865: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
18866: LD_EXP 38
18870: PUSH
18871: LD_EXP 68
18875: AND
18876: IFFALSE 18975
18878: GO 18880
18880: DISABLE
18881: LD_INT 0
18883: PPUSH
18884: PPUSH
// begin enable ;
18885: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
18886: LD_ADDR_VAR 0 1
18890: PUSH
18891: LD_INT 22
18893: PUSH
18894: LD_OWVAR 2
18898: PUSH
18899: EMPTY
18900: LIST
18901: LIST
18902: PUSH
18903: LD_INT 61
18905: PUSH
18906: EMPTY
18907: LIST
18908: PUSH
18909: LD_INT 33
18911: PUSH
18912: LD_INT 2
18914: PUSH
18915: EMPTY
18916: LIST
18917: LIST
18918: PUSH
18919: EMPTY
18920: LIST
18921: LIST
18922: LIST
18923: PPUSH
18924: CALL_OW 69
18928: ST_TO_ADDR
// if not tmp then
18929: LD_VAR 0 1
18933: NOT
18934: IFFALSE 18938
// exit ;
18936: GO 18975
// for i in tmp do
18938: LD_ADDR_VAR 0 2
18942: PUSH
18943: LD_VAR 0 1
18947: PUSH
18948: FOR_IN
18949: IFFALSE 18973
// if IsControledBy ( i ) then
18951: LD_VAR 0 2
18955: PPUSH
18956: CALL_OW 312
18960: IFFALSE 18971
// ComUnlink ( i ) ;
18962: LD_VAR 0 2
18966: PPUSH
18967: CALL_OW 136
18971: GO 18948
18973: POP
18974: POP
// end ;
18975: PPOPN 2
18977: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
18978: LD_EXP 38
18982: PUSH
18983: LD_EXP 69
18987: AND
18988: IFFALSE 19128
18990: GO 18992
18992: DISABLE
18993: LD_INT 0
18995: PPUSH
18996: PPUSH
// begin ToLua ( displayPowell(); ) ;
18997: LD_STRING displayPowell();
18999: PPUSH
19000: CALL_OW 559
// uc_side := 0 ;
19004: LD_ADDR_OWVAR 20
19008: PUSH
19009: LD_INT 0
19011: ST_TO_ADDR
// uc_nation := 2 ;
19012: LD_ADDR_OWVAR 21
19016: PUSH
19017: LD_INT 2
19019: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
19020: LD_ADDR_OWVAR 37
19024: PUSH
19025: LD_INT 14
19027: ST_TO_ADDR
// vc_engine := engine_siberite ;
19028: LD_ADDR_OWVAR 39
19032: PUSH
19033: LD_INT 3
19035: ST_TO_ADDR
// vc_control := control_apeman ;
19036: LD_ADDR_OWVAR 38
19040: PUSH
19041: LD_INT 5
19043: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
19044: LD_ADDR_OWVAR 40
19048: PUSH
19049: LD_INT 29
19051: ST_TO_ADDR
// un := CreateVehicle ;
19052: LD_ADDR_VAR 0 2
19056: PUSH
19057: CALL_OW 45
19061: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19062: LD_VAR 0 2
19066: PPUSH
19067: LD_INT 1
19069: PPUSH
19070: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19074: LD_INT 35
19076: PPUSH
19077: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19081: LD_VAR 0 2
19085: PPUSH
19086: LD_INT 22
19088: PUSH
19089: LD_OWVAR 2
19093: PUSH
19094: EMPTY
19095: LIST
19096: LIST
19097: PPUSH
19098: CALL_OW 69
19102: PPUSH
19103: LD_VAR 0 2
19107: PPUSH
19108: CALL_OW 74
19112: PPUSH
19113: CALL_OW 115
// until IsDead ( un ) ;
19117: LD_VAR 0 2
19121: PPUSH
19122: CALL_OW 301
19126: IFFALSE 19074
// end ;
19128: PPOPN 2
19130: END
// every 0 0$1 trigger StreamModeActive and sStu do
19131: LD_EXP 38
19135: PUSH
19136: LD_EXP 77
19140: AND
19141: IFFALSE 19157
19143: GO 19145
19145: DISABLE
// begin ToLua ( displayStucuk(); ) ;
19146: LD_STRING displayStucuk();
19148: PPUSH
19149: CALL_OW 559
// ResetFog ;
19153: CALL_OW 335
// end ;
19157: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
19158: LD_EXP 38
19162: PUSH
19163: LD_EXP 70
19167: AND
19168: IFFALSE 19309
19170: GO 19172
19172: DISABLE
19173: LD_INT 0
19175: PPUSH
19176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19177: LD_ADDR_VAR 0 2
19181: PUSH
19182: LD_INT 22
19184: PUSH
19185: LD_OWVAR 2
19189: PUSH
19190: EMPTY
19191: LIST
19192: LIST
19193: PUSH
19194: LD_INT 21
19196: PUSH
19197: LD_INT 1
19199: PUSH
19200: EMPTY
19201: LIST
19202: LIST
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: PPUSH
19208: CALL_OW 69
19212: ST_TO_ADDR
// if not tmp then
19213: LD_VAR 0 2
19217: NOT
19218: IFFALSE 19222
// exit ;
19220: GO 19309
// un := tmp [ rand ( 1 , tmp ) ] ;
19222: LD_ADDR_VAR 0 1
19226: PUSH
19227: LD_VAR 0 2
19231: PUSH
19232: LD_INT 1
19234: PPUSH
19235: LD_VAR 0 2
19239: PPUSH
19240: CALL_OW 12
19244: ARRAY
19245: ST_TO_ADDR
// SetSide ( un , 0 ) ;
19246: LD_VAR 0 1
19250: PPUSH
19251: LD_INT 0
19253: PPUSH
19254: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
19258: LD_VAR 0 1
19262: PPUSH
19263: LD_OWVAR 3
19267: PUSH
19268: LD_VAR 0 1
19272: DIFF
19273: PPUSH
19274: LD_VAR 0 1
19278: PPUSH
19279: CALL_OW 74
19283: PPUSH
19284: CALL_OW 115
// wait ( 0 0$20 ) ;
19288: LD_INT 700
19290: PPUSH
19291: CALL_OW 67
// SetSide ( un , your_side ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_OWVAR 2
19304: PPUSH
19305: CALL_OW 235
// end ;
19309: PPOPN 2
19311: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19312: LD_EXP 38
19316: PUSH
19317: LD_EXP 71
19321: AND
19322: IFFALSE 19428
19324: GO 19326
19326: DISABLE
19327: LD_INT 0
19329: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19330: LD_ADDR_VAR 0 1
19334: PUSH
19335: LD_INT 22
19337: PUSH
19338: LD_OWVAR 2
19342: PUSH
19343: EMPTY
19344: LIST
19345: LIST
19346: PUSH
19347: LD_INT 2
19349: PUSH
19350: LD_INT 30
19352: PUSH
19353: LD_INT 0
19355: PUSH
19356: EMPTY
19357: LIST
19358: LIST
19359: PUSH
19360: LD_INT 30
19362: PUSH
19363: LD_INT 1
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: PUSH
19370: EMPTY
19371: LIST
19372: LIST
19373: LIST
19374: PUSH
19375: EMPTY
19376: LIST
19377: LIST
19378: PPUSH
19379: CALL_OW 69
19383: ST_TO_ADDR
// if not depot then
19384: LD_VAR 0 1
19388: NOT
19389: IFFALSE 19393
// exit ;
19391: GO 19428
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19393: LD_VAR 0 1
19397: PUSH
19398: LD_INT 1
19400: ARRAY
19401: PPUSH
19402: CALL_OW 250
19406: PPUSH
19407: LD_VAR 0 1
19411: PUSH
19412: LD_INT 1
19414: ARRAY
19415: PPUSH
19416: CALL_OW 251
19420: PPUSH
19421: LD_INT 70
19423: PPUSH
19424: CALL_OW 495
// end ;
19428: PPOPN 1
19430: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19431: LD_EXP 38
19435: PUSH
19436: LD_EXP 72
19440: AND
19441: IFFALSE 19652
19443: GO 19445
19445: DISABLE
19446: LD_INT 0
19448: PPUSH
19449: PPUSH
19450: PPUSH
19451: PPUSH
19452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19453: LD_ADDR_VAR 0 5
19457: PUSH
19458: LD_INT 22
19460: PUSH
19461: LD_OWVAR 2
19465: PUSH
19466: EMPTY
19467: LIST
19468: LIST
19469: PUSH
19470: LD_INT 21
19472: PUSH
19473: LD_INT 1
19475: PUSH
19476: EMPTY
19477: LIST
19478: LIST
19479: PUSH
19480: EMPTY
19481: LIST
19482: LIST
19483: PPUSH
19484: CALL_OW 69
19488: ST_TO_ADDR
// if not tmp then
19489: LD_VAR 0 5
19493: NOT
19494: IFFALSE 19498
// exit ;
19496: GO 19652
// for i in tmp do
19498: LD_ADDR_VAR 0 1
19502: PUSH
19503: LD_VAR 0 5
19507: PUSH
19508: FOR_IN
19509: IFFALSE 19650
// begin d := rand ( 0 , 5 ) ;
19511: LD_ADDR_VAR 0 4
19515: PUSH
19516: LD_INT 0
19518: PPUSH
19519: LD_INT 5
19521: PPUSH
19522: CALL_OW 12
19526: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19527: LD_ADDR_VAR 0 2
19531: PUSH
19532: LD_VAR 0 1
19536: PPUSH
19537: CALL_OW 250
19541: PPUSH
19542: LD_VAR 0 4
19546: PPUSH
19547: LD_INT 3
19549: PPUSH
19550: LD_INT 12
19552: PPUSH
19553: CALL_OW 12
19557: PPUSH
19558: CALL_OW 272
19562: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19563: LD_ADDR_VAR 0 3
19567: PUSH
19568: LD_VAR 0 1
19572: PPUSH
19573: CALL_OW 251
19577: PPUSH
19578: LD_VAR 0 4
19582: PPUSH
19583: LD_INT 3
19585: PPUSH
19586: LD_INT 12
19588: PPUSH
19589: CALL_OW 12
19593: PPUSH
19594: CALL_OW 273
19598: ST_TO_ADDR
// if ValidHex ( x , y ) then
19599: LD_VAR 0 2
19603: PPUSH
19604: LD_VAR 0 3
19608: PPUSH
19609: CALL_OW 488
19613: IFFALSE 19648
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19615: LD_VAR 0 1
19619: PPUSH
19620: LD_VAR 0 2
19624: PPUSH
19625: LD_VAR 0 3
19629: PPUSH
19630: LD_INT 3
19632: PPUSH
19633: LD_INT 6
19635: PPUSH
19636: CALL_OW 12
19640: PPUSH
19641: LD_INT 1
19643: PPUSH
19644: CALL_OW 483
// end ;
19648: GO 19508
19650: POP
19651: POP
// end ;
19652: PPOPN 5
19654: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19655: LD_EXP 38
19659: PUSH
19660: LD_EXP 73
19664: AND
19665: IFFALSE 19759
19667: GO 19669
19669: DISABLE
19670: LD_INT 0
19672: PPUSH
19673: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19674: LD_ADDR_VAR 0 2
19678: PUSH
19679: LD_INT 22
19681: PUSH
19682: LD_OWVAR 2
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: PUSH
19691: LD_INT 32
19693: PUSH
19694: LD_INT 1
19696: PUSH
19697: EMPTY
19698: LIST
19699: LIST
19700: PUSH
19701: LD_INT 21
19703: PUSH
19704: LD_INT 2
19706: PUSH
19707: EMPTY
19708: LIST
19709: LIST
19710: PUSH
19711: EMPTY
19712: LIST
19713: LIST
19714: LIST
19715: PPUSH
19716: CALL_OW 69
19720: ST_TO_ADDR
// if not tmp then
19721: LD_VAR 0 2
19725: NOT
19726: IFFALSE 19730
// exit ;
19728: GO 19759
// for i in tmp do
19730: LD_ADDR_VAR 0 1
19734: PUSH
19735: LD_VAR 0 2
19739: PUSH
19740: FOR_IN
19741: IFFALSE 19757
// SetFuel ( i , 0 ) ;
19743: LD_VAR 0 1
19747: PPUSH
19748: LD_INT 0
19750: PPUSH
19751: CALL_OW 240
19755: GO 19740
19757: POP
19758: POP
// end ;
19759: PPOPN 2
19761: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19762: LD_EXP 38
19766: PUSH
19767: LD_EXP 74
19771: AND
19772: IFFALSE 19838
19774: GO 19776
19776: DISABLE
19777: LD_INT 0
19779: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19780: LD_ADDR_VAR 0 1
19784: PUSH
19785: LD_INT 22
19787: PUSH
19788: LD_OWVAR 2
19792: PUSH
19793: EMPTY
19794: LIST
19795: LIST
19796: PUSH
19797: LD_INT 30
19799: PUSH
19800: LD_INT 29
19802: PUSH
19803: EMPTY
19804: LIST
19805: LIST
19806: PUSH
19807: EMPTY
19808: LIST
19809: LIST
19810: PPUSH
19811: CALL_OW 69
19815: ST_TO_ADDR
// if not tmp then
19816: LD_VAR 0 1
19820: NOT
19821: IFFALSE 19825
// exit ;
19823: GO 19838
// DestroyUnit ( tmp [ 1 ] ) ;
19825: LD_VAR 0 1
19829: PUSH
19830: LD_INT 1
19832: ARRAY
19833: PPUSH
19834: CALL_OW 65
// end ;
19838: PPOPN 1
19840: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
19841: LD_EXP 38
19845: PUSH
19846: LD_EXP 76
19850: AND
19851: IFFALSE 19980
19853: GO 19855
19855: DISABLE
19856: LD_INT 0
19858: PPUSH
// begin uc_side := 0 ;
19859: LD_ADDR_OWVAR 20
19863: PUSH
19864: LD_INT 0
19866: ST_TO_ADDR
// uc_nation := nation_arabian ;
19867: LD_ADDR_OWVAR 21
19871: PUSH
19872: LD_INT 2
19874: ST_TO_ADDR
// hc_gallery :=  ;
19875: LD_ADDR_OWVAR 33
19879: PUSH
19880: LD_STRING 
19882: ST_TO_ADDR
// hc_name :=  ;
19883: LD_ADDR_OWVAR 26
19887: PUSH
19888: LD_STRING 
19890: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
19891: LD_INT 1
19893: PPUSH
19894: LD_INT 11
19896: PPUSH
19897: LD_INT 10
19899: PPUSH
19900: CALL_OW 380
// un := CreateHuman ;
19904: LD_ADDR_VAR 0 1
19908: PUSH
19909: CALL_OW 44
19913: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19914: LD_VAR 0 1
19918: PPUSH
19919: LD_INT 1
19921: PPUSH
19922: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19926: LD_INT 35
19928: PPUSH
19929: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19933: LD_VAR 0 1
19937: PPUSH
19938: LD_INT 22
19940: PUSH
19941: LD_OWVAR 2
19945: PUSH
19946: EMPTY
19947: LIST
19948: LIST
19949: PPUSH
19950: CALL_OW 69
19954: PPUSH
19955: LD_VAR 0 1
19959: PPUSH
19960: CALL_OW 74
19964: PPUSH
19965: CALL_OW 115
// until IsDead ( un ) ;
19969: LD_VAR 0 1
19973: PPUSH
19974: CALL_OW 301
19978: IFFALSE 19926
// end ;
19980: PPOPN 1
19982: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
19983: LD_EXP 38
19987: PUSH
19988: LD_EXP 78
19992: AND
19993: IFFALSE 20005
19995: GO 19997
19997: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
19998: LD_STRING earthquake(getX(game), 0, 32)
20000: PPUSH
20001: CALL_OW 559
20005: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
20006: LD_EXP 38
20010: PUSH
20011: LD_EXP 79
20015: AND
20016: IFFALSE 20107
20018: GO 20020
20020: DISABLE
20021: LD_INT 0
20023: PPUSH
// begin enable ;
20024: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
20025: LD_ADDR_VAR 0 1
20029: PUSH
20030: LD_INT 22
20032: PUSH
20033: LD_OWVAR 2
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: LD_INT 21
20044: PUSH
20045: LD_INT 2
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: PUSH
20052: LD_INT 33
20054: PUSH
20055: LD_INT 3
20057: PUSH
20058: EMPTY
20059: LIST
20060: LIST
20061: PUSH
20062: EMPTY
20063: LIST
20064: LIST
20065: LIST
20066: PPUSH
20067: CALL_OW 69
20071: ST_TO_ADDR
// if not tmp then
20072: LD_VAR 0 1
20076: NOT
20077: IFFALSE 20081
// exit ;
20079: GO 20107
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20081: LD_VAR 0 1
20085: PUSH
20086: LD_INT 1
20088: PPUSH
20089: LD_VAR 0 1
20093: PPUSH
20094: CALL_OW 12
20098: ARRAY
20099: PPUSH
20100: LD_INT 1
20102: PPUSH
20103: CALL_OW 234
// end ;
20107: PPOPN 1
20109: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
20110: LD_EXP 38
20114: PUSH
20115: LD_EXP 80
20119: AND
20120: IFFALSE 20261
20122: GO 20124
20124: DISABLE
20125: LD_INT 0
20127: PPUSH
20128: PPUSH
20129: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20130: LD_ADDR_VAR 0 3
20134: PUSH
20135: LD_INT 22
20137: PUSH
20138: LD_OWVAR 2
20142: PUSH
20143: EMPTY
20144: LIST
20145: LIST
20146: PUSH
20147: LD_INT 25
20149: PUSH
20150: LD_INT 1
20152: PUSH
20153: EMPTY
20154: LIST
20155: LIST
20156: PUSH
20157: EMPTY
20158: LIST
20159: LIST
20160: PPUSH
20161: CALL_OW 69
20165: ST_TO_ADDR
// if not tmp then
20166: LD_VAR 0 3
20170: NOT
20171: IFFALSE 20175
// exit ;
20173: GO 20261
// un := tmp [ rand ( 1 , tmp ) ] ;
20175: LD_ADDR_VAR 0 2
20179: PUSH
20180: LD_VAR 0 3
20184: PUSH
20185: LD_INT 1
20187: PPUSH
20188: LD_VAR 0 3
20192: PPUSH
20193: CALL_OW 12
20197: ARRAY
20198: ST_TO_ADDR
// if Crawls ( un ) then
20199: LD_VAR 0 2
20203: PPUSH
20204: CALL_OW 318
20208: IFFALSE 20219
// ComWalk ( un ) ;
20210: LD_VAR 0 2
20214: PPUSH
20215: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
20219: LD_VAR 0 2
20223: PPUSH
20224: LD_INT 9
20226: PPUSH
20227: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
20231: LD_INT 28
20233: PPUSH
20234: LD_OWVAR 2
20238: PPUSH
20239: LD_INT 2
20241: PPUSH
20242: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
20246: LD_INT 29
20248: PPUSH
20249: LD_OWVAR 2
20253: PPUSH
20254: LD_INT 2
20256: PPUSH
20257: CALL_OW 322
// end ;
20261: PPOPN 3
20263: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
20264: LD_EXP 38
20268: PUSH
20269: LD_EXP 81
20273: AND
20274: IFFALSE 20385
20276: GO 20278
20278: DISABLE
20279: LD_INT 0
20281: PPUSH
20282: PPUSH
20283: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20284: LD_ADDR_VAR 0 3
20288: PUSH
20289: LD_INT 22
20291: PUSH
20292: LD_OWVAR 2
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: PUSH
20301: LD_INT 25
20303: PUSH
20304: LD_INT 1
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: PPUSH
20315: CALL_OW 69
20319: ST_TO_ADDR
// if not tmp then
20320: LD_VAR 0 3
20324: NOT
20325: IFFALSE 20329
// exit ;
20327: GO 20385
// un := tmp [ rand ( 1 , tmp ) ] ;
20329: LD_ADDR_VAR 0 2
20333: PUSH
20334: LD_VAR 0 3
20338: PUSH
20339: LD_INT 1
20341: PPUSH
20342: LD_VAR 0 3
20346: PPUSH
20347: CALL_OW 12
20351: ARRAY
20352: ST_TO_ADDR
// if Crawls ( un ) then
20353: LD_VAR 0 2
20357: PPUSH
20358: CALL_OW 318
20362: IFFALSE 20373
// ComWalk ( un ) ;
20364: LD_VAR 0 2
20368: PPUSH
20369: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20373: LD_VAR 0 2
20377: PPUSH
20378: LD_INT 8
20380: PPUSH
20381: CALL_OW 336
// end ;
20385: PPOPN 3
20387: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20388: LD_EXP 38
20392: PUSH
20393: LD_EXP 82
20397: AND
20398: IFFALSE 20542
20400: GO 20402
20402: DISABLE
20403: LD_INT 0
20405: PPUSH
20406: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20407: LD_ADDR_VAR 0 2
20411: PUSH
20412: LD_INT 22
20414: PUSH
20415: LD_OWVAR 2
20419: PUSH
20420: EMPTY
20421: LIST
20422: LIST
20423: PUSH
20424: LD_INT 21
20426: PUSH
20427: LD_INT 2
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: PUSH
20434: LD_INT 2
20436: PUSH
20437: LD_INT 34
20439: PUSH
20440: LD_INT 12
20442: PUSH
20443: EMPTY
20444: LIST
20445: LIST
20446: PUSH
20447: LD_INT 34
20449: PUSH
20450: LD_INT 51
20452: PUSH
20453: EMPTY
20454: LIST
20455: LIST
20456: PUSH
20457: LD_INT 34
20459: PUSH
20460: LD_INT 32
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: PUSH
20467: EMPTY
20468: LIST
20469: LIST
20470: LIST
20471: LIST
20472: PUSH
20473: EMPTY
20474: LIST
20475: LIST
20476: LIST
20477: PPUSH
20478: CALL_OW 69
20482: ST_TO_ADDR
// if not tmp then
20483: LD_VAR 0 2
20487: NOT
20488: IFFALSE 20492
// exit ;
20490: GO 20542
// for i in tmp do
20492: LD_ADDR_VAR 0 1
20496: PUSH
20497: LD_VAR 0 2
20501: PUSH
20502: FOR_IN
20503: IFFALSE 20540
// if GetCargo ( i , mat_artifact ) = 0 then
20505: LD_VAR 0 1
20509: PPUSH
20510: LD_INT 4
20512: PPUSH
20513: CALL_OW 289
20517: PUSH
20518: LD_INT 0
20520: EQUAL
20521: IFFALSE 20538
// SetCargo ( i , mat_siberit , 100 ) ;
20523: LD_VAR 0 1
20527: PPUSH
20528: LD_INT 3
20530: PPUSH
20531: LD_INT 100
20533: PPUSH
20534: CALL_OW 290
20538: GO 20502
20540: POP
20541: POP
// end ;
20542: PPOPN 2
20544: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20545: LD_EXP 38
20549: PUSH
20550: LD_EXP 83
20554: AND
20555: IFFALSE 20708
20557: GO 20559
20559: DISABLE
20560: LD_INT 0
20562: PPUSH
20563: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20564: LD_ADDR_VAR 0 2
20568: PUSH
20569: LD_INT 22
20571: PUSH
20572: LD_OWVAR 2
20576: PUSH
20577: EMPTY
20578: LIST
20579: LIST
20580: PPUSH
20581: CALL_OW 69
20585: ST_TO_ADDR
// if not tmp then
20586: LD_VAR 0 2
20590: NOT
20591: IFFALSE 20595
// exit ;
20593: GO 20708
// for i := 1 to 2 do
20595: LD_ADDR_VAR 0 1
20599: PUSH
20600: DOUBLE
20601: LD_INT 1
20603: DEC
20604: ST_TO_ADDR
20605: LD_INT 2
20607: PUSH
20608: FOR_TO
20609: IFFALSE 20706
// begin uc_side := your_side ;
20611: LD_ADDR_OWVAR 20
20615: PUSH
20616: LD_OWVAR 2
20620: ST_TO_ADDR
// uc_nation := nation_american ;
20621: LD_ADDR_OWVAR 21
20625: PUSH
20626: LD_INT 1
20628: ST_TO_ADDR
// vc_chassis := us_morphling ;
20629: LD_ADDR_OWVAR 37
20633: PUSH
20634: LD_INT 5
20636: ST_TO_ADDR
// vc_engine := engine_siberite ;
20637: LD_ADDR_OWVAR 39
20641: PUSH
20642: LD_INT 3
20644: ST_TO_ADDR
// vc_control := control_computer ;
20645: LD_ADDR_OWVAR 38
20649: PUSH
20650: LD_INT 3
20652: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20653: LD_ADDR_OWVAR 40
20657: PUSH
20658: LD_INT 10
20660: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
20661: CALL_OW 45
20665: PPUSH
20666: LD_VAR 0 2
20670: PUSH
20671: LD_INT 1
20673: ARRAY
20674: PPUSH
20675: CALL_OW 250
20679: PPUSH
20680: LD_VAR 0 2
20684: PUSH
20685: LD_INT 1
20687: ARRAY
20688: PPUSH
20689: CALL_OW 251
20693: PPUSH
20694: LD_INT 12
20696: PPUSH
20697: LD_INT 1
20699: PPUSH
20700: CALL_OW 50
// end ;
20704: GO 20608
20706: POP
20707: POP
// end ;
20708: PPOPN 2
20710: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20711: LD_EXP 38
20715: PUSH
20716: LD_EXP 84
20720: AND
20721: IFFALSE 20943
20723: GO 20725
20725: DISABLE
20726: LD_INT 0
20728: PPUSH
20729: PPUSH
20730: PPUSH
20731: PPUSH
20732: PPUSH
20733: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20734: LD_ADDR_VAR 0 6
20738: PUSH
20739: LD_INT 22
20741: PUSH
20742: LD_OWVAR 2
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: PUSH
20751: LD_INT 21
20753: PUSH
20754: LD_INT 1
20756: PUSH
20757: EMPTY
20758: LIST
20759: LIST
20760: PUSH
20761: LD_INT 3
20763: PUSH
20764: LD_INT 23
20766: PUSH
20767: LD_INT 0
20769: PUSH
20770: EMPTY
20771: LIST
20772: LIST
20773: PUSH
20774: EMPTY
20775: LIST
20776: LIST
20777: PUSH
20778: EMPTY
20779: LIST
20780: LIST
20781: LIST
20782: PPUSH
20783: CALL_OW 69
20787: ST_TO_ADDR
// if not tmp then
20788: LD_VAR 0 6
20792: NOT
20793: IFFALSE 20797
// exit ;
20795: GO 20943
// s1 := rand ( 1 , 4 ) ;
20797: LD_ADDR_VAR 0 2
20801: PUSH
20802: LD_INT 1
20804: PPUSH
20805: LD_INT 4
20807: PPUSH
20808: CALL_OW 12
20812: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
20813: LD_ADDR_VAR 0 4
20817: PUSH
20818: LD_VAR 0 6
20822: PUSH
20823: LD_INT 1
20825: ARRAY
20826: PPUSH
20827: LD_VAR 0 2
20831: PPUSH
20832: CALL_OW 259
20836: ST_TO_ADDR
// if s1 = 1 then
20837: LD_VAR 0 2
20841: PUSH
20842: LD_INT 1
20844: EQUAL
20845: IFFALSE 20865
// s2 := rand ( 2 , 4 ) else
20847: LD_ADDR_VAR 0 3
20851: PUSH
20852: LD_INT 2
20854: PPUSH
20855: LD_INT 4
20857: PPUSH
20858: CALL_OW 12
20862: ST_TO_ADDR
20863: GO 20873
// s2 := 1 ;
20865: LD_ADDR_VAR 0 3
20869: PUSH
20870: LD_INT 1
20872: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
20873: LD_ADDR_VAR 0 5
20877: PUSH
20878: LD_VAR 0 6
20882: PUSH
20883: LD_INT 1
20885: ARRAY
20886: PPUSH
20887: LD_VAR 0 3
20891: PPUSH
20892: CALL_OW 259
20896: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
20897: LD_VAR 0 6
20901: PUSH
20902: LD_INT 1
20904: ARRAY
20905: PPUSH
20906: LD_VAR 0 2
20910: PPUSH
20911: LD_VAR 0 5
20915: PPUSH
20916: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
20920: LD_VAR 0 6
20924: PUSH
20925: LD_INT 1
20927: ARRAY
20928: PPUSH
20929: LD_VAR 0 3
20933: PPUSH
20934: LD_VAR 0 4
20938: PPUSH
20939: CALL_OW 237
// end ;
20943: PPOPN 6
20945: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
20946: LD_EXP 38
20950: PUSH
20951: LD_EXP 85
20955: AND
20956: IFFALSE 21035
20958: GO 20960
20960: DISABLE
20961: LD_INT 0
20963: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
20964: LD_ADDR_VAR 0 1
20968: PUSH
20969: LD_INT 22
20971: PUSH
20972: LD_OWVAR 2
20976: PUSH
20977: EMPTY
20978: LIST
20979: LIST
20980: PUSH
20981: LD_INT 30
20983: PUSH
20984: LD_INT 3
20986: PUSH
20987: EMPTY
20988: LIST
20989: LIST
20990: PUSH
20991: EMPTY
20992: LIST
20993: LIST
20994: PPUSH
20995: CALL_OW 69
20999: ST_TO_ADDR
// if not tmp then
21000: LD_VAR 0 1
21004: NOT
21005: IFFALSE 21009
// exit ;
21007: GO 21035
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
21009: LD_VAR 0 1
21013: PUSH
21014: LD_INT 1
21016: PPUSH
21017: LD_VAR 0 1
21021: PPUSH
21022: CALL_OW 12
21026: ARRAY
21027: PPUSH
21028: LD_INT 1
21030: PPUSH
21031: CALL_OW 234
// end ;
21035: PPOPN 1
21037: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
21038: LD_EXP 38
21042: PUSH
21043: LD_EXP 86
21047: AND
21048: IFFALSE 21160
21050: GO 21052
21052: DISABLE
21053: LD_INT 0
21055: PPUSH
21056: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
21057: LD_ADDR_VAR 0 2
21061: PUSH
21062: LD_INT 22
21064: PUSH
21065: LD_OWVAR 2
21069: PUSH
21070: EMPTY
21071: LIST
21072: LIST
21073: PUSH
21074: LD_INT 2
21076: PUSH
21077: LD_INT 30
21079: PUSH
21080: LD_INT 27
21082: PUSH
21083: EMPTY
21084: LIST
21085: LIST
21086: PUSH
21087: LD_INT 30
21089: PUSH
21090: LD_INT 26
21092: PUSH
21093: EMPTY
21094: LIST
21095: LIST
21096: PUSH
21097: LD_INT 30
21099: PUSH
21100: LD_INT 28
21102: PUSH
21103: EMPTY
21104: LIST
21105: LIST
21106: PUSH
21107: EMPTY
21108: LIST
21109: LIST
21110: LIST
21111: LIST
21112: PUSH
21113: EMPTY
21114: LIST
21115: LIST
21116: PPUSH
21117: CALL_OW 69
21121: ST_TO_ADDR
// if not tmp then
21122: LD_VAR 0 2
21126: NOT
21127: IFFALSE 21131
// exit ;
21129: GO 21160
// for i in tmp do
21131: LD_ADDR_VAR 0 1
21135: PUSH
21136: LD_VAR 0 2
21140: PUSH
21141: FOR_IN
21142: IFFALSE 21158
// SetLives ( i , 1 ) ;
21144: LD_VAR 0 1
21148: PPUSH
21149: LD_INT 1
21151: PPUSH
21152: CALL_OW 234
21156: GO 21141
21158: POP
21159: POP
// end ;
21160: PPOPN 2
21162: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
21163: LD_EXP 38
21167: PUSH
21168: LD_EXP 87
21172: AND
21173: IFFALSE 21447
21175: GO 21177
21177: DISABLE
21178: LD_INT 0
21180: PPUSH
21181: PPUSH
21182: PPUSH
// begin i := rand ( 1 , 7 ) ;
21183: LD_ADDR_VAR 0 1
21187: PUSH
21188: LD_INT 1
21190: PPUSH
21191: LD_INT 7
21193: PPUSH
21194: CALL_OW 12
21198: ST_TO_ADDR
// case i of 1 :
21199: LD_VAR 0 1
21203: PUSH
21204: LD_INT 1
21206: DOUBLE
21207: EQUAL
21208: IFTRUE 21212
21210: GO 21222
21212: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
21213: LD_STRING earthquake(getX(game), 0, 32)
21215: PPUSH
21216: CALL_OW 559
21220: GO 21447
21222: LD_INT 2
21224: DOUBLE
21225: EQUAL
21226: IFTRUE 21230
21228: GO 21244
21230: POP
// begin ToLua ( displayStucuk(); ) ;
21231: LD_STRING displayStucuk();
21233: PPUSH
21234: CALL_OW 559
// ResetFog ;
21238: CALL_OW 335
// end ; 3 :
21242: GO 21447
21244: LD_INT 3
21246: DOUBLE
21247: EQUAL
21248: IFTRUE 21252
21250: GO 21356
21252: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
21253: LD_ADDR_VAR 0 2
21257: PUSH
21258: LD_INT 22
21260: PUSH
21261: LD_OWVAR 2
21265: PUSH
21266: EMPTY
21267: LIST
21268: LIST
21269: PUSH
21270: LD_INT 25
21272: PUSH
21273: LD_INT 1
21275: PUSH
21276: EMPTY
21277: LIST
21278: LIST
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: PPUSH
21284: CALL_OW 69
21288: ST_TO_ADDR
// if not tmp then
21289: LD_VAR 0 2
21293: NOT
21294: IFFALSE 21298
// exit ;
21296: GO 21447
// un := tmp [ rand ( 1 , tmp ) ] ;
21298: LD_ADDR_VAR 0 3
21302: PUSH
21303: LD_VAR 0 2
21307: PUSH
21308: LD_INT 1
21310: PPUSH
21311: LD_VAR 0 2
21315: PPUSH
21316: CALL_OW 12
21320: ARRAY
21321: ST_TO_ADDR
// if Crawls ( un ) then
21322: LD_VAR 0 3
21326: PPUSH
21327: CALL_OW 318
21331: IFFALSE 21342
// ComWalk ( un ) ;
21333: LD_VAR 0 3
21337: PPUSH
21338: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21342: LD_VAR 0 3
21346: PPUSH
21347: LD_INT 8
21349: PPUSH
21350: CALL_OW 336
// end ; 4 :
21354: GO 21447
21356: LD_INT 4
21358: DOUBLE
21359: EQUAL
21360: IFTRUE 21364
21362: GO 21425
21364: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21365: LD_ADDR_VAR 0 2
21369: PUSH
21370: LD_INT 22
21372: PUSH
21373: LD_OWVAR 2
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: PUSH
21382: LD_INT 30
21384: PUSH
21385: LD_INT 29
21387: PUSH
21388: EMPTY
21389: LIST
21390: LIST
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: PPUSH
21396: CALL_OW 69
21400: ST_TO_ADDR
// if not tmp then
21401: LD_VAR 0 2
21405: NOT
21406: IFFALSE 21410
// exit ;
21408: GO 21447
// DestroyUnit ( tmp [ 1 ] ) ;
21410: LD_VAR 0 2
21414: PUSH
21415: LD_INT 1
21417: ARRAY
21418: PPUSH
21419: CALL_OW 65
// end ; 5 .. 7 :
21423: GO 21447
21425: LD_INT 5
21427: DOUBLE
21428: GREATEREQUAL
21429: IFFALSE 21437
21431: LD_INT 7
21433: DOUBLE
21434: LESSEQUAL
21435: IFTRUE 21439
21437: GO 21446
21439: POP
// StreamSibBomb ; end ;
21440: CALL 17727 0 0
21444: GO 21447
21446: POP
// end ;
21447: PPOPN 3
21449: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
21450: LD_EXP 38
21454: PUSH
21455: LD_EXP 88
21459: AND
21460: IFFALSE 21616
21462: GO 21464
21464: DISABLE
21465: LD_INT 0
21467: PPUSH
21468: PPUSH
21469: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
21470: LD_ADDR_VAR 0 2
21474: PUSH
21475: LD_INT 81
21477: PUSH
21478: LD_OWVAR 2
21482: PUSH
21483: EMPTY
21484: LIST
21485: LIST
21486: PUSH
21487: LD_INT 2
21489: PUSH
21490: LD_INT 21
21492: PUSH
21493: LD_INT 1
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: PUSH
21500: LD_INT 21
21502: PUSH
21503: LD_INT 2
21505: PUSH
21506: EMPTY
21507: LIST
21508: LIST
21509: PUSH
21510: EMPTY
21511: LIST
21512: LIST
21513: LIST
21514: PUSH
21515: EMPTY
21516: LIST
21517: LIST
21518: PPUSH
21519: CALL_OW 69
21523: ST_TO_ADDR
// if not tmp then
21524: LD_VAR 0 2
21528: NOT
21529: IFFALSE 21533
// exit ;
21531: GO 21616
// p := 0 ;
21533: LD_ADDR_VAR 0 3
21537: PUSH
21538: LD_INT 0
21540: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21541: LD_INT 35
21543: PPUSH
21544: CALL_OW 67
// p := p + 1 ;
21548: LD_ADDR_VAR 0 3
21552: PUSH
21553: LD_VAR 0 3
21557: PUSH
21558: LD_INT 1
21560: PLUS
21561: ST_TO_ADDR
// for i in tmp do
21562: LD_ADDR_VAR 0 1
21566: PUSH
21567: LD_VAR 0 2
21571: PUSH
21572: FOR_IN
21573: IFFALSE 21604
// if GetLives ( i ) < 1000 then
21575: LD_VAR 0 1
21579: PPUSH
21580: CALL_OW 256
21584: PUSH
21585: LD_INT 1000
21587: LESS
21588: IFFALSE 21602
// SetLives ( i , 1000 ) ;
21590: LD_VAR 0 1
21594: PPUSH
21595: LD_INT 1000
21597: PPUSH
21598: CALL_OW 234
21602: GO 21572
21604: POP
21605: POP
// until p > 20 ;
21606: LD_VAR 0 3
21610: PUSH
21611: LD_INT 20
21613: GREATER
21614: IFFALSE 21541
// end ;
21616: PPOPN 3
21618: END
// every 0 0$1 trigger StreamModeActive and sTime do
21619: LD_EXP 38
21623: PUSH
21624: LD_EXP 89
21628: AND
21629: IFFALSE 21664
21631: GO 21633
21633: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21634: LD_INT 28
21636: PPUSH
21637: LD_OWVAR 2
21641: PPUSH
21642: LD_INT 2
21644: PPUSH
21645: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21649: LD_INT 30
21651: PPUSH
21652: LD_OWVAR 2
21656: PPUSH
21657: LD_INT 2
21659: PPUSH
21660: CALL_OW 322
// end ;
21664: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21665: LD_EXP 38
21669: PUSH
21670: LD_EXP 90
21674: AND
21675: IFFALSE 21796
21677: GO 21679
21679: DISABLE
21680: LD_INT 0
21682: PPUSH
21683: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21684: LD_ADDR_VAR 0 2
21688: PUSH
21689: LD_INT 22
21691: PUSH
21692: LD_OWVAR 2
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: PUSH
21701: LD_INT 21
21703: PUSH
21704: LD_INT 1
21706: PUSH
21707: EMPTY
21708: LIST
21709: LIST
21710: PUSH
21711: LD_INT 3
21713: PUSH
21714: LD_INT 23
21716: PUSH
21717: LD_INT 0
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: PUSH
21724: EMPTY
21725: LIST
21726: LIST
21727: PUSH
21728: EMPTY
21729: LIST
21730: LIST
21731: LIST
21732: PPUSH
21733: CALL_OW 69
21737: ST_TO_ADDR
// if not tmp then
21738: LD_VAR 0 2
21742: NOT
21743: IFFALSE 21747
// exit ;
21745: GO 21796
// for i in tmp do
21747: LD_ADDR_VAR 0 1
21751: PUSH
21752: LD_VAR 0 2
21756: PUSH
21757: FOR_IN
21758: IFFALSE 21794
// begin if Crawls ( i ) then
21760: LD_VAR 0 1
21764: PPUSH
21765: CALL_OW 318
21769: IFFALSE 21780
// ComWalk ( i ) ;
21771: LD_VAR 0 1
21775: PPUSH
21776: CALL_OW 138
// SetClass ( i , 2 ) ;
21780: LD_VAR 0 1
21784: PPUSH
21785: LD_INT 2
21787: PPUSH
21788: CALL_OW 336
// end ;
21792: GO 21757
21794: POP
21795: POP
// end ;
21796: PPOPN 2
21798: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
21799: LD_EXP 38
21803: PUSH
21804: LD_EXP 91
21808: AND
21809: IFFALSE 22090
21811: GO 21813
21813: DISABLE
21814: LD_INT 0
21816: PPUSH
21817: PPUSH
21818: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
21819: LD_OWVAR 2
21823: PPUSH
21824: LD_INT 9
21826: PPUSH
21827: LD_INT 1
21829: PPUSH
21830: LD_INT 1
21832: PPUSH
21833: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
21837: LD_INT 9
21839: PPUSH
21840: LD_OWVAR 2
21844: PPUSH
21845: CALL_OW 343
// uc_side := 9 ;
21849: LD_ADDR_OWVAR 20
21853: PUSH
21854: LD_INT 9
21856: ST_TO_ADDR
// uc_nation := 2 ;
21857: LD_ADDR_OWVAR 21
21861: PUSH
21862: LD_INT 2
21864: ST_TO_ADDR
// hc_name := Dark Warrior ;
21865: LD_ADDR_OWVAR 26
21869: PUSH
21870: LD_STRING Dark Warrior
21872: ST_TO_ADDR
// hc_gallery :=  ;
21873: LD_ADDR_OWVAR 33
21877: PUSH
21878: LD_STRING 
21880: ST_TO_ADDR
// hc_noskilllimit := true ;
21881: LD_ADDR_OWVAR 76
21885: PUSH
21886: LD_INT 1
21888: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
21889: LD_ADDR_OWVAR 31
21893: PUSH
21894: LD_INT 30
21896: PUSH
21897: LD_INT 30
21899: PUSH
21900: LD_INT 30
21902: PUSH
21903: LD_INT 30
21905: PUSH
21906: EMPTY
21907: LIST
21908: LIST
21909: LIST
21910: LIST
21911: ST_TO_ADDR
// un := CreateHuman ;
21912: LD_ADDR_VAR 0 3
21916: PUSH
21917: CALL_OW 44
21921: ST_TO_ADDR
// hc_noskilllimit := false ;
21922: LD_ADDR_OWVAR 76
21926: PUSH
21927: LD_INT 0
21929: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21930: LD_VAR 0 3
21934: PPUSH
21935: LD_INT 1
21937: PPUSH
21938: CALL_OW 51
// p := 0 ;
21942: LD_ADDR_VAR 0 2
21946: PUSH
21947: LD_INT 0
21949: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21950: LD_INT 35
21952: PPUSH
21953: CALL_OW 67
// p := p + 1 ;
21957: LD_ADDR_VAR 0 2
21961: PUSH
21962: LD_VAR 0 2
21966: PUSH
21967: LD_INT 1
21969: PLUS
21970: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
21971: LD_VAR 0 3
21975: PPUSH
21976: CALL_OW 256
21980: PUSH
21981: LD_INT 1000
21983: LESS
21984: IFFALSE 21998
// SetLives ( un , 1000 ) ;
21986: LD_VAR 0 3
21990: PPUSH
21991: LD_INT 1000
21993: PPUSH
21994: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
21998: LD_VAR 0 3
22002: PPUSH
22003: LD_INT 81
22005: PUSH
22006: LD_OWVAR 2
22010: PUSH
22011: EMPTY
22012: LIST
22013: LIST
22014: PUSH
22015: LD_INT 91
22017: PUSH
22018: LD_VAR 0 3
22022: PUSH
22023: LD_INT 30
22025: PUSH
22026: EMPTY
22027: LIST
22028: LIST
22029: LIST
22030: PUSH
22031: EMPTY
22032: LIST
22033: LIST
22034: PPUSH
22035: CALL_OW 69
22039: PPUSH
22040: LD_VAR 0 3
22044: PPUSH
22045: CALL_OW 74
22049: PPUSH
22050: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
22054: LD_VAR 0 2
22058: PUSH
22059: LD_INT 60
22061: GREATER
22062: PUSH
22063: LD_VAR 0 3
22067: PPUSH
22068: CALL_OW 301
22072: OR
22073: IFFALSE 21950
// if un then
22075: LD_VAR 0 3
22079: IFFALSE 22090
// RemoveUnit ( un ) ;
22081: LD_VAR 0 3
22085: PPUSH
22086: CALL_OW 64
// end ; end_of_file
22090: PPOPN 3
22092: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
22093: LD_INT 0
22095: PPUSH
22096: PPUSH
22097: PPUSH
22098: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
22099: LD_VAR 0 1
22103: PPUSH
22104: CALL_OW 264
22108: PUSH
22109: LD_EXP 29
22113: EQUAL
22114: IFFALSE 22186
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
22116: LD_INT 68
22118: PPUSH
22119: LD_VAR 0 1
22123: PPUSH
22124: CALL_OW 255
22128: PPUSH
22129: CALL_OW 321
22133: PUSH
22134: LD_INT 2
22136: EQUAL
22137: IFFALSE 22149
// eff := 70 else
22139: LD_ADDR_VAR 0 4
22143: PUSH
22144: LD_INT 70
22146: ST_TO_ADDR
22147: GO 22157
// eff := 30 ;
22149: LD_ADDR_VAR 0 4
22153: PUSH
22154: LD_INT 30
22156: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
22157: LD_VAR 0 1
22161: PPUSH
22162: CALL_OW 250
22166: PPUSH
22167: LD_VAR 0 1
22171: PPUSH
22172: CALL_OW 251
22176: PPUSH
22177: LD_VAR 0 4
22181: PPUSH
22182: CALL_OW 495
// end ; end ;
22186: LD_VAR 0 2
22190: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
22191: LD_INT 0
22193: PPUSH
// end ;
22194: LD_VAR 0 4
22198: RET
// export function SOS_Command ( cmd ) ; begin
22199: LD_INT 0
22201: PPUSH
// end ;
22202: LD_VAR 0 2
22206: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
22207: LD_VAR 0 1
22211: PUSH
22212: LD_INT 255
22214: EQUAL
22215: PUSH
22216: LD_VAR 0 2
22220: PPUSH
22221: CALL_OW 264
22225: PUSH
22226: LD_INT 14
22228: PUSH
22229: LD_INT 53
22231: PUSH
22232: EMPTY
22233: LIST
22234: LIST
22235: IN
22236: AND
22237: PUSH
22238: LD_VAR 0 4
22242: PPUSH
22243: LD_VAR 0 5
22247: PPUSH
22248: CALL_OW 488
22252: AND
22253: IFFALSE 22277
// CutTreeXYR ( unit , x , y , 12 ) ;
22255: LD_VAR 0 2
22259: PPUSH
22260: LD_VAR 0 4
22264: PPUSH
22265: LD_VAR 0 5
22269: PPUSH
22270: LD_INT 12
22272: PPUSH
22273: CALL 22280 0 4
// end ;
22277: PPOPN 5
22279: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22280: LD_INT 0
22282: PPUSH
22283: PPUSH
22284: PPUSH
22285: PPUSH
22286: PPUSH
22287: PPUSH
22288: PPUSH
22289: PPUSH
22290: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22291: LD_VAR 0 1
22295: NOT
22296: PUSH
22297: LD_VAR 0 2
22301: PPUSH
22302: LD_VAR 0 3
22306: PPUSH
22307: CALL_OW 488
22311: NOT
22312: OR
22313: PUSH
22314: LD_VAR 0 4
22318: NOT
22319: OR
22320: IFFALSE 22324
// exit ;
22322: GO 22664
// list := [ ] ;
22324: LD_ADDR_VAR 0 13
22328: PUSH
22329: EMPTY
22330: ST_TO_ADDR
// if x - r < 0 then
22331: LD_VAR 0 2
22335: PUSH
22336: LD_VAR 0 4
22340: MINUS
22341: PUSH
22342: LD_INT 0
22344: LESS
22345: IFFALSE 22357
// min_x := 0 else
22347: LD_ADDR_VAR 0 7
22351: PUSH
22352: LD_INT 0
22354: ST_TO_ADDR
22355: GO 22373
// min_x := x - r ;
22357: LD_ADDR_VAR 0 7
22361: PUSH
22362: LD_VAR 0 2
22366: PUSH
22367: LD_VAR 0 4
22371: MINUS
22372: ST_TO_ADDR
// if y - r < 0 then
22373: LD_VAR 0 3
22377: PUSH
22378: LD_VAR 0 4
22382: MINUS
22383: PUSH
22384: LD_INT 0
22386: LESS
22387: IFFALSE 22399
// min_y := 0 else
22389: LD_ADDR_VAR 0 8
22393: PUSH
22394: LD_INT 0
22396: ST_TO_ADDR
22397: GO 22415
// min_y := y - r ;
22399: LD_ADDR_VAR 0 8
22403: PUSH
22404: LD_VAR 0 3
22408: PUSH
22409: LD_VAR 0 4
22413: MINUS
22414: ST_TO_ADDR
// max_x := x + r ;
22415: LD_ADDR_VAR 0 9
22419: PUSH
22420: LD_VAR 0 2
22424: PUSH
22425: LD_VAR 0 4
22429: PLUS
22430: ST_TO_ADDR
// max_y := y + r ;
22431: LD_ADDR_VAR 0 10
22435: PUSH
22436: LD_VAR 0 3
22440: PUSH
22441: LD_VAR 0 4
22445: PLUS
22446: ST_TO_ADDR
// for _x = min_x to max_x do
22447: LD_ADDR_VAR 0 11
22451: PUSH
22452: DOUBLE
22453: LD_VAR 0 7
22457: DEC
22458: ST_TO_ADDR
22459: LD_VAR 0 9
22463: PUSH
22464: FOR_TO
22465: IFFALSE 22582
// for _y = min_y to max_y do
22467: LD_ADDR_VAR 0 12
22471: PUSH
22472: DOUBLE
22473: LD_VAR 0 8
22477: DEC
22478: ST_TO_ADDR
22479: LD_VAR 0 10
22483: PUSH
22484: FOR_TO
22485: IFFALSE 22578
// begin if not ValidHex ( _x , _y ) then
22487: LD_VAR 0 11
22491: PPUSH
22492: LD_VAR 0 12
22496: PPUSH
22497: CALL_OW 488
22501: NOT
22502: IFFALSE 22506
// continue ;
22504: GO 22484
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22506: LD_VAR 0 11
22510: PPUSH
22511: LD_VAR 0 12
22515: PPUSH
22516: CALL_OW 351
22520: PUSH
22521: LD_VAR 0 11
22525: PPUSH
22526: LD_VAR 0 12
22530: PPUSH
22531: CALL_OW 554
22535: AND
22536: IFFALSE 22576
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22538: LD_ADDR_VAR 0 13
22542: PUSH
22543: LD_VAR 0 13
22547: PPUSH
22548: LD_VAR 0 13
22552: PUSH
22553: LD_INT 1
22555: PLUS
22556: PPUSH
22557: LD_VAR 0 11
22561: PUSH
22562: LD_VAR 0 12
22566: PUSH
22567: EMPTY
22568: LIST
22569: LIST
22570: PPUSH
22571: CALL_OW 2
22575: ST_TO_ADDR
// end ;
22576: GO 22484
22578: POP
22579: POP
22580: GO 22464
22582: POP
22583: POP
// if not list then
22584: LD_VAR 0 13
22588: NOT
22589: IFFALSE 22593
// exit ;
22591: GO 22664
// for i in list do
22593: LD_ADDR_VAR 0 6
22597: PUSH
22598: LD_VAR 0 13
22602: PUSH
22603: FOR_IN
22604: IFFALSE 22662
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22606: LD_VAR 0 1
22610: PPUSH
22611: LD_STRING M
22613: PUSH
22614: LD_VAR 0 6
22618: PUSH
22619: LD_INT 1
22621: ARRAY
22622: PUSH
22623: LD_VAR 0 6
22627: PUSH
22628: LD_INT 2
22630: ARRAY
22631: PUSH
22632: LD_INT 0
22634: PUSH
22635: LD_INT 0
22637: PUSH
22638: LD_INT 0
22640: PUSH
22641: LD_INT 0
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: LIST
22648: LIST
22649: LIST
22650: LIST
22651: LIST
22652: PUSH
22653: EMPTY
22654: LIST
22655: PPUSH
22656: CALL_OW 447
22660: GO 22603
22662: POP
22663: POP
// end ;
22664: LD_VAR 0 5
22668: RET
