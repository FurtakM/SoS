// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 59 0 0
// Action ;
   8: CALL 8002 0 0
// PrepareAnimals ( 6 , 3 , 4 , apearea ) ;
  12: LD_INT 6
  14: PPUSH
  15: LD_INT 3
  17: PPUSH
  18: LD_INT 4
  20: PPUSH
  21: LD_INT 21
  23: PPUSH
  24: CALL 10314 0 4
// PrepareAmerican ;
  28: CALL 3806 0 0
// PrepareRussian ;
  32: CALL 270 0 0
// end ;
  36: END
// every 0 0$01 do
  37: GO 39
  39: DISABLE
// begin enable ;
  40: ENABLE
// display_strings := [ #tick , tick ] ;
  41: LD_ADDR_OWVAR 47
  45: PUSH
  46: LD_STRING #tick
  48: PUSH
  49: LD_OWVAR 1
  53: PUSH
  54: EMPTY
  55: LIST
  56: LIST
  57: ST_TO_ADDR
// end ;
  58: END
// export conv_squad , escort , medal1 , medal2 , medal3 , path , convoy_start , dest_counter ; export riv , ar_attacks , ar_force , us_force , conv_counter , crates_counter ; function Init ; begin
  59: LD_INT 0
  61: PPUSH
// medal1 := true ;
  62: LD_ADDR_EXP 3
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// medal2 := true ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 1
  77: ST_TO_ADDR
// medal3 := true ;
  78: LD_ADDR_EXP 5
  82: PUSH
  83: LD_INT 1
  85: ST_TO_ADDR
// path := [ p1 , p2 , p3 , p4 , conv_end ] ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 10
  93: PUSH
  94: LD_INT 11
  96: PUSH
  97: LD_INT 12
  99: PUSH
 100: LD_INT 13
 102: PUSH
 103: LD_INT 9
 105: PUSH
 106: EMPTY
 107: LIST
 108: LIST
 109: LIST
 110: LIST
 111: LIST
 112: ST_TO_ADDR
// conv_squad := [ ] ;
 113: LD_ADDR_EXP 1
 117: PUSH
 118: EMPTY
 119: ST_TO_ADDR
// escort := [ ] ;
 120: LD_ADDR_EXP 2
 124: PUSH
 125: EMPTY
 126: ST_TO_ADDR
// riv := [ ] ;
 127: LD_ADDR_EXP 9
 131: PUSH
 132: EMPTY
 133: ST_TO_ADDR
// ar_force := [ ] ;
 134: LD_ADDR_EXP 11
 138: PUSH
 139: EMPTY
 140: ST_TO_ADDR
// ar_attacks := false ;
 141: LD_ADDR_EXP 10
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// us_force := [ ] ;
 149: LD_ADDR_EXP 12
 153: PUSH
 154: EMPTY
 155: ST_TO_ADDR
// convoy_start := false ;
 156: LD_ADDR_EXP 7
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// conv_counter := 0 ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// dest_counter := 0 ;
 172: LD_ADDR_EXP 8
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// crates_counter := 0 0$40 ;
 180: LD_ADDR_EXP 14
 184: PUSH
 185: LD_INT 1400
 187: ST_TO_ADDR
// end ;
 188: LD_VAR 0 1
 192: RET
// every 2 2$00 do
 193: GO 195
 195: DISABLE
// begin while ( tick <= [ 47 47$00 , 44 44$00 , 41 41$00 ] [ Difficulty ] ) do
 196: LD_OWVAR 1
 200: PUSH
 201: LD_INT 98700
 203: PUSH
 204: LD_INT 92400
 206: PUSH
 207: LD_INT 86100
 209: PUSH
 210: EMPTY
 211: LIST
 212: LIST
 213: LIST
 214: PUSH
 215: LD_OWVAR 67
 219: ARRAY
 220: LESSEQUAL
 221: IFFALSE 269
// begin Wait ( crates_counter ) ;
 223: LD_EXP 14
 227: PPUSH
 228: CALL_OW 67
// crates_counter := crates_counter + 0 0$09 ;
 232: LD_ADDR_EXP 14
 236: PUSH
 237: LD_EXP 14
 241: PUSH
 242: LD_INT 315
 244: PLUS
 245: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
 246: LD_INT 1
 248: PPUSH
 249: LD_INT 5
 251: PPUSH
 252: CALL_OW 12
 256: PPUSH
 257: LD_INT 22
 259: PPUSH
 260: LD_INT 1
 262: PPUSH
 263: CALL_OW 55
// end ;
 267: GO 196
// end ; end_of_file
 269: END
// export Stolypin , Popov , Saseda ; export function PrepareRussian ; var un , force , i , c , skill , team ; begin
 270: LD_INT 0
 272: PPUSH
 273: PPUSH
 274: PPUSH
 275: PPUSH
 276: PPUSH
 277: PPUSH
 278: PPUSH
// uc_side := 6 ;
 279: LD_ADDR_OWVAR 20
 283: PUSH
 284: LD_INT 6
 286: ST_TO_ADDR
// uc_nation := 3 ;
 287: LD_ADDR_OWVAR 21
 291: PUSH
 292: LD_INT 3
 294: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
 295: LD_INT 3
 297: PPUSH
 298: LD_INT 6
 300: PPUSH
 301: CALL_OW 343
// Popov := NewCharacter ( Gaydar ) ;
 305: LD_ADDR_EXP 16
 309: PUSH
 310: LD_STRING Gaydar
 312: PPUSH
 313: CALL_OW 25
 317: ST_TO_ADDR
// uc_side := 7 ;
 318: LD_ADDR_OWVAR 20
 322: PUSH
 323: LD_INT 7
 325: ST_TO_ADDR
// hc_gallery := sandal ;
 326: LD_ADDR_OWVAR 33
 330: PUSH
 331: LD_STRING sandal
 333: ST_TO_ADDR
// hc_face_number := 9 ;
 334: LD_ADDR_OWVAR 34
 338: PUSH
 339: LD_INT 9
 341: ST_TO_ADDR
// hc_skills := [ 3 , 5 , 2 , 7 ] ;
 342: LD_ADDR_OWVAR 31
 346: PUSH
 347: LD_INT 3
 349: PUSH
 350: LD_INT 5
 352: PUSH
 353: LD_INT 2
 355: PUSH
 356: LD_INT 7
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: LIST
 363: LIST
 364: ST_TO_ADDR
// hc_sex := sex_male ;
 365: LD_ADDR_OWVAR 27
 369: PUSH
 370: LD_INT 1
 372: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 373: LD_ADDR_OWVAR 29
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: ST_TO_ADDR
// hc_class := 4 ;
 388: LD_ADDR_OWVAR 28
 392: PUSH
 393: LD_INT 4
 395: ST_TO_ADDR
// hc_name := Fiodor Saseda ;
 396: LD_ADDR_OWVAR 26
 400: PUSH
 401: LD_STRING Fiodor Saseda
 403: ST_TO_ADDR
// Saseda := CreateHuman ;
 404: LD_ADDR_EXP 17
 408: PUSH
 409: CALL_OW 44
 413: ST_TO_ADDR
// uc_side := 3 ;
 414: LD_ADDR_OWVAR 20
 418: PUSH
 419: LD_INT 3
 421: ST_TO_ADDR
// hc_importance := 100 ;
 422: LD_ADDR_OWVAR 32
 426: PUSH
 427: LD_INT 100
 429: ST_TO_ADDR
// hc_class := 1 ;
 430: LD_ADDR_OWVAR 28
 434: PUSH
 435: LD_INT 1
 437: ST_TO_ADDR
// hc_sex := sex_male ;
 438: LD_ADDR_OWVAR 27
 442: PUSH
 443: LD_INT 1
 445: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
 446: LD_ADDR_OWVAR 31
 450: PUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 3
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: LD_INT 2
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: ST_TO_ADDR
// hc_name := W. I. Stolypin ;
 469: LD_ADDR_OWVAR 26
 473: PUSH
 474: LD_STRING W. I. Stolypin
 476: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 477: LD_ADDR_OWVAR 29
 481: PUSH
 482: LD_INT 10
 484: PUSH
 485: LD_INT 11
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: ST_TO_ADDR
// hc_gallery := ru ;
 492: LD_ADDR_OWVAR 33
 496: PUSH
 497: LD_STRING ru
 499: ST_TO_ADDR
// hc_face_number := 15 ;
 500: LD_ADDR_OWVAR 34
 504: PUSH
 505: LD_INT 15
 507: ST_TO_ADDR
// Stolypin := CreateHuman ;
 508: LD_ADDR_EXP 15
 512: PUSH
 513: CALL_OW 44
 517: ST_TO_ADDR
// hc_importance := 0 ;
 518: LD_ADDR_OWVAR 32
 522: PUSH
 523: LD_INT 0
 525: ST_TO_ADDR
// hc_gallery :=  ;
 526: LD_ADDR_OWVAR 33
 530: PUSH
 531: LD_STRING 
 533: ST_TO_ADDR
// hc_name :=  ;
 534: LD_ADDR_OWVAR 26
 538: PUSH
 539: LD_STRING 
 541: ST_TO_ADDR
// skill := [ 6 , 5 , 5 ] [ Difficulty ] ;
 542: LD_ADDR_VAR 0 6
 546: PUSH
 547: LD_INT 6
 549: PUSH
 550: LD_INT 5
 552: PUSH
 553: LD_INT 5
 555: PUSH
 556: EMPTY
 557: LIST
 558: LIST
 559: LIST
 560: PUSH
 561: LD_OWVAR 67
 565: ARRAY
 566: ST_TO_ADDR
// c := 1 ;
 567: LD_ADDR_VAR 0 5
 571: PUSH
 572: LD_INT 1
 574: ST_TO_ADDR
// for i = 1 to 21 do
 575: LD_ADDR_VAR 0 4
 579: PUSH
 580: DOUBLE
 581: LD_INT 1
 583: DEC
 584: ST_TO_ADDR
 585: LD_INT 21
 587: PUSH
 588: FOR_TO
 589: IFFALSE 690
// begin if i = 10 then
 591: LD_VAR 0 4
 595: PUSH
 596: LD_INT 10
 598: EQUAL
 599: IFFALSE 609
// c := 2 ;
 601: LD_ADDR_VAR 0 5
 605: PUSH
 606: LD_INT 2
 608: ST_TO_ADDR
// if i = 14 then
 609: LD_VAR 0 4
 613: PUSH
 614: LD_INT 14
 616: EQUAL
 617: IFFALSE 627
// c := 3 ;
 619: LD_ADDR_VAR 0 5
 623: PUSH
 624: LD_INT 3
 626: ST_TO_ADDR
// if i = 18 then
 627: LD_VAR 0 4
 631: PUSH
 632: LD_INT 18
 634: EQUAL
 635: IFFALSE 645
// c := 4 ;
 637: LD_ADDR_VAR 0 5
 641: PUSH
 642: LD_INT 4
 644: ST_TO_ADDR
// PrepareHuman ( false , c , skill ) ;
 645: LD_INT 0
 647: PPUSH
 648: LD_VAR 0 5
 652: PPUSH
 653: LD_VAR 0 6
 657: PPUSH
 658: CALL_OW 380
// un := CreateHuman ;
 662: LD_ADDR_VAR 0 2
 666: PUSH
 667: CALL_OW 44
 671: ST_TO_ADDR
// force := force ^ un ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_VAR 0 3
 681: PUSH
 682: LD_VAR 0 2
 686: ADD
 687: ST_TO_ADDR
// end ;
 688: GO 588
 690: POP
 691: POP
// team := CharacterSelection ( text , [ 8 , 7 , 7 ] [ Difficulty ] , [ 8 , 7 , 7 ] [ Difficulty ] , [ sel_change_class , Stolypin , sel_changeable , sel_not_hired ] ^ force , [ [ class_soldier , 3 ] , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
 692: LD_ADDR_VAR 0 7
 696: PUSH
 697: LD_STRING text
 699: PPUSH
 700: LD_INT 8
 702: PUSH
 703: LD_INT 7
 705: PUSH
 706: LD_INT 7
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: PUSH
 714: LD_OWVAR 67
 718: ARRAY
 719: PPUSH
 720: LD_INT 8
 722: PUSH
 723: LD_INT 7
 725: PUSH
 726: LD_INT 7
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_OWVAR 67
 738: ARRAY
 739: PPUSH
 740: LD_INT -5
 742: PUSH
 743: LD_EXP 15
 747: PUSH
 748: LD_INT -3
 750: PUSH
 751: LD_INT -2
 753: PUSH
 754: EMPTY
 755: LIST
 756: LIST
 757: LIST
 758: LIST
 759: PUSH
 760: LD_VAR 0 3
 764: ADD
 765: PPUSH
 766: LD_INT 1
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: EMPTY
 773: LIST
 774: LIST
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 2
 781: PUSH
 782: LD_INT 1
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 4
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: LIST
 796: LIST
 797: PPUSH
 798: CALL_OW 42
 802: ST_TO_ADDR
// team := team ^ Stolypin ;
 803: LD_ADDR_VAR 0 7
 807: PUSH
 808: LD_VAR 0 7
 812: PUSH
 813: LD_EXP 15
 817: ADD
 818: ST_TO_ADDR
// for i = 1 to team do
 819: LD_ADDR_VAR 0 4
 823: PUSH
 824: DOUBLE
 825: LD_INT 1
 827: DEC
 828: ST_TO_ADDR
 829: LD_VAR 0 7
 833: PUSH
 834: FOR_TO
 835: IFFALSE 860
// PlaceUnitArea ( team [ i ] , rus_start , false ) ;
 837: LD_VAR 0 7
 841: PUSH
 842: LD_VAR 0 4
 846: ARRAY
 847: PPUSH
 848: LD_INT 1
 850: PPUSH
 851: LD_INT 0
 853: PPUSH
 854: CALL_OW 49
 858: GO 834
 860: POP
 861: POP
// CenterNowOnUnits ( Stolypin ) ;
 862: LD_EXP 15
 866: PPUSH
 867: CALL_OW 87
// end ;
 871: LD_VAR 0 1
 875: RET
// export conv_ready ; export function Convoy ( type ) ; var i , veh , skill ; begin
 876: LD_INT 0
 878: PPUSH
 879: PPUSH
 880: PPUSH
 881: PPUSH
// Randomize ;
 882: CALL_OW 10
// uc_side := 6 ;
 886: LD_ADDR_OWVAR 20
 890: PUSH
 891: LD_INT 6
 893: ST_TO_ADDR
// uc_nation := 3 ;
 894: LD_ADDR_OWVAR 21
 898: PUSH
 899: LD_INT 3
 901: ST_TO_ADDR
// hc_name :=  ;
 902: LD_ADDR_OWVAR 26
 906: PUSH
 907: LD_STRING 
 909: ST_TO_ADDR
// hc_gallery :=  ;
 910: LD_ADDR_OWVAR 33
 914: PUSH
 915: LD_STRING 
 917: ST_TO_ADDR
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
 918: LD_ADDR_VAR 0 5
 922: PUSH
 923: LD_INT 5
 925: PUSH
 926: LD_INT 5
 928: PUSH
 929: LD_INT 4
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_OWVAR 67
 941: ARRAY
 942: ST_TO_ADDR
// conv_ready := false ;
 943: LD_ADDR_EXP 18
 947: PUSH
 948: LD_INT 0
 950: ST_TO_ADDR
// case type of 1 :
 951: LD_VAR 0 1
 955: PUSH
 956: LD_INT 1
 958: DOUBLE
 959: EQUAL
 960: IFTRUE 964
 962: GO 1216
 964: POP
// begin if Rand ( 0 , 1 ) = 1 then
 965: LD_INT 0
 967: PPUSH
 968: LD_INT 1
 970: PPUSH
 971: CALL_OW 12
 975: PUSH
 976: LD_INT 1
 978: EQUAL
 979: IFFALSE 985
// AddEscort ( ) ;
 981: CALL 2715 0 0
// Wait ( 0 0$02 ) ;
 985: LD_INT 70
 987: PPUSH
 988: CALL_OW 67
// vc_chassis := ru_medium_wheeled ;
 992: LD_ADDR_OWVAR 37
 996: PUSH
 997: LD_INT 21
 999: ST_TO_ADDR
// vc_engine := engine_combustion ;
1000: LD_ADDR_OWVAR 39
1004: PUSH
1005: LD_INT 1
1007: ST_TO_ADDR
// vc_control := control_manual ;
1008: LD_ADDR_OWVAR 38
1012: PUSH
1013: LD_INT 1
1015: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1016: LD_ADDR_OWVAR 40
1020: PUSH
1021: LD_INT 51
1023: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1024: LD_ADDR_OWVAR 41
1028: PUSH
1029: LD_INT 50
1031: PPUSH
1032: LD_INT 99
1034: PPUSH
1035: CALL_OW 12
1039: ST_TO_ADDR
// veh := CreateVehicle ;
1040: LD_ADDR_VAR 0 4
1044: PUSH
1045: CALL_OW 45
1049: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1050: LD_VAR 0 4
1054: PPUSH
1055: LD_INT 3
1057: PPUSH
1058: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1062: LD_VAR 0 4
1066: PPUSH
1067: LD_INT 8
1069: PPUSH
1070: LD_INT 0
1072: PPUSH
1073: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1077: LD_INT 0
1079: PPUSH
1080: LD_INT 1
1082: PPUSH
1083: LD_INT 2
1085: PPUSH
1086: CALL_OW 12
1090: PPUSH
1091: LD_VAR 0 5
1095: PPUSH
1096: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1100: CALL_OW 44
1104: PPUSH
1105: LD_VAR 0 4
1109: PPUSH
1110: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1114: LD_VAR 0 4
1118: PPUSH
1119: LD_INT 500
1121: PPUSH
1122: LD_INT 1000
1124: PPUSH
1125: CALL_OW 12
1129: PPUSH
1130: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1134: LD_VAR 0 4
1138: PPUSH
1139: LD_INT 1
1141: PPUSH
1142: LD_INT 2
1144: PPUSH
1145: CALL_OW 12
1149: PPUSH
1150: LD_INT 2
1152: PPUSH
1153: LD_INT 10
1155: PPUSH
1156: CALL_OW 12
1160: PUSH
1161: LD_INT 10
1163: MUL
1164: PPUSH
1165: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1169: LD_ADDR_EXP 1
1173: PUSH
1174: LD_EXP 1
1178: PPUSH
1179: LD_INT 1
1181: PPUSH
1182: LD_VAR 0 4
1186: PUSH
1187: LD_INT 1
1189: PUSH
1190: EMPTY
1191: LIST
1192: LIST
1193: PPUSH
1194: CALL_OW 2
1198: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
1199: LD_INT 35
1201: PPUSH
1202: CALL_OW 67
// conv_ready := true ;
1206: LD_ADDR_EXP 18
1210: PUSH
1211: LD_INT 1
1213: ST_TO_ADDR
// end ; 2 :
1214: GO 2710
1216: LD_INT 2
1218: DOUBLE
1219: EQUAL
1220: IFTRUE 1224
1222: GO 1506
1224: POP
// begin AddEscort ( ) ;
1225: CALL 2715 0 0
// Wait ( 0 0$02 ) ;
1229: LD_INT 70
1231: PPUSH
1232: CALL_OW 67
// for i = 1 to 2 do
1236: LD_ADDR_VAR 0 3
1240: PUSH
1241: DOUBLE
1242: LD_INT 1
1244: DEC
1245: ST_TO_ADDR
1246: LD_INT 2
1248: PUSH
1249: FOR_TO
1250: IFFALSE 1483
// begin vc_chassis := ru_medium_wheeled ;
1252: LD_ADDR_OWVAR 37
1256: PUSH
1257: LD_INT 21
1259: ST_TO_ADDR
// vc_engine := engine_combustion ;
1260: LD_ADDR_OWVAR 39
1264: PUSH
1265: LD_INT 1
1267: ST_TO_ADDR
// vc_control := control_manual ;
1268: LD_ADDR_OWVAR 38
1272: PUSH
1273: LD_INT 1
1275: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1276: LD_ADDR_OWVAR 40
1280: PUSH
1281: LD_INT 51
1283: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1284: LD_ADDR_OWVAR 41
1288: PUSH
1289: LD_INT 50
1291: PPUSH
1292: LD_INT 99
1294: PPUSH
1295: CALL_OW 12
1299: ST_TO_ADDR
// veh := CreateVehicle ;
1300: LD_ADDR_VAR 0 4
1304: PUSH
1305: CALL_OW 45
1309: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1310: LD_VAR 0 4
1314: PPUSH
1315: LD_INT 3
1317: PPUSH
1318: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1322: LD_VAR 0 4
1326: PPUSH
1327: LD_INT 8
1329: PPUSH
1330: LD_INT 0
1332: PPUSH
1333: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1337: LD_INT 0
1339: PPUSH
1340: LD_INT 1
1342: PPUSH
1343: LD_INT 2
1345: PPUSH
1346: CALL_OW 12
1350: PPUSH
1351: LD_VAR 0 5
1355: PPUSH
1356: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1360: CALL_OW 44
1364: PPUSH
1365: LD_VAR 0 4
1369: PPUSH
1370: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1374: LD_VAR 0 4
1378: PPUSH
1379: LD_INT 500
1381: PPUSH
1382: LD_INT 1000
1384: PPUSH
1385: CALL_OW 12
1389: PPUSH
1390: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1394: LD_VAR 0 4
1398: PPUSH
1399: LD_INT 1
1401: PPUSH
1402: LD_INT 2
1404: PPUSH
1405: CALL_OW 12
1409: PPUSH
1410: LD_INT 2
1412: PPUSH
1413: LD_INT 10
1415: PPUSH
1416: CALL_OW 12
1420: PUSH
1421: LD_INT 10
1423: MUL
1424: PPUSH
1425: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1429: LD_ADDR_EXP 1
1433: PUSH
1434: LD_EXP 1
1438: PPUSH
1439: LD_INT 1
1441: PPUSH
1442: LD_VAR 0 4
1446: PUSH
1447: LD_INT 1
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: PPUSH
1454: CALL_OW 2
1458: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1459: LD_VAR 0 4
1463: PPUSH
1464: LD_INT 120
1466: PPUSH
1467: LD_INT 10
1469: PPUSH
1470: CALL_OW 111
// Wait ( 0 0$02 ) ;
1474: LD_INT 70
1476: PPUSH
1477: CALL_OW 67
// end ;
1481: GO 1249
1483: POP
1484: POP
// AddEscort ( ) ;
1485: CALL 2715 0 0
// Wait ( 0 0$02 ) ;
1489: LD_INT 70
1491: PPUSH
1492: CALL_OW 67
// conv_ready := true ;
1496: LD_ADDR_EXP 18
1500: PUSH
1501: LD_INT 1
1503: ST_TO_ADDR
// end ; 3 :
1504: GO 2710
1506: LD_INT 3
1508: DOUBLE
1509: EQUAL
1510: IFTRUE 1514
1512: GO 1897
1514: POP
// begin AddEscort ( ) ;
1515: CALL 2715 0 0
// Wait ( 0 0$02 ) ;
1519: LD_INT 70
1521: PPUSH
1522: CALL_OW 67
// for i = 1 to 2 do
1526: LD_ADDR_VAR 0 3
1530: PUSH
1531: DOUBLE
1532: LD_INT 1
1534: DEC
1535: ST_TO_ADDR
1536: LD_INT 2
1538: PUSH
1539: FOR_TO
1540: IFFALSE 1773
// begin vc_chassis := ru_medium_wheeled ;
1542: LD_ADDR_OWVAR 37
1546: PUSH
1547: LD_INT 21
1549: ST_TO_ADDR
// vc_engine := engine_combustion ;
1550: LD_ADDR_OWVAR 39
1554: PUSH
1555: LD_INT 1
1557: ST_TO_ADDR
// vc_control := control_manual ;
1558: LD_ADDR_OWVAR 38
1562: PUSH
1563: LD_INT 1
1565: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1566: LD_ADDR_OWVAR 40
1570: PUSH
1571: LD_INT 51
1573: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1574: LD_ADDR_OWVAR 41
1578: PUSH
1579: LD_INT 50
1581: PPUSH
1582: LD_INT 99
1584: PPUSH
1585: CALL_OW 12
1589: ST_TO_ADDR
// veh := CreateVehicle ;
1590: LD_ADDR_VAR 0 4
1594: PUSH
1595: CALL_OW 45
1599: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1600: LD_VAR 0 4
1604: PPUSH
1605: LD_INT 3
1607: PPUSH
1608: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1612: LD_VAR 0 4
1616: PPUSH
1617: LD_INT 8
1619: PPUSH
1620: LD_INT 0
1622: PPUSH
1623: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1627: LD_INT 0
1629: PPUSH
1630: LD_INT 1
1632: PPUSH
1633: LD_INT 2
1635: PPUSH
1636: CALL_OW 12
1640: PPUSH
1641: LD_VAR 0 5
1645: PPUSH
1646: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1650: CALL_OW 44
1654: PPUSH
1655: LD_VAR 0 4
1659: PPUSH
1660: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1664: LD_VAR 0 4
1668: PPUSH
1669: LD_INT 500
1671: PPUSH
1672: LD_INT 1000
1674: PPUSH
1675: CALL_OW 12
1679: PPUSH
1680: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1684: LD_VAR 0 4
1688: PPUSH
1689: LD_INT 1
1691: PPUSH
1692: LD_INT 2
1694: PPUSH
1695: CALL_OW 12
1699: PPUSH
1700: LD_INT 2
1702: PPUSH
1703: LD_INT 10
1705: PPUSH
1706: CALL_OW 12
1710: PUSH
1711: LD_INT 10
1713: MUL
1714: PPUSH
1715: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1719: LD_ADDR_EXP 1
1723: PUSH
1724: LD_EXP 1
1728: PPUSH
1729: LD_INT 1
1731: PPUSH
1732: LD_VAR 0 4
1736: PUSH
1737: LD_INT 1
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PPUSH
1744: CALL_OW 2
1748: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1749: LD_VAR 0 4
1753: PPUSH
1754: LD_INT 120
1756: PPUSH
1757: LD_INT 10
1759: PPUSH
1760: CALL_OW 111
// Wait ( 0 0$02 ) ;
1764: LD_INT 70
1766: PPUSH
1767: CALL_OW 67
// end ;
1771: GO 1539
1773: POP
1774: POP
// for i = 1 to 2 do
1775: LD_ADDR_VAR 0 3
1779: PUSH
1780: DOUBLE
1781: LD_INT 1
1783: DEC
1784: ST_TO_ADDR
1785: LD_INT 2
1787: PUSH
1788: FOR_TO
1789: IFFALSE 1878
// begin PrepareHuman ( false , 1 , skill ) ;
1791: LD_INT 0
1793: PPUSH
1794: LD_INT 1
1796: PPUSH
1797: LD_VAR 0 5
1801: PPUSH
1802: CALL_OW 380
// veh := CreateHuman ;
1806: LD_ADDR_VAR 0 4
1810: PUSH
1811: CALL_OW 44
1815: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1816: LD_VAR 0 4
1820: PPUSH
1821: LD_INT 8
1823: PPUSH
1824: LD_INT 0
1826: PPUSH
1827: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
1831: LD_ADDR_EXP 2
1835: PUSH
1836: LD_EXP 2
1840: PPUSH
1841: LD_INT 1
1843: PPUSH
1844: LD_VAR 0 4
1848: PPUSH
1849: CALL_OW 2
1853: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1854: LD_VAR 0 4
1858: PPUSH
1859: LD_INT 120
1861: PPUSH
1862: LD_INT 10
1864: PPUSH
1865: CALL_OW 111
// Wait ( 0 0$02 ) ;
1869: LD_INT 70
1871: PPUSH
1872: CALL_OW 67
// end ;
1876: GO 1788
1878: POP
1879: POP
// Wait ( 0 0$02 ) ;
1880: LD_INT 70
1882: PPUSH
1883: CALL_OW 67
// conv_ready := true ;
1887: LD_ADDR_EXP 18
1891: PUSH
1892: LD_INT 1
1894: ST_TO_ADDR
// end ; 4 :
1895: GO 2710
1897: LD_INT 4
1899: DOUBLE
1900: EQUAL
1901: IFTRUE 1905
1903: GO 2175
1905: POP
// begin if Rand ( 0 , 1 ) = 1 then
1906: LD_INT 0
1908: PPUSH
1909: LD_INT 1
1911: PPUSH
1912: CALL_OW 12
1916: PUSH
1917: LD_INT 1
1919: EQUAL
1920: IFFALSE 1926
// AddEscort ( ) ;
1922: CALL 2715 0 0
// Wait ( 0 0$02 ) ;
1926: LD_INT 70
1928: PPUSH
1929: CALL_OW 67
// for i = 1 to 5 do
1933: LD_ADDR_VAR 0 3
1937: PUSH
1938: DOUBLE
1939: LD_INT 1
1941: DEC
1942: ST_TO_ADDR
1943: LD_INT 5
1945: PUSH
1946: FOR_TO
1947: IFFALSE 2051
// begin PrepareHuman ( false , Rand ( 2 , 4 ) , skill ) ;
1949: LD_INT 0
1951: PPUSH
1952: LD_INT 2
1954: PPUSH
1955: LD_INT 4
1957: PPUSH
1958: CALL_OW 12
1962: PPUSH
1963: LD_VAR 0 5
1967: PPUSH
1968: CALL_OW 380
// veh := CreateHuman ;
1972: LD_ADDR_VAR 0 4
1976: PUSH
1977: CALL_OW 44
1981: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1982: LD_VAR 0 4
1986: PPUSH
1987: LD_INT 8
1989: PPUSH
1990: LD_INT 0
1992: PPUSH
1993: CALL_OW 49
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1997: LD_ADDR_EXP 1
2001: PUSH
2002: LD_EXP 1
2006: PPUSH
2007: LD_INT 1
2009: PPUSH
2010: LD_VAR 0 4
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: EMPTY
2019: LIST
2020: LIST
2021: PPUSH
2022: CALL_OW 2
2026: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2027: LD_VAR 0 4
2031: PPUSH
2032: LD_INT 120
2034: PPUSH
2035: LD_INT 10
2037: PPUSH
2038: CALL_OW 111
// Wait ( 0 0$02 ) ;
2042: LD_INT 70
2044: PPUSH
2045: CALL_OW 67
// end ;
2049: GO 1946
2051: POP
2052: POP
// for i = 1 to 2 do
2053: LD_ADDR_VAR 0 3
2057: PUSH
2058: DOUBLE
2059: LD_INT 1
2061: DEC
2062: ST_TO_ADDR
2063: LD_INT 2
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2156
// begin PrepareHuman ( false , 1 , skill ) ;
2069: LD_INT 0
2071: PPUSH
2072: LD_INT 1
2074: PPUSH
2075: LD_VAR 0 5
2079: PPUSH
2080: CALL_OW 380
// veh := CreateHuman ;
2084: LD_ADDR_VAR 0 4
2088: PUSH
2089: CALL_OW 44
2093: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2094: LD_VAR 0 4
2098: PPUSH
2099: LD_INT 8
2101: PPUSH
2102: LD_INT 0
2104: PPUSH
2105: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
2109: LD_ADDR_EXP 2
2113: PUSH
2114: LD_EXP 2
2118: PPUSH
2119: LD_INT 1
2121: PPUSH
2122: LD_VAR 0 4
2126: PPUSH
2127: CALL_OW 2
2131: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2132: LD_VAR 0 4
2136: PPUSH
2137: LD_INT 120
2139: PPUSH
2140: LD_INT 10
2142: PPUSH
2143: CALL_OW 111
// Wait ( 0 0$02 ) ;
2147: LD_INT 70
2149: PPUSH
2150: CALL_OW 67
// end ;
2154: GO 2066
2156: POP
2157: POP
// Wait ( 0 0$02 ) ;
2158: LD_INT 70
2160: PPUSH
2161: CALL_OW 67
// conv_ready := true ;
2165: LD_ADDR_EXP 18
2169: PUSH
2170: LD_INT 1
2172: ST_TO_ADDR
// end ; 5 :
2173: GO 2710
2175: LD_INT 5
2177: DOUBLE
2178: EQUAL
2179: IFTRUE 2183
2181: GO 2709
2183: POP
// begin AddEscort ( ) ;
2184: CALL 2715 0 0
// Wait ( 0 0$02 ) ;
2188: LD_INT 70
2190: PPUSH
2191: CALL_OW 67
// AddEscort ( ) ;
2195: CALL 2715 0 0
// Wait ( 0 0$02 ) ;
2199: LD_INT 70
2201: PPUSH
2202: CALL_OW 67
// for i = 1 to 2 do
2206: LD_ADDR_VAR 0 3
2210: PUSH
2211: DOUBLE
2212: LD_INT 1
2214: DEC
2215: ST_TO_ADDR
2216: LD_INT 2
2218: PUSH
2219: FOR_TO
2220: IFFALSE 2453
// begin vc_chassis := ru_medium_wheeled ;
2222: LD_ADDR_OWVAR 37
2226: PUSH
2227: LD_INT 21
2229: ST_TO_ADDR
// vc_engine := engine_combustion ;
2230: LD_ADDR_OWVAR 39
2234: PUSH
2235: LD_INT 1
2237: ST_TO_ADDR
// vc_control := control_manual ;
2238: LD_ADDR_OWVAR 38
2242: PUSH
2243: LD_INT 1
2245: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2246: LD_ADDR_OWVAR 40
2250: PUSH
2251: LD_INT 51
2253: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2254: LD_ADDR_OWVAR 41
2258: PUSH
2259: LD_INT 50
2261: PPUSH
2262: LD_INT 99
2264: PPUSH
2265: CALL_OW 12
2269: ST_TO_ADDR
// veh := CreateVehicle ;
2270: LD_ADDR_VAR 0 4
2274: PUSH
2275: CALL_OW 45
2279: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2280: LD_VAR 0 4
2284: PPUSH
2285: LD_INT 3
2287: PPUSH
2288: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2292: LD_VAR 0 4
2296: PPUSH
2297: LD_INT 8
2299: PPUSH
2300: LD_INT 0
2302: PPUSH
2303: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2307: LD_INT 0
2309: PPUSH
2310: LD_INT 1
2312: PPUSH
2313: LD_INT 2
2315: PPUSH
2316: CALL_OW 12
2320: PPUSH
2321: LD_VAR 0 5
2325: PPUSH
2326: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2330: CALL_OW 44
2334: PPUSH
2335: LD_VAR 0 4
2339: PPUSH
2340: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2344: LD_VAR 0 4
2348: PPUSH
2349: LD_INT 500
2351: PPUSH
2352: LD_INT 1000
2354: PPUSH
2355: CALL_OW 12
2359: PPUSH
2360: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
2364: LD_VAR 0 4
2368: PPUSH
2369: LD_INT 1
2371: PPUSH
2372: LD_INT 2
2374: PPUSH
2375: CALL_OW 12
2379: PPUSH
2380: LD_INT 2
2382: PPUSH
2383: LD_INT 10
2385: PPUSH
2386: CALL_OW 12
2390: PUSH
2391: LD_INT 10
2393: MUL
2394: PPUSH
2395: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2399: LD_ADDR_EXP 1
2403: PUSH
2404: LD_EXP 1
2408: PPUSH
2409: LD_INT 1
2411: PPUSH
2412: LD_VAR 0 4
2416: PUSH
2417: LD_INT 1
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: PPUSH
2424: CALL_OW 2
2428: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2429: LD_VAR 0 4
2433: PPUSH
2434: LD_INT 120
2436: PPUSH
2437: LD_INT 10
2439: PPUSH
2440: CALL_OW 111
// Wait ( 0 0$02 ) ;
2444: LD_INT 70
2446: PPUSH
2447: CALL_OW 67
// end ;
2451: GO 2219
2453: POP
2454: POP
// if Rand ( 0 , 1 ) = 1 then
2455: LD_INT 0
2457: PPUSH
2458: LD_INT 1
2460: PPUSH
2461: CALL_OW 12
2465: PUSH
2466: LD_INT 1
2468: EQUAL
2469: IFFALSE 2505
// begin vc_chassis := ru_medium_tracked ;
2471: LD_ADDR_OWVAR 37
2475: PUSH
2476: LD_INT 22
2478: ST_TO_ADDR
// vc_engine := engine_combustion ;
2479: LD_ADDR_OWVAR 39
2483: PUSH
2484: LD_INT 1
2486: ST_TO_ADDR
// vc_control := control_manual ;
2487: LD_ADDR_OWVAR 38
2491: PUSH
2492: LD_INT 1
2494: ST_TO_ADDR
// vc_weapon := ru_crane ;
2495: LD_ADDR_OWVAR 40
2499: PUSH
2500: LD_INT 52
2502: ST_TO_ADDR
// end else
2503: GO 2537
// begin vc_chassis := ru_heavy_wheeled ;
2505: LD_ADDR_OWVAR 37
2509: PUSH
2510: LD_INT 23
2512: ST_TO_ADDR
// vc_engine := engine_combustion ;
2513: LD_ADDR_OWVAR 39
2517: PUSH
2518: LD_INT 1
2520: ST_TO_ADDR
// vc_control := control_manual ;
2521: LD_ADDR_OWVAR 38
2525: PUSH
2526: LD_INT 1
2528: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2529: LD_ADDR_OWVAR 40
2533: PUSH
2534: LD_INT 53
2536: ST_TO_ADDR
// end ; vc_fuel_battery := Rand ( 50 , 99 ) ;
2537: LD_ADDR_OWVAR 41
2541: PUSH
2542: LD_INT 50
2544: PPUSH
2545: LD_INT 99
2547: PPUSH
2548: CALL_OW 12
2552: ST_TO_ADDR
// veh := CreateVehicle ;
2553: LD_ADDR_VAR 0 4
2557: PUSH
2558: CALL_OW 45
2562: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2563: LD_VAR 0 4
2567: PPUSH
2568: LD_INT 3
2570: PPUSH
2571: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2575: LD_VAR 0 4
2579: PPUSH
2580: LD_INT 8
2582: PPUSH
2583: LD_INT 0
2585: PPUSH
2586: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2590: LD_INT 0
2592: PPUSH
2593: LD_INT 1
2595: PPUSH
2596: LD_INT 2
2598: PPUSH
2599: CALL_OW 12
2603: PPUSH
2604: LD_VAR 0 5
2608: PPUSH
2609: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2613: CALL_OW 44
2617: PPUSH
2618: LD_VAR 0 4
2622: PPUSH
2623: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2627: LD_VAR 0 4
2631: PPUSH
2632: LD_INT 500
2634: PPUSH
2635: LD_INT 1000
2637: PPUSH
2638: CALL_OW 12
2642: PPUSH
2643: CALL_OW 234
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2647: LD_ADDR_EXP 1
2651: PUSH
2652: LD_EXP 1
2656: PPUSH
2657: LD_INT 1
2659: PPUSH
2660: LD_VAR 0 4
2664: PUSH
2665: LD_INT 1
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: PPUSH
2672: CALL_OW 2
2676: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2677: LD_VAR 0 4
2681: PPUSH
2682: LD_INT 120
2684: PPUSH
2685: LD_INT 10
2687: PPUSH
2688: CALL_OW 111
// Wait ( 0 0$02 ) ;
2692: LD_INT 70
2694: PPUSH
2695: CALL_OW 67
// conv_ready := true ;
2699: LD_ADDR_EXP 18
2703: PUSH
2704: LD_INT 1
2706: ST_TO_ADDR
// end ; end ;
2707: GO 2710
2709: POP
// end ;
2710: LD_VAR 0 2
2714: RET
// export function AddEscort ( ) ; var veh , skill ; begin
2715: LD_INT 0
2717: PPUSH
2718: PPUSH
2719: PPUSH
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
2720: LD_ADDR_VAR 0 3
2724: PUSH
2725: LD_INT 5
2727: PUSH
2728: LD_INT 5
2730: PUSH
2731: LD_INT 4
2733: PUSH
2734: EMPTY
2735: LIST
2736: LIST
2737: LIST
2738: PUSH
2739: LD_OWVAR 67
2743: ARRAY
2744: ST_TO_ADDR
// uc_side := 6 ;
2745: LD_ADDR_OWVAR 20
2749: PUSH
2750: LD_INT 6
2752: ST_TO_ADDR
// uc_nation := 3 ;
2753: LD_ADDR_OWVAR 21
2757: PUSH
2758: LD_INT 3
2760: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2761: LD_ADDR_OWVAR 37
2765: PUSH
2766: LD_INT 21
2768: ST_TO_ADDR
// vc_engine := engine_combustion ;
2769: LD_ADDR_OWVAR 39
2773: PUSH
2774: LD_INT 1
2776: ST_TO_ADDR
// vc_control := control_manual ;
2777: LD_ADDR_OWVAR 38
2781: PUSH
2782: LD_INT 1
2784: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 2 ) ] ;
2785: LD_ADDR_OWVAR 40
2789: PUSH
2790: LD_INT 44
2792: PUSH
2793: LD_INT 42
2795: PUSH
2796: EMPTY
2797: LIST
2798: LIST
2799: PUSH
2800: LD_INT 1
2802: PPUSH
2803: LD_INT 2
2805: PPUSH
2806: CALL_OW 12
2810: ARRAY
2811: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2812: LD_ADDR_OWVAR 41
2816: PUSH
2817: LD_INT 50
2819: PPUSH
2820: LD_INT 99
2822: PPUSH
2823: CALL_OW 12
2827: ST_TO_ADDR
// veh := CreateVehicle ;
2828: LD_ADDR_VAR 0 2
2832: PUSH
2833: CALL_OW 45
2837: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2838: LD_VAR 0 2
2842: PPUSH
2843: LD_INT 3
2845: PPUSH
2846: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2850: LD_VAR 0 2
2854: PPUSH
2855: LD_INT 8
2857: PPUSH
2858: LD_INT 0
2860: PPUSH
2861: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
2865: LD_INT 0
2867: PPUSH
2868: LD_INT 3
2870: PPUSH
2871: LD_VAR 0 3
2875: PPUSH
2876: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2880: CALL_OW 44
2884: PPUSH
2885: LD_VAR 0 2
2889: PPUSH
2890: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2894: LD_VAR 0 2
2898: PPUSH
2899: LD_INT 500
2901: PPUSH
2902: LD_INT 1000
2904: PPUSH
2905: CALL_OW 12
2909: PPUSH
2910: CALL_OW 234
// escort := Insert ( escort , 1 , veh ) ;
2914: LD_ADDR_EXP 2
2918: PUSH
2919: LD_EXP 2
2923: PPUSH
2924: LD_INT 1
2926: PPUSH
2927: LD_VAR 0 2
2931: PPUSH
2932: CALL_OW 2
2936: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2937: LD_VAR 0 2
2941: PPUSH
2942: LD_INT 120
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 111
// end ;
2952: LD_VAR 0 1
2956: RET
// every 4 trigger conv_ready and FilterAllUnits ( [ f_side , 6 ] ) do var i , j ;
2957: LD_EXP 18
2961: PUSH
2962: LD_INT 22
2964: PUSH
2965: LD_INT 6
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: PPUSH
2972: CALL_OW 69
2976: AND
2977: IFFALSE 3710
2979: GO 2981
2981: DISABLE
2982: LD_INT 0
2984: PPUSH
2985: PPUSH
// begin enable ;
2986: ENABLE
// if conv_squad then
2987: LD_EXP 1
2991: IFFALSE 3248
// for i = conv_squad downto 1 do
2993: LD_ADDR_VAR 0 1
2997: PUSH
2998: DOUBLE
2999: LD_EXP 1
3003: INC
3004: ST_TO_ADDR
3005: LD_INT 1
3007: PUSH
3008: FOR_DOWNTO
3009: IFFALSE 3246
// begin if IsInArea ( conv_squad [ i ] [ 1 ] , conv_end ) then
3011: LD_EXP 1
3015: PUSH
3016: LD_VAR 0 1
3020: ARRAY
3021: PUSH
3022: LD_INT 1
3024: ARRAY
3025: PPUSH
3026: LD_INT 9
3028: PPUSH
3029: CALL_OW 308
3033: IFFALSE 3096
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3035: LD_ADDR_VAR 0 2
3039: PUSH
3040: LD_INT 9
3042: PPUSH
3043: LD_INT 22
3045: PUSH
3046: LD_INT 6
3048: PUSH
3049: EMPTY
3050: LIST
3051: LIST
3052: PPUSH
3053: CALL_OW 70
3057: PUSH
3058: FOR_IN
3059: IFFALSE 3072
// RemoveUnit ( j ) ;
3061: LD_VAR 0 2
3065: PPUSH
3066: CALL_OW 64
3070: GO 3058
3072: POP
3073: POP
// conv_squad := Delete ( conv_squad , i ) ;
3074: LD_ADDR_EXP 1
3078: PUSH
3079: LD_EXP 1
3083: PPUSH
3084: LD_VAR 0 1
3088: PPUSH
3089: CALL_OW 3
3093: ST_TO_ADDR
// break ;
3094: GO 3246
// end ; if IsInArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) then
3096: LD_EXP 1
3100: PUSH
3101: LD_VAR 0 1
3105: ARRAY
3106: PUSH
3107: LD_INT 1
3109: ARRAY
3110: PPUSH
3111: LD_EXP 6
3115: PUSH
3116: LD_EXP 1
3120: PUSH
3121: LD_VAR 0 1
3125: ARRAY
3126: PUSH
3127: LD_INT 2
3129: ARRAY
3130: ARRAY
3131: PPUSH
3132: CALL_OW 308
3136: IFFALSE 3182
// conv_squad := Replace2 ( conv_squad , i , 2 , conv_squad [ i ] [ 2 ] + 1 ) else
3138: LD_ADDR_EXP 1
3142: PUSH
3143: LD_EXP 1
3147: PPUSH
3148: LD_VAR 0 1
3152: PPUSH
3153: LD_INT 2
3155: PPUSH
3156: LD_EXP 1
3160: PUSH
3161: LD_VAR 0 1
3165: ARRAY
3166: PUSH
3167: LD_INT 2
3169: ARRAY
3170: PUSH
3171: LD_INT 1
3173: PLUS
3174: PPUSH
3175: CALL 9882 0 4
3179: ST_TO_ADDR
3180: GO 3244
// if not HasTask ( conv_squad [ i ] [ 1 ] ) then
3182: LD_EXP 1
3186: PUSH
3187: LD_VAR 0 1
3191: ARRAY
3192: PUSH
3193: LD_INT 1
3195: ARRAY
3196: PPUSH
3197: CALL_OW 314
3201: NOT
3202: IFFALSE 3244
// ComMoveToArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) ;
3204: LD_EXP 1
3208: PUSH
3209: LD_VAR 0 1
3213: ARRAY
3214: PUSH
3215: LD_INT 1
3217: ARRAY
3218: PPUSH
3219: LD_EXP 6
3223: PUSH
3224: LD_EXP 1
3228: PUSH
3229: LD_VAR 0 1
3233: ARRAY
3234: PUSH
3235: LD_INT 2
3237: ARRAY
3238: ARRAY
3239: PPUSH
3240: CALL_OW 113
// end ;
3244: GO 3008
3246: POP
3247: POP
// if escort then
3248: LD_EXP 2
3252: IFFALSE 3577
// for i = escort downto 1 do
3254: LD_ADDR_VAR 0 1
3258: PUSH
3259: DOUBLE
3260: LD_EXP 2
3264: INC
3265: ST_TO_ADDR
3266: LD_INT 1
3268: PUSH
3269: FOR_DOWNTO
3270: IFFALSE 3575
// begin if IsInArea ( escort [ i ] , conv_end ) then
3272: LD_EXP 2
3276: PUSH
3277: LD_VAR 0 1
3281: ARRAY
3282: PPUSH
3283: LD_INT 9
3285: PPUSH
3286: CALL_OW 308
3290: IFFALSE 3353
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3292: LD_ADDR_VAR 0 2
3296: PUSH
3297: LD_INT 9
3299: PPUSH
3300: LD_INT 22
3302: PUSH
3303: LD_INT 6
3305: PUSH
3306: EMPTY
3307: LIST
3308: LIST
3309: PPUSH
3310: CALL_OW 70
3314: PUSH
3315: FOR_IN
3316: IFFALSE 3329
// RemoveUnit ( j ) ;
3318: LD_VAR 0 2
3322: PPUSH
3323: CALL_OW 64
3327: GO 3315
3329: POP
3330: POP
// escort := Delete ( escort , i ) ;
3331: LD_ADDR_EXP 2
3335: PUSH
3336: LD_EXP 2
3340: PPUSH
3341: LD_VAR 0 1
3345: PPUSH
3346: CALL_OW 3
3350: ST_TO_ADDR
// break ;
3351: GO 3575
// end ; if FindTarget ( escort [ i ] ) and GetDistUnits ( escort [ i ] , FindTarget ( escort [ i ] ) ) < 13 then
3353: LD_EXP 2
3357: PUSH
3358: LD_VAR 0 1
3362: ARRAY
3363: PPUSH
3364: CALL 10190 0 1
3368: PUSH
3369: LD_EXP 2
3373: PUSH
3374: LD_VAR 0 1
3378: ARRAY
3379: PPUSH
3380: LD_EXP 2
3384: PUSH
3385: LD_VAR 0 1
3389: ARRAY
3390: PPUSH
3391: CALL 10190 0 1
3395: PPUSH
3396: CALL_OW 296
3400: PUSH
3401: LD_INT 13
3403: LESS
3404: AND
3405: IFFALSE 3440
// ComAttackUnit ( escort [ i ] , FindTarget ( escort [ i ] ) ) else
3407: LD_EXP 2
3411: PUSH
3412: LD_VAR 0 1
3416: ARRAY
3417: PPUSH
3418: LD_EXP 2
3422: PUSH
3423: LD_VAR 0 1
3427: ARRAY
3428: PPUSH
3429: CALL 10190 0 1
3433: PPUSH
3434: CALL_OW 115
3438: GO 3573
// if conv_squad and GetDistUnitXY ( escort [ i ] , 64 , 117 ) > 35 and not HasTask ( escort [ i ] ) then
3440: LD_EXP 1
3444: PUSH
3445: LD_EXP 2
3449: PUSH
3450: LD_VAR 0 1
3454: ARRAY
3455: PPUSH
3456: LD_INT 64
3458: PPUSH
3459: LD_INT 117
3461: PPUSH
3462: CALL_OW 297
3466: PUSH
3467: LD_INT 35
3469: GREATER
3470: AND
3471: PUSH
3472: LD_EXP 2
3476: PUSH
3477: LD_VAR 0 1
3481: ARRAY
3482: PPUSH
3483: CALL_OW 314
3487: NOT
3488: AND
3489: IFFALSE 3555
// begin if GetDistUnits ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) > 6 then
3491: LD_EXP 2
3495: PUSH
3496: LD_VAR 0 1
3500: ARRAY
3501: PPUSH
3502: LD_EXP 1
3506: PUSH
3507: LD_INT 1
3509: ARRAY
3510: PUSH
3511: LD_INT 1
3513: ARRAY
3514: PPUSH
3515: CALL_OW 296
3519: PUSH
3520: LD_INT 6
3522: GREATER
3523: IFFALSE 3553
// ComMoveUnit ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) end else
3525: LD_EXP 2
3529: PUSH
3530: LD_VAR 0 1
3534: ARRAY
3535: PPUSH
3536: LD_EXP 1
3540: PUSH
3541: LD_INT 1
3543: ARRAY
3544: PUSH
3545: LD_INT 1
3547: ARRAY
3548: PPUSH
3549: CALL_OW 112
3553: GO 3573
// ComMoveToArea ( escort [ i ] , conv_end ) ;
3555: LD_EXP 2
3559: PUSH
3560: LD_VAR 0 1
3564: ARRAY
3565: PPUSH
3566: LD_INT 9
3568: PPUSH
3569: CALL_OW 113
// end ;
3573: GO 3269
3575: POP
3576: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) then
3577: LD_INT 22
3579: PUSH
3580: LD_INT 6
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: PUSH
3587: LD_INT 21
3589: PUSH
3590: LD_INT 1
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: PUSH
3597: EMPTY
3598: LIST
3599: LIST
3600: PPUSH
3601: CALL_OW 69
3605: IFFALSE 3710
// for j in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) do
3607: LD_ADDR_VAR 0 2
3611: PUSH
3612: LD_INT 22
3614: PUSH
3615: LD_INT 6
3617: PUSH
3618: EMPTY
3619: LIST
3620: LIST
3621: PUSH
3622: LD_INT 21
3624: PUSH
3625: LD_INT 1
3627: PUSH
3628: EMPTY
3629: LIST
3630: LIST
3631: PUSH
3632: EMPTY
3633: LIST
3634: LIST
3635: PPUSH
3636: CALL_OW 69
3640: PUSH
3641: FOR_IN
3642: IFFALSE 3708
// begin if not HasTask ( j ) and not IsInArea ( j , conv_end ) then
3644: LD_VAR 0 2
3648: PPUSH
3649: CALL_OW 314
3653: NOT
3654: PUSH
3655: LD_VAR 0 2
3659: PPUSH
3660: LD_INT 9
3662: PPUSH
3663: CALL_OW 308
3667: NOT
3668: AND
3669: IFFALSE 3683
// ComMoveToArea ( j , conv_end ) ;
3671: LD_VAR 0 2
3675: PPUSH
3676: LD_INT 9
3678: PPUSH
3679: CALL_OW 113
// if IsInArea ( j , conv_end ) then
3683: LD_VAR 0 2
3687: PPUSH
3688: LD_INT 9
3690: PPUSH
3691: CALL_OW 308
3695: IFFALSE 3706
// RemoveUnit ( j ) ;
3697: LD_VAR 0 2
3701: PPUSH
3702: CALL_OW 64
// end ;
3706: GO 3641
3708: POP
3709: POP
// end ;
3710: PPOPN 2
3712: END
// every 0 0$01 trigger UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do var i ;
3713: LD_EXP 2
3717: PUSH
3718: LD_EXP 1
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PPUSH
3727: LD_INT 22
3729: PUSH
3730: LD_INT 3
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: PPUSH
3737: CALL_OW 72
3741: IFFALSE 3803
3743: GO 3745
3745: DISABLE
3746: LD_INT 0
3748: PPUSH
// begin enable ;
3749: ENABLE
// for i in UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do
3750: LD_ADDR_VAR 0 1
3754: PUSH
3755: LD_EXP 2
3759: PUSH
3760: LD_EXP 1
3764: PUSH
3765: EMPTY
3766: LIST
3767: LIST
3768: PPUSH
3769: LD_INT 22
3771: PUSH
3772: LD_INT 3
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: PPUSH
3779: CALL_OW 72
3783: PUSH
3784: FOR_IN
3785: IFFALSE 3801
// SetSide ( i , 6 ) ;
3787: LD_VAR 0 1
3791: PPUSH
3792: LD_INT 6
3794: PPUSH
3795: CALL_OW 235
3799: GO 3784
3801: POP
3802: POP
// end ; end_of_file
3803: PPOPN 1
3805: END
// export Collins ; export us_alert , us_retreat , us_patrol , us_count ; export function PrepareAmerican ; var i , un , skill , towers ; begin
3806: LD_INT 0
3808: PPUSH
3809: PPUSH
3810: PPUSH
3811: PPUSH
3812: PPUSH
// uc_side := 1 ;
3813: LD_ADDR_OWVAR 20
3817: PUSH
3818: LD_INT 1
3820: ST_TO_ADDR
// uc_nation := 1 ;
3821: LD_ADDR_OWVAR 21
3825: PUSH
3826: LD_INT 1
3828: ST_TO_ADDR
// us_alert := false ;
3829: LD_ADDR_EXP 20
3833: PUSH
3834: LD_INT 0
3836: ST_TO_ADDR
// us_retreat := false ;
3837: LD_ADDR_EXP 21
3841: PUSH
3842: LD_INT 0
3844: ST_TO_ADDR
// us_patrol := false ;
3845: LD_ADDR_EXP 22
3849: PUSH
3850: LD_INT 0
3852: ST_TO_ADDR
// us_count := 0 ;
3853: LD_ADDR_EXP 23
3857: PUSH
3858: LD_INT 0
3860: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
3861: LD_ADDR_VAR 0 4
3865: PUSH
3866: LD_INT 5
3868: PUSH
3869: LD_INT 6
3871: PUSH
3872: LD_INT 7
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: LIST
3879: PUSH
3880: LD_OWVAR 67
3884: ARRAY
3885: ST_TO_ADDR
// hc_class := 1 ;
3886: LD_ADDR_OWVAR 28
3890: PUSH
3891: LD_INT 1
3893: ST_TO_ADDR
// hc_sex := sex_male ;
3894: LD_ADDR_OWVAR 27
3898: PUSH
3899: LD_INT 1
3901: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
3902: LD_ADDR_OWVAR 31
3906: PUSH
3907: LD_INT 6
3909: PUSH
3910: LD_INT 3
3912: PUSH
3913: LD_INT 4
3915: PUSH
3916: LD_INT 2
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: LIST
3924: ST_TO_ADDR
// hc_name := Jack Collins ;
3925: LD_ADDR_OWVAR 26
3929: PUSH
3930: LD_STRING Jack Collins
3932: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
3933: LD_ADDR_OWVAR 29
3937: PUSH
3938: LD_INT 11
3940: PUSH
3941: LD_INT 11
3943: PUSH
3944: EMPTY
3945: LIST
3946: LIST
3947: ST_TO_ADDR
// hc_gallery :=  ;
3948: LD_ADDR_OWVAR 33
3952: PUSH
3953: LD_STRING 
3955: ST_TO_ADDR
// Collins := CreateHuman ;
3956: LD_ADDR_EXP 19
3960: PUSH
3961: CALL_OW 44
3965: ST_TO_ADDR
// PlaceHumanInUnit ( Collins , us_depot ) ;
3966: LD_EXP 19
3970: PPUSH
3971: LD_INT 50
3973: PPUSH
3974: CALL_OW 52
// hc_name :=  ;
3978: LD_ADDR_OWVAR 26
3982: PUSH
3983: LD_STRING 
3985: ST_TO_ADDR
// if Difficulty > 1 then
3986: LD_OWVAR 67
3990: PUSH
3991: LD_INT 1
3993: GREATER
3994: IFFALSE 4048
// begin bc_type := b_bunker ;
3996: LD_ADDR_OWVAR 42
4000: PUSH
4001: LD_INT 32
4003: ST_TO_ADDR
// bc_level := 5 ;
4004: LD_ADDR_OWVAR 43
4008: PUSH
4009: LD_INT 5
4011: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 40 , 33 , 2 ) ;
4012: LD_INT 40
4014: PPUSH
4015: LD_INT 33
4017: PPUSH
4018: LD_INT 2
4020: PPUSH
4021: CALL_OW 47
// if Difficulty > 2 then
4025: LD_OWVAR 67
4029: PUSH
4030: LD_INT 2
4032: GREATER
4033: IFFALSE 4048
// CreateAndPlaceBuildingXYD ( 41 , 42 , 0 ) ;
4035: LD_INT 41
4037: PPUSH
4038: LD_INT 42
4040: PPUSH
4041: LD_INT 0
4043: PPUSH
4044: CALL_OW 47
// end ; PrepareHuman ( false , 2 , skill ) ;
4048: LD_INT 0
4050: PPUSH
4051: LD_INT 2
4053: PPUSH
4054: LD_VAR 0 4
4058: PPUSH
4059: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
4063: CALL_OW 44
4067: PPUSH
4068: LD_INT 50
4070: PPUSH
4071: CALL_OW 52
// PrepareHuman ( false , 3 , skill ) ;
4075: LD_INT 0
4077: PPUSH
4078: LD_INT 3
4080: PPUSH
4081: LD_VAR 0 4
4085: PPUSH
4086: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4090: CALL_OW 44
4094: PPUSH
4095: LD_INT 56
4097: PPUSH
4098: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4102: CALL_OW 44
4106: PPUSH
4107: LD_INT 56
4109: PPUSH
4110: CALL_OW 52
// PrepareHuman ( false , 4 , skill ) ;
4114: LD_INT 0
4116: PPUSH
4117: LD_INT 4
4119: PPUSH
4120: LD_VAR 0 4
4124: PPUSH
4125: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
4129: CALL_OW 44
4133: PPUSH
4134: LD_INT 63
4136: PPUSH
4137: CALL_OW 52
// PrepareHuman ( false , 1 , skill ) ;
4141: LD_INT 0
4143: PPUSH
4144: LD_INT 1
4146: PPUSH
4147: LD_VAR 0 4
4151: PPUSH
4152: CALL_OW 380
// un := CreateHuman ;
4156: LD_ADDR_VAR 0 3
4160: PUSH
4161: CALL_OW 44
4165: ST_TO_ADDR
// SetDir ( un , 4 ) ;
4166: LD_VAR 0 3
4170: PPUSH
4171: LD_INT 4
4173: PPUSH
4174: CALL_OW 233
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
4178: LD_VAR 0 3
4182: PPUSH
4183: LD_INT 22
4185: PUSH
4186: LD_INT 1
4188: PUSH
4189: EMPTY
4190: LIST
4191: LIST
4192: PUSH
4193: LD_INT 30
4195: PUSH
4196: LD_INT 31
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: PUSH
4203: EMPTY
4204: LIST
4205: LIST
4206: PPUSH
4207: CALL_OW 69
4211: PUSH
4212: LD_INT 1
4214: ARRAY
4215: PPUSH
4216: CALL_OW 52
// towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) ;
4220: LD_ADDR_VAR 0 5
4224: PUSH
4225: LD_INT 22
4227: PUSH
4228: LD_INT 1
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PUSH
4235: LD_INT 30
4237: PUSH
4238: LD_INT 32
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PPUSH
4249: CALL_OW 69
4253: ST_TO_ADDR
// for i in towers do
4254: LD_ADDR_VAR 0 2
4258: PUSH
4259: LD_VAR 0 5
4263: PUSH
4264: FOR_IN
4265: IFFALSE 4333
// begin PrepareHuman ( false , 1 , skill ) ;
4267: LD_INT 0
4269: PPUSH
4270: LD_INT 1
4272: PPUSH
4273: LD_VAR 0 4
4277: PPUSH
4278: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4282: CALL_OW 44
4286: PPUSH
4287: LD_VAR 0 2
4291: PPUSH
4292: CALL_OW 52
// PlaceWeaponTurret ( i , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
4296: LD_VAR 0 2
4300: PPUSH
4301: LD_INT 4
4303: PUSH
4304: LD_INT 3
4306: PUSH
4307: LD_INT 5
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: LIST
4314: PUSH
4315: LD_INT 1
4317: PPUSH
4318: LD_INT 3
4320: PPUSH
4321: CALL_OW 12
4325: ARRAY
4326: PPUSH
4327: CALL_OW 431
// end ;
4331: GO 4264
4333: POP
4334: POP
// PrepareHuman ( false , 1 , skill ) ;
4335: LD_INT 0
4337: PPUSH
4338: LD_INT 1
4340: PPUSH
4341: LD_VAR 0 4
4345: PPUSH
4346: CALL_OW 380
// us_patrol := CreateHuman ;
4350: LD_ADDR_EXP 22
4354: PUSH
4355: CALL_OW 44
4359: ST_TO_ADDR
// PlaceUnitXY ( us_patrol , 12 , 5 , false ) ;
4360: LD_EXP 22
4364: PPUSH
4365: LD_INT 12
4367: PPUSH
4368: LD_INT 5
4370: PPUSH
4371: LD_INT 0
4373: PPUSH
4374: CALL_OW 48
// end ;
4378: LD_VAR 0 1
4382: RET
// every 0 0$01 trigger us_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
4383: LD_EXP 23
4387: PUSH
4388: LD_INT 3
4390: PUSH
4391: LD_INT 4
4393: PUSH
4394: LD_INT 5
4396: PUSH
4397: EMPTY
4398: LIST
4399: LIST
4400: LIST
4401: PUSH
4402: LD_OWVAR 67
4406: ARRAY
4407: GREATEREQUAL
4408: IFFALSE 4433
4410: GO 4412
4412: DISABLE
// begin Say ( Collins , DPM_C2 ) ;
4413: LD_EXP 19
4417: PPUSH
4418: LD_STRING DPM_C2
4420: PPUSH
4421: CALL_OW 88
// us_retreat := true ;
4425: LD_ADDR_EXP 21
4429: PUSH
4430: LD_INT 1
4432: ST_TO_ADDR
// end ;
4433: END
// every 10 10$00 trigger not us_alert do var R ;
4434: LD_EXP 20
4438: NOT
4439: IFFALSE 4513
4441: GO 4443
4443: DISABLE
4444: LD_INT 0
4446: PPUSH
// begin uc_side := 1 ;
4447: LD_ADDR_OWVAR 20
4451: PUSH
4452: LD_INT 1
4454: ST_TO_ADDR
// uc_nation := 1 ;
4455: LD_ADDR_OWVAR 21
4459: PUSH
4460: LD_INT 1
4462: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
4463: LD_INT 0
4465: PPUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 0
4471: PPUSH
4472: CALL_OW 380
// R := CreateHuman ;
4476: LD_ADDR_VAR 0 1
4480: PUSH
4481: CALL_OW 44
4485: ST_TO_ADDR
// SayRadio ( R , DPM_R1 ) ;
4486: LD_VAR 0 1
4490: PPUSH
4491: LD_STRING DPM_R1
4493: PPUSH
4494: CALL_OW 94
// Wait ( 0 0$03 ) ;
4498: LD_INT 105
4500: PPUSH
4501: CALL_OW 67
// us_retreat := true ;
4505: LD_ADDR_EXP 21
4509: PUSH
4510: LD_INT 1
4512: ST_TO_ADDR
// end ;
4513: PPOPN 1
4515: END
// every 0 0$01 trigger us_alert do var i ;
4516: LD_EXP 20
4520: IFFALSE 4768
4522: GO 4524
4524: DISABLE
4525: LD_INT 0
4527: PPUSH
// begin if UnitsInside ( us_fac ) then
4528: LD_INT 56
4530: PPUSH
4531: CALL_OW 313
4535: IFFALSE 4590
// for i in UnitsInside ( us_fac ) do
4537: LD_ADDR_VAR 0 1
4541: PUSH
4542: LD_INT 56
4544: PPUSH
4545: CALL_OW 313
4549: PUSH
4550: FOR_IN
4551: IFFALSE 4588
// begin ComExitBuilding ( i ) ;
4553: LD_VAR 0 1
4557: PPUSH
4558: CALL_OW 122
// AddComEnterUnit ( i , us_arm ) ;
4562: LD_VAR 0 1
4566: PPUSH
4567: LD_INT 69
4569: PPUSH
4570: CALL_OW 180
// AddComChangeProfession ( i , 1 ) ;
4574: LD_VAR 0 1
4578: PPUSH
4579: LD_INT 1
4581: PPUSH
4582: CALL_OW 183
// end ;
4586: GO 4550
4588: POP
4589: POP
// ComExitBuilding ( Collins ) ;
4590: LD_EXP 19
4594: PPUSH
4595: CALL_OW 122
// AddComEnterUnit ( Collins , us_arm ) ;
4599: LD_EXP 19
4603: PPUSH
4604: LD_INT 69
4606: PPUSH
4607: CALL_OW 180
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] ) ;
4611: LD_INT 22
4613: PUSH
4614: LD_INT 1
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PUSH
4621: LD_INT 25
4623: PUSH
4624: LD_INT 2
4626: PUSH
4627: EMPTY
4628: LIST
4629: LIST
4630: PUSH
4631: EMPTY
4632: LIST
4633: LIST
4634: PPUSH
4635: CALL_OW 69
4639: PUSH
4640: LD_INT 1
4642: ARRAY
4643: PPUSH
4644: CALL_OW 122
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , 67 , 52 ) ;
4648: LD_INT 22
4650: PUSH
4651: LD_INT 1
4653: PUSH
4654: EMPTY
4655: LIST
4656: LIST
4657: PUSH
4658: LD_INT 25
4660: PUSH
4661: LD_INT 2
4663: PUSH
4664: EMPTY
4665: LIST
4666: LIST
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PPUSH
4672: CALL_OW 69
4676: PUSH
4677: LD_INT 1
4679: ARRAY
4680: PPUSH
4681: LD_INT 67
4683: PPUSH
4684: LD_INT 52
4686: PPUSH
4687: CALL_OW 171
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] ) ;
4691: LD_INT 22
4693: PUSH
4694: LD_INT 1
4696: PUSH
4697: EMPTY
4698: LIST
4699: LIST
4700: PUSH
4701: LD_INT 25
4703: PUSH
4704: LD_INT 4
4706: PUSH
4707: EMPTY
4708: LIST
4709: LIST
4710: PUSH
4711: EMPTY
4712: LIST
4713: LIST
4714: PPUSH
4715: CALL_OW 69
4719: PUSH
4720: LD_INT 1
4722: ARRAY
4723: PPUSH
4724: CALL_OW 122
// AddComEnterUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] , us_arm ) ;
4728: LD_INT 22
4730: PUSH
4731: LD_INT 1
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: LD_INT 25
4740: PUSH
4741: LD_INT 4
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PUSH
4748: EMPTY
4749: LIST
4750: LIST
4751: PPUSH
4752: CALL_OW 69
4756: PUSH
4757: LD_INT 1
4759: ARRAY
4760: PPUSH
4761: LD_INT 69
4763: PPUSH
4764: CALL_OW 180
// end ;
4768: PPOPN 1
4770: END
// every 3 3$00 trigger not us_alert and GetSide ( us_fac ) = 1 do
4771: LD_EXP 20
4775: NOT
4776: PUSH
4777: LD_INT 56
4779: PPUSH
4780: CALL_OW 255
4784: PUSH
4785: LD_INT 1
4787: EQUAL
4788: AND
4789: IFFALSE 4832
4791: GO 4793
4793: DISABLE
// begin AddComConstruct ( us_fac , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun ) ;
4794: LD_INT 56
4796: PPUSH
4797: LD_INT 2
4799: PPUSH
4800: LD_INT 1
4802: PPUSH
4803: LD_INT 1
4805: PPUSH
4806: LD_INT 4
4808: PPUSH
4809: CALL_OW 185
// AddComConstruct ( us_fac , us_medium_tracked , engine_solar , control_manual , us_double_gun ) ;
4813: LD_INT 56
4815: PPUSH
4816: LD_INT 3
4818: PPUSH
4819: LD_INT 2
4821: PPUSH
4822: LD_INT 1
4824: PPUSH
4825: LD_INT 5
4827: PPUSH
4828: CALL_OW 185
// end ;
4832: END
// every 0 0$01 trigger us_patrol do
4833: LD_EXP 22
4837: IFFALSE 4885
4839: GO 4841
4841: DISABLE
// SetPatrol ( us_patrol , [ 12 , 5 , 56 , 4 , 94 , 34 , 92 , 108 ] ) ;
4842: LD_EXP 22
4846: PPUSH
4847: LD_INT 12
4849: PUSH
4850: LD_INT 5
4852: PUSH
4853: LD_INT 56
4855: PUSH
4856: LD_INT 4
4858: PUSH
4859: LD_INT 94
4861: PUSH
4862: LD_INT 34
4864: PUSH
4865: LD_INT 92
4867: PUSH
4868: LD_INT 108
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: PPUSH
4881: CALL 4886 0 2
4885: END
// export function SetPatrol ( un , points ) ; var s , i , turn ; begin
4886: LD_INT 0
4888: PPUSH
4889: PPUSH
4890: PPUSH
4891: PPUSH
// s = 1 ;
4892: LD_ADDR_VAR 0 4
4896: PUSH
4897: LD_INT 1
4899: ST_TO_ADDR
// turn := true ;
4900: LD_ADDR_VAR 0 6
4904: PUSH
4905: LD_INT 1
4907: ST_TO_ADDR
// while ( un and not us_alert ) do
4908: LD_VAR 0 1
4912: PUSH
4913: LD_EXP 20
4917: NOT
4918: AND
4919: IFFALSE 5098
// begin wait ( 35 ) ;
4921: LD_INT 35
4923: PPUSH
4924: CALL_OW 67
// if not HasTask ( un ) then
4928: LD_VAR 0 1
4932: PPUSH
4933: CALL_OW 314
4937: NOT
4938: IFFALSE 5057
// begin ComMoveXY ( un , points [ s ] , points [ s + 1 ] ) ;
4940: LD_VAR 0 1
4944: PPUSH
4945: LD_VAR 0 2
4949: PUSH
4950: LD_VAR 0 4
4954: ARRAY
4955: PPUSH
4956: LD_VAR 0 2
4960: PUSH
4961: LD_VAR 0 4
4965: PUSH
4966: LD_INT 1
4968: PLUS
4969: ARRAY
4970: PPUSH
4971: CALL_OW 111
// if s + 2 > points then
4975: LD_VAR 0 4
4979: PUSH
4980: LD_INT 2
4982: PLUS
4983: PUSH
4984: LD_VAR 0 2
4988: GREATER
4989: IFFALSE 4999
// turn := false ;
4991: LD_ADDR_VAR 0 6
4995: PUSH
4996: LD_INT 0
4998: ST_TO_ADDR
// if s - 2 < 1 then
4999: LD_VAR 0 4
5003: PUSH
5004: LD_INT 2
5006: MINUS
5007: PUSH
5008: LD_INT 1
5010: LESS
5011: IFFALSE 5021
// turn := true ;
5013: LD_ADDR_VAR 0 6
5017: PUSH
5018: LD_INT 1
5020: ST_TO_ADDR
// if turn then
5021: LD_VAR 0 6
5025: IFFALSE 5043
// s := s + 2 else
5027: LD_ADDR_VAR 0 4
5031: PUSH
5032: LD_VAR 0 4
5036: PUSH
5037: LD_INT 2
5039: PLUS
5040: ST_TO_ADDR
5041: GO 5057
// s := s - 2 ;
5043: LD_ADDR_VAR 0 4
5047: PUSH
5048: LD_VAR 0 4
5052: PUSH
5053: LD_INT 2
5055: MINUS
5056: ST_TO_ADDR
// end ; if GetLives ( un ) < 1000 or See ( 3 , un ) then
5057: LD_VAR 0 1
5061: PPUSH
5062: CALL_OW 256
5066: PUSH
5067: LD_INT 1000
5069: LESS
5070: PUSH
5071: LD_INT 3
5073: PPUSH
5074: LD_VAR 0 1
5078: PPUSH
5079: CALL_OW 292
5083: OR
5084: IFFALSE 5096
// begin us_alert := true ;
5086: LD_ADDR_EXP 20
5090: PUSH
5091: LD_INT 1
5093: ST_TO_ADDR
// break ;
5094: GO 5098
// end ; end ;
5096: GO 4908
// ComEnterUnit ( un , us_arm ) ;
5098: LD_VAR 0 1
5102: PPUSH
5103: LD_INT 69
5105: PPUSH
5106: CALL_OW 120
// end ;
5110: LD_VAR 0 3
5114: RET
// every 0 0$01 trigger us_retreat do var i , point ;
5115: LD_EXP 21
5119: IFFALSE 5294
5121: GO 5123
5123: DISABLE
5124: LD_INT 0
5126: PPUSH
5127: PPUSH
// begin point := false ;
5128: LD_ADDR_VAR 0 2
5132: PUSH
5133: LD_INT 0
5135: ST_TO_ADDR
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5136: LD_INT 5
5138: PPUSH
5139: LD_INT 22
5141: PUSH
5142: LD_INT 3
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PPUSH
5149: CALL_OW 70
5153: PUSH
5154: LD_INT 0
5156: EQUAL
5157: IFFALSE 5169
// point := us_ret1 else
5159: LD_ADDR_VAR 0 2
5163: PUSH
5164: LD_INT 3
5166: ST_TO_ADDR
5167: GO 5210
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5169: LD_INT 5
5171: PPUSH
5172: LD_INT 22
5174: PUSH
5175: LD_INT 3
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: PPUSH
5182: CALL_OW 70
5186: PUSH
5187: LD_INT 0
5189: EQUAL
5190: IFFALSE 5202
// point := us_ret2 else
5192: LD_ADDR_VAR 0 2
5196: PUSH
5197: LD_INT 2
5199: ST_TO_ADDR
5200: GO 5210
// point := us_ret3 ;
5202: LD_ADDR_VAR 0 2
5206: PUSH
5207: LD_INT 4
5209: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
5210: LD_ADDR_VAR 0 1
5214: PUSH
5215: LD_INT 22
5217: PUSH
5218: LD_INT 1
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 21
5227: PUSH
5228: LD_INT 1
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PUSH
5235: EMPTY
5236: LIST
5237: LIST
5238: PPUSH
5239: CALL_OW 69
5243: PUSH
5244: FOR_IN
5245: IFFALSE 5292
// begin if IsInUnit ( i ) then
5247: LD_VAR 0 1
5251: PPUSH
5252: CALL_OW 310
5256: IFFALSE 5276
// begin ComExitBuilding ( i ) ;
5258: LD_VAR 0 1
5262: PPUSH
5263: CALL_OW 122
// ComExitVehicle ( i ) ;
5267: LD_VAR 0 1
5271: PPUSH
5272: CALL_OW 121
// end ; AddComMoveToArea ( i , point ) ;
5276: LD_VAR 0 1
5280: PPUSH
5281: LD_VAR 0 2
5285: PPUSH
5286: CALL_OW 173
// end ;
5290: GO 5244
5292: POP
5293: POP
// end ;
5294: PPOPN 2
5296: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) do
5297: LD_EXP 21
5301: PUSH
5302: LD_INT 3
5304: PPUSH
5305: LD_INT 22
5307: PUSH
5308: LD_INT 1
5310: PUSH
5311: EMPTY
5312: LIST
5313: LIST
5314: PPUSH
5315: CALL_OW 70
5319: AND
5320: IFFALSE 5366
5322: GO 5324
5324: DISABLE
// begin enable ;
5325: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) [ 1 ] ) ;
5326: LD_INT 3
5328: PPUSH
5329: LD_INT 22
5331: PUSH
5332: LD_INT 1
5334: PUSH
5335: EMPTY
5336: LIST
5337: LIST
5338: PPUSH
5339: CALL_OW 70
5343: PUSH
5344: LD_INT 1
5346: ARRAY
5347: PPUSH
5348: CALL_OW 64
// if medal1 then
5352: LD_EXP 3
5356: IFFALSE 5366
// medal1 := false ;
5358: LD_ADDR_EXP 3
5362: PUSH
5363: LD_INT 0
5365: ST_TO_ADDR
// end ;
5366: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) do
5367: LD_EXP 21
5371: PUSH
5372: LD_INT 2
5374: PPUSH
5375: LD_INT 22
5377: PUSH
5378: LD_INT 1
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 70
5389: AND
5390: IFFALSE 5436
5392: GO 5394
5394: DISABLE
// begin enable ;
5395: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) [ 1 ] ) ;
5396: LD_INT 2
5398: PPUSH
5399: LD_INT 22
5401: PUSH
5402: LD_INT 1
5404: PUSH
5405: EMPTY
5406: LIST
5407: LIST
5408: PPUSH
5409: CALL_OW 70
5413: PUSH
5414: LD_INT 1
5416: ARRAY
5417: PPUSH
5418: CALL_OW 64
// if medal1 then
5422: LD_EXP 3
5426: IFFALSE 5436
// medal1 := false ;
5428: LD_ADDR_EXP 3
5432: PUSH
5433: LD_INT 0
5435: ST_TO_ADDR
// end ;
5436: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) do
5437: LD_EXP 21
5441: PUSH
5442: LD_INT 4
5444: PPUSH
5445: LD_INT 22
5447: PUSH
5448: LD_INT 1
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: PPUSH
5455: CALL_OW 70
5459: AND
5460: IFFALSE 5506
5462: GO 5464
5464: DISABLE
// begin enable ;
5465: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) [ 1 ] ) ;
5466: LD_INT 4
5468: PPUSH
5469: LD_INT 22
5471: PUSH
5472: LD_INT 1
5474: PUSH
5475: EMPTY
5476: LIST
5477: LIST
5478: PPUSH
5479: CALL_OW 70
5483: PUSH
5484: LD_INT 1
5486: ARRAY
5487: PPUSH
5488: CALL_OW 64
// if medal1 then
5492: LD_EXP 3
5496: IFFALSE 5506
// medal1 := false ;
5498: LD_ADDR_EXP 3
5502: PUSH
5503: LD_INT 0
5505: ST_TO_ADDR
// end ;
5506: END
// every 0 0$03 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
5507: LD_INT 22
5509: PUSH
5510: LD_INT 1
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PPUSH
5517: CALL_OW 69
5521: PUSH
5522: LD_INT 0
5524: EQUAL
5525: IFFALSE 5538
5527: GO 5529
5529: DISABLE
// us_retreat := false ;
5530: LD_ADDR_EXP 21
5534: PUSH
5535: LD_INT 0
5537: ST_TO_ADDR
5538: END
// export function CounterAttack ; var i , j , un , skill ; begin
5539: LD_INT 0
5541: PPUSH
5542: PPUSH
5543: PPUSH
5544: PPUSH
5545: PPUSH
// uc_side := 1 ;
5546: LD_ADDR_OWVAR 20
5550: PUSH
5551: LD_INT 1
5553: ST_TO_ADDR
// uc_nation := 1 ;
5554: LD_ADDR_OWVAR 21
5558: PUSH
5559: LD_INT 1
5561: ST_TO_ADDR
// skill := [ 4 , 5 , 5 ] [ Difficulty ] ;
5562: LD_ADDR_VAR 0 5
5566: PUSH
5567: LD_INT 4
5569: PUSH
5570: LD_INT 5
5572: PUSH
5573: LD_INT 5
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: LIST
5580: PUSH
5581: LD_OWVAR 67
5585: ARRAY
5586: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5587: LD_ADDR_VAR 0 2
5591: PUSH
5592: DOUBLE
5593: LD_INT 1
5595: DEC
5596: ST_TO_ADDR
5597: LD_INT 4
5599: PUSH
5600: LD_INT 5
5602: PUSH
5603: LD_INT 6
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: PUSH
5611: LD_OWVAR 67
5615: ARRAY
5616: PUSH
5617: FOR_TO
5618: IFFALSE 5818
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
5620: LD_ADDR_OWVAR 37
5624: PUSH
5625: LD_INT 2
5627: PUSH
5628: LD_INT 3
5630: PUSH
5631: LD_INT 4
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 1
5641: PPUSH
5642: LD_INT 3
5644: PPUSH
5645: CALL_OW 12
5649: ARRAY
5650: ST_TO_ADDR
// vc_engine := engine_combustion ;
5651: LD_ADDR_OWVAR 39
5655: PUSH
5656: LD_INT 1
5658: ST_TO_ADDR
// vc_control := control_manual ;
5659: LD_ADDR_OWVAR 38
5663: PUSH
5664: LD_INT 1
5666: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_light_gun ] [ Rand ( 1 , 3 ) ] ;
5667: LD_ADDR_OWVAR 40
5671: PUSH
5672: LD_INT 4
5674: PUSH
5675: LD_INT 5
5677: PUSH
5678: LD_INT 3
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 1
5688: PPUSH
5689: LD_INT 3
5691: PPUSH
5692: CALL_OW 12
5696: ARRAY
5697: ST_TO_ADDR
// vc_fuel_battery := Rand ( 88 , 99 ) ;
5698: LD_ADDR_OWVAR 41
5702: PUSH
5703: LD_INT 88
5705: PPUSH
5706: LD_INT 99
5708: PPUSH
5709: CALL_OW 12
5713: ST_TO_ADDR
// un := CreateVehicle ;
5714: LD_ADDR_VAR 0 4
5718: PUSH
5719: CALL_OW 45
5723: ST_TO_ADDR
// PlaceUnitXY ( un , 64 , 117 , false ) ;
5724: LD_VAR 0 4
5728: PPUSH
5729: LD_INT 64
5731: PPUSH
5732: LD_INT 117
5734: PPUSH
5735: LD_INT 0
5737: PPUSH
5738: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
5742: LD_INT 0
5744: PPUSH
5745: LD_INT 3
5747: PPUSH
5748: LD_VAR 0 5
5752: PPUSH
5753: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5757: CALL_OW 44
5761: PPUSH
5762: LD_VAR 0 4
5766: PPUSH
5767: CALL_OW 52
// us_force := Insert ( us_force , 1 , un ) ;
5771: LD_ADDR_EXP 12
5775: PUSH
5776: LD_EXP 12
5780: PPUSH
5781: LD_INT 1
5783: PPUSH
5784: LD_VAR 0 4
5788: PPUSH
5789: CALL_OW 2
5793: ST_TO_ADDR
// ComMoveXY ( un , 60 , 109 ) ;
5794: LD_VAR 0 4
5798: PPUSH
5799: LD_INT 60
5801: PPUSH
5802: LD_INT 109
5804: PPUSH
5805: CALL_OW 111
// Wait ( 0 0$02 ) ;
5809: LD_INT 70
5811: PPUSH
5812: CALL_OW 67
// end ;
5816: GO 5617
5818: POP
5819: POP
// while ( FilterAllUnits ( [ f_side , 1 ] ) ) do
5820: LD_INT 22
5822: PUSH
5823: LD_INT 1
5825: PUSH
5826: EMPTY
5827: LIST
5828: LIST
5829: PPUSH
5830: CALL_OW 69
5834: IFFALSE 6035
// begin Wait ( 0 0$01 ) ;
5836: LD_INT 35
5838: PPUSH
5839: CALL_OW 67
// for i = 1 to us_force do
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: DOUBLE
5849: LD_INT 1
5851: DEC
5852: ST_TO_ADDR
5853: LD_EXP 12
5857: PUSH
5858: FOR_TO
5859: IFFALSE 5894
// ComAttackUnit ( us_force [ i ] , FindTarget ( us_force [ i ] ) ) ;
5861: LD_EXP 12
5865: PUSH
5866: LD_VAR 0 2
5870: ARRAY
5871: PPUSH
5872: LD_EXP 12
5876: PUSH
5877: LD_VAR 0 2
5881: ARRAY
5882: PPUSH
5883: CALL 10190 0 1
5887: PPUSH
5888: CALL_OW 115
5892: GO 5858
5894: POP
5895: POP
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) then
5896: LD_INT 22
5898: PUSH
5899: LD_INT 1
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: LD_INT 25
5908: PUSH
5909: LD_INT 3
5911: PUSH
5912: EMPTY
5913: LIST
5914: LIST
5915: PUSH
5916: LD_INT 3
5918: PUSH
5919: LD_INT 55
5921: PUSH
5922: EMPTY
5923: LIST
5924: PUSH
5925: EMPTY
5926: LIST
5927: LIST
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 69
5938: IFFALSE 6033
// for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) do
5940: LD_ADDR_VAR 0 3
5944: PUSH
5945: LD_INT 22
5947: PUSH
5948: LD_INT 1
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: PUSH
5955: LD_INT 25
5957: PUSH
5958: LD_INT 3
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: PUSH
5965: LD_INT 3
5967: PUSH
5968: LD_INT 55
5970: PUSH
5971: EMPTY
5972: LIST
5973: PUSH
5974: EMPTY
5975: LIST
5976: LIST
5977: PUSH
5978: EMPTY
5979: LIST
5980: LIST
5981: LIST
5982: PPUSH
5983: CALL_OW 69
5987: PUSH
5988: FOR_IN
5989: IFFALSE 6031
// if not IsInArea ( j , conv_end ) then
5991: LD_VAR 0 3
5995: PPUSH
5996: LD_INT 9
5998: PPUSH
5999: CALL_OW 308
6003: NOT
6004: IFFALSE 6020
// ComMoveToArea ( j , conv_end ) else
6006: LD_VAR 0 3
6010: PPUSH
6011: LD_INT 9
6013: PPUSH
6014: CALL_OW 113
6018: GO 6029
// RemoveUnit ( j ) ;
6020: LD_VAR 0 3
6024: PPUSH
6025: CALL_OW 64
6029: GO 5988
6031: POP
6032: POP
// end ;
6033: GO 5820
// end ; end_of_file
6035: LD_VAR 0 1
6039: RET
// export function PrepareArabian ; begin
6040: LD_INT 0
6042: PPUSH
// RobertFarmer ;
6043: CALL 6064 0 0
// PrepareHovercrafts ;
6047: CALL 6934 0 0
// ar_attacks := true ;
6051: LD_ADDR_EXP 10
6055: PUSH
6056: LD_INT 1
6058: ST_TO_ADDR
// end ;
6059: LD_VAR 0 1
6063: RET
// export Farmer ; export function RobertFarmer ; begin
6064: LD_INT 0
6066: PPUSH
// uc_side := 2 ;
6067: LD_ADDR_OWVAR 20
6071: PUSH
6072: LD_INT 2
6074: ST_TO_ADDR
// uc_nation := 2 ;
6075: LD_ADDR_OWVAR 21
6079: PUSH
6080: LD_INT 2
6082: ST_TO_ADDR
// Farmer := NewCharacter ( Farmer ) ;
6083: LD_ADDR_EXP 24
6087: PUSH
6088: LD_STRING Farmer
6090: PPUSH
6091: CALL_OW 25
6095: ST_TO_ADDR
// SayRadio ( Farmer , DPM_F1 ) ;
6096: LD_EXP 24
6100: PPUSH
6101: LD_STRING DPM_F1
6103: PPUSH
6104: CALL_OW 94
// end ;
6108: LD_VAR 0 1
6112: RET
// export function PrepareAttack ( type ) ; var i , un , veh , skill ; begin
6113: LD_INT 0
6115: PPUSH
6116: PPUSH
6117: PPUSH
6118: PPUSH
6119: PPUSH
// uc_side := 2 ;
6120: LD_ADDR_OWVAR 20
6124: PUSH
6125: LD_INT 2
6127: ST_TO_ADDR
// uc_nation := 2 ;
6128: LD_ADDR_OWVAR 21
6132: PUSH
6133: LD_INT 2
6135: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
6136: LD_ADDR_VAR 0 6
6140: PUSH
6141: LD_INT 4
6143: PUSH
6144: LD_INT 5
6146: PUSH
6147: LD_INT 6
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: LD_OWVAR 67
6159: ARRAY
6160: ST_TO_ADDR
// Randomize ;
6161: CALL_OW 10
// case type of 1 :
6165: LD_VAR 0 1
6169: PUSH
6170: LD_INT 1
6172: DOUBLE
6173: EQUAL
6174: IFTRUE 6178
6176: GO 6300
6178: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6179: LD_ADDR_VAR 0 3
6183: PUSH
6184: DOUBLE
6185: LD_INT 1
6187: DEC
6188: ST_TO_ADDR
6189: LD_INT 4
6191: PUSH
6192: LD_INT 5
6194: PUSH
6195: LD_INT 6
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: LIST
6202: PUSH
6203: LD_OWVAR 67
6207: ARRAY
6208: PUSH
6209: FOR_TO
6210: IFFALSE 6296
// begin PrepareHuman ( false , [ class_soldier , class_soldier , class_mortar ] [ Rand ( 1 , 3 ) ] , skill ) ;
6212: LD_INT 0
6214: PPUSH
6215: LD_INT 1
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 8
6223: PUSH
6224: EMPTY
6225: LIST
6226: LIST
6227: LIST
6228: PUSH
6229: LD_INT 1
6231: PPUSH
6232: LD_INT 3
6234: PPUSH
6235: CALL_OW 12
6239: ARRAY
6240: PPUSH
6241: LD_VAR 0 6
6245: PPUSH
6246: CALL_OW 380
// un := CreateHuman ;
6250: LD_ADDR_VAR 0 4
6254: PUSH
6255: CALL_OW 44
6259: ST_TO_ADDR
// PlaceUnitArea ( un , ar3 , false ) ;
6260: LD_VAR 0 4
6264: PPUSH
6265: LD_INT 18
6267: PPUSH
6268: LD_INT 0
6270: PPUSH
6271: CALL_OW 49
// ComMoveToArea ( un , spot3 ) ;
6275: LD_VAR 0 4
6279: PPUSH
6280: LD_INT 20
6282: PPUSH
6283: CALL_OW 113
// Wait ( 0 0$01 ) ;
6287: LD_INT 35
6289: PPUSH
6290: CALL_OW 67
// end ;
6294: GO 6209
6296: POP
6297: POP
// end ; 2 :
6298: GO 6929
6300: LD_INT 2
6302: DOUBLE
6303: EQUAL
6304: IFTRUE 6308
6306: GO 6571
6308: POP
// begin for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
6309: LD_ADDR_VAR 0 3
6313: PUSH
6314: DOUBLE
6315: LD_INT 1
6317: DEC
6318: ST_TO_ADDR
6319: LD_INT 4
6321: PUSH
6322: LD_INT 5
6324: PUSH
6325: LD_INT 5
6327: PUSH
6328: EMPTY
6329: LIST
6330: LIST
6331: LIST
6332: PUSH
6333: LD_OWVAR 67
6337: ARRAY
6338: PUSH
6339: FOR_TO
6340: IFFALSE 6403
// begin PrepareHuman ( false , class_soldier , skill ) ;
6342: LD_INT 0
6344: PPUSH
6345: LD_INT 1
6347: PPUSH
6348: LD_VAR 0 6
6352: PPUSH
6353: CALL_OW 380
// un := CreateHuman ;
6357: LD_ADDR_VAR 0 4
6361: PUSH
6362: CALL_OW 44
6366: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6367: LD_VAR 0 4
6371: PPUSH
6372: LD_INT 17
6374: PPUSH
6375: LD_INT 0
6377: PPUSH
6378: CALL_OW 49
// ComMoveToArea ( un , spot2 ) ;
6382: LD_VAR 0 4
6386: PPUSH
6387: LD_INT 19
6389: PPUSH
6390: CALL_OW 113
// Wait ( 0 0$01 ) ;
6394: LD_INT 35
6396: PPUSH
6397: CALL_OW 67
// end ;
6401: GO 6339
6403: POP
6404: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6405: LD_ADDR_VAR 0 3
6409: PUSH
6410: DOUBLE
6411: LD_INT 1
6413: DEC
6414: ST_TO_ADDR
6415: LD_INT 2
6417: PUSH
6418: LD_INT 3
6420: PUSH
6421: LD_INT 4
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: PUSH
6429: LD_OWVAR 67
6433: ARRAY
6434: PUSH
6435: FOR_TO
6436: IFFALSE 6567
// begin vc_chassis := ar_medium_trike ;
6438: LD_ADDR_OWVAR 37
6442: PUSH
6443: LD_INT 13
6445: ST_TO_ADDR
// vc_engine := engine_combustion ;
6446: LD_ADDR_OWVAR 39
6450: PUSH
6451: LD_INT 1
6453: ST_TO_ADDR
// vc_control := control_manual ;
6454: LD_ADDR_OWVAR 38
6458: PUSH
6459: LD_INT 1
6461: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_light_gun ] [ Rand ( 1 , 2 ) ] ;
6462: LD_ADDR_OWVAR 40
6466: PUSH
6467: LD_INT 24
6469: PUSH
6470: LD_INT 23
6472: PUSH
6473: EMPTY
6474: LIST
6475: LIST
6476: PUSH
6477: LD_INT 1
6479: PPUSH
6480: LD_INT 2
6482: PPUSH
6483: CALL_OW 12
6487: ARRAY
6488: ST_TO_ADDR
// veh := CreateVehicle ;
6489: LD_ADDR_VAR 0 5
6493: PUSH
6494: CALL_OW 45
6498: ST_TO_ADDR
// PlaceUnitArea ( veh , ar2 , false ) ;
6499: LD_VAR 0 5
6503: PPUSH
6504: LD_INT 17
6506: PPUSH
6507: LD_INT 0
6509: PPUSH
6510: CALL_OW 49
// PrepareHuman ( false , 1 , skill ) ;
6514: LD_INT 0
6516: PPUSH
6517: LD_INT 1
6519: PPUSH
6520: LD_VAR 0 6
6524: PPUSH
6525: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6529: CALL_OW 44
6533: PPUSH
6534: LD_VAR 0 5
6538: PPUSH
6539: CALL_OW 52
// ComMoveXY ( veh , 89 , 40 ) ;
6543: LD_VAR 0 5
6547: PPUSH
6548: LD_INT 89
6550: PPUSH
6551: LD_INT 40
6553: PPUSH
6554: CALL_OW 111
// Wait ( 0 0$02 ) ;
6558: LD_INT 70
6560: PPUSH
6561: CALL_OW 67
// end ;
6565: GO 6435
6567: POP
6568: POP
// end ; 3 :
6569: GO 6929
6571: LD_INT 3
6573: DOUBLE
6574: EQUAL
6575: IFTRUE 6579
6577: GO 6928
6579: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( tick div 15 15$00 ) do
6580: LD_ADDR_VAR 0 3
6584: PUSH
6585: DOUBLE
6586: LD_INT 1
6588: DEC
6589: ST_TO_ADDR
6590: LD_INT 4
6592: PUSH
6593: LD_INT 5
6595: PUSH
6596: LD_INT 6
6598: PUSH
6599: EMPTY
6600: LIST
6601: LIST
6602: LIST
6603: PUSH
6604: LD_OWVAR 67
6608: ARRAY
6609: PUSH
6610: LD_OWVAR 1
6614: PUSH
6615: LD_INT 31500
6617: DIV
6618: PLUS
6619: PUSH
6620: FOR_TO
6621: IFFALSE 6729
// begin PrepareHuman ( false , [ class_soldier , class_mortar ] [ Rand ( 1 , 2 ) ] , skill ) ;
6623: LD_INT 0
6625: PPUSH
6626: LD_INT 1
6628: PUSH
6629: LD_INT 8
6631: PUSH
6632: EMPTY
6633: LIST
6634: LIST
6635: PUSH
6636: LD_INT 1
6638: PPUSH
6639: LD_INT 2
6641: PPUSH
6642: CALL_OW 12
6646: ARRAY
6647: PPUSH
6648: LD_VAR 0 6
6652: PPUSH
6653: CALL_OW 380
// un := CreateHuman ;
6657: LD_ADDR_VAR 0 4
6661: PUSH
6662: CALL_OW 44
6666: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6667: LD_VAR 0 4
6671: PPUSH
6672: LD_INT 17
6674: PPUSH
6675: LD_INT 0
6677: PPUSH
6678: CALL_OW 49
// ar_force := Insert ( ar_force , 1 , un ) ;
6682: LD_ADDR_EXP 11
6686: PUSH
6687: LD_EXP 11
6691: PPUSH
6692: LD_INT 1
6694: PPUSH
6695: LD_VAR 0 4
6699: PPUSH
6700: CALL_OW 2
6704: ST_TO_ADDR
// ComMoveXY ( un , 17 , 9 ) ;
6705: LD_VAR 0 4
6709: PPUSH
6710: LD_INT 17
6712: PPUSH
6713: LD_INT 9
6715: PPUSH
6716: CALL_OW 111
// Wait ( 0 0$01 ) ;
6720: LD_INT 35
6722: PPUSH
6723: CALL_OW 67
// end ;
6727: GO 6620
6729: POP
6730: POP
// for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
6731: LD_ADDR_VAR 0 3
6735: PUSH
6736: DOUBLE
6737: LD_INT 1
6739: DEC
6740: ST_TO_ADDR
6741: LD_INT 5
6743: PUSH
6744: LD_INT 6
6746: PUSH
6747: LD_INT 7
6749: PUSH
6750: EMPTY
6751: LIST
6752: LIST
6753: LIST
6754: PUSH
6755: LD_OWVAR 67
6759: ARRAY
6760: PUSH
6761: FOR_TO
6762: IFFALSE 6924
// begin vc_chassis := ar_half_tracked ;
6764: LD_ADDR_OWVAR 37
6768: PUSH
6769: LD_INT 14
6771: ST_TO_ADDR
// vc_engine := engine_combustion ;
6772: LD_ADDR_OWVAR 39
6776: PUSH
6777: LD_INT 1
6779: ST_TO_ADDR
// vc_control := control_manual ;
6780: LD_ADDR_OWVAR 38
6784: PUSH
6785: LD_INT 1
6787: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ;
6788: LD_ADDR_OWVAR 40
6792: PUSH
6793: LD_INT 25
6795: PUSH
6796: LD_INT 27
6798: PUSH
6799: LD_INT 28
6801: PUSH
6802: LD_INT 26
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: LIST
6809: LIST
6810: PUSH
6811: LD_INT 1
6813: PPUSH
6814: LD_INT 4
6816: PPUSH
6817: CALL_OW 12
6821: ARRAY
6822: ST_TO_ADDR
// veh := CreateVehicle ;
6823: LD_ADDR_VAR 0 5
6827: PUSH
6828: CALL_OW 45
6832: ST_TO_ADDR
// PlaceUnitArea ( veh , ar1 , false ) ;
6833: LD_VAR 0 5
6837: PPUSH
6838: LD_INT 16
6840: PPUSH
6841: LD_INT 0
6843: PPUSH
6844: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
6848: LD_INT 0
6850: PPUSH
6851: LD_INT 3
6853: PPUSH
6854: LD_VAR 0 6
6858: PPUSH
6859: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6863: CALL_OW 44
6867: PPUSH
6868: LD_VAR 0 5
6872: PPUSH
6873: CALL_OW 52
// ar_force := Insert ( ar_force , 1 , veh ) ;
6877: LD_ADDR_EXP 11
6881: PUSH
6882: LD_EXP 11
6886: PPUSH
6887: LD_INT 1
6889: PPUSH
6890: LD_VAR 0 5
6894: PPUSH
6895: CALL_OW 2
6899: ST_TO_ADDR
// ComMoveXY ( veh , 125 , 31 ) ;
6900: LD_VAR 0 5
6904: PPUSH
6905: LD_INT 125
6907: PPUSH
6908: LD_INT 31
6910: PPUSH
6911: CALL_OW 111
// Wait ( 0 0$02 ) ;
6915: LD_INT 70
6917: PPUSH
6918: CALL_OW 67
// end ;
6922: GO 6761
6924: POP
6925: POP
// end ; end ;
6926: GO 6929
6928: POP
// end ;
6929: LD_VAR 0 2
6933: RET
// export function PrepareHovercrafts ; var i , un , areas , skill ; begin
6934: LD_INT 0
6936: PPUSH
6937: PPUSH
6938: PPUSH
6939: PPUSH
6940: PPUSH
// areas := [ river1 , river2 ] ;
6941: LD_ADDR_VAR 0 4
6945: PUSH
6946: LD_INT 14
6948: PUSH
6949: LD_INT 15
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
6956: LD_ADDR_VAR 0 5
6960: PUSH
6961: LD_INT 5
6963: PUSH
6964: LD_INT 6
6966: PUSH
6967: LD_INT 7
6969: PUSH
6970: EMPTY
6971: LIST
6972: LIST
6973: LIST
6974: PUSH
6975: LD_OWVAR 67
6979: ARRAY
6980: ST_TO_ADDR
// uc_side := 2 ;
6981: LD_ADDR_OWVAR 20
6985: PUSH
6986: LD_INT 2
6988: ST_TO_ADDR
// uc_nation := 2 ;
6989: LD_ADDR_OWVAR 21
6993: PUSH
6994: LD_INT 2
6996: ST_TO_ADDR
// hc_name :=  ;
6997: LD_ADDR_OWVAR 26
7001: PUSH
7002: LD_STRING 
7004: ST_TO_ADDR
// hc_gallery :=  ;
7005: LD_ADDR_OWVAR 33
7009: PUSH
7010: LD_STRING 
7012: ST_TO_ADDR
// for i = 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
7013: LD_ADDR_VAR 0 2
7017: PUSH
7018: DOUBLE
7019: LD_INT 1
7021: DEC
7022: ST_TO_ADDR
7023: LD_INT 1
7025: PUSH
7026: LD_INT 2
7028: PUSH
7029: LD_INT 2
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: LIST
7036: PUSH
7037: LD_OWVAR 67
7041: ARRAY
7042: PUSH
7043: FOR_TO
7044: IFFALSE 7182
// begin vc_chassis := ar_hovercraft ;
7046: LD_ADDR_OWVAR 37
7050: PUSH
7051: LD_INT 11
7053: ST_TO_ADDR
// vc_engine := engine_solar ;
7054: LD_ADDR_OWVAR 39
7058: PUSH
7059: LD_INT 2
7061: ST_TO_ADDR
// vc_control := control_manual ;
7062: LD_ADDR_OWVAR 38
7066: PUSH
7067: LD_INT 1
7069: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
7070: LD_ADDR_OWVAR 40
7074: PUSH
7075: LD_INT 24
7077: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7078: LD_ADDR_OWVAR 41
7082: PUSH
7083: LD_INT 100
7085: ST_TO_ADDR
// un := CreateVehicle ;
7086: LD_ADDR_VAR 0 3
7090: PUSH
7091: CALL_OW 45
7095: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ i ] , false ) ;
7096: LD_VAR 0 3
7100: PPUSH
7101: LD_VAR 0 4
7105: PUSH
7106: LD_VAR 0 2
7110: ARRAY
7111: PPUSH
7112: LD_INT 0
7114: PPUSH
7115: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7119: LD_INT 0
7121: PPUSH
7122: LD_INT 3
7124: PPUSH
7125: LD_VAR 0 5
7129: PPUSH
7130: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
7134: CALL_OW 44
7138: PPUSH
7139: LD_VAR 0 3
7143: PPUSH
7144: CALL_OW 52
// riv := Insert ( riv , 1 , [ un , i ] ) ;
7148: LD_ADDR_EXP 9
7152: PUSH
7153: LD_EXP 9
7157: PPUSH
7158: LD_INT 1
7160: PPUSH
7161: LD_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: PPUSH
7175: CALL_OW 2
7179: ST_TO_ADDR
// end ;
7180: GO 7043
7182: POP
7183: POP
// end ;
7184: LD_VAR 0 1
7188: RET
// every 0 0$01 trigger riv do var i , c ;
7189: LD_EXP 9
7193: IFFALSE 7512
7195: GO 7197
7197: DISABLE
7198: LD_INT 0
7200: PPUSH
7201: PPUSH
// begin enable ;
7202: ENABLE
// for i = riv downto 1 do
7203: LD_ADDR_VAR 0 1
7207: PUSH
7208: DOUBLE
7209: LD_EXP 9
7213: INC
7214: ST_TO_ADDR
7215: LD_INT 1
7217: PUSH
7218: FOR_DOWNTO
7219: IFFALSE 7510
// begin if not riv [ i ] [ 1 ] then
7221: LD_EXP 9
7225: PUSH
7226: LD_VAR 0 1
7230: ARRAY
7231: PUSH
7232: LD_INT 1
7234: ARRAY
7235: NOT
7236: IFFALSE 7258
// begin riv := Delete ( riv , 1 ) ;
7238: LD_ADDR_EXP 9
7242: PUSH
7243: LD_EXP 9
7247: PPUSH
7248: LD_INT 1
7250: PPUSH
7251: CALL_OW 3
7255: ST_TO_ADDR
// break ;
7256: GO 7510
// end ; if not HasTask ( riv [ i ] [ 1 ] ) then
7258: LD_EXP 9
7262: PUSH
7263: LD_VAR 0 1
7267: ARRAY
7268: PUSH
7269: LD_INT 1
7271: ARRAY
7272: PPUSH
7273: CALL_OW 314
7277: NOT
7278: IFFALSE 7346
// begin if riv [ i ] [ 2 ] = 1 then
7280: LD_EXP 9
7284: PUSH
7285: LD_VAR 0 1
7289: ARRAY
7290: PUSH
7291: LD_INT 2
7293: ARRAY
7294: PUSH
7295: LD_INT 1
7297: EQUAL
7298: IFFALSE 7310
// c := 2 else
7300: LD_ADDR_VAR 0 2
7304: PUSH
7305: LD_INT 2
7307: ST_TO_ADDR
7308: GO 7318
// c := 1 ;
7310: LD_ADDR_VAR 0 2
7314: PUSH
7315: LD_INT 1
7317: ST_TO_ADDR
// riv := Replace2 ( riv , i , 2 , c ) ;
7318: LD_ADDR_EXP 9
7322: PUSH
7323: LD_EXP 9
7327: PPUSH
7328: LD_VAR 0 1
7332: PPUSH
7333: LD_INT 2
7335: PPUSH
7336: LD_VAR 0 2
7340: PPUSH
7341: CALL 9882 0 4
7345: ST_TO_ADDR
// end ; if not IsInArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) then
7346: LD_EXP 9
7350: PUSH
7351: LD_VAR 0 1
7355: ARRAY
7356: PUSH
7357: LD_INT 1
7359: ARRAY
7360: PPUSH
7361: LD_INT 14
7363: PUSH
7364: LD_INT 15
7366: PUSH
7367: EMPTY
7368: LIST
7369: LIST
7370: PUSH
7371: LD_EXP 9
7375: PUSH
7376: LD_VAR 0 1
7380: ARRAY
7381: PUSH
7382: LD_INT 2
7384: ARRAY
7385: ARRAY
7386: PPUSH
7387: CALL_OW 308
7391: NOT
7392: IFFALSE 7508
// begin if GetFuel ( riv [ i ] [ 1 ] ) < 50 then
7394: LD_EXP 9
7398: PUSH
7399: LD_VAR 0 1
7403: ARRAY
7404: PUSH
7405: LD_INT 1
7407: ARRAY
7408: PPUSH
7409: CALL_OW 261
7413: PUSH
7414: LD_INT 50
7416: LESS
7417: IFFALSE 7441
// SetFuel ( riv [ i ] [ 1 ] , 67 ) ;
7419: LD_EXP 9
7423: PUSH
7424: LD_VAR 0 1
7428: ARRAY
7429: PUSH
7430: LD_INT 1
7432: ARRAY
7433: PPUSH
7434: LD_INT 67
7436: PPUSH
7437: CALL_OW 240
// ComMoveToArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) ;
7441: LD_EXP 9
7445: PUSH
7446: LD_VAR 0 1
7450: ARRAY
7451: PUSH
7452: LD_INT 1
7454: ARRAY
7455: PPUSH
7456: LD_INT 14
7458: PUSH
7459: LD_INT 15
7461: PUSH
7462: EMPTY
7463: LIST
7464: LIST
7465: PUSH
7466: LD_EXP 9
7470: PUSH
7471: LD_VAR 0 1
7475: ARRAY
7476: PUSH
7477: LD_INT 2
7479: ARRAY
7480: ARRAY
7481: PPUSH
7482: CALL_OW 113
// AddComWait ( riv [ i ] [ 1 ] , 0 0$10 ) ;
7486: LD_EXP 9
7490: PUSH
7491: LD_VAR 0 1
7495: ARRAY
7496: PUSH
7497: LD_INT 1
7499: ARRAY
7500: PPUSH
7501: LD_INT 350
7503: PPUSH
7504: CALL_OW 202
// end ; end ;
7508: GO 7218
7510: POP
7511: POP
// end ;
7512: PPOPN 2
7514: END
// every 10 10$00 trigger convoy_start do var i , un ;
7515: LD_EXP 7
7519: IFFALSE 7640
7521: GO 7523
7523: DISABLE
7524: LD_INT 0
7526: PPUSH
7527: PPUSH
// begin enable ;
7528: ENABLE
// for i = 1 to 2 do
7529: LD_ADDR_VAR 0 1
7533: PUSH
7534: DOUBLE
7535: LD_INT 1
7537: DEC
7538: ST_TO_ADDR
7539: LD_INT 2
7541: PUSH
7542: FOR_TO
7543: IFFALSE 7638
// begin uc_side := 2 ;
7545: LD_ADDR_OWVAR 20
7549: PUSH
7550: LD_INT 2
7552: ST_TO_ADDR
// uc_nation := 2 ;
7553: LD_ADDR_OWVAR 21
7557: PUSH
7558: LD_INT 2
7560: ST_TO_ADDR
// PrepareHuman ( false , 1 , 4 ) ;
7561: LD_INT 0
7563: PPUSH
7564: LD_INT 1
7566: PPUSH
7567: LD_INT 4
7569: PPUSH
7570: CALL_OW 380
// un := CreateHuman ;
7574: LD_ADDR_VAR 0 2
7578: PUSH
7579: CALL_OW 44
7583: ST_TO_ADDR
// PlaceUnitXY ( un , 10 , 2 , false ) ;
7584: LD_VAR 0 2
7588: PPUSH
7589: LD_INT 10
7591: PPUSH
7592: LD_INT 2
7594: PPUSH
7595: LD_INT 0
7597: PPUSH
7598: CALL_OW 48
// ComMoveXY ( un , 24 , 36 ) ;
7602: LD_VAR 0 2
7606: PPUSH
7607: LD_INT 24
7609: PPUSH
7610: LD_INT 36
7612: PPUSH
7613: CALL_OW 111
// AddComMoveToArea ( un , conv_end ) ;
7617: LD_VAR 0 2
7621: PPUSH
7622: LD_INT 9
7624: PPUSH
7625: CALL_OW 173
// Wait ( 0 0$02 ) ;
7629: LD_INT 70
7631: PPUSH
7632: CALL_OW 67
// end ;
7636: GO 7542
7638: POP
7639: POP
// end ;
7640: PPOPN 2
7642: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , rest ;
7643: LD_INT 22
7645: PUSH
7646: LD_INT 2
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PPUSH
7653: CALL_OW 69
7657: IFFALSE 7968
7659: GO 7661
7661: DISABLE
7662: LD_INT 0
7664: PPUSH
7665: PPUSH
// begin enable ;
7666: ENABLE
// rest := FilterAllUnits ( [ f_side , 2 ] ) diff ar_force ;
7667: LD_ADDR_VAR 0 2
7671: PUSH
7672: LD_INT 22
7674: PUSH
7675: LD_INT 2
7677: PUSH
7678: EMPTY
7679: LIST
7680: LIST
7681: PPUSH
7682: CALL_OW 69
7686: PUSH
7687: LD_EXP 11
7691: DIFF
7692: ST_TO_ADDR
// if rest then
7693: LD_VAR 0 2
7697: IFFALSE 7769
// for i in rest do
7699: LD_ADDR_VAR 0 1
7703: PUSH
7704: LD_VAR 0 2
7708: PUSH
7709: FOR_IN
7710: IFFALSE 7767
// if GetClass ( i ) = 3 then
7712: LD_VAR 0 1
7716: PPUSH
7717: CALL_OW 257
7721: PUSH
7722: LD_INT 3
7724: EQUAL
7725: IFFALSE 7765
// begin if not IsInArea ( i , ar2 ) then
7727: LD_VAR 0 1
7731: PPUSH
7732: LD_INT 17
7734: PPUSH
7735: CALL_OW 308
7739: NOT
7740: IFFALSE 7756
// ComMoveToArea ( i , ar2 ) else
7742: LD_VAR 0 1
7746: PPUSH
7747: LD_INT 17
7749: PPUSH
7750: CALL_OW 113
7754: GO 7765
// RemoveUnit ( i ) ;
7756: LD_VAR 0 1
7760: PPUSH
7761: CALL_OW 64
// end ;
7765: GO 7709
7767: POP
7768: POP
// if ar_force then
7769: LD_EXP 11
7773: IFFALSE 7968
// for i in ar_force do
7775: LD_ADDR_VAR 0 1
7779: PUSH
7780: LD_EXP 11
7784: PUSH
7785: FOR_IN
7786: IFFALSE 7966
// begin if GetClass ( i ) = class_soldier then
7788: LD_VAR 0 1
7792: PPUSH
7793: CALL_OW 257
7797: PUSH
7798: LD_INT 1
7800: EQUAL
7801: IFFALSE 7893
// if FindTarget ( i ) in FilterAllUnits ( [ f_type , unit_building ] ) then
7803: LD_VAR 0 1
7807: PPUSH
7808: CALL 10190 0 1
7812: PUSH
7813: LD_INT 21
7815: PUSH
7816: LD_INT 3
7818: PUSH
7819: EMPTY
7820: LIST
7821: LIST
7822: PPUSH
7823: CALL_OW 69
7827: IN
7828: IFFALSE 7874
// ComPlaceDelayedCharge ( i , GetX ( FindTarget ( i ) ) , GetY ( FindTarget ( i ) ) , 0 ) else
7830: LD_VAR 0 1
7834: PPUSH
7835: LD_VAR 0 1
7839: PPUSH
7840: CALL 10190 0 1
7844: PPUSH
7845: CALL_OW 250
7849: PPUSH
7850: LD_VAR 0 1
7854: PPUSH
7855: CALL 10190 0 1
7859: PPUSH
7860: CALL_OW 251
7864: PPUSH
7865: LD_INT 0
7867: PPUSH
7868: CALL_OW 132
7872: GO 7893
// ComAttackUnit ( i , FindTarget ( i ) ) ;
7874: LD_VAR 0 1
7878: PPUSH
7879: LD_VAR 0 1
7883: PPUSH
7884: CALL 10190 0 1
7888: PPUSH
7889: CALL_OW 115
// if not GetClass ( i ) = 1 then
7893: LD_VAR 0 1
7897: PPUSH
7898: CALL_OW 257
7902: PUSH
7903: LD_INT 1
7905: EQUAL
7906: NOT
7907: IFFALSE 7928
// ComAttackUnit ( i , FindTarget ( i ) ) ;
7909: LD_VAR 0 1
7913: PPUSH
7914: LD_VAR 0 1
7918: PPUSH
7919: CALL 10190 0 1
7923: PPUSH
7924: CALL_OW 115
// if GetDistUnitXY ( i , 65 , 118 ) < 40 then
7928: LD_VAR 0 1
7932: PPUSH
7933: LD_INT 65
7935: PPUSH
7936: LD_INT 118
7938: PPUSH
7939: CALL_OW 297
7943: PUSH
7944: LD_INT 40
7946: LESS
7947: IFFALSE 7964
// ComMoveXY ( i , 65 , 118 ) ;
7949: LD_VAR 0 1
7953: PPUSH
7954: LD_INT 65
7956: PPUSH
7957: LD_INT 118
7959: PPUSH
7960: CALL_OW 111
// end ;
7964: GO 7785
7966: POP
7967: POP
// end ;
7968: PPOPN 2
7970: END
// every 0 0$01 trigger FilterUnitsInArea ( conv_end , [ f_side , 2 ] ) do
7971: LD_INT 9
7973: PPUSH
7974: LD_INT 22
7976: PUSH
7977: LD_INT 2
7979: PUSH
7980: EMPTY
7981: LIST
7982: LIST
7983: PPUSH
7984: CALL_OW 70
7988: IFFALSE 8001
7990: GO 7992
7992: DISABLE
// medal2 := false ; end_of_file
7993: LD_ADDR_EXP 4
7997: PUSH
7998: LD_INT 0
8000: ST_TO_ADDR
8001: END
// export function Action ; begin
8002: LD_INT 0
8004: PPUSH
// case Query ( textdiff ) of 1 :
8005: LD_STRING textdiff
8007: PPUSH
8008: CALL_OW 97
8012: PUSH
8013: LD_INT 1
8015: DOUBLE
8016: EQUAL
8017: IFTRUE 8021
8019: GO 8032
8021: POP
// Difficulty := 1 ; 2 :
8022: LD_ADDR_OWVAR 67
8026: PUSH
8027: LD_INT 1
8029: ST_TO_ADDR
8030: GO 8071
8032: LD_INT 2
8034: DOUBLE
8035: EQUAL
8036: IFTRUE 8040
8038: GO 8051
8040: POP
// Difficulty := 2 ; 3 :
8041: LD_ADDR_OWVAR 67
8045: PUSH
8046: LD_INT 2
8048: ST_TO_ADDR
8049: GO 8071
8051: LD_INT 3
8053: DOUBLE
8054: EQUAL
8055: IFTRUE 8059
8057: GO 8070
8059: POP
// Difficulty := 3 ; end ;
8060: LD_ADDR_OWVAR 67
8064: PUSH
8065: LD_INT 3
8067: ST_TO_ADDR
8068: GO 8071
8070: POP
// case Query ( info ) of 1 :
8071: LD_STRING info
8073: PPUSH
8074: CALL_OW 97
8078: PUSH
8079: LD_INT 1
8081: DOUBLE
8082: EQUAL
8083: IFTRUE 8087
8085: GO 8090
8087: POP
// ; end ;
8088: GO 8091
8090: POP
// SaveForQuickRestart ;
8091: CALL_OW 22
// ChangeMissionObjectives ( PM_1 ) ;
8095: LD_STRING PM_1
8097: PPUSH
8098: CALL_OW 337
// end ;
8102: LD_VAR 0 1
8106: RET
// every 0 0$01 trigger GetSide ( us_depot ) = 3 do
8107: LD_INT 50
8109: PPUSH
8110: CALL_OW 255
8114: PUSH
8115: LD_INT 3
8117: EQUAL
8118: IFFALSE 8399
8120: GO 8122
8122: DISABLE
// begin Say ( Stolypin , DPM_S1 ) ;
8123: LD_EXP 15
8127: PPUSH
8128: LD_STRING DPM_S1
8130: PPUSH
8131: CALL_OW 88
// SayRadio ( Popov , DPM_P1 ) ;
8135: LD_EXP 16
8139: PPUSH
8140: LD_STRING DPM_P1
8142: PPUSH
8143: CALL_OW 94
// Say ( Stolypin , DPM_S2 ) ;
8147: LD_EXP 15
8151: PPUSH
8152: LD_STRING DPM_S2
8154: PPUSH
8155: CALL_OW 88
// SaveForQuickRestart ;
8159: CALL_OW 22
// ChangeMissionObjectives ( PM_2 ) ;
8163: LD_STRING PM_2
8165: PPUSH
8166: CALL_OW 337
// Wait ( 2 2$30 ) ;
8170: LD_INT 5250
8172: PPUSH
8173: CALL_OW 67
// CenterOnXY ( 117 , 4 ) ;
8177: LD_INT 117
8179: PPUSH
8180: LD_INT 4
8182: PPUSH
8183: CALL_OW 84
// Convoy ( 1 ) ;
8187: LD_INT 1
8189: PPUSH
8190: CALL 876 0 1
// Wait ( 0 0$30 ) ;
8194: LD_INT 1050
8196: PPUSH
8197: CALL_OW 67
// Convoy ( 2 ) ;
8201: LD_INT 2
8203: PPUSH
8204: CALL 876 0 1
// Wait ( 1 1$30 ) ;
8208: LD_INT 3150
8210: PPUSH
8211: CALL_OW 67
// Convoy ( 3 ) ;
8215: LD_INT 3
8217: PPUSH
8218: CALL 876 0 1
// Wait ( 5 5$00 ) ;
8222: LD_INT 10500
8224: PPUSH
8225: CALL_OW 67
// convoy_start := true ;
8229: LD_ADDR_EXP 7
8233: PUSH
8234: LD_INT 1
8236: ST_TO_ADDR
// PrepareArabian ;
8237: CALL 6040 0 0
// PrepareAttack ( 1 ) ;
8241: LD_INT 1
8243: PPUSH
8244: CALL 6113 0 1
// while ( convoy_start ) do
8248: LD_EXP 7
8252: IFFALSE 8399
// begin Wait ( Rand ( 2 2$00 , 4 4$00 ) ) ;
8254: LD_INT 4200
8256: PPUSH
8257: LD_INT 8400
8259: PPUSH
8260: CALL_OW 12
8264: PPUSH
8265: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) < 20 then
8269: LD_INT 22
8271: PUSH
8272: LD_INT 2
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PPUSH
8279: CALL_OW 69
8283: PUSH
8284: LD_INT 20
8286: LESS
8287: IFFALSE 8304
// PrepareAttack ( Rand ( 1 , 2 ) ) ;
8289: LD_INT 1
8291: PPUSH
8292: LD_INT 2
8294: PPUSH
8295: CALL_OW 12
8299: PPUSH
8300: CALL 6113 0 1
// Convoy ( Rand ( 1 , 5 ) ) ;
8304: LD_INT 1
8306: PPUSH
8307: LD_INT 5
8309: PPUSH
8310: CALL_OW 12
8314: PPUSH
8315: CALL 876 0 1
// conv_counter := conv_counter + 1 ;
8319: LD_ADDR_EXP 13
8323: PUSH
8324: LD_EXP 13
8328: PUSH
8329: LD_INT 1
8331: PLUS
8332: ST_TO_ADDR
// if conv_counter mod [ 5 , 4 , 3 ] [ Difficulty ] = 0 then
8333: LD_EXP 13
8337: PUSH
8338: LD_INT 5
8340: PUSH
8341: LD_INT 4
8343: PUSH
8344: LD_INT 3
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: LIST
8351: PUSH
8352: LD_OWVAR 67
8356: ARRAY
8357: MOD
8358: PUSH
8359: LD_INT 0
8361: EQUAL
8362: IFFALSE 8397
// begin Wait ( 1 1$20 ) ;
8364: LD_INT 2800
8366: PPUSH
8367: CALL_OW 67
// SayRadio ( Farmer , DPM_F2 ) ;
8371: LD_EXP 24
8375: PPUSH
8376: LD_STRING DPM_F2
8378: PPUSH
8379: CALL_OW 94
// PrepareAttack ( 3 ) ;
8383: LD_INT 3
8385: PPUSH
8386: CALL 6113 0 1
// Wait ( 4 4$00 ) ;
8390: LD_INT 8400
8392: PPUSH
8393: CALL_OW 67
// end ; end ;
8397: GO 8248
// end ;
8399: END
// every 1 1$30 trigger conv_counter mod 4 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8400: LD_EXP 13
8404: PUSH
8405: LD_INT 4
8407: MOD
8408: PUSH
8409: LD_INT 0
8411: EQUAL
8412: PUSH
8413: LD_INT 22
8415: PUSH
8416: LD_INT 2
8418: PUSH
8419: EMPTY
8420: LIST
8421: LIST
8422: PPUSH
8423: CALL_OW 69
8427: PUSH
8428: LD_INT 0
8430: EQUAL
8431: AND
8432: IFFALSE 8449
8434: GO 8436
8436: DISABLE
// SayRadio ( Farmer , DPM_F3 ) ;
8437: LD_EXP 24
8441: PPUSH
8442: LD_STRING DPM_F3
8444: PPUSH
8445: CALL_OW 94
8449: END
// every 1 1$30 trigger conv_counter mod 8 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8450: LD_EXP 13
8454: PUSH
8455: LD_INT 8
8457: MOD
8458: PUSH
8459: LD_INT 0
8461: EQUAL
8462: PUSH
8463: LD_INT 22
8465: PUSH
8466: LD_INT 2
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PPUSH
8473: CALL_OW 69
8477: PUSH
8478: LD_INT 0
8480: EQUAL
8481: AND
8482: IFFALSE 8499
8484: GO 8486
8486: DISABLE
// SayRadio ( Farmer , DPM_F4 ) ;
8487: LD_EXP 24
8491: PPUSH
8492: LD_STRING DPM_F4
8494: PPUSH
8495: CALL_OW 94
8499: END
// every 0 0$10 trigger conv_counter >= 10 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
8500: LD_EXP 13
8504: PUSH
8505: LD_INT 10
8507: GREATEREQUAL
8508: PUSH
8509: LD_INT 22
8511: PUSH
8512: LD_INT 6
8514: PUSH
8515: EMPTY
8516: LIST
8517: LIST
8518: PPUSH
8519: CALL_OW 69
8523: PUSH
8524: LD_INT 0
8526: EQUAL
8527: AND
8528: IFFALSE 8627
8530: GO 8532
8532: DISABLE
// begin SayRadio ( Popov , DPM_PEnd ) ;
8533: LD_EXP 16
8537: PPUSH
8538: LD_STRING DPM_PEnd
8540: PPUSH
8541: CALL_OW 94
// AddMedal ( med1 , medal1 ) ;
8545: LD_STRING med1
8547: PPUSH
8548: LD_EXP 3
8552: PPUSH
8553: CALL_OW 101
// AddMedal ( med2 , medal2 ) ;
8557: LD_STRING med2
8559: PPUSH
8560: LD_EXP 4
8564: PPUSH
8565: CALL_OW 101
// if dest_counter >= [ 15 , 10 , 7 ] [ Difficulty ] then
8569: LD_EXP 8
8573: PUSH
8574: LD_INT 15
8576: PUSH
8577: LD_INT 10
8579: PUSH
8580: LD_INT 7
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: PUSH
8588: LD_OWVAR 67
8592: ARRAY
8593: GREATEREQUAL
8594: IFFALSE 8604
// medal3 := false ;
8596: LD_ADDR_EXP 5
8600: PUSH
8601: LD_INT 0
8603: ST_TO_ADDR
// AddMedal ( med3 , medal3 ) ;
8604: LD_STRING med3
8606: PPUSH
8607: LD_EXP 5
8611: PPUSH
8612: CALL_OW 101
// GiveMedals ( MAIN ) ;
8616: LD_STRING MAIN
8618: PPUSH
8619: CALL_OW 102
// YouWin ;
8623: CALL_OW 103
// end ;
8627: END
// every 4 4$00 trigger convoy_start do var i ;
8628: LD_EXP 7
8632: IFFALSE 8978
8634: GO 8636
8636: DISABLE
8637: LD_INT 0
8639: PPUSH
// begin SayRadio ( Popov , DPM_PHelp ) ;
8640: LD_EXP 16
8644: PPUSH
8645: LD_STRING DPM_PHelp
8647: PPUSH
8648: CALL_OW 94
// Wait ( 0 0$30 ) ;
8652: LD_INT 1050
8654: PPUSH
8655: CALL_OW 67
// Randomize ;
8659: CALL_OW 10
// uc_side := 3 ;
8663: LD_ADDR_OWVAR 20
8667: PUSH
8668: LD_INT 3
8670: ST_TO_ADDR
// uc_nation := 3 ;
8671: LD_ADDR_OWVAR 21
8675: PUSH
8676: LD_INT 3
8678: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ Difficulty ] do
8679: LD_ADDR_VAR 0 1
8683: PUSH
8684: DOUBLE
8685: LD_INT 1
8687: DEC
8688: ST_TO_ADDR
8689: LD_INT 5
8691: PUSH
8692: LD_INT 4
8694: PUSH
8695: LD_INT 3
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: LIST
8702: PUSH
8703: LD_OWVAR 67
8707: ARRAY
8708: PUSH
8709: FOR_TO
8710: IFFALSE 8750
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , 5 ) ;
8712: LD_INT 0
8714: PPUSH
8715: LD_INT 1
8717: PPUSH
8718: LD_INT 3
8720: PPUSH
8721: CALL_OW 12
8725: PPUSH
8726: LD_INT 5
8728: PPUSH
8729: CALL_OW 380
// PlaceUnitArea ( CreateHuman , rus_start , false ) ;
8733: CALL_OW 44
8737: PPUSH
8738: LD_INT 1
8740: PPUSH
8741: LD_INT 0
8743: PPUSH
8744: CALL_OW 49
// end ;
8748: GO 8709
8750: POP
8751: POP
// vc_chassis := ru_heavy_wheeled ;
8752: LD_ADDR_OWVAR 37
8756: PUSH
8757: LD_INT 23
8759: ST_TO_ADDR
// vc_engine := engine_combustion ;
8760: LD_ADDR_OWVAR 39
8764: PUSH
8765: LD_INT 1
8767: ST_TO_ADDR
// vc_control := control_manual ;
8768: LD_ADDR_OWVAR 38
8772: PUSH
8773: LD_INT 1
8775: ST_TO_ADDR
// vc_weapon := 89 ;
8776: LD_ADDR_OWVAR 40
8780: PUSH
8781: LD_INT 89
8783: ST_TO_ADDR
// vc_fuel_battery := 88 ;
8784: LD_ADDR_OWVAR 41
8788: PUSH
8789: LD_INT 88
8791: ST_TO_ADDR
// i := CreateVehicle ;
8792: LD_ADDR_VAR 0 1
8796: PUSH
8797: CALL_OW 45
8801: ST_TO_ADDR
// PlaceUnitXY ( i , 63 , 115 , false ) ;
8802: LD_VAR 0 1
8806: PPUSH
8807: LD_INT 63
8809: PPUSH
8810: LD_INT 115
8812: PPUSH
8813: LD_INT 0
8815: PPUSH
8816: CALL_OW 48
// SetCargo ( i , mat_cans , 200 ) ;
8820: LD_VAR 0 1
8824: PPUSH
8825: LD_INT 1
8827: PPUSH
8828: LD_INT 200
8830: PPUSH
8831: CALL_OW 290
// PrepareHuman ( false , 3 , 5 ) ;
8835: LD_INT 0
8837: PPUSH
8838: LD_INT 3
8840: PPUSH
8841: LD_INT 5
8843: PPUSH
8844: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
8848: CALL_OW 44
8852: PPUSH
8853: LD_VAR 0 1
8857: PPUSH
8858: CALL_OW 52
// DialogueOn ;
8862: CALL_OW 6
// CenterNowOnXY ( 169 , 115 ) ;
8866: LD_INT 169
8868: PPUSH
8869: LD_INT 115
8871: PPUSH
8872: CALL_OW 86
// DWait ( 0 0$01 ) ;
8876: LD_INT 35
8878: PPUSH
8879: CALL_OW 68
// CenterNowOnXY ( 63 , 115 ) ;
8883: LD_INT 63
8885: PPUSH
8886: LD_INT 115
8888: PPUSH
8889: CALL_OW 86
// DWait ( 0 0$01 ) ;
8893: LD_INT 35
8895: PPUSH
8896: CALL_OW 68
// DialogueOff ;
8900: CALL_OW 7
// ComMoveXY ( i , 57 , 53 ) ;
8904: LD_VAR 0 1
8908: PPUSH
8909: LD_INT 57
8911: PPUSH
8912: LD_INT 53
8914: PPUSH
8915: CALL_OW 111
// Wait ( Rand ( 1 1$00 , 4 4$00 ) ) ;
8919: LD_INT 2100
8921: PPUSH
8922: LD_INT 8400
8924: PPUSH
8925: CALL_OW 12
8929: PPUSH
8930: CALL_OW 67
// PlaceUnitXY ( Saseda , 86 , 112 , false ) ;
8934: LD_EXP 17
8938: PPUSH
8939: LD_INT 86
8941: PPUSH
8942: LD_INT 112
8944: PPUSH
8945: LD_INT 0
8947: PPUSH
8948: CALL_OW 48
// Wait ( 0 0$0.3 ) ;
8952: LD_INT 10
8954: PPUSH
8955: CALL_OW 67
// SayRadio ( Saseda , DPM_Sa1 ) ;
8959: LD_EXP 17
8963: PPUSH
8964: LD_STRING DPM_Sa1
8966: PPUSH
8967: CALL_OW 94
// ChangeMissionObjectives ( PM_3 ) ;
8971: LD_STRING PM_3
8973: PPUSH
8974: CALL_OW 337
// end ;
8978: PPOPN 1
8980: END
// every 0 0$01 trigger See ( 3 , Saseda ) do
8981: LD_INT 3
8983: PPUSH
8984: LD_EXP 17
8988: PPUSH
8989: CALL_OW 292
8993: IFFALSE 9042
8995: GO 8997
8997: DISABLE
// begin Say ( Saseda , DPM_Sa2 ) ;
8998: LD_EXP 17
9002: PPUSH
9003: LD_STRING DPM_Sa2
9005: PPUSH
9006: CALL_OW 88
// ChangeMissionObjectives ( PM_4 ) ;
9010: LD_STRING PM_4
9012: PPUSH
9013: CALL_OW 337
// SetTech ( tech_rocket , 3 , state_enabled ) ;
9017: LD_INT 40
9019: PPUSH
9020: LD_INT 3
9022: PPUSH
9023: LD_INT 1
9025: PPUSH
9026: CALL_OW 322
// SetSide ( Saseda , 3 ) ;
9030: LD_EXP 17
9034: PPUSH
9035: LD_INT 3
9037: PPUSH
9038: CALL_OW 235
// end ;
9042: END
// every 16 16$00 trigger not medal1 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
9043: LD_EXP 3
9047: NOT
9048: PUSH
9049: LD_INT 22
9051: PUSH
9052: LD_INT 6
9054: PUSH
9055: EMPTY
9056: LIST
9057: LIST
9058: PPUSH
9059: CALL_OW 69
9063: PUSH
9064: LD_INT 0
9066: EQUAL
9067: AND
9068: IFFALSE 9128
9070: GO 9072
9072: DISABLE
// begin Say ( Stolypin , DPM_S3 ) ;
9073: LD_EXP 15
9077: PPUSH
9078: LD_STRING DPM_S3
9080: PPUSH
9081: CALL_OW 88
// PlaceSeeing ( 62 , 113 , 3 , 10 ) ;
9085: LD_INT 62
9087: PPUSH
9088: LD_INT 113
9090: PPUSH
9091: LD_INT 3
9093: PPUSH
9094: LD_INT 10
9096: PPUSH
9097: CALL_OW 330
// CenterOnXY ( 62 , 113 ) ;
9101: LD_INT 62
9103: PPUSH
9104: LD_INT 113
9106: PPUSH
9107: CALL_OW 84
// CounterAttack ;
9111: CALL 5539 0 0
// RemoveSeeing ( 62 , 113 , 3 ) ;
9115: LD_INT 62
9117: PPUSH
9118: LD_INT 113
9120: PPUSH
9121: LD_INT 3
9123: PPUSH
9124: CALL_OW 331
// end ; end_of_file
9128: END
// on LeaveBuilding ( b , h ) do begin if GetSide ( b ) = 1 then
9129: LD_VAR 0 1
9133: PPUSH
9134: CALL_OW 255
9138: PUSH
9139: LD_INT 1
9141: EQUAL
9142: IFFALSE 9178
// if not us_retreat then
9144: LD_EXP 21
9148: NOT
9149: IFFALSE 9178
// if GetClass ( h ) = 1 then
9151: LD_VAR 0 2
9155: PPUSH
9156: CALL_OW 257
9160: PUSH
9161: LD_INT 1
9163: EQUAL
9164: IFFALSE 9178
// ComEnterUnit ( h , us_arm ) ;
9166: LD_VAR 0 2
9170: PPUSH
9171: LD_INT 69
9173: PPUSH
9174: CALL_OW 120
// end ;
9178: PPOPN 2
9180: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 1 then
9181: LD_VAR 0 1
9185: PPUSH
9186: CALL_OW 255
9190: PUSH
9191: LD_INT 1
9193: EQUAL
9194: IFFALSE 9210
// us_count := us_count + 1 ;
9196: LD_ADDR_EXP 23
9200: PUSH
9201: LD_EXP 23
9205: PUSH
9206: LD_INT 1
9208: PLUS
9209: ST_TO_ADDR
// if un in us_force then
9210: LD_VAR 0 1
9214: PUSH
9215: LD_EXP 12
9219: IN
9220: IFFALSE 9238
// us_force := us_force diff un ;
9222: LD_ADDR_EXP 12
9226: PUSH
9227: LD_EXP 12
9231: PUSH
9232: LD_VAR 0 1
9236: DIFF
9237: ST_TO_ADDR
// if un in ar_force then
9238: LD_VAR 0 1
9242: PUSH
9243: LD_EXP 11
9247: IN
9248: IFFALSE 9266
// ar_force := ar_force diff un ;
9250: LD_ADDR_EXP 11
9254: PUSH
9255: LD_EXP 11
9259: PUSH
9260: LD_VAR 0 1
9264: DIFF
9265: ST_TO_ADDR
// if un = Stolypin then
9266: LD_VAR 0 1
9270: PUSH
9271: LD_EXP 15
9275: EQUAL
9276: IFFALSE 9285
// YouLost ( dead ) ;
9278: LD_STRING dead
9280: PPUSH
9281: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) then
9285: LD_VAR 0 1
9289: PUSH
9290: LD_INT 22
9292: PUSH
9293: LD_INT 1
9295: PUSH
9296: EMPTY
9297: LIST
9298: LIST
9299: PUSH
9300: LD_INT 30
9302: PUSH
9303: LD_INT 0
9305: PUSH
9306: EMPTY
9307: LIST
9308: LIST
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PPUSH
9314: CALL_OW 69
9318: IN
9319: IFFALSE 9328
// YouLost ( depot ) ;
9321: LD_STRING depot
9323: PPUSH
9324: CALL_OW 104
// if GetSide ( un ) = 6 then
9328: LD_VAR 0 1
9332: PPUSH
9333: CALL_OW 255
9337: PUSH
9338: LD_INT 6
9340: EQUAL
9341: IFFALSE 9357
// dest_counter := dest_counter + 1 ;
9343: LD_ADDR_EXP 8
9347: PUSH
9348: LD_EXP 8
9352: PUSH
9353: LD_INT 1
9355: PLUS
9356: ST_TO_ADDR
// end ;
9357: PPOPN 1
9359: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 1 then
9360: LD_VAR 0 1
9364: PPUSH
9365: CALL_OW 255
9369: PUSH
9370: LD_INT 1
9372: EQUAL
9373: IFFALSE 9390
// ComMoveXY ( un , 57 , 52 ) ;
9375: LD_VAR 0 1
9379: PPUSH
9380: LD_INT 57
9382: PPUSH
9383: LD_INT 52
9385: PPUSH
9386: CALL_OW 111
// end ;
9390: PPOPN 2
9392: END
// on Contact ( s1 , s2 ) do begin if not us_alert then
9393: LD_EXP 20
9397: NOT
9398: IFFALSE 9448
// if ( s1 = 3 and s2 = 1 ) or ( s1 = 1 and s2 = 3 ) then
9400: LD_VAR 0 1
9404: PUSH
9405: LD_INT 3
9407: EQUAL
9408: PUSH
9409: LD_VAR 0 2
9413: PUSH
9414: LD_INT 1
9416: EQUAL
9417: AND
9418: PUSH
9419: LD_VAR 0 1
9423: PUSH
9424: LD_INT 1
9426: EQUAL
9427: PUSH
9428: LD_VAR 0 2
9432: PUSH
9433: LD_INT 3
9435: EQUAL
9436: AND
9437: OR
9438: IFFALSE 9448
// us_alert := true ;
9440: LD_ADDR_EXP 20
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
// if ( s1 = 6 and s2 = 3 ) or ( s1 = 3 and s2 = 6 ) then
9448: LD_VAR 0 1
9452: PUSH
9453: LD_INT 6
9455: EQUAL
9456: PUSH
9457: LD_VAR 0 2
9461: PUSH
9462: LD_INT 3
9464: EQUAL
9465: AND
9466: PUSH
9467: LD_VAR 0 1
9471: PUSH
9472: LD_INT 3
9474: EQUAL
9475: PUSH
9476: LD_VAR 0 2
9480: PUSH
9481: LD_INT 6
9483: EQUAL
9484: AND
9485: OR
9486: IFFALSE 9495
// YouLost ( alat ) ;
9488: LD_STRING alat
9490: PPUSH
9491: CALL_OW 104
// end ;
9495: PPOPN 2
9497: END
// on DestinationUnreachable ( un ) do begin if GetSide ( un ) = 6 then
9498: LD_VAR 0 1
9502: PPUSH
9503: CALL_OW 255
9507: PUSH
9508: LD_INT 6
9510: EQUAL
9511: IFFALSE 9527
// display_strings := display_strings union Convoy is blocked! ;
9513: LD_ADDR_OWVAR 47
9517: PUSH
9518: LD_OWVAR 47
9522: PUSH
9523: LD_STRING Convoy is blocked!
9525: UNION
9526: ST_TO_ADDR
// end ;
9527: PPOPN 1
9529: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_empty ] , [ f_type , unit_vehicle ] ] ) then
9530: LD_VAR 0 1
9534: PPUSH
9535: CALL_OW 255
9539: PUSH
9540: LD_INT 2
9542: EQUAL
9543: PUSH
9544: LD_VAR 0 1
9548: PUSH
9549: LD_INT 58
9551: PUSH
9552: EMPTY
9553: LIST
9554: PUSH
9555: LD_INT 21
9557: PUSH
9558: LD_INT 2
9560: PUSH
9561: EMPTY
9562: LIST
9563: LIST
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: PPUSH
9569: CALL_OW 69
9573: IN
9574: AND
9575: IFFALSE 9696
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 2 then
9577: LD_OWVAR 3
9581: PUSH
9582: LD_VAR 0 1
9586: DIFF
9587: PPUSH
9588: LD_VAR 0 1
9592: PPUSH
9593: CALL_OW 74
9597: PPUSH
9598: CALL_OW 255
9602: PUSH
9603: LD_INT 2
9605: NONEQUAL
9606: IFFALSE 9696
// begin Wait ( 0 0$1.3 ) ;
9608: LD_INT 46
9610: PPUSH
9611: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9615: LD_VAR 0 1
9619: PPUSH
9620: CALL_OW 250
9624: PPUSH
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 251
9634: PPUSH
9635: LD_INT 1
9637: PPUSH
9638: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9642: LD_VAR 0 1
9646: PPUSH
9647: CALL_OW 250
9651: PPUSH
9652: LD_VAR 0 1
9656: PPUSH
9657: CALL_OW 251
9661: PPUSH
9662: LD_INT 1
9664: PPUSH
9665: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9669: LD_VAR 0 1
9673: PPUSH
9674: CALL_OW 250
9678: PPUSH
9679: LD_VAR 0 1
9683: PPUSH
9684: CALL_OW 251
9688: PPUSH
9689: LD_INT 1
9691: PPUSH
9692: CALL_OW 453
// end ; end ;
9696: PPOPN 1
9698: END
// on EvacuateVehicle ( driver , un , c1 , c2 ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) and not GetSide ( NearestUnit ( un ) ) = 2 then
9699: LD_VAR 0 2
9703: PUSH
9704: LD_INT 22
9706: PUSH
9707: LD_INT 2
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: PUSH
9714: LD_INT 21
9716: PUSH
9717: LD_INT 2
9719: PUSH
9720: EMPTY
9721: LIST
9722: LIST
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: PPUSH
9728: CALL_OW 69
9732: IN
9733: PUSH
9734: LD_VAR 0 2
9738: PPUSH
9739: CALL 10235 0 1
9743: PPUSH
9744: CALL_OW 255
9748: PUSH
9749: LD_INT 2
9751: EQUAL
9752: NOT
9753: AND
9754: IFFALSE 9879
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
9756: LD_INT 105
9758: PPUSH
9759: LD_INT 210
9761: PPUSH
9762: CALL_OW 12
9766: PPUSH
9767: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9771: LD_VAR 0 2
9775: PPUSH
9776: CALL_OW 250
9780: PPUSH
9781: LD_VAR 0 2
9785: PPUSH
9786: CALL_OW 251
9790: PPUSH
9791: LD_INT 3
9793: PPUSH
9794: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9798: LD_VAR 0 2
9802: PPUSH
9803: CALL_OW 250
9807: PPUSH
9808: LD_VAR 0 2
9812: PPUSH
9813: CALL_OW 251
9817: PPUSH
9818: LD_INT 3
9820: PPUSH
9821: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9825: LD_VAR 0 2
9829: PPUSH
9830: CALL_OW 250
9834: PPUSH
9835: LD_VAR 0 2
9839: PPUSH
9840: CALL_OW 251
9844: PPUSH
9845: LD_INT 3
9847: PPUSH
9848: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9852: LD_VAR 0 2
9856: PPUSH
9857: CALL_OW 250
9861: PPUSH
9862: LD_VAR 0 2
9866: PPUSH
9867: CALL_OW 251
9871: PPUSH
9872: LD_INT 3
9874: PPUSH
9875: CALL_OW 453
// end ; end ; end_of_file
9879: PPOPN 4
9881: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
9882: LD_INT 0
9884: PPUSH
9885: PPUSH
9886: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
9887: LD_ADDR_VAR 0 7
9891: PUSH
9892: LD_VAR 0 1
9896: PUSH
9897: LD_VAR 0 2
9901: ARRAY
9902: PPUSH
9903: LD_VAR 0 3
9907: PPUSH
9908: LD_VAR 0 4
9912: PPUSH
9913: CALL_OW 1
9917: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
9918: LD_ADDR_VAR 0 1
9922: PUSH
9923: LD_VAR 0 1
9927: PPUSH
9928: LD_VAR 0 2
9932: PPUSH
9933: LD_VAR 0 7
9937: PPUSH
9938: CALL_OW 1
9942: ST_TO_ADDR
// result := tab ;
9943: LD_ADDR_VAR 0 5
9947: PUSH
9948: LD_VAR 0 1
9952: ST_TO_ADDR
// end ;
9953: LD_VAR 0 5
9957: RET
// export function IsDriver ( unit ) ; begin
9958: LD_INT 0
9960: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
9961: LD_VAR 0 1
9965: PUSH
9966: LD_INT 55
9968: PUSH
9969: EMPTY
9970: LIST
9971: PPUSH
9972: CALL_OW 69
9976: IN
9977: IFFALSE 9996
// result := IsInUnit ( unit ) else
9979: LD_ADDR_VAR 0 2
9983: PUSH
9984: LD_VAR 0 1
9988: PPUSH
9989: CALL_OW 310
9993: ST_TO_ADDR
9994: GO 10004
// result := false ;
9996: LD_ADDR_VAR 0 2
10000: PUSH
10001: LD_INT 0
10003: ST_TO_ADDR
// end ;
10004: LD_VAR 0 2
10008: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10009: LD_INT 0
10011: PPUSH
10012: PPUSH
10013: PPUSH
// if not GetControl ( veh ) = control_manual then
10014: LD_VAR 0 1
10018: PPUSH
10019: CALL_OW 263
10023: PUSH
10024: LD_INT 1
10026: EQUAL
10027: NOT
10028: IFFALSE 10040
// result := false else
10030: LD_ADDR_VAR 0 2
10034: PUSH
10035: LD_INT 0
10037: ST_TO_ADDR
10038: GO 10185
// if veh in FilterAllUnits ( [ f_empty ] ) then
10040: LD_VAR 0 1
10044: PUSH
10045: LD_INT 58
10047: PUSH
10048: EMPTY
10049: LIST
10050: PPUSH
10051: CALL_OW 69
10055: IN
10056: IFFALSE 10068
// result := false else
10058: LD_ADDR_VAR 0 2
10062: PUSH
10063: LD_INT 0
10065: ST_TO_ADDR
10066: GO 10185
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10068: LD_ADDR_VAR 0 4
10072: PUSH
10073: LD_INT 22
10075: PUSH
10076: LD_VAR 0 1
10080: PPUSH
10081: CALL_OW 255
10085: PUSH
10086: EMPTY
10087: LIST
10088: LIST
10089: PUSH
10090: LD_INT 55
10092: PUSH
10093: EMPTY
10094: LIST
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: PPUSH
10100: CALL_OW 69
10104: ST_TO_ADDR
// if not filter then
10105: LD_VAR 0 4
10109: NOT
10110: IFFALSE 10122
// result := false else
10112: LD_ADDR_VAR 0 2
10116: PUSH
10117: LD_INT 0
10119: ST_TO_ADDR
10120: GO 10185
// for i = 1 to filter do
10122: LD_ADDR_VAR 0 3
10126: PUSH
10127: DOUBLE
10128: LD_INT 1
10130: DEC
10131: ST_TO_ADDR
10132: LD_VAR 0 4
10136: PUSH
10137: FOR_TO
10138: IFFALSE 10183
// if IsDriver ( filter [ i ] ) = veh then
10140: LD_VAR 0 4
10144: PUSH
10145: LD_VAR 0 3
10149: ARRAY
10150: PPUSH
10151: CALL 9958 0 1
10155: PUSH
10156: LD_VAR 0 1
10160: EQUAL
10161: IFFALSE 10181
// begin result := filter [ i ] ;
10163: LD_ADDR_VAR 0 2
10167: PUSH
10168: LD_VAR 0 4
10172: PUSH
10173: LD_VAR 0 3
10177: ARRAY
10178: ST_TO_ADDR
// break ;
10179: GO 10183
// end ;
10181: GO 10137
10183: POP
10184: POP
// end ; end ;
10185: LD_VAR 0 2
10189: RET
// export function FindTarget ( unit ) ; begin
10190: LD_INT 0
10192: PPUSH
// result := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ;
10193: LD_ADDR_VAR 0 2
10197: PUSH
10198: LD_INT 81
10200: PUSH
10201: LD_VAR 0 1
10205: PPUSH
10206: CALL_OW 255
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: PPUSH
10215: CALL_OW 69
10219: PPUSH
10220: LD_VAR 0 1
10224: PPUSH
10225: CALL_OW 74
10229: ST_TO_ADDR
// end ;
10230: LD_VAR 0 2
10234: RET
// export function NearestUnit ( unit ) ; begin
10235: LD_INT 0
10237: PPUSH
// result := NearestUnitToUnit ( all_units diff unit , unit ) ;
10238: LD_ADDR_VAR 0 2
10242: PUSH
10243: LD_OWVAR 3
10247: PUSH
10248: LD_VAR 0 1
10252: DIFF
10253: PPUSH
10254: LD_VAR 0 1
10258: PPUSH
10259: CALL_OW 74
10263: ST_TO_ADDR
// end ; end_of_file
10264: LD_VAR 0 2
10268: RET
// every 12 12$00 do
10269: GO 10271
10271: DISABLE
// begin SetWeather ( 1 , 210 , 110 ) ;
10272: LD_INT 1
10274: PPUSH
10275: LD_INT 210
10277: PPUSH
10278: LD_INT 110
10280: PPUSH
10281: CALL_OW 550
// Wait ( Rand ( 5 5$00 , 10 10$00 ) ) ;
10285: LD_INT 10500
10287: PPUSH
10288: LD_INT 21000
10290: PPUSH
10291: CALL_OW 12
10295: PPUSH
10296: CALL_OW 67
// SetWeather ( 0 , 210 , 110 ) ;
10300: LD_INT 0
10302: PPUSH
10303: LD_INT 210
10305: PPUSH
10306: LD_INT 110
10308: PPUSH
10309: CALL_OW 550
// end ;
10313: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
10314: LD_INT 0
10316: PPUSH
10317: PPUSH
10318: PPUSH
10319: PPUSH
10320: PPUSH
// uc_nation = nation_nature ;
10321: LD_ADDR_OWVAR 21
10325: PUSH
10326: LD_INT 0
10328: ST_TO_ADDR
// uc_side = 0 ;
10329: LD_ADDR_OWVAR 20
10333: PUSH
10334: LD_INT 0
10336: ST_TO_ADDR
// l = 0 ;
10337: LD_ADDR_VAR 0 6
10341: PUSH
10342: LD_INT 0
10344: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
10345: LD_ADDR_OWVAR 24
10349: PUSH
10350: LD_INT 0
10352: PPUSH
10353: LD_INT 5
10355: PPUSH
10356: CALL_OW 12
10360: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
10361: LD_ADDR_OWVAR 35
10365: PUSH
10366: LD_INT 5
10368: NEG
10369: PPUSH
10370: LD_INT 5
10372: PPUSH
10373: CALL_OW 12
10377: ST_TO_ADDR
// hc_gallery =  ;
10378: LD_ADDR_OWVAR 33
10382: PUSH
10383: LD_STRING 
10385: ST_TO_ADDR
// hc_class = class_apeman ;
10386: LD_ADDR_OWVAR 28
10390: PUSH
10391: LD_INT 12
10393: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
10394: LD_ADDR_OWVAR 29
10398: PUSH
10399: LD_INT 11
10401: PPUSH
10402: LD_INT 13
10404: PPUSH
10405: CALL_OW 12
10409: PUSH
10410: LD_INT 10
10412: PPUSH
10413: LD_INT 11
10415: PPUSH
10416: CALL_OW 12
10420: PUSH
10421: EMPTY
10422: LIST
10423: LIST
10424: ST_TO_ADDR
// hc_sex = sex_male ;
10425: LD_ADDR_OWVAR 27
10429: PUSH
10430: LD_INT 1
10432: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
10433: LD_ADDR_OWVAR 31
10437: PUSH
10438: LD_INT 0
10440: PPUSH
10441: LD_INT 2
10443: PPUSH
10444: CALL_OW 12
10448: PUSH
10449: LD_INT 0
10451: PUSH
10452: LD_INT 0
10454: PUSH
10455: LD_INT 0
10457: PUSH
10458: EMPTY
10459: LIST
10460: LIST
10461: LIST
10462: LIST
10463: ST_TO_ADDR
// apeman = CreateHuman ;
10464: LD_ADDR_VAR 0 7
10468: PUSH
10469: CALL_OW 44
10473: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
10474: LD_VAR 0 7
10478: PPUSH
10479: LD_VAR 0 4
10483: PPUSH
10484: LD_INT 0
10486: PPUSH
10487: CALL_OW 49
// l = l + 1 ;
10491: LD_ADDR_VAR 0 6
10495: PUSH
10496: LD_VAR 0 6
10500: PUSH
10501: LD_INT 1
10503: PLUS
10504: ST_TO_ADDR
// end until l = num1 ;
10505: LD_VAR 0 6
10509: PUSH
10510: LD_VAR 0 1
10514: EQUAL
10515: IFFALSE 10345
// l = 0 ;
10517: LD_ADDR_VAR 0 6
10521: PUSH
10522: LD_INT 0
10524: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
10525: LD_ADDR_OWVAR 35
10529: PUSH
10530: LD_INT 0
10532: PPUSH
10533: LD_INT 25
10535: PPUSH
10536: CALL_OW 12
10540: ST_TO_ADDR
// hc_class = class_tiger ;
10541: LD_ADDR_OWVAR 28
10545: PUSH
10546: LD_INT 14
10548: ST_TO_ADDR
// hc_sex = sex_male ;
10549: LD_ADDR_OWVAR 27
10553: PUSH
10554: LD_INT 1
10556: ST_TO_ADDR
// hc_gallery = sandnature ;
10557: LD_ADDR_OWVAR 33
10561: PUSH
10562: LD_STRING sandnature
10564: ST_TO_ADDR
// hc_face_number = 3 ;
10565: LD_ADDR_OWVAR 34
10569: PUSH
10570: LD_INT 3
10572: ST_TO_ADDR
// tiger = CreateHuman ;
10573: LD_ADDR_VAR 0 8
10577: PUSH
10578: CALL_OW 44
10582: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10583: LD_VAR 0 8
10587: PPUSH
10588: LD_VAR 0 4
10592: PPUSH
10593: LD_INT 0
10595: PPUSH
10596: CALL_OW 49
// l = l + 1 ;
10600: LD_ADDR_VAR 0 6
10604: PUSH
10605: LD_VAR 0 6
10609: PUSH
10610: LD_INT 1
10612: PLUS
10613: ST_TO_ADDR
// end until l = num2 ;
10614: LD_VAR 0 6
10618: PUSH
10619: LD_VAR 0 2
10623: EQUAL
10624: IFFALSE 10525
// l = 0 ;
10626: LD_ADDR_VAR 0 6
10630: PUSH
10631: LD_INT 0
10633: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
10634: LD_ADDR_OWVAR 28
10638: PUSH
10639: LD_INT 18
10641: ST_TO_ADDR
// hc_gallery = sandnature ;
10642: LD_ADDR_OWVAR 33
10646: PUSH
10647: LD_STRING sandnature
10649: ST_TO_ADDR
// hc_face_number = 1 ;
10650: LD_ADDR_OWVAR 34
10654: PUSH
10655: LD_INT 1
10657: ST_TO_ADDR
// bird = CreateHuman ;
10658: LD_ADDR_VAR 0 9
10662: PUSH
10663: CALL_OW 44
10667: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
10668: LD_VAR 0 9
10672: PPUSH
10673: LD_INT 0
10675: PPUSH
10676: CALL_OW 51
// l = l + 1 ;
10680: LD_ADDR_VAR 0 6
10684: PUSH
10685: LD_VAR 0 6
10689: PUSH
10690: LD_INT 1
10692: PLUS
10693: ST_TO_ADDR
// end until l = num3 ;
10694: LD_VAR 0 6
10698: PUSH
10699: LD_VAR 0 3
10703: EQUAL
10704: IFFALSE 10634
// end ;
10706: LD_VAR 0 5
10710: RET
