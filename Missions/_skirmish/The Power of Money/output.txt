// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Init ;
  11: CALL 66 0 0
// PrepareAnimals ( 6 , 3 , 4 , apearea ) ;
  15: LD_INT 6
  17: PPUSH
  18: LD_INT 3
  20: PPUSH
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 21
  26: PPUSH
  27: CALL 10558 0 4
// PrepareAmerican ;
  31: CALL 3957 0 0
// PrepareRussian ;
  35: CALL 277 0 0
// Action ;
  39: CALL 8298 0 0
// end ;
  43: END
// every 0 0$01 do
  44: GO 46
  46: DISABLE
// begin enable ;
  47: ENABLE
// display_strings := [ #tick , tick ] ;
  48: LD_ADDR_OWVAR 47
  52: PUSH
  53: LD_STRING #tick
  55: PUSH
  56: LD_OWVAR 1
  60: PUSH
  61: EMPTY
  62: LIST
  63: LIST
  64: ST_TO_ADDR
// end ;
  65: END
// export conv_squad , escort , medal1 , medal2 , medal3 , path , convoy_start , dest_counter ; export riv , ar_attacks , ar_force , us_force , conv_counter , crates_counter ; function Init ; begin
  66: LD_INT 0
  68: PPUSH
// medal1 := true ;
  69: LD_ADDR_EXP 3
  73: PUSH
  74: LD_INT 1
  76: ST_TO_ADDR
// medal2 := true ;
  77: LD_ADDR_EXP 4
  81: PUSH
  82: LD_INT 1
  84: ST_TO_ADDR
// medal3 := true ;
  85: LD_ADDR_EXP 5
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// path := [ pp1 , pp2 , pp3 , pp4 , conv_end ] ;
  93: LD_ADDR_EXP 6
  97: PUSH
  98: LD_INT 10
 100: PUSH
 101: LD_INT 11
 103: PUSH
 104: LD_INT 12
 106: PUSH
 107: LD_INT 13
 109: PUSH
 110: LD_INT 9
 112: PUSH
 113: EMPTY
 114: LIST
 115: LIST
 116: LIST
 117: LIST
 118: LIST
 119: ST_TO_ADDR
// conv_squad := [ ] ;
 120: LD_ADDR_EXP 1
 124: PUSH
 125: EMPTY
 126: ST_TO_ADDR
// escort := [ ] ;
 127: LD_ADDR_EXP 2
 131: PUSH
 132: EMPTY
 133: ST_TO_ADDR
// riv := [ ] ;
 134: LD_ADDR_EXP 9
 138: PUSH
 139: EMPTY
 140: ST_TO_ADDR
// ar_force := [ ] ;
 141: LD_ADDR_EXP 11
 145: PUSH
 146: EMPTY
 147: ST_TO_ADDR
// ar_attacks := false ;
 148: LD_ADDR_EXP 10
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// us_force := [ ] ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: EMPTY
 162: ST_TO_ADDR
// convoy_start := false ;
 163: LD_ADDR_EXP 7
 167: PUSH
 168: LD_INT 0
 170: ST_TO_ADDR
// conv_counter := 0 ;
 171: LD_ADDR_EXP 13
 175: PUSH
 176: LD_INT 0
 178: ST_TO_ADDR
// dest_counter := 0 ;
 179: LD_ADDR_EXP 8
 183: PUSH
 184: LD_INT 0
 186: ST_TO_ADDR
// crates_counter := 0 0$40 ;
 187: LD_ADDR_EXP 14
 191: PUSH
 192: LD_INT 1400
 194: ST_TO_ADDR
// end ;
 195: LD_VAR 0 1
 199: RET
// every 2 2$00 do
 200: GO 202
 202: DISABLE
// begin while ( tick <= [ 47 47$00 , 44 44$00 , 41 41$00 ] [ Difficulty ] ) do
 203: LD_OWVAR 1
 207: PUSH
 208: LD_INT 98700
 210: PUSH
 211: LD_INT 92400
 213: PUSH
 214: LD_INT 86100
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: LIST
 221: PUSH
 222: LD_OWVAR 67
 226: ARRAY
 227: LESSEQUAL
 228: IFFALSE 276
// begin Wait ( crates_counter ) ;
 230: LD_EXP 14
 234: PPUSH
 235: CALL_OW 67
// crates_counter := crates_counter + 0 0$09 ;
 239: LD_ADDR_EXP 14
 243: PUSH
 244: LD_EXP 14
 248: PUSH
 249: LD_INT 315
 251: PLUS
 252: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 5
 258: PPUSH
 259: CALL_OW 12
 263: PPUSH
 264: LD_INT 22
 266: PPUSH
 267: LD_INT 1
 269: PPUSH
 270: CALL_OW 55
// end ;
 274: GO 203
// end ; end_of_file
 276: END
// export Stolypin , Popov , Saseda ; export function PrepareRussian ; var un , force , i , c , skill , team ; begin
 277: LD_INT 0
 279: PPUSH
 280: PPUSH
 281: PPUSH
 282: PPUSH
 283: PPUSH
 284: PPUSH
 285: PPUSH
// uc_side := 6 ;
 286: LD_ADDR_OWVAR 20
 290: PUSH
 291: LD_INT 6
 293: ST_TO_ADDR
// uc_nation := 3 ;
 294: LD_ADDR_OWVAR 21
 298: PUSH
 299: LD_INT 3
 301: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
 302: LD_INT 3
 304: PPUSH
 305: LD_INT 6
 307: PPUSH
 308: CALL_OW 343
// Popov := NewCharacter ( Gaydar ) ;
 312: LD_ADDR_EXP 16
 316: PUSH
 317: LD_STRING Gaydar
 319: PPUSH
 320: CALL_OW 25
 324: ST_TO_ADDR
// uc_side := 7 ;
 325: LD_ADDR_OWVAR 20
 329: PUSH
 330: LD_INT 7
 332: ST_TO_ADDR
// hc_gallery := sandal ;
 333: LD_ADDR_OWVAR 33
 337: PUSH
 338: LD_STRING sandal
 340: ST_TO_ADDR
// hc_face_number := 9 ;
 341: LD_ADDR_OWVAR 34
 345: PUSH
 346: LD_INT 9
 348: ST_TO_ADDR
// hc_skills := [ 3 , 5 , 2 , 7 ] ;
 349: LD_ADDR_OWVAR 31
 353: PUSH
 354: LD_INT 3
 356: PUSH
 357: LD_INT 5
 359: PUSH
 360: LD_INT 2
 362: PUSH
 363: LD_INT 7
 365: PUSH
 366: EMPTY
 367: LIST
 368: LIST
 369: LIST
 370: LIST
 371: ST_TO_ADDR
// hc_sex := sex_male ;
 372: LD_ADDR_OWVAR 27
 376: PUSH
 377: LD_INT 1
 379: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 380: LD_ADDR_OWVAR 29
 384: PUSH
 385: LD_INT 10
 387: PUSH
 388: LD_INT 11
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: ST_TO_ADDR
// hc_class := 4 ;
 395: LD_ADDR_OWVAR 28
 399: PUSH
 400: LD_INT 4
 402: ST_TO_ADDR
// hc_name := Fiodor Saseda ;
 403: LD_ADDR_OWVAR 26
 407: PUSH
 408: LD_STRING Fiodor Saseda
 410: ST_TO_ADDR
// Saseda := CreateHuman ;
 411: LD_ADDR_EXP 17
 415: PUSH
 416: CALL_OW 44
 420: ST_TO_ADDR
// uc_side := 3 ;
 421: LD_ADDR_OWVAR 20
 425: PUSH
 426: LD_INT 3
 428: ST_TO_ADDR
// hc_importance := 100 ;
 429: LD_ADDR_OWVAR 32
 433: PUSH
 434: LD_INT 100
 436: ST_TO_ADDR
// hc_class := 1 ;
 437: LD_ADDR_OWVAR 28
 441: PUSH
 442: LD_INT 1
 444: ST_TO_ADDR
// hc_sex := sex_male ;
 445: LD_ADDR_OWVAR 27
 449: PUSH
 450: LD_INT 1
 452: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
 453: LD_ADDR_OWVAR 31
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 3
 463: PUSH
 464: LD_INT 4
 466: PUSH
 467: LD_INT 2
 469: PUSH
 470: EMPTY
 471: LIST
 472: LIST
 473: LIST
 474: LIST
 475: ST_TO_ADDR
// hc_name := W. I. Stolypin ;
 476: LD_ADDR_OWVAR 26
 480: PUSH
 481: LD_STRING W. I. Stolypin
 483: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 484: LD_ADDR_OWVAR 29
 488: PUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: ST_TO_ADDR
// hc_gallery := ru ;
 499: LD_ADDR_OWVAR 33
 503: PUSH
 504: LD_STRING ru
 506: ST_TO_ADDR
// hc_face_number := 15 ;
 507: LD_ADDR_OWVAR 34
 511: PUSH
 512: LD_INT 15
 514: ST_TO_ADDR
// Stolypin := CreateHuman ;
 515: LD_ADDR_EXP 15
 519: PUSH
 520: CALL_OW 44
 524: ST_TO_ADDR
// hc_importance := 0 ;
 525: LD_ADDR_OWVAR 32
 529: PUSH
 530: LD_INT 0
 532: ST_TO_ADDR
// hc_gallery :=  ;
 533: LD_ADDR_OWVAR 33
 537: PUSH
 538: LD_STRING 
 540: ST_TO_ADDR
// hc_name :=  ;
 541: LD_ADDR_OWVAR 26
 545: PUSH
 546: LD_STRING 
 548: ST_TO_ADDR
// skill := [ 6 , 5 , 5 ] [ Difficulty ] ;
 549: LD_ADDR_VAR 0 6
 553: PUSH
 554: LD_INT 6
 556: PUSH
 557: LD_INT 5
 559: PUSH
 560: LD_INT 5
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: PUSH
 568: LD_OWVAR 67
 572: ARRAY
 573: ST_TO_ADDR
// c := 1 ;
 574: LD_ADDR_VAR 0 5
 578: PUSH
 579: LD_INT 1
 581: ST_TO_ADDR
// for i = 1 to 21 do
 582: LD_ADDR_VAR 0 4
 586: PUSH
 587: DOUBLE
 588: LD_INT 1
 590: DEC
 591: ST_TO_ADDR
 592: LD_INT 21
 594: PUSH
 595: FOR_TO
 596: IFFALSE 697
// begin if i = 10 then
 598: LD_VAR 0 4
 602: PUSH
 603: LD_INT 10
 605: EQUAL
 606: IFFALSE 616
// c := 2 ;
 608: LD_ADDR_VAR 0 5
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// if i = 14 then
 616: LD_VAR 0 4
 620: PUSH
 621: LD_INT 14
 623: EQUAL
 624: IFFALSE 634
// c := 3 ;
 626: LD_ADDR_VAR 0 5
 630: PUSH
 631: LD_INT 3
 633: ST_TO_ADDR
// if i = 18 then
 634: LD_VAR 0 4
 638: PUSH
 639: LD_INT 18
 641: EQUAL
 642: IFFALSE 652
// c := 4 ;
 644: LD_ADDR_VAR 0 5
 648: PUSH
 649: LD_INT 4
 651: ST_TO_ADDR
// PrepareHuman ( false , c , skill ) ;
 652: LD_INT 0
 654: PPUSH
 655: LD_VAR 0 5
 659: PPUSH
 660: LD_VAR 0 6
 664: PPUSH
 665: CALL_OW 380
// un := CreateHuman ;
 669: LD_ADDR_VAR 0 2
 673: PUSH
 674: CALL_OW 44
 678: ST_TO_ADDR
// force := force ^ un ;
 679: LD_ADDR_VAR 0 3
 683: PUSH
 684: LD_VAR 0 3
 688: PUSH
 689: LD_VAR 0 2
 693: ADD
 694: ST_TO_ADDR
// end ;
 695: GO 595
 697: POP
 698: POP
// team := CharacterSelection ( text , [ 8 , 7 , 7 ] [ Difficulty ] , [ 8 , 7 , 7 ] [ Difficulty ] , [ sel_change_class , Stolypin , sel_changeable , sel_not_hired ] ^ force , [ [ class_soldier , 3 ] , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
 699: LD_ADDR_VAR 0 7
 703: PUSH
 704: LD_STRING text
 706: PPUSH
 707: LD_INT 8
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 7
 715: PUSH
 716: EMPTY
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_OWVAR 67
 725: ARRAY
 726: PPUSH
 727: LD_INT 8
 729: PUSH
 730: LD_INT 7
 732: PUSH
 733: LD_INT 7
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_OWVAR 67
 745: ARRAY
 746: PPUSH
 747: LD_INT -5
 749: PUSH
 750: LD_EXP 15
 754: PUSH
 755: LD_INT -3
 757: PUSH
 758: LD_INT -2
 760: PUSH
 761: EMPTY
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PUSH
 767: LD_VAR 0 3
 771: ADD
 772: PPUSH
 773: LD_INT 1
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: EMPTY
 780: LIST
 781: LIST
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 2
 788: PUSH
 789: LD_INT 1
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 4
 798: PUSH
 799: EMPTY
 800: LIST
 801: LIST
 802: LIST
 803: LIST
 804: PPUSH
 805: CALL_OW 42
 809: ST_TO_ADDR
// team := team ^ Stolypin ;
 810: LD_ADDR_VAR 0 7
 814: PUSH
 815: LD_VAR 0 7
 819: PUSH
 820: LD_EXP 15
 824: ADD
 825: ST_TO_ADDR
// for i = 1 to team do
 826: LD_ADDR_VAR 0 4
 830: PUSH
 831: DOUBLE
 832: LD_INT 1
 834: DEC
 835: ST_TO_ADDR
 836: LD_VAR 0 7
 840: PUSH
 841: FOR_TO
 842: IFFALSE 867
// PlaceUnitArea ( team [ i ] , rus_start , false ) ;
 844: LD_VAR 0 7
 848: PUSH
 849: LD_VAR 0 4
 853: ARRAY
 854: PPUSH
 855: LD_INT 1
 857: PPUSH
 858: LD_INT 0
 860: PPUSH
 861: CALL_OW 49
 865: GO 841
 867: POP
 868: POP
// CenterNowOnUnits ( Stolypin ) ;
 869: LD_EXP 15
 873: PPUSH
 874: CALL_OW 87
// end ;
 878: LD_VAR 0 1
 882: RET
// export conv_ready ; export function Convoy ( type ) ; var i , veh , skill ; begin
 883: LD_INT 0
 885: PPUSH
 886: PPUSH
 887: PPUSH
 888: PPUSH
// Randomize ;
 889: CALL_OW 10
// uc_side := 6 ;
 893: LD_ADDR_OWVAR 20
 897: PUSH
 898: LD_INT 6
 900: ST_TO_ADDR
// uc_nation := 3 ;
 901: LD_ADDR_OWVAR 21
 905: PUSH
 906: LD_INT 3
 908: ST_TO_ADDR
// hc_name :=  ;
 909: LD_ADDR_OWVAR 26
 913: PUSH
 914: LD_STRING 
 916: ST_TO_ADDR
// hc_gallery :=  ;
 917: LD_ADDR_OWVAR 33
 921: PUSH
 922: LD_STRING 
 924: ST_TO_ADDR
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
 925: LD_ADDR_VAR 0 5
 929: PUSH
 930: LD_INT 5
 932: PUSH
 933: LD_INT 5
 935: PUSH
 936: LD_INT 4
 938: PUSH
 939: EMPTY
 940: LIST
 941: LIST
 942: LIST
 943: PUSH
 944: LD_OWVAR 67
 948: ARRAY
 949: ST_TO_ADDR
// conv_ready := false ;
 950: LD_ADDR_EXP 18
 954: PUSH
 955: LD_INT 0
 957: ST_TO_ADDR
// case type of 1 :
 958: LD_VAR 0 1
 962: PUSH
 963: LD_INT 1
 965: DOUBLE
 966: EQUAL
 967: IFTRUE 971
 969: GO 1241
 971: POP
// begin if Rand ( 0 , 1 ) = 1 then
 972: LD_INT 0
 974: PPUSH
 975: LD_INT 1
 977: PPUSH
 978: CALL_OW 12
 982: PUSH
 983: LD_INT 1
 985: EQUAL
 986: IFFALSE 992
// AddEscort ( ) ;
 988: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
 992: LD_INT 70
 994: PPUSH
 995: CALL_OW 67
// vc_chassis := ru_medium_wheeled ;
 999: LD_ADDR_OWVAR 37
1003: PUSH
1004: LD_INT 21
1006: ST_TO_ADDR
// vc_engine := engine_combustion ;
1007: LD_ADDR_OWVAR 39
1011: PUSH
1012: LD_INT 1
1014: ST_TO_ADDR
// vc_control := control_manual ;
1015: LD_ADDR_OWVAR 38
1019: PUSH
1020: LD_INT 1
1022: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1023: LD_ADDR_OWVAR 40
1027: PUSH
1028: LD_INT 51
1030: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1031: LD_ADDR_OWVAR 41
1035: PUSH
1036: LD_INT 50
1038: PPUSH
1039: LD_INT 99
1041: PPUSH
1042: CALL_OW 12
1046: ST_TO_ADDR
// if uc_side <> 6 then
1047: LD_OWVAR 20
1051: PUSH
1052: LD_INT 6
1054: NONEQUAL
1055: IFFALSE 1065
// uc_side := 6 ;
1057: LD_ADDR_OWVAR 20
1061: PUSH
1062: LD_INT 6
1064: ST_TO_ADDR
// veh := CreateVehicle ;
1065: LD_ADDR_VAR 0 4
1069: PUSH
1070: CALL_OW 45
1074: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1075: LD_VAR 0 4
1079: PPUSH
1080: LD_INT 3
1082: PPUSH
1083: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1087: LD_VAR 0 4
1091: PPUSH
1092: LD_INT 8
1094: PPUSH
1095: LD_INT 0
1097: PPUSH
1098: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1102: LD_INT 0
1104: PPUSH
1105: LD_INT 1
1107: PPUSH
1108: LD_INT 2
1110: PPUSH
1111: CALL_OW 12
1115: PPUSH
1116: LD_VAR 0 5
1120: PPUSH
1121: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1125: CALL_OW 44
1129: PPUSH
1130: LD_VAR 0 4
1134: PPUSH
1135: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1139: LD_VAR 0 4
1143: PPUSH
1144: LD_INT 500
1146: PPUSH
1147: LD_INT 1000
1149: PPUSH
1150: CALL_OW 12
1154: PPUSH
1155: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1159: LD_VAR 0 4
1163: PPUSH
1164: LD_INT 1
1166: PPUSH
1167: LD_INT 2
1169: PPUSH
1170: CALL_OW 12
1174: PPUSH
1175: LD_INT 2
1177: PPUSH
1178: LD_INT 10
1180: PPUSH
1181: CALL_OW 12
1185: PUSH
1186: LD_INT 10
1188: MUL
1189: PPUSH
1190: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1194: LD_ADDR_EXP 1
1198: PUSH
1199: LD_EXP 1
1203: PPUSH
1204: LD_INT 1
1206: PPUSH
1207: LD_VAR 0 4
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: PPUSH
1219: CALL_OW 2
1223: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
1224: LD_INT 35
1226: PPUSH
1227: CALL_OW 67
// conv_ready := true ;
1231: LD_ADDR_EXP 18
1235: PUSH
1236: LD_INT 1
1238: ST_TO_ADDR
// end ; 2 :
1239: GO 2861
1241: LD_INT 2
1243: DOUBLE
1244: EQUAL
1245: IFTRUE 1249
1247: GO 1549
1249: POP
// begin AddEscort ( ) ;
1250: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1254: LD_INT 70
1256: PPUSH
1257: CALL_OW 67
// for i = 1 to 2 do
1261: LD_ADDR_VAR 0 3
1265: PUSH
1266: DOUBLE
1267: LD_INT 1
1269: DEC
1270: ST_TO_ADDR
1271: LD_INT 2
1273: PUSH
1274: FOR_TO
1275: IFFALSE 1526
// begin vc_chassis := ru_medium_wheeled ;
1277: LD_ADDR_OWVAR 37
1281: PUSH
1282: LD_INT 21
1284: ST_TO_ADDR
// vc_engine := engine_combustion ;
1285: LD_ADDR_OWVAR 39
1289: PUSH
1290: LD_INT 1
1292: ST_TO_ADDR
// vc_control := control_manual ;
1293: LD_ADDR_OWVAR 38
1297: PUSH
1298: LD_INT 1
1300: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1301: LD_ADDR_OWVAR 40
1305: PUSH
1306: LD_INT 51
1308: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1309: LD_ADDR_OWVAR 41
1313: PUSH
1314: LD_INT 50
1316: PPUSH
1317: LD_INT 99
1319: PPUSH
1320: CALL_OW 12
1324: ST_TO_ADDR
// if uc_side <> 6 then
1325: LD_OWVAR 20
1329: PUSH
1330: LD_INT 6
1332: NONEQUAL
1333: IFFALSE 1343
// uc_side := 6 ;
1335: LD_ADDR_OWVAR 20
1339: PUSH
1340: LD_INT 6
1342: ST_TO_ADDR
// veh := CreateVehicle ;
1343: LD_ADDR_VAR 0 4
1347: PUSH
1348: CALL_OW 45
1352: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1353: LD_VAR 0 4
1357: PPUSH
1358: LD_INT 3
1360: PPUSH
1361: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1365: LD_VAR 0 4
1369: PPUSH
1370: LD_INT 8
1372: PPUSH
1373: LD_INT 0
1375: PPUSH
1376: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1380: LD_INT 0
1382: PPUSH
1383: LD_INT 1
1385: PPUSH
1386: LD_INT 2
1388: PPUSH
1389: CALL_OW 12
1393: PPUSH
1394: LD_VAR 0 5
1398: PPUSH
1399: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1403: CALL_OW 44
1407: PPUSH
1408: LD_VAR 0 4
1412: PPUSH
1413: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1417: LD_VAR 0 4
1421: PPUSH
1422: LD_INT 500
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 12
1432: PPUSH
1433: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1437: LD_VAR 0 4
1441: PPUSH
1442: LD_INT 1
1444: PPUSH
1445: LD_INT 2
1447: PPUSH
1448: CALL_OW 12
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 10
1458: PPUSH
1459: CALL_OW 12
1463: PUSH
1464: LD_INT 10
1466: MUL
1467: PPUSH
1468: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1472: LD_ADDR_EXP 1
1476: PUSH
1477: LD_EXP 1
1481: PPUSH
1482: LD_INT 1
1484: PPUSH
1485: LD_VAR 0 4
1489: PUSH
1490: LD_INT 1
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: PPUSH
1497: CALL_OW 2
1501: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1502: LD_VAR 0 4
1506: PPUSH
1507: LD_INT 120
1509: PPUSH
1510: LD_INT 10
1512: PPUSH
1513: CALL_OW 111
// Wait ( 0 0$02 ) ;
1517: LD_INT 70
1519: PPUSH
1520: CALL_OW 67
// end ;
1524: GO 1274
1526: POP
1527: POP
// AddEscort ( ) ;
1528: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1532: LD_INT 70
1534: PPUSH
1535: CALL_OW 67
// conv_ready := true ;
1539: LD_ADDR_EXP 18
1543: PUSH
1544: LD_INT 1
1546: ST_TO_ADDR
// end ; 3 :
1547: GO 2861
1549: LD_INT 3
1551: DOUBLE
1552: EQUAL
1553: IFTRUE 1557
1555: GO 1976
1557: POP
// begin AddEscort ( ) ;
1558: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
1562: LD_INT 70
1564: PPUSH
1565: CALL_OW 67
// for i = 1 to 2 do
1569: LD_ADDR_VAR 0 3
1573: PUSH
1574: DOUBLE
1575: LD_INT 1
1577: DEC
1578: ST_TO_ADDR
1579: LD_INT 2
1581: PUSH
1582: FOR_TO
1583: IFFALSE 1834
// begin vc_chassis := ru_medium_wheeled ;
1585: LD_ADDR_OWVAR 37
1589: PUSH
1590: LD_INT 21
1592: ST_TO_ADDR
// vc_engine := engine_combustion ;
1593: LD_ADDR_OWVAR 39
1597: PUSH
1598: LD_INT 1
1600: ST_TO_ADDR
// vc_control := control_manual ;
1601: LD_ADDR_OWVAR 38
1605: PUSH
1606: LD_INT 1
1608: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1609: LD_ADDR_OWVAR 40
1613: PUSH
1614: LD_INT 51
1616: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1617: LD_ADDR_OWVAR 41
1621: PUSH
1622: LD_INT 50
1624: PPUSH
1625: LD_INT 99
1627: PPUSH
1628: CALL_OW 12
1632: ST_TO_ADDR
// if uc_side <> 6 then
1633: LD_OWVAR 20
1637: PUSH
1638: LD_INT 6
1640: NONEQUAL
1641: IFFALSE 1651
// uc_side := 6 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 6
1650: ST_TO_ADDR
// veh := CreateVehicle ;
1651: LD_ADDR_VAR 0 4
1655: PUSH
1656: CALL_OW 45
1660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1661: LD_VAR 0 4
1665: PPUSH
1666: LD_INT 3
1668: PPUSH
1669: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1673: LD_VAR 0 4
1677: PPUSH
1678: LD_INT 8
1680: PPUSH
1681: LD_INT 0
1683: PPUSH
1684: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1688: LD_INT 0
1690: PPUSH
1691: LD_INT 1
1693: PPUSH
1694: LD_INT 2
1696: PPUSH
1697: CALL_OW 12
1701: PPUSH
1702: LD_VAR 0 5
1706: PPUSH
1707: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1711: CALL_OW 44
1715: PPUSH
1716: LD_VAR 0 4
1720: PPUSH
1721: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1725: LD_VAR 0 4
1729: PPUSH
1730: LD_INT 500
1732: PPUSH
1733: LD_INT 1000
1735: PPUSH
1736: CALL_OW 12
1740: PPUSH
1741: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1745: LD_VAR 0 4
1749: PPUSH
1750: LD_INT 1
1752: PPUSH
1753: LD_INT 2
1755: PPUSH
1756: CALL_OW 12
1760: PPUSH
1761: LD_INT 2
1763: PPUSH
1764: LD_INT 10
1766: PPUSH
1767: CALL_OW 12
1771: PUSH
1772: LD_INT 10
1774: MUL
1775: PPUSH
1776: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1780: LD_ADDR_EXP 1
1784: PUSH
1785: LD_EXP 1
1789: PPUSH
1790: LD_INT 1
1792: PPUSH
1793: LD_VAR 0 4
1797: PUSH
1798: LD_INT 1
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL_OW 2
1809: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1810: LD_VAR 0 4
1814: PPUSH
1815: LD_INT 120
1817: PPUSH
1818: LD_INT 10
1820: PPUSH
1821: CALL_OW 111
// Wait ( 0 0$02 ) ;
1825: LD_INT 70
1827: PPUSH
1828: CALL_OW 67
// end ;
1832: GO 1582
1834: POP
1835: POP
// for i = 1 to 2 do
1836: LD_ADDR_VAR 0 3
1840: PUSH
1841: DOUBLE
1842: LD_INT 1
1844: DEC
1845: ST_TO_ADDR
1846: LD_INT 2
1848: PUSH
1849: FOR_TO
1850: IFFALSE 1957
// begin PrepareHuman ( false , 1 , skill ) ;
1852: LD_INT 0
1854: PPUSH
1855: LD_INT 1
1857: PPUSH
1858: LD_VAR 0 5
1862: PPUSH
1863: CALL_OW 380
// if uc_side <> 6 then
1867: LD_OWVAR 20
1871: PUSH
1872: LD_INT 6
1874: NONEQUAL
1875: IFFALSE 1885
// uc_side := 6 ;
1877: LD_ADDR_OWVAR 20
1881: PUSH
1882: LD_INT 6
1884: ST_TO_ADDR
// veh := CreateHuman ;
1885: LD_ADDR_VAR 0 4
1889: PUSH
1890: CALL_OW 44
1894: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1895: LD_VAR 0 4
1899: PPUSH
1900: LD_INT 8
1902: PPUSH
1903: LD_INT 0
1905: PPUSH
1906: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
1910: LD_ADDR_EXP 2
1914: PUSH
1915: LD_EXP 2
1919: PPUSH
1920: LD_INT 1
1922: PPUSH
1923: LD_VAR 0 4
1927: PPUSH
1928: CALL_OW 2
1932: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1933: LD_VAR 0 4
1937: PPUSH
1938: LD_INT 120
1940: PPUSH
1941: LD_INT 10
1943: PPUSH
1944: CALL_OW 111
// Wait ( 0 0$02 ) ;
1948: LD_INT 70
1950: PPUSH
1951: CALL_OW 67
// end ;
1955: GO 1849
1957: POP
1958: POP
// Wait ( 0 0$02 ) ;
1959: LD_INT 70
1961: PPUSH
1962: CALL_OW 67
// conv_ready := true ;
1966: LD_ADDR_EXP 18
1970: PUSH
1971: LD_INT 1
1973: ST_TO_ADDR
// end ; 4 :
1974: GO 2861
1976: LD_INT 4
1978: DOUBLE
1979: EQUAL
1980: IFTRUE 1984
1982: GO 2290
1984: POP
// begin if Rand ( 0 , 1 ) = 1 then
1985: LD_INT 0
1987: PPUSH
1988: LD_INT 1
1990: PPUSH
1991: CALL_OW 12
1995: PUSH
1996: LD_INT 1
1998: EQUAL
1999: IFFALSE 2005
// AddEscort ( ) ;
2001: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2005: LD_INT 70
2007: PPUSH
2008: CALL_OW 67
// for i = 1 to 5 do
2012: LD_ADDR_VAR 0 3
2016: PUSH
2017: DOUBLE
2018: LD_INT 1
2020: DEC
2021: ST_TO_ADDR
2022: LD_INT 5
2024: PUSH
2025: FOR_TO
2026: IFFALSE 2148
// begin PrepareHuman ( false , Rand ( 2 , 4 ) , skill ) ;
2028: LD_INT 0
2030: PPUSH
2031: LD_INT 2
2033: PPUSH
2034: LD_INT 4
2036: PPUSH
2037: CALL_OW 12
2041: PPUSH
2042: LD_VAR 0 5
2046: PPUSH
2047: CALL_OW 380
// if uc_side <> 6 then
2051: LD_OWVAR 20
2055: PUSH
2056: LD_INT 6
2058: NONEQUAL
2059: IFFALSE 2069
// uc_side := 6 ;
2061: LD_ADDR_OWVAR 20
2065: PUSH
2066: LD_INT 6
2068: ST_TO_ADDR
// veh := CreateHuman ;
2069: LD_ADDR_VAR 0 4
2073: PUSH
2074: CALL_OW 44
2078: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2079: LD_VAR 0 4
2083: PPUSH
2084: LD_INT 8
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 49
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2094: LD_ADDR_EXP 1
2098: PUSH
2099: LD_EXP 1
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_VAR 0 4
2111: PUSH
2112: LD_INT 1
2114: PUSH
2115: EMPTY
2116: LIST
2117: LIST
2118: PPUSH
2119: CALL_OW 2
2123: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2124: LD_VAR 0 4
2128: PPUSH
2129: LD_INT 120
2131: PPUSH
2132: LD_INT 10
2134: PPUSH
2135: CALL_OW 111
// Wait ( 0 0$02 ) ;
2139: LD_INT 70
2141: PPUSH
2142: CALL_OW 67
// end ;
2146: GO 2025
2148: POP
2149: POP
// for i = 1 to 2 do
2150: LD_ADDR_VAR 0 3
2154: PUSH
2155: DOUBLE
2156: LD_INT 1
2158: DEC
2159: ST_TO_ADDR
2160: LD_INT 2
2162: PUSH
2163: FOR_TO
2164: IFFALSE 2271
// begin PrepareHuman ( false , 1 , skill ) ;
2166: LD_INT 0
2168: PPUSH
2169: LD_INT 1
2171: PPUSH
2172: LD_VAR 0 5
2176: PPUSH
2177: CALL_OW 380
// if uc_side <> 6 then
2181: LD_OWVAR 20
2185: PUSH
2186: LD_INT 6
2188: NONEQUAL
2189: IFFALSE 2199
// uc_side := 6 ;
2191: LD_ADDR_OWVAR 20
2195: PUSH
2196: LD_INT 6
2198: ST_TO_ADDR
// veh := CreateHuman ;
2199: LD_ADDR_VAR 0 4
2203: PUSH
2204: CALL_OW 44
2208: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2209: LD_VAR 0 4
2213: PPUSH
2214: LD_INT 8
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
2224: LD_ADDR_EXP 2
2228: PUSH
2229: LD_EXP 2
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: LD_VAR 0 4
2241: PPUSH
2242: CALL_OW 2
2246: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2247: LD_VAR 0 4
2251: PPUSH
2252: LD_INT 120
2254: PPUSH
2255: LD_INT 10
2257: PPUSH
2258: CALL_OW 111
// Wait ( 0 0$02 ) ;
2262: LD_INT 70
2264: PPUSH
2265: CALL_OW 67
// end ;
2269: GO 2163
2271: POP
2272: POP
// Wait ( 0 0$02 ) ;
2273: LD_INT 70
2275: PPUSH
2276: CALL_OW 67
// conv_ready := true ;
2280: LD_ADDR_EXP 18
2284: PUSH
2285: LD_INT 1
2287: ST_TO_ADDR
// end ; 5 :
2288: GO 2861
2290: LD_INT 5
2292: DOUBLE
2293: EQUAL
2294: IFTRUE 2298
2296: GO 2860
2298: POP
// begin AddEscort ( ) ;
2299: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2303: LD_INT 70
2305: PPUSH
2306: CALL_OW 67
// AddEscort ( ) ;
2310: CALL 2866 0 0
// Wait ( 0 0$02 ) ;
2314: LD_INT 70
2316: PPUSH
2317: CALL_OW 67
// for i = 1 to 2 do
2321: LD_ADDR_VAR 0 3
2325: PUSH
2326: DOUBLE
2327: LD_INT 1
2329: DEC
2330: ST_TO_ADDR
2331: LD_INT 2
2333: PUSH
2334: FOR_TO
2335: IFFALSE 2586
// begin vc_chassis := ru_medium_wheeled ;
2337: LD_ADDR_OWVAR 37
2341: PUSH
2342: LD_INT 21
2344: ST_TO_ADDR
// vc_engine := engine_combustion ;
2345: LD_ADDR_OWVAR 39
2349: PUSH
2350: LD_INT 1
2352: ST_TO_ADDR
// vc_control := control_manual ;
2353: LD_ADDR_OWVAR 38
2357: PUSH
2358: LD_INT 1
2360: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2361: LD_ADDR_OWVAR 40
2365: PUSH
2366: LD_INT 51
2368: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2369: LD_ADDR_OWVAR 41
2373: PUSH
2374: LD_INT 50
2376: PPUSH
2377: LD_INT 99
2379: PPUSH
2380: CALL_OW 12
2384: ST_TO_ADDR
// if uc_side <> 6 then
2385: LD_OWVAR 20
2389: PUSH
2390: LD_INT 6
2392: NONEQUAL
2393: IFFALSE 2403
// uc_side := 6 ;
2395: LD_ADDR_OWVAR 20
2399: PUSH
2400: LD_INT 6
2402: ST_TO_ADDR
// veh := CreateVehicle ;
2403: LD_ADDR_VAR 0 4
2407: PUSH
2408: CALL_OW 45
2412: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2413: LD_VAR 0 4
2417: PPUSH
2418: LD_INT 3
2420: PPUSH
2421: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2425: LD_VAR 0 4
2429: PPUSH
2430: LD_INT 8
2432: PPUSH
2433: LD_INT 0
2435: PPUSH
2436: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2440: LD_INT 0
2442: PPUSH
2443: LD_INT 1
2445: PPUSH
2446: LD_INT 2
2448: PPUSH
2449: CALL_OW 12
2453: PPUSH
2454: LD_VAR 0 5
2458: PPUSH
2459: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2463: CALL_OW 44
2467: PPUSH
2468: LD_VAR 0 4
2472: PPUSH
2473: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2477: LD_VAR 0 4
2481: PPUSH
2482: LD_INT 500
2484: PPUSH
2485: LD_INT 1000
2487: PPUSH
2488: CALL_OW 12
2492: PPUSH
2493: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
2497: LD_VAR 0 4
2501: PPUSH
2502: LD_INT 1
2504: PPUSH
2505: LD_INT 2
2507: PPUSH
2508: CALL_OW 12
2512: PPUSH
2513: LD_INT 2
2515: PPUSH
2516: LD_INT 10
2518: PPUSH
2519: CALL_OW 12
2523: PUSH
2524: LD_INT 10
2526: MUL
2527: PPUSH
2528: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2532: LD_ADDR_EXP 1
2536: PUSH
2537: LD_EXP 1
2541: PPUSH
2542: LD_INT 1
2544: PPUSH
2545: LD_VAR 0 4
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 2
2561: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2562: LD_VAR 0 4
2566: PPUSH
2567: LD_INT 120
2569: PPUSH
2570: LD_INT 10
2572: PPUSH
2573: CALL_OW 111
// Wait ( 0 0$02 ) ;
2577: LD_INT 70
2579: PPUSH
2580: CALL_OW 67
// end ;
2584: GO 2334
2586: POP
2587: POP
// if Rand ( 0 , 1 ) = 1 then
2588: LD_INT 0
2590: PPUSH
2591: LD_INT 1
2593: PPUSH
2594: CALL_OW 12
2598: PUSH
2599: LD_INT 1
2601: EQUAL
2602: IFFALSE 2638
// begin vc_chassis := ru_medium_tracked ;
2604: LD_ADDR_OWVAR 37
2608: PUSH
2609: LD_INT 22
2611: ST_TO_ADDR
// vc_engine := engine_combustion ;
2612: LD_ADDR_OWVAR 39
2616: PUSH
2617: LD_INT 1
2619: ST_TO_ADDR
// vc_control := control_manual ;
2620: LD_ADDR_OWVAR 38
2624: PUSH
2625: LD_INT 1
2627: ST_TO_ADDR
// vc_weapon := ru_crane ;
2628: LD_ADDR_OWVAR 40
2632: PUSH
2633: LD_INT 52
2635: ST_TO_ADDR
// end else
2636: GO 2670
// begin vc_chassis := ru_heavy_wheeled ;
2638: LD_ADDR_OWVAR 37
2642: PUSH
2643: LD_INT 23
2645: ST_TO_ADDR
// vc_engine := engine_combustion ;
2646: LD_ADDR_OWVAR 39
2650: PUSH
2651: LD_INT 1
2653: ST_TO_ADDR
// vc_control := control_manual ;
2654: LD_ADDR_OWVAR 38
2658: PUSH
2659: LD_INT 1
2661: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2662: LD_ADDR_OWVAR 40
2666: PUSH
2667: LD_INT 53
2669: ST_TO_ADDR
// end ; vc_fuel_battery := Rand ( 50 , 99 ) ;
2670: LD_ADDR_OWVAR 41
2674: PUSH
2675: LD_INT 50
2677: PPUSH
2678: LD_INT 99
2680: PPUSH
2681: CALL_OW 12
2685: ST_TO_ADDR
// if uc_side <> 6 then
2686: LD_OWVAR 20
2690: PUSH
2691: LD_INT 6
2693: NONEQUAL
2694: IFFALSE 2704
// uc_side := 6 ;
2696: LD_ADDR_OWVAR 20
2700: PUSH
2701: LD_INT 6
2703: ST_TO_ADDR
// veh := CreateVehicle ;
2704: LD_ADDR_VAR 0 4
2708: PUSH
2709: CALL_OW 45
2713: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2714: LD_VAR 0 4
2718: PPUSH
2719: LD_INT 3
2721: PPUSH
2722: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2726: LD_VAR 0 4
2730: PPUSH
2731: LD_INT 8
2733: PPUSH
2734: LD_INT 0
2736: PPUSH
2737: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2741: LD_INT 0
2743: PPUSH
2744: LD_INT 1
2746: PPUSH
2747: LD_INT 2
2749: PPUSH
2750: CALL_OW 12
2754: PPUSH
2755: LD_VAR 0 5
2759: PPUSH
2760: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2764: CALL_OW 44
2768: PPUSH
2769: LD_VAR 0 4
2773: PPUSH
2774: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2778: LD_VAR 0 4
2782: PPUSH
2783: LD_INT 500
2785: PPUSH
2786: LD_INT 1000
2788: PPUSH
2789: CALL_OW 12
2793: PPUSH
2794: CALL_OW 234
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2798: LD_ADDR_EXP 1
2802: PUSH
2803: LD_EXP 1
2807: PPUSH
2808: LD_INT 1
2810: PPUSH
2811: LD_VAR 0 4
2815: PUSH
2816: LD_INT 1
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: PPUSH
2823: CALL_OW 2
2827: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2828: LD_VAR 0 4
2832: PPUSH
2833: LD_INT 120
2835: PPUSH
2836: LD_INT 10
2838: PPUSH
2839: CALL_OW 111
// Wait ( 0 0$02 ) ;
2843: LD_INT 70
2845: PPUSH
2846: CALL_OW 67
// conv_ready := true ;
2850: LD_ADDR_EXP 18
2854: PUSH
2855: LD_INT 1
2857: ST_TO_ADDR
// end ; end ;
2858: GO 2861
2860: POP
// end ;
2861: LD_VAR 0 2
2865: RET
// export function AddEscort ( ) ; var veh , skill ; begin
2866: LD_INT 0
2868: PPUSH
2869: PPUSH
2870: PPUSH
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
2871: LD_ADDR_VAR 0 3
2875: PUSH
2876: LD_INT 5
2878: PUSH
2879: LD_INT 5
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: LIST
2889: PUSH
2890: LD_OWVAR 67
2894: ARRAY
2895: ST_TO_ADDR
// uc_side := 6 ;
2896: LD_ADDR_OWVAR 20
2900: PUSH
2901: LD_INT 6
2903: ST_TO_ADDR
// uc_nation := 3 ;
2904: LD_ADDR_OWVAR 21
2908: PUSH
2909: LD_INT 3
2911: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2912: LD_ADDR_OWVAR 37
2916: PUSH
2917: LD_INT 21
2919: ST_TO_ADDR
// vc_engine := engine_combustion ;
2920: LD_ADDR_OWVAR 39
2924: PUSH
2925: LD_INT 1
2927: ST_TO_ADDR
// vc_control := control_manual ;
2928: LD_ADDR_OWVAR 38
2932: PUSH
2933: LD_INT 1
2935: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 2 ) ] ;
2936: LD_ADDR_OWVAR 40
2940: PUSH
2941: LD_INT 44
2943: PUSH
2944: LD_INT 42
2946: PUSH
2947: EMPTY
2948: LIST
2949: LIST
2950: PUSH
2951: LD_INT 1
2953: PPUSH
2954: LD_INT 2
2956: PPUSH
2957: CALL_OW 12
2961: ARRAY
2962: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2963: LD_ADDR_OWVAR 41
2967: PUSH
2968: LD_INT 50
2970: PPUSH
2971: LD_INT 99
2973: PPUSH
2974: CALL_OW 12
2978: ST_TO_ADDR
// veh := CreateVehicle ;
2979: LD_ADDR_VAR 0 2
2983: PUSH
2984: CALL_OW 45
2988: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2989: LD_VAR 0 2
2993: PPUSH
2994: LD_INT 3
2996: PPUSH
2997: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
3001: LD_VAR 0 2
3005: PPUSH
3006: LD_INT 8
3008: PPUSH
3009: LD_INT 0
3011: PPUSH
3012: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3016: LD_INT 0
3018: PPUSH
3019: LD_INT 3
3021: PPUSH
3022: LD_VAR 0 3
3026: PPUSH
3027: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3031: CALL_OW 44
3035: PPUSH
3036: LD_VAR 0 2
3040: PPUSH
3041: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
3045: LD_VAR 0 2
3049: PPUSH
3050: LD_INT 500
3052: PPUSH
3053: LD_INT 1000
3055: PPUSH
3056: CALL_OW 12
3060: PPUSH
3061: CALL_OW 234
// escort := Insert ( escort , 1 , veh ) ;
3065: LD_ADDR_EXP 2
3069: PUSH
3070: LD_EXP 2
3074: PPUSH
3075: LD_INT 1
3077: PPUSH
3078: LD_VAR 0 2
3082: PPUSH
3083: CALL_OW 2
3087: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
3088: LD_VAR 0 2
3092: PPUSH
3093: LD_INT 120
3095: PPUSH
3096: LD_INT 10
3098: PPUSH
3099: CALL_OW 111
// end ;
3103: LD_VAR 0 1
3107: RET
// every 4 trigger conv_ready and FilterAllUnits ( [ f_side , 6 ] ) do var i , j ;
3108: LD_EXP 18
3112: PUSH
3113: LD_INT 22
3115: PUSH
3116: LD_INT 6
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: PPUSH
3123: CALL_OW 69
3127: AND
3128: IFFALSE 3861
3130: GO 3132
3132: DISABLE
3133: LD_INT 0
3135: PPUSH
3136: PPUSH
// begin enable ;
3137: ENABLE
// if conv_squad then
3138: LD_EXP 1
3142: IFFALSE 3399
// for i = conv_squad downto 1 do
3144: LD_ADDR_VAR 0 1
3148: PUSH
3149: DOUBLE
3150: LD_EXP 1
3154: INC
3155: ST_TO_ADDR
3156: LD_INT 1
3158: PUSH
3159: FOR_DOWNTO
3160: IFFALSE 3397
// begin if IsInArea ( conv_squad [ i ] [ 1 ] , conv_end ) then
3162: LD_EXP 1
3166: PUSH
3167: LD_VAR 0 1
3171: ARRAY
3172: PUSH
3173: LD_INT 1
3175: ARRAY
3176: PPUSH
3177: LD_INT 9
3179: PPUSH
3180: CALL_OW 308
3184: IFFALSE 3247
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3186: LD_ADDR_VAR 0 2
3190: PUSH
3191: LD_INT 9
3193: PPUSH
3194: LD_INT 22
3196: PUSH
3197: LD_INT 6
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: PPUSH
3204: CALL_OW 70
3208: PUSH
3209: FOR_IN
3210: IFFALSE 3223
// RemoveUnit ( j ) ;
3212: LD_VAR 0 2
3216: PPUSH
3217: CALL_OW 64
3221: GO 3209
3223: POP
3224: POP
// conv_squad := Delete ( conv_squad , i ) ;
3225: LD_ADDR_EXP 1
3229: PUSH
3230: LD_EXP 1
3234: PPUSH
3235: LD_VAR 0 1
3239: PPUSH
3240: CALL_OW 3
3244: ST_TO_ADDR
// break ;
3245: GO 3397
// end ; if IsInArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) then
3247: LD_EXP 1
3251: PUSH
3252: LD_VAR 0 1
3256: ARRAY
3257: PUSH
3258: LD_INT 1
3260: ARRAY
3261: PPUSH
3262: LD_EXP 6
3266: PUSH
3267: LD_EXP 1
3271: PUSH
3272: LD_VAR 0 1
3276: ARRAY
3277: PUSH
3278: LD_INT 2
3280: ARRAY
3281: ARRAY
3282: PPUSH
3283: CALL_OW 308
3287: IFFALSE 3333
// conv_squad := Replace2 ( conv_squad , i , 2 , conv_squad [ i ] [ 2 ] + 1 ) else
3289: LD_ADDR_EXP 1
3293: PUSH
3294: LD_EXP 1
3298: PPUSH
3299: LD_VAR 0 1
3303: PPUSH
3304: LD_INT 2
3306: PPUSH
3307: LD_EXP 1
3311: PUSH
3312: LD_VAR 0 1
3316: ARRAY
3317: PUSH
3318: LD_INT 2
3320: ARRAY
3321: PUSH
3322: LD_INT 1
3324: PLUS
3325: PPUSH
3326: CALL 10126 0 4
3330: ST_TO_ADDR
3331: GO 3395
// if not HasTask ( conv_squad [ i ] [ 1 ] ) then
3333: LD_EXP 1
3337: PUSH
3338: LD_VAR 0 1
3342: ARRAY
3343: PUSH
3344: LD_INT 1
3346: ARRAY
3347: PPUSH
3348: CALL_OW 314
3352: NOT
3353: IFFALSE 3395
// ComMoveToArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) ;
3355: LD_EXP 1
3359: PUSH
3360: LD_VAR 0 1
3364: ARRAY
3365: PUSH
3366: LD_INT 1
3368: ARRAY
3369: PPUSH
3370: LD_EXP 6
3374: PUSH
3375: LD_EXP 1
3379: PUSH
3380: LD_VAR 0 1
3384: ARRAY
3385: PUSH
3386: LD_INT 2
3388: ARRAY
3389: ARRAY
3390: PPUSH
3391: CALL_OW 113
// end ;
3395: GO 3159
3397: POP
3398: POP
// if escort then
3399: LD_EXP 2
3403: IFFALSE 3728
// for i = escort downto 1 do
3405: LD_ADDR_VAR 0 1
3409: PUSH
3410: DOUBLE
3411: LD_EXP 2
3415: INC
3416: ST_TO_ADDR
3417: LD_INT 1
3419: PUSH
3420: FOR_DOWNTO
3421: IFFALSE 3726
// begin if IsInArea ( escort [ i ] , conv_end ) then
3423: LD_EXP 2
3427: PUSH
3428: LD_VAR 0 1
3432: ARRAY
3433: PPUSH
3434: LD_INT 9
3436: PPUSH
3437: CALL_OW 308
3441: IFFALSE 3504
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3443: LD_ADDR_VAR 0 2
3447: PUSH
3448: LD_INT 9
3450: PPUSH
3451: LD_INT 22
3453: PUSH
3454: LD_INT 6
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PPUSH
3461: CALL_OW 70
3465: PUSH
3466: FOR_IN
3467: IFFALSE 3480
// RemoveUnit ( j ) ;
3469: LD_VAR 0 2
3473: PPUSH
3474: CALL_OW 64
3478: GO 3466
3480: POP
3481: POP
// escort := Delete ( escort , i ) ;
3482: LD_ADDR_EXP 2
3486: PUSH
3487: LD_EXP 2
3491: PPUSH
3492: LD_VAR 0 1
3496: PPUSH
3497: CALL_OW 3
3501: ST_TO_ADDR
// break ;
3502: GO 3726
// end ; if FindTarget ( escort [ i ] ) and GetDistUnits ( escort [ i ] , FindTarget ( escort [ i ] ) ) < 13 then
3504: LD_EXP 2
3508: PUSH
3509: LD_VAR 0 1
3513: ARRAY
3514: PPUSH
3515: CALL 10434 0 1
3519: PUSH
3520: LD_EXP 2
3524: PUSH
3525: LD_VAR 0 1
3529: ARRAY
3530: PPUSH
3531: LD_EXP 2
3535: PUSH
3536: LD_VAR 0 1
3540: ARRAY
3541: PPUSH
3542: CALL 10434 0 1
3546: PPUSH
3547: CALL_OW 296
3551: PUSH
3552: LD_INT 13
3554: LESS
3555: AND
3556: IFFALSE 3591
// ComAttackUnit ( escort [ i ] , FindTarget ( escort [ i ] ) ) else
3558: LD_EXP 2
3562: PUSH
3563: LD_VAR 0 1
3567: ARRAY
3568: PPUSH
3569: LD_EXP 2
3573: PUSH
3574: LD_VAR 0 1
3578: ARRAY
3579: PPUSH
3580: CALL 10434 0 1
3584: PPUSH
3585: CALL_OW 115
3589: GO 3724
// if conv_squad and GetDistUnitXY ( escort [ i ] , 64 , 117 ) > 35 and not HasTask ( escort [ i ] ) then
3591: LD_EXP 1
3595: PUSH
3596: LD_EXP 2
3600: PUSH
3601: LD_VAR 0 1
3605: ARRAY
3606: PPUSH
3607: LD_INT 64
3609: PPUSH
3610: LD_INT 117
3612: PPUSH
3613: CALL_OW 297
3617: PUSH
3618: LD_INT 35
3620: GREATER
3621: AND
3622: PUSH
3623: LD_EXP 2
3627: PUSH
3628: LD_VAR 0 1
3632: ARRAY
3633: PPUSH
3634: CALL_OW 314
3638: NOT
3639: AND
3640: IFFALSE 3706
// begin if GetDistUnits ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) > 6 then
3642: LD_EXP 2
3646: PUSH
3647: LD_VAR 0 1
3651: ARRAY
3652: PPUSH
3653: LD_EXP 1
3657: PUSH
3658: LD_INT 1
3660: ARRAY
3661: PUSH
3662: LD_INT 1
3664: ARRAY
3665: PPUSH
3666: CALL_OW 296
3670: PUSH
3671: LD_INT 6
3673: GREATER
3674: IFFALSE 3704
// ComMoveUnit ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) end else
3676: LD_EXP 2
3680: PUSH
3681: LD_VAR 0 1
3685: ARRAY
3686: PPUSH
3687: LD_EXP 1
3691: PUSH
3692: LD_INT 1
3694: ARRAY
3695: PUSH
3696: LD_INT 1
3698: ARRAY
3699: PPUSH
3700: CALL_OW 112
3704: GO 3724
// ComMoveToArea ( escort [ i ] , conv_end ) ;
3706: LD_EXP 2
3710: PUSH
3711: LD_VAR 0 1
3715: ARRAY
3716: PPUSH
3717: LD_INT 9
3719: PPUSH
3720: CALL_OW 113
// end ;
3724: GO 3420
3726: POP
3727: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) then
3728: LD_INT 22
3730: PUSH
3731: LD_INT 6
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PUSH
3738: LD_INT 21
3740: PUSH
3741: LD_INT 1
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 69
3756: IFFALSE 3861
// for j in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) do
3758: LD_ADDR_VAR 0 2
3762: PUSH
3763: LD_INT 22
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: LD_INT 21
3775: PUSH
3776: LD_INT 1
3778: PUSH
3779: EMPTY
3780: LIST
3781: LIST
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PPUSH
3787: CALL_OW 69
3791: PUSH
3792: FOR_IN
3793: IFFALSE 3859
// begin if not HasTask ( j ) and not IsInArea ( j , conv_end ) then
3795: LD_VAR 0 2
3799: PPUSH
3800: CALL_OW 314
3804: NOT
3805: PUSH
3806: LD_VAR 0 2
3810: PPUSH
3811: LD_INT 9
3813: PPUSH
3814: CALL_OW 308
3818: NOT
3819: AND
3820: IFFALSE 3834
// ComMoveToArea ( j , conv_end ) ;
3822: LD_VAR 0 2
3826: PPUSH
3827: LD_INT 9
3829: PPUSH
3830: CALL_OW 113
// if IsInArea ( j , conv_end ) then
3834: LD_VAR 0 2
3838: PPUSH
3839: LD_INT 9
3841: PPUSH
3842: CALL_OW 308
3846: IFFALSE 3857
// RemoveUnit ( j ) ;
3848: LD_VAR 0 2
3852: PPUSH
3853: CALL_OW 64
// end ;
3857: GO 3792
3859: POP
3860: POP
// end ;
3861: PPOPN 2
3863: END
// every 0 0$01 trigger UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do var i ;
3864: LD_EXP 2
3868: PUSH
3869: LD_EXP 1
3873: PUSH
3874: EMPTY
3875: LIST
3876: LIST
3877: PPUSH
3878: LD_INT 22
3880: PUSH
3881: LD_INT 3
3883: PUSH
3884: EMPTY
3885: LIST
3886: LIST
3887: PPUSH
3888: CALL_OW 72
3892: IFFALSE 3954
3894: GO 3896
3896: DISABLE
3897: LD_INT 0
3899: PPUSH
// begin enable ;
3900: ENABLE
// for i in UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do
3901: LD_ADDR_VAR 0 1
3905: PUSH
3906: LD_EXP 2
3910: PUSH
3911: LD_EXP 1
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PPUSH
3920: LD_INT 22
3922: PUSH
3923: LD_INT 3
3925: PUSH
3926: EMPTY
3927: LIST
3928: LIST
3929: PPUSH
3930: CALL_OW 72
3934: PUSH
3935: FOR_IN
3936: IFFALSE 3952
// SetSide ( i , 6 ) ;
3938: LD_VAR 0 1
3942: PPUSH
3943: LD_INT 6
3945: PPUSH
3946: CALL_OW 235
3950: GO 3935
3952: POP
3953: POP
// end ; end_of_file
3954: PPOPN 1
3956: END
// export Collins ; export us_alert , us_retreat , us_patrol , us_count ; export function PrepareAmerican ; var i , un , skill , towers ; begin
3957: LD_INT 0
3959: PPUSH
3960: PPUSH
3961: PPUSH
3962: PPUSH
3963: PPUSH
// uc_side := 1 ;
3964: LD_ADDR_OWVAR 20
3968: PUSH
3969: LD_INT 1
3971: ST_TO_ADDR
// uc_nation := 1 ;
3972: LD_ADDR_OWVAR 21
3976: PUSH
3977: LD_INT 1
3979: ST_TO_ADDR
// us_alert := false ;
3980: LD_ADDR_EXP 20
3984: PUSH
3985: LD_INT 0
3987: ST_TO_ADDR
// us_retreat := false ;
3988: LD_ADDR_EXP 21
3992: PUSH
3993: LD_INT 0
3995: ST_TO_ADDR
// us_patrol := false ;
3996: LD_ADDR_EXP 22
4000: PUSH
4001: LD_INT 0
4003: ST_TO_ADDR
// us_count := 0 ;
4004: LD_ADDR_EXP 23
4008: PUSH
4009: LD_INT 0
4011: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4012: LD_ADDR_VAR 0 4
4016: PUSH
4017: LD_INT 5
4019: PUSH
4020: LD_INT 6
4022: PUSH
4023: LD_INT 7
4025: PUSH
4026: EMPTY
4027: LIST
4028: LIST
4029: LIST
4030: PUSH
4031: LD_OWVAR 67
4035: ARRAY
4036: ST_TO_ADDR
// hc_class := 1 ;
4037: LD_ADDR_OWVAR 28
4041: PUSH
4042: LD_INT 1
4044: ST_TO_ADDR
// hc_sex := sex_male ;
4045: LD_ADDR_OWVAR 27
4049: PUSH
4050: LD_INT 1
4052: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
4053: LD_ADDR_OWVAR 31
4057: PUSH
4058: LD_INT 6
4060: PUSH
4061: LD_INT 3
4063: PUSH
4064: LD_INT 4
4066: PUSH
4067: LD_INT 2
4069: PUSH
4070: EMPTY
4071: LIST
4072: LIST
4073: LIST
4074: LIST
4075: ST_TO_ADDR
// hc_name := Jack Collins ;
4076: LD_ADDR_OWVAR 26
4080: PUSH
4081: LD_STRING Jack Collins
4083: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
4084: LD_ADDR_OWVAR 29
4088: PUSH
4089: LD_INT 11
4091: PUSH
4092: LD_INT 11
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: ST_TO_ADDR
// hc_gallery :=  ;
4099: LD_ADDR_OWVAR 33
4103: PUSH
4104: LD_STRING 
4106: ST_TO_ADDR
// Collins := CreateHuman ;
4107: LD_ADDR_EXP 19
4111: PUSH
4112: CALL_OW 44
4116: ST_TO_ADDR
// PlaceHumanInUnit ( Collins , us_depot ) ;
4117: LD_EXP 19
4121: PPUSH
4122: LD_INT 50
4124: PPUSH
4125: CALL_OW 52
// hc_name :=  ;
4129: LD_ADDR_OWVAR 26
4133: PUSH
4134: LD_STRING 
4136: ST_TO_ADDR
// if Difficulty > 1 then
4137: LD_OWVAR 67
4141: PUSH
4142: LD_INT 1
4144: GREATER
4145: IFFALSE 4199
// begin bc_type := b_bunker ;
4147: LD_ADDR_OWVAR 42
4151: PUSH
4152: LD_INT 32
4154: ST_TO_ADDR
// bc_level := 5 ;
4155: LD_ADDR_OWVAR 43
4159: PUSH
4160: LD_INT 5
4162: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 40 , 33 , 2 ) ;
4163: LD_INT 40
4165: PPUSH
4166: LD_INT 33
4168: PPUSH
4169: LD_INT 2
4171: PPUSH
4172: CALL_OW 47
// if Difficulty > 2 then
4176: LD_OWVAR 67
4180: PUSH
4181: LD_INT 2
4183: GREATER
4184: IFFALSE 4199
// CreateAndPlaceBuildingXYD ( 41 , 42 , 0 ) ;
4186: LD_INT 41
4188: PPUSH
4189: LD_INT 42
4191: PPUSH
4192: LD_INT 0
4194: PPUSH
4195: CALL_OW 47
// end ; PrepareHuman ( false , 2 , skill ) ;
4199: LD_INT 0
4201: PPUSH
4202: LD_INT 2
4204: PPUSH
4205: LD_VAR 0 4
4209: PPUSH
4210: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
4214: CALL_OW 44
4218: PPUSH
4219: LD_INT 50
4221: PPUSH
4222: CALL_OW 52
// PrepareHuman ( false , 3 , skill ) ;
4226: LD_INT 0
4228: PPUSH
4229: LD_INT 3
4231: PPUSH
4232: LD_VAR 0 4
4236: PPUSH
4237: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4241: CALL_OW 44
4245: PPUSH
4246: LD_INT 56
4248: PPUSH
4249: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4253: CALL_OW 44
4257: PPUSH
4258: LD_INT 56
4260: PPUSH
4261: CALL_OW 52
// PrepareHuman ( false , 4 , skill ) ;
4265: LD_INT 0
4267: PPUSH
4268: LD_INT 4
4270: PPUSH
4271: LD_VAR 0 4
4275: PPUSH
4276: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
4280: CALL_OW 44
4284: PPUSH
4285: LD_INT 63
4287: PPUSH
4288: CALL_OW 52
// PrepareHuman ( false , 1 , skill ) ;
4292: LD_INT 0
4294: PPUSH
4295: LD_INT 1
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 380
// un := CreateHuman ;
4307: LD_ADDR_VAR 0 3
4311: PUSH
4312: CALL_OW 44
4316: ST_TO_ADDR
// SetDir ( un , 4 ) ;
4317: LD_VAR 0 3
4321: PPUSH
4322: LD_INT 4
4324: PPUSH
4325: CALL_OW 233
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
4329: LD_VAR 0 3
4333: PPUSH
4334: LD_INT 22
4336: PUSH
4337: LD_INT 1
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PUSH
4344: LD_INT 30
4346: PUSH
4347: LD_INT 31
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: PUSH
4354: EMPTY
4355: LIST
4356: LIST
4357: PPUSH
4358: CALL_OW 69
4362: PUSH
4363: LD_INT 1
4365: ARRAY
4366: PPUSH
4367: CALL_OW 52
// towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) ;
4371: LD_ADDR_VAR 0 5
4375: PUSH
4376: LD_INT 22
4378: PUSH
4379: LD_INT 1
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 30
4388: PUSH
4389: LD_INT 32
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: EMPTY
4397: LIST
4398: LIST
4399: PPUSH
4400: CALL_OW 69
4404: ST_TO_ADDR
// for i in towers do
4405: LD_ADDR_VAR 0 2
4409: PUSH
4410: LD_VAR 0 5
4414: PUSH
4415: FOR_IN
4416: IFFALSE 4484
// begin PrepareHuman ( false , 1 , skill ) ;
4418: LD_INT 0
4420: PPUSH
4421: LD_INT 1
4423: PPUSH
4424: LD_VAR 0 4
4428: PPUSH
4429: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4433: CALL_OW 44
4437: PPUSH
4438: LD_VAR 0 2
4442: PPUSH
4443: CALL_OW 52
// PlaceWeaponTurret ( i , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
4447: LD_VAR 0 2
4451: PPUSH
4452: LD_INT 4
4454: PUSH
4455: LD_INT 3
4457: PUSH
4458: LD_INT 5
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_INT 1
4468: PPUSH
4469: LD_INT 3
4471: PPUSH
4472: CALL_OW 12
4476: ARRAY
4477: PPUSH
4478: CALL_OW 431
// end ;
4482: GO 4415
4484: POP
4485: POP
// PrepareHuman ( false , 1 , skill ) ;
4486: LD_INT 0
4488: PPUSH
4489: LD_INT 1
4491: PPUSH
4492: LD_VAR 0 4
4496: PPUSH
4497: CALL_OW 380
// us_patrol := CreateHuman ;
4501: LD_ADDR_EXP 22
4505: PUSH
4506: CALL_OW 44
4510: ST_TO_ADDR
// PlaceUnitXY ( us_patrol , 12 , 5 , false ) ;
4511: LD_EXP 22
4515: PPUSH
4516: LD_INT 12
4518: PPUSH
4519: LD_INT 5
4521: PPUSH
4522: LD_INT 0
4524: PPUSH
4525: CALL_OW 48
// end ;
4529: LD_VAR 0 1
4533: RET
// every 0 0$01 trigger us_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
4534: LD_EXP 23
4538: PUSH
4539: LD_INT 3
4541: PUSH
4542: LD_INT 4
4544: PUSH
4545: LD_INT 5
4547: PUSH
4548: EMPTY
4549: LIST
4550: LIST
4551: LIST
4552: PUSH
4553: LD_OWVAR 67
4557: ARRAY
4558: GREATEREQUAL
4559: IFFALSE 4584
4561: GO 4563
4563: DISABLE
// begin Say ( Collins , DPM_C2 ) ;
4564: LD_EXP 19
4568: PPUSH
4569: LD_STRING DPM_C2
4571: PPUSH
4572: CALL_OW 88
// us_retreat := true ;
4576: LD_ADDR_EXP 21
4580: PUSH
4581: LD_INT 1
4583: ST_TO_ADDR
// end ;
4584: END
// every 10 10$00 trigger not us_alert do var R ;
4585: LD_EXP 20
4589: NOT
4590: IFFALSE 4664
4592: GO 4594
4594: DISABLE
4595: LD_INT 0
4597: PPUSH
// begin uc_side := 1 ;
4598: LD_ADDR_OWVAR 20
4602: PUSH
4603: LD_INT 1
4605: ST_TO_ADDR
// uc_nation := 1 ;
4606: LD_ADDR_OWVAR 21
4610: PUSH
4611: LD_INT 1
4613: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
4614: LD_INT 0
4616: PPUSH
4617: LD_INT 1
4619: PPUSH
4620: LD_INT 0
4622: PPUSH
4623: CALL_OW 380
// R := CreateHuman ;
4627: LD_ADDR_VAR 0 1
4631: PUSH
4632: CALL_OW 44
4636: ST_TO_ADDR
// SayRadio ( R , DPM_R1 ) ;
4637: LD_VAR 0 1
4641: PPUSH
4642: LD_STRING DPM_R1
4644: PPUSH
4645: CALL_OW 94
// Wait ( 0 0$03 ) ;
4649: LD_INT 105
4651: PPUSH
4652: CALL_OW 67
// us_retreat := true ;
4656: LD_ADDR_EXP 21
4660: PUSH
4661: LD_INT 1
4663: ST_TO_ADDR
// end ;
4664: PPOPN 1
4666: END
// every 0 0$01 trigger us_alert do var i ;
4667: LD_EXP 20
4671: IFFALSE 4931
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin Say ( Collins , DPM_C1 ) ;
4679: LD_EXP 19
4683: PPUSH
4684: LD_STRING DPM_C1
4686: PPUSH
4687: CALL_OW 88
// if UnitsInside ( us_fac ) then
4691: LD_INT 56
4693: PPUSH
4694: CALL_OW 313
4698: IFFALSE 4753
// for i in UnitsInside ( us_fac ) do
4700: LD_ADDR_VAR 0 1
4704: PUSH
4705: LD_INT 56
4707: PPUSH
4708: CALL_OW 313
4712: PUSH
4713: FOR_IN
4714: IFFALSE 4751
// begin ComExitBuilding ( i ) ;
4716: LD_VAR 0 1
4720: PPUSH
4721: CALL_OW 122
// AddComEnterUnit ( i , us_arm ) ;
4725: LD_VAR 0 1
4729: PPUSH
4730: LD_INT 69
4732: PPUSH
4733: CALL_OW 180
// AddComChangeProfession ( i , 1 ) ;
4737: LD_VAR 0 1
4741: PPUSH
4742: LD_INT 1
4744: PPUSH
4745: CALL_OW 183
// end ;
4749: GO 4713
4751: POP
4752: POP
// ComExitBuilding ( Collins ) ;
4753: LD_EXP 19
4757: PPUSH
4758: CALL_OW 122
// AddComEnterUnit ( Collins , us_arm ) ;
4762: LD_EXP 19
4766: PPUSH
4767: LD_INT 69
4769: PPUSH
4770: CALL_OW 180
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] ) ;
4774: LD_INT 22
4776: PUSH
4777: LD_INT 1
4779: PUSH
4780: EMPTY
4781: LIST
4782: LIST
4783: PUSH
4784: LD_INT 25
4786: PUSH
4787: LD_INT 2
4789: PUSH
4790: EMPTY
4791: LIST
4792: LIST
4793: PUSH
4794: EMPTY
4795: LIST
4796: LIST
4797: PPUSH
4798: CALL_OW 69
4802: PUSH
4803: LD_INT 1
4805: ARRAY
4806: PPUSH
4807: CALL_OW 122
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , 67 , 52 ) ;
4811: LD_INT 22
4813: PUSH
4814: LD_INT 1
4816: PUSH
4817: EMPTY
4818: LIST
4819: LIST
4820: PUSH
4821: LD_INT 25
4823: PUSH
4824: LD_INT 2
4826: PUSH
4827: EMPTY
4828: LIST
4829: LIST
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PPUSH
4835: CALL_OW 69
4839: PUSH
4840: LD_INT 1
4842: ARRAY
4843: PPUSH
4844: LD_INT 67
4846: PPUSH
4847: LD_INT 52
4849: PPUSH
4850: CALL_OW 171
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] ) ;
4854: LD_INT 22
4856: PUSH
4857: LD_INT 1
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: PUSH
4864: LD_INT 25
4866: PUSH
4867: LD_INT 4
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PPUSH
4878: CALL_OW 69
4882: PUSH
4883: LD_INT 1
4885: ARRAY
4886: PPUSH
4887: CALL_OW 122
// AddComEnterUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] , us_arm ) ;
4891: LD_INT 22
4893: PUSH
4894: LD_INT 1
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: PUSH
4901: LD_INT 25
4903: PUSH
4904: LD_INT 4
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PPUSH
4915: CALL_OW 69
4919: PUSH
4920: LD_INT 1
4922: ARRAY
4923: PPUSH
4924: LD_INT 69
4926: PPUSH
4927: CALL_OW 180
// end ;
4931: PPOPN 1
4933: END
// every 3 3$00 trigger not us_alert and GetSide ( us_fac ) = 1 do
4934: LD_EXP 20
4938: NOT
4939: PUSH
4940: LD_INT 56
4942: PPUSH
4943: CALL_OW 255
4947: PUSH
4948: LD_INT 1
4950: EQUAL
4951: AND
4952: IFFALSE 4995
4954: GO 4956
4956: DISABLE
// begin AddComConstruct ( us_fac , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun ) ;
4957: LD_INT 56
4959: PPUSH
4960: LD_INT 2
4962: PPUSH
4963: LD_INT 1
4965: PPUSH
4966: LD_INT 1
4968: PPUSH
4969: LD_INT 4
4971: PPUSH
4972: CALL_OW 185
// AddComConstruct ( us_fac , us_medium_tracked , engine_solar , control_manual , us_double_gun ) ;
4976: LD_INT 56
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: LD_INT 2
4984: PPUSH
4985: LD_INT 1
4987: PPUSH
4988: LD_INT 5
4990: PPUSH
4991: CALL_OW 185
// end ;
4995: END
// every 0 0$01 trigger us_patrol do
4996: LD_EXP 22
5000: IFFALSE 5048
5002: GO 5004
5004: DISABLE
// SetPatrol ( us_patrol , [ 12 , 5 , 56 , 4 , 94 , 34 , 92 , 108 ] ) ;
5005: LD_EXP 22
5009: PPUSH
5010: LD_INT 12
5012: PUSH
5013: LD_INT 5
5015: PUSH
5016: LD_INT 56
5018: PUSH
5019: LD_INT 4
5021: PUSH
5022: LD_INT 94
5024: PUSH
5025: LD_INT 34
5027: PUSH
5028: LD_INT 92
5030: PUSH
5031: LD_INT 108
5033: PUSH
5034: EMPTY
5035: LIST
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: PPUSH
5044: CALL 5049 0 2
5048: END
// export function SetPatrol ( un , points ) ; var s , i , turn ; begin
5049: LD_INT 0
5051: PPUSH
5052: PPUSH
5053: PPUSH
5054: PPUSH
// s = 1 ;
5055: LD_ADDR_VAR 0 4
5059: PUSH
5060: LD_INT 1
5062: ST_TO_ADDR
// turn := true ;
5063: LD_ADDR_VAR 0 6
5067: PUSH
5068: LD_INT 1
5070: ST_TO_ADDR
// while ( un and not us_alert ) do
5071: LD_VAR 0 1
5075: PUSH
5076: LD_EXP 20
5080: NOT
5081: AND
5082: IFFALSE 5261
// begin wait ( 35 ) ;
5084: LD_INT 35
5086: PPUSH
5087: CALL_OW 67
// if not HasTask ( un ) then
5091: LD_VAR 0 1
5095: PPUSH
5096: CALL_OW 314
5100: NOT
5101: IFFALSE 5220
// begin ComMoveXY ( un , points [ s ] , points [ s + 1 ] ) ;
5103: LD_VAR 0 1
5107: PPUSH
5108: LD_VAR 0 2
5112: PUSH
5113: LD_VAR 0 4
5117: ARRAY
5118: PPUSH
5119: LD_VAR 0 2
5123: PUSH
5124: LD_VAR 0 4
5128: PUSH
5129: LD_INT 1
5131: PLUS
5132: ARRAY
5133: PPUSH
5134: CALL_OW 111
// if s + 2 > points then
5138: LD_VAR 0 4
5142: PUSH
5143: LD_INT 2
5145: PLUS
5146: PUSH
5147: LD_VAR 0 2
5151: GREATER
5152: IFFALSE 5162
// turn := false ;
5154: LD_ADDR_VAR 0 6
5158: PUSH
5159: LD_INT 0
5161: ST_TO_ADDR
// if s - 2 < 1 then
5162: LD_VAR 0 4
5166: PUSH
5167: LD_INT 2
5169: MINUS
5170: PUSH
5171: LD_INT 1
5173: LESS
5174: IFFALSE 5184
// turn := true ;
5176: LD_ADDR_VAR 0 6
5180: PUSH
5181: LD_INT 1
5183: ST_TO_ADDR
// if turn then
5184: LD_VAR 0 6
5188: IFFALSE 5206
// s := s + 2 else
5190: LD_ADDR_VAR 0 4
5194: PUSH
5195: LD_VAR 0 4
5199: PUSH
5200: LD_INT 2
5202: PLUS
5203: ST_TO_ADDR
5204: GO 5220
// s := s - 2 ;
5206: LD_ADDR_VAR 0 4
5210: PUSH
5211: LD_VAR 0 4
5215: PUSH
5216: LD_INT 2
5218: MINUS
5219: ST_TO_ADDR
// end ; if GetLives ( un ) < 1000 or See ( 3 , un ) then
5220: LD_VAR 0 1
5224: PPUSH
5225: CALL_OW 256
5229: PUSH
5230: LD_INT 1000
5232: LESS
5233: PUSH
5234: LD_INT 3
5236: PPUSH
5237: LD_VAR 0 1
5241: PPUSH
5242: CALL_OW 292
5246: OR
5247: IFFALSE 5259
// begin us_alert := true ;
5249: LD_ADDR_EXP 20
5253: PUSH
5254: LD_INT 1
5256: ST_TO_ADDR
// break ;
5257: GO 5261
// end ; end ;
5259: GO 5071
// ComEnterUnit ( un , us_arm ) ;
5261: LD_VAR 0 1
5265: PPUSH
5266: LD_INT 69
5268: PPUSH
5269: CALL_OW 120
// end ;
5273: LD_VAR 0 3
5277: RET
// every 0 0$01 trigger us_retreat do var i , point ;
5278: LD_EXP 21
5282: IFFALSE 5457
5284: GO 5286
5286: DISABLE
5287: LD_INT 0
5289: PPUSH
5290: PPUSH
// begin point := false ;
5291: LD_ADDR_VAR 0 2
5295: PUSH
5296: LD_INT 0
5298: ST_TO_ADDR
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5299: LD_INT 5
5301: PPUSH
5302: LD_INT 22
5304: PUSH
5305: LD_INT 3
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 70
5316: PUSH
5317: LD_INT 0
5319: EQUAL
5320: IFFALSE 5332
// point := us_ret1 else
5322: LD_ADDR_VAR 0 2
5326: PUSH
5327: LD_INT 3
5329: ST_TO_ADDR
5330: GO 5373
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5332: LD_INT 5
5334: PPUSH
5335: LD_INT 22
5337: PUSH
5338: LD_INT 3
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PPUSH
5345: CALL_OW 70
5349: PUSH
5350: LD_INT 0
5352: EQUAL
5353: IFFALSE 5365
// point := us_ret2 else
5355: LD_ADDR_VAR 0 2
5359: PUSH
5360: LD_INT 2
5362: ST_TO_ADDR
5363: GO 5373
// point := us_ret3 ;
5365: LD_ADDR_VAR 0 2
5369: PUSH
5370: LD_INT 4
5372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
5373: LD_ADDR_VAR 0 1
5377: PUSH
5378: LD_INT 22
5380: PUSH
5381: LD_INT 1
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: PUSH
5388: LD_INT 21
5390: PUSH
5391: LD_INT 1
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: PUSH
5398: EMPTY
5399: LIST
5400: LIST
5401: PPUSH
5402: CALL_OW 69
5406: PUSH
5407: FOR_IN
5408: IFFALSE 5455
// begin if IsInUnit ( i ) then
5410: LD_VAR 0 1
5414: PPUSH
5415: CALL_OW 310
5419: IFFALSE 5439
// begin ComExitBuilding ( i ) ;
5421: LD_VAR 0 1
5425: PPUSH
5426: CALL_OW 122
// ComExitVehicle ( i ) ;
5430: LD_VAR 0 1
5434: PPUSH
5435: CALL_OW 121
// end ; AddComMoveToArea ( i , point ) ;
5439: LD_VAR 0 1
5443: PPUSH
5444: LD_VAR 0 2
5448: PPUSH
5449: CALL_OW 173
// end ;
5453: GO 5407
5455: POP
5456: POP
// end ;
5457: PPOPN 2
5459: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) do
5460: LD_EXP 21
5464: PUSH
5465: LD_INT 3
5467: PPUSH
5468: LD_INT 22
5470: PUSH
5471: LD_INT 1
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: PPUSH
5478: CALL_OW 70
5482: AND
5483: IFFALSE 5529
5485: GO 5487
5487: DISABLE
// begin enable ;
5488: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) [ 1 ] ) ;
5489: LD_INT 3
5491: PPUSH
5492: LD_INT 22
5494: PUSH
5495: LD_INT 1
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: PPUSH
5502: CALL_OW 70
5506: PUSH
5507: LD_INT 1
5509: ARRAY
5510: PPUSH
5511: CALL_OW 64
// if medal1 then
5515: LD_EXP 3
5519: IFFALSE 5529
// medal1 := false ;
5521: LD_ADDR_EXP 3
5525: PUSH
5526: LD_INT 0
5528: ST_TO_ADDR
// end ;
5529: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) do
5530: LD_EXP 21
5534: PUSH
5535: LD_INT 2
5537: PPUSH
5538: LD_INT 22
5540: PUSH
5541: LD_INT 1
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: PPUSH
5548: CALL_OW 70
5552: AND
5553: IFFALSE 5599
5555: GO 5557
5557: DISABLE
// begin enable ;
5558: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) [ 1 ] ) ;
5559: LD_INT 2
5561: PPUSH
5562: LD_INT 22
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: EMPTY
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL_OW 70
5576: PUSH
5577: LD_INT 1
5579: ARRAY
5580: PPUSH
5581: CALL_OW 64
// if medal1 then
5585: LD_EXP 3
5589: IFFALSE 5599
// medal1 := false ;
5591: LD_ADDR_EXP 3
5595: PUSH
5596: LD_INT 0
5598: ST_TO_ADDR
// end ;
5599: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) do
5600: LD_EXP 21
5604: PUSH
5605: LD_INT 4
5607: PPUSH
5608: LD_INT 22
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PPUSH
5618: CALL_OW 70
5622: AND
5623: IFFALSE 5669
5625: GO 5627
5627: DISABLE
// begin enable ;
5628: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) [ 1 ] ) ;
5629: LD_INT 4
5631: PPUSH
5632: LD_INT 22
5634: PUSH
5635: LD_INT 1
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PPUSH
5642: CALL_OW 70
5646: PUSH
5647: LD_INT 1
5649: ARRAY
5650: PPUSH
5651: CALL_OW 64
// if medal1 then
5655: LD_EXP 3
5659: IFFALSE 5669
// medal1 := false ;
5661: LD_ADDR_EXP 3
5665: PUSH
5666: LD_INT 0
5668: ST_TO_ADDR
// end ;
5669: END
// every 0 0$03 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
5670: LD_INT 22
5672: PUSH
5673: LD_INT 1
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: PPUSH
5680: CALL_OW 69
5684: PUSH
5685: LD_INT 0
5687: EQUAL
5688: IFFALSE 5701
5690: GO 5692
5692: DISABLE
// us_retreat := false ;
5693: LD_ADDR_EXP 21
5697: PUSH
5698: LD_INT 0
5700: ST_TO_ADDR
5701: END
// export function CounterAttack ; var i , j , un , skill ; begin
5702: LD_INT 0
5704: PPUSH
5705: PPUSH
5706: PPUSH
5707: PPUSH
5708: PPUSH
// uc_side := 1 ;
5709: LD_ADDR_OWVAR 20
5713: PUSH
5714: LD_INT 1
5716: ST_TO_ADDR
// uc_nation := 1 ;
5717: LD_ADDR_OWVAR 21
5721: PUSH
5722: LD_INT 1
5724: ST_TO_ADDR
// skill := [ 4 , 5 , 5 ] [ Difficulty ] ;
5725: LD_ADDR_VAR 0 5
5729: PUSH
5730: LD_INT 4
5732: PUSH
5733: LD_INT 5
5735: PUSH
5736: LD_INT 5
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_OWVAR 67
5748: ARRAY
5749: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5750: LD_ADDR_VAR 0 2
5754: PUSH
5755: DOUBLE
5756: LD_INT 1
5758: DEC
5759: ST_TO_ADDR
5760: LD_INT 4
5762: PUSH
5763: LD_INT 5
5765: PUSH
5766: LD_INT 6
5768: PUSH
5769: EMPTY
5770: LIST
5771: LIST
5772: LIST
5773: PUSH
5774: LD_OWVAR 67
5778: ARRAY
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5981
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
5783: LD_ADDR_OWVAR 37
5787: PUSH
5788: LD_INT 2
5790: PUSH
5791: LD_INT 3
5793: PUSH
5794: LD_INT 4
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: PUSH
5802: LD_INT 1
5804: PPUSH
5805: LD_INT 3
5807: PPUSH
5808: CALL_OW 12
5812: ARRAY
5813: ST_TO_ADDR
// vc_engine := engine_combustion ;
5814: LD_ADDR_OWVAR 39
5818: PUSH
5819: LD_INT 1
5821: ST_TO_ADDR
// vc_control := control_manual ;
5822: LD_ADDR_OWVAR 38
5826: PUSH
5827: LD_INT 1
5829: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_light_gun ] [ Rand ( 1 , 3 ) ] ;
5830: LD_ADDR_OWVAR 40
5834: PUSH
5835: LD_INT 4
5837: PUSH
5838: LD_INT 5
5840: PUSH
5841: LD_INT 3
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: PUSH
5849: LD_INT 1
5851: PPUSH
5852: LD_INT 3
5854: PPUSH
5855: CALL_OW 12
5859: ARRAY
5860: ST_TO_ADDR
// vc_fuel_battery := Rand ( 88 , 99 ) ;
5861: LD_ADDR_OWVAR 41
5865: PUSH
5866: LD_INT 88
5868: PPUSH
5869: LD_INT 99
5871: PPUSH
5872: CALL_OW 12
5876: ST_TO_ADDR
// un := CreateVehicle ;
5877: LD_ADDR_VAR 0 4
5881: PUSH
5882: CALL_OW 45
5886: ST_TO_ADDR
// PlaceUnitXY ( un , 64 , 117 , false ) ;
5887: LD_VAR 0 4
5891: PPUSH
5892: LD_INT 64
5894: PPUSH
5895: LD_INT 117
5897: PPUSH
5898: LD_INT 0
5900: PPUSH
5901: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
5905: LD_INT 0
5907: PPUSH
5908: LD_INT 3
5910: PPUSH
5911: LD_VAR 0 5
5915: PPUSH
5916: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5920: CALL_OW 44
5924: PPUSH
5925: LD_VAR 0 4
5929: PPUSH
5930: CALL_OW 52
// us_force := Insert ( us_force , 1 , un ) ;
5934: LD_ADDR_EXP 12
5938: PUSH
5939: LD_EXP 12
5943: PPUSH
5944: LD_INT 1
5946: PPUSH
5947: LD_VAR 0 4
5951: PPUSH
5952: CALL_OW 2
5956: ST_TO_ADDR
// ComMoveXY ( un , 60 , 109 ) ;
5957: LD_VAR 0 4
5961: PPUSH
5962: LD_INT 60
5964: PPUSH
5965: LD_INT 109
5967: PPUSH
5968: CALL_OW 111
// Wait ( 0 0$02 ) ;
5972: LD_INT 70
5974: PPUSH
5975: CALL_OW 67
// end ;
5979: GO 5780
5981: POP
5982: POP
// RemoveSeeing ( 62 , 113 , 3 ) ;
5983: LD_INT 62
5985: PPUSH
5986: LD_INT 113
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: CALL_OW 331
// while ( FilterAllUnits ( [ f_side , 1 ] ) ) do
5996: LD_INT 22
5998: PUSH
5999: LD_INT 1
6001: PUSH
6002: EMPTY
6003: LIST
6004: LIST
6005: PPUSH
6006: CALL_OW 69
6010: IFFALSE 6211
// begin Wait ( 0 0$01 ) ;
6012: LD_INT 35
6014: PPUSH
6015: CALL_OW 67
// for i = 1 to us_force do
6019: LD_ADDR_VAR 0 2
6023: PUSH
6024: DOUBLE
6025: LD_INT 1
6027: DEC
6028: ST_TO_ADDR
6029: LD_EXP 12
6033: PUSH
6034: FOR_TO
6035: IFFALSE 6070
// ComAttackUnit ( us_force [ i ] , FindTarget ( us_force [ i ] ) ) ;
6037: LD_EXP 12
6041: PUSH
6042: LD_VAR 0 2
6046: ARRAY
6047: PPUSH
6048: LD_EXP 12
6052: PUSH
6053: LD_VAR 0 2
6057: ARRAY
6058: PPUSH
6059: CALL 10434 0 1
6063: PPUSH
6064: CALL_OW 115
6068: GO 6034
6070: POP
6071: POP
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) then
6072: LD_INT 22
6074: PUSH
6075: LD_INT 1
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: PUSH
6082: LD_INT 25
6084: PUSH
6085: LD_INT 3
6087: PUSH
6088: EMPTY
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 3
6094: PUSH
6095: LD_INT 55
6097: PUSH
6098: EMPTY
6099: LIST
6100: PUSH
6101: EMPTY
6102: LIST
6103: LIST
6104: PUSH
6105: EMPTY
6106: LIST
6107: LIST
6108: LIST
6109: PPUSH
6110: CALL_OW 69
6114: IFFALSE 6209
// for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) do
6116: LD_ADDR_VAR 0 3
6120: PUSH
6121: LD_INT 22
6123: PUSH
6124: LD_INT 1
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: LD_INT 25
6133: PUSH
6134: LD_INT 3
6136: PUSH
6137: EMPTY
6138: LIST
6139: LIST
6140: PUSH
6141: LD_INT 3
6143: PUSH
6144: LD_INT 55
6146: PUSH
6147: EMPTY
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: EMPTY
6155: LIST
6156: LIST
6157: LIST
6158: PPUSH
6159: CALL_OW 69
6163: PUSH
6164: FOR_IN
6165: IFFALSE 6207
// if not IsInArea ( j , conv_end ) then
6167: LD_VAR 0 3
6171: PPUSH
6172: LD_INT 9
6174: PPUSH
6175: CALL_OW 308
6179: NOT
6180: IFFALSE 6196
// ComMoveToArea ( j , conv_end ) else
6182: LD_VAR 0 3
6186: PPUSH
6187: LD_INT 9
6189: PPUSH
6190: CALL_OW 113
6194: GO 6205
// RemoveUnit ( j ) ;
6196: LD_VAR 0 3
6200: PPUSH
6201: CALL_OW 64
6205: GO 6164
6207: POP
6208: POP
// end ;
6209: GO 5996
// end ; end_of_file
6211: LD_VAR 0 1
6215: RET
// export function PrepareArabian ; begin
6216: LD_INT 0
6218: PPUSH
// RobertFarmer ;
6219: CALL 6240 0 0
// PrepareHovercrafts ;
6223: CALL 7114 0 0
// ar_attacks := true ;
6227: LD_ADDR_EXP 10
6231: PUSH
6232: LD_INT 1
6234: ST_TO_ADDR
// end ;
6235: LD_VAR 0 1
6239: RET
// export Farmer ; export function RobertFarmer ; begin
6240: LD_INT 0
6242: PPUSH
// uc_side := 2 ;
6243: LD_ADDR_OWVAR 20
6247: PUSH
6248: LD_INT 2
6250: ST_TO_ADDR
// uc_nation := 2 ;
6251: LD_ADDR_OWVAR 21
6255: PUSH
6256: LD_INT 2
6258: ST_TO_ADDR
// Farmer := NewCharacter ( Farmer ) ;
6259: LD_ADDR_EXP 24
6263: PUSH
6264: LD_STRING Farmer
6266: PPUSH
6267: CALL_OW 25
6271: ST_TO_ADDR
// SayRadio ( Farmer , DPM_F1 ) ;
6272: LD_EXP 24
6276: PPUSH
6277: LD_STRING DPM_F1
6279: PPUSH
6280: CALL_OW 94
// end ;
6284: LD_VAR 0 1
6288: RET
// export function PrepareAttack ( type ) ; var i , un , veh , skill ; begin
6289: LD_INT 0
6291: PPUSH
6292: PPUSH
6293: PPUSH
6294: PPUSH
6295: PPUSH
// uc_side := 2 ;
6296: LD_ADDR_OWVAR 20
6300: PUSH
6301: LD_INT 2
6303: ST_TO_ADDR
// uc_nation := 2 ;
6304: LD_ADDR_OWVAR 21
6308: PUSH
6309: LD_INT 2
6311: ST_TO_ADDR
// skill := [ 4 , 6 , 7 ] [ Difficulty ] ;
6312: LD_ADDR_VAR 0 6
6316: PUSH
6317: LD_INT 4
6319: PUSH
6320: LD_INT 6
6322: PUSH
6323: LD_INT 7
6325: PUSH
6326: EMPTY
6327: LIST
6328: LIST
6329: LIST
6330: PUSH
6331: LD_OWVAR 67
6335: ARRAY
6336: ST_TO_ADDR
// Randomize ;
6337: CALL_OW 10
// case type of 1 :
6341: LD_VAR 0 1
6345: PUSH
6346: LD_INT 1
6348: DOUBLE
6349: EQUAL
6350: IFTRUE 6354
6352: GO 6476
6354: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6355: LD_ADDR_VAR 0 3
6359: PUSH
6360: DOUBLE
6361: LD_INT 1
6363: DEC
6364: ST_TO_ADDR
6365: LD_INT 3
6367: PUSH
6368: LD_INT 4
6370: PUSH
6371: LD_INT 5
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: LIST
6378: PUSH
6379: LD_OWVAR 67
6383: ARRAY
6384: PUSH
6385: FOR_TO
6386: IFFALSE 6472
// begin PrepareHuman ( false , [ class_soldier , class_soldier , class_mortar ] [ Rand ( 1 , 3 ) ] , skill ) ;
6388: LD_INT 0
6390: PPUSH
6391: LD_INT 1
6393: PUSH
6394: LD_INT 1
6396: PUSH
6397: LD_INT 8
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 3
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: PPUSH
6417: LD_VAR 0 6
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 4
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , ar3 , false ) ;
6436: LD_VAR 0 4
6440: PPUSH
6441: LD_INT 18
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// ComMoveToArea ( un , spot3 ) ;
6451: LD_VAR 0 4
6455: PPUSH
6456: LD_INT 20
6458: PPUSH
6459: CALL_OW 113
// Wait ( 0 0$01 ) ;
6463: LD_INT 35
6465: PPUSH
6466: CALL_OW 67
// end ;
6470: GO 6385
6472: POP
6473: POP
// end ; 2 :
6474: GO 7109
6476: LD_INT 2
6478: DOUBLE
6479: EQUAL
6480: IFTRUE 6484
6482: GO 6751
6484: POP
// begin for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
6485: LD_ADDR_VAR 0 3
6489: PUSH
6490: DOUBLE
6491: LD_INT 1
6493: DEC
6494: ST_TO_ADDR
6495: LD_INT 4
6497: PUSH
6498: LD_INT 5
6500: PUSH
6501: LD_INT 5
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: PUSH
6509: LD_OWVAR 67
6513: ARRAY
6514: PUSH
6515: FOR_TO
6516: IFFALSE 6579
// begin PrepareHuman ( false , class_soldier , skill ) ;
6518: LD_INT 0
6520: PPUSH
6521: LD_INT 1
6523: PPUSH
6524: LD_VAR 0 6
6528: PPUSH
6529: CALL_OW 380
// un := CreateHuman ;
6533: LD_ADDR_VAR 0 4
6537: PUSH
6538: CALL_OW 44
6542: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6543: LD_VAR 0 4
6547: PPUSH
6548: LD_INT 17
6550: PPUSH
6551: LD_INT 0
6553: PPUSH
6554: CALL_OW 49
// ComMoveToArea ( un , spot2 ) ;
6558: LD_VAR 0 4
6562: PPUSH
6563: LD_INT 19
6565: PPUSH
6566: CALL_OW 113
// Wait ( 0 0$01 ) ;
6570: LD_INT 35
6572: PPUSH
6573: CALL_OW 67
// end ;
6577: GO 6515
6579: POP
6580: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6581: LD_ADDR_VAR 0 3
6585: PUSH
6586: DOUBLE
6587: LD_INT 1
6589: DEC
6590: ST_TO_ADDR
6591: LD_INT 2
6593: PUSH
6594: LD_INT 3
6596: PUSH
6597: LD_INT 4
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: PUSH
6605: LD_OWVAR 67
6609: ARRAY
6610: PUSH
6611: FOR_TO
6612: IFFALSE 6747
// begin vc_chassis := ar_medium_trike ;
6614: LD_ADDR_OWVAR 37
6618: PUSH
6619: LD_INT 13
6621: ST_TO_ADDR
// vc_engine := engine_combustion ;
6622: LD_ADDR_OWVAR 39
6626: PUSH
6627: LD_INT 1
6629: ST_TO_ADDR
// vc_control := control_manual ;
6630: LD_ADDR_OWVAR 38
6634: PUSH
6635: LD_INT 1
6637: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_light_gun , ar_gun ] [ Rand ( 1 , 3 ) ] ;
6638: LD_ADDR_OWVAR 40
6642: PUSH
6643: LD_INT 24
6645: PUSH
6646: LD_INT 23
6648: PUSH
6649: LD_INT 27
6651: PUSH
6652: EMPTY
6653: LIST
6654: LIST
6655: LIST
6656: PUSH
6657: LD_INT 1
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 12
6667: ARRAY
6668: ST_TO_ADDR
// veh := CreateVehicle ;
6669: LD_ADDR_VAR 0 5
6673: PUSH
6674: CALL_OW 45
6678: ST_TO_ADDR
// PlaceUnitArea ( veh , ar2 , false ) ;
6679: LD_VAR 0 5
6683: PPUSH
6684: LD_INT 17
6686: PPUSH
6687: LD_INT 0
6689: PPUSH
6690: CALL_OW 49
// PrepareHuman ( false , 1 , skill ) ;
6694: LD_INT 0
6696: PPUSH
6697: LD_INT 1
6699: PPUSH
6700: LD_VAR 0 6
6704: PPUSH
6705: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6709: CALL_OW 44
6713: PPUSH
6714: LD_VAR 0 5
6718: PPUSH
6719: CALL_OW 52
// ComMoveXY ( veh , 89 , 40 ) ;
6723: LD_VAR 0 5
6727: PPUSH
6728: LD_INT 89
6730: PPUSH
6731: LD_INT 40
6733: PPUSH
6734: CALL_OW 111
// Wait ( 0 0$02 ) ;
6738: LD_INT 70
6740: PPUSH
6741: CALL_OW 67
// end ;
6745: GO 6611
6747: POP
6748: POP
// end ; 3 :
6749: GO 7109
6751: LD_INT 3
6753: DOUBLE
6754: EQUAL
6755: IFTRUE 6759
6757: GO 7108
6759: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] + ( tick div 15 15$00 ) do
6760: LD_ADDR_VAR 0 3
6764: PUSH
6765: DOUBLE
6766: LD_INT 1
6768: DEC
6769: ST_TO_ADDR
6770: LD_INT 3
6772: PUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 5
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: PUSH
6784: LD_OWVAR 67
6788: ARRAY
6789: PUSH
6790: LD_OWVAR 1
6794: PUSH
6795: LD_INT 31500
6797: DIV
6798: PLUS
6799: PUSH
6800: FOR_TO
6801: IFFALSE 6909
// begin PrepareHuman ( false , [ class_soldier , class_mortar ] [ Rand ( 1 , 2 ) ] , skill ) ;
6803: LD_INT 0
6805: PPUSH
6806: LD_INT 1
6808: PUSH
6809: LD_INT 8
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PUSH
6816: LD_INT 1
6818: PPUSH
6819: LD_INT 2
6821: PPUSH
6822: CALL_OW 12
6826: ARRAY
6827: PPUSH
6828: LD_VAR 0 6
6832: PPUSH
6833: CALL_OW 380
// un := CreateHuman ;
6837: LD_ADDR_VAR 0 4
6841: PUSH
6842: CALL_OW 44
6846: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6847: LD_VAR 0 4
6851: PPUSH
6852: LD_INT 17
6854: PPUSH
6855: LD_INT 0
6857: PPUSH
6858: CALL_OW 49
// ar_force := Insert ( ar_force , 1 , un ) ;
6862: LD_ADDR_EXP 11
6866: PUSH
6867: LD_EXP 11
6871: PPUSH
6872: LD_INT 1
6874: PPUSH
6875: LD_VAR 0 4
6879: PPUSH
6880: CALL_OW 2
6884: ST_TO_ADDR
// ComMoveXY ( un , 17 , 9 ) ;
6885: LD_VAR 0 4
6889: PPUSH
6890: LD_INT 17
6892: PPUSH
6893: LD_INT 9
6895: PPUSH
6896: CALL_OW 111
// Wait ( 0 0$01 ) ;
6900: LD_INT 35
6902: PPUSH
6903: CALL_OW 67
// end ;
6907: GO 6800
6909: POP
6910: POP
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: DOUBLE
6917: LD_INT 1
6919: DEC
6920: ST_TO_ADDR
6921: LD_INT 4
6923: PUSH
6924: LD_INT 5
6926: PUSH
6927: LD_INT 6
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: PUSH
6935: LD_OWVAR 67
6939: ARRAY
6940: PUSH
6941: FOR_TO
6942: IFFALSE 7104
// begin vc_chassis := ar_half_tracked ;
6944: LD_ADDR_OWVAR 37
6948: PUSH
6949: LD_INT 14
6951: ST_TO_ADDR
// vc_engine := engine_combustion ;
6952: LD_ADDR_OWVAR 39
6956: PUSH
6957: LD_INT 1
6959: ST_TO_ADDR
// vc_control := control_manual ;
6960: LD_ADDR_OWVAR 38
6964: PUSH
6965: LD_INT 1
6967: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ;
6968: LD_ADDR_OWVAR 40
6972: PUSH
6973: LD_INT 25
6975: PUSH
6976: LD_INT 27
6978: PUSH
6979: LD_INT 28
6981: PUSH
6982: LD_INT 26
6984: PUSH
6985: EMPTY
6986: LIST
6987: LIST
6988: LIST
6989: LIST
6990: PUSH
6991: LD_INT 1
6993: PPUSH
6994: LD_INT 4
6996: PPUSH
6997: CALL_OW 12
7001: ARRAY
7002: ST_TO_ADDR
// veh := CreateVehicle ;
7003: LD_ADDR_VAR 0 5
7007: PUSH
7008: CALL_OW 45
7012: ST_TO_ADDR
// PlaceUnitArea ( veh , ar1 , false ) ;
7013: LD_VAR 0 5
7017: PPUSH
7018: LD_INT 16
7020: PPUSH
7021: LD_INT 0
7023: PPUSH
7024: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7028: LD_INT 0
7030: PPUSH
7031: LD_INT 3
7033: PPUSH
7034: LD_VAR 0 6
7038: PPUSH
7039: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7043: CALL_OW 44
7047: PPUSH
7048: LD_VAR 0 5
7052: PPUSH
7053: CALL_OW 52
// ar_force := Insert ( ar_force , 1 , veh ) ;
7057: LD_ADDR_EXP 11
7061: PUSH
7062: LD_EXP 11
7066: PPUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_VAR 0 5
7074: PPUSH
7075: CALL_OW 2
7079: ST_TO_ADDR
// ComMoveXY ( veh , 125 , 31 ) ;
7080: LD_VAR 0 5
7084: PPUSH
7085: LD_INT 125
7087: PPUSH
7088: LD_INT 31
7090: PPUSH
7091: CALL_OW 111
// Wait ( 0 0$02 ) ;
7095: LD_INT 70
7097: PPUSH
7098: CALL_OW 67
// end ;
7102: GO 6941
7104: POP
7105: POP
// end ; end ;
7106: GO 7109
7108: POP
// end ;
7109: LD_VAR 0 2
7113: RET
// export function PrepareHovercrafts ; var i , un , areas , skill ; begin
7114: LD_INT 0
7116: PPUSH
7117: PPUSH
7118: PPUSH
7119: PPUSH
7120: PPUSH
// areas := [ river1 , river2 ] ;
7121: LD_ADDR_VAR 0 4
7125: PUSH
7126: LD_INT 14
7128: PUSH
7129: LD_INT 15
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7136: LD_ADDR_VAR 0 5
7140: PUSH
7141: LD_INT 5
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 7
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: LIST
7154: PUSH
7155: LD_OWVAR 67
7159: ARRAY
7160: ST_TO_ADDR
// uc_side := 2 ;
7161: LD_ADDR_OWVAR 20
7165: PUSH
7166: LD_INT 2
7168: ST_TO_ADDR
// uc_nation := 2 ;
7169: LD_ADDR_OWVAR 21
7173: PUSH
7174: LD_INT 2
7176: ST_TO_ADDR
// hc_name :=  ;
7177: LD_ADDR_OWVAR 26
7181: PUSH
7182: LD_STRING 
7184: ST_TO_ADDR
// hc_gallery :=  ;
7185: LD_ADDR_OWVAR 33
7189: PUSH
7190: LD_STRING 
7192: ST_TO_ADDR
// for i = 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
7193: LD_ADDR_VAR 0 2
7197: PUSH
7198: DOUBLE
7199: LD_INT 1
7201: DEC
7202: ST_TO_ADDR
7203: LD_INT 1
7205: PUSH
7206: LD_INT 2
7208: PUSH
7209: LD_INT 2
7211: PUSH
7212: EMPTY
7213: LIST
7214: LIST
7215: LIST
7216: PUSH
7217: LD_OWVAR 67
7221: ARRAY
7222: PUSH
7223: FOR_TO
7224: IFFALSE 7362
// begin vc_chassis := ar_hovercraft ;
7226: LD_ADDR_OWVAR 37
7230: PUSH
7231: LD_INT 11
7233: ST_TO_ADDR
// vc_engine := engine_solar ;
7234: LD_ADDR_OWVAR 39
7238: PUSH
7239: LD_INT 2
7241: ST_TO_ADDR
// vc_control := control_manual ;
7242: LD_ADDR_OWVAR 38
7246: PUSH
7247: LD_INT 1
7249: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
7250: LD_ADDR_OWVAR 40
7254: PUSH
7255: LD_INT 24
7257: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7258: LD_ADDR_OWVAR 41
7262: PUSH
7263: LD_INT 100
7265: ST_TO_ADDR
// un := CreateVehicle ;
7266: LD_ADDR_VAR 0 3
7270: PUSH
7271: CALL_OW 45
7275: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ i ] , false ) ;
7276: LD_VAR 0 3
7280: PPUSH
7281: LD_VAR 0 4
7285: PUSH
7286: LD_VAR 0 2
7290: ARRAY
7291: PPUSH
7292: LD_INT 0
7294: PPUSH
7295: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7299: LD_INT 0
7301: PPUSH
7302: LD_INT 3
7304: PPUSH
7305: LD_VAR 0 5
7309: PPUSH
7310: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
7314: CALL_OW 44
7318: PPUSH
7319: LD_VAR 0 3
7323: PPUSH
7324: CALL_OW 52
// riv := Insert ( riv , 1 , [ un , i ] ) ;
7328: LD_ADDR_EXP 9
7332: PUSH
7333: LD_EXP 9
7337: PPUSH
7338: LD_INT 1
7340: PPUSH
7341: LD_VAR 0 3
7345: PUSH
7346: LD_VAR 0 2
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: PPUSH
7355: CALL_OW 2
7359: ST_TO_ADDR
// end ;
7360: GO 7223
7362: POP
7363: POP
// end ;
7364: LD_VAR 0 1
7368: RET
// every 0 0$01 trigger riv do var i , c ;
7369: LD_EXP 9
7373: IFFALSE 7808
7375: GO 7377
7377: DISABLE
7378: LD_INT 0
7380: PPUSH
7381: PPUSH
// begin enable ;
7382: ENABLE
// for i = riv downto 1 do
7383: LD_ADDR_VAR 0 1
7387: PUSH
7388: DOUBLE
7389: LD_EXP 9
7393: INC
7394: ST_TO_ADDR
7395: LD_INT 1
7397: PUSH
7398: FOR_DOWNTO
7399: IFFALSE 7806
// begin if not riv [ i ] [ 1 ] then
7401: LD_EXP 9
7405: PUSH
7406: LD_VAR 0 1
7410: ARRAY
7411: PUSH
7412: LD_INT 1
7414: ARRAY
7415: NOT
7416: IFFALSE 7438
// begin riv := Delete ( riv , 1 ) ;
7418: LD_ADDR_EXP 9
7422: PUSH
7423: LD_EXP 9
7427: PPUSH
7428: LD_INT 1
7430: PPUSH
7431: CALL_OW 3
7435: ST_TO_ADDR
// break ;
7436: GO 7806
// end ; if not HasTask ( riv [ i ] [ 1 ] ) then
7438: LD_EXP 9
7442: PUSH
7443: LD_VAR 0 1
7447: ARRAY
7448: PUSH
7449: LD_INT 1
7451: ARRAY
7452: PPUSH
7453: CALL_OW 314
7457: NOT
7458: IFFALSE 7526
// begin if riv [ i ] [ 2 ] = 1 then
7460: LD_EXP 9
7464: PUSH
7465: LD_VAR 0 1
7469: ARRAY
7470: PUSH
7471: LD_INT 2
7473: ARRAY
7474: PUSH
7475: LD_INT 1
7477: EQUAL
7478: IFFALSE 7490
// c := 2 else
7480: LD_ADDR_VAR 0 2
7484: PUSH
7485: LD_INT 2
7487: ST_TO_ADDR
7488: GO 7498
// c := 1 ;
7490: LD_ADDR_VAR 0 2
7494: PUSH
7495: LD_INT 1
7497: ST_TO_ADDR
// riv := Replace2 ( riv , i , 2 , c ) ;
7498: LD_ADDR_EXP 9
7502: PUSH
7503: LD_EXP 9
7507: PPUSH
7508: LD_VAR 0 1
7512: PPUSH
7513: LD_INT 2
7515: PPUSH
7516: LD_VAR 0 2
7520: PPUSH
7521: CALL 10126 0 4
7525: ST_TO_ADDR
// end ; if not IsInArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) then
7526: LD_EXP 9
7530: PUSH
7531: LD_VAR 0 1
7535: ARRAY
7536: PUSH
7537: LD_INT 1
7539: ARRAY
7540: PPUSH
7541: LD_INT 14
7543: PUSH
7544: LD_INT 15
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: PUSH
7551: LD_EXP 9
7555: PUSH
7556: LD_VAR 0 1
7560: ARRAY
7561: PUSH
7562: LD_INT 2
7564: ARRAY
7565: ARRAY
7566: PPUSH
7567: CALL_OW 308
7571: NOT
7572: IFFALSE 7804
// begin if GetFuel ( riv [ i ] [ 1 ] ) < 50 then
7574: LD_EXP 9
7578: PUSH
7579: LD_VAR 0 1
7583: ARRAY
7584: PUSH
7585: LD_INT 1
7587: ARRAY
7588: PPUSH
7589: CALL_OW 261
7593: PUSH
7594: LD_INT 50
7596: LESS
7597: IFFALSE 7621
// SetFuel ( riv [ i ] [ 1 ] , 67 ) ;
7599: LD_EXP 9
7603: PUSH
7604: LD_VAR 0 1
7608: ARRAY
7609: PUSH
7610: LD_INT 1
7612: ARRAY
7613: PPUSH
7614: LD_INT 67
7616: PPUSH
7617: CALL_OW 240
// if GetDistUnits ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) < 9 then
7621: LD_EXP 9
7625: PUSH
7626: LD_VAR 0 1
7630: ARRAY
7631: PUSH
7632: LD_INT 1
7634: ARRAY
7635: PPUSH
7636: LD_INT 22
7638: PUSH
7639: LD_INT 3
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PPUSH
7646: CALL_OW 69
7650: PPUSH
7651: LD_EXP 9
7655: PUSH
7656: LD_VAR 0 1
7660: ARRAY
7661: PUSH
7662: LD_INT 1
7664: ARRAY
7665: PPUSH
7666: CALL_OW 74
7670: PPUSH
7671: CALL_OW 296
7675: PUSH
7676: LD_INT 9
7678: LESS
7679: IFFALSE 7737
// ComAttackUnit ( riv [ i ] [ 1 ] , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 3 ] ) , riv [ i ] [ 1 ] ) ) else
7681: LD_EXP 9
7685: PUSH
7686: LD_VAR 0 1
7690: ARRAY
7691: PUSH
7692: LD_INT 1
7694: ARRAY
7695: PPUSH
7696: LD_INT 22
7698: PUSH
7699: LD_INT 3
7701: PUSH
7702: EMPTY
7703: LIST
7704: LIST
7705: PPUSH
7706: CALL_OW 69
7710: PPUSH
7711: LD_EXP 9
7715: PUSH
7716: LD_VAR 0 1
7720: ARRAY
7721: PUSH
7722: LD_INT 1
7724: ARRAY
7725: PPUSH
7726: CALL_OW 74
7730: PPUSH
7731: CALL_OW 115
7735: GO 7804
// begin ComMoveToArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) ;
7737: LD_EXP 9
7741: PUSH
7742: LD_VAR 0 1
7746: ARRAY
7747: PUSH
7748: LD_INT 1
7750: ARRAY
7751: PPUSH
7752: LD_INT 14
7754: PUSH
7755: LD_INT 15
7757: PUSH
7758: EMPTY
7759: LIST
7760: LIST
7761: PUSH
7762: LD_EXP 9
7766: PUSH
7767: LD_VAR 0 1
7771: ARRAY
7772: PUSH
7773: LD_INT 2
7775: ARRAY
7776: ARRAY
7777: PPUSH
7778: CALL_OW 113
// AddComWait ( riv [ i ] [ 1 ] , 0 0$10 ) ;
7782: LD_EXP 9
7786: PUSH
7787: LD_VAR 0 1
7791: ARRAY
7792: PUSH
7793: LD_INT 1
7795: ARRAY
7796: PPUSH
7797: LD_INT 350
7799: PPUSH
7800: CALL_OW 202
// end ; end ; end ;
7804: GO 7398
7806: POP
7807: POP
// end ;
7808: PPOPN 2
7810: END
// every 10 10$00 trigger convoy_start do var i , un ;
7811: LD_EXP 7
7815: IFFALSE 7936
7817: GO 7819
7819: DISABLE
7820: LD_INT 0
7822: PPUSH
7823: PPUSH
// begin enable ;
7824: ENABLE
// for i = 1 to 2 do
7825: LD_ADDR_VAR 0 1
7829: PUSH
7830: DOUBLE
7831: LD_INT 1
7833: DEC
7834: ST_TO_ADDR
7835: LD_INT 2
7837: PUSH
7838: FOR_TO
7839: IFFALSE 7934
// begin uc_side := 2 ;
7841: LD_ADDR_OWVAR 20
7845: PUSH
7846: LD_INT 2
7848: ST_TO_ADDR
// uc_nation := 2 ;
7849: LD_ADDR_OWVAR 21
7853: PUSH
7854: LD_INT 2
7856: ST_TO_ADDR
// PrepareHuman ( false , 1 , 4 ) ;
7857: LD_INT 0
7859: PPUSH
7860: LD_INT 1
7862: PPUSH
7863: LD_INT 4
7865: PPUSH
7866: CALL_OW 380
// un := CreateHuman ;
7870: LD_ADDR_VAR 0 2
7874: PUSH
7875: CALL_OW 44
7879: ST_TO_ADDR
// PlaceUnitXY ( un , 10 , 2 , false ) ;
7880: LD_VAR 0 2
7884: PPUSH
7885: LD_INT 10
7887: PPUSH
7888: LD_INT 2
7890: PPUSH
7891: LD_INT 0
7893: PPUSH
7894: CALL_OW 48
// ComMoveXY ( un , 24 , 36 ) ;
7898: LD_VAR 0 2
7902: PPUSH
7903: LD_INT 24
7905: PPUSH
7906: LD_INT 36
7908: PPUSH
7909: CALL_OW 111
// AddComMoveToArea ( un , conv_end ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: LD_INT 9
7920: PPUSH
7921: CALL_OW 173
// Wait ( 0 0$02 ) ;
7925: LD_INT 70
7927: PPUSH
7928: CALL_OW 67
// end ;
7932: GO 7838
7934: POP
7935: POP
// end ;
7936: PPOPN 2
7938: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , rest ;
7939: LD_INT 22
7941: PUSH
7942: LD_INT 2
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PPUSH
7949: CALL_OW 69
7953: IFFALSE 8264
7955: GO 7957
7957: DISABLE
7958: LD_INT 0
7960: PPUSH
7961: PPUSH
// begin enable ;
7962: ENABLE
// rest := FilterAllUnits ( [ f_side , 2 ] ) diff ar_force ;
7963: LD_ADDR_VAR 0 2
7967: PUSH
7968: LD_INT 22
7970: PUSH
7971: LD_INT 2
7973: PUSH
7974: EMPTY
7975: LIST
7976: LIST
7977: PPUSH
7978: CALL_OW 69
7982: PUSH
7983: LD_EXP 11
7987: DIFF
7988: ST_TO_ADDR
// if rest then
7989: LD_VAR 0 2
7993: IFFALSE 8065
// for i in rest do
7995: LD_ADDR_VAR 0 1
7999: PUSH
8000: LD_VAR 0 2
8004: PUSH
8005: FOR_IN
8006: IFFALSE 8063
// if GetClass ( i ) = 3 then
8008: LD_VAR 0 1
8012: PPUSH
8013: CALL_OW 257
8017: PUSH
8018: LD_INT 3
8020: EQUAL
8021: IFFALSE 8061
// begin if not IsInArea ( i , ar2 ) then
8023: LD_VAR 0 1
8027: PPUSH
8028: LD_INT 17
8030: PPUSH
8031: CALL_OW 308
8035: NOT
8036: IFFALSE 8052
// ComMoveToArea ( i , ar2 ) else
8038: LD_VAR 0 1
8042: PPUSH
8043: LD_INT 17
8045: PPUSH
8046: CALL_OW 113
8050: GO 8061
// RemoveUnit ( i ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: CALL_OW 64
// end ;
8061: GO 8005
8063: POP
8064: POP
// if ar_force then
8065: LD_EXP 11
8069: IFFALSE 8264
// for i in ar_force do
8071: LD_ADDR_VAR 0 1
8075: PUSH
8076: LD_EXP 11
8080: PUSH
8081: FOR_IN
8082: IFFALSE 8262
// begin if GetClass ( i ) = class_soldier then
8084: LD_VAR 0 1
8088: PPUSH
8089: CALL_OW 257
8093: PUSH
8094: LD_INT 1
8096: EQUAL
8097: IFFALSE 8189
// if FindTarget ( i ) in FilterAllUnits ( [ f_type , unit_building ] ) then
8099: LD_VAR 0 1
8103: PPUSH
8104: CALL 10434 0 1
8108: PUSH
8109: LD_INT 21
8111: PUSH
8112: LD_INT 3
8114: PUSH
8115: EMPTY
8116: LIST
8117: LIST
8118: PPUSH
8119: CALL_OW 69
8123: IN
8124: IFFALSE 8170
// ComPlaceDelayedCharge ( i , GetX ( FindTarget ( i ) ) , GetY ( FindTarget ( i ) ) , 0 ) else
8126: LD_VAR 0 1
8130: PPUSH
8131: LD_VAR 0 1
8135: PPUSH
8136: CALL 10434 0 1
8140: PPUSH
8141: CALL_OW 250
8145: PPUSH
8146: LD_VAR 0 1
8150: PPUSH
8151: CALL 10434 0 1
8155: PPUSH
8156: CALL_OW 251
8160: PPUSH
8161: LD_INT 0
8163: PPUSH
8164: CALL_OW 132
8168: GO 8189
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8170: LD_VAR 0 1
8174: PPUSH
8175: LD_VAR 0 1
8179: PPUSH
8180: CALL 10434 0 1
8184: PPUSH
8185: CALL_OW 115
// if not GetClass ( i ) = 1 then
8189: LD_VAR 0 1
8193: PPUSH
8194: CALL_OW 257
8198: PUSH
8199: LD_INT 1
8201: EQUAL
8202: NOT
8203: IFFALSE 8224
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8205: LD_VAR 0 1
8209: PPUSH
8210: LD_VAR 0 1
8214: PPUSH
8215: CALL 10434 0 1
8219: PPUSH
8220: CALL_OW 115
// if GetDistUnitXY ( i , 65 , 118 ) < 40 then
8224: LD_VAR 0 1
8228: PPUSH
8229: LD_INT 65
8231: PPUSH
8232: LD_INT 118
8234: PPUSH
8235: CALL_OW 297
8239: PUSH
8240: LD_INT 40
8242: LESS
8243: IFFALSE 8260
// ComMoveXY ( i , 65 , 118 ) ;
8245: LD_VAR 0 1
8249: PPUSH
8250: LD_INT 65
8252: PPUSH
8253: LD_INT 118
8255: PPUSH
8256: CALL_OW 111
// end ;
8260: GO 8081
8262: POP
8263: POP
// end ;
8264: PPOPN 2
8266: END
// every 0 0$01 trigger FilterUnitsInArea ( conv_end , [ f_side , 2 ] ) do
8267: LD_INT 9
8269: PPUSH
8270: LD_INT 22
8272: PUSH
8273: LD_INT 2
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: PPUSH
8280: CALL_OW 70
8284: IFFALSE 8297
8286: GO 8288
8288: DISABLE
// medal2 := false ; end_of_file
8289: LD_ADDR_EXP 4
8293: PUSH
8294: LD_INT 0
8296: ST_TO_ADDR
8297: END
// export function Action ; begin
8298: LD_INT 0
8300: PPUSH
// Difficulty := GetMultiplayerSetting ( 0 ) ;
8301: LD_ADDR_OWVAR 67
8305: PUSH
8306: LD_INT 0
8308: PPUSH
8309: CALL_OW 426
8313: ST_TO_ADDR
// case Query ( info ) of 1 :
8314: LD_STRING info
8316: PPUSH
8317: CALL_OW 97
8321: PUSH
8322: LD_INT 1
8324: DOUBLE
8325: EQUAL
8326: IFTRUE 8330
8328: GO 8333
8330: POP
// ; end ;
8331: GO 8334
8333: POP
// ChangeMissionObjectives ( PM_1 ) ;
8334: LD_STRING PM_1
8336: PPUSH
8337: CALL_OW 337
// SaveForQuickRestart ;
8341: CALL_OW 22
// end ;
8345: LD_VAR 0 1
8349: RET
// every 0 0$01 trigger GetSide ( us_depot ) = 3 do
8350: LD_INT 50
8352: PPUSH
8353: CALL_OW 255
8357: PUSH
8358: LD_INT 3
8360: EQUAL
8361: IFFALSE 8642
8363: GO 8365
8365: DISABLE
// begin Say ( Stolypin , DPM_S1 ) ;
8366: LD_EXP 15
8370: PPUSH
8371: LD_STRING DPM_S1
8373: PPUSH
8374: CALL_OW 88
// SayRadio ( Popov , DPM_P1 ) ;
8378: LD_EXP 16
8382: PPUSH
8383: LD_STRING DPM_P1
8385: PPUSH
8386: CALL_OW 94
// Say ( Stolypin , DPM_S2 ) ;
8390: LD_EXP 15
8394: PPUSH
8395: LD_STRING DPM_S2
8397: PPUSH
8398: CALL_OW 88
// SaveForQuickRestart ;
8402: CALL_OW 22
// ChangeMissionObjectives ( PM_2 ) ;
8406: LD_STRING PM_2
8408: PPUSH
8409: CALL_OW 337
// Wait ( 2 2$30 ) ;
8413: LD_INT 5250
8415: PPUSH
8416: CALL_OW 67
// CenterOnXY ( 117 , 4 ) ;
8420: LD_INT 117
8422: PPUSH
8423: LD_INT 4
8425: PPUSH
8426: CALL_OW 84
// Convoy ( 1 ) ;
8430: LD_INT 1
8432: PPUSH
8433: CALL 883 0 1
// Wait ( 0 0$30 ) ;
8437: LD_INT 1050
8439: PPUSH
8440: CALL_OW 67
// Convoy ( 2 ) ;
8444: LD_INT 2
8446: PPUSH
8447: CALL 883 0 1
// Wait ( 1 1$30 ) ;
8451: LD_INT 3150
8453: PPUSH
8454: CALL_OW 67
// Convoy ( 3 ) ;
8458: LD_INT 3
8460: PPUSH
8461: CALL 883 0 1
// Wait ( 5 5$00 ) ;
8465: LD_INT 10500
8467: PPUSH
8468: CALL_OW 67
// convoy_start := true ;
8472: LD_ADDR_EXP 7
8476: PUSH
8477: LD_INT 1
8479: ST_TO_ADDR
// PrepareArabian ;
8480: CALL 6216 0 0
// PrepareAttack ( 1 ) ;
8484: LD_INT 1
8486: PPUSH
8487: CALL 6289 0 1
// while ( convoy_start ) do
8491: LD_EXP 7
8495: IFFALSE 8642
// begin Wait ( Rand ( 2 2$00 , 4 4$00 ) ) ;
8497: LD_INT 4200
8499: PPUSH
8500: LD_INT 8400
8502: PPUSH
8503: CALL_OW 12
8507: PPUSH
8508: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) < 20 then
8512: LD_INT 22
8514: PUSH
8515: LD_INT 2
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PPUSH
8522: CALL_OW 69
8526: PUSH
8527: LD_INT 20
8529: LESS
8530: IFFALSE 8547
// PrepareAttack ( Rand ( 1 , 2 ) ) ;
8532: LD_INT 1
8534: PPUSH
8535: LD_INT 2
8537: PPUSH
8538: CALL_OW 12
8542: PPUSH
8543: CALL 6289 0 1
// Convoy ( Rand ( 1 , 5 ) ) ;
8547: LD_INT 1
8549: PPUSH
8550: LD_INT 5
8552: PPUSH
8553: CALL_OW 12
8557: PPUSH
8558: CALL 883 0 1
// conv_counter := conv_counter + 1 ;
8562: LD_ADDR_EXP 13
8566: PUSH
8567: LD_EXP 13
8571: PUSH
8572: LD_INT 1
8574: PLUS
8575: ST_TO_ADDR
// if conv_counter mod [ 5 , 4 , 3 ] [ Difficulty ] = 0 then
8576: LD_EXP 13
8580: PUSH
8581: LD_INT 5
8583: PUSH
8584: LD_INT 4
8586: PUSH
8587: LD_INT 3
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: LIST
8594: PUSH
8595: LD_OWVAR 67
8599: ARRAY
8600: MOD
8601: PUSH
8602: LD_INT 0
8604: EQUAL
8605: IFFALSE 8640
// begin Wait ( 1 1$20 ) ;
8607: LD_INT 2800
8609: PPUSH
8610: CALL_OW 67
// SayRadio ( Farmer , DPM_F2 ) ;
8614: LD_EXP 24
8618: PPUSH
8619: LD_STRING DPM_F2
8621: PPUSH
8622: CALL_OW 94
// PrepareAttack ( 3 ) ;
8626: LD_INT 3
8628: PPUSH
8629: CALL 6289 0 1
// Wait ( 4 4$00 ) ;
8633: LD_INT 8400
8635: PPUSH
8636: CALL_OW 67
// end ; end ;
8640: GO 8491
// end ;
8642: END
// every 1 1$30 trigger conv_counter mod 3 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8643: LD_EXP 13
8647: PUSH
8648: LD_INT 3
8650: MOD
8651: PUSH
8652: LD_INT 0
8654: EQUAL
8655: PUSH
8656: LD_INT 22
8658: PUSH
8659: LD_INT 2
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PPUSH
8666: CALL_OW 69
8670: PUSH
8671: LD_INT 0
8673: EQUAL
8674: AND
8675: IFFALSE 8692
8677: GO 8679
8679: DISABLE
// SayRadio ( Farmer , DPM_F3 ) ;
8680: LD_EXP 24
8684: PPUSH
8685: LD_STRING DPM_F3
8687: PPUSH
8688: CALL_OW 94
8692: END
// every 1 1$30 trigger conv_counter mod 5 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8693: LD_EXP 13
8697: PUSH
8698: LD_INT 5
8700: MOD
8701: PUSH
8702: LD_INT 0
8704: EQUAL
8705: PUSH
8706: LD_INT 22
8708: PUSH
8709: LD_INT 2
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: PPUSH
8716: CALL_OW 69
8720: PUSH
8721: LD_INT 0
8723: EQUAL
8724: AND
8725: IFFALSE 8742
8727: GO 8729
8729: DISABLE
// SayRadio ( Farmer , DPM_F4 ) ;
8730: LD_EXP 24
8734: PPUSH
8735: LD_STRING DPM_F4
8737: PPUSH
8738: CALL_OW 94
8742: END
// every 0 0$10 trigger conv_counter >= 8 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
8743: LD_EXP 13
8747: PUSH
8748: LD_INT 8
8750: GREATEREQUAL
8751: PUSH
8752: LD_INT 22
8754: PUSH
8755: LD_INT 6
8757: PUSH
8758: EMPTY
8759: LIST
8760: LIST
8761: PPUSH
8762: CALL_OW 69
8766: PUSH
8767: LD_INT 0
8769: EQUAL
8770: AND
8771: IFFALSE 8870
8773: GO 8775
8775: DISABLE
// begin SayRadio ( Popov , DPM_PEnd ) ;
8776: LD_EXP 16
8780: PPUSH
8781: LD_STRING DPM_PEnd
8783: PPUSH
8784: CALL_OW 94
// AddMedal ( med1 , medal1 ) ;
8788: LD_STRING med1
8790: PPUSH
8791: LD_EXP 3
8795: PPUSH
8796: CALL_OW 101
// AddMedal ( med2 , medal2 ) ;
8800: LD_STRING med2
8802: PPUSH
8803: LD_EXP 4
8807: PPUSH
8808: CALL_OW 101
// if dest_counter >= [ 15 , 10 , 7 ] [ Difficulty ] then
8812: LD_EXP 8
8816: PUSH
8817: LD_INT 15
8819: PUSH
8820: LD_INT 10
8822: PUSH
8823: LD_INT 7
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: PUSH
8831: LD_OWVAR 67
8835: ARRAY
8836: GREATEREQUAL
8837: IFFALSE 8847
// medal3 := false ;
8839: LD_ADDR_EXP 5
8843: PUSH
8844: LD_INT 0
8846: ST_TO_ADDR
// AddMedal ( med3 , medal3 ) ;
8847: LD_STRING med3
8849: PPUSH
8850: LD_EXP 5
8854: PPUSH
8855: CALL_OW 101
// GiveMedals ( MAIN ) ;
8859: LD_STRING MAIN
8861: PPUSH
8862: CALL_OW 102
// YouWin ;
8866: CALL_OW 103
// end ;
8870: END
// every 4 4$00 trigger convoy_start do var i ;
8871: LD_EXP 7
8875: IFFALSE 9233
8877: GO 8879
8879: DISABLE
8880: LD_INT 0
8882: PPUSH
// begin SayRadio ( Popov , DPM_PHelp ) ;
8883: LD_EXP 16
8887: PPUSH
8888: LD_STRING DPM_PHelp
8890: PPUSH
8891: CALL_OW 94
// Wait ( 0 0$30 ) ;
8895: LD_INT 1050
8897: PPUSH
8898: CALL_OW 67
// Randomize ;
8902: CALL_OW 10
// uc_side := 3 ;
8906: LD_ADDR_OWVAR 20
8910: PUSH
8911: LD_INT 3
8913: ST_TO_ADDR
// uc_nation := 3 ;
8914: LD_ADDR_OWVAR 21
8918: PUSH
8919: LD_INT 3
8921: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ Difficulty ] do
8922: LD_ADDR_VAR 0 1
8926: PUSH
8927: DOUBLE
8928: LD_INT 1
8930: DEC
8931: ST_TO_ADDR
8932: LD_INT 5
8934: PUSH
8935: LD_INT 4
8937: PUSH
8938: LD_INT 3
8940: PUSH
8941: EMPTY
8942: LIST
8943: LIST
8944: LIST
8945: PUSH
8946: LD_OWVAR 67
8950: ARRAY
8951: PUSH
8952: FOR_TO
8953: IFFALSE 8993
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , 5 ) ;
8955: LD_INT 0
8957: PPUSH
8958: LD_INT 1
8960: PPUSH
8961: LD_INT 3
8963: PPUSH
8964: CALL_OW 12
8968: PPUSH
8969: LD_INT 5
8971: PPUSH
8972: CALL_OW 380
// PlaceUnitArea ( CreateHuman , rus_start , false ) ;
8976: CALL_OW 44
8980: PPUSH
8981: LD_INT 1
8983: PPUSH
8984: LD_INT 0
8986: PPUSH
8987: CALL_OW 49
// end ;
8991: GO 8952
8993: POP
8994: POP
// vc_chassis := ru_heavy_wheeled ;
8995: LD_ADDR_OWVAR 37
8999: PUSH
9000: LD_INT 23
9002: ST_TO_ADDR
// vc_engine := engine_combustion ;
9003: LD_ADDR_OWVAR 39
9007: PUSH
9008: LD_INT 1
9010: ST_TO_ADDR
// vc_control := control_manual ;
9011: LD_ADDR_OWVAR 38
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// vc_weapon := 89 ;
9019: LD_ADDR_OWVAR 40
9023: PUSH
9024: LD_INT 89
9026: ST_TO_ADDR
// vc_fuel_battery := 88 ;
9027: LD_ADDR_OWVAR 41
9031: PUSH
9032: LD_INT 88
9034: ST_TO_ADDR
// i := CreateVehicle ;
9035: LD_ADDR_VAR 0 1
9039: PUSH
9040: CALL_OW 45
9044: ST_TO_ADDR
// SetDir ( i , 5 ) ;
9045: LD_VAR 0 1
9049: PPUSH
9050: LD_INT 5
9052: PPUSH
9053: CALL_OW 233
// PlaceUnitXY ( i , 63 , 115 , false ) ;
9057: LD_VAR 0 1
9061: PPUSH
9062: LD_INT 63
9064: PPUSH
9065: LD_INT 115
9067: PPUSH
9068: LD_INT 0
9070: PPUSH
9071: CALL_OW 48
// SetCargo ( i , mat_cans , 200 ) ;
9075: LD_VAR 0 1
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 200
9085: PPUSH
9086: CALL_OW 290
// PrepareHuman ( false , 3 , 5 ) ;
9090: LD_INT 0
9092: PPUSH
9093: LD_INT 3
9095: PPUSH
9096: LD_INT 5
9098: PPUSH
9099: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9103: CALL_OW 44
9107: PPUSH
9108: LD_VAR 0 1
9112: PPUSH
9113: CALL_OW 52
// DialogueOn ;
9117: CALL_OW 6
// CenterNowOnXY ( 169 , 115 ) ;
9121: LD_INT 169
9123: PPUSH
9124: LD_INT 115
9126: PPUSH
9127: CALL_OW 86
// DWait ( 0 0$01 ) ;
9131: LD_INT 35
9133: PPUSH
9134: CALL_OW 68
// CenterNowOnXY ( 63 , 115 ) ;
9138: LD_INT 63
9140: PPUSH
9141: LD_INT 115
9143: PPUSH
9144: CALL_OW 86
// DWait ( 0 0$01 ) ;
9148: LD_INT 35
9150: PPUSH
9151: CALL_OW 68
// DialogueOff ;
9155: CALL_OW 7
// ComMoveXY ( i , 57 , 53 ) ;
9159: LD_VAR 0 1
9163: PPUSH
9164: LD_INT 57
9166: PPUSH
9167: LD_INT 53
9169: PPUSH
9170: CALL_OW 111
// Wait ( Rand ( 3 3$00 , 7 7$00 ) ) ;
9174: LD_INT 6300
9176: PPUSH
9177: LD_INT 14700
9179: PPUSH
9180: CALL_OW 12
9184: PPUSH
9185: CALL_OW 67
// PlaceUnitXY ( Saseda , 86 , 112 , false ) ;
9189: LD_EXP 17
9193: PPUSH
9194: LD_INT 86
9196: PPUSH
9197: LD_INT 112
9199: PPUSH
9200: LD_INT 0
9202: PPUSH
9203: CALL_OW 48
// Wait ( 0 0$0.3 ) ;
9207: LD_INT 10
9209: PPUSH
9210: CALL_OW 67
// SayRadio ( Saseda , DPM_Sa1 ) ;
9214: LD_EXP 17
9218: PPUSH
9219: LD_STRING DPM_Sa1
9221: PPUSH
9222: CALL_OW 94
// ChangeMissionObjectives ( PM_3 ) ;
9226: LD_STRING PM_3
9228: PPUSH
9229: CALL_OW 337
// end ;
9233: PPOPN 1
9235: END
// every 0 0$01 trigger See ( 3 , Saseda ) do
9236: LD_INT 3
9238: PPUSH
9239: LD_EXP 17
9243: PPUSH
9244: CALL_OW 292
9248: IFFALSE 9297
9250: GO 9252
9252: DISABLE
// begin Say ( Saseda , DPM_Sa2 ) ;
9253: LD_EXP 17
9257: PPUSH
9258: LD_STRING DPM_Sa2
9260: PPUSH
9261: CALL_OW 88
// ChangeMissionObjectives ( PM_4 ) ;
9265: LD_STRING PM_4
9267: PPUSH
9268: CALL_OW 337
// SetTech ( tech_rocket , 3 , state_enabled ) ;
9272: LD_INT 40
9274: PPUSH
9275: LD_INT 3
9277: PPUSH
9278: LD_INT 1
9280: PPUSH
9281: CALL_OW 322
// SetSide ( Saseda , 3 ) ;
9285: LD_EXP 17
9289: PPUSH
9290: LD_INT 3
9292: PPUSH
9293: CALL_OW 235
// end ;
9297: END
// every 16 16$00 trigger not medal1 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
9298: LD_EXP 3
9302: NOT
9303: PUSH
9304: LD_INT 22
9306: PUSH
9307: LD_INT 6
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: PPUSH
9314: CALL_OW 69
9318: PUSH
9319: LD_INT 0
9321: EQUAL
9322: AND
9323: IFFALSE 9370
9325: GO 9327
9327: DISABLE
// begin Say ( Stolypin , DPM_S3 ) ;
9328: LD_EXP 15
9332: PPUSH
9333: LD_STRING DPM_S3
9335: PPUSH
9336: CALL_OW 88
// PlaceSeeing ( 62 , 113 , 3 , 10 ) ;
9340: LD_INT 62
9342: PPUSH
9343: LD_INT 113
9345: PPUSH
9346: LD_INT 3
9348: PPUSH
9349: LD_INT 10
9351: PPUSH
9352: CALL_OW 330
// CenterOnXY ( 62 , 113 ) ;
9356: LD_INT 62
9358: PPUSH
9359: LD_INT 113
9361: PPUSH
9362: CALL_OW 84
// CounterAttack ;
9366: CALL 5702 0 0
// end ; end_of_file
9370: END
// on LeaveBuilding ( b , h ) do begin if GetSide ( b ) = 1 then
9371: LD_VAR 0 1
9375: PPUSH
9376: CALL_OW 255
9380: PUSH
9381: LD_INT 1
9383: EQUAL
9384: IFFALSE 9420
// if not us_retreat then
9386: LD_EXP 21
9390: NOT
9391: IFFALSE 9420
// if GetClass ( h ) = 1 then
9393: LD_VAR 0 2
9397: PPUSH
9398: CALL_OW 257
9402: PUSH
9403: LD_INT 1
9405: EQUAL
9406: IFFALSE 9420
// ComEnterUnit ( h , us_arm ) ;
9408: LD_VAR 0 2
9412: PPUSH
9413: LD_INT 69
9415: PPUSH
9416: CALL_OW 120
// end ;
9420: PPOPN 2
9422: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 1 then
9423: LD_VAR 0 1
9427: PPUSH
9428: CALL_OW 255
9432: PUSH
9433: LD_INT 1
9435: EQUAL
9436: IFFALSE 9452
// us_count := us_count + 1 ;
9438: LD_ADDR_EXP 23
9442: PUSH
9443: LD_EXP 23
9447: PUSH
9448: LD_INT 1
9450: PLUS
9451: ST_TO_ADDR
// if un in us_force then
9452: LD_VAR 0 1
9456: PUSH
9457: LD_EXP 12
9461: IN
9462: IFFALSE 9480
// us_force := us_force diff un ;
9464: LD_ADDR_EXP 12
9468: PUSH
9469: LD_EXP 12
9473: PUSH
9474: LD_VAR 0 1
9478: DIFF
9479: ST_TO_ADDR
// if un in ar_force then
9480: LD_VAR 0 1
9484: PUSH
9485: LD_EXP 11
9489: IN
9490: IFFALSE 9508
// ar_force := ar_force diff un ;
9492: LD_ADDR_EXP 11
9496: PUSH
9497: LD_EXP 11
9501: PUSH
9502: LD_VAR 0 1
9506: DIFF
9507: ST_TO_ADDR
// if un = Stolypin then
9508: LD_VAR 0 1
9512: PUSH
9513: LD_EXP 15
9517: EQUAL
9518: IFFALSE 9527
// YouLost ( dead ) ;
9520: LD_STRING dead
9522: PPUSH
9523: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) then
9527: LD_VAR 0 1
9531: PUSH
9532: LD_INT 22
9534: PUSH
9535: LD_INT 1
9537: PUSH
9538: EMPTY
9539: LIST
9540: LIST
9541: PUSH
9542: LD_INT 30
9544: PUSH
9545: LD_INT 0
9547: PUSH
9548: EMPTY
9549: LIST
9550: LIST
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: PPUSH
9556: CALL_OW 69
9560: IN
9561: IFFALSE 9570
// YouLost ( depot ) ;
9563: LD_STRING depot
9565: PPUSH
9566: CALL_OW 104
// if GetSide ( un ) = 6 then
9570: LD_VAR 0 1
9574: PPUSH
9575: CALL_OW 255
9579: PUSH
9580: LD_INT 6
9582: EQUAL
9583: IFFALSE 9599
// dest_counter := dest_counter + 1 ;
9585: LD_ADDR_EXP 8
9589: PUSH
9590: LD_EXP 8
9594: PUSH
9595: LD_INT 1
9597: PLUS
9598: ST_TO_ADDR
// end ;
9599: PPOPN 1
9601: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 1 then
9602: LD_VAR 0 1
9606: PPUSH
9607: CALL_OW 255
9611: PUSH
9612: LD_INT 1
9614: EQUAL
9615: IFFALSE 9632
// ComMoveXY ( un , 57 , 52 ) ;
9617: LD_VAR 0 1
9621: PPUSH
9622: LD_INT 57
9624: PPUSH
9625: LD_INT 52
9627: PPUSH
9628: CALL_OW 111
// end ;
9632: PPOPN 2
9634: END
// on Contact ( s1 , s2 ) do begin if not us_alert then
9635: LD_EXP 20
9639: NOT
9640: IFFALSE 9690
// if ( s1 = 3 and s2 = 1 ) or ( s1 = 1 and s2 = 3 ) then
9642: LD_VAR 0 1
9646: PUSH
9647: LD_INT 3
9649: EQUAL
9650: PUSH
9651: LD_VAR 0 2
9655: PUSH
9656: LD_INT 1
9658: EQUAL
9659: AND
9660: PUSH
9661: LD_VAR 0 1
9665: PUSH
9666: LD_INT 1
9668: EQUAL
9669: PUSH
9670: LD_VAR 0 2
9674: PUSH
9675: LD_INT 3
9677: EQUAL
9678: AND
9679: OR
9680: IFFALSE 9690
// us_alert := true ;
9682: LD_ADDR_EXP 20
9686: PUSH
9687: LD_INT 1
9689: ST_TO_ADDR
// if ( s1 = 6 and s2 = 3 ) or ( s1 = 3 and s2 = 6 ) then
9690: LD_VAR 0 1
9694: PUSH
9695: LD_INT 6
9697: EQUAL
9698: PUSH
9699: LD_VAR 0 2
9703: PUSH
9704: LD_INT 3
9706: EQUAL
9707: AND
9708: PUSH
9709: LD_VAR 0 1
9713: PUSH
9714: LD_INT 3
9716: EQUAL
9717: PUSH
9718: LD_VAR 0 2
9722: PUSH
9723: LD_INT 6
9725: EQUAL
9726: AND
9727: OR
9728: IFFALSE 9737
// YouLost ( alat ) ;
9730: LD_STRING alat
9732: PPUSH
9733: CALL_OW 104
// end ;
9737: PPOPN 2
9739: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_empty ] , [ f_type , unit_vehicle ] ] ) then
9740: LD_VAR 0 1
9744: PPUSH
9745: CALL_OW 255
9749: PUSH
9750: LD_INT 2
9752: EQUAL
9753: PUSH
9754: LD_VAR 0 1
9758: PUSH
9759: LD_INT 58
9761: PUSH
9762: EMPTY
9763: LIST
9764: PUSH
9765: LD_INT 21
9767: PUSH
9768: LD_INT 2
9770: PUSH
9771: EMPTY
9772: LIST
9773: LIST
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PPUSH
9779: CALL_OW 69
9783: IN
9784: AND
9785: IFFALSE 9906
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 2 then
9787: LD_OWVAR 3
9791: PUSH
9792: LD_VAR 0 1
9796: DIFF
9797: PPUSH
9798: LD_VAR 0 1
9802: PPUSH
9803: CALL_OW 74
9807: PPUSH
9808: CALL_OW 255
9812: PUSH
9813: LD_INT 2
9815: NONEQUAL
9816: IFFALSE 9906
// begin Wait ( 0 0$1.3 ) ;
9818: LD_INT 46
9820: PPUSH
9821: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9825: LD_VAR 0 1
9829: PPUSH
9830: CALL_OW 250
9834: PPUSH
9835: LD_VAR 0 1
9839: PPUSH
9840: CALL_OW 251
9844: PPUSH
9845: LD_INT 1
9847: PPUSH
9848: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9852: LD_VAR 0 1
9856: PPUSH
9857: CALL_OW 250
9861: PPUSH
9862: LD_VAR 0 1
9866: PPUSH
9867: CALL_OW 251
9871: PPUSH
9872: LD_INT 1
9874: PPUSH
9875: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9879: LD_VAR 0 1
9883: PPUSH
9884: CALL_OW 250
9888: PPUSH
9889: LD_VAR 0 1
9893: PPUSH
9894: CALL_OW 251
9898: PPUSH
9899: LD_INT 1
9901: PPUSH
9902: CALL_OW 453
// end ; end ;
9906: PPOPN 1
9908: END
// on EvacuateVehicle ( driver , un , c1 , c2 ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) and not GetSide ( NearestUnit ( un ) ) = 2 then
9909: LD_VAR 0 2
9913: PUSH
9914: LD_INT 22
9916: PUSH
9917: LD_INT 2
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PUSH
9924: LD_INT 21
9926: PUSH
9927: LD_INT 2
9929: PUSH
9930: EMPTY
9931: LIST
9932: LIST
9933: PUSH
9934: EMPTY
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 69
9942: IN
9943: PUSH
9944: LD_VAR 0 2
9948: PPUSH
9949: CALL 10479 0 1
9953: PPUSH
9954: CALL_OW 255
9958: PUSH
9959: LD_INT 2
9961: EQUAL
9962: NOT
9963: AND
9964: IFFALSE 10089
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
9966: LD_INT 105
9968: PPUSH
9969: LD_INT 210
9971: PPUSH
9972: CALL_OW 12
9976: PPUSH
9977: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9981: LD_VAR 0 2
9985: PPUSH
9986: CALL_OW 250
9990: PPUSH
9991: LD_VAR 0 2
9995: PPUSH
9996: CALL_OW 251
10000: PPUSH
10001: LD_INT 3
10003: PPUSH
10004: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10008: LD_VAR 0 2
10012: PPUSH
10013: CALL_OW 250
10017: PPUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: CALL_OW 251
10027: PPUSH
10028: LD_INT 3
10030: PPUSH
10031: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10035: LD_VAR 0 2
10039: PPUSH
10040: CALL_OW 250
10044: PPUSH
10045: LD_VAR 0 2
10049: PPUSH
10050: CALL_OW 251
10054: PPUSH
10055: LD_INT 3
10057: PPUSH
10058: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10062: LD_VAR 0 2
10066: PPUSH
10067: CALL_OW 250
10071: PPUSH
10072: LD_VAR 0 2
10076: PPUSH
10077: CALL_OW 251
10081: PPUSH
10082: LD_INT 3
10084: PPUSH
10085: CALL_OW 453
// end ; end ;
10089: PPOPN 4
10091: END
// on UnitDestroyed_Extra ( un , killerSide , killerUnit ) do begin SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ;
10092: LD_VAR 0 1
10096: PPUSH
10097: LD_VAR 0 2
10101: PPUSH
10102: LD_VAR 0 3
10106: PPUSH
10107: CALL 21741 0 3
// end ;
10111: PPOPN 3
10113: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10114: LD_VAR 0 1
10118: PPUSH
10119: CALL 21839 0 1
// end ; end_of_file
10123: PPOPN 1
10125: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
10126: LD_INT 0
10128: PPUSH
10129: PPUSH
10130: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
10131: LD_ADDR_VAR 0 7
10135: PUSH
10136: LD_VAR 0 1
10140: PUSH
10141: LD_VAR 0 2
10145: ARRAY
10146: PPUSH
10147: LD_VAR 0 3
10151: PPUSH
10152: LD_VAR 0 4
10156: PPUSH
10157: CALL_OW 1
10161: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
10162: LD_ADDR_VAR 0 1
10166: PUSH
10167: LD_VAR 0 1
10171: PPUSH
10172: LD_VAR 0 2
10176: PPUSH
10177: LD_VAR 0 7
10181: PPUSH
10182: CALL_OW 1
10186: ST_TO_ADDR
// result := tab ;
10187: LD_ADDR_VAR 0 5
10191: PUSH
10192: LD_VAR 0 1
10196: ST_TO_ADDR
// end ;
10197: LD_VAR 0 5
10201: RET
// export function IsDriver ( unit ) ; begin
10202: LD_INT 0
10204: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
10205: LD_VAR 0 1
10209: PUSH
10210: LD_INT 55
10212: PUSH
10213: EMPTY
10214: LIST
10215: PPUSH
10216: CALL_OW 69
10220: IN
10221: IFFALSE 10240
// result := IsInUnit ( unit ) else
10223: LD_ADDR_VAR 0 2
10227: PUSH
10228: LD_VAR 0 1
10232: PPUSH
10233: CALL_OW 310
10237: ST_TO_ADDR
10238: GO 10248
// result := false ;
10240: LD_ADDR_VAR 0 2
10244: PUSH
10245: LD_INT 0
10247: ST_TO_ADDR
// end ;
10248: LD_VAR 0 2
10252: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10253: LD_INT 0
10255: PPUSH
10256: PPUSH
10257: PPUSH
// if not GetControl ( veh ) = control_manual then
10258: LD_VAR 0 1
10262: PPUSH
10263: CALL_OW 263
10267: PUSH
10268: LD_INT 1
10270: EQUAL
10271: NOT
10272: IFFALSE 10284
// result := false else
10274: LD_ADDR_VAR 0 2
10278: PUSH
10279: LD_INT 0
10281: ST_TO_ADDR
10282: GO 10429
// if veh in FilterAllUnits ( [ f_empty ] ) then
10284: LD_VAR 0 1
10288: PUSH
10289: LD_INT 58
10291: PUSH
10292: EMPTY
10293: LIST
10294: PPUSH
10295: CALL_OW 69
10299: IN
10300: IFFALSE 10312
// result := false else
10302: LD_ADDR_VAR 0 2
10306: PUSH
10307: LD_INT 0
10309: ST_TO_ADDR
10310: GO 10429
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10312: LD_ADDR_VAR 0 4
10316: PUSH
10317: LD_INT 22
10319: PUSH
10320: LD_VAR 0 1
10324: PPUSH
10325: CALL_OW 255
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: PUSH
10334: LD_INT 55
10336: PUSH
10337: EMPTY
10338: LIST
10339: PUSH
10340: EMPTY
10341: LIST
10342: LIST
10343: PPUSH
10344: CALL_OW 69
10348: ST_TO_ADDR
// if not filter then
10349: LD_VAR 0 4
10353: NOT
10354: IFFALSE 10366
// result := false else
10356: LD_ADDR_VAR 0 2
10360: PUSH
10361: LD_INT 0
10363: ST_TO_ADDR
10364: GO 10429
// for i = 1 to filter do
10366: LD_ADDR_VAR 0 3
10370: PUSH
10371: DOUBLE
10372: LD_INT 1
10374: DEC
10375: ST_TO_ADDR
10376: LD_VAR 0 4
10380: PUSH
10381: FOR_TO
10382: IFFALSE 10427
// if IsDriver ( filter [ i ] ) = veh then
10384: LD_VAR 0 4
10388: PUSH
10389: LD_VAR 0 3
10393: ARRAY
10394: PPUSH
10395: CALL 10202 0 1
10399: PUSH
10400: LD_VAR 0 1
10404: EQUAL
10405: IFFALSE 10425
// begin result := filter [ i ] ;
10407: LD_ADDR_VAR 0 2
10411: PUSH
10412: LD_VAR 0 4
10416: PUSH
10417: LD_VAR 0 3
10421: ARRAY
10422: ST_TO_ADDR
// break ;
10423: GO 10427
// end ;
10425: GO 10381
10427: POP
10428: POP
// end ; end ;
10429: LD_VAR 0 2
10433: RET
// export function FindTarget ( unit ) ; begin
10434: LD_INT 0
10436: PPUSH
// result := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ;
10437: LD_ADDR_VAR 0 2
10441: PUSH
10442: LD_INT 81
10444: PUSH
10445: LD_VAR 0 1
10449: PPUSH
10450: CALL_OW 255
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PPUSH
10459: CALL_OW 69
10463: PPUSH
10464: LD_VAR 0 1
10468: PPUSH
10469: CALL_OW 74
10473: ST_TO_ADDR
// end ;
10474: LD_VAR 0 2
10478: RET
// export function NearestUnit ( unit ) ; begin
10479: LD_INT 0
10481: PPUSH
// result := NearestUnitToUnit ( all_units diff unit , unit ) ;
10482: LD_ADDR_VAR 0 2
10486: PUSH
10487: LD_OWVAR 3
10491: PUSH
10492: LD_VAR 0 1
10496: DIFF
10497: PPUSH
10498: LD_VAR 0 1
10502: PPUSH
10503: CALL_OW 74
10507: ST_TO_ADDR
// end ; end_of_file
10508: LD_VAR 0 2
10512: RET
// every 12 12$00 do
10513: GO 10515
10515: DISABLE
// begin SetWeather ( 1 , 210 , 110 ) ;
10516: LD_INT 1
10518: PPUSH
10519: LD_INT 210
10521: PPUSH
10522: LD_INT 110
10524: PPUSH
10525: CALL_OW 550
// Wait ( Rand ( 5 5$00 , 10 10$00 ) ) ;
10529: LD_INT 10500
10531: PPUSH
10532: LD_INT 21000
10534: PPUSH
10535: CALL_OW 12
10539: PPUSH
10540: CALL_OW 67
// SetWeather ( 0 , 210 , 110 ) ;
10544: LD_INT 0
10546: PPUSH
10547: LD_INT 210
10549: PPUSH
10550: LD_INT 110
10552: PPUSH
10553: CALL_OW 550
// end ;
10557: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
10558: LD_INT 0
10560: PPUSH
10561: PPUSH
10562: PPUSH
10563: PPUSH
10564: PPUSH
// uc_nation = nation_nature ;
10565: LD_ADDR_OWVAR 21
10569: PUSH
10570: LD_INT 0
10572: ST_TO_ADDR
// uc_side = 0 ;
10573: LD_ADDR_OWVAR 20
10577: PUSH
10578: LD_INT 0
10580: ST_TO_ADDR
// l = 0 ;
10581: LD_ADDR_VAR 0 6
10585: PUSH
10586: LD_INT 0
10588: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
10589: LD_ADDR_OWVAR 24
10593: PUSH
10594: LD_INT 0
10596: PPUSH
10597: LD_INT 5
10599: PPUSH
10600: CALL_OW 12
10604: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
10605: LD_ADDR_OWVAR 35
10609: PUSH
10610: LD_INT 5
10612: NEG
10613: PPUSH
10614: LD_INT 5
10616: PPUSH
10617: CALL_OW 12
10621: ST_TO_ADDR
// hc_gallery =  ;
10622: LD_ADDR_OWVAR 33
10626: PUSH
10627: LD_STRING 
10629: ST_TO_ADDR
// hc_class = class_apeman ;
10630: LD_ADDR_OWVAR 28
10634: PUSH
10635: LD_INT 12
10637: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
10638: LD_ADDR_OWVAR 29
10642: PUSH
10643: LD_INT 11
10645: PPUSH
10646: LD_INT 13
10648: PPUSH
10649: CALL_OW 12
10653: PUSH
10654: LD_INT 10
10656: PPUSH
10657: LD_INT 11
10659: PPUSH
10660: CALL_OW 12
10664: PUSH
10665: EMPTY
10666: LIST
10667: LIST
10668: ST_TO_ADDR
// hc_sex = sex_male ;
10669: LD_ADDR_OWVAR 27
10673: PUSH
10674: LD_INT 1
10676: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
10677: LD_ADDR_OWVAR 31
10681: PUSH
10682: LD_INT 0
10684: PPUSH
10685: LD_INT 2
10687: PPUSH
10688: CALL_OW 12
10692: PUSH
10693: LD_INT 0
10695: PUSH
10696: LD_INT 0
10698: PUSH
10699: LD_INT 0
10701: PUSH
10702: EMPTY
10703: LIST
10704: LIST
10705: LIST
10706: LIST
10707: ST_TO_ADDR
// apeman = CreateHuman ;
10708: LD_ADDR_VAR 0 7
10712: PUSH
10713: CALL_OW 44
10717: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
10718: LD_VAR 0 7
10722: PPUSH
10723: LD_VAR 0 4
10727: PPUSH
10728: LD_INT 0
10730: PPUSH
10731: CALL_OW 49
// l = l + 1 ;
10735: LD_ADDR_VAR 0 6
10739: PUSH
10740: LD_VAR 0 6
10744: PUSH
10745: LD_INT 1
10747: PLUS
10748: ST_TO_ADDR
// end until l = num1 ;
10749: LD_VAR 0 6
10753: PUSH
10754: LD_VAR 0 1
10758: EQUAL
10759: IFFALSE 10589
// l = 0 ;
10761: LD_ADDR_VAR 0 6
10765: PUSH
10766: LD_INT 0
10768: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
10769: LD_ADDR_OWVAR 35
10773: PUSH
10774: LD_INT 0
10776: PPUSH
10777: LD_INT 25
10779: PPUSH
10780: CALL_OW 12
10784: ST_TO_ADDR
// hc_class = class_tiger ;
10785: LD_ADDR_OWVAR 28
10789: PUSH
10790: LD_INT 14
10792: ST_TO_ADDR
// hc_sex = sex_male ;
10793: LD_ADDR_OWVAR 27
10797: PUSH
10798: LD_INT 1
10800: ST_TO_ADDR
// hc_gallery = sandnature ;
10801: LD_ADDR_OWVAR 33
10805: PUSH
10806: LD_STRING sandnature
10808: ST_TO_ADDR
// hc_face_number = 3 ;
10809: LD_ADDR_OWVAR 34
10813: PUSH
10814: LD_INT 3
10816: ST_TO_ADDR
// tiger = CreateHuman ;
10817: LD_ADDR_VAR 0 8
10821: PUSH
10822: CALL_OW 44
10826: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10827: LD_VAR 0 8
10831: PPUSH
10832: LD_VAR 0 4
10836: PPUSH
10837: LD_INT 0
10839: PPUSH
10840: CALL_OW 49
// l = l + 1 ;
10844: LD_ADDR_VAR 0 6
10848: PUSH
10849: LD_VAR 0 6
10853: PUSH
10854: LD_INT 1
10856: PLUS
10857: ST_TO_ADDR
// end until l = num2 ;
10858: LD_VAR 0 6
10862: PUSH
10863: LD_VAR 0 2
10867: EQUAL
10868: IFFALSE 10769
// l = 0 ;
10870: LD_ADDR_VAR 0 6
10874: PUSH
10875: LD_INT 0
10877: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
10878: LD_ADDR_OWVAR 28
10882: PUSH
10883: LD_INT 18
10885: ST_TO_ADDR
// hc_gallery = sandnature ;
10886: LD_ADDR_OWVAR 33
10890: PUSH
10891: LD_STRING sandnature
10893: ST_TO_ADDR
// hc_face_number = 1 ;
10894: LD_ADDR_OWVAR 34
10898: PUSH
10899: LD_INT 1
10901: ST_TO_ADDR
// bird = CreateHuman ;
10902: LD_ADDR_VAR 0 9
10906: PUSH
10907: CALL_OW 44
10911: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
10912: LD_VAR 0 9
10916: PPUSH
10917: LD_INT 0
10919: PPUSH
10920: CALL_OW 51
// l = l + 1 ;
10924: LD_ADDR_VAR 0 6
10928: PUSH
10929: LD_VAR 0 6
10933: PUSH
10934: LD_INT 1
10936: PLUS
10937: ST_TO_ADDR
// end until l = num3 ;
10938: LD_VAR 0 6
10942: PUSH
10943: LD_VAR 0 3
10947: EQUAL
10948: IFFALSE 10878
// end ; end_of_file
10950: LD_VAR 0 5
10954: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10955: GO 10957
10957: DISABLE
// begin ru_radar := 98 ;
10958: LD_ADDR_EXP 25
10962: PUSH
10963: LD_INT 98
10965: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10966: LD_ADDR_EXP 26
10970: PUSH
10971: LD_INT 89
10973: ST_TO_ADDR
// us_hack := 99 ;
10974: LD_ADDR_EXP 27
10978: PUSH
10979: LD_INT 99
10981: ST_TO_ADDR
// us_artillery := 97 ;
10982: LD_ADDR_EXP 28
10986: PUSH
10987: LD_INT 97
10989: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10990: LD_ADDR_EXP 29
10994: PUSH
10995: LD_INT 91
10997: ST_TO_ADDR
// end ; end_of_file end_of_file
10998: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
10999: GO 11001
11001: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
11002: LD_STRING initStreamRollete();
11004: PPUSH
11005: CALL_OW 559
// InitStreamMode ;
11009: CALL 11018 0 0
// DefineStreamItems ( ) ;
11013: CALL 11458 0 0
// end ;
11017: END
// function InitStreamMode ; begin
11018: LD_INT 0
11020: PPUSH
// streamModeActive := false ;
11021: LD_ADDR_EXP 30
11025: PUSH
11026: LD_INT 0
11028: ST_TO_ADDR
// normalCounter := 26 ;
11029: LD_ADDR_EXP 31
11033: PUSH
11034: LD_INT 26
11036: ST_TO_ADDR
// hardcoreCounter := 12 ;
11037: LD_ADDR_EXP 32
11041: PUSH
11042: LD_INT 12
11044: ST_TO_ADDR
// sRocket := false ;
11045: LD_ADDR_EXP 35
11049: PUSH
11050: LD_INT 0
11052: ST_TO_ADDR
// sSpeed := false ;
11053: LD_ADDR_EXP 34
11057: PUSH
11058: LD_INT 0
11060: ST_TO_ADDR
// sEngine := false ;
11061: LD_ADDR_EXP 36
11065: PUSH
11066: LD_INT 0
11068: ST_TO_ADDR
// sSpec := false ;
11069: LD_ADDR_EXP 33
11073: PUSH
11074: LD_INT 0
11076: ST_TO_ADDR
// sLevel := false ;
11077: LD_ADDR_EXP 37
11081: PUSH
11082: LD_INT 0
11084: ST_TO_ADDR
// sArmoury := false ;
11085: LD_ADDR_EXP 38
11089: PUSH
11090: LD_INT 0
11092: ST_TO_ADDR
// sRadar := false ;
11093: LD_ADDR_EXP 39
11097: PUSH
11098: LD_INT 0
11100: ST_TO_ADDR
// sBunker := false ;
11101: LD_ADDR_EXP 40
11105: PUSH
11106: LD_INT 0
11108: ST_TO_ADDR
// sHack := false ;
11109: LD_ADDR_EXP 41
11113: PUSH
11114: LD_INT 0
11116: ST_TO_ADDR
// sFire := false ;
11117: LD_ADDR_EXP 42
11121: PUSH
11122: LD_INT 0
11124: ST_TO_ADDR
// sRefresh := false ;
11125: LD_ADDR_EXP 43
11129: PUSH
11130: LD_INT 0
11132: ST_TO_ADDR
// sExp := false ;
11133: LD_ADDR_EXP 44
11137: PUSH
11138: LD_INT 0
11140: ST_TO_ADDR
// sDepot := false ;
11141: LD_ADDR_EXP 45
11145: PUSH
11146: LD_INT 0
11148: ST_TO_ADDR
// sFlag := false ;
11149: LD_ADDR_EXP 46
11153: PUSH
11154: LD_INT 0
11156: ST_TO_ADDR
// sKamikadze := false ;
11157: LD_ADDR_EXP 54
11161: PUSH
11162: LD_INT 0
11164: ST_TO_ADDR
// sTroll := false ;
11165: LD_ADDR_EXP 55
11169: PUSH
11170: LD_INT 0
11172: ST_TO_ADDR
// sSlow := false ;
11173: LD_ADDR_EXP 56
11177: PUSH
11178: LD_INT 0
11180: ST_TO_ADDR
// sLack := false ;
11181: LD_ADDR_EXP 57
11185: PUSH
11186: LD_INT 0
11188: ST_TO_ADDR
// sTank := false ;
11189: LD_ADDR_EXP 59
11193: PUSH
11194: LD_INT 0
11196: ST_TO_ADDR
// sRemote := false ;
11197: LD_ADDR_EXP 60
11201: PUSH
11202: LD_INT 0
11204: ST_TO_ADDR
// sPowell := false ;
11205: LD_ADDR_EXP 61
11209: PUSH
11210: LD_INT 0
11212: ST_TO_ADDR
// sTeleport := false ;
11213: LD_ADDR_EXP 64
11217: PUSH
11218: LD_INT 0
11220: ST_TO_ADDR
// sOilTower := false ;
11221: LD_ADDR_EXP 66
11225: PUSH
11226: LD_INT 0
11228: ST_TO_ADDR
// sShovel := false ;
11229: LD_ADDR_EXP 67
11233: PUSH
11234: LD_INT 0
11236: ST_TO_ADDR
// sSheik := false ;
11237: LD_ADDR_EXP 68
11241: PUSH
11242: LD_INT 0
11244: ST_TO_ADDR
// sEarthquake := false ;
11245: LD_ADDR_EXP 70
11249: PUSH
11250: LD_INT 0
11252: ST_TO_ADDR
// sAI := false ;
11253: LD_ADDR_EXP 71
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// sCargo := false ;
11261: LD_ADDR_EXP 74
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// sDLaser := false ;
11269: LD_ADDR_EXP 75
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// sExchange := false ;
11277: LD_ADDR_EXP 76
11281: PUSH
11282: LD_INT 0
11284: ST_TO_ADDR
// sFac := false ;
11285: LD_ADDR_EXP 77
11289: PUSH
11290: LD_INT 0
11292: ST_TO_ADDR
// sPower := false ;
11293: LD_ADDR_EXP 78
11297: PUSH
11298: LD_INT 0
11300: ST_TO_ADDR
// sRandom := false ;
11301: LD_ADDR_EXP 79
11305: PUSH
11306: LD_INT 0
11308: ST_TO_ADDR
// sShield := false ;
11309: LD_ADDR_EXP 80
11313: PUSH
11314: LD_INT 0
11316: ST_TO_ADDR
// sTime := false ;
11317: LD_ADDR_EXP 81
11321: PUSH
11322: LD_INT 0
11324: ST_TO_ADDR
// sTools := false ;
11325: LD_ADDR_EXP 82
11329: PUSH
11330: LD_INT 0
11332: ST_TO_ADDR
// sSold := false ;
11333: LD_ADDR_EXP 47
11337: PUSH
11338: LD_INT 0
11340: ST_TO_ADDR
// sDiff := false ;
11341: LD_ADDR_EXP 48
11345: PUSH
11346: LD_INT 0
11348: ST_TO_ADDR
// sFog := false ;
11349: LD_ADDR_EXP 51
11353: PUSH
11354: LD_INT 0
11356: ST_TO_ADDR
// sReset := false ;
11357: LD_ADDR_EXP 52
11361: PUSH
11362: LD_INT 0
11364: ST_TO_ADDR
// sSun := false ;
11365: LD_ADDR_EXP 53
11369: PUSH
11370: LD_INT 0
11372: ST_TO_ADDR
// sTiger := false ;
11373: LD_ADDR_EXP 49
11377: PUSH
11378: LD_INT 0
11380: ST_TO_ADDR
// sBomb := false ;
11381: LD_ADDR_EXP 50
11385: PUSH
11386: LD_INT 0
11388: ST_TO_ADDR
// sWound := false ;
11389: LD_ADDR_EXP 58
11393: PUSH
11394: LD_INT 0
11396: ST_TO_ADDR
// sBetray := false ;
11397: LD_ADDR_EXP 62
11401: PUSH
11402: LD_INT 0
11404: ST_TO_ADDR
// sContamin := false ;
11405: LD_ADDR_EXP 63
11409: PUSH
11410: LD_INT 0
11412: ST_TO_ADDR
// sOil := false ;
11413: LD_ADDR_EXP 65
11417: PUSH
11418: LD_INT 0
11420: ST_TO_ADDR
// sStu := false ;
11421: LD_ADDR_EXP 69
11425: PUSH
11426: LD_INT 0
11428: ST_TO_ADDR
// sBazooka := false ;
11429: LD_ADDR_EXP 72
11433: PUSH
11434: LD_INT 0
11436: ST_TO_ADDR
// sMortar := false ;
11437: LD_ADDR_EXP 73
11441: PUSH
11442: LD_INT 0
11444: ST_TO_ADDR
// sRanger := false ;
11445: LD_ADDR_EXP 83
11449: PUSH
11450: LD_INT 0
11452: ST_TO_ADDR
// end ;
11453: LD_VAR 0 1
11457: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
11458: LD_INT 0
11460: PPUSH
11461: PPUSH
11462: PPUSH
11463: PPUSH
11464: PPUSH
// result := [ ] ;
11465: LD_ADDR_VAR 0 1
11469: PUSH
11470: EMPTY
11471: ST_TO_ADDR
// if campaign_id = 1 then
11472: LD_OWVAR 69
11476: PUSH
11477: LD_INT 1
11479: EQUAL
11480: IFFALSE 14416
// begin case mission_number of 1 :
11482: LD_OWVAR 70
11486: PUSH
11487: LD_INT 1
11489: DOUBLE
11490: EQUAL
11491: IFTRUE 11495
11493: GO 11559
11495: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
11496: LD_ADDR_VAR 0 1
11500: PUSH
11501: LD_INT 2
11503: PUSH
11504: LD_INT 4
11506: PUSH
11507: LD_INT 11
11509: PUSH
11510: LD_INT 12
11512: PUSH
11513: LD_INT 15
11515: PUSH
11516: LD_INT 16
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 23
11524: PUSH
11525: LD_INT 26
11527: PUSH
11528: EMPTY
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: PUSH
11539: LD_INT 101
11541: PUSH
11542: LD_INT 102
11544: PUSH
11545: LD_INT 106
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: LIST
11552: PUSH
11553: EMPTY
11554: LIST
11555: LIST
11556: ST_TO_ADDR
11557: GO 14416
11559: LD_INT 2
11561: DOUBLE
11562: EQUAL
11563: IFTRUE 11567
11565: GO 11639
11567: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
11568: LD_ADDR_VAR 0 1
11572: PUSH
11573: LD_INT 2
11575: PUSH
11576: LD_INT 4
11578: PUSH
11579: LD_INT 11
11581: PUSH
11582: LD_INT 12
11584: PUSH
11585: LD_INT 15
11587: PUSH
11588: LD_INT 16
11590: PUSH
11591: LD_INT 22
11593: PUSH
11594: LD_INT 23
11596: PUSH
11597: LD_INT 26
11599: PUSH
11600: EMPTY
11601: LIST
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: PUSH
11611: LD_INT 101
11613: PUSH
11614: LD_INT 102
11616: PUSH
11617: LD_INT 105
11619: PUSH
11620: LD_INT 106
11622: PUSH
11623: LD_INT 108
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: PUSH
11633: EMPTY
11634: LIST
11635: LIST
11636: ST_TO_ADDR
11637: GO 14416
11639: LD_INT 3
11641: DOUBLE
11642: EQUAL
11643: IFTRUE 11647
11645: GO 11723
11647: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
11648: LD_ADDR_VAR 0 1
11652: PUSH
11653: LD_INT 2
11655: PUSH
11656: LD_INT 4
11658: PUSH
11659: LD_INT 5
11661: PUSH
11662: LD_INT 11
11664: PUSH
11665: LD_INT 12
11667: PUSH
11668: LD_INT 15
11670: PUSH
11671: LD_INT 16
11673: PUSH
11674: LD_INT 22
11676: PUSH
11677: LD_INT 26
11679: PUSH
11680: LD_INT 36
11682: PUSH
11683: EMPTY
11684: LIST
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: LIST
11694: PUSH
11695: LD_INT 101
11697: PUSH
11698: LD_INT 102
11700: PUSH
11701: LD_INT 105
11703: PUSH
11704: LD_INT 106
11706: PUSH
11707: LD_INT 108
11709: PUSH
11710: EMPTY
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: LIST
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: ST_TO_ADDR
11721: GO 14416
11723: LD_INT 4
11725: DOUBLE
11726: EQUAL
11727: IFTRUE 11731
11729: GO 11815
11731: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
11732: LD_ADDR_VAR 0 1
11736: PUSH
11737: LD_INT 2
11739: PUSH
11740: LD_INT 4
11742: PUSH
11743: LD_INT 5
11745: PUSH
11746: LD_INT 8
11748: PUSH
11749: LD_INT 11
11751: PUSH
11752: LD_INT 12
11754: PUSH
11755: LD_INT 15
11757: PUSH
11758: LD_INT 16
11760: PUSH
11761: LD_INT 22
11763: PUSH
11764: LD_INT 23
11766: PUSH
11767: LD_INT 26
11769: PUSH
11770: LD_INT 36
11772: PUSH
11773: EMPTY
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: PUSH
11787: LD_INT 101
11789: PUSH
11790: LD_INT 102
11792: PUSH
11793: LD_INT 105
11795: PUSH
11796: LD_INT 106
11798: PUSH
11799: LD_INT 108
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: PUSH
11809: EMPTY
11810: LIST
11811: LIST
11812: ST_TO_ADDR
11813: GO 14416
11815: LD_INT 5
11817: DOUBLE
11818: EQUAL
11819: IFTRUE 11823
11821: GO 11923
11823: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
11824: LD_ADDR_VAR 0 1
11828: PUSH
11829: LD_INT 2
11831: PUSH
11832: LD_INT 4
11834: PUSH
11835: LD_INT 5
11837: PUSH
11838: LD_INT 6
11840: PUSH
11841: LD_INT 8
11843: PUSH
11844: LD_INT 11
11846: PUSH
11847: LD_INT 12
11849: PUSH
11850: LD_INT 15
11852: PUSH
11853: LD_INT 16
11855: PUSH
11856: LD_INT 22
11858: PUSH
11859: LD_INT 23
11861: PUSH
11862: LD_INT 25
11864: PUSH
11865: LD_INT 26
11867: PUSH
11868: LD_INT 36
11870: PUSH
11871: EMPTY
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: PUSH
11887: LD_INT 101
11889: PUSH
11890: LD_INT 102
11892: PUSH
11893: LD_INT 105
11895: PUSH
11896: LD_INT 106
11898: PUSH
11899: LD_INT 108
11901: PUSH
11902: LD_INT 109
11904: PUSH
11905: LD_INT 112
11907: PUSH
11908: EMPTY
11909: LIST
11910: LIST
11911: LIST
11912: LIST
11913: LIST
11914: LIST
11915: LIST
11916: PUSH
11917: EMPTY
11918: LIST
11919: LIST
11920: ST_TO_ADDR
11921: GO 14416
11923: LD_INT 6
11925: DOUBLE
11926: EQUAL
11927: IFTRUE 11931
11929: GO 12051
11931: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
11932: LD_ADDR_VAR 0 1
11936: PUSH
11937: LD_INT 2
11939: PUSH
11940: LD_INT 4
11942: PUSH
11943: LD_INT 5
11945: PUSH
11946: LD_INT 6
11948: PUSH
11949: LD_INT 8
11951: PUSH
11952: LD_INT 11
11954: PUSH
11955: LD_INT 12
11957: PUSH
11958: LD_INT 15
11960: PUSH
11961: LD_INT 16
11963: PUSH
11964: LD_INT 20
11966: PUSH
11967: LD_INT 21
11969: PUSH
11970: LD_INT 22
11972: PUSH
11973: LD_INT 23
11975: PUSH
11976: LD_INT 25
11978: PUSH
11979: LD_INT 26
11981: PUSH
11982: LD_INT 30
11984: PUSH
11985: LD_INT 31
11987: PUSH
11988: LD_INT 32
11990: PUSH
11991: LD_INT 36
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: PUSH
12015: LD_INT 101
12017: PUSH
12018: LD_INT 102
12020: PUSH
12021: LD_INT 105
12023: PUSH
12024: LD_INT 106
12026: PUSH
12027: LD_INT 108
12029: PUSH
12030: LD_INT 109
12032: PUSH
12033: LD_INT 112
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: LIST
12040: LIST
12041: LIST
12042: LIST
12043: LIST
12044: PUSH
12045: EMPTY
12046: LIST
12047: LIST
12048: ST_TO_ADDR
12049: GO 14416
12051: LD_INT 7
12053: DOUBLE
12054: EQUAL
12055: IFTRUE 12059
12057: GO 12159
12059: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
12060: LD_ADDR_VAR 0 1
12064: PUSH
12065: LD_INT 2
12067: PUSH
12068: LD_INT 4
12070: PUSH
12071: LD_INT 5
12073: PUSH
12074: LD_INT 7
12076: PUSH
12077: LD_INT 11
12079: PUSH
12080: LD_INT 12
12082: PUSH
12083: LD_INT 15
12085: PUSH
12086: LD_INT 16
12088: PUSH
12089: LD_INT 20
12091: PUSH
12092: LD_INT 21
12094: PUSH
12095: LD_INT 22
12097: PUSH
12098: LD_INT 23
12100: PUSH
12101: LD_INT 25
12103: PUSH
12104: LD_INT 26
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: LIST
12113: LIST
12114: LIST
12115: LIST
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 101
12125: PUSH
12126: LD_INT 102
12128: PUSH
12129: LD_INT 103
12131: PUSH
12132: LD_INT 105
12134: PUSH
12135: LD_INT 106
12137: PUSH
12138: LD_INT 108
12140: PUSH
12141: LD_INT 112
12143: PUSH
12144: EMPTY
12145: LIST
12146: LIST
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: ST_TO_ADDR
12157: GO 14416
12159: LD_INT 8
12161: DOUBLE
12162: EQUAL
12163: IFTRUE 12167
12165: GO 12295
12167: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
12168: LD_ADDR_VAR 0 1
12172: PUSH
12173: LD_INT 2
12175: PUSH
12176: LD_INT 4
12178: PUSH
12179: LD_INT 5
12181: PUSH
12182: LD_INT 6
12184: PUSH
12185: LD_INT 7
12187: PUSH
12188: LD_INT 8
12190: PUSH
12191: LD_INT 11
12193: PUSH
12194: LD_INT 12
12196: PUSH
12197: LD_INT 15
12199: PUSH
12200: LD_INT 16
12202: PUSH
12203: LD_INT 20
12205: PUSH
12206: LD_INT 21
12208: PUSH
12209: LD_INT 22
12211: PUSH
12212: LD_INT 23
12214: PUSH
12215: LD_INT 25
12217: PUSH
12218: LD_INT 26
12220: PUSH
12221: LD_INT 30
12223: PUSH
12224: LD_INT 31
12226: PUSH
12227: LD_INT 32
12229: PUSH
12230: LD_INT 36
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: LIST
12239: LIST
12240: LIST
12241: LIST
12242: LIST
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: LIST
12252: LIST
12253: LIST
12254: PUSH
12255: LD_INT 101
12257: PUSH
12258: LD_INT 102
12260: PUSH
12261: LD_INT 103
12263: PUSH
12264: LD_INT 105
12266: PUSH
12267: LD_INT 106
12269: PUSH
12270: LD_INT 108
12272: PUSH
12273: LD_INT 109
12275: PUSH
12276: LD_INT 112
12278: PUSH
12279: EMPTY
12280: LIST
12281: LIST
12282: LIST
12283: LIST
12284: LIST
12285: LIST
12286: LIST
12287: LIST
12288: PUSH
12289: EMPTY
12290: LIST
12291: LIST
12292: ST_TO_ADDR
12293: GO 14416
12295: LD_INT 9
12297: DOUBLE
12298: EQUAL
12299: IFTRUE 12303
12301: GO 12439
12303: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
12304: LD_ADDR_VAR 0 1
12308: PUSH
12309: LD_INT 2
12311: PUSH
12312: LD_INT 4
12314: PUSH
12315: LD_INT 5
12317: PUSH
12318: LD_INT 6
12320: PUSH
12321: LD_INT 7
12323: PUSH
12324: LD_INT 8
12326: PUSH
12327: LD_INT 11
12329: PUSH
12330: LD_INT 12
12332: PUSH
12333: LD_INT 15
12335: PUSH
12336: LD_INT 16
12338: PUSH
12339: LD_INT 20
12341: PUSH
12342: LD_INT 21
12344: PUSH
12345: LD_INT 22
12347: PUSH
12348: LD_INT 23
12350: PUSH
12351: LD_INT 25
12353: PUSH
12354: LD_INT 26
12356: PUSH
12357: LD_INT 28
12359: PUSH
12360: LD_INT 30
12362: PUSH
12363: LD_INT 31
12365: PUSH
12366: LD_INT 32
12368: PUSH
12369: LD_INT 36
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: LIST
12376: LIST
12377: LIST
12378: LIST
12379: LIST
12380: LIST
12381: LIST
12382: LIST
12383: LIST
12384: LIST
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: PUSH
12395: LD_INT 101
12397: PUSH
12398: LD_INT 102
12400: PUSH
12401: LD_INT 103
12403: PUSH
12404: LD_INT 105
12406: PUSH
12407: LD_INT 106
12409: PUSH
12410: LD_INT 108
12412: PUSH
12413: LD_INT 109
12415: PUSH
12416: LD_INT 112
12418: PUSH
12419: LD_INT 114
12421: PUSH
12422: EMPTY
12423: LIST
12424: LIST
12425: LIST
12426: LIST
12427: LIST
12428: LIST
12429: LIST
12430: LIST
12431: LIST
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: ST_TO_ADDR
12437: GO 14416
12439: LD_INT 10
12441: DOUBLE
12442: EQUAL
12443: IFTRUE 12447
12445: GO 12631
12447: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
12448: LD_ADDR_VAR 0 1
12452: PUSH
12453: LD_INT 2
12455: PUSH
12456: LD_INT 4
12458: PUSH
12459: LD_INT 5
12461: PUSH
12462: LD_INT 6
12464: PUSH
12465: LD_INT 7
12467: PUSH
12468: LD_INT 8
12470: PUSH
12471: LD_INT 9
12473: PUSH
12474: LD_INT 10
12476: PUSH
12477: LD_INT 11
12479: PUSH
12480: LD_INT 12
12482: PUSH
12483: LD_INT 13
12485: PUSH
12486: LD_INT 14
12488: PUSH
12489: LD_INT 15
12491: PUSH
12492: LD_INT 16
12494: PUSH
12495: LD_INT 17
12497: PUSH
12498: LD_INT 18
12500: PUSH
12501: LD_INT 19
12503: PUSH
12504: LD_INT 20
12506: PUSH
12507: LD_INT 21
12509: PUSH
12510: LD_INT 22
12512: PUSH
12513: LD_INT 23
12515: PUSH
12516: LD_INT 24
12518: PUSH
12519: LD_INT 25
12521: PUSH
12522: LD_INT 26
12524: PUSH
12525: LD_INT 28
12527: PUSH
12528: LD_INT 30
12530: PUSH
12531: LD_INT 31
12533: PUSH
12534: LD_INT 32
12536: PUSH
12537: LD_INT 36
12539: PUSH
12540: EMPTY
12541: LIST
12542: LIST
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: LIST
12548: LIST
12549: LIST
12550: LIST
12551: LIST
12552: LIST
12553: LIST
12554: LIST
12555: LIST
12556: LIST
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: LIST
12567: LIST
12568: LIST
12569: LIST
12570: PUSH
12571: LD_INT 101
12573: PUSH
12574: LD_INT 102
12576: PUSH
12577: LD_INT 103
12579: PUSH
12580: LD_INT 104
12582: PUSH
12583: LD_INT 105
12585: PUSH
12586: LD_INT 106
12588: PUSH
12589: LD_INT 107
12591: PUSH
12592: LD_INT 108
12594: PUSH
12595: LD_INT 109
12597: PUSH
12598: LD_INT 110
12600: PUSH
12601: LD_INT 111
12603: PUSH
12604: LD_INT 112
12606: PUSH
12607: LD_INT 114
12609: PUSH
12610: EMPTY
12611: LIST
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: LIST
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: ST_TO_ADDR
12629: GO 14416
12631: LD_INT 11
12633: DOUBLE
12634: EQUAL
12635: IFTRUE 12639
12637: GO 12831
12639: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
12640: LD_ADDR_VAR 0 1
12644: PUSH
12645: LD_INT 2
12647: PUSH
12648: LD_INT 3
12650: PUSH
12651: LD_INT 4
12653: PUSH
12654: LD_INT 5
12656: PUSH
12657: LD_INT 6
12659: PUSH
12660: LD_INT 7
12662: PUSH
12663: LD_INT 8
12665: PUSH
12666: LD_INT 9
12668: PUSH
12669: LD_INT 10
12671: PUSH
12672: LD_INT 11
12674: PUSH
12675: LD_INT 12
12677: PUSH
12678: LD_INT 13
12680: PUSH
12681: LD_INT 14
12683: PUSH
12684: LD_INT 15
12686: PUSH
12687: LD_INT 16
12689: PUSH
12690: LD_INT 17
12692: PUSH
12693: LD_INT 18
12695: PUSH
12696: LD_INT 19
12698: PUSH
12699: LD_INT 20
12701: PUSH
12702: LD_INT 21
12704: PUSH
12705: LD_INT 22
12707: PUSH
12708: LD_INT 23
12710: PUSH
12711: LD_INT 24
12713: PUSH
12714: LD_INT 25
12716: PUSH
12717: LD_INT 26
12719: PUSH
12720: LD_INT 28
12722: PUSH
12723: LD_INT 30
12725: PUSH
12726: LD_INT 31
12728: PUSH
12729: LD_INT 32
12731: PUSH
12732: LD_INT 34
12734: PUSH
12735: LD_INT 36
12737: PUSH
12738: EMPTY
12739: LIST
12740: LIST
12741: LIST
12742: LIST
12743: LIST
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: LIST
12750: LIST
12751: LIST
12752: LIST
12753: LIST
12754: LIST
12755: LIST
12756: LIST
12757: LIST
12758: LIST
12759: LIST
12760: LIST
12761: LIST
12762: LIST
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: PUSH
12771: LD_INT 101
12773: PUSH
12774: LD_INT 102
12776: PUSH
12777: LD_INT 103
12779: PUSH
12780: LD_INT 104
12782: PUSH
12783: LD_INT 105
12785: PUSH
12786: LD_INT 106
12788: PUSH
12789: LD_INT 107
12791: PUSH
12792: LD_INT 108
12794: PUSH
12795: LD_INT 109
12797: PUSH
12798: LD_INT 110
12800: PUSH
12801: LD_INT 111
12803: PUSH
12804: LD_INT 112
12806: PUSH
12807: LD_INT 114
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: ST_TO_ADDR
12829: GO 14416
12831: LD_INT 12
12833: DOUBLE
12834: EQUAL
12835: IFTRUE 12839
12837: GO 13047
12839: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
12840: LD_ADDR_VAR 0 1
12844: PUSH
12845: LD_INT 1
12847: PUSH
12848: LD_INT 2
12850: PUSH
12851: LD_INT 3
12853: PUSH
12854: LD_INT 4
12856: PUSH
12857: LD_INT 5
12859: PUSH
12860: LD_INT 6
12862: PUSH
12863: LD_INT 7
12865: PUSH
12866: LD_INT 8
12868: PUSH
12869: LD_INT 9
12871: PUSH
12872: LD_INT 10
12874: PUSH
12875: LD_INT 11
12877: PUSH
12878: LD_INT 12
12880: PUSH
12881: LD_INT 13
12883: PUSH
12884: LD_INT 14
12886: PUSH
12887: LD_INT 15
12889: PUSH
12890: LD_INT 16
12892: PUSH
12893: LD_INT 17
12895: PUSH
12896: LD_INT 18
12898: PUSH
12899: LD_INT 19
12901: PUSH
12902: LD_INT 20
12904: PUSH
12905: LD_INT 21
12907: PUSH
12908: LD_INT 22
12910: PUSH
12911: LD_INT 23
12913: PUSH
12914: LD_INT 24
12916: PUSH
12917: LD_INT 25
12919: PUSH
12920: LD_INT 26
12922: PUSH
12923: LD_INT 27
12925: PUSH
12926: LD_INT 28
12928: PUSH
12929: LD_INT 30
12931: PUSH
12932: LD_INT 31
12934: PUSH
12935: LD_INT 32
12937: PUSH
12938: LD_INT 33
12940: PUSH
12941: LD_INT 34
12943: PUSH
12944: LD_INT 36
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: LIST
12951: LIST
12952: LIST
12953: LIST
12954: LIST
12955: LIST
12956: LIST
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: LIST
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: LIST
12982: PUSH
12983: LD_INT 101
12985: PUSH
12986: LD_INT 102
12988: PUSH
12989: LD_INT 103
12991: PUSH
12992: LD_INT 104
12994: PUSH
12995: LD_INT 105
12997: PUSH
12998: LD_INT 106
13000: PUSH
13001: LD_INT 107
13003: PUSH
13004: LD_INT 108
13006: PUSH
13007: LD_INT 109
13009: PUSH
13010: LD_INT 110
13012: PUSH
13013: LD_INT 111
13015: PUSH
13016: LD_INT 112
13018: PUSH
13019: LD_INT 113
13021: PUSH
13022: LD_INT 114
13024: PUSH
13025: EMPTY
13026: LIST
13027: LIST
13028: LIST
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: LIST
13038: LIST
13039: LIST
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: ST_TO_ADDR
13045: GO 14416
13047: LD_INT 13
13049: DOUBLE
13050: EQUAL
13051: IFTRUE 13055
13053: GO 13251
13055: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
13056: LD_ADDR_VAR 0 1
13060: PUSH
13061: LD_INT 1
13063: PUSH
13064: LD_INT 2
13066: PUSH
13067: LD_INT 3
13069: PUSH
13070: LD_INT 4
13072: PUSH
13073: LD_INT 5
13075: PUSH
13076: LD_INT 8
13078: PUSH
13079: LD_INT 9
13081: PUSH
13082: LD_INT 10
13084: PUSH
13085: LD_INT 11
13087: PUSH
13088: LD_INT 12
13090: PUSH
13091: LD_INT 14
13093: PUSH
13094: LD_INT 15
13096: PUSH
13097: LD_INT 16
13099: PUSH
13100: LD_INT 17
13102: PUSH
13103: LD_INT 18
13105: PUSH
13106: LD_INT 19
13108: PUSH
13109: LD_INT 20
13111: PUSH
13112: LD_INT 21
13114: PUSH
13115: LD_INT 22
13117: PUSH
13118: LD_INT 23
13120: PUSH
13121: LD_INT 24
13123: PUSH
13124: LD_INT 25
13126: PUSH
13127: LD_INT 26
13129: PUSH
13130: LD_INT 27
13132: PUSH
13133: LD_INT 28
13135: PUSH
13136: LD_INT 30
13138: PUSH
13139: LD_INT 31
13141: PUSH
13142: LD_INT 32
13144: PUSH
13145: LD_INT 33
13147: PUSH
13148: LD_INT 34
13150: PUSH
13151: LD_INT 36
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: LIST
13163: LIST
13164: LIST
13165: LIST
13166: LIST
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: PUSH
13187: LD_INT 101
13189: PUSH
13190: LD_INT 102
13192: PUSH
13193: LD_INT 103
13195: PUSH
13196: LD_INT 104
13198: PUSH
13199: LD_INT 105
13201: PUSH
13202: LD_INT 106
13204: PUSH
13205: LD_INT 107
13207: PUSH
13208: LD_INT 108
13210: PUSH
13211: LD_INT 109
13213: PUSH
13214: LD_INT 110
13216: PUSH
13217: LD_INT 111
13219: PUSH
13220: LD_INT 112
13222: PUSH
13223: LD_INT 113
13225: PUSH
13226: LD_INT 114
13228: PUSH
13229: EMPTY
13230: LIST
13231: LIST
13232: LIST
13233: LIST
13234: LIST
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: LIST
13244: PUSH
13245: EMPTY
13246: LIST
13247: LIST
13248: ST_TO_ADDR
13249: GO 14416
13251: LD_INT 14
13253: DOUBLE
13254: EQUAL
13255: IFTRUE 13259
13257: GO 13471
13259: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
13260: LD_ADDR_VAR 0 1
13264: PUSH
13265: LD_INT 1
13267: PUSH
13268: LD_INT 2
13270: PUSH
13271: LD_INT 3
13273: PUSH
13274: LD_INT 4
13276: PUSH
13277: LD_INT 5
13279: PUSH
13280: LD_INT 6
13282: PUSH
13283: LD_INT 7
13285: PUSH
13286: LD_INT 8
13288: PUSH
13289: LD_INT 9
13291: PUSH
13292: LD_INT 10
13294: PUSH
13295: LD_INT 11
13297: PUSH
13298: LD_INT 12
13300: PUSH
13301: LD_INT 13
13303: PUSH
13304: LD_INT 14
13306: PUSH
13307: LD_INT 15
13309: PUSH
13310: LD_INT 16
13312: PUSH
13313: LD_INT 17
13315: PUSH
13316: LD_INT 18
13318: PUSH
13319: LD_INT 19
13321: PUSH
13322: LD_INT 20
13324: PUSH
13325: LD_INT 21
13327: PUSH
13328: LD_INT 22
13330: PUSH
13331: LD_INT 23
13333: PUSH
13334: LD_INT 24
13336: PUSH
13337: LD_INT 25
13339: PUSH
13340: LD_INT 26
13342: PUSH
13343: LD_INT 27
13345: PUSH
13346: LD_INT 28
13348: PUSH
13349: LD_INT 29
13351: PUSH
13352: LD_INT 30
13354: PUSH
13355: LD_INT 31
13357: PUSH
13358: LD_INT 32
13360: PUSH
13361: LD_INT 33
13363: PUSH
13364: LD_INT 34
13366: PUSH
13367: LD_INT 36
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: LIST
13384: LIST
13385: LIST
13386: LIST
13387: LIST
13388: LIST
13389: LIST
13390: LIST
13391: LIST
13392: LIST
13393: LIST
13394: LIST
13395: LIST
13396: LIST
13397: LIST
13398: LIST
13399: LIST
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: LIST
13405: LIST
13406: PUSH
13407: LD_INT 101
13409: PUSH
13410: LD_INT 102
13412: PUSH
13413: LD_INT 103
13415: PUSH
13416: LD_INT 104
13418: PUSH
13419: LD_INT 105
13421: PUSH
13422: LD_INT 106
13424: PUSH
13425: LD_INT 107
13427: PUSH
13428: LD_INT 108
13430: PUSH
13431: LD_INT 109
13433: PUSH
13434: LD_INT 110
13436: PUSH
13437: LD_INT 111
13439: PUSH
13440: LD_INT 112
13442: PUSH
13443: LD_INT 113
13445: PUSH
13446: LD_INT 114
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: LIST
13455: LIST
13456: LIST
13457: LIST
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: LIST
13463: LIST
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: ST_TO_ADDR
13469: GO 14416
13471: LD_INT 15
13473: DOUBLE
13474: EQUAL
13475: IFTRUE 13479
13477: GO 13691
13479: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
13480: LD_ADDR_VAR 0 1
13484: PUSH
13485: LD_INT 1
13487: PUSH
13488: LD_INT 2
13490: PUSH
13491: LD_INT 3
13493: PUSH
13494: LD_INT 4
13496: PUSH
13497: LD_INT 5
13499: PUSH
13500: LD_INT 6
13502: PUSH
13503: LD_INT 7
13505: PUSH
13506: LD_INT 8
13508: PUSH
13509: LD_INT 9
13511: PUSH
13512: LD_INT 10
13514: PUSH
13515: LD_INT 11
13517: PUSH
13518: LD_INT 12
13520: PUSH
13521: LD_INT 13
13523: PUSH
13524: LD_INT 14
13526: PUSH
13527: LD_INT 15
13529: PUSH
13530: LD_INT 16
13532: PUSH
13533: LD_INT 17
13535: PUSH
13536: LD_INT 18
13538: PUSH
13539: LD_INT 19
13541: PUSH
13542: LD_INT 20
13544: PUSH
13545: LD_INT 21
13547: PUSH
13548: LD_INT 22
13550: PUSH
13551: LD_INT 23
13553: PUSH
13554: LD_INT 24
13556: PUSH
13557: LD_INT 25
13559: PUSH
13560: LD_INT 26
13562: PUSH
13563: LD_INT 27
13565: PUSH
13566: LD_INT 28
13568: PUSH
13569: LD_INT 29
13571: PUSH
13572: LD_INT 30
13574: PUSH
13575: LD_INT 31
13577: PUSH
13578: LD_INT 32
13580: PUSH
13581: LD_INT 33
13583: PUSH
13584: LD_INT 34
13586: PUSH
13587: LD_INT 36
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: LIST
13594: LIST
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: LIST
13602: LIST
13603: LIST
13604: LIST
13605: LIST
13606: LIST
13607: LIST
13608: LIST
13609: LIST
13610: LIST
13611: LIST
13612: LIST
13613: LIST
13614: LIST
13615: LIST
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: LIST
13625: LIST
13626: PUSH
13627: LD_INT 101
13629: PUSH
13630: LD_INT 102
13632: PUSH
13633: LD_INT 103
13635: PUSH
13636: LD_INT 104
13638: PUSH
13639: LD_INT 105
13641: PUSH
13642: LD_INT 106
13644: PUSH
13645: LD_INT 107
13647: PUSH
13648: LD_INT 108
13650: PUSH
13651: LD_INT 109
13653: PUSH
13654: LD_INT 110
13656: PUSH
13657: LD_INT 111
13659: PUSH
13660: LD_INT 112
13662: PUSH
13663: LD_INT 113
13665: PUSH
13666: LD_INT 114
13668: PUSH
13669: EMPTY
13670: LIST
13671: LIST
13672: LIST
13673: LIST
13674: LIST
13675: LIST
13676: LIST
13677: LIST
13678: LIST
13679: LIST
13680: LIST
13681: LIST
13682: LIST
13683: LIST
13684: PUSH
13685: EMPTY
13686: LIST
13687: LIST
13688: ST_TO_ADDR
13689: GO 14416
13691: LD_INT 16
13693: DOUBLE
13694: EQUAL
13695: IFTRUE 13699
13697: GO 13823
13699: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
13700: LD_ADDR_VAR 0 1
13704: PUSH
13705: LD_INT 2
13707: PUSH
13708: LD_INT 4
13710: PUSH
13711: LD_INT 5
13713: PUSH
13714: LD_INT 7
13716: PUSH
13717: LD_INT 11
13719: PUSH
13720: LD_INT 12
13722: PUSH
13723: LD_INT 15
13725: PUSH
13726: LD_INT 16
13728: PUSH
13729: LD_INT 20
13731: PUSH
13732: LD_INT 21
13734: PUSH
13735: LD_INT 22
13737: PUSH
13738: LD_INT 23
13740: PUSH
13741: LD_INT 25
13743: PUSH
13744: LD_INT 26
13746: PUSH
13747: LD_INT 30
13749: PUSH
13750: LD_INT 31
13752: PUSH
13753: LD_INT 32
13755: PUSH
13756: LD_INT 33
13758: PUSH
13759: LD_INT 34
13761: PUSH
13762: EMPTY
13763: LIST
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: LIST
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: LIST
13779: LIST
13780: LIST
13781: LIST
13782: PUSH
13783: LD_INT 101
13785: PUSH
13786: LD_INT 102
13788: PUSH
13789: LD_INT 103
13791: PUSH
13792: LD_INT 106
13794: PUSH
13795: LD_INT 108
13797: PUSH
13798: LD_INT 112
13800: PUSH
13801: LD_INT 113
13803: PUSH
13804: LD_INT 114
13806: PUSH
13807: EMPTY
13808: LIST
13809: LIST
13810: LIST
13811: LIST
13812: LIST
13813: LIST
13814: LIST
13815: LIST
13816: PUSH
13817: EMPTY
13818: LIST
13819: LIST
13820: ST_TO_ADDR
13821: GO 14416
13823: LD_INT 17
13825: DOUBLE
13826: EQUAL
13827: IFTRUE 13831
13829: GO 14043
13831: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
13832: LD_ADDR_VAR 0 1
13836: PUSH
13837: LD_INT 1
13839: PUSH
13840: LD_INT 2
13842: PUSH
13843: LD_INT 3
13845: PUSH
13846: LD_INT 4
13848: PUSH
13849: LD_INT 5
13851: PUSH
13852: LD_INT 6
13854: PUSH
13855: LD_INT 7
13857: PUSH
13858: LD_INT 8
13860: PUSH
13861: LD_INT 9
13863: PUSH
13864: LD_INT 10
13866: PUSH
13867: LD_INT 11
13869: PUSH
13870: LD_INT 12
13872: PUSH
13873: LD_INT 13
13875: PUSH
13876: LD_INT 14
13878: PUSH
13879: LD_INT 15
13881: PUSH
13882: LD_INT 16
13884: PUSH
13885: LD_INT 17
13887: PUSH
13888: LD_INT 18
13890: PUSH
13891: LD_INT 19
13893: PUSH
13894: LD_INT 20
13896: PUSH
13897: LD_INT 21
13899: PUSH
13900: LD_INT 22
13902: PUSH
13903: LD_INT 23
13905: PUSH
13906: LD_INT 24
13908: PUSH
13909: LD_INT 25
13911: PUSH
13912: LD_INT 26
13914: PUSH
13915: LD_INT 27
13917: PUSH
13918: LD_INT 28
13920: PUSH
13921: LD_INT 29
13923: PUSH
13924: LD_INT 30
13926: PUSH
13927: LD_INT 31
13929: PUSH
13930: LD_INT 32
13932: PUSH
13933: LD_INT 33
13935: PUSH
13936: LD_INT 34
13938: PUSH
13939: LD_INT 36
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: LIST
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: LIST
13965: LIST
13966: LIST
13967: LIST
13968: LIST
13969: LIST
13970: LIST
13971: LIST
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: LIST
13978: PUSH
13979: LD_INT 101
13981: PUSH
13982: LD_INT 102
13984: PUSH
13985: LD_INT 103
13987: PUSH
13988: LD_INT 104
13990: PUSH
13991: LD_INT 105
13993: PUSH
13994: LD_INT 106
13996: PUSH
13997: LD_INT 107
13999: PUSH
14000: LD_INT 108
14002: PUSH
14003: LD_INT 109
14005: PUSH
14006: LD_INT 110
14008: PUSH
14009: LD_INT 111
14011: PUSH
14012: LD_INT 112
14014: PUSH
14015: LD_INT 113
14017: PUSH
14018: LD_INT 114
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: LIST
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: ST_TO_ADDR
14041: GO 14416
14043: LD_INT 18
14045: DOUBLE
14046: EQUAL
14047: IFTRUE 14051
14049: GO 14187
14051: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
14052: LD_ADDR_VAR 0 1
14056: PUSH
14057: LD_INT 2
14059: PUSH
14060: LD_INT 4
14062: PUSH
14063: LD_INT 5
14065: PUSH
14066: LD_INT 7
14068: PUSH
14069: LD_INT 11
14071: PUSH
14072: LD_INT 12
14074: PUSH
14075: LD_INT 15
14077: PUSH
14078: LD_INT 16
14080: PUSH
14081: LD_INT 20
14083: PUSH
14084: LD_INT 21
14086: PUSH
14087: LD_INT 22
14089: PUSH
14090: LD_INT 23
14092: PUSH
14093: LD_INT 25
14095: PUSH
14096: LD_INT 26
14098: PUSH
14099: LD_INT 30
14101: PUSH
14102: LD_INT 31
14104: PUSH
14105: LD_INT 32
14107: PUSH
14108: LD_INT 33
14110: PUSH
14111: LD_INT 34
14113: PUSH
14114: LD_INT 35
14116: PUSH
14117: LD_INT 36
14119: PUSH
14120: EMPTY
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: PUSH
14143: LD_INT 101
14145: PUSH
14146: LD_INT 102
14148: PUSH
14149: LD_INT 103
14151: PUSH
14152: LD_INT 106
14154: PUSH
14155: LD_INT 108
14157: PUSH
14158: LD_INT 112
14160: PUSH
14161: LD_INT 113
14163: PUSH
14164: LD_INT 114
14166: PUSH
14167: LD_INT 115
14169: PUSH
14170: EMPTY
14171: LIST
14172: LIST
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: LIST
14180: PUSH
14181: EMPTY
14182: LIST
14183: LIST
14184: ST_TO_ADDR
14185: GO 14416
14187: LD_INT 19
14189: DOUBLE
14190: EQUAL
14191: IFTRUE 14195
14193: GO 14415
14195: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
14196: LD_ADDR_VAR 0 1
14200: PUSH
14201: LD_INT 1
14203: PUSH
14204: LD_INT 2
14206: PUSH
14207: LD_INT 3
14209: PUSH
14210: LD_INT 4
14212: PUSH
14213: LD_INT 5
14215: PUSH
14216: LD_INT 6
14218: PUSH
14219: LD_INT 7
14221: PUSH
14222: LD_INT 8
14224: PUSH
14225: LD_INT 9
14227: PUSH
14228: LD_INT 10
14230: PUSH
14231: LD_INT 11
14233: PUSH
14234: LD_INT 12
14236: PUSH
14237: LD_INT 13
14239: PUSH
14240: LD_INT 14
14242: PUSH
14243: LD_INT 15
14245: PUSH
14246: LD_INT 16
14248: PUSH
14249: LD_INT 17
14251: PUSH
14252: LD_INT 18
14254: PUSH
14255: LD_INT 19
14257: PUSH
14258: LD_INT 20
14260: PUSH
14261: LD_INT 21
14263: PUSH
14264: LD_INT 22
14266: PUSH
14267: LD_INT 23
14269: PUSH
14270: LD_INT 24
14272: PUSH
14273: LD_INT 25
14275: PUSH
14276: LD_INT 26
14278: PUSH
14279: LD_INT 27
14281: PUSH
14282: LD_INT 28
14284: PUSH
14285: LD_INT 29
14287: PUSH
14288: LD_INT 30
14290: PUSH
14291: LD_INT 31
14293: PUSH
14294: LD_INT 32
14296: PUSH
14297: LD_INT 33
14299: PUSH
14300: LD_INT 34
14302: PUSH
14303: LD_INT 35
14305: PUSH
14306: LD_INT 36
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: LIST
14313: LIST
14314: LIST
14315: LIST
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: PUSH
14347: LD_INT 101
14349: PUSH
14350: LD_INT 102
14352: PUSH
14353: LD_INT 103
14355: PUSH
14356: LD_INT 104
14358: PUSH
14359: LD_INT 105
14361: PUSH
14362: LD_INT 106
14364: PUSH
14365: LD_INT 107
14367: PUSH
14368: LD_INT 108
14370: PUSH
14371: LD_INT 109
14373: PUSH
14374: LD_INT 110
14376: PUSH
14377: LD_INT 111
14379: PUSH
14380: LD_INT 112
14382: PUSH
14383: LD_INT 113
14385: PUSH
14386: LD_INT 114
14388: PUSH
14389: LD_INT 115
14391: PUSH
14392: EMPTY
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: ST_TO_ADDR
14413: GO 14416
14415: POP
// end ; if result then
14416: LD_VAR 0 1
14420: IFFALSE 14709
// begin normal :=  ;
14422: LD_ADDR_VAR 0 3
14426: PUSH
14427: LD_STRING 
14429: ST_TO_ADDR
// hardcore :=  ;
14430: LD_ADDR_VAR 0 4
14434: PUSH
14435: LD_STRING 
14437: ST_TO_ADDR
// for i = 1 to normalCounter do
14438: LD_ADDR_VAR 0 5
14442: PUSH
14443: DOUBLE
14444: LD_INT 1
14446: DEC
14447: ST_TO_ADDR
14448: LD_EXP 31
14452: PUSH
14453: FOR_TO
14454: IFFALSE 14555
// begin tmp := 0 ;
14456: LD_ADDR_VAR 0 2
14460: PUSH
14461: LD_STRING 0
14463: ST_TO_ADDR
// if result [ 1 ] then
14464: LD_VAR 0 1
14468: PUSH
14469: LD_INT 1
14471: ARRAY
14472: IFFALSE 14537
// if result [ 1 ] [ 1 ] = i then
14474: LD_VAR 0 1
14478: PUSH
14479: LD_INT 1
14481: ARRAY
14482: PUSH
14483: LD_INT 1
14485: ARRAY
14486: PUSH
14487: LD_VAR 0 5
14491: EQUAL
14492: IFFALSE 14537
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
14494: LD_ADDR_VAR 0 1
14498: PUSH
14499: LD_VAR 0 1
14503: PPUSH
14504: LD_INT 1
14506: PPUSH
14507: LD_VAR 0 1
14511: PUSH
14512: LD_INT 1
14514: ARRAY
14515: PPUSH
14516: LD_INT 1
14518: PPUSH
14519: CALL_OW 3
14523: PPUSH
14524: CALL_OW 1
14528: ST_TO_ADDR
// tmp := 1 ;
14529: LD_ADDR_VAR 0 2
14533: PUSH
14534: LD_STRING 1
14536: ST_TO_ADDR
// end ; normal := normal & tmp ;
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_VAR 0 3
14546: PUSH
14547: LD_VAR 0 2
14551: STR
14552: ST_TO_ADDR
// end ;
14553: GO 14453
14555: POP
14556: POP
// for i = 1 to hardcoreCounter do
14557: LD_ADDR_VAR 0 5
14561: PUSH
14562: DOUBLE
14563: LD_INT 1
14565: DEC
14566: ST_TO_ADDR
14567: LD_EXP 32
14571: PUSH
14572: FOR_TO
14573: IFFALSE 14678
// begin tmp := 0 ;
14575: LD_ADDR_VAR 0 2
14579: PUSH
14580: LD_STRING 0
14582: ST_TO_ADDR
// if result [ 2 ] then
14583: LD_VAR 0 1
14587: PUSH
14588: LD_INT 2
14590: ARRAY
14591: IFFALSE 14660
// if result [ 2 ] [ 1 ] = 100 + i then
14593: LD_VAR 0 1
14597: PUSH
14598: LD_INT 2
14600: ARRAY
14601: PUSH
14602: LD_INT 1
14604: ARRAY
14605: PUSH
14606: LD_INT 100
14608: PUSH
14609: LD_VAR 0 5
14613: PLUS
14614: EQUAL
14615: IFFALSE 14660
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
14617: LD_ADDR_VAR 0 1
14621: PUSH
14622: LD_VAR 0 1
14626: PPUSH
14627: LD_INT 2
14629: PPUSH
14630: LD_VAR 0 1
14634: PUSH
14635: LD_INT 2
14637: ARRAY
14638: PPUSH
14639: LD_INT 1
14641: PPUSH
14642: CALL_OW 3
14646: PPUSH
14647: CALL_OW 1
14651: ST_TO_ADDR
// tmp := 1 ;
14652: LD_ADDR_VAR 0 2
14656: PUSH
14657: LD_STRING 1
14659: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
14660: LD_ADDR_VAR 0 4
14664: PUSH
14665: LD_VAR 0 4
14669: PUSH
14670: LD_VAR 0 2
14674: STR
14675: ST_TO_ADDR
// end ;
14676: GO 14572
14678: POP
14679: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
14680: LD_STRING getStreamItemsFromMission("
14682: PUSH
14683: LD_VAR 0 3
14687: STR
14688: PUSH
14689: LD_STRING ","
14691: STR
14692: PUSH
14693: LD_VAR 0 4
14697: STR
14698: PUSH
14699: LD_STRING ")
14701: STR
14702: PPUSH
14703: CALL_OW 559
// end else
14707: GO 14716
// ToLua ( getStreamItemsFromMission("","") ) ;
14709: LD_STRING getStreamItemsFromMission("","")
14711: PPUSH
14712: CALL_OW 559
// end ;
14716: LD_VAR 0 1
14720: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
14721: LD_VAR 0 2
14725: PUSH
14726: LD_INT 100
14728: EQUAL
14729: IFFALSE 15678
// begin if not StreamModeActive then
14731: LD_EXP 30
14735: NOT
14736: IFFALSE 14746
// StreamModeActive := true ;
14738: LD_ADDR_EXP 30
14742: PUSH
14743: LD_INT 1
14745: ST_TO_ADDR
// if p3 = 0 then
14746: LD_VAR 0 3
14750: PUSH
14751: LD_INT 0
14753: EQUAL
14754: IFFALSE 14760
// InitStreamMode ;
14756: CALL 11018 0 0
// if p3 = 1 then
14760: LD_VAR 0 3
14764: PUSH
14765: LD_INT 1
14767: EQUAL
14768: IFFALSE 14778
// sRocket := true ;
14770: LD_ADDR_EXP 35
14774: PUSH
14775: LD_INT 1
14777: ST_TO_ADDR
// if p3 = 2 then
14778: LD_VAR 0 3
14782: PUSH
14783: LD_INT 2
14785: EQUAL
14786: IFFALSE 14796
// sSpeed := true ;
14788: LD_ADDR_EXP 34
14792: PUSH
14793: LD_INT 1
14795: ST_TO_ADDR
// if p3 = 3 then
14796: LD_VAR 0 3
14800: PUSH
14801: LD_INT 3
14803: EQUAL
14804: IFFALSE 14814
// sEngine := true ;
14806: LD_ADDR_EXP 36
14810: PUSH
14811: LD_INT 1
14813: ST_TO_ADDR
// if p3 = 4 then
14814: LD_VAR 0 3
14818: PUSH
14819: LD_INT 4
14821: EQUAL
14822: IFFALSE 14832
// sSpec := true ;
14824: LD_ADDR_EXP 33
14828: PUSH
14829: LD_INT 1
14831: ST_TO_ADDR
// if p3 = 5 then
14832: LD_VAR 0 3
14836: PUSH
14837: LD_INT 5
14839: EQUAL
14840: IFFALSE 14850
// sLevel := true ;
14842: LD_ADDR_EXP 37
14846: PUSH
14847: LD_INT 1
14849: ST_TO_ADDR
// if p3 = 6 then
14850: LD_VAR 0 3
14854: PUSH
14855: LD_INT 6
14857: EQUAL
14858: IFFALSE 14868
// sArmoury := true ;
14860: LD_ADDR_EXP 38
14864: PUSH
14865: LD_INT 1
14867: ST_TO_ADDR
// if p3 = 7 then
14868: LD_VAR 0 3
14872: PUSH
14873: LD_INT 7
14875: EQUAL
14876: IFFALSE 14886
// sRadar := true ;
14878: LD_ADDR_EXP 39
14882: PUSH
14883: LD_INT 1
14885: ST_TO_ADDR
// if p3 = 8 then
14886: LD_VAR 0 3
14890: PUSH
14891: LD_INT 8
14893: EQUAL
14894: IFFALSE 14904
// sBunker := true ;
14896: LD_ADDR_EXP 40
14900: PUSH
14901: LD_INT 1
14903: ST_TO_ADDR
// if p3 = 9 then
14904: LD_VAR 0 3
14908: PUSH
14909: LD_INT 9
14911: EQUAL
14912: IFFALSE 14922
// sHack := true ;
14914: LD_ADDR_EXP 41
14918: PUSH
14919: LD_INT 1
14921: ST_TO_ADDR
// if p3 = 10 then
14922: LD_VAR 0 3
14926: PUSH
14927: LD_INT 10
14929: EQUAL
14930: IFFALSE 14940
// sFire := true ;
14932: LD_ADDR_EXP 42
14936: PUSH
14937: LD_INT 1
14939: ST_TO_ADDR
// if p3 = 11 then
14940: LD_VAR 0 3
14944: PUSH
14945: LD_INT 11
14947: EQUAL
14948: IFFALSE 14958
// sRefresh := true ;
14950: LD_ADDR_EXP 43
14954: PUSH
14955: LD_INT 1
14957: ST_TO_ADDR
// if p3 = 12 then
14958: LD_VAR 0 3
14962: PUSH
14963: LD_INT 12
14965: EQUAL
14966: IFFALSE 14976
// sExp := true ;
14968: LD_ADDR_EXP 44
14972: PUSH
14973: LD_INT 1
14975: ST_TO_ADDR
// if p3 = 13 then
14976: LD_VAR 0 3
14980: PUSH
14981: LD_INT 13
14983: EQUAL
14984: IFFALSE 14994
// sDepot := true ;
14986: LD_ADDR_EXP 45
14990: PUSH
14991: LD_INT 1
14993: ST_TO_ADDR
// if p3 = 14 then
14994: LD_VAR 0 3
14998: PUSH
14999: LD_INT 14
15001: EQUAL
15002: IFFALSE 15012
// sFlag := true ;
15004: LD_ADDR_EXP 46
15008: PUSH
15009: LD_INT 1
15011: ST_TO_ADDR
// if p3 = 15 then
15012: LD_VAR 0 3
15016: PUSH
15017: LD_INT 15
15019: EQUAL
15020: IFFALSE 15030
// sKamikadze := true ;
15022: LD_ADDR_EXP 54
15026: PUSH
15027: LD_INT 1
15029: ST_TO_ADDR
// if p3 = 16 then
15030: LD_VAR 0 3
15034: PUSH
15035: LD_INT 16
15037: EQUAL
15038: IFFALSE 15048
// sTroll := true ;
15040: LD_ADDR_EXP 55
15044: PUSH
15045: LD_INT 1
15047: ST_TO_ADDR
// if p3 = 17 then
15048: LD_VAR 0 3
15052: PUSH
15053: LD_INT 17
15055: EQUAL
15056: IFFALSE 15066
// sSlow := true ;
15058: LD_ADDR_EXP 56
15062: PUSH
15063: LD_INT 1
15065: ST_TO_ADDR
// if p3 = 18 then
15066: LD_VAR 0 3
15070: PUSH
15071: LD_INT 18
15073: EQUAL
15074: IFFALSE 15084
// sLack := true ;
15076: LD_ADDR_EXP 57
15080: PUSH
15081: LD_INT 1
15083: ST_TO_ADDR
// if p3 = 19 then
15084: LD_VAR 0 3
15088: PUSH
15089: LD_INT 19
15091: EQUAL
15092: IFFALSE 15102
// sTank := true ;
15094: LD_ADDR_EXP 59
15098: PUSH
15099: LD_INT 1
15101: ST_TO_ADDR
// if p3 = 20 then
15102: LD_VAR 0 3
15106: PUSH
15107: LD_INT 20
15109: EQUAL
15110: IFFALSE 15120
// sRemote := true ;
15112: LD_ADDR_EXP 60
15116: PUSH
15117: LD_INT 1
15119: ST_TO_ADDR
// if p3 = 21 then
15120: LD_VAR 0 3
15124: PUSH
15125: LD_INT 21
15127: EQUAL
15128: IFFALSE 15138
// sPowell := true ;
15130: LD_ADDR_EXP 61
15134: PUSH
15135: LD_INT 1
15137: ST_TO_ADDR
// if p3 = 22 then
15138: LD_VAR 0 3
15142: PUSH
15143: LD_INT 22
15145: EQUAL
15146: IFFALSE 15156
// sTeleport := true ;
15148: LD_ADDR_EXP 64
15152: PUSH
15153: LD_INT 1
15155: ST_TO_ADDR
// if p3 = 23 then
15156: LD_VAR 0 3
15160: PUSH
15161: LD_INT 23
15163: EQUAL
15164: IFFALSE 15174
// sOilTower := true ;
15166: LD_ADDR_EXP 66
15170: PUSH
15171: LD_INT 1
15173: ST_TO_ADDR
// if p3 = 24 then
15174: LD_VAR 0 3
15178: PUSH
15179: LD_INT 24
15181: EQUAL
15182: IFFALSE 15192
// sShovel := true ;
15184: LD_ADDR_EXP 67
15188: PUSH
15189: LD_INT 1
15191: ST_TO_ADDR
// if p3 = 25 then
15192: LD_VAR 0 3
15196: PUSH
15197: LD_INT 25
15199: EQUAL
15200: IFFALSE 15210
// sSheik := true ;
15202: LD_ADDR_EXP 68
15206: PUSH
15207: LD_INT 1
15209: ST_TO_ADDR
// if p3 = 26 then
15210: LD_VAR 0 3
15214: PUSH
15215: LD_INT 26
15217: EQUAL
15218: IFFALSE 15228
// sEarthquake := true ;
15220: LD_ADDR_EXP 70
15224: PUSH
15225: LD_INT 1
15227: ST_TO_ADDR
// if p3 = 27 then
15228: LD_VAR 0 3
15232: PUSH
15233: LD_INT 27
15235: EQUAL
15236: IFFALSE 15246
// sAI := true ;
15238: LD_ADDR_EXP 71
15242: PUSH
15243: LD_INT 1
15245: ST_TO_ADDR
// if p3 = 28 then
15246: LD_VAR 0 3
15250: PUSH
15251: LD_INT 28
15253: EQUAL
15254: IFFALSE 15264
// sCargo := true ;
15256: LD_ADDR_EXP 74
15260: PUSH
15261: LD_INT 1
15263: ST_TO_ADDR
// if p3 = 29 then
15264: LD_VAR 0 3
15268: PUSH
15269: LD_INT 29
15271: EQUAL
15272: IFFALSE 15282
// sDLaser := true ;
15274: LD_ADDR_EXP 75
15278: PUSH
15279: LD_INT 1
15281: ST_TO_ADDR
// if p3 = 30 then
15282: LD_VAR 0 3
15286: PUSH
15287: LD_INT 30
15289: EQUAL
15290: IFFALSE 15300
// sExchange := true ;
15292: LD_ADDR_EXP 76
15296: PUSH
15297: LD_INT 1
15299: ST_TO_ADDR
// if p3 = 31 then
15300: LD_VAR 0 3
15304: PUSH
15305: LD_INT 31
15307: EQUAL
15308: IFFALSE 15318
// sFac := true ;
15310: LD_ADDR_EXP 77
15314: PUSH
15315: LD_INT 1
15317: ST_TO_ADDR
// if p3 = 32 then
15318: LD_VAR 0 3
15322: PUSH
15323: LD_INT 32
15325: EQUAL
15326: IFFALSE 15336
// sPower := true ;
15328: LD_ADDR_EXP 78
15332: PUSH
15333: LD_INT 1
15335: ST_TO_ADDR
// if p3 = 33 then
15336: LD_VAR 0 3
15340: PUSH
15341: LD_INT 33
15343: EQUAL
15344: IFFALSE 15354
// sRandom := true ;
15346: LD_ADDR_EXP 79
15350: PUSH
15351: LD_INT 1
15353: ST_TO_ADDR
// if p3 = 34 then
15354: LD_VAR 0 3
15358: PUSH
15359: LD_INT 34
15361: EQUAL
15362: IFFALSE 15372
// sShield := true ;
15364: LD_ADDR_EXP 80
15368: PUSH
15369: LD_INT 1
15371: ST_TO_ADDR
// if p3 = 35 then
15372: LD_VAR 0 3
15376: PUSH
15377: LD_INT 35
15379: EQUAL
15380: IFFALSE 15390
// sTime := true ;
15382: LD_ADDR_EXP 81
15386: PUSH
15387: LD_INT 1
15389: ST_TO_ADDR
// if p3 = 36 then
15390: LD_VAR 0 3
15394: PUSH
15395: LD_INT 36
15397: EQUAL
15398: IFFALSE 15408
// sTools := true ;
15400: LD_ADDR_EXP 82
15404: PUSH
15405: LD_INT 1
15407: ST_TO_ADDR
// if p3 = 101 then
15408: LD_VAR 0 3
15412: PUSH
15413: LD_INT 101
15415: EQUAL
15416: IFFALSE 15426
// sSold := true ;
15418: LD_ADDR_EXP 47
15422: PUSH
15423: LD_INT 1
15425: ST_TO_ADDR
// if p3 = 102 then
15426: LD_VAR 0 3
15430: PUSH
15431: LD_INT 102
15433: EQUAL
15434: IFFALSE 15444
// sDiff := true ;
15436: LD_ADDR_EXP 48
15440: PUSH
15441: LD_INT 1
15443: ST_TO_ADDR
// if p3 = 103 then
15444: LD_VAR 0 3
15448: PUSH
15449: LD_INT 103
15451: EQUAL
15452: IFFALSE 15462
// sFog := true ;
15454: LD_ADDR_EXP 51
15458: PUSH
15459: LD_INT 1
15461: ST_TO_ADDR
// if p3 = 104 then
15462: LD_VAR 0 3
15466: PUSH
15467: LD_INT 104
15469: EQUAL
15470: IFFALSE 15480
// sReset := true ;
15472: LD_ADDR_EXP 52
15476: PUSH
15477: LD_INT 1
15479: ST_TO_ADDR
// if p3 = 105 then
15480: LD_VAR 0 3
15484: PUSH
15485: LD_INT 105
15487: EQUAL
15488: IFFALSE 15498
// sSun := true ;
15490: LD_ADDR_EXP 53
15494: PUSH
15495: LD_INT 1
15497: ST_TO_ADDR
// if p3 = 106 then
15498: LD_VAR 0 3
15502: PUSH
15503: LD_INT 106
15505: EQUAL
15506: IFFALSE 15516
// sTiger := true ;
15508: LD_ADDR_EXP 49
15512: PUSH
15513: LD_INT 1
15515: ST_TO_ADDR
// if p3 = 107 then
15516: LD_VAR 0 3
15520: PUSH
15521: LD_INT 107
15523: EQUAL
15524: IFFALSE 15534
// sBomb := true ;
15526: LD_ADDR_EXP 50
15530: PUSH
15531: LD_INT 1
15533: ST_TO_ADDR
// if p3 = 108 then
15534: LD_VAR 0 3
15538: PUSH
15539: LD_INT 108
15541: EQUAL
15542: IFFALSE 15552
// sWound := true ;
15544: LD_ADDR_EXP 58
15548: PUSH
15549: LD_INT 1
15551: ST_TO_ADDR
// if p3 = 109 then
15552: LD_VAR 0 3
15556: PUSH
15557: LD_INT 109
15559: EQUAL
15560: IFFALSE 15570
// sBetray := true ;
15562: LD_ADDR_EXP 62
15566: PUSH
15567: LD_INT 1
15569: ST_TO_ADDR
// if p3 = 110 then
15570: LD_VAR 0 3
15574: PUSH
15575: LD_INT 110
15577: EQUAL
15578: IFFALSE 15588
// sContamin := true ;
15580: LD_ADDR_EXP 63
15584: PUSH
15585: LD_INT 1
15587: ST_TO_ADDR
// if p3 = 111 then
15588: LD_VAR 0 3
15592: PUSH
15593: LD_INT 111
15595: EQUAL
15596: IFFALSE 15606
// sOil := true ;
15598: LD_ADDR_EXP 65
15602: PUSH
15603: LD_INT 1
15605: ST_TO_ADDR
// if p3 = 112 then
15606: LD_VAR 0 3
15610: PUSH
15611: LD_INT 112
15613: EQUAL
15614: IFFALSE 15624
// sStu := true ;
15616: LD_ADDR_EXP 69
15620: PUSH
15621: LD_INT 1
15623: ST_TO_ADDR
// if p3 = 113 then
15624: LD_VAR 0 3
15628: PUSH
15629: LD_INT 113
15631: EQUAL
15632: IFFALSE 15642
// sBazooka := true ;
15634: LD_ADDR_EXP 72
15638: PUSH
15639: LD_INT 1
15641: ST_TO_ADDR
// if p3 = 114 then
15642: LD_VAR 0 3
15646: PUSH
15647: LD_INT 114
15649: EQUAL
15650: IFFALSE 15660
// sMortar := true ;
15652: LD_ADDR_EXP 73
15656: PUSH
15657: LD_INT 1
15659: ST_TO_ADDR
// if p3 = 115 then
15660: LD_VAR 0 3
15664: PUSH
15665: LD_INT 115
15667: EQUAL
15668: IFFALSE 15678
// sRanger := true ;
15670: LD_ADDR_EXP 83
15674: PUSH
15675: LD_INT 1
15677: ST_TO_ADDR
// end ; end ;
15678: PPOPN 6
15680: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
15681: LD_EXP 30
15685: PUSH
15686: LD_EXP 35
15690: AND
15691: IFFALSE 15815
15693: GO 15695
15695: DISABLE
15696: LD_INT 0
15698: PPUSH
15699: PPUSH
// begin enable ;
15700: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
15701: LD_ADDR_VAR 0 2
15705: PUSH
15706: LD_INT 22
15708: PUSH
15709: LD_OWVAR 2
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: PUSH
15718: LD_INT 2
15720: PUSH
15721: LD_INT 34
15723: PUSH
15724: LD_INT 7
15726: PUSH
15727: EMPTY
15728: LIST
15729: LIST
15730: PUSH
15731: LD_INT 34
15733: PUSH
15734: LD_INT 45
15736: PUSH
15737: EMPTY
15738: LIST
15739: LIST
15740: PUSH
15741: LD_INT 34
15743: PUSH
15744: LD_INT 28
15746: PUSH
15747: EMPTY
15748: LIST
15749: LIST
15750: PUSH
15751: LD_INT 34
15753: PUSH
15754: LD_INT 47
15756: PUSH
15757: EMPTY
15758: LIST
15759: LIST
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: LIST
15765: LIST
15766: LIST
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PPUSH
15772: CALL_OW 69
15776: ST_TO_ADDR
// if not tmp then
15777: LD_VAR 0 2
15781: NOT
15782: IFFALSE 15786
// exit ;
15784: GO 15815
// for i in tmp do
15786: LD_ADDR_VAR 0 1
15790: PUSH
15791: LD_VAR 0 2
15795: PUSH
15796: FOR_IN
15797: IFFALSE 15813
// begin SetLives ( i , 0 ) ;
15799: LD_VAR 0 1
15803: PPUSH
15804: LD_INT 0
15806: PPUSH
15807: CALL_OW 234
// end ;
15811: GO 15796
15813: POP
15814: POP
// end ;
15815: PPOPN 2
15817: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
15818: LD_EXP 30
15822: PUSH
15823: LD_EXP 36
15827: AND
15828: IFFALSE 15912
15830: GO 15832
15832: DISABLE
15833: LD_INT 0
15835: PPUSH
15836: PPUSH
// begin enable ;
15837: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
15838: LD_ADDR_VAR 0 2
15842: PUSH
15843: LD_INT 22
15845: PUSH
15846: LD_OWVAR 2
15850: PUSH
15851: EMPTY
15852: LIST
15853: LIST
15854: PUSH
15855: LD_INT 32
15857: PUSH
15858: LD_INT 3
15860: PUSH
15861: EMPTY
15862: LIST
15863: LIST
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: PPUSH
15869: CALL_OW 69
15873: ST_TO_ADDR
// if not tmp then
15874: LD_VAR 0 2
15878: NOT
15879: IFFALSE 15883
// exit ;
15881: GO 15912
// for i in tmp do
15883: LD_ADDR_VAR 0 1
15887: PUSH
15888: LD_VAR 0 2
15892: PUSH
15893: FOR_IN
15894: IFFALSE 15910
// begin SetLives ( i , 0 ) ;
15896: LD_VAR 0 1
15900: PPUSH
15901: LD_INT 0
15903: PPUSH
15904: CALL_OW 234
// end ;
15908: GO 15893
15910: POP
15911: POP
// end ;
15912: PPOPN 2
15914: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
15915: LD_EXP 30
15919: PUSH
15920: LD_EXP 33
15924: AND
15925: IFFALSE 16018
15927: GO 15929
15929: DISABLE
15930: LD_INT 0
15932: PPUSH
// begin enable ;
15933: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
15934: LD_ADDR_VAR 0 1
15938: PUSH
15939: LD_INT 22
15941: PUSH
15942: LD_OWVAR 2
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: PUSH
15951: LD_INT 2
15953: PUSH
15954: LD_INT 25
15956: PUSH
15957: LD_INT 5
15959: PUSH
15960: EMPTY
15961: LIST
15962: LIST
15963: PUSH
15964: LD_INT 25
15966: PUSH
15967: LD_INT 9
15969: PUSH
15970: EMPTY
15971: LIST
15972: LIST
15973: PUSH
15974: LD_INT 25
15976: PUSH
15977: LD_INT 8
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: PUSH
15984: EMPTY
15985: LIST
15986: LIST
15987: LIST
15988: LIST
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PPUSH
15994: CALL_OW 69
15998: PUSH
15999: FOR_IN
16000: IFFALSE 16016
// begin SetClass ( i , 1 ) ;
16002: LD_VAR 0 1
16006: PPUSH
16007: LD_INT 1
16009: PPUSH
16010: CALL_OW 336
// end ;
16014: GO 15999
16016: POP
16017: POP
// end ;
16018: PPOPN 1
16020: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
16021: LD_EXP 30
16025: PUSH
16026: LD_EXP 34
16030: AND
16031: PUSH
16032: LD_OWVAR 65
16036: PUSH
16037: LD_INT 7
16039: LESS
16040: AND
16041: IFFALSE 16055
16043: GO 16045
16045: DISABLE
// begin enable ;
16046: ENABLE
// game_speed := 7 ;
16047: LD_ADDR_OWVAR 65
16051: PUSH
16052: LD_INT 7
16054: ST_TO_ADDR
// end ;
16055: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
16056: LD_EXP 30
16060: PUSH
16061: LD_EXP 37
16065: AND
16066: IFFALSE 16268
16068: GO 16070
16070: DISABLE
16071: LD_INT 0
16073: PPUSH
16074: PPUSH
16075: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
16076: LD_ADDR_VAR 0 3
16080: PUSH
16081: LD_INT 81
16083: PUSH
16084: LD_OWVAR 2
16088: PUSH
16089: EMPTY
16090: LIST
16091: LIST
16092: PUSH
16093: LD_INT 21
16095: PUSH
16096: LD_INT 1
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: PPUSH
16107: CALL_OW 69
16111: ST_TO_ADDR
// if not tmp then
16112: LD_VAR 0 3
16116: NOT
16117: IFFALSE 16121
// exit ;
16119: GO 16268
// if tmp > 5 then
16121: LD_VAR 0 3
16125: PUSH
16126: LD_INT 5
16128: GREATER
16129: IFFALSE 16141
// k := 5 else
16131: LD_ADDR_VAR 0 2
16135: PUSH
16136: LD_INT 5
16138: ST_TO_ADDR
16139: GO 16151
// k := tmp ;
16141: LD_ADDR_VAR 0 2
16145: PUSH
16146: LD_VAR 0 3
16150: ST_TO_ADDR
// for i := 1 to k do
16151: LD_ADDR_VAR 0 1
16155: PUSH
16156: DOUBLE
16157: LD_INT 1
16159: DEC
16160: ST_TO_ADDR
16161: LD_VAR 0 2
16165: PUSH
16166: FOR_TO
16167: IFFALSE 16266
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
16169: LD_VAR 0 3
16173: PUSH
16174: LD_VAR 0 1
16178: ARRAY
16179: PPUSH
16180: LD_VAR 0 1
16184: PUSH
16185: LD_INT 4
16187: MOD
16188: PUSH
16189: LD_INT 1
16191: PLUS
16192: PPUSH
16193: CALL_OW 259
16197: PUSH
16198: LD_INT 10
16200: LESS
16201: IFFALSE 16264
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
16203: LD_VAR 0 3
16207: PUSH
16208: LD_VAR 0 1
16212: ARRAY
16213: PPUSH
16214: LD_VAR 0 1
16218: PUSH
16219: LD_INT 4
16221: MOD
16222: PUSH
16223: LD_INT 1
16225: PLUS
16226: PPUSH
16227: LD_VAR 0 3
16231: PUSH
16232: LD_VAR 0 1
16236: ARRAY
16237: PPUSH
16238: LD_VAR 0 1
16242: PUSH
16243: LD_INT 4
16245: MOD
16246: PUSH
16247: LD_INT 1
16249: PLUS
16250: PPUSH
16251: CALL_OW 259
16255: PUSH
16256: LD_INT 1
16258: PLUS
16259: PPUSH
16260: CALL_OW 237
16264: GO 16166
16266: POP
16267: POP
// end ;
16268: PPOPN 3
16270: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
16271: LD_EXP 30
16275: PUSH
16276: LD_EXP 38
16280: AND
16281: IFFALSE 16301
16283: GO 16285
16285: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
16286: LD_INT 4
16288: PPUSH
16289: LD_OWVAR 2
16293: PPUSH
16294: LD_INT 0
16296: PPUSH
16297: CALL_OW 324
16301: END
// every 0 0$1 trigger StreamModeActive and sShovel do
16302: LD_EXP 30
16306: PUSH
16307: LD_EXP 67
16311: AND
16312: IFFALSE 16332
16314: GO 16316
16316: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
16317: LD_INT 19
16319: PPUSH
16320: LD_OWVAR 2
16324: PPUSH
16325: LD_INT 0
16327: PPUSH
16328: CALL_OW 324
16332: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
16333: LD_EXP 30
16337: PUSH
16338: LD_EXP 39
16342: AND
16343: IFFALSE 16445
16345: GO 16347
16347: DISABLE
16348: LD_INT 0
16350: PPUSH
16351: PPUSH
// begin enable ;
16352: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
16353: LD_ADDR_VAR 0 2
16357: PUSH
16358: LD_INT 22
16360: PUSH
16361: LD_OWVAR 2
16365: PUSH
16366: EMPTY
16367: LIST
16368: LIST
16369: PUSH
16370: LD_INT 2
16372: PUSH
16373: LD_INT 34
16375: PUSH
16376: LD_INT 11
16378: PUSH
16379: EMPTY
16380: LIST
16381: LIST
16382: PUSH
16383: LD_INT 34
16385: PUSH
16386: LD_INT 30
16388: PUSH
16389: EMPTY
16390: LIST
16391: LIST
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: LIST
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PPUSH
16402: CALL_OW 69
16406: ST_TO_ADDR
// if not tmp then
16407: LD_VAR 0 2
16411: NOT
16412: IFFALSE 16416
// exit ;
16414: GO 16445
// for i in tmp do
16416: LD_ADDR_VAR 0 1
16420: PUSH
16421: LD_VAR 0 2
16425: PUSH
16426: FOR_IN
16427: IFFALSE 16443
// begin SetLives ( i , 0 ) ;
16429: LD_VAR 0 1
16433: PPUSH
16434: LD_INT 0
16436: PPUSH
16437: CALL_OW 234
// end ;
16441: GO 16426
16443: POP
16444: POP
// end ;
16445: PPOPN 2
16447: END
// every 0 0$1 trigger StreamModeActive and sBunker do
16448: LD_EXP 30
16452: PUSH
16453: LD_EXP 40
16457: AND
16458: IFFALSE 16478
16460: GO 16462
16462: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
16463: LD_INT 32
16465: PPUSH
16466: LD_OWVAR 2
16470: PPUSH
16471: LD_INT 0
16473: PPUSH
16474: CALL_OW 324
16478: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
16479: LD_EXP 30
16483: PUSH
16484: LD_EXP 41
16488: AND
16489: IFFALSE 16670
16491: GO 16493
16493: DISABLE
16494: LD_INT 0
16496: PPUSH
16497: PPUSH
16498: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
16499: LD_ADDR_VAR 0 2
16503: PUSH
16504: LD_INT 22
16506: PUSH
16507: LD_OWVAR 2
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PUSH
16516: LD_INT 33
16518: PUSH
16519: LD_INT 3
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: PUSH
16526: EMPTY
16527: LIST
16528: LIST
16529: PPUSH
16530: CALL_OW 69
16534: ST_TO_ADDR
// if not tmp then
16535: LD_VAR 0 2
16539: NOT
16540: IFFALSE 16544
// exit ;
16542: GO 16670
// side := 0 ;
16544: LD_ADDR_VAR 0 3
16548: PUSH
16549: LD_INT 0
16551: ST_TO_ADDR
// for i := 1 to 8 do
16552: LD_ADDR_VAR 0 1
16556: PUSH
16557: DOUBLE
16558: LD_INT 1
16560: DEC
16561: ST_TO_ADDR
16562: LD_INT 8
16564: PUSH
16565: FOR_TO
16566: IFFALSE 16614
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
16568: LD_OWVAR 2
16572: PUSH
16573: LD_VAR 0 1
16577: NONEQUAL
16578: PUSH
16579: LD_OWVAR 2
16583: PPUSH
16584: LD_VAR 0 1
16588: PPUSH
16589: CALL_OW 81
16593: PUSH
16594: LD_INT 2
16596: EQUAL
16597: AND
16598: IFFALSE 16612
// begin side := i ;
16600: LD_ADDR_VAR 0 3
16604: PUSH
16605: LD_VAR 0 1
16609: ST_TO_ADDR
// break ;
16610: GO 16614
// end ;
16612: GO 16565
16614: POP
16615: POP
// if not side then
16616: LD_VAR 0 3
16620: NOT
16621: IFFALSE 16625
// exit ;
16623: GO 16670
// for i := 1 to tmp do
16625: LD_ADDR_VAR 0 1
16629: PUSH
16630: DOUBLE
16631: LD_INT 1
16633: DEC
16634: ST_TO_ADDR
16635: LD_VAR 0 2
16639: PUSH
16640: FOR_TO
16641: IFFALSE 16668
// if Prob ( 60 ) then
16643: LD_INT 60
16645: PPUSH
16646: CALL_OW 13
16650: IFFALSE 16666
// SetSide ( i , side ) ;
16652: LD_VAR 0 1
16656: PPUSH
16657: LD_VAR 0 3
16661: PPUSH
16662: CALL_OW 235
16666: GO 16640
16668: POP
16669: POP
// end ;
16670: PPOPN 3
16672: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
16673: LD_EXP 30
16677: PUSH
16678: LD_EXP 43
16682: AND
16683: IFFALSE 16802
16685: GO 16687
16687: DISABLE
16688: LD_INT 0
16690: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
16691: LD_ADDR_VAR 0 1
16695: PUSH
16696: LD_INT 22
16698: PUSH
16699: LD_OWVAR 2
16703: PUSH
16704: EMPTY
16705: LIST
16706: LIST
16707: PUSH
16708: LD_INT 21
16710: PUSH
16711: LD_INT 1
16713: PUSH
16714: EMPTY
16715: LIST
16716: LIST
16717: PUSH
16718: LD_INT 3
16720: PUSH
16721: LD_INT 23
16723: PUSH
16724: LD_INT 0
16726: PUSH
16727: EMPTY
16728: LIST
16729: LIST
16730: PUSH
16731: EMPTY
16732: LIST
16733: LIST
16734: PUSH
16735: EMPTY
16736: LIST
16737: LIST
16738: LIST
16739: PPUSH
16740: CALL_OW 69
16744: PUSH
16745: FOR_IN
16746: IFFALSE 16800
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
16748: LD_VAR 0 1
16752: PPUSH
16753: CALL_OW 257
16757: PUSH
16758: LD_INT 1
16760: PUSH
16761: LD_INT 2
16763: PUSH
16764: LD_INT 3
16766: PUSH
16767: LD_INT 4
16769: PUSH
16770: EMPTY
16771: LIST
16772: LIST
16773: LIST
16774: LIST
16775: IN
16776: IFFALSE 16798
// SetClass ( un , rand ( 1 , 4 ) ) ;
16778: LD_VAR 0 1
16782: PPUSH
16783: LD_INT 1
16785: PPUSH
16786: LD_INT 4
16788: PPUSH
16789: CALL_OW 12
16793: PPUSH
16794: CALL_OW 336
16798: GO 16745
16800: POP
16801: POP
// end ;
16802: PPOPN 1
16804: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
16805: LD_EXP 30
16809: PUSH
16810: LD_EXP 42
16814: AND
16815: IFFALSE 16894
16817: GO 16819
16819: DISABLE
16820: LD_INT 0
16822: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
16823: LD_ADDR_VAR 0 1
16827: PUSH
16828: LD_INT 22
16830: PUSH
16831: LD_OWVAR 2
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: LD_INT 21
16842: PUSH
16843: LD_INT 3
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: PPUSH
16854: CALL_OW 69
16858: ST_TO_ADDR
// if not tmp then
16859: LD_VAR 0 1
16863: NOT
16864: IFFALSE 16868
// exit ;
16866: GO 16894
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
16868: LD_VAR 0 1
16872: PUSH
16873: LD_INT 1
16875: PPUSH
16876: LD_VAR 0 1
16880: PPUSH
16881: CALL_OW 12
16885: ARRAY
16886: PPUSH
16887: LD_INT 100
16889: PPUSH
16890: CALL_OW 234
// end ;
16894: PPOPN 1
16896: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
16897: LD_EXP 30
16901: PUSH
16902: LD_EXP 44
16906: AND
16907: IFFALSE 17005
16909: GO 16911
16911: DISABLE
16912: LD_INT 0
16914: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
16915: LD_ADDR_VAR 0 1
16919: PUSH
16920: LD_INT 22
16922: PUSH
16923: LD_OWVAR 2
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PUSH
16932: LD_INT 21
16934: PUSH
16935: LD_INT 1
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: PUSH
16942: EMPTY
16943: LIST
16944: LIST
16945: PPUSH
16946: CALL_OW 69
16950: ST_TO_ADDR
// if not tmp then
16951: LD_VAR 0 1
16955: NOT
16956: IFFALSE 16960
// exit ;
16958: GO 17005
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
16960: LD_VAR 0 1
16964: PUSH
16965: LD_INT 1
16967: PPUSH
16968: LD_VAR 0 1
16972: PPUSH
16973: CALL_OW 12
16977: ARRAY
16978: PPUSH
16979: LD_INT 1
16981: PPUSH
16982: LD_INT 4
16984: PPUSH
16985: CALL_OW 12
16989: PPUSH
16990: LD_INT 3000
16992: PPUSH
16993: LD_INT 9000
16995: PPUSH
16996: CALL_OW 12
17000: PPUSH
17001: CALL_OW 492
// end ;
17005: PPOPN 1
17007: END
// every 0 0$1 trigger StreamModeActive and sDepot do
17008: LD_EXP 30
17012: PUSH
17013: LD_EXP 45
17017: AND
17018: IFFALSE 17038
17020: GO 17022
17022: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
17023: LD_INT 1
17025: PPUSH
17026: LD_OWVAR 2
17030: PPUSH
17031: LD_INT 0
17033: PPUSH
17034: CALL_OW 324
17038: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
17039: LD_EXP 30
17043: PUSH
17044: LD_EXP 46
17048: AND
17049: IFFALSE 17132
17051: GO 17053
17053: DISABLE
17054: LD_INT 0
17056: PPUSH
17057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
17058: LD_ADDR_VAR 0 2
17062: PUSH
17063: LD_INT 22
17065: PUSH
17066: LD_OWVAR 2
17070: PUSH
17071: EMPTY
17072: LIST
17073: LIST
17074: PUSH
17075: LD_INT 21
17077: PUSH
17078: LD_INT 3
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: PUSH
17085: EMPTY
17086: LIST
17087: LIST
17088: PPUSH
17089: CALL_OW 69
17093: ST_TO_ADDR
// if not tmp then
17094: LD_VAR 0 2
17098: NOT
17099: IFFALSE 17103
// exit ;
17101: GO 17132
// for i in tmp do
17103: LD_ADDR_VAR 0 1
17107: PUSH
17108: LD_VAR 0 2
17112: PUSH
17113: FOR_IN
17114: IFFALSE 17130
// SetBLevel ( i , 10 ) ;
17116: LD_VAR 0 1
17120: PPUSH
17121: LD_INT 10
17123: PPUSH
17124: CALL_OW 241
17128: GO 17113
17130: POP
17131: POP
// end ;
17132: PPOPN 2
17134: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
17135: LD_EXP 30
17139: PUSH
17140: LD_EXP 47
17144: AND
17145: IFFALSE 17256
17147: GO 17149
17149: DISABLE
17150: LD_INT 0
17152: PPUSH
17153: PPUSH
17154: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
17155: LD_ADDR_VAR 0 3
17159: PUSH
17160: LD_INT 22
17162: PUSH
17163: LD_OWVAR 2
17167: PUSH
17168: EMPTY
17169: LIST
17170: LIST
17171: PUSH
17172: LD_INT 25
17174: PUSH
17175: LD_INT 1
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: PUSH
17182: EMPTY
17183: LIST
17184: LIST
17185: PPUSH
17186: CALL_OW 69
17190: ST_TO_ADDR
// if not tmp then
17191: LD_VAR 0 3
17195: NOT
17196: IFFALSE 17200
// exit ;
17198: GO 17256
// un := tmp [ rand ( 1 , tmp ) ] ;
17200: LD_ADDR_VAR 0 2
17204: PUSH
17205: LD_VAR 0 3
17209: PUSH
17210: LD_INT 1
17212: PPUSH
17213: LD_VAR 0 3
17217: PPUSH
17218: CALL_OW 12
17222: ARRAY
17223: ST_TO_ADDR
// if Crawls ( un ) then
17224: LD_VAR 0 2
17228: PPUSH
17229: CALL_OW 318
17233: IFFALSE 17244
// ComWalk ( un ) ;
17235: LD_VAR 0 2
17239: PPUSH
17240: CALL_OW 138
// SetClass ( un , class_sniper ) ;
17244: LD_VAR 0 2
17248: PPUSH
17249: LD_INT 5
17251: PPUSH
17252: CALL_OW 336
// end ;
17256: PPOPN 3
17258: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
17259: LD_EXP 30
17263: PUSH
17264: LD_EXP 48
17268: AND
17269: PUSH
17270: LD_OWVAR 67
17274: PUSH
17275: LD_INT 3
17277: LESS
17278: AND
17279: IFFALSE 17298
17281: GO 17283
17283: DISABLE
// Difficulty := Difficulty + 1 ;
17284: LD_ADDR_OWVAR 67
17288: PUSH
17289: LD_OWVAR 67
17293: PUSH
17294: LD_INT 1
17296: PLUS
17297: ST_TO_ADDR
17298: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
17299: LD_EXP 30
17303: PUSH
17304: LD_EXP 49
17308: AND
17309: IFFALSE 17412
17311: GO 17313
17313: DISABLE
17314: LD_INT 0
17316: PPUSH
// begin for i := 1 to 5 do
17317: LD_ADDR_VAR 0 1
17321: PUSH
17322: DOUBLE
17323: LD_INT 1
17325: DEC
17326: ST_TO_ADDR
17327: LD_INT 5
17329: PUSH
17330: FOR_TO
17331: IFFALSE 17410
// begin uc_nation := nation_nature ;
17333: LD_ADDR_OWVAR 21
17337: PUSH
17338: LD_INT 0
17340: ST_TO_ADDR
// uc_side := 0 ;
17341: LD_ADDR_OWVAR 20
17345: PUSH
17346: LD_INT 0
17348: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17349: LD_ADDR_OWVAR 29
17353: PUSH
17354: LD_INT 12
17356: PUSH
17357: LD_INT 12
17359: PUSH
17360: EMPTY
17361: LIST
17362: LIST
17363: ST_TO_ADDR
// hc_agressivity := 20 ;
17364: LD_ADDR_OWVAR 35
17368: PUSH
17369: LD_INT 20
17371: ST_TO_ADDR
// hc_class := class_tiger ;
17372: LD_ADDR_OWVAR 28
17376: PUSH
17377: LD_INT 14
17379: ST_TO_ADDR
// hc_gallery :=  ;
17380: LD_ADDR_OWVAR 33
17384: PUSH
17385: LD_STRING 
17387: ST_TO_ADDR
// hc_name :=  ;
17388: LD_ADDR_OWVAR 26
17392: PUSH
17393: LD_STRING 
17395: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
17396: CALL_OW 44
17400: PPUSH
17401: LD_INT 0
17403: PPUSH
17404: CALL_OW 51
// end ;
17408: GO 17330
17410: POP
17411: POP
// end ;
17412: PPOPN 1
17414: END
// every 0 0$1 trigger StreamModeActive and sBomb do
17415: LD_EXP 30
17419: PUSH
17420: LD_EXP 50
17424: AND
17425: IFFALSE 17434
17427: GO 17429
17429: DISABLE
// StreamSibBomb ;
17430: CALL 17435 0 0
17434: END
// export function StreamSibBomb ; var i , x , y ; begin
17435: LD_INT 0
17437: PPUSH
17438: PPUSH
17439: PPUSH
17440: PPUSH
// result := false ;
17441: LD_ADDR_VAR 0 1
17445: PUSH
17446: LD_INT 0
17448: ST_TO_ADDR
// for i := 1 to 16 do
17449: LD_ADDR_VAR 0 2
17453: PUSH
17454: DOUBLE
17455: LD_INT 1
17457: DEC
17458: ST_TO_ADDR
17459: LD_INT 16
17461: PUSH
17462: FOR_TO
17463: IFFALSE 17662
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17465: LD_ADDR_VAR 0 3
17469: PUSH
17470: LD_INT 10
17472: PUSH
17473: LD_INT 20
17475: PUSH
17476: LD_INT 30
17478: PUSH
17479: LD_INT 40
17481: PUSH
17482: LD_INT 50
17484: PUSH
17485: LD_INT 60
17487: PUSH
17488: LD_INT 70
17490: PUSH
17491: LD_INT 80
17493: PUSH
17494: LD_INT 90
17496: PUSH
17497: LD_INT 100
17499: PUSH
17500: LD_INT 110
17502: PUSH
17503: LD_INT 120
17505: PUSH
17506: LD_INT 130
17508: PUSH
17509: LD_INT 140
17511: PUSH
17512: LD_INT 150
17514: PUSH
17515: EMPTY
17516: LIST
17517: LIST
17518: LIST
17519: LIST
17520: LIST
17521: LIST
17522: LIST
17523: LIST
17524: LIST
17525: LIST
17526: LIST
17527: LIST
17528: LIST
17529: LIST
17530: LIST
17531: PUSH
17532: LD_INT 1
17534: PPUSH
17535: LD_INT 15
17537: PPUSH
17538: CALL_OW 12
17542: ARRAY
17543: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
17544: LD_ADDR_VAR 0 4
17548: PUSH
17549: LD_INT 10
17551: PUSH
17552: LD_INT 20
17554: PUSH
17555: LD_INT 30
17557: PUSH
17558: LD_INT 40
17560: PUSH
17561: LD_INT 50
17563: PUSH
17564: LD_INT 60
17566: PUSH
17567: LD_INT 70
17569: PUSH
17570: LD_INT 80
17572: PUSH
17573: LD_INT 90
17575: PUSH
17576: LD_INT 100
17578: PUSH
17579: LD_INT 110
17581: PUSH
17582: LD_INT 120
17584: PUSH
17585: LD_INT 130
17587: PUSH
17588: LD_INT 140
17590: PUSH
17591: LD_INT 150
17593: PUSH
17594: EMPTY
17595: LIST
17596: LIST
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: LIST
17607: LIST
17608: LIST
17609: LIST
17610: PUSH
17611: LD_INT 1
17613: PPUSH
17614: LD_INT 15
17616: PPUSH
17617: CALL_OW 12
17621: ARRAY
17622: ST_TO_ADDR
// if ValidHex ( x , y ) then
17623: LD_VAR 0 3
17627: PPUSH
17628: LD_VAR 0 4
17632: PPUSH
17633: CALL_OW 488
17637: IFFALSE 17660
// begin result := [ x , y ] ;
17639: LD_ADDR_VAR 0 1
17643: PUSH
17644: LD_VAR 0 3
17648: PUSH
17649: LD_VAR 0 4
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: ST_TO_ADDR
// break ;
17658: GO 17662
// end ; end ;
17660: GO 17462
17662: POP
17663: POP
// if result then
17664: LD_VAR 0 1
17668: IFFALSE 17728
// begin ToLua ( playSibBomb() ) ;
17670: LD_STRING playSibBomb()
17672: PPUSH
17673: CALL_OW 559
// wait ( 0 0$14 ) ;
17677: LD_INT 490
17679: PPUSH
17680: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
17684: LD_VAR 0 1
17688: PUSH
17689: LD_INT 1
17691: ARRAY
17692: PPUSH
17693: LD_VAR 0 1
17697: PUSH
17698: LD_INT 2
17700: ARRAY
17701: PPUSH
17702: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
17706: LD_VAR 0 1
17710: PUSH
17711: LD_INT 1
17713: ARRAY
17714: PPUSH
17715: LD_VAR 0 1
17719: PUSH
17720: LD_INT 2
17722: ARRAY
17723: PPUSH
17724: CALL_OW 429
// end ; end ;
17728: LD_VAR 0 1
17732: RET
// every 0 0$1 trigger StreamModeActive and sReset do
17733: LD_EXP 30
17737: PUSH
17738: LD_EXP 52
17742: AND
17743: IFFALSE 17755
17745: GO 17747
17747: DISABLE
// YouLost (  ) ;
17748: LD_STRING 
17750: PPUSH
17751: CALL_OW 104
17755: END
// every 0 0$1 trigger StreamModeActive and sFog do
17756: LD_EXP 30
17760: PUSH
17761: LD_EXP 51
17765: AND
17766: IFFALSE 17780
17768: GO 17770
17770: DISABLE
// FogOff ( your_side ) ;
17771: LD_OWVAR 2
17775: PPUSH
17776: CALL_OW 344
17780: END
// every 0 0$1 trigger StreamModeActive and sSun do
17781: LD_EXP 30
17785: PUSH
17786: LD_EXP 53
17790: AND
17791: IFFALSE 17819
17793: GO 17795
17795: DISABLE
// begin solar_recharge_percent := 0 ;
17796: LD_ADDR_OWVAR 79
17800: PUSH
17801: LD_INT 0
17803: ST_TO_ADDR
// wait ( 5 5$00 ) ;
17804: LD_INT 10500
17806: PPUSH
17807: CALL_OW 67
// solar_recharge_percent := 100 ;
17811: LD_ADDR_OWVAR 79
17815: PUSH
17816: LD_INT 100
17818: ST_TO_ADDR
// end ;
17819: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
17820: LD_EXP 30
17824: PUSH
17825: LD_EXP 54
17829: AND
17830: IFFALSE 18069
17832: GO 17834
17834: DISABLE
17835: LD_INT 0
17837: PPUSH
17838: PPUSH
17839: PPUSH
// begin tmp := [ ] ;
17840: LD_ADDR_VAR 0 3
17844: PUSH
17845: EMPTY
17846: ST_TO_ADDR
// for i := 1 to 6 do
17847: LD_ADDR_VAR 0 1
17851: PUSH
17852: DOUBLE
17853: LD_INT 1
17855: DEC
17856: ST_TO_ADDR
17857: LD_INT 6
17859: PUSH
17860: FOR_TO
17861: IFFALSE 17966
// begin uc_nation := nation_nature ;
17863: LD_ADDR_OWVAR 21
17867: PUSH
17868: LD_INT 0
17870: ST_TO_ADDR
// uc_side := 0 ;
17871: LD_ADDR_OWVAR 20
17875: PUSH
17876: LD_INT 0
17878: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
17879: LD_ADDR_OWVAR 29
17883: PUSH
17884: LD_INT 12
17886: PUSH
17887: LD_INT 12
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: ST_TO_ADDR
// hc_agressivity := 20 ;
17894: LD_ADDR_OWVAR 35
17898: PUSH
17899: LD_INT 20
17901: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
17902: LD_ADDR_OWVAR 28
17906: PUSH
17907: LD_INT 17
17909: ST_TO_ADDR
// hc_gallery :=  ;
17910: LD_ADDR_OWVAR 33
17914: PUSH
17915: LD_STRING 
17917: ST_TO_ADDR
// hc_name :=  ;
17918: LD_ADDR_OWVAR 26
17922: PUSH
17923: LD_STRING 
17925: ST_TO_ADDR
// un := CreateHuman ;
17926: LD_ADDR_VAR 0 2
17930: PUSH
17931: CALL_OW 44
17935: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
17936: LD_VAR 0 2
17940: PPUSH
17941: LD_INT 1
17943: PPUSH
17944: CALL_OW 51
// tmp := tmp ^ un ;
17948: LD_ADDR_VAR 0 3
17952: PUSH
17953: LD_VAR 0 3
17957: PUSH
17958: LD_VAR 0 2
17962: ADD
17963: ST_TO_ADDR
// end ;
17964: GO 17860
17966: POP
17967: POP
// repeat wait ( 0 0$1 ) ;
17968: LD_INT 35
17970: PPUSH
17971: CALL_OW 67
// for un in tmp do
17975: LD_ADDR_VAR 0 2
17979: PUSH
17980: LD_VAR 0 3
17984: PUSH
17985: FOR_IN
17986: IFFALSE 18060
// begin if IsDead ( un ) then
17988: LD_VAR 0 2
17992: PPUSH
17993: CALL_OW 301
17997: IFFALSE 18017
// begin tmp := tmp diff un ;
17999: LD_ADDR_VAR 0 3
18003: PUSH
18004: LD_VAR 0 3
18008: PUSH
18009: LD_VAR 0 2
18013: DIFF
18014: ST_TO_ADDR
// continue ;
18015: GO 17985
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
18017: LD_VAR 0 2
18021: PPUSH
18022: LD_INT 3
18024: PUSH
18025: LD_INT 22
18027: PUSH
18028: LD_INT 0
18030: PUSH
18031: EMPTY
18032: LIST
18033: LIST
18034: PUSH
18035: EMPTY
18036: LIST
18037: LIST
18038: PPUSH
18039: CALL_OW 69
18043: PPUSH
18044: LD_VAR 0 2
18048: PPUSH
18049: CALL_OW 74
18053: PPUSH
18054: CALL_OW 115
// end ;
18058: GO 17985
18060: POP
18061: POP
// until not tmp ;
18062: LD_VAR 0 3
18066: NOT
18067: IFFALSE 17968
// end ;
18069: PPOPN 3
18071: END
// every 0 0$1 trigger StreamModeActive and sTroll do
18072: LD_EXP 30
18076: PUSH
18077: LD_EXP 55
18081: AND
18082: IFFALSE 18136
18084: GO 18086
18086: DISABLE
// begin ToLua ( displayTroll(); ) ;
18087: LD_STRING displayTroll();
18089: PPUSH
18090: CALL_OW 559
// wait ( 3 3$00 ) ;
18094: LD_INT 6300
18096: PPUSH
18097: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18101: LD_STRING hideTroll();
18103: PPUSH
18104: CALL_OW 559
// wait ( 1 1$00 ) ;
18108: LD_INT 2100
18110: PPUSH
18111: CALL_OW 67
// ToLua ( displayTroll(); ) ;
18115: LD_STRING displayTroll();
18117: PPUSH
18118: CALL_OW 559
// wait ( 1 1$00 ) ;
18122: LD_INT 2100
18124: PPUSH
18125: CALL_OW 67
// ToLua ( hideTroll(); ) ;
18129: LD_STRING hideTroll();
18131: PPUSH
18132: CALL_OW 559
// end ;
18136: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
18137: LD_EXP 30
18141: PUSH
18142: LD_EXP 56
18146: AND
18147: IFFALSE 18210
18149: GO 18151
18151: DISABLE
18152: LD_INT 0
18154: PPUSH
// begin p := 0 ;
18155: LD_ADDR_VAR 0 1
18159: PUSH
18160: LD_INT 0
18162: ST_TO_ADDR
// repeat game_speed := 1 ;
18163: LD_ADDR_OWVAR 65
18167: PUSH
18168: LD_INT 1
18170: ST_TO_ADDR
// wait ( 0 0$1 ) ;
18171: LD_INT 35
18173: PPUSH
18174: CALL_OW 67
// p := p + 1 ;
18178: LD_ADDR_VAR 0 1
18182: PUSH
18183: LD_VAR 0 1
18187: PUSH
18188: LD_INT 1
18190: PLUS
18191: ST_TO_ADDR
// until p >= 60 ;
18192: LD_VAR 0 1
18196: PUSH
18197: LD_INT 60
18199: GREATEREQUAL
18200: IFFALSE 18163
// game_speed := 4 ;
18202: LD_ADDR_OWVAR 65
18206: PUSH
18207: LD_INT 4
18209: ST_TO_ADDR
// end ;
18210: PPOPN 1
18212: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
18213: LD_EXP 30
18217: PUSH
18218: LD_EXP 57
18222: AND
18223: IFFALSE 18369
18225: GO 18227
18227: DISABLE
18228: LD_INT 0
18230: PPUSH
18231: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
18232: LD_ADDR_VAR 0 1
18236: PUSH
18237: LD_INT 22
18239: PUSH
18240: LD_OWVAR 2
18244: PUSH
18245: EMPTY
18246: LIST
18247: LIST
18248: PUSH
18249: LD_INT 2
18251: PUSH
18252: LD_INT 30
18254: PUSH
18255: LD_INT 0
18257: PUSH
18258: EMPTY
18259: LIST
18260: LIST
18261: PUSH
18262: LD_INT 30
18264: PUSH
18265: LD_INT 1
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: PUSH
18272: EMPTY
18273: LIST
18274: LIST
18275: LIST
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: PPUSH
18281: CALL_OW 69
18285: ST_TO_ADDR
// if not depot then
18286: LD_VAR 0 1
18290: NOT
18291: IFFALSE 18295
// exit ;
18293: GO 18369
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
18295: LD_ADDR_VAR 0 2
18299: PUSH
18300: LD_VAR 0 1
18304: PUSH
18305: LD_INT 1
18307: PPUSH
18308: LD_VAR 0 1
18312: PPUSH
18313: CALL_OW 12
18317: ARRAY
18318: PPUSH
18319: CALL_OW 274
18323: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
18324: LD_VAR 0 2
18328: PPUSH
18329: LD_INT 1
18331: PPUSH
18332: LD_INT 0
18334: PPUSH
18335: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
18339: LD_VAR 0 2
18343: PPUSH
18344: LD_INT 2
18346: PPUSH
18347: LD_INT 0
18349: PPUSH
18350: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
18354: LD_VAR 0 2
18358: PPUSH
18359: LD_INT 3
18361: PPUSH
18362: LD_INT 0
18364: PPUSH
18365: CALL_OW 277
// end ;
18369: PPOPN 2
18371: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
18372: LD_EXP 30
18376: PUSH
18377: LD_EXP 58
18381: AND
18382: IFFALSE 18479
18384: GO 18386
18386: DISABLE
18387: LD_INT 0
18389: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
18390: LD_ADDR_VAR 0 1
18394: PUSH
18395: LD_INT 22
18397: PUSH
18398: LD_OWVAR 2
18402: PUSH
18403: EMPTY
18404: LIST
18405: LIST
18406: PUSH
18407: LD_INT 21
18409: PUSH
18410: LD_INT 1
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: PUSH
18417: LD_INT 3
18419: PUSH
18420: LD_INT 23
18422: PUSH
18423: LD_INT 0
18425: PUSH
18426: EMPTY
18427: LIST
18428: LIST
18429: PUSH
18430: EMPTY
18431: LIST
18432: LIST
18433: PUSH
18434: EMPTY
18435: LIST
18436: LIST
18437: LIST
18438: PPUSH
18439: CALL_OW 69
18443: ST_TO_ADDR
// if not tmp then
18444: LD_VAR 0 1
18448: NOT
18449: IFFALSE 18453
// exit ;
18451: GO 18479
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
18453: LD_VAR 0 1
18457: PUSH
18458: LD_INT 1
18460: PPUSH
18461: LD_VAR 0 1
18465: PPUSH
18466: CALL_OW 12
18470: ARRAY
18471: PPUSH
18472: LD_INT 200
18474: PPUSH
18475: CALL_OW 234
// end ;
18479: PPOPN 1
18481: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
18482: LD_EXP 30
18486: PUSH
18487: LD_EXP 59
18491: AND
18492: IFFALSE 18571
18494: GO 18496
18496: DISABLE
18497: LD_INT 0
18499: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
18500: LD_ADDR_VAR 0 1
18504: PUSH
18505: LD_INT 22
18507: PUSH
18508: LD_OWVAR 2
18512: PUSH
18513: EMPTY
18514: LIST
18515: LIST
18516: PUSH
18517: LD_INT 21
18519: PUSH
18520: LD_INT 2
18522: PUSH
18523: EMPTY
18524: LIST
18525: LIST
18526: PUSH
18527: EMPTY
18528: LIST
18529: LIST
18530: PPUSH
18531: CALL_OW 69
18535: ST_TO_ADDR
// if not tmp then
18536: LD_VAR 0 1
18540: NOT
18541: IFFALSE 18545
// exit ;
18543: GO 18571
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
18545: LD_VAR 0 1
18549: PUSH
18550: LD_INT 1
18552: PPUSH
18553: LD_VAR 0 1
18557: PPUSH
18558: CALL_OW 12
18562: ARRAY
18563: PPUSH
18564: LD_INT 60
18566: PPUSH
18567: CALL_OW 234
// end ;
18571: PPOPN 1
18573: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
18574: LD_EXP 30
18578: PUSH
18579: LD_EXP 60
18583: AND
18584: IFFALSE 18683
18586: GO 18588
18588: DISABLE
18589: LD_INT 0
18591: PPUSH
18592: PPUSH
// begin enable ;
18593: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
18594: LD_ADDR_VAR 0 1
18598: PUSH
18599: LD_INT 22
18601: PUSH
18602: LD_OWVAR 2
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PUSH
18611: LD_INT 61
18613: PUSH
18614: EMPTY
18615: LIST
18616: PUSH
18617: LD_INT 33
18619: PUSH
18620: LD_INT 2
18622: PUSH
18623: EMPTY
18624: LIST
18625: LIST
18626: PUSH
18627: EMPTY
18628: LIST
18629: LIST
18630: LIST
18631: PPUSH
18632: CALL_OW 69
18636: ST_TO_ADDR
// if not tmp then
18637: LD_VAR 0 1
18641: NOT
18642: IFFALSE 18646
// exit ;
18644: GO 18683
// for i in tmp do
18646: LD_ADDR_VAR 0 2
18650: PUSH
18651: LD_VAR 0 1
18655: PUSH
18656: FOR_IN
18657: IFFALSE 18681
// if IsControledBy ( i ) then
18659: LD_VAR 0 2
18663: PPUSH
18664: CALL_OW 312
18668: IFFALSE 18679
// ComUnlink ( i ) ;
18670: LD_VAR 0 2
18674: PPUSH
18675: CALL_OW 136
18679: GO 18656
18681: POP
18682: POP
// end ;
18683: PPOPN 2
18685: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
18686: LD_EXP 30
18690: PUSH
18691: LD_EXP 61
18695: AND
18696: IFFALSE 18836
18698: GO 18700
18700: DISABLE
18701: LD_INT 0
18703: PPUSH
18704: PPUSH
// begin ToLua ( displayPowell(); ) ;
18705: LD_STRING displayPowell();
18707: PPUSH
18708: CALL_OW 559
// uc_side := 0 ;
18712: LD_ADDR_OWVAR 20
18716: PUSH
18717: LD_INT 0
18719: ST_TO_ADDR
// uc_nation := 2 ;
18720: LD_ADDR_OWVAR 21
18724: PUSH
18725: LD_INT 2
18727: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
18728: LD_ADDR_OWVAR 37
18732: PUSH
18733: LD_INT 14
18735: ST_TO_ADDR
// vc_engine := engine_siberite ;
18736: LD_ADDR_OWVAR 39
18740: PUSH
18741: LD_INT 3
18743: ST_TO_ADDR
// vc_control := control_apeman ;
18744: LD_ADDR_OWVAR 38
18748: PUSH
18749: LD_INT 5
18751: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
18752: LD_ADDR_OWVAR 40
18756: PUSH
18757: LD_INT 29
18759: ST_TO_ADDR
// un := CreateVehicle ;
18760: LD_ADDR_VAR 0 2
18764: PUSH
18765: CALL_OW 45
18769: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
18770: LD_VAR 0 2
18774: PPUSH
18775: LD_INT 1
18777: PPUSH
18778: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
18782: LD_INT 35
18784: PPUSH
18785: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
18789: LD_VAR 0 2
18793: PPUSH
18794: LD_INT 22
18796: PUSH
18797: LD_OWVAR 2
18801: PUSH
18802: EMPTY
18803: LIST
18804: LIST
18805: PPUSH
18806: CALL_OW 69
18810: PPUSH
18811: LD_VAR 0 2
18815: PPUSH
18816: CALL_OW 74
18820: PPUSH
18821: CALL_OW 115
// until IsDead ( un ) ;
18825: LD_VAR 0 2
18829: PPUSH
18830: CALL_OW 301
18834: IFFALSE 18782
// end ;
18836: PPOPN 2
18838: END
// every 0 0$1 trigger StreamModeActive and sStu do
18839: LD_EXP 30
18843: PUSH
18844: LD_EXP 69
18848: AND
18849: IFFALSE 18865
18851: GO 18853
18853: DISABLE
// begin ToLua ( displayStucuk(); ) ;
18854: LD_STRING displayStucuk();
18856: PPUSH
18857: CALL_OW 559
// ResetFog ;
18861: CALL_OW 335
// end ;
18865: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
18866: LD_EXP 30
18870: PUSH
18871: LD_EXP 62
18875: AND
18876: IFFALSE 19017
18878: GO 18880
18880: DISABLE
18881: LD_INT 0
18883: PPUSH
18884: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
18885: LD_ADDR_VAR 0 2
18889: PUSH
18890: LD_INT 22
18892: PUSH
18893: LD_OWVAR 2
18897: PUSH
18898: EMPTY
18899: LIST
18900: LIST
18901: PUSH
18902: LD_INT 21
18904: PUSH
18905: LD_INT 1
18907: PUSH
18908: EMPTY
18909: LIST
18910: LIST
18911: PUSH
18912: EMPTY
18913: LIST
18914: LIST
18915: PPUSH
18916: CALL_OW 69
18920: ST_TO_ADDR
// if not tmp then
18921: LD_VAR 0 2
18925: NOT
18926: IFFALSE 18930
// exit ;
18928: GO 19017
// un := tmp [ rand ( 1 , tmp ) ] ;
18930: LD_ADDR_VAR 0 1
18934: PUSH
18935: LD_VAR 0 2
18939: PUSH
18940: LD_INT 1
18942: PPUSH
18943: LD_VAR 0 2
18947: PPUSH
18948: CALL_OW 12
18952: ARRAY
18953: ST_TO_ADDR
// SetSide ( un , 0 ) ;
18954: LD_VAR 0 1
18958: PPUSH
18959: LD_INT 0
18961: PPUSH
18962: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
18966: LD_VAR 0 1
18970: PPUSH
18971: LD_OWVAR 3
18975: PUSH
18976: LD_VAR 0 1
18980: DIFF
18981: PPUSH
18982: LD_VAR 0 1
18986: PPUSH
18987: CALL_OW 74
18991: PPUSH
18992: CALL_OW 115
// wait ( 0 0$20 ) ;
18996: LD_INT 700
18998: PPUSH
18999: CALL_OW 67
// SetSide ( un , your_side ) ;
19003: LD_VAR 0 1
19007: PPUSH
19008: LD_OWVAR 2
19012: PPUSH
19013: CALL_OW 235
// end ;
19017: PPOPN 2
19019: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
19020: LD_EXP 30
19024: PUSH
19025: LD_EXP 63
19029: AND
19030: IFFALSE 19136
19032: GO 19034
19034: DISABLE
19035: LD_INT 0
19037: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
19038: LD_ADDR_VAR 0 1
19042: PUSH
19043: LD_INT 22
19045: PUSH
19046: LD_OWVAR 2
19050: PUSH
19051: EMPTY
19052: LIST
19053: LIST
19054: PUSH
19055: LD_INT 2
19057: PUSH
19058: LD_INT 30
19060: PUSH
19061: LD_INT 0
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: PUSH
19068: LD_INT 30
19070: PUSH
19071: LD_INT 1
19073: PUSH
19074: EMPTY
19075: LIST
19076: LIST
19077: PUSH
19078: EMPTY
19079: LIST
19080: LIST
19081: LIST
19082: PUSH
19083: EMPTY
19084: LIST
19085: LIST
19086: PPUSH
19087: CALL_OW 69
19091: ST_TO_ADDR
// if not depot then
19092: LD_VAR 0 1
19096: NOT
19097: IFFALSE 19101
// exit ;
19099: GO 19136
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
19101: LD_VAR 0 1
19105: PUSH
19106: LD_INT 1
19108: ARRAY
19109: PPUSH
19110: CALL_OW 250
19114: PPUSH
19115: LD_VAR 0 1
19119: PUSH
19120: LD_INT 1
19122: ARRAY
19123: PPUSH
19124: CALL_OW 251
19128: PPUSH
19129: LD_INT 70
19131: PPUSH
19132: CALL_OW 495
// end ;
19136: PPOPN 1
19138: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
19139: LD_EXP 30
19143: PUSH
19144: LD_EXP 64
19148: AND
19149: IFFALSE 19360
19151: GO 19153
19153: DISABLE
19154: LD_INT 0
19156: PPUSH
19157: PPUSH
19158: PPUSH
19159: PPUSH
19160: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
19161: LD_ADDR_VAR 0 5
19165: PUSH
19166: LD_INT 22
19168: PUSH
19169: LD_OWVAR 2
19173: PUSH
19174: EMPTY
19175: LIST
19176: LIST
19177: PUSH
19178: LD_INT 21
19180: PUSH
19181: LD_INT 1
19183: PUSH
19184: EMPTY
19185: LIST
19186: LIST
19187: PUSH
19188: EMPTY
19189: LIST
19190: LIST
19191: PPUSH
19192: CALL_OW 69
19196: ST_TO_ADDR
// if not tmp then
19197: LD_VAR 0 5
19201: NOT
19202: IFFALSE 19206
// exit ;
19204: GO 19360
// for i in tmp do
19206: LD_ADDR_VAR 0 1
19210: PUSH
19211: LD_VAR 0 5
19215: PUSH
19216: FOR_IN
19217: IFFALSE 19358
// begin d := rand ( 0 , 5 ) ;
19219: LD_ADDR_VAR 0 4
19223: PUSH
19224: LD_INT 0
19226: PPUSH
19227: LD_INT 5
19229: PPUSH
19230: CALL_OW 12
19234: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
19235: LD_ADDR_VAR 0 2
19239: PUSH
19240: LD_VAR 0 1
19244: PPUSH
19245: CALL_OW 250
19249: PPUSH
19250: LD_VAR 0 4
19254: PPUSH
19255: LD_INT 3
19257: PPUSH
19258: LD_INT 12
19260: PPUSH
19261: CALL_OW 12
19265: PPUSH
19266: CALL_OW 272
19270: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
19271: LD_ADDR_VAR 0 3
19275: PUSH
19276: LD_VAR 0 1
19280: PPUSH
19281: CALL_OW 251
19285: PPUSH
19286: LD_VAR 0 4
19290: PPUSH
19291: LD_INT 3
19293: PPUSH
19294: LD_INT 12
19296: PPUSH
19297: CALL_OW 12
19301: PPUSH
19302: CALL_OW 273
19306: ST_TO_ADDR
// if ValidHex ( x , y ) then
19307: LD_VAR 0 2
19311: PPUSH
19312: LD_VAR 0 3
19316: PPUSH
19317: CALL_OW 488
19321: IFFALSE 19356
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
19323: LD_VAR 0 1
19327: PPUSH
19328: LD_VAR 0 2
19332: PPUSH
19333: LD_VAR 0 3
19337: PPUSH
19338: LD_INT 3
19340: PPUSH
19341: LD_INT 6
19343: PPUSH
19344: CALL_OW 12
19348: PPUSH
19349: LD_INT 1
19351: PPUSH
19352: CALL_OW 483
// end ;
19356: GO 19216
19358: POP
19359: POP
// end ;
19360: PPOPN 5
19362: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
19363: LD_EXP 30
19367: PUSH
19368: LD_EXP 65
19372: AND
19373: IFFALSE 19467
19375: GO 19377
19377: DISABLE
19378: LD_INT 0
19380: PPUSH
19381: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
19382: LD_ADDR_VAR 0 2
19386: PUSH
19387: LD_INT 22
19389: PUSH
19390: LD_OWVAR 2
19394: PUSH
19395: EMPTY
19396: LIST
19397: LIST
19398: PUSH
19399: LD_INT 32
19401: PUSH
19402: LD_INT 1
19404: PUSH
19405: EMPTY
19406: LIST
19407: LIST
19408: PUSH
19409: LD_INT 21
19411: PUSH
19412: LD_INT 2
19414: PUSH
19415: EMPTY
19416: LIST
19417: LIST
19418: PUSH
19419: EMPTY
19420: LIST
19421: LIST
19422: LIST
19423: PPUSH
19424: CALL_OW 69
19428: ST_TO_ADDR
// if not tmp then
19429: LD_VAR 0 2
19433: NOT
19434: IFFALSE 19438
// exit ;
19436: GO 19467
// for i in tmp do
19438: LD_ADDR_VAR 0 1
19442: PUSH
19443: LD_VAR 0 2
19447: PUSH
19448: FOR_IN
19449: IFFALSE 19465
// SetFuel ( i , 0 ) ;
19451: LD_VAR 0 1
19455: PPUSH
19456: LD_INT 0
19458: PPUSH
19459: CALL_OW 240
19463: GO 19448
19465: POP
19466: POP
// end ;
19467: PPOPN 2
19469: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
19470: LD_EXP 30
19474: PUSH
19475: LD_EXP 66
19479: AND
19480: IFFALSE 19546
19482: GO 19484
19484: DISABLE
19485: LD_INT 0
19487: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
19488: LD_ADDR_VAR 0 1
19492: PUSH
19493: LD_INT 22
19495: PUSH
19496: LD_OWVAR 2
19500: PUSH
19501: EMPTY
19502: LIST
19503: LIST
19504: PUSH
19505: LD_INT 30
19507: PUSH
19508: LD_INT 29
19510: PUSH
19511: EMPTY
19512: LIST
19513: LIST
19514: PUSH
19515: EMPTY
19516: LIST
19517: LIST
19518: PPUSH
19519: CALL_OW 69
19523: ST_TO_ADDR
// if not tmp then
19524: LD_VAR 0 1
19528: NOT
19529: IFFALSE 19533
// exit ;
19531: GO 19546
// DestroyUnit ( tmp [ 1 ] ) ;
19533: LD_VAR 0 1
19537: PUSH
19538: LD_INT 1
19540: ARRAY
19541: PPUSH
19542: CALL_OW 65
// end ;
19546: PPOPN 1
19548: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
19549: LD_EXP 30
19553: PUSH
19554: LD_EXP 68
19558: AND
19559: IFFALSE 19688
19561: GO 19563
19563: DISABLE
19564: LD_INT 0
19566: PPUSH
// begin uc_side := 0 ;
19567: LD_ADDR_OWVAR 20
19571: PUSH
19572: LD_INT 0
19574: ST_TO_ADDR
// uc_nation := nation_arabian ;
19575: LD_ADDR_OWVAR 21
19579: PUSH
19580: LD_INT 2
19582: ST_TO_ADDR
// hc_gallery :=  ;
19583: LD_ADDR_OWVAR 33
19587: PUSH
19588: LD_STRING 
19590: ST_TO_ADDR
// hc_name :=  ;
19591: LD_ADDR_OWVAR 26
19595: PUSH
19596: LD_STRING 
19598: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
19599: LD_INT 1
19601: PPUSH
19602: LD_INT 11
19604: PPUSH
19605: LD_INT 10
19607: PPUSH
19608: CALL_OW 380
// un := CreateHuman ;
19612: LD_ADDR_VAR 0 1
19616: PUSH
19617: CALL_OW 44
19621: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
19622: LD_VAR 0 1
19626: PPUSH
19627: LD_INT 1
19629: PPUSH
19630: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
19634: LD_INT 35
19636: PPUSH
19637: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
19641: LD_VAR 0 1
19645: PPUSH
19646: LD_INT 22
19648: PUSH
19649: LD_OWVAR 2
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: PPUSH
19658: CALL_OW 69
19662: PPUSH
19663: LD_VAR 0 1
19667: PPUSH
19668: CALL_OW 74
19672: PPUSH
19673: CALL_OW 115
// until IsDead ( un ) ;
19677: LD_VAR 0 1
19681: PPUSH
19682: CALL_OW 301
19686: IFFALSE 19634
// end ;
19688: PPOPN 1
19690: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
19691: LD_EXP 30
19695: PUSH
19696: LD_EXP 70
19700: AND
19701: IFFALSE 19713
19703: GO 19705
19705: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
19706: LD_STRING earthquake(getX(game), 0, 32)
19708: PPUSH
19709: CALL_OW 559
19713: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
19714: LD_EXP 30
19718: PUSH
19719: LD_EXP 71
19723: AND
19724: IFFALSE 19815
19726: GO 19728
19728: DISABLE
19729: LD_INT 0
19731: PPUSH
// begin enable ;
19732: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
19733: LD_ADDR_VAR 0 1
19737: PUSH
19738: LD_INT 22
19740: PUSH
19741: LD_OWVAR 2
19745: PUSH
19746: EMPTY
19747: LIST
19748: LIST
19749: PUSH
19750: LD_INT 21
19752: PUSH
19753: LD_INT 2
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PUSH
19760: LD_INT 33
19762: PUSH
19763: LD_INT 3
19765: PUSH
19766: EMPTY
19767: LIST
19768: LIST
19769: PUSH
19770: EMPTY
19771: LIST
19772: LIST
19773: LIST
19774: PPUSH
19775: CALL_OW 69
19779: ST_TO_ADDR
// if not tmp then
19780: LD_VAR 0 1
19784: NOT
19785: IFFALSE 19789
// exit ;
19787: GO 19815
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
19789: LD_VAR 0 1
19793: PUSH
19794: LD_INT 1
19796: PPUSH
19797: LD_VAR 0 1
19801: PPUSH
19802: CALL_OW 12
19806: ARRAY
19807: PPUSH
19808: LD_INT 1
19810: PPUSH
19811: CALL_OW 234
// end ;
19815: PPOPN 1
19817: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
19818: LD_EXP 30
19822: PUSH
19823: LD_EXP 72
19827: AND
19828: IFFALSE 19969
19830: GO 19832
19832: DISABLE
19833: LD_INT 0
19835: PPUSH
19836: PPUSH
19837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19838: LD_ADDR_VAR 0 3
19842: PUSH
19843: LD_INT 22
19845: PUSH
19846: LD_OWVAR 2
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: PUSH
19855: LD_INT 25
19857: PUSH
19858: LD_INT 1
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: PPUSH
19869: CALL_OW 69
19873: ST_TO_ADDR
// if not tmp then
19874: LD_VAR 0 3
19878: NOT
19879: IFFALSE 19883
// exit ;
19881: GO 19969
// un := tmp [ rand ( 1 , tmp ) ] ;
19883: LD_ADDR_VAR 0 2
19887: PUSH
19888: LD_VAR 0 3
19892: PUSH
19893: LD_INT 1
19895: PPUSH
19896: LD_VAR 0 3
19900: PPUSH
19901: CALL_OW 12
19905: ARRAY
19906: ST_TO_ADDR
// if Crawls ( un ) then
19907: LD_VAR 0 2
19911: PPUSH
19912: CALL_OW 318
19916: IFFALSE 19927
// ComWalk ( un ) ;
19918: LD_VAR 0 2
19922: PPUSH
19923: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
19927: LD_VAR 0 2
19931: PPUSH
19932: LD_INT 9
19934: PPUSH
19935: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
19939: LD_INT 28
19941: PPUSH
19942: LD_OWVAR 2
19946: PPUSH
19947: LD_INT 2
19949: PPUSH
19950: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
19954: LD_INT 29
19956: PPUSH
19957: LD_OWVAR 2
19961: PPUSH
19962: LD_INT 2
19964: PPUSH
19965: CALL_OW 322
// end ;
19969: PPOPN 3
19971: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
19972: LD_EXP 30
19976: PUSH
19977: LD_EXP 73
19981: AND
19982: IFFALSE 20093
19984: GO 19986
19986: DISABLE
19987: LD_INT 0
19989: PPUSH
19990: PPUSH
19991: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
19992: LD_ADDR_VAR 0 3
19996: PUSH
19997: LD_INT 22
19999: PUSH
20000: LD_OWVAR 2
20004: PUSH
20005: EMPTY
20006: LIST
20007: LIST
20008: PUSH
20009: LD_INT 25
20011: PUSH
20012: LD_INT 1
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: PPUSH
20023: CALL_OW 69
20027: ST_TO_ADDR
// if not tmp then
20028: LD_VAR 0 3
20032: NOT
20033: IFFALSE 20037
// exit ;
20035: GO 20093
// un := tmp [ rand ( 1 , tmp ) ] ;
20037: LD_ADDR_VAR 0 2
20041: PUSH
20042: LD_VAR 0 3
20046: PUSH
20047: LD_INT 1
20049: PPUSH
20050: LD_VAR 0 3
20054: PPUSH
20055: CALL_OW 12
20059: ARRAY
20060: ST_TO_ADDR
// if Crawls ( un ) then
20061: LD_VAR 0 2
20065: PPUSH
20066: CALL_OW 318
20070: IFFALSE 20081
// ComWalk ( un ) ;
20072: LD_VAR 0 2
20076: PPUSH
20077: CALL_OW 138
// SetClass ( un , class_mortar ) ;
20081: LD_VAR 0 2
20085: PPUSH
20086: LD_INT 8
20088: PPUSH
20089: CALL_OW 336
// end ;
20093: PPOPN 3
20095: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
20096: LD_EXP 30
20100: PUSH
20101: LD_EXP 74
20105: AND
20106: IFFALSE 20250
20108: GO 20110
20110: DISABLE
20111: LD_INT 0
20113: PPUSH
20114: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
20115: LD_ADDR_VAR 0 2
20119: PUSH
20120: LD_INT 22
20122: PUSH
20123: LD_OWVAR 2
20127: PUSH
20128: EMPTY
20129: LIST
20130: LIST
20131: PUSH
20132: LD_INT 21
20134: PUSH
20135: LD_INT 2
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PUSH
20142: LD_INT 2
20144: PUSH
20145: LD_INT 34
20147: PUSH
20148: LD_INT 12
20150: PUSH
20151: EMPTY
20152: LIST
20153: LIST
20154: PUSH
20155: LD_INT 34
20157: PUSH
20158: LD_INT 51
20160: PUSH
20161: EMPTY
20162: LIST
20163: LIST
20164: PUSH
20165: LD_INT 34
20167: PUSH
20168: LD_INT 32
20170: PUSH
20171: EMPTY
20172: LIST
20173: LIST
20174: PUSH
20175: EMPTY
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: PUSH
20181: EMPTY
20182: LIST
20183: LIST
20184: LIST
20185: PPUSH
20186: CALL_OW 69
20190: ST_TO_ADDR
// if not tmp then
20191: LD_VAR 0 2
20195: NOT
20196: IFFALSE 20200
// exit ;
20198: GO 20250
// for i in tmp do
20200: LD_ADDR_VAR 0 1
20204: PUSH
20205: LD_VAR 0 2
20209: PUSH
20210: FOR_IN
20211: IFFALSE 20248
// if GetCargo ( i , mat_artifact ) = 0 then
20213: LD_VAR 0 1
20217: PPUSH
20218: LD_INT 4
20220: PPUSH
20221: CALL_OW 289
20225: PUSH
20226: LD_INT 0
20228: EQUAL
20229: IFFALSE 20246
// SetCargo ( i , mat_siberit , 100 ) ;
20231: LD_VAR 0 1
20235: PPUSH
20236: LD_INT 3
20238: PPUSH
20239: LD_INT 100
20241: PPUSH
20242: CALL_OW 290
20246: GO 20210
20248: POP
20249: POP
// end ;
20250: PPOPN 2
20252: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
20253: LD_EXP 30
20257: PUSH
20258: LD_EXP 75
20262: AND
20263: IFFALSE 20416
20265: GO 20267
20267: DISABLE
20268: LD_INT 0
20270: PPUSH
20271: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
20272: LD_ADDR_VAR 0 2
20276: PUSH
20277: LD_INT 22
20279: PUSH
20280: LD_OWVAR 2
20284: PUSH
20285: EMPTY
20286: LIST
20287: LIST
20288: PPUSH
20289: CALL_OW 69
20293: ST_TO_ADDR
// if not tmp then
20294: LD_VAR 0 2
20298: NOT
20299: IFFALSE 20303
// exit ;
20301: GO 20416
// for i := 1 to 2 do
20303: LD_ADDR_VAR 0 1
20307: PUSH
20308: DOUBLE
20309: LD_INT 1
20311: DEC
20312: ST_TO_ADDR
20313: LD_INT 2
20315: PUSH
20316: FOR_TO
20317: IFFALSE 20414
// begin uc_side := your_side ;
20319: LD_ADDR_OWVAR 20
20323: PUSH
20324: LD_OWVAR 2
20328: ST_TO_ADDR
// uc_nation := nation_american ;
20329: LD_ADDR_OWVAR 21
20333: PUSH
20334: LD_INT 1
20336: ST_TO_ADDR
// vc_chassis := us_morphling ;
20337: LD_ADDR_OWVAR 37
20341: PUSH
20342: LD_INT 5
20344: ST_TO_ADDR
// vc_engine := engine_siberite ;
20345: LD_ADDR_OWVAR 39
20349: PUSH
20350: LD_INT 3
20352: ST_TO_ADDR
// vc_control := control_computer ;
20353: LD_ADDR_OWVAR 38
20357: PUSH
20358: LD_INT 3
20360: ST_TO_ADDR
// vc_weapon := us_double_laser ;
20361: LD_ADDR_OWVAR 40
20365: PUSH
20366: LD_INT 10
20368: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
20369: CALL_OW 45
20373: PPUSH
20374: LD_VAR 0 2
20378: PUSH
20379: LD_INT 1
20381: ARRAY
20382: PPUSH
20383: CALL_OW 250
20387: PPUSH
20388: LD_VAR 0 2
20392: PUSH
20393: LD_INT 1
20395: ARRAY
20396: PPUSH
20397: CALL_OW 251
20401: PPUSH
20402: LD_INT 12
20404: PPUSH
20405: LD_INT 1
20407: PPUSH
20408: CALL_OW 50
// end ;
20412: GO 20316
20414: POP
20415: POP
// end ;
20416: PPOPN 2
20418: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
20419: LD_EXP 30
20423: PUSH
20424: LD_EXP 76
20428: AND
20429: IFFALSE 20651
20431: GO 20433
20433: DISABLE
20434: LD_INT 0
20436: PPUSH
20437: PPUSH
20438: PPUSH
20439: PPUSH
20440: PPUSH
20441: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
20442: LD_ADDR_VAR 0 6
20446: PUSH
20447: LD_INT 22
20449: PUSH
20450: LD_OWVAR 2
20454: PUSH
20455: EMPTY
20456: LIST
20457: LIST
20458: PUSH
20459: LD_INT 21
20461: PUSH
20462: LD_INT 1
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: PUSH
20469: LD_INT 3
20471: PUSH
20472: LD_INT 23
20474: PUSH
20475: LD_INT 0
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: PUSH
20482: EMPTY
20483: LIST
20484: LIST
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: LIST
20490: PPUSH
20491: CALL_OW 69
20495: ST_TO_ADDR
// if not tmp then
20496: LD_VAR 0 6
20500: NOT
20501: IFFALSE 20505
// exit ;
20503: GO 20651
// s1 := rand ( 1 , 4 ) ;
20505: LD_ADDR_VAR 0 2
20509: PUSH
20510: LD_INT 1
20512: PPUSH
20513: LD_INT 4
20515: PPUSH
20516: CALL_OW 12
20520: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
20521: LD_ADDR_VAR 0 4
20525: PUSH
20526: LD_VAR 0 6
20530: PUSH
20531: LD_INT 1
20533: ARRAY
20534: PPUSH
20535: LD_VAR 0 2
20539: PPUSH
20540: CALL_OW 259
20544: ST_TO_ADDR
// if s1 = 1 then
20545: LD_VAR 0 2
20549: PUSH
20550: LD_INT 1
20552: EQUAL
20553: IFFALSE 20573
// s2 := rand ( 2 , 4 ) else
20555: LD_ADDR_VAR 0 3
20559: PUSH
20560: LD_INT 2
20562: PPUSH
20563: LD_INT 4
20565: PPUSH
20566: CALL_OW 12
20570: ST_TO_ADDR
20571: GO 20581
// s2 := 1 ;
20573: LD_ADDR_VAR 0 3
20577: PUSH
20578: LD_INT 1
20580: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
20581: LD_ADDR_VAR 0 5
20585: PUSH
20586: LD_VAR 0 6
20590: PUSH
20591: LD_INT 1
20593: ARRAY
20594: PPUSH
20595: LD_VAR 0 3
20599: PPUSH
20600: CALL_OW 259
20604: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
20605: LD_VAR 0 6
20609: PUSH
20610: LD_INT 1
20612: ARRAY
20613: PPUSH
20614: LD_VAR 0 2
20618: PPUSH
20619: LD_VAR 0 5
20623: PPUSH
20624: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
20628: LD_VAR 0 6
20632: PUSH
20633: LD_INT 1
20635: ARRAY
20636: PPUSH
20637: LD_VAR 0 3
20641: PPUSH
20642: LD_VAR 0 4
20646: PPUSH
20647: CALL_OW 237
// end ;
20651: PPOPN 6
20653: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
20654: LD_EXP 30
20658: PUSH
20659: LD_EXP 77
20663: AND
20664: IFFALSE 20743
20666: GO 20668
20668: DISABLE
20669: LD_INT 0
20671: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
20672: LD_ADDR_VAR 0 1
20676: PUSH
20677: LD_INT 22
20679: PUSH
20680: LD_OWVAR 2
20684: PUSH
20685: EMPTY
20686: LIST
20687: LIST
20688: PUSH
20689: LD_INT 30
20691: PUSH
20692: LD_INT 3
20694: PUSH
20695: EMPTY
20696: LIST
20697: LIST
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: PPUSH
20703: CALL_OW 69
20707: ST_TO_ADDR
// if not tmp then
20708: LD_VAR 0 1
20712: NOT
20713: IFFALSE 20717
// exit ;
20715: GO 20743
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
20717: LD_VAR 0 1
20721: PUSH
20722: LD_INT 1
20724: PPUSH
20725: LD_VAR 0 1
20729: PPUSH
20730: CALL_OW 12
20734: ARRAY
20735: PPUSH
20736: LD_INT 1
20738: PPUSH
20739: CALL_OW 234
// end ;
20743: PPOPN 1
20745: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
20746: LD_EXP 30
20750: PUSH
20751: LD_EXP 78
20755: AND
20756: IFFALSE 20868
20758: GO 20760
20760: DISABLE
20761: LD_INT 0
20763: PPUSH
20764: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
20765: LD_ADDR_VAR 0 2
20769: PUSH
20770: LD_INT 22
20772: PUSH
20773: LD_OWVAR 2
20777: PUSH
20778: EMPTY
20779: LIST
20780: LIST
20781: PUSH
20782: LD_INT 2
20784: PUSH
20785: LD_INT 30
20787: PUSH
20788: LD_INT 27
20790: PUSH
20791: EMPTY
20792: LIST
20793: LIST
20794: PUSH
20795: LD_INT 30
20797: PUSH
20798: LD_INT 26
20800: PUSH
20801: EMPTY
20802: LIST
20803: LIST
20804: PUSH
20805: LD_INT 30
20807: PUSH
20808: LD_INT 28
20810: PUSH
20811: EMPTY
20812: LIST
20813: LIST
20814: PUSH
20815: EMPTY
20816: LIST
20817: LIST
20818: LIST
20819: LIST
20820: PUSH
20821: EMPTY
20822: LIST
20823: LIST
20824: PPUSH
20825: CALL_OW 69
20829: ST_TO_ADDR
// if not tmp then
20830: LD_VAR 0 2
20834: NOT
20835: IFFALSE 20839
// exit ;
20837: GO 20868
// for i in tmp do
20839: LD_ADDR_VAR 0 1
20843: PUSH
20844: LD_VAR 0 2
20848: PUSH
20849: FOR_IN
20850: IFFALSE 20866
// SetLives ( i , 1 ) ;
20852: LD_VAR 0 1
20856: PPUSH
20857: LD_INT 1
20859: PPUSH
20860: CALL_OW 234
20864: GO 20849
20866: POP
20867: POP
// end ;
20868: PPOPN 2
20870: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
20871: LD_EXP 30
20875: PUSH
20876: LD_EXP 79
20880: AND
20881: IFFALSE 21155
20883: GO 20885
20885: DISABLE
20886: LD_INT 0
20888: PPUSH
20889: PPUSH
20890: PPUSH
// begin i := rand ( 1 , 7 ) ;
20891: LD_ADDR_VAR 0 1
20895: PUSH
20896: LD_INT 1
20898: PPUSH
20899: LD_INT 7
20901: PPUSH
20902: CALL_OW 12
20906: ST_TO_ADDR
// case i of 1 :
20907: LD_VAR 0 1
20911: PUSH
20912: LD_INT 1
20914: DOUBLE
20915: EQUAL
20916: IFTRUE 20920
20918: GO 20930
20920: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
20921: LD_STRING earthquake(getX(game), 0, 32)
20923: PPUSH
20924: CALL_OW 559
20928: GO 21155
20930: LD_INT 2
20932: DOUBLE
20933: EQUAL
20934: IFTRUE 20938
20936: GO 20952
20938: POP
// begin ToLua ( displayStucuk(); ) ;
20939: LD_STRING displayStucuk();
20941: PPUSH
20942: CALL_OW 559
// ResetFog ;
20946: CALL_OW 335
// end ; 3 :
20950: GO 21155
20952: LD_INT 3
20954: DOUBLE
20955: EQUAL
20956: IFTRUE 20960
20958: GO 21064
20960: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
20961: LD_ADDR_VAR 0 2
20965: PUSH
20966: LD_INT 22
20968: PUSH
20969: LD_OWVAR 2
20973: PUSH
20974: EMPTY
20975: LIST
20976: LIST
20977: PUSH
20978: LD_INT 25
20980: PUSH
20981: LD_INT 1
20983: PUSH
20984: EMPTY
20985: LIST
20986: LIST
20987: PUSH
20988: EMPTY
20989: LIST
20990: LIST
20991: PPUSH
20992: CALL_OW 69
20996: ST_TO_ADDR
// if not tmp then
20997: LD_VAR 0 2
21001: NOT
21002: IFFALSE 21006
// exit ;
21004: GO 21155
// un := tmp [ rand ( 1 , tmp ) ] ;
21006: LD_ADDR_VAR 0 3
21010: PUSH
21011: LD_VAR 0 2
21015: PUSH
21016: LD_INT 1
21018: PPUSH
21019: LD_VAR 0 2
21023: PPUSH
21024: CALL_OW 12
21028: ARRAY
21029: ST_TO_ADDR
// if Crawls ( un ) then
21030: LD_VAR 0 3
21034: PPUSH
21035: CALL_OW 318
21039: IFFALSE 21050
// ComWalk ( un ) ;
21041: LD_VAR 0 3
21045: PPUSH
21046: CALL_OW 138
// SetClass ( un , class_mortar ) ;
21050: LD_VAR 0 3
21054: PPUSH
21055: LD_INT 8
21057: PPUSH
21058: CALL_OW 336
// end ; 4 :
21062: GO 21155
21064: LD_INT 4
21066: DOUBLE
21067: EQUAL
21068: IFTRUE 21072
21070: GO 21133
21072: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
21073: LD_ADDR_VAR 0 2
21077: PUSH
21078: LD_INT 22
21080: PUSH
21081: LD_OWVAR 2
21085: PUSH
21086: EMPTY
21087: LIST
21088: LIST
21089: PUSH
21090: LD_INT 30
21092: PUSH
21093: LD_INT 29
21095: PUSH
21096: EMPTY
21097: LIST
21098: LIST
21099: PUSH
21100: EMPTY
21101: LIST
21102: LIST
21103: PPUSH
21104: CALL_OW 69
21108: ST_TO_ADDR
// if not tmp then
21109: LD_VAR 0 2
21113: NOT
21114: IFFALSE 21118
// exit ;
21116: GO 21155
// DestroyUnit ( tmp [ 1 ] ) ;
21118: LD_VAR 0 2
21122: PUSH
21123: LD_INT 1
21125: ARRAY
21126: PPUSH
21127: CALL_OW 65
// end ; 5 .. 7 :
21131: GO 21155
21133: LD_INT 5
21135: DOUBLE
21136: GREATEREQUAL
21137: IFFALSE 21145
21139: LD_INT 7
21141: DOUBLE
21142: LESSEQUAL
21143: IFTRUE 21147
21145: GO 21154
21147: POP
// StreamSibBomb ; end ;
21148: CALL 17435 0 0
21152: GO 21155
21154: POP
// end ;
21155: PPOPN 3
21157: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
21158: LD_EXP 30
21162: PUSH
21163: LD_EXP 80
21167: AND
21168: IFFALSE 21324
21170: GO 21172
21172: DISABLE
21173: LD_INT 0
21175: PPUSH
21176: PPUSH
21177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
21178: LD_ADDR_VAR 0 2
21182: PUSH
21183: LD_INT 81
21185: PUSH
21186: LD_OWVAR 2
21190: PUSH
21191: EMPTY
21192: LIST
21193: LIST
21194: PUSH
21195: LD_INT 2
21197: PUSH
21198: LD_INT 21
21200: PUSH
21201: LD_INT 1
21203: PUSH
21204: EMPTY
21205: LIST
21206: LIST
21207: PUSH
21208: LD_INT 21
21210: PUSH
21211: LD_INT 2
21213: PUSH
21214: EMPTY
21215: LIST
21216: LIST
21217: PUSH
21218: EMPTY
21219: LIST
21220: LIST
21221: LIST
21222: PUSH
21223: EMPTY
21224: LIST
21225: LIST
21226: PPUSH
21227: CALL_OW 69
21231: ST_TO_ADDR
// if not tmp then
21232: LD_VAR 0 2
21236: NOT
21237: IFFALSE 21241
// exit ;
21239: GO 21324
// p := 0 ;
21241: LD_ADDR_VAR 0 3
21245: PUSH
21246: LD_INT 0
21248: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21249: LD_INT 35
21251: PPUSH
21252: CALL_OW 67
// p := p + 1 ;
21256: LD_ADDR_VAR 0 3
21260: PUSH
21261: LD_VAR 0 3
21265: PUSH
21266: LD_INT 1
21268: PLUS
21269: ST_TO_ADDR
// for i in tmp do
21270: LD_ADDR_VAR 0 1
21274: PUSH
21275: LD_VAR 0 2
21279: PUSH
21280: FOR_IN
21281: IFFALSE 21312
// if GetLives ( i ) < 1000 then
21283: LD_VAR 0 1
21287: PPUSH
21288: CALL_OW 256
21292: PUSH
21293: LD_INT 1000
21295: LESS
21296: IFFALSE 21310
// SetLives ( i , 1000 ) ;
21298: LD_VAR 0 1
21302: PPUSH
21303: LD_INT 1000
21305: PPUSH
21306: CALL_OW 234
21310: GO 21280
21312: POP
21313: POP
// until p > 20 ;
21314: LD_VAR 0 3
21318: PUSH
21319: LD_INT 20
21321: GREATER
21322: IFFALSE 21249
// end ;
21324: PPOPN 3
21326: END
// every 0 0$1 trigger StreamModeActive and sTime do
21327: LD_EXP 30
21331: PUSH
21332: LD_EXP 81
21336: AND
21337: IFFALSE 21372
21339: GO 21341
21341: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
21342: LD_INT 28
21344: PPUSH
21345: LD_OWVAR 2
21349: PPUSH
21350: LD_INT 2
21352: PPUSH
21353: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
21357: LD_INT 30
21359: PPUSH
21360: LD_OWVAR 2
21364: PPUSH
21365: LD_INT 2
21367: PPUSH
21368: CALL_OW 322
// end ;
21372: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
21373: LD_EXP 30
21377: PUSH
21378: LD_EXP 82
21382: AND
21383: IFFALSE 21504
21385: GO 21387
21387: DISABLE
21388: LD_INT 0
21390: PPUSH
21391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
21392: LD_ADDR_VAR 0 2
21396: PUSH
21397: LD_INT 22
21399: PUSH
21400: LD_OWVAR 2
21404: PUSH
21405: EMPTY
21406: LIST
21407: LIST
21408: PUSH
21409: LD_INT 21
21411: PUSH
21412: LD_INT 1
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 3
21421: PUSH
21422: LD_INT 23
21424: PUSH
21425: LD_INT 0
21427: PUSH
21428: EMPTY
21429: LIST
21430: LIST
21431: PUSH
21432: EMPTY
21433: LIST
21434: LIST
21435: PUSH
21436: EMPTY
21437: LIST
21438: LIST
21439: LIST
21440: PPUSH
21441: CALL_OW 69
21445: ST_TO_ADDR
// if not tmp then
21446: LD_VAR 0 2
21450: NOT
21451: IFFALSE 21455
// exit ;
21453: GO 21504
// for i in tmp do
21455: LD_ADDR_VAR 0 1
21459: PUSH
21460: LD_VAR 0 2
21464: PUSH
21465: FOR_IN
21466: IFFALSE 21502
// begin if Crawls ( i ) then
21468: LD_VAR 0 1
21472: PPUSH
21473: CALL_OW 318
21477: IFFALSE 21488
// ComWalk ( i ) ;
21479: LD_VAR 0 1
21483: PPUSH
21484: CALL_OW 138
// SetClass ( i , 2 ) ;
21488: LD_VAR 0 1
21492: PPUSH
21493: LD_INT 2
21495: PPUSH
21496: CALL_OW 336
// end ;
21500: GO 21465
21502: POP
21503: POP
// end ;
21504: PPOPN 2
21506: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
21507: LD_EXP 30
21511: PUSH
21512: LD_EXP 83
21516: AND
21517: IFFALSE 21738
21519: GO 21521
21521: DISABLE
21522: LD_INT 0
21524: PPUSH
21525: PPUSH
21526: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
21527: LD_OWVAR 2
21531: PPUSH
21532: LD_INT 9
21534: PPUSH
21535: LD_INT 1
21537: PPUSH
21538: LD_INT 1
21540: PPUSH
21541: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
21545: LD_INT 9
21547: PPUSH
21548: LD_OWVAR 2
21552: PPUSH
21553: CALL_OW 343
// uc_side := 9 ;
21557: LD_ADDR_OWVAR 20
21561: PUSH
21562: LD_INT 9
21564: ST_TO_ADDR
// uc_nation := 2 ;
21565: LD_ADDR_OWVAR 21
21569: PUSH
21570: LD_INT 2
21572: ST_TO_ADDR
// hc_name := Dark Warrior ;
21573: LD_ADDR_OWVAR 26
21577: PUSH
21578: LD_STRING Dark Warrior
21580: ST_TO_ADDR
// hc_gallery :=  ;
21581: LD_ADDR_OWVAR 33
21585: PUSH
21586: LD_STRING 
21588: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , 10 ) ;
21589: LD_INT 1
21591: PPUSH
21592: LD_INT 1
21594: PPUSH
21595: LD_INT 10
21597: PPUSH
21598: CALL_OW 380
// un := CreateHuman ;
21602: LD_ADDR_VAR 0 3
21606: PUSH
21607: CALL_OW 44
21611: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
21612: LD_VAR 0 3
21616: PPUSH
21617: LD_INT 1
21619: PPUSH
21620: CALL_OW 51
// p := 0 ;
21624: LD_ADDR_VAR 0 2
21628: PUSH
21629: LD_INT 0
21631: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21632: LD_INT 35
21634: PPUSH
21635: CALL_OW 67
// if GetLives ( un ) < 1000 then
21639: LD_VAR 0 3
21643: PPUSH
21644: CALL_OW 256
21648: PUSH
21649: LD_INT 1000
21651: LESS
21652: IFFALSE 21666
// SetLives ( un , 1000 ) ;
21654: LD_VAR 0 3
21658: PPUSH
21659: LD_INT 1000
21661: PPUSH
21662: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , your_side ] ) , un ) ) ;
21666: LD_VAR 0 3
21670: PPUSH
21671: LD_INT 81
21673: PUSH
21674: LD_OWVAR 2
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: PPUSH
21683: CALL_OW 69
21687: PPUSH
21688: LD_VAR 0 3
21692: PPUSH
21693: CALL_OW 74
21697: PPUSH
21698: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
21702: LD_VAR 0 2
21706: PUSH
21707: LD_INT 60
21709: GREATER
21710: PUSH
21711: LD_VAR 0 3
21715: PPUSH
21716: CALL_OW 301
21720: OR
21721: IFFALSE 21632
// if un then
21723: LD_VAR 0 3
21727: IFFALSE 21738
// RemoveUnit ( un ) ;
21729: LD_VAR 0 3
21733: PPUSH
21734: CALL_OW 64
// end ; end_of_file
21738: PPOPN 3
21740: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
21741: LD_INT 0
21743: PPUSH
21744: PPUSH
21745: PPUSH
21746: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
21747: LD_VAR 0 1
21751: PPUSH
21752: CALL_OW 264
21756: PUSH
21757: LD_EXP 29
21761: EQUAL
21762: IFFALSE 21834
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
21764: LD_INT 68
21766: PPUSH
21767: LD_VAR 0 1
21771: PPUSH
21772: CALL_OW 255
21776: PPUSH
21777: CALL_OW 321
21781: PUSH
21782: LD_INT 2
21784: EQUAL
21785: IFFALSE 21797
// eff := 70 else
21787: LD_ADDR_VAR 0 6
21791: PUSH
21792: LD_INT 70
21794: ST_TO_ADDR
21795: GO 21805
// eff := 30 ;
21797: LD_ADDR_VAR 0 6
21801: PUSH
21802: LD_INT 30
21804: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
21805: LD_VAR 0 1
21809: PPUSH
21810: CALL_OW 250
21814: PPUSH
21815: LD_VAR 0 1
21819: PPUSH
21820: CALL_OW 251
21824: PPUSH
21825: LD_VAR 0 6
21829: PPUSH
21830: CALL_OW 495
// end ; end ;
21834: LD_VAR 0 4
21838: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
21839: LD_INT 0
21841: PPUSH
21842: PPUSH
21843: PPUSH
21844: PPUSH
21845: PPUSH
21846: PPUSH
// if cmd = 124 then
21847: LD_VAR 0 1
21851: PUSH
21852: LD_INT 124
21854: EQUAL
21855: IFFALSE 22061
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
21857: LD_ADDR_VAR 0 5
21861: PUSH
21862: LD_INT 2
21864: PUSH
21865: LD_INT 34
21867: PUSH
21868: LD_INT 53
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PUSH
21875: LD_INT 34
21877: PUSH
21878: LD_INT 14
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: EMPTY
21886: LIST
21887: LIST
21888: LIST
21889: PPUSH
21890: CALL_OW 69
21894: ST_TO_ADDR
// if not tmp then
21895: LD_VAR 0 5
21899: NOT
21900: IFFALSE 21904
// exit ;
21902: GO 22061
// for i in tmp do
21904: LD_ADDR_VAR 0 3
21908: PUSH
21909: LD_VAR 0 5
21913: PUSH
21914: FOR_IN
21915: IFFALSE 22059
// begin taskList := GetTaskList ( i ) ;
21917: LD_ADDR_VAR 0 6
21921: PUSH
21922: LD_VAR 0 3
21926: PPUSH
21927: CALL_OW 437
21931: ST_TO_ADDR
// if not taskList then
21932: LD_VAR 0 6
21936: NOT
21937: IFFALSE 21941
// continue ;
21939: GO 21914
// for j = 1 to taskList do
21941: LD_ADDR_VAR 0 4
21945: PUSH
21946: DOUBLE
21947: LD_INT 1
21949: DEC
21950: ST_TO_ADDR
21951: LD_VAR 0 6
21955: PUSH
21956: FOR_TO
21957: IFFALSE 22055
// if taskList [ j ] [ 1 ] = | then
21959: LD_VAR 0 6
21963: PUSH
21964: LD_VAR 0 4
21968: ARRAY
21969: PUSH
21970: LD_INT 1
21972: ARRAY
21973: PUSH
21974: LD_STRING |
21976: EQUAL
21977: IFFALSE 22053
// begin _taskList := Delete ( taskList , 1 ) ;
21979: LD_ADDR_VAR 0 7
21983: PUSH
21984: LD_VAR 0 6
21988: PPUSH
21989: LD_INT 1
21991: PPUSH
21992: CALL_OW 3
21996: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
21997: LD_VAR 0 3
22001: PPUSH
22002: LD_VAR 0 7
22006: PPUSH
22007: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
22011: LD_VAR 0 3
22015: PPUSH
22016: LD_VAR 0 6
22020: PUSH
22021: LD_VAR 0 4
22025: ARRAY
22026: PUSH
22027: LD_INT 2
22029: ARRAY
22030: PPUSH
22031: LD_VAR 0 6
22035: PUSH
22036: LD_VAR 0 4
22040: ARRAY
22041: PUSH
22042: LD_INT 3
22044: ARRAY
22045: PPUSH
22046: LD_INT 8
22048: PPUSH
22049: CALL 22066 0 4
// end ;
22053: GO 21956
22055: POP
22056: POP
// end ;
22057: GO 21914
22059: POP
22060: POP
// end ; end ;
22061: LD_VAR 0 2
22065: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
22066: LD_INT 0
22068: PPUSH
22069: PPUSH
22070: PPUSH
22071: PPUSH
22072: PPUSH
22073: PPUSH
22074: PPUSH
22075: PPUSH
22076: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
22077: LD_VAR 0 1
22081: NOT
22082: PUSH
22083: LD_VAR 0 2
22087: PPUSH
22088: LD_VAR 0 3
22092: PPUSH
22093: CALL_OW 488
22097: NOT
22098: OR
22099: PUSH
22100: LD_VAR 0 4
22104: NOT
22105: OR
22106: IFFALSE 22110
// exit ;
22108: GO 22450
// list := [ ] ;
22110: LD_ADDR_VAR 0 13
22114: PUSH
22115: EMPTY
22116: ST_TO_ADDR
// if x - r < 0 then
22117: LD_VAR 0 2
22121: PUSH
22122: LD_VAR 0 4
22126: MINUS
22127: PUSH
22128: LD_INT 0
22130: LESS
22131: IFFALSE 22143
// min_x := 0 else
22133: LD_ADDR_VAR 0 7
22137: PUSH
22138: LD_INT 0
22140: ST_TO_ADDR
22141: GO 22159
// min_x := x - r ;
22143: LD_ADDR_VAR 0 7
22147: PUSH
22148: LD_VAR 0 2
22152: PUSH
22153: LD_VAR 0 4
22157: MINUS
22158: ST_TO_ADDR
// if y - r < 0 then
22159: LD_VAR 0 3
22163: PUSH
22164: LD_VAR 0 4
22168: MINUS
22169: PUSH
22170: LD_INT 0
22172: LESS
22173: IFFALSE 22185
// min_y := 0 else
22175: LD_ADDR_VAR 0 8
22179: PUSH
22180: LD_INT 0
22182: ST_TO_ADDR
22183: GO 22201
// min_y := y - r ;
22185: LD_ADDR_VAR 0 8
22189: PUSH
22190: LD_VAR 0 3
22194: PUSH
22195: LD_VAR 0 4
22199: MINUS
22200: ST_TO_ADDR
// max_x := x + r ;
22201: LD_ADDR_VAR 0 9
22205: PUSH
22206: LD_VAR 0 2
22210: PUSH
22211: LD_VAR 0 4
22215: PLUS
22216: ST_TO_ADDR
// max_y := y + r ;
22217: LD_ADDR_VAR 0 10
22221: PUSH
22222: LD_VAR 0 3
22226: PUSH
22227: LD_VAR 0 4
22231: PLUS
22232: ST_TO_ADDR
// for _x = min_x to max_x do
22233: LD_ADDR_VAR 0 11
22237: PUSH
22238: DOUBLE
22239: LD_VAR 0 7
22243: DEC
22244: ST_TO_ADDR
22245: LD_VAR 0 9
22249: PUSH
22250: FOR_TO
22251: IFFALSE 22368
// for _y = min_y to max_y do
22253: LD_ADDR_VAR 0 12
22257: PUSH
22258: DOUBLE
22259: LD_VAR 0 8
22263: DEC
22264: ST_TO_ADDR
22265: LD_VAR 0 10
22269: PUSH
22270: FOR_TO
22271: IFFALSE 22364
// begin if not ValidHex ( _x , _y ) then
22273: LD_VAR 0 11
22277: PPUSH
22278: LD_VAR 0 12
22282: PPUSH
22283: CALL_OW 488
22287: NOT
22288: IFFALSE 22292
// continue ;
22290: GO 22270
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
22292: LD_VAR 0 11
22296: PPUSH
22297: LD_VAR 0 12
22301: PPUSH
22302: CALL_OW 351
22306: PUSH
22307: LD_VAR 0 11
22311: PPUSH
22312: LD_VAR 0 12
22316: PPUSH
22317: CALL_OW 554
22321: AND
22322: IFFALSE 22362
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
22324: LD_ADDR_VAR 0 13
22328: PUSH
22329: LD_VAR 0 13
22333: PPUSH
22334: LD_VAR 0 13
22338: PUSH
22339: LD_INT 1
22341: PLUS
22342: PPUSH
22343: LD_VAR 0 11
22347: PUSH
22348: LD_VAR 0 12
22352: PUSH
22353: EMPTY
22354: LIST
22355: LIST
22356: PPUSH
22357: CALL_OW 2
22361: ST_TO_ADDR
// end ;
22362: GO 22270
22364: POP
22365: POP
22366: GO 22250
22368: POP
22369: POP
// if not list then
22370: LD_VAR 0 13
22374: NOT
22375: IFFALSE 22379
// exit ;
22377: GO 22450
// for i in list do
22379: LD_ADDR_VAR 0 6
22383: PUSH
22384: LD_VAR 0 13
22388: PUSH
22389: FOR_IN
22390: IFFALSE 22448
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
22392: LD_VAR 0 1
22396: PPUSH
22397: LD_STRING M
22399: PUSH
22400: LD_VAR 0 6
22404: PUSH
22405: LD_INT 1
22407: ARRAY
22408: PUSH
22409: LD_VAR 0 6
22413: PUSH
22414: LD_INT 2
22416: ARRAY
22417: PUSH
22418: LD_INT 0
22420: PUSH
22421: LD_INT 0
22423: PUSH
22424: LD_INT 0
22426: PUSH
22427: LD_INT 0
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: LIST
22434: LIST
22435: LIST
22436: LIST
22437: LIST
22438: PUSH
22439: EMPTY
22440: LIST
22441: PPUSH
22442: CALL_OW 447
22446: GO 22389
22448: POP
22449: POP
// end ;
22450: LD_VAR 0 5
22454: RET
