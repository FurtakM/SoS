// starting begin ResetFog ;
   0: CALL_OW 335
// Init ;
   4: CALL 59 0 0
// Action ;
   8: CALL 8158 0 0
// PrepareAnimals ( 6 , 3 , 4 , apearea ) ;
  12: LD_INT 6
  14: PPUSH
  15: LD_INT 3
  17: PPUSH
  18: LD_INT 4
  20: PPUSH
  21: LD_INT 21
  23: PPUSH
  24: CALL 10482 0 4
// PrepareAmerican ;
  28: CALL 3950 0 0
// PrepareRussian ;
  32: CALL 270 0 0
// end ;
  36: END
// every 0 0$01 do
  37: GO 39
  39: DISABLE
// begin enable ;
  40: ENABLE
// display_strings := [ #tick , tick ] ;
  41: LD_ADDR_OWVAR 47
  45: PUSH
  46: LD_STRING #tick
  48: PUSH
  49: LD_OWVAR 1
  53: PUSH
  54: EMPTY
  55: LIST
  56: LIST
  57: ST_TO_ADDR
// end ;
  58: END
// export conv_squad , escort , medal1 , medal2 , medal3 , path , convoy_start , dest_counter ; export riv , ar_attacks , ar_force , us_force , conv_counter , crates_counter ; function Init ; begin
  59: LD_INT 0
  61: PPUSH
// medal1 := true ;
  62: LD_ADDR_EXP 3
  66: PUSH
  67: LD_INT 1
  69: ST_TO_ADDR
// medal2 := true ;
  70: LD_ADDR_EXP 4
  74: PUSH
  75: LD_INT 1
  77: ST_TO_ADDR
// medal3 := true ;
  78: LD_ADDR_EXP 5
  82: PUSH
  83: LD_INT 1
  85: ST_TO_ADDR
// path := [ p1 , p2 , p3 , p4 , conv_end ] ;
  86: LD_ADDR_EXP 6
  90: PUSH
  91: LD_INT 10
  93: PUSH
  94: LD_INT 11
  96: PUSH
  97: LD_INT 12
  99: PUSH
 100: LD_INT 13
 102: PUSH
 103: LD_INT 9
 105: PUSH
 106: EMPTY
 107: LIST
 108: LIST
 109: LIST
 110: LIST
 111: LIST
 112: ST_TO_ADDR
// conv_squad := [ ] ;
 113: LD_ADDR_EXP 1
 117: PUSH
 118: EMPTY
 119: ST_TO_ADDR
// escort := [ ] ;
 120: LD_ADDR_EXP 2
 124: PUSH
 125: EMPTY
 126: ST_TO_ADDR
// riv := [ ] ;
 127: LD_ADDR_EXP 9
 131: PUSH
 132: EMPTY
 133: ST_TO_ADDR
// ar_force := [ ] ;
 134: LD_ADDR_EXP 11
 138: PUSH
 139: EMPTY
 140: ST_TO_ADDR
// ar_attacks := false ;
 141: LD_ADDR_EXP 10
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// us_force := [ ] ;
 149: LD_ADDR_EXP 12
 153: PUSH
 154: EMPTY
 155: ST_TO_ADDR
// convoy_start := false ;
 156: LD_ADDR_EXP 7
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// conv_counter := 0 ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// dest_counter := 0 ;
 172: LD_ADDR_EXP 8
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// crates_counter := 0 0$40 ;
 180: LD_ADDR_EXP 14
 184: PUSH
 185: LD_INT 1400
 187: ST_TO_ADDR
// end ;
 188: LD_VAR 0 1
 192: RET
// every 2 2$00 do
 193: GO 195
 195: DISABLE
// begin while ( tick <= [ 47 47$00 , 44 44$00 , 41 41$00 ] [ Difficulty ] ) do
 196: LD_OWVAR 1
 200: PUSH
 201: LD_INT 98700
 203: PUSH
 204: LD_INT 92400
 206: PUSH
 207: LD_INT 86100
 209: PUSH
 210: EMPTY
 211: LIST
 212: LIST
 213: LIST
 214: PUSH
 215: LD_OWVAR 67
 219: ARRAY
 220: LESSEQUAL
 221: IFFALSE 269
// begin Wait ( crates_counter ) ;
 223: LD_EXP 14
 227: PPUSH
 228: CALL_OW 67
// crates_counter := crates_counter + 0 0$09 ;
 232: LD_ADDR_EXP 14
 236: PUSH
 237: LD_EXP 14
 241: PUSH
 242: LD_INT 315
 244: PLUS
 245: ST_TO_ADDR
// CreateCratesArea ( Rand ( 1 , 5 ) , crates_spawn , true ) ;
 246: LD_INT 1
 248: PPUSH
 249: LD_INT 5
 251: PPUSH
 252: CALL_OW 12
 256: PPUSH
 257: LD_INT 22
 259: PPUSH
 260: LD_INT 1
 262: PPUSH
 263: CALL_OW 55
// end ;
 267: GO 196
// end ; end_of_file
 269: END
// export Stolypin , Popov , Saseda ; export function PrepareRussian ; var un , force , i , c , skill , team ; begin
 270: LD_INT 0
 272: PPUSH
 273: PPUSH
 274: PPUSH
 275: PPUSH
 276: PPUSH
 277: PPUSH
 278: PPUSH
// uc_side := 6 ;
 279: LD_ADDR_OWVAR 20
 283: PUSH
 284: LD_INT 6
 286: ST_TO_ADDR
// uc_nation := 3 ;
 287: LD_ADDR_OWVAR 21
 291: PUSH
 292: LD_INT 3
 294: ST_TO_ADDR
// ChangeSideFog ( 3 , 6 ) ;
 295: LD_INT 3
 297: PPUSH
 298: LD_INT 6
 300: PPUSH
 301: CALL_OW 343
// Popov := NewCharacter ( Gaydar ) ;
 305: LD_ADDR_EXP 16
 309: PUSH
 310: LD_STRING Gaydar
 312: PPUSH
 313: CALL_OW 25
 317: ST_TO_ADDR
// uc_side := 7 ;
 318: LD_ADDR_OWVAR 20
 322: PUSH
 323: LD_INT 7
 325: ST_TO_ADDR
// hc_gallery := sandal ;
 326: LD_ADDR_OWVAR 33
 330: PUSH
 331: LD_STRING sandal
 333: ST_TO_ADDR
// hc_face_number := 9 ;
 334: LD_ADDR_OWVAR 34
 338: PUSH
 339: LD_INT 9
 341: ST_TO_ADDR
// hc_skills := [ 3 , 5 , 2 , 7 ] ;
 342: LD_ADDR_OWVAR 31
 346: PUSH
 347: LD_INT 3
 349: PUSH
 350: LD_INT 5
 352: PUSH
 353: LD_INT 2
 355: PUSH
 356: LD_INT 7
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: LIST
 363: LIST
 364: ST_TO_ADDR
// hc_sex := sex_male ;
 365: LD_ADDR_OWVAR 27
 369: PUSH
 370: LD_INT 1
 372: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 373: LD_ADDR_OWVAR 29
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: ST_TO_ADDR
// hc_class := 4 ;
 388: LD_ADDR_OWVAR 28
 392: PUSH
 393: LD_INT 4
 395: ST_TO_ADDR
// hc_name := Fiodor Saseda ;
 396: LD_ADDR_OWVAR 26
 400: PUSH
 401: LD_STRING Fiodor Saseda
 403: ST_TO_ADDR
// Saseda := CreateHuman ;
 404: LD_ADDR_EXP 17
 408: PUSH
 409: CALL_OW 44
 413: ST_TO_ADDR
// uc_side := 3 ;
 414: LD_ADDR_OWVAR 20
 418: PUSH
 419: LD_INT 3
 421: ST_TO_ADDR
// hc_importance := 100 ;
 422: LD_ADDR_OWVAR 32
 426: PUSH
 427: LD_INT 100
 429: ST_TO_ADDR
// hc_class := 1 ;
 430: LD_ADDR_OWVAR 28
 434: PUSH
 435: LD_INT 1
 437: ST_TO_ADDR
// hc_sex := sex_male ;
 438: LD_ADDR_OWVAR 27
 442: PUSH
 443: LD_INT 1
 445: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
 446: LD_ADDR_OWVAR 31
 450: PUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 3
 456: PUSH
 457: LD_INT 4
 459: PUSH
 460: LD_INT 2
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: ST_TO_ADDR
// hc_name := W. I. Stolypin ;
 469: LD_ADDR_OWVAR 26
 473: PUSH
 474: LD_STRING W. I. Stolypin
 476: ST_TO_ADDR
// hc_attr := [ 10 , 11 ] ;
 477: LD_ADDR_OWVAR 29
 481: PUSH
 482: LD_INT 10
 484: PUSH
 485: LD_INT 11
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: ST_TO_ADDR
// hc_gallery := ru ;
 492: LD_ADDR_OWVAR 33
 496: PUSH
 497: LD_STRING ru
 499: ST_TO_ADDR
// hc_face_number := 15 ;
 500: LD_ADDR_OWVAR 34
 504: PUSH
 505: LD_INT 15
 507: ST_TO_ADDR
// Stolypin := CreateHuman ;
 508: LD_ADDR_EXP 15
 512: PUSH
 513: CALL_OW 44
 517: ST_TO_ADDR
// hc_importance := 0 ;
 518: LD_ADDR_OWVAR 32
 522: PUSH
 523: LD_INT 0
 525: ST_TO_ADDR
// hc_gallery :=  ;
 526: LD_ADDR_OWVAR 33
 530: PUSH
 531: LD_STRING 
 533: ST_TO_ADDR
// hc_name :=  ;
 534: LD_ADDR_OWVAR 26
 538: PUSH
 539: LD_STRING 
 541: ST_TO_ADDR
// skill := [ 6 , 5 , 5 ] [ Difficulty ] ;
 542: LD_ADDR_VAR 0 6
 546: PUSH
 547: LD_INT 6
 549: PUSH
 550: LD_INT 5
 552: PUSH
 553: LD_INT 5
 555: PUSH
 556: EMPTY
 557: LIST
 558: LIST
 559: LIST
 560: PUSH
 561: LD_OWVAR 67
 565: ARRAY
 566: ST_TO_ADDR
// c := 1 ;
 567: LD_ADDR_VAR 0 5
 571: PUSH
 572: LD_INT 1
 574: ST_TO_ADDR
// for i = 1 to 21 do
 575: LD_ADDR_VAR 0 4
 579: PUSH
 580: DOUBLE
 581: LD_INT 1
 583: DEC
 584: ST_TO_ADDR
 585: LD_INT 21
 587: PUSH
 588: FOR_TO
 589: IFFALSE 690
// begin if i = 10 then
 591: LD_VAR 0 4
 595: PUSH
 596: LD_INT 10
 598: EQUAL
 599: IFFALSE 609
// c := 2 ;
 601: LD_ADDR_VAR 0 5
 605: PUSH
 606: LD_INT 2
 608: ST_TO_ADDR
// if i = 14 then
 609: LD_VAR 0 4
 613: PUSH
 614: LD_INT 14
 616: EQUAL
 617: IFFALSE 627
// c := 3 ;
 619: LD_ADDR_VAR 0 5
 623: PUSH
 624: LD_INT 3
 626: ST_TO_ADDR
// if i = 18 then
 627: LD_VAR 0 4
 631: PUSH
 632: LD_INT 18
 634: EQUAL
 635: IFFALSE 645
// c := 4 ;
 637: LD_ADDR_VAR 0 5
 641: PUSH
 642: LD_INT 4
 644: ST_TO_ADDR
// PrepareHuman ( false , c , skill ) ;
 645: LD_INT 0
 647: PPUSH
 648: LD_VAR 0 5
 652: PPUSH
 653: LD_VAR 0 6
 657: PPUSH
 658: CALL_OW 380
// un := CreateHuman ;
 662: LD_ADDR_VAR 0 2
 666: PUSH
 667: CALL_OW 44
 671: ST_TO_ADDR
// force := force ^ un ;
 672: LD_ADDR_VAR 0 3
 676: PUSH
 677: LD_VAR 0 3
 681: PUSH
 682: LD_VAR 0 2
 686: ADD
 687: ST_TO_ADDR
// end ;
 688: GO 588
 690: POP
 691: POP
// team := CharacterSelection ( text , [ 8 , 7 , 7 ] [ Difficulty ] , [ 8 , 7 , 7 ] [ Difficulty ] , [ sel_change_class , Stolypin , sel_changeable , sel_not_hired ] ^ force , [ [ class_soldier , 3 ] , class_mechanic , [ class_engineer , 1 ] , class_scientistic ] ) ;
 692: LD_ADDR_VAR 0 7
 696: PUSH
 697: LD_STRING text
 699: PPUSH
 700: LD_INT 8
 702: PUSH
 703: LD_INT 7
 705: PUSH
 706: LD_INT 7
 708: PUSH
 709: EMPTY
 710: LIST
 711: LIST
 712: LIST
 713: PUSH
 714: LD_OWVAR 67
 718: ARRAY
 719: PPUSH
 720: LD_INT 8
 722: PUSH
 723: LD_INT 7
 725: PUSH
 726: LD_INT 7
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_OWVAR 67
 738: ARRAY
 739: PPUSH
 740: LD_INT -5
 742: PUSH
 743: LD_EXP 15
 747: PUSH
 748: LD_INT -3
 750: PUSH
 751: LD_INT -2
 753: PUSH
 754: EMPTY
 755: LIST
 756: LIST
 757: LIST
 758: LIST
 759: PUSH
 760: LD_VAR 0 3
 764: ADD
 765: PPUSH
 766: LD_INT 1
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: EMPTY
 773: LIST
 774: LIST
 775: PUSH
 776: LD_INT 3
 778: PUSH
 779: LD_INT 2
 781: PUSH
 782: LD_INT 1
 784: PUSH
 785: EMPTY
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 4
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: LIST
 796: LIST
 797: PPUSH
 798: CALL_OW 42
 802: ST_TO_ADDR
// team := team ^ Stolypin ;
 803: LD_ADDR_VAR 0 7
 807: PUSH
 808: LD_VAR 0 7
 812: PUSH
 813: LD_EXP 15
 817: ADD
 818: ST_TO_ADDR
// for i = 1 to team do
 819: LD_ADDR_VAR 0 4
 823: PUSH
 824: DOUBLE
 825: LD_INT 1
 827: DEC
 828: ST_TO_ADDR
 829: LD_VAR 0 7
 833: PUSH
 834: FOR_TO
 835: IFFALSE 860
// PlaceUnitArea ( team [ i ] , rus_start , false ) ;
 837: LD_VAR 0 7
 841: PUSH
 842: LD_VAR 0 4
 846: ARRAY
 847: PPUSH
 848: LD_INT 1
 850: PPUSH
 851: LD_INT 0
 853: PPUSH
 854: CALL_OW 49
 858: GO 834
 860: POP
 861: POP
// CenterNowOnUnits ( Stolypin ) ;
 862: LD_EXP 15
 866: PPUSH
 867: CALL_OW 87
// end ;
 871: LD_VAR 0 1
 875: RET
// export conv_ready ; export function Convoy ( type ) ; var i , veh , skill ; begin
 876: LD_INT 0
 878: PPUSH
 879: PPUSH
 880: PPUSH
 881: PPUSH
// Randomize ;
 882: CALL_OW 10
// uc_side := 6 ;
 886: LD_ADDR_OWVAR 20
 890: PUSH
 891: LD_INT 6
 893: ST_TO_ADDR
// uc_nation := 3 ;
 894: LD_ADDR_OWVAR 21
 898: PUSH
 899: LD_INT 3
 901: ST_TO_ADDR
// hc_name :=  ;
 902: LD_ADDR_OWVAR 26
 906: PUSH
 907: LD_STRING 
 909: ST_TO_ADDR
// hc_gallery :=  ;
 910: LD_ADDR_OWVAR 33
 914: PUSH
 915: LD_STRING 
 917: ST_TO_ADDR
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
 918: LD_ADDR_VAR 0 5
 922: PUSH
 923: LD_INT 5
 925: PUSH
 926: LD_INT 5
 928: PUSH
 929: LD_INT 4
 931: PUSH
 932: EMPTY
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_OWVAR 67
 941: ARRAY
 942: ST_TO_ADDR
// conv_ready := false ;
 943: LD_ADDR_EXP 18
 947: PUSH
 948: LD_INT 0
 950: ST_TO_ADDR
// case type of 1 :
 951: LD_VAR 0 1
 955: PUSH
 956: LD_INT 1
 958: DOUBLE
 959: EQUAL
 960: IFTRUE 964
 962: GO 1234
 964: POP
// begin if Rand ( 0 , 1 ) = 1 then
 965: LD_INT 0
 967: PPUSH
 968: LD_INT 1
 970: PPUSH
 971: CALL_OW 12
 975: PUSH
 976: LD_INT 1
 978: EQUAL
 979: IFFALSE 985
// AddEscort ( ) ;
 981: CALL 2859 0 0
// Wait ( 0 0$02 ) ;
 985: LD_INT 70
 987: PPUSH
 988: CALL_OW 67
// vc_chassis := ru_medium_wheeled ;
 992: LD_ADDR_OWVAR 37
 996: PUSH
 997: LD_INT 21
 999: ST_TO_ADDR
// vc_engine := engine_combustion ;
1000: LD_ADDR_OWVAR 39
1004: PUSH
1005: LD_INT 1
1007: ST_TO_ADDR
// vc_control := control_manual ;
1008: LD_ADDR_OWVAR 38
1012: PUSH
1013: LD_INT 1
1015: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1016: LD_ADDR_OWVAR 40
1020: PUSH
1021: LD_INT 51
1023: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1024: LD_ADDR_OWVAR 41
1028: PUSH
1029: LD_INT 50
1031: PPUSH
1032: LD_INT 99
1034: PPUSH
1035: CALL_OW 12
1039: ST_TO_ADDR
// if uc_side <> 6 then
1040: LD_OWVAR 20
1044: PUSH
1045: LD_INT 6
1047: NONEQUAL
1048: IFFALSE 1058
// uc_side := 6 ;
1050: LD_ADDR_OWVAR 20
1054: PUSH
1055: LD_INT 6
1057: ST_TO_ADDR
// veh := CreateVehicle ;
1058: LD_ADDR_VAR 0 4
1062: PUSH
1063: CALL_OW 45
1067: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1068: LD_VAR 0 4
1072: PPUSH
1073: LD_INT 3
1075: PPUSH
1076: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1080: LD_VAR 0 4
1084: PPUSH
1085: LD_INT 8
1087: PPUSH
1088: LD_INT 0
1090: PPUSH
1091: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1095: LD_INT 0
1097: PPUSH
1098: LD_INT 1
1100: PPUSH
1101: LD_INT 2
1103: PPUSH
1104: CALL_OW 12
1108: PPUSH
1109: LD_VAR 0 5
1113: PPUSH
1114: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1118: CALL_OW 44
1122: PPUSH
1123: LD_VAR 0 4
1127: PPUSH
1128: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1132: LD_VAR 0 4
1136: PPUSH
1137: LD_INT 500
1139: PPUSH
1140: LD_INT 1000
1142: PPUSH
1143: CALL_OW 12
1147: PPUSH
1148: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1152: LD_VAR 0 4
1156: PPUSH
1157: LD_INT 1
1159: PPUSH
1160: LD_INT 2
1162: PPUSH
1163: CALL_OW 12
1167: PPUSH
1168: LD_INT 2
1170: PPUSH
1171: LD_INT 10
1173: PPUSH
1174: CALL_OW 12
1178: PUSH
1179: LD_INT 10
1181: MUL
1182: PPUSH
1183: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1187: LD_ADDR_EXP 1
1191: PUSH
1192: LD_EXP 1
1196: PPUSH
1197: LD_INT 1
1199: PPUSH
1200: LD_VAR 0 4
1204: PUSH
1205: LD_INT 1
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: PPUSH
1212: CALL_OW 2
1216: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
1217: LD_INT 35
1219: PPUSH
1220: CALL_OW 67
// conv_ready := true ;
1224: LD_ADDR_EXP 18
1228: PUSH
1229: LD_INT 1
1231: ST_TO_ADDR
// end ; 2 :
1232: GO 2854
1234: LD_INT 2
1236: DOUBLE
1237: EQUAL
1238: IFTRUE 1242
1240: GO 1542
1242: POP
// begin AddEscort ( ) ;
1243: CALL 2859 0 0
// Wait ( 0 0$02 ) ;
1247: LD_INT 70
1249: PPUSH
1250: CALL_OW 67
// for i = 1 to 2 do
1254: LD_ADDR_VAR 0 3
1258: PUSH
1259: DOUBLE
1260: LD_INT 1
1262: DEC
1263: ST_TO_ADDR
1264: LD_INT 2
1266: PUSH
1267: FOR_TO
1268: IFFALSE 1519
// begin vc_chassis := ru_medium_wheeled ;
1270: LD_ADDR_OWVAR 37
1274: PUSH
1275: LD_INT 21
1277: ST_TO_ADDR
// vc_engine := engine_combustion ;
1278: LD_ADDR_OWVAR 39
1282: PUSH
1283: LD_INT 1
1285: ST_TO_ADDR
// vc_control := control_manual ;
1286: LD_ADDR_OWVAR 38
1290: PUSH
1291: LD_INT 1
1293: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1294: LD_ADDR_OWVAR 40
1298: PUSH
1299: LD_INT 51
1301: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1302: LD_ADDR_OWVAR 41
1306: PUSH
1307: LD_INT 50
1309: PPUSH
1310: LD_INT 99
1312: PPUSH
1313: CALL_OW 12
1317: ST_TO_ADDR
// if uc_side <> 6 then
1318: LD_OWVAR 20
1322: PUSH
1323: LD_INT 6
1325: NONEQUAL
1326: IFFALSE 1336
// uc_side := 6 ;
1328: LD_ADDR_OWVAR 20
1332: PUSH
1333: LD_INT 6
1335: ST_TO_ADDR
// veh := CreateVehicle ;
1336: LD_ADDR_VAR 0 4
1340: PUSH
1341: CALL_OW 45
1345: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1346: LD_VAR 0 4
1350: PPUSH
1351: LD_INT 3
1353: PPUSH
1354: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1358: LD_VAR 0 4
1362: PPUSH
1363: LD_INT 8
1365: PPUSH
1366: LD_INT 0
1368: PPUSH
1369: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1373: LD_INT 0
1375: PPUSH
1376: LD_INT 1
1378: PPUSH
1379: LD_INT 2
1381: PPUSH
1382: CALL_OW 12
1386: PPUSH
1387: LD_VAR 0 5
1391: PPUSH
1392: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1396: CALL_OW 44
1400: PPUSH
1401: LD_VAR 0 4
1405: PPUSH
1406: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1410: LD_VAR 0 4
1414: PPUSH
1415: LD_INT 500
1417: PPUSH
1418: LD_INT 1000
1420: PPUSH
1421: CALL_OW 12
1425: PPUSH
1426: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1430: LD_VAR 0 4
1434: PPUSH
1435: LD_INT 1
1437: PPUSH
1438: LD_INT 2
1440: PPUSH
1441: CALL_OW 12
1445: PPUSH
1446: LD_INT 2
1448: PPUSH
1449: LD_INT 10
1451: PPUSH
1452: CALL_OW 12
1456: PUSH
1457: LD_INT 10
1459: MUL
1460: PPUSH
1461: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1465: LD_ADDR_EXP 1
1469: PUSH
1470: LD_EXP 1
1474: PPUSH
1475: LD_INT 1
1477: PPUSH
1478: LD_VAR 0 4
1482: PUSH
1483: LD_INT 1
1485: PUSH
1486: EMPTY
1487: LIST
1488: LIST
1489: PPUSH
1490: CALL_OW 2
1494: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1495: LD_VAR 0 4
1499: PPUSH
1500: LD_INT 120
1502: PPUSH
1503: LD_INT 10
1505: PPUSH
1506: CALL_OW 111
// Wait ( 0 0$02 ) ;
1510: LD_INT 70
1512: PPUSH
1513: CALL_OW 67
// end ;
1517: GO 1267
1519: POP
1520: POP
// AddEscort ( ) ;
1521: CALL 2859 0 0
// Wait ( 0 0$02 ) ;
1525: LD_INT 70
1527: PPUSH
1528: CALL_OW 67
// conv_ready := true ;
1532: LD_ADDR_EXP 18
1536: PUSH
1537: LD_INT 1
1539: ST_TO_ADDR
// end ; 3 :
1540: GO 2854
1542: LD_INT 3
1544: DOUBLE
1545: EQUAL
1546: IFTRUE 1550
1548: GO 1969
1550: POP
// begin AddEscort ( ) ;
1551: CALL 2859 0 0
// Wait ( 0 0$02 ) ;
1555: LD_INT 70
1557: PPUSH
1558: CALL_OW 67
// for i = 1 to 2 do
1562: LD_ADDR_VAR 0 3
1566: PUSH
1567: DOUBLE
1568: LD_INT 1
1570: DEC
1571: ST_TO_ADDR
1572: LD_INT 2
1574: PUSH
1575: FOR_TO
1576: IFFALSE 1827
// begin vc_chassis := ru_medium_wheeled ;
1578: LD_ADDR_OWVAR 37
1582: PUSH
1583: LD_INT 21
1585: ST_TO_ADDR
// vc_engine := engine_combustion ;
1586: LD_ADDR_OWVAR 39
1590: PUSH
1591: LD_INT 1
1593: ST_TO_ADDR
// vc_control := control_manual ;
1594: LD_ADDR_OWVAR 38
1598: PUSH
1599: LD_INT 1
1601: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
1602: LD_ADDR_OWVAR 40
1606: PUSH
1607: LD_INT 51
1609: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
1610: LD_ADDR_OWVAR 41
1614: PUSH
1615: LD_INT 50
1617: PPUSH
1618: LD_INT 99
1620: PPUSH
1621: CALL_OW 12
1625: ST_TO_ADDR
// if uc_side <> 6 then
1626: LD_OWVAR 20
1630: PUSH
1631: LD_INT 6
1633: NONEQUAL
1634: IFFALSE 1644
// uc_side := 6 ;
1636: LD_ADDR_OWVAR 20
1640: PUSH
1641: LD_INT 6
1643: ST_TO_ADDR
// veh := CreateVehicle ;
1644: LD_ADDR_VAR 0 4
1648: PUSH
1649: CALL_OW 45
1653: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1654: LD_VAR 0 4
1658: PPUSH
1659: LD_INT 3
1661: PPUSH
1662: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
1666: LD_VAR 0 4
1670: PPUSH
1671: LD_INT 8
1673: PPUSH
1674: LD_INT 0
1676: PPUSH
1677: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
1681: LD_INT 0
1683: PPUSH
1684: LD_INT 1
1686: PPUSH
1687: LD_INT 2
1689: PPUSH
1690: CALL_OW 12
1694: PPUSH
1695: LD_VAR 0 5
1699: PPUSH
1700: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
1704: CALL_OW 44
1708: PPUSH
1709: LD_VAR 0 4
1713: PPUSH
1714: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
1718: LD_VAR 0 4
1722: PPUSH
1723: LD_INT 500
1725: PPUSH
1726: LD_INT 1000
1728: PPUSH
1729: CALL_OW 12
1733: PPUSH
1734: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
1738: LD_VAR 0 4
1742: PPUSH
1743: LD_INT 1
1745: PPUSH
1746: LD_INT 2
1748: PPUSH
1749: CALL_OW 12
1753: PPUSH
1754: LD_INT 2
1756: PPUSH
1757: LD_INT 10
1759: PPUSH
1760: CALL_OW 12
1764: PUSH
1765: LD_INT 10
1767: MUL
1768: PPUSH
1769: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
1773: LD_ADDR_EXP 1
1777: PUSH
1778: LD_EXP 1
1782: PPUSH
1783: LD_INT 1
1785: PPUSH
1786: LD_VAR 0 4
1790: PUSH
1791: LD_INT 1
1793: PUSH
1794: EMPTY
1795: LIST
1796: LIST
1797: PPUSH
1798: CALL_OW 2
1802: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1803: LD_VAR 0 4
1807: PPUSH
1808: LD_INT 120
1810: PPUSH
1811: LD_INT 10
1813: PPUSH
1814: CALL_OW 111
// Wait ( 0 0$02 ) ;
1818: LD_INT 70
1820: PPUSH
1821: CALL_OW 67
// end ;
1825: GO 1575
1827: POP
1828: POP
// for i = 1 to 2 do
1829: LD_ADDR_VAR 0 3
1833: PUSH
1834: DOUBLE
1835: LD_INT 1
1837: DEC
1838: ST_TO_ADDR
1839: LD_INT 2
1841: PUSH
1842: FOR_TO
1843: IFFALSE 1950
// begin PrepareHuman ( false , 1 , skill ) ;
1845: LD_INT 0
1847: PPUSH
1848: LD_INT 1
1850: PPUSH
1851: LD_VAR 0 5
1855: PPUSH
1856: CALL_OW 380
// if uc_side <> 6 then
1860: LD_OWVAR 20
1864: PUSH
1865: LD_INT 6
1867: NONEQUAL
1868: IFFALSE 1878
// uc_side := 6 ;
1870: LD_ADDR_OWVAR 20
1874: PUSH
1875: LD_INT 6
1877: ST_TO_ADDR
// veh := CreateHuman ;
1878: LD_ADDR_VAR 0 4
1882: PUSH
1883: CALL_OW 44
1887: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
1888: LD_VAR 0 4
1892: PPUSH
1893: LD_INT 8
1895: PPUSH
1896: LD_INT 0
1898: PPUSH
1899: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
1903: LD_ADDR_EXP 2
1907: PUSH
1908: LD_EXP 2
1912: PPUSH
1913: LD_INT 1
1915: PPUSH
1916: LD_VAR 0 4
1920: PPUSH
1921: CALL_OW 2
1925: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
1926: LD_VAR 0 4
1930: PPUSH
1931: LD_INT 120
1933: PPUSH
1934: LD_INT 10
1936: PPUSH
1937: CALL_OW 111
// Wait ( 0 0$02 ) ;
1941: LD_INT 70
1943: PPUSH
1944: CALL_OW 67
// end ;
1948: GO 1842
1950: POP
1951: POP
// Wait ( 0 0$02 ) ;
1952: LD_INT 70
1954: PPUSH
1955: CALL_OW 67
// conv_ready := true ;
1959: LD_ADDR_EXP 18
1963: PUSH
1964: LD_INT 1
1966: ST_TO_ADDR
// end ; 4 :
1967: GO 2854
1969: LD_INT 4
1971: DOUBLE
1972: EQUAL
1973: IFTRUE 1977
1975: GO 2283
1977: POP
// begin if Rand ( 0 , 1 ) = 1 then
1978: LD_INT 0
1980: PPUSH
1981: LD_INT 1
1983: PPUSH
1984: CALL_OW 12
1988: PUSH
1989: LD_INT 1
1991: EQUAL
1992: IFFALSE 1998
// AddEscort ( ) ;
1994: CALL 2859 0 0
// Wait ( 0 0$02 ) ;
1998: LD_INT 70
2000: PPUSH
2001: CALL_OW 67
// for i = 1 to 5 do
2005: LD_ADDR_VAR 0 3
2009: PUSH
2010: DOUBLE
2011: LD_INT 1
2013: DEC
2014: ST_TO_ADDR
2015: LD_INT 5
2017: PUSH
2018: FOR_TO
2019: IFFALSE 2141
// begin PrepareHuman ( false , Rand ( 2 , 4 ) , skill ) ;
2021: LD_INT 0
2023: PPUSH
2024: LD_INT 2
2026: PPUSH
2027: LD_INT 4
2029: PPUSH
2030: CALL_OW 12
2034: PPUSH
2035: LD_VAR 0 5
2039: PPUSH
2040: CALL_OW 380
// if uc_side <> 6 then
2044: LD_OWVAR 20
2048: PUSH
2049: LD_INT 6
2051: NONEQUAL
2052: IFFALSE 2062
// uc_side := 6 ;
2054: LD_ADDR_OWVAR 20
2058: PUSH
2059: LD_INT 6
2061: ST_TO_ADDR
// veh := CreateHuman ;
2062: LD_ADDR_VAR 0 4
2066: PUSH
2067: CALL_OW 44
2071: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2072: LD_VAR 0 4
2076: PPUSH
2077: LD_INT 8
2079: PPUSH
2080: LD_INT 0
2082: PPUSH
2083: CALL_OW 49
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2087: LD_ADDR_EXP 1
2091: PUSH
2092: LD_EXP 1
2096: PPUSH
2097: LD_INT 1
2099: PPUSH
2100: LD_VAR 0 4
2104: PUSH
2105: LD_INT 1
2107: PUSH
2108: EMPTY
2109: LIST
2110: LIST
2111: PPUSH
2112: CALL_OW 2
2116: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2117: LD_VAR 0 4
2121: PPUSH
2122: LD_INT 120
2124: PPUSH
2125: LD_INT 10
2127: PPUSH
2128: CALL_OW 111
// Wait ( 0 0$02 ) ;
2132: LD_INT 70
2134: PPUSH
2135: CALL_OW 67
// end ;
2139: GO 2018
2141: POP
2142: POP
// for i = 1 to 2 do
2143: LD_ADDR_VAR 0 3
2147: PUSH
2148: DOUBLE
2149: LD_INT 1
2151: DEC
2152: ST_TO_ADDR
2153: LD_INT 2
2155: PUSH
2156: FOR_TO
2157: IFFALSE 2264
// begin PrepareHuman ( false , 1 , skill ) ;
2159: LD_INT 0
2161: PPUSH
2162: LD_INT 1
2164: PPUSH
2165: LD_VAR 0 5
2169: PPUSH
2170: CALL_OW 380
// if uc_side <> 6 then
2174: LD_OWVAR 20
2178: PUSH
2179: LD_INT 6
2181: NONEQUAL
2182: IFFALSE 2192
// uc_side := 6 ;
2184: LD_ADDR_OWVAR 20
2188: PUSH
2189: LD_INT 6
2191: ST_TO_ADDR
// veh := CreateHuman ;
2192: LD_ADDR_VAR 0 4
2196: PUSH
2197: CALL_OW 44
2201: ST_TO_ADDR
// PlaceUnitArea ( veh , conv_start , false ) ;
2202: LD_VAR 0 4
2206: PPUSH
2207: LD_INT 8
2209: PPUSH
2210: LD_INT 0
2212: PPUSH
2213: CALL_OW 49
// escort := Insert ( escort , 1 , veh ) ;
2217: LD_ADDR_EXP 2
2221: PUSH
2222: LD_EXP 2
2226: PPUSH
2227: LD_INT 1
2229: PPUSH
2230: LD_VAR 0 4
2234: PPUSH
2235: CALL_OW 2
2239: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2240: LD_VAR 0 4
2244: PPUSH
2245: LD_INT 120
2247: PPUSH
2248: LD_INT 10
2250: PPUSH
2251: CALL_OW 111
// Wait ( 0 0$02 ) ;
2255: LD_INT 70
2257: PPUSH
2258: CALL_OW 67
// end ;
2262: GO 2156
2264: POP
2265: POP
// Wait ( 0 0$02 ) ;
2266: LD_INT 70
2268: PPUSH
2269: CALL_OW 67
// conv_ready := true ;
2273: LD_ADDR_EXP 18
2277: PUSH
2278: LD_INT 1
2280: ST_TO_ADDR
// end ; 5 :
2281: GO 2854
2283: LD_INT 5
2285: DOUBLE
2286: EQUAL
2287: IFTRUE 2291
2289: GO 2853
2291: POP
// begin AddEscort ( ) ;
2292: CALL 2859 0 0
// Wait ( 0 0$02 ) ;
2296: LD_INT 70
2298: PPUSH
2299: CALL_OW 67
// AddEscort ( ) ;
2303: CALL 2859 0 0
// Wait ( 0 0$02 ) ;
2307: LD_INT 70
2309: PPUSH
2310: CALL_OW 67
// for i = 1 to 2 do
2314: LD_ADDR_VAR 0 3
2318: PUSH
2319: DOUBLE
2320: LD_INT 1
2322: DEC
2323: ST_TO_ADDR
2324: LD_INT 2
2326: PUSH
2327: FOR_TO
2328: IFFALSE 2579
// begin vc_chassis := ru_medium_wheeled ;
2330: LD_ADDR_OWVAR 37
2334: PUSH
2335: LD_INT 21
2337: ST_TO_ADDR
// vc_engine := engine_combustion ;
2338: LD_ADDR_OWVAR 39
2342: PUSH
2343: LD_INT 1
2345: ST_TO_ADDR
// vc_control := control_manual ;
2346: LD_ADDR_OWVAR 38
2350: PUSH
2351: LD_INT 1
2353: ST_TO_ADDR
// vc_weapon := ru_cargo_bay ;
2354: LD_ADDR_OWVAR 40
2358: PUSH
2359: LD_INT 51
2361: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2362: LD_ADDR_OWVAR 41
2366: PUSH
2367: LD_INT 50
2369: PPUSH
2370: LD_INT 99
2372: PPUSH
2373: CALL_OW 12
2377: ST_TO_ADDR
// if uc_side <> 6 then
2378: LD_OWVAR 20
2382: PUSH
2383: LD_INT 6
2385: NONEQUAL
2386: IFFALSE 2396
// uc_side := 6 ;
2388: LD_ADDR_OWVAR 20
2392: PUSH
2393: LD_INT 6
2395: ST_TO_ADDR
// veh := CreateVehicle ;
2396: LD_ADDR_VAR 0 4
2400: PUSH
2401: CALL_OW 45
2405: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2406: LD_VAR 0 4
2410: PPUSH
2411: LD_INT 3
2413: PPUSH
2414: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2418: LD_VAR 0 4
2422: PPUSH
2423: LD_INT 8
2425: PPUSH
2426: LD_INT 0
2428: PPUSH
2429: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2433: LD_INT 0
2435: PPUSH
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 2
2441: PPUSH
2442: CALL_OW 12
2446: PPUSH
2447: LD_VAR 0 5
2451: PPUSH
2452: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2456: CALL_OW 44
2460: PPUSH
2461: LD_VAR 0 4
2465: PPUSH
2466: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2470: LD_VAR 0 4
2474: PPUSH
2475: LD_INT 500
2477: PPUSH
2478: LD_INT 1000
2480: PPUSH
2481: CALL_OW 12
2485: PPUSH
2486: CALL_OW 234
// SetCargo ( veh , Rand ( 1 , 2 ) , Rand ( 2 , 10 ) * 10 ) ;
2490: LD_VAR 0 4
2494: PPUSH
2495: LD_INT 1
2497: PPUSH
2498: LD_INT 2
2500: PPUSH
2501: CALL_OW 12
2505: PPUSH
2506: LD_INT 2
2508: PPUSH
2509: LD_INT 10
2511: PPUSH
2512: CALL_OW 12
2516: PUSH
2517: LD_INT 10
2519: MUL
2520: PPUSH
2521: CALL_OW 290
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2525: LD_ADDR_EXP 1
2529: PUSH
2530: LD_EXP 1
2534: PPUSH
2535: LD_INT 1
2537: PPUSH
2538: LD_VAR 0 4
2542: PUSH
2543: LD_INT 1
2545: PUSH
2546: EMPTY
2547: LIST
2548: LIST
2549: PPUSH
2550: CALL_OW 2
2554: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2555: LD_VAR 0 4
2559: PPUSH
2560: LD_INT 120
2562: PPUSH
2563: LD_INT 10
2565: PPUSH
2566: CALL_OW 111
// Wait ( 0 0$02 ) ;
2570: LD_INT 70
2572: PPUSH
2573: CALL_OW 67
// end ;
2577: GO 2327
2579: POP
2580: POP
// if Rand ( 0 , 1 ) = 1 then
2581: LD_INT 0
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: CALL_OW 12
2591: PUSH
2592: LD_INT 1
2594: EQUAL
2595: IFFALSE 2631
// begin vc_chassis := ru_medium_tracked ;
2597: LD_ADDR_OWVAR 37
2601: PUSH
2602: LD_INT 22
2604: ST_TO_ADDR
// vc_engine := engine_combustion ;
2605: LD_ADDR_OWVAR 39
2609: PUSH
2610: LD_INT 1
2612: ST_TO_ADDR
// vc_control := control_manual ;
2613: LD_ADDR_OWVAR 38
2617: PUSH
2618: LD_INT 1
2620: ST_TO_ADDR
// vc_weapon := ru_crane ;
2621: LD_ADDR_OWVAR 40
2625: PUSH
2626: LD_INT 52
2628: ST_TO_ADDR
// end else
2629: GO 2663
// begin vc_chassis := ru_heavy_wheeled ;
2631: LD_ADDR_OWVAR 37
2635: PUSH
2636: LD_INT 23
2638: ST_TO_ADDR
// vc_engine := engine_combustion ;
2639: LD_ADDR_OWVAR 39
2643: PUSH
2644: LD_INT 1
2646: ST_TO_ADDR
// vc_control := control_manual ;
2647: LD_ADDR_OWVAR 38
2651: PUSH
2652: LD_INT 1
2654: ST_TO_ADDR
// vc_weapon := ru_bulldozer ;
2655: LD_ADDR_OWVAR 40
2659: PUSH
2660: LD_INT 53
2662: ST_TO_ADDR
// end ; vc_fuel_battery := Rand ( 50 , 99 ) ;
2663: LD_ADDR_OWVAR 41
2667: PUSH
2668: LD_INT 50
2670: PPUSH
2671: LD_INT 99
2673: PPUSH
2674: CALL_OW 12
2678: ST_TO_ADDR
// if uc_side <> 6 then
2679: LD_OWVAR 20
2683: PUSH
2684: LD_INT 6
2686: NONEQUAL
2687: IFFALSE 2697
// uc_side := 6 ;
2689: LD_ADDR_OWVAR 20
2693: PUSH
2694: LD_INT 6
2696: ST_TO_ADDR
// veh := CreateVehicle ;
2697: LD_ADDR_VAR 0 4
2701: PUSH
2702: CALL_OW 45
2706: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2707: LD_VAR 0 4
2711: PPUSH
2712: LD_INT 3
2714: PPUSH
2715: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2719: LD_VAR 0 4
2723: PPUSH
2724: LD_INT 8
2726: PPUSH
2727: LD_INT 0
2729: PPUSH
2730: CALL_OW 49
// PrepareHuman ( false , Rand ( 1 , 2 ) , skill ) ;
2734: LD_INT 0
2736: PPUSH
2737: LD_INT 1
2739: PPUSH
2740: LD_INT 2
2742: PPUSH
2743: CALL_OW 12
2747: PPUSH
2748: LD_VAR 0 5
2752: PPUSH
2753: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
2757: CALL_OW 44
2761: PPUSH
2762: LD_VAR 0 4
2766: PPUSH
2767: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
2771: LD_VAR 0 4
2775: PPUSH
2776: LD_INT 500
2778: PPUSH
2779: LD_INT 1000
2781: PPUSH
2782: CALL_OW 12
2786: PPUSH
2787: CALL_OW 234
// conv_squad := Insert ( conv_squad , 1 , [ veh , 1 ] ) ;
2791: LD_ADDR_EXP 1
2795: PUSH
2796: LD_EXP 1
2800: PPUSH
2801: LD_INT 1
2803: PPUSH
2804: LD_VAR 0 4
2808: PUSH
2809: LD_INT 1
2811: PUSH
2812: EMPTY
2813: LIST
2814: LIST
2815: PPUSH
2816: CALL_OW 2
2820: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
2821: LD_VAR 0 4
2825: PPUSH
2826: LD_INT 120
2828: PPUSH
2829: LD_INT 10
2831: PPUSH
2832: CALL_OW 111
// Wait ( 0 0$02 ) ;
2836: LD_INT 70
2838: PPUSH
2839: CALL_OW 67
// conv_ready := true ;
2843: LD_ADDR_EXP 18
2847: PUSH
2848: LD_INT 1
2850: ST_TO_ADDR
// end ; end ;
2851: GO 2854
2853: POP
// end ;
2854: LD_VAR 0 2
2858: RET
// export function AddEscort ( ) ; var veh , skill ; begin
2859: LD_INT 0
2861: PPUSH
2862: PPUSH
2863: PPUSH
// skill := [ 5 , 5 , 4 ] [ Difficulty ] ;
2864: LD_ADDR_VAR 0 3
2868: PUSH
2869: LD_INT 5
2871: PUSH
2872: LD_INT 5
2874: PUSH
2875: LD_INT 4
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: LIST
2882: PUSH
2883: LD_OWVAR 67
2887: ARRAY
2888: ST_TO_ADDR
// uc_side := 6 ;
2889: LD_ADDR_OWVAR 20
2893: PUSH
2894: LD_INT 6
2896: ST_TO_ADDR
// uc_nation := 3 ;
2897: LD_ADDR_OWVAR 21
2901: PUSH
2902: LD_INT 3
2904: ST_TO_ADDR
// vc_chassis := ru_medium_wheeled ;
2905: LD_ADDR_OWVAR 37
2909: PUSH
2910: LD_INT 21
2912: ST_TO_ADDR
// vc_engine := engine_combustion ;
2913: LD_ADDR_OWVAR 39
2917: PUSH
2918: LD_INT 1
2920: ST_TO_ADDR
// vc_control := control_manual ;
2921: LD_ADDR_OWVAR 38
2925: PUSH
2926: LD_INT 1
2928: ST_TO_ADDR
// vc_weapon := [ ru_gun , ru_heavy_machine_gun ] [ Rand ( 1 , 2 ) ] ;
2929: LD_ADDR_OWVAR 40
2933: PUSH
2934: LD_INT 44
2936: PUSH
2937: LD_INT 42
2939: PUSH
2940: EMPTY
2941: LIST
2942: LIST
2943: PUSH
2944: LD_INT 1
2946: PPUSH
2947: LD_INT 2
2949: PPUSH
2950: CALL_OW 12
2954: ARRAY
2955: ST_TO_ADDR
// vc_fuel_battery := Rand ( 50 , 99 ) ;
2956: LD_ADDR_OWVAR 41
2960: PUSH
2961: LD_INT 50
2963: PPUSH
2964: LD_INT 99
2966: PPUSH
2967: CALL_OW 12
2971: ST_TO_ADDR
// veh := CreateVehicle ;
2972: LD_ADDR_VAR 0 2
2976: PUSH
2977: CALL_OW 45
2981: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
2982: LD_VAR 0 2
2986: PPUSH
2987: LD_INT 3
2989: PPUSH
2990: CALL_OW 233
// PlaceUnitArea ( veh , conv_start , false ) ;
2994: LD_VAR 0 2
2998: PPUSH
2999: LD_INT 8
3001: PPUSH
3002: LD_INT 0
3004: PPUSH
3005: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
3009: LD_INT 0
3011: PPUSH
3012: LD_INT 3
3014: PPUSH
3015: LD_VAR 0 3
3019: PPUSH
3020: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
3024: CALL_OW 44
3028: PPUSH
3029: LD_VAR 0 2
3033: PPUSH
3034: CALL_OW 52
// SetLives ( veh , Rand ( 500 , 1000 ) ) ;
3038: LD_VAR 0 2
3042: PPUSH
3043: LD_INT 500
3045: PPUSH
3046: LD_INT 1000
3048: PPUSH
3049: CALL_OW 12
3053: PPUSH
3054: CALL_OW 234
// escort := Insert ( escort , 1 , veh ) ;
3058: LD_ADDR_EXP 2
3062: PUSH
3063: LD_EXP 2
3067: PPUSH
3068: LD_INT 1
3070: PPUSH
3071: LD_VAR 0 2
3075: PPUSH
3076: CALL_OW 2
3080: ST_TO_ADDR
// ComMoveXY ( veh , 120 , 10 ) ;
3081: LD_VAR 0 2
3085: PPUSH
3086: LD_INT 120
3088: PPUSH
3089: LD_INT 10
3091: PPUSH
3092: CALL_OW 111
// end ;
3096: LD_VAR 0 1
3100: RET
// every 4 trigger conv_ready and FilterAllUnits ( [ f_side , 6 ] ) do var i , j ;
3101: LD_EXP 18
3105: PUSH
3106: LD_INT 22
3108: PUSH
3109: LD_INT 6
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: PPUSH
3116: CALL_OW 69
3120: AND
3121: IFFALSE 3854
3123: GO 3125
3125: DISABLE
3126: LD_INT 0
3128: PPUSH
3129: PPUSH
// begin enable ;
3130: ENABLE
// if conv_squad then
3131: LD_EXP 1
3135: IFFALSE 3392
// for i = conv_squad downto 1 do
3137: LD_ADDR_VAR 0 1
3141: PUSH
3142: DOUBLE
3143: LD_EXP 1
3147: INC
3148: ST_TO_ADDR
3149: LD_INT 1
3151: PUSH
3152: FOR_DOWNTO
3153: IFFALSE 3390
// begin if IsInArea ( conv_squad [ i ] [ 1 ] , conv_end ) then
3155: LD_EXP 1
3159: PUSH
3160: LD_VAR 0 1
3164: ARRAY
3165: PUSH
3166: LD_INT 1
3168: ARRAY
3169: PPUSH
3170: LD_INT 9
3172: PPUSH
3173: CALL_OW 308
3177: IFFALSE 3240
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3179: LD_ADDR_VAR 0 2
3183: PUSH
3184: LD_INT 9
3186: PPUSH
3187: LD_INT 22
3189: PUSH
3190: LD_INT 6
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: PPUSH
3197: CALL_OW 70
3201: PUSH
3202: FOR_IN
3203: IFFALSE 3216
// RemoveUnit ( j ) ;
3205: LD_VAR 0 2
3209: PPUSH
3210: CALL_OW 64
3214: GO 3202
3216: POP
3217: POP
// conv_squad := Delete ( conv_squad , i ) ;
3218: LD_ADDR_EXP 1
3222: PUSH
3223: LD_EXP 1
3227: PPUSH
3228: LD_VAR 0 1
3232: PPUSH
3233: CALL_OW 3
3237: ST_TO_ADDR
// break ;
3238: GO 3390
// end ; if IsInArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) then
3240: LD_EXP 1
3244: PUSH
3245: LD_VAR 0 1
3249: ARRAY
3250: PUSH
3251: LD_INT 1
3253: ARRAY
3254: PPUSH
3255: LD_EXP 6
3259: PUSH
3260: LD_EXP 1
3264: PUSH
3265: LD_VAR 0 1
3269: ARRAY
3270: PUSH
3271: LD_INT 2
3273: ARRAY
3274: ARRAY
3275: PPUSH
3276: CALL_OW 308
3280: IFFALSE 3326
// conv_squad := Replace2 ( conv_squad , i , 2 , conv_squad [ i ] [ 2 ] + 1 ) else
3282: LD_ADDR_EXP 1
3286: PUSH
3287: LD_EXP 1
3291: PPUSH
3292: LD_VAR 0 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: LD_EXP 1
3304: PUSH
3305: LD_VAR 0 1
3309: ARRAY
3310: PUSH
3311: LD_INT 2
3313: ARRAY
3314: PUSH
3315: LD_INT 1
3317: PLUS
3318: PPUSH
3319: CALL 10050 0 4
3323: ST_TO_ADDR
3324: GO 3388
// if not HasTask ( conv_squad [ i ] [ 1 ] ) then
3326: LD_EXP 1
3330: PUSH
3331: LD_VAR 0 1
3335: ARRAY
3336: PUSH
3337: LD_INT 1
3339: ARRAY
3340: PPUSH
3341: CALL_OW 314
3345: NOT
3346: IFFALSE 3388
// ComMoveToArea ( conv_squad [ i ] [ 1 ] , path [ conv_squad [ i ] [ 2 ] ] ) ;
3348: LD_EXP 1
3352: PUSH
3353: LD_VAR 0 1
3357: ARRAY
3358: PUSH
3359: LD_INT 1
3361: ARRAY
3362: PPUSH
3363: LD_EXP 6
3367: PUSH
3368: LD_EXP 1
3372: PUSH
3373: LD_VAR 0 1
3377: ARRAY
3378: PUSH
3379: LD_INT 2
3381: ARRAY
3382: ARRAY
3383: PPUSH
3384: CALL_OW 113
// end ;
3388: GO 3152
3390: POP
3391: POP
// if escort then
3392: LD_EXP 2
3396: IFFALSE 3721
// for i = escort downto 1 do
3398: LD_ADDR_VAR 0 1
3402: PUSH
3403: DOUBLE
3404: LD_EXP 2
3408: INC
3409: ST_TO_ADDR
3410: LD_INT 1
3412: PUSH
3413: FOR_DOWNTO
3414: IFFALSE 3719
// begin if IsInArea ( escort [ i ] , conv_end ) then
3416: LD_EXP 2
3420: PUSH
3421: LD_VAR 0 1
3425: ARRAY
3426: PPUSH
3427: LD_INT 9
3429: PPUSH
3430: CALL_OW 308
3434: IFFALSE 3497
// begin for j in FilterUnitsInArea ( conv_end , [ f_side , 6 ] ) do
3436: LD_ADDR_VAR 0 2
3440: PUSH
3441: LD_INT 9
3443: PPUSH
3444: LD_INT 22
3446: PUSH
3447: LD_INT 6
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: PPUSH
3454: CALL_OW 70
3458: PUSH
3459: FOR_IN
3460: IFFALSE 3473
// RemoveUnit ( j ) ;
3462: LD_VAR 0 2
3466: PPUSH
3467: CALL_OW 64
3471: GO 3459
3473: POP
3474: POP
// escort := Delete ( escort , i ) ;
3475: LD_ADDR_EXP 2
3479: PUSH
3480: LD_EXP 2
3484: PPUSH
3485: LD_VAR 0 1
3489: PPUSH
3490: CALL_OW 3
3494: ST_TO_ADDR
// break ;
3495: GO 3719
// end ; if FindTarget ( escort [ i ] ) and GetDistUnits ( escort [ i ] , FindTarget ( escort [ i ] ) ) < 13 then
3497: LD_EXP 2
3501: PUSH
3502: LD_VAR 0 1
3506: ARRAY
3507: PPUSH
3508: CALL 10358 0 1
3512: PUSH
3513: LD_EXP 2
3517: PUSH
3518: LD_VAR 0 1
3522: ARRAY
3523: PPUSH
3524: LD_EXP 2
3528: PUSH
3529: LD_VAR 0 1
3533: ARRAY
3534: PPUSH
3535: CALL 10358 0 1
3539: PPUSH
3540: CALL_OW 296
3544: PUSH
3545: LD_INT 13
3547: LESS
3548: AND
3549: IFFALSE 3584
// ComAttackUnit ( escort [ i ] , FindTarget ( escort [ i ] ) ) else
3551: LD_EXP 2
3555: PUSH
3556: LD_VAR 0 1
3560: ARRAY
3561: PPUSH
3562: LD_EXP 2
3566: PUSH
3567: LD_VAR 0 1
3571: ARRAY
3572: PPUSH
3573: CALL 10358 0 1
3577: PPUSH
3578: CALL_OW 115
3582: GO 3717
// if conv_squad and GetDistUnitXY ( escort [ i ] , 64 , 117 ) > 35 and not HasTask ( escort [ i ] ) then
3584: LD_EXP 1
3588: PUSH
3589: LD_EXP 2
3593: PUSH
3594: LD_VAR 0 1
3598: ARRAY
3599: PPUSH
3600: LD_INT 64
3602: PPUSH
3603: LD_INT 117
3605: PPUSH
3606: CALL_OW 297
3610: PUSH
3611: LD_INT 35
3613: GREATER
3614: AND
3615: PUSH
3616: LD_EXP 2
3620: PUSH
3621: LD_VAR 0 1
3625: ARRAY
3626: PPUSH
3627: CALL_OW 314
3631: NOT
3632: AND
3633: IFFALSE 3699
// begin if GetDistUnits ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) > 6 then
3635: LD_EXP 2
3639: PUSH
3640: LD_VAR 0 1
3644: ARRAY
3645: PPUSH
3646: LD_EXP 1
3650: PUSH
3651: LD_INT 1
3653: ARRAY
3654: PUSH
3655: LD_INT 1
3657: ARRAY
3658: PPUSH
3659: CALL_OW 296
3663: PUSH
3664: LD_INT 6
3666: GREATER
3667: IFFALSE 3697
// ComMoveUnit ( escort [ i ] , conv_squad [ 1 ] [ 1 ] ) end else
3669: LD_EXP 2
3673: PUSH
3674: LD_VAR 0 1
3678: ARRAY
3679: PPUSH
3680: LD_EXP 1
3684: PUSH
3685: LD_INT 1
3687: ARRAY
3688: PUSH
3689: LD_INT 1
3691: ARRAY
3692: PPUSH
3693: CALL_OW 112
3697: GO 3717
// ComMoveToArea ( escort [ i ] , conv_end ) ;
3699: LD_EXP 2
3703: PUSH
3704: LD_VAR 0 1
3708: ARRAY
3709: PPUSH
3710: LD_INT 9
3712: PPUSH
3713: CALL_OW 113
// end ;
3717: GO 3413
3719: POP
3720: POP
// if FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) then
3721: LD_INT 22
3723: PUSH
3724: LD_INT 6
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PUSH
3731: LD_INT 21
3733: PUSH
3734: LD_INT 1
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: PPUSH
3745: CALL_OW 69
3749: IFFALSE 3854
// for j in FilterAllUnits ( [ [ f_side , 6 ] , [ f_type , unit_human ] ] ) do
3751: LD_ADDR_VAR 0 2
3755: PUSH
3756: LD_INT 22
3758: PUSH
3759: LD_INT 6
3761: PUSH
3762: EMPTY
3763: LIST
3764: LIST
3765: PUSH
3766: LD_INT 21
3768: PUSH
3769: LD_INT 1
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: PUSH
3776: EMPTY
3777: LIST
3778: LIST
3779: PPUSH
3780: CALL_OW 69
3784: PUSH
3785: FOR_IN
3786: IFFALSE 3852
// begin if not HasTask ( j ) and not IsInArea ( j , conv_end ) then
3788: LD_VAR 0 2
3792: PPUSH
3793: CALL_OW 314
3797: NOT
3798: PUSH
3799: LD_VAR 0 2
3803: PPUSH
3804: LD_INT 9
3806: PPUSH
3807: CALL_OW 308
3811: NOT
3812: AND
3813: IFFALSE 3827
// ComMoveToArea ( j , conv_end ) ;
3815: LD_VAR 0 2
3819: PPUSH
3820: LD_INT 9
3822: PPUSH
3823: CALL_OW 113
// if IsInArea ( j , conv_end ) then
3827: LD_VAR 0 2
3831: PPUSH
3832: LD_INT 9
3834: PPUSH
3835: CALL_OW 308
3839: IFFALSE 3850
// RemoveUnit ( j ) ;
3841: LD_VAR 0 2
3845: PPUSH
3846: CALL_OW 64
// end ;
3850: GO 3785
3852: POP
3853: POP
// end ;
3854: PPOPN 2
3856: END
// every 0 0$01 trigger UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do var i ;
3857: LD_EXP 2
3861: PUSH
3862: LD_EXP 1
3866: PUSH
3867: EMPTY
3868: LIST
3869: LIST
3870: PPUSH
3871: LD_INT 22
3873: PUSH
3874: LD_INT 3
3876: PUSH
3877: EMPTY
3878: LIST
3879: LIST
3880: PPUSH
3881: CALL_OW 72
3885: IFFALSE 3947
3887: GO 3889
3889: DISABLE
3890: LD_INT 0
3892: PPUSH
// begin enable ;
3893: ENABLE
// for i in UnitFilter ( [ escort , conv_squad ] , [ f_side , 3 ] ) do
3894: LD_ADDR_VAR 0 1
3898: PUSH
3899: LD_EXP 2
3903: PUSH
3904: LD_EXP 1
3908: PUSH
3909: EMPTY
3910: LIST
3911: LIST
3912: PPUSH
3913: LD_INT 22
3915: PUSH
3916: LD_INT 3
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: PPUSH
3923: CALL_OW 72
3927: PUSH
3928: FOR_IN
3929: IFFALSE 3945
// SetSide ( i , 6 ) ;
3931: LD_VAR 0 1
3935: PPUSH
3936: LD_INT 6
3938: PPUSH
3939: CALL_OW 235
3943: GO 3928
3945: POP
3946: POP
// end ; end_of_file
3947: PPOPN 1
3949: END
// export Collins ; export us_alert , us_retreat , us_patrol , us_count ; export function PrepareAmerican ; var i , un , skill , towers ; begin
3950: LD_INT 0
3952: PPUSH
3953: PPUSH
3954: PPUSH
3955: PPUSH
3956: PPUSH
// uc_side := 1 ;
3957: LD_ADDR_OWVAR 20
3961: PUSH
3962: LD_INT 1
3964: ST_TO_ADDR
// uc_nation := 1 ;
3965: LD_ADDR_OWVAR 21
3969: PUSH
3970: LD_INT 1
3972: ST_TO_ADDR
// us_alert := false ;
3973: LD_ADDR_EXP 20
3977: PUSH
3978: LD_INT 0
3980: ST_TO_ADDR
// us_retreat := false ;
3981: LD_ADDR_EXP 21
3985: PUSH
3986: LD_INT 0
3988: ST_TO_ADDR
// us_patrol := false ;
3989: LD_ADDR_EXP 22
3993: PUSH
3994: LD_INT 0
3996: ST_TO_ADDR
// us_count := 0 ;
3997: LD_ADDR_EXP 23
4001: PUSH
4002: LD_INT 0
4004: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
4005: LD_ADDR_VAR 0 4
4009: PUSH
4010: LD_INT 5
4012: PUSH
4013: LD_INT 6
4015: PUSH
4016: LD_INT 7
4018: PUSH
4019: EMPTY
4020: LIST
4021: LIST
4022: LIST
4023: PUSH
4024: LD_OWVAR 67
4028: ARRAY
4029: ST_TO_ADDR
// hc_class := 1 ;
4030: LD_ADDR_OWVAR 28
4034: PUSH
4035: LD_INT 1
4037: ST_TO_ADDR
// hc_sex := sex_male ;
4038: LD_ADDR_OWVAR 27
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// hc_skills := [ 6 , 3 , 4 , 2 ] ;
4046: LD_ADDR_OWVAR 31
4050: PUSH
4051: LD_INT 6
4053: PUSH
4054: LD_INT 3
4056: PUSH
4057: LD_INT 4
4059: PUSH
4060: LD_INT 2
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: LIST
4067: LIST
4068: ST_TO_ADDR
// hc_name := Jack Collins ;
4069: LD_ADDR_OWVAR 26
4073: PUSH
4074: LD_STRING Jack Collins
4076: ST_TO_ADDR
// hc_attr := [ 11 , 11 ] ;
4077: LD_ADDR_OWVAR 29
4081: PUSH
4082: LD_INT 11
4084: PUSH
4085: LD_INT 11
4087: PUSH
4088: EMPTY
4089: LIST
4090: LIST
4091: ST_TO_ADDR
// hc_gallery :=  ;
4092: LD_ADDR_OWVAR 33
4096: PUSH
4097: LD_STRING 
4099: ST_TO_ADDR
// Collins := CreateHuman ;
4100: LD_ADDR_EXP 19
4104: PUSH
4105: CALL_OW 44
4109: ST_TO_ADDR
// PlaceHumanInUnit ( Collins , us_depot ) ;
4110: LD_EXP 19
4114: PPUSH
4115: LD_INT 50
4117: PPUSH
4118: CALL_OW 52
// hc_name :=  ;
4122: LD_ADDR_OWVAR 26
4126: PUSH
4127: LD_STRING 
4129: ST_TO_ADDR
// if Difficulty > 1 then
4130: LD_OWVAR 67
4134: PUSH
4135: LD_INT 1
4137: GREATER
4138: IFFALSE 4192
// begin bc_type := b_bunker ;
4140: LD_ADDR_OWVAR 42
4144: PUSH
4145: LD_INT 32
4147: ST_TO_ADDR
// bc_level := 5 ;
4148: LD_ADDR_OWVAR 43
4152: PUSH
4153: LD_INT 5
4155: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( 40 , 33 , 2 ) ;
4156: LD_INT 40
4158: PPUSH
4159: LD_INT 33
4161: PPUSH
4162: LD_INT 2
4164: PPUSH
4165: CALL_OW 47
// if Difficulty > 2 then
4169: LD_OWVAR 67
4173: PUSH
4174: LD_INT 2
4176: GREATER
4177: IFFALSE 4192
// CreateAndPlaceBuildingXYD ( 41 , 42 , 0 ) ;
4179: LD_INT 41
4181: PPUSH
4182: LD_INT 42
4184: PPUSH
4185: LD_INT 0
4187: PPUSH
4188: CALL_OW 47
// end ; PrepareHuman ( false , 2 , skill ) ;
4192: LD_INT 0
4194: PPUSH
4195: LD_INT 2
4197: PPUSH
4198: LD_VAR 0 4
4202: PPUSH
4203: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_depot ) ;
4207: CALL_OW 44
4211: PPUSH
4212: LD_INT 50
4214: PPUSH
4215: CALL_OW 52
// PrepareHuman ( false , 3 , skill ) ;
4219: LD_INT 0
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: LD_VAR 0 4
4229: PPUSH
4230: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4234: CALL_OW 44
4238: PPUSH
4239: LD_INT 56
4241: PPUSH
4242: CALL_OW 52
// PlaceHumanInUnit ( CreateHuman , us_fac ) ;
4246: CALL_OW 44
4250: PPUSH
4251: LD_INT 56
4253: PPUSH
4254: CALL_OW 52
// PrepareHuman ( false , 4 , skill ) ;
4258: LD_INT 0
4260: PPUSH
4261: LD_INT 4
4263: PPUSH
4264: LD_VAR 0 4
4268: PPUSH
4269: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , us_lab ) ;
4273: CALL_OW 44
4277: PPUSH
4278: LD_INT 63
4280: PPUSH
4281: CALL_OW 52
// PrepareHuman ( false , 1 , skill ) ;
4285: LD_INT 0
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_VAR 0 4
4295: PPUSH
4296: CALL_OW 380
// un := CreateHuman ;
4300: LD_ADDR_VAR 0 3
4304: PUSH
4305: CALL_OW 44
4309: ST_TO_ADDR
// SetDir ( un , 4 ) ;
4310: LD_VAR 0 3
4314: PPUSH
4315: LD_INT 4
4317: PPUSH
4318: CALL_OW 233
// PlaceHumanInUnit ( un , FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_breastwork ] ] ) [ 1 ] ) ;
4322: LD_VAR 0 3
4326: PPUSH
4327: LD_INT 22
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: EMPTY
4334: LIST
4335: LIST
4336: PUSH
4337: LD_INT 30
4339: PUSH
4340: LD_INT 31
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: PUSH
4347: EMPTY
4348: LIST
4349: LIST
4350: PPUSH
4351: CALL_OW 69
4355: PUSH
4356: LD_INT 1
4358: ARRAY
4359: PPUSH
4360: CALL_OW 52
// towers := FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_bunker ] ] ) ;
4364: LD_ADDR_VAR 0 5
4368: PUSH
4369: LD_INT 22
4371: PUSH
4372: LD_INT 1
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 30
4381: PUSH
4382: LD_INT 32
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: PPUSH
4393: CALL_OW 69
4397: ST_TO_ADDR
// for i in towers do
4398: LD_ADDR_VAR 0 2
4402: PUSH
4403: LD_VAR 0 5
4407: PUSH
4408: FOR_IN
4409: IFFALSE 4477
// begin PrepareHuman ( false , 1 , skill ) ;
4411: LD_INT 0
4413: PPUSH
4414: LD_INT 1
4416: PPUSH
4417: LD_VAR 0 4
4421: PPUSH
4422: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
4426: CALL_OW 44
4430: PPUSH
4431: LD_VAR 0 2
4435: PPUSH
4436: CALL_OW 52
// PlaceWeaponTurret ( i , [ us_gatling_gun , us_light_gun , us_double_gun ] [ Rand ( 1 , 3 ) ] ) ;
4440: LD_VAR 0 2
4444: PPUSH
4445: LD_INT 4
4447: PUSH
4448: LD_INT 3
4450: PUSH
4451: LD_INT 5
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: PUSH
4459: LD_INT 1
4461: PPUSH
4462: LD_INT 3
4464: PPUSH
4465: CALL_OW 12
4469: ARRAY
4470: PPUSH
4471: CALL_OW 431
// end ;
4475: GO 4408
4477: POP
4478: POP
// PrepareHuman ( false , 1 , skill ) ;
4479: LD_INT 0
4481: PPUSH
4482: LD_INT 1
4484: PPUSH
4485: LD_VAR 0 4
4489: PPUSH
4490: CALL_OW 380
// us_patrol := CreateHuman ;
4494: LD_ADDR_EXP 22
4498: PUSH
4499: CALL_OW 44
4503: ST_TO_ADDR
// PlaceUnitXY ( us_patrol , 12 , 5 , false ) ;
4504: LD_EXP 22
4508: PPUSH
4509: LD_INT 12
4511: PPUSH
4512: LD_INT 5
4514: PPUSH
4515: LD_INT 0
4517: PPUSH
4518: CALL_OW 48
// end ;
4522: LD_VAR 0 1
4526: RET
// every 0 0$01 trigger us_count >= [ 3 , 4 , 5 ] [ Difficulty ] do
4527: LD_EXP 23
4531: PUSH
4532: LD_INT 3
4534: PUSH
4535: LD_INT 4
4537: PUSH
4538: LD_INT 5
4540: PUSH
4541: EMPTY
4542: LIST
4543: LIST
4544: LIST
4545: PUSH
4546: LD_OWVAR 67
4550: ARRAY
4551: GREATEREQUAL
4552: IFFALSE 4577
4554: GO 4556
4556: DISABLE
// begin Say ( Collins , DPM_C2 ) ;
4557: LD_EXP 19
4561: PPUSH
4562: LD_STRING DPM_C2
4564: PPUSH
4565: CALL_OW 88
// us_retreat := true ;
4569: LD_ADDR_EXP 21
4573: PUSH
4574: LD_INT 1
4576: ST_TO_ADDR
// end ;
4577: END
// every 10 10$00 trigger not us_alert do var R ;
4578: LD_EXP 20
4582: NOT
4583: IFFALSE 4657
4585: GO 4587
4587: DISABLE
4588: LD_INT 0
4590: PPUSH
// begin uc_side := 1 ;
4591: LD_ADDR_OWVAR 20
4595: PUSH
4596: LD_INT 1
4598: ST_TO_ADDR
// uc_nation := 1 ;
4599: LD_ADDR_OWVAR 21
4603: PUSH
4604: LD_INT 1
4606: ST_TO_ADDR
// PrepareHuman ( false , 1 , 0 ) ;
4607: LD_INT 0
4609: PPUSH
4610: LD_INT 1
4612: PPUSH
4613: LD_INT 0
4615: PPUSH
4616: CALL_OW 380
// R := CreateHuman ;
4620: LD_ADDR_VAR 0 1
4624: PUSH
4625: CALL_OW 44
4629: ST_TO_ADDR
// SayRadio ( R , DPM_R1 ) ;
4630: LD_VAR 0 1
4634: PPUSH
4635: LD_STRING DPM_R1
4637: PPUSH
4638: CALL_OW 94
// Wait ( 0 0$03 ) ;
4642: LD_INT 105
4644: PPUSH
4645: CALL_OW 67
// us_retreat := true ;
4649: LD_ADDR_EXP 21
4653: PUSH
4654: LD_INT 1
4656: ST_TO_ADDR
// end ;
4657: PPOPN 1
4659: END
// every 0 0$01 trigger us_alert do var i ;
4660: LD_EXP 20
4664: IFFALSE 4924
4666: GO 4668
4668: DISABLE
4669: LD_INT 0
4671: PPUSH
// begin Say ( Collins , DPM_C1 ) ;
4672: LD_EXP 19
4676: PPUSH
4677: LD_STRING DPM_C1
4679: PPUSH
4680: CALL_OW 88
// if UnitsInside ( us_fac ) then
4684: LD_INT 56
4686: PPUSH
4687: CALL_OW 313
4691: IFFALSE 4746
// for i in UnitsInside ( us_fac ) do
4693: LD_ADDR_VAR 0 1
4697: PUSH
4698: LD_INT 56
4700: PPUSH
4701: CALL_OW 313
4705: PUSH
4706: FOR_IN
4707: IFFALSE 4744
// begin ComExitBuilding ( i ) ;
4709: LD_VAR 0 1
4713: PPUSH
4714: CALL_OW 122
// AddComEnterUnit ( i , us_arm ) ;
4718: LD_VAR 0 1
4722: PPUSH
4723: LD_INT 69
4725: PPUSH
4726: CALL_OW 180
// AddComChangeProfession ( i , 1 ) ;
4730: LD_VAR 0 1
4734: PPUSH
4735: LD_INT 1
4737: PPUSH
4738: CALL_OW 183
// end ;
4742: GO 4706
4744: POP
4745: POP
// ComExitBuilding ( Collins ) ;
4746: LD_EXP 19
4750: PPUSH
4751: CALL_OW 122
// AddComEnterUnit ( Collins , us_arm ) ;
4755: LD_EXP 19
4759: PPUSH
4760: LD_INT 69
4762: PPUSH
4763: CALL_OW 180
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] ) ;
4767: LD_INT 22
4769: PUSH
4770: LD_INT 1
4772: PUSH
4773: EMPTY
4774: LIST
4775: LIST
4776: PUSH
4777: LD_INT 25
4779: PUSH
4780: LD_INT 2
4782: PUSH
4783: EMPTY
4784: LIST
4785: LIST
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: PPUSH
4791: CALL_OW 69
4795: PUSH
4796: LD_INT 1
4798: ARRAY
4799: PPUSH
4800: CALL_OW 122
// AddComMoveXY ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 2 ] ] ) [ 1 ] , 67 , 52 ) ;
4804: LD_INT 22
4806: PUSH
4807: LD_INT 1
4809: PUSH
4810: EMPTY
4811: LIST
4812: LIST
4813: PUSH
4814: LD_INT 25
4816: PUSH
4817: LD_INT 2
4819: PUSH
4820: EMPTY
4821: LIST
4822: LIST
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PPUSH
4828: CALL_OW 69
4832: PUSH
4833: LD_INT 1
4835: ARRAY
4836: PPUSH
4837: LD_INT 67
4839: PPUSH
4840: LD_INT 52
4842: PPUSH
4843: CALL_OW 171
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] ) ;
4847: LD_INT 22
4849: PUSH
4850: LD_INT 1
4852: PUSH
4853: EMPTY
4854: LIST
4855: LIST
4856: PUSH
4857: LD_INT 25
4859: PUSH
4860: LD_INT 4
4862: PUSH
4863: EMPTY
4864: LIST
4865: LIST
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: PPUSH
4871: CALL_OW 69
4875: PUSH
4876: LD_INT 1
4878: ARRAY
4879: PPUSH
4880: CALL_OW 122
// AddComEnterUnit ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 4 ] ] ) [ 1 ] , us_arm ) ;
4884: LD_INT 22
4886: PUSH
4887: LD_INT 1
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 25
4896: PUSH
4897: LD_INT 4
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PPUSH
4908: CALL_OW 69
4912: PUSH
4913: LD_INT 1
4915: ARRAY
4916: PPUSH
4917: LD_INT 69
4919: PPUSH
4920: CALL_OW 180
// end ;
4924: PPOPN 1
4926: END
// every 3 3$00 trigger not us_alert and GetSide ( us_fac ) = 1 do
4927: LD_EXP 20
4931: NOT
4932: PUSH
4933: LD_INT 56
4935: PPUSH
4936: CALL_OW 255
4940: PUSH
4941: LD_INT 1
4943: EQUAL
4944: AND
4945: IFFALSE 4988
4947: GO 4949
4949: DISABLE
// begin AddComConstruct ( us_fac , us_medium_wheeled , engine_combustion , control_manual , us_gatling_gun ) ;
4950: LD_INT 56
4952: PPUSH
4953: LD_INT 2
4955: PPUSH
4956: LD_INT 1
4958: PPUSH
4959: LD_INT 1
4961: PPUSH
4962: LD_INT 4
4964: PPUSH
4965: CALL_OW 185
// AddComConstruct ( us_fac , us_medium_tracked , engine_solar , control_manual , us_double_gun ) ;
4969: LD_INT 56
4971: PPUSH
4972: LD_INT 3
4974: PPUSH
4975: LD_INT 2
4977: PPUSH
4978: LD_INT 1
4980: PPUSH
4981: LD_INT 5
4983: PPUSH
4984: CALL_OW 185
// end ;
4988: END
// every 0 0$01 trigger us_patrol do
4989: LD_EXP 22
4993: IFFALSE 5041
4995: GO 4997
4997: DISABLE
// SetPatrol ( us_patrol , [ 12 , 5 , 56 , 4 , 94 , 34 , 92 , 108 ] ) ;
4998: LD_EXP 22
5002: PPUSH
5003: LD_INT 12
5005: PUSH
5006: LD_INT 5
5008: PUSH
5009: LD_INT 56
5011: PUSH
5012: LD_INT 4
5014: PUSH
5015: LD_INT 94
5017: PUSH
5018: LD_INT 34
5020: PUSH
5021: LD_INT 92
5023: PUSH
5024: LD_INT 108
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: LIST
5036: PPUSH
5037: CALL 5042 0 2
5041: END
// export function SetPatrol ( un , points ) ; var s , i , turn ; begin
5042: LD_INT 0
5044: PPUSH
5045: PPUSH
5046: PPUSH
5047: PPUSH
// s = 1 ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_INT 1
5055: ST_TO_ADDR
// turn := true ;
5056: LD_ADDR_VAR 0 6
5060: PUSH
5061: LD_INT 1
5063: ST_TO_ADDR
// while ( un and not us_alert ) do
5064: LD_VAR 0 1
5068: PUSH
5069: LD_EXP 20
5073: NOT
5074: AND
5075: IFFALSE 5254
// begin wait ( 35 ) ;
5077: LD_INT 35
5079: PPUSH
5080: CALL_OW 67
// if not HasTask ( un ) then
5084: LD_VAR 0 1
5088: PPUSH
5089: CALL_OW 314
5093: NOT
5094: IFFALSE 5213
// begin ComMoveXY ( un , points [ s ] , points [ s + 1 ] ) ;
5096: LD_VAR 0 1
5100: PPUSH
5101: LD_VAR 0 2
5105: PUSH
5106: LD_VAR 0 4
5110: ARRAY
5111: PPUSH
5112: LD_VAR 0 2
5116: PUSH
5117: LD_VAR 0 4
5121: PUSH
5122: LD_INT 1
5124: PLUS
5125: ARRAY
5126: PPUSH
5127: CALL_OW 111
// if s + 2 > points then
5131: LD_VAR 0 4
5135: PUSH
5136: LD_INT 2
5138: PLUS
5139: PUSH
5140: LD_VAR 0 2
5144: GREATER
5145: IFFALSE 5155
// turn := false ;
5147: LD_ADDR_VAR 0 6
5151: PUSH
5152: LD_INT 0
5154: ST_TO_ADDR
// if s - 2 < 1 then
5155: LD_VAR 0 4
5159: PUSH
5160: LD_INT 2
5162: MINUS
5163: PUSH
5164: LD_INT 1
5166: LESS
5167: IFFALSE 5177
// turn := true ;
5169: LD_ADDR_VAR 0 6
5173: PUSH
5174: LD_INT 1
5176: ST_TO_ADDR
// if turn then
5177: LD_VAR 0 6
5181: IFFALSE 5199
// s := s + 2 else
5183: LD_ADDR_VAR 0 4
5187: PUSH
5188: LD_VAR 0 4
5192: PUSH
5193: LD_INT 2
5195: PLUS
5196: ST_TO_ADDR
5197: GO 5213
// s := s - 2 ;
5199: LD_ADDR_VAR 0 4
5203: PUSH
5204: LD_VAR 0 4
5208: PUSH
5209: LD_INT 2
5211: MINUS
5212: ST_TO_ADDR
// end ; if GetLives ( un ) < 1000 or See ( 3 , un ) then
5213: LD_VAR 0 1
5217: PPUSH
5218: CALL_OW 256
5222: PUSH
5223: LD_INT 1000
5225: LESS
5226: PUSH
5227: LD_INT 3
5229: PPUSH
5230: LD_VAR 0 1
5234: PPUSH
5235: CALL_OW 292
5239: OR
5240: IFFALSE 5252
// begin us_alert := true ;
5242: LD_ADDR_EXP 20
5246: PUSH
5247: LD_INT 1
5249: ST_TO_ADDR
// break ;
5250: GO 5254
// end ; end ;
5252: GO 5064
// ComEnterUnit ( un , us_arm ) ;
5254: LD_VAR 0 1
5258: PPUSH
5259: LD_INT 69
5261: PPUSH
5262: CALL_OW 120
// end ;
5266: LD_VAR 0 3
5270: RET
// every 0 0$01 trigger us_retreat do var i , point ;
5271: LD_EXP 21
5275: IFFALSE 5450
5277: GO 5279
5279: DISABLE
5280: LD_INT 0
5282: PPUSH
5283: PPUSH
// begin point := false ;
5284: LD_ADDR_VAR 0 2
5288: PUSH
5289: LD_INT 0
5291: ST_TO_ADDR
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5292: LD_INT 5
5294: PPUSH
5295: LD_INT 22
5297: PUSH
5298: LD_INT 3
5300: PUSH
5301: EMPTY
5302: LIST
5303: LIST
5304: PPUSH
5305: CALL_OW 70
5309: PUSH
5310: LD_INT 0
5312: EQUAL
5313: IFFALSE 5325
// point := us_ret1 else
5315: LD_ADDR_VAR 0 2
5319: PUSH
5320: LD_INT 3
5322: ST_TO_ADDR
5323: GO 5366
// if FilterUnitsInArea ( zone1 , [ f_side , 3 ] ) = 0 then
5325: LD_INT 5
5327: PPUSH
5328: LD_INT 22
5330: PUSH
5331: LD_INT 3
5333: PUSH
5334: EMPTY
5335: LIST
5336: LIST
5337: PPUSH
5338: CALL_OW 70
5342: PUSH
5343: LD_INT 0
5345: EQUAL
5346: IFFALSE 5358
// point := us_ret2 else
5348: LD_ADDR_VAR 0 2
5352: PUSH
5353: LD_INT 2
5355: ST_TO_ADDR
5356: GO 5366
// point := us_ret3 ;
5358: LD_ADDR_VAR 0 2
5362: PUSH
5363: LD_INT 4
5365: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) do
5366: LD_ADDR_VAR 0 1
5370: PUSH
5371: LD_INT 22
5373: PUSH
5374: LD_INT 1
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: PUSH
5381: LD_INT 21
5383: PUSH
5384: LD_INT 1
5386: PUSH
5387: EMPTY
5388: LIST
5389: LIST
5390: PUSH
5391: EMPTY
5392: LIST
5393: LIST
5394: PPUSH
5395: CALL_OW 69
5399: PUSH
5400: FOR_IN
5401: IFFALSE 5448
// begin if IsInUnit ( i ) then
5403: LD_VAR 0 1
5407: PPUSH
5408: CALL_OW 310
5412: IFFALSE 5432
// begin ComExitBuilding ( i ) ;
5414: LD_VAR 0 1
5418: PPUSH
5419: CALL_OW 122
// ComExitVehicle ( i ) ;
5423: LD_VAR 0 1
5427: PPUSH
5428: CALL_OW 121
// end ; AddComMoveToArea ( i , point ) ;
5432: LD_VAR 0 1
5436: PPUSH
5437: LD_VAR 0 2
5441: PPUSH
5442: CALL_OW 173
// end ;
5446: GO 5400
5448: POP
5449: POP
// end ;
5450: PPOPN 2
5452: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) do
5453: LD_EXP 21
5457: PUSH
5458: LD_INT 3
5460: PPUSH
5461: LD_INT 22
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: EMPTY
5468: LIST
5469: LIST
5470: PPUSH
5471: CALL_OW 70
5475: AND
5476: IFFALSE 5522
5478: GO 5480
5480: DISABLE
// begin enable ;
5481: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret1 , [ f_side , 1 ] ) [ 1 ] ) ;
5482: LD_INT 3
5484: PPUSH
5485: LD_INT 22
5487: PUSH
5488: LD_INT 1
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: PPUSH
5495: CALL_OW 70
5499: PUSH
5500: LD_INT 1
5502: ARRAY
5503: PPUSH
5504: CALL_OW 64
// if medal1 then
5508: LD_EXP 3
5512: IFFALSE 5522
// medal1 := false ;
5514: LD_ADDR_EXP 3
5518: PUSH
5519: LD_INT 0
5521: ST_TO_ADDR
// end ;
5522: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) do
5523: LD_EXP 21
5527: PUSH
5528: LD_INT 2
5530: PPUSH
5531: LD_INT 22
5533: PUSH
5534: LD_INT 1
5536: PUSH
5537: EMPTY
5538: LIST
5539: LIST
5540: PPUSH
5541: CALL_OW 70
5545: AND
5546: IFFALSE 5592
5548: GO 5550
5550: DISABLE
// begin enable ;
5551: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret2 , [ f_side , 1 ] ) [ 1 ] ) ;
5552: LD_INT 2
5554: PPUSH
5555: LD_INT 22
5557: PUSH
5558: LD_INT 1
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: PPUSH
5565: CALL_OW 70
5569: PUSH
5570: LD_INT 1
5572: ARRAY
5573: PPUSH
5574: CALL_OW 64
// if medal1 then
5578: LD_EXP 3
5582: IFFALSE 5592
// medal1 := false ;
5584: LD_ADDR_EXP 3
5588: PUSH
5589: LD_INT 0
5591: ST_TO_ADDR
// end ;
5592: END
// every 10 trigger us_retreat and FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) do
5593: LD_EXP 21
5597: PUSH
5598: LD_INT 4
5600: PPUSH
5601: LD_INT 22
5603: PUSH
5604: LD_INT 1
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 70
5615: AND
5616: IFFALSE 5662
5618: GO 5620
5620: DISABLE
// begin enable ;
5621: ENABLE
// RemoveUnit ( FilterUnitsInArea ( us_ret3 , [ f_side , 1 ] ) [ 1 ] ) ;
5622: LD_INT 4
5624: PPUSH
5625: LD_INT 22
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: PPUSH
5635: CALL_OW 70
5639: PUSH
5640: LD_INT 1
5642: ARRAY
5643: PPUSH
5644: CALL_OW 64
// if medal1 then
5648: LD_EXP 3
5652: IFFALSE 5662
// medal1 := false ;
5654: LD_ADDR_EXP 3
5658: PUSH
5659: LD_INT 0
5661: ST_TO_ADDR
// end ;
5662: END
// every 0 0$03 trigger FilterAllUnits ( [ f_side , 1 ] ) = 0 do
5663: LD_INT 22
5665: PUSH
5666: LD_INT 1
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: PPUSH
5673: CALL_OW 69
5677: PUSH
5678: LD_INT 0
5680: EQUAL
5681: IFFALSE 5694
5683: GO 5685
5685: DISABLE
// us_retreat := false ;
5686: LD_ADDR_EXP 21
5690: PUSH
5691: LD_INT 0
5693: ST_TO_ADDR
5694: END
// export function CounterAttack ; var i , j , un , skill ; begin
5695: LD_INT 0
5697: PPUSH
5698: PPUSH
5699: PPUSH
5700: PPUSH
5701: PPUSH
// uc_side := 1 ;
5702: LD_ADDR_OWVAR 20
5706: PUSH
5707: LD_INT 1
5709: ST_TO_ADDR
// uc_nation := 1 ;
5710: LD_ADDR_OWVAR 21
5714: PUSH
5715: LD_INT 1
5717: ST_TO_ADDR
// skill := [ 4 , 5 , 5 ] [ Difficulty ] ;
5718: LD_ADDR_VAR 0 5
5722: PUSH
5723: LD_INT 4
5725: PUSH
5726: LD_INT 5
5728: PUSH
5729: LD_INT 5
5731: PUSH
5732: EMPTY
5733: LIST
5734: LIST
5735: LIST
5736: PUSH
5737: LD_OWVAR 67
5741: ARRAY
5742: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5743: LD_ADDR_VAR 0 2
5747: PUSH
5748: DOUBLE
5749: LD_INT 1
5751: DEC
5752: ST_TO_ADDR
5753: LD_INT 4
5755: PUSH
5756: LD_INT 5
5758: PUSH
5759: LD_INT 6
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: LIST
5766: PUSH
5767: LD_OWVAR 67
5771: ARRAY
5772: PUSH
5773: FOR_TO
5774: IFFALSE 5974
// begin vc_chassis := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked ] [ Rand ( 1 , 3 ) ] ;
5776: LD_ADDR_OWVAR 37
5780: PUSH
5781: LD_INT 2
5783: PUSH
5784: LD_INT 3
5786: PUSH
5787: LD_INT 4
5789: PUSH
5790: EMPTY
5791: LIST
5792: LIST
5793: LIST
5794: PUSH
5795: LD_INT 1
5797: PPUSH
5798: LD_INT 3
5800: PPUSH
5801: CALL_OW 12
5805: ARRAY
5806: ST_TO_ADDR
// vc_engine := engine_combustion ;
5807: LD_ADDR_OWVAR 39
5811: PUSH
5812: LD_INT 1
5814: ST_TO_ADDR
// vc_control := control_manual ;
5815: LD_ADDR_OWVAR 38
5819: PUSH
5820: LD_INT 1
5822: ST_TO_ADDR
// vc_weapon := [ us_gatling_gun , us_double_gun , us_light_gun ] [ Rand ( 1 , 3 ) ] ;
5823: LD_ADDR_OWVAR 40
5827: PUSH
5828: LD_INT 4
5830: PUSH
5831: LD_INT 5
5833: PUSH
5834: LD_INT 3
5836: PUSH
5837: EMPTY
5838: LIST
5839: LIST
5840: LIST
5841: PUSH
5842: LD_INT 1
5844: PPUSH
5845: LD_INT 3
5847: PPUSH
5848: CALL_OW 12
5852: ARRAY
5853: ST_TO_ADDR
// vc_fuel_battery := Rand ( 88 , 99 ) ;
5854: LD_ADDR_OWVAR 41
5858: PUSH
5859: LD_INT 88
5861: PPUSH
5862: LD_INT 99
5864: PPUSH
5865: CALL_OW 12
5869: ST_TO_ADDR
// un := CreateVehicle ;
5870: LD_ADDR_VAR 0 4
5874: PUSH
5875: CALL_OW 45
5879: ST_TO_ADDR
// PlaceUnitXY ( un , 64 , 117 , false ) ;
5880: LD_VAR 0 4
5884: PPUSH
5885: LD_INT 64
5887: PPUSH
5888: LD_INT 117
5890: PPUSH
5891: LD_INT 0
5893: PPUSH
5894: CALL_OW 48
// PrepareHuman ( false , 3 , skill ) ;
5898: LD_INT 0
5900: PPUSH
5901: LD_INT 3
5903: PPUSH
5904: LD_VAR 0 5
5908: PPUSH
5909: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
5913: CALL_OW 44
5917: PPUSH
5918: LD_VAR 0 4
5922: PPUSH
5923: CALL_OW 52
// us_force := Insert ( us_force , 1 , un ) ;
5927: LD_ADDR_EXP 12
5931: PUSH
5932: LD_EXP 12
5936: PPUSH
5937: LD_INT 1
5939: PPUSH
5940: LD_VAR 0 4
5944: PPUSH
5945: CALL_OW 2
5949: ST_TO_ADDR
// ComMoveXY ( un , 60 , 109 ) ;
5950: LD_VAR 0 4
5954: PPUSH
5955: LD_INT 60
5957: PPUSH
5958: LD_INT 109
5960: PPUSH
5961: CALL_OW 111
// Wait ( 0 0$02 ) ;
5965: LD_INT 70
5967: PPUSH
5968: CALL_OW 67
// end ;
5972: GO 5773
5974: POP
5975: POP
// while ( FilterAllUnits ( [ f_side , 1 ] ) ) do
5976: LD_INT 22
5978: PUSH
5979: LD_INT 1
5981: PUSH
5982: EMPTY
5983: LIST
5984: LIST
5985: PPUSH
5986: CALL_OW 69
5990: IFFALSE 6191
// begin Wait ( 0 0$01 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// for i = 1 to us_force do
5999: LD_ADDR_VAR 0 2
6003: PUSH
6004: DOUBLE
6005: LD_INT 1
6007: DEC
6008: ST_TO_ADDR
6009: LD_EXP 12
6013: PUSH
6014: FOR_TO
6015: IFFALSE 6050
// ComAttackUnit ( us_force [ i ] , FindTarget ( us_force [ i ] ) ) ;
6017: LD_EXP 12
6021: PUSH
6022: LD_VAR 0 2
6026: ARRAY
6027: PPUSH
6028: LD_EXP 12
6032: PUSH
6033: LD_VAR 0 2
6037: ARRAY
6038: PPUSH
6039: CALL 10358 0 1
6043: PPUSH
6044: CALL_OW 115
6048: GO 6014
6050: POP
6051: POP
// if FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) then
6052: LD_INT 22
6054: PUSH
6055: LD_INT 1
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PUSH
6062: LD_INT 25
6064: PUSH
6065: LD_INT 3
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: PUSH
6072: LD_INT 3
6074: PUSH
6075: LD_INT 55
6077: PUSH
6078: EMPTY
6079: LIST
6080: PUSH
6081: EMPTY
6082: LIST
6083: LIST
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: LIST
6089: PPUSH
6090: CALL_OW 69
6094: IFFALSE 6189
// for j in FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 3 ] , [ f_not , [ f_driving ] ] ] ) do
6096: LD_ADDR_VAR 0 3
6100: PUSH
6101: LD_INT 22
6103: PUSH
6104: LD_INT 1
6106: PUSH
6107: EMPTY
6108: LIST
6109: LIST
6110: PUSH
6111: LD_INT 25
6113: PUSH
6114: LD_INT 3
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: PUSH
6121: LD_INT 3
6123: PUSH
6124: LD_INT 55
6126: PUSH
6127: EMPTY
6128: LIST
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: PUSH
6134: EMPTY
6135: LIST
6136: LIST
6137: LIST
6138: PPUSH
6139: CALL_OW 69
6143: PUSH
6144: FOR_IN
6145: IFFALSE 6187
// if not IsInArea ( j , conv_end ) then
6147: LD_VAR 0 3
6151: PPUSH
6152: LD_INT 9
6154: PPUSH
6155: CALL_OW 308
6159: NOT
6160: IFFALSE 6176
// ComMoveToArea ( j , conv_end ) else
6162: LD_VAR 0 3
6166: PPUSH
6167: LD_INT 9
6169: PPUSH
6170: CALL_OW 113
6174: GO 6185
// RemoveUnit ( j ) ;
6176: LD_VAR 0 3
6180: PPUSH
6181: CALL_OW 64
6185: GO 6144
6187: POP
6188: POP
// end ;
6189: GO 5976
// end ; end_of_file
6191: LD_VAR 0 1
6195: RET
// export function PrepareArabian ; begin
6196: LD_INT 0
6198: PPUSH
// RobertFarmer ;
6199: CALL 6220 0 0
// PrepareHovercrafts ;
6203: CALL 7090 0 0
// ar_attacks := true ;
6207: LD_ADDR_EXP 10
6211: PUSH
6212: LD_INT 1
6214: ST_TO_ADDR
// end ;
6215: LD_VAR 0 1
6219: RET
// export Farmer ; export function RobertFarmer ; begin
6220: LD_INT 0
6222: PPUSH
// uc_side := 2 ;
6223: LD_ADDR_OWVAR 20
6227: PUSH
6228: LD_INT 2
6230: ST_TO_ADDR
// uc_nation := 2 ;
6231: LD_ADDR_OWVAR 21
6235: PUSH
6236: LD_INT 2
6238: ST_TO_ADDR
// Farmer := NewCharacter ( Farmer ) ;
6239: LD_ADDR_EXP 24
6243: PUSH
6244: LD_STRING Farmer
6246: PPUSH
6247: CALL_OW 25
6251: ST_TO_ADDR
// SayRadio ( Farmer , DPM_F1 ) ;
6252: LD_EXP 24
6256: PPUSH
6257: LD_STRING DPM_F1
6259: PPUSH
6260: CALL_OW 94
// end ;
6264: LD_VAR 0 1
6268: RET
// export function PrepareAttack ( type ) ; var i , un , veh , skill ; begin
6269: LD_INT 0
6271: PPUSH
6272: PPUSH
6273: PPUSH
6274: PPUSH
6275: PPUSH
// uc_side := 2 ;
6276: LD_ADDR_OWVAR 20
6280: PUSH
6281: LD_INT 2
6283: ST_TO_ADDR
// uc_nation := 2 ;
6284: LD_ADDR_OWVAR 21
6288: PUSH
6289: LD_INT 2
6291: ST_TO_ADDR
// skill := [ 4 , 5 , 6 ] [ Difficulty ] ;
6292: LD_ADDR_VAR 0 6
6296: PUSH
6297: LD_INT 4
6299: PUSH
6300: LD_INT 5
6302: PUSH
6303: LD_INT 6
6305: PUSH
6306: EMPTY
6307: LIST
6308: LIST
6309: LIST
6310: PUSH
6311: LD_OWVAR 67
6315: ARRAY
6316: ST_TO_ADDR
// Randomize ;
6317: CALL_OW 10
// case type of 1 :
6321: LD_VAR 0 1
6325: PUSH
6326: LD_INT 1
6328: DOUBLE
6329: EQUAL
6330: IFTRUE 6334
6332: GO 6456
6334: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6335: LD_ADDR_VAR 0 3
6339: PUSH
6340: DOUBLE
6341: LD_INT 1
6343: DEC
6344: ST_TO_ADDR
6345: LD_INT 3
6347: PUSH
6348: LD_INT 4
6350: PUSH
6351: LD_INT 5
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: LIST
6358: PUSH
6359: LD_OWVAR 67
6363: ARRAY
6364: PUSH
6365: FOR_TO
6366: IFFALSE 6452
// begin PrepareHuman ( false , [ class_soldier , class_soldier , class_mortar ] [ Rand ( 1 , 3 ) ] , skill ) ;
6368: LD_INT 0
6370: PPUSH
6371: LD_INT 1
6373: PUSH
6374: LD_INT 1
6376: PUSH
6377: LD_INT 8
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_INT 1
6387: PPUSH
6388: LD_INT 3
6390: PPUSH
6391: CALL_OW 12
6395: ARRAY
6396: PPUSH
6397: LD_VAR 0 6
6401: PPUSH
6402: CALL_OW 380
// un := CreateHuman ;
6406: LD_ADDR_VAR 0 4
6410: PUSH
6411: CALL_OW 44
6415: ST_TO_ADDR
// PlaceUnitArea ( un , ar3 , false ) ;
6416: LD_VAR 0 4
6420: PPUSH
6421: LD_INT 18
6423: PPUSH
6424: LD_INT 0
6426: PPUSH
6427: CALL_OW 49
// ComMoveToArea ( un , spot3 ) ;
6431: LD_VAR 0 4
6435: PPUSH
6436: LD_INT 20
6438: PPUSH
6439: CALL_OW 113
// Wait ( 0 0$01 ) ;
6443: LD_INT 35
6445: PPUSH
6446: CALL_OW 67
// end ;
6450: GO 6365
6452: POP
6453: POP
// end ; 2 :
6454: GO 7085
6456: LD_INT 2
6458: DOUBLE
6459: EQUAL
6460: IFTRUE 6464
6462: GO 6727
6464: POP
// begin for i = 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
6465: LD_ADDR_VAR 0 3
6469: PUSH
6470: DOUBLE
6471: LD_INT 1
6473: DEC
6474: ST_TO_ADDR
6475: LD_INT 4
6477: PUSH
6478: LD_INT 5
6480: PUSH
6481: LD_INT 5
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: PUSH
6489: LD_OWVAR 67
6493: ARRAY
6494: PUSH
6495: FOR_TO
6496: IFFALSE 6559
// begin PrepareHuman ( false , class_soldier , skill ) ;
6498: LD_INT 0
6500: PPUSH
6501: LD_INT 1
6503: PPUSH
6504: LD_VAR 0 6
6508: PPUSH
6509: CALL_OW 380
// un := CreateHuman ;
6513: LD_ADDR_VAR 0 4
6517: PUSH
6518: CALL_OW 44
6522: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6523: LD_VAR 0 4
6527: PPUSH
6528: LD_INT 17
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: CALL_OW 49
// ComMoveToArea ( un , spot2 ) ;
6538: LD_VAR 0 4
6542: PPUSH
6543: LD_INT 19
6545: PPUSH
6546: CALL_OW 113
// Wait ( 0 0$01 ) ;
6550: LD_INT 35
6552: PPUSH
6553: CALL_OW 67
// end ;
6557: GO 6495
6559: POP
6560: POP
// for i = 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6561: LD_ADDR_VAR 0 3
6565: PUSH
6566: DOUBLE
6567: LD_INT 1
6569: DEC
6570: ST_TO_ADDR
6571: LD_INT 2
6573: PUSH
6574: LD_INT 3
6576: PUSH
6577: LD_INT 4
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: LIST
6584: PUSH
6585: LD_OWVAR 67
6589: ARRAY
6590: PUSH
6591: FOR_TO
6592: IFFALSE 6723
// begin vc_chassis := ar_medium_trike ;
6594: LD_ADDR_OWVAR 37
6598: PUSH
6599: LD_INT 13
6601: ST_TO_ADDR
// vc_engine := engine_combustion ;
6602: LD_ADDR_OWVAR 39
6606: PUSH
6607: LD_INT 1
6609: ST_TO_ADDR
// vc_control := control_manual ;
6610: LD_ADDR_OWVAR 38
6614: PUSH
6615: LD_INT 1
6617: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_light_gun ] [ Rand ( 1 , 2 ) ] ;
6618: LD_ADDR_OWVAR 40
6622: PUSH
6623: LD_INT 24
6625: PUSH
6626: LD_INT 23
6628: PUSH
6629: EMPTY
6630: LIST
6631: LIST
6632: PUSH
6633: LD_INT 1
6635: PPUSH
6636: LD_INT 2
6638: PPUSH
6639: CALL_OW 12
6643: ARRAY
6644: ST_TO_ADDR
// veh := CreateVehicle ;
6645: LD_ADDR_VAR 0 5
6649: PUSH
6650: CALL_OW 45
6654: ST_TO_ADDR
// PlaceUnitArea ( veh , ar2 , false ) ;
6655: LD_VAR 0 5
6659: PPUSH
6660: LD_INT 17
6662: PPUSH
6663: LD_INT 0
6665: PPUSH
6666: CALL_OW 49
// PrepareHuman ( false , 1 , skill ) ;
6670: LD_INT 0
6672: PPUSH
6673: LD_INT 1
6675: PPUSH
6676: LD_VAR 0 6
6680: PPUSH
6681: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
6685: CALL_OW 44
6689: PPUSH
6690: LD_VAR 0 5
6694: PPUSH
6695: CALL_OW 52
// ComMoveXY ( veh , 89 , 40 ) ;
6699: LD_VAR 0 5
6703: PPUSH
6704: LD_INT 89
6706: PPUSH
6707: LD_INT 40
6709: PPUSH
6710: CALL_OW 111
// Wait ( 0 0$02 ) ;
6714: LD_INT 70
6716: PPUSH
6717: CALL_OW 67
// end ;
6721: GO 6591
6723: POP
6724: POP
// end ; 3 :
6725: GO 7085
6727: LD_INT 3
6729: DOUBLE
6730: EQUAL
6731: IFTRUE 6735
6733: GO 7084
6735: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] + ( tick div 15 15$00 ) do
6736: LD_ADDR_VAR 0 3
6740: PUSH
6741: DOUBLE
6742: LD_INT 1
6744: DEC
6745: ST_TO_ADDR
6746: LD_INT 4
6748: PUSH
6749: LD_INT 5
6751: PUSH
6752: LD_INT 6
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: LIST
6759: PUSH
6760: LD_OWVAR 67
6764: ARRAY
6765: PUSH
6766: LD_OWVAR 1
6770: PUSH
6771: LD_INT 31500
6773: DIV
6774: PLUS
6775: PUSH
6776: FOR_TO
6777: IFFALSE 6885
// begin PrepareHuman ( false , [ class_soldier , class_mortar ] [ Rand ( 1 , 2 ) ] , skill ) ;
6779: LD_INT 0
6781: PPUSH
6782: LD_INT 1
6784: PUSH
6785: LD_INT 8
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 1
6794: PPUSH
6795: LD_INT 2
6797: PPUSH
6798: CALL_OW 12
6802: ARRAY
6803: PPUSH
6804: LD_VAR 0 6
6808: PPUSH
6809: CALL_OW 380
// un := CreateHuman ;
6813: LD_ADDR_VAR 0 4
6817: PUSH
6818: CALL_OW 44
6822: ST_TO_ADDR
// PlaceUnitArea ( un , ar2 , false ) ;
6823: LD_VAR 0 4
6827: PPUSH
6828: LD_INT 17
6830: PPUSH
6831: LD_INT 0
6833: PPUSH
6834: CALL_OW 49
// ar_force := Insert ( ar_force , 1 , un ) ;
6838: LD_ADDR_EXP 11
6842: PUSH
6843: LD_EXP 11
6847: PPUSH
6848: LD_INT 1
6850: PPUSH
6851: LD_VAR 0 4
6855: PPUSH
6856: CALL_OW 2
6860: ST_TO_ADDR
// ComMoveXY ( un , 17 , 9 ) ;
6861: LD_VAR 0 4
6865: PPUSH
6866: LD_INT 17
6868: PPUSH
6869: LD_INT 9
6871: PPUSH
6872: CALL_OW 111
// Wait ( 0 0$01 ) ;
6876: LD_INT 35
6878: PPUSH
6879: CALL_OW 67
// end ;
6883: GO 6776
6885: POP
6886: POP
// for i = 1 to [ 4 , 5 , 7 ] [ Difficulty ] do
6887: LD_ADDR_VAR 0 3
6891: PUSH
6892: DOUBLE
6893: LD_INT 1
6895: DEC
6896: ST_TO_ADDR
6897: LD_INT 4
6899: PUSH
6900: LD_INT 5
6902: PUSH
6903: LD_INT 7
6905: PUSH
6906: EMPTY
6907: LIST
6908: LIST
6909: LIST
6910: PUSH
6911: LD_OWVAR 67
6915: ARRAY
6916: PUSH
6917: FOR_TO
6918: IFFALSE 7080
// begin vc_chassis := ar_half_tracked ;
6920: LD_ADDR_OWVAR 37
6924: PUSH
6925: LD_INT 14
6927: ST_TO_ADDR
// vc_engine := engine_combustion ;
6928: LD_ADDR_OWVAR 39
6932: PUSH
6933: LD_INT 1
6935: ST_TO_ADDR
// vc_control := control_manual ;
6936: LD_ADDR_OWVAR 38
6940: PUSH
6941: LD_INT 1
6943: ST_TO_ADDR
// vc_weapon := [ ar_gatling_gun , ar_gun , ar_rocket_launcher , ar_flame_thrower ] [ Rand ( 1 , 4 ) ] ;
6944: LD_ADDR_OWVAR 40
6948: PUSH
6949: LD_INT 25
6951: PUSH
6952: LD_INT 27
6954: PUSH
6955: LD_INT 28
6957: PUSH
6958: LD_INT 26
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: PUSH
6967: LD_INT 1
6969: PPUSH
6970: LD_INT 4
6972: PPUSH
6973: CALL_OW 12
6977: ARRAY
6978: ST_TO_ADDR
// veh := CreateVehicle ;
6979: LD_ADDR_VAR 0 5
6983: PUSH
6984: CALL_OW 45
6988: ST_TO_ADDR
// PlaceUnitArea ( veh , ar1 , false ) ;
6989: LD_VAR 0 5
6993: PPUSH
6994: LD_INT 16
6996: PPUSH
6997: LD_INT 0
6999: PPUSH
7000: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7004: LD_INT 0
7006: PPUSH
7007: LD_INT 3
7009: PPUSH
7010: LD_VAR 0 6
7014: PPUSH
7015: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , veh ) ;
7019: CALL_OW 44
7023: PPUSH
7024: LD_VAR 0 5
7028: PPUSH
7029: CALL_OW 52
// ar_force := Insert ( ar_force , 1 , veh ) ;
7033: LD_ADDR_EXP 11
7037: PUSH
7038: LD_EXP 11
7042: PPUSH
7043: LD_INT 1
7045: PPUSH
7046: LD_VAR 0 5
7050: PPUSH
7051: CALL_OW 2
7055: ST_TO_ADDR
// ComMoveXY ( veh , 125 , 31 ) ;
7056: LD_VAR 0 5
7060: PPUSH
7061: LD_INT 125
7063: PPUSH
7064: LD_INT 31
7066: PPUSH
7067: CALL_OW 111
// Wait ( 0 0$02 ) ;
7071: LD_INT 70
7073: PPUSH
7074: CALL_OW 67
// end ;
7078: GO 6917
7080: POP
7081: POP
// end ; end ;
7082: GO 7085
7084: POP
// end ;
7085: LD_VAR 0 2
7089: RET
// export function PrepareHovercrafts ; var i , un , areas , skill ; begin
7090: LD_INT 0
7092: PPUSH
7093: PPUSH
7094: PPUSH
7095: PPUSH
7096: PPUSH
// areas := [ river1 , river2 ] ;
7097: LD_ADDR_VAR 0 4
7101: PUSH
7102: LD_INT 14
7104: PUSH
7105: LD_INT 15
7107: PUSH
7108: EMPTY
7109: LIST
7110: LIST
7111: ST_TO_ADDR
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
7112: LD_ADDR_VAR 0 5
7116: PUSH
7117: LD_INT 5
7119: PUSH
7120: LD_INT 6
7122: PUSH
7123: LD_INT 7
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: LIST
7130: PUSH
7131: LD_OWVAR 67
7135: ARRAY
7136: ST_TO_ADDR
// uc_side := 2 ;
7137: LD_ADDR_OWVAR 20
7141: PUSH
7142: LD_INT 2
7144: ST_TO_ADDR
// uc_nation := 2 ;
7145: LD_ADDR_OWVAR 21
7149: PUSH
7150: LD_INT 2
7152: ST_TO_ADDR
// hc_name :=  ;
7153: LD_ADDR_OWVAR 26
7157: PUSH
7158: LD_STRING 
7160: ST_TO_ADDR
// hc_gallery :=  ;
7161: LD_ADDR_OWVAR 33
7165: PUSH
7166: LD_STRING 
7168: ST_TO_ADDR
// for i = 1 to [ 1 , 2 , 2 ] [ Difficulty ] do
7169: LD_ADDR_VAR 0 2
7173: PUSH
7174: DOUBLE
7175: LD_INT 1
7177: DEC
7178: ST_TO_ADDR
7179: LD_INT 1
7181: PUSH
7182: LD_INT 2
7184: PUSH
7185: LD_INT 2
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: LIST
7192: PUSH
7193: LD_OWVAR 67
7197: ARRAY
7198: PUSH
7199: FOR_TO
7200: IFFALSE 7338
// begin vc_chassis := ar_hovercraft ;
7202: LD_ADDR_OWVAR 37
7206: PUSH
7207: LD_INT 11
7209: ST_TO_ADDR
// vc_engine := engine_solar ;
7210: LD_ADDR_OWVAR 39
7214: PUSH
7215: LD_INT 2
7217: ST_TO_ADDR
// vc_control := control_manual ;
7218: LD_ADDR_OWVAR 38
7222: PUSH
7223: LD_INT 1
7225: ST_TO_ADDR
// vc_weapon := ar_double_machine_gun ;
7226: LD_ADDR_OWVAR 40
7230: PUSH
7231: LD_INT 24
7233: ST_TO_ADDR
// vc_fuel_battery := 100 ;
7234: LD_ADDR_OWVAR 41
7238: PUSH
7239: LD_INT 100
7241: ST_TO_ADDR
// un := CreateVehicle ;
7242: LD_ADDR_VAR 0 3
7246: PUSH
7247: CALL_OW 45
7251: ST_TO_ADDR
// PlaceUnitArea ( un , areas [ i ] , false ) ;
7252: LD_VAR 0 3
7256: PPUSH
7257: LD_VAR 0 4
7261: PUSH
7262: LD_VAR 0 2
7266: ARRAY
7267: PPUSH
7268: LD_INT 0
7270: PPUSH
7271: CALL_OW 49
// PrepareHuman ( false , 3 , skill ) ;
7275: LD_INT 0
7277: PPUSH
7278: LD_INT 3
7280: PPUSH
7281: LD_VAR 0 5
7285: PPUSH
7286: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
7290: CALL_OW 44
7294: PPUSH
7295: LD_VAR 0 3
7299: PPUSH
7300: CALL_OW 52
// riv := Insert ( riv , 1 , [ un , i ] ) ;
7304: LD_ADDR_EXP 9
7308: PUSH
7309: LD_EXP 9
7313: PPUSH
7314: LD_INT 1
7316: PPUSH
7317: LD_VAR 0 3
7321: PUSH
7322: LD_VAR 0 2
7326: PUSH
7327: EMPTY
7328: LIST
7329: LIST
7330: PPUSH
7331: CALL_OW 2
7335: ST_TO_ADDR
// end ;
7336: GO 7199
7338: POP
7339: POP
// end ;
7340: LD_VAR 0 1
7344: RET
// every 0 0$01 trigger riv do var i , c ;
7345: LD_EXP 9
7349: IFFALSE 7668
7351: GO 7353
7353: DISABLE
7354: LD_INT 0
7356: PPUSH
7357: PPUSH
// begin enable ;
7358: ENABLE
// for i = riv downto 1 do
7359: LD_ADDR_VAR 0 1
7363: PUSH
7364: DOUBLE
7365: LD_EXP 9
7369: INC
7370: ST_TO_ADDR
7371: LD_INT 1
7373: PUSH
7374: FOR_DOWNTO
7375: IFFALSE 7666
// begin if not riv [ i ] [ 1 ] then
7377: LD_EXP 9
7381: PUSH
7382: LD_VAR 0 1
7386: ARRAY
7387: PUSH
7388: LD_INT 1
7390: ARRAY
7391: NOT
7392: IFFALSE 7414
// begin riv := Delete ( riv , 1 ) ;
7394: LD_ADDR_EXP 9
7398: PUSH
7399: LD_EXP 9
7403: PPUSH
7404: LD_INT 1
7406: PPUSH
7407: CALL_OW 3
7411: ST_TO_ADDR
// break ;
7412: GO 7666
// end ; if not HasTask ( riv [ i ] [ 1 ] ) then
7414: LD_EXP 9
7418: PUSH
7419: LD_VAR 0 1
7423: ARRAY
7424: PUSH
7425: LD_INT 1
7427: ARRAY
7428: PPUSH
7429: CALL_OW 314
7433: NOT
7434: IFFALSE 7502
// begin if riv [ i ] [ 2 ] = 1 then
7436: LD_EXP 9
7440: PUSH
7441: LD_VAR 0 1
7445: ARRAY
7446: PUSH
7447: LD_INT 2
7449: ARRAY
7450: PUSH
7451: LD_INT 1
7453: EQUAL
7454: IFFALSE 7466
// c := 2 else
7456: LD_ADDR_VAR 0 2
7460: PUSH
7461: LD_INT 2
7463: ST_TO_ADDR
7464: GO 7474
// c := 1 ;
7466: LD_ADDR_VAR 0 2
7470: PUSH
7471: LD_INT 1
7473: ST_TO_ADDR
// riv := Replace2 ( riv , i , 2 , c ) ;
7474: LD_ADDR_EXP 9
7478: PUSH
7479: LD_EXP 9
7483: PPUSH
7484: LD_VAR 0 1
7488: PPUSH
7489: LD_INT 2
7491: PPUSH
7492: LD_VAR 0 2
7496: PPUSH
7497: CALL 10050 0 4
7501: ST_TO_ADDR
// end ; if not IsInArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) then
7502: LD_EXP 9
7506: PUSH
7507: LD_VAR 0 1
7511: ARRAY
7512: PUSH
7513: LD_INT 1
7515: ARRAY
7516: PPUSH
7517: LD_INT 14
7519: PUSH
7520: LD_INT 15
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: PUSH
7527: LD_EXP 9
7531: PUSH
7532: LD_VAR 0 1
7536: ARRAY
7537: PUSH
7538: LD_INT 2
7540: ARRAY
7541: ARRAY
7542: PPUSH
7543: CALL_OW 308
7547: NOT
7548: IFFALSE 7664
// begin if GetFuel ( riv [ i ] [ 1 ] ) < 50 then
7550: LD_EXP 9
7554: PUSH
7555: LD_VAR 0 1
7559: ARRAY
7560: PUSH
7561: LD_INT 1
7563: ARRAY
7564: PPUSH
7565: CALL_OW 261
7569: PUSH
7570: LD_INT 50
7572: LESS
7573: IFFALSE 7597
// SetFuel ( riv [ i ] [ 1 ] , 67 ) ;
7575: LD_EXP 9
7579: PUSH
7580: LD_VAR 0 1
7584: ARRAY
7585: PUSH
7586: LD_INT 1
7588: ARRAY
7589: PPUSH
7590: LD_INT 67
7592: PPUSH
7593: CALL_OW 240
// ComMoveToArea ( riv [ i ] [ 1 ] , [ river1 , river2 ] [ riv [ i ] [ 2 ] ] ) ;
7597: LD_EXP 9
7601: PUSH
7602: LD_VAR 0 1
7606: ARRAY
7607: PUSH
7608: LD_INT 1
7610: ARRAY
7611: PPUSH
7612: LD_INT 14
7614: PUSH
7615: LD_INT 15
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: LD_EXP 9
7626: PUSH
7627: LD_VAR 0 1
7631: ARRAY
7632: PUSH
7633: LD_INT 2
7635: ARRAY
7636: ARRAY
7637: PPUSH
7638: CALL_OW 113
// AddComWait ( riv [ i ] [ 1 ] , 0 0$10 ) ;
7642: LD_EXP 9
7646: PUSH
7647: LD_VAR 0 1
7651: ARRAY
7652: PUSH
7653: LD_INT 1
7655: ARRAY
7656: PPUSH
7657: LD_INT 350
7659: PPUSH
7660: CALL_OW 202
// end ; end ;
7664: GO 7374
7666: POP
7667: POP
// end ;
7668: PPOPN 2
7670: END
// every 10 10$00 trigger convoy_start do var i , un ;
7671: LD_EXP 7
7675: IFFALSE 7796
7677: GO 7679
7679: DISABLE
7680: LD_INT 0
7682: PPUSH
7683: PPUSH
// begin enable ;
7684: ENABLE
// for i = 1 to 2 do
7685: LD_ADDR_VAR 0 1
7689: PUSH
7690: DOUBLE
7691: LD_INT 1
7693: DEC
7694: ST_TO_ADDR
7695: LD_INT 2
7697: PUSH
7698: FOR_TO
7699: IFFALSE 7794
// begin uc_side := 2 ;
7701: LD_ADDR_OWVAR 20
7705: PUSH
7706: LD_INT 2
7708: ST_TO_ADDR
// uc_nation := 2 ;
7709: LD_ADDR_OWVAR 21
7713: PUSH
7714: LD_INT 2
7716: ST_TO_ADDR
// PrepareHuman ( false , 1 , 4 ) ;
7717: LD_INT 0
7719: PPUSH
7720: LD_INT 1
7722: PPUSH
7723: LD_INT 4
7725: PPUSH
7726: CALL_OW 380
// un := CreateHuman ;
7730: LD_ADDR_VAR 0 2
7734: PUSH
7735: CALL_OW 44
7739: ST_TO_ADDR
// PlaceUnitXY ( un , 10 , 2 , false ) ;
7740: LD_VAR 0 2
7744: PPUSH
7745: LD_INT 10
7747: PPUSH
7748: LD_INT 2
7750: PPUSH
7751: LD_INT 0
7753: PPUSH
7754: CALL_OW 48
// ComMoveXY ( un , 24 , 36 ) ;
7758: LD_VAR 0 2
7762: PPUSH
7763: LD_INT 24
7765: PPUSH
7766: LD_INT 36
7768: PPUSH
7769: CALL_OW 111
// AddComMoveToArea ( un , conv_end ) ;
7773: LD_VAR 0 2
7777: PPUSH
7778: LD_INT 9
7780: PPUSH
7781: CALL_OW 173
// Wait ( 0 0$02 ) ;
7785: LD_INT 70
7787: PPUSH
7788: CALL_OW 67
// end ;
7792: GO 7698
7794: POP
7795: POP
// end ;
7796: PPOPN 2
7798: END
// every 0 0$01 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , rest ;
7799: LD_INT 22
7801: PUSH
7802: LD_INT 2
7804: PUSH
7805: EMPTY
7806: LIST
7807: LIST
7808: PPUSH
7809: CALL_OW 69
7813: IFFALSE 8124
7815: GO 7817
7817: DISABLE
7818: LD_INT 0
7820: PPUSH
7821: PPUSH
// begin enable ;
7822: ENABLE
// rest := FilterAllUnits ( [ f_side , 2 ] ) diff ar_force ;
7823: LD_ADDR_VAR 0 2
7827: PUSH
7828: LD_INT 22
7830: PUSH
7831: LD_INT 2
7833: PUSH
7834: EMPTY
7835: LIST
7836: LIST
7837: PPUSH
7838: CALL_OW 69
7842: PUSH
7843: LD_EXP 11
7847: DIFF
7848: ST_TO_ADDR
// if rest then
7849: LD_VAR 0 2
7853: IFFALSE 7925
// for i in rest do
7855: LD_ADDR_VAR 0 1
7859: PUSH
7860: LD_VAR 0 2
7864: PUSH
7865: FOR_IN
7866: IFFALSE 7923
// if GetClass ( i ) = 3 then
7868: LD_VAR 0 1
7872: PPUSH
7873: CALL_OW 257
7877: PUSH
7878: LD_INT 3
7880: EQUAL
7881: IFFALSE 7921
// begin if not IsInArea ( i , ar2 ) then
7883: LD_VAR 0 1
7887: PPUSH
7888: LD_INT 17
7890: PPUSH
7891: CALL_OW 308
7895: NOT
7896: IFFALSE 7912
// ComMoveToArea ( i , ar2 ) else
7898: LD_VAR 0 1
7902: PPUSH
7903: LD_INT 17
7905: PPUSH
7906: CALL_OW 113
7910: GO 7921
// RemoveUnit ( i ) ;
7912: LD_VAR 0 1
7916: PPUSH
7917: CALL_OW 64
// end ;
7921: GO 7865
7923: POP
7924: POP
// if ar_force then
7925: LD_EXP 11
7929: IFFALSE 8124
// for i in ar_force do
7931: LD_ADDR_VAR 0 1
7935: PUSH
7936: LD_EXP 11
7940: PUSH
7941: FOR_IN
7942: IFFALSE 8122
// begin if GetClass ( i ) = class_soldier then
7944: LD_VAR 0 1
7948: PPUSH
7949: CALL_OW 257
7953: PUSH
7954: LD_INT 1
7956: EQUAL
7957: IFFALSE 8049
// if FindTarget ( i ) in FilterAllUnits ( [ f_type , unit_building ] ) then
7959: LD_VAR 0 1
7963: PPUSH
7964: CALL 10358 0 1
7968: PUSH
7969: LD_INT 21
7971: PUSH
7972: LD_INT 3
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PPUSH
7979: CALL_OW 69
7983: IN
7984: IFFALSE 8030
// ComPlaceDelayedCharge ( i , GetX ( FindTarget ( i ) ) , GetY ( FindTarget ( i ) ) , 0 ) else
7986: LD_VAR 0 1
7990: PPUSH
7991: LD_VAR 0 1
7995: PPUSH
7996: CALL 10358 0 1
8000: PPUSH
8001: CALL_OW 250
8005: PPUSH
8006: LD_VAR 0 1
8010: PPUSH
8011: CALL 10358 0 1
8015: PPUSH
8016: CALL_OW 251
8020: PPUSH
8021: LD_INT 0
8023: PPUSH
8024: CALL_OW 132
8028: GO 8049
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8030: LD_VAR 0 1
8034: PPUSH
8035: LD_VAR 0 1
8039: PPUSH
8040: CALL 10358 0 1
8044: PPUSH
8045: CALL_OW 115
// if not GetClass ( i ) = 1 then
8049: LD_VAR 0 1
8053: PPUSH
8054: CALL_OW 257
8058: PUSH
8059: LD_INT 1
8061: EQUAL
8062: NOT
8063: IFFALSE 8084
// ComAttackUnit ( i , FindTarget ( i ) ) ;
8065: LD_VAR 0 1
8069: PPUSH
8070: LD_VAR 0 1
8074: PPUSH
8075: CALL 10358 0 1
8079: PPUSH
8080: CALL_OW 115
// if GetDistUnitXY ( i , 65 , 118 ) < 40 then
8084: LD_VAR 0 1
8088: PPUSH
8089: LD_INT 65
8091: PPUSH
8092: LD_INT 118
8094: PPUSH
8095: CALL_OW 297
8099: PUSH
8100: LD_INT 40
8102: LESS
8103: IFFALSE 8120
// ComMoveXY ( i , 65 , 118 ) ;
8105: LD_VAR 0 1
8109: PPUSH
8110: LD_INT 65
8112: PPUSH
8113: LD_INT 118
8115: PPUSH
8116: CALL_OW 111
// end ;
8120: GO 7941
8122: POP
8123: POP
// end ;
8124: PPOPN 2
8126: END
// every 0 0$01 trigger FilterUnitsInArea ( conv_end , [ f_side , 2 ] ) do
8127: LD_INT 9
8129: PPUSH
8130: LD_INT 22
8132: PUSH
8133: LD_INT 2
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: PPUSH
8140: CALL_OW 70
8144: IFFALSE 8157
8146: GO 8148
8148: DISABLE
// medal2 := false ; end_of_file
8149: LD_ADDR_EXP 4
8153: PUSH
8154: LD_INT 0
8156: ST_TO_ADDR
8157: END
// export function Action ; begin
8158: LD_INT 0
8160: PPUSH
// case Query ( textdiff ) of 1 :
8161: LD_STRING textdiff
8163: PPUSH
8164: CALL_OW 97
8168: PUSH
8169: LD_INT 1
8171: DOUBLE
8172: EQUAL
8173: IFTRUE 8177
8175: GO 8188
8177: POP
// Difficulty := 1 ; 2 :
8178: LD_ADDR_OWVAR 67
8182: PUSH
8183: LD_INT 1
8185: ST_TO_ADDR
8186: GO 8227
8188: LD_INT 2
8190: DOUBLE
8191: EQUAL
8192: IFTRUE 8196
8194: GO 8207
8196: POP
// Difficulty := 2 ; 3 :
8197: LD_ADDR_OWVAR 67
8201: PUSH
8202: LD_INT 2
8204: ST_TO_ADDR
8205: GO 8227
8207: LD_INT 3
8209: DOUBLE
8210: EQUAL
8211: IFTRUE 8215
8213: GO 8226
8215: POP
// Difficulty := 3 ; end ;
8216: LD_ADDR_OWVAR 67
8220: PUSH
8221: LD_INT 3
8223: ST_TO_ADDR
8224: GO 8227
8226: POP
// case Query ( info ) of 1 :
8227: LD_STRING info
8229: PPUSH
8230: CALL_OW 97
8234: PUSH
8235: LD_INT 1
8237: DOUBLE
8238: EQUAL
8239: IFTRUE 8243
8241: GO 8246
8243: POP
// ; end ;
8244: GO 8247
8246: POP
// SaveForQuickRestart ;
8247: CALL_OW 22
// ChangeMissionObjectives ( PM_1 ) ;
8251: LD_STRING PM_1
8253: PPUSH
8254: CALL_OW 337
// end ;
8258: LD_VAR 0 1
8262: RET
// every 0 0$01 trigger GetSide ( us_depot ) = 3 do
8263: LD_INT 50
8265: PPUSH
8266: CALL_OW 255
8270: PUSH
8271: LD_INT 3
8273: EQUAL
8274: IFFALSE 8555
8276: GO 8278
8278: DISABLE
// begin Say ( Stolypin , DPM_S1 ) ;
8279: LD_EXP 15
8283: PPUSH
8284: LD_STRING DPM_S1
8286: PPUSH
8287: CALL_OW 88
// SayRadio ( Popov , DPM_P1 ) ;
8291: LD_EXP 16
8295: PPUSH
8296: LD_STRING DPM_P1
8298: PPUSH
8299: CALL_OW 94
// Say ( Stolypin , DPM_S2 ) ;
8303: LD_EXP 15
8307: PPUSH
8308: LD_STRING DPM_S2
8310: PPUSH
8311: CALL_OW 88
// SaveForQuickRestart ;
8315: CALL_OW 22
// ChangeMissionObjectives ( PM_2 ) ;
8319: LD_STRING PM_2
8321: PPUSH
8322: CALL_OW 337
// Wait ( 2 2$30 ) ;
8326: LD_INT 5250
8328: PPUSH
8329: CALL_OW 67
// CenterOnXY ( 117 , 4 ) ;
8333: LD_INT 117
8335: PPUSH
8336: LD_INT 4
8338: PPUSH
8339: CALL_OW 84
// Convoy ( 1 ) ;
8343: LD_INT 1
8345: PPUSH
8346: CALL 876 0 1
// Wait ( 0 0$30 ) ;
8350: LD_INT 1050
8352: PPUSH
8353: CALL_OW 67
// Convoy ( 2 ) ;
8357: LD_INT 2
8359: PPUSH
8360: CALL 876 0 1
// Wait ( 1 1$30 ) ;
8364: LD_INT 3150
8366: PPUSH
8367: CALL_OW 67
// Convoy ( 3 ) ;
8371: LD_INT 3
8373: PPUSH
8374: CALL 876 0 1
// Wait ( 5 5$00 ) ;
8378: LD_INT 10500
8380: PPUSH
8381: CALL_OW 67
// convoy_start := true ;
8385: LD_ADDR_EXP 7
8389: PUSH
8390: LD_INT 1
8392: ST_TO_ADDR
// PrepareArabian ;
8393: CALL 6196 0 0
// PrepareAttack ( 1 ) ;
8397: LD_INT 1
8399: PPUSH
8400: CALL 6269 0 1
// while ( convoy_start ) do
8404: LD_EXP 7
8408: IFFALSE 8555
// begin Wait ( Rand ( 2 2$00 , 4 4$00 ) ) ;
8410: LD_INT 4200
8412: PPUSH
8413: LD_INT 8400
8415: PPUSH
8416: CALL_OW 12
8420: PPUSH
8421: CALL_OW 67
// if FilterAllUnits ( [ f_side , 2 ] ) < 20 then
8425: LD_INT 22
8427: PUSH
8428: LD_INT 2
8430: PUSH
8431: EMPTY
8432: LIST
8433: LIST
8434: PPUSH
8435: CALL_OW 69
8439: PUSH
8440: LD_INT 20
8442: LESS
8443: IFFALSE 8460
// PrepareAttack ( Rand ( 1 , 2 ) ) ;
8445: LD_INT 1
8447: PPUSH
8448: LD_INT 2
8450: PPUSH
8451: CALL_OW 12
8455: PPUSH
8456: CALL 6269 0 1
// Convoy ( Rand ( 1 , 5 ) ) ;
8460: LD_INT 1
8462: PPUSH
8463: LD_INT 5
8465: PPUSH
8466: CALL_OW 12
8470: PPUSH
8471: CALL 876 0 1
// conv_counter := conv_counter + 1 ;
8475: LD_ADDR_EXP 13
8479: PUSH
8480: LD_EXP 13
8484: PUSH
8485: LD_INT 1
8487: PLUS
8488: ST_TO_ADDR
// if conv_counter mod [ 5 , 4 , 3 ] [ Difficulty ] = 0 then
8489: LD_EXP 13
8493: PUSH
8494: LD_INT 5
8496: PUSH
8497: LD_INT 4
8499: PUSH
8500: LD_INT 3
8502: PUSH
8503: EMPTY
8504: LIST
8505: LIST
8506: LIST
8507: PUSH
8508: LD_OWVAR 67
8512: ARRAY
8513: MOD
8514: PUSH
8515: LD_INT 0
8517: EQUAL
8518: IFFALSE 8553
// begin Wait ( 1 1$20 ) ;
8520: LD_INT 2800
8522: PPUSH
8523: CALL_OW 67
// SayRadio ( Farmer , DPM_F2 ) ;
8527: LD_EXP 24
8531: PPUSH
8532: LD_STRING DPM_F2
8534: PPUSH
8535: CALL_OW 94
// PrepareAttack ( 3 ) ;
8539: LD_INT 3
8541: PPUSH
8542: CALL 6269 0 1
// Wait ( 4 4$00 ) ;
8546: LD_INT 8400
8548: PPUSH
8549: CALL_OW 67
// end ; end ;
8553: GO 8404
// end ;
8555: END
// every 1 1$30 trigger conv_counter mod 3 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8556: LD_EXP 13
8560: PUSH
8561: LD_INT 3
8563: MOD
8564: PUSH
8565: LD_INT 0
8567: EQUAL
8568: PUSH
8569: LD_INT 22
8571: PUSH
8572: LD_INT 2
8574: PUSH
8575: EMPTY
8576: LIST
8577: LIST
8578: PPUSH
8579: CALL_OW 69
8583: PUSH
8584: LD_INT 0
8586: EQUAL
8587: AND
8588: IFFALSE 8605
8590: GO 8592
8592: DISABLE
// SayRadio ( Farmer , DPM_F3 ) ;
8593: LD_EXP 24
8597: PPUSH
8598: LD_STRING DPM_F3
8600: PPUSH
8601: CALL_OW 94
8605: END
// every 1 1$30 trigger conv_counter mod 5 = 0 and FilterAllUnits ( [ f_side , 2 ] ) = 0 do
8606: LD_EXP 13
8610: PUSH
8611: LD_INT 5
8613: MOD
8614: PUSH
8615: LD_INT 0
8617: EQUAL
8618: PUSH
8619: LD_INT 22
8621: PUSH
8622: LD_INT 2
8624: PUSH
8625: EMPTY
8626: LIST
8627: LIST
8628: PPUSH
8629: CALL_OW 69
8633: PUSH
8634: LD_INT 0
8636: EQUAL
8637: AND
8638: IFFALSE 8655
8640: GO 8642
8642: DISABLE
// SayRadio ( Farmer , DPM_F4 ) ;
8643: LD_EXP 24
8647: PPUSH
8648: LD_STRING DPM_F4
8650: PPUSH
8651: CALL_OW 94
8655: END
// every 0 0$10 trigger conv_counter >= 8 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
8656: LD_EXP 13
8660: PUSH
8661: LD_INT 8
8663: GREATEREQUAL
8664: PUSH
8665: LD_INT 22
8667: PUSH
8668: LD_INT 6
8670: PUSH
8671: EMPTY
8672: LIST
8673: LIST
8674: PPUSH
8675: CALL_OW 69
8679: PUSH
8680: LD_INT 0
8682: EQUAL
8683: AND
8684: IFFALSE 8783
8686: GO 8688
8688: DISABLE
// begin SayRadio ( Popov , DPM_PEnd ) ;
8689: LD_EXP 16
8693: PPUSH
8694: LD_STRING DPM_PEnd
8696: PPUSH
8697: CALL_OW 94
// AddMedal ( med1 , medal1 ) ;
8701: LD_STRING med1
8703: PPUSH
8704: LD_EXP 3
8708: PPUSH
8709: CALL_OW 101
// AddMedal ( med2 , medal2 ) ;
8713: LD_STRING med2
8715: PPUSH
8716: LD_EXP 4
8720: PPUSH
8721: CALL_OW 101
// if dest_counter >= [ 15 , 10 , 7 ] [ Difficulty ] then
8725: LD_EXP 8
8729: PUSH
8730: LD_INT 15
8732: PUSH
8733: LD_INT 10
8735: PUSH
8736: LD_INT 7
8738: PUSH
8739: EMPTY
8740: LIST
8741: LIST
8742: LIST
8743: PUSH
8744: LD_OWVAR 67
8748: ARRAY
8749: GREATEREQUAL
8750: IFFALSE 8760
// medal3 := false ;
8752: LD_ADDR_EXP 5
8756: PUSH
8757: LD_INT 0
8759: ST_TO_ADDR
// AddMedal ( med3 , medal3 ) ;
8760: LD_STRING med3
8762: PPUSH
8763: LD_EXP 5
8767: PPUSH
8768: CALL_OW 101
// GiveMedals ( MAIN ) ;
8772: LD_STRING MAIN
8774: PPUSH
8775: CALL_OW 102
// YouWin ;
8779: CALL_OW 103
// end ;
8783: END
// every 4 4$00 trigger convoy_start do var i ;
8784: LD_EXP 7
8788: IFFALSE 9146
8790: GO 8792
8792: DISABLE
8793: LD_INT 0
8795: PPUSH
// begin SayRadio ( Popov , DPM_PHelp ) ;
8796: LD_EXP 16
8800: PPUSH
8801: LD_STRING DPM_PHelp
8803: PPUSH
8804: CALL_OW 94
// Wait ( 0 0$30 ) ;
8808: LD_INT 1050
8810: PPUSH
8811: CALL_OW 67
// Randomize ;
8815: CALL_OW 10
// uc_side := 3 ;
8819: LD_ADDR_OWVAR 20
8823: PUSH
8824: LD_INT 3
8826: ST_TO_ADDR
// uc_nation := 3 ;
8827: LD_ADDR_OWVAR 21
8831: PUSH
8832: LD_INT 3
8834: ST_TO_ADDR
// for i = 1 to [ 5 , 4 , 3 ] [ Difficulty ] do
8835: LD_ADDR_VAR 0 1
8839: PUSH
8840: DOUBLE
8841: LD_INT 1
8843: DEC
8844: ST_TO_ADDR
8845: LD_INT 5
8847: PUSH
8848: LD_INT 4
8850: PUSH
8851: LD_INT 3
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: LIST
8858: PUSH
8859: LD_OWVAR 67
8863: ARRAY
8864: PUSH
8865: FOR_TO
8866: IFFALSE 8906
// begin PrepareHuman ( false , Rand ( 1 , 3 ) , 5 ) ;
8868: LD_INT 0
8870: PPUSH
8871: LD_INT 1
8873: PPUSH
8874: LD_INT 3
8876: PPUSH
8877: CALL_OW 12
8881: PPUSH
8882: LD_INT 5
8884: PPUSH
8885: CALL_OW 380
// PlaceUnitArea ( CreateHuman , rus_start , false ) ;
8889: CALL_OW 44
8893: PPUSH
8894: LD_INT 1
8896: PPUSH
8897: LD_INT 0
8899: PPUSH
8900: CALL_OW 49
// end ;
8904: GO 8865
8906: POP
8907: POP
// vc_chassis := ru_heavy_wheeled ;
8908: LD_ADDR_OWVAR 37
8912: PUSH
8913: LD_INT 23
8915: ST_TO_ADDR
// vc_engine := engine_combustion ;
8916: LD_ADDR_OWVAR 39
8920: PUSH
8921: LD_INT 1
8923: ST_TO_ADDR
// vc_control := control_manual ;
8924: LD_ADDR_OWVAR 38
8928: PUSH
8929: LD_INT 1
8931: ST_TO_ADDR
// vc_weapon := 89 ;
8932: LD_ADDR_OWVAR 40
8936: PUSH
8937: LD_INT 89
8939: ST_TO_ADDR
// vc_fuel_battery := 88 ;
8940: LD_ADDR_OWVAR 41
8944: PUSH
8945: LD_INT 88
8947: ST_TO_ADDR
// i := CreateVehicle ;
8948: LD_ADDR_VAR 0 1
8952: PUSH
8953: CALL_OW 45
8957: ST_TO_ADDR
// SetDir ( i , 5 ) ;
8958: LD_VAR 0 1
8962: PPUSH
8963: LD_INT 5
8965: PPUSH
8966: CALL_OW 233
// PlaceUnitXY ( i , 63 , 115 , false ) ;
8970: LD_VAR 0 1
8974: PPUSH
8975: LD_INT 63
8977: PPUSH
8978: LD_INT 115
8980: PPUSH
8981: LD_INT 0
8983: PPUSH
8984: CALL_OW 48
// SetCargo ( i , mat_cans , 200 ) ;
8988: LD_VAR 0 1
8992: PPUSH
8993: LD_INT 1
8995: PPUSH
8996: LD_INT 200
8998: PPUSH
8999: CALL_OW 290
// PrepareHuman ( false , 3 , 5 ) ;
9003: LD_INT 0
9005: PPUSH
9006: LD_INT 3
9008: PPUSH
9009: LD_INT 5
9011: PPUSH
9012: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9016: CALL_OW 44
9020: PPUSH
9021: LD_VAR 0 1
9025: PPUSH
9026: CALL_OW 52
// DialogueOn ;
9030: CALL_OW 6
// CenterNowOnXY ( 169 , 115 ) ;
9034: LD_INT 169
9036: PPUSH
9037: LD_INT 115
9039: PPUSH
9040: CALL_OW 86
// DWait ( 0 0$01 ) ;
9044: LD_INT 35
9046: PPUSH
9047: CALL_OW 68
// CenterNowOnXY ( 63 , 115 ) ;
9051: LD_INT 63
9053: PPUSH
9054: LD_INT 115
9056: PPUSH
9057: CALL_OW 86
// DWait ( 0 0$01 ) ;
9061: LD_INT 35
9063: PPUSH
9064: CALL_OW 68
// DialogueOff ;
9068: CALL_OW 7
// ComMoveXY ( i , 57 , 53 ) ;
9072: LD_VAR 0 1
9076: PPUSH
9077: LD_INT 57
9079: PPUSH
9080: LD_INT 53
9082: PPUSH
9083: CALL_OW 111
// Wait ( Rand ( 1 1$00 , 4 4$00 ) ) ;
9087: LD_INT 2100
9089: PPUSH
9090: LD_INT 8400
9092: PPUSH
9093: CALL_OW 12
9097: PPUSH
9098: CALL_OW 67
// PlaceUnitXY ( Saseda , 86 , 112 , false ) ;
9102: LD_EXP 17
9106: PPUSH
9107: LD_INT 86
9109: PPUSH
9110: LD_INT 112
9112: PPUSH
9113: LD_INT 0
9115: PPUSH
9116: CALL_OW 48
// Wait ( 0 0$0.3 ) ;
9120: LD_INT 10
9122: PPUSH
9123: CALL_OW 67
// SayRadio ( Saseda , DPM_Sa1 ) ;
9127: LD_EXP 17
9131: PPUSH
9132: LD_STRING DPM_Sa1
9134: PPUSH
9135: CALL_OW 94
// ChangeMissionObjectives ( PM_3 ) ;
9139: LD_STRING PM_3
9141: PPUSH
9142: CALL_OW 337
// end ;
9146: PPOPN 1
9148: END
// every 0 0$01 trigger See ( 3 , Saseda ) do
9149: LD_INT 3
9151: PPUSH
9152: LD_EXP 17
9156: PPUSH
9157: CALL_OW 292
9161: IFFALSE 9210
9163: GO 9165
9165: DISABLE
// begin Say ( Saseda , DPM_Sa2 ) ;
9166: LD_EXP 17
9170: PPUSH
9171: LD_STRING DPM_Sa2
9173: PPUSH
9174: CALL_OW 88
// ChangeMissionObjectives ( PM_4 ) ;
9178: LD_STRING PM_4
9180: PPUSH
9181: CALL_OW 337
// SetTech ( tech_rocket , 3 , state_enabled ) ;
9185: LD_INT 40
9187: PPUSH
9188: LD_INT 3
9190: PPUSH
9191: LD_INT 1
9193: PPUSH
9194: CALL_OW 322
// SetSide ( Saseda , 3 ) ;
9198: LD_EXP 17
9202: PPUSH
9203: LD_INT 3
9205: PPUSH
9206: CALL_OW 235
// end ;
9210: END
// every 16 16$00 trigger not medal1 and FilterAllUnits ( [ f_side , 6 ] ) = 0 do
9211: LD_EXP 3
9215: NOT
9216: PUSH
9217: LD_INT 22
9219: PUSH
9220: LD_INT 6
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: PPUSH
9227: CALL_OW 69
9231: PUSH
9232: LD_INT 0
9234: EQUAL
9235: AND
9236: IFFALSE 9296
9238: GO 9240
9240: DISABLE
// begin Say ( Stolypin , DPM_S3 ) ;
9241: LD_EXP 15
9245: PPUSH
9246: LD_STRING DPM_S3
9248: PPUSH
9249: CALL_OW 88
// PlaceSeeing ( 62 , 113 , 3 , 10 ) ;
9253: LD_INT 62
9255: PPUSH
9256: LD_INT 113
9258: PPUSH
9259: LD_INT 3
9261: PPUSH
9262: LD_INT 10
9264: PPUSH
9265: CALL_OW 330
// CenterOnXY ( 62 , 113 ) ;
9269: LD_INT 62
9271: PPUSH
9272: LD_INT 113
9274: PPUSH
9275: CALL_OW 84
// CounterAttack ;
9279: CALL 5695 0 0
// RemoveSeeing ( 62 , 113 , 3 ) ;
9283: LD_INT 62
9285: PPUSH
9286: LD_INT 113
9288: PPUSH
9289: LD_INT 3
9291: PPUSH
9292: CALL_OW 331
// end ; end_of_file
9296: END
// on LeaveBuilding ( b , h ) do begin if GetSide ( b ) = 1 then
9297: LD_VAR 0 1
9301: PPUSH
9302: CALL_OW 255
9306: PUSH
9307: LD_INT 1
9309: EQUAL
9310: IFFALSE 9346
// if not us_retreat then
9312: LD_EXP 21
9316: NOT
9317: IFFALSE 9346
// if GetClass ( h ) = 1 then
9319: LD_VAR 0 2
9323: PPUSH
9324: CALL_OW 257
9328: PUSH
9329: LD_INT 1
9331: EQUAL
9332: IFFALSE 9346
// ComEnterUnit ( h , us_arm ) ;
9334: LD_VAR 0 2
9338: PPUSH
9339: LD_INT 69
9341: PPUSH
9342: CALL_OW 120
// end ;
9346: PPOPN 2
9348: END
// on UnitDestroyed ( un ) do begin if GetSide ( un ) = 1 then
9349: LD_VAR 0 1
9353: PPUSH
9354: CALL_OW 255
9358: PUSH
9359: LD_INT 1
9361: EQUAL
9362: IFFALSE 9378
// us_count := us_count + 1 ;
9364: LD_ADDR_EXP 23
9368: PUSH
9369: LD_EXP 23
9373: PUSH
9374: LD_INT 1
9376: PLUS
9377: ST_TO_ADDR
// if un in us_force then
9378: LD_VAR 0 1
9382: PUSH
9383: LD_EXP 12
9387: IN
9388: IFFALSE 9406
// us_force := us_force diff un ;
9390: LD_ADDR_EXP 12
9394: PUSH
9395: LD_EXP 12
9399: PUSH
9400: LD_VAR 0 1
9404: DIFF
9405: ST_TO_ADDR
// if un in ar_force then
9406: LD_VAR 0 1
9410: PUSH
9411: LD_EXP 11
9415: IN
9416: IFFALSE 9434
// ar_force := ar_force diff un ;
9418: LD_ADDR_EXP 11
9422: PUSH
9423: LD_EXP 11
9427: PUSH
9428: LD_VAR 0 1
9432: DIFF
9433: ST_TO_ADDR
// if un = Stolypin then
9434: LD_VAR 0 1
9438: PUSH
9439: LD_EXP 15
9443: EQUAL
9444: IFFALSE 9453
// YouLost ( dead ) ;
9446: LD_STRING dead
9448: PPUSH
9449: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_btype , b_depot ] ] ) then
9453: LD_VAR 0 1
9457: PUSH
9458: LD_INT 22
9460: PUSH
9461: LD_INT 1
9463: PUSH
9464: EMPTY
9465: LIST
9466: LIST
9467: PUSH
9468: LD_INT 30
9470: PUSH
9471: LD_INT 0
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: PUSH
9478: EMPTY
9479: LIST
9480: LIST
9481: PPUSH
9482: CALL_OW 69
9486: IN
9487: IFFALSE 9496
// YouLost ( depot ) ;
9489: LD_STRING depot
9491: PPUSH
9492: CALL_OW 104
// if GetSide ( un ) = 6 then
9496: LD_VAR 0 1
9500: PPUSH
9501: CALL_OW 255
9505: PUSH
9506: LD_INT 6
9508: EQUAL
9509: IFFALSE 9525
// dest_counter := dest_counter + 1 ;
9511: LD_ADDR_EXP 8
9515: PUSH
9516: LD_EXP 8
9520: PUSH
9521: LD_INT 1
9523: PLUS
9524: ST_TO_ADDR
// end ;
9525: PPOPN 1
9527: END
// on VehicleConstructed ( un , fac ) do begin if GetSide ( un ) = 1 then
9528: LD_VAR 0 1
9532: PPUSH
9533: CALL_OW 255
9537: PUSH
9538: LD_INT 1
9540: EQUAL
9541: IFFALSE 9558
// ComMoveXY ( un , 57 , 52 ) ;
9543: LD_VAR 0 1
9547: PPUSH
9548: LD_INT 57
9550: PPUSH
9551: LD_INT 52
9553: PPUSH
9554: CALL_OW 111
// end ;
9558: PPOPN 2
9560: END
// on Contact ( s1 , s2 ) do begin if not us_alert then
9561: LD_EXP 20
9565: NOT
9566: IFFALSE 9616
// if ( s1 = 3 and s2 = 1 ) or ( s1 = 1 and s2 = 3 ) then
9568: LD_VAR 0 1
9572: PUSH
9573: LD_INT 3
9575: EQUAL
9576: PUSH
9577: LD_VAR 0 2
9581: PUSH
9582: LD_INT 1
9584: EQUAL
9585: AND
9586: PUSH
9587: LD_VAR 0 1
9591: PUSH
9592: LD_INT 1
9594: EQUAL
9595: PUSH
9596: LD_VAR 0 2
9600: PUSH
9601: LD_INT 3
9603: EQUAL
9604: AND
9605: OR
9606: IFFALSE 9616
// us_alert := true ;
9608: LD_ADDR_EXP 20
9612: PUSH
9613: LD_INT 1
9615: ST_TO_ADDR
// if ( s1 = 6 and s2 = 3 ) or ( s1 = 3 and s2 = 6 ) then
9616: LD_VAR 0 1
9620: PUSH
9621: LD_INT 6
9623: EQUAL
9624: PUSH
9625: LD_VAR 0 2
9629: PUSH
9630: LD_INT 3
9632: EQUAL
9633: AND
9634: PUSH
9635: LD_VAR 0 1
9639: PUSH
9640: LD_INT 3
9642: EQUAL
9643: PUSH
9644: LD_VAR 0 2
9648: PUSH
9649: LD_INT 6
9651: EQUAL
9652: AND
9653: OR
9654: IFFALSE 9663
// YouLost ( alat ) ;
9656: LD_STRING alat
9658: PPUSH
9659: CALL_OW 104
// end ;
9663: PPOPN 2
9665: END
// on DestinationUnreachable ( un ) do begin if GetSide ( un ) = 6 then
9666: LD_VAR 0 1
9670: PPUSH
9671: CALL_OW 255
9675: PUSH
9676: LD_INT 6
9678: EQUAL
9679: IFFALSE 9695
// display_strings := display_strings union Convoy is blocked! ;
9681: LD_ADDR_OWVAR 47
9685: PUSH
9686: LD_OWVAR 47
9690: PUSH
9691: LD_STRING Convoy is blocked!
9693: UNION
9694: ST_TO_ADDR
// end ;
9695: PPOPN 1
9697: END
// on UnitGoesToRed ( un ) do begin if GetSide ( un ) = 2 and un in FilterAllUnits ( [ [ f_empty ] , [ f_type , unit_vehicle ] ] ) then
9698: LD_VAR 0 1
9702: PPUSH
9703: CALL_OW 255
9707: PUSH
9708: LD_INT 2
9710: EQUAL
9711: PUSH
9712: LD_VAR 0 1
9716: PUSH
9717: LD_INT 58
9719: PUSH
9720: EMPTY
9721: LIST
9722: PUSH
9723: LD_INT 21
9725: PUSH
9726: LD_INT 2
9728: PUSH
9729: EMPTY
9730: LIST
9731: LIST
9732: PUSH
9733: EMPTY
9734: LIST
9735: LIST
9736: PPUSH
9737: CALL_OW 69
9741: IN
9742: AND
9743: IFFALSE 9864
// if GetSide ( NearestUnitToUnit ( all_units diff un , un ) ) <> 2 then
9745: LD_OWVAR 3
9749: PUSH
9750: LD_VAR 0 1
9754: DIFF
9755: PPUSH
9756: LD_VAR 0 1
9760: PPUSH
9761: CALL_OW 74
9765: PPUSH
9766: CALL_OW 255
9770: PUSH
9771: LD_INT 2
9773: NONEQUAL
9774: IFFALSE 9864
// begin Wait ( 0 0$1.3 ) ;
9776: LD_INT 46
9778: PPUSH
9779: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9783: LD_VAR 0 1
9787: PPUSH
9788: CALL_OW 250
9792: PPUSH
9793: LD_VAR 0 1
9797: PPUSH
9798: CALL_OW 251
9802: PPUSH
9803: LD_INT 1
9805: PPUSH
9806: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9810: LD_VAR 0 1
9814: PPUSH
9815: CALL_OW 250
9819: PPUSH
9820: LD_VAR 0 1
9824: PPUSH
9825: CALL_OW 251
9829: PPUSH
9830: LD_INT 1
9832: PPUSH
9833: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 1 ) ;
9837: LD_VAR 0 1
9841: PPUSH
9842: CALL_OW 250
9846: PPUSH
9847: LD_VAR 0 1
9851: PPUSH
9852: CALL_OW 251
9856: PPUSH
9857: LD_INT 1
9859: PPUSH
9860: CALL_OW 453
// end ; end ;
9864: PPOPN 1
9866: END
// on EvacuateVehicle ( driver , un , c1 , c2 ) do begin if un in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] ] ) and not GetSide ( NearestUnit ( un ) ) = 2 then
9867: LD_VAR 0 2
9871: PUSH
9872: LD_INT 22
9874: PUSH
9875: LD_INT 2
9877: PUSH
9878: EMPTY
9879: LIST
9880: LIST
9881: PUSH
9882: LD_INT 21
9884: PUSH
9885: LD_INT 2
9887: PUSH
9888: EMPTY
9889: LIST
9890: LIST
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: PPUSH
9896: CALL_OW 69
9900: IN
9901: PUSH
9902: LD_VAR 0 2
9906: PPUSH
9907: CALL 10403 0 1
9911: PPUSH
9912: CALL_OW 255
9916: PUSH
9917: LD_INT 2
9919: EQUAL
9920: NOT
9921: AND
9922: IFFALSE 10047
// begin Wait ( Rand ( 0 0$03 , 0 0$06 ) ) ;
9924: LD_INT 105
9926: PPUSH
9927: LD_INT 210
9929: PPUSH
9930: CALL_OW 12
9934: PPUSH
9935: CALL_OW 67
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9939: LD_VAR 0 2
9943: PPUSH
9944: CALL_OW 250
9948: PPUSH
9949: LD_VAR 0 2
9953: PPUSH
9954: CALL_OW 251
9958: PPUSH
9959: LD_INT 3
9961: PPUSH
9962: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9966: LD_VAR 0 2
9970: PPUSH
9971: CALL_OW 250
9975: PPUSH
9976: LD_VAR 0 2
9980: PPUSH
9981: CALL_OW 251
9985: PPUSH
9986: LD_INT 3
9988: PPUSH
9989: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
9993: LD_VAR 0 2
9997: PPUSH
9998: CALL_OW 250
10002: PPUSH
10003: LD_VAR 0 2
10007: PPUSH
10008: CALL_OW 251
10012: PPUSH
10013: LD_INT 3
10015: PPUSH
10016: CALL_OW 453
// MineExplosion ( GetX ( un ) , GetY ( un ) , 3 ) ;
10020: LD_VAR 0 2
10024: PPUSH
10025: CALL_OW 250
10029: PPUSH
10030: LD_VAR 0 2
10034: PPUSH
10035: CALL_OW 251
10039: PPUSH
10040: LD_INT 3
10042: PPUSH
10043: CALL_OW 453
// end ; end ; end_of_file
10047: PPOPN 4
10049: END
// export function Replace2 ( tab , j , k , value ) ; var i , tmp ; begin
10050: LD_INT 0
10052: PPUSH
10053: PPUSH
10054: PPUSH
// tmp := Replace ( tab [ j ] , k , value ) ;
10055: LD_ADDR_VAR 0 7
10059: PUSH
10060: LD_VAR 0 1
10064: PUSH
10065: LD_VAR 0 2
10069: ARRAY
10070: PPUSH
10071: LD_VAR 0 3
10075: PPUSH
10076: LD_VAR 0 4
10080: PPUSH
10081: CALL_OW 1
10085: ST_TO_ADDR
// tab := Replace ( tab , j , tmp ) ;
10086: LD_ADDR_VAR 0 1
10090: PUSH
10091: LD_VAR 0 1
10095: PPUSH
10096: LD_VAR 0 2
10100: PPUSH
10101: LD_VAR 0 7
10105: PPUSH
10106: CALL_OW 1
10110: ST_TO_ADDR
// result := tab ;
10111: LD_ADDR_VAR 0 5
10115: PUSH
10116: LD_VAR 0 1
10120: ST_TO_ADDR
// end ;
10121: LD_VAR 0 5
10125: RET
// export function IsDriver ( unit ) ; begin
10126: LD_INT 0
10128: PPUSH
// if unit in FilterAllUnits ( [ f_driving ] ) then
10129: LD_VAR 0 1
10133: PUSH
10134: LD_INT 55
10136: PUSH
10137: EMPTY
10138: LIST
10139: PPUSH
10140: CALL_OW 69
10144: IN
10145: IFFALSE 10164
// result := IsInUnit ( unit ) else
10147: LD_ADDR_VAR 0 2
10151: PUSH
10152: LD_VAR 0 1
10156: PPUSH
10157: CALL_OW 310
10161: ST_TO_ADDR
10162: GO 10172
// result := false ;
10164: LD_ADDR_VAR 0 2
10168: PUSH
10169: LD_INT 0
10171: ST_TO_ADDR
// end ;
10172: LD_VAR 0 2
10176: RET
// export function GetDriver ( veh ) ; var i , filter ; begin
10177: LD_INT 0
10179: PPUSH
10180: PPUSH
10181: PPUSH
// if not GetControl ( veh ) = control_manual then
10182: LD_VAR 0 1
10186: PPUSH
10187: CALL_OW 263
10191: PUSH
10192: LD_INT 1
10194: EQUAL
10195: NOT
10196: IFFALSE 10208
// result := false else
10198: LD_ADDR_VAR 0 2
10202: PUSH
10203: LD_INT 0
10205: ST_TO_ADDR
10206: GO 10353
// if veh in FilterAllUnits ( [ f_empty ] ) then
10208: LD_VAR 0 1
10212: PUSH
10213: LD_INT 58
10215: PUSH
10216: EMPTY
10217: LIST
10218: PPUSH
10219: CALL_OW 69
10223: IN
10224: IFFALSE 10236
// result := false else
10226: LD_ADDR_VAR 0 2
10230: PUSH
10231: LD_INT 0
10233: ST_TO_ADDR
10234: GO 10353
// begin filter := FilterAllUnits ( [ [ f_side , GetSide ( veh ) ] , [ f_driving ] ] ) ;
10236: LD_ADDR_VAR 0 4
10240: PUSH
10241: LD_INT 22
10243: PUSH
10244: LD_VAR 0 1
10248: PPUSH
10249: CALL_OW 255
10253: PUSH
10254: EMPTY
10255: LIST
10256: LIST
10257: PUSH
10258: LD_INT 55
10260: PUSH
10261: EMPTY
10262: LIST
10263: PUSH
10264: EMPTY
10265: LIST
10266: LIST
10267: PPUSH
10268: CALL_OW 69
10272: ST_TO_ADDR
// if not filter then
10273: LD_VAR 0 4
10277: NOT
10278: IFFALSE 10290
// result := false else
10280: LD_ADDR_VAR 0 2
10284: PUSH
10285: LD_INT 0
10287: ST_TO_ADDR
10288: GO 10353
// for i = 1 to filter do
10290: LD_ADDR_VAR 0 3
10294: PUSH
10295: DOUBLE
10296: LD_INT 1
10298: DEC
10299: ST_TO_ADDR
10300: LD_VAR 0 4
10304: PUSH
10305: FOR_TO
10306: IFFALSE 10351
// if IsDriver ( filter [ i ] ) = veh then
10308: LD_VAR 0 4
10312: PUSH
10313: LD_VAR 0 3
10317: ARRAY
10318: PPUSH
10319: CALL 10126 0 1
10323: PUSH
10324: LD_VAR 0 1
10328: EQUAL
10329: IFFALSE 10349
// begin result := filter [ i ] ;
10331: LD_ADDR_VAR 0 2
10335: PUSH
10336: LD_VAR 0 4
10340: PUSH
10341: LD_VAR 0 3
10345: ARRAY
10346: ST_TO_ADDR
// break ;
10347: GO 10351
// end ;
10349: GO 10305
10351: POP
10352: POP
// end ; end ;
10353: LD_VAR 0 2
10357: RET
// export function FindTarget ( unit ) ; begin
10358: LD_INT 0
10360: PPUSH
// result := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( unit ) ] ) , unit ) ;
10361: LD_ADDR_VAR 0 2
10365: PUSH
10366: LD_INT 81
10368: PUSH
10369: LD_VAR 0 1
10373: PPUSH
10374: CALL_OW 255
10378: PUSH
10379: EMPTY
10380: LIST
10381: LIST
10382: PPUSH
10383: CALL_OW 69
10387: PPUSH
10388: LD_VAR 0 1
10392: PPUSH
10393: CALL_OW 74
10397: ST_TO_ADDR
// end ;
10398: LD_VAR 0 2
10402: RET
// export function NearestUnit ( unit ) ; begin
10403: LD_INT 0
10405: PPUSH
// result := NearestUnitToUnit ( all_units diff unit , unit ) ;
10406: LD_ADDR_VAR 0 2
10410: PUSH
10411: LD_OWVAR 3
10415: PUSH
10416: LD_VAR 0 1
10420: DIFF
10421: PPUSH
10422: LD_VAR 0 1
10426: PPUSH
10427: CALL_OW 74
10431: ST_TO_ADDR
// end ; end_of_file
10432: LD_VAR 0 2
10436: RET
// every 12 12$00 do
10437: GO 10439
10439: DISABLE
// begin SetWeather ( 1 , 210 , 110 ) ;
10440: LD_INT 1
10442: PPUSH
10443: LD_INT 210
10445: PPUSH
10446: LD_INT 110
10448: PPUSH
10449: CALL_OW 550
// Wait ( Rand ( 5 5$00 , 10 10$00 ) ) ;
10453: LD_INT 10500
10455: PPUSH
10456: LD_INT 21000
10458: PPUSH
10459: CALL_OW 12
10463: PPUSH
10464: CALL_OW 67
// SetWeather ( 0 , 210 , 110 ) ;
10468: LD_INT 0
10470: PPUSH
10471: LD_INT 210
10473: PPUSH
10474: LD_INT 110
10476: PPUSH
10477: CALL_OW 550
// end ;
10481: END
// export function PrepareAnimals ( num1 , num2 , num3 , area ) ; var l , apeman , tiger , bird ; begin
10482: LD_INT 0
10484: PPUSH
10485: PPUSH
10486: PPUSH
10487: PPUSH
10488: PPUSH
// uc_nation = nation_nature ;
10489: LD_ADDR_OWVAR 21
10493: PUSH
10494: LD_INT 0
10496: ST_TO_ADDR
// uc_side = 0 ;
10497: LD_ADDR_OWVAR 20
10501: PUSH
10502: LD_INT 0
10504: ST_TO_ADDR
// l = 0 ;
10505: LD_ADDR_VAR 0 6
10509: PUSH
10510: LD_INT 0
10512: ST_TO_ADDR
// repeat begin uc_direction = Rand ( 0 , 5 ) ;
10513: LD_ADDR_OWVAR 24
10517: PUSH
10518: LD_INT 0
10520: PPUSH
10521: LD_INT 5
10523: PPUSH
10524: CALL_OW 12
10528: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 5 ) ;
10529: LD_ADDR_OWVAR 35
10533: PUSH
10534: LD_INT 5
10536: NEG
10537: PPUSH
10538: LD_INT 5
10540: PPUSH
10541: CALL_OW 12
10545: ST_TO_ADDR
// hc_gallery =  ;
10546: LD_ADDR_OWVAR 33
10550: PUSH
10551: LD_STRING 
10553: ST_TO_ADDR
// hc_class = class_apeman ;
10554: LD_ADDR_OWVAR 28
10558: PUSH
10559: LD_INT 12
10561: ST_TO_ADDR
// hc_attr = [ Rand ( 11 , 13 ) , Rand ( 10 , 11 ) ] ;
10562: LD_ADDR_OWVAR 29
10566: PUSH
10567: LD_INT 11
10569: PPUSH
10570: LD_INT 13
10572: PPUSH
10573: CALL_OW 12
10577: PUSH
10578: LD_INT 10
10580: PPUSH
10581: LD_INT 11
10583: PPUSH
10584: CALL_OW 12
10588: PUSH
10589: EMPTY
10590: LIST
10591: LIST
10592: ST_TO_ADDR
// hc_sex = sex_male ;
10593: LD_ADDR_OWVAR 27
10597: PUSH
10598: LD_INT 1
10600: ST_TO_ADDR
// hc_skills = [ Rand ( 0 , 2 ) , 0 , 0 , 0 ] ;
10601: LD_ADDR_OWVAR 31
10605: PUSH
10606: LD_INT 0
10608: PPUSH
10609: LD_INT 2
10611: PPUSH
10612: CALL_OW 12
10616: PUSH
10617: LD_INT 0
10619: PUSH
10620: LD_INT 0
10622: PUSH
10623: LD_INT 0
10625: PUSH
10626: EMPTY
10627: LIST
10628: LIST
10629: LIST
10630: LIST
10631: ST_TO_ADDR
// apeman = CreateHuman ;
10632: LD_ADDR_VAR 0 7
10636: PUSH
10637: CALL_OW 44
10641: ST_TO_ADDR
// PlaceUnitArea ( apeman , area , false ) ;
10642: LD_VAR 0 7
10646: PPUSH
10647: LD_VAR 0 4
10651: PPUSH
10652: LD_INT 0
10654: PPUSH
10655: CALL_OW 49
// l = l + 1 ;
10659: LD_ADDR_VAR 0 6
10663: PUSH
10664: LD_VAR 0 6
10668: PUSH
10669: LD_INT 1
10671: PLUS
10672: ST_TO_ADDR
// end until l = num1 ;
10673: LD_VAR 0 6
10677: PUSH
10678: LD_VAR 0 1
10682: EQUAL
10683: IFFALSE 10513
// l = 0 ;
10685: LD_ADDR_VAR 0 6
10689: PUSH
10690: LD_INT 0
10692: ST_TO_ADDR
// repeat begin hc_agressivity = Rand ( 0 , 25 ) ;
10693: LD_ADDR_OWVAR 35
10697: PUSH
10698: LD_INT 0
10700: PPUSH
10701: LD_INT 25
10703: PPUSH
10704: CALL_OW 12
10708: ST_TO_ADDR
// hc_class = class_tiger ;
10709: LD_ADDR_OWVAR 28
10713: PUSH
10714: LD_INT 14
10716: ST_TO_ADDR
// hc_sex = sex_male ;
10717: LD_ADDR_OWVAR 27
10721: PUSH
10722: LD_INT 1
10724: ST_TO_ADDR
// hc_gallery = sandnature ;
10725: LD_ADDR_OWVAR 33
10729: PUSH
10730: LD_STRING sandnature
10732: ST_TO_ADDR
// hc_face_number = 3 ;
10733: LD_ADDR_OWVAR 34
10737: PUSH
10738: LD_INT 3
10740: ST_TO_ADDR
// tiger = CreateHuman ;
10741: LD_ADDR_VAR 0 8
10745: PUSH
10746: CALL_OW 44
10750: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
10751: LD_VAR 0 8
10755: PPUSH
10756: LD_VAR 0 4
10760: PPUSH
10761: LD_INT 0
10763: PPUSH
10764: CALL_OW 49
// l = l + 1 ;
10768: LD_ADDR_VAR 0 6
10772: PUSH
10773: LD_VAR 0 6
10777: PUSH
10778: LD_INT 1
10780: PLUS
10781: ST_TO_ADDR
// end until l = num2 ;
10782: LD_VAR 0 6
10786: PUSH
10787: LD_VAR 0 2
10791: EQUAL
10792: IFFALSE 10693
// l = 0 ;
10794: LD_ADDR_VAR 0 6
10798: PUSH
10799: LD_INT 0
10801: ST_TO_ADDR
// repeat begin hc_class = class_phororhacos ;
10802: LD_ADDR_OWVAR 28
10806: PUSH
10807: LD_INT 18
10809: ST_TO_ADDR
// hc_gallery = sandnature ;
10810: LD_ADDR_OWVAR 33
10814: PUSH
10815: LD_STRING sandnature
10817: ST_TO_ADDR
// hc_face_number = 1 ;
10818: LD_ADDR_OWVAR 34
10822: PUSH
10823: LD_INT 1
10825: ST_TO_ADDR
// bird = CreateHuman ;
10826: LD_ADDR_VAR 0 9
10830: PUSH
10831: CALL_OW 44
10835: ST_TO_ADDR
// PlaceUnitAnywhere ( bird , false ) ;
10836: LD_VAR 0 9
10840: PPUSH
10841: LD_INT 0
10843: PPUSH
10844: CALL_OW 51
// l = l + 1 ;
10848: LD_ADDR_VAR 0 6
10852: PUSH
10853: LD_VAR 0 6
10857: PUSH
10858: LD_INT 1
10860: PLUS
10861: ST_TO_ADDR
// end until l = num3 ;
10862: LD_VAR 0 6
10866: PUSH
10867: LD_VAR 0 3
10871: EQUAL
10872: IFFALSE 10802
// end ;
10874: LD_VAR 0 5
10878: RET
